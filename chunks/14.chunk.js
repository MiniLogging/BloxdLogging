"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[14],{12706:(K,A,T)=>{T.d(A,{c:()=>f,e:()=>L,h:()=>G,k:()=>B});const G=1/2.2,B=2.2,L=(1+Math.sqrt(5))/2,f=.001},12716:(K,A,T)=>{function G(K){return parseInt(K.toString().replace(/\W/g,""))}function B(K,A){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(K-A)<=T}function L(K,A,T){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return K<A-G||K>T+G}function f(K,A){return K===A?K:Math.random()*(A-K)+K}function O(K,A,T){return K+(A-K)*T}function C(K,A,T){let G=F(A-K,360);return G>180&&(G-=360),K+G*x(T)}function Q(K,A,T){let G=0;return G=K!=A?x((T-K)/(A-K)):0,G}function Y(K,A,T,G,B){const L=B*B,f=B*L;return K*(2*f-3*L+1)+T*(-2*f+3*L)+A*(f-2*L+B)+G*(f-L)}function Z(K,A,T,G,B){const L=B*B;return 6*(L-B)*K+(3*L-4*B+1)*A+6*(-L+B)*T+(3*L-2*B)*G}function x(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(T,Math.max(A,K))}function J(K){return K-=2*Math.PI*Math.floor((K+Math.PI)/(2*Math.PI))}function b(K){const A=K.toString(16);return K<=15?("0"+A).toUpperCase():A.toUpperCase()}function P(K){if(Math.log2)return Math.floor(Math.log2(K));if(K<0)return NaN;if(0===K)return-1/0;let A=0;if(K<1){for(;K<1;)A++,K*=2;A=-A}else if(K>1)for(;K>1;)A++,K=Math.floor(K/2);return A}function F(K,A){return K-Math.floor(K/A)*A}function d(K,A,T){return(K-A)/(T-A)}function N(K,A,T){return K*(T-A)+A}function D(K,A){let T=F(A-K,360);return T>180&&(T-=360),T}function mK(K,A){const T=F(K,2*A);return A-Math.abs(T-A)}function U(K,A,T){let G=x(T);return G=-2*G*G*G+3*G*G,A*G+K*(1-G)}function z(K,A,T){let G=0;return G=Math.abs(A-K)<=T?A:K+Math.sign(A-K)*T,G}function g(K,A,T){const G=D(K,A);let B=0;return B=-T<G&&G<T?A:z(K,A=K+G,T),B}function S(K,A,T){return(K-A)/(T-A)}function l(K,A,T){return(T-A)*K+A}function u(K,A){const T=K%A;return 0===T?A:u(A,T)}T.r(A),T.d(A,{Clamp:()=>x,DeltaAngle:()=>D,Denormalize:()=>N,ExtractAsInt:()=>G,Hermite:()=>Y,Hermite1stDerivative:()=>Z,HighestCommonFactor:()=>u,ILog2:()=>P,InverseLerp:()=>Q,Lerp:()=>O,LerpAngle:()=>C,MoveTowards:()=>z,MoveTowardsAngle:()=>g,Normalize:()=>d,NormalizeRadians:()=>J,OutsideRange:()=>L,PercentToRange:()=>l,PingPong:()=>mK,RandomRange:()=>f,RangeToPercent:()=>S,Repeat:()=>F,SmoothStep:()=>U,ToHex:()=>b,WithinEpsilon:()=>B})},12700:(K,A,T)=>{T.r(A),T.d(A,{Matrix:()=>N,Quaternion:()=>d,TmpVectors:()=>mK,Vector2:()=>b,PA:()=>P,Vector4:()=>F});var G=T(12706),B=T(12714),L=T(12651),f=T(12629),O=T(12565),C=T(12716);class Q{}function Y(K,A,T){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const B=K.kf(),L=A.kf(),f=B[0],O=B[1],C=B[2],Q=B[3],Y=B[4],Z=B[5],x=B[6],J=B[7],b=B[8],P=B[9],F=B[10],d=B[11],N=B[12],D=B[13],mK=B[14],U=B[15],z=L[0],g=L[1],S=L[2],l=L[3],u=L[4],c=L[5],n=L[6],H=L[7],e=L[8],p=L[9],r=L[10],h=L[11],k=L[12],s=L[13],j=L[14],R=L[15];T[G]=f*z+O*u+C*e+Q*k,T[G+1]=f*g+O*c+C*p+Q*s,T[G+2]=f*S+O*n+C*r+Q*j,T[G+3]=f*l+O*H+C*h+Q*R,T[G+4]=Y*z+Z*u+x*e+J*k,T[G+5]=Y*g+Z*c+x*p+J*s,T[G+6]=Y*S+Z*n+x*r+J*j,T[G+7]=Y*l+Z*H+x*h+J*R,T[G+8]=b*z+P*u+F*e+d*k,T[G+9]=b*g+P*c+F*p+d*s,T[G+10]=b*S+P*n+F*r+d*j,T[G+11]=b*l+P*H+F*h+d*R,T[G+12]=N*z+D*u+mK*e+U*k,T[G+13]=N*g+D*c+mK*p+U*s,T[G+14]=N*S+D*n+mK*r+U*j,T[G+15]=N*l+D*H+mK*h+U*R}function Z(K,A){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const G=K.kf();A[T]=G[0],A[T+1]=G[1],A[T+2]=G[2],A[T+3]=G[3],A[T+4]=G[4],A[T+5]=G[5],A[T+6]=G[6],A[T+7]=G[7],A[T+8]=G[8],A[T+9]=G[9],A[T+10]=G[10],A[T+11]=G[11],A[T+12]=G[12],A[T+13]=G[13],A[T+14]=G[14],A[T+15]=G[15]}function x(K,A){const T=K.kf(),G=T[0],B=T[1],L=T[2],f=T[3],O=T[4],C=T[5],Q=T[6],Y=T[7],Z=T[8],x=T[9],J=T[10],b=T[11],P=T[12],F=T[13],d=T[14],N=T[15],D=J*N-d*b,mK=x*N-F*b,U=x*d-F*J,z=Z*N-P*b,g=Z*d-J*P,S=Z*F-P*x,l=+(C*D-Q*mK+Y*U),u=-(O*D-Q*z+Y*g),c=+(O*mK-C*z+Y*S),n=-(O*U-C*g+Q*S),H=G*l+B*u+L*c+f*n;if(0===H)return!1;const e=1/H,p=Q*N-d*Y,r=C*N-F*Y,h=C*d-F*Q,k=O*N-P*Y,s=O*d-P*Q,j=O*F-P*C,R=Q*b-J*Y,v=C*b-x*Y,I=C*J-x*Q,o=O*b-Z*Y,W=O*J-Z*Q,i=O*x-Z*C,V=-(B*D-L*mK+f*U),X=+(G*D-L*z+f*g),q=-(G*mK-B*z+f*S),y=+(G*U-B*g+L*S),w=+(B*p-L*r+f*h),a=-(G*p-L*k+f*s),M=+(G*r-B*k+f*j),E=-(G*h-B*s+L*j),t=-(B*R-L*v+f*I),KK=+(G*R-L*o+f*W),AK=-(G*v-B*o+f*i),TK=+(G*I-B*W+L*i);return A[0]=l*e,A[1]=V*e,A[2]=w*e,A[3]=t*e,A[4]=u*e,A[5]=X*e,A[6]=a*e,A[7]=KK*e,A[8]=c*e,A[9]=q*e,A[10]=M*e,A[11]=AK*e,A[12]=n*e,A[13]=y*e,A[14]=E*e,A[15]=TK*e,!0}Q._UpdateFlagSeed=0;const J=K=>parseInt(K.toString().replace(/\W/g,""));class b{constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=K,this.y=A}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let K=J(this.x);return K=397*K^J(this.y),K}toArray(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[A]=this.x,K[A+1]=this.y,this}bT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b.FromArrayToRef(K,A,this),this}kf(){return[this.x,this.y]}G(K){return this.x=K.x,this.y=K.y,this}RO(K,A){return this.x=K,this.y=A,this}set(K,A){return this.RO(K,A)}IO(K){return this.RO(K,K)}add(K){return new b(this.x+K.x,this.y+K.y)}addToRef(K,A){return A.x=this.x+K.x,A.y=this.y+K.y,A}addInPlace(K){return this.x+=K.x,this.y+=K.y,this}addInPlaceFromFloats(K,A){return this.x+=K,this.y+=A,this}addVector3(K){return new b(this.x+K.x,this.y+K.y)}FA(K){return new b(this.x-K.x,this.y-K.y)}subtractToRef(K,A){return A.x=this.x-K.x,A.y=this.y-K.y,A}DZ(K){return this.x-=K.x,this.y-=K.y,this}multiplyInPlace(K){return this.x*=K.x,this.y*=K.y,this}multiply(K){return new b(this.x*K.x,this.y*K.y)}multiplyToRef(K,A){return A.x=this.x*K.x,A.y=this.y*K.y,A}multiplyByFloats(K,A){return new b(this.x*K,this.y*A)}divide(K){return new b(this.x/K.x,this.y/K.y)}divideToRef(K,A){return A.x=this.x/K.x,A.y=this.y/K.y,A}divideInPlace(K){return this.x=this.x/K.x,this.y=this.y/K.y,this}minimizeInPlace(K){return this.minimizeInPlaceFromFloats(K.x,K.y)}maximizeInPlace(K){return this.maximizeInPlaceFromFloats(K.x,K.y)}minimizeInPlaceFromFloats(K,A){return this.x=Math.min(K,this.x),this.y=Math.min(A,this.y),this}maximizeInPlaceFromFloats(K,A){return this.x=Math.max(K,this.x),this.y=Math.max(A,this.y),this}subtractFromFloats(K,A){return new b(this.x-K,this.y-A)}subtractFromFloatsToRef(K,A,T){return T.x=this.x-K,T.y=this.y-A,T}negate(){return new b(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(K){return K.x=-this.x,K.y=-this.y,K}scaleInPlace(K){return this.x*=K,this.y*=K,this}scale(K){return new b(this.x*K,this.y*K)}scaleToRef(K,A){return A.x=this.x*K,A.y=this.y*K,A}scaleAndAddToRef(K,A){return A.x+=this.x*K,A.y+=this.y*K,A}equals(K){return K&&this.x===K.x&&this.y===K.y}equalsWithEpsilon(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return K&&(0,C.WithinEpsilon)(this.x,K.x,A)&&(0,C.WithinEpsilon)(this.y,K.y,A)}equalsToFloats(K,A){return this.x===K&&this.y===A}floor(){return new b(Math.floor(this.x),Math.floor(this.y))}floorToRef(K){return K.x=Math.floor(this.x),K.y=Math.floor(this.y),K}fract(){return new b(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(K){return K.x=this.x-Math.floor(this.x),K.y=this.y-Math.floor(this.y),K}rotate(K){return this.rotateToRef(K,new b)}rotateToRef(K,A){const T=Math.cos(K),G=Math.sin(K);return A.x=T*this.x-G*this.y,A.y=G*this.x+T*this.y,A}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){const K=new b;return this.normalizeToRef(K),K}normalizeToRef(K){const A=this.length();return 0===A&&(K.x=this.x,K.y=this.y),this.scaleToRef(1/A,K)}clone(){return new b(this.x,this.y)}dot(K){return this.x*K.x+this.y*K.y}static Zero(){return new b(0,0)}static One(){return new b(1,1)}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new b((0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).RO((0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A))}static get ZeroReadOnly(){return b._ZeroReadOnly}static mT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new b(K[A],K[A+1])}static FromArrayToRef(K,A,T){return T.x=K[A],T.y=K[A+1],T}static FromFloatsToRef(K,A,T){return T.RO(K,A),T}static CatmullRom(K,A,T,G,B){const L=B*B,f=B*L,O=.5*(2*A.x+(-K.x+T.x)*B+(2*K.x-5*A.x+4*T.x-G.x)*L+(-K.x+3*A.x-3*T.x+G.x)*f),C=.5*(2*A.y+(-K.y+T.y)*B+(2*K.y-5*A.y+4*T.y-G.y)*L+(-K.y+3*A.y-3*T.y+G.y)*f);return new b(O,C)}static ClampToRef(K,A,T,G){return G.x=(0,C.Clamp)(K.x,A.x,T.x),G.y=(0,C.Clamp)(K.y,A.y,T.y),G}static Clamp(K,A,T){const G=(0,C.Clamp)(K.x,A.x,T.x),B=(0,C.Clamp)(K.y,A.y,T.y);return new b(G,B)}static Hermite(K,A,T,G,B){const L=B*B,f=B*L,O=2*f-3*L+1,C=-2*f+3*L,Q=f-2*L+B,Y=f-L,Z=K.x*O+T.x*C+A.x*Q+G.x*Y,x=K.y*O+T.y*C+A.y*Q+G.y*Y;return new b(Z,x)}static Hermite1stDerivative(K,A,T,G,B){return this.Hermite1stDerivativeToRef(K,A,T,G,B,new b)}static Hermite1stDerivativeToRef(K,A,T,G,B,L){const f=B*B;return L.x=6*(f-B)*K.x+(3*f-4*B+1)*A.x+6*(-f+B)*T.x+(3*f-2*B)*G.x,L.y=6*(f-B)*K.y+(3*f-4*B+1)*A.y+6*(-f+B)*T.y+(3*f-2*B)*G.y,L}static Lerp(K,A,T){return b.LerpToRef(K,A,T,new b)}static LerpToRef(K,A,T,G){return G.x=K.x+(A.x-K.x)*T,G.y=K.y+(A.y-K.y)*T,G}static Dot(K,A){return K.x*A.x+K.y*A.y}static Normalize(K){return b.NormalizeToRef(K,new b)}static NormalizeToRef(K,A){return K.normalizeToRef(A),A}static Minimize(K,A){const T=K.x<A.x?K.x:A.x,G=K.y<A.y?K.y:A.y;return new b(T,G)}static Maximize(K,A){const T=K.x>A.x?K.x:A.x,G=K.y>A.y?K.y:A.y;return new b(T,G)}static Transform(K,A){return b.TransformToRef(K,A,new b)}static TransformToRef(K,A,T){const G=A.m,B=K.x*G[0]+K.y*G[4]+G[12],L=K.x*G[1]+K.y*G[5]+G[13];return T.x=B,T.y=L,T}static PointInTriangle(K,A,T,G){const B=.5*(-T.y*G.x+A.y*(-T.x+G.x)+A.x*(T.y-G.y)+T.x*G.y),L=B<0?-1:1,f=(A.y*G.x-A.x*G.y+(G.y-A.y)*K.x+(A.x-G.x)*K.y)*L,O=(A.x*T.y-A.y*T.x+(A.y-T.y)*K.x+(T.x-A.x)*K.y)*L;return f>0&&O>0&&f+O<2*B*L}static Distance(K,A){return Math.sqrt(b.DistanceSquared(K,A))}static DistanceSquared(K,A){const T=K.x-A.x,G=K.y-A.y;return T*T+G*G}static Center(K,A){return b.CenterToRef(K,A,new b)}static CenterToRef(K,A,T){return T.RO((K.x+A.x)/2,(K.y+A.y)/2)}static DistanceOfPointFromSegment(K,A,T){const G=b.DistanceSquared(A,T);if(0===G)return b.Distance(K,A);const B=T.FA(A),L=Math.max(0,Math.min(1,b.Dot(K.FA(A),B)/G)),f=A.add(B.multiplyByFloats(L,L));return b.Distance(K,f)}}b._V8PerformanceHack=new b(.5,.5),b._ZeroReadOnly=b.Zero(),Object.defineProperties(b.prototype,{dimension:{value:[2]},rank:{value:1}});class P{get x(){return this._x}set x(K){this._x=K,this._isDirty=!0}get y(){return this._y}set y(K){this._y=K,this._isDirty=!0}get z(){return this._z}set z(K){this._z=K,this._isDirty=!0}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=K,this._y=A,this._z=T}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"PA"}getHashCode(){let K=J(this._x);return K=397*K^J(this._y),K=397*K^J(this._z),K}kf(){return[this._x,this._y,this._z]}toArray(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[A]=this._x,K[A+1]=this._y,K[A+2]=this._z,this}bT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(K,A,this),this}toQuaternion(){return d.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(K){return this._x+=K._x,this._y+=K._y,this._z+=K._z,this._isDirty=!0,this}addInPlaceFromFloats(K,A,T){return this._x+=K,this._y+=A,this._z+=T,this._isDirty=!0,this}add(K){return new P(this._x+K._x,this._y+K._y,this._z+K._z)}addToRef(K,A){return A._x=this._x+K._x,A._y=this._y+K._y,A._z=this._z+K._z,A._isDirty=!0,A}DZ(K){return this._x-=K._x,this._y-=K._y,this._z-=K._z,this._isDirty=!0,this}FA(K){return new P(this._x-K._x,this._y-K._y,this._z-K._z)}subtractToRef(K,A){return this.subtractFromFloatsToRef(K._x,K._y,K._z,A)}subtractFromFloats(K,A,T){return new P(this._x-K,this._y-A,this._z-T)}subtractFromFloatsToRef(K,A,T,G){return G._x=this._x-K,G._y=this._y-A,G._z=this._z-T,G._isDirty=!0,G}negate(){return new P(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(K){return K._x=-1*this._x,K._y=-1*this._y,K._z=-1*this._z,K._isDirty=!0,K}scaleInPlace(K){return this._x*=K,this._y*=K,this._z*=K,this._isDirty=!0,this}scale(K){return new P(this._x*K,this._y*K,this._z*K)}scaleToRef(K,A){return A._x=this._x*K,A._y=this._y*K,A._z=this._z*K,A._isDirty=!0,A}getNormalToRef(K){const A=this.length();let T=Math.acos(this._y/A);const G=Math.atan2(this._z,this._x);T>Math.PI/2?T-=Math.PI/2:T+=Math.PI/2;const B=A*Math.sin(T)*Math.cos(G),L=A*Math.cos(T),f=A*Math.sin(T)*Math.sin(G);return K.set(B,L,f),K}applyRotationQuaternionToRef(K,A){const T=this._x,G=this._y,B=this._z,L=K._x,f=K._y,O=K._z,C=K._w,Q=2*(f*B-O*G),Y=2*(O*T-L*B),Z=2*(L*G-f*T);return A._x=T+C*Q+f*Z-O*Y,A._y=G+C*Y+O*Q-L*Z,A._z=B+C*Z+L*Y-f*Q,A._isDirty=!0,A}applyRotationQuaternionInPlace(K){return this.applyRotationQuaternionToRef(K,this)}applyRotationQuaternion(K){return this.applyRotationQuaternionToRef(K,new P)}scaleAndAddToRef(K,A){return A._x+=this._x*K,A._y+=this._y*K,A._z+=this._z*K,A._isDirty=!0,A}projectOnPlane(K,A){return this.projectOnPlaneToRef(K,A,new P)}projectOnPlaneToRef(K,A,T){const G=K.normal,B=K.d,L=D.PA[0];this.subtractToRef(A,L),L.normalize();const f=P.Dot(L,G);if(Math.abs(f)<1e-10)T.IO(1/0);else{const K=-(P.Dot(A,G)+B)/f,O=L.scaleInPlace(K);A.addToRef(O,T)}return T}equals(K){return K&&this._x===K._x&&this._y===K._y&&this._z===K._z}equalsWithEpsilon(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return K&&(0,C.WithinEpsilon)(this._x,K._x,A)&&(0,C.WithinEpsilon)(this._y,K._y,A)&&(0,C.WithinEpsilon)(this._z,K._z,A)}equalsToFloats(K,A,T){return this._x===K&&this._y===A&&this._z===T}multiplyInPlace(K){return this._x*=K._x,this._y*=K._y,this._z*=K._z,this._isDirty=!0,this}multiply(K){return this.multiplyByFloats(K._x,K._y,K._z)}multiplyToRef(K,A){return A._x=this._x*K._x,A._y=this._y*K._y,A._z=this._z*K._z,A._isDirty=!0,A}multiplyByFloats(K,A,T){return new P(this._x*K,this._y*A,this._z*T)}divide(K){return new P(this._x/K._x,this._y/K._y,this._z/K._z)}divideToRef(K,A){return A._x=this._x/K._x,A._y=this._y/K._y,A._z=this._z/K._z,A._isDirty=!0,A}divideInPlace(K){return this._x=this._x/K._x,this._y=this._y/K._y,this._z=this._z/K._z,this._isDirty=!0,this}minimizeInPlace(K){return this.minimizeInPlaceFromFloats(K._x,K._y,K._z)}maximizeInPlace(K){return this.maximizeInPlaceFromFloats(K._x,K._y,K._z)}minimizeInPlaceFromFloats(K,A,T){return K<this._x&&(this.x=K),A<this._y&&(this.y=A),T<this._z&&(this.z=T),this}maximizeInPlaceFromFloats(K,A,T){return K>this._x&&(this.x=K),A>this._y&&(this.y=A),T>this._z&&(this.z=T),this}isNonUniformWithinEpsilon(K){const A=Math.abs(this._x),T=Math.abs(this._y);if(!(0,C.WithinEpsilon)(A,T,K))return!0;const G=Math.abs(this._z);return!(0,C.WithinEpsilon)(A,G,K)||!(0,C.WithinEpsilon)(T,G,K)}get isNonUniform(){const K=Math.abs(this._x);if(K!==Math.abs(this._y))return!0;return K!==Math.abs(this._z)}floorToRef(K){return K._x=Math.floor(this._x),K._y=Math.floor(this._y),K._z=Math.floor(this._z),K._isDirty=!0,K}floor(){return new P(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(K){return K._x=this._x-Math.floor(this._x),K._y=this._y-Math.floor(this._y),K._z=this._z-Math.floor(this._z),K._isDirty=!0,K}fract(){return new P(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(K){if("xyz"===(K=K.toLowerCase()))return this;const A=D.PA[0].G(this);return this.x=A[K[0]],this.y=A[K[1]],this.z=A[K[2]],this}rotateByQuaternionToRef(K,A){return K.toRotationMatrix(D.Matrix[0]),P.TransformCoordinatesToRef(this,D.Matrix[0],A),A}rotateByQuaternionAroundPointToRef(K,A,T){return this.subtractToRef(A,D.PA[0]),D.PA[0].rotateByQuaternionToRef(K,D.PA[0]),A.addToRef(D.PA[0],T),T}cross(K){return P.CrossToRef(this,K,new P)}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){return this.normalizeToRef(new P)}normalizeToRef(K){const A=this.length();return 0===A||1===A?(K._x=this._x,K._y=this._y,K._z=this._z,K._isDirty=!0,K):this.scaleToRef(1/A,K)}clone(){return new P(this._x,this._y,this._z)}G(K){return this.RO(K._x,K._y,K._z)}RO(K,A,T){return this._x=K,this._y=A,this._z=T,this._isDirty=!0,this}set(K,A,T){return this.RO(K,A,T)}IO(K){return this._x=this._y=this._z=K,this._isDirty=!0,this}static GetClipFactor(K,A,T,G){const B=P.Dot(K,T);return(B-G)/(B-P.Dot(A,T))}static GetAngleBetweenVectors(K,A,T){const G=K.normalizeToRef(D.PA[1]),B=A.normalizeToRef(D.PA[2]);let L=P.Dot(G,B);L=(0,C.Clamp)(L,-1,1);const f=Math.acos(L),O=D.PA[3];return P.CrossToRef(G,B,O),P.Dot(O,T)>0?isNaN(f)?0:f:isNaN(f)?-Math.PI:-Math.acos(L)}static GetAngleBetweenVectorsOnPlane(K,A,T){D.PA[0].G(K);const G=D.PA[0];D.PA[1].G(A);const B=D.PA[1];D.PA[2].G(T);const L=D.PA[2],f=D.PA[3],O=D.PA[4];G.normalize(),B.normalize(),L.normalize(),P.CrossToRef(L,G,f),P.CrossToRef(f,L,O);const Q=Math.atan2(P.Dot(B,f),P.Dot(B,O));return(0,C.NormalizeRadians)(Q)}static PitchYawRollToMoveBetweenPointsToRef(K,A,T){const G=mK.PA[0];return A.subtractToRef(K,G),T._y=Math.atan2(G.x,G.z)||0,T._x=Math.atan2(Math.sqrt(G.x**2+G.z**2),G.y)||0,T._z=0,T._isDirty=!0,T}static PitchYawRollToMoveBetweenPoints(K,A){const T=P.Zero();return P.PitchYawRollToMoveBetweenPointsToRef(K,A,T)}static SlerpToRef(K,A,T,B){T=(0,C.Clamp)(T,0,1);const L=D.PA[0],f=D.PA[1];L.G(K);const O=L.length();L.normalizeFromLength(O),f.G(A);const Q=f.length();f.normalizeFromLength(Q);const Y=P.Dot(L,f);let Z,x;if(Y<1-G.c){const K=Math.acos(Y),A=1/Math.sin(K);Z=Math.sin((1-T)*K)*A,x=Math.sin(T*K)*A}else Z=1-T,x=T;return L.scaleInPlace(Z),f.scaleInPlace(x),B.G(L).addInPlace(f),B.scaleInPlace((0,C.Lerp)(O,Q,T)),B}static SmoothToRef(K,A,T,G,B){return P.SlerpToRef(K,A,0===G?1:T/G,B),B}static mT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new P(K[A],K[A+1],K[A+2])}static FromFloatArray(K,A){return P.mT(K,A)}static FromArrayToRef(K,A,T){return T._x=K[A],T._y=K[A+1],T._z=K[A+2],T._isDirty=!0,T}static FromFloatArrayToRef(K,A,T){return P.FromArrayToRef(K,A,T)}static FromFloatsToRef(K,A,T,G){return G.RO(K,A,T),G}static Zero(){return new P(0,0,0)}static One(){return new P(1,1,1)}static Up(){return new P(0,1,0)}static get UpReadOnly(){return P._UpReadOnly}static get DownReadOnly(){return P._DownReadOnly}static get RightReadOnly(){return P._RightReadOnly}static get LeftReadOnly(){return P._LeftReadOnly}static get LeftHandedForwardReadOnly(){return P._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return P._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return P._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return P._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return P._ZeroReadOnly}static get OneReadOnly(){return P._OneReadOnly}static Down(){return new P(0,-1,0)}static Forward(){return new P(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new P(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new P(1,0,0)}static Left(){return new P(-1,0,0)}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new P((0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).RO((0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A))}static TransformCoordinates(K,A){const T=P.Zero();return P.TransformCoordinatesToRef(K,A,T),T}static TransformCoordinatesToRef(K,A,T){return P.TransformCoordinatesFromFloatsToRef(K._x,K._y,K._z,A,T),T}static TransformCoordinatesFromFloatsToRef(K,A,T,G,B){const L=G.m,f=K*L[0]+A*L[4]+T*L[8]+L[12],O=K*L[1]+A*L[5]+T*L[9]+L[13],C=K*L[2]+A*L[6]+T*L[10]+L[14],Q=1/(K*L[3]+A*L[7]+T*L[11]+L[15]);return B._x=f*Q,B._y=O*Q,B._z=C*Q,B._isDirty=!0,B}static TransformNormal(K,A){const T=P.Zero();return P.TransformNormalToRef(K,A,T),T}static TransformNormalToRef(K,A,T){return this.TransformNormalFromFloatsToRef(K._x,K._y,K._z,A,T),T}static TransformNormalFromFloatsToRef(K,A,T,G,B){const L=G.m;return B._x=K*L[0]+A*L[4]+T*L[8],B._y=K*L[1]+A*L[5]+T*L[9],B._z=K*L[2]+A*L[6]+T*L[10],B._isDirty=!0,B}static CatmullRom(K,A,T,G,B){const L=B*B,f=B*L,O=.5*(2*A._x+(-K._x+T._x)*B+(2*K._x-5*A._x+4*T._x-G._x)*L+(-K._x+3*A._x-3*T._x+G._x)*f),C=.5*(2*A._y+(-K._y+T._y)*B+(2*K._y-5*A._y+4*T._y-G._y)*L+(-K._y+3*A._y-3*T._y+G._y)*f),Q=.5*(2*A._z+(-K._z+T._z)*B+(2*K._z-5*A._z+4*T._z-G._z)*L+(-K._z+3*A._z-3*T._z+G._z)*f);return new P(O,C,Q)}static Clamp(K,A,T){const G=new P;return P.ClampToRef(K,A,T,G),G}static ClampToRef(K,A,T,G){let B=K._x;B=B>T._x?T._x:B,B=B<A._x?A._x:B;let L=K._y;L=L>T._y?T._y:L,L=L<A._y?A._y:L;let f=K._z;return f=f>T._z?T._z:f,f=f<A._z?A._z:f,G.RO(B,L,f),G}static CheckExtends(K,A,T){A.minimizeInPlace(K),T.maximizeInPlace(K)}static Hermite(K,A,T,G,B){const L=B*B,f=B*L,O=2*f-3*L+1,C=-2*f+3*L,Q=f-2*L+B,Y=f-L,Z=K._x*O+T._x*C+A._x*Q+G._x*Y,x=K._y*O+T._y*C+A._y*Q+G._y*Y,J=K._z*O+T._z*C+A._z*Q+G._z*Y;return new P(Z,x,J)}static Hermite1stDerivative(K,A,T,G,B){const L=new P;return this.Hermite1stDerivativeToRef(K,A,T,G,B,L),L}static Hermite1stDerivativeToRef(K,A,T,G,B,L){const f=B*B;return L._x=6*(f-B)*K._x+(3*f-4*B+1)*A._x+6*(-f+B)*T._x+(3*f-2*B)*G._x,L._y=6*(f-B)*K._y+(3*f-4*B+1)*A._y+6*(-f+B)*T._y+(3*f-2*B)*G._y,L._z=6*(f-B)*K._z+(3*f-4*B+1)*A._z+6*(-f+B)*T._z+(3*f-2*B)*G._z,L._isDirty=!0,L}static Lerp(K,A,T){const G=new P(0,0,0);return P.LerpToRef(K,A,T,G),G}static LerpToRef(K,A,T,G){return G._x=K._x+(A._x-K._x)*T,G._y=K._y+(A._y-K._y)*T,G._z=K._z+(A._z-K._z)*T,G._isDirty=!0,G}static Dot(K,A){return K._x*A._x+K._y*A._y+K._z*A._z}dot(K){return this._x*K._x+this._y*K._y+this._z*K._z}static Cross(K,A){const T=new P;return P.CrossToRef(K,A,T),T}static CrossToRef(K,A,T){const G=K._y*A._z-K._z*A._y,B=K._z*A._x-K._x*A._z,L=K._x*A._y-K._y*A._x;return T.RO(G,B,L),T}static Normalize(K){const A=P.Zero();return P.NormalizeToRef(K,A),A}static NormalizeToRef(K,A){return K.normalizeToRef(A),A}static Project(K,A,T,G){const B=new P;return P.ProjectToRef(K,A,T,G,B),B}static ProjectToRef(K,A,T,G,B){var L;const f=G.width,C=G.height,Q=G.x,Y=G.y,Z=D.Matrix[1],x=null===(L=O.b.LastCreatedEngine)||void 0===L?void 0:L.isNDCHalfZRange,J=x?1:.5,b=x?0:.5;N.FromValuesToRef(f/2,0,0,0,0,-C/2,0,0,0,0,J,0,Q+f/2,C/2+Y,b,1,Z);const F=D.Matrix[0];return A.multiplyToRef(T,F),F.multiplyToRef(Z,F),P.TransformCoordinatesToRef(K,F,B),B}static Reflect(K,A){return this.ReflectToRef(K,A,new P)}static ReflectToRef(K,A,T){const G=mK.PA[0];return G.G(A).scaleInPlace(2*P.Dot(K,A)),T.G(K).DZ(G)}static _UnprojectFromInvertedMatrixToRef(K,A,T){P.TransformCoordinatesToRef(K,A,T);const G=A.m,B=K._x*G[3]+K._y*G[7]+K._z*G[11]+G[15];return(0,C.WithinEpsilon)(B,1)&&T.scaleInPlace(1/B),T}static UnprojectFromTransform(K,A,T,G,B){return this.Unproject(K,A,T,G,B,N.IdentityReadOnly)}static Unproject(K,A,T,G,B,L){const f=new P;return P.UnprojectToRef(K,A,T,G,B,L,f),f}static UnprojectToRef(K,A,T,G,B,L,f){return P.UnprojectFloatsToRef(K._x,K._y,K._z,A,T,G,B,L,f),f}static UnprojectFloatsToRef(K,A,T,G,B,L,f,C,Q){var Y;const Z=D.Matrix[0];L.multiplyToRef(f,Z),Z.multiplyToRef(C,Z),Z.invert();const x=D.PA[0];return x.x=K/G*2-1,x.y=-(A/B*2-1),null!==(Y=O.b.LastCreatedEngine)&&void 0!==Y&&Y.isNDCHalfZRange?x.z=T:x.z=2*T-1,P._UnprojectFromInvertedMatrixToRef(x,Z,Q),Q}static Minimize(K,A){const T=new P;return T.G(K),T.minimizeInPlace(A),T}static Maximize(K,A){const T=new P;return T.G(K),T.maximizeInPlace(A),T}static Distance(K,A){return Math.sqrt(P.DistanceSquared(K,A))}static DistanceSquared(K,A){const T=K._x-A._x,G=K._y-A._y,B=K._z-A._z;return T*T+G*G+B*B}static ProjectOnTriangleToRef(K,A,T,B,L){const f=D.PA[0],O=D.PA[1],Q=D.PA[2],Y=D.PA[3],Z=D.PA[4];T.subtractToRef(A,f),B.subtractToRef(A,O),B.subtractToRef(T,Q);const x=f.length(),J=O.length(),b=Q.length();if(x<G.c||J<G.c||b<G.c)return L.G(A),P.Distance(K,A);K.subtractToRef(A,Z),P.CrossToRef(f,O,Y);const F=Y.length();if(F<G.c)return L.G(A),P.Distance(K,A);Y.normalizeFromLength(F);let d=Z.length();if(d<G.c)return L.G(A),0;Z.normalizeFromLength(d);const N=P.Dot(Y,Z),mK=D.PA[5],U=D.PA[6];mK.G(Y).scaleInPlace(-d*N),U.G(K).addInPlace(mK);const z=D.PA[4],g=D.PA[5],S=D.PA[7],l=D.PA[8];z.G(f).scaleInPlace(1/x),l.G(O).scaleInPlace(1/J),z.addInPlace(l).scaleInPlace(-1),g.G(f).scaleInPlace(-1/x),l.G(Q).scaleInPlace(1/b),g.addInPlace(l).scaleInPlace(-1),S.G(Q).scaleInPlace(-1/b),l.G(O).scaleInPlace(-1/J),S.addInPlace(l).scaleInPlace(-1);const u=D.PA[9];let c;u.G(U).DZ(A),P.CrossToRef(z,u,l),c=P.Dot(l,Y);const n=c;u.G(U).DZ(T),P.CrossToRef(g,u,l),c=P.Dot(l,Y);const H=c;u.G(U).DZ(B),P.CrossToRef(S,u,l),c=P.Dot(l,Y);const e=c,p=D.PA[10];let r,h;n>0&&H<0?(p.G(f),r=A,h=T):H>0&&e<0?(p.G(Q),r=T,h=B):(p.G(O).scaleInPlace(-1),r=B,h=A);const k=D.PA[9],s=D.PA[4];r.subtractToRef(U,l),h.subtractToRef(U,k),P.CrossToRef(l,k,s);if(!(P.Dot(s,Y)<0))return L.G(U),Math.abs(d*N);const j=D.PA[5];P.CrossToRef(p,s,j),j.normalize();const R=D.PA[9];R.G(r).DZ(U);const v=R.length();if(v<G.c)return L.G(r),P.Distance(K,r);R.normalizeFromLength(v);const I=P.Dot(j,R),o=D.PA[7];o.G(U).addInPlace(j.scaleInPlace(v*I)),l.G(o).DZ(r),d=p.length(),p.normalizeFromLength(d);let W=P.Dot(l,p)/Math.max(d,G.c);return W=(0,C.Clamp)(W,0,1),o.G(r).addInPlace(p.scaleInPlace(W*d)),L.G(o),P.Distance(K,o)}static Center(K,A){return P.CenterToRef(K,A,P.Zero())}static CenterToRef(K,A,T){return T.RO((K._x+A._x)/2,(K._y+A._y)/2,(K._z+A._z)/2)}static RotationFromAxis(K,A,T){const G=new P;return P.RotationFromAxisToRef(K,A,T,G),G}static RotationFromAxisToRef(K,A,T,G){const B=D.Quaternion[0];return d.RotationQuaternionFromAxisToRef(K,A,T,B),B.toEulerAnglesToRef(G),G}}P._V8PerformanceHack=new P(.5,.5,.5),P._UpReadOnly=P.Up(),P._DownReadOnly=P.Down(),P._LeftHandedForwardReadOnly=P.Forward(!1),P._RightHandedForwardReadOnly=P.Forward(!0),P._LeftHandedBackwardReadOnly=P.Backward(!1),P._RightHandedBackwardReadOnly=P.Backward(!0),P._RightReadOnly=P.Right(),P._LeftReadOnly=P.Left(),P._ZeroReadOnly=P.Zero(),P._OneReadOnly=P.One(),Object.defineProperties(P.prototype,{dimension:{value:[3]},rank:{value:1}});class F{get x(){return this._x}set x(K){this._x=K,this._isDirty=!0}get y(){return this._y}set y(K){this._y=K,this._isDirty=!0}get z(){return this._z}set z(K){this._z=K,this._isDirty=!0}get w(){return this._w}set w(K){this._w=K,this._isDirty=!0}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=K,this._y=A,this._z=T,this._w=G}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let K=J(this._x);return K=397*K^J(this._y),K=397*K^J(this._z),K=397*K^J(this._w),K}kf(){return[this._x,this._y,this._z,this._w]}toArray(K,A){return void 0===A&&(A=0),K[A]=this._x,K[A+1]=this._y,K[A+2]=this._z,K[A+3]=this._w,this}bT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(K,A,this),this}addInPlace(K){return this.x+=K._x,this.y+=K._y,this.z+=K._z,this.w+=K._w,this}addInPlaceFromFloats(K,A,T,G){return this.x+=K,this.y+=A,this.z+=T,this.w+=G,this}add(K){return new F(this._x+K.x,this._y+K.y,this._z+K.z,this._w+K.w)}addToRef(K,A){return A.x=this._x+K.x,A.y=this._y+K.y,A.z=this._z+K.z,A.w=this._w+K.w,A}DZ(K){return this.x-=K.x,this.y-=K.y,this.z-=K.z,this.w-=K.w,this}FA(K){return new F(this._x-K.x,this._y-K.y,this._z-K.z,this._w-K.w)}subtractToRef(K,A){return A.x=this._x-K.x,A.y=this._y-K.y,A.z=this._z-K.z,A.w=this._w-K.w,A}subtractFromFloats(K,A,T,G){return new F(this._x-K,this._y-A,this._z-T,this._w-G)}subtractFromFloatsToRef(K,A,T,G,B){return B.x=this._x-K,B.y=this._y-A,B.z=this._z-T,B.w=this._w-G,B}negate(){return new F(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(K){return K.x=-this._x,K.y=-this._y,K.z=-this._z,K.w=-this._w,K}scaleInPlace(K){return this.x*=K,this.y*=K,this.z*=K,this.w*=K,this}scale(K){return new F(this._x*K,this._y*K,this._z*K,this._w*K)}scaleToRef(K,A){return A.x=this._x*K,A.y=this._y*K,A.z=this._z*K,A.w=this._w*K,A}scaleAndAddToRef(K,A){return A.x+=this._x*K,A.y+=this._y*K,A.z+=this._z*K,A.w+=this._w*K,A}equals(K){return K&&this._x===K.x&&this._y===K.y&&this._z===K.z&&this._w===K.w}equalsWithEpsilon(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return K&&(0,C.WithinEpsilon)(this._x,K.x,A)&&(0,C.WithinEpsilon)(this._y,K.y,A)&&(0,C.WithinEpsilon)(this._z,K.z,A)&&(0,C.WithinEpsilon)(this._w,K.w,A)}equalsToFloats(K,A,T,G){return this._x===K&&this._y===A&&this._z===T&&this._w===G}multiplyInPlace(K){return this.x*=K.x,this.y*=K.y,this.z*=K.z,this.w*=K.w,this}multiply(K){return new F(this._x*K.x,this._y*K.y,this._z*K.z,this._w*K.w)}multiplyToRef(K,A){return A.x=this._x*K.x,A.y=this._y*K.y,A.z=this._z*K.z,A.w=this._w*K.w,A}multiplyByFloats(K,A,T,G){return new F(this._x*K,this._y*A,this._z*T,this._w*G)}divide(K){return new F(this._x/K.x,this._y/K.y,this._z/K.z,this._w/K.w)}divideToRef(K,A){return A.x=this._x/K.x,A.y=this._y/K.y,A.z=this._z/K.z,A.w=this._w/K.w,A}divideInPlace(K){return this.divideToRef(K,this)}minimizeInPlace(K){return K.x<this._x&&(this.x=K.x),K.y<this._y&&(this.y=K.y),K.z<this._z&&(this.z=K.z),K.w<this._w&&(this.w=K.w),this}maximizeInPlace(K){return K.x>this._x&&(this.x=K.x),K.y>this._y&&(this.y=K.y),K.z>this._z&&(this.z=K.z),K.w>this._w&&(this.w=K.w),this}minimizeInPlaceFromFloats(K,A,T,G){return this.x=Math.min(K,this._x),this.y=Math.min(A,this._y),this.z=Math.min(T,this._z),this.w=Math.min(G,this._w),this}maximizeInPlaceFromFloats(K,A,T,G){return this.x=Math.max(K,this._x),this.y=Math.max(A,this._y),this.z=Math.max(T,this._z),this.w=Math.max(G,this._w),this}floorToRef(K){return K.x=Math.floor(this._x),K.y=Math.floor(this._y),K.z=Math.floor(this._z),K.w=Math.floor(this._w),K}floor(){return new F(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(K){return K.x=this._x-Math.floor(this._x),K.y=this._y-Math.floor(this._y),K.z=this._z-Math.floor(this._z),K.w=this._w-Math.floor(this._w),K}fract(){return new F(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){return this.normalizeToRef(new F)}normalizeToRef(K){const A=this.length();return 0===A||1===A?(K.x=this._x,K.y=this._y,K.z=this._z,K.w=this._w,K):this.scaleToRef(1/A,K)}toVector3(){return new P(this._x,this._y,this._z)}clone(){return new F(this._x,this._y,this._z,this._w)}G(K){return this.x=K.x,this.y=K.y,this.z=K.z,this.w=K.w,this}RO(K,A,T,G){return this.x=K,this.y=A,this.z=T,this.w=G,this}set(K,A,T,G){return this.RO(K,A,T,G)}IO(K){return this.x=this.y=this.z=this.w=K,this}dot(K){return this._x*K.x+this._y*K.y+this._z*K.z+this._w*K.w}static mT(K,A){return A||(A=0),new F(K[A],K[A+1],K[A+2],K[A+3])}static FromArrayToRef(K,A,T){return T.x=K[A],T.y=K[A+1],T.z=K[A+2],T.w=K[A+3],T}static FromFloatArrayToRef(K,A,T){return F.FromArrayToRef(K,A,T),T}static FromFloatsToRef(K,A,T,G,B){return B.x=K,B.y=A,B.z=T,B.w=G,B}static Zero(){return new F(0,0,0,0)}static One(){return new F(1,1,1,1)}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F((0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0;return T.x=(0,C.RandomRange)(K,A),T.y=(0,C.RandomRange)(K,A),T.z=(0,C.RandomRange)(K,A),T.w=(0,C.RandomRange)(K,A),T}static Clamp(K,A,T){return F.ClampToRef(K,A,T,new F)}static ClampToRef(K,A,T,G){return G.x=(0,C.Clamp)(K.x,A.x,T.x),G.y=(0,C.Clamp)(K.y,A.y,T.y),G.z=(0,C.Clamp)(K.z,A.z,T.z),G.w=(0,C.Clamp)(K.w,A.w,T.w),G}static CheckExtends(K,A,T){A.minimizeInPlace(K),T.maximizeInPlace(K)}static get ZeroReadOnly(){return F._ZeroReadOnly}static Normalize(K){return F.NormalizeToRef(K,new F)}static NormalizeToRef(K,A){return K.normalizeToRef(A),A}static Minimize(K,A){const T=new F;return T.G(K),T.minimizeInPlace(A),T}static Maximize(K,A){const T=new F;return T.G(K),T.maximizeInPlace(A),T}static Distance(K,A){return Math.sqrt(F.DistanceSquared(K,A))}static DistanceSquared(K,A){const T=K.x-A.x,G=K.y-A.y,B=K.z-A.z,L=K.w-A.w;return T*T+G*G+B*B+L*L}static Center(K,A){return F.CenterToRef(K,A,new F)}static CenterToRef(K,A,T){return T.x=(K.x+A.x)/2,T.y=(K.y+A.y)/2,T.z=(K.z+A.z)/2,T.w=(K.w+A.w)/2,T}static TransformCoordinates(K,A){return F.TransformCoordinatesToRef(K,A,new F)}static TransformCoordinatesToRef(K,A,T){return F.TransformCoordinatesFromFloatsToRef(K._x,K._y,K._z,A,T),T}static TransformCoordinatesFromFloatsToRef(K,A,T,G,B){const L=G.m,f=K*L[0]+A*L[4]+T*L[8]+L[12],O=K*L[1]+A*L[5]+T*L[9]+L[13],C=K*L[2]+A*L[6]+T*L[10]+L[14],Q=K*L[3]+A*L[7]+T*L[11]+L[15];return B.x=f,B.y=O,B.z=C,B.w=Q,B}static TransformNormal(K,A){return F.TransformNormalToRef(K,A,new F)}static TransformNormalToRef(K,A,T){const G=A.m,B=K.x*G[0]+K.y*G[4]+K.z*G[8],L=K.x*G[1]+K.y*G[5]+K.z*G[9],f=K.x*G[2]+K.y*G[6]+K.z*G[10];return T.x=B,T.y=L,T.z=f,T.w=K.w,T}static TransformNormalFromFloatsToRef(K,A,T,G,B,L){const f=B.m;return L.x=K*f[0]+A*f[4]+T*f[8],L.y=K*f[1]+A*f[5]+T*f[9],L.z=K*f[2]+A*f[6]+T*f[10],L.w=G,L}static FromVector3(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(K._x,K._y,K._z,A)}static Dot(K,A){return K.x*A.x+K.y*A.y+K.z*A.z+K.w*A.w}}F._V8PerformanceHack=new F(.5,.5,.5,.5),F._ZeroReadOnly=F.Zero(),Object.defineProperties(F.prototype,{dimension:{value:[4]},rank:{value:1}});class d{get x(){return this._x}set x(K){this._x=K,this._isDirty=!0}get y(){return this._y}set y(K){this._y=K,this._isDirty=!0}get z(){return this._z}set z(K){this._z=K,this._isDirty=!0}get w(){return this._w}set w(K){this._w=K,this._isDirty=!0}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=K,this._y=A,this._z=T,this._w=G}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let K=J(this._x);return K=397*K^J(this._y),K=397*K^J(this._z),K=397*K^J(this._w),K}kf(){return[this._x,this._y,this._z,this._w]}toArray(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[A]=this._x,K[A+1]=this._y,K[A+2]=this._z,K[A+3]=this._w,this}bT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return d.FromArrayToRef(K,A,this)}equals(K){return K&&this._x===K._x&&this._y===K._y&&this._z===K._z&&this._w===K._w}equalsWithEpsilon(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return K&&(0,C.WithinEpsilon)(this._x,K._x,A)&&(0,C.WithinEpsilon)(this._y,K._y,A)&&(0,C.WithinEpsilon)(this._z,K._z,A)&&(0,C.WithinEpsilon)(this._w,K._w,A)}isApprox(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return K&&((0,C.WithinEpsilon)(this._x,K._x,A)&&(0,C.WithinEpsilon)(this._y,K._y,A)&&(0,C.WithinEpsilon)(this._z,K._z,A)&&(0,C.WithinEpsilon)(this._w,K._w,A)||(0,C.WithinEpsilon)(this._x,-K._x,A)&&(0,C.WithinEpsilon)(this._y,-K._y,A)&&(0,C.WithinEpsilon)(this._z,-K._z,A)&&(0,C.WithinEpsilon)(this._w,-K._w,A))}clone(){return new d(this._x,this._y,this._z,this._w)}G(K){return this._x=K._x,this._y=K._y,this._z=K._z,this._w=K._w,this._isDirty=!0,this}RO(K,A,T,G){return this._x=K,this._y=A,this._z=T,this._w=G,this._isDirty=!0,this}set(K,A,T,G){return this.RO(K,A,T,G)}IO(K){return this.RO(K,K,K,K)}add(K){return new d(this._x+K._x,this._y+K._y,this._z+K._z,this._w+K._w)}addInPlace(K){return this._x+=K._x,this._y+=K._y,this._z+=K._z,this._w+=K._w,this._isDirty=!0,this}addToRef(K,A){return A._x=this._x+K._x,A._y=this._y+K._y,A._z=this._z+K._z,A._w=this._w+K._w,A._isDirty=!0,A}addInPlaceFromFloats(K,A,T,G){return this._x+=K,this._y+=A,this._z+=T,this._w+=G,this._isDirty=!0,this}subtractToRef(K,A){return A._x=this._x-K._x,A._y=this._y-K._y,A._z=this._z-K._z,A._w=this._w-K._w,A._isDirty=!0,A}subtractFromFloats(K,A,T,G){return this.subtractFromFloatsToRef(K,A,T,G,new d)}subtractFromFloatsToRef(K,A,T,G,B){return B._x=this._x-K,B._y=this._y-A,B._z=this._z-T,B._w=this._w-G,B._isDirty=!0,B}FA(K){return new d(this._x-K._x,this._y-K._y,this._z-K._z,this._w-K._w)}DZ(K){return this._x-=K._x,this._y-=K._y,this._z-=K._z,this._w-=K._w,this._isDirty=!0,this}scale(K){return new d(this._x*K,this._y*K,this._z*K,this._w*K)}scaleToRef(K,A){return A._x=this._x*K,A._y=this._y*K,A._z=this._z*K,A._w=this._w*K,A._isDirty=!0,A}scaleInPlace(K){return this._x*=K,this._y*=K,this._z*=K,this._w*=K,this._isDirty=!0,this}scaleAndAddToRef(K,A){return A._x+=this._x*K,A._y+=this._y*K,A._z+=this._z*K,A._w+=this._w*K,A._isDirty=!0,A}multiply(K){const A=new d(0,0,0,1);return this.multiplyToRef(K,A),A}multiplyToRef(K,A){const T=this._x*K._w+this._y*K._z-this._z*K._y+this._w*K._x,G=-this._x*K._z+this._y*K._w+this._z*K._x+this._w*K._y,B=this._x*K._y-this._y*K._x+this._z*K._w+this._w*K._z,L=-this._x*K._x-this._y*K._y-this._z*K._z+this._w*K._w;return A.RO(T,G,B,L),A}multiplyInPlace(K){return this.multiplyToRef(K,this)}multiplyByFloats(K,A,T,G){return this._x*=K,this._y*=A,this._z*=T,this._w*=G,this._isDirty=!0,this}divide(K){throw new ReferenceError("Can not divide a quaternion")}divideToRef(K,A){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(K){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new d)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(K){return K._x=-this._x,K._y=-this._y,K._z=-this._z,K._w=-this._w,K._isDirty=!0,K}equalsToFloats(K,A,T,G){return this._x===K&&this._y===A&&this._z===T&&this._w===G}floorToRef(K){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(K){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(K){return K.RO(-this._x,-this._y,-this._z,this._w),K}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new d(-this._x,-this._y,-this._z,this._w)}invert(){const K=this.conjugate(),A=this.lengthSquared();return 0==A||1==A||K.scaleInPlace(1/A),K}invertInPlace(){this.conjugateInPlace();const K=this.lengthSquared();return 0==K||1==K||this.scaleInPlace(1/K),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){const K=new d(0,0,0,1);return this.normalizeToRef(K),K}normalizeToRef(K){const A=this.length();return 0===A||1===A?K.RO(this._x,this._y,this._z,this._w):this.scaleToRef(1/A,K)}toEulerAngles(){const K=P.Zero();return this.toEulerAnglesToRef(K),K}toEulerAnglesToRef(K){const A=this._z,T=this._x,G=this._y,B=this._w,L=G*A-T*B,f=.4999999;if(L<-f)K._y=2*Math.atan2(G,B),K._x=Math.PI/2,K._z=0,K._isDirty=!0;else if(L>f)K._y=2*Math.atan2(G,B),K._x=-Math.PI/2,K._z=0,K._isDirty=!0;else{const f=B*B,O=A*A,C=T*T,Q=G*G;K._z=Math.atan2(2*(T*G+A*B),-O-C+Q+f),K._x=Math.asin(-2*L),K._y=Math.atan2(2*(A*T+G*B),O-C-Q+f),K._isDirty=!0}return K}toAlphaBetaGammaToRef(K){const A=this._z,T=this._x,G=this._y,B=this._w,L=Math.sqrt(T*T+G*G),f=Math.sqrt(A*A+B*B),O=2*Math.atan2(L,f),C=2*Math.atan2(A,B),Q=2*Math.atan2(G,T),Y=(C+Q)/2,Z=(C-Q)/2;return K.set(Z,O,Y),K}toRotationMatrix(K){return N.FromQuaternionToRef(this,K),K}fromRotationMatrix(K){return d.FromRotationMatrixToRef(K,this),this}dot(K){return this._x*K._x+this._y*K._y+this._z*K._z+this._w*K._w}toAxisAngle(){const K=P.Zero();return{axis:K,angle:this.toAxisAngleToRef(K)}}toAxisAngleToRef(K){let A=0;const T=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),G=this._w;return T>0?(A=2*Math.atan2(T,G),K.set(this._x/T,this._y/T,this._z/T)):(A=0,K.set(1,0,0)),A}static FromRotationMatrix(K){const A=new d;return d.FromRotationMatrixToRef(K,A),A}static FromRotationMatrixToRef(K,A){const T=K.m,G=T[0],B=T[4],L=T[8],f=T[1],O=T[5],C=T[9],Q=T[2],Y=T[6],Z=T[10],x=G+O+Z;let J;return x>0?(J=.5/Math.sqrt(x+1),A._w=.25/J,A._x=(Y-C)*J,A._y=(L-Q)*J,A._z=(f-B)*J,A._isDirty=!0):G>O&&G>Z?(J=2*Math.sqrt(1+G-O-Z),A._w=(Y-C)/J,A._x=.25*J,A._y=(B+f)/J,A._z=(L+Q)/J,A._isDirty=!0):O>Z?(J=2*Math.sqrt(1+O-G-Z),A._w=(L-Q)/J,A._x=(B+f)/J,A._y=.25*J,A._z=(C+Y)/J,A._isDirty=!0):(J=2*Math.sqrt(1+Z-G-O),A._w=(f-B)/J,A._x=(L+Q)/J,A._y=(C+Y)/J,A._z=.25*J,A._isDirty=!0),A}static Dot(K,A){return K._x*A._x+K._y*A._y+K._z*A._z+K._w*A._w}static AreClose(K,A){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const G=d.Dot(K,A);return 1-G*G<=T}static SmoothToRef(K,A,T,G,B){let L=0===G?1:T/G;return L=(0,C.Clamp)(L,0,1),d.SlerpToRef(K,A,L,B),B}static Zero(){return new d(0,0,0,0)}static Inverse(K){return new d(-K._x,-K._y,-K._z,K._w)}static InverseToRef(K,A){return A.set(-K._x,-K._y,-K._z,K._w),A}static Identity(){return new d(0,0,0,1)}static IsIdentity(K){return K&&0===K._x&&0===K._y&&0===K._z&&1===K._w}static RotationAxis(K,A){return d.RotationAxisToRef(K,A,new d)}static RotationAxisToRef(K,A,T){T._w=Math.cos(A/2);const G=Math.sin(A/2)/K.length();return T._x=K._x*G,T._y=K._y*G,T._z=K._z*G,T._isDirty=!0,T}static mT(K,A){return A||(A=0),new d(K[A],K[A+1],K[A+2],K[A+3])}static FromArrayToRef(K,A,T){return T._x=K[A],T._y=K[A+1],T._z=K[A+2],T._w=K[A+3],T._isDirty=!0,T}static FromFloatsToRef(K,A,T,G,B){return B.RO(K,A,T,G),B}static FromEulerAngles(K,A,T){const G=new d;return d.RotationYawPitchRollToRef(A,K,T,G),G}static FromEulerAnglesToRef(K,A,T,G){return d.RotationYawPitchRollToRef(A,K,T,G),G}static FromEulerVector(K){const A=new d;return d.RotationYawPitchRollToRef(K._y,K._x,K._z,A),A}static FromEulerVectorToRef(K,A){return d.RotationYawPitchRollToRef(K._y,K._x,K._z,A),A}static FromUnitVectorsToRef(K,A,T){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:G.c;const L=P.Dot(K,A)+1;return L<B?Math.abs(K.x)>Math.abs(K.z)?T.set(-K.y,K.x,0,0):T.set(0,-K.z,K.y,0):(P.CrossToRef(K,A,mK.PA[0]),T.set(mK.PA[0].x,mK.PA[0].y,mK.PA[0].z,L)),T.normalize()}static RotationYawPitchRoll(K,A,T){const G=new d;return d.RotationYawPitchRollToRef(K,A,T,G),G}static RotationYawPitchRollToRef(K,A,T,G){const B=.5*T,L=.5*A,f=.5*K,O=Math.sin(B),C=Math.cos(B),Q=Math.sin(L),Y=Math.cos(L),Z=Math.sin(f),x=Math.cos(f);return G._x=x*Q*C+Z*Y*O,G._y=Z*Y*C-x*Q*O,G._z=x*Y*O-Z*Q*C,G._w=x*Y*C+Z*Q*O,G._isDirty=!0,G}static RotationAlphaBetaGamma(K,A,T){const G=new d;return d.RotationAlphaBetaGammaToRef(K,A,T,G),G}static RotationAlphaBetaGammaToRef(K,A,T,G){const B=.5*(T+K),L=.5*(T-K),f=.5*A;return G._x=Math.cos(L)*Math.sin(f),G._y=Math.sin(L)*Math.sin(f),G._z=Math.sin(B)*Math.cos(f),G._w=Math.cos(B)*Math.cos(f),G._isDirty=!0,G}static RotationQuaternionFromAxis(K,A,T){const G=new d(0,0,0,0);return d.RotationQuaternionFromAxisToRef(K,A,T,G),G}static RotationQuaternionFromAxisToRef(K,A,T,G){const B=D.Matrix[0];return K=K.normalizeToRef(D.PA[0]),A=A.normalizeToRef(D.PA[1]),T=T.normalizeToRef(D.PA[2]),N.FromXYZAxesToRef(K,A,T,B),d.FromRotationMatrixToRef(B,G),G}static FromLookDirectionLH(K,A){const T=new d;return d.FromLookDirectionLHToRef(K,A,T),T}static FromLookDirectionLHToRef(K,A,T){const G=D.Matrix[0];return N.LookDirectionLHToRef(K,A,G),d.FromRotationMatrixToRef(G,T),T}static FromLookDirectionRH(K,A){const T=new d;return d.FromLookDirectionRHToRef(K,A,T),T}static FromLookDirectionRHToRef(K,A,T){const G=D.Matrix[0];return N.LookDirectionRHToRef(K,A,G),d.FromRotationMatrixToRef(G,T)}static Slerp(K,A,T){const G=d.Identity();return d.SlerpToRef(K,A,T,G),G}static SlerpToRef(K,A,T,G){let B,L,f=K._x*A._x+K._y*A._y+K._z*A._z+K._w*A._w,O=!1;if(f<0&&(O=!0,f=-f),f>.999999)L=1-T,B=O?-T:T;else{const K=Math.acos(f),A=1/Math.sin(K);L=Math.sin((1-T)*K)*A,B=O?-Math.sin(T*K)*A:Math.sin(T*K)*A}return G._x=L*K._x+B*A._x,G._y=L*K._y+B*A._y,G._z=L*K._z+B*A._z,G._w=L*K._w+B*A._w,G._isDirty=!0,G}static Hermite(K,A,T,G,B){const L=B*B,f=B*L,O=2*f-3*L+1,C=-2*f+3*L,Q=f-2*L+B,Y=f-L,Z=K._x*O+T._x*C+A._x*Q+G._x*Y,x=K._y*O+T._y*C+A._y*Q+G._y*Y,J=K._z*O+T._z*C+A._z*Q+G._z*Y,b=K._w*O+T._w*C+A._w*Q+G._w*Y;return new d(Z,x,J,b)}static Hermite1stDerivative(K,A,T,G,B){const L=new d;return this.Hermite1stDerivativeToRef(K,A,T,G,B,L),L}static Hermite1stDerivativeToRef(K,A,T,G,B,L){const f=B*B;return L._x=6*(f-B)*K._x+(3*f-4*B+1)*A._x+6*(-f+B)*T._x+(3*f-2*B)*G._x,L._y=6*(f-B)*K._y+(3*f-4*B+1)*A._y+6*(-f+B)*T._y+(3*f-2*B)*G._y,L._z=6*(f-B)*K._z+(3*f-4*B+1)*A._z+6*(-f+B)*T._z+(3*f-2*B)*G._z,L._w=6*(f-B)*K._w+(3*f-4*B+1)*A._w+6*(-f+B)*T._w+(3*f-2*B)*G._w,L._isDirty=!0,L}static Normalize(K){const A=d.Zero();return d.NormalizeToRef(K,A),A}static NormalizeToRef(K,A){return K.normalizeToRef(A),A}static Clamp(K,A,T){const G=new d;return d.ClampToRef(K,A,T,G),G}static ClampToRef(K,A,T,G){return G.RO((0,C.Clamp)(K.x,A.x,T.x),(0,C.Clamp)(K.y,A.y,T.y),(0,C.Clamp)(K.z,A.z,T.z),(0,C.Clamp)(K.w,A.w,T.w))}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new d((0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).RO((0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A),(0,C.RandomRange)(K,A))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(K,A){return Math.sqrt(d.DistanceSquared(K,A))}static DistanceSquared(K,A){const T=K.x-A.x,G=K.y-A.y,B=K.z-A.z,L=K.w-A.w;return T*T+G*G+B*B+L*L}static Center(K,A){return d.CenterToRef(K,A,d.Zero())}static CenterToRef(K,A,T){return T.RO((K.x+A.x)/2,(K.y+A.y)/2,(K.z+A.z)/2,(K.w+A.w)/2)}}d._V8PerformanceHack=new d(.5,.5,.5,.5),Object.defineProperties(d.prototype,{dimension:{value:[4]},rank:{value:1}});class N{static get Use64Bits(){return f.b.MatrixUse64Bits}get m(){return this.zf}markAsUpdated(){this.updateFlag=Q._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(K){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1],T=arguments.length>2&&void 0!==arguments[2]&&arguments[2],G=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=K,this._isIdentity3x2=K||T,this._isIdentityDirty=!this._isIdentity&&A,this._isIdentity3x2Dirty=!this._isIdentity3x2&&G}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,f.b.MatrixTrackPrecisionChange&&f.b.MatrixTrackedMatrices.push(this),this.zf=new f.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const K=this.zf;this._isIdentity=1===K[0]&&0===K[1]&&0===K[2]&&0===K[3]&&0===K[4]&&1===K[5]&&0===K[6]&&0===K[7]&&0===K[8]&&0===K[9]&&1===K[10]&&0===K[11]&&0===K[12]&&0===K[13]&&0===K[14]&&1===K[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.zf[0]||1!==this.zf[5]||1!==this.zf[15]||0!==this.zf[1]||0!==this.zf[2]||0!==this.zf[3]||0!==this.zf[4]||0!==this.zf[6]||0!==this.zf[7]||0!==this.zf[8]||0!==this.zf[9]||0!==this.zf[10]||0!==this.zf[11]||0!==this.zf[12]||0!==this.zf[13]||0!==this.zf[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const K=this.zf,A=K[0],T=K[1],G=K[2],B=K[3],L=K[4],f=K[5],O=K[6],C=K[7],Q=K[8],Y=K[9],Z=K[10],x=K[11],J=K[12],b=K[13],P=K[14],F=K[15],d=Z*F-P*x,N=Y*F-b*x,D=Y*P-b*Z,mK=Q*F-J*x,U=Q*P-Z*J,z=Q*b-J*Y;return A*+(f*d-O*N+C*D)+T*-(L*d-O*mK+C*U)+G*+(L*N-f*mK+C*z)+B*-(L*D-f*U+O*z)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!K)return this.zf;const T=this.zf;for(let G=0;G<16;G++)K[A+G]=T[G];return this}kf(){return this.zf}bT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N.FromArrayToRef(K,A,this)}RO(){for(var K=arguments.length,A=new Array(K),T=0;T<K;T++)A[T]=arguments[T];return N.FromArrayToRef(A,0,this)}set(){const K=this.zf;for(let A=0;A<16;A++)K[A]=A<0||arguments.length<=A?void 0:arguments[A];return this.markAsUpdated(),this}IO(K){const A=this.zf;for(let T=0;T<16;T++)A[T]=K;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return N.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(K){const A=new N;return this.addToRef(K,A),A}addToRef(K,A){const T=this.zf,G=A.zf,B=K.m;for(let L=0;L<16;L++)G[L]=T[L]+B[L];return A.markAsUpdated(),A}addToSelf(K){const A=this.zf,T=K.m;return A[0]+=T[0],A[1]+=T[1],A[2]+=T[2],A[3]+=T[3],A[4]+=T[4],A[5]+=T[5],A[6]+=T[6],A[7]+=T[7],A[8]+=T[8],A[9]+=T[9],A[10]+=T[10],A[11]+=T[11],A[12]+=T[12],A[13]+=T[13],A[14]+=T[14],A[15]+=T[15],this.markAsUpdated(),this}addInPlace(K){const A=this.zf,T=K.m;for(let G=0;G<16;G++)A[G]+=T[G];return this.markAsUpdated(),this}addInPlaceFromFloats(){const K=this.zf;for(let A=0;A<16;A++)K[A]+=A<0||arguments.length<=A?void 0:arguments[A];return this.markAsUpdated(),this}FA(K){const A=this.zf,T=K.m;for(let G=0;G<16;G++)A[G]-=T[G];return this.markAsUpdated(),this}subtractToRef(K,A){const T=this.zf,G=K.m,B=A.zf;for(let L=0;L<16;L++)B[L]=T[L]-G[L];return A.markAsUpdated(),A}DZ(K){const A=this.zf,T=K.m;for(let G=0;G<16;G++)A[G]-=T[G];return this.markAsUpdated(),this}subtractFromFloats(){for(var K=arguments.length,A=new Array(K),T=0;T<K;T++)A[T]=arguments[T];return this.subtractFromFloatsToRef(...A,new N)}subtractFromFloatsToRef(){for(var K=arguments.length,A=new Array(K),T=0;T<K;T++)A[T]=arguments[T];const G=A.pop(),B=this.zf,L=G.zf,f=A;for(let O=0;O<16;O++)L[O]=B[O]-f[O];return G.markAsUpdated(),G}invertToRef(K){return!0===this._isIdentity?(N.IdentityToRef(K),K):(x(this,K.kf())?K.markAsUpdated():K.G(this),K)}addAtIndex(K,A){return this.zf[K]+=A,this.markAsUpdated(),this}multiplyAtIndex(K,A){return this.zf[K]*=A,this.markAsUpdated(),this}setTranslationFromFloats(K,A,T){return this.zf[12]=K,this.zf[13]=A,this.zf[14]=T,this.markAsUpdated(),this}addTranslationFromFloats(K,A,T){return this.zf[12]+=K,this.zf[13]+=A,this.zf[14]+=T,this.markAsUpdated(),this}setTranslation(K){return this.setTranslationFromFloats(K._x,K._y,K._z)}getTranslation(){return new P(this.zf[12],this.zf[13],this.zf[14])}getTranslationToRef(K){return K.x=this.zf[12],K.y=this.zf[13],K.z=this.zf[14],K}removeRotationAndScaling(){const K=this.m;return N.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,K[12],K[13],K[14],K[15],this),this._updateIdentityStatus(0===K[12]&&0===K[13]&&0===K[14]&&1===K[15]),this}G(K){K.copyToArray(this.zf);const A=K;return this.updateFlag=A.updateFlag,this._updateIdentityStatus(A._isIdentity,A._isIdentityDirty,A._isIdentity3x2,A._isIdentity3x2Dirty),this}copyToArray(K){return Z(this,K,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(K){const A=new N;return this.multiplyToRef(K,A),A}multiplyInPlace(K){const A=this.zf,T=K.m;for(let G=0;G<16;G++)A[G]*=T[G];return this.markAsUpdated(),this}multiplyByFloats(){const K=this.zf;for(let A=0;A<16;A++)K[A]*=A<0||arguments.length<=A?void 0:arguments[A];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var K=arguments.length,A=new Array(K),T=0;T<K;T++)A[T]=arguments[T];const G=A.pop(),B=this.zf,L=G.zf,f=A;for(let O=0;O<16;O++)L[O]=B[O]*f[O];return G.markAsUpdated(),G}multiplyToRef(K,A){return this._isIdentity?(A.G(K),A):K._isIdentity?(A.G(this),A):(this.multiplyToArray(K,A.zf,0),A.markAsUpdated(),A)}multiplyToArray(K,A,T){return Y(this,K,A,T),this}divide(K){return this.divideToRef(K,new N)}divideToRef(K,A){const T=this.zf,G=K.m,B=A.zf;for(let L=0;L<16;L++)B[L]=T[L]/G[L];return A.markAsUpdated(),A}divideInPlace(K){const A=this.zf,T=K.m;for(let G=0;G<16;G++)A[G]/=T[G];return this.markAsUpdated(),this}minimizeInPlace(K){const A=this.zf,T=K.m;for(let G=0;G<16;G++)A[G]=Math.min(A[G],T[G]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const K=this.zf;for(let A=0;A<16;A++)K[A]=Math.min(K[A],A<0||arguments.length<=A?void 0:arguments[A]);return this.markAsUpdated(),this}maximizeInPlace(K){const A=this.zf,T=K.m;for(let G=0;G<16;G++)A[G]=Math.min(A[G],T[G]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const K=this.zf;for(let A=0;A<16;A++)K[A]=Math.min(K[A],A<0||arguments.length<=A?void 0:arguments[A]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new N)}negateInPlace(){const K=this.zf;for(let A=0;A<16;A++)K[A]=-K[A];return this.markAsUpdated(),this}negateToRef(K){const A=this.zf,T=K.zf;for(let G=0;G<16;G++)T[G]=-A[G];return K.markAsUpdated(),K}equals(K){const A=K;if(!A)return!1;if((this._isIdentity||A._isIdentity)&&!this._isIdentityDirty&&!A._isIdentityDirty)return this._isIdentity&&A._isIdentity;const T=this.m,G=A.m;return T[0]===G[0]&&T[1]===G[1]&&T[2]===G[2]&&T[3]===G[3]&&T[4]===G[4]&&T[5]===G[5]&&T[6]===G[6]&&T[7]===G[7]&&T[8]===G[8]&&T[9]===G[9]&&T[10]===G[10]&&T[11]===G[11]&&T[12]===G[12]&&T[13]===G[13]&&T[14]===G[14]&&T[15]===G[15]}equalsWithEpsilon(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const T=this.zf,G=K.m;for(let B=0;B<16;B++)if(!(0,C.WithinEpsilon)(T[B],G[B],A))return!1;return!0}equalsToFloats(){const K=this.zf;for(let A=0;A<16;A++)if(K[A]!=(A<0||arguments.length<=A?void 0:arguments[A]))return!1;return!0}floor(){return this.floorToRef(new N)}floorToRef(K){const A=this.zf,T=K.zf;for(let G=0;G<16;G++)T[G]=Math.floor(A[G]);return K.markAsUpdated(),K}fract(){return this.fractToRef(new N)}fractToRef(K){const A=this.zf,T=K.zf;for(let G=0;G<16;G++)T[G]=A[G]-Math.floor(A[G]);return K.markAsUpdated(),K}clone(){const K=new N;return K.G(this),K}getClassName(){return"Matrix"}getHashCode(){let K=J(this.zf[0]);for(let A=1;A<16;A++)K=397*K^J(this.zf[A]);return K}decomposeToTransformNode(K){return K.rotationQuaternion=K.rotationQuaternion||new d,this.decompose(K.vO,K.rotationQuaternion,K.position)}decompose(K,A,T,G){let B=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return T&&T.IO(0),K&&K.IO(1),A&&A.RO(0,0,0,1),!0;const L=this.zf;if(T&&T.RO(L[12],L[13],L[14]),(K=K||D.PA[0]).x=Math.sqrt(L[0]*L[0]+L[1]*L[1]+L[2]*L[2]),K.y=Math.sqrt(L[4]*L[4]+L[5]*L[5]+L[6]*L[6]),K.z=Math.sqrt(L[8]*L[8]+L[9]*L[9]+L[10]*L[10]),G){const A=(B?G.absoluteScaling.x:G.vO.x)<0?-1:1,T=(B?G.absoluteScaling.y:G.vO.y)<0?-1:1,L=(B?G.absoluteScaling.z:G.vO.z)<0?-1:1;K.x*=A,K.y*=T,K.z*=L}else this.determinant()<=0&&(K.y*=-1);if(0===K._x||0===K._y||0===K._z)return A&&A.RO(0,0,0,1),!1;if(A){const T=1/K._x,G=1/K._y,B=1/K._z;N.FromValuesToRef(L[0]*T,L[1]*T,L[2]*T,0,L[4]*G,L[5]*G,L[6]*G,0,L[8]*B,L[9]*B,L[10]*B,0,0,0,0,1,D.Matrix[0]),d.FromRotationMatrixToRef(D.Matrix[0],A)}return!0}getRow(K){if(K<0||K>3)return null;const A=4*K;return new F(this.zf[A+0],this.zf[A+1],this.zf[A+2],this.zf[A+3])}getRowToRef(K,A){if(K>=0&&K<=3){const T=4*K;A.x=this.zf[T+0],A.y=this.zf[T+1],A.z=this.zf[T+2],A.w=this.zf[T+3]}return A}setRow(K,A){return this.setRowFromFloats(K,A.x,A.y,A.z,A.w)}transpose(){const K=new N;return N.TransposeToRef(this,K),K}transposeToRef(K){return N.TransposeToRef(this,K),K}setRowFromFloats(K,A,T,G,B){if(K<0||K>3)return this;const L=4*K;return this.zf[L+0]=A,this.zf[L+1]=T,this.zf[L+2]=G,this.zf[L+3]=B,this.markAsUpdated(),this}scale(K){const A=new N;return this.scaleToRef(K,A),A}scaleToRef(K,A){for(let T=0;T<16;T++)A.zf[T]=this.zf[T]*K;return A.markAsUpdated(),A}scaleAndAddToRef(K,A){for(let T=0;T<16;T++)A.zf[T]+=this.zf[T]*K;return A.markAsUpdated(),A}scaleInPlace(K){const A=this.zf;for(let T=0;T<16;T++)A[T]*=K;return this.markAsUpdated(),this}toNormalMatrix(K){const A=D.Matrix[0];this.invertToRef(A),A.transposeToRef(K);const T=K.zf;return N.FromValuesToRef(T[0],T[1],T[2],0,T[4],T[5],T[6],0,T[8],T[9],T[10],0,0,0,0,1,K),K}getRotationMatrix(){const K=new N;return this.getRotationMatrixToRef(K),K}getRotationMatrixToRef(K){const A=D.PA[0];if(!this.decompose(A))return N.IdentityToRef(K),K;const T=this.zf,G=1/A._x,B=1/A._y,L=1/A._z;return N.FromValuesToRef(T[0]*G,T[1]*G,T[2]*G,0,T[4]*B,T[5]*B,T[6]*B,0,T[8]*L,T[9]*L,T[10]*L,0,0,0,0,1,K),K}toggleModelMatrixHandInPlace(){const K=this.zf;return K[2]*=-1,K[6]*=-1,K[8]*=-1,K[9]*=-1,K[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const K=this.zf;return K[8]*=-1,K[9]*=-1,K[10]*=-1,K[11]*=-1,this.markAsUpdated(),this}static mT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const T=new N;return N.FromArrayToRef(K,A,T),T}static FromArrayToRef(K,A,T){for(let G=0;G<16;G++)T.zf[G]=K[G+A];return T.markAsUpdated(),T}static FromFloat32ArrayToRefScaled(K,A,T,G){return G.zf[0]=K[0+A]*T,G.zf[1]=K[1+A]*T,G.zf[2]=K[2+A]*T,G.zf[3]=K[3+A]*T,G.zf[4]=K[4+A]*T,G.zf[5]=K[5+A]*T,G.zf[6]=K[6+A]*T,G.zf[7]=K[7+A]*T,G.zf[8]=K[8+A]*T,G.zf[9]=K[9+A]*T,G.zf[10]=K[10+A]*T,G.zf[11]=K[11+A]*T,G.zf[12]=K[12+A]*T,G.zf[13]=K[13+A]*T,G.zf[14]=K[14+A]*T,G.zf[15]=K[15+A]*T,G.markAsUpdated(),G}static get IdentityReadOnly(){return N._IdentityReadOnly}static FromValuesToRef(K,A,T,G,B,L,f,O,C,Q,Y,Z,x,J,b,P,F){const d=F.zf;d[0]=K,d[1]=A,d[2]=T,d[3]=G,d[4]=B,d[5]=L,d[6]=f,d[7]=O,d[8]=C,d[9]=Q,d[10]=Y,d[11]=Z,d[12]=x,d[13]=J,d[14]=b,d[15]=P,F.markAsUpdated()}static FromValues(K,A,T,G,B,L,f,O,C,Q,Y,Z,x,J,b,P){const F=new N,d=F.zf;return d[0]=K,d[1]=A,d[2]=T,d[3]=G,d[4]=B,d[5]=L,d[6]=f,d[7]=O,d[8]=C,d[9]=Q,d[10]=Y,d[11]=Z,d[12]=x,d[13]=J,d[14]=b,d[15]=P,F.markAsUpdated(),F}static Compose(K,A,T){const G=new N;return N.ComposeToRef(K,A,T,G),G}static ComposeToRef(K,A,T,G){const B=G.zf,L=A._x,f=A._y,O=A._z,C=A._w,Q=L+L,Y=f+f,Z=O+O,x=L*Q,J=L*Y,b=L*Z,P=f*Y,F=f*Z,d=O*Z,N=C*Q,D=C*Y,mK=C*Z,U=K._x,z=K._y,g=K._z;return B[0]=(1-(P+d))*U,B[1]=(J+mK)*U,B[2]=(b-D)*U,B[3]=0,B[4]=(J-mK)*z,B[5]=(1-(x+d))*z,B[6]=(F+N)*z,B[7]=0,B[8]=(b+D)*g,B[9]=(F-N)*g,B[10]=(1-(x+P))*g,B[11]=0,B[12]=T._x,B[13]=T._y,B[14]=T._z,B[15]=1,G.markAsUpdated(),G}static Identity(){const K=N.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return K._updateIdentityStatus(!0),K}static IdentityToRef(K){return N.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,K),K._updateIdentityStatus(!0),K}static Zero(){const K=N.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return K._updateIdentityStatus(!1),K}static RotationX(K){const A=new N;return N.RotationXToRef(K,A),A}static Invert(K){const A=new N;return K.invertToRef(A),A}static RotationXToRef(K,A){const T=Math.sin(K),G=Math.cos(K);return N.FromValuesToRef(1,0,0,0,0,G,T,0,0,-T,G,0,0,0,0,1,A),A._updateIdentityStatus(1===G&&0===T),A}static RotationY(K){const A=new N;return N.RotationYToRef(K,A),A}static RotationYToRef(K,A){const T=Math.sin(K),G=Math.cos(K);return N.FromValuesToRef(G,0,-T,0,0,1,0,0,T,0,G,0,0,0,0,1,A),A._updateIdentityStatus(1===G&&0===T),A}static RotationZ(K){const A=new N;return N.RotationZToRef(K,A),A}static RotationZToRef(K,A){const T=Math.sin(K),G=Math.cos(K);return N.FromValuesToRef(G,T,0,0,-T,G,0,0,0,0,1,0,0,0,0,1,A),A._updateIdentityStatus(1===G&&0===T),A}static RotationAxis(K,A){const T=new N;return N.RotationAxisToRef(K,A,T),T}static RotationAxisToRef(K,A,T){const G=Math.sin(-A),B=Math.cos(-A),L=1-B;K=K.normalizeToRef(D.PA[0]);const f=T.zf;return f[0]=K._x*K._x*L+B,f[1]=K._x*K._y*L-K._z*G,f[2]=K._x*K._z*L+K._y*G,f[3]=0,f[4]=K._y*K._x*L+K._z*G,f[5]=K._y*K._y*L+B,f[6]=K._y*K._z*L-K._x*G,f[7]=0,f[8]=K._z*K._x*L-K._y*G,f[9]=K._z*K._y*L+K._x*G,f[10]=K._z*K._z*L+B,f[11]=0,f[12]=0,f[13]=0,f[14]=0,f[15]=1,T.markAsUpdated(),T}static RotationAlignToRef(K,A,T){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const L=P.Dot(A,K),f=T.zf;if(L<-1+G.c)f[0]=-1,f[1]=0,f[2]=0,f[3]=0,f[4]=0,f[5]=B?1:-1,f[6]=0,f[7]=0,f[8]=0,f[9]=0,f[10]=B?-1:1,f[11]=0;else{const T=P.Cross(A,K),G=1/(1+L);f[0]=T._x*T._x*G+L,f[1]=T._y*T._x*G-T._z,f[2]=T._z*T._x*G+T._y,f[3]=0,f[4]=T._x*T._y*G+T._z,f[5]=T._y*T._y*G+L,f[6]=T._z*T._y*G-T._x,f[7]=0,f[8]=T._x*T._z*G-T._y,f[9]=T._y*T._z*G+T._x,f[10]=T._z*T._z*G+L,f[11]=0}return f[12]=0,f[13]=0,f[14]=0,f[15]=1,T.markAsUpdated(),T}static RotationYawPitchRoll(K,A,T){const G=new N;return N.RotationYawPitchRollToRef(K,A,T,G),G}static RotationYawPitchRollToRef(K,A,T,G){return d.RotationYawPitchRollToRef(K,A,T,D.Quaternion[0]),D.Quaternion[0].toRotationMatrix(G),G}static Scaling(K,A,T){const G=new N;return N.ScalingToRef(K,A,T,G),G}static ScalingToRef(K,A,T,G){return N.FromValuesToRef(K,0,0,0,0,A,0,0,0,0,T,0,0,0,0,1,G),G._updateIdentityStatus(1===K&&1===A&&1===T),G}static Translation(K,A,T){const G=new N;return N.TranslationToRef(K,A,T,G),G}static TranslationToRef(K,A,T,G){return N.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,K,A,T,1,G),G._updateIdentityStatus(0===K&&0===A&&0===T),G}static Lerp(K,A,T){const G=new N;return N.LerpToRef(K,A,T,G),G}static LerpToRef(K,A,T,G){const B=G.zf,L=K.m,f=A.m;for(let O=0;O<16;O++)B[O]=L[O]*(1-T)+f[O]*T;return G.markAsUpdated(),G}static DecomposeLerp(K,A,T){const G=new N;return N.DecomposeLerpToRef(K,A,T,G),G}static DecomposeLerpToRef(K,A,T,G){const B=D.PA[0],L=D.Quaternion[0],f=D.PA[1];K.decompose(B,L,f);const O=D.PA[2],C=D.Quaternion[1],Q=D.PA[3];A.decompose(O,C,Q);const Y=D.PA[4];P.LerpToRef(B,O,T,Y);const Z=D.Quaternion[2];d.SlerpToRef(L,C,T,Z);const x=D.PA[5];return P.LerpToRef(f,Q,T,x),N.ComposeToRef(Y,Z,x,G),G}static LookAtLH(K,A,T){const G=new N;return N.LookAtLHToRef(K,A,T,G),G}static LookAtLHToRef(K,A,T,G){const B=D.PA[0],L=D.PA[1],f=D.PA[2];A.subtractToRef(K,f),f.normalize(),P.CrossToRef(T,f,B);const O=B.lengthSquared();0===O?B.x=1:B.normalizeFromLength(Math.sqrt(O)),P.CrossToRef(f,B,L),L.normalize();const C=-P.Dot(B,K),Q=-P.Dot(L,K),Y=-P.Dot(f,K);return N.FromValuesToRef(B._x,L._x,f._x,0,B._y,L._y,f._y,0,B._z,L._z,f._z,0,C,Q,Y,1,G),G}static LookAtRH(K,A,T){const G=new N;return N.LookAtRHToRef(K,A,T,G),G}static LookAtRHToRef(K,A,T,G){const B=D.PA[0],L=D.PA[1],f=D.PA[2];K.subtractToRef(A,f),f.normalize(),P.CrossToRef(T,f,B);const O=B.lengthSquared();0===O?B.x=1:B.normalizeFromLength(Math.sqrt(O)),P.CrossToRef(f,B,L),L.normalize();const C=-P.Dot(B,K),Q=-P.Dot(L,K),Y=-P.Dot(f,K);return N.FromValuesToRef(B._x,L._x,f._x,0,B._y,L._y,f._y,0,B._z,L._z,f._z,0,C,Q,Y,1,G),G}static LookDirectionLH(K,A){const T=new N;return N.LookDirectionLHToRef(K,A,T),T}static LookDirectionLHToRef(K,A,T){const G=D.PA[0];G.G(K),G.scaleInPlace(-1);const B=D.PA[1];return P.CrossToRef(A,G,B),N.FromValuesToRef(B._x,B._y,B._z,0,A._x,A._y,A._z,0,G._x,G._y,G._z,0,0,0,0,1,T),T}static LookDirectionRH(K,A){const T=new N;return N.LookDirectionRHToRef(K,A,T),T}static LookDirectionRHToRef(K,A,T){const G=D.PA[2];return P.CrossToRef(A,K,G),N.FromValuesToRef(G._x,G._y,G._z,0,A._x,A._y,A._z,0,K._x,K._y,K._z,0,0,0,0,1,T),T}static OrthoLH(K,A,T,G,B){const L=new N;return N.OrthoLHToRef(K,A,T,G,L,B),L}static OrthoLHToRef(K,A,T,G,B,L){const f=2/K,O=2/A,C=2/(G-T),Q=-(G+T)/(G-T);return N.FromValuesToRef(f,0,0,0,0,O,0,0,0,0,C,0,0,0,Q,1,B),L&&B.multiplyToRef(U,B),B._updateIdentityStatus(1===f&&1===O&&1===C&&0===Q),B}static OrthoOffCenterLH(K,A,T,G,B,L,f){const O=new N;return N.OrthoOffCenterLHToRef(K,A,T,G,B,L,O,f),O}static OrthoOffCenterLHToRef(K,A,T,G,B,L,f,O){const C=2/(A-K),Q=2/(G-T),Y=2/(L-B),Z=-(L+B)/(L-B),x=(K+A)/(K-A),J=(G+T)/(T-G);return N.FromValuesToRef(C,0,0,0,0,Q,0,0,0,0,Y,0,x,J,Z,1,f),O&&f.multiplyToRef(U,f),f.markAsUpdated(),f}static ObliqueOffCenterLHToRef(K,A,T,G,B,L,f,O,C,Q,Y){const Z=-f*Math.cos(O),x=-f*Math.sin(O);return N.TranslationToRef(0,0,-C,D.Matrix[1]),N.FromValuesToRef(1,0,0,0,0,1,0,0,Z,x,1,0,0,0,0,1,D.Matrix[0]),D.Matrix[1].multiplyToRef(D.Matrix[0],D.Matrix[0]),N.TranslationToRef(0,0,C,D.Matrix[1]),D.Matrix[0].multiplyToRef(D.Matrix[1],D.Matrix[0]),N.OrthoOffCenterLHToRef(K,A,T,G,B,L,Q,Y),D.Matrix[0].multiplyToRef(Q,Q),Q}static OrthoOffCenterRH(K,A,T,G,B,L,f){const O=new N;return N.OrthoOffCenterRHToRef(K,A,T,G,B,L,O,f),O}static OrthoOffCenterRHToRef(K,A,T,G,B,L,f,O){return N.OrthoOffCenterLHToRef(K,A,T,G,B,L,f,O),f.zf[10]*=-1,f}static ObliqueOffCenterRHToRef(K,A,T,G,B,L,f,O,C,Q,Y){const Z=f*Math.cos(O),x=f*Math.sin(O);return N.TranslationToRef(0,0,C,D.Matrix[1]),N.FromValuesToRef(1,0,0,0,0,1,0,0,Z,x,1,0,0,0,0,1,D.Matrix[0]),D.Matrix[1].multiplyToRef(D.Matrix[0],D.Matrix[0]),N.TranslationToRef(0,0,-C,D.Matrix[1]),D.Matrix[0].multiplyToRef(D.Matrix[1],D.Matrix[0]),N.OrthoOffCenterRHToRef(K,A,T,G,B,L,Q,Y),D.Matrix[0].multiplyToRef(Q,Q),Q}static PerspectiveLH(K,A,T,G,B){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const f=new N,O=2*T/K,C=2*T/A,Q=(G+T)/(G-T),Y=-2*G*T/(G-T),Z=Math.tan(L);return N.FromValuesToRef(O,0,0,0,0,C,0,Z,0,0,Q,1,0,0,Y,0,f),B&&f.multiplyToRef(U,f),f._updateIdentityStatus(!1),f}static PerspectiveFovLH(K,A,T,G,B){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,f=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const O=new N;return N.PerspectiveFovLHToRef(K,A,T,G,O,!0,B,L,f),O}static PerspectiveFovLHToRef(K,A,T,G,B){let L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],f=arguments.length>6?arguments[6]:void 0,O=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,C=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const Q=T,Y=G,Z=1/Math.tan(.5*K),x=L?Z/A:Z,J=L?Z:Z*A,b=C&&0===Q?-1:0!==Y?(Y+Q)/(Y-Q):1,P=C&&0===Q?2*Y:0!==Y?-2*Y*Q/(Y-Q):-2*Q,F=Math.tan(O);return N.FromValuesToRef(x,0,0,0,0,J,0,F,0,0,b,1,0,0,P,0,B),f&&B.multiplyToRef(U,B),B._updateIdentityStatus(!1),B}static PerspectiveFovReverseLHToRef(K,A,T,G,B){let L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],f=arguments.length>6?arguments[6]:void 0,O=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const C=1/Math.tan(.5*K),Q=L?C/A:C,Y=L?C:C*A,Z=Math.tan(O);return N.FromValuesToRef(Q,0,0,0,0,Y,0,Z,0,0,-T,1,0,0,1,0,B),f&&B.multiplyToRef(U,B),B._updateIdentityStatus(!1),B}static PerspectiveFovRH(K,A,T,G,B){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,f=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const O=new N;return N.PerspectiveFovRHToRef(K,A,T,G,O,!0,B,L,f),O}static PerspectiveFovRHToRef(K,A,T,G,B){let L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],f=arguments.length>6?arguments[6]:void 0,O=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,C=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const Q=T,Y=G,Z=1/Math.tan(.5*K),x=L?Z/A:Z,J=L?Z:Z*A,b=C&&0===Q?1:0!==Y?-(Y+Q)/(Y-Q):-1,P=C&&0===Q?2*Y:0!==Y?-2*Y*Q/(Y-Q):-2*Q,F=Math.tan(O);return N.FromValuesToRef(x,0,0,0,0,J,0,F,0,0,b,-1,0,0,P,0,B),f&&B.multiplyToRef(U,B),B._updateIdentityStatus(!1),B}static PerspectiveFovReverseRHToRef(K,A,T,G,B){let L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],f=arguments.length>6?arguments[6]:void 0,O=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const C=1/Math.tan(.5*K),Q=L?C/A:C,Y=L?C:C*A,Z=Math.tan(O);return N.FromValuesToRef(Q,0,0,0,0,Y,0,Z,0,0,-T,-1,0,0,-1,0,B),f&&B.multiplyToRef(U,B),B._updateIdentityStatus(!1),B}static GetFinalMatrix(K,A,T,G,B,L){const f=K.width,O=K.height,C=K.x,Q=K.y,Y=N.FromValues(f/2,0,0,0,0,-O/2,0,0,0,0,L-B,0,C+f/2,O/2+Q,B,1),Z=new N;return A.multiplyToRef(T,Z),Z.multiplyToRef(G,Z),Z.multiplyToRef(Y,Z)}static GetAsMatrix2x2(K){const A=K.m,T=[A[0],A[1],A[4],A[5]];return f.b.MatrixUse64Bits?T:new Float32Array(T)}static GetAsMatrix3x3(K){const A=K.m,T=[A[0],A[1],A[2],A[4],A[5],A[6],A[8],A[9],A[10]];return f.b.MatrixUse64Bits?T:new Float32Array(T)}static Transpose(K){const A=new N;return N.TransposeToRef(K,A),A}static TransposeToRef(K,A){const T=K.m,G=T[0],B=T[4],L=T[8],f=T[12],O=T[1],C=T[5],Q=T[9],Y=T[13],Z=T[2],x=T[6],J=T[10],b=T[14],P=T[3],F=T[7],d=T[11],N=T[15],D=A.zf;return D[0]=G,D[1]=B,D[2]=L,D[3]=f,D[4]=O,D[5]=C,D[6]=Q,D[7]=Y,D[8]=Z,D[9]=x,D[10]=J,D[11]=b,D[12]=P,D[13]=F,D[14]=d,D[15]=N,A.markAsUpdated(),A._updateIdentityStatus(K._isIdentity,K._isIdentityDirty),A}static Reflection(K){const A=new N;return N.ReflectionToRef(K,A),A}static ReflectionToRef(K,A){K.normalize();const T=K.normal.x,G=K.normal.y,B=K.normal.z,L=-2*T,f=-2*G,O=-2*B;return N.FromValuesToRef(L*T+1,f*T,O*T,0,L*G,f*G+1,O*G,0,L*B,f*B,O*B+1,0,L*K.d,f*K.d,O*K.d,1,A),A}static FromXYZAxesToRef(K,A,T,G){return N.FromValuesToRef(K._x,K._y,K._z,0,A._x,A._y,A._z,0,T._x,T._y,T._z,0,0,0,0,1,G),G}static FromQuaternionToRef(K,A){const T=K._x*K._x,G=K._y*K._y,B=K._z*K._z,L=K._x*K._y,f=K._z*K._w,O=K._z*K._x,C=K._y*K._w,Q=K._y*K._z,Y=K._x*K._w;return A.zf[0]=1-2*(G+B),A.zf[1]=2*(L+f),A.zf[2]=2*(O-C),A.zf[3]=0,A.zf[4]=2*(L-f),A.zf[5]=1-2*(B+T),A.zf[6]=2*(Q+Y),A.zf[7]=0,A.zf[8]=2*(O+C),A.zf[9]=2*(Q-Y),A.zf[10]=1-2*(G+T),A.zf[11]=0,A.zf[12]=0,A.zf[13]=0,A.zf[14]=0,A.zf[15]=1,A.markAsUpdated(),A}}N._IdentityReadOnly=N.Identity(),Object.defineProperties(N.prototype,{dimension:{value:[4,4]},rank:{value:2}});class D{}D.PA=(0,B.c)(11,P.Zero),D.Matrix=(0,B.c)(2,N.Identity),D.Quaternion=(0,B.c)(3,d.Zero);class mK{}mK.Vector2=(0,B.c)(3,b.Zero),mK.PA=(0,B.c)(13,P.Zero),mK.Vector4=(0,B.c)(3,F.Zero),mK.Quaternion=(0,B.c)(3,d.Zero),mK.Matrix=(0,B.c)(8,N.Identity),(0,L.c)("BABYLON.Vector2",b),(0,L.c)("BABYLON.Vector3",P),(0,L.c)("BABYLON.Vector4",F),(0,L.c)("BABYLON.Matrix",N);const U=N.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12714:(K,A,T)=>{function G(K,A){const T=[];for(let G=0;G<K;++G)T.push(A());return T}function B(K,A){return G(K,A)}T.d(A,{b:()=>G,c:()=>B,g:()=>f});const L=["push","splice","pop","shift","unshift"];function f(K,A){const T=L.map((T=>function(K,A,T){const G=K[A];if("function"!==typeof G)return null;const B=function(){const G=K.length,L=B.previous.apply(K,arguments);return T(A,G),L};return G.next=B,B.previous=G,K[A]=B,()=>{const T=B.previous;if(!T)return;const G=B.next;G?(T.next=G,G.previous=T):(T.next=void 0,K[A]=T),B.next=void 0,B.previous=void 0}}(K,T,A)));return()=>{for(const K of T)null===K||void 0===K||K()}}}}]);