"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{2252:(Y,d,t)=>{t.r(d),t.d(d,{_ExrTextureLoader:()=>R});var x=t(531),C=t(705);const U=65536,y=14,B=65537,W=16384;var o,f;!function(Y){Y[Y.NO_COMPRESSION=0]="NO_COMPRESSION",Y[Y.RLE_COMPRESSION=1]="RLE_COMPRESSION",Y[Y.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Y[Y.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Y[Y.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Y[Y.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(o||(o={})),function(Y){Y[Y.INCREASING_Y=0]="INCREASING_Y",Y[Y.DECREASING_Y=1]="DECREASING_Y"}(f||(f={}));const F=function(){const Y=new ArrayBuffer(4),d=new Float32Array(Y),t=new Uint32Array(Y),x=new Uint32Array(512),C=new Uint32Array(512);for(let W=0;W<256;++W){const Y=W-127;Y<-27?(x[W]=0,x[256|W]=32768,C[W]=24,C[256|W]=24):Y<-14?(x[W]=1024>>-Y-14,x[256|W]=1024>>-Y-14|32768,C[W]=-Y-1,C[256|W]=-Y-1):Y<=15?(x[W]=Y+15<<10,x[256|W]=Y+15<<10|32768,C[W]=13,C[256|W]=13):Y<128?(x[W]=31744,x[256|W]=64512,C[W]=24,C[256|W]=24):(x[W]=31744,x[256|W]=64512,C[W]=13,C[256|W]=13)}const U=new Uint32Array(2048),y=new Uint32Array(64),B=new Uint32Array(64);for(let W=1;W<1024;++W){let Y=W<<13,d=0;for(;0===(8388608&Y);)Y<<=1,d-=8388608;Y&=-8388609,d+=947912704,U[W]=Y|d}for(let W=1024;W<2048;++W)U[W]=939524096+(W-1024<<13);for(let W=1;W<31;++W)y[W]=W<<23;y[31]=1199570944,y[32]=2147483648;for(let W=33;W<63;++W)y[W]=2147483648+(W-32<<23);y[63]=3347054592;for(let W=1;W<64;++W)32!==W&&(B[W]=1024);return{floatView:d,uint32View:t,baseTable:x,shiftTable:C,mantissaTable:U,exponentTable:y,offsetTable:B}}();function D(Y,d){const t=new Uint8Array(Y);let x=0;for(;0!=t[d.value+x];)x+=1;const C=(new TextDecoder).decode(t.slice(d.value,d.value+x));return d.value=d.value+x+1,C}function b(Y,d){const t=Y.getInt32(d.value,!0);return d.value+=4,t}function m(Y,d){const t=Y.getUint32(d.value,!0);return d.value+=4,t}function M(Y,d){const t=Y.getUint8(d.value);return d.value+=1,t}function J(Y,d){const t=Y.getUint16(d.value,!0);return d.value+=2,t}function g(Y,d){const t=Y[d.value];return d.value+=1,t}function T(Y,d){let t;return t="getBigInt64"in DataView.prototype?Number(Y.getBigInt64(d.value,!0)):Y.getUint32(d.value+4,!0)+Number(Y.getUint32(d.value,!0)<<32),d.value+=8,t}function s(Y,d){const t=Y.getFloat32(d.value,!0);return d.value+=4,t}function l(Y,d){return function(Y){const d=(31744&Y)>>10,t=1023&Y;return(Y>>15?-1:1)*(d?31===d?t?NaN:1/0:Math.pow(2,d-15)*(1+t/1024):t/1024*6103515625e-14)}(J(Y,d))}function h(Y,d){return function(Y){if(Math.abs(Y)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Y=(0,C.b)(Y,-65504,65504),F.floatView[0]=Y;const d=F.uint32View[0],t=d>>23&511;return F.baseTable[t]+((8388607&d)>>F.shiftTable[t])}(s(Y,d))}function Z(Y,d,t,x){switch(t){case"string":case"stringvector":case"iccProfile":return function(Y,d,t){const x=(new TextDecoder).decode(new Uint8Array(Y).slice(d.value,d.value+t));return d.value=d.value+t,x}(Y.buffer,d,x);case"chlist":return function(Y,d,t){const x=d.value,C=[];for(;d.value<x+t-1;){const t=D(Y.buffer,d),x=b(Y,d),U=M(Y,d);d.value+=3;const y=b(Y,d),B=b(Y,d);C.push({name:t,pixelType:x,pLinear:U,xSampling:y,ySampling:B})}return d.value+=1,C}(Y,d,x);case"chromaticities":return function(Y,d){return{redX:s(Y,d),redY:s(Y,d),greenX:s(Y,d),greenY:s(Y,d),blueX:s(Y,d),blueY:s(Y,d),whiteX:s(Y,d),whiteY:s(Y,d)}}(Y,d);case"compression":return function(Y,d){return M(Y,d)}(Y,d);case"box2i":return function(Y,d){return{xMin:b(Y,d),yMin:b(Y,d),xMax:b(Y,d),yMax:b(Y,d)}}(Y,d);case"lineOrder":return function(Y,d){const t=M(Y,d);return f[t]}(Y,d);case"float":return s(Y,d);case"v2f":return function(Y,d){return[s(Y,d),s(Y,d)]}(Y,d);case"v3f":return function(Y,d){return[s(Y,d),s(Y,d),s(Y,d)]}(Y,d);case"int":return b(Y,d);case"rational":return function(Y,d){return[b(Y,d),m(Y,d)]}(Y,d);case"timecode":return function(Y,d){return[m(Y,d),m(Y,d)]}(Y,d);case"preview":return d.value+=x,"skipped";default:return void(d.value+=x)}}function N(Y){for(let d=1;d<Y.length;d++){const t=Y[d-1]+Y[d]-128;Y[d]=t}}function w(Y,d){let t=0,x=Math.floor((Y.length+1)/2),C=0;const U=Y.length-1;for(;!(C>U)&&(d[C++]=Y[t++],!(C>U));)d[C++]=Y[x++]}function K(Y,d,t,x,C){for(;t<Y;)d=d<<8|g(x,C),t+=8;return{l:d>>(t-=Y)&(1<<Y)-1,c:d,lc:t}}function P(Y,d,t,x){return{c:Y=Y<<8|g(t,x),lc:d+=8}}function V(Y,d,t,x,C,U,y,B,W){if(Y==d){if(x<8){const Y=P(t,x,C,U);t=Y.c,x=Y.lc}let Y=t>>(x-=8);if(Y=new Uint8Array([Y])[0],B.value+Y>W)return null;const d=y[B.value-1];for(;Y-- >0;)y[B.value++]=d}else{if(!(B.value<W))return null;y[B.value++]=Y}return{c:t,lc:x}}const j=new Array(59);function n(Y,d,t,x,C,U){const y=d;let W=0,o=0;for(;x<=C;x++){if(y.value-d.value>t)return;let B=K(6,W,o,Y,y);const f=B.l;if(W=B.c,o=B.lc,U[x]=f,63==f){if(y.value-d.value>t)throw new Error("Error in HufUnpackEncTable");B=K(8,W,o,Y,y);let f=B.l+6;if(W=B.c,o=B.lc,x+f>C+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)U[x++]=0;x--}else if(f>=59){let Y=f-59+2;if(x+Y>C+1)throw new Error("Error in HufUnpackEncTable");for(;Y--;)U[x++]=0;x--}}!function(Y){for(let t=0;t<=58;++t)j[t]=0;for(let t=0;t<B;++t)j[Y[t]]+=1;let d=0;for(let t=58;t>0;--t){const Y=d+j[t]>>1;j[t]=d,d=Y}for(let t=0;t<B;++t){const d=Y[t];d>0&&(Y[t]=d|j[d]++<<6)}}(U)}function H(Y){return 63&Y}function v(Y){return Y>>6}function u(Y,d,t,x,C,U){const o=t.value,f=m(d,t),F=m(d,t);t.value+=4;const D=m(d,t);if(t.value+=4,f<0||f>=B||F<0||F>=B)throw new Error("Wrong HUF_ENCSIZE");const b=new Array(B),M=new Array(W);!function(Y){for(let d=0;d<W;d++)Y[d]={},Y[d].len=0,Y[d].lit=0,Y[d].p=null}(M);if(n(Y,t,x-(t.value-o),f,F,b),D>8*(x-(t.value-o)))throw new Error("Wrong hufUncompress");!function(Y,d,t,x){for(;d<=t;d++){const t=v(Y[d]),C=H(Y[d]);if(t>>C)throw new Error("Invalid table entry");if(C>y){const Y=x[t>>C-y];if(Y.len)throw new Error("Invalid table entry");if(Y.lit++,Y.p){const d=Y.p;Y.p=new Array(Y.lit);for(let t=0;t<Y.lit-1;++t)Y.p[t]=d[t]}else Y.p=new Array(1);Y.p[Y.lit-1]=d}else if(C){let Y=0;for(let U=1<<y-C;U>0;U--){const U=x[(t<<y-C)+Y];if(U.len||U.p)throw new Error("Invalid table entry");U.len=C,U.lit=d,Y++}}}}(b,f,F,M),function(Y,d,t,x,C,U,B,W,o){let f=0,F=0;const D=B,b=Math.trunc(x.value+(C+7)/8);for(;x.value<b;){let C=P(f,F,t,x);for(f=C.c,F=C.lc;F>=y;){const B=d[f>>F-y&16383];if(B.len){F-=B.len;const Y=V(B.lit,U,f,F,t,x,W,o,D);Y&&(f=Y.c,F=Y.lc)}else{if(!B.p)throw new Error("hufDecode issues");let d;for(d=0;d<B.lit;d++){const y=H(Y[B.p[d]]);for(;F<y&&x.value<b;)C=P(f,F,t,x),f=C.c,F=C.lc;if(F>=y&&v(Y[B.p[d]])==(f>>F-y&(1<<y)-1)){F-=y;const Y=V(B.p[d],U,f,F,t,x,W,o,D);Y&&(f=Y.c,F=Y.lc);break}}if(d==B.lit)throw new Error("HufDecode issues")}}}const m=8-C&7;for(f>>=m,F-=m;F>0;){const Y=d[f<<y-F&16383];if(!Y.len)throw new Error("HufDecode issues");{F-=Y.len;const d=V(Y.lit,U,f,F,t,x,W,o,D);d&&(f=d.c,F=d.lc)}}}(b,M,Y,t,D,F,U,C,{value:0})}function I(Y){return 65535&Y}function e(Y){const d=I(Y);return d>32767?d-65536:d}function i(Y,d){const t=e(Y),x=e(d),C=t+(1&x)+(x>>1);return{a:C,b:C-x}}function X(Y,d){const t=I(Y),x=I(d),C=t-(x>>1)&65535;return{a:x+C-32768&65535,b:C}}function O(Y,d,t,x,C,U,y){const B=y<16384,W=t>C?C:t;let o,f,F=1;for(;F<=W;)F<<=1;for(F>>=1,o=F,F>>=1;F>=1;){f=0;const y=f+U*(C-o),W=U*F,D=U*o,b=x*F,m=x*o;let M,J,g,T;for(;f<=y;f+=D){let C=f;const U=f+x*(t-o);for(;C<=U;C+=m){const t=C+b,x=C+W,U=x+b;if(B){let y=i(Y[C+d],Y[x+d]);M=y.a,g=y.b,y=i(Y[t+d],Y[U+d]),J=y.a,T=y.b,y=i(M,J),Y[C+d]=y.a,Y[t+d]=y.b,y=i(g,T),Y[x+d]=y.a,Y[U+d]=y.b}else{let y=X(Y[C+d],Y[x+d]);M=y.a,g=y.b,y=X(Y[t+d],Y[U+d]),J=y.a,T=y.b,y=X(M,J),Y[C+d]=y.a,Y[t+d]=y.b,y=X(g,T),Y[x+d]=y.a,Y[U+d]=y.b}}if(t&F){const t=C+W;let x;x=B?i(Y[C+d],Y[t+d]):X(Y[C+d],Y[t+d]),M=x.a,Y[t+d]=x.b,Y[C+d]=M}}if(C&F){let C=f;const U=f+x*(t-o);for(;C<=U;C+=m){const t=C+b;let x;x=B?i(Y[C+d],Y[t+d]):X(Y[C+d],Y[t+d]),M=x.a,Y[t+d]=x.b,Y[C+d]=M}}o=F,F>>=1}return f}function G(Y){return new DataView(Y.array.buffer,Y.offset.value,Y.size)}function Q(Y){const d=Y.viewer.buffer.slice(Y.offset.value,Y.offset.value+Y.size),t=new Uint8Array(function(Y){let d=Y.byteLength;const t=new Array;let x=0;const C=new DataView(Y);for(;d>0;){const Y=C.getInt8(x++);if(Y<0){const U=-Y;d-=U+1;for(let Y=0;Y<U;Y++)t.push(C.getUint8(x++))}else{const U=Y;d-=2;const y=C.getUint8(x++);for(let Y=0;Y<U+1;Y++)t.push(y)}}return t}(d)),x=new Uint8Array(t.length);return N(t),w(t,x),new DataView(x.buffer)}function a(Y){const d=Y.array.slice(Y.offset.value,Y.offset.value+Y.size),t=fflate.unzlibSync(d),x=new Uint8Array(t.length);return N(t),w(t,x),new DataView(x.buffer)}function c(Y){const d=Y.array.slice(Y.offset.value,Y.offset.value+Y.size),t=fflate.unzlibSync(d),x=Y.lines*Y.channels*Y.width,C=1==Y.type?new Uint16Array(x):new Uint32Array(x);let U=0,y=0;const B=new Array(4);for(let W=0;W<Y.lines;W++)for(let d=0;d<Y.channels;d++){let d=0;switch(Y.type){case 1:B[0]=U,B[1]=B[0]+Y.width,U=B[1]+Y.width;for(let x=0;x<Y.width;++x){d+=t[B[0]++]<<8|t[B[1]++],C[y]=d,y++}break;case 2:B[0]=U,B[1]=B[0]+Y.width,B[2]=B[1]+Y.width,U=B[2]+Y.width;for(let x=0;x<Y.width;++x){d+=t[B[0]++]<<24|t[B[1]++]<<16|t[B[2]++]<<8,C[y]=d,y++}}}return new DataView(C.buffer)}function z(Y){const d=Y.viewer,t={value:Y.offset.value},x=new Uint16Array(Y.width*Y.scanlineBlockSize*(Y.channels*Y.type)),C=new Uint8Array(8192);let y=0;const B=new Array(Y.channels);for(let U=0;U<Y.channels;U++)B[U]={},B[U].start=y,B[U].end=B[U].start,B[U].nx=Y.width,B[U].ny=Y.lines,B[U].size=Y.type,y+=B[U].nx*B[U].ny*B[U].size;const W=J(d,t),o=J(d,t);if(o>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(W<=o)for(let U=0;U<o-W+1;U++)C[U+W]=M(d,t);const f=new Uint16Array(U),F=function(Y,d){let t=0;for(let C=0;C<U;++C)(0==C||Y[C>>3]&1<<(7&C))&&(d[t++]=C);const x=t-1;for(;t<U;)d[t++]=0;return x}(C,f),D=m(d,t);u(Y.array,d,t,D,x,y);for(let U=0;U<Y.channels;++U){const Y=B[U];for(let d=0;d<B[U].size;++d)O(x,Y.start+d,Y.nx,Y.size,Y.ny,Y.nx*Y.size,F)}!function(Y,d,t){for(let x=0;x<t;++x)d[x]=Y[d[x]]}(f,x,y);let b=0;const g=new Uint8Array(x.buffer.byteLength);for(let U=0;U<Y.lines;U++)for(let d=0;d<Y.channels;d++){const Y=B[d],t=Y.nx*Y.size,C=new Uint8Array(x.buffer,2*Y.end,2*t);g.set(C,b),b+=2*t,Y.end+=t}return new DataView(g.buffer)}var E,p=t(521);!function(Y){Y[Y.Float=0]="Float",Y[Y.HalfFloat=1]="HalfFloat"}(E||(E={}));class L{}L.DefaultOutputType=E.HalfFloat,L.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class R{constructor(){this.supportCascades=!1}loadCubeData(Y,d,t,x,C){throw".exr not supported in Cube."}async loadData(Y,d,t){const C=new DataView(Y.buffer),U={value:0},y=function(Y,d){if(20000630!=Y.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const t=Y.getUint8(4),C=Y.getUint8(5),U={singleTile:!!(2&C),longName:!!(4&C),deepFormat:!!(8&C),multiPart:!!(16&C)};d.value=8;const y={};let B=!0;for(;B;){const t=D(Y.buffer,d);if(t){const C=D(Y.buffer,d),U=Z(Y,d,C,m(Y,d));void 0===U?x.c.Warn(`Unknown header attribute type ${C}'.`):y[t]=U}else B=!1}if(0!=(-5&C))throw new Error("Unsupported file format");return{version:t,spec:U,...y}}(C,U),B=await async function(Y,d,t,x){const C={size:0,viewer:d,array:new Uint8Array(d.buffer),offset:t,width:Y.dataWindow.xMax-Y.dataWindow.xMin+1,height:Y.dataWindow.yMax-Y.dataWindow.yMin+1,channels:Y.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Y.compression){case o.NO_COMPRESSION:C.lines=1,C.uncompress=G;break;case o.RLE_COMPRESSION:C.lines=1,C.uncompress=Q;break;case o.ZIPS_COMPRESSION:C.lines=1,C.uncompress=a,await p.e.LoadScriptAsync(L.FFLATEUrl);break;case o.ZIP_COMPRESSION:C.lines=16,C.uncompress=a,await p.e.LoadScriptAsync(L.FFLATEUrl);break;case o.PIZ_COMPRESSION:C.lines=32,C.uncompress=z;break;case o.PXR24_COMPRESSION:C.lines=16,C.uncompress=c,await p.e.LoadScriptAsync(L.FFLATEUrl);break;default:throw new Error(o[Y.compression]+" is unsupported")}C.scanlineBlockSize=C.lines;const U={};for(const o of Y.channels)switch(o.name){case"Y":case"R":case"G":case"B":case"A":U[o.name]=!0,C.type=o.pixelType}let y=!1;if(U.R&&U.G&&U.B)y=!U.A,C.outputChannels=4,C.decodeChannels={R:0,G:1,B:2,A:3};else{if(!U.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");C.outputChannels=1,C.decodeChannels={Y:0}}if(1===C.type)switch(x){case E.Float:C.getter=l,C.inputSize=2;break;case E.HalfFloat:C.getter=J,C.inputSize=2}else{if(2!==C.type)throw new Error("Unsupported pixelType "+C.type+" for "+Y.compression);switch(x){case E.Float:C.getter=s,C.inputSize=4;break;case E.HalfFloat:C.getter=h,C.inputSize=4}}C.blockCount=C.height/C.scanlineBlockSize;for(let o=0;o<C.blockCount;o++)T(d,t);const B=C.width*C.height*C.outputChannels;switch(x){case E.Float:C.byteArray=new Float32Array(B),C.textureType=1,y&&C.byteArray.fill(1,0,B);break;case E.HalfFloat:C.byteArray=new Uint16Array(B),C.textureType=2,y&&C.byteArray.fill(15360,0,B);break;default:throw new Error("Unsupported type: "+x)}let W=0;for(const o of Y.channels)void 0!==C.decodeChannels[o.name]&&(C.channelLineOffsets[o.name]=W*C.width),W+=2*o.pixelType;return C.bytesPerLine=C.width*W,C.outLineWidth=C.width*C.outputChannels,"INCREASING_Y"===Y.lineOrder?C.scanOrder=Y=>Y:C.scanOrder=Y=>C.height-1-Y,4==C.outputChannels?(C.format=5,C.linearSpace=!0):(C.format=6,C.linearSpace=!1),C}(y,C,U,L.DefaultOutputType);!function(Y,d,t,x){const C={value:0};for(let U=0;U<Y.height/Y.scanlineBlockSize;U++){const y=b(t,x)-d.dataWindow.yMin;Y.size=m(t,x),Y.lines=y+Y.scanlineBlockSize>Y.height?Y.height-y:Y.scanlineBlockSize;const B=Y.size<Y.lines*Y.bytesPerLine&&Y.uncompress?Y.uncompress(Y):G(Y);x.value+=Y.size;for(let t=0;t<Y.scanlineBlockSize;t++){const x=U*Y.scanlineBlockSize,y=t+Y.scanOrder(x);if(y>=Y.height)continue;const W=t*Y.bytesPerLine,o=(Y.height-1-y)*Y.outLineWidth;for(let t=0;t<Y.channels;t++){const x=d.channels[t].name,U=Y.channelLineOffsets[x],y=Y.decodeChannels[x];if(void 0!==y){C.value=W+U;for(let d=0;d<Y.width;d++){const t=o+d*Y.outputChannels+y;Y.byteArray&&(Y.byteArray[t]=Y.getter(B,C))}}}}}}(B,y,C,U);t(y.dataWindow.xMax-y.dataWindow.xMin+1,y.dataWindow.yMax-y.dataWindow.yMin+1,d.generateMipMaps,!1,(()=>{const Y=d.getEngine();d.format=y.format,d.type=B.textureType,d.invertY=!1,d._gammaSpace=!y.linearSpace,B.byteArray&&Y._uploadDataToTextureDirectly(d,B.byteArray,0,0,void 0,!0)}))}}}}]);