"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[14],{12874:(Y,c,h)=>{h.d(c,{d:()=>Q,h:()=>N,k:()=>C,l:()=>E});const C=1/2.2,E=2.2,N=(1+Math.sqrt(5))/2,Q=.001},12883:(Y,c,h)=>{function C(Y){return parseInt(Y.toString().replace(/\W/g,""))}function E(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Y-c)<=h}function N(Y,c,h){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Y<c-C||Y>h+C}function Q(Y,c){return Y===c?Y:Math.random()*(c-Y)+Y}function b(Y,c,h){return Y+(c-Y)*h}function H(Y,c,h){let C=y(c-Y,360);return C>180&&(C-=360),Y+C*k(h)}function w(Y,c,h){let C=0;return C=Y!=c?k((h-Y)/(c-Y)):0,C}function W(Y,c,h,C,E){const N=E*E,Q=E*N;return Y*(2*Q-3*N+1)+h*(-2*Q+3*N)+c*(Q-2*N+E)+C*(Q-N)}function q(Y,c,h,C,E){const N=E*E;return 6*(N-E)*Y+(3*N-4*E+1)*c+6*(-N+E)*h+(3*N-2*E)*C}function k(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(h,Math.max(c,Y))}function M(Y){return Y-=2*Math.PI*Math.floor((Y+Math.PI)/(2*Math.PI))}function p(Y){const c=Y.toString(16);return Y<=15?("0"+c).toUpperCase():c.toUpperCase()}function P(Y){if(Math.log2)return Math.floor(Math.log2(Y));if(Y<0)return NaN;if(0===Y)return-1/0;let c=0;if(Y<1){for(;Y<1;)c++,Y*=2;c=-c}else if(Y>1)for(;Y>1;)c++,Y=Math.floor(Y/2);return c}function y(Y,c){return Y-Math.floor(Y/c)*c}function d(Y,c,h){return(Y-c)/(h-c)}function D(Y,c,h){return Y*(h-c)+c}function T(Y,c){let h=y(c-Y,360);return h>180&&(h-=360),h}function e(Y,c){const h=y(Y,2*c);return c-Math.abs(h-c)}function r(Y,c,h){let C=k(h);return C=-2*C*C*C+3*C*C,c*C+Y*(1-C)}function X(Y,c,h){let C=0;return C=Math.abs(c-Y)<=h?c:Y+Math.sign(c-Y)*h,C}function Z(Y,c,h){const C=T(Y,c);let E=0;return E=-h<C&&C<h?c:X(Y,c=Y+C,h),E}function a(Y,c,h){return(Y-c)/(h-c)}function G(Y,c,h){return(h-c)*Y+c}function K(Y,c){const h=Y%c;return 0===h?c:K(c,h)}h.r(c),h.d(c,{Clamp:()=>k,DeltaAngle:()=>T,Denormalize:()=>D,ExtractAsInt:()=>C,Hermite:()=>W,Hermite1stDerivative:()=>q,HighestCommonFactor:()=>K,ILog2:()=>P,InverseLerp:()=>w,Lerp:()=>b,LerpAngle:()=>H,MoveTowards:()=>X,MoveTowardsAngle:()=>Z,Normalize:()=>d,NormalizeRadians:()=>M,OutsideRange:()=>N,PercentToRange:()=>G,PingPong:()=>e,RandomRange:()=>Q,RangeToPercent:()=>a,Repeat:()=>y,SmoothStep:()=>r,ToHex:()=>p,WithinEpsilon:()=>E})},12869:(Y,c,h)=>{h.r(c),h.d(c,{Matrix:()=>D,Quaternion:()=>d,TmpVectors:()=>e,Vector2:()=>p,bh:()=>P,Vector4:()=>y});var C=h(12874),E=h(12877),N=h(12825),Q=h(12799),b=h(12722),H=h(12883);class w{}function W(Y,c,h){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const E=Y.Xc(),N=c.Xc(),Q=E[0],b=E[1],H=E[2],w=E[3],W=E[4],q=E[5],k=E[6],M=E[7],p=E[8],P=E[9],y=E[10],d=E[11],D=E[12],T=E[13],e=E[14],r=E[15],X=N[0],Z=N[1],a=N[2],G=N[3],K=N[4],I=N[5],s=N[6],x=N[7],A=N[8],V=N[9],U=N[10],l=N[11],n=N[12],v=N[13],g=N[14],z=N[15];h[C]=Q*X+b*K+H*A+w*n,h[C+1]=Q*Z+b*I+H*V+w*v,h[C+2]=Q*a+b*s+H*U+w*g,h[C+3]=Q*G+b*x+H*l+w*z,h[C+4]=W*X+q*K+k*A+M*n,h[C+5]=W*Z+q*I+k*V+M*v,h[C+6]=W*a+q*s+k*U+M*g,h[C+7]=W*G+q*x+k*l+M*z,h[C+8]=p*X+P*K+y*A+d*n,h[C+9]=p*Z+P*I+y*V+d*v,h[C+10]=p*a+P*s+y*U+d*g,h[C+11]=p*G+P*x+y*l+d*z,h[C+12]=D*X+T*K+e*A+r*n,h[C+13]=D*Z+T*I+e*V+r*v,h[C+14]=D*a+T*s+e*U+r*g,h[C+15]=D*G+T*x+e*l+r*z}function q(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const C=Y.Xc();c[h]=C[0],c[h+1]=C[1],c[h+2]=C[2],c[h+3]=C[3],c[h+4]=C[4],c[h+5]=C[5],c[h+6]=C[6],c[h+7]=C[7],c[h+8]=C[8],c[h+9]=C[9],c[h+10]=C[10],c[h+11]=C[11],c[h+12]=C[12],c[h+13]=C[13],c[h+14]=C[14],c[h+15]=C[15]}function k(Y,c){const h=Y.Xc(),C=h[0],E=h[1],N=h[2],Q=h[3],b=h[4],H=h[5],w=h[6],W=h[7],q=h[8],k=h[9],M=h[10],p=h[11],P=h[12],y=h[13],d=h[14],D=h[15],T=M*D-d*p,e=k*D-y*p,r=k*d-y*M,X=q*D-P*p,Z=q*d-M*P,a=q*y-P*k,G=+(H*T-w*e+W*r),K=-(b*T-w*X+W*Z),I=+(b*e-H*X+W*a),s=-(b*r-H*Z+w*a),x=C*G+E*K+N*I+Q*s;if(0===x)return!1;const A=1/x,V=w*D-d*W,U=H*D-y*W,l=H*d-y*w,n=b*D-P*W,v=b*d-P*w,g=b*y-P*H,z=w*p-M*W,O=H*p-k*W,o=H*M-k*w,f=b*p-q*W,L=b*M-q*w,u=b*k-q*H,i=-(E*T-N*e+Q*r),R=+(C*T-N*X+Q*Z),B=-(C*e-E*X+Q*a),t=+(C*r-E*Z+N*a),F=+(E*V-N*U+Q*l),J=-(C*V-N*n+Q*v),j=+(C*U-E*n+Q*g),S=-(C*l-E*v+N*g),mY=-(E*z-N*O+Q*o),YY=+(C*z-N*f+Q*L),cY=-(C*O-E*f+Q*u),hY=+(C*o-E*L+N*u);return c[0]=G*A,c[1]=i*A,c[2]=F*A,c[3]=mY*A,c[4]=K*A,c[5]=R*A,c[6]=J*A,c[7]=YY*A,c[8]=I*A,c[9]=B*A,c[10]=j*A,c[11]=cY*A,c[12]=s*A,c[13]=t*A,c[14]=S*A,c[15]=hY*A,!0}w._UpdateFlagSeed=0;const M=Y=>parseInt(Y.toString().replace(/\W/g,""));class p{constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=Y,this.y=c}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let Y=M(this.x);return Y=397*Y^M(this.y),Y}toArray(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y[c]=this.x,Y[c+1]=this.y,this}IC(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p.FromArrayToRef(Y,c,this),this}Xc(){return[this.x,this.y]}N(Y){return this.x=Y.x,this.y=Y.y,this}Vc(Y,c){return this.x=Y,this.y=c,this}set(Y,c){return this.Vc(Y,c)}nc(Y){return this.Vc(Y,Y)}add(Y){return new p(this.x+Y.x,this.y+Y.y)}addToRef(Y,c){return c.x=this.x+Y.x,c.y=this.y+Y.y,c}addInPlace(Y){return this.x+=Y.x,this.y+=Y.y,this}addInPlaceFromFloats(Y,c){return this.x+=Y,this.y+=c,this}addVector3(Y){return new p(this.x+Y.x,this.y+Y.y)}Hh(Y){return new p(this.x-Y.x,this.y-Y.y)}subtractToRef(Y,c){return c.x=this.x-Y.x,c.y=this.y-Y.y,c}Lk(Y){return this.x-=Y.x,this.y-=Y.y,this}multiplyInPlace(Y){return this.x*=Y.x,this.y*=Y.y,this}multiply(Y){return new p(this.x*Y.x,this.y*Y.y)}multiplyToRef(Y,c){return c.x=this.x*Y.x,c.y=this.y*Y.y,c}multiplyByFloats(Y,c){return new p(this.x*Y,this.y*c)}divide(Y){return new p(this.x/Y.x,this.y/Y.y)}divideToRef(Y,c){return c.x=this.x/Y.x,c.y=this.y/Y.y,c}divideInPlace(Y){return this.x=this.x/Y.x,this.y=this.y/Y.y,this}minimizeInPlace(Y){return this.minimizeInPlaceFromFloats(Y.x,Y.y)}maximizeInPlace(Y){return this.maximizeInPlaceFromFloats(Y.x,Y.y)}minimizeInPlaceFromFloats(Y,c){return this.x=Math.min(Y,this.x),this.y=Math.min(c,this.y),this}maximizeInPlaceFromFloats(Y,c){return this.x=Math.max(Y,this.x),this.y=Math.max(c,this.y),this}subtractFromFloats(Y,c){return new p(this.x-Y,this.y-c)}subtractFromFloatsToRef(Y,c,h){return h.x=this.x-Y,h.y=this.y-c,h}negate(){return new p(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(Y){return Y.x=-this.x,Y.y=-this.y,Y}scaleInPlace(Y){return this.x*=Y,this.y*=Y,this}scale(Y){return new p(this.x*Y,this.y*Y)}scaleToRef(Y,c){return c.x=this.x*Y,c.y=this.y*Y,c}scaleAndAddToRef(Y,c){return c.x+=this.x*Y,c.y+=this.y*Y,c}equals(Y){return Y&&this.x===Y.x&&this.y===Y.y}equalsWithEpsilon(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.d;return Y&&(0,H.WithinEpsilon)(this.x,Y.x,c)&&(0,H.WithinEpsilon)(this.y,Y.y,c)}equalsToFloats(Y,c){return this.x===Y&&this.y===c}floor(){return new p(Math.floor(this.x),Math.floor(this.y))}floorToRef(Y){return Y.x=Math.floor(this.x),Y.y=Math.floor(this.y),Y}fract(){return new p(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(Y){return Y.x=this.x-Math.floor(this.x),Y.y=this.y-Math.floor(this.y),Y}rotate(Y){return this.rotateToRef(Y,new p)}rotateToRef(Y,c){const h=Math.cos(Y),C=Math.sin(Y);return c.x=h*this.x-C*this.y,c.y=C*this.x+h*this.y,c}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Y){return 0===Y||1===Y?this:this.scaleInPlace(1/Y)}normalizeToNew(){const Y=new p;return this.normalizeToRef(Y),Y}normalizeToRef(Y){const c=this.length();return 0===c&&(Y.x=this.x,Y.y=this.y),this.scaleToRef(1/c,Y)}clone(){return new p(this.x,this.y)}dot(Y){return this.x*Y.x+this.y*Y.y}static Zero(){return new p(0,0)}static One(){return new p(1,1)}static Random(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new p((0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c))}static RandomToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Vc((0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c))}static get ZeroReadOnly(){return p._ZeroReadOnly}static dh(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new p(Y[c],Y[c+1])}static FromArrayToRef(Y,c,h){return h.x=Y[c],h.y=Y[c+1],h}static FromFloatsToRef(Y,c,h){return h.Vc(Y,c),h}static CatmullRom(Y,c,h,C,E){const N=E*E,Q=E*N,b=.5*(2*c.x+(-Y.x+h.x)*E+(2*Y.x-5*c.x+4*h.x-C.x)*N+(-Y.x+3*c.x-3*h.x+C.x)*Q),H=.5*(2*c.y+(-Y.y+h.y)*E+(2*Y.y-5*c.y+4*h.y-C.y)*N+(-Y.y+3*c.y-3*h.y+C.y)*Q);return new p(b,H)}static ClampToRef(Y,c,h,C){return C.x=(0,H.Clamp)(Y.x,c.x,h.x),C.y=(0,H.Clamp)(Y.y,c.y,h.y),C}static Clamp(Y,c,h){const C=(0,H.Clamp)(Y.x,c.x,h.x),E=(0,H.Clamp)(Y.y,c.y,h.y);return new p(C,E)}static Hermite(Y,c,h,C,E){const N=E*E,Q=E*N,b=2*Q-3*N+1,H=-2*Q+3*N,w=Q-2*N+E,W=Q-N,q=Y.x*b+h.x*H+c.x*w+C.x*W,k=Y.y*b+h.y*H+c.y*w+C.y*W;return new p(q,k)}static Hermite1stDerivative(Y,c,h,C,E){return this.Hermite1stDerivativeToRef(Y,c,h,C,E,new p)}static Hermite1stDerivativeToRef(Y,c,h,C,E,N){const Q=E*E;return N.x=6*(Q-E)*Y.x+(3*Q-4*E+1)*c.x+6*(-Q+E)*h.x+(3*Q-2*E)*C.x,N.y=6*(Q-E)*Y.y+(3*Q-4*E+1)*c.y+6*(-Q+E)*h.y+(3*Q-2*E)*C.y,N}static Lerp(Y,c,h){return p.LerpToRef(Y,c,h,new p)}static LerpToRef(Y,c,h,C){return C.x=Y.x+(c.x-Y.x)*h,C.y=Y.y+(c.y-Y.y)*h,C}static Dot(Y,c){return Y.x*c.x+Y.y*c.y}static Normalize(Y){return p.NormalizeToRef(Y,new p)}static NormalizeToRef(Y,c){return Y.normalizeToRef(c),c}static Minimize(Y,c){const h=Y.x<c.x?Y.x:c.x,C=Y.y<c.y?Y.y:c.y;return new p(h,C)}static Maximize(Y,c){const h=Y.x>c.x?Y.x:c.x,C=Y.y>c.y?Y.y:c.y;return new p(h,C)}static Transform(Y,c){return p.TransformToRef(Y,c,new p)}static TransformToRef(Y,c,h){const C=c.m,E=Y.x*C[0]+Y.y*C[4]+C[12],N=Y.x*C[1]+Y.y*C[5]+C[13];return h.x=E,h.y=N,h}static PointInTriangle(Y,c,h,C){const E=.5*(-h.y*C.x+c.y*(-h.x+C.x)+c.x*(h.y-C.y)+h.x*C.y),N=E<0?-1:1,Q=(c.y*C.x-c.x*C.y+(C.y-c.y)*Y.x+(c.x-C.x)*Y.y)*N,b=(c.x*h.y-c.y*h.x+(c.y-h.y)*Y.x+(h.x-c.x)*Y.y)*N;return Q>0&&b>0&&Q+b<2*E*N}static Distance(Y,c){return Math.sqrt(p.DistanceSquared(Y,c))}static DistanceSquared(Y,c){const h=Y.x-c.x,C=Y.y-c.y;return h*h+C*C}static Center(Y,c){return p.CenterToRef(Y,c,new p)}static CenterToRef(Y,c,h){return h.Vc((Y.x+c.x)/2,(Y.y+c.y)/2)}static DistanceOfPointFromSegment(Y,c,h){const C=p.DistanceSquared(c,h);if(0===C)return p.Distance(Y,c);const E=h.Hh(c),N=Math.max(0,Math.min(1,p.Dot(Y.Hh(c),E)/C)),Q=c.add(E.multiplyByFloats(N,N));return p.Distance(Y,Q)}}p._V8PerformanceHack=new p(.5,.5),p._ZeroReadOnly=p.Zero(),Object.defineProperties(p.prototype,{dimension:{value:[2]},rank:{value:1}});class P{get x(){return this._x}set x(Y){this._x=Y,this._isDirty=!0}get y(){return this._y}set y(Y){this._y=Y,this._isDirty=!0}get z(){return this._z}set z(Y){this._z=Y,this._isDirty=!0}constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=Y,this._y=c,this._z=h}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"bh"}getHashCode(){let Y=M(this._x);return Y=397*Y^M(this._y),Y=397*Y^M(this._z),Y}Xc(){return[this._x,this._y,this._z]}toArray(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y[c]=this._x,Y[c+1]=this._y,Y[c+2]=this._z,this}IC(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(Y,c,this),this}toQuaternion(){return d.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(Y){return this._x+=Y._x,this._y+=Y._y,this._z+=Y._z,this._isDirty=!0,this}addInPlaceFromFloats(Y,c,h){return this._x+=Y,this._y+=c,this._z+=h,this._isDirty=!0,this}add(Y){return new P(this._x+Y._x,this._y+Y._y,this._z+Y._z)}addToRef(Y,c){return c._x=this._x+Y._x,c._y=this._y+Y._y,c._z=this._z+Y._z,c._isDirty=!0,c}Lk(Y){return this._x-=Y._x,this._y-=Y._y,this._z-=Y._z,this._isDirty=!0,this}Hh(Y){return new P(this._x-Y._x,this._y-Y._y,this._z-Y._z)}subtractToRef(Y,c){return this.subtractFromFloatsToRef(Y._x,Y._y,Y._z,c)}subtractFromFloats(Y,c,h){return new P(this._x-Y,this._y-c,this._z-h)}subtractFromFloatsToRef(Y,c,h,C){return C._x=this._x-Y,C._y=this._y-c,C._z=this._z-h,C._isDirty=!0,C}negate(){return new P(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(Y){return Y._x=-1*this._x,Y._y=-1*this._y,Y._z=-1*this._z,Y._isDirty=!0,Y}scaleInPlace(Y){return this._x*=Y,this._y*=Y,this._z*=Y,this._isDirty=!0,this}scale(Y){return new P(this._x*Y,this._y*Y,this._z*Y)}scaleToRef(Y,c){return c._x=this._x*Y,c._y=this._y*Y,c._z=this._z*Y,c._isDirty=!0,c}getNormalToRef(Y){const c=this.length();let h=Math.acos(this._y/c);const C=Math.atan2(this._z,this._x);h>Math.PI/2?h-=Math.PI/2:h+=Math.PI/2;const E=c*Math.sin(h)*Math.cos(C),N=c*Math.cos(h),Q=c*Math.sin(h)*Math.sin(C);return Y.set(E,N,Q),Y}applyRotationQuaternionToRef(Y,c){const h=this._x,C=this._y,E=this._z,N=Y._x,Q=Y._y,b=Y._z,H=Y._w,w=2*(Q*E-b*C),W=2*(b*h-N*E),q=2*(N*C-Q*h);return c._x=h+H*w+Q*q-b*W,c._y=C+H*W+b*w-N*q,c._z=E+H*q+N*W-Q*w,c._isDirty=!0,c}applyRotationQuaternionInPlace(Y){return this.applyRotationQuaternionToRef(Y,this)}applyRotationQuaternion(Y){return this.applyRotationQuaternionToRef(Y,new P)}scaleAndAddToRef(Y,c){return c._x+=this._x*Y,c._y+=this._y*Y,c._z+=this._z*Y,c._isDirty=!0,c}projectOnPlane(Y,c){return this.projectOnPlaneToRef(Y,c,new P)}projectOnPlaneToRef(Y,c,h){const C=Y.normal,E=Y.d,N=T.bh[0];this.subtractToRef(c,N),N.normalize();const Q=P.Dot(N,C);if(Math.abs(Q)<1e-10)h.nc(1/0);else{const Y=-(P.Dot(c,C)+E)/Q,b=N.scaleInPlace(Y);c.addToRef(b,h)}return h}equals(Y){return Y&&this._x===Y._x&&this._y===Y._y&&this._z===Y._z}equalsWithEpsilon(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.d;return Y&&(0,H.WithinEpsilon)(this._x,Y._x,c)&&(0,H.WithinEpsilon)(this._y,Y._y,c)&&(0,H.WithinEpsilon)(this._z,Y._z,c)}equalsToFloats(Y,c,h){return this._x===Y&&this._y===c&&this._z===h}multiplyInPlace(Y){return this._x*=Y._x,this._y*=Y._y,this._z*=Y._z,this._isDirty=!0,this}multiply(Y){return this.multiplyByFloats(Y._x,Y._y,Y._z)}multiplyToRef(Y,c){return c._x=this._x*Y._x,c._y=this._y*Y._y,c._z=this._z*Y._z,c._isDirty=!0,c}multiplyByFloats(Y,c,h){return new P(this._x*Y,this._y*c,this._z*h)}divide(Y){return new P(this._x/Y._x,this._y/Y._y,this._z/Y._z)}divideToRef(Y,c){return c._x=this._x/Y._x,c._y=this._y/Y._y,c._z=this._z/Y._z,c._isDirty=!0,c}divideInPlace(Y){return this._x=this._x/Y._x,this._y=this._y/Y._y,this._z=this._z/Y._z,this._isDirty=!0,this}minimizeInPlace(Y){return this.minimizeInPlaceFromFloats(Y._x,Y._y,Y._z)}maximizeInPlace(Y){return this.maximizeInPlaceFromFloats(Y._x,Y._y,Y._z)}minimizeInPlaceFromFloats(Y,c,h){return Y<this._x&&(this.x=Y),c<this._y&&(this.y=c),h<this._z&&(this.z=h),this}maximizeInPlaceFromFloats(Y,c,h){return Y>this._x&&(this.x=Y),c>this._y&&(this.y=c),h>this._z&&(this.z=h),this}isNonUniformWithinEpsilon(Y){const c=Math.abs(this._x),h=Math.abs(this._y);if(!(0,H.WithinEpsilon)(c,h,Y))return!0;const C=Math.abs(this._z);return!(0,H.WithinEpsilon)(c,C,Y)||!(0,H.WithinEpsilon)(h,C,Y)}get isNonUniform(){const Y=Math.abs(this._x);if(Y!==Math.abs(this._y))return!0;return Y!==Math.abs(this._z)}floorToRef(Y){return Y._x=Math.floor(this._x),Y._y=Math.floor(this._y),Y._z=Math.floor(this._z),Y._isDirty=!0,Y}floor(){return new P(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(Y){return Y._x=this._x-Math.floor(this._x),Y._y=this._y-Math.floor(this._y),Y._z=this._z-Math.floor(this._z),Y._isDirty=!0,Y}fract(){return new P(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(Y){if("xyz"===(Y=Y.toLowerCase()))return this;const c=T.bh[0].N(this);return this.x=c[Y[0]],this.y=c[Y[1]],this.z=c[Y[2]],this}rotateByQuaternionToRef(Y,c){return Y.toRotationMatrix(T.Matrix[0]),P.TransformCoordinatesToRef(this,T.Matrix[0],c),c}rotateByQuaternionAroundPointToRef(Y,c,h){return this.subtractToRef(c,T.bh[0]),T.bh[0].rotateByQuaternionToRef(Y,T.bh[0]),c.addToRef(T.bh[0],h),h}cross(Y){return P.CrossToRef(this,Y,new P)}normalizeFromLength(Y){return 0===Y||1===Y?this:this.scaleInPlace(1/Y)}normalizeToNew(){return this.normalizeToRef(new P)}normalizeToRef(Y){const c=this.length();return 0===c||1===c?(Y._x=this._x,Y._y=this._y,Y._z=this._z,Y._isDirty=!0,Y):this.scaleToRef(1/c,Y)}clone(){return new P(this._x,this._y,this._z)}N(Y){return this.Vc(Y._x,Y._y,Y._z)}Vc(Y,c,h){return this._x=Y,this._y=c,this._z=h,this._isDirty=!0,this}set(Y,c,h){return this.Vc(Y,c,h)}nc(Y){return this._x=this._y=this._z=Y,this._isDirty=!0,this}static GetClipFactor(Y,c,h,C){const E=P.Dot(Y,h);return(E-C)/(E-P.Dot(c,h))}static GetAngleBetweenVectors(Y,c,h){const C=Y.normalizeToRef(T.bh[1]),E=c.normalizeToRef(T.bh[2]);let N=P.Dot(C,E);N=(0,H.Clamp)(N,-1,1);const Q=Math.acos(N),b=T.bh[3];return P.CrossToRef(C,E,b),P.Dot(b,h)>0?isNaN(Q)?0:Q:isNaN(Q)?-Math.PI:-Math.acos(N)}static GetAngleBetweenVectorsOnPlane(Y,c,h){T.bh[0].N(Y);const C=T.bh[0];T.bh[1].N(c);const E=T.bh[1];T.bh[2].N(h);const N=T.bh[2],Q=T.bh[3],b=T.bh[4];C.normalize(),E.normalize(),N.normalize(),P.CrossToRef(N,C,Q),P.CrossToRef(Q,N,b);const w=Math.atan2(P.Dot(E,Q),P.Dot(E,b));return(0,H.NormalizeRadians)(w)}static PitchYawRollToMoveBetweenPointsToRef(Y,c,h){const C=e.bh[0];return c.subtractToRef(Y,C),h._y=Math.atan2(C.x,C.z)||0,h._x=Math.atan2(Math.sqrt(C.x**2+C.z**2),C.y)||0,h._z=0,h._isDirty=!0,h}static PitchYawRollToMoveBetweenPoints(Y,c){const h=P.Zero();return P.PitchYawRollToMoveBetweenPointsToRef(Y,c,h)}static SlerpToRef(Y,c,h,E){h=(0,H.Clamp)(h,0,1);const N=T.bh[0],Q=T.bh[1];N.N(Y);const b=N.length();N.normalizeFromLength(b),Q.N(c);const w=Q.length();Q.normalizeFromLength(w);const W=P.Dot(N,Q);let q,k;if(W<1-C.d){const Y=Math.acos(W),c=1/Math.sin(Y);q=Math.sin((1-h)*Y)*c,k=Math.sin(h*Y)*c}else q=1-h,k=h;return N.scaleInPlace(q),Q.scaleInPlace(k),E.N(N).addInPlace(Q),E.scaleInPlace((0,H.Lerp)(b,w,h)),E}static SmoothToRef(Y,c,h,C,E){return P.SlerpToRef(Y,c,0===C?1:h/C,E),E}static dh(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new P(Y[c],Y[c+1],Y[c+2])}static FromFloatArray(Y,c){return P.dh(Y,c)}static FromArrayToRef(Y,c,h){return h._x=Y[c],h._y=Y[c+1],h._z=Y[c+2],h._isDirty=!0,h}static FromFloatArrayToRef(Y,c,h){return P.FromArrayToRef(Y,c,h)}static FromFloatsToRef(Y,c,h,C){return C.Vc(Y,c,h),C}static Zero(){return new P(0,0,0)}static One(){return new P(1,1,1)}static Up(){return new P(0,1,0)}static get UpReadOnly(){return P._UpReadOnly}static get DownReadOnly(){return P._DownReadOnly}static get RightReadOnly(){return P._RightReadOnly}static get LeftReadOnly(){return P._LeftReadOnly}static get LeftHandedForwardReadOnly(){return P._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return P._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return P._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return P._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return P._ZeroReadOnly}static get OneReadOnly(){return P._OneReadOnly}static Down(){return new P(0,-1,0)}static Forward(){return new P(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new P(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new P(1,0,0)}static Left(){return new P(-1,0,0)}static Random(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new P((0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c))}static RandomToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Vc((0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c))}static TransformCoordinates(Y,c){const h=P.Zero();return P.TransformCoordinatesToRef(Y,c,h),h}static TransformCoordinatesToRef(Y,c,h){return P.TransformCoordinatesFromFloatsToRef(Y._x,Y._y,Y._z,c,h),h}static TransformCoordinatesFromFloatsToRef(Y,c,h,C,E){const N=C.m,Q=Y*N[0]+c*N[4]+h*N[8]+N[12],b=Y*N[1]+c*N[5]+h*N[9]+N[13],H=Y*N[2]+c*N[6]+h*N[10]+N[14],w=1/(Y*N[3]+c*N[7]+h*N[11]+N[15]);return E._x=Q*w,E._y=b*w,E._z=H*w,E._isDirty=!0,E}static TransformNormal(Y,c){const h=P.Zero();return P.TransformNormalToRef(Y,c,h),h}static TransformNormalToRef(Y,c,h){return this.TransformNormalFromFloatsToRef(Y._x,Y._y,Y._z,c,h),h}static TransformNormalFromFloatsToRef(Y,c,h,C,E){const N=C.m;return E._x=Y*N[0]+c*N[4]+h*N[8],E._y=Y*N[1]+c*N[5]+h*N[9],E._z=Y*N[2]+c*N[6]+h*N[10],E._isDirty=!0,E}static CatmullRom(Y,c,h,C,E){const N=E*E,Q=E*N,b=.5*(2*c._x+(-Y._x+h._x)*E+(2*Y._x-5*c._x+4*h._x-C._x)*N+(-Y._x+3*c._x-3*h._x+C._x)*Q),H=.5*(2*c._y+(-Y._y+h._y)*E+(2*Y._y-5*c._y+4*h._y-C._y)*N+(-Y._y+3*c._y-3*h._y+C._y)*Q),w=.5*(2*c._z+(-Y._z+h._z)*E+(2*Y._z-5*c._z+4*h._z-C._z)*N+(-Y._z+3*c._z-3*h._z+C._z)*Q);return new P(b,H,w)}static Clamp(Y,c,h){const C=new P;return P.ClampToRef(Y,c,h,C),C}static ClampToRef(Y,c,h,C){let E=Y._x;E=E>h._x?h._x:E,E=E<c._x?c._x:E;let N=Y._y;N=N>h._y?h._y:N,N=N<c._y?c._y:N;let Q=Y._z;return Q=Q>h._z?h._z:Q,Q=Q<c._z?c._z:Q,C.Vc(E,N,Q),C}static CheckExtends(Y,c,h){c.minimizeInPlace(Y),h.maximizeInPlace(Y)}static Hermite(Y,c,h,C,E){const N=E*E,Q=E*N,b=2*Q-3*N+1,H=-2*Q+3*N,w=Q-2*N+E,W=Q-N,q=Y._x*b+h._x*H+c._x*w+C._x*W,k=Y._y*b+h._y*H+c._y*w+C._y*W,M=Y._z*b+h._z*H+c._z*w+C._z*W;return new P(q,k,M)}static Hermite1stDerivative(Y,c,h,C,E){const N=new P;return this.Hermite1stDerivativeToRef(Y,c,h,C,E,N),N}static Hermite1stDerivativeToRef(Y,c,h,C,E,N){const Q=E*E;return N._x=6*(Q-E)*Y._x+(3*Q-4*E+1)*c._x+6*(-Q+E)*h._x+(3*Q-2*E)*C._x,N._y=6*(Q-E)*Y._y+(3*Q-4*E+1)*c._y+6*(-Q+E)*h._y+(3*Q-2*E)*C._y,N._z=6*(Q-E)*Y._z+(3*Q-4*E+1)*c._z+6*(-Q+E)*h._z+(3*Q-2*E)*C._z,N._isDirty=!0,N}static Lerp(Y,c,h){const C=new P(0,0,0);return P.LerpToRef(Y,c,h,C),C}static LerpToRef(Y,c,h,C){return C._x=Y._x+(c._x-Y._x)*h,C._y=Y._y+(c._y-Y._y)*h,C._z=Y._z+(c._z-Y._z)*h,C._isDirty=!0,C}static Dot(Y,c){return Y._x*c._x+Y._y*c._y+Y._z*c._z}dot(Y){return this._x*Y._x+this._y*Y._y+this._z*Y._z}static Cross(Y,c){const h=new P;return P.CrossToRef(Y,c,h),h}static CrossToRef(Y,c,h){const C=Y._y*c._z-Y._z*c._y,E=Y._z*c._x-Y._x*c._z,N=Y._x*c._y-Y._y*c._x;return h.Vc(C,E,N),h}static Normalize(Y){const c=P.Zero();return P.NormalizeToRef(Y,c),c}static NormalizeToRef(Y,c){return Y.normalizeToRef(c),c}static Project(Y,c,h,C){const E=new P;return P.ProjectToRef(Y,c,h,C,E),E}static ProjectToRef(Y,c,h,C,E){var N;const Q=C.width,H=C.height,w=C.x,W=C.y,q=T.Matrix[1],k=null===(N=b.d.LastCreatedEngine)||void 0===N?void 0:N.isNDCHalfZRange,M=k?1:.5,p=k?0:.5;D.FromValuesToRef(Q/2,0,0,0,0,-H/2,0,0,0,0,M,0,w+Q/2,H/2+W,p,1,q);const y=T.Matrix[0];return c.multiplyToRef(h,y),y.multiplyToRef(q,y),P.TransformCoordinatesToRef(Y,y,E),E}static Reflect(Y,c){return this.ReflectToRef(Y,c,new P)}static ReflectToRef(Y,c,h){const C=e.bh[0];return C.N(c).scaleInPlace(2*P.Dot(Y,c)),h.N(Y).Lk(C)}static _UnprojectFromInvertedMatrixToRef(Y,c,h){P.TransformCoordinatesToRef(Y,c,h);const C=c.m,E=Y._x*C[3]+Y._y*C[7]+Y._z*C[11]+C[15];return(0,H.WithinEpsilon)(E,1)&&h.scaleInPlace(1/E),h}static UnprojectFromTransform(Y,c,h,C,E){return this.Unproject(Y,c,h,C,E,D.IdentityReadOnly)}static Unproject(Y,c,h,C,E,N){const Q=new P;return P.UnprojectToRef(Y,c,h,C,E,N,Q),Q}static UnprojectToRef(Y,c,h,C,E,N,Q){return P.UnprojectFloatsToRef(Y._x,Y._y,Y._z,c,h,C,E,N,Q),Q}static UnprojectFloatsToRef(Y,c,h,C,E,N,Q,H,w){var W;const q=T.Matrix[0];N.multiplyToRef(Q,q),q.multiplyToRef(H,q),q.invert();const k=T.bh[0];return k.x=Y/C*2-1,k.y=-(c/E*2-1),null!==(W=b.d.LastCreatedEngine)&&void 0!==W&&W.isNDCHalfZRange?k.z=h:k.z=2*h-1,P._UnprojectFromInvertedMatrixToRef(k,q,w),w}static Minimize(Y,c){const h=new P;return h.N(Y),h.minimizeInPlace(c),h}static Maximize(Y,c){const h=new P;return h.N(Y),h.maximizeInPlace(c),h}static Distance(Y,c){return Math.sqrt(P.DistanceSquared(Y,c))}static DistanceSquared(Y,c){const h=Y._x-c._x,C=Y._y-c._y,E=Y._z-c._z;return h*h+C*C+E*E}static ProjectOnTriangleToRef(Y,c,h,E,N){const Q=T.bh[0],b=T.bh[1],w=T.bh[2],W=T.bh[3],q=T.bh[4];h.subtractToRef(c,Q),E.subtractToRef(c,b),E.subtractToRef(h,w);const k=Q.length(),M=b.length(),p=w.length();if(k<C.d||M<C.d||p<C.d)return N.N(c),P.Distance(Y,c);Y.subtractToRef(c,q),P.CrossToRef(Q,b,W);const y=W.length();if(y<C.d)return N.N(c),P.Distance(Y,c);W.normalizeFromLength(y);let d=q.length();if(d<C.d)return N.N(c),0;q.normalizeFromLength(d);const D=P.Dot(W,q),e=T.bh[5],r=T.bh[6];e.N(W).scaleInPlace(-d*D),r.N(Y).addInPlace(e);const X=T.bh[4],Z=T.bh[5],a=T.bh[7],G=T.bh[8];X.N(Q).scaleInPlace(1/k),G.N(b).scaleInPlace(1/M),X.addInPlace(G).scaleInPlace(-1),Z.N(Q).scaleInPlace(-1/k),G.N(w).scaleInPlace(1/p),Z.addInPlace(G).scaleInPlace(-1),a.N(w).scaleInPlace(-1/p),G.N(b).scaleInPlace(-1/M),a.addInPlace(G).scaleInPlace(-1);const K=T.bh[9];let I;K.N(r).Lk(c),P.CrossToRef(X,K,G),I=P.Dot(G,W);const s=I;K.N(r).Lk(h),P.CrossToRef(Z,K,G),I=P.Dot(G,W);const x=I;K.N(r).Lk(E),P.CrossToRef(a,K,G),I=P.Dot(G,W);const A=I,V=T.bh[10];let U,l;s>0&&x<0?(V.N(Q),U=c,l=h):x>0&&A<0?(V.N(w),U=h,l=E):(V.N(b).scaleInPlace(-1),U=E,l=c);const n=T.bh[9],v=T.bh[4];U.subtractToRef(r,G),l.subtractToRef(r,n),P.CrossToRef(G,n,v);if(!(P.Dot(v,W)<0))return N.N(r),Math.abs(d*D);const g=T.bh[5];P.CrossToRef(V,v,g),g.normalize();const z=T.bh[9];z.N(U).Lk(r);const O=z.length();if(O<C.d)return N.N(U),P.Distance(Y,U);z.normalizeFromLength(O);const o=P.Dot(g,z),f=T.bh[7];f.N(r).addInPlace(g.scaleInPlace(O*o)),G.N(f).Lk(U),d=V.length(),V.normalizeFromLength(d);let L=P.Dot(G,V)/Math.max(d,C.d);return L=(0,H.Clamp)(L,0,1),f.N(U).addInPlace(V.scaleInPlace(L*d)),N.N(f),P.Distance(Y,f)}static Center(Y,c){return P.CenterToRef(Y,c,P.Zero())}static CenterToRef(Y,c,h){return h.Vc((Y._x+c._x)/2,(Y._y+c._y)/2,(Y._z+c._z)/2)}static RotationFromAxis(Y,c,h){const C=new P;return P.RotationFromAxisToRef(Y,c,h,C),C}static RotationFromAxisToRef(Y,c,h,C){const E=T.Quaternion[0];return d.RotationQuaternionFromAxisToRef(Y,c,h,E),E.toEulerAnglesToRef(C),C}}P._V8PerformanceHack=new P(.5,.5,.5),P._UpReadOnly=P.Up(),P._DownReadOnly=P.Down(),P._LeftHandedForwardReadOnly=P.Forward(!1),P._RightHandedForwardReadOnly=P.Forward(!0),P._LeftHandedBackwardReadOnly=P.Backward(!1),P._RightHandedBackwardReadOnly=P.Backward(!0),P._RightReadOnly=P.Right(),P._LeftReadOnly=P.Left(),P._ZeroReadOnly=P.Zero(),P._OneReadOnly=P.One(),Object.defineProperties(P.prototype,{dimension:{value:[3]},rank:{value:1}});class y{get x(){return this._x}set x(Y){this._x=Y,this._isDirty=!0}get y(){return this._y}set y(Y){this._y=Y,this._isDirty=!0}get z(){return this._z}set z(Y){this._z=Y,this._isDirty=!0}get w(){return this._w}set w(Y){this._w=Y,this._isDirty=!0}constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=Y,this._y=c,this._z=h,this._w=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let Y=M(this._x);return Y=397*Y^M(this._y),Y=397*Y^M(this._z),Y=397*Y^M(this._w),Y}Xc(){return[this._x,this._y,this._z,this._w]}toArray(Y,c){return void 0===c&&(c=0),Y[c]=this._x,Y[c+1]=this._y,Y[c+2]=this._z,Y[c+3]=this._w,this}IC(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y.FromArrayToRef(Y,c,this),this}addInPlace(Y){return this.x+=Y._x,this.y+=Y._y,this.z+=Y._z,this.w+=Y._w,this}addInPlaceFromFloats(Y,c,h,C){return this.x+=Y,this.y+=c,this.z+=h,this.w+=C,this}add(Y){return new y(this._x+Y.x,this._y+Y.y,this._z+Y.z,this._w+Y.w)}addToRef(Y,c){return c.x=this._x+Y.x,c.y=this._y+Y.y,c.z=this._z+Y.z,c.w=this._w+Y.w,c}Lk(Y){return this.x-=Y.x,this.y-=Y.y,this.z-=Y.z,this.w-=Y.w,this}Hh(Y){return new y(this._x-Y.x,this._y-Y.y,this._z-Y.z,this._w-Y.w)}subtractToRef(Y,c){return c.x=this._x-Y.x,c.y=this._y-Y.y,c.z=this._z-Y.z,c.w=this._w-Y.w,c}subtractFromFloats(Y,c,h,C){return new y(this._x-Y,this._y-c,this._z-h,this._w-C)}subtractFromFloatsToRef(Y,c,h,C,E){return E.x=this._x-Y,E.y=this._y-c,E.z=this._z-h,E.w=this._w-C,E}negate(){return new y(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(Y){return Y.x=-this._x,Y.y=-this._y,Y.z=-this._z,Y.w=-this._w,Y}scaleInPlace(Y){return this.x*=Y,this.y*=Y,this.z*=Y,this.w*=Y,this}scale(Y){return new y(this._x*Y,this._y*Y,this._z*Y,this._w*Y)}scaleToRef(Y,c){return c.x=this._x*Y,c.y=this._y*Y,c.z=this._z*Y,c.w=this._w*Y,c}scaleAndAddToRef(Y,c){return c.x+=this._x*Y,c.y+=this._y*Y,c.z+=this._z*Y,c.w+=this._w*Y,c}equals(Y){return Y&&this._x===Y.x&&this._y===Y.y&&this._z===Y.z&&this._w===Y.w}equalsWithEpsilon(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.d;return Y&&(0,H.WithinEpsilon)(this._x,Y.x,c)&&(0,H.WithinEpsilon)(this._y,Y.y,c)&&(0,H.WithinEpsilon)(this._z,Y.z,c)&&(0,H.WithinEpsilon)(this._w,Y.w,c)}equalsToFloats(Y,c,h,C){return this._x===Y&&this._y===c&&this._z===h&&this._w===C}multiplyInPlace(Y){return this.x*=Y.x,this.y*=Y.y,this.z*=Y.z,this.w*=Y.w,this}multiply(Y){return new y(this._x*Y.x,this._y*Y.y,this._z*Y.z,this._w*Y.w)}multiplyToRef(Y,c){return c.x=this._x*Y.x,c.y=this._y*Y.y,c.z=this._z*Y.z,c.w=this._w*Y.w,c}multiplyByFloats(Y,c,h,C){return new y(this._x*Y,this._y*c,this._z*h,this._w*C)}divide(Y){return new y(this._x/Y.x,this._y/Y.y,this._z/Y.z,this._w/Y.w)}divideToRef(Y,c){return c.x=this._x/Y.x,c.y=this._y/Y.y,c.z=this._z/Y.z,c.w=this._w/Y.w,c}divideInPlace(Y){return this.divideToRef(Y,this)}minimizeInPlace(Y){return Y.x<this._x&&(this.x=Y.x),Y.y<this._y&&(this.y=Y.y),Y.z<this._z&&(this.z=Y.z),Y.w<this._w&&(this.w=Y.w),this}maximizeInPlace(Y){return Y.x>this._x&&(this.x=Y.x),Y.y>this._y&&(this.y=Y.y),Y.z>this._z&&(this.z=Y.z),Y.w>this._w&&(this.w=Y.w),this}minimizeInPlaceFromFloats(Y,c,h,C){return this.x=Math.min(Y,this._x),this.y=Math.min(c,this._y),this.z=Math.min(h,this._z),this.w=Math.min(C,this._w),this}maximizeInPlaceFromFloats(Y,c,h,C){return this.x=Math.max(Y,this._x),this.y=Math.max(c,this._y),this.z=Math.max(h,this._z),this.w=Math.max(C,this._w),this}floorToRef(Y){return Y.x=Math.floor(this._x),Y.y=Math.floor(this._y),Y.z=Math.floor(this._z),Y.w=Math.floor(this._w),Y}floor(){return new y(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(Y){return Y.x=this._x-Math.floor(this._x),Y.y=this._y-Math.floor(this._y),Y.z=this._z-Math.floor(this._z),Y.w=this._w-Math.floor(this._w),Y}fract(){return new y(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Y){return 0===Y||1===Y?this:this.scaleInPlace(1/Y)}normalizeToNew(){return this.normalizeToRef(new y)}normalizeToRef(Y){const c=this.length();return 0===c||1===c?(Y.x=this._x,Y.y=this._y,Y.z=this._z,Y.w=this._w,Y):this.scaleToRef(1/c,Y)}toVector3(){return new P(this._x,this._y,this._z)}clone(){return new y(this._x,this._y,this._z,this._w)}N(Y){return this.x=Y.x,this.y=Y.y,this.z=Y.z,this.w=Y.w,this}Vc(Y,c,h,C){return this.x=Y,this.y=c,this.z=h,this.w=C,this}set(Y,c,h,C){return this.Vc(Y,c,h,C)}nc(Y){return this.x=this.y=this.z=this.w=Y,this}dot(Y){return this._x*Y.x+this._y*Y.y+this._z*Y.z+this._w*Y.w}static dh(Y,c){return c||(c=0),new y(Y[c],Y[c+1],Y[c+2],Y[c+3])}static FromArrayToRef(Y,c,h){return h.x=Y[c],h.y=Y[c+1],h.z=Y[c+2],h.w=Y[c+3],h}static FromFloatArrayToRef(Y,c,h){return y.FromArrayToRef(Y,c,h),h}static FromFloatsToRef(Y,c,h,C,E){return E.x=Y,E.y=c,E.z=h,E.w=C,E}static Zero(){return new y(0,0,0,0)}static One(){return new y(1,1,1,1)}static Random(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new y((0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c))}static RandomToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0;return h.x=(0,H.RandomRange)(Y,c),h.y=(0,H.RandomRange)(Y,c),h.z=(0,H.RandomRange)(Y,c),h.w=(0,H.RandomRange)(Y,c),h}static Clamp(Y,c,h){return y.ClampToRef(Y,c,h,new y)}static ClampToRef(Y,c,h,C){return C.x=(0,H.Clamp)(Y.x,c.x,h.x),C.y=(0,H.Clamp)(Y.y,c.y,h.y),C.z=(0,H.Clamp)(Y.z,c.z,h.z),C.w=(0,H.Clamp)(Y.w,c.w,h.w),C}static CheckExtends(Y,c,h){c.minimizeInPlace(Y),h.maximizeInPlace(Y)}static get ZeroReadOnly(){return y._ZeroReadOnly}static Normalize(Y){return y.NormalizeToRef(Y,new y)}static NormalizeToRef(Y,c){return Y.normalizeToRef(c),c}static Minimize(Y,c){const h=new y;return h.N(Y),h.minimizeInPlace(c),h}static Maximize(Y,c){const h=new y;return h.N(Y),h.maximizeInPlace(c),h}static Distance(Y,c){return Math.sqrt(y.DistanceSquared(Y,c))}static DistanceSquared(Y,c){const h=Y.x-c.x,C=Y.y-c.y,E=Y.z-c.z,N=Y.w-c.w;return h*h+C*C+E*E+N*N}static Center(Y,c){return y.CenterToRef(Y,c,new y)}static CenterToRef(Y,c,h){return h.x=(Y.x+c.x)/2,h.y=(Y.y+c.y)/2,h.z=(Y.z+c.z)/2,h.w=(Y.w+c.w)/2,h}static TransformCoordinates(Y,c){return y.TransformCoordinatesToRef(Y,c,new y)}static TransformCoordinatesToRef(Y,c,h){return y.TransformCoordinatesFromFloatsToRef(Y._x,Y._y,Y._z,c,h),h}static TransformCoordinatesFromFloatsToRef(Y,c,h,C,E){const N=C.m,Q=Y*N[0]+c*N[4]+h*N[8]+N[12],b=Y*N[1]+c*N[5]+h*N[9]+N[13],H=Y*N[2]+c*N[6]+h*N[10]+N[14],w=Y*N[3]+c*N[7]+h*N[11]+N[15];return E.x=Q,E.y=b,E.z=H,E.w=w,E}static TransformNormal(Y,c){return y.TransformNormalToRef(Y,c,new y)}static TransformNormalToRef(Y,c,h){const C=c.m,E=Y.x*C[0]+Y.y*C[4]+Y.z*C[8],N=Y.x*C[1]+Y.y*C[5]+Y.z*C[9],Q=Y.x*C[2]+Y.y*C[6]+Y.z*C[10];return h.x=E,h.y=N,h.z=Q,h.w=Y.w,h}static TransformNormalFromFloatsToRef(Y,c,h,C,E,N){const Q=E.m;return N.x=Y*Q[0]+c*Q[4]+h*Q[8],N.y=Y*Q[1]+c*Q[5]+h*Q[9],N.z=Y*Q[2]+c*Q[6]+h*Q[10],N.w=C,N}static FromVector3(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new y(Y._x,Y._y,Y._z,c)}static Dot(Y,c){return Y.x*c.x+Y.y*c.y+Y.z*c.z+Y.w*c.w}}y._V8PerformanceHack=new y(.5,.5,.5,.5),y._ZeroReadOnly=y.Zero(),Object.defineProperties(y.prototype,{dimension:{value:[4]},rank:{value:1}});class d{get x(){return this._x}set x(Y){this._x=Y,this._isDirty=!0}get y(){return this._y}set y(Y){this._y=Y,this._isDirty=!0}get z(){return this._z}set z(Y){this._z=Y,this._isDirty=!0}get w(){return this._w}set w(Y){this._w=Y,this._isDirty=!0}constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=Y,this._y=c,this._z=h,this._w=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let Y=M(this._x);return Y=397*Y^M(this._y),Y=397*Y^M(this._z),Y=397*Y^M(this._w),Y}Xc(){return[this._x,this._y,this._z,this._w]}toArray(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y[c]=this._x,Y[c+1]=this._y,Y[c+2]=this._z,Y[c+3]=this._w,this}IC(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return d.FromArrayToRef(Y,c,this)}equals(Y){return Y&&this._x===Y._x&&this._y===Y._y&&this._z===Y._z&&this._w===Y._w}equalsWithEpsilon(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.d;return Y&&(0,H.WithinEpsilon)(this._x,Y._x,c)&&(0,H.WithinEpsilon)(this._y,Y._y,c)&&(0,H.WithinEpsilon)(this._z,Y._z,c)&&(0,H.WithinEpsilon)(this._w,Y._w,c)}isApprox(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.d;return Y&&((0,H.WithinEpsilon)(this._x,Y._x,c)&&(0,H.WithinEpsilon)(this._y,Y._y,c)&&(0,H.WithinEpsilon)(this._z,Y._z,c)&&(0,H.WithinEpsilon)(this._w,Y._w,c)||(0,H.WithinEpsilon)(this._x,-Y._x,c)&&(0,H.WithinEpsilon)(this._y,-Y._y,c)&&(0,H.WithinEpsilon)(this._z,-Y._z,c)&&(0,H.WithinEpsilon)(this._w,-Y._w,c))}clone(){return new d(this._x,this._y,this._z,this._w)}N(Y){return this._x=Y._x,this._y=Y._y,this._z=Y._z,this._w=Y._w,this._isDirty=!0,this}Vc(Y,c,h,C){return this._x=Y,this._y=c,this._z=h,this._w=C,this._isDirty=!0,this}set(Y,c,h,C){return this.Vc(Y,c,h,C)}nc(Y){return this.Vc(Y,Y,Y,Y)}add(Y){return new d(this._x+Y._x,this._y+Y._y,this._z+Y._z,this._w+Y._w)}addInPlace(Y){return this._x+=Y._x,this._y+=Y._y,this._z+=Y._z,this._w+=Y._w,this._isDirty=!0,this}addToRef(Y,c){return c._x=this._x+Y._x,c._y=this._y+Y._y,c._z=this._z+Y._z,c._w=this._w+Y._w,c._isDirty=!0,c}addInPlaceFromFloats(Y,c,h,C){return this._x+=Y,this._y+=c,this._z+=h,this._w+=C,this._isDirty=!0,this}subtractToRef(Y,c){return c._x=this._x-Y._x,c._y=this._y-Y._y,c._z=this._z-Y._z,c._w=this._w-Y._w,c._isDirty=!0,c}subtractFromFloats(Y,c,h,C){return this.subtractFromFloatsToRef(Y,c,h,C,new d)}subtractFromFloatsToRef(Y,c,h,C,E){return E._x=this._x-Y,E._y=this._y-c,E._z=this._z-h,E._w=this._w-C,E._isDirty=!0,E}Hh(Y){return new d(this._x-Y._x,this._y-Y._y,this._z-Y._z,this._w-Y._w)}Lk(Y){return this._x-=Y._x,this._y-=Y._y,this._z-=Y._z,this._w-=Y._w,this._isDirty=!0,this}scale(Y){return new d(this._x*Y,this._y*Y,this._z*Y,this._w*Y)}scaleToRef(Y,c){return c._x=this._x*Y,c._y=this._y*Y,c._z=this._z*Y,c._w=this._w*Y,c._isDirty=!0,c}scaleInPlace(Y){return this._x*=Y,this._y*=Y,this._z*=Y,this._w*=Y,this._isDirty=!0,this}scaleAndAddToRef(Y,c){return c._x+=this._x*Y,c._y+=this._y*Y,c._z+=this._z*Y,c._w+=this._w*Y,c._isDirty=!0,c}multiply(Y){const c=new d(0,0,0,1);return this.multiplyToRef(Y,c),c}multiplyToRef(Y,c){const h=this._x*Y._w+this._y*Y._z-this._z*Y._y+this._w*Y._x,C=-this._x*Y._z+this._y*Y._w+this._z*Y._x+this._w*Y._y,E=this._x*Y._y-this._y*Y._x+this._z*Y._w+this._w*Y._z,N=-this._x*Y._x-this._y*Y._y-this._z*Y._z+this._w*Y._w;return c.Vc(h,C,E,N),c}multiplyInPlace(Y){return this.multiplyToRef(Y,this)}multiplyByFloats(Y,c,h,C){return this._x*=Y,this._y*=c,this._z*=h,this._w*=C,this._isDirty=!0,this}divide(Y){throw new ReferenceError("Can not divide a quaternion")}divideToRef(Y,c){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(Y){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new d)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(Y){return Y._x=-this._x,Y._y=-this._y,Y._z=-this._z,Y._w=-this._w,Y._isDirty=!0,Y}equalsToFloats(Y,c,h,C){return this._x===Y&&this._y===c&&this._z===h&&this._w===C}floorToRef(Y){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(Y){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(Y){return Y.Vc(-this._x,-this._y,-this._z,this._w),Y}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new d(-this._x,-this._y,-this._z,this._w)}invert(){const Y=this.conjugate(),c=this.lengthSquared();return 0==c||1==c||Y.scaleInPlace(1/c),Y}invertInPlace(){this.conjugateInPlace();const Y=this.lengthSquared();return 0==Y||1==Y||this.scaleInPlace(1/Y),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Y){return 0===Y||1===Y?this:this.scaleInPlace(1/Y)}normalizeToNew(){const Y=new d(0,0,0,1);return this.normalizeToRef(Y),Y}normalizeToRef(Y){const c=this.length();return 0===c||1===c?Y.Vc(this._x,this._y,this._z,this._w):this.scaleToRef(1/c,Y)}toEulerAngles(){const Y=P.Zero();return this.toEulerAnglesToRef(Y),Y}toEulerAnglesToRef(Y){const c=this._z,h=this._x,C=this._y,E=this._w,N=C*c-h*E,Q=.4999999;if(N<-Q)Y._y=2*Math.atan2(C,E),Y._x=Math.PI/2,Y._z=0,Y._isDirty=!0;else if(N>Q)Y._y=2*Math.atan2(C,E),Y._x=-Math.PI/2,Y._z=0,Y._isDirty=!0;else{const Q=E*E,b=c*c,H=h*h,w=C*C;Y._z=Math.atan2(2*(h*C+c*E),-b-H+w+Q),Y._x=Math.asin(-2*N),Y._y=Math.atan2(2*(c*h+C*E),b-H-w+Q),Y._isDirty=!0}return Y}toAlphaBetaGammaToRef(Y){const c=this._z,h=this._x,C=this._y,E=this._w,N=Math.sqrt(h*h+C*C),Q=Math.sqrt(c*c+E*E),b=2*Math.atan2(N,Q),H=2*Math.atan2(c,E),w=2*Math.atan2(C,h),W=(H+w)/2,q=(H-w)/2;return Y.set(q,b,W),Y}toRotationMatrix(Y){return D.FromQuaternionToRef(this,Y),Y}fromRotationMatrix(Y){return d.FromRotationMatrixToRef(Y,this),this}dot(Y){return this._x*Y._x+this._y*Y._y+this._z*Y._z+this._w*Y._w}toAxisAngle(){const Y=P.Zero();return{axis:Y,angle:this.toAxisAngleToRef(Y)}}toAxisAngleToRef(Y){let c=0;const h=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),C=this._w;return h>0?(c=2*Math.atan2(h,C),Y.set(this._x/h,this._y/h,this._z/h)):(c=0,Y.set(1,0,0)),c}static FromRotationMatrix(Y){const c=new d;return d.FromRotationMatrixToRef(Y,c),c}static FromRotationMatrixToRef(Y,c){const h=Y.m,C=h[0],E=h[4],N=h[8],Q=h[1],b=h[5],H=h[9],w=h[2],W=h[6],q=h[10],k=C+b+q;let M;return k>0?(M=.5/Math.sqrt(k+1),c._w=.25/M,c._x=(W-H)*M,c._y=(N-w)*M,c._z=(Q-E)*M,c._isDirty=!0):C>b&&C>q?(M=2*Math.sqrt(1+C-b-q),c._w=(W-H)/M,c._x=.25*M,c._y=(E+Q)/M,c._z=(N+w)/M,c._isDirty=!0):b>q?(M=2*Math.sqrt(1+b-C-q),c._w=(N-w)/M,c._x=(E+Q)/M,c._y=.25*M,c._z=(H+W)/M,c._isDirty=!0):(M=2*Math.sqrt(1+q-C-b),c._w=(Q-E)/M,c._x=(N+w)/M,c._y=(H+W)/M,c._z=.25*M,c._isDirty=!0),c}static Dot(Y,c){return Y._x*c._x+Y._y*c._y+Y._z*c._z+Y._w*c._w}static AreClose(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const C=d.Dot(Y,c);return 1-C*C<=h}static SmoothToRef(Y,c,h,C,E){let N=0===C?1:h/C;return N=(0,H.Clamp)(N,0,1),d.SlerpToRef(Y,c,N,E),E}static Zero(){return new d(0,0,0,0)}static Inverse(Y){return new d(-Y._x,-Y._y,-Y._z,Y._w)}static InverseToRef(Y,c){return c.set(-Y._x,-Y._y,-Y._z,Y._w),c}static Identity(){return new d(0,0,0,1)}static IsIdentity(Y){return Y&&0===Y._x&&0===Y._y&&0===Y._z&&1===Y._w}static RotationAxis(Y,c){return d.RotationAxisToRef(Y,c,new d)}static RotationAxisToRef(Y,c,h){h._w=Math.cos(c/2);const C=Math.sin(c/2)/Y.length();return h._x=Y._x*C,h._y=Y._y*C,h._z=Y._z*C,h._isDirty=!0,h}static dh(Y,c){return c||(c=0),new d(Y[c],Y[c+1],Y[c+2],Y[c+3])}static FromArrayToRef(Y,c,h){return h._x=Y[c],h._y=Y[c+1],h._z=Y[c+2],h._w=Y[c+3],h._isDirty=!0,h}static FromFloatsToRef(Y,c,h,C,E){return E.Vc(Y,c,h,C),E}static FromEulerAngles(Y,c,h){const C=new d;return d.RotationYawPitchRollToRef(c,Y,h,C),C}static FromEulerAnglesToRef(Y,c,h,C){return d.RotationYawPitchRollToRef(c,Y,h,C),C}static FromEulerVector(Y){const c=new d;return d.RotationYawPitchRollToRef(Y._y,Y._x,Y._z,c),c}static FromEulerVectorToRef(Y,c){return d.RotationYawPitchRollToRef(Y._y,Y._x,Y._z,c),c}static FromUnitVectorsToRef(Y,c,h){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C.d;const N=P.Dot(Y,c)+1;return N<E?Math.abs(Y.x)>Math.abs(Y.z)?h.set(-Y.y,Y.x,0,0):h.set(0,-Y.z,Y.y,0):(P.CrossToRef(Y,c,e.bh[0]),h.set(e.bh[0].x,e.bh[0].y,e.bh[0].z,N)),h.normalize()}static RotationYawPitchRoll(Y,c,h){const C=new d;return d.RotationYawPitchRollToRef(Y,c,h,C),C}static RotationYawPitchRollToRef(Y,c,h,C){const E=.5*h,N=.5*c,Q=.5*Y,b=Math.sin(E),H=Math.cos(E),w=Math.sin(N),W=Math.cos(N),q=Math.sin(Q),k=Math.cos(Q);return C._x=k*w*H+q*W*b,C._y=q*W*H-k*w*b,C._z=k*W*b-q*w*H,C._w=k*W*H+q*w*b,C._isDirty=!0,C}static RotationAlphaBetaGamma(Y,c,h){const C=new d;return d.RotationAlphaBetaGammaToRef(Y,c,h,C),C}static RotationAlphaBetaGammaToRef(Y,c,h,C){const E=.5*(h+Y),N=.5*(h-Y),Q=.5*c;return C._x=Math.cos(N)*Math.sin(Q),C._y=Math.sin(N)*Math.sin(Q),C._z=Math.sin(E)*Math.cos(Q),C._w=Math.cos(E)*Math.cos(Q),C._isDirty=!0,C}static RotationQuaternionFromAxis(Y,c,h){const C=new d(0,0,0,0);return d.RotationQuaternionFromAxisToRef(Y,c,h,C),C}static RotationQuaternionFromAxisToRef(Y,c,h,C){const E=T.Matrix[0];return Y=Y.normalizeToRef(T.bh[0]),c=c.normalizeToRef(T.bh[1]),h=h.normalizeToRef(T.bh[2]),D.FromXYZAxesToRef(Y,c,h,E),d.FromRotationMatrixToRef(E,C),C}static FromLookDirectionLH(Y,c){const h=new d;return d.FromLookDirectionLHToRef(Y,c,h),h}static FromLookDirectionLHToRef(Y,c,h){const C=T.Matrix[0];return D.LookDirectionLHToRef(Y,c,C),d.FromRotationMatrixToRef(C,h),h}static FromLookDirectionRH(Y,c){const h=new d;return d.FromLookDirectionRHToRef(Y,c,h),h}static FromLookDirectionRHToRef(Y,c,h){const C=T.Matrix[0];return D.LookDirectionRHToRef(Y,c,C),d.FromRotationMatrixToRef(C,h)}static Slerp(Y,c,h){const C=d.Identity();return d.SlerpToRef(Y,c,h,C),C}static SlerpToRef(Y,c,h,C){let E,N,Q=Y._x*c._x+Y._y*c._y+Y._z*c._z+Y._w*c._w,b=!1;if(Q<0&&(b=!0,Q=-Q),Q>.999999)N=1-h,E=b?-h:h;else{const Y=Math.acos(Q),c=1/Math.sin(Y);N=Math.sin((1-h)*Y)*c,E=b?-Math.sin(h*Y)*c:Math.sin(h*Y)*c}return C._x=N*Y._x+E*c._x,C._y=N*Y._y+E*c._y,C._z=N*Y._z+E*c._z,C._w=N*Y._w+E*c._w,C._isDirty=!0,C}static Hermite(Y,c,h,C,E){const N=E*E,Q=E*N,b=2*Q-3*N+1,H=-2*Q+3*N,w=Q-2*N+E,W=Q-N,q=Y._x*b+h._x*H+c._x*w+C._x*W,k=Y._y*b+h._y*H+c._y*w+C._y*W,M=Y._z*b+h._z*H+c._z*w+C._z*W,p=Y._w*b+h._w*H+c._w*w+C._w*W;return new d(q,k,M,p)}static Hermite1stDerivative(Y,c,h,C,E){const N=new d;return this.Hermite1stDerivativeToRef(Y,c,h,C,E,N),N}static Hermite1stDerivativeToRef(Y,c,h,C,E,N){const Q=E*E;return N._x=6*(Q-E)*Y._x+(3*Q-4*E+1)*c._x+6*(-Q+E)*h._x+(3*Q-2*E)*C._x,N._y=6*(Q-E)*Y._y+(3*Q-4*E+1)*c._y+6*(-Q+E)*h._y+(3*Q-2*E)*C._y,N._z=6*(Q-E)*Y._z+(3*Q-4*E+1)*c._z+6*(-Q+E)*h._z+(3*Q-2*E)*C._z,N._w=6*(Q-E)*Y._w+(3*Q-4*E+1)*c._w+6*(-Q+E)*h._w+(3*Q-2*E)*C._w,N._isDirty=!0,N}static Normalize(Y){const c=d.Zero();return d.NormalizeToRef(Y,c),c}static NormalizeToRef(Y,c){return Y.normalizeToRef(c),c}static Clamp(Y,c,h){const C=new d;return d.ClampToRef(Y,c,h,C),C}static ClampToRef(Y,c,h,C){return C.Vc((0,H.Clamp)(Y.x,c.x,h.x),(0,H.Clamp)(Y.y,c.y,h.y),(0,H.Clamp)(Y.z,c.z,h.z),(0,H.Clamp)(Y.w,c.w,h.w))}static Random(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new d((0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c))}static RandomToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Vc((0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c),(0,H.RandomRange)(Y,c))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(Y,c){return Math.sqrt(d.DistanceSquared(Y,c))}static DistanceSquared(Y,c){const h=Y.x-c.x,C=Y.y-c.y,E=Y.z-c.z,N=Y.w-c.w;return h*h+C*C+E*E+N*N}static Center(Y,c){return d.CenterToRef(Y,c,d.Zero())}static CenterToRef(Y,c,h){return h.Vc((Y.x+c.x)/2,(Y.y+c.y)/2,(Y.z+c.z)/2,(Y.w+c.w)/2)}}d._V8PerformanceHack=new d(.5,.5,.5,.5),Object.defineProperties(d.prototype,{dimension:{value:[4]},rank:{value:1}});class D{static get Use64Bits(){return Q.b.MatrixUse64Bits}get m(){return this.yc}markAsUpdated(){this.updateFlag=w._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(Y){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=Y,this._isIdentity3x2=Y||h,this._isIdentityDirty=!this._isIdentity&&c,this._isIdentity3x2Dirty=!this._isIdentity3x2&&C}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,Q.b.MatrixTrackPrecisionChange&&Q.b.MatrixTrackedMatrices.push(this),this.yc=new Q.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const Y=this.yc;this._isIdentity=1===Y[0]&&0===Y[1]&&0===Y[2]&&0===Y[3]&&0===Y[4]&&1===Y[5]&&0===Y[6]&&0===Y[7]&&0===Y[8]&&0===Y[9]&&1===Y[10]&&0===Y[11]&&0===Y[12]&&0===Y[13]&&0===Y[14]&&1===Y[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.yc[0]||1!==this.yc[5]||1!==this.yc[15]||0!==this.yc[1]||0!==this.yc[2]||0!==this.yc[3]||0!==this.yc[4]||0!==this.yc[6]||0!==this.yc[7]||0!==this.yc[8]||0!==this.yc[9]||0!==this.yc[10]||0!==this.yc[11]||0!==this.yc[12]||0!==this.yc[13]||0!==this.yc[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const Y=this.yc,c=Y[0],h=Y[1],C=Y[2],E=Y[3],N=Y[4],Q=Y[5],b=Y[6],H=Y[7],w=Y[8],W=Y[9],q=Y[10],k=Y[11],M=Y[12],p=Y[13],P=Y[14],y=Y[15],d=q*y-P*k,D=W*y-p*k,T=W*P-p*q,e=w*y-M*k,r=w*P-q*M,X=w*p-M*W;return c*+(Q*d-b*D+H*T)+h*-(N*d-b*e+H*r)+C*+(N*D-Q*e+H*X)+E*-(N*T-Q*r+b*X)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!Y)return this.yc;const h=this.yc;for(let C=0;C<16;C++)Y[c+C]=h[C];return this}Xc(){return this.yc}IC(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D.FromArrayToRef(Y,c,this)}Vc(){for(var Y=arguments.length,c=new Array(Y),h=0;h<Y;h++)c[h]=arguments[h];return D.FromArrayToRef(c,0,this)}set(){const Y=this.yc;for(let c=0;c<16;c++)Y[c]=c<0||arguments.length<=c?void 0:arguments[c];return this.markAsUpdated(),this}nc(Y){const c=this.yc;for(let h=0;h<16;h++)c[h]=Y;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return D.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(Y){const c=new D;return this.addToRef(Y,c),c}addToRef(Y,c){const h=this.yc,C=c.yc,E=Y.m;for(let N=0;N<16;N++)C[N]=h[N]+E[N];return c.markAsUpdated(),c}addToSelf(Y){const c=this.yc,h=Y.m;return c[0]+=h[0],c[1]+=h[1],c[2]+=h[2],c[3]+=h[3],c[4]+=h[4],c[5]+=h[5],c[6]+=h[6],c[7]+=h[7],c[8]+=h[8],c[9]+=h[9],c[10]+=h[10],c[11]+=h[11],c[12]+=h[12],c[13]+=h[13],c[14]+=h[14],c[15]+=h[15],this.markAsUpdated(),this}addInPlace(Y){const c=this.yc,h=Y.m;for(let C=0;C<16;C++)c[C]+=h[C];return this.markAsUpdated(),this}addInPlaceFromFloats(){const Y=this.yc;for(let c=0;c<16;c++)Y[c]+=c<0||arguments.length<=c?void 0:arguments[c];return this.markAsUpdated(),this}Hh(Y){const c=this.yc,h=Y.m;for(let C=0;C<16;C++)c[C]-=h[C];return this.markAsUpdated(),this}subtractToRef(Y,c){const h=this.yc,C=Y.m,E=c.yc;for(let N=0;N<16;N++)E[N]=h[N]-C[N];return c.markAsUpdated(),c}Lk(Y){const c=this.yc,h=Y.m;for(let C=0;C<16;C++)c[C]-=h[C];return this.markAsUpdated(),this}subtractFromFloats(){for(var Y=arguments.length,c=new Array(Y),h=0;h<Y;h++)c[h]=arguments[h];return this.subtractFromFloatsToRef(...c,new D)}subtractFromFloatsToRef(){for(var Y=arguments.length,c=new Array(Y),h=0;h<Y;h++)c[h]=arguments[h];const C=c.pop(),E=this.yc,N=C.yc,Q=c;for(let b=0;b<16;b++)N[b]=E[b]-Q[b];return C.markAsUpdated(),C}invertToRef(Y){return!0===this._isIdentity?(D.IdentityToRef(Y),Y):(k(this,Y.Xc())?Y.markAsUpdated():Y.N(this),Y)}addAtIndex(Y,c){return this.yc[Y]+=c,this.markAsUpdated(),this}multiplyAtIndex(Y,c){return this.yc[Y]*=c,this.markAsUpdated(),this}setTranslationFromFloats(Y,c,h){return this.yc[12]=Y,this.yc[13]=c,this.yc[14]=h,this.markAsUpdated(),this}addTranslationFromFloats(Y,c,h){return this.yc[12]+=Y,this.yc[13]+=c,this.yc[14]+=h,this.markAsUpdated(),this}setTranslation(Y){return this.setTranslationFromFloats(Y._x,Y._y,Y._z)}getTranslation(){return new P(this.yc[12],this.yc[13],this.yc[14])}getTranslationToRef(Y){return Y.x=this.yc[12],Y.y=this.yc[13],Y.z=this.yc[14],Y}removeRotationAndScaling(){const Y=this.m;return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,Y[12],Y[13],Y[14],Y[15],this),this._updateIdentityStatus(0===Y[12]&&0===Y[13]&&0===Y[14]&&1===Y[15]),this}N(Y){Y.copyToArray(this.yc);const c=Y;return this.updateFlag=c.updateFlag,this._updateIdentityStatus(c._isIdentity,c._isIdentityDirty,c._isIdentity3x2,c._isIdentity3x2Dirty),this}copyToArray(Y){return q(this,Y,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(Y){const c=new D;return this.multiplyToRef(Y,c),c}multiplyInPlace(Y){const c=this.yc,h=Y.m;for(let C=0;C<16;C++)c[C]*=h[C];return this.markAsUpdated(),this}multiplyByFloats(){const Y=this.yc;for(let c=0;c<16;c++)Y[c]*=c<0||arguments.length<=c?void 0:arguments[c];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var Y=arguments.length,c=new Array(Y),h=0;h<Y;h++)c[h]=arguments[h];const C=c.pop(),E=this.yc,N=C.yc,Q=c;for(let b=0;b<16;b++)N[b]=E[b]*Q[b];return C.markAsUpdated(),C}multiplyToRef(Y,c){return this._isIdentity?(c.N(Y),c):Y._isIdentity?(c.N(this),c):(this.multiplyToArray(Y,c.yc,0),c.markAsUpdated(),c)}multiplyToArray(Y,c,h){return W(this,Y,c,h),this}divide(Y){return this.divideToRef(Y,new D)}divideToRef(Y,c){const h=this.yc,C=Y.m,E=c.yc;for(let N=0;N<16;N++)E[N]=h[N]/C[N];return c.markAsUpdated(),c}divideInPlace(Y){const c=this.yc,h=Y.m;for(let C=0;C<16;C++)c[C]/=h[C];return this.markAsUpdated(),this}minimizeInPlace(Y){const c=this.yc,h=Y.m;for(let C=0;C<16;C++)c[C]=Math.min(c[C],h[C]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const Y=this.yc;for(let c=0;c<16;c++)Y[c]=Math.min(Y[c],c<0||arguments.length<=c?void 0:arguments[c]);return this.markAsUpdated(),this}maximizeInPlace(Y){const c=this.yc,h=Y.m;for(let C=0;C<16;C++)c[C]=Math.min(c[C],h[C]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const Y=this.yc;for(let c=0;c<16;c++)Y[c]=Math.min(Y[c],c<0||arguments.length<=c?void 0:arguments[c]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new D)}negateInPlace(){const Y=this.yc;for(let c=0;c<16;c++)Y[c]=-Y[c];return this.markAsUpdated(),this}negateToRef(Y){const c=this.yc,h=Y.yc;for(let C=0;C<16;C++)h[C]=-c[C];return Y.markAsUpdated(),Y}equals(Y){const c=Y;if(!c)return!1;if((this._isIdentity||c._isIdentity)&&!this._isIdentityDirty&&!c._isIdentityDirty)return this._isIdentity&&c._isIdentity;const h=this.m,C=c.m;return h[0]===C[0]&&h[1]===C[1]&&h[2]===C[2]&&h[3]===C[3]&&h[4]===C[4]&&h[5]===C[5]&&h[6]===C[6]&&h[7]===C[7]&&h[8]===C[8]&&h[9]===C[9]&&h[10]===C[10]&&h[11]===C[11]&&h[12]===C[12]&&h[13]===C[13]&&h[14]===C[14]&&h[15]===C[15]}equalsWithEpsilon(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=this.yc,C=Y.m;for(let E=0;E<16;E++)if(!(0,H.WithinEpsilon)(h[E],C[E],c))return!1;return!0}equalsToFloats(){const Y=this.yc;for(let c=0;c<16;c++)if(Y[c]!=(c<0||arguments.length<=c?void 0:arguments[c]))return!1;return!0}floor(){return this.floorToRef(new D)}floorToRef(Y){const c=this.yc,h=Y.yc;for(let C=0;C<16;C++)h[C]=Math.floor(c[C]);return Y.markAsUpdated(),Y}fract(){return this.fractToRef(new D)}fractToRef(Y){const c=this.yc,h=Y.yc;for(let C=0;C<16;C++)h[C]=c[C]-Math.floor(c[C]);return Y.markAsUpdated(),Y}clone(){const Y=new D;return Y.N(this),Y}getClassName(){return"Matrix"}getHashCode(){let Y=M(this.yc[0]);for(let c=1;c<16;c++)Y=397*Y^M(this.yc[c]);return Y}decomposeToTransformNode(Y){return Y.rotationQuaternion=Y.rotationQuaternion||new d,this.decompose(Y.lc,Y.rotationQuaternion,Y.position)}decompose(Y,c,h,C){let E=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return h&&h.nc(0),Y&&Y.nc(1),c&&c.Vc(0,0,0,1),!0;const N=this.yc;if(h&&h.Vc(N[12],N[13],N[14]),(Y=Y||T.bh[0]).x=Math.sqrt(N[0]*N[0]+N[1]*N[1]+N[2]*N[2]),Y.y=Math.sqrt(N[4]*N[4]+N[5]*N[5]+N[6]*N[6]),Y.z=Math.sqrt(N[8]*N[8]+N[9]*N[9]+N[10]*N[10]),C){const c=(E?C.absoluteScaling.x:C.lc.x)<0?-1:1,h=(E?C.absoluteScaling.y:C.lc.y)<0?-1:1,N=(E?C.absoluteScaling.z:C.lc.z)<0?-1:1;Y.x*=c,Y.y*=h,Y.z*=N}else this.determinant()<=0&&(Y.y*=-1);if(0===Y._x||0===Y._y||0===Y._z)return c&&c.Vc(0,0,0,1),!1;if(c){const h=1/Y._x,C=1/Y._y,E=1/Y._z;D.FromValuesToRef(N[0]*h,N[1]*h,N[2]*h,0,N[4]*C,N[5]*C,N[6]*C,0,N[8]*E,N[9]*E,N[10]*E,0,0,0,0,1,T.Matrix[0]),d.FromRotationMatrixToRef(T.Matrix[0],c)}return!0}getRow(Y){if(Y<0||Y>3)return null;const c=4*Y;return new y(this.yc[c+0],this.yc[c+1],this.yc[c+2],this.yc[c+3])}getRowToRef(Y,c){if(Y>=0&&Y<=3){const h=4*Y;c.x=this.yc[h+0],c.y=this.yc[h+1],c.z=this.yc[h+2],c.w=this.yc[h+3]}return c}setRow(Y,c){return this.setRowFromFloats(Y,c.x,c.y,c.z,c.w)}transpose(){const Y=new D;return D.TransposeToRef(this,Y),Y}transposeToRef(Y){return D.TransposeToRef(this,Y),Y}setRowFromFloats(Y,c,h,C,E){if(Y<0||Y>3)return this;const N=4*Y;return this.yc[N+0]=c,this.yc[N+1]=h,this.yc[N+2]=C,this.yc[N+3]=E,this.markAsUpdated(),this}scale(Y){const c=new D;return this.scaleToRef(Y,c),c}scaleToRef(Y,c){for(let h=0;h<16;h++)c.yc[h]=this.yc[h]*Y;return c.markAsUpdated(),c}scaleAndAddToRef(Y,c){for(let h=0;h<16;h++)c.yc[h]+=this.yc[h]*Y;return c.markAsUpdated(),c}scaleInPlace(Y){const c=this.yc;for(let h=0;h<16;h++)c[h]*=Y;return this.markAsUpdated(),this}toNormalMatrix(Y){const c=T.Matrix[0];this.invertToRef(c),c.transposeToRef(Y);const h=Y.yc;return D.FromValuesToRef(h[0],h[1],h[2],0,h[4],h[5],h[6],0,h[8],h[9],h[10],0,0,0,0,1,Y),Y}getRotationMatrix(){const Y=new D;return this.getRotationMatrixToRef(Y),Y}getRotationMatrixToRef(Y){const c=T.bh[0];if(!this.decompose(c))return D.IdentityToRef(Y),Y;const h=this.yc,C=1/c._x,E=1/c._y,N=1/c._z;return D.FromValuesToRef(h[0]*C,h[1]*C,h[2]*C,0,h[4]*E,h[5]*E,h[6]*E,0,h[8]*N,h[9]*N,h[10]*N,0,0,0,0,1,Y),Y}toggleModelMatrixHandInPlace(){const Y=this.yc;return Y[2]*=-1,Y[6]*=-1,Y[8]*=-1,Y[9]*=-1,Y[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const Y=this.yc;return Y[8]*=-1,Y[9]*=-1,Y[10]*=-1,Y[11]*=-1,this.markAsUpdated(),this}static dh(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=new D;return D.FromArrayToRef(Y,c,h),h}static FromArrayToRef(Y,c,h){for(let C=0;C<16;C++)h.yc[C]=Y[C+c];return h.markAsUpdated(),h}static FromFloat32ArrayToRefScaled(Y,c,h,C){return C.yc[0]=Y[0+c]*h,C.yc[1]=Y[1+c]*h,C.yc[2]=Y[2+c]*h,C.yc[3]=Y[3+c]*h,C.yc[4]=Y[4+c]*h,C.yc[5]=Y[5+c]*h,C.yc[6]=Y[6+c]*h,C.yc[7]=Y[7+c]*h,C.yc[8]=Y[8+c]*h,C.yc[9]=Y[9+c]*h,C.yc[10]=Y[10+c]*h,C.yc[11]=Y[11+c]*h,C.yc[12]=Y[12+c]*h,C.yc[13]=Y[13+c]*h,C.yc[14]=Y[14+c]*h,C.yc[15]=Y[15+c]*h,C.markAsUpdated(),C}static get IdentityReadOnly(){return D._IdentityReadOnly}static FromValuesToRef(Y,c,h,C,E,N,Q,b,H,w,W,q,k,M,p,P,y){const d=y.yc;d[0]=Y,d[1]=c,d[2]=h,d[3]=C,d[4]=E,d[5]=N,d[6]=Q,d[7]=b,d[8]=H,d[9]=w,d[10]=W,d[11]=q,d[12]=k,d[13]=M,d[14]=p,d[15]=P,y.markAsUpdated()}static FromValues(Y,c,h,C,E,N,Q,b,H,w,W,q,k,M,p,P){const y=new D,d=y.yc;return d[0]=Y,d[1]=c,d[2]=h,d[3]=C,d[4]=E,d[5]=N,d[6]=Q,d[7]=b,d[8]=H,d[9]=w,d[10]=W,d[11]=q,d[12]=k,d[13]=M,d[14]=p,d[15]=P,y.markAsUpdated(),y}static Compose(Y,c,h){const C=new D;return D.ComposeToRef(Y,c,h,C),C}static ComposeToRef(Y,c,h,C){const E=C.yc,N=c._x,Q=c._y,b=c._z,H=c._w,w=N+N,W=Q+Q,q=b+b,k=N*w,M=N*W,p=N*q,P=Q*W,y=Q*q,d=b*q,D=H*w,T=H*W,e=H*q,r=Y._x,X=Y._y,Z=Y._z;return E[0]=(1-(P+d))*r,E[1]=(M+e)*r,E[2]=(p-T)*r,E[3]=0,E[4]=(M-e)*X,E[5]=(1-(k+d))*X,E[6]=(y+D)*X,E[7]=0,E[8]=(p+T)*Z,E[9]=(y-D)*Z,E[10]=(1-(k+P))*Z,E[11]=0,E[12]=h._x,E[13]=h._y,E[14]=h._z,E[15]=1,C.markAsUpdated(),C}static Identity(){const Y=D.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return Y._updateIdentityStatus(!0),Y}static IdentityToRef(Y){return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,Y),Y._updateIdentityStatus(!0),Y}static Zero(){const Y=D.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return Y._updateIdentityStatus(!1),Y}static RotationX(Y){const c=new D;return D.RotationXToRef(Y,c),c}static Invert(Y){const c=new D;return Y.invertToRef(c),c}static RotationXToRef(Y,c){const h=Math.sin(Y),C=Math.cos(Y);return D.FromValuesToRef(1,0,0,0,0,C,h,0,0,-h,C,0,0,0,0,1,c),c._updateIdentityStatus(1===C&&0===h),c}static RotationY(Y){const c=new D;return D.RotationYToRef(Y,c),c}static RotationYToRef(Y,c){const h=Math.sin(Y),C=Math.cos(Y);return D.FromValuesToRef(C,0,-h,0,0,1,0,0,h,0,C,0,0,0,0,1,c),c._updateIdentityStatus(1===C&&0===h),c}static RotationZ(Y){const c=new D;return D.RotationZToRef(Y,c),c}static RotationZToRef(Y,c){const h=Math.sin(Y),C=Math.cos(Y);return D.FromValuesToRef(C,h,0,0,-h,C,0,0,0,0,1,0,0,0,0,1,c),c._updateIdentityStatus(1===C&&0===h),c}static RotationAxis(Y,c){const h=new D;return D.RotationAxisToRef(Y,c,h),h}static RotationAxisToRef(Y,c,h){const C=Math.sin(-c),E=Math.cos(-c),N=1-E;Y=Y.normalizeToRef(T.bh[0]);const Q=h.yc;return Q[0]=Y._x*Y._x*N+E,Q[1]=Y._x*Y._y*N-Y._z*C,Q[2]=Y._x*Y._z*N+Y._y*C,Q[3]=0,Q[4]=Y._y*Y._x*N+Y._z*C,Q[5]=Y._y*Y._y*N+E,Q[6]=Y._y*Y._z*N-Y._x*C,Q[7]=0,Q[8]=Y._z*Y._x*N-Y._y*C,Q[9]=Y._z*Y._y*N+Y._x*C,Q[10]=Y._z*Y._z*N+E,Q[11]=0,Q[12]=0,Q[13]=0,Q[14]=0,Q[15]=1,h.markAsUpdated(),h}static RotationAlignToRef(Y,c,h){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const N=P.Dot(c,Y),Q=h.yc;if(N<-1+C.d)Q[0]=-1,Q[1]=0,Q[2]=0,Q[3]=0,Q[4]=0,Q[5]=E?1:-1,Q[6]=0,Q[7]=0,Q[8]=0,Q[9]=0,Q[10]=E?-1:1,Q[11]=0;else{const h=P.Cross(c,Y),C=1/(1+N);Q[0]=h._x*h._x*C+N,Q[1]=h._y*h._x*C-h._z,Q[2]=h._z*h._x*C+h._y,Q[3]=0,Q[4]=h._x*h._y*C+h._z,Q[5]=h._y*h._y*C+N,Q[6]=h._z*h._y*C-h._x,Q[7]=0,Q[8]=h._x*h._z*C-h._y,Q[9]=h._y*h._z*C+h._x,Q[10]=h._z*h._z*C+N,Q[11]=0}return Q[12]=0,Q[13]=0,Q[14]=0,Q[15]=1,h.markAsUpdated(),h}static RotationYawPitchRoll(Y,c,h){const C=new D;return D.RotationYawPitchRollToRef(Y,c,h,C),C}static RotationYawPitchRollToRef(Y,c,h,C){return d.RotationYawPitchRollToRef(Y,c,h,T.Quaternion[0]),T.Quaternion[0].toRotationMatrix(C),C}static Scaling(Y,c,h){const C=new D;return D.ScalingToRef(Y,c,h,C),C}static ScalingToRef(Y,c,h,C){return D.FromValuesToRef(Y,0,0,0,0,c,0,0,0,0,h,0,0,0,0,1,C),C._updateIdentityStatus(1===Y&&1===c&&1===h),C}static Translation(Y,c,h){const C=new D;return D.TranslationToRef(Y,c,h,C),C}static TranslationToRef(Y,c,h,C){return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,Y,c,h,1,C),C._updateIdentityStatus(0===Y&&0===c&&0===h),C}static Lerp(Y,c,h){const C=new D;return D.LerpToRef(Y,c,h,C),C}static LerpToRef(Y,c,h,C){const E=C.yc,N=Y.m,Q=c.m;for(let b=0;b<16;b++)E[b]=N[b]*(1-h)+Q[b]*h;return C.markAsUpdated(),C}static DecomposeLerp(Y,c,h){const C=new D;return D.DecomposeLerpToRef(Y,c,h,C),C}static DecomposeLerpToRef(Y,c,h,C){const E=T.bh[0],N=T.Quaternion[0],Q=T.bh[1];Y.decompose(E,N,Q);const b=T.bh[2],H=T.Quaternion[1],w=T.bh[3];c.decompose(b,H,w);const W=T.bh[4];P.LerpToRef(E,b,h,W);const q=T.Quaternion[2];d.SlerpToRef(N,H,h,q);const k=T.bh[5];return P.LerpToRef(Q,w,h,k),D.ComposeToRef(W,q,k,C),C}static LookAtLH(Y,c,h){const C=new D;return D.LookAtLHToRef(Y,c,h,C),C}static LookAtLHToRef(Y,c,h,C){const E=T.bh[0],N=T.bh[1],Q=T.bh[2];c.subtractToRef(Y,Q),Q.normalize(),P.CrossToRef(h,Q,E);const b=E.lengthSquared();0===b?E.x=1:E.normalizeFromLength(Math.sqrt(b)),P.CrossToRef(Q,E,N),N.normalize();const H=-P.Dot(E,Y),w=-P.Dot(N,Y),W=-P.Dot(Q,Y);return D.FromValuesToRef(E._x,N._x,Q._x,0,E._y,N._y,Q._y,0,E._z,N._z,Q._z,0,H,w,W,1,C),C}static LookAtRH(Y,c,h){const C=new D;return D.LookAtRHToRef(Y,c,h,C),C}static LookAtRHToRef(Y,c,h,C){const E=T.bh[0],N=T.bh[1],Q=T.bh[2];Y.subtractToRef(c,Q),Q.normalize(),P.CrossToRef(h,Q,E);const b=E.lengthSquared();0===b?E.x=1:E.normalizeFromLength(Math.sqrt(b)),P.CrossToRef(Q,E,N),N.normalize();const H=-P.Dot(E,Y),w=-P.Dot(N,Y),W=-P.Dot(Q,Y);return D.FromValuesToRef(E._x,N._x,Q._x,0,E._y,N._y,Q._y,0,E._z,N._z,Q._z,0,H,w,W,1,C),C}static LookDirectionLH(Y,c){const h=new D;return D.LookDirectionLHToRef(Y,c,h),h}static LookDirectionLHToRef(Y,c,h){const C=T.bh[0];C.N(Y),C.scaleInPlace(-1);const E=T.bh[1];return P.CrossToRef(c,C,E),D.FromValuesToRef(E._x,E._y,E._z,0,c._x,c._y,c._z,0,C._x,C._y,C._z,0,0,0,0,1,h),h}static LookDirectionRH(Y,c){const h=new D;return D.LookDirectionRHToRef(Y,c,h),h}static LookDirectionRHToRef(Y,c,h){const C=T.bh[2];return P.CrossToRef(c,Y,C),D.FromValuesToRef(C._x,C._y,C._z,0,c._x,c._y,c._z,0,Y._x,Y._y,Y._z,0,0,0,0,1,h),h}static OrthoLH(Y,c,h,C,E){const N=new D;return D.OrthoLHToRef(Y,c,h,C,N,E),N}static OrthoLHToRef(Y,c,h,C,E,N){const Q=2/Y,b=2/c,H=2/(C-h),w=-(C+h)/(C-h);return D.FromValuesToRef(Q,0,0,0,0,b,0,0,0,0,H,0,0,0,w,1,E),N&&E.multiplyToRef(r,E),E._updateIdentityStatus(1===Q&&1===b&&1===H&&0===w),E}static OrthoOffCenterLH(Y,c,h,C,E,N,Q){const b=new D;return D.OrthoOffCenterLHToRef(Y,c,h,C,E,N,b,Q),b}static OrthoOffCenterLHToRef(Y,c,h,C,E,N,Q,b){const H=2/(c-Y),w=2/(C-h),W=2/(N-E),q=-(N+E)/(N-E),k=(Y+c)/(Y-c),M=(C+h)/(h-C);return D.FromValuesToRef(H,0,0,0,0,w,0,0,0,0,W,0,k,M,q,1,Q),b&&Q.multiplyToRef(r,Q),Q.markAsUpdated(),Q}static ObliqueOffCenterLHToRef(Y,c,h,C,E,N,Q,b,H,w,W){const q=-Q*Math.cos(b),k=-Q*Math.sin(b);return D.TranslationToRef(0,0,-H,T.Matrix[1]),D.FromValuesToRef(1,0,0,0,0,1,0,0,q,k,1,0,0,0,0,1,T.Matrix[0]),T.Matrix[1].multiplyToRef(T.Matrix[0],T.Matrix[0]),D.TranslationToRef(0,0,H,T.Matrix[1]),T.Matrix[0].multiplyToRef(T.Matrix[1],T.Matrix[0]),D.OrthoOffCenterLHToRef(Y,c,h,C,E,N,w,W),T.Matrix[0].multiplyToRef(w,w),w}static OrthoOffCenterRH(Y,c,h,C,E,N,Q){const b=new D;return D.OrthoOffCenterRHToRef(Y,c,h,C,E,N,b,Q),b}static OrthoOffCenterRHToRef(Y,c,h,C,E,N,Q,b){return D.OrthoOffCenterLHToRef(Y,c,h,C,E,N,Q,b),Q.yc[10]*=-1,Q}static ObliqueOffCenterRHToRef(Y,c,h,C,E,N,Q,b,H,w,W){const q=Q*Math.cos(b),k=Q*Math.sin(b);return D.TranslationToRef(0,0,H,T.Matrix[1]),D.FromValuesToRef(1,0,0,0,0,1,0,0,q,k,1,0,0,0,0,1,T.Matrix[0]),T.Matrix[1].multiplyToRef(T.Matrix[0],T.Matrix[0]),D.TranslationToRef(0,0,-H,T.Matrix[1]),T.Matrix[0].multiplyToRef(T.Matrix[1],T.Matrix[0]),D.OrthoOffCenterRHToRef(Y,c,h,C,E,N,w,W),T.Matrix[0].multiplyToRef(w,w),w}static PerspectiveLH(Y,c,h,C,E){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const Q=new D,b=2*h/Y,H=2*h/c,w=(C+h)/(C-h),W=-2*C*h/(C-h),q=Math.tan(N);return D.FromValuesToRef(b,0,0,0,0,H,0,q,0,0,w,1,0,0,W,0,Q),E&&Q.multiplyToRef(r,Q),Q._updateIdentityStatus(!1),Q}static PerspectiveFovLH(Y,c,h,C,E){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const b=new D;return D.PerspectiveFovLHToRef(Y,c,h,C,b,!0,E,N,Q),b}static PerspectiveFovLHToRef(Y,c,h,C,E){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,b=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,H=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const w=h,W=C,q=1/Math.tan(.5*Y),k=N?q/c:q,M=N?q:q*c,p=H&&0===w?-1:0!==W?(W+w)/(W-w):1,P=H&&0===w?2*W:0!==W?-2*W*w/(W-w):-2*w,y=Math.tan(b);return D.FromValuesToRef(k,0,0,0,0,M,0,y,0,0,p,1,0,0,P,0,E),Q&&E.multiplyToRef(r,E),E._updateIdentityStatus(!1),E}static PerspectiveFovReverseLHToRef(Y,c,h,C,E){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,b=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const H=1/Math.tan(.5*Y),w=N?H/c:H,W=N?H:H*c,q=Math.tan(b);return D.FromValuesToRef(w,0,0,0,0,W,0,q,0,0,-h,1,0,0,1,0,E),Q&&E.multiplyToRef(r,E),E._updateIdentityStatus(!1),E}static PerspectiveFovRH(Y,c,h,C,E){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const b=new D;return D.PerspectiveFovRHToRef(Y,c,h,C,b,!0,E,N,Q),b}static PerspectiveFovRHToRef(Y,c,h,C,E){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,b=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,H=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const w=h,W=C,q=1/Math.tan(.5*Y),k=N?q/c:q,M=N?q:q*c,p=H&&0===w?1:0!==W?-(W+w)/(W-w):-1,P=H&&0===w?2*W:0!==W?-2*W*w/(W-w):-2*w,y=Math.tan(b);return D.FromValuesToRef(k,0,0,0,0,M,0,y,0,0,p,-1,0,0,P,0,E),Q&&E.multiplyToRef(r,E),E._updateIdentityStatus(!1),E}static PerspectiveFovReverseRHToRef(Y,c,h,C,E){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,b=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const H=1/Math.tan(.5*Y),w=N?H/c:H,W=N?H:H*c,q=Math.tan(b);return D.FromValuesToRef(w,0,0,0,0,W,0,q,0,0,-h,-1,0,0,-1,0,E),Q&&E.multiplyToRef(r,E),E._updateIdentityStatus(!1),E}static GetFinalMatrix(Y,c,h,C,E,N){const Q=Y.width,b=Y.height,H=Y.x,w=Y.y,W=D.FromValues(Q/2,0,0,0,0,-b/2,0,0,0,0,N-E,0,H+Q/2,b/2+w,E,1),q=new D;return c.multiplyToRef(h,q),q.multiplyToRef(C,q),q.multiplyToRef(W,q)}static GetAsMatrix2x2(Y){const c=Y.m,h=[c[0],c[1],c[4],c[5]];return Q.b.MatrixUse64Bits?h:new Float32Array(h)}static GetAsMatrix3x3(Y){const c=Y.m,h=[c[0],c[1],c[2],c[4],c[5],c[6],c[8],c[9],c[10]];return Q.b.MatrixUse64Bits?h:new Float32Array(h)}static Transpose(Y){const c=new D;return D.TransposeToRef(Y,c),c}static TransposeToRef(Y,c){const h=Y.m,C=h[0],E=h[4],N=h[8],Q=h[12],b=h[1],H=h[5],w=h[9],W=h[13],q=h[2],k=h[6],M=h[10],p=h[14],P=h[3],y=h[7],d=h[11],D=h[15],T=c.yc;return T[0]=C,T[1]=E,T[2]=N,T[3]=Q,T[4]=b,T[5]=H,T[6]=w,T[7]=W,T[8]=q,T[9]=k,T[10]=M,T[11]=p,T[12]=P,T[13]=y,T[14]=d,T[15]=D,c.markAsUpdated(),c._updateIdentityStatus(Y._isIdentity,Y._isIdentityDirty),c}static Reflection(Y){const c=new D;return D.ReflectionToRef(Y,c),c}static ReflectionToRef(Y,c){Y.normalize();const h=Y.normal.x,C=Y.normal.y,E=Y.normal.z,N=-2*h,Q=-2*C,b=-2*E;return D.FromValuesToRef(N*h+1,Q*h,b*h,0,N*C,Q*C+1,b*C,0,N*E,Q*E,b*E+1,0,N*Y.d,Q*Y.d,b*Y.d,1,c),c}static FromXYZAxesToRef(Y,c,h,C){return D.FromValuesToRef(Y._x,Y._y,Y._z,0,c._x,c._y,c._z,0,h._x,h._y,h._z,0,0,0,0,1,C),C}static FromQuaternionToRef(Y,c){const h=Y._x*Y._x,C=Y._y*Y._y,E=Y._z*Y._z,N=Y._x*Y._y,Q=Y._z*Y._w,b=Y._z*Y._x,H=Y._y*Y._w,w=Y._y*Y._z,W=Y._x*Y._w;return c.yc[0]=1-2*(C+E),c.yc[1]=2*(N+Q),c.yc[2]=2*(b-H),c.yc[3]=0,c.yc[4]=2*(N-Q),c.yc[5]=1-2*(E+h),c.yc[6]=2*(w+W),c.yc[7]=0,c.yc[8]=2*(b+H),c.yc[9]=2*(w-W),c.yc[10]=1-2*(C+h),c.yc[11]=0,c.yc[12]=0,c.yc[13]=0,c.yc[14]=0,c.yc[15]=1,c.markAsUpdated(),c}}D._IdentityReadOnly=D.Identity(),Object.defineProperties(D.prototype,{dimension:{value:[4,4]},rank:{value:2}});class T{}T.bh=(0,E.d)(11,P.Zero),T.Matrix=(0,E.d)(2,D.Identity),T.Quaternion=(0,E.d)(3,d.Zero);class e{}e.Vector2=(0,E.d)(3,p.Zero),e.bh=(0,E.d)(13,P.Zero),e.Vector4=(0,E.d)(3,y.Zero),e.Quaternion=(0,E.d)(3,d.Zero),e.Matrix=(0,E.d)(8,D.Identity),(0,N.e)("BABYLON.Vector2",p),(0,N.e)("BABYLON.Vector3",P),(0,N.e)("BABYLON.Vector4",y),(0,N.e)("BABYLON.Matrix",D);const r=D.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12877:(Y,c,h)=>{function C(Y,c){const h=[];for(let C=0;C<Y;++C)h.push(c());return h}function E(Y,c){return C(Y,c)}h.d(c,{b:()=>C,d:()=>E,e:()=>Q});const N=["push","splice","pop","shift","unshift"];function Q(Y,c){const h=N.map((h=>function(Y,c,h){const C=Y[c];if("function"!==typeof C)return null;const E=function(){const C=Y.length,N=E.previous.apply(Y,arguments);return h(c,C),N};return C.next=E,E.previous=C,Y[c]=E,()=>{const h=E.previous;if(!h)return;const C=E.next;C?(h.next=C,C.previous=h):(h.next=void 0,Y[c]=h),E.next=void 0,E.previous=void 0}}(Y,h,c)));return()=>{for(const Y of h)null===Y||void 0===Y||Y()}}}}]);