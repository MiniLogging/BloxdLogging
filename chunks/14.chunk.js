"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{11109:(q,S,b)=>{b.d(S,{d:()=>U,g:()=>v,h:()=>z,j:()=>C});const z=1/2.2,C=2.2,v=(1+Math.sqrt(5))/2,U=.001},11121:(q,S,b)=>{function z(q){return parseInt(q.toString().replace(/\W/g,""))}function C(q,S){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(q-S)<=b}function v(q,S,b){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return q<S-z||q>b+z}function U(q,S){return q===S?q:Math.random()*(S-q)+q}function g(q,S,b){return q+(S-q)*b}function r(q,S,b){let z=H(S-q,360);return z>180&&(z-=360),q+z*y(b)}function I(q,S,b){let z=0;return z=q!=S?y((b-q)/(S-q)):0,z}function V(q,S,b,z,C){const v=C*C,U=C*v;return q*(2*U-3*v+1)+b*(-2*U+3*v)+S*(U-2*v+C)+z*(U-v)}function l(q,S,b,z,C){const v=C*C;return 6*(v-C)*q+(3*v-4*C+1)*S+6*(-v+C)*b+(3*v-2*C)*z}function y(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(b,Math.max(S,q))}function R(q){return q-=2*Math.PI*Math.floor((q+Math.PI)/(2*Math.PI))}function G(q){const S=q.toString(16);return q<=15?("0"+S).toUpperCase():S.toUpperCase()}function Z(q){if(Math.log2)return Math.floor(Math.log2(q));if(q<0)return NaN;if(0===q)return-1/0;let S=0;if(q<1){for(;q<1;)S++,q*=2;S=-S}else if(q>1)for(;q>1;)S++,q=Math.floor(q/2);return S}function H(q,S){return q-Math.floor(q/S)*S}function Q(q,S,b){return(q-S)/(b-S)}function k(q,S,b){return q*(b-S)+S}function W(q,S){let b=H(S-q,360);return b>180&&(b-=360),b}function N(q,S){const b=H(q,2*S);return S-Math.abs(b-S)}function u(q,S,b){let z=y(b);return z=-2*z*z*z+3*z*z,S*z+q*(1-z)}function X(q,S,b){let z=0;return z=Math.abs(S-q)<=b?S:q+Math.sign(S-q)*b,z}function T(q,S,b){const z=W(q,S);let C=0;return C=-b<z&&z<b?S:X(q,S=q+z,b),C}function B(q,S,b){return(q-S)/(b-S)}function t(q,S,b){return(b-S)*q+S}function f(q,S){const b=q%S;return 0===b?S:f(S,b)}b.r(S),b.d(S,{Clamp:()=>y,DeltaAngle:()=>W,Denormalize:()=>k,ExtractAsInt:()=>z,Hermite:()=>V,Hermite1stDerivative:()=>l,HighestCommonFactor:()=>f,ILog2:()=>Z,InverseLerp:()=>I,Lerp:()=>g,LerpAngle:()=>r,MoveTowards:()=>X,MoveTowardsAngle:()=>T,Normalize:()=>Q,NormalizeRadians:()=>R,OutsideRange:()=>v,PercentToRange:()=>t,PingPong:()=>N,RandomRange:()=>U,RangeToPercent:()=>B,Repeat:()=>H,SmoothStep:()=>u,ToHex:()=>G,WithinEpsilon:()=>C})},11103:(q,S,b)=>{b.r(S),b.d(S,{Matrix:()=>k,Quaternion:()=>Q,TmpVectors:()=>N,Vector2:()=>G,yS:()=>Z,Vector4:()=>H});var z=b(11109),C=b(11118),v=b(11058),U=b(11029),g=b(10975),r=b(11121);class I{}function V(q,S,b){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const C=q.Zb(),v=S.Zb(),U=C[0],g=C[1],r=C[2],I=C[3],V=C[4],l=C[5],y=C[6],R=C[7],G=C[8],Z=C[9],H=C[10],Q=C[11],k=C[12],W=C[13],N=C[14],u=C[15],X=v[0],T=v[1],B=v[2],t=v[3],f=v[4],m=v[5],E=v[6],e=v[7],i=v[8],J=v[9],L=v[10],d=v[11],K=v[12],D=v[13],x=v[14],F=v[15];b[z]=U*X+g*f+r*i+I*K,b[z+1]=U*T+g*m+r*J+I*D,b[z+2]=U*B+g*E+r*L+I*x,b[z+3]=U*t+g*e+r*d+I*F,b[z+4]=V*X+l*f+y*i+R*K,b[z+5]=V*T+l*m+y*J+R*D,b[z+6]=V*B+l*E+y*L+R*x,b[z+7]=V*t+l*e+y*d+R*F,b[z+8]=G*X+Z*f+H*i+Q*K,b[z+9]=G*T+Z*m+H*J+Q*D,b[z+10]=G*B+Z*E+H*L+Q*x,b[z+11]=G*t+Z*e+H*d+Q*F,b[z+12]=k*X+W*f+N*i+u*K,b[z+13]=k*T+W*m+N*J+u*D,b[z+14]=k*B+W*E+N*L+u*x,b[z+15]=k*t+W*e+N*d+u*F}function l(q,S){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const z=q.Zb();S[b]=z[0],S[b+1]=z[1],S[b+2]=z[2],S[b+3]=z[3],S[b+4]=z[4],S[b+5]=z[5],S[b+6]=z[6],S[b+7]=z[7],S[b+8]=z[8],S[b+9]=z[9],S[b+10]=z[10],S[b+11]=z[11],S[b+12]=z[12],S[b+13]=z[13],S[b+14]=z[14],S[b+15]=z[15]}function y(q,S){const b=q.Zb(),z=b[0],C=b[1],v=b[2],U=b[3],g=b[4],r=b[5],I=b[6],V=b[7],l=b[8],y=b[9],R=b[10],G=b[11],Z=b[12],H=b[13],Q=b[14],k=b[15],W=R*k-Q*G,N=y*k-H*G,u=y*Q-H*R,X=l*k-Z*G,T=l*Q-R*Z,B=l*H-Z*y,t=+(r*W-I*N+V*u),f=-(g*W-I*X+V*T),m=+(g*N-r*X+V*B),E=-(g*u-r*T+I*B),e=z*t+C*f+v*m+U*E;if(0===e)return!1;const i=1/e,J=I*k-Q*V,L=r*k-H*V,d=r*Q-H*I,K=g*k-Z*V,D=g*Q-Z*I,x=g*H-Z*r,F=I*G-R*V,a=r*G-y*V,n=r*R-y*I,o=g*G-l*V,s=g*R-l*I,A=g*y-l*r,w=-(C*W-v*N+U*u),P=+(z*W-v*X+U*T),h=-(z*N-C*X+U*B),O=+(z*u-C*T+v*B),j=+(C*J-v*L+U*d),M=-(z*J-v*K+U*D),p=+(z*L-C*K+U*x),Y=-(z*d-C*D+v*x),c=-(C*F-v*a+U*n),qq=+(z*F-v*o+U*s),Sq=-(z*a-C*o+U*A),bq=+(z*n-C*s+v*A);return S[0]=t*i,S[1]=w*i,S[2]=j*i,S[3]=c*i,S[4]=f*i,S[5]=P*i,S[6]=M*i,S[7]=qq*i,S[8]=m*i,S[9]=h*i,S[10]=p*i,S[11]=Sq*i,S[12]=E*i,S[13]=O*i,S[14]=Y*i,S[15]=bq*i,!0}I._UpdateFlagSeed=0;const R=q=>parseInt(q.toString().replace(/\W/g,""));class G{constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=q,this.y=S}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let q=R(this.x);return q=397*q^R(this.y),q}toArray(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q[S]=this.x,q[S+1]=this.y,this}Uz(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G.FromArrayToRef(q,S,this),this}Zb(){return[this.x,this.y]}v(q){return this.x=q.x,this.y=q.y,this}Bb(q,S){return this.x=q,this.y=S,this}set(q,S){return this.Bb(q,S)}fb(q){return this.Bb(q,q)}add(q){return new G(this.x+q.x,this.y+q.y)}addToRef(q,S){return S.x=this.x+q.x,S.y=this.y+q.y,S}addInPlace(q){return this.x+=q.x,this.y+=q.y,this}addInPlaceFromFloats(q,S){return this.x+=q,this.y+=S,this}addVector3(q){return new G(this.x+q.x,this.y+q.y)}RS(q){return new G(this.x-q.x,this.y-q.y)}subtractToRef(q,S){return S.x=this.x-q.x,S.y=this.y-q.y,S}Ql(q){return this.x-=q.x,this.y-=q.y,this}multiplyInPlace(q){return this.x*=q.x,this.y*=q.y,this}multiply(q){return new G(this.x*q.x,this.y*q.y)}multiplyToRef(q,S){return S.x=this.x*q.x,S.y=this.y*q.y,S}multiplyByFloats(q,S){return new G(this.x*q,this.y*S)}divide(q){return new G(this.x/q.x,this.y/q.y)}divideToRef(q,S){return S.x=this.x/q.x,S.y=this.y/q.y,S}divideInPlace(q){return this.x=this.x/q.x,this.y=this.y/q.y,this}minimizeInPlace(q){return this.minimizeInPlaceFromFloats(q.x,q.y)}maximizeInPlace(q){return this.maximizeInPlaceFromFloats(q.x,q.y)}minimizeInPlaceFromFloats(q,S){return this.x=Math.min(q,this.x),this.y=Math.min(S,this.y),this}maximizeInPlaceFromFloats(q,S){return this.x=Math.max(q,this.x),this.y=Math.max(S,this.y),this}subtractFromFloats(q,S){return new G(this.x-q,this.y-S)}subtractFromFloatsToRef(q,S,b){return b.x=this.x-q,b.y=this.y-S,b}negate(){return new G(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(q){return q.x=-this.x,q.y=-this.y,q}scaleInPlace(q){return this.x*=q,this.y*=q,this}scale(q){return new G(this.x*q,this.y*q)}scaleToRef(q,S){return S.x=this.x*q,S.y=this.y*q,S}scaleAndAddToRef(q,S){return S.x+=this.x*q,S.y+=this.y*q,S}equals(q){return q&&this.x===q.x&&this.y===q.y}equalsWithEpsilon(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.d;return q&&(0,r.WithinEpsilon)(this.x,q.x,S)&&(0,r.WithinEpsilon)(this.y,q.y,S)}equalsToFloats(q,S){return this.x===q&&this.y===S}floor(){return new G(Math.floor(this.x),Math.floor(this.y))}floorToRef(q){return q.x=Math.floor(this.x),q.y=Math.floor(this.y),q}fract(){return new G(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(q){return q.x=this.x-Math.floor(this.x),q.y=this.y-Math.floor(this.y),q}rotate(q){return this.rotateToRef(q,new G)}rotateToRef(q,S){const b=Math.cos(q),z=Math.sin(q);return S.x=b*this.x-z*this.y,S.y=z*this.x+b*this.y,S}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(q){return 0===q||1===q?this:this.scaleInPlace(1/q)}normalizeToNew(){const q=new G;return this.normalizeToRef(q),q}normalizeToRef(q){const S=this.length();return 0===S&&(q.x=this.x,q.y=this.y),this.scaleToRef(1/S,q)}clone(){return new G(this.x,this.y)}dot(q){return this.x*q.x+this.y*q.y}static Zero(){return new G(0,0)}static One(){return new G(1,1)}static Random(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new G((0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S))}static RandomToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Bb((0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S))}static get ZeroReadOnly(){return G._ZeroReadOnly}static Hb(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new G(q[S],q[S+1])}static FromArrayToRef(q,S,b){return b.x=q[S],b.y=q[S+1],b}static FromFloatsToRef(q,S,b){return b.Bb(q,S),b}static CatmullRom(q,S,b,z,C){const v=C*C,U=C*v,g=.5*(2*S.x+(-q.x+b.x)*C+(2*q.x-5*S.x+4*b.x-z.x)*v+(-q.x+3*S.x-3*b.x+z.x)*U),r=.5*(2*S.y+(-q.y+b.y)*C+(2*q.y-5*S.y+4*b.y-z.y)*v+(-q.y+3*S.y-3*b.y+z.y)*U);return new G(g,r)}static ClampToRef(q,S,b,z){return z.x=(0,r.Clamp)(q.x,S.x,b.x),z.y=(0,r.Clamp)(q.y,S.y,b.y),z}static Clamp(q,S,b){const z=(0,r.Clamp)(q.x,S.x,b.x),C=(0,r.Clamp)(q.y,S.y,b.y);return new G(z,C)}static Hermite(q,S,b,z,C){const v=C*C,U=C*v,g=2*U-3*v+1,r=-2*U+3*v,I=U-2*v+C,V=U-v,l=q.x*g+b.x*r+S.x*I+z.x*V,y=q.y*g+b.y*r+S.y*I+z.y*V;return new G(l,y)}static Hermite1stDerivative(q,S,b,z,C){return this.Hermite1stDerivativeToRef(q,S,b,z,C,new G)}static Hermite1stDerivativeToRef(q,S,b,z,C,v){const U=C*C;return v.x=6*(U-C)*q.x+(3*U-4*C+1)*S.x+6*(-U+C)*b.x+(3*U-2*C)*z.x,v.y=6*(U-C)*q.y+(3*U-4*C+1)*S.y+6*(-U+C)*b.y+(3*U-2*C)*z.y,v}static Lerp(q,S,b){return G.LerpToRef(q,S,b,new G)}static LerpToRef(q,S,b,z){return z.x=q.x+(S.x-q.x)*b,z.y=q.y+(S.y-q.y)*b,z}static Dot(q,S){return q.x*S.x+q.y*S.y}static Normalize(q){return G.NormalizeToRef(q,new G)}static NormalizeToRef(q,S){return q.normalizeToRef(S),S}static Minimize(q,S){const b=q.x<S.x?q.x:S.x,z=q.y<S.y?q.y:S.y;return new G(b,z)}static Maximize(q,S){const b=q.x>S.x?q.x:S.x,z=q.y>S.y?q.y:S.y;return new G(b,z)}static Transform(q,S){return G.TransformToRef(q,S,new G)}static TransformToRef(q,S,b){const z=S.m,C=q.x*z[0]+q.y*z[4]+z[12],v=q.x*z[1]+q.y*z[5]+z[13];return b.x=C,b.y=v,b}static PointInTriangle(q,S,b,z){const C=.5*(-b.y*z.x+S.y*(-b.x+z.x)+S.x*(b.y-z.y)+b.x*z.y),v=C<0?-1:1,U=(S.y*z.x-S.x*z.y+(z.y-S.y)*q.x+(S.x-z.x)*q.y)*v,g=(S.x*b.y-S.y*b.x+(S.y-b.y)*q.x+(b.x-S.x)*q.y)*v;return U>0&&g>0&&U+g<2*C*v}static Distance(q,S){return Math.sqrt(G.DistanceSquared(q,S))}static DistanceSquared(q,S){const b=q.x-S.x,z=q.y-S.y;return b*b+z*z}static Center(q,S){return G.CenterToRef(q,S,new G)}static CenterToRef(q,S,b){return b.Bb((q.x+S.x)/2,(q.y+S.y)/2)}static DistanceOfPointFromSegment(q,S,b){const z=G.DistanceSquared(S,b);if(0===z)return G.Distance(q,S);const C=b.RS(S),v=Math.max(0,Math.min(1,G.Dot(q.RS(S),C)/z)),U=S.add(C.multiplyByFloats(v,v));return G.Distance(q,U)}}G._V8PerformanceHack=new G(.5,.5),G._ZeroReadOnly=G.Zero(),Object.defineProperties(G.prototype,{dimension:{value:[2]},rank:{value:1}});class Z{get x(){return this._x}set x(q){this._x=q,this._isDirty=!0}get y(){return this._y}set y(q){this._y=q,this._isDirty=!0}get z(){return this._z}set z(q){this._z=q,this._isDirty=!0}constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=q,this._y=S,this._z=b}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"yS"}getHashCode(){let q=R(this._x);return q=397*q^R(this._y),q=397*q^R(this._z),q}Zb(){return[this._x,this._y,this._z]}toArray(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q[S]=this._x,q[S+1]=this._y,q[S+2]=this._z,this}Uz(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z.FromArrayToRef(q,S,this),this}toQuaternion(){return Q.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(q){return this._x+=q._x,this._y+=q._y,this._z+=q._z,this._isDirty=!0,this}addInPlaceFromFloats(q,S,b){return this._x+=q,this._y+=S,this._z+=b,this._isDirty=!0,this}add(q){return new Z(this._x+q._x,this._y+q._y,this._z+q._z)}addToRef(q,S){return S._x=this._x+q._x,S._y=this._y+q._y,S._z=this._z+q._z,S._isDirty=!0,S}Ql(q){return this._x-=q._x,this._y-=q._y,this._z-=q._z,this._isDirty=!0,this}RS(q){return new Z(this._x-q._x,this._y-q._y,this._z-q._z)}subtractToRef(q,S){return this.subtractFromFloatsToRef(q._x,q._y,q._z,S)}subtractFromFloats(q,S,b){return new Z(this._x-q,this._y-S,this._z-b)}subtractFromFloatsToRef(q,S,b,z){return z._x=this._x-q,z._y=this._y-S,z._z=this._z-b,z._isDirty=!0,z}negate(){return new Z(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(q){return q._x=-1*this._x,q._y=-1*this._y,q._z=-1*this._z,q._isDirty=!0,q}scaleInPlace(q){return this._x*=q,this._y*=q,this._z*=q,this._isDirty=!0,this}scale(q){return new Z(this._x*q,this._y*q,this._z*q)}scaleToRef(q,S){return S._x=this._x*q,S._y=this._y*q,S._z=this._z*q,S._isDirty=!0,S}getNormalToRef(q){const S=this.length();let b=Math.acos(this._y/S);const z=Math.atan2(this._z,this._x);b>Math.PI/2?b-=Math.PI/2:b+=Math.PI/2;const C=S*Math.sin(b)*Math.cos(z),v=S*Math.cos(b),U=S*Math.sin(b)*Math.sin(z);return q.set(C,v,U),q}applyRotationQuaternionToRef(q,S){const b=this._x,z=this._y,C=this._z,v=q._x,U=q._y,g=q._z,r=q._w,I=2*(U*C-g*z),V=2*(g*b-v*C),l=2*(v*z-U*b);return S._x=b+r*I+U*l-g*V,S._y=z+r*V+g*I-v*l,S._z=C+r*l+v*V-U*I,S._isDirty=!0,S}applyRotationQuaternionInPlace(q){return this.applyRotationQuaternionToRef(q,this)}applyRotationQuaternion(q){return this.applyRotationQuaternionToRef(q,new Z)}scaleAndAddToRef(q,S){return S._x+=this._x*q,S._y+=this._y*q,S._z+=this._z*q,S._isDirty=!0,S}projectOnPlane(q,S){return this.projectOnPlaneToRef(q,S,new Z)}projectOnPlaneToRef(q,S,b){const z=q.normal,C=q.d,v=W.yS[0];this.subtractToRef(S,v),v.normalize();const U=Z.Dot(v,z);if(Math.abs(U)<1e-10)b.fb(1/0);else{const q=-(Z.Dot(S,z)+C)/U,g=v.scaleInPlace(q);S.addToRef(g,b)}return b}equals(q){return q&&this._x===q._x&&this._y===q._y&&this._z===q._z}equalsWithEpsilon(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.d;return q&&(0,r.WithinEpsilon)(this._x,q._x,S)&&(0,r.WithinEpsilon)(this._y,q._y,S)&&(0,r.WithinEpsilon)(this._z,q._z,S)}equalsToFloats(q,S,b){return this._x===q&&this._y===S&&this._z===b}multiplyInPlace(q){return this._x*=q._x,this._y*=q._y,this._z*=q._z,this._isDirty=!0,this}multiply(q){return this.multiplyByFloats(q._x,q._y,q._z)}multiplyToRef(q,S){return S._x=this._x*q._x,S._y=this._y*q._y,S._z=this._z*q._z,S._isDirty=!0,S}multiplyByFloats(q,S,b){return new Z(this._x*q,this._y*S,this._z*b)}divide(q){return new Z(this._x/q._x,this._y/q._y,this._z/q._z)}divideToRef(q,S){return S._x=this._x/q._x,S._y=this._y/q._y,S._z=this._z/q._z,S._isDirty=!0,S}divideInPlace(q){return this._x=this._x/q._x,this._y=this._y/q._y,this._z=this._z/q._z,this._isDirty=!0,this}minimizeInPlace(q){return this.minimizeInPlaceFromFloats(q._x,q._y,q._z)}maximizeInPlace(q){return this.maximizeInPlaceFromFloats(q._x,q._y,q._z)}minimizeInPlaceFromFloats(q,S,b){return q<this._x&&(this.x=q),S<this._y&&(this.y=S),b<this._z&&(this.z=b),this}maximizeInPlaceFromFloats(q,S,b){return q>this._x&&(this.x=q),S>this._y&&(this.y=S),b>this._z&&(this.z=b),this}isNonUniformWithinEpsilon(q){const S=Math.abs(this._x),b=Math.abs(this._y);if(!(0,r.WithinEpsilon)(S,b,q))return!0;const z=Math.abs(this._z);return!(0,r.WithinEpsilon)(S,z,q)||!(0,r.WithinEpsilon)(b,z,q)}get isNonUniform(){const q=Math.abs(this._x);if(q!==Math.abs(this._y))return!0;return q!==Math.abs(this._z)}floorToRef(q){return q._x=Math.floor(this._x),q._y=Math.floor(this._y),q._z=Math.floor(this._z),q._isDirty=!0,q}floor(){return new Z(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(q){return q._x=this._x-Math.floor(this._x),q._y=this._y-Math.floor(this._y),q._z=this._z-Math.floor(this._z),q._isDirty=!0,q}fract(){return new Z(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(q){if("xyz"===(q=q.toLowerCase()))return this;const S=W.yS[0].v(this);return this.x=S[q[0]],this.y=S[q[1]],this.z=S[q[2]],this}rotateByQuaternionToRef(q,S){return q.toRotationMatrix(W.Matrix[0]),Z.TransformCoordinatesToRef(this,W.Matrix[0],S),S}rotateByQuaternionAroundPointToRef(q,S,b){return this.subtractToRef(S,W.yS[0]),W.yS[0].rotateByQuaternionToRef(q,W.yS[0]),S.addToRef(W.yS[0],b),b}cross(q){return Z.CrossToRef(this,q,new Z)}normalizeFromLength(q){return 0===q||1===q?this:this.scaleInPlace(1/q)}normalizeToNew(){return this.normalizeToRef(new Z)}normalizeToRef(q){const S=this.length();return 0===S||1===S?(q._x=this._x,q._y=this._y,q._z=this._z,q._isDirty=!0,q):this.scaleToRef(1/S,q)}clone(){return new Z(this._x,this._y,this._z)}v(q){return this.Bb(q._x,q._y,q._z)}Bb(q,S,b){return this._x=q,this._y=S,this._z=b,this._isDirty=!0,this}set(q,S,b){return this.Bb(q,S,b)}fb(q){return this._x=this._y=this._z=q,this._isDirty=!0,this}static GetClipFactor(q,S,b,z){const C=Z.Dot(q,b);return(C-z)/(C-Z.Dot(S,b))}static GetAngleBetweenVectors(q,S,b){const z=q.normalizeToRef(W.yS[1]),C=S.normalizeToRef(W.yS[2]);let v=Z.Dot(z,C);v=(0,r.Clamp)(v,-1,1);const U=Math.acos(v),g=W.yS[3];return Z.CrossToRef(z,C,g),Z.Dot(g,b)>0?isNaN(U)?0:U:isNaN(U)?-Math.PI:-Math.acos(v)}static GetAngleBetweenVectorsOnPlane(q,S,b){W.yS[0].v(q);const z=W.yS[0];W.yS[1].v(S);const C=W.yS[1];W.yS[2].v(b);const v=W.yS[2],U=W.yS[3],g=W.yS[4];z.normalize(),C.normalize(),v.normalize(),Z.CrossToRef(v,z,U),Z.CrossToRef(U,v,g);const I=Math.atan2(Z.Dot(C,U),Z.Dot(C,g));return(0,r.NormalizeRadians)(I)}static PitchYawRollToMoveBetweenPointsToRef(q,S,b){const z=N.yS[0];return S.subtractToRef(q,z),b._y=Math.atan2(z.x,z.z)||0,b._x=Math.atan2(Math.sqrt(z.x**2+z.z**2),z.y)||0,b._z=0,b._isDirty=!0,b}static PitchYawRollToMoveBetweenPoints(q,S){const b=Z.Zero();return Z.PitchYawRollToMoveBetweenPointsToRef(q,S,b)}static SlerpToRef(q,S,b,C){b=(0,r.Clamp)(b,0,1);const v=W.yS[0],U=W.yS[1];v.v(q);const g=v.length();v.normalizeFromLength(g),U.v(S);const I=U.length();U.normalizeFromLength(I);const V=Z.Dot(v,U);let l,y;if(V<1-z.d){const q=Math.acos(V),S=1/Math.sin(q);l=Math.sin((1-b)*q)*S,y=Math.sin(b*q)*S}else l=1-b,y=b;return v.scaleInPlace(l),U.scaleInPlace(y),C.v(v).addInPlace(U),C.scaleInPlace((0,r.Lerp)(g,I,b)),C}static SmoothToRef(q,S,b,z,C){return Z.SlerpToRef(q,S,0===z?1:b/z,C),C}static Hb(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Z(q[S],q[S+1],q[S+2])}static FromFloatArray(q,S){return Z.Hb(q,S)}static FromArrayToRef(q,S,b){return b._x=q[S],b._y=q[S+1],b._z=q[S+2],b._isDirty=!0,b}static FromFloatArrayToRef(q,S,b){return Z.FromArrayToRef(q,S,b)}static FromFloatsToRef(q,S,b,z){return z.Bb(q,S,b),z}static Zero(){return new Z(0,0,0)}static One(){return new Z(1,1,1)}static Up(){return new Z(0,1,0)}static get UpReadOnly(){return Z._UpReadOnly}static get DownReadOnly(){return Z._DownReadOnly}static get RightReadOnly(){return Z._RightReadOnly}static get LeftReadOnly(){return Z._LeftReadOnly}static get LeftHandedForwardReadOnly(){return Z._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return Z._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return Z._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return Z._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return Z._ZeroReadOnly}static get OneReadOnly(){return Z._OneReadOnly}static Down(){return new Z(0,-1,0)}static Forward(){return new Z(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new Z(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new Z(1,0,0)}static Left(){return new Z(-1,0,0)}static Random(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Z((0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S))}static RandomToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Bb((0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S))}static TransformCoordinates(q,S){const b=Z.Zero();return Z.TransformCoordinatesToRef(q,S,b),b}static TransformCoordinatesToRef(q,S,b){return Z.TransformCoordinatesFromFloatsToRef(q._x,q._y,q._z,S,b),b}static TransformCoordinatesFromFloatsToRef(q,S,b,z,C){const v=z.m,U=q*v[0]+S*v[4]+b*v[8]+v[12],g=q*v[1]+S*v[5]+b*v[9]+v[13],r=q*v[2]+S*v[6]+b*v[10]+v[14],I=1/(q*v[3]+S*v[7]+b*v[11]+v[15]);return C._x=U*I,C._y=g*I,C._z=r*I,C._isDirty=!0,C}static TransformNormal(q,S){const b=Z.Zero();return Z.TransformNormalToRef(q,S,b),b}static TransformNormalToRef(q,S,b){return this.TransformNormalFromFloatsToRef(q._x,q._y,q._z,S,b),b}static TransformNormalFromFloatsToRef(q,S,b,z,C){const v=z.m;return C._x=q*v[0]+S*v[4]+b*v[8],C._y=q*v[1]+S*v[5]+b*v[9],C._z=q*v[2]+S*v[6]+b*v[10],C._isDirty=!0,C}static CatmullRom(q,S,b,z,C){const v=C*C,U=C*v,g=.5*(2*S._x+(-q._x+b._x)*C+(2*q._x-5*S._x+4*b._x-z._x)*v+(-q._x+3*S._x-3*b._x+z._x)*U),r=.5*(2*S._y+(-q._y+b._y)*C+(2*q._y-5*S._y+4*b._y-z._y)*v+(-q._y+3*S._y-3*b._y+z._y)*U),I=.5*(2*S._z+(-q._z+b._z)*C+(2*q._z-5*S._z+4*b._z-z._z)*v+(-q._z+3*S._z-3*b._z+z._z)*U);return new Z(g,r,I)}static Clamp(q,S,b){const z=new Z;return Z.ClampToRef(q,S,b,z),z}static ClampToRef(q,S,b,z){let C=q._x;C=C>b._x?b._x:C,C=C<S._x?S._x:C;let v=q._y;v=v>b._y?b._y:v,v=v<S._y?S._y:v;let U=q._z;return U=U>b._z?b._z:U,U=U<S._z?S._z:U,z.Bb(C,v,U),z}static CheckExtends(q,S,b){S.minimizeInPlace(q),b.maximizeInPlace(q)}static Hermite(q,S,b,z,C){const v=C*C,U=C*v,g=2*U-3*v+1,r=-2*U+3*v,I=U-2*v+C,V=U-v,l=q._x*g+b._x*r+S._x*I+z._x*V,y=q._y*g+b._y*r+S._y*I+z._y*V,R=q._z*g+b._z*r+S._z*I+z._z*V;return new Z(l,y,R)}static Hermite1stDerivative(q,S,b,z,C){const v=new Z;return this.Hermite1stDerivativeToRef(q,S,b,z,C,v),v}static Hermite1stDerivativeToRef(q,S,b,z,C,v){const U=C*C;return v._x=6*(U-C)*q._x+(3*U-4*C+1)*S._x+6*(-U+C)*b._x+(3*U-2*C)*z._x,v._y=6*(U-C)*q._y+(3*U-4*C+1)*S._y+6*(-U+C)*b._y+(3*U-2*C)*z._y,v._z=6*(U-C)*q._z+(3*U-4*C+1)*S._z+6*(-U+C)*b._z+(3*U-2*C)*z._z,v._isDirty=!0,v}static Lerp(q,S,b){const z=new Z(0,0,0);return Z.LerpToRef(q,S,b,z),z}static LerpToRef(q,S,b,z){return z._x=q._x+(S._x-q._x)*b,z._y=q._y+(S._y-q._y)*b,z._z=q._z+(S._z-q._z)*b,z._isDirty=!0,z}static Dot(q,S){return q._x*S._x+q._y*S._y+q._z*S._z}dot(q){return this._x*q._x+this._y*q._y+this._z*q._z}static Cross(q,S){const b=new Z;return Z.CrossToRef(q,S,b),b}static CrossToRef(q,S,b){const z=q._y*S._z-q._z*S._y,C=q._z*S._x-q._x*S._z,v=q._x*S._y-q._y*S._x;return b.Bb(z,C,v),b}static Normalize(q){const S=Z.Zero();return Z.NormalizeToRef(q,S),S}static NormalizeToRef(q,S){return q.normalizeToRef(S),S}static Project(q,S,b,z){const C=new Z;return Z.ProjectToRef(q,S,b,z,C),C}static ProjectToRef(q,S,b,z,C){var v;const U=z.width,r=z.height,I=z.x,V=z.y,l=W.Matrix[1],y=null===(v=g.b.LastCreatedEngine)||void 0===v?void 0:v.isNDCHalfZRange,R=y?1:.5,G=y?0:.5;k.FromValuesToRef(U/2,0,0,0,0,-r/2,0,0,0,0,R,0,I+U/2,r/2+V,G,1,l);const H=W.Matrix[0];return S.multiplyToRef(b,H),H.multiplyToRef(l,H),Z.TransformCoordinatesToRef(q,H,C),C}static Reflect(q,S){return this.ReflectToRef(q,S,new Z)}static ReflectToRef(q,S,b){const z=N.yS[0];return z.v(S).scaleInPlace(2*Z.Dot(q,S)),b.v(q).Ql(z)}static _UnprojectFromInvertedMatrixToRef(q,S,b){Z.TransformCoordinatesToRef(q,S,b);const z=S.m,C=q._x*z[3]+q._y*z[7]+q._z*z[11]+z[15];return(0,r.WithinEpsilon)(C,1)&&b.scaleInPlace(1/C),b}static UnprojectFromTransform(q,S,b,z,C){return this.Unproject(q,S,b,z,C,k.IdentityReadOnly)}static Unproject(q,S,b,z,C,v){const U=new Z;return Z.UnprojectToRef(q,S,b,z,C,v,U),U}static UnprojectToRef(q,S,b,z,C,v,U){return Z.UnprojectFloatsToRef(q._x,q._y,q._z,S,b,z,C,v,U),U}static UnprojectFloatsToRef(q,S,b,z,C,v,U,r,I){var V;const l=W.Matrix[0];v.multiplyToRef(U,l),l.multiplyToRef(r,l),l.invert();const y=W.yS[0];return y.x=q/z*2-1,y.y=-(S/C*2-1),null!==(V=g.b.LastCreatedEngine)&&void 0!==V&&V.isNDCHalfZRange?y.z=b:y.z=2*b-1,Z._UnprojectFromInvertedMatrixToRef(y,l,I),I}static Minimize(q,S){const b=new Z;return b.v(q),b.minimizeInPlace(S),b}static Maximize(q,S){const b=new Z;return b.v(q),b.maximizeInPlace(S),b}static Distance(q,S){return Math.sqrt(Z.DistanceSquared(q,S))}static DistanceSquared(q,S){const b=q._x-S._x,z=q._y-S._y,C=q._z-S._z;return b*b+z*z+C*C}static ProjectOnTriangleToRef(q,S,b,C,v){const U=W.yS[0],g=W.yS[1],I=W.yS[2],V=W.yS[3],l=W.yS[4];b.subtractToRef(S,U),C.subtractToRef(S,g),C.subtractToRef(b,I);const y=U.length(),R=g.length(),G=I.length();if(y<z.d||R<z.d||G<z.d)return v.v(S),Z.Distance(q,S);q.subtractToRef(S,l),Z.CrossToRef(U,g,V);const H=V.length();if(H<z.d)return v.v(S),Z.Distance(q,S);V.normalizeFromLength(H);let Q=l.length();if(Q<z.d)return v.v(S),0;l.normalizeFromLength(Q);const k=Z.Dot(V,l),N=W.yS[5],u=W.yS[6];N.v(V).scaleInPlace(-Q*k),u.v(q).addInPlace(N);const X=W.yS[4],T=W.yS[5],B=W.yS[7],t=W.yS[8];X.v(U).scaleInPlace(1/y),t.v(g).scaleInPlace(1/R),X.addInPlace(t).scaleInPlace(-1),T.v(U).scaleInPlace(-1/y),t.v(I).scaleInPlace(1/G),T.addInPlace(t).scaleInPlace(-1),B.v(I).scaleInPlace(-1/G),t.v(g).scaleInPlace(-1/R),B.addInPlace(t).scaleInPlace(-1);const f=W.yS[9];let m;f.v(u).Ql(S),Z.CrossToRef(X,f,t),m=Z.Dot(t,V);const E=m;f.v(u).Ql(b),Z.CrossToRef(T,f,t),m=Z.Dot(t,V);const e=m;f.v(u).Ql(C),Z.CrossToRef(B,f,t),m=Z.Dot(t,V);const i=m,J=W.yS[10];let L,d;E>0&&e<0?(J.v(U),L=S,d=b):e>0&&i<0?(J.v(I),L=b,d=C):(J.v(g).scaleInPlace(-1),L=C,d=S);const K=W.yS[9],D=W.yS[4];L.subtractToRef(u,t),d.subtractToRef(u,K),Z.CrossToRef(t,K,D);if(!(Z.Dot(D,V)<0))return v.v(u),Math.abs(Q*k);const x=W.yS[5];Z.CrossToRef(J,D,x),x.normalize();const F=W.yS[9];F.v(L).Ql(u);const a=F.length();if(a<z.d)return v.v(L),Z.Distance(q,L);F.normalizeFromLength(a);const n=Z.Dot(x,F),o=W.yS[7];o.v(u).addInPlace(x.scaleInPlace(a*n)),t.v(o).Ql(L),Q=J.length(),J.normalizeFromLength(Q);let s=Z.Dot(t,J)/Math.max(Q,z.d);return s=(0,r.Clamp)(s,0,1),o.v(L).addInPlace(J.scaleInPlace(s*Q)),v.v(o),Z.Distance(q,o)}static Center(q,S){return Z.CenterToRef(q,S,Z.Zero())}static CenterToRef(q,S,b){return b.Bb((q._x+S._x)/2,(q._y+S._y)/2,(q._z+S._z)/2)}static RotationFromAxis(q,S,b){const z=new Z;return Z.RotationFromAxisToRef(q,S,b,z),z}static RotationFromAxisToRef(q,S,b,z){const C=W.Quaternion[0];return Q.RotationQuaternionFromAxisToRef(q,S,b,C),C.toEulerAnglesToRef(z),z}}Z._V8PerformanceHack=new Z(.5,.5,.5),Z._UpReadOnly=Z.Up(),Z._DownReadOnly=Z.Down(),Z._LeftHandedForwardReadOnly=Z.Forward(!1),Z._RightHandedForwardReadOnly=Z.Forward(!0),Z._LeftHandedBackwardReadOnly=Z.Backward(!1),Z._RightHandedBackwardReadOnly=Z.Backward(!0),Z._RightReadOnly=Z.Right(),Z._LeftReadOnly=Z.Left(),Z._ZeroReadOnly=Z.Zero(),Z._OneReadOnly=Z.One(),Object.defineProperties(Z.prototype,{dimension:{value:[3]},rank:{value:1}});class H{get x(){return this._x}set x(q){this._x=q,this._isDirty=!0}get y(){return this._y}set y(q){this._y=q,this._isDirty=!0}get z(){return this._z}set z(q){this._z=q,this._isDirty=!0}get w(){return this._w}set w(q){this._w=q,this._isDirty=!0}constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=q,this._y=S,this._z=b,this._w=z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let q=R(this._x);return q=397*q^R(this._y),q=397*q^R(this._z),q=397*q^R(this._w),q}Zb(){return[this._x,this._y,this._z,this._w]}toArray(q,S){return void 0===S&&(S=0),q[S]=this._x,q[S+1]=this._y,q[S+2]=this._z,q[S+3]=this._w,this}Uz(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H.FromArrayToRef(q,S,this),this}addInPlace(q){return this.x+=q._x,this.y+=q._y,this.z+=q._z,this.w+=q._w,this}addInPlaceFromFloats(q,S,b,z){return this.x+=q,this.y+=S,this.z+=b,this.w+=z,this}add(q){return new H(this._x+q.x,this._y+q.y,this._z+q.z,this._w+q.w)}addToRef(q,S){return S.x=this._x+q.x,S.y=this._y+q.y,S.z=this._z+q.z,S.w=this._w+q.w,S}Ql(q){return this.x-=q.x,this.y-=q.y,this.z-=q.z,this.w-=q.w,this}RS(q){return new H(this._x-q.x,this._y-q.y,this._z-q.z,this._w-q.w)}subtractToRef(q,S){return S.x=this._x-q.x,S.y=this._y-q.y,S.z=this._z-q.z,S.w=this._w-q.w,S}subtractFromFloats(q,S,b,z){return new H(this._x-q,this._y-S,this._z-b,this._w-z)}subtractFromFloatsToRef(q,S,b,z,C){return C.x=this._x-q,C.y=this._y-S,C.z=this._z-b,C.w=this._w-z,C}negate(){return new H(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(q){return q.x=-this._x,q.y=-this._y,q.z=-this._z,q.w=-this._w,q}scaleInPlace(q){return this.x*=q,this.y*=q,this.z*=q,this.w*=q,this}scale(q){return new H(this._x*q,this._y*q,this._z*q,this._w*q)}scaleToRef(q,S){return S.x=this._x*q,S.y=this._y*q,S.z=this._z*q,S.w=this._w*q,S}scaleAndAddToRef(q,S){return S.x+=this._x*q,S.y+=this._y*q,S.z+=this._z*q,S.w+=this._w*q,S}equals(q){return q&&this._x===q.x&&this._y===q.y&&this._z===q.z&&this._w===q.w}equalsWithEpsilon(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.d;return q&&(0,r.WithinEpsilon)(this._x,q.x,S)&&(0,r.WithinEpsilon)(this._y,q.y,S)&&(0,r.WithinEpsilon)(this._z,q.z,S)&&(0,r.WithinEpsilon)(this._w,q.w,S)}equalsToFloats(q,S,b,z){return this._x===q&&this._y===S&&this._z===b&&this._w===z}multiplyInPlace(q){return this.x*=q.x,this.y*=q.y,this.z*=q.z,this.w*=q.w,this}multiply(q){return new H(this._x*q.x,this._y*q.y,this._z*q.z,this._w*q.w)}multiplyToRef(q,S){return S.x=this._x*q.x,S.y=this._y*q.y,S.z=this._z*q.z,S.w=this._w*q.w,S}multiplyByFloats(q,S,b,z){return new H(this._x*q,this._y*S,this._z*b,this._w*z)}divide(q){return new H(this._x/q.x,this._y/q.y,this._z/q.z,this._w/q.w)}divideToRef(q,S){return S.x=this._x/q.x,S.y=this._y/q.y,S.z=this._z/q.z,S.w=this._w/q.w,S}divideInPlace(q){return this.divideToRef(q,this)}minimizeInPlace(q){return q.x<this._x&&(this.x=q.x),q.y<this._y&&(this.y=q.y),q.z<this._z&&(this.z=q.z),q.w<this._w&&(this.w=q.w),this}maximizeInPlace(q){return q.x>this._x&&(this.x=q.x),q.y>this._y&&(this.y=q.y),q.z>this._z&&(this.z=q.z),q.w>this._w&&(this.w=q.w),this}minimizeInPlaceFromFloats(q,S,b,z){return this.x=Math.min(q,this._x),this.y=Math.min(S,this._y),this.z=Math.min(b,this._z),this.w=Math.min(z,this._w),this}maximizeInPlaceFromFloats(q,S,b,z){return this.x=Math.max(q,this._x),this.y=Math.max(S,this._y),this.z=Math.max(b,this._z),this.w=Math.max(z,this._w),this}floorToRef(q){return q.x=Math.floor(this._x),q.y=Math.floor(this._y),q.z=Math.floor(this._z),q.w=Math.floor(this._w),q}floor(){return new H(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(q){return q.x=this._x-Math.floor(this._x),q.y=this._y-Math.floor(this._y),q.z=this._z-Math.floor(this._z),q.w=this._w-Math.floor(this._w),q}fract(){return new H(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(q){return 0===q||1===q?this:this.scaleInPlace(1/q)}normalizeToNew(){return this.normalizeToRef(new H)}normalizeToRef(q){const S=this.length();return 0===S||1===S?(q.x=this._x,q.y=this._y,q.z=this._z,q.w=this._w,q):this.scaleToRef(1/S,q)}toVector3(){return new Z(this._x,this._y,this._z)}clone(){return new H(this._x,this._y,this._z,this._w)}v(q){return this.x=q.x,this.y=q.y,this.z=q.z,this.w=q.w,this}Bb(q,S,b,z){return this.x=q,this.y=S,this.z=b,this.w=z,this}set(q,S,b,z){return this.Bb(q,S,b,z)}fb(q){return this.x=this.y=this.z=this.w=q,this}dot(q){return this._x*q.x+this._y*q.y+this._z*q.z+this._w*q.w}static Hb(q,S){return S||(S=0),new H(q[S],q[S+1],q[S+2],q[S+3])}static FromArrayToRef(q,S,b){return b.x=q[S],b.y=q[S+1],b.z=q[S+2],b.w=q[S+3],b}static FromFloatArrayToRef(q,S,b){return H.FromArrayToRef(q,S,b),b}static FromFloatsToRef(q,S,b,z,C){return C.x=q,C.y=S,C.z=b,C.w=z,C}static Zero(){return new H(0,0,0,0)}static One(){return new H(1,1,1,1)}static Random(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new H((0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S))}static RandomToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.x=(0,r.RandomRange)(q,S),b.y=(0,r.RandomRange)(q,S),b.z=(0,r.RandomRange)(q,S),b.w=(0,r.RandomRange)(q,S),b}static Clamp(q,S,b){return H.ClampToRef(q,S,b,new H)}static ClampToRef(q,S,b,z){return z.x=(0,r.Clamp)(q.x,S.x,b.x),z.y=(0,r.Clamp)(q.y,S.y,b.y),z.z=(0,r.Clamp)(q.z,S.z,b.z),z.w=(0,r.Clamp)(q.w,S.w,b.w),z}static CheckExtends(q,S,b){S.minimizeInPlace(q),b.maximizeInPlace(q)}static get ZeroReadOnly(){return H._ZeroReadOnly}static Normalize(q){return H.NormalizeToRef(q,new H)}static NormalizeToRef(q,S){return q.normalizeToRef(S),S}static Minimize(q,S){const b=new H;return b.v(q),b.minimizeInPlace(S),b}static Maximize(q,S){const b=new H;return b.v(q),b.maximizeInPlace(S),b}static Distance(q,S){return Math.sqrt(H.DistanceSquared(q,S))}static DistanceSquared(q,S){const b=q.x-S.x,z=q.y-S.y,C=q.z-S.z,v=q.w-S.w;return b*b+z*z+C*C+v*v}static Center(q,S){return H.CenterToRef(q,S,new H)}static CenterToRef(q,S,b){return b.x=(q.x+S.x)/2,b.y=(q.y+S.y)/2,b.z=(q.z+S.z)/2,b.w=(q.w+S.w)/2,b}static TransformCoordinates(q,S){return H.TransformCoordinatesToRef(q,S,new H)}static TransformCoordinatesToRef(q,S,b){return H.TransformCoordinatesFromFloatsToRef(q._x,q._y,q._z,S,b),b}static TransformCoordinatesFromFloatsToRef(q,S,b,z,C){const v=z.m,U=q*v[0]+S*v[4]+b*v[8]+v[12],g=q*v[1]+S*v[5]+b*v[9]+v[13],r=q*v[2]+S*v[6]+b*v[10]+v[14],I=q*v[3]+S*v[7]+b*v[11]+v[15];return C.x=U,C.y=g,C.z=r,C.w=I,C}static TransformNormal(q,S){return H.TransformNormalToRef(q,S,new H)}static TransformNormalToRef(q,S,b){const z=S.m,C=q.x*z[0]+q.y*z[4]+q.z*z[8],v=q.x*z[1]+q.y*z[5]+q.z*z[9],U=q.x*z[2]+q.y*z[6]+q.z*z[10];return b.x=C,b.y=v,b.z=U,b.w=q.w,b}static TransformNormalFromFloatsToRef(q,S,b,z,C,v){const U=C.m;return v.x=q*U[0]+S*U[4]+b*U[8],v.y=q*U[1]+S*U[5]+b*U[9],v.z=q*U[2]+S*U[6]+b*U[10],v.w=z,v}static FromVector3(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new H(q._x,q._y,q._z,S)}static Dot(q,S){return q.x*S.x+q.y*S.y+q.z*S.z+q.w*S.w}}H._V8PerformanceHack=new H(.5,.5,.5,.5),H._ZeroReadOnly=H.Zero(),Object.defineProperties(H.prototype,{dimension:{value:[4]},rank:{value:1}});class Q{get x(){return this._x}set x(q){this._x=q,this._isDirty=!0}get y(){return this._y}set y(q){this._y=q,this._isDirty=!0}get z(){return this._z}set z(q){this._z=q,this._isDirty=!0}get w(){return this._w}set w(q){this._w=q,this._isDirty=!0}constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=q,this._y=S,this._z=b,this._w=z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let q=R(this._x);return q=397*q^R(this._y),q=397*q^R(this._z),q=397*q^R(this._w),q}Zb(){return[this._x,this._y,this._z,this._w]}toArray(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q[S]=this._x,q[S+1]=this._y,q[S+2]=this._z,q[S+3]=this._w,this}Uz(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(q,S,this)}equals(q){return q&&this._x===q._x&&this._y===q._y&&this._z===q._z&&this._w===q._w}equalsWithEpsilon(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.d;return q&&(0,r.WithinEpsilon)(this._x,q._x,S)&&(0,r.WithinEpsilon)(this._y,q._y,S)&&(0,r.WithinEpsilon)(this._z,q._z,S)&&(0,r.WithinEpsilon)(this._w,q._w,S)}isApprox(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.d;return q&&((0,r.WithinEpsilon)(this._x,q._x,S)&&(0,r.WithinEpsilon)(this._y,q._y,S)&&(0,r.WithinEpsilon)(this._z,q._z,S)&&(0,r.WithinEpsilon)(this._w,q._w,S)||(0,r.WithinEpsilon)(this._x,-q._x,S)&&(0,r.WithinEpsilon)(this._y,-q._y,S)&&(0,r.WithinEpsilon)(this._z,-q._z,S)&&(0,r.WithinEpsilon)(this._w,-q._w,S))}clone(){return new Q(this._x,this._y,this._z,this._w)}v(q){return this._x=q._x,this._y=q._y,this._z=q._z,this._w=q._w,this._isDirty=!0,this}Bb(q,S,b,z){return this._x=q,this._y=S,this._z=b,this._w=z,this._isDirty=!0,this}set(q,S,b,z){return this.Bb(q,S,b,z)}fb(q){return this.Bb(q,q,q,q)}add(q){return new Q(this._x+q._x,this._y+q._y,this._z+q._z,this._w+q._w)}addInPlace(q){return this._x+=q._x,this._y+=q._y,this._z+=q._z,this._w+=q._w,this._isDirty=!0,this}addToRef(q,S){return S._x=this._x+q._x,S._y=this._y+q._y,S._z=this._z+q._z,S._w=this._w+q._w,S._isDirty=!0,S}addInPlaceFromFloats(q,S,b,z){return this._x+=q,this._y+=S,this._z+=b,this._w+=z,this._isDirty=!0,this}subtractToRef(q,S){return S._x=this._x-q._x,S._y=this._y-q._y,S._z=this._z-q._z,S._w=this._w-q._w,S._isDirty=!0,S}subtractFromFloats(q,S,b,z){return this.subtractFromFloatsToRef(q,S,b,z,new Q)}subtractFromFloatsToRef(q,S,b,z,C){return C._x=this._x-q,C._y=this._y-S,C._z=this._z-b,C._w=this._w-z,C._isDirty=!0,C}RS(q){return new Q(this._x-q._x,this._y-q._y,this._z-q._z,this._w-q._w)}Ql(q){return this._x-=q._x,this._y-=q._y,this._z-=q._z,this._w-=q._w,this._isDirty=!0,this}scale(q){return new Q(this._x*q,this._y*q,this._z*q,this._w*q)}scaleToRef(q,S){return S._x=this._x*q,S._y=this._y*q,S._z=this._z*q,S._w=this._w*q,S._isDirty=!0,S}scaleInPlace(q){return this._x*=q,this._y*=q,this._z*=q,this._w*=q,this._isDirty=!0,this}scaleAndAddToRef(q,S){return S._x+=this._x*q,S._y+=this._y*q,S._z+=this._z*q,S._w+=this._w*q,S._isDirty=!0,S}multiply(q){const S=new Q(0,0,0,1);return this.multiplyToRef(q,S),S}multiplyToRef(q,S){const b=this._x*q._w+this._y*q._z-this._z*q._y+this._w*q._x,z=-this._x*q._z+this._y*q._w+this._z*q._x+this._w*q._y,C=this._x*q._y-this._y*q._x+this._z*q._w+this._w*q._z,v=-this._x*q._x-this._y*q._y-this._z*q._z+this._w*q._w;return S.Bb(b,z,C,v),S}multiplyInPlace(q){return this.multiplyToRef(q,this)}multiplyByFloats(q,S,b,z){return this._x*=q,this._y*=S,this._z*=b,this._w*=z,this._isDirty=!0,this}divide(q){throw new ReferenceError("Can not divide a quaternion")}divideToRef(q,S){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(q){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new Q)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(q){return q._x=-this._x,q._y=-this._y,q._z=-this._z,q._w=-this._w,q._isDirty=!0,q}equalsToFloats(q,S,b,z){return this._x===q&&this._y===S&&this._z===b&&this._w===z}floorToRef(q){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(q){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(q){return q.Bb(-this._x,-this._y,-this._z,this._w),q}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new Q(-this._x,-this._y,-this._z,this._w)}invert(){const q=this.conjugate(),S=this.lengthSquared();return 0==S||1==S||q.scaleInPlace(1/S),q}invertInPlace(){this.conjugateInPlace();const q=this.lengthSquared();return 0==q||1==q||this.scaleInPlace(1/q),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(q){return 0===q||1===q?this:this.scaleInPlace(1/q)}normalizeToNew(){const q=new Q(0,0,0,1);return this.normalizeToRef(q),q}normalizeToRef(q){const S=this.length();return 0===S||1===S?q.Bb(this._x,this._y,this._z,this._w):this.scaleToRef(1/S,q)}toEulerAngles(){const q=Z.Zero();return this.toEulerAnglesToRef(q),q}toEulerAnglesToRef(q){const S=this._z,b=this._x,z=this._y,C=this._w,v=z*S-b*C,U=.4999999;if(v<-U)q._y=2*Math.atan2(z,C),q._x=Math.PI/2,q._z=0,q._isDirty=!0;else if(v>U)q._y=2*Math.atan2(z,C),q._x=-Math.PI/2,q._z=0,q._isDirty=!0;else{const U=C*C,g=S*S,r=b*b,I=z*z;q._z=Math.atan2(2*(b*z+S*C),-g-r+I+U),q._x=Math.asin(-2*v),q._y=Math.atan2(2*(S*b+z*C),g-r-I+U),q._isDirty=!0}return q}toAlphaBetaGammaToRef(q){const S=this._z,b=this._x,z=this._y,C=this._w,v=Math.sqrt(b*b+z*z),U=Math.sqrt(S*S+C*C),g=2*Math.atan2(v,U),r=2*Math.atan2(S,C),I=2*Math.atan2(z,b),V=(r+I)/2,l=(r-I)/2;return q.set(l,g,V),q}toRotationMatrix(q){return k.FromQuaternionToRef(this,q),q}fromRotationMatrix(q){return Q.FromRotationMatrixToRef(q,this),this}dot(q){return this._x*q._x+this._y*q._y+this._z*q._z+this._w*q._w}toAxisAngle(){const q=Z.Zero();return{axis:q,angle:this.toAxisAngleToRef(q)}}toAxisAngleToRef(q){let S=0;const b=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),z=this._w;return b>0?(S=2*Math.atan2(b,z),q.set(this._x/b,this._y/b,this._z/b)):(S=0,q.set(1,0,0)),S}static FromRotationMatrix(q){const S=new Q;return Q.FromRotationMatrixToRef(q,S),S}static FromRotationMatrixToRef(q,S){const b=q.m,z=b[0],C=b[4],v=b[8],U=b[1],g=b[5],r=b[9],I=b[2],V=b[6],l=b[10],y=z+g+l;let R;return y>0?(R=.5/Math.sqrt(y+1),S._w=.25/R,S._x=(V-r)*R,S._y=(v-I)*R,S._z=(U-C)*R,S._isDirty=!0):z>g&&z>l?(R=2*Math.sqrt(1+z-g-l),S._w=(V-r)/R,S._x=.25*R,S._y=(C+U)/R,S._z=(v+I)/R,S._isDirty=!0):g>l?(R=2*Math.sqrt(1+g-z-l),S._w=(v-I)/R,S._x=(C+U)/R,S._y=.25*R,S._z=(r+V)/R,S._isDirty=!0):(R=2*Math.sqrt(1+l-z-g),S._w=(U-C)/R,S._x=(v+I)/R,S._y=(r+V)/R,S._z=.25*R,S._isDirty=!0),S}static Dot(q,S){return q._x*S._x+q._y*S._y+q._z*S._z+q._w*S._w}static AreClose(q,S){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const z=Q.Dot(q,S);return 1-z*z<=b}static SmoothToRef(q,S,b,z,C){let v=0===z?1:b/z;return v=(0,r.Clamp)(v,0,1),Q.SlerpToRef(q,S,v,C),C}static Zero(){return new Q(0,0,0,0)}static Inverse(q){return new Q(-q._x,-q._y,-q._z,q._w)}static InverseToRef(q,S){return S.set(-q._x,-q._y,-q._z,q._w),S}static Identity(){return new Q(0,0,0,1)}static IsIdentity(q){return q&&0===q._x&&0===q._y&&0===q._z&&1===q._w}static RotationAxis(q,S){return Q.RotationAxisToRef(q,S,new Q)}static RotationAxisToRef(q,S,b){b._w=Math.cos(S/2);const z=Math.sin(S/2)/q.length();return b._x=q._x*z,b._y=q._y*z,b._z=q._z*z,b._isDirty=!0,b}static Hb(q,S){return S||(S=0),new Q(q[S],q[S+1],q[S+2],q[S+3])}static FromArrayToRef(q,S,b){return b._x=q[S],b._y=q[S+1],b._z=q[S+2],b._w=q[S+3],b._isDirty=!0,b}static FromFloatsToRef(q,S,b,z,C){return C.Bb(q,S,b,z),C}static FromEulerAngles(q,S,b){const z=new Q;return Q.RotationYawPitchRollToRef(S,q,b,z),z}static FromEulerAnglesToRef(q,S,b,z){return Q.RotationYawPitchRollToRef(S,q,b,z),z}static FromEulerVector(q){const S=new Q;return Q.RotationYawPitchRollToRef(q._y,q._x,q._z,S),S}static FromEulerVectorToRef(q,S){return Q.RotationYawPitchRollToRef(q._y,q._x,q._z,S),S}static FromUnitVectorsToRef(q,S,b){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z.d;const v=Z.Dot(q,S)+1;return v<C?Math.abs(q.x)>Math.abs(q.z)?b.set(-q.y,q.x,0,0):b.set(0,-q.z,q.y,0):(Z.CrossToRef(q,S,N.yS[0]),b.set(N.yS[0].x,N.yS[0].y,N.yS[0].z,v)),b.normalize()}static RotationYawPitchRoll(q,S,b){const z=new Q;return Q.RotationYawPitchRollToRef(q,S,b,z),z}static RotationYawPitchRollToRef(q,S,b,z){const C=.5*b,v=.5*S,U=.5*q,g=Math.sin(C),r=Math.cos(C),I=Math.sin(v),V=Math.cos(v),l=Math.sin(U),y=Math.cos(U);return z._x=y*I*r+l*V*g,z._y=l*V*r-y*I*g,z._z=y*V*g-l*I*r,z._w=y*V*r+l*I*g,z._isDirty=!0,z}static RotationAlphaBetaGamma(q,S,b){const z=new Q;return Q.RotationAlphaBetaGammaToRef(q,S,b,z),z}static RotationAlphaBetaGammaToRef(q,S,b,z){const C=.5*(b+q),v=.5*(b-q),U=.5*S;return z._x=Math.cos(v)*Math.sin(U),z._y=Math.sin(v)*Math.sin(U),z._z=Math.sin(C)*Math.cos(U),z._w=Math.cos(C)*Math.cos(U),z._isDirty=!0,z}static RotationQuaternionFromAxis(q,S,b){const z=new Q(0,0,0,0);return Q.RotationQuaternionFromAxisToRef(q,S,b,z),z}static RotationQuaternionFromAxisToRef(q,S,b,z){const C=W.Matrix[0];return q=q.normalizeToRef(W.yS[0]),S=S.normalizeToRef(W.yS[1]),b=b.normalizeToRef(W.yS[2]),k.FromXYZAxesToRef(q,S,b,C),Q.FromRotationMatrixToRef(C,z),z}static FromLookDirectionLH(q,S){const b=new Q;return Q.FromLookDirectionLHToRef(q,S,b),b}static FromLookDirectionLHToRef(q,S,b){const z=W.Matrix[0];return k.LookDirectionLHToRef(q,S,z),Q.FromRotationMatrixToRef(z,b),b}static FromLookDirectionRH(q,S){const b=new Q;return Q.FromLookDirectionRHToRef(q,S,b),b}static FromLookDirectionRHToRef(q,S,b){const z=W.Matrix[0];return k.LookDirectionRHToRef(q,S,z),Q.FromRotationMatrixToRef(z,b)}static Slerp(q,S,b){const z=Q.Identity();return Q.SlerpToRef(q,S,b,z),z}static SlerpToRef(q,S,b,z){let C,v,U=q._x*S._x+q._y*S._y+q._z*S._z+q._w*S._w,g=!1;if(U<0&&(g=!0,U=-U),U>.999999)v=1-b,C=g?-b:b;else{const q=Math.acos(U),S=1/Math.sin(q);v=Math.sin((1-b)*q)*S,C=g?-Math.sin(b*q)*S:Math.sin(b*q)*S}return z._x=v*q._x+C*S._x,z._y=v*q._y+C*S._y,z._z=v*q._z+C*S._z,z._w=v*q._w+C*S._w,z._isDirty=!0,z}static Hermite(q,S,b,z,C){const v=C*C,U=C*v,g=2*U-3*v+1,r=-2*U+3*v,I=U-2*v+C,V=U-v,l=q._x*g+b._x*r+S._x*I+z._x*V,y=q._y*g+b._y*r+S._y*I+z._y*V,R=q._z*g+b._z*r+S._z*I+z._z*V,G=q._w*g+b._w*r+S._w*I+z._w*V;return new Q(l,y,R,G)}static Hermite1stDerivative(q,S,b,z,C){const v=new Q;return this.Hermite1stDerivativeToRef(q,S,b,z,C,v),v}static Hermite1stDerivativeToRef(q,S,b,z,C,v){const U=C*C;return v._x=6*(U-C)*q._x+(3*U-4*C+1)*S._x+6*(-U+C)*b._x+(3*U-2*C)*z._x,v._y=6*(U-C)*q._y+(3*U-4*C+1)*S._y+6*(-U+C)*b._y+(3*U-2*C)*z._y,v._z=6*(U-C)*q._z+(3*U-4*C+1)*S._z+6*(-U+C)*b._z+(3*U-2*C)*z._z,v._w=6*(U-C)*q._w+(3*U-4*C+1)*S._w+6*(-U+C)*b._w+(3*U-2*C)*z._w,v._isDirty=!0,v}static Normalize(q){const S=Q.Zero();return Q.NormalizeToRef(q,S),S}static NormalizeToRef(q,S){return q.normalizeToRef(S),S}static Clamp(q,S,b){const z=new Q;return Q.ClampToRef(q,S,b,z),z}static ClampToRef(q,S,b,z){return z.Bb((0,r.Clamp)(q.x,S.x,b.x),(0,r.Clamp)(q.y,S.y,b.y),(0,r.Clamp)(q.z,S.z,b.z),(0,r.Clamp)(q.w,S.w,b.w))}static Random(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Q((0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S))}static RandomToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Bb((0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S),(0,r.RandomRange)(q,S))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(q,S){return Math.sqrt(Q.DistanceSquared(q,S))}static DistanceSquared(q,S){const b=q.x-S.x,z=q.y-S.y,C=q.z-S.z,v=q.w-S.w;return b*b+z*z+C*C+v*v}static Center(q,S){return Q.CenterToRef(q,S,Q.Zero())}static CenterToRef(q,S,b){return b.Bb((q.x+S.x)/2,(q.y+S.y)/2,(q.z+S.z)/2,(q.w+S.w)/2)}}Q._V8PerformanceHack=new Q(.5,.5,.5,.5),Object.defineProperties(Q.prototype,{dimension:{value:[4]},rank:{value:1}});class k{static get Use64Bits(){return U.c.MatrixUse64Bits}get m(){return this.rb}markAsUpdated(){this.updateFlag=I._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(q){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=q,this._isIdentity3x2=q||b,this._isIdentityDirty=!this._isIdentity&&S,this._isIdentity3x2Dirty=!this._isIdentity3x2&&z}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,U.c.MatrixTrackPrecisionChange&&U.c.MatrixTrackedMatrices.push(this),this.rb=new U.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const q=this.rb;this._isIdentity=1===q[0]&&0===q[1]&&0===q[2]&&0===q[3]&&0===q[4]&&1===q[5]&&0===q[6]&&0===q[7]&&0===q[8]&&0===q[9]&&1===q[10]&&0===q[11]&&0===q[12]&&0===q[13]&&0===q[14]&&1===q[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.rb[0]||1!==this.rb[5]||1!==this.rb[15]||0!==this.rb[1]||0!==this.rb[2]||0!==this.rb[3]||0!==this.rb[4]||0!==this.rb[6]||0!==this.rb[7]||0!==this.rb[8]||0!==this.rb[9]||0!==this.rb[10]||0!==this.rb[11]||0!==this.rb[12]||0!==this.rb[13]||0!==this.rb[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const q=this.rb,S=q[0],b=q[1],z=q[2],C=q[3],v=q[4],U=q[5],g=q[6],r=q[7],I=q[8],V=q[9],l=q[10],y=q[11],R=q[12],G=q[13],Z=q[14],H=q[15],Q=l*H-Z*y,k=V*H-G*y,W=V*Z-G*l,N=I*H-R*y,u=I*Z-l*R,X=I*G-R*V;return S*+(U*Q-g*k+r*W)+b*-(v*Q-g*N+r*u)+z*+(v*k-U*N+r*X)+C*-(v*W-U*u+g*X)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!q)return this.rb;const b=this.rb;for(let z=0;z<16;z++)q[S+z]=b[z];return this}Zb(){return this.rb}Uz(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k.FromArrayToRef(q,S,this)}Bb(){for(var q=arguments.length,S=new Array(q),b=0;b<q;b++)S[b]=arguments[b];return k.FromArrayToRef(S,0,this)}set(){const q=this.rb;for(let S=0;S<16;S++)q[S]=S<0||arguments.length<=S?void 0:arguments[S];return this.markAsUpdated(),this}fb(q){const S=this.rb;for(let b=0;b<16;b++)S[b]=q;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return k.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(q){const S=new k;return this.addToRef(q,S),S}addToRef(q,S){const b=this.rb,z=S.rb,C=q.m;for(let v=0;v<16;v++)z[v]=b[v]+C[v];return S.markAsUpdated(),S}addToSelf(q){const S=this.rb,b=q.m;return S[0]+=b[0],S[1]+=b[1],S[2]+=b[2],S[3]+=b[3],S[4]+=b[4],S[5]+=b[5],S[6]+=b[6],S[7]+=b[7],S[8]+=b[8],S[9]+=b[9],S[10]+=b[10],S[11]+=b[11],S[12]+=b[12],S[13]+=b[13],S[14]+=b[14],S[15]+=b[15],this.markAsUpdated(),this}addInPlace(q){const S=this.rb,b=q.m;for(let z=0;z<16;z++)S[z]+=b[z];return this.markAsUpdated(),this}addInPlaceFromFloats(){const q=this.rb;for(let S=0;S<16;S++)q[S]+=S<0||arguments.length<=S?void 0:arguments[S];return this.markAsUpdated(),this}RS(q){const S=this.rb,b=q.m;for(let z=0;z<16;z++)S[z]-=b[z];return this.markAsUpdated(),this}subtractToRef(q,S){const b=this.rb,z=q.m,C=S.rb;for(let v=0;v<16;v++)C[v]=b[v]-z[v];return S.markAsUpdated(),S}Ql(q){const S=this.rb,b=q.m;for(let z=0;z<16;z++)S[z]-=b[z];return this.markAsUpdated(),this}subtractFromFloats(){for(var q=arguments.length,S=new Array(q),b=0;b<q;b++)S[b]=arguments[b];return this.subtractFromFloatsToRef(...S,new k)}subtractFromFloatsToRef(){for(var q=arguments.length,S=new Array(q),b=0;b<q;b++)S[b]=arguments[b];const z=S.pop(),C=this.rb,v=z.rb,U=S;for(let g=0;g<16;g++)v[g]=C[g]-U[g];return z.markAsUpdated(),z}invertToRef(q){return!0===this._isIdentity?(k.IdentityToRef(q),q):(y(this,q.Zb())?q.markAsUpdated():q.v(this),q)}addAtIndex(q,S){return this.rb[q]+=S,this.markAsUpdated(),this}multiplyAtIndex(q,S){return this.rb[q]*=S,this.markAsUpdated(),this}setTranslationFromFloats(q,S,b){return this.rb[12]=q,this.rb[13]=S,this.rb[14]=b,this.markAsUpdated(),this}addTranslationFromFloats(q,S,b){return this.rb[12]+=q,this.rb[13]+=S,this.rb[14]+=b,this.markAsUpdated(),this}setTranslation(q){return this.setTranslationFromFloats(q._x,q._y,q._z)}getTranslation(){return new Z(this.rb[12],this.rb[13],this.rb[14])}getTranslationToRef(q){return q.x=this.rb[12],q.y=this.rb[13],q.z=this.rb[14],q}removeRotationAndScaling(){const q=this.m;return k.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,q[12],q[13],q[14],q[15],this),this._updateIdentityStatus(0===q[12]&&0===q[13]&&0===q[14]&&1===q[15]),this}v(q){q.copyToArray(this.rb);const S=q;return this.updateFlag=S.updateFlag,this._updateIdentityStatus(S._isIdentity,S._isIdentityDirty,S._isIdentity3x2,S._isIdentity3x2Dirty),this}copyToArray(q){return l(this,q,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(q){const S=new k;return this.multiplyToRef(q,S),S}multiplyInPlace(q){const S=this.rb,b=q.m;for(let z=0;z<16;z++)S[z]*=b[z];return this.markAsUpdated(),this}multiplyByFloats(){const q=this.rb;for(let S=0;S<16;S++)q[S]*=S<0||arguments.length<=S?void 0:arguments[S];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var q=arguments.length,S=new Array(q),b=0;b<q;b++)S[b]=arguments[b];const z=S.pop(),C=this.rb,v=z.rb,U=S;for(let g=0;g<16;g++)v[g]=C[g]*U[g];return z.markAsUpdated(),z}multiplyToRef(q,S){return this._isIdentity?(S.v(q),S):q._isIdentity?(S.v(this),S):(this.multiplyToArray(q,S.rb,0),S.markAsUpdated(),S)}multiplyToArray(q,S,b){return V(this,q,S,b),this}divide(q){return this.divideToRef(q,new k)}divideToRef(q,S){const b=this.rb,z=q.m,C=S.rb;for(let v=0;v<16;v++)C[v]=b[v]/z[v];return S.markAsUpdated(),S}divideInPlace(q){const S=this.rb,b=q.m;for(let z=0;z<16;z++)S[z]/=b[z];return this.markAsUpdated(),this}minimizeInPlace(q){const S=this.rb,b=q.m;for(let z=0;z<16;z++)S[z]=Math.min(S[z],b[z]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const q=this.rb;for(let S=0;S<16;S++)q[S]=Math.min(q[S],S<0||arguments.length<=S?void 0:arguments[S]);return this.markAsUpdated(),this}maximizeInPlace(q){const S=this.rb,b=q.m;for(let z=0;z<16;z++)S[z]=Math.min(S[z],b[z]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const q=this.rb;for(let S=0;S<16;S++)q[S]=Math.min(q[S],S<0||arguments.length<=S?void 0:arguments[S]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new k)}negateInPlace(){const q=this.rb;for(let S=0;S<16;S++)q[S]=-q[S];return this.markAsUpdated(),this}negateToRef(q){const S=this.rb,b=q.rb;for(let z=0;z<16;z++)b[z]=-S[z];return q.markAsUpdated(),q}equals(q){const S=q;if(!S)return!1;if((this._isIdentity||S._isIdentity)&&!this._isIdentityDirty&&!S._isIdentityDirty)return this._isIdentity&&S._isIdentity;const b=this.m,z=S.m;return b[0]===z[0]&&b[1]===z[1]&&b[2]===z[2]&&b[3]===z[3]&&b[4]===z[4]&&b[5]===z[5]&&b[6]===z[6]&&b[7]===z[7]&&b[8]===z[8]&&b[9]===z[9]&&b[10]===z[10]&&b[11]===z[11]&&b[12]===z[12]&&b[13]===z[13]&&b[14]===z[14]&&b[15]===z[15]}equalsWithEpsilon(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=this.rb,z=q.m;for(let C=0;C<16;C++)if(!(0,r.WithinEpsilon)(b[C],z[C],S))return!1;return!0}equalsToFloats(){const q=this.rb;for(let S=0;S<16;S++)if(q[S]!=(S<0||arguments.length<=S?void 0:arguments[S]))return!1;return!0}floor(){return this.floorToRef(new k)}floorToRef(q){const S=this.rb,b=q.rb;for(let z=0;z<16;z++)b[z]=Math.floor(S[z]);return q.markAsUpdated(),q}fract(){return this.fractToRef(new k)}fractToRef(q){const S=this.rb,b=q.rb;for(let z=0;z<16;z++)b[z]=S[z]-Math.floor(S[z]);return q.markAsUpdated(),q}clone(){const q=new k;return q.v(this),q}getClassName(){return"Matrix"}getHashCode(){let q=R(this.rb[0]);for(let S=1;S<16;S++)q=397*q^R(this.rb[S]);return q}decomposeToTransformNode(q){return q.rotationQuaternion=q.rotationQuaternion||new Q,this.decompose(q.tb,q.rotationQuaternion,q.position)}decompose(q,S,b,z){let C=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return b&&b.fb(0),q&&q.fb(1),S&&S.Bb(0,0,0,1),!0;const v=this.rb;if(b&&b.Bb(v[12],v[13],v[14]),(q=q||W.yS[0]).x=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]),q.y=Math.sqrt(v[4]*v[4]+v[5]*v[5]+v[6]*v[6]),q.z=Math.sqrt(v[8]*v[8]+v[9]*v[9]+v[10]*v[10]),z){const S=(C?z.absoluteScaling.x:z.tb.x)<0?-1:1,b=(C?z.absoluteScaling.y:z.tb.y)<0?-1:1,v=(C?z.absoluteScaling.z:z.tb.z)<0?-1:1;q.x*=S,q.y*=b,q.z*=v}else this.determinant()<=0&&(q.y*=-1);if(0===q._x||0===q._y||0===q._z)return S&&S.Bb(0,0,0,1),!1;if(S){const b=1/q._x,z=1/q._y,C=1/q._z;k.FromValuesToRef(v[0]*b,v[1]*b,v[2]*b,0,v[4]*z,v[5]*z,v[6]*z,0,v[8]*C,v[9]*C,v[10]*C,0,0,0,0,1,W.Matrix[0]),Q.FromRotationMatrixToRef(W.Matrix[0],S)}return!0}getRow(q){if(q<0||q>3)return null;const S=4*q;return new H(this.rb[S+0],this.rb[S+1],this.rb[S+2],this.rb[S+3])}getRowToRef(q,S){if(q>=0&&q<=3){const b=4*q;S.x=this.rb[b+0],S.y=this.rb[b+1],S.z=this.rb[b+2],S.w=this.rb[b+3]}return S}setRow(q,S){return this.setRowFromFloats(q,S.x,S.y,S.z,S.w)}transpose(){const q=new k;return k.TransposeToRef(this,q),q}transposeToRef(q){return k.TransposeToRef(this,q),q}setRowFromFloats(q,S,b,z,C){if(q<0||q>3)return this;const v=4*q;return this.rb[v+0]=S,this.rb[v+1]=b,this.rb[v+2]=z,this.rb[v+3]=C,this.markAsUpdated(),this}scale(q){const S=new k;return this.scaleToRef(q,S),S}scaleToRef(q,S){for(let b=0;b<16;b++)S.rb[b]=this.rb[b]*q;return S.markAsUpdated(),S}scaleAndAddToRef(q,S){for(let b=0;b<16;b++)S.rb[b]+=this.rb[b]*q;return S.markAsUpdated(),S}scaleInPlace(q){const S=this.rb;for(let b=0;b<16;b++)S[b]*=q;return this.markAsUpdated(),this}toNormalMatrix(q){const S=W.Matrix[0];this.invertToRef(S),S.transposeToRef(q);const b=q.rb;return k.FromValuesToRef(b[0],b[1],b[2],0,b[4],b[5],b[6],0,b[8],b[9],b[10],0,0,0,0,1,q),q}getRotationMatrix(){const q=new k;return this.getRotationMatrixToRef(q),q}getRotationMatrixToRef(q){const S=W.yS[0];if(!this.decompose(S))return k.IdentityToRef(q),q;const b=this.rb,z=1/S._x,C=1/S._y,v=1/S._z;return k.FromValuesToRef(b[0]*z,b[1]*z,b[2]*z,0,b[4]*C,b[5]*C,b[6]*C,0,b[8]*v,b[9]*v,b[10]*v,0,0,0,0,1,q),q}toggleModelMatrixHandInPlace(){const q=this.rb;return q[2]*=-1,q[6]*=-1,q[8]*=-1,q[9]*=-1,q[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const q=this.rb;return q[8]*=-1,q[9]*=-1,q[10]*=-1,q[11]*=-1,this.markAsUpdated(),this}static Hb(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=new k;return k.FromArrayToRef(q,S,b),b}static FromArrayToRef(q,S,b){for(let z=0;z<16;z++)b.rb[z]=q[z+S];return b.markAsUpdated(),b}static FromFloat32ArrayToRefScaled(q,S,b,z){return z.rb[0]=q[0+S]*b,z.rb[1]=q[1+S]*b,z.rb[2]=q[2+S]*b,z.rb[3]=q[3+S]*b,z.rb[4]=q[4+S]*b,z.rb[5]=q[5+S]*b,z.rb[6]=q[6+S]*b,z.rb[7]=q[7+S]*b,z.rb[8]=q[8+S]*b,z.rb[9]=q[9+S]*b,z.rb[10]=q[10+S]*b,z.rb[11]=q[11+S]*b,z.rb[12]=q[12+S]*b,z.rb[13]=q[13+S]*b,z.rb[14]=q[14+S]*b,z.rb[15]=q[15+S]*b,z.markAsUpdated(),z}static get IdentityReadOnly(){return k._IdentityReadOnly}static FromValuesToRef(q,S,b,z,C,v,U,g,r,I,V,l,y,R,G,Z,H){const Q=H.rb;Q[0]=q,Q[1]=S,Q[2]=b,Q[3]=z,Q[4]=C,Q[5]=v,Q[6]=U,Q[7]=g,Q[8]=r,Q[9]=I,Q[10]=V,Q[11]=l,Q[12]=y,Q[13]=R,Q[14]=G,Q[15]=Z,H.markAsUpdated()}static FromValues(q,S,b,z,C,v,U,g,r,I,V,l,y,R,G,Z){const H=new k,Q=H.rb;return Q[0]=q,Q[1]=S,Q[2]=b,Q[3]=z,Q[4]=C,Q[5]=v,Q[6]=U,Q[7]=g,Q[8]=r,Q[9]=I,Q[10]=V,Q[11]=l,Q[12]=y,Q[13]=R,Q[14]=G,Q[15]=Z,H.markAsUpdated(),H}static Compose(q,S,b){const z=new k;return k.ComposeToRef(q,S,b,z),z}static ComposeToRef(q,S,b,z){const C=z.rb,v=S._x,U=S._y,g=S._z,r=S._w,I=v+v,V=U+U,l=g+g,y=v*I,R=v*V,G=v*l,Z=U*V,H=U*l,Q=g*l,k=r*I,W=r*V,N=r*l,u=q._x,X=q._y,T=q._z;return C[0]=(1-(Z+Q))*u,C[1]=(R+N)*u,C[2]=(G-W)*u,C[3]=0,C[4]=(R-N)*X,C[5]=(1-(y+Q))*X,C[6]=(H+k)*X,C[7]=0,C[8]=(G+W)*T,C[9]=(H-k)*T,C[10]=(1-(y+Z))*T,C[11]=0,C[12]=b._x,C[13]=b._y,C[14]=b._z,C[15]=1,z.markAsUpdated(),z}static Identity(){const q=k.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return q._updateIdentityStatus(!0),q}static IdentityToRef(q){return k.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,q),q._updateIdentityStatus(!0),q}static Zero(){const q=k.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return q._updateIdentityStatus(!1),q}static RotationX(q){const S=new k;return k.RotationXToRef(q,S),S}static Invert(q){const S=new k;return q.invertToRef(S),S}static RotationXToRef(q,S){const b=Math.sin(q),z=Math.cos(q);return k.FromValuesToRef(1,0,0,0,0,z,b,0,0,-b,z,0,0,0,0,1,S),S._updateIdentityStatus(1===z&&0===b),S}static RotationY(q){const S=new k;return k.RotationYToRef(q,S),S}static RotationYToRef(q,S){const b=Math.sin(q),z=Math.cos(q);return k.FromValuesToRef(z,0,-b,0,0,1,0,0,b,0,z,0,0,0,0,1,S),S._updateIdentityStatus(1===z&&0===b),S}static RotationZ(q){const S=new k;return k.RotationZToRef(q,S),S}static RotationZToRef(q,S){const b=Math.sin(q),z=Math.cos(q);return k.FromValuesToRef(z,b,0,0,-b,z,0,0,0,0,1,0,0,0,0,1,S),S._updateIdentityStatus(1===z&&0===b),S}static RotationAxis(q,S){const b=new k;return k.RotationAxisToRef(q,S,b),b}static RotationAxisToRef(q,S,b){const z=Math.sin(-S),C=Math.cos(-S),v=1-C;q=q.normalizeToRef(W.yS[0]);const U=b.rb;return U[0]=q._x*q._x*v+C,U[1]=q._x*q._y*v-q._z*z,U[2]=q._x*q._z*v+q._y*z,U[3]=0,U[4]=q._y*q._x*v+q._z*z,U[5]=q._y*q._y*v+C,U[6]=q._y*q._z*v-q._x*z,U[7]=0,U[8]=q._z*q._x*v-q._y*z,U[9]=q._z*q._y*v+q._x*z,U[10]=q._z*q._z*v+C,U[11]=0,U[12]=0,U[13]=0,U[14]=0,U[15]=1,b.markAsUpdated(),b}static RotationAlignToRef(q,S,b){let C=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const v=Z.Dot(S,q),U=b.rb;if(v<-1+z.d)U[0]=-1,U[1]=0,U[2]=0,U[3]=0,U[4]=0,U[5]=C?1:-1,U[6]=0,U[7]=0,U[8]=0,U[9]=0,U[10]=C?-1:1,U[11]=0;else{const b=Z.Cross(S,q),z=1/(1+v);U[0]=b._x*b._x*z+v,U[1]=b._y*b._x*z-b._z,U[2]=b._z*b._x*z+b._y,U[3]=0,U[4]=b._x*b._y*z+b._z,U[5]=b._y*b._y*z+v,U[6]=b._z*b._y*z-b._x,U[7]=0,U[8]=b._x*b._z*z-b._y,U[9]=b._y*b._z*z+b._x,U[10]=b._z*b._z*z+v,U[11]=0}return U[12]=0,U[13]=0,U[14]=0,U[15]=1,b.markAsUpdated(),b}static RotationYawPitchRoll(q,S,b){const z=new k;return k.RotationYawPitchRollToRef(q,S,b,z),z}static RotationYawPitchRollToRef(q,S,b,z){return Q.RotationYawPitchRollToRef(q,S,b,W.Quaternion[0]),W.Quaternion[0].toRotationMatrix(z),z}static Scaling(q,S,b){const z=new k;return k.ScalingToRef(q,S,b,z),z}static ScalingToRef(q,S,b,z){return k.FromValuesToRef(q,0,0,0,0,S,0,0,0,0,b,0,0,0,0,1,z),z._updateIdentityStatus(1===q&&1===S&&1===b),z}static Translation(q,S,b){const z=new k;return k.TranslationToRef(q,S,b,z),z}static TranslationToRef(q,S,b,z){return k.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,q,S,b,1,z),z._updateIdentityStatus(0===q&&0===S&&0===b),z}static Lerp(q,S,b){const z=new k;return k.LerpToRef(q,S,b,z),z}static LerpToRef(q,S,b,z){const C=z.rb,v=q.m,U=S.m;for(let g=0;g<16;g++)C[g]=v[g]*(1-b)+U[g]*b;return z.markAsUpdated(),z}static DecomposeLerp(q,S,b){const z=new k;return k.DecomposeLerpToRef(q,S,b,z),z}static DecomposeLerpToRef(q,S,b,z){const C=W.yS[0],v=W.Quaternion[0],U=W.yS[1];q.decompose(C,v,U);const g=W.yS[2],r=W.Quaternion[1],I=W.yS[3];S.decompose(g,r,I);const V=W.yS[4];Z.LerpToRef(C,g,b,V);const l=W.Quaternion[2];Q.SlerpToRef(v,r,b,l);const y=W.yS[5];return Z.LerpToRef(U,I,b,y),k.ComposeToRef(V,l,y,z),z}static LookAtLH(q,S,b){const z=new k;return k.LookAtLHToRef(q,S,b,z),z}static LookAtLHToRef(q,S,b,z){const C=W.yS[0],v=W.yS[1],U=W.yS[2];S.subtractToRef(q,U),U.normalize(),Z.CrossToRef(b,U,C);const g=C.lengthSquared();0===g?C.x=1:C.normalizeFromLength(Math.sqrt(g)),Z.CrossToRef(U,C,v),v.normalize();const r=-Z.Dot(C,q),I=-Z.Dot(v,q),V=-Z.Dot(U,q);return k.FromValuesToRef(C._x,v._x,U._x,0,C._y,v._y,U._y,0,C._z,v._z,U._z,0,r,I,V,1,z),z}static LookAtRH(q,S,b){const z=new k;return k.LookAtRHToRef(q,S,b,z),z}static LookAtRHToRef(q,S,b,z){const C=W.yS[0],v=W.yS[1],U=W.yS[2];q.subtractToRef(S,U),U.normalize(),Z.CrossToRef(b,U,C);const g=C.lengthSquared();0===g?C.x=1:C.normalizeFromLength(Math.sqrt(g)),Z.CrossToRef(U,C,v),v.normalize();const r=-Z.Dot(C,q),I=-Z.Dot(v,q),V=-Z.Dot(U,q);return k.FromValuesToRef(C._x,v._x,U._x,0,C._y,v._y,U._y,0,C._z,v._z,U._z,0,r,I,V,1,z),z}static LookDirectionLH(q,S){const b=new k;return k.LookDirectionLHToRef(q,S,b),b}static LookDirectionLHToRef(q,S,b){const z=W.yS[0];z.v(q),z.scaleInPlace(-1);const C=W.yS[1];return Z.CrossToRef(S,z,C),k.FromValuesToRef(C._x,C._y,C._z,0,S._x,S._y,S._z,0,z._x,z._y,z._z,0,0,0,0,1,b),b}static LookDirectionRH(q,S){const b=new k;return k.LookDirectionRHToRef(q,S,b),b}static LookDirectionRHToRef(q,S,b){const z=W.yS[2];return Z.CrossToRef(S,q,z),k.FromValuesToRef(z._x,z._y,z._z,0,S._x,S._y,S._z,0,q._x,q._y,q._z,0,0,0,0,1,b),b}static OrthoLH(q,S,b,z,C){const v=new k;return k.OrthoLHToRef(q,S,b,z,v,C),v}static OrthoLHToRef(q,S,b,z,C,v){const U=2/q,g=2/S,r=2/(z-b),I=-(z+b)/(z-b);return k.FromValuesToRef(U,0,0,0,0,g,0,0,0,0,r,0,0,0,I,1,C),v&&C.multiplyToRef(u,C),C._updateIdentityStatus(1===U&&1===g&&1===r&&0===I),C}static OrthoOffCenterLH(q,S,b,z,C,v,U){const g=new k;return k.OrthoOffCenterLHToRef(q,S,b,z,C,v,g,U),g}static OrthoOffCenterLHToRef(q,S,b,z,C,v,U,g){const r=2/(S-q),I=2/(z-b),V=2/(v-C),l=-(v+C)/(v-C),y=(q+S)/(q-S),R=(z+b)/(b-z);return k.FromValuesToRef(r,0,0,0,0,I,0,0,0,0,V,0,y,R,l,1,U),g&&U.multiplyToRef(u,U),U.markAsUpdated(),U}static ObliqueOffCenterLHToRef(q,S,b,z,C,v,U,g,r,I,V){const l=-U*Math.cos(g),y=-U*Math.sin(g);return k.TranslationToRef(0,0,-r,W.Matrix[1]),k.FromValuesToRef(1,0,0,0,0,1,0,0,l,y,1,0,0,0,0,1,W.Matrix[0]),W.Matrix[1].multiplyToRef(W.Matrix[0],W.Matrix[0]),k.TranslationToRef(0,0,r,W.Matrix[1]),W.Matrix[0].multiplyToRef(W.Matrix[1],W.Matrix[0]),k.OrthoOffCenterLHToRef(q,S,b,z,C,v,I,V),W.Matrix[0].multiplyToRef(I,I),I}static OrthoOffCenterRH(q,S,b,z,C,v,U){const g=new k;return k.OrthoOffCenterRHToRef(q,S,b,z,C,v,g,U),g}static OrthoOffCenterRHToRef(q,S,b,z,C,v,U,g){return k.OrthoOffCenterLHToRef(q,S,b,z,C,v,U,g),U.rb[10]*=-1,U}static ObliqueOffCenterRHToRef(q,S,b,z,C,v,U,g,r,I,V){const l=U*Math.cos(g),y=U*Math.sin(g);return k.TranslationToRef(0,0,r,W.Matrix[1]),k.FromValuesToRef(1,0,0,0,0,1,0,0,l,y,1,0,0,0,0,1,W.Matrix[0]),W.Matrix[1].multiplyToRef(W.Matrix[0],W.Matrix[0]),k.TranslationToRef(0,0,-r,W.Matrix[1]),W.Matrix[0].multiplyToRef(W.Matrix[1],W.Matrix[0]),k.OrthoOffCenterRHToRef(q,S,b,z,C,v,I,V),W.Matrix[0].multiplyToRef(I,I),I}static PerspectiveLH(q,S,b,z,C){let v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const U=new k,g=2*b/q,r=2*b/S,I=(z+b)/(z-b),V=-2*z*b/(z-b),l=Math.tan(v);return k.FromValuesToRef(g,0,0,0,0,r,0,l,0,0,I,1,0,0,V,0,U),C&&U.multiplyToRef(u,U),U._updateIdentityStatus(!1),U}static PerspectiveFovLH(q,S,b,z,C){let v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const g=new k;return k.PerspectiveFovLHToRef(q,S,b,z,g,!0,C,v,U),g}static PerspectiveFovLHToRef(q,S,b,z,C){let v=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,g=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,r=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const I=b,V=z,l=1/Math.tan(.5*q),y=v?l/S:l,R=v?l:l*S,G=r&&0===I?-1:0!==V?(V+I)/(V-I):1,Z=r&&0===I?2*V:0!==V?-2*V*I/(V-I):-2*I,H=Math.tan(g);return k.FromValuesToRef(y,0,0,0,0,R,0,H,0,0,G,1,0,0,Z,0,C),U&&C.multiplyToRef(u,C),C._updateIdentityStatus(!1),C}static PerspectiveFovReverseLHToRef(q,S,b,z,C){let v=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,g=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const r=1/Math.tan(.5*q),I=v?r/S:r,V=v?r:r*S,l=Math.tan(g);return k.FromValuesToRef(I,0,0,0,0,V,0,l,0,0,-b,1,0,0,1,0,C),U&&C.multiplyToRef(u,C),C._updateIdentityStatus(!1),C}static PerspectiveFovRH(q,S,b,z,C){let v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const g=new k;return k.PerspectiveFovRHToRef(q,S,b,z,g,!0,C,v,U),g}static PerspectiveFovRHToRef(q,S,b,z,C){let v=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,g=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,r=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const I=b,V=z,l=1/Math.tan(.5*q),y=v?l/S:l,R=v?l:l*S,G=r&&0===I?1:0!==V?-(V+I)/(V-I):-1,Z=r&&0===I?2*V:0!==V?-2*V*I/(V-I):-2*I,H=Math.tan(g);return k.FromValuesToRef(y,0,0,0,0,R,0,H,0,0,G,-1,0,0,Z,0,C),U&&C.multiplyToRef(u,C),C._updateIdentityStatus(!1),C}static PerspectiveFovReverseRHToRef(q,S,b,z,C){let v=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,g=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const r=1/Math.tan(.5*q),I=v?r/S:r,V=v?r:r*S,l=Math.tan(g);return k.FromValuesToRef(I,0,0,0,0,V,0,l,0,0,-b,-1,0,0,-1,0,C),U&&C.multiplyToRef(u,C),C._updateIdentityStatus(!1),C}static GetFinalMatrix(q,S,b,z,C,v){const U=q.width,g=q.height,r=q.x,I=q.y,V=k.FromValues(U/2,0,0,0,0,-g/2,0,0,0,0,v-C,0,r+U/2,g/2+I,C,1),l=new k;return S.multiplyToRef(b,l),l.multiplyToRef(z,l),l.multiplyToRef(V,l)}static GetAsMatrix2x2(q){const S=q.m,b=[S[0],S[1],S[4],S[5]];return U.c.MatrixUse64Bits?b:new Float32Array(b)}static GetAsMatrix3x3(q){const S=q.m,b=[S[0],S[1],S[2],S[4],S[5],S[6],S[8],S[9],S[10]];return U.c.MatrixUse64Bits?b:new Float32Array(b)}static Transpose(q){const S=new k;return k.TransposeToRef(q,S),S}static TransposeToRef(q,S){const b=q.m,z=b[0],C=b[4],v=b[8],U=b[12],g=b[1],r=b[5],I=b[9],V=b[13],l=b[2],y=b[6],R=b[10],G=b[14],Z=b[3],H=b[7],Q=b[11],k=b[15],W=S.rb;return W[0]=z,W[1]=C,W[2]=v,W[3]=U,W[4]=g,W[5]=r,W[6]=I,W[7]=V,W[8]=l,W[9]=y,W[10]=R,W[11]=G,W[12]=Z,W[13]=H,W[14]=Q,W[15]=k,S.markAsUpdated(),S._updateIdentityStatus(q._isIdentity,q._isIdentityDirty),S}static Reflection(q){const S=new k;return k.ReflectionToRef(q,S),S}static ReflectionToRef(q,S){q.normalize();const b=q.normal.x,z=q.normal.y,C=q.normal.z,v=-2*b,U=-2*z,g=-2*C;return k.FromValuesToRef(v*b+1,U*b,g*b,0,v*z,U*z+1,g*z,0,v*C,U*C,g*C+1,0,v*q.d,U*q.d,g*q.d,1,S),S}static FromXYZAxesToRef(q,S,b,z){return k.FromValuesToRef(q._x,q._y,q._z,0,S._x,S._y,S._z,0,b._x,b._y,b._z,0,0,0,0,1,z),z}static FromQuaternionToRef(q,S){const b=q._x*q._x,z=q._y*q._y,C=q._z*q._z,v=q._x*q._y,U=q._z*q._w,g=q._z*q._x,r=q._y*q._w,I=q._y*q._z,V=q._x*q._w;return S.rb[0]=1-2*(z+C),S.rb[1]=2*(v+U),S.rb[2]=2*(g-r),S.rb[3]=0,S.rb[4]=2*(v-U),S.rb[5]=1-2*(C+b),S.rb[6]=2*(I+V),S.rb[7]=0,S.rb[8]=2*(g+r),S.rb[9]=2*(I-V),S.rb[10]=1-2*(z+b),S.rb[11]=0,S.rb[12]=0,S.rb[13]=0,S.rb[14]=0,S.rb[15]=1,S.markAsUpdated(),S}}k._IdentityReadOnly=k.Identity(),Object.defineProperties(k.prototype,{dimension:{value:[4,4]},rank:{value:2}});class W{}W.yS=(0,C.h)(11,Z.Zero),W.Matrix=(0,C.h)(2,k.Identity),W.Quaternion=(0,C.h)(3,Q.Zero);class N{}N.Vector2=(0,C.h)(3,G.Zero),N.yS=(0,C.h)(13,Z.Zero),N.Vector4=(0,C.h)(3,H.Zero),N.Quaternion=(0,C.h)(3,Q.Zero),N.Matrix=(0,C.h)(8,k.Identity),(0,v.f)("BABYLON.Vector2",G),(0,v.f)("BABYLON.Vector3",Z),(0,v.f)("BABYLON.Vector4",H),(0,v.f)("BABYLON.Matrix",k);const u=k.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11118:(q,S,b)=>{function z(q,S){const b=[];for(let z=0;z<q;++z)b.push(S());return b}function C(q,S){return z(q,S)}b.d(S,{e:()=>z,h:()=>C,l:()=>U});const v=["push","splice","pop","shift","unshift"];function U(q,S){const b=v.map((b=>function(q,S,b){const z=q[S];if("function"!==typeof z)return null;const C=function(){const z=q.length,v=C.previous.apply(q,arguments);return b(S,z),v};return z.next=C,C.previous=z,q[S]=C,()=>{const b=C.previous;if(!b)return;const z=C.next;z?(b.next=z,z.previous=b):(b.next=void 0,q[S]=b),C.next=void 0,C.previous=void 0}}(q,b,S)));return()=>{for(const q of b)null===q||void 0===q||q()}}}}]);