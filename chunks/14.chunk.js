"use strict";(self["7c63p8lin4r"]=self["7c63p8lin4r"]||[]).push([[14],{12917:(z,u,U)=>{U.d(u,{d:()=>g,g:()=>f,i:()=>J,l:()=>v});const J=1/2.2,v=2.2,f=(1+Math.sqrt(5))/2,g=.001},12935:(z,u,U)=>{function J(z){return parseInt(z.toString().replace(/\W/g,""))}function v(z,u){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(z-u)<=U}function f(z,u,U){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return z<u-J||z>U+J}function g(z,u){return z===u?z:Math.random()*(u-z)+z}function w(z,u,U){return z+(u-z)*U}function P(z,u,U){let J=C(u-z,360);return J>180&&(J-=360),z+J*mz(U)}function R(z,u,U){let J=0;return J=z!=u?mz((U-z)/(u-z)):0,J}function S(z,u,U,J,v){const f=v*v,g=v*f;return z*(2*g-3*f+1)+U*(-2*g+3*f)+u*(g-2*f+v)+J*(g-f)}function d(z,u,U,J,v){const f=v*v;return 6*(f-v)*z+(3*f-4*v+1)*u+6*(-f+v)*U+(3*f-2*v)*J}function mz(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(U,Math.max(u,z))}function Z(z){return z-=2*Math.PI*Math.floor((z+Math.PI)/(2*Math.PI))}function A(z){const u=z.toString(16);return z<=15?("0"+u).toUpperCase():u.toUpperCase()}function E(z){if(Math.log2)return Math.floor(Math.log2(z));if(z<0)return NaN;if(0===z)return-1/0;let u=0;if(z<1){for(;z<1;)u++,z*=2;u=-u}else if(z>1)for(;z>1;)u++,z=Math.floor(z/2);return u}function C(z,u){return z-Math.floor(z/u)*u}function r(z,u,U){return(z-u)/(U-u)}function M(z,u,U){return z*(U-u)+u}function T(z,u){let U=C(u-z,360);return U>180&&(U-=360),U}function X(z,u){const U=C(z,2*u);return u-Math.abs(U-u)}function h(z,u,U){let J=mz(U);return J=-2*J*J*J+3*J*J,u*J+z*(1-J)}function t(z,u,U){let J=0;return J=Math.abs(u-z)<=U?u:z+Math.sign(u-z)*U,J}function V(z,u,U){const J=T(z,u);let v=0;return v=-U<J&&J<U?u:t(z,u=z+J,U),v}function L(z,u,U){return(z-u)/(U-u)}function O(z,u,U){return(U-u)*z+u}function x(z,u){const U=z%u;return 0===U?u:x(u,U)}U.r(u),U.d(u,{Clamp:()=>mz,DeltaAngle:()=>T,Denormalize:()=>M,ExtractAsInt:()=>J,Hermite:()=>S,Hermite1stDerivative:()=>d,HighestCommonFactor:()=>x,ILog2:()=>E,InverseLerp:()=>R,Lerp:()=>w,LerpAngle:()=>P,MoveTowards:()=>t,MoveTowardsAngle:()=>V,Normalize:()=>r,NormalizeRadians:()=>Z,OutsideRange:()=>f,PercentToRange:()=>O,PingPong:()=>X,RandomRange:()=>g,RangeToPercent:()=>L,Repeat:()=>C,SmoothStep:()=>h,ToHex:()=>A,WithinEpsilon:()=>v})},12914:(z,u,U)=>{U.r(u),U.d(u,{Matrix:()=>M,Quaternion:()=>r,TmpVectors:()=>X,Vector2:()=>A,Eu:()=>E,Vector4:()=>C});var J=U(12917),v=U(12926),f=U(12875),g=U(12850),w=U(12797),P=U(12935);class R{}function S(z,u,U){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const v=z.jf(),f=u.jf(),g=v[0],w=v[1],P=v[2],R=v[3],S=v[4],d=v[5],mz=v[6],Z=v[7],A=v[8],E=v[9],C=v[10],r=v[11],M=v[12],T=v[13],X=v[14],h=v[15],t=f[0],V=f[1],L=f[2],O=f[3],x=f[4],Q=f[5],K=f[6],Y=f[7],p=f[8],N=f[9],D=f[10],c=f[11],W=f[12],j=f[13],I=f[14],F=f[15];U[J]=g*t+w*x+P*p+R*W,U[J+1]=g*V+w*Q+P*N+R*j,U[J+2]=g*L+w*K+P*D+R*I,U[J+3]=g*O+w*Y+P*c+R*F,U[J+4]=S*t+d*x+mz*p+Z*W,U[J+5]=S*V+d*Q+mz*N+Z*j,U[J+6]=S*L+d*K+mz*D+Z*I,U[J+7]=S*O+d*Y+mz*c+Z*F,U[J+8]=A*t+E*x+C*p+r*W,U[J+9]=A*V+E*Q+C*N+r*j,U[J+10]=A*L+E*K+C*D+r*I,U[J+11]=A*O+E*Y+C*c+r*F,U[J+12]=M*t+T*x+X*p+h*W,U[J+13]=M*V+T*Q+X*N+h*j,U[J+14]=M*L+T*K+X*D+h*I,U[J+15]=M*O+T*Y+X*c+h*F}function d(z,u){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const J=z.jf();u[U]=J[0],u[U+1]=J[1],u[U+2]=J[2],u[U+3]=J[3],u[U+4]=J[4],u[U+5]=J[5],u[U+6]=J[6],u[U+7]=J[7],u[U+8]=J[8],u[U+9]=J[9],u[U+10]=J[10],u[U+11]=J[11],u[U+12]=J[12],u[U+13]=J[13],u[U+14]=J[14],u[U+15]=J[15]}function mz(z,u){const U=z.jf(),J=U[0],v=U[1],f=U[2],g=U[3],w=U[4],P=U[5],R=U[6],S=U[7],d=U[8],mz=U[9],Z=U[10],A=U[11],E=U[12],C=U[13],r=U[14],M=U[15],T=Z*M-r*A,X=mz*M-C*A,h=mz*r-C*Z,t=d*M-E*A,V=d*r-Z*E,L=d*C-E*mz,O=+(P*T-R*X+S*h),x=-(w*T-R*t+S*V),Q=+(w*X-P*t+S*L),K=-(w*h-P*V+R*L),Y=J*O+v*x+f*Q+g*K;if(0===Y)return!1;const p=1/Y,N=R*M-r*S,D=P*M-C*S,c=P*r-C*R,W=w*M-E*S,j=w*r-E*R,I=w*C-E*P,F=R*A-Z*S,b=P*A-mz*S,k=P*Z-mz*R,B=w*A-d*S,y=w*Z-d*R,H=w*mz-d*P,G=-(v*T-f*X+g*h),a=+(J*T-f*t+g*V),i=-(J*X-v*t+g*L),n=+(J*h-v*V+f*L),q=+(v*N-f*D+g*c),o=-(J*N-f*W+g*j),s=+(J*D-v*W+g*I),l=-(J*c-v*j+f*I),e=-(v*F-f*b+g*k),zz=+(J*F-f*B+g*y),uz=-(J*b-v*B+g*H),Uz=+(J*k-v*y+f*H);return u[0]=O*p,u[1]=G*p,u[2]=q*p,u[3]=e*p,u[4]=x*p,u[5]=a*p,u[6]=o*p,u[7]=zz*p,u[8]=Q*p,u[9]=i*p,u[10]=s*p,u[11]=uz*p,u[12]=K*p,u[13]=n*p,u[14]=l*p,u[15]=Uz*p,!0}R._UpdateFlagSeed=0;const Z=z=>parseInt(z.toString().replace(/\W/g,""));class A{constructor(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=z,this.y=u}toString(){return"{X: ".concat(this.x," Y: ").concat(this.y,"}")}getClassName(){return"Vector2"}getHashCode(){let z=Z(this.x);return z=397*z^Z(this.y),z}toArray(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z[u]=this.x,z[u+1]=this.y,this}CU(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return A.FromArrayToRef(z,u,this),this}jf(){return[this.x,this.y]}v(z){return this.x=z.x,this.y=z.y,this}zg(z,u){return this.x=z,this.y=u,this}set(z,u){return this.zg(z,u)}fg(z){return this.zg(z,z)}add(z){return new A(this.x+z.x,this.y+z.y)}addToRef(z,u){return u.x=this.x+z.x,u.y=this.y+z.y,u}addInPlace(z){return this.x+=z.x,this.y+=z.y,this}addInPlaceFromFloats(z,u){return this.x+=z,this.y+=u,this}addVector3(z){return new A(this.x+z.x,this.y+z.y)}Cu(z){return new A(this.x-z.x,this.y-z.y)}subtractToRef(z,u){return u.x=this.x-z.x,u.y=this.y-z.y,u}dm(z){return this.x-=z.x,this.y-=z.y,this}multiplyInPlace(z){return this.x*=z.x,this.y*=z.y,this}multiply(z){return new A(this.x*z.x,this.y*z.y)}multiplyToRef(z,u){return u.x=this.x*z.x,u.y=this.y*z.y,u}multiplyByFloats(z,u){return new A(this.x*z,this.y*u)}divide(z){return new A(this.x/z.x,this.y/z.y)}divideToRef(z,u){return u.x=this.x/z.x,u.y=this.y/z.y,u}divideInPlace(z){return this.x=this.x/z.x,this.y=this.y/z.y,this}minimizeInPlace(z){return this.minimizeInPlaceFromFloats(z.x,z.y)}maximizeInPlace(z){return this.maximizeInPlaceFromFloats(z.x,z.y)}minimizeInPlaceFromFloats(z,u){return this.x=Math.min(z,this.x),this.y=Math.min(u,this.y),this}maximizeInPlaceFromFloats(z,u){return this.x=Math.max(z,this.x),this.y=Math.max(u,this.y),this}subtractFromFloats(z,u){return new A(this.x-z,this.y-u)}subtractFromFloatsToRef(z,u,U){return U.x=this.x-z,U.y=this.y-u,U}negate(){return new A(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(z){return z.x=-this.x,z.y=-this.y,z}scaleInPlace(z){return this.x*=z,this.y*=z,this}scale(z){return new A(this.x*z,this.y*z)}scaleToRef(z,u){return u.x=this.x*z,u.y=this.y*z,u}scaleAndAddToRef(z,u){return u.x+=this.x*z,u.y+=this.y*z,u}equals(z){return z&&this.x===z.x&&this.y===z.y}equalsWithEpsilon(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.d;return z&&(0,P.WithinEpsilon)(this.x,z.x,u)&&(0,P.WithinEpsilon)(this.y,z.y,u)}equalsToFloats(z,u){return this.x===z&&this.y===u}floor(){return new A(Math.floor(this.x),Math.floor(this.y))}floorToRef(z){return z.x=Math.floor(this.x),z.y=Math.floor(this.y),z}fract(){return new A(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(z){return z.x=this.x-Math.floor(this.x),z.y=this.y-Math.floor(this.y),z}rotate(z){return this.rotateToRef(z,new A)}rotateToRef(z,u){const U=Math.cos(z),J=Math.sin(z);return u.x=U*this.x-J*this.y,u.y=J*this.x+U*this.y,u}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(z){return 0===z||1===z?this:this.scaleInPlace(1/z)}normalizeToNew(){const z=new A;return this.normalizeToRef(z),z}normalizeToRef(z){const u=this.length();return 0===u&&(z.x=this.x,z.y=this.y),this.scaleToRef(1/u,z)}clone(){return new A(this.x,this.y)}dot(z){return this.x*z.x+this.y*z.y}static Zero(){return new A(0,0)}static One(){return new A(1,1)}static Random(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new A((0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u))}static RandomToRef(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).zg((0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u))}static get ZeroReadOnly(){return A._ZeroReadOnly}static Xu(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new A(z[u],z[u+1])}static FromArrayToRef(z,u,U){return U.x=z[u],U.y=z[u+1],U}static FromFloatsToRef(z,u,U){return U.zg(z,u),U}static CatmullRom(z,u,U,J,v){const f=v*v,g=v*f,w=.5*(2*u.x+(-z.x+U.x)*v+(2*z.x-5*u.x+4*U.x-J.x)*f+(-z.x+3*u.x-3*U.x+J.x)*g),P=.5*(2*u.y+(-z.y+U.y)*v+(2*z.y-5*u.y+4*U.y-J.y)*f+(-z.y+3*u.y-3*U.y+J.y)*g);return new A(w,P)}static ClampToRef(z,u,U,J){return J.x=(0,P.Clamp)(z.x,u.x,U.x),J.y=(0,P.Clamp)(z.y,u.y,U.y),J}static Clamp(z,u,U){const J=(0,P.Clamp)(z.x,u.x,U.x),v=(0,P.Clamp)(z.y,u.y,U.y);return new A(J,v)}static Hermite(z,u,U,J,v){const f=v*v,g=v*f,w=2*g-3*f+1,P=-2*g+3*f,R=g-2*f+v,S=g-f,d=z.x*w+U.x*P+u.x*R+J.x*S,mz=z.y*w+U.y*P+u.y*R+J.y*S;return new A(d,mz)}static Hermite1stDerivative(z,u,U,J,v){return this.Hermite1stDerivativeToRef(z,u,U,J,v,new A)}static Hermite1stDerivativeToRef(z,u,U,J,v,f){const g=v*v;return f.x=6*(g-v)*z.x+(3*g-4*v+1)*u.x+6*(-g+v)*U.x+(3*g-2*v)*J.x,f.y=6*(g-v)*z.y+(3*g-4*v+1)*u.y+6*(-g+v)*U.y+(3*g-2*v)*J.y,f}static Lerp(z,u,U){return A.LerpToRef(z,u,U,new A)}static LerpToRef(z,u,U,J){return J.x=z.x+(u.x-z.x)*U,J.y=z.y+(u.y-z.y)*U,J}static Dot(z,u){return z.x*u.x+z.y*u.y}static Normalize(z){return A.NormalizeToRef(z,new A)}static NormalizeToRef(z,u){return z.normalizeToRef(u),u}static Minimize(z,u){const U=z.x<u.x?z.x:u.x,J=z.y<u.y?z.y:u.y;return new A(U,J)}static Maximize(z,u){const U=z.x>u.x?z.x:u.x,J=z.y>u.y?z.y:u.y;return new A(U,J)}static Transform(z,u){return A.TransformToRef(z,u,new A)}static TransformToRef(z,u,U){const J=u.m,v=z.x*J[0]+z.y*J[4]+J[12],f=z.x*J[1]+z.y*J[5]+J[13];return U.x=v,U.y=f,U}static PointInTriangle(z,u,U,J){const v=.5*(-U.y*J.x+u.y*(-U.x+J.x)+u.x*(U.y-J.y)+U.x*J.y),f=v<0?-1:1,g=(u.y*J.x-u.x*J.y+(J.y-u.y)*z.x+(u.x-J.x)*z.y)*f,w=(u.x*U.y-u.y*U.x+(u.y-U.y)*z.x+(U.x-u.x)*z.y)*f;return g>0&&w>0&&g+w<2*v*f}static Distance(z,u){return Math.sqrt(A.DistanceSquared(z,u))}static DistanceSquared(z,u){const U=z.x-u.x,J=z.y-u.y;return U*U+J*J}static Center(z,u){return A.CenterToRef(z,u,new A)}static CenterToRef(z,u,U){return U.zg((z.x+u.x)/2,(z.y+u.y)/2)}static DistanceOfPointFromSegment(z,u,U){const J=A.DistanceSquared(u,U);if(0===J)return A.Distance(z,u);const v=U.Cu(u),f=Math.max(0,Math.min(1,A.Dot(z.Cu(u),v)/J)),g=u.add(v.multiplyByFloats(f,f));return A.Distance(z,g)}}A._V8PerformanceHack=new A(.5,.5),A._ZeroReadOnly=A.Zero(),Object.defineProperties(A.prototype,{dimension:{value:[2]},rank:{value:1}});class E{get x(){return this._x}set x(z){this._x=z,this._isDirty=!0}get y(){return this._y}set y(z){this._y=z,this._isDirty=!0}get z(){return this._z}set z(z){this._z=z,this._isDirty=!0}constructor(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=z,this._y=u,this._z=U}toString(){return"{X: ".concat(this._x," Y: ").concat(this._y," Z: ").concat(this._z,"}")}getClassName(){return"Eu"}getHashCode(){let z=Z(this._x);return z=397*z^Z(this._y),z=397*z^Z(this._z),z}jf(){return[this._x,this._y,this._z]}toArray(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z[u]=this._x,z[u+1]=this._y,z[u+2]=this._z,this}CU(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(z,u,this),this}toQuaternion(){return r.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(z){return this._x+=z._x,this._y+=z._y,this._z+=z._z,this._isDirty=!0,this}addInPlaceFromFloats(z,u,U){return this._x+=z,this._y+=u,this._z+=U,this._isDirty=!0,this}add(z){return new E(this._x+z._x,this._y+z._y,this._z+z._z)}addToRef(z,u){return u._x=this._x+z._x,u._y=this._y+z._y,u._z=this._z+z._z,u._isDirty=!0,u}dm(z){return this._x-=z._x,this._y-=z._y,this._z-=z._z,this._isDirty=!0,this}Cu(z){return new E(this._x-z._x,this._y-z._y,this._z-z._z)}subtractToRef(z,u){return this.subtractFromFloatsToRef(z._x,z._y,z._z,u)}subtractFromFloats(z,u,U){return new E(this._x-z,this._y-u,this._z-U)}subtractFromFloatsToRef(z,u,U,J){return J._x=this._x-z,J._y=this._y-u,J._z=this._z-U,J._isDirty=!0,J}negate(){return new E(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(z){return z._x=-1*this._x,z._y=-1*this._y,z._z=-1*this._z,z._isDirty=!0,z}scaleInPlace(z){return this._x*=z,this._y*=z,this._z*=z,this._isDirty=!0,this}scale(z){return new E(this._x*z,this._y*z,this._z*z)}scaleToRef(z,u){return u._x=this._x*z,u._y=this._y*z,u._z=this._z*z,u._isDirty=!0,u}getNormalToRef(z){const u=this.length();let U=Math.acos(this._y/u);const J=Math.atan2(this._z,this._x);U>Math.PI/2?U-=Math.PI/2:U+=Math.PI/2;const v=u*Math.sin(U)*Math.cos(J),f=u*Math.cos(U),g=u*Math.sin(U)*Math.sin(J);return z.set(v,f,g),z}applyRotationQuaternionToRef(z,u){const U=this._x,J=this._y,v=this._z,f=z._x,g=z._y,w=z._z,P=z._w,R=2*(g*v-w*J),S=2*(w*U-f*v),d=2*(f*J-g*U);return u._x=U+P*R+g*d-w*S,u._y=J+P*S+w*R-f*d,u._z=v+P*d+f*S-g*R,u._isDirty=!0,u}applyRotationQuaternionInPlace(z){return this.applyRotationQuaternionToRef(z,this)}applyRotationQuaternion(z){return this.applyRotationQuaternionToRef(z,new E)}scaleAndAddToRef(z,u){return u._x+=this._x*z,u._y+=this._y*z,u._z+=this._z*z,u._isDirty=!0,u}projectOnPlane(z,u){return this.projectOnPlaneToRef(z,u,new E)}projectOnPlaneToRef(z,u,U){const J=z.normal,v=z.d,f=T.Eu[0];this.subtractToRef(u,f),f.normalize();const g=E.Dot(f,J);if(Math.abs(g)<1e-10)U.fg(1/0);else{const z=-(E.Dot(u,J)+v)/g,w=f.scaleInPlace(z);u.addToRef(w,U)}return U}equals(z){return z&&this._x===z._x&&this._y===z._y&&this._z===z._z}equalsWithEpsilon(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.d;return z&&(0,P.WithinEpsilon)(this._x,z._x,u)&&(0,P.WithinEpsilon)(this._y,z._y,u)&&(0,P.WithinEpsilon)(this._z,z._z,u)}equalsToFloats(z,u,U){return this._x===z&&this._y===u&&this._z===U}multiplyInPlace(z){return this._x*=z._x,this._y*=z._y,this._z*=z._z,this._isDirty=!0,this}multiply(z){return this.multiplyByFloats(z._x,z._y,z._z)}multiplyToRef(z,u){return u._x=this._x*z._x,u._y=this._y*z._y,u._z=this._z*z._z,u._isDirty=!0,u}multiplyByFloats(z,u,U){return new E(this._x*z,this._y*u,this._z*U)}divide(z){return new E(this._x/z._x,this._y/z._y,this._z/z._z)}divideToRef(z,u){return u._x=this._x/z._x,u._y=this._y/z._y,u._z=this._z/z._z,u._isDirty=!0,u}divideInPlace(z){return this._x=this._x/z._x,this._y=this._y/z._y,this._z=this._z/z._z,this._isDirty=!0,this}minimizeInPlace(z){return this.minimizeInPlaceFromFloats(z._x,z._y,z._z)}maximizeInPlace(z){return this.maximizeInPlaceFromFloats(z._x,z._y,z._z)}minimizeInPlaceFromFloats(z,u,U){return z<this._x&&(this.x=z),u<this._y&&(this.y=u),U<this._z&&(this.z=U),this}maximizeInPlaceFromFloats(z,u,U){return z>this._x&&(this.x=z),u>this._y&&(this.y=u),U>this._z&&(this.z=U),this}isNonUniformWithinEpsilon(z){const u=Math.abs(this._x),U=Math.abs(this._y);if(!(0,P.WithinEpsilon)(u,U,z))return!0;const J=Math.abs(this._z);return!(0,P.WithinEpsilon)(u,J,z)||!(0,P.WithinEpsilon)(U,J,z)}get isNonUniform(){const z=Math.abs(this._x);if(z!==Math.abs(this._y))return!0;return z!==Math.abs(this._z)}floorToRef(z){return z._x=Math.floor(this._x),z._y=Math.floor(this._y),z._z=Math.floor(this._z),z._isDirty=!0,z}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(z){return z._x=this._x-Math.floor(this._x),z._y=this._y-Math.floor(this._y),z._z=this._z-Math.floor(this._z),z._isDirty=!0,z}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(z){if("xyz"===(z=z.toLowerCase()))return this;const u=T.Eu[0].v(this);return this.x=u[z[0]],this.y=u[z[1]],this.z=u[z[2]],this}rotateByQuaternionToRef(z,u){return z.toRotationMatrix(T.Matrix[0]),E.TransformCoordinatesToRef(this,T.Matrix[0],u),u}rotateByQuaternionAroundPointToRef(z,u,U){return this.subtractToRef(u,T.Eu[0]),T.Eu[0].rotateByQuaternionToRef(z,T.Eu[0]),u.addToRef(T.Eu[0],U),U}cross(z){return E.CrossToRef(this,z,new E)}normalizeFromLength(z){return 0===z||1===z?this:this.scaleInPlace(1/z)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(z){const u=this.length();return 0===u||1===u?(z._x=this._x,z._y=this._y,z._z=this._z,z._isDirty=!0,z):this.scaleToRef(1/u,z)}clone(){return new E(this._x,this._y,this._z)}v(z){return this.zg(z._x,z._y,z._z)}zg(z,u,U){return this._x=z,this._y=u,this._z=U,this._isDirty=!0,this}set(z,u,U){return this.zg(z,u,U)}fg(z){return this._x=this._y=this._z=z,this._isDirty=!0,this}static GetClipFactor(z,u,U,J){const v=E.Dot(z,U);return(v-J)/(v-E.Dot(u,U))}static GetAngleBetweenVectors(z,u,U){const J=z.normalizeToRef(T.Eu[1]),v=u.normalizeToRef(T.Eu[2]);let f=E.Dot(J,v);f=(0,P.Clamp)(f,-1,1);const g=Math.acos(f),w=T.Eu[3];return E.CrossToRef(J,v,w),E.Dot(w,U)>0?isNaN(g)?0:g:isNaN(g)?-Math.PI:-Math.acos(f)}static GetAngleBetweenVectorsOnPlane(z,u,U){T.Eu[0].v(z);const J=T.Eu[0];T.Eu[1].v(u);const v=T.Eu[1];T.Eu[2].v(U);const f=T.Eu[2],g=T.Eu[3],w=T.Eu[4];J.normalize(),v.normalize(),f.normalize(),E.CrossToRef(f,J,g),E.CrossToRef(g,f,w);const R=Math.atan2(E.Dot(v,g),E.Dot(v,w));return(0,P.NormalizeRadians)(R)}static PitchYawRollToMoveBetweenPointsToRef(z,u,U){const J=X.Eu[0];return u.subtractToRef(z,J),U._y=Math.atan2(J.x,J.z)||0,U._x=Math.atan2(Math.sqrt(J.x**2+J.z**2),J.y)||0,U._z=0,U._isDirty=!0,U}static PitchYawRollToMoveBetweenPoints(z,u){const U=E.Zero();return E.PitchYawRollToMoveBetweenPointsToRef(z,u,U)}static SlerpToRef(z,u,U,v){U=(0,P.Clamp)(U,0,1);const f=T.Eu[0],g=T.Eu[1];f.v(z);const w=f.length();f.normalizeFromLength(w),g.v(u);const R=g.length();g.normalizeFromLength(R);const S=E.Dot(f,g);let d,mz;if(S<1-J.d){const z=Math.acos(S),u=1/Math.sin(z);d=Math.sin((1-U)*z)*u,mz=Math.sin(U*z)*u}else d=1-U,mz=U;return f.scaleInPlace(d),g.scaleInPlace(mz),v.v(f).addInPlace(g),v.scaleInPlace((0,P.Lerp)(w,R,U)),v}static SmoothToRef(z,u,U,J,v){return E.SlerpToRef(z,u,0===J?1:U/J,v),v}static Xu(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(z[u],z[u+1],z[u+2])}static FromFloatArray(z,u){return E.Xu(z,u)}static FromArrayToRef(z,u,U){return U._x=z[u],U._y=z[u+1],U._z=z[u+2],U._isDirty=!0,U}static FromFloatArrayToRef(z,u,U){return E.FromArrayToRef(z,u,U)}static FromFloatsToRef(z,u,U,J){return J.zg(z,u,U),J}static Zero(){return new E(0,0,0)}static One(){return new E(1,1,1)}static Up(){return new E(0,1,0)}static get UpReadOnly(){return E._UpReadOnly}static get DownReadOnly(){return E._DownReadOnly}static get RightReadOnly(){return E._RightReadOnly}static get LeftReadOnly(){return E._LeftReadOnly}static get LeftHandedForwardReadOnly(){return E._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return E._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return E._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return E._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return E._ZeroReadOnly}static get OneReadOnly(){return E._OneReadOnly}static Down(){return new E(0,-1,0)}static Forward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new E(1,0,0)}static Left(){return new E(-1,0,0)}static Random(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u))}static RandomToRef(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).zg((0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u))}static TransformCoordinates(z,u){const U=E.Zero();return E.TransformCoordinatesToRef(z,u,U),U}static TransformCoordinatesToRef(z,u,U){return E.TransformCoordinatesFromFloatsToRef(z._x,z._y,z._z,u,U),U}static TransformCoordinatesFromFloatsToRef(z,u,U,J,v){const f=J.m,g=z*f[0]+u*f[4]+U*f[8]+f[12],w=z*f[1]+u*f[5]+U*f[9]+f[13],P=z*f[2]+u*f[6]+U*f[10]+f[14],R=1/(z*f[3]+u*f[7]+U*f[11]+f[15]);return v._x=g*R,v._y=w*R,v._z=P*R,v._isDirty=!0,v}static TransformNormal(z,u){const U=E.Zero();return E.TransformNormalToRef(z,u,U),U}static TransformNormalToRef(z,u,U){return this.TransformNormalFromFloatsToRef(z._x,z._y,z._z,u,U),U}static TransformNormalFromFloatsToRef(z,u,U,J,v){const f=J.m;return v._x=z*f[0]+u*f[4]+U*f[8],v._y=z*f[1]+u*f[5]+U*f[9],v._z=z*f[2]+u*f[6]+U*f[10],v._isDirty=!0,v}static CatmullRom(z,u,U,J,v){const f=v*v,g=v*f,w=.5*(2*u._x+(-z._x+U._x)*v+(2*z._x-5*u._x+4*U._x-J._x)*f+(-z._x+3*u._x-3*U._x+J._x)*g),P=.5*(2*u._y+(-z._y+U._y)*v+(2*z._y-5*u._y+4*U._y-J._y)*f+(-z._y+3*u._y-3*U._y+J._y)*g),R=.5*(2*u._z+(-z._z+U._z)*v+(2*z._z-5*u._z+4*U._z-J._z)*f+(-z._z+3*u._z-3*U._z+J._z)*g);return new E(w,P,R)}static Clamp(z,u,U){const J=new E;return E.ClampToRef(z,u,U,J),J}static ClampToRef(z,u,U,J){let v=z._x;v=v>U._x?U._x:v,v=v<u._x?u._x:v;let f=z._y;f=f>U._y?U._y:f,f=f<u._y?u._y:f;let g=z._z;return g=g>U._z?U._z:g,g=g<u._z?u._z:g,J.zg(v,f,g),J}static CheckExtends(z,u,U){u.minimizeInPlace(z),U.maximizeInPlace(z)}static Hermite(z,u,U,J,v){const f=v*v,g=v*f,w=2*g-3*f+1,P=-2*g+3*f,R=g-2*f+v,S=g-f,d=z._x*w+U._x*P+u._x*R+J._x*S,mz=z._y*w+U._y*P+u._y*R+J._y*S,Z=z._z*w+U._z*P+u._z*R+J._z*S;return new E(d,mz,Z)}static Hermite1stDerivative(z,u,U,J,v){const f=new E;return this.Hermite1stDerivativeToRef(z,u,U,J,v,f),f}static Hermite1stDerivativeToRef(z,u,U,J,v,f){const g=v*v;return f._x=6*(g-v)*z._x+(3*g-4*v+1)*u._x+6*(-g+v)*U._x+(3*g-2*v)*J._x,f._y=6*(g-v)*z._y+(3*g-4*v+1)*u._y+6*(-g+v)*U._y+(3*g-2*v)*J._y,f._z=6*(g-v)*z._z+(3*g-4*v+1)*u._z+6*(-g+v)*U._z+(3*g-2*v)*J._z,f._isDirty=!0,f}static Lerp(z,u,U){const J=new E(0,0,0);return E.LerpToRef(z,u,U,J),J}static LerpToRef(z,u,U,J){return J._x=z._x+(u._x-z._x)*U,J._y=z._y+(u._y-z._y)*U,J._z=z._z+(u._z-z._z)*U,J._isDirty=!0,J}static Dot(z,u){return z._x*u._x+z._y*u._y+z._z*u._z}dot(z){return this._x*z._x+this._y*z._y+this._z*z._z}static Cross(z,u){const U=new E;return E.CrossToRef(z,u,U),U}static CrossToRef(z,u,U){const J=z._y*u._z-z._z*u._y,v=z._z*u._x-z._x*u._z,f=z._x*u._y-z._y*u._x;return U.zg(J,v,f),U}static Normalize(z){const u=E.Zero();return E.NormalizeToRef(z,u),u}static NormalizeToRef(z,u){return z.normalizeToRef(u),u}static Project(z,u,U,J){const v=new E;return E.ProjectToRef(z,u,U,J,v),v}static ProjectToRef(z,u,U,J,v){var f;const g=J.width,P=J.height,R=J.x,S=J.y,d=T.Matrix[1],mz=null===(f=w.e.LastCreatedEngine)||void 0===f?void 0:f.isNDCHalfZRange,Z=mz?1:.5,A=mz?0:.5;M.FromValuesToRef(g/2,0,0,0,0,-P/2,0,0,0,0,Z,0,R+g/2,P/2+S,A,1,d);const C=T.Matrix[0];return u.multiplyToRef(U,C),C.multiplyToRef(d,C),E.TransformCoordinatesToRef(z,C,v),v}static Reflect(z,u){return this.ReflectToRef(z,u,new E)}static ReflectToRef(z,u,U){const J=X.Eu[0];return J.v(u).scaleInPlace(2*E.Dot(z,u)),U.v(z).dm(J)}static _UnprojectFromInvertedMatrixToRef(z,u,U){E.TransformCoordinatesToRef(z,u,U);const J=u.m,v=z._x*J[3]+z._y*J[7]+z._z*J[11]+J[15];return(0,P.WithinEpsilon)(v,1)&&U.scaleInPlace(1/v),U}static UnprojectFromTransform(z,u,U,J,v){return this.Unproject(z,u,U,J,v,M.IdentityReadOnly)}static Unproject(z,u,U,J,v,f){const g=new E;return E.UnprojectToRef(z,u,U,J,v,f,g),g}static UnprojectToRef(z,u,U,J,v,f,g){return E.UnprojectFloatsToRef(z._x,z._y,z._z,u,U,J,v,f,g),g}static UnprojectFloatsToRef(z,u,U,J,v,f,g,P,R){var S;const d=T.Matrix[0];f.multiplyToRef(g,d),d.multiplyToRef(P,d),d.invert();const mz=T.Eu[0];return mz.x=z/J*2-1,mz.y=-(u/v*2-1),null!==(S=w.e.LastCreatedEngine)&&void 0!==S&&S.isNDCHalfZRange?mz.z=U:mz.z=2*U-1,E._UnprojectFromInvertedMatrixToRef(mz,d,R),R}static Minimize(z,u){const U=new E;return U.v(z),U.minimizeInPlace(u),U}static Maximize(z,u){const U=new E;return U.v(z),U.maximizeInPlace(u),U}static Distance(z,u){return Math.sqrt(E.DistanceSquared(z,u))}static DistanceSquared(z,u){const U=z._x-u._x,J=z._y-u._y,v=z._z-u._z;return U*U+J*J+v*v}static ProjectOnTriangleToRef(z,u,U,v,f){const g=T.Eu[0],w=T.Eu[1],R=T.Eu[2],S=T.Eu[3],d=T.Eu[4];U.subtractToRef(u,g),v.subtractToRef(u,w),v.subtractToRef(U,R);const mz=g.length(),Z=w.length(),A=R.length();if(mz<J.d||Z<J.d||A<J.d)return f.v(u),E.Distance(z,u);z.subtractToRef(u,d),E.CrossToRef(g,w,S);const C=S.length();if(C<J.d)return f.v(u),E.Distance(z,u);S.normalizeFromLength(C);let r=d.length();if(r<J.d)return f.v(u),0;d.normalizeFromLength(r);const M=E.Dot(S,d),X=T.Eu[5],h=T.Eu[6];X.v(S).scaleInPlace(-r*M),h.v(z).addInPlace(X);const t=T.Eu[4],V=T.Eu[5],L=T.Eu[7],O=T.Eu[8];t.v(g).scaleInPlace(1/mz),O.v(w).scaleInPlace(1/Z),t.addInPlace(O).scaleInPlace(-1),V.v(g).scaleInPlace(-1/mz),O.v(R).scaleInPlace(1/A),V.addInPlace(O).scaleInPlace(-1),L.v(R).scaleInPlace(-1/A),O.v(w).scaleInPlace(-1/Z),L.addInPlace(O).scaleInPlace(-1);const x=T.Eu[9];let Q;x.v(h).dm(u),E.CrossToRef(t,x,O),Q=E.Dot(O,S);const K=Q;x.v(h).dm(U),E.CrossToRef(V,x,O),Q=E.Dot(O,S);const Y=Q;x.v(h).dm(v),E.CrossToRef(L,x,O),Q=E.Dot(O,S);const p=Q,N=T.Eu[10];let D,c;K>0&&Y<0?(N.v(g),D=u,c=U):Y>0&&p<0?(N.v(R),D=U,c=v):(N.v(w).scaleInPlace(-1),D=v,c=u);const W=T.Eu[9],j=T.Eu[4];D.subtractToRef(h,O),c.subtractToRef(h,W),E.CrossToRef(O,W,j);if(!(E.Dot(j,S)<0))return f.v(h),Math.abs(r*M);const I=T.Eu[5];E.CrossToRef(N,j,I),I.normalize();const F=T.Eu[9];F.v(D).dm(h);const b=F.length();if(b<J.d)return f.v(D),E.Distance(z,D);F.normalizeFromLength(b);const k=E.Dot(I,F),B=T.Eu[7];B.v(h).addInPlace(I.scaleInPlace(b*k)),O.v(B).dm(D),r=N.length(),N.normalizeFromLength(r);let y=E.Dot(O,N)/Math.max(r,J.d);return y=(0,P.Clamp)(y,0,1),B.v(D).addInPlace(N.scaleInPlace(y*r)),f.v(B),E.Distance(z,B)}static Center(z,u){return E.CenterToRef(z,u,E.Zero())}static CenterToRef(z,u,U){return U.zg((z._x+u._x)/2,(z._y+u._y)/2,(z._z+u._z)/2)}static RotationFromAxis(z,u,U){const J=new E;return E.RotationFromAxisToRef(z,u,U,J),J}static RotationFromAxisToRef(z,u,U,J){const v=T.Quaternion[0];return r.RotationQuaternionFromAxisToRef(z,u,U,v),v.toEulerAnglesToRef(J),J}}E._V8PerformanceHack=new E(.5,.5,.5),E._UpReadOnly=E.Up(),E._DownReadOnly=E.Down(),E._LeftHandedForwardReadOnly=E.Forward(!1),E._RightHandedForwardReadOnly=E.Forward(!0),E._LeftHandedBackwardReadOnly=E.Backward(!1),E._RightHandedBackwardReadOnly=E.Backward(!0),E._RightReadOnly=E.Right(),E._LeftReadOnly=E.Left(),E._ZeroReadOnly=E.Zero(),E._OneReadOnly=E.One(),Object.defineProperties(E.prototype,{dimension:{value:[3]},rank:{value:1}});class C{get x(){return this._x}set x(z){this._x=z,this._isDirty=!0}get y(){return this._y}set y(z){this._y=z,this._isDirty=!0}get z(){return this._z}set z(z){this._z=z,this._isDirty=!0}get w(){return this._w}set w(z){this._w=z,this._isDirty=!0}constructor(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=z,this._y=u,this._z=U,this._w=J}toString(){return"{X: ".concat(this._x," Y: ").concat(this._y," Z: ").concat(this._z," W: ").concat(this._w,"}")}getClassName(){return"Vector4"}getHashCode(){let z=Z(this._x);return z=397*z^Z(this._y),z=397*z^Z(this._z),z=397*z^Z(this._w),z}jf(){return[this._x,this._y,this._z,this._w]}toArray(z,u){return void 0===u&&(u=0),z[u]=this._x,z[u+1]=this._y,z[u+2]=this._z,z[u+3]=this._w,this}CU(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C.FromArrayToRef(z,u,this),this}addInPlace(z){return this.x+=z._x,this.y+=z._y,this.z+=z._z,this.w+=z._w,this}addInPlaceFromFloats(z,u,U,J){return this.x+=z,this.y+=u,this.z+=U,this.w+=J,this}add(z){return new C(this._x+z.x,this._y+z.y,this._z+z.z,this._w+z.w)}addToRef(z,u){return u.x=this._x+z.x,u.y=this._y+z.y,u.z=this._z+z.z,u.w=this._w+z.w,u}dm(z){return this.x-=z.x,this.y-=z.y,this.z-=z.z,this.w-=z.w,this}Cu(z){return new C(this._x-z.x,this._y-z.y,this._z-z.z,this._w-z.w)}subtractToRef(z,u){return u.x=this._x-z.x,u.y=this._y-z.y,u.z=this._z-z.z,u.w=this._w-z.w,u}subtractFromFloats(z,u,U,J){return new C(this._x-z,this._y-u,this._z-U,this._w-J)}subtractFromFloatsToRef(z,u,U,J,v){return v.x=this._x-z,v.y=this._y-u,v.z=this._z-U,v.w=this._w-J,v}negate(){return new C(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(z){return z.x=-this._x,z.y=-this._y,z.z=-this._z,z.w=-this._w,z}scaleInPlace(z){return this.x*=z,this.y*=z,this.z*=z,this.w*=z,this}scale(z){return new C(this._x*z,this._y*z,this._z*z,this._w*z)}scaleToRef(z,u){return u.x=this._x*z,u.y=this._y*z,u.z=this._z*z,u.w=this._w*z,u}scaleAndAddToRef(z,u){return u.x+=this._x*z,u.y+=this._y*z,u.z+=this._z*z,u.w+=this._w*z,u}equals(z){return z&&this._x===z.x&&this._y===z.y&&this._z===z.z&&this._w===z.w}equalsWithEpsilon(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.d;return z&&(0,P.WithinEpsilon)(this._x,z.x,u)&&(0,P.WithinEpsilon)(this._y,z.y,u)&&(0,P.WithinEpsilon)(this._z,z.z,u)&&(0,P.WithinEpsilon)(this._w,z.w,u)}equalsToFloats(z,u,U,J){return this._x===z&&this._y===u&&this._z===U&&this._w===J}multiplyInPlace(z){return this.x*=z.x,this.y*=z.y,this.z*=z.z,this.w*=z.w,this}multiply(z){return new C(this._x*z.x,this._y*z.y,this._z*z.z,this._w*z.w)}multiplyToRef(z,u){return u.x=this._x*z.x,u.y=this._y*z.y,u.z=this._z*z.z,u.w=this._w*z.w,u}multiplyByFloats(z,u,U,J){return new C(this._x*z,this._y*u,this._z*U,this._w*J)}divide(z){return new C(this._x/z.x,this._y/z.y,this._z/z.z,this._w/z.w)}divideToRef(z,u){return u.x=this._x/z.x,u.y=this._y/z.y,u.z=this._z/z.z,u.w=this._w/z.w,u}divideInPlace(z){return this.divideToRef(z,this)}minimizeInPlace(z){return z.x<this._x&&(this.x=z.x),z.y<this._y&&(this.y=z.y),z.z<this._z&&(this.z=z.z),z.w<this._w&&(this.w=z.w),this}maximizeInPlace(z){return z.x>this._x&&(this.x=z.x),z.y>this._y&&(this.y=z.y),z.z>this._z&&(this.z=z.z),z.w>this._w&&(this.w=z.w),this}minimizeInPlaceFromFloats(z,u,U,J){return this.x=Math.min(z,this._x),this.y=Math.min(u,this._y),this.z=Math.min(U,this._z),this.w=Math.min(J,this._w),this}maximizeInPlaceFromFloats(z,u,U,J){return this.x=Math.max(z,this._x),this.y=Math.max(u,this._y),this.z=Math.max(U,this._z),this.w=Math.max(J,this._w),this}floorToRef(z){return z.x=Math.floor(this._x),z.y=Math.floor(this._y),z.z=Math.floor(this._z),z.w=Math.floor(this._w),z}floor(){return new C(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(z){return z.x=this._x-Math.floor(this._x),z.y=this._y-Math.floor(this._y),z.z=this._z-Math.floor(this._z),z.w=this._w-Math.floor(this._w),z}fract(){return new C(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(z){return 0===z||1===z?this:this.scaleInPlace(1/z)}normalizeToNew(){return this.normalizeToRef(new C)}normalizeToRef(z){const u=this.length();return 0===u||1===u?(z.x=this._x,z.y=this._y,z.z=this._z,z.w=this._w,z):this.scaleToRef(1/u,z)}toVector3(){return new E(this._x,this._y,this._z)}clone(){return new C(this._x,this._y,this._z,this._w)}v(z){return this.x=z.x,this.y=z.y,this.z=z.z,this.w=z.w,this}zg(z,u,U,J){return this.x=z,this.y=u,this.z=U,this.w=J,this}set(z,u,U,J){return this.zg(z,u,U,J)}fg(z){return this.x=this.y=this.z=this.w=z,this}dot(z){return this._x*z.x+this._y*z.y+this._z*z.z+this._w*z.w}static Xu(z,u){return u||(u=0),new C(z[u],z[u+1],z[u+2],z[u+3])}static FromArrayToRef(z,u,U){return U.x=z[u],U.y=z[u+1],U.z=z[u+2],U.w=z[u+3],U}static FromFloatArrayToRef(z,u,U){return C.FromArrayToRef(z,u,U),U}static FromFloatsToRef(z,u,U,J,v){return v.x=z,v.y=u,v.z=U,v.w=J,v}static Zero(){return new C(0,0,0,0)}static One(){return new C(1,1,1,1)}static Random(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new C((0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u))}static RandomToRef(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,U=arguments.length>2?arguments[2]:void 0;return U.x=(0,P.RandomRange)(z,u),U.y=(0,P.RandomRange)(z,u),U.z=(0,P.RandomRange)(z,u),U.w=(0,P.RandomRange)(z,u),U}static Clamp(z,u,U){return C.ClampToRef(z,u,U,new C)}static ClampToRef(z,u,U,J){return J.x=(0,P.Clamp)(z.x,u.x,U.x),J.y=(0,P.Clamp)(z.y,u.y,U.y),J.z=(0,P.Clamp)(z.z,u.z,U.z),J.w=(0,P.Clamp)(z.w,u.w,U.w),J}static CheckExtends(z,u,U){u.minimizeInPlace(z),U.maximizeInPlace(z)}static get ZeroReadOnly(){return C._ZeroReadOnly}static Normalize(z){return C.NormalizeToRef(z,new C)}static NormalizeToRef(z,u){return z.normalizeToRef(u),u}static Minimize(z,u){const U=new C;return U.v(z),U.minimizeInPlace(u),U}static Maximize(z,u){const U=new C;return U.v(z),U.maximizeInPlace(u),U}static Distance(z,u){return Math.sqrt(C.DistanceSquared(z,u))}static DistanceSquared(z,u){const U=z.x-u.x,J=z.y-u.y,v=z.z-u.z,f=z.w-u.w;return U*U+J*J+v*v+f*f}static Center(z,u){return C.CenterToRef(z,u,new C)}static CenterToRef(z,u,U){return U.x=(z.x+u.x)/2,U.y=(z.y+u.y)/2,U.z=(z.z+u.z)/2,U.w=(z.w+u.w)/2,U}static TransformCoordinates(z,u){return C.TransformCoordinatesToRef(z,u,new C)}static TransformCoordinatesToRef(z,u,U){return C.TransformCoordinatesFromFloatsToRef(z._x,z._y,z._z,u,U),U}static TransformCoordinatesFromFloatsToRef(z,u,U,J,v){const f=J.m,g=z*f[0]+u*f[4]+U*f[8]+f[12],w=z*f[1]+u*f[5]+U*f[9]+f[13],P=z*f[2]+u*f[6]+U*f[10]+f[14],R=z*f[3]+u*f[7]+U*f[11]+f[15];return v.x=g,v.y=w,v.z=P,v.w=R,v}static TransformNormal(z,u){return C.TransformNormalToRef(z,u,new C)}static TransformNormalToRef(z,u,U){const J=u.m,v=z.x*J[0]+z.y*J[4]+z.z*J[8],f=z.x*J[1]+z.y*J[5]+z.z*J[9],g=z.x*J[2]+z.y*J[6]+z.z*J[10];return U.x=v,U.y=f,U.z=g,U.w=z.w,U}static TransformNormalFromFloatsToRef(z,u,U,J,v,f){const g=v.m;return f.x=z*g[0]+u*g[4]+U*g[8],f.y=z*g[1]+u*g[5]+U*g[9],f.z=z*g[2]+u*g[6]+U*g[10],f.w=J,f}static FromVector3(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new C(z._x,z._y,z._z,u)}static Dot(z,u){return z.x*u.x+z.y*u.y+z.z*u.z+z.w*u.w}}C._V8PerformanceHack=new C(.5,.5,.5,.5),C._ZeroReadOnly=C.Zero(),Object.defineProperties(C.prototype,{dimension:{value:[4]},rank:{value:1}});class r{get x(){return this._x}set x(z){this._x=z,this._isDirty=!0}get y(){return this._y}set y(z){this._y=z,this._isDirty=!0}get z(){return this._z}set z(z){this._z=z,this._isDirty=!0}get w(){return this._w}set w(z){this._w=z,this._isDirty=!0}constructor(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=z,this._y=u,this._z=U,this._w=J}toString(){return"{X: ".concat(this._x," Y: ").concat(this._y," Z: ").concat(this._z," W: ").concat(this._w,"}")}getClassName(){return"Quaternion"}getHashCode(){let z=Z(this._x);return z=397*z^Z(this._y),z=397*z^Z(this._z),z=397*z^Z(this._w),z}jf(){return[this._x,this._y,this._z,this._w]}toArray(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z[u]=this._x,z[u+1]=this._y,z[u+2]=this._z,z[u+3]=this._w,this}CU(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r.FromArrayToRef(z,u,this)}equals(z){return z&&this._x===z._x&&this._y===z._y&&this._z===z._z&&this._w===z._w}equalsWithEpsilon(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.d;return z&&(0,P.WithinEpsilon)(this._x,z._x,u)&&(0,P.WithinEpsilon)(this._y,z._y,u)&&(0,P.WithinEpsilon)(this._z,z._z,u)&&(0,P.WithinEpsilon)(this._w,z._w,u)}isApprox(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.d;return z&&((0,P.WithinEpsilon)(this._x,z._x,u)&&(0,P.WithinEpsilon)(this._y,z._y,u)&&(0,P.WithinEpsilon)(this._z,z._z,u)&&(0,P.WithinEpsilon)(this._w,z._w,u)||(0,P.WithinEpsilon)(this._x,-z._x,u)&&(0,P.WithinEpsilon)(this._y,-z._y,u)&&(0,P.WithinEpsilon)(this._z,-z._z,u)&&(0,P.WithinEpsilon)(this._w,-z._w,u))}clone(){return new r(this._x,this._y,this._z,this._w)}v(z){return this._x=z._x,this._y=z._y,this._z=z._z,this._w=z._w,this._isDirty=!0,this}zg(z,u,U,J){return this._x=z,this._y=u,this._z=U,this._w=J,this._isDirty=!0,this}set(z,u,U,J){return this.zg(z,u,U,J)}fg(z){return this.zg(z,z,z,z)}add(z){return new r(this._x+z._x,this._y+z._y,this._z+z._z,this._w+z._w)}addInPlace(z){return this._x+=z._x,this._y+=z._y,this._z+=z._z,this._w+=z._w,this._isDirty=!0,this}addToRef(z,u){return u._x=this._x+z._x,u._y=this._y+z._y,u._z=this._z+z._z,u._w=this._w+z._w,u._isDirty=!0,u}addInPlaceFromFloats(z,u,U,J){return this._x+=z,this._y+=u,this._z+=U,this._w+=J,this._isDirty=!0,this}subtractToRef(z,u){return u._x=this._x-z._x,u._y=this._y-z._y,u._z=this._z-z._z,u._w=this._w-z._w,u._isDirty=!0,u}subtractFromFloats(z,u,U,J){return this.subtractFromFloatsToRef(z,u,U,J,new r)}subtractFromFloatsToRef(z,u,U,J,v){return v._x=this._x-z,v._y=this._y-u,v._z=this._z-U,v._w=this._w-J,v._isDirty=!0,v}Cu(z){return new r(this._x-z._x,this._y-z._y,this._z-z._z,this._w-z._w)}dm(z){return this._x-=z._x,this._y-=z._y,this._z-=z._z,this._w-=z._w,this._isDirty=!0,this}scale(z){return new r(this._x*z,this._y*z,this._z*z,this._w*z)}scaleToRef(z,u){return u._x=this._x*z,u._y=this._y*z,u._z=this._z*z,u._w=this._w*z,u._isDirty=!0,u}scaleInPlace(z){return this._x*=z,this._y*=z,this._z*=z,this._w*=z,this._isDirty=!0,this}scaleAndAddToRef(z,u){return u._x+=this._x*z,u._y+=this._y*z,u._z+=this._z*z,u._w+=this._w*z,u._isDirty=!0,u}multiply(z){const u=new r(0,0,0,1);return this.multiplyToRef(z,u),u}multiplyToRef(z,u){const U=this._x*z._w+this._y*z._z-this._z*z._y+this._w*z._x,J=-this._x*z._z+this._y*z._w+this._z*z._x+this._w*z._y,v=this._x*z._y-this._y*z._x+this._z*z._w+this._w*z._z,f=-this._x*z._x-this._y*z._y-this._z*z._z+this._w*z._w;return u.zg(U,J,v,f),u}multiplyInPlace(z){return this.multiplyToRef(z,this)}multiplyByFloats(z,u,U,J){return this._x*=z,this._y*=u,this._z*=U,this._w*=J,this._isDirty=!0,this}divide(z){throw new ReferenceError("Can not divide a quaternion")}divideToRef(z,u){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(z){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new r)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(z){return z._x=-this._x,z._y=-this._y,z._z=-this._z,z._w=-this._w,z._isDirty=!0,z}equalsToFloats(z,u,U,J){return this._x===z&&this._y===u&&this._z===U&&this._w===J}floorToRef(z){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(z){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(z){return z.zg(-this._x,-this._y,-this._z,this._w),z}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new r(-this._x,-this._y,-this._z,this._w)}invert(){const z=this.conjugate(),u=this.lengthSquared();return 0==u||1==u||z.scaleInPlace(1/u),z}invertInPlace(){this.conjugateInPlace();const z=this.lengthSquared();return 0==z||1==z||this.scaleInPlace(1/z),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(z){return 0===z||1===z?this:this.scaleInPlace(1/z)}normalizeToNew(){const z=new r(0,0,0,1);return this.normalizeToRef(z),z}normalizeToRef(z){const u=this.length();return 0===u||1===u?z.zg(this._x,this._y,this._z,this._w):this.scaleToRef(1/u,z)}toEulerAngles(){const z=E.Zero();return this.toEulerAnglesToRef(z),z}toEulerAnglesToRef(z){const u=this._z,U=this._x,J=this._y,v=this._w,f=J*u-U*v,g=.4999999;if(f<-g)z._y=2*Math.atan2(J,v),z._x=Math.PI/2,z._z=0,z._isDirty=!0;else if(f>g)z._y=2*Math.atan2(J,v),z._x=-Math.PI/2,z._z=0,z._isDirty=!0;else{const g=v*v,w=u*u,P=U*U,R=J*J;z._z=Math.atan2(2*(U*J+u*v),-w-P+R+g),z._x=Math.asin(-2*f),z._y=Math.atan2(2*(u*U+J*v),w-P-R+g),z._isDirty=!0}return z}toAlphaBetaGammaToRef(z){const u=this._z,U=this._x,J=this._y,v=this._w,f=Math.sqrt(U*U+J*J),g=Math.sqrt(u*u+v*v),w=2*Math.atan2(f,g),P=2*Math.atan2(u,v),R=2*Math.atan2(J,U),S=(P+R)/2,d=(P-R)/2;return z.set(d,w,S),z}toRotationMatrix(z){return M.FromQuaternionToRef(this,z),z}fromRotationMatrix(z){return r.FromRotationMatrixToRef(z,this),this}dot(z){return this._x*z._x+this._y*z._y+this._z*z._z+this._w*z._w}toAxisAngle(){const z=E.Zero();return{axis:z,angle:this.toAxisAngleToRef(z)}}toAxisAngleToRef(z){let u=0;const U=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),J=this._w;return U>0?(u=2*Math.atan2(U,J),z.set(this._x/U,this._y/U,this._z/U)):(u=0,z.set(1,0,0)),u}static FromRotationMatrix(z){const u=new r;return r.FromRotationMatrixToRef(z,u),u}static FromRotationMatrixToRef(z,u){const U=z.m,J=U[0],v=U[4],f=U[8],g=U[1],w=U[5],P=U[9],R=U[2],S=U[6],d=U[10],mz=J+w+d;let Z;return mz>0?(Z=.5/Math.sqrt(mz+1),u._w=.25/Z,u._x=(S-P)*Z,u._y=(f-R)*Z,u._z=(g-v)*Z,u._isDirty=!0):J>w&&J>d?(Z=2*Math.sqrt(1+J-w-d),u._w=(S-P)/Z,u._x=.25*Z,u._y=(v+g)/Z,u._z=(f+R)/Z,u._isDirty=!0):w>d?(Z=2*Math.sqrt(1+w-J-d),u._w=(f-R)/Z,u._x=(v+g)/Z,u._y=.25*Z,u._z=(P+S)/Z,u._isDirty=!0):(Z=2*Math.sqrt(1+d-J-w),u._w=(g-v)/Z,u._x=(f+R)/Z,u._y=(P+S)/Z,u._z=.25*Z,u._isDirty=!0),u}static Dot(z,u){return z._x*u._x+z._y*u._y+z._z*u._z+z._w*u._w}static AreClose(z,u){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const J=r.Dot(z,u);return 1-J*J<=U}static SmoothToRef(z,u,U,J,v){let f=0===J?1:U/J;return f=(0,P.Clamp)(f,0,1),r.SlerpToRef(z,u,f,v),v}static Zero(){return new r(0,0,0,0)}static Inverse(z){return new r(-z._x,-z._y,-z._z,z._w)}static InverseToRef(z,u){return u.set(-z._x,-z._y,-z._z,z._w),u}static Identity(){return new r(0,0,0,1)}static IsIdentity(z){return z&&0===z._x&&0===z._y&&0===z._z&&1===z._w}static RotationAxis(z,u){return r.RotationAxisToRef(z,u,new r)}static RotationAxisToRef(z,u,U){U._w=Math.cos(u/2);const J=Math.sin(u/2)/z.length();return U._x=z._x*J,U._y=z._y*J,U._z=z._z*J,U._isDirty=!0,U}static Xu(z,u){return u||(u=0),new r(z[u],z[u+1],z[u+2],z[u+3])}static FromArrayToRef(z,u,U){return U._x=z[u],U._y=z[u+1],U._z=z[u+2],U._w=z[u+3],U._isDirty=!0,U}static FromFloatsToRef(z,u,U,J,v){return v.zg(z,u,U,J),v}static FromEulerAngles(z,u,U){const J=new r;return r.RotationYawPitchRollToRef(u,z,U,J),J}static FromEulerAnglesToRef(z,u,U,J){return r.RotationYawPitchRollToRef(u,z,U,J),J}static FromEulerVector(z){const u=new r;return r.RotationYawPitchRollToRef(z._y,z._x,z._z,u),u}static FromEulerVectorToRef(z,u){return r.RotationYawPitchRollToRef(z._y,z._x,z._z,u),u}static FromUnitVectorsToRef(z,u,U){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:J.d;const f=E.Dot(z,u)+1;return f<v?Math.abs(z.x)>Math.abs(z.z)?U.set(-z.y,z.x,0,0):U.set(0,-z.z,z.y,0):(E.CrossToRef(z,u,X.Eu[0]),U.set(X.Eu[0].x,X.Eu[0].y,X.Eu[0].z,f)),U.normalize()}static RotationYawPitchRoll(z,u,U){const J=new r;return r.RotationYawPitchRollToRef(z,u,U,J),J}static RotationYawPitchRollToRef(z,u,U,J){const v=.5*U,f=.5*u,g=.5*z,w=Math.sin(v),P=Math.cos(v),R=Math.sin(f),S=Math.cos(f),d=Math.sin(g),mz=Math.cos(g);return J._x=mz*R*P+d*S*w,J._y=d*S*P-mz*R*w,J._z=mz*S*w-d*R*P,J._w=mz*S*P+d*R*w,J._isDirty=!0,J}static RotationAlphaBetaGamma(z,u,U){const J=new r;return r.RotationAlphaBetaGammaToRef(z,u,U,J),J}static RotationAlphaBetaGammaToRef(z,u,U,J){const v=.5*(U+z),f=.5*(U-z),g=.5*u;return J._x=Math.cos(f)*Math.sin(g),J._y=Math.sin(f)*Math.sin(g),J._z=Math.sin(v)*Math.cos(g),J._w=Math.cos(v)*Math.cos(g),J._isDirty=!0,J}static RotationQuaternionFromAxis(z,u,U){const J=new r(0,0,0,0);return r.RotationQuaternionFromAxisToRef(z,u,U,J),J}static RotationQuaternionFromAxisToRef(z,u,U,J){const v=T.Matrix[0];return z=z.normalizeToRef(T.Eu[0]),u=u.normalizeToRef(T.Eu[1]),U=U.normalizeToRef(T.Eu[2]),M.FromXYZAxesToRef(z,u,U,v),r.FromRotationMatrixToRef(v,J),J}static FromLookDirectionLH(z,u){const U=new r;return r.FromLookDirectionLHToRef(z,u,U),U}static FromLookDirectionLHToRef(z,u,U){const J=T.Matrix[0];return M.LookDirectionLHToRef(z,u,J),r.FromRotationMatrixToRef(J,U),U}static FromLookDirectionRH(z,u){const U=new r;return r.FromLookDirectionRHToRef(z,u,U),U}static FromLookDirectionRHToRef(z,u,U){const J=T.Matrix[0];return M.LookDirectionRHToRef(z,u,J),r.FromRotationMatrixToRef(J,U)}static Slerp(z,u,U){const J=r.Identity();return r.SlerpToRef(z,u,U,J),J}static SlerpToRef(z,u,U,J){let v,f,g=z._x*u._x+z._y*u._y+z._z*u._z+z._w*u._w,w=!1;if(g<0&&(w=!0,g=-g),g>.999999)f=1-U,v=w?-U:U;else{const z=Math.acos(g),u=1/Math.sin(z);f=Math.sin((1-U)*z)*u,v=w?-Math.sin(U*z)*u:Math.sin(U*z)*u}return J._x=f*z._x+v*u._x,J._y=f*z._y+v*u._y,J._z=f*z._z+v*u._z,J._w=f*z._w+v*u._w,J._isDirty=!0,J}static Hermite(z,u,U,J,v){const f=v*v,g=v*f,w=2*g-3*f+1,P=-2*g+3*f,R=g-2*f+v,S=g-f,d=z._x*w+U._x*P+u._x*R+J._x*S,mz=z._y*w+U._y*P+u._y*R+J._y*S,Z=z._z*w+U._z*P+u._z*R+J._z*S,A=z._w*w+U._w*P+u._w*R+J._w*S;return new r(d,mz,Z,A)}static Hermite1stDerivative(z,u,U,J,v){const f=new r;return this.Hermite1stDerivativeToRef(z,u,U,J,v,f),f}static Hermite1stDerivativeToRef(z,u,U,J,v,f){const g=v*v;return f._x=6*(g-v)*z._x+(3*g-4*v+1)*u._x+6*(-g+v)*U._x+(3*g-2*v)*J._x,f._y=6*(g-v)*z._y+(3*g-4*v+1)*u._y+6*(-g+v)*U._y+(3*g-2*v)*J._y,f._z=6*(g-v)*z._z+(3*g-4*v+1)*u._z+6*(-g+v)*U._z+(3*g-2*v)*J._z,f._w=6*(g-v)*z._w+(3*g-4*v+1)*u._w+6*(-g+v)*U._w+(3*g-2*v)*J._w,f._isDirty=!0,f}static Normalize(z){const u=r.Zero();return r.NormalizeToRef(z,u),u}static NormalizeToRef(z,u){return z.normalizeToRef(u),u}static Clamp(z,u,U){const J=new r;return r.ClampToRef(z,u,U,J),J}static ClampToRef(z,u,U,J){return J.zg((0,P.Clamp)(z.x,u.x,U.x),(0,P.Clamp)(z.y,u.y,U.y),(0,P.Clamp)(z.z,u.z,U.z),(0,P.Clamp)(z.w,u.w,U.w))}static Random(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new r((0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u))}static RandomToRef(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).zg((0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u),(0,P.RandomRange)(z,u))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(z,u){return Math.sqrt(r.DistanceSquared(z,u))}static DistanceSquared(z,u){const U=z.x-u.x,J=z.y-u.y,v=z.z-u.z,f=z.w-u.w;return U*U+J*J+v*v+f*f}static Center(z,u){return r.CenterToRef(z,u,r.Zero())}static CenterToRef(z,u,U){return U.zg((z.x+u.x)/2,(z.y+u.y)/2,(z.z+u.z)/2,(z.w+u.w)/2)}}r._V8PerformanceHack=new r(.5,.5,.5,.5),Object.defineProperties(r.prototype,{dimension:{value:[4]},rank:{value:1}});class M{static get Use64Bits(){return g.e.MatrixUse64Bits}get m(){return this.Lf}markAsUpdated(){this.updateFlag=R._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1],U=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=z,this._isIdentity3x2=z||U,this._isIdentityDirty=!this._isIdentity&&u,this._isIdentity3x2Dirty=!this._isIdentity3x2&&J}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,g.e.MatrixTrackPrecisionChange&&g.e.MatrixTrackedMatrices.push(this),this.Lf=new g.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const z=this.Lf;this._isIdentity=1===z[0]&&0===z[1]&&0===z[2]&&0===z[3]&&0===z[4]&&1===z[5]&&0===z[6]&&0===z[7]&&0===z[8]&&0===z[9]&&1===z[10]&&0===z[11]&&0===z[12]&&0===z[13]&&0===z[14]&&1===z[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Lf[0]||1!==this.Lf[5]||1!==this.Lf[15]||0!==this.Lf[1]||0!==this.Lf[2]||0!==this.Lf[3]||0!==this.Lf[4]||0!==this.Lf[6]||0!==this.Lf[7]||0!==this.Lf[8]||0!==this.Lf[9]||0!==this.Lf[10]||0!==this.Lf[11]||0!==this.Lf[12]||0!==this.Lf[13]||0!==this.Lf[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const z=this.Lf,u=z[0],U=z[1],J=z[2],v=z[3],f=z[4],g=z[5],w=z[6],P=z[7],R=z[8],S=z[9],d=z[10],mz=z[11],Z=z[12],A=z[13],E=z[14],C=z[15],r=d*C-E*mz,M=S*C-A*mz,T=S*E-A*d,X=R*C-Z*mz,h=R*E-d*Z,t=R*A-Z*S;return u*+(g*r-w*M+P*T)+U*-(f*r-w*X+P*h)+J*+(f*M-g*X+P*t)+v*-(f*T-g*h+w*t)}toString(){return"{".concat(this.m[0],", ").concat(this.m[1],", ").concat(this.m[2],", ").concat(this.m[3],"\n").concat(this.m[4],", ").concat(this.m[5],", ").concat(this.m[6],", ").concat(this.m[7],"\n").concat(this.m[8],", ").concat(this.m[9],", ").concat(this.m[10],", ").concat(this.m[11],"\n").concat(this.m[12],", ").concat(this.m[13],", ").concat(this.m[14],", ").concat(this.m[15],"}")}toArray(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!z)return this.Lf;const U=this.Lf;for(let J=0;J<16;J++)z[u+J]=U[J];return this}jf(){return this.Lf}CU(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M.FromArrayToRef(z,u,this)}zg(){for(var z=arguments.length,u=new Array(z),U=0;U<z;U++)u[U]=arguments[U];return M.FromArrayToRef(u,0,this)}set(){const z=this.Lf;for(let u=0;u<16;u++)z[u]=u<0||arguments.length<=u?void 0:arguments[u];return this.markAsUpdated(),this}fg(z){const u=this.Lf;for(let U=0;U<16;U++)u[U]=z;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return M.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(z){const u=new M;return this.addToRef(z,u),u}addToRef(z,u){const U=this.Lf,J=u.Lf,v=z.m;for(let f=0;f<16;f++)J[f]=U[f]+v[f];return u.markAsUpdated(),u}addToSelf(z){const u=this.Lf,U=z.m;return u[0]+=U[0],u[1]+=U[1],u[2]+=U[2],u[3]+=U[3],u[4]+=U[4],u[5]+=U[5],u[6]+=U[6],u[7]+=U[7],u[8]+=U[8],u[9]+=U[9],u[10]+=U[10],u[11]+=U[11],u[12]+=U[12],u[13]+=U[13],u[14]+=U[14],u[15]+=U[15],this.markAsUpdated(),this}addInPlace(z){const u=this.Lf,U=z.m;for(let J=0;J<16;J++)u[J]+=U[J];return this.markAsUpdated(),this}addInPlaceFromFloats(){const z=this.Lf;for(let u=0;u<16;u++)z[u]+=u<0||arguments.length<=u?void 0:arguments[u];return this.markAsUpdated(),this}Cu(z){const u=this.Lf,U=z.m;for(let J=0;J<16;J++)u[J]-=U[J];return this.markAsUpdated(),this}subtractToRef(z,u){const U=this.Lf,J=z.m,v=u.Lf;for(let f=0;f<16;f++)v[f]=U[f]-J[f];return u.markAsUpdated(),u}dm(z){const u=this.Lf,U=z.m;for(let J=0;J<16;J++)u[J]-=U[J];return this.markAsUpdated(),this}subtractFromFloats(){for(var z=arguments.length,u=new Array(z),U=0;U<z;U++)u[U]=arguments[U];return this.subtractFromFloatsToRef(...u,new M)}subtractFromFloatsToRef(){for(var z=arguments.length,u=new Array(z),U=0;U<z;U++)u[U]=arguments[U];const J=u.pop(),v=this.Lf,f=J.Lf,g=u;for(let w=0;w<16;w++)f[w]=v[w]-g[w];return J.markAsUpdated(),J}invertToRef(z){return!0===this._isIdentity?(M.IdentityToRef(z),z):(mz(this,z.jf())?z.markAsUpdated():z.v(this),z)}addAtIndex(z,u){return this.Lf[z]+=u,this.markAsUpdated(),this}multiplyAtIndex(z,u){return this.Lf[z]*=u,this.markAsUpdated(),this}setTranslationFromFloats(z,u,U){return this.Lf[12]=z,this.Lf[13]=u,this.Lf[14]=U,this.markAsUpdated(),this}addTranslationFromFloats(z,u,U){return this.Lf[12]+=z,this.Lf[13]+=u,this.Lf[14]+=U,this.markAsUpdated(),this}setTranslation(z){return this.setTranslationFromFloats(z._x,z._y,z._z)}getTranslation(){return new E(this.Lf[12],this.Lf[13],this.Lf[14])}getTranslationToRef(z){return z.x=this.Lf[12],z.y=this.Lf[13],z.z=this.Lf[14],z}removeRotationAndScaling(){const z=this.m;return M.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,z[12],z[13],z[14],z[15],this),this._updateIdentityStatus(0===z[12]&&0===z[13]&&0===z[14]&&1===z[15]),this}v(z){z.copyToArray(this.Lf);const u=z;return this.updateFlag=u.updateFlag,this._updateIdentityStatus(u._isIdentity,u._isIdentityDirty,u._isIdentity3x2,u._isIdentity3x2Dirty),this}copyToArray(z){return d(this,z,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(z){const u=new M;return this.multiplyToRef(z,u),u}multiplyInPlace(z){const u=this.Lf,U=z.m;for(let J=0;J<16;J++)u[J]*=U[J];return this.markAsUpdated(),this}multiplyByFloats(){const z=this.Lf;for(let u=0;u<16;u++)z[u]*=u<0||arguments.length<=u?void 0:arguments[u];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var z=arguments.length,u=new Array(z),U=0;U<z;U++)u[U]=arguments[U];const J=u.pop(),v=this.Lf,f=J.Lf,g=u;for(let w=0;w<16;w++)f[w]=v[w]*g[w];return J.markAsUpdated(),J}multiplyToRef(z,u){return this._isIdentity?(u.v(z),u):z._isIdentity?(u.v(this),u):(this.multiplyToArray(z,u.Lf,0),u.markAsUpdated(),u)}multiplyToArray(z,u,U){return S(this,z,u,U),this}divide(z){return this.divideToRef(z,new M)}divideToRef(z,u){const U=this.Lf,J=z.m,v=u.Lf;for(let f=0;f<16;f++)v[f]=U[f]/J[f];return u.markAsUpdated(),u}divideInPlace(z){const u=this.Lf,U=z.m;for(let J=0;J<16;J++)u[J]/=U[J];return this.markAsUpdated(),this}minimizeInPlace(z){const u=this.Lf,U=z.m;for(let J=0;J<16;J++)u[J]=Math.min(u[J],U[J]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const z=this.Lf;for(let u=0;u<16;u++)z[u]=Math.min(z[u],u<0||arguments.length<=u?void 0:arguments[u]);return this.markAsUpdated(),this}maximizeInPlace(z){const u=this.Lf,U=z.m;for(let J=0;J<16;J++)u[J]=Math.min(u[J],U[J]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const z=this.Lf;for(let u=0;u<16;u++)z[u]=Math.min(z[u],u<0||arguments.length<=u?void 0:arguments[u]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new M)}negateInPlace(){const z=this.Lf;for(let u=0;u<16;u++)z[u]=-z[u];return this.markAsUpdated(),this}negateToRef(z){const u=this.Lf,U=z.Lf;for(let J=0;J<16;J++)U[J]=-u[J];return z.markAsUpdated(),z}equals(z){const u=z;if(!u)return!1;if((this._isIdentity||u._isIdentity)&&!this._isIdentityDirty&&!u._isIdentityDirty)return this._isIdentity&&u._isIdentity;const U=this.m,J=u.m;return U[0]===J[0]&&U[1]===J[1]&&U[2]===J[2]&&U[3]===J[3]&&U[4]===J[4]&&U[5]===J[5]&&U[6]===J[6]&&U[7]===J[7]&&U[8]===J[8]&&U[9]===J[9]&&U[10]===J[10]&&U[11]===J[11]&&U[12]===J[12]&&U[13]===J[13]&&U[14]===J[14]&&U[15]===J[15]}equalsWithEpsilon(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const U=this.Lf,J=z.m;for(let v=0;v<16;v++)if(!(0,P.WithinEpsilon)(U[v],J[v],u))return!1;return!0}equalsToFloats(){const z=this.Lf;for(let u=0;u<16;u++)if(z[u]!=(u<0||arguments.length<=u?void 0:arguments[u]))return!1;return!0}floor(){return this.floorToRef(new M)}floorToRef(z){const u=this.Lf,U=z.Lf;for(let J=0;J<16;J++)U[J]=Math.floor(u[J]);return z.markAsUpdated(),z}fract(){return this.fractToRef(new M)}fractToRef(z){const u=this.Lf,U=z.Lf;for(let J=0;J<16;J++)U[J]=u[J]-Math.floor(u[J]);return z.markAsUpdated(),z}clone(){const z=new M;return z.v(this),z}getClassName(){return"Matrix"}getHashCode(){let z=Z(this.Lf[0]);for(let u=1;u<16;u++)z=397*z^Z(this.Lf[u]);return z}decomposeToTransformNode(z){return z.rotationQuaternion=z.rotationQuaternion||new r,this.decompose(z.Ug,z.rotationQuaternion,z.position)}decompose(z,u,U,J){let v=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return U&&U.fg(0),z&&z.fg(1),u&&u.zg(0,0,0,1),!0;const f=this.Lf;if(U&&U.zg(f[12],f[13],f[14]),(z=z||T.Eu[0]).x=Math.sqrt(f[0]*f[0]+f[1]*f[1]+f[2]*f[2]),z.y=Math.sqrt(f[4]*f[4]+f[5]*f[5]+f[6]*f[6]),z.z=Math.sqrt(f[8]*f[8]+f[9]*f[9]+f[10]*f[10]),J){const u=(v?J.absoluteScaling.x:J.Ug.x)<0?-1:1,U=(v?J.absoluteScaling.y:J.Ug.y)<0?-1:1,f=(v?J.absoluteScaling.z:J.Ug.z)<0?-1:1;z.x*=u,z.y*=U,z.z*=f}else this.determinant()<=0&&(z.y*=-1);if(0===z._x||0===z._y||0===z._z)return u&&u.zg(0,0,0,1),!1;if(u){const U=1/z._x,J=1/z._y,v=1/z._z;M.FromValuesToRef(f[0]*U,f[1]*U,f[2]*U,0,f[4]*J,f[5]*J,f[6]*J,0,f[8]*v,f[9]*v,f[10]*v,0,0,0,0,1,T.Matrix[0]),r.FromRotationMatrixToRef(T.Matrix[0],u)}return!0}getRow(z){if(z<0||z>3)return null;const u=4*z;return new C(this.Lf[u+0],this.Lf[u+1],this.Lf[u+2],this.Lf[u+3])}getRowToRef(z,u){if(z>=0&&z<=3){const U=4*z;u.x=this.Lf[U+0],u.y=this.Lf[U+1],u.z=this.Lf[U+2],u.w=this.Lf[U+3]}return u}setRow(z,u){return this.setRowFromFloats(z,u.x,u.y,u.z,u.w)}transpose(){const z=new M;return M.TransposeToRef(this,z),z}transposeToRef(z){return M.TransposeToRef(this,z),z}setRowFromFloats(z,u,U,J,v){if(z<0||z>3)return this;const f=4*z;return this.Lf[f+0]=u,this.Lf[f+1]=U,this.Lf[f+2]=J,this.Lf[f+3]=v,this.markAsUpdated(),this}scale(z){const u=new M;return this.scaleToRef(z,u),u}scaleToRef(z,u){for(let U=0;U<16;U++)u.Lf[U]=this.Lf[U]*z;return u.markAsUpdated(),u}scaleAndAddToRef(z,u){for(let U=0;U<16;U++)u.Lf[U]+=this.Lf[U]*z;return u.markAsUpdated(),u}scaleInPlace(z){const u=this.Lf;for(let U=0;U<16;U++)u[U]*=z;return this.markAsUpdated(),this}toNormalMatrix(z){const u=T.Matrix[0];this.invertToRef(u),u.transposeToRef(z);const U=z.Lf;return M.FromValuesToRef(U[0],U[1],U[2],0,U[4],U[5],U[6],0,U[8],U[9],U[10],0,0,0,0,1,z),z}getRotationMatrix(){const z=new M;return this.getRotationMatrixToRef(z),z}getRotationMatrixToRef(z){const u=T.Eu[0];if(!this.decompose(u))return M.IdentityToRef(z),z;const U=this.Lf,J=1/u._x,v=1/u._y,f=1/u._z;return M.FromValuesToRef(U[0]*J,U[1]*J,U[2]*J,0,U[4]*v,U[5]*v,U[6]*v,0,U[8]*f,U[9]*f,U[10]*f,0,0,0,0,1,z),z}toggleModelMatrixHandInPlace(){const z=this.Lf;return z[2]*=-1,z[6]*=-1,z[8]*=-1,z[9]*=-1,z[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const z=this.Lf;return z[8]*=-1,z[9]*=-1,z[10]*=-1,z[11]*=-1,this.markAsUpdated(),this}static Xu(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const U=new M;return M.FromArrayToRef(z,u,U),U}static FromArrayToRef(z,u,U){for(let J=0;J<16;J++)U.Lf[J]=z[J+u];return U.markAsUpdated(),U}static FromFloat32ArrayToRefScaled(z,u,U,J){return J.Lf[0]=z[0+u]*U,J.Lf[1]=z[1+u]*U,J.Lf[2]=z[2+u]*U,J.Lf[3]=z[3+u]*U,J.Lf[4]=z[4+u]*U,J.Lf[5]=z[5+u]*U,J.Lf[6]=z[6+u]*U,J.Lf[7]=z[7+u]*U,J.Lf[8]=z[8+u]*U,J.Lf[9]=z[9+u]*U,J.Lf[10]=z[10+u]*U,J.Lf[11]=z[11+u]*U,J.Lf[12]=z[12+u]*U,J.Lf[13]=z[13+u]*U,J.Lf[14]=z[14+u]*U,J.Lf[15]=z[15+u]*U,J.markAsUpdated(),J}static get IdentityReadOnly(){return M._IdentityReadOnly}static FromValuesToRef(z,u,U,J,v,f,g,w,P,R,S,d,mz,Z,A,E,C){const r=C.Lf;r[0]=z,r[1]=u,r[2]=U,r[3]=J,r[4]=v,r[5]=f,r[6]=g,r[7]=w,r[8]=P,r[9]=R,r[10]=S,r[11]=d,r[12]=mz,r[13]=Z,r[14]=A,r[15]=E,C.markAsUpdated()}static FromValues(z,u,U,J,v,f,g,w,P,R,S,d,mz,Z,A,E){const C=new M,r=C.Lf;return r[0]=z,r[1]=u,r[2]=U,r[3]=J,r[4]=v,r[5]=f,r[6]=g,r[7]=w,r[8]=P,r[9]=R,r[10]=S,r[11]=d,r[12]=mz,r[13]=Z,r[14]=A,r[15]=E,C.markAsUpdated(),C}static Compose(z,u,U){const J=new M;return M.ComposeToRef(z,u,U,J),J}static ComposeToRef(z,u,U,J){const v=J.Lf,f=u._x,g=u._y,w=u._z,P=u._w,R=f+f,S=g+g,d=w+w,mz=f*R,Z=f*S,A=f*d,E=g*S,C=g*d,r=w*d,M=P*R,T=P*S,X=P*d,h=z._x,t=z._y,V=z._z;return v[0]=(1-(E+r))*h,v[1]=(Z+X)*h,v[2]=(A-T)*h,v[3]=0,v[4]=(Z-X)*t,v[5]=(1-(mz+r))*t,v[6]=(C+M)*t,v[7]=0,v[8]=(A+T)*V,v[9]=(C-M)*V,v[10]=(1-(mz+E))*V,v[11]=0,v[12]=U._x,v[13]=U._y,v[14]=U._z,v[15]=1,J.markAsUpdated(),J}static Identity(){const z=M.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return z._updateIdentityStatus(!0),z}static IdentityToRef(z){return M.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,z),z._updateIdentityStatus(!0),z}static Zero(){const z=M.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return z._updateIdentityStatus(!1),z}static RotationX(z){const u=new M;return M.RotationXToRef(z,u),u}static Invert(z){const u=new M;return z.invertToRef(u),u}static RotationXToRef(z,u){const U=Math.sin(z),J=Math.cos(z);return M.FromValuesToRef(1,0,0,0,0,J,U,0,0,-U,J,0,0,0,0,1,u),u._updateIdentityStatus(1===J&&0===U),u}static RotationY(z){const u=new M;return M.RotationYToRef(z,u),u}static RotationYToRef(z,u){const U=Math.sin(z),J=Math.cos(z);return M.FromValuesToRef(J,0,-U,0,0,1,0,0,U,0,J,0,0,0,0,1,u),u._updateIdentityStatus(1===J&&0===U),u}static RotationZ(z){const u=new M;return M.RotationZToRef(z,u),u}static RotationZToRef(z,u){const U=Math.sin(z),J=Math.cos(z);return M.FromValuesToRef(J,U,0,0,-U,J,0,0,0,0,1,0,0,0,0,1,u),u._updateIdentityStatus(1===J&&0===U),u}static RotationAxis(z,u){const U=new M;return M.RotationAxisToRef(z,u,U),U}static RotationAxisToRef(z,u,U){const J=Math.sin(-u),v=Math.cos(-u),f=1-v;z=z.normalizeToRef(T.Eu[0]);const g=U.Lf;return g[0]=z._x*z._x*f+v,g[1]=z._x*z._y*f-z._z*J,g[2]=z._x*z._z*f+z._y*J,g[3]=0,g[4]=z._y*z._x*f+z._z*J,g[5]=z._y*z._y*f+v,g[6]=z._y*z._z*f-z._x*J,g[7]=0,g[8]=z._z*z._x*f-z._y*J,g[9]=z._z*z._y*f+z._x*J,g[10]=z._z*z._z*f+v,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,U.markAsUpdated(),U}static RotationAlignToRef(z,u,U){let v=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const f=E.Dot(u,z),g=U.Lf;if(f<-1+J.d)g[0]=-1,g[1]=0,g[2]=0,g[3]=0,g[4]=0,g[5]=v?1:-1,g[6]=0,g[7]=0,g[8]=0,g[9]=0,g[10]=v?-1:1,g[11]=0;else{const U=E.Cross(u,z),J=1/(1+f);g[0]=U._x*U._x*J+f,g[1]=U._y*U._x*J-U._z,g[2]=U._z*U._x*J+U._y,g[3]=0,g[4]=U._x*U._y*J+U._z,g[5]=U._y*U._y*J+f,g[6]=U._z*U._y*J-U._x,g[7]=0,g[8]=U._x*U._z*J-U._y,g[9]=U._y*U._z*J+U._x,g[10]=U._z*U._z*J+f,g[11]=0}return g[12]=0,g[13]=0,g[14]=0,g[15]=1,U.markAsUpdated(),U}static RotationYawPitchRoll(z,u,U){const J=new M;return M.RotationYawPitchRollToRef(z,u,U,J),J}static RotationYawPitchRollToRef(z,u,U,J){return r.RotationYawPitchRollToRef(z,u,U,T.Quaternion[0]),T.Quaternion[0].toRotationMatrix(J),J}static Scaling(z,u,U){const J=new M;return M.ScalingToRef(z,u,U,J),J}static ScalingToRef(z,u,U,J){return M.FromValuesToRef(z,0,0,0,0,u,0,0,0,0,U,0,0,0,0,1,J),J._updateIdentityStatus(1===z&&1===u&&1===U),J}static Translation(z,u,U){const J=new M;return M.TranslationToRef(z,u,U,J),J}static TranslationToRef(z,u,U,J){return M.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,z,u,U,1,J),J._updateIdentityStatus(0===z&&0===u&&0===U),J}static Lerp(z,u,U){const J=new M;return M.LerpToRef(z,u,U,J),J}static LerpToRef(z,u,U,J){const v=J.Lf,f=z.m,g=u.m;for(let w=0;w<16;w++)v[w]=f[w]*(1-U)+g[w]*U;return J.markAsUpdated(),J}static DecomposeLerp(z,u,U){const J=new M;return M.DecomposeLerpToRef(z,u,U,J),J}static DecomposeLerpToRef(z,u,U,J){const v=T.Eu[0],f=T.Quaternion[0],g=T.Eu[1];z.decompose(v,f,g);const w=T.Eu[2],P=T.Quaternion[1],R=T.Eu[3];u.decompose(w,P,R);const S=T.Eu[4];E.LerpToRef(v,w,U,S);const d=T.Quaternion[2];r.SlerpToRef(f,P,U,d);const mz=T.Eu[5];return E.LerpToRef(g,R,U,mz),M.ComposeToRef(S,d,mz,J),J}static LookAtLH(z,u,U){const J=new M;return M.LookAtLHToRef(z,u,U,J),J}static LookAtLHToRef(z,u,U,J){const v=T.Eu[0],f=T.Eu[1],g=T.Eu[2];u.subtractToRef(z,g),g.normalize(),E.CrossToRef(U,g,v);const w=v.lengthSquared();0===w?v.x=1:v.normalizeFromLength(Math.sqrt(w)),E.CrossToRef(g,v,f),f.normalize();const P=-E.Dot(v,z),R=-E.Dot(f,z),S=-E.Dot(g,z);return M.FromValuesToRef(v._x,f._x,g._x,0,v._y,f._y,g._y,0,v._z,f._z,g._z,0,P,R,S,1,J),J}static LookAtRH(z,u,U){const J=new M;return M.LookAtRHToRef(z,u,U,J),J}static LookAtRHToRef(z,u,U,J){const v=T.Eu[0],f=T.Eu[1],g=T.Eu[2];z.subtractToRef(u,g),g.normalize(),E.CrossToRef(U,g,v);const w=v.lengthSquared();0===w?v.x=1:v.normalizeFromLength(Math.sqrt(w)),E.CrossToRef(g,v,f),f.normalize();const P=-E.Dot(v,z),R=-E.Dot(f,z),S=-E.Dot(g,z);return M.FromValuesToRef(v._x,f._x,g._x,0,v._y,f._y,g._y,0,v._z,f._z,g._z,0,P,R,S,1,J),J}static LookDirectionLH(z,u){const U=new M;return M.LookDirectionLHToRef(z,u,U),U}static LookDirectionLHToRef(z,u,U){const J=T.Eu[0];J.v(z),J.scaleInPlace(-1);const v=T.Eu[1];return E.CrossToRef(u,J,v),M.FromValuesToRef(v._x,v._y,v._z,0,u._x,u._y,u._z,0,J._x,J._y,J._z,0,0,0,0,1,U),U}static LookDirectionRH(z,u){const U=new M;return M.LookDirectionRHToRef(z,u,U),U}static LookDirectionRHToRef(z,u,U){const J=T.Eu[2];return E.CrossToRef(u,z,J),M.FromValuesToRef(J._x,J._y,J._z,0,u._x,u._y,u._z,0,z._x,z._y,z._z,0,0,0,0,1,U),U}static OrthoLH(z,u,U,J,v){const f=new M;return M.OrthoLHToRef(z,u,U,J,f,v),f}static OrthoLHToRef(z,u,U,J,v,f){const g=2/z,w=2/u,P=2/(J-U),R=-(J+U)/(J-U);return M.FromValuesToRef(g,0,0,0,0,w,0,0,0,0,P,0,0,0,R,1,v),f&&v.multiplyToRef(h,v),v._updateIdentityStatus(1===g&&1===w&&1===P&&0===R),v}static OrthoOffCenterLH(z,u,U,J,v,f,g){const w=new M;return M.OrthoOffCenterLHToRef(z,u,U,J,v,f,w,g),w}static OrthoOffCenterLHToRef(z,u,U,J,v,f,g,w){const P=2/(u-z),R=2/(J-U),S=2/(f-v),d=-(f+v)/(f-v),mz=(z+u)/(z-u),Z=(J+U)/(U-J);return M.FromValuesToRef(P,0,0,0,0,R,0,0,0,0,S,0,mz,Z,d,1,g),w&&g.multiplyToRef(h,g),g.markAsUpdated(),g}static ObliqueOffCenterLHToRef(z,u,U,J,v,f,g,w,P,R,S){const d=-g*Math.cos(w),mz=-g*Math.sin(w);return M.TranslationToRef(0,0,-P,T.Matrix[1]),M.FromValuesToRef(1,0,0,0,0,1,0,0,d,mz,1,0,0,0,0,1,T.Matrix[0]),T.Matrix[1].multiplyToRef(T.Matrix[0],T.Matrix[0]),M.TranslationToRef(0,0,P,T.Matrix[1]),T.Matrix[0].multiplyToRef(T.Matrix[1],T.Matrix[0]),M.OrthoOffCenterLHToRef(z,u,U,J,v,f,R,S),T.Matrix[0].multiplyToRef(R,R),R}static OrthoOffCenterRH(z,u,U,J,v,f,g){const w=new M;return M.OrthoOffCenterRHToRef(z,u,U,J,v,f,w,g),w}static OrthoOffCenterRHToRef(z,u,U,J,v,f,g,w){return M.OrthoOffCenterLHToRef(z,u,U,J,v,f,g,w),g.Lf[10]*=-1,g}static ObliqueOffCenterRHToRef(z,u,U,J,v,f,g,w,P,R,S){const d=g*Math.cos(w),mz=g*Math.sin(w);return M.TranslationToRef(0,0,P,T.Matrix[1]),M.FromValuesToRef(1,0,0,0,0,1,0,0,d,mz,1,0,0,0,0,1,T.Matrix[0]),T.Matrix[1].multiplyToRef(T.Matrix[0],T.Matrix[0]),M.TranslationToRef(0,0,-P,T.Matrix[1]),T.Matrix[0].multiplyToRef(T.Matrix[1],T.Matrix[0]),M.OrthoOffCenterRHToRef(z,u,U,J,v,f,R,S),T.Matrix[0].multiplyToRef(R,R),R}static PerspectiveLH(z,u,U,J,v){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const g=new M,w=2*U/z,P=2*U/u,R=(J+U)/(J-U),S=-2*J*U/(J-U),d=Math.tan(f);return M.FromValuesToRef(w,0,0,0,0,P,0,d,0,0,R,1,0,0,S,0,g),v&&g.multiplyToRef(h,g),g._updateIdentityStatus(!1),g}static PerspectiveFovLH(z,u,U,J,v){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const w=new M;return M.PerspectiveFovLHToRef(z,u,U,J,w,!0,v,f,g),w}static PerspectiveFovLHToRef(z,u,U,J,v){let f=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,P=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const R=U,S=J,d=1/Math.tan(.5*z),mz=f?d/u:d,Z=f?d:d*u,A=P&&0===R?-1:0!==S?(S+R)/(S-R):1,E=P&&0===R?2*S:0!==S?-2*S*R/(S-R):-2*R,C=Math.tan(w);return M.FromValuesToRef(mz,0,0,0,0,Z,0,C,0,0,A,1,0,0,E,0,v),g&&v.multiplyToRef(h,v),v._updateIdentityStatus(!1),v}static PerspectiveFovReverseLHToRef(z,u,U,J,v){let f=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const P=1/Math.tan(.5*z),R=f?P/u:P,S=f?P:P*u,d=Math.tan(w);return M.FromValuesToRef(R,0,0,0,0,S,0,d,0,0,-U,1,0,0,1,0,v),g&&v.multiplyToRef(h,v),v._updateIdentityStatus(!1),v}static PerspectiveFovRH(z,u,U,J,v){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const w=new M;return M.PerspectiveFovRHToRef(z,u,U,J,w,!0,v,f,g),w}static PerspectiveFovRHToRef(z,u,U,J,v){let f=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,P=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const R=U,S=J,d=1/Math.tan(.5*z),mz=f?d/u:d,Z=f?d:d*u,A=P&&0===R?1:0!==S?-(S+R)/(S-R):-1,E=P&&0===R?2*S:0!==S?-2*S*R/(S-R):-2*R,C=Math.tan(w);return M.FromValuesToRef(mz,0,0,0,0,Z,0,C,0,0,A,-1,0,0,E,0,v),g&&v.multiplyToRef(h,v),v._updateIdentityStatus(!1),v}static PerspectiveFovReverseRHToRef(z,u,U,J,v){let f=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const P=1/Math.tan(.5*z),R=f?P/u:P,S=f?P:P*u,d=Math.tan(w);return M.FromValuesToRef(R,0,0,0,0,S,0,d,0,0,-U,-1,0,0,-1,0,v),g&&v.multiplyToRef(h,v),v._updateIdentityStatus(!1),v}static GetFinalMatrix(z,u,U,J,v,f){const g=z.width,w=z.height,P=z.x,R=z.y,S=M.FromValues(g/2,0,0,0,0,-w/2,0,0,0,0,f-v,0,P+g/2,w/2+R,v,1),d=new M;return u.multiplyToRef(U,d),d.multiplyToRef(J,d),d.multiplyToRef(S,d)}static GetAsMatrix2x2(z){const u=z.m,U=[u[0],u[1],u[4],u[5]];return g.e.MatrixUse64Bits?U:new Float32Array(U)}static GetAsMatrix3x3(z){const u=z.m,U=[u[0],u[1],u[2],u[4],u[5],u[6],u[8],u[9],u[10]];return g.e.MatrixUse64Bits?U:new Float32Array(U)}static Transpose(z){const u=new M;return M.TransposeToRef(z,u),u}static TransposeToRef(z,u){const U=z.m,J=U[0],v=U[4],f=U[8],g=U[12],w=U[1],P=U[5],R=U[9],S=U[13],d=U[2],mz=U[6],Z=U[10],A=U[14],E=U[3],C=U[7],r=U[11],M=U[15],T=u.Lf;return T[0]=J,T[1]=v,T[2]=f,T[3]=g,T[4]=w,T[5]=P,T[6]=R,T[7]=S,T[8]=d,T[9]=mz,T[10]=Z,T[11]=A,T[12]=E,T[13]=C,T[14]=r,T[15]=M,u.markAsUpdated(),u._updateIdentityStatus(z._isIdentity,z._isIdentityDirty),u}static Reflection(z){const u=new M;return M.ReflectionToRef(z,u),u}static ReflectionToRef(z,u){z.normalize();const U=z.normal.x,J=z.normal.y,v=z.normal.z,f=-2*U,g=-2*J,w=-2*v;return M.FromValuesToRef(f*U+1,g*U,w*U,0,f*J,g*J+1,w*J,0,f*v,g*v,w*v+1,0,f*z.d,g*z.d,w*z.d,1,u),u}static FromXYZAxesToRef(z,u,U,J){return M.FromValuesToRef(z._x,z._y,z._z,0,u._x,u._y,u._z,0,U._x,U._y,U._z,0,0,0,0,1,J),J}static FromQuaternionToRef(z,u){const U=z._x*z._x,J=z._y*z._y,v=z._z*z._z,f=z._x*z._y,g=z._z*z._w,w=z._z*z._x,P=z._y*z._w,R=z._y*z._z,S=z._x*z._w;return u.Lf[0]=1-2*(J+v),u.Lf[1]=2*(f+g),u.Lf[2]=2*(w-P),u.Lf[3]=0,u.Lf[4]=2*(f-g),u.Lf[5]=1-2*(v+U),u.Lf[6]=2*(R+S),u.Lf[7]=0,u.Lf[8]=2*(w+P),u.Lf[9]=2*(R-S),u.Lf[10]=1-2*(J+U),u.Lf[11]=0,u.Lf[12]=0,u.Lf[13]=0,u.Lf[14]=0,u.Lf[15]=1,u.markAsUpdated(),u}}M._IdentityReadOnly=M.Identity(),Object.defineProperties(M.prototype,{dimension:{value:[4,4]},rank:{value:2}});class T{}T.Eu=(0,v.i)(11,E.Zero),T.Matrix=(0,v.i)(2,M.Identity),T.Quaternion=(0,v.i)(3,r.Zero);class X{}X.Vector2=(0,v.i)(3,A.Zero),X.Eu=(0,v.i)(13,E.Zero),X.Vector4=(0,v.i)(3,C.Zero),X.Quaternion=(0,v.i)(3,r.Zero),X.Matrix=(0,v.i)(8,M.Identity),(0,f.f)("BABYLON.Vector2",A),(0,f.f)("BABYLON.Vector3",E),(0,f.f)("BABYLON.Vector4",C),(0,f.f)("BABYLON.Matrix",M);const h=M.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12926:(z,u,U)=>{function J(z,u){const U=[];for(let J=0;J<z;++J)U.push(u());return U}function v(z,u){return J(z,u)}U.d(u,{e:()=>J,i:()=>v,m:()=>g});const f=["push","splice","pop","shift","unshift"];function g(z,u){const U=f.map((U=>function(z,u,U){const J=z[u];if("function"!==typeof J)return null;const v=function(){const J=z.length,f=v.previous.apply(z,arguments);return U(u,J),f};return J.next=v,v.previous=J,z[u]=v,()=>{const U=v.previous;if(!U)return;const J=v.next;J?(U.next=J,J.previous=U):(U.next=void 0,z[u]=U),v.next=void 0,v.previous=void 0}}(z,U,u)));return()=>{for(const z of U)null===z||void 0===z||z()}}}}]);