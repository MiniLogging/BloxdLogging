"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[14],{12837:(Y,b,C)=>{C.d(b,{e:()=>E,h:()=>A,l:()=>R,n:()=>q});const R=1/2.2,q=2.2,A=(1+Math.sqrt(5))/2,E=.001},12852:(Y,b,C)=>{function R(Y){return parseInt(Y.toString().replace(/\W/g,""))}function q(Y,b){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Y-b)<=C}function A(Y,b,C){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Y<b-R||Y>C+R}function E(Y,b){return Y===b?Y:Math.random()*(b-Y)+Y}function B(Y,b,C){return Y+(b-Y)*C}function g(Y,b,C){let R=I(b-Y,360);return R>180&&(R-=360),Y+R*y(C)}function r(Y,b,C){let R=0;return R=Y!=b?y((C-Y)/(b-Y)):0,R}function O(Y,b,C,R,q){const A=q*q,E=q*A;return Y*(2*E-3*A+1)+C*(-2*E+3*A)+b*(E-2*A+q)+R*(E-A)}function F(Y,b,C,R,q){const A=q*q;return 6*(A-q)*Y+(3*A-4*q+1)*b+6*(-A+q)*C+(3*A-2*q)*R}function y(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(b,Y))}function S(Y){return Y-=2*Math.PI*Math.floor((Y+Math.PI)/(2*Math.PI))}function n(Y){const b=Y.toString(16);return Y<=15?("0"+b).toUpperCase():b.toUpperCase()}function t(Y){if(Math.log2)return Math.floor(Math.log2(Y));if(Y<0)return NaN;if(0===Y)return-1/0;let b=0;if(Y<1){for(;Y<1;)b++,Y*=2;b=-b}else if(Y>1)for(;Y>1;)b++,Y=Math.floor(Y/2);return b}function I(Y,b){return Y-Math.floor(Y/b)*b}function w(Y,b,C){return(Y-b)/(C-b)}function Q(Y,b,C){return Y*(C-b)+b}function N(Y,b){let C=I(b-Y,360);return C>180&&(C-=360),C}function p(Y,b){const C=I(Y,2*b);return b-Math.abs(C-b)}function mY(Y,b,C){let R=y(C);return R=-2*R*R*R+3*R*R,b*R+Y*(1-R)}function L(Y,b,C){let R=0;return R=Math.abs(b-Y)<=C?b:Y+Math.sign(b-Y)*C,R}function u(Y,b,C){const R=N(Y,b);let q=0;return q=-C<R&&R<C?b:L(Y,b=Y+R,C),q}function c(Y,b,C){return(Y-b)/(C-b)}function l(Y,b,C){return(C-b)*Y+b}function X(Y,b){const C=Y%b;return 0===C?b:X(b,C)}C.r(b),C.d(b,{Clamp:()=>y,DeltaAngle:()=>N,Denormalize:()=>Q,ExtractAsInt:()=>R,Hermite:()=>O,Hermite1stDerivative:()=>F,HighestCommonFactor:()=>X,ILog2:()=>t,InverseLerp:()=>r,Lerp:()=>B,LerpAngle:()=>g,MoveTowards:()=>L,MoveTowardsAngle:()=>u,Normalize:()=>w,NormalizeRadians:()=>S,OutsideRange:()=>A,PercentToRange:()=>l,PingPong:()=>p,RandomRange:()=>E,RangeToPercent:()=>c,Repeat:()=>I,SmoothStep:()=>mY,ToHex:()=>n,WithinEpsilon:()=>q})},12831:(Y,b,C)=>{C.r(b),C.d(b,{Matrix:()=>Q,Quaternion:()=>w,TmpVectors:()=>p,Vector2:()=>n,AC:()=>t,Vector4:()=>I});var R=C(12837),q=C(12846),A=C(12790),E=C(12764),B=C(12702),g=C(12852);class r{}function O(Y,b,C){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const q=Y.cb(),A=b.cb(),E=q[0],B=q[1],g=q[2],r=q[3],O=q[4],F=q[5],y=q[6],S=q[7],n=q[8],t=q[9],I=q[10],w=q[11],Q=q[12],N=q[13],p=q[14],mY=q[15],L=A[0],u=A[1],c=A[2],l=A[3],X=A[4],j=A[5],T=A[6],P=A[7],v=A[8],z=A[9],J=A[10],U=A[11],o=A[12],G=A[13],h=A[14],e=A[15];C[R]=E*L+B*X+g*v+r*o,C[R+1]=E*u+B*j+g*z+r*G,C[R+2]=E*c+B*T+g*J+r*h,C[R+3]=E*l+B*P+g*U+r*e,C[R+4]=O*L+F*X+y*v+S*o,C[R+5]=O*u+F*j+y*z+S*G,C[R+6]=O*c+F*T+y*J+S*h,C[R+7]=O*l+F*P+y*U+S*e,C[R+8]=n*L+t*X+I*v+w*o,C[R+9]=n*u+t*j+I*z+w*G,C[R+10]=n*c+t*T+I*J+w*h,C[R+11]=n*l+t*P+I*U+w*e,C[R+12]=Q*L+N*X+p*v+mY*o,C[R+13]=Q*u+N*j+p*z+mY*G,C[R+14]=Q*c+N*T+p*J+mY*h,C[R+15]=Q*l+N*P+p*U+mY*e}function F(Y,b){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const R=Y.cb();b[C]=R[0],b[C+1]=R[1],b[C+2]=R[2],b[C+3]=R[3],b[C+4]=R[4],b[C+5]=R[5],b[C+6]=R[6],b[C+7]=R[7],b[C+8]=R[8],b[C+9]=R[9],b[C+10]=R[10],b[C+11]=R[11],b[C+12]=R[12],b[C+13]=R[13],b[C+14]=R[14],b[C+15]=R[15]}function y(Y,b){const C=Y.cb(),R=C[0],q=C[1],A=C[2],E=C[3],B=C[4],g=C[5],r=C[6],O=C[7],F=C[8],y=C[9],S=C[10],n=C[11],t=C[12],I=C[13],w=C[14],Q=C[15],N=S*Q-w*n,p=y*Q-I*n,mY=y*w-I*S,L=F*Q-t*n,u=F*w-S*t,c=F*I-t*y,l=+(g*N-r*p+O*mY),X=-(B*N-r*L+O*u),j=+(B*p-g*L+O*c),T=-(B*mY-g*u+r*c),P=R*l+q*X+A*j+E*T;if(0===P)return!1;const v=1/P,z=r*Q-w*O,J=g*Q-I*O,U=g*w-I*r,o=B*Q-t*O,G=B*w-t*r,h=B*I-t*g,e=r*n-S*O,H=g*n-y*O,i=g*S-y*r,W=B*n-F*O,s=B*S-F*r,D=B*y-F*g,d=-(q*N-A*p+E*mY),V=+(R*N-A*L+E*u),k=-(R*p-q*L+E*c),x=+(R*mY-q*u+A*c),a=+(q*z-A*J+E*U),M=-(R*z-A*o+E*G),K=+(R*J-q*o+E*h),f=-(R*U-q*G+A*h),Z=-(q*e-A*H+E*i),YY=+(R*e-A*W+E*s),bY=-(R*H-q*W+E*D),CY=+(R*i-q*s+A*D);return b[0]=l*v,b[1]=d*v,b[2]=a*v,b[3]=Z*v,b[4]=X*v,b[5]=V*v,b[6]=M*v,b[7]=YY*v,b[8]=j*v,b[9]=k*v,b[10]=K*v,b[11]=bY*v,b[12]=T*v,b[13]=x*v,b[14]=f*v,b[15]=CY*v,!0}r._UpdateFlagSeed=0;const S=Y=>parseInt(Y.toString().replace(/\W/g,""));class n{constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=Y,this.y=b}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let Y=S(this.x);return Y=397*Y^S(this.y),Y}toArray(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y[b]=this.x,Y[b+1]=this.y,this}ER(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n.FromArrayToRef(Y,b,this),this}cb(){return[this.x,this.y]}q(Y){return this.x=Y.x,this.y=Y.y,this}Ub(Y,b){return this.x=Y,this.y=b,this}set(Y,b){return this.Ub(Y,b)}Gb(Y){return this.Ub(Y,Y)}add(Y){return new n(this.x+Y.x,this.y+Y.y)}addToRef(Y,b){return b.x=this.x+Y.x,b.y=this.y+Y.y,b}addInPlace(Y){return this.x+=Y.x,this.y+=Y.y,this}addInPlaceFromFloats(Y,b){return this.x+=Y,this.y+=b,this}addVector3(Y){return new n(this.x+Y.x,this.y+Y.y)}EC(Y){return new n(this.x-Y.x,this.y-Y.y)}subtractToRef(Y,b){return b.x=this.x-Y.x,b.y=this.y-Y.y,b}dF(Y){return this.x-=Y.x,this.y-=Y.y,this}multiplyInPlace(Y){return this.x*=Y.x,this.y*=Y.y,this}multiply(Y){return new n(this.x*Y.x,this.y*Y.y)}multiplyToRef(Y,b){return b.x=this.x*Y.x,b.y=this.y*Y.y,b}multiplyByFloats(Y,b){return new n(this.x*Y,this.y*b)}divide(Y){return new n(this.x/Y.x,this.y/Y.y)}divideToRef(Y,b){return b.x=this.x/Y.x,b.y=this.y/Y.y,b}divideInPlace(Y){return this.x=this.x/Y.x,this.y=this.y/Y.y,this}minimizeInPlace(Y){return this.minimizeInPlaceFromFloats(Y.x,Y.y)}maximizeInPlace(Y){return this.maximizeInPlaceFromFloats(Y.x,Y.y)}minimizeInPlaceFromFloats(Y,b){return this.x=Math.min(Y,this.x),this.y=Math.min(b,this.y),this}maximizeInPlaceFromFloats(Y,b){return this.x=Math.max(Y,this.x),this.y=Math.max(b,this.y),this}subtractFromFloats(Y,b){return new n(this.x-Y,this.y-b)}subtractFromFloatsToRef(Y,b,C){return C.x=this.x-Y,C.y=this.y-b,C}negate(){return new n(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(Y){return Y.x=-this.x,Y.y=-this.y,Y}scaleInPlace(Y){return this.x*=Y,this.y*=Y,this}scale(Y){return new n(this.x*Y,this.y*Y)}scaleToRef(Y,b){return b.x=this.x*Y,b.y=this.y*Y,b}scaleAndAddToRef(Y,b){return b.x+=this.x*Y,b.y+=this.y*Y,b}equals(Y){return Y&&this.x===Y.x&&this.y===Y.y}equalsWithEpsilon(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.e;return Y&&(0,g.WithinEpsilon)(this.x,Y.x,b)&&(0,g.WithinEpsilon)(this.y,Y.y,b)}equalsToFloats(Y,b){return this.x===Y&&this.y===b}floor(){return new n(Math.floor(this.x),Math.floor(this.y))}floorToRef(Y){return Y.x=Math.floor(this.x),Y.y=Math.floor(this.y),Y}fract(){return new n(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(Y){return Y.x=this.x-Math.floor(this.x),Y.y=this.y-Math.floor(this.y),Y}rotate(Y){return this.rotateToRef(Y,new n)}rotateToRef(Y,b){const C=Math.cos(Y),R=Math.sin(Y);return b.x=C*this.x-R*this.y,b.y=R*this.x+C*this.y,b}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Y){return 0===Y||1===Y?this:this.scaleInPlace(1/Y)}normalizeToNew(){const Y=new n;return this.normalizeToRef(Y),Y}normalizeToRef(Y){const b=this.length();return 0===b&&(Y.x=this.x,Y.y=this.y),this.scaleToRef(1/b,Y)}clone(){return new n(this.x,this.y)}dot(Y){return this.x*Y.x+this.y*Y.y}static Zero(){return new n(0,0)}static One(){return new n(1,1)}static Random(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new n((0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b))}static RandomToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ub((0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b))}static get ZeroReadOnly(){return n._ZeroReadOnly}static OC(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new n(Y[b],Y[b+1])}static FromArrayToRef(Y,b,C){return C.x=Y[b],C.y=Y[b+1],C}static FromFloatsToRef(Y,b,C){return C.Ub(Y,b),C}static CatmullRom(Y,b,C,R,q){const A=q*q,E=q*A,B=.5*(2*b.x+(-Y.x+C.x)*q+(2*Y.x-5*b.x+4*C.x-R.x)*A+(-Y.x+3*b.x-3*C.x+R.x)*E),g=.5*(2*b.y+(-Y.y+C.y)*q+(2*Y.y-5*b.y+4*C.y-R.y)*A+(-Y.y+3*b.y-3*C.y+R.y)*E);return new n(B,g)}static ClampToRef(Y,b,C,R){return R.x=(0,g.Clamp)(Y.x,b.x,C.x),R.y=(0,g.Clamp)(Y.y,b.y,C.y),R}static Clamp(Y,b,C){const R=(0,g.Clamp)(Y.x,b.x,C.x),q=(0,g.Clamp)(Y.y,b.y,C.y);return new n(R,q)}static Hermite(Y,b,C,R,q){const A=q*q,E=q*A,B=2*E-3*A+1,g=-2*E+3*A,r=E-2*A+q,O=E-A,F=Y.x*B+C.x*g+b.x*r+R.x*O,y=Y.y*B+C.y*g+b.y*r+R.y*O;return new n(F,y)}static Hermite1stDerivative(Y,b,C,R,q){return this.Hermite1stDerivativeToRef(Y,b,C,R,q,new n)}static Hermite1stDerivativeToRef(Y,b,C,R,q,A){const E=q*q;return A.x=6*(E-q)*Y.x+(3*E-4*q+1)*b.x+6*(-E+q)*C.x+(3*E-2*q)*R.x,A.y=6*(E-q)*Y.y+(3*E-4*q+1)*b.y+6*(-E+q)*C.y+(3*E-2*q)*R.y,A}static Lerp(Y,b,C){return n.LerpToRef(Y,b,C,new n)}static LerpToRef(Y,b,C,R){return R.x=Y.x+(b.x-Y.x)*C,R.y=Y.y+(b.y-Y.y)*C,R}static Dot(Y,b){return Y.x*b.x+Y.y*b.y}static Normalize(Y){return n.NormalizeToRef(Y,new n)}static NormalizeToRef(Y,b){return Y.normalizeToRef(b),b}static Minimize(Y,b){const C=Y.x<b.x?Y.x:b.x,R=Y.y<b.y?Y.y:b.y;return new n(C,R)}static Maximize(Y,b){const C=Y.x>b.x?Y.x:b.x,R=Y.y>b.y?Y.y:b.y;return new n(C,R)}static Transform(Y,b){return n.TransformToRef(Y,b,new n)}static TransformToRef(Y,b,C){const R=b.m,q=Y.x*R[0]+Y.y*R[4]+R[12],A=Y.x*R[1]+Y.y*R[5]+R[13];return C.x=q,C.y=A,C}static PointInTriangle(Y,b,C,R){const q=.5*(-C.y*R.x+b.y*(-C.x+R.x)+b.x*(C.y-R.y)+C.x*R.y),A=q<0?-1:1,E=(b.y*R.x-b.x*R.y+(R.y-b.y)*Y.x+(b.x-R.x)*Y.y)*A,B=(b.x*C.y-b.y*C.x+(b.y-C.y)*Y.x+(C.x-b.x)*Y.y)*A;return E>0&&B>0&&E+B<2*q*A}static Distance(Y,b){return Math.sqrt(n.DistanceSquared(Y,b))}static DistanceSquared(Y,b){const C=Y.x-b.x,R=Y.y-b.y;return C*C+R*R}static Center(Y,b){return n.CenterToRef(Y,b,new n)}static CenterToRef(Y,b,C){return C.Ub((Y.x+b.x)/2,(Y.y+b.y)/2)}static DistanceOfPointFromSegment(Y,b,C){const R=n.DistanceSquared(b,C);if(0===R)return n.Distance(Y,b);const q=C.EC(b),A=Math.max(0,Math.min(1,n.Dot(Y.EC(b),q)/R)),E=b.add(q.multiplyByFloats(A,A));return n.Distance(Y,E)}}n._V8PerformanceHack=new n(.5,.5),n._ZeroReadOnly=n.Zero(),Object.defineProperties(n.prototype,{dimension:{value:[2]},rank:{value:1}});class t{get x(){return this._x}set x(Y){this._x=Y,this._isDirty=!0}get y(){return this._y}set y(Y){this._y=Y,this._isDirty=!0}get z(){return this._z}set z(Y){this._z=Y,this._isDirty=!0}constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=Y,this._y=b,this._z=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"AC"}getHashCode(){let Y=S(this._x);return Y=397*Y^S(this._y),Y=397*Y^S(this._z),Y}cb(){return[this._x,this._y,this._z]}toArray(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y[b]=this._x,Y[b+1]=this._y,Y[b+2]=this._z,this}ER(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(Y,b,this),this}toQuaternion(){return w.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(Y){return this._x+=Y._x,this._y+=Y._y,this._z+=Y._z,this._isDirty=!0,this}addInPlaceFromFloats(Y,b,C){return this._x+=Y,this._y+=b,this._z+=C,this._isDirty=!0,this}add(Y){return new t(this._x+Y._x,this._y+Y._y,this._z+Y._z)}addToRef(Y,b){return b._x=this._x+Y._x,b._y=this._y+Y._y,b._z=this._z+Y._z,b._isDirty=!0,b}dF(Y){return this._x-=Y._x,this._y-=Y._y,this._z-=Y._z,this._isDirty=!0,this}EC(Y){return new t(this._x-Y._x,this._y-Y._y,this._z-Y._z)}subtractToRef(Y,b){return this.subtractFromFloatsToRef(Y._x,Y._y,Y._z,b)}subtractFromFloats(Y,b,C){return new t(this._x-Y,this._y-b,this._z-C)}subtractFromFloatsToRef(Y,b,C,R){return R._x=this._x-Y,R._y=this._y-b,R._z=this._z-C,R._isDirty=!0,R}negate(){return new t(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(Y){return Y._x=-1*this._x,Y._y=-1*this._y,Y._z=-1*this._z,Y._isDirty=!0,Y}scaleInPlace(Y){return this._x*=Y,this._y*=Y,this._z*=Y,this._isDirty=!0,this}scale(Y){return new t(this._x*Y,this._y*Y,this._z*Y)}scaleToRef(Y,b){return b._x=this._x*Y,b._y=this._y*Y,b._z=this._z*Y,b._isDirty=!0,b}getNormalToRef(Y){const b=this.length();let C=Math.acos(this._y/b);const R=Math.atan2(this._z,this._x);C>Math.PI/2?C-=Math.PI/2:C+=Math.PI/2;const q=b*Math.sin(C)*Math.cos(R),A=b*Math.cos(C),E=b*Math.sin(C)*Math.sin(R);return Y.set(q,A,E),Y}applyRotationQuaternionToRef(Y,b){const C=this._x,R=this._y,q=this._z,A=Y._x,E=Y._y,B=Y._z,g=Y._w,r=2*(E*q-B*R),O=2*(B*C-A*q),F=2*(A*R-E*C);return b._x=C+g*r+E*F-B*O,b._y=R+g*O+B*r-A*F,b._z=q+g*F+A*O-E*r,b._isDirty=!0,b}applyRotationQuaternionInPlace(Y){return this.applyRotationQuaternionToRef(Y,this)}applyRotationQuaternion(Y){return this.applyRotationQuaternionToRef(Y,new t)}scaleAndAddToRef(Y,b){return b._x+=this._x*Y,b._y+=this._y*Y,b._z+=this._z*Y,b._isDirty=!0,b}projectOnPlane(Y,b){return this.projectOnPlaneToRef(Y,b,new t)}projectOnPlaneToRef(Y,b,C){const R=Y.normal,q=Y.d,A=N.AC[0];this.subtractToRef(b,A),A.normalize();const E=t.Dot(A,R);if(Math.abs(E)<1e-10)C.Gb(1/0);else{const Y=-(t.Dot(b,R)+q)/E,B=A.scaleInPlace(Y);b.addToRef(B,C)}return C}equals(Y){return Y&&this._x===Y._x&&this._y===Y._y&&this._z===Y._z}equalsWithEpsilon(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.e;return Y&&(0,g.WithinEpsilon)(this._x,Y._x,b)&&(0,g.WithinEpsilon)(this._y,Y._y,b)&&(0,g.WithinEpsilon)(this._z,Y._z,b)}equalsToFloats(Y,b,C){return this._x===Y&&this._y===b&&this._z===C}multiplyInPlace(Y){return this._x*=Y._x,this._y*=Y._y,this._z*=Y._z,this._isDirty=!0,this}multiply(Y){return this.multiplyByFloats(Y._x,Y._y,Y._z)}multiplyToRef(Y,b){return b._x=this._x*Y._x,b._y=this._y*Y._y,b._z=this._z*Y._z,b._isDirty=!0,b}multiplyByFloats(Y,b,C){return new t(this._x*Y,this._y*b,this._z*C)}divide(Y){return new t(this._x/Y._x,this._y/Y._y,this._z/Y._z)}divideToRef(Y,b){return b._x=this._x/Y._x,b._y=this._y/Y._y,b._z=this._z/Y._z,b._isDirty=!0,b}divideInPlace(Y){return this._x=this._x/Y._x,this._y=this._y/Y._y,this._z=this._z/Y._z,this._isDirty=!0,this}minimizeInPlace(Y){return this.minimizeInPlaceFromFloats(Y._x,Y._y,Y._z)}maximizeInPlace(Y){return this.maximizeInPlaceFromFloats(Y._x,Y._y,Y._z)}minimizeInPlaceFromFloats(Y,b,C){return Y<this._x&&(this.x=Y),b<this._y&&(this.y=b),C<this._z&&(this.z=C),this}maximizeInPlaceFromFloats(Y,b,C){return Y>this._x&&(this.x=Y),b>this._y&&(this.y=b),C>this._z&&(this.z=C),this}isNonUniformWithinEpsilon(Y){const b=Math.abs(this._x),C=Math.abs(this._y);if(!(0,g.WithinEpsilon)(b,C,Y))return!0;const R=Math.abs(this._z);return!(0,g.WithinEpsilon)(b,R,Y)||!(0,g.WithinEpsilon)(C,R,Y)}get isNonUniform(){const Y=Math.abs(this._x);if(Y!==Math.abs(this._y))return!0;return Y!==Math.abs(this._z)}floorToRef(Y){return Y._x=Math.floor(this._x),Y._y=Math.floor(this._y),Y._z=Math.floor(this._z),Y._isDirty=!0,Y}floor(){return new t(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(Y){return Y._x=this._x-Math.floor(this._x),Y._y=this._y-Math.floor(this._y),Y._z=this._z-Math.floor(this._z),Y._isDirty=!0,Y}fract(){return new t(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(Y){if("xyz"===(Y=Y.toLowerCase()))return this;const b=N.AC[0].q(this);return this.x=b[Y[0]],this.y=b[Y[1]],this.z=b[Y[2]],this}rotateByQuaternionToRef(Y,b){return Y.toRotationMatrix(N.Matrix[0]),t.TransformCoordinatesToRef(this,N.Matrix[0],b),b}rotateByQuaternionAroundPointToRef(Y,b,C){return this.subtractToRef(b,N.AC[0]),N.AC[0].rotateByQuaternionToRef(Y,N.AC[0]),b.addToRef(N.AC[0],C),C}cross(Y){return t.CrossToRef(this,Y,new t)}normalizeFromLength(Y){return 0===Y||1===Y?this:this.scaleInPlace(1/Y)}normalizeToNew(){return this.normalizeToRef(new t)}normalizeToRef(Y){const b=this.length();return 0===b||1===b?(Y._x=this._x,Y._y=this._y,Y._z=this._z,Y._isDirty=!0,Y):this.scaleToRef(1/b,Y)}clone(){return new t(this._x,this._y,this._z)}q(Y){return this.Ub(Y._x,Y._y,Y._z)}Ub(Y,b,C){return this._x=Y,this._y=b,this._z=C,this._isDirty=!0,this}set(Y,b,C){return this.Ub(Y,b,C)}Gb(Y){return this._x=this._y=this._z=Y,this._isDirty=!0,this}static GetClipFactor(Y,b,C,R){const q=t.Dot(Y,C);return(q-R)/(q-t.Dot(b,C))}static GetAngleBetweenVectors(Y,b,C){const R=Y.normalizeToRef(N.AC[1]),q=b.normalizeToRef(N.AC[2]);let A=t.Dot(R,q);A=(0,g.Clamp)(A,-1,1);const E=Math.acos(A),B=N.AC[3];return t.CrossToRef(R,q,B),t.Dot(B,C)>0?isNaN(E)?0:E:isNaN(E)?-Math.PI:-Math.acos(A)}static GetAngleBetweenVectorsOnPlane(Y,b,C){N.AC[0].q(Y);const R=N.AC[0];N.AC[1].q(b);const q=N.AC[1];N.AC[2].q(C);const A=N.AC[2],E=N.AC[3],B=N.AC[4];R.normalize(),q.normalize(),A.normalize(),t.CrossToRef(A,R,E),t.CrossToRef(E,A,B);const r=Math.atan2(t.Dot(q,E),t.Dot(q,B));return(0,g.NormalizeRadians)(r)}static PitchYawRollToMoveBetweenPointsToRef(Y,b,C){const R=p.AC[0];return b.subtractToRef(Y,R),C._y=Math.atan2(R.x,R.z)||0,C._x=Math.atan2(Math.sqrt(R.x**2+R.z**2),R.y)||0,C._z=0,C._isDirty=!0,C}static PitchYawRollToMoveBetweenPoints(Y,b){const C=t.Zero();return t.PitchYawRollToMoveBetweenPointsToRef(Y,b,C)}static SlerpToRef(Y,b,C,q){C=(0,g.Clamp)(C,0,1);const A=N.AC[0],E=N.AC[1];A.q(Y);const B=A.length();A.normalizeFromLength(B),E.q(b);const r=E.length();E.normalizeFromLength(r);const O=t.Dot(A,E);let F,y;if(O<1-R.e){const Y=Math.acos(O),b=1/Math.sin(Y);F=Math.sin((1-C)*Y)*b,y=Math.sin(C*Y)*b}else F=1-C,y=C;return A.scaleInPlace(F),E.scaleInPlace(y),q.q(A).addInPlace(E),q.scaleInPlace((0,g.Lerp)(B,r,C)),q}static SmoothToRef(Y,b,C,R,q){return t.SlerpToRef(Y,b,0===R?1:C/R,q),q}static OC(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new t(Y[b],Y[b+1],Y[b+2])}static FromFloatArray(Y,b){return t.OC(Y,b)}static FromArrayToRef(Y,b,C){return C._x=Y[b],C._y=Y[b+1],C._z=Y[b+2],C._isDirty=!0,C}static FromFloatArrayToRef(Y,b,C){return t.FromArrayToRef(Y,b,C)}static FromFloatsToRef(Y,b,C,R){return R.Ub(Y,b,C),R}static Zero(){return new t(0,0,0)}static One(){return new t(1,1,1)}static Up(){return new t(0,1,0)}static get UpReadOnly(){return t._UpReadOnly}static get DownReadOnly(){return t._DownReadOnly}static get RightReadOnly(){return t._RightReadOnly}static get LeftReadOnly(){return t._LeftReadOnly}static get LeftHandedForwardReadOnly(){return t._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return t._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return t._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return t._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return t._ZeroReadOnly}static get OneReadOnly(){return t._OneReadOnly}static Down(){return new t(0,-1,0)}static Forward(){return new t(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new t(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new t(1,0,0)}static Left(){return new t(-1,0,0)}static Random(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new t((0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b))}static RandomToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ub((0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b))}static TransformCoordinates(Y,b){const C=t.Zero();return t.TransformCoordinatesToRef(Y,b,C),C}static TransformCoordinatesToRef(Y,b,C){return t.TransformCoordinatesFromFloatsToRef(Y._x,Y._y,Y._z,b,C),C}static TransformCoordinatesFromFloatsToRef(Y,b,C,R,q){const A=R.m,E=Y*A[0]+b*A[4]+C*A[8]+A[12],B=Y*A[1]+b*A[5]+C*A[9]+A[13],g=Y*A[2]+b*A[6]+C*A[10]+A[14],r=1/(Y*A[3]+b*A[7]+C*A[11]+A[15]);return q._x=E*r,q._y=B*r,q._z=g*r,q._isDirty=!0,q}static TransformNormal(Y,b){const C=t.Zero();return t.TransformNormalToRef(Y,b,C),C}static TransformNormalToRef(Y,b,C){return this.TransformNormalFromFloatsToRef(Y._x,Y._y,Y._z,b,C),C}static TransformNormalFromFloatsToRef(Y,b,C,R,q){const A=R.m;return q._x=Y*A[0]+b*A[4]+C*A[8],q._y=Y*A[1]+b*A[5]+C*A[9],q._z=Y*A[2]+b*A[6]+C*A[10],q._isDirty=!0,q}static CatmullRom(Y,b,C,R,q){const A=q*q,E=q*A,B=.5*(2*b._x+(-Y._x+C._x)*q+(2*Y._x-5*b._x+4*C._x-R._x)*A+(-Y._x+3*b._x-3*C._x+R._x)*E),g=.5*(2*b._y+(-Y._y+C._y)*q+(2*Y._y-5*b._y+4*C._y-R._y)*A+(-Y._y+3*b._y-3*C._y+R._y)*E),r=.5*(2*b._z+(-Y._z+C._z)*q+(2*Y._z-5*b._z+4*C._z-R._z)*A+(-Y._z+3*b._z-3*C._z+R._z)*E);return new t(B,g,r)}static Clamp(Y,b,C){const R=new t;return t.ClampToRef(Y,b,C,R),R}static ClampToRef(Y,b,C,R){let q=Y._x;q=q>C._x?C._x:q,q=q<b._x?b._x:q;let A=Y._y;A=A>C._y?C._y:A,A=A<b._y?b._y:A;let E=Y._z;return E=E>C._z?C._z:E,E=E<b._z?b._z:E,R.Ub(q,A,E),R}static CheckExtends(Y,b,C){b.minimizeInPlace(Y),C.maximizeInPlace(Y)}static Hermite(Y,b,C,R,q){const A=q*q,E=q*A,B=2*E-3*A+1,g=-2*E+3*A,r=E-2*A+q,O=E-A,F=Y._x*B+C._x*g+b._x*r+R._x*O,y=Y._y*B+C._y*g+b._y*r+R._y*O,S=Y._z*B+C._z*g+b._z*r+R._z*O;return new t(F,y,S)}static Hermite1stDerivative(Y,b,C,R,q){const A=new t;return this.Hermite1stDerivativeToRef(Y,b,C,R,q,A),A}static Hermite1stDerivativeToRef(Y,b,C,R,q,A){const E=q*q;return A._x=6*(E-q)*Y._x+(3*E-4*q+1)*b._x+6*(-E+q)*C._x+(3*E-2*q)*R._x,A._y=6*(E-q)*Y._y+(3*E-4*q+1)*b._y+6*(-E+q)*C._y+(3*E-2*q)*R._y,A._z=6*(E-q)*Y._z+(3*E-4*q+1)*b._z+6*(-E+q)*C._z+(3*E-2*q)*R._z,A._isDirty=!0,A}static Lerp(Y,b,C){const R=new t(0,0,0);return t.LerpToRef(Y,b,C,R),R}static LerpToRef(Y,b,C,R){return R._x=Y._x+(b._x-Y._x)*C,R._y=Y._y+(b._y-Y._y)*C,R._z=Y._z+(b._z-Y._z)*C,R._isDirty=!0,R}static Dot(Y,b){return Y._x*b._x+Y._y*b._y+Y._z*b._z}dot(Y){return this._x*Y._x+this._y*Y._y+this._z*Y._z}static Cross(Y,b){const C=new t;return t.CrossToRef(Y,b,C),C}static CrossToRef(Y,b,C){const R=Y._y*b._z-Y._z*b._y,q=Y._z*b._x-Y._x*b._z,A=Y._x*b._y-Y._y*b._x;return C.Ub(R,q,A),C}static Normalize(Y){const b=t.Zero();return t.NormalizeToRef(Y,b),b}static NormalizeToRef(Y,b){return Y.normalizeToRef(b),b}static Project(Y,b,C,R){const q=new t;return t.ProjectToRef(Y,b,C,R,q),q}static ProjectToRef(Y,b,C,R,q){var A;const E=R.width,g=R.height,r=R.x,O=R.y,F=N.Matrix[1],y=null===(A=B.d.LastCreatedEngine)||void 0===A?void 0:A.isNDCHalfZRange,S=y?1:.5,n=y?0:.5;Q.FromValuesToRef(E/2,0,0,0,0,-g/2,0,0,0,0,S,0,r+E/2,g/2+O,n,1,F);const I=N.Matrix[0];return b.multiplyToRef(C,I),I.multiplyToRef(F,I),t.TransformCoordinatesToRef(Y,I,q),q}static Reflect(Y,b){return this.ReflectToRef(Y,b,new t)}static ReflectToRef(Y,b,C){const R=p.AC[0];return R.q(b).scaleInPlace(2*t.Dot(Y,b)),C.q(Y).dF(R)}static _UnprojectFromInvertedMatrixToRef(Y,b,C){t.TransformCoordinatesToRef(Y,b,C);const R=b.m,q=Y._x*R[3]+Y._y*R[7]+Y._z*R[11]+R[15];return(0,g.WithinEpsilon)(q,1)&&C.scaleInPlace(1/q),C}static UnprojectFromTransform(Y,b,C,R,q){return this.Unproject(Y,b,C,R,q,Q.IdentityReadOnly)}static Unproject(Y,b,C,R,q,A){const E=new t;return t.UnprojectToRef(Y,b,C,R,q,A,E),E}static UnprojectToRef(Y,b,C,R,q,A,E){return t.UnprojectFloatsToRef(Y._x,Y._y,Y._z,b,C,R,q,A,E),E}static UnprojectFloatsToRef(Y,b,C,R,q,A,E,g,r){var O;const F=N.Matrix[0];A.multiplyToRef(E,F),F.multiplyToRef(g,F),F.invert();const y=N.AC[0];return y.x=Y/R*2-1,y.y=-(b/q*2-1),null!==(O=B.d.LastCreatedEngine)&&void 0!==O&&O.isNDCHalfZRange?y.z=C:y.z=2*C-1,t._UnprojectFromInvertedMatrixToRef(y,F,r),r}static Minimize(Y,b){const C=new t;return C.q(Y),C.minimizeInPlace(b),C}static Maximize(Y,b){const C=new t;return C.q(Y),C.maximizeInPlace(b),C}static Distance(Y,b){return Math.sqrt(t.DistanceSquared(Y,b))}static DistanceSquared(Y,b){const C=Y._x-b._x,R=Y._y-b._y,q=Y._z-b._z;return C*C+R*R+q*q}static ProjectOnTriangleToRef(Y,b,C,q,A){const E=N.AC[0],B=N.AC[1],r=N.AC[2],O=N.AC[3],F=N.AC[4];C.subtractToRef(b,E),q.subtractToRef(b,B),q.subtractToRef(C,r);const y=E.length(),S=B.length(),n=r.length();if(y<R.e||S<R.e||n<R.e)return A.q(b),t.Distance(Y,b);Y.subtractToRef(b,F),t.CrossToRef(E,B,O);const I=O.length();if(I<R.e)return A.q(b),t.Distance(Y,b);O.normalizeFromLength(I);let w=F.length();if(w<R.e)return A.q(b),0;F.normalizeFromLength(w);const Q=t.Dot(O,F),p=N.AC[5],mY=N.AC[6];p.q(O).scaleInPlace(-w*Q),mY.q(Y).addInPlace(p);const L=N.AC[4],u=N.AC[5],c=N.AC[7],l=N.AC[8];L.q(E).scaleInPlace(1/y),l.q(B).scaleInPlace(1/S),L.addInPlace(l).scaleInPlace(-1),u.q(E).scaleInPlace(-1/y),l.q(r).scaleInPlace(1/n),u.addInPlace(l).scaleInPlace(-1),c.q(r).scaleInPlace(-1/n),l.q(B).scaleInPlace(-1/S),c.addInPlace(l).scaleInPlace(-1);const X=N.AC[9];let j;X.q(mY).dF(b),t.CrossToRef(L,X,l),j=t.Dot(l,O);const T=j;X.q(mY).dF(C),t.CrossToRef(u,X,l),j=t.Dot(l,O);const P=j;X.q(mY).dF(q),t.CrossToRef(c,X,l),j=t.Dot(l,O);const v=j,z=N.AC[10];let J,U;T>0&&P<0?(z.q(E),J=b,U=C):P>0&&v<0?(z.q(r),J=C,U=q):(z.q(B).scaleInPlace(-1),J=q,U=b);const o=N.AC[9],G=N.AC[4];J.subtractToRef(mY,l),U.subtractToRef(mY,o),t.CrossToRef(l,o,G);if(!(t.Dot(G,O)<0))return A.q(mY),Math.abs(w*Q);const h=N.AC[5];t.CrossToRef(z,G,h),h.normalize();const e=N.AC[9];e.q(J).dF(mY);const H=e.length();if(H<R.e)return A.q(J),t.Distance(Y,J);e.normalizeFromLength(H);const i=t.Dot(h,e),W=N.AC[7];W.q(mY).addInPlace(h.scaleInPlace(H*i)),l.q(W).dF(J),w=z.length(),z.normalizeFromLength(w);let s=t.Dot(l,z)/Math.max(w,R.e);return s=(0,g.Clamp)(s,0,1),W.q(J).addInPlace(z.scaleInPlace(s*w)),A.q(W),t.Distance(Y,W)}static Center(Y,b){return t.CenterToRef(Y,b,t.Zero())}static CenterToRef(Y,b,C){return C.Ub((Y._x+b._x)/2,(Y._y+b._y)/2,(Y._z+b._z)/2)}static RotationFromAxis(Y,b,C){const R=new t;return t.RotationFromAxisToRef(Y,b,C,R),R}static RotationFromAxisToRef(Y,b,C,R){const q=N.Quaternion[0];return w.RotationQuaternionFromAxisToRef(Y,b,C,q),q.toEulerAnglesToRef(R),R}}t._V8PerformanceHack=new t(.5,.5,.5),t._UpReadOnly=t.Up(),t._DownReadOnly=t.Down(),t._LeftHandedForwardReadOnly=t.Forward(!1),t._RightHandedForwardReadOnly=t.Forward(!0),t._LeftHandedBackwardReadOnly=t.Backward(!1),t._RightHandedBackwardReadOnly=t.Backward(!0),t._RightReadOnly=t.Right(),t._LeftReadOnly=t.Left(),t._ZeroReadOnly=t.Zero(),t._OneReadOnly=t.One(),Object.defineProperties(t.prototype,{dimension:{value:[3]},rank:{value:1}});class I{get x(){return this._x}set x(Y){this._x=Y,this._isDirty=!0}get y(){return this._y}set y(Y){this._y=Y,this._isDirty=!0}get z(){return this._z}set z(Y){this._z=Y,this._isDirty=!0}get w(){return this._w}set w(Y){this._w=Y,this._isDirty=!0}constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=Y,this._y=b,this._z=C,this._w=R}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let Y=S(this._x);return Y=397*Y^S(this._y),Y=397*Y^S(this._z),Y=397*Y^S(this._w),Y}cb(){return[this._x,this._y,this._z,this._w]}toArray(Y,b){return void 0===b&&(b=0),Y[b]=this._x,Y[b+1]=this._y,Y[b+2]=this._z,Y[b+3]=this._w,this}ER(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I.FromArrayToRef(Y,b,this),this}addInPlace(Y){return this.x+=Y._x,this.y+=Y._y,this.z+=Y._z,this.w+=Y._w,this}addInPlaceFromFloats(Y,b,C,R){return this.x+=Y,this.y+=b,this.z+=C,this.w+=R,this}add(Y){return new I(this._x+Y.x,this._y+Y.y,this._z+Y.z,this._w+Y.w)}addToRef(Y,b){return b.x=this._x+Y.x,b.y=this._y+Y.y,b.z=this._z+Y.z,b.w=this._w+Y.w,b}dF(Y){return this.x-=Y.x,this.y-=Y.y,this.z-=Y.z,this.w-=Y.w,this}EC(Y){return new I(this._x-Y.x,this._y-Y.y,this._z-Y.z,this._w-Y.w)}subtractToRef(Y,b){return b.x=this._x-Y.x,b.y=this._y-Y.y,b.z=this._z-Y.z,b.w=this._w-Y.w,b}subtractFromFloats(Y,b,C,R){return new I(this._x-Y,this._y-b,this._z-C,this._w-R)}subtractFromFloatsToRef(Y,b,C,R,q){return q.x=this._x-Y,q.y=this._y-b,q.z=this._z-C,q.w=this._w-R,q}negate(){return new I(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(Y){return Y.x=-this._x,Y.y=-this._y,Y.z=-this._z,Y.w=-this._w,Y}scaleInPlace(Y){return this.x*=Y,this.y*=Y,this.z*=Y,this.w*=Y,this}scale(Y){return new I(this._x*Y,this._y*Y,this._z*Y,this._w*Y)}scaleToRef(Y,b){return b.x=this._x*Y,b.y=this._y*Y,b.z=this._z*Y,b.w=this._w*Y,b}scaleAndAddToRef(Y,b){return b.x+=this._x*Y,b.y+=this._y*Y,b.z+=this._z*Y,b.w+=this._w*Y,b}equals(Y){return Y&&this._x===Y.x&&this._y===Y.y&&this._z===Y.z&&this._w===Y.w}equalsWithEpsilon(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.e;return Y&&(0,g.WithinEpsilon)(this._x,Y.x,b)&&(0,g.WithinEpsilon)(this._y,Y.y,b)&&(0,g.WithinEpsilon)(this._z,Y.z,b)&&(0,g.WithinEpsilon)(this._w,Y.w,b)}equalsToFloats(Y,b,C,R){return this._x===Y&&this._y===b&&this._z===C&&this._w===R}multiplyInPlace(Y){return this.x*=Y.x,this.y*=Y.y,this.z*=Y.z,this.w*=Y.w,this}multiply(Y){return new I(this._x*Y.x,this._y*Y.y,this._z*Y.z,this._w*Y.w)}multiplyToRef(Y,b){return b.x=this._x*Y.x,b.y=this._y*Y.y,b.z=this._z*Y.z,b.w=this._w*Y.w,b}multiplyByFloats(Y,b,C,R){return new I(this._x*Y,this._y*b,this._z*C,this._w*R)}divide(Y){return new I(this._x/Y.x,this._y/Y.y,this._z/Y.z,this._w/Y.w)}divideToRef(Y,b){return b.x=this._x/Y.x,b.y=this._y/Y.y,b.z=this._z/Y.z,b.w=this._w/Y.w,b}divideInPlace(Y){return this.divideToRef(Y,this)}minimizeInPlace(Y){return Y.x<this._x&&(this.x=Y.x),Y.y<this._y&&(this.y=Y.y),Y.z<this._z&&(this.z=Y.z),Y.w<this._w&&(this.w=Y.w),this}maximizeInPlace(Y){return Y.x>this._x&&(this.x=Y.x),Y.y>this._y&&(this.y=Y.y),Y.z>this._z&&(this.z=Y.z),Y.w>this._w&&(this.w=Y.w),this}minimizeInPlaceFromFloats(Y,b,C,R){return this.x=Math.min(Y,this._x),this.y=Math.min(b,this._y),this.z=Math.min(C,this._z),this.w=Math.min(R,this._w),this}maximizeInPlaceFromFloats(Y,b,C,R){return this.x=Math.max(Y,this._x),this.y=Math.max(b,this._y),this.z=Math.max(C,this._z),this.w=Math.max(R,this._w),this}floorToRef(Y){return Y.x=Math.floor(this._x),Y.y=Math.floor(this._y),Y.z=Math.floor(this._z),Y.w=Math.floor(this._w),Y}floor(){return new I(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(Y){return Y.x=this._x-Math.floor(this._x),Y.y=this._y-Math.floor(this._y),Y.z=this._z-Math.floor(this._z),Y.w=this._w-Math.floor(this._w),Y}fract(){return new I(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Y){return 0===Y||1===Y?this:this.scaleInPlace(1/Y)}normalizeToNew(){return this.normalizeToRef(new I)}normalizeToRef(Y){const b=this.length();return 0===b||1===b?(Y.x=this._x,Y.y=this._y,Y.z=this._z,Y.w=this._w,Y):this.scaleToRef(1/b,Y)}toVector3(){return new t(this._x,this._y,this._z)}clone(){return new I(this._x,this._y,this._z,this._w)}q(Y){return this.x=Y.x,this.y=Y.y,this.z=Y.z,this.w=Y.w,this}Ub(Y,b,C,R){return this.x=Y,this.y=b,this.z=C,this.w=R,this}set(Y,b,C,R){return this.Ub(Y,b,C,R)}Gb(Y){return this.x=this.y=this.z=this.w=Y,this}dot(Y){return this._x*Y.x+this._y*Y.y+this._z*Y.z+this._w*Y.w}static OC(Y,b){return b||(b=0),new I(Y[b],Y[b+1],Y[b+2],Y[b+3])}static FromArrayToRef(Y,b,C){return C.x=Y[b],C.y=Y[b+1],C.z=Y[b+2],C.w=Y[b+3],C}static FromFloatArrayToRef(Y,b,C){return I.FromArrayToRef(Y,b,C),C}static FromFloatsToRef(Y,b,C,R,q){return q.x=Y,q.y=b,q.z=C,q.w=R,q}static Zero(){return new I(0,0,0,0)}static One(){return new I(1,1,1,1)}static Random(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new I((0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b))}static RandomToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.x=(0,g.RandomRange)(Y,b),C.y=(0,g.RandomRange)(Y,b),C.z=(0,g.RandomRange)(Y,b),C.w=(0,g.RandomRange)(Y,b),C}static Clamp(Y,b,C){return I.ClampToRef(Y,b,C,new I)}static ClampToRef(Y,b,C,R){return R.x=(0,g.Clamp)(Y.x,b.x,C.x),R.y=(0,g.Clamp)(Y.y,b.y,C.y),R.z=(0,g.Clamp)(Y.z,b.z,C.z),R.w=(0,g.Clamp)(Y.w,b.w,C.w),R}static CheckExtends(Y,b,C){b.minimizeInPlace(Y),C.maximizeInPlace(Y)}static get ZeroReadOnly(){return I._ZeroReadOnly}static Normalize(Y){return I.NormalizeToRef(Y,new I)}static NormalizeToRef(Y,b){return Y.normalizeToRef(b),b}static Minimize(Y,b){const C=new I;return C.q(Y),C.minimizeInPlace(b),C}static Maximize(Y,b){const C=new I;return C.q(Y),C.maximizeInPlace(b),C}static Distance(Y,b){return Math.sqrt(I.DistanceSquared(Y,b))}static DistanceSquared(Y,b){const C=Y.x-b.x,R=Y.y-b.y,q=Y.z-b.z,A=Y.w-b.w;return C*C+R*R+q*q+A*A}static Center(Y,b){return I.CenterToRef(Y,b,new I)}static CenterToRef(Y,b,C){return C.x=(Y.x+b.x)/2,C.y=(Y.y+b.y)/2,C.z=(Y.z+b.z)/2,C.w=(Y.w+b.w)/2,C}static TransformCoordinates(Y,b){return I.TransformCoordinatesToRef(Y,b,new I)}static TransformCoordinatesToRef(Y,b,C){return I.TransformCoordinatesFromFloatsToRef(Y._x,Y._y,Y._z,b,C),C}static TransformCoordinatesFromFloatsToRef(Y,b,C,R,q){const A=R.m,E=Y*A[0]+b*A[4]+C*A[8]+A[12],B=Y*A[1]+b*A[5]+C*A[9]+A[13],g=Y*A[2]+b*A[6]+C*A[10]+A[14],r=Y*A[3]+b*A[7]+C*A[11]+A[15];return q.x=E,q.y=B,q.z=g,q.w=r,q}static TransformNormal(Y,b){return I.TransformNormalToRef(Y,b,new I)}static TransformNormalToRef(Y,b,C){const R=b.m,q=Y.x*R[0]+Y.y*R[4]+Y.z*R[8],A=Y.x*R[1]+Y.y*R[5]+Y.z*R[9],E=Y.x*R[2]+Y.y*R[6]+Y.z*R[10];return C.x=q,C.y=A,C.z=E,C.w=Y.w,C}static TransformNormalFromFloatsToRef(Y,b,C,R,q,A){const E=q.m;return A.x=Y*E[0]+b*E[4]+C*E[8],A.y=Y*E[1]+b*E[5]+C*E[9],A.z=Y*E[2]+b*E[6]+C*E[10],A.w=R,A}static FromVector3(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new I(Y._x,Y._y,Y._z,b)}static Dot(Y,b){return Y.x*b.x+Y.y*b.y+Y.z*b.z+Y.w*b.w}}I._V8PerformanceHack=new I(.5,.5,.5,.5),I._ZeroReadOnly=I.Zero(),Object.defineProperties(I.prototype,{dimension:{value:[4]},rank:{value:1}});class w{get x(){return this._x}set x(Y){this._x=Y,this._isDirty=!0}get y(){return this._y}set y(Y){this._y=Y,this._isDirty=!0}get z(){return this._z}set z(Y){this._z=Y,this._isDirty=!0}get w(){return this._w}set w(Y){this._w=Y,this._isDirty=!0}constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=Y,this._y=b,this._z=C,this._w=R}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let Y=S(this._x);return Y=397*Y^S(this._y),Y=397*Y^S(this._z),Y=397*Y^S(this._w),Y}cb(){return[this._x,this._y,this._z,this._w]}toArray(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y[b]=this._x,Y[b+1]=this._y,Y[b+2]=this._z,Y[b+3]=this._w,this}ER(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w.FromArrayToRef(Y,b,this)}equals(Y){return Y&&this._x===Y._x&&this._y===Y._y&&this._z===Y._z&&this._w===Y._w}equalsWithEpsilon(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.e;return Y&&(0,g.WithinEpsilon)(this._x,Y._x,b)&&(0,g.WithinEpsilon)(this._y,Y._y,b)&&(0,g.WithinEpsilon)(this._z,Y._z,b)&&(0,g.WithinEpsilon)(this._w,Y._w,b)}isApprox(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.e;return Y&&((0,g.WithinEpsilon)(this._x,Y._x,b)&&(0,g.WithinEpsilon)(this._y,Y._y,b)&&(0,g.WithinEpsilon)(this._z,Y._z,b)&&(0,g.WithinEpsilon)(this._w,Y._w,b)||(0,g.WithinEpsilon)(this._x,-Y._x,b)&&(0,g.WithinEpsilon)(this._y,-Y._y,b)&&(0,g.WithinEpsilon)(this._z,-Y._z,b)&&(0,g.WithinEpsilon)(this._w,-Y._w,b))}clone(){return new w(this._x,this._y,this._z,this._w)}q(Y){return this._x=Y._x,this._y=Y._y,this._z=Y._z,this._w=Y._w,this._isDirty=!0,this}Ub(Y,b,C,R){return this._x=Y,this._y=b,this._z=C,this._w=R,this._isDirty=!0,this}set(Y,b,C,R){return this.Ub(Y,b,C,R)}Gb(Y){return this.Ub(Y,Y,Y,Y)}add(Y){return new w(this._x+Y._x,this._y+Y._y,this._z+Y._z,this._w+Y._w)}addInPlace(Y){return this._x+=Y._x,this._y+=Y._y,this._z+=Y._z,this._w+=Y._w,this._isDirty=!0,this}addToRef(Y,b){return b._x=this._x+Y._x,b._y=this._y+Y._y,b._z=this._z+Y._z,b._w=this._w+Y._w,b._isDirty=!0,b}addInPlaceFromFloats(Y,b,C,R){return this._x+=Y,this._y+=b,this._z+=C,this._w+=R,this._isDirty=!0,this}subtractToRef(Y,b){return b._x=this._x-Y._x,b._y=this._y-Y._y,b._z=this._z-Y._z,b._w=this._w-Y._w,b._isDirty=!0,b}subtractFromFloats(Y,b,C,R){return this.subtractFromFloatsToRef(Y,b,C,R,new w)}subtractFromFloatsToRef(Y,b,C,R,q){return q._x=this._x-Y,q._y=this._y-b,q._z=this._z-C,q._w=this._w-R,q._isDirty=!0,q}EC(Y){return new w(this._x-Y._x,this._y-Y._y,this._z-Y._z,this._w-Y._w)}dF(Y){return this._x-=Y._x,this._y-=Y._y,this._z-=Y._z,this._w-=Y._w,this._isDirty=!0,this}scale(Y){return new w(this._x*Y,this._y*Y,this._z*Y,this._w*Y)}scaleToRef(Y,b){return b._x=this._x*Y,b._y=this._y*Y,b._z=this._z*Y,b._w=this._w*Y,b._isDirty=!0,b}scaleInPlace(Y){return this._x*=Y,this._y*=Y,this._z*=Y,this._w*=Y,this._isDirty=!0,this}scaleAndAddToRef(Y,b){return b._x+=this._x*Y,b._y+=this._y*Y,b._z+=this._z*Y,b._w+=this._w*Y,b._isDirty=!0,b}multiply(Y){const b=new w(0,0,0,1);return this.multiplyToRef(Y,b),b}multiplyToRef(Y,b){const C=this._x*Y._w+this._y*Y._z-this._z*Y._y+this._w*Y._x,R=-this._x*Y._z+this._y*Y._w+this._z*Y._x+this._w*Y._y,q=this._x*Y._y-this._y*Y._x+this._z*Y._w+this._w*Y._z,A=-this._x*Y._x-this._y*Y._y-this._z*Y._z+this._w*Y._w;return b.Ub(C,R,q,A),b}multiplyInPlace(Y){return this.multiplyToRef(Y,this)}multiplyByFloats(Y,b,C,R){return this._x*=Y,this._y*=b,this._z*=C,this._w*=R,this._isDirty=!0,this}divide(Y){throw new ReferenceError("Can not divide a quaternion")}divideToRef(Y,b){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(Y){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new w)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(Y){return Y._x=-this._x,Y._y=-this._y,Y._z=-this._z,Y._w=-this._w,Y._isDirty=!0,Y}equalsToFloats(Y,b,C,R){return this._x===Y&&this._y===b&&this._z===C&&this._w===R}floorToRef(Y){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(Y){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(Y){return Y.Ub(-this._x,-this._y,-this._z,this._w),Y}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new w(-this._x,-this._y,-this._z,this._w)}invert(){const Y=this.conjugate(),b=this.lengthSquared();return 0==b||1==b||Y.scaleInPlace(1/b),Y}invertInPlace(){this.conjugateInPlace();const Y=this.lengthSquared();return 0==Y||1==Y||this.scaleInPlace(1/Y),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Y){return 0===Y||1===Y?this:this.scaleInPlace(1/Y)}normalizeToNew(){const Y=new w(0,0,0,1);return this.normalizeToRef(Y),Y}normalizeToRef(Y){const b=this.length();return 0===b||1===b?Y.Ub(this._x,this._y,this._z,this._w):this.scaleToRef(1/b,Y)}toEulerAngles(){const Y=t.Zero();return this.toEulerAnglesToRef(Y),Y}toEulerAnglesToRef(Y){const b=this._z,C=this._x,R=this._y,q=this._w,A=R*b-C*q,E=.4999999;if(A<-E)Y._y=2*Math.atan2(R,q),Y._x=Math.PI/2,Y._z=0,Y._isDirty=!0;else if(A>E)Y._y=2*Math.atan2(R,q),Y._x=-Math.PI/2,Y._z=0,Y._isDirty=!0;else{const E=q*q,B=b*b,g=C*C,r=R*R;Y._z=Math.atan2(2*(C*R+b*q),-B-g+r+E),Y._x=Math.asin(-2*A),Y._y=Math.atan2(2*(b*C+R*q),B-g-r+E),Y._isDirty=!0}return Y}toAlphaBetaGammaToRef(Y){const b=this._z,C=this._x,R=this._y,q=this._w,A=Math.sqrt(C*C+R*R),E=Math.sqrt(b*b+q*q),B=2*Math.atan2(A,E),g=2*Math.atan2(b,q),r=2*Math.atan2(R,C),O=(g+r)/2,F=(g-r)/2;return Y.set(F,B,O),Y}toRotationMatrix(Y){return Q.FromQuaternionToRef(this,Y),Y}fromRotationMatrix(Y){return w.FromRotationMatrixToRef(Y,this),this}dot(Y){return this._x*Y._x+this._y*Y._y+this._z*Y._z+this._w*Y._w}toAxisAngle(){const Y=t.Zero();return{axis:Y,angle:this.toAxisAngleToRef(Y)}}toAxisAngleToRef(Y){let b=0;const C=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),R=this._w;return C>0?(b=2*Math.atan2(C,R),Y.set(this._x/C,this._y/C,this._z/C)):(b=0,Y.set(1,0,0)),b}static FromRotationMatrix(Y){const b=new w;return w.FromRotationMatrixToRef(Y,b),b}static FromRotationMatrixToRef(Y,b){const C=Y.m,R=C[0],q=C[4],A=C[8],E=C[1],B=C[5],g=C[9],r=C[2],O=C[6],F=C[10],y=R+B+F;let S;return y>0?(S=.5/Math.sqrt(y+1),b._w=.25/S,b._x=(O-g)*S,b._y=(A-r)*S,b._z=(E-q)*S,b._isDirty=!0):R>B&&R>F?(S=2*Math.sqrt(1+R-B-F),b._w=(O-g)/S,b._x=.25*S,b._y=(q+E)/S,b._z=(A+r)/S,b._isDirty=!0):B>F?(S=2*Math.sqrt(1+B-R-F),b._w=(A-r)/S,b._x=(q+E)/S,b._y=.25*S,b._z=(g+O)/S,b._isDirty=!0):(S=2*Math.sqrt(1+F-R-B),b._w=(E-q)/S,b._x=(A+r)/S,b._y=(g+O)/S,b._z=.25*S,b._isDirty=!0),b}static Dot(Y,b){return Y._x*b._x+Y._y*b._y+Y._z*b._z+Y._w*b._w}static AreClose(Y,b){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const R=w.Dot(Y,b);return 1-R*R<=C}static SmoothToRef(Y,b,C,R,q){let A=0===R?1:C/R;return A=(0,g.Clamp)(A,0,1),w.SlerpToRef(Y,b,A,q),q}static Zero(){return new w(0,0,0,0)}static Inverse(Y){return new w(-Y._x,-Y._y,-Y._z,Y._w)}static InverseToRef(Y,b){return b.set(-Y._x,-Y._y,-Y._z,Y._w),b}static Identity(){return new w(0,0,0,1)}static IsIdentity(Y){return Y&&0===Y._x&&0===Y._y&&0===Y._z&&1===Y._w}static RotationAxis(Y,b){return w.RotationAxisToRef(Y,b,new w)}static RotationAxisToRef(Y,b,C){C._w=Math.cos(b/2);const R=Math.sin(b/2)/Y.length();return C._x=Y._x*R,C._y=Y._y*R,C._z=Y._z*R,C._isDirty=!0,C}static OC(Y,b){return b||(b=0),new w(Y[b],Y[b+1],Y[b+2],Y[b+3])}static FromArrayToRef(Y,b,C){return C._x=Y[b],C._y=Y[b+1],C._z=Y[b+2],C._w=Y[b+3],C._isDirty=!0,C}static FromFloatsToRef(Y,b,C,R,q){return q.Ub(Y,b,C,R),q}static FromEulerAngles(Y,b,C){const R=new w;return w.RotationYawPitchRollToRef(b,Y,C,R),R}static FromEulerAnglesToRef(Y,b,C,R){return w.RotationYawPitchRollToRef(b,Y,C,R),R}static FromEulerVector(Y){const b=new w;return w.RotationYawPitchRollToRef(Y._y,Y._x,Y._z,b),b}static FromEulerVectorToRef(Y,b){return w.RotationYawPitchRollToRef(Y._y,Y._x,Y._z,b),b}static FromUnitVectorsToRef(Y,b,C){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:R.e;const A=t.Dot(Y,b)+1;return A<q?Math.abs(Y.x)>Math.abs(Y.z)?C.set(-Y.y,Y.x,0,0):C.set(0,-Y.z,Y.y,0):(t.CrossToRef(Y,b,p.AC[0]),C.set(p.AC[0].x,p.AC[0].y,p.AC[0].z,A)),C.normalize()}static RotationYawPitchRoll(Y,b,C){const R=new w;return w.RotationYawPitchRollToRef(Y,b,C,R),R}static RotationYawPitchRollToRef(Y,b,C,R){const q=.5*C,A=.5*b,E=.5*Y,B=Math.sin(q),g=Math.cos(q),r=Math.sin(A),O=Math.cos(A),F=Math.sin(E),y=Math.cos(E);return R._x=y*r*g+F*O*B,R._y=F*O*g-y*r*B,R._z=y*O*B-F*r*g,R._w=y*O*g+F*r*B,R._isDirty=!0,R}static RotationAlphaBetaGamma(Y,b,C){const R=new w;return w.RotationAlphaBetaGammaToRef(Y,b,C,R),R}static RotationAlphaBetaGammaToRef(Y,b,C,R){const q=.5*(C+Y),A=.5*(C-Y),E=.5*b;return R._x=Math.cos(A)*Math.sin(E),R._y=Math.sin(A)*Math.sin(E),R._z=Math.sin(q)*Math.cos(E),R._w=Math.cos(q)*Math.cos(E),R._isDirty=!0,R}static RotationQuaternionFromAxis(Y,b,C){const R=new w(0,0,0,0);return w.RotationQuaternionFromAxisToRef(Y,b,C,R),R}static RotationQuaternionFromAxisToRef(Y,b,C,R){const q=N.Matrix[0];return Y=Y.normalizeToRef(N.AC[0]),b=b.normalizeToRef(N.AC[1]),C=C.normalizeToRef(N.AC[2]),Q.FromXYZAxesToRef(Y,b,C,q),w.FromRotationMatrixToRef(q,R),R}static FromLookDirectionLH(Y,b){const C=new w;return w.FromLookDirectionLHToRef(Y,b,C),C}static FromLookDirectionLHToRef(Y,b,C){const R=N.Matrix[0];return Q.LookDirectionLHToRef(Y,b,R),w.FromRotationMatrixToRef(R,C),C}static FromLookDirectionRH(Y,b){const C=new w;return w.FromLookDirectionRHToRef(Y,b,C),C}static FromLookDirectionRHToRef(Y,b,C){const R=N.Matrix[0];return Q.LookDirectionRHToRef(Y,b,R),w.FromRotationMatrixToRef(R,C)}static Slerp(Y,b,C){const R=w.Identity();return w.SlerpToRef(Y,b,C,R),R}static SlerpToRef(Y,b,C,R){let q,A,E=Y._x*b._x+Y._y*b._y+Y._z*b._z+Y._w*b._w,B=!1;if(E<0&&(B=!0,E=-E),E>.999999)A=1-C,q=B?-C:C;else{const Y=Math.acos(E),b=1/Math.sin(Y);A=Math.sin((1-C)*Y)*b,q=B?-Math.sin(C*Y)*b:Math.sin(C*Y)*b}return R._x=A*Y._x+q*b._x,R._y=A*Y._y+q*b._y,R._z=A*Y._z+q*b._z,R._w=A*Y._w+q*b._w,R._isDirty=!0,R}static Hermite(Y,b,C,R,q){const A=q*q,E=q*A,B=2*E-3*A+1,g=-2*E+3*A,r=E-2*A+q,O=E-A,F=Y._x*B+C._x*g+b._x*r+R._x*O,y=Y._y*B+C._y*g+b._y*r+R._y*O,S=Y._z*B+C._z*g+b._z*r+R._z*O,n=Y._w*B+C._w*g+b._w*r+R._w*O;return new w(F,y,S,n)}static Hermite1stDerivative(Y,b,C,R,q){const A=new w;return this.Hermite1stDerivativeToRef(Y,b,C,R,q,A),A}static Hermite1stDerivativeToRef(Y,b,C,R,q,A){const E=q*q;return A._x=6*(E-q)*Y._x+(3*E-4*q+1)*b._x+6*(-E+q)*C._x+(3*E-2*q)*R._x,A._y=6*(E-q)*Y._y+(3*E-4*q+1)*b._y+6*(-E+q)*C._y+(3*E-2*q)*R._y,A._z=6*(E-q)*Y._z+(3*E-4*q+1)*b._z+6*(-E+q)*C._z+(3*E-2*q)*R._z,A._w=6*(E-q)*Y._w+(3*E-4*q+1)*b._w+6*(-E+q)*C._w+(3*E-2*q)*R._w,A._isDirty=!0,A}static Normalize(Y){const b=w.Zero();return w.NormalizeToRef(Y,b),b}static NormalizeToRef(Y,b){return Y.normalizeToRef(b),b}static Clamp(Y,b,C){const R=new w;return w.ClampToRef(Y,b,C,R),R}static ClampToRef(Y,b,C,R){return R.Ub((0,g.Clamp)(Y.x,b.x,C.x),(0,g.Clamp)(Y.y,b.y,C.y),(0,g.Clamp)(Y.z,b.z,C.z),(0,g.Clamp)(Y.w,b.w,C.w))}static Random(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new w((0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b))}static RandomToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ub((0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b),(0,g.RandomRange)(Y,b))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(Y,b){return Math.sqrt(w.DistanceSquared(Y,b))}static DistanceSquared(Y,b){const C=Y.x-b.x,R=Y.y-b.y,q=Y.z-b.z,A=Y.w-b.w;return C*C+R*R+q*q+A*A}static Center(Y,b){return w.CenterToRef(Y,b,w.Zero())}static CenterToRef(Y,b,C){return C.Ub((Y.x+b.x)/2,(Y.y+b.y)/2,(Y.z+b.z)/2,(Y.w+b.w)/2)}}w._V8PerformanceHack=new w(.5,.5,.5,.5),Object.defineProperties(w.prototype,{dimension:{value:[4]},rank:{value:1}});class Q{static get Use64Bits(){return E.c.MatrixUse64Bits}get m(){return this.Ib}markAsUpdated(){this.updateFlag=r._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(Y){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],R=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=Y,this._isIdentity3x2=Y||C,this._isIdentityDirty=!this._isIdentity&&b,this._isIdentity3x2Dirty=!this._isIdentity3x2&&R}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,E.c.MatrixTrackPrecisionChange&&E.c.MatrixTrackedMatrices.push(this),this.Ib=new E.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const Y=this.Ib;this._isIdentity=1===Y[0]&&0===Y[1]&&0===Y[2]&&0===Y[3]&&0===Y[4]&&1===Y[5]&&0===Y[6]&&0===Y[7]&&0===Y[8]&&0===Y[9]&&1===Y[10]&&0===Y[11]&&0===Y[12]&&0===Y[13]&&0===Y[14]&&1===Y[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Ib[0]||1!==this.Ib[5]||1!==this.Ib[15]||0!==this.Ib[1]||0!==this.Ib[2]||0!==this.Ib[3]||0!==this.Ib[4]||0!==this.Ib[6]||0!==this.Ib[7]||0!==this.Ib[8]||0!==this.Ib[9]||0!==this.Ib[10]||0!==this.Ib[11]||0!==this.Ib[12]||0!==this.Ib[13]||0!==this.Ib[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const Y=this.Ib,b=Y[0],C=Y[1],R=Y[2],q=Y[3],A=Y[4],E=Y[5],B=Y[6],g=Y[7],r=Y[8],O=Y[9],F=Y[10],y=Y[11],S=Y[12],n=Y[13],t=Y[14],I=Y[15],w=F*I-t*y,Q=O*I-n*y,N=O*t-n*F,p=r*I-S*y,mY=r*t-F*S,L=r*n-S*O;return b*+(E*w-B*Q+g*N)+C*-(A*w-B*p+g*mY)+R*+(A*Q-E*p+g*L)+q*-(A*N-E*mY+B*L)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!Y)return this.Ib;const C=this.Ib;for(let R=0;R<16;R++)Y[b+R]=C[R];return this}cb(){return this.Ib}ER(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(Y,b,this)}Ub(){for(var Y=arguments.length,b=new Array(Y),C=0;C<Y;C++)b[C]=arguments[C];return Q.FromArrayToRef(b,0,this)}set(){const Y=this.Ib;for(let b=0;b<16;b++)Y[b]=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}Gb(Y){const b=this.Ib;for(let C=0;C<16;C++)b[C]=Y;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return Q.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(Y){const b=new Q;return this.addToRef(Y,b),b}addToRef(Y,b){const C=this.Ib,R=b.Ib,q=Y.m;for(let A=0;A<16;A++)R[A]=C[A]+q[A];return b.markAsUpdated(),b}addToSelf(Y){const b=this.Ib,C=Y.m;return b[0]+=C[0],b[1]+=C[1],b[2]+=C[2],b[3]+=C[3],b[4]+=C[4],b[5]+=C[5],b[6]+=C[6],b[7]+=C[7],b[8]+=C[8],b[9]+=C[9],b[10]+=C[10],b[11]+=C[11],b[12]+=C[12],b[13]+=C[13],b[14]+=C[14],b[15]+=C[15],this.markAsUpdated(),this}addInPlace(Y){const b=this.Ib,C=Y.m;for(let R=0;R<16;R++)b[R]+=C[R];return this.markAsUpdated(),this}addInPlaceFromFloats(){const Y=this.Ib;for(let b=0;b<16;b++)Y[b]+=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}EC(Y){const b=this.Ib,C=Y.m;for(let R=0;R<16;R++)b[R]-=C[R];return this.markAsUpdated(),this}subtractToRef(Y,b){const C=this.Ib,R=Y.m,q=b.Ib;for(let A=0;A<16;A++)q[A]=C[A]-R[A];return b.markAsUpdated(),b}dF(Y){const b=this.Ib,C=Y.m;for(let R=0;R<16;R++)b[R]-=C[R];return this.markAsUpdated(),this}subtractFromFloats(){for(var Y=arguments.length,b=new Array(Y),C=0;C<Y;C++)b[C]=arguments[C];return this.subtractFromFloatsToRef(...b,new Q)}subtractFromFloatsToRef(){for(var Y=arguments.length,b=new Array(Y),C=0;C<Y;C++)b[C]=arguments[C];const R=b.pop(),q=this.Ib,A=R.Ib,E=b;for(let B=0;B<16;B++)A[B]=q[B]-E[B];return R.markAsUpdated(),R}invertToRef(Y){return!0===this._isIdentity?(Q.IdentityToRef(Y),Y):(y(this,Y.cb())?Y.markAsUpdated():Y.q(this),Y)}addAtIndex(Y,b){return this.Ib[Y]+=b,this.markAsUpdated(),this}multiplyAtIndex(Y,b){return this.Ib[Y]*=b,this.markAsUpdated(),this}setTranslationFromFloats(Y,b,C){return this.Ib[12]=Y,this.Ib[13]=b,this.Ib[14]=C,this.markAsUpdated(),this}addTranslationFromFloats(Y,b,C){return this.Ib[12]+=Y,this.Ib[13]+=b,this.Ib[14]+=C,this.markAsUpdated(),this}setTranslation(Y){return this.setTranslationFromFloats(Y._x,Y._y,Y._z)}getTranslation(){return new t(this.Ib[12],this.Ib[13],this.Ib[14])}getTranslationToRef(Y){return Y.x=this.Ib[12],Y.y=this.Ib[13],Y.z=this.Ib[14],Y}removeRotationAndScaling(){const Y=this.m;return Q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,Y[12],Y[13],Y[14],Y[15],this),this._updateIdentityStatus(0===Y[12]&&0===Y[13]&&0===Y[14]&&1===Y[15]),this}q(Y){Y.copyToArray(this.Ib);const b=Y;return this.updateFlag=b.updateFlag,this._updateIdentityStatus(b._isIdentity,b._isIdentityDirty,b._isIdentity3x2,b._isIdentity3x2Dirty),this}copyToArray(Y){return F(this,Y,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(Y){const b=new Q;return this.multiplyToRef(Y,b),b}multiplyInPlace(Y){const b=this.Ib,C=Y.m;for(let R=0;R<16;R++)b[R]*=C[R];return this.markAsUpdated(),this}multiplyByFloats(){const Y=this.Ib;for(let b=0;b<16;b++)Y[b]*=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var Y=arguments.length,b=new Array(Y),C=0;C<Y;C++)b[C]=arguments[C];const R=b.pop(),q=this.Ib,A=R.Ib,E=b;for(let B=0;B<16;B++)A[B]=q[B]*E[B];return R.markAsUpdated(),R}multiplyToRef(Y,b){return this._isIdentity?(b.q(Y),b):Y._isIdentity?(b.q(this),b):(this.multiplyToArray(Y,b.Ib,0),b.markAsUpdated(),b)}multiplyToArray(Y,b,C){return O(this,Y,b,C),this}divide(Y){return this.divideToRef(Y,new Q)}divideToRef(Y,b){const C=this.Ib,R=Y.m,q=b.Ib;for(let A=0;A<16;A++)q[A]=C[A]/R[A];return b.markAsUpdated(),b}divideInPlace(Y){const b=this.Ib,C=Y.m;for(let R=0;R<16;R++)b[R]/=C[R];return this.markAsUpdated(),this}minimizeInPlace(Y){const b=this.Ib,C=Y.m;for(let R=0;R<16;R++)b[R]=Math.min(b[R],C[R]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const Y=this.Ib;for(let b=0;b<16;b++)Y[b]=Math.min(Y[b],b<0||arguments.length<=b?void 0:arguments[b]);return this.markAsUpdated(),this}maximizeInPlace(Y){const b=this.Ib,C=Y.m;for(let R=0;R<16;R++)b[R]=Math.min(b[R],C[R]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const Y=this.Ib;for(let b=0;b<16;b++)Y[b]=Math.min(Y[b],b<0||arguments.length<=b?void 0:arguments[b]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new Q)}negateInPlace(){const Y=this.Ib;for(let b=0;b<16;b++)Y[b]=-Y[b];return this.markAsUpdated(),this}negateToRef(Y){const b=this.Ib,C=Y.Ib;for(let R=0;R<16;R++)C[R]=-b[R];return Y.markAsUpdated(),Y}equals(Y){const b=Y;if(!b)return!1;if((this._isIdentity||b._isIdentity)&&!this._isIdentityDirty&&!b._isIdentityDirty)return this._isIdentity&&b._isIdentity;const C=this.m,R=b.m;return C[0]===R[0]&&C[1]===R[1]&&C[2]===R[2]&&C[3]===R[3]&&C[4]===R[4]&&C[5]===R[5]&&C[6]===R[6]&&C[7]===R[7]&&C[8]===R[8]&&C[9]===R[9]&&C[10]===R[10]&&C[11]===R[11]&&C[12]===R[12]&&C[13]===R[13]&&C[14]===R[14]&&C[15]===R[15]}equalsWithEpsilon(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this.Ib,R=Y.m;for(let q=0;q<16;q++)if(!(0,g.WithinEpsilon)(C[q],R[q],b))return!1;return!0}equalsToFloats(){const Y=this.Ib;for(let b=0;b<16;b++)if(Y[b]!=(b<0||arguments.length<=b?void 0:arguments[b]))return!1;return!0}floor(){return this.floorToRef(new Q)}floorToRef(Y){const b=this.Ib,C=Y.Ib;for(let R=0;R<16;R++)C[R]=Math.floor(b[R]);return Y.markAsUpdated(),Y}fract(){return this.fractToRef(new Q)}fractToRef(Y){const b=this.Ib,C=Y.Ib;for(let R=0;R<16;R++)C[R]=b[R]-Math.floor(b[R]);return Y.markAsUpdated(),Y}clone(){const Y=new Q;return Y.q(this),Y}getClassName(){return"Matrix"}getHashCode(){let Y=S(this.Ib[0]);for(let b=1;b<16;b++)Y=397*Y^S(this.Ib[b]);return Y}decomposeToTransformNode(Y){return Y.rotationQuaternion=Y.rotationQuaternion||new w,this.decompose(Y.ob,Y.rotationQuaternion,Y.position)}decompose(Y,b,C,R){let q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return C&&C.Gb(0),Y&&Y.Gb(1),b&&b.Ub(0,0,0,1),!0;const A=this.Ib;if(C&&C.Ub(A[12],A[13],A[14]),(Y=Y||N.AC[0]).x=Math.sqrt(A[0]*A[0]+A[1]*A[1]+A[2]*A[2]),Y.y=Math.sqrt(A[4]*A[4]+A[5]*A[5]+A[6]*A[6]),Y.z=Math.sqrt(A[8]*A[8]+A[9]*A[9]+A[10]*A[10]),R){const b=(q?R.absoluteScaling.x:R.ob.x)<0?-1:1,C=(q?R.absoluteScaling.y:R.ob.y)<0?-1:1,A=(q?R.absoluteScaling.z:R.ob.z)<0?-1:1;Y.x*=b,Y.y*=C,Y.z*=A}else this.determinant()<=0&&(Y.y*=-1);if(0===Y._x||0===Y._y||0===Y._z)return b&&b.Ub(0,0,0,1),!1;if(b){const C=1/Y._x,R=1/Y._y,q=1/Y._z;Q.FromValuesToRef(A[0]*C,A[1]*C,A[2]*C,0,A[4]*R,A[5]*R,A[6]*R,0,A[8]*q,A[9]*q,A[10]*q,0,0,0,0,1,N.Matrix[0]),w.FromRotationMatrixToRef(N.Matrix[0],b)}return!0}getRow(Y){if(Y<0||Y>3)return null;const b=4*Y;return new I(this.Ib[b+0],this.Ib[b+1],this.Ib[b+2],this.Ib[b+3])}getRowToRef(Y,b){if(Y>=0&&Y<=3){const C=4*Y;b.x=this.Ib[C+0],b.y=this.Ib[C+1],b.z=this.Ib[C+2],b.w=this.Ib[C+3]}return b}setRow(Y,b){return this.setRowFromFloats(Y,b.x,b.y,b.z,b.w)}transpose(){const Y=new Q;return Q.TransposeToRef(this,Y),Y}transposeToRef(Y){return Q.TransposeToRef(this,Y),Y}setRowFromFloats(Y,b,C,R,q){if(Y<0||Y>3)return this;const A=4*Y;return this.Ib[A+0]=b,this.Ib[A+1]=C,this.Ib[A+2]=R,this.Ib[A+3]=q,this.markAsUpdated(),this}scale(Y){const b=new Q;return this.scaleToRef(Y,b),b}scaleToRef(Y,b){for(let C=0;C<16;C++)b.Ib[C]=this.Ib[C]*Y;return b.markAsUpdated(),b}scaleAndAddToRef(Y,b){for(let C=0;C<16;C++)b.Ib[C]+=this.Ib[C]*Y;return b.markAsUpdated(),b}scaleInPlace(Y){const b=this.Ib;for(let C=0;C<16;C++)b[C]*=Y;return this.markAsUpdated(),this}toNormalMatrix(Y){const b=N.Matrix[0];this.invertToRef(b),b.transposeToRef(Y);const C=Y.Ib;return Q.FromValuesToRef(C[0],C[1],C[2],0,C[4],C[5],C[6],0,C[8],C[9],C[10],0,0,0,0,1,Y),Y}getRotationMatrix(){const Y=new Q;return this.getRotationMatrixToRef(Y),Y}getRotationMatrixToRef(Y){const b=N.AC[0];if(!this.decompose(b))return Q.IdentityToRef(Y),Y;const C=this.Ib,R=1/b._x,q=1/b._y,A=1/b._z;return Q.FromValuesToRef(C[0]*R,C[1]*R,C[2]*R,0,C[4]*q,C[5]*q,C[6]*q,0,C[8]*A,C[9]*A,C[10]*A,0,0,0,0,1,Y),Y}toggleModelMatrixHandInPlace(){const Y=this.Ib;return Y[2]*=-1,Y[6]*=-1,Y[8]*=-1,Y[9]*=-1,Y[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const Y=this.Ib;return Y[8]*=-1,Y[9]*=-1,Y[10]*=-1,Y[11]*=-1,this.markAsUpdated(),this}static OC(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=new Q;return Q.FromArrayToRef(Y,b,C),C}static FromArrayToRef(Y,b,C){for(let R=0;R<16;R++)C.Ib[R]=Y[R+b];return C.markAsUpdated(),C}static FromFloat32ArrayToRefScaled(Y,b,C,R){return R.Ib[0]=Y[0+b]*C,R.Ib[1]=Y[1+b]*C,R.Ib[2]=Y[2+b]*C,R.Ib[3]=Y[3+b]*C,R.Ib[4]=Y[4+b]*C,R.Ib[5]=Y[5+b]*C,R.Ib[6]=Y[6+b]*C,R.Ib[7]=Y[7+b]*C,R.Ib[8]=Y[8+b]*C,R.Ib[9]=Y[9+b]*C,R.Ib[10]=Y[10+b]*C,R.Ib[11]=Y[11+b]*C,R.Ib[12]=Y[12+b]*C,R.Ib[13]=Y[13+b]*C,R.Ib[14]=Y[14+b]*C,R.Ib[15]=Y[15+b]*C,R.markAsUpdated(),R}static get IdentityReadOnly(){return Q._IdentityReadOnly}static FromValuesToRef(Y,b,C,R,q,A,E,B,g,r,O,F,y,S,n,t,I){const w=I.Ib;w[0]=Y,w[1]=b,w[2]=C,w[3]=R,w[4]=q,w[5]=A,w[6]=E,w[7]=B,w[8]=g,w[9]=r,w[10]=O,w[11]=F,w[12]=y,w[13]=S,w[14]=n,w[15]=t,I.markAsUpdated()}static FromValues(Y,b,C,R,q,A,E,B,g,r,O,F,y,S,n,t){const I=new Q,w=I.Ib;return w[0]=Y,w[1]=b,w[2]=C,w[3]=R,w[4]=q,w[5]=A,w[6]=E,w[7]=B,w[8]=g,w[9]=r,w[10]=O,w[11]=F,w[12]=y,w[13]=S,w[14]=n,w[15]=t,I.markAsUpdated(),I}static Compose(Y,b,C){const R=new Q;return Q.ComposeToRef(Y,b,C,R),R}static ComposeToRef(Y,b,C,R){const q=R.Ib,A=b._x,E=b._y,B=b._z,g=b._w,r=A+A,O=E+E,F=B+B,y=A*r,S=A*O,n=A*F,t=E*O,I=E*F,w=B*F,Q=g*r,N=g*O,p=g*F,mY=Y._x,L=Y._y,u=Y._z;return q[0]=(1-(t+w))*mY,q[1]=(S+p)*mY,q[2]=(n-N)*mY,q[3]=0,q[4]=(S-p)*L,q[5]=(1-(y+w))*L,q[6]=(I+Q)*L,q[7]=0,q[8]=(n+N)*u,q[9]=(I-Q)*u,q[10]=(1-(y+t))*u,q[11]=0,q[12]=C._x,q[13]=C._y,q[14]=C._z,q[15]=1,R.markAsUpdated(),R}static Identity(){const Y=Q.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return Y._updateIdentityStatus(!0),Y}static IdentityToRef(Y){return Q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,Y),Y._updateIdentityStatus(!0),Y}static Zero(){const Y=Q.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return Y._updateIdentityStatus(!1),Y}static RotationX(Y){const b=new Q;return Q.RotationXToRef(Y,b),b}static Invert(Y){const b=new Q;return Y.invertToRef(b),b}static RotationXToRef(Y,b){const C=Math.sin(Y),R=Math.cos(Y);return Q.FromValuesToRef(1,0,0,0,0,R,C,0,0,-C,R,0,0,0,0,1,b),b._updateIdentityStatus(1===R&&0===C),b}static RotationY(Y){const b=new Q;return Q.RotationYToRef(Y,b),b}static RotationYToRef(Y,b){const C=Math.sin(Y),R=Math.cos(Y);return Q.FromValuesToRef(R,0,-C,0,0,1,0,0,C,0,R,0,0,0,0,1,b),b._updateIdentityStatus(1===R&&0===C),b}static RotationZ(Y){const b=new Q;return Q.RotationZToRef(Y,b),b}static RotationZToRef(Y,b){const C=Math.sin(Y),R=Math.cos(Y);return Q.FromValuesToRef(R,C,0,0,-C,R,0,0,0,0,1,0,0,0,0,1,b),b._updateIdentityStatus(1===R&&0===C),b}static RotationAxis(Y,b){const C=new Q;return Q.RotationAxisToRef(Y,b,C),C}static RotationAxisToRef(Y,b,C){const R=Math.sin(-b),q=Math.cos(-b),A=1-q;Y=Y.normalizeToRef(N.AC[0]);const E=C.Ib;return E[0]=Y._x*Y._x*A+q,E[1]=Y._x*Y._y*A-Y._z*R,E[2]=Y._x*Y._z*A+Y._y*R,E[3]=0,E[4]=Y._y*Y._x*A+Y._z*R,E[5]=Y._y*Y._y*A+q,E[6]=Y._y*Y._z*A-Y._x*R,E[7]=0,E[8]=Y._z*Y._x*A-Y._y*R,E[9]=Y._z*Y._y*A+Y._x*R,E[10]=Y._z*Y._z*A+q,E[11]=0,E[12]=0,E[13]=0,E[14]=0,E[15]=1,C.markAsUpdated(),C}static RotationAlignToRef(Y,b,C){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const A=t.Dot(b,Y),E=C.Ib;if(A<-1+R.e)E[0]=-1,E[1]=0,E[2]=0,E[3]=0,E[4]=0,E[5]=q?1:-1,E[6]=0,E[7]=0,E[8]=0,E[9]=0,E[10]=q?-1:1,E[11]=0;else{const C=t.Cross(b,Y),R=1/(1+A);E[0]=C._x*C._x*R+A,E[1]=C._y*C._x*R-C._z,E[2]=C._z*C._x*R+C._y,E[3]=0,E[4]=C._x*C._y*R+C._z,E[5]=C._y*C._y*R+A,E[6]=C._z*C._y*R-C._x,E[7]=0,E[8]=C._x*C._z*R-C._y,E[9]=C._y*C._z*R+C._x,E[10]=C._z*C._z*R+A,E[11]=0}return E[12]=0,E[13]=0,E[14]=0,E[15]=1,C.markAsUpdated(),C}static RotationYawPitchRoll(Y,b,C){const R=new Q;return Q.RotationYawPitchRollToRef(Y,b,C,R),R}static RotationYawPitchRollToRef(Y,b,C,R){return w.RotationYawPitchRollToRef(Y,b,C,N.Quaternion[0]),N.Quaternion[0].toRotationMatrix(R),R}static Scaling(Y,b,C){const R=new Q;return Q.ScalingToRef(Y,b,C,R),R}static ScalingToRef(Y,b,C,R){return Q.FromValuesToRef(Y,0,0,0,0,b,0,0,0,0,C,0,0,0,0,1,R),R._updateIdentityStatus(1===Y&&1===b&&1===C),R}static Translation(Y,b,C){const R=new Q;return Q.TranslationToRef(Y,b,C,R),R}static TranslationToRef(Y,b,C,R){return Q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,Y,b,C,1,R),R._updateIdentityStatus(0===Y&&0===b&&0===C),R}static Lerp(Y,b,C){const R=new Q;return Q.LerpToRef(Y,b,C,R),R}static LerpToRef(Y,b,C,R){const q=R.Ib,A=Y.m,E=b.m;for(let B=0;B<16;B++)q[B]=A[B]*(1-C)+E[B]*C;return R.markAsUpdated(),R}static DecomposeLerp(Y,b,C){const R=new Q;return Q.DecomposeLerpToRef(Y,b,C,R),R}static DecomposeLerpToRef(Y,b,C,R){const q=N.AC[0],A=N.Quaternion[0],E=N.AC[1];Y.decompose(q,A,E);const B=N.AC[2],g=N.Quaternion[1],r=N.AC[3];b.decompose(B,g,r);const O=N.AC[4];t.LerpToRef(q,B,C,O);const F=N.Quaternion[2];w.SlerpToRef(A,g,C,F);const y=N.AC[5];return t.LerpToRef(E,r,C,y),Q.ComposeToRef(O,F,y,R),R}static LookAtLH(Y,b,C){const R=new Q;return Q.LookAtLHToRef(Y,b,C,R),R}static LookAtLHToRef(Y,b,C,R){const q=N.AC[0],A=N.AC[1],E=N.AC[2];b.subtractToRef(Y,E),E.normalize(),t.CrossToRef(C,E,q);const B=q.lengthSquared();0===B?q.x=1:q.normalizeFromLength(Math.sqrt(B)),t.CrossToRef(E,q,A),A.normalize();const g=-t.Dot(q,Y),r=-t.Dot(A,Y),O=-t.Dot(E,Y);return Q.FromValuesToRef(q._x,A._x,E._x,0,q._y,A._y,E._y,0,q._z,A._z,E._z,0,g,r,O,1,R),R}static LookAtRH(Y,b,C){const R=new Q;return Q.LookAtRHToRef(Y,b,C,R),R}static LookAtRHToRef(Y,b,C,R){const q=N.AC[0],A=N.AC[1],E=N.AC[2];Y.subtractToRef(b,E),E.normalize(),t.CrossToRef(C,E,q);const B=q.lengthSquared();0===B?q.x=1:q.normalizeFromLength(Math.sqrt(B)),t.CrossToRef(E,q,A),A.normalize();const g=-t.Dot(q,Y),r=-t.Dot(A,Y),O=-t.Dot(E,Y);return Q.FromValuesToRef(q._x,A._x,E._x,0,q._y,A._y,E._y,0,q._z,A._z,E._z,0,g,r,O,1,R),R}static LookDirectionLH(Y,b){const C=new Q;return Q.LookDirectionLHToRef(Y,b,C),C}static LookDirectionLHToRef(Y,b,C){const R=N.AC[0];R.q(Y),R.scaleInPlace(-1);const q=N.AC[1];return t.CrossToRef(b,R,q),Q.FromValuesToRef(q._x,q._y,q._z,0,b._x,b._y,b._z,0,R._x,R._y,R._z,0,0,0,0,1,C),C}static LookDirectionRH(Y,b){const C=new Q;return Q.LookDirectionRHToRef(Y,b,C),C}static LookDirectionRHToRef(Y,b,C){const R=N.AC[2];return t.CrossToRef(b,Y,R),Q.FromValuesToRef(R._x,R._y,R._z,0,b._x,b._y,b._z,0,Y._x,Y._y,Y._z,0,0,0,0,1,C),C}static OrthoLH(Y,b,C,R,q){const A=new Q;return Q.OrthoLHToRef(Y,b,C,R,A,q),A}static OrthoLHToRef(Y,b,C,R,q,A){const E=2/Y,B=2/b,g=2/(R-C),r=-(R+C)/(R-C);return Q.FromValuesToRef(E,0,0,0,0,B,0,0,0,0,g,0,0,0,r,1,q),A&&q.multiplyToRef(mY,q),q._updateIdentityStatus(1===E&&1===B&&1===g&&0===r),q}static OrthoOffCenterLH(Y,b,C,R,q,A,E){const B=new Q;return Q.OrthoOffCenterLHToRef(Y,b,C,R,q,A,B,E),B}static OrthoOffCenterLHToRef(Y,b,C,R,q,A,E,B){const g=2/(b-Y),r=2/(R-C),O=2/(A-q),F=-(A+q)/(A-q),y=(Y+b)/(Y-b),S=(R+C)/(C-R);return Q.FromValuesToRef(g,0,0,0,0,r,0,0,0,0,O,0,y,S,F,1,E),B&&E.multiplyToRef(mY,E),E.markAsUpdated(),E}static ObliqueOffCenterLHToRef(Y,b,C,R,q,A,E,B,g,r,O){const F=-E*Math.cos(B),y=-E*Math.sin(B);return Q.TranslationToRef(0,0,-g,N.Matrix[1]),Q.FromValuesToRef(1,0,0,0,0,1,0,0,F,y,1,0,0,0,0,1,N.Matrix[0]),N.Matrix[1].multiplyToRef(N.Matrix[0],N.Matrix[0]),Q.TranslationToRef(0,0,g,N.Matrix[1]),N.Matrix[0].multiplyToRef(N.Matrix[1],N.Matrix[0]),Q.OrthoOffCenterLHToRef(Y,b,C,R,q,A,r,O),N.Matrix[0].multiplyToRef(r,r),r}static OrthoOffCenterRH(Y,b,C,R,q,A,E){const B=new Q;return Q.OrthoOffCenterRHToRef(Y,b,C,R,q,A,B,E),B}static OrthoOffCenterRHToRef(Y,b,C,R,q,A,E,B){return Q.OrthoOffCenterLHToRef(Y,b,C,R,q,A,E,B),E.Ib[10]*=-1,E}static ObliqueOffCenterRHToRef(Y,b,C,R,q,A,E,B,g,r,O){const F=E*Math.cos(B),y=E*Math.sin(B);return Q.TranslationToRef(0,0,g,N.Matrix[1]),Q.FromValuesToRef(1,0,0,0,0,1,0,0,F,y,1,0,0,0,0,1,N.Matrix[0]),N.Matrix[1].multiplyToRef(N.Matrix[0],N.Matrix[0]),Q.TranslationToRef(0,0,-g,N.Matrix[1]),N.Matrix[0].multiplyToRef(N.Matrix[1],N.Matrix[0]),Q.OrthoOffCenterRHToRef(Y,b,C,R,q,A,r,O),N.Matrix[0].multiplyToRef(r,r),r}static PerspectiveLH(Y,b,C,R,q){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const E=new Q,B=2*C/Y,g=2*C/b,r=(R+C)/(R-C),O=-2*R*C/(R-C),F=Math.tan(A);return Q.FromValuesToRef(B,0,0,0,0,g,0,F,0,0,r,1,0,0,O,0,E),q&&E.multiplyToRef(mY,E),E._updateIdentityStatus(!1),E}static PerspectiveFovLH(Y,b,C,R,q){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,E=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const B=new Q;return Q.PerspectiveFovLHToRef(Y,b,C,R,B,!0,q,A,E),B}static PerspectiveFovLHToRef(Y,b,C,R,q){let A=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],E=arguments.length>6?arguments[6]:void 0,B=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,g=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const r=C,O=R,F=1/Math.tan(.5*Y),y=A?F/b:F,S=A?F:F*b,n=g&&0===r?-1:0!==O?(O+r)/(O-r):1,t=g&&0===r?2*O:0!==O?-2*O*r/(O-r):-2*r,I=Math.tan(B);return Q.FromValuesToRef(y,0,0,0,0,S,0,I,0,0,n,1,0,0,t,0,q),E&&q.multiplyToRef(mY,q),q._updateIdentityStatus(!1),q}static PerspectiveFovReverseLHToRef(Y,b,C,R,q){let A=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],E=arguments.length>6?arguments[6]:void 0,B=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const g=1/Math.tan(.5*Y),r=A?g/b:g,O=A?g:g*b,F=Math.tan(B);return Q.FromValuesToRef(r,0,0,0,0,O,0,F,0,0,-C,1,0,0,1,0,q),E&&q.multiplyToRef(mY,q),q._updateIdentityStatus(!1),q}static PerspectiveFovRH(Y,b,C,R,q){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,E=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const B=new Q;return Q.PerspectiveFovRHToRef(Y,b,C,R,B,!0,q,A,E),B}static PerspectiveFovRHToRef(Y,b,C,R,q){let A=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],E=arguments.length>6?arguments[6]:void 0,B=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,g=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const r=C,O=R,F=1/Math.tan(.5*Y),y=A?F/b:F,S=A?F:F*b,n=g&&0===r?1:0!==O?-(O+r)/(O-r):-1,t=g&&0===r?2*O:0!==O?-2*O*r/(O-r):-2*r,I=Math.tan(B);return Q.FromValuesToRef(y,0,0,0,0,S,0,I,0,0,n,-1,0,0,t,0,q),E&&q.multiplyToRef(mY,q),q._updateIdentityStatus(!1),q}static PerspectiveFovReverseRHToRef(Y,b,C,R,q){let A=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],E=arguments.length>6?arguments[6]:void 0,B=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const g=1/Math.tan(.5*Y),r=A?g/b:g,O=A?g:g*b,F=Math.tan(B);return Q.FromValuesToRef(r,0,0,0,0,O,0,F,0,0,-C,-1,0,0,-1,0,q),E&&q.multiplyToRef(mY,q),q._updateIdentityStatus(!1),q}static GetFinalMatrix(Y,b,C,R,q,A){const E=Y.width,B=Y.height,g=Y.x,r=Y.y,O=Q.FromValues(E/2,0,0,0,0,-B/2,0,0,0,0,A-q,0,g+E/2,B/2+r,q,1),F=new Q;return b.multiplyToRef(C,F),F.multiplyToRef(R,F),F.multiplyToRef(O,F)}static GetAsMatrix2x2(Y){const b=Y.m,C=[b[0],b[1],b[4],b[5]];return E.c.MatrixUse64Bits?C:new Float32Array(C)}static GetAsMatrix3x3(Y){const b=Y.m,C=[b[0],b[1],b[2],b[4],b[5],b[6],b[8],b[9],b[10]];return E.c.MatrixUse64Bits?C:new Float32Array(C)}static Transpose(Y){const b=new Q;return Q.TransposeToRef(Y,b),b}static TransposeToRef(Y,b){const C=Y.m,R=C[0],q=C[4],A=C[8],E=C[12],B=C[1],g=C[5],r=C[9],O=C[13],F=C[2],y=C[6],S=C[10],n=C[14],t=C[3],I=C[7],w=C[11],Q=C[15],N=b.Ib;return N[0]=R,N[1]=q,N[2]=A,N[3]=E,N[4]=B,N[5]=g,N[6]=r,N[7]=O,N[8]=F,N[9]=y,N[10]=S,N[11]=n,N[12]=t,N[13]=I,N[14]=w,N[15]=Q,b.markAsUpdated(),b._updateIdentityStatus(Y._isIdentity,Y._isIdentityDirty),b}static Reflection(Y){const b=new Q;return Q.ReflectionToRef(Y,b),b}static ReflectionToRef(Y,b){Y.normalize();const C=Y.normal.x,R=Y.normal.y,q=Y.normal.z,A=-2*C,E=-2*R,B=-2*q;return Q.FromValuesToRef(A*C+1,E*C,B*C,0,A*R,E*R+1,B*R,0,A*q,E*q,B*q+1,0,A*Y.d,E*Y.d,B*Y.d,1,b),b}static FromXYZAxesToRef(Y,b,C,R){return Q.FromValuesToRef(Y._x,Y._y,Y._z,0,b._x,b._y,b._z,0,C._x,C._y,C._z,0,0,0,0,1,R),R}static FromQuaternionToRef(Y,b){const C=Y._x*Y._x,R=Y._y*Y._y,q=Y._z*Y._z,A=Y._x*Y._y,E=Y._z*Y._w,B=Y._z*Y._x,g=Y._y*Y._w,r=Y._y*Y._z,O=Y._x*Y._w;return b.Ib[0]=1-2*(R+q),b.Ib[1]=2*(A+E),b.Ib[2]=2*(B-g),b.Ib[3]=0,b.Ib[4]=2*(A-E),b.Ib[5]=1-2*(q+C),b.Ib[6]=2*(r+O),b.Ib[7]=0,b.Ib[8]=2*(B+g),b.Ib[9]=2*(r-O),b.Ib[10]=1-2*(R+C),b.Ib[11]=0,b.Ib[12]=0,b.Ib[13]=0,b.Ib[14]=0,b.Ib[15]=1,b.markAsUpdated(),b}}Q._IdentityReadOnly=Q.Identity(),Object.defineProperties(Q.prototype,{dimension:{value:[4,4]},rank:{value:2}});class N{}N.AC=(0,q.g)(11,t.Zero),N.Matrix=(0,q.g)(2,Q.Identity),N.Quaternion=(0,q.g)(3,w.Zero);class p{}p.Vector2=(0,q.g)(3,n.Zero),p.AC=(0,q.g)(13,t.Zero),p.Vector4=(0,q.g)(3,I.Zero),p.Quaternion=(0,q.g)(3,w.Zero),p.Matrix=(0,q.g)(8,Q.Identity),(0,A.g)("BABYLON.Vector2",n),(0,A.g)("BABYLON.Vector3",t),(0,A.g)("BABYLON.Vector4",I),(0,A.g)("BABYLON.Matrix",Q);const mY=Q.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12846:(Y,b,C)=>{function R(Y,b){const C=[];for(let R=0;R<Y;++R)C.push(b());return C}function q(Y,b){return R(Y,b)}C.d(b,{e:()=>R,g:()=>q,h:()=>E});const A=["push","splice","pop","shift","unshift"];function E(Y,b){const C=A.map((C=>function(Y,b,C){const R=Y[b];if("function"!==typeof R)return null;const q=function(){const R=Y.length,A=q.previous.apply(Y,arguments);return C(b,R),A};return R.next=q,q.previous=R,Y[b]=q,()=>{const C=q.previous;if(!C)return;const R=q.next;R?(C.next=R,R.previous=C):(C.next=void 0,Y[b]=C),q.next=void 0,q.previous=void 0}}(Y,C,b)));return()=>{for(const Y of C)null===Y||void 0===Y||Y()}}}}]);