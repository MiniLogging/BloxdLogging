"use strict";(self["9x1utqq1axc"]=self["9x1utqq1axc"]||[]).push([[14],{12330:(y,c,A)=>{A.d(c,{b:()=>p,e:()=>N,g:()=>l,j:()=>w});const l=1/2.2,w=2.2,N=(1+Math.sqrt(5))/2,p=.001},12340:(y,c,A)=>{function l(y){return parseInt(y.toString().replace(/\W/g,""))}function w(y,c){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(y-c)<=A}function N(y,c,A){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return y<c-l||y>A+l}function p(y,c){return y===c?y:Math.random()*(c-y)+y}function W(y,c,A){return y+(c-y)*A}function h(y,c,A){let l=P(c-y,360);return l>180&&(l-=360),y+l*O(A)}function I(y,c,A){let l=0;return l=y!=c?O((A-y)/(c-y)):0,l}function q(y,c,A,l,w){const N=w*w,p=w*N;return y*(2*p-3*N+1)+A*(-2*p+3*N)+c*(p-2*N+w)+l*(p-N)}function o(y,c,A,l,w){const N=w*w;return 6*(N-w)*y+(3*N-4*w+1)*c+6*(-N+w)*A+(3*N-2*w)*l}function O(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(A,Math.max(c,y))}function L(y){return y-=2*Math.PI*Math.floor((y+Math.PI)/(2*Math.PI))}function i(y){const c=y.toString(16);return y<=15?("0"+c).toUpperCase():c.toUpperCase()}function H(y){if(Math.log2)return Math.floor(Math.log2(y));if(y<0)return NaN;if(0===y)return-1/0;let c=0;if(y<1){for(;y<1;)c++,y*=2;c=-c}else if(y>1)for(;y>1;)c++,y=Math.floor(y/2);return c}function P(y,c){return y-Math.floor(y/c)*c}function D(y,c,A){return(y-c)/(A-c)}function t(y,c,A){return y*(A-c)+c}function s(y,c){let A=P(c-y,360);return A>180&&(A-=360),A}function B(y,c){const A=P(y,2*c);return c-Math.abs(A-c)}function X(y,c,A){let l=O(A);return l=-2*l*l*l+3*l*l,c*l+y*(1-l)}function C(y,c,A){let l=0;return l=Math.abs(c-y)<=A?c:y+Math.sign(c-y)*A,l}function K(y,c,A){const l=s(y,c);let w=0;return w=-A<l&&l<A?c:C(y,c=y+l,A),w}function my(y,c,A){return(y-c)/(A-c)}function T(y,c,A){return(A-c)*y+c}function z(y,c){const A=y%c;return 0===A?c:z(c,A)}A.r(c),A.d(c,{Clamp:()=>O,DeltaAngle:()=>s,Denormalize:()=>t,ExtractAsInt:()=>l,Hermite:()=>q,Hermite1stDerivative:()=>o,HighestCommonFactor:()=>z,ILog2:()=>H,InverseLerp:()=>I,Lerp:()=>W,LerpAngle:()=>h,MoveTowards:()=>C,MoveTowardsAngle:()=>K,Normalize:()=>D,NormalizeRadians:()=>L,OutsideRange:()=>N,PercentToRange:()=>T,PingPong:()=>B,RandomRange:()=>p,RangeToPercent:()=>my,Repeat:()=>P,SmoothStep:()=>X,ToHex:()=>i,WithinEpsilon:()=>w})},12325:(y,c,A)=>{A.r(c),A.d(c,{Matrix:()=>t,Quaternion:()=>D,TmpVectors:()=>B,Vector2:()=>i,gc:()=>H,Vector4:()=>P});var l=A(12330),w=A(12337),N=A(12283),p=A(12251),W=A(12184),h=A(12340);class I{}function q(y,c,A){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const w=y.fc(),N=c.fc(),p=w[0],W=w[1],h=w[2],I=w[3],q=w[4],o=w[5],O=w[6],L=w[7],i=w[8],H=w[9],P=w[10],D=w[11],t=w[12],s=w[13],B=w[14],X=w[15],C=N[0],K=N[1],my=N[2],T=N[3],z=N[4],S=N[5],M=N[6],k=N[7],a=N[8],u=N[9],G=N[10],j=N[11],f=N[12],V=N[13],J=N[14],U=N[15];A[l]=p*C+W*z+h*a+I*f,A[l+1]=p*K+W*S+h*u+I*V,A[l+2]=p*my+W*M+h*G+I*J,A[l+3]=p*T+W*k+h*j+I*U,A[l+4]=q*C+o*z+O*a+L*f,A[l+5]=q*K+o*S+O*u+L*V,A[l+6]=q*my+o*M+O*G+L*J,A[l+7]=q*T+o*k+O*j+L*U,A[l+8]=i*C+H*z+P*a+D*f,A[l+9]=i*K+H*S+P*u+D*V,A[l+10]=i*my+H*M+P*G+D*J,A[l+11]=i*T+H*k+P*j+D*U,A[l+12]=t*C+s*z+B*a+X*f,A[l+13]=t*K+s*S+B*u+X*V,A[l+14]=t*my+s*M+B*G+X*J,A[l+15]=t*T+s*k+B*j+X*U}function o(y,c){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const l=y.fc();c[A]=l[0],c[A+1]=l[1],c[A+2]=l[2],c[A+3]=l[3],c[A+4]=l[4],c[A+5]=l[5],c[A+6]=l[6],c[A+7]=l[7],c[A+8]=l[8],c[A+9]=l[9],c[A+10]=l[10],c[A+11]=l[11],c[A+12]=l[12],c[A+13]=l[13],c[A+14]=l[14],c[A+15]=l[15]}function O(y,c){const A=y.fc(),l=A[0],w=A[1],N=A[2],p=A[3],W=A[4],h=A[5],I=A[6],q=A[7],o=A[8],O=A[9],L=A[10],i=A[11],H=A[12],P=A[13],D=A[14],t=A[15],s=L*t-D*i,B=O*t-P*i,X=O*D-P*L,C=o*t-H*i,K=o*D-L*H,my=o*P-H*O,T=+(h*s-I*B+q*X),z=-(W*s-I*C+q*K),S=+(W*B-h*C+q*my),M=-(W*X-h*K+I*my),k=l*T+w*z+N*S+p*M;if(0===k)return!1;const a=1/k,u=I*t-D*q,G=h*t-P*q,j=h*D-P*I,f=W*t-H*q,V=W*D-H*I,J=W*P-H*h,U=I*i-L*q,e=h*i-O*q,Q=h*L-O*I,Y=W*i-o*q,g=W*L-o*I,x=W*O-o*h,F=-(w*s-N*B+p*X),R=+(l*s-N*C+p*K),r=-(l*B-w*C+p*my),n=+(l*X-w*K+N*my),E=+(w*u-N*G+p*j),b=-(l*u-N*f+p*V),Z=+(l*G-w*f+p*J),v=-(l*j-w*V+N*J),d=-(w*U-N*e+p*Q),yy=+(l*U-N*Y+p*g),cy=-(l*e-w*Y+p*x),Ay=+(l*Q-w*g+N*x);return c[0]=T*a,c[1]=F*a,c[2]=E*a,c[3]=d*a,c[4]=z*a,c[5]=R*a,c[6]=b*a,c[7]=yy*a,c[8]=S*a,c[9]=r*a,c[10]=Z*a,c[11]=cy*a,c[12]=M*a,c[13]=n*a,c[14]=v*a,c[15]=Ay*a,!0}I._UpdateFlagSeed=0;const L=y=>parseInt(y.toString().replace(/\W/g,""));class i{constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=y,this.y=c}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let y=L(this.x);return y=397*y^L(this.y),y}toArray(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y[c]=this.x,y[c+1]=this.y,this}nA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return i.FromArrayToRef(y,c,this),this}fc(){return[this.x,this.y]}p(y){return this.x=y.x,this.y=y.y,this}Ec(y,c){return this.x=y,this.y=c,this}set(y,c){return this.Ec(y,c)}vc(y){return this.Ec(y,y)}add(y){return new i(this.x+y.x,this.y+y.y)}addToRef(y,c){return c.x=this.x+y.x,c.y=this.y+y.y,c}addInPlace(y){return this.x+=y.x,this.y+=y.y,this}addInPlaceFromFloats(y,c){return this.x+=y,this.y+=c,this}addVector3(y){return new i(this.x+y.x,this.y+y.y)}xc(y){return new i(this.x-y.x,this.y-y.y)}subtractToRef(y,c){return c.x=this.x-y.x,c.y=this.y-y.y,c}uo(y){return this.x-=y.x,this.y-=y.y,this}multiplyInPlace(y){return this.x*=y.x,this.y*=y.y,this}multiply(y){return new i(this.x*y.x,this.y*y.y)}multiplyToRef(y,c){return c.x=this.x*y.x,c.y=this.y*y.y,c}multiplyByFloats(y,c){return new i(this.x*y,this.y*c)}divide(y){return new i(this.x/y.x,this.y/y.y)}divideToRef(y,c){return c.x=this.x/y.x,c.y=this.y/y.y,c}divideInPlace(y){return this.x=this.x/y.x,this.y=this.y/y.y,this}minimizeInPlace(y){return this.minimizeInPlaceFromFloats(y.x,y.y)}maximizeInPlace(y){return this.maximizeInPlaceFromFloats(y.x,y.y)}minimizeInPlaceFromFloats(y,c){return this.x=Math.min(y,this.x),this.y=Math.min(c,this.y),this}maximizeInPlaceFromFloats(y,c){return this.x=Math.max(y,this.x),this.y=Math.max(c,this.y),this}subtractFromFloats(y,c){return new i(this.x-y,this.y-c)}subtractFromFloatsToRef(y,c,A){return A.x=this.x-y,A.y=this.y-c,A}negate(){return new i(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(y){return y.x=-this.x,y.y=-this.y,y}scaleInPlace(y){return this.x*=y,this.y*=y,this}scale(y){return new i(this.x*y,this.y*y)}scaleToRef(y,c){return c.x=this.x*y,c.y=this.y*y,c}scaleAndAddToRef(y,c){return c.x+=this.x*y,c.y+=this.y*y,c}equals(y){return y&&this.x===y.x&&this.y===y.y}equalsWithEpsilon(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.b;return y&&(0,h.WithinEpsilon)(this.x,y.x,c)&&(0,h.WithinEpsilon)(this.y,y.y,c)}equalsToFloats(y,c){return this.x===y&&this.y===c}floor(){return new i(Math.floor(this.x),Math.floor(this.y))}floorToRef(y){return y.x=Math.floor(this.x),y.y=Math.floor(this.y),y}fract(){return new i(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(y){return y.x=this.x-Math.floor(this.x),y.y=this.y-Math.floor(this.y),y}rotate(y){return this.rotateToRef(y,new i)}rotateToRef(y,c){const A=Math.cos(y),l=Math.sin(y);return c.x=A*this.x-l*this.y,c.y=l*this.x+A*this.y,c}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(y){return 0===y||1===y?this:this.scaleInPlace(1/y)}normalizeToNew(){const y=new i;return this.normalizeToRef(y),y}normalizeToRef(y){const c=this.length();return 0===c&&(y.x=this.x,y.y=this.y),this.scaleToRef(1/c,y)}clone(){return new i(this.x,this.y)}dot(y){return this.x*y.x+this.y*y.y}static Zero(){return new i(0,0)}static One(){return new i(1,1)}static Random(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new i((0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c))}static RandomToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ec((0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c))}static get ZeroReadOnly(){return i._ZeroReadOnly}static yA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new i(y[c],y[c+1])}static FromArrayToRef(y,c,A){return A.x=y[c],A.y=y[c+1],A}static FromFloatsToRef(y,c,A){return A.Ec(y,c),A}static CatmullRom(y,c,A,l,w){const N=w*w,p=w*N,W=.5*(2*c.x+(-y.x+A.x)*w+(2*y.x-5*c.x+4*A.x-l.x)*N+(-y.x+3*c.x-3*A.x+l.x)*p),h=.5*(2*c.y+(-y.y+A.y)*w+(2*y.y-5*c.y+4*A.y-l.y)*N+(-y.y+3*c.y-3*A.y+l.y)*p);return new i(W,h)}static ClampToRef(y,c,A,l){return l.x=(0,h.Clamp)(y.x,c.x,A.x),l.y=(0,h.Clamp)(y.y,c.y,A.y),l}static Clamp(y,c,A){const l=(0,h.Clamp)(y.x,c.x,A.x),w=(0,h.Clamp)(y.y,c.y,A.y);return new i(l,w)}static Hermite(y,c,A,l,w){const N=w*w,p=w*N,W=2*p-3*N+1,h=-2*p+3*N,I=p-2*N+w,q=p-N,o=y.x*W+A.x*h+c.x*I+l.x*q,O=y.y*W+A.y*h+c.y*I+l.y*q;return new i(o,O)}static Hermite1stDerivative(y,c,A,l,w){return this.Hermite1stDerivativeToRef(y,c,A,l,w,new i)}static Hermite1stDerivativeToRef(y,c,A,l,w,N){const p=w*w;return N.x=6*(p-w)*y.x+(3*p-4*w+1)*c.x+6*(-p+w)*A.x+(3*p-2*w)*l.x,N.y=6*(p-w)*y.y+(3*p-4*w+1)*c.y+6*(-p+w)*A.y+(3*p-2*w)*l.y,N}static Lerp(y,c,A){return i.LerpToRef(y,c,A,new i)}static LerpToRef(y,c,A,l){return l.x=y.x+(c.x-y.x)*A,l.y=y.y+(c.y-y.y)*A,l}static Dot(y,c){return y.x*c.x+y.y*c.y}static Normalize(y){return i.NormalizeToRef(y,new i)}static NormalizeToRef(y,c){return y.normalizeToRef(c),c}static Minimize(y,c){const A=y.x<c.x?y.x:c.x,l=y.y<c.y?y.y:c.y;return new i(A,l)}static Maximize(y,c){const A=y.x>c.x?y.x:c.x,l=y.y>c.y?y.y:c.y;return new i(A,l)}static Transform(y,c){return i.TransformToRef(y,c,new i)}static TransformToRef(y,c,A){const l=c.m,w=y.x*l[0]+y.y*l[4]+l[12],N=y.x*l[1]+y.y*l[5]+l[13];return A.x=w,A.y=N,A}static PointInTriangle(y,c,A,l){const w=.5*(-A.y*l.x+c.y*(-A.x+l.x)+c.x*(A.y-l.y)+A.x*l.y),N=w<0?-1:1,p=(c.y*l.x-c.x*l.y+(l.y-c.y)*y.x+(c.x-l.x)*y.y)*N,W=(c.x*A.y-c.y*A.x+(c.y-A.y)*y.x+(A.x-c.x)*y.y)*N;return p>0&&W>0&&p+W<2*w*N}static Distance(y,c){return Math.sqrt(i.DistanceSquared(y,c))}static DistanceSquared(y,c){const A=y.x-c.x,l=y.y-c.y;return A*A+l*l}static Center(y,c){return i.CenterToRef(y,c,new i)}static CenterToRef(y,c,A){return A.Ec((y.x+c.x)/2,(y.y+c.y)/2)}static DistanceOfPointFromSegment(y,c,A){const l=i.DistanceSquared(c,A);if(0===l)return i.Distance(y,c);const w=A.xc(c),N=Math.max(0,Math.min(1,i.Dot(y.xc(c),w)/l)),p=c.add(w.multiplyByFloats(N,N));return i.Distance(y,p)}}i._V8PerformanceHack=new i(.5,.5),i._ZeroReadOnly=i.Zero(),Object.defineProperties(i.prototype,{dimension:{value:[2]},rank:{value:1}});class H{get x(){return this._x}set x(y){this._x=y,this._isDirty=!0}get y(){return this._y}set y(y){this._y=y,this._isDirty=!0}get z(){return this._z}set z(y){this._z=y,this._isDirty=!0}constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=y,this._y=c,this._z=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"gc"}getHashCode(){let y=L(this._x);return y=397*y^L(this._y),y=397*y^L(this._z),y}fc(){return[this._x,this._y,this._z]}toArray(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y[c]=this._x,y[c+1]=this._y,y[c+2]=this._z,this}nA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H.FromArrayToRef(y,c,this),this}toQuaternion(){return D.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(y){return this._x+=y._x,this._y+=y._y,this._z+=y._z,this._isDirty=!0,this}addInPlaceFromFloats(y,c,A){return this._x+=y,this._y+=c,this._z+=A,this._isDirty=!0,this}add(y){return new H(this._x+y._x,this._y+y._y,this._z+y._z)}addToRef(y,c){return c._x=this._x+y._x,c._y=this._y+y._y,c._z=this._z+y._z,c._isDirty=!0,c}uo(y){return this._x-=y._x,this._y-=y._y,this._z-=y._z,this._isDirty=!0,this}xc(y){return new H(this._x-y._x,this._y-y._y,this._z-y._z)}subtractToRef(y,c){return this.subtractFromFloatsToRef(y._x,y._y,y._z,c)}subtractFromFloats(y,c,A){return new H(this._x-y,this._y-c,this._z-A)}subtractFromFloatsToRef(y,c,A,l){return l._x=this._x-y,l._y=this._y-c,l._z=this._z-A,l._isDirty=!0,l}negate(){return new H(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(y){return y._x=-1*this._x,y._y=-1*this._y,y._z=-1*this._z,y._isDirty=!0,y}scaleInPlace(y){return this._x*=y,this._y*=y,this._z*=y,this._isDirty=!0,this}scale(y){return new H(this._x*y,this._y*y,this._z*y)}scaleToRef(y,c){return c._x=this._x*y,c._y=this._y*y,c._z=this._z*y,c._isDirty=!0,c}getNormalToRef(y){const c=this.length();let A=Math.acos(this._y/c);const l=Math.atan2(this._z,this._x);A>Math.PI/2?A-=Math.PI/2:A+=Math.PI/2;const w=c*Math.sin(A)*Math.cos(l),N=c*Math.cos(A),p=c*Math.sin(A)*Math.sin(l);return y.set(w,N,p),y}applyRotationQuaternionToRef(y,c){const A=this._x,l=this._y,w=this._z,N=y._x,p=y._y,W=y._z,h=y._w,I=2*(p*w-W*l),q=2*(W*A-N*w),o=2*(N*l-p*A);return c._x=A+h*I+p*o-W*q,c._y=l+h*q+W*I-N*o,c._z=w+h*o+N*q-p*I,c._isDirty=!0,c}applyRotationQuaternionInPlace(y){return this.applyRotationQuaternionToRef(y,this)}applyRotationQuaternion(y){return this.applyRotationQuaternionToRef(y,new H)}scaleAndAddToRef(y,c){return c._x+=this._x*y,c._y+=this._y*y,c._z+=this._z*y,c._isDirty=!0,c}projectOnPlane(y,c){return this.projectOnPlaneToRef(y,c,new H)}projectOnPlaneToRef(y,c,A){const l=y.normal,w=y.d,N=s.gc[0];this.subtractToRef(c,N),N.normalize();const p=H.Dot(N,l);if(Math.abs(p)<1e-10)A.vc(1/0);else{const y=-(H.Dot(c,l)+w)/p,W=N.scaleInPlace(y);c.addToRef(W,A)}return A}equals(y){return y&&this._x===y._x&&this._y===y._y&&this._z===y._z}equalsWithEpsilon(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.b;return y&&(0,h.WithinEpsilon)(this._x,y._x,c)&&(0,h.WithinEpsilon)(this._y,y._y,c)&&(0,h.WithinEpsilon)(this._z,y._z,c)}equalsToFloats(y,c,A){return this._x===y&&this._y===c&&this._z===A}multiplyInPlace(y){return this._x*=y._x,this._y*=y._y,this._z*=y._z,this._isDirty=!0,this}multiply(y){return this.multiplyByFloats(y._x,y._y,y._z)}multiplyToRef(y,c){return c._x=this._x*y._x,c._y=this._y*y._y,c._z=this._z*y._z,c._isDirty=!0,c}multiplyByFloats(y,c,A){return new H(this._x*y,this._y*c,this._z*A)}divide(y){return new H(this._x/y._x,this._y/y._y,this._z/y._z)}divideToRef(y,c){return c._x=this._x/y._x,c._y=this._y/y._y,c._z=this._z/y._z,c._isDirty=!0,c}divideInPlace(y){return this._x=this._x/y._x,this._y=this._y/y._y,this._z=this._z/y._z,this._isDirty=!0,this}minimizeInPlace(y){return this.minimizeInPlaceFromFloats(y._x,y._y,y._z)}maximizeInPlace(y){return this.maximizeInPlaceFromFloats(y._x,y._y,y._z)}minimizeInPlaceFromFloats(y,c,A){return y<this._x&&(this.x=y),c<this._y&&(this.y=c),A<this._z&&(this.z=A),this}maximizeInPlaceFromFloats(y,c,A){return y>this._x&&(this.x=y),c>this._y&&(this.y=c),A>this._z&&(this.z=A),this}isNonUniformWithinEpsilon(y){const c=Math.abs(this._x),A=Math.abs(this._y);if(!(0,h.WithinEpsilon)(c,A,y))return!0;const l=Math.abs(this._z);return!(0,h.WithinEpsilon)(c,l,y)||!(0,h.WithinEpsilon)(A,l,y)}get isNonUniform(){const y=Math.abs(this._x);if(y!==Math.abs(this._y))return!0;return y!==Math.abs(this._z)}floorToRef(y){return y._x=Math.floor(this._x),y._y=Math.floor(this._y),y._z=Math.floor(this._z),y._isDirty=!0,y}floor(){return new H(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(y){return y._x=this._x-Math.floor(this._x),y._y=this._y-Math.floor(this._y),y._z=this._z-Math.floor(this._z),y._isDirty=!0,y}fract(){return new H(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(y){if("xyz"===(y=y.toLowerCase()))return this;const c=s.gc[0].p(this);return this.x=c[y[0]],this.y=c[y[1]],this.z=c[y[2]],this}rotateByQuaternionToRef(y,c){return y.toRotationMatrix(s.Matrix[0]),H.TransformCoordinatesToRef(this,s.Matrix[0],c),c}rotateByQuaternionAroundPointToRef(y,c,A){return this.subtractToRef(c,s.gc[0]),s.gc[0].rotateByQuaternionToRef(y,s.gc[0]),c.addToRef(s.gc[0],A),A}cross(y){return H.CrossToRef(this,y,new H)}normalizeFromLength(y){return 0===y||1===y?this:this.scaleInPlace(1/y)}normalizeToNew(){return this.normalizeToRef(new H)}normalizeToRef(y){const c=this.length();return 0===c||1===c?(y._x=this._x,y._y=this._y,y._z=this._z,y._isDirty=!0,y):this.scaleToRef(1/c,y)}clone(){return new H(this._x,this._y,this._z)}p(y){return this.Ec(y._x,y._y,y._z)}Ec(y,c,A){return this._x=y,this._y=c,this._z=A,this._isDirty=!0,this}set(y,c,A){return this.Ec(y,c,A)}vc(y){return this._x=this._y=this._z=y,this._isDirty=!0,this}static GetClipFactor(y,c,A,l){const w=H.Dot(y,A);return(w-l)/(w-H.Dot(c,A))}static GetAngleBetweenVectors(y,c,A){const l=y.normalizeToRef(s.gc[1]),w=c.normalizeToRef(s.gc[2]);let N=H.Dot(l,w);N=(0,h.Clamp)(N,-1,1);const p=Math.acos(N),W=s.gc[3];return H.CrossToRef(l,w,W),H.Dot(W,A)>0?isNaN(p)?0:p:isNaN(p)?-Math.PI:-Math.acos(N)}static GetAngleBetweenVectorsOnPlane(y,c,A){s.gc[0].p(y);const l=s.gc[0];s.gc[1].p(c);const w=s.gc[1];s.gc[2].p(A);const N=s.gc[2],p=s.gc[3],W=s.gc[4];l.normalize(),w.normalize(),N.normalize(),H.CrossToRef(N,l,p),H.CrossToRef(p,N,W);const I=Math.atan2(H.Dot(w,p),H.Dot(w,W));return(0,h.NormalizeRadians)(I)}static PitchYawRollToMoveBetweenPointsToRef(y,c,A){const l=B.gc[0];return c.subtractToRef(y,l),A._y=Math.atan2(l.x,l.z)||0,A._x=Math.atan2(Math.sqrt(l.x**2+l.z**2),l.y)||0,A._z=0,A._isDirty=!0,A}static PitchYawRollToMoveBetweenPoints(y,c){const A=H.Zero();return H.PitchYawRollToMoveBetweenPointsToRef(y,c,A)}static SlerpToRef(y,c,A,w){A=(0,h.Clamp)(A,0,1);const N=s.gc[0],p=s.gc[1];N.p(y);const W=N.length();N.normalizeFromLength(W),p.p(c);const I=p.length();p.normalizeFromLength(I);const q=H.Dot(N,p);let o,O;if(q<1-l.b){const y=Math.acos(q),c=1/Math.sin(y);o=Math.sin((1-A)*y)*c,O=Math.sin(A*y)*c}else o=1-A,O=A;return N.scaleInPlace(o),p.scaleInPlace(O),w.p(N).addInPlace(p),w.scaleInPlace((0,h.Lerp)(W,I,A)),w}static SmoothToRef(y,c,A,l,w){return H.SlerpToRef(y,c,0===l?1:A/l,w),w}static yA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new H(y[c],y[c+1],y[c+2])}static FromFloatArray(y,c){return H.yA(y,c)}static FromArrayToRef(y,c,A){return A._x=y[c],A._y=y[c+1],A._z=y[c+2],A._isDirty=!0,A}static FromFloatArrayToRef(y,c,A){return H.FromArrayToRef(y,c,A)}static FromFloatsToRef(y,c,A,l){return l.Ec(y,c,A),l}static Zero(){return new H(0,0,0)}static One(){return new H(1,1,1)}static Up(){return new H(0,1,0)}static get UpReadOnly(){return H._UpReadOnly}static get DownReadOnly(){return H._DownReadOnly}static get RightReadOnly(){return H._RightReadOnly}static get LeftReadOnly(){return H._LeftReadOnly}static get LeftHandedForwardReadOnly(){return H._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return H._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return H._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return H._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return H._ZeroReadOnly}static get OneReadOnly(){return H._OneReadOnly}static Down(){return new H(0,-1,0)}static Forward(){return new H(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new H(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new H(1,0,0)}static Left(){return new H(-1,0,0)}static Random(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new H((0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c))}static RandomToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ec((0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c))}static TransformCoordinates(y,c){const A=H.Zero();return H.TransformCoordinatesToRef(y,c,A),A}static TransformCoordinatesToRef(y,c,A){return H.TransformCoordinatesFromFloatsToRef(y._x,y._y,y._z,c,A),A}static TransformCoordinatesFromFloatsToRef(y,c,A,l,w){const N=l.m,p=y*N[0]+c*N[4]+A*N[8]+N[12],W=y*N[1]+c*N[5]+A*N[9]+N[13],h=y*N[2]+c*N[6]+A*N[10]+N[14],I=1/(y*N[3]+c*N[7]+A*N[11]+N[15]);return w._x=p*I,w._y=W*I,w._z=h*I,w._isDirty=!0,w}static TransformNormal(y,c){const A=H.Zero();return H.TransformNormalToRef(y,c,A),A}static TransformNormalToRef(y,c,A){return this.TransformNormalFromFloatsToRef(y._x,y._y,y._z,c,A),A}static TransformNormalFromFloatsToRef(y,c,A,l,w){const N=l.m;return w._x=y*N[0]+c*N[4]+A*N[8],w._y=y*N[1]+c*N[5]+A*N[9],w._z=y*N[2]+c*N[6]+A*N[10],w._isDirty=!0,w}static CatmullRom(y,c,A,l,w){const N=w*w,p=w*N,W=.5*(2*c._x+(-y._x+A._x)*w+(2*y._x-5*c._x+4*A._x-l._x)*N+(-y._x+3*c._x-3*A._x+l._x)*p),h=.5*(2*c._y+(-y._y+A._y)*w+(2*y._y-5*c._y+4*A._y-l._y)*N+(-y._y+3*c._y-3*A._y+l._y)*p),I=.5*(2*c._z+(-y._z+A._z)*w+(2*y._z-5*c._z+4*A._z-l._z)*N+(-y._z+3*c._z-3*A._z+l._z)*p);return new H(W,h,I)}static Clamp(y,c,A){const l=new H;return H.ClampToRef(y,c,A,l),l}static ClampToRef(y,c,A,l){let w=y._x;w=w>A._x?A._x:w,w=w<c._x?c._x:w;let N=y._y;N=N>A._y?A._y:N,N=N<c._y?c._y:N;let p=y._z;return p=p>A._z?A._z:p,p=p<c._z?c._z:p,l.Ec(w,N,p),l}static CheckExtends(y,c,A){c.minimizeInPlace(y),A.maximizeInPlace(y)}static Hermite(y,c,A,l,w){const N=w*w,p=w*N,W=2*p-3*N+1,h=-2*p+3*N,I=p-2*N+w,q=p-N,o=y._x*W+A._x*h+c._x*I+l._x*q,O=y._y*W+A._y*h+c._y*I+l._y*q,L=y._z*W+A._z*h+c._z*I+l._z*q;return new H(o,O,L)}static Hermite1stDerivative(y,c,A,l,w){const N=new H;return this.Hermite1stDerivativeToRef(y,c,A,l,w,N),N}static Hermite1stDerivativeToRef(y,c,A,l,w,N){const p=w*w;return N._x=6*(p-w)*y._x+(3*p-4*w+1)*c._x+6*(-p+w)*A._x+(3*p-2*w)*l._x,N._y=6*(p-w)*y._y+(3*p-4*w+1)*c._y+6*(-p+w)*A._y+(3*p-2*w)*l._y,N._z=6*(p-w)*y._z+(3*p-4*w+1)*c._z+6*(-p+w)*A._z+(3*p-2*w)*l._z,N._isDirty=!0,N}static Lerp(y,c,A){const l=new H(0,0,0);return H.LerpToRef(y,c,A,l),l}static LerpToRef(y,c,A,l){return l._x=y._x+(c._x-y._x)*A,l._y=y._y+(c._y-y._y)*A,l._z=y._z+(c._z-y._z)*A,l._isDirty=!0,l}static Dot(y,c){return y._x*c._x+y._y*c._y+y._z*c._z}dot(y){return this._x*y._x+this._y*y._y+this._z*y._z}static Cross(y,c){const A=new H;return H.CrossToRef(y,c,A),A}static CrossToRef(y,c,A){const l=y._y*c._z-y._z*c._y,w=y._z*c._x-y._x*c._z,N=y._x*c._y-y._y*c._x;return A.Ec(l,w,N),A}static Normalize(y){const c=H.Zero();return H.NormalizeToRef(y,c),c}static NormalizeToRef(y,c){return y.normalizeToRef(c),c}static Project(y,c,A,l){const w=new H;return H.ProjectToRef(y,c,A,l,w),w}static ProjectToRef(y,c,A,l,w){var N;const p=l.width,h=l.height,I=l.x,q=l.y,o=s.Matrix[1],O=null===(N=W.c.LastCreatedEngine)||void 0===N?void 0:N.isNDCHalfZRange,L=O?1:.5,i=O?0:.5;t.FromValuesToRef(p/2,0,0,0,0,-h/2,0,0,0,0,L,0,I+p/2,h/2+q,i,1,o);const P=s.Matrix[0];return c.multiplyToRef(A,P),P.multiplyToRef(o,P),H.TransformCoordinatesToRef(y,P,w),w}static Reflect(y,c){return this.ReflectToRef(y,c,new H)}static ReflectToRef(y,c,A){const l=B.gc[0];return l.p(c).scaleInPlace(2*H.Dot(y,c)),A.p(y).uo(l)}static _UnprojectFromInvertedMatrixToRef(y,c,A){H.TransformCoordinatesToRef(y,c,A);const l=c.m,w=y._x*l[3]+y._y*l[7]+y._z*l[11]+l[15];return(0,h.WithinEpsilon)(w,1)&&A.scaleInPlace(1/w),A}static UnprojectFromTransform(y,c,A,l,w){return this.Unproject(y,c,A,l,w,t.IdentityReadOnly)}static Unproject(y,c,A,l,w,N){const p=new H;return H.UnprojectToRef(y,c,A,l,w,N,p),p}static UnprojectToRef(y,c,A,l,w,N,p){return H.UnprojectFloatsToRef(y._x,y._y,y._z,c,A,l,w,N,p),p}static UnprojectFloatsToRef(y,c,A,l,w,N,p,h,I){var q;const o=s.Matrix[0];N.multiplyToRef(p,o),o.multiplyToRef(h,o),o.invert();const O=s.gc[0];return O.x=y/l*2-1,O.y=-(c/w*2-1),null!==(q=W.c.LastCreatedEngine)&&void 0!==q&&q.isNDCHalfZRange?O.z=A:O.z=2*A-1,H._UnprojectFromInvertedMatrixToRef(O,o,I),I}static Minimize(y,c){const A=new H;return A.p(y),A.minimizeInPlace(c),A}static Maximize(y,c){const A=new H;return A.p(y),A.maximizeInPlace(c),A}static Distance(y,c){return Math.sqrt(H.DistanceSquared(y,c))}static DistanceSquared(y,c){const A=y._x-c._x,l=y._y-c._y,w=y._z-c._z;return A*A+l*l+w*w}static ProjectOnTriangleToRef(y,c,A,w,N){const p=s.gc[0],W=s.gc[1],I=s.gc[2],q=s.gc[3],o=s.gc[4];A.subtractToRef(c,p),w.subtractToRef(c,W),w.subtractToRef(A,I);const O=p.length(),L=W.length(),i=I.length();if(O<l.b||L<l.b||i<l.b)return N.p(c),H.Distance(y,c);y.subtractToRef(c,o),H.CrossToRef(p,W,q);const P=q.length();if(P<l.b)return N.p(c),H.Distance(y,c);q.normalizeFromLength(P);let D=o.length();if(D<l.b)return N.p(c),0;o.normalizeFromLength(D);const t=H.Dot(q,o),B=s.gc[5],X=s.gc[6];B.p(q).scaleInPlace(-D*t),X.p(y).addInPlace(B);const C=s.gc[4],K=s.gc[5],my=s.gc[7],T=s.gc[8];C.p(p).scaleInPlace(1/O),T.p(W).scaleInPlace(1/L),C.addInPlace(T).scaleInPlace(-1),K.p(p).scaleInPlace(-1/O),T.p(I).scaleInPlace(1/i),K.addInPlace(T).scaleInPlace(-1),my.p(I).scaleInPlace(-1/i),T.p(W).scaleInPlace(-1/L),my.addInPlace(T).scaleInPlace(-1);const z=s.gc[9];let S;z.p(X).uo(c),H.CrossToRef(C,z,T),S=H.Dot(T,q);const M=S;z.p(X).uo(A),H.CrossToRef(K,z,T),S=H.Dot(T,q);const k=S;z.p(X).uo(w),H.CrossToRef(my,z,T),S=H.Dot(T,q);const a=S,u=s.gc[10];let G,j;M>0&&k<0?(u.p(p),G=c,j=A):k>0&&a<0?(u.p(I),G=A,j=w):(u.p(W).scaleInPlace(-1),G=w,j=c);const f=s.gc[9],V=s.gc[4];G.subtractToRef(X,T),j.subtractToRef(X,f),H.CrossToRef(T,f,V);if(!(H.Dot(V,q)<0))return N.p(X),Math.abs(D*t);const J=s.gc[5];H.CrossToRef(u,V,J),J.normalize();const U=s.gc[9];U.p(G).uo(X);const e=U.length();if(e<l.b)return N.p(G),H.Distance(y,G);U.normalizeFromLength(e);const Q=H.Dot(J,U),Y=s.gc[7];Y.p(X).addInPlace(J.scaleInPlace(e*Q)),T.p(Y).uo(G),D=u.length(),u.normalizeFromLength(D);let g=H.Dot(T,u)/Math.max(D,l.b);return g=(0,h.Clamp)(g,0,1),Y.p(G).addInPlace(u.scaleInPlace(g*D)),N.p(Y),H.Distance(y,Y)}static Center(y,c){return H.CenterToRef(y,c,H.Zero())}static CenterToRef(y,c,A){return A.Ec((y._x+c._x)/2,(y._y+c._y)/2,(y._z+c._z)/2)}static RotationFromAxis(y,c,A){const l=new H;return H.RotationFromAxisToRef(y,c,A,l),l}static RotationFromAxisToRef(y,c,A,l){const w=s.Quaternion[0];return D.RotationQuaternionFromAxisToRef(y,c,A,w),w.toEulerAnglesToRef(l),l}}H._V8PerformanceHack=new H(.5,.5,.5),H._UpReadOnly=H.Up(),H._DownReadOnly=H.Down(),H._LeftHandedForwardReadOnly=H.Forward(!1),H._RightHandedForwardReadOnly=H.Forward(!0),H._LeftHandedBackwardReadOnly=H.Backward(!1),H._RightHandedBackwardReadOnly=H.Backward(!0),H._RightReadOnly=H.Right(),H._LeftReadOnly=H.Left(),H._ZeroReadOnly=H.Zero(),H._OneReadOnly=H.One(),Object.defineProperties(H.prototype,{dimension:{value:[3]},rank:{value:1}});class P{get x(){return this._x}set x(y){this._x=y,this._isDirty=!0}get y(){return this._y}set y(y){this._y=y,this._isDirty=!0}get z(){return this._z}set z(y){this._z=y,this._isDirty=!0}get w(){return this._w}set w(y){this._w=y,this._isDirty=!0}constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=y,this._y=c,this._z=A,this._w=l}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let y=L(this._x);return y=397*y^L(this._y),y=397*y^L(this._z),y=397*y^L(this._w),y}fc(){return[this._x,this._y,this._z,this._w]}toArray(y,c){return void 0===c&&(c=0),y[c]=this._x,y[c+1]=this._y,y[c+2]=this._z,y[c+3]=this._w,this}nA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(y,c,this),this}addInPlace(y){return this.x+=y._x,this.y+=y._y,this.z+=y._z,this.w+=y._w,this}addInPlaceFromFloats(y,c,A,l){return this.x+=y,this.y+=c,this.z+=A,this.w+=l,this}add(y){return new P(this._x+y.x,this._y+y.y,this._z+y.z,this._w+y.w)}addToRef(y,c){return c.x=this._x+y.x,c.y=this._y+y.y,c.z=this._z+y.z,c.w=this._w+y.w,c}uo(y){return this.x-=y.x,this.y-=y.y,this.z-=y.z,this.w-=y.w,this}xc(y){return new P(this._x-y.x,this._y-y.y,this._z-y.z,this._w-y.w)}subtractToRef(y,c){return c.x=this._x-y.x,c.y=this._y-y.y,c.z=this._z-y.z,c.w=this._w-y.w,c}subtractFromFloats(y,c,A,l){return new P(this._x-y,this._y-c,this._z-A,this._w-l)}subtractFromFloatsToRef(y,c,A,l,w){return w.x=this._x-y,w.y=this._y-c,w.z=this._z-A,w.w=this._w-l,w}negate(){return new P(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(y){return y.x=-this._x,y.y=-this._y,y.z=-this._z,y.w=-this._w,y}scaleInPlace(y){return this.x*=y,this.y*=y,this.z*=y,this.w*=y,this}scale(y){return new P(this._x*y,this._y*y,this._z*y,this._w*y)}scaleToRef(y,c){return c.x=this._x*y,c.y=this._y*y,c.z=this._z*y,c.w=this._w*y,c}scaleAndAddToRef(y,c){return c.x+=this._x*y,c.y+=this._y*y,c.z+=this._z*y,c.w+=this._w*y,c}equals(y){return y&&this._x===y.x&&this._y===y.y&&this._z===y.z&&this._w===y.w}equalsWithEpsilon(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.b;return y&&(0,h.WithinEpsilon)(this._x,y.x,c)&&(0,h.WithinEpsilon)(this._y,y.y,c)&&(0,h.WithinEpsilon)(this._z,y.z,c)&&(0,h.WithinEpsilon)(this._w,y.w,c)}equalsToFloats(y,c,A,l){return this._x===y&&this._y===c&&this._z===A&&this._w===l}multiplyInPlace(y){return this.x*=y.x,this.y*=y.y,this.z*=y.z,this.w*=y.w,this}multiply(y){return new P(this._x*y.x,this._y*y.y,this._z*y.z,this._w*y.w)}multiplyToRef(y,c){return c.x=this._x*y.x,c.y=this._y*y.y,c.z=this._z*y.z,c.w=this._w*y.w,c}multiplyByFloats(y,c,A,l){return new P(this._x*y,this._y*c,this._z*A,this._w*l)}divide(y){return new P(this._x/y.x,this._y/y.y,this._z/y.z,this._w/y.w)}divideToRef(y,c){return c.x=this._x/y.x,c.y=this._y/y.y,c.z=this._z/y.z,c.w=this._w/y.w,c}divideInPlace(y){return this.divideToRef(y,this)}minimizeInPlace(y){return y.x<this._x&&(this.x=y.x),y.y<this._y&&(this.y=y.y),y.z<this._z&&(this.z=y.z),y.w<this._w&&(this.w=y.w),this}maximizeInPlace(y){return y.x>this._x&&(this.x=y.x),y.y>this._y&&(this.y=y.y),y.z>this._z&&(this.z=y.z),y.w>this._w&&(this.w=y.w),this}minimizeInPlaceFromFloats(y,c,A,l){return this.x=Math.min(y,this._x),this.y=Math.min(c,this._y),this.z=Math.min(A,this._z),this.w=Math.min(l,this._w),this}maximizeInPlaceFromFloats(y,c,A,l){return this.x=Math.max(y,this._x),this.y=Math.max(c,this._y),this.z=Math.max(A,this._z),this.w=Math.max(l,this._w),this}floorToRef(y){return y.x=Math.floor(this._x),y.y=Math.floor(this._y),y.z=Math.floor(this._z),y.w=Math.floor(this._w),y}floor(){return new P(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(y){return y.x=this._x-Math.floor(this._x),y.y=this._y-Math.floor(this._y),y.z=this._z-Math.floor(this._z),y.w=this._w-Math.floor(this._w),y}fract(){return new P(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(y){return 0===y||1===y?this:this.scaleInPlace(1/y)}normalizeToNew(){return this.normalizeToRef(new P)}normalizeToRef(y){const c=this.length();return 0===c||1===c?(y.x=this._x,y.y=this._y,y.z=this._z,y.w=this._w,y):this.scaleToRef(1/c,y)}toVector3(){return new H(this._x,this._y,this._z)}clone(){return new P(this._x,this._y,this._z,this._w)}p(y){return this.x=y.x,this.y=y.y,this.z=y.z,this.w=y.w,this}Ec(y,c,A,l){return this.x=y,this.y=c,this.z=A,this.w=l,this}set(y,c,A,l){return this.Ec(y,c,A,l)}vc(y){return this.x=this.y=this.z=this.w=y,this}dot(y){return this._x*y.x+this._y*y.y+this._z*y.z+this._w*y.w}static yA(y,c){return c||(c=0),new P(y[c],y[c+1],y[c+2],y[c+3])}static FromArrayToRef(y,c,A){return A.x=y[c],A.y=y[c+1],A.z=y[c+2],A.w=y[c+3],A}static FromFloatArrayToRef(y,c,A){return P.FromArrayToRef(y,c,A),A}static FromFloatsToRef(y,c,A,l,w){return w.x=y,w.y=c,w.z=A,w.w=l,w}static Zero(){return new P(0,0,0,0)}static One(){return new P(1,1,1,1)}static Random(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new P((0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c))}static RandomToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,A=arguments.length>2?arguments[2]:void 0;return A.x=(0,h.RandomRange)(y,c),A.y=(0,h.RandomRange)(y,c),A.z=(0,h.RandomRange)(y,c),A.w=(0,h.RandomRange)(y,c),A}static Clamp(y,c,A){return P.ClampToRef(y,c,A,new P)}static ClampToRef(y,c,A,l){return l.x=(0,h.Clamp)(y.x,c.x,A.x),l.y=(0,h.Clamp)(y.y,c.y,A.y),l.z=(0,h.Clamp)(y.z,c.z,A.z),l.w=(0,h.Clamp)(y.w,c.w,A.w),l}static CheckExtends(y,c,A){c.minimizeInPlace(y),A.maximizeInPlace(y)}static get ZeroReadOnly(){return P._ZeroReadOnly}static Normalize(y){return P.NormalizeToRef(y,new P)}static NormalizeToRef(y,c){return y.normalizeToRef(c),c}static Minimize(y,c){const A=new P;return A.p(y),A.minimizeInPlace(c),A}static Maximize(y,c){const A=new P;return A.p(y),A.maximizeInPlace(c),A}static Distance(y,c){return Math.sqrt(P.DistanceSquared(y,c))}static DistanceSquared(y,c){const A=y.x-c.x,l=y.y-c.y,w=y.z-c.z,N=y.w-c.w;return A*A+l*l+w*w+N*N}static Center(y,c){return P.CenterToRef(y,c,new P)}static CenterToRef(y,c,A){return A.x=(y.x+c.x)/2,A.y=(y.y+c.y)/2,A.z=(y.z+c.z)/2,A.w=(y.w+c.w)/2,A}static TransformCoordinates(y,c){return P.TransformCoordinatesToRef(y,c,new P)}static TransformCoordinatesToRef(y,c,A){return P.TransformCoordinatesFromFloatsToRef(y._x,y._y,y._z,c,A),A}static TransformCoordinatesFromFloatsToRef(y,c,A,l,w){const N=l.m,p=y*N[0]+c*N[4]+A*N[8]+N[12],W=y*N[1]+c*N[5]+A*N[9]+N[13],h=y*N[2]+c*N[6]+A*N[10]+N[14],I=y*N[3]+c*N[7]+A*N[11]+N[15];return w.x=p,w.y=W,w.z=h,w.w=I,w}static TransformNormal(y,c){return P.TransformNormalToRef(y,c,new P)}static TransformNormalToRef(y,c,A){const l=c.m,w=y.x*l[0]+y.y*l[4]+y.z*l[8],N=y.x*l[1]+y.y*l[5]+y.z*l[9],p=y.x*l[2]+y.y*l[6]+y.z*l[10];return A.x=w,A.y=N,A.z=p,A.w=y.w,A}static TransformNormalFromFloatsToRef(y,c,A,l,w,N){const p=w.m;return N.x=y*p[0]+c*p[4]+A*p[8],N.y=y*p[1]+c*p[5]+A*p[9],N.z=y*p[2]+c*p[6]+A*p[10],N.w=l,N}static FromVector3(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new P(y._x,y._y,y._z,c)}static Dot(y,c){return y.x*c.x+y.y*c.y+y.z*c.z+y.w*c.w}}P._V8PerformanceHack=new P(.5,.5,.5,.5),P._ZeroReadOnly=P.Zero(),Object.defineProperties(P.prototype,{dimension:{value:[4]},rank:{value:1}});class D{get x(){return this._x}set x(y){this._x=y,this._isDirty=!0}get y(){return this._y}set y(y){this._y=y,this._isDirty=!0}get z(){return this._z}set z(y){this._z=y,this._isDirty=!0}get w(){return this._w}set w(y){this._w=y,this._isDirty=!0}constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=y,this._y=c,this._z=A,this._w=l}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let y=L(this._x);return y=397*y^L(this._y),y=397*y^L(this._z),y=397*y^L(this._w),y}fc(){return[this._x,this._y,this._z,this._w]}toArray(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y[c]=this._x,y[c+1]=this._y,y[c+2]=this._z,y[c+3]=this._w,this}nA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D.FromArrayToRef(y,c,this)}equals(y){return y&&this._x===y._x&&this._y===y._y&&this._z===y._z&&this._w===y._w}equalsWithEpsilon(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.b;return y&&(0,h.WithinEpsilon)(this._x,y._x,c)&&(0,h.WithinEpsilon)(this._y,y._y,c)&&(0,h.WithinEpsilon)(this._z,y._z,c)&&(0,h.WithinEpsilon)(this._w,y._w,c)}isApprox(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.b;return y&&((0,h.WithinEpsilon)(this._x,y._x,c)&&(0,h.WithinEpsilon)(this._y,y._y,c)&&(0,h.WithinEpsilon)(this._z,y._z,c)&&(0,h.WithinEpsilon)(this._w,y._w,c)||(0,h.WithinEpsilon)(this._x,-y._x,c)&&(0,h.WithinEpsilon)(this._y,-y._y,c)&&(0,h.WithinEpsilon)(this._z,-y._z,c)&&(0,h.WithinEpsilon)(this._w,-y._w,c))}clone(){return new D(this._x,this._y,this._z,this._w)}p(y){return this._x=y._x,this._y=y._y,this._z=y._z,this._w=y._w,this._isDirty=!0,this}Ec(y,c,A,l){return this._x=y,this._y=c,this._z=A,this._w=l,this._isDirty=!0,this}set(y,c,A,l){return this.Ec(y,c,A,l)}vc(y){return this.Ec(y,y,y,y)}add(y){return new D(this._x+y._x,this._y+y._y,this._z+y._z,this._w+y._w)}addInPlace(y){return this._x+=y._x,this._y+=y._y,this._z+=y._z,this._w+=y._w,this._isDirty=!0,this}addToRef(y,c){return c._x=this._x+y._x,c._y=this._y+y._y,c._z=this._z+y._z,c._w=this._w+y._w,c._isDirty=!0,c}addInPlaceFromFloats(y,c,A,l){return this._x+=y,this._y+=c,this._z+=A,this._w+=l,this._isDirty=!0,this}subtractToRef(y,c){return c._x=this._x-y._x,c._y=this._y-y._y,c._z=this._z-y._z,c._w=this._w-y._w,c._isDirty=!0,c}subtractFromFloats(y,c,A,l){return this.subtractFromFloatsToRef(y,c,A,l,new D)}subtractFromFloatsToRef(y,c,A,l,w){return w._x=this._x-y,w._y=this._y-c,w._z=this._z-A,w._w=this._w-l,w._isDirty=!0,w}xc(y){return new D(this._x-y._x,this._y-y._y,this._z-y._z,this._w-y._w)}uo(y){return this._x-=y._x,this._y-=y._y,this._z-=y._z,this._w-=y._w,this._isDirty=!0,this}scale(y){return new D(this._x*y,this._y*y,this._z*y,this._w*y)}scaleToRef(y,c){return c._x=this._x*y,c._y=this._y*y,c._z=this._z*y,c._w=this._w*y,c._isDirty=!0,c}scaleInPlace(y){return this._x*=y,this._y*=y,this._z*=y,this._w*=y,this._isDirty=!0,this}scaleAndAddToRef(y,c){return c._x+=this._x*y,c._y+=this._y*y,c._z+=this._z*y,c._w+=this._w*y,c._isDirty=!0,c}multiply(y){const c=new D(0,0,0,1);return this.multiplyToRef(y,c),c}multiplyToRef(y,c){const A=this._x*y._w+this._y*y._z-this._z*y._y+this._w*y._x,l=-this._x*y._z+this._y*y._w+this._z*y._x+this._w*y._y,w=this._x*y._y-this._y*y._x+this._z*y._w+this._w*y._z,N=-this._x*y._x-this._y*y._y-this._z*y._z+this._w*y._w;return c.Ec(A,l,w,N),c}multiplyInPlace(y){return this.multiplyToRef(y,this)}multiplyByFloats(y,c,A,l){return this._x*=y,this._y*=c,this._z*=A,this._w*=l,this._isDirty=!0,this}divide(y){throw new ReferenceError("Can not divide a quaternion")}divideToRef(y,c){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(y){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new D)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(y){return y._x=-this._x,y._y=-this._y,y._z=-this._z,y._w=-this._w,y._isDirty=!0,y}equalsToFloats(y,c,A,l){return this._x===y&&this._y===c&&this._z===A&&this._w===l}floorToRef(y){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(y){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(y){return y.Ec(-this._x,-this._y,-this._z,this._w),y}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new D(-this._x,-this._y,-this._z,this._w)}invert(){const y=this.conjugate(),c=this.lengthSquared();return 0==c||1==c||y.scaleInPlace(1/c),y}invertInPlace(){this.conjugateInPlace();const y=this.lengthSquared();return 0==y||1==y||this.scaleInPlace(1/y),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(y){return 0===y||1===y?this:this.scaleInPlace(1/y)}normalizeToNew(){const y=new D(0,0,0,1);return this.normalizeToRef(y),y}normalizeToRef(y){const c=this.length();return 0===c||1===c?y.Ec(this._x,this._y,this._z,this._w):this.scaleToRef(1/c,y)}toEulerAngles(){const y=H.Zero();return this.toEulerAnglesToRef(y),y}toEulerAnglesToRef(y){const c=this._z,A=this._x,l=this._y,w=this._w,N=l*c-A*w,p=.4999999;if(N<-p)y._y=2*Math.atan2(l,w),y._x=Math.PI/2,y._z=0,y._isDirty=!0;else if(N>p)y._y=2*Math.atan2(l,w),y._x=-Math.PI/2,y._z=0,y._isDirty=!0;else{const p=w*w,W=c*c,h=A*A,I=l*l;y._z=Math.atan2(2*(A*l+c*w),-W-h+I+p),y._x=Math.asin(-2*N),y._y=Math.atan2(2*(c*A+l*w),W-h-I+p),y._isDirty=!0}return y}toAlphaBetaGammaToRef(y){const c=this._z,A=this._x,l=this._y,w=this._w,N=Math.sqrt(A*A+l*l),p=Math.sqrt(c*c+w*w),W=2*Math.atan2(N,p),h=2*Math.atan2(c,w),I=2*Math.atan2(l,A),q=(h+I)/2,o=(h-I)/2;return y.set(o,W,q),y}toRotationMatrix(y){return t.FromQuaternionToRef(this,y),y}fromRotationMatrix(y){return D.FromRotationMatrixToRef(y,this),this}dot(y){return this._x*y._x+this._y*y._y+this._z*y._z+this._w*y._w}toAxisAngle(){const y=H.Zero();return{axis:y,angle:this.toAxisAngleToRef(y)}}toAxisAngleToRef(y){let c=0;const A=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),l=this._w;return A>0?(c=2*Math.atan2(A,l),y.set(this._x/A,this._y/A,this._z/A)):(c=0,y.set(1,0,0)),c}static FromRotationMatrix(y){const c=new D;return D.FromRotationMatrixToRef(y,c),c}static FromRotationMatrixToRef(y,c){const A=y.m,l=A[0],w=A[4],N=A[8],p=A[1],W=A[5],h=A[9],I=A[2],q=A[6],o=A[10],O=l+W+o;let L;return O>0?(L=.5/Math.sqrt(O+1),c._w=.25/L,c._x=(q-h)*L,c._y=(N-I)*L,c._z=(p-w)*L,c._isDirty=!0):l>W&&l>o?(L=2*Math.sqrt(1+l-W-o),c._w=(q-h)/L,c._x=.25*L,c._y=(w+p)/L,c._z=(N+I)/L,c._isDirty=!0):W>o?(L=2*Math.sqrt(1+W-l-o),c._w=(N-I)/L,c._x=(w+p)/L,c._y=.25*L,c._z=(h+q)/L,c._isDirty=!0):(L=2*Math.sqrt(1+o-l-W),c._w=(p-w)/L,c._x=(N+I)/L,c._y=(h+q)/L,c._z=.25*L,c._isDirty=!0),c}static Dot(y,c){return y._x*c._x+y._y*c._y+y._z*c._z+y._w*c._w}static AreClose(y,c){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const l=D.Dot(y,c);return 1-l*l<=A}static SmoothToRef(y,c,A,l,w){let N=0===l?1:A/l;return N=(0,h.Clamp)(N,0,1),D.SlerpToRef(y,c,N,w),w}static Zero(){return new D(0,0,0,0)}static Inverse(y){return new D(-y._x,-y._y,-y._z,y._w)}static InverseToRef(y,c){return c.set(-y._x,-y._y,-y._z,y._w),c}static Identity(){return new D(0,0,0,1)}static IsIdentity(y){return y&&0===y._x&&0===y._y&&0===y._z&&1===y._w}static RotationAxis(y,c){return D.RotationAxisToRef(y,c,new D)}static RotationAxisToRef(y,c,A){A._w=Math.cos(c/2);const l=Math.sin(c/2)/y.length();return A._x=y._x*l,A._y=y._y*l,A._z=y._z*l,A._isDirty=!0,A}static yA(y,c){return c||(c=0),new D(y[c],y[c+1],y[c+2],y[c+3])}static FromArrayToRef(y,c,A){return A._x=y[c],A._y=y[c+1],A._z=y[c+2],A._w=y[c+3],A._isDirty=!0,A}static FromFloatsToRef(y,c,A,l,w){return w.Ec(y,c,A,l),w}static FromEulerAngles(y,c,A){const l=new D;return D.RotationYawPitchRollToRef(c,y,A,l),l}static FromEulerAnglesToRef(y,c,A,l){return D.RotationYawPitchRollToRef(c,y,A,l),l}static FromEulerVector(y){const c=new D;return D.RotationYawPitchRollToRef(y._y,y._x,y._z,c),c}static FromEulerVectorToRef(y,c){return D.RotationYawPitchRollToRef(y._y,y._x,y._z,c),c}static FromUnitVectorsToRef(y,c,A){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:l.b;const N=H.Dot(y,c)+1;return N<w?Math.abs(y.x)>Math.abs(y.z)?A.set(-y.y,y.x,0,0):A.set(0,-y.z,y.y,0):(H.CrossToRef(y,c,B.gc[0]),A.set(B.gc[0].x,B.gc[0].y,B.gc[0].z,N)),A.normalize()}static RotationYawPitchRoll(y,c,A){const l=new D;return D.RotationYawPitchRollToRef(y,c,A,l),l}static RotationYawPitchRollToRef(y,c,A,l){const w=.5*A,N=.5*c,p=.5*y,W=Math.sin(w),h=Math.cos(w),I=Math.sin(N),q=Math.cos(N),o=Math.sin(p),O=Math.cos(p);return l._x=O*I*h+o*q*W,l._y=o*q*h-O*I*W,l._z=O*q*W-o*I*h,l._w=O*q*h+o*I*W,l._isDirty=!0,l}static RotationAlphaBetaGamma(y,c,A){const l=new D;return D.RotationAlphaBetaGammaToRef(y,c,A,l),l}static RotationAlphaBetaGammaToRef(y,c,A,l){const w=.5*(A+y),N=.5*(A-y),p=.5*c;return l._x=Math.cos(N)*Math.sin(p),l._y=Math.sin(N)*Math.sin(p),l._z=Math.sin(w)*Math.cos(p),l._w=Math.cos(w)*Math.cos(p),l._isDirty=!0,l}static RotationQuaternionFromAxis(y,c,A){const l=new D(0,0,0,0);return D.RotationQuaternionFromAxisToRef(y,c,A,l),l}static RotationQuaternionFromAxisToRef(y,c,A,l){const w=s.Matrix[0];return y=y.normalizeToRef(s.gc[0]),c=c.normalizeToRef(s.gc[1]),A=A.normalizeToRef(s.gc[2]),t.FromXYZAxesToRef(y,c,A,w),D.FromRotationMatrixToRef(w,l),l}static FromLookDirectionLH(y,c){const A=new D;return D.FromLookDirectionLHToRef(y,c,A),A}static FromLookDirectionLHToRef(y,c,A){const l=s.Matrix[0];return t.LookDirectionLHToRef(y,c,l),D.FromRotationMatrixToRef(l,A),A}static FromLookDirectionRH(y,c){const A=new D;return D.FromLookDirectionRHToRef(y,c,A),A}static FromLookDirectionRHToRef(y,c,A){const l=s.Matrix[0];return t.LookDirectionRHToRef(y,c,l),D.FromRotationMatrixToRef(l,A)}static Slerp(y,c,A){const l=D.Identity();return D.SlerpToRef(y,c,A,l),l}static SlerpToRef(y,c,A,l){let w,N,p=y._x*c._x+y._y*c._y+y._z*c._z+y._w*c._w,W=!1;if(p<0&&(W=!0,p=-p),p>.999999)N=1-A,w=W?-A:A;else{const y=Math.acos(p),c=1/Math.sin(y);N=Math.sin((1-A)*y)*c,w=W?-Math.sin(A*y)*c:Math.sin(A*y)*c}return l._x=N*y._x+w*c._x,l._y=N*y._y+w*c._y,l._z=N*y._z+w*c._z,l._w=N*y._w+w*c._w,l._isDirty=!0,l}static Hermite(y,c,A,l,w){const N=w*w,p=w*N,W=2*p-3*N+1,h=-2*p+3*N,I=p-2*N+w,q=p-N,o=y._x*W+A._x*h+c._x*I+l._x*q,O=y._y*W+A._y*h+c._y*I+l._y*q,L=y._z*W+A._z*h+c._z*I+l._z*q,i=y._w*W+A._w*h+c._w*I+l._w*q;return new D(o,O,L,i)}static Hermite1stDerivative(y,c,A,l,w){const N=new D;return this.Hermite1stDerivativeToRef(y,c,A,l,w,N),N}static Hermite1stDerivativeToRef(y,c,A,l,w,N){const p=w*w;return N._x=6*(p-w)*y._x+(3*p-4*w+1)*c._x+6*(-p+w)*A._x+(3*p-2*w)*l._x,N._y=6*(p-w)*y._y+(3*p-4*w+1)*c._y+6*(-p+w)*A._y+(3*p-2*w)*l._y,N._z=6*(p-w)*y._z+(3*p-4*w+1)*c._z+6*(-p+w)*A._z+(3*p-2*w)*l._z,N._w=6*(p-w)*y._w+(3*p-4*w+1)*c._w+6*(-p+w)*A._w+(3*p-2*w)*l._w,N._isDirty=!0,N}static Normalize(y){const c=D.Zero();return D.NormalizeToRef(y,c),c}static NormalizeToRef(y,c){return y.normalizeToRef(c),c}static Clamp(y,c,A){const l=new D;return D.ClampToRef(y,c,A,l),l}static ClampToRef(y,c,A,l){return l.Ec((0,h.Clamp)(y.x,c.x,A.x),(0,h.Clamp)(y.y,c.y,A.y),(0,h.Clamp)(y.z,c.z,A.z),(0,h.Clamp)(y.w,c.w,A.w))}static Random(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new D((0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c))}static RandomToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ec((0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c),(0,h.RandomRange)(y,c))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(y,c){return Math.sqrt(D.DistanceSquared(y,c))}static DistanceSquared(y,c){const A=y.x-c.x,l=y.y-c.y,w=y.z-c.z,N=y.w-c.w;return A*A+l*l+w*w+N*N}static Center(y,c){return D.CenterToRef(y,c,D.Zero())}static CenterToRef(y,c,A){return A.Ec((y.x+c.x)/2,(y.y+c.y)/2,(y.z+c.z)/2,(y.w+c.w)/2)}}D._V8PerformanceHack=new D(.5,.5,.5,.5),Object.defineProperties(D.prototype,{dimension:{value:[4]},rank:{value:1}});class t{static get Use64Bits(){return p.c.MatrixUse64Bits}get m(){return this.kc}markAsUpdated(){this.updateFlag=I._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(y){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2],l=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=y,this._isIdentity3x2=y||A,this._isIdentityDirty=!this._isIdentity&&c,this._isIdentity3x2Dirty=!this._isIdentity3x2&&l}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,p.c.MatrixTrackPrecisionChange&&p.c.MatrixTrackedMatrices.push(this),this.kc=new p.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const y=this.kc;this._isIdentity=1===y[0]&&0===y[1]&&0===y[2]&&0===y[3]&&0===y[4]&&1===y[5]&&0===y[6]&&0===y[7]&&0===y[8]&&0===y[9]&&1===y[10]&&0===y[11]&&0===y[12]&&0===y[13]&&0===y[14]&&1===y[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.kc[0]||1!==this.kc[5]||1!==this.kc[15]||0!==this.kc[1]||0!==this.kc[2]||0!==this.kc[3]||0!==this.kc[4]||0!==this.kc[6]||0!==this.kc[7]||0!==this.kc[8]||0!==this.kc[9]||0!==this.kc[10]||0!==this.kc[11]||0!==this.kc[12]||0!==this.kc[13]||0!==this.kc[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const y=this.kc,c=y[0],A=y[1],l=y[2],w=y[3],N=y[4],p=y[5],W=y[6],h=y[7],I=y[8],q=y[9],o=y[10],O=y[11],L=y[12],i=y[13],H=y[14],P=y[15],D=o*P-H*O,t=q*P-i*O,s=q*H-i*o,B=I*P-L*O,X=I*H-o*L,C=I*i-L*q;return c*+(p*D-W*t+h*s)+A*-(N*D-W*B+h*X)+l*+(N*t-p*B+h*C)+w*-(N*s-p*X+W*C)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!y)return this.kc;const A=this.kc;for(let l=0;l<16;l++)y[c+l]=A[l];return this}fc(){return this.kc}nA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(y,c,this)}Ec(){for(var y=arguments.length,c=new Array(y),A=0;A<y;A++)c[A]=arguments[A];return t.FromArrayToRef(c,0,this)}set(){const y=this.kc;for(let c=0;c<16;c++)y[c]=c<0||arguments.length<=c?void 0:arguments[c];return this.markAsUpdated(),this}vc(y){const c=this.kc;for(let A=0;A<16;A++)c[A]=y;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return t.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(y){const c=new t;return this.addToRef(y,c),c}addToRef(y,c){const A=this.kc,l=c.kc,w=y.m;for(let N=0;N<16;N++)l[N]=A[N]+w[N];return c.markAsUpdated(),c}addToSelf(y){const c=this.kc,A=y.m;return c[0]+=A[0],c[1]+=A[1],c[2]+=A[2],c[3]+=A[3],c[4]+=A[4],c[5]+=A[5],c[6]+=A[6],c[7]+=A[7],c[8]+=A[8],c[9]+=A[9],c[10]+=A[10],c[11]+=A[11],c[12]+=A[12],c[13]+=A[13],c[14]+=A[14],c[15]+=A[15],this.markAsUpdated(),this}addInPlace(y){const c=this.kc,A=y.m;for(let l=0;l<16;l++)c[l]+=A[l];return this.markAsUpdated(),this}addInPlaceFromFloats(){const y=this.kc;for(let c=0;c<16;c++)y[c]+=c<0||arguments.length<=c?void 0:arguments[c];return this.markAsUpdated(),this}xc(y){const c=this.kc,A=y.m;for(let l=0;l<16;l++)c[l]-=A[l];return this.markAsUpdated(),this}subtractToRef(y,c){const A=this.kc,l=y.m,w=c.kc;for(let N=0;N<16;N++)w[N]=A[N]-l[N];return c.markAsUpdated(),c}uo(y){const c=this.kc,A=y.m;for(let l=0;l<16;l++)c[l]-=A[l];return this.markAsUpdated(),this}subtractFromFloats(){for(var y=arguments.length,c=new Array(y),A=0;A<y;A++)c[A]=arguments[A];return this.subtractFromFloatsToRef(...c,new t)}subtractFromFloatsToRef(){for(var y=arguments.length,c=new Array(y),A=0;A<y;A++)c[A]=arguments[A];const l=c.pop(),w=this.kc,N=l.kc,p=c;for(let W=0;W<16;W++)N[W]=w[W]-p[W];return l.markAsUpdated(),l}invertToRef(y){return!0===this._isIdentity?(t.IdentityToRef(y),y):(O(this,y.fc())?y.markAsUpdated():y.p(this),y)}addAtIndex(y,c){return this.kc[y]+=c,this.markAsUpdated(),this}multiplyAtIndex(y,c){return this.kc[y]*=c,this.markAsUpdated(),this}setTranslationFromFloats(y,c,A){return this.kc[12]=y,this.kc[13]=c,this.kc[14]=A,this.markAsUpdated(),this}addTranslationFromFloats(y,c,A){return this.kc[12]+=y,this.kc[13]+=c,this.kc[14]+=A,this.markAsUpdated(),this}setTranslation(y){return this.setTranslationFromFloats(y._x,y._y,y._z)}getTranslation(){return new H(this.kc[12],this.kc[13],this.kc[14])}getTranslationToRef(y){return y.x=this.kc[12],y.y=this.kc[13],y.z=this.kc[14],y}removeRotationAndScaling(){const y=this.m;return t.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,y[12],y[13],y[14],y[15],this),this._updateIdentityStatus(0===y[12]&&0===y[13]&&0===y[14]&&1===y[15]),this}p(y){y.copyToArray(this.kc);const c=y;return this.updateFlag=c.updateFlag,this._updateIdentityStatus(c._isIdentity,c._isIdentityDirty,c._isIdentity3x2,c._isIdentity3x2Dirty),this}copyToArray(y){return o(this,y,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(y){const c=new t;return this.multiplyToRef(y,c),c}multiplyInPlace(y){const c=this.kc,A=y.m;for(let l=0;l<16;l++)c[l]*=A[l];return this.markAsUpdated(),this}multiplyByFloats(){const y=this.kc;for(let c=0;c<16;c++)y[c]*=c<0||arguments.length<=c?void 0:arguments[c];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var y=arguments.length,c=new Array(y),A=0;A<y;A++)c[A]=arguments[A];const l=c.pop(),w=this.kc,N=l.kc,p=c;for(let W=0;W<16;W++)N[W]=w[W]*p[W];return l.markAsUpdated(),l}multiplyToRef(y,c){return this._isIdentity?(c.p(y),c):y._isIdentity?(c.p(this),c):(this.multiplyToArray(y,c.kc,0),c.markAsUpdated(),c)}multiplyToArray(y,c,A){return q(this,y,c,A),this}divide(y){return this.divideToRef(y,new t)}divideToRef(y,c){const A=this.kc,l=y.m,w=c.kc;for(let N=0;N<16;N++)w[N]=A[N]/l[N];return c.markAsUpdated(),c}divideInPlace(y){const c=this.kc,A=y.m;for(let l=0;l<16;l++)c[l]/=A[l];return this.markAsUpdated(),this}minimizeInPlace(y){const c=this.kc,A=y.m;for(let l=0;l<16;l++)c[l]=Math.min(c[l],A[l]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const y=this.kc;for(let c=0;c<16;c++)y[c]=Math.min(y[c],c<0||arguments.length<=c?void 0:arguments[c]);return this.markAsUpdated(),this}maximizeInPlace(y){const c=this.kc,A=y.m;for(let l=0;l<16;l++)c[l]=Math.min(c[l],A[l]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const y=this.kc;for(let c=0;c<16;c++)y[c]=Math.min(y[c],c<0||arguments.length<=c?void 0:arguments[c]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new t)}negateInPlace(){const y=this.kc;for(let c=0;c<16;c++)y[c]=-y[c];return this.markAsUpdated(),this}negateToRef(y){const c=this.kc,A=y.kc;for(let l=0;l<16;l++)A[l]=-c[l];return y.markAsUpdated(),y}equals(y){const c=y;if(!c)return!1;if((this._isIdentity||c._isIdentity)&&!this._isIdentityDirty&&!c._isIdentityDirty)return this._isIdentity&&c._isIdentity;const A=this.m,l=c.m;return A[0]===l[0]&&A[1]===l[1]&&A[2]===l[2]&&A[3]===l[3]&&A[4]===l[4]&&A[5]===l[5]&&A[6]===l[6]&&A[7]===l[7]&&A[8]===l[8]&&A[9]===l[9]&&A[10]===l[10]&&A[11]===l[11]&&A[12]===l[12]&&A[13]===l[13]&&A[14]===l[14]&&A[15]===l[15]}equalsWithEpsilon(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const A=this.kc,l=y.m;for(let w=0;w<16;w++)if(!(0,h.WithinEpsilon)(A[w],l[w],c))return!1;return!0}equalsToFloats(){const y=this.kc;for(let c=0;c<16;c++)if(y[c]!=(c<0||arguments.length<=c?void 0:arguments[c]))return!1;return!0}floor(){return this.floorToRef(new t)}floorToRef(y){const c=this.kc,A=y.kc;for(let l=0;l<16;l++)A[l]=Math.floor(c[l]);return y.markAsUpdated(),y}fract(){return this.fractToRef(new t)}fractToRef(y){const c=this.kc,A=y.kc;for(let l=0;l<16;l++)A[l]=c[l]-Math.floor(c[l]);return y.markAsUpdated(),y}clone(){const y=new t;return y.p(this),y}getClassName(){return"Matrix"}getHashCode(){let y=L(this.kc[0]);for(let c=1;c<16;c++)y=397*y^L(this.kc[c]);return y}decomposeToTransformNode(y){return y.rotationQuaternion=y.rotationQuaternion||new D,this.decompose(y.bc,y.rotationQuaternion,y.position)}decompose(y,c,A,l){let w=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return A&&A.vc(0),y&&y.vc(1),c&&c.Ec(0,0,0,1),!0;const N=this.kc;if(A&&A.Ec(N[12],N[13],N[14]),(y=y||s.gc[0]).x=Math.sqrt(N[0]*N[0]+N[1]*N[1]+N[2]*N[2]),y.y=Math.sqrt(N[4]*N[4]+N[5]*N[5]+N[6]*N[6]),y.z=Math.sqrt(N[8]*N[8]+N[9]*N[9]+N[10]*N[10]),l){const c=(w?l.absoluteScaling.x:l.bc.x)<0?-1:1,A=(w?l.absoluteScaling.y:l.bc.y)<0?-1:1,N=(w?l.absoluteScaling.z:l.bc.z)<0?-1:1;y.x*=c,y.y*=A,y.z*=N}else this.determinant()<=0&&(y.y*=-1);if(0===y._x||0===y._y||0===y._z)return c&&c.Ec(0,0,0,1),!1;if(c){const A=1/y._x,l=1/y._y,w=1/y._z;t.FromValuesToRef(N[0]*A,N[1]*A,N[2]*A,0,N[4]*l,N[5]*l,N[6]*l,0,N[8]*w,N[9]*w,N[10]*w,0,0,0,0,1,s.Matrix[0]),D.FromRotationMatrixToRef(s.Matrix[0],c)}return!0}getRow(y){if(y<0||y>3)return null;const c=4*y;return new P(this.kc[c+0],this.kc[c+1],this.kc[c+2],this.kc[c+3])}getRowToRef(y,c){if(y>=0&&y<=3){const A=4*y;c.x=this.kc[A+0],c.y=this.kc[A+1],c.z=this.kc[A+2],c.w=this.kc[A+3]}return c}setRow(y,c){return this.setRowFromFloats(y,c.x,c.y,c.z,c.w)}transpose(){const y=new t;return t.TransposeToRef(this,y),y}transposeToRef(y){return t.TransposeToRef(this,y),y}setRowFromFloats(y,c,A,l,w){if(y<0||y>3)return this;const N=4*y;return this.kc[N+0]=c,this.kc[N+1]=A,this.kc[N+2]=l,this.kc[N+3]=w,this.markAsUpdated(),this}scale(y){const c=new t;return this.scaleToRef(y,c),c}scaleToRef(y,c){for(let A=0;A<16;A++)c.kc[A]=this.kc[A]*y;return c.markAsUpdated(),c}scaleAndAddToRef(y,c){for(let A=0;A<16;A++)c.kc[A]+=this.kc[A]*y;return c.markAsUpdated(),c}scaleInPlace(y){const c=this.kc;for(let A=0;A<16;A++)c[A]*=y;return this.markAsUpdated(),this}toNormalMatrix(y){const c=s.Matrix[0];this.invertToRef(c),c.transposeToRef(y);const A=y.kc;return t.FromValuesToRef(A[0],A[1],A[2],0,A[4],A[5],A[6],0,A[8],A[9],A[10],0,0,0,0,1,y),y}getRotationMatrix(){const y=new t;return this.getRotationMatrixToRef(y),y}getRotationMatrixToRef(y){const c=s.gc[0];if(!this.decompose(c))return t.IdentityToRef(y),y;const A=this.kc,l=1/c._x,w=1/c._y,N=1/c._z;return t.FromValuesToRef(A[0]*l,A[1]*l,A[2]*l,0,A[4]*w,A[5]*w,A[6]*w,0,A[8]*N,A[9]*N,A[10]*N,0,0,0,0,1,y),y}toggleModelMatrixHandInPlace(){const y=this.kc;return y[2]*=-1,y[6]*=-1,y[8]*=-1,y[9]*=-1,y[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const y=this.kc;return y[8]*=-1,y[9]*=-1,y[10]*=-1,y[11]*=-1,this.markAsUpdated(),this}static yA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const A=new t;return t.FromArrayToRef(y,c,A),A}static FromArrayToRef(y,c,A){for(let l=0;l<16;l++)A.kc[l]=y[l+c];return A.markAsUpdated(),A}static FromFloat32ArrayToRefScaled(y,c,A,l){return l.kc[0]=y[0+c]*A,l.kc[1]=y[1+c]*A,l.kc[2]=y[2+c]*A,l.kc[3]=y[3+c]*A,l.kc[4]=y[4+c]*A,l.kc[5]=y[5+c]*A,l.kc[6]=y[6+c]*A,l.kc[7]=y[7+c]*A,l.kc[8]=y[8+c]*A,l.kc[9]=y[9+c]*A,l.kc[10]=y[10+c]*A,l.kc[11]=y[11+c]*A,l.kc[12]=y[12+c]*A,l.kc[13]=y[13+c]*A,l.kc[14]=y[14+c]*A,l.kc[15]=y[15+c]*A,l.markAsUpdated(),l}static get IdentityReadOnly(){return t._IdentityReadOnly}static FromValuesToRef(y,c,A,l,w,N,p,W,h,I,q,o,O,L,i,H,P){const D=P.kc;D[0]=y,D[1]=c,D[2]=A,D[3]=l,D[4]=w,D[5]=N,D[6]=p,D[7]=W,D[8]=h,D[9]=I,D[10]=q,D[11]=o,D[12]=O,D[13]=L,D[14]=i,D[15]=H,P.markAsUpdated()}static FromValues(y,c,A,l,w,N,p,W,h,I,q,o,O,L,i,H){const P=new t,D=P.kc;return D[0]=y,D[1]=c,D[2]=A,D[3]=l,D[4]=w,D[5]=N,D[6]=p,D[7]=W,D[8]=h,D[9]=I,D[10]=q,D[11]=o,D[12]=O,D[13]=L,D[14]=i,D[15]=H,P.markAsUpdated(),P}static Compose(y,c,A){const l=new t;return t.ComposeToRef(y,c,A,l),l}static ComposeToRef(y,c,A,l){const w=l.kc,N=c._x,p=c._y,W=c._z,h=c._w,I=N+N,q=p+p,o=W+W,O=N*I,L=N*q,i=N*o,H=p*q,P=p*o,D=W*o,t=h*I,s=h*q,B=h*o,X=y._x,C=y._y,K=y._z;return w[0]=(1-(H+D))*X,w[1]=(L+B)*X,w[2]=(i-s)*X,w[3]=0,w[4]=(L-B)*C,w[5]=(1-(O+D))*C,w[6]=(P+t)*C,w[7]=0,w[8]=(i+s)*K,w[9]=(P-t)*K,w[10]=(1-(O+H))*K,w[11]=0,w[12]=A._x,w[13]=A._y,w[14]=A._z,w[15]=1,l.markAsUpdated(),l}static Identity(){const y=t.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return y._updateIdentityStatus(!0),y}static IdentityToRef(y){return t.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,y),y._updateIdentityStatus(!0),y}static Zero(){const y=t.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return y._updateIdentityStatus(!1),y}static RotationX(y){const c=new t;return t.RotationXToRef(y,c),c}static Invert(y){const c=new t;return y.invertToRef(c),c}static RotationXToRef(y,c){const A=Math.sin(y),l=Math.cos(y);return t.FromValuesToRef(1,0,0,0,0,l,A,0,0,-A,l,0,0,0,0,1,c),c._updateIdentityStatus(1===l&&0===A),c}static RotationY(y){const c=new t;return t.RotationYToRef(y,c),c}static RotationYToRef(y,c){const A=Math.sin(y),l=Math.cos(y);return t.FromValuesToRef(l,0,-A,0,0,1,0,0,A,0,l,0,0,0,0,1,c),c._updateIdentityStatus(1===l&&0===A),c}static RotationZ(y){const c=new t;return t.RotationZToRef(y,c),c}static RotationZToRef(y,c){const A=Math.sin(y),l=Math.cos(y);return t.FromValuesToRef(l,A,0,0,-A,l,0,0,0,0,1,0,0,0,0,1,c),c._updateIdentityStatus(1===l&&0===A),c}static RotationAxis(y,c){const A=new t;return t.RotationAxisToRef(y,c,A),A}static RotationAxisToRef(y,c,A){const l=Math.sin(-c),w=Math.cos(-c),N=1-w;y=y.normalizeToRef(s.gc[0]);const p=A.kc;return p[0]=y._x*y._x*N+w,p[1]=y._x*y._y*N-y._z*l,p[2]=y._x*y._z*N+y._y*l,p[3]=0,p[4]=y._y*y._x*N+y._z*l,p[5]=y._y*y._y*N+w,p[6]=y._y*y._z*N-y._x*l,p[7]=0,p[8]=y._z*y._x*N-y._y*l,p[9]=y._z*y._y*N+y._x*l,p[10]=y._z*y._z*N+w,p[11]=0,p[12]=0,p[13]=0,p[14]=0,p[15]=1,A.markAsUpdated(),A}static RotationAlignToRef(y,c,A){let w=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const N=H.Dot(c,y),p=A.kc;if(N<-1+l.b)p[0]=-1,p[1]=0,p[2]=0,p[3]=0,p[4]=0,p[5]=w?1:-1,p[6]=0,p[7]=0,p[8]=0,p[9]=0,p[10]=w?-1:1,p[11]=0;else{const A=H.Cross(c,y),l=1/(1+N);p[0]=A._x*A._x*l+N,p[1]=A._y*A._x*l-A._z,p[2]=A._z*A._x*l+A._y,p[3]=0,p[4]=A._x*A._y*l+A._z,p[5]=A._y*A._y*l+N,p[6]=A._z*A._y*l-A._x,p[7]=0,p[8]=A._x*A._z*l-A._y,p[9]=A._y*A._z*l+A._x,p[10]=A._z*A._z*l+N,p[11]=0}return p[12]=0,p[13]=0,p[14]=0,p[15]=1,A.markAsUpdated(),A}static RotationYawPitchRoll(y,c,A){const l=new t;return t.RotationYawPitchRollToRef(y,c,A,l),l}static RotationYawPitchRollToRef(y,c,A,l){return D.RotationYawPitchRollToRef(y,c,A,s.Quaternion[0]),s.Quaternion[0].toRotationMatrix(l),l}static Scaling(y,c,A){const l=new t;return t.ScalingToRef(y,c,A,l),l}static ScalingToRef(y,c,A,l){return t.FromValuesToRef(y,0,0,0,0,c,0,0,0,0,A,0,0,0,0,1,l),l._updateIdentityStatus(1===y&&1===c&&1===A),l}static Translation(y,c,A){const l=new t;return t.TranslationToRef(y,c,A,l),l}static TranslationToRef(y,c,A,l){return t.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,y,c,A,1,l),l._updateIdentityStatus(0===y&&0===c&&0===A),l}static Lerp(y,c,A){const l=new t;return t.LerpToRef(y,c,A,l),l}static LerpToRef(y,c,A,l){const w=l.kc,N=y.m,p=c.m;for(let W=0;W<16;W++)w[W]=N[W]*(1-A)+p[W]*A;return l.markAsUpdated(),l}static DecomposeLerp(y,c,A){const l=new t;return t.DecomposeLerpToRef(y,c,A,l),l}static DecomposeLerpToRef(y,c,A,l){const w=s.gc[0],N=s.Quaternion[0],p=s.gc[1];y.decompose(w,N,p);const W=s.gc[2],h=s.Quaternion[1],I=s.gc[3];c.decompose(W,h,I);const q=s.gc[4];H.LerpToRef(w,W,A,q);const o=s.Quaternion[2];D.SlerpToRef(N,h,A,o);const O=s.gc[5];return H.LerpToRef(p,I,A,O),t.ComposeToRef(q,o,O,l),l}static LookAtLH(y,c,A){const l=new t;return t.LookAtLHToRef(y,c,A,l),l}static LookAtLHToRef(y,c,A,l){const w=s.gc[0],N=s.gc[1],p=s.gc[2];c.subtractToRef(y,p),p.normalize(),H.CrossToRef(A,p,w);const W=w.lengthSquared();0===W?w.x=1:w.normalizeFromLength(Math.sqrt(W)),H.CrossToRef(p,w,N),N.normalize();const h=-H.Dot(w,y),I=-H.Dot(N,y),q=-H.Dot(p,y);return t.FromValuesToRef(w._x,N._x,p._x,0,w._y,N._y,p._y,0,w._z,N._z,p._z,0,h,I,q,1,l),l}static LookAtRH(y,c,A){const l=new t;return t.LookAtRHToRef(y,c,A,l),l}static LookAtRHToRef(y,c,A,l){const w=s.gc[0],N=s.gc[1],p=s.gc[2];y.subtractToRef(c,p),p.normalize(),H.CrossToRef(A,p,w);const W=w.lengthSquared();0===W?w.x=1:w.normalizeFromLength(Math.sqrt(W)),H.CrossToRef(p,w,N),N.normalize();const h=-H.Dot(w,y),I=-H.Dot(N,y),q=-H.Dot(p,y);return t.FromValuesToRef(w._x,N._x,p._x,0,w._y,N._y,p._y,0,w._z,N._z,p._z,0,h,I,q,1,l),l}static LookDirectionLH(y,c){const A=new t;return t.LookDirectionLHToRef(y,c,A),A}static LookDirectionLHToRef(y,c,A){const l=s.gc[0];l.p(y),l.scaleInPlace(-1);const w=s.gc[1];return H.CrossToRef(c,l,w),t.FromValuesToRef(w._x,w._y,w._z,0,c._x,c._y,c._z,0,l._x,l._y,l._z,0,0,0,0,1,A),A}static LookDirectionRH(y,c){const A=new t;return t.LookDirectionRHToRef(y,c,A),A}static LookDirectionRHToRef(y,c,A){const l=s.gc[2];return H.CrossToRef(c,y,l),t.FromValuesToRef(l._x,l._y,l._z,0,c._x,c._y,c._z,0,y._x,y._y,y._z,0,0,0,0,1,A),A}static OrthoLH(y,c,A,l,w){const N=new t;return t.OrthoLHToRef(y,c,A,l,N,w),N}static OrthoLHToRef(y,c,A,l,w,N){const p=2/y,W=2/c,h=2/(l-A),I=-(l+A)/(l-A);return t.FromValuesToRef(p,0,0,0,0,W,0,0,0,0,h,0,0,0,I,1,w),N&&w.multiplyToRef(X,w),w._updateIdentityStatus(1===p&&1===W&&1===h&&0===I),w}static OrthoOffCenterLH(y,c,A,l,w,N,p){const W=new t;return t.OrthoOffCenterLHToRef(y,c,A,l,w,N,W,p),W}static OrthoOffCenterLHToRef(y,c,A,l,w,N,p,W){const h=2/(c-y),I=2/(l-A),q=2/(N-w),o=-(N+w)/(N-w),O=(y+c)/(y-c),L=(l+A)/(A-l);return t.FromValuesToRef(h,0,0,0,0,I,0,0,0,0,q,0,O,L,o,1,p),W&&p.multiplyToRef(X,p),p.markAsUpdated(),p}static ObliqueOffCenterLHToRef(y,c,A,l,w,N,p,W,h,I,q){const o=-p*Math.cos(W),O=-p*Math.sin(W);return t.TranslationToRef(0,0,-h,s.Matrix[1]),t.FromValuesToRef(1,0,0,0,0,1,0,0,o,O,1,0,0,0,0,1,s.Matrix[0]),s.Matrix[1].multiplyToRef(s.Matrix[0],s.Matrix[0]),t.TranslationToRef(0,0,h,s.Matrix[1]),s.Matrix[0].multiplyToRef(s.Matrix[1],s.Matrix[0]),t.OrthoOffCenterLHToRef(y,c,A,l,w,N,I,q),s.Matrix[0].multiplyToRef(I,I),I}static OrthoOffCenterRH(y,c,A,l,w,N,p){const W=new t;return t.OrthoOffCenterRHToRef(y,c,A,l,w,N,W,p),W}static OrthoOffCenterRHToRef(y,c,A,l,w,N,p,W){return t.OrthoOffCenterLHToRef(y,c,A,l,w,N,p,W),p.kc[10]*=-1,p}static ObliqueOffCenterRHToRef(y,c,A,l,w,N,p,W,h,I,q){const o=p*Math.cos(W),O=p*Math.sin(W);return t.TranslationToRef(0,0,h,s.Matrix[1]),t.FromValuesToRef(1,0,0,0,0,1,0,0,o,O,1,0,0,0,0,1,s.Matrix[0]),s.Matrix[1].multiplyToRef(s.Matrix[0],s.Matrix[0]),t.TranslationToRef(0,0,-h,s.Matrix[1]),s.Matrix[0].multiplyToRef(s.Matrix[1],s.Matrix[0]),t.OrthoOffCenterRHToRef(y,c,A,l,w,N,I,q),s.Matrix[0].multiplyToRef(I,I),I}static PerspectiveLH(y,c,A,l,w){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const p=new t,W=2*A/y,h=2*A/c,I=(l+A)/(l-A),q=-2*l*A/(l-A),o=Math.tan(N);return t.FromValuesToRef(W,0,0,0,0,h,0,o,0,0,I,1,0,0,q,0,p),w&&p.multiplyToRef(X,p),p._updateIdentityStatus(!1),p}static PerspectiveFovLH(y,c,A,l,w){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,p=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const W=new t;return t.PerspectiveFovLHToRef(y,c,A,l,W,!0,w,N,p),W}static PerspectiveFovLHToRef(y,c,A,l,w){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],p=arguments.length>6?arguments[6]:void 0,W=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,h=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const I=A,q=l,o=1/Math.tan(.5*y),O=N?o/c:o,L=N?o:o*c,i=h&&0===I?-1:0!==q?(q+I)/(q-I):1,H=h&&0===I?2*q:0!==q?-2*q*I/(q-I):-2*I,P=Math.tan(W);return t.FromValuesToRef(O,0,0,0,0,L,0,P,0,0,i,1,0,0,H,0,w),p&&w.multiplyToRef(X,w),w._updateIdentityStatus(!1),w}static PerspectiveFovReverseLHToRef(y,c,A,l,w){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],p=arguments.length>6?arguments[6]:void 0,W=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const h=1/Math.tan(.5*y),I=N?h/c:h,q=N?h:h*c,o=Math.tan(W);return t.FromValuesToRef(I,0,0,0,0,q,0,o,0,0,-A,1,0,0,1,0,w),p&&w.multiplyToRef(X,w),w._updateIdentityStatus(!1),w}static PerspectiveFovRH(y,c,A,l,w){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,p=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const W=new t;return t.PerspectiveFovRHToRef(y,c,A,l,W,!0,w,N,p),W}static PerspectiveFovRHToRef(y,c,A,l,w){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],p=arguments.length>6?arguments[6]:void 0,W=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,h=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const I=A,q=l,o=1/Math.tan(.5*y),O=N?o/c:o,L=N?o:o*c,i=h&&0===I?1:0!==q?-(q+I)/(q-I):-1,H=h&&0===I?2*q:0!==q?-2*q*I/(q-I):-2*I,P=Math.tan(W);return t.FromValuesToRef(O,0,0,0,0,L,0,P,0,0,i,-1,0,0,H,0,w),p&&w.multiplyToRef(X,w),w._updateIdentityStatus(!1),w}static PerspectiveFovReverseRHToRef(y,c,A,l,w){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],p=arguments.length>6?arguments[6]:void 0,W=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const h=1/Math.tan(.5*y),I=N?h/c:h,q=N?h:h*c,o=Math.tan(W);return t.FromValuesToRef(I,0,0,0,0,q,0,o,0,0,-A,-1,0,0,-1,0,w),p&&w.multiplyToRef(X,w),w._updateIdentityStatus(!1),w}static GetFinalMatrix(y,c,A,l,w,N){const p=y.width,W=y.height,h=y.x,I=y.y,q=t.FromValues(p/2,0,0,0,0,-W/2,0,0,0,0,N-w,0,h+p/2,W/2+I,w,1),o=new t;return c.multiplyToRef(A,o),o.multiplyToRef(l,o),o.multiplyToRef(q,o)}static GetAsMatrix2x2(y){const c=y.m,A=[c[0],c[1],c[4],c[5]];return p.c.MatrixUse64Bits?A:new Float32Array(A)}static GetAsMatrix3x3(y){const c=y.m,A=[c[0],c[1],c[2],c[4],c[5],c[6],c[8],c[9],c[10]];return p.c.MatrixUse64Bits?A:new Float32Array(A)}static Transpose(y){const c=new t;return t.TransposeToRef(y,c),c}static TransposeToRef(y,c){const A=y.m,l=A[0],w=A[4],N=A[8],p=A[12],W=A[1],h=A[5],I=A[9],q=A[13],o=A[2],O=A[6],L=A[10],i=A[14],H=A[3],P=A[7],D=A[11],t=A[15],s=c.kc;return s[0]=l,s[1]=w,s[2]=N,s[3]=p,s[4]=W,s[5]=h,s[6]=I,s[7]=q,s[8]=o,s[9]=O,s[10]=L,s[11]=i,s[12]=H,s[13]=P,s[14]=D,s[15]=t,c.markAsUpdated(),c._updateIdentityStatus(y._isIdentity,y._isIdentityDirty),c}static Reflection(y){const c=new t;return t.ReflectionToRef(y,c),c}static ReflectionToRef(y,c){y.normalize();const A=y.normal.x,l=y.normal.y,w=y.normal.z,N=-2*A,p=-2*l,W=-2*w;return t.FromValuesToRef(N*A+1,p*A,W*A,0,N*l,p*l+1,W*l,0,N*w,p*w,W*w+1,0,N*y.d,p*y.d,W*y.d,1,c),c}static FromXYZAxesToRef(y,c,A,l){return t.FromValuesToRef(y._x,y._y,y._z,0,c._x,c._y,c._z,0,A._x,A._y,A._z,0,0,0,0,1,l),l}static FromQuaternionToRef(y,c){const A=y._x*y._x,l=y._y*y._y,w=y._z*y._z,N=y._x*y._y,p=y._z*y._w,W=y._z*y._x,h=y._y*y._w,I=y._y*y._z,q=y._x*y._w;return c.kc[0]=1-2*(l+w),c.kc[1]=2*(N+p),c.kc[2]=2*(W-h),c.kc[3]=0,c.kc[4]=2*(N-p),c.kc[5]=1-2*(w+A),c.kc[6]=2*(I+q),c.kc[7]=0,c.kc[8]=2*(W+h),c.kc[9]=2*(I-q),c.kc[10]=1-2*(l+A),c.kc[11]=0,c.kc[12]=0,c.kc[13]=0,c.kc[14]=0,c.kc[15]=1,c.markAsUpdated(),c}}t._IdentityReadOnly=t.Identity(),Object.defineProperties(t.prototype,{dimension:{value:[4,4]},rank:{value:2}});class s{}s.gc=(0,w.e)(11,H.Zero),s.Matrix=(0,w.e)(2,t.Identity),s.Quaternion=(0,w.e)(3,D.Zero);class B{}B.Vector2=(0,w.e)(3,i.Zero),B.gc=(0,w.e)(13,H.Zero),B.Vector4=(0,w.e)(3,P.Zero),B.Quaternion=(0,w.e)(3,D.Zero),B.Matrix=(0,w.e)(8,t.Identity),(0,N.f)("BABYLON.Vector2",i),(0,N.f)("BABYLON.Vector3",H),(0,N.f)("BABYLON.Vector4",P),(0,N.f)("BABYLON.Matrix",t);const X=t.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12337:(y,c,A)=>{function l(y,c){const A=[];for(let l=0;l<y;++l)A.push(c());return A}function w(y,c){return l(y,c)}A.d(c,{d:()=>l,e:()=>w,g:()=>p});const N=["push","splice","pop","shift","unshift"];function p(y,c){const A=N.map((A=>function(y,c,A){const l=y[c];if("function"!==typeof l)return null;const w=function(){const l=y.length,N=w.previous.apply(y,arguments);return A(c,l),N};return l.next=w,w.previous=l,y[c]=w,()=>{const A=w.previous;if(!A)return;const l=w.next;l?(A.next=l,l.previous=A):(A.next=void 0,y[c]=A),w.next=void 0,w.previous=void 0}}(y,A,c)));return()=>{for(const y of A)null===y||void 0===y||y()}}}}]);