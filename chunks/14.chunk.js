"use strict";(self.bjbkv7h3qsd=self.bjbkv7h3qsd||[]).push([[14],{11222:(G,A,j)=>{j.d(A,{d:()=>x,f:()=>B,h:()=>u,j:()=>k});const u=1/2.2,k=2.2,B=(1+Math.sqrt(5))/2,x=.001},11237:(G,A,j)=>{function u(G){return parseInt(G.toString().replace(/\W/g,""))}function k(G,A){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(G-A)<=j}function B(G,A,j){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return G<A-u||G>j+u}function x(G,A){return G===A?G:Math.random()*(A-G)+G}function s(G,A,j){return G+(A-G)*j}function O(G,A,j){let u=C(A-G,360);return u>180&&(u-=360),G+u*F(j)}function d(G,A,j){let u=0;return u=G!=A?F((j-G)/(A-G)):0,u}function h(G,A,j,u,k){const B=k*k,x=k*B;return G*(2*x-3*B+1)+j*(-2*x+3*B)+A*(x-2*B+k)+u*(x-B)}function H(G,A,j,u,k){const B=k*k;return 6*(B-k)*G+(3*B-4*k+1)*A+6*(-B+k)*j+(3*B-2*k)*u}function F(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(j,Math.max(A,G))}function R(G){return G-=2*Math.PI*Math.floor((G+Math.PI)/(2*Math.PI))}function U(G){const A=G.toString(16);return G<=15?("0"+A).toUpperCase():A.toUpperCase()}function S(G){if(Math.log2)return Math.floor(Math.log2(G));if(G<0)return NaN;if(0===G)return-1/0;let A=0;if(G<1){for(;G<1;)A++,G*=2;A=-A}else if(G>1)for(;G>1;)A++,G=Math.floor(G/2);return A}function C(G,A){return G-Math.floor(G/A)*A}function t(G,A,j){return(G-A)/(j-A)}function Y(G,A,j){return G*(j-A)+A}function n(G,A){let j=C(A-G,360);return j>180&&(j-=360),j}function Q(G,A){const j=C(G,2*A);return A-Math.abs(j-A)}function X(G,A,j){let u=F(j);return u=-2*u*u*u+3*u*u,A*u+G*(1-u)}function I(G,A,j){let u=0;return u=Math.abs(A-G)<=j?A:G+Math.sign(A-G)*j,u}function D(G,A,j){const u=n(G,A);let k=0;return k=-j<u&&u<j?A:I(G,A=G+u,j),k}function g(G,A,j){return(G-A)/(j-A)}function c(G,A,j){return(j-A)*G+A}function E(G,A){const j=G%A;return 0===j?A:E(A,j)}j.r(A),j.d(A,{Clamp:()=>F,DeltaAngle:()=>n,Denormalize:()=>Y,ExtractAsInt:()=>u,Hermite:()=>h,Hermite1stDerivative:()=>H,HighestCommonFactor:()=>E,ILog2:()=>S,InverseLerp:()=>d,Lerp:()=>s,LerpAngle:()=>O,MoveTowards:()=>I,MoveTowardsAngle:()=>D,Normalize:()=>t,NormalizeRadians:()=>R,OutsideRange:()=>B,PercentToRange:()=>c,PingPong:()=>Q,RandomRange:()=>x,RangeToPercent:()=>g,Repeat:()=>C,SmoothStep:()=>X,ToHex:()=>U,WithinEpsilon:()=>k})},11218:(G,A,j)=>{j.r(A),j.d(A,{Matrix:()=>Y,Quaternion:()=>t,TmpVectors:()=>Q,Vector2:()=>U,SA:()=>S,Vector4:()=>C});var u=j(11222),k=j(11228),B=j(11181),x=j(11150),s=j(11085),O=j(11237);class d{}function h(G,A,j){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const k=G.hs(),B=A.hs(),x=k[0],s=k[1],O=k[2],d=k[3],h=k[4],H=k[5],F=k[6],R=k[7],U=k[8],S=k[9],C=k[10],t=k[11],Y=k[12],n=k[13],Q=k[14],X=k[15],I=B[0],D=B[1],g=B[2],c=B[3],E=B[4],r=B[5],b=B[6],M=B[7],o=B[8],W=B[9],J=B[10],p=B[11],e=B[12],l=B[13],w=B[14],Z=B[15];j[u]=x*I+s*E+O*o+d*e,j[u+1]=x*D+s*r+O*W+d*l,j[u+2]=x*g+s*b+O*J+d*w,j[u+3]=x*c+s*M+O*p+d*Z,j[u+4]=h*I+H*E+F*o+R*e,j[u+5]=h*D+H*r+F*W+R*l,j[u+6]=h*g+H*b+F*J+R*w,j[u+7]=h*c+H*M+F*p+R*Z,j[u+8]=U*I+S*E+C*o+t*e,j[u+9]=U*D+S*r+C*W+t*l,j[u+10]=U*g+S*b+C*J+t*w,j[u+11]=U*c+S*M+C*p+t*Z,j[u+12]=Y*I+n*E+Q*o+X*e,j[u+13]=Y*D+n*r+Q*W+X*l,j[u+14]=Y*g+n*b+Q*J+X*w,j[u+15]=Y*c+n*M+Q*p+X*Z}function H(G,A){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const u=G.hs();A[j]=u[0],A[j+1]=u[1],A[j+2]=u[2],A[j+3]=u[3],A[j+4]=u[4],A[j+5]=u[5],A[j+6]=u[6],A[j+7]=u[7],A[j+8]=u[8],A[j+9]=u[9],A[j+10]=u[10],A[j+11]=u[11],A[j+12]=u[12],A[j+13]=u[13],A[j+14]=u[14],A[j+15]=u[15]}function F(G,A){const j=G.hs(),u=j[0],k=j[1],B=j[2],x=j[3],s=j[4],O=j[5],d=j[6],h=j[7],H=j[8],F=j[9],R=j[10],U=j[11],S=j[12],C=j[13],t=j[14],Y=j[15],n=R*Y-t*U,Q=F*Y-C*U,X=F*t-C*R,I=H*Y-S*U,D=H*t-R*S,g=H*C-S*F,c=+(O*n-d*Q+h*X),E=-(s*n-d*I+h*D),r=+(s*Q-O*I+h*g),b=-(s*X-O*D+d*g),M=u*c+k*E+B*r+x*b;if(0===M)return!1;const o=1/M,W=d*Y-t*h,J=O*Y-C*h,p=O*t-C*d,e=s*Y-S*h,l=s*t-S*d,w=s*C-S*O,Z=d*U-R*h,P=O*U-F*h,N=O*R-F*d,q=s*U-H*h,a=s*R-H*d,y=s*F-H*O,z=-(k*n-B*Q+x*X),f=+(u*n-B*I+x*D),v=-(u*Q-k*I+x*g),i=+(u*X-k*D+B*g),L=+(k*W-B*J+x*p),V=-(u*W-B*e+x*l),K=+(u*J-k*e+x*w),T=-(u*p-k*l+B*w),m=-(k*Z-B*P+x*N),GG=+(u*Z-B*q+x*a),AG=-(u*P-k*q+x*y),jG=+(u*N-k*a+B*y);return A[0]=c*o,A[1]=z*o,A[2]=L*o,A[3]=m*o,A[4]=E*o,A[5]=f*o,A[6]=V*o,A[7]=GG*o,A[8]=r*o,A[9]=v*o,A[10]=K*o,A[11]=AG*o,A[12]=b*o,A[13]=i*o,A[14]=T*o,A[15]=jG*o,!0}d._UpdateFlagSeed=0;const R=G=>parseInt(G.toString().replace(/\W/g,""));class U{constructor(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=G,this.y=A}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let G=R(this.x);return G=397*G^R(this.y),G}toArray(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G[A]=this.x,G[A+1]=this.y,this}Uj(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U.FromArrayToRef(G,A,this),this}hs(){return[this.x,this.y]}B(G){return this.x=G.x,this.y=G.y,this}Ys(G,A){return this.x=G,this.y=A,this}set(G,A){return this.Ys(G,A)}Qs(G){return this.Ys(G,G)}add(G){return new U(this.x+G.x,this.y+G.y)}addToRef(G,A){return A.x=this.x+G.x,A.y=this.y+G.y,A}addInPlace(G){return this.x+=G.x,this.y+=G.y,this}addInPlaceFromFloats(G,A){return this.x+=G,this.y+=A,this}addVector3(G){return new U(this.x+G.x,this.y+G.y)}CA(G){return new U(this.x-G.x,this.y-G.y)}subtractToRef(G,A){return A.x=this.x-G.x,A.y=this.y-G.y,A}LH(G){return this.x-=G.x,this.y-=G.y,this}multiplyInPlace(G){return this.x*=G.x,this.y*=G.y,this}multiply(G){return new U(this.x*G.x,this.y*G.y)}multiplyToRef(G,A){return A.x=this.x*G.x,A.y=this.y*G.y,A}multiplyByFloats(G,A){return new U(this.x*G,this.y*A)}divide(G){return new U(this.x/G.x,this.y/G.y)}divideToRef(G,A){return A.x=this.x/G.x,A.y=this.y/G.y,A}divideInPlace(G){return this.x=this.x/G.x,this.y=this.y/G.y,this}minimizeInPlace(G){return this.minimizeInPlaceFromFloats(G.x,G.y)}maximizeInPlace(G){return this.maximizeInPlaceFromFloats(G.x,G.y)}minimizeInPlaceFromFloats(G,A){return this.x=Math.min(G,this.x),this.y=Math.min(A,this.y),this}maximizeInPlaceFromFloats(G,A){return this.x=Math.max(G,this.x),this.y=Math.max(A,this.y),this}subtractFromFloats(G,A){return new U(this.x-G,this.y-A)}subtractFromFloatsToRef(G,A,j){return j.x=this.x-G,j.y=this.y-A,j}negate(){return new U(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(G){return G.x=-this.x,G.y=-this.y,G}scaleInPlace(G){return this.x*=G,this.y*=G,this}scale(G){return new U(this.x*G,this.y*G)}scaleToRef(G,A){return A.x=this.x*G,A.y=this.y*G,A}scaleAndAddToRef(G,A){return A.x+=this.x*G,A.y+=this.y*G,A}equals(G){return G&&this.x===G.x&&this.y===G.y}equalsWithEpsilon(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.d;return G&&(0,O.WithinEpsilon)(this.x,G.x,A)&&(0,O.WithinEpsilon)(this.y,G.y,A)}equalsToFloats(G,A){return this.x===G&&this.y===A}floor(){return new U(Math.floor(this.x),Math.floor(this.y))}floorToRef(G){return G.x=Math.floor(this.x),G.y=Math.floor(this.y),G}fract(){return new U(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(G){return G.x=this.x-Math.floor(this.x),G.y=this.y-Math.floor(this.y),G}rotate(G){return this.rotateToRef(G,new U)}rotateToRef(G,A){const j=Math.cos(G),u=Math.sin(G);return A.x=j*this.x-u*this.y,A.y=u*this.x+j*this.y,A}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(G){return 0===G||1===G?this:this.scaleInPlace(1/G)}normalizeToNew(){const G=new U;return this.normalizeToRef(G),G}normalizeToRef(G){const A=this.length();return 0===A&&(G.x=this.x,G.y=this.y),this.scaleToRef(1/A,G)}clone(){return new U(this.x,this.y)}dot(G){return this.x*G.x+this.y*G.y}static Zero(){return new U(0,0)}static One(){return new U(1,1)}static Random(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new U((0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A))}static RandomToRef(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ys((0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A))}static get ZeroReadOnly(){return U._ZeroReadOnly}static QA(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new U(G[A],G[A+1])}static FromArrayToRef(G,A,j){return j.x=G[A],j.y=G[A+1],j}static FromFloatsToRef(G,A,j){return j.Ys(G,A),j}static CatmullRom(G,A,j,u,k){const B=k*k,x=k*B,s=.5*(2*A.x+(-G.x+j.x)*k+(2*G.x-5*A.x+4*j.x-u.x)*B+(-G.x+3*A.x-3*j.x+u.x)*x),O=.5*(2*A.y+(-G.y+j.y)*k+(2*G.y-5*A.y+4*j.y-u.y)*B+(-G.y+3*A.y-3*j.y+u.y)*x);return new U(s,O)}static ClampToRef(G,A,j,u){return u.x=(0,O.Clamp)(G.x,A.x,j.x),u.y=(0,O.Clamp)(G.y,A.y,j.y),u}static Clamp(G,A,j){const u=(0,O.Clamp)(G.x,A.x,j.x),k=(0,O.Clamp)(G.y,A.y,j.y);return new U(u,k)}static Hermite(G,A,j,u,k){const B=k*k,x=k*B,s=2*x-3*B+1,O=-2*x+3*B,d=x-2*B+k,h=x-B,H=G.x*s+j.x*O+A.x*d+u.x*h,F=G.y*s+j.y*O+A.y*d+u.y*h;return new U(H,F)}static Hermite1stDerivative(G,A,j,u,k){return this.Hermite1stDerivativeToRef(G,A,j,u,k,new U)}static Hermite1stDerivativeToRef(G,A,j,u,k,B){const x=k*k;return B.x=6*(x-k)*G.x+(3*x-4*k+1)*A.x+6*(-x+k)*j.x+(3*x-2*k)*u.x,B.y=6*(x-k)*G.y+(3*x-4*k+1)*A.y+6*(-x+k)*j.y+(3*x-2*k)*u.y,B}static Lerp(G,A,j){return U.LerpToRef(G,A,j,new U)}static LerpToRef(G,A,j,u){return u.x=G.x+(A.x-G.x)*j,u.y=G.y+(A.y-G.y)*j,u}static Dot(G,A){return G.x*A.x+G.y*A.y}static Normalize(G){return U.NormalizeToRef(G,new U)}static NormalizeToRef(G,A){return G.normalizeToRef(A),A}static Minimize(G,A){const j=G.x<A.x?G.x:A.x,u=G.y<A.y?G.y:A.y;return new U(j,u)}static Maximize(G,A){const j=G.x>A.x?G.x:A.x,u=G.y>A.y?G.y:A.y;return new U(j,u)}static Transform(G,A){return U.TransformToRef(G,A,new U)}static TransformToRef(G,A,j){const u=A.m,k=G.x*u[0]+G.y*u[4]+u[12],B=G.x*u[1]+G.y*u[5]+u[13];return j.x=k,j.y=B,j}static PointInTriangle(G,A,j,u){const k=.5*(-j.y*u.x+A.y*(-j.x+u.x)+A.x*(j.y-u.y)+j.x*u.y),B=k<0?-1:1,x=(A.y*u.x-A.x*u.y+(u.y-A.y)*G.x+(A.x-u.x)*G.y)*B,s=(A.x*j.y-A.y*j.x+(A.y-j.y)*G.x+(j.x-A.x)*G.y)*B;return x>0&&s>0&&x+s<2*k*B}static Distance(G,A){return Math.sqrt(U.DistanceSquared(G,A))}static DistanceSquared(G,A){const j=G.x-A.x,u=G.y-A.y;return j*j+u*u}static Center(G,A){return U.CenterToRef(G,A,new U)}static CenterToRef(G,A,j){return j.Ys((G.x+A.x)/2,(G.y+A.y)/2)}static DistanceOfPointFromSegment(G,A,j){const u=U.DistanceSquared(A,j);if(0===u)return U.Distance(G,A);const k=j.CA(A),B=Math.max(0,Math.min(1,U.Dot(G.CA(A),k)/u)),x=A.add(k.multiplyByFloats(B,B));return U.Distance(G,x)}}U._V8PerformanceHack=new U(.5,.5),U._ZeroReadOnly=U.Zero(),Object.defineProperties(U.prototype,{dimension:{value:[2]},rank:{value:1}});class S{get x(){return this._x}set x(G){this._x=G,this._isDirty=!0}get y(){return this._y}set y(G){this._y=G,this._isDirty=!0}get z(){return this._z}set z(G){this._z=G,this._isDirty=!0}constructor(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=G,this._y=A,this._z=j}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"SA"}getHashCode(){let G=R(this._x);return G=397*G^R(this._y),G=397*G^R(this._z),G}hs(){return[this._x,this._y,this._z]}toArray(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G[A]=this._x,G[A+1]=this._y,G[A+2]=this._z,this}Uj(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(G,A,this),this}toQuaternion(){return t.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(G){return this._x+=G._x,this._y+=G._y,this._z+=G._z,this._isDirty=!0,this}addInPlaceFromFloats(G,A,j){return this._x+=G,this._y+=A,this._z+=j,this._isDirty=!0,this}add(G){return new S(this._x+G._x,this._y+G._y,this._z+G._z)}addToRef(G,A){return A._x=this._x+G._x,A._y=this._y+G._y,A._z=this._z+G._z,A._isDirty=!0,A}LH(G){return this._x-=G._x,this._y-=G._y,this._z-=G._z,this._isDirty=!0,this}CA(G){return new S(this._x-G._x,this._y-G._y,this._z-G._z)}subtractToRef(G,A){return this.subtractFromFloatsToRef(G._x,G._y,G._z,A)}subtractFromFloats(G,A,j){return new S(this._x-G,this._y-A,this._z-j)}subtractFromFloatsToRef(G,A,j,u){return u._x=this._x-G,u._y=this._y-A,u._z=this._z-j,u._isDirty=!0,u}negate(){return new S(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(G){return G._x=-1*this._x,G._y=-1*this._y,G._z=-1*this._z,G._isDirty=!0,G}scaleInPlace(G){return this._x*=G,this._y*=G,this._z*=G,this._isDirty=!0,this}scale(G){return new S(this._x*G,this._y*G,this._z*G)}scaleToRef(G,A){return A._x=this._x*G,A._y=this._y*G,A._z=this._z*G,A._isDirty=!0,A}getNormalToRef(G){const A=this.length();let j=Math.acos(this._y/A);const u=Math.atan2(this._z,this._x);j>Math.PI/2?j-=Math.PI/2:j+=Math.PI/2;const k=A*Math.sin(j)*Math.cos(u),B=A*Math.cos(j),x=A*Math.sin(j)*Math.sin(u);return G.set(k,B,x),G}applyRotationQuaternionToRef(G,A){const j=this._x,u=this._y,k=this._z,B=G._x,x=G._y,s=G._z,O=G._w,d=2*(x*k-s*u),h=2*(s*j-B*k),H=2*(B*u-x*j);return A._x=j+O*d+x*H-s*h,A._y=u+O*h+s*d-B*H,A._z=k+O*H+B*h-x*d,A._isDirty=!0,A}applyRotationQuaternionInPlace(G){return this.applyRotationQuaternionToRef(G,this)}applyRotationQuaternion(G){return this.applyRotationQuaternionToRef(G,new S)}scaleAndAddToRef(G,A){return A._x+=this._x*G,A._y+=this._y*G,A._z+=this._z*G,A._isDirty=!0,A}projectOnPlane(G,A){return this.projectOnPlaneToRef(G,A,new S)}projectOnPlaneToRef(G,A,j){const u=G.normal,k=G.d,B=n.SA[0];this.subtractToRef(A,B),B.normalize();const x=S.Dot(B,u);if(Math.abs(x)<1e-10)j.Qs(1/0);else{const G=-(S.Dot(A,u)+k)/x,s=B.scaleInPlace(G);A.addToRef(s,j)}return j}equals(G){return G&&this._x===G._x&&this._y===G._y&&this._z===G._z}equalsWithEpsilon(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.d;return G&&(0,O.WithinEpsilon)(this._x,G._x,A)&&(0,O.WithinEpsilon)(this._y,G._y,A)&&(0,O.WithinEpsilon)(this._z,G._z,A)}equalsToFloats(G,A,j){return this._x===G&&this._y===A&&this._z===j}multiplyInPlace(G){return this._x*=G._x,this._y*=G._y,this._z*=G._z,this._isDirty=!0,this}multiply(G){return this.multiplyByFloats(G._x,G._y,G._z)}multiplyToRef(G,A){return A._x=this._x*G._x,A._y=this._y*G._y,A._z=this._z*G._z,A._isDirty=!0,A}multiplyByFloats(G,A,j){return new S(this._x*G,this._y*A,this._z*j)}divide(G){return new S(this._x/G._x,this._y/G._y,this._z/G._z)}divideToRef(G,A){return A._x=this._x/G._x,A._y=this._y/G._y,A._z=this._z/G._z,A._isDirty=!0,A}divideInPlace(G){return this._x=this._x/G._x,this._y=this._y/G._y,this._z=this._z/G._z,this._isDirty=!0,this}minimizeInPlace(G){return this.minimizeInPlaceFromFloats(G._x,G._y,G._z)}maximizeInPlace(G){return this.maximizeInPlaceFromFloats(G._x,G._y,G._z)}minimizeInPlaceFromFloats(G,A,j){return G<this._x&&(this.x=G),A<this._y&&(this.y=A),j<this._z&&(this.z=j),this}maximizeInPlaceFromFloats(G,A,j){return G>this._x&&(this.x=G),A>this._y&&(this.y=A),j>this._z&&(this.z=j),this}isNonUniformWithinEpsilon(G){const A=Math.abs(this._x),j=Math.abs(this._y);if(!(0,O.WithinEpsilon)(A,j,G))return!0;const u=Math.abs(this._z);return!(0,O.WithinEpsilon)(A,u,G)||!(0,O.WithinEpsilon)(j,u,G)}get isNonUniform(){const G=Math.abs(this._x);if(G!==Math.abs(this._y))return!0;return G!==Math.abs(this._z)}floorToRef(G){return G._x=Math.floor(this._x),G._y=Math.floor(this._y),G._z=Math.floor(this._z),G._isDirty=!0,G}floor(){return new S(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(G){return G._x=this._x-Math.floor(this._x),G._y=this._y-Math.floor(this._y),G._z=this._z-Math.floor(this._z),G._isDirty=!0,G}fract(){return new S(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(G){if("xyz"===(G=G.toLowerCase()))return this;const A=n.SA[0].B(this);return this.x=A[G[0]],this.y=A[G[1]],this.z=A[G[2]],this}rotateByQuaternionToRef(G,A){return G.toRotationMatrix(n.Matrix[0]),S.TransformCoordinatesToRef(this,n.Matrix[0],A),A}rotateByQuaternionAroundPointToRef(G,A,j){return this.subtractToRef(A,n.SA[0]),n.SA[0].rotateByQuaternionToRef(G,n.SA[0]),A.addToRef(n.SA[0],j),j}cross(G){return S.CrossToRef(this,G,new S)}normalizeFromLength(G){return 0===G||1===G?this:this.scaleInPlace(1/G)}normalizeToNew(){return this.normalizeToRef(new S)}normalizeToRef(G){const A=this.length();return 0===A||1===A?(G._x=this._x,G._y=this._y,G._z=this._z,G._isDirty=!0,G):this.scaleToRef(1/A,G)}clone(){return new S(this._x,this._y,this._z)}B(G){return this.Ys(G._x,G._y,G._z)}Ys(G,A,j){return this._x=G,this._y=A,this._z=j,this._isDirty=!0,this}set(G,A,j){return this.Ys(G,A,j)}Qs(G){return this._x=this._y=this._z=G,this._isDirty=!0,this}static GetClipFactor(G,A,j,u){const k=S.Dot(G,j);return(k-u)/(k-S.Dot(A,j))}static GetAngleBetweenVectors(G,A,j){const u=G.normalizeToRef(n.SA[1]),k=A.normalizeToRef(n.SA[2]);let B=S.Dot(u,k);B=(0,O.Clamp)(B,-1,1);const x=Math.acos(B),s=n.SA[3];return S.CrossToRef(u,k,s),S.Dot(s,j)>0?isNaN(x)?0:x:isNaN(x)?-Math.PI:-Math.acos(B)}static GetAngleBetweenVectorsOnPlane(G,A,j){n.SA[0].B(G);const u=n.SA[0];n.SA[1].B(A);const k=n.SA[1];n.SA[2].B(j);const B=n.SA[2],x=n.SA[3],s=n.SA[4];u.normalize(),k.normalize(),B.normalize(),S.CrossToRef(B,u,x),S.CrossToRef(x,B,s);const d=Math.atan2(S.Dot(k,x),S.Dot(k,s));return(0,O.NormalizeRadians)(d)}static PitchYawRollToMoveBetweenPointsToRef(G,A,j){const u=Q.SA[0];return A.subtractToRef(G,u),j._y=Math.atan2(u.x,u.z)||0,j._x=Math.atan2(Math.sqrt(u.x**2+u.z**2),u.y)||0,j._z=0,j._isDirty=!0,j}static PitchYawRollToMoveBetweenPoints(G,A){const j=S.Zero();return S.PitchYawRollToMoveBetweenPointsToRef(G,A,j)}static SlerpToRef(G,A,j,k){j=(0,O.Clamp)(j,0,1);const B=n.SA[0],x=n.SA[1];B.B(G);const s=B.length();B.normalizeFromLength(s),x.B(A);const d=x.length();x.normalizeFromLength(d);const h=S.Dot(B,x);let H,F;if(h<1-u.d){const G=Math.acos(h),A=1/Math.sin(G);H=Math.sin((1-j)*G)*A,F=Math.sin(j*G)*A}else H=1-j,F=j;return B.scaleInPlace(H),x.scaleInPlace(F),k.B(B).addInPlace(x),k.scaleInPlace((0,O.Lerp)(s,d,j)),k}static SmoothToRef(G,A,j,u,k){return S.SlerpToRef(G,A,0===u?1:j/u,k),k}static QA(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new S(G[A],G[A+1],G[A+2])}static FromFloatArray(G,A){return S.QA(G,A)}static FromArrayToRef(G,A,j){return j._x=G[A],j._y=G[A+1],j._z=G[A+2],j._isDirty=!0,j}static FromFloatArrayToRef(G,A,j){return S.FromArrayToRef(G,A,j)}static FromFloatsToRef(G,A,j,u){return u.Ys(G,A,j),u}static Zero(){return new S(0,0,0)}static One(){return new S(1,1,1)}static Up(){return new S(0,1,0)}static get UpReadOnly(){return S._UpReadOnly}static get DownReadOnly(){return S._DownReadOnly}static get RightReadOnly(){return S._RightReadOnly}static get LeftReadOnly(){return S._LeftReadOnly}static get LeftHandedForwardReadOnly(){return S._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return S._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return S._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return S._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return S._ZeroReadOnly}static get OneReadOnly(){return S._OneReadOnly}static Down(){return new S(0,-1,0)}static Forward(){return new S(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new S(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new S(1,0,0)}static Left(){return new S(-1,0,0)}static Random(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new S((0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A))}static RandomToRef(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ys((0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A))}static TransformCoordinates(G,A){const j=S.Zero();return S.TransformCoordinatesToRef(G,A,j),j}static TransformCoordinatesToRef(G,A,j){return S.TransformCoordinatesFromFloatsToRef(G._x,G._y,G._z,A,j),j}static TransformCoordinatesFromFloatsToRef(G,A,j,u,k){const B=u.m,x=G*B[0]+A*B[4]+j*B[8]+B[12],s=G*B[1]+A*B[5]+j*B[9]+B[13],O=G*B[2]+A*B[6]+j*B[10]+B[14],d=1/(G*B[3]+A*B[7]+j*B[11]+B[15]);return k._x=x*d,k._y=s*d,k._z=O*d,k._isDirty=!0,k}static TransformNormal(G,A){const j=S.Zero();return S.TransformNormalToRef(G,A,j),j}static TransformNormalToRef(G,A,j){return this.TransformNormalFromFloatsToRef(G._x,G._y,G._z,A,j),j}static TransformNormalFromFloatsToRef(G,A,j,u,k){const B=u.m;return k._x=G*B[0]+A*B[4]+j*B[8],k._y=G*B[1]+A*B[5]+j*B[9],k._z=G*B[2]+A*B[6]+j*B[10],k._isDirty=!0,k}static CatmullRom(G,A,j,u,k){const B=k*k,x=k*B,s=.5*(2*A._x+(-G._x+j._x)*k+(2*G._x-5*A._x+4*j._x-u._x)*B+(-G._x+3*A._x-3*j._x+u._x)*x),O=.5*(2*A._y+(-G._y+j._y)*k+(2*G._y-5*A._y+4*j._y-u._y)*B+(-G._y+3*A._y-3*j._y+u._y)*x),d=.5*(2*A._z+(-G._z+j._z)*k+(2*G._z-5*A._z+4*j._z-u._z)*B+(-G._z+3*A._z-3*j._z+u._z)*x);return new S(s,O,d)}static Clamp(G,A,j){const u=new S;return S.ClampToRef(G,A,j,u),u}static ClampToRef(G,A,j,u){let k=G._x;k=k>j._x?j._x:k,k=k<A._x?A._x:k;let B=G._y;B=B>j._y?j._y:B,B=B<A._y?A._y:B;let x=G._z;return x=x>j._z?j._z:x,x=x<A._z?A._z:x,u.Ys(k,B,x),u}static CheckExtends(G,A,j){A.minimizeInPlace(G),j.maximizeInPlace(G)}static Hermite(G,A,j,u,k){const B=k*k,x=k*B,s=2*x-3*B+1,O=-2*x+3*B,d=x-2*B+k,h=x-B,H=G._x*s+j._x*O+A._x*d+u._x*h,F=G._y*s+j._y*O+A._y*d+u._y*h,R=G._z*s+j._z*O+A._z*d+u._z*h;return new S(H,F,R)}static Hermite1stDerivative(G,A,j,u,k){const B=new S;return this.Hermite1stDerivativeToRef(G,A,j,u,k,B),B}static Hermite1stDerivativeToRef(G,A,j,u,k,B){const x=k*k;return B._x=6*(x-k)*G._x+(3*x-4*k+1)*A._x+6*(-x+k)*j._x+(3*x-2*k)*u._x,B._y=6*(x-k)*G._y+(3*x-4*k+1)*A._y+6*(-x+k)*j._y+(3*x-2*k)*u._y,B._z=6*(x-k)*G._z+(3*x-4*k+1)*A._z+6*(-x+k)*j._z+(3*x-2*k)*u._z,B._isDirty=!0,B}static Lerp(G,A,j){const u=new S(0,0,0);return S.LerpToRef(G,A,j,u),u}static LerpToRef(G,A,j,u){return u._x=G._x+(A._x-G._x)*j,u._y=G._y+(A._y-G._y)*j,u._z=G._z+(A._z-G._z)*j,u._isDirty=!0,u}static Dot(G,A){return G._x*A._x+G._y*A._y+G._z*A._z}dot(G){return this._x*G._x+this._y*G._y+this._z*G._z}static Cross(G,A){const j=new S;return S.CrossToRef(G,A,j),j}static CrossToRef(G,A,j){const u=G._y*A._z-G._z*A._y,k=G._z*A._x-G._x*A._z,B=G._x*A._y-G._y*A._x;return j.Ys(u,k,B),j}static Normalize(G){const A=S.Zero();return S.NormalizeToRef(G,A),A}static NormalizeToRef(G,A){return G.normalizeToRef(A),A}static Project(G,A,j,u){const k=new S;return S.ProjectToRef(G,A,j,u,k),k}static ProjectToRef(G,A,j,u,k){var B;const x=u.width,O=u.height,d=u.x,h=u.y,H=n.Matrix[1],F=null===(B=s.d.LastCreatedEngine)||void 0===B?void 0:B.isNDCHalfZRange,R=F?1:.5,U=F?0:.5;Y.FromValuesToRef(x/2,0,0,0,0,-O/2,0,0,0,0,R,0,d+x/2,O/2+h,U,1,H);const C=n.Matrix[0];return A.multiplyToRef(j,C),C.multiplyToRef(H,C),S.TransformCoordinatesToRef(G,C,k),k}static Reflect(G,A){return this.ReflectToRef(G,A,new S)}static ReflectToRef(G,A,j){const u=Q.SA[0];return u.B(A).scaleInPlace(2*S.Dot(G,A)),j.B(G).LH(u)}static _UnprojectFromInvertedMatrixToRef(G,A,j){S.TransformCoordinatesToRef(G,A,j);const u=A.m,k=G._x*u[3]+G._y*u[7]+G._z*u[11]+u[15];return(0,O.WithinEpsilon)(k,1)&&j.scaleInPlace(1/k),j}static UnprojectFromTransform(G,A,j,u,k){return this.Unproject(G,A,j,u,k,Y.IdentityReadOnly)}static Unproject(G,A,j,u,k,B){const x=new S;return S.UnprojectToRef(G,A,j,u,k,B,x),x}static UnprojectToRef(G,A,j,u,k,B,x){return S.UnprojectFloatsToRef(G._x,G._y,G._z,A,j,u,k,B,x),x}static UnprojectFloatsToRef(G,A,j,u,k,B,x,O,d){var h;const H=n.Matrix[0];B.multiplyToRef(x,H),H.multiplyToRef(O,H),H.invert();const F=n.SA[0];return F.x=G/u*2-1,F.y=-(A/k*2-1),null!==(h=s.d.LastCreatedEngine)&&void 0!==h&&h.isNDCHalfZRange?F.z=j:F.z=2*j-1,S._UnprojectFromInvertedMatrixToRef(F,H,d),d}static Minimize(G,A){const j=new S;return j.B(G),j.minimizeInPlace(A),j}static Maximize(G,A){const j=new S;return j.B(G),j.maximizeInPlace(A),j}static Distance(G,A){return Math.sqrt(S.DistanceSquared(G,A))}static DistanceSquared(G,A){const j=G._x-A._x,u=G._y-A._y,k=G._z-A._z;return j*j+u*u+k*k}static ProjectOnTriangleToRef(G,A,j,k,B){const x=n.SA[0],s=n.SA[1],d=n.SA[2],h=n.SA[3],H=n.SA[4];j.subtractToRef(A,x),k.subtractToRef(A,s),k.subtractToRef(j,d);const F=x.length(),R=s.length(),U=d.length();if(F<u.d||R<u.d||U<u.d)return B.B(A),S.Distance(G,A);G.subtractToRef(A,H),S.CrossToRef(x,s,h);const C=h.length();if(C<u.d)return B.B(A),S.Distance(G,A);h.normalizeFromLength(C);let t=H.length();if(t<u.d)return B.B(A),0;H.normalizeFromLength(t);const Y=S.Dot(h,H),Q=n.SA[5],X=n.SA[6];Q.B(h).scaleInPlace(-t*Y),X.B(G).addInPlace(Q);const I=n.SA[4],D=n.SA[5],g=n.SA[7],c=n.SA[8];I.B(x).scaleInPlace(1/F),c.B(s).scaleInPlace(1/R),I.addInPlace(c).scaleInPlace(-1),D.B(x).scaleInPlace(-1/F),c.B(d).scaleInPlace(1/U),D.addInPlace(c).scaleInPlace(-1),g.B(d).scaleInPlace(-1/U),c.B(s).scaleInPlace(-1/R),g.addInPlace(c).scaleInPlace(-1);const E=n.SA[9];let r;E.B(X).LH(A),S.CrossToRef(I,E,c),r=S.Dot(c,h);const b=r;E.B(X).LH(j),S.CrossToRef(D,E,c),r=S.Dot(c,h);const M=r;E.B(X).LH(k),S.CrossToRef(g,E,c),r=S.Dot(c,h);const o=r,W=n.SA[10];let J,p;b>0&&M<0?(W.B(x),J=A,p=j):M>0&&o<0?(W.B(d),J=j,p=k):(W.B(s).scaleInPlace(-1),J=k,p=A);const e=n.SA[9],l=n.SA[4];J.subtractToRef(X,c),p.subtractToRef(X,e),S.CrossToRef(c,e,l);if(!(S.Dot(l,h)<0))return B.B(X),Math.abs(t*Y);const w=n.SA[5];S.CrossToRef(W,l,w),w.normalize();const Z=n.SA[9];Z.B(J).LH(X);const P=Z.length();if(P<u.d)return B.B(J),S.Distance(G,J);Z.normalizeFromLength(P);const N=S.Dot(w,Z),q=n.SA[7];q.B(X).addInPlace(w.scaleInPlace(P*N)),c.B(q).LH(J),t=W.length(),W.normalizeFromLength(t);let a=S.Dot(c,W)/Math.max(t,u.d);return a=(0,O.Clamp)(a,0,1),q.B(J).addInPlace(W.scaleInPlace(a*t)),B.B(q),S.Distance(G,q)}static Center(G,A){return S.CenterToRef(G,A,S.Zero())}static CenterToRef(G,A,j){return j.Ys((G._x+A._x)/2,(G._y+A._y)/2,(G._z+A._z)/2)}static RotationFromAxis(G,A,j){const u=new S;return S.RotationFromAxisToRef(G,A,j,u),u}static RotationFromAxisToRef(G,A,j,u){const k=n.Quaternion[0];return t.RotationQuaternionFromAxisToRef(G,A,j,k),k.toEulerAnglesToRef(u),u}}S._V8PerformanceHack=new S(.5,.5,.5),S._UpReadOnly=S.Up(),S._DownReadOnly=S.Down(),S._LeftHandedForwardReadOnly=S.Forward(!1),S._RightHandedForwardReadOnly=S.Forward(!0),S._LeftHandedBackwardReadOnly=S.Backward(!1),S._RightHandedBackwardReadOnly=S.Backward(!0),S._RightReadOnly=S.Right(),S._LeftReadOnly=S.Left(),S._ZeroReadOnly=S.Zero(),S._OneReadOnly=S.One(),Object.defineProperties(S.prototype,{dimension:{value:[3]},rank:{value:1}});class C{get x(){return this._x}set x(G){this._x=G,this._isDirty=!0}get y(){return this._y}set y(G){this._y=G,this._isDirty=!0}get z(){return this._z}set z(G){this._z=G,this._isDirty=!0}get w(){return this._w}set w(G){this._w=G,this._isDirty=!0}constructor(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=G,this._y=A,this._z=j,this._w=u}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let G=R(this._x);return G=397*G^R(this._y),G=397*G^R(this._z),G=397*G^R(this._w),G}hs(){return[this._x,this._y,this._z,this._w]}toArray(G,A){return void 0===A&&(A=0),G[A]=this._x,G[A+1]=this._y,G[A+2]=this._z,G[A+3]=this._w,this}Uj(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C.FromArrayToRef(G,A,this),this}addInPlace(G){return this.x+=G._x,this.y+=G._y,this.z+=G._z,this.w+=G._w,this}addInPlaceFromFloats(G,A,j,u){return this.x+=G,this.y+=A,this.z+=j,this.w+=u,this}add(G){return new C(this._x+G.x,this._y+G.y,this._z+G.z,this._w+G.w)}addToRef(G,A){return A.x=this._x+G.x,A.y=this._y+G.y,A.z=this._z+G.z,A.w=this._w+G.w,A}LH(G){return this.x-=G.x,this.y-=G.y,this.z-=G.z,this.w-=G.w,this}CA(G){return new C(this._x-G.x,this._y-G.y,this._z-G.z,this._w-G.w)}subtractToRef(G,A){return A.x=this._x-G.x,A.y=this._y-G.y,A.z=this._z-G.z,A.w=this._w-G.w,A}subtractFromFloats(G,A,j,u){return new C(this._x-G,this._y-A,this._z-j,this._w-u)}subtractFromFloatsToRef(G,A,j,u,k){return k.x=this._x-G,k.y=this._y-A,k.z=this._z-j,k.w=this._w-u,k}negate(){return new C(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(G){return G.x=-this._x,G.y=-this._y,G.z=-this._z,G.w=-this._w,G}scaleInPlace(G){return this.x*=G,this.y*=G,this.z*=G,this.w*=G,this}scale(G){return new C(this._x*G,this._y*G,this._z*G,this._w*G)}scaleToRef(G,A){return A.x=this._x*G,A.y=this._y*G,A.z=this._z*G,A.w=this._w*G,A}scaleAndAddToRef(G,A){return A.x+=this._x*G,A.y+=this._y*G,A.z+=this._z*G,A.w+=this._w*G,A}equals(G){return G&&this._x===G.x&&this._y===G.y&&this._z===G.z&&this._w===G.w}equalsWithEpsilon(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.d;return G&&(0,O.WithinEpsilon)(this._x,G.x,A)&&(0,O.WithinEpsilon)(this._y,G.y,A)&&(0,O.WithinEpsilon)(this._z,G.z,A)&&(0,O.WithinEpsilon)(this._w,G.w,A)}equalsToFloats(G,A,j,u){return this._x===G&&this._y===A&&this._z===j&&this._w===u}multiplyInPlace(G){return this.x*=G.x,this.y*=G.y,this.z*=G.z,this.w*=G.w,this}multiply(G){return new C(this._x*G.x,this._y*G.y,this._z*G.z,this._w*G.w)}multiplyToRef(G,A){return A.x=this._x*G.x,A.y=this._y*G.y,A.z=this._z*G.z,A.w=this._w*G.w,A}multiplyByFloats(G,A,j,u){return new C(this._x*G,this._y*A,this._z*j,this._w*u)}divide(G){return new C(this._x/G.x,this._y/G.y,this._z/G.z,this._w/G.w)}divideToRef(G,A){return A.x=this._x/G.x,A.y=this._y/G.y,A.z=this._z/G.z,A.w=this._w/G.w,A}divideInPlace(G){return this.divideToRef(G,this)}minimizeInPlace(G){return G.x<this._x&&(this.x=G.x),G.y<this._y&&(this.y=G.y),G.z<this._z&&(this.z=G.z),G.w<this._w&&(this.w=G.w),this}maximizeInPlace(G){return G.x>this._x&&(this.x=G.x),G.y>this._y&&(this.y=G.y),G.z>this._z&&(this.z=G.z),G.w>this._w&&(this.w=G.w),this}minimizeInPlaceFromFloats(G,A,j,u){return this.x=Math.min(G,this._x),this.y=Math.min(A,this._y),this.z=Math.min(j,this._z),this.w=Math.min(u,this._w),this}maximizeInPlaceFromFloats(G,A,j,u){return this.x=Math.max(G,this._x),this.y=Math.max(A,this._y),this.z=Math.max(j,this._z),this.w=Math.max(u,this._w),this}floorToRef(G){return G.x=Math.floor(this._x),G.y=Math.floor(this._y),G.z=Math.floor(this._z),G.w=Math.floor(this._w),G}floor(){return new C(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(G){return G.x=this._x-Math.floor(this._x),G.y=this._y-Math.floor(this._y),G.z=this._z-Math.floor(this._z),G.w=this._w-Math.floor(this._w),G}fract(){return new C(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(G){return 0===G||1===G?this:this.scaleInPlace(1/G)}normalizeToNew(){return this.normalizeToRef(new C)}normalizeToRef(G){const A=this.length();return 0===A||1===A?(G.x=this._x,G.y=this._y,G.z=this._z,G.w=this._w,G):this.scaleToRef(1/A,G)}toVector3(){return new S(this._x,this._y,this._z)}clone(){return new C(this._x,this._y,this._z,this._w)}B(G){return this.x=G.x,this.y=G.y,this.z=G.z,this.w=G.w,this}Ys(G,A,j,u){return this.x=G,this.y=A,this.z=j,this.w=u,this}set(G,A,j,u){return this.Ys(G,A,j,u)}Qs(G){return this.x=this.y=this.z=this.w=G,this}dot(G){return this._x*G.x+this._y*G.y+this._z*G.z+this._w*G.w}static QA(G,A){return A||(A=0),new C(G[A],G[A+1],G[A+2],G[A+3])}static FromArrayToRef(G,A,j){return j.x=G[A],j.y=G[A+1],j.z=G[A+2],j.w=G[A+3],j}static FromFloatArrayToRef(G,A,j){return C.FromArrayToRef(G,A,j),j}static FromFloatsToRef(G,A,j,u,k){return k.x=G,k.y=A,k.z=j,k.w=u,k}static Zero(){return new C(0,0,0,0)}static One(){return new C(1,1,1,1)}static Random(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new C((0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A))}static RandomToRef(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,j=arguments.length>2?arguments[2]:void 0;return j.x=(0,O.RandomRange)(G,A),j.y=(0,O.RandomRange)(G,A),j.z=(0,O.RandomRange)(G,A),j.w=(0,O.RandomRange)(G,A),j}static Clamp(G,A,j){return C.ClampToRef(G,A,j,new C)}static ClampToRef(G,A,j,u){return u.x=(0,O.Clamp)(G.x,A.x,j.x),u.y=(0,O.Clamp)(G.y,A.y,j.y),u.z=(0,O.Clamp)(G.z,A.z,j.z),u.w=(0,O.Clamp)(G.w,A.w,j.w),u}static CheckExtends(G,A,j){A.minimizeInPlace(G),j.maximizeInPlace(G)}static get ZeroReadOnly(){return C._ZeroReadOnly}static Normalize(G){return C.NormalizeToRef(G,new C)}static NormalizeToRef(G,A){return G.normalizeToRef(A),A}static Minimize(G,A){const j=new C;return j.B(G),j.minimizeInPlace(A),j}static Maximize(G,A){const j=new C;return j.B(G),j.maximizeInPlace(A),j}static Distance(G,A){return Math.sqrt(C.DistanceSquared(G,A))}static DistanceSquared(G,A){const j=G.x-A.x,u=G.y-A.y,k=G.z-A.z,B=G.w-A.w;return j*j+u*u+k*k+B*B}static Center(G,A){return C.CenterToRef(G,A,new C)}static CenterToRef(G,A,j){return j.x=(G.x+A.x)/2,j.y=(G.y+A.y)/2,j.z=(G.z+A.z)/2,j.w=(G.w+A.w)/2,j}static TransformCoordinates(G,A){return C.TransformCoordinatesToRef(G,A,new C)}static TransformCoordinatesToRef(G,A,j){return C.TransformCoordinatesFromFloatsToRef(G._x,G._y,G._z,A,j),j}static TransformCoordinatesFromFloatsToRef(G,A,j,u,k){const B=u.m,x=G*B[0]+A*B[4]+j*B[8]+B[12],s=G*B[1]+A*B[5]+j*B[9]+B[13],O=G*B[2]+A*B[6]+j*B[10]+B[14],d=G*B[3]+A*B[7]+j*B[11]+B[15];return k.x=x,k.y=s,k.z=O,k.w=d,k}static TransformNormal(G,A){return C.TransformNormalToRef(G,A,new C)}static TransformNormalToRef(G,A,j){const u=A.m,k=G.x*u[0]+G.y*u[4]+G.z*u[8],B=G.x*u[1]+G.y*u[5]+G.z*u[9],x=G.x*u[2]+G.y*u[6]+G.z*u[10];return j.x=k,j.y=B,j.z=x,j.w=G.w,j}static TransformNormalFromFloatsToRef(G,A,j,u,k,B){const x=k.m;return B.x=G*x[0]+A*x[4]+j*x[8],B.y=G*x[1]+A*x[5]+j*x[9],B.z=G*x[2]+A*x[6]+j*x[10],B.w=u,B}static FromVector3(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new C(G._x,G._y,G._z,A)}static Dot(G,A){return G.x*A.x+G.y*A.y+G.z*A.z+G.w*A.w}}C._V8PerformanceHack=new C(.5,.5,.5,.5),C._ZeroReadOnly=C.Zero(),Object.defineProperties(C.prototype,{dimension:{value:[4]},rank:{value:1}});class t{get x(){return this._x}set x(G){this._x=G,this._isDirty=!0}get y(){return this._y}set y(G){this._y=G,this._isDirty=!0}get z(){return this._z}set z(G){this._z=G,this._isDirty=!0}get w(){return this._w}set w(G){this._w=G,this._isDirty=!0}constructor(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=G,this._y=A,this._z=j,this._w=u}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let G=R(this._x);return G=397*G^R(this._y),G=397*G^R(this._z),G=397*G^R(this._w),G}hs(){return[this._x,this._y,this._z,this._w]}toArray(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G[A]=this._x,G[A+1]=this._y,G[A+2]=this._z,G[A+3]=this._w,this}Uj(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(G,A,this)}equals(G){return G&&this._x===G._x&&this._y===G._y&&this._z===G._z&&this._w===G._w}equalsWithEpsilon(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.d;return G&&(0,O.WithinEpsilon)(this._x,G._x,A)&&(0,O.WithinEpsilon)(this._y,G._y,A)&&(0,O.WithinEpsilon)(this._z,G._z,A)&&(0,O.WithinEpsilon)(this._w,G._w,A)}isApprox(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.d;return G&&((0,O.WithinEpsilon)(this._x,G._x,A)&&(0,O.WithinEpsilon)(this._y,G._y,A)&&(0,O.WithinEpsilon)(this._z,G._z,A)&&(0,O.WithinEpsilon)(this._w,G._w,A)||(0,O.WithinEpsilon)(this._x,-G._x,A)&&(0,O.WithinEpsilon)(this._y,-G._y,A)&&(0,O.WithinEpsilon)(this._z,-G._z,A)&&(0,O.WithinEpsilon)(this._w,-G._w,A))}clone(){return new t(this._x,this._y,this._z,this._w)}B(G){return this._x=G._x,this._y=G._y,this._z=G._z,this._w=G._w,this._isDirty=!0,this}Ys(G,A,j,u){return this._x=G,this._y=A,this._z=j,this._w=u,this._isDirty=!0,this}set(G,A,j,u){return this.Ys(G,A,j,u)}Qs(G){return this.Ys(G,G,G,G)}add(G){return new t(this._x+G._x,this._y+G._y,this._z+G._z,this._w+G._w)}addInPlace(G){return this._x+=G._x,this._y+=G._y,this._z+=G._z,this._w+=G._w,this._isDirty=!0,this}addToRef(G,A){return A._x=this._x+G._x,A._y=this._y+G._y,A._z=this._z+G._z,A._w=this._w+G._w,A._isDirty=!0,A}addInPlaceFromFloats(G,A,j,u){return this._x+=G,this._y+=A,this._z+=j,this._w+=u,this._isDirty=!0,this}subtractToRef(G,A){return A._x=this._x-G._x,A._y=this._y-G._y,A._z=this._z-G._z,A._w=this._w-G._w,A._isDirty=!0,A}subtractFromFloats(G,A,j,u){return this.subtractFromFloatsToRef(G,A,j,u,new t)}subtractFromFloatsToRef(G,A,j,u,k){return k._x=this._x-G,k._y=this._y-A,k._z=this._z-j,k._w=this._w-u,k._isDirty=!0,k}CA(G){return new t(this._x-G._x,this._y-G._y,this._z-G._z,this._w-G._w)}LH(G){return this._x-=G._x,this._y-=G._y,this._z-=G._z,this._w-=G._w,this._isDirty=!0,this}scale(G){return new t(this._x*G,this._y*G,this._z*G,this._w*G)}scaleToRef(G,A){return A._x=this._x*G,A._y=this._y*G,A._z=this._z*G,A._w=this._w*G,A._isDirty=!0,A}scaleInPlace(G){return this._x*=G,this._y*=G,this._z*=G,this._w*=G,this._isDirty=!0,this}scaleAndAddToRef(G,A){return A._x+=this._x*G,A._y+=this._y*G,A._z+=this._z*G,A._w+=this._w*G,A._isDirty=!0,A}multiply(G){const A=new t(0,0,0,1);return this.multiplyToRef(G,A),A}multiplyToRef(G,A){const j=this._x*G._w+this._y*G._z-this._z*G._y+this._w*G._x,u=-this._x*G._z+this._y*G._w+this._z*G._x+this._w*G._y,k=this._x*G._y-this._y*G._x+this._z*G._w+this._w*G._z,B=-this._x*G._x-this._y*G._y-this._z*G._z+this._w*G._w;return A.Ys(j,u,k,B),A}multiplyInPlace(G){return this.multiplyToRef(G,this)}multiplyByFloats(G,A,j,u){return this._x*=G,this._y*=A,this._z*=j,this._w*=u,this._isDirty=!0,this}divide(G){throw new ReferenceError("Can not divide a quaternion")}divideToRef(G,A){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(G){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new t)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(G){return G._x=-this._x,G._y=-this._y,G._z=-this._z,G._w=-this._w,G._isDirty=!0,G}equalsToFloats(G,A,j,u){return this._x===G&&this._y===A&&this._z===j&&this._w===u}floorToRef(G){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(G){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(G){return G.Ys(-this._x,-this._y,-this._z,this._w),G}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new t(-this._x,-this._y,-this._z,this._w)}invert(){const G=this.conjugate(),A=this.lengthSquared();return 0==A||1==A||G.scaleInPlace(1/A),G}invertInPlace(){this.conjugateInPlace();const G=this.lengthSquared();return 0==G||1==G||this.scaleInPlace(1/G),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(G){return 0===G||1===G?this:this.scaleInPlace(1/G)}normalizeToNew(){const G=new t(0,0,0,1);return this.normalizeToRef(G),G}normalizeToRef(G){const A=this.length();return 0===A||1===A?G.Ys(this._x,this._y,this._z,this._w):this.scaleToRef(1/A,G)}toEulerAngles(){const G=S.Zero();return this.toEulerAnglesToRef(G),G}toEulerAnglesToRef(G){const A=this._z,j=this._x,u=this._y,k=this._w,B=u*A-j*k,x=.4999999;if(B<-x)G._y=2*Math.atan2(u,k),G._x=Math.PI/2,G._z=0,G._isDirty=!0;else if(B>x)G._y=2*Math.atan2(u,k),G._x=-Math.PI/2,G._z=0,G._isDirty=!0;else{const x=k*k,s=A*A,O=j*j,d=u*u;G._z=Math.atan2(2*(j*u+A*k),-s-O+d+x),G._x=Math.asin(-2*B),G._y=Math.atan2(2*(A*j+u*k),s-O-d+x),G._isDirty=!0}return G}toAlphaBetaGammaToRef(G){const A=this._z,j=this._x,u=this._y,k=this._w,B=Math.sqrt(j*j+u*u),x=Math.sqrt(A*A+k*k),s=2*Math.atan2(B,x),O=2*Math.atan2(A,k),d=2*Math.atan2(u,j),h=(O+d)/2,H=(O-d)/2;return G.set(H,s,h),G}toRotationMatrix(G){return Y.FromQuaternionToRef(this,G),G}fromRotationMatrix(G){return t.FromRotationMatrixToRef(G,this),this}dot(G){return this._x*G._x+this._y*G._y+this._z*G._z+this._w*G._w}toAxisAngle(){const G=S.Zero();return{axis:G,angle:this.toAxisAngleToRef(G)}}toAxisAngleToRef(G){let A=0;const j=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),u=this._w;return j>0?(A=2*Math.atan2(j,u),G.set(this._x/j,this._y/j,this._z/j)):(A=0,G.set(1,0,0)),A}static FromRotationMatrix(G){const A=new t;return t.FromRotationMatrixToRef(G,A),A}static FromRotationMatrixToRef(G,A){const j=G.m,u=j[0],k=j[4],B=j[8],x=j[1],s=j[5],O=j[9],d=j[2],h=j[6],H=j[10],F=u+s+H;let R;return F>0?(R=.5/Math.sqrt(F+1),A._w=.25/R,A._x=(h-O)*R,A._y=(B-d)*R,A._z=(x-k)*R,A._isDirty=!0):u>s&&u>H?(R=2*Math.sqrt(1+u-s-H),A._w=(h-O)/R,A._x=.25*R,A._y=(k+x)/R,A._z=(B+d)/R,A._isDirty=!0):s>H?(R=2*Math.sqrt(1+s-u-H),A._w=(B-d)/R,A._x=(k+x)/R,A._y=.25*R,A._z=(O+h)/R,A._isDirty=!0):(R=2*Math.sqrt(1+H-u-s),A._w=(x-k)/R,A._x=(B+d)/R,A._y=(O+h)/R,A._z=.25*R,A._isDirty=!0),A}static Dot(G,A){return G._x*A._x+G._y*A._y+G._z*A._z+G._w*A._w}static AreClose(G,A){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const u=t.Dot(G,A);return 1-u*u<=j}static SmoothToRef(G,A,j,u,k){let B=0===u?1:j/u;return B=(0,O.Clamp)(B,0,1),t.SlerpToRef(G,A,B,k),k}static Zero(){return new t(0,0,0,0)}static Inverse(G){return new t(-G._x,-G._y,-G._z,G._w)}static InverseToRef(G,A){return A.set(-G._x,-G._y,-G._z,G._w),A}static Identity(){return new t(0,0,0,1)}static IsIdentity(G){return G&&0===G._x&&0===G._y&&0===G._z&&1===G._w}static RotationAxis(G,A){return t.RotationAxisToRef(G,A,new t)}static RotationAxisToRef(G,A,j){j._w=Math.cos(A/2);const u=Math.sin(A/2)/G.length();return j._x=G._x*u,j._y=G._y*u,j._z=G._z*u,j._isDirty=!0,j}static QA(G,A){return A||(A=0),new t(G[A],G[A+1],G[A+2],G[A+3])}static FromArrayToRef(G,A,j){return j._x=G[A],j._y=G[A+1],j._z=G[A+2],j._w=G[A+3],j._isDirty=!0,j}static FromFloatsToRef(G,A,j,u,k){return k.Ys(G,A,j,u),k}static FromEulerAngles(G,A,j){const u=new t;return t.RotationYawPitchRollToRef(A,G,j,u),u}static FromEulerAnglesToRef(G,A,j,u){return t.RotationYawPitchRollToRef(A,G,j,u),u}static FromEulerVector(G){const A=new t;return t.RotationYawPitchRollToRef(G._y,G._x,G._z,A),A}static FromEulerVectorToRef(G,A){return t.RotationYawPitchRollToRef(G._y,G._x,G._z,A),A}static FromUnitVectorsToRef(G,A,j){let k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:u.d;const B=S.Dot(G,A)+1;return B<k?Math.abs(G.x)>Math.abs(G.z)?j.set(-G.y,G.x,0,0):j.set(0,-G.z,G.y,0):(S.CrossToRef(G,A,Q.SA[0]),j.set(Q.SA[0].x,Q.SA[0].y,Q.SA[0].z,B)),j.normalize()}static RotationYawPitchRoll(G,A,j){const u=new t;return t.RotationYawPitchRollToRef(G,A,j,u),u}static RotationYawPitchRollToRef(G,A,j,u){const k=.5*j,B=.5*A,x=.5*G,s=Math.sin(k),O=Math.cos(k),d=Math.sin(B),h=Math.cos(B),H=Math.sin(x),F=Math.cos(x);return u._x=F*d*O+H*h*s,u._y=H*h*O-F*d*s,u._z=F*h*s-H*d*O,u._w=F*h*O+H*d*s,u._isDirty=!0,u}static RotationAlphaBetaGamma(G,A,j){const u=new t;return t.RotationAlphaBetaGammaToRef(G,A,j,u),u}static RotationAlphaBetaGammaToRef(G,A,j,u){const k=.5*(j+G),B=.5*(j-G),x=.5*A;return u._x=Math.cos(B)*Math.sin(x),u._y=Math.sin(B)*Math.sin(x),u._z=Math.sin(k)*Math.cos(x),u._w=Math.cos(k)*Math.cos(x),u._isDirty=!0,u}static RotationQuaternionFromAxis(G,A,j){const u=new t(0,0,0,0);return t.RotationQuaternionFromAxisToRef(G,A,j,u),u}static RotationQuaternionFromAxisToRef(G,A,j,u){const k=n.Matrix[0];return G=G.normalizeToRef(n.SA[0]),A=A.normalizeToRef(n.SA[1]),j=j.normalizeToRef(n.SA[2]),Y.FromXYZAxesToRef(G,A,j,k),t.FromRotationMatrixToRef(k,u),u}static FromLookDirectionLH(G,A){const j=new t;return t.FromLookDirectionLHToRef(G,A,j),j}static FromLookDirectionLHToRef(G,A,j){const u=n.Matrix[0];return Y.LookDirectionLHToRef(G,A,u),t.FromRotationMatrixToRef(u,j),j}static FromLookDirectionRH(G,A){const j=new t;return t.FromLookDirectionRHToRef(G,A,j),j}static FromLookDirectionRHToRef(G,A,j){const u=n.Matrix[0];return Y.LookDirectionRHToRef(G,A,u),t.FromRotationMatrixToRef(u,j)}static Slerp(G,A,j){const u=t.Identity();return t.SlerpToRef(G,A,j,u),u}static SlerpToRef(G,A,j,u){let k,B,x=G._x*A._x+G._y*A._y+G._z*A._z+G._w*A._w,s=!1;if(x<0&&(s=!0,x=-x),x>.999999)B=1-j,k=s?-j:j;else{const G=Math.acos(x),A=1/Math.sin(G);B=Math.sin((1-j)*G)*A,k=s?-Math.sin(j*G)*A:Math.sin(j*G)*A}return u._x=B*G._x+k*A._x,u._y=B*G._y+k*A._y,u._z=B*G._z+k*A._z,u._w=B*G._w+k*A._w,u._isDirty=!0,u}static Hermite(G,A,j,u,k){const B=k*k,x=k*B,s=2*x-3*B+1,O=-2*x+3*B,d=x-2*B+k,h=x-B,H=G._x*s+j._x*O+A._x*d+u._x*h,F=G._y*s+j._y*O+A._y*d+u._y*h,R=G._z*s+j._z*O+A._z*d+u._z*h,U=G._w*s+j._w*O+A._w*d+u._w*h;return new t(H,F,R,U)}static Hermite1stDerivative(G,A,j,u,k){const B=new t;return this.Hermite1stDerivativeToRef(G,A,j,u,k,B),B}static Hermite1stDerivativeToRef(G,A,j,u,k,B){const x=k*k;return B._x=6*(x-k)*G._x+(3*x-4*k+1)*A._x+6*(-x+k)*j._x+(3*x-2*k)*u._x,B._y=6*(x-k)*G._y+(3*x-4*k+1)*A._y+6*(-x+k)*j._y+(3*x-2*k)*u._y,B._z=6*(x-k)*G._z+(3*x-4*k+1)*A._z+6*(-x+k)*j._z+(3*x-2*k)*u._z,B._w=6*(x-k)*G._w+(3*x-4*k+1)*A._w+6*(-x+k)*j._w+(3*x-2*k)*u._w,B._isDirty=!0,B}static Normalize(G){const A=t.Zero();return t.NormalizeToRef(G,A),A}static NormalizeToRef(G,A){return G.normalizeToRef(A),A}static Clamp(G,A,j){const u=new t;return t.ClampToRef(G,A,j,u),u}static ClampToRef(G,A,j,u){return u.Ys((0,O.Clamp)(G.x,A.x,j.x),(0,O.Clamp)(G.y,A.y,j.y),(0,O.Clamp)(G.z,A.z,j.z),(0,O.Clamp)(G.w,A.w,j.w))}static Random(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new t((0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A))}static RandomToRef(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ys((0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A),(0,O.RandomRange)(G,A))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(G,A){return Math.sqrt(t.DistanceSquared(G,A))}static DistanceSquared(G,A){const j=G.x-A.x,u=G.y-A.y,k=G.z-A.z,B=G.w-A.w;return j*j+u*u+k*k+B*B}static Center(G,A){return t.CenterToRef(G,A,t.Zero())}static CenterToRef(G,A,j){return j.Ys((G.x+A.x)/2,(G.y+A.y)/2,(G.z+A.z)/2,(G.w+A.w)/2)}}t._V8PerformanceHack=new t(.5,.5,.5,.5),Object.defineProperties(t.prototype,{dimension:{value:[4]},rank:{value:1}});class Y{static get Use64Bits(){return x.c.MatrixUse64Bits}get m(){return this.Bs}markAsUpdated(){this.updateFlag=d._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(G){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1],j=arguments.length>2&&void 0!==arguments[2]&&arguments[2],u=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=G,this._isIdentity3x2=G||j,this._isIdentityDirty=!this._isIdentity&&A,this._isIdentity3x2Dirty=!this._isIdentity3x2&&u}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,x.c.MatrixTrackPrecisionChange&&x.c.MatrixTrackedMatrices.push(this),this.Bs=new x.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const G=this.Bs;this._isIdentity=1===G[0]&&0===G[1]&&0===G[2]&&0===G[3]&&0===G[4]&&1===G[5]&&0===G[6]&&0===G[7]&&0===G[8]&&0===G[9]&&1===G[10]&&0===G[11]&&0===G[12]&&0===G[13]&&0===G[14]&&1===G[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Bs[0]||1!==this.Bs[5]||1!==this.Bs[15]||0!==this.Bs[1]||0!==this.Bs[2]||0!==this.Bs[3]||0!==this.Bs[4]||0!==this.Bs[6]||0!==this.Bs[7]||0!==this.Bs[8]||0!==this.Bs[9]||0!==this.Bs[10]||0!==this.Bs[11]||0!==this.Bs[12]||0!==this.Bs[13]||0!==this.Bs[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const G=this.Bs,A=G[0],j=G[1],u=G[2],k=G[3],B=G[4],x=G[5],s=G[6],O=G[7],d=G[8],h=G[9],H=G[10],F=G[11],R=G[12],U=G[13],S=G[14],C=G[15],t=H*C-S*F,Y=h*C-U*F,n=h*S-U*H,Q=d*C-R*F,X=d*S-H*R,I=d*U-R*h;return A*+(x*t-s*Y+O*n)+j*-(B*t-s*Q+O*X)+u*+(B*Y-x*Q+O*I)+k*-(B*n-x*X+s*I)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!G)return this.Bs;const j=this.Bs;for(let u=0;u<16;u++)G[A+u]=j[u];return this}hs(){return this.Bs}Uj(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y.FromArrayToRef(G,A,this)}Ys(){for(var G=arguments.length,A=new Array(G),j=0;j<G;j++)A[j]=arguments[j];return Y.FromArrayToRef(A,0,this)}set(){const G=this.Bs;for(let A=0;A<16;A++)G[A]=A<0||arguments.length<=A?void 0:arguments[A];return this.markAsUpdated(),this}Qs(G){const A=this.Bs;for(let j=0;j<16;j++)A[j]=G;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return Y.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(G){const A=new Y;return this.addToRef(G,A),A}addToRef(G,A){const j=this.Bs,u=A.Bs,k=G.m;for(let B=0;B<16;B++)u[B]=j[B]+k[B];return A.markAsUpdated(),A}addToSelf(G){const A=this.Bs,j=G.m;return A[0]+=j[0],A[1]+=j[1],A[2]+=j[2],A[3]+=j[3],A[4]+=j[4],A[5]+=j[5],A[6]+=j[6],A[7]+=j[7],A[8]+=j[8],A[9]+=j[9],A[10]+=j[10],A[11]+=j[11],A[12]+=j[12],A[13]+=j[13],A[14]+=j[14],A[15]+=j[15],this.markAsUpdated(),this}addInPlace(G){const A=this.Bs,j=G.m;for(let u=0;u<16;u++)A[u]+=j[u];return this.markAsUpdated(),this}addInPlaceFromFloats(){const G=this.Bs;for(let A=0;A<16;A++)G[A]+=A<0||arguments.length<=A?void 0:arguments[A];return this.markAsUpdated(),this}CA(G){const A=this.Bs,j=G.m;for(let u=0;u<16;u++)A[u]-=j[u];return this.markAsUpdated(),this}subtractToRef(G,A){const j=this.Bs,u=G.m,k=A.Bs;for(let B=0;B<16;B++)k[B]=j[B]-u[B];return A.markAsUpdated(),A}LH(G){const A=this.Bs,j=G.m;for(let u=0;u<16;u++)A[u]-=j[u];return this.markAsUpdated(),this}subtractFromFloats(){for(var G=arguments.length,A=new Array(G),j=0;j<G;j++)A[j]=arguments[j];return this.subtractFromFloatsToRef(...A,new Y)}subtractFromFloatsToRef(){for(var G=arguments.length,A=new Array(G),j=0;j<G;j++)A[j]=arguments[j];const u=A.pop(),k=this.Bs,B=u.Bs,x=A;for(let s=0;s<16;s++)B[s]=k[s]-x[s];return u.markAsUpdated(),u}invertToRef(G){return!0===this._isIdentity?(Y.IdentityToRef(G),G):(F(this,G.hs())?G.markAsUpdated():G.B(this),G)}addAtIndex(G,A){return this.Bs[G]+=A,this.markAsUpdated(),this}multiplyAtIndex(G,A){return this.Bs[G]*=A,this.markAsUpdated(),this}setTranslationFromFloats(G,A,j){return this.Bs[12]=G,this.Bs[13]=A,this.Bs[14]=j,this.markAsUpdated(),this}addTranslationFromFloats(G,A,j){return this.Bs[12]+=G,this.Bs[13]+=A,this.Bs[14]+=j,this.markAsUpdated(),this}setTranslation(G){return this.setTranslationFromFloats(G._x,G._y,G._z)}getTranslation(){return new S(this.Bs[12],this.Bs[13],this.Bs[14])}getTranslationToRef(G){return G.x=this.Bs[12],G.y=this.Bs[13],G.z=this.Bs[14],G}removeRotationAndScaling(){const G=this.m;return Y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,G[12],G[13],G[14],G[15],this),this._updateIdentityStatus(0===G[12]&&0===G[13]&&0===G[14]&&1===G[15]),this}B(G){G.copyToArray(this.Bs);const A=G;return this.updateFlag=A.updateFlag,this._updateIdentityStatus(A._isIdentity,A._isIdentityDirty,A._isIdentity3x2,A._isIdentity3x2Dirty),this}copyToArray(G){return H(this,G,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(G){const A=new Y;return this.multiplyToRef(G,A),A}multiplyInPlace(G){const A=this.Bs,j=G.m;for(let u=0;u<16;u++)A[u]*=j[u];return this.markAsUpdated(),this}multiplyByFloats(){const G=this.Bs;for(let A=0;A<16;A++)G[A]*=A<0||arguments.length<=A?void 0:arguments[A];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var G=arguments.length,A=new Array(G),j=0;j<G;j++)A[j]=arguments[j];const u=A.pop(),k=this.Bs,B=u.Bs,x=A;for(let s=0;s<16;s++)B[s]=k[s]*x[s];return u.markAsUpdated(),u}multiplyToRef(G,A){return this._isIdentity?(A.B(G),A):G._isIdentity?(A.B(this),A):(this.multiplyToArray(G,A.Bs,0),A.markAsUpdated(),A)}multiplyToArray(G,A,j){return h(this,G,A,j),this}divide(G){return this.divideToRef(G,new Y)}divideToRef(G,A){const j=this.Bs,u=G.m,k=A.Bs;for(let B=0;B<16;B++)k[B]=j[B]/u[B];return A.markAsUpdated(),A}divideInPlace(G){const A=this.Bs,j=G.m;for(let u=0;u<16;u++)A[u]/=j[u];return this.markAsUpdated(),this}minimizeInPlace(G){const A=this.Bs,j=G.m;for(let u=0;u<16;u++)A[u]=Math.min(A[u],j[u]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const G=this.Bs;for(let A=0;A<16;A++)G[A]=Math.min(G[A],A<0||arguments.length<=A?void 0:arguments[A]);return this.markAsUpdated(),this}maximizeInPlace(G){const A=this.Bs,j=G.m;for(let u=0;u<16;u++)A[u]=Math.min(A[u],j[u]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const G=this.Bs;for(let A=0;A<16;A++)G[A]=Math.min(G[A],A<0||arguments.length<=A?void 0:arguments[A]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new Y)}negateInPlace(){const G=this.Bs;for(let A=0;A<16;A++)G[A]=-G[A];return this.markAsUpdated(),this}negateToRef(G){const A=this.Bs,j=G.Bs;for(let u=0;u<16;u++)j[u]=-A[u];return G.markAsUpdated(),G}equals(G){const A=G;if(!A)return!1;if((this._isIdentity||A._isIdentity)&&!this._isIdentityDirty&&!A._isIdentityDirty)return this._isIdentity&&A._isIdentity;const j=this.m,u=A.m;return j[0]===u[0]&&j[1]===u[1]&&j[2]===u[2]&&j[3]===u[3]&&j[4]===u[4]&&j[5]===u[5]&&j[6]===u[6]&&j[7]===u[7]&&j[8]===u[8]&&j[9]===u[9]&&j[10]===u[10]&&j[11]===u[11]&&j[12]===u[12]&&j[13]===u[13]&&j[14]===u[14]&&j[15]===u[15]}equalsWithEpsilon(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const j=this.Bs,u=G.m;for(let k=0;k<16;k++)if(!(0,O.WithinEpsilon)(j[k],u[k],A))return!1;return!0}equalsToFloats(){const G=this.Bs;for(let A=0;A<16;A++)if(G[A]!=(A<0||arguments.length<=A?void 0:arguments[A]))return!1;return!0}floor(){return this.floorToRef(new Y)}floorToRef(G){const A=this.Bs,j=G.Bs;for(let u=0;u<16;u++)j[u]=Math.floor(A[u]);return G.markAsUpdated(),G}fract(){return this.fractToRef(new Y)}fractToRef(G){const A=this.Bs,j=G.Bs;for(let u=0;u<16;u++)j[u]=A[u]-Math.floor(A[u]);return G.markAsUpdated(),G}clone(){const G=new Y;return G.B(this),G}getClassName(){return"Matrix"}getHashCode(){let G=R(this.Bs[0]);for(let A=1;A<16;A++)G=397*G^R(this.Bs[A]);return G}decomposeToTransformNode(G){return G.rotationQuaternion=G.rotationQuaternion||new t,this.decompose(G.ns,G.rotationQuaternion,G.position)}decompose(G,A,j,u){let k=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return j&&j.Qs(0),G&&G.Qs(1),A&&A.Ys(0,0,0,1),!0;const B=this.Bs;if(j&&j.Ys(B[12],B[13],B[14]),(G=G||n.SA[0]).x=Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]),G.y=Math.sqrt(B[4]*B[4]+B[5]*B[5]+B[6]*B[6]),G.z=Math.sqrt(B[8]*B[8]+B[9]*B[9]+B[10]*B[10]),u){const A=(k?u.absoluteScaling.x:u.ns.x)<0?-1:1,j=(k?u.absoluteScaling.y:u.ns.y)<0?-1:1,B=(k?u.absoluteScaling.z:u.ns.z)<0?-1:1;G.x*=A,G.y*=j,G.z*=B}else this.determinant()<=0&&(G.y*=-1);if(0===G._x||0===G._y||0===G._z)return A&&A.Ys(0,0,0,1),!1;if(A){const j=1/G._x,u=1/G._y,k=1/G._z;Y.FromValuesToRef(B[0]*j,B[1]*j,B[2]*j,0,B[4]*u,B[5]*u,B[6]*u,0,B[8]*k,B[9]*k,B[10]*k,0,0,0,0,1,n.Matrix[0]),t.FromRotationMatrixToRef(n.Matrix[0],A)}return!0}getRow(G){if(G<0||G>3)return null;const A=4*G;return new C(this.Bs[A+0],this.Bs[A+1],this.Bs[A+2],this.Bs[A+3])}getRowToRef(G,A){if(G>=0&&G<=3){const j=4*G;A.x=this.Bs[j+0],A.y=this.Bs[j+1],A.z=this.Bs[j+2],A.w=this.Bs[j+3]}return A}setRow(G,A){return this.setRowFromFloats(G,A.x,A.y,A.z,A.w)}transpose(){const G=new Y;return Y.TransposeToRef(this,G),G}transposeToRef(G){return Y.TransposeToRef(this,G),G}setRowFromFloats(G,A,j,u,k){if(G<0||G>3)return this;const B=4*G;return this.Bs[B+0]=A,this.Bs[B+1]=j,this.Bs[B+2]=u,this.Bs[B+3]=k,this.markAsUpdated(),this}scale(G){const A=new Y;return this.scaleToRef(G,A),A}scaleToRef(G,A){for(let j=0;j<16;j++)A.Bs[j]=this.Bs[j]*G;return A.markAsUpdated(),A}scaleAndAddToRef(G,A){for(let j=0;j<16;j++)A.Bs[j]+=this.Bs[j]*G;return A.markAsUpdated(),A}scaleInPlace(G){const A=this.Bs;for(let j=0;j<16;j++)A[j]*=G;return this.markAsUpdated(),this}toNormalMatrix(G){const A=n.Matrix[0];this.invertToRef(A),A.transposeToRef(G);const j=G.Bs;return Y.FromValuesToRef(j[0],j[1],j[2],0,j[4],j[5],j[6],0,j[8],j[9],j[10],0,0,0,0,1,G),G}getRotationMatrix(){const G=new Y;return this.getRotationMatrixToRef(G),G}getRotationMatrixToRef(G){const A=n.SA[0];if(!this.decompose(A))return Y.IdentityToRef(G),G;const j=this.Bs,u=1/A._x,k=1/A._y,B=1/A._z;return Y.FromValuesToRef(j[0]*u,j[1]*u,j[2]*u,0,j[4]*k,j[5]*k,j[6]*k,0,j[8]*B,j[9]*B,j[10]*B,0,0,0,0,1,G),G}toggleModelMatrixHandInPlace(){const G=this.Bs;return G[2]*=-1,G[6]*=-1,G[8]*=-1,G[9]*=-1,G[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const G=this.Bs;return G[8]*=-1,G[9]*=-1,G[10]*=-1,G[11]*=-1,this.markAsUpdated(),this}static QA(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const j=new Y;return Y.FromArrayToRef(G,A,j),j}static FromArrayToRef(G,A,j){for(let u=0;u<16;u++)j.Bs[u]=G[u+A];return j.markAsUpdated(),j}static FromFloat32ArrayToRefScaled(G,A,j,u){return u.Bs[0]=G[0+A]*j,u.Bs[1]=G[1+A]*j,u.Bs[2]=G[2+A]*j,u.Bs[3]=G[3+A]*j,u.Bs[4]=G[4+A]*j,u.Bs[5]=G[5+A]*j,u.Bs[6]=G[6+A]*j,u.Bs[7]=G[7+A]*j,u.Bs[8]=G[8+A]*j,u.Bs[9]=G[9+A]*j,u.Bs[10]=G[10+A]*j,u.Bs[11]=G[11+A]*j,u.Bs[12]=G[12+A]*j,u.Bs[13]=G[13+A]*j,u.Bs[14]=G[14+A]*j,u.Bs[15]=G[15+A]*j,u.markAsUpdated(),u}static get IdentityReadOnly(){return Y._IdentityReadOnly}static FromValuesToRef(G,A,j,u,k,B,x,s,O,d,h,H,F,R,U,S,C){const t=C.Bs;t[0]=G,t[1]=A,t[2]=j,t[3]=u,t[4]=k,t[5]=B,t[6]=x,t[7]=s,t[8]=O,t[9]=d,t[10]=h,t[11]=H,t[12]=F,t[13]=R,t[14]=U,t[15]=S,C.markAsUpdated()}static FromValues(G,A,j,u,k,B,x,s,O,d,h,H,F,R,U,S){const C=new Y,t=C.Bs;return t[0]=G,t[1]=A,t[2]=j,t[3]=u,t[4]=k,t[5]=B,t[6]=x,t[7]=s,t[8]=O,t[9]=d,t[10]=h,t[11]=H,t[12]=F,t[13]=R,t[14]=U,t[15]=S,C.markAsUpdated(),C}static Compose(G,A,j){const u=new Y;return Y.ComposeToRef(G,A,j,u),u}static ComposeToRef(G,A,j,u){const k=u.Bs,B=A._x,x=A._y,s=A._z,O=A._w,d=B+B,h=x+x,H=s+s,F=B*d,R=B*h,U=B*H,S=x*h,C=x*H,t=s*H,Y=O*d,n=O*h,Q=O*H,X=G._x,I=G._y,D=G._z;return k[0]=(1-(S+t))*X,k[1]=(R+Q)*X,k[2]=(U-n)*X,k[3]=0,k[4]=(R-Q)*I,k[5]=(1-(F+t))*I,k[6]=(C+Y)*I,k[7]=0,k[8]=(U+n)*D,k[9]=(C-Y)*D,k[10]=(1-(F+S))*D,k[11]=0,k[12]=j._x,k[13]=j._y,k[14]=j._z,k[15]=1,u.markAsUpdated(),u}static Identity(){const G=Y.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return G._updateIdentityStatus(!0),G}static IdentityToRef(G){return Y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,G),G._updateIdentityStatus(!0),G}static Zero(){const G=Y.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return G._updateIdentityStatus(!1),G}static RotationX(G){const A=new Y;return Y.RotationXToRef(G,A),A}static Invert(G){const A=new Y;return G.invertToRef(A),A}static RotationXToRef(G,A){const j=Math.sin(G),u=Math.cos(G);return Y.FromValuesToRef(1,0,0,0,0,u,j,0,0,-j,u,0,0,0,0,1,A),A._updateIdentityStatus(1===u&&0===j),A}static RotationY(G){const A=new Y;return Y.RotationYToRef(G,A),A}static RotationYToRef(G,A){const j=Math.sin(G),u=Math.cos(G);return Y.FromValuesToRef(u,0,-j,0,0,1,0,0,j,0,u,0,0,0,0,1,A),A._updateIdentityStatus(1===u&&0===j),A}static RotationZ(G){const A=new Y;return Y.RotationZToRef(G,A),A}static RotationZToRef(G,A){const j=Math.sin(G),u=Math.cos(G);return Y.FromValuesToRef(u,j,0,0,-j,u,0,0,0,0,1,0,0,0,0,1,A),A._updateIdentityStatus(1===u&&0===j),A}static RotationAxis(G,A){const j=new Y;return Y.RotationAxisToRef(G,A,j),j}static RotationAxisToRef(G,A,j){const u=Math.sin(-A),k=Math.cos(-A),B=1-k;G=G.normalizeToRef(n.SA[0]);const x=j.Bs;return x[0]=G._x*G._x*B+k,x[1]=G._x*G._y*B-G._z*u,x[2]=G._x*G._z*B+G._y*u,x[3]=0,x[4]=G._y*G._x*B+G._z*u,x[5]=G._y*G._y*B+k,x[6]=G._y*G._z*B-G._x*u,x[7]=0,x[8]=G._z*G._x*B-G._y*u,x[9]=G._z*G._y*B+G._x*u,x[10]=G._z*G._z*B+k,x[11]=0,x[12]=0,x[13]=0,x[14]=0,x[15]=1,j.markAsUpdated(),j}static RotationAlignToRef(G,A,j){let k=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const B=S.Dot(A,G),x=j.Bs;if(B<-1+u.d)x[0]=-1,x[1]=0,x[2]=0,x[3]=0,x[4]=0,x[5]=k?1:-1,x[6]=0,x[7]=0,x[8]=0,x[9]=0,x[10]=k?-1:1,x[11]=0;else{const j=S.Cross(A,G),u=1/(1+B);x[0]=j._x*j._x*u+B,x[1]=j._y*j._x*u-j._z,x[2]=j._z*j._x*u+j._y,x[3]=0,x[4]=j._x*j._y*u+j._z,x[5]=j._y*j._y*u+B,x[6]=j._z*j._y*u-j._x,x[7]=0,x[8]=j._x*j._z*u-j._y,x[9]=j._y*j._z*u+j._x,x[10]=j._z*j._z*u+B,x[11]=0}return x[12]=0,x[13]=0,x[14]=0,x[15]=1,j.markAsUpdated(),j}static RotationYawPitchRoll(G,A,j){const u=new Y;return Y.RotationYawPitchRollToRef(G,A,j,u),u}static RotationYawPitchRollToRef(G,A,j,u){return t.RotationYawPitchRollToRef(G,A,j,n.Quaternion[0]),n.Quaternion[0].toRotationMatrix(u),u}static Scaling(G,A,j){const u=new Y;return Y.ScalingToRef(G,A,j,u),u}static ScalingToRef(G,A,j,u){return Y.FromValuesToRef(G,0,0,0,0,A,0,0,0,0,j,0,0,0,0,1,u),u._updateIdentityStatus(1===G&&1===A&&1===j),u}static Translation(G,A,j){const u=new Y;return Y.TranslationToRef(G,A,j,u),u}static TranslationToRef(G,A,j,u){return Y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,G,A,j,1,u),u._updateIdentityStatus(0===G&&0===A&&0===j),u}static Lerp(G,A,j){const u=new Y;return Y.LerpToRef(G,A,j,u),u}static LerpToRef(G,A,j,u){const k=u.Bs,B=G.m,x=A.m;for(let s=0;s<16;s++)k[s]=B[s]*(1-j)+x[s]*j;return u.markAsUpdated(),u}static DecomposeLerp(G,A,j){const u=new Y;return Y.DecomposeLerpToRef(G,A,j,u),u}static DecomposeLerpToRef(G,A,j,u){const k=n.SA[0],B=n.Quaternion[0],x=n.SA[1];G.decompose(k,B,x);const s=n.SA[2],O=n.Quaternion[1],d=n.SA[3];A.decompose(s,O,d);const h=n.SA[4];S.LerpToRef(k,s,j,h);const H=n.Quaternion[2];t.SlerpToRef(B,O,j,H);const F=n.SA[5];return S.LerpToRef(x,d,j,F),Y.ComposeToRef(h,H,F,u),u}static LookAtLH(G,A,j){const u=new Y;return Y.LookAtLHToRef(G,A,j,u),u}static LookAtLHToRef(G,A,j,u){const k=n.SA[0],B=n.SA[1],x=n.SA[2];A.subtractToRef(G,x),x.normalize(),S.CrossToRef(j,x,k);const s=k.lengthSquared();0===s?k.x=1:k.normalizeFromLength(Math.sqrt(s)),S.CrossToRef(x,k,B),B.normalize();const O=-S.Dot(k,G),d=-S.Dot(B,G),h=-S.Dot(x,G);return Y.FromValuesToRef(k._x,B._x,x._x,0,k._y,B._y,x._y,0,k._z,B._z,x._z,0,O,d,h,1,u),u}static LookAtRH(G,A,j){const u=new Y;return Y.LookAtRHToRef(G,A,j,u),u}static LookAtRHToRef(G,A,j,u){const k=n.SA[0],B=n.SA[1],x=n.SA[2];G.subtractToRef(A,x),x.normalize(),S.CrossToRef(j,x,k);const s=k.lengthSquared();0===s?k.x=1:k.normalizeFromLength(Math.sqrt(s)),S.CrossToRef(x,k,B),B.normalize();const O=-S.Dot(k,G),d=-S.Dot(B,G),h=-S.Dot(x,G);return Y.FromValuesToRef(k._x,B._x,x._x,0,k._y,B._y,x._y,0,k._z,B._z,x._z,0,O,d,h,1,u),u}static LookDirectionLH(G,A){const j=new Y;return Y.LookDirectionLHToRef(G,A,j),j}static LookDirectionLHToRef(G,A,j){const u=n.SA[0];u.B(G),u.scaleInPlace(-1);const k=n.SA[1];return S.CrossToRef(A,u,k),Y.FromValuesToRef(k._x,k._y,k._z,0,A._x,A._y,A._z,0,u._x,u._y,u._z,0,0,0,0,1,j),j}static LookDirectionRH(G,A){const j=new Y;return Y.LookDirectionRHToRef(G,A,j),j}static LookDirectionRHToRef(G,A,j){const u=n.SA[2];return S.CrossToRef(A,G,u),Y.FromValuesToRef(u._x,u._y,u._z,0,A._x,A._y,A._z,0,G._x,G._y,G._z,0,0,0,0,1,j),j}static OrthoLH(G,A,j,u,k){const B=new Y;return Y.OrthoLHToRef(G,A,j,u,B,k),B}static OrthoLHToRef(G,A,j,u,k,B){const x=2/G,s=2/A,O=2/(u-j),d=-(u+j)/(u-j);return Y.FromValuesToRef(x,0,0,0,0,s,0,0,0,0,O,0,0,0,d,1,k),B&&k.multiplyToRef(X,k),k._updateIdentityStatus(1===x&&1===s&&1===O&&0===d),k}static OrthoOffCenterLH(G,A,j,u,k,B,x){const s=new Y;return Y.OrthoOffCenterLHToRef(G,A,j,u,k,B,s,x),s}static OrthoOffCenterLHToRef(G,A,j,u,k,B,x,s){const O=2/(A-G),d=2/(u-j),h=2/(B-k),H=-(B+k)/(B-k),F=(G+A)/(G-A),R=(u+j)/(j-u);return Y.FromValuesToRef(O,0,0,0,0,d,0,0,0,0,h,0,F,R,H,1,x),s&&x.multiplyToRef(X,x),x.markAsUpdated(),x}static ObliqueOffCenterLHToRef(G,A,j,u,k,B,x,s,O,d,h){const H=-x*Math.cos(s),F=-x*Math.sin(s);return Y.TranslationToRef(0,0,-O,n.Matrix[1]),Y.FromValuesToRef(1,0,0,0,0,1,0,0,H,F,1,0,0,0,0,1,n.Matrix[0]),n.Matrix[1].multiplyToRef(n.Matrix[0],n.Matrix[0]),Y.TranslationToRef(0,0,O,n.Matrix[1]),n.Matrix[0].multiplyToRef(n.Matrix[1],n.Matrix[0]),Y.OrthoOffCenterLHToRef(G,A,j,u,k,B,d,h),n.Matrix[0].multiplyToRef(d,d),d}static OrthoOffCenterRH(G,A,j,u,k,B,x){const s=new Y;return Y.OrthoOffCenterRHToRef(G,A,j,u,k,B,s,x),s}static OrthoOffCenterRHToRef(G,A,j,u,k,B,x,s){return Y.OrthoOffCenterLHToRef(G,A,j,u,k,B,x,s),x.Bs[10]*=-1,x}static ObliqueOffCenterRHToRef(G,A,j,u,k,B,x,s,O,d,h){const H=x*Math.cos(s),F=x*Math.sin(s);return Y.TranslationToRef(0,0,O,n.Matrix[1]),Y.FromValuesToRef(1,0,0,0,0,1,0,0,H,F,1,0,0,0,0,1,n.Matrix[0]),n.Matrix[1].multiplyToRef(n.Matrix[0],n.Matrix[0]),Y.TranslationToRef(0,0,-O,n.Matrix[1]),n.Matrix[0].multiplyToRef(n.Matrix[1],n.Matrix[0]),Y.OrthoOffCenterRHToRef(G,A,j,u,k,B,d,h),n.Matrix[0].multiplyToRef(d,d),d}static PerspectiveLH(G,A,j,u,k){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const x=new Y,s=2*j/G,O=2*j/A,d=(u+j)/(u-j),h=-2*u*j/(u-j),H=Math.tan(B);return Y.FromValuesToRef(s,0,0,0,0,O,0,H,0,0,d,1,0,0,h,0,x),k&&x.multiplyToRef(X,x),x._updateIdentityStatus(!1),x}static PerspectiveFovLH(G,A,j,u,k){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,x=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const s=new Y;return Y.PerspectiveFovLHToRef(G,A,j,u,s,!0,k,B,x),s}static PerspectiveFovLHToRef(G,A,j,u,k){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],x=arguments.length>6?arguments[6]:void 0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,O=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const d=j,h=u,H=1/Math.tan(.5*G),F=B?H/A:H,R=B?H:H*A,U=O&&0===d?-1:0!==h?(h+d)/(h-d):1,S=O&&0===d?2*h:0!==h?-2*h*d/(h-d):-2*d,C=Math.tan(s);return Y.FromValuesToRef(F,0,0,0,0,R,0,C,0,0,U,1,0,0,S,0,k),x&&k.multiplyToRef(X,k),k._updateIdentityStatus(!1),k}static PerspectiveFovReverseLHToRef(G,A,j,u,k){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],x=arguments.length>6?arguments[6]:void 0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const O=1/Math.tan(.5*G),d=B?O/A:O,h=B?O:O*A,H=Math.tan(s);return Y.FromValuesToRef(d,0,0,0,0,h,0,H,0,0,-j,1,0,0,1,0,k),x&&k.multiplyToRef(X,k),k._updateIdentityStatus(!1),k}static PerspectiveFovRH(G,A,j,u,k){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,x=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const s=new Y;return Y.PerspectiveFovRHToRef(G,A,j,u,s,!0,k,B,x),s}static PerspectiveFovRHToRef(G,A,j,u,k){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],x=arguments.length>6?arguments[6]:void 0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,O=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const d=j,h=u,H=1/Math.tan(.5*G),F=B?H/A:H,R=B?H:H*A,U=O&&0===d?1:0!==h?-(h+d)/(h-d):-1,S=O&&0===d?2*h:0!==h?-2*h*d/(h-d):-2*d,C=Math.tan(s);return Y.FromValuesToRef(F,0,0,0,0,R,0,C,0,0,U,-1,0,0,S,0,k),x&&k.multiplyToRef(X,k),k._updateIdentityStatus(!1),k}static PerspectiveFovReverseRHToRef(G,A,j,u,k){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],x=arguments.length>6?arguments[6]:void 0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const O=1/Math.tan(.5*G),d=B?O/A:O,h=B?O:O*A,H=Math.tan(s);return Y.FromValuesToRef(d,0,0,0,0,h,0,H,0,0,-j,-1,0,0,-1,0,k),x&&k.multiplyToRef(X,k),k._updateIdentityStatus(!1),k}static GetFinalMatrix(G,A,j,u,k,B){const x=G.width,s=G.height,O=G.x,d=G.y,h=Y.FromValues(x/2,0,0,0,0,-s/2,0,0,0,0,B-k,0,O+x/2,s/2+d,k,1),H=new Y;return A.multiplyToRef(j,H),H.multiplyToRef(u,H),H.multiplyToRef(h,H)}static GetAsMatrix2x2(G){const A=G.m,j=[A[0],A[1],A[4],A[5]];return x.c.MatrixUse64Bits?j:new Float32Array(j)}static GetAsMatrix3x3(G){const A=G.m,j=[A[0],A[1],A[2],A[4],A[5],A[6],A[8],A[9],A[10]];return x.c.MatrixUse64Bits?j:new Float32Array(j)}static Transpose(G){const A=new Y;return Y.TransposeToRef(G,A),A}static TransposeToRef(G,A){const j=G.m,u=j[0],k=j[4],B=j[8],x=j[12],s=j[1],O=j[5],d=j[9],h=j[13],H=j[2],F=j[6],R=j[10],U=j[14],S=j[3],C=j[7],t=j[11],Y=j[15],n=A.Bs;return n[0]=u,n[1]=k,n[2]=B,n[3]=x,n[4]=s,n[5]=O,n[6]=d,n[7]=h,n[8]=H,n[9]=F,n[10]=R,n[11]=U,n[12]=S,n[13]=C,n[14]=t,n[15]=Y,A.markAsUpdated(),A._updateIdentityStatus(G._isIdentity,G._isIdentityDirty),A}static Reflection(G){const A=new Y;return Y.ReflectionToRef(G,A),A}static ReflectionToRef(G,A){G.normalize();const j=G.normal.x,u=G.normal.y,k=G.normal.z,B=-2*j,x=-2*u,s=-2*k;return Y.FromValuesToRef(B*j+1,x*j,s*j,0,B*u,x*u+1,s*u,0,B*k,x*k,s*k+1,0,B*G.d,x*G.d,s*G.d,1,A),A}static FromXYZAxesToRef(G,A,j,u){return Y.FromValuesToRef(G._x,G._y,G._z,0,A._x,A._y,A._z,0,j._x,j._y,j._z,0,0,0,0,1,u),u}static FromQuaternionToRef(G,A){const j=G._x*G._x,u=G._y*G._y,k=G._z*G._z,B=G._x*G._y,x=G._z*G._w,s=G._z*G._x,O=G._y*G._w,d=G._y*G._z,h=G._x*G._w;return A.Bs[0]=1-2*(u+k),A.Bs[1]=2*(B+x),A.Bs[2]=2*(s-O),A.Bs[3]=0,A.Bs[4]=2*(B-x),A.Bs[5]=1-2*(k+j),A.Bs[6]=2*(d+h),A.Bs[7]=0,A.Bs[8]=2*(s+O),A.Bs[9]=2*(d-h),A.Bs[10]=1-2*(u+j),A.Bs[11]=0,A.Bs[12]=0,A.Bs[13]=0,A.Bs[14]=0,A.Bs[15]=1,A.markAsUpdated(),A}}Y._IdentityReadOnly=Y.Identity(),Object.defineProperties(Y.prototype,{dimension:{value:[4,4]},rank:{value:2}});class n{}n.SA=(0,k.f)(11,S.Zero),n.Matrix=(0,k.f)(2,Y.Identity),n.Quaternion=(0,k.f)(3,t.Zero);class Q{}Q.Vector2=(0,k.f)(3,U.Zero),Q.SA=(0,k.f)(13,S.Zero),Q.Vector4=(0,k.f)(3,C.Zero),Q.Quaternion=(0,k.f)(3,t.Zero),Q.Matrix=(0,k.f)(8,Y.Identity),(0,B.h)("BABYLON.Vector2",U),(0,B.h)("BABYLON.Vector3",S),(0,B.h)("BABYLON.Vector4",C),(0,B.h)("BABYLON.Matrix",Y);const X=Y.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11228:(G,A,j)=>{function u(G,A){const j=[];for(let u=0;u<G;++u)j.push(A());return j}function k(G,A){return u(G,A)}j.d(A,{e:()=>u,f:()=>k,g:()=>x});const B=["push","splice","pop","shift","unshift"];function x(G,A){const j=B.map((j=>function(G,A,j){const u=G[A];if("function"!==typeof u)return null;const k=function(){const u=G.length,B=k.previous.apply(G,arguments);return j(A,u),B};return u.next=k,k.previous=u,G[A]=k,()=>{const j=k.previous;if(!j)return;const u=k.next;u?(j.next=u,u.previous=j):(j.next=void 0,G[A]=j),k.next=void 0,k.previous=void 0}}(G,j,A)));return()=>{for(const G of j)null===G||void 0===G||G()}}}}]);