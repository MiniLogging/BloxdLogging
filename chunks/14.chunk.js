"use strict";(self.xeuzlpp225k=self.xeuzlpp225k||[]).push([[14],{11304:(k,Q,i)=>{i.d(Q,{e:()=>B,g:()=>C,j:()=>Z,m:()=>U});const Z=1/2.2,U=2.2,C=(1+Math.sqrt(5))/2,B=.001},11311:(k,Q,i)=>{function Z(k){return parseInt(k.toString().replace(/\W/g,""))}function U(k,Q){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(k-Q)<=i}function C(k,Q,i){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return k<Q-Z||k>i+Z}function B(k,Q){return k===Q?k:Math.random()*(Q-k)+k}function o(k,Q,i){return k+(Q-k)*i}function m(k,Q,i){let Z=E(Q-k,360);return Z>180&&(Z-=360),k+Z*H(i)}function O(k,Q,i){let Z=0;return Z=k!=Q?H((i-k)/(Q-k)):0,Z}function J(k,Q,i,Z,U){const C=U*U,B=U*C;return k*(2*B-3*C+1)+i*(-2*B+3*C)+Q*(B-2*C+U)+Z*(B-C)}function G(k,Q,i,Z,U){const C=U*U;return 6*(C-U)*k+(3*C-4*U+1)*Q+6*(-C+U)*i+(3*C-2*U)*Z}function H(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(i,Math.max(Q,k))}function e(k){return k-=2*Math.PI*Math.floor((k+Math.PI)/(2*Math.PI))}function F(k){const Q=k.toString(16);return k<=15?("0"+Q).toUpperCase():Q.toUpperCase()}function z(k){if(Math.log2)return Math.floor(Math.log2(k));if(k<0)return NaN;if(0===k)return-1/0;let Q=0;if(k<1){for(;k<1;)Q++,k*=2;Q=-Q}else if(k>1)for(;k>1;)Q++,k=Math.floor(k/2);return Q}function E(k,Q){return k-Math.floor(k/Q)*Q}function l(k,Q,i){return(k-Q)/(i-Q)}function h(k,Q,i){return k*(i-Q)+Q}function c(k,Q){let i=E(Q-k,360);return i>180&&(i-=360),i}function f(k,Q){const i=E(k,2*Q);return Q-Math.abs(i-Q)}function Y(k,Q,i){let Z=H(i);return Z=-2*Z*Z*Z+3*Z*Z,Q*Z+k*(1-Z)}function y(k,Q,i){let Z=0;return Z=Math.abs(Q-k)<=i?Q:k+Math.sign(Q-k)*i,Z}function L(k,Q,i){const Z=c(k,Q);let U=0;return U=-i<Z&&Z<i?Q:y(k,Q=k+Z,i),U}function s(k,Q,i){return(k-Q)/(i-Q)}function u(k,Q,i){return(i-Q)*k+Q}function a(k,Q){const i=k%Q;return 0===i?Q:a(Q,i)}i.r(Q),i.d(Q,{Clamp:()=>H,DeltaAngle:()=>c,Denormalize:()=>h,ExtractAsInt:()=>Z,Hermite:()=>J,Hermite1stDerivative:()=>G,HighestCommonFactor:()=>a,ILog2:()=>z,InverseLerp:()=>O,Lerp:()=>o,LerpAngle:()=>m,MoveTowards:()=>y,MoveTowardsAngle:()=>L,Normalize:()=>l,NormalizeRadians:()=>e,OutsideRange:()=>C,PercentToRange:()=>u,PingPong:()=>f,RandomRange:()=>B,RangeToPercent:()=>s,Repeat:()=>E,SmoothStep:()=>Y,ToHex:()=>F,WithinEpsilon:()=>U})},11298:(k,Q,i)=>{i.r(Q),i.d(Q,{Matrix:()=>h,Quaternion:()=>l,TmpVectors:()=>f,Vector2:()=>F,zQ:()=>z,Vector4:()=>E});var Z=i(11304),U=i(11307),C=i(11253),B=i(11230),o=i(11157),m=i(11311);class O{}function J(k,Q,i){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const U=k.Zo(),C=Q.Zo(),B=U[0],o=U[1],m=U[2],O=U[3],J=U[4],G=U[5],H=U[6],e=U[7],F=U[8],z=U[9],E=U[10],l=U[11],h=U[12],c=U[13],f=U[14],Y=U[15],y=C[0],L=C[1],s=C[2],u=C[3],a=C[4],j=C[5],T=C[6],K=C[7],v=C[8],N=C[9],X=C[10],p=C[11],d=C[12],b=C[13],D=C[14],M=C[15];i[Z]=B*y+o*a+m*v+O*d,i[Z+1]=B*L+o*j+m*N+O*b,i[Z+2]=B*s+o*T+m*X+O*D,i[Z+3]=B*u+o*K+m*p+O*M,i[Z+4]=J*y+G*a+H*v+e*d,i[Z+5]=J*L+G*j+H*N+e*b,i[Z+6]=J*s+G*T+H*X+e*D,i[Z+7]=J*u+G*K+H*p+e*M,i[Z+8]=F*y+z*a+E*v+l*d,i[Z+9]=F*L+z*j+E*N+l*b,i[Z+10]=F*s+z*T+E*X+l*D,i[Z+11]=F*u+z*K+E*p+l*M,i[Z+12]=h*y+c*a+f*v+Y*d,i[Z+13]=h*L+c*j+f*N+Y*b,i[Z+14]=h*s+c*T+f*X+Y*D,i[Z+15]=h*u+c*K+f*p+Y*M}function G(k,Q){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const Z=k.Zo();Q[i]=Z[0],Q[i+1]=Z[1],Q[i+2]=Z[2],Q[i+3]=Z[3],Q[i+4]=Z[4],Q[i+5]=Z[5],Q[i+6]=Z[6],Q[i+7]=Z[7],Q[i+8]=Z[8],Q[i+9]=Z[9],Q[i+10]=Z[10],Q[i+11]=Z[11],Q[i+12]=Z[12],Q[i+13]=Z[13],Q[i+14]=Z[14],Q[i+15]=Z[15]}function H(k,Q){const i=k.Zo(),Z=i[0],U=i[1],C=i[2],B=i[3],o=i[4],m=i[5],O=i[6],J=i[7],G=i[8],H=i[9],e=i[10],F=i[11],z=i[12],E=i[13],l=i[14],h=i[15],c=e*h-l*F,f=H*h-E*F,Y=H*l-E*e,y=G*h-z*F,L=G*l-e*z,s=G*E-z*H,u=+(m*c-O*f+J*Y),a=-(o*c-O*y+J*L),j=+(o*f-m*y+J*s),T=-(o*Y-m*L+O*s),K=Z*u+U*a+C*j+B*T;if(0===K)return!1;const v=1/K,N=O*h-l*J,X=m*h-E*J,p=m*l-E*O,d=o*h-z*J,b=o*l-z*O,D=o*E-z*m,M=O*F-e*J,W=m*F-H*J,A=m*e-H*O,g=o*F-G*J,R=o*e-G*O,w=o*H-G*m,S=-(U*c-C*f+B*Y),q=+(Z*c-C*y+B*L),P=-(Z*f-U*y+B*s),t=+(Z*Y-U*L+C*s),I=+(U*N-C*X+B*p),r=-(Z*N-C*d+B*b),n=+(Z*X-U*d+B*D),x=-(Z*p-U*b+C*D),V=-(U*M-C*W+B*A),kk=+(Z*M-C*g+B*R),Qk=-(Z*W-U*g+B*w),ik=+(Z*A-U*R+C*w);return Q[0]=u*v,Q[1]=S*v,Q[2]=I*v,Q[3]=V*v,Q[4]=a*v,Q[5]=q*v,Q[6]=r*v,Q[7]=kk*v,Q[8]=j*v,Q[9]=P*v,Q[10]=n*v,Q[11]=Qk*v,Q[12]=T*v,Q[13]=t*v,Q[14]=x*v,Q[15]=ik*v,!0}O._UpdateFlagSeed=0;const e=k=>parseInt(k.toString().replace(/\W/g,""));class F{constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=k,this.y=Q}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let k=e(this.x);return k=397*k^e(this.y),k}toArray(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k[Q]=this.x,k[Q+1]=this.y,this}Ei(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(k,Q,this),this}Zo(){return[this.x,this.y]}B(k){return this.x=k.x,this.y=k.y,this}Go(k,Q){return this.x=k,this.y=Q,this}set(k,Q){return this.Go(k,Q)}eo(k){return this.Go(k,k)}add(k){return new F(this.x+k.x,this.y+k.y)}addToRef(k,Q){return Q.x=this.x+k.x,Q.y=this.y+k.y,Q}addInPlace(k){return this.x+=k.x,this.y+=k.y,this}addInPlaceFromFloats(k,Q){return this.x+=k,this.y+=Q,this}addVector3(k){return new F(this.x+k.x,this.y+k.y)}EQ(k){return new F(this.x-k.x,this.y-k.y)}subtractToRef(k,Q){return Q.x=this.x-k.x,Q.y=this.y-k.y,Q}tJ(k){return this.x-=k.x,this.y-=k.y,this}multiplyInPlace(k){return this.x*=k.x,this.y*=k.y,this}multiply(k){return new F(this.x*k.x,this.y*k.y)}multiplyToRef(k,Q){return Q.x=this.x*k.x,Q.y=this.y*k.y,Q}multiplyByFloats(k,Q){return new F(this.x*k,this.y*Q)}divide(k){return new F(this.x/k.x,this.y/k.y)}divideToRef(k,Q){return Q.x=this.x/k.x,Q.y=this.y/k.y,Q}divideInPlace(k){return this.x=this.x/k.x,this.y=this.y/k.y,this}minimizeInPlace(k){return this.minimizeInPlaceFromFloats(k.x,k.y)}maximizeInPlace(k){return this.maximizeInPlaceFromFloats(k.x,k.y)}minimizeInPlaceFromFloats(k,Q){return this.x=Math.min(k,this.x),this.y=Math.min(Q,this.y),this}maximizeInPlaceFromFloats(k,Q){return this.x=Math.max(k,this.x),this.y=Math.max(Q,this.y),this}subtractFromFloats(k,Q){return new F(this.x-k,this.y-Q)}subtractFromFloatsToRef(k,Q,i){return i.x=this.x-k,i.y=this.y-Q,i}negate(){return new F(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(k){return k.x=-this.x,k.y=-this.y,k}scaleInPlace(k){return this.x*=k,this.y*=k,this}scale(k){return new F(this.x*k,this.y*k)}scaleToRef(k,Q){return Q.x=this.x*k,Q.y=this.y*k,Q}scaleAndAddToRef(k,Q){return Q.x+=this.x*k,Q.y+=this.y*k,Q}equals(k){return k&&this.x===k.x&&this.y===k.y}equalsWithEpsilon(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.e;return k&&(0,m.WithinEpsilon)(this.x,k.x,Q)&&(0,m.WithinEpsilon)(this.y,k.y,Q)}equalsToFloats(k,Q){return this.x===k&&this.y===Q}floor(){return new F(Math.floor(this.x),Math.floor(this.y))}floorToRef(k){return k.x=Math.floor(this.x),k.y=Math.floor(this.y),k}fract(){return new F(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(k){return k.x=this.x-Math.floor(this.x),k.y=this.y-Math.floor(this.y),k}rotate(k){return this.rotateToRef(k,new F)}rotateToRef(k,Q){const i=Math.cos(k),Z=Math.sin(k);return Q.x=i*this.x-Z*this.y,Q.y=Z*this.x+i*this.y,Q}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(k){return 0===k||1===k?this:this.scaleInPlace(1/k)}normalizeToNew(){const k=new F;return this.normalizeToRef(k),k}normalizeToRef(k){const Q=this.length();return 0===Q&&(k.x=this.x,k.y=this.y),this.scaleToRef(1/Q,k)}clone(){return new F(this.x,this.y)}dot(k){return this.x*k.x+this.y*k.y}static Zero(){return new F(0,0)}static One(){return new F(1,1)}static Random(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F((0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q))}static RandomToRef(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Go((0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q))}static get ZeroReadOnly(){return F._ZeroReadOnly}static fQ(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(k[Q],k[Q+1])}static FromArrayToRef(k,Q,i){return i.x=k[Q],i.y=k[Q+1],i}static FromFloatsToRef(k,Q,i){return i.Go(k,Q),i}static CatmullRom(k,Q,i,Z,U){const C=U*U,B=U*C,o=.5*(2*Q.x+(-k.x+i.x)*U+(2*k.x-5*Q.x+4*i.x-Z.x)*C+(-k.x+3*Q.x-3*i.x+Z.x)*B),m=.5*(2*Q.y+(-k.y+i.y)*U+(2*k.y-5*Q.y+4*i.y-Z.y)*C+(-k.y+3*Q.y-3*i.y+Z.y)*B);return new F(o,m)}static ClampToRef(k,Q,i,Z){return Z.x=(0,m.Clamp)(k.x,Q.x,i.x),Z.y=(0,m.Clamp)(k.y,Q.y,i.y),Z}static Clamp(k,Q,i){const Z=(0,m.Clamp)(k.x,Q.x,i.x),U=(0,m.Clamp)(k.y,Q.y,i.y);return new F(Z,U)}static Hermite(k,Q,i,Z,U){const C=U*U,B=U*C,o=2*B-3*C+1,m=-2*B+3*C,O=B-2*C+U,J=B-C,G=k.x*o+i.x*m+Q.x*O+Z.x*J,H=k.y*o+i.y*m+Q.y*O+Z.y*J;return new F(G,H)}static Hermite1stDerivative(k,Q,i,Z,U){return this.Hermite1stDerivativeToRef(k,Q,i,Z,U,new F)}static Hermite1stDerivativeToRef(k,Q,i,Z,U,C){const B=U*U;return C.x=6*(B-U)*k.x+(3*B-4*U+1)*Q.x+6*(-B+U)*i.x+(3*B-2*U)*Z.x,C.y=6*(B-U)*k.y+(3*B-4*U+1)*Q.y+6*(-B+U)*i.y+(3*B-2*U)*Z.y,C}static Lerp(k,Q,i){return F.LerpToRef(k,Q,i,new F)}static LerpToRef(k,Q,i,Z){return Z.x=k.x+(Q.x-k.x)*i,Z.y=k.y+(Q.y-k.y)*i,Z}static Dot(k,Q){return k.x*Q.x+k.y*Q.y}static Normalize(k){return F.NormalizeToRef(k,new F)}static NormalizeToRef(k,Q){return k.normalizeToRef(Q),Q}static Minimize(k,Q){const i=k.x<Q.x?k.x:Q.x,Z=k.y<Q.y?k.y:Q.y;return new F(i,Z)}static Maximize(k,Q){const i=k.x>Q.x?k.x:Q.x,Z=k.y>Q.y?k.y:Q.y;return new F(i,Z)}static Transform(k,Q){return F.TransformToRef(k,Q,new F)}static TransformToRef(k,Q,i){const Z=Q.m,U=k.x*Z[0]+k.y*Z[4]+Z[12],C=k.x*Z[1]+k.y*Z[5]+Z[13];return i.x=U,i.y=C,i}static PointInTriangle(k,Q,i,Z){const U=.5*(-i.y*Z.x+Q.y*(-i.x+Z.x)+Q.x*(i.y-Z.y)+i.x*Z.y),C=U<0?-1:1,B=(Q.y*Z.x-Q.x*Z.y+(Z.y-Q.y)*k.x+(Q.x-Z.x)*k.y)*C,o=(Q.x*i.y-Q.y*i.x+(Q.y-i.y)*k.x+(i.x-Q.x)*k.y)*C;return B>0&&o>0&&B+o<2*U*C}static Distance(k,Q){return Math.sqrt(F.DistanceSquared(k,Q))}static DistanceSquared(k,Q){const i=k.x-Q.x,Z=k.y-Q.y;return i*i+Z*Z}static Center(k,Q){return F.CenterToRef(k,Q,new F)}static CenterToRef(k,Q,i){return i.Go((k.x+Q.x)/2,(k.y+Q.y)/2)}static DistanceOfPointFromSegment(k,Q,i){const Z=F.DistanceSquared(Q,i);if(0===Z)return F.Distance(k,Q);const U=i.EQ(Q),C=Math.max(0,Math.min(1,F.Dot(k.EQ(Q),U)/Z)),B=Q.add(U.multiplyByFloats(C,C));return F.Distance(k,B)}}F._V8PerformanceHack=new F(.5,.5),F._ZeroReadOnly=F.Zero(),Object.defineProperties(F.prototype,{dimension:{value:[2]},rank:{value:1}});class z{get x(){return this._x}set x(k){this._x=k,this._isDirty=!0}get y(){return this._y}set y(k){this._y=k,this._isDirty=!0}get z(){return this._z}set z(k){this._z=k,this._isDirty=!0}constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=k,this._y=Q,this._z=i}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"zQ"}getHashCode(){let k=e(this._x);return k=397*k^e(this._y),k=397*k^e(this._z),k}Zo(){return[this._x,this._y,this._z]}toArray(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k[Q]=this._x,k[Q+1]=this._y,k[Q+2]=this._z,this}Ei(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z.FromArrayToRef(k,Q,this),this}toQuaternion(){return l.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(k){return this._x+=k._x,this._y+=k._y,this._z+=k._z,this._isDirty=!0,this}addInPlaceFromFloats(k,Q,i){return this._x+=k,this._y+=Q,this._z+=i,this._isDirty=!0,this}add(k){return new z(this._x+k._x,this._y+k._y,this._z+k._z)}addToRef(k,Q){return Q._x=this._x+k._x,Q._y=this._y+k._y,Q._z=this._z+k._z,Q._isDirty=!0,Q}tJ(k){return this._x-=k._x,this._y-=k._y,this._z-=k._z,this._isDirty=!0,this}EQ(k){return new z(this._x-k._x,this._y-k._y,this._z-k._z)}subtractToRef(k,Q){return this.subtractFromFloatsToRef(k._x,k._y,k._z,Q)}subtractFromFloats(k,Q,i){return new z(this._x-k,this._y-Q,this._z-i)}subtractFromFloatsToRef(k,Q,i,Z){return Z._x=this._x-k,Z._y=this._y-Q,Z._z=this._z-i,Z._isDirty=!0,Z}negate(){return new z(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(k){return k._x=-1*this._x,k._y=-1*this._y,k._z=-1*this._z,k._isDirty=!0,k}scaleInPlace(k){return this._x*=k,this._y*=k,this._z*=k,this._isDirty=!0,this}scale(k){return new z(this._x*k,this._y*k,this._z*k)}scaleToRef(k,Q){return Q._x=this._x*k,Q._y=this._y*k,Q._z=this._z*k,Q._isDirty=!0,Q}getNormalToRef(k){const Q=this.length();let i=Math.acos(this._y/Q);const Z=Math.atan2(this._z,this._x);i>Math.PI/2?i-=Math.PI/2:i+=Math.PI/2;const U=Q*Math.sin(i)*Math.cos(Z),C=Q*Math.cos(i),B=Q*Math.sin(i)*Math.sin(Z);return k.set(U,C,B),k}applyRotationQuaternionToRef(k,Q){const i=this._x,Z=this._y,U=this._z,C=k._x,B=k._y,o=k._z,m=k._w,O=2*(B*U-o*Z),J=2*(o*i-C*U),G=2*(C*Z-B*i);return Q._x=i+m*O+B*G-o*J,Q._y=Z+m*J+o*O-C*G,Q._z=U+m*G+C*J-B*O,Q._isDirty=!0,Q}applyRotationQuaternionInPlace(k){return this.applyRotationQuaternionToRef(k,this)}applyRotationQuaternion(k){return this.applyRotationQuaternionToRef(k,new z)}scaleAndAddToRef(k,Q){return Q._x+=this._x*k,Q._y+=this._y*k,Q._z+=this._z*k,Q._isDirty=!0,Q}projectOnPlane(k,Q){return this.projectOnPlaneToRef(k,Q,new z)}projectOnPlaneToRef(k,Q,i){const Z=k.normal,U=k.d,C=c.zQ[0];this.subtractToRef(Q,C),C.normalize();const B=z.Dot(C,Z);if(Math.abs(B)<1e-10)i.eo(1/0);else{const k=-(z.Dot(Q,Z)+U)/B,o=C.scaleInPlace(k);Q.addToRef(o,i)}return i}equals(k){return k&&this._x===k._x&&this._y===k._y&&this._z===k._z}equalsWithEpsilon(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.e;return k&&(0,m.WithinEpsilon)(this._x,k._x,Q)&&(0,m.WithinEpsilon)(this._y,k._y,Q)&&(0,m.WithinEpsilon)(this._z,k._z,Q)}equalsToFloats(k,Q,i){return this._x===k&&this._y===Q&&this._z===i}multiplyInPlace(k){return this._x*=k._x,this._y*=k._y,this._z*=k._z,this._isDirty=!0,this}multiply(k){return this.multiplyByFloats(k._x,k._y,k._z)}multiplyToRef(k,Q){return Q._x=this._x*k._x,Q._y=this._y*k._y,Q._z=this._z*k._z,Q._isDirty=!0,Q}multiplyByFloats(k,Q,i){return new z(this._x*k,this._y*Q,this._z*i)}divide(k){return new z(this._x/k._x,this._y/k._y,this._z/k._z)}divideToRef(k,Q){return Q._x=this._x/k._x,Q._y=this._y/k._y,Q._z=this._z/k._z,Q._isDirty=!0,Q}divideInPlace(k){return this._x=this._x/k._x,this._y=this._y/k._y,this._z=this._z/k._z,this._isDirty=!0,this}minimizeInPlace(k){return this.minimizeInPlaceFromFloats(k._x,k._y,k._z)}maximizeInPlace(k){return this.maximizeInPlaceFromFloats(k._x,k._y,k._z)}minimizeInPlaceFromFloats(k,Q,i){return k<this._x&&(this.x=k),Q<this._y&&(this.y=Q),i<this._z&&(this.z=i),this}maximizeInPlaceFromFloats(k,Q,i){return k>this._x&&(this.x=k),Q>this._y&&(this.y=Q),i>this._z&&(this.z=i),this}isNonUniformWithinEpsilon(k){const Q=Math.abs(this._x),i=Math.abs(this._y);if(!(0,m.WithinEpsilon)(Q,i,k))return!0;const Z=Math.abs(this._z);return!(0,m.WithinEpsilon)(Q,Z,k)||!(0,m.WithinEpsilon)(i,Z,k)}get isNonUniform(){const k=Math.abs(this._x);if(k!==Math.abs(this._y))return!0;return k!==Math.abs(this._z)}floorToRef(k){return k._x=Math.floor(this._x),k._y=Math.floor(this._y),k._z=Math.floor(this._z),k._isDirty=!0,k}floor(){return new z(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(k){return k._x=this._x-Math.floor(this._x),k._y=this._y-Math.floor(this._y),k._z=this._z-Math.floor(this._z),k._isDirty=!0,k}fract(){return new z(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(k){if("xyz"===(k=k.toLowerCase()))return this;const Q=c.zQ[0].B(this);return this.x=Q[k[0]],this.y=Q[k[1]],this.z=Q[k[2]],this}rotateByQuaternionToRef(k,Q){return k.toRotationMatrix(c.Matrix[0]),z.TransformCoordinatesToRef(this,c.Matrix[0],Q),Q}rotateByQuaternionAroundPointToRef(k,Q,i){return this.subtractToRef(Q,c.zQ[0]),c.zQ[0].rotateByQuaternionToRef(k,c.zQ[0]),Q.addToRef(c.zQ[0],i),i}cross(k){return z.CrossToRef(this,k,new z)}normalizeFromLength(k){return 0===k||1===k?this:this.scaleInPlace(1/k)}normalizeToNew(){return this.normalizeToRef(new z)}normalizeToRef(k){const Q=this.length();return 0===Q||1===Q?(k._x=this._x,k._y=this._y,k._z=this._z,k._isDirty=!0,k):this.scaleToRef(1/Q,k)}clone(){return new z(this._x,this._y,this._z)}B(k){return this.Go(k._x,k._y,k._z)}Go(k,Q,i){return this._x=k,this._y=Q,this._z=i,this._isDirty=!0,this}set(k,Q,i){return this.Go(k,Q,i)}eo(k){return this._x=this._y=this._z=k,this._isDirty=!0,this}static GetClipFactor(k,Q,i,Z){const U=z.Dot(k,i);return(U-Z)/(U-z.Dot(Q,i))}static GetAngleBetweenVectors(k,Q,i){const Z=k.normalizeToRef(c.zQ[1]),U=Q.normalizeToRef(c.zQ[2]);let C=z.Dot(Z,U);C=(0,m.Clamp)(C,-1,1);const B=Math.acos(C),o=c.zQ[3];return z.CrossToRef(Z,U,o),z.Dot(o,i)>0?isNaN(B)?0:B:isNaN(B)?-Math.PI:-Math.acos(C)}static GetAngleBetweenVectorsOnPlane(k,Q,i){c.zQ[0].B(k);const Z=c.zQ[0];c.zQ[1].B(Q);const U=c.zQ[1];c.zQ[2].B(i);const C=c.zQ[2],B=c.zQ[3],o=c.zQ[4];Z.normalize(),U.normalize(),C.normalize(),z.CrossToRef(C,Z,B),z.CrossToRef(B,C,o);const O=Math.atan2(z.Dot(U,B),z.Dot(U,o));return(0,m.NormalizeRadians)(O)}static PitchYawRollToMoveBetweenPointsToRef(k,Q,i){const Z=f.zQ[0];return Q.subtractToRef(k,Z),i._y=Math.atan2(Z.x,Z.z)||0,i._x=Math.atan2(Math.sqrt(Z.x**2+Z.z**2),Z.y)||0,i._z=0,i._isDirty=!0,i}static PitchYawRollToMoveBetweenPoints(k,Q){const i=z.Zero();return z.PitchYawRollToMoveBetweenPointsToRef(k,Q,i)}static SlerpToRef(k,Q,i,U){i=(0,m.Clamp)(i,0,1);const C=c.zQ[0],B=c.zQ[1];C.B(k);const o=C.length();C.normalizeFromLength(o),B.B(Q);const O=B.length();B.normalizeFromLength(O);const J=z.Dot(C,B);let G,H;if(J<1-Z.e){const k=Math.acos(J),Q=1/Math.sin(k);G=Math.sin((1-i)*k)*Q,H=Math.sin(i*k)*Q}else G=1-i,H=i;return C.scaleInPlace(G),B.scaleInPlace(H),U.B(C).addInPlace(B),U.scaleInPlace((0,m.Lerp)(o,O,i)),U}static SmoothToRef(k,Q,i,Z,U){return z.SlerpToRef(k,Q,0===Z?1:i/Z,U),U}static fQ(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new z(k[Q],k[Q+1],k[Q+2])}static FromFloatArray(k,Q){return z.fQ(k,Q)}static FromArrayToRef(k,Q,i){return i._x=k[Q],i._y=k[Q+1],i._z=k[Q+2],i._isDirty=!0,i}static FromFloatArrayToRef(k,Q,i){return z.FromArrayToRef(k,Q,i)}static FromFloatsToRef(k,Q,i,Z){return Z.Go(k,Q,i),Z}static Zero(){return new z(0,0,0)}static One(){return new z(1,1,1)}static Up(){return new z(0,1,0)}static get UpReadOnly(){return z._UpReadOnly}static get DownReadOnly(){return z._DownReadOnly}static get RightReadOnly(){return z._RightReadOnly}static get LeftReadOnly(){return z._LeftReadOnly}static get LeftHandedForwardReadOnly(){return z._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return z._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return z._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return z._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return z._ZeroReadOnly}static get OneReadOnly(){return z._OneReadOnly}static Down(){return new z(0,-1,0)}static Forward(){return new z(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new z(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new z(1,0,0)}static Left(){return new z(-1,0,0)}static Random(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new z((0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q))}static RandomToRef(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Go((0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q))}static TransformCoordinates(k,Q){const i=z.Zero();return z.TransformCoordinatesToRef(k,Q,i),i}static TransformCoordinatesToRef(k,Q,i){return z.TransformCoordinatesFromFloatsToRef(k._x,k._y,k._z,Q,i),i}static TransformCoordinatesFromFloatsToRef(k,Q,i,Z,U){const C=Z.m,B=k*C[0]+Q*C[4]+i*C[8]+C[12],o=k*C[1]+Q*C[5]+i*C[9]+C[13],m=k*C[2]+Q*C[6]+i*C[10]+C[14],O=1/(k*C[3]+Q*C[7]+i*C[11]+C[15]);return U._x=B*O,U._y=o*O,U._z=m*O,U._isDirty=!0,U}static TransformNormal(k,Q){const i=z.Zero();return z.TransformNormalToRef(k,Q,i),i}static TransformNormalToRef(k,Q,i){return this.TransformNormalFromFloatsToRef(k._x,k._y,k._z,Q,i),i}static TransformNormalFromFloatsToRef(k,Q,i,Z,U){const C=Z.m;return U._x=k*C[0]+Q*C[4]+i*C[8],U._y=k*C[1]+Q*C[5]+i*C[9],U._z=k*C[2]+Q*C[6]+i*C[10],U._isDirty=!0,U}static CatmullRom(k,Q,i,Z,U){const C=U*U,B=U*C,o=.5*(2*Q._x+(-k._x+i._x)*U+(2*k._x-5*Q._x+4*i._x-Z._x)*C+(-k._x+3*Q._x-3*i._x+Z._x)*B),m=.5*(2*Q._y+(-k._y+i._y)*U+(2*k._y-5*Q._y+4*i._y-Z._y)*C+(-k._y+3*Q._y-3*i._y+Z._y)*B),O=.5*(2*Q._z+(-k._z+i._z)*U+(2*k._z-5*Q._z+4*i._z-Z._z)*C+(-k._z+3*Q._z-3*i._z+Z._z)*B);return new z(o,m,O)}static Clamp(k,Q,i){const Z=new z;return z.ClampToRef(k,Q,i,Z),Z}static ClampToRef(k,Q,i,Z){let U=k._x;U=U>i._x?i._x:U,U=U<Q._x?Q._x:U;let C=k._y;C=C>i._y?i._y:C,C=C<Q._y?Q._y:C;let B=k._z;return B=B>i._z?i._z:B,B=B<Q._z?Q._z:B,Z.Go(U,C,B),Z}static CheckExtends(k,Q,i){Q.minimizeInPlace(k),i.maximizeInPlace(k)}static Hermite(k,Q,i,Z,U){const C=U*U,B=U*C,o=2*B-3*C+1,m=-2*B+3*C,O=B-2*C+U,J=B-C,G=k._x*o+i._x*m+Q._x*O+Z._x*J,H=k._y*o+i._y*m+Q._y*O+Z._y*J,e=k._z*o+i._z*m+Q._z*O+Z._z*J;return new z(G,H,e)}static Hermite1stDerivative(k,Q,i,Z,U){const C=new z;return this.Hermite1stDerivativeToRef(k,Q,i,Z,U,C),C}static Hermite1stDerivativeToRef(k,Q,i,Z,U,C){const B=U*U;return C._x=6*(B-U)*k._x+(3*B-4*U+1)*Q._x+6*(-B+U)*i._x+(3*B-2*U)*Z._x,C._y=6*(B-U)*k._y+(3*B-4*U+1)*Q._y+6*(-B+U)*i._y+(3*B-2*U)*Z._y,C._z=6*(B-U)*k._z+(3*B-4*U+1)*Q._z+6*(-B+U)*i._z+(3*B-2*U)*Z._z,C._isDirty=!0,C}static Lerp(k,Q,i){const Z=new z(0,0,0);return z.LerpToRef(k,Q,i,Z),Z}static LerpToRef(k,Q,i,Z){return Z._x=k._x+(Q._x-k._x)*i,Z._y=k._y+(Q._y-k._y)*i,Z._z=k._z+(Q._z-k._z)*i,Z._isDirty=!0,Z}static Dot(k,Q){return k._x*Q._x+k._y*Q._y+k._z*Q._z}dot(k){return this._x*k._x+this._y*k._y+this._z*k._z}static Cross(k,Q){const i=new z;return z.CrossToRef(k,Q,i),i}static CrossToRef(k,Q,i){const Z=k._y*Q._z-k._z*Q._y,U=k._z*Q._x-k._x*Q._z,C=k._x*Q._y-k._y*Q._x;return i.Go(Z,U,C),i}static Normalize(k){const Q=z.Zero();return z.NormalizeToRef(k,Q),Q}static NormalizeToRef(k,Q){return k.normalizeToRef(Q),Q}static Project(k,Q,i,Z){const U=new z;return z.ProjectToRef(k,Q,i,Z,U),U}static ProjectToRef(k,Q,i,Z,U){var C;const B=Z.width,m=Z.height,O=Z.x,J=Z.y,G=c.Matrix[1],H=null===(C=o.b.LastCreatedEngine)||void 0===C?void 0:C.isNDCHalfZRange,e=H?1:.5,F=H?0:.5;h.FromValuesToRef(B/2,0,0,0,0,-m/2,0,0,0,0,e,0,O+B/2,m/2+J,F,1,G);const E=c.Matrix[0];return Q.multiplyToRef(i,E),E.multiplyToRef(G,E),z.TransformCoordinatesToRef(k,E,U),U}static Reflect(k,Q){return this.ReflectToRef(k,Q,new z)}static ReflectToRef(k,Q,i){const Z=f.zQ[0];return Z.B(Q).scaleInPlace(2*z.Dot(k,Q)),i.B(k).tJ(Z)}static _UnprojectFromInvertedMatrixToRef(k,Q,i){z.TransformCoordinatesToRef(k,Q,i);const Z=Q.m,U=k._x*Z[3]+k._y*Z[7]+k._z*Z[11]+Z[15];return(0,m.WithinEpsilon)(U,1)&&i.scaleInPlace(1/U),i}static UnprojectFromTransform(k,Q,i,Z,U){return this.Unproject(k,Q,i,Z,U,h.IdentityReadOnly)}static Unproject(k,Q,i,Z,U,C){const B=new z;return z.UnprojectToRef(k,Q,i,Z,U,C,B),B}static UnprojectToRef(k,Q,i,Z,U,C,B){return z.UnprojectFloatsToRef(k._x,k._y,k._z,Q,i,Z,U,C,B),B}static UnprojectFloatsToRef(k,Q,i,Z,U,C,B,m,O){var J;const G=c.Matrix[0];C.multiplyToRef(B,G),G.multiplyToRef(m,G),G.invert();const H=c.zQ[0];return H.x=k/Z*2-1,H.y=-(Q/U*2-1),null!==(J=o.b.LastCreatedEngine)&&void 0!==J&&J.isNDCHalfZRange?H.z=i:H.z=2*i-1,z._UnprojectFromInvertedMatrixToRef(H,G,O),O}static Minimize(k,Q){const i=new z;return i.B(k),i.minimizeInPlace(Q),i}static Maximize(k,Q){const i=new z;return i.B(k),i.maximizeInPlace(Q),i}static Distance(k,Q){return Math.sqrt(z.DistanceSquared(k,Q))}static DistanceSquared(k,Q){const i=k._x-Q._x,Z=k._y-Q._y,U=k._z-Q._z;return i*i+Z*Z+U*U}static ProjectOnTriangleToRef(k,Q,i,U,C){const B=c.zQ[0],o=c.zQ[1],O=c.zQ[2],J=c.zQ[3],G=c.zQ[4];i.subtractToRef(Q,B),U.subtractToRef(Q,o),U.subtractToRef(i,O);const H=B.length(),e=o.length(),F=O.length();if(H<Z.e||e<Z.e||F<Z.e)return C.B(Q),z.Distance(k,Q);k.subtractToRef(Q,G),z.CrossToRef(B,o,J);const E=J.length();if(E<Z.e)return C.B(Q),z.Distance(k,Q);J.normalizeFromLength(E);let l=G.length();if(l<Z.e)return C.B(Q),0;G.normalizeFromLength(l);const h=z.Dot(J,G),f=c.zQ[5],Y=c.zQ[6];f.B(J).scaleInPlace(-l*h),Y.B(k).addInPlace(f);const y=c.zQ[4],L=c.zQ[5],s=c.zQ[7],u=c.zQ[8];y.B(B).scaleInPlace(1/H),u.B(o).scaleInPlace(1/e),y.addInPlace(u).scaleInPlace(-1),L.B(B).scaleInPlace(-1/H),u.B(O).scaleInPlace(1/F),L.addInPlace(u).scaleInPlace(-1),s.B(O).scaleInPlace(-1/F),u.B(o).scaleInPlace(-1/e),s.addInPlace(u).scaleInPlace(-1);const a=c.zQ[9];let j;a.B(Y).tJ(Q),z.CrossToRef(y,a,u),j=z.Dot(u,J);const T=j;a.B(Y).tJ(i),z.CrossToRef(L,a,u),j=z.Dot(u,J);const K=j;a.B(Y).tJ(U),z.CrossToRef(s,a,u),j=z.Dot(u,J);const v=j,N=c.zQ[10];let X,p;T>0&&K<0?(N.B(B),X=Q,p=i):K>0&&v<0?(N.B(O),X=i,p=U):(N.B(o).scaleInPlace(-1),X=U,p=Q);const d=c.zQ[9],b=c.zQ[4];X.subtractToRef(Y,u),p.subtractToRef(Y,d),z.CrossToRef(u,d,b);if(!(z.Dot(b,J)<0))return C.B(Y),Math.abs(l*h);const D=c.zQ[5];z.CrossToRef(N,b,D),D.normalize();const M=c.zQ[9];M.B(X).tJ(Y);const W=M.length();if(W<Z.e)return C.B(X),z.Distance(k,X);M.normalizeFromLength(W);const A=z.Dot(D,M),g=c.zQ[7];g.B(Y).addInPlace(D.scaleInPlace(W*A)),u.B(g).tJ(X),l=N.length(),N.normalizeFromLength(l);let R=z.Dot(u,N)/Math.max(l,Z.e);return R=(0,m.Clamp)(R,0,1),g.B(X).addInPlace(N.scaleInPlace(R*l)),C.B(g),z.Distance(k,g)}static Center(k,Q){return z.CenterToRef(k,Q,z.Zero())}static CenterToRef(k,Q,i){return i.Go((k._x+Q._x)/2,(k._y+Q._y)/2,(k._z+Q._z)/2)}static RotationFromAxis(k,Q,i){const Z=new z;return z.RotationFromAxisToRef(k,Q,i,Z),Z}static RotationFromAxisToRef(k,Q,i,Z){const U=c.Quaternion[0];return l.RotationQuaternionFromAxisToRef(k,Q,i,U),U.toEulerAnglesToRef(Z),Z}}z._V8PerformanceHack=new z(.5,.5,.5),z._UpReadOnly=z.Up(),z._DownReadOnly=z.Down(),z._LeftHandedForwardReadOnly=z.Forward(!1),z._RightHandedForwardReadOnly=z.Forward(!0),z._LeftHandedBackwardReadOnly=z.Backward(!1),z._RightHandedBackwardReadOnly=z.Backward(!0),z._RightReadOnly=z.Right(),z._LeftReadOnly=z.Left(),z._ZeroReadOnly=z.Zero(),z._OneReadOnly=z.One(),Object.defineProperties(z.prototype,{dimension:{value:[3]},rank:{value:1}});class E{get x(){return this._x}set x(k){this._x=k,this._isDirty=!0}get y(){return this._y}set y(k){this._y=k,this._isDirty=!0}get z(){return this._z}set z(k){this._z=k,this._isDirty=!0}get w(){return this._w}set w(k){this._w=k,this._isDirty=!0}constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=k,this._y=Q,this._z=i,this._w=Z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let k=e(this._x);return k=397*k^e(this._y),k=397*k^e(this._z),k=397*k^e(this._w),k}Zo(){return[this._x,this._y,this._z,this._w]}toArray(k,Q){return void 0===Q&&(Q=0),k[Q]=this._x,k[Q+1]=this._y,k[Q+2]=this._z,k[Q+3]=this._w,this}Ei(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(k,Q,this),this}addInPlace(k){return this.x+=k._x,this.y+=k._y,this.z+=k._z,this.w+=k._w,this}addInPlaceFromFloats(k,Q,i,Z){return this.x+=k,this.y+=Q,this.z+=i,this.w+=Z,this}add(k){return new E(this._x+k.x,this._y+k.y,this._z+k.z,this._w+k.w)}addToRef(k,Q){return Q.x=this._x+k.x,Q.y=this._y+k.y,Q.z=this._z+k.z,Q.w=this._w+k.w,Q}tJ(k){return this.x-=k.x,this.y-=k.y,this.z-=k.z,this.w-=k.w,this}EQ(k){return new E(this._x-k.x,this._y-k.y,this._z-k.z,this._w-k.w)}subtractToRef(k,Q){return Q.x=this._x-k.x,Q.y=this._y-k.y,Q.z=this._z-k.z,Q.w=this._w-k.w,Q}subtractFromFloats(k,Q,i,Z){return new E(this._x-k,this._y-Q,this._z-i,this._w-Z)}subtractFromFloatsToRef(k,Q,i,Z,U){return U.x=this._x-k,U.y=this._y-Q,U.z=this._z-i,U.w=this._w-Z,U}negate(){return new E(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(k){return k.x=-this._x,k.y=-this._y,k.z=-this._z,k.w=-this._w,k}scaleInPlace(k){return this.x*=k,this.y*=k,this.z*=k,this.w*=k,this}scale(k){return new E(this._x*k,this._y*k,this._z*k,this._w*k)}scaleToRef(k,Q){return Q.x=this._x*k,Q.y=this._y*k,Q.z=this._z*k,Q.w=this._w*k,Q}scaleAndAddToRef(k,Q){return Q.x+=this._x*k,Q.y+=this._y*k,Q.z+=this._z*k,Q.w+=this._w*k,Q}equals(k){return k&&this._x===k.x&&this._y===k.y&&this._z===k.z&&this._w===k.w}equalsWithEpsilon(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.e;return k&&(0,m.WithinEpsilon)(this._x,k.x,Q)&&(0,m.WithinEpsilon)(this._y,k.y,Q)&&(0,m.WithinEpsilon)(this._z,k.z,Q)&&(0,m.WithinEpsilon)(this._w,k.w,Q)}equalsToFloats(k,Q,i,Z){return this._x===k&&this._y===Q&&this._z===i&&this._w===Z}multiplyInPlace(k){return this.x*=k.x,this.y*=k.y,this.z*=k.z,this.w*=k.w,this}multiply(k){return new E(this._x*k.x,this._y*k.y,this._z*k.z,this._w*k.w)}multiplyToRef(k,Q){return Q.x=this._x*k.x,Q.y=this._y*k.y,Q.z=this._z*k.z,Q.w=this._w*k.w,Q}multiplyByFloats(k,Q,i,Z){return new E(this._x*k,this._y*Q,this._z*i,this._w*Z)}divide(k){return new E(this._x/k.x,this._y/k.y,this._z/k.z,this._w/k.w)}divideToRef(k,Q){return Q.x=this._x/k.x,Q.y=this._y/k.y,Q.z=this._z/k.z,Q.w=this._w/k.w,Q}divideInPlace(k){return this.divideToRef(k,this)}minimizeInPlace(k){return k.x<this._x&&(this.x=k.x),k.y<this._y&&(this.y=k.y),k.z<this._z&&(this.z=k.z),k.w<this._w&&(this.w=k.w),this}maximizeInPlace(k){return k.x>this._x&&(this.x=k.x),k.y>this._y&&(this.y=k.y),k.z>this._z&&(this.z=k.z),k.w>this._w&&(this.w=k.w),this}minimizeInPlaceFromFloats(k,Q,i,Z){return this.x=Math.min(k,this._x),this.y=Math.min(Q,this._y),this.z=Math.min(i,this._z),this.w=Math.min(Z,this._w),this}maximizeInPlaceFromFloats(k,Q,i,Z){return this.x=Math.max(k,this._x),this.y=Math.max(Q,this._y),this.z=Math.max(i,this._z),this.w=Math.max(Z,this._w),this}floorToRef(k){return k.x=Math.floor(this._x),k.y=Math.floor(this._y),k.z=Math.floor(this._z),k.w=Math.floor(this._w),k}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(k){return k.x=this._x-Math.floor(this._x),k.y=this._y-Math.floor(this._y),k.z=this._z-Math.floor(this._z),k.w=this._w-Math.floor(this._w),k}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(k){return 0===k||1===k?this:this.scaleInPlace(1/k)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(k){const Q=this.length();return 0===Q||1===Q?(k.x=this._x,k.y=this._y,k.z=this._z,k.w=this._w,k):this.scaleToRef(1/Q,k)}toVector3(){return new z(this._x,this._y,this._z)}clone(){return new E(this._x,this._y,this._z,this._w)}B(k){return this.x=k.x,this.y=k.y,this.z=k.z,this.w=k.w,this}Go(k,Q,i,Z){return this.x=k,this.y=Q,this.z=i,this.w=Z,this}set(k,Q,i,Z){return this.Go(k,Q,i,Z)}eo(k){return this.x=this.y=this.z=this.w=k,this}dot(k){return this._x*k.x+this._y*k.y+this._z*k.z+this._w*k.w}static fQ(k,Q){return Q||(Q=0),new E(k[Q],k[Q+1],k[Q+2],k[Q+3])}static FromArrayToRef(k,Q,i){return i.x=k[Q],i.y=k[Q+1],i.z=k[Q+2],i.w=k[Q+3],i}static FromFloatArrayToRef(k,Q,i){return E.FromArrayToRef(k,Q,i),i}static FromFloatsToRef(k,Q,i,Z,U){return U.x=k,U.y=Q,U.z=i,U.w=Z,U}static Zero(){return new E(0,0,0,0)}static One(){return new E(1,1,1,1)}static Random(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q))}static RandomToRef(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0;return i.x=(0,m.RandomRange)(k,Q),i.y=(0,m.RandomRange)(k,Q),i.z=(0,m.RandomRange)(k,Q),i.w=(0,m.RandomRange)(k,Q),i}static Clamp(k,Q,i){return E.ClampToRef(k,Q,i,new E)}static ClampToRef(k,Q,i,Z){return Z.x=(0,m.Clamp)(k.x,Q.x,i.x),Z.y=(0,m.Clamp)(k.y,Q.y,i.y),Z.z=(0,m.Clamp)(k.z,Q.z,i.z),Z.w=(0,m.Clamp)(k.w,Q.w,i.w),Z}static CheckExtends(k,Q,i){Q.minimizeInPlace(k),i.maximizeInPlace(k)}static get ZeroReadOnly(){return E._ZeroReadOnly}static Normalize(k){return E.NormalizeToRef(k,new E)}static NormalizeToRef(k,Q){return k.normalizeToRef(Q),Q}static Minimize(k,Q){const i=new E;return i.B(k),i.minimizeInPlace(Q),i}static Maximize(k,Q){const i=new E;return i.B(k),i.maximizeInPlace(Q),i}static Distance(k,Q){return Math.sqrt(E.DistanceSquared(k,Q))}static DistanceSquared(k,Q){const i=k.x-Q.x,Z=k.y-Q.y,U=k.z-Q.z,C=k.w-Q.w;return i*i+Z*Z+U*U+C*C}static Center(k,Q){return E.CenterToRef(k,Q,new E)}static CenterToRef(k,Q,i){return i.x=(k.x+Q.x)/2,i.y=(k.y+Q.y)/2,i.z=(k.z+Q.z)/2,i.w=(k.w+Q.w)/2,i}static TransformCoordinates(k,Q){return E.TransformCoordinatesToRef(k,Q,new E)}static TransformCoordinatesToRef(k,Q,i){return E.TransformCoordinatesFromFloatsToRef(k._x,k._y,k._z,Q,i),i}static TransformCoordinatesFromFloatsToRef(k,Q,i,Z,U){const C=Z.m,B=k*C[0]+Q*C[4]+i*C[8]+C[12],o=k*C[1]+Q*C[5]+i*C[9]+C[13],m=k*C[2]+Q*C[6]+i*C[10]+C[14],O=k*C[3]+Q*C[7]+i*C[11]+C[15];return U.x=B,U.y=o,U.z=m,U.w=O,U}static TransformNormal(k,Q){return E.TransformNormalToRef(k,Q,new E)}static TransformNormalToRef(k,Q,i){const Z=Q.m,U=k.x*Z[0]+k.y*Z[4]+k.z*Z[8],C=k.x*Z[1]+k.y*Z[5]+k.z*Z[9],B=k.x*Z[2]+k.y*Z[6]+k.z*Z[10];return i.x=U,i.y=C,i.z=B,i.w=k.w,i}static TransformNormalFromFloatsToRef(k,Q,i,Z,U,C){const B=U.m;return C.x=k*B[0]+Q*B[4]+i*B[8],C.y=k*B[1]+Q*B[5]+i*B[9],C.z=k*B[2]+Q*B[6]+i*B[10],C.w=Z,C}static FromVector3(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(k._x,k._y,k._z,Q)}static Dot(k,Q){return k.x*Q.x+k.y*Q.y+k.z*Q.z+k.w*Q.w}}E._V8PerformanceHack=new E(.5,.5,.5,.5),E._ZeroReadOnly=E.Zero(),Object.defineProperties(E.prototype,{dimension:{value:[4]},rank:{value:1}});class l{get x(){return this._x}set x(k){this._x=k,this._isDirty=!0}get y(){return this._y}set y(k){this._y=k,this._isDirty=!0}get z(){return this._z}set z(k){this._z=k,this._isDirty=!0}get w(){return this._w}set w(k){this._w=k,this._isDirty=!0}constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=k,this._y=Q,this._z=i,this._w=Z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let k=e(this._x);return k=397*k^e(this._y),k=397*k^e(this._z),k=397*k^e(this._w),k}Zo(){return[this._x,this._y,this._z,this._w]}toArray(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k[Q]=this._x,k[Q+1]=this._y,k[Q+2]=this._z,k[Q+3]=this._w,this}Ei(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(k,Q,this)}equals(k){return k&&this._x===k._x&&this._y===k._y&&this._z===k._z&&this._w===k._w}equalsWithEpsilon(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.e;return k&&(0,m.WithinEpsilon)(this._x,k._x,Q)&&(0,m.WithinEpsilon)(this._y,k._y,Q)&&(0,m.WithinEpsilon)(this._z,k._z,Q)&&(0,m.WithinEpsilon)(this._w,k._w,Q)}isApprox(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.e;return k&&((0,m.WithinEpsilon)(this._x,k._x,Q)&&(0,m.WithinEpsilon)(this._y,k._y,Q)&&(0,m.WithinEpsilon)(this._z,k._z,Q)&&(0,m.WithinEpsilon)(this._w,k._w,Q)||(0,m.WithinEpsilon)(this._x,-k._x,Q)&&(0,m.WithinEpsilon)(this._y,-k._y,Q)&&(0,m.WithinEpsilon)(this._z,-k._z,Q)&&(0,m.WithinEpsilon)(this._w,-k._w,Q))}clone(){return new l(this._x,this._y,this._z,this._w)}B(k){return this._x=k._x,this._y=k._y,this._z=k._z,this._w=k._w,this._isDirty=!0,this}Go(k,Q,i,Z){return this._x=k,this._y=Q,this._z=i,this._w=Z,this._isDirty=!0,this}set(k,Q,i,Z){return this.Go(k,Q,i,Z)}eo(k){return this.Go(k,k,k,k)}add(k){return new l(this._x+k._x,this._y+k._y,this._z+k._z,this._w+k._w)}addInPlace(k){return this._x+=k._x,this._y+=k._y,this._z+=k._z,this._w+=k._w,this._isDirty=!0,this}addToRef(k,Q){return Q._x=this._x+k._x,Q._y=this._y+k._y,Q._z=this._z+k._z,Q._w=this._w+k._w,Q._isDirty=!0,Q}addInPlaceFromFloats(k,Q,i,Z){return this._x+=k,this._y+=Q,this._z+=i,this._w+=Z,this._isDirty=!0,this}subtractToRef(k,Q){return Q._x=this._x-k._x,Q._y=this._y-k._y,Q._z=this._z-k._z,Q._w=this._w-k._w,Q._isDirty=!0,Q}subtractFromFloats(k,Q,i,Z){return this.subtractFromFloatsToRef(k,Q,i,Z,new l)}subtractFromFloatsToRef(k,Q,i,Z,U){return U._x=this._x-k,U._y=this._y-Q,U._z=this._z-i,U._w=this._w-Z,U._isDirty=!0,U}EQ(k){return new l(this._x-k._x,this._y-k._y,this._z-k._z,this._w-k._w)}tJ(k){return this._x-=k._x,this._y-=k._y,this._z-=k._z,this._w-=k._w,this._isDirty=!0,this}scale(k){return new l(this._x*k,this._y*k,this._z*k,this._w*k)}scaleToRef(k,Q){return Q._x=this._x*k,Q._y=this._y*k,Q._z=this._z*k,Q._w=this._w*k,Q._isDirty=!0,Q}scaleInPlace(k){return this._x*=k,this._y*=k,this._z*=k,this._w*=k,this._isDirty=!0,this}scaleAndAddToRef(k,Q){return Q._x+=this._x*k,Q._y+=this._y*k,Q._z+=this._z*k,Q._w+=this._w*k,Q._isDirty=!0,Q}multiply(k){const Q=new l(0,0,0,1);return this.multiplyToRef(k,Q),Q}multiplyToRef(k,Q){const i=this._x*k._w+this._y*k._z-this._z*k._y+this._w*k._x,Z=-this._x*k._z+this._y*k._w+this._z*k._x+this._w*k._y,U=this._x*k._y-this._y*k._x+this._z*k._w+this._w*k._z,C=-this._x*k._x-this._y*k._y-this._z*k._z+this._w*k._w;return Q.Go(i,Z,U,C),Q}multiplyInPlace(k){return this.multiplyToRef(k,this)}multiplyByFloats(k,Q,i,Z){return this._x*=k,this._y*=Q,this._z*=i,this._w*=Z,this._isDirty=!0,this}divide(k){throw new ReferenceError("Can not divide a quaternion")}divideToRef(k,Q){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(k){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new l)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(k){return k._x=-this._x,k._y=-this._y,k._z=-this._z,k._w=-this._w,k._isDirty=!0,k}equalsToFloats(k,Q,i,Z){return this._x===k&&this._y===Q&&this._z===i&&this._w===Z}floorToRef(k){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(k){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(k){return k.Go(-this._x,-this._y,-this._z,this._w),k}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new l(-this._x,-this._y,-this._z,this._w)}invert(){const k=this.conjugate(),Q=this.lengthSquared();return 0==Q||1==Q||k.scaleInPlace(1/Q),k}invertInPlace(){this.conjugateInPlace();const k=this.lengthSquared();return 0==k||1==k||this.scaleInPlace(1/k),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(k){return 0===k||1===k?this:this.scaleInPlace(1/k)}normalizeToNew(){const k=new l(0,0,0,1);return this.normalizeToRef(k),k}normalizeToRef(k){const Q=this.length();return 0===Q||1===Q?k.Go(this._x,this._y,this._z,this._w):this.scaleToRef(1/Q,k)}toEulerAngles(){const k=z.Zero();return this.toEulerAnglesToRef(k),k}toEulerAnglesToRef(k){const Q=this._z,i=this._x,Z=this._y,U=this._w,C=Z*Q-i*U,B=.4999999;if(C<-B)k._y=2*Math.atan2(Z,U),k._x=Math.PI/2,k._z=0,k._isDirty=!0;else if(C>B)k._y=2*Math.atan2(Z,U),k._x=-Math.PI/2,k._z=0,k._isDirty=!0;else{const B=U*U,o=Q*Q,m=i*i,O=Z*Z;k._z=Math.atan2(2*(i*Z+Q*U),-o-m+O+B),k._x=Math.asin(-2*C),k._y=Math.atan2(2*(Q*i+Z*U),o-m-O+B),k._isDirty=!0}return k}toAlphaBetaGammaToRef(k){const Q=this._z,i=this._x,Z=this._y,U=this._w,C=Math.sqrt(i*i+Z*Z),B=Math.sqrt(Q*Q+U*U),o=2*Math.atan2(C,B),m=2*Math.atan2(Q,U),O=2*Math.atan2(Z,i),J=(m+O)/2,G=(m-O)/2;return k.set(G,o,J),k}toRotationMatrix(k){return h.FromQuaternionToRef(this,k),k}fromRotationMatrix(k){return l.FromRotationMatrixToRef(k,this),this}dot(k){return this._x*k._x+this._y*k._y+this._z*k._z+this._w*k._w}toAxisAngle(){const k=z.Zero();return{axis:k,angle:this.toAxisAngleToRef(k)}}toAxisAngleToRef(k){let Q=0;const i=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),Z=this._w;return i>0?(Q=2*Math.atan2(i,Z),k.set(this._x/i,this._y/i,this._z/i)):(Q=0,k.set(1,0,0)),Q}static FromRotationMatrix(k){const Q=new l;return l.FromRotationMatrixToRef(k,Q),Q}static FromRotationMatrixToRef(k,Q){const i=k.m,Z=i[0],U=i[4],C=i[8],B=i[1],o=i[5],m=i[9],O=i[2],J=i[6],G=i[10],H=Z+o+G;let e;return H>0?(e=.5/Math.sqrt(H+1),Q._w=.25/e,Q._x=(J-m)*e,Q._y=(C-O)*e,Q._z=(B-U)*e,Q._isDirty=!0):Z>o&&Z>G?(e=2*Math.sqrt(1+Z-o-G),Q._w=(J-m)/e,Q._x=.25*e,Q._y=(U+B)/e,Q._z=(C+O)/e,Q._isDirty=!0):o>G?(e=2*Math.sqrt(1+o-Z-G),Q._w=(C-O)/e,Q._x=(U+B)/e,Q._y=.25*e,Q._z=(m+J)/e,Q._isDirty=!0):(e=2*Math.sqrt(1+G-Z-o),Q._w=(B-U)/e,Q._x=(C+O)/e,Q._y=(m+J)/e,Q._z=.25*e,Q._isDirty=!0),Q}static Dot(k,Q){return k._x*Q._x+k._y*Q._y+k._z*Q._z+k._w*Q._w}static AreClose(k,Q){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const Z=l.Dot(k,Q);return 1-Z*Z<=i}static SmoothToRef(k,Q,i,Z,U){let C=0===Z?1:i/Z;return C=(0,m.Clamp)(C,0,1),l.SlerpToRef(k,Q,C,U),U}static Zero(){return new l(0,0,0,0)}static Inverse(k){return new l(-k._x,-k._y,-k._z,k._w)}static InverseToRef(k,Q){return Q.set(-k._x,-k._y,-k._z,k._w),Q}static Identity(){return new l(0,0,0,1)}static IsIdentity(k){return k&&0===k._x&&0===k._y&&0===k._z&&1===k._w}static RotationAxis(k,Q){return l.RotationAxisToRef(k,Q,new l)}static RotationAxisToRef(k,Q,i){i._w=Math.cos(Q/2);const Z=Math.sin(Q/2)/k.length();return i._x=k._x*Z,i._y=k._y*Z,i._z=k._z*Z,i._isDirty=!0,i}static fQ(k,Q){return Q||(Q=0),new l(k[Q],k[Q+1],k[Q+2],k[Q+3])}static FromArrayToRef(k,Q,i){return i._x=k[Q],i._y=k[Q+1],i._z=k[Q+2],i._w=k[Q+3],i._isDirty=!0,i}static FromFloatsToRef(k,Q,i,Z,U){return U.Go(k,Q,i,Z),U}static FromEulerAngles(k,Q,i){const Z=new l;return l.RotationYawPitchRollToRef(Q,k,i,Z),Z}static FromEulerAnglesToRef(k,Q,i,Z){return l.RotationYawPitchRollToRef(Q,k,i,Z),Z}static FromEulerVector(k){const Q=new l;return l.RotationYawPitchRollToRef(k._y,k._x,k._z,Q),Q}static FromEulerVectorToRef(k,Q){return l.RotationYawPitchRollToRef(k._y,k._x,k._z,Q),Q}static FromUnitVectorsToRef(k,Q,i){let U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Z.e;const C=z.Dot(k,Q)+1;return C<U?Math.abs(k.x)>Math.abs(k.z)?i.set(-k.y,k.x,0,0):i.set(0,-k.z,k.y,0):(z.CrossToRef(k,Q,f.zQ[0]),i.set(f.zQ[0].x,f.zQ[0].y,f.zQ[0].z,C)),i.normalize()}static RotationYawPitchRoll(k,Q,i){const Z=new l;return l.RotationYawPitchRollToRef(k,Q,i,Z),Z}static RotationYawPitchRollToRef(k,Q,i,Z){const U=.5*i,C=.5*Q,B=.5*k,o=Math.sin(U),m=Math.cos(U),O=Math.sin(C),J=Math.cos(C),G=Math.sin(B),H=Math.cos(B);return Z._x=H*O*m+G*J*o,Z._y=G*J*m-H*O*o,Z._z=H*J*o-G*O*m,Z._w=H*J*m+G*O*o,Z._isDirty=!0,Z}static RotationAlphaBetaGamma(k,Q,i){const Z=new l;return l.RotationAlphaBetaGammaToRef(k,Q,i,Z),Z}static RotationAlphaBetaGammaToRef(k,Q,i,Z){const U=.5*(i+k),C=.5*(i-k),B=.5*Q;return Z._x=Math.cos(C)*Math.sin(B),Z._y=Math.sin(C)*Math.sin(B),Z._z=Math.sin(U)*Math.cos(B),Z._w=Math.cos(U)*Math.cos(B),Z._isDirty=!0,Z}static RotationQuaternionFromAxis(k,Q,i){const Z=new l(0,0,0,0);return l.RotationQuaternionFromAxisToRef(k,Q,i,Z),Z}static RotationQuaternionFromAxisToRef(k,Q,i,Z){const U=c.Matrix[0];return k=k.normalizeToRef(c.zQ[0]),Q=Q.normalizeToRef(c.zQ[1]),i=i.normalizeToRef(c.zQ[2]),h.FromXYZAxesToRef(k,Q,i,U),l.FromRotationMatrixToRef(U,Z),Z}static FromLookDirectionLH(k,Q){const i=new l;return l.FromLookDirectionLHToRef(k,Q,i),i}static FromLookDirectionLHToRef(k,Q,i){const Z=c.Matrix[0];return h.LookDirectionLHToRef(k,Q,Z),l.FromRotationMatrixToRef(Z,i),i}static FromLookDirectionRH(k,Q){const i=new l;return l.FromLookDirectionRHToRef(k,Q,i),i}static FromLookDirectionRHToRef(k,Q,i){const Z=c.Matrix[0];return h.LookDirectionRHToRef(k,Q,Z),l.FromRotationMatrixToRef(Z,i)}static Slerp(k,Q,i){const Z=l.Identity();return l.SlerpToRef(k,Q,i,Z),Z}static SlerpToRef(k,Q,i,Z){let U,C,B=k._x*Q._x+k._y*Q._y+k._z*Q._z+k._w*Q._w,o=!1;if(B<0&&(o=!0,B=-B),B>.999999)C=1-i,U=o?-i:i;else{const k=Math.acos(B),Q=1/Math.sin(k);C=Math.sin((1-i)*k)*Q,U=o?-Math.sin(i*k)*Q:Math.sin(i*k)*Q}return Z._x=C*k._x+U*Q._x,Z._y=C*k._y+U*Q._y,Z._z=C*k._z+U*Q._z,Z._w=C*k._w+U*Q._w,Z._isDirty=!0,Z}static Hermite(k,Q,i,Z,U){const C=U*U,B=U*C,o=2*B-3*C+1,m=-2*B+3*C,O=B-2*C+U,J=B-C,G=k._x*o+i._x*m+Q._x*O+Z._x*J,H=k._y*o+i._y*m+Q._y*O+Z._y*J,e=k._z*o+i._z*m+Q._z*O+Z._z*J,F=k._w*o+i._w*m+Q._w*O+Z._w*J;return new l(G,H,e,F)}static Hermite1stDerivative(k,Q,i,Z,U){const C=new l;return this.Hermite1stDerivativeToRef(k,Q,i,Z,U,C),C}static Hermite1stDerivativeToRef(k,Q,i,Z,U,C){const B=U*U;return C._x=6*(B-U)*k._x+(3*B-4*U+1)*Q._x+6*(-B+U)*i._x+(3*B-2*U)*Z._x,C._y=6*(B-U)*k._y+(3*B-4*U+1)*Q._y+6*(-B+U)*i._y+(3*B-2*U)*Z._y,C._z=6*(B-U)*k._z+(3*B-4*U+1)*Q._z+6*(-B+U)*i._z+(3*B-2*U)*Z._z,C._w=6*(B-U)*k._w+(3*B-4*U+1)*Q._w+6*(-B+U)*i._w+(3*B-2*U)*Z._w,C._isDirty=!0,C}static Normalize(k){const Q=l.Zero();return l.NormalizeToRef(k,Q),Q}static NormalizeToRef(k,Q){return k.normalizeToRef(Q),Q}static Clamp(k,Q,i){const Z=new l;return l.ClampToRef(k,Q,i,Z),Z}static ClampToRef(k,Q,i,Z){return Z.Go((0,m.Clamp)(k.x,Q.x,i.x),(0,m.Clamp)(k.y,Q.y,i.y),(0,m.Clamp)(k.z,Q.z,i.z),(0,m.Clamp)(k.w,Q.w,i.w))}static Random(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new l((0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q))}static RandomToRef(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Go((0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q),(0,m.RandomRange)(k,Q))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(k,Q){return Math.sqrt(l.DistanceSquared(k,Q))}static DistanceSquared(k,Q){const i=k.x-Q.x,Z=k.y-Q.y,U=k.z-Q.z,C=k.w-Q.w;return i*i+Z*Z+U*U+C*C}static Center(k,Q){return l.CenterToRef(k,Q,l.Zero())}static CenterToRef(k,Q,i){return i.Go((k.x+Q.x)/2,(k.y+Q.y)/2,(k.z+Q.z)/2,(k.w+Q.w)/2)}}l._V8PerformanceHack=new l(.5,.5,.5,.5),Object.defineProperties(l.prototype,{dimension:{value:[4]},rank:{value:1}});class h{static get Use64Bits(){return B.d.MatrixUse64Bits}get m(){return this.ri}markAsUpdated(){this.updateFlag=O._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(k){let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Z=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=k,this._isIdentity3x2=k||i,this._isIdentityDirty=!this._isIdentity&&Q,this._isIdentity3x2Dirty=!this._isIdentity3x2&&Z}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,B.d.MatrixTrackPrecisionChange&&B.d.MatrixTrackedMatrices.push(this),this.ri=new B.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const k=this.ri;this._isIdentity=1===k[0]&&0===k[1]&&0===k[2]&&0===k[3]&&0===k[4]&&1===k[5]&&0===k[6]&&0===k[7]&&0===k[8]&&0===k[9]&&1===k[10]&&0===k[11]&&0===k[12]&&0===k[13]&&0===k[14]&&1===k[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ri[0]||1!==this.ri[5]||1!==this.ri[15]||0!==this.ri[1]||0!==this.ri[2]||0!==this.ri[3]||0!==this.ri[4]||0!==this.ri[6]||0!==this.ri[7]||0!==this.ri[8]||0!==this.ri[9]||0!==this.ri[10]||0!==this.ri[11]||0!==this.ri[12]||0!==this.ri[13]||0!==this.ri[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const k=this.ri,Q=k[0],i=k[1],Z=k[2],U=k[3],C=k[4],B=k[5],o=k[6],m=k[7],O=k[8],J=k[9],G=k[10],H=k[11],e=k[12],F=k[13],z=k[14],E=k[15],l=G*E-z*H,h=J*E-F*H,c=J*z-F*G,f=O*E-e*H,Y=O*z-G*e,y=O*F-e*J;return Q*+(B*l-o*h+m*c)+i*-(C*l-o*f+m*Y)+Z*+(C*h-B*f+m*y)+U*-(C*c-B*Y+o*y)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!k)return this.ri;const i=this.ri;for(let Z=0;Z<16;Z++)k[Q+Z]=i[Z];return this}Zo(){return this.ri}Ei(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h.FromArrayToRef(k,Q,this)}Go(){for(var k=arguments.length,Q=new Array(k),i=0;i<k;i++)Q[i]=arguments[i];return h.FromArrayToRef(Q,0,this)}set(){const k=this.ri;for(let Q=0;Q<16;Q++)k[Q]=Q<0||arguments.length<=Q?void 0:arguments[Q];return this.markAsUpdated(),this}eo(k){const Q=this.ri;for(let i=0;i<16;i++)Q[i]=k;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return h.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(k){const Q=new h;return this.addToRef(k,Q),Q}addToRef(k,Q){const i=this.ri,Z=Q.ri,U=k.m;for(let C=0;C<16;C++)Z[C]=i[C]+U[C];return Q.markAsUpdated(),Q}addToSelf(k){const Q=this.ri,i=k.m;return Q[0]+=i[0],Q[1]+=i[1],Q[2]+=i[2],Q[3]+=i[3],Q[4]+=i[4],Q[5]+=i[5],Q[6]+=i[6],Q[7]+=i[7],Q[8]+=i[8],Q[9]+=i[9],Q[10]+=i[10],Q[11]+=i[11],Q[12]+=i[12],Q[13]+=i[13],Q[14]+=i[14],Q[15]+=i[15],this.markAsUpdated(),this}addInPlace(k){const Q=this.ri,i=k.m;for(let Z=0;Z<16;Z++)Q[Z]+=i[Z];return this.markAsUpdated(),this}addInPlaceFromFloats(){const k=this.ri;for(let Q=0;Q<16;Q++)k[Q]+=Q<0||arguments.length<=Q?void 0:arguments[Q];return this.markAsUpdated(),this}EQ(k){const Q=this.ri,i=k.m;for(let Z=0;Z<16;Z++)Q[Z]-=i[Z];return this.markAsUpdated(),this}subtractToRef(k,Q){const i=this.ri,Z=k.m,U=Q.ri;for(let C=0;C<16;C++)U[C]=i[C]-Z[C];return Q.markAsUpdated(),Q}tJ(k){const Q=this.ri,i=k.m;for(let Z=0;Z<16;Z++)Q[Z]-=i[Z];return this.markAsUpdated(),this}subtractFromFloats(){for(var k=arguments.length,Q=new Array(k),i=0;i<k;i++)Q[i]=arguments[i];return this.subtractFromFloatsToRef(...Q,new h)}subtractFromFloatsToRef(){for(var k=arguments.length,Q=new Array(k),i=0;i<k;i++)Q[i]=arguments[i];const Z=Q.pop(),U=this.ri,C=Z.ri,B=Q;for(let o=0;o<16;o++)C[o]=U[o]-B[o];return Z.markAsUpdated(),Z}invertToRef(k){return!0===this._isIdentity?(h.IdentityToRef(k),k):(H(this,k.Zo())?k.markAsUpdated():k.B(this),k)}addAtIndex(k,Q){return this.ri[k]+=Q,this.markAsUpdated(),this}multiplyAtIndex(k,Q){return this.ri[k]*=Q,this.markAsUpdated(),this}setTranslationFromFloats(k,Q,i){return this.ri[12]=k,this.ri[13]=Q,this.ri[14]=i,this.markAsUpdated(),this}addTranslationFromFloats(k,Q,i){return this.ri[12]+=k,this.ri[13]+=Q,this.ri[14]+=i,this.markAsUpdated(),this}setTranslation(k){return this.setTranslationFromFloats(k._x,k._y,k._z)}getTranslation(){return new z(this.ri[12],this.ri[13],this.ri[14])}getTranslationToRef(k){return k.x=this.ri[12],k.y=this.ri[13],k.z=this.ri[14],k}removeRotationAndScaling(){const k=this.m;return h.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,k[12],k[13],k[14],k[15],this),this._updateIdentityStatus(0===k[12]&&0===k[13]&&0===k[14]&&1===k[15]),this}B(k){k.copyToArray(this.ri);const Q=k;return this.updateFlag=Q.updateFlag,this._updateIdentityStatus(Q._isIdentity,Q._isIdentityDirty,Q._isIdentity3x2,Q._isIdentity3x2Dirty),this}copyToArray(k){return G(this,k,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(k){const Q=new h;return this.multiplyToRef(k,Q),Q}multiplyInPlace(k){const Q=this.ri,i=k.m;for(let Z=0;Z<16;Z++)Q[Z]*=i[Z];return this.markAsUpdated(),this}multiplyByFloats(){const k=this.ri;for(let Q=0;Q<16;Q++)k[Q]*=Q<0||arguments.length<=Q?void 0:arguments[Q];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var k=arguments.length,Q=new Array(k),i=0;i<k;i++)Q[i]=arguments[i];const Z=Q.pop(),U=this.ri,C=Z.ri,B=Q;for(let o=0;o<16;o++)C[o]=U[o]*B[o];return Z.markAsUpdated(),Z}multiplyToRef(k,Q){return this._isIdentity?(Q.B(k),Q):k._isIdentity?(Q.B(this),Q):(this.multiplyToArray(k,Q.ri,0),Q.markAsUpdated(),Q)}multiplyToArray(k,Q,i){return J(this,k,Q,i),this}divide(k){return this.divideToRef(k,new h)}divideToRef(k,Q){const i=this.ri,Z=k.m,U=Q.ri;for(let C=0;C<16;C++)U[C]=i[C]/Z[C];return Q.markAsUpdated(),Q}divideInPlace(k){const Q=this.ri,i=k.m;for(let Z=0;Z<16;Z++)Q[Z]/=i[Z];return this.markAsUpdated(),this}minimizeInPlace(k){const Q=this.ri,i=k.m;for(let Z=0;Z<16;Z++)Q[Z]=Math.min(Q[Z],i[Z]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const k=this.ri;for(let Q=0;Q<16;Q++)k[Q]=Math.min(k[Q],Q<0||arguments.length<=Q?void 0:arguments[Q]);return this.markAsUpdated(),this}maximizeInPlace(k){const Q=this.ri,i=k.m;for(let Z=0;Z<16;Z++)Q[Z]=Math.min(Q[Z],i[Z]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const k=this.ri;for(let Q=0;Q<16;Q++)k[Q]=Math.min(k[Q],Q<0||arguments.length<=Q?void 0:arguments[Q]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new h)}negateInPlace(){const k=this.ri;for(let Q=0;Q<16;Q++)k[Q]=-k[Q];return this.markAsUpdated(),this}negateToRef(k){const Q=this.ri,i=k.ri;for(let Z=0;Z<16;Z++)i[Z]=-Q[Z];return k.markAsUpdated(),k}equals(k){const Q=k;if(!Q)return!1;if((this._isIdentity||Q._isIdentity)&&!this._isIdentityDirty&&!Q._isIdentityDirty)return this._isIdentity&&Q._isIdentity;const i=this.m,Z=Q.m;return i[0]===Z[0]&&i[1]===Z[1]&&i[2]===Z[2]&&i[3]===Z[3]&&i[4]===Z[4]&&i[5]===Z[5]&&i[6]===Z[6]&&i[7]===Z[7]&&i[8]===Z[8]&&i[9]===Z[9]&&i[10]===Z[10]&&i[11]===Z[11]&&i[12]===Z[12]&&i[13]===Z[13]&&i[14]===Z[14]&&i[15]===Z[15]}equalsWithEpsilon(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const i=this.ri,Z=k.m;for(let U=0;U<16;U++)if(!(0,m.WithinEpsilon)(i[U],Z[U],Q))return!1;return!0}equalsToFloats(){const k=this.ri;for(let Q=0;Q<16;Q++)if(k[Q]!=(Q<0||arguments.length<=Q?void 0:arguments[Q]))return!1;return!0}floor(){return this.floorToRef(new h)}floorToRef(k){const Q=this.ri,i=k.ri;for(let Z=0;Z<16;Z++)i[Z]=Math.floor(Q[Z]);return k.markAsUpdated(),k}fract(){return this.fractToRef(new h)}fractToRef(k){const Q=this.ri,i=k.ri;for(let Z=0;Z<16;Z++)i[Z]=Q[Z]-Math.floor(Q[Z]);return k.markAsUpdated(),k}clone(){const k=new h;return k.B(this),k}getClassName(){return"Matrix"}getHashCode(){let k=e(this.ri[0]);for(let Q=1;Q<16;Q++)k=397*k^e(this.ri[Q]);return k}decomposeToTransformNode(k){return k.rotationQuaternion=k.rotationQuaternion||new l,this.decompose(k.Ho,k.rotationQuaternion,k.position)}decompose(k,Q,i,Z){let U=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return i&&i.eo(0),k&&k.eo(1),Q&&Q.Go(0,0,0,1),!0;const C=this.ri;if(i&&i.Go(C[12],C[13],C[14]),(k=k||c.zQ[0]).x=Math.sqrt(C[0]*C[0]+C[1]*C[1]+C[2]*C[2]),k.y=Math.sqrt(C[4]*C[4]+C[5]*C[5]+C[6]*C[6]),k.z=Math.sqrt(C[8]*C[8]+C[9]*C[9]+C[10]*C[10]),Z){const Q=(U?Z.absoluteScaling.x:Z.Ho.x)<0?-1:1,i=(U?Z.absoluteScaling.y:Z.Ho.y)<0?-1:1,C=(U?Z.absoluteScaling.z:Z.Ho.z)<0?-1:1;k.x*=Q,k.y*=i,k.z*=C}else this.determinant()<=0&&(k.y*=-1);if(0===k._x||0===k._y||0===k._z)return Q&&Q.Go(0,0,0,1),!1;if(Q){const i=1/k._x,Z=1/k._y,U=1/k._z;h.FromValuesToRef(C[0]*i,C[1]*i,C[2]*i,0,C[4]*Z,C[5]*Z,C[6]*Z,0,C[8]*U,C[9]*U,C[10]*U,0,0,0,0,1,c.Matrix[0]),l.FromRotationMatrixToRef(c.Matrix[0],Q)}return!0}getRow(k){if(k<0||k>3)return null;const Q=4*k;return new E(this.ri[Q+0],this.ri[Q+1],this.ri[Q+2],this.ri[Q+3])}getRowToRef(k,Q){if(k>=0&&k<=3){const i=4*k;Q.x=this.ri[i+0],Q.y=this.ri[i+1],Q.z=this.ri[i+2],Q.w=this.ri[i+3]}return Q}setRow(k,Q){return this.setRowFromFloats(k,Q.x,Q.y,Q.z,Q.w)}transpose(){const k=new h;return h.TransposeToRef(this,k),k}transposeToRef(k){return h.TransposeToRef(this,k),k}setRowFromFloats(k,Q,i,Z,U){if(k<0||k>3)return this;const C=4*k;return this.ri[C+0]=Q,this.ri[C+1]=i,this.ri[C+2]=Z,this.ri[C+3]=U,this.markAsUpdated(),this}scale(k){const Q=new h;return this.scaleToRef(k,Q),Q}scaleToRef(k,Q){for(let i=0;i<16;i++)Q.ri[i]=this.ri[i]*k;return Q.markAsUpdated(),Q}scaleAndAddToRef(k,Q){for(let i=0;i<16;i++)Q.ri[i]+=this.ri[i]*k;return Q.markAsUpdated(),Q}scaleInPlace(k){const Q=this.ri;for(let i=0;i<16;i++)Q[i]*=k;return this.markAsUpdated(),this}toNormalMatrix(k){const Q=c.Matrix[0];this.invertToRef(Q),Q.transposeToRef(k);const i=k.ri;return h.FromValuesToRef(i[0],i[1],i[2],0,i[4],i[5],i[6],0,i[8],i[9],i[10],0,0,0,0,1,k),k}getRotationMatrix(){const k=new h;return this.getRotationMatrixToRef(k),k}getRotationMatrixToRef(k){const Q=c.zQ[0];if(!this.decompose(Q))return h.IdentityToRef(k),k;const i=this.ri,Z=1/Q._x,U=1/Q._y,C=1/Q._z;return h.FromValuesToRef(i[0]*Z,i[1]*Z,i[2]*Z,0,i[4]*U,i[5]*U,i[6]*U,0,i[8]*C,i[9]*C,i[10]*C,0,0,0,0,1,k),k}toggleModelMatrixHandInPlace(){const k=this.ri;return k[2]*=-1,k[6]*=-1,k[8]*=-1,k[9]*=-1,k[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const k=this.ri;return k[8]*=-1,k[9]*=-1,k[10]*=-1,k[11]*=-1,this.markAsUpdated(),this}static fQ(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const i=new h;return h.FromArrayToRef(k,Q,i),i}static FromArrayToRef(k,Q,i){for(let Z=0;Z<16;Z++)i.ri[Z]=k[Z+Q];return i.markAsUpdated(),i}static FromFloat32ArrayToRefScaled(k,Q,i,Z){return Z.ri[0]=k[0+Q]*i,Z.ri[1]=k[1+Q]*i,Z.ri[2]=k[2+Q]*i,Z.ri[3]=k[3+Q]*i,Z.ri[4]=k[4+Q]*i,Z.ri[5]=k[5+Q]*i,Z.ri[6]=k[6+Q]*i,Z.ri[7]=k[7+Q]*i,Z.ri[8]=k[8+Q]*i,Z.ri[9]=k[9+Q]*i,Z.ri[10]=k[10+Q]*i,Z.ri[11]=k[11+Q]*i,Z.ri[12]=k[12+Q]*i,Z.ri[13]=k[13+Q]*i,Z.ri[14]=k[14+Q]*i,Z.ri[15]=k[15+Q]*i,Z.markAsUpdated(),Z}static get IdentityReadOnly(){return h._IdentityReadOnly}static FromValuesToRef(k,Q,i,Z,U,C,B,o,m,O,J,G,H,e,F,z,E){const l=E.ri;l[0]=k,l[1]=Q,l[2]=i,l[3]=Z,l[4]=U,l[5]=C,l[6]=B,l[7]=o,l[8]=m,l[9]=O,l[10]=J,l[11]=G,l[12]=H,l[13]=e,l[14]=F,l[15]=z,E.markAsUpdated()}static FromValues(k,Q,i,Z,U,C,B,o,m,O,J,G,H,e,F,z){const E=new h,l=E.ri;return l[0]=k,l[1]=Q,l[2]=i,l[3]=Z,l[4]=U,l[5]=C,l[6]=B,l[7]=o,l[8]=m,l[9]=O,l[10]=J,l[11]=G,l[12]=H,l[13]=e,l[14]=F,l[15]=z,E.markAsUpdated(),E}static Compose(k,Q,i){const Z=new h;return h.ComposeToRef(k,Q,i,Z),Z}static ComposeToRef(k,Q,i,Z){const U=Z.ri,C=Q._x,B=Q._y,o=Q._z,m=Q._w,O=C+C,J=B+B,G=o+o,H=C*O,e=C*J,F=C*G,z=B*J,E=B*G,l=o*G,h=m*O,c=m*J,f=m*G,Y=k._x,y=k._y,L=k._z;return U[0]=(1-(z+l))*Y,U[1]=(e+f)*Y,U[2]=(F-c)*Y,U[3]=0,U[4]=(e-f)*y,U[5]=(1-(H+l))*y,U[6]=(E+h)*y,U[7]=0,U[8]=(F+c)*L,U[9]=(E-h)*L,U[10]=(1-(H+z))*L,U[11]=0,U[12]=i._x,U[13]=i._y,U[14]=i._z,U[15]=1,Z.markAsUpdated(),Z}static Identity(){const k=h.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return k._updateIdentityStatus(!0),k}static IdentityToRef(k){return h.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,k),k._updateIdentityStatus(!0),k}static Zero(){const k=h.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return k._updateIdentityStatus(!1),k}static RotationX(k){const Q=new h;return h.RotationXToRef(k,Q),Q}static Invert(k){const Q=new h;return k.invertToRef(Q),Q}static RotationXToRef(k,Q){const i=Math.sin(k),Z=Math.cos(k);return h.FromValuesToRef(1,0,0,0,0,Z,i,0,0,-i,Z,0,0,0,0,1,Q),Q._updateIdentityStatus(1===Z&&0===i),Q}static RotationY(k){const Q=new h;return h.RotationYToRef(k,Q),Q}static RotationYToRef(k,Q){const i=Math.sin(k),Z=Math.cos(k);return h.FromValuesToRef(Z,0,-i,0,0,1,0,0,i,0,Z,0,0,0,0,1,Q),Q._updateIdentityStatus(1===Z&&0===i),Q}static RotationZ(k){const Q=new h;return h.RotationZToRef(k,Q),Q}static RotationZToRef(k,Q){const i=Math.sin(k),Z=Math.cos(k);return h.FromValuesToRef(Z,i,0,0,-i,Z,0,0,0,0,1,0,0,0,0,1,Q),Q._updateIdentityStatus(1===Z&&0===i),Q}static RotationAxis(k,Q){const i=new h;return h.RotationAxisToRef(k,Q,i),i}static RotationAxisToRef(k,Q,i){const Z=Math.sin(-Q),U=Math.cos(-Q),C=1-U;k=k.normalizeToRef(c.zQ[0]);const B=i.ri;return B[0]=k._x*k._x*C+U,B[1]=k._x*k._y*C-k._z*Z,B[2]=k._x*k._z*C+k._y*Z,B[3]=0,B[4]=k._y*k._x*C+k._z*Z,B[5]=k._y*k._y*C+U,B[6]=k._y*k._z*C-k._x*Z,B[7]=0,B[8]=k._z*k._x*C-k._y*Z,B[9]=k._z*k._y*C+k._x*Z,B[10]=k._z*k._z*C+U,B[11]=0,B[12]=0,B[13]=0,B[14]=0,B[15]=1,i.markAsUpdated(),i}static RotationAlignToRef(k,Q,i){let U=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const C=z.Dot(Q,k),B=i.ri;if(C<-1+Z.e)B[0]=-1,B[1]=0,B[2]=0,B[3]=0,B[4]=0,B[5]=U?1:-1,B[6]=0,B[7]=0,B[8]=0,B[9]=0,B[10]=U?-1:1,B[11]=0;else{const i=z.Cross(Q,k),Z=1/(1+C);B[0]=i._x*i._x*Z+C,B[1]=i._y*i._x*Z-i._z,B[2]=i._z*i._x*Z+i._y,B[3]=0,B[4]=i._x*i._y*Z+i._z,B[5]=i._y*i._y*Z+C,B[6]=i._z*i._y*Z-i._x,B[7]=0,B[8]=i._x*i._z*Z-i._y,B[9]=i._y*i._z*Z+i._x,B[10]=i._z*i._z*Z+C,B[11]=0}return B[12]=0,B[13]=0,B[14]=0,B[15]=1,i.markAsUpdated(),i}static RotationYawPitchRoll(k,Q,i){const Z=new h;return h.RotationYawPitchRollToRef(k,Q,i,Z),Z}static RotationYawPitchRollToRef(k,Q,i,Z){return l.RotationYawPitchRollToRef(k,Q,i,c.Quaternion[0]),c.Quaternion[0].toRotationMatrix(Z),Z}static Scaling(k,Q,i){const Z=new h;return h.ScalingToRef(k,Q,i,Z),Z}static ScalingToRef(k,Q,i,Z){return h.FromValuesToRef(k,0,0,0,0,Q,0,0,0,0,i,0,0,0,0,1,Z),Z._updateIdentityStatus(1===k&&1===Q&&1===i),Z}static Translation(k,Q,i){const Z=new h;return h.TranslationToRef(k,Q,i,Z),Z}static TranslationToRef(k,Q,i,Z){return h.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,k,Q,i,1,Z),Z._updateIdentityStatus(0===k&&0===Q&&0===i),Z}static Lerp(k,Q,i){const Z=new h;return h.LerpToRef(k,Q,i,Z),Z}static LerpToRef(k,Q,i,Z){const U=Z.ri,C=k.m,B=Q.m;for(let o=0;o<16;o++)U[o]=C[o]*(1-i)+B[o]*i;return Z.markAsUpdated(),Z}static DecomposeLerp(k,Q,i){const Z=new h;return h.DecomposeLerpToRef(k,Q,i,Z),Z}static DecomposeLerpToRef(k,Q,i,Z){const U=c.zQ[0],C=c.Quaternion[0],B=c.zQ[1];k.decompose(U,C,B);const o=c.zQ[2],m=c.Quaternion[1],O=c.zQ[3];Q.decompose(o,m,O);const J=c.zQ[4];z.LerpToRef(U,o,i,J);const G=c.Quaternion[2];l.SlerpToRef(C,m,i,G);const H=c.zQ[5];return z.LerpToRef(B,O,i,H),h.ComposeToRef(J,G,H,Z),Z}static LookAtLH(k,Q,i){const Z=new h;return h.LookAtLHToRef(k,Q,i,Z),Z}static LookAtLHToRef(k,Q,i,Z){const U=c.zQ[0],C=c.zQ[1],B=c.zQ[2];Q.subtractToRef(k,B),B.normalize(),z.CrossToRef(i,B,U);const o=U.lengthSquared();0===o?U.x=1:U.normalizeFromLength(Math.sqrt(o)),z.CrossToRef(B,U,C),C.normalize();const m=-z.Dot(U,k),O=-z.Dot(C,k),J=-z.Dot(B,k);return h.FromValuesToRef(U._x,C._x,B._x,0,U._y,C._y,B._y,0,U._z,C._z,B._z,0,m,O,J,1,Z),Z}static LookAtRH(k,Q,i){const Z=new h;return h.LookAtRHToRef(k,Q,i,Z),Z}static LookAtRHToRef(k,Q,i,Z){const U=c.zQ[0],C=c.zQ[1],B=c.zQ[2];k.subtractToRef(Q,B),B.normalize(),z.CrossToRef(i,B,U);const o=U.lengthSquared();0===o?U.x=1:U.normalizeFromLength(Math.sqrt(o)),z.CrossToRef(B,U,C),C.normalize();const m=-z.Dot(U,k),O=-z.Dot(C,k),J=-z.Dot(B,k);return h.FromValuesToRef(U._x,C._x,B._x,0,U._y,C._y,B._y,0,U._z,C._z,B._z,0,m,O,J,1,Z),Z}static LookDirectionLH(k,Q){const i=new h;return h.LookDirectionLHToRef(k,Q,i),i}static LookDirectionLHToRef(k,Q,i){const Z=c.zQ[0];Z.B(k),Z.scaleInPlace(-1);const U=c.zQ[1];return z.CrossToRef(Q,Z,U),h.FromValuesToRef(U._x,U._y,U._z,0,Q._x,Q._y,Q._z,0,Z._x,Z._y,Z._z,0,0,0,0,1,i),i}static LookDirectionRH(k,Q){const i=new h;return h.LookDirectionRHToRef(k,Q,i),i}static LookDirectionRHToRef(k,Q,i){const Z=c.zQ[2];return z.CrossToRef(Q,k,Z),h.FromValuesToRef(Z._x,Z._y,Z._z,0,Q._x,Q._y,Q._z,0,k._x,k._y,k._z,0,0,0,0,1,i),i}static OrthoLH(k,Q,i,Z,U){const C=new h;return h.OrthoLHToRef(k,Q,i,Z,C,U),C}static OrthoLHToRef(k,Q,i,Z,U,C){const B=2/k,o=2/Q,m=2/(Z-i),O=-(Z+i)/(Z-i);return h.FromValuesToRef(B,0,0,0,0,o,0,0,0,0,m,0,0,0,O,1,U),C&&U.multiplyToRef(Y,U),U._updateIdentityStatus(1===B&&1===o&&1===m&&0===O),U}static OrthoOffCenterLH(k,Q,i,Z,U,C,B){const o=new h;return h.OrthoOffCenterLHToRef(k,Q,i,Z,U,C,o,B),o}static OrthoOffCenterLHToRef(k,Q,i,Z,U,C,B,o){const m=2/(Q-k),O=2/(Z-i),J=2/(C-U),G=-(C+U)/(C-U),H=(k+Q)/(k-Q),e=(Z+i)/(i-Z);return h.FromValuesToRef(m,0,0,0,0,O,0,0,0,0,J,0,H,e,G,1,B),o&&B.multiplyToRef(Y,B),B.markAsUpdated(),B}static ObliqueOffCenterLHToRef(k,Q,i,Z,U,C,B,o,m,O,J){const G=-B*Math.cos(o),H=-B*Math.sin(o);return h.TranslationToRef(0,0,-m,c.Matrix[1]),h.FromValuesToRef(1,0,0,0,0,1,0,0,G,H,1,0,0,0,0,1,c.Matrix[0]),c.Matrix[1].multiplyToRef(c.Matrix[0],c.Matrix[0]),h.TranslationToRef(0,0,m,c.Matrix[1]),c.Matrix[0].multiplyToRef(c.Matrix[1],c.Matrix[0]),h.OrthoOffCenterLHToRef(k,Q,i,Z,U,C,O,J),c.Matrix[0].multiplyToRef(O,O),O}static OrthoOffCenterRH(k,Q,i,Z,U,C,B){const o=new h;return h.OrthoOffCenterRHToRef(k,Q,i,Z,U,C,o,B),o}static OrthoOffCenterRHToRef(k,Q,i,Z,U,C,B,o){return h.OrthoOffCenterLHToRef(k,Q,i,Z,U,C,B,o),B.ri[10]*=-1,B}static ObliqueOffCenterRHToRef(k,Q,i,Z,U,C,B,o,m,O,J){const G=B*Math.cos(o),H=B*Math.sin(o);return h.TranslationToRef(0,0,m,c.Matrix[1]),h.FromValuesToRef(1,0,0,0,0,1,0,0,G,H,1,0,0,0,0,1,c.Matrix[0]),c.Matrix[1].multiplyToRef(c.Matrix[0],c.Matrix[0]),h.TranslationToRef(0,0,-m,c.Matrix[1]),c.Matrix[0].multiplyToRef(c.Matrix[1],c.Matrix[0]),h.OrthoOffCenterRHToRef(k,Q,i,Z,U,C,O,J),c.Matrix[0].multiplyToRef(O,O),O}static PerspectiveLH(k,Q,i,Z,U){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const B=new h,o=2*i/k,m=2*i/Q,O=(Z+i)/(Z-i),J=-2*Z*i/(Z-i),G=Math.tan(C);return h.FromValuesToRef(o,0,0,0,0,m,0,G,0,0,O,1,0,0,J,0,B),U&&B.multiplyToRef(Y,B),B._updateIdentityStatus(!1),B}static PerspectiveFovLH(k,Q,i,Z,U){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,B=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const o=new h;return h.PerspectiveFovLHToRef(k,Q,i,Z,o,!0,U,C,B),o}static PerspectiveFovLHToRef(k,Q,i,Z,U){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,m=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const O=i,J=Z,G=1/Math.tan(.5*k),H=C?G/Q:G,e=C?G:G*Q,F=m&&0===O?-1:0!==J?(J+O)/(J-O):1,z=m&&0===O?2*J:0!==J?-2*J*O/(J-O):-2*O,E=Math.tan(o);return h.FromValuesToRef(H,0,0,0,0,e,0,E,0,0,F,1,0,0,z,0,U),B&&U.multiplyToRef(Y,U),U._updateIdentityStatus(!1),U}static PerspectiveFovReverseLHToRef(k,Q,i,Z,U){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const m=1/Math.tan(.5*k),O=C?m/Q:m,J=C?m:m*Q,G=Math.tan(o);return h.FromValuesToRef(O,0,0,0,0,J,0,G,0,0,-i,1,0,0,1,0,U),B&&U.multiplyToRef(Y,U),U._updateIdentityStatus(!1),U}static PerspectiveFovRH(k,Q,i,Z,U){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,B=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const o=new h;return h.PerspectiveFovRHToRef(k,Q,i,Z,o,!0,U,C,B),o}static PerspectiveFovRHToRef(k,Q,i,Z,U){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,m=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const O=i,J=Z,G=1/Math.tan(.5*k),H=C?G/Q:G,e=C?G:G*Q,F=m&&0===O?1:0!==J?-(J+O)/(J-O):-1,z=m&&0===O?2*J:0!==J?-2*J*O/(J-O):-2*O,E=Math.tan(o);return h.FromValuesToRef(H,0,0,0,0,e,0,E,0,0,F,-1,0,0,z,0,U),B&&U.multiplyToRef(Y,U),U._updateIdentityStatus(!1),U}static PerspectiveFovReverseRHToRef(k,Q,i,Z,U){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const m=1/Math.tan(.5*k),O=C?m/Q:m,J=C?m:m*Q,G=Math.tan(o);return h.FromValuesToRef(O,0,0,0,0,J,0,G,0,0,-i,-1,0,0,-1,0,U),B&&U.multiplyToRef(Y,U),U._updateIdentityStatus(!1),U}static GetFinalMatrix(k,Q,i,Z,U,C){const B=k.width,o=k.height,m=k.x,O=k.y,J=h.FromValues(B/2,0,0,0,0,-o/2,0,0,0,0,C-U,0,m+B/2,o/2+O,U,1),G=new h;return Q.multiplyToRef(i,G),G.multiplyToRef(Z,G),G.multiplyToRef(J,G)}static GetAsMatrix2x2(k){const Q=k.m,i=[Q[0],Q[1],Q[4],Q[5]];return B.d.MatrixUse64Bits?i:new Float32Array(i)}static GetAsMatrix3x3(k){const Q=k.m,i=[Q[0],Q[1],Q[2],Q[4],Q[5],Q[6],Q[8],Q[9],Q[10]];return B.d.MatrixUse64Bits?i:new Float32Array(i)}static Transpose(k){const Q=new h;return h.TransposeToRef(k,Q),Q}static TransposeToRef(k,Q){const i=k.m,Z=i[0],U=i[4],C=i[8],B=i[12],o=i[1],m=i[5],O=i[9],J=i[13],G=i[2],H=i[6],e=i[10],F=i[14],z=i[3],E=i[7],l=i[11],h=i[15],c=Q.ri;return c[0]=Z,c[1]=U,c[2]=C,c[3]=B,c[4]=o,c[5]=m,c[6]=O,c[7]=J,c[8]=G,c[9]=H,c[10]=e,c[11]=F,c[12]=z,c[13]=E,c[14]=l,c[15]=h,Q.markAsUpdated(),Q._updateIdentityStatus(k._isIdentity,k._isIdentityDirty),Q}static Reflection(k){const Q=new h;return h.ReflectionToRef(k,Q),Q}static ReflectionToRef(k,Q){k.normalize();const i=k.normal.x,Z=k.normal.y,U=k.normal.z,C=-2*i,B=-2*Z,o=-2*U;return h.FromValuesToRef(C*i+1,B*i,o*i,0,C*Z,B*Z+1,o*Z,0,C*U,B*U,o*U+1,0,C*k.d,B*k.d,o*k.d,1,Q),Q}static FromXYZAxesToRef(k,Q,i,Z){return h.FromValuesToRef(k._x,k._y,k._z,0,Q._x,Q._y,Q._z,0,i._x,i._y,i._z,0,0,0,0,1,Z),Z}static FromQuaternionToRef(k,Q){const i=k._x*k._x,Z=k._y*k._y,U=k._z*k._z,C=k._x*k._y,B=k._z*k._w,o=k._z*k._x,m=k._y*k._w,O=k._y*k._z,J=k._x*k._w;return Q.ri[0]=1-2*(Z+U),Q.ri[1]=2*(C+B),Q.ri[2]=2*(o-m),Q.ri[3]=0,Q.ri[4]=2*(C-B),Q.ri[5]=1-2*(U+i),Q.ri[6]=2*(O+J),Q.ri[7]=0,Q.ri[8]=2*(o+m),Q.ri[9]=2*(O-J),Q.ri[10]=1-2*(Z+i),Q.ri[11]=0,Q.ri[12]=0,Q.ri[13]=0,Q.ri[14]=0,Q.ri[15]=1,Q.markAsUpdated(),Q}}h._IdentityReadOnly=h.Identity(),Object.defineProperties(h.prototype,{dimension:{value:[4,4]},rank:{value:2}});class c{}c.zQ=(0,U.g)(11,z.Zero),c.Matrix=(0,U.g)(2,h.Identity),c.Quaternion=(0,U.g)(3,l.Zero);class f{}f.Vector2=(0,U.g)(3,F.Zero),f.zQ=(0,U.g)(13,z.Zero),f.Vector4=(0,U.g)(3,E.Zero),f.Quaternion=(0,U.g)(3,l.Zero),f.Matrix=(0,U.g)(8,h.Identity),(0,C.e)("BABYLON.Vector2",F),(0,C.e)("BABYLON.Vector3",z),(0,C.e)("BABYLON.Vector4",E),(0,C.e)("BABYLON.Matrix",h);const Y=h.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11307:(k,Q,i)=>{function Z(k,Q){const i=[];for(let Z=0;Z<k;++Z)i.push(Q());return i}function U(k,Q){return Z(k,Q)}i.d(Q,{c:()=>Z,g:()=>U,h:()=>B});const C=["push","splice","pop","shift","unshift"];function B(k,Q){const i=C.map((i=>function(k,Q,i){const Z=k[Q];if("function"!==typeof Z)return null;const U=function(){const Z=k.length,C=U.previous.apply(k,arguments);return i(Q,Z),C};return Z.next=U,U.previous=Z,k[Q]=U,()=>{const i=U.previous;if(!i)return;const Z=U.next;Z?(i.next=Z,Z.previous=i):(i.next=void 0,k[Q]=i),U.next=void 0,U.previous=void 0}}(k,i,Q)));return()=>{for(const k of i)null===k||void 0===k||k()}}}}]);