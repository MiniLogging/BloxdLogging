"use strict";(self.ra6kpa9z1sg=self.ra6kpa9z1sg||[]).push([[14],{12779:(p,b,M)=>{M.d(b,{d:()=>y,h:()=>mp,l:()=>h,m:()=>Q});const h=1/2.2,Q=2.2,mp=(1+Math.sqrt(5))/2,y=.001},12789:(p,b,M)=>{function h(p){return parseInt(p.toString().replace(/\W/g,""))}function Q(p,b){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(p-b)<=M}function mp(p,b,M){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return p<b-h||p>M+h}function y(p,b){return p===b?p:Math.random()*(b-p)+p}function P(p,b,M){return p+(b-p)*M}function w(p,b,M){let h=g(b-p,360);return h>180&&(h-=360),p+h*S(M)}function t(p,b,M){let h=0;return h=p!=b?S((M-p)/(b-p)):0,h}function z(p,b,M,h,Q){const mp=Q*Q,y=Q*mp;return p*(2*y-3*mp+1)+M*(-2*y+3*mp)+b*(y-2*mp+Q)+h*(y-mp)}function x(p,b,M,h,Q){const mp=Q*Q;return 6*(mp-Q)*p+(3*mp-4*Q+1)*b+6*(-mp+Q)*M+(3*mp-2*Q)*h}function S(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(M,Math.max(b,p))}function X(p){return p-=2*Math.PI*Math.floor((p+Math.PI)/(2*Math.PI))}function c(p){const b=p.toString(16);return p<=15?("0"+b).toUpperCase():b.toUpperCase()}function J(p){if(Math.log2)return Math.floor(Math.log2(p));if(p<0)return NaN;if(0===p)return-1/0;let b=0;if(p<1){for(;p<1;)b++,p*=2;b=-b}else if(p>1)for(;p>1;)b++,p=Math.floor(p/2);return b}function g(p,b){return p-Math.floor(p/b)*b}function f(p,b,M){return(p-b)/(M-b)}function Y(p,b,M){return p*(M-b)+b}function a(p,b){let M=g(b-p,360);return M>180&&(M-=360),M}function o(p,b){const M=g(p,2*b);return b-Math.abs(M-b)}function l(p,b,M){let h=S(M);return h=-2*h*h*h+3*h*h,b*h+p*(1-h)}function L(p,b,M){let h=0;return h=Math.abs(b-p)<=M?b:p+Math.sign(b-p)*M,h}function u(p,b,M){const h=a(p,b);let Q=0;return Q=-M<h&&h<M?b:L(p,b=p+h,M),Q}function e(p,b,M){return(p-b)/(M-b)}function d(p,b,M){return(M-b)*p+b}function I(p,b){const M=p%b;return 0===M?b:I(b,M)}M.r(b),M.d(b,{Clamp:()=>S,DeltaAngle:()=>a,Denormalize:()=>Y,ExtractAsInt:()=>h,Hermite:()=>z,Hermite1stDerivative:()=>x,HighestCommonFactor:()=>I,ILog2:()=>J,InverseLerp:()=>t,Lerp:()=>P,LerpAngle:()=>w,MoveTowards:()=>L,MoveTowardsAngle:()=>u,Normalize:()=>f,NormalizeRadians:()=>X,OutsideRange:()=>mp,PercentToRange:()=>d,PingPong:()=>o,RandomRange:()=>y,RangeToPercent:()=>e,Repeat:()=>g,SmoothStep:()=>l,ToHex:()=>c,WithinEpsilon:()=>Q})},12777:(p,b,M)=>{M.r(b),M.d(b,{Matrix:()=>Y,Quaternion:()=>f,TmpVectors:()=>o,Vector2:()=>c,QM:()=>J,Vector4:()=>g});var h=M(12779),Q=M(12785),mp=M(12730),y=M(12705),P=M(12652),w=M(12789);class t{}function z(p,b,M){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const Q=p.ub(),mp=b.ub(),y=Q[0],P=Q[1],w=Q[2],t=Q[3],z=Q[4],x=Q[5],S=Q[6],X=Q[7],c=Q[8],J=Q[9],g=Q[10],f=Q[11],Y=Q[12],a=Q[13],o=Q[14],l=Q[15],L=mp[0],u=mp[1],e=mp[2],d=mp[3],I=mp[4],G=mp[5],v=mp[6],Z=mp[7],U=mp[8],q=mp[9],B=mp[10],s=mp[11],i=mp[12],T=mp[13],W=mp[14],H=mp[15];M[h]=y*L+P*I+w*U+t*i,M[h+1]=y*u+P*G+w*q+t*T,M[h+2]=y*e+P*v+w*B+t*W,M[h+3]=y*d+P*Z+w*s+t*H,M[h+4]=z*L+x*I+S*U+X*i,M[h+5]=z*u+x*G+S*q+X*T,M[h+6]=z*e+x*v+S*B+X*W,M[h+7]=z*d+x*Z+S*s+X*H,M[h+8]=c*L+J*I+g*U+f*i,M[h+9]=c*u+J*G+g*q+f*T,M[h+10]=c*e+J*v+g*B+f*W,M[h+11]=c*d+J*Z+g*s+f*H,M[h+12]=Y*L+a*I+o*U+l*i,M[h+13]=Y*u+a*G+o*q+l*T,M[h+14]=Y*e+a*v+o*B+l*W,M[h+15]=Y*d+a*Z+o*s+l*H}function x(p,b){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const h=p.ub();b[M]=h[0],b[M+1]=h[1],b[M+2]=h[2],b[M+3]=h[3],b[M+4]=h[4],b[M+5]=h[5],b[M+6]=h[6],b[M+7]=h[7],b[M+8]=h[8],b[M+9]=h[9],b[M+10]=h[10],b[M+11]=h[11],b[M+12]=h[12],b[M+13]=h[13],b[M+14]=h[14],b[M+15]=h[15]}function S(p,b){const M=p.ub(),h=M[0],Q=M[1],mp=M[2],y=M[3],P=M[4],w=M[5],t=M[6],z=M[7],x=M[8],S=M[9],X=M[10],c=M[11],J=M[12],g=M[13],f=M[14],Y=M[15],a=X*Y-f*c,o=S*Y-g*c,l=S*f-g*X,L=x*Y-J*c,u=x*f-X*J,e=x*g-J*S,d=+(w*a-t*o+z*l),I=-(P*a-t*L+z*u),G=+(P*o-w*L+z*e),v=-(P*l-w*u+t*e),Z=h*d+Q*I+mp*G+y*v;if(0===Z)return!1;const U=1/Z,q=t*Y-f*z,B=w*Y-g*z,s=w*f-g*t,i=P*Y-J*z,T=P*f-J*t,W=P*g-J*w,H=t*c-X*z,E=w*c-S*z,j=w*X-S*t,V=P*c-x*z,D=P*X-x*t,N=P*S-x*w,O=-(Q*a-mp*o+y*l),R=+(h*a-mp*L+y*u),K=-(h*o-Q*L+y*e),r=+(h*l-Q*u+mp*e),k=+(Q*q-mp*B+y*s),A=-(h*q-mp*i+y*T),n=+(h*B-Q*i+y*W),C=-(h*s-Q*T+mp*W),F=-(Q*H-mp*E+y*j),pp=+(h*H-mp*V+y*D),bp=-(h*E-Q*V+y*N),Mp=+(h*j-Q*D+mp*N);return b[0]=d*U,b[1]=O*U,b[2]=k*U,b[3]=F*U,b[4]=I*U,b[5]=R*U,b[6]=A*U,b[7]=pp*U,b[8]=G*U,b[9]=K*U,b[10]=n*U,b[11]=bp*U,b[12]=v*U,b[13]=r*U,b[14]=C*U,b[15]=Mp*U,!0}t._UpdateFlagSeed=0;const X=p=>parseInt(p.toString().replace(/\W/g,""));class c{constructor(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=p,this.y=b}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let p=X(this.x);return p=397*p^X(this.y),p}toArray(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p[b]=this.x,p[b+1]=this.y,this}Jh(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c.FromArrayToRef(p,b,this),this}ub(){return[this.x,this.y]}mp(p){return this.x=p.x,this.y=p.y,this}sb(p,b){return this.x=p,this.y=b,this}set(p,b){return this.sb(p,b)}Tb(p){return this.sb(p,p)}add(p){return new c(this.x+p.x,this.y+p.y)}addToRef(p,b){return b.x=this.x+p.x,b.y=this.y+p.y,b}addInPlace(p){return this.x+=p.x,this.y+=p.y,this}addInPlaceFromFloats(p,b){return this.x+=p,this.y+=b,this}addVector3(p){return new c(this.x+p.x,this.y+p.y)}mh(p){return new c(this.x-p.x,this.y-p.y)}subtractToRef(p,b){return b.x=this.x-p.x,b.y=this.y-p.y,b}eS(p){return this.x-=p.x,this.y-=p.y,this}multiplyInPlace(p){return this.x*=p.x,this.y*=p.y,this}multiply(p){return new c(this.x*p.x,this.y*p.y)}multiplyToRef(p,b){return b.x=this.x*p.x,b.y=this.y*p.y,b}multiplyByFloats(p,b){return new c(this.x*p,this.y*b)}divide(p){return new c(this.x/p.x,this.y/p.y)}divideToRef(p,b){return b.x=this.x/p.x,b.y=this.y/p.y,b}divideInPlace(p){return this.x=this.x/p.x,this.y=this.y/p.y,this}minimizeInPlace(p){return this.minimizeInPlaceFromFloats(p.x,p.y)}maximizeInPlace(p){return this.maximizeInPlaceFromFloats(p.x,p.y)}minimizeInPlaceFromFloats(p,b){return this.x=Math.min(p,this.x),this.y=Math.min(b,this.y),this}maximizeInPlaceFromFloats(p,b){return this.x=Math.max(p,this.x),this.y=Math.max(b,this.y),this}subtractFromFloats(p,b){return new c(this.x-p,this.y-b)}subtractFromFloatsToRef(p,b,M){return M.x=this.x-p,M.y=this.y-b,M}negate(){return new c(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(p){return p.x=-this.x,p.y=-this.y,p}scaleInPlace(p){return this.x*=p,this.y*=p,this}scale(p){return new c(this.x*p,this.y*p)}scaleToRef(p,b){return b.x=this.x*p,b.y=this.y*p,b}scaleAndAddToRef(p,b){return b.x+=this.x*p,b.y+=this.y*p,b}equals(p){return p&&this.x===p.x&&this.y===p.y}equalsWithEpsilon(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.d;return p&&(0,w.WithinEpsilon)(this.x,p.x,b)&&(0,w.WithinEpsilon)(this.y,p.y,b)}equalsToFloats(p,b){return this.x===p&&this.y===b}floor(){return new c(Math.floor(this.x),Math.floor(this.y))}floorToRef(p){return p.x=Math.floor(this.x),p.y=Math.floor(this.y),p}fract(){return new c(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(p){return p.x=this.x-Math.floor(this.x),p.y=this.y-Math.floor(this.y),p}rotate(p){return this.rotateToRef(p,new c)}rotateToRef(p,b){const M=Math.cos(p),h=Math.sin(p);return b.x=M*this.x-h*this.y,b.y=h*this.x+M*this.y,b}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(p){return 0===p||1===p?this:this.scaleInPlace(1/p)}normalizeToNew(){const p=new c;return this.normalizeToRef(p),p}normalizeToRef(p){const b=this.length();return 0===b&&(p.x=this.x,p.y=this.y),this.scaleToRef(1/b,p)}clone(){return new c(this.x,this.y)}dot(p){return this.x*p.x+this.y*p.y}static Zero(){return new c(0,0)}static One(){return new c(1,1)}static Random(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new c((0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b))}static RandomToRef(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).sb((0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b))}static get ZeroReadOnly(){return c._ZeroReadOnly}static tM(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new c(p[b],p[b+1])}static FromArrayToRef(p,b,M){return M.x=p[b],M.y=p[b+1],M}static FromFloatsToRef(p,b,M){return M.sb(p,b),M}static CatmullRom(p,b,M,h,Q){const mp=Q*Q,y=Q*mp,P=.5*(2*b.x+(-p.x+M.x)*Q+(2*p.x-5*b.x+4*M.x-h.x)*mp+(-p.x+3*b.x-3*M.x+h.x)*y),w=.5*(2*b.y+(-p.y+M.y)*Q+(2*p.y-5*b.y+4*M.y-h.y)*mp+(-p.y+3*b.y-3*M.y+h.y)*y);return new c(P,w)}static ClampToRef(p,b,M,h){return h.x=(0,w.Clamp)(p.x,b.x,M.x),h.y=(0,w.Clamp)(p.y,b.y,M.y),h}static Clamp(p,b,M){const h=(0,w.Clamp)(p.x,b.x,M.x),Q=(0,w.Clamp)(p.y,b.y,M.y);return new c(h,Q)}static Hermite(p,b,M,h,Q){const mp=Q*Q,y=Q*mp,P=2*y-3*mp+1,w=-2*y+3*mp,t=y-2*mp+Q,z=y-mp,x=p.x*P+M.x*w+b.x*t+h.x*z,S=p.y*P+M.y*w+b.y*t+h.y*z;return new c(x,S)}static Hermite1stDerivative(p,b,M,h,Q){return this.Hermite1stDerivativeToRef(p,b,M,h,Q,new c)}static Hermite1stDerivativeToRef(p,b,M,h,Q,mp){const y=Q*Q;return mp.x=6*(y-Q)*p.x+(3*y-4*Q+1)*b.x+6*(-y+Q)*M.x+(3*y-2*Q)*h.x,mp.y=6*(y-Q)*p.y+(3*y-4*Q+1)*b.y+6*(-y+Q)*M.y+(3*y-2*Q)*h.y,mp}static Lerp(p,b,M){return c.LerpToRef(p,b,M,new c)}static LerpToRef(p,b,M,h){return h.x=p.x+(b.x-p.x)*M,h.y=p.y+(b.y-p.y)*M,h}static Dot(p,b){return p.x*b.x+p.y*b.y}static Normalize(p){return c.NormalizeToRef(p,new c)}static NormalizeToRef(p,b){return p.normalizeToRef(b),b}static Minimize(p,b){const M=p.x<b.x?p.x:b.x,h=p.y<b.y?p.y:b.y;return new c(M,h)}static Maximize(p,b){const M=p.x>b.x?p.x:b.x,h=p.y>b.y?p.y:b.y;return new c(M,h)}static Transform(p,b){return c.TransformToRef(p,b,new c)}static TransformToRef(p,b,M){const h=b.m,Q=p.x*h[0]+p.y*h[4]+h[12],mp=p.x*h[1]+p.y*h[5]+h[13];return M.x=Q,M.y=mp,M}static PointInTriangle(p,b,M,h){const Q=.5*(-M.y*h.x+b.y*(-M.x+h.x)+b.x*(M.y-h.y)+M.x*h.y),mp=Q<0?-1:1,y=(b.y*h.x-b.x*h.y+(h.y-b.y)*p.x+(b.x-h.x)*p.y)*mp,P=(b.x*M.y-b.y*M.x+(b.y-M.y)*p.x+(M.x-b.x)*p.y)*mp;return y>0&&P>0&&y+P<2*Q*mp}static Distance(p,b){return Math.sqrt(c.DistanceSquared(p,b))}static DistanceSquared(p,b){const M=p.x-b.x,h=p.y-b.y;return M*M+h*h}static Center(p,b){return c.CenterToRef(p,b,new c)}static CenterToRef(p,b,M){return M.sb((p.x+b.x)/2,(p.y+b.y)/2)}static DistanceOfPointFromSegment(p,b,M){const h=c.DistanceSquared(b,M);if(0===h)return c.Distance(p,b);const Q=M.mh(b),mp=Math.max(0,Math.min(1,c.Dot(p.mh(b),Q)/h)),y=b.add(Q.multiplyByFloats(mp,mp));return c.Distance(p,y)}}c._V8PerformanceHack=new c(.5,.5),c._ZeroReadOnly=c.Zero(),Object.defineProperties(c.prototype,{dimension:{value:[2]},rank:{value:1}});class J{get x(){return this._x}set x(p){this._x=p,this._isDirty=!0}get y(){return this._y}set y(p){this._y=p,this._isDirty=!0}get z(){return this._z}set z(p){this._z=p,this._isDirty=!0}constructor(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=p,this._y=b,this._z=M}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"QM"}getHashCode(){let p=X(this._x);return p=397*p^X(this._y),p=397*p^X(this._z),p}ub(){return[this._x,this._y,this._z]}toArray(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p[b]=this._x,p[b+1]=this._y,p[b+2]=this._z,this}Jh(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(p,b,this),this}toQuaternion(){return f.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(p){return this._x+=p._x,this._y+=p._y,this._z+=p._z,this._isDirty=!0,this}addInPlaceFromFloats(p,b,M){return this._x+=p,this._y+=b,this._z+=M,this._isDirty=!0,this}add(p){return new J(this._x+p._x,this._y+p._y,this._z+p._z)}addToRef(p,b){return b._x=this._x+p._x,b._y=this._y+p._y,b._z=this._z+p._z,b._isDirty=!0,b}eS(p){return this._x-=p._x,this._y-=p._y,this._z-=p._z,this._isDirty=!0,this}mh(p){return new J(this._x-p._x,this._y-p._y,this._z-p._z)}subtractToRef(p,b){return this.subtractFromFloatsToRef(p._x,p._y,p._z,b)}subtractFromFloats(p,b,M){return new J(this._x-p,this._y-b,this._z-M)}subtractFromFloatsToRef(p,b,M,h){return h._x=this._x-p,h._y=this._y-b,h._z=this._z-M,h._isDirty=!0,h}negate(){return new J(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(p){return p._x=-1*this._x,p._y=-1*this._y,p._z=-1*this._z,p._isDirty=!0,p}scaleInPlace(p){return this._x*=p,this._y*=p,this._z*=p,this._isDirty=!0,this}scale(p){return new J(this._x*p,this._y*p,this._z*p)}scaleToRef(p,b){return b._x=this._x*p,b._y=this._y*p,b._z=this._z*p,b._isDirty=!0,b}getNormalToRef(p){const b=this.length();let M=Math.acos(this._y/b);const h=Math.atan2(this._z,this._x);M>Math.PI/2?M-=Math.PI/2:M+=Math.PI/2;const Q=b*Math.sin(M)*Math.cos(h),mp=b*Math.cos(M),y=b*Math.sin(M)*Math.sin(h);return p.set(Q,mp,y),p}applyRotationQuaternionToRef(p,b){const M=this._x,h=this._y,Q=this._z,mp=p._x,y=p._y,P=p._z,w=p._w,t=2*(y*Q-P*h),z=2*(P*M-mp*Q),x=2*(mp*h-y*M);return b._x=M+w*t+y*x-P*z,b._y=h+w*z+P*t-mp*x,b._z=Q+w*x+mp*z-y*t,b._isDirty=!0,b}applyRotationQuaternionInPlace(p){return this.applyRotationQuaternionToRef(p,this)}applyRotationQuaternion(p){return this.applyRotationQuaternionToRef(p,new J)}scaleAndAddToRef(p,b){return b._x+=this._x*p,b._y+=this._y*p,b._z+=this._z*p,b._isDirty=!0,b}projectOnPlane(p,b){return this.projectOnPlaneToRef(p,b,new J)}projectOnPlaneToRef(p,b,M){const h=p.normal,Q=p.d,mp=a.QM[0];this.subtractToRef(b,mp),mp.normalize();const y=J.Dot(mp,h);if(Math.abs(y)<1e-10)M.Tb(1/0);else{const p=-(J.Dot(b,h)+Q)/y,P=mp.scaleInPlace(p);b.addToRef(P,M)}return M}equals(p){return p&&this._x===p._x&&this._y===p._y&&this._z===p._z}equalsWithEpsilon(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.d;return p&&(0,w.WithinEpsilon)(this._x,p._x,b)&&(0,w.WithinEpsilon)(this._y,p._y,b)&&(0,w.WithinEpsilon)(this._z,p._z,b)}equalsToFloats(p,b,M){return this._x===p&&this._y===b&&this._z===M}multiplyInPlace(p){return this._x*=p._x,this._y*=p._y,this._z*=p._z,this._isDirty=!0,this}multiply(p){return this.multiplyByFloats(p._x,p._y,p._z)}multiplyToRef(p,b){return b._x=this._x*p._x,b._y=this._y*p._y,b._z=this._z*p._z,b._isDirty=!0,b}multiplyByFloats(p,b,M){return new J(this._x*p,this._y*b,this._z*M)}divide(p){return new J(this._x/p._x,this._y/p._y,this._z/p._z)}divideToRef(p,b){return b._x=this._x/p._x,b._y=this._y/p._y,b._z=this._z/p._z,b._isDirty=!0,b}divideInPlace(p){return this._x=this._x/p._x,this._y=this._y/p._y,this._z=this._z/p._z,this._isDirty=!0,this}minimizeInPlace(p){return this.minimizeInPlaceFromFloats(p._x,p._y,p._z)}maximizeInPlace(p){return this.maximizeInPlaceFromFloats(p._x,p._y,p._z)}minimizeInPlaceFromFloats(p,b,M){return p<this._x&&(this.x=p),b<this._y&&(this.y=b),M<this._z&&(this.z=M),this}maximizeInPlaceFromFloats(p,b,M){return p>this._x&&(this.x=p),b>this._y&&(this.y=b),M>this._z&&(this.z=M),this}isNonUniformWithinEpsilon(p){const b=Math.abs(this._x),M=Math.abs(this._y);if(!(0,w.WithinEpsilon)(b,M,p))return!0;const h=Math.abs(this._z);return!(0,w.WithinEpsilon)(b,h,p)||!(0,w.WithinEpsilon)(M,h,p)}get isNonUniform(){const p=Math.abs(this._x);if(p!==Math.abs(this._y))return!0;return p!==Math.abs(this._z)}floorToRef(p){return p._x=Math.floor(this._x),p._y=Math.floor(this._y),p._z=Math.floor(this._z),p._isDirty=!0,p}floor(){return new J(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(p){return p._x=this._x-Math.floor(this._x),p._y=this._y-Math.floor(this._y),p._z=this._z-Math.floor(this._z),p._isDirty=!0,p}fract(){return new J(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(p){if("xyz"===(p=p.toLowerCase()))return this;const b=a.QM[0].mp(this);return this.x=b[p[0]],this.y=b[p[1]],this.z=b[p[2]],this}rotateByQuaternionToRef(p,b){return p.toRotationMatrix(a.Matrix[0]),J.TransformCoordinatesToRef(this,a.Matrix[0],b),b}rotateByQuaternionAroundPointToRef(p,b,M){return this.subtractToRef(b,a.QM[0]),a.QM[0].rotateByQuaternionToRef(p,a.QM[0]),b.addToRef(a.QM[0],M),M}cross(p){return J.CrossToRef(this,p,new J)}normalizeFromLength(p){return 0===p||1===p?this:this.scaleInPlace(1/p)}normalizeToNew(){return this.normalizeToRef(new J)}normalizeToRef(p){const b=this.length();return 0===b||1===b?(p._x=this._x,p._y=this._y,p._z=this._z,p._isDirty=!0,p):this.scaleToRef(1/b,p)}clone(){return new J(this._x,this._y,this._z)}mp(p){return this.sb(p._x,p._y,p._z)}sb(p,b,M){return this._x=p,this._y=b,this._z=M,this._isDirty=!0,this}set(p,b,M){return this.sb(p,b,M)}Tb(p){return this._x=this._y=this._z=p,this._isDirty=!0,this}static GetClipFactor(p,b,M,h){const Q=J.Dot(p,M);return(Q-h)/(Q-J.Dot(b,M))}static GetAngleBetweenVectors(p,b,M){const h=p.normalizeToRef(a.QM[1]),Q=b.normalizeToRef(a.QM[2]);let mp=J.Dot(h,Q);mp=(0,w.Clamp)(mp,-1,1);const y=Math.acos(mp),P=a.QM[3];return J.CrossToRef(h,Q,P),J.Dot(P,M)>0?isNaN(y)?0:y:isNaN(y)?-Math.PI:-Math.acos(mp)}static GetAngleBetweenVectorsOnPlane(p,b,M){a.QM[0].mp(p);const h=a.QM[0];a.QM[1].mp(b);const Q=a.QM[1];a.QM[2].mp(M);const mp=a.QM[2],y=a.QM[3],P=a.QM[4];h.normalize(),Q.normalize(),mp.normalize(),J.CrossToRef(mp,h,y),J.CrossToRef(y,mp,P);const t=Math.atan2(J.Dot(Q,y),J.Dot(Q,P));return(0,w.NormalizeRadians)(t)}static PitchYawRollToMoveBetweenPointsToRef(p,b,M){const h=o.QM[0];return b.subtractToRef(p,h),M._y=Math.atan2(h.x,h.z)||0,M._x=Math.atan2(Math.sqrt(h.x**2+h.z**2),h.y)||0,M._z=0,M._isDirty=!0,M}static PitchYawRollToMoveBetweenPoints(p,b){const M=J.Zero();return J.PitchYawRollToMoveBetweenPointsToRef(p,b,M)}static SlerpToRef(p,b,M,Q){M=(0,w.Clamp)(M,0,1);const mp=a.QM[0],y=a.QM[1];mp.mp(p);const P=mp.length();mp.normalizeFromLength(P),y.mp(b);const t=y.length();y.normalizeFromLength(t);const z=J.Dot(mp,y);let x,S;if(z<1-h.d){const p=Math.acos(z),b=1/Math.sin(p);x=Math.sin((1-M)*p)*b,S=Math.sin(M*p)*b}else x=1-M,S=M;return mp.scaleInPlace(x),y.scaleInPlace(S),Q.mp(mp).addInPlace(y),Q.scaleInPlace((0,w.Lerp)(P,t,M)),Q}static SmoothToRef(p,b,M,h,Q){return J.SlerpToRef(p,b,0===h?1:M/h,Q),Q}static tM(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new J(p[b],p[b+1],p[b+2])}static FromFloatArray(p,b){return J.tM(p,b)}static FromArrayToRef(p,b,M){return M._x=p[b],M._y=p[b+1],M._z=p[b+2],M._isDirty=!0,M}static FromFloatArrayToRef(p,b,M){return J.FromArrayToRef(p,b,M)}static FromFloatsToRef(p,b,M,h){return h.sb(p,b,M),h}static Zero(){return new J(0,0,0)}static One(){return new J(1,1,1)}static Up(){return new J(0,1,0)}static get UpReadOnly(){return J._UpReadOnly}static get DownReadOnly(){return J._DownReadOnly}static get RightReadOnly(){return J._RightReadOnly}static get LeftReadOnly(){return J._LeftReadOnly}static get LeftHandedForwardReadOnly(){return J._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return J._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return J._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return J._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return J._ZeroReadOnly}static get OneReadOnly(){return J._OneReadOnly}static Down(){return new J(0,-1,0)}static Forward(){return new J(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new J(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new J(1,0,0)}static Left(){return new J(-1,0,0)}static Random(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new J((0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b))}static RandomToRef(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).sb((0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b))}static TransformCoordinates(p,b){const M=J.Zero();return J.TransformCoordinatesToRef(p,b,M),M}static TransformCoordinatesToRef(p,b,M){return J.TransformCoordinatesFromFloatsToRef(p._x,p._y,p._z,b,M),M}static TransformCoordinatesFromFloatsToRef(p,b,M,h,Q){const mp=h.m,y=p*mp[0]+b*mp[4]+M*mp[8]+mp[12],P=p*mp[1]+b*mp[5]+M*mp[9]+mp[13],w=p*mp[2]+b*mp[6]+M*mp[10]+mp[14],t=1/(p*mp[3]+b*mp[7]+M*mp[11]+mp[15]);return Q._x=y*t,Q._y=P*t,Q._z=w*t,Q._isDirty=!0,Q}static TransformNormal(p,b){const M=J.Zero();return J.TransformNormalToRef(p,b,M),M}static TransformNormalToRef(p,b,M){return this.TransformNormalFromFloatsToRef(p._x,p._y,p._z,b,M),M}static TransformNormalFromFloatsToRef(p,b,M,h,Q){const mp=h.m;return Q._x=p*mp[0]+b*mp[4]+M*mp[8],Q._y=p*mp[1]+b*mp[5]+M*mp[9],Q._z=p*mp[2]+b*mp[6]+M*mp[10],Q._isDirty=!0,Q}static CatmullRom(p,b,M,h,Q){const mp=Q*Q,y=Q*mp,P=.5*(2*b._x+(-p._x+M._x)*Q+(2*p._x-5*b._x+4*M._x-h._x)*mp+(-p._x+3*b._x-3*M._x+h._x)*y),w=.5*(2*b._y+(-p._y+M._y)*Q+(2*p._y-5*b._y+4*M._y-h._y)*mp+(-p._y+3*b._y-3*M._y+h._y)*y),t=.5*(2*b._z+(-p._z+M._z)*Q+(2*p._z-5*b._z+4*M._z-h._z)*mp+(-p._z+3*b._z-3*M._z+h._z)*y);return new J(P,w,t)}static Clamp(p,b,M){const h=new J;return J.ClampToRef(p,b,M,h),h}static ClampToRef(p,b,M,h){let Q=p._x;Q=Q>M._x?M._x:Q,Q=Q<b._x?b._x:Q;let mp=p._y;mp=mp>M._y?M._y:mp,mp=mp<b._y?b._y:mp;let y=p._z;return y=y>M._z?M._z:y,y=y<b._z?b._z:y,h.sb(Q,mp,y),h}static CheckExtends(p,b,M){b.minimizeInPlace(p),M.maximizeInPlace(p)}static Hermite(p,b,M,h,Q){const mp=Q*Q,y=Q*mp,P=2*y-3*mp+1,w=-2*y+3*mp,t=y-2*mp+Q,z=y-mp,x=p._x*P+M._x*w+b._x*t+h._x*z,S=p._y*P+M._y*w+b._y*t+h._y*z,X=p._z*P+M._z*w+b._z*t+h._z*z;return new J(x,S,X)}static Hermite1stDerivative(p,b,M,h,Q){const mp=new J;return this.Hermite1stDerivativeToRef(p,b,M,h,Q,mp),mp}static Hermite1stDerivativeToRef(p,b,M,h,Q,mp){const y=Q*Q;return mp._x=6*(y-Q)*p._x+(3*y-4*Q+1)*b._x+6*(-y+Q)*M._x+(3*y-2*Q)*h._x,mp._y=6*(y-Q)*p._y+(3*y-4*Q+1)*b._y+6*(-y+Q)*M._y+(3*y-2*Q)*h._y,mp._z=6*(y-Q)*p._z+(3*y-4*Q+1)*b._z+6*(-y+Q)*M._z+(3*y-2*Q)*h._z,mp._isDirty=!0,mp}static Lerp(p,b,M){const h=new J(0,0,0);return J.LerpToRef(p,b,M,h),h}static LerpToRef(p,b,M,h){return h._x=p._x+(b._x-p._x)*M,h._y=p._y+(b._y-p._y)*M,h._z=p._z+(b._z-p._z)*M,h._isDirty=!0,h}static Dot(p,b){return p._x*b._x+p._y*b._y+p._z*b._z}dot(p){return this._x*p._x+this._y*p._y+this._z*p._z}static Cross(p,b){const M=new J;return J.CrossToRef(p,b,M),M}static CrossToRef(p,b,M){const h=p._y*b._z-p._z*b._y,Q=p._z*b._x-p._x*b._z,mp=p._x*b._y-p._y*b._x;return M.sb(h,Q,mp),M}static Normalize(p){const b=J.Zero();return J.NormalizeToRef(p,b),b}static NormalizeToRef(p,b){return p.normalizeToRef(b),b}static Project(p,b,M,h){const Q=new J;return J.ProjectToRef(p,b,M,h,Q),Q}static ProjectToRef(p,b,M,h,Q){var mp;const y=h.width,w=h.height,t=h.x,z=h.y,x=a.Matrix[1],S=null===(mp=P.c.LastCreatedEngine)||void 0===mp?void 0:mp.isNDCHalfZRange,X=S?1:.5,c=S?0:.5;Y.FromValuesToRef(y/2,0,0,0,0,-w/2,0,0,0,0,X,0,t+y/2,w/2+z,c,1,x);const g=a.Matrix[0];return b.multiplyToRef(M,g),g.multiplyToRef(x,g),J.TransformCoordinatesToRef(p,g,Q),Q}static Reflect(p,b){return this.ReflectToRef(p,b,new J)}static ReflectToRef(p,b,M){const h=o.QM[0];return h.mp(b).scaleInPlace(2*J.Dot(p,b)),M.mp(p).eS(h)}static _UnprojectFromInvertedMatrixToRef(p,b,M){J.TransformCoordinatesToRef(p,b,M);const h=b.m,Q=p._x*h[3]+p._y*h[7]+p._z*h[11]+h[15];return(0,w.WithinEpsilon)(Q,1)&&M.scaleInPlace(1/Q),M}static UnprojectFromTransform(p,b,M,h,Q){return this.Unproject(p,b,M,h,Q,Y.IdentityReadOnly)}static Unproject(p,b,M,h,Q,mp){const y=new J;return J.UnprojectToRef(p,b,M,h,Q,mp,y),y}static UnprojectToRef(p,b,M,h,Q,mp,y){return J.UnprojectFloatsToRef(p._x,p._y,p._z,b,M,h,Q,mp,y),y}static UnprojectFloatsToRef(p,b,M,h,Q,mp,y,w,t){var z;const x=a.Matrix[0];mp.multiplyToRef(y,x),x.multiplyToRef(w,x),x.invert();const S=a.QM[0];return S.x=p/h*2-1,S.y=-(b/Q*2-1),null!==(z=P.c.LastCreatedEngine)&&void 0!==z&&z.isNDCHalfZRange?S.z=M:S.z=2*M-1,J._UnprojectFromInvertedMatrixToRef(S,x,t),t}static Minimize(p,b){const M=new J;return M.mp(p),M.minimizeInPlace(b),M}static Maximize(p,b){const M=new J;return M.mp(p),M.maximizeInPlace(b),M}static Distance(p,b){return Math.sqrt(J.DistanceSquared(p,b))}static DistanceSquared(p,b){const M=p._x-b._x,h=p._y-b._y,Q=p._z-b._z;return M*M+h*h+Q*Q}static ProjectOnTriangleToRef(p,b,M,Q,mp){const y=a.QM[0],P=a.QM[1],t=a.QM[2],z=a.QM[3],x=a.QM[4];M.subtractToRef(b,y),Q.subtractToRef(b,P),Q.subtractToRef(M,t);const S=y.length(),X=P.length(),c=t.length();if(S<h.d||X<h.d||c<h.d)return mp.mp(b),J.Distance(p,b);p.subtractToRef(b,x),J.CrossToRef(y,P,z);const g=z.length();if(g<h.d)return mp.mp(b),J.Distance(p,b);z.normalizeFromLength(g);let f=x.length();if(f<h.d)return mp.mp(b),0;x.normalizeFromLength(f);const Y=J.Dot(z,x),o=a.QM[5],l=a.QM[6];o.mp(z).scaleInPlace(-f*Y),l.mp(p).addInPlace(o);const L=a.QM[4],u=a.QM[5],e=a.QM[7],d=a.QM[8];L.mp(y).scaleInPlace(1/S),d.mp(P).scaleInPlace(1/X),L.addInPlace(d).scaleInPlace(-1),u.mp(y).scaleInPlace(-1/S),d.mp(t).scaleInPlace(1/c),u.addInPlace(d).scaleInPlace(-1),e.mp(t).scaleInPlace(-1/c),d.mp(P).scaleInPlace(-1/X),e.addInPlace(d).scaleInPlace(-1);const I=a.QM[9];let G;I.mp(l).eS(b),J.CrossToRef(L,I,d),G=J.Dot(d,z);const v=G;I.mp(l).eS(M),J.CrossToRef(u,I,d),G=J.Dot(d,z);const Z=G;I.mp(l).eS(Q),J.CrossToRef(e,I,d),G=J.Dot(d,z);const U=G,q=a.QM[10];let B,s;v>0&&Z<0?(q.mp(y),B=b,s=M):Z>0&&U<0?(q.mp(t),B=M,s=Q):(q.mp(P).scaleInPlace(-1),B=Q,s=b);const i=a.QM[9],T=a.QM[4];B.subtractToRef(l,d),s.subtractToRef(l,i),J.CrossToRef(d,i,T);if(!(J.Dot(T,z)<0))return mp.mp(l),Math.abs(f*Y);const W=a.QM[5];J.CrossToRef(q,T,W),W.normalize();const H=a.QM[9];H.mp(B).eS(l);const E=H.length();if(E<h.d)return mp.mp(B),J.Distance(p,B);H.normalizeFromLength(E);const j=J.Dot(W,H),V=a.QM[7];V.mp(l).addInPlace(W.scaleInPlace(E*j)),d.mp(V).eS(B),f=q.length(),q.normalizeFromLength(f);let D=J.Dot(d,q)/Math.max(f,h.d);return D=(0,w.Clamp)(D,0,1),V.mp(B).addInPlace(q.scaleInPlace(D*f)),mp.mp(V),J.Distance(p,V)}static Center(p,b){return J.CenterToRef(p,b,J.Zero())}static CenterToRef(p,b,M){return M.sb((p._x+b._x)/2,(p._y+b._y)/2,(p._z+b._z)/2)}static RotationFromAxis(p,b,M){const h=new J;return J.RotationFromAxisToRef(p,b,M,h),h}static RotationFromAxisToRef(p,b,M,h){const Q=a.Quaternion[0];return f.RotationQuaternionFromAxisToRef(p,b,M,Q),Q.toEulerAnglesToRef(h),h}}J._V8PerformanceHack=new J(.5,.5,.5),J._UpReadOnly=J.Up(),J._DownReadOnly=J.Down(),J._LeftHandedForwardReadOnly=J.Forward(!1),J._RightHandedForwardReadOnly=J.Forward(!0),J._LeftHandedBackwardReadOnly=J.Backward(!1),J._RightHandedBackwardReadOnly=J.Backward(!0),J._RightReadOnly=J.Right(),J._LeftReadOnly=J.Left(),J._ZeroReadOnly=J.Zero(),J._OneReadOnly=J.One(),Object.defineProperties(J.prototype,{dimension:{value:[3]},rank:{value:1}});class g{get x(){return this._x}set x(p){this._x=p,this._isDirty=!0}get y(){return this._y}set y(p){this._y=p,this._isDirty=!0}get z(){return this._z}set z(p){this._z=p,this._isDirty=!0}get w(){return this._w}set w(p){this._w=p,this._isDirty=!0}constructor(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=p,this._y=b,this._z=M,this._w=h}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let p=X(this._x);return p=397*p^X(this._y),p=397*p^X(this._z),p=397*p^X(this._w),p}ub(){return[this._x,this._y,this._z,this._w]}toArray(p,b){return void 0===b&&(b=0),p[b]=this._x,p[b+1]=this._y,p[b+2]=this._z,p[b+3]=this._w,this}Jh(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g.FromArrayToRef(p,b,this),this}addInPlace(p){return this.x+=p._x,this.y+=p._y,this.z+=p._z,this.w+=p._w,this}addInPlaceFromFloats(p,b,M,h){return this.x+=p,this.y+=b,this.z+=M,this.w+=h,this}add(p){return new g(this._x+p.x,this._y+p.y,this._z+p.z,this._w+p.w)}addToRef(p,b){return b.x=this._x+p.x,b.y=this._y+p.y,b.z=this._z+p.z,b.w=this._w+p.w,b}eS(p){return this.x-=p.x,this.y-=p.y,this.z-=p.z,this.w-=p.w,this}mh(p){return new g(this._x-p.x,this._y-p.y,this._z-p.z,this._w-p.w)}subtractToRef(p,b){return b.x=this._x-p.x,b.y=this._y-p.y,b.z=this._z-p.z,b.w=this._w-p.w,b}subtractFromFloats(p,b,M,h){return new g(this._x-p,this._y-b,this._z-M,this._w-h)}subtractFromFloatsToRef(p,b,M,h,Q){return Q.x=this._x-p,Q.y=this._y-b,Q.z=this._z-M,Q.w=this._w-h,Q}negate(){return new g(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(p){return p.x=-this._x,p.y=-this._y,p.z=-this._z,p.w=-this._w,p}scaleInPlace(p){return this.x*=p,this.y*=p,this.z*=p,this.w*=p,this}scale(p){return new g(this._x*p,this._y*p,this._z*p,this._w*p)}scaleToRef(p,b){return b.x=this._x*p,b.y=this._y*p,b.z=this._z*p,b.w=this._w*p,b}scaleAndAddToRef(p,b){return b.x+=this._x*p,b.y+=this._y*p,b.z+=this._z*p,b.w+=this._w*p,b}equals(p){return p&&this._x===p.x&&this._y===p.y&&this._z===p.z&&this._w===p.w}equalsWithEpsilon(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.d;return p&&(0,w.WithinEpsilon)(this._x,p.x,b)&&(0,w.WithinEpsilon)(this._y,p.y,b)&&(0,w.WithinEpsilon)(this._z,p.z,b)&&(0,w.WithinEpsilon)(this._w,p.w,b)}equalsToFloats(p,b,M,h){return this._x===p&&this._y===b&&this._z===M&&this._w===h}multiplyInPlace(p){return this.x*=p.x,this.y*=p.y,this.z*=p.z,this.w*=p.w,this}multiply(p){return new g(this._x*p.x,this._y*p.y,this._z*p.z,this._w*p.w)}multiplyToRef(p,b){return b.x=this._x*p.x,b.y=this._y*p.y,b.z=this._z*p.z,b.w=this._w*p.w,b}multiplyByFloats(p,b,M,h){return new g(this._x*p,this._y*b,this._z*M,this._w*h)}divide(p){return new g(this._x/p.x,this._y/p.y,this._z/p.z,this._w/p.w)}divideToRef(p,b){return b.x=this._x/p.x,b.y=this._y/p.y,b.z=this._z/p.z,b.w=this._w/p.w,b}divideInPlace(p){return this.divideToRef(p,this)}minimizeInPlace(p){return p.x<this._x&&(this.x=p.x),p.y<this._y&&(this.y=p.y),p.z<this._z&&(this.z=p.z),p.w<this._w&&(this.w=p.w),this}maximizeInPlace(p){return p.x>this._x&&(this.x=p.x),p.y>this._y&&(this.y=p.y),p.z>this._z&&(this.z=p.z),p.w>this._w&&(this.w=p.w),this}minimizeInPlaceFromFloats(p,b,M,h){return this.x=Math.min(p,this._x),this.y=Math.min(b,this._y),this.z=Math.min(M,this._z),this.w=Math.min(h,this._w),this}maximizeInPlaceFromFloats(p,b,M,h){return this.x=Math.max(p,this._x),this.y=Math.max(b,this._y),this.z=Math.max(M,this._z),this.w=Math.max(h,this._w),this}floorToRef(p){return p.x=Math.floor(this._x),p.y=Math.floor(this._y),p.z=Math.floor(this._z),p.w=Math.floor(this._w),p}floor(){return new g(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(p){return p.x=this._x-Math.floor(this._x),p.y=this._y-Math.floor(this._y),p.z=this._z-Math.floor(this._z),p.w=this._w-Math.floor(this._w),p}fract(){return new g(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(p){return 0===p||1===p?this:this.scaleInPlace(1/p)}normalizeToNew(){return this.normalizeToRef(new g)}normalizeToRef(p){const b=this.length();return 0===b||1===b?(p.x=this._x,p.y=this._y,p.z=this._z,p.w=this._w,p):this.scaleToRef(1/b,p)}toVector3(){return new J(this._x,this._y,this._z)}clone(){return new g(this._x,this._y,this._z,this._w)}mp(p){return this.x=p.x,this.y=p.y,this.z=p.z,this.w=p.w,this}sb(p,b,M,h){return this.x=p,this.y=b,this.z=M,this.w=h,this}set(p,b,M,h){return this.sb(p,b,M,h)}Tb(p){return this.x=this.y=this.z=this.w=p,this}dot(p){return this._x*p.x+this._y*p.y+this._z*p.z+this._w*p.w}static tM(p,b){return b||(b=0),new g(p[b],p[b+1],p[b+2],p[b+3])}static FromArrayToRef(p,b,M){return M.x=p[b],M.y=p[b+1],M.z=p[b+2],M.w=p[b+3],M}static FromFloatArrayToRef(p,b,M){return g.FromArrayToRef(p,b,M),M}static FromFloatsToRef(p,b,M,h,Q){return Q.x=p,Q.y=b,Q.z=M,Q.w=h,Q}static Zero(){return new g(0,0,0,0)}static One(){return new g(1,1,1,1)}static Random(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new g((0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b))}static RandomToRef(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,M=arguments.length>2?arguments[2]:void 0;return M.x=(0,w.RandomRange)(p,b),M.y=(0,w.RandomRange)(p,b),M.z=(0,w.RandomRange)(p,b),M.w=(0,w.RandomRange)(p,b),M}static Clamp(p,b,M){return g.ClampToRef(p,b,M,new g)}static ClampToRef(p,b,M,h){return h.x=(0,w.Clamp)(p.x,b.x,M.x),h.y=(0,w.Clamp)(p.y,b.y,M.y),h.z=(0,w.Clamp)(p.z,b.z,M.z),h.w=(0,w.Clamp)(p.w,b.w,M.w),h}static CheckExtends(p,b,M){b.minimizeInPlace(p),M.maximizeInPlace(p)}static get ZeroReadOnly(){return g._ZeroReadOnly}static Normalize(p){return g.NormalizeToRef(p,new g)}static NormalizeToRef(p,b){return p.normalizeToRef(b),b}static Minimize(p,b){const M=new g;return M.mp(p),M.minimizeInPlace(b),M}static Maximize(p,b){const M=new g;return M.mp(p),M.maximizeInPlace(b),M}static Distance(p,b){return Math.sqrt(g.DistanceSquared(p,b))}static DistanceSquared(p,b){const M=p.x-b.x,h=p.y-b.y,Q=p.z-b.z,mp=p.w-b.w;return M*M+h*h+Q*Q+mp*mp}static Center(p,b){return g.CenterToRef(p,b,new g)}static CenterToRef(p,b,M){return M.x=(p.x+b.x)/2,M.y=(p.y+b.y)/2,M.z=(p.z+b.z)/2,M.w=(p.w+b.w)/2,M}static TransformCoordinates(p,b){return g.TransformCoordinatesToRef(p,b,new g)}static TransformCoordinatesToRef(p,b,M){return g.TransformCoordinatesFromFloatsToRef(p._x,p._y,p._z,b,M),M}static TransformCoordinatesFromFloatsToRef(p,b,M,h,Q){const mp=h.m,y=p*mp[0]+b*mp[4]+M*mp[8]+mp[12],P=p*mp[1]+b*mp[5]+M*mp[9]+mp[13],w=p*mp[2]+b*mp[6]+M*mp[10]+mp[14],t=p*mp[3]+b*mp[7]+M*mp[11]+mp[15];return Q.x=y,Q.y=P,Q.z=w,Q.w=t,Q}static TransformNormal(p,b){return g.TransformNormalToRef(p,b,new g)}static TransformNormalToRef(p,b,M){const h=b.m,Q=p.x*h[0]+p.y*h[4]+p.z*h[8],mp=p.x*h[1]+p.y*h[5]+p.z*h[9],y=p.x*h[2]+p.y*h[6]+p.z*h[10];return M.x=Q,M.y=mp,M.z=y,M.w=p.w,M}static TransformNormalFromFloatsToRef(p,b,M,h,Q,mp){const y=Q.m;return mp.x=p*y[0]+b*y[4]+M*y[8],mp.y=p*y[1]+b*y[5]+M*y[9],mp.z=p*y[2]+b*y[6]+M*y[10],mp.w=h,mp}static FromVector3(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new g(p._x,p._y,p._z,b)}static Dot(p,b){return p.x*b.x+p.y*b.y+p.z*b.z+p.w*b.w}}g._V8PerformanceHack=new g(.5,.5,.5,.5),g._ZeroReadOnly=g.Zero(),Object.defineProperties(g.prototype,{dimension:{value:[4]},rank:{value:1}});class f{get x(){return this._x}set x(p){this._x=p,this._isDirty=!0}get y(){return this._y}set y(p){this._y=p,this._isDirty=!0}get z(){return this._z}set z(p){this._z=p,this._isDirty=!0}get w(){return this._w}set w(p){this._w=p,this._isDirty=!0}constructor(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=p,this._y=b,this._z=M,this._w=h}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let p=X(this._x);return p=397*p^X(this._y),p=397*p^X(this._z),p=397*p^X(this._w),p}ub(){return[this._x,this._y,this._z,this._w]}toArray(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p[b]=this._x,p[b+1]=this._y,p[b+2]=this._z,p[b+3]=this._w,this}Jh(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f.FromArrayToRef(p,b,this)}equals(p){return p&&this._x===p._x&&this._y===p._y&&this._z===p._z&&this._w===p._w}equalsWithEpsilon(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.d;return p&&(0,w.WithinEpsilon)(this._x,p._x,b)&&(0,w.WithinEpsilon)(this._y,p._y,b)&&(0,w.WithinEpsilon)(this._z,p._z,b)&&(0,w.WithinEpsilon)(this._w,p._w,b)}isApprox(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.d;return p&&((0,w.WithinEpsilon)(this._x,p._x,b)&&(0,w.WithinEpsilon)(this._y,p._y,b)&&(0,w.WithinEpsilon)(this._z,p._z,b)&&(0,w.WithinEpsilon)(this._w,p._w,b)||(0,w.WithinEpsilon)(this._x,-p._x,b)&&(0,w.WithinEpsilon)(this._y,-p._y,b)&&(0,w.WithinEpsilon)(this._z,-p._z,b)&&(0,w.WithinEpsilon)(this._w,-p._w,b))}clone(){return new f(this._x,this._y,this._z,this._w)}mp(p){return this._x=p._x,this._y=p._y,this._z=p._z,this._w=p._w,this._isDirty=!0,this}sb(p,b,M,h){return this._x=p,this._y=b,this._z=M,this._w=h,this._isDirty=!0,this}set(p,b,M,h){return this.sb(p,b,M,h)}Tb(p){return this.sb(p,p,p,p)}add(p){return new f(this._x+p._x,this._y+p._y,this._z+p._z,this._w+p._w)}addInPlace(p){return this._x+=p._x,this._y+=p._y,this._z+=p._z,this._w+=p._w,this._isDirty=!0,this}addToRef(p,b){return b._x=this._x+p._x,b._y=this._y+p._y,b._z=this._z+p._z,b._w=this._w+p._w,b._isDirty=!0,b}addInPlaceFromFloats(p,b,M,h){return this._x+=p,this._y+=b,this._z+=M,this._w+=h,this._isDirty=!0,this}subtractToRef(p,b){return b._x=this._x-p._x,b._y=this._y-p._y,b._z=this._z-p._z,b._w=this._w-p._w,b._isDirty=!0,b}subtractFromFloats(p,b,M,h){return this.subtractFromFloatsToRef(p,b,M,h,new f)}subtractFromFloatsToRef(p,b,M,h,Q){return Q._x=this._x-p,Q._y=this._y-b,Q._z=this._z-M,Q._w=this._w-h,Q._isDirty=!0,Q}mh(p){return new f(this._x-p._x,this._y-p._y,this._z-p._z,this._w-p._w)}eS(p){return this._x-=p._x,this._y-=p._y,this._z-=p._z,this._w-=p._w,this._isDirty=!0,this}scale(p){return new f(this._x*p,this._y*p,this._z*p,this._w*p)}scaleToRef(p,b){return b._x=this._x*p,b._y=this._y*p,b._z=this._z*p,b._w=this._w*p,b._isDirty=!0,b}scaleInPlace(p){return this._x*=p,this._y*=p,this._z*=p,this._w*=p,this._isDirty=!0,this}scaleAndAddToRef(p,b){return b._x+=this._x*p,b._y+=this._y*p,b._z+=this._z*p,b._w+=this._w*p,b._isDirty=!0,b}multiply(p){const b=new f(0,0,0,1);return this.multiplyToRef(p,b),b}multiplyToRef(p,b){const M=this._x*p._w+this._y*p._z-this._z*p._y+this._w*p._x,h=-this._x*p._z+this._y*p._w+this._z*p._x+this._w*p._y,Q=this._x*p._y-this._y*p._x+this._z*p._w+this._w*p._z,mp=-this._x*p._x-this._y*p._y-this._z*p._z+this._w*p._w;return b.sb(M,h,Q,mp),b}multiplyInPlace(p){return this.multiplyToRef(p,this)}multiplyByFloats(p,b,M,h){return this._x*=p,this._y*=b,this._z*=M,this._w*=h,this._isDirty=!0,this}divide(p){throw new ReferenceError("Can not divide a quaternion")}divideToRef(p,b){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(p){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new f)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(p){return p._x=-this._x,p._y=-this._y,p._z=-this._z,p._w=-this._w,p._isDirty=!0,p}equalsToFloats(p,b,M,h){return this._x===p&&this._y===b&&this._z===M&&this._w===h}floorToRef(p){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(p){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(p){return p.sb(-this._x,-this._y,-this._z,this._w),p}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new f(-this._x,-this._y,-this._z,this._w)}invert(){const p=this.conjugate(),b=this.lengthSquared();return 0==b||1==b||p.scaleInPlace(1/b),p}invertInPlace(){this.conjugateInPlace();const p=this.lengthSquared();return 0==p||1==p||this.scaleInPlace(1/p),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(p){return 0===p||1===p?this:this.scaleInPlace(1/p)}normalizeToNew(){const p=new f(0,0,0,1);return this.normalizeToRef(p),p}normalizeToRef(p){const b=this.length();return 0===b||1===b?p.sb(this._x,this._y,this._z,this._w):this.scaleToRef(1/b,p)}toEulerAngles(){const p=J.Zero();return this.toEulerAnglesToRef(p),p}toEulerAnglesToRef(p){const b=this._z,M=this._x,h=this._y,Q=this._w,mp=h*b-M*Q,y=.4999999;if(mp<-y)p._y=2*Math.atan2(h,Q),p._x=Math.PI/2,p._z=0,p._isDirty=!0;else if(mp>y)p._y=2*Math.atan2(h,Q),p._x=-Math.PI/2,p._z=0,p._isDirty=!0;else{const y=Q*Q,P=b*b,w=M*M,t=h*h;p._z=Math.atan2(2*(M*h+b*Q),-P-w+t+y),p._x=Math.asin(-2*mp),p._y=Math.atan2(2*(b*M+h*Q),P-w-t+y),p._isDirty=!0}return p}toAlphaBetaGammaToRef(p){const b=this._z,M=this._x,h=this._y,Q=this._w,mp=Math.sqrt(M*M+h*h),y=Math.sqrt(b*b+Q*Q),P=2*Math.atan2(mp,y),w=2*Math.atan2(b,Q),t=2*Math.atan2(h,M),z=(w+t)/2,x=(w-t)/2;return p.set(x,P,z),p}toRotationMatrix(p){return Y.FromQuaternionToRef(this,p),p}fromRotationMatrix(p){return f.FromRotationMatrixToRef(p,this),this}dot(p){return this._x*p._x+this._y*p._y+this._z*p._z+this._w*p._w}toAxisAngle(){const p=J.Zero();return{axis:p,angle:this.toAxisAngleToRef(p)}}toAxisAngleToRef(p){let b=0;const M=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),h=this._w;return M>0?(b=2*Math.atan2(M,h),p.set(this._x/M,this._y/M,this._z/M)):(b=0,p.set(1,0,0)),b}static FromRotationMatrix(p){const b=new f;return f.FromRotationMatrixToRef(p,b),b}static FromRotationMatrixToRef(p,b){const M=p.m,h=M[0],Q=M[4],mp=M[8],y=M[1],P=M[5],w=M[9],t=M[2],z=M[6],x=M[10],S=h+P+x;let X;return S>0?(X=.5/Math.sqrt(S+1),b._w=.25/X,b._x=(z-w)*X,b._y=(mp-t)*X,b._z=(y-Q)*X,b._isDirty=!0):h>P&&h>x?(X=2*Math.sqrt(1+h-P-x),b._w=(z-w)/X,b._x=.25*X,b._y=(Q+y)/X,b._z=(mp+t)/X,b._isDirty=!0):P>x?(X=2*Math.sqrt(1+P-h-x),b._w=(mp-t)/X,b._x=(Q+y)/X,b._y=.25*X,b._z=(w+z)/X,b._isDirty=!0):(X=2*Math.sqrt(1+x-h-P),b._w=(y-Q)/X,b._x=(mp+t)/X,b._y=(w+z)/X,b._z=.25*X,b._isDirty=!0),b}static Dot(p,b){return p._x*b._x+p._y*b._y+p._z*b._z+p._w*b._w}static AreClose(p,b){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const h=f.Dot(p,b);return 1-h*h<=M}static SmoothToRef(p,b,M,h,Q){let mp=0===h?1:M/h;return mp=(0,w.Clamp)(mp,0,1),f.SlerpToRef(p,b,mp,Q),Q}static Zero(){return new f(0,0,0,0)}static Inverse(p){return new f(-p._x,-p._y,-p._z,p._w)}static InverseToRef(p,b){return b.set(-p._x,-p._y,-p._z,p._w),b}static Identity(){return new f(0,0,0,1)}static IsIdentity(p){return p&&0===p._x&&0===p._y&&0===p._z&&1===p._w}static RotationAxis(p,b){return f.RotationAxisToRef(p,b,new f)}static RotationAxisToRef(p,b,M){M._w=Math.cos(b/2);const h=Math.sin(b/2)/p.length();return M._x=p._x*h,M._y=p._y*h,M._z=p._z*h,M._isDirty=!0,M}static tM(p,b){return b||(b=0),new f(p[b],p[b+1],p[b+2],p[b+3])}static FromArrayToRef(p,b,M){return M._x=p[b],M._y=p[b+1],M._z=p[b+2],M._w=p[b+3],M._isDirty=!0,M}static FromFloatsToRef(p,b,M,h,Q){return Q.sb(p,b,M,h),Q}static FromEulerAngles(p,b,M){const h=new f;return f.RotationYawPitchRollToRef(b,p,M,h),h}static FromEulerAnglesToRef(p,b,M,h){return f.RotationYawPitchRollToRef(b,p,M,h),h}static FromEulerVector(p){const b=new f;return f.RotationYawPitchRollToRef(p._y,p._x,p._z,b),b}static FromEulerVectorToRef(p,b){return f.RotationYawPitchRollToRef(p._y,p._x,p._z,b),b}static FromUnitVectorsToRef(p,b,M){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:h.d;const mp=J.Dot(p,b)+1;return mp<Q?Math.abs(p.x)>Math.abs(p.z)?M.set(-p.y,p.x,0,0):M.set(0,-p.z,p.y,0):(J.CrossToRef(p,b,o.QM[0]),M.set(o.QM[0].x,o.QM[0].y,o.QM[0].z,mp)),M.normalize()}static RotationYawPitchRoll(p,b,M){const h=new f;return f.RotationYawPitchRollToRef(p,b,M,h),h}static RotationYawPitchRollToRef(p,b,M,h){const Q=.5*M,mp=.5*b,y=.5*p,P=Math.sin(Q),w=Math.cos(Q),t=Math.sin(mp),z=Math.cos(mp),x=Math.sin(y),S=Math.cos(y);return h._x=S*t*w+x*z*P,h._y=x*z*w-S*t*P,h._z=S*z*P-x*t*w,h._w=S*z*w+x*t*P,h._isDirty=!0,h}static RotationAlphaBetaGamma(p,b,M){const h=new f;return f.RotationAlphaBetaGammaToRef(p,b,M,h),h}static RotationAlphaBetaGammaToRef(p,b,M,h){const Q=.5*(M+p),mp=.5*(M-p),y=.5*b;return h._x=Math.cos(mp)*Math.sin(y),h._y=Math.sin(mp)*Math.sin(y),h._z=Math.sin(Q)*Math.cos(y),h._w=Math.cos(Q)*Math.cos(y),h._isDirty=!0,h}static RotationQuaternionFromAxis(p,b,M){const h=new f(0,0,0,0);return f.RotationQuaternionFromAxisToRef(p,b,M,h),h}static RotationQuaternionFromAxisToRef(p,b,M,h){const Q=a.Matrix[0];return p=p.normalizeToRef(a.QM[0]),b=b.normalizeToRef(a.QM[1]),M=M.normalizeToRef(a.QM[2]),Y.FromXYZAxesToRef(p,b,M,Q),f.FromRotationMatrixToRef(Q,h),h}static FromLookDirectionLH(p,b){const M=new f;return f.FromLookDirectionLHToRef(p,b,M),M}static FromLookDirectionLHToRef(p,b,M){const h=a.Matrix[0];return Y.LookDirectionLHToRef(p,b,h),f.FromRotationMatrixToRef(h,M),M}static FromLookDirectionRH(p,b){const M=new f;return f.FromLookDirectionRHToRef(p,b,M),M}static FromLookDirectionRHToRef(p,b,M){const h=a.Matrix[0];return Y.LookDirectionRHToRef(p,b,h),f.FromRotationMatrixToRef(h,M)}static Slerp(p,b,M){const h=f.Identity();return f.SlerpToRef(p,b,M,h),h}static SlerpToRef(p,b,M,h){let Q,mp,y=p._x*b._x+p._y*b._y+p._z*b._z+p._w*b._w,P=!1;if(y<0&&(P=!0,y=-y),y>.999999)mp=1-M,Q=P?-M:M;else{const p=Math.acos(y),b=1/Math.sin(p);mp=Math.sin((1-M)*p)*b,Q=P?-Math.sin(M*p)*b:Math.sin(M*p)*b}return h._x=mp*p._x+Q*b._x,h._y=mp*p._y+Q*b._y,h._z=mp*p._z+Q*b._z,h._w=mp*p._w+Q*b._w,h._isDirty=!0,h}static Hermite(p,b,M,h,Q){const mp=Q*Q,y=Q*mp,P=2*y-3*mp+1,w=-2*y+3*mp,t=y-2*mp+Q,z=y-mp,x=p._x*P+M._x*w+b._x*t+h._x*z,S=p._y*P+M._y*w+b._y*t+h._y*z,X=p._z*P+M._z*w+b._z*t+h._z*z,c=p._w*P+M._w*w+b._w*t+h._w*z;return new f(x,S,X,c)}static Hermite1stDerivative(p,b,M,h,Q){const mp=new f;return this.Hermite1stDerivativeToRef(p,b,M,h,Q,mp),mp}static Hermite1stDerivativeToRef(p,b,M,h,Q,mp){const y=Q*Q;return mp._x=6*(y-Q)*p._x+(3*y-4*Q+1)*b._x+6*(-y+Q)*M._x+(3*y-2*Q)*h._x,mp._y=6*(y-Q)*p._y+(3*y-4*Q+1)*b._y+6*(-y+Q)*M._y+(3*y-2*Q)*h._y,mp._z=6*(y-Q)*p._z+(3*y-4*Q+1)*b._z+6*(-y+Q)*M._z+(3*y-2*Q)*h._z,mp._w=6*(y-Q)*p._w+(3*y-4*Q+1)*b._w+6*(-y+Q)*M._w+(3*y-2*Q)*h._w,mp._isDirty=!0,mp}static Normalize(p){const b=f.Zero();return f.NormalizeToRef(p,b),b}static NormalizeToRef(p,b){return p.normalizeToRef(b),b}static Clamp(p,b,M){const h=new f;return f.ClampToRef(p,b,M,h),h}static ClampToRef(p,b,M,h){return h.sb((0,w.Clamp)(p.x,b.x,M.x),(0,w.Clamp)(p.y,b.y,M.y),(0,w.Clamp)(p.z,b.z,M.z),(0,w.Clamp)(p.w,b.w,M.w))}static Random(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new f((0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b))}static RandomToRef(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).sb((0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b),(0,w.RandomRange)(p,b))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(p,b){return Math.sqrt(f.DistanceSquared(p,b))}static DistanceSquared(p,b){const M=p.x-b.x,h=p.y-b.y,Q=p.z-b.z,mp=p.w-b.w;return M*M+h*h+Q*Q+mp*mp}static Center(p,b){return f.CenterToRef(p,b,f.Zero())}static CenterToRef(p,b,M){return M.sb((p.x+b.x)/2,(p.y+b.y)/2,(p.z+b.z)/2,(p.w+b.w)/2)}}f._V8PerformanceHack=new f(.5,.5,.5,.5),Object.defineProperties(f.prototype,{dimension:{value:[4]},rank:{value:1}});class Y{static get Use64Bits(){return y.d.MatrixUse64Bits}get m(){return this.Jb}markAsUpdated(){this.updateFlag=t._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(p){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],M=arguments.length>2&&void 0!==arguments[2]&&arguments[2],h=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=p,this._isIdentity3x2=p||M,this._isIdentityDirty=!this._isIdentity&&b,this._isIdentity3x2Dirty=!this._isIdentity3x2&&h}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,y.d.MatrixTrackPrecisionChange&&y.d.MatrixTrackedMatrices.push(this),this.Jb=new y.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const p=this.Jb;this._isIdentity=1===p[0]&&0===p[1]&&0===p[2]&&0===p[3]&&0===p[4]&&1===p[5]&&0===p[6]&&0===p[7]&&0===p[8]&&0===p[9]&&1===p[10]&&0===p[11]&&0===p[12]&&0===p[13]&&0===p[14]&&1===p[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Jb[0]||1!==this.Jb[5]||1!==this.Jb[15]||0!==this.Jb[1]||0!==this.Jb[2]||0!==this.Jb[3]||0!==this.Jb[4]||0!==this.Jb[6]||0!==this.Jb[7]||0!==this.Jb[8]||0!==this.Jb[9]||0!==this.Jb[10]||0!==this.Jb[11]||0!==this.Jb[12]||0!==this.Jb[13]||0!==this.Jb[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const p=this.Jb,b=p[0],M=p[1],h=p[2],Q=p[3],mp=p[4],y=p[5],P=p[6],w=p[7],t=p[8],z=p[9],x=p[10],S=p[11],X=p[12],c=p[13],J=p[14],g=p[15],f=x*g-J*S,Y=z*g-c*S,a=z*J-c*x,o=t*g-X*S,l=t*J-x*X,L=t*c-X*z;return b*+(y*f-P*Y+w*a)+M*-(mp*f-P*o+w*l)+h*+(mp*Y-y*o+w*L)+Q*-(mp*a-y*l+P*L)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!p)return this.Jb;const M=this.Jb;for(let h=0;h<16;h++)p[b+h]=M[h];return this}ub(){return this.Jb}Jh(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y.FromArrayToRef(p,b,this)}sb(){for(var p=arguments.length,b=new Array(p),M=0;M<p;M++)b[M]=arguments[M];return Y.FromArrayToRef(b,0,this)}set(){const p=this.Jb;for(let b=0;b<16;b++)p[b]=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}Tb(p){const b=this.Jb;for(let M=0;M<16;M++)b[M]=p;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return Y.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(p){const b=new Y;return this.addToRef(p,b),b}addToRef(p,b){const M=this.Jb,h=b.Jb,Q=p.m;for(let mp=0;mp<16;mp++)h[mp]=M[mp]+Q[mp];return b.markAsUpdated(),b}addToSelf(p){const b=this.Jb,M=p.m;return b[0]+=M[0],b[1]+=M[1],b[2]+=M[2],b[3]+=M[3],b[4]+=M[4],b[5]+=M[5],b[6]+=M[6],b[7]+=M[7],b[8]+=M[8],b[9]+=M[9],b[10]+=M[10],b[11]+=M[11],b[12]+=M[12],b[13]+=M[13],b[14]+=M[14],b[15]+=M[15],this.markAsUpdated(),this}addInPlace(p){const b=this.Jb,M=p.m;for(let h=0;h<16;h++)b[h]+=M[h];return this.markAsUpdated(),this}addInPlaceFromFloats(){const p=this.Jb;for(let b=0;b<16;b++)p[b]+=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}mh(p){const b=this.Jb,M=p.m;for(let h=0;h<16;h++)b[h]-=M[h];return this.markAsUpdated(),this}subtractToRef(p,b){const M=this.Jb,h=p.m,Q=b.Jb;for(let mp=0;mp<16;mp++)Q[mp]=M[mp]-h[mp];return b.markAsUpdated(),b}eS(p){const b=this.Jb,M=p.m;for(let h=0;h<16;h++)b[h]-=M[h];return this.markAsUpdated(),this}subtractFromFloats(){for(var p=arguments.length,b=new Array(p),M=0;M<p;M++)b[M]=arguments[M];return this.subtractFromFloatsToRef(...b,new Y)}subtractFromFloatsToRef(){for(var p=arguments.length,b=new Array(p),M=0;M<p;M++)b[M]=arguments[M];const h=b.pop(),Q=this.Jb,mp=h.Jb,y=b;for(let P=0;P<16;P++)mp[P]=Q[P]-y[P];return h.markAsUpdated(),h}invertToRef(p){return!0===this._isIdentity?(Y.IdentityToRef(p),p):(S(this,p.ub())?p.markAsUpdated():p.mp(this),p)}addAtIndex(p,b){return this.Jb[p]+=b,this.markAsUpdated(),this}multiplyAtIndex(p,b){return this.Jb[p]*=b,this.markAsUpdated(),this}setTranslationFromFloats(p,b,M){return this.Jb[12]=p,this.Jb[13]=b,this.Jb[14]=M,this.markAsUpdated(),this}addTranslationFromFloats(p,b,M){return this.Jb[12]+=p,this.Jb[13]+=b,this.Jb[14]+=M,this.markAsUpdated(),this}setTranslation(p){return this.setTranslationFromFloats(p._x,p._y,p._z)}getTranslation(){return new J(this.Jb[12],this.Jb[13],this.Jb[14])}getTranslationToRef(p){return p.x=this.Jb[12],p.y=this.Jb[13],p.z=this.Jb[14],p}removeRotationAndScaling(){const p=this.m;return Y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,p[12],p[13],p[14],p[15],this),this._updateIdentityStatus(0===p[12]&&0===p[13]&&0===p[14]&&1===p[15]),this}mp(p){p.copyToArray(this.Jb);const b=p;return this.updateFlag=b.updateFlag,this._updateIdentityStatus(b._isIdentity,b._isIdentityDirty,b._isIdentity3x2,b._isIdentity3x2Dirty),this}copyToArray(p){return x(this,p,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(p){const b=new Y;return this.multiplyToRef(p,b),b}multiplyInPlace(p){const b=this.Jb,M=p.m;for(let h=0;h<16;h++)b[h]*=M[h];return this.markAsUpdated(),this}multiplyByFloats(){const p=this.Jb;for(let b=0;b<16;b++)p[b]*=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var p=arguments.length,b=new Array(p),M=0;M<p;M++)b[M]=arguments[M];const h=b.pop(),Q=this.Jb,mp=h.Jb,y=b;for(let P=0;P<16;P++)mp[P]=Q[P]*y[P];return h.markAsUpdated(),h}multiplyToRef(p,b){return this._isIdentity?(b.mp(p),b):p._isIdentity?(b.mp(this),b):(this.multiplyToArray(p,b.Jb,0),b.markAsUpdated(),b)}multiplyToArray(p,b,M){return z(this,p,b,M),this}divide(p){return this.divideToRef(p,new Y)}divideToRef(p,b){const M=this.Jb,h=p.m,Q=b.Jb;for(let mp=0;mp<16;mp++)Q[mp]=M[mp]/h[mp];return b.markAsUpdated(),b}divideInPlace(p){const b=this.Jb,M=p.m;for(let h=0;h<16;h++)b[h]/=M[h];return this.markAsUpdated(),this}minimizeInPlace(p){const b=this.Jb,M=p.m;for(let h=0;h<16;h++)b[h]=Math.min(b[h],M[h]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const p=this.Jb;for(let b=0;b<16;b++)p[b]=Math.min(p[b],b<0||arguments.length<=b?void 0:arguments[b]);return this.markAsUpdated(),this}maximizeInPlace(p){const b=this.Jb,M=p.m;for(let h=0;h<16;h++)b[h]=Math.min(b[h],M[h]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const p=this.Jb;for(let b=0;b<16;b++)p[b]=Math.min(p[b],b<0||arguments.length<=b?void 0:arguments[b]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new Y)}negateInPlace(){const p=this.Jb;for(let b=0;b<16;b++)p[b]=-p[b];return this.markAsUpdated(),this}negateToRef(p){const b=this.Jb,M=p.Jb;for(let h=0;h<16;h++)M[h]=-b[h];return p.markAsUpdated(),p}equals(p){const b=p;if(!b)return!1;if((this._isIdentity||b._isIdentity)&&!this._isIdentityDirty&&!b._isIdentityDirty)return this._isIdentity&&b._isIdentity;const M=this.m,h=b.m;return M[0]===h[0]&&M[1]===h[1]&&M[2]===h[2]&&M[3]===h[3]&&M[4]===h[4]&&M[5]===h[5]&&M[6]===h[6]&&M[7]===h[7]&&M[8]===h[8]&&M[9]===h[9]&&M[10]===h[10]&&M[11]===h[11]&&M[12]===h[12]&&M[13]===h[13]&&M[14]===h[14]&&M[15]===h[15]}equalsWithEpsilon(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const M=this.Jb,h=p.m;for(let Q=0;Q<16;Q++)if(!(0,w.WithinEpsilon)(M[Q],h[Q],b))return!1;return!0}equalsToFloats(){const p=this.Jb;for(let b=0;b<16;b++)if(p[b]!=(b<0||arguments.length<=b?void 0:arguments[b]))return!1;return!0}floor(){return this.floorToRef(new Y)}floorToRef(p){const b=this.Jb,M=p.Jb;for(let h=0;h<16;h++)M[h]=Math.floor(b[h]);return p.markAsUpdated(),p}fract(){return this.fractToRef(new Y)}fractToRef(p){const b=this.Jb,M=p.Jb;for(let h=0;h<16;h++)M[h]=b[h]-Math.floor(b[h]);return p.markAsUpdated(),p}clone(){const p=new Y;return p.mp(this),p}getClassName(){return"Matrix"}getHashCode(){let p=X(this.Jb[0]);for(let b=1;b<16;b++)p=397*p^X(this.Jb[b]);return p}decomposeToTransformNode(p){return p.rotationQuaternion=p.rotationQuaternion||new f,this.decompose(p.ib,p.rotationQuaternion,p.position)}decompose(p,b,M,h){let Q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return M&&M.Tb(0),p&&p.Tb(1),b&&b.sb(0,0,0,1),!0;const mp=this.Jb;if(M&&M.sb(mp[12],mp[13],mp[14]),(p=p||a.QM[0]).x=Math.sqrt(mp[0]*mp[0]+mp[1]*mp[1]+mp[2]*mp[2]),p.y=Math.sqrt(mp[4]*mp[4]+mp[5]*mp[5]+mp[6]*mp[6]),p.z=Math.sqrt(mp[8]*mp[8]+mp[9]*mp[9]+mp[10]*mp[10]),h){const b=(Q?h.absoluteScaling.x:h.ib.x)<0?-1:1,M=(Q?h.absoluteScaling.y:h.ib.y)<0?-1:1,mp=(Q?h.absoluteScaling.z:h.ib.z)<0?-1:1;p.x*=b,p.y*=M,p.z*=mp}else this.determinant()<=0&&(p.y*=-1);if(0===p._x||0===p._y||0===p._z)return b&&b.sb(0,0,0,1),!1;if(b){const M=1/p._x,h=1/p._y,Q=1/p._z;Y.FromValuesToRef(mp[0]*M,mp[1]*M,mp[2]*M,0,mp[4]*h,mp[5]*h,mp[6]*h,0,mp[8]*Q,mp[9]*Q,mp[10]*Q,0,0,0,0,1,a.Matrix[0]),f.FromRotationMatrixToRef(a.Matrix[0],b)}return!0}getRow(p){if(p<0||p>3)return null;const b=4*p;return new g(this.Jb[b+0],this.Jb[b+1],this.Jb[b+2],this.Jb[b+3])}getRowToRef(p,b){if(p>=0&&p<=3){const M=4*p;b.x=this.Jb[M+0],b.y=this.Jb[M+1],b.z=this.Jb[M+2],b.w=this.Jb[M+3]}return b}setRow(p,b){return this.setRowFromFloats(p,b.x,b.y,b.z,b.w)}transpose(){const p=new Y;return Y.TransposeToRef(this,p),p}transposeToRef(p){return Y.TransposeToRef(this,p),p}setRowFromFloats(p,b,M,h,Q){if(p<0||p>3)return this;const mp=4*p;return this.Jb[mp+0]=b,this.Jb[mp+1]=M,this.Jb[mp+2]=h,this.Jb[mp+3]=Q,this.markAsUpdated(),this}scale(p){const b=new Y;return this.scaleToRef(p,b),b}scaleToRef(p,b){for(let M=0;M<16;M++)b.Jb[M]=this.Jb[M]*p;return b.markAsUpdated(),b}scaleAndAddToRef(p,b){for(let M=0;M<16;M++)b.Jb[M]+=this.Jb[M]*p;return b.markAsUpdated(),b}scaleInPlace(p){const b=this.Jb;for(let M=0;M<16;M++)b[M]*=p;return this.markAsUpdated(),this}toNormalMatrix(p){const b=a.Matrix[0];this.invertToRef(b),b.transposeToRef(p);const M=p.Jb;return Y.FromValuesToRef(M[0],M[1],M[2],0,M[4],M[5],M[6],0,M[8],M[9],M[10],0,0,0,0,1,p),p}getRotationMatrix(){const p=new Y;return this.getRotationMatrixToRef(p),p}getRotationMatrixToRef(p){const b=a.QM[0];if(!this.decompose(b))return Y.IdentityToRef(p),p;const M=this.Jb,h=1/b._x,Q=1/b._y,mp=1/b._z;return Y.FromValuesToRef(M[0]*h,M[1]*h,M[2]*h,0,M[4]*Q,M[5]*Q,M[6]*Q,0,M[8]*mp,M[9]*mp,M[10]*mp,0,0,0,0,1,p),p}toggleModelMatrixHandInPlace(){const p=this.Jb;return p[2]*=-1,p[6]*=-1,p[8]*=-1,p[9]*=-1,p[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const p=this.Jb;return p[8]*=-1,p[9]*=-1,p[10]*=-1,p[11]*=-1,this.markAsUpdated(),this}static tM(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const M=new Y;return Y.FromArrayToRef(p,b,M),M}static FromArrayToRef(p,b,M){for(let h=0;h<16;h++)M.Jb[h]=p[h+b];return M.markAsUpdated(),M}static FromFloat32ArrayToRefScaled(p,b,M,h){return h.Jb[0]=p[0+b]*M,h.Jb[1]=p[1+b]*M,h.Jb[2]=p[2+b]*M,h.Jb[3]=p[3+b]*M,h.Jb[4]=p[4+b]*M,h.Jb[5]=p[5+b]*M,h.Jb[6]=p[6+b]*M,h.Jb[7]=p[7+b]*M,h.Jb[8]=p[8+b]*M,h.Jb[9]=p[9+b]*M,h.Jb[10]=p[10+b]*M,h.Jb[11]=p[11+b]*M,h.Jb[12]=p[12+b]*M,h.Jb[13]=p[13+b]*M,h.Jb[14]=p[14+b]*M,h.Jb[15]=p[15+b]*M,h.markAsUpdated(),h}static get IdentityReadOnly(){return Y._IdentityReadOnly}static FromValuesToRef(p,b,M,h,Q,mp,y,P,w,t,z,x,S,X,c,J,g){const f=g.Jb;f[0]=p,f[1]=b,f[2]=M,f[3]=h,f[4]=Q,f[5]=mp,f[6]=y,f[7]=P,f[8]=w,f[9]=t,f[10]=z,f[11]=x,f[12]=S,f[13]=X,f[14]=c,f[15]=J,g.markAsUpdated()}static FromValues(p,b,M,h,Q,mp,y,P,w,t,z,x,S,X,c,J){const g=new Y,f=g.Jb;return f[0]=p,f[1]=b,f[2]=M,f[3]=h,f[4]=Q,f[5]=mp,f[6]=y,f[7]=P,f[8]=w,f[9]=t,f[10]=z,f[11]=x,f[12]=S,f[13]=X,f[14]=c,f[15]=J,g.markAsUpdated(),g}static Compose(p,b,M){const h=new Y;return Y.ComposeToRef(p,b,M,h),h}static ComposeToRef(p,b,M,h){const Q=h.Jb,mp=b._x,y=b._y,P=b._z,w=b._w,t=mp+mp,z=y+y,x=P+P,S=mp*t,X=mp*z,c=mp*x,J=y*z,g=y*x,f=P*x,Y=w*t,a=w*z,o=w*x,l=p._x,L=p._y,u=p._z;return Q[0]=(1-(J+f))*l,Q[1]=(X+o)*l,Q[2]=(c-a)*l,Q[3]=0,Q[4]=(X-o)*L,Q[5]=(1-(S+f))*L,Q[6]=(g+Y)*L,Q[7]=0,Q[8]=(c+a)*u,Q[9]=(g-Y)*u,Q[10]=(1-(S+J))*u,Q[11]=0,Q[12]=M._x,Q[13]=M._y,Q[14]=M._z,Q[15]=1,h.markAsUpdated(),h}static Identity(){const p=Y.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return p._updateIdentityStatus(!0),p}static IdentityToRef(p){return Y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,p),p._updateIdentityStatus(!0),p}static Zero(){const p=Y.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return p._updateIdentityStatus(!1),p}static RotationX(p){const b=new Y;return Y.RotationXToRef(p,b),b}static Invert(p){const b=new Y;return p.invertToRef(b),b}static RotationXToRef(p,b){const M=Math.sin(p),h=Math.cos(p);return Y.FromValuesToRef(1,0,0,0,0,h,M,0,0,-M,h,0,0,0,0,1,b),b._updateIdentityStatus(1===h&&0===M),b}static RotationY(p){const b=new Y;return Y.RotationYToRef(p,b),b}static RotationYToRef(p,b){const M=Math.sin(p),h=Math.cos(p);return Y.FromValuesToRef(h,0,-M,0,0,1,0,0,M,0,h,0,0,0,0,1,b),b._updateIdentityStatus(1===h&&0===M),b}static RotationZ(p){const b=new Y;return Y.RotationZToRef(p,b),b}static RotationZToRef(p,b){const M=Math.sin(p),h=Math.cos(p);return Y.FromValuesToRef(h,M,0,0,-M,h,0,0,0,0,1,0,0,0,0,1,b),b._updateIdentityStatus(1===h&&0===M),b}static RotationAxis(p,b){const M=new Y;return Y.RotationAxisToRef(p,b,M),M}static RotationAxisToRef(p,b,M){const h=Math.sin(-b),Q=Math.cos(-b),mp=1-Q;p=p.normalizeToRef(a.QM[0]);const y=M.Jb;return y[0]=p._x*p._x*mp+Q,y[1]=p._x*p._y*mp-p._z*h,y[2]=p._x*p._z*mp+p._y*h,y[3]=0,y[4]=p._y*p._x*mp+p._z*h,y[5]=p._y*p._y*mp+Q,y[6]=p._y*p._z*mp-p._x*h,y[7]=0,y[8]=p._z*p._x*mp-p._y*h,y[9]=p._z*p._y*mp+p._x*h,y[10]=p._z*p._z*mp+Q,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,M.markAsUpdated(),M}static RotationAlignToRef(p,b,M){let Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const mp=J.Dot(b,p),y=M.Jb;if(mp<-1+h.d)y[0]=-1,y[1]=0,y[2]=0,y[3]=0,y[4]=0,y[5]=Q?1:-1,y[6]=0,y[7]=0,y[8]=0,y[9]=0,y[10]=Q?-1:1,y[11]=0;else{const M=J.Cross(b,p),h=1/(1+mp);y[0]=M._x*M._x*h+mp,y[1]=M._y*M._x*h-M._z,y[2]=M._z*M._x*h+M._y,y[3]=0,y[4]=M._x*M._y*h+M._z,y[5]=M._y*M._y*h+mp,y[6]=M._z*M._y*h-M._x,y[7]=0,y[8]=M._x*M._z*h-M._y,y[9]=M._y*M._z*h+M._x,y[10]=M._z*M._z*h+mp,y[11]=0}return y[12]=0,y[13]=0,y[14]=0,y[15]=1,M.markAsUpdated(),M}static RotationYawPitchRoll(p,b,M){const h=new Y;return Y.RotationYawPitchRollToRef(p,b,M,h),h}static RotationYawPitchRollToRef(p,b,M,h){return f.RotationYawPitchRollToRef(p,b,M,a.Quaternion[0]),a.Quaternion[0].toRotationMatrix(h),h}static Scaling(p,b,M){const h=new Y;return Y.ScalingToRef(p,b,M,h),h}static ScalingToRef(p,b,M,h){return Y.FromValuesToRef(p,0,0,0,0,b,0,0,0,0,M,0,0,0,0,1,h),h._updateIdentityStatus(1===p&&1===b&&1===M),h}static Translation(p,b,M){const h=new Y;return Y.TranslationToRef(p,b,M,h),h}static TranslationToRef(p,b,M,h){return Y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,p,b,M,1,h),h._updateIdentityStatus(0===p&&0===b&&0===M),h}static Lerp(p,b,M){const h=new Y;return Y.LerpToRef(p,b,M,h),h}static LerpToRef(p,b,M,h){const Q=h.Jb,mp=p.m,y=b.m;for(let P=0;P<16;P++)Q[P]=mp[P]*(1-M)+y[P]*M;return h.markAsUpdated(),h}static DecomposeLerp(p,b,M){const h=new Y;return Y.DecomposeLerpToRef(p,b,M,h),h}static DecomposeLerpToRef(p,b,M,h){const Q=a.QM[0],mp=a.Quaternion[0],y=a.QM[1];p.decompose(Q,mp,y);const P=a.QM[2],w=a.Quaternion[1],t=a.QM[3];b.decompose(P,w,t);const z=a.QM[4];J.LerpToRef(Q,P,M,z);const x=a.Quaternion[2];f.SlerpToRef(mp,w,M,x);const S=a.QM[5];return J.LerpToRef(y,t,M,S),Y.ComposeToRef(z,x,S,h),h}static LookAtLH(p,b,M){const h=new Y;return Y.LookAtLHToRef(p,b,M,h),h}static LookAtLHToRef(p,b,M,h){const Q=a.QM[0],mp=a.QM[1],y=a.QM[2];b.subtractToRef(p,y),y.normalize(),J.CrossToRef(M,y,Q);const P=Q.lengthSquared();0===P?Q.x=1:Q.normalizeFromLength(Math.sqrt(P)),J.CrossToRef(y,Q,mp),mp.normalize();const w=-J.Dot(Q,p),t=-J.Dot(mp,p),z=-J.Dot(y,p);return Y.FromValuesToRef(Q._x,mp._x,y._x,0,Q._y,mp._y,y._y,0,Q._z,mp._z,y._z,0,w,t,z,1,h),h}static LookAtRH(p,b,M){const h=new Y;return Y.LookAtRHToRef(p,b,M,h),h}static LookAtRHToRef(p,b,M,h){const Q=a.QM[0],mp=a.QM[1],y=a.QM[2];p.subtractToRef(b,y),y.normalize(),J.CrossToRef(M,y,Q);const P=Q.lengthSquared();0===P?Q.x=1:Q.normalizeFromLength(Math.sqrt(P)),J.CrossToRef(y,Q,mp),mp.normalize();const w=-J.Dot(Q,p),t=-J.Dot(mp,p),z=-J.Dot(y,p);return Y.FromValuesToRef(Q._x,mp._x,y._x,0,Q._y,mp._y,y._y,0,Q._z,mp._z,y._z,0,w,t,z,1,h),h}static LookDirectionLH(p,b){const M=new Y;return Y.LookDirectionLHToRef(p,b,M),M}static LookDirectionLHToRef(p,b,M){const h=a.QM[0];h.mp(p),h.scaleInPlace(-1);const Q=a.QM[1];return J.CrossToRef(b,h,Q),Y.FromValuesToRef(Q._x,Q._y,Q._z,0,b._x,b._y,b._z,0,h._x,h._y,h._z,0,0,0,0,1,M),M}static LookDirectionRH(p,b){const M=new Y;return Y.LookDirectionRHToRef(p,b,M),M}static LookDirectionRHToRef(p,b,M){const h=a.QM[2];return J.CrossToRef(b,p,h),Y.FromValuesToRef(h._x,h._y,h._z,0,b._x,b._y,b._z,0,p._x,p._y,p._z,0,0,0,0,1,M),M}static OrthoLH(p,b,M,h,Q){const mp=new Y;return Y.OrthoLHToRef(p,b,M,h,mp,Q),mp}static OrthoLHToRef(p,b,M,h,Q,mp){const y=2/p,P=2/b,w=2/(h-M),t=-(h+M)/(h-M);return Y.FromValuesToRef(y,0,0,0,0,P,0,0,0,0,w,0,0,0,t,1,Q),mp&&Q.multiplyToRef(l,Q),Q._updateIdentityStatus(1===y&&1===P&&1===w&&0===t),Q}static OrthoOffCenterLH(p,b,M,h,Q,mp,y){const P=new Y;return Y.OrthoOffCenterLHToRef(p,b,M,h,Q,mp,P,y),P}static OrthoOffCenterLHToRef(p,b,M,h,Q,mp,y,P){const w=2/(b-p),t=2/(h-M),z=2/(mp-Q),x=-(mp+Q)/(mp-Q),S=(p+b)/(p-b),X=(h+M)/(M-h);return Y.FromValuesToRef(w,0,0,0,0,t,0,0,0,0,z,0,S,X,x,1,y),P&&y.multiplyToRef(l,y),y.markAsUpdated(),y}static ObliqueOffCenterLHToRef(p,b,M,h,Q,mp,y,P,w,t,z){const x=-y*Math.cos(P),S=-y*Math.sin(P);return Y.TranslationToRef(0,0,-w,a.Matrix[1]),Y.FromValuesToRef(1,0,0,0,0,1,0,0,x,S,1,0,0,0,0,1,a.Matrix[0]),a.Matrix[1].multiplyToRef(a.Matrix[0],a.Matrix[0]),Y.TranslationToRef(0,0,w,a.Matrix[1]),a.Matrix[0].multiplyToRef(a.Matrix[1],a.Matrix[0]),Y.OrthoOffCenterLHToRef(p,b,M,h,Q,mp,t,z),a.Matrix[0].multiplyToRef(t,t),t}static OrthoOffCenterRH(p,b,M,h,Q,mp,y){const P=new Y;return Y.OrthoOffCenterRHToRef(p,b,M,h,Q,mp,P,y),P}static OrthoOffCenterRHToRef(p,b,M,h,Q,mp,y,P){return Y.OrthoOffCenterLHToRef(p,b,M,h,Q,mp,y,P),y.Jb[10]*=-1,y}static ObliqueOffCenterRHToRef(p,b,M,h,Q,mp,y,P,w,t,z){const x=y*Math.cos(P),S=y*Math.sin(P);return Y.TranslationToRef(0,0,w,a.Matrix[1]),Y.FromValuesToRef(1,0,0,0,0,1,0,0,x,S,1,0,0,0,0,1,a.Matrix[0]),a.Matrix[1].multiplyToRef(a.Matrix[0],a.Matrix[0]),Y.TranslationToRef(0,0,-w,a.Matrix[1]),a.Matrix[0].multiplyToRef(a.Matrix[1],a.Matrix[0]),Y.OrthoOffCenterRHToRef(p,b,M,h,Q,mp,t,z),a.Matrix[0].multiplyToRef(t,t),t}static PerspectiveLH(p,b,M,h,Q){let mp=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const y=new Y,P=2*M/p,w=2*M/b,t=(h+M)/(h-M),z=-2*h*M/(h-M),x=Math.tan(mp);return Y.FromValuesToRef(P,0,0,0,0,w,0,x,0,0,t,1,0,0,z,0,y),Q&&y.multiplyToRef(l,y),y._updateIdentityStatus(!1),y}static PerspectiveFovLH(p,b,M,h,Q){let mp=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const P=new Y;return Y.PerspectiveFovLHToRef(p,b,M,h,P,!0,Q,mp,y),P}static PerspectiveFovLHToRef(p,b,M,h,Q){let mp=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,P=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,w=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const t=M,z=h,x=1/Math.tan(.5*p),S=mp?x/b:x,X=mp?x:x*b,c=w&&0===t?-1:0!==z?(z+t)/(z-t):1,J=w&&0===t?2*z:0!==z?-2*z*t/(z-t):-2*t,g=Math.tan(P);return Y.FromValuesToRef(S,0,0,0,0,X,0,g,0,0,c,1,0,0,J,0,Q),y&&Q.multiplyToRef(l,Q),Q._updateIdentityStatus(!1),Q}static PerspectiveFovReverseLHToRef(p,b,M,h,Q){let mp=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,P=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const w=1/Math.tan(.5*p),t=mp?w/b:w,z=mp?w:w*b,x=Math.tan(P);return Y.FromValuesToRef(t,0,0,0,0,z,0,x,0,0,-M,1,0,0,1,0,Q),y&&Q.multiplyToRef(l,Q),Q._updateIdentityStatus(!1),Q}static PerspectiveFovRH(p,b,M,h,Q){let mp=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const P=new Y;return Y.PerspectiveFovRHToRef(p,b,M,h,P,!0,Q,mp,y),P}static PerspectiveFovRHToRef(p,b,M,h,Q){let mp=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,P=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,w=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const t=M,z=h,x=1/Math.tan(.5*p),S=mp?x/b:x,X=mp?x:x*b,c=w&&0===t?1:0!==z?-(z+t)/(z-t):-1,J=w&&0===t?2*z:0!==z?-2*z*t/(z-t):-2*t,g=Math.tan(P);return Y.FromValuesToRef(S,0,0,0,0,X,0,g,0,0,c,-1,0,0,J,0,Q),y&&Q.multiplyToRef(l,Q),Q._updateIdentityStatus(!1),Q}static PerspectiveFovReverseRHToRef(p,b,M,h,Q){let mp=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,P=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const w=1/Math.tan(.5*p),t=mp?w/b:w,z=mp?w:w*b,x=Math.tan(P);return Y.FromValuesToRef(t,0,0,0,0,z,0,x,0,0,-M,-1,0,0,-1,0,Q),y&&Q.multiplyToRef(l,Q),Q._updateIdentityStatus(!1),Q}static GetFinalMatrix(p,b,M,h,Q,mp){const y=p.width,P=p.height,w=p.x,t=p.y,z=Y.FromValues(y/2,0,0,0,0,-P/2,0,0,0,0,mp-Q,0,w+y/2,P/2+t,Q,1),x=new Y;return b.multiplyToRef(M,x),x.multiplyToRef(h,x),x.multiplyToRef(z,x)}static GetAsMatrix2x2(p){const b=p.m,M=[b[0],b[1],b[4],b[5]];return y.d.MatrixUse64Bits?M:new Float32Array(M)}static GetAsMatrix3x3(p){const b=p.m,M=[b[0],b[1],b[2],b[4],b[5],b[6],b[8],b[9],b[10]];return y.d.MatrixUse64Bits?M:new Float32Array(M)}static Transpose(p){const b=new Y;return Y.TransposeToRef(p,b),b}static TransposeToRef(p,b){const M=p.m,h=M[0],Q=M[4],mp=M[8],y=M[12],P=M[1],w=M[5],t=M[9],z=M[13],x=M[2],S=M[6],X=M[10],c=M[14],J=M[3],g=M[7],f=M[11],Y=M[15],a=b.Jb;return a[0]=h,a[1]=Q,a[2]=mp,a[3]=y,a[4]=P,a[5]=w,a[6]=t,a[7]=z,a[8]=x,a[9]=S,a[10]=X,a[11]=c,a[12]=J,a[13]=g,a[14]=f,a[15]=Y,b.markAsUpdated(),b._updateIdentityStatus(p._isIdentity,p._isIdentityDirty),b}static Reflection(p){const b=new Y;return Y.ReflectionToRef(p,b),b}static ReflectionToRef(p,b){p.normalize();const M=p.normal.x,h=p.normal.y,Q=p.normal.z,mp=-2*M,y=-2*h,P=-2*Q;return Y.FromValuesToRef(mp*M+1,y*M,P*M,0,mp*h,y*h+1,P*h,0,mp*Q,y*Q,P*Q+1,0,mp*p.d,y*p.d,P*p.d,1,b),b}static FromXYZAxesToRef(p,b,M,h){return Y.FromValuesToRef(p._x,p._y,p._z,0,b._x,b._y,b._z,0,M._x,M._y,M._z,0,0,0,0,1,h),h}static FromQuaternionToRef(p,b){const M=p._x*p._x,h=p._y*p._y,Q=p._z*p._z,mp=p._x*p._y,y=p._z*p._w,P=p._z*p._x,w=p._y*p._w,t=p._y*p._z,z=p._x*p._w;return b.Jb[0]=1-2*(h+Q),b.Jb[1]=2*(mp+y),b.Jb[2]=2*(P-w),b.Jb[3]=0,b.Jb[4]=2*(mp-y),b.Jb[5]=1-2*(Q+M),b.Jb[6]=2*(t+z),b.Jb[7]=0,b.Jb[8]=2*(P+w),b.Jb[9]=2*(t-z),b.Jb[10]=1-2*(h+M),b.Jb[11]=0,b.Jb[12]=0,b.Jb[13]=0,b.Jb[14]=0,b.Jb[15]=1,b.markAsUpdated(),b}}Y._IdentityReadOnly=Y.Identity(),Object.defineProperties(Y.prototype,{dimension:{value:[4,4]},rank:{value:2}});class a{}a.QM=(0,Q.i)(11,J.Zero),a.Matrix=(0,Q.i)(2,Y.Identity),a.Quaternion=(0,Q.i)(3,f.Zero);class o{}o.Vector2=(0,Q.i)(3,c.Zero),o.QM=(0,Q.i)(13,J.Zero),o.Vector4=(0,Q.i)(3,g.Zero),o.Quaternion=(0,Q.i)(3,f.Zero),o.Matrix=(0,Q.i)(8,Y.Identity),(0,mp.c)("BABYLON.Vector2",c),(0,mp.c)("BABYLON.Vector3",J),(0,mp.c)("BABYLON.Vector4",g),(0,mp.c)("BABYLON.Matrix",Y);const l=Y.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12785:(p,b,M)=>{function h(p,b){const M=[];for(let h=0;h<p;++h)M.push(b());return M}function Q(p,b){return h(p,b)}M.d(b,{e:()=>h,i:()=>Q,j:()=>y});const mp=["push","splice","pop","shift","unshift"];function y(p,b){const M=mp.map((M=>function(p,b,M){const h=p[b];if("function"!==typeof h)return null;const Q=function(){const h=p.length,mp=Q.previous.apply(p,arguments);return M(b,h),mp};return h.next=Q,Q.previous=h,p[b]=Q,()=>{const M=Q.previous;if(!M)return;const h=Q.next;h?(M.next=h,h.previous=M):(M.next=void 0,p[b]=M),Q.next=void 0,Q.previous=void 0}}(p,M,b)));return()=>{for(const p of M)null===p||void 0===p||p()}}}}]);