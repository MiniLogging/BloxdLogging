"use strict";(self.hwpa2z1pqte=self.hwpa2z1pqte||[]).push([[14],{12902:(h,R,l)=>{l.d(R,{d:()=>U,h:()=>D,i:()=>j,j:()=>a});const j=1/2.2,a=2.2,D=(1+Math.sqrt(5))/2,U=.001},12917:(h,R,l)=>{function j(h){return parseInt(h.toString().replace(/\W/g,""))}function a(h,R){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(h-R)<=l}function D(h,R,l){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return h<R-j||h>l+j}function U(h,R){return h===R?h:Math.random()*(R-h)+h}function F(h,R,l){return h+(R-h)*l}function w(h,R,l){let j=s(R-h,360);return j>180&&(j-=360),h+j*J(l)}function mh(h,R,l){let j=0;return j=h!=R?J((l-h)/(R-h)):0,j}function u(h,R,l,j,a){const D=a*a,U=a*D;return h*(2*U-3*D+1)+l*(-2*U+3*D)+R*(U-2*D+a)+j*(U-D)}function c(h,R,l,j,a){const D=a*a;return 6*(D-a)*h+(3*D-4*a+1)*R+6*(-D+a)*l+(3*D-2*a)*j}function J(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(l,Math.max(R,h))}function q(h){return h-=2*Math.PI*Math.floor((h+Math.PI)/(2*Math.PI))}function Q(h){const R=h.toString(16);return h<=15?("0"+R).toUpperCase():R.toUpperCase()}function Y(h){if(Math.log2)return Math.floor(Math.log2(h));if(h<0)return NaN;if(0===h)return-1/0;let R=0;if(h<1){for(;h<1;)R++,h*=2;R=-R}else if(h>1)for(;h>1;)R++,h=Math.floor(h/2);return R}function s(h,R){return h-Math.floor(h/R)*R}function t(h,R,l){return(h-R)/(l-R)}function f(h,R,l){return h*(l-R)+R}function T(h,R){let l=s(R-h,360);return l>180&&(l-=360),l}function E(h,R){const l=s(h,2*R);return R-Math.abs(l-R)}function x(h,R,l){let j=J(l);return j=-2*j*j*j+3*j*j,R*j+h*(1-j)}function G(h,R,l){let j=0;return j=Math.abs(R-h)<=l?R:h+Math.sign(R-h)*l,j}function p(h,R,l){const j=T(h,R);let a=0;return a=-l<j&&j<l?R:G(h,R=h+j,l),a}function O(h,R,l){return(h-R)/(l-R)}function y(h,R,l){return(l-R)*h+R}function v(h,R){const l=h%R;return 0===l?R:v(R,l)}l.r(R),l.d(R,{Clamp:()=>J,DeltaAngle:()=>T,Denormalize:()=>f,ExtractAsInt:()=>j,Hermite:()=>u,Hermite1stDerivative:()=>c,HighestCommonFactor:()=>v,ILog2:()=>Y,InverseLerp:()=>mh,Lerp:()=>F,LerpAngle:()=>w,MoveTowards:()=>G,MoveTowardsAngle:()=>p,Normalize:()=>t,NormalizeRadians:()=>q,OutsideRange:()=>D,PercentToRange:()=>y,PingPong:()=>E,RandomRange:()=>U,RangeToPercent:()=>O,Repeat:()=>s,SmoothStep:()=>x,ToHex:()=>Q,WithinEpsilon:()=>a})},12900:(h,R,l)=>{l.r(R),l.d(R,{Matrix:()=>f,Quaternion:()=>t,TmpVectors:()=>E,Vector2:()=>Q,tR:()=>Y,Vector4:()=>s});var j=l(12902),a=l(12910),D=l(12852),U=l(12829),F=l(12749),w=l(12917);class mh{}function u(h,R,l){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a=h.sF(),D=R.sF(),U=a[0],F=a[1],w=a[2],mh=a[3],u=a[4],c=a[5],J=a[6],q=a[7],Q=a[8],Y=a[9],s=a[10],t=a[11],f=a[12],T=a[13],E=a[14],x=a[15],G=D[0],p=D[1],O=D[2],y=D[3],v=D[4],b=D[5],I=D[6],L=D[7],n=D[8],r=D[9],P=D[10],z=D[11],o=D[12],K=D[13],W=D[14],g=D[15];l[j]=U*G+F*v+w*n+mh*o,l[j+1]=U*p+F*b+w*r+mh*K,l[j+2]=U*O+F*I+w*P+mh*W,l[j+3]=U*y+F*L+w*z+mh*g,l[j+4]=u*G+c*v+J*n+q*o,l[j+5]=u*p+c*b+J*r+q*K,l[j+6]=u*O+c*I+J*P+q*W,l[j+7]=u*y+c*L+J*z+q*g,l[j+8]=Q*G+Y*v+s*n+t*o,l[j+9]=Q*p+Y*b+s*r+t*K,l[j+10]=Q*O+Y*I+s*P+t*W,l[j+11]=Q*y+Y*L+s*z+t*g,l[j+12]=f*G+T*v+E*n+x*o,l[j+13]=f*p+T*b+E*r+x*K,l[j+14]=f*O+T*I+E*P+x*W,l[j+15]=f*y+T*L+E*z+x*g}function c(h,R){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const j=h.sF();R[l]=j[0],R[l+1]=j[1],R[l+2]=j[2],R[l+3]=j[3],R[l+4]=j[4],R[l+5]=j[5],R[l+6]=j[6],R[l+7]=j[7],R[l+8]=j[8],R[l+9]=j[9],R[l+10]=j[10],R[l+11]=j[11],R[l+12]=j[12],R[l+13]=j[13],R[l+14]=j[14],R[l+15]=j[15]}function J(h,R){const l=h.sF(),j=l[0],a=l[1],D=l[2],U=l[3],F=l[4],w=l[5],mh=l[6],u=l[7],c=l[8],J=l[9],q=l[10],Q=l[11],Y=l[12],s=l[13],t=l[14],f=l[15],T=q*f-t*Q,E=J*f-s*Q,x=J*t-s*q,G=c*f-Y*Q,p=c*t-q*Y,O=c*s-Y*J,y=+(w*T-mh*E+u*x),v=-(F*T-mh*G+u*p),b=+(F*E-w*G+u*O),I=-(F*x-w*p+mh*O),L=j*y+a*v+D*b+U*I;if(0===L)return!1;const n=1/L,r=mh*f-t*u,P=w*f-s*u,z=w*t-s*mh,o=F*f-Y*u,K=F*t-Y*mh,W=F*s-Y*w,g=mh*Q-q*u,H=w*Q-J*u,k=w*q-J*mh,C=F*Q-c*u,A=F*q-c*mh,e=F*J-c*w,S=-(a*T-D*E+U*x),Z=+(j*T-D*G+U*p),M=-(j*E-a*G+U*O),i=+(j*x-a*p+D*O),d=+(a*r-D*P+U*z),X=-(j*r-D*o+U*K),V=+(j*P-a*o+U*W),B=-(j*z-a*K+D*W),N=-(a*g-D*H+U*k),hh=+(j*g-D*C+U*A),Rh=-(j*H-a*C+U*e),lh=+(j*k-a*A+D*e);return R[0]=y*n,R[1]=S*n,R[2]=d*n,R[3]=N*n,R[4]=v*n,R[5]=Z*n,R[6]=X*n,R[7]=hh*n,R[8]=b*n,R[9]=M*n,R[10]=V*n,R[11]=Rh*n,R[12]=I*n,R[13]=i*n,R[14]=B*n,R[15]=lh*n,!0}mh._UpdateFlagSeed=0;const q=h=>parseInt(h.toString().replace(/\W/g,""));class Q{constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=h,this.y=R}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let h=q(this.x);return h=397*h^q(this.y),h}toArray(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[R]=this.x,h[R+1]=this.y,this}Yl(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(h,R,this),this}sF(){return[this.x,this.y]}D(h){return this.x=h.x,this.y=h.y,this}OF(h,R){return this.x=h,this.y=R,this}set(h,R){return this.OF(h,R)}vF(h){return this.OF(h,h)}add(h){return new Q(this.x+h.x,this.y+h.y)}addToRef(h,R){return R.x=this.x+h.x,R.y=this.y+h.y,R}addInPlace(h){return this.x+=h.x,this.y+=h.y,this}addInPlaceFromFloats(h,R){return this.x+=h,this.y+=R,this}addVector3(h){return new Q(this.x+h.x,this.y+h.y)}fR(h){return new Q(this.x-h.x,this.y-h.y)}subtractToRef(h,R){return R.x=this.x-h.x,R.y=this.y-h.y,R}Pc(h){return this.x-=h.x,this.y-=h.y,this}multiplyInPlace(h){return this.x*=h.x,this.y*=h.y,this}multiply(h){return new Q(this.x*h.x,this.y*h.y)}multiplyToRef(h,R){return R.x=this.x*h.x,R.y=this.y*h.y,R}multiplyByFloats(h,R){return new Q(this.x*h,this.y*R)}divide(h){return new Q(this.x/h.x,this.y/h.y)}divideToRef(h,R){return R.x=this.x/h.x,R.y=this.y/h.y,R}divideInPlace(h){return this.x=this.x/h.x,this.y=this.y/h.y,this}minimizeInPlace(h){return this.minimizeInPlaceFromFloats(h.x,h.y)}maximizeInPlace(h){return this.maximizeInPlaceFromFloats(h.x,h.y)}minimizeInPlaceFromFloats(h,R){return this.x=Math.min(h,this.x),this.y=Math.min(R,this.y),this}maximizeInPlaceFromFloats(h,R){return this.x=Math.max(h,this.x),this.y=Math.max(R,this.y),this}subtractFromFloats(h,R){return new Q(this.x-h,this.y-R)}subtractFromFloatsToRef(h,R,l){return l.x=this.x-h,l.y=this.y-R,l}negate(){return new Q(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(h){return h.x=-this.x,h.y=-this.y,h}scaleInPlace(h){return this.x*=h,this.y*=h,this}scale(h){return new Q(this.x*h,this.y*h)}scaleToRef(h,R){return R.x=this.x*h,R.y=this.y*h,R}scaleAndAddToRef(h,R){return R.x+=this.x*h,R.y+=this.y*h,R}equals(h){return h&&this.x===h.x&&this.y===h.y}equalsWithEpsilon(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return h&&(0,w.WithinEpsilon)(this.x,h.x,R)&&(0,w.WithinEpsilon)(this.y,h.y,R)}equalsToFloats(h,R){return this.x===h&&this.y===R}floor(){return new Q(Math.floor(this.x),Math.floor(this.y))}floorToRef(h){return h.x=Math.floor(this.x),h.y=Math.floor(this.y),h}fract(){return new Q(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(h){return h.x=this.x-Math.floor(this.x),h.y=this.y-Math.floor(this.y),h}rotate(h){return this.rotateToRef(h,new Q)}rotateToRef(h,R){const l=Math.cos(h),j=Math.sin(h);return R.x=l*this.x-j*this.y,R.y=j*this.x+l*this.y,R}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){const h=new Q;return this.normalizeToRef(h),h}normalizeToRef(h){const R=this.length();return 0===R&&(h.x=this.x,h.y=this.y),this.scaleToRef(1/R,h)}clone(){return new Q(this.x,this.y)}dot(h){return this.x*h.x+this.y*h.y}static Zero(){return new Q(0,0)}static One(){return new Q(1,1)}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Q((0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).OF((0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R))}static get ZeroReadOnly(){return Q._ZeroReadOnly}static GR(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(h[R],h[R+1])}static FromArrayToRef(h,R,l){return l.x=h[R],l.y=h[R+1],l}static FromFloatsToRef(h,R,l){return l.OF(h,R),l}static CatmullRom(h,R,l,j,a){const D=a*a,U=a*D,F=.5*(2*R.x+(-h.x+l.x)*a+(2*h.x-5*R.x+4*l.x-j.x)*D+(-h.x+3*R.x-3*l.x+j.x)*U),w=.5*(2*R.y+(-h.y+l.y)*a+(2*h.y-5*R.y+4*l.y-j.y)*D+(-h.y+3*R.y-3*l.y+j.y)*U);return new Q(F,w)}static ClampToRef(h,R,l,j){return j.x=(0,w.Clamp)(h.x,R.x,l.x),j.y=(0,w.Clamp)(h.y,R.y,l.y),j}static Clamp(h,R,l){const j=(0,w.Clamp)(h.x,R.x,l.x),a=(0,w.Clamp)(h.y,R.y,l.y);return new Q(j,a)}static Hermite(h,R,l,j,a){const D=a*a,U=a*D,F=2*U-3*D+1,w=-2*U+3*D,mh=U-2*D+a,u=U-D,c=h.x*F+l.x*w+R.x*mh+j.x*u,J=h.y*F+l.y*w+R.y*mh+j.y*u;return new Q(c,J)}static Hermite1stDerivative(h,R,l,j,a){return this.Hermite1stDerivativeToRef(h,R,l,j,a,new Q)}static Hermite1stDerivativeToRef(h,R,l,j,a,D){const U=a*a;return D.x=6*(U-a)*h.x+(3*U-4*a+1)*R.x+6*(-U+a)*l.x+(3*U-2*a)*j.x,D.y=6*(U-a)*h.y+(3*U-4*a+1)*R.y+6*(-U+a)*l.y+(3*U-2*a)*j.y,D}static Lerp(h,R,l){return Q.LerpToRef(h,R,l,new Q)}static LerpToRef(h,R,l,j){return j.x=h.x+(R.x-h.x)*l,j.y=h.y+(R.y-h.y)*l,j}static Dot(h,R){return h.x*R.x+h.y*R.y}static Normalize(h){return Q.NormalizeToRef(h,new Q)}static NormalizeToRef(h,R){return h.normalizeToRef(R),R}static Minimize(h,R){const l=h.x<R.x?h.x:R.x,j=h.y<R.y?h.y:R.y;return new Q(l,j)}static Maximize(h,R){const l=h.x>R.x?h.x:R.x,j=h.y>R.y?h.y:R.y;return new Q(l,j)}static Transform(h,R){return Q.TransformToRef(h,R,new Q)}static TransformToRef(h,R,l){const j=R.m,a=h.x*j[0]+h.y*j[4]+j[12],D=h.x*j[1]+h.y*j[5]+j[13];return l.x=a,l.y=D,l}static PointInTriangle(h,R,l,j){const a=.5*(-l.y*j.x+R.y*(-l.x+j.x)+R.x*(l.y-j.y)+l.x*j.y),D=a<0?-1:1,U=(R.y*j.x-R.x*j.y+(j.y-R.y)*h.x+(R.x-j.x)*h.y)*D,F=(R.x*l.y-R.y*l.x+(R.y-l.y)*h.x+(l.x-R.x)*h.y)*D;return U>0&&F>0&&U+F<2*a*D}static Distance(h,R){return Math.sqrt(Q.DistanceSquared(h,R))}static DistanceSquared(h,R){const l=h.x-R.x,j=h.y-R.y;return l*l+j*j}static Center(h,R){return Q.CenterToRef(h,R,new Q)}static CenterToRef(h,R,l){return l.OF((h.x+R.x)/2,(h.y+R.y)/2)}static DistanceOfPointFromSegment(h,R,l){const j=Q.DistanceSquared(R,l);if(0===j)return Q.Distance(h,R);const a=l.fR(R),D=Math.max(0,Math.min(1,Q.Dot(h.fR(R),a)/j)),U=R.add(a.multiplyByFloats(D,D));return Q.Distance(h,U)}}Q._V8PerformanceHack=new Q(.5,.5),Q._ZeroReadOnly=Q.Zero(),Object.defineProperties(Q.prototype,{dimension:{value:[2]},rank:{value:1}});class Y{get x(){return this._x}set x(h){this._x=h,this._isDirty=!0}get y(){return this._y}set y(h){this._y=h,this._isDirty=!0}get z(){return this._z}set z(h){this._z=h,this._isDirty=!0}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=h,this._y=R,this._z=l}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"tR"}getHashCode(){let h=q(this._x);return h=397*h^q(this._y),h=397*h^q(this._z),h}sF(){return[this._x,this._y,this._z]}toArray(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[R]=this._x,h[R+1]=this._y,h[R+2]=this._z,this}Yl(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y.FromArrayToRef(h,R,this),this}toQuaternion(){return t.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(h){return this._x+=h._x,this._y+=h._y,this._z+=h._z,this._isDirty=!0,this}addInPlaceFromFloats(h,R,l){return this._x+=h,this._y+=R,this._z+=l,this._isDirty=!0,this}add(h){return new Y(this._x+h._x,this._y+h._y,this._z+h._z)}addToRef(h,R){return R._x=this._x+h._x,R._y=this._y+h._y,R._z=this._z+h._z,R._isDirty=!0,R}Pc(h){return this._x-=h._x,this._y-=h._y,this._z-=h._z,this._isDirty=!0,this}fR(h){return new Y(this._x-h._x,this._y-h._y,this._z-h._z)}subtractToRef(h,R){return this.subtractFromFloatsToRef(h._x,h._y,h._z,R)}subtractFromFloats(h,R,l){return new Y(this._x-h,this._y-R,this._z-l)}subtractFromFloatsToRef(h,R,l,j){return j._x=this._x-h,j._y=this._y-R,j._z=this._z-l,j._isDirty=!0,j}negate(){return new Y(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(h){return h._x=-1*this._x,h._y=-1*this._y,h._z=-1*this._z,h._isDirty=!0,h}scaleInPlace(h){return this._x*=h,this._y*=h,this._z*=h,this._isDirty=!0,this}scale(h){return new Y(this._x*h,this._y*h,this._z*h)}scaleToRef(h,R){return R._x=this._x*h,R._y=this._y*h,R._z=this._z*h,R._isDirty=!0,R}getNormalToRef(h){const R=this.length();let l=Math.acos(this._y/R);const j=Math.atan2(this._z,this._x);l>Math.PI/2?l-=Math.PI/2:l+=Math.PI/2;const a=R*Math.sin(l)*Math.cos(j),D=R*Math.cos(l),U=R*Math.sin(l)*Math.sin(j);return h.set(a,D,U),h}applyRotationQuaternionToRef(h,R){const l=this._x,j=this._y,a=this._z,D=h._x,U=h._y,F=h._z,w=h._w,mh=2*(U*a-F*j),u=2*(F*l-D*a),c=2*(D*j-U*l);return R._x=l+w*mh+U*c-F*u,R._y=j+w*u+F*mh-D*c,R._z=a+w*c+D*u-U*mh,R._isDirty=!0,R}applyRotationQuaternionInPlace(h){return this.applyRotationQuaternionToRef(h,this)}applyRotationQuaternion(h){return this.applyRotationQuaternionToRef(h,new Y)}scaleAndAddToRef(h,R){return R._x+=this._x*h,R._y+=this._y*h,R._z+=this._z*h,R._isDirty=!0,R}projectOnPlane(h,R){return this.projectOnPlaneToRef(h,R,new Y)}projectOnPlaneToRef(h,R,l){const j=h.normal,a=h.d,D=T.tR[0];this.subtractToRef(R,D),D.normalize();const U=Y.Dot(D,j);if(Math.abs(U)<1e-10)l.vF(1/0);else{const h=-(Y.Dot(R,j)+a)/U,F=D.scaleInPlace(h);R.addToRef(F,l)}return l}equals(h){return h&&this._x===h._x&&this._y===h._y&&this._z===h._z}equalsWithEpsilon(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return h&&(0,w.WithinEpsilon)(this._x,h._x,R)&&(0,w.WithinEpsilon)(this._y,h._y,R)&&(0,w.WithinEpsilon)(this._z,h._z,R)}equalsToFloats(h,R,l){return this._x===h&&this._y===R&&this._z===l}multiplyInPlace(h){return this._x*=h._x,this._y*=h._y,this._z*=h._z,this._isDirty=!0,this}multiply(h){return this.multiplyByFloats(h._x,h._y,h._z)}multiplyToRef(h,R){return R._x=this._x*h._x,R._y=this._y*h._y,R._z=this._z*h._z,R._isDirty=!0,R}multiplyByFloats(h,R,l){return new Y(this._x*h,this._y*R,this._z*l)}divide(h){return new Y(this._x/h._x,this._y/h._y,this._z/h._z)}divideToRef(h,R){return R._x=this._x/h._x,R._y=this._y/h._y,R._z=this._z/h._z,R._isDirty=!0,R}divideInPlace(h){return this._x=this._x/h._x,this._y=this._y/h._y,this._z=this._z/h._z,this._isDirty=!0,this}minimizeInPlace(h){return this.minimizeInPlaceFromFloats(h._x,h._y,h._z)}maximizeInPlace(h){return this.maximizeInPlaceFromFloats(h._x,h._y,h._z)}minimizeInPlaceFromFloats(h,R,l){return h<this._x&&(this.x=h),R<this._y&&(this.y=R),l<this._z&&(this.z=l),this}maximizeInPlaceFromFloats(h,R,l){return h>this._x&&(this.x=h),R>this._y&&(this.y=R),l>this._z&&(this.z=l),this}isNonUniformWithinEpsilon(h){const R=Math.abs(this._x),l=Math.abs(this._y);if(!(0,w.WithinEpsilon)(R,l,h))return!0;const j=Math.abs(this._z);return!(0,w.WithinEpsilon)(R,j,h)||!(0,w.WithinEpsilon)(l,j,h)}get isNonUniform(){const h=Math.abs(this._x);if(h!==Math.abs(this._y))return!0;return h!==Math.abs(this._z)}floorToRef(h){return h._x=Math.floor(this._x),h._y=Math.floor(this._y),h._z=Math.floor(this._z),h._isDirty=!0,h}floor(){return new Y(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(h){return h._x=this._x-Math.floor(this._x),h._y=this._y-Math.floor(this._y),h._z=this._z-Math.floor(this._z),h._isDirty=!0,h}fract(){return new Y(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(h){if("xyz"===(h=h.toLowerCase()))return this;const R=T.tR[0].D(this);return this.x=R[h[0]],this.y=R[h[1]],this.z=R[h[2]],this}rotateByQuaternionToRef(h,R){return h.toRotationMatrix(T.Matrix[0]),Y.TransformCoordinatesToRef(this,T.Matrix[0],R),R}rotateByQuaternionAroundPointToRef(h,R,l){return this.subtractToRef(R,T.tR[0]),T.tR[0].rotateByQuaternionToRef(h,T.tR[0]),R.addToRef(T.tR[0],l),l}cross(h){return Y.CrossToRef(this,h,new Y)}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){return this.normalizeToRef(new Y)}normalizeToRef(h){const R=this.length();return 0===R||1===R?(h._x=this._x,h._y=this._y,h._z=this._z,h._isDirty=!0,h):this.scaleToRef(1/R,h)}clone(){return new Y(this._x,this._y,this._z)}D(h){return this.OF(h._x,h._y,h._z)}OF(h,R,l){return this._x=h,this._y=R,this._z=l,this._isDirty=!0,this}set(h,R,l){return this.OF(h,R,l)}vF(h){return this._x=this._y=this._z=h,this._isDirty=!0,this}static GetClipFactor(h,R,l,j){const a=Y.Dot(h,l);return(a-j)/(a-Y.Dot(R,l))}static GetAngleBetweenVectors(h,R,l){const j=h.normalizeToRef(T.tR[1]),a=R.normalizeToRef(T.tR[2]);let D=Y.Dot(j,a);D=(0,w.Clamp)(D,-1,1);const U=Math.acos(D),F=T.tR[3];return Y.CrossToRef(j,a,F),Y.Dot(F,l)>0?isNaN(U)?0:U:isNaN(U)?-Math.PI:-Math.acos(D)}static GetAngleBetweenVectorsOnPlane(h,R,l){T.tR[0].D(h);const j=T.tR[0];T.tR[1].D(R);const a=T.tR[1];T.tR[2].D(l);const D=T.tR[2],U=T.tR[3],F=T.tR[4];j.normalize(),a.normalize(),D.normalize(),Y.CrossToRef(D,j,U),Y.CrossToRef(U,D,F);const mh=Math.atan2(Y.Dot(a,U),Y.Dot(a,F));return(0,w.NormalizeRadians)(mh)}static PitchYawRollToMoveBetweenPointsToRef(h,R,l){const j=E.tR[0];return R.subtractToRef(h,j),l._y=Math.atan2(j.x,j.z)||0,l._x=Math.atan2(Math.sqrt(j.x**2+j.z**2),j.y)||0,l._z=0,l._isDirty=!0,l}static PitchYawRollToMoveBetweenPoints(h,R){const l=Y.Zero();return Y.PitchYawRollToMoveBetweenPointsToRef(h,R,l)}static SlerpToRef(h,R,l,a){l=(0,w.Clamp)(l,0,1);const D=T.tR[0],U=T.tR[1];D.D(h);const F=D.length();D.normalizeFromLength(F),U.D(R);const mh=U.length();U.normalizeFromLength(mh);const u=Y.Dot(D,U);let c,J;if(u<1-j.d){const h=Math.acos(u),R=1/Math.sin(h);c=Math.sin((1-l)*h)*R,J=Math.sin(l*h)*R}else c=1-l,J=l;return D.scaleInPlace(c),U.scaleInPlace(J),a.D(D).addInPlace(U),a.scaleInPlace((0,w.Lerp)(F,mh,l)),a}static SmoothToRef(h,R,l,j,a){return Y.SlerpToRef(h,R,0===j?1:l/j,a),a}static GR(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Y(h[R],h[R+1],h[R+2])}static FromFloatArray(h,R){return Y.GR(h,R)}static FromArrayToRef(h,R,l){return l._x=h[R],l._y=h[R+1],l._z=h[R+2],l._isDirty=!0,l}static FromFloatArrayToRef(h,R,l){return Y.FromArrayToRef(h,R,l)}static FromFloatsToRef(h,R,l,j){return j.OF(h,R,l),j}static Zero(){return new Y(0,0,0)}static One(){return new Y(1,1,1)}static Up(){return new Y(0,1,0)}static get UpReadOnly(){return Y._UpReadOnly}static get DownReadOnly(){return Y._DownReadOnly}static get RightReadOnly(){return Y._RightReadOnly}static get LeftReadOnly(){return Y._LeftReadOnly}static get LeftHandedForwardReadOnly(){return Y._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return Y._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return Y._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return Y._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return Y._ZeroReadOnly}static get OneReadOnly(){return Y._OneReadOnly}static Down(){return new Y(0,-1,0)}static Forward(){return new Y(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new Y(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new Y(1,0,0)}static Left(){return new Y(-1,0,0)}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Y((0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).OF((0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R))}static TransformCoordinates(h,R){const l=Y.Zero();return Y.TransformCoordinatesToRef(h,R,l),l}static TransformCoordinatesToRef(h,R,l){return Y.TransformCoordinatesFromFloatsToRef(h._x,h._y,h._z,R,l),l}static TransformCoordinatesFromFloatsToRef(h,R,l,j,a){const D=j.m,U=h*D[0]+R*D[4]+l*D[8]+D[12],F=h*D[1]+R*D[5]+l*D[9]+D[13],w=h*D[2]+R*D[6]+l*D[10]+D[14],mh=1/(h*D[3]+R*D[7]+l*D[11]+D[15]);return a._x=U*mh,a._y=F*mh,a._z=w*mh,a._isDirty=!0,a}static TransformNormal(h,R){const l=Y.Zero();return Y.TransformNormalToRef(h,R,l),l}static TransformNormalToRef(h,R,l){return this.TransformNormalFromFloatsToRef(h._x,h._y,h._z,R,l),l}static TransformNormalFromFloatsToRef(h,R,l,j,a){const D=j.m;return a._x=h*D[0]+R*D[4]+l*D[8],a._y=h*D[1]+R*D[5]+l*D[9],a._z=h*D[2]+R*D[6]+l*D[10],a._isDirty=!0,a}static CatmullRom(h,R,l,j,a){const D=a*a,U=a*D,F=.5*(2*R._x+(-h._x+l._x)*a+(2*h._x-5*R._x+4*l._x-j._x)*D+(-h._x+3*R._x-3*l._x+j._x)*U),w=.5*(2*R._y+(-h._y+l._y)*a+(2*h._y-5*R._y+4*l._y-j._y)*D+(-h._y+3*R._y-3*l._y+j._y)*U),mh=.5*(2*R._z+(-h._z+l._z)*a+(2*h._z-5*R._z+4*l._z-j._z)*D+(-h._z+3*R._z-3*l._z+j._z)*U);return new Y(F,w,mh)}static Clamp(h,R,l){const j=new Y;return Y.ClampToRef(h,R,l,j),j}static ClampToRef(h,R,l,j){let a=h._x;a=a>l._x?l._x:a,a=a<R._x?R._x:a;let D=h._y;D=D>l._y?l._y:D,D=D<R._y?R._y:D;let U=h._z;return U=U>l._z?l._z:U,U=U<R._z?R._z:U,j.OF(a,D,U),j}static CheckExtends(h,R,l){R.minimizeInPlace(h),l.maximizeInPlace(h)}static Hermite(h,R,l,j,a){const D=a*a,U=a*D,F=2*U-3*D+1,w=-2*U+3*D,mh=U-2*D+a,u=U-D,c=h._x*F+l._x*w+R._x*mh+j._x*u,J=h._y*F+l._y*w+R._y*mh+j._y*u,q=h._z*F+l._z*w+R._z*mh+j._z*u;return new Y(c,J,q)}static Hermite1stDerivative(h,R,l,j,a){const D=new Y;return this.Hermite1stDerivativeToRef(h,R,l,j,a,D),D}static Hermite1stDerivativeToRef(h,R,l,j,a,D){const U=a*a;return D._x=6*(U-a)*h._x+(3*U-4*a+1)*R._x+6*(-U+a)*l._x+(3*U-2*a)*j._x,D._y=6*(U-a)*h._y+(3*U-4*a+1)*R._y+6*(-U+a)*l._y+(3*U-2*a)*j._y,D._z=6*(U-a)*h._z+(3*U-4*a+1)*R._z+6*(-U+a)*l._z+(3*U-2*a)*j._z,D._isDirty=!0,D}static Lerp(h,R,l){const j=new Y(0,0,0);return Y.LerpToRef(h,R,l,j),j}static LerpToRef(h,R,l,j){return j._x=h._x+(R._x-h._x)*l,j._y=h._y+(R._y-h._y)*l,j._z=h._z+(R._z-h._z)*l,j._isDirty=!0,j}static Dot(h,R){return h._x*R._x+h._y*R._y+h._z*R._z}dot(h){return this._x*h._x+this._y*h._y+this._z*h._z}static Cross(h,R){const l=new Y;return Y.CrossToRef(h,R,l),l}static CrossToRef(h,R,l){const j=h._y*R._z-h._z*R._y,a=h._z*R._x-h._x*R._z,D=h._x*R._y-h._y*R._x;return l.OF(j,a,D),l}static Normalize(h){const R=Y.Zero();return Y.NormalizeToRef(h,R),R}static NormalizeToRef(h,R){return h.normalizeToRef(R),R}static Project(h,R,l,j){const a=new Y;return Y.ProjectToRef(h,R,l,j,a),a}static ProjectToRef(h,R,l,j,a){var D;const U=j.width,w=j.height,mh=j.x,u=j.y,c=T.Matrix[1],J=null===(D=F.b.LastCreatedEngine)||void 0===D?void 0:D.isNDCHalfZRange,q=J?1:.5,Q=J?0:.5;f.FromValuesToRef(U/2,0,0,0,0,-w/2,0,0,0,0,q,0,mh+U/2,w/2+u,Q,1,c);const s=T.Matrix[0];return R.multiplyToRef(l,s),s.multiplyToRef(c,s),Y.TransformCoordinatesToRef(h,s,a),a}static Reflect(h,R){return this.ReflectToRef(h,R,new Y)}static ReflectToRef(h,R,l){const j=E.tR[0];return j.D(R).scaleInPlace(2*Y.Dot(h,R)),l.D(h).Pc(j)}static _UnprojectFromInvertedMatrixToRef(h,R,l){Y.TransformCoordinatesToRef(h,R,l);const j=R.m,a=h._x*j[3]+h._y*j[7]+h._z*j[11]+j[15];return(0,w.WithinEpsilon)(a,1)&&l.scaleInPlace(1/a),l}static UnprojectFromTransform(h,R,l,j,a){return this.Unproject(h,R,l,j,a,f.IdentityReadOnly)}static Unproject(h,R,l,j,a,D){const U=new Y;return Y.UnprojectToRef(h,R,l,j,a,D,U),U}static UnprojectToRef(h,R,l,j,a,D,U){return Y.UnprojectFloatsToRef(h._x,h._y,h._z,R,l,j,a,D,U),U}static UnprojectFloatsToRef(h,R,l,j,a,D,U,w,mh){var u;const c=T.Matrix[0];D.multiplyToRef(U,c),c.multiplyToRef(w,c),c.invert();const J=T.tR[0];return J.x=h/j*2-1,J.y=-(R/a*2-1),null!==(u=F.b.LastCreatedEngine)&&void 0!==u&&u.isNDCHalfZRange?J.z=l:J.z=2*l-1,Y._UnprojectFromInvertedMatrixToRef(J,c,mh),mh}static Minimize(h,R){const l=new Y;return l.D(h),l.minimizeInPlace(R),l}static Maximize(h,R){const l=new Y;return l.D(h),l.maximizeInPlace(R),l}static Distance(h,R){return Math.sqrt(Y.DistanceSquared(h,R))}static DistanceSquared(h,R){const l=h._x-R._x,j=h._y-R._y,a=h._z-R._z;return l*l+j*j+a*a}static ProjectOnTriangleToRef(h,R,l,a,D){const U=T.tR[0],F=T.tR[1],mh=T.tR[2],u=T.tR[3],c=T.tR[4];l.subtractToRef(R,U),a.subtractToRef(R,F),a.subtractToRef(l,mh);const J=U.length(),q=F.length(),Q=mh.length();if(J<j.d||q<j.d||Q<j.d)return D.D(R),Y.Distance(h,R);h.subtractToRef(R,c),Y.CrossToRef(U,F,u);const s=u.length();if(s<j.d)return D.D(R),Y.Distance(h,R);u.normalizeFromLength(s);let t=c.length();if(t<j.d)return D.D(R),0;c.normalizeFromLength(t);const f=Y.Dot(u,c),E=T.tR[5],x=T.tR[6];E.D(u).scaleInPlace(-t*f),x.D(h).addInPlace(E);const G=T.tR[4],p=T.tR[5],O=T.tR[7],y=T.tR[8];G.D(U).scaleInPlace(1/J),y.D(F).scaleInPlace(1/q),G.addInPlace(y).scaleInPlace(-1),p.D(U).scaleInPlace(-1/J),y.D(mh).scaleInPlace(1/Q),p.addInPlace(y).scaleInPlace(-1),O.D(mh).scaleInPlace(-1/Q),y.D(F).scaleInPlace(-1/q),O.addInPlace(y).scaleInPlace(-1);const v=T.tR[9];let b;v.D(x).Pc(R),Y.CrossToRef(G,v,y),b=Y.Dot(y,u);const I=b;v.D(x).Pc(l),Y.CrossToRef(p,v,y),b=Y.Dot(y,u);const L=b;v.D(x).Pc(a),Y.CrossToRef(O,v,y),b=Y.Dot(y,u);const n=b,r=T.tR[10];let P,z;I>0&&L<0?(r.D(U),P=R,z=l):L>0&&n<0?(r.D(mh),P=l,z=a):(r.D(F).scaleInPlace(-1),P=a,z=R);const o=T.tR[9],K=T.tR[4];P.subtractToRef(x,y),z.subtractToRef(x,o),Y.CrossToRef(y,o,K);if(!(Y.Dot(K,u)<0))return D.D(x),Math.abs(t*f);const W=T.tR[5];Y.CrossToRef(r,K,W),W.normalize();const g=T.tR[9];g.D(P).Pc(x);const H=g.length();if(H<j.d)return D.D(P),Y.Distance(h,P);g.normalizeFromLength(H);const k=Y.Dot(W,g),C=T.tR[7];C.D(x).addInPlace(W.scaleInPlace(H*k)),y.D(C).Pc(P),t=r.length(),r.normalizeFromLength(t);let A=Y.Dot(y,r)/Math.max(t,j.d);return A=(0,w.Clamp)(A,0,1),C.D(P).addInPlace(r.scaleInPlace(A*t)),D.D(C),Y.Distance(h,C)}static Center(h,R){return Y.CenterToRef(h,R,Y.Zero())}static CenterToRef(h,R,l){return l.OF((h._x+R._x)/2,(h._y+R._y)/2,(h._z+R._z)/2)}static RotationFromAxis(h,R,l){const j=new Y;return Y.RotationFromAxisToRef(h,R,l,j),j}static RotationFromAxisToRef(h,R,l,j){const a=T.Quaternion[0];return t.RotationQuaternionFromAxisToRef(h,R,l,a),a.toEulerAnglesToRef(j),j}}Y._V8PerformanceHack=new Y(.5,.5,.5),Y._UpReadOnly=Y.Up(),Y._DownReadOnly=Y.Down(),Y._LeftHandedForwardReadOnly=Y.Forward(!1),Y._RightHandedForwardReadOnly=Y.Forward(!0),Y._LeftHandedBackwardReadOnly=Y.Backward(!1),Y._RightHandedBackwardReadOnly=Y.Backward(!0),Y._RightReadOnly=Y.Right(),Y._LeftReadOnly=Y.Left(),Y._ZeroReadOnly=Y.Zero(),Y._OneReadOnly=Y.One(),Object.defineProperties(Y.prototype,{dimension:{value:[3]},rank:{value:1}});class s{get x(){return this._x}set x(h){this._x=h,this._isDirty=!0}get y(){return this._y}set y(h){this._y=h,this._isDirty=!0}get z(){return this._z}set z(h){this._z=h,this._isDirty=!0}get w(){return this._w}set w(h){this._w=h,this._isDirty=!0}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=h,this._y=R,this._z=l,this._w=j}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let h=q(this._x);return h=397*h^q(this._y),h=397*h^q(this._z),h=397*h^q(this._w),h}sF(){return[this._x,this._y,this._z,this._w]}toArray(h,R){return void 0===R&&(R=0),h[R]=this._x,h[R+1]=this._y,h[R+2]=this._z,h[R+3]=this._w,this}Yl(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s.FromArrayToRef(h,R,this),this}addInPlace(h){return this.x+=h._x,this.y+=h._y,this.z+=h._z,this.w+=h._w,this}addInPlaceFromFloats(h,R,l,j){return this.x+=h,this.y+=R,this.z+=l,this.w+=j,this}add(h){return new s(this._x+h.x,this._y+h.y,this._z+h.z,this._w+h.w)}addToRef(h,R){return R.x=this._x+h.x,R.y=this._y+h.y,R.z=this._z+h.z,R.w=this._w+h.w,R}Pc(h){return this.x-=h.x,this.y-=h.y,this.z-=h.z,this.w-=h.w,this}fR(h){return new s(this._x-h.x,this._y-h.y,this._z-h.z,this._w-h.w)}subtractToRef(h,R){return R.x=this._x-h.x,R.y=this._y-h.y,R.z=this._z-h.z,R.w=this._w-h.w,R}subtractFromFloats(h,R,l,j){return new s(this._x-h,this._y-R,this._z-l,this._w-j)}subtractFromFloatsToRef(h,R,l,j,a){return a.x=this._x-h,a.y=this._y-R,a.z=this._z-l,a.w=this._w-j,a}negate(){return new s(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(h){return h.x=-this._x,h.y=-this._y,h.z=-this._z,h.w=-this._w,h}scaleInPlace(h){return this.x*=h,this.y*=h,this.z*=h,this.w*=h,this}scale(h){return new s(this._x*h,this._y*h,this._z*h,this._w*h)}scaleToRef(h,R){return R.x=this._x*h,R.y=this._y*h,R.z=this._z*h,R.w=this._w*h,R}scaleAndAddToRef(h,R){return R.x+=this._x*h,R.y+=this._y*h,R.z+=this._z*h,R.w+=this._w*h,R}equals(h){return h&&this._x===h.x&&this._y===h.y&&this._z===h.z&&this._w===h.w}equalsWithEpsilon(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return h&&(0,w.WithinEpsilon)(this._x,h.x,R)&&(0,w.WithinEpsilon)(this._y,h.y,R)&&(0,w.WithinEpsilon)(this._z,h.z,R)&&(0,w.WithinEpsilon)(this._w,h.w,R)}equalsToFloats(h,R,l,j){return this._x===h&&this._y===R&&this._z===l&&this._w===j}multiplyInPlace(h){return this.x*=h.x,this.y*=h.y,this.z*=h.z,this.w*=h.w,this}multiply(h){return new s(this._x*h.x,this._y*h.y,this._z*h.z,this._w*h.w)}multiplyToRef(h,R){return R.x=this._x*h.x,R.y=this._y*h.y,R.z=this._z*h.z,R.w=this._w*h.w,R}multiplyByFloats(h,R,l,j){return new s(this._x*h,this._y*R,this._z*l,this._w*j)}divide(h){return new s(this._x/h.x,this._y/h.y,this._z/h.z,this._w/h.w)}divideToRef(h,R){return R.x=this._x/h.x,R.y=this._y/h.y,R.z=this._z/h.z,R.w=this._w/h.w,R}divideInPlace(h){return this.divideToRef(h,this)}minimizeInPlace(h){return h.x<this._x&&(this.x=h.x),h.y<this._y&&(this.y=h.y),h.z<this._z&&(this.z=h.z),h.w<this._w&&(this.w=h.w),this}maximizeInPlace(h){return h.x>this._x&&(this.x=h.x),h.y>this._y&&(this.y=h.y),h.z>this._z&&(this.z=h.z),h.w>this._w&&(this.w=h.w),this}minimizeInPlaceFromFloats(h,R,l,j){return this.x=Math.min(h,this._x),this.y=Math.min(R,this._y),this.z=Math.min(l,this._z),this.w=Math.min(j,this._w),this}maximizeInPlaceFromFloats(h,R,l,j){return this.x=Math.max(h,this._x),this.y=Math.max(R,this._y),this.z=Math.max(l,this._z),this.w=Math.max(j,this._w),this}floorToRef(h){return h.x=Math.floor(this._x),h.y=Math.floor(this._y),h.z=Math.floor(this._z),h.w=Math.floor(this._w),h}floor(){return new s(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(h){return h.x=this._x-Math.floor(this._x),h.y=this._y-Math.floor(this._y),h.z=this._z-Math.floor(this._z),h.w=this._w-Math.floor(this._w),h}fract(){return new s(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){return this.normalizeToRef(new s)}normalizeToRef(h){const R=this.length();return 0===R||1===R?(h.x=this._x,h.y=this._y,h.z=this._z,h.w=this._w,h):this.scaleToRef(1/R,h)}toVector3(){return new Y(this._x,this._y,this._z)}clone(){return new s(this._x,this._y,this._z,this._w)}D(h){return this.x=h.x,this.y=h.y,this.z=h.z,this.w=h.w,this}OF(h,R,l,j){return this.x=h,this.y=R,this.z=l,this.w=j,this}set(h,R,l,j){return this.OF(h,R,l,j)}vF(h){return this.x=this.y=this.z=this.w=h,this}dot(h){return this._x*h.x+this._y*h.y+this._z*h.z+this._w*h.w}static GR(h,R){return R||(R=0),new s(h[R],h[R+1],h[R+2],h[R+3])}static FromArrayToRef(h,R,l){return l.x=h[R],l.y=h[R+1],l.z=h[R+2],l.w=h[R+3],l}static FromFloatArrayToRef(h,R,l){return s.FromArrayToRef(h,R,l),l}static FromFloatsToRef(h,R,l,j,a){return a.x=h,a.y=R,a.z=l,a.w=j,a}static Zero(){return new s(0,0,0,0)}static One(){return new s(1,1,1,1)}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new s((0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,l=arguments.length>2?arguments[2]:void 0;return l.x=(0,w.RandomRange)(h,R),l.y=(0,w.RandomRange)(h,R),l.z=(0,w.RandomRange)(h,R),l.w=(0,w.RandomRange)(h,R),l}static Clamp(h,R,l){return s.ClampToRef(h,R,l,new s)}static ClampToRef(h,R,l,j){return j.x=(0,w.Clamp)(h.x,R.x,l.x),j.y=(0,w.Clamp)(h.y,R.y,l.y),j.z=(0,w.Clamp)(h.z,R.z,l.z),j.w=(0,w.Clamp)(h.w,R.w,l.w),j}static CheckExtends(h,R,l){R.minimizeInPlace(h),l.maximizeInPlace(h)}static get ZeroReadOnly(){return s._ZeroReadOnly}static Normalize(h){return s.NormalizeToRef(h,new s)}static NormalizeToRef(h,R){return h.normalizeToRef(R),R}static Minimize(h,R){const l=new s;return l.D(h),l.minimizeInPlace(R),l}static Maximize(h,R){const l=new s;return l.D(h),l.maximizeInPlace(R),l}static Distance(h,R){return Math.sqrt(s.DistanceSquared(h,R))}static DistanceSquared(h,R){const l=h.x-R.x,j=h.y-R.y,a=h.z-R.z,D=h.w-R.w;return l*l+j*j+a*a+D*D}static Center(h,R){return s.CenterToRef(h,R,new s)}static CenterToRef(h,R,l){return l.x=(h.x+R.x)/2,l.y=(h.y+R.y)/2,l.z=(h.z+R.z)/2,l.w=(h.w+R.w)/2,l}static TransformCoordinates(h,R){return s.TransformCoordinatesToRef(h,R,new s)}static TransformCoordinatesToRef(h,R,l){return s.TransformCoordinatesFromFloatsToRef(h._x,h._y,h._z,R,l),l}static TransformCoordinatesFromFloatsToRef(h,R,l,j,a){const D=j.m,U=h*D[0]+R*D[4]+l*D[8]+D[12],F=h*D[1]+R*D[5]+l*D[9]+D[13],w=h*D[2]+R*D[6]+l*D[10]+D[14],mh=h*D[3]+R*D[7]+l*D[11]+D[15];return a.x=U,a.y=F,a.z=w,a.w=mh,a}static TransformNormal(h,R){return s.TransformNormalToRef(h,R,new s)}static TransformNormalToRef(h,R,l){const j=R.m,a=h.x*j[0]+h.y*j[4]+h.z*j[8],D=h.x*j[1]+h.y*j[5]+h.z*j[9],U=h.x*j[2]+h.y*j[6]+h.z*j[10];return l.x=a,l.y=D,l.z=U,l.w=h.w,l}static TransformNormalFromFloatsToRef(h,R,l,j,a,D){const U=a.m;return D.x=h*U[0]+R*U[4]+l*U[8],D.y=h*U[1]+R*U[5]+l*U[9],D.z=h*U[2]+R*U[6]+l*U[10],D.w=j,D}static FromVector3(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new s(h._x,h._y,h._z,R)}static Dot(h,R){return h.x*R.x+h.y*R.y+h.z*R.z+h.w*R.w}}s._V8PerformanceHack=new s(.5,.5,.5,.5),s._ZeroReadOnly=s.Zero(),Object.defineProperties(s.prototype,{dimension:{value:[4]},rank:{value:1}});class t{get x(){return this._x}set x(h){this._x=h,this._isDirty=!0}get y(){return this._y}set y(h){this._y=h,this._isDirty=!0}get z(){return this._z}set z(h){this._z=h,this._isDirty=!0}get w(){return this._w}set w(h){this._w=h,this._isDirty=!0}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=h,this._y=R,this._z=l,this._w=j}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let h=q(this._x);return h=397*h^q(this._y),h=397*h^q(this._z),h=397*h^q(this._w),h}sF(){return[this._x,this._y,this._z,this._w]}toArray(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[R]=this._x,h[R+1]=this._y,h[R+2]=this._z,h[R+3]=this._w,this}Yl(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(h,R,this)}equals(h){return h&&this._x===h._x&&this._y===h._y&&this._z===h._z&&this._w===h._w}equalsWithEpsilon(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return h&&(0,w.WithinEpsilon)(this._x,h._x,R)&&(0,w.WithinEpsilon)(this._y,h._y,R)&&(0,w.WithinEpsilon)(this._z,h._z,R)&&(0,w.WithinEpsilon)(this._w,h._w,R)}isApprox(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return h&&((0,w.WithinEpsilon)(this._x,h._x,R)&&(0,w.WithinEpsilon)(this._y,h._y,R)&&(0,w.WithinEpsilon)(this._z,h._z,R)&&(0,w.WithinEpsilon)(this._w,h._w,R)||(0,w.WithinEpsilon)(this._x,-h._x,R)&&(0,w.WithinEpsilon)(this._y,-h._y,R)&&(0,w.WithinEpsilon)(this._z,-h._z,R)&&(0,w.WithinEpsilon)(this._w,-h._w,R))}clone(){return new t(this._x,this._y,this._z,this._w)}D(h){return this._x=h._x,this._y=h._y,this._z=h._z,this._w=h._w,this._isDirty=!0,this}OF(h,R,l,j){return this._x=h,this._y=R,this._z=l,this._w=j,this._isDirty=!0,this}set(h,R,l,j){return this.OF(h,R,l,j)}vF(h){return this.OF(h,h,h,h)}add(h){return new t(this._x+h._x,this._y+h._y,this._z+h._z,this._w+h._w)}addInPlace(h){return this._x+=h._x,this._y+=h._y,this._z+=h._z,this._w+=h._w,this._isDirty=!0,this}addToRef(h,R){return R._x=this._x+h._x,R._y=this._y+h._y,R._z=this._z+h._z,R._w=this._w+h._w,R._isDirty=!0,R}addInPlaceFromFloats(h,R,l,j){return this._x+=h,this._y+=R,this._z+=l,this._w+=j,this._isDirty=!0,this}subtractToRef(h,R){return R._x=this._x-h._x,R._y=this._y-h._y,R._z=this._z-h._z,R._w=this._w-h._w,R._isDirty=!0,R}subtractFromFloats(h,R,l,j){return this.subtractFromFloatsToRef(h,R,l,j,new t)}subtractFromFloatsToRef(h,R,l,j,a){return a._x=this._x-h,a._y=this._y-R,a._z=this._z-l,a._w=this._w-j,a._isDirty=!0,a}fR(h){return new t(this._x-h._x,this._y-h._y,this._z-h._z,this._w-h._w)}Pc(h){return this._x-=h._x,this._y-=h._y,this._z-=h._z,this._w-=h._w,this._isDirty=!0,this}scale(h){return new t(this._x*h,this._y*h,this._z*h,this._w*h)}scaleToRef(h,R){return R._x=this._x*h,R._y=this._y*h,R._z=this._z*h,R._w=this._w*h,R._isDirty=!0,R}scaleInPlace(h){return this._x*=h,this._y*=h,this._z*=h,this._w*=h,this._isDirty=!0,this}scaleAndAddToRef(h,R){return R._x+=this._x*h,R._y+=this._y*h,R._z+=this._z*h,R._w+=this._w*h,R._isDirty=!0,R}multiply(h){const R=new t(0,0,0,1);return this.multiplyToRef(h,R),R}multiplyToRef(h,R){const l=this._x*h._w+this._y*h._z-this._z*h._y+this._w*h._x,j=-this._x*h._z+this._y*h._w+this._z*h._x+this._w*h._y,a=this._x*h._y-this._y*h._x+this._z*h._w+this._w*h._z,D=-this._x*h._x-this._y*h._y-this._z*h._z+this._w*h._w;return R.OF(l,j,a,D),R}multiplyInPlace(h){return this.multiplyToRef(h,this)}multiplyByFloats(h,R,l,j){return this._x*=h,this._y*=R,this._z*=l,this._w*=j,this._isDirty=!0,this}divide(h){throw new ReferenceError("Can not divide a quaternion")}divideToRef(h,R){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(h){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new t)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(h){return h._x=-this._x,h._y=-this._y,h._z=-this._z,h._w=-this._w,h._isDirty=!0,h}equalsToFloats(h,R,l,j){return this._x===h&&this._y===R&&this._z===l&&this._w===j}floorToRef(h){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(h){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(h){return h.OF(-this._x,-this._y,-this._z,this._w),h}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new t(-this._x,-this._y,-this._z,this._w)}invert(){const h=this.conjugate(),R=this.lengthSquared();return 0==R||1==R||h.scaleInPlace(1/R),h}invertInPlace(){this.conjugateInPlace();const h=this.lengthSquared();return 0==h||1==h||this.scaleInPlace(1/h),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){const h=new t(0,0,0,1);return this.normalizeToRef(h),h}normalizeToRef(h){const R=this.length();return 0===R||1===R?h.OF(this._x,this._y,this._z,this._w):this.scaleToRef(1/R,h)}toEulerAngles(){const h=Y.Zero();return this.toEulerAnglesToRef(h),h}toEulerAnglesToRef(h){const R=this._z,l=this._x,j=this._y,a=this._w,D=j*R-l*a,U=.4999999;if(D<-U)h._y=2*Math.atan2(j,a),h._x=Math.PI/2,h._z=0,h._isDirty=!0;else if(D>U)h._y=2*Math.atan2(j,a),h._x=-Math.PI/2,h._z=0,h._isDirty=!0;else{const U=a*a,F=R*R,w=l*l,mh=j*j;h._z=Math.atan2(2*(l*j+R*a),-F-w+mh+U),h._x=Math.asin(-2*D),h._y=Math.atan2(2*(R*l+j*a),F-w-mh+U),h._isDirty=!0}return h}toAlphaBetaGammaToRef(h){const R=this._z,l=this._x,j=this._y,a=this._w,D=Math.sqrt(l*l+j*j),U=Math.sqrt(R*R+a*a),F=2*Math.atan2(D,U),w=2*Math.atan2(R,a),mh=2*Math.atan2(j,l),u=(w+mh)/2,c=(w-mh)/2;return h.set(c,F,u),h}toRotationMatrix(h){return f.FromQuaternionToRef(this,h),h}fromRotationMatrix(h){return t.FromRotationMatrixToRef(h,this),this}dot(h){return this._x*h._x+this._y*h._y+this._z*h._z+this._w*h._w}toAxisAngle(){const h=Y.Zero();return{axis:h,angle:this.toAxisAngleToRef(h)}}toAxisAngleToRef(h){let R=0;const l=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),j=this._w;return l>0?(R=2*Math.atan2(l,j),h.set(this._x/l,this._y/l,this._z/l)):(R=0,h.set(1,0,0)),R}static FromRotationMatrix(h){const R=new t;return t.FromRotationMatrixToRef(h,R),R}static FromRotationMatrixToRef(h,R){const l=h.m,j=l[0],a=l[4],D=l[8],U=l[1],F=l[5],w=l[9],mh=l[2],u=l[6],c=l[10],J=j+F+c;let q;return J>0?(q=.5/Math.sqrt(J+1),R._w=.25/q,R._x=(u-w)*q,R._y=(D-mh)*q,R._z=(U-a)*q,R._isDirty=!0):j>F&&j>c?(q=2*Math.sqrt(1+j-F-c),R._w=(u-w)/q,R._x=.25*q,R._y=(a+U)/q,R._z=(D+mh)/q,R._isDirty=!0):F>c?(q=2*Math.sqrt(1+F-j-c),R._w=(D-mh)/q,R._x=(a+U)/q,R._y=.25*q,R._z=(w+u)/q,R._isDirty=!0):(q=2*Math.sqrt(1+c-j-F),R._w=(U-a)/q,R._x=(D+mh)/q,R._y=(w+u)/q,R._z=.25*q,R._isDirty=!0),R}static Dot(h,R){return h._x*R._x+h._y*R._y+h._z*R._z+h._w*R._w}static AreClose(h,R){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const j=t.Dot(h,R);return 1-j*j<=l}static SmoothToRef(h,R,l,j,a){let D=0===j?1:l/j;return D=(0,w.Clamp)(D,0,1),t.SlerpToRef(h,R,D,a),a}static Zero(){return new t(0,0,0,0)}static Inverse(h){return new t(-h._x,-h._y,-h._z,h._w)}static InverseToRef(h,R){return R.set(-h._x,-h._y,-h._z,h._w),R}static Identity(){return new t(0,0,0,1)}static IsIdentity(h){return h&&0===h._x&&0===h._y&&0===h._z&&1===h._w}static RotationAxis(h,R){return t.RotationAxisToRef(h,R,new t)}static RotationAxisToRef(h,R,l){l._w=Math.cos(R/2);const j=Math.sin(R/2)/h.length();return l._x=h._x*j,l._y=h._y*j,l._z=h._z*j,l._isDirty=!0,l}static GR(h,R){return R||(R=0),new t(h[R],h[R+1],h[R+2],h[R+3])}static FromArrayToRef(h,R,l){return l._x=h[R],l._y=h[R+1],l._z=h[R+2],l._w=h[R+3],l._isDirty=!0,l}static FromFloatsToRef(h,R,l,j,a){return a.OF(h,R,l,j),a}static FromEulerAngles(h,R,l){const j=new t;return t.RotationYawPitchRollToRef(R,h,l,j),j}static FromEulerAnglesToRef(h,R,l,j){return t.RotationYawPitchRollToRef(R,h,l,j),j}static FromEulerVector(h){const R=new t;return t.RotationYawPitchRollToRef(h._y,h._x,h._z,R),R}static FromEulerVectorToRef(h,R){return t.RotationYawPitchRollToRef(h._y,h._x,h._z,R),R}static FromUnitVectorsToRef(h,R,l){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:j.d;const D=Y.Dot(h,R)+1;return D<a?Math.abs(h.x)>Math.abs(h.z)?l.set(-h.y,h.x,0,0):l.set(0,-h.z,h.y,0):(Y.CrossToRef(h,R,E.tR[0]),l.set(E.tR[0].x,E.tR[0].y,E.tR[0].z,D)),l.normalize()}static RotationYawPitchRoll(h,R,l){const j=new t;return t.RotationYawPitchRollToRef(h,R,l,j),j}static RotationYawPitchRollToRef(h,R,l,j){const a=.5*l,D=.5*R,U=.5*h,F=Math.sin(a),w=Math.cos(a),mh=Math.sin(D),u=Math.cos(D),c=Math.sin(U),J=Math.cos(U);return j._x=J*mh*w+c*u*F,j._y=c*u*w-J*mh*F,j._z=J*u*F-c*mh*w,j._w=J*u*w+c*mh*F,j._isDirty=!0,j}static RotationAlphaBetaGamma(h,R,l){const j=new t;return t.RotationAlphaBetaGammaToRef(h,R,l,j),j}static RotationAlphaBetaGammaToRef(h,R,l,j){const a=.5*(l+h),D=.5*(l-h),U=.5*R;return j._x=Math.cos(D)*Math.sin(U),j._y=Math.sin(D)*Math.sin(U),j._z=Math.sin(a)*Math.cos(U),j._w=Math.cos(a)*Math.cos(U),j._isDirty=!0,j}static RotationQuaternionFromAxis(h,R,l){const j=new t(0,0,0,0);return t.RotationQuaternionFromAxisToRef(h,R,l,j),j}static RotationQuaternionFromAxisToRef(h,R,l,j){const a=T.Matrix[0];return h=h.normalizeToRef(T.tR[0]),R=R.normalizeToRef(T.tR[1]),l=l.normalizeToRef(T.tR[2]),f.FromXYZAxesToRef(h,R,l,a),t.FromRotationMatrixToRef(a,j),j}static FromLookDirectionLH(h,R){const l=new t;return t.FromLookDirectionLHToRef(h,R,l),l}static FromLookDirectionLHToRef(h,R,l){const j=T.Matrix[0];return f.LookDirectionLHToRef(h,R,j),t.FromRotationMatrixToRef(j,l),l}static FromLookDirectionRH(h,R){const l=new t;return t.FromLookDirectionRHToRef(h,R,l),l}static FromLookDirectionRHToRef(h,R,l){const j=T.Matrix[0];return f.LookDirectionRHToRef(h,R,j),t.FromRotationMatrixToRef(j,l)}static Slerp(h,R,l){const j=t.Identity();return t.SlerpToRef(h,R,l,j),j}static SlerpToRef(h,R,l,j){let a,D,U=h._x*R._x+h._y*R._y+h._z*R._z+h._w*R._w,F=!1;if(U<0&&(F=!0,U=-U),U>.999999)D=1-l,a=F?-l:l;else{const h=Math.acos(U),R=1/Math.sin(h);D=Math.sin((1-l)*h)*R,a=F?-Math.sin(l*h)*R:Math.sin(l*h)*R}return j._x=D*h._x+a*R._x,j._y=D*h._y+a*R._y,j._z=D*h._z+a*R._z,j._w=D*h._w+a*R._w,j._isDirty=!0,j}static Hermite(h,R,l,j,a){const D=a*a,U=a*D,F=2*U-3*D+1,w=-2*U+3*D,mh=U-2*D+a,u=U-D,c=h._x*F+l._x*w+R._x*mh+j._x*u,J=h._y*F+l._y*w+R._y*mh+j._y*u,q=h._z*F+l._z*w+R._z*mh+j._z*u,Q=h._w*F+l._w*w+R._w*mh+j._w*u;return new t(c,J,q,Q)}static Hermite1stDerivative(h,R,l,j,a){const D=new t;return this.Hermite1stDerivativeToRef(h,R,l,j,a,D),D}static Hermite1stDerivativeToRef(h,R,l,j,a,D){const U=a*a;return D._x=6*(U-a)*h._x+(3*U-4*a+1)*R._x+6*(-U+a)*l._x+(3*U-2*a)*j._x,D._y=6*(U-a)*h._y+(3*U-4*a+1)*R._y+6*(-U+a)*l._y+(3*U-2*a)*j._y,D._z=6*(U-a)*h._z+(3*U-4*a+1)*R._z+6*(-U+a)*l._z+(3*U-2*a)*j._z,D._w=6*(U-a)*h._w+(3*U-4*a+1)*R._w+6*(-U+a)*l._w+(3*U-2*a)*j._w,D._isDirty=!0,D}static Normalize(h){const R=t.Zero();return t.NormalizeToRef(h,R),R}static NormalizeToRef(h,R){return h.normalizeToRef(R),R}static Clamp(h,R,l){const j=new t;return t.ClampToRef(h,R,l,j),j}static ClampToRef(h,R,l,j){return j.OF((0,w.Clamp)(h.x,R.x,l.x),(0,w.Clamp)(h.y,R.y,l.y),(0,w.Clamp)(h.z,R.z,l.z),(0,w.Clamp)(h.w,R.w,l.w))}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new t((0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).OF((0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R),(0,w.RandomRange)(h,R))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(h,R){return Math.sqrt(t.DistanceSquared(h,R))}static DistanceSquared(h,R){const l=h.x-R.x,j=h.y-R.y,a=h.z-R.z,D=h.w-R.w;return l*l+j*j+a*a+D*D}static Center(h,R){return t.CenterToRef(h,R,t.Zero())}static CenterToRef(h,R,l){return l.OF((h.x+R.x)/2,(h.y+R.y)/2,(h.z+R.z)/2,(h.w+R.w)/2)}}t._V8PerformanceHack=new t(.5,.5,.5,.5),Object.defineProperties(t.prototype,{dimension:{value:[4]},rank:{value:1}});class f{static get Use64Bits(){return U.c.MatrixUse64Bits}get m(){return this.cF}markAsUpdated(){this.updateFlag=mh._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(h){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],j=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=h,this._isIdentity3x2=h||l,this._isIdentityDirty=!this._isIdentity&&R,this._isIdentity3x2Dirty=!this._isIdentity3x2&&j}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,U.c.MatrixTrackPrecisionChange&&U.c.MatrixTrackedMatrices.push(this),this.cF=new U.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const h=this.cF;this._isIdentity=1===h[0]&&0===h[1]&&0===h[2]&&0===h[3]&&0===h[4]&&1===h[5]&&0===h[6]&&0===h[7]&&0===h[8]&&0===h[9]&&1===h[10]&&0===h[11]&&0===h[12]&&0===h[13]&&0===h[14]&&1===h[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.cF[0]||1!==this.cF[5]||1!==this.cF[15]||0!==this.cF[1]||0!==this.cF[2]||0!==this.cF[3]||0!==this.cF[4]||0!==this.cF[6]||0!==this.cF[7]||0!==this.cF[8]||0!==this.cF[9]||0!==this.cF[10]||0!==this.cF[11]||0!==this.cF[12]||0!==this.cF[13]||0!==this.cF[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const h=this.cF,R=h[0],l=h[1],j=h[2],a=h[3],D=h[4],U=h[5],F=h[6],w=h[7],mh=h[8],u=h[9],c=h[10],J=h[11],q=h[12],Q=h[13],Y=h[14],s=h[15],t=c*s-Y*J,f=u*s-Q*J,T=u*Y-Q*c,E=mh*s-q*J,x=mh*Y-c*q,G=mh*Q-q*u;return R*+(U*t-F*f+w*T)+l*-(D*t-F*E+w*x)+j*+(D*f-U*E+w*G)+a*-(D*T-U*x+F*G)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!h)return this.cF;const l=this.cF;for(let j=0;j<16;j++)h[R+j]=l[j];return this}sF(){return this.cF}Yl(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f.FromArrayToRef(h,R,this)}OF(){for(var h=arguments.length,R=new Array(h),l=0;l<h;l++)R[l]=arguments[l];return f.FromArrayToRef(R,0,this)}set(){const h=this.cF;for(let R=0;R<16;R++)h[R]=R<0||arguments.length<=R?void 0:arguments[R];return this.markAsUpdated(),this}vF(h){const R=this.cF;for(let l=0;l<16;l++)R[l]=h;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return f.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(h){const R=new f;return this.addToRef(h,R),R}addToRef(h,R){const l=this.cF,j=R.cF,a=h.m;for(let D=0;D<16;D++)j[D]=l[D]+a[D];return R.markAsUpdated(),R}addToSelf(h){const R=this.cF,l=h.m;return R[0]+=l[0],R[1]+=l[1],R[2]+=l[2],R[3]+=l[3],R[4]+=l[4],R[5]+=l[5],R[6]+=l[6],R[7]+=l[7],R[8]+=l[8],R[9]+=l[9],R[10]+=l[10],R[11]+=l[11],R[12]+=l[12],R[13]+=l[13],R[14]+=l[14],R[15]+=l[15],this.markAsUpdated(),this}addInPlace(h){const R=this.cF,l=h.m;for(let j=0;j<16;j++)R[j]+=l[j];return this.markAsUpdated(),this}addInPlaceFromFloats(){const h=this.cF;for(let R=0;R<16;R++)h[R]+=R<0||arguments.length<=R?void 0:arguments[R];return this.markAsUpdated(),this}fR(h){const R=this.cF,l=h.m;for(let j=0;j<16;j++)R[j]-=l[j];return this.markAsUpdated(),this}subtractToRef(h,R){const l=this.cF,j=h.m,a=R.cF;for(let D=0;D<16;D++)a[D]=l[D]-j[D];return R.markAsUpdated(),R}Pc(h){const R=this.cF,l=h.m;for(let j=0;j<16;j++)R[j]-=l[j];return this.markAsUpdated(),this}subtractFromFloats(){for(var h=arguments.length,R=new Array(h),l=0;l<h;l++)R[l]=arguments[l];return this.subtractFromFloatsToRef(...R,new f)}subtractFromFloatsToRef(){for(var h=arguments.length,R=new Array(h),l=0;l<h;l++)R[l]=arguments[l];const j=R.pop(),a=this.cF,D=j.cF,U=R;for(let F=0;F<16;F++)D[F]=a[F]-U[F];return j.markAsUpdated(),j}invertToRef(h){return!0===this._isIdentity?(f.IdentityToRef(h),h):(J(this,h.sF())?h.markAsUpdated():h.D(this),h)}addAtIndex(h,R){return this.cF[h]+=R,this.markAsUpdated(),this}multiplyAtIndex(h,R){return this.cF[h]*=R,this.markAsUpdated(),this}setTranslationFromFloats(h,R,l){return this.cF[12]=h,this.cF[13]=R,this.cF[14]=l,this.markAsUpdated(),this}addTranslationFromFloats(h,R,l){return this.cF[12]+=h,this.cF[13]+=R,this.cF[14]+=l,this.markAsUpdated(),this}setTranslation(h){return this.setTranslationFromFloats(h._x,h._y,h._z)}getTranslation(){return new Y(this.cF[12],this.cF[13],this.cF[14])}getTranslationToRef(h){return h.x=this.cF[12],h.y=this.cF[13],h.z=this.cF[14],h}removeRotationAndScaling(){const h=this.m;return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,h[12],h[13],h[14],h[15],this),this._updateIdentityStatus(0===h[12]&&0===h[13]&&0===h[14]&&1===h[15]),this}D(h){h.copyToArray(this.cF);const R=h;return this.updateFlag=R.updateFlag,this._updateIdentityStatus(R._isIdentity,R._isIdentityDirty,R._isIdentity3x2,R._isIdentity3x2Dirty),this}copyToArray(h){return c(this,h,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(h){const R=new f;return this.multiplyToRef(h,R),R}multiplyInPlace(h){const R=this.cF,l=h.m;for(let j=0;j<16;j++)R[j]*=l[j];return this.markAsUpdated(),this}multiplyByFloats(){const h=this.cF;for(let R=0;R<16;R++)h[R]*=R<0||arguments.length<=R?void 0:arguments[R];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var h=arguments.length,R=new Array(h),l=0;l<h;l++)R[l]=arguments[l];const j=R.pop(),a=this.cF,D=j.cF,U=R;for(let F=0;F<16;F++)D[F]=a[F]*U[F];return j.markAsUpdated(),j}multiplyToRef(h,R){return this._isIdentity?(R.D(h),R):h._isIdentity?(R.D(this),R):(this.multiplyToArray(h,R.cF,0),R.markAsUpdated(),R)}multiplyToArray(h,R,l){return u(this,h,R,l),this}divide(h){return this.divideToRef(h,new f)}divideToRef(h,R){const l=this.cF,j=h.m,a=R.cF;for(let D=0;D<16;D++)a[D]=l[D]/j[D];return R.markAsUpdated(),R}divideInPlace(h){const R=this.cF,l=h.m;for(let j=0;j<16;j++)R[j]/=l[j];return this.markAsUpdated(),this}minimizeInPlace(h){const R=this.cF,l=h.m;for(let j=0;j<16;j++)R[j]=Math.min(R[j],l[j]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const h=this.cF;for(let R=0;R<16;R++)h[R]=Math.min(h[R],R<0||arguments.length<=R?void 0:arguments[R]);return this.markAsUpdated(),this}maximizeInPlace(h){const R=this.cF,l=h.m;for(let j=0;j<16;j++)R[j]=Math.min(R[j],l[j]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const h=this.cF;for(let R=0;R<16;R++)h[R]=Math.min(h[R],R<0||arguments.length<=R?void 0:arguments[R]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new f)}negateInPlace(){const h=this.cF;for(let R=0;R<16;R++)h[R]=-h[R];return this.markAsUpdated(),this}negateToRef(h){const R=this.cF,l=h.cF;for(let j=0;j<16;j++)l[j]=-R[j];return h.markAsUpdated(),h}equals(h){const R=h;if(!R)return!1;if((this._isIdentity||R._isIdentity)&&!this._isIdentityDirty&&!R._isIdentityDirty)return this._isIdentity&&R._isIdentity;const l=this.m,j=R.m;return l[0]===j[0]&&l[1]===j[1]&&l[2]===j[2]&&l[3]===j[3]&&l[4]===j[4]&&l[5]===j[5]&&l[6]===j[6]&&l[7]===j[7]&&l[8]===j[8]&&l[9]===j[9]&&l[10]===j[10]&&l[11]===j[11]&&l[12]===j[12]&&l[13]===j[13]&&l[14]===j[14]&&l[15]===j[15]}equalsWithEpsilon(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const l=this.cF,j=h.m;for(let a=0;a<16;a++)if(!(0,w.WithinEpsilon)(l[a],j[a],R))return!1;return!0}equalsToFloats(){const h=this.cF;for(let R=0;R<16;R++)if(h[R]!=(R<0||arguments.length<=R?void 0:arguments[R]))return!1;return!0}floor(){return this.floorToRef(new f)}floorToRef(h){const R=this.cF,l=h.cF;for(let j=0;j<16;j++)l[j]=Math.floor(R[j]);return h.markAsUpdated(),h}fract(){return this.fractToRef(new f)}fractToRef(h){const R=this.cF,l=h.cF;for(let j=0;j<16;j++)l[j]=R[j]-Math.floor(R[j]);return h.markAsUpdated(),h}clone(){const h=new f;return h.D(this),h}getClassName(){return"Matrix"}getHashCode(){let h=q(this.cF[0]);for(let R=1;R<16;R++)h=397*h^q(this.cF[R]);return h}decomposeToTransformNode(h){return h.rotationQuaternion=h.rotationQuaternion||new t,this.decompose(h.yF,h.rotationQuaternion,h.position)}decompose(h,R,l,j){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return l&&l.vF(0),h&&h.vF(1),R&&R.OF(0,0,0,1),!0;const D=this.cF;if(l&&l.OF(D[12],D[13],D[14]),(h=h||T.tR[0]).x=Math.sqrt(D[0]*D[0]+D[1]*D[1]+D[2]*D[2]),h.y=Math.sqrt(D[4]*D[4]+D[5]*D[5]+D[6]*D[6]),h.z=Math.sqrt(D[8]*D[8]+D[9]*D[9]+D[10]*D[10]),j){const R=(a?j.absoluteScaling.x:j.yF.x)<0?-1:1,l=(a?j.absoluteScaling.y:j.yF.y)<0?-1:1,D=(a?j.absoluteScaling.z:j.yF.z)<0?-1:1;h.x*=R,h.y*=l,h.z*=D}else this.determinant()<=0&&(h.y*=-1);if(0===h._x||0===h._y||0===h._z)return R&&R.OF(0,0,0,1),!1;if(R){const l=1/h._x,j=1/h._y,a=1/h._z;f.FromValuesToRef(D[0]*l,D[1]*l,D[2]*l,0,D[4]*j,D[5]*j,D[6]*j,0,D[8]*a,D[9]*a,D[10]*a,0,0,0,0,1,T.Matrix[0]),t.FromRotationMatrixToRef(T.Matrix[0],R)}return!0}getRow(h){if(h<0||h>3)return null;const R=4*h;return new s(this.cF[R+0],this.cF[R+1],this.cF[R+2],this.cF[R+3])}getRowToRef(h,R){if(h>=0&&h<=3){const l=4*h;R.x=this.cF[l+0],R.y=this.cF[l+1],R.z=this.cF[l+2],R.w=this.cF[l+3]}return R}setRow(h,R){return this.setRowFromFloats(h,R.x,R.y,R.z,R.w)}transpose(){const h=new f;return f.TransposeToRef(this,h),h}transposeToRef(h){return f.TransposeToRef(this,h),h}setRowFromFloats(h,R,l,j,a){if(h<0||h>3)return this;const D=4*h;return this.cF[D+0]=R,this.cF[D+1]=l,this.cF[D+2]=j,this.cF[D+3]=a,this.markAsUpdated(),this}scale(h){const R=new f;return this.scaleToRef(h,R),R}scaleToRef(h,R){for(let l=0;l<16;l++)R.cF[l]=this.cF[l]*h;return R.markAsUpdated(),R}scaleAndAddToRef(h,R){for(let l=0;l<16;l++)R.cF[l]+=this.cF[l]*h;return R.markAsUpdated(),R}scaleInPlace(h){const R=this.cF;for(let l=0;l<16;l++)R[l]*=h;return this.markAsUpdated(),this}toNormalMatrix(h){const R=T.Matrix[0];this.invertToRef(R),R.transposeToRef(h);const l=h.cF;return f.FromValuesToRef(l[0],l[1],l[2],0,l[4],l[5],l[6],0,l[8],l[9],l[10],0,0,0,0,1,h),h}getRotationMatrix(){const h=new f;return this.getRotationMatrixToRef(h),h}getRotationMatrixToRef(h){const R=T.tR[0];if(!this.decompose(R))return f.IdentityToRef(h),h;const l=this.cF,j=1/R._x,a=1/R._y,D=1/R._z;return f.FromValuesToRef(l[0]*j,l[1]*j,l[2]*j,0,l[4]*a,l[5]*a,l[6]*a,0,l[8]*D,l[9]*D,l[10]*D,0,0,0,0,1,h),h}toggleModelMatrixHandInPlace(){const h=this.cF;return h[2]*=-1,h[6]*=-1,h[8]*=-1,h[9]*=-1,h[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const h=this.cF;return h[8]*=-1,h[9]*=-1,h[10]*=-1,h[11]*=-1,this.markAsUpdated(),this}static GR(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const l=new f;return f.FromArrayToRef(h,R,l),l}static FromArrayToRef(h,R,l){for(let j=0;j<16;j++)l.cF[j]=h[j+R];return l.markAsUpdated(),l}static FromFloat32ArrayToRefScaled(h,R,l,j){return j.cF[0]=h[0+R]*l,j.cF[1]=h[1+R]*l,j.cF[2]=h[2+R]*l,j.cF[3]=h[3+R]*l,j.cF[4]=h[4+R]*l,j.cF[5]=h[5+R]*l,j.cF[6]=h[6+R]*l,j.cF[7]=h[7+R]*l,j.cF[8]=h[8+R]*l,j.cF[9]=h[9+R]*l,j.cF[10]=h[10+R]*l,j.cF[11]=h[11+R]*l,j.cF[12]=h[12+R]*l,j.cF[13]=h[13+R]*l,j.cF[14]=h[14+R]*l,j.cF[15]=h[15+R]*l,j.markAsUpdated(),j}static get IdentityReadOnly(){return f._IdentityReadOnly}static FromValuesToRef(h,R,l,j,a,D,U,F,w,mh,u,c,J,q,Q,Y,s){const t=s.cF;t[0]=h,t[1]=R,t[2]=l,t[3]=j,t[4]=a,t[5]=D,t[6]=U,t[7]=F,t[8]=w,t[9]=mh,t[10]=u,t[11]=c,t[12]=J,t[13]=q,t[14]=Q,t[15]=Y,s.markAsUpdated()}static FromValues(h,R,l,j,a,D,U,F,w,mh,u,c,J,q,Q,Y){const s=new f,t=s.cF;return t[0]=h,t[1]=R,t[2]=l,t[3]=j,t[4]=a,t[5]=D,t[6]=U,t[7]=F,t[8]=w,t[9]=mh,t[10]=u,t[11]=c,t[12]=J,t[13]=q,t[14]=Q,t[15]=Y,s.markAsUpdated(),s}static Compose(h,R,l){const j=new f;return f.ComposeToRef(h,R,l,j),j}static ComposeToRef(h,R,l,j){const a=j.cF,D=R._x,U=R._y,F=R._z,w=R._w,mh=D+D,u=U+U,c=F+F,J=D*mh,q=D*u,Q=D*c,Y=U*u,s=U*c,t=F*c,f=w*mh,T=w*u,E=w*c,x=h._x,G=h._y,p=h._z;return a[0]=(1-(Y+t))*x,a[1]=(q+E)*x,a[2]=(Q-T)*x,a[3]=0,a[4]=(q-E)*G,a[5]=(1-(J+t))*G,a[6]=(s+f)*G,a[7]=0,a[8]=(Q+T)*p,a[9]=(s-f)*p,a[10]=(1-(J+Y))*p,a[11]=0,a[12]=l._x,a[13]=l._y,a[14]=l._z,a[15]=1,j.markAsUpdated(),j}static Identity(){const h=f.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return h._updateIdentityStatus(!0),h}static IdentityToRef(h){return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,h),h._updateIdentityStatus(!0),h}static Zero(){const h=f.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return h._updateIdentityStatus(!1),h}static RotationX(h){const R=new f;return f.RotationXToRef(h,R),R}static Invert(h){const R=new f;return h.invertToRef(R),R}static RotationXToRef(h,R){const l=Math.sin(h),j=Math.cos(h);return f.FromValuesToRef(1,0,0,0,0,j,l,0,0,-l,j,0,0,0,0,1,R),R._updateIdentityStatus(1===j&&0===l),R}static RotationY(h){const R=new f;return f.RotationYToRef(h,R),R}static RotationYToRef(h,R){const l=Math.sin(h),j=Math.cos(h);return f.FromValuesToRef(j,0,-l,0,0,1,0,0,l,0,j,0,0,0,0,1,R),R._updateIdentityStatus(1===j&&0===l),R}static RotationZ(h){const R=new f;return f.RotationZToRef(h,R),R}static RotationZToRef(h,R){const l=Math.sin(h),j=Math.cos(h);return f.FromValuesToRef(j,l,0,0,-l,j,0,0,0,0,1,0,0,0,0,1,R),R._updateIdentityStatus(1===j&&0===l),R}static RotationAxis(h,R){const l=new f;return f.RotationAxisToRef(h,R,l),l}static RotationAxisToRef(h,R,l){const j=Math.sin(-R),a=Math.cos(-R),D=1-a;h=h.normalizeToRef(T.tR[0]);const U=l.cF;return U[0]=h._x*h._x*D+a,U[1]=h._x*h._y*D-h._z*j,U[2]=h._x*h._z*D+h._y*j,U[3]=0,U[4]=h._y*h._x*D+h._z*j,U[5]=h._y*h._y*D+a,U[6]=h._y*h._z*D-h._x*j,U[7]=0,U[8]=h._z*h._x*D-h._y*j,U[9]=h._z*h._y*D+h._x*j,U[10]=h._z*h._z*D+a,U[11]=0,U[12]=0,U[13]=0,U[14]=0,U[15]=1,l.markAsUpdated(),l}static RotationAlignToRef(h,R,l){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const D=Y.Dot(R,h),U=l.cF;if(D<-1+j.d)U[0]=-1,U[1]=0,U[2]=0,U[3]=0,U[4]=0,U[5]=a?1:-1,U[6]=0,U[7]=0,U[8]=0,U[9]=0,U[10]=a?-1:1,U[11]=0;else{const l=Y.Cross(R,h),j=1/(1+D);U[0]=l._x*l._x*j+D,U[1]=l._y*l._x*j-l._z,U[2]=l._z*l._x*j+l._y,U[3]=0,U[4]=l._x*l._y*j+l._z,U[5]=l._y*l._y*j+D,U[6]=l._z*l._y*j-l._x,U[7]=0,U[8]=l._x*l._z*j-l._y,U[9]=l._y*l._z*j+l._x,U[10]=l._z*l._z*j+D,U[11]=0}return U[12]=0,U[13]=0,U[14]=0,U[15]=1,l.markAsUpdated(),l}static RotationYawPitchRoll(h,R,l){const j=new f;return f.RotationYawPitchRollToRef(h,R,l,j),j}static RotationYawPitchRollToRef(h,R,l,j){return t.RotationYawPitchRollToRef(h,R,l,T.Quaternion[0]),T.Quaternion[0].toRotationMatrix(j),j}static Scaling(h,R,l){const j=new f;return f.ScalingToRef(h,R,l,j),j}static ScalingToRef(h,R,l,j){return f.FromValuesToRef(h,0,0,0,0,R,0,0,0,0,l,0,0,0,0,1,j),j._updateIdentityStatus(1===h&&1===R&&1===l),j}static Translation(h,R,l){const j=new f;return f.TranslationToRef(h,R,l,j),j}static TranslationToRef(h,R,l,j){return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,h,R,l,1,j),j._updateIdentityStatus(0===h&&0===R&&0===l),j}static Lerp(h,R,l){const j=new f;return f.LerpToRef(h,R,l,j),j}static LerpToRef(h,R,l,j){const a=j.cF,D=h.m,U=R.m;for(let F=0;F<16;F++)a[F]=D[F]*(1-l)+U[F]*l;return j.markAsUpdated(),j}static DecomposeLerp(h,R,l){const j=new f;return f.DecomposeLerpToRef(h,R,l,j),j}static DecomposeLerpToRef(h,R,l,j){const a=T.tR[0],D=T.Quaternion[0],U=T.tR[1];h.decompose(a,D,U);const F=T.tR[2],w=T.Quaternion[1],mh=T.tR[3];R.decompose(F,w,mh);const u=T.tR[4];Y.LerpToRef(a,F,l,u);const c=T.Quaternion[2];t.SlerpToRef(D,w,l,c);const J=T.tR[5];return Y.LerpToRef(U,mh,l,J),f.ComposeToRef(u,c,J,j),j}static LookAtLH(h,R,l){const j=new f;return f.LookAtLHToRef(h,R,l,j),j}static LookAtLHToRef(h,R,l,j){const a=T.tR[0],D=T.tR[1],U=T.tR[2];R.subtractToRef(h,U),U.normalize(),Y.CrossToRef(l,U,a);const F=a.lengthSquared();0===F?a.x=1:a.normalizeFromLength(Math.sqrt(F)),Y.CrossToRef(U,a,D),D.normalize();const w=-Y.Dot(a,h),mh=-Y.Dot(D,h),u=-Y.Dot(U,h);return f.FromValuesToRef(a._x,D._x,U._x,0,a._y,D._y,U._y,0,a._z,D._z,U._z,0,w,mh,u,1,j),j}static LookAtRH(h,R,l){const j=new f;return f.LookAtRHToRef(h,R,l,j),j}static LookAtRHToRef(h,R,l,j){const a=T.tR[0],D=T.tR[1],U=T.tR[2];h.subtractToRef(R,U),U.normalize(),Y.CrossToRef(l,U,a);const F=a.lengthSquared();0===F?a.x=1:a.normalizeFromLength(Math.sqrt(F)),Y.CrossToRef(U,a,D),D.normalize();const w=-Y.Dot(a,h),mh=-Y.Dot(D,h),u=-Y.Dot(U,h);return f.FromValuesToRef(a._x,D._x,U._x,0,a._y,D._y,U._y,0,a._z,D._z,U._z,0,w,mh,u,1,j),j}static LookDirectionLH(h,R){const l=new f;return f.LookDirectionLHToRef(h,R,l),l}static LookDirectionLHToRef(h,R,l){const j=T.tR[0];j.D(h),j.scaleInPlace(-1);const a=T.tR[1];return Y.CrossToRef(R,j,a),f.FromValuesToRef(a._x,a._y,a._z,0,R._x,R._y,R._z,0,j._x,j._y,j._z,0,0,0,0,1,l),l}static LookDirectionRH(h,R){const l=new f;return f.LookDirectionRHToRef(h,R,l),l}static LookDirectionRHToRef(h,R,l){const j=T.tR[2];return Y.CrossToRef(R,h,j),f.FromValuesToRef(j._x,j._y,j._z,0,R._x,R._y,R._z,0,h._x,h._y,h._z,0,0,0,0,1,l),l}static OrthoLH(h,R,l,j,a){const D=new f;return f.OrthoLHToRef(h,R,l,j,D,a),D}static OrthoLHToRef(h,R,l,j,a,D){const U=2/h,F=2/R,w=2/(j-l),mh=-(j+l)/(j-l);return f.FromValuesToRef(U,0,0,0,0,F,0,0,0,0,w,0,0,0,mh,1,a),D&&a.multiplyToRef(x,a),a._updateIdentityStatus(1===U&&1===F&&1===w&&0===mh),a}static OrthoOffCenterLH(h,R,l,j,a,D,U){const F=new f;return f.OrthoOffCenterLHToRef(h,R,l,j,a,D,F,U),F}static OrthoOffCenterLHToRef(h,R,l,j,a,D,U,F){const w=2/(R-h),mh=2/(j-l),u=2/(D-a),c=-(D+a)/(D-a),J=(h+R)/(h-R),q=(j+l)/(l-j);return f.FromValuesToRef(w,0,0,0,0,mh,0,0,0,0,u,0,J,q,c,1,U),F&&U.multiplyToRef(x,U),U.markAsUpdated(),U}static ObliqueOffCenterLHToRef(h,R,l,j,a,D,U,F,w,mh,u){const c=-U*Math.cos(F),J=-U*Math.sin(F);return f.TranslationToRef(0,0,-w,T.Matrix[1]),f.FromValuesToRef(1,0,0,0,0,1,0,0,c,J,1,0,0,0,0,1,T.Matrix[0]),T.Matrix[1].multiplyToRef(T.Matrix[0],T.Matrix[0]),f.TranslationToRef(0,0,w,T.Matrix[1]),T.Matrix[0].multiplyToRef(T.Matrix[1],T.Matrix[0]),f.OrthoOffCenterLHToRef(h,R,l,j,a,D,mh,u),T.Matrix[0].multiplyToRef(mh,mh),mh}static OrthoOffCenterRH(h,R,l,j,a,D,U){const F=new f;return f.OrthoOffCenterRHToRef(h,R,l,j,a,D,F,U),F}static OrthoOffCenterRHToRef(h,R,l,j,a,D,U,F){return f.OrthoOffCenterLHToRef(h,R,l,j,a,D,U,F),U.cF[10]*=-1,U}static ObliqueOffCenterRHToRef(h,R,l,j,a,D,U,F,w,mh,u){const c=U*Math.cos(F),J=U*Math.sin(F);return f.TranslationToRef(0,0,w,T.Matrix[1]),f.FromValuesToRef(1,0,0,0,0,1,0,0,c,J,1,0,0,0,0,1,T.Matrix[0]),T.Matrix[1].multiplyToRef(T.Matrix[0],T.Matrix[0]),f.TranslationToRef(0,0,-w,T.Matrix[1]),T.Matrix[0].multiplyToRef(T.Matrix[1],T.Matrix[0]),f.OrthoOffCenterRHToRef(h,R,l,j,a,D,mh,u),T.Matrix[0].multiplyToRef(mh,mh),mh}static PerspectiveLH(h,R,l,j,a){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const U=new f,F=2*l/h,w=2*l/R,mh=(j+l)/(j-l),u=-2*j*l/(j-l),c=Math.tan(D);return f.FromValuesToRef(F,0,0,0,0,w,0,c,0,0,mh,1,0,0,u,0,U),a&&U.multiplyToRef(x,U),U._updateIdentityStatus(!1),U}static PerspectiveFovLH(h,R,l,j,a){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const F=new f;return f.PerspectiveFovLHToRef(h,R,l,j,F,!0,a,D,U),F}static PerspectiveFovLHToRef(h,R,l,j,a){let D=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,F=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,w=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const mh=l,u=j,c=1/Math.tan(.5*h),J=D?c/R:c,q=D?c:c*R,Q=w&&0===mh?-1:0!==u?(u+mh)/(u-mh):1,Y=w&&0===mh?2*u:0!==u?-2*u*mh/(u-mh):-2*mh,s=Math.tan(F);return f.FromValuesToRef(J,0,0,0,0,q,0,s,0,0,Q,1,0,0,Y,0,a),U&&a.multiplyToRef(x,a),a._updateIdentityStatus(!1),a}static PerspectiveFovReverseLHToRef(h,R,l,j,a){let D=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,F=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const w=1/Math.tan(.5*h),mh=D?w/R:w,u=D?w:w*R,c=Math.tan(F);return f.FromValuesToRef(mh,0,0,0,0,u,0,c,0,0,-l,1,0,0,1,0,a),U&&a.multiplyToRef(x,a),a._updateIdentityStatus(!1),a}static PerspectiveFovRH(h,R,l,j,a){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const F=new f;return f.PerspectiveFovRHToRef(h,R,l,j,F,!0,a,D,U),F}static PerspectiveFovRHToRef(h,R,l,j,a){let D=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,F=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,w=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const mh=l,u=j,c=1/Math.tan(.5*h),J=D?c/R:c,q=D?c:c*R,Q=w&&0===mh?1:0!==u?-(u+mh)/(u-mh):-1,Y=w&&0===mh?2*u:0!==u?-2*u*mh/(u-mh):-2*mh,s=Math.tan(F);return f.FromValuesToRef(J,0,0,0,0,q,0,s,0,0,Q,-1,0,0,Y,0,a),U&&a.multiplyToRef(x,a),a._updateIdentityStatus(!1),a}static PerspectiveFovReverseRHToRef(h,R,l,j,a){let D=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,F=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const w=1/Math.tan(.5*h),mh=D?w/R:w,u=D?w:w*R,c=Math.tan(F);return f.FromValuesToRef(mh,0,0,0,0,u,0,c,0,0,-l,-1,0,0,-1,0,a),U&&a.multiplyToRef(x,a),a._updateIdentityStatus(!1),a}static GetFinalMatrix(h,R,l,j,a,D){const U=h.width,F=h.height,w=h.x,mh=h.y,u=f.FromValues(U/2,0,0,0,0,-F/2,0,0,0,0,D-a,0,w+U/2,F/2+mh,a,1),c=new f;return R.multiplyToRef(l,c),c.multiplyToRef(j,c),c.multiplyToRef(u,c)}static GetAsMatrix2x2(h){const R=h.m,l=[R[0],R[1],R[4],R[5]];return U.c.MatrixUse64Bits?l:new Float32Array(l)}static GetAsMatrix3x3(h){const R=h.m,l=[R[0],R[1],R[2],R[4],R[5],R[6],R[8],R[9],R[10]];return U.c.MatrixUse64Bits?l:new Float32Array(l)}static Transpose(h){const R=new f;return f.TransposeToRef(h,R),R}static TransposeToRef(h,R){const l=h.m,j=l[0],a=l[4],D=l[8],U=l[12],F=l[1],w=l[5],mh=l[9],u=l[13],c=l[2],J=l[6],q=l[10],Q=l[14],Y=l[3],s=l[7],t=l[11],f=l[15],T=R.cF;return T[0]=j,T[1]=a,T[2]=D,T[3]=U,T[4]=F,T[5]=w,T[6]=mh,T[7]=u,T[8]=c,T[9]=J,T[10]=q,T[11]=Q,T[12]=Y,T[13]=s,T[14]=t,T[15]=f,R.markAsUpdated(),R._updateIdentityStatus(h._isIdentity,h._isIdentityDirty),R}static Reflection(h){const R=new f;return f.ReflectionToRef(h,R),R}static ReflectionToRef(h,R){h.normalize();const l=h.normal.x,j=h.normal.y,a=h.normal.z,D=-2*l,U=-2*j,F=-2*a;return f.FromValuesToRef(D*l+1,U*l,F*l,0,D*j,U*j+1,F*j,0,D*a,U*a,F*a+1,0,D*h.d,U*h.d,F*h.d,1,R),R}static FromXYZAxesToRef(h,R,l,j){return f.FromValuesToRef(h._x,h._y,h._z,0,R._x,R._y,R._z,0,l._x,l._y,l._z,0,0,0,0,1,j),j}static FromQuaternionToRef(h,R){const l=h._x*h._x,j=h._y*h._y,a=h._z*h._z,D=h._x*h._y,U=h._z*h._w,F=h._z*h._x,w=h._y*h._w,mh=h._y*h._z,u=h._x*h._w;return R.cF[0]=1-2*(j+a),R.cF[1]=2*(D+U),R.cF[2]=2*(F-w),R.cF[3]=0,R.cF[4]=2*(D-U),R.cF[5]=1-2*(a+l),R.cF[6]=2*(mh+u),R.cF[7]=0,R.cF[8]=2*(F+w),R.cF[9]=2*(mh-u),R.cF[10]=1-2*(j+l),R.cF[11]=0,R.cF[12]=0,R.cF[13]=0,R.cF[14]=0,R.cF[15]=1,R.markAsUpdated(),R}}f._IdentityReadOnly=f.Identity(),Object.defineProperties(f.prototype,{dimension:{value:[4,4]},rank:{value:2}});class T{}T.tR=(0,a.h)(11,Y.Zero),T.Matrix=(0,a.h)(2,f.Identity),T.Quaternion=(0,a.h)(3,t.Zero);class E{}E.Vector2=(0,a.h)(3,Q.Zero),E.tR=(0,a.h)(13,Y.Zero),E.Vector4=(0,a.h)(3,s.Zero),E.Quaternion=(0,a.h)(3,t.Zero),E.Matrix=(0,a.h)(8,f.Identity),(0,D.f)("BABYLON.Vector2",Q),(0,D.f)("BABYLON.Vector3",Y),(0,D.f)("BABYLON.Vector4",s),(0,D.f)("BABYLON.Matrix",f);const x=f.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12910:(h,R,l)=>{function j(h,R){const l=[];for(let j=0;j<h;++j)l.push(R());return l}function a(h,R){return j(h,R)}l.d(R,{e:()=>j,h:()=>a,j:()=>U});const D=["push","splice","pop","shift","unshift"];function U(h,R){const l=D.map((l=>function(h,R,l){const j=h[R];if("function"!==typeof j)return null;const a=function(){const j=h.length,D=a.previous.apply(h,arguments);return l(R,j),D};return j.next=a,a.previous=j,h[R]=a,()=>{const l=a.previous;if(!l)return;const j=a.next;j?(l.next=j,j.previous=l):(l.next=void 0,h[R]=l),a.next=void 0,a.previous=void 0}}(h,l,R)));return()=>{for(const h of l)null===h||void 0===h||h()}}}}]);