"use strict";(self["6xhfpmwgjr5"]=self["6xhfpmwgjr5"]||[]).push([[14],{12418:(P,a,R)=>{R.d(a,{c:()=>p,e:()=>Z,i:()=>S,m:()=>A});const S=1/2.2,A=2.2,Z=(1+Math.sqrt(5))/2,p=.001},12430:(P,a,R)=>{function S(P){return parseInt(P.toString().replace(/\W/g,""))}function A(P,a){let R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(P-a)<=R}function Z(P,a,R){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return P<a-S||P>R+S}function p(P,a){return P===a?P:Math.random()*(a-P)+P}function j(P,a,R){return P+(a-P)*R}function U(P,a,R){let S=y(a-P,360);return S>180&&(S-=360),P+S*V(R)}function Q(P,a,R){let S=0;return S=P!=a?V((R-P)/(a-P)):0,S}function h(P,a,R,S,A){const Z=A*A,p=A*Z;return P*(2*p-3*Z+1)+R*(-2*p+3*Z)+a*(p-2*Z+A)+S*(p-Z)}function l(P,a,R,S,A){const Z=A*A;return 6*(Z-A)*P+(3*Z-4*A+1)*a+6*(-Z+A)*R+(3*Z-2*A)*S}function V(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(R,Math.max(a,P))}function f(P){return P-=2*Math.PI*Math.floor((P+Math.PI)/(2*Math.PI))}function O(P){const a=P.toString(16);return P<=15?("0"+a).toUpperCase():a.toUpperCase()}function q(P){if(Math.log2)return Math.floor(Math.log2(P));if(P<0)return NaN;if(0===P)return-1/0;let a=0;if(P<1){for(;P<1;)a++,P*=2;a=-a}else if(P>1)for(;P>1;)a++,P=Math.floor(P/2);return a}function y(P,a){return P-Math.floor(P/a)*a}function t(P,a,R){return(P-a)/(R-a)}function W(P,a,R){return P*(R-a)+a}function k(P,a){let R=y(a-P,360);return R>180&&(R-=360),R}function x(P,a){const R=y(P,2*a);return a-Math.abs(R-a)}function s(P,a,R){let S=V(R);return S=-2*S*S*S+3*S*S,a*S+P*(1-S)}function d(P,a,R){let S=0;return S=Math.abs(a-P)<=R?a:P+Math.sign(a-P)*R,S}function G(P,a,R){const S=k(P,a);let A=0;return A=-R<S&&S<R?a:d(P,a=P+S,R),A}function H(P,a,R){return(P-a)/(R-a)}function mP(P,a,R){return(R-a)*P+a}function N(P,a){const R=P%a;return 0===R?a:N(a,R)}R.r(a),R.d(a,{Clamp:()=>V,DeltaAngle:()=>k,Denormalize:()=>W,ExtractAsInt:()=>S,Hermite:()=>h,Hermite1stDerivative:()=>l,HighestCommonFactor:()=>N,ILog2:()=>q,InverseLerp:()=>Q,Lerp:()=>j,LerpAngle:()=>U,MoveTowards:()=>d,MoveTowardsAngle:()=>G,Normalize:()=>t,NormalizeRadians:()=>f,OutsideRange:()=>Z,PercentToRange:()=>mP,PingPong:()=>x,RandomRange:()=>p,RangeToPercent:()=>H,Repeat:()=>y,SmoothStep:()=>s,ToHex:()=>O,WithinEpsilon:()=>A})},12415:(P,a,R)=>{R.r(a),R.d(a,{Matrix:()=>W,Quaternion:()=>t,TmpVectors:()=>x,Vector2:()=>O,Oa:()=>q,Vector4:()=>y});var S=R(12418),A=R(12423),Z=R(12376),p=R(12353),j=R(12277),U=R(12430);class Q{}function h(P,a,R){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const A=P.pj(),Z=a.pj(),p=A[0],j=A[1],U=A[2],Q=A[3],h=A[4],l=A[5],V=A[6],f=A[7],O=A[8],q=A[9],y=A[10],t=A[11],W=A[12],k=A[13],x=A[14],s=A[15],d=Z[0],G=Z[1],H=Z[2],mP=Z[3],N=Z[4],D=Z[5],L=Z[6],c=Z[7],u=Z[8],Y=Z[9],J=Z[10],n=Z[11],b=Z[12],B=Z[13],o=Z[14],r=Z[15];R[S]=p*d+j*N+U*u+Q*b,R[S+1]=p*G+j*D+U*Y+Q*B,R[S+2]=p*H+j*L+U*J+Q*o,R[S+3]=p*mP+j*c+U*n+Q*r,R[S+4]=h*d+l*N+V*u+f*b,R[S+5]=h*G+l*D+V*Y+f*B,R[S+6]=h*H+l*L+V*J+f*o,R[S+7]=h*mP+l*c+V*n+f*r,R[S+8]=O*d+q*N+y*u+t*b,R[S+9]=O*G+q*D+y*Y+t*B,R[S+10]=O*H+q*L+y*J+t*o,R[S+11]=O*mP+q*c+y*n+t*r,R[S+12]=W*d+k*N+x*u+s*b,R[S+13]=W*G+k*D+x*Y+s*B,R[S+14]=W*H+k*L+x*J+s*o,R[S+15]=W*mP+k*c+x*n+s*r}function l(P,a){let R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const S=P.pj();a[R]=S[0],a[R+1]=S[1],a[R+2]=S[2],a[R+3]=S[3],a[R+4]=S[4],a[R+5]=S[5],a[R+6]=S[6],a[R+7]=S[7],a[R+8]=S[8],a[R+9]=S[9],a[R+10]=S[10],a[R+11]=S[11],a[R+12]=S[12],a[R+13]=S[13],a[R+14]=S[14],a[R+15]=S[15]}function V(P,a){const R=P.pj(),S=R[0],A=R[1],Z=R[2],p=R[3],j=R[4],U=R[5],Q=R[6],h=R[7],l=R[8],V=R[9],f=R[10],O=R[11],q=R[12],y=R[13],t=R[14],W=R[15],k=f*W-t*O,x=V*W-y*O,s=V*t-y*f,d=l*W-q*O,G=l*t-f*q,H=l*y-q*V,mP=+(U*k-Q*x+h*s),N=-(j*k-Q*d+h*G),D=+(j*x-U*d+h*H),L=-(j*s-U*G+Q*H),c=S*mP+A*N+Z*D+p*L;if(0===c)return!1;const u=1/c,Y=Q*W-t*h,J=U*W-y*h,n=U*t-y*Q,b=j*W-q*h,B=j*t-q*Q,o=j*y-q*U,r=Q*O-f*h,v=U*O-V*h,M=U*f-V*Q,E=j*O-l*h,e=j*f-l*Q,w=j*V-l*U,T=-(A*k-Z*x+p*s),I=+(S*k-Z*d+p*G),i=-(S*x-A*d+p*H),X=+(S*s-A*G+Z*H),C=+(A*Y-Z*J+p*n),z=-(S*Y-Z*b+p*B),K=+(S*J-A*b+p*o),F=-(S*n-A*B+Z*o),g=-(A*r-Z*v+p*M),PP=+(S*r-Z*E+p*e),aP=-(S*v-A*E+p*w),RP=+(S*M-A*e+Z*w);return a[0]=mP*u,a[1]=T*u,a[2]=C*u,a[3]=g*u,a[4]=N*u,a[5]=I*u,a[6]=z*u,a[7]=PP*u,a[8]=D*u,a[9]=i*u,a[10]=K*u,a[11]=aP*u,a[12]=L*u,a[13]=X*u,a[14]=F*u,a[15]=RP*u,!0}Q._UpdateFlagSeed=0;const f=P=>parseInt(P.toString().replace(/\W/g,""));class O{constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=P,this.y=a}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let P=f(this.x);return P=397*P^f(this.y),P}toArray(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[a]=this.x,P[a+1]=this.y,this}fR(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(P,a,this),this}pj(){return[this.x,this.y]}A(P){return this.x=P.x,this.y=P.y,this}Oj(P,a){return this.x=P,this.y=a,this}set(P,a){return this.Oj(P,a)}yj(P){return this.Oj(P,P)}add(P){return new O(this.x+P.x,this.y+P.y)}addToRef(P,a){return a.x=this.x+P.x,a.y=this.y+P.y,a}addInPlace(P){return this.x+=P.x,this.y+=P.y,this}addInPlaceFromFloats(P,a){return this.x+=P,this.y+=a,this}addVector3(P){return new O(this.x+P.x,this.y+P.y)}qa(P){return new O(this.x-P.x,this.y-P.y)}subtractToRef(P,a){return a.x=this.x-P.x,a.y=this.y-P.y,a}Ul(P){return this.x-=P.x,this.y-=P.y,this}multiplyInPlace(P){return this.x*=P.x,this.y*=P.y,this}multiply(P){return new O(this.x*P.x,this.y*P.y)}multiplyToRef(P,a){return a.x=this.x*P.x,a.y=this.y*P.y,a}multiplyByFloats(P,a){return new O(this.x*P,this.y*a)}divide(P){return new O(this.x/P.x,this.y/P.y)}divideToRef(P,a){return a.x=this.x/P.x,a.y=this.y/P.y,a}divideInPlace(P){return this.x=this.x/P.x,this.y=this.y/P.y,this}minimizeInPlace(P){return this.minimizeInPlaceFromFloats(P.x,P.y)}maximizeInPlace(P){return this.maximizeInPlaceFromFloats(P.x,P.y)}minimizeInPlaceFromFloats(P,a){return this.x=Math.min(P,this.x),this.y=Math.min(a,this.y),this}maximizeInPlaceFromFloats(P,a){return this.x=Math.max(P,this.x),this.y=Math.max(a,this.y),this}subtractFromFloats(P,a){return new O(this.x-P,this.y-a)}subtractFromFloatsToRef(P,a,R){return R.x=this.x-P,R.y=this.y-a,R}negate(){return new O(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(P){return P.x=-this.x,P.y=-this.y,P}scaleInPlace(P){return this.x*=P,this.y*=P,this}scale(P){return new O(this.x*P,this.y*P)}scaleToRef(P,a){return a.x=this.x*P,a.y=this.y*P,a}scaleAndAddToRef(P,a){return a.x+=this.x*P,a.y+=this.y*P,a}equals(P){return P&&this.x===P.x&&this.y===P.y}equalsWithEpsilon(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.c;return P&&(0,U.WithinEpsilon)(this.x,P.x,a)&&(0,U.WithinEpsilon)(this.y,P.y,a)}equalsToFloats(P,a){return this.x===P&&this.y===a}floor(){return new O(Math.floor(this.x),Math.floor(this.y))}floorToRef(P){return P.x=Math.floor(this.x),P.y=Math.floor(this.y),P}fract(){return new O(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(P){return P.x=this.x-Math.floor(this.x),P.y=this.y-Math.floor(this.y),P}rotate(P){return this.rotateToRef(P,new O)}rotateToRef(P,a){const R=Math.cos(P),S=Math.sin(P);return a.x=R*this.x-S*this.y,a.y=S*this.x+R*this.y,a}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){const P=new O;return this.normalizeToRef(P),P}normalizeToRef(P){const a=this.length();return 0===a&&(P.x=this.x,P.y=this.y),this.scaleToRef(1/a,P)}clone(){return new O(this.x,this.y)}dot(P){return this.x*P.x+this.y*P.y}static Zero(){return new O(0,0)}static One(){return new O(1,1)}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new O((0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Oj((0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a))}static get ZeroReadOnly(){return O._ZeroReadOnly}static ka(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new O(P[a],P[a+1])}static FromArrayToRef(P,a,R){return R.x=P[a],R.y=P[a+1],R}static FromFloatsToRef(P,a,R){return R.Oj(P,a),R}static CatmullRom(P,a,R,S,A){const Z=A*A,p=A*Z,j=.5*(2*a.x+(-P.x+R.x)*A+(2*P.x-5*a.x+4*R.x-S.x)*Z+(-P.x+3*a.x-3*R.x+S.x)*p),U=.5*(2*a.y+(-P.y+R.y)*A+(2*P.y-5*a.y+4*R.y-S.y)*Z+(-P.y+3*a.y-3*R.y+S.y)*p);return new O(j,U)}static ClampToRef(P,a,R,S){return S.x=(0,U.Clamp)(P.x,a.x,R.x),S.y=(0,U.Clamp)(P.y,a.y,R.y),S}static Clamp(P,a,R){const S=(0,U.Clamp)(P.x,a.x,R.x),A=(0,U.Clamp)(P.y,a.y,R.y);return new O(S,A)}static Hermite(P,a,R,S,A){const Z=A*A,p=A*Z,j=2*p-3*Z+1,U=-2*p+3*Z,Q=p-2*Z+A,h=p-Z,l=P.x*j+R.x*U+a.x*Q+S.x*h,V=P.y*j+R.y*U+a.y*Q+S.y*h;return new O(l,V)}static Hermite1stDerivative(P,a,R,S,A){return this.Hermite1stDerivativeToRef(P,a,R,S,A,new O)}static Hermite1stDerivativeToRef(P,a,R,S,A,Z){const p=A*A;return Z.x=6*(p-A)*P.x+(3*p-4*A+1)*a.x+6*(-p+A)*R.x+(3*p-2*A)*S.x,Z.y=6*(p-A)*P.y+(3*p-4*A+1)*a.y+6*(-p+A)*R.y+(3*p-2*A)*S.y,Z}static Lerp(P,a,R){return O.LerpToRef(P,a,R,new O)}static LerpToRef(P,a,R,S){return S.x=P.x+(a.x-P.x)*R,S.y=P.y+(a.y-P.y)*R,S}static Dot(P,a){return P.x*a.x+P.y*a.y}static Normalize(P){return O.NormalizeToRef(P,new O)}static NormalizeToRef(P,a){return P.normalizeToRef(a),a}static Minimize(P,a){const R=P.x<a.x?P.x:a.x,S=P.y<a.y?P.y:a.y;return new O(R,S)}static Maximize(P,a){const R=P.x>a.x?P.x:a.x,S=P.y>a.y?P.y:a.y;return new O(R,S)}static Transform(P,a){return O.TransformToRef(P,a,new O)}static TransformToRef(P,a,R){const S=a.m,A=P.x*S[0]+P.y*S[4]+S[12],Z=P.x*S[1]+P.y*S[5]+S[13];return R.x=A,R.y=Z,R}static PointInTriangle(P,a,R,S){const A=.5*(-R.y*S.x+a.y*(-R.x+S.x)+a.x*(R.y-S.y)+R.x*S.y),Z=A<0?-1:1,p=(a.y*S.x-a.x*S.y+(S.y-a.y)*P.x+(a.x-S.x)*P.y)*Z,j=(a.x*R.y-a.y*R.x+(a.y-R.y)*P.x+(R.x-a.x)*P.y)*Z;return p>0&&j>0&&p+j<2*A*Z}static Distance(P,a){return Math.sqrt(O.DistanceSquared(P,a))}static DistanceSquared(P,a){const R=P.x-a.x,S=P.y-a.y;return R*R+S*S}static Center(P,a){return O.CenterToRef(P,a,new O)}static CenterToRef(P,a,R){return R.Oj((P.x+a.x)/2,(P.y+a.y)/2)}static DistanceOfPointFromSegment(P,a,R){const S=O.DistanceSquared(a,R);if(0===S)return O.Distance(P,a);const A=R.qa(a),Z=Math.max(0,Math.min(1,O.Dot(P.qa(a),A)/S)),p=a.add(A.multiplyByFloats(Z,Z));return O.Distance(P,p)}}O._V8PerformanceHack=new O(.5,.5),O._ZeroReadOnly=O.Zero(),Object.defineProperties(O.prototype,{dimension:{value:[2]},rank:{value:1}});class q{get x(){return this._x}set x(P){this._x=P,this._isDirty=!0}get y(){return this._y}set y(P){this._y=P,this._isDirty=!0}get z(){return this._z}set z(P){this._z=P,this._isDirty=!0}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=P,this._y=a,this._z=R}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Oa"}getHashCode(){let P=f(this._x);return P=397*P^f(this._y),P=397*P^f(this._z),P}pj(){return[this._x,this._y,this._z]}toArray(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[a]=this._x,P[a+1]=this._y,P[a+2]=this._z,this}fR(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q.FromArrayToRef(P,a,this),this}toQuaternion(){return t.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(P){return this._x+=P._x,this._y+=P._y,this._z+=P._z,this._isDirty=!0,this}addInPlaceFromFloats(P,a,R){return this._x+=P,this._y+=a,this._z+=R,this._isDirty=!0,this}add(P){return new q(this._x+P._x,this._y+P._y,this._z+P._z)}addToRef(P,a){return a._x=this._x+P._x,a._y=this._y+P._y,a._z=this._z+P._z,a._isDirty=!0,a}Ul(P){return this._x-=P._x,this._y-=P._y,this._z-=P._z,this._isDirty=!0,this}qa(P){return new q(this._x-P._x,this._y-P._y,this._z-P._z)}subtractToRef(P,a){return this.subtractFromFloatsToRef(P._x,P._y,P._z,a)}subtractFromFloats(P,a,R){return new q(this._x-P,this._y-a,this._z-R)}subtractFromFloatsToRef(P,a,R,S){return S._x=this._x-P,S._y=this._y-a,S._z=this._z-R,S._isDirty=!0,S}negate(){return new q(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(P){return P._x=-1*this._x,P._y=-1*this._y,P._z=-1*this._z,P._isDirty=!0,P}scaleInPlace(P){return this._x*=P,this._y*=P,this._z*=P,this._isDirty=!0,this}scale(P){return new q(this._x*P,this._y*P,this._z*P)}scaleToRef(P,a){return a._x=this._x*P,a._y=this._y*P,a._z=this._z*P,a._isDirty=!0,a}getNormalToRef(P){const a=this.length();let R=Math.acos(this._y/a);const S=Math.atan2(this._z,this._x);R>Math.PI/2?R-=Math.PI/2:R+=Math.PI/2;const A=a*Math.sin(R)*Math.cos(S),Z=a*Math.cos(R),p=a*Math.sin(R)*Math.sin(S);return P.set(A,Z,p),P}applyRotationQuaternionToRef(P,a){const R=this._x,S=this._y,A=this._z,Z=P._x,p=P._y,j=P._z,U=P._w,Q=2*(p*A-j*S),h=2*(j*R-Z*A),l=2*(Z*S-p*R);return a._x=R+U*Q+p*l-j*h,a._y=S+U*h+j*Q-Z*l,a._z=A+U*l+Z*h-p*Q,a._isDirty=!0,a}applyRotationQuaternionInPlace(P){return this.applyRotationQuaternionToRef(P,this)}applyRotationQuaternion(P){return this.applyRotationQuaternionToRef(P,new q)}scaleAndAddToRef(P,a){return a._x+=this._x*P,a._y+=this._y*P,a._z+=this._z*P,a._isDirty=!0,a}projectOnPlane(P,a){return this.projectOnPlaneToRef(P,a,new q)}projectOnPlaneToRef(P,a,R){const S=P.normal,A=P.d,Z=k.Oa[0];this.subtractToRef(a,Z),Z.normalize();const p=q.Dot(Z,S);if(Math.abs(p)<1e-10)R.yj(1/0);else{const P=-(q.Dot(a,S)+A)/p,j=Z.scaleInPlace(P);a.addToRef(j,R)}return R}equals(P){return P&&this._x===P._x&&this._y===P._y&&this._z===P._z}equalsWithEpsilon(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.c;return P&&(0,U.WithinEpsilon)(this._x,P._x,a)&&(0,U.WithinEpsilon)(this._y,P._y,a)&&(0,U.WithinEpsilon)(this._z,P._z,a)}equalsToFloats(P,a,R){return this._x===P&&this._y===a&&this._z===R}multiplyInPlace(P){return this._x*=P._x,this._y*=P._y,this._z*=P._z,this._isDirty=!0,this}multiply(P){return this.multiplyByFloats(P._x,P._y,P._z)}multiplyToRef(P,a){return a._x=this._x*P._x,a._y=this._y*P._y,a._z=this._z*P._z,a._isDirty=!0,a}multiplyByFloats(P,a,R){return new q(this._x*P,this._y*a,this._z*R)}divide(P){return new q(this._x/P._x,this._y/P._y,this._z/P._z)}divideToRef(P,a){return a._x=this._x/P._x,a._y=this._y/P._y,a._z=this._z/P._z,a._isDirty=!0,a}divideInPlace(P){return this._x=this._x/P._x,this._y=this._y/P._y,this._z=this._z/P._z,this._isDirty=!0,this}minimizeInPlace(P){return this.minimizeInPlaceFromFloats(P._x,P._y,P._z)}maximizeInPlace(P){return this.maximizeInPlaceFromFloats(P._x,P._y,P._z)}minimizeInPlaceFromFloats(P,a,R){return P<this._x&&(this.x=P),a<this._y&&(this.y=a),R<this._z&&(this.z=R),this}maximizeInPlaceFromFloats(P,a,R){return P>this._x&&(this.x=P),a>this._y&&(this.y=a),R>this._z&&(this.z=R),this}isNonUniformWithinEpsilon(P){const a=Math.abs(this._x),R=Math.abs(this._y);if(!(0,U.WithinEpsilon)(a,R,P))return!0;const S=Math.abs(this._z);return!(0,U.WithinEpsilon)(a,S,P)||!(0,U.WithinEpsilon)(R,S,P)}get isNonUniform(){const P=Math.abs(this._x);if(P!==Math.abs(this._y))return!0;return P!==Math.abs(this._z)}floorToRef(P){return P._x=Math.floor(this._x),P._y=Math.floor(this._y),P._z=Math.floor(this._z),P._isDirty=!0,P}floor(){return new q(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(P){return P._x=this._x-Math.floor(this._x),P._y=this._y-Math.floor(this._y),P._z=this._z-Math.floor(this._z),P._isDirty=!0,P}fract(){return new q(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(P){if("xyz"===(P=P.toLowerCase()))return this;const a=k.Oa[0].A(this);return this.x=a[P[0]],this.y=a[P[1]],this.z=a[P[2]],this}rotateByQuaternionToRef(P,a){return P.toRotationMatrix(k.Matrix[0]),q.TransformCoordinatesToRef(this,k.Matrix[0],a),a}rotateByQuaternionAroundPointToRef(P,a,R){return this.subtractToRef(a,k.Oa[0]),k.Oa[0].rotateByQuaternionToRef(P,k.Oa[0]),a.addToRef(k.Oa[0],R),R}cross(P){return q.CrossToRef(this,P,new q)}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){return this.normalizeToRef(new q)}normalizeToRef(P){const a=this.length();return 0===a||1===a?(P._x=this._x,P._y=this._y,P._z=this._z,P._isDirty=!0,P):this.scaleToRef(1/a,P)}clone(){return new q(this._x,this._y,this._z)}A(P){return this.Oj(P._x,P._y,P._z)}Oj(P,a,R){return this._x=P,this._y=a,this._z=R,this._isDirty=!0,this}set(P,a,R){return this.Oj(P,a,R)}yj(P){return this._x=this._y=this._z=P,this._isDirty=!0,this}static GetClipFactor(P,a,R,S){const A=q.Dot(P,R);return(A-S)/(A-q.Dot(a,R))}static GetAngleBetweenVectors(P,a,R){const S=P.normalizeToRef(k.Oa[1]),A=a.normalizeToRef(k.Oa[2]);let Z=q.Dot(S,A);Z=(0,U.Clamp)(Z,-1,1);const p=Math.acos(Z),j=k.Oa[3];return q.CrossToRef(S,A,j),q.Dot(j,R)>0?isNaN(p)?0:p:isNaN(p)?-Math.PI:-Math.acos(Z)}static GetAngleBetweenVectorsOnPlane(P,a,R){k.Oa[0].A(P);const S=k.Oa[0];k.Oa[1].A(a);const A=k.Oa[1];k.Oa[2].A(R);const Z=k.Oa[2],p=k.Oa[3],j=k.Oa[4];S.normalize(),A.normalize(),Z.normalize(),q.CrossToRef(Z,S,p),q.CrossToRef(p,Z,j);const Q=Math.atan2(q.Dot(A,p),q.Dot(A,j));return(0,U.NormalizeRadians)(Q)}static PitchYawRollToMoveBetweenPointsToRef(P,a,R){const S=x.Oa[0];return a.subtractToRef(P,S),R._y=Math.atan2(S.x,S.z)||0,R._x=Math.atan2(Math.sqrt(S.x**2+S.z**2),S.y)||0,R._z=0,R._isDirty=!0,R}static PitchYawRollToMoveBetweenPoints(P,a){const R=q.Zero();return q.PitchYawRollToMoveBetweenPointsToRef(P,a,R)}static SlerpToRef(P,a,R,A){R=(0,U.Clamp)(R,0,1);const Z=k.Oa[0],p=k.Oa[1];Z.A(P);const j=Z.length();Z.normalizeFromLength(j),p.A(a);const Q=p.length();p.normalizeFromLength(Q);const h=q.Dot(Z,p);let l,V;if(h<1-S.c){const P=Math.acos(h),a=1/Math.sin(P);l=Math.sin((1-R)*P)*a,V=Math.sin(R*P)*a}else l=1-R,V=R;return Z.scaleInPlace(l),p.scaleInPlace(V),A.A(Z).addInPlace(p),A.scaleInPlace((0,U.Lerp)(j,Q,R)),A}static SmoothToRef(P,a,R,S,A){return q.SlerpToRef(P,a,0===S?1:R/S,A),A}static ka(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new q(P[a],P[a+1],P[a+2])}static FromFloatArray(P,a){return q.ka(P,a)}static FromArrayToRef(P,a,R){return R._x=P[a],R._y=P[a+1],R._z=P[a+2],R._isDirty=!0,R}static FromFloatArrayToRef(P,a,R){return q.FromArrayToRef(P,a,R)}static FromFloatsToRef(P,a,R,S){return S.Oj(P,a,R),S}static Zero(){return new q(0,0,0)}static One(){return new q(1,1,1)}static Up(){return new q(0,1,0)}static get UpReadOnly(){return q._UpReadOnly}static get DownReadOnly(){return q._DownReadOnly}static get RightReadOnly(){return q._RightReadOnly}static get LeftReadOnly(){return q._LeftReadOnly}static get LeftHandedForwardReadOnly(){return q._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return q._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return q._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return q._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return q._ZeroReadOnly}static get OneReadOnly(){return q._OneReadOnly}static Down(){return new q(0,-1,0)}static Forward(){return new q(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new q(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new q(1,0,0)}static Left(){return new q(-1,0,0)}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new q((0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Oj((0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a))}static TransformCoordinates(P,a){const R=q.Zero();return q.TransformCoordinatesToRef(P,a,R),R}static TransformCoordinatesToRef(P,a,R){return q.TransformCoordinatesFromFloatsToRef(P._x,P._y,P._z,a,R),R}static TransformCoordinatesFromFloatsToRef(P,a,R,S,A){const Z=S.m,p=P*Z[0]+a*Z[4]+R*Z[8]+Z[12],j=P*Z[1]+a*Z[5]+R*Z[9]+Z[13],U=P*Z[2]+a*Z[6]+R*Z[10]+Z[14],Q=1/(P*Z[3]+a*Z[7]+R*Z[11]+Z[15]);return A._x=p*Q,A._y=j*Q,A._z=U*Q,A._isDirty=!0,A}static TransformNormal(P,a){const R=q.Zero();return q.TransformNormalToRef(P,a,R),R}static TransformNormalToRef(P,a,R){return this.TransformNormalFromFloatsToRef(P._x,P._y,P._z,a,R),R}static TransformNormalFromFloatsToRef(P,a,R,S,A){const Z=S.m;return A._x=P*Z[0]+a*Z[4]+R*Z[8],A._y=P*Z[1]+a*Z[5]+R*Z[9],A._z=P*Z[2]+a*Z[6]+R*Z[10],A._isDirty=!0,A}static CatmullRom(P,a,R,S,A){const Z=A*A,p=A*Z,j=.5*(2*a._x+(-P._x+R._x)*A+(2*P._x-5*a._x+4*R._x-S._x)*Z+(-P._x+3*a._x-3*R._x+S._x)*p),U=.5*(2*a._y+(-P._y+R._y)*A+(2*P._y-5*a._y+4*R._y-S._y)*Z+(-P._y+3*a._y-3*R._y+S._y)*p),Q=.5*(2*a._z+(-P._z+R._z)*A+(2*P._z-5*a._z+4*R._z-S._z)*Z+(-P._z+3*a._z-3*R._z+S._z)*p);return new q(j,U,Q)}static Clamp(P,a,R){const S=new q;return q.ClampToRef(P,a,R,S),S}static ClampToRef(P,a,R,S){let A=P._x;A=A>R._x?R._x:A,A=A<a._x?a._x:A;let Z=P._y;Z=Z>R._y?R._y:Z,Z=Z<a._y?a._y:Z;let p=P._z;return p=p>R._z?R._z:p,p=p<a._z?a._z:p,S.Oj(A,Z,p),S}static CheckExtends(P,a,R){a.minimizeInPlace(P),R.maximizeInPlace(P)}static Hermite(P,a,R,S,A){const Z=A*A,p=A*Z,j=2*p-3*Z+1,U=-2*p+3*Z,Q=p-2*Z+A,h=p-Z,l=P._x*j+R._x*U+a._x*Q+S._x*h,V=P._y*j+R._y*U+a._y*Q+S._y*h,f=P._z*j+R._z*U+a._z*Q+S._z*h;return new q(l,V,f)}static Hermite1stDerivative(P,a,R,S,A){const Z=new q;return this.Hermite1stDerivativeToRef(P,a,R,S,A,Z),Z}static Hermite1stDerivativeToRef(P,a,R,S,A,Z){const p=A*A;return Z._x=6*(p-A)*P._x+(3*p-4*A+1)*a._x+6*(-p+A)*R._x+(3*p-2*A)*S._x,Z._y=6*(p-A)*P._y+(3*p-4*A+1)*a._y+6*(-p+A)*R._y+(3*p-2*A)*S._y,Z._z=6*(p-A)*P._z+(3*p-4*A+1)*a._z+6*(-p+A)*R._z+(3*p-2*A)*S._z,Z._isDirty=!0,Z}static Lerp(P,a,R){const S=new q(0,0,0);return q.LerpToRef(P,a,R,S),S}static LerpToRef(P,a,R,S){return S._x=P._x+(a._x-P._x)*R,S._y=P._y+(a._y-P._y)*R,S._z=P._z+(a._z-P._z)*R,S._isDirty=!0,S}static Dot(P,a){return P._x*a._x+P._y*a._y+P._z*a._z}dot(P){return this._x*P._x+this._y*P._y+this._z*P._z}static Cross(P,a){const R=new q;return q.CrossToRef(P,a,R),R}static CrossToRef(P,a,R){const S=P._y*a._z-P._z*a._y,A=P._z*a._x-P._x*a._z,Z=P._x*a._y-P._y*a._x;return R.Oj(S,A,Z),R}static Normalize(P){const a=q.Zero();return q.NormalizeToRef(P,a),a}static NormalizeToRef(P,a){return P.normalizeToRef(a),a}static Project(P,a,R,S){const A=new q;return q.ProjectToRef(P,a,R,S,A),A}static ProjectToRef(P,a,R,S,A){var Z;const p=S.width,U=S.height,Q=S.x,h=S.y,l=k.Matrix[1],V=null===(Z=j.e.LastCreatedEngine)||void 0===Z?void 0:Z.isNDCHalfZRange,f=V?1:.5,O=V?0:.5;W.FromValuesToRef(p/2,0,0,0,0,-U/2,0,0,0,0,f,0,Q+p/2,U/2+h,O,1,l);const y=k.Matrix[0];return a.multiplyToRef(R,y),y.multiplyToRef(l,y),q.TransformCoordinatesToRef(P,y,A),A}static Reflect(P,a){return this.ReflectToRef(P,a,new q)}static ReflectToRef(P,a,R){const S=x.Oa[0];return S.A(a).scaleInPlace(2*q.Dot(P,a)),R.A(P).Ul(S)}static _UnprojectFromInvertedMatrixToRef(P,a,R){q.TransformCoordinatesToRef(P,a,R);const S=a.m,A=P._x*S[3]+P._y*S[7]+P._z*S[11]+S[15];return(0,U.WithinEpsilon)(A,1)&&R.scaleInPlace(1/A),R}static UnprojectFromTransform(P,a,R,S,A){return this.Unproject(P,a,R,S,A,W.IdentityReadOnly)}static Unproject(P,a,R,S,A,Z){const p=new q;return q.UnprojectToRef(P,a,R,S,A,Z,p),p}static UnprojectToRef(P,a,R,S,A,Z,p){return q.UnprojectFloatsToRef(P._x,P._y,P._z,a,R,S,A,Z,p),p}static UnprojectFloatsToRef(P,a,R,S,A,Z,p,U,Q){var h;const l=k.Matrix[0];Z.multiplyToRef(p,l),l.multiplyToRef(U,l),l.invert();const V=k.Oa[0];return V.x=P/S*2-1,V.y=-(a/A*2-1),null!==(h=j.e.LastCreatedEngine)&&void 0!==h&&h.isNDCHalfZRange?V.z=R:V.z=2*R-1,q._UnprojectFromInvertedMatrixToRef(V,l,Q),Q}static Minimize(P,a){const R=new q;return R.A(P),R.minimizeInPlace(a),R}static Maximize(P,a){const R=new q;return R.A(P),R.maximizeInPlace(a),R}static Distance(P,a){return Math.sqrt(q.DistanceSquared(P,a))}static DistanceSquared(P,a){const R=P._x-a._x,S=P._y-a._y,A=P._z-a._z;return R*R+S*S+A*A}static ProjectOnTriangleToRef(P,a,R,A,Z){const p=k.Oa[0],j=k.Oa[1],Q=k.Oa[2],h=k.Oa[3],l=k.Oa[4];R.subtractToRef(a,p),A.subtractToRef(a,j),A.subtractToRef(R,Q);const V=p.length(),f=j.length(),O=Q.length();if(V<S.c||f<S.c||O<S.c)return Z.A(a),q.Distance(P,a);P.subtractToRef(a,l),q.CrossToRef(p,j,h);const y=h.length();if(y<S.c)return Z.A(a),q.Distance(P,a);h.normalizeFromLength(y);let t=l.length();if(t<S.c)return Z.A(a),0;l.normalizeFromLength(t);const W=q.Dot(h,l),x=k.Oa[5],s=k.Oa[6];x.A(h).scaleInPlace(-t*W),s.A(P).addInPlace(x);const d=k.Oa[4],G=k.Oa[5],H=k.Oa[7],mP=k.Oa[8];d.A(p).scaleInPlace(1/V),mP.A(j).scaleInPlace(1/f),d.addInPlace(mP).scaleInPlace(-1),G.A(p).scaleInPlace(-1/V),mP.A(Q).scaleInPlace(1/O),G.addInPlace(mP).scaleInPlace(-1),H.A(Q).scaleInPlace(-1/O),mP.A(j).scaleInPlace(-1/f),H.addInPlace(mP).scaleInPlace(-1);const N=k.Oa[9];let D;N.A(s).Ul(a),q.CrossToRef(d,N,mP),D=q.Dot(mP,h);const L=D;N.A(s).Ul(R),q.CrossToRef(G,N,mP),D=q.Dot(mP,h);const c=D;N.A(s).Ul(A),q.CrossToRef(H,N,mP),D=q.Dot(mP,h);const u=D,Y=k.Oa[10];let J,n;L>0&&c<0?(Y.A(p),J=a,n=R):c>0&&u<0?(Y.A(Q),J=R,n=A):(Y.A(j).scaleInPlace(-1),J=A,n=a);const b=k.Oa[9],B=k.Oa[4];J.subtractToRef(s,mP),n.subtractToRef(s,b),q.CrossToRef(mP,b,B);if(!(q.Dot(B,h)<0))return Z.A(s),Math.abs(t*W);const o=k.Oa[5];q.CrossToRef(Y,B,o),o.normalize();const r=k.Oa[9];r.A(J).Ul(s);const v=r.length();if(v<S.c)return Z.A(J),q.Distance(P,J);r.normalizeFromLength(v);const M=q.Dot(o,r),E=k.Oa[7];E.A(s).addInPlace(o.scaleInPlace(v*M)),mP.A(E).Ul(J),t=Y.length(),Y.normalizeFromLength(t);let e=q.Dot(mP,Y)/Math.max(t,S.c);return e=(0,U.Clamp)(e,0,1),E.A(J).addInPlace(Y.scaleInPlace(e*t)),Z.A(E),q.Distance(P,E)}static Center(P,a){return q.CenterToRef(P,a,q.Zero())}static CenterToRef(P,a,R){return R.Oj((P._x+a._x)/2,(P._y+a._y)/2,(P._z+a._z)/2)}static RotationFromAxis(P,a,R){const S=new q;return q.RotationFromAxisToRef(P,a,R,S),S}static RotationFromAxisToRef(P,a,R,S){const A=k.Quaternion[0];return t.RotationQuaternionFromAxisToRef(P,a,R,A),A.toEulerAnglesToRef(S),S}}q._V8PerformanceHack=new q(.5,.5,.5),q._UpReadOnly=q.Up(),q._DownReadOnly=q.Down(),q._LeftHandedForwardReadOnly=q.Forward(!1),q._RightHandedForwardReadOnly=q.Forward(!0),q._LeftHandedBackwardReadOnly=q.Backward(!1),q._RightHandedBackwardReadOnly=q.Backward(!0),q._RightReadOnly=q.Right(),q._LeftReadOnly=q.Left(),q._ZeroReadOnly=q.Zero(),q._OneReadOnly=q.One(),Object.defineProperties(q.prototype,{dimension:{value:[3]},rank:{value:1}});class y{get x(){return this._x}set x(P){this._x=P,this._isDirty=!0}get y(){return this._y}set y(P){this._y=P,this._isDirty=!0}get z(){return this._z}set z(P){this._z=P,this._isDirty=!0}get w(){return this._w}set w(P){this._w=P,this._isDirty=!0}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=P,this._y=a,this._z=R,this._w=S}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let P=f(this._x);return P=397*P^f(this._y),P=397*P^f(this._z),P=397*P^f(this._w),P}pj(){return[this._x,this._y,this._z,this._w]}toArray(P,a){return void 0===a&&(a=0),P[a]=this._x,P[a+1]=this._y,P[a+2]=this._z,P[a+3]=this._w,this}fR(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y.FromArrayToRef(P,a,this),this}addInPlace(P){return this.x+=P._x,this.y+=P._y,this.z+=P._z,this.w+=P._w,this}addInPlaceFromFloats(P,a,R,S){return this.x+=P,this.y+=a,this.z+=R,this.w+=S,this}add(P){return new y(this._x+P.x,this._y+P.y,this._z+P.z,this._w+P.w)}addToRef(P,a){return a.x=this._x+P.x,a.y=this._y+P.y,a.z=this._z+P.z,a.w=this._w+P.w,a}Ul(P){return this.x-=P.x,this.y-=P.y,this.z-=P.z,this.w-=P.w,this}qa(P){return new y(this._x-P.x,this._y-P.y,this._z-P.z,this._w-P.w)}subtractToRef(P,a){return a.x=this._x-P.x,a.y=this._y-P.y,a.z=this._z-P.z,a.w=this._w-P.w,a}subtractFromFloats(P,a,R,S){return new y(this._x-P,this._y-a,this._z-R,this._w-S)}subtractFromFloatsToRef(P,a,R,S,A){return A.x=this._x-P,A.y=this._y-a,A.z=this._z-R,A.w=this._w-S,A}negate(){return new y(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(P){return P.x=-this._x,P.y=-this._y,P.z=-this._z,P.w=-this._w,P}scaleInPlace(P){return this.x*=P,this.y*=P,this.z*=P,this.w*=P,this}scale(P){return new y(this._x*P,this._y*P,this._z*P,this._w*P)}scaleToRef(P,a){return a.x=this._x*P,a.y=this._y*P,a.z=this._z*P,a.w=this._w*P,a}scaleAndAddToRef(P,a){return a.x+=this._x*P,a.y+=this._y*P,a.z+=this._z*P,a.w+=this._w*P,a}equals(P){return P&&this._x===P.x&&this._y===P.y&&this._z===P.z&&this._w===P.w}equalsWithEpsilon(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.c;return P&&(0,U.WithinEpsilon)(this._x,P.x,a)&&(0,U.WithinEpsilon)(this._y,P.y,a)&&(0,U.WithinEpsilon)(this._z,P.z,a)&&(0,U.WithinEpsilon)(this._w,P.w,a)}equalsToFloats(P,a,R,S){return this._x===P&&this._y===a&&this._z===R&&this._w===S}multiplyInPlace(P){return this.x*=P.x,this.y*=P.y,this.z*=P.z,this.w*=P.w,this}multiply(P){return new y(this._x*P.x,this._y*P.y,this._z*P.z,this._w*P.w)}multiplyToRef(P,a){return a.x=this._x*P.x,a.y=this._y*P.y,a.z=this._z*P.z,a.w=this._w*P.w,a}multiplyByFloats(P,a,R,S){return new y(this._x*P,this._y*a,this._z*R,this._w*S)}divide(P){return new y(this._x/P.x,this._y/P.y,this._z/P.z,this._w/P.w)}divideToRef(P,a){return a.x=this._x/P.x,a.y=this._y/P.y,a.z=this._z/P.z,a.w=this._w/P.w,a}divideInPlace(P){return this.divideToRef(P,this)}minimizeInPlace(P){return P.x<this._x&&(this.x=P.x),P.y<this._y&&(this.y=P.y),P.z<this._z&&(this.z=P.z),P.w<this._w&&(this.w=P.w),this}maximizeInPlace(P){return P.x>this._x&&(this.x=P.x),P.y>this._y&&(this.y=P.y),P.z>this._z&&(this.z=P.z),P.w>this._w&&(this.w=P.w),this}minimizeInPlaceFromFloats(P,a,R,S){return this.x=Math.min(P,this._x),this.y=Math.min(a,this._y),this.z=Math.min(R,this._z),this.w=Math.min(S,this._w),this}maximizeInPlaceFromFloats(P,a,R,S){return this.x=Math.max(P,this._x),this.y=Math.max(a,this._y),this.z=Math.max(R,this._z),this.w=Math.max(S,this._w),this}floorToRef(P){return P.x=Math.floor(this._x),P.y=Math.floor(this._y),P.z=Math.floor(this._z),P.w=Math.floor(this._w),P}floor(){return new y(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(P){return P.x=this._x-Math.floor(this._x),P.y=this._y-Math.floor(this._y),P.z=this._z-Math.floor(this._z),P.w=this._w-Math.floor(this._w),P}fract(){return new y(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){return this.normalizeToRef(new y)}normalizeToRef(P){const a=this.length();return 0===a||1===a?(P.x=this._x,P.y=this._y,P.z=this._z,P.w=this._w,P):this.scaleToRef(1/a,P)}toVector3(){return new q(this._x,this._y,this._z)}clone(){return new y(this._x,this._y,this._z,this._w)}A(P){return this.x=P.x,this.y=P.y,this.z=P.z,this.w=P.w,this}Oj(P,a,R,S){return this.x=P,this.y=a,this.z=R,this.w=S,this}set(P,a,R,S){return this.Oj(P,a,R,S)}yj(P){return this.x=this.y=this.z=this.w=P,this}dot(P){return this._x*P.x+this._y*P.y+this._z*P.z+this._w*P.w}static ka(P,a){return a||(a=0),new y(P[a],P[a+1],P[a+2],P[a+3])}static FromArrayToRef(P,a,R){return R.x=P[a],R.y=P[a+1],R.z=P[a+2],R.w=P[a+3],R}static FromFloatArrayToRef(P,a,R){return y.FromArrayToRef(P,a,R),R}static FromFloatsToRef(P,a,R,S,A){return A.x=P,A.y=a,A.z=R,A.w=S,A}static Zero(){return new y(0,0,0,0)}static One(){return new y(1,1,1,1)}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new y((0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,R=arguments.length>2?arguments[2]:void 0;return R.x=(0,U.RandomRange)(P,a),R.y=(0,U.RandomRange)(P,a),R.z=(0,U.RandomRange)(P,a),R.w=(0,U.RandomRange)(P,a),R}static Clamp(P,a,R){return y.ClampToRef(P,a,R,new y)}static ClampToRef(P,a,R,S){return S.x=(0,U.Clamp)(P.x,a.x,R.x),S.y=(0,U.Clamp)(P.y,a.y,R.y),S.z=(0,U.Clamp)(P.z,a.z,R.z),S.w=(0,U.Clamp)(P.w,a.w,R.w),S}static CheckExtends(P,a,R){a.minimizeInPlace(P),R.maximizeInPlace(P)}static get ZeroReadOnly(){return y._ZeroReadOnly}static Normalize(P){return y.NormalizeToRef(P,new y)}static NormalizeToRef(P,a){return P.normalizeToRef(a),a}static Minimize(P,a){const R=new y;return R.A(P),R.minimizeInPlace(a),R}static Maximize(P,a){const R=new y;return R.A(P),R.maximizeInPlace(a),R}static Distance(P,a){return Math.sqrt(y.DistanceSquared(P,a))}static DistanceSquared(P,a){const R=P.x-a.x,S=P.y-a.y,A=P.z-a.z,Z=P.w-a.w;return R*R+S*S+A*A+Z*Z}static Center(P,a){return y.CenterToRef(P,a,new y)}static CenterToRef(P,a,R){return R.x=(P.x+a.x)/2,R.y=(P.y+a.y)/2,R.z=(P.z+a.z)/2,R.w=(P.w+a.w)/2,R}static TransformCoordinates(P,a){return y.TransformCoordinatesToRef(P,a,new y)}static TransformCoordinatesToRef(P,a,R){return y.TransformCoordinatesFromFloatsToRef(P._x,P._y,P._z,a,R),R}static TransformCoordinatesFromFloatsToRef(P,a,R,S,A){const Z=S.m,p=P*Z[0]+a*Z[4]+R*Z[8]+Z[12],j=P*Z[1]+a*Z[5]+R*Z[9]+Z[13],U=P*Z[2]+a*Z[6]+R*Z[10]+Z[14],Q=P*Z[3]+a*Z[7]+R*Z[11]+Z[15];return A.x=p,A.y=j,A.z=U,A.w=Q,A}static TransformNormal(P,a){return y.TransformNormalToRef(P,a,new y)}static TransformNormalToRef(P,a,R){const S=a.m,A=P.x*S[0]+P.y*S[4]+P.z*S[8],Z=P.x*S[1]+P.y*S[5]+P.z*S[9],p=P.x*S[2]+P.y*S[6]+P.z*S[10];return R.x=A,R.y=Z,R.z=p,R.w=P.w,R}static TransformNormalFromFloatsToRef(P,a,R,S,A,Z){const p=A.m;return Z.x=P*p[0]+a*p[4]+R*p[8],Z.y=P*p[1]+a*p[5]+R*p[9],Z.z=P*p[2]+a*p[6]+R*p[10],Z.w=S,Z}static FromVector3(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new y(P._x,P._y,P._z,a)}static Dot(P,a){return P.x*a.x+P.y*a.y+P.z*a.z+P.w*a.w}}y._V8PerformanceHack=new y(.5,.5,.5,.5),y._ZeroReadOnly=y.Zero(),Object.defineProperties(y.prototype,{dimension:{value:[4]},rank:{value:1}});class t{get x(){return this._x}set x(P){this._x=P,this._isDirty=!0}get y(){return this._y}set y(P){this._y=P,this._isDirty=!0}get z(){return this._z}set z(P){this._z=P,this._isDirty=!0}get w(){return this._w}set w(P){this._w=P,this._isDirty=!0}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=P,this._y=a,this._z=R,this._w=S}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let P=f(this._x);return P=397*P^f(this._y),P=397*P^f(this._z),P=397*P^f(this._w),P}pj(){return[this._x,this._y,this._z,this._w]}toArray(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[a]=this._x,P[a+1]=this._y,P[a+2]=this._z,P[a+3]=this._w,this}fR(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(P,a,this)}equals(P){return P&&this._x===P._x&&this._y===P._y&&this._z===P._z&&this._w===P._w}equalsWithEpsilon(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.c;return P&&(0,U.WithinEpsilon)(this._x,P._x,a)&&(0,U.WithinEpsilon)(this._y,P._y,a)&&(0,U.WithinEpsilon)(this._z,P._z,a)&&(0,U.WithinEpsilon)(this._w,P._w,a)}isApprox(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.c;return P&&((0,U.WithinEpsilon)(this._x,P._x,a)&&(0,U.WithinEpsilon)(this._y,P._y,a)&&(0,U.WithinEpsilon)(this._z,P._z,a)&&(0,U.WithinEpsilon)(this._w,P._w,a)||(0,U.WithinEpsilon)(this._x,-P._x,a)&&(0,U.WithinEpsilon)(this._y,-P._y,a)&&(0,U.WithinEpsilon)(this._z,-P._z,a)&&(0,U.WithinEpsilon)(this._w,-P._w,a))}clone(){return new t(this._x,this._y,this._z,this._w)}A(P){return this._x=P._x,this._y=P._y,this._z=P._z,this._w=P._w,this._isDirty=!0,this}Oj(P,a,R,S){return this._x=P,this._y=a,this._z=R,this._w=S,this._isDirty=!0,this}set(P,a,R,S){return this.Oj(P,a,R,S)}yj(P){return this.Oj(P,P,P,P)}add(P){return new t(this._x+P._x,this._y+P._y,this._z+P._z,this._w+P._w)}addInPlace(P){return this._x+=P._x,this._y+=P._y,this._z+=P._z,this._w+=P._w,this._isDirty=!0,this}addToRef(P,a){return a._x=this._x+P._x,a._y=this._y+P._y,a._z=this._z+P._z,a._w=this._w+P._w,a._isDirty=!0,a}addInPlaceFromFloats(P,a,R,S){return this._x+=P,this._y+=a,this._z+=R,this._w+=S,this._isDirty=!0,this}subtractToRef(P,a){return a._x=this._x-P._x,a._y=this._y-P._y,a._z=this._z-P._z,a._w=this._w-P._w,a._isDirty=!0,a}subtractFromFloats(P,a,R,S){return this.subtractFromFloatsToRef(P,a,R,S,new t)}subtractFromFloatsToRef(P,a,R,S,A){return A._x=this._x-P,A._y=this._y-a,A._z=this._z-R,A._w=this._w-S,A._isDirty=!0,A}qa(P){return new t(this._x-P._x,this._y-P._y,this._z-P._z,this._w-P._w)}Ul(P){return this._x-=P._x,this._y-=P._y,this._z-=P._z,this._w-=P._w,this._isDirty=!0,this}scale(P){return new t(this._x*P,this._y*P,this._z*P,this._w*P)}scaleToRef(P,a){return a._x=this._x*P,a._y=this._y*P,a._z=this._z*P,a._w=this._w*P,a._isDirty=!0,a}scaleInPlace(P){return this._x*=P,this._y*=P,this._z*=P,this._w*=P,this._isDirty=!0,this}scaleAndAddToRef(P,a){return a._x+=this._x*P,a._y+=this._y*P,a._z+=this._z*P,a._w+=this._w*P,a._isDirty=!0,a}multiply(P){const a=new t(0,0,0,1);return this.multiplyToRef(P,a),a}multiplyToRef(P,a){const R=this._x*P._w+this._y*P._z-this._z*P._y+this._w*P._x,S=-this._x*P._z+this._y*P._w+this._z*P._x+this._w*P._y,A=this._x*P._y-this._y*P._x+this._z*P._w+this._w*P._z,Z=-this._x*P._x-this._y*P._y-this._z*P._z+this._w*P._w;return a.Oj(R,S,A,Z),a}multiplyInPlace(P){return this.multiplyToRef(P,this)}multiplyByFloats(P,a,R,S){return this._x*=P,this._y*=a,this._z*=R,this._w*=S,this._isDirty=!0,this}divide(P){throw new ReferenceError("Can not divide a quaternion")}divideToRef(P,a){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(P){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new t)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(P){return P._x=-this._x,P._y=-this._y,P._z=-this._z,P._w=-this._w,P._isDirty=!0,P}equalsToFloats(P,a,R,S){return this._x===P&&this._y===a&&this._z===R&&this._w===S}floorToRef(P){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(P){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(P){return P.Oj(-this._x,-this._y,-this._z,this._w),P}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new t(-this._x,-this._y,-this._z,this._w)}invert(){const P=this.conjugate(),a=this.lengthSquared();return 0==a||1==a||P.scaleInPlace(1/a),P}invertInPlace(){this.conjugateInPlace();const P=this.lengthSquared();return 0==P||1==P||this.scaleInPlace(1/P),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){const P=new t(0,0,0,1);return this.normalizeToRef(P),P}normalizeToRef(P){const a=this.length();return 0===a||1===a?P.Oj(this._x,this._y,this._z,this._w):this.scaleToRef(1/a,P)}toEulerAngles(){const P=q.Zero();return this.toEulerAnglesToRef(P),P}toEulerAnglesToRef(P){const a=this._z,R=this._x,S=this._y,A=this._w,Z=S*a-R*A,p=.4999999;if(Z<-p)P._y=2*Math.atan2(S,A),P._x=Math.PI/2,P._z=0,P._isDirty=!0;else if(Z>p)P._y=2*Math.atan2(S,A),P._x=-Math.PI/2,P._z=0,P._isDirty=!0;else{const p=A*A,j=a*a,U=R*R,Q=S*S;P._z=Math.atan2(2*(R*S+a*A),-j-U+Q+p),P._x=Math.asin(-2*Z),P._y=Math.atan2(2*(a*R+S*A),j-U-Q+p),P._isDirty=!0}return P}toAlphaBetaGammaToRef(P){const a=this._z,R=this._x,S=this._y,A=this._w,Z=Math.sqrt(R*R+S*S),p=Math.sqrt(a*a+A*A),j=2*Math.atan2(Z,p),U=2*Math.atan2(a,A),Q=2*Math.atan2(S,R),h=(U+Q)/2,l=(U-Q)/2;return P.set(l,j,h),P}toRotationMatrix(P){return W.FromQuaternionToRef(this,P),P}fromRotationMatrix(P){return t.FromRotationMatrixToRef(P,this),this}dot(P){return this._x*P._x+this._y*P._y+this._z*P._z+this._w*P._w}toAxisAngle(){const P=q.Zero();return{axis:P,angle:this.toAxisAngleToRef(P)}}toAxisAngleToRef(P){let a=0;const R=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),S=this._w;return R>0?(a=2*Math.atan2(R,S),P.set(this._x/R,this._y/R,this._z/R)):(a=0,P.set(1,0,0)),a}static FromRotationMatrix(P){const a=new t;return t.FromRotationMatrixToRef(P,a),a}static FromRotationMatrixToRef(P,a){const R=P.m,S=R[0],A=R[4],Z=R[8],p=R[1],j=R[5],U=R[9],Q=R[2],h=R[6],l=R[10],V=S+j+l;let f;return V>0?(f=.5/Math.sqrt(V+1),a._w=.25/f,a._x=(h-U)*f,a._y=(Z-Q)*f,a._z=(p-A)*f,a._isDirty=!0):S>j&&S>l?(f=2*Math.sqrt(1+S-j-l),a._w=(h-U)/f,a._x=.25*f,a._y=(A+p)/f,a._z=(Z+Q)/f,a._isDirty=!0):j>l?(f=2*Math.sqrt(1+j-S-l),a._w=(Z-Q)/f,a._x=(A+p)/f,a._y=.25*f,a._z=(U+h)/f,a._isDirty=!0):(f=2*Math.sqrt(1+l-S-j),a._w=(p-A)/f,a._x=(Z+Q)/f,a._y=(U+h)/f,a._z=.25*f,a._isDirty=!0),a}static Dot(P,a){return P._x*a._x+P._y*a._y+P._z*a._z+P._w*a._w}static AreClose(P,a){let R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const S=t.Dot(P,a);return 1-S*S<=R}static SmoothToRef(P,a,R,S,A){let Z=0===S?1:R/S;return Z=(0,U.Clamp)(Z,0,1),t.SlerpToRef(P,a,Z,A),A}static Zero(){return new t(0,0,0,0)}static Inverse(P){return new t(-P._x,-P._y,-P._z,P._w)}static InverseToRef(P,a){return a.set(-P._x,-P._y,-P._z,P._w),a}static Identity(){return new t(0,0,0,1)}static IsIdentity(P){return P&&0===P._x&&0===P._y&&0===P._z&&1===P._w}static RotationAxis(P,a){return t.RotationAxisToRef(P,a,new t)}static RotationAxisToRef(P,a,R){R._w=Math.cos(a/2);const S=Math.sin(a/2)/P.length();return R._x=P._x*S,R._y=P._y*S,R._z=P._z*S,R._isDirty=!0,R}static ka(P,a){return a||(a=0),new t(P[a],P[a+1],P[a+2],P[a+3])}static FromArrayToRef(P,a,R){return R._x=P[a],R._y=P[a+1],R._z=P[a+2],R._w=P[a+3],R._isDirty=!0,R}static FromFloatsToRef(P,a,R,S,A){return A.Oj(P,a,R,S),A}static FromEulerAngles(P,a,R){const S=new t;return t.RotationYawPitchRollToRef(a,P,R,S),S}static FromEulerAnglesToRef(P,a,R,S){return t.RotationYawPitchRollToRef(a,P,R,S),S}static FromEulerVector(P){const a=new t;return t.RotationYawPitchRollToRef(P._y,P._x,P._z,a),a}static FromEulerVectorToRef(P,a){return t.RotationYawPitchRollToRef(P._y,P._x,P._z,a),a}static FromUnitVectorsToRef(P,a,R){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:S.c;const Z=q.Dot(P,a)+1;return Z<A?Math.abs(P.x)>Math.abs(P.z)?R.set(-P.y,P.x,0,0):R.set(0,-P.z,P.y,0):(q.CrossToRef(P,a,x.Oa[0]),R.set(x.Oa[0].x,x.Oa[0].y,x.Oa[0].z,Z)),R.normalize()}static RotationYawPitchRoll(P,a,R){const S=new t;return t.RotationYawPitchRollToRef(P,a,R,S),S}static RotationYawPitchRollToRef(P,a,R,S){const A=.5*R,Z=.5*a,p=.5*P,j=Math.sin(A),U=Math.cos(A),Q=Math.sin(Z),h=Math.cos(Z),l=Math.sin(p),V=Math.cos(p);return S._x=V*Q*U+l*h*j,S._y=l*h*U-V*Q*j,S._z=V*h*j-l*Q*U,S._w=V*h*U+l*Q*j,S._isDirty=!0,S}static RotationAlphaBetaGamma(P,a,R){const S=new t;return t.RotationAlphaBetaGammaToRef(P,a,R,S),S}static RotationAlphaBetaGammaToRef(P,a,R,S){const A=.5*(R+P),Z=.5*(R-P),p=.5*a;return S._x=Math.cos(Z)*Math.sin(p),S._y=Math.sin(Z)*Math.sin(p),S._z=Math.sin(A)*Math.cos(p),S._w=Math.cos(A)*Math.cos(p),S._isDirty=!0,S}static RotationQuaternionFromAxis(P,a,R){const S=new t(0,0,0,0);return t.RotationQuaternionFromAxisToRef(P,a,R,S),S}static RotationQuaternionFromAxisToRef(P,a,R,S){const A=k.Matrix[0];return P=P.normalizeToRef(k.Oa[0]),a=a.normalizeToRef(k.Oa[1]),R=R.normalizeToRef(k.Oa[2]),W.FromXYZAxesToRef(P,a,R,A),t.FromRotationMatrixToRef(A,S),S}static FromLookDirectionLH(P,a){const R=new t;return t.FromLookDirectionLHToRef(P,a,R),R}static FromLookDirectionLHToRef(P,a,R){const S=k.Matrix[0];return W.LookDirectionLHToRef(P,a,S),t.FromRotationMatrixToRef(S,R),R}static FromLookDirectionRH(P,a){const R=new t;return t.FromLookDirectionRHToRef(P,a,R),R}static FromLookDirectionRHToRef(P,a,R){const S=k.Matrix[0];return W.LookDirectionRHToRef(P,a,S),t.FromRotationMatrixToRef(S,R)}static Slerp(P,a,R){const S=t.Identity();return t.SlerpToRef(P,a,R,S),S}static SlerpToRef(P,a,R,S){let A,Z,p=P._x*a._x+P._y*a._y+P._z*a._z+P._w*a._w,j=!1;if(p<0&&(j=!0,p=-p),p>.999999)Z=1-R,A=j?-R:R;else{const P=Math.acos(p),a=1/Math.sin(P);Z=Math.sin((1-R)*P)*a,A=j?-Math.sin(R*P)*a:Math.sin(R*P)*a}return S._x=Z*P._x+A*a._x,S._y=Z*P._y+A*a._y,S._z=Z*P._z+A*a._z,S._w=Z*P._w+A*a._w,S._isDirty=!0,S}static Hermite(P,a,R,S,A){const Z=A*A,p=A*Z,j=2*p-3*Z+1,U=-2*p+3*Z,Q=p-2*Z+A,h=p-Z,l=P._x*j+R._x*U+a._x*Q+S._x*h,V=P._y*j+R._y*U+a._y*Q+S._y*h,f=P._z*j+R._z*U+a._z*Q+S._z*h,O=P._w*j+R._w*U+a._w*Q+S._w*h;return new t(l,V,f,O)}static Hermite1stDerivative(P,a,R,S,A){const Z=new t;return this.Hermite1stDerivativeToRef(P,a,R,S,A,Z),Z}static Hermite1stDerivativeToRef(P,a,R,S,A,Z){const p=A*A;return Z._x=6*(p-A)*P._x+(3*p-4*A+1)*a._x+6*(-p+A)*R._x+(3*p-2*A)*S._x,Z._y=6*(p-A)*P._y+(3*p-4*A+1)*a._y+6*(-p+A)*R._y+(3*p-2*A)*S._y,Z._z=6*(p-A)*P._z+(3*p-4*A+1)*a._z+6*(-p+A)*R._z+(3*p-2*A)*S._z,Z._w=6*(p-A)*P._w+(3*p-4*A+1)*a._w+6*(-p+A)*R._w+(3*p-2*A)*S._w,Z._isDirty=!0,Z}static Normalize(P){const a=t.Zero();return t.NormalizeToRef(P,a),a}static NormalizeToRef(P,a){return P.normalizeToRef(a),a}static Clamp(P,a,R){const S=new t;return t.ClampToRef(P,a,R,S),S}static ClampToRef(P,a,R,S){return S.Oj((0,U.Clamp)(P.x,a.x,R.x),(0,U.Clamp)(P.y,a.y,R.y),(0,U.Clamp)(P.z,a.z,R.z),(0,U.Clamp)(P.w,a.w,R.w))}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new t((0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Oj((0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a),(0,U.RandomRange)(P,a))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(P,a){return Math.sqrt(t.DistanceSquared(P,a))}static DistanceSquared(P,a){const R=P.x-a.x,S=P.y-a.y,A=P.z-a.z,Z=P.w-a.w;return R*R+S*S+A*A+Z*Z}static Center(P,a){return t.CenterToRef(P,a,t.Zero())}static CenterToRef(P,a,R){return R.Oj((P.x+a.x)/2,(P.y+a.y)/2,(P.z+a.z)/2,(P.w+a.w)/2)}}t._V8PerformanceHack=new t(.5,.5,.5,.5),Object.defineProperties(t.prototype,{dimension:{value:[4]},rank:{value:1}});class W{static get Use64Bits(){return p.b.MatrixUse64Bits}get m(){return this.Pj}markAsUpdated(){this.updateFlag=Q._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(P){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1],R=arguments.length>2&&void 0!==arguments[2]&&arguments[2],S=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=P,this._isIdentity3x2=P||R,this._isIdentityDirty=!this._isIdentity&&a,this._isIdentity3x2Dirty=!this._isIdentity3x2&&S}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,p.b.MatrixTrackPrecisionChange&&p.b.MatrixTrackedMatrices.push(this),this.Pj=new p.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const P=this.Pj;this._isIdentity=1===P[0]&&0===P[1]&&0===P[2]&&0===P[3]&&0===P[4]&&1===P[5]&&0===P[6]&&0===P[7]&&0===P[8]&&0===P[9]&&1===P[10]&&0===P[11]&&0===P[12]&&0===P[13]&&0===P[14]&&1===P[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Pj[0]||1!==this.Pj[5]||1!==this.Pj[15]||0!==this.Pj[1]||0!==this.Pj[2]||0!==this.Pj[3]||0!==this.Pj[4]||0!==this.Pj[6]||0!==this.Pj[7]||0!==this.Pj[8]||0!==this.Pj[9]||0!==this.Pj[10]||0!==this.Pj[11]||0!==this.Pj[12]||0!==this.Pj[13]||0!==this.Pj[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const P=this.Pj,a=P[0],R=P[1],S=P[2],A=P[3],Z=P[4],p=P[5],j=P[6],U=P[7],Q=P[8],h=P[9],l=P[10],V=P[11],f=P[12],O=P[13],q=P[14],y=P[15],t=l*y-q*V,W=h*y-O*V,k=h*q-O*l,x=Q*y-f*V,s=Q*q-l*f,d=Q*O-f*h;return a*+(p*t-j*W+U*k)+R*-(Z*t-j*x+U*s)+S*+(Z*W-p*x+U*d)+A*-(Z*k-p*s+j*d)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!P)return this.Pj;const R=this.Pj;for(let S=0;S<16;S++)P[a+S]=R[S];return this}pj(){return this.Pj}fR(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return W.FromArrayToRef(P,a,this)}Oj(){for(var P=arguments.length,a=new Array(P),R=0;R<P;R++)a[R]=arguments[R];return W.FromArrayToRef(a,0,this)}set(){const P=this.Pj;for(let a=0;a<16;a++)P[a]=a<0||arguments.length<=a?void 0:arguments[a];return this.markAsUpdated(),this}yj(P){const a=this.Pj;for(let R=0;R<16;R++)a[R]=P;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return W.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(P){const a=new W;return this.addToRef(P,a),a}addToRef(P,a){const R=this.Pj,S=a.Pj,A=P.m;for(let Z=0;Z<16;Z++)S[Z]=R[Z]+A[Z];return a.markAsUpdated(),a}addToSelf(P){const a=this.Pj,R=P.m;return a[0]+=R[0],a[1]+=R[1],a[2]+=R[2],a[3]+=R[3],a[4]+=R[4],a[5]+=R[5],a[6]+=R[6],a[7]+=R[7],a[8]+=R[8],a[9]+=R[9],a[10]+=R[10],a[11]+=R[11],a[12]+=R[12],a[13]+=R[13],a[14]+=R[14],a[15]+=R[15],this.markAsUpdated(),this}addInPlace(P){const a=this.Pj,R=P.m;for(let S=0;S<16;S++)a[S]+=R[S];return this.markAsUpdated(),this}addInPlaceFromFloats(){const P=this.Pj;for(let a=0;a<16;a++)P[a]+=a<0||arguments.length<=a?void 0:arguments[a];return this.markAsUpdated(),this}qa(P){const a=this.Pj,R=P.m;for(let S=0;S<16;S++)a[S]-=R[S];return this.markAsUpdated(),this}subtractToRef(P,a){const R=this.Pj,S=P.m,A=a.Pj;for(let Z=0;Z<16;Z++)A[Z]=R[Z]-S[Z];return a.markAsUpdated(),a}Ul(P){const a=this.Pj,R=P.m;for(let S=0;S<16;S++)a[S]-=R[S];return this.markAsUpdated(),this}subtractFromFloats(){for(var P=arguments.length,a=new Array(P),R=0;R<P;R++)a[R]=arguments[R];return this.subtractFromFloatsToRef(...a,new W)}subtractFromFloatsToRef(){for(var P=arguments.length,a=new Array(P),R=0;R<P;R++)a[R]=arguments[R];const S=a.pop(),A=this.Pj,Z=S.Pj,p=a;for(let j=0;j<16;j++)Z[j]=A[j]-p[j];return S.markAsUpdated(),S}invertToRef(P){return!0===this._isIdentity?(W.IdentityToRef(P),P):(V(this,P.pj())?P.markAsUpdated():P.A(this),P)}addAtIndex(P,a){return this.Pj[P]+=a,this.markAsUpdated(),this}multiplyAtIndex(P,a){return this.Pj[P]*=a,this.markAsUpdated(),this}setTranslationFromFloats(P,a,R){return this.Pj[12]=P,this.Pj[13]=a,this.Pj[14]=R,this.markAsUpdated(),this}addTranslationFromFloats(P,a,R){return this.Pj[12]+=P,this.Pj[13]+=a,this.Pj[14]+=R,this.markAsUpdated(),this}setTranslation(P){return this.setTranslationFromFloats(P._x,P._y,P._z)}getTranslation(){return new q(this.Pj[12],this.Pj[13],this.Pj[14])}getTranslationToRef(P){return P.x=this.Pj[12],P.y=this.Pj[13],P.z=this.Pj[14],P}removeRotationAndScaling(){const P=this.m;return W.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,P[12],P[13],P[14],P[15],this),this._updateIdentityStatus(0===P[12]&&0===P[13]&&0===P[14]&&1===P[15]),this}A(P){P.copyToArray(this.Pj);const a=P;return this.updateFlag=a.updateFlag,this._updateIdentityStatus(a._isIdentity,a._isIdentityDirty,a._isIdentity3x2,a._isIdentity3x2Dirty),this}copyToArray(P){return l(this,P,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(P){const a=new W;return this.multiplyToRef(P,a),a}multiplyInPlace(P){const a=this.Pj,R=P.m;for(let S=0;S<16;S++)a[S]*=R[S];return this.markAsUpdated(),this}multiplyByFloats(){const P=this.Pj;for(let a=0;a<16;a++)P[a]*=a<0||arguments.length<=a?void 0:arguments[a];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var P=arguments.length,a=new Array(P),R=0;R<P;R++)a[R]=arguments[R];const S=a.pop(),A=this.Pj,Z=S.Pj,p=a;for(let j=0;j<16;j++)Z[j]=A[j]*p[j];return S.markAsUpdated(),S}multiplyToRef(P,a){return this._isIdentity?(a.A(P),a):P._isIdentity?(a.A(this),a):(this.multiplyToArray(P,a.Pj,0),a.markAsUpdated(),a)}multiplyToArray(P,a,R){return h(this,P,a,R),this}divide(P){return this.divideToRef(P,new W)}divideToRef(P,a){const R=this.Pj,S=P.m,A=a.Pj;for(let Z=0;Z<16;Z++)A[Z]=R[Z]/S[Z];return a.markAsUpdated(),a}divideInPlace(P){const a=this.Pj,R=P.m;for(let S=0;S<16;S++)a[S]/=R[S];return this.markAsUpdated(),this}minimizeInPlace(P){const a=this.Pj,R=P.m;for(let S=0;S<16;S++)a[S]=Math.min(a[S],R[S]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const P=this.Pj;for(let a=0;a<16;a++)P[a]=Math.min(P[a],a<0||arguments.length<=a?void 0:arguments[a]);return this.markAsUpdated(),this}maximizeInPlace(P){const a=this.Pj,R=P.m;for(let S=0;S<16;S++)a[S]=Math.min(a[S],R[S]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const P=this.Pj;for(let a=0;a<16;a++)P[a]=Math.min(P[a],a<0||arguments.length<=a?void 0:arguments[a]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new W)}negateInPlace(){const P=this.Pj;for(let a=0;a<16;a++)P[a]=-P[a];return this.markAsUpdated(),this}negateToRef(P){const a=this.Pj,R=P.Pj;for(let S=0;S<16;S++)R[S]=-a[S];return P.markAsUpdated(),P}equals(P){const a=P;if(!a)return!1;if((this._isIdentity||a._isIdentity)&&!this._isIdentityDirty&&!a._isIdentityDirty)return this._isIdentity&&a._isIdentity;const R=this.m,S=a.m;return R[0]===S[0]&&R[1]===S[1]&&R[2]===S[2]&&R[3]===S[3]&&R[4]===S[4]&&R[5]===S[5]&&R[6]===S[6]&&R[7]===S[7]&&R[8]===S[8]&&R[9]===S[9]&&R[10]===S[10]&&R[11]===S[11]&&R[12]===S[12]&&R[13]===S[13]&&R[14]===S[14]&&R[15]===S[15]}equalsWithEpsilon(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const R=this.Pj,S=P.m;for(let A=0;A<16;A++)if(!(0,U.WithinEpsilon)(R[A],S[A],a))return!1;return!0}equalsToFloats(){const P=this.Pj;for(let a=0;a<16;a++)if(P[a]!=(a<0||arguments.length<=a?void 0:arguments[a]))return!1;return!0}floor(){return this.floorToRef(new W)}floorToRef(P){const a=this.Pj,R=P.Pj;for(let S=0;S<16;S++)R[S]=Math.floor(a[S]);return P.markAsUpdated(),P}fract(){return this.fractToRef(new W)}fractToRef(P){const a=this.Pj,R=P.Pj;for(let S=0;S<16;S++)R[S]=a[S]-Math.floor(a[S]);return P.markAsUpdated(),P}clone(){const P=new W;return P.A(this),P}getClassName(){return"Matrix"}getHashCode(){let P=f(this.Pj[0]);for(let a=1;a<16;a++)P=397*P^f(this.Pj[a]);return P}decomposeToTransformNode(P){return P.rotationQuaternion=P.rotationQuaternion||new t,this.decompose(P.qj,P.rotationQuaternion,P.position)}decompose(P,a,R,S){let A=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return R&&R.yj(0),P&&P.yj(1),a&&a.Oj(0,0,0,1),!0;const Z=this.Pj;if(R&&R.Oj(Z[12],Z[13],Z[14]),(P=P||k.Oa[0]).x=Math.sqrt(Z[0]*Z[0]+Z[1]*Z[1]+Z[2]*Z[2]),P.y=Math.sqrt(Z[4]*Z[4]+Z[5]*Z[5]+Z[6]*Z[6]),P.z=Math.sqrt(Z[8]*Z[8]+Z[9]*Z[9]+Z[10]*Z[10]),S){const a=(A?S.absoluteScaling.x:S.qj.x)<0?-1:1,R=(A?S.absoluteScaling.y:S.qj.y)<0?-1:1,Z=(A?S.absoluteScaling.z:S.qj.z)<0?-1:1;P.x*=a,P.y*=R,P.z*=Z}else this.determinant()<=0&&(P.y*=-1);if(0===P._x||0===P._y||0===P._z)return a&&a.Oj(0,0,0,1),!1;if(a){const R=1/P._x,S=1/P._y,A=1/P._z;W.FromValuesToRef(Z[0]*R,Z[1]*R,Z[2]*R,0,Z[4]*S,Z[5]*S,Z[6]*S,0,Z[8]*A,Z[9]*A,Z[10]*A,0,0,0,0,1,k.Matrix[0]),t.FromRotationMatrixToRef(k.Matrix[0],a)}return!0}getRow(P){if(P<0||P>3)return null;const a=4*P;return new y(this.Pj[a+0],this.Pj[a+1],this.Pj[a+2],this.Pj[a+3])}getRowToRef(P,a){if(P>=0&&P<=3){const R=4*P;a.x=this.Pj[R+0],a.y=this.Pj[R+1],a.z=this.Pj[R+2],a.w=this.Pj[R+3]}return a}setRow(P,a){return this.setRowFromFloats(P,a.x,a.y,a.z,a.w)}transpose(){const P=new W;return W.TransposeToRef(this,P),P}transposeToRef(P){return W.TransposeToRef(this,P),P}setRowFromFloats(P,a,R,S,A){if(P<0||P>3)return this;const Z=4*P;return this.Pj[Z+0]=a,this.Pj[Z+1]=R,this.Pj[Z+2]=S,this.Pj[Z+3]=A,this.markAsUpdated(),this}scale(P){const a=new W;return this.scaleToRef(P,a),a}scaleToRef(P,a){for(let R=0;R<16;R++)a.Pj[R]=this.Pj[R]*P;return a.markAsUpdated(),a}scaleAndAddToRef(P,a){for(let R=0;R<16;R++)a.Pj[R]+=this.Pj[R]*P;return a.markAsUpdated(),a}scaleInPlace(P){const a=this.Pj;for(let R=0;R<16;R++)a[R]*=P;return this.markAsUpdated(),this}toNormalMatrix(P){const a=k.Matrix[0];this.invertToRef(a),a.transposeToRef(P);const R=P.Pj;return W.FromValuesToRef(R[0],R[1],R[2],0,R[4],R[5],R[6],0,R[8],R[9],R[10],0,0,0,0,1,P),P}getRotationMatrix(){const P=new W;return this.getRotationMatrixToRef(P),P}getRotationMatrixToRef(P){const a=k.Oa[0];if(!this.decompose(a))return W.IdentityToRef(P),P;const R=this.Pj,S=1/a._x,A=1/a._y,Z=1/a._z;return W.FromValuesToRef(R[0]*S,R[1]*S,R[2]*S,0,R[4]*A,R[5]*A,R[6]*A,0,R[8]*Z,R[9]*Z,R[10]*Z,0,0,0,0,1,P),P}toggleModelMatrixHandInPlace(){const P=this.Pj;return P[2]*=-1,P[6]*=-1,P[8]*=-1,P[9]*=-1,P[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const P=this.Pj;return P[8]*=-1,P[9]*=-1,P[10]*=-1,P[11]*=-1,this.markAsUpdated(),this}static ka(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const R=new W;return W.FromArrayToRef(P,a,R),R}static FromArrayToRef(P,a,R){for(let S=0;S<16;S++)R.Pj[S]=P[S+a];return R.markAsUpdated(),R}static FromFloat32ArrayToRefScaled(P,a,R,S){return S.Pj[0]=P[0+a]*R,S.Pj[1]=P[1+a]*R,S.Pj[2]=P[2+a]*R,S.Pj[3]=P[3+a]*R,S.Pj[4]=P[4+a]*R,S.Pj[5]=P[5+a]*R,S.Pj[6]=P[6+a]*R,S.Pj[7]=P[7+a]*R,S.Pj[8]=P[8+a]*R,S.Pj[9]=P[9+a]*R,S.Pj[10]=P[10+a]*R,S.Pj[11]=P[11+a]*R,S.Pj[12]=P[12+a]*R,S.Pj[13]=P[13+a]*R,S.Pj[14]=P[14+a]*R,S.Pj[15]=P[15+a]*R,S.markAsUpdated(),S}static get IdentityReadOnly(){return W._IdentityReadOnly}static FromValuesToRef(P,a,R,S,A,Z,p,j,U,Q,h,l,V,f,O,q,y){const t=y.Pj;t[0]=P,t[1]=a,t[2]=R,t[3]=S,t[4]=A,t[5]=Z,t[6]=p,t[7]=j,t[8]=U,t[9]=Q,t[10]=h,t[11]=l,t[12]=V,t[13]=f,t[14]=O,t[15]=q,y.markAsUpdated()}static FromValues(P,a,R,S,A,Z,p,j,U,Q,h,l,V,f,O,q){const y=new W,t=y.Pj;return t[0]=P,t[1]=a,t[2]=R,t[3]=S,t[4]=A,t[5]=Z,t[6]=p,t[7]=j,t[8]=U,t[9]=Q,t[10]=h,t[11]=l,t[12]=V,t[13]=f,t[14]=O,t[15]=q,y.markAsUpdated(),y}static Compose(P,a,R){const S=new W;return W.ComposeToRef(P,a,R,S),S}static ComposeToRef(P,a,R,S){const A=S.Pj,Z=a._x,p=a._y,j=a._z,U=a._w,Q=Z+Z,h=p+p,l=j+j,V=Z*Q,f=Z*h,O=Z*l,q=p*h,y=p*l,t=j*l,W=U*Q,k=U*h,x=U*l,s=P._x,d=P._y,G=P._z;return A[0]=(1-(q+t))*s,A[1]=(f+x)*s,A[2]=(O-k)*s,A[3]=0,A[4]=(f-x)*d,A[5]=(1-(V+t))*d,A[6]=(y+W)*d,A[7]=0,A[8]=(O+k)*G,A[9]=(y-W)*G,A[10]=(1-(V+q))*G,A[11]=0,A[12]=R._x,A[13]=R._y,A[14]=R._z,A[15]=1,S.markAsUpdated(),S}static Identity(){const P=W.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return P._updateIdentityStatus(!0),P}static IdentityToRef(P){return W.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,P),P._updateIdentityStatus(!0),P}static Zero(){const P=W.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return P._updateIdentityStatus(!1),P}static RotationX(P){const a=new W;return W.RotationXToRef(P,a),a}static Invert(P){const a=new W;return P.invertToRef(a),a}static RotationXToRef(P,a){const R=Math.sin(P),S=Math.cos(P);return W.FromValuesToRef(1,0,0,0,0,S,R,0,0,-R,S,0,0,0,0,1,a),a._updateIdentityStatus(1===S&&0===R),a}static RotationY(P){const a=new W;return W.RotationYToRef(P,a),a}static RotationYToRef(P,a){const R=Math.sin(P),S=Math.cos(P);return W.FromValuesToRef(S,0,-R,0,0,1,0,0,R,0,S,0,0,0,0,1,a),a._updateIdentityStatus(1===S&&0===R),a}static RotationZ(P){const a=new W;return W.RotationZToRef(P,a),a}static RotationZToRef(P,a){const R=Math.sin(P),S=Math.cos(P);return W.FromValuesToRef(S,R,0,0,-R,S,0,0,0,0,1,0,0,0,0,1,a),a._updateIdentityStatus(1===S&&0===R),a}static RotationAxis(P,a){const R=new W;return W.RotationAxisToRef(P,a,R),R}static RotationAxisToRef(P,a,R){const S=Math.sin(-a),A=Math.cos(-a),Z=1-A;P=P.normalizeToRef(k.Oa[0]);const p=R.Pj;return p[0]=P._x*P._x*Z+A,p[1]=P._x*P._y*Z-P._z*S,p[2]=P._x*P._z*Z+P._y*S,p[3]=0,p[4]=P._y*P._x*Z+P._z*S,p[5]=P._y*P._y*Z+A,p[6]=P._y*P._z*Z-P._x*S,p[7]=0,p[8]=P._z*P._x*Z-P._y*S,p[9]=P._z*P._y*Z+P._x*S,p[10]=P._z*P._z*Z+A,p[11]=0,p[12]=0,p[13]=0,p[14]=0,p[15]=1,R.markAsUpdated(),R}static RotationAlignToRef(P,a,R){let A=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const Z=q.Dot(a,P),p=R.Pj;if(Z<-1+S.c)p[0]=-1,p[1]=0,p[2]=0,p[3]=0,p[4]=0,p[5]=A?1:-1,p[6]=0,p[7]=0,p[8]=0,p[9]=0,p[10]=A?-1:1,p[11]=0;else{const R=q.Cross(a,P),S=1/(1+Z);p[0]=R._x*R._x*S+Z,p[1]=R._y*R._x*S-R._z,p[2]=R._z*R._x*S+R._y,p[3]=0,p[4]=R._x*R._y*S+R._z,p[5]=R._y*R._y*S+Z,p[6]=R._z*R._y*S-R._x,p[7]=0,p[8]=R._x*R._z*S-R._y,p[9]=R._y*R._z*S+R._x,p[10]=R._z*R._z*S+Z,p[11]=0}return p[12]=0,p[13]=0,p[14]=0,p[15]=1,R.markAsUpdated(),R}static RotationYawPitchRoll(P,a,R){const S=new W;return W.RotationYawPitchRollToRef(P,a,R,S),S}static RotationYawPitchRollToRef(P,a,R,S){return t.RotationYawPitchRollToRef(P,a,R,k.Quaternion[0]),k.Quaternion[0].toRotationMatrix(S),S}static Scaling(P,a,R){const S=new W;return W.ScalingToRef(P,a,R,S),S}static ScalingToRef(P,a,R,S){return W.FromValuesToRef(P,0,0,0,0,a,0,0,0,0,R,0,0,0,0,1,S),S._updateIdentityStatus(1===P&&1===a&&1===R),S}static Translation(P,a,R){const S=new W;return W.TranslationToRef(P,a,R,S),S}static TranslationToRef(P,a,R,S){return W.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,P,a,R,1,S),S._updateIdentityStatus(0===P&&0===a&&0===R),S}static Lerp(P,a,R){const S=new W;return W.LerpToRef(P,a,R,S),S}static LerpToRef(P,a,R,S){const A=S.Pj,Z=P.m,p=a.m;for(let j=0;j<16;j++)A[j]=Z[j]*(1-R)+p[j]*R;return S.markAsUpdated(),S}static DecomposeLerp(P,a,R){const S=new W;return W.DecomposeLerpToRef(P,a,R,S),S}static DecomposeLerpToRef(P,a,R,S){const A=k.Oa[0],Z=k.Quaternion[0],p=k.Oa[1];P.decompose(A,Z,p);const j=k.Oa[2],U=k.Quaternion[1],Q=k.Oa[3];a.decompose(j,U,Q);const h=k.Oa[4];q.LerpToRef(A,j,R,h);const l=k.Quaternion[2];t.SlerpToRef(Z,U,R,l);const V=k.Oa[5];return q.LerpToRef(p,Q,R,V),W.ComposeToRef(h,l,V,S),S}static LookAtLH(P,a,R){const S=new W;return W.LookAtLHToRef(P,a,R,S),S}static LookAtLHToRef(P,a,R,S){const A=k.Oa[0],Z=k.Oa[1],p=k.Oa[2];a.subtractToRef(P,p),p.normalize(),q.CrossToRef(R,p,A);const j=A.lengthSquared();0===j?A.x=1:A.normalizeFromLength(Math.sqrt(j)),q.CrossToRef(p,A,Z),Z.normalize();const U=-q.Dot(A,P),Q=-q.Dot(Z,P),h=-q.Dot(p,P);return W.FromValuesToRef(A._x,Z._x,p._x,0,A._y,Z._y,p._y,0,A._z,Z._z,p._z,0,U,Q,h,1,S),S}static LookAtRH(P,a,R){const S=new W;return W.LookAtRHToRef(P,a,R,S),S}static LookAtRHToRef(P,a,R,S){const A=k.Oa[0],Z=k.Oa[1],p=k.Oa[2];P.subtractToRef(a,p),p.normalize(),q.CrossToRef(R,p,A);const j=A.lengthSquared();0===j?A.x=1:A.normalizeFromLength(Math.sqrt(j)),q.CrossToRef(p,A,Z),Z.normalize();const U=-q.Dot(A,P),Q=-q.Dot(Z,P),h=-q.Dot(p,P);return W.FromValuesToRef(A._x,Z._x,p._x,0,A._y,Z._y,p._y,0,A._z,Z._z,p._z,0,U,Q,h,1,S),S}static LookDirectionLH(P,a){const R=new W;return W.LookDirectionLHToRef(P,a,R),R}static LookDirectionLHToRef(P,a,R){const S=k.Oa[0];S.A(P),S.scaleInPlace(-1);const A=k.Oa[1];return q.CrossToRef(a,S,A),W.FromValuesToRef(A._x,A._y,A._z,0,a._x,a._y,a._z,0,S._x,S._y,S._z,0,0,0,0,1,R),R}static LookDirectionRH(P,a){const R=new W;return W.LookDirectionRHToRef(P,a,R),R}static LookDirectionRHToRef(P,a,R){const S=k.Oa[2];return q.CrossToRef(a,P,S),W.FromValuesToRef(S._x,S._y,S._z,0,a._x,a._y,a._z,0,P._x,P._y,P._z,0,0,0,0,1,R),R}static OrthoLH(P,a,R,S,A){const Z=new W;return W.OrthoLHToRef(P,a,R,S,Z,A),Z}static OrthoLHToRef(P,a,R,S,A,Z){const p=2/P,j=2/a,U=2/(S-R),Q=-(S+R)/(S-R);return W.FromValuesToRef(p,0,0,0,0,j,0,0,0,0,U,0,0,0,Q,1,A),Z&&A.multiplyToRef(s,A),A._updateIdentityStatus(1===p&&1===j&&1===U&&0===Q),A}static OrthoOffCenterLH(P,a,R,S,A,Z,p){const j=new W;return W.OrthoOffCenterLHToRef(P,a,R,S,A,Z,j,p),j}static OrthoOffCenterLHToRef(P,a,R,S,A,Z,p,j){const U=2/(a-P),Q=2/(S-R),h=2/(Z-A),l=-(Z+A)/(Z-A),V=(P+a)/(P-a),f=(S+R)/(R-S);return W.FromValuesToRef(U,0,0,0,0,Q,0,0,0,0,h,0,V,f,l,1,p),j&&p.multiplyToRef(s,p),p.markAsUpdated(),p}static ObliqueOffCenterLHToRef(P,a,R,S,A,Z,p,j,U,Q,h){const l=-p*Math.cos(j),V=-p*Math.sin(j);return W.TranslationToRef(0,0,-U,k.Matrix[1]),W.FromValuesToRef(1,0,0,0,0,1,0,0,l,V,1,0,0,0,0,1,k.Matrix[0]),k.Matrix[1].multiplyToRef(k.Matrix[0],k.Matrix[0]),W.TranslationToRef(0,0,U,k.Matrix[1]),k.Matrix[0].multiplyToRef(k.Matrix[1],k.Matrix[0]),W.OrthoOffCenterLHToRef(P,a,R,S,A,Z,Q,h),k.Matrix[0].multiplyToRef(Q,Q),Q}static OrthoOffCenterRH(P,a,R,S,A,Z,p){const j=new W;return W.OrthoOffCenterRHToRef(P,a,R,S,A,Z,j,p),j}static OrthoOffCenterRHToRef(P,a,R,S,A,Z,p,j){return W.OrthoOffCenterLHToRef(P,a,R,S,A,Z,p,j),p.Pj[10]*=-1,p}static ObliqueOffCenterRHToRef(P,a,R,S,A,Z,p,j,U,Q,h){const l=p*Math.cos(j),V=p*Math.sin(j);return W.TranslationToRef(0,0,U,k.Matrix[1]),W.FromValuesToRef(1,0,0,0,0,1,0,0,l,V,1,0,0,0,0,1,k.Matrix[0]),k.Matrix[1].multiplyToRef(k.Matrix[0],k.Matrix[0]),W.TranslationToRef(0,0,-U,k.Matrix[1]),k.Matrix[0].multiplyToRef(k.Matrix[1],k.Matrix[0]),W.OrthoOffCenterRHToRef(P,a,R,S,A,Z,Q,h),k.Matrix[0].multiplyToRef(Q,Q),Q}static PerspectiveLH(P,a,R,S,A){let Z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const p=new W,j=2*R/P,U=2*R/a,Q=(S+R)/(S-R),h=-2*S*R/(S-R),l=Math.tan(Z);return W.FromValuesToRef(j,0,0,0,0,U,0,l,0,0,Q,1,0,0,h,0,p),A&&p.multiplyToRef(s,p),p._updateIdentityStatus(!1),p}static PerspectiveFovLH(P,a,R,S,A){let Z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,p=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const j=new W;return W.PerspectiveFovLHToRef(P,a,R,S,j,!0,A,Z,p),j}static PerspectiveFovLHToRef(P,a,R,S,A){let Z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],p=arguments.length>6?arguments[6]:void 0,j=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,U=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const Q=R,h=S,l=1/Math.tan(.5*P),V=Z?l/a:l,f=Z?l:l*a,O=U&&0===Q?-1:0!==h?(h+Q)/(h-Q):1,q=U&&0===Q?2*h:0!==h?-2*h*Q/(h-Q):-2*Q,y=Math.tan(j);return W.FromValuesToRef(V,0,0,0,0,f,0,y,0,0,O,1,0,0,q,0,A),p&&A.multiplyToRef(s,A),A._updateIdentityStatus(!1),A}static PerspectiveFovReverseLHToRef(P,a,R,S,A){let Z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],p=arguments.length>6?arguments[6]:void 0,j=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const U=1/Math.tan(.5*P),Q=Z?U/a:U,h=Z?U:U*a,l=Math.tan(j);return W.FromValuesToRef(Q,0,0,0,0,h,0,l,0,0,-R,1,0,0,1,0,A),p&&A.multiplyToRef(s,A),A._updateIdentityStatus(!1),A}static PerspectiveFovRH(P,a,R,S,A){let Z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,p=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const j=new W;return W.PerspectiveFovRHToRef(P,a,R,S,j,!0,A,Z,p),j}static PerspectiveFovRHToRef(P,a,R,S,A){let Z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],p=arguments.length>6?arguments[6]:void 0,j=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,U=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const Q=R,h=S,l=1/Math.tan(.5*P),V=Z?l/a:l,f=Z?l:l*a,O=U&&0===Q?1:0!==h?-(h+Q)/(h-Q):-1,q=U&&0===Q?2*h:0!==h?-2*h*Q/(h-Q):-2*Q,y=Math.tan(j);return W.FromValuesToRef(V,0,0,0,0,f,0,y,0,0,O,-1,0,0,q,0,A),p&&A.multiplyToRef(s,A),A._updateIdentityStatus(!1),A}static PerspectiveFovReverseRHToRef(P,a,R,S,A){let Z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],p=arguments.length>6?arguments[6]:void 0,j=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const U=1/Math.tan(.5*P),Q=Z?U/a:U,h=Z?U:U*a,l=Math.tan(j);return W.FromValuesToRef(Q,0,0,0,0,h,0,l,0,0,-R,-1,0,0,-1,0,A),p&&A.multiplyToRef(s,A),A._updateIdentityStatus(!1),A}static GetFinalMatrix(P,a,R,S,A,Z){const p=P.width,j=P.height,U=P.x,Q=P.y,h=W.FromValues(p/2,0,0,0,0,-j/2,0,0,0,0,Z-A,0,U+p/2,j/2+Q,A,1),l=new W;return a.multiplyToRef(R,l),l.multiplyToRef(S,l),l.multiplyToRef(h,l)}static GetAsMatrix2x2(P){const a=P.m,R=[a[0],a[1],a[4],a[5]];return p.b.MatrixUse64Bits?R:new Float32Array(R)}static GetAsMatrix3x3(P){const a=P.m,R=[a[0],a[1],a[2],a[4],a[5],a[6],a[8],a[9],a[10]];return p.b.MatrixUse64Bits?R:new Float32Array(R)}static Transpose(P){const a=new W;return W.TransposeToRef(P,a),a}static TransposeToRef(P,a){const R=P.m,S=R[0],A=R[4],Z=R[8],p=R[12],j=R[1],U=R[5],Q=R[9],h=R[13],l=R[2],V=R[6],f=R[10],O=R[14],q=R[3],y=R[7],t=R[11],W=R[15],k=a.Pj;return k[0]=S,k[1]=A,k[2]=Z,k[3]=p,k[4]=j,k[5]=U,k[6]=Q,k[7]=h,k[8]=l,k[9]=V,k[10]=f,k[11]=O,k[12]=q,k[13]=y,k[14]=t,k[15]=W,a.markAsUpdated(),a._updateIdentityStatus(P._isIdentity,P._isIdentityDirty),a}static Reflection(P){const a=new W;return W.ReflectionToRef(P,a),a}static ReflectionToRef(P,a){P.normalize();const R=P.normal.x,S=P.normal.y,A=P.normal.z,Z=-2*R,p=-2*S,j=-2*A;return W.FromValuesToRef(Z*R+1,p*R,j*R,0,Z*S,p*S+1,j*S,0,Z*A,p*A,j*A+1,0,Z*P.d,p*P.d,j*P.d,1,a),a}static FromXYZAxesToRef(P,a,R,S){return W.FromValuesToRef(P._x,P._y,P._z,0,a._x,a._y,a._z,0,R._x,R._y,R._z,0,0,0,0,1,S),S}static FromQuaternionToRef(P,a){const R=P._x*P._x,S=P._y*P._y,A=P._z*P._z,Z=P._x*P._y,p=P._z*P._w,j=P._z*P._x,U=P._y*P._w,Q=P._y*P._z,h=P._x*P._w;return a.Pj[0]=1-2*(S+A),a.Pj[1]=2*(Z+p),a.Pj[2]=2*(j-U),a.Pj[3]=0,a.Pj[4]=2*(Z-p),a.Pj[5]=1-2*(A+R),a.Pj[6]=2*(Q+h),a.Pj[7]=0,a.Pj[8]=2*(j+U),a.Pj[9]=2*(Q-h),a.Pj[10]=1-2*(S+R),a.Pj[11]=0,a.Pj[12]=0,a.Pj[13]=0,a.Pj[14]=0,a.Pj[15]=1,a.markAsUpdated(),a}}W._IdentityReadOnly=W.Identity(),Object.defineProperties(W.prototype,{dimension:{value:[4,4]},rank:{value:2}});class k{}k.Oa=(0,A.h)(11,q.Zero),k.Matrix=(0,A.h)(2,W.Identity),k.Quaternion=(0,A.h)(3,t.Zero);class x{}x.Vector2=(0,A.h)(3,O.Zero),x.Oa=(0,A.h)(13,q.Zero),x.Vector4=(0,A.h)(3,y.Zero),x.Quaternion=(0,A.h)(3,t.Zero),x.Matrix=(0,A.h)(8,W.Identity),(0,Z.d)("BABYLON.Vector2",O),(0,Z.d)("BABYLON.Vector3",q),(0,Z.d)("BABYLON.Vector4",y),(0,Z.d)("BABYLON.Matrix",W);const s=W.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12423:(P,a,R)=>{function S(P,a){const R=[];for(let S=0;S<P;++S)R.push(a());return R}function A(P,a){return S(P,a)}R.d(a,{e:()=>S,h:()=>A,k:()=>p});const Z=["push","splice","pop","shift","unshift"];function p(P,a){const R=Z.map((R=>function(P,a,R){const S=P[a];if("function"!==typeof S)return null;const A=function(){const S=P.length,Z=A.previous.apply(P,arguments);return R(a,S),Z};return S.next=A,A.previous=S,P[a]=A,()=>{const R=A.previous;if(!R)return;const S=A.next;S?(R.next=S,S.previous=R):(R.next=void 0,P[a]=R),A.next=void 0,A.previous=void 0}}(P,R,a)));return()=>{for(const P of R)null===P||void 0===P||P()}}}}]);