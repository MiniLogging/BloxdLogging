"use strict";(self.ozi0exxand9=self.ozi0exxand9||[]).push([[14],{11428:(f,v,Z)=>{Z.d(v,{c:()=>l,e:()=>J,g:()=>V,h:()=>h});const V=1/2.2,h=2.2,J=(1+Math.sqrt(5))/2,l=.001},11440:(f,v,Z)=>{function V(f){return parseInt(f.toString().replace(/\W/g,""))}function h(f,v){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(f-v)<=Z}function J(f,v,Z){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return f<v-V||f>Z+V}function l(f,v){return f===v?f:Math.random()*(v-f)+f}function e(f,v,Z){return f+(v-f)*Z}function C(f,v,Z){let V=F(v-f,360);return V>180&&(V-=360),f+V*W(Z)}function H(f,v,Z){let V=0;return V=f!=v?W((Z-f)/(v-f)):0,V}function O(f,v,Z,V,h){const J=h*h,l=h*J;return f*(2*l-3*J+1)+Z*(-2*l+3*J)+v*(l-2*J+h)+V*(l-J)}function u(f,v,Z,V,h){const J=h*h;return 6*(J-h)*f+(3*J-4*h+1)*v+6*(-J+h)*Z+(3*J-2*h)*V}function W(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(Z,Math.max(v,f))}function a(f){return f-=2*Math.PI*Math.floor((f+Math.PI)/(2*Math.PI))}function b(f){const v=f.toString(16);return f<=15?("0"+v).toUpperCase():v.toUpperCase()}function X(f){if(Math.log2)return Math.floor(Math.log2(f));if(f<0)return NaN;if(0===f)return-1/0;let v=0;if(f<1){for(;f<1;)v++,f*=2;v=-v}else if(f>1)for(;f>1;)v++,f=Math.floor(f/2);return v}function F(f,v){return f-Math.floor(f/v)*v}function U(f,v,Z){return(f-v)/(Z-v)}function K(f,v,Z){return f*(Z-v)+v}function M(f,v){let Z=F(v-f,360);return Z>180&&(Z-=360),Z}function A(f,v){const Z=F(f,2*v);return v-Math.abs(Z-v)}function s(f,v,Z){let V=W(Z);return V=-2*V*V*V+3*V*V,v*V+f*(1-V)}function z(f,v,Z){let V=0;return V=Math.abs(v-f)<=Z?v:f+Math.sign(v-f)*Z,V}function Y(f,v,Z){const V=M(f,v);let h=0;return h=-Z<V&&V<Z?v:z(f,v=f+V,Z),h}function y(f,v,Z){return(f-v)/(Z-v)}function N(f,v,Z){return(Z-v)*f+v}function i(f,v){const Z=f%v;return 0===Z?v:i(v,Z)}Z.r(v),Z.d(v,{Clamp:()=>W,DeltaAngle:()=>M,Denormalize:()=>K,ExtractAsInt:()=>V,Hermite:()=>O,Hermite1stDerivative:()=>u,HighestCommonFactor:()=>i,ILog2:()=>X,InverseLerp:()=>H,Lerp:()=>e,LerpAngle:()=>C,MoveTowards:()=>z,MoveTowardsAngle:()=>Y,Normalize:()=>U,NormalizeRadians:()=>a,OutsideRange:()=>J,PercentToRange:()=>N,PingPong:()=>A,RandomRange:()=>l,RangeToPercent:()=>y,Repeat:()=>F,SmoothStep:()=>s,ToHex:()=>b,WithinEpsilon:()=>h})},11421:(f,v,Z)=>{Z.r(v),Z.d(v,{Matrix:()=>K,Quaternion:()=>U,TmpVectors:()=>A,Vector2:()=>b,Xv:()=>X,Vector4:()=>F});var V=Z(11428),h=Z(11437),J=Z(11372),l=Z(11354),e=Z(11281),C=Z(11440);class H{}function O(f,v,Z){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const h=f.Ph(),J=v.Ph(),l=h[0],e=h[1],C=h[2],H=h[3],O=h[4],u=h[5],W=h[6],a=h[7],b=h[8],X=h[9],F=h[10],U=h[11],K=h[12],M=h[13],A=h[14],s=h[15],z=J[0],Y=J[1],y=J[2],N=J[3],i=J[4],I=J[5],T=J[6],B=J[7],P=J[8],g=J[9],w=J[10],t=J[11],L=J[12],E=J[13],j=J[14],q=J[15];Z[V]=l*z+e*i+C*P+H*L,Z[V+1]=l*Y+e*I+C*g+H*E,Z[V+2]=l*y+e*T+C*w+H*j,Z[V+3]=l*N+e*B+C*t+H*q,Z[V+4]=O*z+u*i+W*P+a*L,Z[V+5]=O*Y+u*I+W*g+a*E,Z[V+6]=O*y+u*T+W*w+a*j,Z[V+7]=O*N+u*B+W*t+a*q,Z[V+8]=b*z+X*i+F*P+U*L,Z[V+9]=b*Y+X*I+F*g+U*E,Z[V+10]=b*y+X*T+F*w+U*j,Z[V+11]=b*N+X*B+F*t+U*q,Z[V+12]=K*z+M*i+A*P+s*L,Z[V+13]=K*Y+M*I+A*g+s*E,Z[V+14]=K*y+M*T+A*w+s*j,Z[V+15]=K*N+M*B+A*t+s*q}function u(f,v){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const V=f.Ph();v[Z]=V[0],v[Z+1]=V[1],v[Z+2]=V[2],v[Z+3]=V[3],v[Z+4]=V[4],v[Z+5]=V[5],v[Z+6]=V[6],v[Z+7]=V[7],v[Z+8]=V[8],v[Z+9]=V[9],v[Z+10]=V[10],v[Z+11]=V[11],v[Z+12]=V[12],v[Z+13]=V[13],v[Z+14]=V[14],v[Z+15]=V[15]}function W(f,v){const Z=f.Ph(),V=Z[0],h=Z[1],J=Z[2],l=Z[3],e=Z[4],C=Z[5],H=Z[6],O=Z[7],u=Z[8],W=Z[9],a=Z[10],b=Z[11],X=Z[12],F=Z[13],U=Z[14],K=Z[15],M=a*K-U*b,A=W*K-F*b,s=W*U-F*a,z=u*K-X*b,Y=u*U-a*X,y=u*F-X*W,N=+(C*M-H*A+O*s),i=-(e*M-H*z+O*Y),I=+(e*A-C*z+O*y),T=-(e*s-C*Y+H*y),B=V*N+h*i+J*I+l*T;if(0===B)return!1;const P=1/B,g=H*K-U*O,w=C*K-F*O,t=C*U-F*H,L=e*K-X*O,E=e*U-X*H,j=e*F-X*C,q=H*b-a*O,c=C*b-W*O,m=C*a-W*H,p=e*b-u*O,k=e*a-u*H,r=e*W-u*C,o=-(h*M-J*A+l*s),G=+(V*M-J*z+l*Y),Q=-(V*A-h*z+l*y),d=+(V*s-h*Y+J*y),x=+(h*g-J*w+l*t),R=-(V*g-J*L+l*E),n=+(V*w-h*L+l*j),S=-(V*t-h*E+J*j),D=-(h*q-J*c+l*m),ff=+(V*q-J*p+l*k),vf=-(V*c-h*p+l*r),Zf=+(V*m-h*k+J*r);return v[0]=N*P,v[1]=o*P,v[2]=x*P,v[3]=D*P,v[4]=i*P,v[5]=G*P,v[6]=R*P,v[7]=ff*P,v[8]=I*P,v[9]=Q*P,v[10]=n*P,v[11]=vf*P,v[12]=T*P,v[13]=d*P,v[14]=S*P,v[15]=Zf*P,!0}H._UpdateFlagSeed=0;const a=f=>parseInt(f.toString().replace(/\W/g,""));class b{constructor(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=f,this.y=v}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let f=a(this.x);return f=397*f^a(this.y),f}toArray(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f[v]=this.x,f[v+1]=this.y,this}bZ(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b.FromArrayToRef(f,v,this),this}Ph(){return[this.x,this.y]}h(f){return this.x=f.x,this.y=f.y,this}fe(f,v){return this.x=f,this.y=v,this}set(f,v){return this.fe(f,v)}Ve(f){return this.fe(f,f)}add(f){return new b(this.x+f.x,this.y+f.y)}addToRef(f,v){return v.x=this.x+f.x,v.y=this.y+f.y,v}addInPlace(f){return this.x+=f.x,this.y+=f.y,this}addInPlaceFromFloats(f,v){return this.x+=f,this.y+=v,this}addVector3(f){return new b(this.x+f.x,this.y+f.y)}Fv(f){return new b(this.x-f.x,this.y-f.y)}subtractToRef(f,v){return v.x=this.x-f.x,v.y=this.y-f.y,v}hu(f){return this.x-=f.x,this.y-=f.y,this}multiplyInPlace(f){return this.x*=f.x,this.y*=f.y,this}multiply(f){return new b(this.x*f.x,this.y*f.y)}multiplyToRef(f,v){return v.x=this.x*f.x,v.y=this.y*f.y,v}multiplyByFloats(f,v){return new b(this.x*f,this.y*v)}divide(f){return new b(this.x/f.x,this.y/f.y)}divideToRef(f,v){return v.x=this.x/f.x,v.y=this.y/f.y,v}divideInPlace(f){return this.x=this.x/f.x,this.y=this.y/f.y,this}minimizeInPlace(f){return this.minimizeInPlaceFromFloats(f.x,f.y)}maximizeInPlace(f){return this.maximizeInPlaceFromFloats(f.x,f.y)}minimizeInPlaceFromFloats(f,v){return this.x=Math.min(f,this.x),this.y=Math.min(v,this.y),this}maximizeInPlaceFromFloats(f,v){return this.x=Math.max(f,this.x),this.y=Math.max(v,this.y),this}subtractFromFloats(f,v){return new b(this.x-f,this.y-v)}subtractFromFloatsToRef(f,v,Z){return Z.x=this.x-f,Z.y=this.y-v,Z}negate(){return new b(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(f){return f.x=-this.x,f.y=-this.y,f}scaleInPlace(f){return this.x*=f,this.y*=f,this}scale(f){return new b(this.x*f,this.y*f)}scaleToRef(f,v){return v.x=this.x*f,v.y=this.y*f,v}scaleAndAddToRef(f,v){return v.x+=this.x*f,v.y+=this.y*f,v}equals(f){return f&&this.x===f.x&&this.y===f.y}equalsWithEpsilon(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.c;return f&&(0,C.WithinEpsilon)(this.x,f.x,v)&&(0,C.WithinEpsilon)(this.y,f.y,v)}equalsToFloats(f,v){return this.x===f&&this.y===v}floor(){return new b(Math.floor(this.x),Math.floor(this.y))}floorToRef(f){return f.x=Math.floor(this.x),f.y=Math.floor(this.y),f}fract(){return new b(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(f){return f.x=this.x-Math.floor(this.x),f.y=this.y-Math.floor(this.y),f}rotate(f){return this.rotateToRef(f,new b)}rotateToRef(f,v){const Z=Math.cos(f),V=Math.sin(f);return v.x=Z*this.x-V*this.y,v.y=V*this.x+Z*this.y,v}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(f){return 0===f||1===f?this:this.scaleInPlace(1/f)}normalizeToNew(){const f=new b;return this.normalizeToRef(f),f}normalizeToRef(f){const v=this.length();return 0===v&&(f.x=this.x,f.y=this.y),this.scaleToRef(1/v,f)}clone(){return new b(this.x,this.y)}dot(f){return this.x*f.x+this.y*f.y}static Zero(){return new b(0,0)}static One(){return new b(1,1)}static Random(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new b((0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v))}static RandomToRef(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fe((0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v))}static get ZeroReadOnly(){return b._ZeroReadOnly}static Av(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new b(f[v],f[v+1])}static FromArrayToRef(f,v,Z){return Z.x=f[v],Z.y=f[v+1],Z}static FromFloatsToRef(f,v,Z){return Z.fe(f,v),Z}static CatmullRom(f,v,Z,V,h){const J=h*h,l=h*J,e=.5*(2*v.x+(-f.x+Z.x)*h+(2*f.x-5*v.x+4*Z.x-V.x)*J+(-f.x+3*v.x-3*Z.x+V.x)*l),C=.5*(2*v.y+(-f.y+Z.y)*h+(2*f.y-5*v.y+4*Z.y-V.y)*J+(-f.y+3*v.y-3*Z.y+V.y)*l);return new b(e,C)}static ClampToRef(f,v,Z,V){return V.x=(0,C.Clamp)(f.x,v.x,Z.x),V.y=(0,C.Clamp)(f.y,v.y,Z.y),V}static Clamp(f,v,Z){const V=(0,C.Clamp)(f.x,v.x,Z.x),h=(0,C.Clamp)(f.y,v.y,Z.y);return new b(V,h)}static Hermite(f,v,Z,V,h){const J=h*h,l=h*J,e=2*l-3*J+1,C=-2*l+3*J,H=l-2*J+h,O=l-J,u=f.x*e+Z.x*C+v.x*H+V.x*O,W=f.y*e+Z.y*C+v.y*H+V.y*O;return new b(u,W)}static Hermite1stDerivative(f,v,Z,V,h){return this.Hermite1stDerivativeToRef(f,v,Z,V,h,new b)}static Hermite1stDerivativeToRef(f,v,Z,V,h,J){const l=h*h;return J.x=6*(l-h)*f.x+(3*l-4*h+1)*v.x+6*(-l+h)*Z.x+(3*l-2*h)*V.x,J.y=6*(l-h)*f.y+(3*l-4*h+1)*v.y+6*(-l+h)*Z.y+(3*l-2*h)*V.y,J}static Lerp(f,v,Z){return b.LerpToRef(f,v,Z,new b)}static LerpToRef(f,v,Z,V){return V.x=f.x+(v.x-f.x)*Z,V.y=f.y+(v.y-f.y)*Z,V}static Dot(f,v){return f.x*v.x+f.y*v.y}static Normalize(f){return b.NormalizeToRef(f,new b)}static NormalizeToRef(f,v){return f.normalizeToRef(v),v}static Minimize(f,v){const Z=f.x<v.x?f.x:v.x,V=f.y<v.y?f.y:v.y;return new b(Z,V)}static Maximize(f,v){const Z=f.x>v.x?f.x:v.x,V=f.y>v.y?f.y:v.y;return new b(Z,V)}static Transform(f,v){return b.TransformToRef(f,v,new b)}static TransformToRef(f,v,Z){const V=v.m,h=f.x*V[0]+f.y*V[4]+V[12],J=f.x*V[1]+f.y*V[5]+V[13];return Z.x=h,Z.y=J,Z}static PointInTriangle(f,v,Z,V){const h=.5*(-Z.y*V.x+v.y*(-Z.x+V.x)+v.x*(Z.y-V.y)+Z.x*V.y),J=h<0?-1:1,l=(v.y*V.x-v.x*V.y+(V.y-v.y)*f.x+(v.x-V.x)*f.y)*J,e=(v.x*Z.y-v.y*Z.x+(v.y-Z.y)*f.x+(Z.x-v.x)*f.y)*J;return l>0&&e>0&&l+e<2*h*J}static Distance(f,v){return Math.sqrt(b.DistanceSquared(f,v))}static DistanceSquared(f,v){const Z=f.x-v.x,V=f.y-v.y;return Z*Z+V*V}static Center(f,v){return b.CenterToRef(f,v,new b)}static CenterToRef(f,v,Z){return Z.fe((f.x+v.x)/2,(f.y+v.y)/2)}static DistanceOfPointFromSegment(f,v,Z){const V=b.DistanceSquared(v,Z);if(0===V)return b.Distance(f,v);const h=Z.Fv(v),J=Math.max(0,Math.min(1,b.Dot(f.Fv(v),h)/V)),l=v.add(h.multiplyByFloats(J,J));return b.Distance(f,l)}}b._V8PerformanceHack=new b(.5,.5),b._ZeroReadOnly=b.Zero(),Object.defineProperties(b.prototype,{dimension:{value:[2]},rank:{value:1}});class X{get x(){return this._x}set x(f){this._x=f,this._isDirty=!0}get y(){return this._y}set y(f){this._y=f,this._isDirty=!0}get z(){return this._z}set z(f){this._z=f,this._isDirty=!0}constructor(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=f,this._y=v,this._z=Z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Xv"}getHashCode(){let f=a(this._x);return f=397*f^a(this._y),f=397*f^a(this._z),f}Ph(){return[this._x,this._y,this._z]}toArray(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f[v]=this._x,f[v+1]=this._y,f[v+2]=this._z,this}bZ(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return X.FromArrayToRef(f,v,this),this}toQuaternion(){return U.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(f){return this._x+=f._x,this._y+=f._y,this._z+=f._z,this._isDirty=!0,this}addInPlaceFromFloats(f,v,Z){return this._x+=f,this._y+=v,this._z+=Z,this._isDirty=!0,this}add(f){return new X(this._x+f._x,this._y+f._y,this._z+f._z)}addToRef(f,v){return v._x=this._x+f._x,v._y=this._y+f._y,v._z=this._z+f._z,v._isDirty=!0,v}hu(f){return this._x-=f._x,this._y-=f._y,this._z-=f._z,this._isDirty=!0,this}Fv(f){return new X(this._x-f._x,this._y-f._y,this._z-f._z)}subtractToRef(f,v){return this.subtractFromFloatsToRef(f._x,f._y,f._z,v)}subtractFromFloats(f,v,Z){return new X(this._x-f,this._y-v,this._z-Z)}subtractFromFloatsToRef(f,v,Z,V){return V._x=this._x-f,V._y=this._y-v,V._z=this._z-Z,V._isDirty=!0,V}negate(){return new X(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(f){return f._x=-1*this._x,f._y=-1*this._y,f._z=-1*this._z,f._isDirty=!0,f}scaleInPlace(f){return this._x*=f,this._y*=f,this._z*=f,this._isDirty=!0,this}scale(f){return new X(this._x*f,this._y*f,this._z*f)}scaleToRef(f,v){return v._x=this._x*f,v._y=this._y*f,v._z=this._z*f,v._isDirty=!0,v}getNormalToRef(f){const v=this.length();let Z=Math.acos(this._y/v);const V=Math.atan2(this._z,this._x);Z>Math.PI/2?Z-=Math.PI/2:Z+=Math.PI/2;const h=v*Math.sin(Z)*Math.cos(V),J=v*Math.cos(Z),l=v*Math.sin(Z)*Math.sin(V);return f.set(h,J,l),f}applyRotationQuaternionToRef(f,v){const Z=this._x,V=this._y,h=this._z,J=f._x,l=f._y,e=f._z,C=f._w,H=2*(l*h-e*V),O=2*(e*Z-J*h),u=2*(J*V-l*Z);return v._x=Z+C*H+l*u-e*O,v._y=V+C*O+e*H-J*u,v._z=h+C*u+J*O-l*H,v._isDirty=!0,v}applyRotationQuaternionInPlace(f){return this.applyRotationQuaternionToRef(f,this)}applyRotationQuaternion(f){return this.applyRotationQuaternionToRef(f,new X)}scaleAndAddToRef(f,v){return v._x+=this._x*f,v._y+=this._y*f,v._z+=this._z*f,v._isDirty=!0,v}projectOnPlane(f,v){return this.projectOnPlaneToRef(f,v,new X)}projectOnPlaneToRef(f,v,Z){const V=f.normal,h=f.d,J=M.Xv[0];this.subtractToRef(v,J),J.normalize();const l=X.Dot(J,V);if(Math.abs(l)<1e-10)Z.Ve(1/0);else{const f=-(X.Dot(v,V)+h)/l,e=J.scaleInPlace(f);v.addToRef(e,Z)}return Z}equals(f){return f&&this._x===f._x&&this._y===f._y&&this._z===f._z}equalsWithEpsilon(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.c;return f&&(0,C.WithinEpsilon)(this._x,f._x,v)&&(0,C.WithinEpsilon)(this._y,f._y,v)&&(0,C.WithinEpsilon)(this._z,f._z,v)}equalsToFloats(f,v,Z){return this._x===f&&this._y===v&&this._z===Z}multiplyInPlace(f){return this._x*=f._x,this._y*=f._y,this._z*=f._z,this._isDirty=!0,this}multiply(f){return this.multiplyByFloats(f._x,f._y,f._z)}multiplyToRef(f,v){return v._x=this._x*f._x,v._y=this._y*f._y,v._z=this._z*f._z,v._isDirty=!0,v}multiplyByFloats(f,v,Z){return new X(this._x*f,this._y*v,this._z*Z)}divide(f){return new X(this._x/f._x,this._y/f._y,this._z/f._z)}divideToRef(f,v){return v._x=this._x/f._x,v._y=this._y/f._y,v._z=this._z/f._z,v._isDirty=!0,v}divideInPlace(f){return this._x=this._x/f._x,this._y=this._y/f._y,this._z=this._z/f._z,this._isDirty=!0,this}minimizeInPlace(f){return this.minimizeInPlaceFromFloats(f._x,f._y,f._z)}maximizeInPlace(f){return this.maximizeInPlaceFromFloats(f._x,f._y,f._z)}minimizeInPlaceFromFloats(f,v,Z){return f<this._x&&(this.x=f),v<this._y&&(this.y=v),Z<this._z&&(this.z=Z),this}maximizeInPlaceFromFloats(f,v,Z){return f>this._x&&(this.x=f),v>this._y&&(this.y=v),Z>this._z&&(this.z=Z),this}isNonUniformWithinEpsilon(f){const v=Math.abs(this._x),Z=Math.abs(this._y);if(!(0,C.WithinEpsilon)(v,Z,f))return!0;const V=Math.abs(this._z);return!(0,C.WithinEpsilon)(v,V,f)||!(0,C.WithinEpsilon)(Z,V,f)}get isNonUniform(){const f=Math.abs(this._x);if(f!==Math.abs(this._y))return!0;return f!==Math.abs(this._z)}floorToRef(f){return f._x=Math.floor(this._x),f._y=Math.floor(this._y),f._z=Math.floor(this._z),f._isDirty=!0,f}floor(){return new X(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(f){return f._x=this._x-Math.floor(this._x),f._y=this._y-Math.floor(this._y),f._z=this._z-Math.floor(this._z),f._isDirty=!0,f}fract(){return new X(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(f){if("xyz"===(f=f.toLowerCase()))return this;const v=M.Xv[0].h(this);return this.x=v[f[0]],this.y=v[f[1]],this.z=v[f[2]],this}rotateByQuaternionToRef(f,v){return f.toRotationMatrix(M.Matrix[0]),X.TransformCoordinatesToRef(this,M.Matrix[0],v),v}rotateByQuaternionAroundPointToRef(f,v,Z){return this.subtractToRef(v,M.Xv[0]),M.Xv[0].rotateByQuaternionToRef(f,M.Xv[0]),v.addToRef(M.Xv[0],Z),Z}cross(f){return X.CrossToRef(this,f,new X)}normalizeFromLength(f){return 0===f||1===f?this:this.scaleInPlace(1/f)}normalizeToNew(){return this.normalizeToRef(new X)}normalizeToRef(f){const v=this.length();return 0===v||1===v?(f._x=this._x,f._y=this._y,f._z=this._z,f._isDirty=!0,f):this.scaleToRef(1/v,f)}clone(){return new X(this._x,this._y,this._z)}h(f){return this.fe(f._x,f._y,f._z)}fe(f,v,Z){return this._x=f,this._y=v,this._z=Z,this._isDirty=!0,this}set(f,v,Z){return this.fe(f,v,Z)}Ve(f){return this._x=this._y=this._z=f,this._isDirty=!0,this}static GetClipFactor(f,v,Z,V){const h=X.Dot(f,Z);return(h-V)/(h-X.Dot(v,Z))}static GetAngleBetweenVectors(f,v,Z){const V=f.normalizeToRef(M.Xv[1]),h=v.normalizeToRef(M.Xv[2]);let J=X.Dot(V,h);J=(0,C.Clamp)(J,-1,1);const l=Math.acos(J),e=M.Xv[3];return X.CrossToRef(V,h,e),X.Dot(e,Z)>0?isNaN(l)?0:l:isNaN(l)?-Math.PI:-Math.acos(J)}static GetAngleBetweenVectorsOnPlane(f,v,Z){M.Xv[0].h(f);const V=M.Xv[0];M.Xv[1].h(v);const h=M.Xv[1];M.Xv[2].h(Z);const J=M.Xv[2],l=M.Xv[3],e=M.Xv[4];V.normalize(),h.normalize(),J.normalize(),X.CrossToRef(J,V,l),X.CrossToRef(l,J,e);const H=Math.atan2(X.Dot(h,l),X.Dot(h,e));return(0,C.NormalizeRadians)(H)}static PitchYawRollToMoveBetweenPointsToRef(f,v,Z){const V=A.Xv[0];return v.subtractToRef(f,V),Z._y=Math.atan2(V.x,V.z)||0,Z._x=Math.atan2(Math.sqrt(V.x**2+V.z**2),V.y)||0,Z._z=0,Z._isDirty=!0,Z}static PitchYawRollToMoveBetweenPoints(f,v){const Z=X.Zero();return X.PitchYawRollToMoveBetweenPointsToRef(f,v,Z)}static SlerpToRef(f,v,Z,h){Z=(0,C.Clamp)(Z,0,1);const J=M.Xv[0],l=M.Xv[1];J.h(f);const e=J.length();J.normalizeFromLength(e),l.h(v);const H=l.length();l.normalizeFromLength(H);const O=X.Dot(J,l);let u,W;if(O<1-V.c){const f=Math.acos(O),v=1/Math.sin(f);u=Math.sin((1-Z)*f)*v,W=Math.sin(Z*f)*v}else u=1-Z,W=Z;return J.scaleInPlace(u),l.scaleInPlace(W),h.h(J).addInPlace(l),h.scaleInPlace((0,C.Lerp)(e,H,Z)),h}static SmoothToRef(f,v,Z,V,h){return X.SlerpToRef(f,v,0===V?1:Z/V,h),h}static Av(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new X(f[v],f[v+1],f[v+2])}static FromFloatArray(f,v){return X.Av(f,v)}static FromArrayToRef(f,v,Z){return Z._x=f[v],Z._y=f[v+1],Z._z=f[v+2],Z._isDirty=!0,Z}static FromFloatArrayToRef(f,v,Z){return X.FromArrayToRef(f,v,Z)}static FromFloatsToRef(f,v,Z,V){return V.fe(f,v,Z),V}static Zero(){return new X(0,0,0)}static One(){return new X(1,1,1)}static Up(){return new X(0,1,0)}static get UpReadOnly(){return X._UpReadOnly}static get DownReadOnly(){return X._DownReadOnly}static get RightReadOnly(){return X._RightReadOnly}static get LeftReadOnly(){return X._LeftReadOnly}static get LeftHandedForwardReadOnly(){return X._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return X._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return X._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return X._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return X._ZeroReadOnly}static get OneReadOnly(){return X._OneReadOnly}static Down(){return new X(0,-1,0)}static Forward(){return new X(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new X(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new X(1,0,0)}static Left(){return new X(-1,0,0)}static Random(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new X((0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v))}static RandomToRef(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fe((0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v))}static TransformCoordinates(f,v){const Z=X.Zero();return X.TransformCoordinatesToRef(f,v,Z),Z}static TransformCoordinatesToRef(f,v,Z){return X.TransformCoordinatesFromFloatsToRef(f._x,f._y,f._z,v,Z),Z}static TransformCoordinatesFromFloatsToRef(f,v,Z,V,h){const J=V.m,l=f*J[0]+v*J[4]+Z*J[8]+J[12],e=f*J[1]+v*J[5]+Z*J[9]+J[13],C=f*J[2]+v*J[6]+Z*J[10]+J[14],H=1/(f*J[3]+v*J[7]+Z*J[11]+J[15]);return h._x=l*H,h._y=e*H,h._z=C*H,h._isDirty=!0,h}static TransformNormal(f,v){const Z=X.Zero();return X.TransformNormalToRef(f,v,Z),Z}static TransformNormalToRef(f,v,Z){return this.TransformNormalFromFloatsToRef(f._x,f._y,f._z,v,Z),Z}static TransformNormalFromFloatsToRef(f,v,Z,V,h){const J=V.m;return h._x=f*J[0]+v*J[4]+Z*J[8],h._y=f*J[1]+v*J[5]+Z*J[9],h._z=f*J[2]+v*J[6]+Z*J[10],h._isDirty=!0,h}static CatmullRom(f,v,Z,V,h){const J=h*h,l=h*J,e=.5*(2*v._x+(-f._x+Z._x)*h+(2*f._x-5*v._x+4*Z._x-V._x)*J+(-f._x+3*v._x-3*Z._x+V._x)*l),C=.5*(2*v._y+(-f._y+Z._y)*h+(2*f._y-5*v._y+4*Z._y-V._y)*J+(-f._y+3*v._y-3*Z._y+V._y)*l),H=.5*(2*v._z+(-f._z+Z._z)*h+(2*f._z-5*v._z+4*Z._z-V._z)*J+(-f._z+3*v._z-3*Z._z+V._z)*l);return new X(e,C,H)}static Clamp(f,v,Z){const V=new X;return X.ClampToRef(f,v,Z,V),V}static ClampToRef(f,v,Z,V){let h=f._x;h=h>Z._x?Z._x:h,h=h<v._x?v._x:h;let J=f._y;J=J>Z._y?Z._y:J,J=J<v._y?v._y:J;let l=f._z;return l=l>Z._z?Z._z:l,l=l<v._z?v._z:l,V.fe(h,J,l),V}static CheckExtends(f,v,Z){v.minimizeInPlace(f),Z.maximizeInPlace(f)}static Hermite(f,v,Z,V,h){const J=h*h,l=h*J,e=2*l-3*J+1,C=-2*l+3*J,H=l-2*J+h,O=l-J,u=f._x*e+Z._x*C+v._x*H+V._x*O,W=f._y*e+Z._y*C+v._y*H+V._y*O,a=f._z*e+Z._z*C+v._z*H+V._z*O;return new X(u,W,a)}static Hermite1stDerivative(f,v,Z,V,h){const J=new X;return this.Hermite1stDerivativeToRef(f,v,Z,V,h,J),J}static Hermite1stDerivativeToRef(f,v,Z,V,h,J){const l=h*h;return J._x=6*(l-h)*f._x+(3*l-4*h+1)*v._x+6*(-l+h)*Z._x+(3*l-2*h)*V._x,J._y=6*(l-h)*f._y+(3*l-4*h+1)*v._y+6*(-l+h)*Z._y+(3*l-2*h)*V._y,J._z=6*(l-h)*f._z+(3*l-4*h+1)*v._z+6*(-l+h)*Z._z+(3*l-2*h)*V._z,J._isDirty=!0,J}static Lerp(f,v,Z){const V=new X(0,0,0);return X.LerpToRef(f,v,Z,V),V}static LerpToRef(f,v,Z,V){return V._x=f._x+(v._x-f._x)*Z,V._y=f._y+(v._y-f._y)*Z,V._z=f._z+(v._z-f._z)*Z,V._isDirty=!0,V}static Dot(f,v){return f._x*v._x+f._y*v._y+f._z*v._z}dot(f){return this._x*f._x+this._y*f._y+this._z*f._z}static Cross(f,v){const Z=new X;return X.CrossToRef(f,v,Z),Z}static CrossToRef(f,v,Z){const V=f._y*v._z-f._z*v._y,h=f._z*v._x-f._x*v._z,J=f._x*v._y-f._y*v._x;return Z.fe(V,h,J),Z}static Normalize(f){const v=X.Zero();return X.NormalizeToRef(f,v),v}static NormalizeToRef(f,v){return f.normalizeToRef(v),v}static Project(f,v,Z,V){const h=new X;return X.ProjectToRef(f,v,Z,V,h),h}static ProjectToRef(f,v,Z,V,h){var J;const l=V.width,C=V.height,H=V.x,O=V.y,u=M.Matrix[1],W=null===(J=e.c.LastCreatedEngine)||void 0===J?void 0:J.isNDCHalfZRange,a=W?1:.5,b=W?0:.5;K.FromValuesToRef(l/2,0,0,0,0,-C/2,0,0,0,0,a,0,H+l/2,C/2+O,b,1,u);const F=M.Matrix[0];return v.multiplyToRef(Z,F),F.multiplyToRef(u,F),X.TransformCoordinatesToRef(f,F,h),h}static Reflect(f,v){return this.ReflectToRef(f,v,new X)}static ReflectToRef(f,v,Z){const V=A.Xv[0];return V.h(v).scaleInPlace(2*X.Dot(f,v)),Z.h(f).hu(V)}static _UnprojectFromInvertedMatrixToRef(f,v,Z){X.TransformCoordinatesToRef(f,v,Z);const V=v.m,h=f._x*V[3]+f._y*V[7]+f._z*V[11]+V[15];return(0,C.WithinEpsilon)(h,1)&&Z.scaleInPlace(1/h),Z}static UnprojectFromTransform(f,v,Z,V,h){return this.Unproject(f,v,Z,V,h,K.IdentityReadOnly)}static Unproject(f,v,Z,V,h,J){const l=new X;return X.UnprojectToRef(f,v,Z,V,h,J,l),l}static UnprojectToRef(f,v,Z,V,h,J,l){return X.UnprojectFloatsToRef(f._x,f._y,f._z,v,Z,V,h,J,l),l}static UnprojectFloatsToRef(f,v,Z,V,h,J,l,C,H){var O;const u=M.Matrix[0];J.multiplyToRef(l,u),u.multiplyToRef(C,u),u.invert();const W=M.Xv[0];return W.x=f/V*2-1,W.y=-(v/h*2-1),null!==(O=e.c.LastCreatedEngine)&&void 0!==O&&O.isNDCHalfZRange?W.z=Z:W.z=2*Z-1,X._UnprojectFromInvertedMatrixToRef(W,u,H),H}static Minimize(f,v){const Z=new X;return Z.h(f),Z.minimizeInPlace(v),Z}static Maximize(f,v){const Z=new X;return Z.h(f),Z.maximizeInPlace(v),Z}static Distance(f,v){return Math.sqrt(X.DistanceSquared(f,v))}static DistanceSquared(f,v){const Z=f._x-v._x,V=f._y-v._y,h=f._z-v._z;return Z*Z+V*V+h*h}static ProjectOnTriangleToRef(f,v,Z,h,J){const l=M.Xv[0],e=M.Xv[1],H=M.Xv[2],O=M.Xv[3],u=M.Xv[4];Z.subtractToRef(v,l),h.subtractToRef(v,e),h.subtractToRef(Z,H);const W=l.length(),a=e.length(),b=H.length();if(W<V.c||a<V.c||b<V.c)return J.h(v),X.Distance(f,v);f.subtractToRef(v,u),X.CrossToRef(l,e,O);const F=O.length();if(F<V.c)return J.h(v),X.Distance(f,v);O.normalizeFromLength(F);let U=u.length();if(U<V.c)return J.h(v),0;u.normalizeFromLength(U);const K=X.Dot(O,u),A=M.Xv[5],s=M.Xv[6];A.h(O).scaleInPlace(-U*K),s.h(f).addInPlace(A);const z=M.Xv[4],Y=M.Xv[5],y=M.Xv[7],N=M.Xv[8];z.h(l).scaleInPlace(1/W),N.h(e).scaleInPlace(1/a),z.addInPlace(N).scaleInPlace(-1),Y.h(l).scaleInPlace(-1/W),N.h(H).scaleInPlace(1/b),Y.addInPlace(N).scaleInPlace(-1),y.h(H).scaleInPlace(-1/b),N.h(e).scaleInPlace(-1/a),y.addInPlace(N).scaleInPlace(-1);const i=M.Xv[9];let I;i.h(s).hu(v),X.CrossToRef(z,i,N),I=X.Dot(N,O);const T=I;i.h(s).hu(Z),X.CrossToRef(Y,i,N),I=X.Dot(N,O);const B=I;i.h(s).hu(h),X.CrossToRef(y,i,N),I=X.Dot(N,O);const P=I,g=M.Xv[10];let w,t;T>0&&B<0?(g.h(l),w=v,t=Z):B>0&&P<0?(g.h(H),w=Z,t=h):(g.h(e).scaleInPlace(-1),w=h,t=v);const L=M.Xv[9],E=M.Xv[4];w.subtractToRef(s,N),t.subtractToRef(s,L),X.CrossToRef(N,L,E);if(!(X.Dot(E,O)<0))return J.h(s),Math.abs(U*K);const j=M.Xv[5];X.CrossToRef(g,E,j),j.normalize();const q=M.Xv[9];q.h(w).hu(s);const c=q.length();if(c<V.c)return J.h(w),X.Distance(f,w);q.normalizeFromLength(c);const m=X.Dot(j,q),p=M.Xv[7];p.h(s).addInPlace(j.scaleInPlace(c*m)),N.h(p).hu(w),U=g.length(),g.normalizeFromLength(U);let k=X.Dot(N,g)/Math.max(U,V.c);return k=(0,C.Clamp)(k,0,1),p.h(w).addInPlace(g.scaleInPlace(k*U)),J.h(p),X.Distance(f,p)}static Center(f,v){return X.CenterToRef(f,v,X.Zero())}static CenterToRef(f,v,Z){return Z.fe((f._x+v._x)/2,(f._y+v._y)/2,(f._z+v._z)/2)}static RotationFromAxis(f,v,Z){const V=new X;return X.RotationFromAxisToRef(f,v,Z,V),V}static RotationFromAxisToRef(f,v,Z,V){const h=M.Quaternion[0];return U.RotationQuaternionFromAxisToRef(f,v,Z,h),h.toEulerAnglesToRef(V),V}}X._V8PerformanceHack=new X(.5,.5,.5),X._UpReadOnly=X.Up(),X._DownReadOnly=X.Down(),X._LeftHandedForwardReadOnly=X.Forward(!1),X._RightHandedForwardReadOnly=X.Forward(!0),X._LeftHandedBackwardReadOnly=X.Backward(!1),X._RightHandedBackwardReadOnly=X.Backward(!0),X._RightReadOnly=X.Right(),X._LeftReadOnly=X.Left(),X._ZeroReadOnly=X.Zero(),X._OneReadOnly=X.One(),Object.defineProperties(X.prototype,{dimension:{value:[3]},rank:{value:1}});class F{get x(){return this._x}set x(f){this._x=f,this._isDirty=!0}get y(){return this._y}set y(f){this._y=f,this._isDirty=!0}get z(){return this._z}set z(f){this._z=f,this._isDirty=!0}get w(){return this._w}set w(f){this._w=f,this._isDirty=!0}constructor(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=f,this._y=v,this._z=Z,this._w=V}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let f=a(this._x);return f=397*f^a(this._y),f=397*f^a(this._z),f=397*f^a(this._w),f}Ph(){return[this._x,this._y,this._z,this._w]}toArray(f,v){return void 0===v&&(v=0),f[v]=this._x,f[v+1]=this._y,f[v+2]=this._z,f[v+3]=this._w,this}bZ(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(f,v,this),this}addInPlace(f){return this.x+=f._x,this.y+=f._y,this.z+=f._z,this.w+=f._w,this}addInPlaceFromFloats(f,v,Z,V){return this.x+=f,this.y+=v,this.z+=Z,this.w+=V,this}add(f){return new F(this._x+f.x,this._y+f.y,this._z+f.z,this._w+f.w)}addToRef(f,v){return v.x=this._x+f.x,v.y=this._y+f.y,v.z=this._z+f.z,v.w=this._w+f.w,v}hu(f){return this.x-=f.x,this.y-=f.y,this.z-=f.z,this.w-=f.w,this}Fv(f){return new F(this._x-f.x,this._y-f.y,this._z-f.z,this._w-f.w)}subtractToRef(f,v){return v.x=this._x-f.x,v.y=this._y-f.y,v.z=this._z-f.z,v.w=this._w-f.w,v}subtractFromFloats(f,v,Z,V){return new F(this._x-f,this._y-v,this._z-Z,this._w-V)}subtractFromFloatsToRef(f,v,Z,V,h){return h.x=this._x-f,h.y=this._y-v,h.z=this._z-Z,h.w=this._w-V,h}negate(){return new F(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(f){return f.x=-this._x,f.y=-this._y,f.z=-this._z,f.w=-this._w,f}scaleInPlace(f){return this.x*=f,this.y*=f,this.z*=f,this.w*=f,this}scale(f){return new F(this._x*f,this._y*f,this._z*f,this._w*f)}scaleToRef(f,v){return v.x=this._x*f,v.y=this._y*f,v.z=this._z*f,v.w=this._w*f,v}scaleAndAddToRef(f,v){return v.x+=this._x*f,v.y+=this._y*f,v.z+=this._z*f,v.w+=this._w*f,v}equals(f){return f&&this._x===f.x&&this._y===f.y&&this._z===f.z&&this._w===f.w}equalsWithEpsilon(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.c;return f&&(0,C.WithinEpsilon)(this._x,f.x,v)&&(0,C.WithinEpsilon)(this._y,f.y,v)&&(0,C.WithinEpsilon)(this._z,f.z,v)&&(0,C.WithinEpsilon)(this._w,f.w,v)}equalsToFloats(f,v,Z,V){return this._x===f&&this._y===v&&this._z===Z&&this._w===V}multiplyInPlace(f){return this.x*=f.x,this.y*=f.y,this.z*=f.z,this.w*=f.w,this}multiply(f){return new F(this._x*f.x,this._y*f.y,this._z*f.z,this._w*f.w)}multiplyToRef(f,v){return v.x=this._x*f.x,v.y=this._y*f.y,v.z=this._z*f.z,v.w=this._w*f.w,v}multiplyByFloats(f,v,Z,V){return new F(this._x*f,this._y*v,this._z*Z,this._w*V)}divide(f){return new F(this._x/f.x,this._y/f.y,this._z/f.z,this._w/f.w)}divideToRef(f,v){return v.x=this._x/f.x,v.y=this._y/f.y,v.z=this._z/f.z,v.w=this._w/f.w,v}divideInPlace(f){return this.divideToRef(f,this)}minimizeInPlace(f){return f.x<this._x&&(this.x=f.x),f.y<this._y&&(this.y=f.y),f.z<this._z&&(this.z=f.z),f.w<this._w&&(this.w=f.w),this}maximizeInPlace(f){return f.x>this._x&&(this.x=f.x),f.y>this._y&&(this.y=f.y),f.z>this._z&&(this.z=f.z),f.w>this._w&&(this.w=f.w),this}minimizeInPlaceFromFloats(f,v,Z,V){return this.x=Math.min(f,this._x),this.y=Math.min(v,this._y),this.z=Math.min(Z,this._z),this.w=Math.min(V,this._w),this}maximizeInPlaceFromFloats(f,v,Z,V){return this.x=Math.max(f,this._x),this.y=Math.max(v,this._y),this.z=Math.max(Z,this._z),this.w=Math.max(V,this._w),this}floorToRef(f){return f.x=Math.floor(this._x),f.y=Math.floor(this._y),f.z=Math.floor(this._z),f.w=Math.floor(this._w),f}floor(){return new F(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(f){return f.x=this._x-Math.floor(this._x),f.y=this._y-Math.floor(this._y),f.z=this._z-Math.floor(this._z),f.w=this._w-Math.floor(this._w),f}fract(){return new F(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(f){return 0===f||1===f?this:this.scaleInPlace(1/f)}normalizeToNew(){return this.normalizeToRef(new F)}normalizeToRef(f){const v=this.length();return 0===v||1===v?(f.x=this._x,f.y=this._y,f.z=this._z,f.w=this._w,f):this.scaleToRef(1/v,f)}toVector3(){return new X(this._x,this._y,this._z)}clone(){return new F(this._x,this._y,this._z,this._w)}h(f){return this.x=f.x,this.y=f.y,this.z=f.z,this.w=f.w,this}fe(f,v,Z,V){return this.x=f,this.y=v,this.z=Z,this.w=V,this}set(f,v,Z,V){return this.fe(f,v,Z,V)}Ve(f){return this.x=this.y=this.z=this.w=f,this}dot(f){return this._x*f.x+this._y*f.y+this._z*f.z+this._w*f.w}static Av(f,v){return v||(v=0),new F(f[v],f[v+1],f[v+2],f[v+3])}static FromArrayToRef(f,v,Z){return Z.x=f[v],Z.y=f[v+1],Z.z=f[v+2],Z.w=f[v+3],Z}static FromFloatArrayToRef(f,v,Z){return F.FromArrayToRef(f,v,Z),Z}static FromFloatsToRef(f,v,Z,V,h){return h.x=f,h.y=v,h.z=Z,h.w=V,h}static Zero(){return new F(0,0,0,0)}static One(){return new F(1,1,1,1)}static Random(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F((0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v))}static RandomToRef(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Z=arguments.length>2?arguments[2]:void 0;return Z.x=(0,C.RandomRange)(f,v),Z.y=(0,C.RandomRange)(f,v),Z.z=(0,C.RandomRange)(f,v),Z.w=(0,C.RandomRange)(f,v),Z}static Clamp(f,v,Z){return F.ClampToRef(f,v,Z,new F)}static ClampToRef(f,v,Z,V){return V.x=(0,C.Clamp)(f.x,v.x,Z.x),V.y=(0,C.Clamp)(f.y,v.y,Z.y),V.z=(0,C.Clamp)(f.z,v.z,Z.z),V.w=(0,C.Clamp)(f.w,v.w,Z.w),V}static CheckExtends(f,v,Z){v.minimizeInPlace(f),Z.maximizeInPlace(f)}static get ZeroReadOnly(){return F._ZeroReadOnly}static Normalize(f){return F.NormalizeToRef(f,new F)}static NormalizeToRef(f,v){return f.normalizeToRef(v),v}static Minimize(f,v){const Z=new F;return Z.h(f),Z.minimizeInPlace(v),Z}static Maximize(f,v){const Z=new F;return Z.h(f),Z.maximizeInPlace(v),Z}static Distance(f,v){return Math.sqrt(F.DistanceSquared(f,v))}static DistanceSquared(f,v){const Z=f.x-v.x,V=f.y-v.y,h=f.z-v.z,J=f.w-v.w;return Z*Z+V*V+h*h+J*J}static Center(f,v){return F.CenterToRef(f,v,new F)}static CenterToRef(f,v,Z){return Z.x=(f.x+v.x)/2,Z.y=(f.y+v.y)/2,Z.z=(f.z+v.z)/2,Z.w=(f.w+v.w)/2,Z}static TransformCoordinates(f,v){return F.TransformCoordinatesToRef(f,v,new F)}static TransformCoordinatesToRef(f,v,Z){return F.TransformCoordinatesFromFloatsToRef(f._x,f._y,f._z,v,Z),Z}static TransformCoordinatesFromFloatsToRef(f,v,Z,V,h){const J=V.m,l=f*J[0]+v*J[4]+Z*J[8]+J[12],e=f*J[1]+v*J[5]+Z*J[9]+J[13],C=f*J[2]+v*J[6]+Z*J[10]+J[14],H=f*J[3]+v*J[7]+Z*J[11]+J[15];return h.x=l,h.y=e,h.z=C,h.w=H,h}static TransformNormal(f,v){return F.TransformNormalToRef(f,v,new F)}static TransformNormalToRef(f,v,Z){const V=v.m,h=f.x*V[0]+f.y*V[4]+f.z*V[8],J=f.x*V[1]+f.y*V[5]+f.z*V[9],l=f.x*V[2]+f.y*V[6]+f.z*V[10];return Z.x=h,Z.y=J,Z.z=l,Z.w=f.w,Z}static TransformNormalFromFloatsToRef(f,v,Z,V,h,J){const l=h.m;return J.x=f*l[0]+v*l[4]+Z*l[8],J.y=f*l[1]+v*l[5]+Z*l[9],J.z=f*l[2]+v*l[6]+Z*l[10],J.w=V,J}static FromVector3(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(f._x,f._y,f._z,v)}static Dot(f,v){return f.x*v.x+f.y*v.y+f.z*v.z+f.w*v.w}}F._V8PerformanceHack=new F(.5,.5,.5,.5),F._ZeroReadOnly=F.Zero(),Object.defineProperties(F.prototype,{dimension:{value:[4]},rank:{value:1}});class U{get x(){return this._x}set x(f){this._x=f,this._isDirty=!0}get y(){return this._y}set y(f){this._y=f,this._isDirty=!0}get z(){return this._z}set z(f){this._z=f,this._isDirty=!0}get w(){return this._w}set w(f){this._w=f,this._isDirty=!0}constructor(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=f,this._y=v,this._z=Z,this._w=V}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let f=a(this._x);return f=397*f^a(this._y),f=397*f^a(this._z),f=397*f^a(this._w),f}Ph(){return[this._x,this._y,this._z,this._w]}toArray(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f[v]=this._x,f[v+1]=this._y,f[v+2]=this._z,f[v+3]=this._w,this}bZ(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U.FromArrayToRef(f,v,this)}equals(f){return f&&this._x===f._x&&this._y===f._y&&this._z===f._z&&this._w===f._w}equalsWithEpsilon(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.c;return f&&(0,C.WithinEpsilon)(this._x,f._x,v)&&(0,C.WithinEpsilon)(this._y,f._y,v)&&(0,C.WithinEpsilon)(this._z,f._z,v)&&(0,C.WithinEpsilon)(this._w,f._w,v)}isApprox(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.c;return f&&((0,C.WithinEpsilon)(this._x,f._x,v)&&(0,C.WithinEpsilon)(this._y,f._y,v)&&(0,C.WithinEpsilon)(this._z,f._z,v)&&(0,C.WithinEpsilon)(this._w,f._w,v)||(0,C.WithinEpsilon)(this._x,-f._x,v)&&(0,C.WithinEpsilon)(this._y,-f._y,v)&&(0,C.WithinEpsilon)(this._z,-f._z,v)&&(0,C.WithinEpsilon)(this._w,-f._w,v))}clone(){return new U(this._x,this._y,this._z,this._w)}h(f){return this._x=f._x,this._y=f._y,this._z=f._z,this._w=f._w,this._isDirty=!0,this}fe(f,v,Z,V){return this._x=f,this._y=v,this._z=Z,this._w=V,this._isDirty=!0,this}set(f,v,Z,V){return this.fe(f,v,Z,V)}Ve(f){return this.fe(f,f,f,f)}add(f){return new U(this._x+f._x,this._y+f._y,this._z+f._z,this._w+f._w)}addInPlace(f){return this._x+=f._x,this._y+=f._y,this._z+=f._z,this._w+=f._w,this._isDirty=!0,this}addToRef(f,v){return v._x=this._x+f._x,v._y=this._y+f._y,v._z=this._z+f._z,v._w=this._w+f._w,v._isDirty=!0,v}addInPlaceFromFloats(f,v,Z,V){return this._x+=f,this._y+=v,this._z+=Z,this._w+=V,this._isDirty=!0,this}subtractToRef(f,v){return v._x=this._x-f._x,v._y=this._y-f._y,v._z=this._z-f._z,v._w=this._w-f._w,v._isDirty=!0,v}subtractFromFloats(f,v,Z,V){return this.subtractFromFloatsToRef(f,v,Z,V,new U)}subtractFromFloatsToRef(f,v,Z,V,h){return h._x=this._x-f,h._y=this._y-v,h._z=this._z-Z,h._w=this._w-V,h._isDirty=!0,h}Fv(f){return new U(this._x-f._x,this._y-f._y,this._z-f._z,this._w-f._w)}hu(f){return this._x-=f._x,this._y-=f._y,this._z-=f._z,this._w-=f._w,this._isDirty=!0,this}scale(f){return new U(this._x*f,this._y*f,this._z*f,this._w*f)}scaleToRef(f,v){return v._x=this._x*f,v._y=this._y*f,v._z=this._z*f,v._w=this._w*f,v._isDirty=!0,v}scaleInPlace(f){return this._x*=f,this._y*=f,this._z*=f,this._w*=f,this._isDirty=!0,this}scaleAndAddToRef(f,v){return v._x+=this._x*f,v._y+=this._y*f,v._z+=this._z*f,v._w+=this._w*f,v._isDirty=!0,v}multiply(f){const v=new U(0,0,0,1);return this.multiplyToRef(f,v),v}multiplyToRef(f,v){const Z=this._x*f._w+this._y*f._z-this._z*f._y+this._w*f._x,V=-this._x*f._z+this._y*f._w+this._z*f._x+this._w*f._y,h=this._x*f._y-this._y*f._x+this._z*f._w+this._w*f._z,J=-this._x*f._x-this._y*f._y-this._z*f._z+this._w*f._w;return v.fe(Z,V,h,J),v}multiplyInPlace(f){return this.multiplyToRef(f,this)}multiplyByFloats(f,v,Z,V){return this._x*=f,this._y*=v,this._z*=Z,this._w*=V,this._isDirty=!0,this}divide(f){throw new ReferenceError("Can not divide a quaternion")}divideToRef(f,v){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(f){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new U)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(f){return f._x=-this._x,f._y=-this._y,f._z=-this._z,f._w=-this._w,f._isDirty=!0,f}equalsToFloats(f,v,Z,V){return this._x===f&&this._y===v&&this._z===Z&&this._w===V}floorToRef(f){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(f){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(f){return f.fe(-this._x,-this._y,-this._z,this._w),f}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new U(-this._x,-this._y,-this._z,this._w)}invert(){const f=this.conjugate(),v=this.lengthSquared();return 0==v||1==v||f.scaleInPlace(1/v),f}invertInPlace(){this.conjugateInPlace();const f=this.lengthSquared();return 0==f||1==f||this.scaleInPlace(1/f),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(f){return 0===f||1===f?this:this.scaleInPlace(1/f)}normalizeToNew(){const f=new U(0,0,0,1);return this.normalizeToRef(f),f}normalizeToRef(f){const v=this.length();return 0===v||1===v?f.fe(this._x,this._y,this._z,this._w):this.scaleToRef(1/v,f)}toEulerAngles(){const f=X.Zero();return this.toEulerAnglesToRef(f),f}toEulerAnglesToRef(f){const v=this._z,Z=this._x,V=this._y,h=this._w,J=V*v-Z*h,l=.4999999;if(J<-l)f._y=2*Math.atan2(V,h),f._x=Math.PI/2,f._z=0,f._isDirty=!0;else if(J>l)f._y=2*Math.atan2(V,h),f._x=-Math.PI/2,f._z=0,f._isDirty=!0;else{const l=h*h,e=v*v,C=Z*Z,H=V*V;f._z=Math.atan2(2*(Z*V+v*h),-e-C+H+l),f._x=Math.asin(-2*J),f._y=Math.atan2(2*(v*Z+V*h),e-C-H+l),f._isDirty=!0}return f}toAlphaBetaGammaToRef(f){const v=this._z,Z=this._x,V=this._y,h=this._w,J=Math.sqrt(Z*Z+V*V),l=Math.sqrt(v*v+h*h),e=2*Math.atan2(J,l),C=2*Math.atan2(v,h),H=2*Math.atan2(V,Z),O=(C+H)/2,u=(C-H)/2;return f.set(u,e,O),f}toRotationMatrix(f){return K.FromQuaternionToRef(this,f),f}fromRotationMatrix(f){return U.FromRotationMatrixToRef(f,this),this}dot(f){return this._x*f._x+this._y*f._y+this._z*f._z+this._w*f._w}toAxisAngle(){const f=X.Zero();return{axis:f,angle:this.toAxisAngleToRef(f)}}toAxisAngleToRef(f){let v=0;const Z=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),V=this._w;return Z>0?(v=2*Math.atan2(Z,V),f.set(this._x/Z,this._y/Z,this._z/Z)):(v=0,f.set(1,0,0)),v}static FromRotationMatrix(f){const v=new U;return U.FromRotationMatrixToRef(f,v),v}static FromRotationMatrixToRef(f,v){const Z=f.m,V=Z[0],h=Z[4],J=Z[8],l=Z[1],e=Z[5],C=Z[9],H=Z[2],O=Z[6],u=Z[10],W=V+e+u;let a;return W>0?(a=.5/Math.sqrt(W+1),v._w=.25/a,v._x=(O-C)*a,v._y=(J-H)*a,v._z=(l-h)*a,v._isDirty=!0):V>e&&V>u?(a=2*Math.sqrt(1+V-e-u),v._w=(O-C)/a,v._x=.25*a,v._y=(h+l)/a,v._z=(J+H)/a,v._isDirty=!0):e>u?(a=2*Math.sqrt(1+e-V-u),v._w=(J-H)/a,v._x=(h+l)/a,v._y=.25*a,v._z=(C+O)/a,v._isDirty=!0):(a=2*Math.sqrt(1+u-V-e),v._w=(l-h)/a,v._x=(J+H)/a,v._y=(C+O)/a,v._z=.25*a,v._isDirty=!0),v}static Dot(f,v){return f._x*v._x+f._y*v._y+f._z*v._z+f._w*v._w}static AreClose(f,v){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const V=U.Dot(f,v);return 1-V*V<=Z}static SmoothToRef(f,v,Z,V,h){let J=0===V?1:Z/V;return J=(0,C.Clamp)(J,0,1),U.SlerpToRef(f,v,J,h),h}static Zero(){return new U(0,0,0,0)}static Inverse(f){return new U(-f._x,-f._y,-f._z,f._w)}static InverseToRef(f,v){return v.set(-f._x,-f._y,-f._z,f._w),v}static Identity(){return new U(0,0,0,1)}static IsIdentity(f){return f&&0===f._x&&0===f._y&&0===f._z&&1===f._w}static RotationAxis(f,v){return U.RotationAxisToRef(f,v,new U)}static RotationAxisToRef(f,v,Z){Z._w=Math.cos(v/2);const V=Math.sin(v/2)/f.length();return Z._x=f._x*V,Z._y=f._y*V,Z._z=f._z*V,Z._isDirty=!0,Z}static Av(f,v){return v||(v=0),new U(f[v],f[v+1],f[v+2],f[v+3])}static FromArrayToRef(f,v,Z){return Z._x=f[v],Z._y=f[v+1],Z._z=f[v+2],Z._w=f[v+3],Z._isDirty=!0,Z}static FromFloatsToRef(f,v,Z,V,h){return h.fe(f,v,Z,V),h}static FromEulerAngles(f,v,Z){const V=new U;return U.RotationYawPitchRollToRef(v,f,Z,V),V}static FromEulerAnglesToRef(f,v,Z,V){return U.RotationYawPitchRollToRef(v,f,Z,V),V}static FromEulerVector(f){const v=new U;return U.RotationYawPitchRollToRef(f._y,f._x,f._z,v),v}static FromEulerVectorToRef(f,v){return U.RotationYawPitchRollToRef(f._y,f._x,f._z,v),v}static FromUnitVectorsToRef(f,v,Z){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V.c;const J=X.Dot(f,v)+1;return J<h?Math.abs(f.x)>Math.abs(f.z)?Z.set(-f.y,f.x,0,0):Z.set(0,-f.z,f.y,0):(X.CrossToRef(f,v,A.Xv[0]),Z.set(A.Xv[0].x,A.Xv[0].y,A.Xv[0].z,J)),Z.normalize()}static RotationYawPitchRoll(f,v,Z){const V=new U;return U.RotationYawPitchRollToRef(f,v,Z,V),V}static RotationYawPitchRollToRef(f,v,Z,V){const h=.5*Z,J=.5*v,l=.5*f,e=Math.sin(h),C=Math.cos(h),H=Math.sin(J),O=Math.cos(J),u=Math.sin(l),W=Math.cos(l);return V._x=W*H*C+u*O*e,V._y=u*O*C-W*H*e,V._z=W*O*e-u*H*C,V._w=W*O*C+u*H*e,V._isDirty=!0,V}static RotationAlphaBetaGamma(f,v,Z){const V=new U;return U.RotationAlphaBetaGammaToRef(f,v,Z,V),V}static RotationAlphaBetaGammaToRef(f,v,Z,V){const h=.5*(Z+f),J=.5*(Z-f),l=.5*v;return V._x=Math.cos(J)*Math.sin(l),V._y=Math.sin(J)*Math.sin(l),V._z=Math.sin(h)*Math.cos(l),V._w=Math.cos(h)*Math.cos(l),V._isDirty=!0,V}static RotationQuaternionFromAxis(f,v,Z){const V=new U(0,0,0,0);return U.RotationQuaternionFromAxisToRef(f,v,Z,V),V}static RotationQuaternionFromAxisToRef(f,v,Z,V){const h=M.Matrix[0];return f=f.normalizeToRef(M.Xv[0]),v=v.normalizeToRef(M.Xv[1]),Z=Z.normalizeToRef(M.Xv[2]),K.FromXYZAxesToRef(f,v,Z,h),U.FromRotationMatrixToRef(h,V),V}static FromLookDirectionLH(f,v){const Z=new U;return U.FromLookDirectionLHToRef(f,v,Z),Z}static FromLookDirectionLHToRef(f,v,Z){const V=M.Matrix[0];return K.LookDirectionLHToRef(f,v,V),U.FromRotationMatrixToRef(V,Z),Z}static FromLookDirectionRH(f,v){const Z=new U;return U.FromLookDirectionRHToRef(f,v,Z),Z}static FromLookDirectionRHToRef(f,v,Z){const V=M.Matrix[0];return K.LookDirectionRHToRef(f,v,V),U.FromRotationMatrixToRef(V,Z)}static Slerp(f,v,Z){const V=U.Identity();return U.SlerpToRef(f,v,Z,V),V}static SlerpToRef(f,v,Z,V){let h,J,l=f._x*v._x+f._y*v._y+f._z*v._z+f._w*v._w,e=!1;if(l<0&&(e=!0,l=-l),l>.999999)J=1-Z,h=e?-Z:Z;else{const f=Math.acos(l),v=1/Math.sin(f);J=Math.sin((1-Z)*f)*v,h=e?-Math.sin(Z*f)*v:Math.sin(Z*f)*v}return V._x=J*f._x+h*v._x,V._y=J*f._y+h*v._y,V._z=J*f._z+h*v._z,V._w=J*f._w+h*v._w,V._isDirty=!0,V}static Hermite(f,v,Z,V,h){const J=h*h,l=h*J,e=2*l-3*J+1,C=-2*l+3*J,H=l-2*J+h,O=l-J,u=f._x*e+Z._x*C+v._x*H+V._x*O,W=f._y*e+Z._y*C+v._y*H+V._y*O,a=f._z*e+Z._z*C+v._z*H+V._z*O,b=f._w*e+Z._w*C+v._w*H+V._w*O;return new U(u,W,a,b)}static Hermite1stDerivative(f,v,Z,V,h){const J=new U;return this.Hermite1stDerivativeToRef(f,v,Z,V,h,J),J}static Hermite1stDerivativeToRef(f,v,Z,V,h,J){const l=h*h;return J._x=6*(l-h)*f._x+(3*l-4*h+1)*v._x+6*(-l+h)*Z._x+(3*l-2*h)*V._x,J._y=6*(l-h)*f._y+(3*l-4*h+1)*v._y+6*(-l+h)*Z._y+(3*l-2*h)*V._y,J._z=6*(l-h)*f._z+(3*l-4*h+1)*v._z+6*(-l+h)*Z._z+(3*l-2*h)*V._z,J._w=6*(l-h)*f._w+(3*l-4*h+1)*v._w+6*(-l+h)*Z._w+(3*l-2*h)*V._w,J._isDirty=!0,J}static Normalize(f){const v=U.Zero();return U.NormalizeToRef(f,v),v}static NormalizeToRef(f,v){return f.normalizeToRef(v),v}static Clamp(f,v,Z){const V=new U;return U.ClampToRef(f,v,Z,V),V}static ClampToRef(f,v,Z,V){return V.fe((0,C.Clamp)(f.x,v.x,Z.x),(0,C.Clamp)(f.y,v.y,Z.y),(0,C.Clamp)(f.z,v.z,Z.z),(0,C.Clamp)(f.w,v.w,Z.w))}static Random(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new U((0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v))}static RandomToRef(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fe((0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v),(0,C.RandomRange)(f,v))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(f,v){return Math.sqrt(U.DistanceSquared(f,v))}static DistanceSquared(f,v){const Z=f.x-v.x,V=f.y-v.y,h=f.z-v.z,J=f.w-v.w;return Z*Z+V*V+h*h+J*J}static Center(f,v){return U.CenterToRef(f,v,U.Zero())}static CenterToRef(f,v,Z){return Z.fe((f.x+v.x)/2,(f.y+v.y)/2,(f.z+v.z)/2,(f.w+v.w)/2)}}U._V8PerformanceHack=new U(.5,.5,.5,.5),Object.defineProperties(U.prototype,{dimension:{value:[4]},rank:{value:1}});class K{static get Use64Bits(){return l.e.MatrixUse64Bits}get m(){return this.Mh}markAsUpdated(){this.updateFlag=H._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(f){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Z=arguments.length>2&&void 0!==arguments[2]&&arguments[2],V=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=f,this._isIdentity3x2=f||Z,this._isIdentityDirty=!this._isIdentity&&v,this._isIdentity3x2Dirty=!this._isIdentity3x2&&V}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,l.e.MatrixTrackPrecisionChange&&l.e.MatrixTrackedMatrices.push(this),this.Mh=new l.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const f=this.Mh;this._isIdentity=1===f[0]&&0===f[1]&&0===f[2]&&0===f[3]&&0===f[4]&&1===f[5]&&0===f[6]&&0===f[7]&&0===f[8]&&0===f[9]&&1===f[10]&&0===f[11]&&0===f[12]&&0===f[13]&&0===f[14]&&1===f[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Mh[0]||1!==this.Mh[5]||1!==this.Mh[15]||0!==this.Mh[1]||0!==this.Mh[2]||0!==this.Mh[3]||0!==this.Mh[4]||0!==this.Mh[6]||0!==this.Mh[7]||0!==this.Mh[8]||0!==this.Mh[9]||0!==this.Mh[10]||0!==this.Mh[11]||0!==this.Mh[12]||0!==this.Mh[13]||0!==this.Mh[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const f=this.Mh,v=f[0],Z=f[1],V=f[2],h=f[3],J=f[4],l=f[5],e=f[6],C=f[7],H=f[8],O=f[9],u=f[10],W=f[11],a=f[12],b=f[13],X=f[14],F=f[15],U=u*F-X*W,K=O*F-b*W,M=O*X-b*u,A=H*F-a*W,s=H*X-u*a,z=H*b-a*O;return v*+(l*U-e*K+C*M)+Z*-(J*U-e*A+C*s)+V*+(J*K-l*A+C*z)+h*-(J*M-l*s+e*z)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!f)return this.Mh;const Z=this.Mh;for(let V=0;V<16;V++)f[v+V]=Z[V];return this}Ph(){return this.Mh}bZ(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(f,v,this)}fe(){for(var f=arguments.length,v=new Array(f),Z=0;Z<f;Z++)v[Z]=arguments[Z];return K.FromArrayToRef(v,0,this)}set(){const f=this.Mh;for(let v=0;v<16;v++)f[v]=v<0||arguments.length<=v?void 0:arguments[v];return this.markAsUpdated(),this}Ve(f){const v=this.Mh;for(let Z=0;Z<16;Z++)v[Z]=f;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return K.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(f){const v=new K;return this.addToRef(f,v),v}addToRef(f,v){const Z=this.Mh,V=v.Mh,h=f.m;for(let J=0;J<16;J++)V[J]=Z[J]+h[J];return v.markAsUpdated(),v}addToSelf(f){const v=this.Mh,Z=f.m;return v[0]+=Z[0],v[1]+=Z[1],v[2]+=Z[2],v[3]+=Z[3],v[4]+=Z[4],v[5]+=Z[5],v[6]+=Z[6],v[7]+=Z[7],v[8]+=Z[8],v[9]+=Z[9],v[10]+=Z[10],v[11]+=Z[11],v[12]+=Z[12],v[13]+=Z[13],v[14]+=Z[14],v[15]+=Z[15],this.markAsUpdated(),this}addInPlace(f){const v=this.Mh,Z=f.m;for(let V=0;V<16;V++)v[V]+=Z[V];return this.markAsUpdated(),this}addInPlaceFromFloats(){const f=this.Mh;for(let v=0;v<16;v++)f[v]+=v<0||arguments.length<=v?void 0:arguments[v];return this.markAsUpdated(),this}Fv(f){const v=this.Mh,Z=f.m;for(let V=0;V<16;V++)v[V]-=Z[V];return this.markAsUpdated(),this}subtractToRef(f,v){const Z=this.Mh,V=f.m,h=v.Mh;for(let J=0;J<16;J++)h[J]=Z[J]-V[J];return v.markAsUpdated(),v}hu(f){const v=this.Mh,Z=f.m;for(let V=0;V<16;V++)v[V]-=Z[V];return this.markAsUpdated(),this}subtractFromFloats(){for(var f=arguments.length,v=new Array(f),Z=0;Z<f;Z++)v[Z]=arguments[Z];return this.subtractFromFloatsToRef(...v,new K)}subtractFromFloatsToRef(){for(var f=arguments.length,v=new Array(f),Z=0;Z<f;Z++)v[Z]=arguments[Z];const V=v.pop(),h=this.Mh,J=V.Mh,l=v;for(let e=0;e<16;e++)J[e]=h[e]-l[e];return V.markAsUpdated(),V}invertToRef(f){return!0===this._isIdentity?(K.IdentityToRef(f),f):(W(this,f.Ph())?f.markAsUpdated():f.h(this),f)}addAtIndex(f,v){return this.Mh[f]+=v,this.markAsUpdated(),this}multiplyAtIndex(f,v){return this.Mh[f]*=v,this.markAsUpdated(),this}setTranslationFromFloats(f,v,Z){return this.Mh[12]=f,this.Mh[13]=v,this.Mh[14]=Z,this.markAsUpdated(),this}addTranslationFromFloats(f,v,Z){return this.Mh[12]+=f,this.Mh[13]+=v,this.Mh[14]+=Z,this.markAsUpdated(),this}setTranslation(f){return this.setTranslationFromFloats(f._x,f._y,f._z)}getTranslation(){return new X(this.Mh[12],this.Mh[13],this.Mh[14])}getTranslationToRef(f){return f.x=this.Mh[12],f.y=this.Mh[13],f.z=this.Mh[14],f}removeRotationAndScaling(){const f=this.m;return K.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,f[12],f[13],f[14],f[15],this),this._updateIdentityStatus(0===f[12]&&0===f[13]&&0===f[14]&&1===f[15]),this}h(f){f.copyToArray(this.Mh);const v=f;return this.updateFlag=v.updateFlag,this._updateIdentityStatus(v._isIdentity,v._isIdentityDirty,v._isIdentity3x2,v._isIdentity3x2Dirty),this}copyToArray(f){return u(this,f,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(f){const v=new K;return this.multiplyToRef(f,v),v}multiplyInPlace(f){const v=this.Mh,Z=f.m;for(let V=0;V<16;V++)v[V]*=Z[V];return this.markAsUpdated(),this}multiplyByFloats(){const f=this.Mh;for(let v=0;v<16;v++)f[v]*=v<0||arguments.length<=v?void 0:arguments[v];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var f=arguments.length,v=new Array(f),Z=0;Z<f;Z++)v[Z]=arguments[Z];const V=v.pop(),h=this.Mh,J=V.Mh,l=v;for(let e=0;e<16;e++)J[e]=h[e]*l[e];return V.markAsUpdated(),V}multiplyToRef(f,v){return this._isIdentity?(v.h(f),v):f._isIdentity?(v.h(this),v):(this.multiplyToArray(f,v.Mh,0),v.markAsUpdated(),v)}multiplyToArray(f,v,Z){return O(this,f,v,Z),this}divide(f){return this.divideToRef(f,new K)}divideToRef(f,v){const Z=this.Mh,V=f.m,h=v.Mh;for(let J=0;J<16;J++)h[J]=Z[J]/V[J];return v.markAsUpdated(),v}divideInPlace(f){const v=this.Mh,Z=f.m;for(let V=0;V<16;V++)v[V]/=Z[V];return this.markAsUpdated(),this}minimizeInPlace(f){const v=this.Mh,Z=f.m;for(let V=0;V<16;V++)v[V]=Math.min(v[V],Z[V]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const f=this.Mh;for(let v=0;v<16;v++)f[v]=Math.min(f[v],v<0||arguments.length<=v?void 0:arguments[v]);return this.markAsUpdated(),this}maximizeInPlace(f){const v=this.Mh,Z=f.m;for(let V=0;V<16;V++)v[V]=Math.min(v[V],Z[V]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const f=this.Mh;for(let v=0;v<16;v++)f[v]=Math.min(f[v],v<0||arguments.length<=v?void 0:arguments[v]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new K)}negateInPlace(){const f=this.Mh;for(let v=0;v<16;v++)f[v]=-f[v];return this.markAsUpdated(),this}negateToRef(f){const v=this.Mh,Z=f.Mh;for(let V=0;V<16;V++)Z[V]=-v[V];return f.markAsUpdated(),f}equals(f){const v=f;if(!v)return!1;if((this._isIdentity||v._isIdentity)&&!this._isIdentityDirty&&!v._isIdentityDirty)return this._isIdentity&&v._isIdentity;const Z=this.m,V=v.m;return Z[0]===V[0]&&Z[1]===V[1]&&Z[2]===V[2]&&Z[3]===V[3]&&Z[4]===V[4]&&Z[5]===V[5]&&Z[6]===V[6]&&Z[7]===V[7]&&Z[8]===V[8]&&Z[9]===V[9]&&Z[10]===V[10]&&Z[11]===V[11]&&Z[12]===V[12]&&Z[13]===V[13]&&Z[14]===V[14]&&Z[15]===V[15]}equalsWithEpsilon(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Z=this.Mh,V=f.m;for(let h=0;h<16;h++)if(!(0,C.WithinEpsilon)(Z[h],V[h],v))return!1;return!0}equalsToFloats(){const f=this.Mh;for(let v=0;v<16;v++)if(f[v]!=(v<0||arguments.length<=v?void 0:arguments[v]))return!1;return!0}floor(){return this.floorToRef(new K)}floorToRef(f){const v=this.Mh,Z=f.Mh;for(let V=0;V<16;V++)Z[V]=Math.floor(v[V]);return f.markAsUpdated(),f}fract(){return this.fractToRef(new K)}fractToRef(f){const v=this.Mh,Z=f.Mh;for(let V=0;V<16;V++)Z[V]=v[V]-Math.floor(v[V]);return f.markAsUpdated(),f}clone(){const f=new K;return f.h(this),f}getClassName(){return"Matrix"}getHashCode(){let f=a(this.Mh[0]);for(let v=1;v<16;v++)f=397*f^a(this.Mh[v]);return f}decomposeToTransformNode(f){return f.rotationQuaternion=f.rotationQuaternion||new U,this.decompose(f.Ze,f.rotationQuaternion,f.position)}decompose(f,v,Z,V){let h=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return Z&&Z.Ve(0),f&&f.Ve(1),v&&v.fe(0,0,0,1),!0;const J=this.Mh;if(Z&&Z.fe(J[12],J[13],J[14]),(f=f||M.Xv[0]).x=Math.sqrt(J[0]*J[0]+J[1]*J[1]+J[2]*J[2]),f.y=Math.sqrt(J[4]*J[4]+J[5]*J[5]+J[6]*J[6]),f.z=Math.sqrt(J[8]*J[8]+J[9]*J[9]+J[10]*J[10]),V){const v=(h?V.absoluteScaling.x:V.Ze.x)<0?-1:1,Z=(h?V.absoluteScaling.y:V.Ze.y)<0?-1:1,J=(h?V.absoluteScaling.z:V.Ze.z)<0?-1:1;f.x*=v,f.y*=Z,f.z*=J}else this.determinant()<=0&&(f.y*=-1);if(0===f._x||0===f._y||0===f._z)return v&&v.fe(0,0,0,1),!1;if(v){const Z=1/f._x,V=1/f._y,h=1/f._z;K.FromValuesToRef(J[0]*Z,J[1]*Z,J[2]*Z,0,J[4]*V,J[5]*V,J[6]*V,0,J[8]*h,J[9]*h,J[10]*h,0,0,0,0,1,M.Matrix[0]),U.FromRotationMatrixToRef(M.Matrix[0],v)}return!0}getRow(f){if(f<0||f>3)return null;const v=4*f;return new F(this.Mh[v+0],this.Mh[v+1],this.Mh[v+2],this.Mh[v+3])}getRowToRef(f,v){if(f>=0&&f<=3){const Z=4*f;v.x=this.Mh[Z+0],v.y=this.Mh[Z+1],v.z=this.Mh[Z+2],v.w=this.Mh[Z+3]}return v}setRow(f,v){return this.setRowFromFloats(f,v.x,v.y,v.z,v.w)}transpose(){const f=new K;return K.TransposeToRef(this,f),f}transposeToRef(f){return K.TransposeToRef(this,f),f}setRowFromFloats(f,v,Z,V,h){if(f<0||f>3)return this;const J=4*f;return this.Mh[J+0]=v,this.Mh[J+1]=Z,this.Mh[J+2]=V,this.Mh[J+3]=h,this.markAsUpdated(),this}scale(f){const v=new K;return this.scaleToRef(f,v),v}scaleToRef(f,v){for(let Z=0;Z<16;Z++)v.Mh[Z]=this.Mh[Z]*f;return v.markAsUpdated(),v}scaleAndAddToRef(f,v){for(let Z=0;Z<16;Z++)v.Mh[Z]+=this.Mh[Z]*f;return v.markAsUpdated(),v}scaleInPlace(f){const v=this.Mh;for(let Z=0;Z<16;Z++)v[Z]*=f;return this.markAsUpdated(),this}toNormalMatrix(f){const v=M.Matrix[0];this.invertToRef(v),v.transposeToRef(f);const Z=f.Mh;return K.FromValuesToRef(Z[0],Z[1],Z[2],0,Z[4],Z[5],Z[6],0,Z[8],Z[9],Z[10],0,0,0,0,1,f),f}getRotationMatrix(){const f=new K;return this.getRotationMatrixToRef(f),f}getRotationMatrixToRef(f){const v=M.Xv[0];if(!this.decompose(v))return K.IdentityToRef(f),f;const Z=this.Mh,V=1/v._x,h=1/v._y,J=1/v._z;return K.FromValuesToRef(Z[0]*V,Z[1]*V,Z[2]*V,0,Z[4]*h,Z[5]*h,Z[6]*h,0,Z[8]*J,Z[9]*J,Z[10]*J,0,0,0,0,1,f),f}toggleModelMatrixHandInPlace(){const f=this.Mh;return f[2]*=-1,f[6]*=-1,f[8]*=-1,f[9]*=-1,f[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const f=this.Mh;return f[8]*=-1,f[9]*=-1,f[10]*=-1,f[11]*=-1,this.markAsUpdated(),this}static Av(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Z=new K;return K.FromArrayToRef(f,v,Z),Z}static FromArrayToRef(f,v,Z){for(let V=0;V<16;V++)Z.Mh[V]=f[V+v];return Z.markAsUpdated(),Z}static FromFloat32ArrayToRefScaled(f,v,Z,V){return V.Mh[0]=f[0+v]*Z,V.Mh[1]=f[1+v]*Z,V.Mh[2]=f[2+v]*Z,V.Mh[3]=f[3+v]*Z,V.Mh[4]=f[4+v]*Z,V.Mh[5]=f[5+v]*Z,V.Mh[6]=f[6+v]*Z,V.Mh[7]=f[7+v]*Z,V.Mh[8]=f[8+v]*Z,V.Mh[9]=f[9+v]*Z,V.Mh[10]=f[10+v]*Z,V.Mh[11]=f[11+v]*Z,V.Mh[12]=f[12+v]*Z,V.Mh[13]=f[13+v]*Z,V.Mh[14]=f[14+v]*Z,V.Mh[15]=f[15+v]*Z,V.markAsUpdated(),V}static get IdentityReadOnly(){return K._IdentityReadOnly}static FromValuesToRef(f,v,Z,V,h,J,l,e,C,H,O,u,W,a,b,X,F){const U=F.Mh;U[0]=f,U[1]=v,U[2]=Z,U[3]=V,U[4]=h,U[5]=J,U[6]=l,U[7]=e,U[8]=C,U[9]=H,U[10]=O,U[11]=u,U[12]=W,U[13]=a,U[14]=b,U[15]=X,F.markAsUpdated()}static FromValues(f,v,Z,V,h,J,l,e,C,H,O,u,W,a,b,X){const F=new K,U=F.Mh;return U[0]=f,U[1]=v,U[2]=Z,U[3]=V,U[4]=h,U[5]=J,U[6]=l,U[7]=e,U[8]=C,U[9]=H,U[10]=O,U[11]=u,U[12]=W,U[13]=a,U[14]=b,U[15]=X,F.markAsUpdated(),F}static Compose(f,v,Z){const V=new K;return K.ComposeToRef(f,v,Z,V),V}static ComposeToRef(f,v,Z,V){const h=V.Mh,J=v._x,l=v._y,e=v._z,C=v._w,H=J+J,O=l+l,u=e+e,W=J*H,a=J*O,b=J*u,X=l*O,F=l*u,U=e*u,K=C*H,M=C*O,A=C*u,s=f._x,z=f._y,Y=f._z;return h[0]=(1-(X+U))*s,h[1]=(a+A)*s,h[2]=(b-M)*s,h[3]=0,h[4]=(a-A)*z,h[5]=(1-(W+U))*z,h[6]=(F+K)*z,h[7]=0,h[8]=(b+M)*Y,h[9]=(F-K)*Y,h[10]=(1-(W+X))*Y,h[11]=0,h[12]=Z._x,h[13]=Z._y,h[14]=Z._z,h[15]=1,V.markAsUpdated(),V}static Identity(){const f=K.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return f._updateIdentityStatus(!0),f}static IdentityToRef(f){return K.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,f),f._updateIdentityStatus(!0),f}static Zero(){const f=K.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return f._updateIdentityStatus(!1),f}static RotationX(f){const v=new K;return K.RotationXToRef(f,v),v}static Invert(f){const v=new K;return f.invertToRef(v),v}static RotationXToRef(f,v){const Z=Math.sin(f),V=Math.cos(f);return K.FromValuesToRef(1,0,0,0,0,V,Z,0,0,-Z,V,0,0,0,0,1,v),v._updateIdentityStatus(1===V&&0===Z),v}static RotationY(f){const v=new K;return K.RotationYToRef(f,v),v}static RotationYToRef(f,v){const Z=Math.sin(f),V=Math.cos(f);return K.FromValuesToRef(V,0,-Z,0,0,1,0,0,Z,0,V,0,0,0,0,1,v),v._updateIdentityStatus(1===V&&0===Z),v}static RotationZ(f){const v=new K;return K.RotationZToRef(f,v),v}static RotationZToRef(f,v){const Z=Math.sin(f),V=Math.cos(f);return K.FromValuesToRef(V,Z,0,0,-Z,V,0,0,0,0,1,0,0,0,0,1,v),v._updateIdentityStatus(1===V&&0===Z),v}static RotationAxis(f,v){const Z=new K;return K.RotationAxisToRef(f,v,Z),Z}static RotationAxisToRef(f,v,Z){const V=Math.sin(-v),h=Math.cos(-v),J=1-h;f=f.normalizeToRef(M.Xv[0]);const l=Z.Mh;return l[0]=f._x*f._x*J+h,l[1]=f._x*f._y*J-f._z*V,l[2]=f._x*f._z*J+f._y*V,l[3]=0,l[4]=f._y*f._x*J+f._z*V,l[5]=f._y*f._y*J+h,l[6]=f._y*f._z*J-f._x*V,l[7]=0,l[8]=f._z*f._x*J-f._y*V,l[9]=f._z*f._y*J+f._x*V,l[10]=f._z*f._z*J+h,l[11]=0,l[12]=0,l[13]=0,l[14]=0,l[15]=1,Z.markAsUpdated(),Z}static RotationAlignToRef(f,v,Z){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const J=X.Dot(v,f),l=Z.Mh;if(J<-1+V.c)l[0]=-1,l[1]=0,l[2]=0,l[3]=0,l[4]=0,l[5]=h?1:-1,l[6]=0,l[7]=0,l[8]=0,l[9]=0,l[10]=h?-1:1,l[11]=0;else{const Z=X.Cross(v,f),V=1/(1+J);l[0]=Z._x*Z._x*V+J,l[1]=Z._y*Z._x*V-Z._z,l[2]=Z._z*Z._x*V+Z._y,l[3]=0,l[4]=Z._x*Z._y*V+Z._z,l[5]=Z._y*Z._y*V+J,l[6]=Z._z*Z._y*V-Z._x,l[7]=0,l[8]=Z._x*Z._z*V-Z._y,l[9]=Z._y*Z._z*V+Z._x,l[10]=Z._z*Z._z*V+J,l[11]=0}return l[12]=0,l[13]=0,l[14]=0,l[15]=1,Z.markAsUpdated(),Z}static RotationYawPitchRoll(f,v,Z){const V=new K;return K.RotationYawPitchRollToRef(f,v,Z,V),V}static RotationYawPitchRollToRef(f,v,Z,V){return U.RotationYawPitchRollToRef(f,v,Z,M.Quaternion[0]),M.Quaternion[0].toRotationMatrix(V),V}static Scaling(f,v,Z){const V=new K;return K.ScalingToRef(f,v,Z,V),V}static ScalingToRef(f,v,Z,V){return K.FromValuesToRef(f,0,0,0,0,v,0,0,0,0,Z,0,0,0,0,1,V),V._updateIdentityStatus(1===f&&1===v&&1===Z),V}static Translation(f,v,Z){const V=new K;return K.TranslationToRef(f,v,Z,V),V}static TranslationToRef(f,v,Z,V){return K.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,f,v,Z,1,V),V._updateIdentityStatus(0===f&&0===v&&0===Z),V}static Lerp(f,v,Z){const V=new K;return K.LerpToRef(f,v,Z,V),V}static LerpToRef(f,v,Z,V){const h=V.Mh,J=f.m,l=v.m;for(let e=0;e<16;e++)h[e]=J[e]*(1-Z)+l[e]*Z;return V.markAsUpdated(),V}static DecomposeLerp(f,v,Z){const V=new K;return K.DecomposeLerpToRef(f,v,Z,V),V}static DecomposeLerpToRef(f,v,Z,V){const h=M.Xv[0],J=M.Quaternion[0],l=M.Xv[1];f.decompose(h,J,l);const e=M.Xv[2],C=M.Quaternion[1],H=M.Xv[3];v.decompose(e,C,H);const O=M.Xv[4];X.LerpToRef(h,e,Z,O);const u=M.Quaternion[2];U.SlerpToRef(J,C,Z,u);const W=M.Xv[5];return X.LerpToRef(l,H,Z,W),K.ComposeToRef(O,u,W,V),V}static LookAtLH(f,v,Z){const V=new K;return K.LookAtLHToRef(f,v,Z,V),V}static LookAtLHToRef(f,v,Z,V){const h=M.Xv[0],J=M.Xv[1],l=M.Xv[2];v.subtractToRef(f,l),l.normalize(),X.CrossToRef(Z,l,h);const e=h.lengthSquared();0===e?h.x=1:h.normalizeFromLength(Math.sqrt(e)),X.CrossToRef(l,h,J),J.normalize();const C=-X.Dot(h,f),H=-X.Dot(J,f),O=-X.Dot(l,f);return K.FromValuesToRef(h._x,J._x,l._x,0,h._y,J._y,l._y,0,h._z,J._z,l._z,0,C,H,O,1,V),V}static LookAtRH(f,v,Z){const V=new K;return K.LookAtRHToRef(f,v,Z,V),V}static LookAtRHToRef(f,v,Z,V){const h=M.Xv[0],J=M.Xv[1],l=M.Xv[2];f.subtractToRef(v,l),l.normalize(),X.CrossToRef(Z,l,h);const e=h.lengthSquared();0===e?h.x=1:h.normalizeFromLength(Math.sqrt(e)),X.CrossToRef(l,h,J),J.normalize();const C=-X.Dot(h,f),H=-X.Dot(J,f),O=-X.Dot(l,f);return K.FromValuesToRef(h._x,J._x,l._x,0,h._y,J._y,l._y,0,h._z,J._z,l._z,0,C,H,O,1,V),V}static LookDirectionLH(f,v){const Z=new K;return K.LookDirectionLHToRef(f,v,Z),Z}static LookDirectionLHToRef(f,v,Z){const V=M.Xv[0];V.h(f),V.scaleInPlace(-1);const h=M.Xv[1];return X.CrossToRef(v,V,h),K.FromValuesToRef(h._x,h._y,h._z,0,v._x,v._y,v._z,0,V._x,V._y,V._z,0,0,0,0,1,Z),Z}static LookDirectionRH(f,v){const Z=new K;return K.LookDirectionRHToRef(f,v,Z),Z}static LookDirectionRHToRef(f,v,Z){const V=M.Xv[2];return X.CrossToRef(v,f,V),K.FromValuesToRef(V._x,V._y,V._z,0,v._x,v._y,v._z,0,f._x,f._y,f._z,0,0,0,0,1,Z),Z}static OrthoLH(f,v,Z,V,h){const J=new K;return K.OrthoLHToRef(f,v,Z,V,J,h),J}static OrthoLHToRef(f,v,Z,V,h,J){const l=2/f,e=2/v,C=2/(V-Z),H=-(V+Z)/(V-Z);return K.FromValuesToRef(l,0,0,0,0,e,0,0,0,0,C,0,0,0,H,1,h),J&&h.multiplyToRef(s,h),h._updateIdentityStatus(1===l&&1===e&&1===C&&0===H),h}static OrthoOffCenterLH(f,v,Z,V,h,J,l){const e=new K;return K.OrthoOffCenterLHToRef(f,v,Z,V,h,J,e,l),e}static OrthoOffCenterLHToRef(f,v,Z,V,h,J,l,e){const C=2/(v-f),H=2/(V-Z),O=2/(J-h),u=-(J+h)/(J-h),W=(f+v)/(f-v),a=(V+Z)/(Z-V);return K.FromValuesToRef(C,0,0,0,0,H,0,0,0,0,O,0,W,a,u,1,l),e&&l.multiplyToRef(s,l),l.markAsUpdated(),l}static ObliqueOffCenterLHToRef(f,v,Z,V,h,J,l,e,C,H,O){const u=-l*Math.cos(e),W=-l*Math.sin(e);return K.TranslationToRef(0,0,-C,M.Matrix[1]),K.FromValuesToRef(1,0,0,0,0,1,0,0,u,W,1,0,0,0,0,1,M.Matrix[0]),M.Matrix[1].multiplyToRef(M.Matrix[0],M.Matrix[0]),K.TranslationToRef(0,0,C,M.Matrix[1]),M.Matrix[0].multiplyToRef(M.Matrix[1],M.Matrix[0]),K.OrthoOffCenterLHToRef(f,v,Z,V,h,J,H,O),M.Matrix[0].multiplyToRef(H,H),H}static OrthoOffCenterRH(f,v,Z,V,h,J,l){const e=new K;return K.OrthoOffCenterRHToRef(f,v,Z,V,h,J,e,l),e}static OrthoOffCenterRHToRef(f,v,Z,V,h,J,l,e){return K.OrthoOffCenterLHToRef(f,v,Z,V,h,J,l,e),l.Mh[10]*=-1,l}static ObliqueOffCenterRHToRef(f,v,Z,V,h,J,l,e,C,H,O){const u=l*Math.cos(e),W=l*Math.sin(e);return K.TranslationToRef(0,0,C,M.Matrix[1]),K.FromValuesToRef(1,0,0,0,0,1,0,0,u,W,1,0,0,0,0,1,M.Matrix[0]),M.Matrix[1].multiplyToRef(M.Matrix[0],M.Matrix[0]),K.TranslationToRef(0,0,-C,M.Matrix[1]),M.Matrix[0].multiplyToRef(M.Matrix[1],M.Matrix[0]),K.OrthoOffCenterRHToRef(f,v,Z,V,h,J,H,O),M.Matrix[0].multiplyToRef(H,H),H}static PerspectiveLH(f,v,Z,V,h){let J=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const l=new K,e=2*Z/f,C=2*Z/v,H=(V+Z)/(V-Z),O=-2*V*Z/(V-Z),u=Math.tan(J);return K.FromValuesToRef(e,0,0,0,0,C,0,u,0,0,H,1,0,0,O,0,l),h&&l.multiplyToRef(s,l),l._updateIdentityStatus(!1),l}static PerspectiveFovLH(f,v,Z,V,h){let J=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const e=new K;return K.PerspectiveFovLHToRef(f,v,Z,V,e,!0,h,J,l),e}static PerspectiveFovLHToRef(f,v,Z,V,h){let J=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],l=arguments.length>6?arguments[6]:void 0,e=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,C=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const H=Z,O=V,u=1/Math.tan(.5*f),W=J?u/v:u,a=J?u:u*v,b=C&&0===H?-1:0!==O?(O+H)/(O-H):1,X=C&&0===H?2*O:0!==O?-2*O*H/(O-H):-2*H,F=Math.tan(e);return K.FromValuesToRef(W,0,0,0,0,a,0,F,0,0,b,1,0,0,X,0,h),l&&h.multiplyToRef(s,h),h._updateIdentityStatus(!1),h}static PerspectiveFovReverseLHToRef(f,v,Z,V,h){let J=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],l=arguments.length>6?arguments[6]:void 0,e=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const C=1/Math.tan(.5*f),H=J?C/v:C,O=J?C:C*v,u=Math.tan(e);return K.FromValuesToRef(H,0,0,0,0,O,0,u,0,0,-Z,1,0,0,1,0,h),l&&h.multiplyToRef(s,h),h._updateIdentityStatus(!1),h}static PerspectiveFovRH(f,v,Z,V,h){let J=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const e=new K;return K.PerspectiveFovRHToRef(f,v,Z,V,e,!0,h,J,l),e}static PerspectiveFovRHToRef(f,v,Z,V,h){let J=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],l=arguments.length>6?arguments[6]:void 0,e=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,C=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const H=Z,O=V,u=1/Math.tan(.5*f),W=J?u/v:u,a=J?u:u*v,b=C&&0===H?1:0!==O?-(O+H)/(O-H):-1,X=C&&0===H?2*O:0!==O?-2*O*H/(O-H):-2*H,F=Math.tan(e);return K.FromValuesToRef(W,0,0,0,0,a,0,F,0,0,b,-1,0,0,X,0,h),l&&h.multiplyToRef(s,h),h._updateIdentityStatus(!1),h}static PerspectiveFovReverseRHToRef(f,v,Z,V,h){let J=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],l=arguments.length>6?arguments[6]:void 0,e=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const C=1/Math.tan(.5*f),H=J?C/v:C,O=J?C:C*v,u=Math.tan(e);return K.FromValuesToRef(H,0,0,0,0,O,0,u,0,0,-Z,-1,0,0,-1,0,h),l&&h.multiplyToRef(s,h),h._updateIdentityStatus(!1),h}static GetFinalMatrix(f,v,Z,V,h,J){const l=f.width,e=f.height,C=f.x,H=f.y,O=K.FromValues(l/2,0,0,0,0,-e/2,0,0,0,0,J-h,0,C+l/2,e/2+H,h,1),u=new K;return v.multiplyToRef(Z,u),u.multiplyToRef(V,u),u.multiplyToRef(O,u)}static GetAsMatrix2x2(f){const v=f.m,Z=[v[0],v[1],v[4],v[5]];return l.e.MatrixUse64Bits?Z:new Float32Array(Z)}static GetAsMatrix3x3(f){const v=f.m,Z=[v[0],v[1],v[2],v[4],v[5],v[6],v[8],v[9],v[10]];return l.e.MatrixUse64Bits?Z:new Float32Array(Z)}static Transpose(f){const v=new K;return K.TransposeToRef(f,v),v}static TransposeToRef(f,v){const Z=f.m,V=Z[0],h=Z[4],J=Z[8],l=Z[12],e=Z[1],C=Z[5],H=Z[9],O=Z[13],u=Z[2],W=Z[6],a=Z[10],b=Z[14],X=Z[3],F=Z[7],U=Z[11],K=Z[15],M=v.Mh;return M[0]=V,M[1]=h,M[2]=J,M[3]=l,M[4]=e,M[5]=C,M[6]=H,M[7]=O,M[8]=u,M[9]=W,M[10]=a,M[11]=b,M[12]=X,M[13]=F,M[14]=U,M[15]=K,v.markAsUpdated(),v._updateIdentityStatus(f._isIdentity,f._isIdentityDirty),v}static Reflection(f){const v=new K;return K.ReflectionToRef(f,v),v}static ReflectionToRef(f,v){f.normalize();const Z=f.normal.x,V=f.normal.y,h=f.normal.z,J=-2*Z,l=-2*V,e=-2*h;return K.FromValuesToRef(J*Z+1,l*Z,e*Z,0,J*V,l*V+1,e*V,0,J*h,l*h,e*h+1,0,J*f.d,l*f.d,e*f.d,1,v),v}static FromXYZAxesToRef(f,v,Z,V){return K.FromValuesToRef(f._x,f._y,f._z,0,v._x,v._y,v._z,0,Z._x,Z._y,Z._z,0,0,0,0,1,V),V}static FromQuaternionToRef(f,v){const Z=f._x*f._x,V=f._y*f._y,h=f._z*f._z,J=f._x*f._y,l=f._z*f._w,e=f._z*f._x,C=f._y*f._w,H=f._y*f._z,O=f._x*f._w;return v.Mh[0]=1-2*(V+h),v.Mh[1]=2*(J+l),v.Mh[2]=2*(e-C),v.Mh[3]=0,v.Mh[4]=2*(J-l),v.Mh[5]=1-2*(h+Z),v.Mh[6]=2*(H+O),v.Mh[7]=0,v.Mh[8]=2*(e+C),v.Mh[9]=2*(H-O),v.Mh[10]=1-2*(V+Z),v.Mh[11]=0,v.Mh[12]=0,v.Mh[13]=0,v.Mh[14]=0,v.Mh[15]=1,v.markAsUpdated(),v}}K._IdentityReadOnly=K.Identity(),Object.defineProperties(K.prototype,{dimension:{value:[4,4]},rank:{value:2}});class M{}M.Xv=(0,h.f)(11,X.Zero),M.Matrix=(0,h.f)(2,K.Identity),M.Quaternion=(0,h.f)(3,U.Zero);class A{}A.Vector2=(0,h.f)(3,b.Zero),A.Xv=(0,h.f)(13,X.Zero),A.Vector4=(0,h.f)(3,F.Zero),A.Quaternion=(0,h.f)(3,U.Zero),A.Matrix=(0,h.f)(8,K.Identity),(0,J.h)("BABYLON.Vector2",b),(0,J.h)("BABYLON.Vector3",X),(0,J.h)("BABYLON.Vector4",F),(0,J.h)("BABYLON.Matrix",K);const s=K.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11437:(f,v,Z)=>{function V(f,v){const Z=[];for(let V=0;V<f;++V)Z.push(v());return Z}function h(f,v){return V(f,v)}Z.d(v,{c:()=>V,f:()=>h,j:()=>l});const J=["push","splice","pop","shift","unshift"];function l(f,v){const Z=J.map((Z=>function(f,v,Z){const V=f[v];if("function"!==typeof V)return null;const h=function(){const V=f.length,J=h.previous.apply(f,arguments);return Z(v,V),J};return V.next=h,h.previous=V,f[v]=h,()=>{const Z=h.previous;if(!Z)return;const V=h.next;V?(Z.next=V,V.previous=Z):(Z.next=void 0,f[v]=Z),h.next=void 0,h.previous=void 0}}(f,Z,v)));return()=>{for(const f of Z)null===f||void 0===f||f()}}}}]);