"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[14],{11737:(Z,h,V)=>{V.d(h,{c:()=>K,f:()=>H,j:()=>v,k:()=>A});const v=1/2.2,A=2.2,H=(1+Math.sqrt(5))/2,K=.001},11748:(Z,h,V)=>{function v(Z){return parseInt(Z.toString().replace(/\W/g,""))}function A(Z,h){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Z-h)<=V}function H(Z,h,V){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Z<h-v||Z>V+v}function K(Z,h){return Z===h?Z:Math.random()*(h-Z)+Z}function d(Z,h,V){return Z+(h-Z)*V}function a(Z,h,V){let v=b(h-Z,360);return v>180&&(v-=360),Z+v*D(V)}function n(Z,h,V){let v=0;return v=Z!=h?D((V-Z)/(h-Z)):0,v}function x(Z,h,V,v,A){const H=A*A,K=A*H;return Z*(2*K-3*H+1)+V*(-2*K+3*H)+h*(K-2*H+A)+v*(K-H)}function N(Z,h,V,v,A){const H=A*A;return 6*(H-A)*Z+(3*H-4*A+1)*h+6*(-H+A)*V+(3*H-2*A)*v}function D(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(V,Math.max(h,Z))}function k(Z){return Z-=2*Math.PI*Math.floor((Z+Math.PI)/(2*Math.PI))}function u(Z){const h=Z.toString(16);return Z<=15?("0"+h).toUpperCase():h.toUpperCase()}function F(Z){if(Math.log2)return Math.floor(Math.log2(Z));if(Z<0)return NaN;if(0===Z)return-1/0;let h=0;if(Z<1){for(;Z<1;)h++,Z*=2;h=-h}else if(Z>1)for(;Z>1;)h++,Z=Math.floor(Z/2);return h}function b(Z,h){return Z-Math.floor(Z/h)*h}function o(Z,h,V){return(Z-h)/(V-h)}function q(Z,h,V){return Z*(V-h)+h}function X(Z,h){let V=b(h-Z,360);return V>180&&(V-=360),V}function E(Z,h){const V=b(Z,2*h);return h-Math.abs(V-h)}function j(Z,h,V){let v=D(V);return v=-2*v*v*v+3*v*v,h*v+Z*(1-v)}function P(Z,h,V){let v=0;return v=Math.abs(h-Z)<=V?h:Z+Math.sign(h-Z)*V,v}function C(Z,h,V){const v=X(Z,h);let A=0;return A=-V<v&&v<V?h:P(Z,h=Z+v,V),A}function l(Z,h,V){return(Z-h)/(V-h)}function B(Z,h,V){return(V-h)*Z+h}function S(Z,h){const V=Z%h;return 0===V?h:S(h,V)}V.r(h),V.d(h,{Clamp:()=>D,DeltaAngle:()=>X,Denormalize:()=>q,ExtractAsInt:()=>v,Hermite:()=>x,Hermite1stDerivative:()=>N,HighestCommonFactor:()=>S,ILog2:()=>F,InverseLerp:()=>n,Lerp:()=>d,LerpAngle:()=>a,MoveTowards:()=>P,MoveTowardsAngle:()=>C,Normalize:()=>o,NormalizeRadians:()=>k,OutsideRange:()=>H,PercentToRange:()=>B,PingPong:()=>E,RandomRange:()=>K,RangeToPercent:()=>l,Repeat:()=>b,SmoothStep:()=>j,ToHex:()=>u,WithinEpsilon:()=>A})},11729:(Z,h,V)=>{V.r(h),V.d(h,{Matrix:()=>q,Quaternion:()=>o,TmpVectors:()=>E,Vector2:()=>u,Ch:()=>F,Vector4:()=>b});var v=V(11737),A=V(11739),H=V(11691),K=V(11664),d=V(11599),a=V(11748);class n{}function x(Z,h,V){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const A=Z.mh(),H=h.mh(),K=A[0],d=A[1],a=A[2],n=A[3],x=A[4],N=A[5],D=A[6],k=A[7],u=A[8],F=A[9],b=A[10],o=A[11],q=A[12],X=A[13],E=A[14],j=A[15],P=H[0],C=H[1],l=H[2],B=H[3],S=H[4],r=H[5],L=H[6],y=H[7],W=H[8],z=H[9],m=H[10],g=H[11],I=H[12],e=H[13],U=H[14],R=H[15];V[v]=K*P+d*S+a*W+n*I,V[v+1]=K*C+d*r+a*z+n*e,V[v+2]=K*l+d*L+a*m+n*U,V[v+3]=K*B+d*y+a*g+n*R,V[v+4]=x*P+N*S+D*W+k*I,V[v+5]=x*C+N*r+D*z+k*e,V[v+6]=x*l+N*L+D*m+k*U,V[v+7]=x*B+N*y+D*g+k*R,V[v+8]=u*P+F*S+b*W+o*I,V[v+9]=u*C+F*r+b*z+o*e,V[v+10]=u*l+F*L+b*m+o*U,V[v+11]=u*B+F*y+b*g+o*R,V[v+12]=q*P+X*S+E*W+j*I,V[v+13]=q*C+X*r+E*z+j*e,V[v+14]=q*l+X*L+E*m+j*U,V[v+15]=q*B+X*y+E*g+j*R}function N(Z,h){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const v=Z.mh();h[V]=v[0],h[V+1]=v[1],h[V+2]=v[2],h[V+3]=v[3],h[V+4]=v[4],h[V+5]=v[5],h[V+6]=v[6],h[V+7]=v[7],h[V+8]=v[8],h[V+9]=v[9],h[V+10]=v[10],h[V+11]=v[11],h[V+12]=v[12],h[V+13]=v[13],h[V+14]=v[14],h[V+15]=v[15]}function D(Z,h){const V=Z.mh(),v=V[0],A=V[1],H=V[2],K=V[3],d=V[4],a=V[5],n=V[6],x=V[7],N=V[8],D=V[9],k=V[10],u=V[11],F=V[12],b=V[13],o=V[14],q=V[15],X=k*q-o*u,E=D*q-b*u,j=D*o-b*k,P=N*q-F*u,C=N*o-k*F,l=N*b-F*D,B=+(a*X-n*E+x*j),S=-(d*X-n*P+x*C),r=+(d*E-a*P+x*l),L=-(d*j-a*C+n*l),y=v*B+A*S+H*r+K*L;if(0===y)return!1;const W=1/y,z=n*q-o*x,m=a*q-b*x,g=a*o-b*n,I=d*q-F*x,e=d*o-F*n,U=d*b-F*a,R=n*u-k*x,Q=a*u-D*x,w=a*k-D*n,T=d*u-N*x,t=d*k-N*n,c=d*D-N*a,i=-(A*X-H*E+K*j),M=+(v*X-H*P+K*C),O=-(v*E-A*P+K*l),s=+(v*j-A*C+H*l),J=+(A*z-H*m+K*g),f=-(v*z-H*I+K*e),p=+(v*m-A*I+K*U),Y=-(v*g-A*e+H*U),G=-(A*R-H*Q+K*w),ZZ=+(v*R-H*T+K*t),hZ=-(v*Q-A*T+K*c),VZ=+(v*w-A*t+H*c);return h[0]=B*W,h[1]=i*W,h[2]=J*W,h[3]=G*W,h[4]=S*W,h[5]=M*W,h[6]=f*W,h[7]=ZZ*W,h[8]=r*W,h[9]=O*W,h[10]=p*W,h[11]=hZ*W,h[12]=L*W,h[13]=s*W,h[14]=Y*W,h[15]=VZ*W,!0}n._UpdateFlagSeed=0;const k=Z=>parseInt(Z.toString().replace(/\W/g,""));class u{constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=Z,this.y=h}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let Z=k(this.x);return Z=397*Z^k(this.y),Z}toArray(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[h]=this.x,Z[h+1]=this.y,this}QV(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(Z,h,this),this}mh(){return[this.x,this.y]}v(Z){return this.x=Z.x,this.y=Z.y,this}IV(Z,h){return this.x=Z,this.y=h,this}set(Z,h){return this.IV(Z,h)}vd(Z){return this.IV(Z,Z)}add(Z){return new u(this.x+Z.x,this.y+Z.y)}addToRef(Z,h){return h.x=this.x+Z.x,h.y=this.y+Z.y,h}addInPlace(Z){return this.x+=Z.x,this.y+=Z.y,this}addInPlaceFromFloats(Z,h){return this.x+=Z,this.y+=h,this}addVector3(Z){return new u(this.x+Z.x,this.y+Z.y)}rh(Z){return new u(this.x-Z.x,this.y-Z.y)}subtractToRef(Z,h){return h.x=this.x-Z.x,h.y=this.y-Z.y,h}EN(Z){return this.x-=Z.x,this.y-=Z.y,this}multiplyInPlace(Z){return this.x*=Z.x,this.y*=Z.y,this}multiply(Z){return new u(this.x*Z.x,this.y*Z.y)}multiplyToRef(Z,h){return h.x=this.x*Z.x,h.y=this.y*Z.y,h}multiplyByFloats(Z,h){return new u(this.x*Z,this.y*h)}divide(Z){return new u(this.x/Z.x,this.y/Z.y)}divideToRef(Z,h){return h.x=this.x/Z.x,h.y=this.y/Z.y,h}divideInPlace(Z){return this.x=this.x/Z.x,this.y=this.y/Z.y,this}minimizeInPlace(Z){return this.minimizeInPlaceFromFloats(Z.x,Z.y)}maximizeInPlace(Z){return this.maximizeInPlaceFromFloats(Z.x,Z.y)}minimizeInPlaceFromFloats(Z,h){return this.x=Math.min(Z,this.x),this.y=Math.min(h,this.y),this}maximizeInPlaceFromFloats(Z,h){return this.x=Math.max(Z,this.x),this.y=Math.max(h,this.y),this}subtractFromFloats(Z,h){return new u(this.x-Z,this.y-h)}subtractFromFloatsToRef(Z,h,V){return V.x=this.x-Z,V.y=this.y-h,V}negate(){return new u(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(Z){return Z.x=-this.x,Z.y=-this.y,Z}scaleInPlace(Z){return this.x*=Z,this.y*=Z,this}scale(Z){return new u(this.x*Z,this.y*Z)}scaleToRef(Z,h){return h.x=this.x*Z,h.y=this.y*Z,h}scaleAndAddToRef(Z,h){return h.x+=this.x*Z,h.y+=this.y*Z,h}equals(Z){return Z&&this.x===Z.x&&this.y===Z.y}equalsWithEpsilon(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v.c;return Z&&(0,a.WithinEpsilon)(this.x,Z.x,h)&&(0,a.WithinEpsilon)(this.y,Z.y,h)}equalsToFloats(Z,h){return this.x===Z&&this.y===h}floor(){return new u(Math.floor(this.x),Math.floor(this.y))}floorToRef(Z){return Z.x=Math.floor(this.x),Z.y=Math.floor(this.y),Z}fract(){return new u(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(Z){return Z.x=this.x-Math.floor(this.x),Z.y=this.y-Math.floor(this.y),Z}rotate(Z){return this.rotateToRef(Z,new u)}rotateToRef(Z,h){const V=Math.cos(Z),v=Math.sin(Z);return h.x=V*this.x-v*this.y,h.y=v*this.x+V*this.y,h}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){const Z=new u;return this.normalizeToRef(Z),Z}normalizeToRef(Z){const h=this.length();return 0===h&&(Z.x=this.x,Z.y=this.y),this.scaleToRef(1/h,Z)}clone(){return new u(this.x,this.y)}dot(Z){return this.x*Z.x+this.y*Z.y}static Zero(){return new u(0,0)}static One(){return new u(1,1)}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new u((0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).IV((0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h))}static get ZeroReadOnly(){return u._ZeroReadOnly}static eh(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new u(Z[h],Z[h+1])}static FromArrayToRef(Z,h,V){return V.x=Z[h],V.y=Z[h+1],V}static FromFloatsToRef(Z,h,V){return V.IV(Z,h),V}static CatmullRom(Z,h,V,v,A){const H=A*A,K=A*H,d=.5*(2*h.x+(-Z.x+V.x)*A+(2*Z.x-5*h.x+4*V.x-v.x)*H+(-Z.x+3*h.x-3*V.x+v.x)*K),a=.5*(2*h.y+(-Z.y+V.y)*A+(2*Z.y-5*h.y+4*V.y-v.y)*H+(-Z.y+3*h.y-3*V.y+v.y)*K);return new u(d,a)}static ClampToRef(Z,h,V,v){return v.x=(0,a.Clamp)(Z.x,h.x,V.x),v.y=(0,a.Clamp)(Z.y,h.y,V.y),v}static Clamp(Z,h,V){const v=(0,a.Clamp)(Z.x,h.x,V.x),A=(0,a.Clamp)(Z.y,h.y,V.y);return new u(v,A)}static Hermite(Z,h,V,v,A){const H=A*A,K=A*H,d=2*K-3*H+1,a=-2*K+3*H,n=K-2*H+A,x=K-H,N=Z.x*d+V.x*a+h.x*n+v.x*x,D=Z.y*d+V.y*a+h.y*n+v.y*x;return new u(N,D)}static Hermite1stDerivative(Z,h,V,v,A){return this.Hermite1stDerivativeToRef(Z,h,V,v,A,new u)}static Hermite1stDerivativeToRef(Z,h,V,v,A,H){const K=A*A;return H.x=6*(K-A)*Z.x+(3*K-4*A+1)*h.x+6*(-K+A)*V.x+(3*K-2*A)*v.x,H.y=6*(K-A)*Z.y+(3*K-4*A+1)*h.y+6*(-K+A)*V.y+(3*K-2*A)*v.y,H}static Lerp(Z,h,V){return u.LerpToRef(Z,h,V,new u)}static LerpToRef(Z,h,V,v){return v.x=Z.x+(h.x-Z.x)*V,v.y=Z.y+(h.y-Z.y)*V,v}static Dot(Z,h){return Z.x*h.x+Z.y*h.y}static Normalize(Z){return u.NormalizeToRef(Z,new u)}static NormalizeToRef(Z,h){return Z.normalizeToRef(h),h}static Minimize(Z,h){const V=Z.x<h.x?Z.x:h.x,v=Z.y<h.y?Z.y:h.y;return new u(V,v)}static Maximize(Z,h){const V=Z.x>h.x?Z.x:h.x,v=Z.y>h.y?Z.y:h.y;return new u(V,v)}static Transform(Z,h){return u.TransformToRef(Z,h,new u)}static TransformToRef(Z,h,V){const v=h.m,A=Z.x*v[0]+Z.y*v[4]+v[12],H=Z.x*v[1]+Z.y*v[5]+v[13];return V.x=A,V.y=H,V}static PointInTriangle(Z,h,V,v){const A=.5*(-V.y*v.x+h.y*(-V.x+v.x)+h.x*(V.y-v.y)+V.x*v.y),H=A<0?-1:1,K=(h.y*v.x-h.x*v.y+(v.y-h.y)*Z.x+(h.x-v.x)*Z.y)*H,d=(h.x*V.y-h.y*V.x+(h.y-V.y)*Z.x+(V.x-h.x)*Z.y)*H;return K>0&&d>0&&K+d<2*A*H}static Distance(Z,h){return Math.sqrt(u.DistanceSquared(Z,h))}static DistanceSquared(Z,h){const V=Z.x-h.x,v=Z.y-h.y;return V*V+v*v}static Center(Z,h){return u.CenterToRef(Z,h,new u)}static CenterToRef(Z,h,V){return V.IV((Z.x+h.x)/2,(Z.y+h.y)/2)}static DistanceOfPointFromSegment(Z,h,V){const v=u.DistanceSquared(h,V);if(0===v)return u.Distance(Z,h);const A=V.rh(h),H=Math.max(0,Math.min(1,u.Dot(Z.rh(h),A)/v)),K=h.add(A.multiplyByFloats(H,H));return u.Distance(Z,K)}}u._V8PerformanceHack=new u(.5,.5),u._ZeroReadOnly=u.Zero(),Object.defineProperties(u.prototype,{dimension:{value:[2]},rank:{value:1}});class F{get x(){return this._x}set x(Z){this._x=Z,this._isDirty=!0}get y(){return this._y}set y(Z){this._y=Z,this._isDirty=!0}get z(){return this._z}set z(Z){this._z=Z,this._isDirty=!0}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=Z,this._y=h,this._z=V}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Ch"}getHashCode(){let Z=k(this._x);return Z=397*Z^k(this._y),Z=397*Z^k(this._z),Z}mh(){return[this._x,this._y,this._z]}toArray(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[h]=this._x,Z[h+1]=this._y,Z[h+2]=this._z,this}QV(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(Z,h,this),this}toQuaternion(){return o.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(Z){return this._x+=Z._x,this._y+=Z._y,this._z+=Z._z,this._isDirty=!0,this}addInPlaceFromFloats(Z,h,V){return this._x+=Z,this._y+=h,this._z+=V,this._isDirty=!0,this}add(Z){return new F(this._x+Z._x,this._y+Z._y,this._z+Z._z)}addToRef(Z,h){return h._x=this._x+Z._x,h._y=this._y+Z._y,h._z=this._z+Z._z,h._isDirty=!0,h}EN(Z){return this._x-=Z._x,this._y-=Z._y,this._z-=Z._z,this._isDirty=!0,this}rh(Z){return new F(this._x-Z._x,this._y-Z._y,this._z-Z._z)}subtractToRef(Z,h){return this.subtractFromFloatsToRef(Z._x,Z._y,Z._z,h)}subtractFromFloats(Z,h,V){return new F(this._x-Z,this._y-h,this._z-V)}subtractFromFloatsToRef(Z,h,V,v){return v._x=this._x-Z,v._y=this._y-h,v._z=this._z-V,v._isDirty=!0,v}negate(){return new F(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(Z){return Z._x=-1*this._x,Z._y=-1*this._y,Z._z=-1*this._z,Z._isDirty=!0,Z}scaleInPlace(Z){return this._x*=Z,this._y*=Z,this._z*=Z,this._isDirty=!0,this}scale(Z){return new F(this._x*Z,this._y*Z,this._z*Z)}scaleToRef(Z,h){return h._x=this._x*Z,h._y=this._y*Z,h._z=this._z*Z,h._isDirty=!0,h}getNormalToRef(Z){const h=this.length();let V=Math.acos(this._y/h);const v=Math.atan2(this._z,this._x);V>Math.PI/2?V-=Math.PI/2:V+=Math.PI/2;const A=h*Math.sin(V)*Math.cos(v),H=h*Math.cos(V),K=h*Math.sin(V)*Math.sin(v);return Z.set(A,H,K),Z}applyRotationQuaternionToRef(Z,h){const V=this._x,v=this._y,A=this._z,H=Z._x,K=Z._y,d=Z._z,a=Z._w,n=2*(K*A-d*v),x=2*(d*V-H*A),N=2*(H*v-K*V);return h._x=V+a*n+K*N-d*x,h._y=v+a*x+d*n-H*N,h._z=A+a*N+H*x-K*n,h._isDirty=!0,h}applyRotationQuaternionInPlace(Z){return this.applyRotationQuaternionToRef(Z,this)}applyRotationQuaternion(Z){return this.applyRotationQuaternionToRef(Z,new F)}scaleAndAddToRef(Z,h){return h._x+=this._x*Z,h._y+=this._y*Z,h._z+=this._z*Z,h._isDirty=!0,h}projectOnPlane(Z,h){return this.projectOnPlaneToRef(Z,h,new F)}projectOnPlaneToRef(Z,h,V){const v=Z.normal,A=Z.d,H=X.Ch[0];this.subtractToRef(h,H),H.normalize();const K=F.Dot(H,v);if(Math.abs(K)<1e-10)V.vd(1/0);else{const Z=-(F.Dot(h,v)+A)/K,d=H.scaleInPlace(Z);h.addToRef(d,V)}return V}equals(Z){return Z&&this._x===Z._x&&this._y===Z._y&&this._z===Z._z}equalsWithEpsilon(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v.c;return Z&&(0,a.WithinEpsilon)(this._x,Z._x,h)&&(0,a.WithinEpsilon)(this._y,Z._y,h)&&(0,a.WithinEpsilon)(this._z,Z._z,h)}equalsToFloats(Z,h,V){return this._x===Z&&this._y===h&&this._z===V}multiplyInPlace(Z){return this._x*=Z._x,this._y*=Z._y,this._z*=Z._z,this._isDirty=!0,this}multiply(Z){return this.multiplyByFloats(Z._x,Z._y,Z._z)}multiplyToRef(Z,h){return h._x=this._x*Z._x,h._y=this._y*Z._y,h._z=this._z*Z._z,h._isDirty=!0,h}multiplyByFloats(Z,h,V){return new F(this._x*Z,this._y*h,this._z*V)}divide(Z){return new F(this._x/Z._x,this._y/Z._y,this._z/Z._z)}divideToRef(Z,h){return h._x=this._x/Z._x,h._y=this._y/Z._y,h._z=this._z/Z._z,h._isDirty=!0,h}divideInPlace(Z){return this._x=this._x/Z._x,this._y=this._y/Z._y,this._z=this._z/Z._z,this._isDirty=!0,this}minimizeInPlace(Z){return this.minimizeInPlaceFromFloats(Z._x,Z._y,Z._z)}maximizeInPlace(Z){return this.maximizeInPlaceFromFloats(Z._x,Z._y,Z._z)}minimizeInPlaceFromFloats(Z,h,V){return Z<this._x&&(this.x=Z),h<this._y&&(this.y=h),V<this._z&&(this.z=V),this}maximizeInPlaceFromFloats(Z,h,V){return Z>this._x&&(this.x=Z),h>this._y&&(this.y=h),V>this._z&&(this.z=V),this}isNonUniformWithinEpsilon(Z){const h=Math.abs(this._x),V=Math.abs(this._y);if(!(0,a.WithinEpsilon)(h,V,Z))return!0;const v=Math.abs(this._z);return!(0,a.WithinEpsilon)(h,v,Z)||!(0,a.WithinEpsilon)(V,v,Z)}get isNonUniform(){const Z=Math.abs(this._x);if(Z!==Math.abs(this._y))return!0;return Z!==Math.abs(this._z)}floorToRef(Z){return Z._x=Math.floor(this._x),Z._y=Math.floor(this._y),Z._z=Math.floor(this._z),Z._isDirty=!0,Z}floor(){return new F(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(Z){return Z._x=this._x-Math.floor(this._x),Z._y=this._y-Math.floor(this._y),Z._z=this._z-Math.floor(this._z),Z._isDirty=!0,Z}fract(){return new F(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(Z){if("xyz"===(Z=Z.toLowerCase()))return this;const h=X.Ch[0].v(this);return this.x=h[Z[0]],this.y=h[Z[1]],this.z=h[Z[2]],this}rotateByQuaternionToRef(Z,h){return Z.toRotationMatrix(X.Matrix[0]),F.TransformCoordinatesToRef(this,X.Matrix[0],h),h}rotateByQuaternionAroundPointToRef(Z,h,V){return this.subtractToRef(h,X.Ch[0]),X.Ch[0].rotateByQuaternionToRef(Z,X.Ch[0]),h.addToRef(X.Ch[0],V),V}cross(Z){return F.CrossToRef(this,Z,new F)}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){return this.normalizeToRef(new F)}normalizeToRef(Z){const h=this.length();return 0===h||1===h?(Z._x=this._x,Z._y=this._y,Z._z=this._z,Z._isDirty=!0,Z):this.scaleToRef(1/h,Z)}clone(){return new F(this._x,this._y,this._z)}v(Z){return this.IV(Z._x,Z._y,Z._z)}IV(Z,h,V){return this._x=Z,this._y=h,this._z=V,this._isDirty=!0,this}set(Z,h,V){return this.IV(Z,h,V)}vd(Z){return this._x=this._y=this._z=Z,this._isDirty=!0,this}static GetClipFactor(Z,h,V,v){const A=F.Dot(Z,V);return(A-v)/(A-F.Dot(h,V))}static GetAngleBetweenVectors(Z,h,V){const v=Z.normalizeToRef(X.Ch[1]),A=h.normalizeToRef(X.Ch[2]);let H=F.Dot(v,A);H=(0,a.Clamp)(H,-1,1);const K=Math.acos(H),d=X.Ch[3];return F.CrossToRef(v,A,d),F.Dot(d,V)>0?isNaN(K)?0:K:isNaN(K)?-Math.PI:-Math.acos(H)}static GetAngleBetweenVectorsOnPlane(Z,h,V){X.Ch[0].v(Z);const v=X.Ch[0];X.Ch[1].v(h);const A=X.Ch[1];X.Ch[2].v(V);const H=X.Ch[2],K=X.Ch[3],d=X.Ch[4];v.normalize(),A.normalize(),H.normalize(),F.CrossToRef(H,v,K),F.CrossToRef(K,H,d);const n=Math.atan2(F.Dot(A,K),F.Dot(A,d));return(0,a.NormalizeRadians)(n)}static PitchYawRollToMoveBetweenPointsToRef(Z,h,V){const v=E.Ch[0];return h.subtractToRef(Z,v),V._y=Math.atan2(v.x,v.z)||0,V._x=Math.atan2(Math.sqrt(v.x**2+v.z**2),v.y)||0,V._z=0,V._isDirty=!0,V}static PitchYawRollToMoveBetweenPoints(Z,h){const V=F.Zero();return F.PitchYawRollToMoveBetweenPointsToRef(Z,h,V)}static SlerpToRef(Z,h,V,A){V=(0,a.Clamp)(V,0,1);const H=X.Ch[0],K=X.Ch[1];H.v(Z);const d=H.length();H.normalizeFromLength(d),K.v(h);const n=K.length();K.normalizeFromLength(n);const x=F.Dot(H,K);let N,D;if(x<1-v.c){const Z=Math.acos(x),h=1/Math.sin(Z);N=Math.sin((1-V)*Z)*h,D=Math.sin(V*Z)*h}else N=1-V,D=V;return H.scaleInPlace(N),K.scaleInPlace(D),A.v(H).addInPlace(K),A.scaleInPlace((0,a.Lerp)(d,n,V)),A}static SmoothToRef(Z,h,V,v,A){return F.SlerpToRef(Z,h,0===v?1:V/v,A),A}static eh(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(Z[h],Z[h+1],Z[h+2])}static FromFloatArray(Z,h){return F.eh(Z,h)}static FromArrayToRef(Z,h,V){return V._x=Z[h],V._y=Z[h+1],V._z=Z[h+2],V._isDirty=!0,V}static FromFloatArrayToRef(Z,h,V){return F.FromArrayToRef(Z,h,V)}static FromFloatsToRef(Z,h,V,v){return v.IV(Z,h,V),v}static Zero(){return new F(0,0,0)}static One(){return new F(1,1,1)}static Up(){return new F(0,1,0)}static get UpReadOnly(){return F._UpReadOnly}static get DownReadOnly(){return F._DownReadOnly}static get RightReadOnly(){return F._RightReadOnly}static get LeftReadOnly(){return F._LeftReadOnly}static get LeftHandedForwardReadOnly(){return F._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return F._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return F._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return F._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return F._ZeroReadOnly}static get OneReadOnly(){return F._OneReadOnly}static Down(){return new F(0,-1,0)}static Forward(){return new F(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new F(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new F(1,0,0)}static Left(){return new F(-1,0,0)}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F((0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).IV((0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h))}static TransformCoordinates(Z,h){const V=F.Zero();return F.TransformCoordinatesToRef(Z,h,V),V}static TransformCoordinatesToRef(Z,h,V){return F.TransformCoordinatesFromFloatsToRef(Z._x,Z._y,Z._z,h,V),V}static TransformCoordinatesFromFloatsToRef(Z,h,V,v,A){const H=v.m,K=Z*H[0]+h*H[4]+V*H[8]+H[12],d=Z*H[1]+h*H[5]+V*H[9]+H[13],a=Z*H[2]+h*H[6]+V*H[10]+H[14],n=1/(Z*H[3]+h*H[7]+V*H[11]+H[15]);return A._x=K*n,A._y=d*n,A._z=a*n,A._isDirty=!0,A}static TransformNormal(Z,h){const V=F.Zero();return F.TransformNormalToRef(Z,h,V),V}static TransformNormalToRef(Z,h,V){return this.TransformNormalFromFloatsToRef(Z._x,Z._y,Z._z,h,V),V}static TransformNormalFromFloatsToRef(Z,h,V,v,A){const H=v.m;return A._x=Z*H[0]+h*H[4]+V*H[8],A._y=Z*H[1]+h*H[5]+V*H[9],A._z=Z*H[2]+h*H[6]+V*H[10],A._isDirty=!0,A}static CatmullRom(Z,h,V,v,A){const H=A*A,K=A*H,d=.5*(2*h._x+(-Z._x+V._x)*A+(2*Z._x-5*h._x+4*V._x-v._x)*H+(-Z._x+3*h._x-3*V._x+v._x)*K),a=.5*(2*h._y+(-Z._y+V._y)*A+(2*Z._y-5*h._y+4*V._y-v._y)*H+(-Z._y+3*h._y-3*V._y+v._y)*K),n=.5*(2*h._z+(-Z._z+V._z)*A+(2*Z._z-5*h._z+4*V._z-v._z)*H+(-Z._z+3*h._z-3*V._z+v._z)*K);return new F(d,a,n)}static Clamp(Z,h,V){const v=new F;return F.ClampToRef(Z,h,V,v),v}static ClampToRef(Z,h,V,v){let A=Z._x;A=A>V._x?V._x:A,A=A<h._x?h._x:A;let H=Z._y;H=H>V._y?V._y:H,H=H<h._y?h._y:H;let K=Z._z;return K=K>V._z?V._z:K,K=K<h._z?h._z:K,v.IV(A,H,K),v}static CheckExtends(Z,h,V){h.minimizeInPlace(Z),V.maximizeInPlace(Z)}static Hermite(Z,h,V,v,A){const H=A*A,K=A*H,d=2*K-3*H+1,a=-2*K+3*H,n=K-2*H+A,x=K-H,N=Z._x*d+V._x*a+h._x*n+v._x*x,D=Z._y*d+V._y*a+h._y*n+v._y*x,k=Z._z*d+V._z*a+h._z*n+v._z*x;return new F(N,D,k)}static Hermite1stDerivative(Z,h,V,v,A){const H=new F;return this.Hermite1stDerivativeToRef(Z,h,V,v,A,H),H}static Hermite1stDerivativeToRef(Z,h,V,v,A,H){const K=A*A;return H._x=6*(K-A)*Z._x+(3*K-4*A+1)*h._x+6*(-K+A)*V._x+(3*K-2*A)*v._x,H._y=6*(K-A)*Z._y+(3*K-4*A+1)*h._y+6*(-K+A)*V._y+(3*K-2*A)*v._y,H._z=6*(K-A)*Z._z+(3*K-4*A+1)*h._z+6*(-K+A)*V._z+(3*K-2*A)*v._z,H._isDirty=!0,H}static Lerp(Z,h,V){const v=new F(0,0,0);return F.LerpToRef(Z,h,V,v),v}static LerpToRef(Z,h,V,v){return v._x=Z._x+(h._x-Z._x)*V,v._y=Z._y+(h._y-Z._y)*V,v._z=Z._z+(h._z-Z._z)*V,v._isDirty=!0,v}static Dot(Z,h){return Z._x*h._x+Z._y*h._y+Z._z*h._z}dot(Z){return this._x*Z._x+this._y*Z._y+this._z*Z._z}static Cross(Z,h){const V=new F;return F.CrossToRef(Z,h,V),V}static CrossToRef(Z,h,V){const v=Z._y*h._z-Z._z*h._y,A=Z._z*h._x-Z._x*h._z,H=Z._x*h._y-Z._y*h._x;return V.IV(v,A,H),V}static Normalize(Z){const h=F.Zero();return F.NormalizeToRef(Z,h),h}static NormalizeToRef(Z,h){return Z.normalizeToRef(h),h}static Project(Z,h,V,v){const A=new F;return F.ProjectToRef(Z,h,V,v,A),A}static ProjectToRef(Z,h,V,v,A){var H;const K=v.width,a=v.height,n=v.x,x=v.y,N=X.Matrix[1],D=null===(H=d.b.LastCreatedEngine)||void 0===H?void 0:H.isNDCHalfZRange,k=D?1:.5,u=D?0:.5;q.FromValuesToRef(K/2,0,0,0,0,-a/2,0,0,0,0,k,0,n+K/2,a/2+x,u,1,N);const b=X.Matrix[0];return h.multiplyToRef(V,b),b.multiplyToRef(N,b),F.TransformCoordinatesToRef(Z,b,A),A}static Reflect(Z,h){return this.ReflectToRef(Z,h,new F)}static ReflectToRef(Z,h,V){const v=E.Ch[0];return v.v(h).scaleInPlace(2*F.Dot(Z,h)),V.v(Z).EN(v)}static _UnprojectFromInvertedMatrixToRef(Z,h,V){F.TransformCoordinatesToRef(Z,h,V);const v=h.m,A=Z._x*v[3]+Z._y*v[7]+Z._z*v[11]+v[15];return(0,a.WithinEpsilon)(A,1)&&V.scaleInPlace(1/A),V}static UnprojectFromTransform(Z,h,V,v,A){return this.Unproject(Z,h,V,v,A,q.IdentityReadOnly)}static Unproject(Z,h,V,v,A,H){const K=new F;return F.UnprojectToRef(Z,h,V,v,A,H,K),K}static UnprojectToRef(Z,h,V,v,A,H,K){return F.UnprojectFloatsToRef(Z._x,Z._y,Z._z,h,V,v,A,H,K),K}static UnprojectFloatsToRef(Z,h,V,v,A,H,K,a,n){var x;const N=X.Matrix[0];H.multiplyToRef(K,N),N.multiplyToRef(a,N),N.invert();const D=X.Ch[0];return D.x=Z/v*2-1,D.y=-(h/A*2-1),null!==(x=d.b.LastCreatedEngine)&&void 0!==x&&x.isNDCHalfZRange?D.z=V:D.z=2*V-1,F._UnprojectFromInvertedMatrixToRef(D,N,n),n}static Minimize(Z,h){const V=new F;return V.v(Z),V.minimizeInPlace(h),V}static Maximize(Z,h){const V=new F;return V.v(Z),V.maximizeInPlace(h),V}static Distance(Z,h){return Math.sqrt(F.DistanceSquared(Z,h))}static DistanceSquared(Z,h){const V=Z._x-h._x,v=Z._y-h._y,A=Z._z-h._z;return V*V+v*v+A*A}static ProjectOnTriangleToRef(Z,h,V,A,H){const K=X.Ch[0],d=X.Ch[1],n=X.Ch[2],x=X.Ch[3],N=X.Ch[4];V.subtractToRef(h,K),A.subtractToRef(h,d),A.subtractToRef(V,n);const D=K.length(),k=d.length(),u=n.length();if(D<v.c||k<v.c||u<v.c)return H.v(h),F.Distance(Z,h);Z.subtractToRef(h,N),F.CrossToRef(K,d,x);const b=x.length();if(b<v.c)return H.v(h),F.Distance(Z,h);x.normalizeFromLength(b);let o=N.length();if(o<v.c)return H.v(h),0;N.normalizeFromLength(o);const q=F.Dot(x,N),E=X.Ch[5],j=X.Ch[6];E.v(x).scaleInPlace(-o*q),j.v(Z).addInPlace(E);const P=X.Ch[4],C=X.Ch[5],l=X.Ch[7],B=X.Ch[8];P.v(K).scaleInPlace(1/D),B.v(d).scaleInPlace(1/k),P.addInPlace(B).scaleInPlace(-1),C.v(K).scaleInPlace(-1/D),B.v(n).scaleInPlace(1/u),C.addInPlace(B).scaleInPlace(-1),l.v(n).scaleInPlace(-1/u),B.v(d).scaleInPlace(-1/k),l.addInPlace(B).scaleInPlace(-1);const S=X.Ch[9];let r;S.v(j).EN(h),F.CrossToRef(P,S,B),r=F.Dot(B,x);const L=r;S.v(j).EN(V),F.CrossToRef(C,S,B),r=F.Dot(B,x);const y=r;S.v(j).EN(A),F.CrossToRef(l,S,B),r=F.Dot(B,x);const W=r,z=X.Ch[10];let m,g;L>0&&y<0?(z.v(K),m=h,g=V):y>0&&W<0?(z.v(n),m=V,g=A):(z.v(d).scaleInPlace(-1),m=A,g=h);const I=X.Ch[9],e=X.Ch[4];m.subtractToRef(j,B),g.subtractToRef(j,I),F.CrossToRef(B,I,e);if(!(F.Dot(e,x)<0))return H.v(j),Math.abs(o*q);const U=X.Ch[5];F.CrossToRef(z,e,U),U.normalize();const R=X.Ch[9];R.v(m).EN(j);const Q=R.length();if(Q<v.c)return H.v(m),F.Distance(Z,m);R.normalizeFromLength(Q);const w=F.Dot(U,R),T=X.Ch[7];T.v(j).addInPlace(U.scaleInPlace(Q*w)),B.v(T).EN(m),o=z.length(),z.normalizeFromLength(o);let t=F.Dot(B,z)/Math.max(o,v.c);return t=(0,a.Clamp)(t,0,1),T.v(m).addInPlace(z.scaleInPlace(t*o)),H.v(T),F.Distance(Z,T)}static Center(Z,h){return F.CenterToRef(Z,h,F.Zero())}static CenterToRef(Z,h,V){return V.IV((Z._x+h._x)/2,(Z._y+h._y)/2,(Z._z+h._z)/2)}static RotationFromAxis(Z,h,V){const v=new F;return F.RotationFromAxisToRef(Z,h,V,v),v}static RotationFromAxisToRef(Z,h,V,v){const A=X.Quaternion[0];return o.RotationQuaternionFromAxisToRef(Z,h,V,A),A.toEulerAnglesToRef(v),v}}F._V8PerformanceHack=new F(.5,.5,.5),F._UpReadOnly=F.Up(),F._DownReadOnly=F.Down(),F._LeftHandedForwardReadOnly=F.Forward(!1),F._RightHandedForwardReadOnly=F.Forward(!0),F._LeftHandedBackwardReadOnly=F.Backward(!1),F._RightHandedBackwardReadOnly=F.Backward(!0),F._RightReadOnly=F.Right(),F._LeftReadOnly=F.Left(),F._ZeroReadOnly=F.Zero(),F._OneReadOnly=F.One(),Object.defineProperties(F.prototype,{dimension:{value:[3]},rank:{value:1}});class b{get x(){return this._x}set x(Z){this._x=Z,this._isDirty=!0}get y(){return this._y}set y(Z){this._y=Z,this._isDirty=!0}get z(){return this._z}set z(Z){this._z=Z,this._isDirty=!0}get w(){return this._w}set w(Z){this._w=Z,this._isDirty=!0}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=Z,this._y=h,this._z=V,this._w=v}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let Z=k(this._x);return Z=397*Z^k(this._y),Z=397*Z^k(this._z),Z=397*Z^k(this._w),Z}mh(){return[this._x,this._y,this._z,this._w]}toArray(Z,h){return void 0===h&&(h=0),Z[h]=this._x,Z[h+1]=this._y,Z[h+2]=this._z,Z[h+3]=this._w,this}QV(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b.FromArrayToRef(Z,h,this),this}addInPlace(Z){return this.x+=Z._x,this.y+=Z._y,this.z+=Z._z,this.w+=Z._w,this}addInPlaceFromFloats(Z,h,V,v){return this.x+=Z,this.y+=h,this.z+=V,this.w+=v,this}add(Z){return new b(this._x+Z.x,this._y+Z.y,this._z+Z.z,this._w+Z.w)}addToRef(Z,h){return h.x=this._x+Z.x,h.y=this._y+Z.y,h.z=this._z+Z.z,h.w=this._w+Z.w,h}EN(Z){return this.x-=Z.x,this.y-=Z.y,this.z-=Z.z,this.w-=Z.w,this}rh(Z){return new b(this._x-Z.x,this._y-Z.y,this._z-Z.z,this._w-Z.w)}subtractToRef(Z,h){return h.x=this._x-Z.x,h.y=this._y-Z.y,h.z=this._z-Z.z,h.w=this._w-Z.w,h}subtractFromFloats(Z,h,V,v){return new b(this._x-Z,this._y-h,this._z-V,this._w-v)}subtractFromFloatsToRef(Z,h,V,v,A){return A.x=this._x-Z,A.y=this._y-h,A.z=this._z-V,A.w=this._w-v,A}negate(){return new b(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(Z){return Z.x=-this._x,Z.y=-this._y,Z.z=-this._z,Z.w=-this._w,Z}scaleInPlace(Z){return this.x*=Z,this.y*=Z,this.z*=Z,this.w*=Z,this}scale(Z){return new b(this._x*Z,this._y*Z,this._z*Z,this._w*Z)}scaleToRef(Z,h){return h.x=this._x*Z,h.y=this._y*Z,h.z=this._z*Z,h.w=this._w*Z,h}scaleAndAddToRef(Z,h){return h.x+=this._x*Z,h.y+=this._y*Z,h.z+=this._z*Z,h.w+=this._w*Z,h}equals(Z){return Z&&this._x===Z.x&&this._y===Z.y&&this._z===Z.z&&this._w===Z.w}equalsWithEpsilon(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v.c;return Z&&(0,a.WithinEpsilon)(this._x,Z.x,h)&&(0,a.WithinEpsilon)(this._y,Z.y,h)&&(0,a.WithinEpsilon)(this._z,Z.z,h)&&(0,a.WithinEpsilon)(this._w,Z.w,h)}equalsToFloats(Z,h,V,v){return this._x===Z&&this._y===h&&this._z===V&&this._w===v}multiplyInPlace(Z){return this.x*=Z.x,this.y*=Z.y,this.z*=Z.z,this.w*=Z.w,this}multiply(Z){return new b(this._x*Z.x,this._y*Z.y,this._z*Z.z,this._w*Z.w)}multiplyToRef(Z,h){return h.x=this._x*Z.x,h.y=this._y*Z.y,h.z=this._z*Z.z,h.w=this._w*Z.w,h}multiplyByFloats(Z,h,V,v){return new b(this._x*Z,this._y*h,this._z*V,this._w*v)}divide(Z){return new b(this._x/Z.x,this._y/Z.y,this._z/Z.z,this._w/Z.w)}divideToRef(Z,h){return h.x=this._x/Z.x,h.y=this._y/Z.y,h.z=this._z/Z.z,h.w=this._w/Z.w,h}divideInPlace(Z){return this.divideToRef(Z,this)}minimizeInPlace(Z){return Z.x<this._x&&(this.x=Z.x),Z.y<this._y&&(this.y=Z.y),Z.z<this._z&&(this.z=Z.z),Z.w<this._w&&(this.w=Z.w),this}maximizeInPlace(Z){return Z.x>this._x&&(this.x=Z.x),Z.y>this._y&&(this.y=Z.y),Z.z>this._z&&(this.z=Z.z),Z.w>this._w&&(this.w=Z.w),this}minimizeInPlaceFromFloats(Z,h,V,v){return this.x=Math.min(Z,this._x),this.y=Math.min(h,this._y),this.z=Math.min(V,this._z),this.w=Math.min(v,this._w),this}maximizeInPlaceFromFloats(Z,h,V,v){return this.x=Math.max(Z,this._x),this.y=Math.max(h,this._y),this.z=Math.max(V,this._z),this.w=Math.max(v,this._w),this}floorToRef(Z){return Z.x=Math.floor(this._x),Z.y=Math.floor(this._y),Z.z=Math.floor(this._z),Z.w=Math.floor(this._w),Z}floor(){return new b(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(Z){return Z.x=this._x-Math.floor(this._x),Z.y=this._y-Math.floor(this._y),Z.z=this._z-Math.floor(this._z),Z.w=this._w-Math.floor(this._w),Z}fract(){return new b(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){return this.normalizeToRef(new b)}normalizeToRef(Z){const h=this.length();return 0===h||1===h?(Z.x=this._x,Z.y=this._y,Z.z=this._z,Z.w=this._w,Z):this.scaleToRef(1/h,Z)}toVector3(){return new F(this._x,this._y,this._z)}clone(){return new b(this._x,this._y,this._z,this._w)}v(Z){return this.x=Z.x,this.y=Z.y,this.z=Z.z,this.w=Z.w,this}IV(Z,h,V,v){return this.x=Z,this.y=h,this.z=V,this.w=v,this}set(Z,h,V,v){return this.IV(Z,h,V,v)}vd(Z){return this.x=this.y=this.z=this.w=Z,this}dot(Z){return this._x*Z.x+this._y*Z.y+this._z*Z.z+this._w*Z.w}static eh(Z,h){return h||(h=0),new b(Z[h],Z[h+1],Z[h+2],Z[h+3])}static FromArrayToRef(Z,h,V){return V.x=Z[h],V.y=Z[h+1],V.z=Z[h+2],V.w=Z[h+3],V}static FromFloatArrayToRef(Z,h,V){return b.FromArrayToRef(Z,h,V),V}static FromFloatsToRef(Z,h,V,v,A){return A.x=Z,A.y=h,A.z=V,A.w=v,A}static Zero(){return new b(0,0,0,0)}static One(){return new b(1,1,1,1)}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new b((0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0;return V.x=(0,a.RandomRange)(Z,h),V.y=(0,a.RandomRange)(Z,h),V.z=(0,a.RandomRange)(Z,h),V.w=(0,a.RandomRange)(Z,h),V}static Clamp(Z,h,V){return b.ClampToRef(Z,h,V,new b)}static ClampToRef(Z,h,V,v){return v.x=(0,a.Clamp)(Z.x,h.x,V.x),v.y=(0,a.Clamp)(Z.y,h.y,V.y),v.z=(0,a.Clamp)(Z.z,h.z,V.z),v.w=(0,a.Clamp)(Z.w,h.w,V.w),v}static CheckExtends(Z,h,V){h.minimizeInPlace(Z),V.maximizeInPlace(Z)}static get ZeroReadOnly(){return b._ZeroReadOnly}static Normalize(Z){return b.NormalizeToRef(Z,new b)}static NormalizeToRef(Z,h){return Z.normalizeToRef(h),h}static Minimize(Z,h){const V=new b;return V.v(Z),V.minimizeInPlace(h),V}static Maximize(Z,h){const V=new b;return V.v(Z),V.maximizeInPlace(h),V}static Distance(Z,h){return Math.sqrt(b.DistanceSquared(Z,h))}static DistanceSquared(Z,h){const V=Z.x-h.x,v=Z.y-h.y,A=Z.z-h.z,H=Z.w-h.w;return V*V+v*v+A*A+H*H}static Center(Z,h){return b.CenterToRef(Z,h,new b)}static CenterToRef(Z,h,V){return V.x=(Z.x+h.x)/2,V.y=(Z.y+h.y)/2,V.z=(Z.z+h.z)/2,V.w=(Z.w+h.w)/2,V}static TransformCoordinates(Z,h){return b.TransformCoordinatesToRef(Z,h,new b)}static TransformCoordinatesToRef(Z,h,V){return b.TransformCoordinatesFromFloatsToRef(Z._x,Z._y,Z._z,h,V),V}static TransformCoordinatesFromFloatsToRef(Z,h,V,v,A){const H=v.m,K=Z*H[0]+h*H[4]+V*H[8]+H[12],d=Z*H[1]+h*H[5]+V*H[9]+H[13],a=Z*H[2]+h*H[6]+V*H[10]+H[14],n=Z*H[3]+h*H[7]+V*H[11]+H[15];return A.x=K,A.y=d,A.z=a,A.w=n,A}static TransformNormal(Z,h){return b.TransformNormalToRef(Z,h,new b)}static TransformNormalToRef(Z,h,V){const v=h.m,A=Z.x*v[0]+Z.y*v[4]+Z.z*v[8],H=Z.x*v[1]+Z.y*v[5]+Z.z*v[9],K=Z.x*v[2]+Z.y*v[6]+Z.z*v[10];return V.x=A,V.y=H,V.z=K,V.w=Z.w,V}static TransformNormalFromFloatsToRef(Z,h,V,v,A,H){const K=A.m;return H.x=Z*K[0]+h*K[4]+V*K[8],H.y=Z*K[1]+h*K[5]+V*K[9],H.z=Z*K[2]+h*K[6]+V*K[10],H.w=v,H}static FromVector3(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new b(Z._x,Z._y,Z._z,h)}static Dot(Z,h){return Z.x*h.x+Z.y*h.y+Z.z*h.z+Z.w*h.w}}b._V8PerformanceHack=new b(.5,.5,.5,.5),b._ZeroReadOnly=b.Zero(),Object.defineProperties(b.prototype,{dimension:{value:[4]},rank:{value:1}});class o{get x(){return this._x}set x(Z){this._x=Z,this._isDirty=!0}get y(){return this._y}set y(Z){this._y=Z,this._isDirty=!0}get z(){return this._z}set z(Z){this._z=Z,this._isDirty=!0}get w(){return this._w}set w(Z){this._w=Z,this._isDirty=!0}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=Z,this._y=h,this._z=V,this._w=v}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let Z=k(this._x);return Z=397*Z^k(this._y),Z=397*Z^k(this._z),Z=397*Z^k(this._w),Z}mh(){return[this._x,this._y,this._z,this._w]}toArray(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[h]=this._x,Z[h+1]=this._y,Z[h+2]=this._z,Z[h+3]=this._w,this}QV(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o.FromArrayToRef(Z,h,this)}equals(Z){return Z&&this._x===Z._x&&this._y===Z._y&&this._z===Z._z&&this._w===Z._w}equalsWithEpsilon(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v.c;return Z&&(0,a.WithinEpsilon)(this._x,Z._x,h)&&(0,a.WithinEpsilon)(this._y,Z._y,h)&&(0,a.WithinEpsilon)(this._z,Z._z,h)&&(0,a.WithinEpsilon)(this._w,Z._w,h)}isApprox(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v.c;return Z&&((0,a.WithinEpsilon)(this._x,Z._x,h)&&(0,a.WithinEpsilon)(this._y,Z._y,h)&&(0,a.WithinEpsilon)(this._z,Z._z,h)&&(0,a.WithinEpsilon)(this._w,Z._w,h)||(0,a.WithinEpsilon)(this._x,-Z._x,h)&&(0,a.WithinEpsilon)(this._y,-Z._y,h)&&(0,a.WithinEpsilon)(this._z,-Z._z,h)&&(0,a.WithinEpsilon)(this._w,-Z._w,h))}clone(){return new o(this._x,this._y,this._z,this._w)}v(Z){return this._x=Z._x,this._y=Z._y,this._z=Z._z,this._w=Z._w,this._isDirty=!0,this}IV(Z,h,V,v){return this._x=Z,this._y=h,this._z=V,this._w=v,this._isDirty=!0,this}set(Z,h,V,v){return this.IV(Z,h,V,v)}vd(Z){return this.IV(Z,Z,Z,Z)}add(Z){return new o(this._x+Z._x,this._y+Z._y,this._z+Z._z,this._w+Z._w)}addInPlace(Z){return this._x+=Z._x,this._y+=Z._y,this._z+=Z._z,this._w+=Z._w,this._isDirty=!0,this}addToRef(Z,h){return h._x=this._x+Z._x,h._y=this._y+Z._y,h._z=this._z+Z._z,h._w=this._w+Z._w,h._isDirty=!0,h}addInPlaceFromFloats(Z,h,V,v){return this._x+=Z,this._y+=h,this._z+=V,this._w+=v,this._isDirty=!0,this}subtractToRef(Z,h){return h._x=this._x-Z._x,h._y=this._y-Z._y,h._z=this._z-Z._z,h._w=this._w-Z._w,h._isDirty=!0,h}subtractFromFloats(Z,h,V,v){return this.subtractFromFloatsToRef(Z,h,V,v,new o)}subtractFromFloatsToRef(Z,h,V,v,A){return A._x=this._x-Z,A._y=this._y-h,A._z=this._z-V,A._w=this._w-v,A._isDirty=!0,A}rh(Z){return new o(this._x-Z._x,this._y-Z._y,this._z-Z._z,this._w-Z._w)}EN(Z){return this._x-=Z._x,this._y-=Z._y,this._z-=Z._z,this._w-=Z._w,this._isDirty=!0,this}scale(Z){return new o(this._x*Z,this._y*Z,this._z*Z,this._w*Z)}scaleToRef(Z,h){return h._x=this._x*Z,h._y=this._y*Z,h._z=this._z*Z,h._w=this._w*Z,h._isDirty=!0,h}scaleInPlace(Z){return this._x*=Z,this._y*=Z,this._z*=Z,this._w*=Z,this._isDirty=!0,this}scaleAndAddToRef(Z,h){return h._x+=this._x*Z,h._y+=this._y*Z,h._z+=this._z*Z,h._w+=this._w*Z,h._isDirty=!0,h}multiply(Z){const h=new o(0,0,0,1);return this.multiplyToRef(Z,h),h}multiplyToRef(Z,h){const V=this._x*Z._w+this._y*Z._z-this._z*Z._y+this._w*Z._x,v=-this._x*Z._z+this._y*Z._w+this._z*Z._x+this._w*Z._y,A=this._x*Z._y-this._y*Z._x+this._z*Z._w+this._w*Z._z,H=-this._x*Z._x-this._y*Z._y-this._z*Z._z+this._w*Z._w;return h.IV(V,v,A,H),h}multiplyInPlace(Z){return this.multiplyToRef(Z,this)}multiplyByFloats(Z,h,V,v){return this._x*=Z,this._y*=h,this._z*=V,this._w*=v,this._isDirty=!0,this}divide(Z){throw new ReferenceError("Can not divide a quaternion")}divideToRef(Z,h){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(Z){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new o)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(Z){return Z._x=-this._x,Z._y=-this._y,Z._z=-this._z,Z._w=-this._w,Z._isDirty=!0,Z}equalsToFloats(Z,h,V,v){return this._x===Z&&this._y===h&&this._z===V&&this._w===v}floorToRef(Z){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(Z){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(Z){return Z.IV(-this._x,-this._y,-this._z,this._w),Z}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new o(-this._x,-this._y,-this._z,this._w)}invert(){const Z=this.conjugate(),h=this.lengthSquared();return 0==h||1==h||Z.scaleInPlace(1/h),Z}invertInPlace(){this.conjugateInPlace();const Z=this.lengthSquared();return 0==Z||1==Z||this.scaleInPlace(1/Z),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){const Z=new o(0,0,0,1);return this.normalizeToRef(Z),Z}normalizeToRef(Z){const h=this.length();return 0===h||1===h?Z.IV(this._x,this._y,this._z,this._w):this.scaleToRef(1/h,Z)}toEulerAngles(){const Z=F.Zero();return this.toEulerAnglesToRef(Z),Z}toEulerAnglesToRef(Z){const h=this._z,V=this._x,v=this._y,A=this._w,H=v*h-V*A,K=.4999999;if(H<-K)Z._y=2*Math.atan2(v,A),Z._x=Math.PI/2,Z._z=0,Z._isDirty=!0;else if(H>K)Z._y=2*Math.atan2(v,A),Z._x=-Math.PI/2,Z._z=0,Z._isDirty=!0;else{const K=A*A,d=h*h,a=V*V,n=v*v;Z._z=Math.atan2(2*(V*v+h*A),-d-a+n+K),Z._x=Math.asin(-2*H),Z._y=Math.atan2(2*(h*V+v*A),d-a-n+K),Z._isDirty=!0}return Z}toAlphaBetaGammaToRef(Z){const h=this._z,V=this._x,v=this._y,A=this._w,H=Math.sqrt(V*V+v*v),K=Math.sqrt(h*h+A*A),d=2*Math.atan2(H,K),a=2*Math.atan2(h,A),n=2*Math.atan2(v,V),x=(a+n)/2,N=(a-n)/2;return Z.set(N,d,x),Z}toRotationMatrix(Z){return q.FromQuaternionToRef(this,Z),Z}fromRotationMatrix(Z){return o.FromRotationMatrixToRef(Z,this),this}dot(Z){return this._x*Z._x+this._y*Z._y+this._z*Z._z+this._w*Z._w}toAxisAngle(){const Z=F.Zero();return{axis:Z,angle:this.toAxisAngleToRef(Z)}}toAxisAngleToRef(Z){let h=0;const V=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),v=this._w;return V>0?(h=2*Math.atan2(V,v),Z.set(this._x/V,this._y/V,this._z/V)):(h=0,Z.set(1,0,0)),h}static FromRotationMatrix(Z){const h=new o;return o.FromRotationMatrixToRef(Z,h),h}static FromRotationMatrixToRef(Z,h){const V=Z.m,v=V[0],A=V[4],H=V[8],K=V[1],d=V[5],a=V[9],n=V[2],x=V[6],N=V[10],D=v+d+N;let k;return D>0?(k=.5/Math.sqrt(D+1),h._w=.25/k,h._x=(x-a)*k,h._y=(H-n)*k,h._z=(K-A)*k,h._isDirty=!0):v>d&&v>N?(k=2*Math.sqrt(1+v-d-N),h._w=(x-a)/k,h._x=.25*k,h._y=(A+K)/k,h._z=(H+n)/k,h._isDirty=!0):d>N?(k=2*Math.sqrt(1+d-v-N),h._w=(H-n)/k,h._x=(A+K)/k,h._y=.25*k,h._z=(a+x)/k,h._isDirty=!0):(k=2*Math.sqrt(1+N-v-d),h._w=(K-A)/k,h._x=(H+n)/k,h._y=(a+x)/k,h._z=.25*k,h._isDirty=!0),h}static Dot(Z,h){return Z._x*h._x+Z._y*h._y+Z._z*h._z+Z._w*h._w}static AreClose(Z,h){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const v=o.Dot(Z,h);return 1-v*v<=V}static SmoothToRef(Z,h,V,v,A){let H=0===v?1:V/v;return H=(0,a.Clamp)(H,0,1),o.SlerpToRef(Z,h,H,A),A}static Zero(){return new o(0,0,0,0)}static Inverse(Z){return new o(-Z._x,-Z._y,-Z._z,Z._w)}static InverseToRef(Z,h){return h.set(-Z._x,-Z._y,-Z._z,Z._w),h}static Identity(){return new o(0,0,0,1)}static IsIdentity(Z){return Z&&0===Z._x&&0===Z._y&&0===Z._z&&1===Z._w}static RotationAxis(Z,h){return o.RotationAxisToRef(Z,h,new o)}static RotationAxisToRef(Z,h,V){V._w=Math.cos(h/2);const v=Math.sin(h/2)/Z.length();return V._x=Z._x*v,V._y=Z._y*v,V._z=Z._z*v,V._isDirty=!0,V}static eh(Z,h){return h||(h=0),new o(Z[h],Z[h+1],Z[h+2],Z[h+3])}static FromArrayToRef(Z,h,V){return V._x=Z[h],V._y=Z[h+1],V._z=Z[h+2],V._w=Z[h+3],V._isDirty=!0,V}static FromFloatsToRef(Z,h,V,v,A){return A.IV(Z,h,V,v),A}static FromEulerAngles(Z,h,V){const v=new o;return o.RotationYawPitchRollToRef(h,Z,V,v),v}static FromEulerAnglesToRef(Z,h,V,v){return o.RotationYawPitchRollToRef(h,Z,V,v),v}static FromEulerVector(Z){const h=new o;return o.RotationYawPitchRollToRef(Z._y,Z._x,Z._z,h),h}static FromEulerVectorToRef(Z,h){return o.RotationYawPitchRollToRef(Z._y,Z._x,Z._z,h),h}static FromUnitVectorsToRef(Z,h,V){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:v.c;const H=F.Dot(Z,h)+1;return H<A?Math.abs(Z.x)>Math.abs(Z.z)?V.set(-Z.y,Z.x,0,0):V.set(0,-Z.z,Z.y,0):(F.CrossToRef(Z,h,E.Ch[0]),V.set(E.Ch[0].x,E.Ch[0].y,E.Ch[0].z,H)),V.normalize()}static RotationYawPitchRoll(Z,h,V){const v=new o;return o.RotationYawPitchRollToRef(Z,h,V,v),v}static RotationYawPitchRollToRef(Z,h,V,v){const A=.5*V,H=.5*h,K=.5*Z,d=Math.sin(A),a=Math.cos(A),n=Math.sin(H),x=Math.cos(H),N=Math.sin(K),D=Math.cos(K);return v._x=D*n*a+N*x*d,v._y=N*x*a-D*n*d,v._z=D*x*d-N*n*a,v._w=D*x*a+N*n*d,v._isDirty=!0,v}static RotationAlphaBetaGamma(Z,h,V){const v=new o;return o.RotationAlphaBetaGammaToRef(Z,h,V,v),v}static RotationAlphaBetaGammaToRef(Z,h,V,v){const A=.5*(V+Z),H=.5*(V-Z),K=.5*h;return v._x=Math.cos(H)*Math.sin(K),v._y=Math.sin(H)*Math.sin(K),v._z=Math.sin(A)*Math.cos(K),v._w=Math.cos(A)*Math.cos(K),v._isDirty=!0,v}static RotationQuaternionFromAxis(Z,h,V){const v=new o(0,0,0,0);return o.RotationQuaternionFromAxisToRef(Z,h,V,v),v}static RotationQuaternionFromAxisToRef(Z,h,V,v){const A=X.Matrix[0];return Z=Z.normalizeToRef(X.Ch[0]),h=h.normalizeToRef(X.Ch[1]),V=V.normalizeToRef(X.Ch[2]),q.FromXYZAxesToRef(Z,h,V,A),o.FromRotationMatrixToRef(A,v),v}static FromLookDirectionLH(Z,h){const V=new o;return o.FromLookDirectionLHToRef(Z,h,V),V}static FromLookDirectionLHToRef(Z,h,V){const v=X.Matrix[0];return q.LookDirectionLHToRef(Z,h,v),o.FromRotationMatrixToRef(v,V),V}static FromLookDirectionRH(Z,h){const V=new o;return o.FromLookDirectionRHToRef(Z,h,V),V}static FromLookDirectionRHToRef(Z,h,V){const v=X.Matrix[0];return q.LookDirectionRHToRef(Z,h,v),o.FromRotationMatrixToRef(v,V)}static Slerp(Z,h,V){const v=o.Identity();return o.SlerpToRef(Z,h,V,v),v}static SlerpToRef(Z,h,V,v){let A,H,K=Z._x*h._x+Z._y*h._y+Z._z*h._z+Z._w*h._w,d=!1;if(K<0&&(d=!0,K=-K),K>.999999)H=1-V,A=d?-V:V;else{const Z=Math.acos(K),h=1/Math.sin(Z);H=Math.sin((1-V)*Z)*h,A=d?-Math.sin(V*Z)*h:Math.sin(V*Z)*h}return v._x=H*Z._x+A*h._x,v._y=H*Z._y+A*h._y,v._z=H*Z._z+A*h._z,v._w=H*Z._w+A*h._w,v._isDirty=!0,v}static Hermite(Z,h,V,v,A){const H=A*A,K=A*H,d=2*K-3*H+1,a=-2*K+3*H,n=K-2*H+A,x=K-H,N=Z._x*d+V._x*a+h._x*n+v._x*x,D=Z._y*d+V._y*a+h._y*n+v._y*x,k=Z._z*d+V._z*a+h._z*n+v._z*x,u=Z._w*d+V._w*a+h._w*n+v._w*x;return new o(N,D,k,u)}static Hermite1stDerivative(Z,h,V,v,A){const H=new o;return this.Hermite1stDerivativeToRef(Z,h,V,v,A,H),H}static Hermite1stDerivativeToRef(Z,h,V,v,A,H){const K=A*A;return H._x=6*(K-A)*Z._x+(3*K-4*A+1)*h._x+6*(-K+A)*V._x+(3*K-2*A)*v._x,H._y=6*(K-A)*Z._y+(3*K-4*A+1)*h._y+6*(-K+A)*V._y+(3*K-2*A)*v._y,H._z=6*(K-A)*Z._z+(3*K-4*A+1)*h._z+6*(-K+A)*V._z+(3*K-2*A)*v._z,H._w=6*(K-A)*Z._w+(3*K-4*A+1)*h._w+6*(-K+A)*V._w+(3*K-2*A)*v._w,H._isDirty=!0,H}static Normalize(Z){const h=o.Zero();return o.NormalizeToRef(Z,h),h}static NormalizeToRef(Z,h){return Z.normalizeToRef(h),h}static Clamp(Z,h,V){const v=new o;return o.ClampToRef(Z,h,V,v),v}static ClampToRef(Z,h,V,v){return v.IV((0,a.Clamp)(Z.x,h.x,V.x),(0,a.Clamp)(Z.y,h.y,V.y),(0,a.Clamp)(Z.z,h.z,V.z),(0,a.Clamp)(Z.w,h.w,V.w))}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new o((0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).IV((0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h),(0,a.RandomRange)(Z,h))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(Z,h){return Math.sqrt(o.DistanceSquared(Z,h))}static DistanceSquared(Z,h){const V=Z.x-h.x,v=Z.y-h.y,A=Z.z-h.z,H=Z.w-h.w;return V*V+v*v+A*A+H*H}static Center(Z,h){return o.CenterToRef(Z,h,o.Zero())}static CenterToRef(Z,h,V){return V.IV((Z.x+h.x)/2,(Z.y+h.y)/2,(Z.z+h.z)/2,(Z.w+h.w)/2)}}o._V8PerformanceHack=new o(.5,.5,.5,.5),Object.defineProperties(o.prototype,{dimension:{value:[4]},rank:{value:1}});class q{static get Use64Bits(){return K.c.MatrixUse64Bits}get m(){return this.Bh}markAsUpdated(){this.updateFlag=n._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(Z){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2],v=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=Z,this._isIdentity3x2=Z||V,this._isIdentityDirty=!this._isIdentity&&h,this._isIdentity3x2Dirty=!this._isIdentity3x2&&v}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,K.c.MatrixTrackPrecisionChange&&K.c.MatrixTrackedMatrices.push(this),this.Bh=new K.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const Z=this.Bh;this._isIdentity=1===Z[0]&&0===Z[1]&&0===Z[2]&&0===Z[3]&&0===Z[4]&&1===Z[5]&&0===Z[6]&&0===Z[7]&&0===Z[8]&&0===Z[9]&&1===Z[10]&&0===Z[11]&&0===Z[12]&&0===Z[13]&&0===Z[14]&&1===Z[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Bh[0]||1!==this.Bh[5]||1!==this.Bh[15]||0!==this.Bh[1]||0!==this.Bh[2]||0!==this.Bh[3]||0!==this.Bh[4]||0!==this.Bh[6]||0!==this.Bh[7]||0!==this.Bh[8]||0!==this.Bh[9]||0!==this.Bh[10]||0!==this.Bh[11]||0!==this.Bh[12]||0!==this.Bh[13]||0!==this.Bh[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const Z=this.Bh,h=Z[0],V=Z[1],v=Z[2],A=Z[3],H=Z[4],K=Z[5],d=Z[6],a=Z[7],n=Z[8],x=Z[9],N=Z[10],D=Z[11],k=Z[12],u=Z[13],F=Z[14],b=Z[15],o=N*b-F*D,q=x*b-u*D,X=x*F-u*N,E=n*b-k*D,j=n*F-N*k,P=n*u-k*x;return h*+(K*o-d*q+a*X)+V*-(H*o-d*E+a*j)+v*+(H*q-K*E+a*P)+A*-(H*X-K*j+d*P)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!Z)return this.Bh;const V=this.Bh;for(let v=0;v<16;v++)Z[h+v]=V[v];return this}mh(){return this.Bh}QV(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q.FromArrayToRef(Z,h,this)}IV(){for(var Z=arguments.length,h=new Array(Z),V=0;V<Z;V++)h[V]=arguments[V];return q.FromArrayToRef(h,0,this)}set(){const Z=this.Bh;for(let h=0;h<16;h++)Z[h]=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}vd(Z){const h=this.Bh;for(let V=0;V<16;V++)h[V]=Z;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return q.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(Z){const h=new q;return this.addToRef(Z,h),h}addToRef(Z,h){const V=this.Bh,v=h.Bh,A=Z.m;for(let H=0;H<16;H++)v[H]=V[H]+A[H];return h.markAsUpdated(),h}addToSelf(Z){const h=this.Bh,V=Z.m;return h[0]+=V[0],h[1]+=V[1],h[2]+=V[2],h[3]+=V[3],h[4]+=V[4],h[5]+=V[5],h[6]+=V[6],h[7]+=V[7],h[8]+=V[8],h[9]+=V[9],h[10]+=V[10],h[11]+=V[11],h[12]+=V[12],h[13]+=V[13],h[14]+=V[14],h[15]+=V[15],this.markAsUpdated(),this}addInPlace(Z){const h=this.Bh,V=Z.m;for(let v=0;v<16;v++)h[v]+=V[v];return this.markAsUpdated(),this}addInPlaceFromFloats(){const Z=this.Bh;for(let h=0;h<16;h++)Z[h]+=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}rh(Z){const h=this.Bh,V=Z.m;for(let v=0;v<16;v++)h[v]-=V[v];return this.markAsUpdated(),this}subtractToRef(Z,h){const V=this.Bh,v=Z.m,A=h.Bh;for(let H=0;H<16;H++)A[H]=V[H]-v[H];return h.markAsUpdated(),h}EN(Z){const h=this.Bh,V=Z.m;for(let v=0;v<16;v++)h[v]-=V[v];return this.markAsUpdated(),this}subtractFromFloats(){for(var Z=arguments.length,h=new Array(Z),V=0;V<Z;V++)h[V]=arguments[V];return this.subtractFromFloatsToRef(...h,new q)}subtractFromFloatsToRef(){for(var Z=arguments.length,h=new Array(Z),V=0;V<Z;V++)h[V]=arguments[V];const v=h.pop(),A=this.Bh,H=v.Bh,K=h;for(let d=0;d<16;d++)H[d]=A[d]-K[d];return v.markAsUpdated(),v}invertToRef(Z){return!0===this._isIdentity?(q.IdentityToRef(Z),Z):(D(this,Z.mh())?Z.markAsUpdated():Z.v(this),Z)}addAtIndex(Z,h){return this.Bh[Z]+=h,this.markAsUpdated(),this}multiplyAtIndex(Z,h){return this.Bh[Z]*=h,this.markAsUpdated(),this}setTranslationFromFloats(Z,h,V){return this.Bh[12]=Z,this.Bh[13]=h,this.Bh[14]=V,this.markAsUpdated(),this}addTranslationFromFloats(Z,h,V){return this.Bh[12]+=Z,this.Bh[13]+=h,this.Bh[14]+=V,this.markAsUpdated(),this}setTranslation(Z){return this.setTranslationFromFloats(Z._x,Z._y,Z._z)}getTranslation(){return new F(this.Bh[12],this.Bh[13],this.Bh[14])}getTranslationToRef(Z){return Z.x=this.Bh[12],Z.y=this.Bh[13],Z.z=this.Bh[14],Z}removeRotationAndScaling(){const Z=this.m;return q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,Z[12],Z[13],Z[14],Z[15],this),this._updateIdentityStatus(0===Z[12]&&0===Z[13]&&0===Z[14]&&1===Z[15]),this}v(Z){Z.copyToArray(this.Bh);const h=Z;return this.updateFlag=h.updateFlag,this._updateIdentityStatus(h._isIdentity,h._isIdentityDirty,h._isIdentity3x2,h._isIdentity3x2Dirty),this}copyToArray(Z){return N(this,Z,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(Z){const h=new q;return this.multiplyToRef(Z,h),h}multiplyInPlace(Z){const h=this.Bh,V=Z.m;for(let v=0;v<16;v++)h[v]*=V[v];return this.markAsUpdated(),this}multiplyByFloats(){const Z=this.Bh;for(let h=0;h<16;h++)Z[h]*=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var Z=arguments.length,h=new Array(Z),V=0;V<Z;V++)h[V]=arguments[V];const v=h.pop(),A=this.Bh,H=v.Bh,K=h;for(let d=0;d<16;d++)H[d]=A[d]*K[d];return v.markAsUpdated(),v}multiplyToRef(Z,h){return this._isIdentity?(h.v(Z),h):Z._isIdentity?(h.v(this),h):(this.multiplyToArray(Z,h.Bh,0),h.markAsUpdated(),h)}multiplyToArray(Z,h,V){return x(this,Z,h,V),this}divide(Z){return this.divideToRef(Z,new q)}divideToRef(Z,h){const V=this.Bh,v=Z.m,A=h.Bh;for(let H=0;H<16;H++)A[H]=V[H]/v[H];return h.markAsUpdated(),h}divideInPlace(Z){const h=this.Bh,V=Z.m;for(let v=0;v<16;v++)h[v]/=V[v];return this.markAsUpdated(),this}minimizeInPlace(Z){const h=this.Bh,V=Z.m;for(let v=0;v<16;v++)h[v]=Math.min(h[v],V[v]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const Z=this.Bh;for(let h=0;h<16;h++)Z[h]=Math.min(Z[h],h<0||arguments.length<=h?void 0:arguments[h]);return this.markAsUpdated(),this}maximizeInPlace(Z){const h=this.Bh,V=Z.m;for(let v=0;v<16;v++)h[v]=Math.min(h[v],V[v]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const Z=this.Bh;for(let h=0;h<16;h++)Z[h]=Math.min(Z[h],h<0||arguments.length<=h?void 0:arguments[h]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new q)}negateInPlace(){const Z=this.Bh;for(let h=0;h<16;h++)Z[h]=-Z[h];return this.markAsUpdated(),this}negateToRef(Z){const h=this.Bh,V=Z.Bh;for(let v=0;v<16;v++)V[v]=-h[v];return Z.markAsUpdated(),Z}equals(Z){const h=Z;if(!h)return!1;if((this._isIdentity||h._isIdentity)&&!this._isIdentityDirty&&!h._isIdentityDirty)return this._isIdentity&&h._isIdentity;const V=this.m,v=h.m;return V[0]===v[0]&&V[1]===v[1]&&V[2]===v[2]&&V[3]===v[3]&&V[4]===v[4]&&V[5]===v[5]&&V[6]===v[6]&&V[7]===v[7]&&V[8]===v[8]&&V[9]===v[9]&&V[10]===v[10]&&V[11]===v[11]&&V[12]===v[12]&&V[13]===v[13]&&V[14]===v[14]&&V[15]===v[15]}equalsWithEpsilon(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const V=this.Bh,v=Z.m;for(let A=0;A<16;A++)if(!(0,a.WithinEpsilon)(V[A],v[A],h))return!1;return!0}equalsToFloats(){const Z=this.Bh;for(let h=0;h<16;h++)if(Z[h]!=(h<0||arguments.length<=h?void 0:arguments[h]))return!1;return!0}floor(){return this.floorToRef(new q)}floorToRef(Z){const h=this.Bh,V=Z.Bh;for(let v=0;v<16;v++)V[v]=Math.floor(h[v]);return Z.markAsUpdated(),Z}fract(){return this.fractToRef(new q)}fractToRef(Z){const h=this.Bh,V=Z.Bh;for(let v=0;v<16;v++)V[v]=h[v]-Math.floor(h[v]);return Z.markAsUpdated(),Z}clone(){const Z=new q;return Z.v(this),Z}getClassName(){return"Matrix"}getHashCode(){let Z=k(this.Bh[0]);for(let h=1;h<16;h++)Z=397*Z^k(this.Bh[h]);return Z}decomposeToTransformNode(Z){return Z.rotationQuaternion=Z.rotationQuaternion||new o,this.decompose(Z.tv,Z.rotationQuaternion,Z.position)}decompose(Z,h,V,v){let A=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return V&&V.vd(0),Z&&Z.vd(1),h&&h.IV(0,0,0,1),!0;const H=this.Bh;if(V&&V.IV(H[12],H[13],H[14]),(Z=Z||X.Ch[0]).x=Math.sqrt(H[0]*H[0]+H[1]*H[1]+H[2]*H[2]),Z.y=Math.sqrt(H[4]*H[4]+H[5]*H[5]+H[6]*H[6]),Z.z=Math.sqrt(H[8]*H[8]+H[9]*H[9]+H[10]*H[10]),v){const h=(A?v.absoluteScaling.x:v.tv.x)<0?-1:1,V=(A?v.absoluteScaling.y:v.tv.y)<0?-1:1,H=(A?v.absoluteScaling.z:v.tv.z)<0?-1:1;Z.x*=h,Z.y*=V,Z.z*=H}else this.determinant()<=0&&(Z.y*=-1);if(0===Z._x||0===Z._y||0===Z._z)return h&&h.IV(0,0,0,1),!1;if(h){const V=1/Z._x,v=1/Z._y,A=1/Z._z;q.FromValuesToRef(H[0]*V,H[1]*V,H[2]*V,0,H[4]*v,H[5]*v,H[6]*v,0,H[8]*A,H[9]*A,H[10]*A,0,0,0,0,1,X.Matrix[0]),o.FromRotationMatrixToRef(X.Matrix[0],h)}return!0}getRow(Z){if(Z<0||Z>3)return null;const h=4*Z;return new b(this.Bh[h+0],this.Bh[h+1],this.Bh[h+2],this.Bh[h+3])}getRowToRef(Z,h){if(Z>=0&&Z<=3){const V=4*Z;h.x=this.Bh[V+0],h.y=this.Bh[V+1],h.z=this.Bh[V+2],h.w=this.Bh[V+3]}return h}setRow(Z,h){return this.setRowFromFloats(Z,h.x,h.y,h.z,h.w)}transpose(){const Z=new q;return q.TransposeToRef(this,Z),Z}transposeToRef(Z){return q.TransposeToRef(this,Z),Z}setRowFromFloats(Z,h,V,v,A){if(Z<0||Z>3)return this;const H=4*Z;return this.Bh[H+0]=h,this.Bh[H+1]=V,this.Bh[H+2]=v,this.Bh[H+3]=A,this.markAsUpdated(),this}scale(Z){const h=new q;return this.scaleToRef(Z,h),h}scaleToRef(Z,h){for(let V=0;V<16;V++)h.Bh[V]=this.Bh[V]*Z;return h.markAsUpdated(),h}scaleAndAddToRef(Z,h){for(let V=0;V<16;V++)h.Bh[V]+=this.Bh[V]*Z;return h.markAsUpdated(),h}scaleInPlace(Z){const h=this.Bh;for(let V=0;V<16;V++)h[V]*=Z;return this.markAsUpdated(),this}toNormalMatrix(Z){const h=X.Matrix[0];this.invertToRef(h),h.transposeToRef(Z);const V=Z.Bh;return q.FromValuesToRef(V[0],V[1],V[2],0,V[4],V[5],V[6],0,V[8],V[9],V[10],0,0,0,0,1,Z),Z}getRotationMatrix(){const Z=new q;return this.getRotationMatrixToRef(Z),Z}getRotationMatrixToRef(Z){const h=X.Ch[0];if(!this.decompose(h))return q.IdentityToRef(Z),Z;const V=this.Bh,v=1/h._x,A=1/h._y,H=1/h._z;return q.FromValuesToRef(V[0]*v,V[1]*v,V[2]*v,0,V[4]*A,V[5]*A,V[6]*A,0,V[8]*H,V[9]*H,V[10]*H,0,0,0,0,1,Z),Z}toggleModelMatrixHandInPlace(){const Z=this.Bh;return Z[2]*=-1,Z[6]*=-1,Z[8]*=-1,Z[9]*=-1,Z[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const Z=this.Bh;return Z[8]*=-1,Z[9]*=-1,Z[10]*=-1,Z[11]*=-1,this.markAsUpdated(),this}static eh(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const V=new q;return q.FromArrayToRef(Z,h,V),V}static FromArrayToRef(Z,h,V){for(let v=0;v<16;v++)V.Bh[v]=Z[v+h];return V.markAsUpdated(),V}static FromFloat32ArrayToRefScaled(Z,h,V,v){return v.Bh[0]=Z[0+h]*V,v.Bh[1]=Z[1+h]*V,v.Bh[2]=Z[2+h]*V,v.Bh[3]=Z[3+h]*V,v.Bh[4]=Z[4+h]*V,v.Bh[5]=Z[5+h]*V,v.Bh[6]=Z[6+h]*V,v.Bh[7]=Z[7+h]*V,v.Bh[8]=Z[8+h]*V,v.Bh[9]=Z[9+h]*V,v.Bh[10]=Z[10+h]*V,v.Bh[11]=Z[11+h]*V,v.Bh[12]=Z[12+h]*V,v.Bh[13]=Z[13+h]*V,v.Bh[14]=Z[14+h]*V,v.Bh[15]=Z[15+h]*V,v.markAsUpdated(),v}static get IdentityReadOnly(){return q._IdentityReadOnly}static FromValuesToRef(Z,h,V,v,A,H,K,d,a,n,x,N,D,k,u,F,b){const o=b.Bh;o[0]=Z,o[1]=h,o[2]=V,o[3]=v,o[4]=A,o[5]=H,o[6]=K,o[7]=d,o[8]=a,o[9]=n,o[10]=x,o[11]=N,o[12]=D,o[13]=k,o[14]=u,o[15]=F,b.markAsUpdated()}static FromValues(Z,h,V,v,A,H,K,d,a,n,x,N,D,k,u,F){const b=new q,o=b.Bh;return o[0]=Z,o[1]=h,o[2]=V,o[3]=v,o[4]=A,o[5]=H,o[6]=K,o[7]=d,o[8]=a,o[9]=n,o[10]=x,o[11]=N,o[12]=D,o[13]=k,o[14]=u,o[15]=F,b.markAsUpdated(),b}static Compose(Z,h,V){const v=new q;return q.ComposeToRef(Z,h,V,v),v}static ComposeToRef(Z,h,V,v){const A=v.Bh,H=h._x,K=h._y,d=h._z,a=h._w,n=H+H,x=K+K,N=d+d,D=H*n,k=H*x,u=H*N,F=K*x,b=K*N,o=d*N,q=a*n,X=a*x,E=a*N,j=Z._x,P=Z._y,C=Z._z;return A[0]=(1-(F+o))*j,A[1]=(k+E)*j,A[2]=(u-X)*j,A[3]=0,A[4]=(k-E)*P,A[5]=(1-(D+o))*P,A[6]=(b+q)*P,A[7]=0,A[8]=(u+X)*C,A[9]=(b-q)*C,A[10]=(1-(D+F))*C,A[11]=0,A[12]=V._x,A[13]=V._y,A[14]=V._z,A[15]=1,v.markAsUpdated(),v}static Identity(){const Z=q.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return Z._updateIdentityStatus(!0),Z}static IdentityToRef(Z){return q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,Z),Z._updateIdentityStatus(!0),Z}static Zero(){const Z=q.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return Z._updateIdentityStatus(!1),Z}static RotationX(Z){const h=new q;return q.RotationXToRef(Z,h),h}static Invert(Z){const h=new q;return Z.invertToRef(h),h}static RotationXToRef(Z,h){const V=Math.sin(Z),v=Math.cos(Z);return q.FromValuesToRef(1,0,0,0,0,v,V,0,0,-V,v,0,0,0,0,1,h),h._updateIdentityStatus(1===v&&0===V),h}static RotationY(Z){const h=new q;return q.RotationYToRef(Z,h),h}static RotationYToRef(Z,h){const V=Math.sin(Z),v=Math.cos(Z);return q.FromValuesToRef(v,0,-V,0,0,1,0,0,V,0,v,0,0,0,0,1,h),h._updateIdentityStatus(1===v&&0===V),h}static RotationZ(Z){const h=new q;return q.RotationZToRef(Z,h),h}static RotationZToRef(Z,h){const V=Math.sin(Z),v=Math.cos(Z);return q.FromValuesToRef(v,V,0,0,-V,v,0,0,0,0,1,0,0,0,0,1,h),h._updateIdentityStatus(1===v&&0===V),h}static RotationAxis(Z,h){const V=new q;return q.RotationAxisToRef(Z,h,V),V}static RotationAxisToRef(Z,h,V){const v=Math.sin(-h),A=Math.cos(-h),H=1-A;Z=Z.normalizeToRef(X.Ch[0]);const K=V.Bh;return K[0]=Z._x*Z._x*H+A,K[1]=Z._x*Z._y*H-Z._z*v,K[2]=Z._x*Z._z*H+Z._y*v,K[3]=0,K[4]=Z._y*Z._x*H+Z._z*v,K[5]=Z._y*Z._y*H+A,K[6]=Z._y*Z._z*H-Z._x*v,K[7]=0,K[8]=Z._z*Z._x*H-Z._y*v,K[9]=Z._z*Z._y*H+Z._x*v,K[10]=Z._z*Z._z*H+A,K[11]=0,K[12]=0,K[13]=0,K[14]=0,K[15]=1,V.markAsUpdated(),V}static RotationAlignToRef(Z,h,V){let A=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const H=F.Dot(h,Z),K=V.Bh;if(H<-1+v.c)K[0]=-1,K[1]=0,K[2]=0,K[3]=0,K[4]=0,K[5]=A?1:-1,K[6]=0,K[7]=0,K[8]=0,K[9]=0,K[10]=A?-1:1,K[11]=0;else{const V=F.Cross(h,Z),v=1/(1+H);K[0]=V._x*V._x*v+H,K[1]=V._y*V._x*v-V._z,K[2]=V._z*V._x*v+V._y,K[3]=0,K[4]=V._x*V._y*v+V._z,K[5]=V._y*V._y*v+H,K[6]=V._z*V._y*v-V._x,K[7]=0,K[8]=V._x*V._z*v-V._y,K[9]=V._y*V._z*v+V._x,K[10]=V._z*V._z*v+H,K[11]=0}return K[12]=0,K[13]=0,K[14]=0,K[15]=1,V.markAsUpdated(),V}static RotationYawPitchRoll(Z,h,V){const v=new q;return q.RotationYawPitchRollToRef(Z,h,V,v),v}static RotationYawPitchRollToRef(Z,h,V,v){return o.RotationYawPitchRollToRef(Z,h,V,X.Quaternion[0]),X.Quaternion[0].toRotationMatrix(v),v}static Scaling(Z,h,V){const v=new q;return q.ScalingToRef(Z,h,V,v),v}static ScalingToRef(Z,h,V,v){return q.FromValuesToRef(Z,0,0,0,0,h,0,0,0,0,V,0,0,0,0,1,v),v._updateIdentityStatus(1===Z&&1===h&&1===V),v}static Translation(Z,h,V){const v=new q;return q.TranslationToRef(Z,h,V,v),v}static TranslationToRef(Z,h,V,v){return q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,Z,h,V,1,v),v._updateIdentityStatus(0===Z&&0===h&&0===V),v}static Lerp(Z,h,V){const v=new q;return q.LerpToRef(Z,h,V,v),v}static LerpToRef(Z,h,V,v){const A=v.Bh,H=Z.m,K=h.m;for(let d=0;d<16;d++)A[d]=H[d]*(1-V)+K[d]*V;return v.markAsUpdated(),v}static DecomposeLerp(Z,h,V){const v=new q;return q.DecomposeLerpToRef(Z,h,V,v),v}static DecomposeLerpToRef(Z,h,V,v){const A=X.Ch[0],H=X.Quaternion[0],K=X.Ch[1];Z.decompose(A,H,K);const d=X.Ch[2],a=X.Quaternion[1],n=X.Ch[3];h.decompose(d,a,n);const x=X.Ch[4];F.LerpToRef(A,d,V,x);const N=X.Quaternion[2];o.SlerpToRef(H,a,V,N);const D=X.Ch[5];return F.LerpToRef(K,n,V,D),q.ComposeToRef(x,N,D,v),v}static LookAtLH(Z,h,V){const v=new q;return q.LookAtLHToRef(Z,h,V,v),v}static LookAtLHToRef(Z,h,V,v){const A=X.Ch[0],H=X.Ch[1],K=X.Ch[2];h.subtractToRef(Z,K),K.normalize(),F.CrossToRef(V,K,A);const d=A.lengthSquared();0===d?A.x=1:A.normalizeFromLength(Math.sqrt(d)),F.CrossToRef(K,A,H),H.normalize();const a=-F.Dot(A,Z),n=-F.Dot(H,Z),x=-F.Dot(K,Z);return q.FromValuesToRef(A._x,H._x,K._x,0,A._y,H._y,K._y,0,A._z,H._z,K._z,0,a,n,x,1,v),v}static LookAtRH(Z,h,V){const v=new q;return q.LookAtRHToRef(Z,h,V,v),v}static LookAtRHToRef(Z,h,V,v){const A=X.Ch[0],H=X.Ch[1],K=X.Ch[2];Z.subtractToRef(h,K),K.normalize(),F.CrossToRef(V,K,A);const d=A.lengthSquared();0===d?A.x=1:A.normalizeFromLength(Math.sqrt(d)),F.CrossToRef(K,A,H),H.normalize();const a=-F.Dot(A,Z),n=-F.Dot(H,Z),x=-F.Dot(K,Z);return q.FromValuesToRef(A._x,H._x,K._x,0,A._y,H._y,K._y,0,A._z,H._z,K._z,0,a,n,x,1,v),v}static LookDirectionLH(Z,h){const V=new q;return q.LookDirectionLHToRef(Z,h,V),V}static LookDirectionLHToRef(Z,h,V){const v=X.Ch[0];v.v(Z),v.scaleInPlace(-1);const A=X.Ch[1];return F.CrossToRef(h,v,A),q.FromValuesToRef(A._x,A._y,A._z,0,h._x,h._y,h._z,0,v._x,v._y,v._z,0,0,0,0,1,V),V}static LookDirectionRH(Z,h){const V=new q;return q.LookDirectionRHToRef(Z,h,V),V}static LookDirectionRHToRef(Z,h,V){const v=X.Ch[2];return F.CrossToRef(h,Z,v),q.FromValuesToRef(v._x,v._y,v._z,0,h._x,h._y,h._z,0,Z._x,Z._y,Z._z,0,0,0,0,1,V),V}static OrthoLH(Z,h,V,v,A){const H=new q;return q.OrthoLHToRef(Z,h,V,v,H,A),H}static OrthoLHToRef(Z,h,V,v,A,H){const K=2/Z,d=2/h,a=2/(v-V),n=-(v+V)/(v-V);return q.FromValuesToRef(K,0,0,0,0,d,0,0,0,0,a,0,0,0,n,1,A),H&&A.multiplyToRef(j,A),A._updateIdentityStatus(1===K&&1===d&&1===a&&0===n),A}static OrthoOffCenterLH(Z,h,V,v,A,H,K){const d=new q;return q.OrthoOffCenterLHToRef(Z,h,V,v,A,H,d,K),d}static OrthoOffCenterLHToRef(Z,h,V,v,A,H,K,d){const a=2/(h-Z),n=2/(v-V),x=2/(H-A),N=-(H+A)/(H-A),D=(Z+h)/(Z-h),k=(v+V)/(V-v);return q.FromValuesToRef(a,0,0,0,0,n,0,0,0,0,x,0,D,k,N,1,K),d&&K.multiplyToRef(j,K),K.markAsUpdated(),K}static ObliqueOffCenterLHToRef(Z,h,V,v,A,H,K,d,a,n,x){const N=-K*Math.cos(d),D=-K*Math.sin(d);return q.TranslationToRef(0,0,-a,X.Matrix[1]),q.FromValuesToRef(1,0,0,0,0,1,0,0,N,D,1,0,0,0,0,1,X.Matrix[0]),X.Matrix[1].multiplyToRef(X.Matrix[0],X.Matrix[0]),q.TranslationToRef(0,0,a,X.Matrix[1]),X.Matrix[0].multiplyToRef(X.Matrix[1],X.Matrix[0]),q.OrthoOffCenterLHToRef(Z,h,V,v,A,H,n,x),X.Matrix[0].multiplyToRef(n,n),n}static OrthoOffCenterRH(Z,h,V,v,A,H,K){const d=new q;return q.OrthoOffCenterRHToRef(Z,h,V,v,A,H,d,K),d}static OrthoOffCenterRHToRef(Z,h,V,v,A,H,K,d){return q.OrthoOffCenterLHToRef(Z,h,V,v,A,H,K,d),K.Bh[10]*=-1,K}static ObliqueOffCenterRHToRef(Z,h,V,v,A,H,K,d,a,n,x){const N=K*Math.cos(d),D=K*Math.sin(d);return q.TranslationToRef(0,0,a,X.Matrix[1]),q.FromValuesToRef(1,0,0,0,0,1,0,0,N,D,1,0,0,0,0,1,X.Matrix[0]),X.Matrix[1].multiplyToRef(X.Matrix[0],X.Matrix[0]),q.TranslationToRef(0,0,-a,X.Matrix[1]),X.Matrix[0].multiplyToRef(X.Matrix[1],X.Matrix[0]),q.OrthoOffCenterRHToRef(Z,h,V,v,A,H,n,x),X.Matrix[0].multiplyToRef(n,n),n}static PerspectiveLH(Z,h,V,v,A){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const K=new q,d=2*V/Z,a=2*V/h,n=(v+V)/(v-V),x=-2*v*V/(v-V),N=Math.tan(H);return q.FromValuesToRef(d,0,0,0,0,a,0,N,0,0,n,1,0,0,x,0,K),A&&K.multiplyToRef(j,K),K._updateIdentityStatus(!1),K}static PerspectiveFovLH(Z,h,V,v,A){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,K=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const d=new q;return q.PerspectiveFovLHToRef(Z,h,V,v,d,!0,A,H,K),d}static PerspectiveFovLHToRef(Z,h,V,v,A){let H=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],K=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,a=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const n=V,x=v,N=1/Math.tan(.5*Z),D=H?N/h:N,k=H?N:N*h,u=a&&0===n?-1:0!==x?(x+n)/(x-n):1,F=a&&0===n?2*x:0!==x?-2*x*n/(x-n):-2*n,b=Math.tan(d);return q.FromValuesToRef(D,0,0,0,0,k,0,b,0,0,u,1,0,0,F,0,A),K&&A.multiplyToRef(j,A),A._updateIdentityStatus(!1),A}static PerspectiveFovReverseLHToRef(Z,h,V,v,A){let H=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],K=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const a=1/Math.tan(.5*Z),n=H?a/h:a,x=H?a:a*h,N=Math.tan(d);return q.FromValuesToRef(n,0,0,0,0,x,0,N,0,0,-V,1,0,0,1,0,A),K&&A.multiplyToRef(j,A),A._updateIdentityStatus(!1),A}static PerspectiveFovRH(Z,h,V,v,A){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,K=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const d=new q;return q.PerspectiveFovRHToRef(Z,h,V,v,d,!0,A,H,K),d}static PerspectiveFovRHToRef(Z,h,V,v,A){let H=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],K=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,a=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const n=V,x=v,N=1/Math.tan(.5*Z),D=H?N/h:N,k=H?N:N*h,u=a&&0===n?1:0!==x?-(x+n)/(x-n):-1,F=a&&0===n?2*x:0!==x?-2*x*n/(x-n):-2*n,b=Math.tan(d);return q.FromValuesToRef(D,0,0,0,0,k,0,b,0,0,u,-1,0,0,F,0,A),K&&A.multiplyToRef(j,A),A._updateIdentityStatus(!1),A}static PerspectiveFovReverseRHToRef(Z,h,V,v,A){let H=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],K=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const a=1/Math.tan(.5*Z),n=H?a/h:a,x=H?a:a*h,N=Math.tan(d);return q.FromValuesToRef(n,0,0,0,0,x,0,N,0,0,-V,-1,0,0,-1,0,A),K&&A.multiplyToRef(j,A),A._updateIdentityStatus(!1),A}static GetFinalMatrix(Z,h,V,v,A,H){const K=Z.width,d=Z.height,a=Z.x,n=Z.y,x=q.FromValues(K/2,0,0,0,0,-d/2,0,0,0,0,H-A,0,a+K/2,d/2+n,A,1),N=new q;return h.multiplyToRef(V,N),N.multiplyToRef(v,N),N.multiplyToRef(x,N)}static GetAsMatrix2x2(Z){const h=Z.m,V=[h[0],h[1],h[4],h[5]];return K.c.MatrixUse64Bits?V:new Float32Array(V)}static GetAsMatrix3x3(Z){const h=Z.m,V=[h[0],h[1],h[2],h[4],h[5],h[6],h[8],h[9],h[10]];return K.c.MatrixUse64Bits?V:new Float32Array(V)}static Transpose(Z){const h=new q;return q.TransposeToRef(Z,h),h}static TransposeToRef(Z,h){const V=Z.m,v=V[0],A=V[4],H=V[8],K=V[12],d=V[1],a=V[5],n=V[9],x=V[13],N=V[2],D=V[6],k=V[10],u=V[14],F=V[3],b=V[7],o=V[11],q=V[15],X=h.Bh;return X[0]=v,X[1]=A,X[2]=H,X[3]=K,X[4]=d,X[5]=a,X[6]=n,X[7]=x,X[8]=N,X[9]=D,X[10]=k,X[11]=u,X[12]=F,X[13]=b,X[14]=o,X[15]=q,h.markAsUpdated(),h._updateIdentityStatus(Z._isIdentity,Z._isIdentityDirty),h}static Reflection(Z){const h=new q;return q.ReflectionToRef(Z,h),h}static ReflectionToRef(Z,h){Z.normalize();const V=Z.normal.x,v=Z.normal.y,A=Z.normal.z,H=-2*V,K=-2*v,d=-2*A;return q.FromValuesToRef(H*V+1,K*V,d*V,0,H*v,K*v+1,d*v,0,H*A,K*A,d*A+1,0,H*Z.d,K*Z.d,d*Z.d,1,h),h}static FromXYZAxesToRef(Z,h,V,v){return q.FromValuesToRef(Z._x,Z._y,Z._z,0,h._x,h._y,h._z,0,V._x,V._y,V._z,0,0,0,0,1,v),v}static FromQuaternionToRef(Z,h){const V=Z._x*Z._x,v=Z._y*Z._y,A=Z._z*Z._z,H=Z._x*Z._y,K=Z._z*Z._w,d=Z._z*Z._x,a=Z._y*Z._w,n=Z._y*Z._z,x=Z._x*Z._w;return h.Bh[0]=1-2*(v+A),h.Bh[1]=2*(H+K),h.Bh[2]=2*(d-a),h.Bh[3]=0,h.Bh[4]=2*(H-K),h.Bh[5]=1-2*(A+V),h.Bh[6]=2*(n+x),h.Bh[7]=0,h.Bh[8]=2*(d+a),h.Bh[9]=2*(n-x),h.Bh[10]=1-2*(v+V),h.Bh[11]=0,h.Bh[12]=0,h.Bh[13]=0,h.Bh[14]=0,h.Bh[15]=1,h.markAsUpdated(),h}}q._IdentityReadOnly=q.Identity(),Object.defineProperties(q.prototype,{dimension:{value:[4,4]},rank:{value:2}});class X{}X.Ch=(0,A.g)(11,F.Zero),X.Matrix=(0,A.g)(2,q.Identity),X.Quaternion=(0,A.g)(3,o.Zero);class E{}E.Vector2=(0,A.g)(3,u.Zero),E.Ch=(0,A.g)(13,F.Zero),E.Vector4=(0,A.g)(3,b.Zero),E.Quaternion=(0,A.g)(3,o.Zero),E.Matrix=(0,A.g)(8,q.Identity),(0,H.i)("BABYLON.Vector2",u),(0,H.i)("BABYLON.Vector3",F),(0,H.i)("BABYLON.Vector4",b),(0,H.i)("BABYLON.Matrix",q);const j=q.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11739:(Z,h,V)=>{function v(Z,h){const V=[];for(let v=0;v<Z;++v)V.push(h());return V}function A(Z,h){return v(Z,h)}V.d(h,{d:()=>v,g:()=>A,k:()=>K});const H=["push","splice","pop","shift","unshift"];function K(Z,h){const V=H.map((V=>function(Z,h,V){const v=Z[h];if("function"!==typeof v)return null;const A=function(){const v=Z.length,H=A.previous.apply(Z,arguments);return V(h,v),H};return v.next=A,A.previous=v,Z[h]=A,()=>{const V=A.previous;if(!V)return;const v=A.next;v?(V.next=v,v.previous=V):(V.next=void 0,Z[h]=V),A.next=void 0,A.previous=void 0}}(Z,V,h)));return()=>{for(const Z of V)null===Z||void 0===Z||Z()}}}}]);