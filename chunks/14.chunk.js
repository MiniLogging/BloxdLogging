"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[14],{12898:(U,G,C)=>{C.d(G,{d:()=>t,h:()=>l,k:()=>L,l:()=>X});const L=1/2.2,X=2.2,l=(1+Math.sqrt(5))/2,t=.001},12911:(U,G,C)=>{function L(U){return parseInt(U.toString().replace(/\W/g,""))}function X(U,G){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(U-G)<=C}function l(U,G,C){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return U<G-L||U>C+L}function t(U,G){return U===G?U:Math.random()*(G-U)+U}function E(U,G,C){return U+(G-U)*C}function K(U,G,C){let L=I(G-U,360);return L>180&&(L-=360),U+L*D(C)}function P(U,G,C){let L=0;return L=U!=G?D((C-U)/(G-U)):0,L}function O(U,G,C,L,X){const l=X*X,t=X*l;return U*(2*t-3*l+1)+C*(-2*t+3*l)+G*(t-2*l+X)+L*(t-l)}function T(U,G,C,L,X){const l=X*X;return 6*(l-X)*U+(3*l-4*X+1)*G+6*(-l+X)*C+(3*l-2*X)*L}function D(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(G,U))}function y(U){return U-=2*Math.PI*Math.floor((U+Math.PI)/(2*Math.PI))}function V(U){const G=U.toString(16);return U<=15?("0"+G).toUpperCase():G.toUpperCase()}function p(U){if(Math.log2)return Math.floor(Math.log2(U));if(U<0)return NaN;if(0===U)return-1/0;let G=0;if(U<1){for(;U<1;)G++,U*=2;G=-G}else if(U>1)for(;U>1;)G++,U=Math.floor(U/2);return G}function I(U,G){return U-Math.floor(U/G)*G}function H(U,G,C){return(U-G)/(C-G)}function x(U,G,C){return U*(C-G)+G}function h(U,G){let C=I(G-U,360);return C>180&&(C-=360),C}function N(U,G){const C=I(U,2*G);return G-Math.abs(C-G)}function b(U,G,C){let L=D(C);return L=-2*L*L*L+3*L*L,G*L+U*(1-L)}function o(U,G,C){let L=0;return L=Math.abs(G-U)<=C?G:U+Math.sign(G-U)*C,L}function w(U,G,C){const L=h(U,G);let X=0;return X=-C<L&&L<C?G:o(U,G=U+L,C),X}function S(U,G,C){return(U-G)/(C-G)}function v(U,G,C){return(C-G)*U+G}function u(U,G){const C=U%G;return 0===C?G:u(G,C)}C.r(G),C.d(G,{Clamp:()=>D,DeltaAngle:()=>h,Denormalize:()=>x,ExtractAsInt:()=>L,Hermite:()=>O,Hermite1stDerivative:()=>T,HighestCommonFactor:()=>u,ILog2:()=>p,InverseLerp:()=>P,Lerp:()=>E,LerpAngle:()=>K,MoveTowards:()=>o,MoveTowardsAngle:()=>w,Normalize:()=>H,NormalizeRadians:()=>y,OutsideRange:()=>l,PercentToRange:()=>v,PingPong:()=>N,RandomRange:()=>t,RangeToPercent:()=>S,Repeat:()=>I,SmoothStep:()=>b,ToHex:()=>V,WithinEpsilon:()=>X})},12896:(U,G,C)=>{C.r(G),C.d(G,{Matrix:()=>x,Quaternion:()=>H,TmpVectors:()=>N,Vector2:()=>V,pG:()=>p,Vector4:()=>I});var L=C(12898),X=C(12907),l=C(12850),t=C(12820),E=C(12763),K=C(12911);class P{}function O(U,G,C){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const X=U.sE(),l=G.sE(),t=X[0],E=X[1],K=X[2],P=X[3],O=X[4],T=X[5],D=X[6],y=X[7],V=X[8],p=X[9],I=X[10],H=X[11],x=X[12],h=X[13],N=X[14],b=X[15],o=l[0],w=l[1],S=l[2],v=l[3],u=l[4],d=l[5],g=l[6],Z=l[7],F=l[8],q=l[9],a=l[10],k=l[11],n=l[12],Q=l[13],mU=l[14],B=l[15];C[L]=t*o+E*u+K*F+P*n,C[L+1]=t*w+E*d+K*q+P*Q,C[L+2]=t*S+E*g+K*a+P*mU,C[L+3]=t*v+E*Z+K*k+P*B,C[L+4]=O*o+T*u+D*F+y*n,C[L+5]=O*w+T*d+D*q+y*Q,C[L+6]=O*S+T*g+D*a+y*mU,C[L+7]=O*v+T*Z+D*k+y*B,C[L+8]=V*o+p*u+I*F+H*n,C[L+9]=V*w+p*d+I*q+H*Q,C[L+10]=V*S+p*g+I*a+H*mU,C[L+11]=V*v+p*Z+I*k+H*B,C[L+12]=x*o+h*u+N*F+b*n,C[L+13]=x*w+h*d+N*q+b*Q,C[L+14]=x*S+h*g+N*a+b*mU,C[L+15]=x*v+h*Z+N*k+b*B}function T(U,G){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const L=U.sE();G[C]=L[0],G[C+1]=L[1],G[C+2]=L[2],G[C+3]=L[3],G[C+4]=L[4],G[C+5]=L[5],G[C+6]=L[6],G[C+7]=L[7],G[C+8]=L[8],G[C+9]=L[9],G[C+10]=L[10],G[C+11]=L[11],G[C+12]=L[12],G[C+13]=L[13],G[C+14]=L[14],G[C+15]=L[15]}function D(U,G){const C=U.sE(),L=C[0],X=C[1],l=C[2],t=C[3],E=C[4],K=C[5],P=C[6],O=C[7],T=C[8],D=C[9],y=C[10],V=C[11],p=C[12],I=C[13],H=C[14],x=C[15],h=y*x-H*V,N=D*x-I*V,b=D*H-I*y,o=T*x-p*V,w=T*H-y*p,S=T*I-p*D,v=+(K*h-P*N+O*b),u=-(E*h-P*o+O*w),d=+(E*N-K*o+O*S),g=-(E*b-K*w+P*S),Z=L*v+X*u+l*d+t*g;if(0===Z)return!1;const F=1/Z,q=P*x-H*O,a=K*x-I*O,k=K*H-I*P,n=E*x-p*O,Q=E*H-p*P,mU=E*I-p*K,B=P*V-y*O,M=K*V-D*O,z=K*y-D*P,s=E*V-T*O,j=E*y-T*P,A=E*D-T*K,Y=-(X*h-l*N+t*b),e=+(L*h-l*o+t*w),i=-(L*N-X*o+t*S),c=+(L*b-X*w+l*S),R=+(X*q-l*a+t*k),W=-(L*q-l*n+t*Q),f=+(L*a-X*n+t*mU),r=-(L*k-X*Q+l*mU),J=-(X*B-l*M+t*z),UU=+(L*B-l*s+t*j),GU=-(L*M-X*s+t*A),CU=+(L*z-X*j+l*A);return G[0]=v*F,G[1]=Y*F,G[2]=R*F,G[3]=J*F,G[4]=u*F,G[5]=e*F,G[6]=W*F,G[7]=UU*F,G[8]=d*F,G[9]=i*F,G[10]=f*F,G[11]=GU*F,G[12]=g*F,G[13]=c*F,G[14]=r*F,G[15]=CU*F,!0}P._UpdateFlagSeed=0;const y=U=>parseInt(U.toString().replace(/\W/g,""));class V{constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=U,this.y=G}toString(){return"{X: ".concat(this.x," Y: ").concat(this.y,"}")}getClassName(){return"Vector2"}getHashCode(){let U=y(this.x);return U=397*U^y(this.y),U}toArray(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U[G]=this.x,U[G+1]=this.y,this}xC(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V.FromArrayToRef(U,G,this),this}sE(){return[this.x,this.y]}L(U){return this.x=U.x,this.y=U.y,this}WE(U,G){return this.x=U,this.y=G,this}set(U,G){return this.WE(U,G)}rE(U){return this.WE(U,U)}add(U){return new V(this.x+U.x,this.y+U.y)}addToRef(U,G){return G.x=this.x+U.x,G.y=this.y+U.y,G}addInPlace(U){return this.x+=U.x,this.y+=U.y,this}addInPlaceFromFloats(U,G){return this.x+=U,this.y+=G,this}addVector3(U){return new V(this.x+U.x,this.y+U.y)}IG(U){return new V(this.x-U.x,this.y-U.y)}subtractToRef(U,G){return G.x=this.x-U.x,G.y=this.y-U.y,G}uT(U){return this.x-=U.x,this.y-=U.y,this}multiplyInPlace(U){return this.x*=U.x,this.y*=U.y,this}multiply(U){return new V(this.x*U.x,this.y*U.y)}multiplyToRef(U,G){return G.x=this.x*U.x,G.y=this.y*U.y,G}multiplyByFloats(U,G){return new V(this.x*U,this.y*G)}divide(U){return new V(this.x/U.x,this.y/U.y)}divideToRef(U,G){return G.x=this.x/U.x,G.y=this.y/U.y,G}divideInPlace(U){return this.x=this.x/U.x,this.y=this.y/U.y,this}minimizeInPlace(U){return this.minimizeInPlaceFromFloats(U.x,U.y)}maximizeInPlace(U){return this.maximizeInPlaceFromFloats(U.x,U.y)}minimizeInPlaceFromFloats(U,G){return this.x=Math.min(U,this.x),this.y=Math.min(G,this.y),this}maximizeInPlaceFromFloats(U,G){return this.x=Math.max(U,this.x),this.y=Math.max(G,this.y),this}subtractFromFloats(U,G){return new V(this.x-U,this.y-G)}subtractFromFloatsToRef(U,G,C){return C.x=this.x-U,C.y=this.y-G,C}negate(){return new V(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(U){return U.x=-this.x,U.y=-this.y,U}scaleInPlace(U){return this.x*=U,this.y*=U,this}scale(U){return new V(this.x*U,this.y*U)}scaleToRef(U,G){return G.x=this.x*U,G.y=this.y*U,G}scaleAndAddToRef(U,G){return G.x+=this.x*U,G.y+=this.y*U,G}equals(U){return U&&this.x===U.x&&this.y===U.y}equalsWithEpsilon(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:L.d;return U&&(0,K.WithinEpsilon)(this.x,U.x,G)&&(0,K.WithinEpsilon)(this.y,U.y,G)}equalsToFloats(U,G){return this.x===U&&this.y===G}floor(){return new V(Math.floor(this.x),Math.floor(this.y))}floorToRef(U){return U.x=Math.floor(this.x),U.y=Math.floor(this.y),U}fract(){return new V(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(U){return U.x=this.x-Math.floor(this.x),U.y=this.y-Math.floor(this.y),U}rotate(U){return this.rotateToRef(U,new V)}rotateToRef(U,G){const C=Math.cos(U),L=Math.sin(U);return G.x=C*this.x-L*this.y,G.y=L*this.x+C*this.y,G}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(U){return 0===U||1===U?this:this.scaleInPlace(1/U)}normalizeToNew(){const U=new V;return this.normalizeToRef(U),U}normalizeToRef(U){const G=this.length();return 0===G&&(U.x=this.x,U.y=this.y),this.scaleToRef(1/G,U)}clone(){return new V(this.x,this.y)}dot(U){return this.x*U.x+this.y*U.y}static Zero(){return new V(0,0)}static One(){return new V(1,1)}static Random(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new V((0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G))}static RandomToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).WE((0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G))}static get ZeroReadOnly(){return V._ZeroReadOnly}static NG(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new V(U[G],U[G+1])}static FromArrayToRef(U,G,C){return C.x=U[G],C.y=U[G+1],C}static FromFloatsToRef(U,G,C){return C.WE(U,G),C}static CatmullRom(U,G,C,L,X){const l=X*X,t=X*l,E=.5*(2*G.x+(-U.x+C.x)*X+(2*U.x-5*G.x+4*C.x-L.x)*l+(-U.x+3*G.x-3*C.x+L.x)*t),K=.5*(2*G.y+(-U.y+C.y)*X+(2*U.y-5*G.y+4*C.y-L.y)*l+(-U.y+3*G.y-3*C.y+L.y)*t);return new V(E,K)}static ClampToRef(U,G,C,L){return L.x=(0,K.Clamp)(U.x,G.x,C.x),L.y=(0,K.Clamp)(U.y,G.y,C.y),L}static Clamp(U,G,C){const L=(0,K.Clamp)(U.x,G.x,C.x),X=(0,K.Clamp)(U.y,G.y,C.y);return new V(L,X)}static Hermite(U,G,C,L,X){const l=X*X,t=X*l,E=2*t-3*l+1,K=-2*t+3*l,P=t-2*l+X,O=t-l,T=U.x*E+C.x*K+G.x*P+L.x*O,D=U.y*E+C.y*K+G.y*P+L.y*O;return new V(T,D)}static Hermite1stDerivative(U,G,C,L,X){return this.Hermite1stDerivativeToRef(U,G,C,L,X,new V)}static Hermite1stDerivativeToRef(U,G,C,L,X,l){const t=X*X;return l.x=6*(t-X)*U.x+(3*t-4*X+1)*G.x+6*(-t+X)*C.x+(3*t-2*X)*L.x,l.y=6*(t-X)*U.y+(3*t-4*X+1)*G.y+6*(-t+X)*C.y+(3*t-2*X)*L.y,l}static Lerp(U,G,C){return V.LerpToRef(U,G,C,new V)}static LerpToRef(U,G,C,L){return L.x=U.x+(G.x-U.x)*C,L.y=U.y+(G.y-U.y)*C,L}static Dot(U,G){return U.x*G.x+U.y*G.y}static Normalize(U){return V.NormalizeToRef(U,new V)}static NormalizeToRef(U,G){return U.normalizeToRef(G),G}static Minimize(U,G){const C=U.x<G.x?U.x:G.x,L=U.y<G.y?U.y:G.y;return new V(C,L)}static Maximize(U,G){const C=U.x>G.x?U.x:G.x,L=U.y>G.y?U.y:G.y;return new V(C,L)}static Transform(U,G){return V.TransformToRef(U,G,new V)}static TransformToRef(U,G,C){const L=G.m,X=U.x*L[0]+U.y*L[4]+L[12],l=U.x*L[1]+U.y*L[5]+L[13];return C.x=X,C.y=l,C}static PointInTriangle(U,G,C,L){const X=.5*(-C.y*L.x+G.y*(-C.x+L.x)+G.x*(C.y-L.y)+C.x*L.y),l=X<0?-1:1,t=(G.y*L.x-G.x*L.y+(L.y-G.y)*U.x+(G.x-L.x)*U.y)*l,E=(G.x*C.y-G.y*C.x+(G.y-C.y)*U.x+(C.x-G.x)*U.y)*l;return t>0&&E>0&&t+E<2*X*l}static Distance(U,G){return Math.sqrt(V.DistanceSquared(U,G))}static DistanceSquared(U,G){const C=U.x-G.x,L=U.y-G.y;return C*C+L*L}static Center(U,G){return V.CenterToRef(U,G,new V)}static CenterToRef(U,G,C){return C.WE((U.x+G.x)/2,(U.y+G.y)/2)}static DistanceOfPointFromSegment(U,G,C){const L=V.DistanceSquared(G,C);if(0===L)return V.Distance(U,G);const X=C.IG(G),l=Math.max(0,Math.min(1,V.Dot(U.IG(G),X)/L)),t=G.add(X.multiplyByFloats(l,l));return V.Distance(U,t)}}V._V8PerformanceHack=new V(.5,.5),V._ZeroReadOnly=V.Zero(),Object.defineProperties(V.prototype,{dimension:{value:[2]},rank:{value:1}});class p{get x(){return this._x}set x(U){this._x=U,this._isDirty=!0}get y(){return this._y}set y(U){this._y=U,this._isDirty=!0}get z(){return this._z}set z(U){this._z=U,this._isDirty=!0}constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=U,this._y=G,this._z=C}toString(){return"{X: ".concat(this._x," Y: ").concat(this._y," Z: ").concat(this._z,"}")}getClassName(){return"pG"}getHashCode(){let U=y(this._x);return U=397*U^y(this._y),U=397*U^y(this._z),U}sE(){return[this._x,this._y,this._z]}toArray(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U[G]=this._x,U[G+1]=this._y,U[G+2]=this._z,this}xC(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p.FromArrayToRef(U,G,this),this}toQuaternion(){return H.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(U){return this._x+=U._x,this._y+=U._y,this._z+=U._z,this._isDirty=!0,this}addInPlaceFromFloats(U,G,C){return this._x+=U,this._y+=G,this._z+=C,this._isDirty=!0,this}add(U){return new p(this._x+U._x,this._y+U._y,this._z+U._z)}addToRef(U,G){return G._x=this._x+U._x,G._y=this._y+U._y,G._z=this._z+U._z,G._isDirty=!0,G}uT(U){return this._x-=U._x,this._y-=U._y,this._z-=U._z,this._isDirty=!0,this}IG(U){return new p(this._x-U._x,this._y-U._y,this._z-U._z)}subtractToRef(U,G){return this.subtractFromFloatsToRef(U._x,U._y,U._z,G)}subtractFromFloats(U,G,C){return new p(this._x-U,this._y-G,this._z-C)}subtractFromFloatsToRef(U,G,C,L){return L._x=this._x-U,L._y=this._y-G,L._z=this._z-C,L._isDirty=!0,L}negate(){return new p(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(U){return U._x=-1*this._x,U._y=-1*this._y,U._z=-1*this._z,U._isDirty=!0,U}scaleInPlace(U){return this._x*=U,this._y*=U,this._z*=U,this._isDirty=!0,this}scale(U){return new p(this._x*U,this._y*U,this._z*U)}scaleToRef(U,G){return G._x=this._x*U,G._y=this._y*U,G._z=this._z*U,G._isDirty=!0,G}getNormalToRef(U){const G=this.length();let C=Math.acos(this._y/G);const L=Math.atan2(this._z,this._x);C>Math.PI/2?C-=Math.PI/2:C+=Math.PI/2;const X=G*Math.sin(C)*Math.cos(L),l=G*Math.cos(C),t=G*Math.sin(C)*Math.sin(L);return U.set(X,l,t),U}applyRotationQuaternionToRef(U,G){const C=this._x,L=this._y,X=this._z,l=U._x,t=U._y,E=U._z,K=U._w,P=2*(t*X-E*L),O=2*(E*C-l*X),T=2*(l*L-t*C);return G._x=C+K*P+t*T-E*O,G._y=L+K*O+E*P-l*T,G._z=X+K*T+l*O-t*P,G._isDirty=!0,G}applyRotationQuaternionInPlace(U){return this.applyRotationQuaternionToRef(U,this)}applyRotationQuaternion(U){return this.applyRotationQuaternionToRef(U,new p)}scaleAndAddToRef(U,G){return G._x+=this._x*U,G._y+=this._y*U,G._z+=this._z*U,G._isDirty=!0,G}projectOnPlane(U,G){return this.projectOnPlaneToRef(U,G,new p)}projectOnPlaneToRef(U,G,C){const L=U.normal,X=U.d,l=h.pG[0];this.subtractToRef(G,l),l.normalize();const t=p.Dot(l,L);if(Math.abs(t)<1e-10)C.rE(1/0);else{const U=-(p.Dot(G,L)+X)/t,E=l.scaleInPlace(U);G.addToRef(E,C)}return C}equals(U){return U&&this._x===U._x&&this._y===U._y&&this._z===U._z}equalsWithEpsilon(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:L.d;return U&&(0,K.WithinEpsilon)(this._x,U._x,G)&&(0,K.WithinEpsilon)(this._y,U._y,G)&&(0,K.WithinEpsilon)(this._z,U._z,G)}equalsToFloats(U,G,C){return this._x===U&&this._y===G&&this._z===C}multiplyInPlace(U){return this._x*=U._x,this._y*=U._y,this._z*=U._z,this._isDirty=!0,this}multiply(U){return this.multiplyByFloats(U._x,U._y,U._z)}multiplyToRef(U,G){return G._x=this._x*U._x,G._y=this._y*U._y,G._z=this._z*U._z,G._isDirty=!0,G}multiplyByFloats(U,G,C){return new p(this._x*U,this._y*G,this._z*C)}divide(U){return new p(this._x/U._x,this._y/U._y,this._z/U._z)}divideToRef(U,G){return G._x=this._x/U._x,G._y=this._y/U._y,G._z=this._z/U._z,G._isDirty=!0,G}divideInPlace(U){return this._x=this._x/U._x,this._y=this._y/U._y,this._z=this._z/U._z,this._isDirty=!0,this}minimizeInPlace(U){return this.minimizeInPlaceFromFloats(U._x,U._y,U._z)}maximizeInPlace(U){return this.maximizeInPlaceFromFloats(U._x,U._y,U._z)}minimizeInPlaceFromFloats(U,G,C){return U<this._x&&(this.x=U),G<this._y&&(this.y=G),C<this._z&&(this.z=C),this}maximizeInPlaceFromFloats(U,G,C){return U>this._x&&(this.x=U),G>this._y&&(this.y=G),C>this._z&&(this.z=C),this}isNonUniformWithinEpsilon(U){const G=Math.abs(this._x),C=Math.abs(this._y);if(!(0,K.WithinEpsilon)(G,C,U))return!0;const L=Math.abs(this._z);return!(0,K.WithinEpsilon)(G,L,U)||!(0,K.WithinEpsilon)(C,L,U)}get isNonUniform(){const U=Math.abs(this._x);if(U!==Math.abs(this._y))return!0;return U!==Math.abs(this._z)}floorToRef(U){return U._x=Math.floor(this._x),U._y=Math.floor(this._y),U._z=Math.floor(this._z),U._isDirty=!0,U}floor(){return new p(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(U){return U._x=this._x-Math.floor(this._x),U._y=this._y-Math.floor(this._y),U._z=this._z-Math.floor(this._z),U._isDirty=!0,U}fract(){return new p(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(U){if("xyz"===(U=U.toLowerCase()))return this;const G=h.pG[0].L(this);return this.x=G[U[0]],this.y=G[U[1]],this.z=G[U[2]],this}rotateByQuaternionToRef(U,G){return U.toRotationMatrix(h.Matrix[0]),p.TransformCoordinatesToRef(this,h.Matrix[0],G),G}rotateByQuaternionAroundPointToRef(U,G,C){return this.subtractToRef(G,h.pG[0]),h.pG[0].rotateByQuaternionToRef(U,h.pG[0]),G.addToRef(h.pG[0],C),C}cross(U){return p.CrossToRef(this,U,new p)}normalizeFromLength(U){return 0===U||1===U?this:this.scaleInPlace(1/U)}normalizeToNew(){return this.normalizeToRef(new p)}normalizeToRef(U){const G=this.length();return 0===G||1===G?(U._x=this._x,U._y=this._y,U._z=this._z,U._isDirty=!0,U):this.scaleToRef(1/G,U)}clone(){return new p(this._x,this._y,this._z)}L(U){return this.WE(U._x,U._y,U._z)}WE(U,G,C){return this._x=U,this._y=G,this._z=C,this._isDirty=!0,this}set(U,G,C){return this.WE(U,G,C)}rE(U){return this._x=this._y=this._z=U,this._isDirty=!0,this}static GetClipFactor(U,G,C,L){const X=p.Dot(U,C);return(X-L)/(X-p.Dot(G,C))}static GetAngleBetweenVectors(U,G,C){const L=U.normalizeToRef(h.pG[1]),X=G.normalizeToRef(h.pG[2]);let l=p.Dot(L,X);l=(0,K.Clamp)(l,-1,1);const t=Math.acos(l),E=h.pG[3];return p.CrossToRef(L,X,E),p.Dot(E,C)>0?isNaN(t)?0:t:isNaN(t)?-Math.PI:-Math.acos(l)}static GetAngleBetweenVectorsOnPlane(U,G,C){h.pG[0].L(U);const L=h.pG[0];h.pG[1].L(G);const X=h.pG[1];h.pG[2].L(C);const l=h.pG[2],t=h.pG[3],E=h.pG[4];L.normalize(),X.normalize(),l.normalize(),p.CrossToRef(l,L,t),p.CrossToRef(t,l,E);const P=Math.atan2(p.Dot(X,t),p.Dot(X,E));return(0,K.NormalizeRadians)(P)}static PitchYawRollToMoveBetweenPointsToRef(U,G,C){const L=N.pG[0];return G.subtractToRef(U,L),C._y=Math.atan2(L.x,L.z)||0,C._x=Math.atan2(Math.sqrt(L.x**2+L.z**2),L.y)||0,C._z=0,C._isDirty=!0,C}static PitchYawRollToMoveBetweenPoints(U,G){const C=p.Zero();return p.PitchYawRollToMoveBetweenPointsToRef(U,G,C)}static SlerpToRef(U,G,C,X){C=(0,K.Clamp)(C,0,1);const l=h.pG[0],t=h.pG[1];l.L(U);const E=l.length();l.normalizeFromLength(E),t.L(G);const P=t.length();t.normalizeFromLength(P);const O=p.Dot(l,t);let T,D;if(O<1-L.d){const U=Math.acos(O),G=1/Math.sin(U);T=Math.sin((1-C)*U)*G,D=Math.sin(C*U)*G}else T=1-C,D=C;return l.scaleInPlace(T),t.scaleInPlace(D),X.L(l).addInPlace(t),X.scaleInPlace((0,K.Lerp)(E,P,C)),X}static SmoothToRef(U,G,C,L,X){return p.SlerpToRef(U,G,0===L?1:C/L,X),X}static NG(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new p(U[G],U[G+1],U[G+2])}static FromFloatArray(U,G){return p.NG(U,G)}static FromArrayToRef(U,G,C){return C._x=U[G],C._y=U[G+1],C._z=U[G+2],C._isDirty=!0,C}static FromFloatArrayToRef(U,G,C){return p.FromArrayToRef(U,G,C)}static FromFloatsToRef(U,G,C,L){return L.WE(U,G,C),L}static Zero(){return new p(0,0,0)}static One(){return new p(1,1,1)}static Up(){return new p(0,1,0)}static get UpReadOnly(){return p._UpReadOnly}static get DownReadOnly(){return p._DownReadOnly}static get RightReadOnly(){return p._RightReadOnly}static get LeftReadOnly(){return p._LeftReadOnly}static get LeftHandedForwardReadOnly(){return p._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return p._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return p._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return p._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return p._ZeroReadOnly}static get OneReadOnly(){return p._OneReadOnly}static Down(){return new p(0,-1,0)}static Forward(){return new p(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new p(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new p(1,0,0)}static Left(){return new p(-1,0,0)}static Random(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new p((0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G))}static RandomToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).WE((0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G))}static TransformCoordinates(U,G){const C=p.Zero();return p.TransformCoordinatesToRef(U,G,C),C}static TransformCoordinatesToRef(U,G,C){return p.TransformCoordinatesFromFloatsToRef(U._x,U._y,U._z,G,C),C}static TransformCoordinatesFromFloatsToRef(U,G,C,L,X){const l=L.m,t=U*l[0]+G*l[4]+C*l[8]+l[12],E=U*l[1]+G*l[5]+C*l[9]+l[13],K=U*l[2]+G*l[6]+C*l[10]+l[14],P=1/(U*l[3]+G*l[7]+C*l[11]+l[15]);return X._x=t*P,X._y=E*P,X._z=K*P,X._isDirty=!0,X}static TransformNormal(U,G){const C=p.Zero();return p.TransformNormalToRef(U,G,C),C}static TransformNormalToRef(U,G,C){return this.TransformNormalFromFloatsToRef(U._x,U._y,U._z,G,C),C}static TransformNormalFromFloatsToRef(U,G,C,L,X){const l=L.m;return X._x=U*l[0]+G*l[4]+C*l[8],X._y=U*l[1]+G*l[5]+C*l[9],X._z=U*l[2]+G*l[6]+C*l[10],X._isDirty=!0,X}static CatmullRom(U,G,C,L,X){const l=X*X,t=X*l,E=.5*(2*G._x+(-U._x+C._x)*X+(2*U._x-5*G._x+4*C._x-L._x)*l+(-U._x+3*G._x-3*C._x+L._x)*t),K=.5*(2*G._y+(-U._y+C._y)*X+(2*U._y-5*G._y+4*C._y-L._y)*l+(-U._y+3*G._y-3*C._y+L._y)*t),P=.5*(2*G._z+(-U._z+C._z)*X+(2*U._z-5*G._z+4*C._z-L._z)*l+(-U._z+3*G._z-3*C._z+L._z)*t);return new p(E,K,P)}static Clamp(U,G,C){const L=new p;return p.ClampToRef(U,G,C,L),L}static ClampToRef(U,G,C,L){let X=U._x;X=X>C._x?C._x:X,X=X<G._x?G._x:X;let l=U._y;l=l>C._y?C._y:l,l=l<G._y?G._y:l;let t=U._z;return t=t>C._z?C._z:t,t=t<G._z?G._z:t,L.WE(X,l,t),L}static CheckExtends(U,G,C){G.minimizeInPlace(U),C.maximizeInPlace(U)}static Hermite(U,G,C,L,X){const l=X*X,t=X*l,E=2*t-3*l+1,K=-2*t+3*l,P=t-2*l+X,O=t-l,T=U._x*E+C._x*K+G._x*P+L._x*O,D=U._y*E+C._y*K+G._y*P+L._y*O,y=U._z*E+C._z*K+G._z*P+L._z*O;return new p(T,D,y)}static Hermite1stDerivative(U,G,C,L,X){const l=new p;return this.Hermite1stDerivativeToRef(U,G,C,L,X,l),l}static Hermite1stDerivativeToRef(U,G,C,L,X,l){const t=X*X;return l._x=6*(t-X)*U._x+(3*t-4*X+1)*G._x+6*(-t+X)*C._x+(3*t-2*X)*L._x,l._y=6*(t-X)*U._y+(3*t-4*X+1)*G._y+6*(-t+X)*C._y+(3*t-2*X)*L._y,l._z=6*(t-X)*U._z+(3*t-4*X+1)*G._z+6*(-t+X)*C._z+(3*t-2*X)*L._z,l._isDirty=!0,l}static Lerp(U,G,C){const L=new p(0,0,0);return p.LerpToRef(U,G,C,L),L}static LerpToRef(U,G,C,L){return L._x=U._x+(G._x-U._x)*C,L._y=U._y+(G._y-U._y)*C,L._z=U._z+(G._z-U._z)*C,L._isDirty=!0,L}static Dot(U,G){return U._x*G._x+U._y*G._y+U._z*G._z}dot(U){return this._x*U._x+this._y*U._y+this._z*U._z}static Cross(U,G){const C=new p;return p.CrossToRef(U,G,C),C}static CrossToRef(U,G,C){const L=U._y*G._z-U._z*G._y,X=U._z*G._x-U._x*G._z,l=U._x*G._y-U._y*G._x;return C.WE(L,X,l),C}static Normalize(U){const G=p.Zero();return p.NormalizeToRef(U,G),G}static NormalizeToRef(U,G){return U.normalizeToRef(G),G}static Project(U,G,C,L){const X=new p;return p.ProjectToRef(U,G,C,L,X),X}static ProjectToRef(U,G,C,L,X){var l;const t=L.width,K=L.height,P=L.x,O=L.y,T=h.Matrix[1],D=null===(l=E.d.LastCreatedEngine)||void 0===l?void 0:l.isNDCHalfZRange,y=D?1:.5,V=D?0:.5;x.FromValuesToRef(t/2,0,0,0,0,-K/2,0,0,0,0,y,0,P+t/2,K/2+O,V,1,T);const I=h.Matrix[0];return G.multiplyToRef(C,I),I.multiplyToRef(T,I),p.TransformCoordinatesToRef(U,I,X),X}static Reflect(U,G){return this.ReflectToRef(U,G,new p)}static ReflectToRef(U,G,C){const L=N.pG[0];return L.L(G).scaleInPlace(2*p.Dot(U,G)),C.L(U).uT(L)}static _UnprojectFromInvertedMatrixToRef(U,G,C){p.TransformCoordinatesToRef(U,G,C);const L=G.m,X=U._x*L[3]+U._y*L[7]+U._z*L[11]+L[15];return(0,K.WithinEpsilon)(X,1)&&C.scaleInPlace(1/X),C}static UnprojectFromTransform(U,G,C,L,X){return this.Unproject(U,G,C,L,X,x.IdentityReadOnly)}static Unproject(U,G,C,L,X,l){const t=new p;return p.UnprojectToRef(U,G,C,L,X,l,t),t}static UnprojectToRef(U,G,C,L,X,l,t){return p.UnprojectFloatsToRef(U._x,U._y,U._z,G,C,L,X,l,t),t}static UnprojectFloatsToRef(U,G,C,L,X,l,t,K,P){var O;const T=h.Matrix[0];l.multiplyToRef(t,T),T.multiplyToRef(K,T),T.invert();const D=h.pG[0];return D.x=U/L*2-1,D.y=-(G/X*2-1),null!==(O=E.d.LastCreatedEngine)&&void 0!==O&&O.isNDCHalfZRange?D.z=C:D.z=2*C-1,p._UnprojectFromInvertedMatrixToRef(D,T,P),P}static Minimize(U,G){const C=new p;return C.L(U),C.minimizeInPlace(G),C}static Maximize(U,G){const C=new p;return C.L(U),C.maximizeInPlace(G),C}static Distance(U,G){return Math.sqrt(p.DistanceSquared(U,G))}static DistanceSquared(U,G){const C=U._x-G._x,L=U._y-G._y,X=U._z-G._z;return C*C+L*L+X*X}static ProjectOnTriangleToRef(U,G,C,X,l){const t=h.pG[0],E=h.pG[1],P=h.pG[2],O=h.pG[3],T=h.pG[4];C.subtractToRef(G,t),X.subtractToRef(G,E),X.subtractToRef(C,P);const D=t.length(),y=E.length(),V=P.length();if(D<L.d||y<L.d||V<L.d)return l.L(G),p.Distance(U,G);U.subtractToRef(G,T),p.CrossToRef(t,E,O);const I=O.length();if(I<L.d)return l.L(G),p.Distance(U,G);O.normalizeFromLength(I);let H=T.length();if(H<L.d)return l.L(G),0;T.normalizeFromLength(H);const x=p.Dot(O,T),N=h.pG[5],b=h.pG[6];N.L(O).scaleInPlace(-H*x),b.L(U).addInPlace(N);const o=h.pG[4],w=h.pG[5],S=h.pG[7],v=h.pG[8];o.L(t).scaleInPlace(1/D),v.L(E).scaleInPlace(1/y),o.addInPlace(v).scaleInPlace(-1),w.L(t).scaleInPlace(-1/D),v.L(P).scaleInPlace(1/V),w.addInPlace(v).scaleInPlace(-1),S.L(P).scaleInPlace(-1/V),v.L(E).scaleInPlace(-1/y),S.addInPlace(v).scaleInPlace(-1);const u=h.pG[9];let d;u.L(b).uT(G),p.CrossToRef(o,u,v),d=p.Dot(v,O);const g=d;u.L(b).uT(C),p.CrossToRef(w,u,v),d=p.Dot(v,O);const Z=d;u.L(b).uT(X),p.CrossToRef(S,u,v),d=p.Dot(v,O);const F=d,q=h.pG[10];let a,k;g>0&&Z<0?(q.L(t),a=G,k=C):Z>0&&F<0?(q.L(P),a=C,k=X):(q.L(E).scaleInPlace(-1),a=X,k=G);const n=h.pG[9],Q=h.pG[4];a.subtractToRef(b,v),k.subtractToRef(b,n),p.CrossToRef(v,n,Q);if(!(p.Dot(Q,O)<0))return l.L(b),Math.abs(H*x);const mU=h.pG[5];p.CrossToRef(q,Q,mU),mU.normalize();const B=h.pG[9];B.L(a).uT(b);const M=B.length();if(M<L.d)return l.L(a),p.Distance(U,a);B.normalizeFromLength(M);const z=p.Dot(mU,B),s=h.pG[7];s.L(b).addInPlace(mU.scaleInPlace(M*z)),v.L(s).uT(a),H=q.length(),q.normalizeFromLength(H);let j=p.Dot(v,q)/Math.max(H,L.d);return j=(0,K.Clamp)(j,0,1),s.L(a).addInPlace(q.scaleInPlace(j*H)),l.L(s),p.Distance(U,s)}static Center(U,G){return p.CenterToRef(U,G,p.Zero())}static CenterToRef(U,G,C){return C.WE((U._x+G._x)/2,(U._y+G._y)/2,(U._z+G._z)/2)}static RotationFromAxis(U,G,C){const L=new p;return p.RotationFromAxisToRef(U,G,C,L),L}static RotationFromAxisToRef(U,G,C,L){const X=h.Quaternion[0];return H.RotationQuaternionFromAxisToRef(U,G,C,X),X.toEulerAnglesToRef(L),L}}p._V8PerformanceHack=new p(.5,.5,.5),p._UpReadOnly=p.Up(),p._DownReadOnly=p.Down(),p._LeftHandedForwardReadOnly=p.Forward(!1),p._RightHandedForwardReadOnly=p.Forward(!0),p._LeftHandedBackwardReadOnly=p.Backward(!1),p._RightHandedBackwardReadOnly=p.Backward(!0),p._RightReadOnly=p.Right(),p._LeftReadOnly=p.Left(),p._ZeroReadOnly=p.Zero(),p._OneReadOnly=p.One(),Object.defineProperties(p.prototype,{dimension:{value:[3]},rank:{value:1}});class I{get x(){return this._x}set x(U){this._x=U,this._isDirty=!0}get y(){return this._y}set y(U){this._y=U,this._isDirty=!0}get z(){return this._z}set z(U){this._z=U,this._isDirty=!0}get w(){return this._w}set w(U){this._w=U,this._isDirty=!0}constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=U,this._y=G,this._z=C,this._w=L}toString(){return"{X: ".concat(this._x," Y: ").concat(this._y," Z: ").concat(this._z," W: ").concat(this._w,"}")}getClassName(){return"Vector4"}getHashCode(){let U=y(this._x);return U=397*U^y(this._y),U=397*U^y(this._z),U=397*U^y(this._w),U}sE(){return[this._x,this._y,this._z,this._w]}toArray(U,G){return void 0===G&&(G=0),U[G]=this._x,U[G+1]=this._y,U[G+2]=this._z,U[G+3]=this._w,this}xC(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I.FromArrayToRef(U,G,this),this}addInPlace(U){return this.x+=U._x,this.y+=U._y,this.z+=U._z,this.w+=U._w,this}addInPlaceFromFloats(U,G,C,L){return this.x+=U,this.y+=G,this.z+=C,this.w+=L,this}add(U){return new I(this._x+U.x,this._y+U.y,this._z+U.z,this._w+U.w)}addToRef(U,G){return G.x=this._x+U.x,G.y=this._y+U.y,G.z=this._z+U.z,G.w=this._w+U.w,G}uT(U){return this.x-=U.x,this.y-=U.y,this.z-=U.z,this.w-=U.w,this}IG(U){return new I(this._x-U.x,this._y-U.y,this._z-U.z,this._w-U.w)}subtractToRef(U,G){return G.x=this._x-U.x,G.y=this._y-U.y,G.z=this._z-U.z,G.w=this._w-U.w,G}subtractFromFloats(U,G,C,L){return new I(this._x-U,this._y-G,this._z-C,this._w-L)}subtractFromFloatsToRef(U,G,C,L,X){return X.x=this._x-U,X.y=this._y-G,X.z=this._z-C,X.w=this._w-L,X}negate(){return new I(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(U){return U.x=-this._x,U.y=-this._y,U.z=-this._z,U.w=-this._w,U}scaleInPlace(U){return this.x*=U,this.y*=U,this.z*=U,this.w*=U,this}scale(U){return new I(this._x*U,this._y*U,this._z*U,this._w*U)}scaleToRef(U,G){return G.x=this._x*U,G.y=this._y*U,G.z=this._z*U,G.w=this._w*U,G}scaleAndAddToRef(U,G){return G.x+=this._x*U,G.y+=this._y*U,G.z+=this._z*U,G.w+=this._w*U,G}equals(U){return U&&this._x===U.x&&this._y===U.y&&this._z===U.z&&this._w===U.w}equalsWithEpsilon(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:L.d;return U&&(0,K.WithinEpsilon)(this._x,U.x,G)&&(0,K.WithinEpsilon)(this._y,U.y,G)&&(0,K.WithinEpsilon)(this._z,U.z,G)&&(0,K.WithinEpsilon)(this._w,U.w,G)}equalsToFloats(U,G,C,L){return this._x===U&&this._y===G&&this._z===C&&this._w===L}multiplyInPlace(U){return this.x*=U.x,this.y*=U.y,this.z*=U.z,this.w*=U.w,this}multiply(U){return new I(this._x*U.x,this._y*U.y,this._z*U.z,this._w*U.w)}multiplyToRef(U,G){return G.x=this._x*U.x,G.y=this._y*U.y,G.z=this._z*U.z,G.w=this._w*U.w,G}multiplyByFloats(U,G,C,L){return new I(this._x*U,this._y*G,this._z*C,this._w*L)}divide(U){return new I(this._x/U.x,this._y/U.y,this._z/U.z,this._w/U.w)}divideToRef(U,G){return G.x=this._x/U.x,G.y=this._y/U.y,G.z=this._z/U.z,G.w=this._w/U.w,G}divideInPlace(U){return this.divideToRef(U,this)}minimizeInPlace(U){return U.x<this._x&&(this.x=U.x),U.y<this._y&&(this.y=U.y),U.z<this._z&&(this.z=U.z),U.w<this._w&&(this.w=U.w),this}maximizeInPlace(U){return U.x>this._x&&(this.x=U.x),U.y>this._y&&(this.y=U.y),U.z>this._z&&(this.z=U.z),U.w>this._w&&(this.w=U.w),this}minimizeInPlaceFromFloats(U,G,C,L){return this.x=Math.min(U,this._x),this.y=Math.min(G,this._y),this.z=Math.min(C,this._z),this.w=Math.min(L,this._w),this}maximizeInPlaceFromFloats(U,G,C,L){return this.x=Math.max(U,this._x),this.y=Math.max(G,this._y),this.z=Math.max(C,this._z),this.w=Math.max(L,this._w),this}floorToRef(U){return U.x=Math.floor(this._x),U.y=Math.floor(this._y),U.z=Math.floor(this._z),U.w=Math.floor(this._w),U}floor(){return new I(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(U){return U.x=this._x-Math.floor(this._x),U.y=this._y-Math.floor(this._y),U.z=this._z-Math.floor(this._z),U.w=this._w-Math.floor(this._w),U}fract(){return new I(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(U){return 0===U||1===U?this:this.scaleInPlace(1/U)}normalizeToNew(){return this.normalizeToRef(new I)}normalizeToRef(U){const G=this.length();return 0===G||1===G?(U.x=this._x,U.y=this._y,U.z=this._z,U.w=this._w,U):this.scaleToRef(1/G,U)}toVector3(){return new p(this._x,this._y,this._z)}clone(){return new I(this._x,this._y,this._z,this._w)}L(U){return this.x=U.x,this.y=U.y,this.z=U.z,this.w=U.w,this}WE(U,G,C,L){return this.x=U,this.y=G,this.z=C,this.w=L,this}set(U,G,C,L){return this.WE(U,G,C,L)}rE(U){return this.x=this.y=this.z=this.w=U,this}dot(U){return this._x*U.x+this._y*U.y+this._z*U.z+this._w*U.w}static NG(U,G){return G||(G=0),new I(U[G],U[G+1],U[G+2],U[G+3])}static FromArrayToRef(U,G,C){return C.x=U[G],C.y=U[G+1],C.z=U[G+2],C.w=U[G+3],C}static FromFloatArrayToRef(U,G,C){return I.FromArrayToRef(U,G,C),C}static FromFloatsToRef(U,G,C,L,X){return X.x=U,X.y=G,X.z=C,X.w=L,X}static Zero(){return new I(0,0,0,0)}static One(){return new I(1,1,1,1)}static Random(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new I((0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G))}static RandomToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.x=(0,K.RandomRange)(U,G),C.y=(0,K.RandomRange)(U,G),C.z=(0,K.RandomRange)(U,G),C.w=(0,K.RandomRange)(U,G),C}static Clamp(U,G,C){return I.ClampToRef(U,G,C,new I)}static ClampToRef(U,G,C,L){return L.x=(0,K.Clamp)(U.x,G.x,C.x),L.y=(0,K.Clamp)(U.y,G.y,C.y),L.z=(0,K.Clamp)(U.z,G.z,C.z),L.w=(0,K.Clamp)(U.w,G.w,C.w),L}static CheckExtends(U,G,C){G.minimizeInPlace(U),C.maximizeInPlace(U)}static get ZeroReadOnly(){return I._ZeroReadOnly}static Normalize(U){return I.NormalizeToRef(U,new I)}static NormalizeToRef(U,G){return U.normalizeToRef(G),G}static Minimize(U,G){const C=new I;return C.L(U),C.minimizeInPlace(G),C}static Maximize(U,G){const C=new I;return C.L(U),C.maximizeInPlace(G),C}static Distance(U,G){return Math.sqrt(I.DistanceSquared(U,G))}static DistanceSquared(U,G){const C=U.x-G.x,L=U.y-G.y,X=U.z-G.z,l=U.w-G.w;return C*C+L*L+X*X+l*l}static Center(U,G){return I.CenterToRef(U,G,new I)}static CenterToRef(U,G,C){return C.x=(U.x+G.x)/2,C.y=(U.y+G.y)/2,C.z=(U.z+G.z)/2,C.w=(U.w+G.w)/2,C}static TransformCoordinates(U,G){return I.TransformCoordinatesToRef(U,G,new I)}static TransformCoordinatesToRef(U,G,C){return I.TransformCoordinatesFromFloatsToRef(U._x,U._y,U._z,G,C),C}static TransformCoordinatesFromFloatsToRef(U,G,C,L,X){const l=L.m,t=U*l[0]+G*l[4]+C*l[8]+l[12],E=U*l[1]+G*l[5]+C*l[9]+l[13],K=U*l[2]+G*l[6]+C*l[10]+l[14],P=U*l[3]+G*l[7]+C*l[11]+l[15];return X.x=t,X.y=E,X.z=K,X.w=P,X}static TransformNormal(U,G){return I.TransformNormalToRef(U,G,new I)}static TransformNormalToRef(U,G,C){const L=G.m,X=U.x*L[0]+U.y*L[4]+U.z*L[8],l=U.x*L[1]+U.y*L[5]+U.z*L[9],t=U.x*L[2]+U.y*L[6]+U.z*L[10];return C.x=X,C.y=l,C.z=t,C.w=U.w,C}static TransformNormalFromFloatsToRef(U,G,C,L,X,l){const t=X.m;return l.x=U*t[0]+G*t[4]+C*t[8],l.y=U*t[1]+G*t[5]+C*t[9],l.z=U*t[2]+G*t[6]+C*t[10],l.w=L,l}static FromVector3(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new I(U._x,U._y,U._z,G)}static Dot(U,G){return U.x*G.x+U.y*G.y+U.z*G.z+U.w*G.w}}I._V8PerformanceHack=new I(.5,.5,.5,.5),I._ZeroReadOnly=I.Zero(),Object.defineProperties(I.prototype,{dimension:{value:[4]},rank:{value:1}});class H{get x(){return this._x}set x(U){this._x=U,this._isDirty=!0}get y(){return this._y}set y(U){this._y=U,this._isDirty=!0}get z(){return this._z}set z(U){this._z=U,this._isDirty=!0}get w(){return this._w}set w(U){this._w=U,this._isDirty=!0}constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=U,this._y=G,this._z=C,this._w=L}toString(){return"{X: ".concat(this._x," Y: ").concat(this._y," Z: ").concat(this._z," W: ").concat(this._w,"}")}getClassName(){return"Quaternion"}getHashCode(){let U=y(this._x);return U=397*U^y(this._y),U=397*U^y(this._z),U=397*U^y(this._w),U}sE(){return[this._x,this._y,this._z,this._w]}toArray(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U[G]=this._x,U[G+1]=this._y,U[G+2]=this._z,U[G+3]=this._w,this}xC(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H.FromArrayToRef(U,G,this)}equals(U){return U&&this._x===U._x&&this._y===U._y&&this._z===U._z&&this._w===U._w}equalsWithEpsilon(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:L.d;return U&&(0,K.WithinEpsilon)(this._x,U._x,G)&&(0,K.WithinEpsilon)(this._y,U._y,G)&&(0,K.WithinEpsilon)(this._z,U._z,G)&&(0,K.WithinEpsilon)(this._w,U._w,G)}isApprox(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:L.d;return U&&((0,K.WithinEpsilon)(this._x,U._x,G)&&(0,K.WithinEpsilon)(this._y,U._y,G)&&(0,K.WithinEpsilon)(this._z,U._z,G)&&(0,K.WithinEpsilon)(this._w,U._w,G)||(0,K.WithinEpsilon)(this._x,-U._x,G)&&(0,K.WithinEpsilon)(this._y,-U._y,G)&&(0,K.WithinEpsilon)(this._z,-U._z,G)&&(0,K.WithinEpsilon)(this._w,-U._w,G))}clone(){return new H(this._x,this._y,this._z,this._w)}L(U){return this._x=U._x,this._y=U._y,this._z=U._z,this._w=U._w,this._isDirty=!0,this}WE(U,G,C,L){return this._x=U,this._y=G,this._z=C,this._w=L,this._isDirty=!0,this}set(U,G,C,L){return this.WE(U,G,C,L)}rE(U){return this.WE(U,U,U,U)}add(U){return new H(this._x+U._x,this._y+U._y,this._z+U._z,this._w+U._w)}addInPlace(U){return this._x+=U._x,this._y+=U._y,this._z+=U._z,this._w+=U._w,this._isDirty=!0,this}addToRef(U,G){return G._x=this._x+U._x,G._y=this._y+U._y,G._z=this._z+U._z,G._w=this._w+U._w,G._isDirty=!0,G}addInPlaceFromFloats(U,G,C,L){return this._x+=U,this._y+=G,this._z+=C,this._w+=L,this._isDirty=!0,this}subtractToRef(U,G){return G._x=this._x-U._x,G._y=this._y-U._y,G._z=this._z-U._z,G._w=this._w-U._w,G._isDirty=!0,G}subtractFromFloats(U,G,C,L){return this.subtractFromFloatsToRef(U,G,C,L,new H)}subtractFromFloatsToRef(U,G,C,L,X){return X._x=this._x-U,X._y=this._y-G,X._z=this._z-C,X._w=this._w-L,X._isDirty=!0,X}IG(U){return new H(this._x-U._x,this._y-U._y,this._z-U._z,this._w-U._w)}uT(U){return this._x-=U._x,this._y-=U._y,this._z-=U._z,this._w-=U._w,this._isDirty=!0,this}scale(U){return new H(this._x*U,this._y*U,this._z*U,this._w*U)}scaleToRef(U,G){return G._x=this._x*U,G._y=this._y*U,G._z=this._z*U,G._w=this._w*U,G._isDirty=!0,G}scaleInPlace(U){return this._x*=U,this._y*=U,this._z*=U,this._w*=U,this._isDirty=!0,this}scaleAndAddToRef(U,G){return G._x+=this._x*U,G._y+=this._y*U,G._z+=this._z*U,G._w+=this._w*U,G._isDirty=!0,G}multiply(U){const G=new H(0,0,0,1);return this.multiplyToRef(U,G),G}multiplyToRef(U,G){const C=this._x*U._w+this._y*U._z-this._z*U._y+this._w*U._x,L=-this._x*U._z+this._y*U._w+this._z*U._x+this._w*U._y,X=this._x*U._y-this._y*U._x+this._z*U._w+this._w*U._z,l=-this._x*U._x-this._y*U._y-this._z*U._z+this._w*U._w;return G.WE(C,L,X,l),G}multiplyInPlace(U){return this.multiplyToRef(U,this)}multiplyByFloats(U,G,C,L){return this._x*=U,this._y*=G,this._z*=C,this._w*=L,this._isDirty=!0,this}divide(U){throw new ReferenceError("Can not divide a quaternion")}divideToRef(U,G){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(U){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new H)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(U){return U._x=-this._x,U._y=-this._y,U._z=-this._z,U._w=-this._w,U._isDirty=!0,U}equalsToFloats(U,G,C,L){return this._x===U&&this._y===G&&this._z===C&&this._w===L}floorToRef(U){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(U){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(U){return U.WE(-this._x,-this._y,-this._z,this._w),U}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new H(-this._x,-this._y,-this._z,this._w)}invert(){const U=this.conjugate(),G=this.lengthSquared();return 0==G||1==G||U.scaleInPlace(1/G),U}invertInPlace(){this.conjugateInPlace();const U=this.lengthSquared();return 0==U||1==U||this.scaleInPlace(1/U),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(U){return 0===U||1===U?this:this.scaleInPlace(1/U)}normalizeToNew(){const U=new H(0,0,0,1);return this.normalizeToRef(U),U}normalizeToRef(U){const G=this.length();return 0===G||1===G?U.WE(this._x,this._y,this._z,this._w):this.scaleToRef(1/G,U)}toEulerAngles(){const U=p.Zero();return this.toEulerAnglesToRef(U),U}toEulerAnglesToRef(U){const G=this._z,C=this._x,L=this._y,X=this._w,l=L*G-C*X,t=.4999999;if(l<-t)U._y=2*Math.atan2(L,X),U._x=Math.PI/2,U._z=0,U._isDirty=!0;else if(l>t)U._y=2*Math.atan2(L,X),U._x=-Math.PI/2,U._z=0,U._isDirty=!0;else{const t=X*X,E=G*G,K=C*C,P=L*L;U._z=Math.atan2(2*(C*L+G*X),-E-K+P+t),U._x=Math.asin(-2*l),U._y=Math.atan2(2*(G*C+L*X),E-K-P+t),U._isDirty=!0}return U}toAlphaBetaGammaToRef(U){const G=this._z,C=this._x,L=this._y,X=this._w,l=Math.sqrt(C*C+L*L),t=Math.sqrt(G*G+X*X),E=2*Math.atan2(l,t),K=2*Math.atan2(G,X),P=2*Math.atan2(L,C),O=(K+P)/2,T=(K-P)/2;return U.set(T,E,O),U}toRotationMatrix(U){return x.FromQuaternionToRef(this,U),U}fromRotationMatrix(U){return H.FromRotationMatrixToRef(U,this),this}dot(U){return this._x*U._x+this._y*U._y+this._z*U._z+this._w*U._w}toAxisAngle(){const U=p.Zero();return{axis:U,angle:this.toAxisAngleToRef(U)}}toAxisAngleToRef(U){let G=0;const C=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),L=this._w;return C>0?(G=2*Math.atan2(C,L),U.set(this._x/C,this._y/C,this._z/C)):(G=0,U.set(1,0,0)),G}static FromRotationMatrix(U){const G=new H;return H.FromRotationMatrixToRef(U,G),G}static FromRotationMatrixToRef(U,G){const C=U.m,L=C[0],X=C[4],l=C[8],t=C[1],E=C[5],K=C[9],P=C[2],O=C[6],T=C[10],D=L+E+T;let y;return D>0?(y=.5/Math.sqrt(D+1),G._w=.25/y,G._x=(O-K)*y,G._y=(l-P)*y,G._z=(t-X)*y,G._isDirty=!0):L>E&&L>T?(y=2*Math.sqrt(1+L-E-T),G._w=(O-K)/y,G._x=.25*y,G._y=(X+t)/y,G._z=(l+P)/y,G._isDirty=!0):E>T?(y=2*Math.sqrt(1+E-L-T),G._w=(l-P)/y,G._x=(X+t)/y,G._y=.25*y,G._z=(K+O)/y,G._isDirty=!0):(y=2*Math.sqrt(1+T-L-E),G._w=(t-X)/y,G._x=(l+P)/y,G._y=(K+O)/y,G._z=.25*y,G._isDirty=!0),G}static Dot(U,G){return U._x*G._x+U._y*G._y+U._z*G._z+U._w*G._w}static AreClose(U,G){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const L=H.Dot(U,G);return 1-L*L<=C}static SmoothToRef(U,G,C,L,X){let l=0===L?1:C/L;return l=(0,K.Clamp)(l,0,1),H.SlerpToRef(U,G,l,X),X}static Zero(){return new H(0,0,0,0)}static Inverse(U){return new H(-U._x,-U._y,-U._z,U._w)}static InverseToRef(U,G){return G.set(-U._x,-U._y,-U._z,U._w),G}static Identity(){return new H(0,0,0,1)}static IsIdentity(U){return U&&0===U._x&&0===U._y&&0===U._z&&1===U._w}static RotationAxis(U,G){return H.RotationAxisToRef(U,G,new H)}static RotationAxisToRef(U,G,C){C._w=Math.cos(G/2);const L=Math.sin(G/2)/U.length();return C._x=U._x*L,C._y=U._y*L,C._z=U._z*L,C._isDirty=!0,C}static NG(U,G){return G||(G=0),new H(U[G],U[G+1],U[G+2],U[G+3])}static FromArrayToRef(U,G,C){return C._x=U[G],C._y=U[G+1],C._z=U[G+2],C._w=U[G+3],C._isDirty=!0,C}static FromFloatsToRef(U,G,C,L,X){return X.WE(U,G,C,L),X}static FromEulerAngles(U,G,C){const L=new H;return H.RotationYawPitchRollToRef(G,U,C,L),L}static FromEulerAnglesToRef(U,G,C,L){return H.RotationYawPitchRollToRef(G,U,C,L),L}static FromEulerVector(U){const G=new H;return H.RotationYawPitchRollToRef(U._y,U._x,U._z,G),G}static FromEulerVectorToRef(U,G){return H.RotationYawPitchRollToRef(U._y,U._x,U._z,G),G}static FromUnitVectorsToRef(U,G,C){let X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L.d;const l=p.Dot(U,G)+1;return l<X?Math.abs(U.x)>Math.abs(U.z)?C.set(-U.y,U.x,0,0):C.set(0,-U.z,U.y,0):(p.CrossToRef(U,G,N.pG[0]),C.set(N.pG[0].x,N.pG[0].y,N.pG[0].z,l)),C.normalize()}static RotationYawPitchRoll(U,G,C){const L=new H;return H.RotationYawPitchRollToRef(U,G,C,L),L}static RotationYawPitchRollToRef(U,G,C,L){const X=.5*C,l=.5*G,t=.5*U,E=Math.sin(X),K=Math.cos(X),P=Math.sin(l),O=Math.cos(l),T=Math.sin(t),D=Math.cos(t);return L._x=D*P*K+T*O*E,L._y=T*O*K-D*P*E,L._z=D*O*E-T*P*K,L._w=D*O*K+T*P*E,L._isDirty=!0,L}static RotationAlphaBetaGamma(U,G,C){const L=new H;return H.RotationAlphaBetaGammaToRef(U,G,C,L),L}static RotationAlphaBetaGammaToRef(U,G,C,L){const X=.5*(C+U),l=.5*(C-U),t=.5*G;return L._x=Math.cos(l)*Math.sin(t),L._y=Math.sin(l)*Math.sin(t),L._z=Math.sin(X)*Math.cos(t),L._w=Math.cos(X)*Math.cos(t),L._isDirty=!0,L}static RotationQuaternionFromAxis(U,G,C){const L=new H(0,0,0,0);return H.RotationQuaternionFromAxisToRef(U,G,C,L),L}static RotationQuaternionFromAxisToRef(U,G,C,L){const X=h.Matrix[0];return U=U.normalizeToRef(h.pG[0]),G=G.normalizeToRef(h.pG[1]),C=C.normalizeToRef(h.pG[2]),x.FromXYZAxesToRef(U,G,C,X),H.FromRotationMatrixToRef(X,L),L}static FromLookDirectionLH(U,G){const C=new H;return H.FromLookDirectionLHToRef(U,G,C),C}static FromLookDirectionLHToRef(U,G,C){const L=h.Matrix[0];return x.LookDirectionLHToRef(U,G,L),H.FromRotationMatrixToRef(L,C),C}static FromLookDirectionRH(U,G){const C=new H;return H.FromLookDirectionRHToRef(U,G,C),C}static FromLookDirectionRHToRef(U,G,C){const L=h.Matrix[0];return x.LookDirectionRHToRef(U,G,L),H.FromRotationMatrixToRef(L,C)}static Slerp(U,G,C){const L=H.Identity();return H.SlerpToRef(U,G,C,L),L}static SlerpToRef(U,G,C,L){let X,l,t=U._x*G._x+U._y*G._y+U._z*G._z+U._w*G._w,E=!1;if(t<0&&(E=!0,t=-t),t>.999999)l=1-C,X=E?-C:C;else{const U=Math.acos(t),G=1/Math.sin(U);l=Math.sin((1-C)*U)*G,X=E?-Math.sin(C*U)*G:Math.sin(C*U)*G}return L._x=l*U._x+X*G._x,L._y=l*U._y+X*G._y,L._z=l*U._z+X*G._z,L._w=l*U._w+X*G._w,L._isDirty=!0,L}static Hermite(U,G,C,L,X){const l=X*X,t=X*l,E=2*t-3*l+1,K=-2*t+3*l,P=t-2*l+X,O=t-l,T=U._x*E+C._x*K+G._x*P+L._x*O,D=U._y*E+C._y*K+G._y*P+L._y*O,y=U._z*E+C._z*K+G._z*P+L._z*O,V=U._w*E+C._w*K+G._w*P+L._w*O;return new H(T,D,y,V)}static Hermite1stDerivative(U,G,C,L,X){const l=new H;return this.Hermite1stDerivativeToRef(U,G,C,L,X,l),l}static Hermite1stDerivativeToRef(U,G,C,L,X,l){const t=X*X;return l._x=6*(t-X)*U._x+(3*t-4*X+1)*G._x+6*(-t+X)*C._x+(3*t-2*X)*L._x,l._y=6*(t-X)*U._y+(3*t-4*X+1)*G._y+6*(-t+X)*C._y+(3*t-2*X)*L._y,l._z=6*(t-X)*U._z+(3*t-4*X+1)*G._z+6*(-t+X)*C._z+(3*t-2*X)*L._z,l._w=6*(t-X)*U._w+(3*t-4*X+1)*G._w+6*(-t+X)*C._w+(3*t-2*X)*L._w,l._isDirty=!0,l}static Normalize(U){const G=H.Zero();return H.NormalizeToRef(U,G),G}static NormalizeToRef(U,G){return U.normalizeToRef(G),G}static Clamp(U,G,C){const L=new H;return H.ClampToRef(U,G,C,L),L}static ClampToRef(U,G,C,L){return L.WE((0,K.Clamp)(U.x,G.x,C.x),(0,K.Clamp)(U.y,G.y,C.y),(0,K.Clamp)(U.z,G.z,C.z),(0,K.Clamp)(U.w,G.w,C.w))}static Random(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new H((0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G))}static RandomToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).WE((0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G),(0,K.RandomRange)(U,G))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(U,G){return Math.sqrt(H.DistanceSquared(U,G))}static DistanceSquared(U,G){const C=U.x-G.x,L=U.y-G.y,X=U.z-G.z,l=U.w-G.w;return C*C+L*L+X*X+l*l}static Center(U,G){return H.CenterToRef(U,G,H.Zero())}static CenterToRef(U,G,C){return C.WE((U.x+G.x)/2,(U.y+G.y)/2,(U.z+G.z)/2,(U.w+G.w)/2)}}H._V8PerformanceHack=new H(.5,.5,.5,.5),Object.defineProperties(H.prototype,{dimension:{value:[4]},rank:{value:1}});class x{static get Use64Bits(){return t.b.MatrixUse64Bits}get m(){return this.nE}markAsUpdated(){this.updateFlag=P._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(U){let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],L=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=U,this._isIdentity3x2=U||C,this._isIdentityDirty=!this._isIdentity&&G,this._isIdentity3x2Dirty=!this._isIdentity3x2&&L}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,t.b.MatrixTrackPrecisionChange&&t.b.MatrixTrackedMatrices.push(this),this.nE=new t.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const U=this.nE;this._isIdentity=1===U[0]&&0===U[1]&&0===U[2]&&0===U[3]&&0===U[4]&&1===U[5]&&0===U[6]&&0===U[7]&&0===U[8]&&0===U[9]&&1===U[10]&&0===U[11]&&0===U[12]&&0===U[13]&&0===U[14]&&1===U[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.nE[0]||1!==this.nE[5]||1!==this.nE[15]||0!==this.nE[1]||0!==this.nE[2]||0!==this.nE[3]||0!==this.nE[4]||0!==this.nE[6]||0!==this.nE[7]||0!==this.nE[8]||0!==this.nE[9]||0!==this.nE[10]||0!==this.nE[11]||0!==this.nE[12]||0!==this.nE[13]||0!==this.nE[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const U=this.nE,G=U[0],C=U[1],L=U[2],X=U[3],l=U[4],t=U[5],E=U[6],K=U[7],P=U[8],O=U[9],T=U[10],D=U[11],y=U[12],V=U[13],p=U[14],I=U[15],H=T*I-p*D,x=O*I-V*D,h=O*p-V*T,N=P*I-y*D,b=P*p-T*y,o=P*V-y*O;return G*+(t*H-E*x+K*h)+C*-(l*H-E*N+K*b)+L*+(l*x-t*N+K*o)+X*-(l*h-t*b+E*o)}toString(){return"{".concat(this.m[0],", ").concat(this.m[1],", ").concat(this.m[2],", ").concat(this.m[3],"\n").concat(this.m[4],", ").concat(this.m[5],", ").concat(this.m[6],", ").concat(this.m[7],"\n").concat(this.m[8],", ").concat(this.m[9],", ").concat(this.m[10],", ").concat(this.m[11],"\n").concat(this.m[12],", ").concat(this.m[13],", ").concat(this.m[14],", ").concat(this.m[15],"}")}toArray(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!U)return this.nE;const C=this.nE;for(let L=0;L<16;L++)U[G+L]=C[L];return this}sE(){return this.nE}xC(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return x.FromArrayToRef(U,G,this)}WE(){for(var U=arguments.length,G=new Array(U),C=0;C<U;C++)G[C]=arguments[C];return x.FromArrayToRef(G,0,this)}set(){const U=this.nE;for(let G=0;G<16;G++)U[G]=G<0||arguments.length<=G?void 0:arguments[G];return this.markAsUpdated(),this}rE(U){const G=this.nE;for(let C=0;C<16;C++)G[C]=U;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return x.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(U){const G=new x;return this.addToRef(U,G),G}addToRef(U,G){const C=this.nE,L=G.nE,X=U.m;for(let l=0;l<16;l++)L[l]=C[l]+X[l];return G.markAsUpdated(),G}addToSelf(U){const G=this.nE,C=U.m;return G[0]+=C[0],G[1]+=C[1],G[2]+=C[2],G[3]+=C[3],G[4]+=C[4],G[5]+=C[5],G[6]+=C[6],G[7]+=C[7],G[8]+=C[8],G[9]+=C[9],G[10]+=C[10],G[11]+=C[11],G[12]+=C[12],G[13]+=C[13],G[14]+=C[14],G[15]+=C[15],this.markAsUpdated(),this}addInPlace(U){const G=this.nE,C=U.m;for(let L=0;L<16;L++)G[L]+=C[L];return this.markAsUpdated(),this}addInPlaceFromFloats(){const U=this.nE;for(let G=0;G<16;G++)U[G]+=G<0||arguments.length<=G?void 0:arguments[G];return this.markAsUpdated(),this}IG(U){const G=this.nE,C=U.m;for(let L=0;L<16;L++)G[L]-=C[L];return this.markAsUpdated(),this}subtractToRef(U,G){const C=this.nE,L=U.m,X=G.nE;for(let l=0;l<16;l++)X[l]=C[l]-L[l];return G.markAsUpdated(),G}uT(U){const G=this.nE,C=U.m;for(let L=0;L<16;L++)G[L]-=C[L];return this.markAsUpdated(),this}subtractFromFloats(){for(var U=arguments.length,G=new Array(U),C=0;C<U;C++)G[C]=arguments[C];return this.subtractFromFloatsToRef(...G,new x)}subtractFromFloatsToRef(){for(var U=arguments.length,G=new Array(U),C=0;C<U;C++)G[C]=arguments[C];const L=G.pop(),X=this.nE,l=L.nE,t=G;for(let E=0;E<16;E++)l[E]=X[E]-t[E];return L.markAsUpdated(),L}invertToRef(U){return!0===this._isIdentity?(x.IdentityToRef(U),U):(D(this,U.sE())?U.markAsUpdated():U.L(this),U)}addAtIndex(U,G){return this.nE[U]+=G,this.markAsUpdated(),this}multiplyAtIndex(U,G){return this.nE[U]*=G,this.markAsUpdated(),this}setTranslationFromFloats(U,G,C){return this.nE[12]=U,this.nE[13]=G,this.nE[14]=C,this.markAsUpdated(),this}addTranslationFromFloats(U,G,C){return this.nE[12]+=U,this.nE[13]+=G,this.nE[14]+=C,this.markAsUpdated(),this}setTranslation(U){return this.setTranslationFromFloats(U._x,U._y,U._z)}getTranslation(){return new p(this.nE[12],this.nE[13],this.nE[14])}getTranslationToRef(U){return U.x=this.nE[12],U.y=this.nE[13],U.z=this.nE[14],U}removeRotationAndScaling(){const U=this.m;return x.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,U[12],U[13],U[14],U[15],this),this._updateIdentityStatus(0===U[12]&&0===U[13]&&0===U[14]&&1===U[15]),this}L(U){U.copyToArray(this.nE);const G=U;return this.updateFlag=G.updateFlag,this._updateIdentityStatus(G._isIdentity,G._isIdentityDirty,G._isIdentity3x2,G._isIdentity3x2Dirty),this}copyToArray(U){return T(this,U,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(U){const G=new x;return this.multiplyToRef(U,G),G}multiplyInPlace(U){const G=this.nE,C=U.m;for(let L=0;L<16;L++)G[L]*=C[L];return this.markAsUpdated(),this}multiplyByFloats(){const U=this.nE;for(let G=0;G<16;G++)U[G]*=G<0||arguments.length<=G?void 0:arguments[G];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var U=arguments.length,G=new Array(U),C=0;C<U;C++)G[C]=arguments[C];const L=G.pop(),X=this.nE,l=L.nE,t=G;for(let E=0;E<16;E++)l[E]=X[E]*t[E];return L.markAsUpdated(),L}multiplyToRef(U,G){return this._isIdentity?(G.L(U),G):U._isIdentity?(G.L(this),G):(this.multiplyToArray(U,G.nE,0),G.markAsUpdated(),G)}multiplyToArray(U,G,C){return O(this,U,G,C),this}divide(U){return this.divideToRef(U,new x)}divideToRef(U,G){const C=this.nE,L=U.m,X=G.nE;for(let l=0;l<16;l++)X[l]=C[l]/L[l];return G.markAsUpdated(),G}divideInPlace(U){const G=this.nE,C=U.m;for(let L=0;L<16;L++)G[L]/=C[L];return this.markAsUpdated(),this}minimizeInPlace(U){const G=this.nE,C=U.m;for(let L=0;L<16;L++)G[L]=Math.min(G[L],C[L]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const U=this.nE;for(let G=0;G<16;G++)U[G]=Math.min(U[G],G<0||arguments.length<=G?void 0:arguments[G]);return this.markAsUpdated(),this}maximizeInPlace(U){const G=this.nE,C=U.m;for(let L=0;L<16;L++)G[L]=Math.min(G[L],C[L]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const U=this.nE;for(let G=0;G<16;G++)U[G]=Math.min(U[G],G<0||arguments.length<=G?void 0:arguments[G]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new x)}negateInPlace(){const U=this.nE;for(let G=0;G<16;G++)U[G]=-U[G];return this.markAsUpdated(),this}negateToRef(U){const G=this.nE,C=U.nE;for(let L=0;L<16;L++)C[L]=-G[L];return U.markAsUpdated(),U}equals(U){const G=U;if(!G)return!1;if((this._isIdentity||G._isIdentity)&&!this._isIdentityDirty&&!G._isIdentityDirty)return this._isIdentity&&G._isIdentity;const C=this.m,L=G.m;return C[0]===L[0]&&C[1]===L[1]&&C[2]===L[2]&&C[3]===L[3]&&C[4]===L[4]&&C[5]===L[5]&&C[6]===L[6]&&C[7]===L[7]&&C[8]===L[8]&&C[9]===L[9]&&C[10]===L[10]&&C[11]===L[11]&&C[12]===L[12]&&C[13]===L[13]&&C[14]===L[14]&&C[15]===L[15]}equalsWithEpsilon(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this.nE,L=U.m;for(let X=0;X<16;X++)if(!(0,K.WithinEpsilon)(C[X],L[X],G))return!1;return!0}equalsToFloats(){const U=this.nE;for(let G=0;G<16;G++)if(U[G]!=(G<0||arguments.length<=G?void 0:arguments[G]))return!1;return!0}floor(){return this.floorToRef(new x)}floorToRef(U){const G=this.nE,C=U.nE;for(let L=0;L<16;L++)C[L]=Math.floor(G[L]);return U.markAsUpdated(),U}fract(){return this.fractToRef(new x)}fractToRef(U){const G=this.nE,C=U.nE;for(let L=0;L<16;L++)C[L]=G[L]-Math.floor(G[L]);return U.markAsUpdated(),U}clone(){const U=new x;return U.L(this),U}getClassName(){return"Matrix"}getHashCode(){let U=y(this.nE[0]);for(let G=1;G<16;G++)U=397*U^y(this.nE[G]);return U}decomposeToTransformNode(U){return U.rotationQuaternion=U.rotationQuaternion||new H,this.decompose(U.fE,U.rotationQuaternion,U.position)}decompose(U,G,C,L){let X=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return C&&C.rE(0),U&&U.rE(1),G&&G.WE(0,0,0,1),!0;const l=this.nE;if(C&&C.WE(l[12],l[13],l[14]),(U=U||h.pG[0]).x=Math.sqrt(l[0]*l[0]+l[1]*l[1]+l[2]*l[2]),U.y=Math.sqrt(l[4]*l[4]+l[5]*l[5]+l[6]*l[6]),U.z=Math.sqrt(l[8]*l[8]+l[9]*l[9]+l[10]*l[10]),L){const G=(X?L.absoluteScaling.x:L.fE.x)<0?-1:1,C=(X?L.absoluteScaling.y:L.fE.y)<0?-1:1,l=(X?L.absoluteScaling.z:L.fE.z)<0?-1:1;U.x*=G,U.y*=C,U.z*=l}else this.determinant()<=0&&(U.y*=-1);if(0===U._x||0===U._y||0===U._z)return G&&G.WE(0,0,0,1),!1;if(G){const C=1/U._x,L=1/U._y,X=1/U._z;x.FromValuesToRef(l[0]*C,l[1]*C,l[2]*C,0,l[4]*L,l[5]*L,l[6]*L,0,l[8]*X,l[9]*X,l[10]*X,0,0,0,0,1,h.Matrix[0]),H.FromRotationMatrixToRef(h.Matrix[0],G)}return!0}getRow(U){if(U<0||U>3)return null;const G=4*U;return new I(this.nE[G+0],this.nE[G+1],this.nE[G+2],this.nE[G+3])}getRowToRef(U,G){if(U>=0&&U<=3){const C=4*U;G.x=this.nE[C+0],G.y=this.nE[C+1],G.z=this.nE[C+2],G.w=this.nE[C+3]}return G}setRow(U,G){return this.setRowFromFloats(U,G.x,G.y,G.z,G.w)}transpose(){const U=new x;return x.TransposeToRef(this,U),U}transposeToRef(U){return x.TransposeToRef(this,U),U}setRowFromFloats(U,G,C,L,X){if(U<0||U>3)return this;const l=4*U;return this.nE[l+0]=G,this.nE[l+1]=C,this.nE[l+2]=L,this.nE[l+3]=X,this.markAsUpdated(),this}scale(U){const G=new x;return this.scaleToRef(U,G),G}scaleToRef(U,G){for(let C=0;C<16;C++)G.nE[C]=this.nE[C]*U;return G.markAsUpdated(),G}scaleAndAddToRef(U,G){for(let C=0;C<16;C++)G.nE[C]+=this.nE[C]*U;return G.markAsUpdated(),G}scaleInPlace(U){const G=this.nE;for(let C=0;C<16;C++)G[C]*=U;return this.markAsUpdated(),this}toNormalMatrix(U){const G=h.Matrix[0];this.invertToRef(G),G.transposeToRef(U);const C=U.nE;return x.FromValuesToRef(C[0],C[1],C[2],0,C[4],C[5],C[6],0,C[8],C[9],C[10],0,0,0,0,1,U),U}getRotationMatrix(){const U=new x;return this.getRotationMatrixToRef(U),U}getRotationMatrixToRef(U){const G=h.pG[0];if(!this.decompose(G))return x.IdentityToRef(U),U;const C=this.nE,L=1/G._x,X=1/G._y,l=1/G._z;return x.FromValuesToRef(C[0]*L,C[1]*L,C[2]*L,0,C[4]*X,C[5]*X,C[6]*X,0,C[8]*l,C[9]*l,C[10]*l,0,0,0,0,1,U),U}toggleModelMatrixHandInPlace(){const U=this.nE;return U[2]*=-1,U[6]*=-1,U[8]*=-1,U[9]*=-1,U[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const U=this.nE;return U[8]*=-1,U[9]*=-1,U[10]*=-1,U[11]*=-1,this.markAsUpdated(),this}static NG(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=new x;return x.FromArrayToRef(U,G,C),C}static FromArrayToRef(U,G,C){for(let L=0;L<16;L++)C.nE[L]=U[L+G];return C.markAsUpdated(),C}static FromFloat32ArrayToRefScaled(U,G,C,L){return L.nE[0]=U[0+G]*C,L.nE[1]=U[1+G]*C,L.nE[2]=U[2+G]*C,L.nE[3]=U[3+G]*C,L.nE[4]=U[4+G]*C,L.nE[5]=U[5+G]*C,L.nE[6]=U[6+G]*C,L.nE[7]=U[7+G]*C,L.nE[8]=U[8+G]*C,L.nE[9]=U[9+G]*C,L.nE[10]=U[10+G]*C,L.nE[11]=U[11+G]*C,L.nE[12]=U[12+G]*C,L.nE[13]=U[13+G]*C,L.nE[14]=U[14+G]*C,L.nE[15]=U[15+G]*C,L.markAsUpdated(),L}static get IdentityReadOnly(){return x._IdentityReadOnly}static FromValuesToRef(U,G,C,L,X,l,t,E,K,P,O,T,D,y,V,p,I){const H=I.nE;H[0]=U,H[1]=G,H[2]=C,H[3]=L,H[4]=X,H[5]=l,H[6]=t,H[7]=E,H[8]=K,H[9]=P,H[10]=O,H[11]=T,H[12]=D,H[13]=y,H[14]=V,H[15]=p,I.markAsUpdated()}static FromValues(U,G,C,L,X,l,t,E,K,P,O,T,D,y,V,p){const I=new x,H=I.nE;return H[0]=U,H[1]=G,H[2]=C,H[3]=L,H[4]=X,H[5]=l,H[6]=t,H[7]=E,H[8]=K,H[9]=P,H[10]=O,H[11]=T,H[12]=D,H[13]=y,H[14]=V,H[15]=p,I.markAsUpdated(),I}static Compose(U,G,C){const L=new x;return x.ComposeToRef(U,G,C,L),L}static ComposeToRef(U,G,C,L){const X=L.nE,l=G._x,t=G._y,E=G._z,K=G._w,P=l+l,O=t+t,T=E+E,D=l*P,y=l*O,V=l*T,p=t*O,I=t*T,H=E*T,x=K*P,h=K*O,N=K*T,b=U._x,o=U._y,w=U._z;return X[0]=(1-(p+H))*b,X[1]=(y+N)*b,X[2]=(V-h)*b,X[3]=0,X[4]=(y-N)*o,X[5]=(1-(D+H))*o,X[6]=(I+x)*o,X[7]=0,X[8]=(V+h)*w,X[9]=(I-x)*w,X[10]=(1-(D+p))*w,X[11]=0,X[12]=C._x,X[13]=C._y,X[14]=C._z,X[15]=1,L.markAsUpdated(),L}static Identity(){const U=x.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return U._updateIdentityStatus(!0),U}static IdentityToRef(U){return x.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,U),U._updateIdentityStatus(!0),U}static Zero(){const U=x.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return U._updateIdentityStatus(!1),U}static RotationX(U){const G=new x;return x.RotationXToRef(U,G),G}static Invert(U){const G=new x;return U.invertToRef(G),G}static RotationXToRef(U,G){const C=Math.sin(U),L=Math.cos(U);return x.FromValuesToRef(1,0,0,0,0,L,C,0,0,-C,L,0,0,0,0,1,G),G._updateIdentityStatus(1===L&&0===C),G}static RotationY(U){const G=new x;return x.RotationYToRef(U,G),G}static RotationYToRef(U,G){const C=Math.sin(U),L=Math.cos(U);return x.FromValuesToRef(L,0,-C,0,0,1,0,0,C,0,L,0,0,0,0,1,G),G._updateIdentityStatus(1===L&&0===C),G}static RotationZ(U){const G=new x;return x.RotationZToRef(U,G),G}static RotationZToRef(U,G){const C=Math.sin(U),L=Math.cos(U);return x.FromValuesToRef(L,C,0,0,-C,L,0,0,0,0,1,0,0,0,0,1,G),G._updateIdentityStatus(1===L&&0===C),G}static RotationAxis(U,G){const C=new x;return x.RotationAxisToRef(U,G,C),C}static RotationAxisToRef(U,G,C){const L=Math.sin(-G),X=Math.cos(-G),l=1-X;U=U.normalizeToRef(h.pG[0]);const t=C.nE;return t[0]=U._x*U._x*l+X,t[1]=U._x*U._y*l-U._z*L,t[2]=U._x*U._z*l+U._y*L,t[3]=0,t[4]=U._y*U._x*l+U._z*L,t[5]=U._y*U._y*l+X,t[6]=U._y*U._z*l-U._x*L,t[7]=0,t[8]=U._z*U._x*l-U._y*L,t[9]=U._z*U._y*l+U._x*L,t[10]=U._z*U._z*l+X,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,C.markAsUpdated(),C}static RotationAlignToRef(U,G,C){let X=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const l=p.Dot(G,U),t=C.nE;if(l<-1+L.d)t[0]=-1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=X?1:-1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=X?-1:1,t[11]=0;else{const C=p.Cross(G,U),L=1/(1+l);t[0]=C._x*C._x*L+l,t[1]=C._y*C._x*L-C._z,t[2]=C._z*C._x*L+C._y,t[3]=0,t[4]=C._x*C._y*L+C._z,t[5]=C._y*C._y*L+l,t[6]=C._z*C._y*L-C._x,t[7]=0,t[8]=C._x*C._z*L-C._y,t[9]=C._y*C._z*L+C._x,t[10]=C._z*C._z*L+l,t[11]=0}return t[12]=0,t[13]=0,t[14]=0,t[15]=1,C.markAsUpdated(),C}static RotationYawPitchRoll(U,G,C){const L=new x;return x.RotationYawPitchRollToRef(U,G,C,L),L}static RotationYawPitchRollToRef(U,G,C,L){return H.RotationYawPitchRollToRef(U,G,C,h.Quaternion[0]),h.Quaternion[0].toRotationMatrix(L),L}static Scaling(U,G,C){const L=new x;return x.ScalingToRef(U,G,C,L),L}static ScalingToRef(U,G,C,L){return x.FromValuesToRef(U,0,0,0,0,G,0,0,0,0,C,0,0,0,0,1,L),L._updateIdentityStatus(1===U&&1===G&&1===C),L}static Translation(U,G,C){const L=new x;return x.TranslationToRef(U,G,C,L),L}static TranslationToRef(U,G,C,L){return x.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,U,G,C,1,L),L._updateIdentityStatus(0===U&&0===G&&0===C),L}static Lerp(U,G,C){const L=new x;return x.LerpToRef(U,G,C,L),L}static LerpToRef(U,G,C,L){const X=L.nE,l=U.m,t=G.m;for(let E=0;E<16;E++)X[E]=l[E]*(1-C)+t[E]*C;return L.markAsUpdated(),L}static DecomposeLerp(U,G,C){const L=new x;return x.DecomposeLerpToRef(U,G,C,L),L}static DecomposeLerpToRef(U,G,C,L){const X=h.pG[0],l=h.Quaternion[0],t=h.pG[1];U.decompose(X,l,t);const E=h.pG[2],K=h.Quaternion[1],P=h.pG[3];G.decompose(E,K,P);const O=h.pG[4];p.LerpToRef(X,E,C,O);const T=h.Quaternion[2];H.SlerpToRef(l,K,C,T);const D=h.pG[5];return p.LerpToRef(t,P,C,D),x.ComposeToRef(O,T,D,L),L}static LookAtLH(U,G,C){const L=new x;return x.LookAtLHToRef(U,G,C,L),L}static LookAtLHToRef(U,G,C,L){const X=h.pG[0],l=h.pG[1],t=h.pG[2];G.subtractToRef(U,t),t.normalize(),p.CrossToRef(C,t,X);const E=X.lengthSquared();0===E?X.x=1:X.normalizeFromLength(Math.sqrt(E)),p.CrossToRef(t,X,l),l.normalize();const K=-p.Dot(X,U),P=-p.Dot(l,U),O=-p.Dot(t,U);return x.FromValuesToRef(X._x,l._x,t._x,0,X._y,l._y,t._y,0,X._z,l._z,t._z,0,K,P,O,1,L),L}static LookAtRH(U,G,C){const L=new x;return x.LookAtRHToRef(U,G,C,L),L}static LookAtRHToRef(U,G,C,L){const X=h.pG[0],l=h.pG[1],t=h.pG[2];U.subtractToRef(G,t),t.normalize(),p.CrossToRef(C,t,X);const E=X.lengthSquared();0===E?X.x=1:X.normalizeFromLength(Math.sqrt(E)),p.CrossToRef(t,X,l),l.normalize();const K=-p.Dot(X,U),P=-p.Dot(l,U),O=-p.Dot(t,U);return x.FromValuesToRef(X._x,l._x,t._x,0,X._y,l._y,t._y,0,X._z,l._z,t._z,0,K,P,O,1,L),L}static LookDirectionLH(U,G){const C=new x;return x.LookDirectionLHToRef(U,G,C),C}static LookDirectionLHToRef(U,G,C){const L=h.pG[0];L.L(U),L.scaleInPlace(-1);const X=h.pG[1];return p.CrossToRef(G,L,X),x.FromValuesToRef(X._x,X._y,X._z,0,G._x,G._y,G._z,0,L._x,L._y,L._z,0,0,0,0,1,C),C}static LookDirectionRH(U,G){const C=new x;return x.LookDirectionRHToRef(U,G,C),C}static LookDirectionRHToRef(U,G,C){const L=h.pG[2];return p.CrossToRef(G,U,L),x.FromValuesToRef(L._x,L._y,L._z,0,G._x,G._y,G._z,0,U._x,U._y,U._z,0,0,0,0,1,C),C}static OrthoLH(U,G,C,L,X){const l=new x;return x.OrthoLHToRef(U,G,C,L,l,X),l}static OrthoLHToRef(U,G,C,L,X,l){const t=2/U,E=2/G,K=2/(L-C),P=-(L+C)/(L-C);return x.FromValuesToRef(t,0,0,0,0,E,0,0,0,0,K,0,0,0,P,1,X),l&&X.multiplyToRef(b,X),X._updateIdentityStatus(1===t&&1===E&&1===K&&0===P),X}static OrthoOffCenterLH(U,G,C,L,X,l,t){const E=new x;return x.OrthoOffCenterLHToRef(U,G,C,L,X,l,E,t),E}static OrthoOffCenterLHToRef(U,G,C,L,X,l,t,E){const K=2/(G-U),P=2/(L-C),O=2/(l-X),T=-(l+X)/(l-X),D=(U+G)/(U-G),y=(L+C)/(C-L);return x.FromValuesToRef(K,0,0,0,0,P,0,0,0,0,O,0,D,y,T,1,t),E&&t.multiplyToRef(b,t),t.markAsUpdated(),t}static ObliqueOffCenterLHToRef(U,G,C,L,X,l,t,E,K,P,O){const T=-t*Math.cos(E),D=-t*Math.sin(E);return x.TranslationToRef(0,0,-K,h.Matrix[1]),x.FromValuesToRef(1,0,0,0,0,1,0,0,T,D,1,0,0,0,0,1,h.Matrix[0]),h.Matrix[1].multiplyToRef(h.Matrix[0],h.Matrix[0]),x.TranslationToRef(0,0,K,h.Matrix[1]),h.Matrix[0].multiplyToRef(h.Matrix[1],h.Matrix[0]),x.OrthoOffCenterLHToRef(U,G,C,L,X,l,P,O),h.Matrix[0].multiplyToRef(P,P),P}static OrthoOffCenterRH(U,G,C,L,X,l,t){const E=new x;return x.OrthoOffCenterRHToRef(U,G,C,L,X,l,E,t),E}static OrthoOffCenterRHToRef(U,G,C,L,X,l,t,E){return x.OrthoOffCenterLHToRef(U,G,C,L,X,l,t,E),t.nE[10]*=-1,t}static ObliqueOffCenterRHToRef(U,G,C,L,X,l,t,E,K,P,O){const T=t*Math.cos(E),D=t*Math.sin(E);return x.TranslationToRef(0,0,K,h.Matrix[1]),x.FromValuesToRef(1,0,0,0,0,1,0,0,T,D,1,0,0,0,0,1,h.Matrix[0]),h.Matrix[1].multiplyToRef(h.Matrix[0],h.Matrix[0]),x.TranslationToRef(0,0,-K,h.Matrix[1]),h.Matrix[0].multiplyToRef(h.Matrix[1],h.Matrix[0]),x.OrthoOffCenterRHToRef(U,G,C,L,X,l,P,O),h.Matrix[0].multiplyToRef(P,P),P}static PerspectiveLH(U,G,C,L,X){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const t=new x,E=2*C/U,K=2*C/G,P=(L+C)/(L-C),O=-2*L*C/(L-C),T=Math.tan(l);return x.FromValuesToRef(E,0,0,0,0,K,0,T,0,0,P,1,0,0,O,0,t),X&&t.multiplyToRef(b,t),t._updateIdentityStatus(!1),t}static PerspectiveFovLH(U,G,C,L,X){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,t=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const E=new x;return x.PerspectiveFovLHToRef(U,G,C,L,E,!0,X,l,t),E}static PerspectiveFovLHToRef(U,G,C,L,X){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],t=arguments.length>6?arguments[6]:void 0,E=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,K=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const P=C,O=L,T=1/Math.tan(.5*U),D=l?T/G:T,y=l?T:T*G,V=K&&0===P?-1:0!==O?(O+P)/(O-P):1,p=K&&0===P?2*O:0!==O?-2*O*P/(O-P):-2*P,I=Math.tan(E);return x.FromValuesToRef(D,0,0,0,0,y,0,I,0,0,V,1,0,0,p,0,X),t&&X.multiplyToRef(b,X),X._updateIdentityStatus(!1),X}static PerspectiveFovReverseLHToRef(U,G,C,L,X){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],t=arguments.length>6?arguments[6]:void 0,E=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const K=1/Math.tan(.5*U),P=l?K/G:K,O=l?K:K*G,T=Math.tan(E);return x.FromValuesToRef(P,0,0,0,0,O,0,T,0,0,-C,1,0,0,1,0,X),t&&X.multiplyToRef(b,X),X._updateIdentityStatus(!1),X}static PerspectiveFovRH(U,G,C,L,X){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,t=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const E=new x;return x.PerspectiveFovRHToRef(U,G,C,L,E,!0,X,l,t),E}static PerspectiveFovRHToRef(U,G,C,L,X){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],t=arguments.length>6?arguments[6]:void 0,E=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,K=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const P=C,O=L,T=1/Math.tan(.5*U),D=l?T/G:T,y=l?T:T*G,V=K&&0===P?1:0!==O?-(O+P)/(O-P):-1,p=K&&0===P?2*O:0!==O?-2*O*P/(O-P):-2*P,I=Math.tan(E);return x.FromValuesToRef(D,0,0,0,0,y,0,I,0,0,V,-1,0,0,p,0,X),t&&X.multiplyToRef(b,X),X._updateIdentityStatus(!1),X}static PerspectiveFovReverseRHToRef(U,G,C,L,X){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],t=arguments.length>6?arguments[6]:void 0,E=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const K=1/Math.tan(.5*U),P=l?K/G:K,O=l?K:K*G,T=Math.tan(E);return x.FromValuesToRef(P,0,0,0,0,O,0,T,0,0,-C,-1,0,0,-1,0,X),t&&X.multiplyToRef(b,X),X._updateIdentityStatus(!1),X}static GetFinalMatrix(U,G,C,L,X,l){const t=U.width,E=U.height,K=U.x,P=U.y,O=x.FromValues(t/2,0,0,0,0,-E/2,0,0,0,0,l-X,0,K+t/2,E/2+P,X,1),T=new x;return G.multiplyToRef(C,T),T.multiplyToRef(L,T),T.multiplyToRef(O,T)}static GetAsMatrix2x2(U){const G=U.m,C=[G[0],G[1],G[4],G[5]];return t.b.MatrixUse64Bits?C:new Float32Array(C)}static GetAsMatrix3x3(U){const G=U.m,C=[G[0],G[1],G[2],G[4],G[5],G[6],G[8],G[9],G[10]];return t.b.MatrixUse64Bits?C:new Float32Array(C)}static Transpose(U){const G=new x;return x.TransposeToRef(U,G),G}static TransposeToRef(U,G){const C=U.m,L=C[0],X=C[4],l=C[8],t=C[12],E=C[1],K=C[5],P=C[9],O=C[13],T=C[2],D=C[6],y=C[10],V=C[14],p=C[3],I=C[7],H=C[11],x=C[15],h=G.nE;return h[0]=L,h[1]=X,h[2]=l,h[3]=t,h[4]=E,h[5]=K,h[6]=P,h[7]=O,h[8]=T,h[9]=D,h[10]=y,h[11]=V,h[12]=p,h[13]=I,h[14]=H,h[15]=x,G.markAsUpdated(),G._updateIdentityStatus(U._isIdentity,U._isIdentityDirty),G}static Reflection(U){const G=new x;return x.ReflectionToRef(U,G),G}static ReflectionToRef(U,G){U.normalize();const C=U.normal.x,L=U.normal.y,X=U.normal.z,l=-2*C,t=-2*L,E=-2*X;return x.FromValuesToRef(l*C+1,t*C,E*C,0,l*L,t*L+1,E*L,0,l*X,t*X,E*X+1,0,l*U.d,t*U.d,E*U.d,1,G),G}static FromXYZAxesToRef(U,G,C,L){return x.FromValuesToRef(U._x,U._y,U._z,0,G._x,G._y,G._z,0,C._x,C._y,C._z,0,0,0,0,1,L),L}static FromQuaternionToRef(U,G){const C=U._x*U._x,L=U._y*U._y,X=U._z*U._z,l=U._x*U._y,t=U._z*U._w,E=U._z*U._x,K=U._y*U._w,P=U._y*U._z,O=U._x*U._w;return G.nE[0]=1-2*(L+X),G.nE[1]=2*(l+t),G.nE[2]=2*(E-K),G.nE[3]=0,G.nE[4]=2*(l-t),G.nE[5]=1-2*(X+C),G.nE[6]=2*(P+O),G.nE[7]=0,G.nE[8]=2*(E+K),G.nE[9]=2*(P-O),G.nE[10]=1-2*(L+C),G.nE[11]=0,G.nE[12]=0,G.nE[13]=0,G.nE[14]=0,G.nE[15]=1,G.markAsUpdated(),G}}x._IdentityReadOnly=x.Identity(),Object.defineProperties(x.prototype,{dimension:{value:[4,4]},rank:{value:2}});class h{}h.pG=(0,X.i)(11,p.Zero),h.Matrix=(0,X.i)(2,x.Identity),h.Quaternion=(0,X.i)(3,H.Zero);class N{}N.Vector2=(0,X.i)(3,V.Zero),N.pG=(0,X.i)(13,p.Zero),N.Vector4=(0,X.i)(3,I.Zero),N.Quaternion=(0,X.i)(3,H.Zero),N.Matrix=(0,X.i)(8,x.Identity),(0,l.e)("BABYLON.Vector2",V),(0,l.e)("BABYLON.Vector3",p),(0,l.e)("BABYLON.Vector4",I),(0,l.e)("BABYLON.Matrix",x);const b=x.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12907:(U,G,C)=>{function L(U,G){const C=[];for(let L=0;L<U;++L)C.push(G());return C}function X(U,G){return L(U,G)}C.d(G,{e:()=>L,i:()=>X,j:()=>t});const l=["push","splice","pop","shift","unshift"];function t(U,G){const C=l.map((C=>function(U,G,C){const L=U[G];if("function"!==typeof L)return null;const X=function(){const L=U.length,l=X.previous.apply(U,arguments);return C(G,L),l};return L.next=X,X.previous=L,U[G]=X,()=>{const C=X.previous;if(!C)return;const L=X.next;L?(C.next=L,L.previous=C):(C.next=void 0,U[G]=C),X.next=void 0,X.previous=void 0}}(U,C,G)));return()=>{for(const U of C)null===U||void 0===U||U()}}}}]);