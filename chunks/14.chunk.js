"use strict";(self.rsqbdnwe5e=self.rsqbdnwe5e||[]).push([[14],{12376:(N,p,T)=>{T.d(p,{b:()=>U,d:()=>C,h:()=>A,k:()=>a});const A=1/2.2,a=2.2,C=(1+Math.sqrt(5))/2,U=.001},12390:(N,p,T)=>{function A(N){return parseInt(N.toString().replace(/\W/g,""))}function a(N,p){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(N-p)<=T}function C(N,p,T){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return N<p-A||N>T+A}function U(N,p){return N===p?N:Math.random()*(p-N)+N}function X(N,p,T){return N+(p-N)*T}function y(N,p,T){let A=I(p-N,360);return A>180&&(A-=360),N+A*b(T)}function e(N,p,T){let A=0;return A=N!=p?b((T-N)/(p-N)):0,A}function H(N,p,T,A,a){const C=a*a,U=a*C;return N*(2*U-3*C+1)+T*(-2*U+3*C)+p*(U-2*C+a)+A*(U-C)}function M(N,p,T,A,a){const C=a*a;return 6*(C-a)*N+(3*C-4*a+1)*p+6*(-C+a)*T+(3*C-2*a)*A}function b(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(T,Math.max(p,N))}function l(N){return N-=2*Math.PI*Math.floor((N+Math.PI)/(2*Math.PI))}function k(N){const p=N.toString(16);return N<=15?("0"+p).toUpperCase():p.toUpperCase()}function x(N){if(Math.log2)return Math.floor(Math.log2(N));if(N<0)return NaN;if(0===N)return-1/0;let p=0;if(N<1){for(;N<1;)p++,N*=2;p=-p}else if(N>1)for(;N>1;)p++,N=Math.floor(N/2);return p}function I(N,p){return N-Math.floor(N/p)*p}function L(N,p,T){return(N-p)/(T-p)}function n(N,p,T){return N*(T-p)+p}function w(N,p){let T=I(p-N,360);return T>180&&(T-=360),T}function g(N,p){const T=I(N,2*p);return p-Math.abs(T-p)}function P(N,p,T){let A=b(T);return A=-2*A*A*A+3*A*A,p*A+N*(1-A)}function i(N,p,T){let A=0;return A=Math.abs(p-N)<=T?p:N+Math.sign(p-N)*T,A}function K(N,p,T){const A=w(N,p);let a=0;return a=-T<A&&A<T?p:i(N,p=N+A,T),a}function F(N,p,T){return(N-p)/(T-p)}function v(N,p,T){return(T-p)*N+p}function W(N,p){const T=N%p;return 0===T?p:W(p,T)}T.r(p),T.d(p,{Clamp:()=>b,DeltaAngle:()=>w,Denormalize:()=>n,ExtractAsInt:()=>A,Hermite:()=>H,Hermite1stDerivative:()=>M,HighestCommonFactor:()=>W,ILog2:()=>x,InverseLerp:()=>e,Lerp:()=>X,LerpAngle:()=>y,MoveTowards:()=>i,MoveTowardsAngle:()=>K,Normalize:()=>L,NormalizeRadians:()=>l,OutsideRange:()=>C,PercentToRange:()=>v,PingPong:()=>g,RandomRange:()=>U,RangeToPercent:()=>F,Repeat:()=>I,SmoothStep:()=>P,ToHex:()=>k,WithinEpsilon:()=>a})},12371:(N,p,T)=>{T.r(p),T.d(p,{Matrix:()=>n,Quaternion:()=>L,TmpVectors:()=>g,Vector2:()=>k,xp:()=>x,Vector4:()=>I});var A=T(12376),a=T(12384),C=T(12331),U=T(12297),X=T(12231),y=T(12390);class e{}function H(N,p,T){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a=N.UX(),C=p.UX(),U=a[0],X=a[1],y=a[2],e=a[3],H=a[4],M=a[5],b=a[6],l=a[7],k=a[8],x=a[9],I=a[10],L=a[11],n=a[12],w=a[13],g=a[14],P=a[15],i=C[0],K=C[1],F=C[2],v=C[3],W=C[4],z=C[5],R=C[6],J=C[7],f=C[8],G=C[9],o=C[10],Z=C[11],mN=C[12],q=C[13],h=C[14],j=C[15];T[A]=U*i+X*W+y*f+e*mN,T[A+1]=U*K+X*z+y*G+e*q,T[A+2]=U*F+X*R+y*o+e*h,T[A+3]=U*v+X*J+y*Z+e*j,T[A+4]=H*i+M*W+b*f+l*mN,T[A+5]=H*K+M*z+b*G+l*q,T[A+6]=H*F+M*R+b*o+l*h,T[A+7]=H*v+M*J+b*Z+l*j,T[A+8]=k*i+x*W+I*f+L*mN,T[A+9]=k*K+x*z+I*G+L*q,T[A+10]=k*F+x*R+I*o+L*h,T[A+11]=k*v+x*J+I*Z+L*j,T[A+12]=n*i+w*W+g*f+P*mN,T[A+13]=n*K+w*z+g*G+P*q,T[A+14]=n*F+w*R+g*o+P*h,T[A+15]=n*v+w*J+g*Z+P*j}function M(N,p){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const A=N.UX();p[T]=A[0],p[T+1]=A[1],p[T+2]=A[2],p[T+3]=A[3],p[T+4]=A[4],p[T+5]=A[5],p[T+6]=A[6],p[T+7]=A[7],p[T+8]=A[8],p[T+9]=A[9],p[T+10]=A[10],p[T+11]=A[11],p[T+12]=A[12],p[T+13]=A[13],p[T+14]=A[14],p[T+15]=A[15]}function b(N,p){const T=N.UX(),A=T[0],a=T[1],C=T[2],U=T[3],X=T[4],y=T[5],e=T[6],H=T[7],M=T[8],b=T[9],l=T[10],k=T[11],x=T[12],I=T[13],L=T[14],n=T[15],w=l*n-L*k,g=b*n-I*k,P=b*L-I*l,i=M*n-x*k,K=M*L-l*x,F=M*I-x*b,v=+(y*w-e*g+H*P),W=-(X*w-e*i+H*K),z=+(X*g-y*i+H*F),R=-(X*P-y*K+e*F),J=A*v+a*W+C*z+U*R;if(0===J)return!1;const f=1/J,G=e*n-L*H,o=y*n-I*H,Z=y*L-I*e,mN=X*n-x*H,q=X*L-x*e,h=X*I-x*y,j=e*k-l*H,V=y*k-b*H,r=y*l-b*e,u=X*k-M*H,Y=X*l-M*e,D=X*b-M*y,c=-(a*w-C*g+U*P),Q=+(A*w-C*i+U*K),E=-(A*g-a*i+U*F),O=+(A*P-a*K+C*F),B=+(a*G-C*o+U*Z),d=-(A*G-C*mN+U*q),t=+(A*o-a*mN+U*h),S=-(A*Z-a*q+C*h),s=-(a*j-C*V+U*r),NN=+(A*j-C*u+U*Y),pN=-(A*V-a*u+U*D),TN=+(A*r-a*Y+C*D);return p[0]=v*f,p[1]=c*f,p[2]=B*f,p[3]=s*f,p[4]=W*f,p[5]=Q*f,p[6]=d*f,p[7]=NN*f,p[8]=z*f,p[9]=E*f,p[10]=t*f,p[11]=pN*f,p[12]=R*f,p[13]=O*f,p[14]=S*f,p[15]=TN*f,!0}e._UpdateFlagSeed=0;const l=N=>parseInt(N.toString().replace(/\W/g,""));class k{constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=N,this.y=p}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let N=l(this.x);return N=397*N^l(this.y),N}toArray(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[p]=this.x,N[p+1]=this.y,this}IT(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k.FromArrayToRef(N,p,this),this}UX(){return[this.x,this.y]}A(N){return this.x=N.x,this.y=N.y,this}kX(N,p){return this.x=N,this.y=p,this}set(N,p){return this.kX(N,p)}IX(N){return this.kX(N,N)}add(N){return new k(this.x+N.x,this.y+N.y)}addToRef(N,p){return p.x=this.x+N.x,p.y=this.y+N.y,p}addInPlace(N){return this.x+=N.x,this.y+=N.y,this}addInPlaceFromFloats(N,p){return this.x+=N,this.y+=p,this}addVector3(N){return new k(this.x+N.x,this.y+N.y)}Ip(N){return new k(this.x-N.x,this.y-N.y)}subtractToRef(N,p){return p.x=this.x-N.x,p.y=this.y-N.y,p}iM(N){return this.x-=N.x,this.y-=N.y,this}multiplyInPlace(N){return this.x*=N.x,this.y*=N.y,this}multiply(N){return new k(this.x*N.x,this.y*N.y)}multiplyToRef(N,p){return p.x=this.x*N.x,p.y=this.y*N.y,p}multiplyByFloats(N,p){return new k(this.x*N,this.y*p)}divide(N){return new k(this.x/N.x,this.y/N.y)}divideToRef(N,p){return p.x=this.x/N.x,p.y=this.y/N.y,p}divideInPlace(N){return this.x=this.x/N.x,this.y=this.y/N.y,this}minimizeInPlace(N){return this.minimizeInPlaceFromFloats(N.x,N.y)}maximizeInPlace(N){return this.maximizeInPlaceFromFloats(N.x,N.y)}minimizeInPlaceFromFloats(N,p){return this.x=Math.min(N,this.x),this.y=Math.min(p,this.y),this}maximizeInPlaceFromFloats(N,p){return this.x=Math.max(N,this.x),this.y=Math.max(p,this.y),this}subtractFromFloats(N,p){return new k(this.x-N,this.y-p)}subtractFromFloatsToRef(N,p,T){return T.x=this.x-N,T.y=this.y-p,T}negate(){return new k(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(N){return N.x=-this.x,N.y=-this.y,N}scaleInPlace(N){return this.x*=N,this.y*=N,this}scale(N){return new k(this.x*N,this.y*N)}scaleToRef(N,p){return p.x=this.x*N,p.y=this.y*N,p}scaleAndAddToRef(N,p){return p.x+=this.x*N,p.y+=this.y*N,p}equals(N){return N&&this.x===N.x&&this.y===N.y}equalsWithEpsilon(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.b;return N&&(0,y.WithinEpsilon)(this.x,N.x,p)&&(0,y.WithinEpsilon)(this.y,N.y,p)}equalsToFloats(N,p){return this.x===N&&this.y===p}floor(){return new k(Math.floor(this.x),Math.floor(this.y))}floorToRef(N){return N.x=Math.floor(this.x),N.y=Math.floor(this.y),N}fract(){return new k(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(N){return N.x=this.x-Math.floor(this.x),N.y=this.y-Math.floor(this.y),N}rotate(N){return this.rotateToRef(N,new k)}rotateToRef(N,p){const T=Math.cos(N),A=Math.sin(N);return p.x=T*this.x-A*this.y,p.y=A*this.x+T*this.y,p}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){const N=new k;return this.normalizeToRef(N),N}normalizeToRef(N){const p=this.length();return 0===p&&(N.x=this.x,N.y=this.y),this.scaleToRef(1/p,N)}clone(){return new k(this.x,this.y)}dot(N){return this.x*N.x+this.y*N.y}static Zero(){return new k(0,0)}static One(){return new k(1,1)}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new k((0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).kX((0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p))}static get ZeroReadOnly(){return k._ZeroReadOnly}static gp(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new k(N[p],N[p+1])}static FromArrayToRef(N,p,T){return T.x=N[p],T.y=N[p+1],T}static FromFloatsToRef(N,p,T){return T.kX(N,p),T}static CatmullRom(N,p,T,A,a){const C=a*a,U=a*C,X=.5*(2*p.x+(-N.x+T.x)*a+(2*N.x-5*p.x+4*T.x-A.x)*C+(-N.x+3*p.x-3*T.x+A.x)*U),y=.5*(2*p.y+(-N.y+T.y)*a+(2*N.y-5*p.y+4*T.y-A.y)*C+(-N.y+3*p.y-3*T.y+A.y)*U);return new k(X,y)}static ClampToRef(N,p,T,A){return A.x=(0,y.Clamp)(N.x,p.x,T.x),A.y=(0,y.Clamp)(N.y,p.y,T.y),A}static Clamp(N,p,T){const A=(0,y.Clamp)(N.x,p.x,T.x),a=(0,y.Clamp)(N.y,p.y,T.y);return new k(A,a)}static Hermite(N,p,T,A,a){const C=a*a,U=a*C,X=2*U-3*C+1,y=-2*U+3*C,e=U-2*C+a,H=U-C,M=N.x*X+T.x*y+p.x*e+A.x*H,b=N.y*X+T.y*y+p.y*e+A.y*H;return new k(M,b)}static Hermite1stDerivative(N,p,T,A,a){return this.Hermite1stDerivativeToRef(N,p,T,A,a,new k)}static Hermite1stDerivativeToRef(N,p,T,A,a,C){const U=a*a;return C.x=6*(U-a)*N.x+(3*U-4*a+1)*p.x+6*(-U+a)*T.x+(3*U-2*a)*A.x,C.y=6*(U-a)*N.y+(3*U-4*a+1)*p.y+6*(-U+a)*T.y+(3*U-2*a)*A.y,C}static Lerp(N,p,T){return k.LerpToRef(N,p,T,new k)}static LerpToRef(N,p,T,A){return A.x=N.x+(p.x-N.x)*T,A.y=N.y+(p.y-N.y)*T,A}static Dot(N,p){return N.x*p.x+N.y*p.y}static Normalize(N){return k.NormalizeToRef(N,new k)}static NormalizeToRef(N,p){return N.normalizeToRef(p),p}static Minimize(N,p){const T=N.x<p.x?N.x:p.x,A=N.y<p.y?N.y:p.y;return new k(T,A)}static Maximize(N,p){const T=N.x>p.x?N.x:p.x,A=N.y>p.y?N.y:p.y;return new k(T,A)}static Transform(N,p){return k.TransformToRef(N,p,new k)}static TransformToRef(N,p,T){const A=p.m,a=N.x*A[0]+N.y*A[4]+A[12],C=N.x*A[1]+N.y*A[5]+A[13];return T.x=a,T.y=C,T}static PointInTriangle(N,p,T,A){const a=.5*(-T.y*A.x+p.y*(-T.x+A.x)+p.x*(T.y-A.y)+T.x*A.y),C=a<0?-1:1,U=(p.y*A.x-p.x*A.y+(A.y-p.y)*N.x+(p.x-A.x)*N.y)*C,X=(p.x*T.y-p.y*T.x+(p.y-T.y)*N.x+(T.x-p.x)*N.y)*C;return U>0&&X>0&&U+X<2*a*C}static Distance(N,p){return Math.sqrt(k.DistanceSquared(N,p))}static DistanceSquared(N,p){const T=N.x-p.x,A=N.y-p.y;return T*T+A*A}static Center(N,p){return k.CenterToRef(N,p,new k)}static CenterToRef(N,p,T){return T.kX((N.x+p.x)/2,(N.y+p.y)/2)}static DistanceOfPointFromSegment(N,p,T){const A=k.DistanceSquared(p,T);if(0===A)return k.Distance(N,p);const a=T.Ip(p),C=Math.max(0,Math.min(1,k.Dot(N.Ip(p),a)/A)),U=p.add(a.multiplyByFloats(C,C));return k.Distance(N,U)}}k._V8PerformanceHack=new k(.5,.5),k._ZeroReadOnly=k.Zero(),Object.defineProperties(k.prototype,{dimension:{value:[2]},rank:{value:1}});class x{get x(){return this._x}set x(N){this._x=N,this._isDirty=!0}get y(){return this._y}set y(N){this._y=N,this._isDirty=!0}get z(){return this._z}set z(N){this._z=N,this._isDirty=!0}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=N,this._y=p,this._z=T}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"xp"}getHashCode(){let N=l(this._x);return N=397*N^l(this._y),N=397*N^l(this._z),N}UX(){return[this._x,this._y,this._z]}toArray(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[p]=this._x,N[p+1]=this._y,N[p+2]=this._z,this}IT(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return x.FromArrayToRef(N,p,this),this}toQuaternion(){return L.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(N){return this._x+=N._x,this._y+=N._y,this._z+=N._z,this._isDirty=!0,this}addInPlaceFromFloats(N,p,T){return this._x+=N,this._y+=p,this._z+=T,this._isDirty=!0,this}add(N){return new x(this._x+N._x,this._y+N._y,this._z+N._z)}addToRef(N,p){return p._x=this._x+N._x,p._y=this._y+N._y,p._z=this._z+N._z,p._isDirty=!0,p}iM(N){return this._x-=N._x,this._y-=N._y,this._z-=N._z,this._isDirty=!0,this}Ip(N){return new x(this._x-N._x,this._y-N._y,this._z-N._z)}subtractToRef(N,p){return this.subtractFromFloatsToRef(N._x,N._y,N._z,p)}subtractFromFloats(N,p,T){return new x(this._x-N,this._y-p,this._z-T)}subtractFromFloatsToRef(N,p,T,A){return A._x=this._x-N,A._y=this._y-p,A._z=this._z-T,A._isDirty=!0,A}negate(){return new x(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(N){return N._x=-1*this._x,N._y=-1*this._y,N._z=-1*this._z,N._isDirty=!0,N}scaleInPlace(N){return this._x*=N,this._y*=N,this._z*=N,this._isDirty=!0,this}scale(N){return new x(this._x*N,this._y*N,this._z*N)}scaleToRef(N,p){return p._x=this._x*N,p._y=this._y*N,p._z=this._z*N,p._isDirty=!0,p}getNormalToRef(N){const p=this.length();let T=Math.acos(this._y/p);const A=Math.atan2(this._z,this._x);T>Math.PI/2?T-=Math.PI/2:T+=Math.PI/2;const a=p*Math.sin(T)*Math.cos(A),C=p*Math.cos(T),U=p*Math.sin(T)*Math.sin(A);return N.set(a,C,U),N}applyRotationQuaternionToRef(N,p){const T=this._x,A=this._y,a=this._z,C=N._x,U=N._y,X=N._z,y=N._w,e=2*(U*a-X*A),H=2*(X*T-C*a),M=2*(C*A-U*T);return p._x=T+y*e+U*M-X*H,p._y=A+y*H+X*e-C*M,p._z=a+y*M+C*H-U*e,p._isDirty=!0,p}applyRotationQuaternionInPlace(N){return this.applyRotationQuaternionToRef(N,this)}applyRotationQuaternion(N){return this.applyRotationQuaternionToRef(N,new x)}scaleAndAddToRef(N,p){return p._x+=this._x*N,p._y+=this._y*N,p._z+=this._z*N,p._isDirty=!0,p}projectOnPlane(N,p){return this.projectOnPlaneToRef(N,p,new x)}projectOnPlaneToRef(N,p,T){const A=N.normal,a=N.d,C=w.xp[0];this.subtractToRef(p,C),C.normalize();const U=x.Dot(C,A);if(Math.abs(U)<1e-10)T.IX(1/0);else{const N=-(x.Dot(p,A)+a)/U,X=C.scaleInPlace(N);p.addToRef(X,T)}return T}equals(N){return N&&this._x===N._x&&this._y===N._y&&this._z===N._z}equalsWithEpsilon(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.b;return N&&(0,y.WithinEpsilon)(this._x,N._x,p)&&(0,y.WithinEpsilon)(this._y,N._y,p)&&(0,y.WithinEpsilon)(this._z,N._z,p)}equalsToFloats(N,p,T){return this._x===N&&this._y===p&&this._z===T}multiplyInPlace(N){return this._x*=N._x,this._y*=N._y,this._z*=N._z,this._isDirty=!0,this}multiply(N){return this.multiplyByFloats(N._x,N._y,N._z)}multiplyToRef(N,p){return p._x=this._x*N._x,p._y=this._y*N._y,p._z=this._z*N._z,p._isDirty=!0,p}multiplyByFloats(N,p,T){return new x(this._x*N,this._y*p,this._z*T)}divide(N){return new x(this._x/N._x,this._y/N._y,this._z/N._z)}divideToRef(N,p){return p._x=this._x/N._x,p._y=this._y/N._y,p._z=this._z/N._z,p._isDirty=!0,p}divideInPlace(N){return this._x=this._x/N._x,this._y=this._y/N._y,this._z=this._z/N._z,this._isDirty=!0,this}minimizeInPlace(N){return this.minimizeInPlaceFromFloats(N._x,N._y,N._z)}maximizeInPlace(N){return this.maximizeInPlaceFromFloats(N._x,N._y,N._z)}minimizeInPlaceFromFloats(N,p,T){return N<this._x&&(this.x=N),p<this._y&&(this.y=p),T<this._z&&(this.z=T),this}maximizeInPlaceFromFloats(N,p,T){return N>this._x&&(this.x=N),p>this._y&&(this.y=p),T>this._z&&(this.z=T),this}isNonUniformWithinEpsilon(N){const p=Math.abs(this._x),T=Math.abs(this._y);if(!(0,y.WithinEpsilon)(p,T,N))return!0;const A=Math.abs(this._z);return!(0,y.WithinEpsilon)(p,A,N)||!(0,y.WithinEpsilon)(T,A,N)}get isNonUniform(){const N=Math.abs(this._x);if(N!==Math.abs(this._y))return!0;return N!==Math.abs(this._z)}floorToRef(N){return N._x=Math.floor(this._x),N._y=Math.floor(this._y),N._z=Math.floor(this._z),N._isDirty=!0,N}floor(){return new x(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(N){return N._x=this._x-Math.floor(this._x),N._y=this._y-Math.floor(this._y),N._z=this._z-Math.floor(this._z),N._isDirty=!0,N}fract(){return new x(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(N){if("xyz"===(N=N.toLowerCase()))return this;const p=w.xp[0].A(this);return this.x=p[N[0]],this.y=p[N[1]],this.z=p[N[2]],this}rotateByQuaternionToRef(N,p){return N.toRotationMatrix(w.Matrix[0]),x.TransformCoordinatesToRef(this,w.Matrix[0],p),p}rotateByQuaternionAroundPointToRef(N,p,T){return this.subtractToRef(p,w.xp[0]),w.xp[0].rotateByQuaternionToRef(N,w.xp[0]),p.addToRef(w.xp[0],T),T}cross(N){return x.CrossToRef(this,N,new x)}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){return this.normalizeToRef(new x)}normalizeToRef(N){const p=this.length();return 0===p||1===p?(N._x=this._x,N._y=this._y,N._z=this._z,N._isDirty=!0,N):this.scaleToRef(1/p,N)}clone(){return new x(this._x,this._y,this._z)}A(N){return this.kX(N._x,N._y,N._z)}kX(N,p,T){return this._x=N,this._y=p,this._z=T,this._isDirty=!0,this}set(N,p,T){return this.kX(N,p,T)}IX(N){return this._x=this._y=this._z=N,this._isDirty=!0,this}static GetClipFactor(N,p,T,A){const a=x.Dot(N,T);return(a-A)/(a-x.Dot(p,T))}static GetAngleBetweenVectors(N,p,T){const A=N.normalizeToRef(w.xp[1]),a=p.normalizeToRef(w.xp[2]);let C=x.Dot(A,a);C=(0,y.Clamp)(C,-1,1);const U=Math.acos(C),X=w.xp[3];return x.CrossToRef(A,a,X),x.Dot(X,T)>0?isNaN(U)?0:U:isNaN(U)?-Math.PI:-Math.acos(C)}static GetAngleBetweenVectorsOnPlane(N,p,T){w.xp[0].A(N);const A=w.xp[0];w.xp[1].A(p);const a=w.xp[1];w.xp[2].A(T);const C=w.xp[2],U=w.xp[3],X=w.xp[4];A.normalize(),a.normalize(),C.normalize(),x.CrossToRef(C,A,U),x.CrossToRef(U,C,X);const e=Math.atan2(x.Dot(a,U),x.Dot(a,X));return(0,y.NormalizeRadians)(e)}static PitchYawRollToMoveBetweenPointsToRef(N,p,T){const A=g.xp[0];return p.subtractToRef(N,A),T._y=Math.atan2(A.x,A.z)||0,T._x=Math.atan2(Math.sqrt(A.x**2+A.z**2),A.y)||0,T._z=0,T._isDirty=!0,T}static PitchYawRollToMoveBetweenPoints(N,p){const T=x.Zero();return x.PitchYawRollToMoveBetweenPointsToRef(N,p,T)}static SlerpToRef(N,p,T,a){T=(0,y.Clamp)(T,0,1);const C=w.xp[0],U=w.xp[1];C.A(N);const X=C.length();C.normalizeFromLength(X),U.A(p);const e=U.length();U.normalizeFromLength(e);const H=x.Dot(C,U);let M,b;if(H<1-A.b){const N=Math.acos(H),p=1/Math.sin(N);M=Math.sin((1-T)*N)*p,b=Math.sin(T*N)*p}else M=1-T,b=T;return C.scaleInPlace(M),U.scaleInPlace(b),a.A(C).addInPlace(U),a.scaleInPlace((0,y.Lerp)(X,e,T)),a}static SmoothToRef(N,p,T,A,a){return x.SlerpToRef(N,p,0===A?1:T/A,a),a}static gp(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new x(N[p],N[p+1],N[p+2])}static FromFloatArray(N,p){return x.gp(N,p)}static FromArrayToRef(N,p,T){return T._x=N[p],T._y=N[p+1],T._z=N[p+2],T._isDirty=!0,T}static FromFloatArrayToRef(N,p,T){return x.FromArrayToRef(N,p,T)}static FromFloatsToRef(N,p,T,A){return A.kX(N,p,T),A}static Zero(){return new x(0,0,0)}static One(){return new x(1,1,1)}static Up(){return new x(0,1,0)}static get UpReadOnly(){return x._UpReadOnly}static get DownReadOnly(){return x._DownReadOnly}static get RightReadOnly(){return x._RightReadOnly}static get LeftReadOnly(){return x._LeftReadOnly}static get LeftHandedForwardReadOnly(){return x._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return x._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return x._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return x._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return x._ZeroReadOnly}static get OneReadOnly(){return x._OneReadOnly}static Down(){return new x(0,-1,0)}static Forward(){return new x(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new x(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new x(1,0,0)}static Left(){return new x(-1,0,0)}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new x((0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).kX((0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p))}static TransformCoordinates(N,p){const T=x.Zero();return x.TransformCoordinatesToRef(N,p,T),T}static TransformCoordinatesToRef(N,p,T){return x.TransformCoordinatesFromFloatsToRef(N._x,N._y,N._z,p,T),T}static TransformCoordinatesFromFloatsToRef(N,p,T,A,a){const C=A.m,U=N*C[0]+p*C[4]+T*C[8]+C[12],X=N*C[1]+p*C[5]+T*C[9]+C[13],y=N*C[2]+p*C[6]+T*C[10]+C[14],e=1/(N*C[3]+p*C[7]+T*C[11]+C[15]);return a._x=U*e,a._y=X*e,a._z=y*e,a._isDirty=!0,a}static TransformNormal(N,p){const T=x.Zero();return x.TransformNormalToRef(N,p,T),T}static TransformNormalToRef(N,p,T){return this.TransformNormalFromFloatsToRef(N._x,N._y,N._z,p,T),T}static TransformNormalFromFloatsToRef(N,p,T,A,a){const C=A.m;return a._x=N*C[0]+p*C[4]+T*C[8],a._y=N*C[1]+p*C[5]+T*C[9],a._z=N*C[2]+p*C[6]+T*C[10],a._isDirty=!0,a}static CatmullRom(N,p,T,A,a){const C=a*a,U=a*C,X=.5*(2*p._x+(-N._x+T._x)*a+(2*N._x-5*p._x+4*T._x-A._x)*C+(-N._x+3*p._x-3*T._x+A._x)*U),y=.5*(2*p._y+(-N._y+T._y)*a+(2*N._y-5*p._y+4*T._y-A._y)*C+(-N._y+3*p._y-3*T._y+A._y)*U),e=.5*(2*p._z+(-N._z+T._z)*a+(2*N._z-5*p._z+4*T._z-A._z)*C+(-N._z+3*p._z-3*T._z+A._z)*U);return new x(X,y,e)}static Clamp(N,p,T){const A=new x;return x.ClampToRef(N,p,T,A),A}static ClampToRef(N,p,T,A){let a=N._x;a=a>T._x?T._x:a,a=a<p._x?p._x:a;let C=N._y;C=C>T._y?T._y:C,C=C<p._y?p._y:C;let U=N._z;return U=U>T._z?T._z:U,U=U<p._z?p._z:U,A.kX(a,C,U),A}static CheckExtends(N,p,T){p.minimizeInPlace(N),T.maximizeInPlace(N)}static Hermite(N,p,T,A,a){const C=a*a,U=a*C,X=2*U-3*C+1,y=-2*U+3*C,e=U-2*C+a,H=U-C,M=N._x*X+T._x*y+p._x*e+A._x*H,b=N._y*X+T._y*y+p._y*e+A._y*H,l=N._z*X+T._z*y+p._z*e+A._z*H;return new x(M,b,l)}static Hermite1stDerivative(N,p,T,A,a){const C=new x;return this.Hermite1stDerivativeToRef(N,p,T,A,a,C),C}static Hermite1stDerivativeToRef(N,p,T,A,a,C){const U=a*a;return C._x=6*(U-a)*N._x+(3*U-4*a+1)*p._x+6*(-U+a)*T._x+(3*U-2*a)*A._x,C._y=6*(U-a)*N._y+(3*U-4*a+1)*p._y+6*(-U+a)*T._y+(3*U-2*a)*A._y,C._z=6*(U-a)*N._z+(3*U-4*a+1)*p._z+6*(-U+a)*T._z+(3*U-2*a)*A._z,C._isDirty=!0,C}static Lerp(N,p,T){const A=new x(0,0,0);return x.LerpToRef(N,p,T,A),A}static LerpToRef(N,p,T,A){return A._x=N._x+(p._x-N._x)*T,A._y=N._y+(p._y-N._y)*T,A._z=N._z+(p._z-N._z)*T,A._isDirty=!0,A}static Dot(N,p){return N._x*p._x+N._y*p._y+N._z*p._z}dot(N){return this._x*N._x+this._y*N._y+this._z*N._z}static Cross(N,p){const T=new x;return x.CrossToRef(N,p,T),T}static CrossToRef(N,p,T){const A=N._y*p._z-N._z*p._y,a=N._z*p._x-N._x*p._z,C=N._x*p._y-N._y*p._x;return T.kX(A,a,C),T}static Normalize(N){const p=x.Zero();return x.NormalizeToRef(N,p),p}static NormalizeToRef(N,p){return N.normalizeToRef(p),p}static Project(N,p,T,A){const a=new x;return x.ProjectToRef(N,p,T,A,a),a}static ProjectToRef(N,p,T,A,a){var C;const U=A.width,y=A.height,e=A.x,H=A.y,M=w.Matrix[1],b=null===(C=X.b.LastCreatedEngine)||void 0===C?void 0:C.isNDCHalfZRange,l=b?1:.5,k=b?0:.5;n.FromValuesToRef(U/2,0,0,0,0,-y/2,0,0,0,0,l,0,e+U/2,y/2+H,k,1,M);const I=w.Matrix[0];return p.multiplyToRef(T,I),I.multiplyToRef(M,I),x.TransformCoordinatesToRef(N,I,a),a}static Reflect(N,p){return this.ReflectToRef(N,p,new x)}static ReflectToRef(N,p,T){const A=g.xp[0];return A.A(p).scaleInPlace(2*x.Dot(N,p)),T.A(N).iM(A)}static _UnprojectFromInvertedMatrixToRef(N,p,T){x.TransformCoordinatesToRef(N,p,T);const A=p.m,a=N._x*A[3]+N._y*A[7]+N._z*A[11]+A[15];return(0,y.WithinEpsilon)(a,1)&&T.scaleInPlace(1/a),T}static UnprojectFromTransform(N,p,T,A,a){return this.Unproject(N,p,T,A,a,n.IdentityReadOnly)}static Unproject(N,p,T,A,a,C){const U=new x;return x.UnprojectToRef(N,p,T,A,a,C,U),U}static UnprojectToRef(N,p,T,A,a,C,U){return x.UnprojectFloatsToRef(N._x,N._y,N._z,p,T,A,a,C,U),U}static UnprojectFloatsToRef(N,p,T,A,a,C,U,y,e){var H;const M=w.Matrix[0];C.multiplyToRef(U,M),M.multiplyToRef(y,M),M.invert();const b=w.xp[0];return b.x=N/A*2-1,b.y=-(p/a*2-1),null!==(H=X.b.LastCreatedEngine)&&void 0!==H&&H.isNDCHalfZRange?b.z=T:b.z=2*T-1,x._UnprojectFromInvertedMatrixToRef(b,M,e),e}static Minimize(N,p){const T=new x;return T.A(N),T.minimizeInPlace(p),T}static Maximize(N,p){const T=new x;return T.A(N),T.maximizeInPlace(p),T}static Distance(N,p){return Math.sqrt(x.DistanceSquared(N,p))}static DistanceSquared(N,p){const T=N._x-p._x,A=N._y-p._y,a=N._z-p._z;return T*T+A*A+a*a}static ProjectOnTriangleToRef(N,p,T,a,C){const U=w.xp[0],X=w.xp[1],e=w.xp[2],H=w.xp[3],M=w.xp[4];T.subtractToRef(p,U),a.subtractToRef(p,X),a.subtractToRef(T,e);const b=U.length(),l=X.length(),k=e.length();if(b<A.b||l<A.b||k<A.b)return C.A(p),x.Distance(N,p);N.subtractToRef(p,M),x.CrossToRef(U,X,H);const I=H.length();if(I<A.b)return C.A(p),x.Distance(N,p);H.normalizeFromLength(I);let L=M.length();if(L<A.b)return C.A(p),0;M.normalizeFromLength(L);const n=x.Dot(H,M),g=w.xp[5],P=w.xp[6];g.A(H).scaleInPlace(-L*n),P.A(N).addInPlace(g);const i=w.xp[4],K=w.xp[5],F=w.xp[7],v=w.xp[8];i.A(U).scaleInPlace(1/b),v.A(X).scaleInPlace(1/l),i.addInPlace(v).scaleInPlace(-1),K.A(U).scaleInPlace(-1/b),v.A(e).scaleInPlace(1/k),K.addInPlace(v).scaleInPlace(-1),F.A(e).scaleInPlace(-1/k),v.A(X).scaleInPlace(-1/l),F.addInPlace(v).scaleInPlace(-1);const W=w.xp[9];let z;W.A(P).iM(p),x.CrossToRef(i,W,v),z=x.Dot(v,H);const R=z;W.A(P).iM(T),x.CrossToRef(K,W,v),z=x.Dot(v,H);const J=z;W.A(P).iM(a),x.CrossToRef(F,W,v),z=x.Dot(v,H);const f=z,G=w.xp[10];let o,Z;R>0&&J<0?(G.A(U),o=p,Z=T):J>0&&f<0?(G.A(e),o=T,Z=a):(G.A(X).scaleInPlace(-1),o=a,Z=p);const mN=w.xp[9],q=w.xp[4];o.subtractToRef(P,v),Z.subtractToRef(P,mN),x.CrossToRef(v,mN,q);if(!(x.Dot(q,H)<0))return C.A(P),Math.abs(L*n);const h=w.xp[5];x.CrossToRef(G,q,h),h.normalize();const j=w.xp[9];j.A(o).iM(P);const V=j.length();if(V<A.b)return C.A(o),x.Distance(N,o);j.normalizeFromLength(V);const r=x.Dot(h,j),u=w.xp[7];u.A(P).addInPlace(h.scaleInPlace(V*r)),v.A(u).iM(o),L=G.length(),G.normalizeFromLength(L);let Y=x.Dot(v,G)/Math.max(L,A.b);return Y=(0,y.Clamp)(Y,0,1),u.A(o).addInPlace(G.scaleInPlace(Y*L)),C.A(u),x.Distance(N,u)}static Center(N,p){return x.CenterToRef(N,p,x.Zero())}static CenterToRef(N,p,T){return T.kX((N._x+p._x)/2,(N._y+p._y)/2,(N._z+p._z)/2)}static RotationFromAxis(N,p,T){const A=new x;return x.RotationFromAxisToRef(N,p,T,A),A}static RotationFromAxisToRef(N,p,T,A){const a=w.Quaternion[0];return L.RotationQuaternionFromAxisToRef(N,p,T,a),a.toEulerAnglesToRef(A),A}}x._V8PerformanceHack=new x(.5,.5,.5),x._UpReadOnly=x.Up(),x._DownReadOnly=x.Down(),x._LeftHandedForwardReadOnly=x.Forward(!1),x._RightHandedForwardReadOnly=x.Forward(!0),x._LeftHandedBackwardReadOnly=x.Backward(!1),x._RightHandedBackwardReadOnly=x.Backward(!0),x._RightReadOnly=x.Right(),x._LeftReadOnly=x.Left(),x._ZeroReadOnly=x.Zero(),x._OneReadOnly=x.One(),Object.defineProperties(x.prototype,{dimension:{value:[3]},rank:{value:1}});class I{get x(){return this._x}set x(N){this._x=N,this._isDirty=!0}get y(){return this._y}set y(N){this._y=N,this._isDirty=!0}get z(){return this._z}set z(N){this._z=N,this._isDirty=!0}get w(){return this._w}set w(N){this._w=N,this._isDirty=!0}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=N,this._y=p,this._z=T,this._w=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let N=l(this._x);return N=397*N^l(this._y),N=397*N^l(this._z),N=397*N^l(this._w),N}UX(){return[this._x,this._y,this._z,this._w]}toArray(N,p){return void 0===p&&(p=0),N[p]=this._x,N[p+1]=this._y,N[p+2]=this._z,N[p+3]=this._w,this}IT(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I.FromArrayToRef(N,p,this),this}addInPlace(N){return this.x+=N._x,this.y+=N._y,this.z+=N._z,this.w+=N._w,this}addInPlaceFromFloats(N,p,T,A){return this.x+=N,this.y+=p,this.z+=T,this.w+=A,this}add(N){return new I(this._x+N.x,this._y+N.y,this._z+N.z,this._w+N.w)}addToRef(N,p){return p.x=this._x+N.x,p.y=this._y+N.y,p.z=this._z+N.z,p.w=this._w+N.w,p}iM(N){return this.x-=N.x,this.y-=N.y,this.z-=N.z,this.w-=N.w,this}Ip(N){return new I(this._x-N.x,this._y-N.y,this._z-N.z,this._w-N.w)}subtractToRef(N,p){return p.x=this._x-N.x,p.y=this._y-N.y,p.z=this._z-N.z,p.w=this._w-N.w,p}subtractFromFloats(N,p,T,A){return new I(this._x-N,this._y-p,this._z-T,this._w-A)}subtractFromFloatsToRef(N,p,T,A,a){return a.x=this._x-N,a.y=this._y-p,a.z=this._z-T,a.w=this._w-A,a}negate(){return new I(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(N){return N.x=-this._x,N.y=-this._y,N.z=-this._z,N.w=-this._w,N}scaleInPlace(N){return this.x*=N,this.y*=N,this.z*=N,this.w*=N,this}scale(N){return new I(this._x*N,this._y*N,this._z*N,this._w*N)}scaleToRef(N,p){return p.x=this._x*N,p.y=this._y*N,p.z=this._z*N,p.w=this._w*N,p}scaleAndAddToRef(N,p){return p.x+=this._x*N,p.y+=this._y*N,p.z+=this._z*N,p.w+=this._w*N,p}equals(N){return N&&this._x===N.x&&this._y===N.y&&this._z===N.z&&this._w===N.w}equalsWithEpsilon(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.b;return N&&(0,y.WithinEpsilon)(this._x,N.x,p)&&(0,y.WithinEpsilon)(this._y,N.y,p)&&(0,y.WithinEpsilon)(this._z,N.z,p)&&(0,y.WithinEpsilon)(this._w,N.w,p)}equalsToFloats(N,p,T,A){return this._x===N&&this._y===p&&this._z===T&&this._w===A}multiplyInPlace(N){return this.x*=N.x,this.y*=N.y,this.z*=N.z,this.w*=N.w,this}multiply(N){return new I(this._x*N.x,this._y*N.y,this._z*N.z,this._w*N.w)}multiplyToRef(N,p){return p.x=this._x*N.x,p.y=this._y*N.y,p.z=this._z*N.z,p.w=this._w*N.w,p}multiplyByFloats(N,p,T,A){return new I(this._x*N,this._y*p,this._z*T,this._w*A)}divide(N){return new I(this._x/N.x,this._y/N.y,this._z/N.z,this._w/N.w)}divideToRef(N,p){return p.x=this._x/N.x,p.y=this._y/N.y,p.z=this._z/N.z,p.w=this._w/N.w,p}divideInPlace(N){return this.divideToRef(N,this)}minimizeInPlace(N){return N.x<this._x&&(this.x=N.x),N.y<this._y&&(this.y=N.y),N.z<this._z&&(this.z=N.z),N.w<this._w&&(this.w=N.w),this}maximizeInPlace(N){return N.x>this._x&&(this.x=N.x),N.y>this._y&&(this.y=N.y),N.z>this._z&&(this.z=N.z),N.w>this._w&&(this.w=N.w),this}minimizeInPlaceFromFloats(N,p,T,A){return this.x=Math.min(N,this._x),this.y=Math.min(p,this._y),this.z=Math.min(T,this._z),this.w=Math.min(A,this._w),this}maximizeInPlaceFromFloats(N,p,T,A){return this.x=Math.max(N,this._x),this.y=Math.max(p,this._y),this.z=Math.max(T,this._z),this.w=Math.max(A,this._w),this}floorToRef(N){return N.x=Math.floor(this._x),N.y=Math.floor(this._y),N.z=Math.floor(this._z),N.w=Math.floor(this._w),N}floor(){return new I(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(N){return N.x=this._x-Math.floor(this._x),N.y=this._y-Math.floor(this._y),N.z=this._z-Math.floor(this._z),N.w=this._w-Math.floor(this._w),N}fract(){return new I(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){return this.normalizeToRef(new I)}normalizeToRef(N){const p=this.length();return 0===p||1===p?(N.x=this._x,N.y=this._y,N.z=this._z,N.w=this._w,N):this.scaleToRef(1/p,N)}toVector3(){return new x(this._x,this._y,this._z)}clone(){return new I(this._x,this._y,this._z,this._w)}A(N){return this.x=N.x,this.y=N.y,this.z=N.z,this.w=N.w,this}kX(N,p,T,A){return this.x=N,this.y=p,this.z=T,this.w=A,this}set(N,p,T,A){return this.kX(N,p,T,A)}IX(N){return this.x=this.y=this.z=this.w=N,this}dot(N){return this._x*N.x+this._y*N.y+this._z*N.z+this._w*N.w}static gp(N,p){return p||(p=0),new I(N[p],N[p+1],N[p+2],N[p+3])}static FromArrayToRef(N,p,T){return T.x=N[p],T.y=N[p+1],T.z=N[p+2],T.w=N[p+3],T}static FromFloatArrayToRef(N,p,T){return I.FromArrayToRef(N,p,T),T}static FromFloatsToRef(N,p,T,A,a){return a.x=N,a.y=p,a.z=T,a.w=A,a}static Zero(){return new I(0,0,0,0)}static One(){return new I(1,1,1,1)}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new I((0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0;return T.x=(0,y.RandomRange)(N,p),T.y=(0,y.RandomRange)(N,p),T.z=(0,y.RandomRange)(N,p),T.w=(0,y.RandomRange)(N,p),T}static Clamp(N,p,T){return I.ClampToRef(N,p,T,new I)}static ClampToRef(N,p,T,A){return A.x=(0,y.Clamp)(N.x,p.x,T.x),A.y=(0,y.Clamp)(N.y,p.y,T.y),A.z=(0,y.Clamp)(N.z,p.z,T.z),A.w=(0,y.Clamp)(N.w,p.w,T.w),A}static CheckExtends(N,p,T){p.minimizeInPlace(N),T.maximizeInPlace(N)}static get ZeroReadOnly(){return I._ZeroReadOnly}static Normalize(N){return I.NormalizeToRef(N,new I)}static NormalizeToRef(N,p){return N.normalizeToRef(p),p}static Minimize(N,p){const T=new I;return T.A(N),T.minimizeInPlace(p),T}static Maximize(N,p){const T=new I;return T.A(N),T.maximizeInPlace(p),T}static Distance(N,p){return Math.sqrt(I.DistanceSquared(N,p))}static DistanceSquared(N,p){const T=N.x-p.x,A=N.y-p.y,a=N.z-p.z,C=N.w-p.w;return T*T+A*A+a*a+C*C}static Center(N,p){return I.CenterToRef(N,p,new I)}static CenterToRef(N,p,T){return T.x=(N.x+p.x)/2,T.y=(N.y+p.y)/2,T.z=(N.z+p.z)/2,T.w=(N.w+p.w)/2,T}static TransformCoordinates(N,p){return I.TransformCoordinatesToRef(N,p,new I)}static TransformCoordinatesToRef(N,p,T){return I.TransformCoordinatesFromFloatsToRef(N._x,N._y,N._z,p,T),T}static TransformCoordinatesFromFloatsToRef(N,p,T,A,a){const C=A.m,U=N*C[0]+p*C[4]+T*C[8]+C[12],X=N*C[1]+p*C[5]+T*C[9]+C[13],y=N*C[2]+p*C[6]+T*C[10]+C[14],e=N*C[3]+p*C[7]+T*C[11]+C[15];return a.x=U,a.y=X,a.z=y,a.w=e,a}static TransformNormal(N,p){return I.TransformNormalToRef(N,p,new I)}static TransformNormalToRef(N,p,T){const A=p.m,a=N.x*A[0]+N.y*A[4]+N.z*A[8],C=N.x*A[1]+N.y*A[5]+N.z*A[9],U=N.x*A[2]+N.y*A[6]+N.z*A[10];return T.x=a,T.y=C,T.z=U,T.w=N.w,T}static TransformNormalFromFloatsToRef(N,p,T,A,a,C){const U=a.m;return C.x=N*U[0]+p*U[4]+T*U[8],C.y=N*U[1]+p*U[5]+T*U[9],C.z=N*U[2]+p*U[6]+T*U[10],C.w=A,C}static FromVector3(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new I(N._x,N._y,N._z,p)}static Dot(N,p){return N.x*p.x+N.y*p.y+N.z*p.z+N.w*p.w}}I._V8PerformanceHack=new I(.5,.5,.5,.5),I._ZeroReadOnly=I.Zero(),Object.defineProperties(I.prototype,{dimension:{value:[4]},rank:{value:1}});class L{get x(){return this._x}set x(N){this._x=N,this._isDirty=!0}get y(){return this._y}set y(N){this._y=N,this._isDirty=!0}get z(){return this._z}set z(N){this._z=N,this._isDirty=!0}get w(){return this._w}set w(N){this._w=N,this._isDirty=!0}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=N,this._y=p,this._z=T,this._w=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let N=l(this._x);return N=397*N^l(this._y),N=397*N^l(this._z),N=397*N^l(this._w),N}UX(){return[this._x,this._y,this._z,this._w]}toArray(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[p]=this._x,N[p+1]=this._y,N[p+2]=this._z,N[p+3]=this._w,this}IT(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(N,p,this)}equals(N){return N&&this._x===N._x&&this._y===N._y&&this._z===N._z&&this._w===N._w}equalsWithEpsilon(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.b;return N&&(0,y.WithinEpsilon)(this._x,N._x,p)&&(0,y.WithinEpsilon)(this._y,N._y,p)&&(0,y.WithinEpsilon)(this._z,N._z,p)&&(0,y.WithinEpsilon)(this._w,N._w,p)}isApprox(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.b;return N&&((0,y.WithinEpsilon)(this._x,N._x,p)&&(0,y.WithinEpsilon)(this._y,N._y,p)&&(0,y.WithinEpsilon)(this._z,N._z,p)&&(0,y.WithinEpsilon)(this._w,N._w,p)||(0,y.WithinEpsilon)(this._x,-N._x,p)&&(0,y.WithinEpsilon)(this._y,-N._y,p)&&(0,y.WithinEpsilon)(this._z,-N._z,p)&&(0,y.WithinEpsilon)(this._w,-N._w,p))}clone(){return new L(this._x,this._y,this._z,this._w)}A(N){return this._x=N._x,this._y=N._y,this._z=N._z,this._w=N._w,this._isDirty=!0,this}kX(N,p,T,A){return this._x=N,this._y=p,this._z=T,this._w=A,this._isDirty=!0,this}set(N,p,T,A){return this.kX(N,p,T,A)}IX(N){return this.kX(N,N,N,N)}add(N){return new L(this._x+N._x,this._y+N._y,this._z+N._z,this._w+N._w)}addInPlace(N){return this._x+=N._x,this._y+=N._y,this._z+=N._z,this._w+=N._w,this._isDirty=!0,this}addToRef(N,p){return p._x=this._x+N._x,p._y=this._y+N._y,p._z=this._z+N._z,p._w=this._w+N._w,p._isDirty=!0,p}addInPlaceFromFloats(N,p,T,A){return this._x+=N,this._y+=p,this._z+=T,this._w+=A,this._isDirty=!0,this}subtractToRef(N,p){return p._x=this._x-N._x,p._y=this._y-N._y,p._z=this._z-N._z,p._w=this._w-N._w,p._isDirty=!0,p}subtractFromFloats(N,p,T,A){return this.subtractFromFloatsToRef(N,p,T,A,new L)}subtractFromFloatsToRef(N,p,T,A,a){return a._x=this._x-N,a._y=this._y-p,a._z=this._z-T,a._w=this._w-A,a._isDirty=!0,a}Ip(N){return new L(this._x-N._x,this._y-N._y,this._z-N._z,this._w-N._w)}iM(N){return this._x-=N._x,this._y-=N._y,this._z-=N._z,this._w-=N._w,this._isDirty=!0,this}scale(N){return new L(this._x*N,this._y*N,this._z*N,this._w*N)}scaleToRef(N,p){return p._x=this._x*N,p._y=this._y*N,p._z=this._z*N,p._w=this._w*N,p._isDirty=!0,p}scaleInPlace(N){return this._x*=N,this._y*=N,this._z*=N,this._w*=N,this._isDirty=!0,this}scaleAndAddToRef(N,p){return p._x+=this._x*N,p._y+=this._y*N,p._z+=this._z*N,p._w+=this._w*N,p._isDirty=!0,p}multiply(N){const p=new L(0,0,0,1);return this.multiplyToRef(N,p),p}multiplyToRef(N,p){const T=this._x*N._w+this._y*N._z-this._z*N._y+this._w*N._x,A=-this._x*N._z+this._y*N._w+this._z*N._x+this._w*N._y,a=this._x*N._y-this._y*N._x+this._z*N._w+this._w*N._z,C=-this._x*N._x-this._y*N._y-this._z*N._z+this._w*N._w;return p.kX(T,A,a,C),p}multiplyInPlace(N){return this.multiplyToRef(N,this)}multiplyByFloats(N,p,T,A){return this._x*=N,this._y*=p,this._z*=T,this._w*=A,this._isDirty=!0,this}divide(N){throw new ReferenceError("Can not divide a quaternion")}divideToRef(N,p){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(N){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new L)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(N){return N._x=-this._x,N._y=-this._y,N._z=-this._z,N._w=-this._w,N._isDirty=!0,N}equalsToFloats(N,p,T,A){return this._x===N&&this._y===p&&this._z===T&&this._w===A}floorToRef(N){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(N){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(N){return N.kX(-this._x,-this._y,-this._z,this._w),N}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new L(-this._x,-this._y,-this._z,this._w)}invert(){const N=this.conjugate(),p=this.lengthSquared();return 0==p||1==p||N.scaleInPlace(1/p),N}invertInPlace(){this.conjugateInPlace();const N=this.lengthSquared();return 0==N||1==N||this.scaleInPlace(1/N),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){const N=new L(0,0,0,1);return this.normalizeToRef(N),N}normalizeToRef(N){const p=this.length();return 0===p||1===p?N.kX(this._x,this._y,this._z,this._w):this.scaleToRef(1/p,N)}toEulerAngles(){const N=x.Zero();return this.toEulerAnglesToRef(N),N}toEulerAnglesToRef(N){const p=this._z,T=this._x,A=this._y,a=this._w,C=A*p-T*a,U=.4999999;if(C<-U)N._y=2*Math.atan2(A,a),N._x=Math.PI/2,N._z=0,N._isDirty=!0;else if(C>U)N._y=2*Math.atan2(A,a),N._x=-Math.PI/2,N._z=0,N._isDirty=!0;else{const U=a*a,X=p*p,y=T*T,e=A*A;N._z=Math.atan2(2*(T*A+p*a),-X-y+e+U),N._x=Math.asin(-2*C),N._y=Math.atan2(2*(p*T+A*a),X-y-e+U),N._isDirty=!0}return N}toAlphaBetaGammaToRef(N){const p=this._z,T=this._x,A=this._y,a=this._w,C=Math.sqrt(T*T+A*A),U=Math.sqrt(p*p+a*a),X=2*Math.atan2(C,U),y=2*Math.atan2(p,a),e=2*Math.atan2(A,T),H=(y+e)/2,M=(y-e)/2;return N.set(M,X,H),N}toRotationMatrix(N){return n.FromQuaternionToRef(this,N),N}fromRotationMatrix(N){return L.FromRotationMatrixToRef(N,this),this}dot(N){return this._x*N._x+this._y*N._y+this._z*N._z+this._w*N._w}toAxisAngle(){const N=x.Zero();return{axis:N,angle:this.toAxisAngleToRef(N)}}toAxisAngleToRef(N){let p=0;const T=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),A=this._w;return T>0?(p=2*Math.atan2(T,A),N.set(this._x/T,this._y/T,this._z/T)):(p=0,N.set(1,0,0)),p}static FromRotationMatrix(N){const p=new L;return L.FromRotationMatrixToRef(N,p),p}static FromRotationMatrixToRef(N,p){const T=N.m,A=T[0],a=T[4],C=T[8],U=T[1],X=T[5],y=T[9],e=T[2],H=T[6],M=T[10],b=A+X+M;let l;return b>0?(l=.5/Math.sqrt(b+1),p._w=.25/l,p._x=(H-y)*l,p._y=(C-e)*l,p._z=(U-a)*l,p._isDirty=!0):A>X&&A>M?(l=2*Math.sqrt(1+A-X-M),p._w=(H-y)/l,p._x=.25*l,p._y=(a+U)/l,p._z=(C+e)/l,p._isDirty=!0):X>M?(l=2*Math.sqrt(1+X-A-M),p._w=(C-e)/l,p._x=(a+U)/l,p._y=.25*l,p._z=(y+H)/l,p._isDirty=!0):(l=2*Math.sqrt(1+M-A-X),p._w=(U-a)/l,p._x=(C+e)/l,p._y=(y+H)/l,p._z=.25*l,p._isDirty=!0),p}static Dot(N,p){return N._x*p._x+N._y*p._y+N._z*p._z+N._w*p._w}static AreClose(N,p){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const A=L.Dot(N,p);return 1-A*A<=T}static SmoothToRef(N,p,T,A,a){let C=0===A?1:T/A;return C=(0,y.Clamp)(C,0,1),L.SlerpToRef(N,p,C,a),a}static Zero(){return new L(0,0,0,0)}static Inverse(N){return new L(-N._x,-N._y,-N._z,N._w)}static InverseToRef(N,p){return p.set(-N._x,-N._y,-N._z,N._w),p}static Identity(){return new L(0,0,0,1)}static IsIdentity(N){return N&&0===N._x&&0===N._y&&0===N._z&&1===N._w}static RotationAxis(N,p){return L.RotationAxisToRef(N,p,new L)}static RotationAxisToRef(N,p,T){T._w=Math.cos(p/2);const A=Math.sin(p/2)/N.length();return T._x=N._x*A,T._y=N._y*A,T._z=N._z*A,T._isDirty=!0,T}static gp(N,p){return p||(p=0),new L(N[p],N[p+1],N[p+2],N[p+3])}static FromArrayToRef(N,p,T){return T._x=N[p],T._y=N[p+1],T._z=N[p+2],T._w=N[p+3],T._isDirty=!0,T}static FromFloatsToRef(N,p,T,A,a){return a.kX(N,p,T,A),a}static FromEulerAngles(N,p,T){const A=new L;return L.RotationYawPitchRollToRef(p,N,T,A),A}static FromEulerAnglesToRef(N,p,T,A){return L.RotationYawPitchRollToRef(p,N,T,A),A}static FromEulerVector(N){const p=new L;return L.RotationYawPitchRollToRef(N._y,N._x,N._z,p),p}static FromEulerVectorToRef(N,p){return L.RotationYawPitchRollToRef(N._y,N._x,N._z,p),p}static FromUnitVectorsToRef(N,p,T){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:A.b;const C=x.Dot(N,p)+1;return C<a?Math.abs(N.x)>Math.abs(N.z)?T.set(-N.y,N.x,0,0):T.set(0,-N.z,N.y,0):(x.CrossToRef(N,p,g.xp[0]),T.set(g.xp[0].x,g.xp[0].y,g.xp[0].z,C)),T.normalize()}static RotationYawPitchRoll(N,p,T){const A=new L;return L.RotationYawPitchRollToRef(N,p,T,A),A}static RotationYawPitchRollToRef(N,p,T,A){const a=.5*T,C=.5*p,U=.5*N,X=Math.sin(a),y=Math.cos(a),e=Math.sin(C),H=Math.cos(C),M=Math.sin(U),b=Math.cos(U);return A._x=b*e*y+M*H*X,A._y=M*H*y-b*e*X,A._z=b*H*X-M*e*y,A._w=b*H*y+M*e*X,A._isDirty=!0,A}static RotationAlphaBetaGamma(N,p,T){const A=new L;return L.RotationAlphaBetaGammaToRef(N,p,T,A),A}static RotationAlphaBetaGammaToRef(N,p,T,A){const a=.5*(T+N),C=.5*(T-N),U=.5*p;return A._x=Math.cos(C)*Math.sin(U),A._y=Math.sin(C)*Math.sin(U),A._z=Math.sin(a)*Math.cos(U),A._w=Math.cos(a)*Math.cos(U),A._isDirty=!0,A}static RotationQuaternionFromAxis(N,p,T){const A=new L(0,0,0,0);return L.RotationQuaternionFromAxisToRef(N,p,T,A),A}static RotationQuaternionFromAxisToRef(N,p,T,A){const a=w.Matrix[0];return N=N.normalizeToRef(w.xp[0]),p=p.normalizeToRef(w.xp[1]),T=T.normalizeToRef(w.xp[2]),n.FromXYZAxesToRef(N,p,T,a),L.FromRotationMatrixToRef(a,A),A}static FromLookDirectionLH(N,p){const T=new L;return L.FromLookDirectionLHToRef(N,p,T),T}static FromLookDirectionLHToRef(N,p,T){const A=w.Matrix[0];return n.LookDirectionLHToRef(N,p,A),L.FromRotationMatrixToRef(A,T),T}static FromLookDirectionRH(N,p){const T=new L;return L.FromLookDirectionRHToRef(N,p,T),T}static FromLookDirectionRHToRef(N,p,T){const A=w.Matrix[0];return n.LookDirectionRHToRef(N,p,A),L.FromRotationMatrixToRef(A,T)}static Slerp(N,p,T){const A=L.Identity();return L.SlerpToRef(N,p,T,A),A}static SlerpToRef(N,p,T,A){let a,C,U=N._x*p._x+N._y*p._y+N._z*p._z+N._w*p._w,X=!1;if(U<0&&(X=!0,U=-U),U>.999999)C=1-T,a=X?-T:T;else{const N=Math.acos(U),p=1/Math.sin(N);C=Math.sin((1-T)*N)*p,a=X?-Math.sin(T*N)*p:Math.sin(T*N)*p}return A._x=C*N._x+a*p._x,A._y=C*N._y+a*p._y,A._z=C*N._z+a*p._z,A._w=C*N._w+a*p._w,A._isDirty=!0,A}static Hermite(N,p,T,A,a){const C=a*a,U=a*C,X=2*U-3*C+1,y=-2*U+3*C,e=U-2*C+a,H=U-C,M=N._x*X+T._x*y+p._x*e+A._x*H,b=N._y*X+T._y*y+p._y*e+A._y*H,l=N._z*X+T._z*y+p._z*e+A._z*H,k=N._w*X+T._w*y+p._w*e+A._w*H;return new L(M,b,l,k)}static Hermite1stDerivative(N,p,T,A,a){const C=new L;return this.Hermite1stDerivativeToRef(N,p,T,A,a,C),C}static Hermite1stDerivativeToRef(N,p,T,A,a,C){const U=a*a;return C._x=6*(U-a)*N._x+(3*U-4*a+1)*p._x+6*(-U+a)*T._x+(3*U-2*a)*A._x,C._y=6*(U-a)*N._y+(3*U-4*a+1)*p._y+6*(-U+a)*T._y+(3*U-2*a)*A._y,C._z=6*(U-a)*N._z+(3*U-4*a+1)*p._z+6*(-U+a)*T._z+(3*U-2*a)*A._z,C._w=6*(U-a)*N._w+(3*U-4*a+1)*p._w+6*(-U+a)*T._w+(3*U-2*a)*A._w,C._isDirty=!0,C}static Normalize(N){const p=L.Zero();return L.NormalizeToRef(N,p),p}static NormalizeToRef(N,p){return N.normalizeToRef(p),p}static Clamp(N,p,T){const A=new L;return L.ClampToRef(N,p,T,A),A}static ClampToRef(N,p,T,A){return A.kX((0,y.Clamp)(N.x,p.x,T.x),(0,y.Clamp)(N.y,p.y,T.y),(0,y.Clamp)(N.z,p.z,T.z),(0,y.Clamp)(N.w,p.w,T.w))}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new L((0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).kX((0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p),(0,y.RandomRange)(N,p))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(N,p){return Math.sqrt(L.DistanceSquared(N,p))}static DistanceSquared(N,p){const T=N.x-p.x,A=N.y-p.y,a=N.z-p.z,C=N.w-p.w;return T*T+A*A+a*a+C*C}static Center(N,p){return L.CenterToRef(N,p,L.Zero())}static CenterToRef(N,p,T){return T.kX((N.x+p.x)/2,(N.y+p.y)/2,(N.z+p.z)/2,(N.w+p.w)/2)}}L._V8PerformanceHack=new L(.5,.5,.5,.5),Object.defineProperties(L.prototype,{dimension:{value:[4]},rank:{value:1}});class n{static get Use64Bits(){return U.b.MatrixUse64Bits}get m(){return this.NX}markAsUpdated(){this.updateFlag=e._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(N){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1],T=arguments.length>2&&void 0!==arguments[2]&&arguments[2],A=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=N,this._isIdentity3x2=N||T,this._isIdentityDirty=!this._isIdentity&&p,this._isIdentity3x2Dirty=!this._isIdentity3x2&&A}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,U.b.MatrixTrackPrecisionChange&&U.b.MatrixTrackedMatrices.push(this),this.NX=new U.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const N=this.NX;this._isIdentity=1===N[0]&&0===N[1]&&0===N[2]&&0===N[3]&&0===N[4]&&1===N[5]&&0===N[6]&&0===N[7]&&0===N[8]&&0===N[9]&&1===N[10]&&0===N[11]&&0===N[12]&&0===N[13]&&0===N[14]&&1===N[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.NX[0]||1!==this.NX[5]||1!==this.NX[15]||0!==this.NX[1]||0!==this.NX[2]||0!==this.NX[3]||0!==this.NX[4]||0!==this.NX[6]||0!==this.NX[7]||0!==this.NX[8]||0!==this.NX[9]||0!==this.NX[10]||0!==this.NX[11]||0!==this.NX[12]||0!==this.NX[13]||0!==this.NX[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const N=this.NX,p=N[0],T=N[1],A=N[2],a=N[3],C=N[4],U=N[5],X=N[6],y=N[7],e=N[8],H=N[9],M=N[10],b=N[11],l=N[12],k=N[13],x=N[14],I=N[15],L=M*I-x*b,n=H*I-k*b,w=H*x-k*M,g=e*I-l*b,P=e*x-M*l,i=e*k-l*H;return p*+(U*L-X*n+y*w)+T*-(C*L-X*g+y*P)+A*+(C*n-U*g+y*i)+a*-(C*w-U*P+X*i)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!N)return this.NX;const T=this.NX;for(let A=0;A<16;A++)N[p+A]=T[A];return this}UX(){return this.NX}IT(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n.FromArrayToRef(N,p,this)}kX(){for(var N=arguments.length,p=new Array(N),T=0;T<N;T++)p[T]=arguments[T];return n.FromArrayToRef(p,0,this)}set(){const N=this.NX;for(let p=0;p<16;p++)N[p]=p<0||arguments.length<=p?void 0:arguments[p];return this.markAsUpdated(),this}IX(N){const p=this.NX;for(let T=0;T<16;T++)p[T]=N;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return n.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(N){const p=new n;return this.addToRef(N,p),p}addToRef(N,p){const T=this.NX,A=p.NX,a=N.m;for(let C=0;C<16;C++)A[C]=T[C]+a[C];return p.markAsUpdated(),p}addToSelf(N){const p=this.NX,T=N.m;return p[0]+=T[0],p[1]+=T[1],p[2]+=T[2],p[3]+=T[3],p[4]+=T[4],p[5]+=T[5],p[6]+=T[6],p[7]+=T[7],p[8]+=T[8],p[9]+=T[9],p[10]+=T[10],p[11]+=T[11],p[12]+=T[12],p[13]+=T[13],p[14]+=T[14],p[15]+=T[15],this.markAsUpdated(),this}addInPlace(N){const p=this.NX,T=N.m;for(let A=0;A<16;A++)p[A]+=T[A];return this.markAsUpdated(),this}addInPlaceFromFloats(){const N=this.NX;for(let p=0;p<16;p++)N[p]+=p<0||arguments.length<=p?void 0:arguments[p];return this.markAsUpdated(),this}Ip(N){const p=this.NX,T=N.m;for(let A=0;A<16;A++)p[A]-=T[A];return this.markAsUpdated(),this}subtractToRef(N,p){const T=this.NX,A=N.m,a=p.NX;for(let C=0;C<16;C++)a[C]=T[C]-A[C];return p.markAsUpdated(),p}iM(N){const p=this.NX,T=N.m;for(let A=0;A<16;A++)p[A]-=T[A];return this.markAsUpdated(),this}subtractFromFloats(){for(var N=arguments.length,p=new Array(N),T=0;T<N;T++)p[T]=arguments[T];return this.subtractFromFloatsToRef(...p,new n)}subtractFromFloatsToRef(){for(var N=arguments.length,p=new Array(N),T=0;T<N;T++)p[T]=arguments[T];const A=p.pop(),a=this.NX,C=A.NX,U=p;for(let X=0;X<16;X++)C[X]=a[X]-U[X];return A.markAsUpdated(),A}invertToRef(N){return!0===this._isIdentity?(n.IdentityToRef(N),N):(b(this,N.UX())?N.markAsUpdated():N.A(this),N)}addAtIndex(N,p){return this.NX[N]+=p,this.markAsUpdated(),this}multiplyAtIndex(N,p){return this.NX[N]*=p,this.markAsUpdated(),this}setTranslationFromFloats(N,p,T){return this.NX[12]=N,this.NX[13]=p,this.NX[14]=T,this.markAsUpdated(),this}addTranslationFromFloats(N,p,T){return this.NX[12]+=N,this.NX[13]+=p,this.NX[14]+=T,this.markAsUpdated(),this}setTranslation(N){return this.setTranslationFromFloats(N._x,N._y,N._z)}getTranslation(){return new x(this.NX[12],this.NX[13],this.NX[14])}getTranslationToRef(N){return N.x=this.NX[12],N.y=this.NX[13],N.z=this.NX[14],N}removeRotationAndScaling(){const N=this.m;return n.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,N[12],N[13],N[14],N[15],this),this._updateIdentityStatus(0===N[12]&&0===N[13]&&0===N[14]&&1===N[15]),this}A(N){N.copyToArray(this.NX);const p=N;return this.updateFlag=p.updateFlag,this._updateIdentityStatus(p._isIdentity,p._isIdentityDirty,p._isIdentity3x2,p._isIdentity3x2Dirty),this}copyToArray(N){return M(this,N,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(N){const p=new n;return this.multiplyToRef(N,p),p}multiplyInPlace(N){const p=this.NX,T=N.m;for(let A=0;A<16;A++)p[A]*=T[A];return this.markAsUpdated(),this}multiplyByFloats(){const N=this.NX;for(let p=0;p<16;p++)N[p]*=p<0||arguments.length<=p?void 0:arguments[p];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var N=arguments.length,p=new Array(N),T=0;T<N;T++)p[T]=arguments[T];const A=p.pop(),a=this.NX,C=A.NX,U=p;for(let X=0;X<16;X++)C[X]=a[X]*U[X];return A.markAsUpdated(),A}multiplyToRef(N,p){return this._isIdentity?(p.A(N),p):N._isIdentity?(p.A(this),p):(this.multiplyToArray(N,p.NX,0),p.markAsUpdated(),p)}multiplyToArray(N,p,T){return H(this,N,p,T),this}divide(N){return this.divideToRef(N,new n)}divideToRef(N,p){const T=this.NX,A=N.m,a=p.NX;for(let C=0;C<16;C++)a[C]=T[C]/A[C];return p.markAsUpdated(),p}divideInPlace(N){const p=this.NX,T=N.m;for(let A=0;A<16;A++)p[A]/=T[A];return this.markAsUpdated(),this}minimizeInPlace(N){const p=this.NX,T=N.m;for(let A=0;A<16;A++)p[A]=Math.min(p[A],T[A]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const N=this.NX;for(let p=0;p<16;p++)N[p]=Math.min(N[p],p<0||arguments.length<=p?void 0:arguments[p]);return this.markAsUpdated(),this}maximizeInPlace(N){const p=this.NX,T=N.m;for(let A=0;A<16;A++)p[A]=Math.min(p[A],T[A]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const N=this.NX;for(let p=0;p<16;p++)N[p]=Math.min(N[p],p<0||arguments.length<=p?void 0:arguments[p]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new n)}negateInPlace(){const N=this.NX;for(let p=0;p<16;p++)N[p]=-N[p];return this.markAsUpdated(),this}negateToRef(N){const p=this.NX,T=N.NX;for(let A=0;A<16;A++)T[A]=-p[A];return N.markAsUpdated(),N}equals(N){const p=N;if(!p)return!1;if((this._isIdentity||p._isIdentity)&&!this._isIdentityDirty&&!p._isIdentityDirty)return this._isIdentity&&p._isIdentity;const T=this.m,A=p.m;return T[0]===A[0]&&T[1]===A[1]&&T[2]===A[2]&&T[3]===A[3]&&T[4]===A[4]&&T[5]===A[5]&&T[6]===A[6]&&T[7]===A[7]&&T[8]===A[8]&&T[9]===A[9]&&T[10]===A[10]&&T[11]===A[11]&&T[12]===A[12]&&T[13]===A[13]&&T[14]===A[14]&&T[15]===A[15]}equalsWithEpsilon(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const T=this.NX,A=N.m;for(let a=0;a<16;a++)if(!(0,y.WithinEpsilon)(T[a],A[a],p))return!1;return!0}equalsToFloats(){const N=this.NX;for(let p=0;p<16;p++)if(N[p]!=(p<0||arguments.length<=p?void 0:arguments[p]))return!1;return!0}floor(){return this.floorToRef(new n)}floorToRef(N){const p=this.NX,T=N.NX;for(let A=0;A<16;A++)T[A]=Math.floor(p[A]);return N.markAsUpdated(),N}fract(){return this.fractToRef(new n)}fractToRef(N){const p=this.NX,T=N.NX;for(let A=0;A<16;A++)T[A]=p[A]-Math.floor(p[A]);return N.markAsUpdated(),N}clone(){const N=new n;return N.A(this),N}getClassName(){return"Matrix"}getHashCode(){let N=l(this.NX[0]);for(let p=1;p<16;p++)N=397*N^l(this.NX[p]);return N}decomposeToTransformNode(N){return N.rotationQuaternion=N.rotationQuaternion||new L,this.decompose(N.xX,N.rotationQuaternion,N.position)}decompose(N,p,T,A){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return T&&T.IX(0),N&&N.IX(1),p&&p.kX(0,0,0,1),!0;const C=this.NX;if(T&&T.kX(C[12],C[13],C[14]),(N=N||w.xp[0]).x=Math.sqrt(C[0]*C[0]+C[1]*C[1]+C[2]*C[2]),N.y=Math.sqrt(C[4]*C[4]+C[5]*C[5]+C[6]*C[6]),N.z=Math.sqrt(C[8]*C[8]+C[9]*C[9]+C[10]*C[10]),A){const p=(a?A.absoluteScaling.x:A.xX.x)<0?-1:1,T=(a?A.absoluteScaling.y:A.xX.y)<0?-1:1,C=(a?A.absoluteScaling.z:A.xX.z)<0?-1:1;N.x*=p,N.y*=T,N.z*=C}else this.determinant()<=0&&(N.y*=-1);if(0===N._x||0===N._y||0===N._z)return p&&p.kX(0,0,0,1),!1;if(p){const T=1/N._x,A=1/N._y,a=1/N._z;n.FromValuesToRef(C[0]*T,C[1]*T,C[2]*T,0,C[4]*A,C[5]*A,C[6]*A,0,C[8]*a,C[9]*a,C[10]*a,0,0,0,0,1,w.Matrix[0]),L.FromRotationMatrixToRef(w.Matrix[0],p)}return!0}getRow(N){if(N<0||N>3)return null;const p=4*N;return new I(this.NX[p+0],this.NX[p+1],this.NX[p+2],this.NX[p+3])}getRowToRef(N,p){if(N>=0&&N<=3){const T=4*N;p.x=this.NX[T+0],p.y=this.NX[T+1],p.z=this.NX[T+2],p.w=this.NX[T+3]}return p}setRow(N,p){return this.setRowFromFloats(N,p.x,p.y,p.z,p.w)}transpose(){const N=new n;return n.TransposeToRef(this,N),N}transposeToRef(N){return n.TransposeToRef(this,N),N}setRowFromFloats(N,p,T,A,a){if(N<0||N>3)return this;const C=4*N;return this.NX[C+0]=p,this.NX[C+1]=T,this.NX[C+2]=A,this.NX[C+3]=a,this.markAsUpdated(),this}scale(N){const p=new n;return this.scaleToRef(N,p),p}scaleToRef(N,p){for(let T=0;T<16;T++)p.NX[T]=this.NX[T]*N;return p.markAsUpdated(),p}scaleAndAddToRef(N,p){for(let T=0;T<16;T++)p.NX[T]+=this.NX[T]*N;return p.markAsUpdated(),p}scaleInPlace(N){const p=this.NX;for(let T=0;T<16;T++)p[T]*=N;return this.markAsUpdated(),this}toNormalMatrix(N){const p=w.Matrix[0];this.invertToRef(p),p.transposeToRef(N);const T=N.NX;return n.FromValuesToRef(T[0],T[1],T[2],0,T[4],T[5],T[6],0,T[8],T[9],T[10],0,0,0,0,1,N),N}getRotationMatrix(){const N=new n;return this.getRotationMatrixToRef(N),N}getRotationMatrixToRef(N){const p=w.xp[0];if(!this.decompose(p))return n.IdentityToRef(N),N;const T=this.NX,A=1/p._x,a=1/p._y,C=1/p._z;return n.FromValuesToRef(T[0]*A,T[1]*A,T[2]*A,0,T[4]*a,T[5]*a,T[6]*a,0,T[8]*C,T[9]*C,T[10]*C,0,0,0,0,1,N),N}toggleModelMatrixHandInPlace(){const N=this.NX;return N[2]*=-1,N[6]*=-1,N[8]*=-1,N[9]*=-1,N[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const N=this.NX;return N[8]*=-1,N[9]*=-1,N[10]*=-1,N[11]*=-1,this.markAsUpdated(),this}static gp(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const T=new n;return n.FromArrayToRef(N,p,T),T}static FromArrayToRef(N,p,T){for(let A=0;A<16;A++)T.NX[A]=N[A+p];return T.markAsUpdated(),T}static FromFloat32ArrayToRefScaled(N,p,T,A){return A.NX[0]=N[0+p]*T,A.NX[1]=N[1+p]*T,A.NX[2]=N[2+p]*T,A.NX[3]=N[3+p]*T,A.NX[4]=N[4+p]*T,A.NX[5]=N[5+p]*T,A.NX[6]=N[6+p]*T,A.NX[7]=N[7+p]*T,A.NX[8]=N[8+p]*T,A.NX[9]=N[9+p]*T,A.NX[10]=N[10+p]*T,A.NX[11]=N[11+p]*T,A.NX[12]=N[12+p]*T,A.NX[13]=N[13+p]*T,A.NX[14]=N[14+p]*T,A.NX[15]=N[15+p]*T,A.markAsUpdated(),A}static get IdentityReadOnly(){return n._IdentityReadOnly}static FromValuesToRef(N,p,T,A,a,C,U,X,y,e,H,M,b,l,k,x,I){const L=I.NX;L[0]=N,L[1]=p,L[2]=T,L[3]=A,L[4]=a,L[5]=C,L[6]=U,L[7]=X,L[8]=y,L[9]=e,L[10]=H,L[11]=M,L[12]=b,L[13]=l,L[14]=k,L[15]=x,I.markAsUpdated()}static FromValues(N,p,T,A,a,C,U,X,y,e,H,M,b,l,k,x){const I=new n,L=I.NX;return L[0]=N,L[1]=p,L[2]=T,L[3]=A,L[4]=a,L[5]=C,L[6]=U,L[7]=X,L[8]=y,L[9]=e,L[10]=H,L[11]=M,L[12]=b,L[13]=l,L[14]=k,L[15]=x,I.markAsUpdated(),I}static Compose(N,p,T){const A=new n;return n.ComposeToRef(N,p,T,A),A}static ComposeToRef(N,p,T,A){const a=A.NX,C=p._x,U=p._y,X=p._z,y=p._w,e=C+C,H=U+U,M=X+X,b=C*e,l=C*H,k=C*M,x=U*H,I=U*M,L=X*M,n=y*e,w=y*H,g=y*M,P=N._x,i=N._y,K=N._z;return a[0]=(1-(x+L))*P,a[1]=(l+g)*P,a[2]=(k-w)*P,a[3]=0,a[4]=(l-g)*i,a[5]=(1-(b+L))*i,a[6]=(I+n)*i,a[7]=0,a[8]=(k+w)*K,a[9]=(I-n)*K,a[10]=(1-(b+x))*K,a[11]=0,a[12]=T._x,a[13]=T._y,a[14]=T._z,a[15]=1,A.markAsUpdated(),A}static Identity(){const N=n.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return N._updateIdentityStatus(!0),N}static IdentityToRef(N){return n.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,N),N._updateIdentityStatus(!0),N}static Zero(){const N=n.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return N._updateIdentityStatus(!1),N}static RotationX(N){const p=new n;return n.RotationXToRef(N,p),p}static Invert(N){const p=new n;return N.invertToRef(p),p}static RotationXToRef(N,p){const T=Math.sin(N),A=Math.cos(N);return n.FromValuesToRef(1,0,0,0,0,A,T,0,0,-T,A,0,0,0,0,1,p),p._updateIdentityStatus(1===A&&0===T),p}static RotationY(N){const p=new n;return n.RotationYToRef(N,p),p}static RotationYToRef(N,p){const T=Math.sin(N),A=Math.cos(N);return n.FromValuesToRef(A,0,-T,0,0,1,0,0,T,0,A,0,0,0,0,1,p),p._updateIdentityStatus(1===A&&0===T),p}static RotationZ(N){const p=new n;return n.RotationZToRef(N,p),p}static RotationZToRef(N,p){const T=Math.sin(N),A=Math.cos(N);return n.FromValuesToRef(A,T,0,0,-T,A,0,0,0,0,1,0,0,0,0,1,p),p._updateIdentityStatus(1===A&&0===T),p}static RotationAxis(N,p){const T=new n;return n.RotationAxisToRef(N,p,T),T}static RotationAxisToRef(N,p,T){const A=Math.sin(-p),a=Math.cos(-p),C=1-a;N=N.normalizeToRef(w.xp[0]);const U=T.NX;return U[0]=N._x*N._x*C+a,U[1]=N._x*N._y*C-N._z*A,U[2]=N._x*N._z*C+N._y*A,U[3]=0,U[4]=N._y*N._x*C+N._z*A,U[5]=N._y*N._y*C+a,U[6]=N._y*N._z*C-N._x*A,U[7]=0,U[8]=N._z*N._x*C-N._y*A,U[9]=N._z*N._y*C+N._x*A,U[10]=N._z*N._z*C+a,U[11]=0,U[12]=0,U[13]=0,U[14]=0,U[15]=1,T.markAsUpdated(),T}static RotationAlignToRef(N,p,T){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const C=x.Dot(p,N),U=T.NX;if(C<-1+A.b)U[0]=-1,U[1]=0,U[2]=0,U[3]=0,U[4]=0,U[5]=a?1:-1,U[6]=0,U[7]=0,U[8]=0,U[9]=0,U[10]=a?-1:1,U[11]=0;else{const T=x.Cross(p,N),A=1/(1+C);U[0]=T._x*T._x*A+C,U[1]=T._y*T._x*A-T._z,U[2]=T._z*T._x*A+T._y,U[3]=0,U[4]=T._x*T._y*A+T._z,U[5]=T._y*T._y*A+C,U[6]=T._z*T._y*A-T._x,U[7]=0,U[8]=T._x*T._z*A-T._y,U[9]=T._y*T._z*A+T._x,U[10]=T._z*T._z*A+C,U[11]=0}return U[12]=0,U[13]=0,U[14]=0,U[15]=1,T.markAsUpdated(),T}static RotationYawPitchRoll(N,p,T){const A=new n;return n.RotationYawPitchRollToRef(N,p,T,A),A}static RotationYawPitchRollToRef(N,p,T,A){return L.RotationYawPitchRollToRef(N,p,T,w.Quaternion[0]),w.Quaternion[0].toRotationMatrix(A),A}static Scaling(N,p,T){const A=new n;return n.ScalingToRef(N,p,T,A),A}static ScalingToRef(N,p,T,A){return n.FromValuesToRef(N,0,0,0,0,p,0,0,0,0,T,0,0,0,0,1,A),A._updateIdentityStatus(1===N&&1===p&&1===T),A}static Translation(N,p,T){const A=new n;return n.TranslationToRef(N,p,T,A),A}static TranslationToRef(N,p,T,A){return n.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,N,p,T,1,A),A._updateIdentityStatus(0===N&&0===p&&0===T),A}static Lerp(N,p,T){const A=new n;return n.LerpToRef(N,p,T,A),A}static LerpToRef(N,p,T,A){const a=A.NX,C=N.m,U=p.m;for(let X=0;X<16;X++)a[X]=C[X]*(1-T)+U[X]*T;return A.markAsUpdated(),A}static DecomposeLerp(N,p,T){const A=new n;return n.DecomposeLerpToRef(N,p,T,A),A}static DecomposeLerpToRef(N,p,T,A){const a=w.xp[0],C=w.Quaternion[0],U=w.xp[1];N.decompose(a,C,U);const X=w.xp[2],y=w.Quaternion[1],e=w.xp[3];p.decompose(X,y,e);const H=w.xp[4];x.LerpToRef(a,X,T,H);const M=w.Quaternion[2];L.SlerpToRef(C,y,T,M);const b=w.xp[5];return x.LerpToRef(U,e,T,b),n.ComposeToRef(H,M,b,A),A}static LookAtLH(N,p,T){const A=new n;return n.LookAtLHToRef(N,p,T,A),A}static LookAtLHToRef(N,p,T,A){const a=w.xp[0],C=w.xp[1],U=w.xp[2];p.subtractToRef(N,U),U.normalize(),x.CrossToRef(T,U,a);const X=a.lengthSquared();0===X?a.x=1:a.normalizeFromLength(Math.sqrt(X)),x.CrossToRef(U,a,C),C.normalize();const y=-x.Dot(a,N),e=-x.Dot(C,N),H=-x.Dot(U,N);return n.FromValuesToRef(a._x,C._x,U._x,0,a._y,C._y,U._y,0,a._z,C._z,U._z,0,y,e,H,1,A),A}static LookAtRH(N,p,T){const A=new n;return n.LookAtRHToRef(N,p,T,A),A}static LookAtRHToRef(N,p,T,A){const a=w.xp[0],C=w.xp[1],U=w.xp[2];N.subtractToRef(p,U),U.normalize(),x.CrossToRef(T,U,a);const X=a.lengthSquared();0===X?a.x=1:a.normalizeFromLength(Math.sqrt(X)),x.CrossToRef(U,a,C),C.normalize();const y=-x.Dot(a,N),e=-x.Dot(C,N),H=-x.Dot(U,N);return n.FromValuesToRef(a._x,C._x,U._x,0,a._y,C._y,U._y,0,a._z,C._z,U._z,0,y,e,H,1,A),A}static LookDirectionLH(N,p){const T=new n;return n.LookDirectionLHToRef(N,p,T),T}static LookDirectionLHToRef(N,p,T){const A=w.xp[0];A.A(N),A.scaleInPlace(-1);const a=w.xp[1];return x.CrossToRef(p,A,a),n.FromValuesToRef(a._x,a._y,a._z,0,p._x,p._y,p._z,0,A._x,A._y,A._z,0,0,0,0,1,T),T}static LookDirectionRH(N,p){const T=new n;return n.LookDirectionRHToRef(N,p,T),T}static LookDirectionRHToRef(N,p,T){const A=w.xp[2];return x.CrossToRef(p,N,A),n.FromValuesToRef(A._x,A._y,A._z,0,p._x,p._y,p._z,0,N._x,N._y,N._z,0,0,0,0,1,T),T}static OrthoLH(N,p,T,A,a){const C=new n;return n.OrthoLHToRef(N,p,T,A,C,a),C}static OrthoLHToRef(N,p,T,A,a,C){const U=2/N,X=2/p,y=2/(A-T),e=-(A+T)/(A-T);return n.FromValuesToRef(U,0,0,0,0,X,0,0,0,0,y,0,0,0,e,1,a),C&&a.multiplyToRef(P,a),a._updateIdentityStatus(1===U&&1===X&&1===y&&0===e),a}static OrthoOffCenterLH(N,p,T,A,a,C,U){const X=new n;return n.OrthoOffCenterLHToRef(N,p,T,A,a,C,X,U),X}static OrthoOffCenterLHToRef(N,p,T,A,a,C,U,X){const y=2/(p-N),e=2/(A-T),H=2/(C-a),M=-(C+a)/(C-a),b=(N+p)/(N-p),l=(A+T)/(T-A);return n.FromValuesToRef(y,0,0,0,0,e,0,0,0,0,H,0,b,l,M,1,U),X&&U.multiplyToRef(P,U),U.markAsUpdated(),U}static ObliqueOffCenterLHToRef(N,p,T,A,a,C,U,X,y,e,H){const M=-U*Math.cos(X),b=-U*Math.sin(X);return n.TranslationToRef(0,0,-y,w.Matrix[1]),n.FromValuesToRef(1,0,0,0,0,1,0,0,M,b,1,0,0,0,0,1,w.Matrix[0]),w.Matrix[1].multiplyToRef(w.Matrix[0],w.Matrix[0]),n.TranslationToRef(0,0,y,w.Matrix[1]),w.Matrix[0].multiplyToRef(w.Matrix[1],w.Matrix[0]),n.OrthoOffCenterLHToRef(N,p,T,A,a,C,e,H),w.Matrix[0].multiplyToRef(e,e),e}static OrthoOffCenterRH(N,p,T,A,a,C,U){const X=new n;return n.OrthoOffCenterRHToRef(N,p,T,A,a,C,X,U),X}static OrthoOffCenterRHToRef(N,p,T,A,a,C,U,X){return n.OrthoOffCenterLHToRef(N,p,T,A,a,C,U,X),U.NX[10]*=-1,U}static ObliqueOffCenterRHToRef(N,p,T,A,a,C,U,X,y,e,H){const M=U*Math.cos(X),b=U*Math.sin(X);return n.TranslationToRef(0,0,y,w.Matrix[1]),n.FromValuesToRef(1,0,0,0,0,1,0,0,M,b,1,0,0,0,0,1,w.Matrix[0]),w.Matrix[1].multiplyToRef(w.Matrix[0],w.Matrix[0]),n.TranslationToRef(0,0,-y,w.Matrix[1]),w.Matrix[0].multiplyToRef(w.Matrix[1],w.Matrix[0]),n.OrthoOffCenterRHToRef(N,p,T,A,a,C,e,H),w.Matrix[0].multiplyToRef(e,e),e}static PerspectiveLH(N,p,T,A,a){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const U=new n,X=2*T/N,y=2*T/p,e=(A+T)/(A-T),H=-2*A*T/(A-T),M=Math.tan(C);return n.FromValuesToRef(X,0,0,0,0,y,0,M,0,0,e,1,0,0,H,0,U),a&&U.multiplyToRef(P,U),U._updateIdentityStatus(!1),U}static PerspectiveFovLH(N,p,T,A,a){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const X=new n;return n.PerspectiveFovLHToRef(N,p,T,A,X,!0,a,C,U),X}static PerspectiveFovLHToRef(N,p,T,A,a){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,y=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const e=T,H=A,M=1/Math.tan(.5*N),b=C?M/p:M,l=C?M:M*p,k=y&&0===e?-1:0!==H?(H+e)/(H-e):1,x=y&&0===e?2*H:0!==H?-2*H*e/(H-e):-2*e,I=Math.tan(X);return n.FromValuesToRef(b,0,0,0,0,l,0,I,0,0,k,1,0,0,x,0,a),U&&a.multiplyToRef(P,a),a._updateIdentityStatus(!1),a}static PerspectiveFovReverseLHToRef(N,p,T,A,a){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const y=1/Math.tan(.5*N),e=C?y/p:y,H=C?y:y*p,M=Math.tan(X);return n.FromValuesToRef(e,0,0,0,0,H,0,M,0,0,-T,1,0,0,1,0,a),U&&a.multiplyToRef(P,a),a._updateIdentityStatus(!1),a}static PerspectiveFovRH(N,p,T,A,a){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const X=new n;return n.PerspectiveFovRHToRef(N,p,T,A,X,!0,a,C,U),X}static PerspectiveFovRHToRef(N,p,T,A,a){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,y=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const e=T,H=A,M=1/Math.tan(.5*N),b=C?M/p:M,l=C?M:M*p,k=y&&0===e?1:0!==H?-(H+e)/(H-e):-1,x=y&&0===e?2*H:0!==H?-2*H*e/(H-e):-2*e,I=Math.tan(X);return n.FromValuesToRef(b,0,0,0,0,l,0,I,0,0,k,-1,0,0,x,0,a),U&&a.multiplyToRef(P,a),a._updateIdentityStatus(!1),a}static PerspectiveFovReverseRHToRef(N,p,T,A,a){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const y=1/Math.tan(.5*N),e=C?y/p:y,H=C?y:y*p,M=Math.tan(X);return n.FromValuesToRef(e,0,0,0,0,H,0,M,0,0,-T,-1,0,0,-1,0,a),U&&a.multiplyToRef(P,a),a._updateIdentityStatus(!1),a}static GetFinalMatrix(N,p,T,A,a,C){const U=N.width,X=N.height,y=N.x,e=N.y,H=n.FromValues(U/2,0,0,0,0,-X/2,0,0,0,0,C-a,0,y+U/2,X/2+e,a,1),M=new n;return p.multiplyToRef(T,M),M.multiplyToRef(A,M),M.multiplyToRef(H,M)}static GetAsMatrix2x2(N){const p=N.m,T=[p[0],p[1],p[4],p[5]];return U.b.MatrixUse64Bits?T:new Float32Array(T)}static GetAsMatrix3x3(N){const p=N.m,T=[p[0],p[1],p[2],p[4],p[5],p[6],p[8],p[9],p[10]];return U.b.MatrixUse64Bits?T:new Float32Array(T)}static Transpose(N){const p=new n;return n.TransposeToRef(N,p),p}static TransposeToRef(N,p){const T=N.m,A=T[0],a=T[4],C=T[8],U=T[12],X=T[1],y=T[5],e=T[9],H=T[13],M=T[2],b=T[6],l=T[10],k=T[14],x=T[3],I=T[7],L=T[11],n=T[15],w=p.NX;return w[0]=A,w[1]=a,w[2]=C,w[3]=U,w[4]=X,w[5]=y,w[6]=e,w[7]=H,w[8]=M,w[9]=b,w[10]=l,w[11]=k,w[12]=x,w[13]=I,w[14]=L,w[15]=n,p.markAsUpdated(),p._updateIdentityStatus(N._isIdentity,N._isIdentityDirty),p}static Reflection(N){const p=new n;return n.ReflectionToRef(N,p),p}static ReflectionToRef(N,p){N.normalize();const T=N.normal.x,A=N.normal.y,a=N.normal.z,C=-2*T,U=-2*A,X=-2*a;return n.FromValuesToRef(C*T+1,U*T,X*T,0,C*A,U*A+1,X*A,0,C*a,U*a,X*a+1,0,C*N.d,U*N.d,X*N.d,1,p),p}static FromXYZAxesToRef(N,p,T,A){return n.FromValuesToRef(N._x,N._y,N._z,0,p._x,p._y,p._z,0,T._x,T._y,T._z,0,0,0,0,1,A),A}static FromQuaternionToRef(N,p){const T=N._x*N._x,A=N._y*N._y,a=N._z*N._z,C=N._x*N._y,U=N._z*N._w,X=N._z*N._x,y=N._y*N._w,e=N._y*N._z,H=N._x*N._w;return p.NX[0]=1-2*(A+a),p.NX[1]=2*(C+U),p.NX[2]=2*(X-y),p.NX[3]=0,p.NX[4]=2*(C-U),p.NX[5]=1-2*(a+T),p.NX[6]=2*(e+H),p.NX[7]=0,p.NX[8]=2*(X+y),p.NX[9]=2*(e-H),p.NX[10]=1-2*(A+T),p.NX[11]=0,p.NX[12]=0,p.NX[13]=0,p.NX[14]=0,p.NX[15]=1,p.markAsUpdated(),p}}n._IdentityReadOnly=n.Identity(),Object.defineProperties(n.prototype,{dimension:{value:[4,4]},rank:{value:2}});class w{}w.xp=(0,a.g)(11,x.Zero),w.Matrix=(0,a.g)(2,n.Identity),w.Quaternion=(0,a.g)(3,L.Zero);class g{}g.Vector2=(0,a.g)(3,k.Zero),g.xp=(0,a.g)(13,x.Zero),g.Vector4=(0,a.g)(3,I.Zero),g.Quaternion=(0,a.g)(3,L.Zero),g.Matrix=(0,a.g)(8,n.Identity),(0,C.d)("BABYLON.Vector2",k),(0,C.d)("BABYLON.Vector3",x),(0,C.d)("BABYLON.Vector4",I),(0,C.d)("BABYLON.Matrix",n);const P=n.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12384:(N,p,T)=>{function A(N,p){const T=[];for(let A=0;A<N;++A)T.push(p());return T}function a(N,p){return A(N,p)}T.d(p,{e:()=>A,g:()=>a,j:()=>U});const C=["push","splice","pop","shift","unshift"];function U(N,p){const T=C.map((T=>function(N,p,T){const A=N[p];if("function"!==typeof A)return null;const a=function(){const A=N.length,C=a.previous.apply(N,arguments);return T(p,A),C};return A.next=a,a.previous=A,N[p]=a,()=>{const T=a.previous;if(!T)return;const A=a.next;A?(T.next=A,A.previous=T):(T.next=void 0,N[p]=T),a.next=void 0,a.previous=void 0}}(N,T,p)));return()=>{for(const N of T)null===N||void 0===N||N()}}}}]);