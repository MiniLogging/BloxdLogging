"use strict";(self.i6szn8jgzh=self.i6szn8jgzh||[]).push([[14],{11786:(b,n,i)=>{i.d(n,{c:()=>U,d:()=>Q,g:()=>e,j:()=>V});const e=1/2.2,V=2.2,Q=(1+Math.sqrt(5))/2,U=.001},11796:(b,n,i)=>{function e(b){return parseInt(b.toString().replace(/\W/g,""))}function V(b,n){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(b-n)<=i}function Q(b,n,i){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return b<n-e||b>i+e}function U(b,n){return b===n?b:Math.random()*(n-b)+b}function Y(b,n,i){return b+(n-b)*i}function L(b,n,i){let e=I(n-b,360);return e>180&&(e-=360),b+e*Z(i)}function B(b,n,i){let e=0;return e=b!=n?Z((i-b)/(n-b)):0,e}function mb(b,n,i,e,V){const Q=V*V,U=V*Q;return b*(2*U-3*Q+1)+i*(-2*U+3*Q)+n*(U-2*Q+V)+e*(U-Q)}function N(b,n,i,e,V){const Q=V*V;return 6*(Q-V)*b+(3*Q-4*V+1)*n+6*(-Q+V)*i+(3*Q-2*V)*e}function Z(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(i,Math.max(n,b))}function T(b){return b-=2*Math.PI*Math.floor((b+Math.PI)/(2*Math.PI))}function z(b){const n=b.toString(16);return b<=15?("0"+n).toUpperCase():n.toUpperCase()}function K(b){if(Math.log2)return Math.floor(Math.log2(b));if(b<0)return NaN;if(0===b)return-1/0;let n=0;if(b<1){for(;b<1;)n++,b*=2;n=-n}else if(b>1)for(;b>1;)n++,b=Math.floor(b/2);return n}function I(b,n){return b-Math.floor(b/n)*n}function O(b,n,i){return(b-n)/(i-n)}function u(b,n,i){return b*(i-n)+n}function d(b,n){let i=I(n-b,360);return i>180&&(i-=360),i}function G(b,n){const i=I(b,2*n);return n-Math.abs(i-n)}function o(b,n,i){let e=Z(i);return e=-2*e*e*e+3*e*e,n*e+b*(1-e)}function M(b,n,i){let e=0;return e=Math.abs(n-b)<=i?n:b+Math.sign(n-b)*i,e}function j(b,n,i){const e=d(b,n);let V=0;return V=-i<e&&e<i?n:M(b,n=b+e,i),V}function a(b,n,i){return(b-n)/(i-n)}function D(b,n,i){return(i-n)*b+n}function x(b,n){const i=b%n;return 0===i?n:x(n,i)}i.r(n),i.d(n,{Clamp:()=>Z,DeltaAngle:()=>d,Denormalize:()=>u,ExtractAsInt:()=>e,Hermite:()=>mb,Hermite1stDerivative:()=>N,HighestCommonFactor:()=>x,ILog2:()=>K,InverseLerp:()=>B,Lerp:()=>Y,LerpAngle:()=>L,MoveTowards:()=>M,MoveTowardsAngle:()=>j,Normalize:()=>O,NormalizeRadians:()=>T,OutsideRange:()=>Q,PercentToRange:()=>D,PingPong:()=>G,RandomRange:()=>U,RangeToPercent:()=>a,Repeat:()=>I,SmoothStep:()=>o,ToHex:()=>z,WithinEpsilon:()=>V})},11778:(b,n,i)=>{i.r(n),i.d(n,{Matrix:()=>u,Quaternion:()=>O,TmpVectors:()=>G,Vector2:()=>z,On:()=>K,Vector4:()=>I});var e=i(11786),V=i(11788),Q=i(11734),U=i(11701),Y=i(11646),L=i(11796);class B{}function mb(b,n,i){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const V=b.ye(),Q=n.ye(),U=V[0],Y=V[1],L=V[2],B=V[3],mb=V[4],N=V[5],Z=V[6],T=V[7],z=V[8],K=V[9],I=V[10],O=V[11],u=V[12],d=V[13],G=V[14],o=V[15],M=Q[0],j=Q[1],a=Q[2],D=Q[3],x=Q[4],y=Q[5],s=Q[6],A=Q[7],E=Q[8],C=Q[9],t=Q[10],w=Q[11],h=Q[12],W=Q[13],J=Q[14],R=Q[15];i[e]=U*M+Y*x+L*E+B*h,i[e+1]=U*j+Y*y+L*C+B*W,i[e+2]=U*a+Y*s+L*t+B*J,i[e+3]=U*D+Y*A+L*w+B*R,i[e+4]=mb*M+N*x+Z*E+T*h,i[e+5]=mb*j+N*y+Z*C+T*W,i[e+6]=mb*a+N*s+Z*t+T*J,i[e+7]=mb*D+N*A+Z*w+T*R,i[e+8]=z*M+K*x+I*E+O*h,i[e+9]=z*j+K*y+I*C+O*W,i[e+10]=z*a+K*s+I*t+O*J,i[e+11]=z*D+K*A+I*w+O*R,i[e+12]=u*M+d*x+G*E+o*h,i[e+13]=u*j+d*y+G*C+o*W,i[e+14]=u*a+d*s+G*t+o*J,i[e+15]=u*D+d*A+G*w+o*R}function N(b,n){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const e=b.ye();n[i]=e[0],n[i+1]=e[1],n[i+2]=e[2],n[i+3]=e[3],n[i+4]=e[4],n[i+5]=e[5],n[i+6]=e[6],n[i+7]=e[7],n[i+8]=e[8],n[i+9]=e[9],n[i+10]=e[10],n[i+11]=e[11],n[i+12]=e[12],n[i+13]=e[13],n[i+14]=e[14],n[i+15]=e[15]}function Z(b,n){const i=b.ye(),e=i[0],V=i[1],Q=i[2],U=i[3],Y=i[4],L=i[5],B=i[6],mb=i[7],N=i[8],Z=i[9],T=i[10],z=i[11],K=i[12],I=i[13],O=i[14],u=i[15],d=T*u-O*z,G=Z*u-I*z,o=Z*O-I*T,M=N*u-K*z,j=N*O-T*K,a=N*I-K*Z,D=+(L*d-B*G+mb*o),x=-(Y*d-B*M+mb*j),y=+(Y*G-L*M+mb*a),s=-(Y*o-L*j+B*a),A=e*D+V*x+Q*y+U*s;if(0===A)return!1;const E=1/A,C=B*u-O*mb,t=L*u-I*mb,w=L*O-I*B,h=Y*u-K*mb,W=Y*O-K*B,J=Y*I-K*L,R=B*z-T*mb,k=L*z-Z*mb,r=L*T-Z*B,X=Y*z-N*mb,g=Y*T-N*B,P=Y*Z-N*L,c=-(V*d-Q*G+U*o),q=+(e*d-Q*M+U*j),S=-(e*G-V*M+U*a),H=+(e*o-V*j+Q*a),l=+(V*C-Q*t+U*w),v=-(e*C-Q*h+U*W),p=+(e*t-V*h+U*J),f=-(e*w-V*W+Q*J),F=-(V*R-Q*k+U*r),bb=+(e*R-Q*X+U*g),nb=-(e*k-V*X+U*P),ib=+(e*r-V*g+Q*P);return n[0]=D*E,n[1]=c*E,n[2]=l*E,n[3]=F*E,n[4]=x*E,n[5]=q*E,n[6]=v*E,n[7]=bb*E,n[8]=y*E,n[9]=S*E,n[10]=p*E,n[11]=nb*E,n[12]=s*E,n[13]=H*E,n[14]=f*E,n[15]=ib*E,!0}B._UpdateFlagSeed=0;const T=b=>parseInt(b.toString().replace(/\W/g,""));class z{constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=b,this.y=n}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let b=T(this.x);return b=397*b^T(this.y),b}toArray(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[n]=this.x,b[n+1]=this.y,this}Gi(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z.FromArrayToRef(b,n,this),this}ye(){return[this.x,this.y]}L(b){return this.x=b.x,this.y=b.y,this}re(b,n){return this.x=b,this.y=n,this}set(b,n){return this.re(b,n)}Fe(b){return this.re(b,b)}add(b){return new z(this.x+b.x,this.y+b.y)}addToRef(b,n){return n.x=this.x+b.x,n.y=this.y+b.y,n}addInPlace(b){return this.x+=b.x,this.y+=b.y,this}addInPlaceFromFloats(b,n){return this.x+=b,this.y+=n,this}addVector3(b){return new z(this.x+b.x,this.y+b.y)}un(b){return new z(this.x-b.x,this.y-b.y)}subtractToRef(b,n){return n.x=this.x-b.x,n.y=this.y-b.y,n}lm(b){return this.x-=b.x,this.y-=b.y,this}multiplyInPlace(b){return this.x*=b.x,this.y*=b.y,this}multiply(b){return new z(this.x*b.x,this.y*b.y)}multiplyToRef(b,n){return n.x=this.x*b.x,n.y=this.y*b.y,n}multiplyByFloats(b,n){return new z(this.x*b,this.y*n)}divide(b){return new z(this.x/b.x,this.y/b.y)}divideToRef(b,n){return n.x=this.x/b.x,n.y=this.y/b.y,n}divideInPlace(b){return this.x=this.x/b.x,this.y=this.y/b.y,this}minimizeInPlace(b){return this.minimizeInPlaceFromFloats(b.x,b.y)}maximizeInPlace(b){return this.maximizeInPlaceFromFloats(b.x,b.y)}minimizeInPlaceFromFloats(b,n){return this.x=Math.min(b,this.x),this.y=Math.min(n,this.y),this}maximizeInPlaceFromFloats(b,n){return this.x=Math.max(b,this.x),this.y=Math.max(n,this.y),this}subtractFromFloats(b,n){return new z(this.x-b,this.y-n)}subtractFromFloatsToRef(b,n,i){return i.x=this.x-b,i.y=this.y-n,i}negate(){return new z(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(b){return b.x=-this.x,b.y=-this.y,b}scaleInPlace(b){return this.x*=b,this.y*=b,this}scale(b){return new z(this.x*b,this.y*b)}scaleToRef(b,n){return n.x=this.x*b,n.y=this.y*b,n}scaleAndAddToRef(b,n){return n.x+=this.x*b,n.y+=this.y*b,n}equals(b){return b&&this.x===b.x&&this.y===b.y}equalsWithEpsilon(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.c;return b&&(0,L.WithinEpsilon)(this.x,b.x,n)&&(0,L.WithinEpsilon)(this.y,b.y,n)}equalsToFloats(b,n){return this.x===b&&this.y===n}floor(){return new z(Math.floor(this.x),Math.floor(this.y))}floorToRef(b){return b.x=Math.floor(this.x),b.y=Math.floor(this.y),b}fract(){return new z(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(b){return b.x=this.x-Math.floor(this.x),b.y=this.y-Math.floor(this.y),b}rotate(b){return this.rotateToRef(b,new z)}rotateToRef(b,n){const i=Math.cos(b),e=Math.sin(b);return n.x=i*this.x-e*this.y,n.y=e*this.x+i*this.y,n}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){const b=new z;return this.normalizeToRef(b),b}normalizeToRef(b){const n=this.length();return 0===n&&(b.x=this.x,b.y=this.y),this.scaleToRef(1/n,b)}clone(){return new z(this.x,this.y)}dot(b){return this.x*b.x+this.y*b.y}static Zero(){return new z(0,0)}static One(){return new z(1,1)}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new z((0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).re((0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n))}static get ZeroReadOnly(){return z._ZeroReadOnly}static jn(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new z(b[n],b[n+1])}static FromArrayToRef(b,n,i){return i.x=b[n],i.y=b[n+1],i}static FromFloatsToRef(b,n,i){return i.re(b,n),i}static CatmullRom(b,n,i,e,V){const Q=V*V,U=V*Q,Y=.5*(2*n.x+(-b.x+i.x)*V+(2*b.x-5*n.x+4*i.x-e.x)*Q+(-b.x+3*n.x-3*i.x+e.x)*U),L=.5*(2*n.y+(-b.y+i.y)*V+(2*b.y-5*n.y+4*i.y-e.y)*Q+(-b.y+3*n.y-3*i.y+e.y)*U);return new z(Y,L)}static ClampToRef(b,n,i,e){return e.x=(0,L.Clamp)(b.x,n.x,i.x),e.y=(0,L.Clamp)(b.y,n.y,i.y),e}static Clamp(b,n,i){const e=(0,L.Clamp)(b.x,n.x,i.x),V=(0,L.Clamp)(b.y,n.y,i.y);return new z(e,V)}static Hermite(b,n,i,e,V){const Q=V*V,U=V*Q,Y=2*U-3*Q+1,L=-2*U+3*Q,B=U-2*Q+V,mb=U-Q,N=b.x*Y+i.x*L+n.x*B+e.x*mb,Z=b.y*Y+i.y*L+n.y*B+e.y*mb;return new z(N,Z)}static Hermite1stDerivative(b,n,i,e,V){return this.Hermite1stDerivativeToRef(b,n,i,e,V,new z)}static Hermite1stDerivativeToRef(b,n,i,e,V,Q){const U=V*V;return Q.x=6*(U-V)*b.x+(3*U-4*V+1)*n.x+6*(-U+V)*i.x+(3*U-2*V)*e.x,Q.y=6*(U-V)*b.y+(3*U-4*V+1)*n.y+6*(-U+V)*i.y+(3*U-2*V)*e.y,Q}static Lerp(b,n,i){return z.LerpToRef(b,n,i,new z)}static LerpToRef(b,n,i,e){return e.x=b.x+(n.x-b.x)*i,e.y=b.y+(n.y-b.y)*i,e}static Dot(b,n){return b.x*n.x+b.y*n.y}static Normalize(b){return z.NormalizeToRef(b,new z)}static NormalizeToRef(b,n){return b.normalizeToRef(n),n}static Minimize(b,n){const i=b.x<n.x?b.x:n.x,e=b.y<n.y?b.y:n.y;return new z(i,e)}static Maximize(b,n){const i=b.x>n.x?b.x:n.x,e=b.y>n.y?b.y:n.y;return new z(i,e)}static Transform(b,n){return z.TransformToRef(b,n,new z)}static TransformToRef(b,n,i){const e=n.m,V=b.x*e[0]+b.y*e[4]+e[12],Q=b.x*e[1]+b.y*e[5]+e[13];return i.x=V,i.y=Q,i}static PointInTriangle(b,n,i,e){const V=.5*(-i.y*e.x+n.y*(-i.x+e.x)+n.x*(i.y-e.y)+i.x*e.y),Q=V<0?-1:1,U=(n.y*e.x-n.x*e.y+(e.y-n.y)*b.x+(n.x-e.x)*b.y)*Q,Y=(n.x*i.y-n.y*i.x+(n.y-i.y)*b.x+(i.x-n.x)*b.y)*Q;return U>0&&Y>0&&U+Y<2*V*Q}static Distance(b,n){return Math.sqrt(z.DistanceSquared(b,n))}static DistanceSquared(b,n){const i=b.x-n.x,e=b.y-n.y;return i*i+e*e}static Center(b,n){return z.CenterToRef(b,n,new z)}static CenterToRef(b,n,i){return i.re((b.x+n.x)/2,(b.y+n.y)/2)}static DistanceOfPointFromSegment(b,n,i){const e=z.DistanceSquared(n,i);if(0===e)return z.Distance(b,n);const V=i.un(n),Q=Math.max(0,Math.min(1,z.Dot(b.un(n),V)/e)),U=n.add(V.multiplyByFloats(Q,Q));return z.Distance(b,U)}}z._V8PerformanceHack=new z(.5,.5),z._ZeroReadOnly=z.Zero(),Object.defineProperties(z.prototype,{dimension:{value:[2]},rank:{value:1}});class K{get x(){return this._x}set x(b){this._x=b,this._isDirty=!0}get y(){return this._y}set y(b){this._y=b,this._isDirty=!0}get z(){return this._z}set z(b){this._z=b,this._isDirty=!0}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=b,this._y=n,this._z=i}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"On"}getHashCode(){let b=T(this._x);return b=397*b^T(this._y),b=397*b^T(this._z),b}ye(){return[this._x,this._y,this._z]}toArray(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[n]=this._x,b[n+1]=this._y,b[n+2]=this._z,this}Gi(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(b,n,this),this}toQuaternion(){return O.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(b){return this._x+=b._x,this._y+=b._y,this._z+=b._z,this._isDirty=!0,this}addInPlaceFromFloats(b,n,i){return this._x+=b,this._y+=n,this._z+=i,this._isDirty=!0,this}add(b){return new K(this._x+b._x,this._y+b._y,this._z+b._z)}addToRef(b,n){return n._x=this._x+b._x,n._y=this._y+b._y,n._z=this._z+b._z,n._isDirty=!0,n}lm(b){return this._x-=b._x,this._y-=b._y,this._z-=b._z,this._isDirty=!0,this}un(b){return new K(this._x-b._x,this._y-b._y,this._z-b._z)}subtractToRef(b,n){return this.subtractFromFloatsToRef(b._x,b._y,b._z,n)}subtractFromFloats(b,n,i){return new K(this._x-b,this._y-n,this._z-i)}subtractFromFloatsToRef(b,n,i,e){return e._x=this._x-b,e._y=this._y-n,e._z=this._z-i,e._isDirty=!0,e}negate(){return new K(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(b){return b._x=-1*this._x,b._y=-1*this._y,b._z=-1*this._z,b._isDirty=!0,b}scaleInPlace(b){return this._x*=b,this._y*=b,this._z*=b,this._isDirty=!0,this}scale(b){return new K(this._x*b,this._y*b,this._z*b)}scaleToRef(b,n){return n._x=this._x*b,n._y=this._y*b,n._z=this._z*b,n._isDirty=!0,n}getNormalToRef(b){const n=this.length();let i=Math.acos(this._y/n);const e=Math.atan2(this._z,this._x);i>Math.PI/2?i-=Math.PI/2:i+=Math.PI/2;const V=n*Math.sin(i)*Math.cos(e),Q=n*Math.cos(i),U=n*Math.sin(i)*Math.sin(e);return b.set(V,Q,U),b}applyRotationQuaternionToRef(b,n){const i=this._x,e=this._y,V=this._z,Q=b._x,U=b._y,Y=b._z,L=b._w,B=2*(U*V-Y*e),mb=2*(Y*i-Q*V),N=2*(Q*e-U*i);return n._x=i+L*B+U*N-Y*mb,n._y=e+L*mb+Y*B-Q*N,n._z=V+L*N+Q*mb-U*B,n._isDirty=!0,n}applyRotationQuaternionInPlace(b){return this.applyRotationQuaternionToRef(b,this)}applyRotationQuaternion(b){return this.applyRotationQuaternionToRef(b,new K)}scaleAndAddToRef(b,n){return n._x+=this._x*b,n._y+=this._y*b,n._z+=this._z*b,n._isDirty=!0,n}projectOnPlane(b,n){return this.projectOnPlaneToRef(b,n,new K)}projectOnPlaneToRef(b,n,i){const e=b.normal,V=b.d,Q=d.On[0];this.subtractToRef(n,Q),Q.normalize();const U=K.Dot(Q,e);if(Math.abs(U)<1e-10)i.Fe(1/0);else{const b=-(K.Dot(n,e)+V)/U,Y=Q.scaleInPlace(b);n.addToRef(Y,i)}return i}equals(b){return b&&this._x===b._x&&this._y===b._y&&this._z===b._z}equalsWithEpsilon(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.c;return b&&(0,L.WithinEpsilon)(this._x,b._x,n)&&(0,L.WithinEpsilon)(this._y,b._y,n)&&(0,L.WithinEpsilon)(this._z,b._z,n)}equalsToFloats(b,n,i){return this._x===b&&this._y===n&&this._z===i}multiplyInPlace(b){return this._x*=b._x,this._y*=b._y,this._z*=b._z,this._isDirty=!0,this}multiply(b){return this.multiplyByFloats(b._x,b._y,b._z)}multiplyToRef(b,n){return n._x=this._x*b._x,n._y=this._y*b._y,n._z=this._z*b._z,n._isDirty=!0,n}multiplyByFloats(b,n,i){return new K(this._x*b,this._y*n,this._z*i)}divide(b){return new K(this._x/b._x,this._y/b._y,this._z/b._z)}divideToRef(b,n){return n._x=this._x/b._x,n._y=this._y/b._y,n._z=this._z/b._z,n._isDirty=!0,n}divideInPlace(b){return this._x=this._x/b._x,this._y=this._y/b._y,this._z=this._z/b._z,this._isDirty=!0,this}minimizeInPlace(b){return this.minimizeInPlaceFromFloats(b._x,b._y,b._z)}maximizeInPlace(b){return this.maximizeInPlaceFromFloats(b._x,b._y,b._z)}minimizeInPlaceFromFloats(b,n,i){return b<this._x&&(this.x=b),n<this._y&&(this.y=n),i<this._z&&(this.z=i),this}maximizeInPlaceFromFloats(b,n,i){return b>this._x&&(this.x=b),n>this._y&&(this.y=n),i>this._z&&(this.z=i),this}isNonUniformWithinEpsilon(b){const n=Math.abs(this._x),i=Math.abs(this._y);if(!(0,L.WithinEpsilon)(n,i,b))return!0;const e=Math.abs(this._z);return!(0,L.WithinEpsilon)(n,e,b)||!(0,L.WithinEpsilon)(i,e,b)}get isNonUniform(){const b=Math.abs(this._x);if(b!==Math.abs(this._y))return!0;return b!==Math.abs(this._z)}floorToRef(b){return b._x=Math.floor(this._x),b._y=Math.floor(this._y),b._z=Math.floor(this._z),b._isDirty=!0,b}floor(){return new K(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(b){return b._x=this._x-Math.floor(this._x),b._y=this._y-Math.floor(this._y),b._z=this._z-Math.floor(this._z),b._isDirty=!0,b}fract(){return new K(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(b){if("xyz"===(b=b.toLowerCase()))return this;const n=d.On[0].L(this);return this.x=n[b[0]],this.y=n[b[1]],this.z=n[b[2]],this}rotateByQuaternionToRef(b,n){return b.toRotationMatrix(d.Matrix[0]),K.TransformCoordinatesToRef(this,d.Matrix[0],n),n}rotateByQuaternionAroundPointToRef(b,n,i){return this.subtractToRef(n,d.On[0]),d.On[0].rotateByQuaternionToRef(b,d.On[0]),n.addToRef(d.On[0],i),i}cross(b){return K.CrossToRef(this,b,new K)}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){return this.normalizeToRef(new K)}normalizeToRef(b){const n=this.length();return 0===n||1===n?(b._x=this._x,b._y=this._y,b._z=this._z,b._isDirty=!0,b):this.scaleToRef(1/n,b)}clone(){return new K(this._x,this._y,this._z)}L(b){return this.re(b._x,b._y,b._z)}re(b,n,i){return this._x=b,this._y=n,this._z=i,this._isDirty=!0,this}set(b,n,i){return this.re(b,n,i)}Fe(b){return this._x=this._y=this._z=b,this._isDirty=!0,this}static GetClipFactor(b,n,i,e){const V=K.Dot(b,i);return(V-e)/(V-K.Dot(n,i))}static GetAngleBetweenVectors(b,n,i){const e=b.normalizeToRef(d.On[1]),V=n.normalizeToRef(d.On[2]);let Q=K.Dot(e,V);Q=(0,L.Clamp)(Q,-1,1);const U=Math.acos(Q),Y=d.On[3];return K.CrossToRef(e,V,Y),K.Dot(Y,i)>0?isNaN(U)?0:U:isNaN(U)?-Math.PI:-Math.acos(Q)}static GetAngleBetweenVectorsOnPlane(b,n,i){d.On[0].L(b);const e=d.On[0];d.On[1].L(n);const V=d.On[1];d.On[2].L(i);const Q=d.On[2],U=d.On[3],Y=d.On[4];e.normalize(),V.normalize(),Q.normalize(),K.CrossToRef(Q,e,U),K.CrossToRef(U,Q,Y);const B=Math.atan2(K.Dot(V,U),K.Dot(V,Y));return(0,L.NormalizeRadians)(B)}static PitchYawRollToMoveBetweenPointsToRef(b,n,i){const e=G.On[0];return n.subtractToRef(b,e),i._y=Math.atan2(e.x,e.z)||0,i._x=Math.atan2(Math.sqrt(e.x**2+e.z**2),e.y)||0,i._z=0,i._isDirty=!0,i}static PitchYawRollToMoveBetweenPoints(b,n){const i=K.Zero();return K.PitchYawRollToMoveBetweenPointsToRef(b,n,i)}static SlerpToRef(b,n,i,V){i=(0,L.Clamp)(i,0,1);const Q=d.On[0],U=d.On[1];Q.L(b);const Y=Q.length();Q.normalizeFromLength(Y),U.L(n);const B=U.length();U.normalizeFromLength(B);const mb=K.Dot(Q,U);let N,Z;if(mb<1-e.c){const b=Math.acos(mb),n=1/Math.sin(b);N=Math.sin((1-i)*b)*n,Z=Math.sin(i*b)*n}else N=1-i,Z=i;return Q.scaleInPlace(N),U.scaleInPlace(Z),V.L(Q).addInPlace(U),V.scaleInPlace((0,L.Lerp)(Y,B,i)),V}static SmoothToRef(b,n,i,e,V){return K.SlerpToRef(b,n,0===e?1:i/e,V),V}static jn(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new K(b[n],b[n+1],b[n+2])}static FromFloatArray(b,n){return K.jn(b,n)}static FromArrayToRef(b,n,i){return i._x=b[n],i._y=b[n+1],i._z=b[n+2],i._isDirty=!0,i}static FromFloatArrayToRef(b,n,i){return K.FromArrayToRef(b,n,i)}static FromFloatsToRef(b,n,i,e){return e.re(b,n,i),e}static Zero(){return new K(0,0,0)}static One(){return new K(1,1,1)}static Up(){return new K(0,1,0)}static get UpReadOnly(){return K._UpReadOnly}static get DownReadOnly(){return K._DownReadOnly}static get RightReadOnly(){return K._RightReadOnly}static get LeftReadOnly(){return K._LeftReadOnly}static get LeftHandedForwardReadOnly(){return K._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return K._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return K._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return K._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return K._ZeroReadOnly}static get OneReadOnly(){return K._OneReadOnly}static Down(){return new K(0,-1,0)}static Forward(){return new K(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new K(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new K(1,0,0)}static Left(){return new K(-1,0,0)}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new K((0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).re((0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n))}static TransformCoordinates(b,n){const i=K.Zero();return K.TransformCoordinatesToRef(b,n,i),i}static TransformCoordinatesToRef(b,n,i){return K.TransformCoordinatesFromFloatsToRef(b._x,b._y,b._z,n,i),i}static TransformCoordinatesFromFloatsToRef(b,n,i,e,V){const Q=e.m,U=b*Q[0]+n*Q[4]+i*Q[8]+Q[12],Y=b*Q[1]+n*Q[5]+i*Q[9]+Q[13],L=b*Q[2]+n*Q[6]+i*Q[10]+Q[14],B=1/(b*Q[3]+n*Q[7]+i*Q[11]+Q[15]);return V._x=U*B,V._y=Y*B,V._z=L*B,V._isDirty=!0,V}static TransformNormal(b,n){const i=K.Zero();return K.TransformNormalToRef(b,n,i),i}static TransformNormalToRef(b,n,i){return this.TransformNormalFromFloatsToRef(b._x,b._y,b._z,n,i),i}static TransformNormalFromFloatsToRef(b,n,i,e,V){const Q=e.m;return V._x=b*Q[0]+n*Q[4]+i*Q[8],V._y=b*Q[1]+n*Q[5]+i*Q[9],V._z=b*Q[2]+n*Q[6]+i*Q[10],V._isDirty=!0,V}static CatmullRom(b,n,i,e,V){const Q=V*V,U=V*Q,Y=.5*(2*n._x+(-b._x+i._x)*V+(2*b._x-5*n._x+4*i._x-e._x)*Q+(-b._x+3*n._x-3*i._x+e._x)*U),L=.5*(2*n._y+(-b._y+i._y)*V+(2*b._y-5*n._y+4*i._y-e._y)*Q+(-b._y+3*n._y-3*i._y+e._y)*U),B=.5*(2*n._z+(-b._z+i._z)*V+(2*b._z-5*n._z+4*i._z-e._z)*Q+(-b._z+3*n._z-3*i._z+e._z)*U);return new K(Y,L,B)}static Clamp(b,n,i){const e=new K;return K.ClampToRef(b,n,i,e),e}static ClampToRef(b,n,i,e){let V=b._x;V=V>i._x?i._x:V,V=V<n._x?n._x:V;let Q=b._y;Q=Q>i._y?i._y:Q,Q=Q<n._y?n._y:Q;let U=b._z;return U=U>i._z?i._z:U,U=U<n._z?n._z:U,e.re(V,Q,U),e}static CheckExtends(b,n,i){n.minimizeInPlace(b),i.maximizeInPlace(b)}static Hermite(b,n,i,e,V){const Q=V*V,U=V*Q,Y=2*U-3*Q+1,L=-2*U+3*Q,B=U-2*Q+V,mb=U-Q,N=b._x*Y+i._x*L+n._x*B+e._x*mb,Z=b._y*Y+i._y*L+n._y*B+e._y*mb,T=b._z*Y+i._z*L+n._z*B+e._z*mb;return new K(N,Z,T)}static Hermite1stDerivative(b,n,i,e,V){const Q=new K;return this.Hermite1stDerivativeToRef(b,n,i,e,V,Q),Q}static Hermite1stDerivativeToRef(b,n,i,e,V,Q){const U=V*V;return Q._x=6*(U-V)*b._x+(3*U-4*V+1)*n._x+6*(-U+V)*i._x+(3*U-2*V)*e._x,Q._y=6*(U-V)*b._y+(3*U-4*V+1)*n._y+6*(-U+V)*i._y+(3*U-2*V)*e._y,Q._z=6*(U-V)*b._z+(3*U-4*V+1)*n._z+6*(-U+V)*i._z+(3*U-2*V)*e._z,Q._isDirty=!0,Q}static Lerp(b,n,i){const e=new K(0,0,0);return K.LerpToRef(b,n,i,e),e}static LerpToRef(b,n,i,e){return e._x=b._x+(n._x-b._x)*i,e._y=b._y+(n._y-b._y)*i,e._z=b._z+(n._z-b._z)*i,e._isDirty=!0,e}static Dot(b,n){return b._x*n._x+b._y*n._y+b._z*n._z}dot(b){return this._x*b._x+this._y*b._y+this._z*b._z}static Cross(b,n){const i=new K;return K.CrossToRef(b,n,i),i}static CrossToRef(b,n,i){const e=b._y*n._z-b._z*n._y,V=b._z*n._x-b._x*n._z,Q=b._x*n._y-b._y*n._x;return i.re(e,V,Q),i}static Normalize(b){const n=K.Zero();return K.NormalizeToRef(b,n),n}static NormalizeToRef(b,n){return b.normalizeToRef(n),n}static Project(b,n,i,e){const V=new K;return K.ProjectToRef(b,n,i,e,V),V}static ProjectToRef(b,n,i,e,V){var Q;const U=e.width,L=e.height,B=e.x,mb=e.y,N=d.Matrix[1],Z=null===(Q=Y.d.LastCreatedEngine)||void 0===Q?void 0:Q.isNDCHalfZRange,T=Z?1:.5,z=Z?0:.5;u.FromValuesToRef(U/2,0,0,0,0,-L/2,0,0,0,0,T,0,B+U/2,L/2+mb,z,1,N);const I=d.Matrix[0];return n.multiplyToRef(i,I),I.multiplyToRef(N,I),K.TransformCoordinatesToRef(b,I,V),V}static Reflect(b,n){return this.ReflectToRef(b,n,new K)}static ReflectToRef(b,n,i){const e=G.On[0];return e.L(n).scaleInPlace(2*K.Dot(b,n)),i.L(b).lm(e)}static _UnprojectFromInvertedMatrixToRef(b,n,i){K.TransformCoordinatesToRef(b,n,i);const e=n.m,V=b._x*e[3]+b._y*e[7]+b._z*e[11]+e[15];return(0,L.WithinEpsilon)(V,1)&&i.scaleInPlace(1/V),i}static UnprojectFromTransform(b,n,i,e,V){return this.Unproject(b,n,i,e,V,u.IdentityReadOnly)}static Unproject(b,n,i,e,V,Q){const U=new K;return K.UnprojectToRef(b,n,i,e,V,Q,U),U}static UnprojectToRef(b,n,i,e,V,Q,U){return K.UnprojectFloatsToRef(b._x,b._y,b._z,n,i,e,V,Q,U),U}static UnprojectFloatsToRef(b,n,i,e,V,Q,U,L,B){var mb;const N=d.Matrix[0];Q.multiplyToRef(U,N),N.multiplyToRef(L,N),N.invert();const Z=d.On[0];return Z.x=b/e*2-1,Z.y=-(n/V*2-1),null!==(mb=Y.d.LastCreatedEngine)&&void 0!==mb&&mb.isNDCHalfZRange?Z.z=i:Z.z=2*i-1,K._UnprojectFromInvertedMatrixToRef(Z,N,B),B}static Minimize(b,n){const i=new K;return i.L(b),i.minimizeInPlace(n),i}static Maximize(b,n){const i=new K;return i.L(b),i.maximizeInPlace(n),i}static Distance(b,n){return Math.sqrt(K.DistanceSquared(b,n))}static DistanceSquared(b,n){const i=b._x-n._x,e=b._y-n._y,V=b._z-n._z;return i*i+e*e+V*V}static ProjectOnTriangleToRef(b,n,i,V,Q){const U=d.On[0],Y=d.On[1],B=d.On[2],mb=d.On[3],N=d.On[4];i.subtractToRef(n,U),V.subtractToRef(n,Y),V.subtractToRef(i,B);const Z=U.length(),T=Y.length(),z=B.length();if(Z<e.c||T<e.c||z<e.c)return Q.L(n),K.Distance(b,n);b.subtractToRef(n,N),K.CrossToRef(U,Y,mb);const I=mb.length();if(I<e.c)return Q.L(n),K.Distance(b,n);mb.normalizeFromLength(I);let O=N.length();if(O<e.c)return Q.L(n),0;N.normalizeFromLength(O);const u=K.Dot(mb,N),G=d.On[5],o=d.On[6];G.L(mb).scaleInPlace(-O*u),o.L(b).addInPlace(G);const M=d.On[4],j=d.On[5],a=d.On[7],D=d.On[8];M.L(U).scaleInPlace(1/Z),D.L(Y).scaleInPlace(1/T),M.addInPlace(D).scaleInPlace(-1),j.L(U).scaleInPlace(-1/Z),D.L(B).scaleInPlace(1/z),j.addInPlace(D).scaleInPlace(-1),a.L(B).scaleInPlace(-1/z),D.L(Y).scaleInPlace(-1/T),a.addInPlace(D).scaleInPlace(-1);const x=d.On[9];let y;x.L(o).lm(n),K.CrossToRef(M,x,D),y=K.Dot(D,mb);const s=y;x.L(o).lm(i),K.CrossToRef(j,x,D),y=K.Dot(D,mb);const A=y;x.L(o).lm(V),K.CrossToRef(a,x,D),y=K.Dot(D,mb);const E=y,C=d.On[10];let t,w;s>0&&A<0?(C.L(U),t=n,w=i):A>0&&E<0?(C.L(B),t=i,w=V):(C.L(Y).scaleInPlace(-1),t=V,w=n);const h=d.On[9],W=d.On[4];t.subtractToRef(o,D),w.subtractToRef(o,h),K.CrossToRef(D,h,W);if(!(K.Dot(W,mb)<0))return Q.L(o),Math.abs(O*u);const J=d.On[5];K.CrossToRef(C,W,J),J.normalize();const R=d.On[9];R.L(t).lm(o);const k=R.length();if(k<e.c)return Q.L(t),K.Distance(b,t);R.normalizeFromLength(k);const r=K.Dot(J,R),X=d.On[7];X.L(o).addInPlace(J.scaleInPlace(k*r)),D.L(X).lm(t),O=C.length(),C.normalizeFromLength(O);let g=K.Dot(D,C)/Math.max(O,e.c);return g=(0,L.Clamp)(g,0,1),X.L(t).addInPlace(C.scaleInPlace(g*O)),Q.L(X),K.Distance(b,X)}static Center(b,n){return K.CenterToRef(b,n,K.Zero())}static CenterToRef(b,n,i){return i.re((b._x+n._x)/2,(b._y+n._y)/2,(b._z+n._z)/2)}static RotationFromAxis(b,n,i){const e=new K;return K.RotationFromAxisToRef(b,n,i,e),e}static RotationFromAxisToRef(b,n,i,e){const V=d.Quaternion[0];return O.RotationQuaternionFromAxisToRef(b,n,i,V),V.toEulerAnglesToRef(e),e}}K._V8PerformanceHack=new K(.5,.5,.5),K._UpReadOnly=K.Up(),K._DownReadOnly=K.Down(),K._LeftHandedForwardReadOnly=K.Forward(!1),K._RightHandedForwardReadOnly=K.Forward(!0),K._LeftHandedBackwardReadOnly=K.Backward(!1),K._RightHandedBackwardReadOnly=K.Backward(!0),K._RightReadOnly=K.Right(),K._LeftReadOnly=K.Left(),K._ZeroReadOnly=K.Zero(),K._OneReadOnly=K.One(),Object.defineProperties(K.prototype,{dimension:{value:[3]},rank:{value:1}});class I{get x(){return this._x}set x(b){this._x=b,this._isDirty=!0}get y(){return this._y}set y(b){this._y=b,this._isDirty=!0}get z(){return this._z}set z(b){this._z=b,this._isDirty=!0}get w(){return this._w}set w(b){this._w=b,this._isDirty=!0}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=b,this._y=n,this._z=i,this._w=e}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let b=T(this._x);return b=397*b^T(this._y),b=397*b^T(this._z),b=397*b^T(this._w),b}ye(){return[this._x,this._y,this._z,this._w]}toArray(b,n){return void 0===n&&(n=0),b[n]=this._x,b[n+1]=this._y,b[n+2]=this._z,b[n+3]=this._w,this}Gi(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I.FromArrayToRef(b,n,this),this}addInPlace(b){return this.x+=b._x,this.y+=b._y,this.z+=b._z,this.w+=b._w,this}addInPlaceFromFloats(b,n,i,e){return this.x+=b,this.y+=n,this.z+=i,this.w+=e,this}add(b){return new I(this._x+b.x,this._y+b.y,this._z+b.z,this._w+b.w)}addToRef(b,n){return n.x=this._x+b.x,n.y=this._y+b.y,n.z=this._z+b.z,n.w=this._w+b.w,n}lm(b){return this.x-=b.x,this.y-=b.y,this.z-=b.z,this.w-=b.w,this}un(b){return new I(this._x-b.x,this._y-b.y,this._z-b.z,this._w-b.w)}subtractToRef(b,n){return n.x=this._x-b.x,n.y=this._y-b.y,n.z=this._z-b.z,n.w=this._w-b.w,n}subtractFromFloats(b,n,i,e){return new I(this._x-b,this._y-n,this._z-i,this._w-e)}subtractFromFloatsToRef(b,n,i,e,V){return V.x=this._x-b,V.y=this._y-n,V.z=this._z-i,V.w=this._w-e,V}negate(){return new I(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(b){return b.x=-this._x,b.y=-this._y,b.z=-this._z,b.w=-this._w,b}scaleInPlace(b){return this.x*=b,this.y*=b,this.z*=b,this.w*=b,this}scale(b){return new I(this._x*b,this._y*b,this._z*b,this._w*b)}scaleToRef(b,n){return n.x=this._x*b,n.y=this._y*b,n.z=this._z*b,n.w=this._w*b,n}scaleAndAddToRef(b,n){return n.x+=this._x*b,n.y+=this._y*b,n.z+=this._z*b,n.w+=this._w*b,n}equals(b){return b&&this._x===b.x&&this._y===b.y&&this._z===b.z&&this._w===b.w}equalsWithEpsilon(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.c;return b&&(0,L.WithinEpsilon)(this._x,b.x,n)&&(0,L.WithinEpsilon)(this._y,b.y,n)&&(0,L.WithinEpsilon)(this._z,b.z,n)&&(0,L.WithinEpsilon)(this._w,b.w,n)}equalsToFloats(b,n,i,e){return this._x===b&&this._y===n&&this._z===i&&this._w===e}multiplyInPlace(b){return this.x*=b.x,this.y*=b.y,this.z*=b.z,this.w*=b.w,this}multiply(b){return new I(this._x*b.x,this._y*b.y,this._z*b.z,this._w*b.w)}multiplyToRef(b,n){return n.x=this._x*b.x,n.y=this._y*b.y,n.z=this._z*b.z,n.w=this._w*b.w,n}multiplyByFloats(b,n,i,e){return new I(this._x*b,this._y*n,this._z*i,this._w*e)}divide(b){return new I(this._x/b.x,this._y/b.y,this._z/b.z,this._w/b.w)}divideToRef(b,n){return n.x=this._x/b.x,n.y=this._y/b.y,n.z=this._z/b.z,n.w=this._w/b.w,n}divideInPlace(b){return this.divideToRef(b,this)}minimizeInPlace(b){return b.x<this._x&&(this.x=b.x),b.y<this._y&&(this.y=b.y),b.z<this._z&&(this.z=b.z),b.w<this._w&&(this.w=b.w),this}maximizeInPlace(b){return b.x>this._x&&(this.x=b.x),b.y>this._y&&(this.y=b.y),b.z>this._z&&(this.z=b.z),b.w>this._w&&(this.w=b.w),this}minimizeInPlaceFromFloats(b,n,i,e){return this.x=Math.min(b,this._x),this.y=Math.min(n,this._y),this.z=Math.min(i,this._z),this.w=Math.min(e,this._w),this}maximizeInPlaceFromFloats(b,n,i,e){return this.x=Math.max(b,this._x),this.y=Math.max(n,this._y),this.z=Math.max(i,this._z),this.w=Math.max(e,this._w),this}floorToRef(b){return b.x=Math.floor(this._x),b.y=Math.floor(this._y),b.z=Math.floor(this._z),b.w=Math.floor(this._w),b}floor(){return new I(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(b){return b.x=this._x-Math.floor(this._x),b.y=this._y-Math.floor(this._y),b.z=this._z-Math.floor(this._z),b.w=this._w-Math.floor(this._w),b}fract(){return new I(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){return this.normalizeToRef(new I)}normalizeToRef(b){const n=this.length();return 0===n||1===n?(b.x=this._x,b.y=this._y,b.z=this._z,b.w=this._w,b):this.scaleToRef(1/n,b)}toVector3(){return new K(this._x,this._y,this._z)}clone(){return new I(this._x,this._y,this._z,this._w)}L(b){return this.x=b.x,this.y=b.y,this.z=b.z,this.w=b.w,this}re(b,n,i,e){return this.x=b,this.y=n,this.z=i,this.w=e,this}set(b,n,i,e){return this.re(b,n,i,e)}Fe(b){return this.x=this.y=this.z=this.w=b,this}dot(b){return this._x*b.x+this._y*b.y+this._z*b.z+this._w*b.w}static jn(b,n){return n||(n=0),new I(b[n],b[n+1],b[n+2],b[n+3])}static FromArrayToRef(b,n,i){return i.x=b[n],i.y=b[n+1],i.z=b[n+2],i.w=b[n+3],i}static FromFloatArrayToRef(b,n,i){return I.FromArrayToRef(b,n,i),i}static FromFloatsToRef(b,n,i,e,V){return V.x=b,V.y=n,V.z=i,V.w=e,V}static Zero(){return new I(0,0,0,0)}static One(){return new I(1,1,1,1)}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new I((0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0;return i.x=(0,L.RandomRange)(b,n),i.y=(0,L.RandomRange)(b,n),i.z=(0,L.RandomRange)(b,n),i.w=(0,L.RandomRange)(b,n),i}static Clamp(b,n,i){return I.ClampToRef(b,n,i,new I)}static ClampToRef(b,n,i,e){return e.x=(0,L.Clamp)(b.x,n.x,i.x),e.y=(0,L.Clamp)(b.y,n.y,i.y),e.z=(0,L.Clamp)(b.z,n.z,i.z),e.w=(0,L.Clamp)(b.w,n.w,i.w),e}static CheckExtends(b,n,i){n.minimizeInPlace(b),i.maximizeInPlace(b)}static get ZeroReadOnly(){return I._ZeroReadOnly}static Normalize(b){return I.NormalizeToRef(b,new I)}static NormalizeToRef(b,n){return b.normalizeToRef(n),n}static Minimize(b,n){const i=new I;return i.L(b),i.minimizeInPlace(n),i}static Maximize(b,n){const i=new I;return i.L(b),i.maximizeInPlace(n),i}static Distance(b,n){return Math.sqrt(I.DistanceSquared(b,n))}static DistanceSquared(b,n){const i=b.x-n.x,e=b.y-n.y,V=b.z-n.z,Q=b.w-n.w;return i*i+e*e+V*V+Q*Q}static Center(b,n){return I.CenterToRef(b,n,new I)}static CenterToRef(b,n,i){return i.x=(b.x+n.x)/2,i.y=(b.y+n.y)/2,i.z=(b.z+n.z)/2,i.w=(b.w+n.w)/2,i}static TransformCoordinates(b,n){return I.TransformCoordinatesToRef(b,n,new I)}static TransformCoordinatesToRef(b,n,i){return I.TransformCoordinatesFromFloatsToRef(b._x,b._y,b._z,n,i),i}static TransformCoordinatesFromFloatsToRef(b,n,i,e,V){const Q=e.m,U=b*Q[0]+n*Q[4]+i*Q[8]+Q[12],Y=b*Q[1]+n*Q[5]+i*Q[9]+Q[13],L=b*Q[2]+n*Q[6]+i*Q[10]+Q[14],B=b*Q[3]+n*Q[7]+i*Q[11]+Q[15];return V.x=U,V.y=Y,V.z=L,V.w=B,V}static TransformNormal(b,n){return I.TransformNormalToRef(b,n,new I)}static TransformNormalToRef(b,n,i){const e=n.m,V=b.x*e[0]+b.y*e[4]+b.z*e[8],Q=b.x*e[1]+b.y*e[5]+b.z*e[9],U=b.x*e[2]+b.y*e[6]+b.z*e[10];return i.x=V,i.y=Q,i.z=U,i.w=b.w,i}static TransformNormalFromFloatsToRef(b,n,i,e,V,Q){const U=V.m;return Q.x=b*U[0]+n*U[4]+i*U[8],Q.y=b*U[1]+n*U[5]+i*U[9],Q.z=b*U[2]+n*U[6]+i*U[10],Q.w=e,Q}static FromVector3(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new I(b._x,b._y,b._z,n)}static Dot(b,n){return b.x*n.x+b.y*n.y+b.z*n.z+b.w*n.w}}I._V8PerformanceHack=new I(.5,.5,.5,.5),I._ZeroReadOnly=I.Zero(),Object.defineProperties(I.prototype,{dimension:{value:[4]},rank:{value:1}});class O{get x(){return this._x}set x(b){this._x=b,this._isDirty=!0}get y(){return this._y}set y(b){this._y=b,this._isDirty=!0}get z(){return this._z}set z(b){this._z=b,this._isDirty=!0}get w(){return this._w}set w(b){this._w=b,this._isDirty=!0}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=b,this._y=n,this._z=i,this._w=e}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let b=T(this._x);return b=397*b^T(this._y),b=397*b^T(this._z),b=397*b^T(this._w),b}ye(){return[this._x,this._y,this._z,this._w]}toArray(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[n]=this._x,b[n+1]=this._y,b[n+2]=this._z,b[n+3]=this._w,this}Gi(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(b,n,this)}equals(b){return b&&this._x===b._x&&this._y===b._y&&this._z===b._z&&this._w===b._w}equalsWithEpsilon(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.c;return b&&(0,L.WithinEpsilon)(this._x,b._x,n)&&(0,L.WithinEpsilon)(this._y,b._y,n)&&(0,L.WithinEpsilon)(this._z,b._z,n)&&(0,L.WithinEpsilon)(this._w,b._w,n)}isApprox(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.c;return b&&((0,L.WithinEpsilon)(this._x,b._x,n)&&(0,L.WithinEpsilon)(this._y,b._y,n)&&(0,L.WithinEpsilon)(this._z,b._z,n)&&(0,L.WithinEpsilon)(this._w,b._w,n)||(0,L.WithinEpsilon)(this._x,-b._x,n)&&(0,L.WithinEpsilon)(this._y,-b._y,n)&&(0,L.WithinEpsilon)(this._z,-b._z,n)&&(0,L.WithinEpsilon)(this._w,-b._w,n))}clone(){return new O(this._x,this._y,this._z,this._w)}L(b){return this._x=b._x,this._y=b._y,this._z=b._z,this._w=b._w,this._isDirty=!0,this}re(b,n,i,e){return this._x=b,this._y=n,this._z=i,this._w=e,this._isDirty=!0,this}set(b,n,i,e){return this.re(b,n,i,e)}Fe(b){return this.re(b,b,b,b)}add(b){return new O(this._x+b._x,this._y+b._y,this._z+b._z,this._w+b._w)}addInPlace(b){return this._x+=b._x,this._y+=b._y,this._z+=b._z,this._w+=b._w,this._isDirty=!0,this}addToRef(b,n){return n._x=this._x+b._x,n._y=this._y+b._y,n._z=this._z+b._z,n._w=this._w+b._w,n._isDirty=!0,n}addInPlaceFromFloats(b,n,i,e){return this._x+=b,this._y+=n,this._z+=i,this._w+=e,this._isDirty=!0,this}subtractToRef(b,n){return n._x=this._x-b._x,n._y=this._y-b._y,n._z=this._z-b._z,n._w=this._w-b._w,n._isDirty=!0,n}subtractFromFloats(b,n,i,e){return this.subtractFromFloatsToRef(b,n,i,e,new O)}subtractFromFloatsToRef(b,n,i,e,V){return V._x=this._x-b,V._y=this._y-n,V._z=this._z-i,V._w=this._w-e,V._isDirty=!0,V}un(b){return new O(this._x-b._x,this._y-b._y,this._z-b._z,this._w-b._w)}lm(b){return this._x-=b._x,this._y-=b._y,this._z-=b._z,this._w-=b._w,this._isDirty=!0,this}scale(b){return new O(this._x*b,this._y*b,this._z*b,this._w*b)}scaleToRef(b,n){return n._x=this._x*b,n._y=this._y*b,n._z=this._z*b,n._w=this._w*b,n._isDirty=!0,n}scaleInPlace(b){return this._x*=b,this._y*=b,this._z*=b,this._w*=b,this._isDirty=!0,this}scaleAndAddToRef(b,n){return n._x+=this._x*b,n._y+=this._y*b,n._z+=this._z*b,n._w+=this._w*b,n._isDirty=!0,n}multiply(b){const n=new O(0,0,0,1);return this.multiplyToRef(b,n),n}multiplyToRef(b,n){const i=this._x*b._w+this._y*b._z-this._z*b._y+this._w*b._x,e=-this._x*b._z+this._y*b._w+this._z*b._x+this._w*b._y,V=this._x*b._y-this._y*b._x+this._z*b._w+this._w*b._z,Q=-this._x*b._x-this._y*b._y-this._z*b._z+this._w*b._w;return n.re(i,e,V,Q),n}multiplyInPlace(b){return this.multiplyToRef(b,this)}multiplyByFloats(b,n,i,e){return this._x*=b,this._y*=n,this._z*=i,this._w*=e,this._isDirty=!0,this}divide(b){throw new ReferenceError("Can not divide a quaternion")}divideToRef(b,n){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(b){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new O)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(b){return b._x=-this._x,b._y=-this._y,b._z=-this._z,b._w=-this._w,b._isDirty=!0,b}equalsToFloats(b,n,i,e){return this._x===b&&this._y===n&&this._z===i&&this._w===e}floorToRef(b){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(b){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(b){return b.re(-this._x,-this._y,-this._z,this._w),b}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new O(-this._x,-this._y,-this._z,this._w)}invert(){const b=this.conjugate(),n=this.lengthSquared();return 0==n||1==n||b.scaleInPlace(1/n),b}invertInPlace(){this.conjugateInPlace();const b=this.lengthSquared();return 0==b||1==b||this.scaleInPlace(1/b),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){const b=new O(0,0,0,1);return this.normalizeToRef(b),b}normalizeToRef(b){const n=this.length();return 0===n||1===n?b.re(this._x,this._y,this._z,this._w):this.scaleToRef(1/n,b)}toEulerAngles(){const b=K.Zero();return this.toEulerAnglesToRef(b),b}toEulerAnglesToRef(b){const n=this._z,i=this._x,e=this._y,V=this._w,Q=e*n-i*V,U=.4999999;if(Q<-U)b._y=2*Math.atan2(e,V),b._x=Math.PI/2,b._z=0,b._isDirty=!0;else if(Q>U)b._y=2*Math.atan2(e,V),b._x=-Math.PI/2,b._z=0,b._isDirty=!0;else{const U=V*V,Y=n*n,L=i*i,B=e*e;b._z=Math.atan2(2*(i*e+n*V),-Y-L+B+U),b._x=Math.asin(-2*Q),b._y=Math.atan2(2*(n*i+e*V),Y-L-B+U),b._isDirty=!0}return b}toAlphaBetaGammaToRef(b){const n=this._z,i=this._x,e=this._y,V=this._w,Q=Math.sqrt(i*i+e*e),U=Math.sqrt(n*n+V*V),Y=2*Math.atan2(Q,U),L=2*Math.atan2(n,V),B=2*Math.atan2(e,i),mb=(L+B)/2,N=(L-B)/2;return b.set(N,Y,mb),b}toRotationMatrix(b){return u.FromQuaternionToRef(this,b),b}fromRotationMatrix(b){return O.FromRotationMatrixToRef(b,this),this}dot(b){return this._x*b._x+this._y*b._y+this._z*b._z+this._w*b._w}toAxisAngle(){const b=K.Zero();return{axis:b,angle:this.toAxisAngleToRef(b)}}toAxisAngleToRef(b){let n=0;const i=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),e=this._w;return i>0?(n=2*Math.atan2(i,e),b.set(this._x/i,this._y/i,this._z/i)):(n=0,b.set(1,0,0)),n}static FromRotationMatrix(b){const n=new O;return O.FromRotationMatrixToRef(b,n),n}static FromRotationMatrixToRef(b,n){const i=b.m,e=i[0],V=i[4],Q=i[8],U=i[1],Y=i[5],L=i[9],B=i[2],mb=i[6],N=i[10],Z=e+Y+N;let T;return Z>0?(T=.5/Math.sqrt(Z+1),n._w=.25/T,n._x=(mb-L)*T,n._y=(Q-B)*T,n._z=(U-V)*T,n._isDirty=!0):e>Y&&e>N?(T=2*Math.sqrt(1+e-Y-N),n._w=(mb-L)/T,n._x=.25*T,n._y=(V+U)/T,n._z=(Q+B)/T,n._isDirty=!0):Y>N?(T=2*Math.sqrt(1+Y-e-N),n._w=(Q-B)/T,n._x=(V+U)/T,n._y=.25*T,n._z=(L+mb)/T,n._isDirty=!0):(T=2*Math.sqrt(1+N-e-Y),n._w=(U-V)/T,n._x=(Q+B)/T,n._y=(L+mb)/T,n._z=.25*T,n._isDirty=!0),n}static Dot(b,n){return b._x*n._x+b._y*n._y+b._z*n._z+b._w*n._w}static AreClose(b,n){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const e=O.Dot(b,n);return 1-e*e<=i}static SmoothToRef(b,n,i,e,V){let Q=0===e?1:i/e;return Q=(0,L.Clamp)(Q,0,1),O.SlerpToRef(b,n,Q,V),V}static Zero(){return new O(0,0,0,0)}static Inverse(b){return new O(-b._x,-b._y,-b._z,b._w)}static InverseToRef(b,n){return n.set(-b._x,-b._y,-b._z,b._w),n}static Identity(){return new O(0,0,0,1)}static IsIdentity(b){return b&&0===b._x&&0===b._y&&0===b._z&&1===b._w}static RotationAxis(b,n){return O.RotationAxisToRef(b,n,new O)}static RotationAxisToRef(b,n,i){i._w=Math.cos(n/2);const e=Math.sin(n/2)/b.length();return i._x=b._x*e,i._y=b._y*e,i._z=b._z*e,i._isDirty=!0,i}static jn(b,n){return n||(n=0),new O(b[n],b[n+1],b[n+2],b[n+3])}static FromArrayToRef(b,n,i){return i._x=b[n],i._y=b[n+1],i._z=b[n+2],i._w=b[n+3],i._isDirty=!0,i}static FromFloatsToRef(b,n,i,e,V){return V.re(b,n,i,e),V}static FromEulerAngles(b,n,i){const e=new O;return O.RotationYawPitchRollToRef(n,b,i,e),e}static FromEulerAnglesToRef(b,n,i,e){return O.RotationYawPitchRollToRef(n,b,i,e),e}static FromEulerVector(b){const n=new O;return O.RotationYawPitchRollToRef(b._y,b._x,b._z,n),n}static FromEulerVectorToRef(b,n){return O.RotationYawPitchRollToRef(b._y,b._x,b._z,n),n}static FromUnitVectorsToRef(b,n,i){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.c;const Q=K.Dot(b,n)+1;return Q<V?Math.abs(b.x)>Math.abs(b.z)?i.set(-b.y,b.x,0,0):i.set(0,-b.z,b.y,0):(K.CrossToRef(b,n,G.On[0]),i.set(G.On[0].x,G.On[0].y,G.On[0].z,Q)),i.normalize()}static RotationYawPitchRoll(b,n,i){const e=new O;return O.RotationYawPitchRollToRef(b,n,i,e),e}static RotationYawPitchRollToRef(b,n,i,e){const V=.5*i,Q=.5*n,U=.5*b,Y=Math.sin(V),L=Math.cos(V),B=Math.sin(Q),mb=Math.cos(Q),N=Math.sin(U),Z=Math.cos(U);return e._x=Z*B*L+N*mb*Y,e._y=N*mb*L-Z*B*Y,e._z=Z*mb*Y-N*B*L,e._w=Z*mb*L+N*B*Y,e._isDirty=!0,e}static RotationAlphaBetaGamma(b,n,i){const e=new O;return O.RotationAlphaBetaGammaToRef(b,n,i,e),e}static RotationAlphaBetaGammaToRef(b,n,i,e){const V=.5*(i+b),Q=.5*(i-b),U=.5*n;return e._x=Math.cos(Q)*Math.sin(U),e._y=Math.sin(Q)*Math.sin(U),e._z=Math.sin(V)*Math.cos(U),e._w=Math.cos(V)*Math.cos(U),e._isDirty=!0,e}static RotationQuaternionFromAxis(b,n,i){const e=new O(0,0,0,0);return O.RotationQuaternionFromAxisToRef(b,n,i,e),e}static RotationQuaternionFromAxisToRef(b,n,i,e){const V=d.Matrix[0];return b=b.normalizeToRef(d.On[0]),n=n.normalizeToRef(d.On[1]),i=i.normalizeToRef(d.On[2]),u.FromXYZAxesToRef(b,n,i,V),O.FromRotationMatrixToRef(V,e),e}static FromLookDirectionLH(b,n){const i=new O;return O.FromLookDirectionLHToRef(b,n,i),i}static FromLookDirectionLHToRef(b,n,i){const e=d.Matrix[0];return u.LookDirectionLHToRef(b,n,e),O.FromRotationMatrixToRef(e,i),i}static FromLookDirectionRH(b,n){const i=new O;return O.FromLookDirectionRHToRef(b,n,i),i}static FromLookDirectionRHToRef(b,n,i){const e=d.Matrix[0];return u.LookDirectionRHToRef(b,n,e),O.FromRotationMatrixToRef(e,i)}static Slerp(b,n,i){const e=O.Identity();return O.SlerpToRef(b,n,i,e),e}static SlerpToRef(b,n,i,e){let V,Q,U=b._x*n._x+b._y*n._y+b._z*n._z+b._w*n._w,Y=!1;if(U<0&&(Y=!0,U=-U),U>.999999)Q=1-i,V=Y?-i:i;else{const b=Math.acos(U),n=1/Math.sin(b);Q=Math.sin((1-i)*b)*n,V=Y?-Math.sin(i*b)*n:Math.sin(i*b)*n}return e._x=Q*b._x+V*n._x,e._y=Q*b._y+V*n._y,e._z=Q*b._z+V*n._z,e._w=Q*b._w+V*n._w,e._isDirty=!0,e}static Hermite(b,n,i,e,V){const Q=V*V,U=V*Q,Y=2*U-3*Q+1,L=-2*U+3*Q,B=U-2*Q+V,mb=U-Q,N=b._x*Y+i._x*L+n._x*B+e._x*mb,Z=b._y*Y+i._y*L+n._y*B+e._y*mb,T=b._z*Y+i._z*L+n._z*B+e._z*mb,z=b._w*Y+i._w*L+n._w*B+e._w*mb;return new O(N,Z,T,z)}static Hermite1stDerivative(b,n,i,e,V){const Q=new O;return this.Hermite1stDerivativeToRef(b,n,i,e,V,Q),Q}static Hermite1stDerivativeToRef(b,n,i,e,V,Q){const U=V*V;return Q._x=6*(U-V)*b._x+(3*U-4*V+1)*n._x+6*(-U+V)*i._x+(3*U-2*V)*e._x,Q._y=6*(U-V)*b._y+(3*U-4*V+1)*n._y+6*(-U+V)*i._y+(3*U-2*V)*e._y,Q._z=6*(U-V)*b._z+(3*U-4*V+1)*n._z+6*(-U+V)*i._z+(3*U-2*V)*e._z,Q._w=6*(U-V)*b._w+(3*U-4*V+1)*n._w+6*(-U+V)*i._w+(3*U-2*V)*e._w,Q._isDirty=!0,Q}static Normalize(b){const n=O.Zero();return O.NormalizeToRef(b,n),n}static NormalizeToRef(b,n){return b.normalizeToRef(n),n}static Clamp(b,n,i){const e=new O;return O.ClampToRef(b,n,i,e),e}static ClampToRef(b,n,i,e){return e.re((0,L.Clamp)(b.x,n.x,i.x),(0,L.Clamp)(b.y,n.y,i.y),(0,L.Clamp)(b.z,n.z,i.z),(0,L.Clamp)(b.w,n.w,i.w))}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new O((0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).re((0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n),(0,L.RandomRange)(b,n))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(b,n){return Math.sqrt(O.DistanceSquared(b,n))}static DistanceSquared(b,n){const i=b.x-n.x,e=b.y-n.y,V=b.z-n.z,Q=b.w-n.w;return i*i+e*e+V*V+Q*Q}static Center(b,n){return O.CenterToRef(b,n,O.Zero())}static CenterToRef(b,n,i){return i.re((b.x+n.x)/2,(b.y+n.y)/2,(b.z+n.z)/2,(b.w+n.w)/2)}}O._V8PerformanceHack=new O(.5,.5,.5,.5),Object.defineProperties(O.prototype,{dimension:{value:[4]},rank:{value:1}});class u{static get Use64Bits(){return U.b.MatrixUse64Bits}get m(){return this.Ue}markAsUpdated(){this.updateFlag=B._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(b){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],e=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=b,this._isIdentity3x2=b||i,this._isIdentityDirty=!this._isIdentity&&n,this._isIdentity3x2Dirty=!this._isIdentity3x2&&e}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,U.b.MatrixTrackPrecisionChange&&U.b.MatrixTrackedMatrices.push(this),this.Ue=new U.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const b=this.Ue;this._isIdentity=1===b[0]&&0===b[1]&&0===b[2]&&0===b[3]&&0===b[4]&&1===b[5]&&0===b[6]&&0===b[7]&&0===b[8]&&0===b[9]&&1===b[10]&&0===b[11]&&0===b[12]&&0===b[13]&&0===b[14]&&1===b[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Ue[0]||1!==this.Ue[5]||1!==this.Ue[15]||0!==this.Ue[1]||0!==this.Ue[2]||0!==this.Ue[3]||0!==this.Ue[4]||0!==this.Ue[6]||0!==this.Ue[7]||0!==this.Ue[8]||0!==this.Ue[9]||0!==this.Ue[10]||0!==this.Ue[11]||0!==this.Ue[12]||0!==this.Ue[13]||0!==this.Ue[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const b=this.Ue,n=b[0],i=b[1],e=b[2],V=b[3],Q=b[4],U=b[5],Y=b[6],L=b[7],B=b[8],mb=b[9],N=b[10],Z=b[11],T=b[12],z=b[13],K=b[14],I=b[15],O=N*I-K*Z,u=mb*I-z*Z,d=mb*K-z*N,G=B*I-T*Z,o=B*K-N*T,M=B*z-T*mb;return n*+(U*O-Y*u+L*d)+i*-(Q*O-Y*G+L*o)+e*+(Q*u-U*G+L*M)+V*-(Q*d-U*o+Y*M)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!b)return this.Ue;const i=this.Ue;for(let e=0;e<16;e++)b[n+e]=i[e];return this}ye(){return this.Ue}Gi(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(b,n,this)}re(){for(var b=arguments.length,n=new Array(b),i=0;i<b;i++)n[i]=arguments[i];return u.FromArrayToRef(n,0,this)}set(){const b=this.Ue;for(let n=0;n<16;n++)b[n]=n<0||arguments.length<=n?void 0:arguments[n];return this.markAsUpdated(),this}Fe(b){const n=this.Ue;for(let i=0;i<16;i++)n[i]=b;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return u.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(b){const n=new u;return this.addToRef(b,n),n}addToRef(b,n){const i=this.Ue,e=n.Ue,V=b.m;for(let Q=0;Q<16;Q++)e[Q]=i[Q]+V[Q];return n.markAsUpdated(),n}addToSelf(b){const n=this.Ue,i=b.m;return n[0]+=i[0],n[1]+=i[1],n[2]+=i[2],n[3]+=i[3],n[4]+=i[4],n[5]+=i[5],n[6]+=i[6],n[7]+=i[7],n[8]+=i[8],n[9]+=i[9],n[10]+=i[10],n[11]+=i[11],n[12]+=i[12],n[13]+=i[13],n[14]+=i[14],n[15]+=i[15],this.markAsUpdated(),this}addInPlace(b){const n=this.Ue,i=b.m;for(let e=0;e<16;e++)n[e]+=i[e];return this.markAsUpdated(),this}addInPlaceFromFloats(){const b=this.Ue;for(let n=0;n<16;n++)b[n]+=n<0||arguments.length<=n?void 0:arguments[n];return this.markAsUpdated(),this}un(b){const n=this.Ue,i=b.m;for(let e=0;e<16;e++)n[e]-=i[e];return this.markAsUpdated(),this}subtractToRef(b,n){const i=this.Ue,e=b.m,V=n.Ue;for(let Q=0;Q<16;Q++)V[Q]=i[Q]-e[Q];return n.markAsUpdated(),n}lm(b){const n=this.Ue,i=b.m;for(let e=0;e<16;e++)n[e]-=i[e];return this.markAsUpdated(),this}subtractFromFloats(){for(var b=arguments.length,n=new Array(b),i=0;i<b;i++)n[i]=arguments[i];return this.subtractFromFloatsToRef(...n,new u)}subtractFromFloatsToRef(){for(var b=arguments.length,n=new Array(b),i=0;i<b;i++)n[i]=arguments[i];const e=n.pop(),V=this.Ue,Q=e.Ue,U=n;for(let Y=0;Y<16;Y++)Q[Y]=V[Y]-U[Y];return e.markAsUpdated(),e}invertToRef(b){return!0===this._isIdentity?(u.IdentityToRef(b),b):(Z(this,b.ye())?b.markAsUpdated():b.L(this),b)}addAtIndex(b,n){return this.Ue[b]+=n,this.markAsUpdated(),this}multiplyAtIndex(b,n){return this.Ue[b]*=n,this.markAsUpdated(),this}setTranslationFromFloats(b,n,i){return this.Ue[12]=b,this.Ue[13]=n,this.Ue[14]=i,this.markAsUpdated(),this}addTranslationFromFloats(b,n,i){return this.Ue[12]+=b,this.Ue[13]+=n,this.Ue[14]+=i,this.markAsUpdated(),this}setTranslation(b){return this.setTranslationFromFloats(b._x,b._y,b._z)}getTranslation(){return new K(this.Ue[12],this.Ue[13],this.Ue[14])}getTranslationToRef(b){return b.x=this.Ue[12],b.y=this.Ue[13],b.z=this.Ue[14],b}removeRotationAndScaling(){const b=this.m;return u.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,b[12],b[13],b[14],b[15],this),this._updateIdentityStatus(0===b[12]&&0===b[13]&&0===b[14]&&1===b[15]),this}L(b){b.copyToArray(this.Ue);const n=b;return this.updateFlag=n.updateFlag,this._updateIdentityStatus(n._isIdentity,n._isIdentityDirty,n._isIdentity3x2,n._isIdentity3x2Dirty),this}copyToArray(b){return N(this,b,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(b){const n=new u;return this.multiplyToRef(b,n),n}multiplyInPlace(b){const n=this.Ue,i=b.m;for(let e=0;e<16;e++)n[e]*=i[e];return this.markAsUpdated(),this}multiplyByFloats(){const b=this.Ue;for(let n=0;n<16;n++)b[n]*=n<0||arguments.length<=n?void 0:arguments[n];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var b=arguments.length,n=new Array(b),i=0;i<b;i++)n[i]=arguments[i];const e=n.pop(),V=this.Ue,Q=e.Ue,U=n;for(let Y=0;Y<16;Y++)Q[Y]=V[Y]*U[Y];return e.markAsUpdated(),e}multiplyToRef(b,n){return this._isIdentity?(n.L(b),n):b._isIdentity?(n.L(this),n):(this.multiplyToArray(b,n.Ue,0),n.markAsUpdated(),n)}multiplyToArray(b,n,i){return mb(this,b,n,i),this}divide(b){return this.divideToRef(b,new u)}divideToRef(b,n){const i=this.Ue,e=b.m,V=n.Ue;for(let Q=0;Q<16;Q++)V[Q]=i[Q]/e[Q];return n.markAsUpdated(),n}divideInPlace(b){const n=this.Ue,i=b.m;for(let e=0;e<16;e++)n[e]/=i[e];return this.markAsUpdated(),this}minimizeInPlace(b){const n=this.Ue,i=b.m;for(let e=0;e<16;e++)n[e]=Math.min(n[e],i[e]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const b=this.Ue;for(let n=0;n<16;n++)b[n]=Math.min(b[n],n<0||arguments.length<=n?void 0:arguments[n]);return this.markAsUpdated(),this}maximizeInPlace(b){const n=this.Ue,i=b.m;for(let e=0;e<16;e++)n[e]=Math.min(n[e],i[e]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const b=this.Ue;for(let n=0;n<16;n++)b[n]=Math.min(b[n],n<0||arguments.length<=n?void 0:arguments[n]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new u)}negateInPlace(){const b=this.Ue;for(let n=0;n<16;n++)b[n]=-b[n];return this.markAsUpdated(),this}negateToRef(b){const n=this.Ue,i=b.Ue;for(let e=0;e<16;e++)i[e]=-n[e];return b.markAsUpdated(),b}equals(b){const n=b;if(!n)return!1;if((this._isIdentity||n._isIdentity)&&!this._isIdentityDirty&&!n._isIdentityDirty)return this._isIdentity&&n._isIdentity;const i=this.m,e=n.m;return i[0]===e[0]&&i[1]===e[1]&&i[2]===e[2]&&i[3]===e[3]&&i[4]===e[4]&&i[5]===e[5]&&i[6]===e[6]&&i[7]===e[7]&&i[8]===e[8]&&i[9]===e[9]&&i[10]===e[10]&&i[11]===e[11]&&i[12]===e[12]&&i[13]===e[13]&&i[14]===e[14]&&i[15]===e[15]}equalsWithEpsilon(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const i=this.Ue,e=b.m;for(let V=0;V<16;V++)if(!(0,L.WithinEpsilon)(i[V],e[V],n))return!1;return!0}equalsToFloats(){const b=this.Ue;for(let n=0;n<16;n++)if(b[n]!=(n<0||arguments.length<=n?void 0:arguments[n]))return!1;return!0}floor(){return this.floorToRef(new u)}floorToRef(b){const n=this.Ue,i=b.Ue;for(let e=0;e<16;e++)i[e]=Math.floor(n[e]);return b.markAsUpdated(),b}fract(){return this.fractToRef(new u)}fractToRef(b){const n=this.Ue,i=b.Ue;for(let e=0;e<16;e++)i[e]=n[e]-Math.floor(n[e]);return b.markAsUpdated(),b}clone(){const b=new u;return b.L(this),b}getClassName(){return"Matrix"}getHashCode(){let b=T(this.Ue[0]);for(let n=1;n<16;n++)b=397*b^T(this.Ue[n]);return b}decomposeToTransformNode(b){return b.rotationQuaternion=b.rotationQuaternion||new O,this.decompose(b.ge,b.rotationQuaternion,b.position)}decompose(b,n,i,e){let V=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return i&&i.Fe(0),b&&b.Fe(1),n&&n.re(0,0,0,1),!0;const Q=this.Ue;if(i&&i.re(Q[12],Q[13],Q[14]),(b=b||d.On[0]).x=Math.sqrt(Q[0]*Q[0]+Q[1]*Q[1]+Q[2]*Q[2]),b.y=Math.sqrt(Q[4]*Q[4]+Q[5]*Q[5]+Q[6]*Q[6]),b.z=Math.sqrt(Q[8]*Q[8]+Q[9]*Q[9]+Q[10]*Q[10]),e){const n=(V?e.absoluteScaling.x:e.ge.x)<0?-1:1,i=(V?e.absoluteScaling.y:e.ge.y)<0?-1:1,Q=(V?e.absoluteScaling.z:e.ge.z)<0?-1:1;b.x*=n,b.y*=i,b.z*=Q}else this.determinant()<=0&&(b.y*=-1);if(0===b._x||0===b._y||0===b._z)return n&&n.re(0,0,0,1),!1;if(n){const i=1/b._x,e=1/b._y,V=1/b._z;u.FromValuesToRef(Q[0]*i,Q[1]*i,Q[2]*i,0,Q[4]*e,Q[5]*e,Q[6]*e,0,Q[8]*V,Q[9]*V,Q[10]*V,0,0,0,0,1,d.Matrix[0]),O.FromRotationMatrixToRef(d.Matrix[0],n)}return!0}getRow(b){if(b<0||b>3)return null;const n=4*b;return new I(this.Ue[n+0],this.Ue[n+1],this.Ue[n+2],this.Ue[n+3])}getRowToRef(b,n){if(b>=0&&b<=3){const i=4*b;n.x=this.Ue[i+0],n.y=this.Ue[i+1],n.z=this.Ue[i+2],n.w=this.Ue[i+3]}return n}setRow(b,n){return this.setRowFromFloats(b,n.x,n.y,n.z,n.w)}transpose(){const b=new u;return u.TransposeToRef(this,b),b}transposeToRef(b){return u.TransposeToRef(this,b),b}setRowFromFloats(b,n,i,e,V){if(b<0||b>3)return this;const Q=4*b;return this.Ue[Q+0]=n,this.Ue[Q+1]=i,this.Ue[Q+2]=e,this.Ue[Q+3]=V,this.markAsUpdated(),this}scale(b){const n=new u;return this.scaleToRef(b,n),n}scaleToRef(b,n){for(let i=0;i<16;i++)n.Ue[i]=this.Ue[i]*b;return n.markAsUpdated(),n}scaleAndAddToRef(b,n){for(let i=0;i<16;i++)n.Ue[i]+=this.Ue[i]*b;return n.markAsUpdated(),n}scaleInPlace(b){const n=this.Ue;for(let i=0;i<16;i++)n[i]*=b;return this.markAsUpdated(),this}toNormalMatrix(b){const n=d.Matrix[0];this.invertToRef(n),n.transposeToRef(b);const i=b.Ue;return u.FromValuesToRef(i[0],i[1],i[2],0,i[4],i[5],i[6],0,i[8],i[9],i[10],0,0,0,0,1,b),b}getRotationMatrix(){const b=new u;return this.getRotationMatrixToRef(b),b}getRotationMatrixToRef(b){const n=d.On[0];if(!this.decompose(n))return u.IdentityToRef(b),b;const i=this.Ue,e=1/n._x,V=1/n._y,Q=1/n._z;return u.FromValuesToRef(i[0]*e,i[1]*e,i[2]*e,0,i[4]*V,i[5]*V,i[6]*V,0,i[8]*Q,i[9]*Q,i[10]*Q,0,0,0,0,1,b),b}toggleModelMatrixHandInPlace(){const b=this.Ue;return b[2]*=-1,b[6]*=-1,b[8]*=-1,b[9]*=-1,b[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const b=this.Ue;return b[8]*=-1,b[9]*=-1,b[10]*=-1,b[11]*=-1,this.markAsUpdated(),this}static jn(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const i=new u;return u.FromArrayToRef(b,n,i),i}static FromArrayToRef(b,n,i){for(let e=0;e<16;e++)i.Ue[e]=b[e+n];return i.markAsUpdated(),i}static FromFloat32ArrayToRefScaled(b,n,i,e){return e.Ue[0]=b[0+n]*i,e.Ue[1]=b[1+n]*i,e.Ue[2]=b[2+n]*i,e.Ue[3]=b[3+n]*i,e.Ue[4]=b[4+n]*i,e.Ue[5]=b[5+n]*i,e.Ue[6]=b[6+n]*i,e.Ue[7]=b[7+n]*i,e.Ue[8]=b[8+n]*i,e.Ue[9]=b[9+n]*i,e.Ue[10]=b[10+n]*i,e.Ue[11]=b[11+n]*i,e.Ue[12]=b[12+n]*i,e.Ue[13]=b[13+n]*i,e.Ue[14]=b[14+n]*i,e.Ue[15]=b[15+n]*i,e.markAsUpdated(),e}static get IdentityReadOnly(){return u._IdentityReadOnly}static FromValuesToRef(b,n,i,e,V,Q,U,Y,L,B,mb,N,Z,T,z,K,I){const O=I.Ue;O[0]=b,O[1]=n,O[2]=i,O[3]=e,O[4]=V,O[5]=Q,O[6]=U,O[7]=Y,O[8]=L,O[9]=B,O[10]=mb,O[11]=N,O[12]=Z,O[13]=T,O[14]=z,O[15]=K,I.markAsUpdated()}static FromValues(b,n,i,e,V,Q,U,Y,L,B,mb,N,Z,T,z,K){const I=new u,O=I.Ue;return O[0]=b,O[1]=n,O[2]=i,O[3]=e,O[4]=V,O[5]=Q,O[6]=U,O[7]=Y,O[8]=L,O[9]=B,O[10]=mb,O[11]=N,O[12]=Z,O[13]=T,O[14]=z,O[15]=K,I.markAsUpdated(),I}static Compose(b,n,i){const e=new u;return u.ComposeToRef(b,n,i,e),e}static ComposeToRef(b,n,i,e){const V=e.Ue,Q=n._x,U=n._y,Y=n._z,L=n._w,B=Q+Q,mb=U+U,N=Y+Y,Z=Q*B,T=Q*mb,z=Q*N,K=U*mb,I=U*N,O=Y*N,u=L*B,d=L*mb,G=L*N,o=b._x,M=b._y,j=b._z;return V[0]=(1-(K+O))*o,V[1]=(T+G)*o,V[2]=(z-d)*o,V[3]=0,V[4]=(T-G)*M,V[5]=(1-(Z+O))*M,V[6]=(I+u)*M,V[7]=0,V[8]=(z+d)*j,V[9]=(I-u)*j,V[10]=(1-(Z+K))*j,V[11]=0,V[12]=i._x,V[13]=i._y,V[14]=i._z,V[15]=1,e.markAsUpdated(),e}static Identity(){const b=u.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return b._updateIdentityStatus(!0),b}static IdentityToRef(b){return u.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,b),b._updateIdentityStatus(!0),b}static Zero(){const b=u.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return b._updateIdentityStatus(!1),b}static RotationX(b){const n=new u;return u.RotationXToRef(b,n),n}static Invert(b){const n=new u;return b.invertToRef(n),n}static RotationXToRef(b,n){const i=Math.sin(b),e=Math.cos(b);return u.FromValuesToRef(1,0,0,0,0,e,i,0,0,-i,e,0,0,0,0,1,n),n._updateIdentityStatus(1===e&&0===i),n}static RotationY(b){const n=new u;return u.RotationYToRef(b,n),n}static RotationYToRef(b,n){const i=Math.sin(b),e=Math.cos(b);return u.FromValuesToRef(e,0,-i,0,0,1,0,0,i,0,e,0,0,0,0,1,n),n._updateIdentityStatus(1===e&&0===i),n}static RotationZ(b){const n=new u;return u.RotationZToRef(b,n),n}static RotationZToRef(b,n){const i=Math.sin(b),e=Math.cos(b);return u.FromValuesToRef(e,i,0,0,-i,e,0,0,0,0,1,0,0,0,0,1,n),n._updateIdentityStatus(1===e&&0===i),n}static RotationAxis(b,n){const i=new u;return u.RotationAxisToRef(b,n,i),i}static RotationAxisToRef(b,n,i){const e=Math.sin(-n),V=Math.cos(-n),Q=1-V;b=b.normalizeToRef(d.On[0]);const U=i.Ue;return U[0]=b._x*b._x*Q+V,U[1]=b._x*b._y*Q-b._z*e,U[2]=b._x*b._z*Q+b._y*e,U[3]=0,U[4]=b._y*b._x*Q+b._z*e,U[5]=b._y*b._y*Q+V,U[6]=b._y*b._z*Q-b._x*e,U[7]=0,U[8]=b._z*b._x*Q-b._y*e,U[9]=b._z*b._y*Q+b._x*e,U[10]=b._z*b._z*Q+V,U[11]=0,U[12]=0,U[13]=0,U[14]=0,U[15]=1,i.markAsUpdated(),i}static RotationAlignToRef(b,n,i){let V=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const Q=K.Dot(n,b),U=i.Ue;if(Q<-1+e.c)U[0]=-1,U[1]=0,U[2]=0,U[3]=0,U[4]=0,U[5]=V?1:-1,U[6]=0,U[7]=0,U[8]=0,U[9]=0,U[10]=V?-1:1,U[11]=0;else{const i=K.Cross(n,b),e=1/(1+Q);U[0]=i._x*i._x*e+Q,U[1]=i._y*i._x*e-i._z,U[2]=i._z*i._x*e+i._y,U[3]=0,U[4]=i._x*i._y*e+i._z,U[5]=i._y*i._y*e+Q,U[6]=i._z*i._y*e-i._x,U[7]=0,U[8]=i._x*i._z*e-i._y,U[9]=i._y*i._z*e+i._x,U[10]=i._z*i._z*e+Q,U[11]=0}return U[12]=0,U[13]=0,U[14]=0,U[15]=1,i.markAsUpdated(),i}static RotationYawPitchRoll(b,n,i){const e=new u;return u.RotationYawPitchRollToRef(b,n,i,e),e}static RotationYawPitchRollToRef(b,n,i,e){return O.RotationYawPitchRollToRef(b,n,i,d.Quaternion[0]),d.Quaternion[0].toRotationMatrix(e),e}static Scaling(b,n,i){const e=new u;return u.ScalingToRef(b,n,i,e),e}static ScalingToRef(b,n,i,e){return u.FromValuesToRef(b,0,0,0,0,n,0,0,0,0,i,0,0,0,0,1,e),e._updateIdentityStatus(1===b&&1===n&&1===i),e}static Translation(b,n,i){const e=new u;return u.TranslationToRef(b,n,i,e),e}static TranslationToRef(b,n,i,e){return u.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,b,n,i,1,e),e._updateIdentityStatus(0===b&&0===n&&0===i),e}static Lerp(b,n,i){const e=new u;return u.LerpToRef(b,n,i,e),e}static LerpToRef(b,n,i,e){const V=e.Ue,Q=b.m,U=n.m;for(let Y=0;Y<16;Y++)V[Y]=Q[Y]*(1-i)+U[Y]*i;return e.markAsUpdated(),e}static DecomposeLerp(b,n,i){const e=new u;return u.DecomposeLerpToRef(b,n,i,e),e}static DecomposeLerpToRef(b,n,i,e){const V=d.On[0],Q=d.Quaternion[0],U=d.On[1];b.decompose(V,Q,U);const Y=d.On[2],L=d.Quaternion[1],B=d.On[3];n.decompose(Y,L,B);const mb=d.On[4];K.LerpToRef(V,Y,i,mb);const N=d.Quaternion[2];O.SlerpToRef(Q,L,i,N);const Z=d.On[5];return K.LerpToRef(U,B,i,Z),u.ComposeToRef(mb,N,Z,e),e}static LookAtLH(b,n,i){const e=new u;return u.LookAtLHToRef(b,n,i,e),e}static LookAtLHToRef(b,n,i,e){const V=d.On[0],Q=d.On[1],U=d.On[2];n.subtractToRef(b,U),U.normalize(),K.CrossToRef(i,U,V);const Y=V.lengthSquared();0===Y?V.x=1:V.normalizeFromLength(Math.sqrt(Y)),K.CrossToRef(U,V,Q),Q.normalize();const L=-K.Dot(V,b),B=-K.Dot(Q,b),mb=-K.Dot(U,b);return u.FromValuesToRef(V._x,Q._x,U._x,0,V._y,Q._y,U._y,0,V._z,Q._z,U._z,0,L,B,mb,1,e),e}static LookAtRH(b,n,i){const e=new u;return u.LookAtRHToRef(b,n,i,e),e}static LookAtRHToRef(b,n,i,e){const V=d.On[0],Q=d.On[1],U=d.On[2];b.subtractToRef(n,U),U.normalize(),K.CrossToRef(i,U,V);const Y=V.lengthSquared();0===Y?V.x=1:V.normalizeFromLength(Math.sqrt(Y)),K.CrossToRef(U,V,Q),Q.normalize();const L=-K.Dot(V,b),B=-K.Dot(Q,b),mb=-K.Dot(U,b);return u.FromValuesToRef(V._x,Q._x,U._x,0,V._y,Q._y,U._y,0,V._z,Q._z,U._z,0,L,B,mb,1,e),e}static LookDirectionLH(b,n){const i=new u;return u.LookDirectionLHToRef(b,n,i),i}static LookDirectionLHToRef(b,n,i){const e=d.On[0];e.L(b),e.scaleInPlace(-1);const V=d.On[1];return K.CrossToRef(n,e,V),u.FromValuesToRef(V._x,V._y,V._z,0,n._x,n._y,n._z,0,e._x,e._y,e._z,0,0,0,0,1,i),i}static LookDirectionRH(b,n){const i=new u;return u.LookDirectionRHToRef(b,n,i),i}static LookDirectionRHToRef(b,n,i){const e=d.On[2];return K.CrossToRef(n,b,e),u.FromValuesToRef(e._x,e._y,e._z,0,n._x,n._y,n._z,0,b._x,b._y,b._z,0,0,0,0,1,i),i}static OrthoLH(b,n,i,e,V){const Q=new u;return u.OrthoLHToRef(b,n,i,e,Q,V),Q}static OrthoLHToRef(b,n,i,e,V,Q){const U=2/b,Y=2/n,L=2/(e-i),B=-(e+i)/(e-i);return u.FromValuesToRef(U,0,0,0,0,Y,0,0,0,0,L,0,0,0,B,1,V),Q&&V.multiplyToRef(o,V),V._updateIdentityStatus(1===U&&1===Y&&1===L&&0===B),V}static OrthoOffCenterLH(b,n,i,e,V,Q,U){const Y=new u;return u.OrthoOffCenterLHToRef(b,n,i,e,V,Q,Y,U),Y}static OrthoOffCenterLHToRef(b,n,i,e,V,Q,U,Y){const L=2/(n-b),B=2/(e-i),mb=2/(Q-V),N=-(Q+V)/(Q-V),Z=(b+n)/(b-n),T=(e+i)/(i-e);return u.FromValuesToRef(L,0,0,0,0,B,0,0,0,0,mb,0,Z,T,N,1,U),Y&&U.multiplyToRef(o,U),U.markAsUpdated(),U}static ObliqueOffCenterLHToRef(b,n,i,e,V,Q,U,Y,L,B,mb){const N=-U*Math.cos(Y),Z=-U*Math.sin(Y);return u.TranslationToRef(0,0,-L,d.Matrix[1]),u.FromValuesToRef(1,0,0,0,0,1,0,0,N,Z,1,0,0,0,0,1,d.Matrix[0]),d.Matrix[1].multiplyToRef(d.Matrix[0],d.Matrix[0]),u.TranslationToRef(0,0,L,d.Matrix[1]),d.Matrix[0].multiplyToRef(d.Matrix[1],d.Matrix[0]),u.OrthoOffCenterLHToRef(b,n,i,e,V,Q,B,mb),d.Matrix[0].multiplyToRef(B,B),B}static OrthoOffCenterRH(b,n,i,e,V,Q,U){const Y=new u;return u.OrthoOffCenterRHToRef(b,n,i,e,V,Q,Y,U),Y}static OrthoOffCenterRHToRef(b,n,i,e,V,Q,U,Y){return u.OrthoOffCenterLHToRef(b,n,i,e,V,Q,U,Y),U.Ue[10]*=-1,U}static ObliqueOffCenterRHToRef(b,n,i,e,V,Q,U,Y,L,B,mb){const N=U*Math.cos(Y),Z=U*Math.sin(Y);return u.TranslationToRef(0,0,L,d.Matrix[1]),u.FromValuesToRef(1,0,0,0,0,1,0,0,N,Z,1,0,0,0,0,1,d.Matrix[0]),d.Matrix[1].multiplyToRef(d.Matrix[0],d.Matrix[0]),u.TranslationToRef(0,0,-L,d.Matrix[1]),d.Matrix[0].multiplyToRef(d.Matrix[1],d.Matrix[0]),u.OrthoOffCenterRHToRef(b,n,i,e,V,Q,B,mb),d.Matrix[0].multiplyToRef(B,B),B}static PerspectiveLH(b,n,i,e,V){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const U=new u,Y=2*i/b,L=2*i/n,B=(e+i)/(e-i),mb=-2*e*i/(e-i),N=Math.tan(Q);return u.FromValuesToRef(Y,0,0,0,0,L,0,N,0,0,B,1,0,0,mb,0,U),V&&U.multiplyToRef(o,U),U._updateIdentityStatus(!1),U}static PerspectiveFovLH(b,n,i,e,V){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const Y=new u;return u.PerspectiveFovLHToRef(b,n,i,e,Y,!0,V,Q,U),Y}static PerspectiveFovLHToRef(b,n,i,e,V){let Q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,L=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const B=i,mb=e,N=1/Math.tan(.5*b),Z=Q?N/n:N,T=Q?N:N*n,z=L&&0===B?-1:0!==mb?(mb+B)/(mb-B):1,K=L&&0===B?2*mb:0!==mb?-2*mb*B/(mb-B):-2*B,I=Math.tan(Y);return u.FromValuesToRef(Z,0,0,0,0,T,0,I,0,0,z,1,0,0,K,0,V),U&&V.multiplyToRef(o,V),V._updateIdentityStatus(!1),V}static PerspectiveFovReverseLHToRef(b,n,i,e,V){let Q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const L=1/Math.tan(.5*b),B=Q?L/n:L,mb=Q?L:L*n,N=Math.tan(Y);return u.FromValuesToRef(B,0,0,0,0,mb,0,N,0,0,-i,1,0,0,1,0,V),U&&V.multiplyToRef(o,V),V._updateIdentityStatus(!1),V}static PerspectiveFovRH(b,n,i,e,V){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const Y=new u;return u.PerspectiveFovRHToRef(b,n,i,e,Y,!0,V,Q,U),Y}static PerspectiveFovRHToRef(b,n,i,e,V){let Q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,L=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const B=i,mb=e,N=1/Math.tan(.5*b),Z=Q?N/n:N,T=Q?N:N*n,z=L&&0===B?1:0!==mb?-(mb+B)/(mb-B):-1,K=L&&0===B?2*mb:0!==mb?-2*mb*B/(mb-B):-2*B,I=Math.tan(Y);return u.FromValuesToRef(Z,0,0,0,0,T,0,I,0,0,z,-1,0,0,K,0,V),U&&V.multiplyToRef(o,V),V._updateIdentityStatus(!1),V}static PerspectiveFovReverseRHToRef(b,n,i,e,V){let Q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],U=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const L=1/Math.tan(.5*b),B=Q?L/n:L,mb=Q?L:L*n,N=Math.tan(Y);return u.FromValuesToRef(B,0,0,0,0,mb,0,N,0,0,-i,-1,0,0,-1,0,V),U&&V.multiplyToRef(o,V),V._updateIdentityStatus(!1),V}static GetFinalMatrix(b,n,i,e,V,Q){const U=b.width,Y=b.height,L=b.x,B=b.y,mb=u.FromValues(U/2,0,0,0,0,-Y/2,0,0,0,0,Q-V,0,L+U/2,Y/2+B,V,1),N=new u;return n.multiplyToRef(i,N),N.multiplyToRef(e,N),N.multiplyToRef(mb,N)}static GetAsMatrix2x2(b){const n=b.m,i=[n[0],n[1],n[4],n[5]];return U.b.MatrixUse64Bits?i:new Float32Array(i)}static GetAsMatrix3x3(b){const n=b.m,i=[n[0],n[1],n[2],n[4],n[5],n[6],n[8],n[9],n[10]];return U.b.MatrixUse64Bits?i:new Float32Array(i)}static Transpose(b){const n=new u;return u.TransposeToRef(b,n),n}static TransposeToRef(b,n){const i=b.m,e=i[0],V=i[4],Q=i[8],U=i[12],Y=i[1],L=i[5],B=i[9],mb=i[13],N=i[2],Z=i[6],T=i[10],z=i[14],K=i[3],I=i[7],O=i[11],u=i[15],d=n.Ue;return d[0]=e,d[1]=V,d[2]=Q,d[3]=U,d[4]=Y,d[5]=L,d[6]=B,d[7]=mb,d[8]=N,d[9]=Z,d[10]=T,d[11]=z,d[12]=K,d[13]=I,d[14]=O,d[15]=u,n.markAsUpdated(),n._updateIdentityStatus(b._isIdentity,b._isIdentityDirty),n}static Reflection(b){const n=new u;return u.ReflectionToRef(b,n),n}static ReflectionToRef(b,n){b.normalize();const i=b.normal.x,e=b.normal.y,V=b.normal.z,Q=-2*i,U=-2*e,Y=-2*V;return u.FromValuesToRef(Q*i+1,U*i,Y*i,0,Q*e,U*e+1,Y*e,0,Q*V,U*V,Y*V+1,0,Q*b.d,U*b.d,Y*b.d,1,n),n}static FromXYZAxesToRef(b,n,i,e){return u.FromValuesToRef(b._x,b._y,b._z,0,n._x,n._y,n._z,0,i._x,i._y,i._z,0,0,0,0,1,e),e}static FromQuaternionToRef(b,n){const i=b._x*b._x,e=b._y*b._y,V=b._z*b._z,Q=b._x*b._y,U=b._z*b._w,Y=b._z*b._x,L=b._y*b._w,B=b._y*b._z,mb=b._x*b._w;return n.Ue[0]=1-2*(e+V),n.Ue[1]=2*(Q+U),n.Ue[2]=2*(Y-L),n.Ue[3]=0,n.Ue[4]=2*(Q-U),n.Ue[5]=1-2*(V+i),n.Ue[6]=2*(B+mb),n.Ue[7]=0,n.Ue[8]=2*(Y+L),n.Ue[9]=2*(B-mb),n.Ue[10]=1-2*(e+i),n.Ue[11]=0,n.Ue[12]=0,n.Ue[13]=0,n.Ue[14]=0,n.Ue[15]=1,n.markAsUpdated(),n}}u._IdentityReadOnly=u.Identity(),Object.defineProperties(u.prototype,{dimension:{value:[4,4]},rank:{value:2}});class d{}d.On=(0,V.g)(11,K.Zero),d.Matrix=(0,V.g)(2,u.Identity),d.Quaternion=(0,V.g)(3,O.Zero);class G{}G.Vector2=(0,V.g)(3,z.Zero),G.On=(0,V.g)(13,K.Zero),G.Vector4=(0,V.g)(3,I.Zero),G.Quaternion=(0,V.g)(3,O.Zero),G.Matrix=(0,V.g)(8,u.Identity),(0,Q.i)("BABYLON.Vector2",z),(0,Q.i)("BABYLON.Vector3",K),(0,Q.i)("BABYLON.Vector4",I),(0,Q.i)("BABYLON.Matrix",u);const o=u.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11788:(b,n,i)=>{function e(b,n){const i=[];for(let e=0;e<b;++e)i.push(n());return i}function V(b,n){return e(b,n)}i.d(n,{d:()=>e,g:()=>V,k:()=>U});const Q=["push","splice","pop","shift","unshift"];function U(b,n){const i=Q.map((i=>function(b,n,i){const e=b[n];if("function"!==typeof e)return null;const V=function(){const e=b.length,Q=V.previous.apply(b,arguments);return i(n,e),Q};return e.next=V,V.previous=e,b[n]=V,()=>{const i=V.previous;if(!i)return;const e=V.next;e?(i.next=e,e.previous=i):(i.next=void 0,b[n]=i),V.next=void 0,V.previous=void 0}}(b,i,n)));return()=>{for(const b of i)null===b||void 0===b||b()}}}}]);