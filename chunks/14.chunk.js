"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[14],{11318:(F,b,Q)=>{Q.d(b,{c:()=>g,e:()=>t,f:()=>C,j:()=>z});const C=1/2.2,z=2.2,t=(1+Math.sqrt(5))/2,g=.001},11329:(F,b,Q)=>{function C(F){return parseInt(F.toString().replace(/\W/g,""))}function z(F,b){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(F-b)<=Q}function t(F,b,Q){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return F<b-C||F>Q+C}function g(F,b){return F===b?F:Math.random()*(b-F)+F}function W(F,b,Q){return F+(b-F)*Q}function Z(F,b,Q){let C=c(b-F,360);return C>180&&(C-=360),F+C*e(Q)}function q(F,b,Q){let C=0;return C=F!=b?e((Q-F)/(b-F)):0,C}function G(F,b,Q,C,z){const t=z*z,g=z*t;return F*(2*g-3*t+1)+Q*(-2*g+3*t)+b*(g-2*t+z)+C*(g-t)}function K(F,b,Q,C,z){const t=z*z;return 6*(t-z)*F+(3*t-4*z+1)*b+6*(-t+z)*Q+(3*t-2*z)*C}function e(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(Q,Math.max(b,F))}function N(F){return F-=2*Math.PI*Math.floor((F+Math.PI)/(2*Math.PI))}function y(F){const b=F.toString(16);return F<=15?("0"+b).toUpperCase():b.toUpperCase()}function E(F){if(Math.log2)return Math.floor(Math.log2(F));if(F<0)return NaN;if(0===F)return-1/0;let b=0;if(F<1){for(;F<1;)b++,F*=2;b=-b}else if(F>1)for(;F>1;)b++,F=Math.floor(F/2);return b}function c(F,b){return F-Math.floor(F/b)*b}function X(F,b,Q){return(F-b)/(Q-b)}function L(F,b,Q){return F*(Q-b)+b}function i(F,b){let Q=c(b-F,360);return Q>180&&(Q-=360),Q}function f(F,b){const Q=c(F,2*b);return b-Math.abs(Q-b)}function k(F,b,Q){let C=e(Q);return C=-2*C*C*C+3*C*C,b*C+F*(1-C)}function m(F,b,Q){let C=0;return C=Math.abs(b-F)<=Q?b:F+Math.sign(b-F)*Q,C}function R(F,b,Q){const C=i(F,b);let z=0;return z=-Q<C&&C<Q?b:m(F,b=F+C,Q),z}function p(F,b,Q){return(F-b)/(Q-b)}function D(F,b,Q){return(Q-b)*F+b}function P(F,b){const Q=F%b;return 0===Q?b:P(b,Q)}Q.r(b),Q.d(b,{Clamp:()=>e,DeltaAngle:()=>i,Denormalize:()=>L,ExtractAsInt:()=>C,Hermite:()=>G,Hermite1stDerivative:()=>K,HighestCommonFactor:()=>P,ILog2:()=>E,InverseLerp:()=>q,Lerp:()=>W,LerpAngle:()=>Z,MoveTowards:()=>m,MoveTowardsAngle:()=>R,Normalize:()=>X,NormalizeRadians:()=>N,OutsideRange:()=>t,PercentToRange:()=>D,PingPong:()=>f,RandomRange:()=>g,RangeToPercent:()=>p,Repeat:()=>c,SmoothStep:()=>k,ToHex:()=>y,WithinEpsilon:()=>z})},11309:(F,b,Q)=>{Q.r(b),Q.d(b,{Matrix:()=>L,Quaternion:()=>X,TmpVectors:()=>f,Vector2:()=>y,gQ:()=>E,Vector4:()=>c});var C=Q(11318),z=Q(11320),t=Q(11265),g=Q(11236),W=Q(11161),Z=Q(11329);class q{}function G(F,b,Q){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const z=F.Lb(),t=b.Lb(),g=z[0],W=z[1],Z=z[2],q=z[3],G=z[4],K=z[5],e=z[6],N=z[7],y=z[8],E=z[9],c=z[10],X=z[11],L=z[12],i=z[13],f=z[14],k=z[15],m=t[0],R=t[1],p=t[2],D=t[3],P=t[4],n=t[5],j=t[6],w=t[7],Y=t[8],s=t[9],V=t[10],h=t[11],l=t[12],T=t[13],o=t[14],S=t[15];Q[C]=g*m+W*P+Z*Y+q*l,Q[C+1]=g*R+W*n+Z*s+q*T,Q[C+2]=g*p+W*j+Z*V+q*o,Q[C+3]=g*D+W*w+Z*h+q*S,Q[C+4]=G*m+K*P+e*Y+N*l,Q[C+5]=G*R+K*n+e*s+N*T,Q[C+6]=G*p+K*j+e*V+N*o,Q[C+7]=G*D+K*w+e*h+N*S,Q[C+8]=y*m+E*P+c*Y+X*l,Q[C+9]=y*R+E*n+c*s+X*T,Q[C+10]=y*p+E*j+c*V+X*o,Q[C+11]=y*D+E*w+c*h+X*S,Q[C+12]=L*m+i*P+f*Y+k*l,Q[C+13]=L*R+i*n+f*s+k*T,Q[C+14]=L*p+i*j+f*V+k*o,Q[C+15]=L*D+i*w+f*h+k*S}function K(F,b){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const C=F.Lb();b[Q]=C[0],b[Q+1]=C[1],b[Q+2]=C[2],b[Q+3]=C[3],b[Q+4]=C[4],b[Q+5]=C[5],b[Q+6]=C[6],b[Q+7]=C[7],b[Q+8]=C[8],b[Q+9]=C[9],b[Q+10]=C[10],b[Q+11]=C[11],b[Q+12]=C[12],b[Q+13]=C[13],b[Q+14]=C[14],b[Q+15]=C[15]}function e(F,b){const Q=F.Lb(),C=Q[0],z=Q[1],t=Q[2],g=Q[3],W=Q[4],Z=Q[5],q=Q[6],G=Q[7],K=Q[8],e=Q[9],N=Q[10],y=Q[11],E=Q[12],c=Q[13],X=Q[14],L=Q[15],i=N*L-X*y,f=e*L-c*y,k=e*X-c*N,m=K*L-E*y,R=K*X-N*E,p=K*c-E*e,D=+(Z*i-q*f+G*k),P=-(W*i-q*m+G*R),n=+(W*f-Z*m+G*p),j=-(W*k-Z*R+q*p),w=C*D+z*P+t*n+g*j;if(0===w)return!1;const Y=1/w,s=q*L-X*G,V=Z*L-c*G,h=Z*X-c*q,l=W*L-E*G,T=W*X-E*q,o=W*c-E*Z,S=q*y-N*G,O=Z*y-e*G,x=Z*N-e*q,a=W*y-K*G,A=W*N-K*q,U=W*e-K*Z,u=-(z*i-t*f+g*k),v=+(C*i-t*m+g*R),J=-(C*f-z*m+g*p),I=+(C*k-z*R+t*p),M=+(z*s-t*V+g*h),r=-(C*s-t*l+g*T),H=+(C*V-z*l+g*o),B=-(C*h-z*T+t*o),d=-(z*S-t*O+g*x),FF=+(C*S-t*a+g*A),bF=-(C*O-z*a+g*U),QF=+(C*x-z*A+t*U);return b[0]=D*Y,b[1]=u*Y,b[2]=M*Y,b[3]=d*Y,b[4]=P*Y,b[5]=v*Y,b[6]=r*Y,b[7]=FF*Y,b[8]=n*Y,b[9]=J*Y,b[10]=H*Y,b[11]=bF*Y,b[12]=j*Y,b[13]=I*Y,b[14]=B*Y,b[15]=QF*Y,!0}q._UpdateFlagSeed=0;const N=F=>parseInt(F.toString().replace(/\W/g,""));class y{constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=F,this.y=b}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let F=N(this.x);return F=397*F^N(this.y),F}toArray(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F[b]=this.x,F[b+1]=this.y,this}tC(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y.FromArrayToRef(F,b,this),this}Lb(){return[this.x,this.y]}W(F){return this.x=F.x,this.y=F.y,this}jb(F,b){return this.x=F,this.y=b,this}set(F,b){return this.jb(F,b)}Yb(F){return this.jb(F,F)}add(F){return new y(this.x+F.x,this.y+F.y)}addToRef(F,b){return b.x=this.x+F.x,b.y=this.y+F.y,b}addInPlace(F){return this.x+=F.x,this.y+=F.y,this}addInPlaceFromFloats(F,b){return this.x+=F,this.y+=b,this}addVector3(F){return new y(this.x+F.x,this.y+F.y)}WQ(F){return new y(this.x-F.x,this.y-F.y)}subtractToRef(F,b){return b.x=this.x-F.x,b.y=this.y-F.y,b}PK(F){return this.x-=F.x,this.y-=F.y,this}multiplyInPlace(F){return this.x*=F.x,this.y*=F.y,this}multiply(F){return new y(this.x*F.x,this.y*F.y)}multiplyToRef(F,b){return b.x=this.x*F.x,b.y=this.y*F.y,b}multiplyByFloats(F,b){return new y(this.x*F,this.y*b)}divide(F){return new y(this.x/F.x,this.y/F.y)}divideToRef(F,b){return b.x=this.x/F.x,b.y=this.y/F.y,b}divideInPlace(F){return this.x=this.x/F.x,this.y=this.y/F.y,this}minimizeInPlace(F){return this.minimizeInPlaceFromFloats(F.x,F.y)}maximizeInPlace(F){return this.maximizeInPlaceFromFloats(F.x,F.y)}minimizeInPlaceFromFloats(F,b){return this.x=Math.min(F,this.x),this.y=Math.min(b,this.y),this}maximizeInPlaceFromFloats(F,b){return this.x=Math.max(F,this.x),this.y=Math.max(b,this.y),this}subtractFromFloats(F,b){return new y(this.x-F,this.y-b)}subtractFromFloatsToRef(F,b,Q){return Q.x=this.x-F,Q.y=this.y-b,Q}negate(){return new y(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(F){return F.x=-this.x,F.y=-this.y,F}scaleInPlace(F){return this.x*=F,this.y*=F,this}scale(F){return new y(this.x*F,this.y*F)}scaleToRef(F,b){return b.x=this.x*F,b.y=this.y*F,b}scaleAndAddToRef(F,b){return b.x+=this.x*F,b.y+=this.y*F,b}equals(F){return F&&this.x===F.x&&this.y===F.y}equalsWithEpsilon(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.c;return F&&(0,Z.WithinEpsilon)(this.x,F.x,b)&&(0,Z.WithinEpsilon)(this.y,F.y,b)}equalsToFloats(F,b){return this.x===F&&this.y===b}floor(){return new y(Math.floor(this.x),Math.floor(this.y))}floorToRef(F){return F.x=Math.floor(this.x),F.y=Math.floor(this.y),F}fract(){return new y(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(F){return F.x=this.x-Math.floor(this.x),F.y=this.y-Math.floor(this.y),F}rotate(F){return this.rotateToRef(F,new y)}rotateToRef(F,b){const Q=Math.cos(F),C=Math.sin(F);return b.x=Q*this.x-C*this.y,b.y=C*this.x+Q*this.y,b}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(F){return 0===F||1===F?this:this.scaleInPlace(1/F)}normalizeToNew(){const F=new y;return this.normalizeToRef(F),F}normalizeToRef(F){const b=this.length();return 0===b&&(F.x=this.x,F.y=this.y),this.scaleToRef(1/b,F)}clone(){return new y(this.x,this.y)}dot(F){return this.x*F.x+this.y*F.y}static Zero(){return new y(0,0)}static One(){return new y(1,1)}static Random(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new y((0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b))}static RandomToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).jb((0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b))}static get ZeroReadOnly(){return y._ZeroReadOnly}static KQ(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new y(F[b],F[b+1])}static FromArrayToRef(F,b,Q){return Q.x=F[b],Q.y=F[b+1],Q}static FromFloatsToRef(F,b,Q){return Q.jb(F,b),Q}static CatmullRom(F,b,Q,C,z){const t=z*z,g=z*t,W=.5*(2*b.x+(-F.x+Q.x)*z+(2*F.x-5*b.x+4*Q.x-C.x)*t+(-F.x+3*b.x-3*Q.x+C.x)*g),Z=.5*(2*b.y+(-F.y+Q.y)*z+(2*F.y-5*b.y+4*Q.y-C.y)*t+(-F.y+3*b.y-3*Q.y+C.y)*g);return new y(W,Z)}static ClampToRef(F,b,Q,C){return C.x=(0,Z.Clamp)(F.x,b.x,Q.x),C.y=(0,Z.Clamp)(F.y,b.y,Q.y),C}static Clamp(F,b,Q){const C=(0,Z.Clamp)(F.x,b.x,Q.x),z=(0,Z.Clamp)(F.y,b.y,Q.y);return new y(C,z)}static Hermite(F,b,Q,C,z){const t=z*z,g=z*t,W=2*g-3*t+1,Z=-2*g+3*t,q=g-2*t+z,G=g-t,K=F.x*W+Q.x*Z+b.x*q+C.x*G,e=F.y*W+Q.y*Z+b.y*q+C.y*G;return new y(K,e)}static Hermite1stDerivative(F,b,Q,C,z){return this.Hermite1stDerivativeToRef(F,b,Q,C,z,new y)}static Hermite1stDerivativeToRef(F,b,Q,C,z,t){const g=z*z;return t.x=6*(g-z)*F.x+(3*g-4*z+1)*b.x+6*(-g+z)*Q.x+(3*g-2*z)*C.x,t.y=6*(g-z)*F.y+(3*g-4*z+1)*b.y+6*(-g+z)*Q.y+(3*g-2*z)*C.y,t}static Lerp(F,b,Q){return y.LerpToRef(F,b,Q,new y)}static LerpToRef(F,b,Q,C){return C.x=F.x+(b.x-F.x)*Q,C.y=F.y+(b.y-F.y)*Q,C}static Dot(F,b){return F.x*b.x+F.y*b.y}static Normalize(F){return y.NormalizeToRef(F,new y)}static NormalizeToRef(F,b){return F.normalizeToRef(b),b}static Minimize(F,b){const Q=F.x<b.x?F.x:b.x,C=F.y<b.y?F.y:b.y;return new y(Q,C)}static Maximize(F,b){const Q=F.x>b.x?F.x:b.x,C=F.y>b.y?F.y:b.y;return new y(Q,C)}static Transform(F,b){return y.TransformToRef(F,b,new y)}static TransformToRef(F,b,Q){const C=b.m,z=F.x*C[0]+F.y*C[4]+C[12],t=F.x*C[1]+F.y*C[5]+C[13];return Q.x=z,Q.y=t,Q}static PointInTriangle(F,b,Q,C){const z=.5*(-Q.y*C.x+b.y*(-Q.x+C.x)+b.x*(Q.y-C.y)+Q.x*C.y),t=z<0?-1:1,g=(b.y*C.x-b.x*C.y+(C.y-b.y)*F.x+(b.x-C.x)*F.y)*t,W=(b.x*Q.y-b.y*Q.x+(b.y-Q.y)*F.x+(Q.x-b.x)*F.y)*t;return g>0&&W>0&&g+W<2*z*t}static Distance(F,b){return Math.sqrt(y.DistanceSquared(F,b))}static DistanceSquared(F,b){const Q=F.x-b.x,C=F.y-b.y;return Q*Q+C*C}static Center(F,b){return y.CenterToRef(F,b,new y)}static CenterToRef(F,b,Q){return Q.jb((F.x+b.x)/2,(F.y+b.y)/2)}static DistanceOfPointFromSegment(F,b,Q){const C=y.DistanceSquared(b,Q);if(0===C)return y.Distance(F,b);const z=Q.WQ(b),t=Math.max(0,Math.min(1,y.Dot(F.WQ(b),z)/C)),g=b.add(z.multiplyByFloats(t,t));return y.Distance(F,g)}}y._V8PerformanceHack=new y(.5,.5),y._ZeroReadOnly=y.Zero(),Object.defineProperties(y.prototype,{dimension:{value:[2]},rank:{value:1}});class E{get x(){return this._x}set x(F){this._x=F,this._isDirty=!0}get y(){return this._y}set y(F){this._y=F,this._isDirty=!0}get z(){return this._z}set z(F){this._z=F,this._isDirty=!0}constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=F,this._y=b,this._z=Q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"gQ"}getHashCode(){let F=N(this._x);return F=397*F^N(this._y),F=397*F^N(this._z),F}Lb(){return[this._x,this._y,this._z]}toArray(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F[b]=this._x,F[b+1]=this._y,F[b+2]=this._z,this}tC(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(F,b,this),this}toQuaternion(){return X.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(F){return this._x+=F._x,this._y+=F._y,this._z+=F._z,this._isDirty=!0,this}addInPlaceFromFloats(F,b,Q){return this._x+=F,this._y+=b,this._z+=Q,this._isDirty=!0,this}add(F){return new E(this._x+F._x,this._y+F._y,this._z+F._z)}addToRef(F,b){return b._x=this._x+F._x,b._y=this._y+F._y,b._z=this._z+F._z,b._isDirty=!0,b}PK(F){return this._x-=F._x,this._y-=F._y,this._z-=F._z,this._isDirty=!0,this}WQ(F){return new E(this._x-F._x,this._y-F._y,this._z-F._z)}subtractToRef(F,b){return this.subtractFromFloatsToRef(F._x,F._y,F._z,b)}subtractFromFloats(F,b,Q){return new E(this._x-F,this._y-b,this._z-Q)}subtractFromFloatsToRef(F,b,Q,C){return C._x=this._x-F,C._y=this._y-b,C._z=this._z-Q,C._isDirty=!0,C}negate(){return new E(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(F){return F._x=-1*this._x,F._y=-1*this._y,F._z=-1*this._z,F._isDirty=!0,F}scaleInPlace(F){return this._x*=F,this._y*=F,this._z*=F,this._isDirty=!0,this}scale(F){return new E(this._x*F,this._y*F,this._z*F)}scaleToRef(F,b){return b._x=this._x*F,b._y=this._y*F,b._z=this._z*F,b._isDirty=!0,b}getNormalToRef(F){const b=this.length();let Q=Math.acos(this._y/b);const C=Math.atan2(this._z,this._x);Q>Math.PI/2?Q-=Math.PI/2:Q+=Math.PI/2;const z=b*Math.sin(Q)*Math.cos(C),t=b*Math.cos(Q),g=b*Math.sin(Q)*Math.sin(C);return F.set(z,t,g),F}applyRotationQuaternionToRef(F,b){const Q=this._x,C=this._y,z=this._z,t=F._x,g=F._y,W=F._z,Z=F._w,q=2*(g*z-W*C),G=2*(W*Q-t*z),K=2*(t*C-g*Q);return b._x=Q+Z*q+g*K-W*G,b._y=C+Z*G+W*q-t*K,b._z=z+Z*K+t*G-g*q,b._isDirty=!0,b}applyRotationQuaternionInPlace(F){return this.applyRotationQuaternionToRef(F,this)}applyRotationQuaternion(F){return this.applyRotationQuaternionToRef(F,new E)}scaleAndAddToRef(F,b){return b._x+=this._x*F,b._y+=this._y*F,b._z+=this._z*F,b._isDirty=!0,b}projectOnPlane(F,b){return this.projectOnPlaneToRef(F,b,new E)}projectOnPlaneToRef(F,b,Q){const C=F.normal,z=F.d,t=i.gQ[0];this.subtractToRef(b,t),t.normalize();const g=E.Dot(t,C);if(Math.abs(g)<1e-10)Q.Yb(1/0);else{const F=-(E.Dot(b,C)+z)/g,W=t.scaleInPlace(F);b.addToRef(W,Q)}return Q}equals(F){return F&&this._x===F._x&&this._y===F._y&&this._z===F._z}equalsWithEpsilon(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.c;return F&&(0,Z.WithinEpsilon)(this._x,F._x,b)&&(0,Z.WithinEpsilon)(this._y,F._y,b)&&(0,Z.WithinEpsilon)(this._z,F._z,b)}equalsToFloats(F,b,Q){return this._x===F&&this._y===b&&this._z===Q}multiplyInPlace(F){return this._x*=F._x,this._y*=F._y,this._z*=F._z,this._isDirty=!0,this}multiply(F){return this.multiplyByFloats(F._x,F._y,F._z)}multiplyToRef(F,b){return b._x=this._x*F._x,b._y=this._y*F._y,b._z=this._z*F._z,b._isDirty=!0,b}multiplyByFloats(F,b,Q){return new E(this._x*F,this._y*b,this._z*Q)}divide(F){return new E(this._x/F._x,this._y/F._y,this._z/F._z)}divideToRef(F,b){return b._x=this._x/F._x,b._y=this._y/F._y,b._z=this._z/F._z,b._isDirty=!0,b}divideInPlace(F){return this._x=this._x/F._x,this._y=this._y/F._y,this._z=this._z/F._z,this._isDirty=!0,this}minimizeInPlace(F){return this.minimizeInPlaceFromFloats(F._x,F._y,F._z)}maximizeInPlace(F){return this.maximizeInPlaceFromFloats(F._x,F._y,F._z)}minimizeInPlaceFromFloats(F,b,Q){return F<this._x&&(this.x=F),b<this._y&&(this.y=b),Q<this._z&&(this.z=Q),this}maximizeInPlaceFromFloats(F,b,Q){return F>this._x&&(this.x=F),b>this._y&&(this.y=b),Q>this._z&&(this.z=Q),this}isNonUniformWithinEpsilon(F){const b=Math.abs(this._x),Q=Math.abs(this._y);if(!(0,Z.WithinEpsilon)(b,Q,F))return!0;const C=Math.abs(this._z);return!(0,Z.WithinEpsilon)(b,C,F)||!(0,Z.WithinEpsilon)(Q,C,F)}get isNonUniform(){const F=Math.abs(this._x);if(F!==Math.abs(this._y))return!0;return F!==Math.abs(this._z)}floorToRef(F){return F._x=Math.floor(this._x),F._y=Math.floor(this._y),F._z=Math.floor(this._z),F._isDirty=!0,F}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(F){return F._x=this._x-Math.floor(this._x),F._y=this._y-Math.floor(this._y),F._z=this._z-Math.floor(this._z),F._isDirty=!0,F}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(F){if("xyz"===(F=F.toLowerCase()))return this;const b=i.gQ[0].W(this);return this.x=b[F[0]],this.y=b[F[1]],this.z=b[F[2]],this}rotateByQuaternionToRef(F,b){return F.toRotationMatrix(i.Matrix[0]),E.TransformCoordinatesToRef(this,i.Matrix[0],b),b}rotateByQuaternionAroundPointToRef(F,b,Q){return this.subtractToRef(b,i.gQ[0]),i.gQ[0].rotateByQuaternionToRef(F,i.gQ[0]),b.addToRef(i.gQ[0],Q),Q}cross(F){return E.CrossToRef(this,F,new E)}normalizeFromLength(F){return 0===F||1===F?this:this.scaleInPlace(1/F)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(F){const b=this.length();return 0===b||1===b?(F._x=this._x,F._y=this._y,F._z=this._z,F._isDirty=!0,F):this.scaleToRef(1/b,F)}clone(){return new E(this._x,this._y,this._z)}W(F){return this.jb(F._x,F._y,F._z)}jb(F,b,Q){return this._x=F,this._y=b,this._z=Q,this._isDirty=!0,this}set(F,b,Q){return this.jb(F,b,Q)}Yb(F){return this._x=this._y=this._z=F,this._isDirty=!0,this}static GetClipFactor(F,b,Q,C){const z=E.Dot(F,Q);return(z-C)/(z-E.Dot(b,Q))}static GetAngleBetweenVectors(F,b,Q){const C=F.normalizeToRef(i.gQ[1]),z=b.normalizeToRef(i.gQ[2]);let t=E.Dot(C,z);t=(0,Z.Clamp)(t,-1,1);const g=Math.acos(t),W=i.gQ[3];return E.CrossToRef(C,z,W),E.Dot(W,Q)>0?isNaN(g)?0:g:isNaN(g)?-Math.PI:-Math.acos(t)}static GetAngleBetweenVectorsOnPlane(F,b,Q){i.gQ[0].W(F);const C=i.gQ[0];i.gQ[1].W(b);const z=i.gQ[1];i.gQ[2].W(Q);const t=i.gQ[2],g=i.gQ[3],W=i.gQ[4];C.normalize(),z.normalize(),t.normalize(),E.CrossToRef(t,C,g),E.CrossToRef(g,t,W);const q=Math.atan2(E.Dot(z,g),E.Dot(z,W));return(0,Z.NormalizeRadians)(q)}static PitchYawRollToMoveBetweenPointsToRef(F,b,Q){const C=f.gQ[0];return b.subtractToRef(F,C),Q._y=Math.atan2(C.x,C.z)||0,Q._x=Math.atan2(Math.sqrt(C.x**2+C.z**2),C.y)||0,Q._z=0,Q._isDirty=!0,Q}static PitchYawRollToMoveBetweenPoints(F,b){const Q=E.Zero();return E.PitchYawRollToMoveBetweenPointsToRef(F,b,Q)}static SlerpToRef(F,b,Q,z){Q=(0,Z.Clamp)(Q,0,1);const t=i.gQ[0],g=i.gQ[1];t.W(F);const W=t.length();t.normalizeFromLength(W),g.W(b);const q=g.length();g.normalizeFromLength(q);const G=E.Dot(t,g);let K,e;if(G<1-C.c){const F=Math.acos(G),b=1/Math.sin(F);K=Math.sin((1-Q)*F)*b,e=Math.sin(Q*F)*b}else K=1-Q,e=Q;return t.scaleInPlace(K),g.scaleInPlace(e),z.W(t).addInPlace(g),z.scaleInPlace((0,Z.Lerp)(W,q,Q)),z}static SmoothToRef(F,b,Q,C,z){return E.SlerpToRef(F,b,0===C?1:Q/C,z),z}static KQ(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(F[b],F[b+1],F[b+2])}static FromFloatArray(F,b){return E.KQ(F,b)}static FromArrayToRef(F,b,Q){return Q._x=F[b],Q._y=F[b+1],Q._z=F[b+2],Q._isDirty=!0,Q}static FromFloatArrayToRef(F,b,Q){return E.FromArrayToRef(F,b,Q)}static FromFloatsToRef(F,b,Q,C){return C.jb(F,b,Q),C}static Zero(){return new E(0,0,0)}static One(){return new E(1,1,1)}static Up(){return new E(0,1,0)}static get UpReadOnly(){return E._UpReadOnly}static get DownReadOnly(){return E._DownReadOnly}static get RightReadOnly(){return E._RightReadOnly}static get LeftReadOnly(){return E._LeftReadOnly}static get LeftHandedForwardReadOnly(){return E._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return E._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return E._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return E._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return E._ZeroReadOnly}static get OneReadOnly(){return E._OneReadOnly}static Down(){return new E(0,-1,0)}static Forward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new E(1,0,0)}static Left(){return new E(-1,0,0)}static Random(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b))}static RandomToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).jb((0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b))}static TransformCoordinates(F,b){const Q=E.Zero();return E.TransformCoordinatesToRef(F,b,Q),Q}static TransformCoordinatesToRef(F,b,Q){return E.TransformCoordinatesFromFloatsToRef(F._x,F._y,F._z,b,Q),Q}static TransformCoordinatesFromFloatsToRef(F,b,Q,C,z){const t=C.m,g=F*t[0]+b*t[4]+Q*t[8]+t[12],W=F*t[1]+b*t[5]+Q*t[9]+t[13],Z=F*t[2]+b*t[6]+Q*t[10]+t[14],q=1/(F*t[3]+b*t[7]+Q*t[11]+t[15]);return z._x=g*q,z._y=W*q,z._z=Z*q,z._isDirty=!0,z}static TransformNormal(F,b){const Q=E.Zero();return E.TransformNormalToRef(F,b,Q),Q}static TransformNormalToRef(F,b,Q){return this.TransformNormalFromFloatsToRef(F._x,F._y,F._z,b,Q),Q}static TransformNormalFromFloatsToRef(F,b,Q,C,z){const t=C.m;return z._x=F*t[0]+b*t[4]+Q*t[8],z._y=F*t[1]+b*t[5]+Q*t[9],z._z=F*t[2]+b*t[6]+Q*t[10],z._isDirty=!0,z}static CatmullRom(F,b,Q,C,z){const t=z*z,g=z*t,W=.5*(2*b._x+(-F._x+Q._x)*z+(2*F._x-5*b._x+4*Q._x-C._x)*t+(-F._x+3*b._x-3*Q._x+C._x)*g),Z=.5*(2*b._y+(-F._y+Q._y)*z+(2*F._y-5*b._y+4*Q._y-C._y)*t+(-F._y+3*b._y-3*Q._y+C._y)*g),q=.5*(2*b._z+(-F._z+Q._z)*z+(2*F._z-5*b._z+4*Q._z-C._z)*t+(-F._z+3*b._z-3*Q._z+C._z)*g);return new E(W,Z,q)}static Clamp(F,b,Q){const C=new E;return E.ClampToRef(F,b,Q,C),C}static ClampToRef(F,b,Q,C){let z=F._x;z=z>Q._x?Q._x:z,z=z<b._x?b._x:z;let t=F._y;t=t>Q._y?Q._y:t,t=t<b._y?b._y:t;let g=F._z;return g=g>Q._z?Q._z:g,g=g<b._z?b._z:g,C.jb(z,t,g),C}static CheckExtends(F,b,Q){b.minimizeInPlace(F),Q.maximizeInPlace(F)}static Hermite(F,b,Q,C,z){const t=z*z,g=z*t,W=2*g-3*t+1,Z=-2*g+3*t,q=g-2*t+z,G=g-t,K=F._x*W+Q._x*Z+b._x*q+C._x*G,e=F._y*W+Q._y*Z+b._y*q+C._y*G,N=F._z*W+Q._z*Z+b._z*q+C._z*G;return new E(K,e,N)}static Hermite1stDerivative(F,b,Q,C,z){const t=new E;return this.Hermite1stDerivativeToRef(F,b,Q,C,z,t),t}static Hermite1stDerivativeToRef(F,b,Q,C,z,t){const g=z*z;return t._x=6*(g-z)*F._x+(3*g-4*z+1)*b._x+6*(-g+z)*Q._x+(3*g-2*z)*C._x,t._y=6*(g-z)*F._y+(3*g-4*z+1)*b._y+6*(-g+z)*Q._y+(3*g-2*z)*C._y,t._z=6*(g-z)*F._z+(3*g-4*z+1)*b._z+6*(-g+z)*Q._z+(3*g-2*z)*C._z,t._isDirty=!0,t}static Lerp(F,b,Q){const C=new E(0,0,0);return E.LerpToRef(F,b,Q,C),C}static LerpToRef(F,b,Q,C){return C._x=F._x+(b._x-F._x)*Q,C._y=F._y+(b._y-F._y)*Q,C._z=F._z+(b._z-F._z)*Q,C._isDirty=!0,C}static Dot(F,b){return F._x*b._x+F._y*b._y+F._z*b._z}dot(F){return this._x*F._x+this._y*F._y+this._z*F._z}static Cross(F,b){const Q=new E;return E.CrossToRef(F,b,Q),Q}static CrossToRef(F,b,Q){const C=F._y*b._z-F._z*b._y,z=F._z*b._x-F._x*b._z,t=F._x*b._y-F._y*b._x;return Q.jb(C,z,t),Q}static Normalize(F){const b=E.Zero();return E.NormalizeToRef(F,b),b}static NormalizeToRef(F,b){return F.normalizeToRef(b),b}static Project(F,b,Q,C){const z=new E;return E.ProjectToRef(F,b,Q,C,z),z}static ProjectToRef(F,b,Q,C,z){var t;const g=C.width,Z=C.height,q=C.x,G=C.y,K=i.Matrix[1],e=null===(t=W.d.LastCreatedEngine)||void 0===t?void 0:t.isNDCHalfZRange,N=e?1:.5,y=e?0:.5;L.FromValuesToRef(g/2,0,0,0,0,-Z/2,0,0,0,0,N,0,q+g/2,Z/2+G,y,1,K);const c=i.Matrix[0];return b.multiplyToRef(Q,c),c.multiplyToRef(K,c),E.TransformCoordinatesToRef(F,c,z),z}static Reflect(F,b){return this.ReflectToRef(F,b,new E)}static ReflectToRef(F,b,Q){const C=f.gQ[0];return C.W(b).scaleInPlace(2*E.Dot(F,b)),Q.W(F).PK(C)}static _UnprojectFromInvertedMatrixToRef(F,b,Q){E.TransformCoordinatesToRef(F,b,Q);const C=b.m,z=F._x*C[3]+F._y*C[7]+F._z*C[11]+C[15];return(0,Z.WithinEpsilon)(z,1)&&Q.scaleInPlace(1/z),Q}static UnprojectFromTransform(F,b,Q,C,z){return this.Unproject(F,b,Q,C,z,L.IdentityReadOnly)}static Unproject(F,b,Q,C,z,t){const g=new E;return E.UnprojectToRef(F,b,Q,C,z,t,g),g}static UnprojectToRef(F,b,Q,C,z,t,g){return E.UnprojectFloatsToRef(F._x,F._y,F._z,b,Q,C,z,t,g),g}static UnprojectFloatsToRef(F,b,Q,C,z,t,g,Z,q){var G;const K=i.Matrix[0];t.multiplyToRef(g,K),K.multiplyToRef(Z,K),K.invert();const e=i.gQ[0];return e.x=F/C*2-1,e.y=-(b/z*2-1),null!==(G=W.d.LastCreatedEngine)&&void 0!==G&&G.isNDCHalfZRange?e.z=Q:e.z=2*Q-1,E._UnprojectFromInvertedMatrixToRef(e,K,q),q}static Minimize(F,b){const Q=new E;return Q.W(F),Q.minimizeInPlace(b),Q}static Maximize(F,b){const Q=new E;return Q.W(F),Q.maximizeInPlace(b),Q}static Distance(F,b){return Math.sqrt(E.DistanceSquared(F,b))}static DistanceSquared(F,b){const Q=F._x-b._x,C=F._y-b._y,z=F._z-b._z;return Q*Q+C*C+z*z}static ProjectOnTriangleToRef(F,b,Q,z,t){const g=i.gQ[0],W=i.gQ[1],q=i.gQ[2],G=i.gQ[3],K=i.gQ[4];Q.subtractToRef(b,g),z.subtractToRef(b,W),z.subtractToRef(Q,q);const e=g.length(),N=W.length(),y=q.length();if(e<C.c||N<C.c||y<C.c)return t.W(b),E.Distance(F,b);F.subtractToRef(b,K),E.CrossToRef(g,W,G);const c=G.length();if(c<C.c)return t.W(b),E.Distance(F,b);G.normalizeFromLength(c);let X=K.length();if(X<C.c)return t.W(b),0;K.normalizeFromLength(X);const L=E.Dot(G,K),f=i.gQ[5],k=i.gQ[6];f.W(G).scaleInPlace(-X*L),k.W(F).addInPlace(f);const m=i.gQ[4],R=i.gQ[5],p=i.gQ[7],D=i.gQ[8];m.W(g).scaleInPlace(1/e),D.W(W).scaleInPlace(1/N),m.addInPlace(D).scaleInPlace(-1),R.W(g).scaleInPlace(-1/e),D.W(q).scaleInPlace(1/y),R.addInPlace(D).scaleInPlace(-1),p.W(q).scaleInPlace(-1/y),D.W(W).scaleInPlace(-1/N),p.addInPlace(D).scaleInPlace(-1);const P=i.gQ[9];let n;P.W(k).PK(b),E.CrossToRef(m,P,D),n=E.Dot(D,G);const j=n;P.W(k).PK(Q),E.CrossToRef(R,P,D),n=E.Dot(D,G);const w=n;P.W(k).PK(z),E.CrossToRef(p,P,D),n=E.Dot(D,G);const Y=n,s=i.gQ[10];let V,h;j>0&&w<0?(s.W(g),V=b,h=Q):w>0&&Y<0?(s.W(q),V=Q,h=z):(s.W(W).scaleInPlace(-1),V=z,h=b);const l=i.gQ[9],T=i.gQ[4];V.subtractToRef(k,D),h.subtractToRef(k,l),E.CrossToRef(D,l,T);if(!(E.Dot(T,G)<0))return t.W(k),Math.abs(X*L);const o=i.gQ[5];E.CrossToRef(s,T,o),o.normalize();const S=i.gQ[9];S.W(V).PK(k);const O=S.length();if(O<C.c)return t.W(V),E.Distance(F,V);S.normalizeFromLength(O);const x=E.Dot(o,S),a=i.gQ[7];a.W(k).addInPlace(o.scaleInPlace(O*x)),D.W(a).PK(V),X=s.length(),s.normalizeFromLength(X);let A=E.Dot(D,s)/Math.max(X,C.c);return A=(0,Z.Clamp)(A,0,1),a.W(V).addInPlace(s.scaleInPlace(A*X)),t.W(a),E.Distance(F,a)}static Center(F,b){return E.CenterToRef(F,b,E.Zero())}static CenterToRef(F,b,Q){return Q.jb((F._x+b._x)/2,(F._y+b._y)/2,(F._z+b._z)/2)}static RotationFromAxis(F,b,Q){const C=new E;return E.RotationFromAxisToRef(F,b,Q,C),C}static RotationFromAxisToRef(F,b,Q,C){const z=i.Quaternion[0];return X.RotationQuaternionFromAxisToRef(F,b,Q,z),z.toEulerAnglesToRef(C),C}}E._V8PerformanceHack=new E(.5,.5,.5),E._UpReadOnly=E.Up(),E._DownReadOnly=E.Down(),E._LeftHandedForwardReadOnly=E.Forward(!1),E._RightHandedForwardReadOnly=E.Forward(!0),E._LeftHandedBackwardReadOnly=E.Backward(!1),E._RightHandedBackwardReadOnly=E.Backward(!0),E._RightReadOnly=E.Right(),E._LeftReadOnly=E.Left(),E._ZeroReadOnly=E.Zero(),E._OneReadOnly=E.One(),Object.defineProperties(E.prototype,{dimension:{value:[3]},rank:{value:1}});class c{get x(){return this._x}set x(F){this._x=F,this._isDirty=!0}get y(){return this._y}set y(F){this._y=F,this._isDirty=!0}get z(){return this._z}set z(F){this._z=F,this._isDirty=!0}get w(){return this._w}set w(F){this._w=F,this._isDirty=!0}constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=F,this._y=b,this._z=Q,this._w=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let F=N(this._x);return F=397*F^N(this._y),F=397*F^N(this._z),F=397*F^N(this._w),F}Lb(){return[this._x,this._y,this._z,this._w]}toArray(F,b){return void 0===b&&(b=0),F[b]=this._x,F[b+1]=this._y,F[b+2]=this._z,F[b+3]=this._w,this}tC(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c.FromArrayToRef(F,b,this),this}addInPlace(F){return this.x+=F._x,this.y+=F._y,this.z+=F._z,this.w+=F._w,this}addInPlaceFromFloats(F,b,Q,C){return this.x+=F,this.y+=b,this.z+=Q,this.w+=C,this}add(F){return new c(this._x+F.x,this._y+F.y,this._z+F.z,this._w+F.w)}addToRef(F,b){return b.x=this._x+F.x,b.y=this._y+F.y,b.z=this._z+F.z,b.w=this._w+F.w,b}PK(F){return this.x-=F.x,this.y-=F.y,this.z-=F.z,this.w-=F.w,this}WQ(F){return new c(this._x-F.x,this._y-F.y,this._z-F.z,this._w-F.w)}subtractToRef(F,b){return b.x=this._x-F.x,b.y=this._y-F.y,b.z=this._z-F.z,b.w=this._w-F.w,b}subtractFromFloats(F,b,Q,C){return new c(this._x-F,this._y-b,this._z-Q,this._w-C)}subtractFromFloatsToRef(F,b,Q,C,z){return z.x=this._x-F,z.y=this._y-b,z.z=this._z-Q,z.w=this._w-C,z}negate(){return new c(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(F){return F.x=-this._x,F.y=-this._y,F.z=-this._z,F.w=-this._w,F}scaleInPlace(F){return this.x*=F,this.y*=F,this.z*=F,this.w*=F,this}scale(F){return new c(this._x*F,this._y*F,this._z*F,this._w*F)}scaleToRef(F,b){return b.x=this._x*F,b.y=this._y*F,b.z=this._z*F,b.w=this._w*F,b}scaleAndAddToRef(F,b){return b.x+=this._x*F,b.y+=this._y*F,b.z+=this._z*F,b.w+=this._w*F,b}equals(F){return F&&this._x===F.x&&this._y===F.y&&this._z===F.z&&this._w===F.w}equalsWithEpsilon(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.c;return F&&(0,Z.WithinEpsilon)(this._x,F.x,b)&&(0,Z.WithinEpsilon)(this._y,F.y,b)&&(0,Z.WithinEpsilon)(this._z,F.z,b)&&(0,Z.WithinEpsilon)(this._w,F.w,b)}equalsToFloats(F,b,Q,C){return this._x===F&&this._y===b&&this._z===Q&&this._w===C}multiplyInPlace(F){return this.x*=F.x,this.y*=F.y,this.z*=F.z,this.w*=F.w,this}multiply(F){return new c(this._x*F.x,this._y*F.y,this._z*F.z,this._w*F.w)}multiplyToRef(F,b){return b.x=this._x*F.x,b.y=this._y*F.y,b.z=this._z*F.z,b.w=this._w*F.w,b}multiplyByFloats(F,b,Q,C){return new c(this._x*F,this._y*b,this._z*Q,this._w*C)}divide(F){return new c(this._x/F.x,this._y/F.y,this._z/F.z,this._w/F.w)}divideToRef(F,b){return b.x=this._x/F.x,b.y=this._y/F.y,b.z=this._z/F.z,b.w=this._w/F.w,b}divideInPlace(F){return this.divideToRef(F,this)}minimizeInPlace(F){return F.x<this._x&&(this.x=F.x),F.y<this._y&&(this.y=F.y),F.z<this._z&&(this.z=F.z),F.w<this._w&&(this.w=F.w),this}maximizeInPlace(F){return F.x>this._x&&(this.x=F.x),F.y>this._y&&(this.y=F.y),F.z>this._z&&(this.z=F.z),F.w>this._w&&(this.w=F.w),this}minimizeInPlaceFromFloats(F,b,Q,C){return this.x=Math.min(F,this._x),this.y=Math.min(b,this._y),this.z=Math.min(Q,this._z),this.w=Math.min(C,this._w),this}maximizeInPlaceFromFloats(F,b,Q,C){return this.x=Math.max(F,this._x),this.y=Math.max(b,this._y),this.z=Math.max(Q,this._z),this.w=Math.max(C,this._w),this}floorToRef(F){return F.x=Math.floor(this._x),F.y=Math.floor(this._y),F.z=Math.floor(this._z),F.w=Math.floor(this._w),F}floor(){return new c(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(F){return F.x=this._x-Math.floor(this._x),F.y=this._y-Math.floor(this._y),F.z=this._z-Math.floor(this._z),F.w=this._w-Math.floor(this._w),F}fract(){return new c(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(F){return 0===F||1===F?this:this.scaleInPlace(1/F)}normalizeToNew(){return this.normalizeToRef(new c)}normalizeToRef(F){const b=this.length();return 0===b||1===b?(F.x=this._x,F.y=this._y,F.z=this._z,F.w=this._w,F):this.scaleToRef(1/b,F)}toVector3(){return new E(this._x,this._y,this._z)}clone(){return new c(this._x,this._y,this._z,this._w)}W(F){return this.x=F.x,this.y=F.y,this.z=F.z,this.w=F.w,this}jb(F,b,Q,C){return this.x=F,this.y=b,this.z=Q,this.w=C,this}set(F,b,Q,C){return this.jb(F,b,Q,C)}Yb(F){return this.x=this.y=this.z=this.w=F,this}dot(F){return this._x*F.x+this._y*F.y+this._z*F.z+this._w*F.w}static KQ(F,b){return b||(b=0),new c(F[b],F[b+1],F[b+2],F[b+3])}static FromArrayToRef(F,b,Q){return Q.x=F[b],Q.y=F[b+1],Q.z=F[b+2],Q.w=F[b+3],Q}static FromFloatArrayToRef(F,b,Q){return c.FromArrayToRef(F,b,Q),Q}static FromFloatsToRef(F,b,Q,C,z){return z.x=F,z.y=b,z.z=Q,z.w=C,z}static Zero(){return new c(0,0,0,0)}static One(){return new c(1,1,1,1)}static Random(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new c((0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b))}static RandomToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Q=arguments.length>2?arguments[2]:void 0;return Q.x=(0,Z.RandomRange)(F,b),Q.y=(0,Z.RandomRange)(F,b),Q.z=(0,Z.RandomRange)(F,b),Q.w=(0,Z.RandomRange)(F,b),Q}static Clamp(F,b,Q){return c.ClampToRef(F,b,Q,new c)}static ClampToRef(F,b,Q,C){return C.x=(0,Z.Clamp)(F.x,b.x,Q.x),C.y=(0,Z.Clamp)(F.y,b.y,Q.y),C.z=(0,Z.Clamp)(F.z,b.z,Q.z),C.w=(0,Z.Clamp)(F.w,b.w,Q.w),C}static CheckExtends(F,b,Q){b.minimizeInPlace(F),Q.maximizeInPlace(F)}static get ZeroReadOnly(){return c._ZeroReadOnly}static Normalize(F){return c.NormalizeToRef(F,new c)}static NormalizeToRef(F,b){return F.normalizeToRef(b),b}static Minimize(F,b){const Q=new c;return Q.W(F),Q.minimizeInPlace(b),Q}static Maximize(F,b){const Q=new c;return Q.W(F),Q.maximizeInPlace(b),Q}static Distance(F,b){return Math.sqrt(c.DistanceSquared(F,b))}static DistanceSquared(F,b){const Q=F.x-b.x,C=F.y-b.y,z=F.z-b.z,t=F.w-b.w;return Q*Q+C*C+z*z+t*t}static Center(F,b){return c.CenterToRef(F,b,new c)}static CenterToRef(F,b,Q){return Q.x=(F.x+b.x)/2,Q.y=(F.y+b.y)/2,Q.z=(F.z+b.z)/2,Q.w=(F.w+b.w)/2,Q}static TransformCoordinates(F,b){return c.TransformCoordinatesToRef(F,b,new c)}static TransformCoordinatesToRef(F,b,Q){return c.TransformCoordinatesFromFloatsToRef(F._x,F._y,F._z,b,Q),Q}static TransformCoordinatesFromFloatsToRef(F,b,Q,C,z){const t=C.m,g=F*t[0]+b*t[4]+Q*t[8]+t[12],W=F*t[1]+b*t[5]+Q*t[9]+t[13],Z=F*t[2]+b*t[6]+Q*t[10]+t[14],q=F*t[3]+b*t[7]+Q*t[11]+t[15];return z.x=g,z.y=W,z.z=Z,z.w=q,z}static TransformNormal(F,b){return c.TransformNormalToRef(F,b,new c)}static TransformNormalToRef(F,b,Q){const C=b.m,z=F.x*C[0]+F.y*C[4]+F.z*C[8],t=F.x*C[1]+F.y*C[5]+F.z*C[9],g=F.x*C[2]+F.y*C[6]+F.z*C[10];return Q.x=z,Q.y=t,Q.z=g,Q.w=F.w,Q}static TransformNormalFromFloatsToRef(F,b,Q,C,z,t){const g=z.m;return t.x=F*g[0]+b*g[4]+Q*g[8],t.y=F*g[1]+b*g[5]+Q*g[9],t.z=F*g[2]+b*g[6]+Q*g[10],t.w=C,t}static FromVector3(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new c(F._x,F._y,F._z,b)}static Dot(F,b){return F.x*b.x+F.y*b.y+F.z*b.z+F.w*b.w}}c._V8PerformanceHack=new c(.5,.5,.5,.5),c._ZeroReadOnly=c.Zero(),Object.defineProperties(c.prototype,{dimension:{value:[4]},rank:{value:1}});class X{get x(){return this._x}set x(F){this._x=F,this._isDirty=!0}get y(){return this._y}set y(F){this._y=F,this._isDirty=!0}get z(){return this._z}set z(F){this._z=F,this._isDirty=!0}get w(){return this._w}set w(F){this._w=F,this._isDirty=!0}constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=F,this._y=b,this._z=Q,this._w=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let F=N(this._x);return F=397*F^N(this._y),F=397*F^N(this._z),F=397*F^N(this._w),F}Lb(){return[this._x,this._y,this._z,this._w]}toArray(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F[b]=this._x,F[b+1]=this._y,F[b+2]=this._z,F[b+3]=this._w,this}tC(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return X.FromArrayToRef(F,b,this)}equals(F){return F&&this._x===F._x&&this._y===F._y&&this._z===F._z&&this._w===F._w}equalsWithEpsilon(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.c;return F&&(0,Z.WithinEpsilon)(this._x,F._x,b)&&(0,Z.WithinEpsilon)(this._y,F._y,b)&&(0,Z.WithinEpsilon)(this._z,F._z,b)&&(0,Z.WithinEpsilon)(this._w,F._w,b)}isApprox(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.c;return F&&((0,Z.WithinEpsilon)(this._x,F._x,b)&&(0,Z.WithinEpsilon)(this._y,F._y,b)&&(0,Z.WithinEpsilon)(this._z,F._z,b)&&(0,Z.WithinEpsilon)(this._w,F._w,b)||(0,Z.WithinEpsilon)(this._x,-F._x,b)&&(0,Z.WithinEpsilon)(this._y,-F._y,b)&&(0,Z.WithinEpsilon)(this._z,-F._z,b)&&(0,Z.WithinEpsilon)(this._w,-F._w,b))}clone(){return new X(this._x,this._y,this._z,this._w)}W(F){return this._x=F._x,this._y=F._y,this._z=F._z,this._w=F._w,this._isDirty=!0,this}jb(F,b,Q,C){return this._x=F,this._y=b,this._z=Q,this._w=C,this._isDirty=!0,this}set(F,b,Q,C){return this.jb(F,b,Q,C)}Yb(F){return this.jb(F,F,F,F)}add(F){return new X(this._x+F._x,this._y+F._y,this._z+F._z,this._w+F._w)}addInPlace(F){return this._x+=F._x,this._y+=F._y,this._z+=F._z,this._w+=F._w,this._isDirty=!0,this}addToRef(F,b){return b._x=this._x+F._x,b._y=this._y+F._y,b._z=this._z+F._z,b._w=this._w+F._w,b._isDirty=!0,b}addInPlaceFromFloats(F,b,Q,C){return this._x+=F,this._y+=b,this._z+=Q,this._w+=C,this._isDirty=!0,this}subtractToRef(F,b){return b._x=this._x-F._x,b._y=this._y-F._y,b._z=this._z-F._z,b._w=this._w-F._w,b._isDirty=!0,b}subtractFromFloats(F,b,Q,C){return this.subtractFromFloatsToRef(F,b,Q,C,new X)}subtractFromFloatsToRef(F,b,Q,C,z){return z._x=this._x-F,z._y=this._y-b,z._z=this._z-Q,z._w=this._w-C,z._isDirty=!0,z}WQ(F){return new X(this._x-F._x,this._y-F._y,this._z-F._z,this._w-F._w)}PK(F){return this._x-=F._x,this._y-=F._y,this._z-=F._z,this._w-=F._w,this._isDirty=!0,this}scale(F){return new X(this._x*F,this._y*F,this._z*F,this._w*F)}scaleToRef(F,b){return b._x=this._x*F,b._y=this._y*F,b._z=this._z*F,b._w=this._w*F,b._isDirty=!0,b}scaleInPlace(F){return this._x*=F,this._y*=F,this._z*=F,this._w*=F,this._isDirty=!0,this}scaleAndAddToRef(F,b){return b._x+=this._x*F,b._y+=this._y*F,b._z+=this._z*F,b._w+=this._w*F,b._isDirty=!0,b}multiply(F){const b=new X(0,0,0,1);return this.multiplyToRef(F,b),b}multiplyToRef(F,b){const Q=this._x*F._w+this._y*F._z-this._z*F._y+this._w*F._x,C=-this._x*F._z+this._y*F._w+this._z*F._x+this._w*F._y,z=this._x*F._y-this._y*F._x+this._z*F._w+this._w*F._z,t=-this._x*F._x-this._y*F._y-this._z*F._z+this._w*F._w;return b.jb(Q,C,z,t),b}multiplyInPlace(F){return this.multiplyToRef(F,this)}multiplyByFloats(F,b,Q,C){return this._x*=F,this._y*=b,this._z*=Q,this._w*=C,this._isDirty=!0,this}divide(F){throw new ReferenceError("Can not divide a quaternion")}divideToRef(F,b){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(F){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new X)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(F){return F._x=-this._x,F._y=-this._y,F._z=-this._z,F._w=-this._w,F._isDirty=!0,F}equalsToFloats(F,b,Q,C){return this._x===F&&this._y===b&&this._z===Q&&this._w===C}floorToRef(F){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(F){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(F){return F.jb(-this._x,-this._y,-this._z,this._w),F}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new X(-this._x,-this._y,-this._z,this._w)}invert(){const F=this.conjugate(),b=this.lengthSquared();return 0==b||1==b||F.scaleInPlace(1/b),F}invertInPlace(){this.conjugateInPlace();const F=this.lengthSquared();return 0==F||1==F||this.scaleInPlace(1/F),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(F){return 0===F||1===F?this:this.scaleInPlace(1/F)}normalizeToNew(){const F=new X(0,0,0,1);return this.normalizeToRef(F),F}normalizeToRef(F){const b=this.length();return 0===b||1===b?F.jb(this._x,this._y,this._z,this._w):this.scaleToRef(1/b,F)}toEulerAngles(){const F=E.Zero();return this.toEulerAnglesToRef(F),F}toEulerAnglesToRef(F){const b=this._z,Q=this._x,C=this._y,z=this._w,t=C*b-Q*z,g=.4999999;if(t<-g)F._y=2*Math.atan2(C,z),F._x=Math.PI/2,F._z=0,F._isDirty=!0;else if(t>g)F._y=2*Math.atan2(C,z),F._x=-Math.PI/2,F._z=0,F._isDirty=!0;else{const g=z*z,W=b*b,Z=Q*Q,q=C*C;F._z=Math.atan2(2*(Q*C+b*z),-W-Z+q+g),F._x=Math.asin(-2*t),F._y=Math.atan2(2*(b*Q+C*z),W-Z-q+g),F._isDirty=!0}return F}toAlphaBetaGammaToRef(F){const b=this._z,Q=this._x,C=this._y,z=this._w,t=Math.sqrt(Q*Q+C*C),g=Math.sqrt(b*b+z*z),W=2*Math.atan2(t,g),Z=2*Math.atan2(b,z),q=2*Math.atan2(C,Q),G=(Z+q)/2,K=(Z-q)/2;return F.set(K,W,G),F}toRotationMatrix(F){return L.FromQuaternionToRef(this,F),F}fromRotationMatrix(F){return X.FromRotationMatrixToRef(F,this),this}dot(F){return this._x*F._x+this._y*F._y+this._z*F._z+this._w*F._w}toAxisAngle(){const F=E.Zero();return{axis:F,angle:this.toAxisAngleToRef(F)}}toAxisAngleToRef(F){let b=0;const Q=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),C=this._w;return Q>0?(b=2*Math.atan2(Q,C),F.set(this._x/Q,this._y/Q,this._z/Q)):(b=0,F.set(1,0,0)),b}static FromRotationMatrix(F){const b=new X;return X.FromRotationMatrixToRef(F,b),b}static FromRotationMatrixToRef(F,b){const Q=F.m,C=Q[0],z=Q[4],t=Q[8],g=Q[1],W=Q[5],Z=Q[9],q=Q[2],G=Q[6],K=Q[10],e=C+W+K;let N;return e>0?(N=.5/Math.sqrt(e+1),b._w=.25/N,b._x=(G-Z)*N,b._y=(t-q)*N,b._z=(g-z)*N,b._isDirty=!0):C>W&&C>K?(N=2*Math.sqrt(1+C-W-K),b._w=(G-Z)/N,b._x=.25*N,b._y=(z+g)/N,b._z=(t+q)/N,b._isDirty=!0):W>K?(N=2*Math.sqrt(1+W-C-K),b._w=(t-q)/N,b._x=(z+g)/N,b._y=.25*N,b._z=(Z+G)/N,b._isDirty=!0):(N=2*Math.sqrt(1+K-C-W),b._w=(g-z)/N,b._x=(t+q)/N,b._y=(Z+G)/N,b._z=.25*N,b._isDirty=!0),b}static Dot(F,b){return F._x*b._x+F._y*b._y+F._z*b._z+F._w*b._w}static AreClose(F,b){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const C=X.Dot(F,b);return 1-C*C<=Q}static SmoothToRef(F,b,Q,C,z){let t=0===C?1:Q/C;return t=(0,Z.Clamp)(t,0,1),X.SlerpToRef(F,b,t,z),z}static Zero(){return new X(0,0,0,0)}static Inverse(F){return new X(-F._x,-F._y,-F._z,F._w)}static InverseToRef(F,b){return b.set(-F._x,-F._y,-F._z,F._w),b}static Identity(){return new X(0,0,0,1)}static IsIdentity(F){return F&&0===F._x&&0===F._y&&0===F._z&&1===F._w}static RotationAxis(F,b){return X.RotationAxisToRef(F,b,new X)}static RotationAxisToRef(F,b,Q){Q._w=Math.cos(b/2);const C=Math.sin(b/2)/F.length();return Q._x=F._x*C,Q._y=F._y*C,Q._z=F._z*C,Q._isDirty=!0,Q}static KQ(F,b){return b||(b=0),new X(F[b],F[b+1],F[b+2],F[b+3])}static FromArrayToRef(F,b,Q){return Q._x=F[b],Q._y=F[b+1],Q._z=F[b+2],Q._w=F[b+3],Q._isDirty=!0,Q}static FromFloatsToRef(F,b,Q,C,z){return z.jb(F,b,Q,C),z}static FromEulerAngles(F,b,Q){const C=new X;return X.RotationYawPitchRollToRef(b,F,Q,C),C}static FromEulerAnglesToRef(F,b,Q,C){return X.RotationYawPitchRollToRef(b,F,Q,C),C}static FromEulerVector(F){const b=new X;return X.RotationYawPitchRollToRef(F._y,F._x,F._z,b),b}static FromEulerVectorToRef(F,b){return X.RotationYawPitchRollToRef(F._y,F._x,F._z,b),b}static FromUnitVectorsToRef(F,b,Q){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C.c;const t=E.Dot(F,b)+1;return t<z?Math.abs(F.x)>Math.abs(F.z)?Q.set(-F.y,F.x,0,0):Q.set(0,-F.z,F.y,0):(E.CrossToRef(F,b,f.gQ[0]),Q.set(f.gQ[0].x,f.gQ[0].y,f.gQ[0].z,t)),Q.normalize()}static RotationYawPitchRoll(F,b,Q){const C=new X;return X.RotationYawPitchRollToRef(F,b,Q,C),C}static RotationYawPitchRollToRef(F,b,Q,C){const z=.5*Q,t=.5*b,g=.5*F,W=Math.sin(z),Z=Math.cos(z),q=Math.sin(t),G=Math.cos(t),K=Math.sin(g),e=Math.cos(g);return C._x=e*q*Z+K*G*W,C._y=K*G*Z-e*q*W,C._z=e*G*W-K*q*Z,C._w=e*G*Z+K*q*W,C._isDirty=!0,C}static RotationAlphaBetaGamma(F,b,Q){const C=new X;return X.RotationAlphaBetaGammaToRef(F,b,Q,C),C}static RotationAlphaBetaGammaToRef(F,b,Q,C){const z=.5*(Q+F),t=.5*(Q-F),g=.5*b;return C._x=Math.cos(t)*Math.sin(g),C._y=Math.sin(t)*Math.sin(g),C._z=Math.sin(z)*Math.cos(g),C._w=Math.cos(z)*Math.cos(g),C._isDirty=!0,C}static RotationQuaternionFromAxis(F,b,Q){const C=new X(0,0,0,0);return X.RotationQuaternionFromAxisToRef(F,b,Q,C),C}static RotationQuaternionFromAxisToRef(F,b,Q,C){const z=i.Matrix[0];return F=F.normalizeToRef(i.gQ[0]),b=b.normalizeToRef(i.gQ[1]),Q=Q.normalizeToRef(i.gQ[2]),L.FromXYZAxesToRef(F,b,Q,z),X.FromRotationMatrixToRef(z,C),C}static FromLookDirectionLH(F,b){const Q=new X;return X.FromLookDirectionLHToRef(F,b,Q),Q}static FromLookDirectionLHToRef(F,b,Q){const C=i.Matrix[0];return L.LookDirectionLHToRef(F,b,C),X.FromRotationMatrixToRef(C,Q),Q}static FromLookDirectionRH(F,b){const Q=new X;return X.FromLookDirectionRHToRef(F,b,Q),Q}static FromLookDirectionRHToRef(F,b,Q){const C=i.Matrix[0];return L.LookDirectionRHToRef(F,b,C),X.FromRotationMatrixToRef(C,Q)}static Slerp(F,b,Q){const C=X.Identity();return X.SlerpToRef(F,b,Q,C),C}static SlerpToRef(F,b,Q,C){let z,t,g=F._x*b._x+F._y*b._y+F._z*b._z+F._w*b._w,W=!1;if(g<0&&(W=!0,g=-g),g>.999999)t=1-Q,z=W?-Q:Q;else{const F=Math.acos(g),b=1/Math.sin(F);t=Math.sin((1-Q)*F)*b,z=W?-Math.sin(Q*F)*b:Math.sin(Q*F)*b}return C._x=t*F._x+z*b._x,C._y=t*F._y+z*b._y,C._z=t*F._z+z*b._z,C._w=t*F._w+z*b._w,C._isDirty=!0,C}static Hermite(F,b,Q,C,z){const t=z*z,g=z*t,W=2*g-3*t+1,Z=-2*g+3*t,q=g-2*t+z,G=g-t,K=F._x*W+Q._x*Z+b._x*q+C._x*G,e=F._y*W+Q._y*Z+b._y*q+C._y*G,N=F._z*W+Q._z*Z+b._z*q+C._z*G,y=F._w*W+Q._w*Z+b._w*q+C._w*G;return new X(K,e,N,y)}static Hermite1stDerivative(F,b,Q,C,z){const t=new X;return this.Hermite1stDerivativeToRef(F,b,Q,C,z,t),t}static Hermite1stDerivativeToRef(F,b,Q,C,z,t){const g=z*z;return t._x=6*(g-z)*F._x+(3*g-4*z+1)*b._x+6*(-g+z)*Q._x+(3*g-2*z)*C._x,t._y=6*(g-z)*F._y+(3*g-4*z+1)*b._y+6*(-g+z)*Q._y+(3*g-2*z)*C._y,t._z=6*(g-z)*F._z+(3*g-4*z+1)*b._z+6*(-g+z)*Q._z+(3*g-2*z)*C._z,t._w=6*(g-z)*F._w+(3*g-4*z+1)*b._w+6*(-g+z)*Q._w+(3*g-2*z)*C._w,t._isDirty=!0,t}static Normalize(F){const b=X.Zero();return X.NormalizeToRef(F,b),b}static NormalizeToRef(F,b){return F.normalizeToRef(b),b}static Clamp(F,b,Q){const C=new X;return X.ClampToRef(F,b,Q,C),C}static ClampToRef(F,b,Q,C){return C.jb((0,Z.Clamp)(F.x,b.x,Q.x),(0,Z.Clamp)(F.y,b.y,Q.y),(0,Z.Clamp)(F.z,b.z,Q.z),(0,Z.Clamp)(F.w,b.w,Q.w))}static Random(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new X((0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b))}static RandomToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).jb((0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b),(0,Z.RandomRange)(F,b))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(F,b){return Math.sqrt(X.DistanceSquared(F,b))}static DistanceSquared(F,b){const Q=F.x-b.x,C=F.y-b.y,z=F.z-b.z,t=F.w-b.w;return Q*Q+C*C+z*z+t*t}static Center(F,b){return X.CenterToRef(F,b,X.Zero())}static CenterToRef(F,b,Q){return Q.jb((F.x+b.x)/2,(F.y+b.y)/2,(F.z+b.z)/2,(F.w+b.w)/2)}}X._V8PerformanceHack=new X(.5,.5,.5,.5),Object.defineProperties(X.prototype,{dimension:{value:[4]},rank:{value:1}});class L{static get Use64Bits(){return g.b.MatrixUse64Bits}get m(){return this.eb}markAsUpdated(){this.updateFlag=q._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(F){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=F,this._isIdentity3x2=F||Q,this._isIdentityDirty=!this._isIdentity&&b,this._isIdentity3x2Dirty=!this._isIdentity3x2&&C}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,g.b.MatrixTrackPrecisionChange&&g.b.MatrixTrackedMatrices.push(this),this.eb=new g.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const F=this.eb;this._isIdentity=1===F[0]&&0===F[1]&&0===F[2]&&0===F[3]&&0===F[4]&&1===F[5]&&0===F[6]&&0===F[7]&&0===F[8]&&0===F[9]&&1===F[10]&&0===F[11]&&0===F[12]&&0===F[13]&&0===F[14]&&1===F[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.eb[0]||1!==this.eb[5]||1!==this.eb[15]||0!==this.eb[1]||0!==this.eb[2]||0!==this.eb[3]||0!==this.eb[4]||0!==this.eb[6]||0!==this.eb[7]||0!==this.eb[8]||0!==this.eb[9]||0!==this.eb[10]||0!==this.eb[11]||0!==this.eb[12]||0!==this.eb[13]||0!==this.eb[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const F=this.eb,b=F[0],Q=F[1],C=F[2],z=F[3],t=F[4],g=F[5],W=F[6],Z=F[7],q=F[8],G=F[9],K=F[10],e=F[11],N=F[12],y=F[13],E=F[14],c=F[15],X=K*c-E*e,L=G*c-y*e,i=G*E-y*K,f=q*c-N*e,k=q*E-K*N,m=q*y-N*G;return b*+(g*X-W*L+Z*i)+Q*-(t*X-W*f+Z*k)+C*+(t*L-g*f+Z*m)+z*-(t*i-g*k+W*m)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!F)return this.eb;const Q=this.eb;for(let C=0;C<16;C++)F[b+C]=Q[C];return this}Lb(){return this.eb}tC(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(F,b,this)}jb(){for(var F=arguments.length,b=new Array(F),Q=0;Q<F;Q++)b[Q]=arguments[Q];return L.FromArrayToRef(b,0,this)}set(){const F=this.eb;for(let b=0;b<16;b++)F[b]=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}Yb(F){const b=this.eb;for(let Q=0;Q<16;Q++)b[Q]=F;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return L.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(F){const b=new L;return this.addToRef(F,b),b}addToRef(F,b){const Q=this.eb,C=b.eb,z=F.m;for(let t=0;t<16;t++)C[t]=Q[t]+z[t];return b.markAsUpdated(),b}addToSelf(F){const b=this.eb,Q=F.m;return b[0]+=Q[0],b[1]+=Q[1],b[2]+=Q[2],b[3]+=Q[3],b[4]+=Q[4],b[5]+=Q[5],b[6]+=Q[6],b[7]+=Q[7],b[8]+=Q[8],b[9]+=Q[9],b[10]+=Q[10],b[11]+=Q[11],b[12]+=Q[12],b[13]+=Q[13],b[14]+=Q[14],b[15]+=Q[15],this.markAsUpdated(),this}addInPlace(F){const b=this.eb,Q=F.m;for(let C=0;C<16;C++)b[C]+=Q[C];return this.markAsUpdated(),this}addInPlaceFromFloats(){const F=this.eb;for(let b=0;b<16;b++)F[b]+=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}WQ(F){const b=this.eb,Q=F.m;for(let C=0;C<16;C++)b[C]-=Q[C];return this.markAsUpdated(),this}subtractToRef(F,b){const Q=this.eb,C=F.m,z=b.eb;for(let t=0;t<16;t++)z[t]=Q[t]-C[t];return b.markAsUpdated(),b}PK(F){const b=this.eb,Q=F.m;for(let C=0;C<16;C++)b[C]-=Q[C];return this.markAsUpdated(),this}subtractFromFloats(){for(var F=arguments.length,b=new Array(F),Q=0;Q<F;Q++)b[Q]=arguments[Q];return this.subtractFromFloatsToRef(...b,new L)}subtractFromFloatsToRef(){for(var F=arguments.length,b=new Array(F),Q=0;Q<F;Q++)b[Q]=arguments[Q];const C=b.pop(),z=this.eb,t=C.eb,g=b;for(let W=0;W<16;W++)t[W]=z[W]-g[W];return C.markAsUpdated(),C}invertToRef(F){return!0===this._isIdentity?(L.IdentityToRef(F),F):(e(this,F.Lb())?F.markAsUpdated():F.W(this),F)}addAtIndex(F,b){return this.eb[F]+=b,this.markAsUpdated(),this}multiplyAtIndex(F,b){return this.eb[F]*=b,this.markAsUpdated(),this}setTranslationFromFloats(F,b,Q){return this.eb[12]=F,this.eb[13]=b,this.eb[14]=Q,this.markAsUpdated(),this}addTranslationFromFloats(F,b,Q){return this.eb[12]+=F,this.eb[13]+=b,this.eb[14]+=Q,this.markAsUpdated(),this}setTranslation(F){return this.setTranslationFromFloats(F._x,F._y,F._z)}getTranslation(){return new E(this.eb[12],this.eb[13],this.eb[14])}getTranslationToRef(F){return F.x=this.eb[12],F.y=this.eb[13],F.z=this.eb[14],F}removeRotationAndScaling(){const F=this.m;return L.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,F[12],F[13],F[14],F[15],this),this._updateIdentityStatus(0===F[12]&&0===F[13]&&0===F[14]&&1===F[15]),this}W(F){F.copyToArray(this.eb);const b=F;return this.updateFlag=b.updateFlag,this._updateIdentityStatus(b._isIdentity,b._isIdentityDirty,b._isIdentity3x2,b._isIdentity3x2Dirty),this}copyToArray(F){return K(this,F,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(F){const b=new L;return this.multiplyToRef(F,b),b}multiplyInPlace(F){const b=this.eb,Q=F.m;for(let C=0;C<16;C++)b[C]*=Q[C];return this.markAsUpdated(),this}multiplyByFloats(){const F=this.eb;for(let b=0;b<16;b++)F[b]*=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var F=arguments.length,b=new Array(F),Q=0;Q<F;Q++)b[Q]=arguments[Q];const C=b.pop(),z=this.eb,t=C.eb,g=b;for(let W=0;W<16;W++)t[W]=z[W]*g[W];return C.markAsUpdated(),C}multiplyToRef(F,b){return this._isIdentity?(b.W(F),b):F._isIdentity?(b.W(this),b):(this.multiplyToArray(F,b.eb,0),b.markAsUpdated(),b)}multiplyToArray(F,b,Q){return G(this,F,b,Q),this}divide(F){return this.divideToRef(F,new L)}divideToRef(F,b){const Q=this.eb,C=F.m,z=b.eb;for(let t=0;t<16;t++)z[t]=Q[t]/C[t];return b.markAsUpdated(),b}divideInPlace(F){const b=this.eb,Q=F.m;for(let C=0;C<16;C++)b[C]/=Q[C];return this.markAsUpdated(),this}minimizeInPlace(F){const b=this.eb,Q=F.m;for(let C=0;C<16;C++)b[C]=Math.min(b[C],Q[C]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const F=this.eb;for(let b=0;b<16;b++)F[b]=Math.min(F[b],b<0||arguments.length<=b?void 0:arguments[b]);return this.markAsUpdated(),this}maximizeInPlace(F){const b=this.eb,Q=F.m;for(let C=0;C<16;C++)b[C]=Math.min(b[C],Q[C]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const F=this.eb;for(let b=0;b<16;b++)F[b]=Math.min(F[b],b<0||arguments.length<=b?void 0:arguments[b]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new L)}negateInPlace(){const F=this.eb;for(let b=0;b<16;b++)F[b]=-F[b];return this.markAsUpdated(),this}negateToRef(F){const b=this.eb,Q=F.eb;for(let C=0;C<16;C++)Q[C]=-b[C];return F.markAsUpdated(),F}equals(F){const b=F;if(!b)return!1;if((this._isIdentity||b._isIdentity)&&!this._isIdentityDirty&&!b._isIdentityDirty)return this._isIdentity&&b._isIdentity;const Q=this.m,C=b.m;return Q[0]===C[0]&&Q[1]===C[1]&&Q[2]===C[2]&&Q[3]===C[3]&&Q[4]===C[4]&&Q[5]===C[5]&&Q[6]===C[6]&&Q[7]===C[7]&&Q[8]===C[8]&&Q[9]===C[9]&&Q[10]===C[10]&&Q[11]===C[11]&&Q[12]===C[12]&&Q[13]===C[13]&&Q[14]===C[14]&&Q[15]===C[15]}equalsWithEpsilon(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Q=this.eb,C=F.m;for(let z=0;z<16;z++)if(!(0,Z.WithinEpsilon)(Q[z],C[z],b))return!1;return!0}equalsToFloats(){const F=this.eb;for(let b=0;b<16;b++)if(F[b]!=(b<0||arguments.length<=b?void 0:arguments[b]))return!1;return!0}floor(){return this.floorToRef(new L)}floorToRef(F){const b=this.eb,Q=F.eb;for(let C=0;C<16;C++)Q[C]=Math.floor(b[C]);return F.markAsUpdated(),F}fract(){return this.fractToRef(new L)}fractToRef(F){const b=this.eb,Q=F.eb;for(let C=0;C<16;C++)Q[C]=b[C]-Math.floor(b[C]);return F.markAsUpdated(),F}clone(){const F=new L;return F.W(this),F}getClassName(){return"Matrix"}getHashCode(){let F=N(this.eb[0]);for(let b=1;b<16;b++)F=397*F^N(this.eb[b]);return F}decomposeToTransformNode(F){return F.rotationQuaternion=F.rotationQuaternion||new X,this.decompose(F.wb,F.rotationQuaternion,F.position)}decompose(F,b,Q,C){let z=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return Q&&Q.Yb(0),F&&F.Yb(1),b&&b.jb(0,0,0,1),!0;const t=this.eb;if(Q&&Q.jb(t[12],t[13],t[14]),(F=F||i.gQ[0]).x=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),F.y=Math.sqrt(t[4]*t[4]+t[5]*t[5]+t[6]*t[6]),F.z=Math.sqrt(t[8]*t[8]+t[9]*t[9]+t[10]*t[10]),C){const b=(z?C.absoluteScaling.x:C.wb.x)<0?-1:1,Q=(z?C.absoluteScaling.y:C.wb.y)<0?-1:1,t=(z?C.absoluteScaling.z:C.wb.z)<0?-1:1;F.x*=b,F.y*=Q,F.z*=t}else this.determinant()<=0&&(F.y*=-1);if(0===F._x||0===F._y||0===F._z)return b&&b.jb(0,0,0,1),!1;if(b){const Q=1/F._x,C=1/F._y,z=1/F._z;L.FromValuesToRef(t[0]*Q,t[1]*Q,t[2]*Q,0,t[4]*C,t[5]*C,t[6]*C,0,t[8]*z,t[9]*z,t[10]*z,0,0,0,0,1,i.Matrix[0]),X.FromRotationMatrixToRef(i.Matrix[0],b)}return!0}getRow(F){if(F<0||F>3)return null;const b=4*F;return new c(this.eb[b+0],this.eb[b+1],this.eb[b+2],this.eb[b+3])}getRowToRef(F,b){if(F>=0&&F<=3){const Q=4*F;b.x=this.eb[Q+0],b.y=this.eb[Q+1],b.z=this.eb[Q+2],b.w=this.eb[Q+3]}return b}setRow(F,b){return this.setRowFromFloats(F,b.x,b.y,b.z,b.w)}transpose(){const F=new L;return L.TransposeToRef(this,F),F}transposeToRef(F){return L.TransposeToRef(this,F),F}setRowFromFloats(F,b,Q,C,z){if(F<0||F>3)return this;const t=4*F;return this.eb[t+0]=b,this.eb[t+1]=Q,this.eb[t+2]=C,this.eb[t+3]=z,this.markAsUpdated(),this}scale(F){const b=new L;return this.scaleToRef(F,b),b}scaleToRef(F,b){for(let Q=0;Q<16;Q++)b.eb[Q]=this.eb[Q]*F;return b.markAsUpdated(),b}scaleAndAddToRef(F,b){for(let Q=0;Q<16;Q++)b.eb[Q]+=this.eb[Q]*F;return b.markAsUpdated(),b}scaleInPlace(F){const b=this.eb;for(let Q=0;Q<16;Q++)b[Q]*=F;return this.markAsUpdated(),this}toNormalMatrix(F){const b=i.Matrix[0];this.invertToRef(b),b.transposeToRef(F);const Q=F.eb;return L.FromValuesToRef(Q[0],Q[1],Q[2],0,Q[4],Q[5],Q[6],0,Q[8],Q[9],Q[10],0,0,0,0,1,F),F}getRotationMatrix(){const F=new L;return this.getRotationMatrixToRef(F),F}getRotationMatrixToRef(F){const b=i.gQ[0];if(!this.decompose(b))return L.IdentityToRef(F),F;const Q=this.eb,C=1/b._x,z=1/b._y,t=1/b._z;return L.FromValuesToRef(Q[0]*C,Q[1]*C,Q[2]*C,0,Q[4]*z,Q[5]*z,Q[6]*z,0,Q[8]*t,Q[9]*t,Q[10]*t,0,0,0,0,1,F),F}toggleModelMatrixHandInPlace(){const F=this.eb;return F[2]*=-1,F[6]*=-1,F[8]*=-1,F[9]*=-1,F[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const F=this.eb;return F[8]*=-1,F[9]*=-1,F[10]*=-1,F[11]*=-1,this.markAsUpdated(),this}static KQ(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Q=new L;return L.FromArrayToRef(F,b,Q),Q}static FromArrayToRef(F,b,Q){for(let C=0;C<16;C++)Q.eb[C]=F[C+b];return Q.markAsUpdated(),Q}static FromFloat32ArrayToRefScaled(F,b,Q,C){return C.eb[0]=F[0+b]*Q,C.eb[1]=F[1+b]*Q,C.eb[2]=F[2+b]*Q,C.eb[3]=F[3+b]*Q,C.eb[4]=F[4+b]*Q,C.eb[5]=F[5+b]*Q,C.eb[6]=F[6+b]*Q,C.eb[7]=F[7+b]*Q,C.eb[8]=F[8+b]*Q,C.eb[9]=F[9+b]*Q,C.eb[10]=F[10+b]*Q,C.eb[11]=F[11+b]*Q,C.eb[12]=F[12+b]*Q,C.eb[13]=F[13+b]*Q,C.eb[14]=F[14+b]*Q,C.eb[15]=F[15+b]*Q,C.markAsUpdated(),C}static get IdentityReadOnly(){return L._IdentityReadOnly}static FromValuesToRef(F,b,Q,C,z,t,g,W,Z,q,G,K,e,N,y,E,c){const X=c.eb;X[0]=F,X[1]=b,X[2]=Q,X[3]=C,X[4]=z,X[5]=t,X[6]=g,X[7]=W,X[8]=Z,X[9]=q,X[10]=G,X[11]=K,X[12]=e,X[13]=N,X[14]=y,X[15]=E,c.markAsUpdated()}static FromValues(F,b,Q,C,z,t,g,W,Z,q,G,K,e,N,y,E){const c=new L,X=c.eb;return X[0]=F,X[1]=b,X[2]=Q,X[3]=C,X[4]=z,X[5]=t,X[6]=g,X[7]=W,X[8]=Z,X[9]=q,X[10]=G,X[11]=K,X[12]=e,X[13]=N,X[14]=y,X[15]=E,c.markAsUpdated(),c}static Compose(F,b,Q){const C=new L;return L.ComposeToRef(F,b,Q,C),C}static ComposeToRef(F,b,Q,C){const z=C.eb,t=b._x,g=b._y,W=b._z,Z=b._w,q=t+t,G=g+g,K=W+W,e=t*q,N=t*G,y=t*K,E=g*G,c=g*K,X=W*K,L=Z*q,i=Z*G,f=Z*K,k=F._x,m=F._y,R=F._z;return z[0]=(1-(E+X))*k,z[1]=(N+f)*k,z[2]=(y-i)*k,z[3]=0,z[4]=(N-f)*m,z[5]=(1-(e+X))*m,z[6]=(c+L)*m,z[7]=0,z[8]=(y+i)*R,z[9]=(c-L)*R,z[10]=(1-(e+E))*R,z[11]=0,z[12]=Q._x,z[13]=Q._y,z[14]=Q._z,z[15]=1,C.markAsUpdated(),C}static Identity(){const F=L.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return F._updateIdentityStatus(!0),F}static IdentityToRef(F){return L.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,F),F._updateIdentityStatus(!0),F}static Zero(){const F=L.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return F._updateIdentityStatus(!1),F}static RotationX(F){const b=new L;return L.RotationXToRef(F,b),b}static Invert(F){const b=new L;return F.invertToRef(b),b}static RotationXToRef(F,b){const Q=Math.sin(F),C=Math.cos(F);return L.FromValuesToRef(1,0,0,0,0,C,Q,0,0,-Q,C,0,0,0,0,1,b),b._updateIdentityStatus(1===C&&0===Q),b}static RotationY(F){const b=new L;return L.RotationYToRef(F,b),b}static RotationYToRef(F,b){const Q=Math.sin(F),C=Math.cos(F);return L.FromValuesToRef(C,0,-Q,0,0,1,0,0,Q,0,C,0,0,0,0,1,b),b._updateIdentityStatus(1===C&&0===Q),b}static RotationZ(F){const b=new L;return L.RotationZToRef(F,b),b}static RotationZToRef(F,b){const Q=Math.sin(F),C=Math.cos(F);return L.FromValuesToRef(C,Q,0,0,-Q,C,0,0,0,0,1,0,0,0,0,1,b),b._updateIdentityStatus(1===C&&0===Q),b}static RotationAxis(F,b){const Q=new L;return L.RotationAxisToRef(F,b,Q),Q}static RotationAxisToRef(F,b,Q){const C=Math.sin(-b),z=Math.cos(-b),t=1-z;F=F.normalizeToRef(i.gQ[0]);const g=Q.eb;return g[0]=F._x*F._x*t+z,g[1]=F._x*F._y*t-F._z*C,g[2]=F._x*F._z*t+F._y*C,g[3]=0,g[4]=F._y*F._x*t+F._z*C,g[5]=F._y*F._y*t+z,g[6]=F._y*F._z*t-F._x*C,g[7]=0,g[8]=F._z*F._x*t-F._y*C,g[9]=F._z*F._y*t+F._x*C,g[10]=F._z*F._z*t+z,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,Q.markAsUpdated(),Q}static RotationAlignToRef(F,b,Q){let z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const t=E.Dot(b,F),g=Q.eb;if(t<-1+C.c)g[0]=-1,g[1]=0,g[2]=0,g[3]=0,g[4]=0,g[5]=z?1:-1,g[6]=0,g[7]=0,g[8]=0,g[9]=0,g[10]=z?-1:1,g[11]=0;else{const Q=E.Cross(b,F),C=1/(1+t);g[0]=Q._x*Q._x*C+t,g[1]=Q._y*Q._x*C-Q._z,g[2]=Q._z*Q._x*C+Q._y,g[3]=0,g[4]=Q._x*Q._y*C+Q._z,g[5]=Q._y*Q._y*C+t,g[6]=Q._z*Q._y*C-Q._x,g[7]=0,g[8]=Q._x*Q._z*C-Q._y,g[9]=Q._y*Q._z*C+Q._x,g[10]=Q._z*Q._z*C+t,g[11]=0}return g[12]=0,g[13]=0,g[14]=0,g[15]=1,Q.markAsUpdated(),Q}static RotationYawPitchRoll(F,b,Q){const C=new L;return L.RotationYawPitchRollToRef(F,b,Q,C),C}static RotationYawPitchRollToRef(F,b,Q,C){return X.RotationYawPitchRollToRef(F,b,Q,i.Quaternion[0]),i.Quaternion[0].toRotationMatrix(C),C}static Scaling(F,b,Q){const C=new L;return L.ScalingToRef(F,b,Q,C),C}static ScalingToRef(F,b,Q,C){return L.FromValuesToRef(F,0,0,0,0,b,0,0,0,0,Q,0,0,0,0,1,C),C._updateIdentityStatus(1===F&&1===b&&1===Q),C}static Translation(F,b,Q){const C=new L;return L.TranslationToRef(F,b,Q,C),C}static TranslationToRef(F,b,Q,C){return L.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,F,b,Q,1,C),C._updateIdentityStatus(0===F&&0===b&&0===Q),C}static Lerp(F,b,Q){const C=new L;return L.LerpToRef(F,b,Q,C),C}static LerpToRef(F,b,Q,C){const z=C.eb,t=F.m,g=b.m;for(let W=0;W<16;W++)z[W]=t[W]*(1-Q)+g[W]*Q;return C.markAsUpdated(),C}static DecomposeLerp(F,b,Q){const C=new L;return L.DecomposeLerpToRef(F,b,Q,C),C}static DecomposeLerpToRef(F,b,Q,C){const z=i.gQ[0],t=i.Quaternion[0],g=i.gQ[1];F.decompose(z,t,g);const W=i.gQ[2],Z=i.Quaternion[1],q=i.gQ[3];b.decompose(W,Z,q);const G=i.gQ[4];E.LerpToRef(z,W,Q,G);const K=i.Quaternion[2];X.SlerpToRef(t,Z,Q,K);const e=i.gQ[5];return E.LerpToRef(g,q,Q,e),L.ComposeToRef(G,K,e,C),C}static LookAtLH(F,b,Q){const C=new L;return L.LookAtLHToRef(F,b,Q,C),C}static LookAtLHToRef(F,b,Q,C){const z=i.gQ[0],t=i.gQ[1],g=i.gQ[2];b.subtractToRef(F,g),g.normalize(),E.CrossToRef(Q,g,z);const W=z.lengthSquared();0===W?z.x=1:z.normalizeFromLength(Math.sqrt(W)),E.CrossToRef(g,z,t),t.normalize();const Z=-E.Dot(z,F),q=-E.Dot(t,F),G=-E.Dot(g,F);return L.FromValuesToRef(z._x,t._x,g._x,0,z._y,t._y,g._y,0,z._z,t._z,g._z,0,Z,q,G,1,C),C}static LookAtRH(F,b,Q){const C=new L;return L.LookAtRHToRef(F,b,Q,C),C}static LookAtRHToRef(F,b,Q,C){const z=i.gQ[0],t=i.gQ[1],g=i.gQ[2];F.subtractToRef(b,g),g.normalize(),E.CrossToRef(Q,g,z);const W=z.lengthSquared();0===W?z.x=1:z.normalizeFromLength(Math.sqrt(W)),E.CrossToRef(g,z,t),t.normalize();const Z=-E.Dot(z,F),q=-E.Dot(t,F),G=-E.Dot(g,F);return L.FromValuesToRef(z._x,t._x,g._x,0,z._y,t._y,g._y,0,z._z,t._z,g._z,0,Z,q,G,1,C),C}static LookDirectionLH(F,b){const Q=new L;return L.LookDirectionLHToRef(F,b,Q),Q}static LookDirectionLHToRef(F,b,Q){const C=i.gQ[0];C.W(F),C.scaleInPlace(-1);const z=i.gQ[1];return E.CrossToRef(b,C,z),L.FromValuesToRef(z._x,z._y,z._z,0,b._x,b._y,b._z,0,C._x,C._y,C._z,0,0,0,0,1,Q),Q}static LookDirectionRH(F,b){const Q=new L;return L.LookDirectionRHToRef(F,b,Q),Q}static LookDirectionRHToRef(F,b,Q){const C=i.gQ[2];return E.CrossToRef(b,F,C),L.FromValuesToRef(C._x,C._y,C._z,0,b._x,b._y,b._z,0,F._x,F._y,F._z,0,0,0,0,1,Q),Q}static OrthoLH(F,b,Q,C,z){const t=new L;return L.OrthoLHToRef(F,b,Q,C,t,z),t}static OrthoLHToRef(F,b,Q,C,z,t){const g=2/F,W=2/b,Z=2/(C-Q),q=-(C+Q)/(C-Q);return L.FromValuesToRef(g,0,0,0,0,W,0,0,0,0,Z,0,0,0,q,1,z),t&&z.multiplyToRef(k,z),z._updateIdentityStatus(1===g&&1===W&&1===Z&&0===q),z}static OrthoOffCenterLH(F,b,Q,C,z,t,g){const W=new L;return L.OrthoOffCenterLHToRef(F,b,Q,C,z,t,W,g),W}static OrthoOffCenterLHToRef(F,b,Q,C,z,t,g,W){const Z=2/(b-F),q=2/(C-Q),G=2/(t-z),K=-(t+z)/(t-z),e=(F+b)/(F-b),N=(C+Q)/(Q-C);return L.FromValuesToRef(Z,0,0,0,0,q,0,0,0,0,G,0,e,N,K,1,g),W&&g.multiplyToRef(k,g),g.markAsUpdated(),g}static ObliqueOffCenterLHToRef(F,b,Q,C,z,t,g,W,Z,q,G){const K=-g*Math.cos(W),e=-g*Math.sin(W);return L.TranslationToRef(0,0,-Z,i.Matrix[1]),L.FromValuesToRef(1,0,0,0,0,1,0,0,K,e,1,0,0,0,0,1,i.Matrix[0]),i.Matrix[1].multiplyToRef(i.Matrix[0],i.Matrix[0]),L.TranslationToRef(0,0,Z,i.Matrix[1]),i.Matrix[0].multiplyToRef(i.Matrix[1],i.Matrix[0]),L.OrthoOffCenterLHToRef(F,b,Q,C,z,t,q,G),i.Matrix[0].multiplyToRef(q,q),q}static OrthoOffCenterRH(F,b,Q,C,z,t,g){const W=new L;return L.OrthoOffCenterRHToRef(F,b,Q,C,z,t,W,g),W}static OrthoOffCenterRHToRef(F,b,Q,C,z,t,g,W){return L.OrthoOffCenterLHToRef(F,b,Q,C,z,t,g,W),g.eb[10]*=-1,g}static ObliqueOffCenterRHToRef(F,b,Q,C,z,t,g,W,Z,q,G){const K=g*Math.cos(W),e=g*Math.sin(W);return L.TranslationToRef(0,0,Z,i.Matrix[1]),L.FromValuesToRef(1,0,0,0,0,1,0,0,K,e,1,0,0,0,0,1,i.Matrix[0]),i.Matrix[1].multiplyToRef(i.Matrix[0],i.Matrix[0]),L.TranslationToRef(0,0,-Z,i.Matrix[1]),i.Matrix[0].multiplyToRef(i.Matrix[1],i.Matrix[0]),L.OrthoOffCenterRHToRef(F,b,Q,C,z,t,q,G),i.Matrix[0].multiplyToRef(q,q),q}static PerspectiveLH(F,b,Q,C,z){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const g=new L,W=2*Q/F,Z=2*Q/b,q=(C+Q)/(C-Q),G=-2*C*Q/(C-Q),K=Math.tan(t);return L.FromValuesToRef(W,0,0,0,0,Z,0,K,0,0,q,1,0,0,G,0,g),z&&g.multiplyToRef(k,g),g._updateIdentityStatus(!1),g}static PerspectiveFovLH(F,b,Q,C,z){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const W=new L;return L.PerspectiveFovLHToRef(F,b,Q,C,W,!0,z,t,g),W}static PerspectiveFovLHToRef(F,b,Q,C,z){let t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,W=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,Z=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const q=Q,G=C,K=1/Math.tan(.5*F),e=t?K/b:K,N=t?K:K*b,y=Z&&0===q?-1:0!==G?(G+q)/(G-q):1,E=Z&&0===q?2*G:0!==G?-2*G*q/(G-q):-2*q,c=Math.tan(W);return L.FromValuesToRef(e,0,0,0,0,N,0,c,0,0,y,1,0,0,E,0,z),g&&z.multiplyToRef(k,z),z._updateIdentityStatus(!1),z}static PerspectiveFovReverseLHToRef(F,b,Q,C,z){let t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,W=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const Z=1/Math.tan(.5*F),q=t?Z/b:Z,G=t?Z:Z*b,K=Math.tan(W);return L.FromValuesToRef(q,0,0,0,0,G,0,K,0,0,-Q,1,0,0,1,0,z),g&&z.multiplyToRef(k,z),z._updateIdentityStatus(!1),z}static PerspectiveFovRH(F,b,Q,C,z){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const W=new L;return L.PerspectiveFovRHToRef(F,b,Q,C,W,!0,z,t,g),W}static PerspectiveFovRHToRef(F,b,Q,C,z){let t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,W=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,Z=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const q=Q,G=C,K=1/Math.tan(.5*F),e=t?K/b:K,N=t?K:K*b,y=Z&&0===q?1:0!==G?-(G+q)/(G-q):-1,E=Z&&0===q?2*G:0!==G?-2*G*q/(G-q):-2*q,c=Math.tan(W);return L.FromValuesToRef(e,0,0,0,0,N,0,c,0,0,y,-1,0,0,E,0,z),g&&z.multiplyToRef(k,z),z._updateIdentityStatus(!1),z}static PerspectiveFovReverseRHToRef(F,b,Q,C,z){let t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,W=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const Z=1/Math.tan(.5*F),q=t?Z/b:Z,G=t?Z:Z*b,K=Math.tan(W);return L.FromValuesToRef(q,0,0,0,0,G,0,K,0,0,-Q,-1,0,0,-1,0,z),g&&z.multiplyToRef(k,z),z._updateIdentityStatus(!1),z}static GetFinalMatrix(F,b,Q,C,z,t){const g=F.width,W=F.height,Z=F.x,q=F.y,G=L.FromValues(g/2,0,0,0,0,-W/2,0,0,0,0,t-z,0,Z+g/2,W/2+q,z,1),K=new L;return b.multiplyToRef(Q,K),K.multiplyToRef(C,K),K.multiplyToRef(G,K)}static GetAsMatrix2x2(F){const b=F.m,Q=[b[0],b[1],b[4],b[5]];return g.b.MatrixUse64Bits?Q:new Float32Array(Q)}static GetAsMatrix3x3(F){const b=F.m,Q=[b[0],b[1],b[2],b[4],b[5],b[6],b[8],b[9],b[10]];return g.b.MatrixUse64Bits?Q:new Float32Array(Q)}static Transpose(F){const b=new L;return L.TransposeToRef(F,b),b}static TransposeToRef(F,b){const Q=F.m,C=Q[0],z=Q[4],t=Q[8],g=Q[12],W=Q[1],Z=Q[5],q=Q[9],G=Q[13],K=Q[2],e=Q[6],N=Q[10],y=Q[14],E=Q[3],c=Q[7],X=Q[11],L=Q[15],i=b.eb;return i[0]=C,i[1]=z,i[2]=t,i[3]=g,i[4]=W,i[5]=Z,i[6]=q,i[7]=G,i[8]=K,i[9]=e,i[10]=N,i[11]=y,i[12]=E,i[13]=c,i[14]=X,i[15]=L,b.markAsUpdated(),b._updateIdentityStatus(F._isIdentity,F._isIdentityDirty),b}static Reflection(F){const b=new L;return L.ReflectionToRef(F,b),b}static ReflectionToRef(F,b){F.normalize();const Q=F.normal.x,C=F.normal.y,z=F.normal.z,t=-2*Q,g=-2*C,W=-2*z;return L.FromValuesToRef(t*Q+1,g*Q,W*Q,0,t*C,g*C+1,W*C,0,t*z,g*z,W*z+1,0,t*F.d,g*F.d,W*F.d,1,b),b}static FromXYZAxesToRef(F,b,Q,C){return L.FromValuesToRef(F._x,F._y,F._z,0,b._x,b._y,b._z,0,Q._x,Q._y,Q._z,0,0,0,0,1,C),C}static FromQuaternionToRef(F,b){const Q=F._x*F._x,C=F._y*F._y,z=F._z*F._z,t=F._x*F._y,g=F._z*F._w,W=F._z*F._x,Z=F._y*F._w,q=F._y*F._z,G=F._x*F._w;return b.eb[0]=1-2*(C+z),b.eb[1]=2*(t+g),b.eb[2]=2*(W-Z),b.eb[3]=0,b.eb[4]=2*(t-g),b.eb[5]=1-2*(z+Q),b.eb[6]=2*(q+G),b.eb[7]=0,b.eb[8]=2*(W+Z),b.eb[9]=2*(q-G),b.eb[10]=1-2*(C+Q),b.eb[11]=0,b.eb[12]=0,b.eb[13]=0,b.eb[14]=0,b.eb[15]=1,b.markAsUpdated(),b}}L._IdentityReadOnly=L.Identity(),Object.defineProperties(L.prototype,{dimension:{value:[4,4]},rank:{value:2}});class i{}i.gQ=(0,z.e)(11,E.Zero),i.Matrix=(0,z.e)(2,L.Identity),i.Quaternion=(0,z.e)(3,X.Zero);class f{}f.Vector2=(0,z.e)(3,y.Zero),f.gQ=(0,z.e)(13,E.Zero),f.Vector4=(0,z.e)(3,c.Zero),f.Quaternion=(0,z.e)(3,X.Zero),f.Matrix=(0,z.e)(8,L.Identity),(0,t.g)("BABYLON.Vector2",y),(0,t.g)("BABYLON.Vector3",E),(0,t.g)("BABYLON.Vector4",c),(0,t.g)("BABYLON.Matrix",L);const k=L.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11320:(F,b,Q)=>{function C(F,b){const Q=[];for(let C=0;C<F;++C)Q.push(b());return Q}function z(F,b){return C(F,b)}Q.d(b,{b:()=>C,e:()=>z,h:()=>g});const t=["push","splice","pop","shift","unshift"];function g(F,b){const Q=t.map((Q=>function(F,b,Q){const C=F[b];if("function"!==typeof C)return null;const z=function(){const C=F.length,t=z.previous.apply(F,arguments);return Q(b,C),t};return C.next=z,z.previous=C,F[b]=z,()=>{const Q=z.previous;if(!Q)return;const C=z.next;C?(Q.next=C,C.previous=Q):(Q.next=void 0,F[b]=Q),z.next=void 0,z.previous=void 0}}(F,Q,b)));return()=>{for(const F of Q)null===F||void 0===F||F()}}}}]);