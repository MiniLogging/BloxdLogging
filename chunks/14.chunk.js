"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[14],{11307:(H,O,S)=>{S.d(O,{e:()=>G,g:()=>p,h:()=>t,i:()=>q});const t=1/2.2,q=2.2,p=(1+Math.sqrt(5))/2,G=.001},11317:(H,O,S)=>{function t(H){return parseInt(H.toString().replace(/\W/g,""))}function q(H,O){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(H-O)<=S}function p(H,O,S){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return H<O-t||H>S+t}function G(H,O){return H===O?H:Math.random()*(O-H)+H}function U(H,O,S){return H+(O-H)*S}function V(H,O,S){let t=E(O-H,360);return t>180&&(t-=360),H+t*a(S)}function w(H,O,S){let t=0;return t=H!=O?a((S-H)/(O-H)):0,t}function o(H,O,S,t,q){const p=q*q,G=q*p;return H*(2*G-3*p+1)+S*(-2*G+3*p)+O*(G-2*p+q)+t*(G-p)}function h(H,O,S,t,q){const p=q*q;return 6*(p-q)*H+(3*p-4*q+1)*O+6*(-p+q)*S+(3*p-2*q)*t}function a(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(S,Math.max(O,H))}function j(H){return H-=2*Math.PI*Math.floor((H+Math.PI)/(2*Math.PI))}function e(H){const O=H.toString(16);return H<=15?("0"+O).toUpperCase():O.toUpperCase()}function X(H){if(Math.log2)return Math.floor(Math.log2(H));if(H<0)return NaN;if(0===H)return-1/0;let O=0;if(H<1){for(;H<1;)O++,H*=2;O=-O}else if(H>1)for(;H>1;)O++,H=Math.floor(H/2);return O}function E(H,O){return H-Math.floor(H/O)*O}function y(H,O,S){return(H-O)/(S-O)}function T(H,O,S){return H*(S-O)+O}function K(H,O){let S=E(O-H,360);return S>180&&(S-=360),S}function b(H,O){const S=E(H,2*O);return O-Math.abs(S-O)}function D(H,O,S){let t=a(S);return t=-2*t*t*t+3*t*t,O*t+H*(1-t)}function F(H,O,S){let t=0;return t=Math.abs(O-H)<=S?O:H+Math.sign(O-H)*S,t}function Y(H,O,S){const t=K(H,O);let q=0;return q=-S<t&&t<S?O:F(H,O=H+t,S),q}function l(H,O,S){return(H-O)/(S-O)}function d(H,O,S){return(S-O)*H+O}function v(H,O){const S=H%O;return 0===S?O:v(O,S)}S.r(O),S.d(O,{Clamp:()=>a,DeltaAngle:()=>K,Denormalize:()=>T,ExtractAsInt:()=>t,Hermite:()=>o,Hermite1stDerivative:()=>h,HighestCommonFactor:()=>v,ILog2:()=>X,InverseLerp:()=>w,Lerp:()=>U,LerpAngle:()=>V,MoveTowards:()=>F,MoveTowardsAngle:()=>Y,Normalize:()=>y,NormalizeRadians:()=>j,OutsideRange:()=>p,PercentToRange:()=>d,PingPong:()=>b,RandomRange:()=>G,RangeToPercent:()=>l,Repeat:()=>E,SmoothStep:()=>D,ToHex:()=>e,WithinEpsilon:()=>q})},11301:(H,O,S)=>{S.r(O),S.d(O,{Matrix:()=>T,Quaternion:()=>y,TmpVectors:()=>b,Vector2:()=>e,eO:()=>X,Vector4:()=>E});var t=S(11307),q=S(11310),p=S(11262),G=S(11234),U=S(11180),V=S(11317);class w{}function o(H,O,S){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const q=H.pU(),p=O.pU(),G=q[0],U=q[1],V=q[2],w=q[3],o=q[4],h=q[5],a=q[6],j=q[7],e=q[8],X=q[9],E=q[10],y=q[11],T=q[12],K=q[13],b=q[14],D=q[15],F=p[0],Y=p[1],l=p[2],d=p[3],v=p[4],z=p[5],m=p[6],r=p[7],W=p[8],g=p[9],N=p[10],x=p[11],k=p[12],A=p[13],u=p[14],J=p[15];S[t]=G*F+U*v+V*W+w*k,S[t+1]=G*Y+U*z+V*g+w*A,S[t+2]=G*l+U*m+V*N+w*u,S[t+3]=G*d+U*r+V*x+w*J,S[t+4]=o*F+h*v+a*W+j*k,S[t+5]=o*Y+h*z+a*g+j*A,S[t+6]=o*l+h*m+a*N+j*u,S[t+7]=o*d+h*r+a*x+j*J,S[t+8]=e*F+X*v+E*W+y*k,S[t+9]=e*Y+X*z+E*g+y*A,S[t+10]=e*l+X*m+E*N+y*u,S[t+11]=e*d+X*r+E*x+y*J,S[t+12]=T*F+K*v+b*W+D*k,S[t+13]=T*Y+K*z+b*g+D*A,S[t+14]=T*l+K*m+b*N+D*u,S[t+15]=T*d+K*r+b*x+D*J}function h(H,O){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const t=H.pU();O[S]=t[0],O[S+1]=t[1],O[S+2]=t[2],O[S+3]=t[3],O[S+4]=t[4],O[S+5]=t[5],O[S+6]=t[6],O[S+7]=t[7],O[S+8]=t[8],O[S+9]=t[9],O[S+10]=t[10],O[S+11]=t[11],O[S+12]=t[12],O[S+13]=t[13],O[S+14]=t[14],O[S+15]=t[15]}function a(H,O){const S=H.pU(),t=S[0],q=S[1],p=S[2],G=S[3],U=S[4],V=S[5],w=S[6],o=S[7],h=S[8],a=S[9],j=S[10],e=S[11],X=S[12],E=S[13],y=S[14],T=S[15],K=j*T-y*e,b=a*T-E*e,D=a*y-E*j,F=h*T-X*e,Y=h*y-j*X,l=h*E-X*a,d=+(V*K-w*b+o*D),v=-(U*K-w*F+o*Y),z=+(U*b-V*F+o*l),m=-(U*D-V*Y+w*l),r=t*d+q*v+p*z+G*m;if(0===r)return!1;const W=1/r,g=w*T-y*o,N=V*T-E*o,x=V*y-E*w,k=U*T-X*o,A=U*y-X*w,u=U*E-X*V,J=w*e-j*o,P=V*e-a*o,f=V*j-a*w,c=U*e-h*o,R=U*j-h*w,B=U*a-h*V,Z=-(q*K-p*b+G*D),I=+(t*K-p*F+G*Y),s=-(t*b-q*F+G*l),i=+(t*D-q*Y+p*l),M=+(q*g-p*N+G*x),C=-(t*g-p*k+G*A),n=+(t*N-q*k+G*u),Q=-(t*x-q*A+p*u),L=-(q*J-p*P+G*f),HH=+(t*J-p*c+G*R),OH=-(t*P-q*c+G*B),SH=+(t*f-q*R+p*B);return O[0]=d*W,O[1]=Z*W,O[2]=M*W,O[3]=L*W,O[4]=v*W,O[5]=I*W,O[6]=C*W,O[7]=HH*W,O[8]=z*W,O[9]=s*W,O[10]=n*W,O[11]=OH*W,O[12]=m*W,O[13]=i*W,O[14]=Q*W,O[15]=SH*W,!0}w._UpdateFlagSeed=0;const j=H=>parseInt(H.toString().replace(/\W/g,""));class e{constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=H,this.y=O}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let H=j(this.x);return H=397*H^j(this.y),H}toArray(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[O]=this.x,H[O+1]=this.y,this}jS(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e.FromArrayToRef(H,O,this),this}pU(){return[this.x,this.y]}t(H){return this.x=H.x,this.y=H.y,this}jU(H,O){return this.x=H,this.y=O,this}set(H,O){return this.jU(H,O)}XU(H){return this.jU(H,H)}add(H){return new e(this.x+H.x,this.y+H.y)}addToRef(H,O){return O.x=this.x+H.x,O.y=this.y+H.y,O}addInPlace(H){return this.x+=H.x,this.y+=H.y,this}addInPlaceFromFloats(H,O){return this.x+=H,this.y+=O,this}addVector3(H){return new e(this.x+H.x,this.y+H.y)}XO(H){return new e(this.x-H.x,this.y-H.y)}subtractToRef(H,O){return O.x=this.x-H.x,O.y=this.y-H.y,O}Mo(H){return this.x-=H.x,this.y-=H.y,this}multiplyInPlace(H){return this.x*=H.x,this.y*=H.y,this}multiply(H){return new e(this.x*H.x,this.y*H.y)}multiplyToRef(H,O){return O.x=this.x*H.x,O.y=this.y*H.y,O}multiplyByFloats(H,O){return new e(this.x*H,this.y*O)}divide(H){return new e(this.x/H.x,this.y/H.y)}divideToRef(H,O){return O.x=this.x/H.x,O.y=this.y/H.y,O}divideInPlace(H){return this.x=this.x/H.x,this.y=this.y/H.y,this}minimizeInPlace(H){return this.minimizeInPlaceFromFloats(H.x,H.y)}maximizeInPlace(H){return this.maximizeInPlaceFromFloats(H.x,H.y)}minimizeInPlaceFromFloats(H,O){return this.x=Math.min(H,this.x),this.y=Math.min(O,this.y),this}maximizeInPlaceFromFloats(H,O){return this.x=Math.max(H,this.x),this.y=Math.max(O,this.y),this}subtractFromFloats(H,O){return new e(this.x-H,this.y-O)}subtractFromFloatsToRef(H,O,S){return S.x=this.x-H,S.y=this.y-O,S}negate(){return new e(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(H){return H.x=-this.x,H.y=-this.y,H}scaleInPlace(H){return this.x*=H,this.y*=H,this}scale(H){return new e(this.x*H,this.y*H)}scaleToRef(H,O){return O.x=this.x*H,O.y=this.y*H,O}scaleAndAddToRef(H,O){return O.x+=this.x*H,O.y+=this.y*H,O}equals(H){return H&&this.x===H.x&&this.y===H.y}equalsWithEpsilon(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.e;return H&&(0,V.WithinEpsilon)(this.x,H.x,O)&&(0,V.WithinEpsilon)(this.y,H.y,O)}equalsToFloats(H,O){return this.x===H&&this.y===O}floor(){return new e(Math.floor(this.x),Math.floor(this.y))}floorToRef(H){return H.x=Math.floor(this.x),H.y=Math.floor(this.y),H}fract(){return new e(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(H){return H.x=this.x-Math.floor(this.x),H.y=this.y-Math.floor(this.y),H}rotate(H){return this.rotateToRef(H,new e)}rotateToRef(H,O){const S=Math.cos(H),t=Math.sin(H);return O.x=S*this.x-t*this.y,O.y=t*this.x+S*this.y,O}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(H){return 0===H||1===H?this:this.scaleInPlace(1/H)}normalizeToNew(){const H=new e;return this.normalizeToRef(H),H}normalizeToRef(H){const O=this.length();return 0===O&&(H.x=this.x,H.y=this.y),this.scaleToRef(1/O,H)}clone(){return new e(this.x,this.y)}dot(H){return this.x*H.x+this.y*H.y}static Zero(){return new e(0,0)}static One(){return new e(1,1)}static Random(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new e((0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O))}static RandomToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).jU((0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O))}static get ZeroReadOnly(){return e._ZeroReadOnly}static KO(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new e(H[O],H[O+1])}static FromArrayToRef(H,O,S){return S.x=H[O],S.y=H[O+1],S}static FromFloatsToRef(H,O,S){return S.jU(H,O),S}static CatmullRom(H,O,S,t,q){const p=q*q,G=q*p,U=.5*(2*O.x+(-H.x+S.x)*q+(2*H.x-5*O.x+4*S.x-t.x)*p+(-H.x+3*O.x-3*S.x+t.x)*G),V=.5*(2*O.y+(-H.y+S.y)*q+(2*H.y-5*O.y+4*S.y-t.y)*p+(-H.y+3*O.y-3*S.y+t.y)*G);return new e(U,V)}static ClampToRef(H,O,S,t){return t.x=(0,V.Clamp)(H.x,O.x,S.x),t.y=(0,V.Clamp)(H.y,O.y,S.y),t}static Clamp(H,O,S){const t=(0,V.Clamp)(H.x,O.x,S.x),q=(0,V.Clamp)(H.y,O.y,S.y);return new e(t,q)}static Hermite(H,O,S,t,q){const p=q*q,G=q*p,U=2*G-3*p+1,V=-2*G+3*p,w=G-2*p+q,o=G-p,h=H.x*U+S.x*V+O.x*w+t.x*o,a=H.y*U+S.y*V+O.y*w+t.y*o;return new e(h,a)}static Hermite1stDerivative(H,O,S,t,q){return this.Hermite1stDerivativeToRef(H,O,S,t,q,new e)}static Hermite1stDerivativeToRef(H,O,S,t,q,p){const G=q*q;return p.x=6*(G-q)*H.x+(3*G-4*q+1)*O.x+6*(-G+q)*S.x+(3*G-2*q)*t.x,p.y=6*(G-q)*H.y+(3*G-4*q+1)*O.y+6*(-G+q)*S.y+(3*G-2*q)*t.y,p}static Lerp(H,O,S){return e.LerpToRef(H,O,S,new e)}static LerpToRef(H,O,S,t){return t.x=H.x+(O.x-H.x)*S,t.y=H.y+(O.y-H.y)*S,t}static Dot(H,O){return H.x*O.x+H.y*O.y}static Normalize(H){return e.NormalizeToRef(H,new e)}static NormalizeToRef(H,O){return H.normalizeToRef(O),O}static Minimize(H,O){const S=H.x<O.x?H.x:O.x,t=H.y<O.y?H.y:O.y;return new e(S,t)}static Maximize(H,O){const S=H.x>O.x?H.x:O.x,t=H.y>O.y?H.y:O.y;return new e(S,t)}static Transform(H,O){return e.TransformToRef(H,O,new e)}static TransformToRef(H,O,S){const t=O.m,q=H.x*t[0]+H.y*t[4]+t[12],p=H.x*t[1]+H.y*t[5]+t[13];return S.x=q,S.y=p,S}static PointInTriangle(H,O,S,t){const q=.5*(-S.y*t.x+O.y*(-S.x+t.x)+O.x*(S.y-t.y)+S.x*t.y),p=q<0?-1:1,G=(O.y*t.x-O.x*t.y+(t.y-O.y)*H.x+(O.x-t.x)*H.y)*p,U=(O.x*S.y-O.y*S.x+(O.y-S.y)*H.x+(S.x-O.x)*H.y)*p;return G>0&&U>0&&G+U<2*q*p}static Distance(H,O){return Math.sqrt(e.DistanceSquared(H,O))}static DistanceSquared(H,O){const S=H.x-O.x,t=H.y-O.y;return S*S+t*t}static Center(H,O){return e.CenterToRef(H,O,new e)}static CenterToRef(H,O,S){return S.jU((H.x+O.x)/2,(H.y+O.y)/2)}static DistanceOfPointFromSegment(H,O,S){const t=e.DistanceSquared(O,S);if(0===t)return e.Distance(H,O);const q=S.XO(O),p=Math.max(0,Math.min(1,e.Dot(H.XO(O),q)/t)),G=O.add(q.multiplyByFloats(p,p));return e.Distance(H,G)}}e._V8PerformanceHack=new e(.5,.5),e._ZeroReadOnly=e.Zero(),Object.defineProperties(e.prototype,{dimension:{value:[2]},rank:{value:1}});class X{get x(){return this._x}set x(H){this._x=H,this._isDirty=!0}get y(){return this._y}set y(H){this._y=H,this._isDirty=!0}get z(){return this._z}set z(H){this._z=H,this._isDirty=!0}constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=H,this._y=O,this._z=S}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"eO"}getHashCode(){let H=j(this._x);return H=397*H^j(this._y),H=397*H^j(this._z),H}pU(){return[this._x,this._y,this._z]}toArray(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[O]=this._x,H[O+1]=this._y,H[O+2]=this._z,this}jS(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return X.FromArrayToRef(H,O,this),this}toQuaternion(){return y.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(H){return this._x+=H._x,this._y+=H._y,this._z+=H._z,this._isDirty=!0,this}addInPlaceFromFloats(H,O,S){return this._x+=H,this._y+=O,this._z+=S,this._isDirty=!0,this}add(H){return new X(this._x+H._x,this._y+H._y,this._z+H._z)}addToRef(H,O){return O._x=this._x+H._x,O._y=this._y+H._y,O._z=this._z+H._z,O._isDirty=!0,O}Mo(H){return this._x-=H._x,this._y-=H._y,this._z-=H._z,this._isDirty=!0,this}XO(H){return new X(this._x-H._x,this._y-H._y,this._z-H._z)}subtractToRef(H,O){return this.subtractFromFloatsToRef(H._x,H._y,H._z,O)}subtractFromFloats(H,O,S){return new X(this._x-H,this._y-O,this._z-S)}subtractFromFloatsToRef(H,O,S,t){return t._x=this._x-H,t._y=this._y-O,t._z=this._z-S,t._isDirty=!0,t}negate(){return new X(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(H){return H._x=-1*this._x,H._y=-1*this._y,H._z=-1*this._z,H._isDirty=!0,H}scaleInPlace(H){return this._x*=H,this._y*=H,this._z*=H,this._isDirty=!0,this}scale(H){return new X(this._x*H,this._y*H,this._z*H)}scaleToRef(H,O){return O._x=this._x*H,O._y=this._y*H,O._z=this._z*H,O._isDirty=!0,O}getNormalToRef(H){const O=this.length();let S=Math.acos(this._y/O);const t=Math.atan2(this._z,this._x);S>Math.PI/2?S-=Math.PI/2:S+=Math.PI/2;const q=O*Math.sin(S)*Math.cos(t),p=O*Math.cos(S),G=O*Math.sin(S)*Math.sin(t);return H.set(q,p,G),H}applyRotationQuaternionToRef(H,O){const S=this._x,t=this._y,q=this._z,p=H._x,G=H._y,U=H._z,V=H._w,w=2*(G*q-U*t),o=2*(U*S-p*q),h=2*(p*t-G*S);return O._x=S+V*w+G*h-U*o,O._y=t+V*o+U*w-p*h,O._z=q+V*h+p*o-G*w,O._isDirty=!0,O}applyRotationQuaternionInPlace(H){return this.applyRotationQuaternionToRef(H,this)}applyRotationQuaternion(H){return this.applyRotationQuaternionToRef(H,new X)}scaleAndAddToRef(H,O){return O._x+=this._x*H,O._y+=this._y*H,O._z+=this._z*H,O._isDirty=!0,O}projectOnPlane(H,O){return this.projectOnPlaneToRef(H,O,new X)}projectOnPlaneToRef(H,O,S){const t=H.normal,q=H.d,p=K.eO[0];this.subtractToRef(O,p),p.normalize();const G=X.Dot(p,t);if(Math.abs(G)<1e-10)S.XU(1/0);else{const H=-(X.Dot(O,t)+q)/G,U=p.scaleInPlace(H);O.addToRef(U,S)}return S}equals(H){return H&&this._x===H._x&&this._y===H._y&&this._z===H._z}equalsWithEpsilon(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.e;return H&&(0,V.WithinEpsilon)(this._x,H._x,O)&&(0,V.WithinEpsilon)(this._y,H._y,O)&&(0,V.WithinEpsilon)(this._z,H._z,O)}equalsToFloats(H,O,S){return this._x===H&&this._y===O&&this._z===S}multiplyInPlace(H){return this._x*=H._x,this._y*=H._y,this._z*=H._z,this._isDirty=!0,this}multiply(H){return this.multiplyByFloats(H._x,H._y,H._z)}multiplyToRef(H,O){return O._x=this._x*H._x,O._y=this._y*H._y,O._z=this._z*H._z,O._isDirty=!0,O}multiplyByFloats(H,O,S){return new X(this._x*H,this._y*O,this._z*S)}divide(H){return new X(this._x/H._x,this._y/H._y,this._z/H._z)}divideToRef(H,O){return O._x=this._x/H._x,O._y=this._y/H._y,O._z=this._z/H._z,O._isDirty=!0,O}divideInPlace(H){return this._x=this._x/H._x,this._y=this._y/H._y,this._z=this._z/H._z,this._isDirty=!0,this}minimizeInPlace(H){return this.minimizeInPlaceFromFloats(H._x,H._y,H._z)}maximizeInPlace(H){return this.maximizeInPlaceFromFloats(H._x,H._y,H._z)}minimizeInPlaceFromFloats(H,O,S){return H<this._x&&(this.x=H),O<this._y&&(this.y=O),S<this._z&&(this.z=S),this}maximizeInPlaceFromFloats(H,O,S){return H>this._x&&(this.x=H),O>this._y&&(this.y=O),S>this._z&&(this.z=S),this}isNonUniformWithinEpsilon(H){const O=Math.abs(this._x),S=Math.abs(this._y);if(!(0,V.WithinEpsilon)(O,S,H))return!0;const t=Math.abs(this._z);return!(0,V.WithinEpsilon)(O,t,H)||!(0,V.WithinEpsilon)(S,t,H)}get isNonUniform(){const H=Math.abs(this._x);if(H!==Math.abs(this._y))return!0;return H!==Math.abs(this._z)}floorToRef(H){return H._x=Math.floor(this._x),H._y=Math.floor(this._y),H._z=Math.floor(this._z),H._isDirty=!0,H}floor(){return new X(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(H){return H._x=this._x-Math.floor(this._x),H._y=this._y-Math.floor(this._y),H._z=this._z-Math.floor(this._z),H._isDirty=!0,H}fract(){return new X(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(H){if("xyz"===(H=H.toLowerCase()))return this;const O=K.eO[0].t(this);return this.x=O[H[0]],this.y=O[H[1]],this.z=O[H[2]],this}rotateByQuaternionToRef(H,O){return H.toRotationMatrix(K.Matrix[0]),X.TransformCoordinatesToRef(this,K.Matrix[0],O),O}rotateByQuaternionAroundPointToRef(H,O,S){return this.subtractToRef(O,K.eO[0]),K.eO[0].rotateByQuaternionToRef(H,K.eO[0]),O.addToRef(K.eO[0],S),S}cross(H){return X.CrossToRef(this,H,new X)}normalizeFromLength(H){return 0===H||1===H?this:this.scaleInPlace(1/H)}normalizeToNew(){return this.normalizeToRef(new X)}normalizeToRef(H){const O=this.length();return 0===O||1===O?(H._x=this._x,H._y=this._y,H._z=this._z,H._isDirty=!0,H):this.scaleToRef(1/O,H)}clone(){return new X(this._x,this._y,this._z)}t(H){return this.jU(H._x,H._y,H._z)}jU(H,O,S){return this._x=H,this._y=O,this._z=S,this._isDirty=!0,this}set(H,O,S){return this.jU(H,O,S)}XU(H){return this._x=this._y=this._z=H,this._isDirty=!0,this}static GetClipFactor(H,O,S,t){const q=X.Dot(H,S);return(q-t)/(q-X.Dot(O,S))}static GetAngleBetweenVectors(H,O,S){const t=H.normalizeToRef(K.eO[1]),q=O.normalizeToRef(K.eO[2]);let p=X.Dot(t,q);p=(0,V.Clamp)(p,-1,1);const G=Math.acos(p),U=K.eO[3];return X.CrossToRef(t,q,U),X.Dot(U,S)>0?isNaN(G)?0:G:isNaN(G)?-Math.PI:-Math.acos(p)}static GetAngleBetweenVectorsOnPlane(H,O,S){K.eO[0].t(H);const t=K.eO[0];K.eO[1].t(O);const q=K.eO[1];K.eO[2].t(S);const p=K.eO[2],G=K.eO[3],U=K.eO[4];t.normalize(),q.normalize(),p.normalize(),X.CrossToRef(p,t,G),X.CrossToRef(G,p,U);const w=Math.atan2(X.Dot(q,G),X.Dot(q,U));return(0,V.NormalizeRadians)(w)}static PitchYawRollToMoveBetweenPointsToRef(H,O,S){const t=b.eO[0];return O.subtractToRef(H,t),S._y=Math.atan2(t.x,t.z)||0,S._x=Math.atan2(Math.sqrt(t.x**2+t.z**2),t.y)||0,S._z=0,S._isDirty=!0,S}static PitchYawRollToMoveBetweenPoints(H,O){const S=X.Zero();return X.PitchYawRollToMoveBetweenPointsToRef(H,O,S)}static SlerpToRef(H,O,S,q){S=(0,V.Clamp)(S,0,1);const p=K.eO[0],G=K.eO[1];p.t(H);const U=p.length();p.normalizeFromLength(U),G.t(O);const w=G.length();G.normalizeFromLength(w);const o=X.Dot(p,G);let h,a;if(o<1-t.e){const H=Math.acos(o),O=1/Math.sin(H);h=Math.sin((1-S)*H)*O,a=Math.sin(S*H)*O}else h=1-S,a=S;return p.scaleInPlace(h),G.scaleInPlace(a),q.t(p).addInPlace(G),q.scaleInPlace((0,V.Lerp)(U,w,S)),q}static SmoothToRef(H,O,S,t,q){return X.SlerpToRef(H,O,0===t?1:S/t,q),q}static KO(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new X(H[O],H[O+1],H[O+2])}static FromFloatArray(H,O){return X.KO(H,O)}static FromArrayToRef(H,O,S){return S._x=H[O],S._y=H[O+1],S._z=H[O+2],S._isDirty=!0,S}static FromFloatArrayToRef(H,O,S){return X.FromArrayToRef(H,O,S)}static FromFloatsToRef(H,O,S,t){return t.jU(H,O,S),t}static Zero(){return new X(0,0,0)}static One(){return new X(1,1,1)}static Up(){return new X(0,1,0)}static get UpReadOnly(){return X._UpReadOnly}static get DownReadOnly(){return X._DownReadOnly}static get RightReadOnly(){return X._RightReadOnly}static get LeftReadOnly(){return X._LeftReadOnly}static get LeftHandedForwardReadOnly(){return X._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return X._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return X._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return X._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return X._ZeroReadOnly}static get OneReadOnly(){return X._OneReadOnly}static Down(){return new X(0,-1,0)}static Forward(){return new X(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new X(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new X(1,0,0)}static Left(){return new X(-1,0,0)}static Random(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new X((0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O))}static RandomToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).jU((0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O))}static TransformCoordinates(H,O){const S=X.Zero();return X.TransformCoordinatesToRef(H,O,S),S}static TransformCoordinatesToRef(H,O,S){return X.TransformCoordinatesFromFloatsToRef(H._x,H._y,H._z,O,S),S}static TransformCoordinatesFromFloatsToRef(H,O,S,t,q){const p=t.m,G=H*p[0]+O*p[4]+S*p[8]+p[12],U=H*p[1]+O*p[5]+S*p[9]+p[13],V=H*p[2]+O*p[6]+S*p[10]+p[14],w=1/(H*p[3]+O*p[7]+S*p[11]+p[15]);return q._x=G*w,q._y=U*w,q._z=V*w,q._isDirty=!0,q}static TransformNormal(H,O){const S=X.Zero();return X.TransformNormalToRef(H,O,S),S}static TransformNormalToRef(H,O,S){return this.TransformNormalFromFloatsToRef(H._x,H._y,H._z,O,S),S}static TransformNormalFromFloatsToRef(H,O,S,t,q){const p=t.m;return q._x=H*p[0]+O*p[4]+S*p[8],q._y=H*p[1]+O*p[5]+S*p[9],q._z=H*p[2]+O*p[6]+S*p[10],q._isDirty=!0,q}static CatmullRom(H,O,S,t,q){const p=q*q,G=q*p,U=.5*(2*O._x+(-H._x+S._x)*q+(2*H._x-5*O._x+4*S._x-t._x)*p+(-H._x+3*O._x-3*S._x+t._x)*G),V=.5*(2*O._y+(-H._y+S._y)*q+(2*H._y-5*O._y+4*S._y-t._y)*p+(-H._y+3*O._y-3*S._y+t._y)*G),w=.5*(2*O._z+(-H._z+S._z)*q+(2*H._z-5*O._z+4*S._z-t._z)*p+(-H._z+3*O._z-3*S._z+t._z)*G);return new X(U,V,w)}static Clamp(H,O,S){const t=new X;return X.ClampToRef(H,O,S,t),t}static ClampToRef(H,O,S,t){let q=H._x;q=q>S._x?S._x:q,q=q<O._x?O._x:q;let p=H._y;p=p>S._y?S._y:p,p=p<O._y?O._y:p;let G=H._z;return G=G>S._z?S._z:G,G=G<O._z?O._z:G,t.jU(q,p,G),t}static CheckExtends(H,O,S){O.minimizeInPlace(H),S.maximizeInPlace(H)}static Hermite(H,O,S,t,q){const p=q*q,G=q*p,U=2*G-3*p+1,V=-2*G+3*p,w=G-2*p+q,o=G-p,h=H._x*U+S._x*V+O._x*w+t._x*o,a=H._y*U+S._y*V+O._y*w+t._y*o,j=H._z*U+S._z*V+O._z*w+t._z*o;return new X(h,a,j)}static Hermite1stDerivative(H,O,S,t,q){const p=new X;return this.Hermite1stDerivativeToRef(H,O,S,t,q,p),p}static Hermite1stDerivativeToRef(H,O,S,t,q,p){const G=q*q;return p._x=6*(G-q)*H._x+(3*G-4*q+1)*O._x+6*(-G+q)*S._x+(3*G-2*q)*t._x,p._y=6*(G-q)*H._y+(3*G-4*q+1)*O._y+6*(-G+q)*S._y+(3*G-2*q)*t._y,p._z=6*(G-q)*H._z+(3*G-4*q+1)*O._z+6*(-G+q)*S._z+(3*G-2*q)*t._z,p._isDirty=!0,p}static Lerp(H,O,S){const t=new X(0,0,0);return X.LerpToRef(H,O,S,t),t}static LerpToRef(H,O,S,t){return t._x=H._x+(O._x-H._x)*S,t._y=H._y+(O._y-H._y)*S,t._z=H._z+(O._z-H._z)*S,t._isDirty=!0,t}static Dot(H,O){return H._x*O._x+H._y*O._y+H._z*O._z}dot(H){return this._x*H._x+this._y*H._y+this._z*H._z}static Cross(H,O){const S=new X;return X.CrossToRef(H,O,S),S}static CrossToRef(H,O,S){const t=H._y*O._z-H._z*O._y,q=H._z*O._x-H._x*O._z,p=H._x*O._y-H._y*O._x;return S.jU(t,q,p),S}static Normalize(H){const O=X.Zero();return X.NormalizeToRef(H,O),O}static NormalizeToRef(H,O){return H.normalizeToRef(O),O}static Project(H,O,S,t){const q=new X;return X.ProjectToRef(H,O,S,t,q),q}static ProjectToRef(H,O,S,t,q){var p;const G=t.width,V=t.height,w=t.x,o=t.y,h=K.Matrix[1],a=null===(p=U.c.LastCreatedEngine)||void 0===p?void 0:p.isNDCHalfZRange,j=a?1:.5,e=a?0:.5;T.FromValuesToRef(G/2,0,0,0,0,-V/2,0,0,0,0,j,0,w+G/2,V/2+o,e,1,h);const E=K.Matrix[0];return O.multiplyToRef(S,E),E.multiplyToRef(h,E),X.TransformCoordinatesToRef(H,E,q),q}static Reflect(H,O){return this.ReflectToRef(H,O,new X)}static ReflectToRef(H,O,S){const t=b.eO[0];return t.t(O).scaleInPlace(2*X.Dot(H,O)),S.t(H).Mo(t)}static _UnprojectFromInvertedMatrixToRef(H,O,S){X.TransformCoordinatesToRef(H,O,S);const t=O.m,q=H._x*t[3]+H._y*t[7]+H._z*t[11]+t[15];return(0,V.WithinEpsilon)(q,1)&&S.scaleInPlace(1/q),S}static UnprojectFromTransform(H,O,S,t,q){return this.Unproject(H,O,S,t,q,T.IdentityReadOnly)}static Unproject(H,O,S,t,q,p){const G=new X;return X.UnprojectToRef(H,O,S,t,q,p,G),G}static UnprojectToRef(H,O,S,t,q,p,G){return X.UnprojectFloatsToRef(H._x,H._y,H._z,O,S,t,q,p,G),G}static UnprojectFloatsToRef(H,O,S,t,q,p,G,V,w){var o;const h=K.Matrix[0];p.multiplyToRef(G,h),h.multiplyToRef(V,h),h.invert();const a=K.eO[0];return a.x=H/t*2-1,a.y=-(O/q*2-1),null!==(o=U.c.LastCreatedEngine)&&void 0!==o&&o.isNDCHalfZRange?a.z=S:a.z=2*S-1,X._UnprojectFromInvertedMatrixToRef(a,h,w),w}static Minimize(H,O){const S=new X;return S.t(H),S.minimizeInPlace(O),S}static Maximize(H,O){const S=new X;return S.t(H),S.maximizeInPlace(O),S}static Distance(H,O){return Math.sqrt(X.DistanceSquared(H,O))}static DistanceSquared(H,O){const S=H._x-O._x,t=H._y-O._y,q=H._z-O._z;return S*S+t*t+q*q}static ProjectOnTriangleToRef(H,O,S,q,p){const G=K.eO[0],U=K.eO[1],w=K.eO[2],o=K.eO[3],h=K.eO[4];S.subtractToRef(O,G),q.subtractToRef(O,U),q.subtractToRef(S,w);const a=G.length(),j=U.length(),e=w.length();if(a<t.e||j<t.e||e<t.e)return p.t(O),X.Distance(H,O);H.subtractToRef(O,h),X.CrossToRef(G,U,o);const E=o.length();if(E<t.e)return p.t(O),X.Distance(H,O);o.normalizeFromLength(E);let y=h.length();if(y<t.e)return p.t(O),0;h.normalizeFromLength(y);const T=X.Dot(o,h),b=K.eO[5],D=K.eO[6];b.t(o).scaleInPlace(-y*T),D.t(H).addInPlace(b);const F=K.eO[4],Y=K.eO[5],l=K.eO[7],d=K.eO[8];F.t(G).scaleInPlace(1/a),d.t(U).scaleInPlace(1/j),F.addInPlace(d).scaleInPlace(-1),Y.t(G).scaleInPlace(-1/a),d.t(w).scaleInPlace(1/e),Y.addInPlace(d).scaleInPlace(-1),l.t(w).scaleInPlace(-1/e),d.t(U).scaleInPlace(-1/j),l.addInPlace(d).scaleInPlace(-1);const v=K.eO[9];let z;v.t(D).Mo(O),X.CrossToRef(F,v,d),z=X.Dot(d,o);const m=z;v.t(D).Mo(S),X.CrossToRef(Y,v,d),z=X.Dot(d,o);const r=z;v.t(D).Mo(q),X.CrossToRef(l,v,d),z=X.Dot(d,o);const W=z,g=K.eO[10];let N,x;m>0&&r<0?(g.t(G),N=O,x=S):r>0&&W<0?(g.t(w),N=S,x=q):(g.t(U).scaleInPlace(-1),N=q,x=O);const k=K.eO[9],A=K.eO[4];N.subtractToRef(D,d),x.subtractToRef(D,k),X.CrossToRef(d,k,A);if(!(X.Dot(A,o)<0))return p.t(D),Math.abs(y*T);const u=K.eO[5];X.CrossToRef(g,A,u),u.normalize();const J=K.eO[9];J.t(N).Mo(D);const P=J.length();if(P<t.e)return p.t(N),X.Distance(H,N);J.normalizeFromLength(P);const f=X.Dot(u,J),c=K.eO[7];c.t(D).addInPlace(u.scaleInPlace(P*f)),d.t(c).Mo(N),y=g.length(),g.normalizeFromLength(y);let R=X.Dot(d,g)/Math.max(y,t.e);return R=(0,V.Clamp)(R,0,1),c.t(N).addInPlace(g.scaleInPlace(R*y)),p.t(c),X.Distance(H,c)}static Center(H,O){return X.CenterToRef(H,O,X.Zero())}static CenterToRef(H,O,S){return S.jU((H._x+O._x)/2,(H._y+O._y)/2,(H._z+O._z)/2)}static RotationFromAxis(H,O,S){const t=new X;return X.RotationFromAxisToRef(H,O,S,t),t}static RotationFromAxisToRef(H,O,S,t){const q=K.Quaternion[0];return y.RotationQuaternionFromAxisToRef(H,O,S,q),q.toEulerAnglesToRef(t),t}}X._V8PerformanceHack=new X(.5,.5,.5),X._UpReadOnly=X.Up(),X._DownReadOnly=X.Down(),X._LeftHandedForwardReadOnly=X.Forward(!1),X._RightHandedForwardReadOnly=X.Forward(!0),X._LeftHandedBackwardReadOnly=X.Backward(!1),X._RightHandedBackwardReadOnly=X.Backward(!0),X._RightReadOnly=X.Right(),X._LeftReadOnly=X.Left(),X._ZeroReadOnly=X.Zero(),X._OneReadOnly=X.One(),Object.defineProperties(X.prototype,{dimension:{value:[3]},rank:{value:1}});class E{get x(){return this._x}set x(H){this._x=H,this._isDirty=!0}get y(){return this._y}set y(H){this._y=H,this._isDirty=!0}get z(){return this._z}set z(H){this._z=H,this._isDirty=!0}get w(){return this._w}set w(H){this._w=H,this._isDirty=!0}constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=H,this._y=O,this._z=S,this._w=t}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let H=j(this._x);return H=397*H^j(this._y),H=397*H^j(this._z),H=397*H^j(this._w),H}pU(){return[this._x,this._y,this._z,this._w]}toArray(H,O){return void 0===O&&(O=0),H[O]=this._x,H[O+1]=this._y,H[O+2]=this._z,H[O+3]=this._w,this}jS(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(H,O,this),this}addInPlace(H){return this.x+=H._x,this.y+=H._y,this.z+=H._z,this.w+=H._w,this}addInPlaceFromFloats(H,O,S,t){return this.x+=H,this.y+=O,this.z+=S,this.w+=t,this}add(H){return new E(this._x+H.x,this._y+H.y,this._z+H.z,this._w+H.w)}addToRef(H,O){return O.x=this._x+H.x,O.y=this._y+H.y,O.z=this._z+H.z,O.w=this._w+H.w,O}Mo(H){return this.x-=H.x,this.y-=H.y,this.z-=H.z,this.w-=H.w,this}XO(H){return new E(this._x-H.x,this._y-H.y,this._z-H.z,this._w-H.w)}subtractToRef(H,O){return O.x=this._x-H.x,O.y=this._y-H.y,O.z=this._z-H.z,O.w=this._w-H.w,O}subtractFromFloats(H,O,S,t){return new E(this._x-H,this._y-O,this._z-S,this._w-t)}subtractFromFloatsToRef(H,O,S,t,q){return q.x=this._x-H,q.y=this._y-O,q.z=this._z-S,q.w=this._w-t,q}negate(){return new E(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(H){return H.x=-this._x,H.y=-this._y,H.z=-this._z,H.w=-this._w,H}scaleInPlace(H){return this.x*=H,this.y*=H,this.z*=H,this.w*=H,this}scale(H){return new E(this._x*H,this._y*H,this._z*H,this._w*H)}scaleToRef(H,O){return O.x=this._x*H,O.y=this._y*H,O.z=this._z*H,O.w=this._w*H,O}scaleAndAddToRef(H,O){return O.x+=this._x*H,O.y+=this._y*H,O.z+=this._z*H,O.w+=this._w*H,O}equals(H){return H&&this._x===H.x&&this._y===H.y&&this._z===H.z&&this._w===H.w}equalsWithEpsilon(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.e;return H&&(0,V.WithinEpsilon)(this._x,H.x,O)&&(0,V.WithinEpsilon)(this._y,H.y,O)&&(0,V.WithinEpsilon)(this._z,H.z,O)&&(0,V.WithinEpsilon)(this._w,H.w,O)}equalsToFloats(H,O,S,t){return this._x===H&&this._y===O&&this._z===S&&this._w===t}multiplyInPlace(H){return this.x*=H.x,this.y*=H.y,this.z*=H.z,this.w*=H.w,this}multiply(H){return new E(this._x*H.x,this._y*H.y,this._z*H.z,this._w*H.w)}multiplyToRef(H,O){return O.x=this._x*H.x,O.y=this._y*H.y,O.z=this._z*H.z,O.w=this._w*H.w,O}multiplyByFloats(H,O,S,t){return new E(this._x*H,this._y*O,this._z*S,this._w*t)}divide(H){return new E(this._x/H.x,this._y/H.y,this._z/H.z,this._w/H.w)}divideToRef(H,O){return O.x=this._x/H.x,O.y=this._y/H.y,O.z=this._z/H.z,O.w=this._w/H.w,O}divideInPlace(H){return this.divideToRef(H,this)}minimizeInPlace(H){return H.x<this._x&&(this.x=H.x),H.y<this._y&&(this.y=H.y),H.z<this._z&&(this.z=H.z),H.w<this._w&&(this.w=H.w),this}maximizeInPlace(H){return H.x>this._x&&(this.x=H.x),H.y>this._y&&(this.y=H.y),H.z>this._z&&(this.z=H.z),H.w>this._w&&(this.w=H.w),this}minimizeInPlaceFromFloats(H,O,S,t){return this.x=Math.min(H,this._x),this.y=Math.min(O,this._y),this.z=Math.min(S,this._z),this.w=Math.min(t,this._w),this}maximizeInPlaceFromFloats(H,O,S,t){return this.x=Math.max(H,this._x),this.y=Math.max(O,this._y),this.z=Math.max(S,this._z),this.w=Math.max(t,this._w),this}floorToRef(H){return H.x=Math.floor(this._x),H.y=Math.floor(this._y),H.z=Math.floor(this._z),H.w=Math.floor(this._w),H}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(H){return H.x=this._x-Math.floor(this._x),H.y=this._y-Math.floor(this._y),H.z=this._z-Math.floor(this._z),H.w=this._w-Math.floor(this._w),H}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(H){return 0===H||1===H?this:this.scaleInPlace(1/H)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(H){const O=this.length();return 0===O||1===O?(H.x=this._x,H.y=this._y,H.z=this._z,H.w=this._w,H):this.scaleToRef(1/O,H)}toVector3(){return new X(this._x,this._y,this._z)}clone(){return new E(this._x,this._y,this._z,this._w)}t(H){return this.x=H.x,this.y=H.y,this.z=H.z,this.w=H.w,this}jU(H,O,S,t){return this.x=H,this.y=O,this.z=S,this.w=t,this}set(H,O,S,t){return this.jU(H,O,S,t)}XU(H){return this.x=this.y=this.z=this.w=H,this}dot(H){return this._x*H.x+this._y*H.y+this._z*H.z+this._w*H.w}static KO(H,O){return O||(O=0),new E(H[O],H[O+1],H[O+2],H[O+3])}static FromArrayToRef(H,O,S){return S.x=H[O],S.y=H[O+1],S.z=H[O+2],S.w=H[O+3],S}static FromFloatArrayToRef(H,O,S){return E.FromArrayToRef(H,O,S),S}static FromFloatsToRef(H,O,S,t,q){return q.x=H,q.y=O,q.z=S,q.w=t,q}static Zero(){return new E(0,0,0,0)}static One(){return new E(1,1,1,1)}static Random(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O))}static RandomToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,S=arguments.length>2?arguments[2]:void 0;return S.x=(0,V.RandomRange)(H,O),S.y=(0,V.RandomRange)(H,O),S.z=(0,V.RandomRange)(H,O),S.w=(0,V.RandomRange)(H,O),S}static Clamp(H,O,S){return E.ClampToRef(H,O,S,new E)}static ClampToRef(H,O,S,t){return t.x=(0,V.Clamp)(H.x,O.x,S.x),t.y=(0,V.Clamp)(H.y,O.y,S.y),t.z=(0,V.Clamp)(H.z,O.z,S.z),t.w=(0,V.Clamp)(H.w,O.w,S.w),t}static CheckExtends(H,O,S){O.minimizeInPlace(H),S.maximizeInPlace(H)}static get ZeroReadOnly(){return E._ZeroReadOnly}static Normalize(H){return E.NormalizeToRef(H,new E)}static NormalizeToRef(H,O){return H.normalizeToRef(O),O}static Minimize(H,O){const S=new E;return S.t(H),S.minimizeInPlace(O),S}static Maximize(H,O){const S=new E;return S.t(H),S.maximizeInPlace(O),S}static Distance(H,O){return Math.sqrt(E.DistanceSquared(H,O))}static DistanceSquared(H,O){const S=H.x-O.x,t=H.y-O.y,q=H.z-O.z,p=H.w-O.w;return S*S+t*t+q*q+p*p}static Center(H,O){return E.CenterToRef(H,O,new E)}static CenterToRef(H,O,S){return S.x=(H.x+O.x)/2,S.y=(H.y+O.y)/2,S.z=(H.z+O.z)/2,S.w=(H.w+O.w)/2,S}static TransformCoordinates(H,O){return E.TransformCoordinatesToRef(H,O,new E)}static TransformCoordinatesToRef(H,O,S){return E.TransformCoordinatesFromFloatsToRef(H._x,H._y,H._z,O,S),S}static TransformCoordinatesFromFloatsToRef(H,O,S,t,q){const p=t.m,G=H*p[0]+O*p[4]+S*p[8]+p[12],U=H*p[1]+O*p[5]+S*p[9]+p[13],V=H*p[2]+O*p[6]+S*p[10]+p[14],w=H*p[3]+O*p[7]+S*p[11]+p[15];return q.x=G,q.y=U,q.z=V,q.w=w,q}static TransformNormal(H,O){return E.TransformNormalToRef(H,O,new E)}static TransformNormalToRef(H,O,S){const t=O.m,q=H.x*t[0]+H.y*t[4]+H.z*t[8],p=H.x*t[1]+H.y*t[5]+H.z*t[9],G=H.x*t[2]+H.y*t[6]+H.z*t[10];return S.x=q,S.y=p,S.z=G,S.w=H.w,S}static TransformNormalFromFloatsToRef(H,O,S,t,q,p){const G=q.m;return p.x=H*G[0]+O*G[4]+S*G[8],p.y=H*G[1]+O*G[5]+S*G[9],p.z=H*G[2]+O*G[6]+S*G[10],p.w=t,p}static FromVector3(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(H._x,H._y,H._z,O)}static Dot(H,O){return H.x*O.x+H.y*O.y+H.z*O.z+H.w*O.w}}E._V8PerformanceHack=new E(.5,.5,.5,.5),E._ZeroReadOnly=E.Zero(),Object.defineProperties(E.prototype,{dimension:{value:[4]},rank:{value:1}});class y{get x(){return this._x}set x(H){this._x=H,this._isDirty=!0}get y(){return this._y}set y(H){this._y=H,this._isDirty=!0}get z(){return this._z}set z(H){this._z=H,this._isDirty=!0}get w(){return this._w}set w(H){this._w=H,this._isDirty=!0}constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=H,this._y=O,this._z=S,this._w=t}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let H=j(this._x);return H=397*H^j(this._y),H=397*H^j(this._z),H=397*H^j(this._w),H}pU(){return[this._x,this._y,this._z,this._w]}toArray(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[O]=this._x,H[O+1]=this._y,H[O+2]=this._z,H[O+3]=this._w,this}jS(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y.FromArrayToRef(H,O,this)}equals(H){return H&&this._x===H._x&&this._y===H._y&&this._z===H._z&&this._w===H._w}equalsWithEpsilon(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.e;return H&&(0,V.WithinEpsilon)(this._x,H._x,O)&&(0,V.WithinEpsilon)(this._y,H._y,O)&&(0,V.WithinEpsilon)(this._z,H._z,O)&&(0,V.WithinEpsilon)(this._w,H._w,O)}isApprox(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.e;return H&&((0,V.WithinEpsilon)(this._x,H._x,O)&&(0,V.WithinEpsilon)(this._y,H._y,O)&&(0,V.WithinEpsilon)(this._z,H._z,O)&&(0,V.WithinEpsilon)(this._w,H._w,O)||(0,V.WithinEpsilon)(this._x,-H._x,O)&&(0,V.WithinEpsilon)(this._y,-H._y,O)&&(0,V.WithinEpsilon)(this._z,-H._z,O)&&(0,V.WithinEpsilon)(this._w,-H._w,O))}clone(){return new y(this._x,this._y,this._z,this._w)}t(H){return this._x=H._x,this._y=H._y,this._z=H._z,this._w=H._w,this._isDirty=!0,this}jU(H,O,S,t){return this._x=H,this._y=O,this._z=S,this._w=t,this._isDirty=!0,this}set(H,O,S,t){return this.jU(H,O,S,t)}XU(H){return this.jU(H,H,H,H)}add(H){return new y(this._x+H._x,this._y+H._y,this._z+H._z,this._w+H._w)}addInPlace(H){return this._x+=H._x,this._y+=H._y,this._z+=H._z,this._w+=H._w,this._isDirty=!0,this}addToRef(H,O){return O._x=this._x+H._x,O._y=this._y+H._y,O._z=this._z+H._z,O._w=this._w+H._w,O._isDirty=!0,O}addInPlaceFromFloats(H,O,S,t){return this._x+=H,this._y+=O,this._z+=S,this._w+=t,this._isDirty=!0,this}subtractToRef(H,O){return O._x=this._x-H._x,O._y=this._y-H._y,O._z=this._z-H._z,O._w=this._w-H._w,O._isDirty=!0,O}subtractFromFloats(H,O,S,t){return this.subtractFromFloatsToRef(H,O,S,t,new y)}subtractFromFloatsToRef(H,O,S,t,q){return q._x=this._x-H,q._y=this._y-O,q._z=this._z-S,q._w=this._w-t,q._isDirty=!0,q}XO(H){return new y(this._x-H._x,this._y-H._y,this._z-H._z,this._w-H._w)}Mo(H){return this._x-=H._x,this._y-=H._y,this._z-=H._z,this._w-=H._w,this._isDirty=!0,this}scale(H){return new y(this._x*H,this._y*H,this._z*H,this._w*H)}scaleToRef(H,O){return O._x=this._x*H,O._y=this._y*H,O._z=this._z*H,O._w=this._w*H,O._isDirty=!0,O}scaleInPlace(H){return this._x*=H,this._y*=H,this._z*=H,this._w*=H,this._isDirty=!0,this}scaleAndAddToRef(H,O){return O._x+=this._x*H,O._y+=this._y*H,O._z+=this._z*H,O._w+=this._w*H,O._isDirty=!0,O}multiply(H){const O=new y(0,0,0,1);return this.multiplyToRef(H,O),O}multiplyToRef(H,O){const S=this._x*H._w+this._y*H._z-this._z*H._y+this._w*H._x,t=-this._x*H._z+this._y*H._w+this._z*H._x+this._w*H._y,q=this._x*H._y-this._y*H._x+this._z*H._w+this._w*H._z,p=-this._x*H._x-this._y*H._y-this._z*H._z+this._w*H._w;return O.jU(S,t,q,p),O}multiplyInPlace(H){return this.multiplyToRef(H,this)}multiplyByFloats(H,O,S,t){return this._x*=H,this._y*=O,this._z*=S,this._w*=t,this._isDirty=!0,this}divide(H){throw new ReferenceError("Can not divide a quaternion")}divideToRef(H,O){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(H){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new y)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(H){return H._x=-this._x,H._y=-this._y,H._z=-this._z,H._w=-this._w,H._isDirty=!0,H}equalsToFloats(H,O,S,t){return this._x===H&&this._y===O&&this._z===S&&this._w===t}floorToRef(H){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(H){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(H){return H.jU(-this._x,-this._y,-this._z,this._w),H}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new y(-this._x,-this._y,-this._z,this._w)}invert(){const H=this.conjugate(),O=this.lengthSquared();return 0==O||1==O||H.scaleInPlace(1/O),H}invertInPlace(){this.conjugateInPlace();const H=this.lengthSquared();return 0==H||1==H||this.scaleInPlace(1/H),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(H){return 0===H||1===H?this:this.scaleInPlace(1/H)}normalizeToNew(){const H=new y(0,0,0,1);return this.normalizeToRef(H),H}normalizeToRef(H){const O=this.length();return 0===O||1===O?H.jU(this._x,this._y,this._z,this._w):this.scaleToRef(1/O,H)}toEulerAngles(){const H=X.Zero();return this.toEulerAnglesToRef(H),H}toEulerAnglesToRef(H){const O=this._z,S=this._x,t=this._y,q=this._w,p=t*O-S*q,G=.4999999;if(p<-G)H._y=2*Math.atan2(t,q),H._x=Math.PI/2,H._z=0,H._isDirty=!0;else if(p>G)H._y=2*Math.atan2(t,q),H._x=-Math.PI/2,H._z=0,H._isDirty=!0;else{const G=q*q,U=O*O,V=S*S,w=t*t;H._z=Math.atan2(2*(S*t+O*q),-U-V+w+G),H._x=Math.asin(-2*p),H._y=Math.atan2(2*(O*S+t*q),U-V-w+G),H._isDirty=!0}return H}toAlphaBetaGammaToRef(H){const O=this._z,S=this._x,t=this._y,q=this._w,p=Math.sqrt(S*S+t*t),G=Math.sqrt(O*O+q*q),U=2*Math.atan2(p,G),V=2*Math.atan2(O,q),w=2*Math.atan2(t,S),o=(V+w)/2,h=(V-w)/2;return H.set(h,U,o),H}toRotationMatrix(H){return T.FromQuaternionToRef(this,H),H}fromRotationMatrix(H){return y.FromRotationMatrixToRef(H,this),this}dot(H){return this._x*H._x+this._y*H._y+this._z*H._z+this._w*H._w}toAxisAngle(){const H=X.Zero();return{axis:H,angle:this.toAxisAngleToRef(H)}}toAxisAngleToRef(H){let O=0;const S=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),t=this._w;return S>0?(O=2*Math.atan2(S,t),H.set(this._x/S,this._y/S,this._z/S)):(O=0,H.set(1,0,0)),O}static FromRotationMatrix(H){const O=new y;return y.FromRotationMatrixToRef(H,O),O}static FromRotationMatrixToRef(H,O){const S=H.m,t=S[0],q=S[4],p=S[8],G=S[1],U=S[5],V=S[9],w=S[2],o=S[6],h=S[10],a=t+U+h;let j;return a>0?(j=.5/Math.sqrt(a+1),O._w=.25/j,O._x=(o-V)*j,O._y=(p-w)*j,O._z=(G-q)*j,O._isDirty=!0):t>U&&t>h?(j=2*Math.sqrt(1+t-U-h),O._w=(o-V)/j,O._x=.25*j,O._y=(q+G)/j,O._z=(p+w)/j,O._isDirty=!0):U>h?(j=2*Math.sqrt(1+U-t-h),O._w=(p-w)/j,O._x=(q+G)/j,O._y=.25*j,O._z=(V+o)/j,O._isDirty=!0):(j=2*Math.sqrt(1+h-t-U),O._w=(G-q)/j,O._x=(p+w)/j,O._y=(V+o)/j,O._z=.25*j,O._isDirty=!0),O}static Dot(H,O){return H._x*O._x+H._y*O._y+H._z*O._z+H._w*O._w}static AreClose(H,O){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const t=y.Dot(H,O);return 1-t*t<=S}static SmoothToRef(H,O,S,t,q){let p=0===t?1:S/t;return p=(0,V.Clamp)(p,0,1),y.SlerpToRef(H,O,p,q),q}static Zero(){return new y(0,0,0,0)}static Inverse(H){return new y(-H._x,-H._y,-H._z,H._w)}static InverseToRef(H,O){return O.set(-H._x,-H._y,-H._z,H._w),O}static Identity(){return new y(0,0,0,1)}static IsIdentity(H){return H&&0===H._x&&0===H._y&&0===H._z&&1===H._w}static RotationAxis(H,O){return y.RotationAxisToRef(H,O,new y)}static RotationAxisToRef(H,O,S){S._w=Math.cos(O/2);const t=Math.sin(O/2)/H.length();return S._x=H._x*t,S._y=H._y*t,S._z=H._z*t,S._isDirty=!0,S}static KO(H,O){return O||(O=0),new y(H[O],H[O+1],H[O+2],H[O+3])}static FromArrayToRef(H,O,S){return S._x=H[O],S._y=H[O+1],S._z=H[O+2],S._w=H[O+3],S._isDirty=!0,S}static FromFloatsToRef(H,O,S,t,q){return q.jU(H,O,S,t),q}static FromEulerAngles(H,O,S){const t=new y;return y.RotationYawPitchRollToRef(O,H,S,t),t}static FromEulerAnglesToRef(H,O,S,t){return y.RotationYawPitchRollToRef(O,H,S,t),t}static FromEulerVector(H){const O=new y;return y.RotationYawPitchRollToRef(H._y,H._x,H._z,O),O}static FromEulerVectorToRef(H,O){return y.RotationYawPitchRollToRef(H._y,H._x,H._z,O),O}static FromUnitVectorsToRef(H,O,S){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.e;const p=X.Dot(H,O)+1;return p<q?Math.abs(H.x)>Math.abs(H.z)?S.set(-H.y,H.x,0,0):S.set(0,-H.z,H.y,0):(X.CrossToRef(H,O,b.eO[0]),S.set(b.eO[0].x,b.eO[0].y,b.eO[0].z,p)),S.normalize()}static RotationYawPitchRoll(H,O,S){const t=new y;return y.RotationYawPitchRollToRef(H,O,S,t),t}static RotationYawPitchRollToRef(H,O,S,t){const q=.5*S,p=.5*O,G=.5*H,U=Math.sin(q),V=Math.cos(q),w=Math.sin(p),o=Math.cos(p),h=Math.sin(G),a=Math.cos(G);return t._x=a*w*V+h*o*U,t._y=h*o*V-a*w*U,t._z=a*o*U-h*w*V,t._w=a*o*V+h*w*U,t._isDirty=!0,t}static RotationAlphaBetaGamma(H,O,S){const t=new y;return y.RotationAlphaBetaGammaToRef(H,O,S,t),t}static RotationAlphaBetaGammaToRef(H,O,S,t){const q=.5*(S+H),p=.5*(S-H),G=.5*O;return t._x=Math.cos(p)*Math.sin(G),t._y=Math.sin(p)*Math.sin(G),t._z=Math.sin(q)*Math.cos(G),t._w=Math.cos(q)*Math.cos(G),t._isDirty=!0,t}static RotationQuaternionFromAxis(H,O,S){const t=new y(0,0,0,0);return y.RotationQuaternionFromAxisToRef(H,O,S,t),t}static RotationQuaternionFromAxisToRef(H,O,S,t){const q=K.Matrix[0];return H=H.normalizeToRef(K.eO[0]),O=O.normalizeToRef(K.eO[1]),S=S.normalizeToRef(K.eO[2]),T.FromXYZAxesToRef(H,O,S,q),y.FromRotationMatrixToRef(q,t),t}static FromLookDirectionLH(H,O){const S=new y;return y.FromLookDirectionLHToRef(H,O,S),S}static FromLookDirectionLHToRef(H,O,S){const t=K.Matrix[0];return T.LookDirectionLHToRef(H,O,t),y.FromRotationMatrixToRef(t,S),S}static FromLookDirectionRH(H,O){const S=new y;return y.FromLookDirectionRHToRef(H,O,S),S}static FromLookDirectionRHToRef(H,O,S){const t=K.Matrix[0];return T.LookDirectionRHToRef(H,O,t),y.FromRotationMatrixToRef(t,S)}static Slerp(H,O,S){const t=y.Identity();return y.SlerpToRef(H,O,S,t),t}static SlerpToRef(H,O,S,t){let q,p,G=H._x*O._x+H._y*O._y+H._z*O._z+H._w*O._w,U=!1;if(G<0&&(U=!0,G=-G),G>.999999)p=1-S,q=U?-S:S;else{const H=Math.acos(G),O=1/Math.sin(H);p=Math.sin((1-S)*H)*O,q=U?-Math.sin(S*H)*O:Math.sin(S*H)*O}return t._x=p*H._x+q*O._x,t._y=p*H._y+q*O._y,t._z=p*H._z+q*O._z,t._w=p*H._w+q*O._w,t._isDirty=!0,t}static Hermite(H,O,S,t,q){const p=q*q,G=q*p,U=2*G-3*p+1,V=-2*G+3*p,w=G-2*p+q,o=G-p,h=H._x*U+S._x*V+O._x*w+t._x*o,a=H._y*U+S._y*V+O._y*w+t._y*o,j=H._z*U+S._z*V+O._z*w+t._z*o,e=H._w*U+S._w*V+O._w*w+t._w*o;return new y(h,a,j,e)}static Hermite1stDerivative(H,O,S,t,q){const p=new y;return this.Hermite1stDerivativeToRef(H,O,S,t,q,p),p}static Hermite1stDerivativeToRef(H,O,S,t,q,p){const G=q*q;return p._x=6*(G-q)*H._x+(3*G-4*q+1)*O._x+6*(-G+q)*S._x+(3*G-2*q)*t._x,p._y=6*(G-q)*H._y+(3*G-4*q+1)*O._y+6*(-G+q)*S._y+(3*G-2*q)*t._y,p._z=6*(G-q)*H._z+(3*G-4*q+1)*O._z+6*(-G+q)*S._z+(3*G-2*q)*t._z,p._w=6*(G-q)*H._w+(3*G-4*q+1)*O._w+6*(-G+q)*S._w+(3*G-2*q)*t._w,p._isDirty=!0,p}static Normalize(H){const O=y.Zero();return y.NormalizeToRef(H,O),O}static NormalizeToRef(H,O){return H.normalizeToRef(O),O}static Clamp(H,O,S){const t=new y;return y.ClampToRef(H,O,S,t),t}static ClampToRef(H,O,S,t){return t.jU((0,V.Clamp)(H.x,O.x,S.x),(0,V.Clamp)(H.y,O.y,S.y),(0,V.Clamp)(H.z,O.z,S.z),(0,V.Clamp)(H.w,O.w,S.w))}static Random(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new y((0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O))}static RandomToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).jU((0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O),(0,V.RandomRange)(H,O))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(H,O){return Math.sqrt(y.DistanceSquared(H,O))}static DistanceSquared(H,O){const S=H.x-O.x,t=H.y-O.y,q=H.z-O.z,p=H.w-O.w;return S*S+t*t+q*q+p*p}static Center(H,O){return y.CenterToRef(H,O,y.Zero())}static CenterToRef(H,O,S){return S.jU((H.x+O.x)/2,(H.y+O.y)/2,(H.z+O.z)/2,(H.w+O.w)/2)}}y._V8PerformanceHack=new y(.5,.5,.5,.5),Object.defineProperties(y.prototype,{dimension:{value:[4]},rank:{value:1}});class T{static get Use64Bits(){return G.d.MatrixUse64Bits}get m(){return this.ip}markAsUpdated(){this.updateFlag=w._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(H){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1],S=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=H,this._isIdentity3x2=H||S,this._isIdentityDirty=!this._isIdentity&&O,this._isIdentity3x2Dirty=!this._isIdentity3x2&&t}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,G.d.MatrixTrackPrecisionChange&&G.d.MatrixTrackedMatrices.push(this),this.ip=new G.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const H=this.ip;this._isIdentity=1===H[0]&&0===H[1]&&0===H[2]&&0===H[3]&&0===H[4]&&1===H[5]&&0===H[6]&&0===H[7]&&0===H[8]&&0===H[9]&&1===H[10]&&0===H[11]&&0===H[12]&&0===H[13]&&0===H[14]&&1===H[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ip[0]||1!==this.ip[5]||1!==this.ip[15]||0!==this.ip[1]||0!==this.ip[2]||0!==this.ip[3]||0!==this.ip[4]||0!==this.ip[6]||0!==this.ip[7]||0!==this.ip[8]||0!==this.ip[9]||0!==this.ip[10]||0!==this.ip[11]||0!==this.ip[12]||0!==this.ip[13]||0!==this.ip[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const H=this.ip,O=H[0],S=H[1],t=H[2],q=H[3],p=H[4],G=H[5],U=H[6],V=H[7],w=H[8],o=H[9],h=H[10],a=H[11],j=H[12],e=H[13],X=H[14],E=H[15],y=h*E-X*a,T=o*E-e*a,K=o*X-e*h,b=w*E-j*a,D=w*X-h*j,F=w*e-j*o;return O*+(G*y-U*T+V*K)+S*-(p*y-U*b+V*D)+t*+(p*T-G*b+V*F)+q*-(p*K-G*D+U*F)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!H)return this.ip;const S=this.ip;for(let t=0;t<16;t++)H[O+t]=S[t];return this}pU(){return this.ip}jS(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return T.FromArrayToRef(H,O,this)}jU(){for(var H=arguments.length,O=new Array(H),S=0;S<H;S++)O[S]=arguments[S];return T.FromArrayToRef(O,0,this)}set(){const H=this.ip;for(let O=0;O<16;O++)H[O]=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}XU(H){const O=this.ip;for(let S=0;S<16;S++)O[S]=H;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return T.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(H){const O=new T;return this.addToRef(H,O),O}addToRef(H,O){const S=this.ip,t=O.ip,q=H.m;for(let p=0;p<16;p++)t[p]=S[p]+q[p];return O.markAsUpdated(),O}addToSelf(H){const O=this.ip,S=H.m;return O[0]+=S[0],O[1]+=S[1],O[2]+=S[2],O[3]+=S[3],O[4]+=S[4],O[5]+=S[5],O[6]+=S[6],O[7]+=S[7],O[8]+=S[8],O[9]+=S[9],O[10]+=S[10],O[11]+=S[11],O[12]+=S[12],O[13]+=S[13],O[14]+=S[14],O[15]+=S[15],this.markAsUpdated(),this}addInPlace(H){const O=this.ip,S=H.m;for(let t=0;t<16;t++)O[t]+=S[t];return this.markAsUpdated(),this}addInPlaceFromFloats(){const H=this.ip;for(let O=0;O<16;O++)H[O]+=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}XO(H){const O=this.ip,S=H.m;for(let t=0;t<16;t++)O[t]-=S[t];return this.markAsUpdated(),this}subtractToRef(H,O){const S=this.ip,t=H.m,q=O.ip;for(let p=0;p<16;p++)q[p]=S[p]-t[p];return O.markAsUpdated(),O}Mo(H){const O=this.ip,S=H.m;for(let t=0;t<16;t++)O[t]-=S[t];return this.markAsUpdated(),this}subtractFromFloats(){for(var H=arguments.length,O=new Array(H),S=0;S<H;S++)O[S]=arguments[S];return this.subtractFromFloatsToRef(...O,new T)}subtractFromFloatsToRef(){for(var H=arguments.length,O=new Array(H),S=0;S<H;S++)O[S]=arguments[S];const t=O.pop(),q=this.ip,p=t.ip,G=O;for(let U=0;U<16;U++)p[U]=q[U]-G[U];return t.markAsUpdated(),t}invertToRef(H){return!0===this._isIdentity?(T.IdentityToRef(H),H):(a(this,H.pU())?H.markAsUpdated():H.t(this),H)}addAtIndex(H,O){return this.ip[H]+=O,this.markAsUpdated(),this}multiplyAtIndex(H,O){return this.ip[H]*=O,this.markAsUpdated(),this}setTranslationFromFloats(H,O,S){return this.ip[12]=H,this.ip[13]=O,this.ip[14]=S,this.markAsUpdated(),this}addTranslationFromFloats(H,O,S){return this.ip[12]+=H,this.ip[13]+=O,this.ip[14]+=S,this.markAsUpdated(),this}setTranslation(H){return this.setTranslationFromFloats(H._x,H._y,H._z)}getTranslation(){return new X(this.ip[12],this.ip[13],this.ip[14])}getTranslationToRef(H){return H.x=this.ip[12],H.y=this.ip[13],H.z=this.ip[14],H}removeRotationAndScaling(){const H=this.m;return T.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,H[12],H[13],H[14],H[15],this),this._updateIdentityStatus(0===H[12]&&0===H[13]&&0===H[14]&&1===H[15]),this}t(H){H.copyToArray(this.ip);const O=H;return this.updateFlag=O.updateFlag,this._updateIdentityStatus(O._isIdentity,O._isIdentityDirty,O._isIdentity3x2,O._isIdentity3x2Dirty),this}copyToArray(H){return h(this,H,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(H){const O=new T;return this.multiplyToRef(H,O),O}multiplyInPlace(H){const O=this.ip,S=H.m;for(let t=0;t<16;t++)O[t]*=S[t];return this.markAsUpdated(),this}multiplyByFloats(){const H=this.ip;for(let O=0;O<16;O++)H[O]*=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var H=arguments.length,O=new Array(H),S=0;S<H;S++)O[S]=arguments[S];const t=O.pop(),q=this.ip,p=t.ip,G=O;for(let U=0;U<16;U++)p[U]=q[U]*G[U];return t.markAsUpdated(),t}multiplyToRef(H,O){return this._isIdentity?(O.t(H),O):H._isIdentity?(O.t(this),O):(this.multiplyToArray(H,O.ip,0),O.markAsUpdated(),O)}multiplyToArray(H,O,S){return o(this,H,O,S),this}divide(H){return this.divideToRef(H,new T)}divideToRef(H,O){const S=this.ip,t=H.m,q=O.ip;for(let p=0;p<16;p++)q[p]=S[p]/t[p];return O.markAsUpdated(),O}divideInPlace(H){const O=this.ip,S=H.m;for(let t=0;t<16;t++)O[t]/=S[t];return this.markAsUpdated(),this}minimizeInPlace(H){const O=this.ip,S=H.m;for(let t=0;t<16;t++)O[t]=Math.min(O[t],S[t]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const H=this.ip;for(let O=0;O<16;O++)H[O]=Math.min(H[O],O<0||arguments.length<=O?void 0:arguments[O]);return this.markAsUpdated(),this}maximizeInPlace(H){const O=this.ip,S=H.m;for(let t=0;t<16;t++)O[t]=Math.min(O[t],S[t]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const H=this.ip;for(let O=0;O<16;O++)H[O]=Math.min(H[O],O<0||arguments.length<=O?void 0:arguments[O]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new T)}negateInPlace(){const H=this.ip;for(let O=0;O<16;O++)H[O]=-H[O];return this.markAsUpdated(),this}negateToRef(H){const O=this.ip,S=H.ip;for(let t=0;t<16;t++)S[t]=-O[t];return H.markAsUpdated(),H}equals(H){const O=H;if(!O)return!1;if((this._isIdentity||O._isIdentity)&&!this._isIdentityDirty&&!O._isIdentityDirty)return this._isIdentity&&O._isIdentity;const S=this.m,t=O.m;return S[0]===t[0]&&S[1]===t[1]&&S[2]===t[2]&&S[3]===t[3]&&S[4]===t[4]&&S[5]===t[5]&&S[6]===t[6]&&S[7]===t[7]&&S[8]===t[8]&&S[9]===t[9]&&S[10]===t[10]&&S[11]===t[11]&&S[12]===t[12]&&S[13]===t[13]&&S[14]===t[14]&&S[15]===t[15]}equalsWithEpsilon(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const S=this.ip,t=H.m;for(let q=0;q<16;q++)if(!(0,V.WithinEpsilon)(S[q],t[q],O))return!1;return!0}equalsToFloats(){const H=this.ip;for(let O=0;O<16;O++)if(H[O]!=(O<0||arguments.length<=O?void 0:arguments[O]))return!1;return!0}floor(){return this.floorToRef(new T)}floorToRef(H){const O=this.ip,S=H.ip;for(let t=0;t<16;t++)S[t]=Math.floor(O[t]);return H.markAsUpdated(),H}fract(){return this.fractToRef(new T)}fractToRef(H){const O=this.ip,S=H.ip;for(let t=0;t<16;t++)S[t]=O[t]-Math.floor(O[t]);return H.markAsUpdated(),H}clone(){const H=new T;return H.t(this),H}getClassName(){return"Matrix"}getHashCode(){let H=j(this.ip[0]);for(let O=1;O<16;O++)H=397*H^j(this.ip[O]);return H}decomposeToTransformNode(H){return H.rotationQuaternion=H.rotationQuaternion||new y,this.decompose(H.eU,H.rotationQuaternion,H.position)}decompose(H,O,S,t){let q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return S&&S.XU(0),H&&H.XU(1),O&&O.jU(0,0,0,1),!0;const p=this.ip;if(S&&S.jU(p[12],p[13],p[14]),(H=H||K.eO[0]).x=Math.sqrt(p[0]*p[0]+p[1]*p[1]+p[2]*p[2]),H.y=Math.sqrt(p[4]*p[4]+p[5]*p[5]+p[6]*p[6]),H.z=Math.sqrt(p[8]*p[8]+p[9]*p[9]+p[10]*p[10]),t){const O=(q?t.absoluteScaling.x:t.eU.x)<0?-1:1,S=(q?t.absoluteScaling.y:t.eU.y)<0?-1:1,p=(q?t.absoluteScaling.z:t.eU.z)<0?-1:1;H.x*=O,H.y*=S,H.z*=p}else this.determinant()<=0&&(H.y*=-1);if(0===H._x||0===H._y||0===H._z)return O&&O.jU(0,0,0,1),!1;if(O){const S=1/H._x,t=1/H._y,q=1/H._z;T.FromValuesToRef(p[0]*S,p[1]*S,p[2]*S,0,p[4]*t,p[5]*t,p[6]*t,0,p[8]*q,p[9]*q,p[10]*q,0,0,0,0,1,K.Matrix[0]),y.FromRotationMatrixToRef(K.Matrix[0],O)}return!0}getRow(H){if(H<0||H>3)return null;const O=4*H;return new E(this.ip[O+0],this.ip[O+1],this.ip[O+2],this.ip[O+3])}getRowToRef(H,O){if(H>=0&&H<=3){const S=4*H;O.x=this.ip[S+0],O.y=this.ip[S+1],O.z=this.ip[S+2],O.w=this.ip[S+3]}return O}setRow(H,O){return this.setRowFromFloats(H,O.x,O.y,O.z,O.w)}transpose(){const H=new T;return T.TransposeToRef(this,H),H}transposeToRef(H){return T.TransposeToRef(this,H),H}setRowFromFloats(H,O,S,t,q){if(H<0||H>3)return this;const p=4*H;return this.ip[p+0]=O,this.ip[p+1]=S,this.ip[p+2]=t,this.ip[p+3]=q,this.markAsUpdated(),this}scale(H){const O=new T;return this.scaleToRef(H,O),O}scaleToRef(H,O){for(let S=0;S<16;S++)O.ip[S]=this.ip[S]*H;return O.markAsUpdated(),O}scaleAndAddToRef(H,O){for(let S=0;S<16;S++)O.ip[S]+=this.ip[S]*H;return O.markAsUpdated(),O}scaleInPlace(H){const O=this.ip;for(let S=0;S<16;S++)O[S]*=H;return this.markAsUpdated(),this}toNormalMatrix(H){const O=K.Matrix[0];this.invertToRef(O),O.transposeToRef(H);const S=H.ip;return T.FromValuesToRef(S[0],S[1],S[2],0,S[4],S[5],S[6],0,S[8],S[9],S[10],0,0,0,0,1,H),H}getRotationMatrix(){const H=new T;return this.getRotationMatrixToRef(H),H}getRotationMatrixToRef(H){const O=K.eO[0];if(!this.decompose(O))return T.IdentityToRef(H),H;const S=this.ip,t=1/O._x,q=1/O._y,p=1/O._z;return T.FromValuesToRef(S[0]*t,S[1]*t,S[2]*t,0,S[4]*q,S[5]*q,S[6]*q,0,S[8]*p,S[9]*p,S[10]*p,0,0,0,0,1,H),H}toggleModelMatrixHandInPlace(){const H=this.ip;return H[2]*=-1,H[6]*=-1,H[8]*=-1,H[9]*=-1,H[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const H=this.ip;return H[8]*=-1,H[9]*=-1,H[10]*=-1,H[11]*=-1,this.markAsUpdated(),this}static KO(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const S=new T;return T.FromArrayToRef(H,O,S),S}static FromArrayToRef(H,O,S){for(let t=0;t<16;t++)S.ip[t]=H[t+O];return S.markAsUpdated(),S}static FromFloat32ArrayToRefScaled(H,O,S,t){return t.ip[0]=H[0+O]*S,t.ip[1]=H[1+O]*S,t.ip[2]=H[2+O]*S,t.ip[3]=H[3+O]*S,t.ip[4]=H[4+O]*S,t.ip[5]=H[5+O]*S,t.ip[6]=H[6+O]*S,t.ip[7]=H[7+O]*S,t.ip[8]=H[8+O]*S,t.ip[9]=H[9+O]*S,t.ip[10]=H[10+O]*S,t.ip[11]=H[11+O]*S,t.ip[12]=H[12+O]*S,t.ip[13]=H[13+O]*S,t.ip[14]=H[14+O]*S,t.ip[15]=H[15+O]*S,t.markAsUpdated(),t}static get IdentityReadOnly(){return T._IdentityReadOnly}static FromValuesToRef(H,O,S,t,q,p,G,U,V,w,o,h,a,j,e,X,E){const y=E.ip;y[0]=H,y[1]=O,y[2]=S,y[3]=t,y[4]=q,y[5]=p,y[6]=G,y[7]=U,y[8]=V,y[9]=w,y[10]=o,y[11]=h,y[12]=a,y[13]=j,y[14]=e,y[15]=X,E.markAsUpdated()}static FromValues(H,O,S,t,q,p,G,U,V,w,o,h,a,j,e,X){const E=new T,y=E.ip;return y[0]=H,y[1]=O,y[2]=S,y[3]=t,y[4]=q,y[5]=p,y[6]=G,y[7]=U,y[8]=V,y[9]=w,y[10]=o,y[11]=h,y[12]=a,y[13]=j,y[14]=e,y[15]=X,E.markAsUpdated(),E}static Compose(H,O,S){const t=new T;return T.ComposeToRef(H,O,S,t),t}static ComposeToRef(H,O,S,t){const q=t.ip,p=O._x,G=O._y,U=O._z,V=O._w,w=p+p,o=G+G,h=U+U,a=p*w,j=p*o,e=p*h,X=G*o,E=G*h,y=U*h,T=V*w,K=V*o,b=V*h,D=H._x,F=H._y,Y=H._z;return q[0]=(1-(X+y))*D,q[1]=(j+b)*D,q[2]=(e-K)*D,q[3]=0,q[4]=(j-b)*F,q[5]=(1-(a+y))*F,q[6]=(E+T)*F,q[7]=0,q[8]=(e+K)*Y,q[9]=(E-T)*Y,q[10]=(1-(a+X))*Y,q[11]=0,q[12]=S._x,q[13]=S._y,q[14]=S._z,q[15]=1,t.markAsUpdated(),t}static Identity(){const H=T.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return H._updateIdentityStatus(!0),H}static IdentityToRef(H){return T.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,H),H._updateIdentityStatus(!0),H}static Zero(){const H=T.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return H._updateIdentityStatus(!1),H}static RotationX(H){const O=new T;return T.RotationXToRef(H,O),O}static Invert(H){const O=new T;return H.invertToRef(O),O}static RotationXToRef(H,O){const S=Math.sin(H),t=Math.cos(H);return T.FromValuesToRef(1,0,0,0,0,t,S,0,0,-S,t,0,0,0,0,1,O),O._updateIdentityStatus(1===t&&0===S),O}static RotationY(H){const O=new T;return T.RotationYToRef(H,O),O}static RotationYToRef(H,O){const S=Math.sin(H),t=Math.cos(H);return T.FromValuesToRef(t,0,-S,0,0,1,0,0,S,0,t,0,0,0,0,1,O),O._updateIdentityStatus(1===t&&0===S),O}static RotationZ(H){const O=new T;return T.RotationZToRef(H,O),O}static RotationZToRef(H,O){const S=Math.sin(H),t=Math.cos(H);return T.FromValuesToRef(t,S,0,0,-S,t,0,0,0,0,1,0,0,0,0,1,O),O._updateIdentityStatus(1===t&&0===S),O}static RotationAxis(H,O){const S=new T;return T.RotationAxisToRef(H,O,S),S}static RotationAxisToRef(H,O,S){const t=Math.sin(-O),q=Math.cos(-O),p=1-q;H=H.normalizeToRef(K.eO[0]);const G=S.ip;return G[0]=H._x*H._x*p+q,G[1]=H._x*H._y*p-H._z*t,G[2]=H._x*H._z*p+H._y*t,G[3]=0,G[4]=H._y*H._x*p+H._z*t,G[5]=H._y*H._y*p+q,G[6]=H._y*H._z*p-H._x*t,G[7]=0,G[8]=H._z*H._x*p-H._y*t,G[9]=H._z*H._y*p+H._x*t,G[10]=H._z*H._z*p+q,G[11]=0,G[12]=0,G[13]=0,G[14]=0,G[15]=1,S.markAsUpdated(),S}static RotationAlignToRef(H,O,S){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const p=X.Dot(O,H),G=S.ip;if(p<-1+t.e)G[0]=-1,G[1]=0,G[2]=0,G[3]=0,G[4]=0,G[5]=q?1:-1,G[6]=0,G[7]=0,G[8]=0,G[9]=0,G[10]=q?-1:1,G[11]=0;else{const S=X.Cross(O,H),t=1/(1+p);G[0]=S._x*S._x*t+p,G[1]=S._y*S._x*t-S._z,G[2]=S._z*S._x*t+S._y,G[3]=0,G[4]=S._x*S._y*t+S._z,G[5]=S._y*S._y*t+p,G[6]=S._z*S._y*t-S._x,G[7]=0,G[8]=S._x*S._z*t-S._y,G[9]=S._y*S._z*t+S._x,G[10]=S._z*S._z*t+p,G[11]=0}return G[12]=0,G[13]=0,G[14]=0,G[15]=1,S.markAsUpdated(),S}static RotationYawPitchRoll(H,O,S){const t=new T;return T.RotationYawPitchRollToRef(H,O,S,t),t}static RotationYawPitchRollToRef(H,O,S,t){return y.RotationYawPitchRollToRef(H,O,S,K.Quaternion[0]),K.Quaternion[0].toRotationMatrix(t),t}static Scaling(H,O,S){const t=new T;return T.ScalingToRef(H,O,S,t),t}static ScalingToRef(H,O,S,t){return T.FromValuesToRef(H,0,0,0,0,O,0,0,0,0,S,0,0,0,0,1,t),t._updateIdentityStatus(1===H&&1===O&&1===S),t}static Translation(H,O,S){const t=new T;return T.TranslationToRef(H,O,S,t),t}static TranslationToRef(H,O,S,t){return T.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,H,O,S,1,t),t._updateIdentityStatus(0===H&&0===O&&0===S),t}static Lerp(H,O,S){const t=new T;return T.LerpToRef(H,O,S,t),t}static LerpToRef(H,O,S,t){const q=t.ip,p=H.m,G=O.m;for(let U=0;U<16;U++)q[U]=p[U]*(1-S)+G[U]*S;return t.markAsUpdated(),t}static DecomposeLerp(H,O,S){const t=new T;return T.DecomposeLerpToRef(H,O,S,t),t}static DecomposeLerpToRef(H,O,S,t){const q=K.eO[0],p=K.Quaternion[0],G=K.eO[1];H.decompose(q,p,G);const U=K.eO[2],V=K.Quaternion[1],w=K.eO[3];O.decompose(U,V,w);const o=K.eO[4];X.LerpToRef(q,U,S,o);const h=K.Quaternion[2];y.SlerpToRef(p,V,S,h);const a=K.eO[5];return X.LerpToRef(G,w,S,a),T.ComposeToRef(o,h,a,t),t}static LookAtLH(H,O,S){const t=new T;return T.LookAtLHToRef(H,O,S,t),t}static LookAtLHToRef(H,O,S,t){const q=K.eO[0],p=K.eO[1],G=K.eO[2];O.subtractToRef(H,G),G.normalize(),X.CrossToRef(S,G,q);const U=q.lengthSquared();0===U?q.x=1:q.normalizeFromLength(Math.sqrt(U)),X.CrossToRef(G,q,p),p.normalize();const V=-X.Dot(q,H),w=-X.Dot(p,H),o=-X.Dot(G,H);return T.FromValuesToRef(q._x,p._x,G._x,0,q._y,p._y,G._y,0,q._z,p._z,G._z,0,V,w,o,1,t),t}static LookAtRH(H,O,S){const t=new T;return T.LookAtRHToRef(H,O,S,t),t}static LookAtRHToRef(H,O,S,t){const q=K.eO[0],p=K.eO[1],G=K.eO[2];H.subtractToRef(O,G),G.normalize(),X.CrossToRef(S,G,q);const U=q.lengthSquared();0===U?q.x=1:q.normalizeFromLength(Math.sqrt(U)),X.CrossToRef(G,q,p),p.normalize();const V=-X.Dot(q,H),w=-X.Dot(p,H),o=-X.Dot(G,H);return T.FromValuesToRef(q._x,p._x,G._x,0,q._y,p._y,G._y,0,q._z,p._z,G._z,0,V,w,o,1,t),t}static LookDirectionLH(H,O){const S=new T;return T.LookDirectionLHToRef(H,O,S),S}static LookDirectionLHToRef(H,O,S){const t=K.eO[0];t.t(H),t.scaleInPlace(-1);const q=K.eO[1];return X.CrossToRef(O,t,q),T.FromValuesToRef(q._x,q._y,q._z,0,O._x,O._y,O._z,0,t._x,t._y,t._z,0,0,0,0,1,S),S}static LookDirectionRH(H,O){const S=new T;return T.LookDirectionRHToRef(H,O,S),S}static LookDirectionRHToRef(H,O,S){const t=K.eO[2];return X.CrossToRef(O,H,t),T.FromValuesToRef(t._x,t._y,t._z,0,O._x,O._y,O._z,0,H._x,H._y,H._z,0,0,0,0,1,S),S}static OrthoLH(H,O,S,t,q){const p=new T;return T.OrthoLHToRef(H,O,S,t,p,q),p}static OrthoLHToRef(H,O,S,t,q,p){const G=2/H,U=2/O,V=2/(t-S),w=-(t+S)/(t-S);return T.FromValuesToRef(G,0,0,0,0,U,0,0,0,0,V,0,0,0,w,1,q),p&&q.multiplyToRef(D,q),q._updateIdentityStatus(1===G&&1===U&&1===V&&0===w),q}static OrthoOffCenterLH(H,O,S,t,q,p,G){const U=new T;return T.OrthoOffCenterLHToRef(H,O,S,t,q,p,U,G),U}static OrthoOffCenterLHToRef(H,O,S,t,q,p,G,U){const V=2/(O-H),w=2/(t-S),o=2/(p-q),h=-(p+q)/(p-q),a=(H+O)/(H-O),j=(t+S)/(S-t);return T.FromValuesToRef(V,0,0,0,0,w,0,0,0,0,o,0,a,j,h,1,G),U&&G.multiplyToRef(D,G),G.markAsUpdated(),G}static ObliqueOffCenterLHToRef(H,O,S,t,q,p,G,U,V,w,o){const h=-G*Math.cos(U),a=-G*Math.sin(U);return T.TranslationToRef(0,0,-V,K.Matrix[1]),T.FromValuesToRef(1,0,0,0,0,1,0,0,h,a,1,0,0,0,0,1,K.Matrix[0]),K.Matrix[1].multiplyToRef(K.Matrix[0],K.Matrix[0]),T.TranslationToRef(0,0,V,K.Matrix[1]),K.Matrix[0].multiplyToRef(K.Matrix[1],K.Matrix[0]),T.OrthoOffCenterLHToRef(H,O,S,t,q,p,w,o),K.Matrix[0].multiplyToRef(w,w),w}static OrthoOffCenterRH(H,O,S,t,q,p,G){const U=new T;return T.OrthoOffCenterRHToRef(H,O,S,t,q,p,U,G),U}static OrthoOffCenterRHToRef(H,O,S,t,q,p,G,U){return T.OrthoOffCenterLHToRef(H,O,S,t,q,p,G,U),G.ip[10]*=-1,G}static ObliqueOffCenterRHToRef(H,O,S,t,q,p,G,U,V,w,o){const h=G*Math.cos(U),a=G*Math.sin(U);return T.TranslationToRef(0,0,V,K.Matrix[1]),T.FromValuesToRef(1,0,0,0,0,1,0,0,h,a,1,0,0,0,0,1,K.Matrix[0]),K.Matrix[1].multiplyToRef(K.Matrix[0],K.Matrix[0]),T.TranslationToRef(0,0,-V,K.Matrix[1]),K.Matrix[0].multiplyToRef(K.Matrix[1],K.Matrix[0]),T.OrthoOffCenterRHToRef(H,O,S,t,q,p,w,o),K.Matrix[0].multiplyToRef(w,w),w}static PerspectiveLH(H,O,S,t,q){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const G=new T,U=2*S/H,V=2*S/O,w=(t+S)/(t-S),o=-2*t*S/(t-S),h=Math.tan(p);return T.FromValuesToRef(U,0,0,0,0,V,0,h,0,0,w,1,0,0,o,0,G),q&&G.multiplyToRef(D,G),G._updateIdentityStatus(!1),G}static PerspectiveFovLH(H,O,S,t,q){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,G=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const U=new T;return T.PerspectiveFovLHToRef(H,O,S,t,U,!0,q,p,G),U}static PerspectiveFovLHToRef(H,O,S,t,q){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],G=arguments.length>6?arguments[6]:void 0,U=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,V=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const w=S,o=t,h=1/Math.tan(.5*H),a=p?h/O:h,j=p?h:h*O,e=V&&0===w?-1:0!==o?(o+w)/(o-w):1,X=V&&0===w?2*o:0!==o?-2*o*w/(o-w):-2*w,E=Math.tan(U);return T.FromValuesToRef(a,0,0,0,0,j,0,E,0,0,e,1,0,0,X,0,q),G&&q.multiplyToRef(D,q),q._updateIdentityStatus(!1),q}static PerspectiveFovReverseLHToRef(H,O,S,t,q){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],G=arguments.length>6?arguments[6]:void 0,U=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const V=1/Math.tan(.5*H),w=p?V/O:V,o=p?V:V*O,h=Math.tan(U);return T.FromValuesToRef(w,0,0,0,0,o,0,h,0,0,-S,1,0,0,1,0,q),G&&q.multiplyToRef(D,q),q._updateIdentityStatus(!1),q}static PerspectiveFovRH(H,O,S,t,q){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,G=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const U=new T;return T.PerspectiveFovRHToRef(H,O,S,t,U,!0,q,p,G),U}static PerspectiveFovRHToRef(H,O,S,t,q){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],G=arguments.length>6?arguments[6]:void 0,U=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,V=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const w=S,o=t,h=1/Math.tan(.5*H),a=p?h/O:h,j=p?h:h*O,e=V&&0===w?1:0!==o?-(o+w)/(o-w):-1,X=V&&0===w?2*o:0!==o?-2*o*w/(o-w):-2*w,E=Math.tan(U);return T.FromValuesToRef(a,0,0,0,0,j,0,E,0,0,e,-1,0,0,X,0,q),G&&q.multiplyToRef(D,q),q._updateIdentityStatus(!1),q}static PerspectiveFovReverseRHToRef(H,O,S,t,q){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],G=arguments.length>6?arguments[6]:void 0,U=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const V=1/Math.tan(.5*H),w=p?V/O:V,o=p?V:V*O,h=Math.tan(U);return T.FromValuesToRef(w,0,0,0,0,o,0,h,0,0,-S,-1,0,0,-1,0,q),G&&q.multiplyToRef(D,q),q._updateIdentityStatus(!1),q}static GetFinalMatrix(H,O,S,t,q,p){const G=H.width,U=H.height,V=H.x,w=H.y,o=T.FromValues(G/2,0,0,0,0,-U/2,0,0,0,0,p-q,0,V+G/2,U/2+w,q,1),h=new T;return O.multiplyToRef(S,h),h.multiplyToRef(t,h),h.multiplyToRef(o,h)}static GetAsMatrix2x2(H){const O=H.m,S=[O[0],O[1],O[4],O[5]];return G.d.MatrixUse64Bits?S:new Float32Array(S)}static GetAsMatrix3x3(H){const O=H.m,S=[O[0],O[1],O[2],O[4],O[5],O[6],O[8],O[9],O[10]];return G.d.MatrixUse64Bits?S:new Float32Array(S)}static Transpose(H){const O=new T;return T.TransposeToRef(H,O),O}static TransposeToRef(H,O){const S=H.m,t=S[0],q=S[4],p=S[8],G=S[12],U=S[1],V=S[5],w=S[9],o=S[13],h=S[2],a=S[6],j=S[10],e=S[14],X=S[3],E=S[7],y=S[11],T=S[15],K=O.ip;return K[0]=t,K[1]=q,K[2]=p,K[3]=G,K[4]=U,K[5]=V,K[6]=w,K[7]=o,K[8]=h,K[9]=a,K[10]=j,K[11]=e,K[12]=X,K[13]=E,K[14]=y,K[15]=T,O.markAsUpdated(),O._updateIdentityStatus(H._isIdentity,H._isIdentityDirty),O}static Reflection(H){const O=new T;return T.ReflectionToRef(H,O),O}static ReflectionToRef(H,O){H.normalize();const S=H.normal.x,t=H.normal.y,q=H.normal.z,p=-2*S,G=-2*t,U=-2*q;return T.FromValuesToRef(p*S+1,G*S,U*S,0,p*t,G*t+1,U*t,0,p*q,G*q,U*q+1,0,p*H.d,G*H.d,U*H.d,1,O),O}static FromXYZAxesToRef(H,O,S,t){return T.FromValuesToRef(H._x,H._y,H._z,0,O._x,O._y,O._z,0,S._x,S._y,S._z,0,0,0,0,1,t),t}static FromQuaternionToRef(H,O){const S=H._x*H._x,t=H._y*H._y,q=H._z*H._z,p=H._x*H._y,G=H._z*H._w,U=H._z*H._x,V=H._y*H._w,w=H._y*H._z,o=H._x*H._w;return O.ip[0]=1-2*(t+q),O.ip[1]=2*(p+G),O.ip[2]=2*(U-V),O.ip[3]=0,O.ip[4]=2*(p-G),O.ip[5]=1-2*(q+S),O.ip[6]=2*(w+o),O.ip[7]=0,O.ip[8]=2*(U+V),O.ip[9]=2*(w-o),O.ip[10]=1-2*(t+S),O.ip[11]=0,O.ip[12]=0,O.ip[13]=0,O.ip[14]=0,O.ip[15]=1,O.markAsUpdated(),O}}T._IdentityReadOnly=T.Identity(),Object.defineProperties(T.prototype,{dimension:{value:[4,4]},rank:{value:2}});class K{}K.eO=(0,q.e)(11,X.Zero),K.Matrix=(0,q.e)(2,T.Identity),K.Quaternion=(0,q.e)(3,y.Zero);class b{}b.Vector2=(0,q.e)(3,e.Zero),b.eO=(0,q.e)(13,X.Zero),b.Vector4=(0,q.e)(3,E.Zero),b.Quaternion=(0,q.e)(3,y.Zero),b.Matrix=(0,q.e)(8,T.Identity),(0,p.g)("BABYLON.Vector2",e),(0,p.g)("BABYLON.Vector3",X),(0,p.g)("BABYLON.Vector4",E),(0,p.g)("BABYLON.Matrix",T);const D=T.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11310:(H,O,S)=>{function t(H,O){const S=[];for(let t=0;t<H;++t)S.push(O());return S}function q(H,O){return t(H,O)}S.d(O,{d:()=>t,e:()=>q,g:()=>G});const p=["push","splice","pop","shift","unshift"];function G(H,O){const S=p.map((S=>function(H,O,S){const t=H[O];if("function"!==typeof t)return null;const q=function(){const t=H.length,p=q.previous.apply(H,arguments);return S(O,t),p};return t.next=q,q.previous=t,H[O]=q,()=>{const S=q.previous;if(!S)return;const t=q.next;t?(S.next=t,t.previous=S):(S.next=void 0,H[O]=S),q.next=void 0,q.previous=void 0}}(H,S,O)));return()=>{for(const H of S)null===H||void 0===H||H()}}}}]);