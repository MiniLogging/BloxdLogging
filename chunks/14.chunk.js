"use strict";(self.uw9p3pwwsje=self.uw9p3pwwsje||[]).push([[14],{12833:(D,h,o)=>{o.d(h,{d:()=>M,g:()=>j,j:()=>H,l:()=>g});const H=1/2.2,g=2.2,j=(1+Math.sqrt(5))/2,M=.001},12842:(D,h,o)=>{function H(D){return parseInt(D.toString().replace(/\W/g,""))}function g(D,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(D-h)<=o}function j(D,h,o){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return D<h-H||D>o+H}function M(D,h){return D===h?D:Math.random()*(h-D)+D}function R(D,h,o){return D+(h-D)*o}function t(D,h,o){let H=s(h-D,360);return H>180&&(H-=360),D+H*Q(o)}function S(D,h,o){let H=0;return H=D!=h?Q((o-D)/(h-D)):0,H}function k(D,h,o,H,g){const j=g*g,M=g*j;return D*(2*M-3*j+1)+o*(-2*M+3*j)+h*(M-2*j+g)+H*(M-j)}function K(D,h,o,H,g){const j=g*g;return 6*(j-g)*D+(3*j-4*g+1)*h+6*(-j+g)*o+(3*j-2*g)*H}function Q(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(o,Math.max(h,D))}function v(D){return D-=2*Math.PI*Math.floor((D+Math.PI)/(2*Math.PI))}function r(D){const h=D.toString(16);return D<=15?("0"+h).toUpperCase():h.toUpperCase()}function B(D){if(Math.log2)return Math.floor(Math.log2(D));if(D<0)return NaN;if(0===D)return-1/0;let h=0;if(D<1){for(;D<1;)h++,D*=2;h=-h}else if(D>1)for(;D>1;)h++,D=Math.floor(D/2);return h}function s(D,h){return D-Math.floor(D/h)*h}function U(D,h,o){return(D-h)/(o-h)}function q(D,h,o){return D*(o-h)+h}function c(D,h){let o=s(h-D,360);return o>180&&(o-=360),o}function y(D,h){const o=s(D,2*h);return h-Math.abs(o-h)}function b(D,h,o){let H=Q(o);return H=-2*H*H*H+3*H*H,h*H+D*(1-H)}function i(D,h,o){let H=0;return H=Math.abs(h-D)<=o?h:D+Math.sign(h-D)*o,H}function G(D,h,o){const H=c(D,h);let g=0;return g=-o<H&&H<o?h:i(D,h=D+H,o),g}function N(D,h,o){return(D-h)/(o-h)}function J(D,h,o){return(o-h)*D+h}function O(D,h){const o=D%h;return 0===o?h:O(h,o)}o.r(h),o.d(h,{Clamp:()=>Q,DeltaAngle:()=>c,Denormalize:()=>q,ExtractAsInt:()=>H,Hermite:()=>k,Hermite1stDerivative:()=>K,HighestCommonFactor:()=>O,ILog2:()=>B,InverseLerp:()=>S,Lerp:()=>R,LerpAngle:()=>t,MoveTowards:()=>i,MoveTowardsAngle:()=>G,Normalize:()=>U,NormalizeRadians:()=>v,OutsideRange:()=>j,PercentToRange:()=>J,PingPong:()=>y,RandomRange:()=>M,RangeToPercent:()=>N,Repeat:()=>s,SmoothStep:()=>b,ToHex:()=>r,WithinEpsilon:()=>g})},12831:(D,h,o)=>{o.r(h),o.d(h,{Matrix:()=>q,Quaternion:()=>U,TmpVectors:()=>y,Vector2:()=>r,Gh:()=>B,Vector4:()=>s});var H=o(12833),g=o(12836),j=o(12793),M=o(12762),R=o(12683),t=o(12842);class S{}function k(D,h,o){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const g=D.Fh(),j=h.Fh(),M=g[0],R=g[1],t=g[2],S=g[3],k=g[4],K=g[5],Q=g[6],v=g[7],r=g[8],B=g[9],s=g[10],U=g[11],q=g[12],c=g[13],y=g[14],b=g[15],i=j[0],G=j[1],N=j[2],J=j[3],O=j[4],E=j[5],L=j[6],T=j[7],Z=j[8],e=j[9],p=j[10],mD=j[11],a=j[12],u=j[13],I=j[14],P=j[15];o[H]=M*i+R*O+t*Z+S*a,o[H+1]=M*G+R*E+t*e+S*u,o[H+2]=M*N+R*L+t*p+S*I,o[H+3]=M*J+R*T+t*mD+S*P,o[H+4]=k*i+K*O+Q*Z+v*a,o[H+5]=k*G+K*E+Q*e+v*u,o[H+6]=k*N+K*L+Q*p+v*I,o[H+7]=k*J+K*T+Q*mD+v*P,o[H+8]=r*i+B*O+s*Z+U*a,o[H+9]=r*G+B*E+s*e+U*u,o[H+10]=r*N+B*L+s*p+U*I,o[H+11]=r*J+B*T+s*mD+U*P,o[H+12]=q*i+c*O+y*Z+b*a,o[H+13]=q*G+c*E+y*e+b*u,o[H+14]=q*N+c*L+y*p+b*I,o[H+15]=q*J+c*T+y*mD+b*P}function K(D,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const H=D.Fh();h[o]=H[0],h[o+1]=H[1],h[o+2]=H[2],h[o+3]=H[3],h[o+4]=H[4],h[o+5]=H[5],h[o+6]=H[6],h[o+7]=H[7],h[o+8]=H[8],h[o+9]=H[9],h[o+10]=H[10],h[o+11]=H[11],h[o+12]=H[12],h[o+13]=H[13],h[o+14]=H[14],h[o+15]=H[15]}function Q(D,h){const o=D.Fh(),H=o[0],g=o[1],j=o[2],M=o[3],R=o[4],t=o[5],S=o[6],k=o[7],K=o[8],Q=o[9],v=o[10],r=o[11],B=o[12],s=o[13],U=o[14],q=o[15],c=v*q-U*r,y=Q*q-s*r,b=Q*U-s*v,i=K*q-B*r,G=K*U-v*B,N=K*s-B*Q,J=+(t*c-S*y+k*b),O=-(R*c-S*i+k*G),E=+(R*y-t*i+k*N),L=-(R*b-t*G+S*N),T=H*J+g*O+j*E+M*L;if(0===T)return!1;const Z=1/T,e=S*q-U*k,p=t*q-s*k,mD=t*U-s*S,a=R*q-B*k,u=R*U-B*S,I=R*s-B*t,P=S*r-v*k,n=t*r-Q*k,F=t*v-Q*S,w=R*r-K*k,Y=R*v-K*S,l=R*Q-K*t,C=-(g*c-j*y+M*b),z=+(H*c-j*i+M*G),f=-(H*y-g*i+M*N),V=+(H*b-g*G+j*N),d=+(g*e-j*p+M*mD),X=-(H*e-j*a+M*u),A=+(H*p-g*a+M*I),W=-(H*mD-g*u+j*I),x=-(g*P-j*n+M*F),DD=+(H*P-j*w+M*Y),hD=-(H*n-g*w+M*l),oD=+(H*F-g*Y+j*l);return h[0]=J*Z,h[1]=C*Z,h[2]=d*Z,h[3]=x*Z,h[4]=O*Z,h[5]=z*Z,h[6]=X*Z,h[7]=DD*Z,h[8]=E*Z,h[9]=f*Z,h[10]=A*Z,h[11]=hD*Z,h[12]=L*Z,h[13]=V*Z,h[14]=W*Z,h[15]=oD*Z,!0}S._UpdateFlagSeed=0;const v=D=>parseInt(D.toString().replace(/\W/g,""));class r{constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=D,this.y=h}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let D=v(this.x);return D=397*D^v(this.y),D}toArray(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D[h]=this.x,D[h+1]=this.y,this}lo(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r.FromArrayToRef(D,h,this),this}Fh(){return[this.x,this.y]}M(D){return this.x=D.x,this.y=D.y,this}Qg(D,h){return this.x=D,this.y=h,this}set(D,h){return this.Qg(D,h)}qg(D){return this.Qg(D,D)}add(D){return new r(this.x+D.x,this.y+D.y)}addToRef(D,h){return h.x=this.x+D.x,h.y=this.y+D.y,h}addInPlace(D){return this.x+=D.x,this.y+=D.y,this}addInPlaceFromFloats(D,h){return this.x+=D,this.y+=h,this}addVector3(D){return new r(this.x+D.x,this.y+D.y)}Nh(D){return new r(this.x-D.x,this.y-D.y)}subtractToRef(D,h){return h.x=this.x-D.x,h.y=this.y-D.y,h}zK(D){return this.x-=D.x,this.y-=D.y,this}multiplyInPlace(D){return this.x*=D.x,this.y*=D.y,this}multiply(D){return new r(this.x*D.x,this.y*D.y)}multiplyToRef(D,h){return h.x=this.x*D.x,h.y=this.y*D.y,h}multiplyByFloats(D,h){return new r(this.x*D,this.y*h)}divide(D){return new r(this.x/D.x,this.y/D.y)}divideToRef(D,h){return h.x=this.x/D.x,h.y=this.y/D.y,h}divideInPlace(D){return this.x=this.x/D.x,this.y=this.y/D.y,this}minimizeInPlace(D){return this.minimizeInPlaceFromFloats(D.x,D.y)}maximizeInPlace(D){return this.maximizeInPlaceFromFloats(D.x,D.y)}minimizeInPlaceFromFloats(D,h){return this.x=Math.min(D,this.x),this.y=Math.min(h,this.y),this}maximizeInPlaceFromFloats(D,h){return this.x=Math.max(D,this.x),this.y=Math.max(h,this.y),this}subtractFromFloats(D,h){return new r(this.x-D,this.y-h)}subtractFromFloatsToRef(D,h,o){return o.x=this.x-D,o.y=this.y-h,o}negate(){return new r(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(D){return D.x=-this.x,D.y=-this.y,D}scaleInPlace(D){return this.x*=D,this.y*=D,this}scale(D){return new r(this.x*D,this.y*D)}scaleToRef(D,h){return h.x=this.x*D,h.y=this.y*D,h}scaleAndAddToRef(D,h){return h.x+=this.x*D,h.y+=this.y*D,h}equals(D){return D&&this.x===D.x&&this.y===D.y}equalsWithEpsilon(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.d;return D&&(0,t.WithinEpsilon)(this.x,D.x,h)&&(0,t.WithinEpsilon)(this.y,D.y,h)}equalsToFloats(D,h){return this.x===D&&this.y===h}floor(){return new r(Math.floor(this.x),Math.floor(this.y))}floorToRef(D){return D.x=Math.floor(this.x),D.y=Math.floor(this.y),D}fract(){return new r(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(D){return D.x=this.x-Math.floor(this.x),D.y=this.y-Math.floor(this.y),D}rotate(D){return this.rotateToRef(D,new r)}rotateToRef(D,h){const o=Math.cos(D),H=Math.sin(D);return h.x=o*this.x-H*this.y,h.y=H*this.x+o*this.y,h}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(D){return 0===D||1===D?this:this.scaleInPlace(1/D)}normalizeToNew(){const D=new r;return this.normalizeToRef(D),D}normalizeToRef(D){const h=this.length();return 0===h&&(D.x=this.x,D.y=this.y),this.scaleToRef(1/h,D)}clone(){return new r(this.x,this.y)}dot(D){return this.x*D.x+this.y*D.y}static Zero(){return new r(0,0)}static One(){return new r(1,1)}static Random(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new r((0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h))}static RandomToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Qg((0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h))}static get ZeroReadOnly(){return r._ZeroReadOnly}static Ih(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new r(D[h],D[h+1])}static FromArrayToRef(D,h,o){return o.x=D[h],o.y=D[h+1],o}static FromFloatsToRef(D,h,o){return o.Qg(D,h),o}static CatmullRom(D,h,o,H,g){const j=g*g,M=g*j,R=.5*(2*h.x+(-D.x+o.x)*g+(2*D.x-5*h.x+4*o.x-H.x)*j+(-D.x+3*h.x-3*o.x+H.x)*M),t=.5*(2*h.y+(-D.y+o.y)*g+(2*D.y-5*h.y+4*o.y-H.y)*j+(-D.y+3*h.y-3*o.y+H.y)*M);return new r(R,t)}static ClampToRef(D,h,o,H){return H.x=(0,t.Clamp)(D.x,h.x,o.x),H.y=(0,t.Clamp)(D.y,h.y,o.y),H}static Clamp(D,h,o){const H=(0,t.Clamp)(D.x,h.x,o.x),g=(0,t.Clamp)(D.y,h.y,o.y);return new r(H,g)}static Hermite(D,h,o,H,g){const j=g*g,M=g*j,R=2*M-3*j+1,t=-2*M+3*j,S=M-2*j+g,k=M-j,K=D.x*R+o.x*t+h.x*S+H.x*k,Q=D.y*R+o.y*t+h.y*S+H.y*k;return new r(K,Q)}static Hermite1stDerivative(D,h,o,H,g){return this.Hermite1stDerivativeToRef(D,h,o,H,g,new r)}static Hermite1stDerivativeToRef(D,h,o,H,g,j){const M=g*g;return j.x=6*(M-g)*D.x+(3*M-4*g+1)*h.x+6*(-M+g)*o.x+(3*M-2*g)*H.x,j.y=6*(M-g)*D.y+(3*M-4*g+1)*h.y+6*(-M+g)*o.y+(3*M-2*g)*H.y,j}static Lerp(D,h,o){return r.LerpToRef(D,h,o,new r)}static LerpToRef(D,h,o,H){return H.x=D.x+(h.x-D.x)*o,H.y=D.y+(h.y-D.y)*o,H}static Dot(D,h){return D.x*h.x+D.y*h.y}static Normalize(D){return r.NormalizeToRef(D,new r)}static NormalizeToRef(D,h){return D.normalizeToRef(h),h}static Minimize(D,h){const o=D.x<h.x?D.x:h.x,H=D.y<h.y?D.y:h.y;return new r(o,H)}static Maximize(D,h){const o=D.x>h.x?D.x:h.x,H=D.y>h.y?D.y:h.y;return new r(o,H)}static Transform(D,h){return r.TransformToRef(D,h,new r)}static TransformToRef(D,h,o){const H=h.m,g=D.x*H[0]+D.y*H[4]+H[12],j=D.x*H[1]+D.y*H[5]+H[13];return o.x=g,o.y=j,o}static PointInTriangle(D,h,o,H){const g=.5*(-o.y*H.x+h.y*(-o.x+H.x)+h.x*(o.y-H.y)+o.x*H.y),j=g<0?-1:1,M=(h.y*H.x-h.x*H.y+(H.y-h.y)*D.x+(h.x-H.x)*D.y)*j,R=(h.x*o.y-h.y*o.x+(h.y-o.y)*D.x+(o.x-h.x)*D.y)*j;return M>0&&R>0&&M+R<2*g*j}static Distance(D,h){return Math.sqrt(r.DistanceSquared(D,h))}static DistanceSquared(D,h){const o=D.x-h.x,H=D.y-h.y;return o*o+H*H}static Center(D,h){return r.CenterToRef(D,h,new r)}static CenterToRef(D,h,o){return o.Qg((D.x+h.x)/2,(D.y+h.y)/2)}static DistanceOfPointFromSegment(D,h,o){const H=r.DistanceSquared(h,o);if(0===H)return r.Distance(D,h);const g=o.Nh(h),j=Math.max(0,Math.min(1,r.Dot(D.Nh(h),g)/H)),M=h.add(g.multiplyByFloats(j,j));return r.Distance(D,M)}}r._V8PerformanceHack=new r(.5,.5),r._ZeroReadOnly=r.Zero(),Object.defineProperties(r.prototype,{dimension:{value:[2]},rank:{value:1}});class B{get x(){return this._x}set x(D){this._x=D,this._isDirty=!0}get y(){return this._y}set y(D){this._y=D,this._isDirty=!0}get z(){return this._z}set z(D){this._z=D,this._isDirty=!0}constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=D,this._y=h,this._z=o}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Gh"}getHashCode(){let D=v(this._x);return D=397*D^v(this._y),D=397*D^v(this._z),D}Fh(){return[this._x,this._y,this._z]}toArray(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D[h]=this._x,D[h+1]=this._y,D[h+2]=this._z,this}lo(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B.FromArrayToRef(D,h,this),this}toQuaternion(){return U.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(D){return this._x+=D._x,this._y+=D._y,this._z+=D._z,this._isDirty=!0,this}addInPlaceFromFloats(D,h,o){return this._x+=D,this._y+=h,this._z+=o,this._isDirty=!0,this}add(D){return new B(this._x+D._x,this._y+D._y,this._z+D._z)}addToRef(D,h){return h._x=this._x+D._x,h._y=this._y+D._y,h._z=this._z+D._z,h._isDirty=!0,h}zK(D){return this._x-=D._x,this._y-=D._y,this._z-=D._z,this._isDirty=!0,this}Nh(D){return new B(this._x-D._x,this._y-D._y,this._z-D._z)}subtractToRef(D,h){return this.subtractFromFloatsToRef(D._x,D._y,D._z,h)}subtractFromFloats(D,h,o){return new B(this._x-D,this._y-h,this._z-o)}subtractFromFloatsToRef(D,h,o,H){return H._x=this._x-D,H._y=this._y-h,H._z=this._z-o,H._isDirty=!0,H}negate(){return new B(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(D){return D._x=-1*this._x,D._y=-1*this._y,D._z=-1*this._z,D._isDirty=!0,D}scaleInPlace(D){return this._x*=D,this._y*=D,this._z*=D,this._isDirty=!0,this}scale(D){return new B(this._x*D,this._y*D,this._z*D)}scaleToRef(D,h){return h._x=this._x*D,h._y=this._y*D,h._z=this._z*D,h._isDirty=!0,h}getNormalToRef(D){const h=this.length();let o=Math.acos(this._y/h);const H=Math.atan2(this._z,this._x);o>Math.PI/2?o-=Math.PI/2:o+=Math.PI/2;const g=h*Math.sin(o)*Math.cos(H),j=h*Math.cos(o),M=h*Math.sin(o)*Math.sin(H);return D.set(g,j,M),D}applyRotationQuaternionToRef(D,h){const o=this._x,H=this._y,g=this._z,j=D._x,M=D._y,R=D._z,t=D._w,S=2*(M*g-R*H),k=2*(R*o-j*g),K=2*(j*H-M*o);return h._x=o+t*S+M*K-R*k,h._y=H+t*k+R*S-j*K,h._z=g+t*K+j*k-M*S,h._isDirty=!0,h}applyRotationQuaternionInPlace(D){return this.applyRotationQuaternionToRef(D,this)}applyRotationQuaternion(D){return this.applyRotationQuaternionToRef(D,new B)}scaleAndAddToRef(D,h){return h._x+=this._x*D,h._y+=this._y*D,h._z+=this._z*D,h._isDirty=!0,h}projectOnPlane(D,h){return this.projectOnPlaneToRef(D,h,new B)}projectOnPlaneToRef(D,h,o){const H=D.normal,g=D.d,j=c.Gh[0];this.subtractToRef(h,j),j.normalize();const M=B.Dot(j,H);if(Math.abs(M)<1e-10)o.qg(1/0);else{const D=-(B.Dot(h,H)+g)/M,R=j.scaleInPlace(D);h.addToRef(R,o)}return o}equals(D){return D&&this._x===D._x&&this._y===D._y&&this._z===D._z}equalsWithEpsilon(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.d;return D&&(0,t.WithinEpsilon)(this._x,D._x,h)&&(0,t.WithinEpsilon)(this._y,D._y,h)&&(0,t.WithinEpsilon)(this._z,D._z,h)}equalsToFloats(D,h,o){return this._x===D&&this._y===h&&this._z===o}multiplyInPlace(D){return this._x*=D._x,this._y*=D._y,this._z*=D._z,this._isDirty=!0,this}multiply(D){return this.multiplyByFloats(D._x,D._y,D._z)}multiplyToRef(D,h){return h._x=this._x*D._x,h._y=this._y*D._y,h._z=this._z*D._z,h._isDirty=!0,h}multiplyByFloats(D,h,o){return new B(this._x*D,this._y*h,this._z*o)}divide(D){return new B(this._x/D._x,this._y/D._y,this._z/D._z)}divideToRef(D,h){return h._x=this._x/D._x,h._y=this._y/D._y,h._z=this._z/D._z,h._isDirty=!0,h}divideInPlace(D){return this._x=this._x/D._x,this._y=this._y/D._y,this._z=this._z/D._z,this._isDirty=!0,this}minimizeInPlace(D){return this.minimizeInPlaceFromFloats(D._x,D._y,D._z)}maximizeInPlace(D){return this.maximizeInPlaceFromFloats(D._x,D._y,D._z)}minimizeInPlaceFromFloats(D,h,o){return D<this._x&&(this.x=D),h<this._y&&(this.y=h),o<this._z&&(this.z=o),this}maximizeInPlaceFromFloats(D,h,o){return D>this._x&&(this.x=D),h>this._y&&(this.y=h),o>this._z&&(this.z=o),this}isNonUniformWithinEpsilon(D){const h=Math.abs(this._x),o=Math.abs(this._y);if(!(0,t.WithinEpsilon)(h,o,D))return!0;const H=Math.abs(this._z);return!(0,t.WithinEpsilon)(h,H,D)||!(0,t.WithinEpsilon)(o,H,D)}get isNonUniform(){const D=Math.abs(this._x);if(D!==Math.abs(this._y))return!0;return D!==Math.abs(this._z)}floorToRef(D){return D._x=Math.floor(this._x),D._y=Math.floor(this._y),D._z=Math.floor(this._z),D._isDirty=!0,D}floor(){return new B(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(D){return D._x=this._x-Math.floor(this._x),D._y=this._y-Math.floor(this._y),D._z=this._z-Math.floor(this._z),D._isDirty=!0,D}fract(){return new B(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(D){if("xyz"===(D=D.toLowerCase()))return this;const h=c.Gh[0].M(this);return this.x=h[D[0]],this.y=h[D[1]],this.z=h[D[2]],this}rotateByQuaternionToRef(D,h){return D.toRotationMatrix(c.Matrix[0]),B.TransformCoordinatesToRef(this,c.Matrix[0],h),h}rotateByQuaternionAroundPointToRef(D,h,o){return this.subtractToRef(h,c.Gh[0]),c.Gh[0].rotateByQuaternionToRef(D,c.Gh[0]),h.addToRef(c.Gh[0],o),o}cross(D){return B.CrossToRef(this,D,new B)}normalizeFromLength(D){return 0===D||1===D?this:this.scaleInPlace(1/D)}normalizeToNew(){return this.normalizeToRef(new B)}normalizeToRef(D){const h=this.length();return 0===h||1===h?(D._x=this._x,D._y=this._y,D._z=this._z,D._isDirty=!0,D):this.scaleToRef(1/h,D)}clone(){return new B(this._x,this._y,this._z)}M(D){return this.Qg(D._x,D._y,D._z)}Qg(D,h,o){return this._x=D,this._y=h,this._z=o,this._isDirty=!0,this}set(D,h,o){return this.Qg(D,h,o)}qg(D){return this._x=this._y=this._z=D,this._isDirty=!0,this}static GetClipFactor(D,h,o,H){const g=B.Dot(D,o);return(g-H)/(g-B.Dot(h,o))}static GetAngleBetweenVectors(D,h,o){const H=D.normalizeToRef(c.Gh[1]),g=h.normalizeToRef(c.Gh[2]);let j=B.Dot(H,g);j=(0,t.Clamp)(j,-1,1);const M=Math.acos(j),R=c.Gh[3];return B.CrossToRef(H,g,R),B.Dot(R,o)>0?isNaN(M)?0:M:isNaN(M)?-Math.PI:-Math.acos(j)}static GetAngleBetweenVectorsOnPlane(D,h,o){c.Gh[0].M(D);const H=c.Gh[0];c.Gh[1].M(h);const g=c.Gh[1];c.Gh[2].M(o);const j=c.Gh[2],M=c.Gh[3],R=c.Gh[4];H.normalize(),g.normalize(),j.normalize(),B.CrossToRef(j,H,M),B.CrossToRef(M,j,R);const S=Math.atan2(B.Dot(g,M),B.Dot(g,R));return(0,t.NormalizeRadians)(S)}static PitchYawRollToMoveBetweenPointsToRef(D,h,o){const H=y.Gh[0];return h.subtractToRef(D,H),o._y=Math.atan2(H.x,H.z)||0,o._x=Math.atan2(Math.sqrt(H.x**2+H.z**2),H.y)||0,o._z=0,o._isDirty=!0,o}static PitchYawRollToMoveBetweenPoints(D,h){const o=B.Zero();return B.PitchYawRollToMoveBetweenPointsToRef(D,h,o)}static SlerpToRef(D,h,o,g){o=(0,t.Clamp)(o,0,1);const j=c.Gh[0],M=c.Gh[1];j.M(D);const R=j.length();j.normalizeFromLength(R),M.M(h);const S=M.length();M.normalizeFromLength(S);const k=B.Dot(j,M);let K,Q;if(k<1-H.d){const D=Math.acos(k),h=1/Math.sin(D);K=Math.sin((1-o)*D)*h,Q=Math.sin(o*D)*h}else K=1-o,Q=o;return j.scaleInPlace(K),M.scaleInPlace(Q),g.M(j).addInPlace(M),g.scaleInPlace((0,t.Lerp)(R,S,o)),g}static SmoothToRef(D,h,o,H,g){return B.SlerpToRef(D,h,0===H?1:o/H,g),g}static Ih(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new B(D[h],D[h+1],D[h+2])}static FromFloatArray(D,h){return B.Ih(D,h)}static FromArrayToRef(D,h,o){return o._x=D[h],o._y=D[h+1],o._z=D[h+2],o._isDirty=!0,o}static FromFloatArrayToRef(D,h,o){return B.FromArrayToRef(D,h,o)}static FromFloatsToRef(D,h,o,H){return H.Qg(D,h,o),H}static Zero(){return new B(0,0,0)}static One(){return new B(1,1,1)}static Up(){return new B(0,1,0)}static get UpReadOnly(){return B._UpReadOnly}static get DownReadOnly(){return B._DownReadOnly}static get RightReadOnly(){return B._RightReadOnly}static get LeftReadOnly(){return B._LeftReadOnly}static get LeftHandedForwardReadOnly(){return B._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return B._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return B._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return B._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return B._ZeroReadOnly}static get OneReadOnly(){return B._OneReadOnly}static Down(){return new B(0,-1,0)}static Forward(){return new B(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new B(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new B(1,0,0)}static Left(){return new B(-1,0,0)}static Random(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new B((0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h))}static RandomToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Qg((0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h))}static TransformCoordinates(D,h){const o=B.Zero();return B.TransformCoordinatesToRef(D,h,o),o}static TransformCoordinatesToRef(D,h,o){return B.TransformCoordinatesFromFloatsToRef(D._x,D._y,D._z,h,o),o}static TransformCoordinatesFromFloatsToRef(D,h,o,H,g){const j=H.m,M=D*j[0]+h*j[4]+o*j[8]+j[12],R=D*j[1]+h*j[5]+o*j[9]+j[13],t=D*j[2]+h*j[6]+o*j[10]+j[14],S=1/(D*j[3]+h*j[7]+o*j[11]+j[15]);return g._x=M*S,g._y=R*S,g._z=t*S,g._isDirty=!0,g}static TransformNormal(D,h){const o=B.Zero();return B.TransformNormalToRef(D,h,o),o}static TransformNormalToRef(D,h,o){return this.TransformNormalFromFloatsToRef(D._x,D._y,D._z,h,o),o}static TransformNormalFromFloatsToRef(D,h,o,H,g){const j=H.m;return g._x=D*j[0]+h*j[4]+o*j[8],g._y=D*j[1]+h*j[5]+o*j[9],g._z=D*j[2]+h*j[6]+o*j[10],g._isDirty=!0,g}static CatmullRom(D,h,o,H,g){const j=g*g,M=g*j,R=.5*(2*h._x+(-D._x+o._x)*g+(2*D._x-5*h._x+4*o._x-H._x)*j+(-D._x+3*h._x-3*o._x+H._x)*M),t=.5*(2*h._y+(-D._y+o._y)*g+(2*D._y-5*h._y+4*o._y-H._y)*j+(-D._y+3*h._y-3*o._y+H._y)*M),S=.5*(2*h._z+(-D._z+o._z)*g+(2*D._z-5*h._z+4*o._z-H._z)*j+(-D._z+3*h._z-3*o._z+H._z)*M);return new B(R,t,S)}static Clamp(D,h,o){const H=new B;return B.ClampToRef(D,h,o,H),H}static ClampToRef(D,h,o,H){let g=D._x;g=g>o._x?o._x:g,g=g<h._x?h._x:g;let j=D._y;j=j>o._y?o._y:j,j=j<h._y?h._y:j;let M=D._z;return M=M>o._z?o._z:M,M=M<h._z?h._z:M,H.Qg(g,j,M),H}static CheckExtends(D,h,o){h.minimizeInPlace(D),o.maximizeInPlace(D)}static Hermite(D,h,o,H,g){const j=g*g,M=g*j,R=2*M-3*j+1,t=-2*M+3*j,S=M-2*j+g,k=M-j,K=D._x*R+o._x*t+h._x*S+H._x*k,Q=D._y*R+o._y*t+h._y*S+H._y*k,v=D._z*R+o._z*t+h._z*S+H._z*k;return new B(K,Q,v)}static Hermite1stDerivative(D,h,o,H,g){const j=new B;return this.Hermite1stDerivativeToRef(D,h,o,H,g,j),j}static Hermite1stDerivativeToRef(D,h,o,H,g,j){const M=g*g;return j._x=6*(M-g)*D._x+(3*M-4*g+1)*h._x+6*(-M+g)*o._x+(3*M-2*g)*H._x,j._y=6*(M-g)*D._y+(3*M-4*g+1)*h._y+6*(-M+g)*o._y+(3*M-2*g)*H._y,j._z=6*(M-g)*D._z+(3*M-4*g+1)*h._z+6*(-M+g)*o._z+(3*M-2*g)*H._z,j._isDirty=!0,j}static Lerp(D,h,o){const H=new B(0,0,0);return B.LerpToRef(D,h,o,H),H}static LerpToRef(D,h,o,H){return H._x=D._x+(h._x-D._x)*o,H._y=D._y+(h._y-D._y)*o,H._z=D._z+(h._z-D._z)*o,H._isDirty=!0,H}static Dot(D,h){return D._x*h._x+D._y*h._y+D._z*h._z}dot(D){return this._x*D._x+this._y*D._y+this._z*D._z}static Cross(D,h){const o=new B;return B.CrossToRef(D,h,o),o}static CrossToRef(D,h,o){const H=D._y*h._z-D._z*h._y,g=D._z*h._x-D._x*h._z,j=D._x*h._y-D._y*h._x;return o.Qg(H,g,j),o}static Normalize(D){const h=B.Zero();return B.NormalizeToRef(D,h),h}static NormalizeToRef(D,h){return D.normalizeToRef(h),h}static Project(D,h,o,H){const g=new B;return B.ProjectToRef(D,h,o,H,g),g}static ProjectToRef(D,h,o,H,g){var j;const M=H.width,t=H.height,S=H.x,k=H.y,K=c.Matrix[1],Q=null===(j=R.d.LastCreatedEngine)||void 0===j?void 0:j.isNDCHalfZRange,v=Q?1:.5,r=Q?0:.5;q.FromValuesToRef(M/2,0,0,0,0,-t/2,0,0,0,0,v,0,S+M/2,t/2+k,r,1,K);const s=c.Matrix[0];return h.multiplyToRef(o,s),s.multiplyToRef(K,s),B.TransformCoordinatesToRef(D,s,g),g}static Reflect(D,h){return this.ReflectToRef(D,h,new B)}static ReflectToRef(D,h,o){const H=y.Gh[0];return H.M(h).scaleInPlace(2*B.Dot(D,h)),o.M(D).zK(H)}static _UnprojectFromInvertedMatrixToRef(D,h,o){B.TransformCoordinatesToRef(D,h,o);const H=h.m,g=D._x*H[3]+D._y*H[7]+D._z*H[11]+H[15];return(0,t.WithinEpsilon)(g,1)&&o.scaleInPlace(1/g),o}static UnprojectFromTransform(D,h,o,H,g){return this.Unproject(D,h,o,H,g,q.IdentityReadOnly)}static Unproject(D,h,o,H,g,j){const M=new B;return B.UnprojectToRef(D,h,o,H,g,j,M),M}static UnprojectToRef(D,h,o,H,g,j,M){return B.UnprojectFloatsToRef(D._x,D._y,D._z,h,o,H,g,j,M),M}static UnprojectFloatsToRef(D,h,o,H,g,j,M,t,S){var k;const K=c.Matrix[0];j.multiplyToRef(M,K),K.multiplyToRef(t,K),K.invert();const Q=c.Gh[0];return Q.x=D/H*2-1,Q.y=-(h/g*2-1),null!==(k=R.d.LastCreatedEngine)&&void 0!==k&&k.isNDCHalfZRange?Q.z=o:Q.z=2*o-1,B._UnprojectFromInvertedMatrixToRef(Q,K,S),S}static Minimize(D,h){const o=new B;return o.M(D),o.minimizeInPlace(h),o}static Maximize(D,h){const o=new B;return o.M(D),o.maximizeInPlace(h),o}static Distance(D,h){return Math.sqrt(B.DistanceSquared(D,h))}static DistanceSquared(D,h){const o=D._x-h._x,H=D._y-h._y,g=D._z-h._z;return o*o+H*H+g*g}static ProjectOnTriangleToRef(D,h,o,g,j){const M=c.Gh[0],R=c.Gh[1],S=c.Gh[2],k=c.Gh[3],K=c.Gh[4];o.subtractToRef(h,M),g.subtractToRef(h,R),g.subtractToRef(o,S);const Q=M.length(),v=R.length(),r=S.length();if(Q<H.d||v<H.d||r<H.d)return j.M(h),B.Distance(D,h);D.subtractToRef(h,K),B.CrossToRef(M,R,k);const s=k.length();if(s<H.d)return j.M(h),B.Distance(D,h);k.normalizeFromLength(s);let U=K.length();if(U<H.d)return j.M(h),0;K.normalizeFromLength(U);const q=B.Dot(k,K),y=c.Gh[5],b=c.Gh[6];y.M(k).scaleInPlace(-U*q),b.M(D).addInPlace(y);const i=c.Gh[4],G=c.Gh[5],N=c.Gh[7],J=c.Gh[8];i.M(M).scaleInPlace(1/Q),J.M(R).scaleInPlace(1/v),i.addInPlace(J).scaleInPlace(-1),G.M(M).scaleInPlace(-1/Q),J.M(S).scaleInPlace(1/r),G.addInPlace(J).scaleInPlace(-1),N.M(S).scaleInPlace(-1/r),J.M(R).scaleInPlace(-1/v),N.addInPlace(J).scaleInPlace(-1);const O=c.Gh[9];let E;O.M(b).zK(h),B.CrossToRef(i,O,J),E=B.Dot(J,k);const L=E;O.M(b).zK(o),B.CrossToRef(G,O,J),E=B.Dot(J,k);const T=E;O.M(b).zK(g),B.CrossToRef(N,O,J),E=B.Dot(J,k);const Z=E,e=c.Gh[10];let p,mD;L>0&&T<0?(e.M(M),p=h,mD=o):T>0&&Z<0?(e.M(S),p=o,mD=g):(e.M(R).scaleInPlace(-1),p=g,mD=h);const a=c.Gh[9],u=c.Gh[4];p.subtractToRef(b,J),mD.subtractToRef(b,a),B.CrossToRef(J,a,u);if(!(B.Dot(u,k)<0))return j.M(b),Math.abs(U*q);const I=c.Gh[5];B.CrossToRef(e,u,I),I.normalize();const P=c.Gh[9];P.M(p).zK(b);const n=P.length();if(n<H.d)return j.M(p),B.Distance(D,p);P.normalizeFromLength(n);const F=B.Dot(I,P),w=c.Gh[7];w.M(b).addInPlace(I.scaleInPlace(n*F)),J.M(w).zK(p),U=e.length(),e.normalizeFromLength(U);let Y=B.Dot(J,e)/Math.max(U,H.d);return Y=(0,t.Clamp)(Y,0,1),w.M(p).addInPlace(e.scaleInPlace(Y*U)),j.M(w),B.Distance(D,w)}static Center(D,h){return B.CenterToRef(D,h,B.Zero())}static CenterToRef(D,h,o){return o.Qg((D._x+h._x)/2,(D._y+h._y)/2,(D._z+h._z)/2)}static RotationFromAxis(D,h,o){const H=new B;return B.RotationFromAxisToRef(D,h,o,H),H}static RotationFromAxisToRef(D,h,o,H){const g=c.Quaternion[0];return U.RotationQuaternionFromAxisToRef(D,h,o,g),g.toEulerAnglesToRef(H),H}}B._V8PerformanceHack=new B(.5,.5,.5),B._UpReadOnly=B.Up(),B._DownReadOnly=B.Down(),B._LeftHandedForwardReadOnly=B.Forward(!1),B._RightHandedForwardReadOnly=B.Forward(!0),B._LeftHandedBackwardReadOnly=B.Backward(!1),B._RightHandedBackwardReadOnly=B.Backward(!0),B._RightReadOnly=B.Right(),B._LeftReadOnly=B.Left(),B._ZeroReadOnly=B.Zero(),B._OneReadOnly=B.One(),Object.defineProperties(B.prototype,{dimension:{value:[3]},rank:{value:1}});class s{get x(){return this._x}set x(D){this._x=D,this._isDirty=!0}get y(){return this._y}set y(D){this._y=D,this._isDirty=!0}get z(){return this._z}set z(D){this._z=D,this._isDirty=!0}get w(){return this._w}set w(D){this._w=D,this._isDirty=!0}constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=D,this._y=h,this._z=o,this._w=H}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let D=v(this._x);return D=397*D^v(this._y),D=397*D^v(this._z),D=397*D^v(this._w),D}Fh(){return[this._x,this._y,this._z,this._w]}toArray(D,h){return void 0===h&&(h=0),D[h]=this._x,D[h+1]=this._y,D[h+2]=this._z,D[h+3]=this._w,this}lo(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s.FromArrayToRef(D,h,this),this}addInPlace(D){return this.x+=D._x,this.y+=D._y,this.z+=D._z,this.w+=D._w,this}addInPlaceFromFloats(D,h,o,H){return this.x+=D,this.y+=h,this.z+=o,this.w+=H,this}add(D){return new s(this._x+D.x,this._y+D.y,this._z+D.z,this._w+D.w)}addToRef(D,h){return h.x=this._x+D.x,h.y=this._y+D.y,h.z=this._z+D.z,h.w=this._w+D.w,h}zK(D){return this.x-=D.x,this.y-=D.y,this.z-=D.z,this.w-=D.w,this}Nh(D){return new s(this._x-D.x,this._y-D.y,this._z-D.z,this._w-D.w)}subtractToRef(D,h){return h.x=this._x-D.x,h.y=this._y-D.y,h.z=this._z-D.z,h.w=this._w-D.w,h}subtractFromFloats(D,h,o,H){return new s(this._x-D,this._y-h,this._z-o,this._w-H)}subtractFromFloatsToRef(D,h,o,H,g){return g.x=this._x-D,g.y=this._y-h,g.z=this._z-o,g.w=this._w-H,g}negate(){return new s(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(D){return D.x=-this._x,D.y=-this._y,D.z=-this._z,D.w=-this._w,D}scaleInPlace(D){return this.x*=D,this.y*=D,this.z*=D,this.w*=D,this}scale(D){return new s(this._x*D,this._y*D,this._z*D,this._w*D)}scaleToRef(D,h){return h.x=this._x*D,h.y=this._y*D,h.z=this._z*D,h.w=this._w*D,h}scaleAndAddToRef(D,h){return h.x+=this._x*D,h.y+=this._y*D,h.z+=this._z*D,h.w+=this._w*D,h}equals(D){return D&&this._x===D.x&&this._y===D.y&&this._z===D.z&&this._w===D.w}equalsWithEpsilon(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.d;return D&&(0,t.WithinEpsilon)(this._x,D.x,h)&&(0,t.WithinEpsilon)(this._y,D.y,h)&&(0,t.WithinEpsilon)(this._z,D.z,h)&&(0,t.WithinEpsilon)(this._w,D.w,h)}equalsToFloats(D,h,o,H){return this._x===D&&this._y===h&&this._z===o&&this._w===H}multiplyInPlace(D){return this.x*=D.x,this.y*=D.y,this.z*=D.z,this.w*=D.w,this}multiply(D){return new s(this._x*D.x,this._y*D.y,this._z*D.z,this._w*D.w)}multiplyToRef(D,h){return h.x=this._x*D.x,h.y=this._y*D.y,h.z=this._z*D.z,h.w=this._w*D.w,h}multiplyByFloats(D,h,o,H){return new s(this._x*D,this._y*h,this._z*o,this._w*H)}divide(D){return new s(this._x/D.x,this._y/D.y,this._z/D.z,this._w/D.w)}divideToRef(D,h){return h.x=this._x/D.x,h.y=this._y/D.y,h.z=this._z/D.z,h.w=this._w/D.w,h}divideInPlace(D){return this.divideToRef(D,this)}minimizeInPlace(D){return D.x<this._x&&(this.x=D.x),D.y<this._y&&(this.y=D.y),D.z<this._z&&(this.z=D.z),D.w<this._w&&(this.w=D.w),this}maximizeInPlace(D){return D.x>this._x&&(this.x=D.x),D.y>this._y&&(this.y=D.y),D.z>this._z&&(this.z=D.z),D.w>this._w&&(this.w=D.w),this}minimizeInPlaceFromFloats(D,h,o,H){return this.x=Math.min(D,this._x),this.y=Math.min(h,this._y),this.z=Math.min(o,this._z),this.w=Math.min(H,this._w),this}maximizeInPlaceFromFloats(D,h,o,H){return this.x=Math.max(D,this._x),this.y=Math.max(h,this._y),this.z=Math.max(o,this._z),this.w=Math.max(H,this._w),this}floorToRef(D){return D.x=Math.floor(this._x),D.y=Math.floor(this._y),D.z=Math.floor(this._z),D.w=Math.floor(this._w),D}floor(){return new s(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(D){return D.x=this._x-Math.floor(this._x),D.y=this._y-Math.floor(this._y),D.z=this._z-Math.floor(this._z),D.w=this._w-Math.floor(this._w),D}fract(){return new s(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(D){return 0===D||1===D?this:this.scaleInPlace(1/D)}normalizeToNew(){return this.normalizeToRef(new s)}normalizeToRef(D){const h=this.length();return 0===h||1===h?(D.x=this._x,D.y=this._y,D.z=this._z,D.w=this._w,D):this.scaleToRef(1/h,D)}toVector3(){return new B(this._x,this._y,this._z)}clone(){return new s(this._x,this._y,this._z,this._w)}M(D){return this.x=D.x,this.y=D.y,this.z=D.z,this.w=D.w,this}Qg(D,h,o,H){return this.x=D,this.y=h,this.z=o,this.w=H,this}set(D,h,o,H){return this.Qg(D,h,o,H)}qg(D){return this.x=this.y=this.z=this.w=D,this}dot(D){return this._x*D.x+this._y*D.y+this._z*D.z+this._w*D.w}static Ih(D,h){return h||(h=0),new s(D[h],D[h+1],D[h+2],D[h+3])}static FromArrayToRef(D,h,o){return o.x=D[h],o.y=D[h+1],o.z=D[h+2],o.w=D[h+3],o}static FromFloatArrayToRef(D,h,o){return s.FromArrayToRef(D,h,o),o}static FromFloatsToRef(D,h,o,H,g){return g.x=D,g.y=h,g.z=o,g.w=H,g}static Zero(){return new s(0,0,0,0)}static One(){return new s(1,1,1,1)}static Random(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new s((0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h))}static RandomToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments.length>2?arguments[2]:void 0;return o.x=(0,t.RandomRange)(D,h),o.y=(0,t.RandomRange)(D,h),o.z=(0,t.RandomRange)(D,h),o.w=(0,t.RandomRange)(D,h),o}static Clamp(D,h,o){return s.ClampToRef(D,h,o,new s)}static ClampToRef(D,h,o,H){return H.x=(0,t.Clamp)(D.x,h.x,o.x),H.y=(0,t.Clamp)(D.y,h.y,o.y),H.z=(0,t.Clamp)(D.z,h.z,o.z),H.w=(0,t.Clamp)(D.w,h.w,o.w),H}static CheckExtends(D,h,o){h.minimizeInPlace(D),o.maximizeInPlace(D)}static get ZeroReadOnly(){return s._ZeroReadOnly}static Normalize(D){return s.NormalizeToRef(D,new s)}static NormalizeToRef(D,h){return D.normalizeToRef(h),h}static Minimize(D,h){const o=new s;return o.M(D),o.minimizeInPlace(h),o}static Maximize(D,h){const o=new s;return o.M(D),o.maximizeInPlace(h),o}static Distance(D,h){return Math.sqrt(s.DistanceSquared(D,h))}static DistanceSquared(D,h){const o=D.x-h.x,H=D.y-h.y,g=D.z-h.z,j=D.w-h.w;return o*o+H*H+g*g+j*j}static Center(D,h){return s.CenterToRef(D,h,new s)}static CenterToRef(D,h,o){return o.x=(D.x+h.x)/2,o.y=(D.y+h.y)/2,o.z=(D.z+h.z)/2,o.w=(D.w+h.w)/2,o}static TransformCoordinates(D,h){return s.TransformCoordinatesToRef(D,h,new s)}static TransformCoordinatesToRef(D,h,o){return s.TransformCoordinatesFromFloatsToRef(D._x,D._y,D._z,h,o),o}static TransformCoordinatesFromFloatsToRef(D,h,o,H,g){const j=H.m,M=D*j[0]+h*j[4]+o*j[8]+j[12],R=D*j[1]+h*j[5]+o*j[9]+j[13],t=D*j[2]+h*j[6]+o*j[10]+j[14],S=D*j[3]+h*j[7]+o*j[11]+j[15];return g.x=M,g.y=R,g.z=t,g.w=S,g}static TransformNormal(D,h){return s.TransformNormalToRef(D,h,new s)}static TransformNormalToRef(D,h,o){const H=h.m,g=D.x*H[0]+D.y*H[4]+D.z*H[8],j=D.x*H[1]+D.y*H[5]+D.z*H[9],M=D.x*H[2]+D.y*H[6]+D.z*H[10];return o.x=g,o.y=j,o.z=M,o.w=D.w,o}static TransformNormalFromFloatsToRef(D,h,o,H,g,j){const M=g.m;return j.x=D*M[0]+h*M[4]+o*M[8],j.y=D*M[1]+h*M[5]+o*M[9],j.z=D*M[2]+h*M[6]+o*M[10],j.w=H,j}static FromVector3(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new s(D._x,D._y,D._z,h)}static Dot(D,h){return D.x*h.x+D.y*h.y+D.z*h.z+D.w*h.w}}s._V8PerformanceHack=new s(.5,.5,.5,.5),s._ZeroReadOnly=s.Zero(),Object.defineProperties(s.prototype,{dimension:{value:[4]},rank:{value:1}});class U{get x(){return this._x}set x(D){this._x=D,this._isDirty=!0}get y(){return this._y}set y(D){this._y=D,this._isDirty=!0}get z(){return this._z}set z(D){this._z=D,this._isDirty=!0}get w(){return this._w}set w(D){this._w=D,this._isDirty=!0}constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=D,this._y=h,this._z=o,this._w=H}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let D=v(this._x);return D=397*D^v(this._y),D=397*D^v(this._z),D=397*D^v(this._w),D}Fh(){return[this._x,this._y,this._z,this._w]}toArray(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D[h]=this._x,D[h+1]=this._y,D[h+2]=this._z,D[h+3]=this._w,this}lo(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U.FromArrayToRef(D,h,this)}equals(D){return D&&this._x===D._x&&this._y===D._y&&this._z===D._z&&this._w===D._w}equalsWithEpsilon(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.d;return D&&(0,t.WithinEpsilon)(this._x,D._x,h)&&(0,t.WithinEpsilon)(this._y,D._y,h)&&(0,t.WithinEpsilon)(this._z,D._z,h)&&(0,t.WithinEpsilon)(this._w,D._w,h)}isApprox(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.d;return D&&((0,t.WithinEpsilon)(this._x,D._x,h)&&(0,t.WithinEpsilon)(this._y,D._y,h)&&(0,t.WithinEpsilon)(this._z,D._z,h)&&(0,t.WithinEpsilon)(this._w,D._w,h)||(0,t.WithinEpsilon)(this._x,-D._x,h)&&(0,t.WithinEpsilon)(this._y,-D._y,h)&&(0,t.WithinEpsilon)(this._z,-D._z,h)&&(0,t.WithinEpsilon)(this._w,-D._w,h))}clone(){return new U(this._x,this._y,this._z,this._w)}M(D){return this._x=D._x,this._y=D._y,this._z=D._z,this._w=D._w,this._isDirty=!0,this}Qg(D,h,o,H){return this._x=D,this._y=h,this._z=o,this._w=H,this._isDirty=!0,this}set(D,h,o,H){return this.Qg(D,h,o,H)}qg(D){return this.Qg(D,D,D,D)}add(D){return new U(this._x+D._x,this._y+D._y,this._z+D._z,this._w+D._w)}addInPlace(D){return this._x+=D._x,this._y+=D._y,this._z+=D._z,this._w+=D._w,this._isDirty=!0,this}addToRef(D,h){return h._x=this._x+D._x,h._y=this._y+D._y,h._z=this._z+D._z,h._w=this._w+D._w,h._isDirty=!0,h}addInPlaceFromFloats(D,h,o,H){return this._x+=D,this._y+=h,this._z+=o,this._w+=H,this._isDirty=!0,this}subtractToRef(D,h){return h._x=this._x-D._x,h._y=this._y-D._y,h._z=this._z-D._z,h._w=this._w-D._w,h._isDirty=!0,h}subtractFromFloats(D,h,o,H){return this.subtractFromFloatsToRef(D,h,o,H,new U)}subtractFromFloatsToRef(D,h,o,H,g){return g._x=this._x-D,g._y=this._y-h,g._z=this._z-o,g._w=this._w-H,g._isDirty=!0,g}Nh(D){return new U(this._x-D._x,this._y-D._y,this._z-D._z,this._w-D._w)}zK(D){return this._x-=D._x,this._y-=D._y,this._z-=D._z,this._w-=D._w,this._isDirty=!0,this}scale(D){return new U(this._x*D,this._y*D,this._z*D,this._w*D)}scaleToRef(D,h){return h._x=this._x*D,h._y=this._y*D,h._z=this._z*D,h._w=this._w*D,h._isDirty=!0,h}scaleInPlace(D){return this._x*=D,this._y*=D,this._z*=D,this._w*=D,this._isDirty=!0,this}scaleAndAddToRef(D,h){return h._x+=this._x*D,h._y+=this._y*D,h._z+=this._z*D,h._w+=this._w*D,h._isDirty=!0,h}multiply(D){const h=new U(0,0,0,1);return this.multiplyToRef(D,h),h}multiplyToRef(D,h){const o=this._x*D._w+this._y*D._z-this._z*D._y+this._w*D._x,H=-this._x*D._z+this._y*D._w+this._z*D._x+this._w*D._y,g=this._x*D._y-this._y*D._x+this._z*D._w+this._w*D._z,j=-this._x*D._x-this._y*D._y-this._z*D._z+this._w*D._w;return h.Qg(o,H,g,j),h}multiplyInPlace(D){return this.multiplyToRef(D,this)}multiplyByFloats(D,h,o,H){return this._x*=D,this._y*=h,this._z*=o,this._w*=H,this._isDirty=!0,this}divide(D){throw new ReferenceError("Can not divide a quaternion")}divideToRef(D,h){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(D){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new U)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(D){return D._x=-this._x,D._y=-this._y,D._z=-this._z,D._w=-this._w,D._isDirty=!0,D}equalsToFloats(D,h,o,H){return this._x===D&&this._y===h&&this._z===o&&this._w===H}floorToRef(D){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(D){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(D){return D.Qg(-this._x,-this._y,-this._z,this._w),D}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new U(-this._x,-this._y,-this._z,this._w)}invert(){const D=this.conjugate(),h=this.lengthSquared();return 0==h||1==h||D.scaleInPlace(1/h),D}invertInPlace(){this.conjugateInPlace();const D=this.lengthSquared();return 0==D||1==D||this.scaleInPlace(1/D),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(D){return 0===D||1===D?this:this.scaleInPlace(1/D)}normalizeToNew(){const D=new U(0,0,0,1);return this.normalizeToRef(D),D}normalizeToRef(D){const h=this.length();return 0===h||1===h?D.Qg(this._x,this._y,this._z,this._w):this.scaleToRef(1/h,D)}toEulerAngles(){const D=B.Zero();return this.toEulerAnglesToRef(D),D}toEulerAnglesToRef(D){const h=this._z,o=this._x,H=this._y,g=this._w,j=H*h-o*g,M=.4999999;if(j<-M)D._y=2*Math.atan2(H,g),D._x=Math.PI/2,D._z=0,D._isDirty=!0;else if(j>M)D._y=2*Math.atan2(H,g),D._x=-Math.PI/2,D._z=0,D._isDirty=!0;else{const M=g*g,R=h*h,t=o*o,S=H*H;D._z=Math.atan2(2*(o*H+h*g),-R-t+S+M),D._x=Math.asin(-2*j),D._y=Math.atan2(2*(h*o+H*g),R-t-S+M),D._isDirty=!0}return D}toAlphaBetaGammaToRef(D){const h=this._z,o=this._x,H=this._y,g=this._w,j=Math.sqrt(o*o+H*H),M=Math.sqrt(h*h+g*g),R=2*Math.atan2(j,M),t=2*Math.atan2(h,g),S=2*Math.atan2(H,o),k=(t+S)/2,K=(t-S)/2;return D.set(K,R,k),D}toRotationMatrix(D){return q.FromQuaternionToRef(this,D),D}fromRotationMatrix(D){return U.FromRotationMatrixToRef(D,this),this}dot(D){return this._x*D._x+this._y*D._y+this._z*D._z+this._w*D._w}toAxisAngle(){const D=B.Zero();return{axis:D,angle:this.toAxisAngleToRef(D)}}toAxisAngleToRef(D){let h=0;const o=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),H=this._w;return o>0?(h=2*Math.atan2(o,H),D.set(this._x/o,this._y/o,this._z/o)):(h=0,D.set(1,0,0)),h}static FromRotationMatrix(D){const h=new U;return U.FromRotationMatrixToRef(D,h),h}static FromRotationMatrixToRef(D,h){const o=D.m,H=o[0],g=o[4],j=o[8],M=o[1],R=o[5],t=o[9],S=o[2],k=o[6],K=o[10],Q=H+R+K;let v;return Q>0?(v=.5/Math.sqrt(Q+1),h._w=.25/v,h._x=(k-t)*v,h._y=(j-S)*v,h._z=(M-g)*v,h._isDirty=!0):H>R&&H>K?(v=2*Math.sqrt(1+H-R-K),h._w=(k-t)/v,h._x=.25*v,h._y=(g+M)/v,h._z=(j+S)/v,h._isDirty=!0):R>K?(v=2*Math.sqrt(1+R-H-K),h._w=(j-S)/v,h._x=(g+M)/v,h._y=.25*v,h._z=(t+k)/v,h._isDirty=!0):(v=2*Math.sqrt(1+K-H-R),h._w=(M-g)/v,h._x=(j+S)/v,h._y=(t+k)/v,h._z=.25*v,h._isDirty=!0),h}static Dot(D,h){return D._x*h._x+D._y*h._y+D._z*h._z+D._w*h._w}static AreClose(D,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const H=U.Dot(D,h);return 1-H*H<=o}static SmoothToRef(D,h,o,H,g){let j=0===H?1:o/H;return j=(0,t.Clamp)(j,0,1),U.SlerpToRef(D,h,j,g),g}static Zero(){return new U(0,0,0,0)}static Inverse(D){return new U(-D._x,-D._y,-D._z,D._w)}static InverseToRef(D,h){return h.set(-D._x,-D._y,-D._z,D._w),h}static Identity(){return new U(0,0,0,1)}static IsIdentity(D){return D&&0===D._x&&0===D._y&&0===D._z&&1===D._w}static RotationAxis(D,h){return U.RotationAxisToRef(D,h,new U)}static RotationAxisToRef(D,h,o){o._w=Math.cos(h/2);const H=Math.sin(h/2)/D.length();return o._x=D._x*H,o._y=D._y*H,o._z=D._z*H,o._isDirty=!0,o}static Ih(D,h){return h||(h=0),new U(D[h],D[h+1],D[h+2],D[h+3])}static FromArrayToRef(D,h,o){return o._x=D[h],o._y=D[h+1],o._z=D[h+2],o._w=D[h+3],o._isDirty=!0,o}static FromFloatsToRef(D,h,o,H,g){return g.Qg(D,h,o,H),g}static FromEulerAngles(D,h,o){const H=new U;return U.RotationYawPitchRollToRef(h,D,o,H),H}static FromEulerAnglesToRef(D,h,o,H){return U.RotationYawPitchRollToRef(h,D,o,H),H}static FromEulerVector(D){const h=new U;return U.RotationYawPitchRollToRef(D._y,D._x,D._z,h),h}static FromEulerVectorToRef(D,h){return U.RotationYawPitchRollToRef(D._y,D._x,D._z,h),h}static FromUnitVectorsToRef(D,h,o){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:H.d;const j=B.Dot(D,h)+1;return j<g?Math.abs(D.x)>Math.abs(D.z)?o.set(-D.y,D.x,0,0):o.set(0,-D.z,D.y,0):(B.CrossToRef(D,h,y.Gh[0]),o.set(y.Gh[0].x,y.Gh[0].y,y.Gh[0].z,j)),o.normalize()}static RotationYawPitchRoll(D,h,o){const H=new U;return U.RotationYawPitchRollToRef(D,h,o,H),H}static RotationYawPitchRollToRef(D,h,o,H){const g=.5*o,j=.5*h,M=.5*D,R=Math.sin(g),t=Math.cos(g),S=Math.sin(j),k=Math.cos(j),K=Math.sin(M),Q=Math.cos(M);return H._x=Q*S*t+K*k*R,H._y=K*k*t-Q*S*R,H._z=Q*k*R-K*S*t,H._w=Q*k*t+K*S*R,H._isDirty=!0,H}static RotationAlphaBetaGamma(D,h,o){const H=new U;return U.RotationAlphaBetaGammaToRef(D,h,o,H),H}static RotationAlphaBetaGammaToRef(D,h,o,H){const g=.5*(o+D),j=.5*(o-D),M=.5*h;return H._x=Math.cos(j)*Math.sin(M),H._y=Math.sin(j)*Math.sin(M),H._z=Math.sin(g)*Math.cos(M),H._w=Math.cos(g)*Math.cos(M),H._isDirty=!0,H}static RotationQuaternionFromAxis(D,h,o){const H=new U(0,0,0,0);return U.RotationQuaternionFromAxisToRef(D,h,o,H),H}static RotationQuaternionFromAxisToRef(D,h,o,H){const g=c.Matrix[0];return D=D.normalizeToRef(c.Gh[0]),h=h.normalizeToRef(c.Gh[1]),o=o.normalizeToRef(c.Gh[2]),q.FromXYZAxesToRef(D,h,o,g),U.FromRotationMatrixToRef(g,H),H}static FromLookDirectionLH(D,h){const o=new U;return U.FromLookDirectionLHToRef(D,h,o),o}static FromLookDirectionLHToRef(D,h,o){const H=c.Matrix[0];return q.LookDirectionLHToRef(D,h,H),U.FromRotationMatrixToRef(H,o),o}static FromLookDirectionRH(D,h){const o=new U;return U.FromLookDirectionRHToRef(D,h,o),o}static FromLookDirectionRHToRef(D,h,o){const H=c.Matrix[0];return q.LookDirectionRHToRef(D,h,H),U.FromRotationMatrixToRef(H,o)}static Slerp(D,h,o){const H=U.Identity();return U.SlerpToRef(D,h,o,H),H}static SlerpToRef(D,h,o,H){let g,j,M=D._x*h._x+D._y*h._y+D._z*h._z+D._w*h._w,R=!1;if(M<0&&(R=!0,M=-M),M>.999999)j=1-o,g=R?-o:o;else{const D=Math.acos(M),h=1/Math.sin(D);j=Math.sin((1-o)*D)*h,g=R?-Math.sin(o*D)*h:Math.sin(o*D)*h}return H._x=j*D._x+g*h._x,H._y=j*D._y+g*h._y,H._z=j*D._z+g*h._z,H._w=j*D._w+g*h._w,H._isDirty=!0,H}static Hermite(D,h,o,H,g){const j=g*g,M=g*j,R=2*M-3*j+1,t=-2*M+3*j,S=M-2*j+g,k=M-j,K=D._x*R+o._x*t+h._x*S+H._x*k,Q=D._y*R+o._y*t+h._y*S+H._y*k,v=D._z*R+o._z*t+h._z*S+H._z*k,r=D._w*R+o._w*t+h._w*S+H._w*k;return new U(K,Q,v,r)}static Hermite1stDerivative(D,h,o,H,g){const j=new U;return this.Hermite1stDerivativeToRef(D,h,o,H,g,j),j}static Hermite1stDerivativeToRef(D,h,o,H,g,j){const M=g*g;return j._x=6*(M-g)*D._x+(3*M-4*g+1)*h._x+6*(-M+g)*o._x+(3*M-2*g)*H._x,j._y=6*(M-g)*D._y+(3*M-4*g+1)*h._y+6*(-M+g)*o._y+(3*M-2*g)*H._y,j._z=6*(M-g)*D._z+(3*M-4*g+1)*h._z+6*(-M+g)*o._z+(3*M-2*g)*H._z,j._w=6*(M-g)*D._w+(3*M-4*g+1)*h._w+6*(-M+g)*o._w+(3*M-2*g)*H._w,j._isDirty=!0,j}static Normalize(D){const h=U.Zero();return U.NormalizeToRef(D,h),h}static NormalizeToRef(D,h){return D.normalizeToRef(h),h}static Clamp(D,h,o){const H=new U;return U.ClampToRef(D,h,o,H),H}static ClampToRef(D,h,o,H){return H.Qg((0,t.Clamp)(D.x,h.x,o.x),(0,t.Clamp)(D.y,h.y,o.y),(0,t.Clamp)(D.z,h.z,o.z),(0,t.Clamp)(D.w,h.w,o.w))}static Random(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new U((0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h))}static RandomToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Qg((0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h),(0,t.RandomRange)(D,h))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(D,h){return Math.sqrt(U.DistanceSquared(D,h))}static DistanceSquared(D,h){const o=D.x-h.x,H=D.y-h.y,g=D.z-h.z,j=D.w-h.w;return o*o+H*H+g*g+j*j}static Center(D,h){return U.CenterToRef(D,h,U.Zero())}static CenterToRef(D,h,o){return o.Qg((D.x+h.x)/2,(D.y+h.y)/2,(D.z+h.z)/2,(D.w+h.w)/2)}}U._V8PerformanceHack=new U(.5,.5,.5,.5),Object.defineProperties(U.prototype,{dimension:{value:[4]},rank:{value:1}});class q{static get Use64Bits(){return M.b.MatrixUse64Bits}get m(){return this.Eh}markAsUpdated(){this.updateFlag=S._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(D){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=D,this._isIdentity3x2=D||o,this._isIdentityDirty=!this._isIdentity&&h,this._isIdentity3x2Dirty=!this._isIdentity3x2&&H}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,M.b.MatrixTrackPrecisionChange&&M.b.MatrixTrackedMatrices.push(this),this.Eh=new M.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const D=this.Eh;this._isIdentity=1===D[0]&&0===D[1]&&0===D[2]&&0===D[3]&&0===D[4]&&1===D[5]&&0===D[6]&&0===D[7]&&0===D[8]&&0===D[9]&&1===D[10]&&0===D[11]&&0===D[12]&&0===D[13]&&0===D[14]&&1===D[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Eh[0]||1!==this.Eh[5]||1!==this.Eh[15]||0!==this.Eh[1]||0!==this.Eh[2]||0!==this.Eh[3]||0!==this.Eh[4]||0!==this.Eh[6]||0!==this.Eh[7]||0!==this.Eh[8]||0!==this.Eh[9]||0!==this.Eh[10]||0!==this.Eh[11]||0!==this.Eh[12]||0!==this.Eh[13]||0!==this.Eh[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const D=this.Eh,h=D[0],o=D[1],H=D[2],g=D[3],j=D[4],M=D[5],R=D[6],t=D[7],S=D[8],k=D[9],K=D[10],Q=D[11],v=D[12],r=D[13],B=D[14],s=D[15],U=K*s-B*Q,q=k*s-r*Q,c=k*B-r*K,y=S*s-v*Q,b=S*B-K*v,i=S*r-v*k;return h*+(M*U-R*q+t*c)+o*-(j*U-R*y+t*b)+H*+(j*q-M*y+t*i)+g*-(j*c-M*b+R*i)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!D)return this.Eh;const o=this.Eh;for(let H=0;H<16;H++)D[h+H]=o[H];return this}Fh(){return this.Eh}lo(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q.FromArrayToRef(D,h,this)}Qg(){for(var D=arguments.length,h=new Array(D),o=0;o<D;o++)h[o]=arguments[o];return q.FromArrayToRef(h,0,this)}set(){const D=this.Eh;for(let h=0;h<16;h++)D[h]=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}qg(D){const h=this.Eh;for(let o=0;o<16;o++)h[o]=D;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return q.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(D){const h=new q;return this.addToRef(D,h),h}addToRef(D,h){const o=this.Eh,H=h.Eh,g=D.m;for(let j=0;j<16;j++)H[j]=o[j]+g[j];return h.markAsUpdated(),h}addToSelf(D){const h=this.Eh,o=D.m;return h[0]+=o[0],h[1]+=o[1],h[2]+=o[2],h[3]+=o[3],h[4]+=o[4],h[5]+=o[5],h[6]+=o[6],h[7]+=o[7],h[8]+=o[8],h[9]+=o[9],h[10]+=o[10],h[11]+=o[11],h[12]+=o[12],h[13]+=o[13],h[14]+=o[14],h[15]+=o[15],this.markAsUpdated(),this}addInPlace(D){const h=this.Eh,o=D.m;for(let H=0;H<16;H++)h[H]+=o[H];return this.markAsUpdated(),this}addInPlaceFromFloats(){const D=this.Eh;for(let h=0;h<16;h++)D[h]+=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}Nh(D){const h=this.Eh,o=D.m;for(let H=0;H<16;H++)h[H]-=o[H];return this.markAsUpdated(),this}subtractToRef(D,h){const o=this.Eh,H=D.m,g=h.Eh;for(let j=0;j<16;j++)g[j]=o[j]-H[j];return h.markAsUpdated(),h}zK(D){const h=this.Eh,o=D.m;for(let H=0;H<16;H++)h[H]-=o[H];return this.markAsUpdated(),this}subtractFromFloats(){for(var D=arguments.length,h=new Array(D),o=0;o<D;o++)h[o]=arguments[o];return this.subtractFromFloatsToRef(...h,new q)}subtractFromFloatsToRef(){for(var D=arguments.length,h=new Array(D),o=0;o<D;o++)h[o]=arguments[o];const H=h.pop(),g=this.Eh,j=H.Eh,M=h;for(let R=0;R<16;R++)j[R]=g[R]-M[R];return H.markAsUpdated(),H}invertToRef(D){return!0===this._isIdentity?(q.IdentityToRef(D),D):(Q(this,D.Fh())?D.markAsUpdated():D.M(this),D)}addAtIndex(D,h){return this.Eh[D]+=h,this.markAsUpdated(),this}multiplyAtIndex(D,h){return this.Eh[D]*=h,this.markAsUpdated(),this}setTranslationFromFloats(D,h,o){return this.Eh[12]=D,this.Eh[13]=h,this.Eh[14]=o,this.markAsUpdated(),this}addTranslationFromFloats(D,h,o){return this.Eh[12]+=D,this.Eh[13]+=h,this.Eh[14]+=o,this.markAsUpdated(),this}setTranslation(D){return this.setTranslationFromFloats(D._x,D._y,D._z)}getTranslation(){return new B(this.Eh[12],this.Eh[13],this.Eh[14])}getTranslationToRef(D){return D.x=this.Eh[12],D.y=this.Eh[13],D.z=this.Eh[14],D}removeRotationAndScaling(){const D=this.m;return q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,D[12],D[13],D[14],D[15],this),this._updateIdentityStatus(0===D[12]&&0===D[13]&&0===D[14]&&1===D[15]),this}M(D){D.copyToArray(this.Eh);const h=D;return this.updateFlag=h.updateFlag,this._updateIdentityStatus(h._isIdentity,h._isIdentityDirty,h._isIdentity3x2,h._isIdentity3x2Dirty),this}copyToArray(D){return K(this,D,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(D){const h=new q;return this.multiplyToRef(D,h),h}multiplyInPlace(D){const h=this.Eh,o=D.m;for(let H=0;H<16;H++)h[H]*=o[H];return this.markAsUpdated(),this}multiplyByFloats(){const D=this.Eh;for(let h=0;h<16;h++)D[h]*=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var D=arguments.length,h=new Array(D),o=0;o<D;o++)h[o]=arguments[o];const H=h.pop(),g=this.Eh,j=H.Eh,M=h;for(let R=0;R<16;R++)j[R]=g[R]*M[R];return H.markAsUpdated(),H}multiplyToRef(D,h){return this._isIdentity?(h.M(D),h):D._isIdentity?(h.M(this),h):(this.multiplyToArray(D,h.Eh,0),h.markAsUpdated(),h)}multiplyToArray(D,h,o){return k(this,D,h,o),this}divide(D){return this.divideToRef(D,new q)}divideToRef(D,h){const o=this.Eh,H=D.m,g=h.Eh;for(let j=0;j<16;j++)g[j]=o[j]/H[j];return h.markAsUpdated(),h}divideInPlace(D){const h=this.Eh,o=D.m;for(let H=0;H<16;H++)h[H]/=o[H];return this.markAsUpdated(),this}minimizeInPlace(D){const h=this.Eh,o=D.m;for(let H=0;H<16;H++)h[H]=Math.min(h[H],o[H]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const D=this.Eh;for(let h=0;h<16;h++)D[h]=Math.min(D[h],h<0||arguments.length<=h?void 0:arguments[h]);return this.markAsUpdated(),this}maximizeInPlace(D){const h=this.Eh,o=D.m;for(let H=0;H<16;H++)h[H]=Math.min(h[H],o[H]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const D=this.Eh;for(let h=0;h<16;h++)D[h]=Math.min(D[h],h<0||arguments.length<=h?void 0:arguments[h]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new q)}negateInPlace(){const D=this.Eh;for(let h=0;h<16;h++)D[h]=-D[h];return this.markAsUpdated(),this}negateToRef(D){const h=this.Eh,o=D.Eh;for(let H=0;H<16;H++)o[H]=-h[H];return D.markAsUpdated(),D}equals(D){const h=D;if(!h)return!1;if((this._isIdentity||h._isIdentity)&&!this._isIdentityDirty&&!h._isIdentityDirty)return this._isIdentity&&h._isIdentity;const o=this.m,H=h.m;return o[0]===H[0]&&o[1]===H[1]&&o[2]===H[2]&&o[3]===H[3]&&o[4]===H[4]&&o[5]===H[5]&&o[6]===H[6]&&o[7]===H[7]&&o[8]===H[8]&&o[9]===H[9]&&o[10]===H[10]&&o[11]===H[11]&&o[12]===H[12]&&o[13]===H[13]&&o[14]===H[14]&&o[15]===H[15]}equalsWithEpsilon(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=this.Eh,H=D.m;for(let g=0;g<16;g++)if(!(0,t.WithinEpsilon)(o[g],H[g],h))return!1;return!0}equalsToFloats(){const D=this.Eh;for(let h=0;h<16;h++)if(D[h]!=(h<0||arguments.length<=h?void 0:arguments[h]))return!1;return!0}floor(){return this.floorToRef(new q)}floorToRef(D){const h=this.Eh,o=D.Eh;for(let H=0;H<16;H++)o[H]=Math.floor(h[H]);return D.markAsUpdated(),D}fract(){return this.fractToRef(new q)}fractToRef(D){const h=this.Eh,o=D.Eh;for(let H=0;H<16;H++)o[H]=h[H]-Math.floor(h[H]);return D.markAsUpdated(),D}clone(){const D=new q;return D.M(this),D}getClassName(){return"Matrix"}getHashCode(){let D=v(this.Eh[0]);for(let h=1;h<16;h++)D=397*D^v(this.Eh[h]);return D}decomposeToTransformNode(D){return D.rotationQuaternion=D.rotationQuaternion||new U,this.decompose(D.Ug,D.rotationQuaternion,D.position)}decompose(D,h,o,H){let g=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return o&&o.qg(0),D&&D.qg(1),h&&h.Qg(0,0,0,1),!0;const j=this.Eh;if(o&&o.Qg(j[12],j[13],j[14]),(D=D||c.Gh[0]).x=Math.sqrt(j[0]*j[0]+j[1]*j[1]+j[2]*j[2]),D.y=Math.sqrt(j[4]*j[4]+j[5]*j[5]+j[6]*j[6]),D.z=Math.sqrt(j[8]*j[8]+j[9]*j[9]+j[10]*j[10]),H){const h=(g?H.absoluteScaling.x:H.Ug.x)<0?-1:1,o=(g?H.absoluteScaling.y:H.Ug.y)<0?-1:1,j=(g?H.absoluteScaling.z:H.Ug.z)<0?-1:1;D.x*=h,D.y*=o,D.z*=j}else this.determinant()<=0&&(D.y*=-1);if(0===D._x||0===D._y||0===D._z)return h&&h.Qg(0,0,0,1),!1;if(h){const o=1/D._x,H=1/D._y,g=1/D._z;q.FromValuesToRef(j[0]*o,j[1]*o,j[2]*o,0,j[4]*H,j[5]*H,j[6]*H,0,j[8]*g,j[9]*g,j[10]*g,0,0,0,0,1,c.Matrix[0]),U.FromRotationMatrixToRef(c.Matrix[0],h)}return!0}getRow(D){if(D<0||D>3)return null;const h=4*D;return new s(this.Eh[h+0],this.Eh[h+1],this.Eh[h+2],this.Eh[h+3])}getRowToRef(D,h){if(D>=0&&D<=3){const o=4*D;h.x=this.Eh[o+0],h.y=this.Eh[o+1],h.z=this.Eh[o+2],h.w=this.Eh[o+3]}return h}setRow(D,h){return this.setRowFromFloats(D,h.x,h.y,h.z,h.w)}transpose(){const D=new q;return q.TransposeToRef(this,D),D}transposeToRef(D){return q.TransposeToRef(this,D),D}setRowFromFloats(D,h,o,H,g){if(D<0||D>3)return this;const j=4*D;return this.Eh[j+0]=h,this.Eh[j+1]=o,this.Eh[j+2]=H,this.Eh[j+3]=g,this.markAsUpdated(),this}scale(D){const h=new q;return this.scaleToRef(D,h),h}scaleToRef(D,h){for(let o=0;o<16;o++)h.Eh[o]=this.Eh[o]*D;return h.markAsUpdated(),h}scaleAndAddToRef(D,h){for(let o=0;o<16;o++)h.Eh[o]+=this.Eh[o]*D;return h.markAsUpdated(),h}scaleInPlace(D){const h=this.Eh;for(let o=0;o<16;o++)h[o]*=D;return this.markAsUpdated(),this}toNormalMatrix(D){const h=c.Matrix[0];this.invertToRef(h),h.transposeToRef(D);const o=D.Eh;return q.FromValuesToRef(o[0],o[1],o[2],0,o[4],o[5],o[6],0,o[8],o[9],o[10],0,0,0,0,1,D),D}getRotationMatrix(){const D=new q;return this.getRotationMatrixToRef(D),D}getRotationMatrixToRef(D){const h=c.Gh[0];if(!this.decompose(h))return q.IdentityToRef(D),D;const o=this.Eh,H=1/h._x,g=1/h._y,j=1/h._z;return q.FromValuesToRef(o[0]*H,o[1]*H,o[2]*H,0,o[4]*g,o[5]*g,o[6]*g,0,o[8]*j,o[9]*j,o[10]*j,0,0,0,0,1,D),D}toggleModelMatrixHandInPlace(){const D=this.Eh;return D[2]*=-1,D[6]*=-1,D[8]*=-1,D[9]*=-1,D[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const D=this.Eh;return D[8]*=-1,D[9]*=-1,D[10]*=-1,D[11]*=-1,this.markAsUpdated(),this}static Ih(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=new q;return q.FromArrayToRef(D,h,o),o}static FromArrayToRef(D,h,o){for(let H=0;H<16;H++)o.Eh[H]=D[H+h];return o.markAsUpdated(),o}static FromFloat32ArrayToRefScaled(D,h,o,H){return H.Eh[0]=D[0+h]*o,H.Eh[1]=D[1+h]*o,H.Eh[2]=D[2+h]*o,H.Eh[3]=D[3+h]*o,H.Eh[4]=D[4+h]*o,H.Eh[5]=D[5+h]*o,H.Eh[6]=D[6+h]*o,H.Eh[7]=D[7+h]*o,H.Eh[8]=D[8+h]*o,H.Eh[9]=D[9+h]*o,H.Eh[10]=D[10+h]*o,H.Eh[11]=D[11+h]*o,H.Eh[12]=D[12+h]*o,H.Eh[13]=D[13+h]*o,H.Eh[14]=D[14+h]*o,H.Eh[15]=D[15+h]*o,H.markAsUpdated(),H}static get IdentityReadOnly(){return q._IdentityReadOnly}static FromValuesToRef(D,h,o,H,g,j,M,R,t,S,k,K,Q,v,r,B,s){const U=s.Eh;U[0]=D,U[1]=h,U[2]=o,U[3]=H,U[4]=g,U[5]=j,U[6]=M,U[7]=R,U[8]=t,U[9]=S,U[10]=k,U[11]=K,U[12]=Q,U[13]=v,U[14]=r,U[15]=B,s.markAsUpdated()}static FromValues(D,h,o,H,g,j,M,R,t,S,k,K,Q,v,r,B){const s=new q,U=s.Eh;return U[0]=D,U[1]=h,U[2]=o,U[3]=H,U[4]=g,U[5]=j,U[6]=M,U[7]=R,U[8]=t,U[9]=S,U[10]=k,U[11]=K,U[12]=Q,U[13]=v,U[14]=r,U[15]=B,s.markAsUpdated(),s}static Compose(D,h,o){const H=new q;return q.ComposeToRef(D,h,o,H),H}static ComposeToRef(D,h,o,H){const g=H.Eh,j=h._x,M=h._y,R=h._z,t=h._w,S=j+j,k=M+M,K=R+R,Q=j*S,v=j*k,r=j*K,B=M*k,s=M*K,U=R*K,q=t*S,c=t*k,y=t*K,b=D._x,i=D._y,G=D._z;return g[0]=(1-(B+U))*b,g[1]=(v+y)*b,g[2]=(r-c)*b,g[3]=0,g[4]=(v-y)*i,g[5]=(1-(Q+U))*i,g[6]=(s+q)*i,g[7]=0,g[8]=(r+c)*G,g[9]=(s-q)*G,g[10]=(1-(Q+B))*G,g[11]=0,g[12]=o._x,g[13]=o._y,g[14]=o._z,g[15]=1,H.markAsUpdated(),H}static Identity(){const D=q.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return D._updateIdentityStatus(!0),D}static IdentityToRef(D){return q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,D),D._updateIdentityStatus(!0),D}static Zero(){const D=q.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return D._updateIdentityStatus(!1),D}static RotationX(D){const h=new q;return q.RotationXToRef(D,h),h}static Invert(D){const h=new q;return D.invertToRef(h),h}static RotationXToRef(D,h){const o=Math.sin(D),H=Math.cos(D);return q.FromValuesToRef(1,0,0,0,0,H,o,0,0,-o,H,0,0,0,0,1,h),h._updateIdentityStatus(1===H&&0===o),h}static RotationY(D){const h=new q;return q.RotationYToRef(D,h),h}static RotationYToRef(D,h){const o=Math.sin(D),H=Math.cos(D);return q.FromValuesToRef(H,0,-o,0,0,1,0,0,o,0,H,0,0,0,0,1,h),h._updateIdentityStatus(1===H&&0===o),h}static RotationZ(D){const h=new q;return q.RotationZToRef(D,h),h}static RotationZToRef(D,h){const o=Math.sin(D),H=Math.cos(D);return q.FromValuesToRef(H,o,0,0,-o,H,0,0,0,0,1,0,0,0,0,1,h),h._updateIdentityStatus(1===H&&0===o),h}static RotationAxis(D,h){const o=new q;return q.RotationAxisToRef(D,h,o),o}static RotationAxisToRef(D,h,o){const H=Math.sin(-h),g=Math.cos(-h),j=1-g;D=D.normalizeToRef(c.Gh[0]);const M=o.Eh;return M[0]=D._x*D._x*j+g,M[1]=D._x*D._y*j-D._z*H,M[2]=D._x*D._z*j+D._y*H,M[3]=0,M[4]=D._y*D._x*j+D._z*H,M[5]=D._y*D._y*j+g,M[6]=D._y*D._z*j-D._x*H,M[7]=0,M[8]=D._z*D._x*j-D._y*H,M[9]=D._z*D._y*j+D._x*H,M[10]=D._z*D._z*j+g,M[11]=0,M[12]=0,M[13]=0,M[14]=0,M[15]=1,o.markAsUpdated(),o}static RotationAlignToRef(D,h,o){let g=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const j=B.Dot(h,D),M=o.Eh;if(j<-1+H.d)M[0]=-1,M[1]=0,M[2]=0,M[3]=0,M[4]=0,M[5]=g?1:-1,M[6]=0,M[7]=0,M[8]=0,M[9]=0,M[10]=g?-1:1,M[11]=0;else{const o=B.Cross(h,D),H=1/(1+j);M[0]=o._x*o._x*H+j,M[1]=o._y*o._x*H-o._z,M[2]=o._z*o._x*H+o._y,M[3]=0,M[4]=o._x*o._y*H+o._z,M[5]=o._y*o._y*H+j,M[6]=o._z*o._y*H-o._x,M[7]=0,M[8]=o._x*o._z*H-o._y,M[9]=o._y*o._z*H+o._x,M[10]=o._z*o._z*H+j,M[11]=0}return M[12]=0,M[13]=0,M[14]=0,M[15]=1,o.markAsUpdated(),o}static RotationYawPitchRoll(D,h,o){const H=new q;return q.RotationYawPitchRollToRef(D,h,o,H),H}static RotationYawPitchRollToRef(D,h,o,H){return U.RotationYawPitchRollToRef(D,h,o,c.Quaternion[0]),c.Quaternion[0].toRotationMatrix(H),H}static Scaling(D,h,o){const H=new q;return q.ScalingToRef(D,h,o,H),H}static ScalingToRef(D,h,o,H){return q.FromValuesToRef(D,0,0,0,0,h,0,0,0,0,o,0,0,0,0,1,H),H._updateIdentityStatus(1===D&&1===h&&1===o),H}static Translation(D,h,o){const H=new q;return q.TranslationToRef(D,h,o,H),H}static TranslationToRef(D,h,o,H){return q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,D,h,o,1,H),H._updateIdentityStatus(0===D&&0===h&&0===o),H}static Lerp(D,h,o){const H=new q;return q.LerpToRef(D,h,o,H),H}static LerpToRef(D,h,o,H){const g=H.Eh,j=D.m,M=h.m;for(let R=0;R<16;R++)g[R]=j[R]*(1-o)+M[R]*o;return H.markAsUpdated(),H}static DecomposeLerp(D,h,o){const H=new q;return q.DecomposeLerpToRef(D,h,o,H),H}static DecomposeLerpToRef(D,h,o,H){const g=c.Gh[0],j=c.Quaternion[0],M=c.Gh[1];D.decompose(g,j,M);const R=c.Gh[2],t=c.Quaternion[1],S=c.Gh[3];h.decompose(R,t,S);const k=c.Gh[4];B.LerpToRef(g,R,o,k);const K=c.Quaternion[2];U.SlerpToRef(j,t,o,K);const Q=c.Gh[5];return B.LerpToRef(M,S,o,Q),q.ComposeToRef(k,K,Q,H),H}static LookAtLH(D,h,o){const H=new q;return q.LookAtLHToRef(D,h,o,H),H}static LookAtLHToRef(D,h,o,H){const g=c.Gh[0],j=c.Gh[1],M=c.Gh[2];h.subtractToRef(D,M),M.normalize(),B.CrossToRef(o,M,g);const R=g.lengthSquared();0===R?g.x=1:g.normalizeFromLength(Math.sqrt(R)),B.CrossToRef(M,g,j),j.normalize();const t=-B.Dot(g,D),S=-B.Dot(j,D),k=-B.Dot(M,D);return q.FromValuesToRef(g._x,j._x,M._x,0,g._y,j._y,M._y,0,g._z,j._z,M._z,0,t,S,k,1,H),H}static LookAtRH(D,h,o){const H=new q;return q.LookAtRHToRef(D,h,o,H),H}static LookAtRHToRef(D,h,o,H){const g=c.Gh[0],j=c.Gh[1],M=c.Gh[2];D.subtractToRef(h,M),M.normalize(),B.CrossToRef(o,M,g);const R=g.lengthSquared();0===R?g.x=1:g.normalizeFromLength(Math.sqrt(R)),B.CrossToRef(M,g,j),j.normalize();const t=-B.Dot(g,D),S=-B.Dot(j,D),k=-B.Dot(M,D);return q.FromValuesToRef(g._x,j._x,M._x,0,g._y,j._y,M._y,0,g._z,j._z,M._z,0,t,S,k,1,H),H}static LookDirectionLH(D,h){const o=new q;return q.LookDirectionLHToRef(D,h,o),o}static LookDirectionLHToRef(D,h,o){const H=c.Gh[0];H.M(D),H.scaleInPlace(-1);const g=c.Gh[1];return B.CrossToRef(h,H,g),q.FromValuesToRef(g._x,g._y,g._z,0,h._x,h._y,h._z,0,H._x,H._y,H._z,0,0,0,0,1,o),o}static LookDirectionRH(D,h){const o=new q;return q.LookDirectionRHToRef(D,h,o),o}static LookDirectionRHToRef(D,h,o){const H=c.Gh[2];return B.CrossToRef(h,D,H),q.FromValuesToRef(H._x,H._y,H._z,0,h._x,h._y,h._z,0,D._x,D._y,D._z,0,0,0,0,1,o),o}static OrthoLH(D,h,o,H,g){const j=new q;return q.OrthoLHToRef(D,h,o,H,j,g),j}static OrthoLHToRef(D,h,o,H,g,j){const M=2/D,R=2/h,t=2/(H-o),S=-(H+o)/(H-o);return q.FromValuesToRef(M,0,0,0,0,R,0,0,0,0,t,0,0,0,S,1,g),j&&g.multiplyToRef(b,g),g._updateIdentityStatus(1===M&&1===R&&1===t&&0===S),g}static OrthoOffCenterLH(D,h,o,H,g,j,M){const R=new q;return q.OrthoOffCenterLHToRef(D,h,o,H,g,j,R,M),R}static OrthoOffCenterLHToRef(D,h,o,H,g,j,M,R){const t=2/(h-D),S=2/(H-o),k=2/(j-g),K=-(j+g)/(j-g),Q=(D+h)/(D-h),v=(H+o)/(o-H);return q.FromValuesToRef(t,0,0,0,0,S,0,0,0,0,k,0,Q,v,K,1,M),R&&M.multiplyToRef(b,M),M.markAsUpdated(),M}static ObliqueOffCenterLHToRef(D,h,o,H,g,j,M,R,t,S,k){const K=-M*Math.cos(R),Q=-M*Math.sin(R);return q.TranslationToRef(0,0,-t,c.Matrix[1]),q.FromValuesToRef(1,0,0,0,0,1,0,0,K,Q,1,0,0,0,0,1,c.Matrix[0]),c.Matrix[1].multiplyToRef(c.Matrix[0],c.Matrix[0]),q.TranslationToRef(0,0,t,c.Matrix[1]),c.Matrix[0].multiplyToRef(c.Matrix[1],c.Matrix[0]),q.OrthoOffCenterLHToRef(D,h,o,H,g,j,S,k),c.Matrix[0].multiplyToRef(S,S),S}static OrthoOffCenterRH(D,h,o,H,g,j,M){const R=new q;return q.OrthoOffCenterRHToRef(D,h,o,H,g,j,R,M),R}static OrthoOffCenterRHToRef(D,h,o,H,g,j,M,R){return q.OrthoOffCenterLHToRef(D,h,o,H,g,j,M,R),M.Eh[10]*=-1,M}static ObliqueOffCenterRHToRef(D,h,o,H,g,j,M,R,t,S,k){const K=M*Math.cos(R),Q=M*Math.sin(R);return q.TranslationToRef(0,0,t,c.Matrix[1]),q.FromValuesToRef(1,0,0,0,0,1,0,0,K,Q,1,0,0,0,0,1,c.Matrix[0]),c.Matrix[1].multiplyToRef(c.Matrix[0],c.Matrix[0]),q.TranslationToRef(0,0,-t,c.Matrix[1]),c.Matrix[0].multiplyToRef(c.Matrix[1],c.Matrix[0]),q.OrthoOffCenterRHToRef(D,h,o,H,g,j,S,k),c.Matrix[0].multiplyToRef(S,S),S}static PerspectiveLH(D,h,o,H,g){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const M=new q,R=2*o/D,t=2*o/h,S=(H+o)/(H-o),k=-2*H*o/(H-o),K=Math.tan(j);return q.FromValuesToRef(R,0,0,0,0,t,0,K,0,0,S,1,0,0,k,0,M),g&&M.multiplyToRef(b,M),M._updateIdentityStatus(!1),M}static PerspectiveFovLH(D,h,o,H,g){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,M=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const R=new q;return q.PerspectiveFovLHToRef(D,h,o,H,R,!0,g,j,M),R}static PerspectiveFovLHToRef(D,h,o,H,g){let j=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],M=arguments.length>6?arguments[6]:void 0,R=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,t=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const S=o,k=H,K=1/Math.tan(.5*D),Q=j?K/h:K,v=j?K:K*h,r=t&&0===S?-1:0!==k?(k+S)/(k-S):1,B=t&&0===S?2*k:0!==k?-2*k*S/(k-S):-2*S,s=Math.tan(R);return q.FromValuesToRef(Q,0,0,0,0,v,0,s,0,0,r,1,0,0,B,0,g),M&&g.multiplyToRef(b,g),g._updateIdentityStatus(!1),g}static PerspectiveFovReverseLHToRef(D,h,o,H,g){let j=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],M=arguments.length>6?arguments[6]:void 0,R=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const t=1/Math.tan(.5*D),S=j?t/h:t,k=j?t:t*h,K=Math.tan(R);return q.FromValuesToRef(S,0,0,0,0,k,0,K,0,0,-o,1,0,0,1,0,g),M&&g.multiplyToRef(b,g),g._updateIdentityStatus(!1),g}static PerspectiveFovRH(D,h,o,H,g){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,M=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const R=new q;return q.PerspectiveFovRHToRef(D,h,o,H,R,!0,g,j,M),R}static PerspectiveFovRHToRef(D,h,o,H,g){let j=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],M=arguments.length>6?arguments[6]:void 0,R=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,t=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const S=o,k=H,K=1/Math.tan(.5*D),Q=j?K/h:K,v=j?K:K*h,r=t&&0===S?1:0!==k?-(k+S)/(k-S):-1,B=t&&0===S?2*k:0!==k?-2*k*S/(k-S):-2*S,s=Math.tan(R);return q.FromValuesToRef(Q,0,0,0,0,v,0,s,0,0,r,-1,0,0,B,0,g),M&&g.multiplyToRef(b,g),g._updateIdentityStatus(!1),g}static PerspectiveFovReverseRHToRef(D,h,o,H,g){let j=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],M=arguments.length>6?arguments[6]:void 0,R=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const t=1/Math.tan(.5*D),S=j?t/h:t,k=j?t:t*h,K=Math.tan(R);return q.FromValuesToRef(S,0,0,0,0,k,0,K,0,0,-o,-1,0,0,-1,0,g),M&&g.multiplyToRef(b,g),g._updateIdentityStatus(!1),g}static GetFinalMatrix(D,h,o,H,g,j){const M=D.width,R=D.height,t=D.x,S=D.y,k=q.FromValues(M/2,0,0,0,0,-R/2,0,0,0,0,j-g,0,t+M/2,R/2+S,g,1),K=new q;return h.multiplyToRef(o,K),K.multiplyToRef(H,K),K.multiplyToRef(k,K)}static GetAsMatrix2x2(D){const h=D.m,o=[h[0],h[1],h[4],h[5]];return M.b.MatrixUse64Bits?o:new Float32Array(o)}static GetAsMatrix3x3(D){const h=D.m,o=[h[0],h[1],h[2],h[4],h[5],h[6],h[8],h[9],h[10]];return M.b.MatrixUse64Bits?o:new Float32Array(o)}static Transpose(D){const h=new q;return q.TransposeToRef(D,h),h}static TransposeToRef(D,h){const o=D.m,H=o[0],g=o[4],j=o[8],M=o[12],R=o[1],t=o[5],S=o[9],k=o[13],K=o[2],Q=o[6],v=o[10],r=o[14],B=o[3],s=o[7],U=o[11],q=o[15],c=h.Eh;return c[0]=H,c[1]=g,c[2]=j,c[3]=M,c[4]=R,c[5]=t,c[6]=S,c[7]=k,c[8]=K,c[9]=Q,c[10]=v,c[11]=r,c[12]=B,c[13]=s,c[14]=U,c[15]=q,h.markAsUpdated(),h._updateIdentityStatus(D._isIdentity,D._isIdentityDirty),h}static Reflection(D){const h=new q;return q.ReflectionToRef(D,h),h}static ReflectionToRef(D,h){D.normalize();const o=D.normal.x,H=D.normal.y,g=D.normal.z,j=-2*o,M=-2*H,R=-2*g;return q.FromValuesToRef(j*o+1,M*o,R*o,0,j*H,M*H+1,R*H,0,j*g,M*g,R*g+1,0,j*D.d,M*D.d,R*D.d,1,h),h}static FromXYZAxesToRef(D,h,o,H){return q.FromValuesToRef(D._x,D._y,D._z,0,h._x,h._y,h._z,0,o._x,o._y,o._z,0,0,0,0,1,H),H}static FromQuaternionToRef(D,h){const o=D._x*D._x,H=D._y*D._y,g=D._z*D._z,j=D._x*D._y,M=D._z*D._w,R=D._z*D._x,t=D._y*D._w,S=D._y*D._z,k=D._x*D._w;return h.Eh[0]=1-2*(H+g),h.Eh[1]=2*(j+M),h.Eh[2]=2*(R-t),h.Eh[3]=0,h.Eh[4]=2*(j-M),h.Eh[5]=1-2*(g+o),h.Eh[6]=2*(S+k),h.Eh[7]=0,h.Eh[8]=2*(R+t),h.Eh[9]=2*(S-k),h.Eh[10]=1-2*(H+o),h.Eh[11]=0,h.Eh[12]=0,h.Eh[13]=0,h.Eh[14]=0,h.Eh[15]=1,h.markAsUpdated(),h}}q._IdentityReadOnly=q.Identity(),Object.defineProperties(q.prototype,{dimension:{value:[4,4]},rank:{value:2}});class c{}c.Gh=(0,g.e)(11,B.Zero),c.Matrix=(0,g.e)(2,q.Identity),c.Quaternion=(0,g.e)(3,U.Zero);class y{}y.Vector2=(0,g.e)(3,r.Zero),y.Gh=(0,g.e)(13,B.Zero),y.Vector4=(0,g.e)(3,s.Zero),y.Quaternion=(0,g.e)(3,U.Zero),y.Matrix=(0,g.e)(8,q.Identity),(0,j.g)("BABYLON.Vector2",r),(0,j.g)("BABYLON.Vector3",B),(0,j.g)("BABYLON.Vector4",s),(0,j.g)("BABYLON.Matrix",q);const b=q.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12836:(D,h,o)=>{function H(D,h){const o=[];for(let H=0;H<D;++H)o.push(h());return o}function g(D,h){return H(D,h)}o.d(h,{b:()=>H,e:()=>g,i:()=>M});const j=["push","splice","pop","shift","unshift"];function M(D,h){const o=j.map((o=>function(D,h,o){const H=D[h];if("function"!==typeof H)return null;const g=function(){const H=D.length,j=g.previous.apply(D,arguments);return o(h,H),j};return H.next=g,g.previous=H,D[h]=g,()=>{const o=g.previous;if(!o)return;const H=g.next;H?(o.next=H,H.previous=o):(o.next=void 0,D[h]=o),g.next=void 0,g.previous=void 0}}(D,o,h)));return()=>{for(const D of o)null===D||void 0===D||D()}}}}]);