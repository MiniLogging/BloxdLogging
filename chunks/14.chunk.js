"use strict";(self.h66iwo8dvgq=self.h66iwo8dvgq||[]).push([[14],{11836:(b,X,P)=>{P.d(X,{c:()=>N,g:()=>d,j:()=>Q,k:()=>S});const Q=1/2.2,S=2.2,d=(1+Math.sqrt(5))/2,N=.001},11844:(b,X,P)=>{function Q(b){return parseInt(b.toString().replace(/\W/g,""))}function S(b,X){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(b-X)<=P}function d(b,X,P){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return b<X-Q||b>P+Q}function N(b,X){return b===X?b:Math.random()*(X-b)+b}function a(b,X,P){return b+(X-b)*P}function u(b,X,P){let Q=t(X-b,360);return Q>180&&(Q-=360),b+Q*e(P)}function w(b,X,P){let Q=0;return Q=b!=X?e((P-b)/(X-b)):0,Q}function f(b,X,P,Q,S){const d=S*S,N=S*d;return b*(2*N-3*d+1)+P*(-2*N+3*d)+X*(N-2*d+S)+Q*(N-d)}function O(b,X,P,Q,S){const d=S*S;return 6*(d-S)*b+(3*d-4*S+1)*X+6*(-d+S)*P+(3*d-2*S)*Q}function e(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(P,Math.max(X,b))}function Y(b){return b-=2*Math.PI*Math.floor((b+Math.PI)/(2*Math.PI))}function D(b){const X=b.toString(16);return b<=15?("0"+X).toUpperCase():X.toUpperCase()}function E(b){if(Math.log2)return Math.floor(Math.log2(b));if(b<0)return NaN;if(0===b)return-1/0;let X=0;if(b<1){for(;b<1;)X++,b*=2;X=-X}else if(b>1)for(;b>1;)X++,b=Math.floor(b/2);return X}function t(b,X){return b-Math.floor(b/X)*X}function B(b,X,P){return(b-X)/(P-X)}function W(b,X,P){return b*(P-X)+X}function n(b,X){let P=t(X-b,360);return P>180&&(P-=360),P}function y(b,X){const P=t(b,2*X);return X-Math.abs(P-X)}function h(b,X,P){let Q=e(P);return Q=-2*Q*Q*Q+3*Q*Q,X*Q+b*(1-Q)}function L(b,X,P){let Q=0;return Q=Math.abs(X-b)<=P?X:b+Math.sign(X-b)*P,Q}function Z(b,X,P){const Q=n(b,X);let S=0;return S=-P<Q&&Q<P?X:L(b,X=b+Q,P),S}function v(b,X,P){return(b-X)/(P-X)}function A(b,X,P){return(P-X)*b+X}function o(b,X){const P=b%X;return 0===P?X:o(X,P)}P.r(X),P.d(X,{Clamp:()=>e,DeltaAngle:()=>n,Denormalize:()=>W,ExtractAsInt:()=>Q,Hermite:()=>f,Hermite1stDerivative:()=>O,HighestCommonFactor:()=>o,ILog2:()=>E,InverseLerp:()=>w,Lerp:()=>a,LerpAngle:()=>u,MoveTowards:()=>L,MoveTowardsAngle:()=>Z,Normalize:()=>B,NormalizeRadians:()=>Y,OutsideRange:()=>d,PercentToRange:()=>A,PingPong:()=>y,RandomRange:()=>N,RangeToPercent:()=>v,Repeat:()=>t,SmoothStep:()=>h,ToHex:()=>D,WithinEpsilon:()=>S})},11834:(b,X,P)=>{P.r(X),P.d(X,{Matrix:()=>W,Quaternion:()=>B,TmpVectors:()=>y,Vector2:()=>D,tX:()=>E,Vector4:()=>t});var Q=P(11836),S=P(11841),d=P(11802),N=P(11784),a=P(11732),u=P(11844);class w{}function f(b,X,P){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const S=b.Zd(),d=X.Zd(),N=S[0],a=S[1],u=S[2],w=S[3],f=S[4],O=S[5],e=S[6],Y=S[7],D=S[8],E=S[9],t=S[10],B=S[11],W=S[12],n=S[13],y=S[14],h=S[15],L=d[0],Z=d[1],v=d[2],A=d[3],o=d[4],K=d[5],T=d[6],q=d[7],V=d[8],i=d[9],x=d[10],H=d[11],C=d[12],p=d[13],k=d[14],z=d[15];P[Q]=N*L+a*o+u*V+w*C,P[Q+1]=N*Z+a*K+u*i+w*p,P[Q+2]=N*v+a*T+u*x+w*k,P[Q+3]=N*A+a*q+u*H+w*z,P[Q+4]=f*L+O*o+e*V+Y*C,P[Q+5]=f*Z+O*K+e*i+Y*p,P[Q+6]=f*v+O*T+e*x+Y*k,P[Q+7]=f*A+O*q+e*H+Y*z,P[Q+8]=D*L+E*o+t*V+B*C,P[Q+9]=D*Z+E*K+t*i+B*p,P[Q+10]=D*v+E*T+t*x+B*k,P[Q+11]=D*A+E*q+t*H+B*z,P[Q+12]=W*L+n*o+y*V+h*C,P[Q+13]=W*Z+n*K+y*i+h*p,P[Q+14]=W*v+n*T+y*x+h*k,P[Q+15]=W*A+n*q+y*H+h*z}function O(b,X){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const Q=b.Zd();X[P]=Q[0],X[P+1]=Q[1],X[P+2]=Q[2],X[P+3]=Q[3],X[P+4]=Q[4],X[P+5]=Q[5],X[P+6]=Q[6],X[P+7]=Q[7],X[P+8]=Q[8],X[P+9]=Q[9],X[P+10]=Q[10],X[P+11]=Q[11],X[P+12]=Q[12],X[P+13]=Q[13],X[P+14]=Q[14],X[P+15]=Q[15]}function e(b,X){const P=b.Zd(),Q=P[0],S=P[1],d=P[2],N=P[3],a=P[4],u=P[5],w=P[6],f=P[7],O=P[8],e=P[9],Y=P[10],D=P[11],E=P[12],t=P[13],B=P[14],W=P[15],n=Y*W-B*D,y=e*W-t*D,h=e*B-t*Y,L=O*W-E*D,Z=O*B-Y*E,v=O*t-E*e,A=+(u*n-w*y+f*h),o=-(a*n-w*L+f*Z),K=+(a*y-u*L+f*v),T=-(a*h-u*Z+w*v),q=Q*A+S*o+d*K+N*T;if(0===q)return!1;const V=1/q,i=w*W-B*f,x=u*W-t*f,H=u*B-t*w,C=a*W-E*f,p=a*B-E*w,k=a*t-E*u,z=w*D-Y*f,U=u*D-e*f,g=u*Y-e*w,j=a*D-O*f,l=a*Y-O*w,J=a*e-O*u,c=-(S*n-d*y+N*h),s=+(Q*n-d*L+N*Z),F=-(Q*y-S*L+N*v),M=+(Q*h-S*Z+d*v),R=+(S*i-d*x+N*H),r=-(Q*i-d*C+N*p),I=+(Q*x-S*C+N*k),G=-(Q*H-S*p+d*k),mb=-(S*z-d*U+N*g),bb=+(Q*z-d*j+N*l),Xb=-(Q*U-S*j+N*J),Pb=+(Q*g-S*l+d*J);return X[0]=A*V,X[1]=c*V,X[2]=R*V,X[3]=mb*V,X[4]=o*V,X[5]=s*V,X[6]=r*V,X[7]=bb*V,X[8]=K*V,X[9]=F*V,X[10]=I*V,X[11]=Xb*V,X[12]=T*V,X[13]=M*V,X[14]=G*V,X[15]=Pb*V,!0}w._UpdateFlagSeed=0;const Y=b=>parseInt(b.toString().replace(/\W/g,""));class D{constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=b,this.y=X}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let b=Y(this.x);return b=397*b^Y(this.y),b}toArray(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[X]=this.x,b[X+1]=this.y,this}tP(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D.FromArrayToRef(b,X,this),this}Zd(){return[this.x,this.y]}N(b){return this.x=b.x,this.y=b.y,this}sd(b,X){return this.x=b,this.y=X,this}set(b,X){return this.sd(b,X)}Gd(b){return this.sd(b,b)}add(b){return new D(this.x+b.x,this.y+b.y)}addToRef(b,X){return X.x=this.x+b.x,X.y=this.y+b.y,X}addInPlace(b){return this.x+=b.x,this.y+=b.y,this}addInPlaceFromFloats(b,X){return this.x+=b,this.y+=X,this}addVector3(b){return new D(this.x+b.x,this.y+b.y)}BX(b){return new D(this.x-b.x,this.y-b.y)}subtractToRef(b,X){return X.x=this.x-b.x,X.y=this.y-b.y,X}fO(b){return this.x-=b.x,this.y-=b.y,this}multiplyInPlace(b){return this.x*=b.x,this.y*=b.y,this}multiply(b){return new D(this.x*b.x,this.y*b.y)}multiplyToRef(b,X){return X.x=this.x*b.x,X.y=this.y*b.y,X}multiplyByFloats(b,X){return new D(this.x*b,this.y*X)}divide(b){return new D(this.x/b.x,this.y/b.y)}divideToRef(b,X){return X.x=this.x/b.x,X.y=this.y/b.y,X}divideInPlace(b){return this.x=this.x/b.x,this.y=this.y/b.y,this}minimizeInPlace(b){return this.minimizeInPlaceFromFloats(b.x,b.y)}maximizeInPlace(b){return this.maximizeInPlaceFromFloats(b.x,b.y)}minimizeInPlaceFromFloats(b,X){return this.x=Math.min(b,this.x),this.y=Math.min(X,this.y),this}maximizeInPlaceFromFloats(b,X){return this.x=Math.max(b,this.x),this.y=Math.max(X,this.y),this}subtractFromFloats(b,X){return new D(this.x-b,this.y-X)}subtractFromFloatsToRef(b,X,P){return P.x=this.x-b,P.y=this.y-X,P}negate(){return new D(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(b){return b.x=-this.x,b.y=-this.y,b}scaleInPlace(b){return this.x*=b,this.y*=b,this}scale(b){return new D(this.x*b,this.y*b)}scaleToRef(b,X){return X.x=this.x*b,X.y=this.y*b,X}scaleAndAddToRef(b,X){return X.x+=this.x*b,X.y+=this.y*b,X}equals(b){return b&&this.x===b.x&&this.y===b.y}equalsWithEpsilon(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.c;return b&&(0,u.WithinEpsilon)(this.x,b.x,X)&&(0,u.WithinEpsilon)(this.y,b.y,X)}equalsToFloats(b,X){return this.x===b&&this.y===X}floor(){return new D(Math.floor(this.x),Math.floor(this.y))}floorToRef(b){return b.x=Math.floor(this.x),b.y=Math.floor(this.y),b}fract(){return new D(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(b){return b.x=this.x-Math.floor(this.x),b.y=this.y-Math.floor(this.y),b}rotate(b){return this.rotateToRef(b,new D)}rotateToRef(b,X){const P=Math.cos(b),Q=Math.sin(b);return X.x=P*this.x-Q*this.y,X.y=Q*this.x+P*this.y,X}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){const b=new D;return this.normalizeToRef(b),b}normalizeToRef(b){const X=this.length();return 0===X&&(b.x=this.x,b.y=this.y),this.scaleToRef(1/X,b)}clone(){return new D(this.x,this.y)}dot(b){return this.x*b.x+this.y*b.y}static Zero(){return new D(0,0)}static One(){return new D(1,1)}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new D((0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).sd((0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X))}static get ZeroReadOnly(){return D._ZeroReadOnly}static hX(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new D(b[X],b[X+1])}static FromArrayToRef(b,X,P){return P.x=b[X],P.y=b[X+1],P}static FromFloatsToRef(b,X,P){return P.sd(b,X),P}static CatmullRom(b,X,P,Q,S){const d=S*S,N=S*d,a=.5*(2*X.x+(-b.x+P.x)*S+(2*b.x-5*X.x+4*P.x-Q.x)*d+(-b.x+3*X.x-3*P.x+Q.x)*N),u=.5*(2*X.y+(-b.y+P.y)*S+(2*b.y-5*X.y+4*P.y-Q.y)*d+(-b.y+3*X.y-3*P.y+Q.y)*N);return new D(a,u)}static ClampToRef(b,X,P,Q){return Q.x=(0,u.Clamp)(b.x,X.x,P.x),Q.y=(0,u.Clamp)(b.y,X.y,P.y),Q}static Clamp(b,X,P){const Q=(0,u.Clamp)(b.x,X.x,P.x),S=(0,u.Clamp)(b.y,X.y,P.y);return new D(Q,S)}static Hermite(b,X,P,Q,S){const d=S*S,N=S*d,a=2*N-3*d+1,u=-2*N+3*d,w=N-2*d+S,f=N-d,O=b.x*a+P.x*u+X.x*w+Q.x*f,e=b.y*a+P.y*u+X.y*w+Q.y*f;return new D(O,e)}static Hermite1stDerivative(b,X,P,Q,S){return this.Hermite1stDerivativeToRef(b,X,P,Q,S,new D)}static Hermite1stDerivativeToRef(b,X,P,Q,S,d){const N=S*S;return d.x=6*(N-S)*b.x+(3*N-4*S+1)*X.x+6*(-N+S)*P.x+(3*N-2*S)*Q.x,d.y=6*(N-S)*b.y+(3*N-4*S+1)*X.y+6*(-N+S)*P.y+(3*N-2*S)*Q.y,d}static Lerp(b,X,P){return D.LerpToRef(b,X,P,new D)}static LerpToRef(b,X,P,Q){return Q.x=b.x+(X.x-b.x)*P,Q.y=b.y+(X.y-b.y)*P,Q}static Dot(b,X){return b.x*X.x+b.y*X.y}static Normalize(b){return D.NormalizeToRef(b,new D)}static NormalizeToRef(b,X){return b.normalizeToRef(X),X}static Minimize(b,X){const P=b.x<X.x?b.x:X.x,Q=b.y<X.y?b.y:X.y;return new D(P,Q)}static Maximize(b,X){const P=b.x>X.x?b.x:X.x,Q=b.y>X.y?b.y:X.y;return new D(P,Q)}static Transform(b,X){return D.TransformToRef(b,X,new D)}static TransformToRef(b,X,P){const Q=X.m,S=b.x*Q[0]+b.y*Q[4]+Q[12],d=b.x*Q[1]+b.y*Q[5]+Q[13];return P.x=S,P.y=d,P}static PointInTriangle(b,X,P,Q){const S=.5*(-P.y*Q.x+X.y*(-P.x+Q.x)+X.x*(P.y-Q.y)+P.x*Q.y),d=S<0?-1:1,N=(X.y*Q.x-X.x*Q.y+(Q.y-X.y)*b.x+(X.x-Q.x)*b.y)*d,a=(X.x*P.y-X.y*P.x+(X.y-P.y)*b.x+(P.x-X.x)*b.y)*d;return N>0&&a>0&&N+a<2*S*d}static Distance(b,X){return Math.sqrt(D.DistanceSquared(b,X))}static DistanceSquared(b,X){const P=b.x-X.x,Q=b.y-X.y;return P*P+Q*Q}static Center(b,X){return D.CenterToRef(b,X,new D)}static CenterToRef(b,X,P){return P.sd((b.x+X.x)/2,(b.y+X.y)/2)}static DistanceOfPointFromSegment(b,X,P){const Q=D.DistanceSquared(X,P);if(0===Q)return D.Distance(b,X);const S=P.BX(X),d=Math.max(0,Math.min(1,D.Dot(b.BX(X),S)/Q)),N=X.add(S.multiplyByFloats(d,d));return D.Distance(b,N)}}D._V8PerformanceHack=new D(.5,.5),D._ZeroReadOnly=D.Zero(),Object.defineProperties(D.prototype,{dimension:{value:[2]},rank:{value:1}});class E{get x(){return this._x}set x(b){this._x=b,this._isDirty=!0}get y(){return this._y}set y(b){this._y=b,this._isDirty=!0}get z(){return this._z}set z(b){this._z=b,this._isDirty=!0}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=b,this._y=X,this._z=P}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"tX"}getHashCode(){let b=Y(this._x);return b=397*b^Y(this._y),b=397*b^Y(this._z),b}Zd(){return[this._x,this._y,this._z]}toArray(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[X]=this._x,b[X+1]=this._y,b[X+2]=this._z,this}tP(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(b,X,this),this}toQuaternion(){return B.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(b){return this._x+=b._x,this._y+=b._y,this._z+=b._z,this._isDirty=!0,this}addInPlaceFromFloats(b,X,P){return this._x+=b,this._y+=X,this._z+=P,this._isDirty=!0,this}add(b){return new E(this._x+b._x,this._y+b._y,this._z+b._z)}addToRef(b,X){return X._x=this._x+b._x,X._y=this._y+b._y,X._z=this._z+b._z,X._isDirty=!0,X}fO(b){return this._x-=b._x,this._y-=b._y,this._z-=b._z,this._isDirty=!0,this}BX(b){return new E(this._x-b._x,this._y-b._y,this._z-b._z)}subtractToRef(b,X){return this.subtractFromFloatsToRef(b._x,b._y,b._z,X)}subtractFromFloats(b,X,P){return new E(this._x-b,this._y-X,this._z-P)}subtractFromFloatsToRef(b,X,P,Q){return Q._x=this._x-b,Q._y=this._y-X,Q._z=this._z-P,Q._isDirty=!0,Q}negate(){return new E(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(b){return b._x=-1*this._x,b._y=-1*this._y,b._z=-1*this._z,b._isDirty=!0,b}scaleInPlace(b){return this._x*=b,this._y*=b,this._z*=b,this._isDirty=!0,this}scale(b){return new E(this._x*b,this._y*b,this._z*b)}scaleToRef(b,X){return X._x=this._x*b,X._y=this._y*b,X._z=this._z*b,X._isDirty=!0,X}getNormalToRef(b){const X=this.length();let P=Math.acos(this._y/X);const Q=Math.atan2(this._z,this._x);P>Math.PI/2?P-=Math.PI/2:P+=Math.PI/2;const S=X*Math.sin(P)*Math.cos(Q),d=X*Math.cos(P),N=X*Math.sin(P)*Math.sin(Q);return b.set(S,d,N),b}applyRotationQuaternionToRef(b,X){const P=this._x,Q=this._y,S=this._z,d=b._x,N=b._y,a=b._z,u=b._w,w=2*(N*S-a*Q),f=2*(a*P-d*S),O=2*(d*Q-N*P);return X._x=P+u*w+N*O-a*f,X._y=Q+u*f+a*w-d*O,X._z=S+u*O+d*f-N*w,X._isDirty=!0,X}applyRotationQuaternionInPlace(b){return this.applyRotationQuaternionToRef(b,this)}applyRotationQuaternion(b){return this.applyRotationQuaternionToRef(b,new E)}scaleAndAddToRef(b,X){return X._x+=this._x*b,X._y+=this._y*b,X._z+=this._z*b,X._isDirty=!0,X}projectOnPlane(b,X){return this.projectOnPlaneToRef(b,X,new E)}projectOnPlaneToRef(b,X,P){const Q=b.normal,S=b.d,d=n.tX[0];this.subtractToRef(X,d),d.normalize();const N=E.Dot(d,Q);if(Math.abs(N)<1e-10)P.Gd(1/0);else{const b=-(E.Dot(X,Q)+S)/N,a=d.scaleInPlace(b);X.addToRef(a,P)}return P}equals(b){return b&&this._x===b._x&&this._y===b._y&&this._z===b._z}equalsWithEpsilon(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.c;return b&&(0,u.WithinEpsilon)(this._x,b._x,X)&&(0,u.WithinEpsilon)(this._y,b._y,X)&&(0,u.WithinEpsilon)(this._z,b._z,X)}equalsToFloats(b,X,P){return this._x===b&&this._y===X&&this._z===P}multiplyInPlace(b){return this._x*=b._x,this._y*=b._y,this._z*=b._z,this._isDirty=!0,this}multiply(b){return this.multiplyByFloats(b._x,b._y,b._z)}multiplyToRef(b,X){return X._x=this._x*b._x,X._y=this._y*b._y,X._z=this._z*b._z,X._isDirty=!0,X}multiplyByFloats(b,X,P){return new E(this._x*b,this._y*X,this._z*P)}divide(b){return new E(this._x/b._x,this._y/b._y,this._z/b._z)}divideToRef(b,X){return X._x=this._x/b._x,X._y=this._y/b._y,X._z=this._z/b._z,X._isDirty=!0,X}divideInPlace(b){return this._x=this._x/b._x,this._y=this._y/b._y,this._z=this._z/b._z,this._isDirty=!0,this}minimizeInPlace(b){return this.minimizeInPlaceFromFloats(b._x,b._y,b._z)}maximizeInPlace(b){return this.maximizeInPlaceFromFloats(b._x,b._y,b._z)}minimizeInPlaceFromFloats(b,X,P){return b<this._x&&(this.x=b),X<this._y&&(this.y=X),P<this._z&&(this.z=P),this}maximizeInPlaceFromFloats(b,X,P){return b>this._x&&(this.x=b),X>this._y&&(this.y=X),P>this._z&&(this.z=P),this}isNonUniformWithinEpsilon(b){const X=Math.abs(this._x),P=Math.abs(this._y);if(!(0,u.WithinEpsilon)(X,P,b))return!0;const Q=Math.abs(this._z);return!(0,u.WithinEpsilon)(X,Q,b)||!(0,u.WithinEpsilon)(P,Q,b)}get isNonUniform(){const b=Math.abs(this._x);if(b!==Math.abs(this._y))return!0;return b!==Math.abs(this._z)}floorToRef(b){return b._x=Math.floor(this._x),b._y=Math.floor(this._y),b._z=Math.floor(this._z),b._isDirty=!0,b}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(b){return b._x=this._x-Math.floor(this._x),b._y=this._y-Math.floor(this._y),b._z=this._z-Math.floor(this._z),b._isDirty=!0,b}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(b){if("xyz"===(b=b.toLowerCase()))return this;const X=n.tX[0].N(this);return this.x=X[b[0]],this.y=X[b[1]],this.z=X[b[2]],this}rotateByQuaternionToRef(b,X){return b.toRotationMatrix(n.Matrix[0]),E.TransformCoordinatesToRef(this,n.Matrix[0],X),X}rotateByQuaternionAroundPointToRef(b,X,P){return this.subtractToRef(X,n.tX[0]),n.tX[0].rotateByQuaternionToRef(b,n.tX[0]),X.addToRef(n.tX[0],P),P}cross(b){return E.CrossToRef(this,b,new E)}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(b){const X=this.length();return 0===X||1===X?(b._x=this._x,b._y=this._y,b._z=this._z,b._isDirty=!0,b):this.scaleToRef(1/X,b)}clone(){return new E(this._x,this._y,this._z)}N(b){return this.sd(b._x,b._y,b._z)}sd(b,X,P){return this._x=b,this._y=X,this._z=P,this._isDirty=!0,this}set(b,X,P){return this.sd(b,X,P)}Gd(b){return this._x=this._y=this._z=b,this._isDirty=!0,this}static GetClipFactor(b,X,P,Q){const S=E.Dot(b,P);return(S-Q)/(S-E.Dot(X,P))}static GetAngleBetweenVectors(b,X,P){const Q=b.normalizeToRef(n.tX[1]),S=X.normalizeToRef(n.tX[2]);let d=E.Dot(Q,S);d=(0,u.Clamp)(d,-1,1);const N=Math.acos(d),a=n.tX[3];return E.CrossToRef(Q,S,a),E.Dot(a,P)>0?isNaN(N)?0:N:isNaN(N)?-Math.PI:-Math.acos(d)}static GetAngleBetweenVectorsOnPlane(b,X,P){n.tX[0].N(b);const Q=n.tX[0];n.tX[1].N(X);const S=n.tX[1];n.tX[2].N(P);const d=n.tX[2],N=n.tX[3],a=n.tX[4];Q.normalize(),S.normalize(),d.normalize(),E.CrossToRef(d,Q,N),E.CrossToRef(N,d,a);const w=Math.atan2(E.Dot(S,N),E.Dot(S,a));return(0,u.NormalizeRadians)(w)}static PitchYawRollToMoveBetweenPointsToRef(b,X,P){const Q=y.tX[0];return X.subtractToRef(b,Q),P._y=Math.atan2(Q.x,Q.z)||0,P._x=Math.atan2(Math.sqrt(Q.x**2+Q.z**2),Q.y)||0,P._z=0,P._isDirty=!0,P}static PitchYawRollToMoveBetweenPoints(b,X){const P=E.Zero();return E.PitchYawRollToMoveBetweenPointsToRef(b,X,P)}static SlerpToRef(b,X,P,S){P=(0,u.Clamp)(P,0,1);const d=n.tX[0],N=n.tX[1];d.N(b);const a=d.length();d.normalizeFromLength(a),N.N(X);const w=N.length();N.normalizeFromLength(w);const f=E.Dot(d,N);let O,e;if(f<1-Q.c){const b=Math.acos(f),X=1/Math.sin(b);O=Math.sin((1-P)*b)*X,e=Math.sin(P*b)*X}else O=1-P,e=P;return d.scaleInPlace(O),N.scaleInPlace(e),S.N(d).addInPlace(N),S.scaleInPlace((0,u.Lerp)(a,w,P)),S}static SmoothToRef(b,X,P,Q,S){return E.SlerpToRef(b,X,0===Q?1:P/Q,S),S}static hX(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(b[X],b[X+1],b[X+2])}static FromFloatArray(b,X){return E.hX(b,X)}static FromArrayToRef(b,X,P){return P._x=b[X],P._y=b[X+1],P._z=b[X+2],P._isDirty=!0,P}static FromFloatArrayToRef(b,X,P){return E.FromArrayToRef(b,X,P)}static FromFloatsToRef(b,X,P,Q){return Q.sd(b,X,P),Q}static Zero(){return new E(0,0,0)}static One(){return new E(1,1,1)}static Up(){return new E(0,1,0)}static get UpReadOnly(){return E._UpReadOnly}static get DownReadOnly(){return E._DownReadOnly}static get RightReadOnly(){return E._RightReadOnly}static get LeftReadOnly(){return E._LeftReadOnly}static get LeftHandedForwardReadOnly(){return E._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return E._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return E._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return E._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return E._ZeroReadOnly}static get OneReadOnly(){return E._OneReadOnly}static Down(){return new E(0,-1,0)}static Forward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new E(1,0,0)}static Left(){return new E(-1,0,0)}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).sd((0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X))}static TransformCoordinates(b,X){const P=E.Zero();return E.TransformCoordinatesToRef(b,X,P),P}static TransformCoordinatesToRef(b,X,P){return E.TransformCoordinatesFromFloatsToRef(b._x,b._y,b._z,X,P),P}static TransformCoordinatesFromFloatsToRef(b,X,P,Q,S){const d=Q.m,N=b*d[0]+X*d[4]+P*d[8]+d[12],a=b*d[1]+X*d[5]+P*d[9]+d[13],u=b*d[2]+X*d[6]+P*d[10]+d[14],w=1/(b*d[3]+X*d[7]+P*d[11]+d[15]);return S._x=N*w,S._y=a*w,S._z=u*w,S._isDirty=!0,S}static TransformNormal(b,X){const P=E.Zero();return E.TransformNormalToRef(b,X,P),P}static TransformNormalToRef(b,X,P){return this.TransformNormalFromFloatsToRef(b._x,b._y,b._z,X,P),P}static TransformNormalFromFloatsToRef(b,X,P,Q,S){const d=Q.m;return S._x=b*d[0]+X*d[4]+P*d[8],S._y=b*d[1]+X*d[5]+P*d[9],S._z=b*d[2]+X*d[6]+P*d[10],S._isDirty=!0,S}static CatmullRom(b,X,P,Q,S){const d=S*S,N=S*d,a=.5*(2*X._x+(-b._x+P._x)*S+(2*b._x-5*X._x+4*P._x-Q._x)*d+(-b._x+3*X._x-3*P._x+Q._x)*N),u=.5*(2*X._y+(-b._y+P._y)*S+(2*b._y-5*X._y+4*P._y-Q._y)*d+(-b._y+3*X._y-3*P._y+Q._y)*N),w=.5*(2*X._z+(-b._z+P._z)*S+(2*b._z-5*X._z+4*P._z-Q._z)*d+(-b._z+3*X._z-3*P._z+Q._z)*N);return new E(a,u,w)}static Clamp(b,X,P){const Q=new E;return E.ClampToRef(b,X,P,Q),Q}static ClampToRef(b,X,P,Q){let S=b._x;S=S>P._x?P._x:S,S=S<X._x?X._x:S;let d=b._y;d=d>P._y?P._y:d,d=d<X._y?X._y:d;let N=b._z;return N=N>P._z?P._z:N,N=N<X._z?X._z:N,Q.sd(S,d,N),Q}static CheckExtends(b,X,P){X.minimizeInPlace(b),P.maximizeInPlace(b)}static Hermite(b,X,P,Q,S){const d=S*S,N=S*d,a=2*N-3*d+1,u=-2*N+3*d,w=N-2*d+S,f=N-d,O=b._x*a+P._x*u+X._x*w+Q._x*f,e=b._y*a+P._y*u+X._y*w+Q._y*f,Y=b._z*a+P._z*u+X._z*w+Q._z*f;return new E(O,e,Y)}static Hermite1stDerivative(b,X,P,Q,S){const d=new E;return this.Hermite1stDerivativeToRef(b,X,P,Q,S,d),d}static Hermite1stDerivativeToRef(b,X,P,Q,S,d){const N=S*S;return d._x=6*(N-S)*b._x+(3*N-4*S+1)*X._x+6*(-N+S)*P._x+(3*N-2*S)*Q._x,d._y=6*(N-S)*b._y+(3*N-4*S+1)*X._y+6*(-N+S)*P._y+(3*N-2*S)*Q._y,d._z=6*(N-S)*b._z+(3*N-4*S+1)*X._z+6*(-N+S)*P._z+(3*N-2*S)*Q._z,d._isDirty=!0,d}static Lerp(b,X,P){const Q=new E(0,0,0);return E.LerpToRef(b,X,P,Q),Q}static LerpToRef(b,X,P,Q){return Q._x=b._x+(X._x-b._x)*P,Q._y=b._y+(X._y-b._y)*P,Q._z=b._z+(X._z-b._z)*P,Q._isDirty=!0,Q}static Dot(b,X){return b._x*X._x+b._y*X._y+b._z*X._z}dot(b){return this._x*b._x+this._y*b._y+this._z*b._z}static Cross(b,X){const P=new E;return E.CrossToRef(b,X,P),P}static CrossToRef(b,X,P){const Q=b._y*X._z-b._z*X._y,S=b._z*X._x-b._x*X._z,d=b._x*X._y-b._y*X._x;return P.sd(Q,S,d),P}static Normalize(b){const X=E.Zero();return E.NormalizeToRef(b,X),X}static NormalizeToRef(b,X){return b.normalizeToRef(X),X}static Project(b,X,P,Q){const S=new E;return E.ProjectToRef(b,X,P,Q,S),S}static ProjectToRef(b,X,P,Q,S){var d;const N=Q.width,u=Q.height,w=Q.x,f=Q.y,O=n.Matrix[1],e=null===(d=a.e.LastCreatedEngine)||void 0===d?void 0:d.isNDCHalfZRange,Y=e?1:.5,D=e?0:.5;W.FromValuesToRef(N/2,0,0,0,0,-u/2,0,0,0,0,Y,0,w+N/2,u/2+f,D,1,O);const t=n.Matrix[0];return X.multiplyToRef(P,t),t.multiplyToRef(O,t),E.TransformCoordinatesToRef(b,t,S),S}static Reflect(b,X){return this.ReflectToRef(b,X,new E)}static ReflectToRef(b,X,P){const Q=y.tX[0];return Q.N(X).scaleInPlace(2*E.Dot(b,X)),P.N(b).fO(Q)}static _UnprojectFromInvertedMatrixToRef(b,X,P){E.TransformCoordinatesToRef(b,X,P);const Q=X.m,S=b._x*Q[3]+b._y*Q[7]+b._z*Q[11]+Q[15];return(0,u.WithinEpsilon)(S,1)&&P.scaleInPlace(1/S),P}static UnprojectFromTransform(b,X,P,Q,S){return this.Unproject(b,X,P,Q,S,W.IdentityReadOnly)}static Unproject(b,X,P,Q,S,d){const N=new E;return E.UnprojectToRef(b,X,P,Q,S,d,N),N}static UnprojectToRef(b,X,P,Q,S,d,N){return E.UnprojectFloatsToRef(b._x,b._y,b._z,X,P,Q,S,d,N),N}static UnprojectFloatsToRef(b,X,P,Q,S,d,N,u,w){var f;const O=n.Matrix[0];d.multiplyToRef(N,O),O.multiplyToRef(u,O),O.invert();const e=n.tX[0];return e.x=b/Q*2-1,e.y=-(X/S*2-1),null!==(f=a.e.LastCreatedEngine)&&void 0!==f&&f.isNDCHalfZRange?e.z=P:e.z=2*P-1,E._UnprojectFromInvertedMatrixToRef(e,O,w),w}static Minimize(b,X){const P=new E;return P.N(b),P.minimizeInPlace(X),P}static Maximize(b,X){const P=new E;return P.N(b),P.maximizeInPlace(X),P}static Distance(b,X){return Math.sqrt(E.DistanceSquared(b,X))}static DistanceSquared(b,X){const P=b._x-X._x,Q=b._y-X._y,S=b._z-X._z;return P*P+Q*Q+S*S}static ProjectOnTriangleToRef(b,X,P,S,d){const N=n.tX[0],a=n.tX[1],w=n.tX[2],f=n.tX[3],O=n.tX[4];P.subtractToRef(X,N),S.subtractToRef(X,a),S.subtractToRef(P,w);const e=N.length(),Y=a.length(),D=w.length();if(e<Q.c||Y<Q.c||D<Q.c)return d.N(X),E.Distance(b,X);b.subtractToRef(X,O),E.CrossToRef(N,a,f);const t=f.length();if(t<Q.c)return d.N(X),E.Distance(b,X);f.normalizeFromLength(t);let B=O.length();if(B<Q.c)return d.N(X),0;O.normalizeFromLength(B);const W=E.Dot(f,O),y=n.tX[5],h=n.tX[6];y.N(f).scaleInPlace(-B*W),h.N(b).addInPlace(y);const L=n.tX[4],Z=n.tX[5],v=n.tX[7],A=n.tX[8];L.N(N).scaleInPlace(1/e),A.N(a).scaleInPlace(1/Y),L.addInPlace(A).scaleInPlace(-1),Z.N(N).scaleInPlace(-1/e),A.N(w).scaleInPlace(1/D),Z.addInPlace(A).scaleInPlace(-1),v.N(w).scaleInPlace(-1/D),A.N(a).scaleInPlace(-1/Y),v.addInPlace(A).scaleInPlace(-1);const o=n.tX[9];let K;o.N(h).fO(X),E.CrossToRef(L,o,A),K=E.Dot(A,f);const T=K;o.N(h).fO(P),E.CrossToRef(Z,o,A),K=E.Dot(A,f);const q=K;o.N(h).fO(S),E.CrossToRef(v,o,A),K=E.Dot(A,f);const V=K,i=n.tX[10];let x,H;T>0&&q<0?(i.N(N),x=X,H=P):q>0&&V<0?(i.N(w),x=P,H=S):(i.N(a).scaleInPlace(-1),x=S,H=X);const C=n.tX[9],p=n.tX[4];x.subtractToRef(h,A),H.subtractToRef(h,C),E.CrossToRef(A,C,p);if(!(E.Dot(p,f)<0))return d.N(h),Math.abs(B*W);const k=n.tX[5];E.CrossToRef(i,p,k),k.normalize();const z=n.tX[9];z.N(x).fO(h);const U=z.length();if(U<Q.c)return d.N(x),E.Distance(b,x);z.normalizeFromLength(U);const g=E.Dot(k,z),j=n.tX[7];j.N(h).addInPlace(k.scaleInPlace(U*g)),A.N(j).fO(x),B=i.length(),i.normalizeFromLength(B);let l=E.Dot(A,i)/Math.max(B,Q.c);return l=(0,u.Clamp)(l,0,1),j.N(x).addInPlace(i.scaleInPlace(l*B)),d.N(j),E.Distance(b,j)}static Center(b,X){return E.CenterToRef(b,X,E.Zero())}static CenterToRef(b,X,P){return P.sd((b._x+X._x)/2,(b._y+X._y)/2,(b._z+X._z)/2)}static RotationFromAxis(b,X,P){const Q=new E;return E.RotationFromAxisToRef(b,X,P,Q),Q}static RotationFromAxisToRef(b,X,P,Q){const S=n.Quaternion[0];return B.RotationQuaternionFromAxisToRef(b,X,P,S),S.toEulerAnglesToRef(Q),Q}}E._V8PerformanceHack=new E(.5,.5,.5),E._UpReadOnly=E.Up(),E._DownReadOnly=E.Down(),E._LeftHandedForwardReadOnly=E.Forward(!1),E._RightHandedForwardReadOnly=E.Forward(!0),E._LeftHandedBackwardReadOnly=E.Backward(!1),E._RightHandedBackwardReadOnly=E.Backward(!0),E._RightReadOnly=E.Right(),E._LeftReadOnly=E.Left(),E._ZeroReadOnly=E.Zero(),E._OneReadOnly=E.One(),Object.defineProperties(E.prototype,{dimension:{value:[3]},rank:{value:1}});class t{get x(){return this._x}set x(b){this._x=b,this._isDirty=!0}get y(){return this._y}set y(b){this._y=b,this._isDirty=!0}get z(){return this._z}set z(b){this._z=b,this._isDirty=!0}get w(){return this._w}set w(b){this._w=b,this._isDirty=!0}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=b,this._y=X,this._z=P,this._w=Q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let b=Y(this._x);return b=397*b^Y(this._y),b=397*b^Y(this._z),b=397*b^Y(this._w),b}Zd(){return[this._x,this._y,this._z,this._w]}toArray(b,X){return void 0===X&&(X=0),b[X]=this._x,b[X+1]=this._y,b[X+2]=this._z,b[X+3]=this._w,this}tP(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(b,X,this),this}addInPlace(b){return this.x+=b._x,this.y+=b._y,this.z+=b._z,this.w+=b._w,this}addInPlaceFromFloats(b,X,P,Q){return this.x+=b,this.y+=X,this.z+=P,this.w+=Q,this}add(b){return new t(this._x+b.x,this._y+b.y,this._z+b.z,this._w+b.w)}addToRef(b,X){return X.x=this._x+b.x,X.y=this._y+b.y,X.z=this._z+b.z,X.w=this._w+b.w,X}fO(b){return this.x-=b.x,this.y-=b.y,this.z-=b.z,this.w-=b.w,this}BX(b){return new t(this._x-b.x,this._y-b.y,this._z-b.z,this._w-b.w)}subtractToRef(b,X){return X.x=this._x-b.x,X.y=this._y-b.y,X.z=this._z-b.z,X.w=this._w-b.w,X}subtractFromFloats(b,X,P,Q){return new t(this._x-b,this._y-X,this._z-P,this._w-Q)}subtractFromFloatsToRef(b,X,P,Q,S){return S.x=this._x-b,S.y=this._y-X,S.z=this._z-P,S.w=this._w-Q,S}negate(){return new t(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(b){return b.x=-this._x,b.y=-this._y,b.z=-this._z,b.w=-this._w,b}scaleInPlace(b){return this.x*=b,this.y*=b,this.z*=b,this.w*=b,this}scale(b){return new t(this._x*b,this._y*b,this._z*b,this._w*b)}scaleToRef(b,X){return X.x=this._x*b,X.y=this._y*b,X.z=this._z*b,X.w=this._w*b,X}scaleAndAddToRef(b,X){return X.x+=this._x*b,X.y+=this._y*b,X.z+=this._z*b,X.w+=this._w*b,X}equals(b){return b&&this._x===b.x&&this._y===b.y&&this._z===b.z&&this._w===b.w}equalsWithEpsilon(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.c;return b&&(0,u.WithinEpsilon)(this._x,b.x,X)&&(0,u.WithinEpsilon)(this._y,b.y,X)&&(0,u.WithinEpsilon)(this._z,b.z,X)&&(0,u.WithinEpsilon)(this._w,b.w,X)}equalsToFloats(b,X,P,Q){return this._x===b&&this._y===X&&this._z===P&&this._w===Q}multiplyInPlace(b){return this.x*=b.x,this.y*=b.y,this.z*=b.z,this.w*=b.w,this}multiply(b){return new t(this._x*b.x,this._y*b.y,this._z*b.z,this._w*b.w)}multiplyToRef(b,X){return X.x=this._x*b.x,X.y=this._y*b.y,X.z=this._z*b.z,X.w=this._w*b.w,X}multiplyByFloats(b,X,P,Q){return new t(this._x*b,this._y*X,this._z*P,this._w*Q)}divide(b){return new t(this._x/b.x,this._y/b.y,this._z/b.z,this._w/b.w)}divideToRef(b,X){return X.x=this._x/b.x,X.y=this._y/b.y,X.z=this._z/b.z,X.w=this._w/b.w,X}divideInPlace(b){return this.divideToRef(b,this)}minimizeInPlace(b){return b.x<this._x&&(this.x=b.x),b.y<this._y&&(this.y=b.y),b.z<this._z&&(this.z=b.z),b.w<this._w&&(this.w=b.w),this}maximizeInPlace(b){return b.x>this._x&&(this.x=b.x),b.y>this._y&&(this.y=b.y),b.z>this._z&&(this.z=b.z),b.w>this._w&&(this.w=b.w),this}minimizeInPlaceFromFloats(b,X,P,Q){return this.x=Math.min(b,this._x),this.y=Math.min(X,this._y),this.z=Math.min(P,this._z),this.w=Math.min(Q,this._w),this}maximizeInPlaceFromFloats(b,X,P,Q){return this.x=Math.max(b,this._x),this.y=Math.max(X,this._y),this.z=Math.max(P,this._z),this.w=Math.max(Q,this._w),this}floorToRef(b){return b.x=Math.floor(this._x),b.y=Math.floor(this._y),b.z=Math.floor(this._z),b.w=Math.floor(this._w),b}floor(){return new t(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(b){return b.x=this._x-Math.floor(this._x),b.y=this._y-Math.floor(this._y),b.z=this._z-Math.floor(this._z),b.w=this._w-Math.floor(this._w),b}fract(){return new t(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){return this.normalizeToRef(new t)}normalizeToRef(b){const X=this.length();return 0===X||1===X?(b.x=this._x,b.y=this._y,b.z=this._z,b.w=this._w,b):this.scaleToRef(1/X,b)}toVector3(){return new E(this._x,this._y,this._z)}clone(){return new t(this._x,this._y,this._z,this._w)}N(b){return this.x=b.x,this.y=b.y,this.z=b.z,this.w=b.w,this}sd(b,X,P,Q){return this.x=b,this.y=X,this.z=P,this.w=Q,this}set(b,X,P,Q){return this.sd(b,X,P,Q)}Gd(b){return this.x=this.y=this.z=this.w=b,this}dot(b){return this._x*b.x+this._y*b.y+this._z*b.z+this._w*b.w}static hX(b,X){return X||(X=0),new t(b[X],b[X+1],b[X+2],b[X+3])}static FromArrayToRef(b,X,P){return P.x=b[X],P.y=b[X+1],P.z=b[X+2],P.w=b[X+3],P}static FromFloatArrayToRef(b,X,P){return t.FromArrayToRef(b,X,P),P}static FromFloatsToRef(b,X,P,Q,S){return S.x=b,S.y=X,S.z=P,S.w=Q,S}static Zero(){return new t(0,0,0,0)}static One(){return new t(1,1,1,1)}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new t((0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0;return P.x=(0,u.RandomRange)(b,X),P.y=(0,u.RandomRange)(b,X),P.z=(0,u.RandomRange)(b,X),P.w=(0,u.RandomRange)(b,X),P}static Clamp(b,X,P){return t.ClampToRef(b,X,P,new t)}static ClampToRef(b,X,P,Q){return Q.x=(0,u.Clamp)(b.x,X.x,P.x),Q.y=(0,u.Clamp)(b.y,X.y,P.y),Q.z=(0,u.Clamp)(b.z,X.z,P.z),Q.w=(0,u.Clamp)(b.w,X.w,P.w),Q}static CheckExtends(b,X,P){X.minimizeInPlace(b),P.maximizeInPlace(b)}static get ZeroReadOnly(){return t._ZeroReadOnly}static Normalize(b){return t.NormalizeToRef(b,new t)}static NormalizeToRef(b,X){return b.normalizeToRef(X),X}static Minimize(b,X){const P=new t;return P.N(b),P.minimizeInPlace(X),P}static Maximize(b,X){const P=new t;return P.N(b),P.maximizeInPlace(X),P}static Distance(b,X){return Math.sqrt(t.DistanceSquared(b,X))}static DistanceSquared(b,X){const P=b.x-X.x,Q=b.y-X.y,S=b.z-X.z,d=b.w-X.w;return P*P+Q*Q+S*S+d*d}static Center(b,X){return t.CenterToRef(b,X,new t)}static CenterToRef(b,X,P){return P.x=(b.x+X.x)/2,P.y=(b.y+X.y)/2,P.z=(b.z+X.z)/2,P.w=(b.w+X.w)/2,P}static TransformCoordinates(b,X){return t.TransformCoordinatesToRef(b,X,new t)}static TransformCoordinatesToRef(b,X,P){return t.TransformCoordinatesFromFloatsToRef(b._x,b._y,b._z,X,P),P}static TransformCoordinatesFromFloatsToRef(b,X,P,Q,S){const d=Q.m,N=b*d[0]+X*d[4]+P*d[8]+d[12],a=b*d[1]+X*d[5]+P*d[9]+d[13],u=b*d[2]+X*d[6]+P*d[10]+d[14],w=b*d[3]+X*d[7]+P*d[11]+d[15];return S.x=N,S.y=a,S.z=u,S.w=w,S}static TransformNormal(b,X){return t.TransformNormalToRef(b,X,new t)}static TransformNormalToRef(b,X,P){const Q=X.m,S=b.x*Q[0]+b.y*Q[4]+b.z*Q[8],d=b.x*Q[1]+b.y*Q[5]+b.z*Q[9],N=b.x*Q[2]+b.y*Q[6]+b.z*Q[10];return P.x=S,P.y=d,P.z=N,P.w=b.w,P}static TransformNormalFromFloatsToRef(b,X,P,Q,S,d){const N=S.m;return d.x=b*N[0]+X*N[4]+P*N[8],d.y=b*N[1]+X*N[5]+P*N[9],d.z=b*N[2]+X*N[6]+P*N[10],d.w=Q,d}static FromVector3(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new t(b._x,b._y,b._z,X)}static Dot(b,X){return b.x*X.x+b.y*X.y+b.z*X.z+b.w*X.w}}t._V8PerformanceHack=new t(.5,.5,.5,.5),t._ZeroReadOnly=t.Zero(),Object.defineProperties(t.prototype,{dimension:{value:[4]},rank:{value:1}});class B{get x(){return this._x}set x(b){this._x=b,this._isDirty=!0}get y(){return this._y}set y(b){this._y=b,this._isDirty=!0}get z(){return this._z}set z(b){this._z=b,this._isDirty=!0}get w(){return this._w}set w(b){this._w=b,this._isDirty=!0}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=b,this._y=X,this._z=P,this._w=Q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let b=Y(this._x);return b=397*b^Y(this._y),b=397*b^Y(this._z),b=397*b^Y(this._w),b}Zd(){return[this._x,this._y,this._z,this._w]}toArray(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[X]=this._x,b[X+1]=this._y,b[X+2]=this._z,b[X+3]=this._w,this}tP(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B.FromArrayToRef(b,X,this)}equals(b){return b&&this._x===b._x&&this._y===b._y&&this._z===b._z&&this._w===b._w}equalsWithEpsilon(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.c;return b&&(0,u.WithinEpsilon)(this._x,b._x,X)&&(0,u.WithinEpsilon)(this._y,b._y,X)&&(0,u.WithinEpsilon)(this._z,b._z,X)&&(0,u.WithinEpsilon)(this._w,b._w,X)}isApprox(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.c;return b&&((0,u.WithinEpsilon)(this._x,b._x,X)&&(0,u.WithinEpsilon)(this._y,b._y,X)&&(0,u.WithinEpsilon)(this._z,b._z,X)&&(0,u.WithinEpsilon)(this._w,b._w,X)||(0,u.WithinEpsilon)(this._x,-b._x,X)&&(0,u.WithinEpsilon)(this._y,-b._y,X)&&(0,u.WithinEpsilon)(this._z,-b._z,X)&&(0,u.WithinEpsilon)(this._w,-b._w,X))}clone(){return new B(this._x,this._y,this._z,this._w)}N(b){return this._x=b._x,this._y=b._y,this._z=b._z,this._w=b._w,this._isDirty=!0,this}sd(b,X,P,Q){return this._x=b,this._y=X,this._z=P,this._w=Q,this._isDirty=!0,this}set(b,X,P,Q){return this.sd(b,X,P,Q)}Gd(b){return this.sd(b,b,b,b)}add(b){return new B(this._x+b._x,this._y+b._y,this._z+b._z,this._w+b._w)}addInPlace(b){return this._x+=b._x,this._y+=b._y,this._z+=b._z,this._w+=b._w,this._isDirty=!0,this}addToRef(b,X){return X._x=this._x+b._x,X._y=this._y+b._y,X._z=this._z+b._z,X._w=this._w+b._w,X._isDirty=!0,X}addInPlaceFromFloats(b,X,P,Q){return this._x+=b,this._y+=X,this._z+=P,this._w+=Q,this._isDirty=!0,this}subtractToRef(b,X){return X._x=this._x-b._x,X._y=this._y-b._y,X._z=this._z-b._z,X._w=this._w-b._w,X._isDirty=!0,X}subtractFromFloats(b,X,P,Q){return this.subtractFromFloatsToRef(b,X,P,Q,new B)}subtractFromFloatsToRef(b,X,P,Q,S){return S._x=this._x-b,S._y=this._y-X,S._z=this._z-P,S._w=this._w-Q,S._isDirty=!0,S}BX(b){return new B(this._x-b._x,this._y-b._y,this._z-b._z,this._w-b._w)}fO(b){return this._x-=b._x,this._y-=b._y,this._z-=b._z,this._w-=b._w,this._isDirty=!0,this}scale(b){return new B(this._x*b,this._y*b,this._z*b,this._w*b)}scaleToRef(b,X){return X._x=this._x*b,X._y=this._y*b,X._z=this._z*b,X._w=this._w*b,X._isDirty=!0,X}scaleInPlace(b){return this._x*=b,this._y*=b,this._z*=b,this._w*=b,this._isDirty=!0,this}scaleAndAddToRef(b,X){return X._x+=this._x*b,X._y+=this._y*b,X._z+=this._z*b,X._w+=this._w*b,X._isDirty=!0,X}multiply(b){const X=new B(0,0,0,1);return this.multiplyToRef(b,X),X}multiplyToRef(b,X){const P=this._x*b._w+this._y*b._z-this._z*b._y+this._w*b._x,Q=-this._x*b._z+this._y*b._w+this._z*b._x+this._w*b._y,S=this._x*b._y-this._y*b._x+this._z*b._w+this._w*b._z,d=-this._x*b._x-this._y*b._y-this._z*b._z+this._w*b._w;return X.sd(P,Q,S,d),X}multiplyInPlace(b){return this.multiplyToRef(b,this)}multiplyByFloats(b,X,P,Q){return this._x*=b,this._y*=X,this._z*=P,this._w*=Q,this._isDirty=!0,this}divide(b){throw new ReferenceError("Can not divide a quaternion")}divideToRef(b,X){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(b){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new B)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(b){return b._x=-this._x,b._y=-this._y,b._z=-this._z,b._w=-this._w,b._isDirty=!0,b}equalsToFloats(b,X,P,Q){return this._x===b&&this._y===X&&this._z===P&&this._w===Q}floorToRef(b){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(b){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(b){return b.sd(-this._x,-this._y,-this._z,this._w),b}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new B(-this._x,-this._y,-this._z,this._w)}invert(){const b=this.conjugate(),X=this.lengthSquared();return 0==X||1==X||b.scaleInPlace(1/X),b}invertInPlace(){this.conjugateInPlace();const b=this.lengthSquared();return 0==b||1==b||this.scaleInPlace(1/b),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){const b=new B(0,0,0,1);return this.normalizeToRef(b),b}normalizeToRef(b){const X=this.length();return 0===X||1===X?b.sd(this._x,this._y,this._z,this._w):this.scaleToRef(1/X,b)}toEulerAngles(){const b=E.Zero();return this.toEulerAnglesToRef(b),b}toEulerAnglesToRef(b){const X=this._z,P=this._x,Q=this._y,S=this._w,d=Q*X-P*S,N=.4999999;if(d<-N)b._y=2*Math.atan2(Q,S),b._x=Math.PI/2,b._z=0,b._isDirty=!0;else if(d>N)b._y=2*Math.atan2(Q,S),b._x=-Math.PI/2,b._z=0,b._isDirty=!0;else{const N=S*S,a=X*X,u=P*P,w=Q*Q;b._z=Math.atan2(2*(P*Q+X*S),-a-u+w+N),b._x=Math.asin(-2*d),b._y=Math.atan2(2*(X*P+Q*S),a-u-w+N),b._isDirty=!0}return b}toAlphaBetaGammaToRef(b){const X=this._z,P=this._x,Q=this._y,S=this._w,d=Math.sqrt(P*P+Q*Q),N=Math.sqrt(X*X+S*S),a=2*Math.atan2(d,N),u=2*Math.atan2(X,S),w=2*Math.atan2(Q,P),f=(u+w)/2,O=(u-w)/2;return b.set(O,a,f),b}toRotationMatrix(b){return W.FromQuaternionToRef(this,b),b}fromRotationMatrix(b){return B.FromRotationMatrixToRef(b,this),this}dot(b){return this._x*b._x+this._y*b._y+this._z*b._z+this._w*b._w}toAxisAngle(){const b=E.Zero();return{axis:b,angle:this.toAxisAngleToRef(b)}}toAxisAngleToRef(b){let X=0;const P=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),Q=this._w;return P>0?(X=2*Math.atan2(P,Q),b.set(this._x/P,this._y/P,this._z/P)):(X=0,b.set(1,0,0)),X}static FromRotationMatrix(b){const X=new B;return B.FromRotationMatrixToRef(b,X),X}static FromRotationMatrixToRef(b,X){const P=b.m,Q=P[0],S=P[4],d=P[8],N=P[1],a=P[5],u=P[9],w=P[2],f=P[6],O=P[10],e=Q+a+O;let Y;return e>0?(Y=.5/Math.sqrt(e+1),X._w=.25/Y,X._x=(f-u)*Y,X._y=(d-w)*Y,X._z=(N-S)*Y,X._isDirty=!0):Q>a&&Q>O?(Y=2*Math.sqrt(1+Q-a-O),X._w=(f-u)/Y,X._x=.25*Y,X._y=(S+N)/Y,X._z=(d+w)/Y,X._isDirty=!0):a>O?(Y=2*Math.sqrt(1+a-Q-O),X._w=(d-w)/Y,X._x=(S+N)/Y,X._y=.25*Y,X._z=(u+f)/Y,X._isDirty=!0):(Y=2*Math.sqrt(1+O-Q-a),X._w=(N-S)/Y,X._x=(d+w)/Y,X._y=(u+f)/Y,X._z=.25*Y,X._isDirty=!0),X}static Dot(b,X){return b._x*X._x+b._y*X._y+b._z*X._z+b._w*X._w}static AreClose(b,X){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const Q=B.Dot(b,X);return 1-Q*Q<=P}static SmoothToRef(b,X,P,Q,S){let d=0===Q?1:P/Q;return d=(0,u.Clamp)(d,0,1),B.SlerpToRef(b,X,d,S),S}static Zero(){return new B(0,0,0,0)}static Inverse(b){return new B(-b._x,-b._y,-b._z,b._w)}static InverseToRef(b,X){return X.set(-b._x,-b._y,-b._z,b._w),X}static Identity(){return new B(0,0,0,1)}static IsIdentity(b){return b&&0===b._x&&0===b._y&&0===b._z&&1===b._w}static RotationAxis(b,X){return B.RotationAxisToRef(b,X,new B)}static RotationAxisToRef(b,X,P){P._w=Math.cos(X/2);const Q=Math.sin(X/2)/b.length();return P._x=b._x*Q,P._y=b._y*Q,P._z=b._z*Q,P._isDirty=!0,P}static hX(b,X){return X||(X=0),new B(b[X],b[X+1],b[X+2],b[X+3])}static FromArrayToRef(b,X,P){return P._x=b[X],P._y=b[X+1],P._z=b[X+2],P._w=b[X+3],P._isDirty=!0,P}static FromFloatsToRef(b,X,P,Q,S){return S.sd(b,X,P,Q),S}static FromEulerAngles(b,X,P){const Q=new B;return B.RotationYawPitchRollToRef(X,b,P,Q),Q}static FromEulerAnglesToRef(b,X,P,Q){return B.RotationYawPitchRollToRef(X,b,P,Q),Q}static FromEulerVector(b){const X=new B;return B.RotationYawPitchRollToRef(b._y,b._x,b._z,X),X}static FromEulerVectorToRef(b,X){return B.RotationYawPitchRollToRef(b._y,b._x,b._z,X),X}static FromUnitVectorsToRef(b,X,P){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Q.c;const d=E.Dot(b,X)+1;return d<S?Math.abs(b.x)>Math.abs(b.z)?P.set(-b.y,b.x,0,0):P.set(0,-b.z,b.y,0):(E.CrossToRef(b,X,y.tX[0]),P.set(y.tX[0].x,y.tX[0].y,y.tX[0].z,d)),P.normalize()}static RotationYawPitchRoll(b,X,P){const Q=new B;return B.RotationYawPitchRollToRef(b,X,P,Q),Q}static RotationYawPitchRollToRef(b,X,P,Q){const S=.5*P,d=.5*X,N=.5*b,a=Math.sin(S),u=Math.cos(S),w=Math.sin(d),f=Math.cos(d),O=Math.sin(N),e=Math.cos(N);return Q._x=e*w*u+O*f*a,Q._y=O*f*u-e*w*a,Q._z=e*f*a-O*w*u,Q._w=e*f*u+O*w*a,Q._isDirty=!0,Q}static RotationAlphaBetaGamma(b,X,P){const Q=new B;return B.RotationAlphaBetaGammaToRef(b,X,P,Q),Q}static RotationAlphaBetaGammaToRef(b,X,P,Q){const S=.5*(P+b),d=.5*(P-b),N=.5*X;return Q._x=Math.cos(d)*Math.sin(N),Q._y=Math.sin(d)*Math.sin(N),Q._z=Math.sin(S)*Math.cos(N),Q._w=Math.cos(S)*Math.cos(N),Q._isDirty=!0,Q}static RotationQuaternionFromAxis(b,X,P){const Q=new B(0,0,0,0);return B.RotationQuaternionFromAxisToRef(b,X,P,Q),Q}static RotationQuaternionFromAxisToRef(b,X,P,Q){const S=n.Matrix[0];return b=b.normalizeToRef(n.tX[0]),X=X.normalizeToRef(n.tX[1]),P=P.normalizeToRef(n.tX[2]),W.FromXYZAxesToRef(b,X,P,S),B.FromRotationMatrixToRef(S,Q),Q}static FromLookDirectionLH(b,X){const P=new B;return B.FromLookDirectionLHToRef(b,X,P),P}static FromLookDirectionLHToRef(b,X,P){const Q=n.Matrix[0];return W.LookDirectionLHToRef(b,X,Q),B.FromRotationMatrixToRef(Q,P),P}static FromLookDirectionRH(b,X){const P=new B;return B.FromLookDirectionRHToRef(b,X,P),P}static FromLookDirectionRHToRef(b,X,P){const Q=n.Matrix[0];return W.LookDirectionRHToRef(b,X,Q),B.FromRotationMatrixToRef(Q,P)}static Slerp(b,X,P){const Q=B.Identity();return B.SlerpToRef(b,X,P,Q),Q}static SlerpToRef(b,X,P,Q){let S,d,N=b._x*X._x+b._y*X._y+b._z*X._z+b._w*X._w,a=!1;if(N<0&&(a=!0,N=-N),N>.999999)d=1-P,S=a?-P:P;else{const b=Math.acos(N),X=1/Math.sin(b);d=Math.sin((1-P)*b)*X,S=a?-Math.sin(P*b)*X:Math.sin(P*b)*X}return Q._x=d*b._x+S*X._x,Q._y=d*b._y+S*X._y,Q._z=d*b._z+S*X._z,Q._w=d*b._w+S*X._w,Q._isDirty=!0,Q}static Hermite(b,X,P,Q,S){const d=S*S,N=S*d,a=2*N-3*d+1,u=-2*N+3*d,w=N-2*d+S,f=N-d,O=b._x*a+P._x*u+X._x*w+Q._x*f,e=b._y*a+P._y*u+X._y*w+Q._y*f,Y=b._z*a+P._z*u+X._z*w+Q._z*f,D=b._w*a+P._w*u+X._w*w+Q._w*f;return new B(O,e,Y,D)}static Hermite1stDerivative(b,X,P,Q,S){const d=new B;return this.Hermite1stDerivativeToRef(b,X,P,Q,S,d),d}static Hermite1stDerivativeToRef(b,X,P,Q,S,d){const N=S*S;return d._x=6*(N-S)*b._x+(3*N-4*S+1)*X._x+6*(-N+S)*P._x+(3*N-2*S)*Q._x,d._y=6*(N-S)*b._y+(3*N-4*S+1)*X._y+6*(-N+S)*P._y+(3*N-2*S)*Q._y,d._z=6*(N-S)*b._z+(3*N-4*S+1)*X._z+6*(-N+S)*P._z+(3*N-2*S)*Q._z,d._w=6*(N-S)*b._w+(3*N-4*S+1)*X._w+6*(-N+S)*P._w+(3*N-2*S)*Q._w,d._isDirty=!0,d}static Normalize(b){const X=B.Zero();return B.NormalizeToRef(b,X),X}static NormalizeToRef(b,X){return b.normalizeToRef(X),X}static Clamp(b,X,P){const Q=new B;return B.ClampToRef(b,X,P,Q),Q}static ClampToRef(b,X,P,Q){return Q.sd((0,u.Clamp)(b.x,X.x,P.x),(0,u.Clamp)(b.y,X.y,P.y),(0,u.Clamp)(b.z,X.z,P.z),(0,u.Clamp)(b.w,X.w,P.w))}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new B((0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).sd((0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X),(0,u.RandomRange)(b,X))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(b,X){return Math.sqrt(B.DistanceSquared(b,X))}static DistanceSquared(b,X){const P=b.x-X.x,Q=b.y-X.y,S=b.z-X.z,d=b.w-X.w;return P*P+Q*Q+S*S+d*d}static Center(b,X){return B.CenterToRef(b,X,B.Zero())}static CenterToRef(b,X,P){return P.sd((b.x+X.x)/2,(b.y+X.y)/2,(b.z+X.z)/2,(b.w+X.w)/2)}}B._V8PerformanceHack=new B(.5,.5,.5,.5),Object.defineProperties(B.prototype,{dimension:{value:[4]},rank:{value:1}});class W{static get Use64Bits(){return N.e.MatrixUse64Bits}get m(){return this.wd}markAsUpdated(){this.updateFlag=w._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(b){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=b,this._isIdentity3x2=b||P,this._isIdentityDirty=!this._isIdentity&&X,this._isIdentity3x2Dirty=!this._isIdentity3x2&&Q}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,N.e.MatrixTrackPrecisionChange&&N.e.MatrixTrackedMatrices.push(this),this.wd=new N.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const b=this.wd;this._isIdentity=1===b[0]&&0===b[1]&&0===b[2]&&0===b[3]&&0===b[4]&&1===b[5]&&0===b[6]&&0===b[7]&&0===b[8]&&0===b[9]&&1===b[10]&&0===b[11]&&0===b[12]&&0===b[13]&&0===b[14]&&1===b[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.wd[0]||1!==this.wd[5]||1!==this.wd[15]||0!==this.wd[1]||0!==this.wd[2]||0!==this.wd[3]||0!==this.wd[4]||0!==this.wd[6]||0!==this.wd[7]||0!==this.wd[8]||0!==this.wd[9]||0!==this.wd[10]||0!==this.wd[11]||0!==this.wd[12]||0!==this.wd[13]||0!==this.wd[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const b=this.wd,X=b[0],P=b[1],Q=b[2],S=b[3],d=b[4],N=b[5],a=b[6],u=b[7],w=b[8],f=b[9],O=b[10],e=b[11],Y=b[12],D=b[13],E=b[14],t=b[15],B=O*t-E*e,W=f*t-D*e,n=f*E-D*O,y=w*t-Y*e,h=w*E-O*Y,L=w*D-Y*f;return X*+(N*B-a*W+u*n)+P*-(d*B-a*y+u*h)+Q*+(d*W-N*y+u*L)+S*-(d*n-N*h+a*L)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!b)return this.wd;const P=this.wd;for(let Q=0;Q<16;Q++)b[X+Q]=P[Q];return this}Zd(){return this.wd}tP(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return W.FromArrayToRef(b,X,this)}sd(){for(var b=arguments.length,X=new Array(b),P=0;P<b;P++)X[P]=arguments[P];return W.FromArrayToRef(X,0,this)}set(){const b=this.wd;for(let X=0;X<16;X++)b[X]=X<0||arguments.length<=X?void 0:arguments[X];return this.markAsUpdated(),this}Gd(b){const X=this.wd;for(let P=0;P<16;P++)X[P]=b;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return W.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(b){const X=new W;return this.addToRef(b,X),X}addToRef(b,X){const P=this.wd,Q=X.wd,S=b.m;for(let d=0;d<16;d++)Q[d]=P[d]+S[d];return X.markAsUpdated(),X}addToSelf(b){const X=this.wd,P=b.m;return X[0]+=P[0],X[1]+=P[1],X[2]+=P[2],X[3]+=P[3],X[4]+=P[4],X[5]+=P[5],X[6]+=P[6],X[7]+=P[7],X[8]+=P[8],X[9]+=P[9],X[10]+=P[10],X[11]+=P[11],X[12]+=P[12],X[13]+=P[13],X[14]+=P[14],X[15]+=P[15],this.markAsUpdated(),this}addInPlace(b){const X=this.wd,P=b.m;for(let Q=0;Q<16;Q++)X[Q]+=P[Q];return this.markAsUpdated(),this}addInPlaceFromFloats(){const b=this.wd;for(let X=0;X<16;X++)b[X]+=X<0||arguments.length<=X?void 0:arguments[X];return this.markAsUpdated(),this}BX(b){const X=this.wd,P=b.m;for(let Q=0;Q<16;Q++)X[Q]-=P[Q];return this.markAsUpdated(),this}subtractToRef(b,X){const P=this.wd,Q=b.m,S=X.wd;for(let d=0;d<16;d++)S[d]=P[d]-Q[d];return X.markAsUpdated(),X}fO(b){const X=this.wd,P=b.m;for(let Q=0;Q<16;Q++)X[Q]-=P[Q];return this.markAsUpdated(),this}subtractFromFloats(){for(var b=arguments.length,X=new Array(b),P=0;P<b;P++)X[P]=arguments[P];return this.subtractFromFloatsToRef(...X,new W)}subtractFromFloatsToRef(){for(var b=arguments.length,X=new Array(b),P=0;P<b;P++)X[P]=arguments[P];const Q=X.pop(),S=this.wd,d=Q.wd,N=X;for(let a=0;a<16;a++)d[a]=S[a]-N[a];return Q.markAsUpdated(),Q}invertToRef(b){return!0===this._isIdentity?(W.IdentityToRef(b),b):(e(this,b.Zd())?b.markAsUpdated():b.N(this),b)}addAtIndex(b,X){return this.wd[b]+=X,this.markAsUpdated(),this}multiplyAtIndex(b,X){return this.wd[b]*=X,this.markAsUpdated(),this}setTranslationFromFloats(b,X,P){return this.wd[12]=b,this.wd[13]=X,this.wd[14]=P,this.markAsUpdated(),this}addTranslationFromFloats(b,X,P){return this.wd[12]+=b,this.wd[13]+=X,this.wd[14]+=P,this.markAsUpdated(),this}setTranslation(b){return this.setTranslationFromFloats(b._x,b._y,b._z)}getTranslation(){return new E(this.wd[12],this.wd[13],this.wd[14])}getTranslationToRef(b){return b.x=this.wd[12],b.y=this.wd[13],b.z=this.wd[14],b}removeRotationAndScaling(){const b=this.m;return W.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,b[12],b[13],b[14],b[15],this),this._updateIdentityStatus(0===b[12]&&0===b[13]&&0===b[14]&&1===b[15]),this}N(b){b.copyToArray(this.wd);const X=b;return this.updateFlag=X.updateFlag,this._updateIdentityStatus(X._isIdentity,X._isIdentityDirty,X._isIdentity3x2,X._isIdentity3x2Dirty),this}copyToArray(b){return O(this,b,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(b){const X=new W;return this.multiplyToRef(b,X),X}multiplyInPlace(b){const X=this.wd,P=b.m;for(let Q=0;Q<16;Q++)X[Q]*=P[Q];return this.markAsUpdated(),this}multiplyByFloats(){const b=this.wd;for(let X=0;X<16;X++)b[X]*=X<0||arguments.length<=X?void 0:arguments[X];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var b=arguments.length,X=new Array(b),P=0;P<b;P++)X[P]=arguments[P];const Q=X.pop(),S=this.wd,d=Q.wd,N=X;for(let a=0;a<16;a++)d[a]=S[a]*N[a];return Q.markAsUpdated(),Q}multiplyToRef(b,X){return this._isIdentity?(X.N(b),X):b._isIdentity?(X.N(this),X):(this.multiplyToArray(b,X.wd,0),X.markAsUpdated(),X)}multiplyToArray(b,X,P){return f(this,b,X,P),this}divide(b){return this.divideToRef(b,new W)}divideToRef(b,X){const P=this.wd,Q=b.m,S=X.wd;for(let d=0;d<16;d++)S[d]=P[d]/Q[d];return X.markAsUpdated(),X}divideInPlace(b){const X=this.wd,P=b.m;for(let Q=0;Q<16;Q++)X[Q]/=P[Q];return this.markAsUpdated(),this}minimizeInPlace(b){const X=this.wd,P=b.m;for(let Q=0;Q<16;Q++)X[Q]=Math.min(X[Q],P[Q]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const b=this.wd;for(let X=0;X<16;X++)b[X]=Math.min(b[X],X<0||arguments.length<=X?void 0:arguments[X]);return this.markAsUpdated(),this}maximizeInPlace(b){const X=this.wd,P=b.m;for(let Q=0;Q<16;Q++)X[Q]=Math.min(X[Q],P[Q]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const b=this.wd;for(let X=0;X<16;X++)b[X]=Math.min(b[X],X<0||arguments.length<=X?void 0:arguments[X]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new W)}negateInPlace(){const b=this.wd;for(let X=0;X<16;X++)b[X]=-b[X];return this.markAsUpdated(),this}negateToRef(b){const X=this.wd,P=b.wd;for(let Q=0;Q<16;Q++)P[Q]=-X[Q];return b.markAsUpdated(),b}equals(b){const X=b;if(!X)return!1;if((this._isIdentity||X._isIdentity)&&!this._isIdentityDirty&&!X._isIdentityDirty)return this._isIdentity&&X._isIdentity;const P=this.m,Q=X.m;return P[0]===Q[0]&&P[1]===Q[1]&&P[2]===Q[2]&&P[3]===Q[3]&&P[4]===Q[4]&&P[5]===Q[5]&&P[6]===Q[6]&&P[7]===Q[7]&&P[8]===Q[8]&&P[9]===Q[9]&&P[10]===Q[10]&&P[11]===Q[11]&&P[12]===Q[12]&&P[13]===Q[13]&&P[14]===Q[14]&&P[15]===Q[15]}equalsWithEpsilon(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=this.wd,Q=b.m;for(let S=0;S<16;S++)if(!(0,u.WithinEpsilon)(P[S],Q[S],X))return!1;return!0}equalsToFloats(){const b=this.wd;for(let X=0;X<16;X++)if(b[X]!=(X<0||arguments.length<=X?void 0:arguments[X]))return!1;return!0}floor(){return this.floorToRef(new W)}floorToRef(b){const X=this.wd,P=b.wd;for(let Q=0;Q<16;Q++)P[Q]=Math.floor(X[Q]);return b.markAsUpdated(),b}fract(){return this.fractToRef(new W)}fractToRef(b){const X=this.wd,P=b.wd;for(let Q=0;Q<16;Q++)P[Q]=X[Q]-Math.floor(X[Q]);return b.markAsUpdated(),b}clone(){const b=new W;return b.N(this),b}getClassName(){return"Matrix"}getHashCode(){let b=Y(this.wd[0]);for(let X=1;X<16;X++)b=397*b^Y(this.wd[X]);return b}decomposeToTransformNode(b){return b.rotationQuaternion=b.rotationQuaternion||new B,this.decompose(b.Fd,b.rotationQuaternion,b.position)}decompose(b,X,P,Q){let S=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return P&&P.Gd(0),b&&b.Gd(1),X&&X.sd(0,0,0,1),!0;const d=this.wd;if(P&&P.sd(d[12],d[13],d[14]),(b=b||n.tX[0]).x=Math.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]),b.y=Math.sqrt(d[4]*d[4]+d[5]*d[5]+d[6]*d[6]),b.z=Math.sqrt(d[8]*d[8]+d[9]*d[9]+d[10]*d[10]),Q){const X=(S?Q.absoluteScaling.x:Q.Fd.x)<0?-1:1,P=(S?Q.absoluteScaling.y:Q.Fd.y)<0?-1:1,d=(S?Q.absoluteScaling.z:Q.Fd.z)<0?-1:1;b.x*=X,b.y*=P,b.z*=d}else this.determinant()<=0&&(b.y*=-1);if(0===b._x||0===b._y||0===b._z)return X&&X.sd(0,0,0,1),!1;if(X){const P=1/b._x,Q=1/b._y,S=1/b._z;W.FromValuesToRef(d[0]*P,d[1]*P,d[2]*P,0,d[4]*Q,d[5]*Q,d[6]*Q,0,d[8]*S,d[9]*S,d[10]*S,0,0,0,0,1,n.Matrix[0]),B.FromRotationMatrixToRef(n.Matrix[0],X)}return!0}getRow(b){if(b<0||b>3)return null;const X=4*b;return new t(this.wd[X+0],this.wd[X+1],this.wd[X+2],this.wd[X+3])}getRowToRef(b,X){if(b>=0&&b<=3){const P=4*b;X.x=this.wd[P+0],X.y=this.wd[P+1],X.z=this.wd[P+2],X.w=this.wd[P+3]}return X}setRow(b,X){return this.setRowFromFloats(b,X.x,X.y,X.z,X.w)}transpose(){const b=new W;return W.TransposeToRef(this,b),b}transposeToRef(b){return W.TransposeToRef(this,b),b}setRowFromFloats(b,X,P,Q,S){if(b<0||b>3)return this;const d=4*b;return this.wd[d+0]=X,this.wd[d+1]=P,this.wd[d+2]=Q,this.wd[d+3]=S,this.markAsUpdated(),this}scale(b){const X=new W;return this.scaleToRef(b,X),X}scaleToRef(b,X){for(let P=0;P<16;P++)X.wd[P]=this.wd[P]*b;return X.markAsUpdated(),X}scaleAndAddToRef(b,X){for(let P=0;P<16;P++)X.wd[P]+=this.wd[P]*b;return X.markAsUpdated(),X}scaleInPlace(b){const X=this.wd;for(let P=0;P<16;P++)X[P]*=b;return this.markAsUpdated(),this}toNormalMatrix(b){const X=n.Matrix[0];this.invertToRef(X),X.transposeToRef(b);const P=b.wd;return W.FromValuesToRef(P[0],P[1],P[2],0,P[4],P[5],P[6],0,P[8],P[9],P[10],0,0,0,0,1,b),b}getRotationMatrix(){const b=new W;return this.getRotationMatrixToRef(b),b}getRotationMatrixToRef(b){const X=n.tX[0];if(!this.decompose(X))return W.IdentityToRef(b),b;const P=this.wd,Q=1/X._x,S=1/X._y,d=1/X._z;return W.FromValuesToRef(P[0]*Q,P[1]*Q,P[2]*Q,0,P[4]*S,P[5]*S,P[6]*S,0,P[8]*d,P[9]*d,P[10]*d,0,0,0,0,1,b),b}toggleModelMatrixHandInPlace(){const b=this.wd;return b[2]*=-1,b[6]*=-1,b[8]*=-1,b[9]*=-1,b[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const b=this.wd;return b[8]*=-1,b[9]*=-1,b[10]*=-1,b[11]*=-1,this.markAsUpdated(),this}static hX(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=new W;return W.FromArrayToRef(b,X,P),P}static FromArrayToRef(b,X,P){for(let Q=0;Q<16;Q++)P.wd[Q]=b[Q+X];return P.markAsUpdated(),P}static FromFloat32ArrayToRefScaled(b,X,P,Q){return Q.wd[0]=b[0+X]*P,Q.wd[1]=b[1+X]*P,Q.wd[2]=b[2+X]*P,Q.wd[3]=b[3+X]*P,Q.wd[4]=b[4+X]*P,Q.wd[5]=b[5+X]*P,Q.wd[6]=b[6+X]*P,Q.wd[7]=b[7+X]*P,Q.wd[8]=b[8+X]*P,Q.wd[9]=b[9+X]*P,Q.wd[10]=b[10+X]*P,Q.wd[11]=b[11+X]*P,Q.wd[12]=b[12+X]*P,Q.wd[13]=b[13+X]*P,Q.wd[14]=b[14+X]*P,Q.wd[15]=b[15+X]*P,Q.markAsUpdated(),Q}static get IdentityReadOnly(){return W._IdentityReadOnly}static FromValuesToRef(b,X,P,Q,S,d,N,a,u,w,f,O,e,Y,D,E,t){const B=t.wd;B[0]=b,B[1]=X,B[2]=P,B[3]=Q,B[4]=S,B[5]=d,B[6]=N,B[7]=a,B[8]=u,B[9]=w,B[10]=f,B[11]=O,B[12]=e,B[13]=Y,B[14]=D,B[15]=E,t.markAsUpdated()}static FromValues(b,X,P,Q,S,d,N,a,u,w,f,O,e,Y,D,E){const t=new W,B=t.wd;return B[0]=b,B[1]=X,B[2]=P,B[3]=Q,B[4]=S,B[5]=d,B[6]=N,B[7]=a,B[8]=u,B[9]=w,B[10]=f,B[11]=O,B[12]=e,B[13]=Y,B[14]=D,B[15]=E,t.markAsUpdated(),t}static Compose(b,X,P){const Q=new W;return W.ComposeToRef(b,X,P,Q),Q}static ComposeToRef(b,X,P,Q){const S=Q.wd,d=X._x,N=X._y,a=X._z,u=X._w,w=d+d,f=N+N,O=a+a,e=d*w,Y=d*f,D=d*O,E=N*f,t=N*O,B=a*O,W=u*w,n=u*f,y=u*O,h=b._x,L=b._y,Z=b._z;return S[0]=(1-(E+B))*h,S[1]=(Y+y)*h,S[2]=(D-n)*h,S[3]=0,S[4]=(Y-y)*L,S[5]=(1-(e+B))*L,S[6]=(t+W)*L,S[7]=0,S[8]=(D+n)*Z,S[9]=(t-W)*Z,S[10]=(1-(e+E))*Z,S[11]=0,S[12]=P._x,S[13]=P._y,S[14]=P._z,S[15]=1,Q.markAsUpdated(),Q}static Identity(){const b=W.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return b._updateIdentityStatus(!0),b}static IdentityToRef(b){return W.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,b),b._updateIdentityStatus(!0),b}static Zero(){const b=W.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return b._updateIdentityStatus(!1),b}static RotationX(b){const X=new W;return W.RotationXToRef(b,X),X}static Invert(b){const X=new W;return b.invertToRef(X),X}static RotationXToRef(b,X){const P=Math.sin(b),Q=Math.cos(b);return W.FromValuesToRef(1,0,0,0,0,Q,P,0,0,-P,Q,0,0,0,0,1,X),X._updateIdentityStatus(1===Q&&0===P),X}static RotationY(b){const X=new W;return W.RotationYToRef(b,X),X}static RotationYToRef(b,X){const P=Math.sin(b),Q=Math.cos(b);return W.FromValuesToRef(Q,0,-P,0,0,1,0,0,P,0,Q,0,0,0,0,1,X),X._updateIdentityStatus(1===Q&&0===P),X}static RotationZ(b){const X=new W;return W.RotationZToRef(b,X),X}static RotationZToRef(b,X){const P=Math.sin(b),Q=Math.cos(b);return W.FromValuesToRef(Q,P,0,0,-P,Q,0,0,0,0,1,0,0,0,0,1,X),X._updateIdentityStatus(1===Q&&0===P),X}static RotationAxis(b,X){const P=new W;return W.RotationAxisToRef(b,X,P),P}static RotationAxisToRef(b,X,P){const Q=Math.sin(-X),S=Math.cos(-X),d=1-S;b=b.normalizeToRef(n.tX[0]);const N=P.wd;return N[0]=b._x*b._x*d+S,N[1]=b._x*b._y*d-b._z*Q,N[2]=b._x*b._z*d+b._y*Q,N[3]=0,N[4]=b._y*b._x*d+b._z*Q,N[5]=b._y*b._y*d+S,N[6]=b._y*b._z*d-b._x*Q,N[7]=0,N[8]=b._z*b._x*d-b._y*Q,N[9]=b._z*b._y*d+b._x*Q,N[10]=b._z*b._z*d+S,N[11]=0,N[12]=0,N[13]=0,N[14]=0,N[15]=1,P.markAsUpdated(),P}static RotationAlignToRef(b,X,P){let S=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const d=E.Dot(X,b),N=P.wd;if(d<-1+Q.c)N[0]=-1,N[1]=0,N[2]=0,N[3]=0,N[4]=0,N[5]=S?1:-1,N[6]=0,N[7]=0,N[8]=0,N[9]=0,N[10]=S?-1:1,N[11]=0;else{const P=E.Cross(X,b),Q=1/(1+d);N[0]=P._x*P._x*Q+d,N[1]=P._y*P._x*Q-P._z,N[2]=P._z*P._x*Q+P._y,N[3]=0,N[4]=P._x*P._y*Q+P._z,N[5]=P._y*P._y*Q+d,N[6]=P._z*P._y*Q-P._x,N[7]=0,N[8]=P._x*P._z*Q-P._y,N[9]=P._y*P._z*Q+P._x,N[10]=P._z*P._z*Q+d,N[11]=0}return N[12]=0,N[13]=0,N[14]=0,N[15]=1,P.markAsUpdated(),P}static RotationYawPitchRoll(b,X,P){const Q=new W;return W.RotationYawPitchRollToRef(b,X,P,Q),Q}static RotationYawPitchRollToRef(b,X,P,Q){return B.RotationYawPitchRollToRef(b,X,P,n.Quaternion[0]),n.Quaternion[0].toRotationMatrix(Q),Q}static Scaling(b,X,P){const Q=new W;return W.ScalingToRef(b,X,P,Q),Q}static ScalingToRef(b,X,P,Q){return W.FromValuesToRef(b,0,0,0,0,X,0,0,0,0,P,0,0,0,0,1,Q),Q._updateIdentityStatus(1===b&&1===X&&1===P),Q}static Translation(b,X,P){const Q=new W;return W.TranslationToRef(b,X,P,Q),Q}static TranslationToRef(b,X,P,Q){return W.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,b,X,P,1,Q),Q._updateIdentityStatus(0===b&&0===X&&0===P),Q}static Lerp(b,X,P){const Q=new W;return W.LerpToRef(b,X,P,Q),Q}static LerpToRef(b,X,P,Q){const S=Q.wd,d=b.m,N=X.m;for(let a=0;a<16;a++)S[a]=d[a]*(1-P)+N[a]*P;return Q.markAsUpdated(),Q}static DecomposeLerp(b,X,P){const Q=new W;return W.DecomposeLerpToRef(b,X,P,Q),Q}static DecomposeLerpToRef(b,X,P,Q){const S=n.tX[0],d=n.Quaternion[0],N=n.tX[1];b.decompose(S,d,N);const a=n.tX[2],u=n.Quaternion[1],w=n.tX[3];X.decompose(a,u,w);const f=n.tX[4];E.LerpToRef(S,a,P,f);const O=n.Quaternion[2];B.SlerpToRef(d,u,P,O);const e=n.tX[5];return E.LerpToRef(N,w,P,e),W.ComposeToRef(f,O,e,Q),Q}static LookAtLH(b,X,P){const Q=new W;return W.LookAtLHToRef(b,X,P,Q),Q}static LookAtLHToRef(b,X,P,Q){const S=n.tX[0],d=n.tX[1],N=n.tX[2];X.subtractToRef(b,N),N.normalize(),E.CrossToRef(P,N,S);const a=S.lengthSquared();0===a?S.x=1:S.normalizeFromLength(Math.sqrt(a)),E.CrossToRef(N,S,d),d.normalize();const u=-E.Dot(S,b),w=-E.Dot(d,b),f=-E.Dot(N,b);return W.FromValuesToRef(S._x,d._x,N._x,0,S._y,d._y,N._y,0,S._z,d._z,N._z,0,u,w,f,1,Q),Q}static LookAtRH(b,X,P){const Q=new W;return W.LookAtRHToRef(b,X,P,Q),Q}static LookAtRHToRef(b,X,P,Q){const S=n.tX[0],d=n.tX[1],N=n.tX[2];b.subtractToRef(X,N),N.normalize(),E.CrossToRef(P,N,S);const a=S.lengthSquared();0===a?S.x=1:S.normalizeFromLength(Math.sqrt(a)),E.CrossToRef(N,S,d),d.normalize();const u=-E.Dot(S,b),w=-E.Dot(d,b),f=-E.Dot(N,b);return W.FromValuesToRef(S._x,d._x,N._x,0,S._y,d._y,N._y,0,S._z,d._z,N._z,0,u,w,f,1,Q),Q}static LookDirectionLH(b,X){const P=new W;return W.LookDirectionLHToRef(b,X,P),P}static LookDirectionLHToRef(b,X,P){const Q=n.tX[0];Q.N(b),Q.scaleInPlace(-1);const S=n.tX[1];return E.CrossToRef(X,Q,S),W.FromValuesToRef(S._x,S._y,S._z,0,X._x,X._y,X._z,0,Q._x,Q._y,Q._z,0,0,0,0,1,P),P}static LookDirectionRH(b,X){const P=new W;return W.LookDirectionRHToRef(b,X,P),P}static LookDirectionRHToRef(b,X,P){const Q=n.tX[2];return E.CrossToRef(X,b,Q),W.FromValuesToRef(Q._x,Q._y,Q._z,0,X._x,X._y,X._z,0,b._x,b._y,b._z,0,0,0,0,1,P),P}static OrthoLH(b,X,P,Q,S){const d=new W;return W.OrthoLHToRef(b,X,P,Q,d,S),d}static OrthoLHToRef(b,X,P,Q,S,d){const N=2/b,a=2/X,u=2/(Q-P),w=-(Q+P)/(Q-P);return W.FromValuesToRef(N,0,0,0,0,a,0,0,0,0,u,0,0,0,w,1,S),d&&S.multiplyToRef(h,S),S._updateIdentityStatus(1===N&&1===a&&1===u&&0===w),S}static OrthoOffCenterLH(b,X,P,Q,S,d,N){const a=new W;return W.OrthoOffCenterLHToRef(b,X,P,Q,S,d,a,N),a}static OrthoOffCenterLHToRef(b,X,P,Q,S,d,N,a){const u=2/(X-b),w=2/(Q-P),f=2/(d-S),O=-(d+S)/(d-S),e=(b+X)/(b-X),Y=(Q+P)/(P-Q);return W.FromValuesToRef(u,0,0,0,0,w,0,0,0,0,f,0,e,Y,O,1,N),a&&N.multiplyToRef(h,N),N.markAsUpdated(),N}static ObliqueOffCenterLHToRef(b,X,P,Q,S,d,N,a,u,w,f){const O=-N*Math.cos(a),e=-N*Math.sin(a);return W.TranslationToRef(0,0,-u,n.Matrix[1]),W.FromValuesToRef(1,0,0,0,0,1,0,0,O,e,1,0,0,0,0,1,n.Matrix[0]),n.Matrix[1].multiplyToRef(n.Matrix[0],n.Matrix[0]),W.TranslationToRef(0,0,u,n.Matrix[1]),n.Matrix[0].multiplyToRef(n.Matrix[1],n.Matrix[0]),W.OrthoOffCenterLHToRef(b,X,P,Q,S,d,w,f),n.Matrix[0].multiplyToRef(w,w),w}static OrthoOffCenterRH(b,X,P,Q,S,d,N){const a=new W;return W.OrthoOffCenterRHToRef(b,X,P,Q,S,d,a,N),a}static OrthoOffCenterRHToRef(b,X,P,Q,S,d,N,a){return W.OrthoOffCenterLHToRef(b,X,P,Q,S,d,N,a),N.wd[10]*=-1,N}static ObliqueOffCenterRHToRef(b,X,P,Q,S,d,N,a,u,w,f){const O=N*Math.cos(a),e=N*Math.sin(a);return W.TranslationToRef(0,0,u,n.Matrix[1]),W.FromValuesToRef(1,0,0,0,0,1,0,0,O,e,1,0,0,0,0,1,n.Matrix[0]),n.Matrix[1].multiplyToRef(n.Matrix[0],n.Matrix[0]),W.TranslationToRef(0,0,-u,n.Matrix[1]),n.Matrix[0].multiplyToRef(n.Matrix[1],n.Matrix[0]),W.OrthoOffCenterRHToRef(b,X,P,Q,S,d,w,f),n.Matrix[0].multiplyToRef(w,w),w}static PerspectiveLH(b,X,P,Q,S){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const N=new W,a=2*P/b,u=2*P/X,w=(Q+P)/(Q-P),f=-2*Q*P/(Q-P),O=Math.tan(d);return W.FromValuesToRef(a,0,0,0,0,u,0,O,0,0,w,1,0,0,f,0,N),S&&N.multiplyToRef(h,N),N._updateIdentityStatus(!1),N}static PerspectiveFovLH(b,X,P,Q,S){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,N=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=new W;return W.PerspectiveFovLHToRef(b,X,P,Q,a,!0,S,d,N),a}static PerspectiveFovLHToRef(b,X,P,Q,S){let d=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],N=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const w=P,f=Q,O=1/Math.tan(.5*b),e=d?O/X:O,Y=d?O:O*X,D=u&&0===w?-1:0!==f?(f+w)/(f-w):1,E=u&&0===w?2*f:0!==f?-2*f*w/(f-w):-2*w,t=Math.tan(a);return W.FromValuesToRef(e,0,0,0,0,Y,0,t,0,0,D,1,0,0,E,0,S),N&&S.multiplyToRef(h,S),S._updateIdentityStatus(!1),S}static PerspectiveFovReverseLHToRef(b,X,P,Q,S){let d=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],N=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const u=1/Math.tan(.5*b),w=d?u/X:u,f=d?u:u*X,O=Math.tan(a);return W.FromValuesToRef(w,0,0,0,0,f,0,O,0,0,-P,1,0,0,1,0,S),N&&S.multiplyToRef(h,S),S._updateIdentityStatus(!1),S}static PerspectiveFovRH(b,X,P,Q,S){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,N=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=new W;return W.PerspectiveFovRHToRef(b,X,P,Q,a,!0,S,d,N),a}static PerspectiveFovRHToRef(b,X,P,Q,S){let d=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],N=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const w=P,f=Q,O=1/Math.tan(.5*b),e=d?O/X:O,Y=d?O:O*X,D=u&&0===w?1:0!==f?-(f+w)/(f-w):-1,E=u&&0===w?2*f:0!==f?-2*f*w/(f-w):-2*w,t=Math.tan(a);return W.FromValuesToRef(e,0,0,0,0,Y,0,t,0,0,D,-1,0,0,E,0,S),N&&S.multiplyToRef(h,S),S._updateIdentityStatus(!1),S}static PerspectiveFovReverseRHToRef(b,X,P,Q,S){let d=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],N=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const u=1/Math.tan(.5*b),w=d?u/X:u,f=d?u:u*X,O=Math.tan(a);return W.FromValuesToRef(w,0,0,0,0,f,0,O,0,0,-P,-1,0,0,-1,0,S),N&&S.multiplyToRef(h,S),S._updateIdentityStatus(!1),S}static GetFinalMatrix(b,X,P,Q,S,d){const N=b.width,a=b.height,u=b.x,w=b.y,f=W.FromValues(N/2,0,0,0,0,-a/2,0,0,0,0,d-S,0,u+N/2,a/2+w,S,1),O=new W;return X.multiplyToRef(P,O),O.multiplyToRef(Q,O),O.multiplyToRef(f,O)}static GetAsMatrix2x2(b){const X=b.m,P=[X[0],X[1],X[4],X[5]];return N.e.MatrixUse64Bits?P:new Float32Array(P)}static GetAsMatrix3x3(b){const X=b.m,P=[X[0],X[1],X[2],X[4],X[5],X[6],X[8],X[9],X[10]];return N.e.MatrixUse64Bits?P:new Float32Array(P)}static Transpose(b){const X=new W;return W.TransposeToRef(b,X),X}static TransposeToRef(b,X){const P=b.m,Q=P[0],S=P[4],d=P[8],N=P[12],a=P[1],u=P[5],w=P[9],f=P[13],O=P[2],e=P[6],Y=P[10],D=P[14],E=P[3],t=P[7],B=P[11],W=P[15],n=X.wd;return n[0]=Q,n[1]=S,n[2]=d,n[3]=N,n[4]=a,n[5]=u,n[6]=w,n[7]=f,n[8]=O,n[9]=e,n[10]=Y,n[11]=D,n[12]=E,n[13]=t,n[14]=B,n[15]=W,X.markAsUpdated(),X._updateIdentityStatus(b._isIdentity,b._isIdentityDirty),X}static Reflection(b){const X=new W;return W.ReflectionToRef(b,X),X}static ReflectionToRef(b,X){b.normalize();const P=b.normal.x,Q=b.normal.y,S=b.normal.z,d=-2*P,N=-2*Q,a=-2*S;return W.FromValuesToRef(d*P+1,N*P,a*P,0,d*Q,N*Q+1,a*Q,0,d*S,N*S,a*S+1,0,d*b.d,N*b.d,a*b.d,1,X),X}static FromXYZAxesToRef(b,X,P,Q){return W.FromValuesToRef(b._x,b._y,b._z,0,X._x,X._y,X._z,0,P._x,P._y,P._z,0,0,0,0,1,Q),Q}static FromQuaternionToRef(b,X){const P=b._x*b._x,Q=b._y*b._y,S=b._z*b._z,d=b._x*b._y,N=b._z*b._w,a=b._z*b._x,u=b._y*b._w,w=b._y*b._z,f=b._x*b._w;return X.wd[0]=1-2*(Q+S),X.wd[1]=2*(d+N),X.wd[2]=2*(a-u),X.wd[3]=0,X.wd[4]=2*(d-N),X.wd[5]=1-2*(S+P),X.wd[6]=2*(w+f),X.wd[7]=0,X.wd[8]=2*(a+u),X.wd[9]=2*(w-f),X.wd[10]=1-2*(Q+P),X.wd[11]=0,X.wd[12]=0,X.wd[13]=0,X.wd[14]=0,X.wd[15]=1,X.markAsUpdated(),X}}W._IdentityReadOnly=W.Identity(),Object.defineProperties(W.prototype,{dimension:{value:[4,4]},rank:{value:2}});class n{}n.tX=(0,S.c)(11,E.Zero),n.Matrix=(0,S.c)(2,W.Identity),n.Quaternion=(0,S.c)(3,B.Zero);class y{}y.Vector2=(0,S.c)(3,D.Zero),y.tX=(0,S.c)(13,E.Zero),y.Vector4=(0,S.c)(3,t.Zero),y.Quaternion=(0,S.c)(3,B.Zero),y.Matrix=(0,S.c)(8,W.Identity),(0,d.h)("BABYLON.Vector2",D),(0,d.h)("BABYLON.Vector3",E),(0,d.h)("BABYLON.Vector4",t),(0,d.h)("BABYLON.Matrix",W);const h=W.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11841:(b,X,P)=>{function Q(b,X){const P=[];for(let Q=0;Q<b;++Q)P.push(X());return P}function S(b,X){return Q(b,X)}P.d(X,{b:()=>Q,c:()=>S,d:()=>N});const d=["push","splice","pop","shift","unshift"];function N(b,X){const P=d.map((P=>function(b,X,P){const Q=b[X];if("function"!==typeof Q)return null;const S=function(){const Q=b.length,d=S.previous.apply(b,arguments);return P(X,Q),d};return Q.next=S,S.previous=Q,b[X]=S,()=>{const P=S.previous;if(!P)return;const Q=S.next;Q?(P.next=Q,Q.previous=P):(P.next=void 0,b[X]=P),S.next=void 0,S.previous=void 0}}(b,P,X)));return()=>{for(const b of P)null===b||void 0===b||b()}}}}]);