"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[14],{11140:(P,e,n)=>{n.d(e,{c:()=>k,e:()=>p,h:()=>H,i:()=>S});const H=1/2.2,S=2.2,p=(1+Math.sqrt(5))/2,k=.001},11148:(P,e,n)=>{function H(P){return parseInt(P.toString().replace(/\W/g,""))}function S(P,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(P-e)<=n}function p(P,e,n){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return P<e-H||P>n+H}function k(P,e){return P===e?P:Math.random()*(e-P)+P}function m(P,e,n){return P+(e-P)*n}function t(P,e,n){let H=z(e-P,360);return H>180&&(H-=360),P+H*A(n)}function C(P,e,n){let H=0;return H=P!=e?A((n-P)/(e-P)):0,H}function R(P,e,n,H,S){const p=S*S,k=S*p;return P*(2*k-3*p+1)+n*(-2*k+3*p)+e*(k-2*p+S)+H*(k-p)}function q(P,e,n,H,S){const p=S*S;return 6*(p-S)*P+(3*p-4*S+1)*e+6*(-p+S)*n+(3*p-2*S)*H}function A(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(n,Math.max(e,P))}function F(P){return P-=2*Math.PI*Math.floor((P+Math.PI)/(2*Math.PI))}function Y(P){const e=P.toString(16);return P<=15?("0"+e).toUpperCase():e.toUpperCase()}function j(P){if(Math.log2)return Math.floor(Math.log2(P));if(P<0)return NaN;if(0===P)return-1/0;let e=0;if(P<1){for(;P<1;)e++,P*=2;e=-e}else if(P>1)for(;P>1;)e++,P=Math.floor(P/2);return e}function z(P,e){return P-Math.floor(P/e)*e}function w(P,e,n){return(P-e)/(n-e)}function J(P,e,n){return P*(n-e)+e}function I(P,e){let n=z(e-P,360);return n>180&&(n-=360),n}function O(P,e){const n=z(P,2*e);return e-Math.abs(n-e)}function V(P,e,n){let H=A(n);return H=-2*H*H*H+3*H*H,e*H+P*(1-H)}function i(P,e,n){let H=0;return H=Math.abs(e-P)<=n?e:P+Math.sign(e-P)*n,H}function B(P,e,n){const H=I(P,e);let S=0;return S=-n<H&&H<n?e:i(P,e=P+H,n),S}function l(P,e,n){return(P-e)/(n-e)}function b(P,e,n){return(n-e)*P+e}function T(P,e){const n=P%e;return 0===n?e:T(e,n)}n.r(e),n.d(e,{Clamp:()=>A,DeltaAngle:()=>I,Denormalize:()=>J,ExtractAsInt:()=>H,Hermite:()=>R,Hermite1stDerivative:()=>q,HighestCommonFactor:()=>T,ILog2:()=>j,InverseLerp:()=>C,Lerp:()=>m,LerpAngle:()=>t,MoveTowards:()=>i,MoveTowardsAngle:()=>B,Normalize:()=>w,NormalizeRadians:()=>F,OutsideRange:()=>p,PercentToRange:()=>b,PingPong:()=>O,RandomRange:()=>k,RangeToPercent:()=>l,Repeat:()=>z,SmoothStep:()=>V,ToHex:()=>Y,WithinEpsilon:()=>S})},11133:(P,e,n)=>{n.r(e),n.d(e,{Matrix:()=>J,Quaternion:()=>w,TmpVectors:()=>O,Vector2:()=>Y,Ie:()=>j,Vector4:()=>z});var H=n(11140),S=n(11143),p=n(11096),k=n(11073),m=n(11017),t=n(11148);class C{}function R(P,e,n){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const S=P.fe(),p=e.fe(),k=S[0],m=S[1],t=S[2],C=S[3],R=S[4],q=S[5],A=S[6],F=S[7],Y=S[8],j=S[9],z=S[10],w=S[11],J=S[12],I=S[13],O=S[14],V=S[15],i=p[0],B=p[1],l=p[2],b=p[3],T=p[4],d=p[5],N=p[6],Q=p[7],c=p[8],r=p[9],o=p[10],G=p[11],g=p[12],y=p[13],f=p[14],Z=p[15];n[H]=k*i+m*T+t*c+C*g,n[H+1]=k*B+m*d+t*r+C*y,n[H+2]=k*l+m*N+t*o+C*f,n[H+3]=k*b+m*Q+t*G+C*Z,n[H+4]=R*i+q*T+A*c+F*g,n[H+5]=R*B+q*d+A*r+F*y,n[H+6]=R*l+q*N+A*o+F*f,n[H+7]=R*b+q*Q+A*G+F*Z,n[H+8]=Y*i+j*T+z*c+w*g,n[H+9]=Y*B+j*d+z*r+w*y,n[H+10]=Y*l+j*N+z*o+w*f,n[H+11]=Y*b+j*Q+z*G+w*Z,n[H+12]=J*i+I*T+O*c+V*g,n[H+13]=J*B+I*d+O*r+V*y,n[H+14]=J*l+I*N+O*o+V*f,n[H+15]=J*b+I*Q+O*G+V*Z}function q(P,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const H=P.fe();e[n]=H[0],e[n+1]=H[1],e[n+2]=H[2],e[n+3]=H[3],e[n+4]=H[4],e[n+5]=H[5],e[n+6]=H[6],e[n+7]=H[7],e[n+8]=H[8],e[n+9]=H[9],e[n+10]=H[10],e[n+11]=H[11],e[n+12]=H[12],e[n+13]=H[13],e[n+14]=H[14],e[n+15]=H[15]}function A(P,e){const n=P.fe(),H=n[0],S=n[1],p=n[2],k=n[3],m=n[4],t=n[5],C=n[6],R=n[7],q=n[8],A=n[9],F=n[10],Y=n[11],j=n[12],z=n[13],w=n[14],J=n[15],I=F*J-w*Y,O=A*J-z*Y,V=A*w-z*F,i=q*J-j*Y,B=q*w-F*j,l=q*z-j*A,b=+(t*I-C*O+R*V),T=-(m*I-C*i+R*B),d=+(m*O-t*i+R*l),N=-(m*V-t*B+C*l),Q=H*b+S*T+p*d+k*N;if(0===Q)return!1;const c=1/Q,r=C*J-w*R,o=t*J-z*R,G=t*w-z*C,g=m*J-j*R,y=m*w-j*C,f=m*z-j*t,Z=C*Y-F*R,v=t*Y-A*R,u=t*F-A*C,W=m*Y-q*R,U=m*F-q*C,a=m*A-q*t,L=-(S*I-p*O+k*V),s=+(H*I-p*i+k*B),E=-(H*O-S*i+k*l),X=+(H*V-S*B+p*l),x=+(S*r-p*o+k*G),M=-(H*r-p*g+k*y),K=+(H*o-S*g+k*f),h=-(H*G-S*y+p*f),D=-(S*Z-p*v+k*u),PP=+(H*Z-p*W+k*U),eP=-(H*v-S*W+k*a),nP=+(H*u-S*U+p*a);return e[0]=b*c,e[1]=L*c,e[2]=x*c,e[3]=D*c,e[4]=T*c,e[5]=s*c,e[6]=M*c,e[7]=PP*c,e[8]=d*c,e[9]=E*c,e[10]=K*c,e[11]=eP*c,e[12]=N*c,e[13]=X*c,e[14]=h*c,e[15]=nP*c,!0}C._UpdateFlagSeed=0;const F=P=>parseInt(P.toString().replace(/\W/g,""));class Y{constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=P,this.y=e}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let P=F(this.x);return P=397*P^F(this.y),P}toArray(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[e]=this.x,P[e+1]=this.y,this}yn(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y.FromArrayToRef(P,e,this),this}fe(){return[this.x,this.y]}p(P){return this.x=P.x,this.y=P.y,this}dp(P,e){return this.x=P,this.y=e,this}set(P,e){return this.dp(P,e)}zm(P){return this.dp(P,P)}add(P){return new Y(this.x+P.x,this.y+P.y)}addToRef(P,e){return e.x=this.x+P.x,e.y=this.y+P.y,e}addInPlace(P){return this.x+=P.x,this.y+=P.y,this}addInPlaceFromFloats(P,e){return this.x+=P,this.y+=e,this}addVector3(P){return new Y(this.x+P.x,this.y+P.y)}be(P){return new Y(this.x-P.x,this.y-P.y)}subtractToRef(P,e){return e.x=this.x-P.x,e.y=this.y-P.y,e}MR(P){return this.x-=P.x,this.y-=P.y,this}multiplyInPlace(P){return this.x*=P.x,this.y*=P.y,this}multiply(P){return new Y(this.x*P.x,this.y*P.y)}multiplyToRef(P,e){return e.x=this.x*P.x,e.y=this.y*P.y,e}multiplyByFloats(P,e){return new Y(this.x*P,this.y*e)}divide(P){return new Y(this.x/P.x,this.y/P.y)}divideToRef(P,e){return e.x=this.x/P.x,e.y=this.y/P.y,e}divideInPlace(P){return this.x=this.x/P.x,this.y=this.y/P.y,this}minimizeInPlace(P){return this.minimizeInPlaceFromFloats(P.x,P.y)}maximizeInPlace(P){return this.maximizeInPlaceFromFloats(P.x,P.y)}minimizeInPlaceFromFloats(P,e){return this.x=Math.min(P,this.x),this.y=Math.min(e,this.y),this}maximizeInPlaceFromFloats(P,e){return this.x=Math.max(P,this.x),this.y=Math.max(e,this.y),this}subtractFromFloats(P,e){return new Y(this.x-P,this.y-e)}subtractFromFloatsToRef(P,e,n){return n.x=this.x-P,n.y=this.y-e,n}negate(){return new Y(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(P){return P.x=-this.x,P.y=-this.y,P}scaleInPlace(P){return this.x*=P,this.y*=P,this}scale(P){return new Y(this.x*P,this.y*P)}scaleToRef(P,e){return e.x=this.x*P,e.y=this.y*P,e}scaleAndAddToRef(P,e){return e.x+=this.x*P,e.y+=this.y*P,e}equals(P){return P&&this.x===P.x&&this.y===P.y}equalsWithEpsilon(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.c;return P&&(0,t.WithinEpsilon)(this.x,P.x,e)&&(0,t.WithinEpsilon)(this.y,P.y,e)}equalsToFloats(P,e){return this.x===P&&this.y===e}floor(){return new Y(Math.floor(this.x),Math.floor(this.y))}floorToRef(P){return P.x=Math.floor(this.x),P.y=Math.floor(this.y),P}fract(){return new Y(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(P){return P.x=this.x-Math.floor(this.x),P.y=this.y-Math.floor(this.y),P}rotate(P){return this.rotateToRef(P,new Y)}rotateToRef(P,e){const n=Math.cos(P),H=Math.sin(P);return e.x=n*this.x-H*this.y,e.y=H*this.x+n*this.y,e}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){const P=new Y;return this.normalizeToRef(P),P}normalizeToRef(P){const e=this.length();return 0===e&&(P.x=this.x,P.y=this.y),this.scaleToRef(1/e,P)}clone(){return new Y(this.x,this.y)}dot(P){return this.x*P.x+this.y*P.y}static Zero(){return new Y(0,0)}static One(){return new Y(1,1)}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Y((0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).dp((0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e))}static get ZeroReadOnly(){return Y._ZeroReadOnly}static Qe(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Y(P[e],P[e+1])}static FromArrayToRef(P,e,n){return n.x=P[e],n.y=P[e+1],n}static FromFloatsToRef(P,e,n){return n.dp(P,e),n}static CatmullRom(P,e,n,H,S){const p=S*S,k=S*p,m=.5*(2*e.x+(-P.x+n.x)*S+(2*P.x-5*e.x+4*n.x-H.x)*p+(-P.x+3*e.x-3*n.x+H.x)*k),t=.5*(2*e.y+(-P.y+n.y)*S+(2*P.y-5*e.y+4*n.y-H.y)*p+(-P.y+3*e.y-3*n.y+H.y)*k);return new Y(m,t)}static ClampToRef(P,e,n,H){return H.x=(0,t.Clamp)(P.x,e.x,n.x),H.y=(0,t.Clamp)(P.y,e.y,n.y),H}static Clamp(P,e,n){const H=(0,t.Clamp)(P.x,e.x,n.x),S=(0,t.Clamp)(P.y,e.y,n.y);return new Y(H,S)}static Hermite(P,e,n,H,S){const p=S*S,k=S*p,m=2*k-3*p+1,t=-2*k+3*p,C=k-2*p+S,R=k-p,q=P.x*m+n.x*t+e.x*C+H.x*R,A=P.y*m+n.y*t+e.y*C+H.y*R;return new Y(q,A)}static Hermite1stDerivative(P,e,n,H,S){return this.Hermite1stDerivativeToRef(P,e,n,H,S,new Y)}static Hermite1stDerivativeToRef(P,e,n,H,S,p){const k=S*S;return p.x=6*(k-S)*P.x+(3*k-4*S+1)*e.x+6*(-k+S)*n.x+(3*k-2*S)*H.x,p.y=6*(k-S)*P.y+(3*k-4*S+1)*e.y+6*(-k+S)*n.y+(3*k-2*S)*H.y,p}static Lerp(P,e,n){return Y.LerpToRef(P,e,n,new Y)}static LerpToRef(P,e,n,H){return H.x=P.x+(e.x-P.x)*n,H.y=P.y+(e.y-P.y)*n,H}static Dot(P,e){return P.x*e.x+P.y*e.y}static Normalize(P){return Y.NormalizeToRef(P,new Y)}static NormalizeToRef(P,e){return P.normalizeToRef(e),e}static Minimize(P,e){const n=P.x<e.x?P.x:e.x,H=P.y<e.y?P.y:e.y;return new Y(n,H)}static Maximize(P,e){const n=P.x>e.x?P.x:e.x,H=P.y>e.y?P.y:e.y;return new Y(n,H)}static Transform(P,e){return Y.TransformToRef(P,e,new Y)}static TransformToRef(P,e,n){const H=e.m,S=P.x*H[0]+P.y*H[4]+H[12],p=P.x*H[1]+P.y*H[5]+H[13];return n.x=S,n.y=p,n}static PointInTriangle(P,e,n,H){const S=.5*(-n.y*H.x+e.y*(-n.x+H.x)+e.x*(n.y-H.y)+n.x*H.y),p=S<0?-1:1,k=(e.y*H.x-e.x*H.y+(H.y-e.y)*P.x+(e.x-H.x)*P.y)*p,m=(e.x*n.y-e.y*n.x+(e.y-n.y)*P.x+(n.x-e.x)*P.y)*p;return k>0&&m>0&&k+m<2*S*p}static Distance(P,e){return Math.sqrt(Y.DistanceSquared(P,e))}static DistanceSquared(P,e){const n=P.x-e.x,H=P.y-e.y;return n*n+H*H}static Center(P,e){return Y.CenterToRef(P,e,new Y)}static CenterToRef(P,e,n){return n.dp((P.x+e.x)/2,(P.y+e.y)/2)}static DistanceOfPointFromSegment(P,e,n){const H=Y.DistanceSquared(e,n);if(0===H)return Y.Distance(P,e);const S=n.be(e),p=Math.max(0,Math.min(1,Y.Dot(P.be(e),S)/H)),k=e.add(S.multiplyByFloats(p,p));return Y.Distance(P,k)}}Y._V8PerformanceHack=new Y(.5,.5),Y._ZeroReadOnly=Y.Zero(),Object.defineProperties(Y.prototype,{dimension:{value:[2]},rank:{value:1}});class j{get x(){return this._x}set x(P){this._x=P,this._isDirty=!0}get y(){return this._y}set y(P){this._y=P,this._isDirty=!0}get z(){return this._z}set z(P){this._z=P,this._isDirty=!0}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=P,this._y=e,this._z=n}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Ie"}getHashCode(){let P=F(this._x);return P=397*P^F(this._y),P=397*P^F(this._z),P}fe(){return[this._x,this._y,this._z]}toArray(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[e]=this._x,P[e+1]=this._y,P[e+2]=this._z,this}yn(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return j.FromArrayToRef(P,e,this),this}toQuaternion(){return w.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(P){return this._x+=P._x,this._y+=P._y,this._z+=P._z,this._isDirty=!0,this}addInPlaceFromFloats(P,e,n){return this._x+=P,this._y+=e,this._z+=n,this._isDirty=!0,this}add(P){return new j(this._x+P._x,this._y+P._y,this._z+P._z)}addToRef(P,e){return e._x=this._x+P._x,e._y=this._y+P._y,e._z=this._z+P._z,e._isDirty=!0,e}MR(P){return this._x-=P._x,this._y-=P._y,this._z-=P._z,this._isDirty=!0,this}be(P){return new j(this._x-P._x,this._y-P._y,this._z-P._z)}subtractToRef(P,e){return this.subtractFromFloatsToRef(P._x,P._y,P._z,e)}subtractFromFloats(P,e,n){return new j(this._x-P,this._y-e,this._z-n)}subtractFromFloatsToRef(P,e,n,H){return H._x=this._x-P,H._y=this._y-e,H._z=this._z-n,H._isDirty=!0,H}negate(){return new j(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(P){return P._x=-1*this._x,P._y=-1*this._y,P._z=-1*this._z,P._isDirty=!0,P}scaleInPlace(P){return this._x*=P,this._y*=P,this._z*=P,this._isDirty=!0,this}scale(P){return new j(this._x*P,this._y*P,this._z*P)}scaleToRef(P,e){return e._x=this._x*P,e._y=this._y*P,e._z=this._z*P,e._isDirty=!0,e}getNormalToRef(P){const e=this.length();let n=Math.acos(this._y/e);const H=Math.atan2(this._z,this._x);n>Math.PI/2?n-=Math.PI/2:n+=Math.PI/2;const S=e*Math.sin(n)*Math.cos(H),p=e*Math.cos(n),k=e*Math.sin(n)*Math.sin(H);return P.set(S,p,k),P}applyRotationQuaternionToRef(P,e){const n=this._x,H=this._y,S=this._z,p=P._x,k=P._y,m=P._z,t=P._w,C=2*(k*S-m*H),R=2*(m*n-p*S),q=2*(p*H-k*n);return e._x=n+t*C+k*q-m*R,e._y=H+t*R+m*C-p*q,e._z=S+t*q+p*R-k*C,e._isDirty=!0,e}applyRotationQuaternionInPlace(P){return this.applyRotationQuaternionToRef(P,this)}applyRotationQuaternion(P){return this.applyRotationQuaternionToRef(P,new j)}scaleAndAddToRef(P,e){return e._x+=this._x*P,e._y+=this._y*P,e._z+=this._z*P,e._isDirty=!0,e}projectOnPlane(P,e){return this.projectOnPlaneToRef(P,e,new j)}projectOnPlaneToRef(P,e,n){const H=P.normal,S=P.d,p=I.Ie[0];this.subtractToRef(e,p),p.normalize();const k=j.Dot(p,H);if(Math.abs(k)<1e-10)n.zm(1/0);else{const P=-(j.Dot(e,H)+S)/k,m=p.scaleInPlace(P);e.addToRef(m,n)}return n}equals(P){return P&&this._x===P._x&&this._y===P._y&&this._z===P._z}equalsWithEpsilon(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.c;return P&&(0,t.WithinEpsilon)(this._x,P._x,e)&&(0,t.WithinEpsilon)(this._y,P._y,e)&&(0,t.WithinEpsilon)(this._z,P._z,e)}equalsToFloats(P,e,n){return this._x===P&&this._y===e&&this._z===n}multiplyInPlace(P){return this._x*=P._x,this._y*=P._y,this._z*=P._z,this._isDirty=!0,this}multiply(P){return this.multiplyByFloats(P._x,P._y,P._z)}multiplyToRef(P,e){return e._x=this._x*P._x,e._y=this._y*P._y,e._z=this._z*P._z,e._isDirty=!0,e}multiplyByFloats(P,e,n){return new j(this._x*P,this._y*e,this._z*n)}divide(P){return new j(this._x/P._x,this._y/P._y,this._z/P._z)}divideToRef(P,e){return e._x=this._x/P._x,e._y=this._y/P._y,e._z=this._z/P._z,e._isDirty=!0,e}divideInPlace(P){return this._x=this._x/P._x,this._y=this._y/P._y,this._z=this._z/P._z,this._isDirty=!0,this}minimizeInPlace(P){return this.minimizeInPlaceFromFloats(P._x,P._y,P._z)}maximizeInPlace(P){return this.maximizeInPlaceFromFloats(P._x,P._y,P._z)}minimizeInPlaceFromFloats(P,e,n){return P<this._x&&(this.x=P),e<this._y&&(this.y=e),n<this._z&&(this.z=n),this}maximizeInPlaceFromFloats(P,e,n){return P>this._x&&(this.x=P),e>this._y&&(this.y=e),n>this._z&&(this.z=n),this}isNonUniformWithinEpsilon(P){const e=Math.abs(this._x),n=Math.abs(this._y);if(!(0,t.WithinEpsilon)(e,n,P))return!0;const H=Math.abs(this._z);return!(0,t.WithinEpsilon)(e,H,P)||!(0,t.WithinEpsilon)(n,H,P)}get isNonUniform(){const P=Math.abs(this._x);if(P!==Math.abs(this._y))return!0;return P!==Math.abs(this._z)}floorToRef(P){return P._x=Math.floor(this._x),P._y=Math.floor(this._y),P._z=Math.floor(this._z),P._isDirty=!0,P}floor(){return new j(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(P){return P._x=this._x-Math.floor(this._x),P._y=this._y-Math.floor(this._y),P._z=this._z-Math.floor(this._z),P._isDirty=!0,P}fract(){return new j(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(P){if("xyz"===(P=P.toLowerCase()))return this;const e=I.Ie[0].p(this);return this.x=e[P[0]],this.y=e[P[1]],this.z=e[P[2]],this}rotateByQuaternionToRef(P,e){return P.toRotationMatrix(I.Matrix[0]),j.TransformCoordinatesToRef(this,I.Matrix[0],e),e}rotateByQuaternionAroundPointToRef(P,e,n){return this.subtractToRef(e,I.Ie[0]),I.Ie[0].rotateByQuaternionToRef(P,I.Ie[0]),e.addToRef(I.Ie[0],n),n}cross(P){return j.CrossToRef(this,P,new j)}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){return this.normalizeToRef(new j)}normalizeToRef(P){const e=this.length();return 0===e||1===e?(P._x=this._x,P._y=this._y,P._z=this._z,P._isDirty=!0,P):this.scaleToRef(1/e,P)}clone(){return new j(this._x,this._y,this._z)}p(P){return this.dp(P._x,P._y,P._z)}dp(P,e,n){return this._x=P,this._y=e,this._z=n,this._isDirty=!0,this}set(P,e,n){return this.dp(P,e,n)}zm(P){return this._x=this._y=this._z=P,this._isDirty=!0,this}static GetClipFactor(P,e,n,H){const S=j.Dot(P,n);return(S-H)/(S-j.Dot(e,n))}static GetAngleBetweenVectors(P,e,n){const H=P.normalizeToRef(I.Ie[1]),S=e.normalizeToRef(I.Ie[2]);let p=j.Dot(H,S);p=(0,t.Clamp)(p,-1,1);const k=Math.acos(p),m=I.Ie[3];return j.CrossToRef(H,S,m),j.Dot(m,n)>0?isNaN(k)?0:k:isNaN(k)?-Math.PI:-Math.acos(p)}static GetAngleBetweenVectorsOnPlane(P,e,n){I.Ie[0].p(P);const H=I.Ie[0];I.Ie[1].p(e);const S=I.Ie[1];I.Ie[2].p(n);const p=I.Ie[2],k=I.Ie[3],m=I.Ie[4];H.normalize(),S.normalize(),p.normalize(),j.CrossToRef(p,H,k),j.CrossToRef(k,p,m);const C=Math.atan2(j.Dot(S,k),j.Dot(S,m));return(0,t.NormalizeRadians)(C)}static PitchYawRollToMoveBetweenPointsToRef(P,e,n){const H=O.Ie[0];return e.subtractToRef(P,H),n._y=Math.atan2(H.x,H.z)||0,n._x=Math.atan2(Math.sqrt(H.x**2+H.z**2),H.y)||0,n._z=0,n._isDirty=!0,n}static PitchYawRollToMoveBetweenPoints(P,e){const n=j.Zero();return j.PitchYawRollToMoveBetweenPointsToRef(P,e,n)}static SlerpToRef(P,e,n,S){n=(0,t.Clamp)(n,0,1);const p=I.Ie[0],k=I.Ie[1];p.p(P);const m=p.length();p.normalizeFromLength(m),k.p(e);const C=k.length();k.normalizeFromLength(C);const R=j.Dot(p,k);let q,A;if(R<1-H.c){const P=Math.acos(R),e=1/Math.sin(P);q=Math.sin((1-n)*P)*e,A=Math.sin(n*P)*e}else q=1-n,A=n;return p.scaleInPlace(q),k.scaleInPlace(A),S.p(p).addInPlace(k),S.scaleInPlace((0,t.Lerp)(m,C,n)),S}static SmoothToRef(P,e,n,H,S){return j.SlerpToRef(P,e,0===H?1:n/H,S),S}static Qe(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new j(P[e],P[e+1],P[e+2])}static FromFloatArray(P,e){return j.Qe(P,e)}static FromArrayToRef(P,e,n){return n._x=P[e],n._y=P[e+1],n._z=P[e+2],n._isDirty=!0,n}static FromFloatArrayToRef(P,e,n){return j.FromArrayToRef(P,e,n)}static FromFloatsToRef(P,e,n,H){return H.dp(P,e,n),H}static Zero(){return new j(0,0,0)}static One(){return new j(1,1,1)}static Up(){return new j(0,1,0)}static get UpReadOnly(){return j._UpReadOnly}static get DownReadOnly(){return j._DownReadOnly}static get RightReadOnly(){return j._RightReadOnly}static get LeftReadOnly(){return j._LeftReadOnly}static get LeftHandedForwardReadOnly(){return j._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return j._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return j._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return j._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return j._ZeroReadOnly}static get OneReadOnly(){return j._OneReadOnly}static Down(){return new j(0,-1,0)}static Forward(){return new j(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new j(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new j(1,0,0)}static Left(){return new j(-1,0,0)}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new j((0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).dp((0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e))}static TransformCoordinates(P,e){const n=j.Zero();return j.TransformCoordinatesToRef(P,e,n),n}static TransformCoordinatesToRef(P,e,n){return j.TransformCoordinatesFromFloatsToRef(P._x,P._y,P._z,e,n),n}static TransformCoordinatesFromFloatsToRef(P,e,n,H,S){const p=H.m,k=P*p[0]+e*p[4]+n*p[8]+p[12],m=P*p[1]+e*p[5]+n*p[9]+p[13],t=P*p[2]+e*p[6]+n*p[10]+p[14],C=1/(P*p[3]+e*p[7]+n*p[11]+p[15]);return S._x=k*C,S._y=m*C,S._z=t*C,S._isDirty=!0,S}static TransformNormal(P,e){const n=j.Zero();return j.TransformNormalToRef(P,e,n),n}static TransformNormalToRef(P,e,n){return this.TransformNormalFromFloatsToRef(P._x,P._y,P._z,e,n),n}static TransformNormalFromFloatsToRef(P,e,n,H,S){const p=H.m;return S._x=P*p[0]+e*p[4]+n*p[8],S._y=P*p[1]+e*p[5]+n*p[9],S._z=P*p[2]+e*p[6]+n*p[10],S._isDirty=!0,S}static CatmullRom(P,e,n,H,S){const p=S*S,k=S*p,m=.5*(2*e._x+(-P._x+n._x)*S+(2*P._x-5*e._x+4*n._x-H._x)*p+(-P._x+3*e._x-3*n._x+H._x)*k),t=.5*(2*e._y+(-P._y+n._y)*S+(2*P._y-5*e._y+4*n._y-H._y)*p+(-P._y+3*e._y-3*n._y+H._y)*k),C=.5*(2*e._z+(-P._z+n._z)*S+(2*P._z-5*e._z+4*n._z-H._z)*p+(-P._z+3*e._z-3*n._z+H._z)*k);return new j(m,t,C)}static Clamp(P,e,n){const H=new j;return j.ClampToRef(P,e,n,H),H}static ClampToRef(P,e,n,H){let S=P._x;S=S>n._x?n._x:S,S=S<e._x?e._x:S;let p=P._y;p=p>n._y?n._y:p,p=p<e._y?e._y:p;let k=P._z;return k=k>n._z?n._z:k,k=k<e._z?e._z:k,H.dp(S,p,k),H}static CheckExtends(P,e,n){e.minimizeInPlace(P),n.maximizeInPlace(P)}static Hermite(P,e,n,H,S){const p=S*S,k=S*p,m=2*k-3*p+1,t=-2*k+3*p,C=k-2*p+S,R=k-p,q=P._x*m+n._x*t+e._x*C+H._x*R,A=P._y*m+n._y*t+e._y*C+H._y*R,F=P._z*m+n._z*t+e._z*C+H._z*R;return new j(q,A,F)}static Hermite1stDerivative(P,e,n,H,S){const p=new j;return this.Hermite1stDerivativeToRef(P,e,n,H,S,p),p}static Hermite1stDerivativeToRef(P,e,n,H,S,p){const k=S*S;return p._x=6*(k-S)*P._x+(3*k-4*S+1)*e._x+6*(-k+S)*n._x+(3*k-2*S)*H._x,p._y=6*(k-S)*P._y+(3*k-4*S+1)*e._y+6*(-k+S)*n._y+(3*k-2*S)*H._y,p._z=6*(k-S)*P._z+(3*k-4*S+1)*e._z+6*(-k+S)*n._z+(3*k-2*S)*H._z,p._isDirty=!0,p}static Lerp(P,e,n){const H=new j(0,0,0);return j.LerpToRef(P,e,n,H),H}static LerpToRef(P,e,n,H){return H._x=P._x+(e._x-P._x)*n,H._y=P._y+(e._y-P._y)*n,H._z=P._z+(e._z-P._z)*n,H._isDirty=!0,H}static Dot(P,e){return P._x*e._x+P._y*e._y+P._z*e._z}dot(P){return this._x*P._x+this._y*P._y+this._z*P._z}static Cross(P,e){const n=new j;return j.CrossToRef(P,e,n),n}static CrossToRef(P,e,n){const H=P._y*e._z-P._z*e._y,S=P._z*e._x-P._x*e._z,p=P._x*e._y-P._y*e._x;return n.dp(H,S,p),n}static Normalize(P){const e=j.Zero();return j.NormalizeToRef(P,e),e}static NormalizeToRef(P,e){return P.normalizeToRef(e),e}static Project(P,e,n,H){const S=new j;return j.ProjectToRef(P,e,n,H,S),S}static ProjectToRef(P,e,n,H,S){var p;const k=H.width,t=H.height,C=H.x,R=H.y,q=I.Matrix[1],A=null===(p=m.d.LastCreatedEngine)||void 0===p?void 0:p.isNDCHalfZRange,F=A?1:.5,Y=A?0:.5;J.FromValuesToRef(k/2,0,0,0,0,-t/2,0,0,0,0,F,0,C+k/2,t/2+R,Y,1,q);const z=I.Matrix[0];return e.multiplyToRef(n,z),z.multiplyToRef(q,z),j.TransformCoordinatesToRef(P,z,S),S}static Reflect(P,e){return this.ReflectToRef(P,e,new j)}static ReflectToRef(P,e,n){const H=O.Ie[0];return H.p(e).scaleInPlace(2*j.Dot(P,e)),n.p(P).MR(H)}static _UnprojectFromInvertedMatrixToRef(P,e,n){j.TransformCoordinatesToRef(P,e,n);const H=e.m,S=P._x*H[3]+P._y*H[7]+P._z*H[11]+H[15];return(0,t.WithinEpsilon)(S,1)&&n.scaleInPlace(1/S),n}static UnprojectFromTransform(P,e,n,H,S){return this.Unproject(P,e,n,H,S,J.IdentityReadOnly)}static Unproject(P,e,n,H,S,p){const k=new j;return j.UnprojectToRef(P,e,n,H,S,p,k),k}static UnprojectToRef(P,e,n,H,S,p,k){return j.UnprojectFloatsToRef(P._x,P._y,P._z,e,n,H,S,p,k),k}static UnprojectFloatsToRef(P,e,n,H,S,p,k,t,C){var R;const q=I.Matrix[0];p.multiplyToRef(k,q),q.multiplyToRef(t,q),q.invert();const A=I.Ie[0];return A.x=P/H*2-1,A.y=-(e/S*2-1),null!==(R=m.d.LastCreatedEngine)&&void 0!==R&&R.isNDCHalfZRange?A.z=n:A.z=2*n-1,j._UnprojectFromInvertedMatrixToRef(A,q,C),C}static Minimize(P,e){const n=new j;return n.p(P),n.minimizeInPlace(e),n}static Maximize(P,e){const n=new j;return n.p(P),n.maximizeInPlace(e),n}static Distance(P,e){return Math.sqrt(j.DistanceSquared(P,e))}static DistanceSquared(P,e){const n=P._x-e._x,H=P._y-e._y,S=P._z-e._z;return n*n+H*H+S*S}static ProjectOnTriangleToRef(P,e,n,S,p){const k=I.Ie[0],m=I.Ie[1],C=I.Ie[2],R=I.Ie[3],q=I.Ie[4];n.subtractToRef(e,k),S.subtractToRef(e,m),S.subtractToRef(n,C);const A=k.length(),F=m.length(),Y=C.length();if(A<H.c||F<H.c||Y<H.c)return p.p(e),j.Distance(P,e);P.subtractToRef(e,q),j.CrossToRef(k,m,R);const z=R.length();if(z<H.c)return p.p(e),j.Distance(P,e);R.normalizeFromLength(z);let w=q.length();if(w<H.c)return p.p(e),0;q.normalizeFromLength(w);const J=j.Dot(R,q),O=I.Ie[5],V=I.Ie[6];O.p(R).scaleInPlace(-w*J),V.p(P).addInPlace(O);const i=I.Ie[4],B=I.Ie[5],l=I.Ie[7],b=I.Ie[8];i.p(k).scaleInPlace(1/A),b.p(m).scaleInPlace(1/F),i.addInPlace(b).scaleInPlace(-1),B.p(k).scaleInPlace(-1/A),b.p(C).scaleInPlace(1/Y),B.addInPlace(b).scaleInPlace(-1),l.p(C).scaleInPlace(-1/Y),b.p(m).scaleInPlace(-1/F),l.addInPlace(b).scaleInPlace(-1);const T=I.Ie[9];let d;T.p(V).MR(e),j.CrossToRef(i,T,b),d=j.Dot(b,R);const N=d;T.p(V).MR(n),j.CrossToRef(B,T,b),d=j.Dot(b,R);const Q=d;T.p(V).MR(S),j.CrossToRef(l,T,b),d=j.Dot(b,R);const c=d,r=I.Ie[10];let o,G;N>0&&Q<0?(r.p(k),o=e,G=n):Q>0&&c<0?(r.p(C),o=n,G=S):(r.p(m).scaleInPlace(-1),o=S,G=e);const g=I.Ie[9],y=I.Ie[4];o.subtractToRef(V,b),G.subtractToRef(V,g),j.CrossToRef(b,g,y);if(!(j.Dot(y,R)<0))return p.p(V),Math.abs(w*J);const f=I.Ie[5];j.CrossToRef(r,y,f),f.normalize();const Z=I.Ie[9];Z.p(o).MR(V);const v=Z.length();if(v<H.c)return p.p(o),j.Distance(P,o);Z.normalizeFromLength(v);const u=j.Dot(f,Z),W=I.Ie[7];W.p(V).addInPlace(f.scaleInPlace(v*u)),b.p(W).MR(o),w=r.length(),r.normalizeFromLength(w);let U=j.Dot(b,r)/Math.max(w,H.c);return U=(0,t.Clamp)(U,0,1),W.p(o).addInPlace(r.scaleInPlace(U*w)),p.p(W),j.Distance(P,W)}static Center(P,e){return j.CenterToRef(P,e,j.Zero())}static CenterToRef(P,e,n){return n.dp((P._x+e._x)/2,(P._y+e._y)/2,(P._z+e._z)/2)}static RotationFromAxis(P,e,n){const H=new j;return j.RotationFromAxisToRef(P,e,n,H),H}static RotationFromAxisToRef(P,e,n,H){const S=I.Quaternion[0];return w.RotationQuaternionFromAxisToRef(P,e,n,S),S.toEulerAnglesToRef(H),H}}j._V8PerformanceHack=new j(.5,.5,.5),j._UpReadOnly=j.Up(),j._DownReadOnly=j.Down(),j._LeftHandedForwardReadOnly=j.Forward(!1),j._RightHandedForwardReadOnly=j.Forward(!0),j._LeftHandedBackwardReadOnly=j.Backward(!1),j._RightHandedBackwardReadOnly=j.Backward(!0),j._RightReadOnly=j.Right(),j._LeftReadOnly=j.Left(),j._ZeroReadOnly=j.Zero(),j._OneReadOnly=j.One(),Object.defineProperties(j.prototype,{dimension:{value:[3]},rank:{value:1}});class z{get x(){return this._x}set x(P){this._x=P,this._isDirty=!0}get y(){return this._y}set y(P){this._y=P,this._isDirty=!0}get z(){return this._z}set z(P){this._z=P,this._isDirty=!0}get w(){return this._w}set w(P){this._w=P,this._isDirty=!0}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=P,this._y=e,this._z=n,this._w=H}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let P=F(this._x);return P=397*P^F(this._y),P=397*P^F(this._z),P=397*P^F(this._w),P}fe(){return[this._x,this._y,this._z,this._w]}toArray(P,e){return void 0===e&&(e=0),P[e]=this._x,P[e+1]=this._y,P[e+2]=this._z,P[e+3]=this._w,this}yn(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z.FromArrayToRef(P,e,this),this}addInPlace(P){return this.x+=P._x,this.y+=P._y,this.z+=P._z,this.w+=P._w,this}addInPlaceFromFloats(P,e,n,H){return this.x+=P,this.y+=e,this.z+=n,this.w+=H,this}add(P){return new z(this._x+P.x,this._y+P.y,this._z+P.z,this._w+P.w)}addToRef(P,e){return e.x=this._x+P.x,e.y=this._y+P.y,e.z=this._z+P.z,e.w=this._w+P.w,e}MR(P){return this.x-=P.x,this.y-=P.y,this.z-=P.z,this.w-=P.w,this}be(P){return new z(this._x-P.x,this._y-P.y,this._z-P.z,this._w-P.w)}subtractToRef(P,e){return e.x=this._x-P.x,e.y=this._y-P.y,e.z=this._z-P.z,e.w=this._w-P.w,e}subtractFromFloats(P,e,n,H){return new z(this._x-P,this._y-e,this._z-n,this._w-H)}subtractFromFloatsToRef(P,e,n,H,S){return S.x=this._x-P,S.y=this._y-e,S.z=this._z-n,S.w=this._w-H,S}negate(){return new z(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(P){return P.x=-this._x,P.y=-this._y,P.z=-this._z,P.w=-this._w,P}scaleInPlace(P){return this.x*=P,this.y*=P,this.z*=P,this.w*=P,this}scale(P){return new z(this._x*P,this._y*P,this._z*P,this._w*P)}scaleToRef(P,e){return e.x=this._x*P,e.y=this._y*P,e.z=this._z*P,e.w=this._w*P,e}scaleAndAddToRef(P,e){return e.x+=this._x*P,e.y+=this._y*P,e.z+=this._z*P,e.w+=this._w*P,e}equals(P){return P&&this._x===P.x&&this._y===P.y&&this._z===P.z&&this._w===P.w}equalsWithEpsilon(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.c;return P&&(0,t.WithinEpsilon)(this._x,P.x,e)&&(0,t.WithinEpsilon)(this._y,P.y,e)&&(0,t.WithinEpsilon)(this._z,P.z,e)&&(0,t.WithinEpsilon)(this._w,P.w,e)}equalsToFloats(P,e,n,H){return this._x===P&&this._y===e&&this._z===n&&this._w===H}multiplyInPlace(P){return this.x*=P.x,this.y*=P.y,this.z*=P.z,this.w*=P.w,this}multiply(P){return new z(this._x*P.x,this._y*P.y,this._z*P.z,this._w*P.w)}multiplyToRef(P,e){return e.x=this._x*P.x,e.y=this._y*P.y,e.z=this._z*P.z,e.w=this._w*P.w,e}multiplyByFloats(P,e,n,H){return new z(this._x*P,this._y*e,this._z*n,this._w*H)}divide(P){return new z(this._x/P.x,this._y/P.y,this._z/P.z,this._w/P.w)}divideToRef(P,e){return e.x=this._x/P.x,e.y=this._y/P.y,e.z=this._z/P.z,e.w=this._w/P.w,e}divideInPlace(P){return this.divideToRef(P,this)}minimizeInPlace(P){return P.x<this._x&&(this.x=P.x),P.y<this._y&&(this.y=P.y),P.z<this._z&&(this.z=P.z),P.w<this._w&&(this.w=P.w),this}maximizeInPlace(P){return P.x>this._x&&(this.x=P.x),P.y>this._y&&(this.y=P.y),P.z>this._z&&(this.z=P.z),P.w>this._w&&(this.w=P.w),this}minimizeInPlaceFromFloats(P,e,n,H){return this.x=Math.min(P,this._x),this.y=Math.min(e,this._y),this.z=Math.min(n,this._z),this.w=Math.min(H,this._w),this}maximizeInPlaceFromFloats(P,e,n,H){return this.x=Math.max(P,this._x),this.y=Math.max(e,this._y),this.z=Math.max(n,this._z),this.w=Math.max(H,this._w),this}floorToRef(P){return P.x=Math.floor(this._x),P.y=Math.floor(this._y),P.z=Math.floor(this._z),P.w=Math.floor(this._w),P}floor(){return new z(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(P){return P.x=this._x-Math.floor(this._x),P.y=this._y-Math.floor(this._y),P.z=this._z-Math.floor(this._z),P.w=this._w-Math.floor(this._w),P}fract(){return new z(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){return this.normalizeToRef(new z)}normalizeToRef(P){const e=this.length();return 0===e||1===e?(P.x=this._x,P.y=this._y,P.z=this._z,P.w=this._w,P):this.scaleToRef(1/e,P)}toVector3(){return new j(this._x,this._y,this._z)}clone(){return new z(this._x,this._y,this._z,this._w)}p(P){return this.x=P.x,this.y=P.y,this.z=P.z,this.w=P.w,this}dp(P,e,n,H){return this.x=P,this.y=e,this.z=n,this.w=H,this}set(P,e,n,H){return this.dp(P,e,n,H)}zm(P){return this.x=this.y=this.z=this.w=P,this}dot(P){return this._x*P.x+this._y*P.y+this._z*P.z+this._w*P.w}static Qe(P,e){return e||(e=0),new z(P[e],P[e+1],P[e+2],P[e+3])}static FromArrayToRef(P,e,n){return n.x=P[e],n.y=P[e+1],n.z=P[e+2],n.w=P[e+3],n}static FromFloatArrayToRef(P,e,n){return z.FromArrayToRef(P,e,n),n}static FromFloatsToRef(P,e,n,H,S){return S.x=P,S.y=e,S.z=n,S.w=H,S}static Zero(){return new z(0,0,0,0)}static One(){return new z(1,1,1,1)}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new z((0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0;return n.x=(0,t.RandomRange)(P,e),n.y=(0,t.RandomRange)(P,e),n.z=(0,t.RandomRange)(P,e),n.w=(0,t.RandomRange)(P,e),n}static Clamp(P,e,n){return z.ClampToRef(P,e,n,new z)}static ClampToRef(P,e,n,H){return H.x=(0,t.Clamp)(P.x,e.x,n.x),H.y=(0,t.Clamp)(P.y,e.y,n.y),H.z=(0,t.Clamp)(P.z,e.z,n.z),H.w=(0,t.Clamp)(P.w,e.w,n.w),H}static CheckExtends(P,e,n){e.minimizeInPlace(P),n.maximizeInPlace(P)}static get ZeroReadOnly(){return z._ZeroReadOnly}static Normalize(P){return z.NormalizeToRef(P,new z)}static NormalizeToRef(P,e){return P.normalizeToRef(e),e}static Minimize(P,e){const n=new z;return n.p(P),n.minimizeInPlace(e),n}static Maximize(P,e){const n=new z;return n.p(P),n.maximizeInPlace(e),n}static Distance(P,e){return Math.sqrt(z.DistanceSquared(P,e))}static DistanceSquared(P,e){const n=P.x-e.x,H=P.y-e.y,S=P.z-e.z,p=P.w-e.w;return n*n+H*H+S*S+p*p}static Center(P,e){return z.CenterToRef(P,e,new z)}static CenterToRef(P,e,n){return n.x=(P.x+e.x)/2,n.y=(P.y+e.y)/2,n.z=(P.z+e.z)/2,n.w=(P.w+e.w)/2,n}static TransformCoordinates(P,e){return z.TransformCoordinatesToRef(P,e,new z)}static TransformCoordinatesToRef(P,e,n){return z.TransformCoordinatesFromFloatsToRef(P._x,P._y,P._z,e,n),n}static TransformCoordinatesFromFloatsToRef(P,e,n,H,S){const p=H.m,k=P*p[0]+e*p[4]+n*p[8]+p[12],m=P*p[1]+e*p[5]+n*p[9]+p[13],t=P*p[2]+e*p[6]+n*p[10]+p[14],C=P*p[3]+e*p[7]+n*p[11]+p[15];return S.x=k,S.y=m,S.z=t,S.w=C,S}static TransformNormal(P,e){return z.TransformNormalToRef(P,e,new z)}static TransformNormalToRef(P,e,n){const H=e.m,S=P.x*H[0]+P.y*H[4]+P.z*H[8],p=P.x*H[1]+P.y*H[5]+P.z*H[9],k=P.x*H[2]+P.y*H[6]+P.z*H[10];return n.x=S,n.y=p,n.z=k,n.w=P.w,n}static TransformNormalFromFloatsToRef(P,e,n,H,S,p){const k=S.m;return p.x=P*k[0]+e*k[4]+n*k[8],p.y=P*k[1]+e*k[5]+n*k[9],p.z=P*k[2]+e*k[6]+n*k[10],p.w=H,p}static FromVector3(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new z(P._x,P._y,P._z,e)}static Dot(P,e){return P.x*e.x+P.y*e.y+P.z*e.z+P.w*e.w}}z._V8PerformanceHack=new z(.5,.5,.5,.5),z._ZeroReadOnly=z.Zero(),Object.defineProperties(z.prototype,{dimension:{value:[4]},rank:{value:1}});class w{get x(){return this._x}set x(P){this._x=P,this._isDirty=!0}get y(){return this._y}set y(P){this._y=P,this._isDirty=!0}get z(){return this._z}set z(P){this._z=P,this._isDirty=!0}get w(){return this._w}set w(P){this._w=P,this._isDirty=!0}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=P,this._y=e,this._z=n,this._w=H}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let P=F(this._x);return P=397*P^F(this._y),P=397*P^F(this._z),P=397*P^F(this._w),P}fe(){return[this._x,this._y,this._z,this._w]}toArray(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[e]=this._x,P[e+1]=this._y,P[e+2]=this._z,P[e+3]=this._w,this}yn(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w.FromArrayToRef(P,e,this)}equals(P){return P&&this._x===P._x&&this._y===P._y&&this._z===P._z&&this._w===P._w}equalsWithEpsilon(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.c;return P&&(0,t.WithinEpsilon)(this._x,P._x,e)&&(0,t.WithinEpsilon)(this._y,P._y,e)&&(0,t.WithinEpsilon)(this._z,P._z,e)&&(0,t.WithinEpsilon)(this._w,P._w,e)}isApprox(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.c;return P&&((0,t.WithinEpsilon)(this._x,P._x,e)&&(0,t.WithinEpsilon)(this._y,P._y,e)&&(0,t.WithinEpsilon)(this._z,P._z,e)&&(0,t.WithinEpsilon)(this._w,P._w,e)||(0,t.WithinEpsilon)(this._x,-P._x,e)&&(0,t.WithinEpsilon)(this._y,-P._y,e)&&(0,t.WithinEpsilon)(this._z,-P._z,e)&&(0,t.WithinEpsilon)(this._w,-P._w,e))}clone(){return new w(this._x,this._y,this._z,this._w)}p(P){return this._x=P._x,this._y=P._y,this._z=P._z,this._w=P._w,this._isDirty=!0,this}dp(P,e,n,H){return this._x=P,this._y=e,this._z=n,this._w=H,this._isDirty=!0,this}set(P,e,n,H){return this.dp(P,e,n,H)}zm(P){return this.dp(P,P,P,P)}add(P){return new w(this._x+P._x,this._y+P._y,this._z+P._z,this._w+P._w)}addInPlace(P){return this._x+=P._x,this._y+=P._y,this._z+=P._z,this._w+=P._w,this._isDirty=!0,this}addToRef(P,e){return e._x=this._x+P._x,e._y=this._y+P._y,e._z=this._z+P._z,e._w=this._w+P._w,e._isDirty=!0,e}addInPlaceFromFloats(P,e,n,H){return this._x+=P,this._y+=e,this._z+=n,this._w+=H,this._isDirty=!0,this}subtractToRef(P,e){return e._x=this._x-P._x,e._y=this._y-P._y,e._z=this._z-P._z,e._w=this._w-P._w,e._isDirty=!0,e}subtractFromFloats(P,e,n,H){return this.subtractFromFloatsToRef(P,e,n,H,new w)}subtractFromFloatsToRef(P,e,n,H,S){return S._x=this._x-P,S._y=this._y-e,S._z=this._z-n,S._w=this._w-H,S._isDirty=!0,S}be(P){return new w(this._x-P._x,this._y-P._y,this._z-P._z,this._w-P._w)}MR(P){return this._x-=P._x,this._y-=P._y,this._z-=P._z,this._w-=P._w,this._isDirty=!0,this}scale(P){return new w(this._x*P,this._y*P,this._z*P,this._w*P)}scaleToRef(P,e){return e._x=this._x*P,e._y=this._y*P,e._z=this._z*P,e._w=this._w*P,e._isDirty=!0,e}scaleInPlace(P){return this._x*=P,this._y*=P,this._z*=P,this._w*=P,this._isDirty=!0,this}scaleAndAddToRef(P,e){return e._x+=this._x*P,e._y+=this._y*P,e._z+=this._z*P,e._w+=this._w*P,e._isDirty=!0,e}multiply(P){const e=new w(0,0,0,1);return this.multiplyToRef(P,e),e}multiplyToRef(P,e){const n=this._x*P._w+this._y*P._z-this._z*P._y+this._w*P._x,H=-this._x*P._z+this._y*P._w+this._z*P._x+this._w*P._y,S=this._x*P._y-this._y*P._x+this._z*P._w+this._w*P._z,p=-this._x*P._x-this._y*P._y-this._z*P._z+this._w*P._w;return e.dp(n,H,S,p),e}multiplyInPlace(P){return this.multiplyToRef(P,this)}multiplyByFloats(P,e,n,H){return this._x*=P,this._y*=e,this._z*=n,this._w*=H,this._isDirty=!0,this}divide(P){throw new ReferenceError("Can not divide a quaternion")}divideToRef(P,e){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(P){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new w)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(P){return P._x=-this._x,P._y=-this._y,P._z=-this._z,P._w=-this._w,P._isDirty=!0,P}equalsToFloats(P,e,n,H){return this._x===P&&this._y===e&&this._z===n&&this._w===H}floorToRef(P){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(P){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(P){return P.dp(-this._x,-this._y,-this._z,this._w),P}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new w(-this._x,-this._y,-this._z,this._w)}invert(){const P=this.conjugate(),e=this.lengthSquared();return 0==e||1==e||P.scaleInPlace(1/e),P}invertInPlace(){this.conjugateInPlace();const P=this.lengthSquared();return 0==P||1==P||this.scaleInPlace(1/P),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){const P=new w(0,0,0,1);return this.normalizeToRef(P),P}normalizeToRef(P){const e=this.length();return 0===e||1===e?P.dp(this._x,this._y,this._z,this._w):this.scaleToRef(1/e,P)}toEulerAngles(){const P=j.Zero();return this.toEulerAnglesToRef(P),P}toEulerAnglesToRef(P){const e=this._z,n=this._x,H=this._y,S=this._w,p=H*e-n*S,k=.4999999;if(p<-k)P._y=2*Math.atan2(H,S),P._x=Math.PI/2,P._z=0,P._isDirty=!0;else if(p>k)P._y=2*Math.atan2(H,S),P._x=-Math.PI/2,P._z=0,P._isDirty=!0;else{const k=S*S,m=e*e,t=n*n,C=H*H;P._z=Math.atan2(2*(n*H+e*S),-m-t+C+k),P._x=Math.asin(-2*p),P._y=Math.atan2(2*(e*n+H*S),m-t-C+k),P._isDirty=!0}return P}toAlphaBetaGammaToRef(P){const e=this._z,n=this._x,H=this._y,S=this._w,p=Math.sqrt(n*n+H*H),k=Math.sqrt(e*e+S*S),m=2*Math.atan2(p,k),t=2*Math.atan2(e,S),C=2*Math.atan2(H,n),R=(t+C)/2,q=(t-C)/2;return P.set(q,m,R),P}toRotationMatrix(P){return J.FromQuaternionToRef(this,P),P}fromRotationMatrix(P){return w.FromRotationMatrixToRef(P,this),this}dot(P){return this._x*P._x+this._y*P._y+this._z*P._z+this._w*P._w}toAxisAngle(){const P=j.Zero();return{axis:P,angle:this.toAxisAngleToRef(P)}}toAxisAngleToRef(P){let e=0;const n=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),H=this._w;return n>0?(e=2*Math.atan2(n,H),P.set(this._x/n,this._y/n,this._z/n)):(e=0,P.set(1,0,0)),e}static FromRotationMatrix(P){const e=new w;return w.FromRotationMatrixToRef(P,e),e}static FromRotationMatrixToRef(P,e){const n=P.m,H=n[0],S=n[4],p=n[8],k=n[1],m=n[5],t=n[9],C=n[2],R=n[6],q=n[10],A=H+m+q;let F;return A>0?(F=.5/Math.sqrt(A+1),e._w=.25/F,e._x=(R-t)*F,e._y=(p-C)*F,e._z=(k-S)*F,e._isDirty=!0):H>m&&H>q?(F=2*Math.sqrt(1+H-m-q),e._w=(R-t)/F,e._x=.25*F,e._y=(S+k)/F,e._z=(p+C)/F,e._isDirty=!0):m>q?(F=2*Math.sqrt(1+m-H-q),e._w=(p-C)/F,e._x=(S+k)/F,e._y=.25*F,e._z=(t+R)/F,e._isDirty=!0):(F=2*Math.sqrt(1+q-H-m),e._w=(k-S)/F,e._x=(p+C)/F,e._y=(t+R)/F,e._z=.25*F,e._isDirty=!0),e}static Dot(P,e){return P._x*e._x+P._y*e._y+P._z*e._z+P._w*e._w}static AreClose(P,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const H=w.Dot(P,e);return 1-H*H<=n}static SmoothToRef(P,e,n,H,S){let p=0===H?1:n/H;return p=(0,t.Clamp)(p,0,1),w.SlerpToRef(P,e,p,S),S}static Zero(){return new w(0,0,0,0)}static Inverse(P){return new w(-P._x,-P._y,-P._z,P._w)}static InverseToRef(P,e){return e.set(-P._x,-P._y,-P._z,P._w),e}static Identity(){return new w(0,0,0,1)}static IsIdentity(P){return P&&0===P._x&&0===P._y&&0===P._z&&1===P._w}static RotationAxis(P,e){return w.RotationAxisToRef(P,e,new w)}static RotationAxisToRef(P,e,n){n._w=Math.cos(e/2);const H=Math.sin(e/2)/P.length();return n._x=P._x*H,n._y=P._y*H,n._z=P._z*H,n._isDirty=!0,n}static Qe(P,e){return e||(e=0),new w(P[e],P[e+1],P[e+2],P[e+3])}static FromArrayToRef(P,e,n){return n._x=P[e],n._y=P[e+1],n._z=P[e+2],n._w=P[e+3],n._isDirty=!0,n}static FromFloatsToRef(P,e,n,H,S){return S.dp(P,e,n,H),S}static FromEulerAngles(P,e,n){const H=new w;return w.RotationYawPitchRollToRef(e,P,n,H),H}static FromEulerAnglesToRef(P,e,n,H){return w.RotationYawPitchRollToRef(e,P,n,H),H}static FromEulerVector(P){const e=new w;return w.RotationYawPitchRollToRef(P._y,P._x,P._z,e),e}static FromEulerVectorToRef(P,e){return w.RotationYawPitchRollToRef(P._y,P._x,P._z,e),e}static FromUnitVectorsToRef(P,e,n){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:H.c;const p=j.Dot(P,e)+1;return p<S?Math.abs(P.x)>Math.abs(P.z)?n.set(-P.y,P.x,0,0):n.set(0,-P.z,P.y,0):(j.CrossToRef(P,e,O.Ie[0]),n.set(O.Ie[0].x,O.Ie[0].y,O.Ie[0].z,p)),n.normalize()}static RotationYawPitchRoll(P,e,n){const H=new w;return w.RotationYawPitchRollToRef(P,e,n,H),H}static RotationYawPitchRollToRef(P,e,n,H){const S=.5*n,p=.5*e,k=.5*P,m=Math.sin(S),t=Math.cos(S),C=Math.sin(p),R=Math.cos(p),q=Math.sin(k),A=Math.cos(k);return H._x=A*C*t+q*R*m,H._y=q*R*t-A*C*m,H._z=A*R*m-q*C*t,H._w=A*R*t+q*C*m,H._isDirty=!0,H}static RotationAlphaBetaGamma(P,e,n){const H=new w;return w.RotationAlphaBetaGammaToRef(P,e,n,H),H}static RotationAlphaBetaGammaToRef(P,e,n,H){const S=.5*(n+P),p=.5*(n-P),k=.5*e;return H._x=Math.cos(p)*Math.sin(k),H._y=Math.sin(p)*Math.sin(k),H._z=Math.sin(S)*Math.cos(k),H._w=Math.cos(S)*Math.cos(k),H._isDirty=!0,H}static RotationQuaternionFromAxis(P,e,n){const H=new w(0,0,0,0);return w.RotationQuaternionFromAxisToRef(P,e,n,H),H}static RotationQuaternionFromAxisToRef(P,e,n,H){const S=I.Matrix[0];return P=P.normalizeToRef(I.Ie[0]),e=e.normalizeToRef(I.Ie[1]),n=n.normalizeToRef(I.Ie[2]),J.FromXYZAxesToRef(P,e,n,S),w.FromRotationMatrixToRef(S,H),H}static FromLookDirectionLH(P,e){const n=new w;return w.FromLookDirectionLHToRef(P,e,n),n}static FromLookDirectionLHToRef(P,e,n){const H=I.Matrix[0];return J.LookDirectionLHToRef(P,e,H),w.FromRotationMatrixToRef(H,n),n}static FromLookDirectionRH(P,e){const n=new w;return w.FromLookDirectionRHToRef(P,e,n),n}static FromLookDirectionRHToRef(P,e,n){const H=I.Matrix[0];return J.LookDirectionRHToRef(P,e,H),w.FromRotationMatrixToRef(H,n)}static Slerp(P,e,n){const H=w.Identity();return w.SlerpToRef(P,e,n,H),H}static SlerpToRef(P,e,n,H){let S,p,k=P._x*e._x+P._y*e._y+P._z*e._z+P._w*e._w,m=!1;if(k<0&&(m=!0,k=-k),k>.999999)p=1-n,S=m?-n:n;else{const P=Math.acos(k),e=1/Math.sin(P);p=Math.sin((1-n)*P)*e,S=m?-Math.sin(n*P)*e:Math.sin(n*P)*e}return H._x=p*P._x+S*e._x,H._y=p*P._y+S*e._y,H._z=p*P._z+S*e._z,H._w=p*P._w+S*e._w,H._isDirty=!0,H}static Hermite(P,e,n,H,S){const p=S*S,k=S*p,m=2*k-3*p+1,t=-2*k+3*p,C=k-2*p+S,R=k-p,q=P._x*m+n._x*t+e._x*C+H._x*R,A=P._y*m+n._y*t+e._y*C+H._y*R,F=P._z*m+n._z*t+e._z*C+H._z*R,Y=P._w*m+n._w*t+e._w*C+H._w*R;return new w(q,A,F,Y)}static Hermite1stDerivative(P,e,n,H,S){const p=new w;return this.Hermite1stDerivativeToRef(P,e,n,H,S,p),p}static Hermite1stDerivativeToRef(P,e,n,H,S,p){const k=S*S;return p._x=6*(k-S)*P._x+(3*k-4*S+1)*e._x+6*(-k+S)*n._x+(3*k-2*S)*H._x,p._y=6*(k-S)*P._y+(3*k-4*S+1)*e._y+6*(-k+S)*n._y+(3*k-2*S)*H._y,p._z=6*(k-S)*P._z+(3*k-4*S+1)*e._z+6*(-k+S)*n._z+(3*k-2*S)*H._z,p._w=6*(k-S)*P._w+(3*k-4*S+1)*e._w+6*(-k+S)*n._w+(3*k-2*S)*H._w,p._isDirty=!0,p}static Normalize(P){const e=w.Zero();return w.NormalizeToRef(P,e),e}static NormalizeToRef(P,e){return P.normalizeToRef(e),e}static Clamp(P,e,n){const H=new w;return w.ClampToRef(P,e,n,H),H}static ClampToRef(P,e,n,H){return H.dp((0,t.Clamp)(P.x,e.x,n.x),(0,t.Clamp)(P.y,e.y,n.y),(0,t.Clamp)(P.z,e.z,n.z),(0,t.Clamp)(P.w,e.w,n.w))}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new w((0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).dp((0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e),(0,t.RandomRange)(P,e))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(P,e){return Math.sqrt(w.DistanceSquared(P,e))}static DistanceSquared(P,e){const n=P.x-e.x,H=P.y-e.y,S=P.z-e.z,p=P.w-e.w;return n*n+H*H+S*S+p*p}static Center(P,e){return w.CenterToRef(P,e,w.Zero())}static CenterToRef(P,e,n){return n.dp((P.x+e.x)/2,(P.y+e.y)/2,(P.z+e.z)/2,(P.w+e.w)/2)}}w._V8PerformanceHack=new w(.5,.5,.5,.5),Object.defineProperties(w.prototype,{dimension:{value:[4]},rank:{value:1}});class J{static get Use64Bits(){return k.e.MatrixUse64Bits}get m(){return this.Be}markAsUpdated(){this.updateFlag=C._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(P){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=P,this._isIdentity3x2=P||n,this._isIdentityDirty=!this._isIdentity&&e,this._isIdentity3x2Dirty=!this._isIdentity3x2&&H}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,k.e.MatrixTrackPrecisionChange&&k.e.MatrixTrackedMatrices.push(this),this.Be=new k.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const P=this.Be;this._isIdentity=1===P[0]&&0===P[1]&&0===P[2]&&0===P[3]&&0===P[4]&&1===P[5]&&0===P[6]&&0===P[7]&&0===P[8]&&0===P[9]&&1===P[10]&&0===P[11]&&0===P[12]&&0===P[13]&&0===P[14]&&1===P[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Be[0]||1!==this.Be[5]||1!==this.Be[15]||0!==this.Be[1]||0!==this.Be[2]||0!==this.Be[3]||0!==this.Be[4]||0!==this.Be[6]||0!==this.Be[7]||0!==this.Be[8]||0!==this.Be[9]||0!==this.Be[10]||0!==this.Be[11]||0!==this.Be[12]||0!==this.Be[13]||0!==this.Be[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const P=this.Be,e=P[0],n=P[1],H=P[2],S=P[3],p=P[4],k=P[5],m=P[6],t=P[7],C=P[8],R=P[9],q=P[10],A=P[11],F=P[12],Y=P[13],j=P[14],z=P[15],w=q*z-j*A,J=R*z-Y*A,I=R*j-Y*q,O=C*z-F*A,V=C*j-q*F,i=C*Y-F*R;return e*+(k*w-m*J+t*I)+n*-(p*w-m*O+t*V)+H*+(p*J-k*O+t*i)+S*-(p*I-k*V+m*i)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!P)return this.Be;const n=this.Be;for(let H=0;H<16;H++)P[e+H]=n[H];return this}fe(){return this.Be}yn(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(P,e,this)}dp(){for(var P=arguments.length,e=new Array(P),n=0;n<P;n++)e[n]=arguments[n];return J.FromArrayToRef(e,0,this)}set(){const P=this.Be;for(let e=0;e<16;e++)P[e]=e<0||arguments.length<=e?void 0:arguments[e];return this.markAsUpdated(),this}zm(P){const e=this.Be;for(let n=0;n<16;n++)e[n]=P;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return J.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(P){const e=new J;return this.addToRef(P,e),e}addToRef(P,e){const n=this.Be,H=e.Be,S=P.m;for(let p=0;p<16;p++)H[p]=n[p]+S[p];return e.markAsUpdated(),e}addToSelf(P){const e=this.Be,n=P.m;return e[0]+=n[0],e[1]+=n[1],e[2]+=n[2],e[3]+=n[3],e[4]+=n[4],e[5]+=n[5],e[6]+=n[6],e[7]+=n[7],e[8]+=n[8],e[9]+=n[9],e[10]+=n[10],e[11]+=n[11],e[12]+=n[12],e[13]+=n[13],e[14]+=n[14],e[15]+=n[15],this.markAsUpdated(),this}addInPlace(P){const e=this.Be,n=P.m;for(let H=0;H<16;H++)e[H]+=n[H];return this.markAsUpdated(),this}addInPlaceFromFloats(){const P=this.Be;for(let e=0;e<16;e++)P[e]+=e<0||arguments.length<=e?void 0:arguments[e];return this.markAsUpdated(),this}be(P){const e=this.Be,n=P.m;for(let H=0;H<16;H++)e[H]-=n[H];return this.markAsUpdated(),this}subtractToRef(P,e){const n=this.Be,H=P.m,S=e.Be;for(let p=0;p<16;p++)S[p]=n[p]-H[p];return e.markAsUpdated(),e}MR(P){const e=this.Be,n=P.m;for(let H=0;H<16;H++)e[H]-=n[H];return this.markAsUpdated(),this}subtractFromFloats(){for(var P=arguments.length,e=new Array(P),n=0;n<P;n++)e[n]=arguments[n];return this.subtractFromFloatsToRef(...e,new J)}subtractFromFloatsToRef(){for(var P=arguments.length,e=new Array(P),n=0;n<P;n++)e[n]=arguments[n];const H=e.pop(),S=this.Be,p=H.Be,k=e;for(let m=0;m<16;m++)p[m]=S[m]-k[m];return H.markAsUpdated(),H}invertToRef(P){return!0===this._isIdentity?(J.IdentityToRef(P),P):(A(this,P.fe())?P.markAsUpdated():P.p(this),P)}addAtIndex(P,e){return this.Be[P]+=e,this.markAsUpdated(),this}multiplyAtIndex(P,e){return this.Be[P]*=e,this.markAsUpdated(),this}setTranslationFromFloats(P,e,n){return this.Be[12]=P,this.Be[13]=e,this.Be[14]=n,this.markAsUpdated(),this}addTranslationFromFloats(P,e,n){return this.Be[12]+=P,this.Be[13]+=e,this.Be[14]+=n,this.markAsUpdated(),this}setTranslation(P){return this.setTranslationFromFloats(P._x,P._y,P._z)}getTranslation(){return new j(this.Be[12],this.Be[13],this.Be[14])}getTranslationToRef(P){return P.x=this.Be[12],P.y=this.Be[13],P.z=this.Be[14],P}removeRotationAndScaling(){const P=this.m;return J.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,P[12],P[13],P[14],P[15],this),this._updateIdentityStatus(0===P[12]&&0===P[13]&&0===P[14]&&1===P[15]),this}p(P){P.copyToArray(this.Be);const e=P;return this.updateFlag=e.updateFlag,this._updateIdentityStatus(e._isIdentity,e._isIdentityDirty,e._isIdentity3x2,e._isIdentity3x2Dirty),this}copyToArray(P){return q(this,P,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(P){const e=new J;return this.multiplyToRef(P,e),e}multiplyInPlace(P){const e=this.Be,n=P.m;for(let H=0;H<16;H++)e[H]*=n[H];return this.markAsUpdated(),this}multiplyByFloats(){const P=this.Be;for(let e=0;e<16;e++)P[e]*=e<0||arguments.length<=e?void 0:arguments[e];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var P=arguments.length,e=new Array(P),n=0;n<P;n++)e[n]=arguments[n];const H=e.pop(),S=this.Be,p=H.Be,k=e;for(let m=0;m<16;m++)p[m]=S[m]*k[m];return H.markAsUpdated(),H}multiplyToRef(P,e){return this._isIdentity?(e.p(P),e):P._isIdentity?(e.p(this),e):(this.multiplyToArray(P,e.Be,0),e.markAsUpdated(),e)}multiplyToArray(P,e,n){return R(this,P,e,n),this}divide(P){return this.divideToRef(P,new J)}divideToRef(P,e){const n=this.Be,H=P.m,S=e.Be;for(let p=0;p<16;p++)S[p]=n[p]/H[p];return e.markAsUpdated(),e}divideInPlace(P){const e=this.Be,n=P.m;for(let H=0;H<16;H++)e[H]/=n[H];return this.markAsUpdated(),this}minimizeInPlace(P){const e=this.Be,n=P.m;for(let H=0;H<16;H++)e[H]=Math.min(e[H],n[H]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const P=this.Be;for(let e=0;e<16;e++)P[e]=Math.min(P[e],e<0||arguments.length<=e?void 0:arguments[e]);return this.markAsUpdated(),this}maximizeInPlace(P){const e=this.Be,n=P.m;for(let H=0;H<16;H++)e[H]=Math.min(e[H],n[H]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const P=this.Be;for(let e=0;e<16;e++)P[e]=Math.min(P[e],e<0||arguments.length<=e?void 0:arguments[e]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new J)}negateInPlace(){const P=this.Be;for(let e=0;e<16;e++)P[e]=-P[e];return this.markAsUpdated(),this}negateToRef(P){const e=this.Be,n=P.Be;for(let H=0;H<16;H++)n[H]=-e[H];return P.markAsUpdated(),P}equals(P){const e=P;if(!e)return!1;if((this._isIdentity||e._isIdentity)&&!this._isIdentityDirty&&!e._isIdentityDirty)return this._isIdentity&&e._isIdentity;const n=this.m,H=e.m;return n[0]===H[0]&&n[1]===H[1]&&n[2]===H[2]&&n[3]===H[3]&&n[4]===H[4]&&n[5]===H[5]&&n[6]===H[6]&&n[7]===H[7]&&n[8]===H[8]&&n[9]===H[9]&&n[10]===H[10]&&n[11]===H[11]&&n[12]===H[12]&&n[13]===H[13]&&n[14]===H[14]&&n[15]===H[15]}equalsWithEpsilon(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this.Be,H=P.m;for(let S=0;S<16;S++)if(!(0,t.WithinEpsilon)(n[S],H[S],e))return!1;return!0}equalsToFloats(){const P=this.Be;for(let e=0;e<16;e++)if(P[e]!=(e<0||arguments.length<=e?void 0:arguments[e]))return!1;return!0}floor(){return this.floorToRef(new J)}floorToRef(P){const e=this.Be,n=P.Be;for(let H=0;H<16;H++)n[H]=Math.floor(e[H]);return P.markAsUpdated(),P}fract(){return this.fractToRef(new J)}fractToRef(P){const e=this.Be,n=P.Be;for(let H=0;H<16;H++)n[H]=e[H]-Math.floor(e[H]);return P.markAsUpdated(),P}clone(){const P=new J;return P.p(this),P}getClassName(){return"Matrix"}getHashCode(){let P=F(this.Be[0]);for(let e=1;e<16;e++)P=397*P^F(this.Be[e]);return P}decomposeToTransformNode(P){return P.rotationQuaternion=P.rotationQuaternion||new w,this.decompose(P.Up,P.rotationQuaternion,P.position)}decompose(P,e,n,H){let S=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return n&&n.zm(0),P&&P.zm(1),e&&e.dp(0,0,0,1),!0;const p=this.Be;if(n&&n.dp(p[12],p[13],p[14]),(P=P||I.Ie[0]).x=Math.sqrt(p[0]*p[0]+p[1]*p[1]+p[2]*p[2]),P.y=Math.sqrt(p[4]*p[4]+p[5]*p[5]+p[6]*p[6]),P.z=Math.sqrt(p[8]*p[8]+p[9]*p[9]+p[10]*p[10]),H){const e=(S?H.absoluteScaling.x:H.Up.x)<0?-1:1,n=(S?H.absoluteScaling.y:H.Up.y)<0?-1:1,p=(S?H.absoluteScaling.z:H.Up.z)<0?-1:1;P.x*=e,P.y*=n,P.z*=p}else this.determinant()<=0&&(P.y*=-1);if(0===P._x||0===P._y||0===P._z)return e&&e.dp(0,0,0,1),!1;if(e){const n=1/P._x,H=1/P._y,S=1/P._z;J.FromValuesToRef(p[0]*n,p[1]*n,p[2]*n,0,p[4]*H,p[5]*H,p[6]*H,0,p[8]*S,p[9]*S,p[10]*S,0,0,0,0,1,I.Matrix[0]),w.FromRotationMatrixToRef(I.Matrix[0],e)}return!0}getRow(P){if(P<0||P>3)return null;const e=4*P;return new z(this.Be[e+0],this.Be[e+1],this.Be[e+2],this.Be[e+3])}getRowToRef(P,e){if(P>=0&&P<=3){const n=4*P;e.x=this.Be[n+0],e.y=this.Be[n+1],e.z=this.Be[n+2],e.w=this.Be[n+3]}return e}setRow(P,e){return this.setRowFromFloats(P,e.x,e.y,e.z,e.w)}transpose(){const P=new J;return J.TransposeToRef(this,P),P}transposeToRef(P){return J.TransposeToRef(this,P),P}setRowFromFloats(P,e,n,H,S){if(P<0||P>3)return this;const p=4*P;return this.Be[p+0]=e,this.Be[p+1]=n,this.Be[p+2]=H,this.Be[p+3]=S,this.markAsUpdated(),this}scale(P){const e=new J;return this.scaleToRef(P,e),e}scaleToRef(P,e){for(let n=0;n<16;n++)e.Be[n]=this.Be[n]*P;return e.markAsUpdated(),e}scaleAndAddToRef(P,e){for(let n=0;n<16;n++)e.Be[n]+=this.Be[n]*P;return e.markAsUpdated(),e}scaleInPlace(P){const e=this.Be;for(let n=0;n<16;n++)e[n]*=P;return this.markAsUpdated(),this}toNormalMatrix(P){const e=I.Matrix[0];this.invertToRef(e),e.transposeToRef(P);const n=P.Be;return J.FromValuesToRef(n[0],n[1],n[2],0,n[4],n[5],n[6],0,n[8],n[9],n[10],0,0,0,0,1,P),P}getRotationMatrix(){const P=new J;return this.getRotationMatrixToRef(P),P}getRotationMatrixToRef(P){const e=I.Ie[0];if(!this.decompose(e))return J.IdentityToRef(P),P;const n=this.Be,H=1/e._x,S=1/e._y,p=1/e._z;return J.FromValuesToRef(n[0]*H,n[1]*H,n[2]*H,0,n[4]*S,n[5]*S,n[6]*S,0,n[8]*p,n[9]*p,n[10]*p,0,0,0,0,1,P),P}toggleModelMatrixHandInPlace(){const P=this.Be;return P[2]*=-1,P[6]*=-1,P[8]*=-1,P[9]*=-1,P[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const P=this.Be;return P[8]*=-1,P[9]*=-1,P[10]*=-1,P[11]*=-1,this.markAsUpdated(),this}static Qe(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=new J;return J.FromArrayToRef(P,e,n),n}static FromArrayToRef(P,e,n){for(let H=0;H<16;H++)n.Be[H]=P[H+e];return n.markAsUpdated(),n}static FromFloat32ArrayToRefScaled(P,e,n,H){return H.Be[0]=P[0+e]*n,H.Be[1]=P[1+e]*n,H.Be[2]=P[2+e]*n,H.Be[3]=P[3+e]*n,H.Be[4]=P[4+e]*n,H.Be[5]=P[5+e]*n,H.Be[6]=P[6+e]*n,H.Be[7]=P[7+e]*n,H.Be[8]=P[8+e]*n,H.Be[9]=P[9+e]*n,H.Be[10]=P[10+e]*n,H.Be[11]=P[11+e]*n,H.Be[12]=P[12+e]*n,H.Be[13]=P[13+e]*n,H.Be[14]=P[14+e]*n,H.Be[15]=P[15+e]*n,H.markAsUpdated(),H}static get IdentityReadOnly(){return J._IdentityReadOnly}static FromValuesToRef(P,e,n,H,S,p,k,m,t,C,R,q,A,F,Y,j,z){const w=z.Be;w[0]=P,w[1]=e,w[2]=n,w[3]=H,w[4]=S,w[5]=p,w[6]=k,w[7]=m,w[8]=t,w[9]=C,w[10]=R,w[11]=q,w[12]=A,w[13]=F,w[14]=Y,w[15]=j,z.markAsUpdated()}static FromValues(P,e,n,H,S,p,k,m,t,C,R,q,A,F,Y,j){const z=new J,w=z.Be;return w[0]=P,w[1]=e,w[2]=n,w[3]=H,w[4]=S,w[5]=p,w[6]=k,w[7]=m,w[8]=t,w[9]=C,w[10]=R,w[11]=q,w[12]=A,w[13]=F,w[14]=Y,w[15]=j,z.markAsUpdated(),z}static Compose(P,e,n){const H=new J;return J.ComposeToRef(P,e,n,H),H}static ComposeToRef(P,e,n,H){const S=H.Be,p=e._x,k=e._y,m=e._z,t=e._w,C=p+p,R=k+k,q=m+m,A=p*C,F=p*R,Y=p*q,j=k*R,z=k*q,w=m*q,J=t*C,I=t*R,O=t*q,V=P._x,i=P._y,B=P._z;return S[0]=(1-(j+w))*V,S[1]=(F+O)*V,S[2]=(Y-I)*V,S[3]=0,S[4]=(F-O)*i,S[5]=(1-(A+w))*i,S[6]=(z+J)*i,S[7]=0,S[8]=(Y+I)*B,S[9]=(z-J)*B,S[10]=(1-(A+j))*B,S[11]=0,S[12]=n._x,S[13]=n._y,S[14]=n._z,S[15]=1,H.markAsUpdated(),H}static Identity(){const P=J.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return P._updateIdentityStatus(!0),P}static IdentityToRef(P){return J.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,P),P._updateIdentityStatus(!0),P}static Zero(){const P=J.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return P._updateIdentityStatus(!1),P}static RotationX(P){const e=new J;return J.RotationXToRef(P,e),e}static Invert(P){const e=new J;return P.invertToRef(e),e}static RotationXToRef(P,e){const n=Math.sin(P),H=Math.cos(P);return J.FromValuesToRef(1,0,0,0,0,H,n,0,0,-n,H,0,0,0,0,1,e),e._updateIdentityStatus(1===H&&0===n),e}static RotationY(P){const e=new J;return J.RotationYToRef(P,e),e}static RotationYToRef(P,e){const n=Math.sin(P),H=Math.cos(P);return J.FromValuesToRef(H,0,-n,0,0,1,0,0,n,0,H,0,0,0,0,1,e),e._updateIdentityStatus(1===H&&0===n),e}static RotationZ(P){const e=new J;return J.RotationZToRef(P,e),e}static RotationZToRef(P,e){const n=Math.sin(P),H=Math.cos(P);return J.FromValuesToRef(H,n,0,0,-n,H,0,0,0,0,1,0,0,0,0,1,e),e._updateIdentityStatus(1===H&&0===n),e}static RotationAxis(P,e){const n=new J;return J.RotationAxisToRef(P,e,n),n}static RotationAxisToRef(P,e,n){const H=Math.sin(-e),S=Math.cos(-e),p=1-S;P=P.normalizeToRef(I.Ie[0]);const k=n.Be;return k[0]=P._x*P._x*p+S,k[1]=P._x*P._y*p-P._z*H,k[2]=P._x*P._z*p+P._y*H,k[3]=0,k[4]=P._y*P._x*p+P._z*H,k[5]=P._y*P._y*p+S,k[6]=P._y*P._z*p-P._x*H,k[7]=0,k[8]=P._z*P._x*p-P._y*H,k[9]=P._z*P._y*p+P._x*H,k[10]=P._z*P._z*p+S,k[11]=0,k[12]=0,k[13]=0,k[14]=0,k[15]=1,n.markAsUpdated(),n}static RotationAlignToRef(P,e,n){let S=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const p=j.Dot(e,P),k=n.Be;if(p<-1+H.c)k[0]=-1,k[1]=0,k[2]=0,k[3]=0,k[4]=0,k[5]=S?1:-1,k[6]=0,k[7]=0,k[8]=0,k[9]=0,k[10]=S?-1:1,k[11]=0;else{const n=j.Cross(e,P),H=1/(1+p);k[0]=n._x*n._x*H+p,k[1]=n._y*n._x*H-n._z,k[2]=n._z*n._x*H+n._y,k[3]=0,k[4]=n._x*n._y*H+n._z,k[5]=n._y*n._y*H+p,k[6]=n._z*n._y*H-n._x,k[7]=0,k[8]=n._x*n._z*H-n._y,k[9]=n._y*n._z*H+n._x,k[10]=n._z*n._z*H+p,k[11]=0}return k[12]=0,k[13]=0,k[14]=0,k[15]=1,n.markAsUpdated(),n}static RotationYawPitchRoll(P,e,n){const H=new J;return J.RotationYawPitchRollToRef(P,e,n,H),H}static RotationYawPitchRollToRef(P,e,n,H){return w.RotationYawPitchRollToRef(P,e,n,I.Quaternion[0]),I.Quaternion[0].toRotationMatrix(H),H}static Scaling(P,e,n){const H=new J;return J.ScalingToRef(P,e,n,H),H}static ScalingToRef(P,e,n,H){return J.FromValuesToRef(P,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1,H),H._updateIdentityStatus(1===P&&1===e&&1===n),H}static Translation(P,e,n){const H=new J;return J.TranslationToRef(P,e,n,H),H}static TranslationToRef(P,e,n,H){return J.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,P,e,n,1,H),H._updateIdentityStatus(0===P&&0===e&&0===n),H}static Lerp(P,e,n){const H=new J;return J.LerpToRef(P,e,n,H),H}static LerpToRef(P,e,n,H){const S=H.Be,p=P.m,k=e.m;for(let m=0;m<16;m++)S[m]=p[m]*(1-n)+k[m]*n;return H.markAsUpdated(),H}static DecomposeLerp(P,e,n){const H=new J;return J.DecomposeLerpToRef(P,e,n,H),H}static DecomposeLerpToRef(P,e,n,H){const S=I.Ie[0],p=I.Quaternion[0],k=I.Ie[1];P.decompose(S,p,k);const m=I.Ie[2],t=I.Quaternion[1],C=I.Ie[3];e.decompose(m,t,C);const R=I.Ie[4];j.LerpToRef(S,m,n,R);const q=I.Quaternion[2];w.SlerpToRef(p,t,n,q);const A=I.Ie[5];return j.LerpToRef(k,C,n,A),J.ComposeToRef(R,q,A,H),H}static LookAtLH(P,e,n){const H=new J;return J.LookAtLHToRef(P,e,n,H),H}static LookAtLHToRef(P,e,n,H){const S=I.Ie[0],p=I.Ie[1],k=I.Ie[2];e.subtractToRef(P,k),k.normalize(),j.CrossToRef(n,k,S);const m=S.lengthSquared();0===m?S.x=1:S.normalizeFromLength(Math.sqrt(m)),j.CrossToRef(k,S,p),p.normalize();const t=-j.Dot(S,P),C=-j.Dot(p,P),R=-j.Dot(k,P);return J.FromValuesToRef(S._x,p._x,k._x,0,S._y,p._y,k._y,0,S._z,p._z,k._z,0,t,C,R,1,H),H}static LookAtRH(P,e,n){const H=new J;return J.LookAtRHToRef(P,e,n,H),H}static LookAtRHToRef(P,e,n,H){const S=I.Ie[0],p=I.Ie[1],k=I.Ie[2];P.subtractToRef(e,k),k.normalize(),j.CrossToRef(n,k,S);const m=S.lengthSquared();0===m?S.x=1:S.normalizeFromLength(Math.sqrt(m)),j.CrossToRef(k,S,p),p.normalize();const t=-j.Dot(S,P),C=-j.Dot(p,P),R=-j.Dot(k,P);return J.FromValuesToRef(S._x,p._x,k._x,0,S._y,p._y,k._y,0,S._z,p._z,k._z,0,t,C,R,1,H),H}static LookDirectionLH(P,e){const n=new J;return J.LookDirectionLHToRef(P,e,n),n}static LookDirectionLHToRef(P,e,n){const H=I.Ie[0];H.p(P),H.scaleInPlace(-1);const S=I.Ie[1];return j.CrossToRef(e,H,S),J.FromValuesToRef(S._x,S._y,S._z,0,e._x,e._y,e._z,0,H._x,H._y,H._z,0,0,0,0,1,n),n}static LookDirectionRH(P,e){const n=new J;return J.LookDirectionRHToRef(P,e,n),n}static LookDirectionRHToRef(P,e,n){const H=I.Ie[2];return j.CrossToRef(e,P,H),J.FromValuesToRef(H._x,H._y,H._z,0,e._x,e._y,e._z,0,P._x,P._y,P._z,0,0,0,0,1,n),n}static OrthoLH(P,e,n,H,S){const p=new J;return J.OrthoLHToRef(P,e,n,H,p,S),p}static OrthoLHToRef(P,e,n,H,S,p){const k=2/P,m=2/e,t=2/(H-n),C=-(H+n)/(H-n);return J.FromValuesToRef(k,0,0,0,0,m,0,0,0,0,t,0,0,0,C,1,S),p&&S.multiplyToRef(V,S),S._updateIdentityStatus(1===k&&1===m&&1===t&&0===C),S}static OrthoOffCenterLH(P,e,n,H,S,p,k){const m=new J;return J.OrthoOffCenterLHToRef(P,e,n,H,S,p,m,k),m}static OrthoOffCenterLHToRef(P,e,n,H,S,p,k,m){const t=2/(e-P),C=2/(H-n),R=2/(p-S),q=-(p+S)/(p-S),A=(P+e)/(P-e),F=(H+n)/(n-H);return J.FromValuesToRef(t,0,0,0,0,C,0,0,0,0,R,0,A,F,q,1,k),m&&k.multiplyToRef(V,k),k.markAsUpdated(),k}static ObliqueOffCenterLHToRef(P,e,n,H,S,p,k,m,t,C,R){const q=-k*Math.cos(m),A=-k*Math.sin(m);return J.TranslationToRef(0,0,-t,I.Matrix[1]),J.FromValuesToRef(1,0,0,0,0,1,0,0,q,A,1,0,0,0,0,1,I.Matrix[0]),I.Matrix[1].multiplyToRef(I.Matrix[0],I.Matrix[0]),J.TranslationToRef(0,0,t,I.Matrix[1]),I.Matrix[0].multiplyToRef(I.Matrix[1],I.Matrix[0]),J.OrthoOffCenterLHToRef(P,e,n,H,S,p,C,R),I.Matrix[0].multiplyToRef(C,C),C}static OrthoOffCenterRH(P,e,n,H,S,p,k){const m=new J;return J.OrthoOffCenterRHToRef(P,e,n,H,S,p,m,k),m}static OrthoOffCenterRHToRef(P,e,n,H,S,p,k,m){return J.OrthoOffCenterLHToRef(P,e,n,H,S,p,k,m),k.Be[10]*=-1,k}static ObliqueOffCenterRHToRef(P,e,n,H,S,p,k,m,t,C,R){const q=k*Math.cos(m),A=k*Math.sin(m);return J.TranslationToRef(0,0,t,I.Matrix[1]),J.FromValuesToRef(1,0,0,0,0,1,0,0,q,A,1,0,0,0,0,1,I.Matrix[0]),I.Matrix[1].multiplyToRef(I.Matrix[0],I.Matrix[0]),J.TranslationToRef(0,0,-t,I.Matrix[1]),I.Matrix[0].multiplyToRef(I.Matrix[1],I.Matrix[0]),J.OrthoOffCenterRHToRef(P,e,n,H,S,p,C,R),I.Matrix[0].multiplyToRef(C,C),C}static PerspectiveLH(P,e,n,H,S){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const k=new J,m=2*n/P,t=2*n/e,C=(H+n)/(H-n),R=-2*H*n/(H-n),q=Math.tan(p);return J.FromValuesToRef(m,0,0,0,0,t,0,q,0,0,C,1,0,0,R,0,k),S&&k.multiplyToRef(V,k),k._updateIdentityStatus(!1),k}static PerspectiveFovLH(P,e,n,H,S){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,k=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const m=new J;return J.PerspectiveFovLHToRef(P,e,n,H,m,!0,S,p,k),m}static PerspectiveFovLHToRef(P,e,n,H,S){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,m=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,t=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const C=n,R=H,q=1/Math.tan(.5*P),A=p?q/e:q,F=p?q:q*e,Y=t&&0===C?-1:0!==R?(R+C)/(R-C):1,j=t&&0===C?2*R:0!==R?-2*R*C/(R-C):-2*C,z=Math.tan(m);return J.FromValuesToRef(A,0,0,0,0,F,0,z,0,0,Y,1,0,0,j,0,S),k&&S.multiplyToRef(V,S),S._updateIdentityStatus(!1),S}static PerspectiveFovReverseLHToRef(P,e,n,H,S){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,m=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const t=1/Math.tan(.5*P),C=p?t/e:t,R=p?t:t*e,q=Math.tan(m);return J.FromValuesToRef(C,0,0,0,0,R,0,q,0,0,-n,1,0,0,1,0,S),k&&S.multiplyToRef(V,S),S._updateIdentityStatus(!1),S}static PerspectiveFovRH(P,e,n,H,S){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,k=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const m=new J;return J.PerspectiveFovRHToRef(P,e,n,H,m,!0,S,p,k),m}static PerspectiveFovRHToRef(P,e,n,H,S){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,m=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,t=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const C=n,R=H,q=1/Math.tan(.5*P),A=p?q/e:q,F=p?q:q*e,Y=t&&0===C?1:0!==R?-(R+C)/(R-C):-1,j=t&&0===C?2*R:0!==R?-2*R*C/(R-C):-2*C,z=Math.tan(m);return J.FromValuesToRef(A,0,0,0,0,F,0,z,0,0,Y,-1,0,0,j,0,S),k&&S.multiplyToRef(V,S),S._updateIdentityStatus(!1),S}static PerspectiveFovReverseRHToRef(P,e,n,H,S){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,m=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const t=1/Math.tan(.5*P),C=p?t/e:t,R=p?t:t*e,q=Math.tan(m);return J.FromValuesToRef(C,0,0,0,0,R,0,q,0,0,-n,-1,0,0,-1,0,S),k&&S.multiplyToRef(V,S),S._updateIdentityStatus(!1),S}static GetFinalMatrix(P,e,n,H,S,p){const k=P.width,m=P.height,t=P.x,C=P.y,R=J.FromValues(k/2,0,0,0,0,-m/2,0,0,0,0,p-S,0,t+k/2,m/2+C,S,1),q=new J;return e.multiplyToRef(n,q),q.multiplyToRef(H,q),q.multiplyToRef(R,q)}static GetAsMatrix2x2(P){const e=P.m,n=[e[0],e[1],e[4],e[5]];return k.e.MatrixUse64Bits?n:new Float32Array(n)}static GetAsMatrix3x3(P){const e=P.m,n=[e[0],e[1],e[2],e[4],e[5],e[6],e[8],e[9],e[10]];return k.e.MatrixUse64Bits?n:new Float32Array(n)}static Transpose(P){const e=new J;return J.TransposeToRef(P,e),e}static TransposeToRef(P,e){const n=P.m,H=n[0],S=n[4],p=n[8],k=n[12],m=n[1],t=n[5],C=n[9],R=n[13],q=n[2],A=n[6],F=n[10],Y=n[14],j=n[3],z=n[7],w=n[11],J=n[15],I=e.Be;return I[0]=H,I[1]=S,I[2]=p,I[3]=k,I[4]=m,I[5]=t,I[6]=C,I[7]=R,I[8]=q,I[9]=A,I[10]=F,I[11]=Y,I[12]=j,I[13]=z,I[14]=w,I[15]=J,e.markAsUpdated(),e._updateIdentityStatus(P._isIdentity,P._isIdentityDirty),e}static Reflection(P){const e=new J;return J.ReflectionToRef(P,e),e}static ReflectionToRef(P,e){P.normalize();const n=P.normal.x,H=P.normal.y,S=P.normal.z,p=-2*n,k=-2*H,m=-2*S;return J.FromValuesToRef(p*n+1,k*n,m*n,0,p*H,k*H+1,m*H,0,p*S,k*S,m*S+1,0,p*P.d,k*P.d,m*P.d,1,e),e}static FromXYZAxesToRef(P,e,n,H){return J.FromValuesToRef(P._x,P._y,P._z,0,e._x,e._y,e._z,0,n._x,n._y,n._z,0,0,0,0,1,H),H}static FromQuaternionToRef(P,e){const n=P._x*P._x,H=P._y*P._y,S=P._z*P._z,p=P._x*P._y,k=P._z*P._w,m=P._z*P._x,t=P._y*P._w,C=P._y*P._z,R=P._x*P._w;return e.Be[0]=1-2*(H+S),e.Be[1]=2*(p+k),e.Be[2]=2*(m-t),e.Be[3]=0,e.Be[4]=2*(p-k),e.Be[5]=1-2*(S+n),e.Be[6]=2*(C+R),e.Be[7]=0,e.Be[8]=2*(m+t),e.Be[9]=2*(C-R),e.Be[10]=1-2*(H+n),e.Be[11]=0,e.Be[12]=0,e.Be[13]=0,e.Be[14]=0,e.Be[15]=1,e.markAsUpdated(),e}}J._IdentityReadOnly=J.Identity(),Object.defineProperties(J.prototype,{dimension:{value:[4,4]},rank:{value:2}});class I{}I.Ie=(0,S.i)(11,j.Zero),I.Matrix=(0,S.i)(2,J.Identity),I.Quaternion=(0,S.i)(3,w.Zero);class O{}O.Vector2=(0,S.i)(3,Y.Zero),O.Ie=(0,S.i)(13,j.Zero),O.Vector4=(0,S.i)(3,z.Zero),O.Quaternion=(0,S.i)(3,w.Zero),O.Matrix=(0,S.i)(8,J.Identity),(0,p.h)("BABYLON.Vector2",Y),(0,p.h)("BABYLON.Vector3",j),(0,p.h)("BABYLON.Vector4",z),(0,p.h)("BABYLON.Matrix",J);const V=J.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11143:(P,e,n)=>{function H(P,e){const n=[];for(let H=0;H<P;++H)n.push(e());return n}function S(P,e){return H(P,e)}n.d(e,{e:()=>H,i:()=>S,k:()=>k});const p=["push","splice","pop","shift","unshift"];function k(P,e){const n=p.map((n=>function(P,e,n){const H=P[e];if("function"!==typeof H)return null;const S=function(){const H=P.length,p=S.previous.apply(P,arguments);return n(e,H),p};return H.next=S,S.previous=H,P[e]=S,()=>{const n=S.previous;if(!n)return;const H=S.next;H?(n.next=H,H.previous=n):(n.next=void 0,P[e]=n),S.next=void 0,S.previous=void 0}}(P,n,e)));return()=>{for(const P of n)null===P||void 0===P||P()}}}}]);