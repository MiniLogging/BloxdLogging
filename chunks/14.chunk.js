"use strict";(self["5dou0t7wntc"]=self["5dou0t7wntc"]||[]).push([[14],{11721:(K,O,F)=>{F.d(O,{e:()=>q,i:()=>l,k:()=>f,o:()=>r});const f=1/2.2,r=2.2,l=(1+Math.sqrt(5))/2,q=.001},11734:(K,O,F)=>{function f(K){return parseInt(K.toString().replace(/\W/g,""))}function r(K,O){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(K-O)<=F}function l(K,O,F){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return K<O-f||K>F+f}function q(K,O){return K===O?K:Math.random()*(O-K)+K}function J(K,O,F){return K+(O-K)*F}function c(K,O,F){let f=o(O-K,360);return f>180&&(f-=360),K+f*j(F)}function E(K,O,F){let f=0;return f=K!=O?j((F-K)/(O-K)):0,f}function M(K,O,F,f,r){const l=r*r,q=r*l;return K*(2*q-3*l+1)+F*(-2*q+3*l)+O*(q-2*l+r)+f*(q-l)}function t(K,O,F,f,r){const l=r*r;return 6*(l-r)*K+(3*l-4*r+1)*O+6*(-l+r)*F+(3*l-2*r)*f}function j(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(F,Math.max(O,K))}function X(K){return K-=2*Math.PI*Math.floor((K+Math.PI)/(2*Math.PI))}function u(K){const O=K.toString(16);return K<=15?("0"+O).toUpperCase():O.toUpperCase()}function T(K){if(Math.log2)return Math.floor(Math.log2(K));if(K<0)return NaN;if(0===K)return-1/0;let O=0;if(K<1){for(;K<1;)O++,K*=2;O=-O}else if(K>1)for(;K>1;)O++,K=Math.floor(K/2);return O}function o(K,O){return K-Math.floor(K/O)*O}function k(K,O,F){return(K-O)/(F-O)}function N(K,O,F){return K*(F-O)+O}function Z(K,O){let F=o(O-K,360);return F>180&&(F-=360),F}function L(K,O){const F=o(K,2*O);return O-Math.abs(F-O)}function d(K,O,F){let f=j(F);return f=-2*f*f*f+3*f*f,O*f+K*(1-f)}function a(K,O,F){let f=0;return f=Math.abs(O-K)<=F?O:K+Math.sign(O-K)*F,f}function g(K,O,F){const f=Z(K,O);let r=0;return r=-F<f&&f<F?O:a(K,O=K+f,F),r}function H(K,O,F){return(K-O)/(F-O)}function e(K,O,F){return(F-O)*K+O}function W(K,O){const F=K%O;return 0===F?O:W(O,F)}F.r(O),F.d(O,{Clamp:()=>j,DeltaAngle:()=>Z,Denormalize:()=>N,ExtractAsInt:()=>f,Hermite:()=>M,Hermite1stDerivative:()=>t,HighestCommonFactor:()=>W,ILog2:()=>T,InverseLerp:()=>E,Lerp:()=>J,LerpAngle:()=>c,MoveTowards:()=>a,MoveTowardsAngle:()=>g,Normalize:()=>k,NormalizeRadians:()=>X,OutsideRange:()=>l,PercentToRange:()=>e,PingPong:()=>L,RandomRange:()=>q,RangeToPercent:()=>H,Repeat:()=>o,SmoothStep:()=>d,ToHex:()=>u,WithinEpsilon:()=>r})},11713:(K,O,F)=>{F.r(O),F.d(O,{Matrix:()=>N,Quaternion:()=>k,TmpVectors:()=>L,Vector2:()=>u,TO:()=>T,Vector4:()=>o});var f=F(11721),r=F(11729),l=F(11661),q=F(11629),J=F(11559),c=F(11734);class E{}function M(K,O,F){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r=K.hf(),l=O.hf(),q=r[0],J=r[1],c=r[2],E=r[3],M=r[4],t=r[5],j=r[6],X=r[7],u=r[8],T=r[9],o=r[10],k=r[11],N=r[12],Z=r[13],L=r[14],d=r[15],a=l[0],g=l[1],H=l[2],e=l[3],W=l[4],p=l[5],y=l[6],A=l[7],Q=l[8],R=l[9],G=l[10],z=l[11],m=l[12],x=l[13],V=l[14],v=l[15];F[f]=q*a+J*W+c*Q+E*m,F[f+1]=q*g+J*p+c*R+E*x,F[f+2]=q*H+J*y+c*G+E*V,F[f+3]=q*e+J*A+c*z+E*v,F[f+4]=M*a+t*W+j*Q+X*m,F[f+5]=M*g+t*p+j*R+X*x,F[f+6]=M*H+t*y+j*G+X*V,F[f+7]=M*e+t*A+j*z+X*v,F[f+8]=u*a+T*W+o*Q+k*m,F[f+9]=u*g+T*p+o*R+k*x,F[f+10]=u*H+T*y+o*G+k*V,F[f+11]=u*e+T*A+o*z+k*v,F[f+12]=N*a+Z*W+L*Q+d*m,F[f+13]=N*g+Z*p+L*R+d*x,F[f+14]=N*H+Z*y+L*G+d*V,F[f+15]=N*e+Z*A+L*z+d*v}function t(K,O){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const f=K.hf();O[F]=f[0],O[F+1]=f[1],O[F+2]=f[2],O[F+3]=f[3],O[F+4]=f[4],O[F+5]=f[5],O[F+6]=f[6],O[F+7]=f[7],O[F+8]=f[8],O[F+9]=f[9],O[F+10]=f[10],O[F+11]=f[11],O[F+12]=f[12],O[F+13]=f[13],O[F+14]=f[14],O[F+15]=f[15]}function j(K,O){const F=K.hf(),f=F[0],r=F[1],l=F[2],q=F[3],J=F[4],c=F[5],E=F[6],M=F[7],t=F[8],j=F[9],X=F[10],u=F[11],T=F[12],o=F[13],k=F[14],N=F[15],Z=X*N-k*u,L=j*N-o*u,d=j*k-o*X,a=t*N-T*u,g=t*k-X*T,H=t*o-T*j,e=+(c*Z-E*L+M*d),W=-(J*Z-E*a+M*g),p=+(J*L-c*a+M*H),y=-(J*d-c*g+E*H),A=f*e+r*W+l*p+q*y;if(0===A)return!1;const Q=1/A,R=E*N-k*M,G=c*N-o*M,z=c*k-o*E,m=J*N-T*M,x=J*k-T*E,V=J*o-T*c,v=E*u-X*M,Y=c*u-j*M,B=c*X-j*E,n=J*u-t*M,C=J*X-t*E,I=J*j-t*c,D=-(r*Z-l*L+q*d),h=+(f*Z-l*a+q*g),b=-(f*L-r*a+q*H),i=+(f*d-r*g+l*H),w=+(r*R-l*G+q*z),s=-(f*R-l*m+q*x),U=+(f*G-r*m+q*V),P=-(f*z-r*x+l*V),S=-(r*v-l*Y+q*B),KK=+(f*v-l*n+q*C),OK=-(f*Y-r*n+q*I),FK=+(f*B-r*C+l*I);return O[0]=e*Q,O[1]=D*Q,O[2]=w*Q,O[3]=S*Q,O[4]=W*Q,O[5]=h*Q,O[6]=s*Q,O[7]=KK*Q,O[8]=p*Q,O[9]=b*Q,O[10]=U*Q,O[11]=OK*Q,O[12]=y*Q,O[13]=i*Q,O[14]=P*Q,O[15]=FK*Q,!0}E._UpdateFlagSeed=0;const X=K=>parseInt(K.toString().replace(/\W/g,""));class u{constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=K,this.y=O}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let K=X(this.x);return K=397*K^X(this.y),K}toArray(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[O]=this.x,K[O+1]=this.y,this}uF(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(K,O,this),this}hf(){return[this.x,this.y]}l(K){return this.x=K.x,this.y=K.y,this}eq(K,O){return this.x=K,this.y=O,this}set(K,O){return this.eq(K,O)}oJ(K){return this.eq(K,K)}add(K){return new u(this.x+K.x,this.y+K.y)}addToRef(K,O){return O.x=this.x+K.x,O.y=this.y+K.y,O}addInPlace(K){return this.x+=K.x,this.y+=K.y,this}addInPlaceFromFloats(K,O){return this.x+=K,this.y+=O,this}addVector3(K){return new u(this.x+K.x,this.y+K.y)}oO(K){return new u(this.x-K.x,this.y-K.y)}subtractToRef(K,O){return O.x=this.x-K.x,O.y=this.y-K.y,O}Qt(K){return this.x-=K.x,this.y-=K.y,this}multiplyInPlace(K){return this.x*=K.x,this.y*=K.y,this}multiply(K){return new u(this.x*K.x,this.y*K.y)}multiplyToRef(K,O){return O.x=this.x*K.x,O.y=this.y*K.y,O}multiplyByFloats(K,O){return new u(this.x*K,this.y*O)}divide(K){return new u(this.x/K.x,this.y/K.y)}divideToRef(K,O){return O.x=this.x/K.x,O.y=this.y/K.y,O}divideInPlace(K){return this.x=this.x/K.x,this.y=this.y/K.y,this}minimizeInPlace(K){return this.minimizeInPlaceFromFloats(K.x,K.y)}maximizeInPlace(K){return this.maximizeInPlaceFromFloats(K.x,K.y)}minimizeInPlaceFromFloats(K,O){return this.x=Math.min(K,this.x),this.y=Math.min(O,this.y),this}maximizeInPlaceFromFloats(K,O){return this.x=Math.max(K,this.x),this.y=Math.max(O,this.y),this}subtractFromFloats(K,O){return new u(this.x-K,this.y-O)}subtractFromFloatsToRef(K,O,F){return F.x=this.x-K,F.y=this.y-O,F}negate(){return new u(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(K){return K.x=-this.x,K.y=-this.y,K}scaleInPlace(K){return this.x*=K,this.y*=K,this}scale(K){return new u(this.x*K,this.y*K)}scaleToRef(K,O){return O.x=this.x*K,O.y=this.y*K,O}scaleAndAddToRef(K,O){return O.x+=this.x*K,O.y+=this.y*K,O}equals(K){return K&&this.x===K.x&&this.y===K.y}equalsWithEpsilon(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return K&&(0,c.WithinEpsilon)(this.x,K.x,O)&&(0,c.WithinEpsilon)(this.y,K.y,O)}equalsToFloats(K,O){return this.x===K&&this.y===O}floor(){return new u(Math.floor(this.x),Math.floor(this.y))}floorToRef(K){return K.x=Math.floor(this.x),K.y=Math.floor(this.y),K}fract(){return new u(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(K){return K.x=this.x-Math.floor(this.x),K.y=this.y-Math.floor(this.y),K}rotate(K){return this.rotateToRef(K,new u)}rotateToRef(K,O){const F=Math.cos(K),f=Math.sin(K);return O.x=F*this.x-f*this.y,O.y=f*this.x+F*this.y,O}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){const K=new u;return this.normalizeToRef(K),K}normalizeToRef(K){const O=this.length();return 0===O&&(K.x=this.x,K.y=this.y),this.scaleToRef(1/O,K)}clone(){return new u(this.x,this.y)}dot(K){return this.x*K.x+this.y*K.y}static Zero(){return new u(0,0)}static One(){return new u(1,1)}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new u((0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).eq((0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O))}static get ZeroReadOnly(){return u._ZeroReadOnly}static LO(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new u(K[O],K[O+1])}static FromArrayToRef(K,O,F){return F.x=K[O],F.y=K[O+1],F}static FromFloatsToRef(K,O,F){return F.eq(K,O),F}static CatmullRom(K,O,F,f,r){const l=r*r,q=r*l,J=.5*(2*O.x+(-K.x+F.x)*r+(2*K.x-5*O.x+4*F.x-f.x)*l+(-K.x+3*O.x-3*F.x+f.x)*q),c=.5*(2*O.y+(-K.y+F.y)*r+(2*K.y-5*O.y+4*F.y-f.y)*l+(-K.y+3*O.y-3*F.y+f.y)*q);return new u(J,c)}static ClampToRef(K,O,F,f){return f.x=(0,c.Clamp)(K.x,O.x,F.x),f.y=(0,c.Clamp)(K.y,O.y,F.y),f}static Clamp(K,O,F){const f=(0,c.Clamp)(K.x,O.x,F.x),r=(0,c.Clamp)(K.y,O.y,F.y);return new u(f,r)}static Hermite(K,O,F,f,r){const l=r*r,q=r*l,J=2*q-3*l+1,c=-2*q+3*l,E=q-2*l+r,M=q-l,t=K.x*J+F.x*c+O.x*E+f.x*M,j=K.y*J+F.y*c+O.y*E+f.y*M;return new u(t,j)}static Hermite1stDerivative(K,O,F,f,r){return this.Hermite1stDerivativeToRef(K,O,F,f,r,new u)}static Hermite1stDerivativeToRef(K,O,F,f,r,l){const q=r*r;return l.x=6*(q-r)*K.x+(3*q-4*r+1)*O.x+6*(-q+r)*F.x+(3*q-2*r)*f.x,l.y=6*(q-r)*K.y+(3*q-4*r+1)*O.y+6*(-q+r)*F.y+(3*q-2*r)*f.y,l}static Lerp(K,O,F){return u.LerpToRef(K,O,F,new u)}static LerpToRef(K,O,F,f){return f.x=K.x+(O.x-K.x)*F,f.y=K.y+(O.y-K.y)*F,f}static Dot(K,O){return K.x*O.x+K.y*O.y}static Normalize(K){return u.NormalizeToRef(K,new u)}static NormalizeToRef(K,O){return K.normalizeToRef(O),O}static Minimize(K,O){const F=K.x<O.x?K.x:O.x,f=K.y<O.y?K.y:O.y;return new u(F,f)}static Maximize(K,O){const F=K.x>O.x?K.x:O.x,f=K.y>O.y?K.y:O.y;return new u(F,f)}static Transform(K,O){return u.TransformToRef(K,O,new u)}static TransformToRef(K,O,F){const f=O.m,r=K.x*f[0]+K.y*f[4]+f[12],l=K.x*f[1]+K.y*f[5]+f[13];return F.x=r,F.y=l,F}static PointInTriangle(K,O,F,f){const r=.5*(-F.y*f.x+O.y*(-F.x+f.x)+O.x*(F.y-f.y)+F.x*f.y),l=r<0?-1:1,q=(O.y*f.x-O.x*f.y+(f.y-O.y)*K.x+(O.x-f.x)*K.y)*l,J=(O.x*F.y-O.y*F.x+(O.y-F.y)*K.x+(F.x-O.x)*K.y)*l;return q>0&&J>0&&q+J<2*r*l}static Distance(K,O){return Math.sqrt(u.DistanceSquared(K,O))}static DistanceSquared(K,O){const F=K.x-O.x,f=K.y-O.y;return F*F+f*f}static Center(K,O){return u.CenterToRef(K,O,new u)}static CenterToRef(K,O,F){return F.eq((K.x+O.x)/2,(K.y+O.y)/2)}static DistanceOfPointFromSegment(K,O,F){const f=u.DistanceSquared(O,F);if(0===f)return u.Distance(K,O);const r=F.oO(O),l=Math.max(0,Math.min(1,u.Dot(K.oO(O),r)/f)),q=O.add(r.multiplyByFloats(l,l));return u.Distance(K,q)}}u._V8PerformanceHack=new u(.5,.5),u._ZeroReadOnly=u.Zero(),Object.defineProperties(u.prototype,{dimension:{value:[2]},rank:{value:1}});class T{get x(){return this._x}set x(K){this._x=K,this._isDirty=!0}get y(){return this._y}set y(K){this._y=K,this._isDirty=!0}get z(){return this._z}set z(K){this._z=K,this._isDirty=!0}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=K,this._y=O,this._z=F}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"TO"}getHashCode(){let K=X(this._x);return K=397*K^X(this._y),K=397*K^X(this._z),K}hf(){return[this._x,this._y,this._z]}toArray(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[O]=this._x,K[O+1]=this._y,K[O+2]=this._z,this}uF(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return T.FromArrayToRef(K,O,this),this}toQuaternion(){return k.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(K){return this._x+=K._x,this._y+=K._y,this._z+=K._z,this._isDirty=!0,this}addInPlaceFromFloats(K,O,F){return this._x+=K,this._y+=O,this._z+=F,this._isDirty=!0,this}add(K){return new T(this._x+K._x,this._y+K._y,this._z+K._z)}addToRef(K,O){return O._x=this._x+K._x,O._y=this._y+K._y,O._z=this._z+K._z,O._isDirty=!0,O}Qt(K){return this._x-=K._x,this._y-=K._y,this._z-=K._z,this._isDirty=!0,this}oO(K){return new T(this._x-K._x,this._y-K._y,this._z-K._z)}subtractToRef(K,O){return this.subtractFromFloatsToRef(K._x,K._y,K._z,O)}subtractFromFloats(K,O,F){return new T(this._x-K,this._y-O,this._z-F)}subtractFromFloatsToRef(K,O,F,f){return f._x=this._x-K,f._y=this._y-O,f._z=this._z-F,f._isDirty=!0,f}negate(){return new T(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(K){return K._x=-1*this._x,K._y=-1*this._y,K._z=-1*this._z,K._isDirty=!0,K}scaleInPlace(K){return this._x*=K,this._y*=K,this._z*=K,this._isDirty=!0,this}scale(K){return new T(this._x*K,this._y*K,this._z*K)}scaleToRef(K,O){return O._x=this._x*K,O._y=this._y*K,O._z=this._z*K,O._isDirty=!0,O}getNormalToRef(K){const O=this.length();let F=Math.acos(this._y/O);const f=Math.atan2(this._z,this._x);F>Math.PI/2?F-=Math.PI/2:F+=Math.PI/2;const r=O*Math.sin(F)*Math.cos(f),l=O*Math.cos(F),q=O*Math.sin(F)*Math.sin(f);return K.set(r,l,q),K}applyRotationQuaternionToRef(K,O){const F=this._x,f=this._y,r=this._z,l=K._x,q=K._y,J=K._z,c=K._w,E=2*(q*r-J*f),M=2*(J*F-l*r),t=2*(l*f-q*F);return O._x=F+c*E+q*t-J*M,O._y=f+c*M+J*E-l*t,O._z=r+c*t+l*M-q*E,O._isDirty=!0,O}applyRotationQuaternionInPlace(K){return this.applyRotationQuaternionToRef(K,this)}applyRotationQuaternion(K){return this.applyRotationQuaternionToRef(K,new T)}scaleAndAddToRef(K,O){return O._x+=this._x*K,O._y+=this._y*K,O._z+=this._z*K,O._isDirty=!0,O}projectOnPlane(K,O){return this.projectOnPlaneToRef(K,O,new T)}projectOnPlaneToRef(K,O,F){const f=K.normal,r=K.d,l=Z.TO[0];this.subtractToRef(O,l),l.normalize();const q=T.Dot(l,f);if(Math.abs(q)<1e-10)F.oJ(1/0);else{const K=-(T.Dot(O,f)+r)/q,J=l.scaleInPlace(K);O.addToRef(J,F)}return F}equals(K){return K&&this._x===K._x&&this._y===K._y&&this._z===K._z}equalsWithEpsilon(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return K&&(0,c.WithinEpsilon)(this._x,K._x,O)&&(0,c.WithinEpsilon)(this._y,K._y,O)&&(0,c.WithinEpsilon)(this._z,K._z,O)}equalsToFloats(K,O,F){return this._x===K&&this._y===O&&this._z===F}multiplyInPlace(K){return this._x*=K._x,this._y*=K._y,this._z*=K._z,this._isDirty=!0,this}multiply(K){return this.multiplyByFloats(K._x,K._y,K._z)}multiplyToRef(K,O){return O._x=this._x*K._x,O._y=this._y*K._y,O._z=this._z*K._z,O._isDirty=!0,O}multiplyByFloats(K,O,F){return new T(this._x*K,this._y*O,this._z*F)}divide(K){return new T(this._x/K._x,this._y/K._y,this._z/K._z)}divideToRef(K,O){return O._x=this._x/K._x,O._y=this._y/K._y,O._z=this._z/K._z,O._isDirty=!0,O}divideInPlace(K){return this._x=this._x/K._x,this._y=this._y/K._y,this._z=this._z/K._z,this._isDirty=!0,this}minimizeInPlace(K){return this.minimizeInPlaceFromFloats(K._x,K._y,K._z)}maximizeInPlace(K){return this.maximizeInPlaceFromFloats(K._x,K._y,K._z)}minimizeInPlaceFromFloats(K,O,F){return K<this._x&&(this.x=K),O<this._y&&(this.y=O),F<this._z&&(this.z=F),this}maximizeInPlaceFromFloats(K,O,F){return K>this._x&&(this.x=K),O>this._y&&(this.y=O),F>this._z&&(this.z=F),this}isNonUniformWithinEpsilon(K){const O=Math.abs(this._x),F=Math.abs(this._y);if(!(0,c.WithinEpsilon)(O,F,K))return!0;const f=Math.abs(this._z);return!(0,c.WithinEpsilon)(O,f,K)||!(0,c.WithinEpsilon)(F,f,K)}get isNonUniform(){const K=Math.abs(this._x);if(K!==Math.abs(this._y))return!0;return K!==Math.abs(this._z)}floorToRef(K){return K._x=Math.floor(this._x),K._y=Math.floor(this._y),K._z=Math.floor(this._z),K._isDirty=!0,K}floor(){return new T(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(K){return K._x=this._x-Math.floor(this._x),K._y=this._y-Math.floor(this._y),K._z=this._z-Math.floor(this._z),K._isDirty=!0,K}fract(){return new T(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(K){if("xyz"===(K=K.toLowerCase()))return this;const O=Z.TO[0].l(this);return this.x=O[K[0]],this.y=O[K[1]],this.z=O[K[2]],this}rotateByQuaternionToRef(K,O){return K.toRotationMatrix(Z.Matrix[0]),T.TransformCoordinatesToRef(this,Z.Matrix[0],O),O}rotateByQuaternionAroundPointToRef(K,O,F){return this.subtractToRef(O,Z.TO[0]),Z.TO[0].rotateByQuaternionToRef(K,Z.TO[0]),O.addToRef(Z.TO[0],F),F}cross(K){return T.CrossToRef(this,K,new T)}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){return this.normalizeToRef(new T)}normalizeToRef(K){const O=this.length();return 0===O||1===O?(K._x=this._x,K._y=this._y,K._z=this._z,K._isDirty=!0,K):this.scaleToRef(1/O,K)}clone(){return new T(this._x,this._y,this._z)}l(K){return this.eq(K._x,K._y,K._z)}eq(K,O,F){return this._x=K,this._y=O,this._z=F,this._isDirty=!0,this}set(K,O,F){return this.eq(K,O,F)}oJ(K){return this._x=this._y=this._z=K,this._isDirty=!0,this}static GetClipFactor(K,O,F,f){const r=T.Dot(K,F);return(r-f)/(r-T.Dot(O,F))}static GetAngleBetweenVectors(K,O,F){const f=K.normalizeToRef(Z.TO[1]),r=O.normalizeToRef(Z.TO[2]);let l=T.Dot(f,r);l=(0,c.Clamp)(l,-1,1);const q=Math.acos(l),J=Z.TO[3];return T.CrossToRef(f,r,J),T.Dot(J,F)>0?isNaN(q)?0:q:isNaN(q)?-Math.PI:-Math.acos(l)}static GetAngleBetweenVectorsOnPlane(K,O,F){Z.TO[0].l(K);const f=Z.TO[0];Z.TO[1].l(O);const r=Z.TO[1];Z.TO[2].l(F);const l=Z.TO[2],q=Z.TO[3],J=Z.TO[4];f.normalize(),r.normalize(),l.normalize(),T.CrossToRef(l,f,q),T.CrossToRef(q,l,J);const E=Math.atan2(T.Dot(r,q),T.Dot(r,J));return(0,c.NormalizeRadians)(E)}static PitchYawRollToMoveBetweenPointsToRef(K,O,F){const f=L.TO[0];return O.subtractToRef(K,f),F._y=Math.atan2(f.x,f.z)||0,F._x=Math.atan2(Math.sqrt(f.x**2+f.z**2),f.y)||0,F._z=0,F._isDirty=!0,F}static PitchYawRollToMoveBetweenPoints(K,O){const F=T.Zero();return T.PitchYawRollToMoveBetweenPointsToRef(K,O,F)}static SlerpToRef(K,O,F,r){F=(0,c.Clamp)(F,0,1);const l=Z.TO[0],q=Z.TO[1];l.l(K);const J=l.length();l.normalizeFromLength(J),q.l(O);const E=q.length();q.normalizeFromLength(E);const M=T.Dot(l,q);let t,j;if(M<1-f.e){const K=Math.acos(M),O=1/Math.sin(K);t=Math.sin((1-F)*K)*O,j=Math.sin(F*K)*O}else t=1-F,j=F;return l.scaleInPlace(t),q.scaleInPlace(j),r.l(l).addInPlace(q),r.scaleInPlace((0,c.Lerp)(J,E,F)),r}static SmoothToRef(K,O,F,f,r){return T.SlerpToRef(K,O,0===f?1:F/f,r),r}static LO(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new T(K[O],K[O+1],K[O+2])}static FromFloatArray(K,O){return T.LO(K,O)}static FromArrayToRef(K,O,F){return F._x=K[O],F._y=K[O+1],F._z=K[O+2],F._isDirty=!0,F}static FromFloatArrayToRef(K,O,F){return T.FromArrayToRef(K,O,F)}static FromFloatsToRef(K,O,F,f){return f.eq(K,O,F),f}static Zero(){return new T(0,0,0)}static One(){return new T(1,1,1)}static Up(){return new T(0,1,0)}static get UpReadOnly(){return T._UpReadOnly}static get DownReadOnly(){return T._DownReadOnly}static get RightReadOnly(){return T._RightReadOnly}static get LeftReadOnly(){return T._LeftReadOnly}static get LeftHandedForwardReadOnly(){return T._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return T._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return T._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return T._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return T._ZeroReadOnly}static get OneReadOnly(){return T._OneReadOnly}static Down(){return new T(0,-1,0)}static Forward(){return new T(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new T(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new T(1,0,0)}static Left(){return new T(-1,0,0)}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new T((0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).eq((0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O))}static TransformCoordinates(K,O){const F=T.Zero();return T.TransformCoordinatesToRef(K,O,F),F}static TransformCoordinatesToRef(K,O,F){return T.TransformCoordinatesFromFloatsToRef(K._x,K._y,K._z,O,F),F}static TransformCoordinatesFromFloatsToRef(K,O,F,f,r){const l=f.m,q=K*l[0]+O*l[4]+F*l[8]+l[12],J=K*l[1]+O*l[5]+F*l[9]+l[13],c=K*l[2]+O*l[6]+F*l[10]+l[14],E=1/(K*l[3]+O*l[7]+F*l[11]+l[15]);return r._x=q*E,r._y=J*E,r._z=c*E,r._isDirty=!0,r}static TransformNormal(K,O){const F=T.Zero();return T.TransformNormalToRef(K,O,F),F}static TransformNormalToRef(K,O,F){return this.TransformNormalFromFloatsToRef(K._x,K._y,K._z,O,F),F}static TransformNormalFromFloatsToRef(K,O,F,f,r){const l=f.m;return r._x=K*l[0]+O*l[4]+F*l[8],r._y=K*l[1]+O*l[5]+F*l[9],r._z=K*l[2]+O*l[6]+F*l[10],r._isDirty=!0,r}static CatmullRom(K,O,F,f,r){const l=r*r,q=r*l,J=.5*(2*O._x+(-K._x+F._x)*r+(2*K._x-5*O._x+4*F._x-f._x)*l+(-K._x+3*O._x-3*F._x+f._x)*q),c=.5*(2*O._y+(-K._y+F._y)*r+(2*K._y-5*O._y+4*F._y-f._y)*l+(-K._y+3*O._y-3*F._y+f._y)*q),E=.5*(2*O._z+(-K._z+F._z)*r+(2*K._z-5*O._z+4*F._z-f._z)*l+(-K._z+3*O._z-3*F._z+f._z)*q);return new T(J,c,E)}static Clamp(K,O,F){const f=new T;return T.ClampToRef(K,O,F,f),f}static ClampToRef(K,O,F,f){let r=K._x;r=r>F._x?F._x:r,r=r<O._x?O._x:r;let l=K._y;l=l>F._y?F._y:l,l=l<O._y?O._y:l;let q=K._z;return q=q>F._z?F._z:q,q=q<O._z?O._z:q,f.eq(r,l,q),f}static CheckExtends(K,O,F){O.minimizeInPlace(K),F.maximizeInPlace(K)}static Hermite(K,O,F,f,r){const l=r*r,q=r*l,J=2*q-3*l+1,c=-2*q+3*l,E=q-2*l+r,M=q-l,t=K._x*J+F._x*c+O._x*E+f._x*M,j=K._y*J+F._y*c+O._y*E+f._y*M,X=K._z*J+F._z*c+O._z*E+f._z*M;return new T(t,j,X)}static Hermite1stDerivative(K,O,F,f,r){const l=new T;return this.Hermite1stDerivativeToRef(K,O,F,f,r,l),l}static Hermite1stDerivativeToRef(K,O,F,f,r,l){const q=r*r;return l._x=6*(q-r)*K._x+(3*q-4*r+1)*O._x+6*(-q+r)*F._x+(3*q-2*r)*f._x,l._y=6*(q-r)*K._y+(3*q-4*r+1)*O._y+6*(-q+r)*F._y+(3*q-2*r)*f._y,l._z=6*(q-r)*K._z+(3*q-4*r+1)*O._z+6*(-q+r)*F._z+(3*q-2*r)*f._z,l._isDirty=!0,l}static Lerp(K,O,F){const f=new T(0,0,0);return T.LerpToRef(K,O,F,f),f}static LerpToRef(K,O,F,f){return f._x=K._x+(O._x-K._x)*F,f._y=K._y+(O._y-K._y)*F,f._z=K._z+(O._z-K._z)*F,f._isDirty=!0,f}static Dot(K,O){return K._x*O._x+K._y*O._y+K._z*O._z}dot(K){return this._x*K._x+this._y*K._y+this._z*K._z}static Cross(K,O){const F=new T;return T.CrossToRef(K,O,F),F}static CrossToRef(K,O,F){const f=K._y*O._z-K._z*O._y,r=K._z*O._x-K._x*O._z,l=K._x*O._y-K._y*O._x;return F.eq(f,r,l),F}static Normalize(K){const O=T.Zero();return T.NormalizeToRef(K,O),O}static NormalizeToRef(K,O){return K.normalizeToRef(O),O}static Project(K,O,F,f){const r=new T;return T.ProjectToRef(K,O,F,f,r),r}static ProjectToRef(K,O,F,f,r){var l;const q=f.width,c=f.height,E=f.x,M=f.y,t=Z.Matrix[1],j=null===(l=J.e.LastCreatedEngine)||void 0===l?void 0:l.isNDCHalfZRange,X=j?1:.5,u=j?0:.5;N.FromValuesToRef(q/2,0,0,0,0,-c/2,0,0,0,0,X,0,E+q/2,c/2+M,u,1,t);const o=Z.Matrix[0];return O.multiplyToRef(F,o),o.multiplyToRef(t,o),T.TransformCoordinatesToRef(K,o,r),r}static Reflect(K,O){return this.ReflectToRef(K,O,new T)}static ReflectToRef(K,O,F){const f=L.TO[0];return f.l(O).scaleInPlace(2*T.Dot(K,O)),F.l(K).Qt(f)}static _UnprojectFromInvertedMatrixToRef(K,O,F){T.TransformCoordinatesToRef(K,O,F);const f=O.m,r=K._x*f[3]+K._y*f[7]+K._z*f[11]+f[15];return(0,c.WithinEpsilon)(r,1)&&F.scaleInPlace(1/r),F}static UnprojectFromTransform(K,O,F,f,r){return this.Unproject(K,O,F,f,r,N.IdentityReadOnly)}static Unproject(K,O,F,f,r,l){const q=new T;return T.UnprojectToRef(K,O,F,f,r,l,q),q}static UnprojectToRef(K,O,F,f,r,l,q){return T.UnprojectFloatsToRef(K._x,K._y,K._z,O,F,f,r,l,q),q}static UnprojectFloatsToRef(K,O,F,f,r,l,q,c,E){var M;const t=Z.Matrix[0];l.multiplyToRef(q,t),t.multiplyToRef(c,t),t.invert();const j=Z.TO[0];return j.x=K/f*2-1,j.y=-(O/r*2-1),null!==(M=J.e.LastCreatedEngine)&&void 0!==M&&M.isNDCHalfZRange?j.z=F:j.z=2*F-1,T._UnprojectFromInvertedMatrixToRef(j,t,E),E}static Minimize(K,O){const F=new T;return F.l(K),F.minimizeInPlace(O),F}static Maximize(K,O){const F=new T;return F.l(K),F.maximizeInPlace(O),F}static Distance(K,O){return Math.sqrt(T.DistanceSquared(K,O))}static DistanceSquared(K,O){const F=K._x-O._x,f=K._y-O._y,r=K._z-O._z;return F*F+f*f+r*r}static ProjectOnTriangleToRef(K,O,F,r,l){const q=Z.TO[0],J=Z.TO[1],E=Z.TO[2],M=Z.TO[3],t=Z.TO[4];F.subtractToRef(O,q),r.subtractToRef(O,J),r.subtractToRef(F,E);const j=q.length(),X=J.length(),u=E.length();if(j<f.e||X<f.e||u<f.e)return l.l(O),T.Distance(K,O);K.subtractToRef(O,t),T.CrossToRef(q,J,M);const o=M.length();if(o<f.e)return l.l(O),T.Distance(K,O);M.normalizeFromLength(o);let k=t.length();if(k<f.e)return l.l(O),0;t.normalizeFromLength(k);const N=T.Dot(M,t),L=Z.TO[5],d=Z.TO[6];L.l(M).scaleInPlace(-k*N),d.l(K).addInPlace(L);const a=Z.TO[4],g=Z.TO[5],H=Z.TO[7],e=Z.TO[8];a.l(q).scaleInPlace(1/j),e.l(J).scaleInPlace(1/X),a.addInPlace(e).scaleInPlace(-1),g.l(q).scaleInPlace(-1/j),e.l(E).scaleInPlace(1/u),g.addInPlace(e).scaleInPlace(-1),H.l(E).scaleInPlace(-1/u),e.l(J).scaleInPlace(-1/X),H.addInPlace(e).scaleInPlace(-1);const W=Z.TO[9];let p;W.l(d).Qt(O),T.CrossToRef(a,W,e),p=T.Dot(e,M);const y=p;W.l(d).Qt(F),T.CrossToRef(g,W,e),p=T.Dot(e,M);const A=p;W.l(d).Qt(r),T.CrossToRef(H,W,e),p=T.Dot(e,M);const Q=p,R=Z.TO[10];let G,z;y>0&&A<0?(R.l(q),G=O,z=F):A>0&&Q<0?(R.l(E),G=F,z=r):(R.l(J).scaleInPlace(-1),G=r,z=O);const m=Z.TO[9],x=Z.TO[4];G.subtractToRef(d,e),z.subtractToRef(d,m),T.CrossToRef(e,m,x);if(!(T.Dot(x,M)<0))return l.l(d),Math.abs(k*N);const V=Z.TO[5];T.CrossToRef(R,x,V),V.normalize();const v=Z.TO[9];v.l(G).Qt(d);const Y=v.length();if(Y<f.e)return l.l(G),T.Distance(K,G);v.normalizeFromLength(Y);const B=T.Dot(V,v),n=Z.TO[7];n.l(d).addInPlace(V.scaleInPlace(Y*B)),e.l(n).Qt(G),k=R.length(),R.normalizeFromLength(k);let C=T.Dot(e,R)/Math.max(k,f.e);return C=(0,c.Clamp)(C,0,1),n.l(G).addInPlace(R.scaleInPlace(C*k)),l.l(n),T.Distance(K,n)}static Center(K,O){return T.CenterToRef(K,O,T.Zero())}static CenterToRef(K,O,F){return F.eq((K._x+O._x)/2,(K._y+O._y)/2,(K._z+O._z)/2)}static RotationFromAxis(K,O,F){const f=new T;return T.RotationFromAxisToRef(K,O,F,f),f}static RotationFromAxisToRef(K,O,F,f){const r=Z.Quaternion[0];return k.RotationQuaternionFromAxisToRef(K,O,F,r),r.toEulerAnglesToRef(f),f}}T._V8PerformanceHack=new T(.5,.5,.5),T._UpReadOnly=T.Up(),T._DownReadOnly=T.Down(),T._LeftHandedForwardReadOnly=T.Forward(!1),T._RightHandedForwardReadOnly=T.Forward(!0),T._LeftHandedBackwardReadOnly=T.Backward(!1),T._RightHandedBackwardReadOnly=T.Backward(!0),T._RightReadOnly=T.Right(),T._LeftReadOnly=T.Left(),T._ZeroReadOnly=T.Zero(),T._OneReadOnly=T.One(),Object.defineProperties(T.prototype,{dimension:{value:[3]},rank:{value:1}});class o{get x(){return this._x}set x(K){this._x=K,this._isDirty=!0}get y(){return this._y}set y(K){this._y=K,this._isDirty=!0}get z(){return this._z}set z(K){this._z=K,this._isDirty=!0}get w(){return this._w}set w(K){this._w=K,this._isDirty=!0}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=K,this._y=O,this._z=F,this._w=f}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let K=X(this._x);return K=397*K^X(this._y),K=397*K^X(this._z),K=397*K^X(this._w),K}hf(){return[this._x,this._y,this._z,this._w]}toArray(K,O){return void 0===O&&(O=0),K[O]=this._x,K[O+1]=this._y,K[O+2]=this._z,K[O+3]=this._w,this}uF(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o.FromArrayToRef(K,O,this),this}addInPlace(K){return this.x+=K._x,this.y+=K._y,this.z+=K._z,this.w+=K._w,this}addInPlaceFromFloats(K,O,F,f){return this.x+=K,this.y+=O,this.z+=F,this.w+=f,this}add(K){return new o(this._x+K.x,this._y+K.y,this._z+K.z,this._w+K.w)}addToRef(K,O){return O.x=this._x+K.x,O.y=this._y+K.y,O.z=this._z+K.z,O.w=this._w+K.w,O}Qt(K){return this.x-=K.x,this.y-=K.y,this.z-=K.z,this.w-=K.w,this}oO(K){return new o(this._x-K.x,this._y-K.y,this._z-K.z,this._w-K.w)}subtractToRef(K,O){return O.x=this._x-K.x,O.y=this._y-K.y,O.z=this._z-K.z,O.w=this._w-K.w,O}subtractFromFloats(K,O,F,f){return new o(this._x-K,this._y-O,this._z-F,this._w-f)}subtractFromFloatsToRef(K,O,F,f,r){return r.x=this._x-K,r.y=this._y-O,r.z=this._z-F,r.w=this._w-f,r}negate(){return new o(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(K){return K.x=-this._x,K.y=-this._y,K.z=-this._z,K.w=-this._w,K}scaleInPlace(K){return this.x*=K,this.y*=K,this.z*=K,this.w*=K,this}scale(K){return new o(this._x*K,this._y*K,this._z*K,this._w*K)}scaleToRef(K,O){return O.x=this._x*K,O.y=this._y*K,O.z=this._z*K,O.w=this._w*K,O}scaleAndAddToRef(K,O){return O.x+=this._x*K,O.y+=this._y*K,O.z+=this._z*K,O.w+=this._w*K,O}equals(K){return K&&this._x===K.x&&this._y===K.y&&this._z===K.z&&this._w===K.w}equalsWithEpsilon(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return K&&(0,c.WithinEpsilon)(this._x,K.x,O)&&(0,c.WithinEpsilon)(this._y,K.y,O)&&(0,c.WithinEpsilon)(this._z,K.z,O)&&(0,c.WithinEpsilon)(this._w,K.w,O)}equalsToFloats(K,O,F,f){return this._x===K&&this._y===O&&this._z===F&&this._w===f}multiplyInPlace(K){return this.x*=K.x,this.y*=K.y,this.z*=K.z,this.w*=K.w,this}multiply(K){return new o(this._x*K.x,this._y*K.y,this._z*K.z,this._w*K.w)}multiplyToRef(K,O){return O.x=this._x*K.x,O.y=this._y*K.y,O.z=this._z*K.z,O.w=this._w*K.w,O}multiplyByFloats(K,O,F,f){return new o(this._x*K,this._y*O,this._z*F,this._w*f)}divide(K){return new o(this._x/K.x,this._y/K.y,this._z/K.z,this._w/K.w)}divideToRef(K,O){return O.x=this._x/K.x,O.y=this._y/K.y,O.z=this._z/K.z,O.w=this._w/K.w,O}divideInPlace(K){return this.divideToRef(K,this)}minimizeInPlace(K){return K.x<this._x&&(this.x=K.x),K.y<this._y&&(this.y=K.y),K.z<this._z&&(this.z=K.z),K.w<this._w&&(this.w=K.w),this}maximizeInPlace(K){return K.x>this._x&&(this.x=K.x),K.y>this._y&&(this.y=K.y),K.z>this._z&&(this.z=K.z),K.w>this._w&&(this.w=K.w),this}minimizeInPlaceFromFloats(K,O,F,f){return this.x=Math.min(K,this._x),this.y=Math.min(O,this._y),this.z=Math.min(F,this._z),this.w=Math.min(f,this._w),this}maximizeInPlaceFromFloats(K,O,F,f){return this.x=Math.max(K,this._x),this.y=Math.max(O,this._y),this.z=Math.max(F,this._z),this.w=Math.max(f,this._w),this}floorToRef(K){return K.x=Math.floor(this._x),K.y=Math.floor(this._y),K.z=Math.floor(this._z),K.w=Math.floor(this._w),K}floor(){return new o(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(K){return K.x=this._x-Math.floor(this._x),K.y=this._y-Math.floor(this._y),K.z=this._z-Math.floor(this._z),K.w=this._w-Math.floor(this._w),K}fract(){return new o(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){return this.normalizeToRef(new o)}normalizeToRef(K){const O=this.length();return 0===O||1===O?(K.x=this._x,K.y=this._y,K.z=this._z,K.w=this._w,K):this.scaleToRef(1/O,K)}toVector3(){return new T(this._x,this._y,this._z)}clone(){return new o(this._x,this._y,this._z,this._w)}l(K){return this.x=K.x,this.y=K.y,this.z=K.z,this.w=K.w,this}eq(K,O,F,f){return this.x=K,this.y=O,this.z=F,this.w=f,this}set(K,O,F,f){return this.eq(K,O,F,f)}oJ(K){return this.x=this.y=this.z=this.w=K,this}dot(K){return this._x*K.x+this._y*K.y+this._z*K.z+this._w*K.w}static LO(K,O){return O||(O=0),new o(K[O],K[O+1],K[O+2],K[O+3])}static FromArrayToRef(K,O,F){return F.x=K[O],F.y=K[O+1],F.z=K[O+2],F.w=K[O+3],F}static FromFloatArrayToRef(K,O,F){return o.FromArrayToRef(K,O,F),F}static FromFloatsToRef(K,O,F,f,r){return r.x=K,r.y=O,r.z=F,r.w=f,r}static Zero(){return new o(0,0,0,0)}static One(){return new o(1,1,1,1)}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new o((0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0;return F.x=(0,c.RandomRange)(K,O),F.y=(0,c.RandomRange)(K,O),F.z=(0,c.RandomRange)(K,O),F.w=(0,c.RandomRange)(K,O),F}static Clamp(K,O,F){return o.ClampToRef(K,O,F,new o)}static ClampToRef(K,O,F,f){return f.x=(0,c.Clamp)(K.x,O.x,F.x),f.y=(0,c.Clamp)(K.y,O.y,F.y),f.z=(0,c.Clamp)(K.z,O.z,F.z),f.w=(0,c.Clamp)(K.w,O.w,F.w),f}static CheckExtends(K,O,F){O.minimizeInPlace(K),F.maximizeInPlace(K)}static get ZeroReadOnly(){return o._ZeroReadOnly}static Normalize(K){return o.NormalizeToRef(K,new o)}static NormalizeToRef(K,O){return K.normalizeToRef(O),O}static Minimize(K,O){const F=new o;return F.l(K),F.minimizeInPlace(O),F}static Maximize(K,O){const F=new o;return F.l(K),F.maximizeInPlace(O),F}static Distance(K,O){return Math.sqrt(o.DistanceSquared(K,O))}static DistanceSquared(K,O){const F=K.x-O.x,f=K.y-O.y,r=K.z-O.z,l=K.w-O.w;return F*F+f*f+r*r+l*l}static Center(K,O){return o.CenterToRef(K,O,new o)}static CenterToRef(K,O,F){return F.x=(K.x+O.x)/2,F.y=(K.y+O.y)/2,F.z=(K.z+O.z)/2,F.w=(K.w+O.w)/2,F}static TransformCoordinates(K,O){return o.TransformCoordinatesToRef(K,O,new o)}static TransformCoordinatesToRef(K,O,F){return o.TransformCoordinatesFromFloatsToRef(K._x,K._y,K._z,O,F),F}static TransformCoordinatesFromFloatsToRef(K,O,F,f,r){const l=f.m,q=K*l[0]+O*l[4]+F*l[8]+l[12],J=K*l[1]+O*l[5]+F*l[9]+l[13],c=K*l[2]+O*l[6]+F*l[10]+l[14],E=K*l[3]+O*l[7]+F*l[11]+l[15];return r.x=q,r.y=J,r.z=c,r.w=E,r}static TransformNormal(K,O){return o.TransformNormalToRef(K,O,new o)}static TransformNormalToRef(K,O,F){const f=O.m,r=K.x*f[0]+K.y*f[4]+K.z*f[8],l=K.x*f[1]+K.y*f[5]+K.z*f[9],q=K.x*f[2]+K.y*f[6]+K.z*f[10];return F.x=r,F.y=l,F.z=q,F.w=K.w,F}static TransformNormalFromFloatsToRef(K,O,F,f,r,l){const q=r.m;return l.x=K*q[0]+O*q[4]+F*q[8],l.y=K*q[1]+O*q[5]+F*q[9],l.z=K*q[2]+O*q[6]+F*q[10],l.w=f,l}static FromVector3(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new o(K._x,K._y,K._z,O)}static Dot(K,O){return K.x*O.x+K.y*O.y+K.z*O.z+K.w*O.w}}o._V8PerformanceHack=new o(.5,.5,.5,.5),o._ZeroReadOnly=o.Zero(),Object.defineProperties(o.prototype,{dimension:{value:[4]},rank:{value:1}});class k{get x(){return this._x}set x(K){this._x=K,this._isDirty=!0}get y(){return this._y}set y(K){this._y=K,this._isDirty=!0}get z(){return this._z}set z(K){this._z=K,this._isDirty=!0}get w(){return this._w}set w(K){this._w=K,this._isDirty=!0}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=K,this._y=O,this._z=F,this._w=f}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let K=X(this._x);return K=397*K^X(this._y),K=397*K^X(this._z),K=397*K^X(this._w),K}hf(){return[this._x,this._y,this._z,this._w]}toArray(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[O]=this._x,K[O+1]=this._y,K[O+2]=this._z,K[O+3]=this._w,this}uF(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k.FromArrayToRef(K,O,this)}equals(K){return K&&this._x===K._x&&this._y===K._y&&this._z===K._z&&this._w===K._w}equalsWithEpsilon(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return K&&(0,c.WithinEpsilon)(this._x,K._x,O)&&(0,c.WithinEpsilon)(this._y,K._y,O)&&(0,c.WithinEpsilon)(this._z,K._z,O)&&(0,c.WithinEpsilon)(this._w,K._w,O)}isApprox(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return K&&((0,c.WithinEpsilon)(this._x,K._x,O)&&(0,c.WithinEpsilon)(this._y,K._y,O)&&(0,c.WithinEpsilon)(this._z,K._z,O)&&(0,c.WithinEpsilon)(this._w,K._w,O)||(0,c.WithinEpsilon)(this._x,-K._x,O)&&(0,c.WithinEpsilon)(this._y,-K._y,O)&&(0,c.WithinEpsilon)(this._z,-K._z,O)&&(0,c.WithinEpsilon)(this._w,-K._w,O))}clone(){return new k(this._x,this._y,this._z,this._w)}l(K){return this._x=K._x,this._y=K._y,this._z=K._z,this._w=K._w,this._isDirty=!0,this}eq(K,O,F,f){return this._x=K,this._y=O,this._z=F,this._w=f,this._isDirty=!0,this}set(K,O,F,f){return this.eq(K,O,F,f)}oJ(K){return this.eq(K,K,K,K)}add(K){return new k(this._x+K._x,this._y+K._y,this._z+K._z,this._w+K._w)}addInPlace(K){return this._x+=K._x,this._y+=K._y,this._z+=K._z,this._w+=K._w,this._isDirty=!0,this}addToRef(K,O){return O._x=this._x+K._x,O._y=this._y+K._y,O._z=this._z+K._z,O._w=this._w+K._w,O._isDirty=!0,O}addInPlaceFromFloats(K,O,F,f){return this._x+=K,this._y+=O,this._z+=F,this._w+=f,this._isDirty=!0,this}subtractToRef(K,O){return O._x=this._x-K._x,O._y=this._y-K._y,O._z=this._z-K._z,O._w=this._w-K._w,O._isDirty=!0,O}subtractFromFloats(K,O,F,f){return this.subtractFromFloatsToRef(K,O,F,f,new k)}subtractFromFloatsToRef(K,O,F,f,r){return r._x=this._x-K,r._y=this._y-O,r._z=this._z-F,r._w=this._w-f,r._isDirty=!0,r}oO(K){return new k(this._x-K._x,this._y-K._y,this._z-K._z,this._w-K._w)}Qt(K){return this._x-=K._x,this._y-=K._y,this._z-=K._z,this._w-=K._w,this._isDirty=!0,this}scale(K){return new k(this._x*K,this._y*K,this._z*K,this._w*K)}scaleToRef(K,O){return O._x=this._x*K,O._y=this._y*K,O._z=this._z*K,O._w=this._w*K,O._isDirty=!0,O}scaleInPlace(K){return this._x*=K,this._y*=K,this._z*=K,this._w*=K,this._isDirty=!0,this}scaleAndAddToRef(K,O){return O._x+=this._x*K,O._y+=this._y*K,O._z+=this._z*K,O._w+=this._w*K,O._isDirty=!0,O}multiply(K){const O=new k(0,0,0,1);return this.multiplyToRef(K,O),O}multiplyToRef(K,O){const F=this._x*K._w+this._y*K._z-this._z*K._y+this._w*K._x,f=-this._x*K._z+this._y*K._w+this._z*K._x+this._w*K._y,r=this._x*K._y-this._y*K._x+this._z*K._w+this._w*K._z,l=-this._x*K._x-this._y*K._y-this._z*K._z+this._w*K._w;return O.eq(F,f,r,l),O}multiplyInPlace(K){return this.multiplyToRef(K,this)}multiplyByFloats(K,O,F,f){return this._x*=K,this._y*=O,this._z*=F,this._w*=f,this._isDirty=!0,this}divide(K){throw new ReferenceError("Can not divide a quaternion")}divideToRef(K,O){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(K){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new k)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(K){return K._x=-this._x,K._y=-this._y,K._z=-this._z,K._w=-this._w,K._isDirty=!0,K}equalsToFloats(K,O,F,f){return this._x===K&&this._y===O&&this._z===F&&this._w===f}floorToRef(K){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(K){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(K){return K.eq(-this._x,-this._y,-this._z,this._w),K}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new k(-this._x,-this._y,-this._z,this._w)}invert(){const K=this.conjugate(),O=this.lengthSquared();return 0==O||1==O||K.scaleInPlace(1/O),K}invertInPlace(){this.conjugateInPlace();const K=this.lengthSquared();return 0==K||1==K||this.scaleInPlace(1/K),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){const K=new k(0,0,0,1);return this.normalizeToRef(K),K}normalizeToRef(K){const O=this.length();return 0===O||1===O?K.eq(this._x,this._y,this._z,this._w):this.scaleToRef(1/O,K)}toEulerAngles(){const K=T.Zero();return this.toEulerAnglesToRef(K),K}toEulerAnglesToRef(K){const O=this._z,F=this._x,f=this._y,r=this._w,l=f*O-F*r,q=.4999999;if(l<-q)K._y=2*Math.atan2(f,r),K._x=Math.PI/2,K._z=0,K._isDirty=!0;else if(l>q)K._y=2*Math.atan2(f,r),K._x=-Math.PI/2,K._z=0,K._isDirty=!0;else{const q=r*r,J=O*O,c=F*F,E=f*f;K._z=Math.atan2(2*(F*f+O*r),-J-c+E+q),K._x=Math.asin(-2*l),K._y=Math.atan2(2*(O*F+f*r),J-c-E+q),K._isDirty=!0}return K}toAlphaBetaGammaToRef(K){const O=this._z,F=this._x,f=this._y,r=this._w,l=Math.sqrt(F*F+f*f),q=Math.sqrt(O*O+r*r),J=2*Math.atan2(l,q),c=2*Math.atan2(O,r),E=2*Math.atan2(f,F),M=(c+E)/2,t=(c-E)/2;return K.set(t,J,M),K}toRotationMatrix(K){return N.FromQuaternionToRef(this,K),K}fromRotationMatrix(K){return k.FromRotationMatrixToRef(K,this),this}dot(K){return this._x*K._x+this._y*K._y+this._z*K._z+this._w*K._w}toAxisAngle(){const K=T.Zero();return{axis:K,angle:this.toAxisAngleToRef(K)}}toAxisAngleToRef(K){let O=0;const F=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),f=this._w;return F>0?(O=2*Math.atan2(F,f),K.set(this._x/F,this._y/F,this._z/F)):(O=0,K.set(1,0,0)),O}static FromRotationMatrix(K){const O=new k;return k.FromRotationMatrixToRef(K,O),O}static FromRotationMatrixToRef(K,O){const F=K.m,f=F[0],r=F[4],l=F[8],q=F[1],J=F[5],c=F[9],E=F[2],M=F[6],t=F[10],j=f+J+t;let X;return j>0?(X=.5/Math.sqrt(j+1),O._w=.25/X,O._x=(M-c)*X,O._y=(l-E)*X,O._z=(q-r)*X,O._isDirty=!0):f>J&&f>t?(X=2*Math.sqrt(1+f-J-t),O._w=(M-c)/X,O._x=.25*X,O._y=(r+q)/X,O._z=(l+E)/X,O._isDirty=!0):J>t?(X=2*Math.sqrt(1+J-f-t),O._w=(l-E)/X,O._x=(r+q)/X,O._y=.25*X,O._z=(c+M)/X,O._isDirty=!0):(X=2*Math.sqrt(1+t-f-J),O._w=(q-r)/X,O._x=(l+E)/X,O._y=(c+M)/X,O._z=.25*X,O._isDirty=!0),O}static Dot(K,O){return K._x*O._x+K._y*O._y+K._z*O._z+K._w*O._w}static AreClose(K,O){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const f=k.Dot(K,O);return 1-f*f<=F}static SmoothToRef(K,O,F,f,r){let l=0===f?1:F/f;return l=(0,c.Clamp)(l,0,1),k.SlerpToRef(K,O,l,r),r}static Zero(){return new k(0,0,0,0)}static Inverse(K){return new k(-K._x,-K._y,-K._z,K._w)}static InverseToRef(K,O){return O.set(-K._x,-K._y,-K._z,K._w),O}static Identity(){return new k(0,0,0,1)}static IsIdentity(K){return K&&0===K._x&&0===K._y&&0===K._z&&1===K._w}static RotationAxis(K,O){return k.RotationAxisToRef(K,O,new k)}static RotationAxisToRef(K,O,F){F._w=Math.cos(O/2);const f=Math.sin(O/2)/K.length();return F._x=K._x*f,F._y=K._y*f,F._z=K._z*f,F._isDirty=!0,F}static LO(K,O){return O||(O=0),new k(K[O],K[O+1],K[O+2],K[O+3])}static FromArrayToRef(K,O,F){return F._x=K[O],F._y=K[O+1],F._z=K[O+2],F._w=K[O+3],F._isDirty=!0,F}static FromFloatsToRef(K,O,F,f,r){return r.eq(K,O,F,f),r}static FromEulerAngles(K,O,F){const f=new k;return k.RotationYawPitchRollToRef(O,K,F,f),f}static FromEulerAnglesToRef(K,O,F,f){return k.RotationYawPitchRollToRef(O,K,F,f),f}static FromEulerVector(K){const O=new k;return k.RotationYawPitchRollToRef(K._y,K._x,K._z,O),O}static FromEulerVectorToRef(K,O){return k.RotationYawPitchRollToRef(K._y,K._x,K._z,O),O}static FromUnitVectorsToRef(K,O,F){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:f.e;const l=T.Dot(K,O)+1;return l<r?Math.abs(K.x)>Math.abs(K.z)?F.set(-K.y,K.x,0,0):F.set(0,-K.z,K.y,0):(T.CrossToRef(K,O,L.TO[0]),F.set(L.TO[0].x,L.TO[0].y,L.TO[0].z,l)),F.normalize()}static RotationYawPitchRoll(K,O,F){const f=new k;return k.RotationYawPitchRollToRef(K,O,F,f),f}static RotationYawPitchRollToRef(K,O,F,f){const r=.5*F,l=.5*O,q=.5*K,J=Math.sin(r),c=Math.cos(r),E=Math.sin(l),M=Math.cos(l),t=Math.sin(q),j=Math.cos(q);return f._x=j*E*c+t*M*J,f._y=t*M*c-j*E*J,f._z=j*M*J-t*E*c,f._w=j*M*c+t*E*J,f._isDirty=!0,f}static RotationAlphaBetaGamma(K,O,F){const f=new k;return k.RotationAlphaBetaGammaToRef(K,O,F,f),f}static RotationAlphaBetaGammaToRef(K,O,F,f){const r=.5*(F+K),l=.5*(F-K),q=.5*O;return f._x=Math.cos(l)*Math.sin(q),f._y=Math.sin(l)*Math.sin(q),f._z=Math.sin(r)*Math.cos(q),f._w=Math.cos(r)*Math.cos(q),f._isDirty=!0,f}static RotationQuaternionFromAxis(K,O,F){const f=new k(0,0,0,0);return k.RotationQuaternionFromAxisToRef(K,O,F,f),f}static RotationQuaternionFromAxisToRef(K,O,F,f){const r=Z.Matrix[0];return K=K.normalizeToRef(Z.TO[0]),O=O.normalizeToRef(Z.TO[1]),F=F.normalizeToRef(Z.TO[2]),N.FromXYZAxesToRef(K,O,F,r),k.FromRotationMatrixToRef(r,f),f}static FromLookDirectionLH(K,O){const F=new k;return k.FromLookDirectionLHToRef(K,O,F),F}static FromLookDirectionLHToRef(K,O,F){const f=Z.Matrix[0];return N.LookDirectionLHToRef(K,O,f),k.FromRotationMatrixToRef(f,F),F}static FromLookDirectionRH(K,O){const F=new k;return k.FromLookDirectionRHToRef(K,O,F),F}static FromLookDirectionRHToRef(K,O,F){const f=Z.Matrix[0];return N.LookDirectionRHToRef(K,O,f),k.FromRotationMatrixToRef(f,F)}static Slerp(K,O,F){const f=k.Identity();return k.SlerpToRef(K,O,F,f),f}static SlerpToRef(K,O,F,f){let r,l,q=K._x*O._x+K._y*O._y+K._z*O._z+K._w*O._w,J=!1;if(q<0&&(J=!0,q=-q),q>.999999)l=1-F,r=J?-F:F;else{const K=Math.acos(q),O=1/Math.sin(K);l=Math.sin((1-F)*K)*O,r=J?-Math.sin(F*K)*O:Math.sin(F*K)*O}return f._x=l*K._x+r*O._x,f._y=l*K._y+r*O._y,f._z=l*K._z+r*O._z,f._w=l*K._w+r*O._w,f._isDirty=!0,f}static Hermite(K,O,F,f,r){const l=r*r,q=r*l,J=2*q-3*l+1,c=-2*q+3*l,E=q-2*l+r,M=q-l,t=K._x*J+F._x*c+O._x*E+f._x*M,j=K._y*J+F._y*c+O._y*E+f._y*M,X=K._z*J+F._z*c+O._z*E+f._z*M,u=K._w*J+F._w*c+O._w*E+f._w*M;return new k(t,j,X,u)}static Hermite1stDerivative(K,O,F,f,r){const l=new k;return this.Hermite1stDerivativeToRef(K,O,F,f,r,l),l}static Hermite1stDerivativeToRef(K,O,F,f,r,l){const q=r*r;return l._x=6*(q-r)*K._x+(3*q-4*r+1)*O._x+6*(-q+r)*F._x+(3*q-2*r)*f._x,l._y=6*(q-r)*K._y+(3*q-4*r+1)*O._y+6*(-q+r)*F._y+(3*q-2*r)*f._y,l._z=6*(q-r)*K._z+(3*q-4*r+1)*O._z+6*(-q+r)*F._z+(3*q-2*r)*f._z,l._w=6*(q-r)*K._w+(3*q-4*r+1)*O._w+6*(-q+r)*F._w+(3*q-2*r)*f._w,l._isDirty=!0,l}static Normalize(K){const O=k.Zero();return k.NormalizeToRef(K,O),O}static NormalizeToRef(K,O){return K.normalizeToRef(O),O}static Clamp(K,O,F){const f=new k;return k.ClampToRef(K,O,F,f),f}static ClampToRef(K,O,F,f){return f.eq((0,c.Clamp)(K.x,O.x,F.x),(0,c.Clamp)(K.y,O.y,F.y),(0,c.Clamp)(K.z,O.z,F.z),(0,c.Clamp)(K.w,O.w,F.w))}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new k((0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).eq((0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O),(0,c.RandomRange)(K,O))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(K,O){return Math.sqrt(k.DistanceSquared(K,O))}static DistanceSquared(K,O){const F=K.x-O.x,f=K.y-O.y,r=K.z-O.z,l=K.w-O.w;return F*F+f*f+r*r+l*l}static Center(K,O){return k.CenterToRef(K,O,k.Zero())}static CenterToRef(K,O,F){return F.eq((K.x+O.x)/2,(K.y+O.y)/2,(K.z+O.z)/2,(K.w+O.w)/2)}}k._V8PerformanceHack=new k(.5,.5,.5,.5),Object.defineProperties(k.prototype,{dimension:{value:[4]},rank:{value:1}});class N{static get Use64Bits(){return q.e.MatrixUse64Bits}get m(){return this.pf}markAsUpdated(){this.updateFlag=E._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(K){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1],F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],f=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=K,this._isIdentity3x2=K||F,this._isIdentityDirty=!this._isIdentity&&O,this._isIdentity3x2Dirty=!this._isIdentity3x2&&f}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,q.e.MatrixTrackPrecisionChange&&q.e.MatrixTrackedMatrices.push(this),this.pf=new q.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const K=this.pf;this._isIdentity=1===K[0]&&0===K[1]&&0===K[2]&&0===K[3]&&0===K[4]&&1===K[5]&&0===K[6]&&0===K[7]&&0===K[8]&&0===K[9]&&1===K[10]&&0===K[11]&&0===K[12]&&0===K[13]&&0===K[14]&&1===K[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.pf[0]||1!==this.pf[5]||1!==this.pf[15]||0!==this.pf[1]||0!==this.pf[2]||0!==this.pf[3]||0!==this.pf[4]||0!==this.pf[6]||0!==this.pf[7]||0!==this.pf[8]||0!==this.pf[9]||0!==this.pf[10]||0!==this.pf[11]||0!==this.pf[12]||0!==this.pf[13]||0!==this.pf[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const K=this.pf,O=K[0],F=K[1],f=K[2],r=K[3],l=K[4],q=K[5],J=K[6],c=K[7],E=K[8],M=K[9],t=K[10],j=K[11],X=K[12],u=K[13],T=K[14],o=K[15],k=t*o-T*j,N=M*o-u*j,Z=M*T-u*t,L=E*o-X*j,d=E*T-t*X,a=E*u-X*M;return O*+(q*k-J*N+c*Z)+F*-(l*k-J*L+c*d)+f*+(l*N-q*L+c*a)+r*-(l*Z-q*d+J*a)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!K)return this.pf;const F=this.pf;for(let f=0;f<16;f++)K[O+f]=F[f];return this}hf(){return this.pf}uF(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N.FromArrayToRef(K,O,this)}eq(){for(var K=arguments.length,O=new Array(K),F=0;F<K;F++)O[F]=arguments[F];return N.FromArrayToRef(O,0,this)}set(){const K=this.pf;for(let O=0;O<16;O++)K[O]=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}oJ(K){const O=this.pf;for(let F=0;F<16;F++)O[F]=K;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return N.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(K){const O=new N;return this.addToRef(K,O),O}addToRef(K,O){const F=this.pf,f=O.pf,r=K.m;for(let l=0;l<16;l++)f[l]=F[l]+r[l];return O.markAsUpdated(),O}addToSelf(K){const O=this.pf,F=K.m;return O[0]+=F[0],O[1]+=F[1],O[2]+=F[2],O[3]+=F[3],O[4]+=F[4],O[5]+=F[5],O[6]+=F[6],O[7]+=F[7],O[8]+=F[8],O[9]+=F[9],O[10]+=F[10],O[11]+=F[11],O[12]+=F[12],O[13]+=F[13],O[14]+=F[14],O[15]+=F[15],this.markAsUpdated(),this}addInPlace(K){const O=this.pf,F=K.m;for(let f=0;f<16;f++)O[f]+=F[f];return this.markAsUpdated(),this}addInPlaceFromFloats(){const K=this.pf;for(let O=0;O<16;O++)K[O]+=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}oO(K){const O=this.pf,F=K.m;for(let f=0;f<16;f++)O[f]-=F[f];return this.markAsUpdated(),this}subtractToRef(K,O){const F=this.pf,f=K.m,r=O.pf;for(let l=0;l<16;l++)r[l]=F[l]-f[l];return O.markAsUpdated(),O}Qt(K){const O=this.pf,F=K.m;for(let f=0;f<16;f++)O[f]-=F[f];return this.markAsUpdated(),this}subtractFromFloats(){for(var K=arguments.length,O=new Array(K),F=0;F<K;F++)O[F]=arguments[F];return this.subtractFromFloatsToRef(...O,new N)}subtractFromFloatsToRef(){for(var K=arguments.length,O=new Array(K),F=0;F<K;F++)O[F]=arguments[F];const f=O.pop(),r=this.pf,l=f.pf,q=O;for(let J=0;J<16;J++)l[J]=r[J]-q[J];return f.markAsUpdated(),f}invertToRef(K){return!0===this._isIdentity?(N.IdentityToRef(K),K):(j(this,K.hf())?K.markAsUpdated():K.l(this),K)}addAtIndex(K,O){return this.pf[K]+=O,this.markAsUpdated(),this}multiplyAtIndex(K,O){return this.pf[K]*=O,this.markAsUpdated(),this}setTranslationFromFloats(K,O,F){return this.pf[12]=K,this.pf[13]=O,this.pf[14]=F,this.markAsUpdated(),this}addTranslationFromFloats(K,O,F){return this.pf[12]+=K,this.pf[13]+=O,this.pf[14]+=F,this.markAsUpdated(),this}setTranslation(K){return this.setTranslationFromFloats(K._x,K._y,K._z)}getTranslation(){return new T(this.pf[12],this.pf[13],this.pf[14])}getTranslationToRef(K){return K.x=this.pf[12],K.y=this.pf[13],K.z=this.pf[14],K}removeRotationAndScaling(){const K=this.m;return N.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,K[12],K[13],K[14],K[15],this),this._updateIdentityStatus(0===K[12]&&0===K[13]&&0===K[14]&&1===K[15]),this}l(K){K.copyToArray(this.pf);const O=K;return this.updateFlag=O.updateFlag,this._updateIdentityStatus(O._isIdentity,O._isIdentityDirty,O._isIdentity3x2,O._isIdentity3x2Dirty),this}copyToArray(K){return t(this,K,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(K){const O=new N;return this.multiplyToRef(K,O),O}multiplyInPlace(K){const O=this.pf,F=K.m;for(let f=0;f<16;f++)O[f]*=F[f];return this.markAsUpdated(),this}multiplyByFloats(){const K=this.pf;for(let O=0;O<16;O++)K[O]*=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var K=arguments.length,O=new Array(K),F=0;F<K;F++)O[F]=arguments[F];const f=O.pop(),r=this.pf,l=f.pf,q=O;for(let J=0;J<16;J++)l[J]=r[J]*q[J];return f.markAsUpdated(),f}multiplyToRef(K,O){return this._isIdentity?(O.l(K),O):K._isIdentity?(O.l(this),O):(this.multiplyToArray(K,O.pf,0),O.markAsUpdated(),O)}multiplyToArray(K,O,F){return M(this,K,O,F),this}divide(K){return this.divideToRef(K,new N)}divideToRef(K,O){const F=this.pf,f=K.m,r=O.pf;for(let l=0;l<16;l++)r[l]=F[l]/f[l];return O.markAsUpdated(),O}divideInPlace(K){const O=this.pf,F=K.m;for(let f=0;f<16;f++)O[f]/=F[f];return this.markAsUpdated(),this}minimizeInPlace(K){const O=this.pf,F=K.m;for(let f=0;f<16;f++)O[f]=Math.min(O[f],F[f]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const K=this.pf;for(let O=0;O<16;O++)K[O]=Math.min(K[O],O<0||arguments.length<=O?void 0:arguments[O]);return this.markAsUpdated(),this}maximizeInPlace(K){const O=this.pf,F=K.m;for(let f=0;f<16;f++)O[f]=Math.min(O[f],F[f]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const K=this.pf;for(let O=0;O<16;O++)K[O]=Math.min(K[O],O<0||arguments.length<=O?void 0:arguments[O]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new N)}negateInPlace(){const K=this.pf;for(let O=0;O<16;O++)K[O]=-K[O];return this.markAsUpdated(),this}negateToRef(K){const O=this.pf,F=K.pf;for(let f=0;f<16;f++)F[f]=-O[f];return K.markAsUpdated(),K}equals(K){const O=K;if(!O)return!1;if((this._isIdentity||O._isIdentity)&&!this._isIdentityDirty&&!O._isIdentityDirty)return this._isIdentity&&O._isIdentity;const F=this.m,f=O.m;return F[0]===f[0]&&F[1]===f[1]&&F[2]===f[2]&&F[3]===f[3]&&F[4]===f[4]&&F[5]===f[5]&&F[6]===f[6]&&F[7]===f[7]&&F[8]===f[8]&&F[9]===f[9]&&F[10]===f[10]&&F[11]===f[11]&&F[12]===f[12]&&F[13]===f[13]&&F[14]===f[14]&&F[15]===f[15]}equalsWithEpsilon(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const F=this.pf,f=K.m;for(let r=0;r<16;r++)if(!(0,c.WithinEpsilon)(F[r],f[r],O))return!1;return!0}equalsToFloats(){const K=this.pf;for(let O=0;O<16;O++)if(K[O]!=(O<0||arguments.length<=O?void 0:arguments[O]))return!1;return!0}floor(){return this.floorToRef(new N)}floorToRef(K){const O=this.pf,F=K.pf;for(let f=0;f<16;f++)F[f]=Math.floor(O[f]);return K.markAsUpdated(),K}fract(){return this.fractToRef(new N)}fractToRef(K){const O=this.pf,F=K.pf;for(let f=0;f<16;f++)F[f]=O[f]-Math.floor(O[f]);return K.markAsUpdated(),K}clone(){const K=new N;return K.l(this),K}getClassName(){return"Matrix"}getHashCode(){let K=X(this.pf[0]);for(let O=1;O<16;O++)K=397*K^X(this.pf[O]);return K}decomposeToTransformNode(K){return K.rotationQuaternion=K.rotationQuaternion||new k,this.decompose(K.TJ,K.rotationQuaternion,K.position)}decompose(K,O,F,f){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return F&&F.oJ(0),K&&K.oJ(1),O&&O.eq(0,0,0,1),!0;const l=this.pf;if(F&&F.eq(l[12],l[13],l[14]),(K=K||Z.TO[0]).x=Math.sqrt(l[0]*l[0]+l[1]*l[1]+l[2]*l[2]),K.y=Math.sqrt(l[4]*l[4]+l[5]*l[5]+l[6]*l[6]),K.z=Math.sqrt(l[8]*l[8]+l[9]*l[9]+l[10]*l[10]),f){const O=(r?f.absoluteScaling.x:f.TJ.x)<0?-1:1,F=(r?f.absoluteScaling.y:f.TJ.y)<0?-1:1,l=(r?f.absoluteScaling.z:f.TJ.z)<0?-1:1;K.x*=O,K.y*=F,K.z*=l}else this.determinant()<=0&&(K.y*=-1);if(0===K._x||0===K._y||0===K._z)return O&&O.eq(0,0,0,1),!1;if(O){const F=1/K._x,f=1/K._y,r=1/K._z;N.FromValuesToRef(l[0]*F,l[1]*F,l[2]*F,0,l[4]*f,l[5]*f,l[6]*f,0,l[8]*r,l[9]*r,l[10]*r,0,0,0,0,1,Z.Matrix[0]),k.FromRotationMatrixToRef(Z.Matrix[0],O)}return!0}getRow(K){if(K<0||K>3)return null;const O=4*K;return new o(this.pf[O+0],this.pf[O+1],this.pf[O+2],this.pf[O+3])}getRowToRef(K,O){if(K>=0&&K<=3){const F=4*K;O.x=this.pf[F+0],O.y=this.pf[F+1],O.z=this.pf[F+2],O.w=this.pf[F+3]}return O}setRow(K,O){return this.setRowFromFloats(K,O.x,O.y,O.z,O.w)}transpose(){const K=new N;return N.TransposeToRef(this,K),K}transposeToRef(K){return N.TransposeToRef(this,K),K}setRowFromFloats(K,O,F,f,r){if(K<0||K>3)return this;const l=4*K;return this.pf[l+0]=O,this.pf[l+1]=F,this.pf[l+2]=f,this.pf[l+3]=r,this.markAsUpdated(),this}scale(K){const O=new N;return this.scaleToRef(K,O),O}scaleToRef(K,O){for(let F=0;F<16;F++)O.pf[F]=this.pf[F]*K;return O.markAsUpdated(),O}scaleAndAddToRef(K,O){for(let F=0;F<16;F++)O.pf[F]+=this.pf[F]*K;return O.markAsUpdated(),O}scaleInPlace(K){const O=this.pf;for(let F=0;F<16;F++)O[F]*=K;return this.markAsUpdated(),this}toNormalMatrix(K){const O=Z.Matrix[0];this.invertToRef(O),O.transposeToRef(K);const F=K.pf;return N.FromValuesToRef(F[0],F[1],F[2],0,F[4],F[5],F[6],0,F[8],F[9],F[10],0,0,0,0,1,K),K}getRotationMatrix(){const K=new N;return this.getRotationMatrixToRef(K),K}getRotationMatrixToRef(K){const O=Z.TO[0];if(!this.decompose(O))return N.IdentityToRef(K),K;const F=this.pf,f=1/O._x,r=1/O._y,l=1/O._z;return N.FromValuesToRef(F[0]*f,F[1]*f,F[2]*f,0,F[4]*r,F[5]*r,F[6]*r,0,F[8]*l,F[9]*l,F[10]*l,0,0,0,0,1,K),K}toggleModelMatrixHandInPlace(){const K=this.pf;return K[2]*=-1,K[6]*=-1,K[8]*=-1,K[9]*=-1,K[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const K=this.pf;return K[8]*=-1,K[9]*=-1,K[10]*=-1,K[11]*=-1,this.markAsUpdated(),this}static LO(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const F=new N;return N.FromArrayToRef(K,O,F),F}static FromArrayToRef(K,O,F){for(let f=0;f<16;f++)F.pf[f]=K[f+O];return F.markAsUpdated(),F}static FromFloat32ArrayToRefScaled(K,O,F,f){return f.pf[0]=K[0+O]*F,f.pf[1]=K[1+O]*F,f.pf[2]=K[2+O]*F,f.pf[3]=K[3+O]*F,f.pf[4]=K[4+O]*F,f.pf[5]=K[5+O]*F,f.pf[6]=K[6+O]*F,f.pf[7]=K[7+O]*F,f.pf[8]=K[8+O]*F,f.pf[9]=K[9+O]*F,f.pf[10]=K[10+O]*F,f.pf[11]=K[11+O]*F,f.pf[12]=K[12+O]*F,f.pf[13]=K[13+O]*F,f.pf[14]=K[14+O]*F,f.pf[15]=K[15+O]*F,f.markAsUpdated(),f}static get IdentityReadOnly(){return N._IdentityReadOnly}static FromValuesToRef(K,O,F,f,r,l,q,J,c,E,M,t,j,X,u,T,o){const k=o.pf;k[0]=K,k[1]=O,k[2]=F,k[3]=f,k[4]=r,k[5]=l,k[6]=q,k[7]=J,k[8]=c,k[9]=E,k[10]=M,k[11]=t,k[12]=j,k[13]=X,k[14]=u,k[15]=T,o.markAsUpdated()}static FromValues(K,O,F,f,r,l,q,J,c,E,M,t,j,X,u,T){const o=new N,k=o.pf;return k[0]=K,k[1]=O,k[2]=F,k[3]=f,k[4]=r,k[5]=l,k[6]=q,k[7]=J,k[8]=c,k[9]=E,k[10]=M,k[11]=t,k[12]=j,k[13]=X,k[14]=u,k[15]=T,o.markAsUpdated(),o}static Compose(K,O,F){const f=new N;return N.ComposeToRef(K,O,F,f),f}static ComposeToRef(K,O,F,f){const r=f.pf,l=O._x,q=O._y,J=O._z,c=O._w,E=l+l,M=q+q,t=J+J,j=l*E,X=l*M,u=l*t,T=q*M,o=q*t,k=J*t,N=c*E,Z=c*M,L=c*t,d=K._x,a=K._y,g=K._z;return r[0]=(1-(T+k))*d,r[1]=(X+L)*d,r[2]=(u-Z)*d,r[3]=0,r[4]=(X-L)*a,r[5]=(1-(j+k))*a,r[6]=(o+N)*a,r[7]=0,r[8]=(u+Z)*g,r[9]=(o-N)*g,r[10]=(1-(j+T))*g,r[11]=0,r[12]=F._x,r[13]=F._y,r[14]=F._z,r[15]=1,f.markAsUpdated(),f}static Identity(){const K=N.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return K._updateIdentityStatus(!0),K}static IdentityToRef(K){return N.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,K),K._updateIdentityStatus(!0),K}static Zero(){const K=N.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return K._updateIdentityStatus(!1),K}static RotationX(K){const O=new N;return N.RotationXToRef(K,O),O}static Invert(K){const O=new N;return K.invertToRef(O),O}static RotationXToRef(K,O){const F=Math.sin(K),f=Math.cos(K);return N.FromValuesToRef(1,0,0,0,0,f,F,0,0,-F,f,0,0,0,0,1,O),O._updateIdentityStatus(1===f&&0===F),O}static RotationY(K){const O=new N;return N.RotationYToRef(K,O),O}static RotationYToRef(K,O){const F=Math.sin(K),f=Math.cos(K);return N.FromValuesToRef(f,0,-F,0,0,1,0,0,F,0,f,0,0,0,0,1,O),O._updateIdentityStatus(1===f&&0===F),O}static RotationZ(K){const O=new N;return N.RotationZToRef(K,O),O}static RotationZToRef(K,O){const F=Math.sin(K),f=Math.cos(K);return N.FromValuesToRef(f,F,0,0,-F,f,0,0,0,0,1,0,0,0,0,1,O),O._updateIdentityStatus(1===f&&0===F),O}static RotationAxis(K,O){const F=new N;return N.RotationAxisToRef(K,O,F),F}static RotationAxisToRef(K,O,F){const f=Math.sin(-O),r=Math.cos(-O),l=1-r;K=K.normalizeToRef(Z.TO[0]);const q=F.pf;return q[0]=K._x*K._x*l+r,q[1]=K._x*K._y*l-K._z*f,q[2]=K._x*K._z*l+K._y*f,q[3]=0,q[4]=K._y*K._x*l+K._z*f,q[5]=K._y*K._y*l+r,q[6]=K._y*K._z*l-K._x*f,q[7]=0,q[8]=K._z*K._x*l-K._y*f,q[9]=K._z*K._y*l+K._x*f,q[10]=K._z*K._z*l+r,q[11]=0,q[12]=0,q[13]=0,q[14]=0,q[15]=1,F.markAsUpdated(),F}static RotationAlignToRef(K,O,F){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const l=T.Dot(O,K),q=F.pf;if(l<-1+f.e)q[0]=-1,q[1]=0,q[2]=0,q[3]=0,q[4]=0,q[5]=r?1:-1,q[6]=0,q[7]=0,q[8]=0,q[9]=0,q[10]=r?-1:1,q[11]=0;else{const F=T.Cross(O,K),f=1/(1+l);q[0]=F._x*F._x*f+l,q[1]=F._y*F._x*f-F._z,q[2]=F._z*F._x*f+F._y,q[3]=0,q[4]=F._x*F._y*f+F._z,q[5]=F._y*F._y*f+l,q[6]=F._z*F._y*f-F._x,q[7]=0,q[8]=F._x*F._z*f-F._y,q[9]=F._y*F._z*f+F._x,q[10]=F._z*F._z*f+l,q[11]=0}return q[12]=0,q[13]=0,q[14]=0,q[15]=1,F.markAsUpdated(),F}static RotationYawPitchRoll(K,O,F){const f=new N;return N.RotationYawPitchRollToRef(K,O,F,f),f}static RotationYawPitchRollToRef(K,O,F,f){return k.RotationYawPitchRollToRef(K,O,F,Z.Quaternion[0]),Z.Quaternion[0].toRotationMatrix(f),f}static Scaling(K,O,F){const f=new N;return N.ScalingToRef(K,O,F,f),f}static ScalingToRef(K,O,F,f){return N.FromValuesToRef(K,0,0,0,0,O,0,0,0,0,F,0,0,0,0,1,f),f._updateIdentityStatus(1===K&&1===O&&1===F),f}static Translation(K,O,F){const f=new N;return N.TranslationToRef(K,O,F,f),f}static TranslationToRef(K,O,F,f){return N.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,K,O,F,1,f),f._updateIdentityStatus(0===K&&0===O&&0===F),f}static Lerp(K,O,F){const f=new N;return N.LerpToRef(K,O,F,f),f}static LerpToRef(K,O,F,f){const r=f.pf,l=K.m,q=O.m;for(let J=0;J<16;J++)r[J]=l[J]*(1-F)+q[J]*F;return f.markAsUpdated(),f}static DecomposeLerp(K,O,F){const f=new N;return N.DecomposeLerpToRef(K,O,F,f),f}static DecomposeLerpToRef(K,O,F,f){const r=Z.TO[0],l=Z.Quaternion[0],q=Z.TO[1];K.decompose(r,l,q);const J=Z.TO[2],c=Z.Quaternion[1],E=Z.TO[3];O.decompose(J,c,E);const M=Z.TO[4];T.LerpToRef(r,J,F,M);const t=Z.Quaternion[2];k.SlerpToRef(l,c,F,t);const j=Z.TO[5];return T.LerpToRef(q,E,F,j),N.ComposeToRef(M,t,j,f),f}static LookAtLH(K,O,F){const f=new N;return N.LookAtLHToRef(K,O,F,f),f}static LookAtLHToRef(K,O,F,f){const r=Z.TO[0],l=Z.TO[1],q=Z.TO[2];O.subtractToRef(K,q),q.normalize(),T.CrossToRef(F,q,r);const J=r.lengthSquared();0===J?r.x=1:r.normalizeFromLength(Math.sqrt(J)),T.CrossToRef(q,r,l),l.normalize();const c=-T.Dot(r,K),E=-T.Dot(l,K),M=-T.Dot(q,K);return N.FromValuesToRef(r._x,l._x,q._x,0,r._y,l._y,q._y,0,r._z,l._z,q._z,0,c,E,M,1,f),f}static LookAtRH(K,O,F){const f=new N;return N.LookAtRHToRef(K,O,F,f),f}static LookAtRHToRef(K,O,F,f){const r=Z.TO[0],l=Z.TO[1],q=Z.TO[2];K.subtractToRef(O,q),q.normalize(),T.CrossToRef(F,q,r);const J=r.lengthSquared();0===J?r.x=1:r.normalizeFromLength(Math.sqrt(J)),T.CrossToRef(q,r,l),l.normalize();const c=-T.Dot(r,K),E=-T.Dot(l,K),M=-T.Dot(q,K);return N.FromValuesToRef(r._x,l._x,q._x,0,r._y,l._y,q._y,0,r._z,l._z,q._z,0,c,E,M,1,f),f}static LookDirectionLH(K,O){const F=new N;return N.LookDirectionLHToRef(K,O,F),F}static LookDirectionLHToRef(K,O,F){const f=Z.TO[0];f.l(K),f.scaleInPlace(-1);const r=Z.TO[1];return T.CrossToRef(O,f,r),N.FromValuesToRef(r._x,r._y,r._z,0,O._x,O._y,O._z,0,f._x,f._y,f._z,0,0,0,0,1,F),F}static LookDirectionRH(K,O){const F=new N;return N.LookDirectionRHToRef(K,O,F),F}static LookDirectionRHToRef(K,O,F){const f=Z.TO[2];return T.CrossToRef(O,K,f),N.FromValuesToRef(f._x,f._y,f._z,0,O._x,O._y,O._z,0,K._x,K._y,K._z,0,0,0,0,1,F),F}static OrthoLH(K,O,F,f,r){const l=new N;return N.OrthoLHToRef(K,O,F,f,l,r),l}static OrthoLHToRef(K,O,F,f,r,l){const q=2/K,J=2/O,c=2/(f-F),E=-(f+F)/(f-F);return N.FromValuesToRef(q,0,0,0,0,J,0,0,0,0,c,0,0,0,E,1,r),l&&r.multiplyToRef(d,r),r._updateIdentityStatus(1===q&&1===J&&1===c&&0===E),r}static OrthoOffCenterLH(K,O,F,f,r,l,q){const J=new N;return N.OrthoOffCenterLHToRef(K,O,F,f,r,l,J,q),J}static OrthoOffCenterLHToRef(K,O,F,f,r,l,q,J){const c=2/(O-K),E=2/(f-F),M=2/(l-r),t=-(l+r)/(l-r),j=(K+O)/(K-O),X=(f+F)/(F-f);return N.FromValuesToRef(c,0,0,0,0,E,0,0,0,0,M,0,j,X,t,1,q),J&&q.multiplyToRef(d,q),q.markAsUpdated(),q}static ObliqueOffCenterLHToRef(K,O,F,f,r,l,q,J,c,E,M){const t=-q*Math.cos(J),j=-q*Math.sin(J);return N.TranslationToRef(0,0,-c,Z.Matrix[1]),N.FromValuesToRef(1,0,0,0,0,1,0,0,t,j,1,0,0,0,0,1,Z.Matrix[0]),Z.Matrix[1].multiplyToRef(Z.Matrix[0],Z.Matrix[0]),N.TranslationToRef(0,0,c,Z.Matrix[1]),Z.Matrix[0].multiplyToRef(Z.Matrix[1],Z.Matrix[0]),N.OrthoOffCenterLHToRef(K,O,F,f,r,l,E,M),Z.Matrix[0].multiplyToRef(E,E),E}static OrthoOffCenterRH(K,O,F,f,r,l,q){const J=new N;return N.OrthoOffCenterRHToRef(K,O,F,f,r,l,J,q),J}static OrthoOffCenterRHToRef(K,O,F,f,r,l,q,J){return N.OrthoOffCenterLHToRef(K,O,F,f,r,l,q,J),q.pf[10]*=-1,q}static ObliqueOffCenterRHToRef(K,O,F,f,r,l,q,J,c,E,M){const t=q*Math.cos(J),j=q*Math.sin(J);return N.TranslationToRef(0,0,c,Z.Matrix[1]),N.FromValuesToRef(1,0,0,0,0,1,0,0,t,j,1,0,0,0,0,1,Z.Matrix[0]),Z.Matrix[1].multiplyToRef(Z.Matrix[0],Z.Matrix[0]),N.TranslationToRef(0,0,-c,Z.Matrix[1]),Z.Matrix[0].multiplyToRef(Z.Matrix[1],Z.Matrix[0]),N.OrthoOffCenterRHToRef(K,O,F,f,r,l,E,M),Z.Matrix[0].multiplyToRef(E,E),E}static PerspectiveLH(K,O,F,f,r){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const q=new N,J=2*F/K,c=2*F/O,E=(f+F)/(f-F),M=-2*f*F/(f-F),t=Math.tan(l);return N.FromValuesToRef(J,0,0,0,0,c,0,t,0,0,E,1,0,0,M,0,q),r&&q.multiplyToRef(d,q),q._updateIdentityStatus(!1),q}static PerspectiveFovLH(K,O,F,f,r){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const J=new N;return N.PerspectiveFovLHToRef(K,O,F,f,J,!0,r,l,q),J}static PerspectiveFovLHToRef(K,O,F,f,r){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const E=F,M=f,t=1/Math.tan(.5*K),j=l?t/O:t,X=l?t:t*O,u=c&&0===E?-1:0!==M?(M+E)/(M-E):1,T=c&&0===E?2*M:0!==M?-2*M*E/(M-E):-2*E,o=Math.tan(J);return N.FromValuesToRef(j,0,0,0,0,X,0,o,0,0,u,1,0,0,T,0,r),q&&r.multiplyToRef(d,r),r._updateIdentityStatus(!1),r}static PerspectiveFovReverseLHToRef(K,O,F,f,r){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const c=1/Math.tan(.5*K),E=l?c/O:c,M=l?c:c*O,t=Math.tan(J);return N.FromValuesToRef(E,0,0,0,0,M,0,t,0,0,-F,1,0,0,1,0,r),q&&r.multiplyToRef(d,r),r._updateIdentityStatus(!1),r}static PerspectiveFovRH(K,O,F,f,r){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const J=new N;return N.PerspectiveFovRHToRef(K,O,F,f,J,!0,r,l,q),J}static PerspectiveFovRHToRef(K,O,F,f,r){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const E=F,M=f,t=1/Math.tan(.5*K),j=l?t/O:t,X=l?t:t*O,u=c&&0===E?1:0!==M?-(M+E)/(M-E):-1,T=c&&0===E?2*M:0!==M?-2*M*E/(M-E):-2*E,o=Math.tan(J);return N.FromValuesToRef(j,0,0,0,0,X,0,o,0,0,u,-1,0,0,T,0,r),q&&r.multiplyToRef(d,r),r._updateIdentityStatus(!1),r}static PerspectiveFovReverseRHToRef(K,O,F,f,r){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const c=1/Math.tan(.5*K),E=l?c/O:c,M=l?c:c*O,t=Math.tan(J);return N.FromValuesToRef(E,0,0,0,0,M,0,t,0,0,-F,-1,0,0,-1,0,r),q&&r.multiplyToRef(d,r),r._updateIdentityStatus(!1),r}static GetFinalMatrix(K,O,F,f,r,l){const q=K.width,J=K.height,c=K.x,E=K.y,M=N.FromValues(q/2,0,0,0,0,-J/2,0,0,0,0,l-r,0,c+q/2,J/2+E,r,1),t=new N;return O.multiplyToRef(F,t),t.multiplyToRef(f,t),t.multiplyToRef(M,t)}static GetAsMatrix2x2(K){const O=K.m,F=[O[0],O[1],O[4],O[5]];return q.e.MatrixUse64Bits?F:new Float32Array(F)}static GetAsMatrix3x3(K){const O=K.m,F=[O[0],O[1],O[2],O[4],O[5],O[6],O[8],O[9],O[10]];return q.e.MatrixUse64Bits?F:new Float32Array(F)}static Transpose(K){const O=new N;return N.TransposeToRef(K,O),O}static TransposeToRef(K,O){const F=K.m,f=F[0],r=F[4],l=F[8],q=F[12],J=F[1],c=F[5],E=F[9],M=F[13],t=F[2],j=F[6],X=F[10],u=F[14],T=F[3],o=F[7],k=F[11],N=F[15],Z=O.pf;return Z[0]=f,Z[1]=r,Z[2]=l,Z[3]=q,Z[4]=J,Z[5]=c,Z[6]=E,Z[7]=M,Z[8]=t,Z[9]=j,Z[10]=X,Z[11]=u,Z[12]=T,Z[13]=o,Z[14]=k,Z[15]=N,O.markAsUpdated(),O._updateIdentityStatus(K._isIdentity,K._isIdentityDirty),O}static Reflection(K){const O=new N;return N.ReflectionToRef(K,O),O}static ReflectionToRef(K,O){K.normalize();const F=K.normal.x,f=K.normal.y,r=K.normal.z,l=-2*F,q=-2*f,J=-2*r;return N.FromValuesToRef(l*F+1,q*F,J*F,0,l*f,q*f+1,J*f,0,l*r,q*r,J*r+1,0,l*K.d,q*K.d,J*K.d,1,O),O}static FromXYZAxesToRef(K,O,F,f){return N.FromValuesToRef(K._x,K._y,K._z,0,O._x,O._y,O._z,0,F._x,F._y,F._z,0,0,0,0,1,f),f}static FromQuaternionToRef(K,O){const F=K._x*K._x,f=K._y*K._y,r=K._z*K._z,l=K._x*K._y,q=K._z*K._w,J=K._z*K._x,c=K._y*K._w,E=K._y*K._z,M=K._x*K._w;return O.pf[0]=1-2*(f+r),O.pf[1]=2*(l+q),O.pf[2]=2*(J-c),O.pf[3]=0,O.pf[4]=2*(l-q),O.pf[5]=1-2*(r+F),O.pf[6]=2*(E+M),O.pf[7]=0,O.pf[8]=2*(J+c),O.pf[9]=2*(E-M),O.pf[10]=1-2*(f+F),O.pf[11]=0,O.pf[12]=0,O.pf[13]=0,O.pf[14]=0,O.pf[15]=1,O.markAsUpdated(),O}}N._IdentityReadOnly=N.Identity(),Object.defineProperties(N.prototype,{dimension:{value:[4,4]},rank:{value:2}});class Z{}Z.TO=(0,r.d)(11,T.Zero),Z.Matrix=(0,r.d)(2,N.Identity),Z.Quaternion=(0,r.d)(3,k.Zero);class L{}L.Vector2=(0,r.d)(3,u.Zero),L.TO=(0,r.d)(13,T.Zero),L.Vector4=(0,r.d)(3,o.Zero),L.Quaternion=(0,r.d)(3,k.Zero),L.Matrix=(0,r.d)(8,N.Identity),(0,l.g)("BABYLON.Vector2",u),(0,l.g)("BABYLON.Vector3",T),(0,l.g)("BABYLON.Vector4",o),(0,l.g)("BABYLON.Matrix",N);const d=N.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11729:(K,O,F)=>{function f(K,O){const F=[];for(let f=0;f<K;++f)F.push(O());return F}function r(K,O){return f(K,O)}F.d(O,{c:()=>f,d:()=>r,g:()=>q});const l=["push","splice","pop","shift","unshift"];function q(K,O){const F=l.map((F=>function(K,O,F){const f=K[O];if("function"!==typeof f)return null;const r=function(){const f=K.length,l=r.previous.apply(K,arguments);return F(O,f),l};return f.next=r,r.previous=f,K[O]=r,()=>{const F=r.previous;if(!F)return;const f=r.next;f?(F.next=f,f.previous=F):(F.next=void 0,K[O]=F),r.next=void 0,r.previous=void 0}}(K,F,O)));return()=>{for(const K of F)null===K||void 0===K||K()}}}}]);