"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[14],{12425:(V,h,mV)=>{mV.d(h,{c:()=>A,d:()=>N,g:()=>t,j:()=>L});const t=1/2.2,L=2.2,N=(1+Math.sqrt(5))/2,A=.001},12435:(V,h,mV)=>{function t(V){return parseInt(V.toString().replace(/\W/g,""))}function L(V,h){let mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(V-h)<=mV}function N(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return V<h-t||V>mV+t}function A(V,h){return V===h?V:Math.random()*(h-V)+V}function k(V,h,mV){return V+(h-V)*mV}function C(V,h,mV){let t=s(h-V,360);return t>180&&(t-=360),V+t*q(mV)}function K(V,h,mV){let t=0;return t=V!=h?q((mV-V)/(h-V)):0,t}function o(V,h,mV,t,L){const N=L*L,A=L*N;return V*(2*A-3*N+1)+mV*(-2*A+3*N)+h*(A-2*N+L)+t*(A-N)}function n(V,h,mV,t,L){const N=L*L;return 6*(N-L)*V+(3*N-4*L+1)*h+6*(-N+L)*mV+(3*N-2*L)*t}function q(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(mV,Math.max(h,V))}function x(V){return V-=2*Math.PI*Math.floor((V+Math.PI)/(2*Math.PI))}function R(V){const h=V.toString(16);return V<=15?("0"+h).toUpperCase():h.toUpperCase()}function d(V){if(Math.log2)return Math.floor(Math.log2(V));if(V<0)return NaN;if(0===V)return-1/0;let h=0;if(V<1){for(;V<1;)h++,V*=2;h=-h}else if(V>1)for(;V>1;)h++,V=Math.floor(V/2);return h}function s(V,h){return V-Math.floor(V/h)*h}function M(V,h,mV){return(V-h)/(mV-h)}function c(V,h,mV){return V*(mV-h)+h}function z(V,h){let mV=s(h-V,360);return mV>180&&(mV-=360),mV}function Q(V,h){const mV=s(V,2*h);return h-Math.abs(mV-h)}function J(V,h,mV){let t=q(mV);return t=-2*t*t*t+3*t*t,h*t+V*(1-t)}function v(V,h,mV){let t=0;return t=Math.abs(h-V)<=mV?h:V+Math.sign(h-V)*mV,t}function D(V,h,mV){const t=z(V,h);let L=0;return L=-mV<t&&t<mV?h:v(V,h=V+t,mV),L}function H(V,h,mV){return(V-h)/(mV-h)}function j(V,h,mV){return(mV-h)*V+h}function l(V,h){const mV=V%h;return 0===mV?h:l(h,mV)}mV.r(h),mV.d(h,{Clamp:()=>q,DeltaAngle:()=>z,Denormalize:()=>c,ExtractAsInt:()=>t,Hermite:()=>o,Hermite1stDerivative:()=>n,HighestCommonFactor:()=>l,ILog2:()=>d,InverseLerp:()=>K,Lerp:()=>k,LerpAngle:()=>C,MoveTowards:()=>v,MoveTowardsAngle:()=>D,Normalize:()=>M,NormalizeRadians:()=>x,OutsideRange:()=>N,PercentToRange:()=>j,PingPong:()=>Q,RandomRange:()=>A,RangeToPercent:()=>H,Repeat:()=>s,SmoothStep:()=>J,ToHex:()=>R,WithinEpsilon:()=>L})},12422:(V,h,mV)=>{mV.r(h),mV.d(h,{Matrix:()=>c,Quaternion:()=>M,TmpVectors:()=>Q,Vector2:()=>R,sh:()=>d,Vector4:()=>s});var t=mV(12425),L=mV(12433),N=mV(12388),A=mV(12352),k=mV(12300),C=mV(12435);class K{}function o(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const L=V.sk(),N=h.sk(),A=L[0],k=L[1],C=L[2],K=L[3],o=L[4],n=L[5],q=L[6],x=L[7],R=L[8],d=L[9],s=L[10],M=L[11],c=L[12],z=L[13],Q=L[14],J=L[15],v=N[0],D=N[1],H=N[2],j=N[3],l=N[4],G=N[5],y=N[6],O=N[7],I=N[8],r=N[9],T=N[10],F=N[11],p=N[12],Z=N[13],f=N[14],S=N[15];mV[t]=A*v+k*l+C*I+K*p,mV[t+1]=A*D+k*G+C*r+K*Z,mV[t+2]=A*H+k*y+C*T+K*f,mV[t+3]=A*j+k*O+C*F+K*S,mV[t+4]=o*v+n*l+q*I+x*p,mV[t+5]=o*D+n*G+q*r+x*Z,mV[t+6]=o*H+n*y+q*T+x*f,mV[t+7]=o*j+n*O+q*F+x*S,mV[t+8]=R*v+d*l+s*I+M*p,mV[t+9]=R*D+d*G+s*r+M*Z,mV[t+10]=R*H+d*y+s*T+M*f,mV[t+11]=R*j+d*O+s*F+M*S,mV[t+12]=c*v+z*l+Q*I+J*p,mV[t+13]=c*D+z*G+Q*r+J*Z,mV[t+14]=c*H+z*y+Q*T+J*f,mV[t+15]=c*j+z*O+Q*F+J*S}function n(V,h){let mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const t=V.sk();h[mV]=t[0],h[mV+1]=t[1],h[mV+2]=t[2],h[mV+3]=t[3],h[mV+4]=t[4],h[mV+5]=t[5],h[mV+6]=t[6],h[mV+7]=t[7],h[mV+8]=t[8],h[mV+9]=t[9],h[mV+10]=t[10],h[mV+11]=t[11],h[mV+12]=t[12],h[mV+13]=t[13],h[mV+14]=t[14],h[mV+15]=t[15]}function q(V,h){const mV=V.sk(),t=mV[0],L=mV[1],N=mV[2],A=mV[3],k=mV[4],C=mV[5],K=mV[6],o=mV[7],n=mV[8],q=mV[9],x=mV[10],R=mV[11],d=mV[12],s=mV[13],M=mV[14],c=mV[15],z=x*c-M*R,Q=q*c-s*R,J=q*M-s*x,v=n*c-d*R,D=n*M-x*d,H=n*s-d*q,j=+(C*z-K*Q+o*J),l=-(k*z-K*v+o*D),G=+(k*Q-C*v+o*H),y=-(k*J-C*D+K*H),O=t*j+L*l+N*G+A*y;if(0===O)return!1;const I=1/O,r=K*c-M*o,T=C*c-s*o,F=C*M-s*K,p=k*c-d*o,Z=k*M-d*K,f=k*s-d*C,S=K*R-x*o,Y=C*R-q*o,w=C*x-q*K,E=k*R-n*o,g=k*x-n*K,i=k*q-n*C,b=-(L*z-N*Q+A*J),P=+(t*z-N*v+A*D),U=-(t*Q-L*v+A*H),u=+(t*J-L*D+N*H),e=+(L*r-N*T+A*F),W=-(t*r-N*p+A*Z),X=+(t*T-L*p+A*f),a=-(t*F-L*Z+N*f),B=-(L*S-N*Y+A*w),VV=+(t*S-N*E+A*g),hV=-(t*Y-L*E+A*i),mh=+(t*w-L*g+N*i);return h[0]=j*I,h[1]=b*I,h[2]=e*I,h[3]=B*I,h[4]=l*I,h[5]=P*I,h[6]=W*I,h[7]=VV*I,h[8]=G*I,h[9]=U*I,h[10]=X*I,h[11]=hV*I,h[12]=y*I,h[13]=u*I,h[14]=a*I,h[15]=mh*I,!0}K._UpdateFlagSeed=0;const x=V=>parseInt(V.toString().replace(/\W/g,""));class R{constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=V,this.y=h}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let V=x(this.x);return V=397*V^x(this.y),V}toArray(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V[h]=this.x,V[h+1]=this.y,this}Dm(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R.FromArrayToRef(V,h,this),this}sk(){return[this.x,this.y]}t(V){return this.x=V.x,this.y=V.y,this}Hk(V,h){return this.x=V,this.y=h,this}set(V,h){return this.Hk(V,h)}lk(V){return this.Hk(V,V)}add(V){return new R(this.x+V.x,this.y+V.y)}addToRef(V,h){return h.x=this.x+V.x,h.y=this.y+V.y,h}addInPlace(V){return this.x+=V.x,this.y+=V.y,this}addInPlaceFromFloats(V,h){return this.x+=V,this.y+=h,this}addVector3(V){return new R(this.x+V.x,this.y+V.y)}Mh(V){return new R(this.x-V.x,this.y-V.y)}subtractToRef(V,h){return h.x=this.x-V.x,h.y=this.y-V.y,h}An(V){return this.x-=V.x,this.y-=V.y,this}multiplyInPlace(V){return this.x*=V.x,this.y*=V.y,this}multiply(V){return new R(this.x*V.x,this.y*V.y)}multiplyToRef(V,h){return h.x=this.x*V.x,h.y=this.y*V.y,h}multiplyByFloats(V,h){return new R(this.x*V,this.y*h)}divide(V){return new R(this.x/V.x,this.y/V.y)}divideToRef(V,h){return h.x=this.x/V.x,h.y=this.y/V.y,h}divideInPlace(V){return this.x=this.x/V.x,this.y=this.y/V.y,this}minimizeInPlace(V){return this.minimizeInPlaceFromFloats(V.x,V.y)}maximizeInPlace(V){return this.maximizeInPlaceFromFloats(V.x,V.y)}minimizeInPlaceFromFloats(V,h){return this.x=Math.min(V,this.x),this.y=Math.min(h,this.y),this}maximizeInPlaceFromFloats(V,h){return this.x=Math.max(V,this.x),this.y=Math.max(h,this.y),this}subtractFromFloats(V,h){return new R(this.x-V,this.y-h)}subtractFromFloatsToRef(V,h,mV){return mV.x=this.x-V,mV.y=this.y-h,mV}negate(){return new R(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(V){return V.x=-this.x,V.y=-this.y,V}scaleInPlace(V){return this.x*=V,this.y*=V,this}scale(V){return new R(this.x*V,this.y*V)}scaleToRef(V,h){return h.x=this.x*V,h.y=this.y*V,h}scaleAndAddToRef(V,h){return h.x+=this.x*V,h.y+=this.y*V,h}equals(V){return V&&this.x===V.x&&this.y===V.y}equalsWithEpsilon(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.c;return V&&(0,C.WithinEpsilon)(this.x,V.x,h)&&(0,C.WithinEpsilon)(this.y,V.y,h)}equalsToFloats(V,h){return this.x===V&&this.y===h}floor(){return new R(Math.floor(this.x),Math.floor(this.y))}floorToRef(V){return V.x=Math.floor(this.x),V.y=Math.floor(this.y),V}fract(){return new R(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(V){return V.x=this.x-Math.floor(this.x),V.y=this.y-Math.floor(this.y),V}rotate(V){return this.rotateToRef(V,new R)}rotateToRef(V,h){const mV=Math.cos(V),t=Math.sin(V);return h.x=mV*this.x-t*this.y,h.y=t*this.x+mV*this.y,h}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(V){return 0===V||1===V?this:this.scaleInPlace(1/V)}normalizeToNew(){const V=new R;return this.normalizeToRef(V),V}normalizeToRef(V){const h=this.length();return 0===h&&(V.x=this.x,V.y=this.y),this.scaleToRef(1/h,V)}clone(){return new R(this.x,this.y)}dot(V){return this.x*V.x+this.y*V.y}static Zero(){return new R(0,0)}static One(){return new R(1,1)}static Random(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new R((0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h))}static RandomToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Hk((0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h))}static get ZeroReadOnly(){return R._ZeroReadOnly}static Dh(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new R(V[h],V[h+1])}static FromArrayToRef(V,h,mV){return mV.x=V[h],mV.y=V[h+1],mV}static FromFloatsToRef(V,h,mV){return mV.Hk(V,h),mV}static CatmullRom(V,h,mV,t,L){const N=L*L,A=L*N,k=.5*(2*h.x+(-V.x+mV.x)*L+(2*V.x-5*h.x+4*mV.x-t.x)*N+(-V.x+3*h.x-3*mV.x+t.x)*A),C=.5*(2*h.y+(-V.y+mV.y)*L+(2*V.y-5*h.y+4*mV.y-t.y)*N+(-V.y+3*h.y-3*mV.y+t.y)*A);return new R(k,C)}static ClampToRef(V,h,mV,t){return t.x=(0,C.Clamp)(V.x,h.x,mV.x),t.y=(0,C.Clamp)(V.y,h.y,mV.y),t}static Clamp(V,h,mV){const t=(0,C.Clamp)(V.x,h.x,mV.x),L=(0,C.Clamp)(V.y,h.y,mV.y);return new R(t,L)}static Hermite(V,h,mV,t,L){const N=L*L,A=L*N,k=2*A-3*N+1,C=-2*A+3*N,K=A-2*N+L,o=A-N,n=V.x*k+mV.x*C+h.x*K+t.x*o,q=V.y*k+mV.y*C+h.y*K+t.y*o;return new R(n,q)}static Hermite1stDerivative(V,h,mV,t,L){return this.Hermite1stDerivativeToRef(V,h,mV,t,L,new R)}static Hermite1stDerivativeToRef(V,h,mV,t,L,N){const A=L*L;return N.x=6*(A-L)*V.x+(3*A-4*L+1)*h.x+6*(-A+L)*mV.x+(3*A-2*L)*t.x,N.y=6*(A-L)*V.y+(3*A-4*L+1)*h.y+6*(-A+L)*mV.y+(3*A-2*L)*t.y,N}static Lerp(V,h,mV){return R.LerpToRef(V,h,mV,new R)}static LerpToRef(V,h,mV,t){return t.x=V.x+(h.x-V.x)*mV,t.y=V.y+(h.y-V.y)*mV,t}static Dot(V,h){return V.x*h.x+V.y*h.y}static Normalize(V){return R.NormalizeToRef(V,new R)}static NormalizeToRef(V,h){return V.normalizeToRef(h),h}static Minimize(V,h){const mV=V.x<h.x?V.x:h.x,t=V.y<h.y?V.y:h.y;return new R(mV,t)}static Maximize(V,h){const mV=V.x>h.x?V.x:h.x,t=V.y>h.y?V.y:h.y;return new R(mV,t)}static Transform(V,h){return R.TransformToRef(V,h,new R)}static TransformToRef(V,h,mV){const t=h.m,L=V.x*t[0]+V.y*t[4]+t[12],N=V.x*t[1]+V.y*t[5]+t[13];return mV.x=L,mV.y=N,mV}static PointInTriangle(V,h,mV,t){const L=.5*(-mV.y*t.x+h.y*(-mV.x+t.x)+h.x*(mV.y-t.y)+mV.x*t.y),N=L<0?-1:1,A=(h.y*t.x-h.x*t.y+(t.y-h.y)*V.x+(h.x-t.x)*V.y)*N,k=(h.x*mV.y-h.y*mV.x+(h.y-mV.y)*V.x+(mV.x-h.x)*V.y)*N;return A>0&&k>0&&A+k<2*L*N}static Distance(V,h){return Math.sqrt(R.DistanceSquared(V,h))}static DistanceSquared(V,h){const mV=V.x-h.x,t=V.y-h.y;return mV*mV+t*t}static Center(V,h){return R.CenterToRef(V,h,new R)}static CenterToRef(V,h,mV){return mV.Hk((V.x+h.x)/2,(V.y+h.y)/2)}static DistanceOfPointFromSegment(V,h,mV){const t=R.DistanceSquared(h,mV);if(0===t)return R.Distance(V,h);const L=mV.Mh(h),N=Math.max(0,Math.min(1,R.Dot(V.Mh(h),L)/t)),A=h.add(L.multiplyByFloats(N,N));return R.Distance(V,A)}}R._V8PerformanceHack=new R(.5,.5),R._ZeroReadOnly=R.Zero(),Object.defineProperties(R.prototype,{dimension:{value:[2]},rank:{value:1}});class d{get x(){return this._x}set x(V){this._x=V,this._isDirty=!0}get y(){return this._y}set y(V){this._y=V,this._isDirty=!0}get z(){return this._z}set z(V){this._z=V,this._isDirty=!0}constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=V,this._y=h,this._z=mV}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"sh"}getHashCode(){let V=x(this._x);return V=397*V^x(this._y),V=397*V^x(this._z),V}sk(){return[this._x,this._y,this._z]}toArray(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V[h]=this._x,V[h+1]=this._y,V[h+2]=this._z,this}Dm(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return d.FromArrayToRef(V,h,this),this}toQuaternion(){return M.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(V){return this._x+=V._x,this._y+=V._y,this._z+=V._z,this._isDirty=!0,this}addInPlaceFromFloats(V,h,mV){return this._x+=V,this._y+=h,this._z+=mV,this._isDirty=!0,this}add(V){return new d(this._x+V._x,this._y+V._y,this._z+V._z)}addToRef(V,h){return h._x=this._x+V._x,h._y=this._y+V._y,h._z=this._z+V._z,h._isDirty=!0,h}An(V){return this._x-=V._x,this._y-=V._y,this._z-=V._z,this._isDirty=!0,this}Mh(V){return new d(this._x-V._x,this._y-V._y,this._z-V._z)}subtractToRef(V,h){return this.subtractFromFloatsToRef(V._x,V._y,V._z,h)}subtractFromFloats(V,h,mV){return new d(this._x-V,this._y-h,this._z-mV)}subtractFromFloatsToRef(V,h,mV,t){return t._x=this._x-V,t._y=this._y-h,t._z=this._z-mV,t._isDirty=!0,t}negate(){return new d(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(V){return V._x=-1*this._x,V._y=-1*this._y,V._z=-1*this._z,V._isDirty=!0,V}scaleInPlace(V){return this._x*=V,this._y*=V,this._z*=V,this._isDirty=!0,this}scale(V){return new d(this._x*V,this._y*V,this._z*V)}scaleToRef(V,h){return h._x=this._x*V,h._y=this._y*V,h._z=this._z*V,h._isDirty=!0,h}getNormalToRef(V){const h=this.length();let mV=Math.acos(this._y/h);const t=Math.atan2(this._z,this._x);mV>Math.PI/2?mV-=Math.PI/2:mV+=Math.PI/2;const L=h*Math.sin(mV)*Math.cos(t),N=h*Math.cos(mV),A=h*Math.sin(mV)*Math.sin(t);return V.set(L,N,A),V}applyRotationQuaternionToRef(V,h){const mV=this._x,t=this._y,L=this._z,N=V._x,A=V._y,k=V._z,C=V._w,K=2*(A*L-k*t),o=2*(k*mV-N*L),n=2*(N*t-A*mV);return h._x=mV+C*K+A*n-k*o,h._y=t+C*o+k*K-N*n,h._z=L+C*n+N*o-A*K,h._isDirty=!0,h}applyRotationQuaternionInPlace(V){return this.applyRotationQuaternionToRef(V,this)}applyRotationQuaternion(V){return this.applyRotationQuaternionToRef(V,new d)}scaleAndAddToRef(V,h){return h._x+=this._x*V,h._y+=this._y*V,h._z+=this._z*V,h._isDirty=!0,h}projectOnPlane(V,h){return this.projectOnPlaneToRef(V,h,new d)}projectOnPlaneToRef(V,h,mV){const t=V.normal,L=V.d,N=z.sh[0];this.subtractToRef(h,N),N.normalize();const A=d.Dot(N,t);if(Math.abs(A)<1e-10)mV.lk(1/0);else{const V=-(d.Dot(h,t)+L)/A,k=N.scaleInPlace(V);h.addToRef(k,mV)}return mV}equals(V){return V&&this._x===V._x&&this._y===V._y&&this._z===V._z}equalsWithEpsilon(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.c;return V&&(0,C.WithinEpsilon)(this._x,V._x,h)&&(0,C.WithinEpsilon)(this._y,V._y,h)&&(0,C.WithinEpsilon)(this._z,V._z,h)}equalsToFloats(V,h,mV){return this._x===V&&this._y===h&&this._z===mV}multiplyInPlace(V){return this._x*=V._x,this._y*=V._y,this._z*=V._z,this._isDirty=!0,this}multiply(V){return this.multiplyByFloats(V._x,V._y,V._z)}multiplyToRef(V,h){return h._x=this._x*V._x,h._y=this._y*V._y,h._z=this._z*V._z,h._isDirty=!0,h}multiplyByFloats(V,h,mV){return new d(this._x*V,this._y*h,this._z*mV)}divide(V){return new d(this._x/V._x,this._y/V._y,this._z/V._z)}divideToRef(V,h){return h._x=this._x/V._x,h._y=this._y/V._y,h._z=this._z/V._z,h._isDirty=!0,h}divideInPlace(V){return this._x=this._x/V._x,this._y=this._y/V._y,this._z=this._z/V._z,this._isDirty=!0,this}minimizeInPlace(V){return this.minimizeInPlaceFromFloats(V._x,V._y,V._z)}maximizeInPlace(V){return this.maximizeInPlaceFromFloats(V._x,V._y,V._z)}minimizeInPlaceFromFloats(V,h,mV){return V<this._x&&(this.x=V),h<this._y&&(this.y=h),mV<this._z&&(this.z=mV),this}maximizeInPlaceFromFloats(V,h,mV){return V>this._x&&(this.x=V),h>this._y&&(this.y=h),mV>this._z&&(this.z=mV),this}isNonUniformWithinEpsilon(V){const h=Math.abs(this._x),mV=Math.abs(this._y);if(!(0,C.WithinEpsilon)(h,mV,V))return!0;const t=Math.abs(this._z);return!(0,C.WithinEpsilon)(h,t,V)||!(0,C.WithinEpsilon)(mV,t,V)}get isNonUniform(){const V=Math.abs(this._x);if(V!==Math.abs(this._y))return!0;return V!==Math.abs(this._z)}floorToRef(V){return V._x=Math.floor(this._x),V._y=Math.floor(this._y),V._z=Math.floor(this._z),V._isDirty=!0,V}floor(){return new d(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(V){return V._x=this._x-Math.floor(this._x),V._y=this._y-Math.floor(this._y),V._z=this._z-Math.floor(this._z),V._isDirty=!0,V}fract(){return new d(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(V){if("xyz"===(V=V.toLowerCase()))return this;const h=z.sh[0].t(this);return this.x=h[V[0]],this.y=h[V[1]],this.z=h[V[2]],this}rotateByQuaternionToRef(V,h){return V.toRotationMatrix(z.Matrix[0]),d.TransformCoordinatesToRef(this,z.Matrix[0],h),h}rotateByQuaternionAroundPointToRef(V,h,mV){return this.subtractToRef(h,z.sh[0]),z.sh[0].rotateByQuaternionToRef(V,z.sh[0]),h.addToRef(z.sh[0],mV),mV}cross(V){return d.CrossToRef(this,V,new d)}normalizeFromLength(V){return 0===V||1===V?this:this.scaleInPlace(1/V)}normalizeToNew(){return this.normalizeToRef(new d)}normalizeToRef(V){const h=this.length();return 0===h||1===h?(V._x=this._x,V._y=this._y,V._z=this._z,V._isDirty=!0,V):this.scaleToRef(1/h,V)}clone(){return new d(this._x,this._y,this._z)}t(V){return this.Hk(V._x,V._y,V._z)}Hk(V,h,mV){return this._x=V,this._y=h,this._z=mV,this._isDirty=!0,this}set(V,h,mV){return this.Hk(V,h,mV)}lk(V){return this._x=this._y=this._z=V,this._isDirty=!0,this}static GetClipFactor(V,h,mV,t){const L=d.Dot(V,mV);return(L-t)/(L-d.Dot(h,mV))}static GetAngleBetweenVectors(V,h,mV){const t=V.normalizeToRef(z.sh[1]),L=h.normalizeToRef(z.sh[2]);let N=d.Dot(t,L);N=(0,C.Clamp)(N,-1,1);const A=Math.acos(N),k=z.sh[3];return d.CrossToRef(t,L,k),d.Dot(k,mV)>0?isNaN(A)?0:A:isNaN(A)?-Math.PI:-Math.acos(N)}static GetAngleBetweenVectorsOnPlane(V,h,mV){z.sh[0].t(V);const t=z.sh[0];z.sh[1].t(h);const L=z.sh[1];z.sh[2].t(mV);const N=z.sh[2],A=z.sh[3],k=z.sh[4];t.normalize(),L.normalize(),N.normalize(),d.CrossToRef(N,t,A),d.CrossToRef(A,N,k);const K=Math.atan2(d.Dot(L,A),d.Dot(L,k));return(0,C.NormalizeRadians)(K)}static PitchYawRollToMoveBetweenPointsToRef(V,h,mV){const t=Q.sh[0];return h.subtractToRef(V,t),mV._y=Math.atan2(t.x,t.z)||0,mV._x=Math.atan2(Math.sqrt(t.x**2+t.z**2),t.y)||0,mV._z=0,mV._isDirty=!0,mV}static PitchYawRollToMoveBetweenPoints(V,h){const mV=d.Zero();return d.PitchYawRollToMoveBetweenPointsToRef(V,h,mV)}static SlerpToRef(V,h,mV,L){mV=(0,C.Clamp)(mV,0,1);const N=z.sh[0],A=z.sh[1];N.t(V);const k=N.length();N.normalizeFromLength(k),A.t(h);const K=A.length();A.normalizeFromLength(K);const o=d.Dot(N,A);let n,q;if(o<1-t.c){const V=Math.acos(o),h=1/Math.sin(V);n=Math.sin((1-mV)*V)*h,q=Math.sin(mV*V)*h}else n=1-mV,q=mV;return N.scaleInPlace(n),A.scaleInPlace(q),L.t(N).addInPlace(A),L.scaleInPlace((0,C.Lerp)(k,K,mV)),L}static SmoothToRef(V,h,mV,t,L){return d.SlerpToRef(V,h,0===t?1:mV/t,L),L}static Dh(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new d(V[h],V[h+1],V[h+2])}static FromFloatArray(V,h){return d.Dh(V,h)}static FromArrayToRef(V,h,mV){return mV._x=V[h],mV._y=V[h+1],mV._z=V[h+2],mV._isDirty=!0,mV}static FromFloatArrayToRef(V,h,mV){return d.FromArrayToRef(V,h,mV)}static FromFloatsToRef(V,h,mV,t){return t.Hk(V,h,mV),t}static Zero(){return new d(0,0,0)}static One(){return new d(1,1,1)}static Up(){return new d(0,1,0)}static get UpReadOnly(){return d._UpReadOnly}static get DownReadOnly(){return d._DownReadOnly}static get RightReadOnly(){return d._RightReadOnly}static get LeftReadOnly(){return d._LeftReadOnly}static get LeftHandedForwardReadOnly(){return d._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return d._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return d._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return d._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return d._ZeroReadOnly}static get OneReadOnly(){return d._OneReadOnly}static Down(){return new d(0,-1,0)}static Forward(){return new d(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new d(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new d(1,0,0)}static Left(){return new d(-1,0,0)}static Random(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new d((0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h))}static RandomToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Hk((0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h))}static TransformCoordinates(V,h){const mV=d.Zero();return d.TransformCoordinatesToRef(V,h,mV),mV}static TransformCoordinatesToRef(V,h,mV){return d.TransformCoordinatesFromFloatsToRef(V._x,V._y,V._z,h,mV),mV}static TransformCoordinatesFromFloatsToRef(V,h,mV,t,L){const N=t.m,A=V*N[0]+h*N[4]+mV*N[8]+N[12],k=V*N[1]+h*N[5]+mV*N[9]+N[13],C=V*N[2]+h*N[6]+mV*N[10]+N[14],K=1/(V*N[3]+h*N[7]+mV*N[11]+N[15]);return L._x=A*K,L._y=k*K,L._z=C*K,L._isDirty=!0,L}static TransformNormal(V,h){const mV=d.Zero();return d.TransformNormalToRef(V,h,mV),mV}static TransformNormalToRef(V,h,mV){return this.TransformNormalFromFloatsToRef(V._x,V._y,V._z,h,mV),mV}static TransformNormalFromFloatsToRef(V,h,mV,t,L){const N=t.m;return L._x=V*N[0]+h*N[4]+mV*N[8],L._y=V*N[1]+h*N[5]+mV*N[9],L._z=V*N[2]+h*N[6]+mV*N[10],L._isDirty=!0,L}static CatmullRom(V,h,mV,t,L){const N=L*L,A=L*N,k=.5*(2*h._x+(-V._x+mV._x)*L+(2*V._x-5*h._x+4*mV._x-t._x)*N+(-V._x+3*h._x-3*mV._x+t._x)*A),C=.5*(2*h._y+(-V._y+mV._y)*L+(2*V._y-5*h._y+4*mV._y-t._y)*N+(-V._y+3*h._y-3*mV._y+t._y)*A),K=.5*(2*h._z+(-V._z+mV._z)*L+(2*V._z-5*h._z+4*mV._z-t._z)*N+(-V._z+3*h._z-3*mV._z+t._z)*A);return new d(k,C,K)}static Clamp(V,h,mV){const t=new d;return d.ClampToRef(V,h,mV,t),t}static ClampToRef(V,h,mV,t){let L=V._x;L=L>mV._x?mV._x:L,L=L<h._x?h._x:L;let N=V._y;N=N>mV._y?mV._y:N,N=N<h._y?h._y:N;let A=V._z;return A=A>mV._z?mV._z:A,A=A<h._z?h._z:A,t.Hk(L,N,A),t}static CheckExtends(V,h,mV){h.minimizeInPlace(V),mV.maximizeInPlace(V)}static Hermite(V,h,mV,t,L){const N=L*L,A=L*N,k=2*A-3*N+1,C=-2*A+3*N,K=A-2*N+L,o=A-N,n=V._x*k+mV._x*C+h._x*K+t._x*o,q=V._y*k+mV._y*C+h._y*K+t._y*o,x=V._z*k+mV._z*C+h._z*K+t._z*o;return new d(n,q,x)}static Hermite1stDerivative(V,h,mV,t,L){const N=new d;return this.Hermite1stDerivativeToRef(V,h,mV,t,L,N),N}static Hermite1stDerivativeToRef(V,h,mV,t,L,N){const A=L*L;return N._x=6*(A-L)*V._x+(3*A-4*L+1)*h._x+6*(-A+L)*mV._x+(3*A-2*L)*t._x,N._y=6*(A-L)*V._y+(3*A-4*L+1)*h._y+6*(-A+L)*mV._y+(3*A-2*L)*t._y,N._z=6*(A-L)*V._z+(3*A-4*L+1)*h._z+6*(-A+L)*mV._z+(3*A-2*L)*t._z,N._isDirty=!0,N}static Lerp(V,h,mV){const t=new d(0,0,0);return d.LerpToRef(V,h,mV,t),t}static LerpToRef(V,h,mV,t){return t._x=V._x+(h._x-V._x)*mV,t._y=V._y+(h._y-V._y)*mV,t._z=V._z+(h._z-V._z)*mV,t._isDirty=!0,t}static Dot(V,h){return V._x*h._x+V._y*h._y+V._z*h._z}dot(V){return this._x*V._x+this._y*V._y+this._z*V._z}static Cross(V,h){const mV=new d;return d.CrossToRef(V,h,mV),mV}static CrossToRef(V,h,mV){const t=V._y*h._z-V._z*h._y,L=V._z*h._x-V._x*h._z,N=V._x*h._y-V._y*h._x;return mV.Hk(t,L,N),mV}static Normalize(V){const h=d.Zero();return d.NormalizeToRef(V,h),h}static NormalizeToRef(V,h){return V.normalizeToRef(h),h}static Project(V,h,mV,t){const L=new d;return d.ProjectToRef(V,h,mV,t,L),L}static ProjectToRef(V,h,mV,t,L){var N;const A=t.width,C=t.height,K=t.x,o=t.y,n=z.Matrix[1],q=null===(N=k.b.LastCreatedEngine)||void 0===N?void 0:N.isNDCHalfZRange,x=q?1:.5,R=q?0:.5;c.FromValuesToRef(A/2,0,0,0,0,-C/2,0,0,0,0,x,0,K+A/2,C/2+o,R,1,n);const s=z.Matrix[0];return h.multiplyToRef(mV,s),s.multiplyToRef(n,s),d.TransformCoordinatesToRef(V,s,L),L}static Reflect(V,h){return this.ReflectToRef(V,h,new d)}static ReflectToRef(V,h,mV){const t=Q.sh[0];return t.t(h).scaleInPlace(2*d.Dot(V,h)),mV.t(V).An(t)}static _UnprojectFromInvertedMatrixToRef(V,h,mV){d.TransformCoordinatesToRef(V,h,mV);const t=h.m,L=V._x*t[3]+V._y*t[7]+V._z*t[11]+t[15];return(0,C.WithinEpsilon)(L,1)&&mV.scaleInPlace(1/L),mV}static UnprojectFromTransform(V,h,mV,t,L){return this.Unproject(V,h,mV,t,L,c.IdentityReadOnly)}static Unproject(V,h,mV,t,L,N){const A=new d;return d.UnprojectToRef(V,h,mV,t,L,N,A),A}static UnprojectToRef(V,h,mV,t,L,N,A){return d.UnprojectFloatsToRef(V._x,V._y,V._z,h,mV,t,L,N,A),A}static UnprojectFloatsToRef(V,h,mV,t,L,N,A,C,K){var o;const n=z.Matrix[0];N.multiplyToRef(A,n),n.multiplyToRef(C,n),n.invert();const q=z.sh[0];return q.x=V/t*2-1,q.y=-(h/L*2-1),null!==(o=k.b.LastCreatedEngine)&&void 0!==o&&o.isNDCHalfZRange?q.z=mV:q.z=2*mV-1,d._UnprojectFromInvertedMatrixToRef(q,n,K),K}static Minimize(V,h){const mV=new d;return mV.t(V),mV.minimizeInPlace(h),mV}static Maximize(V,h){const mV=new d;return mV.t(V),mV.maximizeInPlace(h),mV}static Distance(V,h){return Math.sqrt(d.DistanceSquared(V,h))}static DistanceSquared(V,h){const mV=V._x-h._x,t=V._y-h._y,L=V._z-h._z;return mV*mV+t*t+L*L}static ProjectOnTriangleToRef(V,h,mV,L,N){const A=z.sh[0],k=z.sh[1],K=z.sh[2],o=z.sh[3],n=z.sh[4];mV.subtractToRef(h,A),L.subtractToRef(h,k),L.subtractToRef(mV,K);const q=A.length(),x=k.length(),R=K.length();if(q<t.c||x<t.c||R<t.c)return N.t(h),d.Distance(V,h);V.subtractToRef(h,n),d.CrossToRef(A,k,o);const s=o.length();if(s<t.c)return N.t(h),d.Distance(V,h);o.normalizeFromLength(s);let M=n.length();if(M<t.c)return N.t(h),0;n.normalizeFromLength(M);const c=d.Dot(o,n),Q=z.sh[5],J=z.sh[6];Q.t(o).scaleInPlace(-M*c),J.t(V).addInPlace(Q);const v=z.sh[4],D=z.sh[5],H=z.sh[7],j=z.sh[8];v.t(A).scaleInPlace(1/q),j.t(k).scaleInPlace(1/x),v.addInPlace(j).scaleInPlace(-1),D.t(A).scaleInPlace(-1/q),j.t(K).scaleInPlace(1/R),D.addInPlace(j).scaleInPlace(-1),H.t(K).scaleInPlace(-1/R),j.t(k).scaleInPlace(-1/x),H.addInPlace(j).scaleInPlace(-1);const l=z.sh[9];let G;l.t(J).An(h),d.CrossToRef(v,l,j),G=d.Dot(j,o);const y=G;l.t(J).An(mV),d.CrossToRef(D,l,j),G=d.Dot(j,o);const O=G;l.t(J).An(L),d.CrossToRef(H,l,j),G=d.Dot(j,o);const I=G,r=z.sh[10];let T,F;y>0&&O<0?(r.t(A),T=h,F=mV):O>0&&I<0?(r.t(K),T=mV,F=L):(r.t(k).scaleInPlace(-1),T=L,F=h);const p=z.sh[9],Z=z.sh[4];T.subtractToRef(J,j),F.subtractToRef(J,p),d.CrossToRef(j,p,Z);if(!(d.Dot(Z,o)<0))return N.t(J),Math.abs(M*c);const f=z.sh[5];d.CrossToRef(r,Z,f),f.normalize();const S=z.sh[9];S.t(T).An(J);const Y=S.length();if(Y<t.c)return N.t(T),d.Distance(V,T);S.normalizeFromLength(Y);const w=d.Dot(f,S),E=z.sh[7];E.t(J).addInPlace(f.scaleInPlace(Y*w)),j.t(E).An(T),M=r.length(),r.normalizeFromLength(M);let g=d.Dot(j,r)/Math.max(M,t.c);return g=(0,C.Clamp)(g,0,1),E.t(T).addInPlace(r.scaleInPlace(g*M)),N.t(E),d.Distance(V,E)}static Center(V,h){return d.CenterToRef(V,h,d.Zero())}static CenterToRef(V,h,mV){return mV.Hk((V._x+h._x)/2,(V._y+h._y)/2,(V._z+h._z)/2)}static RotationFromAxis(V,h,mV){const t=new d;return d.RotationFromAxisToRef(V,h,mV,t),t}static RotationFromAxisToRef(V,h,mV,t){const L=z.Quaternion[0];return M.RotationQuaternionFromAxisToRef(V,h,mV,L),L.toEulerAnglesToRef(t),t}}d._V8PerformanceHack=new d(.5,.5,.5),d._UpReadOnly=d.Up(),d._DownReadOnly=d.Down(),d._LeftHandedForwardReadOnly=d.Forward(!1),d._RightHandedForwardReadOnly=d.Forward(!0),d._LeftHandedBackwardReadOnly=d.Backward(!1),d._RightHandedBackwardReadOnly=d.Backward(!0),d._RightReadOnly=d.Right(),d._LeftReadOnly=d.Left(),d._ZeroReadOnly=d.Zero(),d._OneReadOnly=d.One(),Object.defineProperties(d.prototype,{dimension:{value:[3]},rank:{value:1}});class s{get x(){return this._x}set x(V){this._x=V,this._isDirty=!0}get y(){return this._y}set y(V){this._y=V,this._isDirty=!0}get z(){return this._z}set z(V){this._z=V,this._isDirty=!0}get w(){return this._w}set w(V){this._w=V,this._isDirty=!0}constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=V,this._y=h,this._z=mV,this._w=t}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let V=x(this._x);return V=397*V^x(this._y),V=397*V^x(this._z),V=397*V^x(this._w),V}sk(){return[this._x,this._y,this._z,this._w]}toArray(V,h){return void 0===h&&(h=0),V[h]=this._x,V[h+1]=this._y,V[h+2]=this._z,V[h+3]=this._w,this}Dm(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s.FromArrayToRef(V,h,this),this}addInPlace(V){return this.x+=V._x,this.y+=V._y,this.z+=V._z,this.w+=V._w,this}addInPlaceFromFloats(V,h,mV,t){return this.x+=V,this.y+=h,this.z+=mV,this.w+=t,this}add(V){return new s(this._x+V.x,this._y+V.y,this._z+V.z,this._w+V.w)}addToRef(V,h){return h.x=this._x+V.x,h.y=this._y+V.y,h.z=this._z+V.z,h.w=this._w+V.w,h}An(V){return this.x-=V.x,this.y-=V.y,this.z-=V.z,this.w-=V.w,this}Mh(V){return new s(this._x-V.x,this._y-V.y,this._z-V.z,this._w-V.w)}subtractToRef(V,h){return h.x=this._x-V.x,h.y=this._y-V.y,h.z=this._z-V.z,h.w=this._w-V.w,h}subtractFromFloats(V,h,mV,t){return new s(this._x-V,this._y-h,this._z-mV,this._w-t)}subtractFromFloatsToRef(V,h,mV,t,L){return L.x=this._x-V,L.y=this._y-h,L.z=this._z-mV,L.w=this._w-t,L}negate(){return new s(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(V){return V.x=-this._x,V.y=-this._y,V.z=-this._z,V.w=-this._w,V}scaleInPlace(V){return this.x*=V,this.y*=V,this.z*=V,this.w*=V,this}scale(V){return new s(this._x*V,this._y*V,this._z*V,this._w*V)}scaleToRef(V,h){return h.x=this._x*V,h.y=this._y*V,h.z=this._z*V,h.w=this._w*V,h}scaleAndAddToRef(V,h){return h.x+=this._x*V,h.y+=this._y*V,h.z+=this._z*V,h.w+=this._w*V,h}equals(V){return V&&this._x===V.x&&this._y===V.y&&this._z===V.z&&this._w===V.w}equalsWithEpsilon(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.c;return V&&(0,C.WithinEpsilon)(this._x,V.x,h)&&(0,C.WithinEpsilon)(this._y,V.y,h)&&(0,C.WithinEpsilon)(this._z,V.z,h)&&(0,C.WithinEpsilon)(this._w,V.w,h)}equalsToFloats(V,h,mV,t){return this._x===V&&this._y===h&&this._z===mV&&this._w===t}multiplyInPlace(V){return this.x*=V.x,this.y*=V.y,this.z*=V.z,this.w*=V.w,this}multiply(V){return new s(this._x*V.x,this._y*V.y,this._z*V.z,this._w*V.w)}multiplyToRef(V,h){return h.x=this._x*V.x,h.y=this._y*V.y,h.z=this._z*V.z,h.w=this._w*V.w,h}multiplyByFloats(V,h,mV,t){return new s(this._x*V,this._y*h,this._z*mV,this._w*t)}divide(V){return new s(this._x/V.x,this._y/V.y,this._z/V.z,this._w/V.w)}divideToRef(V,h){return h.x=this._x/V.x,h.y=this._y/V.y,h.z=this._z/V.z,h.w=this._w/V.w,h}divideInPlace(V){return this.divideToRef(V,this)}minimizeInPlace(V){return V.x<this._x&&(this.x=V.x),V.y<this._y&&(this.y=V.y),V.z<this._z&&(this.z=V.z),V.w<this._w&&(this.w=V.w),this}maximizeInPlace(V){return V.x>this._x&&(this.x=V.x),V.y>this._y&&(this.y=V.y),V.z>this._z&&(this.z=V.z),V.w>this._w&&(this.w=V.w),this}minimizeInPlaceFromFloats(V,h,mV,t){return this.x=Math.min(V,this._x),this.y=Math.min(h,this._y),this.z=Math.min(mV,this._z),this.w=Math.min(t,this._w),this}maximizeInPlaceFromFloats(V,h,mV,t){return this.x=Math.max(V,this._x),this.y=Math.max(h,this._y),this.z=Math.max(mV,this._z),this.w=Math.max(t,this._w),this}floorToRef(V){return V.x=Math.floor(this._x),V.y=Math.floor(this._y),V.z=Math.floor(this._z),V.w=Math.floor(this._w),V}floor(){return new s(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(V){return V.x=this._x-Math.floor(this._x),V.y=this._y-Math.floor(this._y),V.z=this._z-Math.floor(this._z),V.w=this._w-Math.floor(this._w),V}fract(){return new s(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(V){return 0===V||1===V?this:this.scaleInPlace(1/V)}normalizeToNew(){return this.normalizeToRef(new s)}normalizeToRef(V){const h=this.length();return 0===h||1===h?(V.x=this._x,V.y=this._y,V.z=this._z,V.w=this._w,V):this.scaleToRef(1/h,V)}toVector3(){return new d(this._x,this._y,this._z)}clone(){return new s(this._x,this._y,this._z,this._w)}t(V){return this.x=V.x,this.y=V.y,this.z=V.z,this.w=V.w,this}Hk(V,h,mV,t){return this.x=V,this.y=h,this.z=mV,this.w=t,this}set(V,h,mV,t){return this.Hk(V,h,mV,t)}lk(V){return this.x=this.y=this.z=this.w=V,this}dot(V){return this._x*V.x+this._y*V.y+this._z*V.z+this._w*V.w}static Dh(V,h){return h||(h=0),new s(V[h],V[h+1],V[h+2],V[h+3])}static FromArrayToRef(V,h,mV){return mV.x=V[h],mV.y=V[h+1],mV.z=V[h+2],mV.w=V[h+3],mV}static FromFloatArrayToRef(V,h,mV){return s.FromArrayToRef(V,h,mV),mV}static FromFloatsToRef(V,h,mV,t,L){return L.x=V,L.y=h,L.z=mV,L.w=t,L}static Zero(){return new s(0,0,0,0)}static One(){return new s(1,1,1,1)}static Random(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new s((0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h))}static RandomToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,mV=arguments.length>2?arguments[2]:void 0;return mV.x=(0,C.RandomRange)(V,h),mV.y=(0,C.RandomRange)(V,h),mV.z=(0,C.RandomRange)(V,h),mV.w=(0,C.RandomRange)(V,h),mV}static Clamp(V,h,mV){return s.ClampToRef(V,h,mV,new s)}static ClampToRef(V,h,mV,t){return t.x=(0,C.Clamp)(V.x,h.x,mV.x),t.y=(0,C.Clamp)(V.y,h.y,mV.y),t.z=(0,C.Clamp)(V.z,h.z,mV.z),t.w=(0,C.Clamp)(V.w,h.w,mV.w),t}static CheckExtends(V,h,mV){h.minimizeInPlace(V),mV.maximizeInPlace(V)}static get ZeroReadOnly(){return s._ZeroReadOnly}static Normalize(V){return s.NormalizeToRef(V,new s)}static NormalizeToRef(V,h){return V.normalizeToRef(h),h}static Minimize(V,h){const mV=new s;return mV.t(V),mV.minimizeInPlace(h),mV}static Maximize(V,h){const mV=new s;return mV.t(V),mV.maximizeInPlace(h),mV}static Distance(V,h){return Math.sqrt(s.DistanceSquared(V,h))}static DistanceSquared(V,h){const mV=V.x-h.x,t=V.y-h.y,L=V.z-h.z,N=V.w-h.w;return mV*mV+t*t+L*L+N*N}static Center(V,h){return s.CenterToRef(V,h,new s)}static CenterToRef(V,h,mV){return mV.x=(V.x+h.x)/2,mV.y=(V.y+h.y)/2,mV.z=(V.z+h.z)/2,mV.w=(V.w+h.w)/2,mV}static TransformCoordinates(V,h){return s.TransformCoordinatesToRef(V,h,new s)}static TransformCoordinatesToRef(V,h,mV){return s.TransformCoordinatesFromFloatsToRef(V._x,V._y,V._z,h,mV),mV}static TransformCoordinatesFromFloatsToRef(V,h,mV,t,L){const N=t.m,A=V*N[0]+h*N[4]+mV*N[8]+N[12],k=V*N[1]+h*N[5]+mV*N[9]+N[13],C=V*N[2]+h*N[6]+mV*N[10]+N[14],K=V*N[3]+h*N[7]+mV*N[11]+N[15];return L.x=A,L.y=k,L.z=C,L.w=K,L}static TransformNormal(V,h){return s.TransformNormalToRef(V,h,new s)}static TransformNormalToRef(V,h,mV){const t=h.m,L=V.x*t[0]+V.y*t[4]+V.z*t[8],N=V.x*t[1]+V.y*t[5]+V.z*t[9],A=V.x*t[2]+V.y*t[6]+V.z*t[10];return mV.x=L,mV.y=N,mV.z=A,mV.w=V.w,mV}static TransformNormalFromFloatsToRef(V,h,mV,t,L,N){const A=L.m;return N.x=V*A[0]+h*A[4]+mV*A[8],N.y=V*A[1]+h*A[5]+mV*A[9],N.z=V*A[2]+h*A[6]+mV*A[10],N.w=t,N}static FromVector3(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new s(V._x,V._y,V._z,h)}static Dot(V,h){return V.x*h.x+V.y*h.y+V.z*h.z+V.w*h.w}}s._V8PerformanceHack=new s(.5,.5,.5,.5),s._ZeroReadOnly=s.Zero(),Object.defineProperties(s.prototype,{dimension:{value:[4]},rank:{value:1}});class M{get x(){return this._x}set x(V){this._x=V,this._isDirty=!0}get y(){return this._y}set y(V){this._y=V,this._isDirty=!0}get z(){return this._z}set z(V){this._z=V,this._isDirty=!0}get w(){return this._w}set w(V){this._w=V,this._isDirty=!0}constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=V,this._y=h,this._z=mV,this._w=t}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let V=x(this._x);return V=397*V^x(this._y),V=397*V^x(this._z),V=397*V^x(this._w),V}sk(){return[this._x,this._y,this._z,this._w]}toArray(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V[h]=this._x,V[h+1]=this._y,V[h+2]=this._z,V[h+3]=this._w,this}Dm(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M.FromArrayToRef(V,h,this)}equals(V){return V&&this._x===V._x&&this._y===V._y&&this._z===V._z&&this._w===V._w}equalsWithEpsilon(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.c;return V&&(0,C.WithinEpsilon)(this._x,V._x,h)&&(0,C.WithinEpsilon)(this._y,V._y,h)&&(0,C.WithinEpsilon)(this._z,V._z,h)&&(0,C.WithinEpsilon)(this._w,V._w,h)}isApprox(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.c;return V&&((0,C.WithinEpsilon)(this._x,V._x,h)&&(0,C.WithinEpsilon)(this._y,V._y,h)&&(0,C.WithinEpsilon)(this._z,V._z,h)&&(0,C.WithinEpsilon)(this._w,V._w,h)||(0,C.WithinEpsilon)(this._x,-V._x,h)&&(0,C.WithinEpsilon)(this._y,-V._y,h)&&(0,C.WithinEpsilon)(this._z,-V._z,h)&&(0,C.WithinEpsilon)(this._w,-V._w,h))}clone(){return new M(this._x,this._y,this._z,this._w)}t(V){return this._x=V._x,this._y=V._y,this._z=V._z,this._w=V._w,this._isDirty=!0,this}Hk(V,h,mV,t){return this._x=V,this._y=h,this._z=mV,this._w=t,this._isDirty=!0,this}set(V,h,mV,t){return this.Hk(V,h,mV,t)}lk(V){return this.Hk(V,V,V,V)}add(V){return new M(this._x+V._x,this._y+V._y,this._z+V._z,this._w+V._w)}addInPlace(V){return this._x+=V._x,this._y+=V._y,this._z+=V._z,this._w+=V._w,this._isDirty=!0,this}addToRef(V,h){return h._x=this._x+V._x,h._y=this._y+V._y,h._z=this._z+V._z,h._w=this._w+V._w,h._isDirty=!0,h}addInPlaceFromFloats(V,h,mV,t){return this._x+=V,this._y+=h,this._z+=mV,this._w+=t,this._isDirty=!0,this}subtractToRef(V,h){return h._x=this._x-V._x,h._y=this._y-V._y,h._z=this._z-V._z,h._w=this._w-V._w,h._isDirty=!0,h}subtractFromFloats(V,h,mV,t){return this.subtractFromFloatsToRef(V,h,mV,t,new M)}subtractFromFloatsToRef(V,h,mV,t,L){return L._x=this._x-V,L._y=this._y-h,L._z=this._z-mV,L._w=this._w-t,L._isDirty=!0,L}Mh(V){return new M(this._x-V._x,this._y-V._y,this._z-V._z,this._w-V._w)}An(V){return this._x-=V._x,this._y-=V._y,this._z-=V._z,this._w-=V._w,this._isDirty=!0,this}scale(V){return new M(this._x*V,this._y*V,this._z*V,this._w*V)}scaleToRef(V,h){return h._x=this._x*V,h._y=this._y*V,h._z=this._z*V,h._w=this._w*V,h._isDirty=!0,h}scaleInPlace(V){return this._x*=V,this._y*=V,this._z*=V,this._w*=V,this._isDirty=!0,this}scaleAndAddToRef(V,h){return h._x+=this._x*V,h._y+=this._y*V,h._z+=this._z*V,h._w+=this._w*V,h._isDirty=!0,h}multiply(V){const h=new M(0,0,0,1);return this.multiplyToRef(V,h),h}multiplyToRef(V,h){const mV=this._x*V._w+this._y*V._z-this._z*V._y+this._w*V._x,t=-this._x*V._z+this._y*V._w+this._z*V._x+this._w*V._y,L=this._x*V._y-this._y*V._x+this._z*V._w+this._w*V._z,N=-this._x*V._x-this._y*V._y-this._z*V._z+this._w*V._w;return h.Hk(mV,t,L,N),h}multiplyInPlace(V){return this.multiplyToRef(V,this)}multiplyByFloats(V,h,mV,t){return this._x*=V,this._y*=h,this._z*=mV,this._w*=t,this._isDirty=!0,this}divide(V){throw new ReferenceError("Can not divide a quaternion")}divideToRef(V,h){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(V){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new M)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(V){return V._x=-this._x,V._y=-this._y,V._z=-this._z,V._w=-this._w,V._isDirty=!0,V}equalsToFloats(V,h,mV,t){return this._x===V&&this._y===h&&this._z===mV&&this._w===t}floorToRef(V){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(V){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(V){return V.Hk(-this._x,-this._y,-this._z,this._w),V}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new M(-this._x,-this._y,-this._z,this._w)}invert(){const V=this.conjugate(),h=this.lengthSquared();return 0==h||1==h||V.scaleInPlace(1/h),V}invertInPlace(){this.conjugateInPlace();const V=this.lengthSquared();return 0==V||1==V||this.scaleInPlace(1/V),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(V){return 0===V||1===V?this:this.scaleInPlace(1/V)}normalizeToNew(){const V=new M(0,0,0,1);return this.normalizeToRef(V),V}normalizeToRef(V){const h=this.length();return 0===h||1===h?V.Hk(this._x,this._y,this._z,this._w):this.scaleToRef(1/h,V)}toEulerAngles(){const V=d.Zero();return this.toEulerAnglesToRef(V),V}toEulerAnglesToRef(V){const h=this._z,mV=this._x,t=this._y,L=this._w,N=t*h-mV*L,A=.4999999;if(N<-A)V._y=2*Math.atan2(t,L),V._x=Math.PI/2,V._z=0,V._isDirty=!0;else if(N>A)V._y=2*Math.atan2(t,L),V._x=-Math.PI/2,V._z=0,V._isDirty=!0;else{const A=L*L,k=h*h,C=mV*mV,K=t*t;V._z=Math.atan2(2*(mV*t+h*L),-k-C+K+A),V._x=Math.asin(-2*N),V._y=Math.atan2(2*(h*mV+t*L),k-C-K+A),V._isDirty=!0}return V}toAlphaBetaGammaToRef(V){const h=this._z,mV=this._x,t=this._y,L=this._w,N=Math.sqrt(mV*mV+t*t),A=Math.sqrt(h*h+L*L),k=2*Math.atan2(N,A),C=2*Math.atan2(h,L),K=2*Math.atan2(t,mV),o=(C+K)/2,n=(C-K)/2;return V.set(n,k,o),V}toRotationMatrix(V){return c.FromQuaternionToRef(this,V),V}fromRotationMatrix(V){return M.FromRotationMatrixToRef(V,this),this}dot(V){return this._x*V._x+this._y*V._y+this._z*V._z+this._w*V._w}toAxisAngle(){const V=d.Zero();return{axis:V,angle:this.toAxisAngleToRef(V)}}toAxisAngleToRef(V){let h=0;const mV=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),t=this._w;return mV>0?(h=2*Math.atan2(mV,t),V.set(this._x/mV,this._y/mV,this._z/mV)):(h=0,V.set(1,0,0)),h}static FromRotationMatrix(V){const h=new M;return M.FromRotationMatrixToRef(V,h),h}static FromRotationMatrixToRef(V,h){const mV=V.m,t=mV[0],L=mV[4],N=mV[8],A=mV[1],k=mV[5],C=mV[9],K=mV[2],o=mV[6],n=mV[10],q=t+k+n;let x;return q>0?(x=.5/Math.sqrt(q+1),h._w=.25/x,h._x=(o-C)*x,h._y=(N-K)*x,h._z=(A-L)*x,h._isDirty=!0):t>k&&t>n?(x=2*Math.sqrt(1+t-k-n),h._w=(o-C)/x,h._x=.25*x,h._y=(L+A)/x,h._z=(N+K)/x,h._isDirty=!0):k>n?(x=2*Math.sqrt(1+k-t-n),h._w=(N-K)/x,h._x=(L+A)/x,h._y=.25*x,h._z=(C+o)/x,h._isDirty=!0):(x=2*Math.sqrt(1+n-t-k),h._w=(A-L)/x,h._x=(N+K)/x,h._y=(C+o)/x,h._z=.25*x,h._isDirty=!0),h}static Dot(V,h){return V._x*h._x+V._y*h._y+V._z*h._z+V._w*h._w}static AreClose(V,h){let mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const t=M.Dot(V,h);return 1-t*t<=mV}static SmoothToRef(V,h,mV,t,L){let N=0===t?1:mV/t;return N=(0,C.Clamp)(N,0,1),M.SlerpToRef(V,h,N,L),L}static Zero(){return new M(0,0,0,0)}static Inverse(V){return new M(-V._x,-V._y,-V._z,V._w)}static InverseToRef(V,h){return h.set(-V._x,-V._y,-V._z,V._w),h}static Identity(){return new M(0,0,0,1)}static IsIdentity(V){return V&&0===V._x&&0===V._y&&0===V._z&&1===V._w}static RotationAxis(V,h){return M.RotationAxisToRef(V,h,new M)}static RotationAxisToRef(V,h,mV){mV._w=Math.cos(h/2);const t=Math.sin(h/2)/V.length();return mV._x=V._x*t,mV._y=V._y*t,mV._z=V._z*t,mV._isDirty=!0,mV}static Dh(V,h){return h||(h=0),new M(V[h],V[h+1],V[h+2],V[h+3])}static FromArrayToRef(V,h,mV){return mV._x=V[h],mV._y=V[h+1],mV._z=V[h+2],mV._w=V[h+3],mV._isDirty=!0,mV}static FromFloatsToRef(V,h,mV,t,L){return L.Hk(V,h,mV,t),L}static FromEulerAngles(V,h,mV){const t=new M;return M.RotationYawPitchRollToRef(h,V,mV,t),t}static FromEulerAnglesToRef(V,h,mV,t){return M.RotationYawPitchRollToRef(h,V,mV,t),t}static FromEulerVector(V){const h=new M;return M.RotationYawPitchRollToRef(V._y,V._x,V._z,h),h}static FromEulerVectorToRef(V,h){return M.RotationYawPitchRollToRef(V._y,V._x,V._z,h),h}static FromUnitVectorsToRef(V,h,mV){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.c;const N=d.Dot(V,h)+1;return N<L?Math.abs(V.x)>Math.abs(V.z)?mV.set(-V.y,V.x,0,0):mV.set(0,-V.z,V.y,0):(d.CrossToRef(V,h,Q.sh[0]),mV.set(Q.sh[0].x,Q.sh[0].y,Q.sh[0].z,N)),mV.normalize()}static RotationYawPitchRoll(V,h,mV){const t=new M;return M.RotationYawPitchRollToRef(V,h,mV,t),t}static RotationYawPitchRollToRef(V,h,mV,t){const L=.5*mV,N=.5*h,A=.5*V,k=Math.sin(L),C=Math.cos(L),K=Math.sin(N),o=Math.cos(N),n=Math.sin(A),q=Math.cos(A);return t._x=q*K*C+n*o*k,t._y=n*o*C-q*K*k,t._z=q*o*k-n*K*C,t._w=q*o*C+n*K*k,t._isDirty=!0,t}static RotationAlphaBetaGamma(V,h,mV){const t=new M;return M.RotationAlphaBetaGammaToRef(V,h,mV,t),t}static RotationAlphaBetaGammaToRef(V,h,mV,t){const L=.5*(mV+V),N=.5*(mV-V),A=.5*h;return t._x=Math.cos(N)*Math.sin(A),t._y=Math.sin(N)*Math.sin(A),t._z=Math.sin(L)*Math.cos(A),t._w=Math.cos(L)*Math.cos(A),t._isDirty=!0,t}static RotationQuaternionFromAxis(V,h,mV){const t=new M(0,0,0,0);return M.RotationQuaternionFromAxisToRef(V,h,mV,t),t}static RotationQuaternionFromAxisToRef(V,h,mV,t){const L=z.Matrix[0];return V=V.normalizeToRef(z.sh[0]),h=h.normalizeToRef(z.sh[1]),mV=mV.normalizeToRef(z.sh[2]),c.FromXYZAxesToRef(V,h,mV,L),M.FromRotationMatrixToRef(L,t),t}static FromLookDirectionLH(V,h){const mV=new M;return M.FromLookDirectionLHToRef(V,h,mV),mV}static FromLookDirectionLHToRef(V,h,mV){const t=z.Matrix[0];return c.LookDirectionLHToRef(V,h,t),M.FromRotationMatrixToRef(t,mV),mV}static FromLookDirectionRH(V,h){const mV=new M;return M.FromLookDirectionRHToRef(V,h,mV),mV}static FromLookDirectionRHToRef(V,h,mV){const t=z.Matrix[0];return c.LookDirectionRHToRef(V,h,t),M.FromRotationMatrixToRef(t,mV)}static Slerp(V,h,mV){const t=M.Identity();return M.SlerpToRef(V,h,mV,t),t}static SlerpToRef(V,h,mV,t){let L,N,A=V._x*h._x+V._y*h._y+V._z*h._z+V._w*h._w,k=!1;if(A<0&&(k=!0,A=-A),A>.999999)N=1-mV,L=k?-mV:mV;else{const V=Math.acos(A),h=1/Math.sin(V);N=Math.sin((1-mV)*V)*h,L=k?-Math.sin(mV*V)*h:Math.sin(mV*V)*h}return t._x=N*V._x+L*h._x,t._y=N*V._y+L*h._y,t._z=N*V._z+L*h._z,t._w=N*V._w+L*h._w,t._isDirty=!0,t}static Hermite(V,h,mV,t,L){const N=L*L,A=L*N,k=2*A-3*N+1,C=-2*A+3*N,K=A-2*N+L,o=A-N,n=V._x*k+mV._x*C+h._x*K+t._x*o,q=V._y*k+mV._y*C+h._y*K+t._y*o,x=V._z*k+mV._z*C+h._z*K+t._z*o,R=V._w*k+mV._w*C+h._w*K+t._w*o;return new M(n,q,x,R)}static Hermite1stDerivative(V,h,mV,t,L){const N=new M;return this.Hermite1stDerivativeToRef(V,h,mV,t,L,N),N}static Hermite1stDerivativeToRef(V,h,mV,t,L,N){const A=L*L;return N._x=6*(A-L)*V._x+(3*A-4*L+1)*h._x+6*(-A+L)*mV._x+(3*A-2*L)*t._x,N._y=6*(A-L)*V._y+(3*A-4*L+1)*h._y+6*(-A+L)*mV._y+(3*A-2*L)*t._y,N._z=6*(A-L)*V._z+(3*A-4*L+1)*h._z+6*(-A+L)*mV._z+(3*A-2*L)*t._z,N._w=6*(A-L)*V._w+(3*A-4*L+1)*h._w+6*(-A+L)*mV._w+(3*A-2*L)*t._w,N._isDirty=!0,N}static Normalize(V){const h=M.Zero();return M.NormalizeToRef(V,h),h}static NormalizeToRef(V,h){return V.normalizeToRef(h),h}static Clamp(V,h,mV){const t=new M;return M.ClampToRef(V,h,mV,t),t}static ClampToRef(V,h,mV,t){return t.Hk((0,C.Clamp)(V.x,h.x,mV.x),(0,C.Clamp)(V.y,h.y,mV.y),(0,C.Clamp)(V.z,h.z,mV.z),(0,C.Clamp)(V.w,h.w,mV.w))}static Random(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new M((0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h))}static RandomToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Hk((0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h),(0,C.RandomRange)(V,h))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(V,h){return Math.sqrt(M.DistanceSquared(V,h))}static DistanceSquared(V,h){const mV=V.x-h.x,t=V.y-h.y,L=V.z-h.z,N=V.w-h.w;return mV*mV+t*t+L*L+N*N}static Center(V,h){return M.CenterToRef(V,h,M.Zero())}static CenterToRef(V,h,mV){return mV.Hk((V.x+h.x)/2,(V.y+h.y)/2,(V.z+h.z)/2,(V.w+h.w)/2)}}M._V8PerformanceHack=new M(.5,.5,.5,.5),Object.defineProperties(M.prototype,{dimension:{value:[4]},rank:{value:1}});class c{static get Use64Bits(){return A.e.MatrixUse64Bits}get m(){return this.Kk}markAsUpdated(){this.updateFlag=K._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(V){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],mV=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=V,this._isIdentity3x2=V||mV,this._isIdentityDirty=!this._isIdentity&&h,this._isIdentity3x2Dirty=!this._isIdentity3x2&&t}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,A.e.MatrixTrackPrecisionChange&&A.e.MatrixTrackedMatrices.push(this),this.Kk=new A.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const V=this.Kk;this._isIdentity=1===V[0]&&0===V[1]&&0===V[2]&&0===V[3]&&0===V[4]&&1===V[5]&&0===V[6]&&0===V[7]&&0===V[8]&&0===V[9]&&1===V[10]&&0===V[11]&&0===V[12]&&0===V[13]&&0===V[14]&&1===V[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Kk[0]||1!==this.Kk[5]||1!==this.Kk[15]||0!==this.Kk[1]||0!==this.Kk[2]||0!==this.Kk[3]||0!==this.Kk[4]||0!==this.Kk[6]||0!==this.Kk[7]||0!==this.Kk[8]||0!==this.Kk[9]||0!==this.Kk[10]||0!==this.Kk[11]||0!==this.Kk[12]||0!==this.Kk[13]||0!==this.Kk[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const V=this.Kk,h=V[0],mV=V[1],t=V[2],L=V[3],N=V[4],A=V[5],k=V[6],C=V[7],K=V[8],o=V[9],n=V[10],q=V[11],x=V[12],R=V[13],d=V[14],s=V[15],M=n*s-d*q,c=o*s-R*q,z=o*d-R*n,Q=K*s-x*q,J=K*d-n*x,v=K*R-x*o;return h*+(A*M-k*c+C*z)+mV*-(N*M-k*Q+C*J)+t*+(N*c-A*Q+C*v)+L*-(N*z-A*J+k*v)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!V)return this.Kk;const mV=this.Kk;for(let t=0;t<16;t++)V[h+t]=mV[t];return this}sk(){return this.Kk}Dm(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c.FromArrayToRef(V,h,this)}Hk(){for(var V=arguments.length,h=new Array(V),mV=0;mV<V;mV++)h[mV]=arguments[mV];return c.FromArrayToRef(h,0,this)}set(){const V=this.Kk;for(let h=0;h<16;h++)V[h]=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}lk(V){const h=this.Kk;for(let mV=0;mV<16;mV++)h[mV]=V;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return c.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(V){const h=new c;return this.addToRef(V,h),h}addToRef(V,h){const mV=this.Kk,t=h.Kk,L=V.m;for(let N=0;N<16;N++)t[N]=mV[N]+L[N];return h.markAsUpdated(),h}addToSelf(V){const h=this.Kk,mV=V.m;return h[0]+=mV[0],h[1]+=mV[1],h[2]+=mV[2],h[3]+=mV[3],h[4]+=mV[4],h[5]+=mV[5],h[6]+=mV[6],h[7]+=mV[7],h[8]+=mV[8],h[9]+=mV[9],h[10]+=mV[10],h[11]+=mV[11],h[12]+=mV[12],h[13]+=mV[13],h[14]+=mV[14],h[15]+=mV[15],this.markAsUpdated(),this}addInPlace(V){const h=this.Kk,mV=V.m;for(let t=0;t<16;t++)h[t]+=mV[t];return this.markAsUpdated(),this}addInPlaceFromFloats(){const V=this.Kk;for(let h=0;h<16;h++)V[h]+=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}Mh(V){const h=this.Kk,mV=V.m;for(let t=0;t<16;t++)h[t]-=mV[t];return this.markAsUpdated(),this}subtractToRef(V,h){const mV=this.Kk,t=V.m,L=h.Kk;for(let N=0;N<16;N++)L[N]=mV[N]-t[N];return h.markAsUpdated(),h}An(V){const h=this.Kk,mV=V.m;for(let t=0;t<16;t++)h[t]-=mV[t];return this.markAsUpdated(),this}subtractFromFloats(){for(var V=arguments.length,h=new Array(V),mV=0;mV<V;mV++)h[mV]=arguments[mV];return this.subtractFromFloatsToRef(...h,new c)}subtractFromFloatsToRef(){for(var V=arguments.length,h=new Array(V),mV=0;mV<V;mV++)h[mV]=arguments[mV];const t=h.pop(),L=this.Kk,N=t.Kk,A=h;for(let k=0;k<16;k++)N[k]=L[k]-A[k];return t.markAsUpdated(),t}invertToRef(V){return!0===this._isIdentity?(c.IdentityToRef(V),V):(q(this,V.sk())?V.markAsUpdated():V.t(this),V)}addAtIndex(V,h){return this.Kk[V]+=h,this.markAsUpdated(),this}multiplyAtIndex(V,h){return this.Kk[V]*=h,this.markAsUpdated(),this}setTranslationFromFloats(V,h,mV){return this.Kk[12]=V,this.Kk[13]=h,this.Kk[14]=mV,this.markAsUpdated(),this}addTranslationFromFloats(V,h,mV){return this.Kk[12]+=V,this.Kk[13]+=h,this.Kk[14]+=mV,this.markAsUpdated(),this}setTranslation(V){return this.setTranslationFromFloats(V._x,V._y,V._z)}getTranslation(){return new d(this.Kk[12],this.Kk[13],this.Kk[14])}getTranslationToRef(V){return V.x=this.Kk[12],V.y=this.Kk[13],V.z=this.Kk[14],V}removeRotationAndScaling(){const V=this.m;return c.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,V[12],V[13],V[14],V[15],this),this._updateIdentityStatus(0===V[12]&&0===V[13]&&0===V[14]&&1===V[15]),this}t(V){V.copyToArray(this.Kk);const h=V;return this.updateFlag=h.updateFlag,this._updateIdentityStatus(h._isIdentity,h._isIdentityDirty,h._isIdentity3x2,h._isIdentity3x2Dirty),this}copyToArray(V){return n(this,V,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(V){const h=new c;return this.multiplyToRef(V,h),h}multiplyInPlace(V){const h=this.Kk,mV=V.m;for(let t=0;t<16;t++)h[t]*=mV[t];return this.markAsUpdated(),this}multiplyByFloats(){const V=this.Kk;for(let h=0;h<16;h++)V[h]*=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var V=arguments.length,h=new Array(V),mV=0;mV<V;mV++)h[mV]=arguments[mV];const t=h.pop(),L=this.Kk,N=t.Kk,A=h;for(let k=0;k<16;k++)N[k]=L[k]*A[k];return t.markAsUpdated(),t}multiplyToRef(V,h){return this._isIdentity?(h.t(V),h):V._isIdentity?(h.t(this),h):(this.multiplyToArray(V,h.Kk,0),h.markAsUpdated(),h)}multiplyToArray(V,h,mV){return o(this,V,h,mV),this}divide(V){return this.divideToRef(V,new c)}divideToRef(V,h){const mV=this.Kk,t=V.m,L=h.Kk;for(let N=0;N<16;N++)L[N]=mV[N]/t[N];return h.markAsUpdated(),h}divideInPlace(V){const h=this.Kk,mV=V.m;for(let t=0;t<16;t++)h[t]/=mV[t];return this.markAsUpdated(),this}minimizeInPlace(V){const h=this.Kk,mV=V.m;for(let t=0;t<16;t++)h[t]=Math.min(h[t],mV[t]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const V=this.Kk;for(let h=0;h<16;h++)V[h]=Math.min(V[h],h<0||arguments.length<=h?void 0:arguments[h]);return this.markAsUpdated(),this}maximizeInPlace(V){const h=this.Kk,mV=V.m;for(let t=0;t<16;t++)h[t]=Math.min(h[t],mV[t]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const V=this.Kk;for(let h=0;h<16;h++)V[h]=Math.min(V[h],h<0||arguments.length<=h?void 0:arguments[h]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new c)}negateInPlace(){const V=this.Kk;for(let h=0;h<16;h++)V[h]=-V[h];return this.markAsUpdated(),this}negateToRef(V){const h=this.Kk,mV=V.Kk;for(let t=0;t<16;t++)mV[t]=-h[t];return V.markAsUpdated(),V}equals(V){const h=V;if(!h)return!1;if((this._isIdentity||h._isIdentity)&&!this._isIdentityDirty&&!h._isIdentityDirty)return this._isIdentity&&h._isIdentity;const mV=this.m,t=h.m;return mV[0]===t[0]&&mV[1]===t[1]&&mV[2]===t[2]&&mV[3]===t[3]&&mV[4]===t[4]&&mV[5]===t[5]&&mV[6]===t[6]&&mV[7]===t[7]&&mV[8]===t[8]&&mV[9]===t[9]&&mV[10]===t[10]&&mV[11]===t[11]&&mV[12]===t[12]&&mV[13]===t[13]&&mV[14]===t[14]&&mV[15]===t[15]}equalsWithEpsilon(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const mV=this.Kk,t=V.m;for(let L=0;L<16;L++)if(!(0,C.WithinEpsilon)(mV[L],t[L],h))return!1;return!0}equalsToFloats(){const V=this.Kk;for(let h=0;h<16;h++)if(V[h]!=(h<0||arguments.length<=h?void 0:arguments[h]))return!1;return!0}floor(){return this.floorToRef(new c)}floorToRef(V){const h=this.Kk,mV=V.Kk;for(let t=0;t<16;t++)mV[t]=Math.floor(h[t]);return V.markAsUpdated(),V}fract(){return this.fractToRef(new c)}fractToRef(V){const h=this.Kk,mV=V.Kk;for(let t=0;t<16;t++)mV[t]=h[t]-Math.floor(h[t]);return V.markAsUpdated(),V}clone(){const V=new c;return V.t(this),V}getClassName(){return"Matrix"}getHashCode(){let V=x(this.Kk[0]);for(let h=1;h<16;h++)V=397*V^x(this.Kk[h]);return V}decomposeToTransformNode(V){return V.rotationQuaternion=V.rotationQuaternion||new M,this.decompose(V.jk,V.rotationQuaternion,V.position)}decompose(V,h,mV,t){let L=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return mV&&mV.lk(0),V&&V.lk(1),h&&h.Hk(0,0,0,1),!0;const N=this.Kk;if(mV&&mV.Hk(N[12],N[13],N[14]),(V=V||z.sh[0]).x=Math.sqrt(N[0]*N[0]+N[1]*N[1]+N[2]*N[2]),V.y=Math.sqrt(N[4]*N[4]+N[5]*N[5]+N[6]*N[6]),V.z=Math.sqrt(N[8]*N[8]+N[9]*N[9]+N[10]*N[10]),t){const h=(L?t.absoluteScaling.x:t.jk.x)<0?-1:1,mV=(L?t.absoluteScaling.y:t.jk.y)<0?-1:1,N=(L?t.absoluteScaling.z:t.jk.z)<0?-1:1;V.x*=h,V.y*=mV,V.z*=N}else this.determinant()<=0&&(V.y*=-1);if(0===V._x||0===V._y||0===V._z)return h&&h.Hk(0,0,0,1),!1;if(h){const mV=1/V._x,t=1/V._y,L=1/V._z;c.FromValuesToRef(N[0]*mV,N[1]*mV,N[2]*mV,0,N[4]*t,N[5]*t,N[6]*t,0,N[8]*L,N[9]*L,N[10]*L,0,0,0,0,1,z.Matrix[0]),M.FromRotationMatrixToRef(z.Matrix[0],h)}return!0}getRow(V){if(V<0||V>3)return null;const h=4*V;return new s(this.Kk[h+0],this.Kk[h+1],this.Kk[h+2],this.Kk[h+3])}getRowToRef(V,h){if(V>=0&&V<=3){const mV=4*V;h.x=this.Kk[mV+0],h.y=this.Kk[mV+1],h.z=this.Kk[mV+2],h.w=this.Kk[mV+3]}return h}setRow(V,h){return this.setRowFromFloats(V,h.x,h.y,h.z,h.w)}transpose(){const V=new c;return c.TransposeToRef(this,V),V}transposeToRef(V){return c.TransposeToRef(this,V),V}setRowFromFloats(V,h,mV,t,L){if(V<0||V>3)return this;const N=4*V;return this.Kk[N+0]=h,this.Kk[N+1]=mV,this.Kk[N+2]=t,this.Kk[N+3]=L,this.markAsUpdated(),this}scale(V){const h=new c;return this.scaleToRef(V,h),h}scaleToRef(V,h){for(let mV=0;mV<16;mV++)h.Kk[mV]=this.Kk[mV]*V;return h.markAsUpdated(),h}scaleAndAddToRef(V,h){for(let mV=0;mV<16;mV++)h.Kk[mV]+=this.Kk[mV]*V;return h.markAsUpdated(),h}scaleInPlace(V){const h=this.Kk;for(let mV=0;mV<16;mV++)h[mV]*=V;return this.markAsUpdated(),this}toNormalMatrix(V){const h=z.Matrix[0];this.invertToRef(h),h.transposeToRef(V);const mV=V.Kk;return c.FromValuesToRef(mV[0],mV[1],mV[2],0,mV[4],mV[5],mV[6],0,mV[8],mV[9],mV[10],0,0,0,0,1,V),V}getRotationMatrix(){const V=new c;return this.getRotationMatrixToRef(V),V}getRotationMatrixToRef(V){const h=z.sh[0];if(!this.decompose(h))return c.IdentityToRef(V),V;const mV=this.Kk,t=1/h._x,L=1/h._y,N=1/h._z;return c.FromValuesToRef(mV[0]*t,mV[1]*t,mV[2]*t,0,mV[4]*L,mV[5]*L,mV[6]*L,0,mV[8]*N,mV[9]*N,mV[10]*N,0,0,0,0,1,V),V}toggleModelMatrixHandInPlace(){const V=this.Kk;return V[2]*=-1,V[6]*=-1,V[8]*=-1,V[9]*=-1,V[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const V=this.Kk;return V[8]*=-1,V[9]*=-1,V[10]*=-1,V[11]*=-1,this.markAsUpdated(),this}static Dh(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const mV=new c;return c.FromArrayToRef(V,h,mV),mV}static FromArrayToRef(V,h,mV){for(let t=0;t<16;t++)mV.Kk[t]=V[t+h];return mV.markAsUpdated(),mV}static FromFloat32ArrayToRefScaled(V,h,mV,t){return t.Kk[0]=V[0+h]*mV,t.Kk[1]=V[1+h]*mV,t.Kk[2]=V[2+h]*mV,t.Kk[3]=V[3+h]*mV,t.Kk[4]=V[4+h]*mV,t.Kk[5]=V[5+h]*mV,t.Kk[6]=V[6+h]*mV,t.Kk[7]=V[7+h]*mV,t.Kk[8]=V[8+h]*mV,t.Kk[9]=V[9+h]*mV,t.Kk[10]=V[10+h]*mV,t.Kk[11]=V[11+h]*mV,t.Kk[12]=V[12+h]*mV,t.Kk[13]=V[13+h]*mV,t.Kk[14]=V[14+h]*mV,t.Kk[15]=V[15+h]*mV,t.markAsUpdated(),t}static get IdentityReadOnly(){return c._IdentityReadOnly}static FromValuesToRef(V,h,mV,t,L,N,A,k,C,K,o,n,q,x,R,d,s){const M=s.Kk;M[0]=V,M[1]=h,M[2]=mV,M[3]=t,M[4]=L,M[5]=N,M[6]=A,M[7]=k,M[8]=C,M[9]=K,M[10]=o,M[11]=n,M[12]=q,M[13]=x,M[14]=R,M[15]=d,s.markAsUpdated()}static FromValues(V,h,mV,t,L,N,A,k,C,K,o,n,q,x,R,d){const s=new c,M=s.Kk;return M[0]=V,M[1]=h,M[2]=mV,M[3]=t,M[4]=L,M[5]=N,M[6]=A,M[7]=k,M[8]=C,M[9]=K,M[10]=o,M[11]=n,M[12]=q,M[13]=x,M[14]=R,M[15]=d,s.markAsUpdated(),s}static Compose(V,h,mV){const t=new c;return c.ComposeToRef(V,h,mV,t),t}static ComposeToRef(V,h,mV,t){const L=t.Kk,N=h._x,A=h._y,k=h._z,C=h._w,K=N+N,o=A+A,n=k+k,q=N*K,x=N*o,R=N*n,d=A*o,s=A*n,M=k*n,c=C*K,z=C*o,Q=C*n,J=V._x,v=V._y,D=V._z;return L[0]=(1-(d+M))*J,L[1]=(x+Q)*J,L[2]=(R-z)*J,L[3]=0,L[4]=(x-Q)*v,L[5]=(1-(q+M))*v,L[6]=(s+c)*v,L[7]=0,L[8]=(R+z)*D,L[9]=(s-c)*D,L[10]=(1-(q+d))*D,L[11]=0,L[12]=mV._x,L[13]=mV._y,L[14]=mV._z,L[15]=1,t.markAsUpdated(),t}static Identity(){const V=c.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return V._updateIdentityStatus(!0),V}static IdentityToRef(V){return c.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,V),V._updateIdentityStatus(!0),V}static Zero(){const V=c.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return V._updateIdentityStatus(!1),V}static RotationX(V){const h=new c;return c.RotationXToRef(V,h),h}static Invert(V){const h=new c;return V.invertToRef(h),h}static RotationXToRef(V,h){const mV=Math.sin(V),t=Math.cos(V);return c.FromValuesToRef(1,0,0,0,0,t,mV,0,0,-mV,t,0,0,0,0,1,h),h._updateIdentityStatus(1===t&&0===mV),h}static RotationY(V){const h=new c;return c.RotationYToRef(V,h),h}static RotationYToRef(V,h){const mV=Math.sin(V),t=Math.cos(V);return c.FromValuesToRef(t,0,-mV,0,0,1,0,0,mV,0,t,0,0,0,0,1,h),h._updateIdentityStatus(1===t&&0===mV),h}static RotationZ(V){const h=new c;return c.RotationZToRef(V,h),h}static RotationZToRef(V,h){const mV=Math.sin(V),t=Math.cos(V);return c.FromValuesToRef(t,mV,0,0,-mV,t,0,0,0,0,1,0,0,0,0,1,h),h._updateIdentityStatus(1===t&&0===mV),h}static RotationAxis(V,h){const mV=new c;return c.RotationAxisToRef(V,h,mV),mV}static RotationAxisToRef(V,h,mV){const t=Math.sin(-h),L=Math.cos(-h),N=1-L;V=V.normalizeToRef(z.sh[0]);const A=mV.Kk;return A[0]=V._x*V._x*N+L,A[1]=V._x*V._y*N-V._z*t,A[2]=V._x*V._z*N+V._y*t,A[3]=0,A[4]=V._y*V._x*N+V._z*t,A[5]=V._y*V._y*N+L,A[6]=V._y*V._z*N-V._x*t,A[7]=0,A[8]=V._z*V._x*N-V._y*t,A[9]=V._z*V._y*N+V._x*t,A[10]=V._z*V._z*N+L,A[11]=0,A[12]=0,A[13]=0,A[14]=0,A[15]=1,mV.markAsUpdated(),mV}static RotationAlignToRef(V,h,mV){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const N=d.Dot(h,V),A=mV.Kk;if(N<-1+t.c)A[0]=-1,A[1]=0,A[2]=0,A[3]=0,A[4]=0,A[5]=L?1:-1,A[6]=0,A[7]=0,A[8]=0,A[9]=0,A[10]=L?-1:1,A[11]=0;else{const mV=d.Cross(h,V),t=1/(1+N);A[0]=mV._x*mV._x*t+N,A[1]=mV._y*mV._x*t-mV._z,A[2]=mV._z*mV._x*t+mV._y,A[3]=0,A[4]=mV._x*mV._y*t+mV._z,A[5]=mV._y*mV._y*t+N,A[6]=mV._z*mV._y*t-mV._x,A[7]=0,A[8]=mV._x*mV._z*t-mV._y,A[9]=mV._y*mV._z*t+mV._x,A[10]=mV._z*mV._z*t+N,A[11]=0}return A[12]=0,A[13]=0,A[14]=0,A[15]=1,mV.markAsUpdated(),mV}static RotationYawPitchRoll(V,h,mV){const t=new c;return c.RotationYawPitchRollToRef(V,h,mV,t),t}static RotationYawPitchRollToRef(V,h,mV,t){return M.RotationYawPitchRollToRef(V,h,mV,z.Quaternion[0]),z.Quaternion[0].toRotationMatrix(t),t}static Scaling(V,h,mV){const t=new c;return c.ScalingToRef(V,h,mV,t),t}static ScalingToRef(V,h,mV,t){return c.FromValuesToRef(V,0,0,0,0,h,0,0,0,0,mV,0,0,0,0,1,t),t._updateIdentityStatus(1===V&&1===h&&1===mV),t}static Translation(V,h,mV){const t=new c;return c.TranslationToRef(V,h,mV,t),t}static TranslationToRef(V,h,mV,t){return c.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,V,h,mV,1,t),t._updateIdentityStatus(0===V&&0===h&&0===mV),t}static Lerp(V,h,mV){const t=new c;return c.LerpToRef(V,h,mV,t),t}static LerpToRef(V,h,mV,t){const L=t.Kk,N=V.m,A=h.m;for(let k=0;k<16;k++)L[k]=N[k]*(1-mV)+A[k]*mV;return t.markAsUpdated(),t}static DecomposeLerp(V,h,mV){const t=new c;return c.DecomposeLerpToRef(V,h,mV,t),t}static DecomposeLerpToRef(V,h,mV,t){const L=z.sh[0],N=z.Quaternion[0],A=z.sh[1];V.decompose(L,N,A);const k=z.sh[2],C=z.Quaternion[1],K=z.sh[3];h.decompose(k,C,K);const o=z.sh[4];d.LerpToRef(L,k,mV,o);const n=z.Quaternion[2];M.SlerpToRef(N,C,mV,n);const q=z.sh[5];return d.LerpToRef(A,K,mV,q),c.ComposeToRef(o,n,q,t),t}static LookAtLH(V,h,mV){const t=new c;return c.LookAtLHToRef(V,h,mV,t),t}static LookAtLHToRef(V,h,mV,t){const L=z.sh[0],N=z.sh[1],A=z.sh[2];h.subtractToRef(V,A),A.normalize(),d.CrossToRef(mV,A,L);const k=L.lengthSquared();0===k?L.x=1:L.normalizeFromLength(Math.sqrt(k)),d.CrossToRef(A,L,N),N.normalize();const C=-d.Dot(L,V),K=-d.Dot(N,V),o=-d.Dot(A,V);return c.FromValuesToRef(L._x,N._x,A._x,0,L._y,N._y,A._y,0,L._z,N._z,A._z,0,C,K,o,1,t),t}static LookAtRH(V,h,mV){const t=new c;return c.LookAtRHToRef(V,h,mV,t),t}static LookAtRHToRef(V,h,mV,t){const L=z.sh[0],N=z.sh[1],A=z.sh[2];V.subtractToRef(h,A),A.normalize(),d.CrossToRef(mV,A,L);const k=L.lengthSquared();0===k?L.x=1:L.normalizeFromLength(Math.sqrt(k)),d.CrossToRef(A,L,N),N.normalize();const C=-d.Dot(L,V),K=-d.Dot(N,V),o=-d.Dot(A,V);return c.FromValuesToRef(L._x,N._x,A._x,0,L._y,N._y,A._y,0,L._z,N._z,A._z,0,C,K,o,1,t),t}static LookDirectionLH(V,h){const mV=new c;return c.LookDirectionLHToRef(V,h,mV),mV}static LookDirectionLHToRef(V,h,mV){const t=z.sh[0];t.t(V),t.scaleInPlace(-1);const L=z.sh[1];return d.CrossToRef(h,t,L),c.FromValuesToRef(L._x,L._y,L._z,0,h._x,h._y,h._z,0,t._x,t._y,t._z,0,0,0,0,1,mV),mV}static LookDirectionRH(V,h){const mV=new c;return c.LookDirectionRHToRef(V,h,mV),mV}static LookDirectionRHToRef(V,h,mV){const t=z.sh[2];return d.CrossToRef(h,V,t),c.FromValuesToRef(t._x,t._y,t._z,0,h._x,h._y,h._z,0,V._x,V._y,V._z,0,0,0,0,1,mV),mV}static OrthoLH(V,h,mV,t,L){const N=new c;return c.OrthoLHToRef(V,h,mV,t,N,L),N}static OrthoLHToRef(V,h,mV,t,L,N){const A=2/V,k=2/h,C=2/(t-mV),K=-(t+mV)/(t-mV);return c.FromValuesToRef(A,0,0,0,0,k,0,0,0,0,C,0,0,0,K,1,L),N&&L.multiplyToRef(J,L),L._updateIdentityStatus(1===A&&1===k&&1===C&&0===K),L}static OrthoOffCenterLH(V,h,mV,t,L,N,A){const k=new c;return c.OrthoOffCenterLHToRef(V,h,mV,t,L,N,k,A),k}static OrthoOffCenterLHToRef(V,h,mV,t,L,N,A,k){const C=2/(h-V),K=2/(t-mV),o=2/(N-L),n=-(N+L)/(N-L),q=(V+h)/(V-h),x=(t+mV)/(mV-t);return c.FromValuesToRef(C,0,0,0,0,K,0,0,0,0,o,0,q,x,n,1,A),k&&A.multiplyToRef(J,A),A.markAsUpdated(),A}static ObliqueOffCenterLHToRef(V,h,mV,t,L,N,A,k,C,K,o){const n=-A*Math.cos(k),q=-A*Math.sin(k);return c.TranslationToRef(0,0,-C,z.Matrix[1]),c.FromValuesToRef(1,0,0,0,0,1,0,0,n,q,1,0,0,0,0,1,z.Matrix[0]),z.Matrix[1].multiplyToRef(z.Matrix[0],z.Matrix[0]),c.TranslationToRef(0,0,C,z.Matrix[1]),z.Matrix[0].multiplyToRef(z.Matrix[1],z.Matrix[0]),c.OrthoOffCenterLHToRef(V,h,mV,t,L,N,K,o),z.Matrix[0].multiplyToRef(K,K),K}static OrthoOffCenterRH(V,h,mV,t,L,N,A){const k=new c;return c.OrthoOffCenterRHToRef(V,h,mV,t,L,N,k,A),k}static OrthoOffCenterRHToRef(V,h,mV,t,L,N,A,k){return c.OrthoOffCenterLHToRef(V,h,mV,t,L,N,A,k),A.Kk[10]*=-1,A}static ObliqueOffCenterRHToRef(V,h,mV,t,L,N,A,k,C,K,o){const n=A*Math.cos(k),q=A*Math.sin(k);return c.TranslationToRef(0,0,C,z.Matrix[1]),c.FromValuesToRef(1,0,0,0,0,1,0,0,n,q,1,0,0,0,0,1,z.Matrix[0]),z.Matrix[1].multiplyToRef(z.Matrix[0],z.Matrix[0]),c.TranslationToRef(0,0,-C,z.Matrix[1]),z.Matrix[0].multiplyToRef(z.Matrix[1],z.Matrix[0]),c.OrthoOffCenterRHToRef(V,h,mV,t,L,N,K,o),z.Matrix[0].multiplyToRef(K,K),K}static PerspectiveLH(V,h,mV,t,L){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const A=new c,k=2*mV/V,C=2*mV/h,K=(t+mV)/(t-mV),o=-2*t*mV/(t-mV),n=Math.tan(N);return c.FromValuesToRef(k,0,0,0,0,C,0,n,0,0,K,1,0,0,o,0,A),L&&A.multiplyToRef(J,A),A._updateIdentityStatus(!1),A}static PerspectiveFovLH(V,h,mV,t,L){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,A=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const k=new c;return c.PerspectiveFovLHToRef(V,h,mV,t,k,!0,L,N,A),k}static PerspectiveFovLHToRef(V,h,mV,t,L){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],A=arguments.length>6?arguments[6]:void 0,k=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,C=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const K=mV,o=t,n=1/Math.tan(.5*V),q=N?n/h:n,x=N?n:n*h,R=C&&0===K?-1:0!==o?(o+K)/(o-K):1,d=C&&0===K?2*o:0!==o?-2*o*K/(o-K):-2*K,s=Math.tan(k);return c.FromValuesToRef(q,0,0,0,0,x,0,s,0,0,R,1,0,0,d,0,L),A&&L.multiplyToRef(J,L),L._updateIdentityStatus(!1),L}static PerspectiveFovReverseLHToRef(V,h,mV,t,L){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],A=arguments.length>6?arguments[6]:void 0,k=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const C=1/Math.tan(.5*V),K=N?C/h:C,o=N?C:C*h,n=Math.tan(k);return c.FromValuesToRef(K,0,0,0,0,o,0,n,0,0,-mV,1,0,0,1,0,L),A&&L.multiplyToRef(J,L),L._updateIdentityStatus(!1),L}static PerspectiveFovRH(V,h,mV,t,L){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,A=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const k=new c;return c.PerspectiveFovRHToRef(V,h,mV,t,k,!0,L,N,A),k}static PerspectiveFovRHToRef(V,h,mV,t,L){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],A=arguments.length>6?arguments[6]:void 0,k=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,C=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const K=mV,o=t,n=1/Math.tan(.5*V),q=N?n/h:n,x=N?n:n*h,R=C&&0===K?1:0!==o?-(o+K)/(o-K):-1,d=C&&0===K?2*o:0!==o?-2*o*K/(o-K):-2*K,s=Math.tan(k);return c.FromValuesToRef(q,0,0,0,0,x,0,s,0,0,R,-1,0,0,d,0,L),A&&L.multiplyToRef(J,L),L._updateIdentityStatus(!1),L}static PerspectiveFovReverseRHToRef(V,h,mV,t,L){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],A=arguments.length>6?arguments[6]:void 0,k=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const C=1/Math.tan(.5*V),K=N?C/h:C,o=N?C:C*h,n=Math.tan(k);return c.FromValuesToRef(K,0,0,0,0,o,0,n,0,0,-mV,-1,0,0,-1,0,L),A&&L.multiplyToRef(J,L),L._updateIdentityStatus(!1),L}static GetFinalMatrix(V,h,mV,t,L,N){const A=V.width,k=V.height,C=V.x,K=V.y,o=c.FromValues(A/2,0,0,0,0,-k/2,0,0,0,0,N-L,0,C+A/2,k/2+K,L,1),n=new c;return h.multiplyToRef(mV,n),n.multiplyToRef(t,n),n.multiplyToRef(o,n)}static GetAsMatrix2x2(V){const h=V.m,mV=[h[0],h[1],h[4],h[5]];return A.e.MatrixUse64Bits?mV:new Float32Array(mV)}static GetAsMatrix3x3(V){const h=V.m,mV=[h[0],h[1],h[2],h[4],h[5],h[6],h[8],h[9],h[10]];return A.e.MatrixUse64Bits?mV:new Float32Array(mV)}static Transpose(V){const h=new c;return c.TransposeToRef(V,h),h}static TransposeToRef(V,h){const mV=V.m,t=mV[0],L=mV[4],N=mV[8],A=mV[12],k=mV[1],C=mV[5],K=mV[9],o=mV[13],n=mV[2],q=mV[6],x=mV[10],R=mV[14],d=mV[3],s=mV[7],M=mV[11],c=mV[15],z=h.Kk;return z[0]=t,z[1]=L,z[2]=N,z[3]=A,z[4]=k,z[5]=C,z[6]=K,z[7]=o,z[8]=n,z[9]=q,z[10]=x,z[11]=R,z[12]=d,z[13]=s,z[14]=M,z[15]=c,h.markAsUpdated(),h._updateIdentityStatus(V._isIdentity,V._isIdentityDirty),h}static Reflection(V){const h=new c;return c.ReflectionToRef(V,h),h}static ReflectionToRef(V,h){V.normalize();const mV=V.normal.x,t=V.normal.y,L=V.normal.z,N=-2*mV,A=-2*t,k=-2*L;return c.FromValuesToRef(N*mV+1,A*mV,k*mV,0,N*t,A*t+1,k*t,0,N*L,A*L,k*L+1,0,N*V.d,A*V.d,k*V.d,1,h),h}static FromXYZAxesToRef(V,h,mV,t){return c.FromValuesToRef(V._x,V._y,V._z,0,h._x,h._y,h._z,0,mV._x,mV._y,mV._z,0,0,0,0,1,t),t}static FromQuaternionToRef(V,h){const mV=V._x*V._x,t=V._y*V._y,L=V._z*V._z,N=V._x*V._y,A=V._z*V._w,k=V._z*V._x,C=V._y*V._w,K=V._y*V._z,o=V._x*V._w;return h.Kk[0]=1-2*(t+L),h.Kk[1]=2*(N+A),h.Kk[2]=2*(k-C),h.Kk[3]=0,h.Kk[4]=2*(N-A),h.Kk[5]=1-2*(L+mV),h.Kk[6]=2*(K+o),h.Kk[7]=0,h.Kk[8]=2*(k+C),h.Kk[9]=2*(K-o),h.Kk[10]=1-2*(t+mV),h.Kk[11]=0,h.Kk[12]=0,h.Kk[13]=0,h.Kk[14]=0,h.Kk[15]=1,h.markAsUpdated(),h}}c._IdentityReadOnly=c.Identity(),Object.defineProperties(c.prototype,{dimension:{value:[4,4]},rank:{value:2}});class z{}z.sh=(0,L.e)(11,d.Zero),z.Matrix=(0,L.e)(2,c.Identity),z.Quaternion=(0,L.e)(3,M.Zero);class Q{}Q.Vector2=(0,L.e)(3,R.Zero),Q.sh=(0,L.e)(13,d.Zero),Q.Vector4=(0,L.e)(3,s.Zero),Q.Quaternion=(0,L.e)(3,M.Zero),Q.Matrix=(0,L.e)(8,c.Identity),(0,N.i)("BABYLON.Vector2",R),(0,N.i)("BABYLON.Vector3",d),(0,N.i)("BABYLON.Vector4",s),(0,N.i)("BABYLON.Matrix",c);const J=c.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12433:(V,h,mV)=>{function t(V,h){const mV=[];for(let t=0;t<V;++t)mV.push(h());return mV}function L(V,h){return t(V,h)}mV.d(h,{c:()=>t,e:()=>L,h:()=>A});const N=["push","splice","pop","shift","unshift"];function A(V,h){const mV=N.map((mV=>function(V,h,mV){const t=V[h];if("function"!==typeof t)return null;const L=function(){const t=V.length,N=L.previous.apply(V,arguments);return mV(h,t),N};return t.next=L,L.previous=t,V[h]=L,()=>{const mV=L.previous;if(!mV)return;const t=L.next;t?(mV.next=t,t.previous=mV):(mV.next=void 0,V[h]=mV),L.next=void 0,L.previous=void 0}}(V,mV,h)));return()=>{for(const V of mV)null===V||void 0===V||V()}}}}]);