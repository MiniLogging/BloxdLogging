"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[14],{12343:(H,u,J)=>{J.d(u,{d:()=>w,g:()=>h,k:()=>O,n:()=>U});const O=1/2.2,U=2.2,h=(1+Math.sqrt(5))/2,w=.001},12349:(H,u,J)=>{function O(H){return parseInt(H.toString().replace(/\W/g,""))}function U(H,u){let J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(H-u)<=J}function h(H,u,J){let O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return H<u-O||H>J+O}function w(H,u){return H===u?H:Math.random()*(u-H)+H}function g(H,u,J){return H+(u-H)*J}function B(H,u,J){let O=p(u-H,360);return O>180&&(O-=360),H+O*P(J)}function b(H,u,J){let O=0;return O=H!=u?P((J-H)/(u-H)):0,O}function d(H,u,J,O,U){const h=U*U,w=U*h;return H*(2*w-3*h+1)+J*(-2*w+3*h)+u*(w-2*h+U)+O*(w-h)}function G(H,u,J,O,U){const h=U*U;return 6*(h-U)*H+(3*h-4*U+1)*u+6*(-h+U)*J+(3*h-2*U)*O}function P(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(J,Math.max(u,H))}function mH(H){return H-=2*Math.PI*Math.floor((H+Math.PI)/(2*Math.PI))}function l(H){const u=H.toString(16);return H<=15?("0"+u).toUpperCase():u.toUpperCase()}function r(H){if(Math.log2)return Math.floor(Math.log2(H));if(H<0)return NaN;if(0===H)return-1/0;let u=0;if(H<1){for(;H<1;)u++,H*=2;u=-u}else if(H>1)for(;H>1;)u++,H=Math.floor(H/2);return u}function p(H,u){return H-Math.floor(H/u)*u}function a(H,u,J){return(H-u)/(J-u)}function k(H,u,J){return H*(J-u)+u}function C(H,u){let J=p(u-H,360);return J>180&&(J-=360),J}function j(H,u){const J=p(H,2*u);return u-Math.abs(J-u)}function M(H,u,J){let O=P(J);return O=-2*O*O*O+3*O*O,u*O+H*(1-O)}function L(H,u,J){let O=0;return O=Math.abs(u-H)<=J?u:H+Math.sign(u-H)*J,O}function Z(H,u,J){const O=C(H,u);let U=0;return U=-J<O&&O<J?u:L(H,u=H+O,J),U}function Y(H,u,J){return(H-u)/(J-u)}function F(H,u,J){return(J-u)*H+u}function s(H,u){const J=H%u;return 0===J?u:s(u,J)}J.r(u),J.d(u,{Clamp:()=>P,DeltaAngle:()=>C,Denormalize:()=>k,ExtractAsInt:()=>O,Hermite:()=>d,Hermite1stDerivative:()=>G,HighestCommonFactor:()=>s,ILog2:()=>r,InverseLerp:()=>b,Lerp:()=>g,LerpAngle:()=>B,MoveTowards:()=>L,MoveTowardsAngle:()=>Z,Normalize:()=>a,NormalizeRadians:()=>mH,OutsideRange:()=>h,PercentToRange:()=>F,PingPong:()=>j,RandomRange:()=>w,RangeToPercent:()=>Y,Repeat:()=>p,SmoothStep:()=>M,ToHex:()=>l,WithinEpsilon:()=>U})},12338:(H,u,J)=>{J.r(u),J.d(u,{Matrix:()=>k,Quaternion:()=>a,TmpVectors:()=>j,Vector2:()=>l,lu:()=>r,Vector4:()=>p});var O=J(12343),U=J(12345),h=J(12304),w=J(12277),g=J(12203),B=J(12349);class b{}function d(H,u,J){let O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const U=H.Hg(),h=u.Hg(),w=U[0],g=U[1],B=U[2],b=U[3],d=U[4],G=U[5],P=U[6],mH=U[7],l=U[8],r=U[9],p=U[10],a=U[11],k=U[12],C=U[13],j=U[14],M=U[15],L=h[0],Z=h[1],Y=h[2],F=h[3],s=h[4],A=h[5],t=h[6],e=h[7],c=h[8],n=h[9],V=h[10],T=h[11],R=h[12],X=h[13],W=h[14],f=h[15];J[O]=w*L+g*s+B*c+b*R,J[O+1]=w*Z+g*A+B*n+b*X,J[O+2]=w*Y+g*t+B*V+b*W,J[O+3]=w*F+g*e+B*T+b*f,J[O+4]=d*L+G*s+P*c+mH*R,J[O+5]=d*Z+G*A+P*n+mH*X,J[O+6]=d*Y+G*t+P*V+mH*W,J[O+7]=d*F+G*e+P*T+mH*f,J[O+8]=l*L+r*s+p*c+a*R,J[O+9]=l*Z+r*A+p*n+a*X,J[O+10]=l*Y+r*t+p*V+a*W,J[O+11]=l*F+r*e+p*T+a*f,J[O+12]=k*L+C*s+j*c+M*R,J[O+13]=k*Z+C*A+j*n+M*X,J[O+14]=k*Y+C*t+j*V+M*W,J[O+15]=k*F+C*e+j*T+M*f}function G(H,u){let J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const O=H.Hg();u[J]=O[0],u[J+1]=O[1],u[J+2]=O[2],u[J+3]=O[3],u[J+4]=O[4],u[J+5]=O[5],u[J+6]=O[6],u[J+7]=O[7],u[J+8]=O[8],u[J+9]=O[9],u[J+10]=O[10],u[J+11]=O[11],u[J+12]=O[12],u[J+13]=O[13],u[J+14]=O[14],u[J+15]=O[15]}function P(H,u){const J=H.Hg(),O=J[0],U=J[1],h=J[2],w=J[3],g=J[4],B=J[5],b=J[6],d=J[7],G=J[8],P=J[9],mH=J[10],l=J[11],r=J[12],p=J[13],a=J[14],k=J[15],C=mH*k-a*l,j=P*k-p*l,M=P*a-p*mH,L=G*k-r*l,Z=G*a-mH*r,Y=G*p-r*P,F=+(B*C-b*j+d*M),s=-(g*C-b*L+d*Z),A=+(g*j-B*L+d*Y),t=-(g*M-B*Z+b*Y),e=O*F+U*s+h*A+w*t;if(0===e)return!1;const c=1/e,n=b*k-a*d,V=B*k-p*d,T=B*a-p*b,R=g*k-r*d,X=g*a-r*b,W=g*p-r*B,f=b*l-mH*d,i=B*l-P*d,S=B*mH-P*b,v=g*l-G*d,I=g*mH-G*b,D=g*P-G*B,o=-(U*C-h*j+w*M),y=+(O*C-h*L+w*Z),x=-(O*j-U*L+w*Y),z=+(O*M-U*Z+h*Y),K=+(U*n-h*V+w*T),N=-(O*n-h*R+w*X),q=+(O*V-U*R+w*W),E=-(O*T-U*X+h*W),Q=-(U*f-h*i+w*S),HH=+(O*f-h*v+w*I),uH=-(O*i-U*v+w*D),JH=+(O*S-U*I+h*D);return u[0]=F*c,u[1]=o*c,u[2]=K*c,u[3]=Q*c,u[4]=s*c,u[5]=y*c,u[6]=N*c,u[7]=HH*c,u[8]=A*c,u[9]=x*c,u[10]=q*c,u[11]=uH*c,u[12]=t*c,u[13]=z*c,u[14]=E*c,u[15]=JH*c,!0}b._UpdateFlagSeed=0;const mH=H=>parseInt(H.toString().replace(/\W/g,""));class l{constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=H,this.y=u}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let H=mH(this.x);return H=397*H^mH(this.y),H}toArray(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[u]=this.x,H[u+1]=this.y,this}mO(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(H,u,this),this}Hg(){return[this.x,this.y]}O(H){return this.x=H.x,this.y=H.y,this}kg(H,u){return this.x=H,this.y=u,this}set(H,u){return this.kg(H,u)}jg(H){return this.kg(H,H)}add(H){return new l(this.x+H.x,this.y+H.y)}addToRef(H,u){return u.x=this.x+H.x,u.y=this.y+H.y,u}addInPlace(H){return this.x+=H.x,this.y+=H.y,this}addInPlaceFromFloats(H,u){return this.x+=H,this.y+=u,this}addVector3(H){return new l(this.x+H.x,this.y+H.y)}ru(H){return new l(this.x-H.x,this.y-H.y)}subtractToRef(H,u){return u.x=this.x-H.x,u.y=this.y-H.y,u}jP(H){return this.x-=H.x,this.y-=H.y,this}multiplyInPlace(H){return this.x*=H.x,this.y*=H.y,this}multiply(H){return new l(this.x*H.x,this.y*H.y)}multiplyToRef(H,u){return u.x=this.x*H.x,u.y=this.y*H.y,u}multiplyByFloats(H,u){return new l(this.x*H,this.y*u)}divide(H){return new l(this.x/H.x,this.y/H.y)}divideToRef(H,u){return u.x=this.x/H.x,u.y=this.y/H.y,u}divideInPlace(H){return this.x=this.x/H.x,this.y=this.y/H.y,this}minimizeInPlace(H){return this.minimizeInPlaceFromFloats(H.x,H.y)}maximizeInPlace(H){return this.maximizeInPlaceFromFloats(H.x,H.y)}minimizeInPlaceFromFloats(H,u){return this.x=Math.min(H,this.x),this.y=Math.min(u,this.y),this}maximizeInPlaceFromFloats(H,u){return this.x=Math.max(H,this.x),this.y=Math.max(u,this.y),this}subtractFromFloats(H,u){return new l(this.x-H,this.y-u)}subtractFromFloatsToRef(H,u,J){return J.x=this.x-H,J.y=this.y-u,J}negate(){return new l(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(H){return H.x=-this.x,H.y=-this.y,H}scaleInPlace(H){return this.x*=H,this.y*=H,this}scale(H){return new l(this.x*H,this.y*H)}scaleToRef(H,u){return u.x=this.x*H,u.y=this.y*H,u}scaleAndAddToRef(H,u){return u.x+=this.x*H,u.y+=this.y*H,u}equals(H){return H&&this.x===H.x&&this.y===H.y}equalsWithEpsilon(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O.d;return H&&(0,B.WithinEpsilon)(this.x,H.x,u)&&(0,B.WithinEpsilon)(this.y,H.y,u)}equalsToFloats(H,u){return this.x===H&&this.y===u}floor(){return new l(Math.floor(this.x),Math.floor(this.y))}floorToRef(H){return H.x=Math.floor(this.x),H.y=Math.floor(this.y),H}fract(){return new l(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(H){return H.x=this.x-Math.floor(this.x),H.y=this.y-Math.floor(this.y),H}rotate(H){return this.rotateToRef(H,new l)}rotateToRef(H,u){const J=Math.cos(H),O=Math.sin(H);return u.x=J*this.x-O*this.y,u.y=O*this.x+J*this.y,u}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(H){return 0===H||1===H?this:this.scaleInPlace(1/H)}normalizeToNew(){const H=new l;return this.normalizeToRef(H),H}normalizeToRef(H){const u=this.length();return 0===u&&(H.x=this.x,H.y=this.y),this.scaleToRef(1/u,H)}clone(){return new l(this.x,this.y)}dot(H){return this.x*H.x+this.y*H.y}static Zero(){return new l(0,0)}static One(){return new l(1,1)}static Random(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new l((0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u))}static RandomToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).kg((0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u))}static get ZeroReadOnly(){return l._ZeroReadOnly}static Cu(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new l(H[u],H[u+1])}static FromArrayToRef(H,u,J){return J.x=H[u],J.y=H[u+1],J}static FromFloatsToRef(H,u,J){return J.kg(H,u),J}static CatmullRom(H,u,J,O,U){const h=U*U,w=U*h,g=.5*(2*u.x+(-H.x+J.x)*U+(2*H.x-5*u.x+4*J.x-O.x)*h+(-H.x+3*u.x-3*J.x+O.x)*w),B=.5*(2*u.y+(-H.y+J.y)*U+(2*H.y-5*u.y+4*J.y-O.y)*h+(-H.y+3*u.y-3*J.y+O.y)*w);return new l(g,B)}static ClampToRef(H,u,J,O){return O.x=(0,B.Clamp)(H.x,u.x,J.x),O.y=(0,B.Clamp)(H.y,u.y,J.y),O}static Clamp(H,u,J){const O=(0,B.Clamp)(H.x,u.x,J.x),U=(0,B.Clamp)(H.y,u.y,J.y);return new l(O,U)}static Hermite(H,u,J,O,U){const h=U*U,w=U*h,g=2*w-3*h+1,B=-2*w+3*h,b=w-2*h+U,d=w-h,G=H.x*g+J.x*B+u.x*b+O.x*d,P=H.y*g+J.y*B+u.y*b+O.y*d;return new l(G,P)}static Hermite1stDerivative(H,u,J,O,U){return this.Hermite1stDerivativeToRef(H,u,J,O,U,new l)}static Hermite1stDerivativeToRef(H,u,J,O,U,h){const w=U*U;return h.x=6*(w-U)*H.x+(3*w-4*U+1)*u.x+6*(-w+U)*J.x+(3*w-2*U)*O.x,h.y=6*(w-U)*H.y+(3*w-4*U+1)*u.y+6*(-w+U)*J.y+(3*w-2*U)*O.y,h}static Lerp(H,u,J){return l.LerpToRef(H,u,J,new l)}static LerpToRef(H,u,J,O){return O.x=H.x+(u.x-H.x)*J,O.y=H.y+(u.y-H.y)*J,O}static Dot(H,u){return H.x*u.x+H.y*u.y}static Normalize(H){return l.NormalizeToRef(H,new l)}static NormalizeToRef(H,u){return H.normalizeToRef(u),u}static Minimize(H,u){const J=H.x<u.x?H.x:u.x,O=H.y<u.y?H.y:u.y;return new l(J,O)}static Maximize(H,u){const J=H.x>u.x?H.x:u.x,O=H.y>u.y?H.y:u.y;return new l(J,O)}static Transform(H,u){return l.TransformToRef(H,u,new l)}static TransformToRef(H,u,J){const O=u.m,U=H.x*O[0]+H.y*O[4]+O[12],h=H.x*O[1]+H.y*O[5]+O[13];return J.x=U,J.y=h,J}static PointInTriangle(H,u,J,O){const U=.5*(-J.y*O.x+u.y*(-J.x+O.x)+u.x*(J.y-O.y)+J.x*O.y),h=U<0?-1:1,w=(u.y*O.x-u.x*O.y+(O.y-u.y)*H.x+(u.x-O.x)*H.y)*h,g=(u.x*J.y-u.y*J.x+(u.y-J.y)*H.x+(J.x-u.x)*H.y)*h;return w>0&&g>0&&w+g<2*U*h}static Distance(H,u){return Math.sqrt(l.DistanceSquared(H,u))}static DistanceSquared(H,u){const J=H.x-u.x,O=H.y-u.y;return J*J+O*O}static Center(H,u){return l.CenterToRef(H,u,new l)}static CenterToRef(H,u,J){return J.kg((H.x+u.x)/2,(H.y+u.y)/2)}static DistanceOfPointFromSegment(H,u,J){const O=l.DistanceSquared(u,J);if(0===O)return l.Distance(H,u);const U=J.ru(u),h=Math.max(0,Math.min(1,l.Dot(H.ru(u),U)/O)),w=u.add(U.multiplyByFloats(h,h));return l.Distance(H,w)}}l._V8PerformanceHack=new l(.5,.5),l._ZeroReadOnly=l.Zero(),Object.defineProperties(l.prototype,{dimension:{value:[2]},rank:{value:1}});class r{get x(){return this._x}set x(H){this._x=H,this._isDirty=!0}get y(){return this._y}set y(H){this._y=H,this._isDirty=!0}get z(){return this._z}set z(H){this._z=H,this._isDirty=!0}constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=H,this._y=u,this._z=J}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"lu"}getHashCode(){let H=mH(this._x);return H=397*H^mH(this._y),H=397*H^mH(this._z),H}Hg(){return[this._x,this._y,this._z]}toArray(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[u]=this._x,H[u+1]=this._y,H[u+2]=this._z,this}mO(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r.FromArrayToRef(H,u,this),this}toQuaternion(){return a.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(H){return this._x+=H._x,this._y+=H._y,this._z+=H._z,this._isDirty=!0,this}addInPlaceFromFloats(H,u,J){return this._x+=H,this._y+=u,this._z+=J,this._isDirty=!0,this}add(H){return new r(this._x+H._x,this._y+H._y,this._z+H._z)}addToRef(H,u){return u._x=this._x+H._x,u._y=this._y+H._y,u._z=this._z+H._z,u._isDirty=!0,u}jP(H){return this._x-=H._x,this._y-=H._y,this._z-=H._z,this._isDirty=!0,this}ru(H){return new r(this._x-H._x,this._y-H._y,this._z-H._z)}subtractToRef(H,u){return this.subtractFromFloatsToRef(H._x,H._y,H._z,u)}subtractFromFloats(H,u,J){return new r(this._x-H,this._y-u,this._z-J)}subtractFromFloatsToRef(H,u,J,O){return O._x=this._x-H,O._y=this._y-u,O._z=this._z-J,O._isDirty=!0,O}negate(){return new r(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(H){return H._x=-1*this._x,H._y=-1*this._y,H._z=-1*this._z,H._isDirty=!0,H}scaleInPlace(H){return this._x*=H,this._y*=H,this._z*=H,this._isDirty=!0,this}scale(H){return new r(this._x*H,this._y*H,this._z*H)}scaleToRef(H,u){return u._x=this._x*H,u._y=this._y*H,u._z=this._z*H,u._isDirty=!0,u}getNormalToRef(H){const u=this.length();let J=Math.acos(this._y/u);const O=Math.atan2(this._z,this._x);J>Math.PI/2?J-=Math.PI/2:J+=Math.PI/2;const U=u*Math.sin(J)*Math.cos(O),h=u*Math.cos(J),w=u*Math.sin(J)*Math.sin(O);return H.set(U,h,w),H}applyRotationQuaternionToRef(H,u){const J=this._x,O=this._y,U=this._z,h=H._x,w=H._y,g=H._z,B=H._w,b=2*(w*U-g*O),d=2*(g*J-h*U),G=2*(h*O-w*J);return u._x=J+B*b+w*G-g*d,u._y=O+B*d+g*b-h*G,u._z=U+B*G+h*d-w*b,u._isDirty=!0,u}applyRotationQuaternionInPlace(H){return this.applyRotationQuaternionToRef(H,this)}applyRotationQuaternion(H){return this.applyRotationQuaternionToRef(H,new r)}scaleAndAddToRef(H,u){return u._x+=this._x*H,u._y+=this._y*H,u._z+=this._z*H,u._isDirty=!0,u}projectOnPlane(H,u){return this.projectOnPlaneToRef(H,u,new r)}projectOnPlaneToRef(H,u,J){const O=H.normal,U=H.d,h=C.lu[0];this.subtractToRef(u,h),h.normalize();const w=r.Dot(h,O);if(Math.abs(w)<1e-10)J.jg(1/0);else{const H=-(r.Dot(u,O)+U)/w,g=h.scaleInPlace(H);u.addToRef(g,J)}return J}equals(H){return H&&this._x===H._x&&this._y===H._y&&this._z===H._z}equalsWithEpsilon(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O.d;return H&&(0,B.WithinEpsilon)(this._x,H._x,u)&&(0,B.WithinEpsilon)(this._y,H._y,u)&&(0,B.WithinEpsilon)(this._z,H._z,u)}equalsToFloats(H,u,J){return this._x===H&&this._y===u&&this._z===J}multiplyInPlace(H){return this._x*=H._x,this._y*=H._y,this._z*=H._z,this._isDirty=!0,this}multiply(H){return this.multiplyByFloats(H._x,H._y,H._z)}multiplyToRef(H,u){return u._x=this._x*H._x,u._y=this._y*H._y,u._z=this._z*H._z,u._isDirty=!0,u}multiplyByFloats(H,u,J){return new r(this._x*H,this._y*u,this._z*J)}divide(H){return new r(this._x/H._x,this._y/H._y,this._z/H._z)}divideToRef(H,u){return u._x=this._x/H._x,u._y=this._y/H._y,u._z=this._z/H._z,u._isDirty=!0,u}divideInPlace(H){return this._x=this._x/H._x,this._y=this._y/H._y,this._z=this._z/H._z,this._isDirty=!0,this}minimizeInPlace(H){return this.minimizeInPlaceFromFloats(H._x,H._y,H._z)}maximizeInPlace(H){return this.maximizeInPlaceFromFloats(H._x,H._y,H._z)}minimizeInPlaceFromFloats(H,u,J){return H<this._x&&(this.x=H),u<this._y&&(this.y=u),J<this._z&&(this.z=J),this}maximizeInPlaceFromFloats(H,u,J){return H>this._x&&(this.x=H),u>this._y&&(this.y=u),J>this._z&&(this.z=J),this}isNonUniformWithinEpsilon(H){const u=Math.abs(this._x),J=Math.abs(this._y);if(!(0,B.WithinEpsilon)(u,J,H))return!0;const O=Math.abs(this._z);return!(0,B.WithinEpsilon)(u,O,H)||!(0,B.WithinEpsilon)(J,O,H)}get isNonUniform(){const H=Math.abs(this._x);if(H!==Math.abs(this._y))return!0;return H!==Math.abs(this._z)}floorToRef(H){return H._x=Math.floor(this._x),H._y=Math.floor(this._y),H._z=Math.floor(this._z),H._isDirty=!0,H}floor(){return new r(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(H){return H._x=this._x-Math.floor(this._x),H._y=this._y-Math.floor(this._y),H._z=this._z-Math.floor(this._z),H._isDirty=!0,H}fract(){return new r(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(H){if("xyz"===(H=H.toLowerCase()))return this;const u=C.lu[0].O(this);return this.x=u[H[0]],this.y=u[H[1]],this.z=u[H[2]],this}rotateByQuaternionToRef(H,u){return H.toRotationMatrix(C.Matrix[0]),r.TransformCoordinatesToRef(this,C.Matrix[0],u),u}rotateByQuaternionAroundPointToRef(H,u,J){return this.subtractToRef(u,C.lu[0]),C.lu[0].rotateByQuaternionToRef(H,C.lu[0]),u.addToRef(C.lu[0],J),J}cross(H){return r.CrossToRef(this,H,new r)}normalizeFromLength(H){return 0===H||1===H?this:this.scaleInPlace(1/H)}normalizeToNew(){return this.normalizeToRef(new r)}normalizeToRef(H){const u=this.length();return 0===u||1===u?(H._x=this._x,H._y=this._y,H._z=this._z,H._isDirty=!0,H):this.scaleToRef(1/u,H)}clone(){return new r(this._x,this._y,this._z)}O(H){return this.kg(H._x,H._y,H._z)}kg(H,u,J){return this._x=H,this._y=u,this._z=J,this._isDirty=!0,this}set(H,u,J){return this.kg(H,u,J)}jg(H){return this._x=this._y=this._z=H,this._isDirty=!0,this}static GetClipFactor(H,u,J,O){const U=r.Dot(H,J);return(U-O)/(U-r.Dot(u,J))}static GetAngleBetweenVectors(H,u,J){const O=H.normalizeToRef(C.lu[1]),U=u.normalizeToRef(C.lu[2]);let h=r.Dot(O,U);h=(0,B.Clamp)(h,-1,1);const w=Math.acos(h),g=C.lu[3];return r.CrossToRef(O,U,g),r.Dot(g,J)>0?isNaN(w)?0:w:isNaN(w)?-Math.PI:-Math.acos(h)}static GetAngleBetweenVectorsOnPlane(H,u,J){C.lu[0].O(H);const O=C.lu[0];C.lu[1].O(u);const U=C.lu[1];C.lu[2].O(J);const h=C.lu[2],w=C.lu[3],g=C.lu[4];O.normalize(),U.normalize(),h.normalize(),r.CrossToRef(h,O,w),r.CrossToRef(w,h,g);const b=Math.atan2(r.Dot(U,w),r.Dot(U,g));return(0,B.NormalizeRadians)(b)}static PitchYawRollToMoveBetweenPointsToRef(H,u,J){const O=j.lu[0];return u.subtractToRef(H,O),J._y=Math.atan2(O.x,O.z)||0,J._x=Math.atan2(Math.sqrt(O.x**2+O.z**2),O.y)||0,J._z=0,J._isDirty=!0,J}static PitchYawRollToMoveBetweenPoints(H,u){const J=r.Zero();return r.PitchYawRollToMoveBetweenPointsToRef(H,u,J)}static SlerpToRef(H,u,J,U){J=(0,B.Clamp)(J,0,1);const h=C.lu[0],w=C.lu[1];h.O(H);const g=h.length();h.normalizeFromLength(g),w.O(u);const b=w.length();w.normalizeFromLength(b);const d=r.Dot(h,w);let G,P;if(d<1-O.d){const H=Math.acos(d),u=1/Math.sin(H);G=Math.sin((1-J)*H)*u,P=Math.sin(J*H)*u}else G=1-J,P=J;return h.scaleInPlace(G),w.scaleInPlace(P),U.O(h).addInPlace(w),U.scaleInPlace((0,B.Lerp)(g,b,J)),U}static SmoothToRef(H,u,J,O,U){return r.SlerpToRef(H,u,0===O?1:J/O,U),U}static Cu(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new r(H[u],H[u+1],H[u+2])}static FromFloatArray(H,u){return r.Cu(H,u)}static FromArrayToRef(H,u,J){return J._x=H[u],J._y=H[u+1],J._z=H[u+2],J._isDirty=!0,J}static FromFloatArrayToRef(H,u,J){return r.FromArrayToRef(H,u,J)}static FromFloatsToRef(H,u,J,O){return O.kg(H,u,J),O}static Zero(){return new r(0,0,0)}static One(){return new r(1,1,1)}static Up(){return new r(0,1,0)}static get UpReadOnly(){return r._UpReadOnly}static get DownReadOnly(){return r._DownReadOnly}static get RightReadOnly(){return r._RightReadOnly}static get LeftReadOnly(){return r._LeftReadOnly}static get LeftHandedForwardReadOnly(){return r._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return r._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return r._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return r._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return r._ZeroReadOnly}static get OneReadOnly(){return r._OneReadOnly}static Down(){return new r(0,-1,0)}static Forward(){return new r(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new r(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new r(1,0,0)}static Left(){return new r(-1,0,0)}static Random(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new r((0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u))}static RandomToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).kg((0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u))}static TransformCoordinates(H,u){const J=r.Zero();return r.TransformCoordinatesToRef(H,u,J),J}static TransformCoordinatesToRef(H,u,J){return r.TransformCoordinatesFromFloatsToRef(H._x,H._y,H._z,u,J),J}static TransformCoordinatesFromFloatsToRef(H,u,J,O,U){const h=O.m,w=H*h[0]+u*h[4]+J*h[8]+h[12],g=H*h[1]+u*h[5]+J*h[9]+h[13],B=H*h[2]+u*h[6]+J*h[10]+h[14],b=1/(H*h[3]+u*h[7]+J*h[11]+h[15]);return U._x=w*b,U._y=g*b,U._z=B*b,U._isDirty=!0,U}static TransformNormal(H,u){const J=r.Zero();return r.TransformNormalToRef(H,u,J),J}static TransformNormalToRef(H,u,J){return this.TransformNormalFromFloatsToRef(H._x,H._y,H._z,u,J),J}static TransformNormalFromFloatsToRef(H,u,J,O,U){const h=O.m;return U._x=H*h[0]+u*h[4]+J*h[8],U._y=H*h[1]+u*h[5]+J*h[9],U._z=H*h[2]+u*h[6]+J*h[10],U._isDirty=!0,U}static CatmullRom(H,u,J,O,U){const h=U*U,w=U*h,g=.5*(2*u._x+(-H._x+J._x)*U+(2*H._x-5*u._x+4*J._x-O._x)*h+(-H._x+3*u._x-3*J._x+O._x)*w),B=.5*(2*u._y+(-H._y+J._y)*U+(2*H._y-5*u._y+4*J._y-O._y)*h+(-H._y+3*u._y-3*J._y+O._y)*w),b=.5*(2*u._z+(-H._z+J._z)*U+(2*H._z-5*u._z+4*J._z-O._z)*h+(-H._z+3*u._z-3*J._z+O._z)*w);return new r(g,B,b)}static Clamp(H,u,J){const O=new r;return r.ClampToRef(H,u,J,O),O}static ClampToRef(H,u,J,O){let U=H._x;U=U>J._x?J._x:U,U=U<u._x?u._x:U;let h=H._y;h=h>J._y?J._y:h,h=h<u._y?u._y:h;let w=H._z;return w=w>J._z?J._z:w,w=w<u._z?u._z:w,O.kg(U,h,w),O}static CheckExtends(H,u,J){u.minimizeInPlace(H),J.maximizeInPlace(H)}static Hermite(H,u,J,O,U){const h=U*U,w=U*h,g=2*w-3*h+1,B=-2*w+3*h,b=w-2*h+U,d=w-h,G=H._x*g+J._x*B+u._x*b+O._x*d,P=H._y*g+J._y*B+u._y*b+O._y*d,mH=H._z*g+J._z*B+u._z*b+O._z*d;return new r(G,P,mH)}static Hermite1stDerivative(H,u,J,O,U){const h=new r;return this.Hermite1stDerivativeToRef(H,u,J,O,U,h),h}static Hermite1stDerivativeToRef(H,u,J,O,U,h){const w=U*U;return h._x=6*(w-U)*H._x+(3*w-4*U+1)*u._x+6*(-w+U)*J._x+(3*w-2*U)*O._x,h._y=6*(w-U)*H._y+(3*w-4*U+1)*u._y+6*(-w+U)*J._y+(3*w-2*U)*O._y,h._z=6*(w-U)*H._z+(3*w-4*U+1)*u._z+6*(-w+U)*J._z+(3*w-2*U)*O._z,h._isDirty=!0,h}static Lerp(H,u,J){const O=new r(0,0,0);return r.LerpToRef(H,u,J,O),O}static LerpToRef(H,u,J,O){return O._x=H._x+(u._x-H._x)*J,O._y=H._y+(u._y-H._y)*J,O._z=H._z+(u._z-H._z)*J,O._isDirty=!0,O}static Dot(H,u){return H._x*u._x+H._y*u._y+H._z*u._z}dot(H){return this._x*H._x+this._y*H._y+this._z*H._z}static Cross(H,u){const J=new r;return r.CrossToRef(H,u,J),J}static CrossToRef(H,u,J){const O=H._y*u._z-H._z*u._y,U=H._z*u._x-H._x*u._z,h=H._x*u._y-H._y*u._x;return J.kg(O,U,h),J}static Normalize(H){const u=r.Zero();return r.NormalizeToRef(H,u),u}static NormalizeToRef(H,u){return H.normalizeToRef(u),u}static Project(H,u,J,O){const U=new r;return r.ProjectToRef(H,u,J,O,U),U}static ProjectToRef(H,u,J,O,U){var h;const w=O.width,B=O.height,b=O.x,d=O.y,G=C.Matrix[1],P=null===(h=g.e.LastCreatedEngine)||void 0===h?void 0:h.isNDCHalfZRange,mH=P?1:.5,l=P?0:.5;k.FromValuesToRef(w/2,0,0,0,0,-B/2,0,0,0,0,mH,0,b+w/2,B/2+d,l,1,G);const p=C.Matrix[0];return u.multiplyToRef(J,p),p.multiplyToRef(G,p),r.TransformCoordinatesToRef(H,p,U),U}static Reflect(H,u){return this.ReflectToRef(H,u,new r)}static ReflectToRef(H,u,J){const O=j.lu[0];return O.O(u).scaleInPlace(2*r.Dot(H,u)),J.O(H).jP(O)}static _UnprojectFromInvertedMatrixToRef(H,u,J){r.TransformCoordinatesToRef(H,u,J);const O=u.m,U=H._x*O[3]+H._y*O[7]+H._z*O[11]+O[15];return(0,B.WithinEpsilon)(U,1)&&J.scaleInPlace(1/U),J}static UnprojectFromTransform(H,u,J,O,U){return this.Unproject(H,u,J,O,U,k.IdentityReadOnly)}static Unproject(H,u,J,O,U,h){const w=new r;return r.UnprojectToRef(H,u,J,O,U,h,w),w}static UnprojectToRef(H,u,J,O,U,h,w){return r.UnprojectFloatsToRef(H._x,H._y,H._z,u,J,O,U,h,w),w}static UnprojectFloatsToRef(H,u,J,O,U,h,w,B,b){var d;const G=C.Matrix[0];h.multiplyToRef(w,G),G.multiplyToRef(B,G),G.invert();const P=C.lu[0];return P.x=H/O*2-1,P.y=-(u/U*2-1),null!==(d=g.e.LastCreatedEngine)&&void 0!==d&&d.isNDCHalfZRange?P.z=J:P.z=2*J-1,r._UnprojectFromInvertedMatrixToRef(P,G,b),b}static Minimize(H,u){const J=new r;return J.O(H),J.minimizeInPlace(u),J}static Maximize(H,u){const J=new r;return J.O(H),J.maximizeInPlace(u),J}static Distance(H,u){return Math.sqrt(r.DistanceSquared(H,u))}static DistanceSquared(H,u){const J=H._x-u._x,O=H._y-u._y,U=H._z-u._z;return J*J+O*O+U*U}static ProjectOnTriangleToRef(H,u,J,U,h){const w=C.lu[0],g=C.lu[1],b=C.lu[2],d=C.lu[3],G=C.lu[4];J.subtractToRef(u,w),U.subtractToRef(u,g),U.subtractToRef(J,b);const P=w.length(),mH=g.length(),l=b.length();if(P<O.d||mH<O.d||l<O.d)return h.O(u),r.Distance(H,u);H.subtractToRef(u,G),r.CrossToRef(w,g,d);const p=d.length();if(p<O.d)return h.O(u),r.Distance(H,u);d.normalizeFromLength(p);let a=G.length();if(a<O.d)return h.O(u),0;G.normalizeFromLength(a);const k=r.Dot(d,G),j=C.lu[5],M=C.lu[6];j.O(d).scaleInPlace(-a*k),M.O(H).addInPlace(j);const L=C.lu[4],Z=C.lu[5],Y=C.lu[7],F=C.lu[8];L.O(w).scaleInPlace(1/P),F.O(g).scaleInPlace(1/mH),L.addInPlace(F).scaleInPlace(-1),Z.O(w).scaleInPlace(-1/P),F.O(b).scaleInPlace(1/l),Z.addInPlace(F).scaleInPlace(-1),Y.O(b).scaleInPlace(-1/l),F.O(g).scaleInPlace(-1/mH),Y.addInPlace(F).scaleInPlace(-1);const s=C.lu[9];let A;s.O(M).jP(u),r.CrossToRef(L,s,F),A=r.Dot(F,d);const t=A;s.O(M).jP(J),r.CrossToRef(Z,s,F),A=r.Dot(F,d);const e=A;s.O(M).jP(U),r.CrossToRef(Y,s,F),A=r.Dot(F,d);const c=A,n=C.lu[10];let V,T;t>0&&e<0?(n.O(w),V=u,T=J):e>0&&c<0?(n.O(b),V=J,T=U):(n.O(g).scaleInPlace(-1),V=U,T=u);const R=C.lu[9],X=C.lu[4];V.subtractToRef(M,F),T.subtractToRef(M,R),r.CrossToRef(F,R,X);if(!(r.Dot(X,d)<0))return h.O(M),Math.abs(a*k);const W=C.lu[5];r.CrossToRef(n,X,W),W.normalize();const f=C.lu[9];f.O(V).jP(M);const i=f.length();if(i<O.d)return h.O(V),r.Distance(H,V);f.normalizeFromLength(i);const S=r.Dot(W,f),v=C.lu[7];v.O(M).addInPlace(W.scaleInPlace(i*S)),F.O(v).jP(V),a=n.length(),n.normalizeFromLength(a);let I=r.Dot(F,n)/Math.max(a,O.d);return I=(0,B.Clamp)(I,0,1),v.O(V).addInPlace(n.scaleInPlace(I*a)),h.O(v),r.Distance(H,v)}static Center(H,u){return r.CenterToRef(H,u,r.Zero())}static CenterToRef(H,u,J){return J.kg((H._x+u._x)/2,(H._y+u._y)/2,(H._z+u._z)/2)}static RotationFromAxis(H,u,J){const O=new r;return r.RotationFromAxisToRef(H,u,J,O),O}static RotationFromAxisToRef(H,u,J,O){const U=C.Quaternion[0];return a.RotationQuaternionFromAxisToRef(H,u,J,U),U.toEulerAnglesToRef(O),O}}r._V8PerformanceHack=new r(.5,.5,.5),r._UpReadOnly=r.Up(),r._DownReadOnly=r.Down(),r._LeftHandedForwardReadOnly=r.Forward(!1),r._RightHandedForwardReadOnly=r.Forward(!0),r._LeftHandedBackwardReadOnly=r.Backward(!1),r._RightHandedBackwardReadOnly=r.Backward(!0),r._RightReadOnly=r.Right(),r._LeftReadOnly=r.Left(),r._ZeroReadOnly=r.Zero(),r._OneReadOnly=r.One(),Object.defineProperties(r.prototype,{dimension:{value:[3]},rank:{value:1}});class p{get x(){return this._x}set x(H){this._x=H,this._isDirty=!0}get y(){return this._y}set y(H){this._y=H,this._isDirty=!0}get z(){return this._z}set z(H){this._z=H,this._isDirty=!0}get w(){return this._w}set w(H){this._w=H,this._isDirty=!0}constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=H,this._y=u,this._z=J,this._w=O}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let H=mH(this._x);return H=397*H^mH(this._y),H=397*H^mH(this._z),H=397*H^mH(this._w),H}Hg(){return[this._x,this._y,this._z,this._w]}toArray(H,u){return void 0===u&&(u=0),H[u]=this._x,H[u+1]=this._y,H[u+2]=this._z,H[u+3]=this._w,this}mO(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p.FromArrayToRef(H,u,this),this}addInPlace(H){return this.x+=H._x,this.y+=H._y,this.z+=H._z,this.w+=H._w,this}addInPlaceFromFloats(H,u,J,O){return this.x+=H,this.y+=u,this.z+=J,this.w+=O,this}add(H){return new p(this._x+H.x,this._y+H.y,this._z+H.z,this._w+H.w)}addToRef(H,u){return u.x=this._x+H.x,u.y=this._y+H.y,u.z=this._z+H.z,u.w=this._w+H.w,u}jP(H){return this.x-=H.x,this.y-=H.y,this.z-=H.z,this.w-=H.w,this}ru(H){return new p(this._x-H.x,this._y-H.y,this._z-H.z,this._w-H.w)}subtractToRef(H,u){return u.x=this._x-H.x,u.y=this._y-H.y,u.z=this._z-H.z,u.w=this._w-H.w,u}subtractFromFloats(H,u,J,O){return new p(this._x-H,this._y-u,this._z-J,this._w-O)}subtractFromFloatsToRef(H,u,J,O,U){return U.x=this._x-H,U.y=this._y-u,U.z=this._z-J,U.w=this._w-O,U}negate(){return new p(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(H){return H.x=-this._x,H.y=-this._y,H.z=-this._z,H.w=-this._w,H}scaleInPlace(H){return this.x*=H,this.y*=H,this.z*=H,this.w*=H,this}scale(H){return new p(this._x*H,this._y*H,this._z*H,this._w*H)}scaleToRef(H,u){return u.x=this._x*H,u.y=this._y*H,u.z=this._z*H,u.w=this._w*H,u}scaleAndAddToRef(H,u){return u.x+=this._x*H,u.y+=this._y*H,u.z+=this._z*H,u.w+=this._w*H,u}equals(H){return H&&this._x===H.x&&this._y===H.y&&this._z===H.z&&this._w===H.w}equalsWithEpsilon(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O.d;return H&&(0,B.WithinEpsilon)(this._x,H.x,u)&&(0,B.WithinEpsilon)(this._y,H.y,u)&&(0,B.WithinEpsilon)(this._z,H.z,u)&&(0,B.WithinEpsilon)(this._w,H.w,u)}equalsToFloats(H,u,J,O){return this._x===H&&this._y===u&&this._z===J&&this._w===O}multiplyInPlace(H){return this.x*=H.x,this.y*=H.y,this.z*=H.z,this.w*=H.w,this}multiply(H){return new p(this._x*H.x,this._y*H.y,this._z*H.z,this._w*H.w)}multiplyToRef(H,u){return u.x=this._x*H.x,u.y=this._y*H.y,u.z=this._z*H.z,u.w=this._w*H.w,u}multiplyByFloats(H,u,J,O){return new p(this._x*H,this._y*u,this._z*J,this._w*O)}divide(H){return new p(this._x/H.x,this._y/H.y,this._z/H.z,this._w/H.w)}divideToRef(H,u){return u.x=this._x/H.x,u.y=this._y/H.y,u.z=this._z/H.z,u.w=this._w/H.w,u}divideInPlace(H){return this.divideToRef(H,this)}minimizeInPlace(H){return H.x<this._x&&(this.x=H.x),H.y<this._y&&(this.y=H.y),H.z<this._z&&(this.z=H.z),H.w<this._w&&(this.w=H.w),this}maximizeInPlace(H){return H.x>this._x&&(this.x=H.x),H.y>this._y&&(this.y=H.y),H.z>this._z&&(this.z=H.z),H.w>this._w&&(this.w=H.w),this}minimizeInPlaceFromFloats(H,u,J,O){return this.x=Math.min(H,this._x),this.y=Math.min(u,this._y),this.z=Math.min(J,this._z),this.w=Math.min(O,this._w),this}maximizeInPlaceFromFloats(H,u,J,O){return this.x=Math.max(H,this._x),this.y=Math.max(u,this._y),this.z=Math.max(J,this._z),this.w=Math.max(O,this._w),this}floorToRef(H){return H.x=Math.floor(this._x),H.y=Math.floor(this._y),H.z=Math.floor(this._z),H.w=Math.floor(this._w),H}floor(){return new p(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(H){return H.x=this._x-Math.floor(this._x),H.y=this._y-Math.floor(this._y),H.z=this._z-Math.floor(this._z),H.w=this._w-Math.floor(this._w),H}fract(){return new p(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(H){return 0===H||1===H?this:this.scaleInPlace(1/H)}normalizeToNew(){return this.normalizeToRef(new p)}normalizeToRef(H){const u=this.length();return 0===u||1===u?(H.x=this._x,H.y=this._y,H.z=this._z,H.w=this._w,H):this.scaleToRef(1/u,H)}toVector3(){return new r(this._x,this._y,this._z)}clone(){return new p(this._x,this._y,this._z,this._w)}O(H){return this.x=H.x,this.y=H.y,this.z=H.z,this.w=H.w,this}kg(H,u,J,O){return this.x=H,this.y=u,this.z=J,this.w=O,this}set(H,u,J,O){return this.kg(H,u,J,O)}jg(H){return this.x=this.y=this.z=this.w=H,this}dot(H){return this._x*H.x+this._y*H.y+this._z*H.z+this._w*H.w}static Cu(H,u){return u||(u=0),new p(H[u],H[u+1],H[u+2],H[u+3])}static FromArrayToRef(H,u,J){return J.x=H[u],J.y=H[u+1],J.z=H[u+2],J.w=H[u+3],J}static FromFloatArrayToRef(H,u,J){return p.FromArrayToRef(H,u,J),J}static FromFloatsToRef(H,u,J,O,U){return U.x=H,U.y=u,U.z=J,U.w=O,U}static Zero(){return new p(0,0,0,0)}static One(){return new p(1,1,1,1)}static Random(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new p((0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u))}static RandomToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,J=arguments.length>2?arguments[2]:void 0;return J.x=(0,B.RandomRange)(H,u),J.y=(0,B.RandomRange)(H,u),J.z=(0,B.RandomRange)(H,u),J.w=(0,B.RandomRange)(H,u),J}static Clamp(H,u,J){return p.ClampToRef(H,u,J,new p)}static ClampToRef(H,u,J,O){return O.x=(0,B.Clamp)(H.x,u.x,J.x),O.y=(0,B.Clamp)(H.y,u.y,J.y),O.z=(0,B.Clamp)(H.z,u.z,J.z),O.w=(0,B.Clamp)(H.w,u.w,J.w),O}static CheckExtends(H,u,J){u.minimizeInPlace(H),J.maximizeInPlace(H)}static get ZeroReadOnly(){return p._ZeroReadOnly}static Normalize(H){return p.NormalizeToRef(H,new p)}static NormalizeToRef(H,u){return H.normalizeToRef(u),u}static Minimize(H,u){const J=new p;return J.O(H),J.minimizeInPlace(u),J}static Maximize(H,u){const J=new p;return J.O(H),J.maximizeInPlace(u),J}static Distance(H,u){return Math.sqrt(p.DistanceSquared(H,u))}static DistanceSquared(H,u){const J=H.x-u.x,O=H.y-u.y,U=H.z-u.z,h=H.w-u.w;return J*J+O*O+U*U+h*h}static Center(H,u){return p.CenterToRef(H,u,new p)}static CenterToRef(H,u,J){return J.x=(H.x+u.x)/2,J.y=(H.y+u.y)/2,J.z=(H.z+u.z)/2,J.w=(H.w+u.w)/2,J}static TransformCoordinates(H,u){return p.TransformCoordinatesToRef(H,u,new p)}static TransformCoordinatesToRef(H,u,J){return p.TransformCoordinatesFromFloatsToRef(H._x,H._y,H._z,u,J),J}static TransformCoordinatesFromFloatsToRef(H,u,J,O,U){const h=O.m,w=H*h[0]+u*h[4]+J*h[8]+h[12],g=H*h[1]+u*h[5]+J*h[9]+h[13],B=H*h[2]+u*h[6]+J*h[10]+h[14],b=H*h[3]+u*h[7]+J*h[11]+h[15];return U.x=w,U.y=g,U.z=B,U.w=b,U}static TransformNormal(H,u){return p.TransformNormalToRef(H,u,new p)}static TransformNormalToRef(H,u,J){const O=u.m,U=H.x*O[0]+H.y*O[4]+H.z*O[8],h=H.x*O[1]+H.y*O[5]+H.z*O[9],w=H.x*O[2]+H.y*O[6]+H.z*O[10];return J.x=U,J.y=h,J.z=w,J.w=H.w,J}static TransformNormalFromFloatsToRef(H,u,J,O,U,h){const w=U.m;return h.x=H*w[0]+u*w[4]+J*w[8],h.y=H*w[1]+u*w[5]+J*w[9],h.z=H*w[2]+u*w[6]+J*w[10],h.w=O,h}static FromVector3(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new p(H._x,H._y,H._z,u)}static Dot(H,u){return H.x*u.x+H.y*u.y+H.z*u.z+H.w*u.w}}p._V8PerformanceHack=new p(.5,.5,.5,.5),p._ZeroReadOnly=p.Zero(),Object.defineProperties(p.prototype,{dimension:{value:[4]},rank:{value:1}});class a{get x(){return this._x}set x(H){this._x=H,this._isDirty=!0}get y(){return this._y}set y(H){this._y=H,this._isDirty=!0}get z(){return this._z}set z(H){this._z=H,this._isDirty=!0}get w(){return this._w}set w(H){this._w=H,this._isDirty=!0}constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=H,this._y=u,this._z=J,this._w=O}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let H=mH(this._x);return H=397*H^mH(this._y),H=397*H^mH(this._z),H=397*H^mH(this._w),H}Hg(){return[this._x,this._y,this._z,this._w]}toArray(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[u]=this._x,H[u+1]=this._y,H[u+2]=this._z,H[u+3]=this._w,this}mO(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return a.FromArrayToRef(H,u,this)}equals(H){return H&&this._x===H._x&&this._y===H._y&&this._z===H._z&&this._w===H._w}equalsWithEpsilon(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O.d;return H&&(0,B.WithinEpsilon)(this._x,H._x,u)&&(0,B.WithinEpsilon)(this._y,H._y,u)&&(0,B.WithinEpsilon)(this._z,H._z,u)&&(0,B.WithinEpsilon)(this._w,H._w,u)}isApprox(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O.d;return H&&((0,B.WithinEpsilon)(this._x,H._x,u)&&(0,B.WithinEpsilon)(this._y,H._y,u)&&(0,B.WithinEpsilon)(this._z,H._z,u)&&(0,B.WithinEpsilon)(this._w,H._w,u)||(0,B.WithinEpsilon)(this._x,-H._x,u)&&(0,B.WithinEpsilon)(this._y,-H._y,u)&&(0,B.WithinEpsilon)(this._z,-H._z,u)&&(0,B.WithinEpsilon)(this._w,-H._w,u))}clone(){return new a(this._x,this._y,this._z,this._w)}O(H){return this._x=H._x,this._y=H._y,this._z=H._z,this._w=H._w,this._isDirty=!0,this}kg(H,u,J,O){return this._x=H,this._y=u,this._z=J,this._w=O,this._isDirty=!0,this}set(H,u,J,O){return this.kg(H,u,J,O)}jg(H){return this.kg(H,H,H,H)}add(H){return new a(this._x+H._x,this._y+H._y,this._z+H._z,this._w+H._w)}addInPlace(H){return this._x+=H._x,this._y+=H._y,this._z+=H._z,this._w+=H._w,this._isDirty=!0,this}addToRef(H,u){return u._x=this._x+H._x,u._y=this._y+H._y,u._z=this._z+H._z,u._w=this._w+H._w,u._isDirty=!0,u}addInPlaceFromFloats(H,u,J,O){return this._x+=H,this._y+=u,this._z+=J,this._w+=O,this._isDirty=!0,this}subtractToRef(H,u){return u._x=this._x-H._x,u._y=this._y-H._y,u._z=this._z-H._z,u._w=this._w-H._w,u._isDirty=!0,u}subtractFromFloats(H,u,J,O){return this.subtractFromFloatsToRef(H,u,J,O,new a)}subtractFromFloatsToRef(H,u,J,O,U){return U._x=this._x-H,U._y=this._y-u,U._z=this._z-J,U._w=this._w-O,U._isDirty=!0,U}ru(H){return new a(this._x-H._x,this._y-H._y,this._z-H._z,this._w-H._w)}jP(H){return this._x-=H._x,this._y-=H._y,this._z-=H._z,this._w-=H._w,this._isDirty=!0,this}scale(H){return new a(this._x*H,this._y*H,this._z*H,this._w*H)}scaleToRef(H,u){return u._x=this._x*H,u._y=this._y*H,u._z=this._z*H,u._w=this._w*H,u._isDirty=!0,u}scaleInPlace(H){return this._x*=H,this._y*=H,this._z*=H,this._w*=H,this._isDirty=!0,this}scaleAndAddToRef(H,u){return u._x+=this._x*H,u._y+=this._y*H,u._z+=this._z*H,u._w+=this._w*H,u._isDirty=!0,u}multiply(H){const u=new a(0,0,0,1);return this.multiplyToRef(H,u),u}multiplyToRef(H,u){const J=this._x*H._w+this._y*H._z-this._z*H._y+this._w*H._x,O=-this._x*H._z+this._y*H._w+this._z*H._x+this._w*H._y,U=this._x*H._y-this._y*H._x+this._z*H._w+this._w*H._z,h=-this._x*H._x-this._y*H._y-this._z*H._z+this._w*H._w;return u.kg(J,O,U,h),u}multiplyInPlace(H){return this.multiplyToRef(H,this)}multiplyByFloats(H,u,J,O){return this._x*=H,this._y*=u,this._z*=J,this._w*=O,this._isDirty=!0,this}divide(H){throw new ReferenceError("Can not divide a quaternion")}divideToRef(H,u){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(H){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new a)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(H){return H._x=-this._x,H._y=-this._y,H._z=-this._z,H._w=-this._w,H._isDirty=!0,H}equalsToFloats(H,u,J,O){return this._x===H&&this._y===u&&this._z===J&&this._w===O}floorToRef(H){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(H){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(H){return H.kg(-this._x,-this._y,-this._z,this._w),H}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new a(-this._x,-this._y,-this._z,this._w)}invert(){const H=this.conjugate(),u=this.lengthSquared();return 0==u||1==u||H.scaleInPlace(1/u),H}invertInPlace(){this.conjugateInPlace();const H=this.lengthSquared();return 0==H||1==H||this.scaleInPlace(1/H),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(H){return 0===H||1===H?this:this.scaleInPlace(1/H)}normalizeToNew(){const H=new a(0,0,0,1);return this.normalizeToRef(H),H}normalizeToRef(H){const u=this.length();return 0===u||1===u?H.kg(this._x,this._y,this._z,this._w):this.scaleToRef(1/u,H)}toEulerAngles(){const H=r.Zero();return this.toEulerAnglesToRef(H),H}toEulerAnglesToRef(H){const u=this._z,J=this._x,O=this._y,U=this._w,h=O*u-J*U,w=.4999999;if(h<-w)H._y=2*Math.atan2(O,U),H._x=Math.PI/2,H._z=0,H._isDirty=!0;else if(h>w)H._y=2*Math.atan2(O,U),H._x=-Math.PI/2,H._z=0,H._isDirty=!0;else{const w=U*U,g=u*u,B=J*J,b=O*O;H._z=Math.atan2(2*(J*O+u*U),-g-B+b+w),H._x=Math.asin(-2*h),H._y=Math.atan2(2*(u*J+O*U),g-B-b+w),H._isDirty=!0}return H}toAlphaBetaGammaToRef(H){const u=this._z,J=this._x,O=this._y,U=this._w,h=Math.sqrt(J*J+O*O),w=Math.sqrt(u*u+U*U),g=2*Math.atan2(h,w),B=2*Math.atan2(u,U),b=2*Math.atan2(O,J),d=(B+b)/2,G=(B-b)/2;return H.set(G,g,d),H}toRotationMatrix(H){return k.FromQuaternionToRef(this,H),H}fromRotationMatrix(H){return a.FromRotationMatrixToRef(H,this),this}dot(H){return this._x*H._x+this._y*H._y+this._z*H._z+this._w*H._w}toAxisAngle(){const H=r.Zero();return{axis:H,angle:this.toAxisAngleToRef(H)}}toAxisAngleToRef(H){let u=0;const J=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),O=this._w;return J>0?(u=2*Math.atan2(J,O),H.set(this._x/J,this._y/J,this._z/J)):(u=0,H.set(1,0,0)),u}static FromRotationMatrix(H){const u=new a;return a.FromRotationMatrixToRef(H,u),u}static FromRotationMatrixToRef(H,u){const J=H.m,O=J[0],U=J[4],h=J[8],w=J[1],g=J[5],B=J[9],b=J[2],d=J[6],G=J[10],P=O+g+G;let mH;return P>0?(mH=.5/Math.sqrt(P+1),u._w=.25/mH,u._x=(d-B)*mH,u._y=(h-b)*mH,u._z=(w-U)*mH,u._isDirty=!0):O>g&&O>G?(mH=2*Math.sqrt(1+O-g-G),u._w=(d-B)/mH,u._x=.25*mH,u._y=(U+w)/mH,u._z=(h+b)/mH,u._isDirty=!0):g>G?(mH=2*Math.sqrt(1+g-O-G),u._w=(h-b)/mH,u._x=(U+w)/mH,u._y=.25*mH,u._z=(B+d)/mH,u._isDirty=!0):(mH=2*Math.sqrt(1+G-O-g),u._w=(w-U)/mH,u._x=(h+b)/mH,u._y=(B+d)/mH,u._z=.25*mH,u._isDirty=!0),u}static Dot(H,u){return H._x*u._x+H._y*u._y+H._z*u._z+H._w*u._w}static AreClose(H,u){let J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const O=a.Dot(H,u);return 1-O*O<=J}static SmoothToRef(H,u,J,O,U){let h=0===O?1:J/O;return h=(0,B.Clamp)(h,0,1),a.SlerpToRef(H,u,h,U),U}static Zero(){return new a(0,0,0,0)}static Inverse(H){return new a(-H._x,-H._y,-H._z,H._w)}static InverseToRef(H,u){return u.set(-H._x,-H._y,-H._z,H._w),u}static Identity(){return new a(0,0,0,1)}static IsIdentity(H){return H&&0===H._x&&0===H._y&&0===H._z&&1===H._w}static RotationAxis(H,u){return a.RotationAxisToRef(H,u,new a)}static RotationAxisToRef(H,u,J){J._w=Math.cos(u/2);const O=Math.sin(u/2)/H.length();return J._x=H._x*O,J._y=H._y*O,J._z=H._z*O,J._isDirty=!0,J}static Cu(H,u){return u||(u=0),new a(H[u],H[u+1],H[u+2],H[u+3])}static FromArrayToRef(H,u,J){return J._x=H[u],J._y=H[u+1],J._z=H[u+2],J._w=H[u+3],J._isDirty=!0,J}static FromFloatsToRef(H,u,J,O,U){return U.kg(H,u,J,O),U}static FromEulerAngles(H,u,J){const O=new a;return a.RotationYawPitchRollToRef(u,H,J,O),O}static FromEulerAnglesToRef(H,u,J,O){return a.RotationYawPitchRollToRef(u,H,J,O),O}static FromEulerVector(H){const u=new a;return a.RotationYawPitchRollToRef(H._y,H._x,H._z,u),u}static FromEulerVectorToRef(H,u){return a.RotationYawPitchRollToRef(H._y,H._x,H._z,u),u}static FromUnitVectorsToRef(H,u,J){let U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:O.d;const h=r.Dot(H,u)+1;return h<U?Math.abs(H.x)>Math.abs(H.z)?J.set(-H.y,H.x,0,0):J.set(0,-H.z,H.y,0):(r.CrossToRef(H,u,j.lu[0]),J.set(j.lu[0].x,j.lu[0].y,j.lu[0].z,h)),J.normalize()}static RotationYawPitchRoll(H,u,J){const O=new a;return a.RotationYawPitchRollToRef(H,u,J,O),O}static RotationYawPitchRollToRef(H,u,J,O){const U=.5*J,h=.5*u,w=.5*H,g=Math.sin(U),B=Math.cos(U),b=Math.sin(h),d=Math.cos(h),G=Math.sin(w),P=Math.cos(w);return O._x=P*b*B+G*d*g,O._y=G*d*B-P*b*g,O._z=P*d*g-G*b*B,O._w=P*d*B+G*b*g,O._isDirty=!0,O}static RotationAlphaBetaGamma(H,u,J){const O=new a;return a.RotationAlphaBetaGammaToRef(H,u,J,O),O}static RotationAlphaBetaGammaToRef(H,u,J,O){const U=.5*(J+H),h=.5*(J-H),w=.5*u;return O._x=Math.cos(h)*Math.sin(w),O._y=Math.sin(h)*Math.sin(w),O._z=Math.sin(U)*Math.cos(w),O._w=Math.cos(U)*Math.cos(w),O._isDirty=!0,O}static RotationQuaternionFromAxis(H,u,J){const O=new a(0,0,0,0);return a.RotationQuaternionFromAxisToRef(H,u,J,O),O}static RotationQuaternionFromAxisToRef(H,u,J,O){const U=C.Matrix[0];return H=H.normalizeToRef(C.lu[0]),u=u.normalizeToRef(C.lu[1]),J=J.normalizeToRef(C.lu[2]),k.FromXYZAxesToRef(H,u,J,U),a.FromRotationMatrixToRef(U,O),O}static FromLookDirectionLH(H,u){const J=new a;return a.FromLookDirectionLHToRef(H,u,J),J}static FromLookDirectionLHToRef(H,u,J){const O=C.Matrix[0];return k.LookDirectionLHToRef(H,u,O),a.FromRotationMatrixToRef(O,J),J}static FromLookDirectionRH(H,u){const J=new a;return a.FromLookDirectionRHToRef(H,u,J),J}static FromLookDirectionRHToRef(H,u,J){const O=C.Matrix[0];return k.LookDirectionRHToRef(H,u,O),a.FromRotationMatrixToRef(O,J)}static Slerp(H,u,J){const O=a.Identity();return a.SlerpToRef(H,u,J,O),O}static SlerpToRef(H,u,J,O){let U,h,w=H._x*u._x+H._y*u._y+H._z*u._z+H._w*u._w,g=!1;if(w<0&&(g=!0,w=-w),w>.999999)h=1-J,U=g?-J:J;else{const H=Math.acos(w),u=1/Math.sin(H);h=Math.sin((1-J)*H)*u,U=g?-Math.sin(J*H)*u:Math.sin(J*H)*u}return O._x=h*H._x+U*u._x,O._y=h*H._y+U*u._y,O._z=h*H._z+U*u._z,O._w=h*H._w+U*u._w,O._isDirty=!0,O}static Hermite(H,u,J,O,U){const h=U*U,w=U*h,g=2*w-3*h+1,B=-2*w+3*h,b=w-2*h+U,d=w-h,G=H._x*g+J._x*B+u._x*b+O._x*d,P=H._y*g+J._y*B+u._y*b+O._y*d,mH=H._z*g+J._z*B+u._z*b+O._z*d,l=H._w*g+J._w*B+u._w*b+O._w*d;return new a(G,P,mH,l)}static Hermite1stDerivative(H,u,J,O,U){const h=new a;return this.Hermite1stDerivativeToRef(H,u,J,O,U,h),h}static Hermite1stDerivativeToRef(H,u,J,O,U,h){const w=U*U;return h._x=6*(w-U)*H._x+(3*w-4*U+1)*u._x+6*(-w+U)*J._x+(3*w-2*U)*O._x,h._y=6*(w-U)*H._y+(3*w-4*U+1)*u._y+6*(-w+U)*J._y+(3*w-2*U)*O._y,h._z=6*(w-U)*H._z+(3*w-4*U+1)*u._z+6*(-w+U)*J._z+(3*w-2*U)*O._z,h._w=6*(w-U)*H._w+(3*w-4*U+1)*u._w+6*(-w+U)*J._w+(3*w-2*U)*O._w,h._isDirty=!0,h}static Normalize(H){const u=a.Zero();return a.NormalizeToRef(H,u),u}static NormalizeToRef(H,u){return H.normalizeToRef(u),u}static Clamp(H,u,J){const O=new a;return a.ClampToRef(H,u,J,O),O}static ClampToRef(H,u,J,O){return O.kg((0,B.Clamp)(H.x,u.x,J.x),(0,B.Clamp)(H.y,u.y,J.y),(0,B.Clamp)(H.z,u.z,J.z),(0,B.Clamp)(H.w,u.w,J.w))}static Random(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new a((0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u))}static RandomToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).kg((0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u),(0,B.RandomRange)(H,u))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(H,u){return Math.sqrt(a.DistanceSquared(H,u))}static DistanceSquared(H,u){const J=H.x-u.x,O=H.y-u.y,U=H.z-u.z,h=H.w-u.w;return J*J+O*O+U*U+h*h}static Center(H,u){return a.CenterToRef(H,u,a.Zero())}static CenterToRef(H,u,J){return J.kg((H.x+u.x)/2,(H.y+u.y)/2,(H.z+u.z)/2,(H.w+u.w)/2)}}a._V8PerformanceHack=new a(.5,.5,.5,.5),Object.defineProperties(a.prototype,{dimension:{value:[4]},rank:{value:1}});class k{static get Use64Bits(){return w.e.MatrixUse64Bits}get m(){return this.ih}markAsUpdated(){this.updateFlag=b._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(H){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1],J=arguments.length>2&&void 0!==arguments[2]&&arguments[2],O=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=H,this._isIdentity3x2=H||J,this._isIdentityDirty=!this._isIdentity&&u,this._isIdentity3x2Dirty=!this._isIdentity3x2&&O}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,w.e.MatrixTrackPrecisionChange&&w.e.MatrixTrackedMatrices.push(this),this.ih=new w.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const H=this.ih;this._isIdentity=1===H[0]&&0===H[1]&&0===H[2]&&0===H[3]&&0===H[4]&&1===H[5]&&0===H[6]&&0===H[7]&&0===H[8]&&0===H[9]&&1===H[10]&&0===H[11]&&0===H[12]&&0===H[13]&&0===H[14]&&1===H[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ih[0]||1!==this.ih[5]||1!==this.ih[15]||0!==this.ih[1]||0!==this.ih[2]||0!==this.ih[3]||0!==this.ih[4]||0!==this.ih[6]||0!==this.ih[7]||0!==this.ih[8]||0!==this.ih[9]||0!==this.ih[10]||0!==this.ih[11]||0!==this.ih[12]||0!==this.ih[13]||0!==this.ih[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const H=this.ih,u=H[0],J=H[1],O=H[2],U=H[3],h=H[4],w=H[5],g=H[6],B=H[7],b=H[8],d=H[9],G=H[10],P=H[11],mH=H[12],l=H[13],r=H[14],p=H[15],a=G*p-r*P,k=d*p-l*P,C=d*r-l*G,j=b*p-mH*P,M=b*r-G*mH,L=b*l-mH*d;return u*+(w*a-g*k+B*C)+J*-(h*a-g*j+B*M)+O*+(h*k-w*j+B*L)+U*-(h*C-w*M+g*L)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!H)return this.ih;const J=this.ih;for(let O=0;O<16;O++)H[u+O]=J[O];return this}Hg(){return this.ih}mO(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k.FromArrayToRef(H,u,this)}kg(){for(var H=arguments.length,u=new Array(H),J=0;J<H;J++)u[J]=arguments[J];return k.FromArrayToRef(u,0,this)}set(){const H=this.ih;for(let u=0;u<16;u++)H[u]=u<0||arguments.length<=u?void 0:arguments[u];return this.markAsUpdated(),this}jg(H){const u=this.ih;for(let J=0;J<16;J++)u[J]=H;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return k.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(H){const u=new k;return this.addToRef(H,u),u}addToRef(H,u){const J=this.ih,O=u.ih,U=H.m;for(let h=0;h<16;h++)O[h]=J[h]+U[h];return u.markAsUpdated(),u}addToSelf(H){const u=this.ih,J=H.m;return u[0]+=J[0],u[1]+=J[1],u[2]+=J[2],u[3]+=J[3],u[4]+=J[4],u[5]+=J[5],u[6]+=J[6],u[7]+=J[7],u[8]+=J[8],u[9]+=J[9],u[10]+=J[10],u[11]+=J[11],u[12]+=J[12],u[13]+=J[13],u[14]+=J[14],u[15]+=J[15],this.markAsUpdated(),this}addInPlace(H){const u=this.ih,J=H.m;for(let O=0;O<16;O++)u[O]+=J[O];return this.markAsUpdated(),this}addInPlaceFromFloats(){const H=this.ih;for(let u=0;u<16;u++)H[u]+=u<0||arguments.length<=u?void 0:arguments[u];return this.markAsUpdated(),this}ru(H){const u=this.ih,J=H.m;for(let O=0;O<16;O++)u[O]-=J[O];return this.markAsUpdated(),this}subtractToRef(H,u){const J=this.ih,O=H.m,U=u.ih;for(let h=0;h<16;h++)U[h]=J[h]-O[h];return u.markAsUpdated(),u}jP(H){const u=this.ih,J=H.m;for(let O=0;O<16;O++)u[O]-=J[O];return this.markAsUpdated(),this}subtractFromFloats(){for(var H=arguments.length,u=new Array(H),J=0;J<H;J++)u[J]=arguments[J];return this.subtractFromFloatsToRef(...u,new k)}subtractFromFloatsToRef(){for(var H=arguments.length,u=new Array(H),J=0;J<H;J++)u[J]=arguments[J];const O=u.pop(),U=this.ih,h=O.ih,w=u;for(let g=0;g<16;g++)h[g]=U[g]-w[g];return O.markAsUpdated(),O}invertToRef(H){return!0===this._isIdentity?(k.IdentityToRef(H),H):(P(this,H.Hg())?H.markAsUpdated():H.O(this),H)}addAtIndex(H,u){return this.ih[H]+=u,this.markAsUpdated(),this}multiplyAtIndex(H,u){return this.ih[H]*=u,this.markAsUpdated(),this}setTranslationFromFloats(H,u,J){return this.ih[12]=H,this.ih[13]=u,this.ih[14]=J,this.markAsUpdated(),this}addTranslationFromFloats(H,u,J){return this.ih[12]+=H,this.ih[13]+=u,this.ih[14]+=J,this.markAsUpdated(),this}setTranslation(H){return this.setTranslationFromFloats(H._x,H._y,H._z)}getTranslation(){return new r(this.ih[12],this.ih[13],this.ih[14])}getTranslationToRef(H){return H.x=this.ih[12],H.y=this.ih[13],H.z=this.ih[14],H}removeRotationAndScaling(){const H=this.m;return k.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,H[12],H[13],H[14],H[15],this),this._updateIdentityStatus(0===H[12]&&0===H[13]&&0===H[14]&&1===H[15]),this}O(H){H.copyToArray(this.ih);const u=H;return this.updateFlag=u.updateFlag,this._updateIdentityStatus(u._isIdentity,u._isIdentityDirty,u._isIdentity3x2,u._isIdentity3x2Dirty),this}copyToArray(H){return G(this,H,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(H){const u=new k;return this.multiplyToRef(H,u),u}multiplyInPlace(H){const u=this.ih,J=H.m;for(let O=0;O<16;O++)u[O]*=J[O];return this.markAsUpdated(),this}multiplyByFloats(){const H=this.ih;for(let u=0;u<16;u++)H[u]*=u<0||arguments.length<=u?void 0:arguments[u];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var H=arguments.length,u=new Array(H),J=0;J<H;J++)u[J]=arguments[J];const O=u.pop(),U=this.ih,h=O.ih,w=u;for(let g=0;g<16;g++)h[g]=U[g]*w[g];return O.markAsUpdated(),O}multiplyToRef(H,u){return this._isIdentity?(u.O(H),u):H._isIdentity?(u.O(this),u):(this.multiplyToArray(H,u.ih,0),u.markAsUpdated(),u)}multiplyToArray(H,u,J){return d(this,H,u,J),this}divide(H){return this.divideToRef(H,new k)}divideToRef(H,u){const J=this.ih,O=H.m,U=u.ih;for(let h=0;h<16;h++)U[h]=J[h]/O[h];return u.markAsUpdated(),u}divideInPlace(H){const u=this.ih,J=H.m;for(let O=0;O<16;O++)u[O]/=J[O];return this.markAsUpdated(),this}minimizeInPlace(H){const u=this.ih,J=H.m;for(let O=0;O<16;O++)u[O]=Math.min(u[O],J[O]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const H=this.ih;for(let u=0;u<16;u++)H[u]=Math.min(H[u],u<0||arguments.length<=u?void 0:arguments[u]);return this.markAsUpdated(),this}maximizeInPlace(H){const u=this.ih,J=H.m;for(let O=0;O<16;O++)u[O]=Math.min(u[O],J[O]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const H=this.ih;for(let u=0;u<16;u++)H[u]=Math.min(H[u],u<0||arguments.length<=u?void 0:arguments[u]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new k)}negateInPlace(){const H=this.ih;for(let u=0;u<16;u++)H[u]=-H[u];return this.markAsUpdated(),this}negateToRef(H){const u=this.ih,J=H.ih;for(let O=0;O<16;O++)J[O]=-u[O];return H.markAsUpdated(),H}equals(H){const u=H;if(!u)return!1;if((this._isIdentity||u._isIdentity)&&!this._isIdentityDirty&&!u._isIdentityDirty)return this._isIdentity&&u._isIdentity;const J=this.m,O=u.m;return J[0]===O[0]&&J[1]===O[1]&&J[2]===O[2]&&J[3]===O[3]&&J[4]===O[4]&&J[5]===O[5]&&J[6]===O[6]&&J[7]===O[7]&&J[8]===O[8]&&J[9]===O[9]&&J[10]===O[10]&&J[11]===O[11]&&J[12]===O[12]&&J[13]===O[13]&&J[14]===O[14]&&J[15]===O[15]}equalsWithEpsilon(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const J=this.ih,O=H.m;for(let U=0;U<16;U++)if(!(0,B.WithinEpsilon)(J[U],O[U],u))return!1;return!0}equalsToFloats(){const H=this.ih;for(let u=0;u<16;u++)if(H[u]!=(u<0||arguments.length<=u?void 0:arguments[u]))return!1;return!0}floor(){return this.floorToRef(new k)}floorToRef(H){const u=this.ih,J=H.ih;for(let O=0;O<16;O++)J[O]=Math.floor(u[O]);return H.markAsUpdated(),H}fract(){return this.fractToRef(new k)}fractToRef(H){const u=this.ih,J=H.ih;for(let O=0;O<16;O++)J[O]=u[O]-Math.floor(u[O]);return H.markAsUpdated(),H}clone(){const H=new k;return H.O(this),H}getClassName(){return"Matrix"}getHashCode(){let H=mH(this.ih[0]);for(let u=1;u<16;u++)H=397*H^mH(this.ih[u]);return H}decomposeToTransformNode(H){return H.rotationQuaternion=H.rotationQuaternion||new a,this.decompose(H.Cg,H.rotationQuaternion,H.position)}decompose(H,u,J,O){let U=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return J&&J.jg(0),H&&H.jg(1),u&&u.kg(0,0,0,1),!0;const h=this.ih;if(J&&J.kg(h[12],h[13],h[14]),(H=H||C.lu[0]).x=Math.sqrt(h[0]*h[0]+h[1]*h[1]+h[2]*h[2]),H.y=Math.sqrt(h[4]*h[4]+h[5]*h[5]+h[6]*h[6]),H.z=Math.sqrt(h[8]*h[8]+h[9]*h[9]+h[10]*h[10]),O){const u=(U?O.absoluteScaling.x:O.Cg.x)<0?-1:1,J=(U?O.absoluteScaling.y:O.Cg.y)<0?-1:1,h=(U?O.absoluteScaling.z:O.Cg.z)<0?-1:1;H.x*=u,H.y*=J,H.z*=h}else this.determinant()<=0&&(H.y*=-1);if(0===H._x||0===H._y||0===H._z)return u&&u.kg(0,0,0,1),!1;if(u){const J=1/H._x,O=1/H._y,U=1/H._z;k.FromValuesToRef(h[0]*J,h[1]*J,h[2]*J,0,h[4]*O,h[5]*O,h[6]*O,0,h[8]*U,h[9]*U,h[10]*U,0,0,0,0,1,C.Matrix[0]),a.FromRotationMatrixToRef(C.Matrix[0],u)}return!0}getRow(H){if(H<0||H>3)return null;const u=4*H;return new p(this.ih[u+0],this.ih[u+1],this.ih[u+2],this.ih[u+3])}getRowToRef(H,u){if(H>=0&&H<=3){const J=4*H;u.x=this.ih[J+0],u.y=this.ih[J+1],u.z=this.ih[J+2],u.w=this.ih[J+3]}return u}setRow(H,u){return this.setRowFromFloats(H,u.x,u.y,u.z,u.w)}transpose(){const H=new k;return k.TransposeToRef(this,H),H}transposeToRef(H){return k.TransposeToRef(this,H),H}setRowFromFloats(H,u,J,O,U){if(H<0||H>3)return this;const h=4*H;return this.ih[h+0]=u,this.ih[h+1]=J,this.ih[h+2]=O,this.ih[h+3]=U,this.markAsUpdated(),this}scale(H){const u=new k;return this.scaleToRef(H,u),u}scaleToRef(H,u){for(let J=0;J<16;J++)u.ih[J]=this.ih[J]*H;return u.markAsUpdated(),u}scaleAndAddToRef(H,u){for(let J=0;J<16;J++)u.ih[J]+=this.ih[J]*H;return u.markAsUpdated(),u}scaleInPlace(H){const u=this.ih;for(let J=0;J<16;J++)u[J]*=H;return this.markAsUpdated(),this}toNormalMatrix(H){const u=C.Matrix[0];this.invertToRef(u),u.transposeToRef(H);const J=H.ih;return k.FromValuesToRef(J[0],J[1],J[2],0,J[4],J[5],J[6],0,J[8],J[9],J[10],0,0,0,0,1,H),H}getRotationMatrix(){const H=new k;return this.getRotationMatrixToRef(H),H}getRotationMatrixToRef(H){const u=C.lu[0];if(!this.decompose(u))return k.IdentityToRef(H),H;const J=this.ih,O=1/u._x,U=1/u._y,h=1/u._z;return k.FromValuesToRef(J[0]*O,J[1]*O,J[2]*O,0,J[4]*U,J[5]*U,J[6]*U,0,J[8]*h,J[9]*h,J[10]*h,0,0,0,0,1,H),H}toggleModelMatrixHandInPlace(){const H=this.ih;return H[2]*=-1,H[6]*=-1,H[8]*=-1,H[9]*=-1,H[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const H=this.ih;return H[8]*=-1,H[9]*=-1,H[10]*=-1,H[11]*=-1,this.markAsUpdated(),this}static Cu(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const J=new k;return k.FromArrayToRef(H,u,J),J}static FromArrayToRef(H,u,J){for(let O=0;O<16;O++)J.ih[O]=H[O+u];return J.markAsUpdated(),J}static FromFloat32ArrayToRefScaled(H,u,J,O){return O.ih[0]=H[0+u]*J,O.ih[1]=H[1+u]*J,O.ih[2]=H[2+u]*J,O.ih[3]=H[3+u]*J,O.ih[4]=H[4+u]*J,O.ih[5]=H[5+u]*J,O.ih[6]=H[6+u]*J,O.ih[7]=H[7+u]*J,O.ih[8]=H[8+u]*J,O.ih[9]=H[9+u]*J,O.ih[10]=H[10+u]*J,O.ih[11]=H[11+u]*J,O.ih[12]=H[12+u]*J,O.ih[13]=H[13+u]*J,O.ih[14]=H[14+u]*J,O.ih[15]=H[15+u]*J,O.markAsUpdated(),O}static get IdentityReadOnly(){return k._IdentityReadOnly}static FromValuesToRef(H,u,J,O,U,h,w,g,B,b,d,G,P,mH,l,r,p){const a=p.ih;a[0]=H,a[1]=u,a[2]=J,a[3]=O,a[4]=U,a[5]=h,a[6]=w,a[7]=g,a[8]=B,a[9]=b,a[10]=d,a[11]=G,a[12]=P,a[13]=mH,a[14]=l,a[15]=r,p.markAsUpdated()}static FromValues(H,u,J,O,U,h,w,g,B,b,d,G,P,mH,l,r){const p=new k,a=p.ih;return a[0]=H,a[1]=u,a[2]=J,a[3]=O,a[4]=U,a[5]=h,a[6]=w,a[7]=g,a[8]=B,a[9]=b,a[10]=d,a[11]=G,a[12]=P,a[13]=mH,a[14]=l,a[15]=r,p.markAsUpdated(),p}static Compose(H,u,J){const O=new k;return k.ComposeToRef(H,u,J,O),O}static ComposeToRef(H,u,J,O){const U=O.ih,h=u._x,w=u._y,g=u._z,B=u._w,b=h+h,d=w+w,G=g+g,P=h*b,mH=h*d,l=h*G,r=w*d,p=w*G,a=g*G,k=B*b,C=B*d,j=B*G,M=H._x,L=H._y,Z=H._z;return U[0]=(1-(r+a))*M,U[1]=(mH+j)*M,U[2]=(l-C)*M,U[3]=0,U[4]=(mH-j)*L,U[5]=(1-(P+a))*L,U[6]=(p+k)*L,U[7]=0,U[8]=(l+C)*Z,U[9]=(p-k)*Z,U[10]=(1-(P+r))*Z,U[11]=0,U[12]=J._x,U[13]=J._y,U[14]=J._z,U[15]=1,O.markAsUpdated(),O}static Identity(){const H=k.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return H._updateIdentityStatus(!0),H}static IdentityToRef(H){return k.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,H),H._updateIdentityStatus(!0),H}static Zero(){const H=k.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return H._updateIdentityStatus(!1),H}static RotationX(H){const u=new k;return k.RotationXToRef(H,u),u}static Invert(H){const u=new k;return H.invertToRef(u),u}static RotationXToRef(H,u){const J=Math.sin(H),O=Math.cos(H);return k.FromValuesToRef(1,0,0,0,0,O,J,0,0,-J,O,0,0,0,0,1,u),u._updateIdentityStatus(1===O&&0===J),u}static RotationY(H){const u=new k;return k.RotationYToRef(H,u),u}static RotationYToRef(H,u){const J=Math.sin(H),O=Math.cos(H);return k.FromValuesToRef(O,0,-J,0,0,1,0,0,J,0,O,0,0,0,0,1,u),u._updateIdentityStatus(1===O&&0===J),u}static RotationZ(H){const u=new k;return k.RotationZToRef(H,u),u}static RotationZToRef(H,u){const J=Math.sin(H),O=Math.cos(H);return k.FromValuesToRef(O,J,0,0,-J,O,0,0,0,0,1,0,0,0,0,1,u),u._updateIdentityStatus(1===O&&0===J),u}static RotationAxis(H,u){const J=new k;return k.RotationAxisToRef(H,u,J),J}static RotationAxisToRef(H,u,J){const O=Math.sin(-u),U=Math.cos(-u),h=1-U;H=H.normalizeToRef(C.lu[0]);const w=J.ih;return w[0]=H._x*H._x*h+U,w[1]=H._x*H._y*h-H._z*O,w[2]=H._x*H._z*h+H._y*O,w[3]=0,w[4]=H._y*H._x*h+H._z*O,w[5]=H._y*H._y*h+U,w[6]=H._y*H._z*h-H._x*O,w[7]=0,w[8]=H._z*H._x*h-H._y*O,w[9]=H._z*H._y*h+H._x*O,w[10]=H._z*H._z*h+U,w[11]=0,w[12]=0,w[13]=0,w[14]=0,w[15]=1,J.markAsUpdated(),J}static RotationAlignToRef(H,u,J){let U=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const h=r.Dot(u,H),w=J.ih;if(h<-1+O.d)w[0]=-1,w[1]=0,w[2]=0,w[3]=0,w[4]=0,w[5]=U?1:-1,w[6]=0,w[7]=0,w[8]=0,w[9]=0,w[10]=U?-1:1,w[11]=0;else{const J=r.Cross(u,H),O=1/(1+h);w[0]=J._x*J._x*O+h,w[1]=J._y*J._x*O-J._z,w[2]=J._z*J._x*O+J._y,w[3]=0,w[4]=J._x*J._y*O+J._z,w[5]=J._y*J._y*O+h,w[6]=J._z*J._y*O-J._x,w[7]=0,w[8]=J._x*J._z*O-J._y,w[9]=J._y*J._z*O+J._x,w[10]=J._z*J._z*O+h,w[11]=0}return w[12]=0,w[13]=0,w[14]=0,w[15]=1,J.markAsUpdated(),J}static RotationYawPitchRoll(H,u,J){const O=new k;return k.RotationYawPitchRollToRef(H,u,J,O),O}static RotationYawPitchRollToRef(H,u,J,O){return a.RotationYawPitchRollToRef(H,u,J,C.Quaternion[0]),C.Quaternion[0].toRotationMatrix(O),O}static Scaling(H,u,J){const O=new k;return k.ScalingToRef(H,u,J,O),O}static ScalingToRef(H,u,J,O){return k.FromValuesToRef(H,0,0,0,0,u,0,0,0,0,J,0,0,0,0,1,O),O._updateIdentityStatus(1===H&&1===u&&1===J),O}static Translation(H,u,J){const O=new k;return k.TranslationToRef(H,u,J,O),O}static TranslationToRef(H,u,J,O){return k.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,H,u,J,1,O),O._updateIdentityStatus(0===H&&0===u&&0===J),O}static Lerp(H,u,J){const O=new k;return k.LerpToRef(H,u,J,O),O}static LerpToRef(H,u,J,O){const U=O.ih,h=H.m,w=u.m;for(let g=0;g<16;g++)U[g]=h[g]*(1-J)+w[g]*J;return O.markAsUpdated(),O}static DecomposeLerp(H,u,J){const O=new k;return k.DecomposeLerpToRef(H,u,J,O),O}static DecomposeLerpToRef(H,u,J,O){const U=C.lu[0],h=C.Quaternion[0],w=C.lu[1];H.decompose(U,h,w);const g=C.lu[2],B=C.Quaternion[1],b=C.lu[3];u.decompose(g,B,b);const d=C.lu[4];r.LerpToRef(U,g,J,d);const G=C.Quaternion[2];a.SlerpToRef(h,B,J,G);const P=C.lu[5];return r.LerpToRef(w,b,J,P),k.ComposeToRef(d,G,P,O),O}static LookAtLH(H,u,J){const O=new k;return k.LookAtLHToRef(H,u,J,O),O}static LookAtLHToRef(H,u,J,O){const U=C.lu[0],h=C.lu[1],w=C.lu[2];u.subtractToRef(H,w),w.normalize(),r.CrossToRef(J,w,U);const g=U.lengthSquared();0===g?U.x=1:U.normalizeFromLength(Math.sqrt(g)),r.CrossToRef(w,U,h),h.normalize();const B=-r.Dot(U,H),b=-r.Dot(h,H),d=-r.Dot(w,H);return k.FromValuesToRef(U._x,h._x,w._x,0,U._y,h._y,w._y,0,U._z,h._z,w._z,0,B,b,d,1,O),O}static LookAtRH(H,u,J){const O=new k;return k.LookAtRHToRef(H,u,J,O),O}static LookAtRHToRef(H,u,J,O){const U=C.lu[0],h=C.lu[1],w=C.lu[2];H.subtractToRef(u,w),w.normalize(),r.CrossToRef(J,w,U);const g=U.lengthSquared();0===g?U.x=1:U.normalizeFromLength(Math.sqrt(g)),r.CrossToRef(w,U,h),h.normalize();const B=-r.Dot(U,H),b=-r.Dot(h,H),d=-r.Dot(w,H);return k.FromValuesToRef(U._x,h._x,w._x,0,U._y,h._y,w._y,0,U._z,h._z,w._z,0,B,b,d,1,O),O}static LookDirectionLH(H,u){const J=new k;return k.LookDirectionLHToRef(H,u,J),J}static LookDirectionLHToRef(H,u,J){const O=C.lu[0];O.O(H),O.scaleInPlace(-1);const U=C.lu[1];return r.CrossToRef(u,O,U),k.FromValuesToRef(U._x,U._y,U._z,0,u._x,u._y,u._z,0,O._x,O._y,O._z,0,0,0,0,1,J),J}static LookDirectionRH(H,u){const J=new k;return k.LookDirectionRHToRef(H,u,J),J}static LookDirectionRHToRef(H,u,J){const O=C.lu[2];return r.CrossToRef(u,H,O),k.FromValuesToRef(O._x,O._y,O._z,0,u._x,u._y,u._z,0,H._x,H._y,H._z,0,0,0,0,1,J),J}static OrthoLH(H,u,J,O,U){const h=new k;return k.OrthoLHToRef(H,u,J,O,h,U),h}static OrthoLHToRef(H,u,J,O,U,h){const w=2/H,g=2/u,B=2/(O-J),b=-(O+J)/(O-J);return k.FromValuesToRef(w,0,0,0,0,g,0,0,0,0,B,0,0,0,b,1,U),h&&U.multiplyToRef(M,U),U._updateIdentityStatus(1===w&&1===g&&1===B&&0===b),U}static OrthoOffCenterLH(H,u,J,O,U,h,w){const g=new k;return k.OrthoOffCenterLHToRef(H,u,J,O,U,h,g,w),g}static OrthoOffCenterLHToRef(H,u,J,O,U,h,w,g){const B=2/(u-H),b=2/(O-J),d=2/(h-U),G=-(h+U)/(h-U),P=(H+u)/(H-u),mH=(O+J)/(J-O);return k.FromValuesToRef(B,0,0,0,0,b,0,0,0,0,d,0,P,mH,G,1,w),g&&w.multiplyToRef(M,w),w.markAsUpdated(),w}static ObliqueOffCenterLHToRef(H,u,J,O,U,h,w,g,B,b,d){const G=-w*Math.cos(g),P=-w*Math.sin(g);return k.TranslationToRef(0,0,-B,C.Matrix[1]),k.FromValuesToRef(1,0,0,0,0,1,0,0,G,P,1,0,0,0,0,1,C.Matrix[0]),C.Matrix[1].multiplyToRef(C.Matrix[0],C.Matrix[0]),k.TranslationToRef(0,0,B,C.Matrix[1]),C.Matrix[0].multiplyToRef(C.Matrix[1],C.Matrix[0]),k.OrthoOffCenterLHToRef(H,u,J,O,U,h,b,d),C.Matrix[0].multiplyToRef(b,b),b}static OrthoOffCenterRH(H,u,J,O,U,h,w){const g=new k;return k.OrthoOffCenterRHToRef(H,u,J,O,U,h,g,w),g}static OrthoOffCenterRHToRef(H,u,J,O,U,h,w,g){return k.OrthoOffCenterLHToRef(H,u,J,O,U,h,w,g),w.ih[10]*=-1,w}static ObliqueOffCenterRHToRef(H,u,J,O,U,h,w,g,B,b,d){const G=w*Math.cos(g),P=w*Math.sin(g);return k.TranslationToRef(0,0,B,C.Matrix[1]),k.FromValuesToRef(1,0,0,0,0,1,0,0,G,P,1,0,0,0,0,1,C.Matrix[0]),C.Matrix[1].multiplyToRef(C.Matrix[0],C.Matrix[0]),k.TranslationToRef(0,0,-B,C.Matrix[1]),C.Matrix[0].multiplyToRef(C.Matrix[1],C.Matrix[0]),k.OrthoOffCenterRHToRef(H,u,J,O,U,h,b,d),C.Matrix[0].multiplyToRef(b,b),b}static PerspectiveLH(H,u,J,O,U){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const w=new k,g=2*J/H,B=2*J/u,b=(O+J)/(O-J),d=-2*O*J/(O-J),G=Math.tan(h);return k.FromValuesToRef(g,0,0,0,0,B,0,G,0,0,b,1,0,0,d,0,w),U&&w.multiplyToRef(M,w),w._updateIdentityStatus(!1),w}static PerspectiveFovLH(H,u,J,O,U){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,w=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const g=new k;return k.PerspectiveFovLHToRef(H,u,J,O,g,!0,U,h,w),g}static PerspectiveFovLHToRef(H,u,J,O,U){let h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],w=arguments.length>6?arguments[6]:void 0,g=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,B=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const b=J,d=O,G=1/Math.tan(.5*H),P=h?G/u:G,mH=h?G:G*u,l=B&&0===b?-1:0!==d?(d+b)/(d-b):1,r=B&&0===b?2*d:0!==d?-2*d*b/(d-b):-2*b,p=Math.tan(g);return k.FromValuesToRef(P,0,0,0,0,mH,0,p,0,0,l,1,0,0,r,0,U),w&&U.multiplyToRef(M,U),U._updateIdentityStatus(!1),U}static PerspectiveFovReverseLHToRef(H,u,J,O,U){let h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],w=arguments.length>6?arguments[6]:void 0,g=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const B=1/Math.tan(.5*H),b=h?B/u:B,d=h?B:B*u,G=Math.tan(g);return k.FromValuesToRef(b,0,0,0,0,d,0,G,0,0,-J,1,0,0,1,0,U),w&&U.multiplyToRef(M,U),U._updateIdentityStatus(!1),U}static PerspectiveFovRH(H,u,J,O,U){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,w=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const g=new k;return k.PerspectiveFovRHToRef(H,u,J,O,g,!0,U,h,w),g}static PerspectiveFovRHToRef(H,u,J,O,U){let h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],w=arguments.length>6?arguments[6]:void 0,g=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,B=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const b=J,d=O,G=1/Math.tan(.5*H),P=h?G/u:G,mH=h?G:G*u,l=B&&0===b?1:0!==d?-(d+b)/(d-b):-1,r=B&&0===b?2*d:0!==d?-2*d*b/(d-b):-2*b,p=Math.tan(g);return k.FromValuesToRef(P,0,0,0,0,mH,0,p,0,0,l,-1,0,0,r,0,U),w&&U.multiplyToRef(M,U),U._updateIdentityStatus(!1),U}static PerspectiveFovReverseRHToRef(H,u,J,O,U){let h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],w=arguments.length>6?arguments[6]:void 0,g=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const B=1/Math.tan(.5*H),b=h?B/u:B,d=h?B:B*u,G=Math.tan(g);return k.FromValuesToRef(b,0,0,0,0,d,0,G,0,0,-J,-1,0,0,-1,0,U),w&&U.multiplyToRef(M,U),U._updateIdentityStatus(!1),U}static GetFinalMatrix(H,u,J,O,U,h){const w=H.width,g=H.height,B=H.x,b=H.y,d=k.FromValues(w/2,0,0,0,0,-g/2,0,0,0,0,h-U,0,B+w/2,g/2+b,U,1),G=new k;return u.multiplyToRef(J,G),G.multiplyToRef(O,G),G.multiplyToRef(d,G)}static GetAsMatrix2x2(H){const u=H.m,J=[u[0],u[1],u[4],u[5]];return w.e.MatrixUse64Bits?J:new Float32Array(J)}static GetAsMatrix3x3(H){const u=H.m,J=[u[0],u[1],u[2],u[4],u[5],u[6],u[8],u[9],u[10]];return w.e.MatrixUse64Bits?J:new Float32Array(J)}static Transpose(H){const u=new k;return k.TransposeToRef(H,u),u}static TransposeToRef(H,u){const J=H.m,O=J[0],U=J[4],h=J[8],w=J[12],g=J[1],B=J[5],b=J[9],d=J[13],G=J[2],P=J[6],mH=J[10],l=J[14],r=J[3],p=J[7],a=J[11],k=J[15],C=u.ih;return C[0]=O,C[1]=U,C[2]=h,C[3]=w,C[4]=g,C[5]=B,C[6]=b,C[7]=d,C[8]=G,C[9]=P,C[10]=mH,C[11]=l,C[12]=r,C[13]=p,C[14]=a,C[15]=k,u.markAsUpdated(),u._updateIdentityStatus(H._isIdentity,H._isIdentityDirty),u}static Reflection(H){const u=new k;return k.ReflectionToRef(H,u),u}static ReflectionToRef(H,u){H.normalize();const J=H.normal.x,O=H.normal.y,U=H.normal.z,h=-2*J,w=-2*O,g=-2*U;return k.FromValuesToRef(h*J+1,w*J,g*J,0,h*O,w*O+1,g*O,0,h*U,w*U,g*U+1,0,h*H.d,w*H.d,g*H.d,1,u),u}static FromXYZAxesToRef(H,u,J,O){return k.FromValuesToRef(H._x,H._y,H._z,0,u._x,u._y,u._z,0,J._x,J._y,J._z,0,0,0,0,1,O),O}static FromQuaternionToRef(H,u){const J=H._x*H._x,O=H._y*H._y,U=H._z*H._z,h=H._x*H._y,w=H._z*H._w,g=H._z*H._x,B=H._y*H._w,b=H._y*H._z,d=H._x*H._w;return u.ih[0]=1-2*(O+U),u.ih[1]=2*(h+w),u.ih[2]=2*(g-B),u.ih[3]=0,u.ih[4]=2*(h-w),u.ih[5]=1-2*(U+J),u.ih[6]=2*(b+d),u.ih[7]=0,u.ih[8]=2*(g+B),u.ih[9]=2*(b-d),u.ih[10]=1-2*(O+J),u.ih[11]=0,u.ih[12]=0,u.ih[13]=0,u.ih[14]=0,u.ih[15]=1,u.markAsUpdated(),u}}k._IdentityReadOnly=k.Identity(),Object.defineProperties(k.prototype,{dimension:{value:[4,4]},rank:{value:2}});class C{}C.lu=(0,U.f)(11,r.Zero),C.Matrix=(0,U.f)(2,k.Identity),C.Quaternion=(0,U.f)(3,a.Zero);class j{}j.Vector2=(0,U.f)(3,l.Zero),j.lu=(0,U.f)(13,r.Zero),j.Vector4=(0,U.f)(3,p.Zero),j.Quaternion=(0,U.f)(3,a.Zero),j.Matrix=(0,U.f)(8,k.Identity),(0,h.f)("BABYLON.Vector2",l),(0,h.f)("BABYLON.Vector3",r),(0,h.f)("BABYLON.Vector4",p),(0,h.f)("BABYLON.Matrix",k);const M=k.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12345:(H,u,J)=>{function O(H,u){const J=[];for(let O=0;O<H;++O)J.push(u());return J}function U(H,u){return O(H,u)}J.d(u,{b:()=>O,f:()=>U,j:()=>w});const h=["push","splice","pop","shift","unshift"];function w(H,u){const J=h.map((J=>function(H,u,J){const O=H[u];if("function"!==typeof O)return null;const U=function(){const O=H.length,h=U.previous.apply(H,arguments);return J(u,O),h};return O.next=U,U.previous=O,H[u]=U,()=>{const J=U.previous;if(!J)return;const O=U.next;O?(J.next=O,O.previous=J):(J.next=void 0,H[u]=J),U.next=void 0,U.previous=void 0}}(H,J,u)));return()=>{for(const H of J)null===H||void 0===H||H()}}}}]);