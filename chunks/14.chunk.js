"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[14],{11350:(m,S,h)=>{h.d(S,{d:()=>u,f:()=>O,g:()=>l,h:()=>M});const l=1/2.2,M=2.2,O=(1+Math.sqrt(5))/2,u=.001},11359:(m,S,h)=>{function l(m){return parseInt(m.toString().replace(/\W/g,""))}function M(m,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(m-S)<=h}function O(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return m<S-l||m>h+l}function u(m,S){return m===S?m:Math.random()*(S-m)+m}function b(m,S,h){return m+(S-m)*h}function q(m,S,h){let l=E(S-m,360);return l>180&&(l-=360),m+l*Z(h)}function Y(m,S,h){let l=0;return l=m!=S?Z((h-m)/(S-m)):0,l}function V(m,S,h,l,M){const O=M*M,u=M*O;return m*(2*u-3*O+1)+h*(-2*u+3*O)+S*(u-2*O+M)+l*(u-O)}function I(m,S,h,l,M){const O=M*M;return 6*(O-M)*m+(3*O-4*M+1)*S+6*(-O+M)*h+(3*O-2*M)*l}function Z(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(h,Math.max(S,m))}function C(m){return m-=2*Math.PI*Math.floor((m+Math.PI)/(2*Math.PI))}function B(m){const S=m.toString(16);return m<=15?("0"+S).toUpperCase():S.toUpperCase()}function D(m){if(Math.log2)return Math.floor(Math.log2(m));if(m<0)return NaN;if(0===m)return-1/0;let S=0;if(m<1){for(;m<1;)S++,m*=2;S=-S}else if(m>1)for(;m>1;)S++,m=Math.floor(m/2);return S}function E(m,S){return m-Math.floor(m/S)*S}function n(m,S,h){return(m-S)/(h-S)}function L(m,S,h){return m*(h-S)+S}function U(m,S){let h=E(S-m,360);return h>180&&(h-=360),h}function H(m,S){const h=E(m,2*S);return S-Math.abs(h-S)}function R(m,S,h){let l=Z(h);return l=-2*l*l*l+3*l*l,S*l+m*(1-l)}function y(m,S,h){let l=0;return l=Math.abs(S-m)<=h?S:m+Math.sign(S-m)*h,l}function o(m,S,h){const l=U(m,S);let M=0;return M=-h<l&&l<h?S:y(m,S=m+l,h),M}function s(m,S,h){return(m-S)/(h-S)}function v(m,S,h){return(h-S)*m+S}function T(m,S){const h=m%S;return 0===h?S:T(S,h)}h.r(S),h.d(S,{Clamp:()=>Z,DeltaAngle:()=>U,Denormalize:()=>L,ExtractAsInt:()=>l,Hermite:()=>V,Hermite1stDerivative:()=>I,HighestCommonFactor:()=>T,ILog2:()=>D,InverseLerp:()=>Y,Lerp:()=>b,LerpAngle:()=>q,MoveTowards:()=>y,MoveTowardsAngle:()=>o,Normalize:()=>n,NormalizeRadians:()=>C,OutsideRange:()=>O,PercentToRange:()=>v,PingPong:()=>H,RandomRange:()=>u,RangeToPercent:()=>s,Repeat:()=>E,SmoothStep:()=>R,ToHex:()=>B,WithinEpsilon:()=>M})},11347:(m,S,h)=>{h.r(S),h.d(S,{Matrix:()=>L,Quaternion:()=>n,TmpVectors:()=>H,Vector2:()=>B,nS:()=>D,Vector4:()=>E});var l=h(11350),M=h(11356),O=h(11293),u=h(11259),b=h(11196),q=h(11359);class Y{}function V(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const M=m.DM(),O=S.DM(),u=M[0],b=M[1],q=M[2],Y=M[3],V=M[4],I=M[5],Z=M[6],C=M[7],B=M[8],D=M[9],E=M[10],n=M[11],L=M[12],U=M[13],H=M[14],R=M[15],y=O[0],o=O[1],s=O[2],v=O[3],T=O[4],X=O[5],g=O[6],G=O[7],e=O[8],a=O[9],x=O[10],P=O[11],d=O[12],J=O[13],N=O[14],j=O[15];h[l]=u*y+b*T+q*e+Y*d,h[l+1]=u*o+b*X+q*a+Y*J,h[l+2]=u*s+b*g+q*x+Y*N,h[l+3]=u*v+b*G+q*P+Y*j,h[l+4]=V*y+I*T+Z*e+C*d,h[l+5]=V*o+I*X+Z*a+C*J,h[l+6]=V*s+I*g+Z*x+C*N,h[l+7]=V*v+I*G+Z*P+C*j,h[l+8]=B*y+D*T+E*e+n*d,h[l+9]=B*o+D*X+E*a+n*J,h[l+10]=B*s+D*g+E*x+n*N,h[l+11]=B*v+D*G+E*P+n*j,h[l+12]=L*y+U*T+H*e+R*d,h[l+13]=L*o+U*X+H*a+R*J,h[l+14]=L*s+U*g+H*x+R*N,h[l+15]=L*v+U*G+H*P+R*j}function I(m,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const l=m.DM();S[h]=l[0],S[h+1]=l[1],S[h+2]=l[2],S[h+3]=l[3],S[h+4]=l[4],S[h+5]=l[5],S[h+6]=l[6],S[h+7]=l[7],S[h+8]=l[8],S[h+9]=l[9],S[h+10]=l[10],S[h+11]=l[11],S[h+12]=l[12],S[h+13]=l[13],S[h+14]=l[14],S[h+15]=l[15]}function Z(m,S){const h=m.DM(),l=h[0],M=h[1],O=h[2],u=h[3],b=h[4],q=h[5],Y=h[6],V=h[7],I=h[8],Z=h[9],C=h[10],B=h[11],D=h[12],E=h[13],n=h[14],L=h[15],U=C*L-n*B,H=Z*L-E*B,R=Z*n-E*C,y=I*L-D*B,o=I*n-C*D,s=I*E-D*Z,v=+(q*U-Y*H+V*R),T=-(b*U-Y*y+V*o),X=+(b*H-q*y+V*s),g=-(b*R-q*o+Y*s),G=l*v+M*T+O*X+u*g;if(0===G)return!1;const e=1/G,a=Y*L-n*V,x=q*L-E*V,P=q*n-E*Y,d=b*L-D*V,J=b*n-D*Y,N=b*E-D*q,j=Y*B-C*V,K=q*B-Z*V,c=q*C-Z*Y,f=b*B-I*V,p=b*C-I*Y,k=b*Z-I*q,r=-(M*U-O*H+u*R),z=+(l*U-O*y+u*o),Q=-(l*H-M*y+u*s),F=+(l*R-M*o+O*s),w=+(M*a-O*x+u*P),t=-(l*a-O*d+u*J),A=+(l*x-M*d+u*N),i=-(l*P-M*J+O*N),W=-(M*j-O*K+u*c),mm=+(l*j-O*f+u*p),Sm=-(l*K-M*f+u*k),hm=+(l*c-M*p+O*k);return S[0]=v*e,S[1]=r*e,S[2]=w*e,S[3]=W*e,S[4]=T*e,S[5]=z*e,S[6]=t*e,S[7]=mm*e,S[8]=X*e,S[9]=Q*e,S[10]=A*e,S[11]=Sm*e,S[12]=g*e,S[13]=F*e,S[14]=i*e,S[15]=hm*e,!0}Y._UpdateFlagSeed=0;const C=m=>parseInt(m.toString().replace(/\W/g,""));class B{constructor(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=m,this.y=S}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let m=C(this.x);return m=397*m^C(this.y),m}toArray(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return m[S]=this.x,m[S+1]=this.y,this}yh(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B.FromArrayToRef(m,S,this),this}DM(){return[this.x,this.y]}l(m){return this.x=m.x,this.y=m.y,this}Yb(m,S){return this.x=m,this.y=S,this}set(m,S){return this.Yb(m,S)}Zb(m){return this.Yb(m,m)}add(m){return new B(this.x+m.x,this.y+m.y)}addToRef(m,S){return S.x=this.x+m.x,S.y=this.y+m.y,S}addInPlace(m){return this.x+=m.x,this.y+=m.y,this}addInPlaceFromFloats(m,S){return this.x+=m,this.y+=S,this}addVector3(m){return new B(this.x+m.x,this.y+m.y)}LS(m){return new B(this.x-m.x,this.y-m.y)}subtractToRef(m,S){return S.x=this.x-m.x,S.y=this.y-m.y,S}yI(m){return this.x-=m.x,this.y-=m.y,this}multiplyInPlace(m){return this.x*=m.x,this.y*=m.y,this}multiply(m){return new B(this.x*m.x,this.y*m.y)}multiplyToRef(m,S){return S.x=this.x*m.x,S.y=this.y*m.y,S}multiplyByFloats(m,S){return new B(this.x*m,this.y*S)}divide(m){return new B(this.x/m.x,this.y/m.y)}divideToRef(m,S){return S.x=this.x/m.x,S.y=this.y/m.y,S}divideInPlace(m){return this.x=this.x/m.x,this.y=this.y/m.y,this}minimizeInPlace(m){return this.minimizeInPlaceFromFloats(m.x,m.y)}maximizeInPlace(m){return this.maximizeInPlaceFromFloats(m.x,m.y)}minimizeInPlaceFromFloats(m,S){return this.x=Math.min(m,this.x),this.y=Math.min(S,this.y),this}maximizeInPlaceFromFloats(m,S){return this.x=Math.max(m,this.x),this.y=Math.max(S,this.y),this}subtractFromFloats(m,S){return new B(this.x-m,this.y-S)}subtractFromFloatsToRef(m,S,h){return h.x=this.x-m,h.y=this.y-S,h}negate(){return new B(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(m){return m.x=-this.x,m.y=-this.y,m}scaleInPlace(m){return this.x*=m,this.y*=m,this}scale(m){return new B(this.x*m,this.y*m)}scaleToRef(m,S){return S.x=this.x*m,S.y=this.y*m,S}scaleAndAddToRef(m,S){return S.x+=this.x*m,S.y+=this.y*m,S}equals(m){return m&&this.x===m.x&&this.y===m.y}equalsWithEpsilon(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.d;return m&&(0,q.WithinEpsilon)(this.x,m.x,S)&&(0,q.WithinEpsilon)(this.y,m.y,S)}equalsToFloats(m,S){return this.x===m&&this.y===S}floor(){return new B(Math.floor(this.x),Math.floor(this.y))}floorToRef(m){return m.x=Math.floor(this.x),m.y=Math.floor(this.y),m}fract(){return new B(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(m){return m.x=this.x-Math.floor(this.x),m.y=this.y-Math.floor(this.y),m}rotate(m){return this.rotateToRef(m,new B)}rotateToRef(m,S){const h=Math.cos(m),l=Math.sin(m);return S.x=h*this.x-l*this.y,S.y=l*this.x+h*this.y,S}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(m){return 0===m||1===m?this:this.scaleInPlace(1/m)}normalizeToNew(){const m=new B;return this.normalizeToRef(m),m}normalizeToRef(m){const S=this.length();return 0===S&&(m.x=this.x,m.y=this.y),this.scaleToRef(1/S,m)}clone(){return new B(this.x,this.y)}dot(m){return this.x*m.x+this.y*m.y}static Zero(){return new B(0,0)}static One(){return new B(1,1)}static Random(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new B((0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S))}static RandomToRef(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Yb((0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S))}static get ZeroReadOnly(){return B._ZeroReadOnly}static yS(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new B(m[S],m[S+1])}static FromArrayToRef(m,S,h){return h.x=m[S],h.y=m[S+1],h}static FromFloatsToRef(m,S,h){return h.Yb(m,S),h}static CatmullRom(m,S,h,l,M){const O=M*M,u=M*O,b=.5*(2*S.x+(-m.x+h.x)*M+(2*m.x-5*S.x+4*h.x-l.x)*O+(-m.x+3*S.x-3*h.x+l.x)*u),q=.5*(2*S.y+(-m.y+h.y)*M+(2*m.y-5*S.y+4*h.y-l.y)*O+(-m.y+3*S.y-3*h.y+l.y)*u);return new B(b,q)}static ClampToRef(m,S,h,l){return l.x=(0,q.Clamp)(m.x,S.x,h.x),l.y=(0,q.Clamp)(m.y,S.y,h.y),l}static Clamp(m,S,h){const l=(0,q.Clamp)(m.x,S.x,h.x),M=(0,q.Clamp)(m.y,S.y,h.y);return new B(l,M)}static Hermite(m,S,h,l,M){const O=M*M,u=M*O,b=2*u-3*O+1,q=-2*u+3*O,Y=u-2*O+M,V=u-O,I=m.x*b+h.x*q+S.x*Y+l.x*V,Z=m.y*b+h.y*q+S.y*Y+l.y*V;return new B(I,Z)}static Hermite1stDerivative(m,S,h,l,M){return this.Hermite1stDerivativeToRef(m,S,h,l,M,new B)}static Hermite1stDerivativeToRef(m,S,h,l,M,O){const u=M*M;return O.x=6*(u-M)*m.x+(3*u-4*M+1)*S.x+6*(-u+M)*h.x+(3*u-2*M)*l.x,O.y=6*(u-M)*m.y+(3*u-4*M+1)*S.y+6*(-u+M)*h.y+(3*u-2*M)*l.y,O}static Lerp(m,S,h){return B.LerpToRef(m,S,h,new B)}static LerpToRef(m,S,h,l){return l.x=m.x+(S.x-m.x)*h,l.y=m.y+(S.y-m.y)*h,l}static Dot(m,S){return m.x*S.x+m.y*S.y}static Normalize(m){return B.NormalizeToRef(m,new B)}static NormalizeToRef(m,S){return m.normalizeToRef(S),S}static Minimize(m,S){const h=m.x<S.x?m.x:S.x,l=m.y<S.y?m.y:S.y;return new B(h,l)}static Maximize(m,S){const h=m.x>S.x?m.x:S.x,l=m.y>S.y?m.y:S.y;return new B(h,l)}static Transform(m,S){return B.TransformToRef(m,S,new B)}static TransformToRef(m,S,h){const l=S.m,M=m.x*l[0]+m.y*l[4]+l[12],O=m.x*l[1]+m.y*l[5]+l[13];return h.x=M,h.y=O,h}static PointInTriangle(m,S,h,l){const M=.5*(-h.y*l.x+S.y*(-h.x+l.x)+S.x*(h.y-l.y)+h.x*l.y),O=M<0?-1:1,u=(S.y*l.x-S.x*l.y+(l.y-S.y)*m.x+(S.x-l.x)*m.y)*O,b=(S.x*h.y-S.y*h.x+(S.y-h.y)*m.x+(h.x-S.x)*m.y)*O;return u>0&&b>0&&u+b<2*M*O}static Distance(m,S){return Math.sqrt(B.DistanceSquared(m,S))}static DistanceSquared(m,S){const h=m.x-S.x,l=m.y-S.y;return h*h+l*l}static Center(m,S){return B.CenterToRef(m,S,new B)}static CenterToRef(m,S,h){return h.Yb((m.x+S.x)/2,(m.y+S.y)/2)}static DistanceOfPointFromSegment(m,S,h){const l=B.DistanceSquared(S,h);if(0===l)return B.Distance(m,S);const M=h.LS(S),O=Math.max(0,Math.min(1,B.Dot(m.LS(S),M)/l)),u=S.add(M.multiplyByFloats(O,O));return B.Distance(m,u)}}B._V8PerformanceHack=new B(.5,.5),B._ZeroReadOnly=B.Zero(),Object.defineProperties(B.prototype,{dimension:{value:[2]},rank:{value:1}});class D{get x(){return this._x}set x(m){this._x=m,this._isDirty=!0}get y(){return this._y}set y(m){this._y=m,this._isDirty=!0}get z(){return this._z}set z(m){this._z=m,this._isDirty=!0}constructor(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=m,this._y=S,this._z=h}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"nS"}getHashCode(){let m=C(this._x);return m=397*m^C(this._y),m=397*m^C(this._z),m}DM(){return[this._x,this._y,this._z]}toArray(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return m[S]=this._x,m[S+1]=this._y,m[S+2]=this._z,this}yh(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D.FromArrayToRef(m,S,this),this}toQuaternion(){return n.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(m){return this._x+=m._x,this._y+=m._y,this._z+=m._z,this._isDirty=!0,this}addInPlaceFromFloats(m,S,h){return this._x+=m,this._y+=S,this._z+=h,this._isDirty=!0,this}add(m){return new D(this._x+m._x,this._y+m._y,this._z+m._z)}addToRef(m,S){return S._x=this._x+m._x,S._y=this._y+m._y,S._z=this._z+m._z,S._isDirty=!0,S}yI(m){return this._x-=m._x,this._y-=m._y,this._z-=m._z,this._isDirty=!0,this}LS(m){return new D(this._x-m._x,this._y-m._y,this._z-m._z)}subtractToRef(m,S){return this.subtractFromFloatsToRef(m._x,m._y,m._z,S)}subtractFromFloats(m,S,h){return new D(this._x-m,this._y-S,this._z-h)}subtractFromFloatsToRef(m,S,h,l){return l._x=this._x-m,l._y=this._y-S,l._z=this._z-h,l._isDirty=!0,l}negate(){return new D(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(m){return m._x=-1*this._x,m._y=-1*this._y,m._z=-1*this._z,m._isDirty=!0,m}scaleInPlace(m){return this._x*=m,this._y*=m,this._z*=m,this._isDirty=!0,this}scale(m){return new D(this._x*m,this._y*m,this._z*m)}scaleToRef(m,S){return S._x=this._x*m,S._y=this._y*m,S._z=this._z*m,S._isDirty=!0,S}getNormalToRef(m){const S=this.length();let h=Math.acos(this._y/S);const l=Math.atan2(this._z,this._x);h>Math.PI/2?h-=Math.PI/2:h+=Math.PI/2;const M=S*Math.sin(h)*Math.cos(l),O=S*Math.cos(h),u=S*Math.sin(h)*Math.sin(l);return m.set(M,O,u),m}applyRotationQuaternionToRef(m,S){const h=this._x,l=this._y,M=this._z,O=m._x,u=m._y,b=m._z,q=m._w,Y=2*(u*M-b*l),V=2*(b*h-O*M),I=2*(O*l-u*h);return S._x=h+q*Y+u*I-b*V,S._y=l+q*V+b*Y-O*I,S._z=M+q*I+O*V-u*Y,S._isDirty=!0,S}applyRotationQuaternionInPlace(m){return this.applyRotationQuaternionToRef(m,this)}applyRotationQuaternion(m){return this.applyRotationQuaternionToRef(m,new D)}scaleAndAddToRef(m,S){return S._x+=this._x*m,S._y+=this._y*m,S._z+=this._z*m,S._isDirty=!0,S}projectOnPlane(m,S){return this.projectOnPlaneToRef(m,S,new D)}projectOnPlaneToRef(m,S,h){const l=m.normal,M=m.d,O=U.nS[0];this.subtractToRef(S,O),O.normalize();const u=D.Dot(O,l);if(Math.abs(u)<1e-10)h.Zb(1/0);else{const m=-(D.Dot(S,l)+M)/u,b=O.scaleInPlace(m);S.addToRef(b,h)}return h}equals(m){return m&&this._x===m._x&&this._y===m._y&&this._z===m._z}equalsWithEpsilon(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.d;return m&&(0,q.WithinEpsilon)(this._x,m._x,S)&&(0,q.WithinEpsilon)(this._y,m._y,S)&&(0,q.WithinEpsilon)(this._z,m._z,S)}equalsToFloats(m,S,h){return this._x===m&&this._y===S&&this._z===h}multiplyInPlace(m){return this._x*=m._x,this._y*=m._y,this._z*=m._z,this._isDirty=!0,this}multiply(m){return this.multiplyByFloats(m._x,m._y,m._z)}multiplyToRef(m,S){return S._x=this._x*m._x,S._y=this._y*m._y,S._z=this._z*m._z,S._isDirty=!0,S}multiplyByFloats(m,S,h){return new D(this._x*m,this._y*S,this._z*h)}divide(m){return new D(this._x/m._x,this._y/m._y,this._z/m._z)}divideToRef(m,S){return S._x=this._x/m._x,S._y=this._y/m._y,S._z=this._z/m._z,S._isDirty=!0,S}divideInPlace(m){return this._x=this._x/m._x,this._y=this._y/m._y,this._z=this._z/m._z,this._isDirty=!0,this}minimizeInPlace(m){return this.minimizeInPlaceFromFloats(m._x,m._y,m._z)}maximizeInPlace(m){return this.maximizeInPlaceFromFloats(m._x,m._y,m._z)}minimizeInPlaceFromFloats(m,S,h){return m<this._x&&(this.x=m),S<this._y&&(this.y=S),h<this._z&&(this.z=h),this}maximizeInPlaceFromFloats(m,S,h){return m>this._x&&(this.x=m),S>this._y&&(this.y=S),h>this._z&&(this.z=h),this}isNonUniformWithinEpsilon(m){const S=Math.abs(this._x),h=Math.abs(this._y);if(!(0,q.WithinEpsilon)(S,h,m))return!0;const l=Math.abs(this._z);return!(0,q.WithinEpsilon)(S,l,m)||!(0,q.WithinEpsilon)(h,l,m)}get isNonUniform(){const m=Math.abs(this._x);if(m!==Math.abs(this._y))return!0;return m!==Math.abs(this._z)}floorToRef(m){return m._x=Math.floor(this._x),m._y=Math.floor(this._y),m._z=Math.floor(this._z),m._isDirty=!0,m}floor(){return new D(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(m){return m._x=this._x-Math.floor(this._x),m._y=this._y-Math.floor(this._y),m._z=this._z-Math.floor(this._z),m._isDirty=!0,m}fract(){return new D(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(m){if("xyz"===(m=m.toLowerCase()))return this;const S=U.nS[0].l(this);return this.x=S[m[0]],this.y=S[m[1]],this.z=S[m[2]],this}rotateByQuaternionToRef(m,S){return m.toRotationMatrix(U.Matrix[0]),D.TransformCoordinatesToRef(this,U.Matrix[0],S),S}rotateByQuaternionAroundPointToRef(m,S,h){return this.subtractToRef(S,U.nS[0]),U.nS[0].rotateByQuaternionToRef(m,U.nS[0]),S.addToRef(U.nS[0],h),h}cross(m){return D.CrossToRef(this,m,new D)}normalizeFromLength(m){return 0===m||1===m?this:this.scaleInPlace(1/m)}normalizeToNew(){return this.normalizeToRef(new D)}normalizeToRef(m){const S=this.length();return 0===S||1===S?(m._x=this._x,m._y=this._y,m._z=this._z,m._isDirty=!0,m):this.scaleToRef(1/S,m)}clone(){return new D(this._x,this._y,this._z)}l(m){return this.Yb(m._x,m._y,m._z)}Yb(m,S,h){return this._x=m,this._y=S,this._z=h,this._isDirty=!0,this}set(m,S,h){return this.Yb(m,S,h)}Zb(m){return this._x=this._y=this._z=m,this._isDirty=!0,this}static GetClipFactor(m,S,h,l){const M=D.Dot(m,h);return(M-l)/(M-D.Dot(S,h))}static GetAngleBetweenVectors(m,S,h){const l=m.normalizeToRef(U.nS[1]),M=S.normalizeToRef(U.nS[2]);let O=D.Dot(l,M);O=(0,q.Clamp)(O,-1,1);const u=Math.acos(O),b=U.nS[3];return D.CrossToRef(l,M,b),D.Dot(b,h)>0?isNaN(u)?0:u:isNaN(u)?-Math.PI:-Math.acos(O)}static GetAngleBetweenVectorsOnPlane(m,S,h){U.nS[0].l(m);const l=U.nS[0];U.nS[1].l(S);const M=U.nS[1];U.nS[2].l(h);const O=U.nS[2],u=U.nS[3],b=U.nS[4];l.normalize(),M.normalize(),O.normalize(),D.CrossToRef(O,l,u),D.CrossToRef(u,O,b);const Y=Math.atan2(D.Dot(M,u),D.Dot(M,b));return(0,q.NormalizeRadians)(Y)}static PitchYawRollToMoveBetweenPointsToRef(m,S,h){const l=H.nS[0];return S.subtractToRef(m,l),h._y=Math.atan2(l.x,l.z)||0,h._x=Math.atan2(Math.sqrt(l.x**2+l.z**2),l.y)||0,h._z=0,h._isDirty=!0,h}static PitchYawRollToMoveBetweenPoints(m,S){const h=D.Zero();return D.PitchYawRollToMoveBetweenPointsToRef(m,S,h)}static SlerpToRef(m,S,h,M){h=(0,q.Clamp)(h,0,1);const O=U.nS[0],u=U.nS[1];O.l(m);const b=O.length();O.normalizeFromLength(b),u.l(S);const Y=u.length();u.normalizeFromLength(Y);const V=D.Dot(O,u);let I,Z;if(V<1-l.d){const m=Math.acos(V),S=1/Math.sin(m);I=Math.sin((1-h)*m)*S,Z=Math.sin(h*m)*S}else I=1-h,Z=h;return O.scaleInPlace(I),u.scaleInPlace(Z),M.l(O).addInPlace(u),M.scaleInPlace((0,q.Lerp)(b,Y,h)),M}static SmoothToRef(m,S,h,l,M){return D.SlerpToRef(m,S,0===l?1:h/l,M),M}static yS(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new D(m[S],m[S+1],m[S+2])}static FromFloatArray(m,S){return D.yS(m,S)}static FromArrayToRef(m,S,h){return h._x=m[S],h._y=m[S+1],h._z=m[S+2],h._isDirty=!0,h}static FromFloatArrayToRef(m,S,h){return D.FromArrayToRef(m,S,h)}static FromFloatsToRef(m,S,h,l){return l.Yb(m,S,h),l}static Zero(){return new D(0,0,0)}static One(){return new D(1,1,1)}static Up(){return new D(0,1,0)}static get UpReadOnly(){return D._UpReadOnly}static get DownReadOnly(){return D._DownReadOnly}static get RightReadOnly(){return D._RightReadOnly}static get LeftReadOnly(){return D._LeftReadOnly}static get LeftHandedForwardReadOnly(){return D._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return D._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return D._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return D._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return D._ZeroReadOnly}static get OneReadOnly(){return D._OneReadOnly}static Down(){return new D(0,-1,0)}static Forward(){return new D(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new D(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new D(1,0,0)}static Left(){return new D(-1,0,0)}static Random(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new D((0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S))}static RandomToRef(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Yb((0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S))}static TransformCoordinates(m,S){const h=D.Zero();return D.TransformCoordinatesToRef(m,S,h),h}static TransformCoordinatesToRef(m,S,h){return D.TransformCoordinatesFromFloatsToRef(m._x,m._y,m._z,S,h),h}static TransformCoordinatesFromFloatsToRef(m,S,h,l,M){const O=l.m,u=m*O[0]+S*O[4]+h*O[8]+O[12],b=m*O[1]+S*O[5]+h*O[9]+O[13],q=m*O[2]+S*O[6]+h*O[10]+O[14],Y=1/(m*O[3]+S*O[7]+h*O[11]+O[15]);return M._x=u*Y,M._y=b*Y,M._z=q*Y,M._isDirty=!0,M}static TransformNormal(m,S){const h=D.Zero();return D.TransformNormalToRef(m,S,h),h}static TransformNormalToRef(m,S,h){return this.TransformNormalFromFloatsToRef(m._x,m._y,m._z,S,h),h}static TransformNormalFromFloatsToRef(m,S,h,l,M){const O=l.m;return M._x=m*O[0]+S*O[4]+h*O[8],M._y=m*O[1]+S*O[5]+h*O[9],M._z=m*O[2]+S*O[6]+h*O[10],M._isDirty=!0,M}static CatmullRom(m,S,h,l,M){const O=M*M,u=M*O,b=.5*(2*S._x+(-m._x+h._x)*M+(2*m._x-5*S._x+4*h._x-l._x)*O+(-m._x+3*S._x-3*h._x+l._x)*u),q=.5*(2*S._y+(-m._y+h._y)*M+(2*m._y-5*S._y+4*h._y-l._y)*O+(-m._y+3*S._y-3*h._y+l._y)*u),Y=.5*(2*S._z+(-m._z+h._z)*M+(2*m._z-5*S._z+4*h._z-l._z)*O+(-m._z+3*S._z-3*h._z+l._z)*u);return new D(b,q,Y)}static Clamp(m,S,h){const l=new D;return D.ClampToRef(m,S,h,l),l}static ClampToRef(m,S,h,l){let M=m._x;M=M>h._x?h._x:M,M=M<S._x?S._x:M;let O=m._y;O=O>h._y?h._y:O,O=O<S._y?S._y:O;let u=m._z;return u=u>h._z?h._z:u,u=u<S._z?S._z:u,l.Yb(M,O,u),l}static CheckExtends(m,S,h){S.minimizeInPlace(m),h.maximizeInPlace(m)}static Hermite(m,S,h,l,M){const O=M*M,u=M*O,b=2*u-3*O+1,q=-2*u+3*O,Y=u-2*O+M,V=u-O,I=m._x*b+h._x*q+S._x*Y+l._x*V,Z=m._y*b+h._y*q+S._y*Y+l._y*V,C=m._z*b+h._z*q+S._z*Y+l._z*V;return new D(I,Z,C)}static Hermite1stDerivative(m,S,h,l,M){const O=new D;return this.Hermite1stDerivativeToRef(m,S,h,l,M,O),O}static Hermite1stDerivativeToRef(m,S,h,l,M,O){const u=M*M;return O._x=6*(u-M)*m._x+(3*u-4*M+1)*S._x+6*(-u+M)*h._x+(3*u-2*M)*l._x,O._y=6*(u-M)*m._y+(3*u-4*M+1)*S._y+6*(-u+M)*h._y+(3*u-2*M)*l._y,O._z=6*(u-M)*m._z+(3*u-4*M+1)*S._z+6*(-u+M)*h._z+(3*u-2*M)*l._z,O._isDirty=!0,O}static Lerp(m,S,h){const l=new D(0,0,0);return D.LerpToRef(m,S,h,l),l}static LerpToRef(m,S,h,l){return l._x=m._x+(S._x-m._x)*h,l._y=m._y+(S._y-m._y)*h,l._z=m._z+(S._z-m._z)*h,l._isDirty=!0,l}static Dot(m,S){return m._x*S._x+m._y*S._y+m._z*S._z}dot(m){return this._x*m._x+this._y*m._y+this._z*m._z}static Cross(m,S){const h=new D;return D.CrossToRef(m,S,h),h}static CrossToRef(m,S,h){const l=m._y*S._z-m._z*S._y,M=m._z*S._x-m._x*S._z,O=m._x*S._y-m._y*S._x;return h.Yb(l,M,O),h}static Normalize(m){const S=D.Zero();return D.NormalizeToRef(m,S),S}static NormalizeToRef(m,S){return m.normalizeToRef(S),S}static Project(m,S,h,l){const M=new D;return D.ProjectToRef(m,S,h,l,M),M}static ProjectToRef(m,S,h,l,M){var O;const u=l.width,q=l.height,Y=l.x,V=l.y,I=U.Matrix[1],Z=null===(O=b.d.LastCreatedEngine)||void 0===O?void 0:O.isNDCHalfZRange,C=Z?1:.5,B=Z?0:.5;L.FromValuesToRef(u/2,0,0,0,0,-q/2,0,0,0,0,C,0,Y+u/2,q/2+V,B,1,I);const E=U.Matrix[0];return S.multiplyToRef(h,E),E.multiplyToRef(I,E),D.TransformCoordinatesToRef(m,E,M),M}static Reflect(m,S){return this.ReflectToRef(m,S,new D)}static ReflectToRef(m,S,h){const l=H.nS[0];return l.l(S).scaleInPlace(2*D.Dot(m,S)),h.l(m).yI(l)}static _UnprojectFromInvertedMatrixToRef(m,S,h){D.TransformCoordinatesToRef(m,S,h);const l=S.m,M=m._x*l[3]+m._y*l[7]+m._z*l[11]+l[15];return(0,q.WithinEpsilon)(M,1)&&h.scaleInPlace(1/M),h}static UnprojectFromTransform(m,S,h,l,M){return this.Unproject(m,S,h,l,M,L.IdentityReadOnly)}static Unproject(m,S,h,l,M,O){const u=new D;return D.UnprojectToRef(m,S,h,l,M,O,u),u}static UnprojectToRef(m,S,h,l,M,O,u){return D.UnprojectFloatsToRef(m._x,m._y,m._z,S,h,l,M,O,u),u}static UnprojectFloatsToRef(m,S,h,l,M,O,u,q,Y){var V;const I=U.Matrix[0];O.multiplyToRef(u,I),I.multiplyToRef(q,I),I.invert();const Z=U.nS[0];return Z.x=m/l*2-1,Z.y=-(S/M*2-1),null!==(V=b.d.LastCreatedEngine)&&void 0!==V&&V.isNDCHalfZRange?Z.z=h:Z.z=2*h-1,D._UnprojectFromInvertedMatrixToRef(Z,I,Y),Y}static Minimize(m,S){const h=new D;return h.l(m),h.minimizeInPlace(S),h}static Maximize(m,S){const h=new D;return h.l(m),h.maximizeInPlace(S),h}static Distance(m,S){return Math.sqrt(D.DistanceSquared(m,S))}static DistanceSquared(m,S){const h=m._x-S._x,l=m._y-S._y,M=m._z-S._z;return h*h+l*l+M*M}static ProjectOnTriangleToRef(m,S,h,M,O){const u=U.nS[0],b=U.nS[1],Y=U.nS[2],V=U.nS[3],I=U.nS[4];h.subtractToRef(S,u),M.subtractToRef(S,b),M.subtractToRef(h,Y);const Z=u.length(),C=b.length(),B=Y.length();if(Z<l.d||C<l.d||B<l.d)return O.l(S),D.Distance(m,S);m.subtractToRef(S,I),D.CrossToRef(u,b,V);const E=V.length();if(E<l.d)return O.l(S),D.Distance(m,S);V.normalizeFromLength(E);let n=I.length();if(n<l.d)return O.l(S),0;I.normalizeFromLength(n);const L=D.Dot(V,I),H=U.nS[5],R=U.nS[6];H.l(V).scaleInPlace(-n*L),R.l(m).addInPlace(H);const y=U.nS[4],o=U.nS[5],s=U.nS[7],v=U.nS[8];y.l(u).scaleInPlace(1/Z),v.l(b).scaleInPlace(1/C),y.addInPlace(v).scaleInPlace(-1),o.l(u).scaleInPlace(-1/Z),v.l(Y).scaleInPlace(1/B),o.addInPlace(v).scaleInPlace(-1),s.l(Y).scaleInPlace(-1/B),v.l(b).scaleInPlace(-1/C),s.addInPlace(v).scaleInPlace(-1);const T=U.nS[9];let X;T.l(R).yI(S),D.CrossToRef(y,T,v),X=D.Dot(v,V);const g=X;T.l(R).yI(h),D.CrossToRef(o,T,v),X=D.Dot(v,V);const G=X;T.l(R).yI(M),D.CrossToRef(s,T,v),X=D.Dot(v,V);const e=X,a=U.nS[10];let x,P;g>0&&G<0?(a.l(u),x=S,P=h):G>0&&e<0?(a.l(Y),x=h,P=M):(a.l(b).scaleInPlace(-1),x=M,P=S);const d=U.nS[9],J=U.nS[4];x.subtractToRef(R,v),P.subtractToRef(R,d),D.CrossToRef(v,d,J);if(!(D.Dot(J,V)<0))return O.l(R),Math.abs(n*L);const N=U.nS[5];D.CrossToRef(a,J,N),N.normalize();const j=U.nS[9];j.l(x).yI(R);const K=j.length();if(K<l.d)return O.l(x),D.Distance(m,x);j.normalizeFromLength(K);const c=D.Dot(N,j),f=U.nS[7];f.l(R).addInPlace(N.scaleInPlace(K*c)),v.l(f).yI(x),n=a.length(),a.normalizeFromLength(n);let p=D.Dot(v,a)/Math.max(n,l.d);return p=(0,q.Clamp)(p,0,1),f.l(x).addInPlace(a.scaleInPlace(p*n)),O.l(f),D.Distance(m,f)}static Center(m,S){return D.CenterToRef(m,S,D.Zero())}static CenterToRef(m,S,h){return h.Yb((m._x+S._x)/2,(m._y+S._y)/2,(m._z+S._z)/2)}static RotationFromAxis(m,S,h){const l=new D;return D.RotationFromAxisToRef(m,S,h,l),l}static RotationFromAxisToRef(m,S,h,l){const M=U.Quaternion[0];return n.RotationQuaternionFromAxisToRef(m,S,h,M),M.toEulerAnglesToRef(l),l}}D._V8PerformanceHack=new D(.5,.5,.5),D._UpReadOnly=D.Up(),D._DownReadOnly=D.Down(),D._LeftHandedForwardReadOnly=D.Forward(!1),D._RightHandedForwardReadOnly=D.Forward(!0),D._LeftHandedBackwardReadOnly=D.Backward(!1),D._RightHandedBackwardReadOnly=D.Backward(!0),D._RightReadOnly=D.Right(),D._LeftReadOnly=D.Left(),D._ZeroReadOnly=D.Zero(),D._OneReadOnly=D.One(),Object.defineProperties(D.prototype,{dimension:{value:[3]},rank:{value:1}});class E{get x(){return this._x}set x(m){this._x=m,this._isDirty=!0}get y(){return this._y}set y(m){this._y=m,this._isDirty=!0}get z(){return this._z}set z(m){this._z=m,this._isDirty=!0}get w(){return this._w}set w(m){this._w=m,this._isDirty=!0}constructor(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=m,this._y=S,this._z=h,this._w=l}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let m=C(this._x);return m=397*m^C(this._y),m=397*m^C(this._z),m=397*m^C(this._w),m}DM(){return[this._x,this._y,this._z,this._w]}toArray(m,S){return void 0===S&&(S=0),m[S]=this._x,m[S+1]=this._y,m[S+2]=this._z,m[S+3]=this._w,this}yh(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(m,S,this),this}addInPlace(m){return this.x+=m._x,this.y+=m._y,this.z+=m._z,this.w+=m._w,this}addInPlaceFromFloats(m,S,h,l){return this.x+=m,this.y+=S,this.z+=h,this.w+=l,this}add(m){return new E(this._x+m.x,this._y+m.y,this._z+m.z,this._w+m.w)}addToRef(m,S){return S.x=this._x+m.x,S.y=this._y+m.y,S.z=this._z+m.z,S.w=this._w+m.w,S}yI(m){return this.x-=m.x,this.y-=m.y,this.z-=m.z,this.w-=m.w,this}LS(m){return new E(this._x-m.x,this._y-m.y,this._z-m.z,this._w-m.w)}subtractToRef(m,S){return S.x=this._x-m.x,S.y=this._y-m.y,S.z=this._z-m.z,S.w=this._w-m.w,S}subtractFromFloats(m,S,h,l){return new E(this._x-m,this._y-S,this._z-h,this._w-l)}subtractFromFloatsToRef(m,S,h,l,M){return M.x=this._x-m,M.y=this._y-S,M.z=this._z-h,M.w=this._w-l,M}negate(){return new E(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(m){return m.x=-this._x,m.y=-this._y,m.z=-this._z,m.w=-this._w,m}scaleInPlace(m){return this.x*=m,this.y*=m,this.z*=m,this.w*=m,this}scale(m){return new E(this._x*m,this._y*m,this._z*m,this._w*m)}scaleToRef(m,S){return S.x=this._x*m,S.y=this._y*m,S.z=this._z*m,S.w=this._w*m,S}scaleAndAddToRef(m,S){return S.x+=this._x*m,S.y+=this._y*m,S.z+=this._z*m,S.w+=this._w*m,S}equals(m){return m&&this._x===m.x&&this._y===m.y&&this._z===m.z&&this._w===m.w}equalsWithEpsilon(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.d;return m&&(0,q.WithinEpsilon)(this._x,m.x,S)&&(0,q.WithinEpsilon)(this._y,m.y,S)&&(0,q.WithinEpsilon)(this._z,m.z,S)&&(0,q.WithinEpsilon)(this._w,m.w,S)}equalsToFloats(m,S,h,l){return this._x===m&&this._y===S&&this._z===h&&this._w===l}multiplyInPlace(m){return this.x*=m.x,this.y*=m.y,this.z*=m.z,this.w*=m.w,this}multiply(m){return new E(this._x*m.x,this._y*m.y,this._z*m.z,this._w*m.w)}multiplyToRef(m,S){return S.x=this._x*m.x,S.y=this._y*m.y,S.z=this._z*m.z,S.w=this._w*m.w,S}multiplyByFloats(m,S,h,l){return new E(this._x*m,this._y*S,this._z*h,this._w*l)}divide(m){return new E(this._x/m.x,this._y/m.y,this._z/m.z,this._w/m.w)}divideToRef(m,S){return S.x=this._x/m.x,S.y=this._y/m.y,S.z=this._z/m.z,S.w=this._w/m.w,S}divideInPlace(m){return this.divideToRef(m,this)}minimizeInPlace(m){return m.x<this._x&&(this.x=m.x),m.y<this._y&&(this.y=m.y),m.z<this._z&&(this.z=m.z),m.w<this._w&&(this.w=m.w),this}maximizeInPlace(m){return m.x>this._x&&(this.x=m.x),m.y>this._y&&(this.y=m.y),m.z>this._z&&(this.z=m.z),m.w>this._w&&(this.w=m.w),this}minimizeInPlaceFromFloats(m,S,h,l){return this.x=Math.min(m,this._x),this.y=Math.min(S,this._y),this.z=Math.min(h,this._z),this.w=Math.min(l,this._w),this}maximizeInPlaceFromFloats(m,S,h,l){return this.x=Math.max(m,this._x),this.y=Math.max(S,this._y),this.z=Math.max(h,this._z),this.w=Math.max(l,this._w),this}floorToRef(m){return m.x=Math.floor(this._x),m.y=Math.floor(this._y),m.z=Math.floor(this._z),m.w=Math.floor(this._w),m}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(m){return m.x=this._x-Math.floor(this._x),m.y=this._y-Math.floor(this._y),m.z=this._z-Math.floor(this._z),m.w=this._w-Math.floor(this._w),m}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(m){return 0===m||1===m?this:this.scaleInPlace(1/m)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(m){const S=this.length();return 0===S||1===S?(m.x=this._x,m.y=this._y,m.z=this._z,m.w=this._w,m):this.scaleToRef(1/S,m)}toVector3(){return new D(this._x,this._y,this._z)}clone(){return new E(this._x,this._y,this._z,this._w)}l(m){return this.x=m.x,this.y=m.y,this.z=m.z,this.w=m.w,this}Yb(m,S,h,l){return this.x=m,this.y=S,this.z=h,this.w=l,this}set(m,S,h,l){return this.Yb(m,S,h,l)}Zb(m){return this.x=this.y=this.z=this.w=m,this}dot(m){return this._x*m.x+this._y*m.y+this._z*m.z+this._w*m.w}static yS(m,S){return S||(S=0),new E(m[S],m[S+1],m[S+2],m[S+3])}static FromArrayToRef(m,S,h){return h.x=m[S],h.y=m[S+1],h.z=m[S+2],h.w=m[S+3],h}static FromFloatArrayToRef(m,S,h){return E.FromArrayToRef(m,S,h),h}static FromFloatsToRef(m,S,h,l,M){return M.x=m,M.y=S,M.z=h,M.w=l,M}static Zero(){return new E(0,0,0,0)}static One(){return new E(1,1,1,1)}static Random(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S))}static RandomToRef(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0;return h.x=(0,q.RandomRange)(m,S),h.y=(0,q.RandomRange)(m,S),h.z=(0,q.RandomRange)(m,S),h.w=(0,q.RandomRange)(m,S),h}static Clamp(m,S,h){return E.ClampToRef(m,S,h,new E)}static ClampToRef(m,S,h,l){return l.x=(0,q.Clamp)(m.x,S.x,h.x),l.y=(0,q.Clamp)(m.y,S.y,h.y),l.z=(0,q.Clamp)(m.z,S.z,h.z),l.w=(0,q.Clamp)(m.w,S.w,h.w),l}static CheckExtends(m,S,h){S.minimizeInPlace(m),h.maximizeInPlace(m)}static get ZeroReadOnly(){return E._ZeroReadOnly}static Normalize(m){return E.NormalizeToRef(m,new E)}static NormalizeToRef(m,S){return m.normalizeToRef(S),S}static Minimize(m,S){const h=new E;return h.l(m),h.minimizeInPlace(S),h}static Maximize(m,S){const h=new E;return h.l(m),h.maximizeInPlace(S),h}static Distance(m,S){return Math.sqrt(E.DistanceSquared(m,S))}static DistanceSquared(m,S){const h=m.x-S.x,l=m.y-S.y,M=m.z-S.z,O=m.w-S.w;return h*h+l*l+M*M+O*O}static Center(m,S){return E.CenterToRef(m,S,new E)}static CenterToRef(m,S,h){return h.x=(m.x+S.x)/2,h.y=(m.y+S.y)/2,h.z=(m.z+S.z)/2,h.w=(m.w+S.w)/2,h}static TransformCoordinates(m,S){return E.TransformCoordinatesToRef(m,S,new E)}static TransformCoordinatesToRef(m,S,h){return E.TransformCoordinatesFromFloatsToRef(m._x,m._y,m._z,S,h),h}static TransformCoordinatesFromFloatsToRef(m,S,h,l,M){const O=l.m,u=m*O[0]+S*O[4]+h*O[8]+O[12],b=m*O[1]+S*O[5]+h*O[9]+O[13],q=m*O[2]+S*O[6]+h*O[10]+O[14],Y=m*O[3]+S*O[7]+h*O[11]+O[15];return M.x=u,M.y=b,M.z=q,M.w=Y,M}static TransformNormal(m,S){return E.TransformNormalToRef(m,S,new E)}static TransformNormalToRef(m,S,h){const l=S.m,M=m.x*l[0]+m.y*l[4]+m.z*l[8],O=m.x*l[1]+m.y*l[5]+m.z*l[9],u=m.x*l[2]+m.y*l[6]+m.z*l[10];return h.x=M,h.y=O,h.z=u,h.w=m.w,h}static TransformNormalFromFloatsToRef(m,S,h,l,M,O){const u=M.m;return O.x=m*u[0]+S*u[4]+h*u[8],O.y=m*u[1]+S*u[5]+h*u[9],O.z=m*u[2]+S*u[6]+h*u[10],O.w=l,O}static FromVector3(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(m._x,m._y,m._z,S)}static Dot(m,S){return m.x*S.x+m.y*S.y+m.z*S.z+m.w*S.w}}E._V8PerformanceHack=new E(.5,.5,.5,.5),E._ZeroReadOnly=E.Zero(),Object.defineProperties(E.prototype,{dimension:{value:[4]},rank:{value:1}});class n{get x(){return this._x}set x(m){this._x=m,this._isDirty=!0}get y(){return this._y}set y(m){this._y=m,this._isDirty=!0}get z(){return this._z}set z(m){this._z=m,this._isDirty=!0}get w(){return this._w}set w(m){this._w=m,this._isDirty=!0}constructor(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=m,this._y=S,this._z=h,this._w=l}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let m=C(this._x);return m=397*m^C(this._y),m=397*m^C(this._z),m=397*m^C(this._w),m}DM(){return[this._x,this._y,this._z,this._w]}toArray(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return m[S]=this._x,m[S+1]=this._y,m[S+2]=this._z,m[S+3]=this._w,this}yh(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n.FromArrayToRef(m,S,this)}equals(m){return m&&this._x===m._x&&this._y===m._y&&this._z===m._z&&this._w===m._w}equalsWithEpsilon(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.d;return m&&(0,q.WithinEpsilon)(this._x,m._x,S)&&(0,q.WithinEpsilon)(this._y,m._y,S)&&(0,q.WithinEpsilon)(this._z,m._z,S)&&(0,q.WithinEpsilon)(this._w,m._w,S)}isApprox(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.d;return m&&((0,q.WithinEpsilon)(this._x,m._x,S)&&(0,q.WithinEpsilon)(this._y,m._y,S)&&(0,q.WithinEpsilon)(this._z,m._z,S)&&(0,q.WithinEpsilon)(this._w,m._w,S)||(0,q.WithinEpsilon)(this._x,-m._x,S)&&(0,q.WithinEpsilon)(this._y,-m._y,S)&&(0,q.WithinEpsilon)(this._z,-m._z,S)&&(0,q.WithinEpsilon)(this._w,-m._w,S))}clone(){return new n(this._x,this._y,this._z,this._w)}l(m){return this._x=m._x,this._y=m._y,this._z=m._z,this._w=m._w,this._isDirty=!0,this}Yb(m,S,h,l){return this._x=m,this._y=S,this._z=h,this._w=l,this._isDirty=!0,this}set(m,S,h,l){return this.Yb(m,S,h,l)}Zb(m){return this.Yb(m,m,m,m)}add(m){return new n(this._x+m._x,this._y+m._y,this._z+m._z,this._w+m._w)}addInPlace(m){return this._x+=m._x,this._y+=m._y,this._z+=m._z,this._w+=m._w,this._isDirty=!0,this}addToRef(m,S){return S._x=this._x+m._x,S._y=this._y+m._y,S._z=this._z+m._z,S._w=this._w+m._w,S._isDirty=!0,S}addInPlaceFromFloats(m,S,h,l){return this._x+=m,this._y+=S,this._z+=h,this._w+=l,this._isDirty=!0,this}subtractToRef(m,S){return S._x=this._x-m._x,S._y=this._y-m._y,S._z=this._z-m._z,S._w=this._w-m._w,S._isDirty=!0,S}subtractFromFloats(m,S,h,l){return this.subtractFromFloatsToRef(m,S,h,l,new n)}subtractFromFloatsToRef(m,S,h,l,M){return M._x=this._x-m,M._y=this._y-S,M._z=this._z-h,M._w=this._w-l,M._isDirty=!0,M}LS(m){return new n(this._x-m._x,this._y-m._y,this._z-m._z,this._w-m._w)}yI(m){return this._x-=m._x,this._y-=m._y,this._z-=m._z,this._w-=m._w,this._isDirty=!0,this}scale(m){return new n(this._x*m,this._y*m,this._z*m,this._w*m)}scaleToRef(m,S){return S._x=this._x*m,S._y=this._y*m,S._z=this._z*m,S._w=this._w*m,S._isDirty=!0,S}scaleInPlace(m){return this._x*=m,this._y*=m,this._z*=m,this._w*=m,this._isDirty=!0,this}scaleAndAddToRef(m,S){return S._x+=this._x*m,S._y+=this._y*m,S._z+=this._z*m,S._w+=this._w*m,S._isDirty=!0,S}multiply(m){const S=new n(0,0,0,1);return this.multiplyToRef(m,S),S}multiplyToRef(m,S){const h=this._x*m._w+this._y*m._z-this._z*m._y+this._w*m._x,l=-this._x*m._z+this._y*m._w+this._z*m._x+this._w*m._y,M=this._x*m._y-this._y*m._x+this._z*m._w+this._w*m._z,O=-this._x*m._x-this._y*m._y-this._z*m._z+this._w*m._w;return S.Yb(h,l,M,O),S}multiplyInPlace(m){return this.multiplyToRef(m,this)}multiplyByFloats(m,S,h,l){return this._x*=m,this._y*=S,this._z*=h,this._w*=l,this._isDirty=!0,this}divide(m){throw new ReferenceError("Can not divide a quaternion")}divideToRef(m,S){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(m){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new n)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(m){return m._x=-this._x,m._y=-this._y,m._z=-this._z,m._w=-this._w,m._isDirty=!0,m}equalsToFloats(m,S,h,l){return this._x===m&&this._y===S&&this._z===h&&this._w===l}floorToRef(m){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(m){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(m){return m.Yb(-this._x,-this._y,-this._z,this._w),m}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new n(-this._x,-this._y,-this._z,this._w)}invert(){const m=this.conjugate(),S=this.lengthSquared();return 0==S||1==S||m.scaleInPlace(1/S),m}invertInPlace(){this.conjugateInPlace();const m=this.lengthSquared();return 0==m||1==m||this.scaleInPlace(1/m),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(m){return 0===m||1===m?this:this.scaleInPlace(1/m)}normalizeToNew(){const m=new n(0,0,0,1);return this.normalizeToRef(m),m}normalizeToRef(m){const S=this.length();return 0===S||1===S?m.Yb(this._x,this._y,this._z,this._w):this.scaleToRef(1/S,m)}toEulerAngles(){const m=D.Zero();return this.toEulerAnglesToRef(m),m}toEulerAnglesToRef(m){const S=this._z,h=this._x,l=this._y,M=this._w,O=l*S-h*M,u=.4999999;if(O<-u)m._y=2*Math.atan2(l,M),m._x=Math.PI/2,m._z=0,m._isDirty=!0;else if(O>u)m._y=2*Math.atan2(l,M),m._x=-Math.PI/2,m._z=0,m._isDirty=!0;else{const u=M*M,b=S*S,q=h*h,Y=l*l;m._z=Math.atan2(2*(h*l+S*M),-b-q+Y+u),m._x=Math.asin(-2*O),m._y=Math.atan2(2*(S*h+l*M),b-q-Y+u),m._isDirty=!0}return m}toAlphaBetaGammaToRef(m){const S=this._z,h=this._x,l=this._y,M=this._w,O=Math.sqrt(h*h+l*l),u=Math.sqrt(S*S+M*M),b=2*Math.atan2(O,u),q=2*Math.atan2(S,M),Y=2*Math.atan2(l,h),V=(q+Y)/2,I=(q-Y)/2;return m.set(I,b,V),m}toRotationMatrix(m){return L.FromQuaternionToRef(this,m),m}fromRotationMatrix(m){return n.FromRotationMatrixToRef(m,this),this}dot(m){return this._x*m._x+this._y*m._y+this._z*m._z+this._w*m._w}toAxisAngle(){const m=D.Zero();return{axis:m,angle:this.toAxisAngleToRef(m)}}toAxisAngleToRef(m){let S=0;const h=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),l=this._w;return h>0?(S=2*Math.atan2(h,l),m.set(this._x/h,this._y/h,this._z/h)):(S=0,m.set(1,0,0)),S}static FromRotationMatrix(m){const S=new n;return n.FromRotationMatrixToRef(m,S),S}static FromRotationMatrixToRef(m,S){const h=m.m,l=h[0],M=h[4],O=h[8],u=h[1],b=h[5],q=h[9],Y=h[2],V=h[6],I=h[10],Z=l+b+I;let C;return Z>0?(C=.5/Math.sqrt(Z+1),S._w=.25/C,S._x=(V-q)*C,S._y=(O-Y)*C,S._z=(u-M)*C,S._isDirty=!0):l>b&&l>I?(C=2*Math.sqrt(1+l-b-I),S._w=(V-q)/C,S._x=.25*C,S._y=(M+u)/C,S._z=(O+Y)/C,S._isDirty=!0):b>I?(C=2*Math.sqrt(1+b-l-I),S._w=(O-Y)/C,S._x=(M+u)/C,S._y=.25*C,S._z=(q+V)/C,S._isDirty=!0):(C=2*Math.sqrt(1+I-l-b),S._w=(u-M)/C,S._x=(O+Y)/C,S._y=(q+V)/C,S._z=.25*C,S._isDirty=!0),S}static Dot(m,S){return m._x*S._x+m._y*S._y+m._z*S._z+m._w*S._w}static AreClose(m,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const l=n.Dot(m,S);return 1-l*l<=h}static SmoothToRef(m,S,h,l,M){let O=0===l?1:h/l;return O=(0,q.Clamp)(O,0,1),n.SlerpToRef(m,S,O,M),M}static Zero(){return new n(0,0,0,0)}static Inverse(m){return new n(-m._x,-m._y,-m._z,m._w)}static InverseToRef(m,S){return S.set(-m._x,-m._y,-m._z,m._w),S}static Identity(){return new n(0,0,0,1)}static IsIdentity(m){return m&&0===m._x&&0===m._y&&0===m._z&&1===m._w}static RotationAxis(m,S){return n.RotationAxisToRef(m,S,new n)}static RotationAxisToRef(m,S,h){h._w=Math.cos(S/2);const l=Math.sin(S/2)/m.length();return h._x=m._x*l,h._y=m._y*l,h._z=m._z*l,h._isDirty=!0,h}static yS(m,S){return S||(S=0),new n(m[S],m[S+1],m[S+2],m[S+3])}static FromArrayToRef(m,S,h){return h._x=m[S],h._y=m[S+1],h._z=m[S+2],h._w=m[S+3],h._isDirty=!0,h}static FromFloatsToRef(m,S,h,l,M){return M.Yb(m,S,h,l),M}static FromEulerAngles(m,S,h){const l=new n;return n.RotationYawPitchRollToRef(S,m,h,l),l}static FromEulerAnglesToRef(m,S,h,l){return n.RotationYawPitchRollToRef(S,m,h,l),l}static FromEulerVector(m){const S=new n;return n.RotationYawPitchRollToRef(m._y,m._x,m._z,S),S}static FromEulerVectorToRef(m,S){return n.RotationYawPitchRollToRef(m._y,m._x,m._z,S),S}static FromUnitVectorsToRef(m,S,h){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:l.d;const O=D.Dot(m,S)+1;return O<M?Math.abs(m.x)>Math.abs(m.z)?h.set(-m.y,m.x,0,0):h.set(0,-m.z,m.y,0):(D.CrossToRef(m,S,H.nS[0]),h.set(H.nS[0].x,H.nS[0].y,H.nS[0].z,O)),h.normalize()}static RotationYawPitchRoll(m,S,h){const l=new n;return n.RotationYawPitchRollToRef(m,S,h,l),l}static RotationYawPitchRollToRef(m,S,h,l){const M=.5*h,O=.5*S,u=.5*m,b=Math.sin(M),q=Math.cos(M),Y=Math.sin(O),V=Math.cos(O),I=Math.sin(u),Z=Math.cos(u);return l._x=Z*Y*q+I*V*b,l._y=I*V*q-Z*Y*b,l._z=Z*V*b-I*Y*q,l._w=Z*V*q+I*Y*b,l._isDirty=!0,l}static RotationAlphaBetaGamma(m,S,h){const l=new n;return n.RotationAlphaBetaGammaToRef(m,S,h,l),l}static RotationAlphaBetaGammaToRef(m,S,h,l){const M=.5*(h+m),O=.5*(h-m),u=.5*S;return l._x=Math.cos(O)*Math.sin(u),l._y=Math.sin(O)*Math.sin(u),l._z=Math.sin(M)*Math.cos(u),l._w=Math.cos(M)*Math.cos(u),l._isDirty=!0,l}static RotationQuaternionFromAxis(m,S,h){const l=new n(0,0,0,0);return n.RotationQuaternionFromAxisToRef(m,S,h,l),l}static RotationQuaternionFromAxisToRef(m,S,h,l){const M=U.Matrix[0];return m=m.normalizeToRef(U.nS[0]),S=S.normalizeToRef(U.nS[1]),h=h.normalizeToRef(U.nS[2]),L.FromXYZAxesToRef(m,S,h,M),n.FromRotationMatrixToRef(M,l),l}static FromLookDirectionLH(m,S){const h=new n;return n.FromLookDirectionLHToRef(m,S,h),h}static FromLookDirectionLHToRef(m,S,h){const l=U.Matrix[0];return L.LookDirectionLHToRef(m,S,l),n.FromRotationMatrixToRef(l,h),h}static FromLookDirectionRH(m,S){const h=new n;return n.FromLookDirectionRHToRef(m,S,h),h}static FromLookDirectionRHToRef(m,S,h){const l=U.Matrix[0];return L.LookDirectionRHToRef(m,S,l),n.FromRotationMatrixToRef(l,h)}static Slerp(m,S,h){const l=n.Identity();return n.SlerpToRef(m,S,h,l),l}static SlerpToRef(m,S,h,l){let M,O,u=m._x*S._x+m._y*S._y+m._z*S._z+m._w*S._w,b=!1;if(u<0&&(b=!0,u=-u),u>.999999)O=1-h,M=b?-h:h;else{const m=Math.acos(u),S=1/Math.sin(m);O=Math.sin((1-h)*m)*S,M=b?-Math.sin(h*m)*S:Math.sin(h*m)*S}return l._x=O*m._x+M*S._x,l._y=O*m._y+M*S._y,l._z=O*m._z+M*S._z,l._w=O*m._w+M*S._w,l._isDirty=!0,l}static Hermite(m,S,h,l,M){const O=M*M,u=M*O,b=2*u-3*O+1,q=-2*u+3*O,Y=u-2*O+M,V=u-O,I=m._x*b+h._x*q+S._x*Y+l._x*V,Z=m._y*b+h._y*q+S._y*Y+l._y*V,C=m._z*b+h._z*q+S._z*Y+l._z*V,B=m._w*b+h._w*q+S._w*Y+l._w*V;return new n(I,Z,C,B)}static Hermite1stDerivative(m,S,h,l,M){const O=new n;return this.Hermite1stDerivativeToRef(m,S,h,l,M,O),O}static Hermite1stDerivativeToRef(m,S,h,l,M,O){const u=M*M;return O._x=6*(u-M)*m._x+(3*u-4*M+1)*S._x+6*(-u+M)*h._x+(3*u-2*M)*l._x,O._y=6*(u-M)*m._y+(3*u-4*M+1)*S._y+6*(-u+M)*h._y+(3*u-2*M)*l._y,O._z=6*(u-M)*m._z+(3*u-4*M+1)*S._z+6*(-u+M)*h._z+(3*u-2*M)*l._z,O._w=6*(u-M)*m._w+(3*u-4*M+1)*S._w+6*(-u+M)*h._w+(3*u-2*M)*l._w,O._isDirty=!0,O}static Normalize(m){const S=n.Zero();return n.NormalizeToRef(m,S),S}static NormalizeToRef(m,S){return m.normalizeToRef(S),S}static Clamp(m,S,h){const l=new n;return n.ClampToRef(m,S,h,l),l}static ClampToRef(m,S,h,l){return l.Yb((0,q.Clamp)(m.x,S.x,h.x),(0,q.Clamp)(m.y,S.y,h.y),(0,q.Clamp)(m.z,S.z,h.z),(0,q.Clamp)(m.w,S.w,h.w))}static Random(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new n((0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S))}static RandomToRef(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Yb((0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S),(0,q.RandomRange)(m,S))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(m,S){return Math.sqrt(n.DistanceSquared(m,S))}static DistanceSquared(m,S){const h=m.x-S.x,l=m.y-S.y,M=m.z-S.z,O=m.w-S.w;return h*h+l*l+M*M+O*O}static Center(m,S){return n.CenterToRef(m,S,n.Zero())}static CenterToRef(m,S,h){return h.Yb((m.x+S.x)/2,(m.y+S.y)/2,(m.z+S.z)/2,(m.w+S.w)/2)}}n._V8PerformanceHack=new n(.5,.5,.5,.5),Object.defineProperties(n.prototype,{dimension:{value:[4]},rank:{value:1}});class L{static get Use64Bits(){return u.d.MatrixUse64Bits}get m(){return this.ph}markAsUpdated(){this.updateFlag=Y._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(m){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],l=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=m,this._isIdentity3x2=m||h,this._isIdentityDirty=!this._isIdentity&&S,this._isIdentity3x2Dirty=!this._isIdentity3x2&&l}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,u.d.MatrixTrackPrecisionChange&&u.d.MatrixTrackedMatrices.push(this),this.ph=new u.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const m=this.ph;this._isIdentity=1===m[0]&&0===m[1]&&0===m[2]&&0===m[3]&&0===m[4]&&1===m[5]&&0===m[6]&&0===m[7]&&0===m[8]&&0===m[9]&&1===m[10]&&0===m[11]&&0===m[12]&&0===m[13]&&0===m[14]&&1===m[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ph[0]||1!==this.ph[5]||1!==this.ph[15]||0!==this.ph[1]||0!==this.ph[2]||0!==this.ph[3]||0!==this.ph[4]||0!==this.ph[6]||0!==this.ph[7]||0!==this.ph[8]||0!==this.ph[9]||0!==this.ph[10]||0!==this.ph[11]||0!==this.ph[12]||0!==this.ph[13]||0!==this.ph[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const m=this.ph,S=m[0],h=m[1],l=m[2],M=m[3],O=m[4],u=m[5],b=m[6],q=m[7],Y=m[8],V=m[9],I=m[10],Z=m[11],C=m[12],B=m[13],D=m[14],E=m[15],n=I*E-D*Z,L=V*E-B*Z,U=V*D-B*I,H=Y*E-C*Z,R=Y*D-I*C,y=Y*B-C*V;return S*+(u*n-b*L+q*U)+h*-(O*n-b*H+q*R)+l*+(O*L-u*H+q*y)+M*-(O*U-u*R+b*y)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!m)return this.ph;const h=this.ph;for(let l=0;l<16;l++)m[S+l]=h[l];return this}DM(){return this.ph}yh(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(m,S,this)}Yb(){for(var m=arguments.length,S=new Array(m),h=0;h<m;h++)S[h]=arguments[h];return L.FromArrayToRef(S,0,this)}set(){const m=this.ph;for(let S=0;S<16;S++)m[S]=S<0||arguments.length<=S?void 0:arguments[S];return this.markAsUpdated(),this}Zb(m){const S=this.ph;for(let h=0;h<16;h++)S[h]=m;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return L.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(m){const S=new L;return this.addToRef(m,S),S}addToRef(m,S){const h=this.ph,l=S.ph,M=m.m;for(let O=0;O<16;O++)l[O]=h[O]+M[O];return S.markAsUpdated(),S}addToSelf(m){const S=this.ph,h=m.m;return S[0]+=h[0],S[1]+=h[1],S[2]+=h[2],S[3]+=h[3],S[4]+=h[4],S[5]+=h[5],S[6]+=h[6],S[7]+=h[7],S[8]+=h[8],S[9]+=h[9],S[10]+=h[10],S[11]+=h[11],S[12]+=h[12],S[13]+=h[13],S[14]+=h[14],S[15]+=h[15],this.markAsUpdated(),this}addInPlace(m){const S=this.ph,h=m.m;for(let l=0;l<16;l++)S[l]+=h[l];return this.markAsUpdated(),this}addInPlaceFromFloats(){const m=this.ph;for(let S=0;S<16;S++)m[S]+=S<0||arguments.length<=S?void 0:arguments[S];return this.markAsUpdated(),this}LS(m){const S=this.ph,h=m.m;for(let l=0;l<16;l++)S[l]-=h[l];return this.markAsUpdated(),this}subtractToRef(m,S){const h=this.ph,l=m.m,M=S.ph;for(let O=0;O<16;O++)M[O]=h[O]-l[O];return S.markAsUpdated(),S}yI(m){const S=this.ph,h=m.m;for(let l=0;l<16;l++)S[l]-=h[l];return this.markAsUpdated(),this}subtractFromFloats(){for(var m=arguments.length,S=new Array(m),h=0;h<m;h++)S[h]=arguments[h];return this.subtractFromFloatsToRef(...S,new L)}subtractFromFloatsToRef(){for(var m=arguments.length,S=new Array(m),h=0;h<m;h++)S[h]=arguments[h];const l=S.pop(),M=this.ph,O=l.ph,u=S;for(let b=0;b<16;b++)O[b]=M[b]-u[b];return l.markAsUpdated(),l}invertToRef(m){return!0===this._isIdentity?(L.IdentityToRef(m),m):(Z(this,m.DM())?m.markAsUpdated():m.l(this),m)}addAtIndex(m,S){return this.ph[m]+=S,this.markAsUpdated(),this}multiplyAtIndex(m,S){return this.ph[m]*=S,this.markAsUpdated(),this}setTranslationFromFloats(m,S,h){return this.ph[12]=m,this.ph[13]=S,this.ph[14]=h,this.markAsUpdated(),this}addTranslationFromFloats(m,S,h){return this.ph[12]+=m,this.ph[13]+=S,this.ph[14]+=h,this.markAsUpdated(),this}setTranslation(m){return this.setTranslationFromFloats(m._x,m._y,m._z)}getTranslation(){return new D(this.ph[12],this.ph[13],this.ph[14])}getTranslationToRef(m){return m.x=this.ph[12],m.y=this.ph[13],m.z=this.ph[14],m}removeRotationAndScaling(){const m=this.m;return L.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,m[12],m[13],m[14],m[15],this),this._updateIdentityStatus(0===m[12]&&0===m[13]&&0===m[14]&&1===m[15]),this}l(m){m.copyToArray(this.ph);const S=m;return this.updateFlag=S.updateFlag,this._updateIdentityStatus(S._isIdentity,S._isIdentityDirty,S._isIdentity3x2,S._isIdentity3x2Dirty),this}copyToArray(m){return I(this,m,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(m){const S=new L;return this.multiplyToRef(m,S),S}multiplyInPlace(m){const S=this.ph,h=m.m;for(let l=0;l<16;l++)S[l]*=h[l];return this.markAsUpdated(),this}multiplyByFloats(){const m=this.ph;for(let S=0;S<16;S++)m[S]*=S<0||arguments.length<=S?void 0:arguments[S];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var m=arguments.length,S=new Array(m),h=0;h<m;h++)S[h]=arguments[h];const l=S.pop(),M=this.ph,O=l.ph,u=S;for(let b=0;b<16;b++)O[b]=M[b]*u[b];return l.markAsUpdated(),l}multiplyToRef(m,S){return this._isIdentity?(S.l(m),S):m._isIdentity?(S.l(this),S):(this.multiplyToArray(m,S.ph,0),S.markAsUpdated(),S)}multiplyToArray(m,S,h){return V(this,m,S,h),this}divide(m){return this.divideToRef(m,new L)}divideToRef(m,S){const h=this.ph,l=m.m,M=S.ph;for(let O=0;O<16;O++)M[O]=h[O]/l[O];return S.markAsUpdated(),S}divideInPlace(m){const S=this.ph,h=m.m;for(let l=0;l<16;l++)S[l]/=h[l];return this.markAsUpdated(),this}minimizeInPlace(m){const S=this.ph,h=m.m;for(let l=0;l<16;l++)S[l]=Math.min(S[l],h[l]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const m=this.ph;for(let S=0;S<16;S++)m[S]=Math.min(m[S],S<0||arguments.length<=S?void 0:arguments[S]);return this.markAsUpdated(),this}maximizeInPlace(m){const S=this.ph,h=m.m;for(let l=0;l<16;l++)S[l]=Math.min(S[l],h[l]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const m=this.ph;for(let S=0;S<16;S++)m[S]=Math.min(m[S],S<0||arguments.length<=S?void 0:arguments[S]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new L)}negateInPlace(){const m=this.ph;for(let S=0;S<16;S++)m[S]=-m[S];return this.markAsUpdated(),this}negateToRef(m){const S=this.ph,h=m.ph;for(let l=0;l<16;l++)h[l]=-S[l];return m.markAsUpdated(),m}equals(m){const S=m;if(!S)return!1;if((this._isIdentity||S._isIdentity)&&!this._isIdentityDirty&&!S._isIdentityDirty)return this._isIdentity&&S._isIdentity;const h=this.m,l=S.m;return h[0]===l[0]&&h[1]===l[1]&&h[2]===l[2]&&h[3]===l[3]&&h[4]===l[4]&&h[5]===l[5]&&h[6]===l[6]&&h[7]===l[7]&&h[8]===l[8]&&h[9]===l[9]&&h[10]===l[10]&&h[11]===l[11]&&h[12]===l[12]&&h[13]===l[13]&&h[14]===l[14]&&h[15]===l[15]}equalsWithEpsilon(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=this.ph,l=m.m;for(let M=0;M<16;M++)if(!(0,q.WithinEpsilon)(h[M],l[M],S))return!1;return!0}equalsToFloats(){const m=this.ph;for(let S=0;S<16;S++)if(m[S]!=(S<0||arguments.length<=S?void 0:arguments[S]))return!1;return!0}floor(){return this.floorToRef(new L)}floorToRef(m){const S=this.ph,h=m.ph;for(let l=0;l<16;l++)h[l]=Math.floor(S[l]);return m.markAsUpdated(),m}fract(){return this.fractToRef(new L)}fractToRef(m){const S=this.ph,h=m.ph;for(let l=0;l<16;l++)h[l]=S[l]-Math.floor(S[l]);return m.markAsUpdated(),m}clone(){const m=new L;return m.l(this),m}getClassName(){return"Matrix"}getHashCode(){let m=C(this.ph[0]);for(let S=1;S<16;S++)m=397*m^C(this.ph[S]);return m}decomposeToTransformNode(m){return m.rotationQuaternion=m.rotationQuaternion||new n,this.decompose(m.Ib,m.rotationQuaternion,m.position)}decompose(m,S,h,l){let M=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return h&&h.Zb(0),m&&m.Zb(1),S&&S.Yb(0,0,0,1),!0;const O=this.ph;if(h&&h.Yb(O[12],O[13],O[14]),(m=m||U.nS[0]).x=Math.sqrt(O[0]*O[0]+O[1]*O[1]+O[2]*O[2]),m.y=Math.sqrt(O[4]*O[4]+O[5]*O[5]+O[6]*O[6]),m.z=Math.sqrt(O[8]*O[8]+O[9]*O[9]+O[10]*O[10]),l){const S=(M?l.absoluteScaling.x:l.Ib.x)<0?-1:1,h=(M?l.absoluteScaling.y:l.Ib.y)<0?-1:1,O=(M?l.absoluteScaling.z:l.Ib.z)<0?-1:1;m.x*=S,m.y*=h,m.z*=O}else this.determinant()<=0&&(m.y*=-1);if(0===m._x||0===m._y||0===m._z)return S&&S.Yb(0,0,0,1),!1;if(S){const h=1/m._x,l=1/m._y,M=1/m._z;L.FromValuesToRef(O[0]*h,O[1]*h,O[2]*h,0,O[4]*l,O[5]*l,O[6]*l,0,O[8]*M,O[9]*M,O[10]*M,0,0,0,0,1,U.Matrix[0]),n.FromRotationMatrixToRef(U.Matrix[0],S)}return!0}getRow(m){if(m<0||m>3)return null;const S=4*m;return new E(this.ph[S+0],this.ph[S+1],this.ph[S+2],this.ph[S+3])}getRowToRef(m,S){if(m>=0&&m<=3){const h=4*m;S.x=this.ph[h+0],S.y=this.ph[h+1],S.z=this.ph[h+2],S.w=this.ph[h+3]}return S}setRow(m,S){return this.setRowFromFloats(m,S.x,S.y,S.z,S.w)}transpose(){const m=new L;return L.TransposeToRef(this,m),m}transposeToRef(m){return L.TransposeToRef(this,m),m}setRowFromFloats(m,S,h,l,M){if(m<0||m>3)return this;const O=4*m;return this.ph[O+0]=S,this.ph[O+1]=h,this.ph[O+2]=l,this.ph[O+3]=M,this.markAsUpdated(),this}scale(m){const S=new L;return this.scaleToRef(m,S),S}scaleToRef(m,S){for(let h=0;h<16;h++)S.ph[h]=this.ph[h]*m;return S.markAsUpdated(),S}scaleAndAddToRef(m,S){for(let h=0;h<16;h++)S.ph[h]+=this.ph[h]*m;return S.markAsUpdated(),S}scaleInPlace(m){const S=this.ph;for(let h=0;h<16;h++)S[h]*=m;return this.markAsUpdated(),this}toNormalMatrix(m){const S=U.Matrix[0];this.invertToRef(S),S.transposeToRef(m);const h=m.ph;return L.FromValuesToRef(h[0],h[1],h[2],0,h[4],h[5],h[6],0,h[8],h[9],h[10],0,0,0,0,1,m),m}getRotationMatrix(){const m=new L;return this.getRotationMatrixToRef(m),m}getRotationMatrixToRef(m){const S=U.nS[0];if(!this.decompose(S))return L.IdentityToRef(m),m;const h=this.ph,l=1/S._x,M=1/S._y,O=1/S._z;return L.FromValuesToRef(h[0]*l,h[1]*l,h[2]*l,0,h[4]*M,h[5]*M,h[6]*M,0,h[8]*O,h[9]*O,h[10]*O,0,0,0,0,1,m),m}toggleModelMatrixHandInPlace(){const m=this.ph;return m[2]*=-1,m[6]*=-1,m[8]*=-1,m[9]*=-1,m[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const m=this.ph;return m[8]*=-1,m[9]*=-1,m[10]*=-1,m[11]*=-1,this.markAsUpdated(),this}static yS(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=new L;return L.FromArrayToRef(m,S,h),h}static FromArrayToRef(m,S,h){for(let l=0;l<16;l++)h.ph[l]=m[l+S];return h.markAsUpdated(),h}static FromFloat32ArrayToRefScaled(m,S,h,l){return l.ph[0]=m[0+S]*h,l.ph[1]=m[1+S]*h,l.ph[2]=m[2+S]*h,l.ph[3]=m[3+S]*h,l.ph[4]=m[4+S]*h,l.ph[5]=m[5+S]*h,l.ph[6]=m[6+S]*h,l.ph[7]=m[7+S]*h,l.ph[8]=m[8+S]*h,l.ph[9]=m[9+S]*h,l.ph[10]=m[10+S]*h,l.ph[11]=m[11+S]*h,l.ph[12]=m[12+S]*h,l.ph[13]=m[13+S]*h,l.ph[14]=m[14+S]*h,l.ph[15]=m[15+S]*h,l.markAsUpdated(),l}static get IdentityReadOnly(){return L._IdentityReadOnly}static FromValuesToRef(m,S,h,l,M,O,u,b,q,Y,V,I,Z,C,B,D,E){const n=E.ph;n[0]=m,n[1]=S,n[2]=h,n[3]=l,n[4]=M,n[5]=O,n[6]=u,n[7]=b,n[8]=q,n[9]=Y,n[10]=V,n[11]=I,n[12]=Z,n[13]=C,n[14]=B,n[15]=D,E.markAsUpdated()}static FromValues(m,S,h,l,M,O,u,b,q,Y,V,I,Z,C,B,D){const E=new L,n=E.ph;return n[0]=m,n[1]=S,n[2]=h,n[3]=l,n[4]=M,n[5]=O,n[6]=u,n[7]=b,n[8]=q,n[9]=Y,n[10]=V,n[11]=I,n[12]=Z,n[13]=C,n[14]=B,n[15]=D,E.markAsUpdated(),E}static Compose(m,S,h){const l=new L;return L.ComposeToRef(m,S,h,l),l}static ComposeToRef(m,S,h,l){const M=l.ph,O=S._x,u=S._y,b=S._z,q=S._w,Y=O+O,V=u+u,I=b+b,Z=O*Y,C=O*V,B=O*I,D=u*V,E=u*I,n=b*I,L=q*Y,U=q*V,H=q*I,R=m._x,y=m._y,o=m._z;return M[0]=(1-(D+n))*R,M[1]=(C+H)*R,M[2]=(B-U)*R,M[3]=0,M[4]=(C-H)*y,M[5]=(1-(Z+n))*y,M[6]=(E+L)*y,M[7]=0,M[8]=(B+U)*o,M[9]=(E-L)*o,M[10]=(1-(Z+D))*o,M[11]=0,M[12]=h._x,M[13]=h._y,M[14]=h._z,M[15]=1,l.markAsUpdated(),l}static Identity(){const m=L.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return m._updateIdentityStatus(!0),m}static IdentityToRef(m){return L.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,m),m._updateIdentityStatus(!0),m}static Zero(){const m=L.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return m._updateIdentityStatus(!1),m}static RotationX(m){const S=new L;return L.RotationXToRef(m,S),S}static Invert(m){const S=new L;return m.invertToRef(S),S}static RotationXToRef(m,S){const h=Math.sin(m),l=Math.cos(m);return L.FromValuesToRef(1,0,0,0,0,l,h,0,0,-h,l,0,0,0,0,1,S),S._updateIdentityStatus(1===l&&0===h),S}static RotationY(m){const S=new L;return L.RotationYToRef(m,S),S}static RotationYToRef(m,S){const h=Math.sin(m),l=Math.cos(m);return L.FromValuesToRef(l,0,-h,0,0,1,0,0,h,0,l,0,0,0,0,1,S),S._updateIdentityStatus(1===l&&0===h),S}static RotationZ(m){const S=new L;return L.RotationZToRef(m,S),S}static RotationZToRef(m,S){const h=Math.sin(m),l=Math.cos(m);return L.FromValuesToRef(l,h,0,0,-h,l,0,0,0,0,1,0,0,0,0,1,S),S._updateIdentityStatus(1===l&&0===h),S}static RotationAxis(m,S){const h=new L;return L.RotationAxisToRef(m,S,h),h}static RotationAxisToRef(m,S,h){const l=Math.sin(-S),M=Math.cos(-S),O=1-M;m=m.normalizeToRef(U.nS[0]);const u=h.ph;return u[0]=m._x*m._x*O+M,u[1]=m._x*m._y*O-m._z*l,u[2]=m._x*m._z*O+m._y*l,u[3]=0,u[4]=m._y*m._x*O+m._z*l,u[5]=m._y*m._y*O+M,u[6]=m._y*m._z*O-m._x*l,u[7]=0,u[8]=m._z*m._x*O-m._y*l,u[9]=m._z*m._y*O+m._x*l,u[10]=m._z*m._z*O+M,u[11]=0,u[12]=0,u[13]=0,u[14]=0,u[15]=1,h.markAsUpdated(),h}static RotationAlignToRef(m,S,h){let M=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const O=D.Dot(S,m),u=h.ph;if(O<-1+l.d)u[0]=-1,u[1]=0,u[2]=0,u[3]=0,u[4]=0,u[5]=M?1:-1,u[6]=0,u[7]=0,u[8]=0,u[9]=0,u[10]=M?-1:1,u[11]=0;else{const h=D.Cross(S,m),l=1/(1+O);u[0]=h._x*h._x*l+O,u[1]=h._y*h._x*l-h._z,u[2]=h._z*h._x*l+h._y,u[3]=0,u[4]=h._x*h._y*l+h._z,u[5]=h._y*h._y*l+O,u[6]=h._z*h._y*l-h._x,u[7]=0,u[8]=h._x*h._z*l-h._y,u[9]=h._y*h._z*l+h._x,u[10]=h._z*h._z*l+O,u[11]=0}return u[12]=0,u[13]=0,u[14]=0,u[15]=1,h.markAsUpdated(),h}static RotationYawPitchRoll(m,S,h){const l=new L;return L.RotationYawPitchRollToRef(m,S,h,l),l}static RotationYawPitchRollToRef(m,S,h,l){return n.RotationYawPitchRollToRef(m,S,h,U.Quaternion[0]),U.Quaternion[0].toRotationMatrix(l),l}static Scaling(m,S,h){const l=new L;return L.ScalingToRef(m,S,h,l),l}static ScalingToRef(m,S,h,l){return L.FromValuesToRef(m,0,0,0,0,S,0,0,0,0,h,0,0,0,0,1,l),l._updateIdentityStatus(1===m&&1===S&&1===h),l}static Translation(m,S,h){const l=new L;return L.TranslationToRef(m,S,h,l),l}static TranslationToRef(m,S,h,l){return L.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,m,S,h,1,l),l._updateIdentityStatus(0===m&&0===S&&0===h),l}static Lerp(m,S,h){const l=new L;return L.LerpToRef(m,S,h,l),l}static LerpToRef(m,S,h,l){const M=l.ph,O=m.m,u=S.m;for(let b=0;b<16;b++)M[b]=O[b]*(1-h)+u[b]*h;return l.markAsUpdated(),l}static DecomposeLerp(m,S,h){const l=new L;return L.DecomposeLerpToRef(m,S,h,l),l}static DecomposeLerpToRef(m,S,h,l){const M=U.nS[0],O=U.Quaternion[0],u=U.nS[1];m.decompose(M,O,u);const b=U.nS[2],q=U.Quaternion[1],Y=U.nS[3];S.decompose(b,q,Y);const V=U.nS[4];D.LerpToRef(M,b,h,V);const I=U.Quaternion[2];n.SlerpToRef(O,q,h,I);const Z=U.nS[5];return D.LerpToRef(u,Y,h,Z),L.ComposeToRef(V,I,Z,l),l}static LookAtLH(m,S,h){const l=new L;return L.LookAtLHToRef(m,S,h,l),l}static LookAtLHToRef(m,S,h,l){const M=U.nS[0],O=U.nS[1],u=U.nS[2];S.subtractToRef(m,u),u.normalize(),D.CrossToRef(h,u,M);const b=M.lengthSquared();0===b?M.x=1:M.normalizeFromLength(Math.sqrt(b)),D.CrossToRef(u,M,O),O.normalize();const q=-D.Dot(M,m),Y=-D.Dot(O,m),V=-D.Dot(u,m);return L.FromValuesToRef(M._x,O._x,u._x,0,M._y,O._y,u._y,0,M._z,O._z,u._z,0,q,Y,V,1,l),l}static LookAtRH(m,S,h){const l=new L;return L.LookAtRHToRef(m,S,h,l),l}static LookAtRHToRef(m,S,h,l){const M=U.nS[0],O=U.nS[1],u=U.nS[2];m.subtractToRef(S,u),u.normalize(),D.CrossToRef(h,u,M);const b=M.lengthSquared();0===b?M.x=1:M.normalizeFromLength(Math.sqrt(b)),D.CrossToRef(u,M,O),O.normalize();const q=-D.Dot(M,m),Y=-D.Dot(O,m),V=-D.Dot(u,m);return L.FromValuesToRef(M._x,O._x,u._x,0,M._y,O._y,u._y,0,M._z,O._z,u._z,0,q,Y,V,1,l),l}static LookDirectionLH(m,S){const h=new L;return L.LookDirectionLHToRef(m,S,h),h}static LookDirectionLHToRef(m,S,h){const l=U.nS[0];l.l(m),l.scaleInPlace(-1);const M=U.nS[1];return D.CrossToRef(S,l,M),L.FromValuesToRef(M._x,M._y,M._z,0,S._x,S._y,S._z,0,l._x,l._y,l._z,0,0,0,0,1,h),h}static LookDirectionRH(m,S){const h=new L;return L.LookDirectionRHToRef(m,S,h),h}static LookDirectionRHToRef(m,S,h){const l=U.nS[2];return D.CrossToRef(S,m,l),L.FromValuesToRef(l._x,l._y,l._z,0,S._x,S._y,S._z,0,m._x,m._y,m._z,0,0,0,0,1,h),h}static OrthoLH(m,S,h,l,M){const O=new L;return L.OrthoLHToRef(m,S,h,l,O,M),O}static OrthoLHToRef(m,S,h,l,M,O){const u=2/m,b=2/S,q=2/(l-h),Y=-(l+h)/(l-h);return L.FromValuesToRef(u,0,0,0,0,b,0,0,0,0,q,0,0,0,Y,1,M),O&&M.multiplyToRef(R,M),M._updateIdentityStatus(1===u&&1===b&&1===q&&0===Y),M}static OrthoOffCenterLH(m,S,h,l,M,O,u){const b=new L;return L.OrthoOffCenterLHToRef(m,S,h,l,M,O,b,u),b}static OrthoOffCenterLHToRef(m,S,h,l,M,O,u,b){const q=2/(S-m),Y=2/(l-h),V=2/(O-M),I=-(O+M)/(O-M),Z=(m+S)/(m-S),C=(l+h)/(h-l);return L.FromValuesToRef(q,0,0,0,0,Y,0,0,0,0,V,0,Z,C,I,1,u),b&&u.multiplyToRef(R,u),u.markAsUpdated(),u}static ObliqueOffCenterLHToRef(m,S,h,l,M,O,u,b,q,Y,V){const I=-u*Math.cos(b),Z=-u*Math.sin(b);return L.TranslationToRef(0,0,-q,U.Matrix[1]),L.FromValuesToRef(1,0,0,0,0,1,0,0,I,Z,1,0,0,0,0,1,U.Matrix[0]),U.Matrix[1].multiplyToRef(U.Matrix[0],U.Matrix[0]),L.TranslationToRef(0,0,q,U.Matrix[1]),U.Matrix[0].multiplyToRef(U.Matrix[1],U.Matrix[0]),L.OrthoOffCenterLHToRef(m,S,h,l,M,O,Y,V),U.Matrix[0].multiplyToRef(Y,Y),Y}static OrthoOffCenterRH(m,S,h,l,M,O,u){const b=new L;return L.OrthoOffCenterRHToRef(m,S,h,l,M,O,b,u),b}static OrthoOffCenterRHToRef(m,S,h,l,M,O,u,b){return L.OrthoOffCenterLHToRef(m,S,h,l,M,O,u,b),u.ph[10]*=-1,u}static ObliqueOffCenterRHToRef(m,S,h,l,M,O,u,b,q,Y,V){const I=u*Math.cos(b),Z=u*Math.sin(b);return L.TranslationToRef(0,0,q,U.Matrix[1]),L.FromValuesToRef(1,0,0,0,0,1,0,0,I,Z,1,0,0,0,0,1,U.Matrix[0]),U.Matrix[1].multiplyToRef(U.Matrix[0],U.Matrix[0]),L.TranslationToRef(0,0,-q,U.Matrix[1]),U.Matrix[0].multiplyToRef(U.Matrix[1],U.Matrix[0]),L.OrthoOffCenterRHToRef(m,S,h,l,M,O,Y,V),U.Matrix[0].multiplyToRef(Y,Y),Y}static PerspectiveLH(m,S,h,l,M){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const u=new L,b=2*h/m,q=2*h/S,Y=(l+h)/(l-h),V=-2*l*h/(l-h),I=Math.tan(O);return L.FromValuesToRef(b,0,0,0,0,q,0,I,0,0,Y,1,0,0,V,0,u),M&&u.multiplyToRef(R,u),u._updateIdentityStatus(!1),u}static PerspectiveFovLH(m,S,h,l,M){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,u=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const b=new L;return L.PerspectiveFovLHToRef(m,S,h,l,b,!0,M,O,u),b}static PerspectiveFovLHToRef(m,S,h,l,M){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,b=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,q=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const Y=h,V=l,I=1/Math.tan(.5*m),Z=O?I/S:I,C=O?I:I*S,B=q&&0===Y?-1:0!==V?(V+Y)/(V-Y):1,D=q&&0===Y?2*V:0!==V?-2*V*Y/(V-Y):-2*Y,E=Math.tan(b);return L.FromValuesToRef(Z,0,0,0,0,C,0,E,0,0,B,1,0,0,D,0,M),u&&M.multiplyToRef(R,M),M._updateIdentityStatus(!1),M}static PerspectiveFovReverseLHToRef(m,S,h,l,M){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,b=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const q=1/Math.tan(.5*m),Y=O?q/S:q,V=O?q:q*S,I=Math.tan(b);return L.FromValuesToRef(Y,0,0,0,0,V,0,I,0,0,-h,1,0,0,1,0,M),u&&M.multiplyToRef(R,M),M._updateIdentityStatus(!1),M}static PerspectiveFovRH(m,S,h,l,M){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,u=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const b=new L;return L.PerspectiveFovRHToRef(m,S,h,l,b,!0,M,O,u),b}static PerspectiveFovRHToRef(m,S,h,l,M){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,b=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,q=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const Y=h,V=l,I=1/Math.tan(.5*m),Z=O?I/S:I,C=O?I:I*S,B=q&&0===Y?1:0!==V?-(V+Y)/(V-Y):-1,D=q&&0===Y?2*V:0!==V?-2*V*Y/(V-Y):-2*Y,E=Math.tan(b);return L.FromValuesToRef(Z,0,0,0,0,C,0,E,0,0,B,-1,0,0,D,0,M),u&&M.multiplyToRef(R,M),M._updateIdentityStatus(!1),M}static PerspectiveFovReverseRHToRef(m,S,h,l,M){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,b=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const q=1/Math.tan(.5*m),Y=O?q/S:q,V=O?q:q*S,I=Math.tan(b);return L.FromValuesToRef(Y,0,0,0,0,V,0,I,0,0,-h,-1,0,0,-1,0,M),u&&M.multiplyToRef(R,M),M._updateIdentityStatus(!1),M}static GetFinalMatrix(m,S,h,l,M,O){const u=m.width,b=m.height,q=m.x,Y=m.y,V=L.FromValues(u/2,0,0,0,0,-b/2,0,0,0,0,O-M,0,q+u/2,b/2+Y,M,1),I=new L;return S.multiplyToRef(h,I),I.multiplyToRef(l,I),I.multiplyToRef(V,I)}static GetAsMatrix2x2(m){const S=m.m,h=[S[0],S[1],S[4],S[5]];return u.d.MatrixUse64Bits?h:new Float32Array(h)}static GetAsMatrix3x3(m){const S=m.m,h=[S[0],S[1],S[2],S[4],S[5],S[6],S[8],S[9],S[10]];return u.d.MatrixUse64Bits?h:new Float32Array(h)}static Transpose(m){const S=new L;return L.TransposeToRef(m,S),S}static TransposeToRef(m,S){const h=m.m,l=h[0],M=h[4],O=h[8],u=h[12],b=h[1],q=h[5],Y=h[9],V=h[13],I=h[2],Z=h[6],C=h[10],B=h[14],D=h[3],E=h[7],n=h[11],L=h[15],U=S.ph;return U[0]=l,U[1]=M,U[2]=O,U[3]=u,U[4]=b,U[5]=q,U[6]=Y,U[7]=V,U[8]=I,U[9]=Z,U[10]=C,U[11]=B,U[12]=D,U[13]=E,U[14]=n,U[15]=L,S.markAsUpdated(),S._updateIdentityStatus(m._isIdentity,m._isIdentityDirty),S}static Reflection(m){const S=new L;return L.ReflectionToRef(m,S),S}static ReflectionToRef(m,S){m.normalize();const h=m.normal.x,l=m.normal.y,M=m.normal.z,O=-2*h,u=-2*l,b=-2*M;return L.FromValuesToRef(O*h+1,u*h,b*h,0,O*l,u*l+1,b*l,0,O*M,u*M,b*M+1,0,O*m.d,u*m.d,b*m.d,1,S),S}static FromXYZAxesToRef(m,S,h,l){return L.FromValuesToRef(m._x,m._y,m._z,0,S._x,S._y,S._z,0,h._x,h._y,h._z,0,0,0,0,1,l),l}static FromQuaternionToRef(m,S){const h=m._x*m._x,l=m._y*m._y,M=m._z*m._z,O=m._x*m._y,u=m._z*m._w,b=m._z*m._x,q=m._y*m._w,Y=m._y*m._z,V=m._x*m._w;return S.ph[0]=1-2*(l+M),S.ph[1]=2*(O+u),S.ph[2]=2*(b-q),S.ph[3]=0,S.ph[4]=2*(O-u),S.ph[5]=1-2*(M+h),S.ph[6]=2*(Y+V),S.ph[7]=0,S.ph[8]=2*(b+q),S.ph[9]=2*(Y-V),S.ph[10]=1-2*(l+h),S.ph[11]=0,S.ph[12]=0,S.ph[13]=0,S.ph[14]=0,S.ph[15]=1,S.markAsUpdated(),S}}L._IdentityReadOnly=L.Identity(),Object.defineProperties(L.prototype,{dimension:{value:[4,4]},rank:{value:2}});class U{}U.nS=(0,M.g)(11,D.Zero),U.Matrix=(0,M.g)(2,L.Identity),U.Quaternion=(0,M.g)(3,n.Zero);class H{}H.Vector2=(0,M.g)(3,B.Zero),H.nS=(0,M.g)(13,D.Zero),H.Vector4=(0,M.g)(3,E.Zero),H.Quaternion=(0,M.g)(3,n.Zero),H.Matrix=(0,M.g)(8,L.Identity),(0,O.e)("BABYLON.Vector2",B),(0,O.e)("BABYLON.Vector3",D),(0,O.e)("BABYLON.Vector4",E),(0,O.e)("BABYLON.Matrix",L);const R=L.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11356:(m,S,h)=>{function l(m,S){const h=[];for(let l=0;l<m;++l)h.push(S());return h}function M(m,S){return l(m,S)}h.d(S,{e:()=>l,g:()=>M,j:()=>u});const O=["push","splice","pop","shift","unshift"];function u(m,S){const h=O.map((h=>function(m,S,h){const l=m[S];if("function"!==typeof l)return null;const M=function(){const l=m.length,O=M.previous.apply(m,arguments);return h(S,l),O};return l.next=M,M.previous=l,m[S]=M,()=>{const h=M.previous;if(!h)return;const l=M.next;l?(h.next=l,l.previous=h):(h.next=void 0,m[S]=h),M.next=void 0,M.previous=void 0}}(m,h,S)));return()=>{for(const m of h)null===m||void 0===m||m()}}}}]);