"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{11197:(B,I,C)=>{C.d(I,{d:()=>f,e:()=>y,f:()=>M,i:()=>x});const M=1/2.2,x=2.2,y=(1+Math.sqrt(5))/2,f=.001},11212:(B,I,C)=>{function M(B){return parseInt(B.toString().replace(/\W/g,""))}function x(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(B-I)<=C}function y(B,I,C){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return B<I-M||B>C+M}function f(B,I){return B===I?B:Math.random()*(I-B)+B}function L(B,I,C){return B+(I-B)*C}function e(B,I,C){let M=S(I-B,360);return M>180&&(M-=360),B+M*H(C)}function g(B,I,C){let M=0;return M=B!=I?H((C-B)/(I-B)):0,M}function N(B,I,C,M,x){const y=x*x,f=x*y;return B*(2*f-3*y+1)+C*(-2*f+3*y)+I*(f-2*y+x)+M*(f-y)}function R(B,I,C,M,x){const y=x*x;return 6*(y-x)*B+(3*y-4*x+1)*I+6*(-y+x)*C+(3*y-2*x)*M}function H(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(I,B))}function F(B){return B-=2*Math.PI*Math.floor((B+Math.PI)/(2*Math.PI))}function k(B){const I=B.toString(16);return B<=15?("0"+I).toUpperCase():I.toUpperCase()}function q(B){if(Math.log2)return Math.floor(Math.log2(B));if(B<0)return NaN;if(0===B)return-1/0;let I=0;if(B<1){for(;B<1;)I++,B*=2;I=-I}else if(B>1)for(;B>1;)I++,B=Math.floor(B/2);return I}function S(B,I){return B-Math.floor(B/I)*I}function o(B,I,C){return(B-I)/(C-I)}function U(B,I,C){return B*(C-I)+I}function G(B,I){let C=S(I-B,360);return C>180&&(C-=360),C}function V(B,I){const C=S(B,2*I);return I-Math.abs(C-I)}function c(B,I,C){let M=H(C);return M=-2*M*M*M+3*M*M,I*M+B*(1-M)}function t(B,I,C){let M=0;return M=Math.abs(I-B)<=C?I:B+Math.sign(I-B)*C,M}function r(B,I,C){const M=G(B,I);let x=0;return x=-C<M&&M<C?I:t(B,I=B+M,C),x}function A(B,I,C){return(B-I)/(C-I)}function D(B,I,C){return(C-I)*B+I}function J(B,I){const C=B%I;return 0===C?I:J(I,C)}C.r(I),C.d(I,{Clamp:()=>H,DeltaAngle:()=>G,Denormalize:()=>U,ExtractAsInt:()=>M,Hermite:()=>N,Hermite1stDerivative:()=>R,HighestCommonFactor:()=>J,ILog2:()=>q,InverseLerp:()=>g,Lerp:()=>L,LerpAngle:()=>e,MoveTowards:()=>t,MoveTowardsAngle:()=>r,Normalize:()=>o,NormalizeRadians:()=>F,OutsideRange:()=>y,PercentToRange:()=>D,PingPong:()=>V,RandomRange:()=>f,RangeToPercent:()=>A,Repeat:()=>S,SmoothStep:()=>c,ToHex:()=>k,WithinEpsilon:()=>x})},11194:(B,I,C)=>{C.r(I),C.d(I,{Matrix:()=>U,Quaternion:()=>o,TmpVectors:()=>V,Vector2:()=>k,HI:()=>q,Vector4:()=>S});var M=C(11197),x=C(11204),y=C(11149),f=C(11126),L=C(11056),e=C(11212);class g{}function N(B,I,C){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const x=B.Df(),y=I.Df(),f=x[0],L=x[1],e=x[2],g=x[3],N=x[4],R=x[5],H=x[6],F=x[7],k=x[8],q=x[9],S=x[10],o=x[11],U=x[12],G=x[13],V=x[14],c=x[15],t=y[0],r=y[1],A=y[2],D=y[3],J=y[4],i=y[5],u=y[6],p=y[7],n=y[8],O=y[9],a=y[10],W=y[11],d=y[12],l=y[13],E=y[14],Q=y[15];C[M]=f*t+L*J+e*n+g*d,C[M+1]=f*r+L*i+e*O+g*l,C[M+2]=f*A+L*u+e*a+g*E,C[M+3]=f*D+L*p+e*W+g*Q,C[M+4]=N*t+R*J+H*n+F*d,C[M+5]=N*r+R*i+H*O+F*l,C[M+6]=N*A+R*u+H*a+F*E,C[M+7]=N*D+R*p+H*W+F*Q,C[M+8]=k*t+q*J+S*n+o*d,C[M+9]=k*r+q*i+S*O+o*l,C[M+10]=k*A+q*u+S*a+o*E,C[M+11]=k*D+q*p+S*W+o*Q,C[M+12]=U*t+G*J+V*n+c*d,C[M+13]=U*r+G*i+V*O+c*l,C[M+14]=U*A+G*u+V*a+c*E,C[M+15]=U*D+G*p+V*W+c*Q}function R(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const M=B.Df();I[C]=M[0],I[C+1]=M[1],I[C+2]=M[2],I[C+3]=M[3],I[C+4]=M[4],I[C+5]=M[5],I[C+6]=M[6],I[C+7]=M[7],I[C+8]=M[8],I[C+9]=M[9],I[C+10]=M[10],I[C+11]=M[11],I[C+12]=M[12],I[C+13]=M[13],I[C+14]=M[14],I[C+15]=M[15]}function H(B,I){const C=B.Df(),M=C[0],x=C[1],y=C[2],f=C[3],L=C[4],e=C[5],g=C[6],N=C[7],R=C[8],H=C[9],F=C[10],k=C[11],q=C[12],S=C[13],o=C[14],U=C[15],G=F*U-o*k,V=H*U-S*k,c=H*o-S*F,t=R*U-q*k,r=R*o-F*q,A=R*S-q*H,D=+(e*G-g*V+N*c),J=-(L*G-g*t+N*r),i=+(L*V-e*t+N*A),u=-(L*c-e*r+g*A),p=M*D+x*J+y*i+f*u;if(0===p)return!1;const n=1/p,O=g*U-o*N,a=e*U-S*N,W=e*o-S*g,d=L*U-q*N,l=L*o-q*g,E=L*S-q*e,Q=g*k-F*N,Z=e*k-H*N,z=e*F-H*g,b=L*k-R*N,Y=L*F-R*g,v=L*H-R*e,s=-(x*G-y*V+f*c),X=+(M*G-y*t+f*r),T=-(M*V-x*t+f*A),P=+(M*c-x*r+y*A),h=+(x*O-y*a+f*W),j=-(M*O-y*d+f*l),w=+(M*a-x*d+f*E),K=-(M*W-x*l+y*E),m=-(x*Q-y*Z+f*z),BB=+(M*Q-y*b+f*Y),IB=-(M*Z-x*b+f*v),CB=+(M*z-x*Y+y*v);return I[0]=D*n,I[1]=s*n,I[2]=h*n,I[3]=m*n,I[4]=J*n,I[5]=X*n,I[6]=j*n,I[7]=BB*n,I[8]=i*n,I[9]=T*n,I[10]=w*n,I[11]=IB*n,I[12]=u*n,I[13]=P*n,I[14]=K*n,I[15]=CB*n,!0}g._UpdateFlagSeed=0;const F=B=>parseInt(B.toString().replace(/\W/g,""));class k{constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=B,this.y=I}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let B=F(this.x);return B=397*B^F(this.y),B}toArray(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[I]=this.x,B[I+1]=this.y,this}RC(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k.FromArrayToRef(B,I,this),this}Df(){return[this.x,this.y]}M(B){return this.x=B.x,this.y=B.y,this}vf(B,I){return this.x=B,this.y=I,this}set(B,I){return this.vf(B,I)}Tf(B){return this.vf(B,B)}add(B){return new k(this.x+B.x,this.y+B.y)}addToRef(B,I){return I.x=this.x+B.x,I.y=this.y+B.y,I}addInPlace(B){return this.x+=B.x,this.y+=B.y,this}addInPlaceFromFloats(B,I){return this.x+=B,this.y+=I,this}addVector3(B){return new k(this.x+B.x,this.y+B.y)}FI(B){return new k(this.x-B.x,this.y-B.y)}subtractToRef(B,I){return I.x=this.x-B.x,I.y=this.y-B.y,I}cR(B){return this.x-=B.x,this.y-=B.y,this}multiplyInPlace(B){return this.x*=B.x,this.y*=B.y,this}multiply(B){return new k(this.x*B.x,this.y*B.y)}multiplyToRef(B,I){return I.x=this.x*B.x,I.y=this.y*B.y,I}multiplyByFloats(B,I){return new k(this.x*B,this.y*I)}divide(B){return new k(this.x/B.x,this.y/B.y)}divideToRef(B,I){return I.x=this.x/B.x,I.y=this.y/B.y,I}divideInPlace(B){return this.x=this.x/B.x,this.y=this.y/B.y,this}minimizeInPlace(B){return this.minimizeInPlaceFromFloats(B.x,B.y)}maximizeInPlace(B){return this.maximizeInPlaceFromFloats(B.x,B.y)}minimizeInPlaceFromFloats(B,I){return this.x=Math.min(B,this.x),this.y=Math.min(I,this.y),this}maximizeInPlaceFromFloats(B,I){return this.x=Math.max(B,this.x),this.y=Math.max(I,this.y),this}subtractFromFloats(B,I){return new k(this.x-B,this.y-I)}subtractFromFloatsToRef(B,I,C){return C.x=this.x-B,C.y=this.y-I,C}negate(){return new k(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(B){return B.x=-this.x,B.y=-this.y,B}scaleInPlace(B){return this.x*=B,this.y*=B,this}scale(B){return new k(this.x*B,this.y*B)}scaleToRef(B,I){return I.x=this.x*B,I.y=this.y*B,I}scaleAndAddToRef(B,I){return I.x+=this.x*B,I.y+=this.y*B,I}equals(B){return B&&this.x===B.x&&this.y===B.y}equalsWithEpsilon(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:M.d;return B&&(0,e.WithinEpsilon)(this.x,B.x,I)&&(0,e.WithinEpsilon)(this.y,B.y,I)}equalsToFloats(B,I){return this.x===B&&this.y===I}floor(){return new k(Math.floor(this.x),Math.floor(this.y))}floorToRef(B){return B.x=Math.floor(this.x),B.y=Math.floor(this.y),B}fract(){return new k(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(B){return B.x=this.x-Math.floor(this.x),B.y=this.y-Math.floor(this.y),B}rotate(B){return this.rotateToRef(B,new k)}rotateToRef(B,I){const C=Math.cos(B),M=Math.sin(B);return I.x=C*this.x-M*this.y,I.y=M*this.x+C*this.y,I}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){const B=new k;return this.normalizeToRef(B),B}normalizeToRef(B){const I=this.length();return 0===I&&(B.x=this.x,B.y=this.y),this.scaleToRef(1/I,B)}clone(){return new k(this.x,this.y)}dot(B){return this.x*B.x+this.y*B.y}static Zero(){return new k(0,0)}static One(){return new k(1,1)}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new k((0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).vf((0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I))}static get ZeroReadOnly(){return k._ZeroReadOnly}static oI(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new k(B[I],B[I+1])}static FromArrayToRef(B,I,C){return C.x=B[I],C.y=B[I+1],C}static FromFloatsToRef(B,I,C){return C.vf(B,I),C}static CatmullRom(B,I,C,M,x){const y=x*x,f=x*y,L=.5*(2*I.x+(-B.x+C.x)*x+(2*B.x-5*I.x+4*C.x-M.x)*y+(-B.x+3*I.x-3*C.x+M.x)*f),e=.5*(2*I.y+(-B.y+C.y)*x+(2*B.y-5*I.y+4*C.y-M.y)*y+(-B.y+3*I.y-3*C.y+M.y)*f);return new k(L,e)}static ClampToRef(B,I,C,M){return M.x=(0,e.Clamp)(B.x,I.x,C.x),M.y=(0,e.Clamp)(B.y,I.y,C.y),M}static Clamp(B,I,C){const M=(0,e.Clamp)(B.x,I.x,C.x),x=(0,e.Clamp)(B.y,I.y,C.y);return new k(M,x)}static Hermite(B,I,C,M,x){const y=x*x,f=x*y,L=2*f-3*y+1,e=-2*f+3*y,g=f-2*y+x,N=f-y,R=B.x*L+C.x*e+I.x*g+M.x*N,H=B.y*L+C.y*e+I.y*g+M.y*N;return new k(R,H)}static Hermite1stDerivative(B,I,C,M,x){return this.Hermite1stDerivativeToRef(B,I,C,M,x,new k)}static Hermite1stDerivativeToRef(B,I,C,M,x,y){const f=x*x;return y.x=6*(f-x)*B.x+(3*f-4*x+1)*I.x+6*(-f+x)*C.x+(3*f-2*x)*M.x,y.y=6*(f-x)*B.y+(3*f-4*x+1)*I.y+6*(-f+x)*C.y+(3*f-2*x)*M.y,y}static Lerp(B,I,C){return k.LerpToRef(B,I,C,new k)}static LerpToRef(B,I,C,M){return M.x=B.x+(I.x-B.x)*C,M.y=B.y+(I.y-B.y)*C,M}static Dot(B,I){return B.x*I.x+B.y*I.y}static Normalize(B){return k.NormalizeToRef(B,new k)}static NormalizeToRef(B,I){return B.normalizeToRef(I),I}static Minimize(B,I){const C=B.x<I.x?B.x:I.x,M=B.y<I.y?B.y:I.y;return new k(C,M)}static Maximize(B,I){const C=B.x>I.x?B.x:I.x,M=B.y>I.y?B.y:I.y;return new k(C,M)}static Transform(B,I){return k.TransformToRef(B,I,new k)}static TransformToRef(B,I,C){const M=I.m,x=B.x*M[0]+B.y*M[4]+M[12],y=B.x*M[1]+B.y*M[5]+M[13];return C.x=x,C.y=y,C}static PointInTriangle(B,I,C,M){const x=.5*(-C.y*M.x+I.y*(-C.x+M.x)+I.x*(C.y-M.y)+C.x*M.y),y=x<0?-1:1,f=(I.y*M.x-I.x*M.y+(M.y-I.y)*B.x+(I.x-M.x)*B.y)*y,L=(I.x*C.y-I.y*C.x+(I.y-C.y)*B.x+(C.x-I.x)*B.y)*y;return f>0&&L>0&&f+L<2*x*y}static Distance(B,I){return Math.sqrt(k.DistanceSquared(B,I))}static DistanceSquared(B,I){const C=B.x-I.x,M=B.y-I.y;return C*C+M*M}static Center(B,I){return k.CenterToRef(B,I,new k)}static CenterToRef(B,I,C){return C.vf((B.x+I.x)/2,(B.y+I.y)/2)}static DistanceOfPointFromSegment(B,I,C){const M=k.DistanceSquared(I,C);if(0===M)return k.Distance(B,I);const x=C.FI(I),y=Math.max(0,Math.min(1,k.Dot(B.FI(I),x)/M)),f=I.add(x.multiplyByFloats(y,y));return k.Distance(B,f)}}k._V8PerformanceHack=new k(.5,.5),k._ZeroReadOnly=k.Zero(),Object.defineProperties(k.prototype,{dimension:{value:[2]},rank:{value:1}});class q{get x(){return this._x}set x(B){this._x=B,this._isDirty=!0}get y(){return this._y}set y(B){this._y=B,this._isDirty=!0}get z(){return this._z}set z(B){this._z=B,this._isDirty=!0}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=B,this._y=I,this._z=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"HI"}getHashCode(){let B=F(this._x);return B=397*B^F(this._y),B=397*B^F(this._z),B}Df(){return[this._x,this._y,this._z]}toArray(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[I]=this._x,B[I+1]=this._y,B[I+2]=this._z,this}RC(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q.FromArrayToRef(B,I,this),this}toQuaternion(){return o.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(B){return this._x+=B._x,this._y+=B._y,this._z+=B._z,this._isDirty=!0,this}addInPlaceFromFloats(B,I,C){return this._x+=B,this._y+=I,this._z+=C,this._isDirty=!0,this}add(B){return new q(this._x+B._x,this._y+B._y,this._z+B._z)}addToRef(B,I){return I._x=this._x+B._x,I._y=this._y+B._y,I._z=this._z+B._z,I._isDirty=!0,I}cR(B){return this._x-=B._x,this._y-=B._y,this._z-=B._z,this._isDirty=!0,this}FI(B){return new q(this._x-B._x,this._y-B._y,this._z-B._z)}subtractToRef(B,I){return this.subtractFromFloatsToRef(B._x,B._y,B._z,I)}subtractFromFloats(B,I,C){return new q(this._x-B,this._y-I,this._z-C)}subtractFromFloatsToRef(B,I,C,M){return M._x=this._x-B,M._y=this._y-I,M._z=this._z-C,M._isDirty=!0,M}negate(){return new q(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(B){return B._x=-1*this._x,B._y=-1*this._y,B._z=-1*this._z,B._isDirty=!0,B}scaleInPlace(B){return this._x*=B,this._y*=B,this._z*=B,this._isDirty=!0,this}scale(B){return new q(this._x*B,this._y*B,this._z*B)}scaleToRef(B,I){return I._x=this._x*B,I._y=this._y*B,I._z=this._z*B,I._isDirty=!0,I}getNormalToRef(B){const I=this.length();let C=Math.acos(this._y/I);const M=Math.atan2(this._z,this._x);C>Math.PI/2?C-=Math.PI/2:C+=Math.PI/2;const x=I*Math.sin(C)*Math.cos(M),y=I*Math.cos(C),f=I*Math.sin(C)*Math.sin(M);return B.set(x,y,f),B}applyRotationQuaternionToRef(B,I){const C=this._x,M=this._y,x=this._z,y=B._x,f=B._y,L=B._z,e=B._w,g=2*(f*x-L*M),N=2*(L*C-y*x),R=2*(y*M-f*C);return I._x=C+e*g+f*R-L*N,I._y=M+e*N+L*g-y*R,I._z=x+e*R+y*N-f*g,I._isDirty=!0,I}applyRotationQuaternionInPlace(B){return this.applyRotationQuaternionToRef(B,this)}applyRotationQuaternion(B){return this.applyRotationQuaternionToRef(B,new q)}scaleAndAddToRef(B,I){return I._x+=this._x*B,I._y+=this._y*B,I._z+=this._z*B,I._isDirty=!0,I}projectOnPlane(B,I){return this.projectOnPlaneToRef(B,I,new q)}projectOnPlaneToRef(B,I,C){const M=B.normal,x=B.d,y=G.HI[0];this.subtractToRef(I,y),y.normalize();const f=q.Dot(y,M);if(Math.abs(f)<1e-10)C.Tf(1/0);else{const B=-(q.Dot(I,M)+x)/f,L=y.scaleInPlace(B);I.addToRef(L,C)}return C}equals(B){return B&&this._x===B._x&&this._y===B._y&&this._z===B._z}equalsWithEpsilon(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:M.d;return B&&(0,e.WithinEpsilon)(this._x,B._x,I)&&(0,e.WithinEpsilon)(this._y,B._y,I)&&(0,e.WithinEpsilon)(this._z,B._z,I)}equalsToFloats(B,I,C){return this._x===B&&this._y===I&&this._z===C}multiplyInPlace(B){return this._x*=B._x,this._y*=B._y,this._z*=B._z,this._isDirty=!0,this}multiply(B){return this.multiplyByFloats(B._x,B._y,B._z)}multiplyToRef(B,I){return I._x=this._x*B._x,I._y=this._y*B._y,I._z=this._z*B._z,I._isDirty=!0,I}multiplyByFloats(B,I,C){return new q(this._x*B,this._y*I,this._z*C)}divide(B){return new q(this._x/B._x,this._y/B._y,this._z/B._z)}divideToRef(B,I){return I._x=this._x/B._x,I._y=this._y/B._y,I._z=this._z/B._z,I._isDirty=!0,I}divideInPlace(B){return this._x=this._x/B._x,this._y=this._y/B._y,this._z=this._z/B._z,this._isDirty=!0,this}minimizeInPlace(B){return this.minimizeInPlaceFromFloats(B._x,B._y,B._z)}maximizeInPlace(B){return this.maximizeInPlaceFromFloats(B._x,B._y,B._z)}minimizeInPlaceFromFloats(B,I,C){return B<this._x&&(this.x=B),I<this._y&&(this.y=I),C<this._z&&(this.z=C),this}maximizeInPlaceFromFloats(B,I,C){return B>this._x&&(this.x=B),I>this._y&&(this.y=I),C>this._z&&(this.z=C),this}isNonUniformWithinEpsilon(B){const I=Math.abs(this._x),C=Math.abs(this._y);if(!(0,e.WithinEpsilon)(I,C,B))return!0;const M=Math.abs(this._z);return!(0,e.WithinEpsilon)(I,M,B)||!(0,e.WithinEpsilon)(C,M,B)}get isNonUniform(){const B=Math.abs(this._x);if(B!==Math.abs(this._y))return!0;return B!==Math.abs(this._z)}floorToRef(B){return B._x=Math.floor(this._x),B._y=Math.floor(this._y),B._z=Math.floor(this._z),B._isDirty=!0,B}floor(){return new q(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(B){return B._x=this._x-Math.floor(this._x),B._y=this._y-Math.floor(this._y),B._z=this._z-Math.floor(this._z),B._isDirty=!0,B}fract(){return new q(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(B){if("xyz"===(B=B.toLowerCase()))return this;const I=G.HI[0].M(this);return this.x=I[B[0]],this.y=I[B[1]],this.z=I[B[2]],this}rotateByQuaternionToRef(B,I){return B.toRotationMatrix(G.Matrix[0]),q.TransformCoordinatesToRef(this,G.Matrix[0],I),I}rotateByQuaternionAroundPointToRef(B,I,C){return this.subtractToRef(I,G.HI[0]),G.HI[0].rotateByQuaternionToRef(B,G.HI[0]),I.addToRef(G.HI[0],C),C}cross(B){return q.CrossToRef(this,B,new q)}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){return this.normalizeToRef(new q)}normalizeToRef(B){const I=this.length();return 0===I||1===I?(B._x=this._x,B._y=this._y,B._z=this._z,B._isDirty=!0,B):this.scaleToRef(1/I,B)}clone(){return new q(this._x,this._y,this._z)}M(B){return this.vf(B._x,B._y,B._z)}vf(B,I,C){return this._x=B,this._y=I,this._z=C,this._isDirty=!0,this}set(B,I,C){return this.vf(B,I,C)}Tf(B){return this._x=this._y=this._z=B,this._isDirty=!0,this}static GetClipFactor(B,I,C,M){const x=q.Dot(B,C);return(x-M)/(x-q.Dot(I,C))}static GetAngleBetweenVectors(B,I,C){const M=B.normalizeToRef(G.HI[1]),x=I.normalizeToRef(G.HI[2]);let y=q.Dot(M,x);y=(0,e.Clamp)(y,-1,1);const f=Math.acos(y),L=G.HI[3];return q.CrossToRef(M,x,L),q.Dot(L,C)>0?isNaN(f)?0:f:isNaN(f)?-Math.PI:-Math.acos(y)}static GetAngleBetweenVectorsOnPlane(B,I,C){G.HI[0].M(B);const M=G.HI[0];G.HI[1].M(I);const x=G.HI[1];G.HI[2].M(C);const y=G.HI[2],f=G.HI[3],L=G.HI[4];M.normalize(),x.normalize(),y.normalize(),q.CrossToRef(y,M,f),q.CrossToRef(f,y,L);const g=Math.atan2(q.Dot(x,f),q.Dot(x,L));return(0,e.NormalizeRadians)(g)}static PitchYawRollToMoveBetweenPointsToRef(B,I,C){const M=V.HI[0];return I.subtractToRef(B,M),C._y=Math.atan2(M.x,M.z)||0,C._x=Math.atan2(Math.sqrt(M.x**2+M.z**2),M.y)||0,C._z=0,C._isDirty=!0,C}static PitchYawRollToMoveBetweenPoints(B,I){const C=q.Zero();return q.PitchYawRollToMoveBetweenPointsToRef(B,I,C)}static SlerpToRef(B,I,C,x){C=(0,e.Clamp)(C,0,1);const y=G.HI[0],f=G.HI[1];y.M(B);const L=y.length();y.normalizeFromLength(L),f.M(I);const g=f.length();f.normalizeFromLength(g);const N=q.Dot(y,f);let R,H;if(N<1-M.d){const B=Math.acos(N),I=1/Math.sin(B);R=Math.sin((1-C)*B)*I,H=Math.sin(C*B)*I}else R=1-C,H=C;return y.scaleInPlace(R),f.scaleInPlace(H),x.M(y).addInPlace(f),x.scaleInPlace((0,e.Lerp)(L,g,C)),x}static SmoothToRef(B,I,C,M,x){return q.SlerpToRef(B,I,0===M?1:C/M,x),x}static oI(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new q(B[I],B[I+1],B[I+2])}static FromFloatArray(B,I){return q.oI(B,I)}static FromArrayToRef(B,I,C){return C._x=B[I],C._y=B[I+1],C._z=B[I+2],C._isDirty=!0,C}static FromFloatArrayToRef(B,I,C){return q.FromArrayToRef(B,I,C)}static FromFloatsToRef(B,I,C,M){return M.vf(B,I,C),M}static Zero(){return new q(0,0,0)}static One(){return new q(1,1,1)}static Up(){return new q(0,1,0)}static get UpReadOnly(){return q._UpReadOnly}static get DownReadOnly(){return q._DownReadOnly}static get RightReadOnly(){return q._RightReadOnly}static get LeftReadOnly(){return q._LeftReadOnly}static get LeftHandedForwardReadOnly(){return q._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return q._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return q._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return q._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return q._ZeroReadOnly}static get OneReadOnly(){return q._OneReadOnly}static Down(){return new q(0,-1,0)}static Forward(){return new q(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new q(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new q(1,0,0)}static Left(){return new q(-1,0,0)}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new q((0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).vf((0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I))}static TransformCoordinates(B,I){const C=q.Zero();return q.TransformCoordinatesToRef(B,I,C),C}static TransformCoordinatesToRef(B,I,C){return q.TransformCoordinatesFromFloatsToRef(B._x,B._y,B._z,I,C),C}static TransformCoordinatesFromFloatsToRef(B,I,C,M,x){const y=M.m,f=B*y[0]+I*y[4]+C*y[8]+y[12],L=B*y[1]+I*y[5]+C*y[9]+y[13],e=B*y[2]+I*y[6]+C*y[10]+y[14],g=1/(B*y[3]+I*y[7]+C*y[11]+y[15]);return x._x=f*g,x._y=L*g,x._z=e*g,x._isDirty=!0,x}static TransformNormal(B,I){const C=q.Zero();return q.TransformNormalToRef(B,I,C),C}static TransformNormalToRef(B,I,C){return this.TransformNormalFromFloatsToRef(B._x,B._y,B._z,I,C),C}static TransformNormalFromFloatsToRef(B,I,C,M,x){const y=M.m;return x._x=B*y[0]+I*y[4]+C*y[8],x._y=B*y[1]+I*y[5]+C*y[9],x._z=B*y[2]+I*y[6]+C*y[10],x._isDirty=!0,x}static CatmullRom(B,I,C,M,x){const y=x*x,f=x*y,L=.5*(2*I._x+(-B._x+C._x)*x+(2*B._x-5*I._x+4*C._x-M._x)*y+(-B._x+3*I._x-3*C._x+M._x)*f),e=.5*(2*I._y+(-B._y+C._y)*x+(2*B._y-5*I._y+4*C._y-M._y)*y+(-B._y+3*I._y-3*C._y+M._y)*f),g=.5*(2*I._z+(-B._z+C._z)*x+(2*B._z-5*I._z+4*C._z-M._z)*y+(-B._z+3*I._z-3*C._z+M._z)*f);return new q(L,e,g)}static Clamp(B,I,C){const M=new q;return q.ClampToRef(B,I,C,M),M}static ClampToRef(B,I,C,M){let x=B._x;x=x>C._x?C._x:x,x=x<I._x?I._x:x;let y=B._y;y=y>C._y?C._y:y,y=y<I._y?I._y:y;let f=B._z;return f=f>C._z?C._z:f,f=f<I._z?I._z:f,M.vf(x,y,f),M}static CheckExtends(B,I,C){I.minimizeInPlace(B),C.maximizeInPlace(B)}static Hermite(B,I,C,M,x){const y=x*x,f=x*y,L=2*f-3*y+1,e=-2*f+3*y,g=f-2*y+x,N=f-y,R=B._x*L+C._x*e+I._x*g+M._x*N,H=B._y*L+C._y*e+I._y*g+M._y*N,F=B._z*L+C._z*e+I._z*g+M._z*N;return new q(R,H,F)}static Hermite1stDerivative(B,I,C,M,x){const y=new q;return this.Hermite1stDerivativeToRef(B,I,C,M,x,y),y}static Hermite1stDerivativeToRef(B,I,C,M,x,y){const f=x*x;return y._x=6*(f-x)*B._x+(3*f-4*x+1)*I._x+6*(-f+x)*C._x+(3*f-2*x)*M._x,y._y=6*(f-x)*B._y+(3*f-4*x+1)*I._y+6*(-f+x)*C._y+(3*f-2*x)*M._y,y._z=6*(f-x)*B._z+(3*f-4*x+1)*I._z+6*(-f+x)*C._z+(3*f-2*x)*M._z,y._isDirty=!0,y}static Lerp(B,I,C){const M=new q(0,0,0);return q.LerpToRef(B,I,C,M),M}static LerpToRef(B,I,C,M){return M._x=B._x+(I._x-B._x)*C,M._y=B._y+(I._y-B._y)*C,M._z=B._z+(I._z-B._z)*C,M._isDirty=!0,M}static Dot(B,I){return B._x*I._x+B._y*I._y+B._z*I._z}dot(B){return this._x*B._x+this._y*B._y+this._z*B._z}static Cross(B,I){const C=new q;return q.CrossToRef(B,I,C),C}static CrossToRef(B,I,C){const M=B._y*I._z-B._z*I._y,x=B._z*I._x-B._x*I._z,y=B._x*I._y-B._y*I._x;return C.vf(M,x,y),C}static Normalize(B){const I=q.Zero();return q.NormalizeToRef(B,I),I}static NormalizeToRef(B,I){return B.normalizeToRef(I),I}static Project(B,I,C,M){const x=new q;return q.ProjectToRef(B,I,C,M,x),x}static ProjectToRef(B,I,C,M,x){var y;const f=M.width,e=M.height,g=M.x,N=M.y,R=G.Matrix[1],H=null===(y=L.c.LastCreatedEngine)||void 0===y?void 0:y.isNDCHalfZRange,F=H?1:.5,k=H?0:.5;U.FromValuesToRef(f/2,0,0,0,0,-e/2,0,0,0,0,F,0,g+f/2,e/2+N,k,1,R);const S=G.Matrix[0];return I.multiplyToRef(C,S),S.multiplyToRef(R,S),q.TransformCoordinatesToRef(B,S,x),x}static Reflect(B,I){return this.ReflectToRef(B,I,new q)}static ReflectToRef(B,I,C){const M=V.HI[0];return M.M(I).scaleInPlace(2*q.Dot(B,I)),C.M(B).cR(M)}static _UnprojectFromInvertedMatrixToRef(B,I,C){q.TransformCoordinatesToRef(B,I,C);const M=I.m,x=B._x*M[3]+B._y*M[7]+B._z*M[11]+M[15];return(0,e.WithinEpsilon)(x,1)&&C.scaleInPlace(1/x),C}static UnprojectFromTransform(B,I,C,M,x){return this.Unproject(B,I,C,M,x,U.IdentityReadOnly)}static Unproject(B,I,C,M,x,y){const f=new q;return q.UnprojectToRef(B,I,C,M,x,y,f),f}static UnprojectToRef(B,I,C,M,x,y,f){return q.UnprojectFloatsToRef(B._x,B._y,B._z,I,C,M,x,y,f),f}static UnprojectFloatsToRef(B,I,C,M,x,y,f,e,g){var N;const R=G.Matrix[0];y.multiplyToRef(f,R),R.multiplyToRef(e,R),R.invert();const H=G.HI[0];return H.x=B/M*2-1,H.y=-(I/x*2-1),null!==(N=L.c.LastCreatedEngine)&&void 0!==N&&N.isNDCHalfZRange?H.z=C:H.z=2*C-1,q._UnprojectFromInvertedMatrixToRef(H,R,g),g}static Minimize(B,I){const C=new q;return C.M(B),C.minimizeInPlace(I),C}static Maximize(B,I){const C=new q;return C.M(B),C.maximizeInPlace(I),C}static Distance(B,I){return Math.sqrt(q.DistanceSquared(B,I))}static DistanceSquared(B,I){const C=B._x-I._x,M=B._y-I._y,x=B._z-I._z;return C*C+M*M+x*x}static ProjectOnTriangleToRef(B,I,C,x,y){const f=G.HI[0],L=G.HI[1],g=G.HI[2],N=G.HI[3],R=G.HI[4];C.subtractToRef(I,f),x.subtractToRef(I,L),x.subtractToRef(C,g);const H=f.length(),F=L.length(),k=g.length();if(H<M.d||F<M.d||k<M.d)return y.M(I),q.Distance(B,I);B.subtractToRef(I,R),q.CrossToRef(f,L,N);const S=N.length();if(S<M.d)return y.M(I),q.Distance(B,I);N.normalizeFromLength(S);let o=R.length();if(o<M.d)return y.M(I),0;R.normalizeFromLength(o);const U=q.Dot(N,R),V=G.HI[5],c=G.HI[6];V.M(N).scaleInPlace(-o*U),c.M(B).addInPlace(V);const t=G.HI[4],r=G.HI[5],A=G.HI[7],D=G.HI[8];t.M(f).scaleInPlace(1/H),D.M(L).scaleInPlace(1/F),t.addInPlace(D).scaleInPlace(-1),r.M(f).scaleInPlace(-1/H),D.M(g).scaleInPlace(1/k),r.addInPlace(D).scaleInPlace(-1),A.M(g).scaleInPlace(-1/k),D.M(L).scaleInPlace(-1/F),A.addInPlace(D).scaleInPlace(-1);const J=G.HI[9];let i;J.M(c).cR(I),q.CrossToRef(t,J,D),i=q.Dot(D,N);const u=i;J.M(c).cR(C),q.CrossToRef(r,J,D),i=q.Dot(D,N);const p=i;J.M(c).cR(x),q.CrossToRef(A,J,D),i=q.Dot(D,N);const n=i,O=G.HI[10];let a,W;u>0&&p<0?(O.M(f),a=I,W=C):p>0&&n<0?(O.M(g),a=C,W=x):(O.M(L).scaleInPlace(-1),a=x,W=I);const d=G.HI[9],l=G.HI[4];a.subtractToRef(c,D),W.subtractToRef(c,d),q.CrossToRef(D,d,l);if(!(q.Dot(l,N)<0))return y.M(c),Math.abs(o*U);const E=G.HI[5];q.CrossToRef(O,l,E),E.normalize();const Q=G.HI[9];Q.M(a).cR(c);const Z=Q.length();if(Z<M.d)return y.M(a),q.Distance(B,a);Q.normalizeFromLength(Z);const z=q.Dot(E,Q),b=G.HI[7];b.M(c).addInPlace(E.scaleInPlace(Z*z)),D.M(b).cR(a),o=O.length(),O.normalizeFromLength(o);let Y=q.Dot(D,O)/Math.max(o,M.d);return Y=(0,e.Clamp)(Y,0,1),b.M(a).addInPlace(O.scaleInPlace(Y*o)),y.M(b),q.Distance(B,b)}static Center(B,I){return q.CenterToRef(B,I,q.Zero())}static CenterToRef(B,I,C){return C.vf((B._x+I._x)/2,(B._y+I._y)/2,(B._z+I._z)/2)}static RotationFromAxis(B,I,C){const M=new q;return q.RotationFromAxisToRef(B,I,C,M),M}static RotationFromAxisToRef(B,I,C,M){const x=G.Quaternion[0];return o.RotationQuaternionFromAxisToRef(B,I,C,x),x.toEulerAnglesToRef(M),M}}q._V8PerformanceHack=new q(.5,.5,.5),q._UpReadOnly=q.Up(),q._DownReadOnly=q.Down(),q._LeftHandedForwardReadOnly=q.Forward(!1),q._RightHandedForwardReadOnly=q.Forward(!0),q._LeftHandedBackwardReadOnly=q.Backward(!1),q._RightHandedBackwardReadOnly=q.Backward(!0),q._RightReadOnly=q.Right(),q._LeftReadOnly=q.Left(),q._ZeroReadOnly=q.Zero(),q._OneReadOnly=q.One(),Object.defineProperties(q.prototype,{dimension:{value:[3]},rank:{value:1}});class S{get x(){return this._x}set x(B){this._x=B,this._isDirty=!0}get y(){return this._y}set y(B){this._y=B,this._isDirty=!0}get z(){return this._z}set z(B){this._z=B,this._isDirty=!0}get w(){return this._w}set w(B){this._w=B,this._isDirty=!0}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=B,this._y=I,this._z=C,this._w=M}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let B=F(this._x);return B=397*B^F(this._y),B=397*B^F(this._z),B=397*B^F(this._w),B}Df(){return[this._x,this._y,this._z,this._w]}toArray(B,I){return void 0===I&&(I=0),B[I]=this._x,B[I+1]=this._y,B[I+2]=this._z,B[I+3]=this._w,this}RC(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(B,I,this),this}addInPlace(B){return this.x+=B._x,this.y+=B._y,this.z+=B._z,this.w+=B._w,this}addInPlaceFromFloats(B,I,C,M){return this.x+=B,this.y+=I,this.z+=C,this.w+=M,this}add(B){return new S(this._x+B.x,this._y+B.y,this._z+B.z,this._w+B.w)}addToRef(B,I){return I.x=this._x+B.x,I.y=this._y+B.y,I.z=this._z+B.z,I.w=this._w+B.w,I}cR(B){return this.x-=B.x,this.y-=B.y,this.z-=B.z,this.w-=B.w,this}FI(B){return new S(this._x-B.x,this._y-B.y,this._z-B.z,this._w-B.w)}subtractToRef(B,I){return I.x=this._x-B.x,I.y=this._y-B.y,I.z=this._z-B.z,I.w=this._w-B.w,I}subtractFromFloats(B,I,C,M){return new S(this._x-B,this._y-I,this._z-C,this._w-M)}subtractFromFloatsToRef(B,I,C,M,x){return x.x=this._x-B,x.y=this._y-I,x.z=this._z-C,x.w=this._w-M,x}negate(){return new S(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(B){return B.x=-this._x,B.y=-this._y,B.z=-this._z,B.w=-this._w,B}scaleInPlace(B){return this.x*=B,this.y*=B,this.z*=B,this.w*=B,this}scale(B){return new S(this._x*B,this._y*B,this._z*B,this._w*B)}scaleToRef(B,I){return I.x=this._x*B,I.y=this._y*B,I.z=this._z*B,I.w=this._w*B,I}scaleAndAddToRef(B,I){return I.x+=this._x*B,I.y+=this._y*B,I.z+=this._z*B,I.w+=this._w*B,I}equals(B){return B&&this._x===B.x&&this._y===B.y&&this._z===B.z&&this._w===B.w}equalsWithEpsilon(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:M.d;return B&&(0,e.WithinEpsilon)(this._x,B.x,I)&&(0,e.WithinEpsilon)(this._y,B.y,I)&&(0,e.WithinEpsilon)(this._z,B.z,I)&&(0,e.WithinEpsilon)(this._w,B.w,I)}equalsToFloats(B,I,C,M){return this._x===B&&this._y===I&&this._z===C&&this._w===M}multiplyInPlace(B){return this.x*=B.x,this.y*=B.y,this.z*=B.z,this.w*=B.w,this}multiply(B){return new S(this._x*B.x,this._y*B.y,this._z*B.z,this._w*B.w)}multiplyToRef(B,I){return I.x=this._x*B.x,I.y=this._y*B.y,I.z=this._z*B.z,I.w=this._w*B.w,I}multiplyByFloats(B,I,C,M){return new S(this._x*B,this._y*I,this._z*C,this._w*M)}divide(B){return new S(this._x/B.x,this._y/B.y,this._z/B.z,this._w/B.w)}divideToRef(B,I){return I.x=this._x/B.x,I.y=this._y/B.y,I.z=this._z/B.z,I.w=this._w/B.w,I}divideInPlace(B){return this.divideToRef(B,this)}minimizeInPlace(B){return B.x<this._x&&(this.x=B.x),B.y<this._y&&(this.y=B.y),B.z<this._z&&(this.z=B.z),B.w<this._w&&(this.w=B.w),this}maximizeInPlace(B){return B.x>this._x&&(this.x=B.x),B.y>this._y&&(this.y=B.y),B.z>this._z&&(this.z=B.z),B.w>this._w&&(this.w=B.w),this}minimizeInPlaceFromFloats(B,I,C,M){return this.x=Math.min(B,this._x),this.y=Math.min(I,this._y),this.z=Math.min(C,this._z),this.w=Math.min(M,this._w),this}maximizeInPlaceFromFloats(B,I,C,M){return this.x=Math.max(B,this._x),this.y=Math.max(I,this._y),this.z=Math.max(C,this._z),this.w=Math.max(M,this._w),this}floorToRef(B){return B.x=Math.floor(this._x),B.y=Math.floor(this._y),B.z=Math.floor(this._z),B.w=Math.floor(this._w),B}floor(){return new S(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(B){return B.x=this._x-Math.floor(this._x),B.y=this._y-Math.floor(this._y),B.z=this._z-Math.floor(this._z),B.w=this._w-Math.floor(this._w),B}fract(){return new S(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){return this.normalizeToRef(new S)}normalizeToRef(B){const I=this.length();return 0===I||1===I?(B.x=this._x,B.y=this._y,B.z=this._z,B.w=this._w,B):this.scaleToRef(1/I,B)}toVector3(){return new q(this._x,this._y,this._z)}clone(){return new S(this._x,this._y,this._z,this._w)}M(B){return this.x=B.x,this.y=B.y,this.z=B.z,this.w=B.w,this}vf(B,I,C,M){return this.x=B,this.y=I,this.z=C,this.w=M,this}set(B,I,C,M){return this.vf(B,I,C,M)}Tf(B){return this.x=this.y=this.z=this.w=B,this}dot(B){return this._x*B.x+this._y*B.y+this._z*B.z+this._w*B.w}static oI(B,I){return I||(I=0),new S(B[I],B[I+1],B[I+2],B[I+3])}static FromArrayToRef(B,I,C){return C.x=B[I],C.y=B[I+1],C.z=B[I+2],C.w=B[I+3],C}static FromFloatArrayToRef(B,I,C){return S.FromArrayToRef(B,I,C),C}static FromFloatsToRef(B,I,C,M,x){return x.x=B,x.y=I,x.z=C,x.w=M,x}static Zero(){return new S(0,0,0,0)}static One(){return new S(1,1,1,1)}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new S((0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.x=(0,e.RandomRange)(B,I),C.y=(0,e.RandomRange)(B,I),C.z=(0,e.RandomRange)(B,I),C.w=(0,e.RandomRange)(B,I),C}static Clamp(B,I,C){return S.ClampToRef(B,I,C,new S)}static ClampToRef(B,I,C,M){return M.x=(0,e.Clamp)(B.x,I.x,C.x),M.y=(0,e.Clamp)(B.y,I.y,C.y),M.z=(0,e.Clamp)(B.z,I.z,C.z),M.w=(0,e.Clamp)(B.w,I.w,C.w),M}static CheckExtends(B,I,C){I.minimizeInPlace(B),C.maximizeInPlace(B)}static get ZeroReadOnly(){return S._ZeroReadOnly}static Normalize(B){return S.NormalizeToRef(B,new S)}static NormalizeToRef(B,I){return B.normalizeToRef(I),I}static Minimize(B,I){const C=new S;return C.M(B),C.minimizeInPlace(I),C}static Maximize(B,I){const C=new S;return C.M(B),C.maximizeInPlace(I),C}static Distance(B,I){return Math.sqrt(S.DistanceSquared(B,I))}static DistanceSquared(B,I){const C=B.x-I.x,M=B.y-I.y,x=B.z-I.z,y=B.w-I.w;return C*C+M*M+x*x+y*y}static Center(B,I){return S.CenterToRef(B,I,new S)}static CenterToRef(B,I,C){return C.x=(B.x+I.x)/2,C.y=(B.y+I.y)/2,C.z=(B.z+I.z)/2,C.w=(B.w+I.w)/2,C}static TransformCoordinates(B,I){return S.TransformCoordinatesToRef(B,I,new S)}static TransformCoordinatesToRef(B,I,C){return S.TransformCoordinatesFromFloatsToRef(B._x,B._y,B._z,I,C),C}static TransformCoordinatesFromFloatsToRef(B,I,C,M,x){const y=M.m,f=B*y[0]+I*y[4]+C*y[8]+y[12],L=B*y[1]+I*y[5]+C*y[9]+y[13],e=B*y[2]+I*y[6]+C*y[10]+y[14],g=B*y[3]+I*y[7]+C*y[11]+y[15];return x.x=f,x.y=L,x.z=e,x.w=g,x}static TransformNormal(B,I){return S.TransformNormalToRef(B,I,new S)}static TransformNormalToRef(B,I,C){const M=I.m,x=B.x*M[0]+B.y*M[4]+B.z*M[8],y=B.x*M[1]+B.y*M[5]+B.z*M[9],f=B.x*M[2]+B.y*M[6]+B.z*M[10];return C.x=x,C.y=y,C.z=f,C.w=B.w,C}static TransformNormalFromFloatsToRef(B,I,C,M,x,y){const f=x.m;return y.x=B*f[0]+I*f[4]+C*f[8],y.y=B*f[1]+I*f[5]+C*f[9],y.z=B*f[2]+I*f[6]+C*f[10],y.w=M,y}static FromVector3(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new S(B._x,B._y,B._z,I)}static Dot(B,I){return B.x*I.x+B.y*I.y+B.z*I.z+B.w*I.w}}S._V8PerformanceHack=new S(.5,.5,.5,.5),S._ZeroReadOnly=S.Zero(),Object.defineProperties(S.prototype,{dimension:{value:[4]},rank:{value:1}});class o{get x(){return this._x}set x(B){this._x=B,this._isDirty=!0}get y(){return this._y}set y(B){this._y=B,this._isDirty=!0}get z(){return this._z}set z(B){this._z=B,this._isDirty=!0}get w(){return this._w}set w(B){this._w=B,this._isDirty=!0}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=B,this._y=I,this._z=C,this._w=M}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let B=F(this._x);return B=397*B^F(this._y),B=397*B^F(this._z),B=397*B^F(this._w),B}Df(){return[this._x,this._y,this._z,this._w]}toArray(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[I]=this._x,B[I+1]=this._y,B[I+2]=this._z,B[I+3]=this._w,this}RC(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o.FromArrayToRef(B,I,this)}equals(B){return B&&this._x===B._x&&this._y===B._y&&this._z===B._z&&this._w===B._w}equalsWithEpsilon(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:M.d;return B&&(0,e.WithinEpsilon)(this._x,B._x,I)&&(0,e.WithinEpsilon)(this._y,B._y,I)&&(0,e.WithinEpsilon)(this._z,B._z,I)&&(0,e.WithinEpsilon)(this._w,B._w,I)}isApprox(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:M.d;return B&&((0,e.WithinEpsilon)(this._x,B._x,I)&&(0,e.WithinEpsilon)(this._y,B._y,I)&&(0,e.WithinEpsilon)(this._z,B._z,I)&&(0,e.WithinEpsilon)(this._w,B._w,I)||(0,e.WithinEpsilon)(this._x,-B._x,I)&&(0,e.WithinEpsilon)(this._y,-B._y,I)&&(0,e.WithinEpsilon)(this._z,-B._z,I)&&(0,e.WithinEpsilon)(this._w,-B._w,I))}clone(){return new o(this._x,this._y,this._z,this._w)}M(B){return this._x=B._x,this._y=B._y,this._z=B._z,this._w=B._w,this._isDirty=!0,this}vf(B,I,C,M){return this._x=B,this._y=I,this._z=C,this._w=M,this._isDirty=!0,this}set(B,I,C,M){return this.vf(B,I,C,M)}Tf(B){return this.vf(B,B,B,B)}add(B){return new o(this._x+B._x,this._y+B._y,this._z+B._z,this._w+B._w)}addInPlace(B){return this._x+=B._x,this._y+=B._y,this._z+=B._z,this._w+=B._w,this._isDirty=!0,this}addToRef(B,I){return I._x=this._x+B._x,I._y=this._y+B._y,I._z=this._z+B._z,I._w=this._w+B._w,I._isDirty=!0,I}addInPlaceFromFloats(B,I,C,M){return this._x+=B,this._y+=I,this._z+=C,this._w+=M,this._isDirty=!0,this}subtractToRef(B,I){return I._x=this._x-B._x,I._y=this._y-B._y,I._z=this._z-B._z,I._w=this._w-B._w,I._isDirty=!0,I}subtractFromFloats(B,I,C,M){return this.subtractFromFloatsToRef(B,I,C,M,new o)}subtractFromFloatsToRef(B,I,C,M,x){return x._x=this._x-B,x._y=this._y-I,x._z=this._z-C,x._w=this._w-M,x._isDirty=!0,x}FI(B){return new o(this._x-B._x,this._y-B._y,this._z-B._z,this._w-B._w)}cR(B){return this._x-=B._x,this._y-=B._y,this._z-=B._z,this._w-=B._w,this._isDirty=!0,this}scale(B){return new o(this._x*B,this._y*B,this._z*B,this._w*B)}scaleToRef(B,I){return I._x=this._x*B,I._y=this._y*B,I._z=this._z*B,I._w=this._w*B,I._isDirty=!0,I}scaleInPlace(B){return this._x*=B,this._y*=B,this._z*=B,this._w*=B,this._isDirty=!0,this}scaleAndAddToRef(B,I){return I._x+=this._x*B,I._y+=this._y*B,I._z+=this._z*B,I._w+=this._w*B,I._isDirty=!0,I}multiply(B){const I=new o(0,0,0,1);return this.multiplyToRef(B,I),I}multiplyToRef(B,I){const C=this._x*B._w+this._y*B._z-this._z*B._y+this._w*B._x,M=-this._x*B._z+this._y*B._w+this._z*B._x+this._w*B._y,x=this._x*B._y-this._y*B._x+this._z*B._w+this._w*B._z,y=-this._x*B._x-this._y*B._y-this._z*B._z+this._w*B._w;return I.vf(C,M,x,y),I}multiplyInPlace(B){return this.multiplyToRef(B,this)}multiplyByFloats(B,I,C,M){return this._x*=B,this._y*=I,this._z*=C,this._w*=M,this._isDirty=!0,this}divide(B){throw new ReferenceError("Can not divide a quaternion")}divideToRef(B,I){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(B){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new o)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(B){return B._x=-this._x,B._y=-this._y,B._z=-this._z,B._w=-this._w,B._isDirty=!0,B}equalsToFloats(B,I,C,M){return this._x===B&&this._y===I&&this._z===C&&this._w===M}floorToRef(B){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(B){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(B){return B.vf(-this._x,-this._y,-this._z,this._w),B}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new o(-this._x,-this._y,-this._z,this._w)}invert(){const B=this.conjugate(),I=this.lengthSquared();return 0==I||1==I||B.scaleInPlace(1/I),B}invertInPlace(){this.conjugateInPlace();const B=this.lengthSquared();return 0==B||1==B||this.scaleInPlace(1/B),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){const B=new o(0,0,0,1);return this.normalizeToRef(B),B}normalizeToRef(B){const I=this.length();return 0===I||1===I?B.vf(this._x,this._y,this._z,this._w):this.scaleToRef(1/I,B)}toEulerAngles(){const B=q.Zero();return this.toEulerAnglesToRef(B),B}toEulerAnglesToRef(B){const I=this._z,C=this._x,M=this._y,x=this._w,y=M*I-C*x,f=.4999999;if(y<-f)B._y=2*Math.atan2(M,x),B._x=Math.PI/2,B._z=0,B._isDirty=!0;else if(y>f)B._y=2*Math.atan2(M,x),B._x=-Math.PI/2,B._z=0,B._isDirty=!0;else{const f=x*x,L=I*I,e=C*C,g=M*M;B._z=Math.atan2(2*(C*M+I*x),-L-e+g+f),B._x=Math.asin(-2*y),B._y=Math.atan2(2*(I*C+M*x),L-e-g+f),B._isDirty=!0}return B}toAlphaBetaGammaToRef(B){const I=this._z,C=this._x,M=this._y,x=this._w,y=Math.sqrt(C*C+M*M),f=Math.sqrt(I*I+x*x),L=2*Math.atan2(y,f),e=2*Math.atan2(I,x),g=2*Math.atan2(M,C),N=(e+g)/2,R=(e-g)/2;return B.set(R,L,N),B}toRotationMatrix(B){return U.FromQuaternionToRef(this,B),B}fromRotationMatrix(B){return o.FromRotationMatrixToRef(B,this),this}dot(B){return this._x*B._x+this._y*B._y+this._z*B._z+this._w*B._w}toAxisAngle(){const B=q.Zero();return{axis:B,angle:this.toAxisAngleToRef(B)}}toAxisAngleToRef(B){let I=0;const C=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),M=this._w;return C>0?(I=2*Math.atan2(C,M),B.set(this._x/C,this._y/C,this._z/C)):(I=0,B.set(1,0,0)),I}static FromRotationMatrix(B){const I=new o;return o.FromRotationMatrixToRef(B,I),I}static FromRotationMatrixToRef(B,I){const C=B.m,M=C[0],x=C[4],y=C[8],f=C[1],L=C[5],e=C[9],g=C[2],N=C[6],R=C[10],H=M+L+R;let F;return H>0?(F=.5/Math.sqrt(H+1),I._w=.25/F,I._x=(N-e)*F,I._y=(y-g)*F,I._z=(f-x)*F,I._isDirty=!0):M>L&&M>R?(F=2*Math.sqrt(1+M-L-R),I._w=(N-e)/F,I._x=.25*F,I._y=(x+f)/F,I._z=(y+g)/F,I._isDirty=!0):L>R?(F=2*Math.sqrt(1+L-M-R),I._w=(y-g)/F,I._x=(x+f)/F,I._y=.25*F,I._z=(e+N)/F,I._isDirty=!0):(F=2*Math.sqrt(1+R-M-L),I._w=(f-x)/F,I._x=(y+g)/F,I._y=(e+N)/F,I._z=.25*F,I._isDirty=!0),I}static Dot(B,I){return B._x*I._x+B._y*I._y+B._z*I._z+B._w*I._w}static AreClose(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const M=o.Dot(B,I);return 1-M*M<=C}static SmoothToRef(B,I,C,M,x){let y=0===M?1:C/M;return y=(0,e.Clamp)(y,0,1),o.SlerpToRef(B,I,y,x),x}static Zero(){return new o(0,0,0,0)}static Inverse(B){return new o(-B._x,-B._y,-B._z,B._w)}static InverseToRef(B,I){return I.set(-B._x,-B._y,-B._z,B._w),I}static Identity(){return new o(0,0,0,1)}static IsIdentity(B){return B&&0===B._x&&0===B._y&&0===B._z&&1===B._w}static RotationAxis(B,I){return o.RotationAxisToRef(B,I,new o)}static RotationAxisToRef(B,I,C){C._w=Math.cos(I/2);const M=Math.sin(I/2)/B.length();return C._x=B._x*M,C._y=B._y*M,C._z=B._z*M,C._isDirty=!0,C}static oI(B,I){return I||(I=0),new o(B[I],B[I+1],B[I+2],B[I+3])}static FromArrayToRef(B,I,C){return C._x=B[I],C._y=B[I+1],C._z=B[I+2],C._w=B[I+3],C._isDirty=!0,C}static FromFloatsToRef(B,I,C,M,x){return x.vf(B,I,C,M),x}static FromEulerAngles(B,I,C){const M=new o;return o.RotationYawPitchRollToRef(I,B,C,M),M}static FromEulerAnglesToRef(B,I,C,M){return o.RotationYawPitchRollToRef(I,B,C,M),M}static FromEulerVector(B){const I=new o;return o.RotationYawPitchRollToRef(B._y,B._x,B._z,I),I}static FromEulerVectorToRef(B,I){return o.RotationYawPitchRollToRef(B._y,B._x,B._z,I),I}static FromUnitVectorsToRef(B,I,C){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:M.d;const y=q.Dot(B,I)+1;return y<x?Math.abs(B.x)>Math.abs(B.z)?C.set(-B.y,B.x,0,0):C.set(0,-B.z,B.y,0):(q.CrossToRef(B,I,V.HI[0]),C.set(V.HI[0].x,V.HI[0].y,V.HI[0].z,y)),C.normalize()}static RotationYawPitchRoll(B,I,C){const M=new o;return o.RotationYawPitchRollToRef(B,I,C,M),M}static RotationYawPitchRollToRef(B,I,C,M){const x=.5*C,y=.5*I,f=.5*B,L=Math.sin(x),e=Math.cos(x),g=Math.sin(y),N=Math.cos(y),R=Math.sin(f),H=Math.cos(f);return M._x=H*g*e+R*N*L,M._y=R*N*e-H*g*L,M._z=H*N*L-R*g*e,M._w=H*N*e+R*g*L,M._isDirty=!0,M}static RotationAlphaBetaGamma(B,I,C){const M=new o;return o.RotationAlphaBetaGammaToRef(B,I,C,M),M}static RotationAlphaBetaGammaToRef(B,I,C,M){const x=.5*(C+B),y=.5*(C-B),f=.5*I;return M._x=Math.cos(y)*Math.sin(f),M._y=Math.sin(y)*Math.sin(f),M._z=Math.sin(x)*Math.cos(f),M._w=Math.cos(x)*Math.cos(f),M._isDirty=!0,M}static RotationQuaternionFromAxis(B,I,C){const M=new o(0,0,0,0);return o.RotationQuaternionFromAxisToRef(B,I,C,M),M}static RotationQuaternionFromAxisToRef(B,I,C,M){const x=G.Matrix[0];return B=B.normalizeToRef(G.HI[0]),I=I.normalizeToRef(G.HI[1]),C=C.normalizeToRef(G.HI[2]),U.FromXYZAxesToRef(B,I,C,x),o.FromRotationMatrixToRef(x,M),M}static FromLookDirectionLH(B,I){const C=new o;return o.FromLookDirectionLHToRef(B,I,C),C}static FromLookDirectionLHToRef(B,I,C){const M=G.Matrix[0];return U.LookDirectionLHToRef(B,I,M),o.FromRotationMatrixToRef(M,C),C}static FromLookDirectionRH(B,I){const C=new o;return o.FromLookDirectionRHToRef(B,I,C),C}static FromLookDirectionRHToRef(B,I,C){const M=G.Matrix[0];return U.LookDirectionRHToRef(B,I,M),o.FromRotationMatrixToRef(M,C)}static Slerp(B,I,C){const M=o.Identity();return o.SlerpToRef(B,I,C,M),M}static SlerpToRef(B,I,C,M){let x,y,f=B._x*I._x+B._y*I._y+B._z*I._z+B._w*I._w,L=!1;if(f<0&&(L=!0,f=-f),f>.999999)y=1-C,x=L?-C:C;else{const B=Math.acos(f),I=1/Math.sin(B);y=Math.sin((1-C)*B)*I,x=L?-Math.sin(C*B)*I:Math.sin(C*B)*I}return M._x=y*B._x+x*I._x,M._y=y*B._y+x*I._y,M._z=y*B._z+x*I._z,M._w=y*B._w+x*I._w,M._isDirty=!0,M}static Hermite(B,I,C,M,x){const y=x*x,f=x*y,L=2*f-3*y+1,e=-2*f+3*y,g=f-2*y+x,N=f-y,R=B._x*L+C._x*e+I._x*g+M._x*N,H=B._y*L+C._y*e+I._y*g+M._y*N,F=B._z*L+C._z*e+I._z*g+M._z*N,k=B._w*L+C._w*e+I._w*g+M._w*N;return new o(R,H,F,k)}static Hermite1stDerivative(B,I,C,M,x){const y=new o;return this.Hermite1stDerivativeToRef(B,I,C,M,x,y),y}static Hermite1stDerivativeToRef(B,I,C,M,x,y){const f=x*x;return y._x=6*(f-x)*B._x+(3*f-4*x+1)*I._x+6*(-f+x)*C._x+(3*f-2*x)*M._x,y._y=6*(f-x)*B._y+(3*f-4*x+1)*I._y+6*(-f+x)*C._y+(3*f-2*x)*M._y,y._z=6*(f-x)*B._z+(3*f-4*x+1)*I._z+6*(-f+x)*C._z+(3*f-2*x)*M._z,y._w=6*(f-x)*B._w+(3*f-4*x+1)*I._w+6*(-f+x)*C._w+(3*f-2*x)*M._w,y._isDirty=!0,y}static Normalize(B){const I=o.Zero();return o.NormalizeToRef(B,I),I}static NormalizeToRef(B,I){return B.normalizeToRef(I),I}static Clamp(B,I,C){const M=new o;return o.ClampToRef(B,I,C,M),M}static ClampToRef(B,I,C,M){return M.vf((0,e.Clamp)(B.x,I.x,C.x),(0,e.Clamp)(B.y,I.y,C.y),(0,e.Clamp)(B.z,I.z,C.z),(0,e.Clamp)(B.w,I.w,C.w))}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new o((0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).vf((0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I),(0,e.RandomRange)(B,I))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(B,I){return Math.sqrt(o.DistanceSquared(B,I))}static DistanceSquared(B,I){const C=B.x-I.x,M=B.y-I.y,x=B.z-I.z,y=B.w-I.w;return C*C+M*M+x*x+y*y}static Center(B,I){return o.CenterToRef(B,I,o.Zero())}static CenterToRef(B,I,C){return C.vf((B.x+I.x)/2,(B.y+I.y)/2,(B.z+I.z)/2,(B.w+I.w)/2)}}o._V8PerformanceHack=new o(.5,.5,.5,.5),Object.defineProperties(o.prototype,{dimension:{value:[4]},rank:{value:1}});class U{static get Use64Bits(){return f.e.MatrixUse64Bits}get m(){return this.Mf}markAsUpdated(){this.updateFlag=g._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(B){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],M=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=B,this._isIdentity3x2=B||C,this._isIdentityDirty=!this._isIdentity&&I,this._isIdentity3x2Dirty=!this._isIdentity3x2&&M}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,f.e.MatrixTrackPrecisionChange&&f.e.MatrixTrackedMatrices.push(this),this.Mf=new f.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const B=this.Mf;this._isIdentity=1===B[0]&&0===B[1]&&0===B[2]&&0===B[3]&&0===B[4]&&1===B[5]&&0===B[6]&&0===B[7]&&0===B[8]&&0===B[9]&&1===B[10]&&0===B[11]&&0===B[12]&&0===B[13]&&0===B[14]&&1===B[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Mf[0]||1!==this.Mf[5]||1!==this.Mf[15]||0!==this.Mf[1]||0!==this.Mf[2]||0!==this.Mf[3]||0!==this.Mf[4]||0!==this.Mf[6]||0!==this.Mf[7]||0!==this.Mf[8]||0!==this.Mf[9]||0!==this.Mf[10]||0!==this.Mf[11]||0!==this.Mf[12]||0!==this.Mf[13]||0!==this.Mf[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const B=this.Mf,I=B[0],C=B[1],M=B[2],x=B[3],y=B[4],f=B[5],L=B[6],e=B[7],g=B[8],N=B[9],R=B[10],H=B[11],F=B[12],k=B[13],q=B[14],S=B[15],o=R*S-q*H,U=N*S-k*H,G=N*q-k*R,V=g*S-F*H,c=g*q-R*F,t=g*k-F*N;return I*+(f*o-L*U+e*G)+C*-(y*o-L*V+e*c)+M*+(y*U-f*V+e*t)+x*-(y*G-f*c+L*t)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!B)return this.Mf;const C=this.Mf;for(let M=0;M<16;M++)B[I+M]=C[M];return this}Df(){return this.Mf}RC(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U.FromArrayToRef(B,I,this)}vf(){for(var B=arguments.length,I=new Array(B),C=0;C<B;C++)I[C]=arguments[C];return U.FromArrayToRef(I,0,this)}set(){const B=this.Mf;for(let I=0;I<16;I++)B[I]=I<0||arguments.length<=I?void 0:arguments[I];return this.markAsUpdated(),this}Tf(B){const I=this.Mf;for(let C=0;C<16;C++)I[C]=B;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return U.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(B){const I=new U;return this.addToRef(B,I),I}addToRef(B,I){const C=this.Mf,M=I.Mf,x=B.m;for(let y=0;y<16;y++)M[y]=C[y]+x[y];return I.markAsUpdated(),I}addToSelf(B){const I=this.Mf,C=B.m;return I[0]+=C[0],I[1]+=C[1],I[2]+=C[2],I[3]+=C[3],I[4]+=C[4],I[5]+=C[5],I[6]+=C[6],I[7]+=C[7],I[8]+=C[8],I[9]+=C[9],I[10]+=C[10],I[11]+=C[11],I[12]+=C[12],I[13]+=C[13],I[14]+=C[14],I[15]+=C[15],this.markAsUpdated(),this}addInPlace(B){const I=this.Mf,C=B.m;for(let M=0;M<16;M++)I[M]+=C[M];return this.markAsUpdated(),this}addInPlaceFromFloats(){const B=this.Mf;for(let I=0;I<16;I++)B[I]+=I<0||arguments.length<=I?void 0:arguments[I];return this.markAsUpdated(),this}FI(B){const I=this.Mf,C=B.m;for(let M=0;M<16;M++)I[M]-=C[M];return this.markAsUpdated(),this}subtractToRef(B,I){const C=this.Mf,M=B.m,x=I.Mf;for(let y=0;y<16;y++)x[y]=C[y]-M[y];return I.markAsUpdated(),I}cR(B){const I=this.Mf,C=B.m;for(let M=0;M<16;M++)I[M]-=C[M];return this.markAsUpdated(),this}subtractFromFloats(){for(var B=arguments.length,I=new Array(B),C=0;C<B;C++)I[C]=arguments[C];return this.subtractFromFloatsToRef(...I,new U)}subtractFromFloatsToRef(){for(var B=arguments.length,I=new Array(B),C=0;C<B;C++)I[C]=arguments[C];const M=I.pop(),x=this.Mf,y=M.Mf,f=I;for(let L=0;L<16;L++)y[L]=x[L]-f[L];return M.markAsUpdated(),M}invertToRef(B){return!0===this._isIdentity?(U.IdentityToRef(B),B):(H(this,B.Df())?B.markAsUpdated():B.M(this),B)}addAtIndex(B,I){return this.Mf[B]+=I,this.markAsUpdated(),this}multiplyAtIndex(B,I){return this.Mf[B]*=I,this.markAsUpdated(),this}setTranslationFromFloats(B,I,C){return this.Mf[12]=B,this.Mf[13]=I,this.Mf[14]=C,this.markAsUpdated(),this}addTranslationFromFloats(B,I,C){return this.Mf[12]+=B,this.Mf[13]+=I,this.Mf[14]+=C,this.markAsUpdated(),this}setTranslation(B){return this.setTranslationFromFloats(B._x,B._y,B._z)}getTranslation(){return new q(this.Mf[12],this.Mf[13],this.Mf[14])}getTranslationToRef(B){return B.x=this.Mf[12],B.y=this.Mf[13],B.z=this.Mf[14],B}removeRotationAndScaling(){const B=this.m;return U.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,B[12],B[13],B[14],B[15],this),this._updateIdentityStatus(0===B[12]&&0===B[13]&&0===B[14]&&1===B[15]),this}M(B){B.copyToArray(this.Mf);const I=B;return this.updateFlag=I.updateFlag,this._updateIdentityStatus(I._isIdentity,I._isIdentityDirty,I._isIdentity3x2,I._isIdentity3x2Dirty),this}copyToArray(B){return R(this,B,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(B){const I=new U;return this.multiplyToRef(B,I),I}multiplyInPlace(B){const I=this.Mf,C=B.m;for(let M=0;M<16;M++)I[M]*=C[M];return this.markAsUpdated(),this}multiplyByFloats(){const B=this.Mf;for(let I=0;I<16;I++)B[I]*=I<0||arguments.length<=I?void 0:arguments[I];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var B=arguments.length,I=new Array(B),C=0;C<B;C++)I[C]=arguments[C];const M=I.pop(),x=this.Mf,y=M.Mf,f=I;for(let L=0;L<16;L++)y[L]=x[L]*f[L];return M.markAsUpdated(),M}multiplyToRef(B,I){return this._isIdentity?(I.M(B),I):B._isIdentity?(I.M(this),I):(this.multiplyToArray(B,I.Mf,0),I.markAsUpdated(),I)}multiplyToArray(B,I,C){return N(this,B,I,C),this}divide(B){return this.divideToRef(B,new U)}divideToRef(B,I){const C=this.Mf,M=B.m,x=I.Mf;for(let y=0;y<16;y++)x[y]=C[y]/M[y];return I.markAsUpdated(),I}divideInPlace(B){const I=this.Mf,C=B.m;for(let M=0;M<16;M++)I[M]/=C[M];return this.markAsUpdated(),this}minimizeInPlace(B){const I=this.Mf,C=B.m;for(let M=0;M<16;M++)I[M]=Math.min(I[M],C[M]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const B=this.Mf;for(let I=0;I<16;I++)B[I]=Math.min(B[I],I<0||arguments.length<=I?void 0:arguments[I]);return this.markAsUpdated(),this}maximizeInPlace(B){const I=this.Mf,C=B.m;for(let M=0;M<16;M++)I[M]=Math.min(I[M],C[M]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const B=this.Mf;for(let I=0;I<16;I++)B[I]=Math.min(B[I],I<0||arguments.length<=I?void 0:arguments[I]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new U)}negateInPlace(){const B=this.Mf;for(let I=0;I<16;I++)B[I]=-B[I];return this.markAsUpdated(),this}negateToRef(B){const I=this.Mf,C=B.Mf;for(let M=0;M<16;M++)C[M]=-I[M];return B.markAsUpdated(),B}equals(B){const I=B;if(!I)return!1;if((this._isIdentity||I._isIdentity)&&!this._isIdentityDirty&&!I._isIdentityDirty)return this._isIdentity&&I._isIdentity;const C=this.m,M=I.m;return C[0]===M[0]&&C[1]===M[1]&&C[2]===M[2]&&C[3]===M[3]&&C[4]===M[4]&&C[5]===M[5]&&C[6]===M[6]&&C[7]===M[7]&&C[8]===M[8]&&C[9]===M[9]&&C[10]===M[10]&&C[11]===M[11]&&C[12]===M[12]&&C[13]===M[13]&&C[14]===M[14]&&C[15]===M[15]}equalsWithEpsilon(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this.Mf,M=B.m;for(let x=0;x<16;x++)if(!(0,e.WithinEpsilon)(C[x],M[x],I))return!1;return!0}equalsToFloats(){const B=this.Mf;for(let I=0;I<16;I++)if(B[I]!=(I<0||arguments.length<=I?void 0:arguments[I]))return!1;return!0}floor(){return this.floorToRef(new U)}floorToRef(B){const I=this.Mf,C=B.Mf;for(let M=0;M<16;M++)C[M]=Math.floor(I[M]);return B.markAsUpdated(),B}fract(){return this.fractToRef(new U)}fractToRef(B){const I=this.Mf,C=B.Mf;for(let M=0;M<16;M++)C[M]=I[M]-Math.floor(I[M]);return B.markAsUpdated(),B}clone(){const B=new U;return B.M(this),B}getClassName(){return"Matrix"}getHashCode(){let B=F(this.Mf[0]);for(let I=1;I<16;I++)B=397*B^F(this.Mf[I]);return B}decomposeToTransformNode(B){return B.rotationQuaternion=B.rotationQuaternion||new o,this.decompose(B.Xf,B.rotationQuaternion,B.position)}decompose(B,I,C,M){let x=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return C&&C.Tf(0),B&&B.Tf(1),I&&I.vf(0,0,0,1),!0;const y=this.Mf;if(C&&C.vf(y[12],y[13],y[14]),(B=B||G.HI[0]).x=Math.sqrt(y[0]*y[0]+y[1]*y[1]+y[2]*y[2]),B.y=Math.sqrt(y[4]*y[4]+y[5]*y[5]+y[6]*y[6]),B.z=Math.sqrt(y[8]*y[8]+y[9]*y[9]+y[10]*y[10]),M){const I=(x?M.absoluteScaling.x:M.Xf.x)<0?-1:1,C=(x?M.absoluteScaling.y:M.Xf.y)<0?-1:1,y=(x?M.absoluteScaling.z:M.Xf.z)<0?-1:1;B.x*=I,B.y*=C,B.z*=y}else this.determinant()<=0&&(B.y*=-1);if(0===B._x||0===B._y||0===B._z)return I&&I.vf(0,0,0,1),!1;if(I){const C=1/B._x,M=1/B._y,x=1/B._z;U.FromValuesToRef(y[0]*C,y[1]*C,y[2]*C,0,y[4]*M,y[5]*M,y[6]*M,0,y[8]*x,y[9]*x,y[10]*x,0,0,0,0,1,G.Matrix[0]),o.FromRotationMatrixToRef(G.Matrix[0],I)}return!0}getRow(B){if(B<0||B>3)return null;const I=4*B;return new S(this.Mf[I+0],this.Mf[I+1],this.Mf[I+2],this.Mf[I+3])}getRowToRef(B,I){if(B>=0&&B<=3){const C=4*B;I.x=this.Mf[C+0],I.y=this.Mf[C+1],I.z=this.Mf[C+2],I.w=this.Mf[C+3]}return I}setRow(B,I){return this.setRowFromFloats(B,I.x,I.y,I.z,I.w)}transpose(){const B=new U;return U.TransposeToRef(this,B),B}transposeToRef(B){return U.TransposeToRef(this,B),B}setRowFromFloats(B,I,C,M,x){if(B<0||B>3)return this;const y=4*B;return this.Mf[y+0]=I,this.Mf[y+1]=C,this.Mf[y+2]=M,this.Mf[y+3]=x,this.markAsUpdated(),this}scale(B){const I=new U;return this.scaleToRef(B,I),I}scaleToRef(B,I){for(let C=0;C<16;C++)I.Mf[C]=this.Mf[C]*B;return I.markAsUpdated(),I}scaleAndAddToRef(B,I){for(let C=0;C<16;C++)I.Mf[C]+=this.Mf[C]*B;return I.markAsUpdated(),I}scaleInPlace(B){const I=this.Mf;for(let C=0;C<16;C++)I[C]*=B;return this.markAsUpdated(),this}toNormalMatrix(B){const I=G.Matrix[0];this.invertToRef(I),I.transposeToRef(B);const C=B.Mf;return U.FromValuesToRef(C[0],C[1],C[2],0,C[4],C[5],C[6],0,C[8],C[9],C[10],0,0,0,0,1,B),B}getRotationMatrix(){const B=new U;return this.getRotationMatrixToRef(B),B}getRotationMatrixToRef(B){const I=G.HI[0];if(!this.decompose(I))return U.IdentityToRef(B),B;const C=this.Mf,M=1/I._x,x=1/I._y,y=1/I._z;return U.FromValuesToRef(C[0]*M,C[1]*M,C[2]*M,0,C[4]*x,C[5]*x,C[6]*x,0,C[8]*y,C[9]*y,C[10]*y,0,0,0,0,1,B),B}toggleModelMatrixHandInPlace(){const B=this.Mf;return B[2]*=-1,B[6]*=-1,B[8]*=-1,B[9]*=-1,B[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const B=this.Mf;return B[8]*=-1,B[9]*=-1,B[10]*=-1,B[11]*=-1,this.markAsUpdated(),this}static oI(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=new U;return U.FromArrayToRef(B,I,C),C}static FromArrayToRef(B,I,C){for(let M=0;M<16;M++)C.Mf[M]=B[M+I];return C.markAsUpdated(),C}static FromFloat32ArrayToRefScaled(B,I,C,M){return M.Mf[0]=B[0+I]*C,M.Mf[1]=B[1+I]*C,M.Mf[2]=B[2+I]*C,M.Mf[3]=B[3+I]*C,M.Mf[4]=B[4+I]*C,M.Mf[5]=B[5+I]*C,M.Mf[6]=B[6+I]*C,M.Mf[7]=B[7+I]*C,M.Mf[8]=B[8+I]*C,M.Mf[9]=B[9+I]*C,M.Mf[10]=B[10+I]*C,M.Mf[11]=B[11+I]*C,M.Mf[12]=B[12+I]*C,M.Mf[13]=B[13+I]*C,M.Mf[14]=B[14+I]*C,M.Mf[15]=B[15+I]*C,M.markAsUpdated(),M}static get IdentityReadOnly(){return U._IdentityReadOnly}static FromValuesToRef(B,I,C,M,x,y,f,L,e,g,N,R,H,F,k,q,S){const o=S.Mf;o[0]=B,o[1]=I,o[2]=C,o[3]=M,o[4]=x,o[5]=y,o[6]=f,o[7]=L,o[8]=e,o[9]=g,o[10]=N,o[11]=R,o[12]=H,o[13]=F,o[14]=k,o[15]=q,S.markAsUpdated()}static FromValues(B,I,C,M,x,y,f,L,e,g,N,R,H,F,k,q){const S=new U,o=S.Mf;return o[0]=B,o[1]=I,o[2]=C,o[3]=M,o[4]=x,o[5]=y,o[6]=f,o[7]=L,o[8]=e,o[9]=g,o[10]=N,o[11]=R,o[12]=H,o[13]=F,o[14]=k,o[15]=q,S.markAsUpdated(),S}static Compose(B,I,C){const M=new U;return U.ComposeToRef(B,I,C,M),M}static ComposeToRef(B,I,C,M){const x=M.Mf,y=I._x,f=I._y,L=I._z,e=I._w,g=y+y,N=f+f,R=L+L,H=y*g,F=y*N,k=y*R,q=f*N,S=f*R,o=L*R,U=e*g,G=e*N,V=e*R,c=B._x,t=B._y,r=B._z;return x[0]=(1-(q+o))*c,x[1]=(F+V)*c,x[2]=(k-G)*c,x[3]=0,x[4]=(F-V)*t,x[5]=(1-(H+o))*t,x[6]=(S+U)*t,x[7]=0,x[8]=(k+G)*r,x[9]=(S-U)*r,x[10]=(1-(H+q))*r,x[11]=0,x[12]=C._x,x[13]=C._y,x[14]=C._z,x[15]=1,M.markAsUpdated(),M}static Identity(){const B=U.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return B._updateIdentityStatus(!0),B}static IdentityToRef(B){return U.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,B),B._updateIdentityStatus(!0),B}static Zero(){const B=U.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return B._updateIdentityStatus(!1),B}static RotationX(B){const I=new U;return U.RotationXToRef(B,I),I}static Invert(B){const I=new U;return B.invertToRef(I),I}static RotationXToRef(B,I){const C=Math.sin(B),M=Math.cos(B);return U.FromValuesToRef(1,0,0,0,0,M,C,0,0,-C,M,0,0,0,0,1,I),I._updateIdentityStatus(1===M&&0===C),I}static RotationY(B){const I=new U;return U.RotationYToRef(B,I),I}static RotationYToRef(B,I){const C=Math.sin(B),M=Math.cos(B);return U.FromValuesToRef(M,0,-C,0,0,1,0,0,C,0,M,0,0,0,0,1,I),I._updateIdentityStatus(1===M&&0===C),I}static RotationZ(B){const I=new U;return U.RotationZToRef(B,I),I}static RotationZToRef(B,I){const C=Math.sin(B),M=Math.cos(B);return U.FromValuesToRef(M,C,0,0,-C,M,0,0,0,0,1,0,0,0,0,1,I),I._updateIdentityStatus(1===M&&0===C),I}static RotationAxis(B,I){const C=new U;return U.RotationAxisToRef(B,I,C),C}static RotationAxisToRef(B,I,C){const M=Math.sin(-I),x=Math.cos(-I),y=1-x;B=B.normalizeToRef(G.HI[0]);const f=C.Mf;return f[0]=B._x*B._x*y+x,f[1]=B._x*B._y*y-B._z*M,f[2]=B._x*B._z*y+B._y*M,f[3]=0,f[4]=B._y*B._x*y+B._z*M,f[5]=B._y*B._y*y+x,f[6]=B._y*B._z*y-B._x*M,f[7]=0,f[8]=B._z*B._x*y-B._y*M,f[9]=B._z*B._y*y+B._x*M,f[10]=B._z*B._z*y+x,f[11]=0,f[12]=0,f[13]=0,f[14]=0,f[15]=1,C.markAsUpdated(),C}static RotationAlignToRef(B,I,C){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const y=q.Dot(I,B),f=C.Mf;if(y<-1+M.d)f[0]=-1,f[1]=0,f[2]=0,f[3]=0,f[4]=0,f[5]=x?1:-1,f[6]=0,f[7]=0,f[8]=0,f[9]=0,f[10]=x?-1:1,f[11]=0;else{const C=q.Cross(I,B),M=1/(1+y);f[0]=C._x*C._x*M+y,f[1]=C._y*C._x*M-C._z,f[2]=C._z*C._x*M+C._y,f[3]=0,f[4]=C._x*C._y*M+C._z,f[5]=C._y*C._y*M+y,f[6]=C._z*C._y*M-C._x,f[7]=0,f[8]=C._x*C._z*M-C._y,f[9]=C._y*C._z*M+C._x,f[10]=C._z*C._z*M+y,f[11]=0}return f[12]=0,f[13]=0,f[14]=0,f[15]=1,C.markAsUpdated(),C}static RotationYawPitchRoll(B,I,C){const M=new U;return U.RotationYawPitchRollToRef(B,I,C,M),M}static RotationYawPitchRollToRef(B,I,C,M){return o.RotationYawPitchRollToRef(B,I,C,G.Quaternion[0]),G.Quaternion[0].toRotationMatrix(M),M}static Scaling(B,I,C){const M=new U;return U.ScalingToRef(B,I,C,M),M}static ScalingToRef(B,I,C,M){return U.FromValuesToRef(B,0,0,0,0,I,0,0,0,0,C,0,0,0,0,1,M),M._updateIdentityStatus(1===B&&1===I&&1===C),M}static Translation(B,I,C){const M=new U;return U.TranslationToRef(B,I,C,M),M}static TranslationToRef(B,I,C,M){return U.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,B,I,C,1,M),M._updateIdentityStatus(0===B&&0===I&&0===C),M}static Lerp(B,I,C){const M=new U;return U.LerpToRef(B,I,C,M),M}static LerpToRef(B,I,C,M){const x=M.Mf,y=B.m,f=I.m;for(let L=0;L<16;L++)x[L]=y[L]*(1-C)+f[L]*C;return M.markAsUpdated(),M}static DecomposeLerp(B,I,C){const M=new U;return U.DecomposeLerpToRef(B,I,C,M),M}static DecomposeLerpToRef(B,I,C,M){const x=G.HI[0],y=G.Quaternion[0],f=G.HI[1];B.decompose(x,y,f);const L=G.HI[2],e=G.Quaternion[1],g=G.HI[3];I.decompose(L,e,g);const N=G.HI[4];q.LerpToRef(x,L,C,N);const R=G.Quaternion[2];o.SlerpToRef(y,e,C,R);const H=G.HI[5];return q.LerpToRef(f,g,C,H),U.ComposeToRef(N,R,H,M),M}static LookAtLH(B,I,C){const M=new U;return U.LookAtLHToRef(B,I,C,M),M}static LookAtLHToRef(B,I,C,M){const x=G.HI[0],y=G.HI[1],f=G.HI[2];I.subtractToRef(B,f),f.normalize(),q.CrossToRef(C,f,x);const L=x.lengthSquared();0===L?x.x=1:x.normalizeFromLength(Math.sqrt(L)),q.CrossToRef(f,x,y),y.normalize();const e=-q.Dot(x,B),g=-q.Dot(y,B),N=-q.Dot(f,B);return U.FromValuesToRef(x._x,y._x,f._x,0,x._y,y._y,f._y,0,x._z,y._z,f._z,0,e,g,N,1,M),M}static LookAtRH(B,I,C){const M=new U;return U.LookAtRHToRef(B,I,C,M),M}static LookAtRHToRef(B,I,C,M){const x=G.HI[0],y=G.HI[1],f=G.HI[2];B.subtractToRef(I,f),f.normalize(),q.CrossToRef(C,f,x);const L=x.lengthSquared();0===L?x.x=1:x.normalizeFromLength(Math.sqrt(L)),q.CrossToRef(f,x,y),y.normalize();const e=-q.Dot(x,B),g=-q.Dot(y,B),N=-q.Dot(f,B);return U.FromValuesToRef(x._x,y._x,f._x,0,x._y,y._y,f._y,0,x._z,y._z,f._z,0,e,g,N,1,M),M}static LookDirectionLH(B,I){const C=new U;return U.LookDirectionLHToRef(B,I,C),C}static LookDirectionLHToRef(B,I,C){const M=G.HI[0];M.M(B),M.scaleInPlace(-1);const x=G.HI[1];return q.CrossToRef(I,M,x),U.FromValuesToRef(x._x,x._y,x._z,0,I._x,I._y,I._z,0,M._x,M._y,M._z,0,0,0,0,1,C),C}static LookDirectionRH(B,I){const C=new U;return U.LookDirectionRHToRef(B,I,C),C}static LookDirectionRHToRef(B,I,C){const M=G.HI[2];return q.CrossToRef(I,B,M),U.FromValuesToRef(M._x,M._y,M._z,0,I._x,I._y,I._z,0,B._x,B._y,B._z,0,0,0,0,1,C),C}static OrthoLH(B,I,C,M,x){const y=new U;return U.OrthoLHToRef(B,I,C,M,y,x),y}static OrthoLHToRef(B,I,C,M,x,y){const f=2/B,L=2/I,e=2/(M-C),g=-(M+C)/(M-C);return U.FromValuesToRef(f,0,0,0,0,L,0,0,0,0,e,0,0,0,g,1,x),y&&x.multiplyToRef(c,x),x._updateIdentityStatus(1===f&&1===L&&1===e&&0===g),x}static OrthoOffCenterLH(B,I,C,M,x,y,f){const L=new U;return U.OrthoOffCenterLHToRef(B,I,C,M,x,y,L,f),L}static OrthoOffCenterLHToRef(B,I,C,M,x,y,f,L){const e=2/(I-B),g=2/(M-C),N=2/(y-x),R=-(y+x)/(y-x),H=(B+I)/(B-I),F=(M+C)/(C-M);return U.FromValuesToRef(e,0,0,0,0,g,0,0,0,0,N,0,H,F,R,1,f),L&&f.multiplyToRef(c,f),f.markAsUpdated(),f}static ObliqueOffCenterLHToRef(B,I,C,M,x,y,f,L,e,g,N){const R=-f*Math.cos(L),H=-f*Math.sin(L);return U.TranslationToRef(0,0,-e,G.Matrix[1]),U.FromValuesToRef(1,0,0,0,0,1,0,0,R,H,1,0,0,0,0,1,G.Matrix[0]),G.Matrix[1].multiplyToRef(G.Matrix[0],G.Matrix[0]),U.TranslationToRef(0,0,e,G.Matrix[1]),G.Matrix[0].multiplyToRef(G.Matrix[1],G.Matrix[0]),U.OrthoOffCenterLHToRef(B,I,C,M,x,y,g,N),G.Matrix[0].multiplyToRef(g,g),g}static OrthoOffCenterRH(B,I,C,M,x,y,f){const L=new U;return U.OrthoOffCenterRHToRef(B,I,C,M,x,y,L,f),L}static OrthoOffCenterRHToRef(B,I,C,M,x,y,f,L){return U.OrthoOffCenterLHToRef(B,I,C,M,x,y,f,L),f.Mf[10]*=-1,f}static ObliqueOffCenterRHToRef(B,I,C,M,x,y,f,L,e,g,N){const R=f*Math.cos(L),H=f*Math.sin(L);return U.TranslationToRef(0,0,e,G.Matrix[1]),U.FromValuesToRef(1,0,0,0,0,1,0,0,R,H,1,0,0,0,0,1,G.Matrix[0]),G.Matrix[1].multiplyToRef(G.Matrix[0],G.Matrix[0]),U.TranslationToRef(0,0,-e,G.Matrix[1]),G.Matrix[0].multiplyToRef(G.Matrix[1],G.Matrix[0]),U.OrthoOffCenterRHToRef(B,I,C,M,x,y,g,N),G.Matrix[0].multiplyToRef(g,g),g}static PerspectiveLH(B,I,C,M,x){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const f=new U,L=2*C/B,e=2*C/I,g=(M+C)/(M-C),N=-2*M*C/(M-C),R=Math.tan(y);return U.FromValuesToRef(L,0,0,0,0,e,0,R,0,0,g,1,0,0,N,0,f),x&&f.multiplyToRef(c,f),f._updateIdentityStatus(!1),f}static PerspectiveFovLH(B,I,C,M,x){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,f=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const L=new U;return U.PerspectiveFovLHToRef(B,I,C,M,L,!0,x,y,f),L}static PerspectiveFovLHToRef(B,I,C,M,x){let y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],f=arguments.length>6?arguments[6]:void 0,L=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,e=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const g=C,N=M,R=1/Math.tan(.5*B),H=y?R/I:R,F=y?R:R*I,k=e&&0===g?-1:0!==N?(N+g)/(N-g):1,q=e&&0===g?2*N:0!==N?-2*N*g/(N-g):-2*g,S=Math.tan(L);return U.FromValuesToRef(H,0,0,0,0,F,0,S,0,0,k,1,0,0,q,0,x),f&&x.multiplyToRef(c,x),x._updateIdentityStatus(!1),x}static PerspectiveFovReverseLHToRef(B,I,C,M,x){let y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],f=arguments.length>6?arguments[6]:void 0,L=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const e=1/Math.tan(.5*B),g=y?e/I:e,N=y?e:e*I,R=Math.tan(L);return U.FromValuesToRef(g,0,0,0,0,N,0,R,0,0,-C,1,0,0,1,0,x),f&&x.multiplyToRef(c,x),x._updateIdentityStatus(!1),x}static PerspectiveFovRH(B,I,C,M,x){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,f=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const L=new U;return U.PerspectiveFovRHToRef(B,I,C,M,L,!0,x,y,f),L}static PerspectiveFovRHToRef(B,I,C,M,x){let y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],f=arguments.length>6?arguments[6]:void 0,L=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,e=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const g=C,N=M,R=1/Math.tan(.5*B),H=y?R/I:R,F=y?R:R*I,k=e&&0===g?1:0!==N?-(N+g)/(N-g):-1,q=e&&0===g?2*N:0!==N?-2*N*g/(N-g):-2*g,S=Math.tan(L);return U.FromValuesToRef(H,0,0,0,0,F,0,S,0,0,k,-1,0,0,q,0,x),f&&x.multiplyToRef(c,x),x._updateIdentityStatus(!1),x}static PerspectiveFovReverseRHToRef(B,I,C,M,x){let y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],f=arguments.length>6?arguments[6]:void 0,L=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const e=1/Math.tan(.5*B),g=y?e/I:e,N=y?e:e*I,R=Math.tan(L);return U.FromValuesToRef(g,0,0,0,0,N,0,R,0,0,-C,-1,0,0,-1,0,x),f&&x.multiplyToRef(c,x),x._updateIdentityStatus(!1),x}static GetFinalMatrix(B,I,C,M,x,y){const f=B.width,L=B.height,e=B.x,g=B.y,N=U.FromValues(f/2,0,0,0,0,-L/2,0,0,0,0,y-x,0,e+f/2,L/2+g,x,1),R=new U;return I.multiplyToRef(C,R),R.multiplyToRef(M,R),R.multiplyToRef(N,R)}static GetAsMatrix2x2(B){const I=B.m,C=[I[0],I[1],I[4],I[5]];return f.e.MatrixUse64Bits?C:new Float32Array(C)}static GetAsMatrix3x3(B){const I=B.m,C=[I[0],I[1],I[2],I[4],I[5],I[6],I[8],I[9],I[10]];return f.e.MatrixUse64Bits?C:new Float32Array(C)}static Transpose(B){const I=new U;return U.TransposeToRef(B,I),I}static TransposeToRef(B,I){const C=B.m,M=C[0],x=C[4],y=C[8],f=C[12],L=C[1],e=C[5],g=C[9],N=C[13],R=C[2],H=C[6],F=C[10],k=C[14],q=C[3],S=C[7],o=C[11],U=C[15],G=I.Mf;return G[0]=M,G[1]=x,G[2]=y,G[3]=f,G[4]=L,G[5]=e,G[6]=g,G[7]=N,G[8]=R,G[9]=H,G[10]=F,G[11]=k,G[12]=q,G[13]=S,G[14]=o,G[15]=U,I.markAsUpdated(),I._updateIdentityStatus(B._isIdentity,B._isIdentityDirty),I}static Reflection(B){const I=new U;return U.ReflectionToRef(B,I),I}static ReflectionToRef(B,I){B.normalize();const C=B.normal.x,M=B.normal.y,x=B.normal.z,y=-2*C,f=-2*M,L=-2*x;return U.FromValuesToRef(y*C+1,f*C,L*C,0,y*M,f*M+1,L*M,0,y*x,f*x,L*x+1,0,y*B.d,f*B.d,L*B.d,1,I),I}static FromXYZAxesToRef(B,I,C,M){return U.FromValuesToRef(B._x,B._y,B._z,0,I._x,I._y,I._z,0,C._x,C._y,C._z,0,0,0,0,1,M),M}static FromQuaternionToRef(B,I){const C=B._x*B._x,M=B._y*B._y,x=B._z*B._z,y=B._x*B._y,f=B._z*B._w,L=B._z*B._x,e=B._y*B._w,g=B._y*B._z,N=B._x*B._w;return I.Mf[0]=1-2*(M+x),I.Mf[1]=2*(y+f),I.Mf[2]=2*(L-e),I.Mf[3]=0,I.Mf[4]=2*(y-f),I.Mf[5]=1-2*(x+C),I.Mf[6]=2*(g+N),I.Mf[7]=0,I.Mf[8]=2*(L+e),I.Mf[9]=2*(g-N),I.Mf[10]=1-2*(M+C),I.Mf[11]=0,I.Mf[12]=0,I.Mf[13]=0,I.Mf[14]=0,I.Mf[15]=1,I.markAsUpdated(),I}}U._IdentityReadOnly=U.Identity(),Object.defineProperties(U.prototype,{dimension:{value:[4,4]},rank:{value:2}});class G{}G.HI=(0,x.c)(11,q.Zero),G.Matrix=(0,x.c)(2,U.Identity),G.Quaternion=(0,x.c)(3,o.Zero);class V{}V.Vector2=(0,x.c)(3,k.Zero),V.HI=(0,x.c)(13,q.Zero),V.Vector4=(0,x.c)(3,S.Zero),V.Quaternion=(0,x.c)(3,o.Zero),V.Matrix=(0,x.c)(8,U.Identity),(0,y.h)("BABYLON.Vector2",k),(0,y.h)("BABYLON.Vector3",q),(0,y.h)("BABYLON.Vector4",S),(0,y.h)("BABYLON.Matrix",U);const c=U.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11204:(B,I,C)=>{function M(B,I){const C=[];for(let M=0;M<B;++M)C.push(I());return C}function x(B,I){return M(B,I)}C.d(I,{b:()=>M,c:()=>x,d:()=>f});const y=["push","splice","pop","shift","unshift"];function f(B,I){const C=y.map((C=>function(B,I,C){const M=B[I];if("function"!==typeof M)return null;const x=function(){const M=B.length,y=x.previous.apply(B,arguments);return C(I,M),y};return M.next=x,x.previous=M,B[I]=x,()=>{const C=x.previous;if(!C)return;const M=x.next;M?(C.next=M,M.previous=C):(C.next=void 0,B[I]=C),x.next=void 0,x.previous=void 0}}(B,C,I)));return()=>{for(const B of C)null===B||void 0===B||B()}}}}]);