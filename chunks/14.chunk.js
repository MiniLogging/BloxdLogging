"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[14],{12485:(u,R,I)=>{I.d(R,{c:()=>C,f:()=>K,j:()=>B,l:()=>U});const B=1/2.2,U=2.2,K=(1+Math.sqrt(5))/2,C=.001},12491:(u,R,I)=>{function B(u){return parseInt(u.toString().replace(/\W/g,""))}function U(u,R){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(u-R)<=I}function K(u,R,I){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return u<R-B||u>I+B}function C(u,R){return u===R?u:Math.random()*(R-u)+u}function D(u,R,I){return u+(R-u)*I}function s(u,R,I){let B=E(R-u,360);return B>180&&(B-=360),u+B*b(I)}function t(u,R,I){let B=0;return B=u!=R?b((I-u)/(R-u)):0,B}function G(u,R,I,B,U){const K=U*U,C=U*K;return u*(2*C-3*K+1)+I*(-2*C+3*K)+R*(C-2*K+U)+B*(C-K)}function S(u,R,I,B,U){const K=U*U;return 6*(K-U)*u+(3*K-4*U+1)*R+6*(-K+U)*I+(3*K-2*U)*B}function b(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(I,Math.max(R,u))}function r(u){return u-=2*Math.PI*Math.floor((u+Math.PI)/(2*Math.PI))}function P(u){const R=u.toString(16);return u<=15?("0"+R).toUpperCase():R.toUpperCase()}function X(u){if(Math.log2)return Math.floor(Math.log2(u));if(u<0)return NaN;if(0===u)return-1/0;let R=0;if(u<1){for(;u<1;)R++,u*=2;R=-R}else if(u>1)for(;u>1;)R++,u=Math.floor(u/2);return R}function E(u,R){return u-Math.floor(u/R)*R}function z(u,R,I){return(u-R)/(I-R)}function f(u,R,I){return u*(I-R)+R}function T(u,R){let I=E(R-u,360);return I>180&&(I-=360),I}function Q(u,R){const I=E(u,2*R);return R-Math.abs(I-R)}function V(u,R,I){let B=b(I);return B=-2*B*B*B+3*B*B,R*B+u*(1-B)}function q(u,R,I){let B=0;return B=Math.abs(R-u)<=I?R:u+Math.sign(R-u)*I,B}function e(u,R,I){const B=T(u,R);let U=0;return U=-I<B&&B<I?R:q(u,R=u+B,I),U}function Y(u,R,I){return(u-R)/(I-R)}function M(u,R,I){return(I-R)*u+R}function o(u,R){const I=u%R;return 0===I?R:o(R,I)}I.r(R),I.d(R,{Clamp:()=>b,DeltaAngle:()=>T,Denormalize:()=>f,ExtractAsInt:()=>B,Hermite:()=>G,Hermite1stDerivative:()=>S,HighestCommonFactor:()=>o,ILog2:()=>X,InverseLerp:()=>t,Lerp:()=>D,LerpAngle:()=>s,MoveTowards:()=>q,MoveTowardsAngle:()=>e,Normalize:()=>z,NormalizeRadians:()=>r,OutsideRange:()=>K,PercentToRange:()=>M,PingPong:()=>Q,RandomRange:()=>C,RangeToPercent:()=>Y,Repeat:()=>E,SmoothStep:()=>V,ToHex:()=>P,WithinEpsilon:()=>U})},12481:(u,R,I)=>{I.r(R),I.d(R,{Matrix:()=>f,Quaternion:()=>z,TmpVectors:()=>Q,Vector2:()=>P,PR:()=>X,Vector4:()=>E});var B=I(12485),U=I(12487),K=I(12433),C=I(12409),D=I(12346),s=I(12491);class t{}function G(u,R,I){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const U=u.sD(),K=R.sD(),C=U[0],D=U[1],s=U[2],t=U[3],G=U[4],S=U[5],b=U[6],r=U[7],P=U[8],X=U[9],E=U[10],z=U[11],f=U[12],T=U[13],Q=U[14],V=U[15],q=K[0],e=K[1],Y=K[2],M=K[3],o=K[4],j=K[5],h=K[6],x=K[7],g=K[8],v=K[9],p=K[10],l=K[11],Z=K[12],c=K[13],k=K[14],w=K[15];I[B]=C*q+D*o+s*g+t*Z,I[B+1]=C*e+D*j+s*v+t*c,I[B+2]=C*Y+D*h+s*p+t*k,I[B+3]=C*M+D*x+s*l+t*w,I[B+4]=G*q+S*o+b*g+r*Z,I[B+5]=G*e+S*j+b*v+r*c,I[B+6]=G*Y+S*h+b*p+r*k,I[B+7]=G*M+S*x+b*l+r*w,I[B+8]=P*q+X*o+E*g+z*Z,I[B+9]=P*e+X*j+E*v+z*c,I[B+10]=P*Y+X*h+E*p+z*k,I[B+11]=P*M+X*x+E*l+z*w,I[B+12]=f*q+T*o+Q*g+V*Z,I[B+13]=f*e+T*j+Q*v+V*c,I[B+14]=f*Y+T*h+Q*p+V*k,I[B+15]=f*M+T*x+Q*l+V*w}function S(u,R){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const B=u.sD();R[I]=B[0],R[I+1]=B[1],R[I+2]=B[2],R[I+3]=B[3],R[I+4]=B[4],R[I+5]=B[5],R[I+6]=B[6],R[I+7]=B[7],R[I+8]=B[8],R[I+9]=B[9],R[I+10]=B[10],R[I+11]=B[11],R[I+12]=B[12],R[I+13]=B[13],R[I+14]=B[14],R[I+15]=B[15]}function b(u,R){const I=u.sD(),B=I[0],U=I[1],K=I[2],C=I[3],D=I[4],s=I[5],t=I[6],G=I[7],S=I[8],b=I[9],r=I[10],P=I[11],X=I[12],E=I[13],z=I[14],f=I[15],T=r*f-z*P,Q=b*f-E*P,V=b*z-E*r,q=S*f-X*P,e=S*z-r*X,Y=S*E-X*b,M=+(s*T-t*Q+G*V),o=-(D*T-t*q+G*e),j=+(D*Q-s*q+G*Y),h=-(D*V-s*e+t*Y),x=B*M+U*o+K*j+C*h;if(0===x)return!1;const g=1/x,v=t*f-z*G,p=s*f-E*G,l=s*z-E*t,Z=D*f-X*G,c=D*z-X*t,k=D*E-X*s,w=t*P-r*G,i=s*P-b*G,W=s*r-b*t,a=D*P-S*G,A=D*r-S*t,O=D*b-S*s,N=-(U*T-K*Q+C*V),J=+(B*T-K*q+C*e),mu=-(B*Q-U*q+C*Y),L=+(B*V-U*e+K*Y),H=+(U*v-K*p+C*l),y=-(B*v-K*Z+C*c),F=+(B*p-U*Z+C*k),n=-(B*l-U*c+K*k),d=-(U*w-K*i+C*W),uu=+(B*w-K*a+C*A),Ru=-(B*i-U*a+C*O),Iu=+(B*W-U*A+K*O);return R[0]=M*g,R[1]=N*g,R[2]=H*g,R[3]=d*g,R[4]=o*g,R[5]=J*g,R[6]=y*g,R[7]=uu*g,R[8]=j*g,R[9]=mu*g,R[10]=F*g,R[11]=Ru*g,R[12]=h*g,R[13]=L*g,R[14]=n*g,R[15]=Iu*g,!0}t._UpdateFlagSeed=0;const r=u=>parseInt(u.toString().replace(/\W/g,""));class P{constructor(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=u,this.y=R}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let u=r(this.x);return u=397*u^r(this.y),u}toArray(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u[R]=this.x,u[R+1]=this.y,this}bI(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(u,R,this),this}sD(){return[this.x,this.y]}B(u){return this.x=u.x,this.y=u.y,this}ED(u,R){return this.x=u,this.y=R,this}set(u,R){return this.ED(u,R)}fD(u){return this.ED(u,u)}add(u){return new P(this.x+u.x,this.y+u.y)}addToRef(u,R){return R.x=this.x+u.x,R.y=this.y+u.y,R}addInPlace(u){return this.x+=u.x,this.y+=u.y,this}addInPlaceFromFloats(u,R){return this.x+=u,this.y+=R,this}addVector3(u){return new P(this.x+u.x,this.y+u.y)}XR(u){return new P(this.x-u.x,this.y-u.y)}subtractToRef(u,R){return R.x=this.x-u.x,R.y=this.y-u.y,R}RS(u){return this.x-=u.x,this.y-=u.y,this}multiplyInPlace(u){return this.x*=u.x,this.y*=u.y,this}multiply(u){return new P(this.x*u.x,this.y*u.y)}multiplyToRef(u,R){return R.x=this.x*u.x,R.y=this.y*u.y,R}multiplyByFloats(u,R){return new P(this.x*u,this.y*R)}divide(u){return new P(this.x/u.x,this.y/u.y)}divideToRef(u,R){return R.x=this.x/u.x,R.y=this.y/u.y,R}divideInPlace(u){return this.x=this.x/u.x,this.y=this.y/u.y,this}minimizeInPlace(u){return this.minimizeInPlaceFromFloats(u.x,u.y)}maximizeInPlace(u){return this.maximizeInPlaceFromFloats(u.x,u.y)}minimizeInPlaceFromFloats(u,R){return this.x=Math.min(u,this.x),this.y=Math.min(R,this.y),this}maximizeInPlaceFromFloats(u,R){return this.x=Math.max(u,this.x),this.y=Math.max(R,this.y),this}subtractFromFloats(u,R){return new P(this.x-u,this.y-R)}subtractFromFloatsToRef(u,R,I){return I.x=this.x-u,I.y=this.y-R,I}negate(){return new P(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(u){return u.x=-this.x,u.y=-this.y,u}scaleInPlace(u){return this.x*=u,this.y*=u,this}scale(u){return new P(this.x*u,this.y*u)}scaleToRef(u,R){return R.x=this.x*u,R.y=this.y*u,R}scaleAndAddToRef(u,R){return R.x+=this.x*u,R.y+=this.y*u,R}equals(u){return u&&this.x===u.x&&this.y===u.y}equalsWithEpsilon(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.c;return u&&(0,s.WithinEpsilon)(this.x,u.x,R)&&(0,s.WithinEpsilon)(this.y,u.y,R)}equalsToFloats(u,R){return this.x===u&&this.y===R}floor(){return new P(Math.floor(this.x),Math.floor(this.y))}floorToRef(u){return u.x=Math.floor(this.x),u.y=Math.floor(this.y),u}fract(){return new P(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(u){return u.x=this.x-Math.floor(this.x),u.y=this.y-Math.floor(this.y),u}rotate(u){return this.rotateToRef(u,new P)}rotateToRef(u,R){const I=Math.cos(u),B=Math.sin(u);return R.x=I*this.x-B*this.y,R.y=B*this.x+I*this.y,R}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(u){return 0===u||1===u?this:this.scaleInPlace(1/u)}normalizeToNew(){const u=new P;return this.normalizeToRef(u),u}normalizeToRef(u){const R=this.length();return 0===R&&(u.x=this.x,u.y=this.y),this.scaleToRef(1/R,u)}clone(){return new P(this.x,this.y)}dot(u){return this.x*u.x+this.y*u.y}static Zero(){return new P(0,0)}static One(){return new P(1,1)}static Random(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new P((0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R))}static RandomToRef(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).ED((0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R))}static get ZeroReadOnly(){return P._ZeroReadOnly}static TR(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new P(u[R],u[R+1])}static FromArrayToRef(u,R,I){return I.x=u[R],I.y=u[R+1],I}static FromFloatsToRef(u,R,I){return I.ED(u,R),I}static CatmullRom(u,R,I,B,U){const K=U*U,C=U*K,D=.5*(2*R.x+(-u.x+I.x)*U+(2*u.x-5*R.x+4*I.x-B.x)*K+(-u.x+3*R.x-3*I.x+B.x)*C),s=.5*(2*R.y+(-u.y+I.y)*U+(2*u.y-5*R.y+4*I.y-B.y)*K+(-u.y+3*R.y-3*I.y+B.y)*C);return new P(D,s)}static ClampToRef(u,R,I,B){return B.x=(0,s.Clamp)(u.x,R.x,I.x),B.y=(0,s.Clamp)(u.y,R.y,I.y),B}static Clamp(u,R,I){const B=(0,s.Clamp)(u.x,R.x,I.x),U=(0,s.Clamp)(u.y,R.y,I.y);return new P(B,U)}static Hermite(u,R,I,B,U){const K=U*U,C=U*K,D=2*C-3*K+1,s=-2*C+3*K,t=C-2*K+U,G=C-K,S=u.x*D+I.x*s+R.x*t+B.x*G,b=u.y*D+I.y*s+R.y*t+B.y*G;return new P(S,b)}static Hermite1stDerivative(u,R,I,B,U){return this.Hermite1stDerivativeToRef(u,R,I,B,U,new P)}static Hermite1stDerivativeToRef(u,R,I,B,U,K){const C=U*U;return K.x=6*(C-U)*u.x+(3*C-4*U+1)*R.x+6*(-C+U)*I.x+(3*C-2*U)*B.x,K.y=6*(C-U)*u.y+(3*C-4*U+1)*R.y+6*(-C+U)*I.y+(3*C-2*U)*B.y,K}static Lerp(u,R,I){return P.LerpToRef(u,R,I,new P)}static LerpToRef(u,R,I,B){return B.x=u.x+(R.x-u.x)*I,B.y=u.y+(R.y-u.y)*I,B}static Dot(u,R){return u.x*R.x+u.y*R.y}static Normalize(u){return P.NormalizeToRef(u,new P)}static NormalizeToRef(u,R){return u.normalizeToRef(R),R}static Minimize(u,R){const I=u.x<R.x?u.x:R.x,B=u.y<R.y?u.y:R.y;return new P(I,B)}static Maximize(u,R){const I=u.x>R.x?u.x:R.x,B=u.y>R.y?u.y:R.y;return new P(I,B)}static Transform(u,R){return P.TransformToRef(u,R,new P)}static TransformToRef(u,R,I){const B=R.m,U=u.x*B[0]+u.y*B[4]+B[12],K=u.x*B[1]+u.y*B[5]+B[13];return I.x=U,I.y=K,I}static PointInTriangle(u,R,I,B){const U=.5*(-I.y*B.x+R.y*(-I.x+B.x)+R.x*(I.y-B.y)+I.x*B.y),K=U<0?-1:1,C=(R.y*B.x-R.x*B.y+(B.y-R.y)*u.x+(R.x-B.x)*u.y)*K,D=(R.x*I.y-R.y*I.x+(R.y-I.y)*u.x+(I.x-R.x)*u.y)*K;return C>0&&D>0&&C+D<2*U*K}static Distance(u,R){return Math.sqrt(P.DistanceSquared(u,R))}static DistanceSquared(u,R){const I=u.x-R.x,B=u.y-R.y;return I*I+B*B}static Center(u,R){return P.CenterToRef(u,R,new P)}static CenterToRef(u,R,I){return I.ED((u.x+R.x)/2,(u.y+R.y)/2)}static DistanceOfPointFromSegment(u,R,I){const B=P.DistanceSquared(R,I);if(0===B)return P.Distance(u,R);const U=I.XR(R),K=Math.max(0,Math.min(1,P.Dot(u.XR(R),U)/B)),C=R.add(U.multiplyByFloats(K,K));return P.Distance(u,C)}}P._V8PerformanceHack=new P(.5,.5),P._ZeroReadOnly=P.Zero(),Object.defineProperties(P.prototype,{dimension:{value:[2]},rank:{value:1}});class X{get x(){return this._x}set x(u){this._x=u,this._isDirty=!0}get y(){return this._y}set y(u){this._y=u,this._isDirty=!0}get z(){return this._z}set z(u){this._z=u,this._isDirty=!0}constructor(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=u,this._y=R,this._z=I}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"PR"}getHashCode(){let u=r(this._x);return u=397*u^r(this._y),u=397*u^r(this._z),u}sD(){return[this._x,this._y,this._z]}toArray(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u[R]=this._x,u[R+1]=this._y,u[R+2]=this._z,this}bI(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return X.FromArrayToRef(u,R,this),this}toQuaternion(){return z.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(u){return this._x+=u._x,this._y+=u._y,this._z+=u._z,this._isDirty=!0,this}addInPlaceFromFloats(u,R,I){return this._x+=u,this._y+=R,this._z+=I,this._isDirty=!0,this}add(u){return new X(this._x+u._x,this._y+u._y,this._z+u._z)}addToRef(u,R){return R._x=this._x+u._x,R._y=this._y+u._y,R._z=this._z+u._z,R._isDirty=!0,R}RS(u){return this._x-=u._x,this._y-=u._y,this._z-=u._z,this._isDirty=!0,this}XR(u){return new X(this._x-u._x,this._y-u._y,this._z-u._z)}subtractToRef(u,R){return this.subtractFromFloatsToRef(u._x,u._y,u._z,R)}subtractFromFloats(u,R,I){return new X(this._x-u,this._y-R,this._z-I)}subtractFromFloatsToRef(u,R,I,B){return B._x=this._x-u,B._y=this._y-R,B._z=this._z-I,B._isDirty=!0,B}negate(){return new X(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(u){return u._x=-1*this._x,u._y=-1*this._y,u._z=-1*this._z,u._isDirty=!0,u}scaleInPlace(u){return this._x*=u,this._y*=u,this._z*=u,this._isDirty=!0,this}scale(u){return new X(this._x*u,this._y*u,this._z*u)}scaleToRef(u,R){return R._x=this._x*u,R._y=this._y*u,R._z=this._z*u,R._isDirty=!0,R}getNormalToRef(u){const R=this.length();let I=Math.acos(this._y/R);const B=Math.atan2(this._z,this._x);I>Math.PI/2?I-=Math.PI/2:I+=Math.PI/2;const U=R*Math.sin(I)*Math.cos(B),K=R*Math.cos(I),C=R*Math.sin(I)*Math.sin(B);return u.set(U,K,C),u}applyRotationQuaternionToRef(u,R){const I=this._x,B=this._y,U=this._z,K=u._x,C=u._y,D=u._z,s=u._w,t=2*(C*U-D*B),G=2*(D*I-K*U),S=2*(K*B-C*I);return R._x=I+s*t+C*S-D*G,R._y=B+s*G+D*t-K*S,R._z=U+s*S+K*G-C*t,R._isDirty=!0,R}applyRotationQuaternionInPlace(u){return this.applyRotationQuaternionToRef(u,this)}applyRotationQuaternion(u){return this.applyRotationQuaternionToRef(u,new X)}scaleAndAddToRef(u,R){return R._x+=this._x*u,R._y+=this._y*u,R._z+=this._z*u,R._isDirty=!0,R}projectOnPlane(u,R){return this.projectOnPlaneToRef(u,R,new X)}projectOnPlaneToRef(u,R,I){const B=u.normal,U=u.d,K=T.PR[0];this.subtractToRef(R,K),K.normalize();const C=X.Dot(K,B);if(Math.abs(C)<1e-10)I.fD(1/0);else{const u=-(X.Dot(R,B)+U)/C,D=K.scaleInPlace(u);R.addToRef(D,I)}return I}equals(u){return u&&this._x===u._x&&this._y===u._y&&this._z===u._z}equalsWithEpsilon(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.c;return u&&(0,s.WithinEpsilon)(this._x,u._x,R)&&(0,s.WithinEpsilon)(this._y,u._y,R)&&(0,s.WithinEpsilon)(this._z,u._z,R)}equalsToFloats(u,R,I){return this._x===u&&this._y===R&&this._z===I}multiplyInPlace(u){return this._x*=u._x,this._y*=u._y,this._z*=u._z,this._isDirty=!0,this}multiply(u){return this.multiplyByFloats(u._x,u._y,u._z)}multiplyToRef(u,R){return R._x=this._x*u._x,R._y=this._y*u._y,R._z=this._z*u._z,R._isDirty=!0,R}multiplyByFloats(u,R,I){return new X(this._x*u,this._y*R,this._z*I)}divide(u){return new X(this._x/u._x,this._y/u._y,this._z/u._z)}divideToRef(u,R){return R._x=this._x/u._x,R._y=this._y/u._y,R._z=this._z/u._z,R._isDirty=!0,R}divideInPlace(u){return this._x=this._x/u._x,this._y=this._y/u._y,this._z=this._z/u._z,this._isDirty=!0,this}minimizeInPlace(u){return this.minimizeInPlaceFromFloats(u._x,u._y,u._z)}maximizeInPlace(u){return this.maximizeInPlaceFromFloats(u._x,u._y,u._z)}minimizeInPlaceFromFloats(u,R,I){return u<this._x&&(this.x=u),R<this._y&&(this.y=R),I<this._z&&(this.z=I),this}maximizeInPlaceFromFloats(u,R,I){return u>this._x&&(this.x=u),R>this._y&&(this.y=R),I>this._z&&(this.z=I),this}isNonUniformWithinEpsilon(u){const R=Math.abs(this._x),I=Math.abs(this._y);if(!(0,s.WithinEpsilon)(R,I,u))return!0;const B=Math.abs(this._z);return!(0,s.WithinEpsilon)(R,B,u)||!(0,s.WithinEpsilon)(I,B,u)}get isNonUniform(){const u=Math.abs(this._x);if(u!==Math.abs(this._y))return!0;return u!==Math.abs(this._z)}floorToRef(u){return u._x=Math.floor(this._x),u._y=Math.floor(this._y),u._z=Math.floor(this._z),u._isDirty=!0,u}floor(){return new X(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(u){return u._x=this._x-Math.floor(this._x),u._y=this._y-Math.floor(this._y),u._z=this._z-Math.floor(this._z),u._isDirty=!0,u}fract(){return new X(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(u){if("xyz"===(u=u.toLowerCase()))return this;const R=T.PR[0].B(this);return this.x=R[u[0]],this.y=R[u[1]],this.z=R[u[2]],this}rotateByQuaternionToRef(u,R){return u.toRotationMatrix(T.Matrix[0]),X.TransformCoordinatesToRef(this,T.Matrix[0],R),R}rotateByQuaternionAroundPointToRef(u,R,I){return this.subtractToRef(R,T.PR[0]),T.PR[0].rotateByQuaternionToRef(u,T.PR[0]),R.addToRef(T.PR[0],I),I}cross(u){return X.CrossToRef(this,u,new X)}normalizeFromLength(u){return 0===u||1===u?this:this.scaleInPlace(1/u)}normalizeToNew(){return this.normalizeToRef(new X)}normalizeToRef(u){const R=this.length();return 0===R||1===R?(u._x=this._x,u._y=this._y,u._z=this._z,u._isDirty=!0,u):this.scaleToRef(1/R,u)}clone(){return new X(this._x,this._y,this._z)}B(u){return this.ED(u._x,u._y,u._z)}ED(u,R,I){return this._x=u,this._y=R,this._z=I,this._isDirty=!0,this}set(u,R,I){return this.ED(u,R,I)}fD(u){return this._x=this._y=this._z=u,this._isDirty=!0,this}static GetClipFactor(u,R,I,B){const U=X.Dot(u,I);return(U-B)/(U-X.Dot(R,I))}static GetAngleBetweenVectors(u,R,I){const B=u.normalizeToRef(T.PR[1]),U=R.normalizeToRef(T.PR[2]);let K=X.Dot(B,U);K=(0,s.Clamp)(K,-1,1);const C=Math.acos(K),D=T.PR[3];return X.CrossToRef(B,U,D),X.Dot(D,I)>0?isNaN(C)?0:C:isNaN(C)?-Math.PI:-Math.acos(K)}static GetAngleBetweenVectorsOnPlane(u,R,I){T.PR[0].B(u);const B=T.PR[0];T.PR[1].B(R);const U=T.PR[1];T.PR[2].B(I);const K=T.PR[2],C=T.PR[3],D=T.PR[4];B.normalize(),U.normalize(),K.normalize(),X.CrossToRef(K,B,C),X.CrossToRef(C,K,D);const t=Math.atan2(X.Dot(U,C),X.Dot(U,D));return(0,s.NormalizeRadians)(t)}static PitchYawRollToMoveBetweenPointsToRef(u,R,I){const B=Q.PR[0];return R.subtractToRef(u,B),I._y=Math.atan2(B.x,B.z)||0,I._x=Math.atan2(Math.sqrt(B.x**2+B.z**2),B.y)||0,I._z=0,I._isDirty=!0,I}static PitchYawRollToMoveBetweenPoints(u,R){const I=X.Zero();return X.PitchYawRollToMoveBetweenPointsToRef(u,R,I)}static SlerpToRef(u,R,I,U){I=(0,s.Clamp)(I,0,1);const K=T.PR[0],C=T.PR[1];K.B(u);const D=K.length();K.normalizeFromLength(D),C.B(R);const t=C.length();C.normalizeFromLength(t);const G=X.Dot(K,C);let S,b;if(G<1-B.c){const u=Math.acos(G),R=1/Math.sin(u);S=Math.sin((1-I)*u)*R,b=Math.sin(I*u)*R}else S=1-I,b=I;return K.scaleInPlace(S),C.scaleInPlace(b),U.B(K).addInPlace(C),U.scaleInPlace((0,s.Lerp)(D,t,I)),U}static SmoothToRef(u,R,I,B,U){return X.SlerpToRef(u,R,0===B?1:I/B,U),U}static TR(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new X(u[R],u[R+1],u[R+2])}static FromFloatArray(u,R){return X.TR(u,R)}static FromArrayToRef(u,R,I){return I._x=u[R],I._y=u[R+1],I._z=u[R+2],I._isDirty=!0,I}static FromFloatArrayToRef(u,R,I){return X.FromArrayToRef(u,R,I)}static FromFloatsToRef(u,R,I,B){return B.ED(u,R,I),B}static Zero(){return new X(0,0,0)}static One(){return new X(1,1,1)}static Up(){return new X(0,1,0)}static get UpReadOnly(){return X._UpReadOnly}static get DownReadOnly(){return X._DownReadOnly}static get RightReadOnly(){return X._RightReadOnly}static get LeftReadOnly(){return X._LeftReadOnly}static get LeftHandedForwardReadOnly(){return X._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return X._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return X._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return X._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return X._ZeroReadOnly}static get OneReadOnly(){return X._OneReadOnly}static Down(){return new X(0,-1,0)}static Forward(){return new X(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new X(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new X(1,0,0)}static Left(){return new X(-1,0,0)}static Random(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new X((0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R))}static RandomToRef(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).ED((0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R))}static TransformCoordinates(u,R){const I=X.Zero();return X.TransformCoordinatesToRef(u,R,I),I}static TransformCoordinatesToRef(u,R,I){return X.TransformCoordinatesFromFloatsToRef(u._x,u._y,u._z,R,I),I}static TransformCoordinatesFromFloatsToRef(u,R,I,B,U){const K=B.m,C=u*K[0]+R*K[4]+I*K[8]+K[12],D=u*K[1]+R*K[5]+I*K[9]+K[13],s=u*K[2]+R*K[6]+I*K[10]+K[14],t=1/(u*K[3]+R*K[7]+I*K[11]+K[15]);return U._x=C*t,U._y=D*t,U._z=s*t,U._isDirty=!0,U}static TransformNormal(u,R){const I=X.Zero();return X.TransformNormalToRef(u,R,I),I}static TransformNormalToRef(u,R,I){return this.TransformNormalFromFloatsToRef(u._x,u._y,u._z,R,I),I}static TransformNormalFromFloatsToRef(u,R,I,B,U){const K=B.m;return U._x=u*K[0]+R*K[4]+I*K[8],U._y=u*K[1]+R*K[5]+I*K[9],U._z=u*K[2]+R*K[6]+I*K[10],U._isDirty=!0,U}static CatmullRom(u,R,I,B,U){const K=U*U,C=U*K,D=.5*(2*R._x+(-u._x+I._x)*U+(2*u._x-5*R._x+4*I._x-B._x)*K+(-u._x+3*R._x-3*I._x+B._x)*C),s=.5*(2*R._y+(-u._y+I._y)*U+(2*u._y-5*R._y+4*I._y-B._y)*K+(-u._y+3*R._y-3*I._y+B._y)*C),t=.5*(2*R._z+(-u._z+I._z)*U+(2*u._z-5*R._z+4*I._z-B._z)*K+(-u._z+3*R._z-3*I._z+B._z)*C);return new X(D,s,t)}static Clamp(u,R,I){const B=new X;return X.ClampToRef(u,R,I,B),B}static ClampToRef(u,R,I,B){let U=u._x;U=U>I._x?I._x:U,U=U<R._x?R._x:U;let K=u._y;K=K>I._y?I._y:K,K=K<R._y?R._y:K;let C=u._z;return C=C>I._z?I._z:C,C=C<R._z?R._z:C,B.ED(U,K,C),B}static CheckExtends(u,R,I){R.minimizeInPlace(u),I.maximizeInPlace(u)}static Hermite(u,R,I,B,U){const K=U*U,C=U*K,D=2*C-3*K+1,s=-2*C+3*K,t=C-2*K+U,G=C-K,S=u._x*D+I._x*s+R._x*t+B._x*G,b=u._y*D+I._y*s+R._y*t+B._y*G,r=u._z*D+I._z*s+R._z*t+B._z*G;return new X(S,b,r)}static Hermite1stDerivative(u,R,I,B,U){const K=new X;return this.Hermite1stDerivativeToRef(u,R,I,B,U,K),K}static Hermite1stDerivativeToRef(u,R,I,B,U,K){const C=U*U;return K._x=6*(C-U)*u._x+(3*C-4*U+1)*R._x+6*(-C+U)*I._x+(3*C-2*U)*B._x,K._y=6*(C-U)*u._y+(3*C-4*U+1)*R._y+6*(-C+U)*I._y+(3*C-2*U)*B._y,K._z=6*(C-U)*u._z+(3*C-4*U+1)*R._z+6*(-C+U)*I._z+(3*C-2*U)*B._z,K._isDirty=!0,K}static Lerp(u,R,I){const B=new X(0,0,0);return X.LerpToRef(u,R,I,B),B}static LerpToRef(u,R,I,B){return B._x=u._x+(R._x-u._x)*I,B._y=u._y+(R._y-u._y)*I,B._z=u._z+(R._z-u._z)*I,B._isDirty=!0,B}static Dot(u,R){return u._x*R._x+u._y*R._y+u._z*R._z}dot(u){return this._x*u._x+this._y*u._y+this._z*u._z}static Cross(u,R){const I=new X;return X.CrossToRef(u,R,I),I}static CrossToRef(u,R,I){const B=u._y*R._z-u._z*R._y,U=u._z*R._x-u._x*R._z,K=u._x*R._y-u._y*R._x;return I.ED(B,U,K),I}static Normalize(u){const R=X.Zero();return X.NormalizeToRef(u,R),R}static NormalizeToRef(u,R){return u.normalizeToRef(R),R}static Project(u,R,I,B){const U=new X;return X.ProjectToRef(u,R,I,B,U),U}static ProjectToRef(u,R,I,B,U){var K;const C=B.width,s=B.height,t=B.x,G=B.y,S=T.Matrix[1],b=null===(K=D.e.LastCreatedEngine)||void 0===K?void 0:K.isNDCHalfZRange,r=b?1:.5,P=b?0:.5;f.FromValuesToRef(C/2,0,0,0,0,-s/2,0,0,0,0,r,0,t+C/2,s/2+G,P,1,S);const E=T.Matrix[0];return R.multiplyToRef(I,E),E.multiplyToRef(S,E),X.TransformCoordinatesToRef(u,E,U),U}static Reflect(u,R){return this.ReflectToRef(u,R,new X)}static ReflectToRef(u,R,I){const B=Q.PR[0];return B.B(R).scaleInPlace(2*X.Dot(u,R)),I.B(u).RS(B)}static _UnprojectFromInvertedMatrixToRef(u,R,I){X.TransformCoordinatesToRef(u,R,I);const B=R.m,U=u._x*B[3]+u._y*B[7]+u._z*B[11]+B[15];return(0,s.WithinEpsilon)(U,1)&&I.scaleInPlace(1/U),I}static UnprojectFromTransform(u,R,I,B,U){return this.Unproject(u,R,I,B,U,f.IdentityReadOnly)}static Unproject(u,R,I,B,U,K){const C=new X;return X.UnprojectToRef(u,R,I,B,U,K,C),C}static UnprojectToRef(u,R,I,B,U,K,C){return X.UnprojectFloatsToRef(u._x,u._y,u._z,R,I,B,U,K,C),C}static UnprojectFloatsToRef(u,R,I,B,U,K,C,s,t){var G;const S=T.Matrix[0];K.multiplyToRef(C,S),S.multiplyToRef(s,S),S.invert();const b=T.PR[0];return b.x=u/B*2-1,b.y=-(R/U*2-1),null!==(G=D.e.LastCreatedEngine)&&void 0!==G&&G.isNDCHalfZRange?b.z=I:b.z=2*I-1,X._UnprojectFromInvertedMatrixToRef(b,S,t),t}static Minimize(u,R){const I=new X;return I.B(u),I.minimizeInPlace(R),I}static Maximize(u,R){const I=new X;return I.B(u),I.maximizeInPlace(R),I}static Distance(u,R){return Math.sqrt(X.DistanceSquared(u,R))}static DistanceSquared(u,R){const I=u._x-R._x,B=u._y-R._y,U=u._z-R._z;return I*I+B*B+U*U}static ProjectOnTriangleToRef(u,R,I,U,K){const C=T.PR[0],D=T.PR[1],t=T.PR[2],G=T.PR[3],S=T.PR[4];I.subtractToRef(R,C),U.subtractToRef(R,D),U.subtractToRef(I,t);const b=C.length(),r=D.length(),P=t.length();if(b<B.c||r<B.c||P<B.c)return K.B(R),X.Distance(u,R);u.subtractToRef(R,S),X.CrossToRef(C,D,G);const E=G.length();if(E<B.c)return K.B(R),X.Distance(u,R);G.normalizeFromLength(E);let z=S.length();if(z<B.c)return K.B(R),0;S.normalizeFromLength(z);const f=X.Dot(G,S),Q=T.PR[5],V=T.PR[6];Q.B(G).scaleInPlace(-z*f),V.B(u).addInPlace(Q);const q=T.PR[4],e=T.PR[5],Y=T.PR[7],M=T.PR[8];q.B(C).scaleInPlace(1/b),M.B(D).scaleInPlace(1/r),q.addInPlace(M).scaleInPlace(-1),e.B(C).scaleInPlace(-1/b),M.B(t).scaleInPlace(1/P),e.addInPlace(M).scaleInPlace(-1),Y.B(t).scaleInPlace(-1/P),M.B(D).scaleInPlace(-1/r),Y.addInPlace(M).scaleInPlace(-1);const o=T.PR[9];let j;o.B(V).RS(R),X.CrossToRef(q,o,M),j=X.Dot(M,G);const h=j;o.B(V).RS(I),X.CrossToRef(e,o,M),j=X.Dot(M,G);const x=j;o.B(V).RS(U),X.CrossToRef(Y,o,M),j=X.Dot(M,G);const g=j,v=T.PR[10];let p,l;h>0&&x<0?(v.B(C),p=R,l=I):x>0&&g<0?(v.B(t),p=I,l=U):(v.B(D).scaleInPlace(-1),p=U,l=R);const Z=T.PR[9],c=T.PR[4];p.subtractToRef(V,M),l.subtractToRef(V,Z),X.CrossToRef(M,Z,c);if(!(X.Dot(c,G)<0))return K.B(V),Math.abs(z*f);const k=T.PR[5];X.CrossToRef(v,c,k),k.normalize();const w=T.PR[9];w.B(p).RS(V);const i=w.length();if(i<B.c)return K.B(p),X.Distance(u,p);w.normalizeFromLength(i);const W=X.Dot(k,w),a=T.PR[7];a.B(V).addInPlace(k.scaleInPlace(i*W)),M.B(a).RS(p),z=v.length(),v.normalizeFromLength(z);let A=X.Dot(M,v)/Math.max(z,B.c);return A=(0,s.Clamp)(A,0,1),a.B(p).addInPlace(v.scaleInPlace(A*z)),K.B(a),X.Distance(u,a)}static Center(u,R){return X.CenterToRef(u,R,X.Zero())}static CenterToRef(u,R,I){return I.ED((u._x+R._x)/2,(u._y+R._y)/2,(u._z+R._z)/2)}static RotationFromAxis(u,R,I){const B=new X;return X.RotationFromAxisToRef(u,R,I,B),B}static RotationFromAxisToRef(u,R,I,B){const U=T.Quaternion[0];return z.RotationQuaternionFromAxisToRef(u,R,I,U),U.toEulerAnglesToRef(B),B}}X._V8PerformanceHack=new X(.5,.5,.5),X._UpReadOnly=X.Up(),X._DownReadOnly=X.Down(),X._LeftHandedForwardReadOnly=X.Forward(!1),X._RightHandedForwardReadOnly=X.Forward(!0),X._LeftHandedBackwardReadOnly=X.Backward(!1),X._RightHandedBackwardReadOnly=X.Backward(!0),X._RightReadOnly=X.Right(),X._LeftReadOnly=X.Left(),X._ZeroReadOnly=X.Zero(),X._OneReadOnly=X.One(),Object.defineProperties(X.prototype,{dimension:{value:[3]},rank:{value:1}});class E{get x(){return this._x}set x(u){this._x=u,this._isDirty=!0}get y(){return this._y}set y(u){this._y=u,this._isDirty=!0}get z(){return this._z}set z(u){this._z=u,this._isDirty=!0}get w(){return this._w}set w(u){this._w=u,this._isDirty=!0}constructor(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=u,this._y=R,this._z=I,this._w=B}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let u=r(this._x);return u=397*u^r(this._y),u=397*u^r(this._z),u=397*u^r(this._w),u}sD(){return[this._x,this._y,this._z,this._w]}toArray(u,R){return void 0===R&&(R=0),u[R]=this._x,u[R+1]=this._y,u[R+2]=this._z,u[R+3]=this._w,this}bI(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(u,R,this),this}addInPlace(u){return this.x+=u._x,this.y+=u._y,this.z+=u._z,this.w+=u._w,this}addInPlaceFromFloats(u,R,I,B){return this.x+=u,this.y+=R,this.z+=I,this.w+=B,this}add(u){return new E(this._x+u.x,this._y+u.y,this._z+u.z,this._w+u.w)}addToRef(u,R){return R.x=this._x+u.x,R.y=this._y+u.y,R.z=this._z+u.z,R.w=this._w+u.w,R}RS(u){return this.x-=u.x,this.y-=u.y,this.z-=u.z,this.w-=u.w,this}XR(u){return new E(this._x-u.x,this._y-u.y,this._z-u.z,this._w-u.w)}subtractToRef(u,R){return R.x=this._x-u.x,R.y=this._y-u.y,R.z=this._z-u.z,R.w=this._w-u.w,R}subtractFromFloats(u,R,I,B){return new E(this._x-u,this._y-R,this._z-I,this._w-B)}subtractFromFloatsToRef(u,R,I,B,U){return U.x=this._x-u,U.y=this._y-R,U.z=this._z-I,U.w=this._w-B,U}negate(){return new E(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(u){return u.x=-this._x,u.y=-this._y,u.z=-this._z,u.w=-this._w,u}scaleInPlace(u){return this.x*=u,this.y*=u,this.z*=u,this.w*=u,this}scale(u){return new E(this._x*u,this._y*u,this._z*u,this._w*u)}scaleToRef(u,R){return R.x=this._x*u,R.y=this._y*u,R.z=this._z*u,R.w=this._w*u,R}scaleAndAddToRef(u,R){return R.x+=this._x*u,R.y+=this._y*u,R.z+=this._z*u,R.w+=this._w*u,R}equals(u){return u&&this._x===u.x&&this._y===u.y&&this._z===u.z&&this._w===u.w}equalsWithEpsilon(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.c;return u&&(0,s.WithinEpsilon)(this._x,u.x,R)&&(0,s.WithinEpsilon)(this._y,u.y,R)&&(0,s.WithinEpsilon)(this._z,u.z,R)&&(0,s.WithinEpsilon)(this._w,u.w,R)}equalsToFloats(u,R,I,B){return this._x===u&&this._y===R&&this._z===I&&this._w===B}multiplyInPlace(u){return this.x*=u.x,this.y*=u.y,this.z*=u.z,this.w*=u.w,this}multiply(u){return new E(this._x*u.x,this._y*u.y,this._z*u.z,this._w*u.w)}multiplyToRef(u,R){return R.x=this._x*u.x,R.y=this._y*u.y,R.z=this._z*u.z,R.w=this._w*u.w,R}multiplyByFloats(u,R,I,B){return new E(this._x*u,this._y*R,this._z*I,this._w*B)}divide(u){return new E(this._x/u.x,this._y/u.y,this._z/u.z,this._w/u.w)}divideToRef(u,R){return R.x=this._x/u.x,R.y=this._y/u.y,R.z=this._z/u.z,R.w=this._w/u.w,R}divideInPlace(u){return this.divideToRef(u,this)}minimizeInPlace(u){return u.x<this._x&&(this.x=u.x),u.y<this._y&&(this.y=u.y),u.z<this._z&&(this.z=u.z),u.w<this._w&&(this.w=u.w),this}maximizeInPlace(u){return u.x>this._x&&(this.x=u.x),u.y>this._y&&(this.y=u.y),u.z>this._z&&(this.z=u.z),u.w>this._w&&(this.w=u.w),this}minimizeInPlaceFromFloats(u,R,I,B){return this.x=Math.min(u,this._x),this.y=Math.min(R,this._y),this.z=Math.min(I,this._z),this.w=Math.min(B,this._w),this}maximizeInPlaceFromFloats(u,R,I,B){return this.x=Math.max(u,this._x),this.y=Math.max(R,this._y),this.z=Math.max(I,this._z),this.w=Math.max(B,this._w),this}floorToRef(u){return u.x=Math.floor(this._x),u.y=Math.floor(this._y),u.z=Math.floor(this._z),u.w=Math.floor(this._w),u}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(u){return u.x=this._x-Math.floor(this._x),u.y=this._y-Math.floor(this._y),u.z=this._z-Math.floor(this._z),u.w=this._w-Math.floor(this._w),u}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(u){return 0===u||1===u?this:this.scaleInPlace(1/u)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(u){const R=this.length();return 0===R||1===R?(u.x=this._x,u.y=this._y,u.z=this._z,u.w=this._w,u):this.scaleToRef(1/R,u)}toVector3(){return new X(this._x,this._y,this._z)}clone(){return new E(this._x,this._y,this._z,this._w)}B(u){return this.x=u.x,this.y=u.y,this.z=u.z,this.w=u.w,this}ED(u,R,I,B){return this.x=u,this.y=R,this.z=I,this.w=B,this}set(u,R,I,B){return this.ED(u,R,I,B)}fD(u){return this.x=this.y=this.z=this.w=u,this}dot(u){return this._x*u.x+this._y*u.y+this._z*u.z+this._w*u.w}static TR(u,R){return R||(R=0),new E(u[R],u[R+1],u[R+2],u[R+3])}static FromArrayToRef(u,R,I){return I.x=u[R],I.y=u[R+1],I.z=u[R+2],I.w=u[R+3],I}static FromFloatArrayToRef(u,R,I){return E.FromArrayToRef(u,R,I),I}static FromFloatsToRef(u,R,I,B,U){return U.x=u,U.y=R,U.z=I,U.w=B,U}static Zero(){return new E(0,0,0,0)}static One(){return new E(1,1,1,1)}static Random(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R))}static RandomToRef(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,I=arguments.length>2?arguments[2]:void 0;return I.x=(0,s.RandomRange)(u,R),I.y=(0,s.RandomRange)(u,R),I.z=(0,s.RandomRange)(u,R),I.w=(0,s.RandomRange)(u,R),I}static Clamp(u,R,I){return E.ClampToRef(u,R,I,new E)}static ClampToRef(u,R,I,B){return B.x=(0,s.Clamp)(u.x,R.x,I.x),B.y=(0,s.Clamp)(u.y,R.y,I.y),B.z=(0,s.Clamp)(u.z,R.z,I.z),B.w=(0,s.Clamp)(u.w,R.w,I.w),B}static CheckExtends(u,R,I){R.minimizeInPlace(u),I.maximizeInPlace(u)}static get ZeroReadOnly(){return E._ZeroReadOnly}static Normalize(u){return E.NormalizeToRef(u,new E)}static NormalizeToRef(u,R){return u.normalizeToRef(R),R}static Minimize(u,R){const I=new E;return I.B(u),I.minimizeInPlace(R),I}static Maximize(u,R){const I=new E;return I.B(u),I.maximizeInPlace(R),I}static Distance(u,R){return Math.sqrt(E.DistanceSquared(u,R))}static DistanceSquared(u,R){const I=u.x-R.x,B=u.y-R.y,U=u.z-R.z,K=u.w-R.w;return I*I+B*B+U*U+K*K}static Center(u,R){return E.CenterToRef(u,R,new E)}static CenterToRef(u,R,I){return I.x=(u.x+R.x)/2,I.y=(u.y+R.y)/2,I.z=(u.z+R.z)/2,I.w=(u.w+R.w)/2,I}static TransformCoordinates(u,R){return E.TransformCoordinatesToRef(u,R,new E)}static TransformCoordinatesToRef(u,R,I){return E.TransformCoordinatesFromFloatsToRef(u._x,u._y,u._z,R,I),I}static TransformCoordinatesFromFloatsToRef(u,R,I,B,U){const K=B.m,C=u*K[0]+R*K[4]+I*K[8]+K[12],D=u*K[1]+R*K[5]+I*K[9]+K[13],s=u*K[2]+R*K[6]+I*K[10]+K[14],t=u*K[3]+R*K[7]+I*K[11]+K[15];return U.x=C,U.y=D,U.z=s,U.w=t,U}static TransformNormal(u,R){return E.TransformNormalToRef(u,R,new E)}static TransformNormalToRef(u,R,I){const B=R.m,U=u.x*B[0]+u.y*B[4]+u.z*B[8],K=u.x*B[1]+u.y*B[5]+u.z*B[9],C=u.x*B[2]+u.y*B[6]+u.z*B[10];return I.x=U,I.y=K,I.z=C,I.w=u.w,I}static TransformNormalFromFloatsToRef(u,R,I,B,U,K){const C=U.m;return K.x=u*C[0]+R*C[4]+I*C[8],K.y=u*C[1]+R*C[5]+I*C[9],K.z=u*C[2]+R*C[6]+I*C[10],K.w=B,K}static FromVector3(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(u._x,u._y,u._z,R)}static Dot(u,R){return u.x*R.x+u.y*R.y+u.z*R.z+u.w*R.w}}E._V8PerformanceHack=new E(.5,.5,.5,.5),E._ZeroReadOnly=E.Zero(),Object.defineProperties(E.prototype,{dimension:{value:[4]},rank:{value:1}});class z{get x(){return this._x}set x(u){this._x=u,this._isDirty=!0}get y(){return this._y}set y(u){this._y=u,this._isDirty=!0}get z(){return this._z}set z(u){this._z=u,this._isDirty=!0}get w(){return this._w}set w(u){this._w=u,this._isDirty=!0}constructor(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=u,this._y=R,this._z=I,this._w=B}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let u=r(this._x);return u=397*u^r(this._y),u=397*u^r(this._z),u=397*u^r(this._w),u}sD(){return[this._x,this._y,this._z,this._w]}toArray(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u[R]=this._x,u[R+1]=this._y,u[R+2]=this._z,u[R+3]=this._w,this}bI(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z.FromArrayToRef(u,R,this)}equals(u){return u&&this._x===u._x&&this._y===u._y&&this._z===u._z&&this._w===u._w}equalsWithEpsilon(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.c;return u&&(0,s.WithinEpsilon)(this._x,u._x,R)&&(0,s.WithinEpsilon)(this._y,u._y,R)&&(0,s.WithinEpsilon)(this._z,u._z,R)&&(0,s.WithinEpsilon)(this._w,u._w,R)}isApprox(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.c;return u&&((0,s.WithinEpsilon)(this._x,u._x,R)&&(0,s.WithinEpsilon)(this._y,u._y,R)&&(0,s.WithinEpsilon)(this._z,u._z,R)&&(0,s.WithinEpsilon)(this._w,u._w,R)||(0,s.WithinEpsilon)(this._x,-u._x,R)&&(0,s.WithinEpsilon)(this._y,-u._y,R)&&(0,s.WithinEpsilon)(this._z,-u._z,R)&&(0,s.WithinEpsilon)(this._w,-u._w,R))}clone(){return new z(this._x,this._y,this._z,this._w)}B(u){return this._x=u._x,this._y=u._y,this._z=u._z,this._w=u._w,this._isDirty=!0,this}ED(u,R,I,B){return this._x=u,this._y=R,this._z=I,this._w=B,this._isDirty=!0,this}set(u,R,I,B){return this.ED(u,R,I,B)}fD(u){return this.ED(u,u,u,u)}add(u){return new z(this._x+u._x,this._y+u._y,this._z+u._z,this._w+u._w)}addInPlace(u){return this._x+=u._x,this._y+=u._y,this._z+=u._z,this._w+=u._w,this._isDirty=!0,this}addToRef(u,R){return R._x=this._x+u._x,R._y=this._y+u._y,R._z=this._z+u._z,R._w=this._w+u._w,R._isDirty=!0,R}addInPlaceFromFloats(u,R,I,B){return this._x+=u,this._y+=R,this._z+=I,this._w+=B,this._isDirty=!0,this}subtractToRef(u,R){return R._x=this._x-u._x,R._y=this._y-u._y,R._z=this._z-u._z,R._w=this._w-u._w,R._isDirty=!0,R}subtractFromFloats(u,R,I,B){return this.subtractFromFloatsToRef(u,R,I,B,new z)}subtractFromFloatsToRef(u,R,I,B,U){return U._x=this._x-u,U._y=this._y-R,U._z=this._z-I,U._w=this._w-B,U._isDirty=!0,U}XR(u){return new z(this._x-u._x,this._y-u._y,this._z-u._z,this._w-u._w)}RS(u){return this._x-=u._x,this._y-=u._y,this._z-=u._z,this._w-=u._w,this._isDirty=!0,this}scale(u){return new z(this._x*u,this._y*u,this._z*u,this._w*u)}scaleToRef(u,R){return R._x=this._x*u,R._y=this._y*u,R._z=this._z*u,R._w=this._w*u,R._isDirty=!0,R}scaleInPlace(u){return this._x*=u,this._y*=u,this._z*=u,this._w*=u,this._isDirty=!0,this}scaleAndAddToRef(u,R){return R._x+=this._x*u,R._y+=this._y*u,R._z+=this._z*u,R._w+=this._w*u,R._isDirty=!0,R}multiply(u){const R=new z(0,0,0,1);return this.multiplyToRef(u,R),R}multiplyToRef(u,R){const I=this._x*u._w+this._y*u._z-this._z*u._y+this._w*u._x,B=-this._x*u._z+this._y*u._w+this._z*u._x+this._w*u._y,U=this._x*u._y-this._y*u._x+this._z*u._w+this._w*u._z,K=-this._x*u._x-this._y*u._y-this._z*u._z+this._w*u._w;return R.ED(I,B,U,K),R}multiplyInPlace(u){return this.multiplyToRef(u,this)}multiplyByFloats(u,R,I,B){return this._x*=u,this._y*=R,this._z*=I,this._w*=B,this._isDirty=!0,this}divide(u){throw new ReferenceError("Can not divide a quaternion")}divideToRef(u,R){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(u){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new z)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(u){return u._x=-this._x,u._y=-this._y,u._z=-this._z,u._w=-this._w,u._isDirty=!0,u}equalsToFloats(u,R,I,B){return this._x===u&&this._y===R&&this._z===I&&this._w===B}floorToRef(u){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(u){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(u){return u.ED(-this._x,-this._y,-this._z,this._w),u}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new z(-this._x,-this._y,-this._z,this._w)}invert(){const u=this.conjugate(),R=this.lengthSquared();return 0==R||1==R||u.scaleInPlace(1/R),u}invertInPlace(){this.conjugateInPlace();const u=this.lengthSquared();return 0==u||1==u||this.scaleInPlace(1/u),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(u){return 0===u||1===u?this:this.scaleInPlace(1/u)}normalizeToNew(){const u=new z(0,0,0,1);return this.normalizeToRef(u),u}normalizeToRef(u){const R=this.length();return 0===R||1===R?u.ED(this._x,this._y,this._z,this._w):this.scaleToRef(1/R,u)}toEulerAngles(){const u=X.Zero();return this.toEulerAnglesToRef(u),u}toEulerAnglesToRef(u){const R=this._z,I=this._x,B=this._y,U=this._w,K=B*R-I*U,C=.4999999;if(K<-C)u._y=2*Math.atan2(B,U),u._x=Math.PI/2,u._z=0,u._isDirty=!0;else if(K>C)u._y=2*Math.atan2(B,U),u._x=-Math.PI/2,u._z=0,u._isDirty=!0;else{const C=U*U,D=R*R,s=I*I,t=B*B;u._z=Math.atan2(2*(I*B+R*U),-D-s+t+C),u._x=Math.asin(-2*K),u._y=Math.atan2(2*(R*I+B*U),D-s-t+C),u._isDirty=!0}return u}toAlphaBetaGammaToRef(u){const R=this._z,I=this._x,B=this._y,U=this._w,K=Math.sqrt(I*I+B*B),C=Math.sqrt(R*R+U*U),D=2*Math.atan2(K,C),s=2*Math.atan2(R,U),t=2*Math.atan2(B,I),G=(s+t)/2,S=(s-t)/2;return u.set(S,D,G),u}toRotationMatrix(u){return f.FromQuaternionToRef(this,u),u}fromRotationMatrix(u){return z.FromRotationMatrixToRef(u,this),this}dot(u){return this._x*u._x+this._y*u._y+this._z*u._z+this._w*u._w}toAxisAngle(){const u=X.Zero();return{axis:u,angle:this.toAxisAngleToRef(u)}}toAxisAngleToRef(u){let R=0;const I=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),B=this._w;return I>0?(R=2*Math.atan2(I,B),u.set(this._x/I,this._y/I,this._z/I)):(R=0,u.set(1,0,0)),R}static FromRotationMatrix(u){const R=new z;return z.FromRotationMatrixToRef(u,R),R}static FromRotationMatrixToRef(u,R){const I=u.m,B=I[0],U=I[4],K=I[8],C=I[1],D=I[5],s=I[9],t=I[2],G=I[6],S=I[10],b=B+D+S;let r;return b>0?(r=.5/Math.sqrt(b+1),R._w=.25/r,R._x=(G-s)*r,R._y=(K-t)*r,R._z=(C-U)*r,R._isDirty=!0):B>D&&B>S?(r=2*Math.sqrt(1+B-D-S),R._w=(G-s)/r,R._x=.25*r,R._y=(U+C)/r,R._z=(K+t)/r,R._isDirty=!0):D>S?(r=2*Math.sqrt(1+D-B-S),R._w=(K-t)/r,R._x=(U+C)/r,R._y=.25*r,R._z=(s+G)/r,R._isDirty=!0):(r=2*Math.sqrt(1+S-B-D),R._w=(C-U)/r,R._x=(K+t)/r,R._y=(s+G)/r,R._z=.25*r,R._isDirty=!0),R}static Dot(u,R){return u._x*R._x+u._y*R._y+u._z*R._z+u._w*R._w}static AreClose(u,R){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const B=z.Dot(u,R);return 1-B*B<=I}static SmoothToRef(u,R,I,B,U){let K=0===B?1:I/B;return K=(0,s.Clamp)(K,0,1),z.SlerpToRef(u,R,K,U),U}static Zero(){return new z(0,0,0,0)}static Inverse(u){return new z(-u._x,-u._y,-u._z,u._w)}static InverseToRef(u,R){return R.set(-u._x,-u._y,-u._z,u._w),R}static Identity(){return new z(0,0,0,1)}static IsIdentity(u){return u&&0===u._x&&0===u._y&&0===u._z&&1===u._w}static RotationAxis(u,R){return z.RotationAxisToRef(u,R,new z)}static RotationAxisToRef(u,R,I){I._w=Math.cos(R/2);const B=Math.sin(R/2)/u.length();return I._x=u._x*B,I._y=u._y*B,I._z=u._z*B,I._isDirty=!0,I}static TR(u,R){return R||(R=0),new z(u[R],u[R+1],u[R+2],u[R+3])}static FromArrayToRef(u,R,I){return I._x=u[R],I._y=u[R+1],I._z=u[R+2],I._w=u[R+3],I._isDirty=!0,I}static FromFloatsToRef(u,R,I,B,U){return U.ED(u,R,I,B),U}static FromEulerAngles(u,R,I){const B=new z;return z.RotationYawPitchRollToRef(R,u,I,B),B}static FromEulerAnglesToRef(u,R,I,B){return z.RotationYawPitchRollToRef(R,u,I,B),B}static FromEulerVector(u){const R=new z;return z.RotationYawPitchRollToRef(u._y,u._x,u._z,R),R}static FromEulerVectorToRef(u,R){return z.RotationYawPitchRollToRef(u._y,u._x,u._z,R),R}static FromUnitVectorsToRef(u,R,I){let U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:B.c;const K=X.Dot(u,R)+1;return K<U?Math.abs(u.x)>Math.abs(u.z)?I.set(-u.y,u.x,0,0):I.set(0,-u.z,u.y,0):(X.CrossToRef(u,R,Q.PR[0]),I.set(Q.PR[0].x,Q.PR[0].y,Q.PR[0].z,K)),I.normalize()}static RotationYawPitchRoll(u,R,I){const B=new z;return z.RotationYawPitchRollToRef(u,R,I,B),B}static RotationYawPitchRollToRef(u,R,I,B){const U=.5*I,K=.5*R,C=.5*u,D=Math.sin(U),s=Math.cos(U),t=Math.sin(K),G=Math.cos(K),S=Math.sin(C),b=Math.cos(C);return B._x=b*t*s+S*G*D,B._y=S*G*s-b*t*D,B._z=b*G*D-S*t*s,B._w=b*G*s+S*t*D,B._isDirty=!0,B}static RotationAlphaBetaGamma(u,R,I){const B=new z;return z.RotationAlphaBetaGammaToRef(u,R,I,B),B}static RotationAlphaBetaGammaToRef(u,R,I,B){const U=.5*(I+u),K=.5*(I-u),C=.5*R;return B._x=Math.cos(K)*Math.sin(C),B._y=Math.sin(K)*Math.sin(C),B._z=Math.sin(U)*Math.cos(C),B._w=Math.cos(U)*Math.cos(C),B._isDirty=!0,B}static RotationQuaternionFromAxis(u,R,I){const B=new z(0,0,0,0);return z.RotationQuaternionFromAxisToRef(u,R,I,B),B}static RotationQuaternionFromAxisToRef(u,R,I,B){const U=T.Matrix[0];return u=u.normalizeToRef(T.PR[0]),R=R.normalizeToRef(T.PR[1]),I=I.normalizeToRef(T.PR[2]),f.FromXYZAxesToRef(u,R,I,U),z.FromRotationMatrixToRef(U,B),B}static FromLookDirectionLH(u,R){const I=new z;return z.FromLookDirectionLHToRef(u,R,I),I}static FromLookDirectionLHToRef(u,R,I){const B=T.Matrix[0];return f.LookDirectionLHToRef(u,R,B),z.FromRotationMatrixToRef(B,I),I}static FromLookDirectionRH(u,R){const I=new z;return z.FromLookDirectionRHToRef(u,R,I),I}static FromLookDirectionRHToRef(u,R,I){const B=T.Matrix[0];return f.LookDirectionRHToRef(u,R,B),z.FromRotationMatrixToRef(B,I)}static Slerp(u,R,I){const B=z.Identity();return z.SlerpToRef(u,R,I,B),B}static SlerpToRef(u,R,I,B){let U,K,C=u._x*R._x+u._y*R._y+u._z*R._z+u._w*R._w,D=!1;if(C<0&&(D=!0,C=-C),C>.999999)K=1-I,U=D?-I:I;else{const u=Math.acos(C),R=1/Math.sin(u);K=Math.sin((1-I)*u)*R,U=D?-Math.sin(I*u)*R:Math.sin(I*u)*R}return B._x=K*u._x+U*R._x,B._y=K*u._y+U*R._y,B._z=K*u._z+U*R._z,B._w=K*u._w+U*R._w,B._isDirty=!0,B}static Hermite(u,R,I,B,U){const K=U*U,C=U*K,D=2*C-3*K+1,s=-2*C+3*K,t=C-2*K+U,G=C-K,S=u._x*D+I._x*s+R._x*t+B._x*G,b=u._y*D+I._y*s+R._y*t+B._y*G,r=u._z*D+I._z*s+R._z*t+B._z*G,P=u._w*D+I._w*s+R._w*t+B._w*G;return new z(S,b,r,P)}static Hermite1stDerivative(u,R,I,B,U){const K=new z;return this.Hermite1stDerivativeToRef(u,R,I,B,U,K),K}static Hermite1stDerivativeToRef(u,R,I,B,U,K){const C=U*U;return K._x=6*(C-U)*u._x+(3*C-4*U+1)*R._x+6*(-C+U)*I._x+(3*C-2*U)*B._x,K._y=6*(C-U)*u._y+(3*C-4*U+1)*R._y+6*(-C+U)*I._y+(3*C-2*U)*B._y,K._z=6*(C-U)*u._z+(3*C-4*U+1)*R._z+6*(-C+U)*I._z+(3*C-2*U)*B._z,K._w=6*(C-U)*u._w+(3*C-4*U+1)*R._w+6*(-C+U)*I._w+(3*C-2*U)*B._w,K._isDirty=!0,K}static Normalize(u){const R=z.Zero();return z.NormalizeToRef(u,R),R}static NormalizeToRef(u,R){return u.normalizeToRef(R),R}static Clamp(u,R,I){const B=new z;return z.ClampToRef(u,R,I,B),B}static ClampToRef(u,R,I,B){return B.ED((0,s.Clamp)(u.x,R.x,I.x),(0,s.Clamp)(u.y,R.y,I.y),(0,s.Clamp)(u.z,R.z,I.z),(0,s.Clamp)(u.w,R.w,I.w))}static Random(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new z((0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R))}static RandomToRef(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).ED((0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R),(0,s.RandomRange)(u,R))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(u,R){return Math.sqrt(z.DistanceSquared(u,R))}static DistanceSquared(u,R){const I=u.x-R.x,B=u.y-R.y,U=u.z-R.z,K=u.w-R.w;return I*I+B*B+U*U+K*K}static Center(u,R){return z.CenterToRef(u,R,z.Zero())}static CenterToRef(u,R,I){return I.ED((u.x+R.x)/2,(u.y+R.y)/2,(u.z+R.z)/2,(u.w+R.w)/2)}}z._V8PerformanceHack=new z(.5,.5,.5,.5),Object.defineProperties(z.prototype,{dimension:{value:[4]},rank:{value:1}});class f{static get Use64Bits(){return C.c.MatrixUse64Bits}get m(){return this.ID}markAsUpdated(){this.updateFlag=t._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(u){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1],I=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=u,this._isIdentity3x2=u||I,this._isIdentityDirty=!this._isIdentity&&R,this._isIdentity3x2Dirty=!this._isIdentity3x2&&B}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,C.c.MatrixTrackPrecisionChange&&C.c.MatrixTrackedMatrices.push(this),this.ID=new C.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const u=this.ID;this._isIdentity=1===u[0]&&0===u[1]&&0===u[2]&&0===u[3]&&0===u[4]&&1===u[5]&&0===u[6]&&0===u[7]&&0===u[8]&&0===u[9]&&1===u[10]&&0===u[11]&&0===u[12]&&0===u[13]&&0===u[14]&&1===u[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ID[0]||1!==this.ID[5]||1!==this.ID[15]||0!==this.ID[1]||0!==this.ID[2]||0!==this.ID[3]||0!==this.ID[4]||0!==this.ID[6]||0!==this.ID[7]||0!==this.ID[8]||0!==this.ID[9]||0!==this.ID[10]||0!==this.ID[11]||0!==this.ID[12]||0!==this.ID[13]||0!==this.ID[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const u=this.ID,R=u[0],I=u[1],B=u[2],U=u[3],K=u[4],C=u[5],D=u[6],s=u[7],t=u[8],G=u[9],S=u[10],b=u[11],r=u[12],P=u[13],X=u[14],E=u[15],z=S*E-X*b,f=G*E-P*b,T=G*X-P*S,Q=t*E-r*b,V=t*X-S*r,q=t*P-r*G;return R*+(C*z-D*f+s*T)+I*-(K*z-D*Q+s*V)+B*+(K*f-C*Q+s*q)+U*-(K*T-C*V+D*q)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!u)return this.ID;const I=this.ID;for(let B=0;B<16;B++)u[R+B]=I[B];return this}sD(){return this.ID}bI(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f.FromArrayToRef(u,R,this)}ED(){for(var u=arguments.length,R=new Array(u),I=0;I<u;I++)R[I]=arguments[I];return f.FromArrayToRef(R,0,this)}set(){const u=this.ID;for(let R=0;R<16;R++)u[R]=R<0||arguments.length<=R?void 0:arguments[R];return this.markAsUpdated(),this}fD(u){const R=this.ID;for(let I=0;I<16;I++)R[I]=u;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return f.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(u){const R=new f;return this.addToRef(u,R),R}addToRef(u,R){const I=this.ID,B=R.ID,U=u.m;for(let K=0;K<16;K++)B[K]=I[K]+U[K];return R.markAsUpdated(),R}addToSelf(u){const R=this.ID,I=u.m;return R[0]+=I[0],R[1]+=I[1],R[2]+=I[2],R[3]+=I[3],R[4]+=I[4],R[5]+=I[5],R[6]+=I[6],R[7]+=I[7],R[8]+=I[8],R[9]+=I[9],R[10]+=I[10],R[11]+=I[11],R[12]+=I[12],R[13]+=I[13],R[14]+=I[14],R[15]+=I[15],this.markAsUpdated(),this}addInPlace(u){const R=this.ID,I=u.m;for(let B=0;B<16;B++)R[B]+=I[B];return this.markAsUpdated(),this}addInPlaceFromFloats(){const u=this.ID;for(let R=0;R<16;R++)u[R]+=R<0||arguments.length<=R?void 0:arguments[R];return this.markAsUpdated(),this}XR(u){const R=this.ID,I=u.m;for(let B=0;B<16;B++)R[B]-=I[B];return this.markAsUpdated(),this}subtractToRef(u,R){const I=this.ID,B=u.m,U=R.ID;for(let K=0;K<16;K++)U[K]=I[K]-B[K];return R.markAsUpdated(),R}RS(u){const R=this.ID,I=u.m;for(let B=0;B<16;B++)R[B]-=I[B];return this.markAsUpdated(),this}subtractFromFloats(){for(var u=arguments.length,R=new Array(u),I=0;I<u;I++)R[I]=arguments[I];return this.subtractFromFloatsToRef(...R,new f)}subtractFromFloatsToRef(){for(var u=arguments.length,R=new Array(u),I=0;I<u;I++)R[I]=arguments[I];const B=R.pop(),U=this.ID,K=B.ID,C=R;for(let D=0;D<16;D++)K[D]=U[D]-C[D];return B.markAsUpdated(),B}invertToRef(u){return!0===this._isIdentity?(f.IdentityToRef(u),u):(b(this,u.sD())?u.markAsUpdated():u.B(this),u)}addAtIndex(u,R){return this.ID[u]+=R,this.markAsUpdated(),this}multiplyAtIndex(u,R){return this.ID[u]*=R,this.markAsUpdated(),this}setTranslationFromFloats(u,R,I){return this.ID[12]=u,this.ID[13]=R,this.ID[14]=I,this.markAsUpdated(),this}addTranslationFromFloats(u,R,I){return this.ID[12]+=u,this.ID[13]+=R,this.ID[14]+=I,this.markAsUpdated(),this}setTranslation(u){return this.setTranslationFromFloats(u._x,u._y,u._z)}getTranslation(){return new X(this.ID[12],this.ID[13],this.ID[14])}getTranslationToRef(u){return u.x=this.ID[12],u.y=this.ID[13],u.z=this.ID[14],u}removeRotationAndScaling(){const u=this.m;return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,u[12],u[13],u[14],u[15],this),this._updateIdentityStatus(0===u[12]&&0===u[13]&&0===u[14]&&1===u[15]),this}B(u){u.copyToArray(this.ID);const R=u;return this.updateFlag=R.updateFlag,this._updateIdentityStatus(R._isIdentity,R._isIdentityDirty,R._isIdentity3x2,R._isIdentity3x2Dirty),this}copyToArray(u){return S(this,u,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(u){const R=new f;return this.multiplyToRef(u,R),R}multiplyInPlace(u){const R=this.ID,I=u.m;for(let B=0;B<16;B++)R[B]*=I[B];return this.markAsUpdated(),this}multiplyByFloats(){const u=this.ID;for(let R=0;R<16;R++)u[R]*=R<0||arguments.length<=R?void 0:arguments[R];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var u=arguments.length,R=new Array(u),I=0;I<u;I++)R[I]=arguments[I];const B=R.pop(),U=this.ID,K=B.ID,C=R;for(let D=0;D<16;D++)K[D]=U[D]*C[D];return B.markAsUpdated(),B}multiplyToRef(u,R){return this._isIdentity?(R.B(u),R):u._isIdentity?(R.B(this),R):(this.multiplyToArray(u,R.ID,0),R.markAsUpdated(),R)}multiplyToArray(u,R,I){return G(this,u,R,I),this}divide(u){return this.divideToRef(u,new f)}divideToRef(u,R){const I=this.ID,B=u.m,U=R.ID;for(let K=0;K<16;K++)U[K]=I[K]/B[K];return R.markAsUpdated(),R}divideInPlace(u){const R=this.ID,I=u.m;for(let B=0;B<16;B++)R[B]/=I[B];return this.markAsUpdated(),this}minimizeInPlace(u){const R=this.ID,I=u.m;for(let B=0;B<16;B++)R[B]=Math.min(R[B],I[B]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const u=this.ID;for(let R=0;R<16;R++)u[R]=Math.min(u[R],R<0||arguments.length<=R?void 0:arguments[R]);return this.markAsUpdated(),this}maximizeInPlace(u){const R=this.ID,I=u.m;for(let B=0;B<16;B++)R[B]=Math.min(R[B],I[B]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const u=this.ID;for(let R=0;R<16;R++)u[R]=Math.min(u[R],R<0||arguments.length<=R?void 0:arguments[R]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new f)}negateInPlace(){const u=this.ID;for(let R=0;R<16;R++)u[R]=-u[R];return this.markAsUpdated(),this}negateToRef(u){const R=this.ID,I=u.ID;for(let B=0;B<16;B++)I[B]=-R[B];return u.markAsUpdated(),u}equals(u){const R=u;if(!R)return!1;if((this._isIdentity||R._isIdentity)&&!this._isIdentityDirty&&!R._isIdentityDirty)return this._isIdentity&&R._isIdentity;const I=this.m,B=R.m;return I[0]===B[0]&&I[1]===B[1]&&I[2]===B[2]&&I[3]===B[3]&&I[4]===B[4]&&I[5]===B[5]&&I[6]===B[6]&&I[7]===B[7]&&I[8]===B[8]&&I[9]===B[9]&&I[10]===B[10]&&I[11]===B[11]&&I[12]===B[12]&&I[13]===B[13]&&I[14]===B[14]&&I[15]===B[15]}equalsWithEpsilon(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const I=this.ID,B=u.m;for(let U=0;U<16;U++)if(!(0,s.WithinEpsilon)(I[U],B[U],R))return!1;return!0}equalsToFloats(){const u=this.ID;for(let R=0;R<16;R++)if(u[R]!=(R<0||arguments.length<=R?void 0:arguments[R]))return!1;return!0}floor(){return this.floorToRef(new f)}floorToRef(u){const R=this.ID,I=u.ID;for(let B=0;B<16;B++)I[B]=Math.floor(R[B]);return u.markAsUpdated(),u}fract(){return this.fractToRef(new f)}fractToRef(u){const R=this.ID,I=u.ID;for(let B=0;B<16;B++)I[B]=R[B]-Math.floor(R[B]);return u.markAsUpdated(),u}clone(){const u=new f;return u.B(this),u}getClassName(){return"Matrix"}getHashCode(){let u=r(this.ID[0]);for(let R=1;R<16;R++)u=397*u^r(this.ID[R]);return u}decomposeToTransformNode(u){return u.rotationQuaternion=u.rotationQuaternion||new z,this.decompose(u.zD,u.rotationQuaternion,u.position)}decompose(u,R,I,B){let U=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return I&&I.fD(0),u&&u.fD(1),R&&R.ED(0,0,0,1),!0;const K=this.ID;if(I&&I.ED(K[12],K[13],K[14]),(u=u||T.PR[0]).x=Math.sqrt(K[0]*K[0]+K[1]*K[1]+K[2]*K[2]),u.y=Math.sqrt(K[4]*K[4]+K[5]*K[5]+K[6]*K[6]),u.z=Math.sqrt(K[8]*K[8]+K[9]*K[9]+K[10]*K[10]),B){const R=(U?B.absoluteScaling.x:B.zD.x)<0?-1:1,I=(U?B.absoluteScaling.y:B.zD.y)<0?-1:1,K=(U?B.absoluteScaling.z:B.zD.z)<0?-1:1;u.x*=R,u.y*=I,u.z*=K}else this.determinant()<=0&&(u.y*=-1);if(0===u._x||0===u._y||0===u._z)return R&&R.ED(0,0,0,1),!1;if(R){const I=1/u._x,B=1/u._y,U=1/u._z;f.FromValuesToRef(K[0]*I,K[1]*I,K[2]*I,0,K[4]*B,K[5]*B,K[6]*B,0,K[8]*U,K[9]*U,K[10]*U,0,0,0,0,1,T.Matrix[0]),z.FromRotationMatrixToRef(T.Matrix[0],R)}return!0}getRow(u){if(u<0||u>3)return null;const R=4*u;return new E(this.ID[R+0],this.ID[R+1],this.ID[R+2],this.ID[R+3])}getRowToRef(u,R){if(u>=0&&u<=3){const I=4*u;R.x=this.ID[I+0],R.y=this.ID[I+1],R.z=this.ID[I+2],R.w=this.ID[I+3]}return R}setRow(u,R){return this.setRowFromFloats(u,R.x,R.y,R.z,R.w)}transpose(){const u=new f;return f.TransposeToRef(this,u),u}transposeToRef(u){return f.TransposeToRef(this,u),u}setRowFromFloats(u,R,I,B,U){if(u<0||u>3)return this;const K=4*u;return this.ID[K+0]=R,this.ID[K+1]=I,this.ID[K+2]=B,this.ID[K+3]=U,this.markAsUpdated(),this}scale(u){const R=new f;return this.scaleToRef(u,R),R}scaleToRef(u,R){for(let I=0;I<16;I++)R.ID[I]=this.ID[I]*u;return R.markAsUpdated(),R}scaleAndAddToRef(u,R){for(let I=0;I<16;I++)R.ID[I]+=this.ID[I]*u;return R.markAsUpdated(),R}scaleInPlace(u){const R=this.ID;for(let I=0;I<16;I++)R[I]*=u;return this.markAsUpdated(),this}toNormalMatrix(u){const R=T.Matrix[0];this.invertToRef(R),R.transposeToRef(u);const I=u.ID;return f.FromValuesToRef(I[0],I[1],I[2],0,I[4],I[5],I[6],0,I[8],I[9],I[10],0,0,0,0,1,u),u}getRotationMatrix(){const u=new f;return this.getRotationMatrixToRef(u),u}getRotationMatrixToRef(u){const R=T.PR[0];if(!this.decompose(R))return f.IdentityToRef(u),u;const I=this.ID,B=1/R._x,U=1/R._y,K=1/R._z;return f.FromValuesToRef(I[0]*B,I[1]*B,I[2]*B,0,I[4]*U,I[5]*U,I[6]*U,0,I[8]*K,I[9]*K,I[10]*K,0,0,0,0,1,u),u}toggleModelMatrixHandInPlace(){const u=this.ID;return u[2]*=-1,u[6]*=-1,u[8]*=-1,u[9]*=-1,u[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const u=this.ID;return u[8]*=-1,u[9]*=-1,u[10]*=-1,u[11]*=-1,this.markAsUpdated(),this}static TR(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const I=new f;return f.FromArrayToRef(u,R,I),I}static FromArrayToRef(u,R,I){for(let B=0;B<16;B++)I.ID[B]=u[B+R];return I.markAsUpdated(),I}static FromFloat32ArrayToRefScaled(u,R,I,B){return B.ID[0]=u[0+R]*I,B.ID[1]=u[1+R]*I,B.ID[2]=u[2+R]*I,B.ID[3]=u[3+R]*I,B.ID[4]=u[4+R]*I,B.ID[5]=u[5+R]*I,B.ID[6]=u[6+R]*I,B.ID[7]=u[7+R]*I,B.ID[8]=u[8+R]*I,B.ID[9]=u[9+R]*I,B.ID[10]=u[10+R]*I,B.ID[11]=u[11+R]*I,B.ID[12]=u[12+R]*I,B.ID[13]=u[13+R]*I,B.ID[14]=u[14+R]*I,B.ID[15]=u[15+R]*I,B.markAsUpdated(),B}static get IdentityReadOnly(){return f._IdentityReadOnly}static FromValuesToRef(u,R,I,B,U,K,C,D,s,t,G,S,b,r,P,X,E){const z=E.ID;z[0]=u,z[1]=R,z[2]=I,z[3]=B,z[4]=U,z[5]=K,z[6]=C,z[7]=D,z[8]=s,z[9]=t,z[10]=G,z[11]=S,z[12]=b,z[13]=r,z[14]=P,z[15]=X,E.markAsUpdated()}static FromValues(u,R,I,B,U,K,C,D,s,t,G,S,b,r,P,X){const E=new f,z=E.ID;return z[0]=u,z[1]=R,z[2]=I,z[3]=B,z[4]=U,z[5]=K,z[6]=C,z[7]=D,z[8]=s,z[9]=t,z[10]=G,z[11]=S,z[12]=b,z[13]=r,z[14]=P,z[15]=X,E.markAsUpdated(),E}static Compose(u,R,I){const B=new f;return f.ComposeToRef(u,R,I,B),B}static ComposeToRef(u,R,I,B){const U=B.ID,K=R._x,C=R._y,D=R._z,s=R._w,t=K+K,G=C+C,S=D+D,b=K*t,r=K*G,P=K*S,X=C*G,E=C*S,z=D*S,f=s*t,T=s*G,Q=s*S,V=u._x,q=u._y,e=u._z;return U[0]=(1-(X+z))*V,U[1]=(r+Q)*V,U[2]=(P-T)*V,U[3]=0,U[4]=(r-Q)*q,U[5]=(1-(b+z))*q,U[6]=(E+f)*q,U[7]=0,U[8]=(P+T)*e,U[9]=(E-f)*e,U[10]=(1-(b+X))*e,U[11]=0,U[12]=I._x,U[13]=I._y,U[14]=I._z,U[15]=1,B.markAsUpdated(),B}static Identity(){const u=f.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return u._updateIdentityStatus(!0),u}static IdentityToRef(u){return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,u),u._updateIdentityStatus(!0),u}static Zero(){const u=f.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return u._updateIdentityStatus(!1),u}static RotationX(u){const R=new f;return f.RotationXToRef(u,R),R}static Invert(u){const R=new f;return u.invertToRef(R),R}static RotationXToRef(u,R){const I=Math.sin(u),B=Math.cos(u);return f.FromValuesToRef(1,0,0,0,0,B,I,0,0,-I,B,0,0,0,0,1,R),R._updateIdentityStatus(1===B&&0===I),R}static RotationY(u){const R=new f;return f.RotationYToRef(u,R),R}static RotationYToRef(u,R){const I=Math.sin(u),B=Math.cos(u);return f.FromValuesToRef(B,0,-I,0,0,1,0,0,I,0,B,0,0,0,0,1,R),R._updateIdentityStatus(1===B&&0===I),R}static RotationZ(u){const R=new f;return f.RotationZToRef(u,R),R}static RotationZToRef(u,R){const I=Math.sin(u),B=Math.cos(u);return f.FromValuesToRef(B,I,0,0,-I,B,0,0,0,0,1,0,0,0,0,1,R),R._updateIdentityStatus(1===B&&0===I),R}static RotationAxis(u,R){const I=new f;return f.RotationAxisToRef(u,R,I),I}static RotationAxisToRef(u,R,I){const B=Math.sin(-R),U=Math.cos(-R),K=1-U;u=u.normalizeToRef(T.PR[0]);const C=I.ID;return C[0]=u._x*u._x*K+U,C[1]=u._x*u._y*K-u._z*B,C[2]=u._x*u._z*K+u._y*B,C[3]=0,C[4]=u._y*u._x*K+u._z*B,C[5]=u._y*u._y*K+U,C[6]=u._y*u._z*K-u._x*B,C[7]=0,C[8]=u._z*u._x*K-u._y*B,C[9]=u._z*u._y*K+u._x*B,C[10]=u._z*u._z*K+U,C[11]=0,C[12]=0,C[13]=0,C[14]=0,C[15]=1,I.markAsUpdated(),I}static RotationAlignToRef(u,R,I){let U=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const K=X.Dot(R,u),C=I.ID;if(K<-1+B.c)C[0]=-1,C[1]=0,C[2]=0,C[3]=0,C[4]=0,C[5]=U?1:-1,C[6]=0,C[7]=0,C[8]=0,C[9]=0,C[10]=U?-1:1,C[11]=0;else{const I=X.Cross(R,u),B=1/(1+K);C[0]=I._x*I._x*B+K,C[1]=I._y*I._x*B-I._z,C[2]=I._z*I._x*B+I._y,C[3]=0,C[4]=I._x*I._y*B+I._z,C[5]=I._y*I._y*B+K,C[6]=I._z*I._y*B-I._x,C[7]=0,C[8]=I._x*I._z*B-I._y,C[9]=I._y*I._z*B+I._x,C[10]=I._z*I._z*B+K,C[11]=0}return C[12]=0,C[13]=0,C[14]=0,C[15]=1,I.markAsUpdated(),I}static RotationYawPitchRoll(u,R,I){const B=new f;return f.RotationYawPitchRollToRef(u,R,I,B),B}static RotationYawPitchRollToRef(u,R,I,B){return z.RotationYawPitchRollToRef(u,R,I,T.Quaternion[0]),T.Quaternion[0].toRotationMatrix(B),B}static Scaling(u,R,I){const B=new f;return f.ScalingToRef(u,R,I,B),B}static ScalingToRef(u,R,I,B){return f.FromValuesToRef(u,0,0,0,0,R,0,0,0,0,I,0,0,0,0,1,B),B._updateIdentityStatus(1===u&&1===R&&1===I),B}static Translation(u,R,I){const B=new f;return f.TranslationToRef(u,R,I,B),B}static TranslationToRef(u,R,I,B){return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,u,R,I,1,B),B._updateIdentityStatus(0===u&&0===R&&0===I),B}static Lerp(u,R,I){const B=new f;return f.LerpToRef(u,R,I,B),B}static LerpToRef(u,R,I,B){const U=B.ID,K=u.m,C=R.m;for(let D=0;D<16;D++)U[D]=K[D]*(1-I)+C[D]*I;return B.markAsUpdated(),B}static DecomposeLerp(u,R,I){const B=new f;return f.DecomposeLerpToRef(u,R,I,B),B}static DecomposeLerpToRef(u,R,I,B){const U=T.PR[0],K=T.Quaternion[0],C=T.PR[1];u.decompose(U,K,C);const D=T.PR[2],s=T.Quaternion[1],t=T.PR[3];R.decompose(D,s,t);const G=T.PR[4];X.LerpToRef(U,D,I,G);const S=T.Quaternion[2];z.SlerpToRef(K,s,I,S);const b=T.PR[5];return X.LerpToRef(C,t,I,b),f.ComposeToRef(G,S,b,B),B}static LookAtLH(u,R,I){const B=new f;return f.LookAtLHToRef(u,R,I,B),B}static LookAtLHToRef(u,R,I,B){const U=T.PR[0],K=T.PR[1],C=T.PR[2];R.subtractToRef(u,C),C.normalize(),X.CrossToRef(I,C,U);const D=U.lengthSquared();0===D?U.x=1:U.normalizeFromLength(Math.sqrt(D)),X.CrossToRef(C,U,K),K.normalize();const s=-X.Dot(U,u),t=-X.Dot(K,u),G=-X.Dot(C,u);return f.FromValuesToRef(U._x,K._x,C._x,0,U._y,K._y,C._y,0,U._z,K._z,C._z,0,s,t,G,1,B),B}static LookAtRH(u,R,I){const B=new f;return f.LookAtRHToRef(u,R,I,B),B}static LookAtRHToRef(u,R,I,B){const U=T.PR[0],K=T.PR[1],C=T.PR[2];u.subtractToRef(R,C),C.normalize(),X.CrossToRef(I,C,U);const D=U.lengthSquared();0===D?U.x=1:U.normalizeFromLength(Math.sqrt(D)),X.CrossToRef(C,U,K),K.normalize();const s=-X.Dot(U,u),t=-X.Dot(K,u),G=-X.Dot(C,u);return f.FromValuesToRef(U._x,K._x,C._x,0,U._y,K._y,C._y,0,U._z,K._z,C._z,0,s,t,G,1,B),B}static LookDirectionLH(u,R){const I=new f;return f.LookDirectionLHToRef(u,R,I),I}static LookDirectionLHToRef(u,R,I){const B=T.PR[0];B.B(u),B.scaleInPlace(-1);const U=T.PR[1];return X.CrossToRef(R,B,U),f.FromValuesToRef(U._x,U._y,U._z,0,R._x,R._y,R._z,0,B._x,B._y,B._z,0,0,0,0,1,I),I}static LookDirectionRH(u,R){const I=new f;return f.LookDirectionRHToRef(u,R,I),I}static LookDirectionRHToRef(u,R,I){const B=T.PR[2];return X.CrossToRef(R,u,B),f.FromValuesToRef(B._x,B._y,B._z,0,R._x,R._y,R._z,0,u._x,u._y,u._z,0,0,0,0,1,I),I}static OrthoLH(u,R,I,B,U){const K=new f;return f.OrthoLHToRef(u,R,I,B,K,U),K}static OrthoLHToRef(u,R,I,B,U,K){const C=2/u,D=2/R,s=2/(B-I),t=-(B+I)/(B-I);return f.FromValuesToRef(C,0,0,0,0,D,0,0,0,0,s,0,0,0,t,1,U),K&&U.multiplyToRef(V,U),U._updateIdentityStatus(1===C&&1===D&&1===s&&0===t),U}static OrthoOffCenterLH(u,R,I,B,U,K,C){const D=new f;return f.OrthoOffCenterLHToRef(u,R,I,B,U,K,D,C),D}static OrthoOffCenterLHToRef(u,R,I,B,U,K,C,D){const s=2/(R-u),t=2/(B-I),G=2/(K-U),S=-(K+U)/(K-U),b=(u+R)/(u-R),r=(B+I)/(I-B);return f.FromValuesToRef(s,0,0,0,0,t,0,0,0,0,G,0,b,r,S,1,C),D&&C.multiplyToRef(V,C),C.markAsUpdated(),C}static ObliqueOffCenterLHToRef(u,R,I,B,U,K,C,D,s,t,G){const S=-C*Math.cos(D),b=-C*Math.sin(D);return f.TranslationToRef(0,0,-s,T.Matrix[1]),f.FromValuesToRef(1,0,0,0,0,1,0,0,S,b,1,0,0,0,0,1,T.Matrix[0]),T.Matrix[1].multiplyToRef(T.Matrix[0],T.Matrix[0]),f.TranslationToRef(0,0,s,T.Matrix[1]),T.Matrix[0].multiplyToRef(T.Matrix[1],T.Matrix[0]),f.OrthoOffCenterLHToRef(u,R,I,B,U,K,t,G),T.Matrix[0].multiplyToRef(t,t),t}static OrthoOffCenterRH(u,R,I,B,U,K,C){const D=new f;return f.OrthoOffCenterRHToRef(u,R,I,B,U,K,D,C),D}static OrthoOffCenterRHToRef(u,R,I,B,U,K,C,D){return f.OrthoOffCenterLHToRef(u,R,I,B,U,K,C,D),C.ID[10]*=-1,C}static ObliqueOffCenterRHToRef(u,R,I,B,U,K,C,D,s,t,G){const S=C*Math.cos(D),b=C*Math.sin(D);return f.TranslationToRef(0,0,s,T.Matrix[1]),f.FromValuesToRef(1,0,0,0,0,1,0,0,S,b,1,0,0,0,0,1,T.Matrix[0]),T.Matrix[1].multiplyToRef(T.Matrix[0],T.Matrix[0]),f.TranslationToRef(0,0,-s,T.Matrix[1]),T.Matrix[0].multiplyToRef(T.Matrix[1],T.Matrix[0]),f.OrthoOffCenterRHToRef(u,R,I,B,U,K,t,G),T.Matrix[0].multiplyToRef(t,t),t}static PerspectiveLH(u,R,I,B,U){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const C=new f,D=2*I/u,s=2*I/R,t=(B+I)/(B-I),G=-2*B*I/(B-I),S=Math.tan(K);return f.FromValuesToRef(D,0,0,0,0,s,0,S,0,0,t,1,0,0,G,0,C),U&&C.multiplyToRef(V,C),C._updateIdentityStatus(!1),C}static PerspectiveFovLH(u,R,I,B,U){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,C=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const D=new f;return f.PerspectiveFovLHToRef(u,R,I,B,D,!0,U,K,C),D}static PerspectiveFovLHToRef(u,R,I,B,U){let K=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],C=arguments.length>6?arguments[6]:void 0,D=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,s=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const t=I,G=B,S=1/Math.tan(.5*u),b=K?S/R:S,r=K?S:S*R,P=s&&0===t?-1:0!==G?(G+t)/(G-t):1,X=s&&0===t?2*G:0!==G?-2*G*t/(G-t):-2*t,E=Math.tan(D);return f.FromValuesToRef(b,0,0,0,0,r,0,E,0,0,P,1,0,0,X,0,U),C&&U.multiplyToRef(V,U),U._updateIdentityStatus(!1),U}static PerspectiveFovReverseLHToRef(u,R,I,B,U){let K=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],C=arguments.length>6?arguments[6]:void 0,D=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const s=1/Math.tan(.5*u),t=K?s/R:s,G=K?s:s*R,S=Math.tan(D);return f.FromValuesToRef(t,0,0,0,0,G,0,S,0,0,-I,1,0,0,1,0,U),C&&U.multiplyToRef(V,U),U._updateIdentityStatus(!1),U}static PerspectiveFovRH(u,R,I,B,U){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,C=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const D=new f;return f.PerspectiveFovRHToRef(u,R,I,B,D,!0,U,K,C),D}static PerspectiveFovRHToRef(u,R,I,B,U){let K=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],C=arguments.length>6?arguments[6]:void 0,D=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,s=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const t=I,G=B,S=1/Math.tan(.5*u),b=K?S/R:S,r=K?S:S*R,P=s&&0===t?1:0!==G?-(G+t)/(G-t):-1,X=s&&0===t?2*G:0!==G?-2*G*t/(G-t):-2*t,E=Math.tan(D);return f.FromValuesToRef(b,0,0,0,0,r,0,E,0,0,P,-1,0,0,X,0,U),C&&U.multiplyToRef(V,U),U._updateIdentityStatus(!1),U}static PerspectiveFovReverseRHToRef(u,R,I,B,U){let K=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],C=arguments.length>6?arguments[6]:void 0,D=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const s=1/Math.tan(.5*u),t=K?s/R:s,G=K?s:s*R,S=Math.tan(D);return f.FromValuesToRef(t,0,0,0,0,G,0,S,0,0,-I,-1,0,0,-1,0,U),C&&U.multiplyToRef(V,U),U._updateIdentityStatus(!1),U}static GetFinalMatrix(u,R,I,B,U,K){const C=u.width,D=u.height,s=u.x,t=u.y,G=f.FromValues(C/2,0,0,0,0,-D/2,0,0,0,0,K-U,0,s+C/2,D/2+t,U,1),S=new f;return R.multiplyToRef(I,S),S.multiplyToRef(B,S),S.multiplyToRef(G,S)}static GetAsMatrix2x2(u){const R=u.m,I=[R[0],R[1],R[4],R[5]];return C.c.MatrixUse64Bits?I:new Float32Array(I)}static GetAsMatrix3x3(u){const R=u.m,I=[R[0],R[1],R[2],R[4],R[5],R[6],R[8],R[9],R[10]];return C.c.MatrixUse64Bits?I:new Float32Array(I)}static Transpose(u){const R=new f;return f.TransposeToRef(u,R),R}static TransposeToRef(u,R){const I=u.m,B=I[0],U=I[4],K=I[8],C=I[12],D=I[1],s=I[5],t=I[9],G=I[13],S=I[2],b=I[6],r=I[10],P=I[14],X=I[3],E=I[7],z=I[11],f=I[15],T=R.ID;return T[0]=B,T[1]=U,T[2]=K,T[3]=C,T[4]=D,T[5]=s,T[6]=t,T[7]=G,T[8]=S,T[9]=b,T[10]=r,T[11]=P,T[12]=X,T[13]=E,T[14]=z,T[15]=f,R.markAsUpdated(),R._updateIdentityStatus(u._isIdentity,u._isIdentityDirty),R}static Reflection(u){const R=new f;return f.ReflectionToRef(u,R),R}static ReflectionToRef(u,R){u.normalize();const I=u.normal.x,B=u.normal.y,U=u.normal.z,K=-2*I,C=-2*B,D=-2*U;return f.FromValuesToRef(K*I+1,C*I,D*I,0,K*B,C*B+1,D*B,0,K*U,C*U,D*U+1,0,K*u.d,C*u.d,D*u.d,1,R),R}static FromXYZAxesToRef(u,R,I,B){return f.FromValuesToRef(u._x,u._y,u._z,0,R._x,R._y,R._z,0,I._x,I._y,I._z,0,0,0,0,1,B),B}static FromQuaternionToRef(u,R){const I=u._x*u._x,B=u._y*u._y,U=u._z*u._z,K=u._x*u._y,C=u._z*u._w,D=u._z*u._x,s=u._y*u._w,t=u._y*u._z,G=u._x*u._w;return R.ID[0]=1-2*(B+U),R.ID[1]=2*(K+C),R.ID[2]=2*(D-s),R.ID[3]=0,R.ID[4]=2*(K-C),R.ID[5]=1-2*(U+I),R.ID[6]=2*(t+G),R.ID[7]=0,R.ID[8]=2*(D+s),R.ID[9]=2*(t-G),R.ID[10]=1-2*(B+I),R.ID[11]=0,R.ID[12]=0,R.ID[13]=0,R.ID[14]=0,R.ID[15]=1,R.markAsUpdated(),R}}f._IdentityReadOnly=f.Identity(),Object.defineProperties(f.prototype,{dimension:{value:[4,4]},rank:{value:2}});class T{}T.PR=(0,U.f)(11,X.Zero),T.Matrix=(0,U.f)(2,f.Identity),T.Quaternion=(0,U.f)(3,z.Zero);class Q{}Q.Vector2=(0,U.f)(3,P.Zero),Q.PR=(0,U.f)(13,X.Zero),Q.Vector4=(0,U.f)(3,E.Zero),Q.Quaternion=(0,U.f)(3,z.Zero),Q.Matrix=(0,U.f)(8,f.Identity),(0,K.e)("BABYLON.Vector2",P),(0,K.e)("BABYLON.Vector3",X),(0,K.e)("BABYLON.Vector4",E),(0,K.e)("BABYLON.Matrix",f);const V=f.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12487:(u,R,I)=>{function B(u,R){const I=[];for(let B=0;B<u;++B)I.push(R());return I}function U(u,R){return B(u,R)}I.d(R,{d:()=>B,f:()=>U,i:()=>C});const K=["push","splice","pop","shift","unshift"];function C(u,R){const I=K.map((I=>function(u,R,I){const B=u[R];if("function"!==typeof B)return null;const U=function(){const B=u.length,K=U.previous.apply(u,arguments);return I(R,B),K};return B.next=U,U.previous=B,u[R]=U,()=>{const I=U.previous;if(!I)return;const B=U.next;B?(I.next=B,B.previous=I):(I.next=void 0,u[R]=I),U.next=void 0,U.previous=void 0}}(u,I,R)));return()=>{for(const u of I)null===u||void 0===u||u()}}}}]);