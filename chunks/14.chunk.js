"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{2513:(k,M,F)=>{F.r(M),F.d(M,{_ExrTextureLoader:()=>I});var l=F(487),t=F(698);const g=65536,B=14,G=65537,A=16384;var N,d;!function(k){k[k.NO_COMPRESSION=0]="NO_COMPRESSION",k[k.RLE_COMPRESSION=1]="RLE_COMPRESSION",k[k.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",k[k.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",k[k.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",k[k.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(N||(N={})),function(k){k[k.INCREASING_Y=0]="INCREASING_Y",k[k.DECREASING_Y=1]="DECREASING_Y"}(d||(d={}));const L=function(){const k=new ArrayBuffer(4),M=new Float32Array(k),F=new Uint32Array(k),l=new Uint32Array(512),t=new Uint32Array(512);for(let A=0;A<256;++A){const k=A-127;k<-27?(l[A]=0,l[256|A]=32768,t[A]=24,t[256|A]=24):k<-14?(l[A]=1024>>-k-14,l[256|A]=1024>>-k-14|32768,t[A]=-k-1,t[256|A]=-k-1):k<=15?(l[A]=k+15<<10,l[256|A]=k+15<<10|32768,t[A]=13,t[256|A]=13):k<128?(l[A]=31744,l[256|A]=64512,t[A]=24,t[256|A]=24):(l[A]=31744,l[256|A]=64512,t[A]=13,t[256|A]=13)}const g=new Uint32Array(2048),B=new Uint32Array(64),G=new Uint32Array(64);for(let A=1;A<1024;++A){let k=A<<13,M=0;for(;0===(8388608&k);)k<<=1,M-=8388608;k&=-8388609,M+=947912704,g[A]=k|M}for(let A=1024;A<2048;++A)g[A]=939524096+(A-1024<<13);for(let A=1;A<31;++A)B[A]=A<<23;B[31]=1199570944,B[32]=2147483648;for(let A=33;A<63;++A)B[A]=2147483648+(A-32<<23);B[63]=3347054592;for(let A=1;A<64;++A)32!==A&&(G[A]=1024);return{floatView:M,uint32View:F,baseTable:l,shiftTable:t,mantissaTable:g,exponentTable:B,offsetTable:G}}();function U(k,M){const F=new Uint8Array(k);let l=0;for(;0!=F[M.value+l];)l+=1;const t=(new TextDecoder).decode(F.slice(M.value,M.value+l));return M.value=M.value+l+1,t}function O(k,M){const F=k.getInt32(M.value,!0);return M.value+=4,F}function w(k,M){const F=k.getUint32(M.value,!0);return M.value+=4,F}function Z(k,M){const F=k.getUint8(M.value);return M.value+=1,F}function R(k,M){const F=k.getUint16(M.value,!0);return M.value+=2,F}function y(k,M){const F=k[M.value];return M.value+=1,F}function m(k,M){let F;return F="getBigInt64"in DataView.prototype?Number(k.getBigInt64(M.value,!0)):k.getUint32(M.value+4,!0)+Number(k.getUint32(M.value,!0)<<32),M.value+=8,F}function o(k,M){const F=k.getFloat32(M.value,!0);return M.value+=4,F}function Q(k,M){return function(k){const M=(31744&k)>>10,F=1023&k;return(k>>15?-1:1)*(M?31===M?F?NaN:1/0:Math.pow(2,M-15)*(1+F/1024):F/1024*6103515625e-14)}(R(k,M))}function v(k,M){return function(k){if(Math.abs(k)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");k=(0,t.e)(k,-65504,65504),L.floatView[0]=k;const M=L.uint32View[0],F=M>>23&511;return L.baseTable[F]+((8388607&M)>>L.shiftTable[F])}(o(k,M))}function J(k,M,F,l){switch(F){case"string":case"stringvector":case"iccProfile":return function(k,M,F){const l=(new TextDecoder).decode(new Uint8Array(k).slice(M.value,M.value+F));return M.value=M.value+F,l}(k.buffer,M,l);case"chlist":return function(k,M,F){const l=M.value,t=[];for(;M.value<l+F-1;){const F=U(k.buffer,M),l=O(k,M),g=Z(k,M);M.value+=3;const B=O(k,M),G=O(k,M);t.push({name:F,pixelType:l,pLinear:g,xSampling:B,ySampling:G})}return M.value+=1,t}(k,M,l);case"chromaticities":return function(k,M){return{redX:o(k,M),redY:o(k,M),greenX:o(k,M),greenY:o(k,M),blueX:o(k,M),blueY:o(k,M),whiteX:o(k,M),whiteY:o(k,M)}}(k,M);case"compression":return function(k,M){return Z(k,M)}(k,M);case"box2i":return function(k,M){return{xMin:O(k,M),yMin:O(k,M),xMax:O(k,M),yMax:O(k,M)}}(k,M);case"lineOrder":return function(k,M){const F=Z(k,M);return d[F]}(k,M);case"float":return o(k,M);case"v2f":return function(k,M){return[o(k,M),o(k,M)]}(k,M);case"v3f":return function(k,M){return[o(k,M),o(k,M),o(k,M)]}(k,M);case"int":return O(k,M);case"rational":return function(k,M){return[O(k,M),w(k,M)]}(k,M);case"timecode":return function(k,M){return[w(k,M),w(k,M)]}(k,M);case"preview":return M.value+=l,"skipped";default:return void(M.value+=l)}}function n(k){for(let M=1;M<k.length;M++){const F=k[M-1]+k[M]-128;k[M]=F}}function a(k,M){let F=0,l=Math.floor((k.length+1)/2),t=0;const g=k.length-1;for(;!(t>g)&&(M[t++]=k[F++],!(t>g));)M[t++]=k[l++]}function Y(k,M,F,l,t){for(;F<k;)M=M<<8|y(l,t),F+=8;return{l:M>>(F-=k)&(1<<k)-1,c:M,lc:F}}function s(k,M,F,l){return{c:k=k<<8|y(F,l),lc:M+=8}}function j(k,M,F,l,t,g,B,G,A){if(k==M){if(l<8){const k=s(F,l,t,g);F=k.c,l=k.lc}let k=F>>(l-=8);if(k=new Uint8Array([k])[0],G.value+k>A)return null;const M=B[G.value-1];for(;k-- >0;)B[G.value++]=M}else{if(!(G.value<A))return null;B[G.value++]=k}return{c:F,lc:l}}const S=new Array(59);function c(k,M,F,l,t,g){const B=M;let A=0,N=0;for(;l<=t;l++){if(B.value-M.value>F)return;let G=Y(6,A,N,k,B);const d=G.l;if(A=G.c,N=G.lc,g[l]=d,63==d){if(B.value-M.value>F)throw new Error("Error in HufUnpackEncTable");G=Y(8,A,N,k,B);let d=G.l+6;if(A=G.c,N=G.lc,l+d>t+1)throw new Error("Error in HufUnpackEncTable");for(;d--;)g[l++]=0;l--}else if(d>=59){let k=d-59+2;if(l+k>t+1)throw new Error("Error in HufUnpackEncTable");for(;k--;)g[l++]=0;l--}}!function(k){for(let F=0;F<=58;++F)S[F]=0;for(let F=0;F<G;++F)S[k[F]]+=1;let M=0;for(let F=58;F>0;--F){const k=M+S[F]>>1;S[F]=M,M=k}for(let F=0;F<G;++F){const M=k[F];M>0&&(k[F]=M|S[M]++<<6)}}(g)}function r(k){return 63&k}function h(k){return k>>6}function e(k,M,F,l,t,g){const N=F.value,d=w(M,F),L=w(M,F);F.value+=4;const U=w(M,F);if(F.value+=4,d<0||d>=G||L<0||L>=G)throw new Error("Wrong HUF_ENCSIZE");const O=new Array(G),Z=new Array(A);!function(k){for(let M=0;M<A;M++)k[M]={},k[M].len=0,k[M].lit=0,k[M].p=null}(Z);if(c(k,F,l-(F.value-N),d,L,O),U>8*(l-(F.value-N)))throw new Error("Wrong hufUncompress");!function(k,M,F,l){for(;M<=F;M++){const F=h(k[M]),t=r(k[M]);if(F>>t)throw new Error("Invalid table entry");if(t>B){const k=l[F>>t-B];if(k.len)throw new Error("Invalid table entry");if(k.lit++,k.p){const M=k.p;k.p=new Array(k.lit);for(let F=0;F<k.lit-1;++F)k.p[F]=M[F]}else k.p=new Array(1);k.p[k.lit-1]=M}else if(t){let k=0;for(let g=1<<B-t;g>0;g--){const g=l[(F<<B-t)+k];if(g.len||g.p)throw new Error("Invalid table entry");g.len=t,g.lit=M,k++}}}}(O,d,L,Z),function(k,M,F,l,t,g,G,A,N){let d=0,L=0;const U=G,O=Math.trunc(l.value+(t+7)/8);for(;l.value<O;){let t=s(d,L,F,l);for(d=t.c,L=t.lc;L>=B;){const G=M[d>>L-B&16383];if(G.len){L-=G.len;const k=j(G.lit,g,d,L,F,l,A,N,U);k&&(d=k.c,L=k.lc)}else{if(!G.p)throw new Error("hufDecode issues");let M;for(M=0;M<G.lit;M++){const B=r(k[G.p[M]]);for(;L<B&&l.value<O;)t=s(d,L,F,l),d=t.c,L=t.lc;if(L>=B&&h(k[G.p[M]])==(d>>L-B&(1<<B)-1)){L-=B;const k=j(G.p[M],g,d,L,F,l,A,N,U);k&&(d=k.c,L=k.lc);break}}if(M==G.lit)throw new Error("HufDecode issues")}}}const w=8-t&7;for(d>>=w,L-=w;L>0;){const k=M[d<<B-L&16383];if(!k.len)throw new Error("HufDecode issues");{L-=k.len;const M=j(k.lit,g,d,L,F,l,A,N,U);M&&(d=M.c,L=M.lc)}}}(O,Z,k,F,U,L,g,t,{value:0})}function x(k){return 65535&k}function p(k){const M=x(k);return M>32767?M-65536:M}function K(k,M){const F=p(k),l=p(M),t=F+(1&l)+(l>>1);return{a:t,b:t-l}}function f(k,M){const F=x(k),l=x(M),t=F-(l>>1)&65535;return{a:l+t-32768&65535,b:t}}function W(k,M,F,l,t,g,B){const G=B<16384,A=F>t?t:F;let N,d,L=1;for(;L<=A;)L<<=1;for(L>>=1,N=L,L>>=1;L>=1;){d=0;const B=d+g*(t-N),A=g*L,U=g*N,O=l*L,w=l*N;let Z,R,y,m;for(;d<=B;d+=U){let t=d;const g=d+l*(F-N);for(;t<=g;t+=w){const F=t+O,l=t+A,g=l+O;if(G){let B=K(k[t+M],k[l+M]);Z=B.a,y=B.b,B=K(k[F+M],k[g+M]),R=B.a,m=B.b,B=K(Z,R),k[t+M]=B.a,k[F+M]=B.b,B=K(y,m),k[l+M]=B.a,k[g+M]=B.b}else{let B=f(k[t+M],k[l+M]);Z=B.a,y=B.b,B=f(k[F+M],k[g+M]),R=B.a,m=B.b,B=f(Z,R),k[t+M]=B.a,k[F+M]=B.b,B=f(y,m),k[l+M]=B.a,k[g+M]=B.b}}if(F&L){const F=t+A;let l;l=G?K(k[t+M],k[F+M]):f(k[t+M],k[F+M]),Z=l.a,k[F+M]=l.b,k[t+M]=Z}}if(t&L){let t=d;const g=d+l*(F-N);for(;t<=g;t+=w){const F=t+O;let l;l=G?K(k[t+M],k[F+M]):f(k[t+M],k[F+M]),Z=l.a,k[F+M]=l.b,k[t+M]=Z}}N=L,L>>=1}return d}function X(k){return new DataView(k.array.buffer,k.offset.value,k.size)}function V(k){const M=k.viewer.buffer.slice(k.offset.value,k.offset.value+k.size),F=new Uint8Array(function(k){let M=k.byteLength;const F=new Array;let l=0;const t=new DataView(k);for(;M>0;){const k=t.getInt8(l++);if(k<0){const g=-k;M-=g+1;for(let k=0;k<g;k++)F.push(t.getUint8(l++))}else{const g=k;M-=2;const B=t.getUint8(l++);for(let k=0;k<g+1;k++)F.push(B)}}return F}(M)),l=new Uint8Array(F.length);return n(F),a(F,l),new DataView(l.buffer)}function z(k){const M=k.array.slice(k.offset.value,k.offset.value+k.size),F=fflate.unzlibSync(M),l=new Uint8Array(F.length);return n(F),a(F,l),new DataView(l.buffer)}function E(k){const M=k.array.slice(k.offset.value,k.offset.value+k.size),F=fflate.unzlibSync(M),l=k.lines*k.channels*k.width,t=1==k.type?new Uint16Array(l):new Uint32Array(l);let g=0,B=0;const G=new Array(4);for(let A=0;A<k.lines;A++)for(let M=0;M<k.channels;M++){let M=0;switch(k.type){case 1:G[0]=g,G[1]=G[0]+k.width,g=G[1]+k.width;for(let l=0;l<k.width;++l){M+=F[G[0]++]<<8|F[G[1]++],t[B]=M,B++}break;case 2:G[0]=g,G[1]=G[0]+k.width,G[2]=G[1]+k.width,g=G[2]+k.width;for(let l=0;l<k.width;++l){M+=F[G[0]++]<<24|F[G[1]++]<<16|F[G[2]++]<<8,t[B]=M,B++}}}return new DataView(t.buffer)}function u(k){const M=k.viewer,F={value:k.offset.value},l=new Uint16Array(k.width*k.scanlineBlockSize*(k.channels*k.type)),t=new Uint8Array(8192);let B=0;const G=new Array(k.channels);for(let g=0;g<k.channels;g++)G[g]={},G[g].start=B,G[g].end=G[g].start,G[g].nx=k.width,G[g].ny=k.lines,G[g].size=k.type,B+=G[g].nx*G[g].ny*G[g].size;const A=R(M,F),N=R(M,F);if(N>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(A<=N)for(let g=0;g<N-A+1;g++)t[g+A]=Z(M,F);const d=new Uint16Array(g),L=function(k,M){let F=0;for(let t=0;t<g;++t)(0==t||k[t>>3]&1<<(7&t))&&(M[F++]=t);const l=F-1;for(;F<g;)M[F++]=0;return l}(t,d),U=w(M,F);e(k.array,M,F,U,l,B);for(let g=0;g<k.channels;++g){const k=G[g];for(let M=0;M<G[g].size;++M)W(l,k.start+M,k.nx,k.size,k.ny,k.nx*k.size,L)}!function(k,M,F){for(let l=0;l<F;++l)M[l]=k[M[l]]}(d,l,B);let O=0;const y=new Uint8Array(l.buffer.byteLength);for(let g=0;g<k.lines;g++)for(let M=0;M<k.channels;M++){const k=G[M],F=k.nx*k.size,t=new Uint8Array(l.buffer,2*k.end,2*F);y.set(t,O),O+=2*F,k.end+=F}return new DataView(y.buffer)}var T,P=F(480);!function(k){k[k.Float=0]="Float",k[k.HalfFloat=1]="HalfFloat"}(T||(T={}));class q{}q.DefaultOutputType=T.HalfFloat,q.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class I{constructor(){this.supportCascades=!1}loadCubeData(k,M,F,l,t){throw".exr not supported in Cube."}async loadData(k,M,F){const t=new DataView(k.buffer),g={value:0},B=function(k,M){if(20000630!=k.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const F=k.getUint8(4),t=k.getUint8(5),g={singleTile:!!(2&t),longName:!!(4&t),deepFormat:!!(8&t),multiPart:!!(16&t)};M.value=8;const B={};let G=!0;for(;G;){const F=U(k.buffer,M);if(F){const t=U(k.buffer,M),g=J(k,M,t,w(k,M));void 0===g?l.c.Warn(`Unknown header attribute type ${t}'.`):B[F]=g}else G=!1}if(0!=(-5&t))throw new Error("Unsupported file format");return{version:F,spec:g,...B}}(t,g),G=await async function(k,M,F,l){const t={size:0,viewer:M,array:new Uint8Array(M.buffer),offset:F,width:k.dataWindow.xMax-k.dataWindow.xMin+1,height:k.dataWindow.yMax-k.dataWindow.yMin+1,channels:k.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(k.compression){case N.NO_COMPRESSION:t.lines=1,t.uncompress=X;break;case N.RLE_COMPRESSION:t.lines=1,t.uncompress=V;break;case N.ZIPS_COMPRESSION:t.lines=1,t.uncompress=z,await P.f.LoadScriptAsync(q.FFLATEUrl);break;case N.ZIP_COMPRESSION:t.lines=16,t.uncompress=z,await P.f.LoadScriptAsync(q.FFLATEUrl);break;case N.PIZ_COMPRESSION:t.lines=32,t.uncompress=u;break;case N.PXR24_COMPRESSION:t.lines=16,t.uncompress=E,await P.f.LoadScriptAsync(q.FFLATEUrl);break;default:throw new Error(N[k.compression]+" is unsupported")}t.scanlineBlockSize=t.lines;const g={};for(const N of k.channels)switch(N.name){case"Y":case"R":case"G":case"B":case"A":g[N.name]=!0,t.type=N.pixelType}let B=!1;if(g.R&&g.G&&g.B)B=!g.A,t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else{if(!g.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");t.outputChannels=1,t.decodeChannels={Y:0}}if(1===t.type)switch(l){case T.Float:t.getter=Q,t.inputSize=2;break;case T.HalfFloat:t.getter=R,t.inputSize=2}else{if(2!==t.type)throw new Error("Unsupported pixelType "+t.type+" for "+k.compression);switch(l){case T.Float:t.getter=o,t.inputSize=4;break;case T.HalfFloat:t.getter=v,t.inputSize=4}}t.blockCount=t.height/t.scanlineBlockSize;for(let N=0;N<t.blockCount;N++)m(M,F);const G=t.width*t.height*t.outputChannels;switch(l){case T.Float:t.byteArray=new Float32Array(G),t.textureType=1,B&&t.byteArray.fill(1,0,G);break;case T.HalfFloat:t.byteArray=new Uint16Array(G),t.textureType=2,B&&t.byteArray.fill(15360,0,G);break;default:throw new Error("Unsupported type: "+l)}let A=0;for(const N of k.channels)void 0!==t.decodeChannels[N.name]&&(t.channelLineOffsets[N.name]=A*t.width),A+=2*N.pixelType;return t.bytesPerLine=t.width*A,t.outLineWidth=t.width*t.outputChannels,"INCREASING_Y"===k.lineOrder?t.scanOrder=k=>k:t.scanOrder=k=>t.height-1-k,4==t.outputChannels?(t.format=5,t.linearSpace=!0):(t.format=6,t.linearSpace=!1),t}(B,t,g,q.DefaultOutputType);!function(k,M,F,l){const t={value:0};for(let g=0;g<k.height/k.scanlineBlockSize;g++){const B=O(F,l)-M.dataWindow.yMin;k.size=w(F,l),k.lines=B+k.scanlineBlockSize>k.height?k.height-B:k.scanlineBlockSize;const G=k.size<k.lines*k.bytesPerLine&&k.uncompress?k.uncompress(k):X(k);l.value+=k.size;for(let F=0;F<k.scanlineBlockSize;F++){const l=g*k.scanlineBlockSize,B=F+k.scanOrder(l);if(B>=k.height)continue;const A=F*k.bytesPerLine,N=(k.height-1-B)*k.outLineWidth;for(let F=0;F<k.channels;F++){const l=M.channels[F].name,g=k.channelLineOffsets[l],B=k.decodeChannels[l];if(void 0!==B){t.value=A+g;for(let M=0;M<k.width;M++){const F=N+M*k.outputChannels+B;k.byteArray&&(k.byteArray[F]=k.getter(G,t))}}}}}}(G,B,t,g);F(B.dataWindow.xMax-B.dataWindow.xMin+1,B.dataWindow.yMax-B.dataWindow.yMin+1,M.generateMipMaps,!1,(()=>{const k=M.getEngine();M.format=B.format,M.type=G.textureType,M.invertY=!1,M._gammaSpace=!B.linearSpace,G.byteArray&&k._uploadDataToTextureDirectly(M,G.byteArray,0,0,void 0,!0)}))}}}}]);