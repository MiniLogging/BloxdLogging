"use strict";(self.v2pspxy442l=self.v2pspxy442l||[]).push([[14],{12452:(l,a,N)=>{N.d(a,{d:()=>Z,f:()=>K,i:()=>U,k:()=>c});const U=1/2.2,c=2.2,K=(1+Math.sqrt(5))/2,Z=.001},12461:(l,a,N)=>{function U(l){return parseInt(l.toString().replace(/\W/g,""))}function c(l,a){let N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(l-a)<=N}function K(l,a,N){let U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return l<a-U||l>N+U}function Z(l,a){return l===a?l:Math.random()*(a-l)+l}function w(l,a,N){return l+(a-l)*N}function S(l,a,N){let U=B(a-l,360);return U>180&&(U-=360),l+U*y(N)}function T(l,a,N){let U=0;return U=l!=a?y((N-l)/(a-l)):0,U}function J(l,a,N,U,c){const K=c*c,Z=c*K;return l*(2*Z-3*K+1)+N*(-2*Z+3*K)+a*(Z-2*K+c)+U*(Z-K)}function n(l,a,N,U,c){const K=c*c;return 6*(K-c)*l+(3*K-4*c+1)*a+6*(-K+c)*N+(3*K-2*c)*U}function y(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(N,Math.max(a,l))}function H(l){return l-=2*Math.PI*Math.floor((l+Math.PI)/(2*Math.PI))}function u(l){const a=l.toString(16);return l<=15?("0"+a).toUpperCase():a.toUpperCase()}function W(l){if(Math.log2)return Math.floor(Math.log2(l));if(l<0)return NaN;if(0===l)return-1/0;let a=0;if(l<1){for(;l<1;)a++,l*=2;a=-a}else if(l>1)for(;l>1;)a++,l=Math.floor(l/2);return a}function B(l,a){return l-Math.floor(l/a)*a}function Y(l,a,N){return(l-a)/(N-a)}function C(l,a,N){return l*(N-a)+a}function M(l,a){let N=B(a-l,360);return N>180&&(N-=360),N}function A(l,a){const N=B(l,2*a);return a-Math.abs(N-a)}function E(l,a,N){let U=y(N);return U=-2*U*U*U+3*U*U,a*U+l*(1-U)}function q(l,a,N){let U=0;return U=Math.abs(a-l)<=N?a:l+Math.sign(a-l)*N,U}function b(l,a,N){const U=M(l,a);let c=0;return c=-N<U&&U<N?a:q(l,a=l+U,N),c}function z(l,a,N){return(l-a)/(N-a)}function I(l,a,N){return(N-a)*l+a}function t(l,a){const N=l%a;return 0===N?a:t(a,N)}N.r(a),N.d(a,{Clamp:()=>y,DeltaAngle:()=>M,Denormalize:()=>C,ExtractAsInt:()=>U,Hermite:()=>J,Hermite1stDerivative:()=>n,HighestCommonFactor:()=>t,ILog2:()=>W,InverseLerp:()=>T,Lerp:()=>w,LerpAngle:()=>S,MoveTowards:()=>q,MoveTowardsAngle:()=>b,Normalize:()=>Y,NormalizeRadians:()=>H,OutsideRange:()=>K,PercentToRange:()=>I,PingPong:()=>A,RandomRange:()=>Z,RangeToPercent:()=>z,Repeat:()=>B,SmoothStep:()=>E,ToHex:()=>u,WithinEpsilon:()=>c})},12447:(l,a,N)=>{N.r(a),N.d(a,{Matrix:()=>C,Quaternion:()=>Y,TmpVectors:()=>A,Vector2:()=>u,ua:()=>W,Vector4:()=>B});var U=N(12452),c=N(12457),K=N(12394),Z=N(12367),w=N(12296),S=N(12461);class T{}function J(l,a,N){let U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const c=l.Bc(),K=a.Bc(),Z=c[0],w=c[1],S=c[2],T=c[3],J=c[4],n=c[5],y=c[6],H=c[7],u=c[8],W=c[9],B=c[10],Y=c[11],C=c[12],M=c[13],A=c[14],E=c[15],q=K[0],b=K[1],z=K[2],I=K[3],t=K[4],O=K[5],h=K[6],i=K[7],k=K[8],Q=K[9],j=K[10],f=K[11],p=K[12],R=K[13],L=K[14],r=K[15];N[U]=Z*q+w*t+S*k+T*p,N[U+1]=Z*b+w*O+S*Q+T*R,N[U+2]=Z*z+w*h+S*j+T*L,N[U+3]=Z*I+w*i+S*f+T*r,N[U+4]=J*q+n*t+y*k+H*p,N[U+5]=J*b+n*O+y*Q+H*R,N[U+6]=J*z+n*h+y*j+H*L,N[U+7]=J*I+n*i+y*f+H*r,N[U+8]=u*q+W*t+B*k+Y*p,N[U+9]=u*b+W*O+B*Q+Y*R,N[U+10]=u*z+W*h+B*j+Y*L,N[U+11]=u*I+W*i+B*f+Y*r,N[U+12]=C*q+M*t+A*k+E*p,N[U+13]=C*b+M*O+A*Q+E*R,N[U+14]=C*z+M*h+A*j+E*L,N[U+15]=C*I+M*i+A*f+E*r}function n(l,a){let N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const U=l.Bc();a[N]=U[0],a[N+1]=U[1],a[N+2]=U[2],a[N+3]=U[3],a[N+4]=U[4],a[N+5]=U[5],a[N+6]=U[6],a[N+7]=U[7],a[N+8]=U[8],a[N+9]=U[9],a[N+10]=U[10],a[N+11]=U[11],a[N+12]=U[12],a[N+13]=U[13],a[N+14]=U[14],a[N+15]=U[15]}function y(l,a){const N=l.Bc(),U=N[0],c=N[1],K=N[2],Z=N[3],w=N[4],S=N[5],T=N[6],J=N[7],n=N[8],y=N[9],H=N[10],u=N[11],W=N[12],B=N[13],Y=N[14],C=N[15],M=H*C-Y*u,A=y*C-B*u,E=y*Y-B*H,q=n*C-W*u,b=n*Y-H*W,z=n*B-W*y,I=+(S*M-T*A+J*E),t=-(w*M-T*q+J*b),O=+(w*A-S*q+J*z),h=-(w*E-S*b+T*z),i=U*I+c*t+K*O+Z*h;if(0===i)return!1;const k=1/i,Q=T*C-Y*J,j=S*C-B*J,f=S*Y-B*T,p=w*C-W*J,R=w*Y-W*T,L=w*B-W*S,r=T*u-H*J,X=S*u-y*J,P=S*H-y*T,d=w*u-n*J,F=w*H-n*T,e=w*y-n*S,s=-(c*M-K*A+Z*E),o=+(U*M-K*q+Z*b),G=-(U*A-c*q+Z*z),ml=+(U*E-c*b+K*z),x=+(c*Q-K*j+Z*f),V=-(U*Q-K*p+Z*R),D=+(U*j-c*p+Z*L),v=-(U*f-c*R+K*L),g=-(c*r-K*X+Z*P),ll=+(U*r-K*d+Z*F),al=-(U*X-c*d+Z*e),Nl=+(U*P-c*F+K*e);return a[0]=I*k,a[1]=s*k,a[2]=x*k,a[3]=g*k,a[4]=t*k,a[5]=o*k,a[6]=V*k,a[7]=ll*k,a[8]=O*k,a[9]=G*k,a[10]=D*k,a[11]=al*k,a[12]=h*k,a[13]=ml*k,a[14]=v*k,a[15]=Nl*k,!0}T._UpdateFlagSeed=0;const H=l=>parseInt(l.toString().replace(/\W/g,""));class u{constructor(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=l,this.y=a}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let l=H(this.x);return l=397*l^H(this.y),l}toArray(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l[a]=this.x,l[a+1]=this.y,this}yN(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(l,a,this),this}Bc(){return[this.x,this.y]}K(l){return this.x=l.x,this.y=l.y,this}tc(l,a){return this.x=l,this.y=a,this}set(l,a){return this.tc(l,a)}hc(l){return this.tc(l,l)}add(l){return new u(this.x+l.x,this.y+l.y)}addToRef(l,a){return a.x=this.x+l.x,a.y=this.y+l.y,a}addInPlace(l){return this.x+=l.x,this.y+=l.y,this}addInPlaceFromFloats(l,a){return this.x+=l,this.y+=a,this}addVector3(l){return new u(this.x+l.x,this.y+l.y)}Wa(l){return new u(this.x-l.x,this.y-l.y)}subtractToRef(l,a){return a.x=this.x-l.x,a.y=this.y-l.y,a}wn(l){return this.x-=l.x,this.y-=l.y,this}multiplyInPlace(l){return this.x*=l.x,this.y*=l.y,this}multiply(l){return new u(this.x*l.x,this.y*l.y)}multiplyToRef(l,a){return a.x=this.x*l.x,a.y=this.y*l.y,a}multiplyByFloats(l,a){return new u(this.x*l,this.y*a)}divide(l){return new u(this.x/l.x,this.y/l.y)}divideToRef(l,a){return a.x=this.x/l.x,a.y=this.y/l.y,a}divideInPlace(l){return this.x=this.x/l.x,this.y=this.y/l.y,this}minimizeInPlace(l){return this.minimizeInPlaceFromFloats(l.x,l.y)}maximizeInPlace(l){return this.maximizeInPlaceFromFloats(l.x,l.y)}minimizeInPlaceFromFloats(l,a){return this.x=Math.min(l,this.x),this.y=Math.min(a,this.y),this}maximizeInPlaceFromFloats(l,a){return this.x=Math.max(l,this.x),this.y=Math.max(a,this.y),this}subtractFromFloats(l,a){return new u(this.x-l,this.y-a)}subtractFromFloatsToRef(l,a,N){return N.x=this.x-l,N.y=this.y-a,N}negate(){return new u(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(l){return l.x=-this.x,l.y=-this.y,l}scaleInPlace(l){return this.x*=l,this.y*=l,this}scale(l){return new u(this.x*l,this.y*l)}scaleToRef(l,a){return a.x=this.x*l,a.y=this.y*l,a}scaleAndAddToRef(l,a){return a.x+=this.x*l,a.y+=this.y*l,a}equals(l){return l&&this.x===l.x&&this.y===l.y}equalsWithEpsilon(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:U.d;return l&&(0,S.WithinEpsilon)(this.x,l.x,a)&&(0,S.WithinEpsilon)(this.y,l.y,a)}equalsToFloats(l,a){return this.x===l&&this.y===a}floor(){return new u(Math.floor(this.x),Math.floor(this.y))}floorToRef(l){return l.x=Math.floor(this.x),l.y=Math.floor(this.y),l}fract(){return new u(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(l){return l.x=this.x-Math.floor(this.x),l.y=this.y-Math.floor(this.y),l}rotate(l){return this.rotateToRef(l,new u)}rotateToRef(l,a){const N=Math.cos(l),U=Math.sin(l);return a.x=N*this.x-U*this.y,a.y=U*this.x+N*this.y,a}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(l){return 0===l||1===l?this:this.scaleInPlace(1/l)}normalizeToNew(){const l=new u;return this.normalizeToRef(l),l}normalizeToRef(l){const a=this.length();return 0===a&&(l.x=this.x,l.y=this.y),this.scaleToRef(1/a,l)}clone(){return new u(this.x,this.y)}dot(l){return this.x*l.x+this.y*l.y}static Zero(){return new u(0,0)}static One(){return new u(1,1)}static Random(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new u((0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a))}static RandomToRef(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).tc((0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a))}static get ZeroReadOnly(){return u._ZeroReadOnly}static Ma(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new u(l[a],l[a+1])}static FromArrayToRef(l,a,N){return N.x=l[a],N.y=l[a+1],N}static FromFloatsToRef(l,a,N){return N.tc(l,a),N}static CatmullRom(l,a,N,U,c){const K=c*c,Z=c*K,w=.5*(2*a.x+(-l.x+N.x)*c+(2*l.x-5*a.x+4*N.x-U.x)*K+(-l.x+3*a.x-3*N.x+U.x)*Z),S=.5*(2*a.y+(-l.y+N.y)*c+(2*l.y-5*a.y+4*N.y-U.y)*K+(-l.y+3*a.y-3*N.y+U.y)*Z);return new u(w,S)}static ClampToRef(l,a,N,U){return U.x=(0,S.Clamp)(l.x,a.x,N.x),U.y=(0,S.Clamp)(l.y,a.y,N.y),U}static Clamp(l,a,N){const U=(0,S.Clamp)(l.x,a.x,N.x),c=(0,S.Clamp)(l.y,a.y,N.y);return new u(U,c)}static Hermite(l,a,N,U,c){const K=c*c,Z=c*K,w=2*Z-3*K+1,S=-2*Z+3*K,T=Z-2*K+c,J=Z-K,n=l.x*w+N.x*S+a.x*T+U.x*J,y=l.y*w+N.y*S+a.y*T+U.y*J;return new u(n,y)}static Hermite1stDerivative(l,a,N,U,c){return this.Hermite1stDerivativeToRef(l,a,N,U,c,new u)}static Hermite1stDerivativeToRef(l,a,N,U,c,K){const Z=c*c;return K.x=6*(Z-c)*l.x+(3*Z-4*c+1)*a.x+6*(-Z+c)*N.x+(3*Z-2*c)*U.x,K.y=6*(Z-c)*l.y+(3*Z-4*c+1)*a.y+6*(-Z+c)*N.y+(3*Z-2*c)*U.y,K}static Lerp(l,a,N){return u.LerpToRef(l,a,N,new u)}static LerpToRef(l,a,N,U){return U.x=l.x+(a.x-l.x)*N,U.y=l.y+(a.y-l.y)*N,U}static Dot(l,a){return l.x*a.x+l.y*a.y}static Normalize(l){return u.NormalizeToRef(l,new u)}static NormalizeToRef(l,a){return l.normalizeToRef(a),a}static Minimize(l,a){const N=l.x<a.x?l.x:a.x,U=l.y<a.y?l.y:a.y;return new u(N,U)}static Maximize(l,a){const N=l.x>a.x?l.x:a.x,U=l.y>a.y?l.y:a.y;return new u(N,U)}static Transform(l,a){return u.TransformToRef(l,a,new u)}static TransformToRef(l,a,N){const U=a.m,c=l.x*U[0]+l.y*U[4]+U[12],K=l.x*U[1]+l.y*U[5]+U[13];return N.x=c,N.y=K,N}static PointInTriangle(l,a,N,U){const c=.5*(-N.y*U.x+a.y*(-N.x+U.x)+a.x*(N.y-U.y)+N.x*U.y),K=c<0?-1:1,Z=(a.y*U.x-a.x*U.y+(U.y-a.y)*l.x+(a.x-U.x)*l.y)*K,w=(a.x*N.y-a.y*N.x+(a.y-N.y)*l.x+(N.x-a.x)*l.y)*K;return Z>0&&w>0&&Z+w<2*c*K}static Distance(l,a){return Math.sqrt(u.DistanceSquared(l,a))}static DistanceSquared(l,a){const N=l.x-a.x,U=l.y-a.y;return N*N+U*U}static Center(l,a){return u.CenterToRef(l,a,new u)}static CenterToRef(l,a,N){return N.tc((l.x+a.x)/2,(l.y+a.y)/2)}static DistanceOfPointFromSegment(l,a,N){const U=u.DistanceSquared(a,N);if(0===U)return u.Distance(l,a);const c=N.Wa(a),K=Math.max(0,Math.min(1,u.Dot(l.Wa(a),c)/U)),Z=a.add(c.multiplyByFloats(K,K));return u.Distance(l,Z)}}u._V8PerformanceHack=new u(.5,.5),u._ZeroReadOnly=u.Zero(),Object.defineProperties(u.prototype,{dimension:{value:[2]},rank:{value:1}});class W{get x(){return this._x}set x(l){this._x=l,this._isDirty=!0}get y(){return this._y}set y(l){this._y=l,this._isDirty=!0}get z(){return this._z}set z(l){this._z=l,this._isDirty=!0}constructor(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=l,this._y=a,this._z=N}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"ua"}getHashCode(){let l=H(this._x);return l=397*l^H(this._y),l=397*l^H(this._z),l}Bc(){return[this._x,this._y,this._z]}toArray(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l[a]=this._x,l[a+1]=this._y,l[a+2]=this._z,this}yN(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return W.FromArrayToRef(l,a,this),this}toQuaternion(){return Y.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(l){return this._x+=l._x,this._y+=l._y,this._z+=l._z,this._isDirty=!0,this}addInPlaceFromFloats(l,a,N){return this._x+=l,this._y+=a,this._z+=N,this._isDirty=!0,this}add(l){return new W(this._x+l._x,this._y+l._y,this._z+l._z)}addToRef(l,a){return a._x=this._x+l._x,a._y=this._y+l._y,a._z=this._z+l._z,a._isDirty=!0,a}wn(l){return this._x-=l._x,this._y-=l._y,this._z-=l._z,this._isDirty=!0,this}Wa(l){return new W(this._x-l._x,this._y-l._y,this._z-l._z)}subtractToRef(l,a){return this.subtractFromFloatsToRef(l._x,l._y,l._z,a)}subtractFromFloats(l,a,N){return new W(this._x-l,this._y-a,this._z-N)}subtractFromFloatsToRef(l,a,N,U){return U._x=this._x-l,U._y=this._y-a,U._z=this._z-N,U._isDirty=!0,U}negate(){return new W(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(l){return l._x=-1*this._x,l._y=-1*this._y,l._z=-1*this._z,l._isDirty=!0,l}scaleInPlace(l){return this._x*=l,this._y*=l,this._z*=l,this._isDirty=!0,this}scale(l){return new W(this._x*l,this._y*l,this._z*l)}scaleToRef(l,a){return a._x=this._x*l,a._y=this._y*l,a._z=this._z*l,a._isDirty=!0,a}getNormalToRef(l){const a=this.length();let N=Math.acos(this._y/a);const U=Math.atan2(this._z,this._x);N>Math.PI/2?N-=Math.PI/2:N+=Math.PI/2;const c=a*Math.sin(N)*Math.cos(U),K=a*Math.cos(N),Z=a*Math.sin(N)*Math.sin(U);return l.set(c,K,Z),l}applyRotationQuaternionToRef(l,a){const N=this._x,U=this._y,c=this._z,K=l._x,Z=l._y,w=l._z,S=l._w,T=2*(Z*c-w*U),J=2*(w*N-K*c),n=2*(K*U-Z*N);return a._x=N+S*T+Z*n-w*J,a._y=U+S*J+w*T-K*n,a._z=c+S*n+K*J-Z*T,a._isDirty=!0,a}applyRotationQuaternionInPlace(l){return this.applyRotationQuaternionToRef(l,this)}applyRotationQuaternion(l){return this.applyRotationQuaternionToRef(l,new W)}scaleAndAddToRef(l,a){return a._x+=this._x*l,a._y+=this._y*l,a._z+=this._z*l,a._isDirty=!0,a}projectOnPlane(l,a){return this.projectOnPlaneToRef(l,a,new W)}projectOnPlaneToRef(l,a,N){const U=l.normal,c=l.d,K=M.ua[0];this.subtractToRef(a,K),K.normalize();const Z=W.Dot(K,U);if(Math.abs(Z)<1e-10)N.hc(1/0);else{const l=-(W.Dot(a,U)+c)/Z,w=K.scaleInPlace(l);a.addToRef(w,N)}return N}equals(l){return l&&this._x===l._x&&this._y===l._y&&this._z===l._z}equalsWithEpsilon(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:U.d;return l&&(0,S.WithinEpsilon)(this._x,l._x,a)&&(0,S.WithinEpsilon)(this._y,l._y,a)&&(0,S.WithinEpsilon)(this._z,l._z,a)}equalsToFloats(l,a,N){return this._x===l&&this._y===a&&this._z===N}multiplyInPlace(l){return this._x*=l._x,this._y*=l._y,this._z*=l._z,this._isDirty=!0,this}multiply(l){return this.multiplyByFloats(l._x,l._y,l._z)}multiplyToRef(l,a){return a._x=this._x*l._x,a._y=this._y*l._y,a._z=this._z*l._z,a._isDirty=!0,a}multiplyByFloats(l,a,N){return new W(this._x*l,this._y*a,this._z*N)}divide(l){return new W(this._x/l._x,this._y/l._y,this._z/l._z)}divideToRef(l,a){return a._x=this._x/l._x,a._y=this._y/l._y,a._z=this._z/l._z,a._isDirty=!0,a}divideInPlace(l){return this._x=this._x/l._x,this._y=this._y/l._y,this._z=this._z/l._z,this._isDirty=!0,this}minimizeInPlace(l){return this.minimizeInPlaceFromFloats(l._x,l._y,l._z)}maximizeInPlace(l){return this.maximizeInPlaceFromFloats(l._x,l._y,l._z)}minimizeInPlaceFromFloats(l,a,N){return l<this._x&&(this.x=l),a<this._y&&(this.y=a),N<this._z&&(this.z=N),this}maximizeInPlaceFromFloats(l,a,N){return l>this._x&&(this.x=l),a>this._y&&(this.y=a),N>this._z&&(this.z=N),this}isNonUniformWithinEpsilon(l){const a=Math.abs(this._x),N=Math.abs(this._y);if(!(0,S.WithinEpsilon)(a,N,l))return!0;const U=Math.abs(this._z);return!(0,S.WithinEpsilon)(a,U,l)||!(0,S.WithinEpsilon)(N,U,l)}get isNonUniform(){const l=Math.abs(this._x);if(l!==Math.abs(this._y))return!0;return l!==Math.abs(this._z)}floorToRef(l){return l._x=Math.floor(this._x),l._y=Math.floor(this._y),l._z=Math.floor(this._z),l._isDirty=!0,l}floor(){return new W(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(l){return l._x=this._x-Math.floor(this._x),l._y=this._y-Math.floor(this._y),l._z=this._z-Math.floor(this._z),l._isDirty=!0,l}fract(){return new W(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(l){if("xyz"===(l=l.toLowerCase()))return this;const a=M.ua[0].K(this);return this.x=a[l[0]],this.y=a[l[1]],this.z=a[l[2]],this}rotateByQuaternionToRef(l,a){return l.toRotationMatrix(M.Matrix[0]),W.TransformCoordinatesToRef(this,M.Matrix[0],a),a}rotateByQuaternionAroundPointToRef(l,a,N){return this.subtractToRef(a,M.ua[0]),M.ua[0].rotateByQuaternionToRef(l,M.ua[0]),a.addToRef(M.ua[0],N),N}cross(l){return W.CrossToRef(this,l,new W)}normalizeFromLength(l){return 0===l||1===l?this:this.scaleInPlace(1/l)}normalizeToNew(){return this.normalizeToRef(new W)}normalizeToRef(l){const a=this.length();return 0===a||1===a?(l._x=this._x,l._y=this._y,l._z=this._z,l._isDirty=!0,l):this.scaleToRef(1/a,l)}clone(){return new W(this._x,this._y,this._z)}K(l){return this.tc(l._x,l._y,l._z)}tc(l,a,N){return this._x=l,this._y=a,this._z=N,this._isDirty=!0,this}set(l,a,N){return this.tc(l,a,N)}hc(l){return this._x=this._y=this._z=l,this._isDirty=!0,this}static GetClipFactor(l,a,N,U){const c=W.Dot(l,N);return(c-U)/(c-W.Dot(a,N))}static GetAngleBetweenVectors(l,a,N){const U=l.normalizeToRef(M.ua[1]),c=a.normalizeToRef(M.ua[2]);let K=W.Dot(U,c);K=(0,S.Clamp)(K,-1,1);const Z=Math.acos(K),w=M.ua[3];return W.CrossToRef(U,c,w),W.Dot(w,N)>0?isNaN(Z)?0:Z:isNaN(Z)?-Math.PI:-Math.acos(K)}static GetAngleBetweenVectorsOnPlane(l,a,N){M.ua[0].K(l);const U=M.ua[0];M.ua[1].K(a);const c=M.ua[1];M.ua[2].K(N);const K=M.ua[2],Z=M.ua[3],w=M.ua[4];U.normalize(),c.normalize(),K.normalize(),W.CrossToRef(K,U,Z),W.CrossToRef(Z,K,w);const T=Math.atan2(W.Dot(c,Z),W.Dot(c,w));return(0,S.NormalizeRadians)(T)}static PitchYawRollToMoveBetweenPointsToRef(l,a,N){const U=A.ua[0];return a.subtractToRef(l,U),N._y=Math.atan2(U.x,U.z)||0,N._x=Math.atan2(Math.sqrt(U.x**2+U.z**2),U.y)||0,N._z=0,N._isDirty=!0,N}static PitchYawRollToMoveBetweenPoints(l,a){const N=W.Zero();return W.PitchYawRollToMoveBetweenPointsToRef(l,a,N)}static SlerpToRef(l,a,N,c){N=(0,S.Clamp)(N,0,1);const K=M.ua[0],Z=M.ua[1];K.K(l);const w=K.length();K.normalizeFromLength(w),Z.K(a);const T=Z.length();Z.normalizeFromLength(T);const J=W.Dot(K,Z);let n,y;if(J<1-U.d){const l=Math.acos(J),a=1/Math.sin(l);n=Math.sin((1-N)*l)*a,y=Math.sin(N*l)*a}else n=1-N,y=N;return K.scaleInPlace(n),Z.scaleInPlace(y),c.K(K).addInPlace(Z),c.scaleInPlace((0,S.Lerp)(w,T,N)),c}static SmoothToRef(l,a,N,U,c){return W.SlerpToRef(l,a,0===U?1:N/U,c),c}static Ma(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new W(l[a],l[a+1],l[a+2])}static FromFloatArray(l,a){return W.Ma(l,a)}static FromArrayToRef(l,a,N){return N._x=l[a],N._y=l[a+1],N._z=l[a+2],N._isDirty=!0,N}static FromFloatArrayToRef(l,a,N){return W.FromArrayToRef(l,a,N)}static FromFloatsToRef(l,a,N,U){return U.tc(l,a,N),U}static Zero(){return new W(0,0,0)}static One(){return new W(1,1,1)}static Up(){return new W(0,1,0)}static get UpReadOnly(){return W._UpReadOnly}static get DownReadOnly(){return W._DownReadOnly}static get RightReadOnly(){return W._RightReadOnly}static get LeftReadOnly(){return W._LeftReadOnly}static get LeftHandedForwardReadOnly(){return W._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return W._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return W._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return W._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return W._ZeroReadOnly}static get OneReadOnly(){return W._OneReadOnly}static Down(){return new W(0,-1,0)}static Forward(){return new W(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new W(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new W(1,0,0)}static Left(){return new W(-1,0,0)}static Random(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new W((0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a))}static RandomToRef(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).tc((0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a))}static TransformCoordinates(l,a){const N=W.Zero();return W.TransformCoordinatesToRef(l,a,N),N}static TransformCoordinatesToRef(l,a,N){return W.TransformCoordinatesFromFloatsToRef(l._x,l._y,l._z,a,N),N}static TransformCoordinatesFromFloatsToRef(l,a,N,U,c){const K=U.m,Z=l*K[0]+a*K[4]+N*K[8]+K[12],w=l*K[1]+a*K[5]+N*K[9]+K[13],S=l*K[2]+a*K[6]+N*K[10]+K[14],T=1/(l*K[3]+a*K[7]+N*K[11]+K[15]);return c._x=Z*T,c._y=w*T,c._z=S*T,c._isDirty=!0,c}static TransformNormal(l,a){const N=W.Zero();return W.TransformNormalToRef(l,a,N),N}static TransformNormalToRef(l,a,N){return this.TransformNormalFromFloatsToRef(l._x,l._y,l._z,a,N),N}static TransformNormalFromFloatsToRef(l,a,N,U,c){const K=U.m;return c._x=l*K[0]+a*K[4]+N*K[8],c._y=l*K[1]+a*K[5]+N*K[9],c._z=l*K[2]+a*K[6]+N*K[10],c._isDirty=!0,c}static CatmullRom(l,a,N,U,c){const K=c*c,Z=c*K,w=.5*(2*a._x+(-l._x+N._x)*c+(2*l._x-5*a._x+4*N._x-U._x)*K+(-l._x+3*a._x-3*N._x+U._x)*Z),S=.5*(2*a._y+(-l._y+N._y)*c+(2*l._y-5*a._y+4*N._y-U._y)*K+(-l._y+3*a._y-3*N._y+U._y)*Z),T=.5*(2*a._z+(-l._z+N._z)*c+(2*l._z-5*a._z+4*N._z-U._z)*K+(-l._z+3*a._z-3*N._z+U._z)*Z);return new W(w,S,T)}static Clamp(l,a,N){const U=new W;return W.ClampToRef(l,a,N,U),U}static ClampToRef(l,a,N,U){let c=l._x;c=c>N._x?N._x:c,c=c<a._x?a._x:c;let K=l._y;K=K>N._y?N._y:K,K=K<a._y?a._y:K;let Z=l._z;return Z=Z>N._z?N._z:Z,Z=Z<a._z?a._z:Z,U.tc(c,K,Z),U}static CheckExtends(l,a,N){a.minimizeInPlace(l),N.maximizeInPlace(l)}static Hermite(l,a,N,U,c){const K=c*c,Z=c*K,w=2*Z-3*K+1,S=-2*Z+3*K,T=Z-2*K+c,J=Z-K,n=l._x*w+N._x*S+a._x*T+U._x*J,y=l._y*w+N._y*S+a._y*T+U._y*J,H=l._z*w+N._z*S+a._z*T+U._z*J;return new W(n,y,H)}static Hermite1stDerivative(l,a,N,U,c){const K=new W;return this.Hermite1stDerivativeToRef(l,a,N,U,c,K),K}static Hermite1stDerivativeToRef(l,a,N,U,c,K){const Z=c*c;return K._x=6*(Z-c)*l._x+(3*Z-4*c+1)*a._x+6*(-Z+c)*N._x+(3*Z-2*c)*U._x,K._y=6*(Z-c)*l._y+(3*Z-4*c+1)*a._y+6*(-Z+c)*N._y+(3*Z-2*c)*U._y,K._z=6*(Z-c)*l._z+(3*Z-4*c+1)*a._z+6*(-Z+c)*N._z+(3*Z-2*c)*U._z,K._isDirty=!0,K}static Lerp(l,a,N){const U=new W(0,0,0);return W.LerpToRef(l,a,N,U),U}static LerpToRef(l,a,N,U){return U._x=l._x+(a._x-l._x)*N,U._y=l._y+(a._y-l._y)*N,U._z=l._z+(a._z-l._z)*N,U._isDirty=!0,U}static Dot(l,a){return l._x*a._x+l._y*a._y+l._z*a._z}dot(l){return this._x*l._x+this._y*l._y+this._z*l._z}static Cross(l,a){const N=new W;return W.CrossToRef(l,a,N),N}static CrossToRef(l,a,N){const U=l._y*a._z-l._z*a._y,c=l._z*a._x-l._x*a._z,K=l._x*a._y-l._y*a._x;return N.tc(U,c,K),N}static Normalize(l){const a=W.Zero();return W.NormalizeToRef(l,a),a}static NormalizeToRef(l,a){return l.normalizeToRef(a),a}static Project(l,a,N,U){const c=new W;return W.ProjectToRef(l,a,N,U,c),c}static ProjectToRef(l,a,N,U,c){var K;const Z=U.width,S=U.height,T=U.x,J=U.y,n=M.Matrix[1],y=null===(K=w.e.LastCreatedEngine)||void 0===K?void 0:K.isNDCHalfZRange,H=y?1:.5,u=y?0:.5;C.FromValuesToRef(Z/2,0,0,0,0,-S/2,0,0,0,0,H,0,T+Z/2,S/2+J,u,1,n);const B=M.Matrix[0];return a.multiplyToRef(N,B),B.multiplyToRef(n,B),W.TransformCoordinatesToRef(l,B,c),c}static Reflect(l,a){return this.ReflectToRef(l,a,new W)}static ReflectToRef(l,a,N){const U=A.ua[0];return U.K(a).scaleInPlace(2*W.Dot(l,a)),N.K(l).wn(U)}static _UnprojectFromInvertedMatrixToRef(l,a,N){W.TransformCoordinatesToRef(l,a,N);const U=a.m,c=l._x*U[3]+l._y*U[7]+l._z*U[11]+U[15];return(0,S.WithinEpsilon)(c,1)&&N.scaleInPlace(1/c),N}static UnprojectFromTransform(l,a,N,U,c){return this.Unproject(l,a,N,U,c,C.IdentityReadOnly)}static Unproject(l,a,N,U,c,K){const Z=new W;return W.UnprojectToRef(l,a,N,U,c,K,Z),Z}static UnprojectToRef(l,a,N,U,c,K,Z){return W.UnprojectFloatsToRef(l._x,l._y,l._z,a,N,U,c,K,Z),Z}static UnprojectFloatsToRef(l,a,N,U,c,K,Z,S,T){var J;const n=M.Matrix[0];K.multiplyToRef(Z,n),n.multiplyToRef(S,n),n.invert();const y=M.ua[0];return y.x=l/U*2-1,y.y=-(a/c*2-1),null!==(J=w.e.LastCreatedEngine)&&void 0!==J&&J.isNDCHalfZRange?y.z=N:y.z=2*N-1,W._UnprojectFromInvertedMatrixToRef(y,n,T),T}static Minimize(l,a){const N=new W;return N.K(l),N.minimizeInPlace(a),N}static Maximize(l,a){const N=new W;return N.K(l),N.maximizeInPlace(a),N}static Distance(l,a){return Math.sqrt(W.DistanceSquared(l,a))}static DistanceSquared(l,a){const N=l._x-a._x,U=l._y-a._y,c=l._z-a._z;return N*N+U*U+c*c}static ProjectOnTriangleToRef(l,a,N,c,K){const Z=M.ua[0],w=M.ua[1],T=M.ua[2],J=M.ua[3],n=M.ua[4];N.subtractToRef(a,Z),c.subtractToRef(a,w),c.subtractToRef(N,T);const y=Z.length(),H=w.length(),u=T.length();if(y<U.d||H<U.d||u<U.d)return K.K(a),W.Distance(l,a);l.subtractToRef(a,n),W.CrossToRef(Z,w,J);const B=J.length();if(B<U.d)return K.K(a),W.Distance(l,a);J.normalizeFromLength(B);let Y=n.length();if(Y<U.d)return K.K(a),0;n.normalizeFromLength(Y);const C=W.Dot(J,n),A=M.ua[5],E=M.ua[6];A.K(J).scaleInPlace(-Y*C),E.K(l).addInPlace(A);const q=M.ua[4],b=M.ua[5],z=M.ua[7],I=M.ua[8];q.K(Z).scaleInPlace(1/y),I.K(w).scaleInPlace(1/H),q.addInPlace(I).scaleInPlace(-1),b.K(Z).scaleInPlace(-1/y),I.K(T).scaleInPlace(1/u),b.addInPlace(I).scaleInPlace(-1),z.K(T).scaleInPlace(-1/u),I.K(w).scaleInPlace(-1/H),z.addInPlace(I).scaleInPlace(-1);const t=M.ua[9];let O;t.K(E).wn(a),W.CrossToRef(q,t,I),O=W.Dot(I,J);const h=O;t.K(E).wn(N),W.CrossToRef(b,t,I),O=W.Dot(I,J);const i=O;t.K(E).wn(c),W.CrossToRef(z,t,I),O=W.Dot(I,J);const k=O,Q=M.ua[10];let j,f;h>0&&i<0?(Q.K(Z),j=a,f=N):i>0&&k<0?(Q.K(T),j=N,f=c):(Q.K(w).scaleInPlace(-1),j=c,f=a);const p=M.ua[9],R=M.ua[4];j.subtractToRef(E,I),f.subtractToRef(E,p),W.CrossToRef(I,p,R);if(!(W.Dot(R,J)<0))return K.K(E),Math.abs(Y*C);const L=M.ua[5];W.CrossToRef(Q,R,L),L.normalize();const r=M.ua[9];r.K(j).wn(E);const X=r.length();if(X<U.d)return K.K(j),W.Distance(l,j);r.normalizeFromLength(X);const P=W.Dot(L,r),d=M.ua[7];d.K(E).addInPlace(L.scaleInPlace(X*P)),I.K(d).wn(j),Y=Q.length(),Q.normalizeFromLength(Y);let F=W.Dot(I,Q)/Math.max(Y,U.d);return F=(0,S.Clamp)(F,0,1),d.K(j).addInPlace(Q.scaleInPlace(F*Y)),K.K(d),W.Distance(l,d)}static Center(l,a){return W.CenterToRef(l,a,W.Zero())}static CenterToRef(l,a,N){return N.tc((l._x+a._x)/2,(l._y+a._y)/2,(l._z+a._z)/2)}static RotationFromAxis(l,a,N){const U=new W;return W.RotationFromAxisToRef(l,a,N,U),U}static RotationFromAxisToRef(l,a,N,U){const c=M.Quaternion[0];return Y.RotationQuaternionFromAxisToRef(l,a,N,c),c.toEulerAnglesToRef(U),U}}W._V8PerformanceHack=new W(.5,.5,.5),W._UpReadOnly=W.Up(),W._DownReadOnly=W.Down(),W._LeftHandedForwardReadOnly=W.Forward(!1),W._RightHandedForwardReadOnly=W.Forward(!0),W._LeftHandedBackwardReadOnly=W.Backward(!1),W._RightHandedBackwardReadOnly=W.Backward(!0),W._RightReadOnly=W.Right(),W._LeftReadOnly=W.Left(),W._ZeroReadOnly=W.Zero(),W._OneReadOnly=W.One(),Object.defineProperties(W.prototype,{dimension:{value:[3]},rank:{value:1}});class B{get x(){return this._x}set x(l){this._x=l,this._isDirty=!0}get y(){return this._y}set y(l){this._y=l,this._isDirty=!0}get z(){return this._z}set z(l){this._z=l,this._isDirty=!0}get w(){return this._w}set w(l){this._w=l,this._isDirty=!0}constructor(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=l,this._y=a,this._z=N,this._w=U}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let l=H(this._x);return l=397*l^H(this._y),l=397*l^H(this._z),l=397*l^H(this._w),l}Bc(){return[this._x,this._y,this._z,this._w]}toArray(l,a){return void 0===a&&(a=0),l[a]=this._x,l[a+1]=this._y,l[a+2]=this._z,l[a+3]=this._w,this}yN(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B.FromArrayToRef(l,a,this),this}addInPlace(l){return this.x+=l._x,this.y+=l._y,this.z+=l._z,this.w+=l._w,this}addInPlaceFromFloats(l,a,N,U){return this.x+=l,this.y+=a,this.z+=N,this.w+=U,this}add(l){return new B(this._x+l.x,this._y+l.y,this._z+l.z,this._w+l.w)}addToRef(l,a){return a.x=this._x+l.x,a.y=this._y+l.y,a.z=this._z+l.z,a.w=this._w+l.w,a}wn(l){return this.x-=l.x,this.y-=l.y,this.z-=l.z,this.w-=l.w,this}Wa(l){return new B(this._x-l.x,this._y-l.y,this._z-l.z,this._w-l.w)}subtractToRef(l,a){return a.x=this._x-l.x,a.y=this._y-l.y,a.z=this._z-l.z,a.w=this._w-l.w,a}subtractFromFloats(l,a,N,U){return new B(this._x-l,this._y-a,this._z-N,this._w-U)}subtractFromFloatsToRef(l,a,N,U,c){return c.x=this._x-l,c.y=this._y-a,c.z=this._z-N,c.w=this._w-U,c}negate(){return new B(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(l){return l.x=-this._x,l.y=-this._y,l.z=-this._z,l.w=-this._w,l}scaleInPlace(l){return this.x*=l,this.y*=l,this.z*=l,this.w*=l,this}scale(l){return new B(this._x*l,this._y*l,this._z*l,this._w*l)}scaleToRef(l,a){return a.x=this._x*l,a.y=this._y*l,a.z=this._z*l,a.w=this._w*l,a}scaleAndAddToRef(l,a){return a.x+=this._x*l,a.y+=this._y*l,a.z+=this._z*l,a.w+=this._w*l,a}equals(l){return l&&this._x===l.x&&this._y===l.y&&this._z===l.z&&this._w===l.w}equalsWithEpsilon(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:U.d;return l&&(0,S.WithinEpsilon)(this._x,l.x,a)&&(0,S.WithinEpsilon)(this._y,l.y,a)&&(0,S.WithinEpsilon)(this._z,l.z,a)&&(0,S.WithinEpsilon)(this._w,l.w,a)}equalsToFloats(l,a,N,U){return this._x===l&&this._y===a&&this._z===N&&this._w===U}multiplyInPlace(l){return this.x*=l.x,this.y*=l.y,this.z*=l.z,this.w*=l.w,this}multiply(l){return new B(this._x*l.x,this._y*l.y,this._z*l.z,this._w*l.w)}multiplyToRef(l,a){return a.x=this._x*l.x,a.y=this._y*l.y,a.z=this._z*l.z,a.w=this._w*l.w,a}multiplyByFloats(l,a,N,U){return new B(this._x*l,this._y*a,this._z*N,this._w*U)}divide(l){return new B(this._x/l.x,this._y/l.y,this._z/l.z,this._w/l.w)}divideToRef(l,a){return a.x=this._x/l.x,a.y=this._y/l.y,a.z=this._z/l.z,a.w=this._w/l.w,a}divideInPlace(l){return this.divideToRef(l,this)}minimizeInPlace(l){return l.x<this._x&&(this.x=l.x),l.y<this._y&&(this.y=l.y),l.z<this._z&&(this.z=l.z),l.w<this._w&&(this.w=l.w),this}maximizeInPlace(l){return l.x>this._x&&(this.x=l.x),l.y>this._y&&(this.y=l.y),l.z>this._z&&(this.z=l.z),l.w>this._w&&(this.w=l.w),this}minimizeInPlaceFromFloats(l,a,N,U){return this.x=Math.min(l,this._x),this.y=Math.min(a,this._y),this.z=Math.min(N,this._z),this.w=Math.min(U,this._w),this}maximizeInPlaceFromFloats(l,a,N,U){return this.x=Math.max(l,this._x),this.y=Math.max(a,this._y),this.z=Math.max(N,this._z),this.w=Math.max(U,this._w),this}floorToRef(l){return l.x=Math.floor(this._x),l.y=Math.floor(this._y),l.z=Math.floor(this._z),l.w=Math.floor(this._w),l}floor(){return new B(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(l){return l.x=this._x-Math.floor(this._x),l.y=this._y-Math.floor(this._y),l.z=this._z-Math.floor(this._z),l.w=this._w-Math.floor(this._w),l}fract(){return new B(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(l){return 0===l||1===l?this:this.scaleInPlace(1/l)}normalizeToNew(){return this.normalizeToRef(new B)}normalizeToRef(l){const a=this.length();return 0===a||1===a?(l.x=this._x,l.y=this._y,l.z=this._z,l.w=this._w,l):this.scaleToRef(1/a,l)}toVector3(){return new W(this._x,this._y,this._z)}clone(){return new B(this._x,this._y,this._z,this._w)}K(l){return this.x=l.x,this.y=l.y,this.z=l.z,this.w=l.w,this}tc(l,a,N,U){return this.x=l,this.y=a,this.z=N,this.w=U,this}set(l,a,N,U){return this.tc(l,a,N,U)}hc(l){return this.x=this.y=this.z=this.w=l,this}dot(l){return this._x*l.x+this._y*l.y+this._z*l.z+this._w*l.w}static Ma(l,a){return a||(a=0),new B(l[a],l[a+1],l[a+2],l[a+3])}static FromArrayToRef(l,a,N){return N.x=l[a],N.y=l[a+1],N.z=l[a+2],N.w=l[a+3],N}static FromFloatArrayToRef(l,a,N){return B.FromArrayToRef(l,a,N),N}static FromFloatsToRef(l,a,N,U,c){return c.x=l,c.y=a,c.z=N,c.w=U,c}static Zero(){return new B(0,0,0,0)}static One(){return new B(1,1,1,1)}static Random(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new B((0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a))}static RandomToRef(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,N=arguments.length>2?arguments[2]:void 0;return N.x=(0,S.RandomRange)(l,a),N.y=(0,S.RandomRange)(l,a),N.z=(0,S.RandomRange)(l,a),N.w=(0,S.RandomRange)(l,a),N}static Clamp(l,a,N){return B.ClampToRef(l,a,N,new B)}static ClampToRef(l,a,N,U){return U.x=(0,S.Clamp)(l.x,a.x,N.x),U.y=(0,S.Clamp)(l.y,a.y,N.y),U.z=(0,S.Clamp)(l.z,a.z,N.z),U.w=(0,S.Clamp)(l.w,a.w,N.w),U}static CheckExtends(l,a,N){a.minimizeInPlace(l),N.maximizeInPlace(l)}static get ZeroReadOnly(){return B._ZeroReadOnly}static Normalize(l){return B.NormalizeToRef(l,new B)}static NormalizeToRef(l,a){return l.normalizeToRef(a),a}static Minimize(l,a){const N=new B;return N.K(l),N.minimizeInPlace(a),N}static Maximize(l,a){const N=new B;return N.K(l),N.maximizeInPlace(a),N}static Distance(l,a){return Math.sqrt(B.DistanceSquared(l,a))}static DistanceSquared(l,a){const N=l.x-a.x,U=l.y-a.y,c=l.z-a.z,K=l.w-a.w;return N*N+U*U+c*c+K*K}static Center(l,a){return B.CenterToRef(l,a,new B)}static CenterToRef(l,a,N){return N.x=(l.x+a.x)/2,N.y=(l.y+a.y)/2,N.z=(l.z+a.z)/2,N.w=(l.w+a.w)/2,N}static TransformCoordinates(l,a){return B.TransformCoordinatesToRef(l,a,new B)}static TransformCoordinatesToRef(l,a,N){return B.TransformCoordinatesFromFloatsToRef(l._x,l._y,l._z,a,N),N}static TransformCoordinatesFromFloatsToRef(l,a,N,U,c){const K=U.m,Z=l*K[0]+a*K[4]+N*K[8]+K[12],w=l*K[1]+a*K[5]+N*K[9]+K[13],S=l*K[2]+a*K[6]+N*K[10]+K[14],T=l*K[3]+a*K[7]+N*K[11]+K[15];return c.x=Z,c.y=w,c.z=S,c.w=T,c}static TransformNormal(l,a){return B.TransformNormalToRef(l,a,new B)}static TransformNormalToRef(l,a,N){const U=a.m,c=l.x*U[0]+l.y*U[4]+l.z*U[8],K=l.x*U[1]+l.y*U[5]+l.z*U[9],Z=l.x*U[2]+l.y*U[6]+l.z*U[10];return N.x=c,N.y=K,N.z=Z,N.w=l.w,N}static TransformNormalFromFloatsToRef(l,a,N,U,c,K){const Z=c.m;return K.x=l*Z[0]+a*Z[4]+N*Z[8],K.y=l*Z[1]+a*Z[5]+N*Z[9],K.z=l*Z[2]+a*Z[6]+N*Z[10],K.w=U,K}static FromVector3(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new B(l._x,l._y,l._z,a)}static Dot(l,a){return l.x*a.x+l.y*a.y+l.z*a.z+l.w*a.w}}B._V8PerformanceHack=new B(.5,.5,.5,.5),B._ZeroReadOnly=B.Zero(),Object.defineProperties(B.prototype,{dimension:{value:[4]},rank:{value:1}});class Y{get x(){return this._x}set x(l){this._x=l,this._isDirty=!0}get y(){return this._y}set y(l){this._y=l,this._isDirty=!0}get z(){return this._z}set z(l){this._z=l,this._isDirty=!0}get w(){return this._w}set w(l){this._w=l,this._isDirty=!0}constructor(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=l,this._y=a,this._z=N,this._w=U}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let l=H(this._x);return l=397*l^H(this._y),l=397*l^H(this._z),l=397*l^H(this._w),l}Bc(){return[this._x,this._y,this._z,this._w]}toArray(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l[a]=this._x,l[a+1]=this._y,l[a+2]=this._z,l[a+3]=this._w,this}yN(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y.FromArrayToRef(l,a,this)}equals(l){return l&&this._x===l._x&&this._y===l._y&&this._z===l._z&&this._w===l._w}equalsWithEpsilon(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:U.d;return l&&(0,S.WithinEpsilon)(this._x,l._x,a)&&(0,S.WithinEpsilon)(this._y,l._y,a)&&(0,S.WithinEpsilon)(this._z,l._z,a)&&(0,S.WithinEpsilon)(this._w,l._w,a)}isApprox(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:U.d;return l&&((0,S.WithinEpsilon)(this._x,l._x,a)&&(0,S.WithinEpsilon)(this._y,l._y,a)&&(0,S.WithinEpsilon)(this._z,l._z,a)&&(0,S.WithinEpsilon)(this._w,l._w,a)||(0,S.WithinEpsilon)(this._x,-l._x,a)&&(0,S.WithinEpsilon)(this._y,-l._y,a)&&(0,S.WithinEpsilon)(this._z,-l._z,a)&&(0,S.WithinEpsilon)(this._w,-l._w,a))}clone(){return new Y(this._x,this._y,this._z,this._w)}K(l){return this._x=l._x,this._y=l._y,this._z=l._z,this._w=l._w,this._isDirty=!0,this}tc(l,a,N,U){return this._x=l,this._y=a,this._z=N,this._w=U,this._isDirty=!0,this}set(l,a,N,U){return this.tc(l,a,N,U)}hc(l){return this.tc(l,l,l,l)}add(l){return new Y(this._x+l._x,this._y+l._y,this._z+l._z,this._w+l._w)}addInPlace(l){return this._x+=l._x,this._y+=l._y,this._z+=l._z,this._w+=l._w,this._isDirty=!0,this}addToRef(l,a){return a._x=this._x+l._x,a._y=this._y+l._y,a._z=this._z+l._z,a._w=this._w+l._w,a._isDirty=!0,a}addInPlaceFromFloats(l,a,N,U){return this._x+=l,this._y+=a,this._z+=N,this._w+=U,this._isDirty=!0,this}subtractToRef(l,a){return a._x=this._x-l._x,a._y=this._y-l._y,a._z=this._z-l._z,a._w=this._w-l._w,a._isDirty=!0,a}subtractFromFloats(l,a,N,U){return this.subtractFromFloatsToRef(l,a,N,U,new Y)}subtractFromFloatsToRef(l,a,N,U,c){return c._x=this._x-l,c._y=this._y-a,c._z=this._z-N,c._w=this._w-U,c._isDirty=!0,c}Wa(l){return new Y(this._x-l._x,this._y-l._y,this._z-l._z,this._w-l._w)}wn(l){return this._x-=l._x,this._y-=l._y,this._z-=l._z,this._w-=l._w,this._isDirty=!0,this}scale(l){return new Y(this._x*l,this._y*l,this._z*l,this._w*l)}scaleToRef(l,a){return a._x=this._x*l,a._y=this._y*l,a._z=this._z*l,a._w=this._w*l,a._isDirty=!0,a}scaleInPlace(l){return this._x*=l,this._y*=l,this._z*=l,this._w*=l,this._isDirty=!0,this}scaleAndAddToRef(l,a){return a._x+=this._x*l,a._y+=this._y*l,a._z+=this._z*l,a._w+=this._w*l,a._isDirty=!0,a}multiply(l){const a=new Y(0,0,0,1);return this.multiplyToRef(l,a),a}multiplyToRef(l,a){const N=this._x*l._w+this._y*l._z-this._z*l._y+this._w*l._x,U=-this._x*l._z+this._y*l._w+this._z*l._x+this._w*l._y,c=this._x*l._y-this._y*l._x+this._z*l._w+this._w*l._z,K=-this._x*l._x-this._y*l._y-this._z*l._z+this._w*l._w;return a.tc(N,U,c,K),a}multiplyInPlace(l){return this.multiplyToRef(l,this)}multiplyByFloats(l,a,N,U){return this._x*=l,this._y*=a,this._z*=N,this._w*=U,this._isDirty=!0,this}divide(l){throw new ReferenceError("Can not divide a quaternion")}divideToRef(l,a){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(l){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new Y)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(l){return l._x=-this._x,l._y=-this._y,l._z=-this._z,l._w=-this._w,l._isDirty=!0,l}equalsToFloats(l,a,N,U){return this._x===l&&this._y===a&&this._z===N&&this._w===U}floorToRef(l){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(l){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(l){return l.tc(-this._x,-this._y,-this._z,this._w),l}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new Y(-this._x,-this._y,-this._z,this._w)}invert(){const l=this.conjugate(),a=this.lengthSquared();return 0==a||1==a||l.scaleInPlace(1/a),l}invertInPlace(){this.conjugateInPlace();const l=this.lengthSquared();return 0==l||1==l||this.scaleInPlace(1/l),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(l){return 0===l||1===l?this:this.scaleInPlace(1/l)}normalizeToNew(){const l=new Y(0,0,0,1);return this.normalizeToRef(l),l}normalizeToRef(l){const a=this.length();return 0===a||1===a?l.tc(this._x,this._y,this._z,this._w):this.scaleToRef(1/a,l)}toEulerAngles(){const l=W.Zero();return this.toEulerAnglesToRef(l),l}toEulerAnglesToRef(l){const a=this._z,N=this._x,U=this._y,c=this._w,K=U*a-N*c,Z=.4999999;if(K<-Z)l._y=2*Math.atan2(U,c),l._x=Math.PI/2,l._z=0,l._isDirty=!0;else if(K>Z)l._y=2*Math.atan2(U,c),l._x=-Math.PI/2,l._z=0,l._isDirty=!0;else{const Z=c*c,w=a*a,S=N*N,T=U*U;l._z=Math.atan2(2*(N*U+a*c),-w-S+T+Z),l._x=Math.asin(-2*K),l._y=Math.atan2(2*(a*N+U*c),w-S-T+Z),l._isDirty=!0}return l}toAlphaBetaGammaToRef(l){const a=this._z,N=this._x,U=this._y,c=this._w,K=Math.sqrt(N*N+U*U),Z=Math.sqrt(a*a+c*c),w=2*Math.atan2(K,Z),S=2*Math.atan2(a,c),T=2*Math.atan2(U,N),J=(S+T)/2,n=(S-T)/2;return l.set(n,w,J),l}toRotationMatrix(l){return C.FromQuaternionToRef(this,l),l}fromRotationMatrix(l){return Y.FromRotationMatrixToRef(l,this),this}dot(l){return this._x*l._x+this._y*l._y+this._z*l._z+this._w*l._w}toAxisAngle(){const l=W.Zero();return{axis:l,angle:this.toAxisAngleToRef(l)}}toAxisAngleToRef(l){let a=0;const N=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),U=this._w;return N>0?(a=2*Math.atan2(N,U),l.set(this._x/N,this._y/N,this._z/N)):(a=0,l.set(1,0,0)),a}static FromRotationMatrix(l){const a=new Y;return Y.FromRotationMatrixToRef(l,a),a}static FromRotationMatrixToRef(l,a){const N=l.m,U=N[0],c=N[4],K=N[8],Z=N[1],w=N[5],S=N[9],T=N[2],J=N[6],n=N[10],y=U+w+n;let H;return y>0?(H=.5/Math.sqrt(y+1),a._w=.25/H,a._x=(J-S)*H,a._y=(K-T)*H,a._z=(Z-c)*H,a._isDirty=!0):U>w&&U>n?(H=2*Math.sqrt(1+U-w-n),a._w=(J-S)/H,a._x=.25*H,a._y=(c+Z)/H,a._z=(K+T)/H,a._isDirty=!0):w>n?(H=2*Math.sqrt(1+w-U-n),a._w=(K-T)/H,a._x=(c+Z)/H,a._y=.25*H,a._z=(S+J)/H,a._isDirty=!0):(H=2*Math.sqrt(1+n-U-w),a._w=(Z-c)/H,a._x=(K+T)/H,a._y=(S+J)/H,a._z=.25*H,a._isDirty=!0),a}static Dot(l,a){return l._x*a._x+l._y*a._y+l._z*a._z+l._w*a._w}static AreClose(l,a){let N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const U=Y.Dot(l,a);return 1-U*U<=N}static SmoothToRef(l,a,N,U,c){let K=0===U?1:N/U;return K=(0,S.Clamp)(K,0,1),Y.SlerpToRef(l,a,K,c),c}static Zero(){return new Y(0,0,0,0)}static Inverse(l){return new Y(-l._x,-l._y,-l._z,l._w)}static InverseToRef(l,a){return a.set(-l._x,-l._y,-l._z,l._w),a}static Identity(){return new Y(0,0,0,1)}static IsIdentity(l){return l&&0===l._x&&0===l._y&&0===l._z&&1===l._w}static RotationAxis(l,a){return Y.RotationAxisToRef(l,a,new Y)}static RotationAxisToRef(l,a,N){N._w=Math.cos(a/2);const U=Math.sin(a/2)/l.length();return N._x=l._x*U,N._y=l._y*U,N._z=l._z*U,N._isDirty=!0,N}static Ma(l,a){return a||(a=0),new Y(l[a],l[a+1],l[a+2],l[a+3])}static FromArrayToRef(l,a,N){return N._x=l[a],N._y=l[a+1],N._z=l[a+2],N._w=l[a+3],N._isDirty=!0,N}static FromFloatsToRef(l,a,N,U,c){return c.tc(l,a,N,U),c}static FromEulerAngles(l,a,N){const U=new Y;return Y.RotationYawPitchRollToRef(a,l,N,U),U}static FromEulerAnglesToRef(l,a,N,U){return Y.RotationYawPitchRollToRef(a,l,N,U),U}static FromEulerVector(l){const a=new Y;return Y.RotationYawPitchRollToRef(l._y,l._x,l._z,a),a}static FromEulerVectorToRef(l,a){return Y.RotationYawPitchRollToRef(l._y,l._x,l._z,a),a}static FromUnitVectorsToRef(l,a,N){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:U.d;const K=W.Dot(l,a)+1;return K<c?Math.abs(l.x)>Math.abs(l.z)?N.set(-l.y,l.x,0,0):N.set(0,-l.z,l.y,0):(W.CrossToRef(l,a,A.ua[0]),N.set(A.ua[0].x,A.ua[0].y,A.ua[0].z,K)),N.normalize()}static RotationYawPitchRoll(l,a,N){const U=new Y;return Y.RotationYawPitchRollToRef(l,a,N,U),U}static RotationYawPitchRollToRef(l,a,N,U){const c=.5*N,K=.5*a,Z=.5*l,w=Math.sin(c),S=Math.cos(c),T=Math.sin(K),J=Math.cos(K),n=Math.sin(Z),y=Math.cos(Z);return U._x=y*T*S+n*J*w,U._y=n*J*S-y*T*w,U._z=y*J*w-n*T*S,U._w=y*J*S+n*T*w,U._isDirty=!0,U}static RotationAlphaBetaGamma(l,a,N){const U=new Y;return Y.RotationAlphaBetaGammaToRef(l,a,N,U),U}static RotationAlphaBetaGammaToRef(l,a,N,U){const c=.5*(N+l),K=.5*(N-l),Z=.5*a;return U._x=Math.cos(K)*Math.sin(Z),U._y=Math.sin(K)*Math.sin(Z),U._z=Math.sin(c)*Math.cos(Z),U._w=Math.cos(c)*Math.cos(Z),U._isDirty=!0,U}static RotationQuaternionFromAxis(l,a,N){const U=new Y(0,0,0,0);return Y.RotationQuaternionFromAxisToRef(l,a,N,U),U}static RotationQuaternionFromAxisToRef(l,a,N,U){const c=M.Matrix[0];return l=l.normalizeToRef(M.ua[0]),a=a.normalizeToRef(M.ua[1]),N=N.normalizeToRef(M.ua[2]),C.FromXYZAxesToRef(l,a,N,c),Y.FromRotationMatrixToRef(c,U),U}static FromLookDirectionLH(l,a){const N=new Y;return Y.FromLookDirectionLHToRef(l,a,N),N}static FromLookDirectionLHToRef(l,a,N){const U=M.Matrix[0];return C.LookDirectionLHToRef(l,a,U),Y.FromRotationMatrixToRef(U,N),N}static FromLookDirectionRH(l,a){const N=new Y;return Y.FromLookDirectionRHToRef(l,a,N),N}static FromLookDirectionRHToRef(l,a,N){const U=M.Matrix[0];return C.LookDirectionRHToRef(l,a,U),Y.FromRotationMatrixToRef(U,N)}static Slerp(l,a,N){const U=Y.Identity();return Y.SlerpToRef(l,a,N,U),U}static SlerpToRef(l,a,N,U){let c,K,Z=l._x*a._x+l._y*a._y+l._z*a._z+l._w*a._w,w=!1;if(Z<0&&(w=!0,Z=-Z),Z>.999999)K=1-N,c=w?-N:N;else{const l=Math.acos(Z),a=1/Math.sin(l);K=Math.sin((1-N)*l)*a,c=w?-Math.sin(N*l)*a:Math.sin(N*l)*a}return U._x=K*l._x+c*a._x,U._y=K*l._y+c*a._y,U._z=K*l._z+c*a._z,U._w=K*l._w+c*a._w,U._isDirty=!0,U}static Hermite(l,a,N,U,c){const K=c*c,Z=c*K,w=2*Z-3*K+1,S=-2*Z+3*K,T=Z-2*K+c,J=Z-K,n=l._x*w+N._x*S+a._x*T+U._x*J,y=l._y*w+N._y*S+a._y*T+U._y*J,H=l._z*w+N._z*S+a._z*T+U._z*J,u=l._w*w+N._w*S+a._w*T+U._w*J;return new Y(n,y,H,u)}static Hermite1stDerivative(l,a,N,U,c){const K=new Y;return this.Hermite1stDerivativeToRef(l,a,N,U,c,K),K}static Hermite1stDerivativeToRef(l,a,N,U,c,K){const Z=c*c;return K._x=6*(Z-c)*l._x+(3*Z-4*c+1)*a._x+6*(-Z+c)*N._x+(3*Z-2*c)*U._x,K._y=6*(Z-c)*l._y+(3*Z-4*c+1)*a._y+6*(-Z+c)*N._y+(3*Z-2*c)*U._y,K._z=6*(Z-c)*l._z+(3*Z-4*c+1)*a._z+6*(-Z+c)*N._z+(3*Z-2*c)*U._z,K._w=6*(Z-c)*l._w+(3*Z-4*c+1)*a._w+6*(-Z+c)*N._w+(3*Z-2*c)*U._w,K._isDirty=!0,K}static Normalize(l){const a=Y.Zero();return Y.NormalizeToRef(l,a),a}static NormalizeToRef(l,a){return l.normalizeToRef(a),a}static Clamp(l,a,N){const U=new Y;return Y.ClampToRef(l,a,N,U),U}static ClampToRef(l,a,N,U){return U.tc((0,S.Clamp)(l.x,a.x,N.x),(0,S.Clamp)(l.y,a.y,N.y),(0,S.Clamp)(l.z,a.z,N.z),(0,S.Clamp)(l.w,a.w,N.w))}static Random(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Y((0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a))}static RandomToRef(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).tc((0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a),(0,S.RandomRange)(l,a))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(l,a){return Math.sqrt(Y.DistanceSquared(l,a))}static DistanceSquared(l,a){const N=l.x-a.x,U=l.y-a.y,c=l.z-a.z,K=l.w-a.w;return N*N+U*U+c*c+K*K}static Center(l,a){return Y.CenterToRef(l,a,Y.Zero())}static CenterToRef(l,a,N){return N.tc((l.x+a.x)/2,(l.y+a.y)/2,(l.z+a.z)/2,(l.w+a.w)/2)}}Y._V8PerformanceHack=new Y(.5,.5,.5,.5),Object.defineProperties(Y.prototype,{dimension:{value:[4]},rank:{value:1}});class C{static get Use64Bits(){return Z.d.MatrixUse64Bits}get m(){return this.nc}markAsUpdated(){this.updateFlag=T._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(l){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1],N=arguments.length>2&&void 0!==arguments[2]&&arguments[2],U=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=l,this._isIdentity3x2=l||N,this._isIdentityDirty=!this._isIdentity&&a,this._isIdentity3x2Dirty=!this._isIdentity3x2&&U}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,Z.d.MatrixTrackPrecisionChange&&Z.d.MatrixTrackedMatrices.push(this),this.nc=new Z.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const l=this.nc;this._isIdentity=1===l[0]&&0===l[1]&&0===l[2]&&0===l[3]&&0===l[4]&&1===l[5]&&0===l[6]&&0===l[7]&&0===l[8]&&0===l[9]&&1===l[10]&&0===l[11]&&0===l[12]&&0===l[13]&&0===l[14]&&1===l[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.nc[0]||1!==this.nc[5]||1!==this.nc[15]||0!==this.nc[1]||0!==this.nc[2]||0!==this.nc[3]||0!==this.nc[4]||0!==this.nc[6]||0!==this.nc[7]||0!==this.nc[8]||0!==this.nc[9]||0!==this.nc[10]||0!==this.nc[11]||0!==this.nc[12]||0!==this.nc[13]||0!==this.nc[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const l=this.nc,a=l[0],N=l[1],U=l[2],c=l[3],K=l[4],Z=l[5],w=l[6],S=l[7],T=l[8],J=l[9],n=l[10],y=l[11],H=l[12],u=l[13],W=l[14],B=l[15],Y=n*B-W*y,C=J*B-u*y,M=J*W-u*n,A=T*B-H*y,E=T*W-n*H,q=T*u-H*J;return a*+(Z*Y-w*C+S*M)+N*-(K*Y-w*A+S*E)+U*+(K*C-Z*A+S*q)+c*-(K*M-Z*E+w*q)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!l)return this.nc;const N=this.nc;for(let U=0;U<16;U++)l[a+U]=N[U];return this}Bc(){return this.nc}yN(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C.FromArrayToRef(l,a,this)}tc(){for(var l=arguments.length,a=new Array(l),N=0;N<l;N++)a[N]=arguments[N];return C.FromArrayToRef(a,0,this)}set(){const l=this.nc;for(let a=0;a<16;a++)l[a]=a<0||arguments.length<=a?void 0:arguments[a];return this.markAsUpdated(),this}hc(l){const a=this.nc;for(let N=0;N<16;N++)a[N]=l;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return C.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(l){const a=new C;return this.addToRef(l,a),a}addToRef(l,a){const N=this.nc,U=a.nc,c=l.m;for(let K=0;K<16;K++)U[K]=N[K]+c[K];return a.markAsUpdated(),a}addToSelf(l){const a=this.nc,N=l.m;return a[0]+=N[0],a[1]+=N[1],a[2]+=N[2],a[3]+=N[3],a[4]+=N[4],a[5]+=N[5],a[6]+=N[6],a[7]+=N[7],a[8]+=N[8],a[9]+=N[9],a[10]+=N[10],a[11]+=N[11],a[12]+=N[12],a[13]+=N[13],a[14]+=N[14],a[15]+=N[15],this.markAsUpdated(),this}addInPlace(l){const a=this.nc,N=l.m;for(let U=0;U<16;U++)a[U]+=N[U];return this.markAsUpdated(),this}addInPlaceFromFloats(){const l=this.nc;for(let a=0;a<16;a++)l[a]+=a<0||arguments.length<=a?void 0:arguments[a];return this.markAsUpdated(),this}Wa(l){const a=this.nc,N=l.m;for(let U=0;U<16;U++)a[U]-=N[U];return this.markAsUpdated(),this}subtractToRef(l,a){const N=this.nc,U=l.m,c=a.nc;for(let K=0;K<16;K++)c[K]=N[K]-U[K];return a.markAsUpdated(),a}wn(l){const a=this.nc,N=l.m;for(let U=0;U<16;U++)a[U]-=N[U];return this.markAsUpdated(),this}subtractFromFloats(){for(var l=arguments.length,a=new Array(l),N=0;N<l;N++)a[N]=arguments[N];return this.subtractFromFloatsToRef(...a,new C)}subtractFromFloatsToRef(){for(var l=arguments.length,a=new Array(l),N=0;N<l;N++)a[N]=arguments[N];const U=a.pop(),c=this.nc,K=U.nc,Z=a;for(let w=0;w<16;w++)K[w]=c[w]-Z[w];return U.markAsUpdated(),U}invertToRef(l){return!0===this._isIdentity?(C.IdentityToRef(l),l):(y(this,l.Bc())?l.markAsUpdated():l.K(this),l)}addAtIndex(l,a){return this.nc[l]+=a,this.markAsUpdated(),this}multiplyAtIndex(l,a){return this.nc[l]*=a,this.markAsUpdated(),this}setTranslationFromFloats(l,a,N){return this.nc[12]=l,this.nc[13]=a,this.nc[14]=N,this.markAsUpdated(),this}addTranslationFromFloats(l,a,N){return this.nc[12]+=l,this.nc[13]+=a,this.nc[14]+=N,this.markAsUpdated(),this}setTranslation(l){return this.setTranslationFromFloats(l._x,l._y,l._z)}getTranslation(){return new W(this.nc[12],this.nc[13],this.nc[14])}getTranslationToRef(l){return l.x=this.nc[12],l.y=this.nc[13],l.z=this.nc[14],l}removeRotationAndScaling(){const l=this.m;return C.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,l[12],l[13],l[14],l[15],this),this._updateIdentityStatus(0===l[12]&&0===l[13]&&0===l[14]&&1===l[15]),this}K(l){l.copyToArray(this.nc);const a=l;return this.updateFlag=a.updateFlag,this._updateIdentityStatus(a._isIdentity,a._isIdentityDirty,a._isIdentity3x2,a._isIdentity3x2Dirty),this}copyToArray(l){return n(this,l,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(l){const a=new C;return this.multiplyToRef(l,a),a}multiplyInPlace(l){const a=this.nc,N=l.m;for(let U=0;U<16;U++)a[U]*=N[U];return this.markAsUpdated(),this}multiplyByFloats(){const l=this.nc;for(let a=0;a<16;a++)l[a]*=a<0||arguments.length<=a?void 0:arguments[a];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var l=arguments.length,a=new Array(l),N=0;N<l;N++)a[N]=arguments[N];const U=a.pop(),c=this.nc,K=U.nc,Z=a;for(let w=0;w<16;w++)K[w]=c[w]*Z[w];return U.markAsUpdated(),U}multiplyToRef(l,a){return this._isIdentity?(a.K(l),a):l._isIdentity?(a.K(this),a):(this.multiplyToArray(l,a.nc,0),a.markAsUpdated(),a)}multiplyToArray(l,a,N){return J(this,l,a,N),this}divide(l){return this.divideToRef(l,new C)}divideToRef(l,a){const N=this.nc,U=l.m,c=a.nc;for(let K=0;K<16;K++)c[K]=N[K]/U[K];return a.markAsUpdated(),a}divideInPlace(l){const a=this.nc,N=l.m;for(let U=0;U<16;U++)a[U]/=N[U];return this.markAsUpdated(),this}minimizeInPlace(l){const a=this.nc,N=l.m;for(let U=0;U<16;U++)a[U]=Math.min(a[U],N[U]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const l=this.nc;for(let a=0;a<16;a++)l[a]=Math.min(l[a],a<0||arguments.length<=a?void 0:arguments[a]);return this.markAsUpdated(),this}maximizeInPlace(l){const a=this.nc,N=l.m;for(let U=0;U<16;U++)a[U]=Math.min(a[U],N[U]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const l=this.nc;for(let a=0;a<16;a++)l[a]=Math.min(l[a],a<0||arguments.length<=a?void 0:arguments[a]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new C)}negateInPlace(){const l=this.nc;for(let a=0;a<16;a++)l[a]=-l[a];return this.markAsUpdated(),this}negateToRef(l){const a=this.nc,N=l.nc;for(let U=0;U<16;U++)N[U]=-a[U];return l.markAsUpdated(),l}equals(l){const a=l;if(!a)return!1;if((this._isIdentity||a._isIdentity)&&!this._isIdentityDirty&&!a._isIdentityDirty)return this._isIdentity&&a._isIdentity;const N=this.m,U=a.m;return N[0]===U[0]&&N[1]===U[1]&&N[2]===U[2]&&N[3]===U[3]&&N[4]===U[4]&&N[5]===U[5]&&N[6]===U[6]&&N[7]===U[7]&&N[8]===U[8]&&N[9]===U[9]&&N[10]===U[10]&&N[11]===U[11]&&N[12]===U[12]&&N[13]===U[13]&&N[14]===U[14]&&N[15]===U[15]}equalsWithEpsilon(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const N=this.nc,U=l.m;for(let c=0;c<16;c++)if(!(0,S.WithinEpsilon)(N[c],U[c],a))return!1;return!0}equalsToFloats(){const l=this.nc;for(let a=0;a<16;a++)if(l[a]!=(a<0||arguments.length<=a?void 0:arguments[a]))return!1;return!0}floor(){return this.floorToRef(new C)}floorToRef(l){const a=this.nc,N=l.nc;for(let U=0;U<16;U++)N[U]=Math.floor(a[U]);return l.markAsUpdated(),l}fract(){return this.fractToRef(new C)}fractToRef(l){const a=this.nc,N=l.nc;for(let U=0;U<16;U++)N[U]=a[U]-Math.floor(a[U]);return l.markAsUpdated(),l}clone(){const l=new C;return l.K(this),l}getClassName(){return"Matrix"}getHashCode(){let l=H(this.nc[0]);for(let a=1;a<16;a++)l=397*l^H(this.nc[a]);return l}decomposeToTransformNode(l){return l.rotationQuaternion=l.rotationQuaternion||new Y,this.decompose(l.Oc,l.rotationQuaternion,l.position)}decompose(l,a,N,U){let c=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return N&&N.hc(0),l&&l.hc(1),a&&a.tc(0,0,0,1),!0;const K=this.nc;if(N&&N.tc(K[12],K[13],K[14]),(l=l||M.ua[0]).x=Math.sqrt(K[0]*K[0]+K[1]*K[1]+K[2]*K[2]),l.y=Math.sqrt(K[4]*K[4]+K[5]*K[5]+K[6]*K[6]),l.z=Math.sqrt(K[8]*K[8]+K[9]*K[9]+K[10]*K[10]),U){const a=(c?U.absoluteScaling.x:U.Oc.x)<0?-1:1,N=(c?U.absoluteScaling.y:U.Oc.y)<0?-1:1,K=(c?U.absoluteScaling.z:U.Oc.z)<0?-1:1;l.x*=a,l.y*=N,l.z*=K}else this.determinant()<=0&&(l.y*=-1);if(0===l._x||0===l._y||0===l._z)return a&&a.tc(0,0,0,1),!1;if(a){const N=1/l._x,U=1/l._y,c=1/l._z;C.FromValuesToRef(K[0]*N,K[1]*N,K[2]*N,0,K[4]*U,K[5]*U,K[6]*U,0,K[8]*c,K[9]*c,K[10]*c,0,0,0,0,1,M.Matrix[0]),Y.FromRotationMatrixToRef(M.Matrix[0],a)}return!0}getRow(l){if(l<0||l>3)return null;const a=4*l;return new B(this.nc[a+0],this.nc[a+1],this.nc[a+2],this.nc[a+3])}getRowToRef(l,a){if(l>=0&&l<=3){const N=4*l;a.x=this.nc[N+0],a.y=this.nc[N+1],a.z=this.nc[N+2],a.w=this.nc[N+3]}return a}setRow(l,a){return this.setRowFromFloats(l,a.x,a.y,a.z,a.w)}transpose(){const l=new C;return C.TransposeToRef(this,l),l}transposeToRef(l){return C.TransposeToRef(this,l),l}setRowFromFloats(l,a,N,U,c){if(l<0||l>3)return this;const K=4*l;return this.nc[K+0]=a,this.nc[K+1]=N,this.nc[K+2]=U,this.nc[K+3]=c,this.markAsUpdated(),this}scale(l){const a=new C;return this.scaleToRef(l,a),a}scaleToRef(l,a){for(let N=0;N<16;N++)a.nc[N]=this.nc[N]*l;return a.markAsUpdated(),a}scaleAndAddToRef(l,a){for(let N=0;N<16;N++)a.nc[N]+=this.nc[N]*l;return a.markAsUpdated(),a}scaleInPlace(l){const a=this.nc;for(let N=0;N<16;N++)a[N]*=l;return this.markAsUpdated(),this}toNormalMatrix(l){const a=M.Matrix[0];this.invertToRef(a),a.transposeToRef(l);const N=l.nc;return C.FromValuesToRef(N[0],N[1],N[2],0,N[4],N[5],N[6],0,N[8],N[9],N[10],0,0,0,0,1,l),l}getRotationMatrix(){const l=new C;return this.getRotationMatrixToRef(l),l}getRotationMatrixToRef(l){const a=M.ua[0];if(!this.decompose(a))return C.IdentityToRef(l),l;const N=this.nc,U=1/a._x,c=1/a._y,K=1/a._z;return C.FromValuesToRef(N[0]*U,N[1]*U,N[2]*U,0,N[4]*c,N[5]*c,N[6]*c,0,N[8]*K,N[9]*K,N[10]*K,0,0,0,0,1,l),l}toggleModelMatrixHandInPlace(){const l=this.nc;return l[2]*=-1,l[6]*=-1,l[8]*=-1,l[9]*=-1,l[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const l=this.nc;return l[8]*=-1,l[9]*=-1,l[10]*=-1,l[11]*=-1,this.markAsUpdated(),this}static Ma(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const N=new C;return C.FromArrayToRef(l,a,N),N}static FromArrayToRef(l,a,N){for(let U=0;U<16;U++)N.nc[U]=l[U+a];return N.markAsUpdated(),N}static FromFloat32ArrayToRefScaled(l,a,N,U){return U.nc[0]=l[0+a]*N,U.nc[1]=l[1+a]*N,U.nc[2]=l[2+a]*N,U.nc[3]=l[3+a]*N,U.nc[4]=l[4+a]*N,U.nc[5]=l[5+a]*N,U.nc[6]=l[6+a]*N,U.nc[7]=l[7+a]*N,U.nc[8]=l[8+a]*N,U.nc[9]=l[9+a]*N,U.nc[10]=l[10+a]*N,U.nc[11]=l[11+a]*N,U.nc[12]=l[12+a]*N,U.nc[13]=l[13+a]*N,U.nc[14]=l[14+a]*N,U.nc[15]=l[15+a]*N,U.markAsUpdated(),U}static get IdentityReadOnly(){return C._IdentityReadOnly}static FromValuesToRef(l,a,N,U,c,K,Z,w,S,T,J,n,y,H,u,W,B){const Y=B.nc;Y[0]=l,Y[1]=a,Y[2]=N,Y[3]=U,Y[4]=c,Y[5]=K,Y[6]=Z,Y[7]=w,Y[8]=S,Y[9]=T,Y[10]=J,Y[11]=n,Y[12]=y,Y[13]=H,Y[14]=u,Y[15]=W,B.markAsUpdated()}static FromValues(l,a,N,U,c,K,Z,w,S,T,J,n,y,H,u,W){const B=new C,Y=B.nc;return Y[0]=l,Y[1]=a,Y[2]=N,Y[3]=U,Y[4]=c,Y[5]=K,Y[6]=Z,Y[7]=w,Y[8]=S,Y[9]=T,Y[10]=J,Y[11]=n,Y[12]=y,Y[13]=H,Y[14]=u,Y[15]=W,B.markAsUpdated(),B}static Compose(l,a,N){const U=new C;return C.ComposeToRef(l,a,N,U),U}static ComposeToRef(l,a,N,U){const c=U.nc,K=a._x,Z=a._y,w=a._z,S=a._w,T=K+K,J=Z+Z,n=w+w,y=K*T,H=K*J,u=K*n,W=Z*J,B=Z*n,Y=w*n,C=S*T,M=S*J,A=S*n,E=l._x,q=l._y,b=l._z;return c[0]=(1-(W+Y))*E,c[1]=(H+A)*E,c[2]=(u-M)*E,c[3]=0,c[4]=(H-A)*q,c[5]=(1-(y+Y))*q,c[6]=(B+C)*q,c[7]=0,c[8]=(u+M)*b,c[9]=(B-C)*b,c[10]=(1-(y+W))*b,c[11]=0,c[12]=N._x,c[13]=N._y,c[14]=N._z,c[15]=1,U.markAsUpdated(),U}static Identity(){const l=C.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return l._updateIdentityStatus(!0),l}static IdentityToRef(l){return C.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,l),l._updateIdentityStatus(!0),l}static Zero(){const l=C.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return l._updateIdentityStatus(!1),l}static RotationX(l){const a=new C;return C.RotationXToRef(l,a),a}static Invert(l){const a=new C;return l.invertToRef(a),a}static RotationXToRef(l,a){const N=Math.sin(l),U=Math.cos(l);return C.FromValuesToRef(1,0,0,0,0,U,N,0,0,-N,U,0,0,0,0,1,a),a._updateIdentityStatus(1===U&&0===N),a}static RotationY(l){const a=new C;return C.RotationYToRef(l,a),a}static RotationYToRef(l,a){const N=Math.sin(l),U=Math.cos(l);return C.FromValuesToRef(U,0,-N,0,0,1,0,0,N,0,U,0,0,0,0,1,a),a._updateIdentityStatus(1===U&&0===N),a}static RotationZ(l){const a=new C;return C.RotationZToRef(l,a),a}static RotationZToRef(l,a){const N=Math.sin(l),U=Math.cos(l);return C.FromValuesToRef(U,N,0,0,-N,U,0,0,0,0,1,0,0,0,0,1,a),a._updateIdentityStatus(1===U&&0===N),a}static RotationAxis(l,a){const N=new C;return C.RotationAxisToRef(l,a,N),N}static RotationAxisToRef(l,a,N){const U=Math.sin(-a),c=Math.cos(-a),K=1-c;l=l.normalizeToRef(M.ua[0]);const Z=N.nc;return Z[0]=l._x*l._x*K+c,Z[1]=l._x*l._y*K-l._z*U,Z[2]=l._x*l._z*K+l._y*U,Z[3]=0,Z[4]=l._y*l._x*K+l._z*U,Z[5]=l._y*l._y*K+c,Z[6]=l._y*l._z*K-l._x*U,Z[7]=0,Z[8]=l._z*l._x*K-l._y*U,Z[9]=l._z*l._y*K+l._x*U,Z[10]=l._z*l._z*K+c,Z[11]=0,Z[12]=0,Z[13]=0,Z[14]=0,Z[15]=1,N.markAsUpdated(),N}static RotationAlignToRef(l,a,N){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const K=W.Dot(a,l),Z=N.nc;if(K<-1+U.d)Z[0]=-1,Z[1]=0,Z[2]=0,Z[3]=0,Z[4]=0,Z[5]=c?1:-1,Z[6]=0,Z[7]=0,Z[8]=0,Z[9]=0,Z[10]=c?-1:1,Z[11]=0;else{const N=W.Cross(a,l),U=1/(1+K);Z[0]=N._x*N._x*U+K,Z[1]=N._y*N._x*U-N._z,Z[2]=N._z*N._x*U+N._y,Z[3]=0,Z[4]=N._x*N._y*U+N._z,Z[5]=N._y*N._y*U+K,Z[6]=N._z*N._y*U-N._x,Z[7]=0,Z[8]=N._x*N._z*U-N._y,Z[9]=N._y*N._z*U+N._x,Z[10]=N._z*N._z*U+K,Z[11]=0}return Z[12]=0,Z[13]=0,Z[14]=0,Z[15]=1,N.markAsUpdated(),N}static RotationYawPitchRoll(l,a,N){const U=new C;return C.RotationYawPitchRollToRef(l,a,N,U),U}static RotationYawPitchRollToRef(l,a,N,U){return Y.RotationYawPitchRollToRef(l,a,N,M.Quaternion[0]),M.Quaternion[0].toRotationMatrix(U),U}static Scaling(l,a,N){const U=new C;return C.ScalingToRef(l,a,N,U),U}static ScalingToRef(l,a,N,U){return C.FromValuesToRef(l,0,0,0,0,a,0,0,0,0,N,0,0,0,0,1,U),U._updateIdentityStatus(1===l&&1===a&&1===N),U}static Translation(l,a,N){const U=new C;return C.TranslationToRef(l,a,N,U),U}static TranslationToRef(l,a,N,U){return C.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,l,a,N,1,U),U._updateIdentityStatus(0===l&&0===a&&0===N),U}static Lerp(l,a,N){const U=new C;return C.LerpToRef(l,a,N,U),U}static LerpToRef(l,a,N,U){const c=U.nc,K=l.m,Z=a.m;for(let w=0;w<16;w++)c[w]=K[w]*(1-N)+Z[w]*N;return U.markAsUpdated(),U}static DecomposeLerp(l,a,N){const U=new C;return C.DecomposeLerpToRef(l,a,N,U),U}static DecomposeLerpToRef(l,a,N,U){const c=M.ua[0],K=M.Quaternion[0],Z=M.ua[1];l.decompose(c,K,Z);const w=M.ua[2],S=M.Quaternion[1],T=M.ua[3];a.decompose(w,S,T);const J=M.ua[4];W.LerpToRef(c,w,N,J);const n=M.Quaternion[2];Y.SlerpToRef(K,S,N,n);const y=M.ua[5];return W.LerpToRef(Z,T,N,y),C.ComposeToRef(J,n,y,U),U}static LookAtLH(l,a,N){const U=new C;return C.LookAtLHToRef(l,a,N,U),U}static LookAtLHToRef(l,a,N,U){const c=M.ua[0],K=M.ua[1],Z=M.ua[2];a.subtractToRef(l,Z),Z.normalize(),W.CrossToRef(N,Z,c);const w=c.lengthSquared();0===w?c.x=1:c.normalizeFromLength(Math.sqrt(w)),W.CrossToRef(Z,c,K),K.normalize();const S=-W.Dot(c,l),T=-W.Dot(K,l),J=-W.Dot(Z,l);return C.FromValuesToRef(c._x,K._x,Z._x,0,c._y,K._y,Z._y,0,c._z,K._z,Z._z,0,S,T,J,1,U),U}static LookAtRH(l,a,N){const U=new C;return C.LookAtRHToRef(l,a,N,U),U}static LookAtRHToRef(l,a,N,U){const c=M.ua[0],K=M.ua[1],Z=M.ua[2];l.subtractToRef(a,Z),Z.normalize(),W.CrossToRef(N,Z,c);const w=c.lengthSquared();0===w?c.x=1:c.normalizeFromLength(Math.sqrt(w)),W.CrossToRef(Z,c,K),K.normalize();const S=-W.Dot(c,l),T=-W.Dot(K,l),J=-W.Dot(Z,l);return C.FromValuesToRef(c._x,K._x,Z._x,0,c._y,K._y,Z._y,0,c._z,K._z,Z._z,0,S,T,J,1,U),U}static LookDirectionLH(l,a){const N=new C;return C.LookDirectionLHToRef(l,a,N),N}static LookDirectionLHToRef(l,a,N){const U=M.ua[0];U.K(l),U.scaleInPlace(-1);const c=M.ua[1];return W.CrossToRef(a,U,c),C.FromValuesToRef(c._x,c._y,c._z,0,a._x,a._y,a._z,0,U._x,U._y,U._z,0,0,0,0,1,N),N}static LookDirectionRH(l,a){const N=new C;return C.LookDirectionRHToRef(l,a,N),N}static LookDirectionRHToRef(l,a,N){const U=M.ua[2];return W.CrossToRef(a,l,U),C.FromValuesToRef(U._x,U._y,U._z,0,a._x,a._y,a._z,0,l._x,l._y,l._z,0,0,0,0,1,N),N}static OrthoLH(l,a,N,U,c){const K=new C;return C.OrthoLHToRef(l,a,N,U,K,c),K}static OrthoLHToRef(l,a,N,U,c,K){const Z=2/l,w=2/a,S=2/(U-N),T=-(U+N)/(U-N);return C.FromValuesToRef(Z,0,0,0,0,w,0,0,0,0,S,0,0,0,T,1,c),K&&c.multiplyToRef(E,c),c._updateIdentityStatus(1===Z&&1===w&&1===S&&0===T),c}static OrthoOffCenterLH(l,a,N,U,c,K,Z){const w=new C;return C.OrthoOffCenterLHToRef(l,a,N,U,c,K,w,Z),w}static OrthoOffCenterLHToRef(l,a,N,U,c,K,Z,w){const S=2/(a-l),T=2/(U-N),J=2/(K-c),n=-(K+c)/(K-c),y=(l+a)/(l-a),H=(U+N)/(N-U);return C.FromValuesToRef(S,0,0,0,0,T,0,0,0,0,J,0,y,H,n,1,Z),w&&Z.multiplyToRef(E,Z),Z.markAsUpdated(),Z}static ObliqueOffCenterLHToRef(l,a,N,U,c,K,Z,w,S,T,J){const n=-Z*Math.cos(w),y=-Z*Math.sin(w);return C.TranslationToRef(0,0,-S,M.Matrix[1]),C.FromValuesToRef(1,0,0,0,0,1,0,0,n,y,1,0,0,0,0,1,M.Matrix[0]),M.Matrix[1].multiplyToRef(M.Matrix[0],M.Matrix[0]),C.TranslationToRef(0,0,S,M.Matrix[1]),M.Matrix[0].multiplyToRef(M.Matrix[1],M.Matrix[0]),C.OrthoOffCenterLHToRef(l,a,N,U,c,K,T,J),M.Matrix[0].multiplyToRef(T,T),T}static OrthoOffCenterRH(l,a,N,U,c,K,Z){const w=new C;return C.OrthoOffCenterRHToRef(l,a,N,U,c,K,w,Z),w}static OrthoOffCenterRHToRef(l,a,N,U,c,K,Z,w){return C.OrthoOffCenterLHToRef(l,a,N,U,c,K,Z,w),Z.nc[10]*=-1,Z}static ObliqueOffCenterRHToRef(l,a,N,U,c,K,Z,w,S,T,J){const n=Z*Math.cos(w),y=Z*Math.sin(w);return C.TranslationToRef(0,0,S,M.Matrix[1]),C.FromValuesToRef(1,0,0,0,0,1,0,0,n,y,1,0,0,0,0,1,M.Matrix[0]),M.Matrix[1].multiplyToRef(M.Matrix[0],M.Matrix[0]),C.TranslationToRef(0,0,-S,M.Matrix[1]),M.Matrix[0].multiplyToRef(M.Matrix[1],M.Matrix[0]),C.OrthoOffCenterRHToRef(l,a,N,U,c,K,T,J),M.Matrix[0].multiplyToRef(T,T),T}static PerspectiveLH(l,a,N,U,c){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const Z=new C,w=2*N/l,S=2*N/a,T=(U+N)/(U-N),J=-2*U*N/(U-N),n=Math.tan(K);return C.FromValuesToRef(w,0,0,0,0,S,0,n,0,0,T,1,0,0,J,0,Z),c&&Z.multiplyToRef(E,Z),Z._updateIdentityStatus(!1),Z}static PerspectiveFovLH(l,a,N,U,c){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Z=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const w=new C;return C.PerspectiveFovLHToRef(l,a,N,U,w,!0,c,K,Z),w}static PerspectiveFovLHToRef(l,a,N,U,c){let K=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Z=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,S=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const T=N,J=U,n=1/Math.tan(.5*l),y=K?n/a:n,H=K?n:n*a,u=S&&0===T?-1:0!==J?(J+T)/(J-T):1,W=S&&0===T?2*J:0!==J?-2*J*T/(J-T):-2*T,B=Math.tan(w);return C.FromValuesToRef(y,0,0,0,0,H,0,B,0,0,u,1,0,0,W,0,c),Z&&c.multiplyToRef(E,c),c._updateIdentityStatus(!1),c}static PerspectiveFovReverseLHToRef(l,a,N,U,c){let K=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Z=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const S=1/Math.tan(.5*l),T=K?S/a:S,J=K?S:S*a,n=Math.tan(w);return C.FromValuesToRef(T,0,0,0,0,J,0,n,0,0,-N,1,0,0,1,0,c),Z&&c.multiplyToRef(E,c),c._updateIdentityStatus(!1),c}static PerspectiveFovRH(l,a,N,U,c){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Z=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const w=new C;return C.PerspectiveFovRHToRef(l,a,N,U,w,!0,c,K,Z),w}static PerspectiveFovRHToRef(l,a,N,U,c){let K=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Z=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,S=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const T=N,J=U,n=1/Math.tan(.5*l),y=K?n/a:n,H=K?n:n*a,u=S&&0===T?1:0!==J?-(J+T)/(J-T):-1,W=S&&0===T?2*J:0!==J?-2*J*T/(J-T):-2*T,B=Math.tan(w);return C.FromValuesToRef(y,0,0,0,0,H,0,B,0,0,u,-1,0,0,W,0,c),Z&&c.multiplyToRef(E,c),c._updateIdentityStatus(!1),c}static PerspectiveFovReverseRHToRef(l,a,N,U,c){let K=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Z=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const S=1/Math.tan(.5*l),T=K?S/a:S,J=K?S:S*a,n=Math.tan(w);return C.FromValuesToRef(T,0,0,0,0,J,0,n,0,0,-N,-1,0,0,-1,0,c),Z&&c.multiplyToRef(E,c),c._updateIdentityStatus(!1),c}static GetFinalMatrix(l,a,N,U,c,K){const Z=l.width,w=l.height,S=l.x,T=l.y,J=C.FromValues(Z/2,0,0,0,0,-w/2,0,0,0,0,K-c,0,S+Z/2,w/2+T,c,1),n=new C;return a.multiplyToRef(N,n),n.multiplyToRef(U,n),n.multiplyToRef(J,n)}static GetAsMatrix2x2(l){const a=l.m,N=[a[0],a[1],a[4],a[5]];return Z.d.MatrixUse64Bits?N:new Float32Array(N)}static GetAsMatrix3x3(l){const a=l.m,N=[a[0],a[1],a[2],a[4],a[5],a[6],a[8],a[9],a[10]];return Z.d.MatrixUse64Bits?N:new Float32Array(N)}static Transpose(l){const a=new C;return C.TransposeToRef(l,a),a}static TransposeToRef(l,a){const N=l.m,U=N[0],c=N[4],K=N[8],Z=N[12],w=N[1],S=N[5],T=N[9],J=N[13],n=N[2],y=N[6],H=N[10],u=N[14],W=N[3],B=N[7],Y=N[11],C=N[15],M=a.nc;return M[0]=U,M[1]=c,M[2]=K,M[3]=Z,M[4]=w,M[5]=S,M[6]=T,M[7]=J,M[8]=n,M[9]=y,M[10]=H,M[11]=u,M[12]=W,M[13]=B,M[14]=Y,M[15]=C,a.markAsUpdated(),a._updateIdentityStatus(l._isIdentity,l._isIdentityDirty),a}static Reflection(l){const a=new C;return C.ReflectionToRef(l,a),a}static ReflectionToRef(l,a){l.normalize();const N=l.normal.x,U=l.normal.y,c=l.normal.z,K=-2*N,Z=-2*U,w=-2*c;return C.FromValuesToRef(K*N+1,Z*N,w*N,0,K*U,Z*U+1,w*U,0,K*c,Z*c,w*c+1,0,K*l.d,Z*l.d,w*l.d,1,a),a}static FromXYZAxesToRef(l,a,N,U){return C.FromValuesToRef(l._x,l._y,l._z,0,a._x,a._y,a._z,0,N._x,N._y,N._z,0,0,0,0,1,U),U}static FromQuaternionToRef(l,a){const N=l._x*l._x,U=l._y*l._y,c=l._z*l._z,K=l._x*l._y,Z=l._z*l._w,w=l._z*l._x,S=l._y*l._w,T=l._y*l._z,J=l._x*l._w;return a.nc[0]=1-2*(U+c),a.nc[1]=2*(K+Z),a.nc[2]=2*(w-S),a.nc[3]=0,a.nc[4]=2*(K-Z),a.nc[5]=1-2*(c+N),a.nc[6]=2*(T+J),a.nc[7]=0,a.nc[8]=2*(w+S),a.nc[9]=2*(T-J),a.nc[10]=1-2*(U+N),a.nc[11]=0,a.nc[12]=0,a.nc[13]=0,a.nc[14]=0,a.nc[15]=1,a.markAsUpdated(),a}}C._IdentityReadOnly=C.Identity(),Object.defineProperties(C.prototype,{dimension:{value:[4,4]},rank:{value:2}});class M{}M.ua=(0,c.d)(11,W.Zero),M.Matrix=(0,c.d)(2,C.Identity),M.Quaternion=(0,c.d)(3,Y.Zero);class A{}A.Vector2=(0,c.d)(3,u.Zero),A.ua=(0,c.d)(13,W.Zero),A.Vector4=(0,c.d)(3,B.Zero),A.Quaternion=(0,c.d)(3,Y.Zero),A.Matrix=(0,c.d)(8,C.Identity),(0,K.g)("BABYLON.Vector2",u),(0,K.g)("BABYLON.Vector3",W),(0,K.g)("BABYLON.Vector4",B),(0,K.g)("BABYLON.Matrix",C);const E=C.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12457:(l,a,N)=>{function U(l,a){const N=[];for(let U=0;U<l;++U)N.push(a());return N}function c(l,a){return U(l,a)}N.d(a,{b:()=>U,d:()=>c,h:()=>Z});const K=["push","splice","pop","shift","unshift"];function Z(l,a){const N=K.map((N=>function(l,a,N){const U=l[a];if("function"!==typeof U)return null;const c=function(){const U=l.length,K=c.previous.apply(l,arguments);return N(a,U),K};return U.next=c,c.previous=U,l[a]=c,()=>{const N=c.previous;if(!N)return;const U=c.next;U?(N.next=U,U.previous=N):(N.next=void 0,l[a]=N),c.next=void 0,c.previous=void 0}}(l,N,a)));return()=>{for(const l of N)null===l||void 0===l||l()}}}}]);