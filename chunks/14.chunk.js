"use strict";(self.zy41qorie9=self.zy41qorie9||[]).push([[14],{12451:(Z,l,C)=>{C.d(l,{e:()=>K,g:()=>b,h:()=>B,j:()=>x});const B=1/2.2,x=2.2,b=(1+Math.sqrt(5))/2,K=.001},12460:(Z,l,C)=>{function B(Z){return parseInt(Z.toString().replace(/\W/g,""))}function x(Z,l){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Z-l)<=C}function b(Z,l,C){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Z<l-B||Z>C+B}function K(Z,l){return Z===l?Z:Math.random()*(l-Z)+Z}function f(Z,l,C){return Z+(l-Z)*C}function W(Z,l,C){let B=Y(l-Z,360);return B>180&&(B-=360),Z+B*G(C)}function J(Z,l,C){let B=0;return B=Z!=l?G((C-Z)/(l-Z)):0,B}function d(Z,l,C,B,x){const b=x*x,K=x*b;return Z*(2*K-3*b+1)+C*(-2*K+3*b)+l*(K-2*b+x)+B*(K-b)}function E(Z,l,C,B,x){const b=x*x;return 6*(b-x)*Z+(3*b-4*x+1)*l+6*(-b+x)*C+(3*b-2*x)*B}function G(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(l,Z))}function a(Z){return Z-=2*Math.PI*Math.floor((Z+Math.PI)/(2*Math.PI))}function q(Z){const l=Z.toString(16);return Z<=15?("0"+l).toUpperCase():l.toUpperCase()}function z(Z){if(Math.log2)return Math.floor(Math.log2(Z));if(Z<0)return NaN;if(0===Z)return-1/0;let l=0;if(Z<1){for(;Z<1;)l++,Z*=2;l=-l}else if(Z>1)for(;Z>1;)l++,Z=Math.floor(Z/2);return l}function Y(Z,l){return Z-Math.floor(Z/l)*l}function P(Z,l,C){return(Z-l)/(C-l)}function S(Z,l,C){return Z*(C-l)+l}function i(Z,l){let C=Y(l-Z,360);return C>180&&(C-=360),C}function s(Z,l){const C=Y(Z,2*l);return l-Math.abs(C-l)}function F(Z,l,C){let B=G(C);return B=-2*B*B*B+3*B*B,l*B+Z*(1-B)}function n(Z,l,C){let B=0;return B=Math.abs(l-Z)<=C?l:Z+Math.sign(l-Z)*C,B}function c(Z,l,C){const B=i(Z,l);let x=0;return x=-C<B&&B<C?l:n(Z,l=Z+B,C),x}function U(Z,l,C){return(Z-l)/(C-l)}function t(Z,l,C){return(C-l)*Z+l}function r(Z,l){const C=Z%l;return 0===C?l:r(l,C)}C.r(l),C.d(l,{Clamp:()=>G,DeltaAngle:()=>i,Denormalize:()=>S,ExtractAsInt:()=>B,Hermite:()=>d,Hermite1stDerivative:()=>E,HighestCommonFactor:()=>r,ILog2:()=>z,InverseLerp:()=>J,Lerp:()=>f,LerpAngle:()=>W,MoveTowards:()=>n,MoveTowardsAngle:()=>c,Normalize:()=>P,NormalizeRadians:()=>a,OutsideRange:()=>b,PercentToRange:()=>t,PingPong:()=>s,RandomRange:()=>K,RangeToPercent:()=>U,Repeat:()=>Y,SmoothStep:()=>F,ToHex:()=>q,WithinEpsilon:()=>x})},12442:(Z,l,C)=>{C.r(l),C.d(l,{Matrix:()=>S,Quaternion:()=>P,TmpVectors:()=>s,Vector2:()=>q,ql:()=>z,Vector4:()=>Y});var B=C(12451),x=C(12456),b=C(12400),K=C(12379),f=C(12295),W=C(12460);class J{}function d(Z,l,C){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const x=Z.Yb(),b=l.Yb(),K=x[0],f=x[1],W=x[2],J=x[3],d=x[4],E=x[5],G=x[6],a=x[7],q=x[8],z=x[9],Y=x[10],P=x[11],S=x[12],i=x[13],s=x[14],F=x[15],n=b[0],c=b[1],U=b[2],t=b[3],r=b[4],e=b[5],o=b[6],v=b[7],R=b[8],k=b[9],V=b[10],g=b[11],j=b[12],M=b[13],I=b[14],w=b[15];C[B]=K*n+f*r+W*R+J*j,C[B+1]=K*c+f*e+W*k+J*M,C[B+2]=K*U+f*o+W*V+J*I,C[B+3]=K*t+f*v+W*g+J*w,C[B+4]=d*n+E*r+G*R+a*j,C[B+5]=d*c+E*e+G*k+a*M,C[B+6]=d*U+E*o+G*V+a*I,C[B+7]=d*t+E*v+G*g+a*w,C[B+8]=q*n+z*r+Y*R+P*j,C[B+9]=q*c+z*e+Y*k+P*M,C[B+10]=q*U+z*o+Y*V+P*I,C[B+11]=q*t+z*v+Y*g+P*w,C[B+12]=S*n+i*r+s*R+F*j,C[B+13]=S*c+i*e+s*k+F*M,C[B+14]=S*U+i*o+s*V+F*I,C[B+15]=S*t+i*v+s*g+F*w}function E(Z,l){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const B=Z.Yb();l[C]=B[0],l[C+1]=B[1],l[C+2]=B[2],l[C+3]=B[3],l[C+4]=B[4],l[C+5]=B[5],l[C+6]=B[6],l[C+7]=B[7],l[C+8]=B[8],l[C+9]=B[9],l[C+10]=B[10],l[C+11]=B[11],l[C+12]=B[12],l[C+13]=B[13],l[C+14]=B[14],l[C+15]=B[15]}function G(Z,l){const C=Z.Yb(),B=C[0],x=C[1],b=C[2],K=C[3],f=C[4],W=C[5],J=C[6],d=C[7],E=C[8],G=C[9],a=C[10],q=C[11],z=C[12],Y=C[13],P=C[14],S=C[15],i=a*S-P*q,s=G*S-Y*q,F=G*P-Y*a,n=E*S-z*q,c=E*P-a*z,U=E*Y-z*G,t=+(W*i-J*s+d*F),r=-(f*i-J*n+d*c),e=+(f*s-W*n+d*U),o=-(f*F-W*c+J*U),v=B*t+x*r+b*e+K*o;if(0===v)return!1;const R=1/v,k=J*S-P*d,V=W*S-Y*d,g=W*P-Y*J,j=f*S-z*d,M=f*P-z*J,I=f*Y-z*W,w=J*q-a*d,O=W*q-G*d,D=W*a-G*J,y=f*q-E*d,X=f*a-E*J,T=f*G-E*W,u=-(x*i-b*s+K*F),H=+(B*i-b*n+K*c),Q=-(B*s-x*n+K*U),h=+(B*F-x*c+b*U),A=+(x*k-b*V+K*g),L=-(B*k-b*j+K*M),p=+(B*V-x*j+K*I),N=-(B*g-x*M+b*I),mZ=-(x*w-b*O+K*D),ZZ=+(B*w-b*y+K*X),lZ=-(B*O-x*y+K*T),CZ=+(B*D-x*X+b*T);return l[0]=t*R,l[1]=u*R,l[2]=A*R,l[3]=mZ*R,l[4]=r*R,l[5]=H*R,l[6]=L*R,l[7]=ZZ*R,l[8]=e*R,l[9]=Q*R,l[10]=p*R,l[11]=lZ*R,l[12]=o*R,l[13]=h*R,l[14]=N*R,l[15]=CZ*R,!0}J._UpdateFlagSeed=0;const a=Z=>parseInt(Z.toString().replace(/\W/g,""));class q{constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=Z,this.y=l}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let Z=a(this.x);return Z=397*Z^a(this.y),Z}toArray(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[l]=this.x,Z[l+1]=this.y,this}aC(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q.FromArrayToRef(Z,l,this),this}Yb(){return[this.x,this.y]}B(Z){return this.x=Z.x,this.y=Z.y,this}rb(Z,l){return this.x=Z,this.y=l,this}set(Z,l){return this.rb(Z,l)}ob(Z){return this.rb(Z,Z)}add(Z){return new q(this.x+Z.x,this.y+Z.y)}addToRef(Z,l){return l.x=this.x+Z.x,l.y=this.y+Z.y,l}addInPlace(Z){return this.x+=Z.x,this.y+=Z.y,this}addInPlaceFromFloats(Z,l){return this.x+=Z,this.y+=l,this}addVector3(Z){return new q(this.x+Z.x,this.y+Z.y)}zl(Z){return new q(this.x-Z.x,this.y-Z.y)}subtractToRef(Z,l){return l.x=this.x-Z.x,l.y=this.y-Z.y,l}JG(Z){return this.x-=Z.x,this.y-=Z.y,this}multiplyInPlace(Z){return this.x*=Z.x,this.y*=Z.y,this}multiply(Z){return new q(this.x*Z.x,this.y*Z.y)}multiplyToRef(Z,l){return l.x=this.x*Z.x,l.y=this.y*Z.y,l}multiplyByFloats(Z,l){return new q(this.x*Z,this.y*l)}divide(Z){return new q(this.x/Z.x,this.y/Z.y)}divideToRef(Z,l){return l.x=this.x/Z.x,l.y=this.y/Z.y,l}divideInPlace(Z){return this.x=this.x/Z.x,this.y=this.y/Z.y,this}minimizeInPlace(Z){return this.minimizeInPlaceFromFloats(Z.x,Z.y)}maximizeInPlace(Z){return this.maximizeInPlaceFromFloats(Z.x,Z.y)}minimizeInPlaceFromFloats(Z,l){return this.x=Math.min(Z,this.x),this.y=Math.min(l,this.y),this}maximizeInPlaceFromFloats(Z,l){return this.x=Math.max(Z,this.x),this.y=Math.max(l,this.y),this}subtractFromFloats(Z,l){return new q(this.x-Z,this.y-l)}subtractFromFloatsToRef(Z,l,C){return C.x=this.x-Z,C.y=this.y-l,C}negate(){return new q(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(Z){return Z.x=-this.x,Z.y=-this.y,Z}scaleInPlace(Z){return this.x*=Z,this.y*=Z,this}scale(Z){return new q(this.x*Z,this.y*Z)}scaleToRef(Z,l){return l.x=this.x*Z,l.y=this.y*Z,l}scaleAndAddToRef(Z,l){return l.x+=this.x*Z,l.y+=this.y*Z,l}equals(Z){return Z&&this.x===Z.x&&this.y===Z.y}equalsWithEpsilon(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.e;return Z&&(0,W.WithinEpsilon)(this.x,Z.x,l)&&(0,W.WithinEpsilon)(this.y,Z.y,l)}equalsToFloats(Z,l){return this.x===Z&&this.y===l}floor(){return new q(Math.floor(this.x),Math.floor(this.y))}floorToRef(Z){return Z.x=Math.floor(this.x),Z.y=Math.floor(this.y),Z}fract(){return new q(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(Z){return Z.x=this.x-Math.floor(this.x),Z.y=this.y-Math.floor(this.y),Z}rotate(Z){return this.rotateToRef(Z,new q)}rotateToRef(Z,l){const C=Math.cos(Z),B=Math.sin(Z);return l.x=C*this.x-B*this.y,l.y=B*this.x+C*this.y,l}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){const Z=new q;return this.normalizeToRef(Z),Z}normalizeToRef(Z){const l=this.length();return 0===l&&(Z.x=this.x,Z.y=this.y),this.scaleToRef(1/l,Z)}clone(){return new q(this.x,this.y)}dot(Z){return this.x*Z.x+this.y*Z.y}static Zero(){return new q(0,0)}static One(){return new q(1,1)}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new q((0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).rb((0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l))}static get ZeroReadOnly(){return q._ZeroReadOnly}static il(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new q(Z[l],Z[l+1])}static FromArrayToRef(Z,l,C){return C.x=Z[l],C.y=Z[l+1],C}static FromFloatsToRef(Z,l,C){return C.rb(Z,l),C}static CatmullRom(Z,l,C,B,x){const b=x*x,K=x*b,f=.5*(2*l.x+(-Z.x+C.x)*x+(2*Z.x-5*l.x+4*C.x-B.x)*b+(-Z.x+3*l.x-3*C.x+B.x)*K),W=.5*(2*l.y+(-Z.y+C.y)*x+(2*Z.y-5*l.y+4*C.y-B.y)*b+(-Z.y+3*l.y-3*C.y+B.y)*K);return new q(f,W)}static ClampToRef(Z,l,C,B){return B.x=(0,W.Clamp)(Z.x,l.x,C.x),B.y=(0,W.Clamp)(Z.y,l.y,C.y),B}static Clamp(Z,l,C){const B=(0,W.Clamp)(Z.x,l.x,C.x),x=(0,W.Clamp)(Z.y,l.y,C.y);return new q(B,x)}static Hermite(Z,l,C,B,x){const b=x*x,K=x*b,f=2*K-3*b+1,W=-2*K+3*b,J=K-2*b+x,d=K-b,E=Z.x*f+C.x*W+l.x*J+B.x*d,G=Z.y*f+C.y*W+l.y*J+B.y*d;return new q(E,G)}static Hermite1stDerivative(Z,l,C,B,x){return this.Hermite1stDerivativeToRef(Z,l,C,B,x,new q)}static Hermite1stDerivativeToRef(Z,l,C,B,x,b){const K=x*x;return b.x=6*(K-x)*Z.x+(3*K-4*x+1)*l.x+6*(-K+x)*C.x+(3*K-2*x)*B.x,b.y=6*(K-x)*Z.y+(3*K-4*x+1)*l.y+6*(-K+x)*C.y+(3*K-2*x)*B.y,b}static Lerp(Z,l,C){return q.LerpToRef(Z,l,C,new q)}static LerpToRef(Z,l,C,B){return B.x=Z.x+(l.x-Z.x)*C,B.y=Z.y+(l.y-Z.y)*C,B}static Dot(Z,l){return Z.x*l.x+Z.y*l.y}static Normalize(Z){return q.NormalizeToRef(Z,new q)}static NormalizeToRef(Z,l){return Z.normalizeToRef(l),l}static Minimize(Z,l){const C=Z.x<l.x?Z.x:l.x,B=Z.y<l.y?Z.y:l.y;return new q(C,B)}static Maximize(Z,l){const C=Z.x>l.x?Z.x:l.x,B=Z.y>l.y?Z.y:l.y;return new q(C,B)}static Transform(Z,l){return q.TransformToRef(Z,l,new q)}static TransformToRef(Z,l,C){const B=l.m,x=Z.x*B[0]+Z.y*B[4]+B[12],b=Z.x*B[1]+Z.y*B[5]+B[13];return C.x=x,C.y=b,C}static PointInTriangle(Z,l,C,B){const x=.5*(-C.y*B.x+l.y*(-C.x+B.x)+l.x*(C.y-B.y)+C.x*B.y),b=x<0?-1:1,K=(l.y*B.x-l.x*B.y+(B.y-l.y)*Z.x+(l.x-B.x)*Z.y)*b,f=(l.x*C.y-l.y*C.x+(l.y-C.y)*Z.x+(C.x-l.x)*Z.y)*b;return K>0&&f>0&&K+f<2*x*b}static Distance(Z,l){return Math.sqrt(q.DistanceSquared(Z,l))}static DistanceSquared(Z,l){const C=Z.x-l.x,B=Z.y-l.y;return C*C+B*B}static Center(Z,l){return q.CenterToRef(Z,l,new q)}static CenterToRef(Z,l,C){return C.rb((Z.x+l.x)/2,(Z.y+l.y)/2)}static DistanceOfPointFromSegment(Z,l,C){const B=q.DistanceSquared(l,C);if(0===B)return q.Distance(Z,l);const x=C.zl(l),b=Math.max(0,Math.min(1,q.Dot(Z.zl(l),x)/B)),K=l.add(x.multiplyByFloats(b,b));return q.Distance(Z,K)}}q._V8PerformanceHack=new q(.5,.5),q._ZeroReadOnly=q.Zero(),Object.defineProperties(q.prototype,{dimension:{value:[2]},rank:{value:1}});class z{get x(){return this._x}set x(Z){this._x=Z,this._isDirty=!0}get y(){return this._y}set y(Z){this._y=Z,this._isDirty=!0}get z(){return this._z}set z(Z){this._z=Z,this._isDirty=!0}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=Z,this._y=l,this._z=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"ql"}getHashCode(){let Z=a(this._x);return Z=397*Z^a(this._y),Z=397*Z^a(this._z),Z}Yb(){return[this._x,this._y,this._z]}toArray(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[l]=this._x,Z[l+1]=this._y,Z[l+2]=this._z,this}aC(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z.FromArrayToRef(Z,l,this),this}toQuaternion(){return P.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(Z){return this._x+=Z._x,this._y+=Z._y,this._z+=Z._z,this._isDirty=!0,this}addInPlaceFromFloats(Z,l,C){return this._x+=Z,this._y+=l,this._z+=C,this._isDirty=!0,this}add(Z){return new z(this._x+Z._x,this._y+Z._y,this._z+Z._z)}addToRef(Z,l){return l._x=this._x+Z._x,l._y=this._y+Z._y,l._z=this._z+Z._z,l._isDirty=!0,l}JG(Z){return this._x-=Z._x,this._y-=Z._y,this._z-=Z._z,this._isDirty=!0,this}zl(Z){return new z(this._x-Z._x,this._y-Z._y,this._z-Z._z)}subtractToRef(Z,l){return this.subtractFromFloatsToRef(Z._x,Z._y,Z._z,l)}subtractFromFloats(Z,l,C){return new z(this._x-Z,this._y-l,this._z-C)}subtractFromFloatsToRef(Z,l,C,B){return B._x=this._x-Z,B._y=this._y-l,B._z=this._z-C,B._isDirty=!0,B}negate(){return new z(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(Z){return Z._x=-1*this._x,Z._y=-1*this._y,Z._z=-1*this._z,Z._isDirty=!0,Z}scaleInPlace(Z){return this._x*=Z,this._y*=Z,this._z*=Z,this._isDirty=!0,this}scale(Z){return new z(this._x*Z,this._y*Z,this._z*Z)}scaleToRef(Z,l){return l._x=this._x*Z,l._y=this._y*Z,l._z=this._z*Z,l._isDirty=!0,l}getNormalToRef(Z){const l=this.length();let C=Math.acos(this._y/l);const B=Math.atan2(this._z,this._x);C>Math.PI/2?C-=Math.PI/2:C+=Math.PI/2;const x=l*Math.sin(C)*Math.cos(B),b=l*Math.cos(C),K=l*Math.sin(C)*Math.sin(B);return Z.set(x,b,K),Z}applyRotationQuaternionToRef(Z,l){const C=this._x,B=this._y,x=this._z,b=Z._x,K=Z._y,f=Z._z,W=Z._w,J=2*(K*x-f*B),d=2*(f*C-b*x),E=2*(b*B-K*C);return l._x=C+W*J+K*E-f*d,l._y=B+W*d+f*J-b*E,l._z=x+W*E+b*d-K*J,l._isDirty=!0,l}applyRotationQuaternionInPlace(Z){return this.applyRotationQuaternionToRef(Z,this)}applyRotationQuaternion(Z){return this.applyRotationQuaternionToRef(Z,new z)}scaleAndAddToRef(Z,l){return l._x+=this._x*Z,l._y+=this._y*Z,l._z+=this._z*Z,l._isDirty=!0,l}projectOnPlane(Z,l){return this.projectOnPlaneToRef(Z,l,new z)}projectOnPlaneToRef(Z,l,C){const B=Z.normal,x=Z.d,b=i.ql[0];this.subtractToRef(l,b),b.normalize();const K=z.Dot(b,B);if(Math.abs(K)<1e-10)C.ob(1/0);else{const Z=-(z.Dot(l,B)+x)/K,f=b.scaleInPlace(Z);l.addToRef(f,C)}return C}equals(Z){return Z&&this._x===Z._x&&this._y===Z._y&&this._z===Z._z}equalsWithEpsilon(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.e;return Z&&(0,W.WithinEpsilon)(this._x,Z._x,l)&&(0,W.WithinEpsilon)(this._y,Z._y,l)&&(0,W.WithinEpsilon)(this._z,Z._z,l)}equalsToFloats(Z,l,C){return this._x===Z&&this._y===l&&this._z===C}multiplyInPlace(Z){return this._x*=Z._x,this._y*=Z._y,this._z*=Z._z,this._isDirty=!0,this}multiply(Z){return this.multiplyByFloats(Z._x,Z._y,Z._z)}multiplyToRef(Z,l){return l._x=this._x*Z._x,l._y=this._y*Z._y,l._z=this._z*Z._z,l._isDirty=!0,l}multiplyByFloats(Z,l,C){return new z(this._x*Z,this._y*l,this._z*C)}divide(Z){return new z(this._x/Z._x,this._y/Z._y,this._z/Z._z)}divideToRef(Z,l){return l._x=this._x/Z._x,l._y=this._y/Z._y,l._z=this._z/Z._z,l._isDirty=!0,l}divideInPlace(Z){return this._x=this._x/Z._x,this._y=this._y/Z._y,this._z=this._z/Z._z,this._isDirty=!0,this}minimizeInPlace(Z){return this.minimizeInPlaceFromFloats(Z._x,Z._y,Z._z)}maximizeInPlace(Z){return this.maximizeInPlaceFromFloats(Z._x,Z._y,Z._z)}minimizeInPlaceFromFloats(Z,l,C){return Z<this._x&&(this.x=Z),l<this._y&&(this.y=l),C<this._z&&(this.z=C),this}maximizeInPlaceFromFloats(Z,l,C){return Z>this._x&&(this.x=Z),l>this._y&&(this.y=l),C>this._z&&(this.z=C),this}isNonUniformWithinEpsilon(Z){const l=Math.abs(this._x),C=Math.abs(this._y);if(!(0,W.WithinEpsilon)(l,C,Z))return!0;const B=Math.abs(this._z);return!(0,W.WithinEpsilon)(l,B,Z)||!(0,W.WithinEpsilon)(C,B,Z)}get isNonUniform(){const Z=Math.abs(this._x);if(Z!==Math.abs(this._y))return!0;return Z!==Math.abs(this._z)}floorToRef(Z){return Z._x=Math.floor(this._x),Z._y=Math.floor(this._y),Z._z=Math.floor(this._z),Z._isDirty=!0,Z}floor(){return new z(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(Z){return Z._x=this._x-Math.floor(this._x),Z._y=this._y-Math.floor(this._y),Z._z=this._z-Math.floor(this._z),Z._isDirty=!0,Z}fract(){return new z(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(Z){if("xyz"===(Z=Z.toLowerCase()))return this;const l=i.ql[0].B(this);return this.x=l[Z[0]],this.y=l[Z[1]],this.z=l[Z[2]],this}rotateByQuaternionToRef(Z,l){return Z.toRotationMatrix(i.Matrix[0]),z.TransformCoordinatesToRef(this,i.Matrix[0],l),l}rotateByQuaternionAroundPointToRef(Z,l,C){return this.subtractToRef(l,i.ql[0]),i.ql[0].rotateByQuaternionToRef(Z,i.ql[0]),l.addToRef(i.ql[0],C),C}cross(Z){return z.CrossToRef(this,Z,new z)}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){return this.normalizeToRef(new z)}normalizeToRef(Z){const l=this.length();return 0===l||1===l?(Z._x=this._x,Z._y=this._y,Z._z=this._z,Z._isDirty=!0,Z):this.scaleToRef(1/l,Z)}clone(){return new z(this._x,this._y,this._z)}B(Z){return this.rb(Z._x,Z._y,Z._z)}rb(Z,l,C){return this._x=Z,this._y=l,this._z=C,this._isDirty=!0,this}set(Z,l,C){return this.rb(Z,l,C)}ob(Z){return this._x=this._y=this._z=Z,this._isDirty=!0,this}static GetClipFactor(Z,l,C,B){const x=z.Dot(Z,C);return(x-B)/(x-z.Dot(l,C))}static GetAngleBetweenVectors(Z,l,C){const B=Z.normalizeToRef(i.ql[1]),x=l.normalizeToRef(i.ql[2]);let b=z.Dot(B,x);b=(0,W.Clamp)(b,-1,1);const K=Math.acos(b),f=i.ql[3];return z.CrossToRef(B,x,f),z.Dot(f,C)>0?isNaN(K)?0:K:isNaN(K)?-Math.PI:-Math.acos(b)}static GetAngleBetweenVectorsOnPlane(Z,l,C){i.ql[0].B(Z);const B=i.ql[0];i.ql[1].B(l);const x=i.ql[1];i.ql[2].B(C);const b=i.ql[2],K=i.ql[3],f=i.ql[4];B.normalize(),x.normalize(),b.normalize(),z.CrossToRef(b,B,K),z.CrossToRef(K,b,f);const J=Math.atan2(z.Dot(x,K),z.Dot(x,f));return(0,W.NormalizeRadians)(J)}static PitchYawRollToMoveBetweenPointsToRef(Z,l,C){const B=s.ql[0];return l.subtractToRef(Z,B),C._y=Math.atan2(B.x,B.z)||0,C._x=Math.atan2(Math.sqrt(B.x**2+B.z**2),B.y)||0,C._z=0,C._isDirty=!0,C}static PitchYawRollToMoveBetweenPoints(Z,l){const C=z.Zero();return z.PitchYawRollToMoveBetweenPointsToRef(Z,l,C)}static SlerpToRef(Z,l,C,x){C=(0,W.Clamp)(C,0,1);const b=i.ql[0],K=i.ql[1];b.B(Z);const f=b.length();b.normalizeFromLength(f),K.B(l);const J=K.length();K.normalizeFromLength(J);const d=z.Dot(b,K);let E,G;if(d<1-B.e){const Z=Math.acos(d),l=1/Math.sin(Z);E=Math.sin((1-C)*Z)*l,G=Math.sin(C*Z)*l}else E=1-C,G=C;return b.scaleInPlace(E),K.scaleInPlace(G),x.B(b).addInPlace(K),x.scaleInPlace((0,W.Lerp)(f,J,C)),x}static SmoothToRef(Z,l,C,B,x){return z.SlerpToRef(Z,l,0===B?1:C/B,x),x}static il(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new z(Z[l],Z[l+1],Z[l+2])}static FromFloatArray(Z,l){return z.il(Z,l)}static FromArrayToRef(Z,l,C){return C._x=Z[l],C._y=Z[l+1],C._z=Z[l+2],C._isDirty=!0,C}static FromFloatArrayToRef(Z,l,C){return z.FromArrayToRef(Z,l,C)}static FromFloatsToRef(Z,l,C,B){return B.rb(Z,l,C),B}static Zero(){return new z(0,0,0)}static One(){return new z(1,1,1)}static Up(){return new z(0,1,0)}static get UpReadOnly(){return z._UpReadOnly}static get DownReadOnly(){return z._DownReadOnly}static get RightReadOnly(){return z._RightReadOnly}static get LeftReadOnly(){return z._LeftReadOnly}static get LeftHandedForwardReadOnly(){return z._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return z._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return z._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return z._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return z._ZeroReadOnly}static get OneReadOnly(){return z._OneReadOnly}static Down(){return new z(0,-1,0)}static Forward(){return new z(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new z(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new z(1,0,0)}static Left(){return new z(-1,0,0)}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new z((0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).rb((0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l))}static TransformCoordinates(Z,l){const C=z.Zero();return z.TransformCoordinatesToRef(Z,l,C),C}static TransformCoordinatesToRef(Z,l,C){return z.TransformCoordinatesFromFloatsToRef(Z._x,Z._y,Z._z,l,C),C}static TransformCoordinatesFromFloatsToRef(Z,l,C,B,x){const b=B.m,K=Z*b[0]+l*b[4]+C*b[8]+b[12],f=Z*b[1]+l*b[5]+C*b[9]+b[13],W=Z*b[2]+l*b[6]+C*b[10]+b[14],J=1/(Z*b[3]+l*b[7]+C*b[11]+b[15]);return x._x=K*J,x._y=f*J,x._z=W*J,x._isDirty=!0,x}static TransformNormal(Z,l){const C=z.Zero();return z.TransformNormalToRef(Z,l,C),C}static TransformNormalToRef(Z,l,C){return this.TransformNormalFromFloatsToRef(Z._x,Z._y,Z._z,l,C),C}static TransformNormalFromFloatsToRef(Z,l,C,B,x){const b=B.m;return x._x=Z*b[0]+l*b[4]+C*b[8],x._y=Z*b[1]+l*b[5]+C*b[9],x._z=Z*b[2]+l*b[6]+C*b[10],x._isDirty=!0,x}static CatmullRom(Z,l,C,B,x){const b=x*x,K=x*b,f=.5*(2*l._x+(-Z._x+C._x)*x+(2*Z._x-5*l._x+4*C._x-B._x)*b+(-Z._x+3*l._x-3*C._x+B._x)*K),W=.5*(2*l._y+(-Z._y+C._y)*x+(2*Z._y-5*l._y+4*C._y-B._y)*b+(-Z._y+3*l._y-3*C._y+B._y)*K),J=.5*(2*l._z+(-Z._z+C._z)*x+(2*Z._z-5*l._z+4*C._z-B._z)*b+(-Z._z+3*l._z-3*C._z+B._z)*K);return new z(f,W,J)}static Clamp(Z,l,C){const B=new z;return z.ClampToRef(Z,l,C,B),B}static ClampToRef(Z,l,C,B){let x=Z._x;x=x>C._x?C._x:x,x=x<l._x?l._x:x;let b=Z._y;b=b>C._y?C._y:b,b=b<l._y?l._y:b;let K=Z._z;return K=K>C._z?C._z:K,K=K<l._z?l._z:K,B.rb(x,b,K),B}static CheckExtends(Z,l,C){l.minimizeInPlace(Z),C.maximizeInPlace(Z)}static Hermite(Z,l,C,B,x){const b=x*x,K=x*b,f=2*K-3*b+1,W=-2*K+3*b,J=K-2*b+x,d=K-b,E=Z._x*f+C._x*W+l._x*J+B._x*d,G=Z._y*f+C._y*W+l._y*J+B._y*d,a=Z._z*f+C._z*W+l._z*J+B._z*d;return new z(E,G,a)}static Hermite1stDerivative(Z,l,C,B,x){const b=new z;return this.Hermite1stDerivativeToRef(Z,l,C,B,x,b),b}static Hermite1stDerivativeToRef(Z,l,C,B,x,b){const K=x*x;return b._x=6*(K-x)*Z._x+(3*K-4*x+1)*l._x+6*(-K+x)*C._x+(3*K-2*x)*B._x,b._y=6*(K-x)*Z._y+(3*K-4*x+1)*l._y+6*(-K+x)*C._y+(3*K-2*x)*B._y,b._z=6*(K-x)*Z._z+(3*K-4*x+1)*l._z+6*(-K+x)*C._z+(3*K-2*x)*B._z,b._isDirty=!0,b}static Lerp(Z,l,C){const B=new z(0,0,0);return z.LerpToRef(Z,l,C,B),B}static LerpToRef(Z,l,C,B){return B._x=Z._x+(l._x-Z._x)*C,B._y=Z._y+(l._y-Z._y)*C,B._z=Z._z+(l._z-Z._z)*C,B._isDirty=!0,B}static Dot(Z,l){return Z._x*l._x+Z._y*l._y+Z._z*l._z}dot(Z){return this._x*Z._x+this._y*Z._y+this._z*Z._z}static Cross(Z,l){const C=new z;return z.CrossToRef(Z,l,C),C}static CrossToRef(Z,l,C){const B=Z._y*l._z-Z._z*l._y,x=Z._z*l._x-Z._x*l._z,b=Z._x*l._y-Z._y*l._x;return C.rb(B,x,b),C}static Normalize(Z){const l=z.Zero();return z.NormalizeToRef(Z,l),l}static NormalizeToRef(Z,l){return Z.normalizeToRef(l),l}static Project(Z,l,C,B){const x=new z;return z.ProjectToRef(Z,l,C,B,x),x}static ProjectToRef(Z,l,C,B,x){var b;const K=B.width,W=B.height,J=B.x,d=B.y,E=i.Matrix[1],G=null===(b=f.b.LastCreatedEngine)||void 0===b?void 0:b.isNDCHalfZRange,a=G?1:.5,q=G?0:.5;S.FromValuesToRef(K/2,0,0,0,0,-W/2,0,0,0,0,a,0,J+K/2,W/2+d,q,1,E);const Y=i.Matrix[0];return l.multiplyToRef(C,Y),Y.multiplyToRef(E,Y),z.TransformCoordinatesToRef(Z,Y,x),x}static Reflect(Z,l){return this.ReflectToRef(Z,l,new z)}static ReflectToRef(Z,l,C){const B=s.ql[0];return B.B(l).scaleInPlace(2*z.Dot(Z,l)),C.B(Z).JG(B)}static _UnprojectFromInvertedMatrixToRef(Z,l,C){z.TransformCoordinatesToRef(Z,l,C);const B=l.m,x=Z._x*B[3]+Z._y*B[7]+Z._z*B[11]+B[15];return(0,W.WithinEpsilon)(x,1)&&C.scaleInPlace(1/x),C}static UnprojectFromTransform(Z,l,C,B,x){return this.Unproject(Z,l,C,B,x,S.IdentityReadOnly)}static Unproject(Z,l,C,B,x,b){const K=new z;return z.UnprojectToRef(Z,l,C,B,x,b,K),K}static UnprojectToRef(Z,l,C,B,x,b,K){return z.UnprojectFloatsToRef(Z._x,Z._y,Z._z,l,C,B,x,b,K),K}static UnprojectFloatsToRef(Z,l,C,B,x,b,K,W,J){var d;const E=i.Matrix[0];b.multiplyToRef(K,E),E.multiplyToRef(W,E),E.invert();const G=i.ql[0];return G.x=Z/B*2-1,G.y=-(l/x*2-1),null!==(d=f.b.LastCreatedEngine)&&void 0!==d&&d.isNDCHalfZRange?G.z=C:G.z=2*C-1,z._UnprojectFromInvertedMatrixToRef(G,E,J),J}static Minimize(Z,l){const C=new z;return C.B(Z),C.minimizeInPlace(l),C}static Maximize(Z,l){const C=new z;return C.B(Z),C.maximizeInPlace(l),C}static Distance(Z,l){return Math.sqrt(z.DistanceSquared(Z,l))}static DistanceSquared(Z,l){const C=Z._x-l._x,B=Z._y-l._y,x=Z._z-l._z;return C*C+B*B+x*x}static ProjectOnTriangleToRef(Z,l,C,x,b){const K=i.ql[0],f=i.ql[1],J=i.ql[2],d=i.ql[3],E=i.ql[4];C.subtractToRef(l,K),x.subtractToRef(l,f),x.subtractToRef(C,J);const G=K.length(),a=f.length(),q=J.length();if(G<B.e||a<B.e||q<B.e)return b.B(l),z.Distance(Z,l);Z.subtractToRef(l,E),z.CrossToRef(K,f,d);const Y=d.length();if(Y<B.e)return b.B(l),z.Distance(Z,l);d.normalizeFromLength(Y);let P=E.length();if(P<B.e)return b.B(l),0;E.normalizeFromLength(P);const S=z.Dot(d,E),s=i.ql[5],F=i.ql[6];s.B(d).scaleInPlace(-P*S),F.B(Z).addInPlace(s);const n=i.ql[4],c=i.ql[5],U=i.ql[7],t=i.ql[8];n.B(K).scaleInPlace(1/G),t.B(f).scaleInPlace(1/a),n.addInPlace(t).scaleInPlace(-1),c.B(K).scaleInPlace(-1/G),t.B(J).scaleInPlace(1/q),c.addInPlace(t).scaleInPlace(-1),U.B(J).scaleInPlace(-1/q),t.B(f).scaleInPlace(-1/a),U.addInPlace(t).scaleInPlace(-1);const r=i.ql[9];let e;r.B(F).JG(l),z.CrossToRef(n,r,t),e=z.Dot(t,d);const o=e;r.B(F).JG(C),z.CrossToRef(c,r,t),e=z.Dot(t,d);const v=e;r.B(F).JG(x),z.CrossToRef(U,r,t),e=z.Dot(t,d);const R=e,k=i.ql[10];let V,g;o>0&&v<0?(k.B(K),V=l,g=C):v>0&&R<0?(k.B(J),V=C,g=x):(k.B(f).scaleInPlace(-1),V=x,g=l);const j=i.ql[9],M=i.ql[4];V.subtractToRef(F,t),g.subtractToRef(F,j),z.CrossToRef(t,j,M);if(!(z.Dot(M,d)<0))return b.B(F),Math.abs(P*S);const I=i.ql[5];z.CrossToRef(k,M,I),I.normalize();const w=i.ql[9];w.B(V).JG(F);const O=w.length();if(O<B.e)return b.B(V),z.Distance(Z,V);w.normalizeFromLength(O);const D=z.Dot(I,w),y=i.ql[7];y.B(F).addInPlace(I.scaleInPlace(O*D)),t.B(y).JG(V),P=k.length(),k.normalizeFromLength(P);let X=z.Dot(t,k)/Math.max(P,B.e);return X=(0,W.Clamp)(X,0,1),y.B(V).addInPlace(k.scaleInPlace(X*P)),b.B(y),z.Distance(Z,y)}static Center(Z,l){return z.CenterToRef(Z,l,z.Zero())}static CenterToRef(Z,l,C){return C.rb((Z._x+l._x)/2,(Z._y+l._y)/2,(Z._z+l._z)/2)}static RotationFromAxis(Z,l,C){const B=new z;return z.RotationFromAxisToRef(Z,l,C,B),B}static RotationFromAxisToRef(Z,l,C,B){const x=i.Quaternion[0];return P.RotationQuaternionFromAxisToRef(Z,l,C,x),x.toEulerAnglesToRef(B),B}}z._V8PerformanceHack=new z(.5,.5,.5),z._UpReadOnly=z.Up(),z._DownReadOnly=z.Down(),z._LeftHandedForwardReadOnly=z.Forward(!1),z._RightHandedForwardReadOnly=z.Forward(!0),z._LeftHandedBackwardReadOnly=z.Backward(!1),z._RightHandedBackwardReadOnly=z.Backward(!0),z._RightReadOnly=z.Right(),z._LeftReadOnly=z.Left(),z._ZeroReadOnly=z.Zero(),z._OneReadOnly=z.One(),Object.defineProperties(z.prototype,{dimension:{value:[3]},rank:{value:1}});class Y{get x(){return this._x}set x(Z){this._x=Z,this._isDirty=!0}get y(){return this._y}set y(Z){this._y=Z,this._isDirty=!0}get z(){return this._z}set z(Z){this._z=Z,this._isDirty=!0}get w(){return this._w}set w(Z){this._w=Z,this._isDirty=!0}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=Z,this._y=l,this._z=C,this._w=B}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let Z=a(this._x);return Z=397*Z^a(this._y),Z=397*Z^a(this._z),Z=397*Z^a(this._w),Z}Yb(){return[this._x,this._y,this._z,this._w]}toArray(Z,l){return void 0===l&&(l=0),Z[l]=this._x,Z[l+1]=this._y,Z[l+2]=this._z,Z[l+3]=this._w,this}aC(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y.FromArrayToRef(Z,l,this),this}addInPlace(Z){return this.x+=Z._x,this.y+=Z._y,this.z+=Z._z,this.w+=Z._w,this}addInPlaceFromFloats(Z,l,C,B){return this.x+=Z,this.y+=l,this.z+=C,this.w+=B,this}add(Z){return new Y(this._x+Z.x,this._y+Z.y,this._z+Z.z,this._w+Z.w)}addToRef(Z,l){return l.x=this._x+Z.x,l.y=this._y+Z.y,l.z=this._z+Z.z,l.w=this._w+Z.w,l}JG(Z){return this.x-=Z.x,this.y-=Z.y,this.z-=Z.z,this.w-=Z.w,this}zl(Z){return new Y(this._x-Z.x,this._y-Z.y,this._z-Z.z,this._w-Z.w)}subtractToRef(Z,l){return l.x=this._x-Z.x,l.y=this._y-Z.y,l.z=this._z-Z.z,l.w=this._w-Z.w,l}subtractFromFloats(Z,l,C,B){return new Y(this._x-Z,this._y-l,this._z-C,this._w-B)}subtractFromFloatsToRef(Z,l,C,B,x){return x.x=this._x-Z,x.y=this._y-l,x.z=this._z-C,x.w=this._w-B,x}negate(){return new Y(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(Z){return Z.x=-this._x,Z.y=-this._y,Z.z=-this._z,Z.w=-this._w,Z}scaleInPlace(Z){return this.x*=Z,this.y*=Z,this.z*=Z,this.w*=Z,this}scale(Z){return new Y(this._x*Z,this._y*Z,this._z*Z,this._w*Z)}scaleToRef(Z,l){return l.x=this._x*Z,l.y=this._y*Z,l.z=this._z*Z,l.w=this._w*Z,l}scaleAndAddToRef(Z,l){return l.x+=this._x*Z,l.y+=this._y*Z,l.z+=this._z*Z,l.w+=this._w*Z,l}equals(Z){return Z&&this._x===Z.x&&this._y===Z.y&&this._z===Z.z&&this._w===Z.w}equalsWithEpsilon(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.e;return Z&&(0,W.WithinEpsilon)(this._x,Z.x,l)&&(0,W.WithinEpsilon)(this._y,Z.y,l)&&(0,W.WithinEpsilon)(this._z,Z.z,l)&&(0,W.WithinEpsilon)(this._w,Z.w,l)}equalsToFloats(Z,l,C,B){return this._x===Z&&this._y===l&&this._z===C&&this._w===B}multiplyInPlace(Z){return this.x*=Z.x,this.y*=Z.y,this.z*=Z.z,this.w*=Z.w,this}multiply(Z){return new Y(this._x*Z.x,this._y*Z.y,this._z*Z.z,this._w*Z.w)}multiplyToRef(Z,l){return l.x=this._x*Z.x,l.y=this._y*Z.y,l.z=this._z*Z.z,l.w=this._w*Z.w,l}multiplyByFloats(Z,l,C,B){return new Y(this._x*Z,this._y*l,this._z*C,this._w*B)}divide(Z){return new Y(this._x/Z.x,this._y/Z.y,this._z/Z.z,this._w/Z.w)}divideToRef(Z,l){return l.x=this._x/Z.x,l.y=this._y/Z.y,l.z=this._z/Z.z,l.w=this._w/Z.w,l}divideInPlace(Z){return this.divideToRef(Z,this)}minimizeInPlace(Z){return Z.x<this._x&&(this.x=Z.x),Z.y<this._y&&(this.y=Z.y),Z.z<this._z&&(this.z=Z.z),Z.w<this._w&&(this.w=Z.w),this}maximizeInPlace(Z){return Z.x>this._x&&(this.x=Z.x),Z.y>this._y&&(this.y=Z.y),Z.z>this._z&&(this.z=Z.z),Z.w>this._w&&(this.w=Z.w),this}minimizeInPlaceFromFloats(Z,l,C,B){return this.x=Math.min(Z,this._x),this.y=Math.min(l,this._y),this.z=Math.min(C,this._z),this.w=Math.min(B,this._w),this}maximizeInPlaceFromFloats(Z,l,C,B){return this.x=Math.max(Z,this._x),this.y=Math.max(l,this._y),this.z=Math.max(C,this._z),this.w=Math.max(B,this._w),this}floorToRef(Z){return Z.x=Math.floor(this._x),Z.y=Math.floor(this._y),Z.z=Math.floor(this._z),Z.w=Math.floor(this._w),Z}floor(){return new Y(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(Z){return Z.x=this._x-Math.floor(this._x),Z.y=this._y-Math.floor(this._y),Z.z=this._z-Math.floor(this._z),Z.w=this._w-Math.floor(this._w),Z}fract(){return new Y(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){return this.normalizeToRef(new Y)}normalizeToRef(Z){const l=this.length();return 0===l||1===l?(Z.x=this._x,Z.y=this._y,Z.z=this._z,Z.w=this._w,Z):this.scaleToRef(1/l,Z)}toVector3(){return new z(this._x,this._y,this._z)}clone(){return new Y(this._x,this._y,this._z,this._w)}B(Z){return this.x=Z.x,this.y=Z.y,this.z=Z.z,this.w=Z.w,this}rb(Z,l,C,B){return this.x=Z,this.y=l,this.z=C,this.w=B,this}set(Z,l,C,B){return this.rb(Z,l,C,B)}ob(Z){return this.x=this.y=this.z=this.w=Z,this}dot(Z){return this._x*Z.x+this._y*Z.y+this._z*Z.z+this._w*Z.w}static il(Z,l){return l||(l=0),new Y(Z[l],Z[l+1],Z[l+2],Z[l+3])}static FromArrayToRef(Z,l,C){return C.x=Z[l],C.y=Z[l+1],C.z=Z[l+2],C.w=Z[l+3],C}static FromFloatArrayToRef(Z,l,C){return Y.FromArrayToRef(Z,l,C),C}static FromFloatsToRef(Z,l,C,B,x){return x.x=Z,x.y=l,x.z=C,x.w=B,x}static Zero(){return new Y(0,0,0,0)}static One(){return new Y(1,1,1,1)}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Y((0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.x=(0,W.RandomRange)(Z,l),C.y=(0,W.RandomRange)(Z,l),C.z=(0,W.RandomRange)(Z,l),C.w=(0,W.RandomRange)(Z,l),C}static Clamp(Z,l,C){return Y.ClampToRef(Z,l,C,new Y)}static ClampToRef(Z,l,C,B){return B.x=(0,W.Clamp)(Z.x,l.x,C.x),B.y=(0,W.Clamp)(Z.y,l.y,C.y),B.z=(0,W.Clamp)(Z.z,l.z,C.z),B.w=(0,W.Clamp)(Z.w,l.w,C.w),B}static CheckExtends(Z,l,C){l.minimizeInPlace(Z),C.maximizeInPlace(Z)}static get ZeroReadOnly(){return Y._ZeroReadOnly}static Normalize(Z){return Y.NormalizeToRef(Z,new Y)}static NormalizeToRef(Z,l){return Z.normalizeToRef(l),l}static Minimize(Z,l){const C=new Y;return C.B(Z),C.minimizeInPlace(l),C}static Maximize(Z,l){const C=new Y;return C.B(Z),C.maximizeInPlace(l),C}static Distance(Z,l){return Math.sqrt(Y.DistanceSquared(Z,l))}static DistanceSquared(Z,l){const C=Z.x-l.x,B=Z.y-l.y,x=Z.z-l.z,b=Z.w-l.w;return C*C+B*B+x*x+b*b}static Center(Z,l){return Y.CenterToRef(Z,l,new Y)}static CenterToRef(Z,l,C){return C.x=(Z.x+l.x)/2,C.y=(Z.y+l.y)/2,C.z=(Z.z+l.z)/2,C.w=(Z.w+l.w)/2,C}static TransformCoordinates(Z,l){return Y.TransformCoordinatesToRef(Z,l,new Y)}static TransformCoordinatesToRef(Z,l,C){return Y.TransformCoordinatesFromFloatsToRef(Z._x,Z._y,Z._z,l,C),C}static TransformCoordinatesFromFloatsToRef(Z,l,C,B,x){const b=B.m,K=Z*b[0]+l*b[4]+C*b[8]+b[12],f=Z*b[1]+l*b[5]+C*b[9]+b[13],W=Z*b[2]+l*b[6]+C*b[10]+b[14],J=Z*b[3]+l*b[7]+C*b[11]+b[15];return x.x=K,x.y=f,x.z=W,x.w=J,x}static TransformNormal(Z,l){return Y.TransformNormalToRef(Z,l,new Y)}static TransformNormalToRef(Z,l,C){const B=l.m,x=Z.x*B[0]+Z.y*B[4]+Z.z*B[8],b=Z.x*B[1]+Z.y*B[5]+Z.z*B[9],K=Z.x*B[2]+Z.y*B[6]+Z.z*B[10];return C.x=x,C.y=b,C.z=K,C.w=Z.w,C}static TransformNormalFromFloatsToRef(Z,l,C,B,x,b){const K=x.m;return b.x=Z*K[0]+l*K[4]+C*K[8],b.y=Z*K[1]+l*K[5]+C*K[9],b.z=Z*K[2]+l*K[6]+C*K[10],b.w=B,b}static FromVector3(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Y(Z._x,Z._y,Z._z,l)}static Dot(Z,l){return Z.x*l.x+Z.y*l.y+Z.z*l.z+Z.w*l.w}}Y._V8PerformanceHack=new Y(.5,.5,.5,.5),Y._ZeroReadOnly=Y.Zero(),Object.defineProperties(Y.prototype,{dimension:{value:[4]},rank:{value:1}});class P{get x(){return this._x}set x(Z){this._x=Z,this._isDirty=!0}get y(){return this._y}set y(Z){this._y=Z,this._isDirty=!0}get z(){return this._z}set z(Z){this._z=Z,this._isDirty=!0}get w(){return this._w}set w(Z){this._w=Z,this._isDirty=!0}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=Z,this._y=l,this._z=C,this._w=B}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let Z=a(this._x);return Z=397*Z^a(this._y),Z=397*Z^a(this._z),Z=397*Z^a(this._w),Z}Yb(){return[this._x,this._y,this._z,this._w]}toArray(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[l]=this._x,Z[l+1]=this._y,Z[l+2]=this._z,Z[l+3]=this._w,this}aC(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(Z,l,this)}equals(Z){return Z&&this._x===Z._x&&this._y===Z._y&&this._z===Z._z&&this._w===Z._w}equalsWithEpsilon(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.e;return Z&&(0,W.WithinEpsilon)(this._x,Z._x,l)&&(0,W.WithinEpsilon)(this._y,Z._y,l)&&(0,W.WithinEpsilon)(this._z,Z._z,l)&&(0,W.WithinEpsilon)(this._w,Z._w,l)}isApprox(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.e;return Z&&((0,W.WithinEpsilon)(this._x,Z._x,l)&&(0,W.WithinEpsilon)(this._y,Z._y,l)&&(0,W.WithinEpsilon)(this._z,Z._z,l)&&(0,W.WithinEpsilon)(this._w,Z._w,l)||(0,W.WithinEpsilon)(this._x,-Z._x,l)&&(0,W.WithinEpsilon)(this._y,-Z._y,l)&&(0,W.WithinEpsilon)(this._z,-Z._z,l)&&(0,W.WithinEpsilon)(this._w,-Z._w,l))}clone(){return new P(this._x,this._y,this._z,this._w)}B(Z){return this._x=Z._x,this._y=Z._y,this._z=Z._z,this._w=Z._w,this._isDirty=!0,this}rb(Z,l,C,B){return this._x=Z,this._y=l,this._z=C,this._w=B,this._isDirty=!0,this}set(Z,l,C,B){return this.rb(Z,l,C,B)}ob(Z){return this.rb(Z,Z,Z,Z)}add(Z){return new P(this._x+Z._x,this._y+Z._y,this._z+Z._z,this._w+Z._w)}addInPlace(Z){return this._x+=Z._x,this._y+=Z._y,this._z+=Z._z,this._w+=Z._w,this._isDirty=!0,this}addToRef(Z,l){return l._x=this._x+Z._x,l._y=this._y+Z._y,l._z=this._z+Z._z,l._w=this._w+Z._w,l._isDirty=!0,l}addInPlaceFromFloats(Z,l,C,B){return this._x+=Z,this._y+=l,this._z+=C,this._w+=B,this._isDirty=!0,this}subtractToRef(Z,l){return l._x=this._x-Z._x,l._y=this._y-Z._y,l._z=this._z-Z._z,l._w=this._w-Z._w,l._isDirty=!0,l}subtractFromFloats(Z,l,C,B){return this.subtractFromFloatsToRef(Z,l,C,B,new P)}subtractFromFloatsToRef(Z,l,C,B,x){return x._x=this._x-Z,x._y=this._y-l,x._z=this._z-C,x._w=this._w-B,x._isDirty=!0,x}zl(Z){return new P(this._x-Z._x,this._y-Z._y,this._z-Z._z,this._w-Z._w)}JG(Z){return this._x-=Z._x,this._y-=Z._y,this._z-=Z._z,this._w-=Z._w,this._isDirty=!0,this}scale(Z){return new P(this._x*Z,this._y*Z,this._z*Z,this._w*Z)}scaleToRef(Z,l){return l._x=this._x*Z,l._y=this._y*Z,l._z=this._z*Z,l._w=this._w*Z,l._isDirty=!0,l}scaleInPlace(Z){return this._x*=Z,this._y*=Z,this._z*=Z,this._w*=Z,this._isDirty=!0,this}scaleAndAddToRef(Z,l){return l._x+=this._x*Z,l._y+=this._y*Z,l._z+=this._z*Z,l._w+=this._w*Z,l._isDirty=!0,l}multiply(Z){const l=new P(0,0,0,1);return this.multiplyToRef(Z,l),l}multiplyToRef(Z,l){const C=this._x*Z._w+this._y*Z._z-this._z*Z._y+this._w*Z._x,B=-this._x*Z._z+this._y*Z._w+this._z*Z._x+this._w*Z._y,x=this._x*Z._y-this._y*Z._x+this._z*Z._w+this._w*Z._z,b=-this._x*Z._x-this._y*Z._y-this._z*Z._z+this._w*Z._w;return l.rb(C,B,x,b),l}multiplyInPlace(Z){return this.multiplyToRef(Z,this)}multiplyByFloats(Z,l,C,B){return this._x*=Z,this._y*=l,this._z*=C,this._w*=B,this._isDirty=!0,this}divide(Z){throw new ReferenceError("Can not divide a quaternion")}divideToRef(Z,l){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(Z){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new P)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(Z){return Z._x=-this._x,Z._y=-this._y,Z._z=-this._z,Z._w=-this._w,Z._isDirty=!0,Z}equalsToFloats(Z,l,C,B){return this._x===Z&&this._y===l&&this._z===C&&this._w===B}floorToRef(Z){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(Z){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(Z){return Z.rb(-this._x,-this._y,-this._z,this._w),Z}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new P(-this._x,-this._y,-this._z,this._w)}invert(){const Z=this.conjugate(),l=this.lengthSquared();return 0==l||1==l||Z.scaleInPlace(1/l),Z}invertInPlace(){this.conjugateInPlace();const Z=this.lengthSquared();return 0==Z||1==Z||this.scaleInPlace(1/Z),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){const Z=new P(0,0,0,1);return this.normalizeToRef(Z),Z}normalizeToRef(Z){const l=this.length();return 0===l||1===l?Z.rb(this._x,this._y,this._z,this._w):this.scaleToRef(1/l,Z)}toEulerAngles(){const Z=z.Zero();return this.toEulerAnglesToRef(Z),Z}toEulerAnglesToRef(Z){const l=this._z,C=this._x,B=this._y,x=this._w,b=B*l-C*x,K=.4999999;if(b<-K)Z._y=2*Math.atan2(B,x),Z._x=Math.PI/2,Z._z=0,Z._isDirty=!0;else if(b>K)Z._y=2*Math.atan2(B,x),Z._x=-Math.PI/2,Z._z=0,Z._isDirty=!0;else{const K=x*x,f=l*l,W=C*C,J=B*B;Z._z=Math.atan2(2*(C*B+l*x),-f-W+J+K),Z._x=Math.asin(-2*b),Z._y=Math.atan2(2*(l*C+B*x),f-W-J+K),Z._isDirty=!0}return Z}toAlphaBetaGammaToRef(Z){const l=this._z,C=this._x,B=this._y,x=this._w,b=Math.sqrt(C*C+B*B),K=Math.sqrt(l*l+x*x),f=2*Math.atan2(b,K),W=2*Math.atan2(l,x),J=2*Math.atan2(B,C),d=(W+J)/2,E=(W-J)/2;return Z.set(E,f,d),Z}toRotationMatrix(Z){return S.FromQuaternionToRef(this,Z),Z}fromRotationMatrix(Z){return P.FromRotationMatrixToRef(Z,this),this}dot(Z){return this._x*Z._x+this._y*Z._y+this._z*Z._z+this._w*Z._w}toAxisAngle(){const Z=z.Zero();return{axis:Z,angle:this.toAxisAngleToRef(Z)}}toAxisAngleToRef(Z){let l=0;const C=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),B=this._w;return C>0?(l=2*Math.atan2(C,B),Z.set(this._x/C,this._y/C,this._z/C)):(l=0,Z.set(1,0,0)),l}static FromRotationMatrix(Z){const l=new P;return P.FromRotationMatrixToRef(Z,l),l}static FromRotationMatrixToRef(Z,l){const C=Z.m,B=C[0],x=C[4],b=C[8],K=C[1],f=C[5],W=C[9],J=C[2],d=C[6],E=C[10],G=B+f+E;let a;return G>0?(a=.5/Math.sqrt(G+1),l._w=.25/a,l._x=(d-W)*a,l._y=(b-J)*a,l._z=(K-x)*a,l._isDirty=!0):B>f&&B>E?(a=2*Math.sqrt(1+B-f-E),l._w=(d-W)/a,l._x=.25*a,l._y=(x+K)/a,l._z=(b+J)/a,l._isDirty=!0):f>E?(a=2*Math.sqrt(1+f-B-E),l._w=(b-J)/a,l._x=(x+K)/a,l._y=.25*a,l._z=(W+d)/a,l._isDirty=!0):(a=2*Math.sqrt(1+E-B-f),l._w=(K-x)/a,l._x=(b+J)/a,l._y=(W+d)/a,l._z=.25*a,l._isDirty=!0),l}static Dot(Z,l){return Z._x*l._x+Z._y*l._y+Z._z*l._z+Z._w*l._w}static AreClose(Z,l){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const B=P.Dot(Z,l);return 1-B*B<=C}static SmoothToRef(Z,l,C,B,x){let b=0===B?1:C/B;return b=(0,W.Clamp)(b,0,1),P.SlerpToRef(Z,l,b,x),x}static Zero(){return new P(0,0,0,0)}static Inverse(Z){return new P(-Z._x,-Z._y,-Z._z,Z._w)}static InverseToRef(Z,l){return l.set(-Z._x,-Z._y,-Z._z,Z._w),l}static Identity(){return new P(0,0,0,1)}static IsIdentity(Z){return Z&&0===Z._x&&0===Z._y&&0===Z._z&&1===Z._w}static RotationAxis(Z,l){return P.RotationAxisToRef(Z,l,new P)}static RotationAxisToRef(Z,l,C){C._w=Math.cos(l/2);const B=Math.sin(l/2)/Z.length();return C._x=Z._x*B,C._y=Z._y*B,C._z=Z._z*B,C._isDirty=!0,C}static il(Z,l){return l||(l=0),new P(Z[l],Z[l+1],Z[l+2],Z[l+3])}static FromArrayToRef(Z,l,C){return C._x=Z[l],C._y=Z[l+1],C._z=Z[l+2],C._w=Z[l+3],C._isDirty=!0,C}static FromFloatsToRef(Z,l,C,B,x){return x.rb(Z,l,C,B),x}static FromEulerAngles(Z,l,C){const B=new P;return P.RotationYawPitchRollToRef(l,Z,C,B),B}static FromEulerAnglesToRef(Z,l,C,B){return P.RotationYawPitchRollToRef(l,Z,C,B),B}static FromEulerVector(Z){const l=new P;return P.RotationYawPitchRollToRef(Z._y,Z._x,Z._z,l),l}static FromEulerVectorToRef(Z,l){return P.RotationYawPitchRollToRef(Z._y,Z._x,Z._z,l),l}static FromUnitVectorsToRef(Z,l,C){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:B.e;const b=z.Dot(Z,l)+1;return b<x?Math.abs(Z.x)>Math.abs(Z.z)?C.set(-Z.y,Z.x,0,0):C.set(0,-Z.z,Z.y,0):(z.CrossToRef(Z,l,s.ql[0]),C.set(s.ql[0].x,s.ql[0].y,s.ql[0].z,b)),C.normalize()}static RotationYawPitchRoll(Z,l,C){const B=new P;return P.RotationYawPitchRollToRef(Z,l,C,B),B}static RotationYawPitchRollToRef(Z,l,C,B){const x=.5*C,b=.5*l,K=.5*Z,f=Math.sin(x),W=Math.cos(x),J=Math.sin(b),d=Math.cos(b),E=Math.sin(K),G=Math.cos(K);return B._x=G*J*W+E*d*f,B._y=E*d*W-G*J*f,B._z=G*d*f-E*J*W,B._w=G*d*W+E*J*f,B._isDirty=!0,B}static RotationAlphaBetaGamma(Z,l,C){const B=new P;return P.RotationAlphaBetaGammaToRef(Z,l,C,B),B}static RotationAlphaBetaGammaToRef(Z,l,C,B){const x=.5*(C+Z),b=.5*(C-Z),K=.5*l;return B._x=Math.cos(b)*Math.sin(K),B._y=Math.sin(b)*Math.sin(K),B._z=Math.sin(x)*Math.cos(K),B._w=Math.cos(x)*Math.cos(K),B._isDirty=!0,B}static RotationQuaternionFromAxis(Z,l,C){const B=new P(0,0,0,0);return P.RotationQuaternionFromAxisToRef(Z,l,C,B),B}static RotationQuaternionFromAxisToRef(Z,l,C,B){const x=i.Matrix[0];return Z=Z.normalizeToRef(i.ql[0]),l=l.normalizeToRef(i.ql[1]),C=C.normalizeToRef(i.ql[2]),S.FromXYZAxesToRef(Z,l,C,x),P.FromRotationMatrixToRef(x,B),B}static FromLookDirectionLH(Z,l){const C=new P;return P.FromLookDirectionLHToRef(Z,l,C),C}static FromLookDirectionLHToRef(Z,l,C){const B=i.Matrix[0];return S.LookDirectionLHToRef(Z,l,B),P.FromRotationMatrixToRef(B,C),C}static FromLookDirectionRH(Z,l){const C=new P;return P.FromLookDirectionRHToRef(Z,l,C),C}static FromLookDirectionRHToRef(Z,l,C){const B=i.Matrix[0];return S.LookDirectionRHToRef(Z,l,B),P.FromRotationMatrixToRef(B,C)}static Slerp(Z,l,C){const B=P.Identity();return P.SlerpToRef(Z,l,C,B),B}static SlerpToRef(Z,l,C,B){let x,b,K=Z._x*l._x+Z._y*l._y+Z._z*l._z+Z._w*l._w,f=!1;if(K<0&&(f=!0,K=-K),K>.999999)b=1-C,x=f?-C:C;else{const Z=Math.acos(K),l=1/Math.sin(Z);b=Math.sin((1-C)*Z)*l,x=f?-Math.sin(C*Z)*l:Math.sin(C*Z)*l}return B._x=b*Z._x+x*l._x,B._y=b*Z._y+x*l._y,B._z=b*Z._z+x*l._z,B._w=b*Z._w+x*l._w,B._isDirty=!0,B}static Hermite(Z,l,C,B,x){const b=x*x,K=x*b,f=2*K-3*b+1,W=-2*K+3*b,J=K-2*b+x,d=K-b,E=Z._x*f+C._x*W+l._x*J+B._x*d,G=Z._y*f+C._y*W+l._y*J+B._y*d,a=Z._z*f+C._z*W+l._z*J+B._z*d,q=Z._w*f+C._w*W+l._w*J+B._w*d;return new P(E,G,a,q)}static Hermite1stDerivative(Z,l,C,B,x){const b=new P;return this.Hermite1stDerivativeToRef(Z,l,C,B,x,b),b}static Hermite1stDerivativeToRef(Z,l,C,B,x,b){const K=x*x;return b._x=6*(K-x)*Z._x+(3*K-4*x+1)*l._x+6*(-K+x)*C._x+(3*K-2*x)*B._x,b._y=6*(K-x)*Z._y+(3*K-4*x+1)*l._y+6*(-K+x)*C._y+(3*K-2*x)*B._y,b._z=6*(K-x)*Z._z+(3*K-4*x+1)*l._z+6*(-K+x)*C._z+(3*K-2*x)*B._z,b._w=6*(K-x)*Z._w+(3*K-4*x+1)*l._w+6*(-K+x)*C._w+(3*K-2*x)*B._w,b._isDirty=!0,b}static Normalize(Z){const l=P.Zero();return P.NormalizeToRef(Z,l),l}static NormalizeToRef(Z,l){return Z.normalizeToRef(l),l}static Clamp(Z,l,C){const B=new P;return P.ClampToRef(Z,l,C,B),B}static ClampToRef(Z,l,C,B){return B.rb((0,W.Clamp)(Z.x,l.x,C.x),(0,W.Clamp)(Z.y,l.y,C.y),(0,W.Clamp)(Z.z,l.z,C.z),(0,W.Clamp)(Z.w,l.w,C.w))}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new P((0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).rb((0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l),(0,W.RandomRange)(Z,l))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(Z,l){return Math.sqrt(P.DistanceSquared(Z,l))}static DistanceSquared(Z,l){const C=Z.x-l.x,B=Z.y-l.y,x=Z.z-l.z,b=Z.w-l.w;return C*C+B*B+x*x+b*b}static Center(Z,l){return P.CenterToRef(Z,l,P.Zero())}static CenterToRef(Z,l,C){return C.rb((Z.x+l.x)/2,(Z.y+l.y)/2,(Z.z+l.z)/2,(Z.w+l.w)/2)}}P._V8PerformanceHack=new P(.5,.5,.5,.5),Object.defineProperties(P.prototype,{dimension:{value:[4]},rank:{value:1}});class S{static get Use64Bits(){return K.b.MatrixUse64Bits}get m(){return this.Kb}markAsUpdated(){this.updateFlag=J._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(Z){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=Z,this._isIdentity3x2=Z||C,this._isIdentityDirty=!this._isIdentity&&l,this._isIdentity3x2Dirty=!this._isIdentity3x2&&B}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,K.b.MatrixTrackPrecisionChange&&K.b.MatrixTrackedMatrices.push(this),this.Kb=new K.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const Z=this.Kb;this._isIdentity=1===Z[0]&&0===Z[1]&&0===Z[2]&&0===Z[3]&&0===Z[4]&&1===Z[5]&&0===Z[6]&&0===Z[7]&&0===Z[8]&&0===Z[9]&&1===Z[10]&&0===Z[11]&&0===Z[12]&&0===Z[13]&&0===Z[14]&&1===Z[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Kb[0]||1!==this.Kb[5]||1!==this.Kb[15]||0!==this.Kb[1]||0!==this.Kb[2]||0!==this.Kb[3]||0!==this.Kb[4]||0!==this.Kb[6]||0!==this.Kb[7]||0!==this.Kb[8]||0!==this.Kb[9]||0!==this.Kb[10]||0!==this.Kb[11]||0!==this.Kb[12]||0!==this.Kb[13]||0!==this.Kb[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const Z=this.Kb,l=Z[0],C=Z[1],B=Z[2],x=Z[3],b=Z[4],K=Z[5],f=Z[6],W=Z[7],J=Z[8],d=Z[9],E=Z[10],G=Z[11],a=Z[12],q=Z[13],z=Z[14],Y=Z[15],P=E*Y-z*G,S=d*Y-q*G,i=d*z-q*E,s=J*Y-a*G,F=J*z-E*a,n=J*q-a*d;return l*+(K*P-f*S+W*i)+C*-(b*P-f*s+W*F)+B*+(b*S-K*s+W*n)+x*-(b*i-K*F+f*n)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!Z)return this.Kb;const C=this.Kb;for(let B=0;B<16;B++)Z[l+B]=C[B];return this}Yb(){return this.Kb}aC(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(Z,l,this)}rb(){for(var Z=arguments.length,l=new Array(Z),C=0;C<Z;C++)l[C]=arguments[C];return S.FromArrayToRef(l,0,this)}set(){const Z=this.Kb;for(let l=0;l<16;l++)Z[l]=l<0||arguments.length<=l?void 0:arguments[l];return this.markAsUpdated(),this}ob(Z){const l=this.Kb;for(let C=0;C<16;C++)l[C]=Z;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return S.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(Z){const l=new S;return this.addToRef(Z,l),l}addToRef(Z,l){const C=this.Kb,B=l.Kb,x=Z.m;for(let b=0;b<16;b++)B[b]=C[b]+x[b];return l.markAsUpdated(),l}addToSelf(Z){const l=this.Kb,C=Z.m;return l[0]+=C[0],l[1]+=C[1],l[2]+=C[2],l[3]+=C[3],l[4]+=C[4],l[5]+=C[5],l[6]+=C[6],l[7]+=C[7],l[8]+=C[8],l[9]+=C[9],l[10]+=C[10],l[11]+=C[11],l[12]+=C[12],l[13]+=C[13],l[14]+=C[14],l[15]+=C[15],this.markAsUpdated(),this}addInPlace(Z){const l=this.Kb,C=Z.m;for(let B=0;B<16;B++)l[B]+=C[B];return this.markAsUpdated(),this}addInPlaceFromFloats(){const Z=this.Kb;for(let l=0;l<16;l++)Z[l]+=l<0||arguments.length<=l?void 0:arguments[l];return this.markAsUpdated(),this}zl(Z){const l=this.Kb,C=Z.m;for(let B=0;B<16;B++)l[B]-=C[B];return this.markAsUpdated(),this}subtractToRef(Z,l){const C=this.Kb,B=Z.m,x=l.Kb;for(let b=0;b<16;b++)x[b]=C[b]-B[b];return l.markAsUpdated(),l}JG(Z){const l=this.Kb,C=Z.m;for(let B=0;B<16;B++)l[B]-=C[B];return this.markAsUpdated(),this}subtractFromFloats(){for(var Z=arguments.length,l=new Array(Z),C=0;C<Z;C++)l[C]=arguments[C];return this.subtractFromFloatsToRef(...l,new S)}subtractFromFloatsToRef(){for(var Z=arguments.length,l=new Array(Z),C=0;C<Z;C++)l[C]=arguments[C];const B=l.pop(),x=this.Kb,b=B.Kb,K=l;for(let f=0;f<16;f++)b[f]=x[f]-K[f];return B.markAsUpdated(),B}invertToRef(Z){return!0===this._isIdentity?(S.IdentityToRef(Z),Z):(G(this,Z.Yb())?Z.markAsUpdated():Z.B(this),Z)}addAtIndex(Z,l){return this.Kb[Z]+=l,this.markAsUpdated(),this}multiplyAtIndex(Z,l){return this.Kb[Z]*=l,this.markAsUpdated(),this}setTranslationFromFloats(Z,l,C){return this.Kb[12]=Z,this.Kb[13]=l,this.Kb[14]=C,this.markAsUpdated(),this}addTranslationFromFloats(Z,l,C){return this.Kb[12]+=Z,this.Kb[13]+=l,this.Kb[14]+=C,this.markAsUpdated(),this}setTranslation(Z){return this.setTranslationFromFloats(Z._x,Z._y,Z._z)}getTranslation(){return new z(this.Kb[12],this.Kb[13],this.Kb[14])}getTranslationToRef(Z){return Z.x=this.Kb[12],Z.y=this.Kb[13],Z.z=this.Kb[14],Z}removeRotationAndScaling(){const Z=this.m;return S.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,Z[12],Z[13],Z[14],Z[15],this),this._updateIdentityStatus(0===Z[12]&&0===Z[13]&&0===Z[14]&&1===Z[15]),this}B(Z){Z.copyToArray(this.Kb);const l=Z;return this.updateFlag=l.updateFlag,this._updateIdentityStatus(l._isIdentity,l._isIdentityDirty,l._isIdentity3x2,l._isIdentity3x2Dirty),this}copyToArray(Z){return E(this,Z,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(Z){const l=new S;return this.multiplyToRef(Z,l),l}multiplyInPlace(Z){const l=this.Kb,C=Z.m;for(let B=0;B<16;B++)l[B]*=C[B];return this.markAsUpdated(),this}multiplyByFloats(){const Z=this.Kb;for(let l=0;l<16;l++)Z[l]*=l<0||arguments.length<=l?void 0:arguments[l];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var Z=arguments.length,l=new Array(Z),C=0;C<Z;C++)l[C]=arguments[C];const B=l.pop(),x=this.Kb,b=B.Kb,K=l;for(let f=0;f<16;f++)b[f]=x[f]*K[f];return B.markAsUpdated(),B}multiplyToRef(Z,l){return this._isIdentity?(l.B(Z),l):Z._isIdentity?(l.B(this),l):(this.multiplyToArray(Z,l.Kb,0),l.markAsUpdated(),l)}multiplyToArray(Z,l,C){return d(this,Z,l,C),this}divide(Z){return this.divideToRef(Z,new S)}divideToRef(Z,l){const C=this.Kb,B=Z.m,x=l.Kb;for(let b=0;b<16;b++)x[b]=C[b]/B[b];return l.markAsUpdated(),l}divideInPlace(Z){const l=this.Kb,C=Z.m;for(let B=0;B<16;B++)l[B]/=C[B];return this.markAsUpdated(),this}minimizeInPlace(Z){const l=this.Kb,C=Z.m;for(let B=0;B<16;B++)l[B]=Math.min(l[B],C[B]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const Z=this.Kb;for(let l=0;l<16;l++)Z[l]=Math.min(Z[l],l<0||arguments.length<=l?void 0:arguments[l]);return this.markAsUpdated(),this}maximizeInPlace(Z){const l=this.Kb,C=Z.m;for(let B=0;B<16;B++)l[B]=Math.min(l[B],C[B]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const Z=this.Kb;for(let l=0;l<16;l++)Z[l]=Math.min(Z[l],l<0||arguments.length<=l?void 0:arguments[l]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new S)}negateInPlace(){const Z=this.Kb;for(let l=0;l<16;l++)Z[l]=-Z[l];return this.markAsUpdated(),this}negateToRef(Z){const l=this.Kb,C=Z.Kb;for(let B=0;B<16;B++)C[B]=-l[B];return Z.markAsUpdated(),Z}equals(Z){const l=Z;if(!l)return!1;if((this._isIdentity||l._isIdentity)&&!this._isIdentityDirty&&!l._isIdentityDirty)return this._isIdentity&&l._isIdentity;const C=this.m,B=l.m;return C[0]===B[0]&&C[1]===B[1]&&C[2]===B[2]&&C[3]===B[3]&&C[4]===B[4]&&C[5]===B[5]&&C[6]===B[6]&&C[7]===B[7]&&C[8]===B[8]&&C[9]===B[9]&&C[10]===B[10]&&C[11]===B[11]&&C[12]===B[12]&&C[13]===B[13]&&C[14]===B[14]&&C[15]===B[15]}equalsWithEpsilon(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this.Kb,B=Z.m;for(let x=0;x<16;x++)if(!(0,W.WithinEpsilon)(C[x],B[x],l))return!1;return!0}equalsToFloats(){const Z=this.Kb;for(let l=0;l<16;l++)if(Z[l]!=(l<0||arguments.length<=l?void 0:arguments[l]))return!1;return!0}floor(){return this.floorToRef(new S)}floorToRef(Z){const l=this.Kb,C=Z.Kb;for(let B=0;B<16;B++)C[B]=Math.floor(l[B]);return Z.markAsUpdated(),Z}fract(){return this.fractToRef(new S)}fractToRef(Z){const l=this.Kb,C=Z.Kb;for(let B=0;B<16;B++)C[B]=l[B]-Math.floor(l[B]);return Z.markAsUpdated(),Z}clone(){const Z=new S;return Z.B(this),Z}getClassName(){return"Matrix"}getHashCode(){let Z=a(this.Kb[0]);for(let l=1;l<16;l++)Z=397*Z^a(this.Kb[l]);return Z}decomposeToTransformNode(Z){return Z.rotationQuaternion=Z.rotationQuaternion||new P,this.decompose(Z.eb,Z.rotationQuaternion,Z.position)}decompose(Z,l,C,B){let x=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return C&&C.ob(0),Z&&Z.ob(1),l&&l.rb(0,0,0,1),!0;const b=this.Kb;if(C&&C.rb(b[12],b[13],b[14]),(Z=Z||i.ql[0]).x=Math.sqrt(b[0]*b[0]+b[1]*b[1]+b[2]*b[2]),Z.y=Math.sqrt(b[4]*b[4]+b[5]*b[5]+b[6]*b[6]),Z.z=Math.sqrt(b[8]*b[8]+b[9]*b[9]+b[10]*b[10]),B){const l=(x?B.absoluteScaling.x:B.eb.x)<0?-1:1,C=(x?B.absoluteScaling.y:B.eb.y)<0?-1:1,b=(x?B.absoluteScaling.z:B.eb.z)<0?-1:1;Z.x*=l,Z.y*=C,Z.z*=b}else this.determinant()<=0&&(Z.y*=-1);if(0===Z._x||0===Z._y||0===Z._z)return l&&l.rb(0,0,0,1),!1;if(l){const C=1/Z._x,B=1/Z._y,x=1/Z._z;S.FromValuesToRef(b[0]*C,b[1]*C,b[2]*C,0,b[4]*B,b[5]*B,b[6]*B,0,b[8]*x,b[9]*x,b[10]*x,0,0,0,0,1,i.Matrix[0]),P.FromRotationMatrixToRef(i.Matrix[0],l)}return!0}getRow(Z){if(Z<0||Z>3)return null;const l=4*Z;return new Y(this.Kb[l+0],this.Kb[l+1],this.Kb[l+2],this.Kb[l+3])}getRowToRef(Z,l){if(Z>=0&&Z<=3){const C=4*Z;l.x=this.Kb[C+0],l.y=this.Kb[C+1],l.z=this.Kb[C+2],l.w=this.Kb[C+3]}return l}setRow(Z,l){return this.setRowFromFloats(Z,l.x,l.y,l.z,l.w)}transpose(){const Z=new S;return S.TransposeToRef(this,Z),Z}transposeToRef(Z){return S.TransposeToRef(this,Z),Z}setRowFromFloats(Z,l,C,B,x){if(Z<0||Z>3)return this;const b=4*Z;return this.Kb[b+0]=l,this.Kb[b+1]=C,this.Kb[b+2]=B,this.Kb[b+3]=x,this.markAsUpdated(),this}scale(Z){const l=new S;return this.scaleToRef(Z,l),l}scaleToRef(Z,l){for(let C=0;C<16;C++)l.Kb[C]=this.Kb[C]*Z;return l.markAsUpdated(),l}scaleAndAddToRef(Z,l){for(let C=0;C<16;C++)l.Kb[C]+=this.Kb[C]*Z;return l.markAsUpdated(),l}scaleInPlace(Z){const l=this.Kb;for(let C=0;C<16;C++)l[C]*=Z;return this.markAsUpdated(),this}toNormalMatrix(Z){const l=i.Matrix[0];this.invertToRef(l),l.transposeToRef(Z);const C=Z.Kb;return S.FromValuesToRef(C[0],C[1],C[2],0,C[4],C[5],C[6],0,C[8],C[9],C[10],0,0,0,0,1,Z),Z}getRotationMatrix(){const Z=new S;return this.getRotationMatrixToRef(Z),Z}getRotationMatrixToRef(Z){const l=i.ql[0];if(!this.decompose(l))return S.IdentityToRef(Z),Z;const C=this.Kb,B=1/l._x,x=1/l._y,b=1/l._z;return S.FromValuesToRef(C[0]*B,C[1]*B,C[2]*B,0,C[4]*x,C[5]*x,C[6]*x,0,C[8]*b,C[9]*b,C[10]*b,0,0,0,0,1,Z),Z}toggleModelMatrixHandInPlace(){const Z=this.Kb;return Z[2]*=-1,Z[6]*=-1,Z[8]*=-1,Z[9]*=-1,Z[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const Z=this.Kb;return Z[8]*=-1,Z[9]*=-1,Z[10]*=-1,Z[11]*=-1,this.markAsUpdated(),this}static il(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=new S;return S.FromArrayToRef(Z,l,C),C}static FromArrayToRef(Z,l,C){for(let B=0;B<16;B++)C.Kb[B]=Z[B+l];return C.markAsUpdated(),C}static FromFloat32ArrayToRefScaled(Z,l,C,B){return B.Kb[0]=Z[0+l]*C,B.Kb[1]=Z[1+l]*C,B.Kb[2]=Z[2+l]*C,B.Kb[3]=Z[3+l]*C,B.Kb[4]=Z[4+l]*C,B.Kb[5]=Z[5+l]*C,B.Kb[6]=Z[6+l]*C,B.Kb[7]=Z[7+l]*C,B.Kb[8]=Z[8+l]*C,B.Kb[9]=Z[9+l]*C,B.Kb[10]=Z[10+l]*C,B.Kb[11]=Z[11+l]*C,B.Kb[12]=Z[12+l]*C,B.Kb[13]=Z[13+l]*C,B.Kb[14]=Z[14+l]*C,B.Kb[15]=Z[15+l]*C,B.markAsUpdated(),B}static get IdentityReadOnly(){return S._IdentityReadOnly}static FromValuesToRef(Z,l,C,B,x,b,K,f,W,J,d,E,G,a,q,z,Y){const P=Y.Kb;P[0]=Z,P[1]=l,P[2]=C,P[3]=B,P[4]=x,P[5]=b,P[6]=K,P[7]=f,P[8]=W,P[9]=J,P[10]=d,P[11]=E,P[12]=G,P[13]=a,P[14]=q,P[15]=z,Y.markAsUpdated()}static FromValues(Z,l,C,B,x,b,K,f,W,J,d,E,G,a,q,z){const Y=new S,P=Y.Kb;return P[0]=Z,P[1]=l,P[2]=C,P[3]=B,P[4]=x,P[5]=b,P[6]=K,P[7]=f,P[8]=W,P[9]=J,P[10]=d,P[11]=E,P[12]=G,P[13]=a,P[14]=q,P[15]=z,Y.markAsUpdated(),Y}static Compose(Z,l,C){const B=new S;return S.ComposeToRef(Z,l,C,B),B}static ComposeToRef(Z,l,C,B){const x=B.Kb,b=l._x,K=l._y,f=l._z,W=l._w,J=b+b,d=K+K,E=f+f,G=b*J,a=b*d,q=b*E,z=K*d,Y=K*E,P=f*E,S=W*J,i=W*d,s=W*E,F=Z._x,n=Z._y,c=Z._z;return x[0]=(1-(z+P))*F,x[1]=(a+s)*F,x[2]=(q-i)*F,x[3]=0,x[4]=(a-s)*n,x[5]=(1-(G+P))*n,x[6]=(Y+S)*n,x[7]=0,x[8]=(q+i)*c,x[9]=(Y-S)*c,x[10]=(1-(G+z))*c,x[11]=0,x[12]=C._x,x[13]=C._y,x[14]=C._z,x[15]=1,B.markAsUpdated(),B}static Identity(){const Z=S.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return Z._updateIdentityStatus(!0),Z}static IdentityToRef(Z){return S.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,Z),Z._updateIdentityStatus(!0),Z}static Zero(){const Z=S.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return Z._updateIdentityStatus(!1),Z}static RotationX(Z){const l=new S;return S.RotationXToRef(Z,l),l}static Invert(Z){const l=new S;return Z.invertToRef(l),l}static RotationXToRef(Z,l){const C=Math.sin(Z),B=Math.cos(Z);return S.FromValuesToRef(1,0,0,0,0,B,C,0,0,-C,B,0,0,0,0,1,l),l._updateIdentityStatus(1===B&&0===C),l}static RotationY(Z){const l=new S;return S.RotationYToRef(Z,l),l}static RotationYToRef(Z,l){const C=Math.sin(Z),B=Math.cos(Z);return S.FromValuesToRef(B,0,-C,0,0,1,0,0,C,0,B,0,0,0,0,1,l),l._updateIdentityStatus(1===B&&0===C),l}static RotationZ(Z){const l=new S;return S.RotationZToRef(Z,l),l}static RotationZToRef(Z,l){const C=Math.sin(Z),B=Math.cos(Z);return S.FromValuesToRef(B,C,0,0,-C,B,0,0,0,0,1,0,0,0,0,1,l),l._updateIdentityStatus(1===B&&0===C),l}static RotationAxis(Z,l){const C=new S;return S.RotationAxisToRef(Z,l,C),C}static RotationAxisToRef(Z,l,C){const B=Math.sin(-l),x=Math.cos(-l),b=1-x;Z=Z.normalizeToRef(i.ql[0]);const K=C.Kb;return K[0]=Z._x*Z._x*b+x,K[1]=Z._x*Z._y*b-Z._z*B,K[2]=Z._x*Z._z*b+Z._y*B,K[3]=0,K[4]=Z._y*Z._x*b+Z._z*B,K[5]=Z._y*Z._y*b+x,K[6]=Z._y*Z._z*b-Z._x*B,K[7]=0,K[8]=Z._z*Z._x*b-Z._y*B,K[9]=Z._z*Z._y*b+Z._x*B,K[10]=Z._z*Z._z*b+x,K[11]=0,K[12]=0,K[13]=0,K[14]=0,K[15]=1,C.markAsUpdated(),C}static RotationAlignToRef(Z,l,C){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const b=z.Dot(l,Z),K=C.Kb;if(b<-1+B.e)K[0]=-1,K[1]=0,K[2]=0,K[3]=0,K[4]=0,K[5]=x?1:-1,K[6]=0,K[7]=0,K[8]=0,K[9]=0,K[10]=x?-1:1,K[11]=0;else{const C=z.Cross(l,Z),B=1/(1+b);K[0]=C._x*C._x*B+b,K[1]=C._y*C._x*B-C._z,K[2]=C._z*C._x*B+C._y,K[3]=0,K[4]=C._x*C._y*B+C._z,K[5]=C._y*C._y*B+b,K[6]=C._z*C._y*B-C._x,K[7]=0,K[8]=C._x*C._z*B-C._y,K[9]=C._y*C._z*B+C._x,K[10]=C._z*C._z*B+b,K[11]=0}return K[12]=0,K[13]=0,K[14]=0,K[15]=1,C.markAsUpdated(),C}static RotationYawPitchRoll(Z,l,C){const B=new S;return S.RotationYawPitchRollToRef(Z,l,C,B),B}static RotationYawPitchRollToRef(Z,l,C,B){return P.RotationYawPitchRollToRef(Z,l,C,i.Quaternion[0]),i.Quaternion[0].toRotationMatrix(B),B}static Scaling(Z,l,C){const B=new S;return S.ScalingToRef(Z,l,C,B),B}static ScalingToRef(Z,l,C,B){return S.FromValuesToRef(Z,0,0,0,0,l,0,0,0,0,C,0,0,0,0,1,B),B._updateIdentityStatus(1===Z&&1===l&&1===C),B}static Translation(Z,l,C){const B=new S;return S.TranslationToRef(Z,l,C,B),B}static TranslationToRef(Z,l,C,B){return S.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,Z,l,C,1,B),B._updateIdentityStatus(0===Z&&0===l&&0===C),B}static Lerp(Z,l,C){const B=new S;return S.LerpToRef(Z,l,C,B),B}static LerpToRef(Z,l,C,B){const x=B.Kb,b=Z.m,K=l.m;for(let f=0;f<16;f++)x[f]=b[f]*(1-C)+K[f]*C;return B.markAsUpdated(),B}static DecomposeLerp(Z,l,C){const B=new S;return S.DecomposeLerpToRef(Z,l,C,B),B}static DecomposeLerpToRef(Z,l,C,B){const x=i.ql[0],b=i.Quaternion[0],K=i.ql[1];Z.decompose(x,b,K);const f=i.ql[2],W=i.Quaternion[1],J=i.ql[3];l.decompose(f,W,J);const d=i.ql[4];z.LerpToRef(x,f,C,d);const E=i.Quaternion[2];P.SlerpToRef(b,W,C,E);const G=i.ql[5];return z.LerpToRef(K,J,C,G),S.ComposeToRef(d,E,G,B),B}static LookAtLH(Z,l,C){const B=new S;return S.LookAtLHToRef(Z,l,C,B),B}static LookAtLHToRef(Z,l,C,B){const x=i.ql[0],b=i.ql[1],K=i.ql[2];l.subtractToRef(Z,K),K.normalize(),z.CrossToRef(C,K,x);const f=x.lengthSquared();0===f?x.x=1:x.normalizeFromLength(Math.sqrt(f)),z.CrossToRef(K,x,b),b.normalize();const W=-z.Dot(x,Z),J=-z.Dot(b,Z),d=-z.Dot(K,Z);return S.FromValuesToRef(x._x,b._x,K._x,0,x._y,b._y,K._y,0,x._z,b._z,K._z,0,W,J,d,1,B),B}static LookAtRH(Z,l,C){const B=new S;return S.LookAtRHToRef(Z,l,C,B),B}static LookAtRHToRef(Z,l,C,B){const x=i.ql[0],b=i.ql[1],K=i.ql[2];Z.subtractToRef(l,K),K.normalize(),z.CrossToRef(C,K,x);const f=x.lengthSquared();0===f?x.x=1:x.normalizeFromLength(Math.sqrt(f)),z.CrossToRef(K,x,b),b.normalize();const W=-z.Dot(x,Z),J=-z.Dot(b,Z),d=-z.Dot(K,Z);return S.FromValuesToRef(x._x,b._x,K._x,0,x._y,b._y,K._y,0,x._z,b._z,K._z,0,W,J,d,1,B),B}static LookDirectionLH(Z,l){const C=new S;return S.LookDirectionLHToRef(Z,l,C),C}static LookDirectionLHToRef(Z,l,C){const B=i.ql[0];B.B(Z),B.scaleInPlace(-1);const x=i.ql[1];return z.CrossToRef(l,B,x),S.FromValuesToRef(x._x,x._y,x._z,0,l._x,l._y,l._z,0,B._x,B._y,B._z,0,0,0,0,1,C),C}static LookDirectionRH(Z,l){const C=new S;return S.LookDirectionRHToRef(Z,l,C),C}static LookDirectionRHToRef(Z,l,C){const B=i.ql[2];return z.CrossToRef(l,Z,B),S.FromValuesToRef(B._x,B._y,B._z,0,l._x,l._y,l._z,0,Z._x,Z._y,Z._z,0,0,0,0,1,C),C}static OrthoLH(Z,l,C,B,x){const b=new S;return S.OrthoLHToRef(Z,l,C,B,b,x),b}static OrthoLHToRef(Z,l,C,B,x,b){const K=2/Z,f=2/l,W=2/(B-C),J=-(B+C)/(B-C);return S.FromValuesToRef(K,0,0,0,0,f,0,0,0,0,W,0,0,0,J,1,x),b&&x.multiplyToRef(F,x),x._updateIdentityStatus(1===K&&1===f&&1===W&&0===J),x}static OrthoOffCenterLH(Z,l,C,B,x,b,K){const f=new S;return S.OrthoOffCenterLHToRef(Z,l,C,B,x,b,f,K),f}static OrthoOffCenterLHToRef(Z,l,C,B,x,b,K,f){const W=2/(l-Z),J=2/(B-C),d=2/(b-x),E=-(b+x)/(b-x),G=(Z+l)/(Z-l),a=(B+C)/(C-B);return S.FromValuesToRef(W,0,0,0,0,J,0,0,0,0,d,0,G,a,E,1,K),f&&K.multiplyToRef(F,K),K.markAsUpdated(),K}static ObliqueOffCenterLHToRef(Z,l,C,B,x,b,K,f,W,J,d){const E=-K*Math.cos(f),G=-K*Math.sin(f);return S.TranslationToRef(0,0,-W,i.Matrix[1]),S.FromValuesToRef(1,0,0,0,0,1,0,0,E,G,1,0,0,0,0,1,i.Matrix[0]),i.Matrix[1].multiplyToRef(i.Matrix[0],i.Matrix[0]),S.TranslationToRef(0,0,W,i.Matrix[1]),i.Matrix[0].multiplyToRef(i.Matrix[1],i.Matrix[0]),S.OrthoOffCenterLHToRef(Z,l,C,B,x,b,J,d),i.Matrix[0].multiplyToRef(J,J),J}static OrthoOffCenterRH(Z,l,C,B,x,b,K){const f=new S;return S.OrthoOffCenterRHToRef(Z,l,C,B,x,b,f,K),f}static OrthoOffCenterRHToRef(Z,l,C,B,x,b,K,f){return S.OrthoOffCenterLHToRef(Z,l,C,B,x,b,K,f),K.Kb[10]*=-1,K}static ObliqueOffCenterRHToRef(Z,l,C,B,x,b,K,f,W,J,d){const E=K*Math.cos(f),G=K*Math.sin(f);return S.TranslationToRef(0,0,W,i.Matrix[1]),S.FromValuesToRef(1,0,0,0,0,1,0,0,E,G,1,0,0,0,0,1,i.Matrix[0]),i.Matrix[1].multiplyToRef(i.Matrix[0],i.Matrix[0]),S.TranslationToRef(0,0,-W,i.Matrix[1]),i.Matrix[0].multiplyToRef(i.Matrix[1],i.Matrix[0]),S.OrthoOffCenterRHToRef(Z,l,C,B,x,b,J,d),i.Matrix[0].multiplyToRef(J,J),J}static PerspectiveLH(Z,l,C,B,x){let b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const K=new S,f=2*C/Z,W=2*C/l,J=(B+C)/(B-C),d=-2*B*C/(B-C),E=Math.tan(b);return S.FromValuesToRef(f,0,0,0,0,W,0,E,0,0,J,1,0,0,d,0,K),x&&K.multiplyToRef(F,K),K._updateIdentityStatus(!1),K}static PerspectiveFovLH(Z,l,C,B,x){let b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,K=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const f=new S;return S.PerspectiveFovLHToRef(Z,l,C,B,f,!0,x,b,K),f}static PerspectiveFovLHToRef(Z,l,C,B,x){let b=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],K=arguments.length>6?arguments[6]:void 0,f=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,W=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const J=C,d=B,E=1/Math.tan(.5*Z),G=b?E/l:E,a=b?E:E*l,q=W&&0===J?-1:0!==d?(d+J)/(d-J):1,z=W&&0===J?2*d:0!==d?-2*d*J/(d-J):-2*J,Y=Math.tan(f);return S.FromValuesToRef(G,0,0,0,0,a,0,Y,0,0,q,1,0,0,z,0,x),K&&x.multiplyToRef(F,x),x._updateIdentityStatus(!1),x}static PerspectiveFovReverseLHToRef(Z,l,C,B,x){let b=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],K=arguments.length>6?arguments[6]:void 0,f=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const W=1/Math.tan(.5*Z),J=b?W/l:W,d=b?W:W*l,E=Math.tan(f);return S.FromValuesToRef(J,0,0,0,0,d,0,E,0,0,-C,1,0,0,1,0,x),K&&x.multiplyToRef(F,x),x._updateIdentityStatus(!1),x}static PerspectiveFovRH(Z,l,C,B,x){let b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,K=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const f=new S;return S.PerspectiveFovRHToRef(Z,l,C,B,f,!0,x,b,K),f}static PerspectiveFovRHToRef(Z,l,C,B,x){let b=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],K=arguments.length>6?arguments[6]:void 0,f=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,W=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const J=C,d=B,E=1/Math.tan(.5*Z),G=b?E/l:E,a=b?E:E*l,q=W&&0===J?1:0!==d?-(d+J)/(d-J):-1,z=W&&0===J?2*d:0!==d?-2*d*J/(d-J):-2*J,Y=Math.tan(f);return S.FromValuesToRef(G,0,0,0,0,a,0,Y,0,0,q,-1,0,0,z,0,x),K&&x.multiplyToRef(F,x),x._updateIdentityStatus(!1),x}static PerspectiveFovReverseRHToRef(Z,l,C,B,x){let b=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],K=arguments.length>6?arguments[6]:void 0,f=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const W=1/Math.tan(.5*Z),J=b?W/l:W,d=b?W:W*l,E=Math.tan(f);return S.FromValuesToRef(J,0,0,0,0,d,0,E,0,0,-C,-1,0,0,-1,0,x),K&&x.multiplyToRef(F,x),x._updateIdentityStatus(!1),x}static GetFinalMatrix(Z,l,C,B,x,b){const K=Z.width,f=Z.height,W=Z.x,J=Z.y,d=S.FromValues(K/2,0,0,0,0,-f/2,0,0,0,0,b-x,0,W+K/2,f/2+J,x,1),E=new S;return l.multiplyToRef(C,E),E.multiplyToRef(B,E),E.multiplyToRef(d,E)}static GetAsMatrix2x2(Z){const l=Z.m,C=[l[0],l[1],l[4],l[5]];return K.b.MatrixUse64Bits?C:new Float32Array(C)}static GetAsMatrix3x3(Z){const l=Z.m,C=[l[0],l[1],l[2],l[4],l[5],l[6],l[8],l[9],l[10]];return K.b.MatrixUse64Bits?C:new Float32Array(C)}static Transpose(Z){const l=new S;return S.TransposeToRef(Z,l),l}static TransposeToRef(Z,l){const C=Z.m,B=C[0],x=C[4],b=C[8],K=C[12],f=C[1],W=C[5],J=C[9],d=C[13],E=C[2],G=C[6],a=C[10],q=C[14],z=C[3],Y=C[7],P=C[11],S=C[15],i=l.Kb;return i[0]=B,i[1]=x,i[2]=b,i[3]=K,i[4]=f,i[5]=W,i[6]=J,i[7]=d,i[8]=E,i[9]=G,i[10]=a,i[11]=q,i[12]=z,i[13]=Y,i[14]=P,i[15]=S,l.markAsUpdated(),l._updateIdentityStatus(Z._isIdentity,Z._isIdentityDirty),l}static Reflection(Z){const l=new S;return S.ReflectionToRef(Z,l),l}static ReflectionToRef(Z,l){Z.normalize();const C=Z.normal.x,B=Z.normal.y,x=Z.normal.z,b=-2*C,K=-2*B,f=-2*x;return S.FromValuesToRef(b*C+1,K*C,f*C,0,b*B,K*B+1,f*B,0,b*x,K*x,f*x+1,0,b*Z.d,K*Z.d,f*Z.d,1,l),l}static FromXYZAxesToRef(Z,l,C,B){return S.FromValuesToRef(Z._x,Z._y,Z._z,0,l._x,l._y,l._z,0,C._x,C._y,C._z,0,0,0,0,1,B),B}static FromQuaternionToRef(Z,l){const C=Z._x*Z._x,B=Z._y*Z._y,x=Z._z*Z._z,b=Z._x*Z._y,K=Z._z*Z._w,f=Z._z*Z._x,W=Z._y*Z._w,J=Z._y*Z._z,d=Z._x*Z._w;return l.Kb[0]=1-2*(B+x),l.Kb[1]=2*(b+K),l.Kb[2]=2*(f-W),l.Kb[3]=0,l.Kb[4]=2*(b-K),l.Kb[5]=1-2*(x+C),l.Kb[6]=2*(J+d),l.Kb[7]=0,l.Kb[8]=2*(f+W),l.Kb[9]=2*(J-d),l.Kb[10]=1-2*(B+C),l.Kb[11]=0,l.Kb[12]=0,l.Kb[13]=0,l.Kb[14]=0,l.Kb[15]=1,l.markAsUpdated(),l}}S._IdentityReadOnly=S.Identity(),Object.defineProperties(S.prototype,{dimension:{value:[4,4]},rank:{value:2}});class i{}i.ql=(0,x.f)(11,z.Zero),i.Matrix=(0,x.f)(2,S.Identity),i.Quaternion=(0,x.f)(3,P.Zero);class s{}s.Vector2=(0,x.f)(3,q.Zero),s.ql=(0,x.f)(13,z.Zero),s.Vector4=(0,x.f)(3,Y.Zero),s.Quaternion=(0,x.f)(3,P.Zero),s.Matrix=(0,x.f)(8,S.Identity),(0,b.c)("BABYLON.Vector2",q),(0,b.c)("BABYLON.Vector3",z),(0,b.c)("BABYLON.Vector4",Y),(0,b.c)("BABYLON.Matrix",S);const F=S.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12456:(Z,l,C)=>{function B(Z,l){const C=[];for(let B=0;B<Z;++B)C.push(l());return C}function x(Z,l){return B(Z,l)}C.d(l,{b:()=>B,f:()=>x,i:()=>K});const b=["push","splice","pop","shift","unshift"];function K(Z,l){const C=b.map((C=>function(Z,l,C){const B=Z[l];if("function"!==typeof B)return null;const x=function(){const B=Z.length,b=x.previous.apply(Z,arguments);return C(l,B),b};return B.next=x,x.previous=B,Z[l]=x,()=>{const C=x.previous;if(!C)return;const B=x.next;B?(C.next=B,B.previous=C):(C.next=void 0,Z[l]=C),x.next=void 0,x.previous=void 0}}(Z,C,l)));return()=>{for(const Z of C)null===Z||void 0===Z||Z()}}}}]);