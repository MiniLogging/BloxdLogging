"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[14],{11248:(k,h,o)=>{o.d(h,{d:()=>Y,f:()=>q,g:()=>x,i:()=>I});const x=1/2.2,I=2.2,q=(1+Math.sqrt(5))/2,Y=.001},11260:(k,h,o)=>{function x(k){return parseInt(k.toString().replace(/\W/g,""))}function I(k,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(k-h)<=o}function q(k,h,o){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return k<h-x||k>o+x}function Y(k,h){return k===h?k:Math.random()*(h-k)+k}function J(k,h,o){return k+(h-k)*o}function G(k,h,o){let x=W(h-k,360);return x>180&&(x-=360),k+x*a(o)}function l(k,h,o){let x=0;return x=k!=h?a((o-k)/(h-k)):0,x}function A(k,h,o,x,I){const q=I*I,Y=I*q;return k*(2*Y-3*q+1)+o*(-2*Y+3*q)+h*(Y-2*q+I)+x*(Y-q)}function K(k,h,o,x,I){const q=I*I;return 6*(q-I)*k+(3*q-4*I+1)*h+6*(-q+I)*o+(3*q-2*I)*x}function a(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(o,Math.max(h,k))}function N(k){return k-=2*Math.PI*Math.floor((k+Math.PI)/(2*Math.PI))}function X(k){const h=k.toString(16);return k<=15?("0"+h).toUpperCase():h.toUpperCase()}function c(k){if(Math.log2)return Math.floor(Math.log2(k));if(k<0)return NaN;if(0===k)return-1/0;let h=0;if(k<1){for(;k<1;)h++,k*=2;h=-h}else if(k>1)for(;k>1;)h++,k=Math.floor(k/2);return h}function W(k,h){return k-Math.floor(k/h)*h}function f(k,h,o){return(k-h)/(o-h)}function M(k,h,o){return k*(o-h)+h}function T(k,h){let o=W(h-k,360);return o>180&&(o-=360),o}function j(k,h){const o=W(k,2*h);return h-Math.abs(o-h)}function d(k,h,o){let x=a(o);return x=-2*x*x*x+3*x*x,h*x+k*(1-x)}function b(k,h,o){let x=0;return x=Math.abs(h-k)<=o?h:k+Math.sign(h-k)*o,x}function V(k,h,o){const x=T(k,h);let I=0;return I=-o<x&&x<o?h:b(k,h=k+x,o),I}function i(k,h,o){return(k-h)/(o-h)}function F(k,h,o){return(o-h)*k+h}function R(k,h){const o=k%h;return 0===o?h:R(h,o)}o.r(h),o.d(h,{Clamp:()=>a,DeltaAngle:()=>T,Denormalize:()=>M,ExtractAsInt:()=>x,Hermite:()=>A,Hermite1stDerivative:()=>K,HighestCommonFactor:()=>R,ILog2:()=>c,InverseLerp:()=>l,Lerp:()=>J,LerpAngle:()=>G,MoveTowards:()=>b,MoveTowardsAngle:()=>V,Normalize:()=>f,NormalizeRadians:()=>N,OutsideRange:()=>q,PercentToRange:()=>F,PingPong:()=>j,RandomRange:()=>Y,RangeToPercent:()=>i,Repeat:()=>W,SmoothStep:()=>d,ToHex:()=>X,WithinEpsilon:()=>I})},11239:(k,h,o)=>{o.r(h),o.d(h,{Matrix:()=>M,Quaternion:()=>f,TmpVectors:()=>j,Vector2:()=>X,Vh:()=>c,Vector4:()=>W});var x=o(11248),I=o(11256),q=o(11199),Y=o(11173),J=o(11120),G=o(11260);class l{}function A(k,h,o){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const I=k.rh(),q=h.rh(),Y=I[0],J=I[1],G=I[2],l=I[3],A=I[4],K=I[5],a=I[6],N=I[7],X=I[8],c=I[9],W=I[10],f=I[11],M=I[12],T=I[13],j=I[14],d=I[15],b=q[0],V=q[1],i=q[2],F=q[3],R=q[4],s=q[5],Z=q[6],w=q[7],D=q[8],U=q[9],Q=q[10],B=q[11],E=q[12],n=q[13],H=q[14],y=q[15];o[x]=Y*b+J*R+G*D+l*E,o[x+1]=Y*V+J*s+G*U+l*n,o[x+2]=Y*i+J*Z+G*Q+l*H,o[x+3]=Y*F+J*w+G*B+l*y,o[x+4]=A*b+K*R+a*D+N*E,o[x+5]=A*V+K*s+a*U+N*n,o[x+6]=A*i+K*Z+a*Q+N*H,o[x+7]=A*F+K*w+a*B+N*y,o[x+8]=X*b+c*R+W*D+f*E,o[x+9]=X*V+c*s+W*U+f*n,o[x+10]=X*i+c*Z+W*Q+f*H,o[x+11]=X*F+c*w+W*B+f*y,o[x+12]=M*b+T*R+j*D+d*E,o[x+13]=M*V+T*s+j*U+d*n,o[x+14]=M*i+T*Z+j*Q+d*H,o[x+15]=M*F+T*w+j*B+d*y}function K(k,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const x=k.rh();h[o]=x[0],h[o+1]=x[1],h[o+2]=x[2],h[o+3]=x[3],h[o+4]=x[4],h[o+5]=x[5],h[o+6]=x[6],h[o+7]=x[7],h[o+8]=x[8],h[o+9]=x[9],h[o+10]=x[10],h[o+11]=x[11],h[o+12]=x[12],h[o+13]=x[13],h[o+14]=x[14],h[o+15]=x[15]}function a(k,h){const o=k.rh(),x=o[0],I=o[1],q=o[2],Y=o[3],J=o[4],G=o[5],l=o[6],A=o[7],K=o[8],a=o[9],N=o[10],X=o[11],c=o[12],W=o[13],f=o[14],M=o[15],T=N*M-f*X,j=a*M-W*X,d=a*f-W*N,b=K*M-c*X,V=K*f-N*c,i=K*W-c*a,F=+(G*T-l*j+A*d),R=-(J*T-l*b+A*V),s=+(J*j-G*b+A*i),Z=-(J*d-G*V+l*i),w=x*F+I*R+q*s+Y*Z;if(0===w)return!1;const D=1/w,U=l*M-f*A,Q=G*M-W*A,B=G*f-W*l,E=J*M-c*A,n=J*f-c*l,H=J*W-c*G,y=l*X-N*A,O=G*X-a*A,z=G*N-a*l,p=J*X-K*A,v=J*N-K*l,m=J*a-K*G,L=-(I*T-q*j+Y*d),P=+(x*T-q*b+Y*V),r=-(x*j-I*b+Y*i),t=+(x*d-I*V+q*i),S=+(I*U-q*Q+Y*B),C=-(x*U-q*E+Y*n),g=+(x*Q-I*E+Y*H),e=-(x*B-I*n+q*H),u=-(I*y-q*O+Y*z),kk=+(x*y-q*p+Y*v),hk=-(x*O-I*p+Y*m),ok=+(x*z-I*v+q*m);return h[0]=F*D,h[1]=L*D,h[2]=S*D,h[3]=u*D,h[4]=R*D,h[5]=P*D,h[6]=C*D,h[7]=kk*D,h[8]=s*D,h[9]=r*D,h[10]=g*D,h[11]=hk*D,h[12]=Z*D,h[13]=t*D,h[14]=e*D,h[15]=ok*D,!0}l._UpdateFlagSeed=0;const N=k=>parseInt(k.toString().replace(/\W/g,""));class X{constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=k,this.y=h}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let k=N(this.x);return k=397*k^N(this.y),k}toArray(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k[h]=this.x,k[h+1]=this.y,this}Qo(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return X.FromArrayToRef(k,h,this),this}rh(){return[this.x,this.y]}Y(k){return this.x=k.x,this.y=k.y,this}VJ(k,h){return this.x=k,this.y=h,this}set(k,h){return this.VJ(k,h)}FJ(k){return this.VJ(k,k)}add(k){return new X(this.x+k.x,this.y+k.y)}addToRef(k,h){return h.x=this.x+k.x,h.y=this.y+k.y,h}addInPlace(k){return this.x+=k.x,this.y+=k.y,this}addInPlaceFromFloats(k,h){return this.x+=k,this.y+=h,this}addVector3(k){return new X(this.x+k.x,this.y+k.y)}ih(k){return new X(this.x-k.x,this.y-k.y)}subtractToRef(k,h){return h.x=this.x-k.x,h.y=this.y-k.y,h}xK(k){return this.x-=k.x,this.y-=k.y,this}multiplyInPlace(k){return this.x*=k.x,this.y*=k.y,this}multiply(k){return new X(this.x*k.x,this.y*k.y)}multiplyToRef(k,h){return h.x=this.x*k.x,h.y=this.y*k.y,h}multiplyByFloats(k,h){return new X(this.x*k,this.y*h)}divide(k){return new X(this.x/k.x,this.y/k.y)}divideToRef(k,h){return h.x=this.x/k.x,h.y=this.y/k.y,h}divideInPlace(k){return this.x=this.x/k.x,this.y=this.y/k.y,this}minimizeInPlace(k){return this.minimizeInPlaceFromFloats(k.x,k.y)}maximizeInPlace(k){return this.maximizeInPlaceFromFloats(k.x,k.y)}minimizeInPlaceFromFloats(k,h){return this.x=Math.min(k,this.x),this.y=Math.min(h,this.y),this}maximizeInPlaceFromFloats(k,h){return this.x=Math.max(k,this.x),this.y=Math.max(h,this.y),this}subtractFromFloats(k,h){return new X(this.x-k,this.y-h)}subtractFromFloatsToRef(k,h,o){return o.x=this.x-k,o.y=this.y-h,o}negate(){return new X(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(k){return k.x=-this.x,k.y=-this.y,k}scaleInPlace(k){return this.x*=k,this.y*=k,this}scale(k){return new X(this.x*k,this.y*k)}scaleToRef(k,h){return h.x=this.x*k,h.y=this.y*k,h}scaleAndAddToRef(k,h){return h.x+=this.x*k,h.y+=this.y*k,h}equals(k){return k&&this.x===k.x&&this.y===k.y}equalsWithEpsilon(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:x.d;return k&&(0,G.WithinEpsilon)(this.x,k.x,h)&&(0,G.WithinEpsilon)(this.y,k.y,h)}equalsToFloats(k,h){return this.x===k&&this.y===h}floor(){return new X(Math.floor(this.x),Math.floor(this.y))}floorToRef(k){return k.x=Math.floor(this.x),k.y=Math.floor(this.y),k}fract(){return new X(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(k){return k.x=this.x-Math.floor(this.x),k.y=this.y-Math.floor(this.y),k}rotate(k){return this.rotateToRef(k,new X)}rotateToRef(k,h){const o=Math.cos(k),x=Math.sin(k);return h.x=o*this.x-x*this.y,h.y=x*this.x+o*this.y,h}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(k){return 0===k||1===k?this:this.scaleInPlace(1/k)}normalizeToNew(){const k=new X;return this.normalizeToRef(k),k}normalizeToRef(k){const h=this.length();return 0===h&&(k.x=this.x,k.y=this.y),this.scaleToRef(1/h,k)}clone(){return new X(this.x,this.y)}dot(k){return this.x*k.x+this.y*k.y}static Zero(){return new X(0,0)}static One(){return new X(1,1)}static Random(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new X((0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h))}static RandomToRef(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).VJ((0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h))}static get ZeroReadOnly(){return X._ZeroReadOnly}static Uh(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new X(k[h],k[h+1])}static FromArrayToRef(k,h,o){return o.x=k[h],o.y=k[h+1],o}static FromFloatsToRef(k,h,o){return o.VJ(k,h),o}static CatmullRom(k,h,o,x,I){const q=I*I,Y=I*q,J=.5*(2*h.x+(-k.x+o.x)*I+(2*k.x-5*h.x+4*o.x-x.x)*q+(-k.x+3*h.x-3*o.x+x.x)*Y),G=.5*(2*h.y+(-k.y+o.y)*I+(2*k.y-5*h.y+4*o.y-x.y)*q+(-k.y+3*h.y-3*o.y+x.y)*Y);return new X(J,G)}static ClampToRef(k,h,o,x){return x.x=(0,G.Clamp)(k.x,h.x,o.x),x.y=(0,G.Clamp)(k.y,h.y,o.y),x}static Clamp(k,h,o){const x=(0,G.Clamp)(k.x,h.x,o.x),I=(0,G.Clamp)(k.y,h.y,o.y);return new X(x,I)}static Hermite(k,h,o,x,I){const q=I*I,Y=I*q,J=2*Y-3*q+1,G=-2*Y+3*q,l=Y-2*q+I,A=Y-q,K=k.x*J+o.x*G+h.x*l+x.x*A,a=k.y*J+o.y*G+h.y*l+x.y*A;return new X(K,a)}static Hermite1stDerivative(k,h,o,x,I){return this.Hermite1stDerivativeToRef(k,h,o,x,I,new X)}static Hermite1stDerivativeToRef(k,h,o,x,I,q){const Y=I*I;return q.x=6*(Y-I)*k.x+(3*Y-4*I+1)*h.x+6*(-Y+I)*o.x+(3*Y-2*I)*x.x,q.y=6*(Y-I)*k.y+(3*Y-4*I+1)*h.y+6*(-Y+I)*o.y+(3*Y-2*I)*x.y,q}static Lerp(k,h,o){return X.LerpToRef(k,h,o,new X)}static LerpToRef(k,h,o,x){return x.x=k.x+(h.x-k.x)*o,x.y=k.y+(h.y-k.y)*o,x}static Dot(k,h){return k.x*h.x+k.y*h.y}static Normalize(k){return X.NormalizeToRef(k,new X)}static NormalizeToRef(k,h){return k.normalizeToRef(h),h}static Minimize(k,h){const o=k.x<h.x?k.x:h.x,x=k.y<h.y?k.y:h.y;return new X(o,x)}static Maximize(k,h){const o=k.x>h.x?k.x:h.x,x=k.y>h.y?k.y:h.y;return new X(o,x)}static Transform(k,h){return X.TransformToRef(k,h,new X)}static TransformToRef(k,h,o){const x=h.m,I=k.x*x[0]+k.y*x[4]+x[12],q=k.x*x[1]+k.y*x[5]+x[13];return o.x=I,o.y=q,o}static PointInTriangle(k,h,o,x){const I=.5*(-o.y*x.x+h.y*(-o.x+x.x)+h.x*(o.y-x.y)+o.x*x.y),q=I<0?-1:1,Y=(h.y*x.x-h.x*x.y+(x.y-h.y)*k.x+(h.x-x.x)*k.y)*q,J=(h.x*o.y-h.y*o.x+(h.y-o.y)*k.x+(o.x-h.x)*k.y)*q;return Y>0&&J>0&&Y+J<2*I*q}static Distance(k,h){return Math.sqrt(X.DistanceSquared(k,h))}static DistanceSquared(k,h){const o=k.x-h.x,x=k.y-h.y;return o*o+x*x}static Center(k,h){return X.CenterToRef(k,h,new X)}static CenterToRef(k,h,o){return o.VJ((k.x+h.x)/2,(k.y+h.y)/2)}static DistanceOfPointFromSegment(k,h,o){const x=X.DistanceSquared(h,o);if(0===x)return X.Distance(k,h);const I=o.ih(h),q=Math.max(0,Math.min(1,X.Dot(k.ih(h),I)/x)),Y=h.add(I.multiplyByFloats(q,q));return X.Distance(k,Y)}}X._V8PerformanceHack=new X(.5,.5),X._ZeroReadOnly=X.Zero(),Object.defineProperties(X.prototype,{dimension:{value:[2]},rank:{value:1}});class c{get x(){return this._x}set x(k){this._x=k,this._isDirty=!0}get y(){return this._y}set y(k){this._y=k,this._isDirty=!0}get z(){return this._z}set z(k){this._z=k,this._isDirty=!0}constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=k,this._y=h,this._z=o}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vh"}getHashCode(){let k=N(this._x);return k=397*k^N(this._y),k=397*k^N(this._z),k}rh(){return[this._x,this._y,this._z]}toArray(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k[h]=this._x,k[h+1]=this._y,k[h+2]=this._z,this}Qo(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c.FromArrayToRef(k,h,this),this}toQuaternion(){return f.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(k){return this._x+=k._x,this._y+=k._y,this._z+=k._z,this._isDirty=!0,this}addInPlaceFromFloats(k,h,o){return this._x+=k,this._y+=h,this._z+=o,this._isDirty=!0,this}add(k){return new c(this._x+k._x,this._y+k._y,this._z+k._z)}addToRef(k,h){return h._x=this._x+k._x,h._y=this._y+k._y,h._z=this._z+k._z,h._isDirty=!0,h}xK(k){return this._x-=k._x,this._y-=k._y,this._z-=k._z,this._isDirty=!0,this}ih(k){return new c(this._x-k._x,this._y-k._y,this._z-k._z)}subtractToRef(k,h){return this.subtractFromFloatsToRef(k._x,k._y,k._z,h)}subtractFromFloats(k,h,o){return new c(this._x-k,this._y-h,this._z-o)}subtractFromFloatsToRef(k,h,o,x){return x._x=this._x-k,x._y=this._y-h,x._z=this._z-o,x._isDirty=!0,x}negate(){return new c(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(k){return k._x=-1*this._x,k._y=-1*this._y,k._z=-1*this._z,k._isDirty=!0,k}scaleInPlace(k){return this._x*=k,this._y*=k,this._z*=k,this._isDirty=!0,this}scale(k){return new c(this._x*k,this._y*k,this._z*k)}scaleToRef(k,h){return h._x=this._x*k,h._y=this._y*k,h._z=this._z*k,h._isDirty=!0,h}getNormalToRef(k){const h=this.length();let o=Math.acos(this._y/h);const x=Math.atan2(this._z,this._x);o>Math.PI/2?o-=Math.PI/2:o+=Math.PI/2;const I=h*Math.sin(o)*Math.cos(x),q=h*Math.cos(o),Y=h*Math.sin(o)*Math.sin(x);return k.set(I,q,Y),k}applyRotationQuaternionToRef(k,h){const o=this._x,x=this._y,I=this._z,q=k._x,Y=k._y,J=k._z,G=k._w,l=2*(Y*I-J*x),A=2*(J*o-q*I),K=2*(q*x-Y*o);return h._x=o+G*l+Y*K-J*A,h._y=x+G*A+J*l-q*K,h._z=I+G*K+q*A-Y*l,h._isDirty=!0,h}applyRotationQuaternionInPlace(k){return this.applyRotationQuaternionToRef(k,this)}applyRotationQuaternion(k){return this.applyRotationQuaternionToRef(k,new c)}scaleAndAddToRef(k,h){return h._x+=this._x*k,h._y+=this._y*k,h._z+=this._z*k,h._isDirty=!0,h}projectOnPlane(k,h){return this.projectOnPlaneToRef(k,h,new c)}projectOnPlaneToRef(k,h,o){const x=k.normal,I=k.d,q=T.Vh[0];this.subtractToRef(h,q),q.normalize();const Y=c.Dot(q,x);if(Math.abs(Y)<1e-10)o.FJ(1/0);else{const k=-(c.Dot(h,x)+I)/Y,J=q.scaleInPlace(k);h.addToRef(J,o)}return o}equals(k){return k&&this._x===k._x&&this._y===k._y&&this._z===k._z}equalsWithEpsilon(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:x.d;return k&&(0,G.WithinEpsilon)(this._x,k._x,h)&&(0,G.WithinEpsilon)(this._y,k._y,h)&&(0,G.WithinEpsilon)(this._z,k._z,h)}equalsToFloats(k,h,o){return this._x===k&&this._y===h&&this._z===o}multiplyInPlace(k){return this._x*=k._x,this._y*=k._y,this._z*=k._z,this._isDirty=!0,this}multiply(k){return this.multiplyByFloats(k._x,k._y,k._z)}multiplyToRef(k,h){return h._x=this._x*k._x,h._y=this._y*k._y,h._z=this._z*k._z,h._isDirty=!0,h}multiplyByFloats(k,h,o){return new c(this._x*k,this._y*h,this._z*o)}divide(k){return new c(this._x/k._x,this._y/k._y,this._z/k._z)}divideToRef(k,h){return h._x=this._x/k._x,h._y=this._y/k._y,h._z=this._z/k._z,h._isDirty=!0,h}divideInPlace(k){return this._x=this._x/k._x,this._y=this._y/k._y,this._z=this._z/k._z,this._isDirty=!0,this}minimizeInPlace(k){return this.minimizeInPlaceFromFloats(k._x,k._y,k._z)}maximizeInPlace(k){return this.maximizeInPlaceFromFloats(k._x,k._y,k._z)}minimizeInPlaceFromFloats(k,h,o){return k<this._x&&(this.x=k),h<this._y&&(this.y=h),o<this._z&&(this.z=o),this}maximizeInPlaceFromFloats(k,h,o){return k>this._x&&(this.x=k),h>this._y&&(this.y=h),o>this._z&&(this.z=o),this}isNonUniformWithinEpsilon(k){const h=Math.abs(this._x),o=Math.abs(this._y);if(!(0,G.WithinEpsilon)(h,o,k))return!0;const x=Math.abs(this._z);return!(0,G.WithinEpsilon)(h,x,k)||!(0,G.WithinEpsilon)(o,x,k)}get isNonUniform(){const k=Math.abs(this._x);if(k!==Math.abs(this._y))return!0;return k!==Math.abs(this._z)}floorToRef(k){return k._x=Math.floor(this._x),k._y=Math.floor(this._y),k._z=Math.floor(this._z),k._isDirty=!0,k}floor(){return new c(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(k){return k._x=this._x-Math.floor(this._x),k._y=this._y-Math.floor(this._y),k._z=this._z-Math.floor(this._z),k._isDirty=!0,k}fract(){return new c(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(k){if("xyz"===(k=k.toLowerCase()))return this;const h=T.Vh[0].Y(this);return this.x=h[k[0]],this.y=h[k[1]],this.z=h[k[2]],this}rotateByQuaternionToRef(k,h){return k.toRotationMatrix(T.Matrix[0]),c.TransformCoordinatesToRef(this,T.Matrix[0],h),h}rotateByQuaternionAroundPointToRef(k,h,o){return this.subtractToRef(h,T.Vh[0]),T.Vh[0].rotateByQuaternionToRef(k,T.Vh[0]),h.addToRef(T.Vh[0],o),o}cross(k){return c.CrossToRef(this,k,new c)}normalizeFromLength(k){return 0===k||1===k?this:this.scaleInPlace(1/k)}normalizeToNew(){return this.normalizeToRef(new c)}normalizeToRef(k){const h=this.length();return 0===h||1===h?(k._x=this._x,k._y=this._y,k._z=this._z,k._isDirty=!0,k):this.scaleToRef(1/h,k)}clone(){return new c(this._x,this._y,this._z)}Y(k){return this.VJ(k._x,k._y,k._z)}VJ(k,h,o){return this._x=k,this._y=h,this._z=o,this._isDirty=!0,this}set(k,h,o){return this.VJ(k,h,o)}FJ(k){return this._x=this._y=this._z=k,this._isDirty=!0,this}static GetClipFactor(k,h,o,x){const I=c.Dot(k,o);return(I-x)/(I-c.Dot(h,o))}static GetAngleBetweenVectors(k,h,o){const x=k.normalizeToRef(T.Vh[1]),I=h.normalizeToRef(T.Vh[2]);let q=c.Dot(x,I);q=(0,G.Clamp)(q,-1,1);const Y=Math.acos(q),J=T.Vh[3];return c.CrossToRef(x,I,J),c.Dot(J,o)>0?isNaN(Y)?0:Y:isNaN(Y)?-Math.PI:-Math.acos(q)}static GetAngleBetweenVectorsOnPlane(k,h,o){T.Vh[0].Y(k);const x=T.Vh[0];T.Vh[1].Y(h);const I=T.Vh[1];T.Vh[2].Y(o);const q=T.Vh[2],Y=T.Vh[3],J=T.Vh[4];x.normalize(),I.normalize(),q.normalize(),c.CrossToRef(q,x,Y),c.CrossToRef(Y,q,J);const l=Math.atan2(c.Dot(I,Y),c.Dot(I,J));return(0,G.NormalizeRadians)(l)}static PitchYawRollToMoveBetweenPointsToRef(k,h,o){const x=j.Vh[0];return h.subtractToRef(k,x),o._y=Math.atan2(x.x,x.z)||0,o._x=Math.atan2(Math.sqrt(x.x**2+x.z**2),x.y)||0,o._z=0,o._isDirty=!0,o}static PitchYawRollToMoveBetweenPoints(k,h){const o=c.Zero();return c.PitchYawRollToMoveBetweenPointsToRef(k,h,o)}static SlerpToRef(k,h,o,I){o=(0,G.Clamp)(o,0,1);const q=T.Vh[0],Y=T.Vh[1];q.Y(k);const J=q.length();q.normalizeFromLength(J),Y.Y(h);const l=Y.length();Y.normalizeFromLength(l);const A=c.Dot(q,Y);let K,a;if(A<1-x.d){const k=Math.acos(A),h=1/Math.sin(k);K=Math.sin((1-o)*k)*h,a=Math.sin(o*k)*h}else K=1-o,a=o;return q.scaleInPlace(K),Y.scaleInPlace(a),I.Y(q).addInPlace(Y),I.scaleInPlace((0,G.Lerp)(J,l,o)),I}static SmoothToRef(k,h,o,x,I){return c.SlerpToRef(k,h,0===x?1:o/x,I),I}static Uh(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new c(k[h],k[h+1],k[h+2])}static FromFloatArray(k,h){return c.Uh(k,h)}static FromArrayToRef(k,h,o){return o._x=k[h],o._y=k[h+1],o._z=k[h+2],o._isDirty=!0,o}static FromFloatArrayToRef(k,h,o){return c.FromArrayToRef(k,h,o)}static FromFloatsToRef(k,h,o,x){return x.VJ(k,h,o),x}static Zero(){return new c(0,0,0)}static One(){return new c(1,1,1)}static Up(){return new c(0,1,0)}static get UpReadOnly(){return c._UpReadOnly}static get DownReadOnly(){return c._DownReadOnly}static get RightReadOnly(){return c._RightReadOnly}static get LeftReadOnly(){return c._LeftReadOnly}static get LeftHandedForwardReadOnly(){return c._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return c._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return c._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return c._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return c._ZeroReadOnly}static get OneReadOnly(){return c._OneReadOnly}static Down(){return new c(0,-1,0)}static Forward(){return new c(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new c(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new c(1,0,0)}static Left(){return new c(-1,0,0)}static Random(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new c((0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h))}static RandomToRef(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).VJ((0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h))}static TransformCoordinates(k,h){const o=c.Zero();return c.TransformCoordinatesToRef(k,h,o),o}static TransformCoordinatesToRef(k,h,o){return c.TransformCoordinatesFromFloatsToRef(k._x,k._y,k._z,h,o),o}static TransformCoordinatesFromFloatsToRef(k,h,o,x,I){const q=x.m,Y=k*q[0]+h*q[4]+o*q[8]+q[12],J=k*q[1]+h*q[5]+o*q[9]+q[13],G=k*q[2]+h*q[6]+o*q[10]+q[14],l=1/(k*q[3]+h*q[7]+o*q[11]+q[15]);return I._x=Y*l,I._y=J*l,I._z=G*l,I._isDirty=!0,I}static TransformNormal(k,h){const o=c.Zero();return c.TransformNormalToRef(k,h,o),o}static TransformNormalToRef(k,h,o){return this.TransformNormalFromFloatsToRef(k._x,k._y,k._z,h,o),o}static TransformNormalFromFloatsToRef(k,h,o,x,I){const q=x.m;return I._x=k*q[0]+h*q[4]+o*q[8],I._y=k*q[1]+h*q[5]+o*q[9],I._z=k*q[2]+h*q[6]+o*q[10],I._isDirty=!0,I}static CatmullRom(k,h,o,x,I){const q=I*I,Y=I*q,J=.5*(2*h._x+(-k._x+o._x)*I+(2*k._x-5*h._x+4*o._x-x._x)*q+(-k._x+3*h._x-3*o._x+x._x)*Y),G=.5*(2*h._y+(-k._y+o._y)*I+(2*k._y-5*h._y+4*o._y-x._y)*q+(-k._y+3*h._y-3*o._y+x._y)*Y),l=.5*(2*h._z+(-k._z+o._z)*I+(2*k._z-5*h._z+4*o._z-x._z)*q+(-k._z+3*h._z-3*o._z+x._z)*Y);return new c(J,G,l)}static Clamp(k,h,o){const x=new c;return c.ClampToRef(k,h,o,x),x}static ClampToRef(k,h,o,x){let I=k._x;I=I>o._x?o._x:I,I=I<h._x?h._x:I;let q=k._y;q=q>o._y?o._y:q,q=q<h._y?h._y:q;let Y=k._z;return Y=Y>o._z?o._z:Y,Y=Y<h._z?h._z:Y,x.VJ(I,q,Y),x}static CheckExtends(k,h,o){h.minimizeInPlace(k),o.maximizeInPlace(k)}static Hermite(k,h,o,x,I){const q=I*I,Y=I*q,J=2*Y-3*q+1,G=-2*Y+3*q,l=Y-2*q+I,A=Y-q,K=k._x*J+o._x*G+h._x*l+x._x*A,a=k._y*J+o._y*G+h._y*l+x._y*A,N=k._z*J+o._z*G+h._z*l+x._z*A;return new c(K,a,N)}static Hermite1stDerivative(k,h,o,x,I){const q=new c;return this.Hermite1stDerivativeToRef(k,h,o,x,I,q),q}static Hermite1stDerivativeToRef(k,h,o,x,I,q){const Y=I*I;return q._x=6*(Y-I)*k._x+(3*Y-4*I+1)*h._x+6*(-Y+I)*o._x+(3*Y-2*I)*x._x,q._y=6*(Y-I)*k._y+(3*Y-4*I+1)*h._y+6*(-Y+I)*o._y+(3*Y-2*I)*x._y,q._z=6*(Y-I)*k._z+(3*Y-4*I+1)*h._z+6*(-Y+I)*o._z+(3*Y-2*I)*x._z,q._isDirty=!0,q}static Lerp(k,h,o){const x=new c(0,0,0);return c.LerpToRef(k,h,o,x),x}static LerpToRef(k,h,o,x){return x._x=k._x+(h._x-k._x)*o,x._y=k._y+(h._y-k._y)*o,x._z=k._z+(h._z-k._z)*o,x._isDirty=!0,x}static Dot(k,h){return k._x*h._x+k._y*h._y+k._z*h._z}dot(k){return this._x*k._x+this._y*k._y+this._z*k._z}static Cross(k,h){const o=new c;return c.CrossToRef(k,h,o),o}static CrossToRef(k,h,o){const x=k._y*h._z-k._z*h._y,I=k._z*h._x-k._x*h._z,q=k._x*h._y-k._y*h._x;return o.VJ(x,I,q),o}static Normalize(k){const h=c.Zero();return c.NormalizeToRef(k,h),h}static NormalizeToRef(k,h){return k.normalizeToRef(h),h}static Project(k,h,o,x){const I=new c;return c.ProjectToRef(k,h,o,x,I),I}static ProjectToRef(k,h,o,x,I){var q;const Y=x.width,G=x.height,l=x.x,A=x.y,K=T.Matrix[1],a=null===(q=J.b.LastCreatedEngine)||void 0===q?void 0:q.isNDCHalfZRange,N=a?1:.5,X=a?0:.5;M.FromValuesToRef(Y/2,0,0,0,0,-G/2,0,0,0,0,N,0,l+Y/2,G/2+A,X,1,K);const W=T.Matrix[0];return h.multiplyToRef(o,W),W.multiplyToRef(K,W),c.TransformCoordinatesToRef(k,W,I),I}static Reflect(k,h){return this.ReflectToRef(k,h,new c)}static ReflectToRef(k,h,o){const x=j.Vh[0];return x.Y(h).scaleInPlace(2*c.Dot(k,h)),o.Y(k).xK(x)}static _UnprojectFromInvertedMatrixToRef(k,h,o){c.TransformCoordinatesToRef(k,h,o);const x=h.m,I=k._x*x[3]+k._y*x[7]+k._z*x[11]+x[15];return(0,G.WithinEpsilon)(I,1)&&o.scaleInPlace(1/I),o}static UnprojectFromTransform(k,h,o,x,I){return this.Unproject(k,h,o,x,I,M.IdentityReadOnly)}static Unproject(k,h,o,x,I,q){const Y=new c;return c.UnprojectToRef(k,h,o,x,I,q,Y),Y}static UnprojectToRef(k,h,o,x,I,q,Y){return c.UnprojectFloatsToRef(k._x,k._y,k._z,h,o,x,I,q,Y),Y}static UnprojectFloatsToRef(k,h,o,x,I,q,Y,G,l){var A;const K=T.Matrix[0];q.multiplyToRef(Y,K),K.multiplyToRef(G,K),K.invert();const a=T.Vh[0];return a.x=k/x*2-1,a.y=-(h/I*2-1),null!==(A=J.b.LastCreatedEngine)&&void 0!==A&&A.isNDCHalfZRange?a.z=o:a.z=2*o-1,c._UnprojectFromInvertedMatrixToRef(a,K,l),l}static Minimize(k,h){const o=new c;return o.Y(k),o.minimizeInPlace(h),o}static Maximize(k,h){const o=new c;return o.Y(k),o.maximizeInPlace(h),o}static Distance(k,h){return Math.sqrt(c.DistanceSquared(k,h))}static DistanceSquared(k,h){const o=k._x-h._x,x=k._y-h._y,I=k._z-h._z;return o*o+x*x+I*I}static ProjectOnTriangleToRef(k,h,o,I,q){const Y=T.Vh[0],J=T.Vh[1],l=T.Vh[2],A=T.Vh[3],K=T.Vh[4];o.subtractToRef(h,Y),I.subtractToRef(h,J),I.subtractToRef(o,l);const a=Y.length(),N=J.length(),X=l.length();if(a<x.d||N<x.d||X<x.d)return q.Y(h),c.Distance(k,h);k.subtractToRef(h,K),c.CrossToRef(Y,J,A);const W=A.length();if(W<x.d)return q.Y(h),c.Distance(k,h);A.normalizeFromLength(W);let f=K.length();if(f<x.d)return q.Y(h),0;K.normalizeFromLength(f);const M=c.Dot(A,K),j=T.Vh[5],d=T.Vh[6];j.Y(A).scaleInPlace(-f*M),d.Y(k).addInPlace(j);const b=T.Vh[4],V=T.Vh[5],i=T.Vh[7],F=T.Vh[8];b.Y(Y).scaleInPlace(1/a),F.Y(J).scaleInPlace(1/N),b.addInPlace(F).scaleInPlace(-1),V.Y(Y).scaleInPlace(-1/a),F.Y(l).scaleInPlace(1/X),V.addInPlace(F).scaleInPlace(-1),i.Y(l).scaleInPlace(-1/X),F.Y(J).scaleInPlace(-1/N),i.addInPlace(F).scaleInPlace(-1);const R=T.Vh[9];let s;R.Y(d).xK(h),c.CrossToRef(b,R,F),s=c.Dot(F,A);const Z=s;R.Y(d).xK(o),c.CrossToRef(V,R,F),s=c.Dot(F,A);const w=s;R.Y(d).xK(I),c.CrossToRef(i,R,F),s=c.Dot(F,A);const D=s,U=T.Vh[10];let Q,B;Z>0&&w<0?(U.Y(Y),Q=h,B=o):w>0&&D<0?(U.Y(l),Q=o,B=I):(U.Y(J).scaleInPlace(-1),Q=I,B=h);const E=T.Vh[9],n=T.Vh[4];Q.subtractToRef(d,F),B.subtractToRef(d,E),c.CrossToRef(F,E,n);if(!(c.Dot(n,A)<0))return q.Y(d),Math.abs(f*M);const H=T.Vh[5];c.CrossToRef(U,n,H),H.normalize();const y=T.Vh[9];y.Y(Q).xK(d);const O=y.length();if(O<x.d)return q.Y(Q),c.Distance(k,Q);y.normalizeFromLength(O);const z=c.Dot(H,y),p=T.Vh[7];p.Y(d).addInPlace(H.scaleInPlace(O*z)),F.Y(p).xK(Q),f=U.length(),U.normalizeFromLength(f);let v=c.Dot(F,U)/Math.max(f,x.d);return v=(0,G.Clamp)(v,0,1),p.Y(Q).addInPlace(U.scaleInPlace(v*f)),q.Y(p),c.Distance(k,p)}static Center(k,h){return c.CenterToRef(k,h,c.Zero())}static CenterToRef(k,h,o){return o.VJ((k._x+h._x)/2,(k._y+h._y)/2,(k._z+h._z)/2)}static RotationFromAxis(k,h,o){const x=new c;return c.RotationFromAxisToRef(k,h,o,x),x}static RotationFromAxisToRef(k,h,o,x){const I=T.Quaternion[0];return f.RotationQuaternionFromAxisToRef(k,h,o,I),I.toEulerAnglesToRef(x),x}}c._V8PerformanceHack=new c(.5,.5,.5),c._UpReadOnly=c.Up(),c._DownReadOnly=c.Down(),c._LeftHandedForwardReadOnly=c.Forward(!1),c._RightHandedForwardReadOnly=c.Forward(!0),c._LeftHandedBackwardReadOnly=c.Backward(!1),c._RightHandedBackwardReadOnly=c.Backward(!0),c._RightReadOnly=c.Right(),c._LeftReadOnly=c.Left(),c._ZeroReadOnly=c.Zero(),c._OneReadOnly=c.One(),Object.defineProperties(c.prototype,{dimension:{value:[3]},rank:{value:1}});class W{get x(){return this._x}set x(k){this._x=k,this._isDirty=!0}get y(){return this._y}set y(k){this._y=k,this._isDirty=!0}get z(){return this._z}set z(k){this._z=k,this._isDirty=!0}get w(){return this._w}set w(k){this._w=k,this._isDirty=!0}constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=k,this._y=h,this._z=o,this._w=x}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let k=N(this._x);return k=397*k^N(this._y),k=397*k^N(this._z),k=397*k^N(this._w),k}rh(){return[this._x,this._y,this._z,this._w]}toArray(k,h){return void 0===h&&(h=0),k[h]=this._x,k[h+1]=this._y,k[h+2]=this._z,k[h+3]=this._w,this}Qo(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return W.FromArrayToRef(k,h,this),this}addInPlace(k){return this.x+=k._x,this.y+=k._y,this.z+=k._z,this.w+=k._w,this}addInPlaceFromFloats(k,h,o,x){return this.x+=k,this.y+=h,this.z+=o,this.w+=x,this}add(k){return new W(this._x+k.x,this._y+k.y,this._z+k.z,this._w+k.w)}addToRef(k,h){return h.x=this._x+k.x,h.y=this._y+k.y,h.z=this._z+k.z,h.w=this._w+k.w,h}xK(k){return this.x-=k.x,this.y-=k.y,this.z-=k.z,this.w-=k.w,this}ih(k){return new W(this._x-k.x,this._y-k.y,this._z-k.z,this._w-k.w)}subtractToRef(k,h){return h.x=this._x-k.x,h.y=this._y-k.y,h.z=this._z-k.z,h.w=this._w-k.w,h}subtractFromFloats(k,h,o,x){return new W(this._x-k,this._y-h,this._z-o,this._w-x)}subtractFromFloatsToRef(k,h,o,x,I){return I.x=this._x-k,I.y=this._y-h,I.z=this._z-o,I.w=this._w-x,I}negate(){return new W(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(k){return k.x=-this._x,k.y=-this._y,k.z=-this._z,k.w=-this._w,k}scaleInPlace(k){return this.x*=k,this.y*=k,this.z*=k,this.w*=k,this}scale(k){return new W(this._x*k,this._y*k,this._z*k,this._w*k)}scaleToRef(k,h){return h.x=this._x*k,h.y=this._y*k,h.z=this._z*k,h.w=this._w*k,h}scaleAndAddToRef(k,h){return h.x+=this._x*k,h.y+=this._y*k,h.z+=this._z*k,h.w+=this._w*k,h}equals(k){return k&&this._x===k.x&&this._y===k.y&&this._z===k.z&&this._w===k.w}equalsWithEpsilon(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:x.d;return k&&(0,G.WithinEpsilon)(this._x,k.x,h)&&(0,G.WithinEpsilon)(this._y,k.y,h)&&(0,G.WithinEpsilon)(this._z,k.z,h)&&(0,G.WithinEpsilon)(this._w,k.w,h)}equalsToFloats(k,h,o,x){return this._x===k&&this._y===h&&this._z===o&&this._w===x}multiplyInPlace(k){return this.x*=k.x,this.y*=k.y,this.z*=k.z,this.w*=k.w,this}multiply(k){return new W(this._x*k.x,this._y*k.y,this._z*k.z,this._w*k.w)}multiplyToRef(k,h){return h.x=this._x*k.x,h.y=this._y*k.y,h.z=this._z*k.z,h.w=this._w*k.w,h}multiplyByFloats(k,h,o,x){return new W(this._x*k,this._y*h,this._z*o,this._w*x)}divide(k){return new W(this._x/k.x,this._y/k.y,this._z/k.z,this._w/k.w)}divideToRef(k,h){return h.x=this._x/k.x,h.y=this._y/k.y,h.z=this._z/k.z,h.w=this._w/k.w,h}divideInPlace(k){return this.divideToRef(k,this)}minimizeInPlace(k){return k.x<this._x&&(this.x=k.x),k.y<this._y&&(this.y=k.y),k.z<this._z&&(this.z=k.z),k.w<this._w&&(this.w=k.w),this}maximizeInPlace(k){return k.x>this._x&&(this.x=k.x),k.y>this._y&&(this.y=k.y),k.z>this._z&&(this.z=k.z),k.w>this._w&&(this.w=k.w),this}minimizeInPlaceFromFloats(k,h,o,x){return this.x=Math.min(k,this._x),this.y=Math.min(h,this._y),this.z=Math.min(o,this._z),this.w=Math.min(x,this._w),this}maximizeInPlaceFromFloats(k,h,o,x){return this.x=Math.max(k,this._x),this.y=Math.max(h,this._y),this.z=Math.max(o,this._z),this.w=Math.max(x,this._w),this}floorToRef(k){return k.x=Math.floor(this._x),k.y=Math.floor(this._y),k.z=Math.floor(this._z),k.w=Math.floor(this._w),k}floor(){return new W(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(k){return k.x=this._x-Math.floor(this._x),k.y=this._y-Math.floor(this._y),k.z=this._z-Math.floor(this._z),k.w=this._w-Math.floor(this._w),k}fract(){return new W(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(k){return 0===k||1===k?this:this.scaleInPlace(1/k)}normalizeToNew(){return this.normalizeToRef(new W)}normalizeToRef(k){const h=this.length();return 0===h||1===h?(k.x=this._x,k.y=this._y,k.z=this._z,k.w=this._w,k):this.scaleToRef(1/h,k)}toVector3(){return new c(this._x,this._y,this._z)}clone(){return new W(this._x,this._y,this._z,this._w)}Y(k){return this.x=k.x,this.y=k.y,this.z=k.z,this.w=k.w,this}VJ(k,h,o,x){return this.x=k,this.y=h,this.z=o,this.w=x,this}set(k,h,o,x){return this.VJ(k,h,o,x)}FJ(k){return this.x=this.y=this.z=this.w=k,this}dot(k){return this._x*k.x+this._y*k.y+this._z*k.z+this._w*k.w}static Uh(k,h){return h||(h=0),new W(k[h],k[h+1],k[h+2],k[h+3])}static FromArrayToRef(k,h,o){return o.x=k[h],o.y=k[h+1],o.z=k[h+2],o.w=k[h+3],o}static FromFloatArrayToRef(k,h,o){return W.FromArrayToRef(k,h,o),o}static FromFloatsToRef(k,h,o,x,I){return I.x=k,I.y=h,I.z=o,I.w=x,I}static Zero(){return new W(0,0,0,0)}static One(){return new W(1,1,1,1)}static Random(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new W((0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h))}static RandomToRef(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments.length>2?arguments[2]:void 0;return o.x=(0,G.RandomRange)(k,h),o.y=(0,G.RandomRange)(k,h),o.z=(0,G.RandomRange)(k,h),o.w=(0,G.RandomRange)(k,h),o}static Clamp(k,h,o){return W.ClampToRef(k,h,o,new W)}static ClampToRef(k,h,o,x){return x.x=(0,G.Clamp)(k.x,h.x,o.x),x.y=(0,G.Clamp)(k.y,h.y,o.y),x.z=(0,G.Clamp)(k.z,h.z,o.z),x.w=(0,G.Clamp)(k.w,h.w,o.w),x}static CheckExtends(k,h,o){h.minimizeInPlace(k),o.maximizeInPlace(k)}static get ZeroReadOnly(){return W._ZeroReadOnly}static Normalize(k){return W.NormalizeToRef(k,new W)}static NormalizeToRef(k,h){return k.normalizeToRef(h),h}static Minimize(k,h){const o=new W;return o.Y(k),o.minimizeInPlace(h),o}static Maximize(k,h){const o=new W;return o.Y(k),o.maximizeInPlace(h),o}static Distance(k,h){return Math.sqrt(W.DistanceSquared(k,h))}static DistanceSquared(k,h){const o=k.x-h.x,x=k.y-h.y,I=k.z-h.z,q=k.w-h.w;return o*o+x*x+I*I+q*q}static Center(k,h){return W.CenterToRef(k,h,new W)}static CenterToRef(k,h,o){return o.x=(k.x+h.x)/2,o.y=(k.y+h.y)/2,o.z=(k.z+h.z)/2,o.w=(k.w+h.w)/2,o}static TransformCoordinates(k,h){return W.TransformCoordinatesToRef(k,h,new W)}static TransformCoordinatesToRef(k,h,o){return W.TransformCoordinatesFromFloatsToRef(k._x,k._y,k._z,h,o),o}static TransformCoordinatesFromFloatsToRef(k,h,o,x,I){const q=x.m,Y=k*q[0]+h*q[4]+o*q[8]+q[12],J=k*q[1]+h*q[5]+o*q[9]+q[13],G=k*q[2]+h*q[6]+o*q[10]+q[14],l=k*q[3]+h*q[7]+o*q[11]+q[15];return I.x=Y,I.y=J,I.z=G,I.w=l,I}static TransformNormal(k,h){return W.TransformNormalToRef(k,h,new W)}static TransformNormalToRef(k,h,o){const x=h.m,I=k.x*x[0]+k.y*x[4]+k.z*x[8],q=k.x*x[1]+k.y*x[5]+k.z*x[9],Y=k.x*x[2]+k.y*x[6]+k.z*x[10];return o.x=I,o.y=q,o.z=Y,o.w=k.w,o}static TransformNormalFromFloatsToRef(k,h,o,x,I,q){const Y=I.m;return q.x=k*Y[0]+h*Y[4]+o*Y[8],q.y=k*Y[1]+h*Y[5]+o*Y[9],q.z=k*Y[2]+h*Y[6]+o*Y[10],q.w=x,q}static FromVector3(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new W(k._x,k._y,k._z,h)}static Dot(k,h){return k.x*h.x+k.y*h.y+k.z*h.z+k.w*h.w}}W._V8PerformanceHack=new W(.5,.5,.5,.5),W._ZeroReadOnly=W.Zero(),Object.defineProperties(W.prototype,{dimension:{value:[4]},rank:{value:1}});class f{get x(){return this._x}set x(k){this._x=k,this._isDirty=!0}get y(){return this._y}set y(k){this._y=k,this._isDirty=!0}get z(){return this._z}set z(k){this._z=k,this._isDirty=!0}get w(){return this._w}set w(k){this._w=k,this._isDirty=!0}constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=k,this._y=h,this._z=o,this._w=x}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let k=N(this._x);return k=397*k^N(this._y),k=397*k^N(this._z),k=397*k^N(this._w),k}rh(){return[this._x,this._y,this._z,this._w]}toArray(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k[h]=this._x,k[h+1]=this._y,k[h+2]=this._z,k[h+3]=this._w,this}Qo(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f.FromArrayToRef(k,h,this)}equals(k){return k&&this._x===k._x&&this._y===k._y&&this._z===k._z&&this._w===k._w}equalsWithEpsilon(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:x.d;return k&&(0,G.WithinEpsilon)(this._x,k._x,h)&&(0,G.WithinEpsilon)(this._y,k._y,h)&&(0,G.WithinEpsilon)(this._z,k._z,h)&&(0,G.WithinEpsilon)(this._w,k._w,h)}isApprox(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:x.d;return k&&((0,G.WithinEpsilon)(this._x,k._x,h)&&(0,G.WithinEpsilon)(this._y,k._y,h)&&(0,G.WithinEpsilon)(this._z,k._z,h)&&(0,G.WithinEpsilon)(this._w,k._w,h)||(0,G.WithinEpsilon)(this._x,-k._x,h)&&(0,G.WithinEpsilon)(this._y,-k._y,h)&&(0,G.WithinEpsilon)(this._z,-k._z,h)&&(0,G.WithinEpsilon)(this._w,-k._w,h))}clone(){return new f(this._x,this._y,this._z,this._w)}Y(k){return this._x=k._x,this._y=k._y,this._z=k._z,this._w=k._w,this._isDirty=!0,this}VJ(k,h,o,x){return this._x=k,this._y=h,this._z=o,this._w=x,this._isDirty=!0,this}set(k,h,o,x){return this.VJ(k,h,o,x)}FJ(k){return this.VJ(k,k,k,k)}add(k){return new f(this._x+k._x,this._y+k._y,this._z+k._z,this._w+k._w)}addInPlace(k){return this._x+=k._x,this._y+=k._y,this._z+=k._z,this._w+=k._w,this._isDirty=!0,this}addToRef(k,h){return h._x=this._x+k._x,h._y=this._y+k._y,h._z=this._z+k._z,h._w=this._w+k._w,h._isDirty=!0,h}addInPlaceFromFloats(k,h,o,x){return this._x+=k,this._y+=h,this._z+=o,this._w+=x,this._isDirty=!0,this}subtractToRef(k,h){return h._x=this._x-k._x,h._y=this._y-k._y,h._z=this._z-k._z,h._w=this._w-k._w,h._isDirty=!0,h}subtractFromFloats(k,h,o,x){return this.subtractFromFloatsToRef(k,h,o,x,new f)}subtractFromFloatsToRef(k,h,o,x,I){return I._x=this._x-k,I._y=this._y-h,I._z=this._z-o,I._w=this._w-x,I._isDirty=!0,I}ih(k){return new f(this._x-k._x,this._y-k._y,this._z-k._z,this._w-k._w)}xK(k){return this._x-=k._x,this._y-=k._y,this._z-=k._z,this._w-=k._w,this._isDirty=!0,this}scale(k){return new f(this._x*k,this._y*k,this._z*k,this._w*k)}scaleToRef(k,h){return h._x=this._x*k,h._y=this._y*k,h._z=this._z*k,h._w=this._w*k,h._isDirty=!0,h}scaleInPlace(k){return this._x*=k,this._y*=k,this._z*=k,this._w*=k,this._isDirty=!0,this}scaleAndAddToRef(k,h){return h._x+=this._x*k,h._y+=this._y*k,h._z+=this._z*k,h._w+=this._w*k,h._isDirty=!0,h}multiply(k){const h=new f(0,0,0,1);return this.multiplyToRef(k,h),h}multiplyToRef(k,h){const o=this._x*k._w+this._y*k._z-this._z*k._y+this._w*k._x,x=-this._x*k._z+this._y*k._w+this._z*k._x+this._w*k._y,I=this._x*k._y-this._y*k._x+this._z*k._w+this._w*k._z,q=-this._x*k._x-this._y*k._y-this._z*k._z+this._w*k._w;return h.VJ(o,x,I,q),h}multiplyInPlace(k){return this.multiplyToRef(k,this)}multiplyByFloats(k,h,o,x){return this._x*=k,this._y*=h,this._z*=o,this._w*=x,this._isDirty=!0,this}divide(k){throw new ReferenceError("Can not divide a quaternion")}divideToRef(k,h){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(k){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new f)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(k){return k._x=-this._x,k._y=-this._y,k._z=-this._z,k._w=-this._w,k._isDirty=!0,k}equalsToFloats(k,h,o,x){return this._x===k&&this._y===h&&this._z===o&&this._w===x}floorToRef(k){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(k){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(k){return k.VJ(-this._x,-this._y,-this._z,this._w),k}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new f(-this._x,-this._y,-this._z,this._w)}invert(){const k=this.conjugate(),h=this.lengthSquared();return 0==h||1==h||k.scaleInPlace(1/h),k}invertInPlace(){this.conjugateInPlace();const k=this.lengthSquared();return 0==k||1==k||this.scaleInPlace(1/k),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(k){return 0===k||1===k?this:this.scaleInPlace(1/k)}normalizeToNew(){const k=new f(0,0,0,1);return this.normalizeToRef(k),k}normalizeToRef(k){const h=this.length();return 0===h||1===h?k.VJ(this._x,this._y,this._z,this._w):this.scaleToRef(1/h,k)}toEulerAngles(){const k=c.Zero();return this.toEulerAnglesToRef(k),k}toEulerAnglesToRef(k){const h=this._z,o=this._x,x=this._y,I=this._w,q=x*h-o*I,Y=.4999999;if(q<-Y)k._y=2*Math.atan2(x,I),k._x=Math.PI/2,k._z=0,k._isDirty=!0;else if(q>Y)k._y=2*Math.atan2(x,I),k._x=-Math.PI/2,k._z=0,k._isDirty=!0;else{const Y=I*I,J=h*h,G=o*o,l=x*x;k._z=Math.atan2(2*(o*x+h*I),-J-G+l+Y),k._x=Math.asin(-2*q),k._y=Math.atan2(2*(h*o+x*I),J-G-l+Y),k._isDirty=!0}return k}toAlphaBetaGammaToRef(k){const h=this._z,o=this._x,x=this._y,I=this._w,q=Math.sqrt(o*o+x*x),Y=Math.sqrt(h*h+I*I),J=2*Math.atan2(q,Y),G=2*Math.atan2(h,I),l=2*Math.atan2(x,o),A=(G+l)/2,K=(G-l)/2;return k.set(K,J,A),k}toRotationMatrix(k){return M.FromQuaternionToRef(this,k),k}fromRotationMatrix(k){return f.FromRotationMatrixToRef(k,this),this}dot(k){return this._x*k._x+this._y*k._y+this._z*k._z+this._w*k._w}toAxisAngle(){const k=c.Zero();return{axis:k,angle:this.toAxisAngleToRef(k)}}toAxisAngleToRef(k){let h=0;const o=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),x=this._w;return o>0?(h=2*Math.atan2(o,x),k.set(this._x/o,this._y/o,this._z/o)):(h=0,k.set(1,0,0)),h}static FromRotationMatrix(k){const h=new f;return f.FromRotationMatrixToRef(k,h),h}static FromRotationMatrixToRef(k,h){const o=k.m,x=o[0],I=o[4],q=o[8],Y=o[1],J=o[5],G=o[9],l=o[2],A=o[6],K=o[10],a=x+J+K;let N;return a>0?(N=.5/Math.sqrt(a+1),h._w=.25/N,h._x=(A-G)*N,h._y=(q-l)*N,h._z=(Y-I)*N,h._isDirty=!0):x>J&&x>K?(N=2*Math.sqrt(1+x-J-K),h._w=(A-G)/N,h._x=.25*N,h._y=(I+Y)/N,h._z=(q+l)/N,h._isDirty=!0):J>K?(N=2*Math.sqrt(1+J-x-K),h._w=(q-l)/N,h._x=(I+Y)/N,h._y=.25*N,h._z=(G+A)/N,h._isDirty=!0):(N=2*Math.sqrt(1+K-x-J),h._w=(Y-I)/N,h._x=(q+l)/N,h._y=(G+A)/N,h._z=.25*N,h._isDirty=!0),h}static Dot(k,h){return k._x*h._x+k._y*h._y+k._z*h._z+k._w*h._w}static AreClose(k,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const x=f.Dot(k,h);return 1-x*x<=o}static SmoothToRef(k,h,o,x,I){let q=0===x?1:o/x;return q=(0,G.Clamp)(q,0,1),f.SlerpToRef(k,h,q,I),I}static Zero(){return new f(0,0,0,0)}static Inverse(k){return new f(-k._x,-k._y,-k._z,k._w)}static InverseToRef(k,h){return h.set(-k._x,-k._y,-k._z,k._w),h}static Identity(){return new f(0,0,0,1)}static IsIdentity(k){return k&&0===k._x&&0===k._y&&0===k._z&&1===k._w}static RotationAxis(k,h){return f.RotationAxisToRef(k,h,new f)}static RotationAxisToRef(k,h,o){o._w=Math.cos(h/2);const x=Math.sin(h/2)/k.length();return o._x=k._x*x,o._y=k._y*x,o._z=k._z*x,o._isDirty=!0,o}static Uh(k,h){return h||(h=0),new f(k[h],k[h+1],k[h+2],k[h+3])}static FromArrayToRef(k,h,o){return o._x=k[h],o._y=k[h+1],o._z=k[h+2],o._w=k[h+3],o._isDirty=!0,o}static FromFloatsToRef(k,h,o,x,I){return I.VJ(k,h,o,x),I}static FromEulerAngles(k,h,o){const x=new f;return f.RotationYawPitchRollToRef(h,k,o,x),x}static FromEulerAnglesToRef(k,h,o,x){return f.RotationYawPitchRollToRef(h,k,o,x),x}static FromEulerVector(k){const h=new f;return f.RotationYawPitchRollToRef(k._y,k._x,k._z,h),h}static FromEulerVectorToRef(k,h){return f.RotationYawPitchRollToRef(k._y,k._x,k._z,h),h}static FromUnitVectorsToRef(k,h,o){let I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:x.d;const q=c.Dot(k,h)+1;return q<I?Math.abs(k.x)>Math.abs(k.z)?o.set(-k.y,k.x,0,0):o.set(0,-k.z,k.y,0):(c.CrossToRef(k,h,j.Vh[0]),o.set(j.Vh[0].x,j.Vh[0].y,j.Vh[0].z,q)),o.normalize()}static RotationYawPitchRoll(k,h,o){const x=new f;return f.RotationYawPitchRollToRef(k,h,o,x),x}static RotationYawPitchRollToRef(k,h,o,x){const I=.5*o,q=.5*h,Y=.5*k,J=Math.sin(I),G=Math.cos(I),l=Math.sin(q),A=Math.cos(q),K=Math.sin(Y),a=Math.cos(Y);return x._x=a*l*G+K*A*J,x._y=K*A*G-a*l*J,x._z=a*A*J-K*l*G,x._w=a*A*G+K*l*J,x._isDirty=!0,x}static RotationAlphaBetaGamma(k,h,o){const x=new f;return f.RotationAlphaBetaGammaToRef(k,h,o,x),x}static RotationAlphaBetaGammaToRef(k,h,o,x){const I=.5*(o+k),q=.5*(o-k),Y=.5*h;return x._x=Math.cos(q)*Math.sin(Y),x._y=Math.sin(q)*Math.sin(Y),x._z=Math.sin(I)*Math.cos(Y),x._w=Math.cos(I)*Math.cos(Y),x._isDirty=!0,x}static RotationQuaternionFromAxis(k,h,o){const x=new f(0,0,0,0);return f.RotationQuaternionFromAxisToRef(k,h,o,x),x}static RotationQuaternionFromAxisToRef(k,h,o,x){const I=T.Matrix[0];return k=k.normalizeToRef(T.Vh[0]),h=h.normalizeToRef(T.Vh[1]),o=o.normalizeToRef(T.Vh[2]),M.FromXYZAxesToRef(k,h,o,I),f.FromRotationMatrixToRef(I,x),x}static FromLookDirectionLH(k,h){const o=new f;return f.FromLookDirectionLHToRef(k,h,o),o}static FromLookDirectionLHToRef(k,h,o){const x=T.Matrix[0];return M.LookDirectionLHToRef(k,h,x),f.FromRotationMatrixToRef(x,o),o}static FromLookDirectionRH(k,h){const o=new f;return f.FromLookDirectionRHToRef(k,h,o),o}static FromLookDirectionRHToRef(k,h,o){const x=T.Matrix[0];return M.LookDirectionRHToRef(k,h,x),f.FromRotationMatrixToRef(x,o)}static Slerp(k,h,o){const x=f.Identity();return f.SlerpToRef(k,h,o,x),x}static SlerpToRef(k,h,o,x){let I,q,Y=k._x*h._x+k._y*h._y+k._z*h._z+k._w*h._w,J=!1;if(Y<0&&(J=!0,Y=-Y),Y>.999999)q=1-o,I=J?-o:o;else{const k=Math.acos(Y),h=1/Math.sin(k);q=Math.sin((1-o)*k)*h,I=J?-Math.sin(o*k)*h:Math.sin(o*k)*h}return x._x=q*k._x+I*h._x,x._y=q*k._y+I*h._y,x._z=q*k._z+I*h._z,x._w=q*k._w+I*h._w,x._isDirty=!0,x}static Hermite(k,h,o,x,I){const q=I*I,Y=I*q,J=2*Y-3*q+1,G=-2*Y+3*q,l=Y-2*q+I,A=Y-q,K=k._x*J+o._x*G+h._x*l+x._x*A,a=k._y*J+o._y*G+h._y*l+x._y*A,N=k._z*J+o._z*G+h._z*l+x._z*A,X=k._w*J+o._w*G+h._w*l+x._w*A;return new f(K,a,N,X)}static Hermite1stDerivative(k,h,o,x,I){const q=new f;return this.Hermite1stDerivativeToRef(k,h,o,x,I,q),q}static Hermite1stDerivativeToRef(k,h,o,x,I,q){const Y=I*I;return q._x=6*(Y-I)*k._x+(3*Y-4*I+1)*h._x+6*(-Y+I)*o._x+(3*Y-2*I)*x._x,q._y=6*(Y-I)*k._y+(3*Y-4*I+1)*h._y+6*(-Y+I)*o._y+(3*Y-2*I)*x._y,q._z=6*(Y-I)*k._z+(3*Y-4*I+1)*h._z+6*(-Y+I)*o._z+(3*Y-2*I)*x._z,q._w=6*(Y-I)*k._w+(3*Y-4*I+1)*h._w+6*(-Y+I)*o._w+(3*Y-2*I)*x._w,q._isDirty=!0,q}static Normalize(k){const h=f.Zero();return f.NormalizeToRef(k,h),h}static NormalizeToRef(k,h){return k.normalizeToRef(h),h}static Clamp(k,h,o){const x=new f;return f.ClampToRef(k,h,o,x),x}static ClampToRef(k,h,o,x){return x.VJ((0,G.Clamp)(k.x,h.x,o.x),(0,G.Clamp)(k.y,h.y,o.y),(0,G.Clamp)(k.z,h.z,o.z),(0,G.Clamp)(k.w,h.w,o.w))}static Random(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new f((0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h))}static RandomToRef(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).VJ((0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h),(0,G.RandomRange)(k,h))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(k,h){return Math.sqrt(f.DistanceSquared(k,h))}static DistanceSquared(k,h){const o=k.x-h.x,x=k.y-h.y,I=k.z-h.z,q=k.w-h.w;return o*o+x*x+I*I+q*q}static Center(k,h){return f.CenterToRef(k,h,f.Zero())}static CenterToRef(k,h,o){return o.VJ((k.x+h.x)/2,(k.y+h.y)/2,(k.z+h.z)/2,(k.w+h.w)/2)}}f._V8PerformanceHack=new f(.5,.5,.5,.5),Object.defineProperties(f.prototype,{dimension:{value:[4]},rank:{value:1}});class M{static get Use64Bits(){return Y.e.MatrixUse64Bits}get m(){return this.wh}markAsUpdated(){this.updateFlag=l._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(k){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=k,this._isIdentity3x2=k||o,this._isIdentityDirty=!this._isIdentity&&h,this._isIdentity3x2Dirty=!this._isIdentity3x2&&x}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,Y.e.MatrixTrackPrecisionChange&&Y.e.MatrixTrackedMatrices.push(this),this.wh=new Y.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const k=this.wh;this._isIdentity=1===k[0]&&0===k[1]&&0===k[2]&&0===k[3]&&0===k[4]&&1===k[5]&&0===k[6]&&0===k[7]&&0===k[8]&&0===k[9]&&1===k[10]&&0===k[11]&&0===k[12]&&0===k[13]&&0===k[14]&&1===k[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.wh[0]||1!==this.wh[5]||1!==this.wh[15]||0!==this.wh[1]||0!==this.wh[2]||0!==this.wh[3]||0!==this.wh[4]||0!==this.wh[6]||0!==this.wh[7]||0!==this.wh[8]||0!==this.wh[9]||0!==this.wh[10]||0!==this.wh[11]||0!==this.wh[12]||0!==this.wh[13]||0!==this.wh[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const k=this.wh,h=k[0],o=k[1],x=k[2],I=k[3],q=k[4],Y=k[5],J=k[6],G=k[7],l=k[8],A=k[9],K=k[10],a=k[11],N=k[12],X=k[13],c=k[14],W=k[15],f=K*W-c*a,M=A*W-X*a,T=A*c-X*K,j=l*W-N*a,d=l*c-K*N,b=l*X-N*A;return h*+(Y*f-J*M+G*T)+o*-(q*f-J*j+G*d)+x*+(q*M-Y*j+G*b)+I*-(q*T-Y*d+J*b)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!k)return this.wh;const o=this.wh;for(let x=0;x<16;x++)k[h+x]=o[x];return this}rh(){return this.wh}Qo(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M.FromArrayToRef(k,h,this)}VJ(){for(var k=arguments.length,h=new Array(k),o=0;o<k;o++)h[o]=arguments[o];return M.FromArrayToRef(h,0,this)}set(){const k=this.wh;for(let h=0;h<16;h++)k[h]=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}FJ(k){const h=this.wh;for(let o=0;o<16;o++)h[o]=k;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return M.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(k){const h=new M;return this.addToRef(k,h),h}addToRef(k,h){const o=this.wh,x=h.wh,I=k.m;for(let q=0;q<16;q++)x[q]=o[q]+I[q];return h.markAsUpdated(),h}addToSelf(k){const h=this.wh,o=k.m;return h[0]+=o[0],h[1]+=o[1],h[2]+=o[2],h[3]+=o[3],h[4]+=o[4],h[5]+=o[5],h[6]+=o[6],h[7]+=o[7],h[8]+=o[8],h[9]+=o[9],h[10]+=o[10],h[11]+=o[11],h[12]+=o[12],h[13]+=o[13],h[14]+=o[14],h[15]+=o[15],this.markAsUpdated(),this}addInPlace(k){const h=this.wh,o=k.m;for(let x=0;x<16;x++)h[x]+=o[x];return this.markAsUpdated(),this}addInPlaceFromFloats(){const k=this.wh;for(let h=0;h<16;h++)k[h]+=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}ih(k){const h=this.wh,o=k.m;for(let x=0;x<16;x++)h[x]-=o[x];return this.markAsUpdated(),this}subtractToRef(k,h){const o=this.wh,x=k.m,I=h.wh;for(let q=0;q<16;q++)I[q]=o[q]-x[q];return h.markAsUpdated(),h}xK(k){const h=this.wh,o=k.m;for(let x=0;x<16;x++)h[x]-=o[x];return this.markAsUpdated(),this}subtractFromFloats(){for(var k=arguments.length,h=new Array(k),o=0;o<k;o++)h[o]=arguments[o];return this.subtractFromFloatsToRef(...h,new M)}subtractFromFloatsToRef(){for(var k=arguments.length,h=new Array(k),o=0;o<k;o++)h[o]=arguments[o];const x=h.pop(),I=this.wh,q=x.wh,Y=h;for(let J=0;J<16;J++)q[J]=I[J]-Y[J];return x.markAsUpdated(),x}invertToRef(k){return!0===this._isIdentity?(M.IdentityToRef(k),k):(a(this,k.rh())?k.markAsUpdated():k.Y(this),k)}addAtIndex(k,h){return this.wh[k]+=h,this.markAsUpdated(),this}multiplyAtIndex(k,h){return this.wh[k]*=h,this.markAsUpdated(),this}setTranslationFromFloats(k,h,o){return this.wh[12]=k,this.wh[13]=h,this.wh[14]=o,this.markAsUpdated(),this}addTranslationFromFloats(k,h,o){return this.wh[12]+=k,this.wh[13]+=h,this.wh[14]+=o,this.markAsUpdated(),this}setTranslation(k){return this.setTranslationFromFloats(k._x,k._y,k._z)}getTranslation(){return new c(this.wh[12],this.wh[13],this.wh[14])}getTranslationToRef(k){return k.x=this.wh[12],k.y=this.wh[13],k.z=this.wh[14],k}removeRotationAndScaling(){const k=this.m;return M.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,k[12],k[13],k[14],k[15],this),this._updateIdentityStatus(0===k[12]&&0===k[13]&&0===k[14]&&1===k[15]),this}Y(k){k.copyToArray(this.wh);const h=k;return this.updateFlag=h.updateFlag,this._updateIdentityStatus(h._isIdentity,h._isIdentityDirty,h._isIdentity3x2,h._isIdentity3x2Dirty),this}copyToArray(k){return K(this,k,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(k){const h=new M;return this.multiplyToRef(k,h),h}multiplyInPlace(k){const h=this.wh,o=k.m;for(let x=0;x<16;x++)h[x]*=o[x];return this.markAsUpdated(),this}multiplyByFloats(){const k=this.wh;for(let h=0;h<16;h++)k[h]*=h<0||arguments.length<=h?void 0:arguments[h];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var k=arguments.length,h=new Array(k),o=0;o<k;o++)h[o]=arguments[o];const x=h.pop(),I=this.wh,q=x.wh,Y=h;for(let J=0;J<16;J++)q[J]=I[J]*Y[J];return x.markAsUpdated(),x}multiplyToRef(k,h){return this._isIdentity?(h.Y(k),h):k._isIdentity?(h.Y(this),h):(this.multiplyToArray(k,h.wh,0),h.markAsUpdated(),h)}multiplyToArray(k,h,o){return A(this,k,h,o),this}divide(k){return this.divideToRef(k,new M)}divideToRef(k,h){const o=this.wh,x=k.m,I=h.wh;for(let q=0;q<16;q++)I[q]=o[q]/x[q];return h.markAsUpdated(),h}divideInPlace(k){const h=this.wh,o=k.m;for(let x=0;x<16;x++)h[x]/=o[x];return this.markAsUpdated(),this}minimizeInPlace(k){const h=this.wh,o=k.m;for(let x=0;x<16;x++)h[x]=Math.min(h[x],o[x]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const k=this.wh;for(let h=0;h<16;h++)k[h]=Math.min(k[h],h<0||arguments.length<=h?void 0:arguments[h]);return this.markAsUpdated(),this}maximizeInPlace(k){const h=this.wh,o=k.m;for(let x=0;x<16;x++)h[x]=Math.min(h[x],o[x]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const k=this.wh;for(let h=0;h<16;h++)k[h]=Math.min(k[h],h<0||arguments.length<=h?void 0:arguments[h]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new M)}negateInPlace(){const k=this.wh;for(let h=0;h<16;h++)k[h]=-k[h];return this.markAsUpdated(),this}negateToRef(k){const h=this.wh,o=k.wh;for(let x=0;x<16;x++)o[x]=-h[x];return k.markAsUpdated(),k}equals(k){const h=k;if(!h)return!1;if((this._isIdentity||h._isIdentity)&&!this._isIdentityDirty&&!h._isIdentityDirty)return this._isIdentity&&h._isIdentity;const o=this.m,x=h.m;return o[0]===x[0]&&o[1]===x[1]&&o[2]===x[2]&&o[3]===x[3]&&o[4]===x[4]&&o[5]===x[5]&&o[6]===x[6]&&o[7]===x[7]&&o[8]===x[8]&&o[9]===x[9]&&o[10]===x[10]&&o[11]===x[11]&&o[12]===x[12]&&o[13]===x[13]&&o[14]===x[14]&&o[15]===x[15]}equalsWithEpsilon(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=this.wh,x=k.m;for(let I=0;I<16;I++)if(!(0,G.WithinEpsilon)(o[I],x[I],h))return!1;return!0}equalsToFloats(){const k=this.wh;for(let h=0;h<16;h++)if(k[h]!=(h<0||arguments.length<=h?void 0:arguments[h]))return!1;return!0}floor(){return this.floorToRef(new M)}floorToRef(k){const h=this.wh,o=k.wh;for(let x=0;x<16;x++)o[x]=Math.floor(h[x]);return k.markAsUpdated(),k}fract(){return this.fractToRef(new M)}fractToRef(k){const h=this.wh,o=k.wh;for(let x=0;x<16;x++)o[x]=h[x]-Math.floor(h[x]);return k.markAsUpdated(),k}clone(){const k=new M;return k.Y(this),k}getClassName(){return"Matrix"}getHashCode(){let k=N(this.wh[0]);for(let h=1;h<16;h++)k=397*k^N(this.wh[h]);return k}decomposeToTransformNode(k){return k.rotationQuaternion=k.rotationQuaternion||new f,this.decompose(k.iJ,k.rotationQuaternion,k.position)}decompose(k,h,o,x){let I=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return o&&o.FJ(0),k&&k.FJ(1),h&&h.VJ(0,0,0,1),!0;const q=this.wh;if(o&&o.VJ(q[12],q[13],q[14]),(k=k||T.Vh[0]).x=Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]),k.y=Math.sqrt(q[4]*q[4]+q[5]*q[5]+q[6]*q[6]),k.z=Math.sqrt(q[8]*q[8]+q[9]*q[9]+q[10]*q[10]),x){const h=(I?x.absoluteScaling.x:x.iJ.x)<0?-1:1,o=(I?x.absoluteScaling.y:x.iJ.y)<0?-1:1,q=(I?x.absoluteScaling.z:x.iJ.z)<0?-1:1;k.x*=h,k.y*=o,k.z*=q}else this.determinant()<=0&&(k.y*=-1);if(0===k._x||0===k._y||0===k._z)return h&&h.VJ(0,0,0,1),!1;if(h){const o=1/k._x,x=1/k._y,I=1/k._z;M.FromValuesToRef(q[0]*o,q[1]*o,q[2]*o,0,q[4]*x,q[5]*x,q[6]*x,0,q[8]*I,q[9]*I,q[10]*I,0,0,0,0,1,T.Matrix[0]),f.FromRotationMatrixToRef(T.Matrix[0],h)}return!0}getRow(k){if(k<0||k>3)return null;const h=4*k;return new W(this.wh[h+0],this.wh[h+1],this.wh[h+2],this.wh[h+3])}getRowToRef(k,h){if(k>=0&&k<=3){const o=4*k;h.x=this.wh[o+0],h.y=this.wh[o+1],h.z=this.wh[o+2],h.w=this.wh[o+3]}return h}setRow(k,h){return this.setRowFromFloats(k,h.x,h.y,h.z,h.w)}transpose(){const k=new M;return M.TransposeToRef(this,k),k}transposeToRef(k){return M.TransposeToRef(this,k),k}setRowFromFloats(k,h,o,x,I){if(k<0||k>3)return this;const q=4*k;return this.wh[q+0]=h,this.wh[q+1]=o,this.wh[q+2]=x,this.wh[q+3]=I,this.markAsUpdated(),this}scale(k){const h=new M;return this.scaleToRef(k,h),h}scaleToRef(k,h){for(let o=0;o<16;o++)h.wh[o]=this.wh[o]*k;return h.markAsUpdated(),h}scaleAndAddToRef(k,h){for(let o=0;o<16;o++)h.wh[o]+=this.wh[o]*k;return h.markAsUpdated(),h}scaleInPlace(k){const h=this.wh;for(let o=0;o<16;o++)h[o]*=k;return this.markAsUpdated(),this}toNormalMatrix(k){const h=T.Matrix[0];this.invertToRef(h),h.transposeToRef(k);const o=k.wh;return M.FromValuesToRef(o[0],o[1],o[2],0,o[4],o[5],o[6],0,o[8],o[9],o[10],0,0,0,0,1,k),k}getRotationMatrix(){const k=new M;return this.getRotationMatrixToRef(k),k}getRotationMatrixToRef(k){const h=T.Vh[0];if(!this.decompose(h))return M.IdentityToRef(k),k;const o=this.wh,x=1/h._x,I=1/h._y,q=1/h._z;return M.FromValuesToRef(o[0]*x,o[1]*x,o[2]*x,0,o[4]*I,o[5]*I,o[6]*I,0,o[8]*q,o[9]*q,o[10]*q,0,0,0,0,1,k),k}toggleModelMatrixHandInPlace(){const k=this.wh;return k[2]*=-1,k[6]*=-1,k[8]*=-1,k[9]*=-1,k[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const k=this.wh;return k[8]*=-1,k[9]*=-1,k[10]*=-1,k[11]*=-1,this.markAsUpdated(),this}static Uh(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=new M;return M.FromArrayToRef(k,h,o),o}static FromArrayToRef(k,h,o){for(let x=0;x<16;x++)o.wh[x]=k[x+h];return o.markAsUpdated(),o}static FromFloat32ArrayToRefScaled(k,h,o,x){return x.wh[0]=k[0+h]*o,x.wh[1]=k[1+h]*o,x.wh[2]=k[2+h]*o,x.wh[3]=k[3+h]*o,x.wh[4]=k[4+h]*o,x.wh[5]=k[5+h]*o,x.wh[6]=k[6+h]*o,x.wh[7]=k[7+h]*o,x.wh[8]=k[8+h]*o,x.wh[9]=k[9+h]*o,x.wh[10]=k[10+h]*o,x.wh[11]=k[11+h]*o,x.wh[12]=k[12+h]*o,x.wh[13]=k[13+h]*o,x.wh[14]=k[14+h]*o,x.wh[15]=k[15+h]*o,x.markAsUpdated(),x}static get IdentityReadOnly(){return M._IdentityReadOnly}static FromValuesToRef(k,h,o,x,I,q,Y,J,G,l,A,K,a,N,X,c,W){const f=W.wh;f[0]=k,f[1]=h,f[2]=o,f[3]=x,f[4]=I,f[5]=q,f[6]=Y,f[7]=J,f[8]=G,f[9]=l,f[10]=A,f[11]=K,f[12]=a,f[13]=N,f[14]=X,f[15]=c,W.markAsUpdated()}static FromValues(k,h,o,x,I,q,Y,J,G,l,A,K,a,N,X,c){const W=new M,f=W.wh;return f[0]=k,f[1]=h,f[2]=o,f[3]=x,f[4]=I,f[5]=q,f[6]=Y,f[7]=J,f[8]=G,f[9]=l,f[10]=A,f[11]=K,f[12]=a,f[13]=N,f[14]=X,f[15]=c,W.markAsUpdated(),W}static Compose(k,h,o){const x=new M;return M.ComposeToRef(k,h,o,x),x}static ComposeToRef(k,h,o,x){const I=x.wh,q=h._x,Y=h._y,J=h._z,G=h._w,l=q+q,A=Y+Y,K=J+J,a=q*l,N=q*A,X=q*K,c=Y*A,W=Y*K,f=J*K,M=G*l,T=G*A,j=G*K,d=k._x,b=k._y,V=k._z;return I[0]=(1-(c+f))*d,I[1]=(N+j)*d,I[2]=(X-T)*d,I[3]=0,I[4]=(N-j)*b,I[5]=(1-(a+f))*b,I[6]=(W+M)*b,I[7]=0,I[8]=(X+T)*V,I[9]=(W-M)*V,I[10]=(1-(a+c))*V,I[11]=0,I[12]=o._x,I[13]=o._y,I[14]=o._z,I[15]=1,x.markAsUpdated(),x}static Identity(){const k=M.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return k._updateIdentityStatus(!0),k}static IdentityToRef(k){return M.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,k),k._updateIdentityStatus(!0),k}static Zero(){const k=M.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return k._updateIdentityStatus(!1),k}static RotationX(k){const h=new M;return M.RotationXToRef(k,h),h}static Invert(k){const h=new M;return k.invertToRef(h),h}static RotationXToRef(k,h){const o=Math.sin(k),x=Math.cos(k);return M.FromValuesToRef(1,0,0,0,0,x,o,0,0,-o,x,0,0,0,0,1,h),h._updateIdentityStatus(1===x&&0===o),h}static RotationY(k){const h=new M;return M.RotationYToRef(k,h),h}static RotationYToRef(k,h){const o=Math.sin(k),x=Math.cos(k);return M.FromValuesToRef(x,0,-o,0,0,1,0,0,o,0,x,0,0,0,0,1,h),h._updateIdentityStatus(1===x&&0===o),h}static RotationZ(k){const h=new M;return M.RotationZToRef(k,h),h}static RotationZToRef(k,h){const o=Math.sin(k),x=Math.cos(k);return M.FromValuesToRef(x,o,0,0,-o,x,0,0,0,0,1,0,0,0,0,1,h),h._updateIdentityStatus(1===x&&0===o),h}static RotationAxis(k,h){const o=new M;return M.RotationAxisToRef(k,h,o),o}static RotationAxisToRef(k,h,o){const x=Math.sin(-h),I=Math.cos(-h),q=1-I;k=k.normalizeToRef(T.Vh[0]);const Y=o.wh;return Y[0]=k._x*k._x*q+I,Y[1]=k._x*k._y*q-k._z*x,Y[2]=k._x*k._z*q+k._y*x,Y[3]=0,Y[4]=k._y*k._x*q+k._z*x,Y[5]=k._y*k._y*q+I,Y[6]=k._y*k._z*q-k._x*x,Y[7]=0,Y[8]=k._z*k._x*q-k._y*x,Y[9]=k._z*k._y*q+k._x*x,Y[10]=k._z*k._z*q+I,Y[11]=0,Y[12]=0,Y[13]=0,Y[14]=0,Y[15]=1,o.markAsUpdated(),o}static RotationAlignToRef(k,h,o){let I=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const q=c.Dot(h,k),Y=o.wh;if(q<-1+x.d)Y[0]=-1,Y[1]=0,Y[2]=0,Y[3]=0,Y[4]=0,Y[5]=I?1:-1,Y[6]=0,Y[7]=0,Y[8]=0,Y[9]=0,Y[10]=I?-1:1,Y[11]=0;else{const o=c.Cross(h,k),x=1/(1+q);Y[0]=o._x*o._x*x+q,Y[1]=o._y*o._x*x-o._z,Y[2]=o._z*o._x*x+o._y,Y[3]=0,Y[4]=o._x*o._y*x+o._z,Y[5]=o._y*o._y*x+q,Y[6]=o._z*o._y*x-o._x,Y[7]=0,Y[8]=o._x*o._z*x-o._y,Y[9]=o._y*o._z*x+o._x,Y[10]=o._z*o._z*x+q,Y[11]=0}return Y[12]=0,Y[13]=0,Y[14]=0,Y[15]=1,o.markAsUpdated(),o}static RotationYawPitchRoll(k,h,o){const x=new M;return M.RotationYawPitchRollToRef(k,h,o,x),x}static RotationYawPitchRollToRef(k,h,o,x){return f.RotationYawPitchRollToRef(k,h,o,T.Quaternion[0]),T.Quaternion[0].toRotationMatrix(x),x}static Scaling(k,h,o){const x=new M;return M.ScalingToRef(k,h,o,x),x}static ScalingToRef(k,h,o,x){return M.FromValuesToRef(k,0,0,0,0,h,0,0,0,0,o,0,0,0,0,1,x),x._updateIdentityStatus(1===k&&1===h&&1===o),x}static Translation(k,h,o){const x=new M;return M.TranslationToRef(k,h,o,x),x}static TranslationToRef(k,h,o,x){return M.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,k,h,o,1,x),x._updateIdentityStatus(0===k&&0===h&&0===o),x}static Lerp(k,h,o){const x=new M;return M.LerpToRef(k,h,o,x),x}static LerpToRef(k,h,o,x){const I=x.wh,q=k.m,Y=h.m;for(let J=0;J<16;J++)I[J]=q[J]*(1-o)+Y[J]*o;return x.markAsUpdated(),x}static DecomposeLerp(k,h,o){const x=new M;return M.DecomposeLerpToRef(k,h,o,x),x}static DecomposeLerpToRef(k,h,o,x){const I=T.Vh[0],q=T.Quaternion[0],Y=T.Vh[1];k.decompose(I,q,Y);const J=T.Vh[2],G=T.Quaternion[1],l=T.Vh[3];h.decompose(J,G,l);const A=T.Vh[4];c.LerpToRef(I,J,o,A);const K=T.Quaternion[2];f.SlerpToRef(q,G,o,K);const a=T.Vh[5];return c.LerpToRef(Y,l,o,a),M.ComposeToRef(A,K,a,x),x}static LookAtLH(k,h,o){const x=new M;return M.LookAtLHToRef(k,h,o,x),x}static LookAtLHToRef(k,h,o,x){const I=T.Vh[0],q=T.Vh[1],Y=T.Vh[2];h.subtractToRef(k,Y),Y.normalize(),c.CrossToRef(o,Y,I);const J=I.lengthSquared();0===J?I.x=1:I.normalizeFromLength(Math.sqrt(J)),c.CrossToRef(Y,I,q),q.normalize();const G=-c.Dot(I,k),l=-c.Dot(q,k),A=-c.Dot(Y,k);return M.FromValuesToRef(I._x,q._x,Y._x,0,I._y,q._y,Y._y,0,I._z,q._z,Y._z,0,G,l,A,1,x),x}static LookAtRH(k,h,o){const x=new M;return M.LookAtRHToRef(k,h,o,x),x}static LookAtRHToRef(k,h,o,x){const I=T.Vh[0],q=T.Vh[1],Y=T.Vh[2];k.subtractToRef(h,Y),Y.normalize(),c.CrossToRef(o,Y,I);const J=I.lengthSquared();0===J?I.x=1:I.normalizeFromLength(Math.sqrt(J)),c.CrossToRef(Y,I,q),q.normalize();const G=-c.Dot(I,k),l=-c.Dot(q,k),A=-c.Dot(Y,k);return M.FromValuesToRef(I._x,q._x,Y._x,0,I._y,q._y,Y._y,0,I._z,q._z,Y._z,0,G,l,A,1,x),x}static LookDirectionLH(k,h){const o=new M;return M.LookDirectionLHToRef(k,h,o),o}static LookDirectionLHToRef(k,h,o){const x=T.Vh[0];x.Y(k),x.scaleInPlace(-1);const I=T.Vh[1];return c.CrossToRef(h,x,I),M.FromValuesToRef(I._x,I._y,I._z,0,h._x,h._y,h._z,0,x._x,x._y,x._z,0,0,0,0,1,o),o}static LookDirectionRH(k,h){const o=new M;return M.LookDirectionRHToRef(k,h,o),o}static LookDirectionRHToRef(k,h,o){const x=T.Vh[2];return c.CrossToRef(h,k,x),M.FromValuesToRef(x._x,x._y,x._z,0,h._x,h._y,h._z,0,k._x,k._y,k._z,0,0,0,0,1,o),o}static OrthoLH(k,h,o,x,I){const q=new M;return M.OrthoLHToRef(k,h,o,x,q,I),q}static OrthoLHToRef(k,h,o,x,I,q){const Y=2/k,J=2/h,G=2/(x-o),l=-(x+o)/(x-o);return M.FromValuesToRef(Y,0,0,0,0,J,0,0,0,0,G,0,0,0,l,1,I),q&&I.multiplyToRef(d,I),I._updateIdentityStatus(1===Y&&1===J&&1===G&&0===l),I}static OrthoOffCenterLH(k,h,o,x,I,q,Y){const J=new M;return M.OrthoOffCenterLHToRef(k,h,o,x,I,q,J,Y),J}static OrthoOffCenterLHToRef(k,h,o,x,I,q,Y,J){const G=2/(h-k),l=2/(x-o),A=2/(q-I),K=-(q+I)/(q-I),a=(k+h)/(k-h),N=(x+o)/(o-x);return M.FromValuesToRef(G,0,0,0,0,l,0,0,0,0,A,0,a,N,K,1,Y),J&&Y.multiplyToRef(d,Y),Y.markAsUpdated(),Y}static ObliqueOffCenterLHToRef(k,h,o,x,I,q,Y,J,G,l,A){const K=-Y*Math.cos(J),a=-Y*Math.sin(J);return M.TranslationToRef(0,0,-G,T.Matrix[1]),M.FromValuesToRef(1,0,0,0,0,1,0,0,K,a,1,0,0,0,0,1,T.Matrix[0]),T.Matrix[1].multiplyToRef(T.Matrix[0],T.Matrix[0]),M.TranslationToRef(0,0,G,T.Matrix[1]),T.Matrix[0].multiplyToRef(T.Matrix[1],T.Matrix[0]),M.OrthoOffCenterLHToRef(k,h,o,x,I,q,l,A),T.Matrix[0].multiplyToRef(l,l),l}static OrthoOffCenterRH(k,h,o,x,I,q,Y){const J=new M;return M.OrthoOffCenterRHToRef(k,h,o,x,I,q,J,Y),J}static OrthoOffCenterRHToRef(k,h,o,x,I,q,Y,J){return M.OrthoOffCenterLHToRef(k,h,o,x,I,q,Y,J),Y.wh[10]*=-1,Y}static ObliqueOffCenterRHToRef(k,h,o,x,I,q,Y,J,G,l,A){const K=Y*Math.cos(J),a=Y*Math.sin(J);return M.TranslationToRef(0,0,G,T.Matrix[1]),M.FromValuesToRef(1,0,0,0,0,1,0,0,K,a,1,0,0,0,0,1,T.Matrix[0]),T.Matrix[1].multiplyToRef(T.Matrix[0],T.Matrix[0]),M.TranslationToRef(0,0,-G,T.Matrix[1]),T.Matrix[0].multiplyToRef(T.Matrix[1],T.Matrix[0]),M.OrthoOffCenterRHToRef(k,h,o,x,I,q,l,A),T.Matrix[0].multiplyToRef(l,l),l}static PerspectiveLH(k,h,o,x,I){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const Y=new M,J=2*o/k,G=2*o/h,l=(x+o)/(x-o),A=-2*x*o/(x-o),K=Math.tan(q);return M.FromValuesToRef(J,0,0,0,0,G,0,K,0,0,l,1,0,0,A,0,Y),I&&Y.multiplyToRef(d,Y),Y._updateIdentityStatus(!1),Y}static PerspectiveFovLH(k,h,o,x,I){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const J=new M;return M.PerspectiveFovLHToRef(k,h,o,x,J,!0,I,q,Y),J}static PerspectiveFovLHToRef(k,h,o,x,I){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,G=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=o,A=x,K=1/Math.tan(.5*k),a=q?K/h:K,N=q?K:K*h,X=G&&0===l?-1:0!==A?(A+l)/(A-l):1,c=G&&0===l?2*A:0!==A?-2*A*l/(A-l):-2*l,W=Math.tan(J);return M.FromValuesToRef(a,0,0,0,0,N,0,W,0,0,X,1,0,0,c,0,I),Y&&I.multiplyToRef(d,I),I._updateIdentityStatus(!1),I}static PerspectiveFovReverseLHToRef(k,h,o,x,I){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const G=1/Math.tan(.5*k),l=q?G/h:G,A=q?G:G*h,K=Math.tan(J);return M.FromValuesToRef(l,0,0,0,0,A,0,K,0,0,-o,1,0,0,1,0,I),Y&&I.multiplyToRef(d,I),I._updateIdentityStatus(!1),I}static PerspectiveFovRH(k,h,o,x,I){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const J=new M;return M.PerspectiveFovRHToRef(k,h,o,x,J,!0,I,q,Y),J}static PerspectiveFovRHToRef(k,h,o,x,I){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,G=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=o,A=x,K=1/Math.tan(.5*k),a=q?K/h:K,N=q?K:K*h,X=G&&0===l?1:0!==A?-(A+l)/(A-l):-1,c=G&&0===l?2*A:0!==A?-2*A*l/(A-l):-2*l,W=Math.tan(J);return M.FromValuesToRef(a,0,0,0,0,N,0,W,0,0,X,-1,0,0,c,0,I),Y&&I.multiplyToRef(d,I),I._updateIdentityStatus(!1),I}static PerspectiveFovReverseRHToRef(k,h,o,x,I){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const G=1/Math.tan(.5*k),l=q?G/h:G,A=q?G:G*h,K=Math.tan(J);return M.FromValuesToRef(l,0,0,0,0,A,0,K,0,0,-o,-1,0,0,-1,0,I),Y&&I.multiplyToRef(d,I),I._updateIdentityStatus(!1),I}static GetFinalMatrix(k,h,o,x,I,q){const Y=k.width,J=k.height,G=k.x,l=k.y,A=M.FromValues(Y/2,0,0,0,0,-J/2,0,0,0,0,q-I,0,G+Y/2,J/2+l,I,1),K=new M;return h.multiplyToRef(o,K),K.multiplyToRef(x,K),K.multiplyToRef(A,K)}static GetAsMatrix2x2(k){const h=k.m,o=[h[0],h[1],h[4],h[5]];return Y.e.MatrixUse64Bits?o:new Float32Array(o)}static GetAsMatrix3x3(k){const h=k.m,o=[h[0],h[1],h[2],h[4],h[5],h[6],h[8],h[9],h[10]];return Y.e.MatrixUse64Bits?o:new Float32Array(o)}static Transpose(k){const h=new M;return M.TransposeToRef(k,h),h}static TransposeToRef(k,h){const o=k.m,x=o[0],I=o[4],q=o[8],Y=o[12],J=o[1],G=o[5],l=o[9],A=o[13],K=o[2],a=o[6],N=o[10],X=o[14],c=o[3],W=o[7],f=o[11],M=o[15],T=h.wh;return T[0]=x,T[1]=I,T[2]=q,T[3]=Y,T[4]=J,T[5]=G,T[6]=l,T[7]=A,T[8]=K,T[9]=a,T[10]=N,T[11]=X,T[12]=c,T[13]=W,T[14]=f,T[15]=M,h.markAsUpdated(),h._updateIdentityStatus(k._isIdentity,k._isIdentityDirty),h}static Reflection(k){const h=new M;return M.ReflectionToRef(k,h),h}static ReflectionToRef(k,h){k.normalize();const o=k.normal.x,x=k.normal.y,I=k.normal.z,q=-2*o,Y=-2*x,J=-2*I;return M.FromValuesToRef(q*o+1,Y*o,J*o,0,q*x,Y*x+1,J*x,0,q*I,Y*I,J*I+1,0,q*k.d,Y*k.d,J*k.d,1,h),h}static FromXYZAxesToRef(k,h,o,x){return M.FromValuesToRef(k._x,k._y,k._z,0,h._x,h._y,h._z,0,o._x,o._y,o._z,0,0,0,0,1,x),x}static FromQuaternionToRef(k,h){const o=k._x*k._x,x=k._y*k._y,I=k._z*k._z,q=k._x*k._y,Y=k._z*k._w,J=k._z*k._x,G=k._y*k._w,l=k._y*k._z,A=k._x*k._w;return h.wh[0]=1-2*(x+I),h.wh[1]=2*(q+Y),h.wh[2]=2*(J-G),h.wh[3]=0,h.wh[4]=2*(q-Y),h.wh[5]=1-2*(I+o),h.wh[6]=2*(l+A),h.wh[7]=0,h.wh[8]=2*(J+G),h.wh[9]=2*(l-A),h.wh[10]=1-2*(x+o),h.wh[11]=0,h.wh[12]=0,h.wh[13]=0,h.wh[14]=0,h.wh[15]=1,h.markAsUpdated(),h}}M._IdentityReadOnly=M.Identity(),Object.defineProperties(M.prototype,{dimension:{value:[4,4]},rank:{value:2}});class T{}T.Vh=(0,I.g)(11,c.Zero),T.Matrix=(0,I.g)(2,M.Identity),T.Quaternion=(0,I.g)(3,f.Zero);class j{}j.Vector2=(0,I.g)(3,X.Zero),j.Vh=(0,I.g)(13,c.Zero),j.Vector4=(0,I.g)(3,W.Zero),j.Quaternion=(0,I.g)(3,f.Zero),j.Matrix=(0,I.g)(8,M.Identity),(0,q.g)("BABYLON.Vector2",X),(0,q.g)("BABYLON.Vector3",c),(0,q.g)("BABYLON.Vector4",W),(0,q.g)("BABYLON.Matrix",M);const d=M.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11256:(k,h,o)=>{function x(k,h){const o=[];for(let x=0;x<k;++x)o.push(h());return o}function I(k,h){return x(k,h)}o.d(h,{d:()=>x,g:()=>I,i:()=>Y});const q=["push","splice","pop","shift","unshift"];function Y(k,h){const o=q.map((o=>function(k,h,o){const x=k[h];if("function"!==typeof x)return null;const I=function(){const x=k.length,q=I.previous.apply(k,arguments);return o(h,x),q};return x.next=I,I.previous=x,k[h]=I,()=>{const o=I.previous;if(!o)return;const x=I.next;x?(o.next=x,x.previous=o):(o.next=void 0,k[h]=o),I.next=void 0,I.previous=void 0}}(k,o,h)));return()=>{for(const k of o)null===k||void 0===k||k()}}}}]);