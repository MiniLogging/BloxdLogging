"use strict";(self["1kjc9ee3uyt"]=self["1kjc9ee3uyt"]||[]).push([[14],{11681:(w,E,G)=>{G.d(E,{d:()=>y,f:()=>B,h:()=>P,l:()=>h});const P=1/2.2,h=2.2,B=(1+Math.sqrt(5))/2,y=.001},11689:(w,E,G)=>{function P(w){return parseInt(w.toString().replace(/\W/g,""))}function h(w,E){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(w-E)<=G}function B(w,E,G){let P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return w<E-P||w>G+P}function y(w,E){return w===E?w:Math.random()*(E-w)+w}function x(w,E,G){return w+(E-w)*G}function U(w,E,G){let P=c(E-w,360);return P>180&&(P-=360),w+P*u(G)}function l(w,E,G){let P=0;return P=w!=E?u((G-w)/(E-w)):0,P}function i(w,E,G,P,h){const B=h*h,y=h*B;return w*(2*y-3*B+1)+G*(-2*y+3*B)+E*(y-2*B+h)+P*(y-B)}function O(w,E,G,P,h){const B=h*h;return 6*(B-h)*w+(3*B-4*h+1)*E+6*(-B+h)*G+(3*B-2*h)*P}function u(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(G,Math.max(E,w))}function V(w){return w-=2*Math.PI*Math.floor((w+Math.PI)/(2*Math.PI))}function a(w){const E=w.toString(16);return w<=15?("0"+E).toUpperCase():E.toUpperCase()}function Q(w){if(Math.log2)return Math.floor(Math.log2(w));if(w<0)return NaN;if(0===w)return-1/0;let E=0;if(w<1){for(;w<1;)E++,w*=2;E=-E}else if(w>1)for(;w>1;)E++,w=Math.floor(w/2);return E}function c(w,E){return w-Math.floor(w/E)*E}function Z(w,E,G){return(w-E)/(G-E)}function J(w,E,G){return w*(G-E)+E}function d(w,E){let G=c(E-w,360);return G>180&&(G-=360),G}function K(w,E){const G=c(w,2*E);return E-Math.abs(G-E)}function t(w,E,G){let P=u(G);return P=-2*P*P*P+3*P*P,E*P+w*(1-P)}function q(w,E,G){let P=0;return P=Math.abs(E-w)<=G?E:w+Math.sign(E-w)*G,P}function W(w,E,G){const P=d(w,E);let h=0;return h=-G<P&&P<G?E:q(w,E=w+P,G),h}function T(w,E,G){return(w-E)/(G-E)}function I(w,E,G){return(G-E)*w+E}function j(w,E){const G=w%E;return 0===G?E:j(E,G)}G.r(E),G.d(E,{Clamp:()=>u,DeltaAngle:()=>d,Denormalize:()=>J,ExtractAsInt:()=>P,Hermite:()=>i,Hermite1stDerivative:()=>O,HighestCommonFactor:()=>j,ILog2:()=>Q,InverseLerp:()=>l,Lerp:()=>x,LerpAngle:()=>U,MoveTowards:()=>q,MoveTowardsAngle:()=>W,Normalize:()=>Z,NormalizeRadians:()=>V,OutsideRange:()=>B,PercentToRange:()=>I,PingPong:()=>K,RandomRange:()=>y,RangeToPercent:()=>T,Repeat:()=>c,SmoothStep:()=>t,ToHex:()=>a,WithinEpsilon:()=>h})},11679:(w,E,G)=>{G.r(E),G.d(E,{Matrix:()=>J,Quaternion:()=>Z,TmpVectors:()=>K,Vector2:()=>a,QE:()=>Q,Vector4:()=>c});var P=G(11681),h=G(11684),B=G(11646),y=G(11618),x=G(11543),U=G(11689);class l{}function i(w,E,G){let P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const h=w.Lh(),B=E.Lh(),y=h[0],x=h[1],U=h[2],l=h[3],i=h[4],O=h[5],u=h[6],V=h[7],a=h[8],Q=h[9],c=h[10],Z=h[11],J=h[12],d=h[13],K=h[14],t=h[15],q=B[0],W=B[1],T=B[2],I=B[3],j=B[4],g=B[5],o=B[6],f=B[7],k=B[8],N=B[9],v=B[10],C=B[11],s=B[12],F=B[13],M=B[14],p=B[15];G[P]=y*q+x*j+U*k+l*s,G[P+1]=y*W+x*g+U*N+l*F,G[P+2]=y*T+x*o+U*v+l*M,G[P+3]=y*I+x*f+U*C+l*p,G[P+4]=i*q+O*j+u*k+V*s,G[P+5]=i*W+O*g+u*N+V*F,G[P+6]=i*T+O*o+u*v+V*M,G[P+7]=i*I+O*f+u*C+V*p,G[P+8]=a*q+Q*j+c*k+Z*s,G[P+9]=a*W+Q*g+c*N+Z*F,G[P+10]=a*T+Q*o+c*v+Z*M,G[P+11]=a*I+Q*f+c*C+Z*p,G[P+12]=J*q+d*j+K*k+t*s,G[P+13]=J*W+d*g+K*N+t*F,G[P+14]=J*T+d*o+K*v+t*M,G[P+15]=J*I+d*f+K*C+t*p}function O(w,E){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const P=w.Lh();E[G]=P[0],E[G+1]=P[1],E[G+2]=P[2],E[G+3]=P[3],E[G+4]=P[4],E[G+5]=P[5],E[G+6]=P[6],E[G+7]=P[7],E[G+8]=P[8],E[G+9]=P[9],E[G+10]=P[10],E[G+11]=P[11],E[G+12]=P[12],E[G+13]=P[13],E[G+14]=P[14],E[G+15]=P[15]}function u(w,E){const G=w.Lh(),P=G[0],h=G[1],B=G[2],y=G[3],x=G[4],U=G[5],l=G[6],i=G[7],O=G[8],u=G[9],V=G[10],a=G[11],Q=G[12],c=G[13],Z=G[14],J=G[15],d=V*J-Z*a,K=u*J-c*a,t=u*Z-c*V,q=O*J-Q*a,W=O*Z-V*Q,T=O*c-Q*u,I=+(U*d-l*K+i*t),j=-(x*d-l*q+i*W),g=+(x*K-U*q+i*T),o=-(x*t-U*W+l*T),f=P*I+h*j+B*g+y*o;if(0===f)return!1;const k=1/f,N=l*J-Z*i,v=U*J-c*i,C=U*Z-c*l,s=x*J-Q*i,F=x*Z-Q*l,M=x*c-Q*U,p=l*a-V*i,D=U*a-u*i,e=U*V-u*l,R=x*a-O*i,H=x*V-O*l,z=x*u-O*U,L=-(h*d-B*K+y*t),m=+(P*d-B*q+y*W),n=-(P*K-h*q+y*T),r=+(P*t-h*W+B*T),Y=+(h*N-B*v+y*C),S=-(P*N-B*s+y*F),X=+(P*v-h*s+y*M),b=-(P*C-h*F+B*M),A=-(h*p-B*D+y*e),ww=+(P*p-B*R+y*H),Ew=-(P*D-h*R+y*z),Gw=+(P*e-h*H+B*z);return E[0]=I*k,E[1]=L*k,E[2]=Y*k,E[3]=A*k,E[4]=j*k,E[5]=m*k,E[6]=S*k,E[7]=ww*k,E[8]=g*k,E[9]=n*k,E[10]=X*k,E[11]=Ew*k,E[12]=o*k,E[13]=r*k,E[14]=b*k,E[15]=Gw*k,!0}l._UpdateFlagSeed=0;const V=w=>parseInt(w.toString().replace(/\W/g,""));class a{constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=w,this.y=E}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let w=V(this.x);return w=397*w^V(this.y),w}toArray(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w[E]=this.x,w[E+1]=this.y,this}VG(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return a.FromArrayToRef(w,E,this),this}Lh(){return[this.x,this.y]}B(w){return this.x=w.x,this.y=w.y,this}tx(w,E){return this.x=w,this.y=E,this}set(w,E){return this.tx(w,E)}Wx(w){return this.tx(w,w)}add(w){return new a(this.x+w.x,this.y+w.y)}addToRef(w,E){return E.x=this.x+w.x,E.y=this.y+w.y,E}addInPlace(w){return this.x+=w.x,this.y+=w.y,this}addInPlaceFromFloats(w,E){return this.x+=w,this.y+=E,this}addVector3(w){return new a(this.x+w.x,this.y+w.y)}cE(w){return new a(this.x-w.x,this.y-w.y)}subtractToRef(w,E){return E.x=this.x-w.x,E.y=this.y-w.y,E}xO(w){return this.x-=w.x,this.y-=w.y,this}multiplyInPlace(w){return this.x*=w.x,this.y*=w.y,this}multiply(w){return new a(this.x*w.x,this.y*w.y)}multiplyToRef(w,E){return E.x=this.x*w.x,E.y=this.y*w.y,E}multiplyByFloats(w,E){return new a(this.x*w,this.y*E)}divide(w){return new a(this.x/w.x,this.y/w.y)}divideToRef(w,E){return E.x=this.x/w.x,E.y=this.y/w.y,E}divideInPlace(w){return this.x=this.x/w.x,this.y=this.y/w.y,this}minimizeInPlace(w){return this.minimizeInPlaceFromFloats(w.x,w.y)}maximizeInPlace(w){return this.maximizeInPlaceFromFloats(w.x,w.y)}minimizeInPlaceFromFloats(w,E){return this.x=Math.min(w,this.x),this.y=Math.min(E,this.y),this}maximizeInPlaceFromFloats(w,E){return this.x=Math.max(w,this.x),this.y=Math.max(E,this.y),this}subtractFromFloats(w,E){return new a(this.x-w,this.y-E)}subtractFromFloatsToRef(w,E,G){return G.x=this.x-w,G.y=this.y-E,G}negate(){return new a(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(w){return w.x=-this.x,w.y=-this.y,w}scaleInPlace(w){return this.x*=w,this.y*=w,this}scale(w){return new a(this.x*w,this.y*w)}scaleToRef(w,E){return E.x=this.x*w,E.y=this.y*w,E}scaleAndAddToRef(w,E){return E.x+=this.x*w,E.y+=this.y*w,E}equals(w){return w&&this.x===w.x&&this.y===w.y}equalsWithEpsilon(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:P.d;return w&&(0,U.WithinEpsilon)(this.x,w.x,E)&&(0,U.WithinEpsilon)(this.y,w.y,E)}equalsToFloats(w,E){return this.x===w&&this.y===E}floor(){return new a(Math.floor(this.x),Math.floor(this.y))}floorToRef(w){return w.x=Math.floor(this.x),w.y=Math.floor(this.y),w}fract(){return new a(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(w){return w.x=this.x-Math.floor(this.x),w.y=this.y-Math.floor(this.y),w}rotate(w){return this.rotateToRef(w,new a)}rotateToRef(w,E){const G=Math.cos(w),P=Math.sin(w);return E.x=G*this.x-P*this.y,E.y=P*this.x+G*this.y,E}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(w){return 0===w||1===w?this:this.scaleInPlace(1/w)}normalizeToNew(){const w=new a;return this.normalizeToRef(w),w}normalizeToRef(w){const E=this.length();return 0===E&&(w.x=this.x,w.y=this.y),this.scaleToRef(1/E,w)}clone(){return new a(this.x,this.y)}dot(w){return this.x*w.x+this.y*w.y}static Zero(){return new a(0,0)}static One(){return new a(1,1)}static Random(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new a((0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E))}static RandomToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).tx((0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E))}static get ZeroReadOnly(){return a._ZeroReadOnly}static KE(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new a(w[E],w[E+1])}static FromArrayToRef(w,E,G){return G.x=w[E],G.y=w[E+1],G}static FromFloatsToRef(w,E,G){return G.tx(w,E),G}static CatmullRom(w,E,G,P,h){const B=h*h,y=h*B,x=.5*(2*E.x+(-w.x+G.x)*h+(2*w.x-5*E.x+4*G.x-P.x)*B+(-w.x+3*E.x-3*G.x+P.x)*y),U=.5*(2*E.y+(-w.y+G.y)*h+(2*w.y-5*E.y+4*G.y-P.y)*B+(-w.y+3*E.y-3*G.y+P.y)*y);return new a(x,U)}static ClampToRef(w,E,G,P){return P.x=(0,U.Clamp)(w.x,E.x,G.x),P.y=(0,U.Clamp)(w.y,E.y,G.y),P}static Clamp(w,E,G){const P=(0,U.Clamp)(w.x,E.x,G.x),h=(0,U.Clamp)(w.y,E.y,G.y);return new a(P,h)}static Hermite(w,E,G,P,h){const B=h*h,y=h*B,x=2*y-3*B+1,U=-2*y+3*B,l=y-2*B+h,i=y-B,O=w.x*x+G.x*U+E.x*l+P.x*i,u=w.y*x+G.y*U+E.y*l+P.y*i;return new a(O,u)}static Hermite1stDerivative(w,E,G,P,h){return this.Hermite1stDerivativeToRef(w,E,G,P,h,new a)}static Hermite1stDerivativeToRef(w,E,G,P,h,B){const y=h*h;return B.x=6*(y-h)*w.x+(3*y-4*h+1)*E.x+6*(-y+h)*G.x+(3*y-2*h)*P.x,B.y=6*(y-h)*w.y+(3*y-4*h+1)*E.y+6*(-y+h)*G.y+(3*y-2*h)*P.y,B}static Lerp(w,E,G){return a.LerpToRef(w,E,G,new a)}static LerpToRef(w,E,G,P){return P.x=w.x+(E.x-w.x)*G,P.y=w.y+(E.y-w.y)*G,P}static Dot(w,E){return w.x*E.x+w.y*E.y}static Normalize(w){return a.NormalizeToRef(w,new a)}static NormalizeToRef(w,E){return w.normalizeToRef(E),E}static Minimize(w,E){const G=w.x<E.x?w.x:E.x,P=w.y<E.y?w.y:E.y;return new a(G,P)}static Maximize(w,E){const G=w.x>E.x?w.x:E.x,P=w.y>E.y?w.y:E.y;return new a(G,P)}static Transform(w,E){return a.TransformToRef(w,E,new a)}static TransformToRef(w,E,G){const P=E.m,h=w.x*P[0]+w.y*P[4]+P[12],B=w.x*P[1]+w.y*P[5]+P[13];return G.x=h,G.y=B,G}static PointInTriangle(w,E,G,P){const h=.5*(-G.y*P.x+E.y*(-G.x+P.x)+E.x*(G.y-P.y)+G.x*P.y),B=h<0?-1:1,y=(E.y*P.x-E.x*P.y+(P.y-E.y)*w.x+(E.x-P.x)*w.y)*B,x=(E.x*G.y-E.y*G.x+(E.y-G.y)*w.x+(G.x-E.x)*w.y)*B;return y>0&&x>0&&y+x<2*h*B}static Distance(w,E){return Math.sqrt(a.DistanceSquared(w,E))}static DistanceSquared(w,E){const G=w.x-E.x,P=w.y-E.y;return G*G+P*P}static Center(w,E){return a.CenterToRef(w,E,new a)}static CenterToRef(w,E,G){return G.tx((w.x+E.x)/2,(w.y+E.y)/2)}static DistanceOfPointFromSegment(w,E,G){const P=a.DistanceSquared(E,G);if(0===P)return a.Distance(w,E);const h=G.cE(E),B=Math.max(0,Math.min(1,a.Dot(w.cE(E),h)/P)),y=E.add(h.multiplyByFloats(B,B));return a.Distance(w,y)}}a._V8PerformanceHack=new a(.5,.5),a._ZeroReadOnly=a.Zero(),Object.defineProperties(a.prototype,{dimension:{value:[2]},rank:{value:1}});class Q{get x(){return this._x}set x(w){this._x=w,this._isDirty=!0}get y(){return this._y}set y(w){this._y=w,this._isDirty=!0}get z(){return this._z}set z(w){this._z=w,this._isDirty=!0}constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=w,this._y=E,this._z=G}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"QE"}getHashCode(){let w=V(this._x);return w=397*w^V(this._y),w=397*w^V(this._z),w}Lh(){return[this._x,this._y,this._z]}toArray(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w[E]=this._x,w[E+1]=this._y,w[E+2]=this._z,this}VG(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(w,E,this),this}toQuaternion(){return Z.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(w){return this._x+=w._x,this._y+=w._y,this._z+=w._z,this._isDirty=!0,this}addInPlaceFromFloats(w,E,G){return this._x+=w,this._y+=E,this._z+=G,this._isDirty=!0,this}add(w){return new Q(this._x+w._x,this._y+w._y,this._z+w._z)}addToRef(w,E){return E._x=this._x+w._x,E._y=this._y+w._y,E._z=this._z+w._z,E._isDirty=!0,E}xO(w){return this._x-=w._x,this._y-=w._y,this._z-=w._z,this._isDirty=!0,this}cE(w){return new Q(this._x-w._x,this._y-w._y,this._z-w._z)}subtractToRef(w,E){return this.subtractFromFloatsToRef(w._x,w._y,w._z,E)}subtractFromFloats(w,E,G){return new Q(this._x-w,this._y-E,this._z-G)}subtractFromFloatsToRef(w,E,G,P){return P._x=this._x-w,P._y=this._y-E,P._z=this._z-G,P._isDirty=!0,P}negate(){return new Q(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(w){return w._x=-1*this._x,w._y=-1*this._y,w._z=-1*this._z,w._isDirty=!0,w}scaleInPlace(w){return this._x*=w,this._y*=w,this._z*=w,this._isDirty=!0,this}scale(w){return new Q(this._x*w,this._y*w,this._z*w)}scaleToRef(w,E){return E._x=this._x*w,E._y=this._y*w,E._z=this._z*w,E._isDirty=!0,E}getNormalToRef(w){const E=this.length();let G=Math.acos(this._y/E);const P=Math.atan2(this._z,this._x);G>Math.PI/2?G-=Math.PI/2:G+=Math.PI/2;const h=E*Math.sin(G)*Math.cos(P),B=E*Math.cos(G),y=E*Math.sin(G)*Math.sin(P);return w.set(h,B,y),w}applyRotationQuaternionToRef(w,E){const G=this._x,P=this._y,h=this._z,B=w._x,y=w._y,x=w._z,U=w._w,l=2*(y*h-x*P),i=2*(x*G-B*h),O=2*(B*P-y*G);return E._x=G+U*l+y*O-x*i,E._y=P+U*i+x*l-B*O,E._z=h+U*O+B*i-y*l,E._isDirty=!0,E}applyRotationQuaternionInPlace(w){return this.applyRotationQuaternionToRef(w,this)}applyRotationQuaternion(w){return this.applyRotationQuaternionToRef(w,new Q)}scaleAndAddToRef(w,E){return E._x+=this._x*w,E._y+=this._y*w,E._z+=this._z*w,E._isDirty=!0,E}projectOnPlane(w,E){return this.projectOnPlaneToRef(w,E,new Q)}projectOnPlaneToRef(w,E,G){const P=w.normal,h=w.d,B=d.QE[0];this.subtractToRef(E,B),B.normalize();const y=Q.Dot(B,P);if(Math.abs(y)<1e-10)G.Wx(1/0);else{const w=-(Q.Dot(E,P)+h)/y,x=B.scaleInPlace(w);E.addToRef(x,G)}return G}equals(w){return w&&this._x===w._x&&this._y===w._y&&this._z===w._z}equalsWithEpsilon(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:P.d;return w&&(0,U.WithinEpsilon)(this._x,w._x,E)&&(0,U.WithinEpsilon)(this._y,w._y,E)&&(0,U.WithinEpsilon)(this._z,w._z,E)}equalsToFloats(w,E,G){return this._x===w&&this._y===E&&this._z===G}multiplyInPlace(w){return this._x*=w._x,this._y*=w._y,this._z*=w._z,this._isDirty=!0,this}multiply(w){return this.multiplyByFloats(w._x,w._y,w._z)}multiplyToRef(w,E){return E._x=this._x*w._x,E._y=this._y*w._y,E._z=this._z*w._z,E._isDirty=!0,E}multiplyByFloats(w,E,G){return new Q(this._x*w,this._y*E,this._z*G)}divide(w){return new Q(this._x/w._x,this._y/w._y,this._z/w._z)}divideToRef(w,E){return E._x=this._x/w._x,E._y=this._y/w._y,E._z=this._z/w._z,E._isDirty=!0,E}divideInPlace(w){return this._x=this._x/w._x,this._y=this._y/w._y,this._z=this._z/w._z,this._isDirty=!0,this}minimizeInPlace(w){return this.minimizeInPlaceFromFloats(w._x,w._y,w._z)}maximizeInPlace(w){return this.maximizeInPlaceFromFloats(w._x,w._y,w._z)}minimizeInPlaceFromFloats(w,E,G){return w<this._x&&(this.x=w),E<this._y&&(this.y=E),G<this._z&&(this.z=G),this}maximizeInPlaceFromFloats(w,E,G){return w>this._x&&(this.x=w),E>this._y&&(this.y=E),G>this._z&&(this.z=G),this}isNonUniformWithinEpsilon(w){const E=Math.abs(this._x),G=Math.abs(this._y);if(!(0,U.WithinEpsilon)(E,G,w))return!0;const P=Math.abs(this._z);return!(0,U.WithinEpsilon)(E,P,w)||!(0,U.WithinEpsilon)(G,P,w)}get isNonUniform(){const w=Math.abs(this._x);if(w!==Math.abs(this._y))return!0;return w!==Math.abs(this._z)}floorToRef(w){return w._x=Math.floor(this._x),w._y=Math.floor(this._y),w._z=Math.floor(this._z),w._isDirty=!0,w}floor(){return new Q(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(w){return w._x=this._x-Math.floor(this._x),w._y=this._y-Math.floor(this._y),w._z=this._z-Math.floor(this._z),w._isDirty=!0,w}fract(){return new Q(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(w){if("xyz"===(w=w.toLowerCase()))return this;const E=d.QE[0].B(this);return this.x=E[w[0]],this.y=E[w[1]],this.z=E[w[2]],this}rotateByQuaternionToRef(w,E){return w.toRotationMatrix(d.Matrix[0]),Q.TransformCoordinatesToRef(this,d.Matrix[0],E),E}rotateByQuaternionAroundPointToRef(w,E,G){return this.subtractToRef(E,d.QE[0]),d.QE[0].rotateByQuaternionToRef(w,d.QE[0]),E.addToRef(d.QE[0],G),G}cross(w){return Q.CrossToRef(this,w,new Q)}normalizeFromLength(w){return 0===w||1===w?this:this.scaleInPlace(1/w)}normalizeToNew(){return this.normalizeToRef(new Q)}normalizeToRef(w){const E=this.length();return 0===E||1===E?(w._x=this._x,w._y=this._y,w._z=this._z,w._isDirty=!0,w):this.scaleToRef(1/E,w)}clone(){return new Q(this._x,this._y,this._z)}B(w){return this.tx(w._x,w._y,w._z)}tx(w,E,G){return this._x=w,this._y=E,this._z=G,this._isDirty=!0,this}set(w,E,G){return this.tx(w,E,G)}Wx(w){return this._x=this._y=this._z=w,this._isDirty=!0,this}static GetClipFactor(w,E,G,P){const h=Q.Dot(w,G);return(h-P)/(h-Q.Dot(E,G))}static GetAngleBetweenVectors(w,E,G){const P=w.normalizeToRef(d.QE[1]),h=E.normalizeToRef(d.QE[2]);let B=Q.Dot(P,h);B=(0,U.Clamp)(B,-1,1);const y=Math.acos(B),x=d.QE[3];return Q.CrossToRef(P,h,x),Q.Dot(x,G)>0?isNaN(y)?0:y:isNaN(y)?-Math.PI:-Math.acos(B)}static GetAngleBetweenVectorsOnPlane(w,E,G){d.QE[0].B(w);const P=d.QE[0];d.QE[1].B(E);const h=d.QE[1];d.QE[2].B(G);const B=d.QE[2],y=d.QE[3],x=d.QE[4];P.normalize(),h.normalize(),B.normalize(),Q.CrossToRef(B,P,y),Q.CrossToRef(y,B,x);const l=Math.atan2(Q.Dot(h,y),Q.Dot(h,x));return(0,U.NormalizeRadians)(l)}static PitchYawRollToMoveBetweenPointsToRef(w,E,G){const P=K.QE[0];return E.subtractToRef(w,P),G._y=Math.atan2(P.x,P.z)||0,G._x=Math.atan2(Math.sqrt(P.x**2+P.z**2),P.y)||0,G._z=0,G._isDirty=!0,G}static PitchYawRollToMoveBetweenPoints(w,E){const G=Q.Zero();return Q.PitchYawRollToMoveBetweenPointsToRef(w,E,G)}static SlerpToRef(w,E,G,h){G=(0,U.Clamp)(G,0,1);const B=d.QE[0],y=d.QE[1];B.B(w);const x=B.length();B.normalizeFromLength(x),y.B(E);const l=y.length();y.normalizeFromLength(l);const i=Q.Dot(B,y);let O,u;if(i<1-P.d){const w=Math.acos(i),E=1/Math.sin(w);O=Math.sin((1-G)*w)*E,u=Math.sin(G*w)*E}else O=1-G,u=G;return B.scaleInPlace(O),y.scaleInPlace(u),h.B(B).addInPlace(y),h.scaleInPlace((0,U.Lerp)(x,l,G)),h}static SmoothToRef(w,E,G,P,h){return Q.SlerpToRef(w,E,0===P?1:G/P,h),h}static KE(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(w[E],w[E+1],w[E+2])}static FromFloatArray(w,E){return Q.KE(w,E)}static FromArrayToRef(w,E,G){return G._x=w[E],G._y=w[E+1],G._z=w[E+2],G._isDirty=!0,G}static FromFloatArrayToRef(w,E,G){return Q.FromArrayToRef(w,E,G)}static FromFloatsToRef(w,E,G,P){return P.tx(w,E,G),P}static Zero(){return new Q(0,0,0)}static One(){return new Q(1,1,1)}static Up(){return new Q(0,1,0)}static get UpReadOnly(){return Q._UpReadOnly}static get DownReadOnly(){return Q._DownReadOnly}static get RightReadOnly(){return Q._RightReadOnly}static get LeftReadOnly(){return Q._LeftReadOnly}static get LeftHandedForwardReadOnly(){return Q._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return Q._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return Q._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return Q._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return Q._ZeroReadOnly}static get OneReadOnly(){return Q._OneReadOnly}static Down(){return new Q(0,-1,0)}static Forward(){return new Q(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new Q(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new Q(1,0,0)}static Left(){return new Q(-1,0,0)}static Random(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Q((0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E))}static RandomToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).tx((0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E))}static TransformCoordinates(w,E){const G=Q.Zero();return Q.TransformCoordinatesToRef(w,E,G),G}static TransformCoordinatesToRef(w,E,G){return Q.TransformCoordinatesFromFloatsToRef(w._x,w._y,w._z,E,G),G}static TransformCoordinatesFromFloatsToRef(w,E,G,P,h){const B=P.m,y=w*B[0]+E*B[4]+G*B[8]+B[12],x=w*B[1]+E*B[5]+G*B[9]+B[13],U=w*B[2]+E*B[6]+G*B[10]+B[14],l=1/(w*B[3]+E*B[7]+G*B[11]+B[15]);return h._x=y*l,h._y=x*l,h._z=U*l,h._isDirty=!0,h}static TransformNormal(w,E){const G=Q.Zero();return Q.TransformNormalToRef(w,E,G),G}static TransformNormalToRef(w,E,G){return this.TransformNormalFromFloatsToRef(w._x,w._y,w._z,E,G),G}static TransformNormalFromFloatsToRef(w,E,G,P,h){const B=P.m;return h._x=w*B[0]+E*B[4]+G*B[8],h._y=w*B[1]+E*B[5]+G*B[9],h._z=w*B[2]+E*B[6]+G*B[10],h._isDirty=!0,h}static CatmullRom(w,E,G,P,h){const B=h*h,y=h*B,x=.5*(2*E._x+(-w._x+G._x)*h+(2*w._x-5*E._x+4*G._x-P._x)*B+(-w._x+3*E._x-3*G._x+P._x)*y),U=.5*(2*E._y+(-w._y+G._y)*h+(2*w._y-5*E._y+4*G._y-P._y)*B+(-w._y+3*E._y-3*G._y+P._y)*y),l=.5*(2*E._z+(-w._z+G._z)*h+(2*w._z-5*E._z+4*G._z-P._z)*B+(-w._z+3*E._z-3*G._z+P._z)*y);return new Q(x,U,l)}static Clamp(w,E,G){const P=new Q;return Q.ClampToRef(w,E,G,P),P}static ClampToRef(w,E,G,P){let h=w._x;h=h>G._x?G._x:h,h=h<E._x?E._x:h;let B=w._y;B=B>G._y?G._y:B,B=B<E._y?E._y:B;let y=w._z;return y=y>G._z?G._z:y,y=y<E._z?E._z:y,P.tx(h,B,y),P}static CheckExtends(w,E,G){E.minimizeInPlace(w),G.maximizeInPlace(w)}static Hermite(w,E,G,P,h){const B=h*h,y=h*B,x=2*y-3*B+1,U=-2*y+3*B,l=y-2*B+h,i=y-B,O=w._x*x+G._x*U+E._x*l+P._x*i,u=w._y*x+G._y*U+E._y*l+P._y*i,V=w._z*x+G._z*U+E._z*l+P._z*i;return new Q(O,u,V)}static Hermite1stDerivative(w,E,G,P,h){const B=new Q;return this.Hermite1stDerivativeToRef(w,E,G,P,h,B),B}static Hermite1stDerivativeToRef(w,E,G,P,h,B){const y=h*h;return B._x=6*(y-h)*w._x+(3*y-4*h+1)*E._x+6*(-y+h)*G._x+(3*y-2*h)*P._x,B._y=6*(y-h)*w._y+(3*y-4*h+1)*E._y+6*(-y+h)*G._y+(3*y-2*h)*P._y,B._z=6*(y-h)*w._z+(3*y-4*h+1)*E._z+6*(-y+h)*G._z+(3*y-2*h)*P._z,B._isDirty=!0,B}static Lerp(w,E,G){const P=new Q(0,0,0);return Q.LerpToRef(w,E,G,P),P}static LerpToRef(w,E,G,P){return P._x=w._x+(E._x-w._x)*G,P._y=w._y+(E._y-w._y)*G,P._z=w._z+(E._z-w._z)*G,P._isDirty=!0,P}static Dot(w,E){return w._x*E._x+w._y*E._y+w._z*E._z}dot(w){return this._x*w._x+this._y*w._y+this._z*w._z}static Cross(w,E){const G=new Q;return Q.CrossToRef(w,E,G),G}static CrossToRef(w,E,G){const P=w._y*E._z-w._z*E._y,h=w._z*E._x-w._x*E._z,B=w._x*E._y-w._y*E._x;return G.tx(P,h,B),G}static Normalize(w){const E=Q.Zero();return Q.NormalizeToRef(w,E),E}static NormalizeToRef(w,E){return w.normalizeToRef(E),E}static Project(w,E,G,P){const h=new Q;return Q.ProjectToRef(w,E,G,P,h),h}static ProjectToRef(w,E,G,P,h){var B;const y=P.width,U=P.height,l=P.x,i=P.y,O=d.Matrix[1],u=null===(B=x.e.LastCreatedEngine)||void 0===B?void 0:B.isNDCHalfZRange,V=u?1:.5,a=u?0:.5;J.FromValuesToRef(y/2,0,0,0,0,-U/2,0,0,0,0,V,0,l+y/2,U/2+i,a,1,O);const c=d.Matrix[0];return E.multiplyToRef(G,c),c.multiplyToRef(O,c),Q.TransformCoordinatesToRef(w,c,h),h}static Reflect(w,E){return this.ReflectToRef(w,E,new Q)}static ReflectToRef(w,E,G){const P=K.QE[0];return P.B(E).scaleInPlace(2*Q.Dot(w,E)),G.B(w).xO(P)}static _UnprojectFromInvertedMatrixToRef(w,E,G){Q.TransformCoordinatesToRef(w,E,G);const P=E.m,h=w._x*P[3]+w._y*P[7]+w._z*P[11]+P[15];return(0,U.WithinEpsilon)(h,1)&&G.scaleInPlace(1/h),G}static UnprojectFromTransform(w,E,G,P,h){return this.Unproject(w,E,G,P,h,J.IdentityReadOnly)}static Unproject(w,E,G,P,h,B){const y=new Q;return Q.UnprojectToRef(w,E,G,P,h,B,y),y}static UnprojectToRef(w,E,G,P,h,B,y){return Q.UnprojectFloatsToRef(w._x,w._y,w._z,E,G,P,h,B,y),y}static UnprojectFloatsToRef(w,E,G,P,h,B,y,U,l){var i;const O=d.Matrix[0];B.multiplyToRef(y,O),O.multiplyToRef(U,O),O.invert();const u=d.QE[0];return u.x=w/P*2-1,u.y=-(E/h*2-1),null!==(i=x.e.LastCreatedEngine)&&void 0!==i&&i.isNDCHalfZRange?u.z=G:u.z=2*G-1,Q._UnprojectFromInvertedMatrixToRef(u,O,l),l}static Minimize(w,E){const G=new Q;return G.B(w),G.minimizeInPlace(E),G}static Maximize(w,E){const G=new Q;return G.B(w),G.maximizeInPlace(E),G}static Distance(w,E){return Math.sqrt(Q.DistanceSquared(w,E))}static DistanceSquared(w,E){const G=w._x-E._x,P=w._y-E._y,h=w._z-E._z;return G*G+P*P+h*h}static ProjectOnTriangleToRef(w,E,G,h,B){const y=d.QE[0],x=d.QE[1],l=d.QE[2],i=d.QE[3],O=d.QE[4];G.subtractToRef(E,y),h.subtractToRef(E,x),h.subtractToRef(G,l);const u=y.length(),V=x.length(),a=l.length();if(u<P.d||V<P.d||a<P.d)return B.B(E),Q.Distance(w,E);w.subtractToRef(E,O),Q.CrossToRef(y,x,i);const c=i.length();if(c<P.d)return B.B(E),Q.Distance(w,E);i.normalizeFromLength(c);let Z=O.length();if(Z<P.d)return B.B(E),0;O.normalizeFromLength(Z);const J=Q.Dot(i,O),K=d.QE[5],t=d.QE[6];K.B(i).scaleInPlace(-Z*J),t.B(w).addInPlace(K);const q=d.QE[4],W=d.QE[5],T=d.QE[7],I=d.QE[8];q.B(y).scaleInPlace(1/u),I.B(x).scaleInPlace(1/V),q.addInPlace(I).scaleInPlace(-1),W.B(y).scaleInPlace(-1/u),I.B(l).scaleInPlace(1/a),W.addInPlace(I).scaleInPlace(-1),T.B(l).scaleInPlace(-1/a),I.B(x).scaleInPlace(-1/V),T.addInPlace(I).scaleInPlace(-1);const j=d.QE[9];let g;j.B(t).xO(E),Q.CrossToRef(q,j,I),g=Q.Dot(I,i);const o=g;j.B(t).xO(G),Q.CrossToRef(W,j,I),g=Q.Dot(I,i);const f=g;j.B(t).xO(h),Q.CrossToRef(T,j,I),g=Q.Dot(I,i);const k=g,N=d.QE[10];let v,C;o>0&&f<0?(N.B(y),v=E,C=G):f>0&&k<0?(N.B(l),v=G,C=h):(N.B(x).scaleInPlace(-1),v=h,C=E);const s=d.QE[9],F=d.QE[4];v.subtractToRef(t,I),C.subtractToRef(t,s),Q.CrossToRef(I,s,F);if(!(Q.Dot(F,i)<0))return B.B(t),Math.abs(Z*J);const M=d.QE[5];Q.CrossToRef(N,F,M),M.normalize();const p=d.QE[9];p.B(v).xO(t);const D=p.length();if(D<P.d)return B.B(v),Q.Distance(w,v);p.normalizeFromLength(D);const e=Q.Dot(M,p),R=d.QE[7];R.B(t).addInPlace(M.scaleInPlace(D*e)),I.B(R).xO(v),Z=N.length(),N.normalizeFromLength(Z);let H=Q.Dot(I,N)/Math.max(Z,P.d);return H=(0,U.Clamp)(H,0,1),R.B(v).addInPlace(N.scaleInPlace(H*Z)),B.B(R),Q.Distance(w,R)}static Center(w,E){return Q.CenterToRef(w,E,Q.Zero())}static CenterToRef(w,E,G){return G.tx((w._x+E._x)/2,(w._y+E._y)/2,(w._z+E._z)/2)}static RotationFromAxis(w,E,G){const P=new Q;return Q.RotationFromAxisToRef(w,E,G,P),P}static RotationFromAxisToRef(w,E,G,P){const h=d.Quaternion[0];return Z.RotationQuaternionFromAxisToRef(w,E,G,h),h.toEulerAnglesToRef(P),P}}Q._V8PerformanceHack=new Q(.5,.5,.5),Q._UpReadOnly=Q.Up(),Q._DownReadOnly=Q.Down(),Q._LeftHandedForwardReadOnly=Q.Forward(!1),Q._RightHandedForwardReadOnly=Q.Forward(!0),Q._LeftHandedBackwardReadOnly=Q.Backward(!1),Q._RightHandedBackwardReadOnly=Q.Backward(!0),Q._RightReadOnly=Q.Right(),Q._LeftReadOnly=Q.Left(),Q._ZeroReadOnly=Q.Zero(),Q._OneReadOnly=Q.One(),Object.defineProperties(Q.prototype,{dimension:{value:[3]},rank:{value:1}});class c{get x(){return this._x}set x(w){this._x=w,this._isDirty=!0}get y(){return this._y}set y(w){this._y=w,this._isDirty=!0}get z(){return this._z}set z(w){this._z=w,this._isDirty=!0}get w(){return this._w}set w(w){this._w=w,this._isDirty=!0}constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=w,this._y=E,this._z=G,this._w=P}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let w=V(this._x);return w=397*w^V(this._y),w=397*w^V(this._z),w=397*w^V(this._w),w}Lh(){return[this._x,this._y,this._z,this._w]}toArray(w,E){return void 0===E&&(E=0),w[E]=this._x,w[E+1]=this._y,w[E+2]=this._z,w[E+3]=this._w,this}VG(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c.FromArrayToRef(w,E,this),this}addInPlace(w){return this.x+=w._x,this.y+=w._y,this.z+=w._z,this.w+=w._w,this}addInPlaceFromFloats(w,E,G,P){return this.x+=w,this.y+=E,this.z+=G,this.w+=P,this}add(w){return new c(this._x+w.x,this._y+w.y,this._z+w.z,this._w+w.w)}addToRef(w,E){return E.x=this._x+w.x,E.y=this._y+w.y,E.z=this._z+w.z,E.w=this._w+w.w,E}xO(w){return this.x-=w.x,this.y-=w.y,this.z-=w.z,this.w-=w.w,this}cE(w){return new c(this._x-w.x,this._y-w.y,this._z-w.z,this._w-w.w)}subtractToRef(w,E){return E.x=this._x-w.x,E.y=this._y-w.y,E.z=this._z-w.z,E.w=this._w-w.w,E}subtractFromFloats(w,E,G,P){return new c(this._x-w,this._y-E,this._z-G,this._w-P)}subtractFromFloatsToRef(w,E,G,P,h){return h.x=this._x-w,h.y=this._y-E,h.z=this._z-G,h.w=this._w-P,h}negate(){return new c(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(w){return w.x=-this._x,w.y=-this._y,w.z=-this._z,w.w=-this._w,w}scaleInPlace(w){return this.x*=w,this.y*=w,this.z*=w,this.w*=w,this}scale(w){return new c(this._x*w,this._y*w,this._z*w,this._w*w)}scaleToRef(w,E){return E.x=this._x*w,E.y=this._y*w,E.z=this._z*w,E.w=this._w*w,E}scaleAndAddToRef(w,E){return E.x+=this._x*w,E.y+=this._y*w,E.z+=this._z*w,E.w+=this._w*w,E}equals(w){return w&&this._x===w.x&&this._y===w.y&&this._z===w.z&&this._w===w.w}equalsWithEpsilon(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:P.d;return w&&(0,U.WithinEpsilon)(this._x,w.x,E)&&(0,U.WithinEpsilon)(this._y,w.y,E)&&(0,U.WithinEpsilon)(this._z,w.z,E)&&(0,U.WithinEpsilon)(this._w,w.w,E)}equalsToFloats(w,E,G,P){return this._x===w&&this._y===E&&this._z===G&&this._w===P}multiplyInPlace(w){return this.x*=w.x,this.y*=w.y,this.z*=w.z,this.w*=w.w,this}multiply(w){return new c(this._x*w.x,this._y*w.y,this._z*w.z,this._w*w.w)}multiplyToRef(w,E){return E.x=this._x*w.x,E.y=this._y*w.y,E.z=this._z*w.z,E.w=this._w*w.w,E}multiplyByFloats(w,E,G,P){return new c(this._x*w,this._y*E,this._z*G,this._w*P)}divide(w){return new c(this._x/w.x,this._y/w.y,this._z/w.z,this._w/w.w)}divideToRef(w,E){return E.x=this._x/w.x,E.y=this._y/w.y,E.z=this._z/w.z,E.w=this._w/w.w,E}divideInPlace(w){return this.divideToRef(w,this)}minimizeInPlace(w){return w.x<this._x&&(this.x=w.x),w.y<this._y&&(this.y=w.y),w.z<this._z&&(this.z=w.z),w.w<this._w&&(this.w=w.w),this}maximizeInPlace(w){return w.x>this._x&&(this.x=w.x),w.y>this._y&&(this.y=w.y),w.z>this._z&&(this.z=w.z),w.w>this._w&&(this.w=w.w),this}minimizeInPlaceFromFloats(w,E,G,P){return this.x=Math.min(w,this._x),this.y=Math.min(E,this._y),this.z=Math.min(G,this._z),this.w=Math.min(P,this._w),this}maximizeInPlaceFromFloats(w,E,G,P){return this.x=Math.max(w,this._x),this.y=Math.max(E,this._y),this.z=Math.max(G,this._z),this.w=Math.max(P,this._w),this}floorToRef(w){return w.x=Math.floor(this._x),w.y=Math.floor(this._y),w.z=Math.floor(this._z),w.w=Math.floor(this._w),w}floor(){return new c(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(w){return w.x=this._x-Math.floor(this._x),w.y=this._y-Math.floor(this._y),w.z=this._z-Math.floor(this._z),w.w=this._w-Math.floor(this._w),w}fract(){return new c(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(w){return 0===w||1===w?this:this.scaleInPlace(1/w)}normalizeToNew(){return this.normalizeToRef(new c)}normalizeToRef(w){const E=this.length();return 0===E||1===E?(w.x=this._x,w.y=this._y,w.z=this._z,w.w=this._w,w):this.scaleToRef(1/E,w)}toVector3(){return new Q(this._x,this._y,this._z)}clone(){return new c(this._x,this._y,this._z,this._w)}B(w){return this.x=w.x,this.y=w.y,this.z=w.z,this.w=w.w,this}tx(w,E,G,P){return this.x=w,this.y=E,this.z=G,this.w=P,this}set(w,E,G,P){return this.tx(w,E,G,P)}Wx(w){return this.x=this.y=this.z=this.w=w,this}dot(w){return this._x*w.x+this._y*w.y+this._z*w.z+this._w*w.w}static KE(w,E){return E||(E=0),new c(w[E],w[E+1],w[E+2],w[E+3])}static FromArrayToRef(w,E,G){return G.x=w[E],G.y=w[E+1],G.z=w[E+2],G.w=w[E+3],G}static FromFloatArrayToRef(w,E,G){return c.FromArrayToRef(w,E,G),G}static FromFloatsToRef(w,E,G,P,h){return h.x=w,h.y=E,h.z=G,h.w=P,h}static Zero(){return new c(0,0,0,0)}static One(){return new c(1,1,1,1)}static Random(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new c((0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E))}static RandomToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,G=arguments.length>2?arguments[2]:void 0;return G.x=(0,U.RandomRange)(w,E),G.y=(0,U.RandomRange)(w,E),G.z=(0,U.RandomRange)(w,E),G.w=(0,U.RandomRange)(w,E),G}static Clamp(w,E,G){return c.ClampToRef(w,E,G,new c)}static ClampToRef(w,E,G,P){return P.x=(0,U.Clamp)(w.x,E.x,G.x),P.y=(0,U.Clamp)(w.y,E.y,G.y),P.z=(0,U.Clamp)(w.z,E.z,G.z),P.w=(0,U.Clamp)(w.w,E.w,G.w),P}static CheckExtends(w,E,G){E.minimizeInPlace(w),G.maximizeInPlace(w)}static get ZeroReadOnly(){return c._ZeroReadOnly}static Normalize(w){return c.NormalizeToRef(w,new c)}static NormalizeToRef(w,E){return w.normalizeToRef(E),E}static Minimize(w,E){const G=new c;return G.B(w),G.minimizeInPlace(E),G}static Maximize(w,E){const G=new c;return G.B(w),G.maximizeInPlace(E),G}static Distance(w,E){return Math.sqrt(c.DistanceSquared(w,E))}static DistanceSquared(w,E){const G=w.x-E.x,P=w.y-E.y,h=w.z-E.z,B=w.w-E.w;return G*G+P*P+h*h+B*B}static Center(w,E){return c.CenterToRef(w,E,new c)}static CenterToRef(w,E,G){return G.x=(w.x+E.x)/2,G.y=(w.y+E.y)/2,G.z=(w.z+E.z)/2,G.w=(w.w+E.w)/2,G}static TransformCoordinates(w,E){return c.TransformCoordinatesToRef(w,E,new c)}static TransformCoordinatesToRef(w,E,G){return c.TransformCoordinatesFromFloatsToRef(w._x,w._y,w._z,E,G),G}static TransformCoordinatesFromFloatsToRef(w,E,G,P,h){const B=P.m,y=w*B[0]+E*B[4]+G*B[8]+B[12],x=w*B[1]+E*B[5]+G*B[9]+B[13],U=w*B[2]+E*B[6]+G*B[10]+B[14],l=w*B[3]+E*B[7]+G*B[11]+B[15];return h.x=y,h.y=x,h.z=U,h.w=l,h}static TransformNormal(w,E){return c.TransformNormalToRef(w,E,new c)}static TransformNormalToRef(w,E,G){const P=E.m,h=w.x*P[0]+w.y*P[4]+w.z*P[8],B=w.x*P[1]+w.y*P[5]+w.z*P[9],y=w.x*P[2]+w.y*P[6]+w.z*P[10];return G.x=h,G.y=B,G.z=y,G.w=w.w,G}static TransformNormalFromFloatsToRef(w,E,G,P,h,B){const y=h.m;return B.x=w*y[0]+E*y[4]+G*y[8],B.y=w*y[1]+E*y[5]+G*y[9],B.z=w*y[2]+E*y[6]+G*y[10],B.w=P,B}static FromVector3(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new c(w._x,w._y,w._z,E)}static Dot(w,E){return w.x*E.x+w.y*E.y+w.z*E.z+w.w*E.w}}c._V8PerformanceHack=new c(.5,.5,.5,.5),c._ZeroReadOnly=c.Zero(),Object.defineProperties(c.prototype,{dimension:{value:[4]},rank:{value:1}});class Z{get x(){return this._x}set x(w){this._x=w,this._isDirty=!0}get y(){return this._y}set y(w){this._y=w,this._isDirty=!0}get z(){return this._z}set z(w){this._z=w,this._isDirty=!0}get w(){return this._w}set w(w){this._w=w,this._isDirty=!0}constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=w,this._y=E,this._z=G,this._w=P}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let w=V(this._x);return w=397*w^V(this._y),w=397*w^V(this._z),w=397*w^V(this._w),w}Lh(){return[this._x,this._y,this._z,this._w]}toArray(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w[E]=this._x,w[E+1]=this._y,w[E+2]=this._z,w[E+3]=this._w,this}VG(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z.FromArrayToRef(w,E,this)}equals(w){return w&&this._x===w._x&&this._y===w._y&&this._z===w._z&&this._w===w._w}equalsWithEpsilon(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:P.d;return w&&(0,U.WithinEpsilon)(this._x,w._x,E)&&(0,U.WithinEpsilon)(this._y,w._y,E)&&(0,U.WithinEpsilon)(this._z,w._z,E)&&(0,U.WithinEpsilon)(this._w,w._w,E)}isApprox(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:P.d;return w&&((0,U.WithinEpsilon)(this._x,w._x,E)&&(0,U.WithinEpsilon)(this._y,w._y,E)&&(0,U.WithinEpsilon)(this._z,w._z,E)&&(0,U.WithinEpsilon)(this._w,w._w,E)||(0,U.WithinEpsilon)(this._x,-w._x,E)&&(0,U.WithinEpsilon)(this._y,-w._y,E)&&(0,U.WithinEpsilon)(this._z,-w._z,E)&&(0,U.WithinEpsilon)(this._w,-w._w,E))}clone(){return new Z(this._x,this._y,this._z,this._w)}B(w){return this._x=w._x,this._y=w._y,this._z=w._z,this._w=w._w,this._isDirty=!0,this}tx(w,E,G,P){return this._x=w,this._y=E,this._z=G,this._w=P,this._isDirty=!0,this}set(w,E,G,P){return this.tx(w,E,G,P)}Wx(w){return this.tx(w,w,w,w)}add(w){return new Z(this._x+w._x,this._y+w._y,this._z+w._z,this._w+w._w)}addInPlace(w){return this._x+=w._x,this._y+=w._y,this._z+=w._z,this._w+=w._w,this._isDirty=!0,this}addToRef(w,E){return E._x=this._x+w._x,E._y=this._y+w._y,E._z=this._z+w._z,E._w=this._w+w._w,E._isDirty=!0,E}addInPlaceFromFloats(w,E,G,P){return this._x+=w,this._y+=E,this._z+=G,this._w+=P,this._isDirty=!0,this}subtractToRef(w,E){return E._x=this._x-w._x,E._y=this._y-w._y,E._z=this._z-w._z,E._w=this._w-w._w,E._isDirty=!0,E}subtractFromFloats(w,E,G,P){return this.subtractFromFloatsToRef(w,E,G,P,new Z)}subtractFromFloatsToRef(w,E,G,P,h){return h._x=this._x-w,h._y=this._y-E,h._z=this._z-G,h._w=this._w-P,h._isDirty=!0,h}cE(w){return new Z(this._x-w._x,this._y-w._y,this._z-w._z,this._w-w._w)}xO(w){return this._x-=w._x,this._y-=w._y,this._z-=w._z,this._w-=w._w,this._isDirty=!0,this}scale(w){return new Z(this._x*w,this._y*w,this._z*w,this._w*w)}scaleToRef(w,E){return E._x=this._x*w,E._y=this._y*w,E._z=this._z*w,E._w=this._w*w,E._isDirty=!0,E}scaleInPlace(w){return this._x*=w,this._y*=w,this._z*=w,this._w*=w,this._isDirty=!0,this}scaleAndAddToRef(w,E){return E._x+=this._x*w,E._y+=this._y*w,E._z+=this._z*w,E._w+=this._w*w,E._isDirty=!0,E}multiply(w){const E=new Z(0,0,0,1);return this.multiplyToRef(w,E),E}multiplyToRef(w,E){const G=this._x*w._w+this._y*w._z-this._z*w._y+this._w*w._x,P=-this._x*w._z+this._y*w._w+this._z*w._x+this._w*w._y,h=this._x*w._y-this._y*w._x+this._z*w._w+this._w*w._z,B=-this._x*w._x-this._y*w._y-this._z*w._z+this._w*w._w;return E.tx(G,P,h,B),E}multiplyInPlace(w){return this.multiplyToRef(w,this)}multiplyByFloats(w,E,G,P){return this._x*=w,this._y*=E,this._z*=G,this._w*=P,this._isDirty=!0,this}divide(w){throw new ReferenceError("Can not divide a quaternion")}divideToRef(w,E){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(w){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new Z)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(w){return w._x=-this._x,w._y=-this._y,w._z=-this._z,w._w=-this._w,w._isDirty=!0,w}equalsToFloats(w,E,G,P){return this._x===w&&this._y===E&&this._z===G&&this._w===P}floorToRef(w){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(w){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(w){return w.tx(-this._x,-this._y,-this._z,this._w),w}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new Z(-this._x,-this._y,-this._z,this._w)}invert(){const w=this.conjugate(),E=this.lengthSquared();return 0==E||1==E||w.scaleInPlace(1/E),w}invertInPlace(){this.conjugateInPlace();const w=this.lengthSquared();return 0==w||1==w||this.scaleInPlace(1/w),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(w){return 0===w||1===w?this:this.scaleInPlace(1/w)}normalizeToNew(){const w=new Z(0,0,0,1);return this.normalizeToRef(w),w}normalizeToRef(w){const E=this.length();return 0===E||1===E?w.tx(this._x,this._y,this._z,this._w):this.scaleToRef(1/E,w)}toEulerAngles(){const w=Q.Zero();return this.toEulerAnglesToRef(w),w}toEulerAnglesToRef(w){const E=this._z,G=this._x,P=this._y,h=this._w,B=P*E-G*h,y=.4999999;if(B<-y)w._y=2*Math.atan2(P,h),w._x=Math.PI/2,w._z=0,w._isDirty=!0;else if(B>y)w._y=2*Math.atan2(P,h),w._x=-Math.PI/2,w._z=0,w._isDirty=!0;else{const y=h*h,x=E*E,U=G*G,l=P*P;w._z=Math.atan2(2*(G*P+E*h),-x-U+l+y),w._x=Math.asin(-2*B),w._y=Math.atan2(2*(E*G+P*h),x-U-l+y),w._isDirty=!0}return w}toAlphaBetaGammaToRef(w){const E=this._z,G=this._x,P=this._y,h=this._w,B=Math.sqrt(G*G+P*P),y=Math.sqrt(E*E+h*h),x=2*Math.atan2(B,y),U=2*Math.atan2(E,h),l=2*Math.atan2(P,G),i=(U+l)/2,O=(U-l)/2;return w.set(O,x,i),w}toRotationMatrix(w){return J.FromQuaternionToRef(this,w),w}fromRotationMatrix(w){return Z.FromRotationMatrixToRef(w,this),this}dot(w){return this._x*w._x+this._y*w._y+this._z*w._z+this._w*w._w}toAxisAngle(){const w=Q.Zero();return{axis:w,angle:this.toAxisAngleToRef(w)}}toAxisAngleToRef(w){let E=0;const G=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),P=this._w;return G>0?(E=2*Math.atan2(G,P),w.set(this._x/G,this._y/G,this._z/G)):(E=0,w.set(1,0,0)),E}static FromRotationMatrix(w){const E=new Z;return Z.FromRotationMatrixToRef(w,E),E}static FromRotationMatrixToRef(w,E){const G=w.m,P=G[0],h=G[4],B=G[8],y=G[1],x=G[5],U=G[9],l=G[2],i=G[6],O=G[10],u=P+x+O;let V;return u>0?(V=.5/Math.sqrt(u+1),E._w=.25/V,E._x=(i-U)*V,E._y=(B-l)*V,E._z=(y-h)*V,E._isDirty=!0):P>x&&P>O?(V=2*Math.sqrt(1+P-x-O),E._w=(i-U)/V,E._x=.25*V,E._y=(h+y)/V,E._z=(B+l)/V,E._isDirty=!0):x>O?(V=2*Math.sqrt(1+x-P-O),E._w=(B-l)/V,E._x=(h+y)/V,E._y=.25*V,E._z=(U+i)/V,E._isDirty=!0):(V=2*Math.sqrt(1+O-P-x),E._w=(y-h)/V,E._x=(B+l)/V,E._y=(U+i)/V,E._z=.25*V,E._isDirty=!0),E}static Dot(w,E){return w._x*E._x+w._y*E._y+w._z*E._z+w._w*E._w}static AreClose(w,E){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const P=Z.Dot(w,E);return 1-P*P<=G}static SmoothToRef(w,E,G,P,h){let B=0===P?1:G/P;return B=(0,U.Clamp)(B,0,1),Z.SlerpToRef(w,E,B,h),h}static Zero(){return new Z(0,0,0,0)}static Inverse(w){return new Z(-w._x,-w._y,-w._z,w._w)}static InverseToRef(w,E){return E.set(-w._x,-w._y,-w._z,w._w),E}static Identity(){return new Z(0,0,0,1)}static IsIdentity(w){return w&&0===w._x&&0===w._y&&0===w._z&&1===w._w}static RotationAxis(w,E){return Z.RotationAxisToRef(w,E,new Z)}static RotationAxisToRef(w,E,G){G._w=Math.cos(E/2);const P=Math.sin(E/2)/w.length();return G._x=w._x*P,G._y=w._y*P,G._z=w._z*P,G._isDirty=!0,G}static KE(w,E){return E||(E=0),new Z(w[E],w[E+1],w[E+2],w[E+3])}static FromArrayToRef(w,E,G){return G._x=w[E],G._y=w[E+1],G._z=w[E+2],G._w=w[E+3],G._isDirty=!0,G}static FromFloatsToRef(w,E,G,P,h){return h.tx(w,E,G,P),h}static FromEulerAngles(w,E,G){const P=new Z;return Z.RotationYawPitchRollToRef(E,w,G,P),P}static FromEulerAnglesToRef(w,E,G,P){return Z.RotationYawPitchRollToRef(E,w,G,P),P}static FromEulerVector(w){const E=new Z;return Z.RotationYawPitchRollToRef(w._y,w._x,w._z,E),E}static FromEulerVectorToRef(w,E){return Z.RotationYawPitchRollToRef(w._y,w._x,w._z,E),E}static FromUnitVectorsToRef(w,E,G){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P.d;const B=Q.Dot(w,E)+1;return B<h?Math.abs(w.x)>Math.abs(w.z)?G.set(-w.y,w.x,0,0):G.set(0,-w.z,w.y,0):(Q.CrossToRef(w,E,K.QE[0]),G.set(K.QE[0].x,K.QE[0].y,K.QE[0].z,B)),G.normalize()}static RotationYawPitchRoll(w,E,G){const P=new Z;return Z.RotationYawPitchRollToRef(w,E,G,P),P}static RotationYawPitchRollToRef(w,E,G,P){const h=.5*G,B=.5*E,y=.5*w,x=Math.sin(h),U=Math.cos(h),l=Math.sin(B),i=Math.cos(B),O=Math.sin(y),u=Math.cos(y);return P._x=u*l*U+O*i*x,P._y=O*i*U-u*l*x,P._z=u*i*x-O*l*U,P._w=u*i*U+O*l*x,P._isDirty=!0,P}static RotationAlphaBetaGamma(w,E,G){const P=new Z;return Z.RotationAlphaBetaGammaToRef(w,E,G,P),P}static RotationAlphaBetaGammaToRef(w,E,G,P){const h=.5*(G+w),B=.5*(G-w),y=.5*E;return P._x=Math.cos(B)*Math.sin(y),P._y=Math.sin(B)*Math.sin(y),P._z=Math.sin(h)*Math.cos(y),P._w=Math.cos(h)*Math.cos(y),P._isDirty=!0,P}static RotationQuaternionFromAxis(w,E,G){const P=new Z(0,0,0,0);return Z.RotationQuaternionFromAxisToRef(w,E,G,P),P}static RotationQuaternionFromAxisToRef(w,E,G,P){const h=d.Matrix[0];return w=w.normalizeToRef(d.QE[0]),E=E.normalizeToRef(d.QE[1]),G=G.normalizeToRef(d.QE[2]),J.FromXYZAxesToRef(w,E,G,h),Z.FromRotationMatrixToRef(h,P),P}static FromLookDirectionLH(w,E){const G=new Z;return Z.FromLookDirectionLHToRef(w,E,G),G}static FromLookDirectionLHToRef(w,E,G){const P=d.Matrix[0];return J.LookDirectionLHToRef(w,E,P),Z.FromRotationMatrixToRef(P,G),G}static FromLookDirectionRH(w,E){const G=new Z;return Z.FromLookDirectionRHToRef(w,E,G),G}static FromLookDirectionRHToRef(w,E,G){const P=d.Matrix[0];return J.LookDirectionRHToRef(w,E,P),Z.FromRotationMatrixToRef(P,G)}static Slerp(w,E,G){const P=Z.Identity();return Z.SlerpToRef(w,E,G,P),P}static SlerpToRef(w,E,G,P){let h,B,y=w._x*E._x+w._y*E._y+w._z*E._z+w._w*E._w,x=!1;if(y<0&&(x=!0,y=-y),y>.999999)B=1-G,h=x?-G:G;else{const w=Math.acos(y),E=1/Math.sin(w);B=Math.sin((1-G)*w)*E,h=x?-Math.sin(G*w)*E:Math.sin(G*w)*E}return P._x=B*w._x+h*E._x,P._y=B*w._y+h*E._y,P._z=B*w._z+h*E._z,P._w=B*w._w+h*E._w,P._isDirty=!0,P}static Hermite(w,E,G,P,h){const B=h*h,y=h*B,x=2*y-3*B+1,U=-2*y+3*B,l=y-2*B+h,i=y-B,O=w._x*x+G._x*U+E._x*l+P._x*i,u=w._y*x+G._y*U+E._y*l+P._y*i,V=w._z*x+G._z*U+E._z*l+P._z*i,a=w._w*x+G._w*U+E._w*l+P._w*i;return new Z(O,u,V,a)}static Hermite1stDerivative(w,E,G,P,h){const B=new Z;return this.Hermite1stDerivativeToRef(w,E,G,P,h,B),B}static Hermite1stDerivativeToRef(w,E,G,P,h,B){const y=h*h;return B._x=6*(y-h)*w._x+(3*y-4*h+1)*E._x+6*(-y+h)*G._x+(3*y-2*h)*P._x,B._y=6*(y-h)*w._y+(3*y-4*h+1)*E._y+6*(-y+h)*G._y+(3*y-2*h)*P._y,B._z=6*(y-h)*w._z+(3*y-4*h+1)*E._z+6*(-y+h)*G._z+(3*y-2*h)*P._z,B._w=6*(y-h)*w._w+(3*y-4*h+1)*E._w+6*(-y+h)*G._w+(3*y-2*h)*P._w,B._isDirty=!0,B}static Normalize(w){const E=Z.Zero();return Z.NormalizeToRef(w,E),E}static NormalizeToRef(w,E){return w.normalizeToRef(E),E}static Clamp(w,E,G){const P=new Z;return Z.ClampToRef(w,E,G,P),P}static ClampToRef(w,E,G,P){return P.tx((0,U.Clamp)(w.x,E.x,G.x),(0,U.Clamp)(w.y,E.y,G.y),(0,U.Clamp)(w.z,E.z,G.z),(0,U.Clamp)(w.w,E.w,G.w))}static Random(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Z((0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E))}static RandomToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).tx((0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E),(0,U.RandomRange)(w,E))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(w,E){return Math.sqrt(Z.DistanceSquared(w,E))}static DistanceSquared(w,E){const G=w.x-E.x,P=w.y-E.y,h=w.z-E.z,B=w.w-E.w;return G*G+P*P+h*h+B*B}static Center(w,E){return Z.CenterToRef(w,E,Z.Zero())}static CenterToRef(w,E,G){return G.tx((w.x+E.x)/2,(w.y+E.y)/2,(w.z+E.z)/2,(w.w+E.w)/2)}}Z._V8PerformanceHack=new Z(.5,.5,.5,.5),Object.defineProperties(Z.prototype,{dimension:{value:[4]},rank:{value:1}});class J{static get Use64Bits(){return y.c.MatrixUse64Bits}get m(){return this.Wh}markAsUpdated(){this.updateFlag=l._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(w){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1],G=arguments.length>2&&void 0!==arguments[2]&&arguments[2],P=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=w,this._isIdentity3x2=w||G,this._isIdentityDirty=!this._isIdentity&&E,this._isIdentity3x2Dirty=!this._isIdentity3x2&&P}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,y.c.MatrixTrackPrecisionChange&&y.c.MatrixTrackedMatrices.push(this),this.Wh=new y.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const w=this.Wh;this._isIdentity=1===w[0]&&0===w[1]&&0===w[2]&&0===w[3]&&0===w[4]&&1===w[5]&&0===w[6]&&0===w[7]&&0===w[8]&&0===w[9]&&1===w[10]&&0===w[11]&&0===w[12]&&0===w[13]&&0===w[14]&&1===w[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Wh[0]||1!==this.Wh[5]||1!==this.Wh[15]||0!==this.Wh[1]||0!==this.Wh[2]||0!==this.Wh[3]||0!==this.Wh[4]||0!==this.Wh[6]||0!==this.Wh[7]||0!==this.Wh[8]||0!==this.Wh[9]||0!==this.Wh[10]||0!==this.Wh[11]||0!==this.Wh[12]||0!==this.Wh[13]||0!==this.Wh[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const w=this.Wh,E=w[0],G=w[1],P=w[2],h=w[3],B=w[4],y=w[5],x=w[6],U=w[7],l=w[8],i=w[9],O=w[10],u=w[11],V=w[12],a=w[13],Q=w[14],c=w[15],Z=O*c-Q*u,J=i*c-a*u,d=i*Q-a*O,K=l*c-V*u,t=l*Q-O*V,q=l*a-V*i;return E*+(y*Z-x*J+U*d)+G*-(B*Z-x*K+U*t)+P*+(B*J-y*K+U*q)+h*-(B*d-y*t+x*q)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!w)return this.Wh;const G=this.Wh;for(let P=0;P<16;P++)w[E+P]=G[P];return this}Lh(){return this.Wh}VG(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(w,E,this)}tx(){for(var w=arguments.length,E=new Array(w),G=0;G<w;G++)E[G]=arguments[G];return J.FromArrayToRef(E,0,this)}set(){const w=this.Wh;for(let E=0;E<16;E++)w[E]=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}Wx(w){const E=this.Wh;for(let G=0;G<16;G++)E[G]=w;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return J.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(w){const E=new J;return this.addToRef(w,E),E}addToRef(w,E){const G=this.Wh,P=E.Wh,h=w.m;for(let B=0;B<16;B++)P[B]=G[B]+h[B];return E.markAsUpdated(),E}addToSelf(w){const E=this.Wh,G=w.m;return E[0]+=G[0],E[1]+=G[1],E[2]+=G[2],E[3]+=G[3],E[4]+=G[4],E[5]+=G[5],E[6]+=G[6],E[7]+=G[7],E[8]+=G[8],E[9]+=G[9],E[10]+=G[10],E[11]+=G[11],E[12]+=G[12],E[13]+=G[13],E[14]+=G[14],E[15]+=G[15],this.markAsUpdated(),this}addInPlace(w){const E=this.Wh,G=w.m;for(let P=0;P<16;P++)E[P]+=G[P];return this.markAsUpdated(),this}addInPlaceFromFloats(){const w=this.Wh;for(let E=0;E<16;E++)w[E]+=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}cE(w){const E=this.Wh,G=w.m;for(let P=0;P<16;P++)E[P]-=G[P];return this.markAsUpdated(),this}subtractToRef(w,E){const G=this.Wh,P=w.m,h=E.Wh;for(let B=0;B<16;B++)h[B]=G[B]-P[B];return E.markAsUpdated(),E}xO(w){const E=this.Wh,G=w.m;for(let P=0;P<16;P++)E[P]-=G[P];return this.markAsUpdated(),this}subtractFromFloats(){for(var w=arguments.length,E=new Array(w),G=0;G<w;G++)E[G]=arguments[G];return this.subtractFromFloatsToRef(...E,new J)}subtractFromFloatsToRef(){for(var w=arguments.length,E=new Array(w),G=0;G<w;G++)E[G]=arguments[G];const P=E.pop(),h=this.Wh,B=P.Wh,y=E;for(let x=0;x<16;x++)B[x]=h[x]-y[x];return P.markAsUpdated(),P}invertToRef(w){return!0===this._isIdentity?(J.IdentityToRef(w),w):(u(this,w.Lh())?w.markAsUpdated():w.B(this),w)}addAtIndex(w,E){return this.Wh[w]+=E,this.markAsUpdated(),this}multiplyAtIndex(w,E){return this.Wh[w]*=E,this.markAsUpdated(),this}setTranslationFromFloats(w,E,G){return this.Wh[12]=w,this.Wh[13]=E,this.Wh[14]=G,this.markAsUpdated(),this}addTranslationFromFloats(w,E,G){return this.Wh[12]+=w,this.Wh[13]+=E,this.Wh[14]+=G,this.markAsUpdated(),this}setTranslation(w){return this.setTranslationFromFloats(w._x,w._y,w._z)}getTranslation(){return new Q(this.Wh[12],this.Wh[13],this.Wh[14])}getTranslationToRef(w){return w.x=this.Wh[12],w.y=this.Wh[13],w.z=this.Wh[14],w}removeRotationAndScaling(){const w=this.m;return J.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,w[12],w[13],w[14],w[15],this),this._updateIdentityStatus(0===w[12]&&0===w[13]&&0===w[14]&&1===w[15]),this}B(w){w.copyToArray(this.Wh);const E=w;return this.updateFlag=E.updateFlag,this._updateIdentityStatus(E._isIdentity,E._isIdentityDirty,E._isIdentity3x2,E._isIdentity3x2Dirty),this}copyToArray(w){return O(this,w,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(w){const E=new J;return this.multiplyToRef(w,E),E}multiplyInPlace(w){const E=this.Wh,G=w.m;for(let P=0;P<16;P++)E[P]*=G[P];return this.markAsUpdated(),this}multiplyByFloats(){const w=this.Wh;for(let E=0;E<16;E++)w[E]*=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var w=arguments.length,E=new Array(w),G=0;G<w;G++)E[G]=arguments[G];const P=E.pop(),h=this.Wh,B=P.Wh,y=E;for(let x=0;x<16;x++)B[x]=h[x]*y[x];return P.markAsUpdated(),P}multiplyToRef(w,E){return this._isIdentity?(E.B(w),E):w._isIdentity?(E.B(this),E):(this.multiplyToArray(w,E.Wh,0),E.markAsUpdated(),E)}multiplyToArray(w,E,G){return i(this,w,E,G),this}divide(w){return this.divideToRef(w,new J)}divideToRef(w,E){const G=this.Wh,P=w.m,h=E.Wh;for(let B=0;B<16;B++)h[B]=G[B]/P[B];return E.markAsUpdated(),E}divideInPlace(w){const E=this.Wh,G=w.m;for(let P=0;P<16;P++)E[P]/=G[P];return this.markAsUpdated(),this}minimizeInPlace(w){const E=this.Wh,G=w.m;for(let P=0;P<16;P++)E[P]=Math.min(E[P],G[P]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const w=this.Wh;for(let E=0;E<16;E++)w[E]=Math.min(w[E],E<0||arguments.length<=E?void 0:arguments[E]);return this.markAsUpdated(),this}maximizeInPlace(w){const E=this.Wh,G=w.m;for(let P=0;P<16;P++)E[P]=Math.min(E[P],G[P]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const w=this.Wh;for(let E=0;E<16;E++)w[E]=Math.min(w[E],E<0||arguments.length<=E?void 0:arguments[E]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new J)}negateInPlace(){const w=this.Wh;for(let E=0;E<16;E++)w[E]=-w[E];return this.markAsUpdated(),this}negateToRef(w){const E=this.Wh,G=w.Wh;for(let P=0;P<16;P++)G[P]=-E[P];return w.markAsUpdated(),w}equals(w){const E=w;if(!E)return!1;if((this._isIdentity||E._isIdentity)&&!this._isIdentityDirty&&!E._isIdentityDirty)return this._isIdentity&&E._isIdentity;const G=this.m,P=E.m;return G[0]===P[0]&&G[1]===P[1]&&G[2]===P[2]&&G[3]===P[3]&&G[4]===P[4]&&G[5]===P[5]&&G[6]===P[6]&&G[7]===P[7]&&G[8]===P[8]&&G[9]===P[9]&&G[10]===P[10]&&G[11]===P[11]&&G[12]===P[12]&&G[13]===P[13]&&G[14]===P[14]&&G[15]===P[15]}equalsWithEpsilon(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const G=this.Wh,P=w.m;for(let h=0;h<16;h++)if(!(0,U.WithinEpsilon)(G[h],P[h],E))return!1;return!0}equalsToFloats(){const w=this.Wh;for(let E=0;E<16;E++)if(w[E]!=(E<0||arguments.length<=E?void 0:arguments[E]))return!1;return!0}floor(){return this.floorToRef(new J)}floorToRef(w){const E=this.Wh,G=w.Wh;for(let P=0;P<16;P++)G[P]=Math.floor(E[P]);return w.markAsUpdated(),w}fract(){return this.fractToRef(new J)}fractToRef(w){const E=this.Wh,G=w.Wh;for(let P=0;P<16;P++)G[P]=E[P]-Math.floor(E[P]);return w.markAsUpdated(),w}clone(){const w=new J;return w.B(this),w}getClassName(){return"Matrix"}getHashCode(){let w=V(this.Wh[0]);for(let E=1;E<16;E++)w=397*w^V(this.Wh[E]);return w}decomposeToTransformNode(w){return w.rotationQuaternion=w.rotationQuaternion||new Z,this.decompose(w.qx,w.rotationQuaternion,w.position)}decompose(w,E,G,P){let h=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return G&&G.Wx(0),w&&w.Wx(1),E&&E.tx(0,0,0,1),!0;const B=this.Wh;if(G&&G.tx(B[12],B[13],B[14]),(w=w||d.QE[0]).x=Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]),w.y=Math.sqrt(B[4]*B[4]+B[5]*B[5]+B[6]*B[6]),w.z=Math.sqrt(B[8]*B[8]+B[9]*B[9]+B[10]*B[10]),P){const E=(h?P.absoluteScaling.x:P.qx.x)<0?-1:1,G=(h?P.absoluteScaling.y:P.qx.y)<0?-1:1,B=(h?P.absoluteScaling.z:P.qx.z)<0?-1:1;w.x*=E,w.y*=G,w.z*=B}else this.determinant()<=0&&(w.y*=-1);if(0===w._x||0===w._y||0===w._z)return E&&E.tx(0,0,0,1),!1;if(E){const G=1/w._x,P=1/w._y,h=1/w._z;J.FromValuesToRef(B[0]*G,B[1]*G,B[2]*G,0,B[4]*P,B[5]*P,B[6]*P,0,B[8]*h,B[9]*h,B[10]*h,0,0,0,0,1,d.Matrix[0]),Z.FromRotationMatrixToRef(d.Matrix[0],E)}return!0}getRow(w){if(w<0||w>3)return null;const E=4*w;return new c(this.Wh[E+0],this.Wh[E+1],this.Wh[E+2],this.Wh[E+3])}getRowToRef(w,E){if(w>=0&&w<=3){const G=4*w;E.x=this.Wh[G+0],E.y=this.Wh[G+1],E.z=this.Wh[G+2],E.w=this.Wh[G+3]}return E}setRow(w,E){return this.setRowFromFloats(w,E.x,E.y,E.z,E.w)}transpose(){const w=new J;return J.TransposeToRef(this,w),w}transposeToRef(w){return J.TransposeToRef(this,w),w}setRowFromFloats(w,E,G,P,h){if(w<0||w>3)return this;const B=4*w;return this.Wh[B+0]=E,this.Wh[B+1]=G,this.Wh[B+2]=P,this.Wh[B+3]=h,this.markAsUpdated(),this}scale(w){const E=new J;return this.scaleToRef(w,E),E}scaleToRef(w,E){for(let G=0;G<16;G++)E.Wh[G]=this.Wh[G]*w;return E.markAsUpdated(),E}scaleAndAddToRef(w,E){for(let G=0;G<16;G++)E.Wh[G]+=this.Wh[G]*w;return E.markAsUpdated(),E}scaleInPlace(w){const E=this.Wh;for(let G=0;G<16;G++)E[G]*=w;return this.markAsUpdated(),this}toNormalMatrix(w){const E=d.Matrix[0];this.invertToRef(E),E.transposeToRef(w);const G=w.Wh;return J.FromValuesToRef(G[0],G[1],G[2],0,G[4],G[5],G[6],0,G[8],G[9],G[10],0,0,0,0,1,w),w}getRotationMatrix(){const w=new J;return this.getRotationMatrixToRef(w),w}getRotationMatrixToRef(w){const E=d.QE[0];if(!this.decompose(E))return J.IdentityToRef(w),w;const G=this.Wh,P=1/E._x,h=1/E._y,B=1/E._z;return J.FromValuesToRef(G[0]*P,G[1]*P,G[2]*P,0,G[4]*h,G[5]*h,G[6]*h,0,G[8]*B,G[9]*B,G[10]*B,0,0,0,0,1,w),w}toggleModelMatrixHandInPlace(){const w=this.Wh;return w[2]*=-1,w[6]*=-1,w[8]*=-1,w[9]*=-1,w[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const w=this.Wh;return w[8]*=-1,w[9]*=-1,w[10]*=-1,w[11]*=-1,this.markAsUpdated(),this}static KE(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const G=new J;return J.FromArrayToRef(w,E,G),G}static FromArrayToRef(w,E,G){for(let P=0;P<16;P++)G.Wh[P]=w[P+E];return G.markAsUpdated(),G}static FromFloat32ArrayToRefScaled(w,E,G,P){return P.Wh[0]=w[0+E]*G,P.Wh[1]=w[1+E]*G,P.Wh[2]=w[2+E]*G,P.Wh[3]=w[3+E]*G,P.Wh[4]=w[4+E]*G,P.Wh[5]=w[5+E]*G,P.Wh[6]=w[6+E]*G,P.Wh[7]=w[7+E]*G,P.Wh[8]=w[8+E]*G,P.Wh[9]=w[9+E]*G,P.Wh[10]=w[10+E]*G,P.Wh[11]=w[11+E]*G,P.Wh[12]=w[12+E]*G,P.Wh[13]=w[13+E]*G,P.Wh[14]=w[14+E]*G,P.Wh[15]=w[15+E]*G,P.markAsUpdated(),P}static get IdentityReadOnly(){return J._IdentityReadOnly}static FromValuesToRef(w,E,G,P,h,B,y,x,U,l,i,O,u,V,a,Q,c){const Z=c.Wh;Z[0]=w,Z[1]=E,Z[2]=G,Z[3]=P,Z[4]=h,Z[5]=B,Z[6]=y,Z[7]=x,Z[8]=U,Z[9]=l,Z[10]=i,Z[11]=O,Z[12]=u,Z[13]=V,Z[14]=a,Z[15]=Q,c.markAsUpdated()}static FromValues(w,E,G,P,h,B,y,x,U,l,i,O,u,V,a,Q){const c=new J,Z=c.Wh;return Z[0]=w,Z[1]=E,Z[2]=G,Z[3]=P,Z[4]=h,Z[5]=B,Z[6]=y,Z[7]=x,Z[8]=U,Z[9]=l,Z[10]=i,Z[11]=O,Z[12]=u,Z[13]=V,Z[14]=a,Z[15]=Q,c.markAsUpdated(),c}static Compose(w,E,G){const P=new J;return J.ComposeToRef(w,E,G,P),P}static ComposeToRef(w,E,G,P){const h=P.Wh,B=E._x,y=E._y,x=E._z,U=E._w,l=B+B,i=y+y,O=x+x,u=B*l,V=B*i,a=B*O,Q=y*i,c=y*O,Z=x*O,J=U*l,d=U*i,K=U*O,t=w._x,q=w._y,W=w._z;return h[0]=(1-(Q+Z))*t,h[1]=(V+K)*t,h[2]=(a-d)*t,h[3]=0,h[4]=(V-K)*q,h[5]=(1-(u+Z))*q,h[6]=(c+J)*q,h[7]=0,h[8]=(a+d)*W,h[9]=(c-J)*W,h[10]=(1-(u+Q))*W,h[11]=0,h[12]=G._x,h[13]=G._y,h[14]=G._z,h[15]=1,P.markAsUpdated(),P}static Identity(){const w=J.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return w._updateIdentityStatus(!0),w}static IdentityToRef(w){return J.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,w),w._updateIdentityStatus(!0),w}static Zero(){const w=J.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return w._updateIdentityStatus(!1),w}static RotationX(w){const E=new J;return J.RotationXToRef(w,E),E}static Invert(w){const E=new J;return w.invertToRef(E),E}static RotationXToRef(w,E){const G=Math.sin(w),P=Math.cos(w);return J.FromValuesToRef(1,0,0,0,0,P,G,0,0,-G,P,0,0,0,0,1,E),E._updateIdentityStatus(1===P&&0===G),E}static RotationY(w){const E=new J;return J.RotationYToRef(w,E),E}static RotationYToRef(w,E){const G=Math.sin(w),P=Math.cos(w);return J.FromValuesToRef(P,0,-G,0,0,1,0,0,G,0,P,0,0,0,0,1,E),E._updateIdentityStatus(1===P&&0===G),E}static RotationZ(w){const E=new J;return J.RotationZToRef(w,E),E}static RotationZToRef(w,E){const G=Math.sin(w),P=Math.cos(w);return J.FromValuesToRef(P,G,0,0,-G,P,0,0,0,0,1,0,0,0,0,1,E),E._updateIdentityStatus(1===P&&0===G),E}static RotationAxis(w,E){const G=new J;return J.RotationAxisToRef(w,E,G),G}static RotationAxisToRef(w,E,G){const P=Math.sin(-E),h=Math.cos(-E),B=1-h;w=w.normalizeToRef(d.QE[0]);const y=G.Wh;return y[0]=w._x*w._x*B+h,y[1]=w._x*w._y*B-w._z*P,y[2]=w._x*w._z*B+w._y*P,y[3]=0,y[4]=w._y*w._x*B+w._z*P,y[5]=w._y*w._y*B+h,y[6]=w._y*w._z*B-w._x*P,y[7]=0,y[8]=w._z*w._x*B-w._y*P,y[9]=w._z*w._y*B+w._x*P,y[10]=w._z*w._z*B+h,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,G.markAsUpdated(),G}static RotationAlignToRef(w,E,G){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const B=Q.Dot(E,w),y=G.Wh;if(B<-1+P.d)y[0]=-1,y[1]=0,y[2]=0,y[3]=0,y[4]=0,y[5]=h?1:-1,y[6]=0,y[7]=0,y[8]=0,y[9]=0,y[10]=h?-1:1,y[11]=0;else{const G=Q.Cross(E,w),P=1/(1+B);y[0]=G._x*G._x*P+B,y[1]=G._y*G._x*P-G._z,y[2]=G._z*G._x*P+G._y,y[3]=0,y[4]=G._x*G._y*P+G._z,y[5]=G._y*G._y*P+B,y[6]=G._z*G._y*P-G._x,y[7]=0,y[8]=G._x*G._z*P-G._y,y[9]=G._y*G._z*P+G._x,y[10]=G._z*G._z*P+B,y[11]=0}return y[12]=0,y[13]=0,y[14]=0,y[15]=1,G.markAsUpdated(),G}static RotationYawPitchRoll(w,E,G){const P=new J;return J.RotationYawPitchRollToRef(w,E,G,P),P}static RotationYawPitchRollToRef(w,E,G,P){return Z.RotationYawPitchRollToRef(w,E,G,d.Quaternion[0]),d.Quaternion[0].toRotationMatrix(P),P}static Scaling(w,E,G){const P=new J;return J.ScalingToRef(w,E,G,P),P}static ScalingToRef(w,E,G,P){return J.FromValuesToRef(w,0,0,0,0,E,0,0,0,0,G,0,0,0,0,1,P),P._updateIdentityStatus(1===w&&1===E&&1===G),P}static Translation(w,E,G){const P=new J;return J.TranslationToRef(w,E,G,P),P}static TranslationToRef(w,E,G,P){return J.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,w,E,G,1,P),P._updateIdentityStatus(0===w&&0===E&&0===G),P}static Lerp(w,E,G){const P=new J;return J.LerpToRef(w,E,G,P),P}static LerpToRef(w,E,G,P){const h=P.Wh,B=w.m,y=E.m;for(let x=0;x<16;x++)h[x]=B[x]*(1-G)+y[x]*G;return P.markAsUpdated(),P}static DecomposeLerp(w,E,G){const P=new J;return J.DecomposeLerpToRef(w,E,G,P),P}static DecomposeLerpToRef(w,E,G,P){const h=d.QE[0],B=d.Quaternion[0],y=d.QE[1];w.decompose(h,B,y);const x=d.QE[2],U=d.Quaternion[1],l=d.QE[3];E.decompose(x,U,l);const i=d.QE[4];Q.LerpToRef(h,x,G,i);const O=d.Quaternion[2];Z.SlerpToRef(B,U,G,O);const u=d.QE[5];return Q.LerpToRef(y,l,G,u),J.ComposeToRef(i,O,u,P),P}static LookAtLH(w,E,G){const P=new J;return J.LookAtLHToRef(w,E,G,P),P}static LookAtLHToRef(w,E,G,P){const h=d.QE[0],B=d.QE[1],y=d.QE[2];E.subtractToRef(w,y),y.normalize(),Q.CrossToRef(G,y,h);const x=h.lengthSquared();0===x?h.x=1:h.normalizeFromLength(Math.sqrt(x)),Q.CrossToRef(y,h,B),B.normalize();const U=-Q.Dot(h,w),l=-Q.Dot(B,w),i=-Q.Dot(y,w);return J.FromValuesToRef(h._x,B._x,y._x,0,h._y,B._y,y._y,0,h._z,B._z,y._z,0,U,l,i,1,P),P}static LookAtRH(w,E,G){const P=new J;return J.LookAtRHToRef(w,E,G,P),P}static LookAtRHToRef(w,E,G,P){const h=d.QE[0],B=d.QE[1],y=d.QE[2];w.subtractToRef(E,y),y.normalize(),Q.CrossToRef(G,y,h);const x=h.lengthSquared();0===x?h.x=1:h.normalizeFromLength(Math.sqrt(x)),Q.CrossToRef(y,h,B),B.normalize();const U=-Q.Dot(h,w),l=-Q.Dot(B,w),i=-Q.Dot(y,w);return J.FromValuesToRef(h._x,B._x,y._x,0,h._y,B._y,y._y,0,h._z,B._z,y._z,0,U,l,i,1,P),P}static LookDirectionLH(w,E){const G=new J;return J.LookDirectionLHToRef(w,E,G),G}static LookDirectionLHToRef(w,E,G){const P=d.QE[0];P.B(w),P.scaleInPlace(-1);const h=d.QE[1];return Q.CrossToRef(E,P,h),J.FromValuesToRef(h._x,h._y,h._z,0,E._x,E._y,E._z,0,P._x,P._y,P._z,0,0,0,0,1,G),G}static LookDirectionRH(w,E){const G=new J;return J.LookDirectionRHToRef(w,E,G),G}static LookDirectionRHToRef(w,E,G){const P=d.QE[2];return Q.CrossToRef(E,w,P),J.FromValuesToRef(P._x,P._y,P._z,0,E._x,E._y,E._z,0,w._x,w._y,w._z,0,0,0,0,1,G),G}static OrthoLH(w,E,G,P,h){const B=new J;return J.OrthoLHToRef(w,E,G,P,B,h),B}static OrthoLHToRef(w,E,G,P,h,B){const y=2/w,x=2/E,U=2/(P-G),l=-(P+G)/(P-G);return J.FromValuesToRef(y,0,0,0,0,x,0,0,0,0,U,0,0,0,l,1,h),B&&h.multiplyToRef(t,h),h._updateIdentityStatus(1===y&&1===x&&1===U&&0===l),h}static OrthoOffCenterLH(w,E,G,P,h,B,y){const x=new J;return J.OrthoOffCenterLHToRef(w,E,G,P,h,B,x,y),x}static OrthoOffCenterLHToRef(w,E,G,P,h,B,y,x){const U=2/(E-w),l=2/(P-G),i=2/(B-h),O=-(B+h)/(B-h),u=(w+E)/(w-E),V=(P+G)/(G-P);return J.FromValuesToRef(U,0,0,0,0,l,0,0,0,0,i,0,u,V,O,1,y),x&&y.multiplyToRef(t,y),y.markAsUpdated(),y}static ObliqueOffCenterLHToRef(w,E,G,P,h,B,y,x,U,l,i){const O=-y*Math.cos(x),u=-y*Math.sin(x);return J.TranslationToRef(0,0,-U,d.Matrix[1]),J.FromValuesToRef(1,0,0,0,0,1,0,0,O,u,1,0,0,0,0,1,d.Matrix[0]),d.Matrix[1].multiplyToRef(d.Matrix[0],d.Matrix[0]),J.TranslationToRef(0,0,U,d.Matrix[1]),d.Matrix[0].multiplyToRef(d.Matrix[1],d.Matrix[0]),J.OrthoOffCenterLHToRef(w,E,G,P,h,B,l,i),d.Matrix[0].multiplyToRef(l,l),l}static OrthoOffCenterRH(w,E,G,P,h,B,y){const x=new J;return J.OrthoOffCenterRHToRef(w,E,G,P,h,B,x,y),x}static OrthoOffCenterRHToRef(w,E,G,P,h,B,y,x){return J.OrthoOffCenterLHToRef(w,E,G,P,h,B,y,x),y.Wh[10]*=-1,y}static ObliqueOffCenterRHToRef(w,E,G,P,h,B,y,x,U,l,i){const O=y*Math.cos(x),u=y*Math.sin(x);return J.TranslationToRef(0,0,U,d.Matrix[1]),J.FromValuesToRef(1,0,0,0,0,1,0,0,O,u,1,0,0,0,0,1,d.Matrix[0]),d.Matrix[1].multiplyToRef(d.Matrix[0],d.Matrix[0]),J.TranslationToRef(0,0,-U,d.Matrix[1]),d.Matrix[0].multiplyToRef(d.Matrix[1],d.Matrix[0]),J.OrthoOffCenterRHToRef(w,E,G,P,h,B,l,i),d.Matrix[0].multiplyToRef(l,l),l}static PerspectiveLH(w,E,G,P,h){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const y=new J,x=2*G/w,U=2*G/E,l=(P+G)/(P-G),i=-2*P*G/(P-G),O=Math.tan(B);return J.FromValuesToRef(x,0,0,0,0,U,0,O,0,0,l,1,0,0,i,0,y),h&&y.multiplyToRef(t,y),y._updateIdentityStatus(!1),y}static PerspectiveFovLH(w,E,G,P,h){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const x=new J;return J.PerspectiveFovLHToRef(w,E,G,P,x,!0,h,B,y),x}static PerspectiveFovLHToRef(w,E,G,P,h){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,x=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,U=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=G,i=P,O=1/Math.tan(.5*w),u=B?O/E:O,V=B?O:O*E,a=U&&0===l?-1:0!==i?(i+l)/(i-l):1,Q=U&&0===l?2*i:0!==i?-2*i*l/(i-l):-2*l,c=Math.tan(x);return J.FromValuesToRef(u,0,0,0,0,V,0,c,0,0,a,1,0,0,Q,0,h),y&&h.multiplyToRef(t,h),h._updateIdentityStatus(!1),h}static PerspectiveFovReverseLHToRef(w,E,G,P,h){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,x=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const U=1/Math.tan(.5*w),l=B?U/E:U,i=B?U:U*E,O=Math.tan(x);return J.FromValuesToRef(l,0,0,0,0,i,0,O,0,0,-G,1,0,0,1,0,h),y&&h.multiplyToRef(t,h),h._updateIdentityStatus(!1),h}static PerspectiveFovRH(w,E,G,P,h){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const x=new J;return J.PerspectiveFovRHToRef(w,E,G,P,x,!0,h,B,y),x}static PerspectiveFovRHToRef(w,E,G,P,h){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,x=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,U=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=G,i=P,O=1/Math.tan(.5*w),u=B?O/E:O,V=B?O:O*E,a=U&&0===l?1:0!==i?-(i+l)/(i-l):-1,Q=U&&0===l?2*i:0!==i?-2*i*l/(i-l):-2*l,c=Math.tan(x);return J.FromValuesToRef(u,0,0,0,0,V,0,c,0,0,a,-1,0,0,Q,0,h),y&&h.multiplyToRef(t,h),h._updateIdentityStatus(!1),h}static PerspectiveFovReverseRHToRef(w,E,G,P,h){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,x=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const U=1/Math.tan(.5*w),l=B?U/E:U,i=B?U:U*E,O=Math.tan(x);return J.FromValuesToRef(l,0,0,0,0,i,0,O,0,0,-G,-1,0,0,-1,0,h),y&&h.multiplyToRef(t,h),h._updateIdentityStatus(!1),h}static GetFinalMatrix(w,E,G,P,h,B){const y=w.width,x=w.height,U=w.x,l=w.y,i=J.FromValues(y/2,0,0,0,0,-x/2,0,0,0,0,B-h,0,U+y/2,x/2+l,h,1),O=new J;return E.multiplyToRef(G,O),O.multiplyToRef(P,O),O.multiplyToRef(i,O)}static GetAsMatrix2x2(w){const E=w.m,G=[E[0],E[1],E[4],E[5]];return y.c.MatrixUse64Bits?G:new Float32Array(G)}static GetAsMatrix3x3(w){const E=w.m,G=[E[0],E[1],E[2],E[4],E[5],E[6],E[8],E[9],E[10]];return y.c.MatrixUse64Bits?G:new Float32Array(G)}static Transpose(w){const E=new J;return J.TransposeToRef(w,E),E}static TransposeToRef(w,E){const G=w.m,P=G[0],h=G[4],B=G[8],y=G[12],x=G[1],U=G[5],l=G[9],i=G[13],O=G[2],u=G[6],V=G[10],a=G[14],Q=G[3],c=G[7],Z=G[11],J=G[15],d=E.Wh;return d[0]=P,d[1]=h,d[2]=B,d[3]=y,d[4]=x,d[5]=U,d[6]=l,d[7]=i,d[8]=O,d[9]=u,d[10]=V,d[11]=a,d[12]=Q,d[13]=c,d[14]=Z,d[15]=J,E.markAsUpdated(),E._updateIdentityStatus(w._isIdentity,w._isIdentityDirty),E}static Reflection(w){const E=new J;return J.ReflectionToRef(w,E),E}static ReflectionToRef(w,E){w.normalize();const G=w.normal.x,P=w.normal.y,h=w.normal.z,B=-2*G,y=-2*P,x=-2*h;return J.FromValuesToRef(B*G+1,y*G,x*G,0,B*P,y*P+1,x*P,0,B*h,y*h,x*h+1,0,B*w.d,y*w.d,x*w.d,1,E),E}static FromXYZAxesToRef(w,E,G,P){return J.FromValuesToRef(w._x,w._y,w._z,0,E._x,E._y,E._z,0,G._x,G._y,G._z,0,0,0,0,1,P),P}static FromQuaternionToRef(w,E){const G=w._x*w._x,P=w._y*w._y,h=w._z*w._z,B=w._x*w._y,y=w._z*w._w,x=w._z*w._x,U=w._y*w._w,l=w._y*w._z,i=w._x*w._w;return E.Wh[0]=1-2*(P+h),E.Wh[1]=2*(B+y),E.Wh[2]=2*(x-U),E.Wh[3]=0,E.Wh[4]=2*(B-y),E.Wh[5]=1-2*(h+G),E.Wh[6]=2*(l+i),E.Wh[7]=0,E.Wh[8]=2*(x+U),E.Wh[9]=2*(l-i),E.Wh[10]=1-2*(P+G),E.Wh[11]=0,E.Wh[12]=0,E.Wh[13]=0,E.Wh[14]=0,E.Wh[15]=1,E.markAsUpdated(),E}}J._IdentityReadOnly=J.Identity(),Object.defineProperties(J.prototype,{dimension:{value:[4,4]},rank:{value:2}});class d{}d.QE=(0,h.f)(11,Q.Zero),d.Matrix=(0,h.f)(2,J.Identity),d.Quaternion=(0,h.f)(3,Z.Zero);class K{}K.Vector2=(0,h.f)(3,a.Zero),K.QE=(0,h.f)(13,Q.Zero),K.Vector4=(0,h.f)(3,c.Zero),K.Quaternion=(0,h.f)(3,Z.Zero),K.Matrix=(0,h.f)(8,J.Identity),(0,B.g)("BABYLON.Vector2",a),(0,B.g)("BABYLON.Vector3",Q),(0,B.g)("BABYLON.Vector4",c),(0,B.g)("BABYLON.Matrix",J);const t=J.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11684:(w,E,G)=>{function P(w,E){const G=[];for(let P=0;P<w;++P)G.push(E());return G}function h(w,E){return P(w,E)}G.d(E,{d:()=>P,f:()=>h,i:()=>y});const B=["push","splice","pop","shift","unshift"];function y(w,E){const G=B.map((G=>function(w,E,G){const P=w[E];if("function"!==typeof P)return null;const h=function(){const P=w.length,B=h.previous.apply(w,arguments);return G(E,P),B};return P.next=h,h.previous=P,w[E]=h,()=>{const G=h.previous;if(!G)return;const P=h.next;P?(G.next=P,P.previous=G):(G.next=void 0,w[E]=G),h.next=void 0,h.previous=void 0}}(w,G,E)));return()=>{for(const w of G)null===w||void 0===w||w()}}}}]);