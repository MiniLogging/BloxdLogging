"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{11196:(o,H,n)=>{n.d(H,{e:()=>O,h:()=>g,l:()=>E,p:()=>k});const E=1/2.2,k=2.2,g=(1+Math.sqrt(5))/2,O=.001},11205:(o,H,n)=>{function E(o){return parseInt(o.toString().replace(/\W/g,""))}function k(o,H){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(o-H)<=n}function g(o,H,n){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return o<H-E||o>n+E}function O(o,H){return o===H?o:Math.random()*(H-o)+o}function Y(o,H,n){return o+(H-o)*n}function y(o,H,n){let E=V(H-o,360);return E>180&&(E-=360),o+E*A(n)}function S(o,H,n){let E=0;return E=o!=H?A((n-o)/(H-o)):0,E}function G(o,H,n,E,k){const g=k*k,O=k*g;return o*(2*O-3*g+1)+n*(-2*O+3*g)+H*(O-2*g+k)+E*(O-g)}function c(o,H,n,E,k){const g=k*k;return 6*(g-k)*o+(3*g-4*k+1)*H+6*(-g+k)*n+(3*g-2*k)*E}function A(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(n,Math.max(H,o))}function l(o){return o-=2*Math.PI*Math.floor((o+Math.PI)/(2*Math.PI))}function x(o){const H=o.toString(16);return o<=15?("0"+H).toUpperCase():H.toUpperCase()}function z(o){if(Math.log2)return Math.floor(Math.log2(o));if(o<0)return NaN;if(0===o)return-1/0;let H=0;if(o<1){for(;o<1;)H++,o*=2;H=-H}else if(o>1)for(;o>1;)H++,o=Math.floor(o/2);return H}function V(o,H){return o-Math.floor(o/H)*H}function J(o,H,n){return(o-H)/(n-H)}function N(o,H,n){return o*(n-H)+H}function h(o,H){let n=V(H-o,360);return n>180&&(n-=360),n}function Q(o,H){const n=V(o,2*H);return H-Math.abs(n-H)}function p(o,H,n){let E=A(n);return E=-2*E*E*E+3*E*E,H*E+o*(1-E)}function j(o,H,n){let E=0;return E=Math.abs(H-o)<=n?H:o+Math.sign(H-o)*n,E}function m(o,H,n){const E=h(o,H);let k=0;return k=-n<E&&E<n?H:j(o,H=o+E,n),k}function P(o,H,n){return(o-H)/(n-H)}function b(o,H,n){return(n-H)*o+H}function e(o,H){const n=o%H;return 0===n?H:e(H,n)}n.r(H),n.d(H,{Clamp:()=>A,DeltaAngle:()=>h,Denormalize:()=>N,ExtractAsInt:()=>E,Hermite:()=>G,Hermite1stDerivative:()=>c,HighestCommonFactor:()=>e,ILog2:()=>z,InverseLerp:()=>S,Lerp:()=>Y,LerpAngle:()=>y,MoveTowards:()=>j,MoveTowardsAngle:()=>m,Normalize:()=>J,NormalizeRadians:()=>l,OutsideRange:()=>g,PercentToRange:()=>b,PingPong:()=>Q,RandomRange:()=>O,RangeToPercent:()=>P,Repeat:()=>V,SmoothStep:()=>p,ToHex:()=>x,WithinEpsilon:()=>k})},11189:(o,H,n)=>{n.r(H),n.d(H,{Matrix:()=>N,Quaternion:()=>J,TmpVectors:()=>Q,Vector2:()=>x,xH:()=>z,Vector4:()=>V});var E=n(11196),k=n(11201),g=n(11140),O=n(11115),Y=n(11060),y=n(11205);class S{}function G(o,H,n){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const k=o.bg(),g=H.bg(),O=k[0],Y=k[1],y=k[2],S=k[3],G=k[4],c=k[5],A=k[6],l=k[7],x=k[8],z=k[9],V=k[10],J=k[11],N=k[12],h=k[13],Q=k[14],p=k[15],j=g[0],m=g[1],P=g[2],b=g[3],e=g[4],Z=g[5],M=g[6],K=g[7],f=g[8],B=g[9],q=g[10],D=g[11],T=g[12],a=g[13],F=g[14],C=g[15];n[E]=O*j+Y*e+y*f+S*T,n[E+1]=O*m+Y*Z+y*B+S*a,n[E+2]=O*P+Y*M+y*q+S*F,n[E+3]=O*b+Y*K+y*D+S*C,n[E+4]=G*j+c*e+A*f+l*T,n[E+5]=G*m+c*Z+A*B+l*a,n[E+6]=G*P+c*M+A*q+l*F,n[E+7]=G*b+c*K+A*D+l*C,n[E+8]=x*j+z*e+V*f+J*T,n[E+9]=x*m+z*Z+V*B+J*a,n[E+10]=x*P+z*M+V*q+J*F,n[E+11]=x*b+z*K+V*D+J*C,n[E+12]=N*j+h*e+Q*f+p*T,n[E+13]=N*m+h*Z+Q*B+p*a,n[E+14]=N*P+h*M+Q*q+p*F,n[E+15]=N*b+h*K+Q*D+p*C}function c(o,H){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const E=o.bg();H[n]=E[0],H[n+1]=E[1],H[n+2]=E[2],H[n+3]=E[3],H[n+4]=E[4],H[n+5]=E[5],H[n+6]=E[6],H[n+7]=E[7],H[n+8]=E[8],H[n+9]=E[9],H[n+10]=E[10],H[n+11]=E[11],H[n+12]=E[12],H[n+13]=E[13],H[n+14]=E[14],H[n+15]=E[15]}function A(o,H){const n=o.bg(),E=n[0],k=n[1],g=n[2],O=n[3],Y=n[4],y=n[5],S=n[6],G=n[7],c=n[8],A=n[9],l=n[10],x=n[11],z=n[12],V=n[13],J=n[14],N=n[15],h=l*N-J*x,Q=A*N-V*x,p=A*J-V*l,j=c*N-z*x,m=c*J-l*z,P=c*V-z*A,b=+(y*h-S*Q+G*p),e=-(Y*h-S*j+G*m),Z=+(Y*Q-y*j+G*P),M=-(Y*p-y*m+S*P),K=E*b+k*e+g*Z+O*M;if(0===K)return!1;const f=1/K,B=S*N-J*G,q=y*N-V*G,D=y*J-V*S,T=Y*N-z*G,a=Y*J-z*S,F=Y*V-z*y,C=S*x-l*G,t=y*x-A*G,X=y*l-A*S,s=Y*x-c*G,U=Y*l-c*S,I=Y*A-c*y,v=-(k*h-g*Q+O*p),w=+(E*h-g*j+O*m),r=-(E*Q-k*j+O*P),u=+(E*p-k*m+g*P),d=+(k*B-g*q+O*D),R=-(E*B-g*T+O*a),W=+(E*q-k*T+O*F),i=-(E*D-k*a+g*F),L=-(k*C-g*t+O*X),oo=+(E*C-g*s+O*U),Ho=-(E*t-k*s+O*I),no=+(E*X-k*U+g*I);return H[0]=b*f,H[1]=v*f,H[2]=d*f,H[3]=L*f,H[4]=e*f,H[5]=w*f,H[6]=R*f,H[7]=oo*f,H[8]=Z*f,H[9]=r*f,H[10]=W*f,H[11]=Ho*f,H[12]=M*f,H[13]=u*f,H[14]=i*f,H[15]=no*f,!0}S._UpdateFlagSeed=0;const l=o=>parseInt(o.toString().replace(/\W/g,""));class x{constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=o,this.y=H}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let o=l(this.x);return o=397*o^l(this.y),o}toArray(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o[H]=this.x,o[H+1]=this.y,this}An(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return x.FromArrayToRef(o,H,this),this}bg(){return[this.x,this.y]}S(o){return this.x=o.x,this.y=o.y,this}Wg(o,H){return this.x=o,this.y=H,this}set(o,H){return this.Wg(o,H)}AY(o){return this.Wg(o,o)}add(o){return new x(this.x+o.x,this.y+o.y)}addToRef(o,H){return H.x=this.x+o.x,H.y=this.y+o.y,H}addInPlace(o){return this.x+=o.x,this.y+=o.y,this}addInPlaceFromFloats(o,H){return this.x+=o,this.y+=H,this}addVector3(o){return new x(this.x+o.x,this.y+o.y)}zH(o){return new x(this.x-o.x,this.y-o.y)}subtractToRef(o,H){return H.x=this.x-o.x,H.y=this.y-o.y,H}tG(o){return this.x-=o.x,this.y-=o.y,this}multiplyInPlace(o){return this.x*=o.x,this.y*=o.y,this}multiply(o){return new x(this.x*o.x,this.y*o.y)}multiplyToRef(o,H){return H.x=this.x*o.x,H.y=this.y*o.y,H}multiplyByFloats(o,H){return new x(this.x*o,this.y*H)}divide(o){return new x(this.x/o.x,this.y/o.y)}divideToRef(o,H){return H.x=this.x/o.x,H.y=this.y/o.y,H}divideInPlace(o){return this.x=this.x/o.x,this.y=this.y/o.y,this}minimizeInPlace(o){return this.minimizeInPlaceFromFloats(o.x,o.y)}maximizeInPlace(o){return this.maximizeInPlaceFromFloats(o.x,o.y)}minimizeInPlaceFromFloats(o,H){return this.x=Math.min(o,this.x),this.y=Math.min(H,this.y),this}maximizeInPlaceFromFloats(o,H){return this.x=Math.max(o,this.x),this.y=Math.max(H,this.y),this}subtractFromFloats(o,H){return new x(this.x-o,this.y-H)}subtractFromFloatsToRef(o,H,n){return n.x=this.x-o,n.y=this.y-H,n}negate(){return new x(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(o){return o.x=-this.x,o.y=-this.y,o}scaleInPlace(o){return this.x*=o,this.y*=o,this}scale(o){return new x(this.x*o,this.y*o)}scaleToRef(o,H){return H.x=this.x*o,H.y=this.y*o,H}scaleAndAddToRef(o,H){return H.x+=this.x*o,H.y+=this.y*o,H}equals(o){return o&&this.x===o.x&&this.y===o.y}equalsWithEpsilon(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:E.e;return o&&(0,y.WithinEpsilon)(this.x,o.x,H)&&(0,y.WithinEpsilon)(this.y,o.y,H)}equalsToFloats(o,H){return this.x===o&&this.y===H}floor(){return new x(Math.floor(this.x),Math.floor(this.y))}floorToRef(o){return o.x=Math.floor(this.x),o.y=Math.floor(this.y),o}fract(){return new x(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(o){return o.x=this.x-Math.floor(this.x),o.y=this.y-Math.floor(this.y),o}rotate(o){return this.rotateToRef(o,new x)}rotateToRef(o,H){const n=Math.cos(o),E=Math.sin(o);return H.x=n*this.x-E*this.y,H.y=E*this.x+n*this.y,H}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(o){return 0===o||1===o?this:this.scaleInPlace(1/o)}normalizeToNew(){const o=new x;return this.normalizeToRef(o),o}normalizeToRef(o){const H=this.length();return 0===H&&(o.x=this.x,o.y=this.y),this.scaleToRef(1/H,o)}clone(){return new x(this.x,this.y)}dot(o){return this.x*o.x+this.y*o.y}static Zero(){return new x(0,0)}static One(){return new x(1,1)}static Random(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new x((0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H))}static RandomToRef(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Wg((0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H))}static get ZeroReadOnly(){return x._ZeroReadOnly}static Mg(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new x(o[H],o[H+1])}static FromArrayToRef(o,H,n){return n.x=o[H],n.y=o[H+1],n}static FromFloatsToRef(o,H,n){return n.Wg(o,H),n}static CatmullRom(o,H,n,E,k){const g=k*k,O=k*g,Y=.5*(2*H.x+(-o.x+n.x)*k+(2*o.x-5*H.x+4*n.x-E.x)*g+(-o.x+3*H.x-3*n.x+E.x)*O),y=.5*(2*H.y+(-o.y+n.y)*k+(2*o.y-5*H.y+4*n.y-E.y)*g+(-o.y+3*H.y-3*n.y+E.y)*O);return new x(Y,y)}static ClampToRef(o,H,n,E){return E.x=(0,y.Clamp)(o.x,H.x,n.x),E.y=(0,y.Clamp)(o.y,H.y,n.y),E}static Clamp(o,H,n){const E=(0,y.Clamp)(o.x,H.x,n.x),k=(0,y.Clamp)(o.y,H.y,n.y);return new x(E,k)}static Hermite(o,H,n,E,k){const g=k*k,O=k*g,Y=2*O-3*g+1,y=-2*O+3*g,S=O-2*g+k,G=O-g,c=o.x*Y+n.x*y+H.x*S+E.x*G,A=o.y*Y+n.y*y+H.y*S+E.y*G;return new x(c,A)}static Hermite1stDerivative(o,H,n,E,k){return this.Hermite1stDerivativeToRef(o,H,n,E,k,new x)}static Hermite1stDerivativeToRef(o,H,n,E,k,g){const O=k*k;return g.x=6*(O-k)*o.x+(3*O-4*k+1)*H.x+6*(-O+k)*n.x+(3*O-2*k)*E.x,g.y=6*(O-k)*o.y+(3*O-4*k+1)*H.y+6*(-O+k)*n.y+(3*O-2*k)*E.y,g}static Lerp(o,H,n){return x.LerpToRef(o,H,n,new x)}static LerpToRef(o,H,n,E){return E.x=o.x+(H.x-o.x)*n,E.y=o.y+(H.y-o.y)*n,E}static Dot(o,H){return o.x*H.x+o.y*H.y}static Normalize(o){return x.NormalizeToRef(o,new x)}static NormalizeToRef(o,H){return o.normalizeToRef(H),H}static Minimize(o,H){const n=o.x<H.x?o.x:H.x,E=o.y<H.y?o.y:H.y;return new x(n,E)}static Maximize(o,H){const n=o.x>H.x?o.x:H.x,E=o.y>H.y?o.y:H.y;return new x(n,E)}static Transform(o,H){return x.TransformToRef(o,H,new x)}static TransformToRef(o,H,n){const E=H.m,k=o.x*E[0]+o.y*E[4]+E[12],g=o.x*E[1]+o.y*E[5]+E[13];return n.x=k,n.y=g,n}static PointInTriangle(o,H,n,E){const k=.5*(-n.y*E.x+H.y*(-n.x+E.x)+H.x*(n.y-E.y)+n.x*E.y),g=k<0?-1:1,O=(H.y*E.x-H.x*E.y+(E.y-H.y)*o.x+(H.x-E.x)*o.y)*g,Y=(H.x*n.y-H.y*n.x+(H.y-n.y)*o.x+(n.x-H.x)*o.y)*g;return O>0&&Y>0&&O+Y<2*k*g}static Distance(o,H){return Math.sqrt(x.DistanceSquared(o,H))}static DistanceSquared(o,H){const n=o.x-H.x,E=o.y-H.y;return n*n+E*E}static Center(o,H){return x.CenterToRef(o,H,new x)}static CenterToRef(o,H,n){return n.Wg((o.x+H.x)/2,(o.y+H.y)/2)}static DistanceOfPointFromSegment(o,H,n){const E=x.DistanceSquared(H,n);if(0===E)return x.Distance(o,H);const k=n.zH(H),g=Math.max(0,Math.min(1,x.Dot(o.zH(H),k)/E)),O=H.add(k.multiplyByFloats(g,g));return x.Distance(o,O)}}x._V8PerformanceHack=new x(.5,.5),x._ZeroReadOnly=x.Zero(),Object.defineProperties(x.prototype,{dimension:{value:[2]},rank:{value:1}});class z{get x(){return this._x}set x(o){this._x=o,this._isDirty=!0}get y(){return this._y}set y(o){this._y=o,this._isDirty=!0}get z(){return this._z}set z(o){this._z=o,this._isDirty=!0}constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=o,this._y=H,this._z=n}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"xH"}getHashCode(){let o=l(this._x);return o=397*o^l(this._y),o=397*o^l(this._z),o}bg(){return[this._x,this._y,this._z]}toArray(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o[H]=this._x,o[H+1]=this._y,o[H+2]=this._z,this}An(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z.FromArrayToRef(o,H,this),this}toQuaternion(){return J.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(o){return this._x+=o._x,this._y+=o._y,this._z+=o._z,this._isDirty=!0,this}addInPlaceFromFloats(o,H,n){return this._x+=o,this._y+=H,this._z+=n,this._isDirty=!0,this}add(o){return new z(this._x+o._x,this._y+o._y,this._z+o._z)}addToRef(o,H){return H._x=this._x+o._x,H._y=this._y+o._y,H._z=this._z+o._z,H._isDirty=!0,H}tG(o){return this._x-=o._x,this._y-=o._y,this._z-=o._z,this._isDirty=!0,this}zH(o){return new z(this._x-o._x,this._y-o._y,this._z-o._z)}subtractToRef(o,H){return this.subtractFromFloatsToRef(o._x,o._y,o._z,H)}subtractFromFloats(o,H,n){return new z(this._x-o,this._y-H,this._z-n)}subtractFromFloatsToRef(o,H,n,E){return E._x=this._x-o,E._y=this._y-H,E._z=this._z-n,E._isDirty=!0,E}negate(){return new z(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(o){return o._x=-1*this._x,o._y=-1*this._y,o._z=-1*this._z,o._isDirty=!0,o}scaleInPlace(o){return this._x*=o,this._y*=o,this._z*=o,this._isDirty=!0,this}scale(o){return new z(this._x*o,this._y*o,this._z*o)}scaleToRef(o,H){return H._x=this._x*o,H._y=this._y*o,H._z=this._z*o,H._isDirty=!0,H}getNormalToRef(o){const H=this.length();let n=Math.acos(this._y/H);const E=Math.atan2(this._z,this._x);n>Math.PI/2?n-=Math.PI/2:n+=Math.PI/2;const k=H*Math.sin(n)*Math.cos(E),g=H*Math.cos(n),O=H*Math.sin(n)*Math.sin(E);return o.set(k,g,O),o}applyRotationQuaternionToRef(o,H){const n=this._x,E=this._y,k=this._z,g=o._x,O=o._y,Y=o._z,y=o._w,S=2*(O*k-Y*E),G=2*(Y*n-g*k),c=2*(g*E-O*n);return H._x=n+y*S+O*c-Y*G,H._y=E+y*G+Y*S-g*c,H._z=k+y*c+g*G-O*S,H._isDirty=!0,H}applyRotationQuaternionInPlace(o){return this.applyRotationQuaternionToRef(o,this)}applyRotationQuaternion(o){return this.applyRotationQuaternionToRef(o,new z)}scaleAndAddToRef(o,H){return H._x+=this._x*o,H._y+=this._y*o,H._z+=this._z*o,H._isDirty=!0,H}projectOnPlane(o,H){return this.projectOnPlaneToRef(o,H,new z)}projectOnPlaneToRef(o,H,n){const E=o.normal,k=o.d,g=h.xH[0];this.subtractToRef(H,g),g.normalize();const O=z.Dot(g,E);if(Math.abs(O)<1e-10)n.AY(1/0);else{const o=-(z.Dot(H,E)+k)/O,Y=g.scaleInPlace(o);H.addToRef(Y,n)}return n}equals(o){return o&&this._x===o._x&&this._y===o._y&&this._z===o._z}equalsWithEpsilon(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:E.e;return o&&(0,y.WithinEpsilon)(this._x,o._x,H)&&(0,y.WithinEpsilon)(this._y,o._y,H)&&(0,y.WithinEpsilon)(this._z,o._z,H)}equalsToFloats(o,H,n){return this._x===o&&this._y===H&&this._z===n}multiplyInPlace(o){return this._x*=o._x,this._y*=o._y,this._z*=o._z,this._isDirty=!0,this}multiply(o){return this.multiplyByFloats(o._x,o._y,o._z)}multiplyToRef(o,H){return H._x=this._x*o._x,H._y=this._y*o._y,H._z=this._z*o._z,H._isDirty=!0,H}multiplyByFloats(o,H,n){return new z(this._x*o,this._y*H,this._z*n)}divide(o){return new z(this._x/o._x,this._y/o._y,this._z/o._z)}divideToRef(o,H){return H._x=this._x/o._x,H._y=this._y/o._y,H._z=this._z/o._z,H._isDirty=!0,H}divideInPlace(o){return this._x=this._x/o._x,this._y=this._y/o._y,this._z=this._z/o._z,this._isDirty=!0,this}minimizeInPlace(o){return this.minimizeInPlaceFromFloats(o._x,o._y,o._z)}maximizeInPlace(o){return this.maximizeInPlaceFromFloats(o._x,o._y,o._z)}minimizeInPlaceFromFloats(o,H,n){return o<this._x&&(this.x=o),H<this._y&&(this.y=H),n<this._z&&(this.z=n),this}maximizeInPlaceFromFloats(o,H,n){return o>this._x&&(this.x=o),H>this._y&&(this.y=H),n>this._z&&(this.z=n),this}isNonUniformWithinEpsilon(o){const H=Math.abs(this._x),n=Math.abs(this._y);if(!(0,y.WithinEpsilon)(H,n,o))return!0;const E=Math.abs(this._z);return!(0,y.WithinEpsilon)(H,E,o)||!(0,y.WithinEpsilon)(n,E,o)}get isNonUniform(){const o=Math.abs(this._x);if(o!==Math.abs(this._y))return!0;return o!==Math.abs(this._z)}floorToRef(o){return o._x=Math.floor(this._x),o._y=Math.floor(this._y),o._z=Math.floor(this._z),o._isDirty=!0,o}floor(){return new z(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(o){return o._x=this._x-Math.floor(this._x),o._y=this._y-Math.floor(this._y),o._z=this._z-Math.floor(this._z),o._isDirty=!0,o}fract(){return new z(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(o){if("xyz"===(o=o.toLowerCase()))return this;const H=h.xH[0].S(this);return this.x=H[o[0]],this.y=H[o[1]],this.z=H[o[2]],this}rotateByQuaternionToRef(o,H){return o.toRotationMatrix(h.Matrix[0]),z.TransformCoordinatesToRef(this,h.Matrix[0],H),H}rotateByQuaternionAroundPointToRef(o,H,n){return this.subtractToRef(H,h.xH[0]),h.xH[0].rotateByQuaternionToRef(o,h.xH[0]),H.addToRef(h.xH[0],n),n}cross(o){return z.CrossToRef(this,o,new z)}normalizeFromLength(o){return 0===o||1===o?this:this.scaleInPlace(1/o)}normalizeToNew(){return this.normalizeToRef(new z)}normalizeToRef(o){const H=this.length();return 0===H||1===H?(o._x=this._x,o._y=this._y,o._z=this._z,o._isDirty=!0,o):this.scaleToRef(1/H,o)}clone(){return new z(this._x,this._y,this._z)}S(o){return this.Wg(o._x,o._y,o._z)}Wg(o,H,n){return this._x=o,this._y=H,this._z=n,this._isDirty=!0,this}set(o,H,n){return this.Wg(o,H,n)}AY(o){return this._x=this._y=this._z=o,this._isDirty=!0,this}static GetClipFactor(o,H,n,E){const k=z.Dot(o,n);return(k-E)/(k-z.Dot(H,n))}static GetAngleBetweenVectors(o,H,n){const E=o.normalizeToRef(h.xH[1]),k=H.normalizeToRef(h.xH[2]);let g=z.Dot(E,k);g=(0,y.Clamp)(g,-1,1);const O=Math.acos(g),Y=h.xH[3];return z.CrossToRef(E,k,Y),z.Dot(Y,n)>0?isNaN(O)?0:O:isNaN(O)?-Math.PI:-Math.acos(g)}static GetAngleBetweenVectorsOnPlane(o,H,n){h.xH[0].S(o);const E=h.xH[0];h.xH[1].S(H);const k=h.xH[1];h.xH[2].S(n);const g=h.xH[2],O=h.xH[3],Y=h.xH[4];E.normalize(),k.normalize(),g.normalize(),z.CrossToRef(g,E,O),z.CrossToRef(O,g,Y);const S=Math.atan2(z.Dot(k,O),z.Dot(k,Y));return(0,y.NormalizeRadians)(S)}static PitchYawRollToMoveBetweenPointsToRef(o,H,n){const E=Q.xH[0];return H.subtractToRef(o,E),n._y=Math.atan2(E.x,E.z)||0,n._x=Math.atan2(Math.sqrt(E.x**2+E.z**2),E.y)||0,n._z=0,n._isDirty=!0,n}static PitchYawRollToMoveBetweenPoints(o,H){const n=z.Zero();return z.PitchYawRollToMoveBetweenPointsToRef(o,H,n)}static SlerpToRef(o,H,n,k){n=(0,y.Clamp)(n,0,1);const g=h.xH[0],O=h.xH[1];g.S(o);const Y=g.length();g.normalizeFromLength(Y),O.S(H);const S=O.length();O.normalizeFromLength(S);const G=z.Dot(g,O);let c,A;if(G<1-E.e){const o=Math.acos(G),H=1/Math.sin(o);c=Math.sin((1-n)*o)*H,A=Math.sin(n*o)*H}else c=1-n,A=n;return g.scaleInPlace(c),O.scaleInPlace(A),k.S(g).addInPlace(O),k.scaleInPlace((0,y.Lerp)(Y,S,n)),k}static SmoothToRef(o,H,n,E,k){return z.SlerpToRef(o,H,0===E?1:n/E,k),k}static Mg(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new z(o[H],o[H+1],o[H+2])}static FromFloatArray(o,H){return z.Mg(o,H)}static FromArrayToRef(o,H,n){return n._x=o[H],n._y=o[H+1],n._z=o[H+2],n._isDirty=!0,n}static FromFloatArrayToRef(o,H,n){return z.FromArrayToRef(o,H,n)}static FromFloatsToRef(o,H,n,E){return E.Wg(o,H,n),E}static Zero(){return new z(0,0,0)}static One(){return new z(1,1,1)}static Up(){return new z(0,1,0)}static get UpReadOnly(){return z._UpReadOnly}static get DownReadOnly(){return z._DownReadOnly}static get RightReadOnly(){return z._RightReadOnly}static get LeftReadOnly(){return z._LeftReadOnly}static get LeftHandedForwardReadOnly(){return z._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return z._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return z._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return z._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return z._ZeroReadOnly}static get OneReadOnly(){return z._OneReadOnly}static Down(){return new z(0,-1,0)}static Forward(){return new z(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new z(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new z(1,0,0)}static Left(){return new z(-1,0,0)}static Random(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new z((0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H))}static RandomToRef(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Wg((0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H))}static TransformCoordinates(o,H){const n=z.Zero();return z.TransformCoordinatesToRef(o,H,n),n}static TransformCoordinatesToRef(o,H,n){return z.TransformCoordinatesFromFloatsToRef(o._x,o._y,o._z,H,n),n}static TransformCoordinatesFromFloatsToRef(o,H,n,E,k){const g=E.m,O=o*g[0]+H*g[4]+n*g[8]+g[12],Y=o*g[1]+H*g[5]+n*g[9]+g[13],y=o*g[2]+H*g[6]+n*g[10]+g[14],S=1/(o*g[3]+H*g[7]+n*g[11]+g[15]);return k._x=O*S,k._y=Y*S,k._z=y*S,k._isDirty=!0,k}static TransformNormal(o,H){const n=z.Zero();return z.TransformNormalToRef(o,H,n),n}static TransformNormalToRef(o,H,n){return this.TransformNormalFromFloatsToRef(o._x,o._y,o._z,H,n),n}static TransformNormalFromFloatsToRef(o,H,n,E,k){const g=E.m;return k._x=o*g[0]+H*g[4]+n*g[8],k._y=o*g[1]+H*g[5]+n*g[9],k._z=o*g[2]+H*g[6]+n*g[10],k._isDirty=!0,k}static CatmullRom(o,H,n,E,k){const g=k*k,O=k*g,Y=.5*(2*H._x+(-o._x+n._x)*k+(2*o._x-5*H._x+4*n._x-E._x)*g+(-o._x+3*H._x-3*n._x+E._x)*O),y=.5*(2*H._y+(-o._y+n._y)*k+(2*o._y-5*H._y+4*n._y-E._y)*g+(-o._y+3*H._y-3*n._y+E._y)*O),S=.5*(2*H._z+(-o._z+n._z)*k+(2*o._z-5*H._z+4*n._z-E._z)*g+(-o._z+3*H._z-3*n._z+E._z)*O);return new z(Y,y,S)}static Clamp(o,H,n){const E=new z;return z.ClampToRef(o,H,n,E),E}static ClampToRef(o,H,n,E){let k=o._x;k=k>n._x?n._x:k,k=k<H._x?H._x:k;let g=o._y;g=g>n._y?n._y:g,g=g<H._y?H._y:g;let O=o._z;return O=O>n._z?n._z:O,O=O<H._z?H._z:O,E.Wg(k,g,O),E}static CheckExtends(o,H,n){H.minimizeInPlace(o),n.maximizeInPlace(o)}static Hermite(o,H,n,E,k){const g=k*k,O=k*g,Y=2*O-3*g+1,y=-2*O+3*g,S=O-2*g+k,G=O-g,c=o._x*Y+n._x*y+H._x*S+E._x*G,A=o._y*Y+n._y*y+H._y*S+E._y*G,l=o._z*Y+n._z*y+H._z*S+E._z*G;return new z(c,A,l)}static Hermite1stDerivative(o,H,n,E,k){const g=new z;return this.Hermite1stDerivativeToRef(o,H,n,E,k,g),g}static Hermite1stDerivativeToRef(o,H,n,E,k,g){const O=k*k;return g._x=6*(O-k)*o._x+(3*O-4*k+1)*H._x+6*(-O+k)*n._x+(3*O-2*k)*E._x,g._y=6*(O-k)*o._y+(3*O-4*k+1)*H._y+6*(-O+k)*n._y+(3*O-2*k)*E._y,g._z=6*(O-k)*o._z+(3*O-4*k+1)*H._z+6*(-O+k)*n._z+(3*O-2*k)*E._z,g._isDirty=!0,g}static Lerp(o,H,n){const E=new z(0,0,0);return z.LerpToRef(o,H,n,E),E}static LerpToRef(o,H,n,E){return E._x=o._x+(H._x-o._x)*n,E._y=o._y+(H._y-o._y)*n,E._z=o._z+(H._z-o._z)*n,E._isDirty=!0,E}static Dot(o,H){return o._x*H._x+o._y*H._y+o._z*H._z}dot(o){return this._x*o._x+this._y*o._y+this._z*o._z}static Cross(o,H){const n=new z;return z.CrossToRef(o,H,n),n}static CrossToRef(o,H,n){const E=o._y*H._z-o._z*H._y,k=o._z*H._x-o._x*H._z,g=o._x*H._y-o._y*H._x;return n.Wg(E,k,g),n}static Normalize(o){const H=z.Zero();return z.NormalizeToRef(o,H),H}static NormalizeToRef(o,H){return o.normalizeToRef(H),H}static Project(o,H,n,E){const k=new z;return z.ProjectToRef(o,H,n,E,k),k}static ProjectToRef(o,H,n,E,k){var g;const O=E.width,y=E.height,S=E.x,G=E.y,c=h.Matrix[1],A=null===(g=Y.e.LastCreatedEngine)||void 0===g?void 0:g.isNDCHalfZRange,l=A?1:.5,x=A?0:.5;N.FromValuesToRef(O/2,0,0,0,0,-y/2,0,0,0,0,l,0,S+O/2,y/2+G,x,1,c);const V=h.Matrix[0];return H.multiplyToRef(n,V),V.multiplyToRef(c,V),z.TransformCoordinatesToRef(o,V,k),k}static Reflect(o,H){return this.ReflectToRef(o,H,new z)}static ReflectToRef(o,H,n){const E=Q.xH[0];return E.S(H).scaleInPlace(2*z.Dot(o,H)),n.S(o).tG(E)}static _UnprojectFromInvertedMatrixToRef(o,H,n){z.TransformCoordinatesToRef(o,H,n);const E=H.m,k=o._x*E[3]+o._y*E[7]+o._z*E[11]+E[15];return(0,y.WithinEpsilon)(k,1)&&n.scaleInPlace(1/k),n}static UnprojectFromTransform(o,H,n,E,k){return this.Unproject(o,H,n,E,k,N.IdentityReadOnly)}static Unproject(o,H,n,E,k,g){const O=new z;return z.UnprojectToRef(o,H,n,E,k,g,O),O}static UnprojectToRef(o,H,n,E,k,g,O){return z.UnprojectFloatsToRef(o._x,o._y,o._z,H,n,E,k,g,O),O}static UnprojectFloatsToRef(o,H,n,E,k,g,O,y,S){var G;const c=h.Matrix[0];g.multiplyToRef(O,c),c.multiplyToRef(y,c),c.invert();const A=h.xH[0];return A.x=o/E*2-1,A.y=-(H/k*2-1),null!==(G=Y.e.LastCreatedEngine)&&void 0!==G&&G.isNDCHalfZRange?A.z=n:A.z=2*n-1,z._UnprojectFromInvertedMatrixToRef(A,c,S),S}static Minimize(o,H){const n=new z;return n.S(o),n.minimizeInPlace(H),n}static Maximize(o,H){const n=new z;return n.S(o),n.maximizeInPlace(H),n}static Distance(o,H){return Math.sqrt(z.DistanceSquared(o,H))}static DistanceSquared(o,H){const n=o._x-H._x,E=o._y-H._y,k=o._z-H._z;return n*n+E*E+k*k}static ProjectOnTriangleToRef(o,H,n,k,g){const O=h.xH[0],Y=h.xH[1],S=h.xH[2],G=h.xH[3],c=h.xH[4];n.subtractToRef(H,O),k.subtractToRef(H,Y),k.subtractToRef(n,S);const A=O.length(),l=Y.length(),x=S.length();if(A<E.e||l<E.e||x<E.e)return g.S(H),z.Distance(o,H);o.subtractToRef(H,c),z.CrossToRef(O,Y,G);const V=G.length();if(V<E.e)return g.S(H),z.Distance(o,H);G.normalizeFromLength(V);let J=c.length();if(J<E.e)return g.S(H),0;c.normalizeFromLength(J);const N=z.Dot(G,c),Q=h.xH[5],p=h.xH[6];Q.S(G).scaleInPlace(-J*N),p.S(o).addInPlace(Q);const j=h.xH[4],m=h.xH[5],P=h.xH[7],b=h.xH[8];j.S(O).scaleInPlace(1/A),b.S(Y).scaleInPlace(1/l),j.addInPlace(b).scaleInPlace(-1),m.S(O).scaleInPlace(-1/A),b.S(S).scaleInPlace(1/x),m.addInPlace(b).scaleInPlace(-1),P.S(S).scaleInPlace(-1/x),b.S(Y).scaleInPlace(-1/l),P.addInPlace(b).scaleInPlace(-1);const e=h.xH[9];let Z;e.S(p).tG(H),z.CrossToRef(j,e,b),Z=z.Dot(b,G);const M=Z;e.S(p).tG(n),z.CrossToRef(m,e,b),Z=z.Dot(b,G);const K=Z;e.S(p).tG(k),z.CrossToRef(P,e,b),Z=z.Dot(b,G);const f=Z,B=h.xH[10];let q,D;M>0&&K<0?(B.S(O),q=H,D=n):K>0&&f<0?(B.S(S),q=n,D=k):(B.S(Y).scaleInPlace(-1),q=k,D=H);const T=h.xH[9],a=h.xH[4];q.subtractToRef(p,b),D.subtractToRef(p,T),z.CrossToRef(b,T,a);if(!(z.Dot(a,G)<0))return g.S(p),Math.abs(J*N);const F=h.xH[5];z.CrossToRef(B,a,F),F.normalize();const C=h.xH[9];C.S(q).tG(p);const t=C.length();if(t<E.e)return g.S(q),z.Distance(o,q);C.normalizeFromLength(t);const X=z.Dot(F,C),s=h.xH[7];s.S(p).addInPlace(F.scaleInPlace(t*X)),b.S(s).tG(q),J=B.length(),B.normalizeFromLength(J);let U=z.Dot(b,B)/Math.max(J,E.e);return U=(0,y.Clamp)(U,0,1),s.S(q).addInPlace(B.scaleInPlace(U*J)),g.S(s),z.Distance(o,s)}static Center(o,H){return z.CenterToRef(o,H,z.Zero())}static CenterToRef(o,H,n){return n.Wg((o._x+H._x)/2,(o._y+H._y)/2,(o._z+H._z)/2)}static RotationFromAxis(o,H,n){const E=new z;return z.RotationFromAxisToRef(o,H,n,E),E}static RotationFromAxisToRef(o,H,n,E){const k=h.Quaternion[0];return J.RotationQuaternionFromAxisToRef(o,H,n,k),k.toEulerAnglesToRef(E),E}}z._V8PerformanceHack=new z(.5,.5,.5),z._UpReadOnly=z.Up(),z._DownReadOnly=z.Down(),z._LeftHandedForwardReadOnly=z.Forward(!1),z._RightHandedForwardReadOnly=z.Forward(!0),z._LeftHandedBackwardReadOnly=z.Backward(!1),z._RightHandedBackwardReadOnly=z.Backward(!0),z._RightReadOnly=z.Right(),z._LeftReadOnly=z.Left(),z._ZeroReadOnly=z.Zero(),z._OneReadOnly=z.One(),Object.defineProperties(z.prototype,{dimension:{value:[3]},rank:{value:1}});class V{get x(){return this._x}set x(o){this._x=o,this._isDirty=!0}get y(){return this._y}set y(o){this._y=o,this._isDirty=!0}get z(){return this._z}set z(o){this._z=o,this._isDirty=!0}get w(){return this._w}set w(o){this._w=o,this._isDirty=!0}constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=o,this._y=H,this._z=n,this._w=E}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let o=l(this._x);return o=397*o^l(this._y),o=397*o^l(this._z),o=397*o^l(this._w),o}bg(){return[this._x,this._y,this._z,this._w]}toArray(o,H){return void 0===H&&(H=0),o[H]=this._x,o[H+1]=this._y,o[H+2]=this._z,o[H+3]=this._w,this}An(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V.FromArrayToRef(o,H,this),this}addInPlace(o){return this.x+=o._x,this.y+=o._y,this.z+=o._z,this.w+=o._w,this}addInPlaceFromFloats(o,H,n,E){return this.x+=o,this.y+=H,this.z+=n,this.w+=E,this}add(o){return new V(this._x+o.x,this._y+o.y,this._z+o.z,this._w+o.w)}addToRef(o,H){return H.x=this._x+o.x,H.y=this._y+o.y,H.z=this._z+o.z,H.w=this._w+o.w,H}tG(o){return this.x-=o.x,this.y-=o.y,this.z-=o.z,this.w-=o.w,this}zH(o){return new V(this._x-o.x,this._y-o.y,this._z-o.z,this._w-o.w)}subtractToRef(o,H){return H.x=this._x-o.x,H.y=this._y-o.y,H.z=this._z-o.z,H.w=this._w-o.w,H}subtractFromFloats(o,H,n,E){return new V(this._x-o,this._y-H,this._z-n,this._w-E)}subtractFromFloatsToRef(o,H,n,E,k){return k.x=this._x-o,k.y=this._y-H,k.z=this._z-n,k.w=this._w-E,k}negate(){return new V(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(o){return o.x=-this._x,o.y=-this._y,o.z=-this._z,o.w=-this._w,o}scaleInPlace(o){return this.x*=o,this.y*=o,this.z*=o,this.w*=o,this}scale(o){return new V(this._x*o,this._y*o,this._z*o,this._w*o)}scaleToRef(o,H){return H.x=this._x*o,H.y=this._y*o,H.z=this._z*o,H.w=this._w*o,H}scaleAndAddToRef(o,H){return H.x+=this._x*o,H.y+=this._y*o,H.z+=this._z*o,H.w+=this._w*o,H}equals(o){return o&&this._x===o.x&&this._y===o.y&&this._z===o.z&&this._w===o.w}equalsWithEpsilon(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:E.e;return o&&(0,y.WithinEpsilon)(this._x,o.x,H)&&(0,y.WithinEpsilon)(this._y,o.y,H)&&(0,y.WithinEpsilon)(this._z,o.z,H)&&(0,y.WithinEpsilon)(this._w,o.w,H)}equalsToFloats(o,H,n,E){return this._x===o&&this._y===H&&this._z===n&&this._w===E}multiplyInPlace(o){return this.x*=o.x,this.y*=o.y,this.z*=o.z,this.w*=o.w,this}multiply(o){return new V(this._x*o.x,this._y*o.y,this._z*o.z,this._w*o.w)}multiplyToRef(o,H){return H.x=this._x*o.x,H.y=this._y*o.y,H.z=this._z*o.z,H.w=this._w*o.w,H}multiplyByFloats(o,H,n,E){return new V(this._x*o,this._y*H,this._z*n,this._w*E)}divide(o){return new V(this._x/o.x,this._y/o.y,this._z/o.z,this._w/o.w)}divideToRef(o,H){return H.x=this._x/o.x,H.y=this._y/o.y,H.z=this._z/o.z,H.w=this._w/o.w,H}divideInPlace(o){return this.divideToRef(o,this)}minimizeInPlace(o){return o.x<this._x&&(this.x=o.x),o.y<this._y&&(this.y=o.y),o.z<this._z&&(this.z=o.z),o.w<this._w&&(this.w=o.w),this}maximizeInPlace(o){return o.x>this._x&&(this.x=o.x),o.y>this._y&&(this.y=o.y),o.z>this._z&&(this.z=o.z),o.w>this._w&&(this.w=o.w),this}minimizeInPlaceFromFloats(o,H,n,E){return this.x=Math.min(o,this._x),this.y=Math.min(H,this._y),this.z=Math.min(n,this._z),this.w=Math.min(E,this._w),this}maximizeInPlaceFromFloats(o,H,n,E){return this.x=Math.max(o,this._x),this.y=Math.max(H,this._y),this.z=Math.max(n,this._z),this.w=Math.max(E,this._w),this}floorToRef(o){return o.x=Math.floor(this._x),o.y=Math.floor(this._y),o.z=Math.floor(this._z),o.w=Math.floor(this._w),o}floor(){return new V(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(o){return o.x=this._x-Math.floor(this._x),o.y=this._y-Math.floor(this._y),o.z=this._z-Math.floor(this._z),o.w=this._w-Math.floor(this._w),o}fract(){return new V(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(o){return 0===o||1===o?this:this.scaleInPlace(1/o)}normalizeToNew(){return this.normalizeToRef(new V)}normalizeToRef(o){const H=this.length();return 0===H||1===H?(o.x=this._x,o.y=this._y,o.z=this._z,o.w=this._w,o):this.scaleToRef(1/H,o)}toVector3(){return new z(this._x,this._y,this._z)}clone(){return new V(this._x,this._y,this._z,this._w)}S(o){return this.x=o.x,this.y=o.y,this.z=o.z,this.w=o.w,this}Wg(o,H,n,E){return this.x=o,this.y=H,this.z=n,this.w=E,this}set(o,H,n,E){return this.Wg(o,H,n,E)}AY(o){return this.x=this.y=this.z=this.w=o,this}dot(o){return this._x*o.x+this._y*o.y+this._z*o.z+this._w*o.w}static Mg(o,H){return H||(H=0),new V(o[H],o[H+1],o[H+2],o[H+3])}static FromArrayToRef(o,H,n){return n.x=o[H],n.y=o[H+1],n.z=o[H+2],n.w=o[H+3],n}static FromFloatArrayToRef(o,H,n){return V.FromArrayToRef(o,H,n),n}static FromFloatsToRef(o,H,n,E,k){return k.x=o,k.y=H,k.z=n,k.w=E,k}static Zero(){return new V(0,0,0,0)}static One(){return new V(1,1,1,1)}static Random(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new V((0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H))}static RandomToRef(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0;return n.x=(0,y.RandomRange)(o,H),n.y=(0,y.RandomRange)(o,H),n.z=(0,y.RandomRange)(o,H),n.w=(0,y.RandomRange)(o,H),n}static Clamp(o,H,n){return V.ClampToRef(o,H,n,new V)}static ClampToRef(o,H,n,E){return E.x=(0,y.Clamp)(o.x,H.x,n.x),E.y=(0,y.Clamp)(o.y,H.y,n.y),E.z=(0,y.Clamp)(o.z,H.z,n.z),E.w=(0,y.Clamp)(o.w,H.w,n.w),E}static CheckExtends(o,H,n){H.minimizeInPlace(o),n.maximizeInPlace(o)}static get ZeroReadOnly(){return V._ZeroReadOnly}static Normalize(o){return V.NormalizeToRef(o,new V)}static NormalizeToRef(o,H){return o.normalizeToRef(H),H}static Minimize(o,H){const n=new V;return n.S(o),n.minimizeInPlace(H),n}static Maximize(o,H){const n=new V;return n.S(o),n.maximizeInPlace(H),n}static Distance(o,H){return Math.sqrt(V.DistanceSquared(o,H))}static DistanceSquared(o,H){const n=o.x-H.x,E=o.y-H.y,k=o.z-H.z,g=o.w-H.w;return n*n+E*E+k*k+g*g}static Center(o,H){return V.CenterToRef(o,H,new V)}static CenterToRef(o,H,n){return n.x=(o.x+H.x)/2,n.y=(o.y+H.y)/2,n.z=(o.z+H.z)/2,n.w=(o.w+H.w)/2,n}static TransformCoordinates(o,H){return V.TransformCoordinatesToRef(o,H,new V)}static TransformCoordinatesToRef(o,H,n){return V.TransformCoordinatesFromFloatsToRef(o._x,o._y,o._z,H,n),n}static TransformCoordinatesFromFloatsToRef(o,H,n,E,k){const g=E.m,O=o*g[0]+H*g[4]+n*g[8]+g[12],Y=o*g[1]+H*g[5]+n*g[9]+g[13],y=o*g[2]+H*g[6]+n*g[10]+g[14],S=o*g[3]+H*g[7]+n*g[11]+g[15];return k.x=O,k.y=Y,k.z=y,k.w=S,k}static TransformNormal(o,H){return V.TransformNormalToRef(o,H,new V)}static TransformNormalToRef(o,H,n){const E=H.m,k=o.x*E[0]+o.y*E[4]+o.z*E[8],g=o.x*E[1]+o.y*E[5]+o.z*E[9],O=o.x*E[2]+o.y*E[6]+o.z*E[10];return n.x=k,n.y=g,n.z=O,n.w=o.w,n}static TransformNormalFromFloatsToRef(o,H,n,E,k,g){const O=k.m;return g.x=o*O[0]+H*O[4]+n*O[8],g.y=o*O[1]+H*O[5]+n*O[9],g.z=o*O[2]+H*O[6]+n*O[10],g.w=E,g}static FromVector3(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new V(o._x,o._y,o._z,H)}static Dot(o,H){return o.x*H.x+o.y*H.y+o.z*H.z+o.w*H.w}}V._V8PerformanceHack=new V(.5,.5,.5,.5),V._ZeroReadOnly=V.Zero(),Object.defineProperties(V.prototype,{dimension:{value:[4]},rank:{value:1}});class J{get x(){return this._x}set x(o){this._x=o,this._isDirty=!0}get y(){return this._y}set y(o){this._y=o,this._isDirty=!0}get z(){return this._z}set z(o){this._z=o,this._isDirty=!0}get w(){return this._w}set w(o){this._w=o,this._isDirty=!0}constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=o,this._y=H,this._z=n,this._w=E}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let o=l(this._x);return o=397*o^l(this._y),o=397*o^l(this._z),o=397*o^l(this._w),o}bg(){return[this._x,this._y,this._z,this._w]}toArray(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o[H]=this._x,o[H+1]=this._y,o[H+2]=this._z,o[H+3]=this._w,this}An(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(o,H,this)}equals(o){return o&&this._x===o._x&&this._y===o._y&&this._z===o._z&&this._w===o._w}equalsWithEpsilon(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:E.e;return o&&(0,y.WithinEpsilon)(this._x,o._x,H)&&(0,y.WithinEpsilon)(this._y,o._y,H)&&(0,y.WithinEpsilon)(this._z,o._z,H)&&(0,y.WithinEpsilon)(this._w,o._w,H)}isApprox(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:E.e;return o&&((0,y.WithinEpsilon)(this._x,o._x,H)&&(0,y.WithinEpsilon)(this._y,o._y,H)&&(0,y.WithinEpsilon)(this._z,o._z,H)&&(0,y.WithinEpsilon)(this._w,o._w,H)||(0,y.WithinEpsilon)(this._x,-o._x,H)&&(0,y.WithinEpsilon)(this._y,-o._y,H)&&(0,y.WithinEpsilon)(this._z,-o._z,H)&&(0,y.WithinEpsilon)(this._w,-o._w,H))}clone(){return new J(this._x,this._y,this._z,this._w)}S(o){return this._x=o._x,this._y=o._y,this._z=o._z,this._w=o._w,this._isDirty=!0,this}Wg(o,H,n,E){return this._x=o,this._y=H,this._z=n,this._w=E,this._isDirty=!0,this}set(o,H,n,E){return this.Wg(o,H,n,E)}AY(o){return this.Wg(o,o,o,o)}add(o){return new J(this._x+o._x,this._y+o._y,this._z+o._z,this._w+o._w)}addInPlace(o){return this._x+=o._x,this._y+=o._y,this._z+=o._z,this._w+=o._w,this._isDirty=!0,this}addToRef(o,H){return H._x=this._x+o._x,H._y=this._y+o._y,H._z=this._z+o._z,H._w=this._w+o._w,H._isDirty=!0,H}addInPlaceFromFloats(o,H,n,E){return this._x+=o,this._y+=H,this._z+=n,this._w+=E,this._isDirty=!0,this}subtractToRef(o,H){return H._x=this._x-o._x,H._y=this._y-o._y,H._z=this._z-o._z,H._w=this._w-o._w,H._isDirty=!0,H}subtractFromFloats(o,H,n,E){return this.subtractFromFloatsToRef(o,H,n,E,new J)}subtractFromFloatsToRef(o,H,n,E,k){return k._x=this._x-o,k._y=this._y-H,k._z=this._z-n,k._w=this._w-E,k._isDirty=!0,k}zH(o){return new J(this._x-o._x,this._y-o._y,this._z-o._z,this._w-o._w)}tG(o){return this._x-=o._x,this._y-=o._y,this._z-=o._z,this._w-=o._w,this._isDirty=!0,this}scale(o){return new J(this._x*o,this._y*o,this._z*o,this._w*o)}scaleToRef(o,H){return H._x=this._x*o,H._y=this._y*o,H._z=this._z*o,H._w=this._w*o,H._isDirty=!0,H}scaleInPlace(o){return this._x*=o,this._y*=o,this._z*=o,this._w*=o,this._isDirty=!0,this}scaleAndAddToRef(o,H){return H._x+=this._x*o,H._y+=this._y*o,H._z+=this._z*o,H._w+=this._w*o,H._isDirty=!0,H}multiply(o){const H=new J(0,0,0,1);return this.multiplyToRef(o,H),H}multiplyToRef(o,H){const n=this._x*o._w+this._y*o._z-this._z*o._y+this._w*o._x,E=-this._x*o._z+this._y*o._w+this._z*o._x+this._w*o._y,k=this._x*o._y-this._y*o._x+this._z*o._w+this._w*o._z,g=-this._x*o._x-this._y*o._y-this._z*o._z+this._w*o._w;return H.Wg(n,E,k,g),H}multiplyInPlace(o){return this.multiplyToRef(o,this)}multiplyByFloats(o,H,n,E){return this._x*=o,this._y*=H,this._z*=n,this._w*=E,this._isDirty=!0,this}divide(o){throw new ReferenceError("Can not divide a quaternion")}divideToRef(o,H){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(o){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new J)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(o){return o._x=-this._x,o._y=-this._y,o._z=-this._z,o._w=-this._w,o._isDirty=!0,o}equalsToFloats(o,H,n,E){return this._x===o&&this._y===H&&this._z===n&&this._w===E}floorToRef(o){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(o){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(o){return o.Wg(-this._x,-this._y,-this._z,this._w),o}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new J(-this._x,-this._y,-this._z,this._w)}invert(){const o=this.conjugate(),H=this.lengthSquared();return 0==H||1==H||o.scaleInPlace(1/H),o}invertInPlace(){this.conjugateInPlace();const o=this.lengthSquared();return 0==o||1==o||this.scaleInPlace(1/o),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(o){return 0===o||1===o?this:this.scaleInPlace(1/o)}normalizeToNew(){const o=new J(0,0,0,1);return this.normalizeToRef(o),o}normalizeToRef(o){const H=this.length();return 0===H||1===H?o.Wg(this._x,this._y,this._z,this._w):this.scaleToRef(1/H,o)}toEulerAngles(){const o=z.Zero();return this.toEulerAnglesToRef(o),o}toEulerAnglesToRef(o){const H=this._z,n=this._x,E=this._y,k=this._w,g=E*H-n*k,O=.4999999;if(g<-O)o._y=2*Math.atan2(E,k),o._x=Math.PI/2,o._z=0,o._isDirty=!0;else if(g>O)o._y=2*Math.atan2(E,k),o._x=-Math.PI/2,o._z=0,o._isDirty=!0;else{const O=k*k,Y=H*H,y=n*n,S=E*E;o._z=Math.atan2(2*(n*E+H*k),-Y-y+S+O),o._x=Math.asin(-2*g),o._y=Math.atan2(2*(H*n+E*k),Y-y-S+O),o._isDirty=!0}return o}toAlphaBetaGammaToRef(o){const H=this._z,n=this._x,E=this._y,k=this._w,g=Math.sqrt(n*n+E*E),O=Math.sqrt(H*H+k*k),Y=2*Math.atan2(g,O),y=2*Math.atan2(H,k),S=2*Math.atan2(E,n),G=(y+S)/2,c=(y-S)/2;return o.set(c,Y,G),o}toRotationMatrix(o){return N.FromQuaternionToRef(this,o),o}fromRotationMatrix(o){return J.FromRotationMatrixToRef(o,this),this}dot(o){return this._x*o._x+this._y*o._y+this._z*o._z+this._w*o._w}toAxisAngle(){const o=z.Zero();return{axis:o,angle:this.toAxisAngleToRef(o)}}toAxisAngleToRef(o){let H=0;const n=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),E=this._w;return n>0?(H=2*Math.atan2(n,E),o.set(this._x/n,this._y/n,this._z/n)):(H=0,o.set(1,0,0)),H}static FromRotationMatrix(o){const H=new J;return J.FromRotationMatrixToRef(o,H),H}static FromRotationMatrixToRef(o,H){const n=o.m,E=n[0],k=n[4],g=n[8],O=n[1],Y=n[5],y=n[9],S=n[2],G=n[6],c=n[10],A=E+Y+c;let l;return A>0?(l=.5/Math.sqrt(A+1),H._w=.25/l,H._x=(G-y)*l,H._y=(g-S)*l,H._z=(O-k)*l,H._isDirty=!0):E>Y&&E>c?(l=2*Math.sqrt(1+E-Y-c),H._w=(G-y)/l,H._x=.25*l,H._y=(k+O)/l,H._z=(g+S)/l,H._isDirty=!0):Y>c?(l=2*Math.sqrt(1+Y-E-c),H._w=(g-S)/l,H._x=(k+O)/l,H._y=.25*l,H._z=(y+G)/l,H._isDirty=!0):(l=2*Math.sqrt(1+c-E-Y),H._w=(O-k)/l,H._x=(g+S)/l,H._y=(y+G)/l,H._z=.25*l,H._isDirty=!0),H}static Dot(o,H){return o._x*H._x+o._y*H._y+o._z*H._z+o._w*H._w}static AreClose(o,H){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const E=J.Dot(o,H);return 1-E*E<=n}static SmoothToRef(o,H,n,E,k){let g=0===E?1:n/E;return g=(0,y.Clamp)(g,0,1),J.SlerpToRef(o,H,g,k),k}static Zero(){return new J(0,0,0,0)}static Inverse(o){return new J(-o._x,-o._y,-o._z,o._w)}static InverseToRef(o,H){return H.set(-o._x,-o._y,-o._z,o._w),H}static Identity(){return new J(0,0,0,1)}static IsIdentity(o){return o&&0===o._x&&0===o._y&&0===o._z&&1===o._w}static RotationAxis(o,H){return J.RotationAxisToRef(o,H,new J)}static RotationAxisToRef(o,H,n){n._w=Math.cos(H/2);const E=Math.sin(H/2)/o.length();return n._x=o._x*E,n._y=o._y*E,n._z=o._z*E,n._isDirty=!0,n}static Mg(o,H){return H||(H=0),new J(o[H],o[H+1],o[H+2],o[H+3])}static FromArrayToRef(o,H,n){return n._x=o[H],n._y=o[H+1],n._z=o[H+2],n._w=o[H+3],n._isDirty=!0,n}static FromFloatsToRef(o,H,n,E,k){return k.Wg(o,H,n,E),k}static FromEulerAngles(o,H,n){const E=new J;return J.RotationYawPitchRollToRef(H,o,n,E),E}static FromEulerAnglesToRef(o,H,n,E){return J.RotationYawPitchRollToRef(H,o,n,E),E}static FromEulerVector(o){const H=new J;return J.RotationYawPitchRollToRef(o._y,o._x,o._z,H),H}static FromEulerVectorToRef(o,H){return J.RotationYawPitchRollToRef(o._y,o._x,o._z,H),H}static FromUnitVectorsToRef(o,H,n){let k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:E.e;const g=z.Dot(o,H)+1;return g<k?Math.abs(o.x)>Math.abs(o.z)?n.set(-o.y,o.x,0,0):n.set(0,-o.z,o.y,0):(z.CrossToRef(o,H,Q.xH[0]),n.set(Q.xH[0].x,Q.xH[0].y,Q.xH[0].z,g)),n.normalize()}static RotationYawPitchRoll(o,H,n){const E=new J;return J.RotationYawPitchRollToRef(o,H,n,E),E}static RotationYawPitchRollToRef(o,H,n,E){const k=.5*n,g=.5*H,O=.5*o,Y=Math.sin(k),y=Math.cos(k),S=Math.sin(g),G=Math.cos(g),c=Math.sin(O),A=Math.cos(O);return E._x=A*S*y+c*G*Y,E._y=c*G*y-A*S*Y,E._z=A*G*Y-c*S*y,E._w=A*G*y+c*S*Y,E._isDirty=!0,E}static RotationAlphaBetaGamma(o,H,n){const E=new J;return J.RotationAlphaBetaGammaToRef(o,H,n,E),E}static RotationAlphaBetaGammaToRef(o,H,n,E){const k=.5*(n+o),g=.5*(n-o),O=.5*H;return E._x=Math.cos(g)*Math.sin(O),E._y=Math.sin(g)*Math.sin(O),E._z=Math.sin(k)*Math.cos(O),E._w=Math.cos(k)*Math.cos(O),E._isDirty=!0,E}static RotationQuaternionFromAxis(o,H,n){const E=new J(0,0,0,0);return J.RotationQuaternionFromAxisToRef(o,H,n,E),E}static RotationQuaternionFromAxisToRef(o,H,n,E){const k=h.Matrix[0];return o=o.normalizeToRef(h.xH[0]),H=H.normalizeToRef(h.xH[1]),n=n.normalizeToRef(h.xH[2]),N.FromXYZAxesToRef(o,H,n,k),J.FromRotationMatrixToRef(k,E),E}static FromLookDirectionLH(o,H){const n=new J;return J.FromLookDirectionLHToRef(o,H,n),n}static FromLookDirectionLHToRef(o,H,n){const E=h.Matrix[0];return N.LookDirectionLHToRef(o,H,E),J.FromRotationMatrixToRef(E,n),n}static FromLookDirectionRH(o,H){const n=new J;return J.FromLookDirectionRHToRef(o,H,n),n}static FromLookDirectionRHToRef(o,H,n){const E=h.Matrix[0];return N.LookDirectionRHToRef(o,H,E),J.FromRotationMatrixToRef(E,n)}static Slerp(o,H,n){const E=J.Identity();return J.SlerpToRef(o,H,n,E),E}static SlerpToRef(o,H,n,E){let k,g,O=o._x*H._x+o._y*H._y+o._z*H._z+o._w*H._w,Y=!1;if(O<0&&(Y=!0,O=-O),O>.999999)g=1-n,k=Y?-n:n;else{const o=Math.acos(O),H=1/Math.sin(o);g=Math.sin((1-n)*o)*H,k=Y?-Math.sin(n*o)*H:Math.sin(n*o)*H}return E._x=g*o._x+k*H._x,E._y=g*o._y+k*H._y,E._z=g*o._z+k*H._z,E._w=g*o._w+k*H._w,E._isDirty=!0,E}static Hermite(o,H,n,E,k){const g=k*k,O=k*g,Y=2*O-3*g+1,y=-2*O+3*g,S=O-2*g+k,G=O-g,c=o._x*Y+n._x*y+H._x*S+E._x*G,A=o._y*Y+n._y*y+H._y*S+E._y*G,l=o._z*Y+n._z*y+H._z*S+E._z*G,x=o._w*Y+n._w*y+H._w*S+E._w*G;return new J(c,A,l,x)}static Hermite1stDerivative(o,H,n,E,k){const g=new J;return this.Hermite1stDerivativeToRef(o,H,n,E,k,g),g}static Hermite1stDerivativeToRef(o,H,n,E,k,g){const O=k*k;return g._x=6*(O-k)*o._x+(3*O-4*k+1)*H._x+6*(-O+k)*n._x+(3*O-2*k)*E._x,g._y=6*(O-k)*o._y+(3*O-4*k+1)*H._y+6*(-O+k)*n._y+(3*O-2*k)*E._y,g._z=6*(O-k)*o._z+(3*O-4*k+1)*H._z+6*(-O+k)*n._z+(3*O-2*k)*E._z,g._w=6*(O-k)*o._w+(3*O-4*k+1)*H._w+6*(-O+k)*n._w+(3*O-2*k)*E._w,g._isDirty=!0,g}static Normalize(o){const H=J.Zero();return J.NormalizeToRef(o,H),H}static NormalizeToRef(o,H){return o.normalizeToRef(H),H}static Clamp(o,H,n){const E=new J;return J.ClampToRef(o,H,n,E),E}static ClampToRef(o,H,n,E){return E.Wg((0,y.Clamp)(o.x,H.x,n.x),(0,y.Clamp)(o.y,H.y,n.y),(0,y.Clamp)(o.z,H.z,n.z),(0,y.Clamp)(o.w,H.w,n.w))}static Random(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new J((0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H))}static RandomToRef(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Wg((0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H),(0,y.RandomRange)(o,H))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(o,H){return Math.sqrt(J.DistanceSquared(o,H))}static DistanceSquared(o,H){const n=o.x-H.x,E=o.y-H.y,k=o.z-H.z,g=o.w-H.w;return n*n+E*E+k*k+g*g}static Center(o,H){return J.CenterToRef(o,H,J.Zero())}static CenterToRef(o,H,n){return n.Wg((o.x+H.x)/2,(o.y+H.y)/2,(o.z+H.z)/2,(o.w+H.w)/2)}}J._V8PerformanceHack=new J(.5,.5,.5,.5),Object.defineProperties(J.prototype,{dimension:{value:[4]},rank:{value:1}});class N{static get Use64Bits(){return O.c.MatrixUse64Bits}get m(){return this.Sg}markAsUpdated(){this.updateFlag=S._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(o){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],E=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=o,this._isIdentity3x2=o||n,this._isIdentityDirty=!this._isIdentity&&H,this._isIdentity3x2Dirty=!this._isIdentity3x2&&E}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,O.c.MatrixTrackPrecisionChange&&O.c.MatrixTrackedMatrices.push(this),this.Sg=new O.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const o=this.Sg;this._isIdentity=1===o[0]&&0===o[1]&&0===o[2]&&0===o[3]&&0===o[4]&&1===o[5]&&0===o[6]&&0===o[7]&&0===o[8]&&0===o[9]&&1===o[10]&&0===o[11]&&0===o[12]&&0===o[13]&&0===o[14]&&1===o[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Sg[0]||1!==this.Sg[5]||1!==this.Sg[15]||0!==this.Sg[1]||0!==this.Sg[2]||0!==this.Sg[3]||0!==this.Sg[4]||0!==this.Sg[6]||0!==this.Sg[7]||0!==this.Sg[8]||0!==this.Sg[9]||0!==this.Sg[10]||0!==this.Sg[11]||0!==this.Sg[12]||0!==this.Sg[13]||0!==this.Sg[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const o=this.Sg,H=o[0],n=o[1],E=o[2],k=o[3],g=o[4],O=o[5],Y=o[6],y=o[7],S=o[8],G=o[9],c=o[10],A=o[11],l=o[12],x=o[13],z=o[14],V=o[15],J=c*V-z*A,N=G*V-x*A,h=G*z-x*c,Q=S*V-l*A,p=S*z-c*l,j=S*x-l*G;return H*+(O*J-Y*N+y*h)+n*-(g*J-Y*Q+y*p)+E*+(g*N-O*Q+y*j)+k*-(g*h-O*p+Y*j)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!o)return this.Sg;const n=this.Sg;for(let E=0;E<16;E++)o[H+E]=n[E];return this}bg(){return this.Sg}An(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N.FromArrayToRef(o,H,this)}Wg(){for(var o=arguments.length,H=new Array(o),n=0;n<o;n++)H[n]=arguments[n];return N.FromArrayToRef(H,0,this)}set(){const o=this.Sg;for(let H=0;H<16;H++)o[H]=H<0||arguments.length<=H?void 0:arguments[H];return this.markAsUpdated(),this}AY(o){const H=this.Sg;for(let n=0;n<16;n++)H[n]=o;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return N.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(o){const H=new N;return this.addToRef(o,H),H}addToRef(o,H){const n=this.Sg,E=H.Sg,k=o.m;for(let g=0;g<16;g++)E[g]=n[g]+k[g];return H.markAsUpdated(),H}addToSelf(o){const H=this.Sg,n=o.m;return H[0]+=n[0],H[1]+=n[1],H[2]+=n[2],H[3]+=n[3],H[4]+=n[4],H[5]+=n[5],H[6]+=n[6],H[7]+=n[7],H[8]+=n[8],H[9]+=n[9],H[10]+=n[10],H[11]+=n[11],H[12]+=n[12],H[13]+=n[13],H[14]+=n[14],H[15]+=n[15],this.markAsUpdated(),this}addInPlace(o){const H=this.Sg,n=o.m;for(let E=0;E<16;E++)H[E]+=n[E];return this.markAsUpdated(),this}addInPlaceFromFloats(){const o=this.Sg;for(let H=0;H<16;H++)o[H]+=H<0||arguments.length<=H?void 0:arguments[H];return this.markAsUpdated(),this}zH(o){const H=this.Sg,n=o.m;for(let E=0;E<16;E++)H[E]-=n[E];return this.markAsUpdated(),this}subtractToRef(o,H){const n=this.Sg,E=o.m,k=H.Sg;for(let g=0;g<16;g++)k[g]=n[g]-E[g];return H.markAsUpdated(),H}tG(o){const H=this.Sg,n=o.m;for(let E=0;E<16;E++)H[E]-=n[E];return this.markAsUpdated(),this}subtractFromFloats(){for(var o=arguments.length,H=new Array(o),n=0;n<o;n++)H[n]=arguments[n];return this.subtractFromFloatsToRef(...H,new N)}subtractFromFloatsToRef(){for(var o=arguments.length,H=new Array(o),n=0;n<o;n++)H[n]=arguments[n];const E=H.pop(),k=this.Sg,g=E.Sg,O=H;for(let Y=0;Y<16;Y++)g[Y]=k[Y]-O[Y];return E.markAsUpdated(),E}invertToRef(o){return!0===this._isIdentity?(N.IdentityToRef(o),o):(A(this,o.bg())?o.markAsUpdated():o.S(this),o)}addAtIndex(o,H){return this.Sg[o]+=H,this.markAsUpdated(),this}multiplyAtIndex(o,H){return this.Sg[o]*=H,this.markAsUpdated(),this}setTranslationFromFloats(o,H,n){return this.Sg[12]=o,this.Sg[13]=H,this.Sg[14]=n,this.markAsUpdated(),this}addTranslationFromFloats(o,H,n){return this.Sg[12]+=o,this.Sg[13]+=H,this.Sg[14]+=n,this.markAsUpdated(),this}setTranslation(o){return this.setTranslationFromFloats(o._x,o._y,o._z)}getTranslation(){return new z(this.Sg[12],this.Sg[13],this.Sg[14])}getTranslationToRef(o){return o.x=this.Sg[12],o.y=this.Sg[13],o.z=this.Sg[14],o}removeRotationAndScaling(){const o=this.m;return N.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,o[12],o[13],o[14],o[15],this),this._updateIdentityStatus(0===o[12]&&0===o[13]&&0===o[14]&&1===o[15]),this}S(o){o.copyToArray(this.Sg);const H=o;return this.updateFlag=H.updateFlag,this._updateIdentityStatus(H._isIdentity,H._isIdentityDirty,H._isIdentity3x2,H._isIdentity3x2Dirty),this}copyToArray(o){return c(this,o,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(o){const H=new N;return this.multiplyToRef(o,H),H}multiplyInPlace(o){const H=this.Sg,n=o.m;for(let E=0;E<16;E++)H[E]*=n[E];return this.markAsUpdated(),this}multiplyByFloats(){const o=this.Sg;for(let H=0;H<16;H++)o[H]*=H<0||arguments.length<=H?void 0:arguments[H];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var o=arguments.length,H=new Array(o),n=0;n<o;n++)H[n]=arguments[n];const E=H.pop(),k=this.Sg,g=E.Sg,O=H;for(let Y=0;Y<16;Y++)g[Y]=k[Y]*O[Y];return E.markAsUpdated(),E}multiplyToRef(o,H){return this._isIdentity?(H.S(o),H):o._isIdentity?(H.S(this),H):(this.multiplyToArray(o,H.Sg,0),H.markAsUpdated(),H)}multiplyToArray(o,H,n){return G(this,o,H,n),this}divide(o){return this.divideToRef(o,new N)}divideToRef(o,H){const n=this.Sg,E=o.m,k=H.Sg;for(let g=0;g<16;g++)k[g]=n[g]/E[g];return H.markAsUpdated(),H}divideInPlace(o){const H=this.Sg,n=o.m;for(let E=0;E<16;E++)H[E]/=n[E];return this.markAsUpdated(),this}minimizeInPlace(o){const H=this.Sg,n=o.m;for(let E=0;E<16;E++)H[E]=Math.min(H[E],n[E]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const o=this.Sg;for(let H=0;H<16;H++)o[H]=Math.min(o[H],H<0||arguments.length<=H?void 0:arguments[H]);return this.markAsUpdated(),this}maximizeInPlace(o){const H=this.Sg,n=o.m;for(let E=0;E<16;E++)H[E]=Math.min(H[E],n[E]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const o=this.Sg;for(let H=0;H<16;H++)o[H]=Math.min(o[H],H<0||arguments.length<=H?void 0:arguments[H]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new N)}negateInPlace(){const o=this.Sg;for(let H=0;H<16;H++)o[H]=-o[H];return this.markAsUpdated(),this}negateToRef(o){const H=this.Sg,n=o.Sg;for(let E=0;E<16;E++)n[E]=-H[E];return o.markAsUpdated(),o}equals(o){const H=o;if(!H)return!1;if((this._isIdentity||H._isIdentity)&&!this._isIdentityDirty&&!H._isIdentityDirty)return this._isIdentity&&H._isIdentity;const n=this.m,E=H.m;return n[0]===E[0]&&n[1]===E[1]&&n[2]===E[2]&&n[3]===E[3]&&n[4]===E[4]&&n[5]===E[5]&&n[6]===E[6]&&n[7]===E[7]&&n[8]===E[8]&&n[9]===E[9]&&n[10]===E[10]&&n[11]===E[11]&&n[12]===E[12]&&n[13]===E[13]&&n[14]===E[14]&&n[15]===E[15]}equalsWithEpsilon(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this.Sg,E=o.m;for(let k=0;k<16;k++)if(!(0,y.WithinEpsilon)(n[k],E[k],H))return!1;return!0}equalsToFloats(){const o=this.Sg;for(let H=0;H<16;H++)if(o[H]!=(H<0||arguments.length<=H?void 0:arguments[H]))return!1;return!0}floor(){return this.floorToRef(new N)}floorToRef(o){const H=this.Sg,n=o.Sg;for(let E=0;E<16;E++)n[E]=Math.floor(H[E]);return o.markAsUpdated(),o}fract(){return this.fractToRef(new N)}fractToRef(o){const H=this.Sg,n=o.Sg;for(let E=0;E<16;E++)n[E]=H[E]-Math.floor(H[E]);return o.markAsUpdated(),o}clone(){const o=new N;return o.S(this),o}getClassName(){return"Matrix"}getHashCode(){let o=l(this.Sg[0]);for(let H=1;H<16;H++)o=397*o^l(this.Sg[H]);return o}decomposeToTransformNode(o){return o.rotationQuaternion=o.rotationQuaternion||new J,this.decompose(o.cY,o.rotationQuaternion,o.position)}decompose(o,H,n,E){let k=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return n&&n.AY(0),o&&o.AY(1),H&&H.Wg(0,0,0,1),!0;const g=this.Sg;if(n&&n.Wg(g[12],g[13],g[14]),(o=o||h.xH[0]).x=Math.sqrt(g[0]*g[0]+g[1]*g[1]+g[2]*g[2]),o.y=Math.sqrt(g[4]*g[4]+g[5]*g[5]+g[6]*g[6]),o.z=Math.sqrt(g[8]*g[8]+g[9]*g[9]+g[10]*g[10]),E){const H=(k?E.absoluteScaling.x:E.cY.x)<0?-1:1,n=(k?E.absoluteScaling.y:E.cY.y)<0?-1:1,g=(k?E.absoluteScaling.z:E.cY.z)<0?-1:1;o.x*=H,o.y*=n,o.z*=g}else this.determinant()<=0&&(o.y*=-1);if(0===o._x||0===o._y||0===o._z)return H&&H.Wg(0,0,0,1),!1;if(H){const n=1/o._x,E=1/o._y,k=1/o._z;N.FromValuesToRef(g[0]*n,g[1]*n,g[2]*n,0,g[4]*E,g[5]*E,g[6]*E,0,g[8]*k,g[9]*k,g[10]*k,0,0,0,0,1,h.Matrix[0]),J.FromRotationMatrixToRef(h.Matrix[0],H)}return!0}getRow(o){if(o<0||o>3)return null;const H=4*o;return new V(this.Sg[H+0],this.Sg[H+1],this.Sg[H+2],this.Sg[H+3])}getRowToRef(o,H){if(o>=0&&o<=3){const n=4*o;H.x=this.Sg[n+0],H.y=this.Sg[n+1],H.z=this.Sg[n+2],H.w=this.Sg[n+3]}return H}setRow(o,H){return this.setRowFromFloats(o,H.x,H.y,H.z,H.w)}transpose(){const o=new N;return N.TransposeToRef(this,o),o}transposeToRef(o){return N.TransposeToRef(this,o),o}setRowFromFloats(o,H,n,E,k){if(o<0||o>3)return this;const g=4*o;return this.Sg[g+0]=H,this.Sg[g+1]=n,this.Sg[g+2]=E,this.Sg[g+3]=k,this.markAsUpdated(),this}scale(o){const H=new N;return this.scaleToRef(o,H),H}scaleToRef(o,H){for(let n=0;n<16;n++)H.Sg[n]=this.Sg[n]*o;return H.markAsUpdated(),H}scaleAndAddToRef(o,H){for(let n=0;n<16;n++)H.Sg[n]+=this.Sg[n]*o;return H.markAsUpdated(),H}scaleInPlace(o){const H=this.Sg;for(let n=0;n<16;n++)H[n]*=o;return this.markAsUpdated(),this}toNormalMatrix(o){const H=h.Matrix[0];this.invertToRef(H),H.transposeToRef(o);const n=o.Sg;return N.FromValuesToRef(n[0],n[1],n[2],0,n[4],n[5],n[6],0,n[8],n[9],n[10],0,0,0,0,1,o),o}getRotationMatrix(){const o=new N;return this.getRotationMatrixToRef(o),o}getRotationMatrixToRef(o){const H=h.xH[0];if(!this.decompose(H))return N.IdentityToRef(o),o;const n=this.Sg,E=1/H._x,k=1/H._y,g=1/H._z;return N.FromValuesToRef(n[0]*E,n[1]*E,n[2]*E,0,n[4]*k,n[5]*k,n[6]*k,0,n[8]*g,n[9]*g,n[10]*g,0,0,0,0,1,o),o}toggleModelMatrixHandInPlace(){const o=this.Sg;return o[2]*=-1,o[6]*=-1,o[8]*=-1,o[9]*=-1,o[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const o=this.Sg;return o[8]*=-1,o[9]*=-1,o[10]*=-1,o[11]*=-1,this.markAsUpdated(),this}static Mg(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=new N;return N.FromArrayToRef(o,H,n),n}static FromArrayToRef(o,H,n){for(let E=0;E<16;E++)n.Sg[E]=o[E+H];return n.markAsUpdated(),n}static FromFloat32ArrayToRefScaled(o,H,n,E){return E.Sg[0]=o[0+H]*n,E.Sg[1]=o[1+H]*n,E.Sg[2]=o[2+H]*n,E.Sg[3]=o[3+H]*n,E.Sg[4]=o[4+H]*n,E.Sg[5]=o[5+H]*n,E.Sg[6]=o[6+H]*n,E.Sg[7]=o[7+H]*n,E.Sg[8]=o[8+H]*n,E.Sg[9]=o[9+H]*n,E.Sg[10]=o[10+H]*n,E.Sg[11]=o[11+H]*n,E.Sg[12]=o[12+H]*n,E.Sg[13]=o[13+H]*n,E.Sg[14]=o[14+H]*n,E.Sg[15]=o[15+H]*n,E.markAsUpdated(),E}static get IdentityReadOnly(){return N._IdentityReadOnly}static FromValuesToRef(o,H,n,E,k,g,O,Y,y,S,G,c,A,l,x,z,V){const J=V.Sg;J[0]=o,J[1]=H,J[2]=n,J[3]=E,J[4]=k,J[5]=g,J[6]=O,J[7]=Y,J[8]=y,J[9]=S,J[10]=G,J[11]=c,J[12]=A,J[13]=l,J[14]=x,J[15]=z,V.markAsUpdated()}static FromValues(o,H,n,E,k,g,O,Y,y,S,G,c,A,l,x,z){const V=new N,J=V.Sg;return J[0]=o,J[1]=H,J[2]=n,J[3]=E,J[4]=k,J[5]=g,J[6]=O,J[7]=Y,J[8]=y,J[9]=S,J[10]=G,J[11]=c,J[12]=A,J[13]=l,J[14]=x,J[15]=z,V.markAsUpdated(),V}static Compose(o,H,n){const E=new N;return N.ComposeToRef(o,H,n,E),E}static ComposeToRef(o,H,n,E){const k=E.Sg,g=H._x,O=H._y,Y=H._z,y=H._w,S=g+g,G=O+O,c=Y+Y,A=g*S,l=g*G,x=g*c,z=O*G,V=O*c,J=Y*c,N=y*S,h=y*G,Q=y*c,p=o._x,j=o._y,m=o._z;return k[0]=(1-(z+J))*p,k[1]=(l+Q)*p,k[2]=(x-h)*p,k[3]=0,k[4]=(l-Q)*j,k[5]=(1-(A+J))*j,k[6]=(V+N)*j,k[7]=0,k[8]=(x+h)*m,k[9]=(V-N)*m,k[10]=(1-(A+z))*m,k[11]=0,k[12]=n._x,k[13]=n._y,k[14]=n._z,k[15]=1,E.markAsUpdated(),E}static Identity(){const o=N.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return o._updateIdentityStatus(!0),o}static IdentityToRef(o){return N.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,o),o._updateIdentityStatus(!0),o}static Zero(){const o=N.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return o._updateIdentityStatus(!1),o}static RotationX(o){const H=new N;return N.RotationXToRef(o,H),H}static Invert(o){const H=new N;return o.invertToRef(H),H}static RotationXToRef(o,H){const n=Math.sin(o),E=Math.cos(o);return N.FromValuesToRef(1,0,0,0,0,E,n,0,0,-n,E,0,0,0,0,1,H),H._updateIdentityStatus(1===E&&0===n),H}static RotationY(o){const H=new N;return N.RotationYToRef(o,H),H}static RotationYToRef(o,H){const n=Math.sin(o),E=Math.cos(o);return N.FromValuesToRef(E,0,-n,0,0,1,0,0,n,0,E,0,0,0,0,1,H),H._updateIdentityStatus(1===E&&0===n),H}static RotationZ(o){const H=new N;return N.RotationZToRef(o,H),H}static RotationZToRef(o,H){const n=Math.sin(o),E=Math.cos(o);return N.FromValuesToRef(E,n,0,0,-n,E,0,0,0,0,1,0,0,0,0,1,H),H._updateIdentityStatus(1===E&&0===n),H}static RotationAxis(o,H){const n=new N;return N.RotationAxisToRef(o,H,n),n}static RotationAxisToRef(o,H,n){const E=Math.sin(-H),k=Math.cos(-H),g=1-k;o=o.normalizeToRef(h.xH[0]);const O=n.Sg;return O[0]=o._x*o._x*g+k,O[1]=o._x*o._y*g-o._z*E,O[2]=o._x*o._z*g+o._y*E,O[3]=0,O[4]=o._y*o._x*g+o._z*E,O[5]=o._y*o._y*g+k,O[6]=o._y*o._z*g-o._x*E,O[7]=0,O[8]=o._z*o._x*g-o._y*E,O[9]=o._z*o._y*g+o._x*E,O[10]=o._z*o._z*g+k,O[11]=0,O[12]=0,O[13]=0,O[14]=0,O[15]=1,n.markAsUpdated(),n}static RotationAlignToRef(o,H,n){let k=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const g=z.Dot(H,o),O=n.Sg;if(g<-1+E.e)O[0]=-1,O[1]=0,O[2]=0,O[3]=0,O[4]=0,O[5]=k?1:-1,O[6]=0,O[7]=0,O[8]=0,O[9]=0,O[10]=k?-1:1,O[11]=0;else{const n=z.Cross(H,o),E=1/(1+g);O[0]=n._x*n._x*E+g,O[1]=n._y*n._x*E-n._z,O[2]=n._z*n._x*E+n._y,O[3]=0,O[4]=n._x*n._y*E+n._z,O[5]=n._y*n._y*E+g,O[6]=n._z*n._y*E-n._x,O[7]=0,O[8]=n._x*n._z*E-n._y,O[9]=n._y*n._z*E+n._x,O[10]=n._z*n._z*E+g,O[11]=0}return O[12]=0,O[13]=0,O[14]=0,O[15]=1,n.markAsUpdated(),n}static RotationYawPitchRoll(o,H,n){const E=new N;return N.RotationYawPitchRollToRef(o,H,n,E),E}static RotationYawPitchRollToRef(o,H,n,E){return J.RotationYawPitchRollToRef(o,H,n,h.Quaternion[0]),h.Quaternion[0].toRotationMatrix(E),E}static Scaling(o,H,n){const E=new N;return N.ScalingToRef(o,H,n,E),E}static ScalingToRef(o,H,n,E){return N.FromValuesToRef(o,0,0,0,0,H,0,0,0,0,n,0,0,0,0,1,E),E._updateIdentityStatus(1===o&&1===H&&1===n),E}static Translation(o,H,n){const E=new N;return N.TranslationToRef(o,H,n,E),E}static TranslationToRef(o,H,n,E){return N.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,o,H,n,1,E),E._updateIdentityStatus(0===o&&0===H&&0===n),E}static Lerp(o,H,n){const E=new N;return N.LerpToRef(o,H,n,E),E}static LerpToRef(o,H,n,E){const k=E.Sg,g=o.m,O=H.m;for(let Y=0;Y<16;Y++)k[Y]=g[Y]*(1-n)+O[Y]*n;return E.markAsUpdated(),E}static DecomposeLerp(o,H,n){const E=new N;return N.DecomposeLerpToRef(o,H,n,E),E}static DecomposeLerpToRef(o,H,n,E){const k=h.xH[0],g=h.Quaternion[0],O=h.xH[1];o.decompose(k,g,O);const Y=h.xH[2],y=h.Quaternion[1],S=h.xH[3];H.decompose(Y,y,S);const G=h.xH[4];z.LerpToRef(k,Y,n,G);const c=h.Quaternion[2];J.SlerpToRef(g,y,n,c);const A=h.xH[5];return z.LerpToRef(O,S,n,A),N.ComposeToRef(G,c,A,E),E}static LookAtLH(o,H,n){const E=new N;return N.LookAtLHToRef(o,H,n,E),E}static LookAtLHToRef(o,H,n,E){const k=h.xH[0],g=h.xH[1],O=h.xH[2];H.subtractToRef(o,O),O.normalize(),z.CrossToRef(n,O,k);const Y=k.lengthSquared();0===Y?k.x=1:k.normalizeFromLength(Math.sqrt(Y)),z.CrossToRef(O,k,g),g.normalize();const y=-z.Dot(k,o),S=-z.Dot(g,o),G=-z.Dot(O,o);return N.FromValuesToRef(k._x,g._x,O._x,0,k._y,g._y,O._y,0,k._z,g._z,O._z,0,y,S,G,1,E),E}static LookAtRH(o,H,n){const E=new N;return N.LookAtRHToRef(o,H,n,E),E}static LookAtRHToRef(o,H,n,E){const k=h.xH[0],g=h.xH[1],O=h.xH[2];o.subtractToRef(H,O),O.normalize(),z.CrossToRef(n,O,k);const Y=k.lengthSquared();0===Y?k.x=1:k.normalizeFromLength(Math.sqrt(Y)),z.CrossToRef(O,k,g),g.normalize();const y=-z.Dot(k,o),S=-z.Dot(g,o),G=-z.Dot(O,o);return N.FromValuesToRef(k._x,g._x,O._x,0,k._y,g._y,O._y,0,k._z,g._z,O._z,0,y,S,G,1,E),E}static LookDirectionLH(o,H){const n=new N;return N.LookDirectionLHToRef(o,H,n),n}static LookDirectionLHToRef(o,H,n){const E=h.xH[0];E.S(o),E.scaleInPlace(-1);const k=h.xH[1];return z.CrossToRef(H,E,k),N.FromValuesToRef(k._x,k._y,k._z,0,H._x,H._y,H._z,0,E._x,E._y,E._z,0,0,0,0,1,n),n}static LookDirectionRH(o,H){const n=new N;return N.LookDirectionRHToRef(o,H,n),n}static LookDirectionRHToRef(o,H,n){const E=h.xH[2];return z.CrossToRef(H,o,E),N.FromValuesToRef(E._x,E._y,E._z,0,H._x,H._y,H._z,0,o._x,o._y,o._z,0,0,0,0,1,n),n}static OrthoLH(o,H,n,E,k){const g=new N;return N.OrthoLHToRef(o,H,n,E,g,k),g}static OrthoLHToRef(o,H,n,E,k,g){const O=2/o,Y=2/H,y=2/(E-n),S=-(E+n)/(E-n);return N.FromValuesToRef(O,0,0,0,0,Y,0,0,0,0,y,0,0,0,S,1,k),g&&k.multiplyToRef(p,k),k._updateIdentityStatus(1===O&&1===Y&&1===y&&0===S),k}static OrthoOffCenterLH(o,H,n,E,k,g,O){const Y=new N;return N.OrthoOffCenterLHToRef(o,H,n,E,k,g,Y,O),Y}static OrthoOffCenterLHToRef(o,H,n,E,k,g,O,Y){const y=2/(H-o),S=2/(E-n),G=2/(g-k),c=-(g+k)/(g-k),A=(o+H)/(o-H),l=(E+n)/(n-E);return N.FromValuesToRef(y,0,0,0,0,S,0,0,0,0,G,0,A,l,c,1,O),Y&&O.multiplyToRef(p,O),O.markAsUpdated(),O}static ObliqueOffCenterLHToRef(o,H,n,E,k,g,O,Y,y,S,G){const c=-O*Math.cos(Y),A=-O*Math.sin(Y);return N.TranslationToRef(0,0,-y,h.Matrix[1]),N.FromValuesToRef(1,0,0,0,0,1,0,0,c,A,1,0,0,0,0,1,h.Matrix[0]),h.Matrix[1].multiplyToRef(h.Matrix[0],h.Matrix[0]),N.TranslationToRef(0,0,y,h.Matrix[1]),h.Matrix[0].multiplyToRef(h.Matrix[1],h.Matrix[0]),N.OrthoOffCenterLHToRef(o,H,n,E,k,g,S,G),h.Matrix[0].multiplyToRef(S,S),S}static OrthoOffCenterRH(o,H,n,E,k,g,O){const Y=new N;return N.OrthoOffCenterRHToRef(o,H,n,E,k,g,Y,O),Y}static OrthoOffCenterRHToRef(o,H,n,E,k,g,O,Y){return N.OrthoOffCenterLHToRef(o,H,n,E,k,g,O,Y),O.Sg[10]*=-1,O}static ObliqueOffCenterRHToRef(o,H,n,E,k,g,O,Y,y,S,G){const c=O*Math.cos(Y),A=O*Math.sin(Y);return N.TranslationToRef(0,0,y,h.Matrix[1]),N.FromValuesToRef(1,0,0,0,0,1,0,0,c,A,1,0,0,0,0,1,h.Matrix[0]),h.Matrix[1].multiplyToRef(h.Matrix[0],h.Matrix[0]),N.TranslationToRef(0,0,-y,h.Matrix[1]),h.Matrix[0].multiplyToRef(h.Matrix[1],h.Matrix[0]),N.OrthoOffCenterRHToRef(o,H,n,E,k,g,S,G),h.Matrix[0].multiplyToRef(S,S),S}static PerspectiveLH(o,H,n,E,k){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const O=new N,Y=2*n/o,y=2*n/H,S=(E+n)/(E-n),G=-2*E*n/(E-n),c=Math.tan(g);return N.FromValuesToRef(Y,0,0,0,0,y,0,c,0,0,S,1,0,0,G,0,O),k&&O.multiplyToRef(p,O),O._updateIdentityStatus(!1),O}static PerspectiveFovLH(o,H,n,E,k){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,O=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const Y=new N;return N.PerspectiveFovLHToRef(o,H,n,E,Y,!0,k,g,O),Y}static PerspectiveFovLHToRef(o,H,n,E,k){let g=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],O=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,y=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const S=n,G=E,c=1/Math.tan(.5*o),A=g?c/H:c,l=g?c:c*H,x=y&&0===S?-1:0!==G?(G+S)/(G-S):1,z=y&&0===S?2*G:0!==G?-2*G*S/(G-S):-2*S,V=Math.tan(Y);return N.FromValuesToRef(A,0,0,0,0,l,0,V,0,0,x,1,0,0,z,0,k),O&&k.multiplyToRef(p,k),k._updateIdentityStatus(!1),k}static PerspectiveFovReverseLHToRef(o,H,n,E,k){let g=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],O=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const y=1/Math.tan(.5*o),S=g?y/H:y,G=g?y:y*H,c=Math.tan(Y);return N.FromValuesToRef(S,0,0,0,0,G,0,c,0,0,-n,1,0,0,1,0,k),O&&k.multiplyToRef(p,k),k._updateIdentityStatus(!1),k}static PerspectiveFovRH(o,H,n,E,k){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,O=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const Y=new N;return N.PerspectiveFovRHToRef(o,H,n,E,Y,!0,k,g,O),Y}static PerspectiveFovRHToRef(o,H,n,E,k){let g=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],O=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,y=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const S=n,G=E,c=1/Math.tan(.5*o),A=g?c/H:c,l=g?c:c*H,x=y&&0===S?1:0!==G?-(G+S)/(G-S):-1,z=y&&0===S?2*G:0!==G?-2*G*S/(G-S):-2*S,V=Math.tan(Y);return N.FromValuesToRef(A,0,0,0,0,l,0,V,0,0,x,-1,0,0,z,0,k),O&&k.multiplyToRef(p,k),k._updateIdentityStatus(!1),k}static PerspectiveFovReverseRHToRef(o,H,n,E,k){let g=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],O=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const y=1/Math.tan(.5*o),S=g?y/H:y,G=g?y:y*H,c=Math.tan(Y);return N.FromValuesToRef(S,0,0,0,0,G,0,c,0,0,-n,-1,0,0,-1,0,k),O&&k.multiplyToRef(p,k),k._updateIdentityStatus(!1),k}static GetFinalMatrix(o,H,n,E,k,g){const O=o.width,Y=o.height,y=o.x,S=o.y,G=N.FromValues(O/2,0,0,0,0,-Y/2,0,0,0,0,g-k,0,y+O/2,Y/2+S,k,1),c=new N;return H.multiplyToRef(n,c),c.multiplyToRef(E,c),c.multiplyToRef(G,c)}static GetAsMatrix2x2(o){const H=o.m,n=[H[0],H[1],H[4],H[5]];return O.c.MatrixUse64Bits?n:new Float32Array(n)}static GetAsMatrix3x3(o){const H=o.m,n=[H[0],H[1],H[2],H[4],H[5],H[6],H[8],H[9],H[10]];return O.c.MatrixUse64Bits?n:new Float32Array(n)}static Transpose(o){const H=new N;return N.TransposeToRef(o,H),H}static TransposeToRef(o,H){const n=o.m,E=n[0],k=n[4],g=n[8],O=n[12],Y=n[1],y=n[5],S=n[9],G=n[13],c=n[2],A=n[6],l=n[10],x=n[14],z=n[3],V=n[7],J=n[11],N=n[15],h=H.Sg;return h[0]=E,h[1]=k,h[2]=g,h[3]=O,h[4]=Y,h[5]=y,h[6]=S,h[7]=G,h[8]=c,h[9]=A,h[10]=l,h[11]=x,h[12]=z,h[13]=V,h[14]=J,h[15]=N,H.markAsUpdated(),H._updateIdentityStatus(o._isIdentity,o._isIdentityDirty),H}static Reflection(o){const H=new N;return N.ReflectionToRef(o,H),H}static ReflectionToRef(o,H){o.normalize();const n=o.normal.x,E=o.normal.y,k=o.normal.z,g=-2*n,O=-2*E,Y=-2*k;return N.FromValuesToRef(g*n+1,O*n,Y*n,0,g*E,O*E+1,Y*E,0,g*k,O*k,Y*k+1,0,g*o.d,O*o.d,Y*o.d,1,H),H}static FromXYZAxesToRef(o,H,n,E){return N.FromValuesToRef(o._x,o._y,o._z,0,H._x,H._y,H._z,0,n._x,n._y,n._z,0,0,0,0,1,E),E}static FromQuaternionToRef(o,H){const n=o._x*o._x,E=o._y*o._y,k=o._z*o._z,g=o._x*o._y,O=o._z*o._w,Y=o._z*o._x,y=o._y*o._w,S=o._y*o._z,G=o._x*o._w;return H.Sg[0]=1-2*(E+k),H.Sg[1]=2*(g+O),H.Sg[2]=2*(Y-y),H.Sg[3]=0,H.Sg[4]=2*(g-O),H.Sg[5]=1-2*(k+n),H.Sg[6]=2*(S+G),H.Sg[7]=0,H.Sg[8]=2*(Y+y),H.Sg[9]=2*(S-G),H.Sg[10]=1-2*(E+n),H.Sg[11]=0,H.Sg[12]=0,H.Sg[13]=0,H.Sg[14]=0,H.Sg[15]=1,H.markAsUpdated(),H}}N._IdentityReadOnly=N.Identity(),Object.defineProperties(N.prototype,{dimension:{value:[4,4]},rank:{value:2}});class h{}h.xH=(0,k.f)(11,z.Zero),h.Matrix=(0,k.f)(2,N.Identity),h.Quaternion=(0,k.f)(3,J.Zero);class Q{}Q.Vector2=(0,k.f)(3,x.Zero),Q.xH=(0,k.f)(13,z.Zero),Q.Vector4=(0,k.f)(3,V.Zero),Q.Quaternion=(0,k.f)(3,J.Zero),Q.Matrix=(0,k.f)(8,N.Identity),(0,g.e)("BABYLON.Vector2",x),(0,g.e)("BABYLON.Vector3",z),(0,g.e)("BABYLON.Vector4",V),(0,g.e)("BABYLON.Matrix",N);const p=N.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11201:(o,H,n)=>{function E(o,H){const n=[];for(let E=0;E<o;++E)n.push(H());return n}function k(o,H){return E(o,H)}n.d(H,{b:()=>E,f:()=>k,i:()=>O});const g=["push","splice","pop","shift","unshift"];function O(o,H){const n=g.map((n=>function(o,H,n){const E=o[H];if("function"!==typeof E)return null;const k=function(){const E=o.length,g=k.previous.apply(o,arguments);return n(H,E),g};return E.next=k,k.previous=E,o[H]=k,()=>{const n=k.previous;if(!n)return;const E=k.next;E?(n.next=E,E.previous=n):(n.next=void 0,o[H]=n),k.next=void 0,k.previous=void 0}}(o,n,H)));return()=>{for(const o of n)null===o||void 0===o||o()}}}}]);