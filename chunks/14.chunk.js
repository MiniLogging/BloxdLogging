"use strict";(self.c2c3ycupenc=self.c2c3ycupenc||[]).push([[14],{11687:(c,r,D)=>{D.d(r,{c:()=>u,e:()=>t,g:()=>W,k:()=>B});const W=1/2.2,B=2.2,t=(1+Math.sqrt(5))/2,u=.001},11696:(c,r,D)=>{function W(c){return parseInt(c.toString().replace(/\W/g,""))}function B(c,r){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(c-r)<=D}function t(c,r,D){let W=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return c<r-W||c>D+W}function u(c,r){return c===r?c:Math.random()*(r-c)+c}function a(c,r,D){return c+(r-c)*D}function H(c,r,D){let W=w(r-c,360);return W>180&&(W-=360),c+W*m(D)}function x(c,r,D){let W=0;return W=c!=r?m((D-c)/(r-c)):0,W}function M(c,r,D,W,B){const t=B*B,u=B*t;return c*(2*u-3*t+1)+D*(-2*u+3*t)+r*(u-2*t+B)+W*(u-t)}function E(c,r,D,W,B){const t=B*B;return 6*(t-B)*c+(3*t-4*B+1)*r+6*(-t+B)*D+(3*t-2*B)*W}function m(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(D,Math.max(r,c))}function Y(c){return c-=2*Math.PI*Math.floor((c+Math.PI)/(2*Math.PI))}function v(c){const r=c.toString(16);return c<=15?("0"+r).toUpperCase():r.toUpperCase()}function k(c){if(Math.log2)return Math.floor(Math.log2(c));if(c<0)return NaN;if(0===c)return-1/0;let r=0;if(c<1){for(;c<1;)r++,c*=2;r=-r}else if(c>1)for(;c>1;)r++,c=Math.floor(c/2);return r}function w(c,r){return c-Math.floor(c/r)*r}function Z(c,r,D){return(c-r)/(D-r)}function J(c,r,D){return c*(D-r)+r}function q(c,r){let D=w(r-c,360);return D>180&&(D-=360),D}function j(c,r){const D=w(c,2*r);return r-Math.abs(D-r)}function X(c,r,D){let W=m(D);return W=-2*W*W*W+3*W*W,r*W+c*(1-W)}function e(c,r,D){let W=0;return W=Math.abs(r-c)<=D?r:c+Math.sign(r-c)*D,W}function y(c,r,D){const W=q(c,r);let B=0;return B=-D<W&&W<D?r:e(c,r=c+W,D),B}function U(c,r,D){return(c-r)/(D-r)}function N(c,r,D){return(D-r)*c+r}function g(c,r){const D=c%r;return 0===D?r:g(r,D)}D.r(r),D.d(r,{Clamp:()=>m,DeltaAngle:()=>q,Denormalize:()=>J,ExtractAsInt:()=>W,Hermite:()=>M,Hermite1stDerivative:()=>E,HighestCommonFactor:()=>g,ILog2:()=>k,InverseLerp:()=>x,Lerp:()=>a,LerpAngle:()=>H,MoveTowards:()=>e,MoveTowardsAngle:()=>y,Normalize:()=>Z,NormalizeRadians:()=>Y,OutsideRange:()=>t,PercentToRange:()=>N,PingPong:()=>j,RandomRange:()=>u,RangeToPercent:()=>U,Repeat:()=>w,SmoothStep:()=>X,ToHex:()=>v,WithinEpsilon:()=>B})},11683:(c,r,D)=>{D.r(r),D.d(r,{Matrix:()=>J,Quaternion:()=>Z,TmpVectors:()=>j,Vector2:()=>v,Zr:()=>k,Vector4:()=>w});var W=D(11687),B=D(11694),t=D(11637),u=D(11608),a=D(11538),H=D(11696);class x{}function M(c,r,D){let W=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const B=c.Ma(),t=r.Ma(),u=B[0],a=B[1],H=B[2],x=B[3],M=B[4],E=B[5],m=B[6],Y=B[7],v=B[8],k=B[9],w=B[10],Z=B[11],J=B[12],q=B[13],j=B[14],X=B[15],e=t[0],y=t[1],U=t[2],N=t[3],g=t[4],z=t[5],S=t[6],K=t[7],f=t[8],A=t[9],h=t[10],L=t[11],P=t[12],G=t[13],d=t[14],T=t[15];D[W]=u*e+a*g+H*f+x*P,D[W+1]=u*y+a*z+H*A+x*G,D[W+2]=u*U+a*S+H*h+x*d,D[W+3]=u*N+a*K+H*L+x*T,D[W+4]=M*e+E*g+m*f+Y*P,D[W+5]=M*y+E*z+m*A+Y*G,D[W+6]=M*U+E*S+m*h+Y*d,D[W+7]=M*N+E*K+m*L+Y*T,D[W+8]=v*e+k*g+w*f+Z*P,D[W+9]=v*y+k*z+w*A+Z*G,D[W+10]=v*U+k*S+w*h+Z*d,D[W+11]=v*N+k*K+w*L+Z*T,D[W+12]=J*e+q*g+j*f+X*P,D[W+13]=J*y+q*z+j*A+X*G,D[W+14]=J*U+q*S+j*h+X*d,D[W+15]=J*N+q*K+j*L+X*T}function E(c,r){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const W=c.Ma();r[D]=W[0],r[D+1]=W[1],r[D+2]=W[2],r[D+3]=W[3],r[D+4]=W[4],r[D+5]=W[5],r[D+6]=W[6],r[D+7]=W[7],r[D+8]=W[8],r[D+9]=W[9],r[D+10]=W[10],r[D+11]=W[11],r[D+12]=W[12],r[D+13]=W[13],r[D+14]=W[14],r[D+15]=W[15]}function m(c,r){const D=c.Ma(),W=D[0],B=D[1],t=D[2],u=D[3],a=D[4],H=D[5],x=D[6],M=D[7],E=D[8],m=D[9],Y=D[10],v=D[11],k=D[12],w=D[13],Z=D[14],J=D[15],q=Y*J-Z*v,j=m*J-w*v,X=m*Z-w*Y,e=E*J-k*v,y=E*Z-Y*k,U=E*w-k*m,N=+(H*q-x*j+M*X),g=-(a*q-x*e+M*y),z=+(a*j-H*e+M*U),S=-(a*X-H*y+x*U),K=W*N+B*g+t*z+u*S;if(0===K)return!1;const f=1/K,A=x*J-Z*M,h=H*J-w*M,L=H*Z-w*x,P=a*J-k*M,G=a*Z-k*x,d=a*w-k*H,T=x*v-Y*M,b=H*v-m*M,O=H*Y-m*x,C=a*v-E*M,p=a*Y-E*x,R=a*m-E*H,s=-(B*q-t*j+u*X),o=+(W*q-t*e+u*y),Q=-(W*j-B*e+u*U),l=+(W*X-B*y+t*U),F=+(B*A-t*h+u*L),I=-(W*A-t*P+u*G),i=+(W*h-B*P+u*d),n=-(W*L-B*G+t*d),V=-(B*T-t*b+u*O),cc=+(W*T-t*C+u*p),rc=-(W*b-B*C+u*R),Dc=+(W*O-B*p+t*R);return r[0]=N*f,r[1]=s*f,r[2]=F*f,r[3]=V*f,r[4]=g*f,r[5]=o*f,r[6]=I*f,r[7]=cc*f,r[8]=z*f,r[9]=Q*f,r[10]=i*f,r[11]=rc*f,r[12]=S*f,r[13]=l*f,r[14]=n*f,r[15]=Dc*f,!0}x._UpdateFlagSeed=0;const Y=c=>parseInt(c.toString().replace(/\W/g,""));class v{constructor(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=c,this.y=r}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let c=Y(this.x);return c=397*c^Y(this.y),c}toArray(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c[r]=this.x,c[r+1]=this.y,this}jD(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return v.FromArrayToRef(c,r,this),this}Ma(){return[this.x,this.y]}t(c){return this.x=c.x,this.y=c.y,this}Ja(c,r){return this.x=c,this.y=r,this}set(c,r){return this.Ja(c,r)}ja(c){return this.Ja(c,c)}add(c){return new v(this.x+c.x,this.y+c.y)}addToRef(c,r){return r.x=this.x+c.x,r.y=this.y+c.y,r}addInPlace(c){return this.x+=c.x,this.y+=c.y,this}addInPlaceFromFloats(c,r){return this.x+=c,this.y+=r,this}addVector3(c){return new v(this.x+c.x,this.y+c.y)}Jr(c){return new v(this.x-c.x,this.y-c.y)}subtractToRef(c,r){return r.x=this.x-c.x,r.y=this.y-c.y,r}BE(c){return this.x-=c.x,this.y-=c.y,this}multiplyInPlace(c){return this.x*=c.x,this.y*=c.y,this}multiply(c){return new v(this.x*c.x,this.y*c.y)}multiplyToRef(c,r){return r.x=this.x*c.x,r.y=this.y*c.y,r}multiplyByFloats(c,r){return new v(this.x*c,this.y*r)}divide(c){return new v(this.x/c.x,this.y/c.y)}divideToRef(c,r){return r.x=this.x/c.x,r.y=this.y/c.y,r}divideInPlace(c){return this.x=this.x/c.x,this.y=this.y/c.y,this}minimizeInPlace(c){return this.minimizeInPlaceFromFloats(c.x,c.y)}maximizeInPlace(c){return this.maximizeInPlaceFromFloats(c.x,c.y)}minimizeInPlaceFromFloats(c,r){return this.x=Math.min(c,this.x),this.y=Math.min(r,this.y),this}maximizeInPlaceFromFloats(c,r){return this.x=Math.max(c,this.x),this.y=Math.max(r,this.y),this}subtractFromFloats(c,r){return new v(this.x-c,this.y-r)}subtractFromFloatsToRef(c,r,D){return D.x=this.x-c,D.y=this.y-r,D}negate(){return new v(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(c){return c.x=-this.x,c.y=-this.y,c}scaleInPlace(c){return this.x*=c,this.y*=c,this}scale(c){return new v(this.x*c,this.y*c)}scaleToRef(c,r){return r.x=this.x*c,r.y=this.y*c,r}scaleAndAddToRef(c,r){return r.x+=this.x*c,r.y+=this.y*c,r}equals(c){return c&&this.x===c.x&&this.y===c.y}equalsWithEpsilon(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:W.c;return c&&(0,H.WithinEpsilon)(this.x,c.x,r)&&(0,H.WithinEpsilon)(this.y,c.y,r)}equalsToFloats(c,r){return this.x===c&&this.y===r}floor(){return new v(Math.floor(this.x),Math.floor(this.y))}floorToRef(c){return c.x=Math.floor(this.x),c.y=Math.floor(this.y),c}fract(){return new v(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(c){return c.x=this.x-Math.floor(this.x),c.y=this.y-Math.floor(this.y),c}rotate(c){return this.rotateToRef(c,new v)}rotateToRef(c,r){const D=Math.cos(c),W=Math.sin(c);return r.x=D*this.x-W*this.y,r.y=W*this.x+D*this.y,r}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(c){return 0===c||1===c?this:this.scaleInPlace(1/c)}normalizeToNew(){const c=new v;return this.normalizeToRef(c),c}normalizeToRef(c){const r=this.length();return 0===r&&(c.x=this.x,c.y=this.y),this.scaleToRef(1/r,c)}clone(){return new v(this.x,this.y)}dot(c){return this.x*c.x+this.y*c.y}static Zero(){return new v(0,0)}static One(){return new v(1,1)}static Random(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new v((0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r))}static RandomToRef(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ja((0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r))}static get ZeroReadOnly(){return v._ZeroReadOnly}static er(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new v(c[r],c[r+1])}static FromArrayToRef(c,r,D){return D.x=c[r],D.y=c[r+1],D}static FromFloatsToRef(c,r,D){return D.Ja(c,r),D}static CatmullRom(c,r,D,W,B){const t=B*B,u=B*t,a=.5*(2*r.x+(-c.x+D.x)*B+(2*c.x-5*r.x+4*D.x-W.x)*t+(-c.x+3*r.x-3*D.x+W.x)*u),H=.5*(2*r.y+(-c.y+D.y)*B+(2*c.y-5*r.y+4*D.y-W.y)*t+(-c.y+3*r.y-3*D.y+W.y)*u);return new v(a,H)}static ClampToRef(c,r,D,W){return W.x=(0,H.Clamp)(c.x,r.x,D.x),W.y=(0,H.Clamp)(c.y,r.y,D.y),W}static Clamp(c,r,D){const W=(0,H.Clamp)(c.x,r.x,D.x),B=(0,H.Clamp)(c.y,r.y,D.y);return new v(W,B)}static Hermite(c,r,D,W,B){const t=B*B,u=B*t,a=2*u-3*t+1,H=-2*u+3*t,x=u-2*t+B,M=u-t,E=c.x*a+D.x*H+r.x*x+W.x*M,m=c.y*a+D.y*H+r.y*x+W.y*M;return new v(E,m)}static Hermite1stDerivative(c,r,D,W,B){return this.Hermite1stDerivativeToRef(c,r,D,W,B,new v)}static Hermite1stDerivativeToRef(c,r,D,W,B,t){const u=B*B;return t.x=6*(u-B)*c.x+(3*u-4*B+1)*r.x+6*(-u+B)*D.x+(3*u-2*B)*W.x,t.y=6*(u-B)*c.y+(3*u-4*B+1)*r.y+6*(-u+B)*D.y+(3*u-2*B)*W.y,t}static Lerp(c,r,D){return v.LerpToRef(c,r,D,new v)}static LerpToRef(c,r,D,W){return W.x=c.x+(r.x-c.x)*D,W.y=c.y+(r.y-c.y)*D,W}static Dot(c,r){return c.x*r.x+c.y*r.y}static Normalize(c){return v.NormalizeToRef(c,new v)}static NormalizeToRef(c,r){return c.normalizeToRef(r),r}static Minimize(c,r){const D=c.x<r.x?c.x:r.x,W=c.y<r.y?c.y:r.y;return new v(D,W)}static Maximize(c,r){const D=c.x>r.x?c.x:r.x,W=c.y>r.y?c.y:r.y;return new v(D,W)}static Transform(c,r){return v.TransformToRef(c,r,new v)}static TransformToRef(c,r,D){const W=r.m,B=c.x*W[0]+c.y*W[4]+W[12],t=c.x*W[1]+c.y*W[5]+W[13];return D.x=B,D.y=t,D}static PointInTriangle(c,r,D,W){const B=.5*(-D.y*W.x+r.y*(-D.x+W.x)+r.x*(D.y-W.y)+D.x*W.y),t=B<0?-1:1,u=(r.y*W.x-r.x*W.y+(W.y-r.y)*c.x+(r.x-W.x)*c.y)*t,a=(r.x*D.y-r.y*D.x+(r.y-D.y)*c.x+(D.x-r.x)*c.y)*t;return u>0&&a>0&&u+a<2*B*t}static Distance(c,r){return Math.sqrt(v.DistanceSquared(c,r))}static DistanceSquared(c,r){const D=c.x-r.x,W=c.y-r.y;return D*D+W*W}static Center(c,r){return v.CenterToRef(c,r,new v)}static CenterToRef(c,r,D){return D.Ja((c.x+r.x)/2,(c.y+r.y)/2)}static DistanceOfPointFromSegment(c,r,D){const W=v.DistanceSquared(r,D);if(0===W)return v.Distance(c,r);const B=D.Jr(r),t=Math.max(0,Math.min(1,v.Dot(c.Jr(r),B)/W)),u=r.add(B.multiplyByFloats(t,t));return v.Distance(c,u)}}v._V8PerformanceHack=new v(.5,.5),v._ZeroReadOnly=v.Zero(),Object.defineProperties(v.prototype,{dimension:{value:[2]},rank:{value:1}});class k{get x(){return this._x}set x(c){this._x=c,this._isDirty=!0}get y(){return this._y}set y(c){this._y=c,this._isDirty=!0}get z(){return this._z}set z(c){this._z=c,this._isDirty=!0}constructor(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=c,this._y=r,this._z=D}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Zr"}getHashCode(){let c=Y(this._x);return c=397*c^Y(this._y),c=397*c^Y(this._z),c}Ma(){return[this._x,this._y,this._z]}toArray(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c[r]=this._x,c[r+1]=this._y,c[r+2]=this._z,this}jD(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k.FromArrayToRef(c,r,this),this}toQuaternion(){return Z.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(c){return this._x+=c._x,this._y+=c._y,this._z+=c._z,this._isDirty=!0,this}addInPlaceFromFloats(c,r,D){return this._x+=c,this._y+=r,this._z+=D,this._isDirty=!0,this}add(c){return new k(this._x+c._x,this._y+c._y,this._z+c._z)}addToRef(c,r){return r._x=this._x+c._x,r._y=this._y+c._y,r._z=this._z+c._z,r._isDirty=!0,r}BE(c){return this._x-=c._x,this._y-=c._y,this._z-=c._z,this._isDirty=!0,this}Jr(c){return new k(this._x-c._x,this._y-c._y,this._z-c._z)}subtractToRef(c,r){return this.subtractFromFloatsToRef(c._x,c._y,c._z,r)}subtractFromFloats(c,r,D){return new k(this._x-c,this._y-r,this._z-D)}subtractFromFloatsToRef(c,r,D,W){return W._x=this._x-c,W._y=this._y-r,W._z=this._z-D,W._isDirty=!0,W}negate(){return new k(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(c){return c._x=-1*this._x,c._y=-1*this._y,c._z=-1*this._z,c._isDirty=!0,c}scaleInPlace(c){return this._x*=c,this._y*=c,this._z*=c,this._isDirty=!0,this}scale(c){return new k(this._x*c,this._y*c,this._z*c)}scaleToRef(c,r){return r._x=this._x*c,r._y=this._y*c,r._z=this._z*c,r._isDirty=!0,r}getNormalToRef(c){const r=this.length();let D=Math.acos(this._y/r);const W=Math.atan2(this._z,this._x);D>Math.PI/2?D-=Math.PI/2:D+=Math.PI/2;const B=r*Math.sin(D)*Math.cos(W),t=r*Math.cos(D),u=r*Math.sin(D)*Math.sin(W);return c.set(B,t,u),c}applyRotationQuaternionToRef(c,r){const D=this._x,W=this._y,B=this._z,t=c._x,u=c._y,a=c._z,H=c._w,x=2*(u*B-a*W),M=2*(a*D-t*B),E=2*(t*W-u*D);return r._x=D+H*x+u*E-a*M,r._y=W+H*M+a*x-t*E,r._z=B+H*E+t*M-u*x,r._isDirty=!0,r}applyRotationQuaternionInPlace(c){return this.applyRotationQuaternionToRef(c,this)}applyRotationQuaternion(c){return this.applyRotationQuaternionToRef(c,new k)}scaleAndAddToRef(c,r){return r._x+=this._x*c,r._y+=this._y*c,r._z+=this._z*c,r._isDirty=!0,r}projectOnPlane(c,r){return this.projectOnPlaneToRef(c,r,new k)}projectOnPlaneToRef(c,r,D){const W=c.normal,B=c.d,t=q.Zr[0];this.subtractToRef(r,t),t.normalize();const u=k.Dot(t,W);if(Math.abs(u)<1e-10)D.ja(1/0);else{const c=-(k.Dot(r,W)+B)/u,a=t.scaleInPlace(c);r.addToRef(a,D)}return D}equals(c){return c&&this._x===c._x&&this._y===c._y&&this._z===c._z}equalsWithEpsilon(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:W.c;return c&&(0,H.WithinEpsilon)(this._x,c._x,r)&&(0,H.WithinEpsilon)(this._y,c._y,r)&&(0,H.WithinEpsilon)(this._z,c._z,r)}equalsToFloats(c,r,D){return this._x===c&&this._y===r&&this._z===D}multiplyInPlace(c){return this._x*=c._x,this._y*=c._y,this._z*=c._z,this._isDirty=!0,this}multiply(c){return this.multiplyByFloats(c._x,c._y,c._z)}multiplyToRef(c,r){return r._x=this._x*c._x,r._y=this._y*c._y,r._z=this._z*c._z,r._isDirty=!0,r}multiplyByFloats(c,r,D){return new k(this._x*c,this._y*r,this._z*D)}divide(c){return new k(this._x/c._x,this._y/c._y,this._z/c._z)}divideToRef(c,r){return r._x=this._x/c._x,r._y=this._y/c._y,r._z=this._z/c._z,r._isDirty=!0,r}divideInPlace(c){return this._x=this._x/c._x,this._y=this._y/c._y,this._z=this._z/c._z,this._isDirty=!0,this}minimizeInPlace(c){return this.minimizeInPlaceFromFloats(c._x,c._y,c._z)}maximizeInPlace(c){return this.maximizeInPlaceFromFloats(c._x,c._y,c._z)}minimizeInPlaceFromFloats(c,r,D){return c<this._x&&(this.x=c),r<this._y&&(this.y=r),D<this._z&&(this.z=D),this}maximizeInPlaceFromFloats(c,r,D){return c>this._x&&(this.x=c),r>this._y&&(this.y=r),D>this._z&&(this.z=D),this}isNonUniformWithinEpsilon(c){const r=Math.abs(this._x),D=Math.abs(this._y);if(!(0,H.WithinEpsilon)(r,D,c))return!0;const W=Math.abs(this._z);return!(0,H.WithinEpsilon)(r,W,c)||!(0,H.WithinEpsilon)(D,W,c)}get isNonUniform(){const c=Math.abs(this._x);if(c!==Math.abs(this._y))return!0;return c!==Math.abs(this._z)}floorToRef(c){return c._x=Math.floor(this._x),c._y=Math.floor(this._y),c._z=Math.floor(this._z),c._isDirty=!0,c}floor(){return new k(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(c){return c._x=this._x-Math.floor(this._x),c._y=this._y-Math.floor(this._y),c._z=this._z-Math.floor(this._z),c._isDirty=!0,c}fract(){return new k(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(c){if("xyz"===(c=c.toLowerCase()))return this;const r=q.Zr[0].t(this);return this.x=r[c[0]],this.y=r[c[1]],this.z=r[c[2]],this}rotateByQuaternionToRef(c,r){return c.toRotationMatrix(q.Matrix[0]),k.TransformCoordinatesToRef(this,q.Matrix[0],r),r}rotateByQuaternionAroundPointToRef(c,r,D){return this.subtractToRef(r,q.Zr[0]),q.Zr[0].rotateByQuaternionToRef(c,q.Zr[0]),r.addToRef(q.Zr[0],D),D}cross(c){return k.CrossToRef(this,c,new k)}normalizeFromLength(c){return 0===c||1===c?this:this.scaleInPlace(1/c)}normalizeToNew(){return this.normalizeToRef(new k)}normalizeToRef(c){const r=this.length();return 0===r||1===r?(c._x=this._x,c._y=this._y,c._z=this._z,c._isDirty=!0,c):this.scaleToRef(1/r,c)}clone(){return new k(this._x,this._y,this._z)}t(c){return this.Ja(c._x,c._y,c._z)}Ja(c,r,D){return this._x=c,this._y=r,this._z=D,this._isDirty=!0,this}set(c,r,D){return this.Ja(c,r,D)}ja(c){return this._x=this._y=this._z=c,this._isDirty=!0,this}static GetClipFactor(c,r,D,W){const B=k.Dot(c,D);return(B-W)/(B-k.Dot(r,D))}static GetAngleBetweenVectors(c,r,D){const W=c.normalizeToRef(q.Zr[1]),B=r.normalizeToRef(q.Zr[2]);let t=k.Dot(W,B);t=(0,H.Clamp)(t,-1,1);const u=Math.acos(t),a=q.Zr[3];return k.CrossToRef(W,B,a),k.Dot(a,D)>0?isNaN(u)?0:u:isNaN(u)?-Math.PI:-Math.acos(t)}static GetAngleBetweenVectorsOnPlane(c,r,D){q.Zr[0].t(c);const W=q.Zr[0];q.Zr[1].t(r);const B=q.Zr[1];q.Zr[2].t(D);const t=q.Zr[2],u=q.Zr[3],a=q.Zr[4];W.normalize(),B.normalize(),t.normalize(),k.CrossToRef(t,W,u),k.CrossToRef(u,t,a);const x=Math.atan2(k.Dot(B,u),k.Dot(B,a));return(0,H.NormalizeRadians)(x)}static PitchYawRollToMoveBetweenPointsToRef(c,r,D){const W=j.Zr[0];return r.subtractToRef(c,W),D._y=Math.atan2(W.x,W.z)||0,D._x=Math.atan2(Math.sqrt(W.x**2+W.z**2),W.y)||0,D._z=0,D._isDirty=!0,D}static PitchYawRollToMoveBetweenPoints(c,r){const D=k.Zero();return k.PitchYawRollToMoveBetweenPointsToRef(c,r,D)}static SlerpToRef(c,r,D,B){D=(0,H.Clamp)(D,0,1);const t=q.Zr[0],u=q.Zr[1];t.t(c);const a=t.length();t.normalizeFromLength(a),u.t(r);const x=u.length();u.normalizeFromLength(x);const M=k.Dot(t,u);let E,m;if(M<1-W.c){const c=Math.acos(M),r=1/Math.sin(c);E=Math.sin((1-D)*c)*r,m=Math.sin(D*c)*r}else E=1-D,m=D;return t.scaleInPlace(E),u.scaleInPlace(m),B.t(t).addInPlace(u),B.scaleInPlace((0,H.Lerp)(a,x,D)),B}static SmoothToRef(c,r,D,W,B){return k.SlerpToRef(c,r,0===W?1:D/W,B),B}static er(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new k(c[r],c[r+1],c[r+2])}static FromFloatArray(c,r){return k.er(c,r)}static FromArrayToRef(c,r,D){return D._x=c[r],D._y=c[r+1],D._z=c[r+2],D._isDirty=!0,D}static FromFloatArrayToRef(c,r,D){return k.FromArrayToRef(c,r,D)}static FromFloatsToRef(c,r,D,W){return W.Ja(c,r,D),W}static Zero(){return new k(0,0,0)}static One(){return new k(1,1,1)}static Up(){return new k(0,1,0)}static get UpReadOnly(){return k._UpReadOnly}static get DownReadOnly(){return k._DownReadOnly}static get RightReadOnly(){return k._RightReadOnly}static get LeftReadOnly(){return k._LeftReadOnly}static get LeftHandedForwardReadOnly(){return k._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return k._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return k._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return k._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return k._ZeroReadOnly}static get OneReadOnly(){return k._OneReadOnly}static Down(){return new k(0,-1,0)}static Forward(){return new k(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new k(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new k(1,0,0)}static Left(){return new k(-1,0,0)}static Random(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new k((0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r))}static RandomToRef(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ja((0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r))}static TransformCoordinates(c,r){const D=k.Zero();return k.TransformCoordinatesToRef(c,r,D),D}static TransformCoordinatesToRef(c,r,D){return k.TransformCoordinatesFromFloatsToRef(c._x,c._y,c._z,r,D),D}static TransformCoordinatesFromFloatsToRef(c,r,D,W,B){const t=W.m,u=c*t[0]+r*t[4]+D*t[8]+t[12],a=c*t[1]+r*t[5]+D*t[9]+t[13],H=c*t[2]+r*t[6]+D*t[10]+t[14],x=1/(c*t[3]+r*t[7]+D*t[11]+t[15]);return B._x=u*x,B._y=a*x,B._z=H*x,B._isDirty=!0,B}static TransformNormal(c,r){const D=k.Zero();return k.TransformNormalToRef(c,r,D),D}static TransformNormalToRef(c,r,D){return this.TransformNormalFromFloatsToRef(c._x,c._y,c._z,r,D),D}static TransformNormalFromFloatsToRef(c,r,D,W,B){const t=W.m;return B._x=c*t[0]+r*t[4]+D*t[8],B._y=c*t[1]+r*t[5]+D*t[9],B._z=c*t[2]+r*t[6]+D*t[10],B._isDirty=!0,B}static CatmullRom(c,r,D,W,B){const t=B*B,u=B*t,a=.5*(2*r._x+(-c._x+D._x)*B+(2*c._x-5*r._x+4*D._x-W._x)*t+(-c._x+3*r._x-3*D._x+W._x)*u),H=.5*(2*r._y+(-c._y+D._y)*B+(2*c._y-5*r._y+4*D._y-W._y)*t+(-c._y+3*r._y-3*D._y+W._y)*u),x=.5*(2*r._z+(-c._z+D._z)*B+(2*c._z-5*r._z+4*D._z-W._z)*t+(-c._z+3*r._z-3*D._z+W._z)*u);return new k(a,H,x)}static Clamp(c,r,D){const W=new k;return k.ClampToRef(c,r,D,W),W}static ClampToRef(c,r,D,W){let B=c._x;B=B>D._x?D._x:B,B=B<r._x?r._x:B;let t=c._y;t=t>D._y?D._y:t,t=t<r._y?r._y:t;let u=c._z;return u=u>D._z?D._z:u,u=u<r._z?r._z:u,W.Ja(B,t,u),W}static CheckExtends(c,r,D){r.minimizeInPlace(c),D.maximizeInPlace(c)}static Hermite(c,r,D,W,B){const t=B*B,u=B*t,a=2*u-3*t+1,H=-2*u+3*t,x=u-2*t+B,M=u-t,E=c._x*a+D._x*H+r._x*x+W._x*M,m=c._y*a+D._y*H+r._y*x+W._y*M,Y=c._z*a+D._z*H+r._z*x+W._z*M;return new k(E,m,Y)}static Hermite1stDerivative(c,r,D,W,B){const t=new k;return this.Hermite1stDerivativeToRef(c,r,D,W,B,t),t}static Hermite1stDerivativeToRef(c,r,D,W,B,t){const u=B*B;return t._x=6*(u-B)*c._x+(3*u-4*B+1)*r._x+6*(-u+B)*D._x+(3*u-2*B)*W._x,t._y=6*(u-B)*c._y+(3*u-4*B+1)*r._y+6*(-u+B)*D._y+(3*u-2*B)*W._y,t._z=6*(u-B)*c._z+(3*u-4*B+1)*r._z+6*(-u+B)*D._z+(3*u-2*B)*W._z,t._isDirty=!0,t}static Lerp(c,r,D){const W=new k(0,0,0);return k.LerpToRef(c,r,D,W),W}static LerpToRef(c,r,D,W){return W._x=c._x+(r._x-c._x)*D,W._y=c._y+(r._y-c._y)*D,W._z=c._z+(r._z-c._z)*D,W._isDirty=!0,W}static Dot(c,r){return c._x*r._x+c._y*r._y+c._z*r._z}dot(c){return this._x*c._x+this._y*c._y+this._z*c._z}static Cross(c,r){const D=new k;return k.CrossToRef(c,r,D),D}static CrossToRef(c,r,D){const W=c._y*r._z-c._z*r._y,B=c._z*r._x-c._x*r._z,t=c._x*r._y-c._y*r._x;return D.Ja(W,B,t),D}static Normalize(c){const r=k.Zero();return k.NormalizeToRef(c,r),r}static NormalizeToRef(c,r){return c.normalizeToRef(r),r}static Project(c,r,D,W){const B=new k;return k.ProjectToRef(c,r,D,W,B),B}static ProjectToRef(c,r,D,W,B){var t;const u=W.width,H=W.height,x=W.x,M=W.y,E=q.Matrix[1],m=null===(t=a.c.LastCreatedEngine)||void 0===t?void 0:t.isNDCHalfZRange,Y=m?1:.5,v=m?0:.5;J.FromValuesToRef(u/2,0,0,0,0,-H/2,0,0,0,0,Y,0,x+u/2,H/2+M,v,1,E);const w=q.Matrix[0];return r.multiplyToRef(D,w),w.multiplyToRef(E,w),k.TransformCoordinatesToRef(c,w,B),B}static Reflect(c,r){return this.ReflectToRef(c,r,new k)}static ReflectToRef(c,r,D){const W=j.Zr[0];return W.t(r).scaleInPlace(2*k.Dot(c,r)),D.t(c).BE(W)}static _UnprojectFromInvertedMatrixToRef(c,r,D){k.TransformCoordinatesToRef(c,r,D);const W=r.m,B=c._x*W[3]+c._y*W[7]+c._z*W[11]+W[15];return(0,H.WithinEpsilon)(B,1)&&D.scaleInPlace(1/B),D}static UnprojectFromTransform(c,r,D,W,B){return this.Unproject(c,r,D,W,B,J.IdentityReadOnly)}static Unproject(c,r,D,W,B,t){const u=new k;return k.UnprojectToRef(c,r,D,W,B,t,u),u}static UnprojectToRef(c,r,D,W,B,t,u){return k.UnprojectFloatsToRef(c._x,c._y,c._z,r,D,W,B,t,u),u}static UnprojectFloatsToRef(c,r,D,W,B,t,u,H,x){var M;const E=q.Matrix[0];t.multiplyToRef(u,E),E.multiplyToRef(H,E),E.invert();const m=q.Zr[0];return m.x=c/W*2-1,m.y=-(r/B*2-1),null!==(M=a.c.LastCreatedEngine)&&void 0!==M&&M.isNDCHalfZRange?m.z=D:m.z=2*D-1,k._UnprojectFromInvertedMatrixToRef(m,E,x),x}static Minimize(c,r){const D=new k;return D.t(c),D.minimizeInPlace(r),D}static Maximize(c,r){const D=new k;return D.t(c),D.maximizeInPlace(r),D}static Distance(c,r){return Math.sqrt(k.DistanceSquared(c,r))}static DistanceSquared(c,r){const D=c._x-r._x,W=c._y-r._y,B=c._z-r._z;return D*D+W*W+B*B}static ProjectOnTriangleToRef(c,r,D,B,t){const u=q.Zr[0],a=q.Zr[1],x=q.Zr[2],M=q.Zr[3],E=q.Zr[4];D.subtractToRef(r,u),B.subtractToRef(r,a),B.subtractToRef(D,x);const m=u.length(),Y=a.length(),v=x.length();if(m<W.c||Y<W.c||v<W.c)return t.t(r),k.Distance(c,r);c.subtractToRef(r,E),k.CrossToRef(u,a,M);const w=M.length();if(w<W.c)return t.t(r),k.Distance(c,r);M.normalizeFromLength(w);let Z=E.length();if(Z<W.c)return t.t(r),0;E.normalizeFromLength(Z);const J=k.Dot(M,E),j=q.Zr[5],X=q.Zr[6];j.t(M).scaleInPlace(-Z*J),X.t(c).addInPlace(j);const e=q.Zr[4],y=q.Zr[5],U=q.Zr[7],N=q.Zr[8];e.t(u).scaleInPlace(1/m),N.t(a).scaleInPlace(1/Y),e.addInPlace(N).scaleInPlace(-1),y.t(u).scaleInPlace(-1/m),N.t(x).scaleInPlace(1/v),y.addInPlace(N).scaleInPlace(-1),U.t(x).scaleInPlace(-1/v),N.t(a).scaleInPlace(-1/Y),U.addInPlace(N).scaleInPlace(-1);const g=q.Zr[9];let z;g.t(X).BE(r),k.CrossToRef(e,g,N),z=k.Dot(N,M);const S=z;g.t(X).BE(D),k.CrossToRef(y,g,N),z=k.Dot(N,M);const K=z;g.t(X).BE(B),k.CrossToRef(U,g,N),z=k.Dot(N,M);const f=z,A=q.Zr[10];let h,L;S>0&&K<0?(A.t(u),h=r,L=D):K>0&&f<0?(A.t(x),h=D,L=B):(A.t(a).scaleInPlace(-1),h=B,L=r);const P=q.Zr[9],G=q.Zr[4];h.subtractToRef(X,N),L.subtractToRef(X,P),k.CrossToRef(N,P,G);if(!(k.Dot(G,M)<0))return t.t(X),Math.abs(Z*J);const d=q.Zr[5];k.CrossToRef(A,G,d),d.normalize();const T=q.Zr[9];T.t(h).BE(X);const b=T.length();if(b<W.c)return t.t(h),k.Distance(c,h);T.normalizeFromLength(b);const O=k.Dot(d,T),C=q.Zr[7];C.t(X).addInPlace(d.scaleInPlace(b*O)),N.t(C).BE(h),Z=A.length(),A.normalizeFromLength(Z);let p=k.Dot(N,A)/Math.max(Z,W.c);return p=(0,H.Clamp)(p,0,1),C.t(h).addInPlace(A.scaleInPlace(p*Z)),t.t(C),k.Distance(c,C)}static Center(c,r){return k.CenterToRef(c,r,k.Zero())}static CenterToRef(c,r,D){return D.Ja((c._x+r._x)/2,(c._y+r._y)/2,(c._z+r._z)/2)}static RotationFromAxis(c,r,D){const W=new k;return k.RotationFromAxisToRef(c,r,D,W),W}static RotationFromAxisToRef(c,r,D,W){const B=q.Quaternion[0];return Z.RotationQuaternionFromAxisToRef(c,r,D,B),B.toEulerAnglesToRef(W),W}}k._V8PerformanceHack=new k(.5,.5,.5),k._UpReadOnly=k.Up(),k._DownReadOnly=k.Down(),k._LeftHandedForwardReadOnly=k.Forward(!1),k._RightHandedForwardReadOnly=k.Forward(!0),k._LeftHandedBackwardReadOnly=k.Backward(!1),k._RightHandedBackwardReadOnly=k.Backward(!0),k._RightReadOnly=k.Right(),k._LeftReadOnly=k.Left(),k._ZeroReadOnly=k.Zero(),k._OneReadOnly=k.One(),Object.defineProperties(k.prototype,{dimension:{value:[3]},rank:{value:1}});class w{get x(){return this._x}set x(c){this._x=c,this._isDirty=!0}get y(){return this._y}set y(c){this._y=c,this._isDirty=!0}get z(){return this._z}set z(c){this._z=c,this._isDirty=!0}get w(){return this._w}set w(c){this._w=c,this._isDirty=!0}constructor(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,W=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=c,this._y=r,this._z=D,this._w=W}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let c=Y(this._x);return c=397*c^Y(this._y),c=397*c^Y(this._z),c=397*c^Y(this._w),c}Ma(){return[this._x,this._y,this._z,this._w]}toArray(c,r){return void 0===r&&(r=0),c[r]=this._x,c[r+1]=this._y,c[r+2]=this._z,c[r+3]=this._w,this}jD(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w.FromArrayToRef(c,r,this),this}addInPlace(c){return this.x+=c._x,this.y+=c._y,this.z+=c._z,this.w+=c._w,this}addInPlaceFromFloats(c,r,D,W){return this.x+=c,this.y+=r,this.z+=D,this.w+=W,this}add(c){return new w(this._x+c.x,this._y+c.y,this._z+c.z,this._w+c.w)}addToRef(c,r){return r.x=this._x+c.x,r.y=this._y+c.y,r.z=this._z+c.z,r.w=this._w+c.w,r}BE(c){return this.x-=c.x,this.y-=c.y,this.z-=c.z,this.w-=c.w,this}Jr(c){return new w(this._x-c.x,this._y-c.y,this._z-c.z,this._w-c.w)}subtractToRef(c,r){return r.x=this._x-c.x,r.y=this._y-c.y,r.z=this._z-c.z,r.w=this._w-c.w,r}subtractFromFloats(c,r,D,W){return new w(this._x-c,this._y-r,this._z-D,this._w-W)}subtractFromFloatsToRef(c,r,D,W,B){return B.x=this._x-c,B.y=this._y-r,B.z=this._z-D,B.w=this._w-W,B}negate(){return new w(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(c){return c.x=-this._x,c.y=-this._y,c.z=-this._z,c.w=-this._w,c}scaleInPlace(c){return this.x*=c,this.y*=c,this.z*=c,this.w*=c,this}scale(c){return new w(this._x*c,this._y*c,this._z*c,this._w*c)}scaleToRef(c,r){return r.x=this._x*c,r.y=this._y*c,r.z=this._z*c,r.w=this._w*c,r}scaleAndAddToRef(c,r){return r.x+=this._x*c,r.y+=this._y*c,r.z+=this._z*c,r.w+=this._w*c,r}equals(c){return c&&this._x===c.x&&this._y===c.y&&this._z===c.z&&this._w===c.w}equalsWithEpsilon(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:W.c;return c&&(0,H.WithinEpsilon)(this._x,c.x,r)&&(0,H.WithinEpsilon)(this._y,c.y,r)&&(0,H.WithinEpsilon)(this._z,c.z,r)&&(0,H.WithinEpsilon)(this._w,c.w,r)}equalsToFloats(c,r,D,W){return this._x===c&&this._y===r&&this._z===D&&this._w===W}multiplyInPlace(c){return this.x*=c.x,this.y*=c.y,this.z*=c.z,this.w*=c.w,this}multiply(c){return new w(this._x*c.x,this._y*c.y,this._z*c.z,this._w*c.w)}multiplyToRef(c,r){return r.x=this._x*c.x,r.y=this._y*c.y,r.z=this._z*c.z,r.w=this._w*c.w,r}multiplyByFloats(c,r,D,W){return new w(this._x*c,this._y*r,this._z*D,this._w*W)}divide(c){return new w(this._x/c.x,this._y/c.y,this._z/c.z,this._w/c.w)}divideToRef(c,r){return r.x=this._x/c.x,r.y=this._y/c.y,r.z=this._z/c.z,r.w=this._w/c.w,r}divideInPlace(c){return this.divideToRef(c,this)}minimizeInPlace(c){return c.x<this._x&&(this.x=c.x),c.y<this._y&&(this.y=c.y),c.z<this._z&&(this.z=c.z),c.w<this._w&&(this.w=c.w),this}maximizeInPlace(c){return c.x>this._x&&(this.x=c.x),c.y>this._y&&(this.y=c.y),c.z>this._z&&(this.z=c.z),c.w>this._w&&(this.w=c.w),this}minimizeInPlaceFromFloats(c,r,D,W){return this.x=Math.min(c,this._x),this.y=Math.min(r,this._y),this.z=Math.min(D,this._z),this.w=Math.min(W,this._w),this}maximizeInPlaceFromFloats(c,r,D,W){return this.x=Math.max(c,this._x),this.y=Math.max(r,this._y),this.z=Math.max(D,this._z),this.w=Math.max(W,this._w),this}floorToRef(c){return c.x=Math.floor(this._x),c.y=Math.floor(this._y),c.z=Math.floor(this._z),c.w=Math.floor(this._w),c}floor(){return new w(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(c){return c.x=this._x-Math.floor(this._x),c.y=this._y-Math.floor(this._y),c.z=this._z-Math.floor(this._z),c.w=this._w-Math.floor(this._w),c}fract(){return new w(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(c){return 0===c||1===c?this:this.scaleInPlace(1/c)}normalizeToNew(){return this.normalizeToRef(new w)}normalizeToRef(c){const r=this.length();return 0===r||1===r?(c.x=this._x,c.y=this._y,c.z=this._z,c.w=this._w,c):this.scaleToRef(1/r,c)}toVector3(){return new k(this._x,this._y,this._z)}clone(){return new w(this._x,this._y,this._z,this._w)}t(c){return this.x=c.x,this.y=c.y,this.z=c.z,this.w=c.w,this}Ja(c,r,D,W){return this.x=c,this.y=r,this.z=D,this.w=W,this}set(c,r,D,W){return this.Ja(c,r,D,W)}ja(c){return this.x=this.y=this.z=this.w=c,this}dot(c){return this._x*c.x+this._y*c.y+this._z*c.z+this._w*c.w}static er(c,r){return r||(r=0),new w(c[r],c[r+1],c[r+2],c[r+3])}static FromArrayToRef(c,r,D){return D.x=c[r],D.y=c[r+1],D.z=c[r+2],D.w=c[r+3],D}static FromFloatArrayToRef(c,r,D){return w.FromArrayToRef(c,r,D),D}static FromFloatsToRef(c,r,D,W,B){return B.x=c,B.y=r,B.z=D,B.w=W,B}static Zero(){return new w(0,0,0,0)}static One(){return new w(1,1,1,1)}static Random(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new w((0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r))}static RandomToRef(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,D=arguments.length>2?arguments[2]:void 0;return D.x=(0,H.RandomRange)(c,r),D.y=(0,H.RandomRange)(c,r),D.z=(0,H.RandomRange)(c,r),D.w=(0,H.RandomRange)(c,r),D}static Clamp(c,r,D){return w.ClampToRef(c,r,D,new w)}static ClampToRef(c,r,D,W){return W.x=(0,H.Clamp)(c.x,r.x,D.x),W.y=(0,H.Clamp)(c.y,r.y,D.y),W.z=(0,H.Clamp)(c.z,r.z,D.z),W.w=(0,H.Clamp)(c.w,r.w,D.w),W}static CheckExtends(c,r,D){r.minimizeInPlace(c),D.maximizeInPlace(c)}static get ZeroReadOnly(){return w._ZeroReadOnly}static Normalize(c){return w.NormalizeToRef(c,new w)}static NormalizeToRef(c,r){return c.normalizeToRef(r),r}static Minimize(c,r){const D=new w;return D.t(c),D.minimizeInPlace(r),D}static Maximize(c,r){const D=new w;return D.t(c),D.maximizeInPlace(r),D}static Distance(c,r){return Math.sqrt(w.DistanceSquared(c,r))}static DistanceSquared(c,r){const D=c.x-r.x,W=c.y-r.y,B=c.z-r.z,t=c.w-r.w;return D*D+W*W+B*B+t*t}static Center(c,r){return w.CenterToRef(c,r,new w)}static CenterToRef(c,r,D){return D.x=(c.x+r.x)/2,D.y=(c.y+r.y)/2,D.z=(c.z+r.z)/2,D.w=(c.w+r.w)/2,D}static TransformCoordinates(c,r){return w.TransformCoordinatesToRef(c,r,new w)}static TransformCoordinatesToRef(c,r,D){return w.TransformCoordinatesFromFloatsToRef(c._x,c._y,c._z,r,D),D}static TransformCoordinatesFromFloatsToRef(c,r,D,W,B){const t=W.m,u=c*t[0]+r*t[4]+D*t[8]+t[12],a=c*t[1]+r*t[5]+D*t[9]+t[13],H=c*t[2]+r*t[6]+D*t[10]+t[14],x=c*t[3]+r*t[7]+D*t[11]+t[15];return B.x=u,B.y=a,B.z=H,B.w=x,B}static TransformNormal(c,r){return w.TransformNormalToRef(c,r,new w)}static TransformNormalToRef(c,r,D){const W=r.m,B=c.x*W[0]+c.y*W[4]+c.z*W[8],t=c.x*W[1]+c.y*W[5]+c.z*W[9],u=c.x*W[2]+c.y*W[6]+c.z*W[10];return D.x=B,D.y=t,D.z=u,D.w=c.w,D}static TransformNormalFromFloatsToRef(c,r,D,W,B,t){const u=B.m;return t.x=c*u[0]+r*u[4]+D*u[8],t.y=c*u[1]+r*u[5]+D*u[9],t.z=c*u[2]+r*u[6]+D*u[10],t.w=W,t}static FromVector3(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new w(c._x,c._y,c._z,r)}static Dot(c,r){return c.x*r.x+c.y*r.y+c.z*r.z+c.w*r.w}}w._V8PerformanceHack=new w(.5,.5,.5,.5),w._ZeroReadOnly=w.Zero(),Object.defineProperties(w.prototype,{dimension:{value:[4]},rank:{value:1}});class Z{get x(){return this._x}set x(c){this._x=c,this._isDirty=!0}get y(){return this._y}set y(c){this._y=c,this._isDirty=!0}get z(){return this._z}set z(c){this._z=c,this._isDirty=!0}get w(){return this._w}set w(c){this._w=c,this._isDirty=!0}constructor(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,W=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=c,this._y=r,this._z=D,this._w=W}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let c=Y(this._x);return c=397*c^Y(this._y),c=397*c^Y(this._z),c=397*c^Y(this._w),c}Ma(){return[this._x,this._y,this._z,this._w]}toArray(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c[r]=this._x,c[r+1]=this._y,c[r+2]=this._z,c[r+3]=this._w,this}jD(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z.FromArrayToRef(c,r,this)}equals(c){return c&&this._x===c._x&&this._y===c._y&&this._z===c._z&&this._w===c._w}equalsWithEpsilon(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:W.c;return c&&(0,H.WithinEpsilon)(this._x,c._x,r)&&(0,H.WithinEpsilon)(this._y,c._y,r)&&(0,H.WithinEpsilon)(this._z,c._z,r)&&(0,H.WithinEpsilon)(this._w,c._w,r)}isApprox(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:W.c;return c&&((0,H.WithinEpsilon)(this._x,c._x,r)&&(0,H.WithinEpsilon)(this._y,c._y,r)&&(0,H.WithinEpsilon)(this._z,c._z,r)&&(0,H.WithinEpsilon)(this._w,c._w,r)||(0,H.WithinEpsilon)(this._x,-c._x,r)&&(0,H.WithinEpsilon)(this._y,-c._y,r)&&(0,H.WithinEpsilon)(this._z,-c._z,r)&&(0,H.WithinEpsilon)(this._w,-c._w,r))}clone(){return new Z(this._x,this._y,this._z,this._w)}t(c){return this._x=c._x,this._y=c._y,this._z=c._z,this._w=c._w,this._isDirty=!0,this}Ja(c,r,D,W){return this._x=c,this._y=r,this._z=D,this._w=W,this._isDirty=!0,this}set(c,r,D,W){return this.Ja(c,r,D,W)}ja(c){return this.Ja(c,c,c,c)}add(c){return new Z(this._x+c._x,this._y+c._y,this._z+c._z,this._w+c._w)}addInPlace(c){return this._x+=c._x,this._y+=c._y,this._z+=c._z,this._w+=c._w,this._isDirty=!0,this}addToRef(c,r){return r._x=this._x+c._x,r._y=this._y+c._y,r._z=this._z+c._z,r._w=this._w+c._w,r._isDirty=!0,r}addInPlaceFromFloats(c,r,D,W){return this._x+=c,this._y+=r,this._z+=D,this._w+=W,this._isDirty=!0,this}subtractToRef(c,r){return r._x=this._x-c._x,r._y=this._y-c._y,r._z=this._z-c._z,r._w=this._w-c._w,r._isDirty=!0,r}subtractFromFloats(c,r,D,W){return this.subtractFromFloatsToRef(c,r,D,W,new Z)}subtractFromFloatsToRef(c,r,D,W,B){return B._x=this._x-c,B._y=this._y-r,B._z=this._z-D,B._w=this._w-W,B._isDirty=!0,B}Jr(c){return new Z(this._x-c._x,this._y-c._y,this._z-c._z,this._w-c._w)}BE(c){return this._x-=c._x,this._y-=c._y,this._z-=c._z,this._w-=c._w,this._isDirty=!0,this}scale(c){return new Z(this._x*c,this._y*c,this._z*c,this._w*c)}scaleToRef(c,r){return r._x=this._x*c,r._y=this._y*c,r._z=this._z*c,r._w=this._w*c,r._isDirty=!0,r}scaleInPlace(c){return this._x*=c,this._y*=c,this._z*=c,this._w*=c,this._isDirty=!0,this}scaleAndAddToRef(c,r){return r._x+=this._x*c,r._y+=this._y*c,r._z+=this._z*c,r._w+=this._w*c,r._isDirty=!0,r}multiply(c){const r=new Z(0,0,0,1);return this.multiplyToRef(c,r),r}multiplyToRef(c,r){const D=this._x*c._w+this._y*c._z-this._z*c._y+this._w*c._x,W=-this._x*c._z+this._y*c._w+this._z*c._x+this._w*c._y,B=this._x*c._y-this._y*c._x+this._z*c._w+this._w*c._z,t=-this._x*c._x-this._y*c._y-this._z*c._z+this._w*c._w;return r.Ja(D,W,B,t),r}multiplyInPlace(c){return this.multiplyToRef(c,this)}multiplyByFloats(c,r,D,W){return this._x*=c,this._y*=r,this._z*=D,this._w*=W,this._isDirty=!0,this}divide(c){throw new ReferenceError("Can not divide a quaternion")}divideToRef(c,r){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(c){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new Z)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(c){return c._x=-this._x,c._y=-this._y,c._z=-this._z,c._w=-this._w,c._isDirty=!0,c}equalsToFloats(c,r,D,W){return this._x===c&&this._y===r&&this._z===D&&this._w===W}floorToRef(c){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(c){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(c){return c.Ja(-this._x,-this._y,-this._z,this._w),c}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new Z(-this._x,-this._y,-this._z,this._w)}invert(){const c=this.conjugate(),r=this.lengthSquared();return 0==r||1==r||c.scaleInPlace(1/r),c}invertInPlace(){this.conjugateInPlace();const c=this.lengthSquared();return 0==c||1==c||this.scaleInPlace(1/c),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(c){return 0===c||1===c?this:this.scaleInPlace(1/c)}normalizeToNew(){const c=new Z(0,0,0,1);return this.normalizeToRef(c),c}normalizeToRef(c){const r=this.length();return 0===r||1===r?c.Ja(this._x,this._y,this._z,this._w):this.scaleToRef(1/r,c)}toEulerAngles(){const c=k.Zero();return this.toEulerAnglesToRef(c),c}toEulerAnglesToRef(c){const r=this._z,D=this._x,W=this._y,B=this._w,t=W*r-D*B,u=.4999999;if(t<-u)c._y=2*Math.atan2(W,B),c._x=Math.PI/2,c._z=0,c._isDirty=!0;else if(t>u)c._y=2*Math.atan2(W,B),c._x=-Math.PI/2,c._z=0,c._isDirty=!0;else{const u=B*B,a=r*r,H=D*D,x=W*W;c._z=Math.atan2(2*(D*W+r*B),-a-H+x+u),c._x=Math.asin(-2*t),c._y=Math.atan2(2*(r*D+W*B),a-H-x+u),c._isDirty=!0}return c}toAlphaBetaGammaToRef(c){const r=this._z,D=this._x,W=this._y,B=this._w,t=Math.sqrt(D*D+W*W),u=Math.sqrt(r*r+B*B),a=2*Math.atan2(t,u),H=2*Math.atan2(r,B),x=2*Math.atan2(W,D),M=(H+x)/2,E=(H-x)/2;return c.set(E,a,M),c}toRotationMatrix(c){return J.FromQuaternionToRef(this,c),c}fromRotationMatrix(c){return Z.FromRotationMatrixToRef(c,this),this}dot(c){return this._x*c._x+this._y*c._y+this._z*c._z+this._w*c._w}toAxisAngle(){const c=k.Zero();return{axis:c,angle:this.toAxisAngleToRef(c)}}toAxisAngleToRef(c){let r=0;const D=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),W=this._w;return D>0?(r=2*Math.atan2(D,W),c.set(this._x/D,this._y/D,this._z/D)):(r=0,c.set(1,0,0)),r}static FromRotationMatrix(c){const r=new Z;return Z.FromRotationMatrixToRef(c,r),r}static FromRotationMatrixToRef(c,r){const D=c.m,W=D[0],B=D[4],t=D[8],u=D[1],a=D[5],H=D[9],x=D[2],M=D[6],E=D[10],m=W+a+E;let Y;return m>0?(Y=.5/Math.sqrt(m+1),r._w=.25/Y,r._x=(M-H)*Y,r._y=(t-x)*Y,r._z=(u-B)*Y,r._isDirty=!0):W>a&&W>E?(Y=2*Math.sqrt(1+W-a-E),r._w=(M-H)/Y,r._x=.25*Y,r._y=(B+u)/Y,r._z=(t+x)/Y,r._isDirty=!0):a>E?(Y=2*Math.sqrt(1+a-W-E),r._w=(t-x)/Y,r._x=(B+u)/Y,r._y=.25*Y,r._z=(H+M)/Y,r._isDirty=!0):(Y=2*Math.sqrt(1+E-W-a),r._w=(u-B)/Y,r._x=(t+x)/Y,r._y=(H+M)/Y,r._z=.25*Y,r._isDirty=!0),r}static Dot(c,r){return c._x*r._x+c._y*r._y+c._z*r._z+c._w*r._w}static AreClose(c,r){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const W=Z.Dot(c,r);return 1-W*W<=D}static SmoothToRef(c,r,D,W,B){let t=0===W?1:D/W;return t=(0,H.Clamp)(t,0,1),Z.SlerpToRef(c,r,t,B),B}static Zero(){return new Z(0,0,0,0)}static Inverse(c){return new Z(-c._x,-c._y,-c._z,c._w)}static InverseToRef(c,r){return r.set(-c._x,-c._y,-c._z,c._w),r}static Identity(){return new Z(0,0,0,1)}static IsIdentity(c){return c&&0===c._x&&0===c._y&&0===c._z&&1===c._w}static RotationAxis(c,r){return Z.RotationAxisToRef(c,r,new Z)}static RotationAxisToRef(c,r,D){D._w=Math.cos(r/2);const W=Math.sin(r/2)/c.length();return D._x=c._x*W,D._y=c._y*W,D._z=c._z*W,D._isDirty=!0,D}static er(c,r){return r||(r=0),new Z(c[r],c[r+1],c[r+2],c[r+3])}static FromArrayToRef(c,r,D){return D._x=c[r],D._y=c[r+1],D._z=c[r+2],D._w=c[r+3],D._isDirty=!0,D}static FromFloatsToRef(c,r,D,W,B){return B.Ja(c,r,D,W),B}static FromEulerAngles(c,r,D){const W=new Z;return Z.RotationYawPitchRollToRef(r,c,D,W),W}static FromEulerAnglesToRef(c,r,D,W){return Z.RotationYawPitchRollToRef(r,c,D,W),W}static FromEulerVector(c){const r=new Z;return Z.RotationYawPitchRollToRef(c._y,c._x,c._z,r),r}static FromEulerVectorToRef(c,r){return Z.RotationYawPitchRollToRef(c._y,c._x,c._z,r),r}static FromUnitVectorsToRef(c,r,D){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:W.c;const t=k.Dot(c,r)+1;return t<B?Math.abs(c.x)>Math.abs(c.z)?D.set(-c.y,c.x,0,0):D.set(0,-c.z,c.y,0):(k.CrossToRef(c,r,j.Zr[0]),D.set(j.Zr[0].x,j.Zr[0].y,j.Zr[0].z,t)),D.normalize()}static RotationYawPitchRoll(c,r,D){const W=new Z;return Z.RotationYawPitchRollToRef(c,r,D,W),W}static RotationYawPitchRollToRef(c,r,D,W){const B=.5*D,t=.5*r,u=.5*c,a=Math.sin(B),H=Math.cos(B),x=Math.sin(t),M=Math.cos(t),E=Math.sin(u),m=Math.cos(u);return W._x=m*x*H+E*M*a,W._y=E*M*H-m*x*a,W._z=m*M*a-E*x*H,W._w=m*M*H+E*x*a,W._isDirty=!0,W}static RotationAlphaBetaGamma(c,r,D){const W=new Z;return Z.RotationAlphaBetaGammaToRef(c,r,D,W),W}static RotationAlphaBetaGammaToRef(c,r,D,W){const B=.5*(D+c),t=.5*(D-c),u=.5*r;return W._x=Math.cos(t)*Math.sin(u),W._y=Math.sin(t)*Math.sin(u),W._z=Math.sin(B)*Math.cos(u),W._w=Math.cos(B)*Math.cos(u),W._isDirty=!0,W}static RotationQuaternionFromAxis(c,r,D){const W=new Z(0,0,0,0);return Z.RotationQuaternionFromAxisToRef(c,r,D,W),W}static RotationQuaternionFromAxisToRef(c,r,D,W){const B=q.Matrix[0];return c=c.normalizeToRef(q.Zr[0]),r=r.normalizeToRef(q.Zr[1]),D=D.normalizeToRef(q.Zr[2]),J.FromXYZAxesToRef(c,r,D,B),Z.FromRotationMatrixToRef(B,W),W}static FromLookDirectionLH(c,r){const D=new Z;return Z.FromLookDirectionLHToRef(c,r,D),D}static FromLookDirectionLHToRef(c,r,D){const W=q.Matrix[0];return J.LookDirectionLHToRef(c,r,W),Z.FromRotationMatrixToRef(W,D),D}static FromLookDirectionRH(c,r){const D=new Z;return Z.FromLookDirectionRHToRef(c,r,D),D}static FromLookDirectionRHToRef(c,r,D){const W=q.Matrix[0];return J.LookDirectionRHToRef(c,r,W),Z.FromRotationMatrixToRef(W,D)}static Slerp(c,r,D){const W=Z.Identity();return Z.SlerpToRef(c,r,D,W),W}static SlerpToRef(c,r,D,W){let B,t,u=c._x*r._x+c._y*r._y+c._z*r._z+c._w*r._w,a=!1;if(u<0&&(a=!0,u=-u),u>.999999)t=1-D,B=a?-D:D;else{const c=Math.acos(u),r=1/Math.sin(c);t=Math.sin((1-D)*c)*r,B=a?-Math.sin(D*c)*r:Math.sin(D*c)*r}return W._x=t*c._x+B*r._x,W._y=t*c._y+B*r._y,W._z=t*c._z+B*r._z,W._w=t*c._w+B*r._w,W._isDirty=!0,W}static Hermite(c,r,D,W,B){const t=B*B,u=B*t,a=2*u-3*t+1,H=-2*u+3*t,x=u-2*t+B,M=u-t,E=c._x*a+D._x*H+r._x*x+W._x*M,m=c._y*a+D._y*H+r._y*x+W._y*M,Y=c._z*a+D._z*H+r._z*x+W._z*M,v=c._w*a+D._w*H+r._w*x+W._w*M;return new Z(E,m,Y,v)}static Hermite1stDerivative(c,r,D,W,B){const t=new Z;return this.Hermite1stDerivativeToRef(c,r,D,W,B,t),t}static Hermite1stDerivativeToRef(c,r,D,W,B,t){const u=B*B;return t._x=6*(u-B)*c._x+(3*u-4*B+1)*r._x+6*(-u+B)*D._x+(3*u-2*B)*W._x,t._y=6*(u-B)*c._y+(3*u-4*B+1)*r._y+6*(-u+B)*D._y+(3*u-2*B)*W._y,t._z=6*(u-B)*c._z+(3*u-4*B+1)*r._z+6*(-u+B)*D._z+(3*u-2*B)*W._z,t._w=6*(u-B)*c._w+(3*u-4*B+1)*r._w+6*(-u+B)*D._w+(3*u-2*B)*W._w,t._isDirty=!0,t}static Normalize(c){const r=Z.Zero();return Z.NormalizeToRef(c,r),r}static NormalizeToRef(c,r){return c.normalizeToRef(r),r}static Clamp(c,r,D){const W=new Z;return Z.ClampToRef(c,r,D,W),W}static ClampToRef(c,r,D,W){return W.Ja((0,H.Clamp)(c.x,r.x,D.x),(0,H.Clamp)(c.y,r.y,D.y),(0,H.Clamp)(c.z,r.z,D.z),(0,H.Clamp)(c.w,r.w,D.w))}static Random(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Z((0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r))}static RandomToRef(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ja((0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r),(0,H.RandomRange)(c,r))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(c,r){return Math.sqrt(Z.DistanceSquared(c,r))}static DistanceSquared(c,r){const D=c.x-r.x,W=c.y-r.y,B=c.z-r.z,t=c.w-r.w;return D*D+W*W+B*B+t*t}static Center(c,r){return Z.CenterToRef(c,r,Z.Zero())}static CenterToRef(c,r,D){return D.Ja((c.x+r.x)/2,(c.y+r.y)/2,(c.z+r.z)/2,(c.w+r.w)/2)}}Z._V8PerformanceHack=new Z(.5,.5,.5,.5),Object.defineProperties(Z.prototype,{dimension:{value:[4]},rank:{value:1}});class J{static get Use64Bits(){return u.d.MatrixUse64Bits}get m(){return this.Ba}markAsUpdated(){this.updateFlag=x._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(c){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],D=arguments.length>2&&void 0!==arguments[2]&&arguments[2],W=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=c,this._isIdentity3x2=c||D,this._isIdentityDirty=!this._isIdentity&&r,this._isIdentity3x2Dirty=!this._isIdentity3x2&&W}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,u.d.MatrixTrackPrecisionChange&&u.d.MatrixTrackedMatrices.push(this),this.Ba=new u.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const c=this.Ba;this._isIdentity=1===c[0]&&0===c[1]&&0===c[2]&&0===c[3]&&0===c[4]&&1===c[5]&&0===c[6]&&0===c[7]&&0===c[8]&&0===c[9]&&1===c[10]&&0===c[11]&&0===c[12]&&0===c[13]&&0===c[14]&&1===c[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Ba[0]||1!==this.Ba[5]||1!==this.Ba[15]||0!==this.Ba[1]||0!==this.Ba[2]||0!==this.Ba[3]||0!==this.Ba[4]||0!==this.Ba[6]||0!==this.Ba[7]||0!==this.Ba[8]||0!==this.Ba[9]||0!==this.Ba[10]||0!==this.Ba[11]||0!==this.Ba[12]||0!==this.Ba[13]||0!==this.Ba[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const c=this.Ba,r=c[0],D=c[1],W=c[2],B=c[3],t=c[4],u=c[5],a=c[6],H=c[7],x=c[8],M=c[9],E=c[10],m=c[11],Y=c[12],v=c[13],k=c[14],w=c[15],Z=E*w-k*m,J=M*w-v*m,q=M*k-v*E,j=x*w-Y*m,X=x*k-E*Y,e=x*v-Y*M;return r*+(u*Z-a*J+H*q)+D*-(t*Z-a*j+H*X)+W*+(t*J-u*j+H*e)+B*-(t*q-u*X+a*e)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!c)return this.Ba;const D=this.Ba;for(let W=0;W<16;W++)c[r+W]=D[W];return this}Ma(){return this.Ba}jD(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(c,r,this)}Ja(){for(var c=arguments.length,r=new Array(c),D=0;D<c;D++)r[D]=arguments[D];return J.FromArrayToRef(r,0,this)}set(){const c=this.Ba;for(let r=0;r<16;r++)c[r]=r<0||arguments.length<=r?void 0:arguments[r];return this.markAsUpdated(),this}ja(c){const r=this.Ba;for(let D=0;D<16;D++)r[D]=c;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return J.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(c){const r=new J;return this.addToRef(c,r),r}addToRef(c,r){const D=this.Ba,W=r.Ba,B=c.m;for(let t=0;t<16;t++)W[t]=D[t]+B[t];return r.markAsUpdated(),r}addToSelf(c){const r=this.Ba,D=c.m;return r[0]+=D[0],r[1]+=D[1],r[2]+=D[2],r[3]+=D[3],r[4]+=D[4],r[5]+=D[5],r[6]+=D[6],r[7]+=D[7],r[8]+=D[8],r[9]+=D[9],r[10]+=D[10],r[11]+=D[11],r[12]+=D[12],r[13]+=D[13],r[14]+=D[14],r[15]+=D[15],this.markAsUpdated(),this}addInPlace(c){const r=this.Ba,D=c.m;for(let W=0;W<16;W++)r[W]+=D[W];return this.markAsUpdated(),this}addInPlaceFromFloats(){const c=this.Ba;for(let r=0;r<16;r++)c[r]+=r<0||arguments.length<=r?void 0:arguments[r];return this.markAsUpdated(),this}Jr(c){const r=this.Ba,D=c.m;for(let W=0;W<16;W++)r[W]-=D[W];return this.markAsUpdated(),this}subtractToRef(c,r){const D=this.Ba,W=c.m,B=r.Ba;for(let t=0;t<16;t++)B[t]=D[t]-W[t];return r.markAsUpdated(),r}BE(c){const r=this.Ba,D=c.m;for(let W=0;W<16;W++)r[W]-=D[W];return this.markAsUpdated(),this}subtractFromFloats(){for(var c=arguments.length,r=new Array(c),D=0;D<c;D++)r[D]=arguments[D];return this.subtractFromFloatsToRef(...r,new J)}subtractFromFloatsToRef(){for(var c=arguments.length,r=new Array(c),D=0;D<c;D++)r[D]=arguments[D];const W=r.pop(),B=this.Ba,t=W.Ba,u=r;for(let a=0;a<16;a++)t[a]=B[a]-u[a];return W.markAsUpdated(),W}invertToRef(c){return!0===this._isIdentity?(J.IdentityToRef(c),c):(m(this,c.Ma())?c.markAsUpdated():c.t(this),c)}addAtIndex(c,r){return this.Ba[c]+=r,this.markAsUpdated(),this}multiplyAtIndex(c,r){return this.Ba[c]*=r,this.markAsUpdated(),this}setTranslationFromFloats(c,r,D){return this.Ba[12]=c,this.Ba[13]=r,this.Ba[14]=D,this.markAsUpdated(),this}addTranslationFromFloats(c,r,D){return this.Ba[12]+=c,this.Ba[13]+=r,this.Ba[14]+=D,this.markAsUpdated(),this}setTranslation(c){return this.setTranslationFromFloats(c._x,c._y,c._z)}getTranslation(){return new k(this.Ba[12],this.Ba[13],this.Ba[14])}getTranslationToRef(c){return c.x=this.Ba[12],c.y=this.Ba[13],c.z=this.Ba[14],c}removeRotationAndScaling(){const c=this.m;return J.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,c[12],c[13],c[14],c[15],this),this._updateIdentityStatus(0===c[12]&&0===c[13]&&0===c[14]&&1===c[15]),this}t(c){c.copyToArray(this.Ba);const r=c;return this.updateFlag=r.updateFlag,this._updateIdentityStatus(r._isIdentity,r._isIdentityDirty,r._isIdentity3x2,r._isIdentity3x2Dirty),this}copyToArray(c){return E(this,c,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(c){const r=new J;return this.multiplyToRef(c,r),r}multiplyInPlace(c){const r=this.Ba,D=c.m;for(let W=0;W<16;W++)r[W]*=D[W];return this.markAsUpdated(),this}multiplyByFloats(){const c=this.Ba;for(let r=0;r<16;r++)c[r]*=r<0||arguments.length<=r?void 0:arguments[r];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var c=arguments.length,r=new Array(c),D=0;D<c;D++)r[D]=arguments[D];const W=r.pop(),B=this.Ba,t=W.Ba,u=r;for(let a=0;a<16;a++)t[a]=B[a]*u[a];return W.markAsUpdated(),W}multiplyToRef(c,r){return this._isIdentity?(r.t(c),r):c._isIdentity?(r.t(this),r):(this.multiplyToArray(c,r.Ba,0),r.markAsUpdated(),r)}multiplyToArray(c,r,D){return M(this,c,r,D),this}divide(c){return this.divideToRef(c,new J)}divideToRef(c,r){const D=this.Ba,W=c.m,B=r.Ba;for(let t=0;t<16;t++)B[t]=D[t]/W[t];return r.markAsUpdated(),r}divideInPlace(c){const r=this.Ba,D=c.m;for(let W=0;W<16;W++)r[W]/=D[W];return this.markAsUpdated(),this}minimizeInPlace(c){const r=this.Ba,D=c.m;for(let W=0;W<16;W++)r[W]=Math.min(r[W],D[W]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const c=this.Ba;for(let r=0;r<16;r++)c[r]=Math.min(c[r],r<0||arguments.length<=r?void 0:arguments[r]);return this.markAsUpdated(),this}maximizeInPlace(c){const r=this.Ba,D=c.m;for(let W=0;W<16;W++)r[W]=Math.min(r[W],D[W]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const c=this.Ba;for(let r=0;r<16;r++)c[r]=Math.min(c[r],r<0||arguments.length<=r?void 0:arguments[r]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new J)}negateInPlace(){const c=this.Ba;for(let r=0;r<16;r++)c[r]=-c[r];return this.markAsUpdated(),this}negateToRef(c){const r=this.Ba,D=c.Ba;for(let W=0;W<16;W++)D[W]=-r[W];return c.markAsUpdated(),c}equals(c){const r=c;if(!r)return!1;if((this._isIdentity||r._isIdentity)&&!this._isIdentityDirty&&!r._isIdentityDirty)return this._isIdentity&&r._isIdentity;const D=this.m,W=r.m;return D[0]===W[0]&&D[1]===W[1]&&D[2]===W[2]&&D[3]===W[3]&&D[4]===W[4]&&D[5]===W[5]&&D[6]===W[6]&&D[7]===W[7]&&D[8]===W[8]&&D[9]===W[9]&&D[10]===W[10]&&D[11]===W[11]&&D[12]===W[12]&&D[13]===W[13]&&D[14]===W[14]&&D[15]===W[15]}equalsWithEpsilon(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const D=this.Ba,W=c.m;for(let B=0;B<16;B++)if(!(0,H.WithinEpsilon)(D[B],W[B],r))return!1;return!0}equalsToFloats(){const c=this.Ba;for(let r=0;r<16;r++)if(c[r]!=(r<0||arguments.length<=r?void 0:arguments[r]))return!1;return!0}floor(){return this.floorToRef(new J)}floorToRef(c){const r=this.Ba,D=c.Ba;for(let W=0;W<16;W++)D[W]=Math.floor(r[W]);return c.markAsUpdated(),c}fract(){return this.fractToRef(new J)}fractToRef(c){const r=this.Ba,D=c.Ba;for(let W=0;W<16;W++)D[W]=r[W]-Math.floor(r[W]);return c.markAsUpdated(),c}clone(){const c=new J;return c.t(this),c}getClassName(){return"Matrix"}getHashCode(){let c=Y(this.Ba[0]);for(let r=1;r<16;r++)c=397*c^Y(this.Ba[r]);return c}decomposeToTransformNode(c){return c.rotationQuaternion=c.rotationQuaternion||new Z,this.decompose(c.qa,c.rotationQuaternion,c.position)}decompose(c,r,D,W){let B=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return D&&D.ja(0),c&&c.ja(1),r&&r.Ja(0,0,0,1),!0;const t=this.Ba;if(D&&D.Ja(t[12],t[13],t[14]),(c=c||q.Zr[0]).x=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),c.y=Math.sqrt(t[4]*t[4]+t[5]*t[5]+t[6]*t[6]),c.z=Math.sqrt(t[8]*t[8]+t[9]*t[9]+t[10]*t[10]),W){const r=(B?W.absoluteScaling.x:W.qa.x)<0?-1:1,D=(B?W.absoluteScaling.y:W.qa.y)<0?-1:1,t=(B?W.absoluteScaling.z:W.qa.z)<0?-1:1;c.x*=r,c.y*=D,c.z*=t}else this.determinant()<=0&&(c.y*=-1);if(0===c._x||0===c._y||0===c._z)return r&&r.Ja(0,0,0,1),!1;if(r){const D=1/c._x,W=1/c._y,B=1/c._z;J.FromValuesToRef(t[0]*D,t[1]*D,t[2]*D,0,t[4]*W,t[5]*W,t[6]*W,0,t[8]*B,t[9]*B,t[10]*B,0,0,0,0,1,q.Matrix[0]),Z.FromRotationMatrixToRef(q.Matrix[0],r)}return!0}getRow(c){if(c<0||c>3)return null;const r=4*c;return new w(this.Ba[r+0],this.Ba[r+1],this.Ba[r+2],this.Ba[r+3])}getRowToRef(c,r){if(c>=0&&c<=3){const D=4*c;r.x=this.Ba[D+0],r.y=this.Ba[D+1],r.z=this.Ba[D+2],r.w=this.Ba[D+3]}return r}setRow(c,r){return this.setRowFromFloats(c,r.x,r.y,r.z,r.w)}transpose(){const c=new J;return J.TransposeToRef(this,c),c}transposeToRef(c){return J.TransposeToRef(this,c),c}setRowFromFloats(c,r,D,W,B){if(c<0||c>3)return this;const t=4*c;return this.Ba[t+0]=r,this.Ba[t+1]=D,this.Ba[t+2]=W,this.Ba[t+3]=B,this.markAsUpdated(),this}scale(c){const r=new J;return this.scaleToRef(c,r),r}scaleToRef(c,r){for(let D=0;D<16;D++)r.Ba[D]=this.Ba[D]*c;return r.markAsUpdated(),r}scaleAndAddToRef(c,r){for(let D=0;D<16;D++)r.Ba[D]+=this.Ba[D]*c;return r.markAsUpdated(),r}scaleInPlace(c){const r=this.Ba;for(let D=0;D<16;D++)r[D]*=c;return this.markAsUpdated(),this}toNormalMatrix(c){const r=q.Matrix[0];this.invertToRef(r),r.transposeToRef(c);const D=c.Ba;return J.FromValuesToRef(D[0],D[1],D[2],0,D[4],D[5],D[6],0,D[8],D[9],D[10],0,0,0,0,1,c),c}getRotationMatrix(){const c=new J;return this.getRotationMatrixToRef(c),c}getRotationMatrixToRef(c){const r=q.Zr[0];if(!this.decompose(r))return J.IdentityToRef(c),c;const D=this.Ba,W=1/r._x,B=1/r._y,t=1/r._z;return J.FromValuesToRef(D[0]*W,D[1]*W,D[2]*W,0,D[4]*B,D[5]*B,D[6]*B,0,D[8]*t,D[9]*t,D[10]*t,0,0,0,0,1,c),c}toggleModelMatrixHandInPlace(){const c=this.Ba;return c[2]*=-1,c[6]*=-1,c[8]*=-1,c[9]*=-1,c[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const c=this.Ba;return c[8]*=-1,c[9]*=-1,c[10]*=-1,c[11]*=-1,this.markAsUpdated(),this}static er(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const D=new J;return J.FromArrayToRef(c,r,D),D}static FromArrayToRef(c,r,D){for(let W=0;W<16;W++)D.Ba[W]=c[W+r];return D.markAsUpdated(),D}static FromFloat32ArrayToRefScaled(c,r,D,W){return W.Ba[0]=c[0+r]*D,W.Ba[1]=c[1+r]*D,W.Ba[2]=c[2+r]*D,W.Ba[3]=c[3+r]*D,W.Ba[4]=c[4+r]*D,W.Ba[5]=c[5+r]*D,W.Ba[6]=c[6+r]*D,W.Ba[7]=c[7+r]*D,W.Ba[8]=c[8+r]*D,W.Ba[9]=c[9+r]*D,W.Ba[10]=c[10+r]*D,W.Ba[11]=c[11+r]*D,W.Ba[12]=c[12+r]*D,W.Ba[13]=c[13+r]*D,W.Ba[14]=c[14+r]*D,W.Ba[15]=c[15+r]*D,W.markAsUpdated(),W}static get IdentityReadOnly(){return J._IdentityReadOnly}static FromValuesToRef(c,r,D,W,B,t,u,a,H,x,M,E,m,Y,v,k,w){const Z=w.Ba;Z[0]=c,Z[1]=r,Z[2]=D,Z[3]=W,Z[4]=B,Z[5]=t,Z[6]=u,Z[7]=a,Z[8]=H,Z[9]=x,Z[10]=M,Z[11]=E,Z[12]=m,Z[13]=Y,Z[14]=v,Z[15]=k,w.markAsUpdated()}static FromValues(c,r,D,W,B,t,u,a,H,x,M,E,m,Y,v,k){const w=new J,Z=w.Ba;return Z[0]=c,Z[1]=r,Z[2]=D,Z[3]=W,Z[4]=B,Z[5]=t,Z[6]=u,Z[7]=a,Z[8]=H,Z[9]=x,Z[10]=M,Z[11]=E,Z[12]=m,Z[13]=Y,Z[14]=v,Z[15]=k,w.markAsUpdated(),w}static Compose(c,r,D){const W=new J;return J.ComposeToRef(c,r,D,W),W}static ComposeToRef(c,r,D,W){const B=W.Ba,t=r._x,u=r._y,a=r._z,H=r._w,x=t+t,M=u+u,E=a+a,m=t*x,Y=t*M,v=t*E,k=u*M,w=u*E,Z=a*E,J=H*x,q=H*M,j=H*E,X=c._x,e=c._y,y=c._z;return B[0]=(1-(k+Z))*X,B[1]=(Y+j)*X,B[2]=(v-q)*X,B[3]=0,B[4]=(Y-j)*e,B[5]=(1-(m+Z))*e,B[6]=(w+J)*e,B[7]=0,B[8]=(v+q)*y,B[9]=(w-J)*y,B[10]=(1-(m+k))*y,B[11]=0,B[12]=D._x,B[13]=D._y,B[14]=D._z,B[15]=1,W.markAsUpdated(),W}static Identity(){const c=J.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return c._updateIdentityStatus(!0),c}static IdentityToRef(c){return J.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,c),c._updateIdentityStatus(!0),c}static Zero(){const c=J.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return c._updateIdentityStatus(!1),c}static RotationX(c){const r=new J;return J.RotationXToRef(c,r),r}static Invert(c){const r=new J;return c.invertToRef(r),r}static RotationXToRef(c,r){const D=Math.sin(c),W=Math.cos(c);return J.FromValuesToRef(1,0,0,0,0,W,D,0,0,-D,W,0,0,0,0,1,r),r._updateIdentityStatus(1===W&&0===D),r}static RotationY(c){const r=new J;return J.RotationYToRef(c,r),r}static RotationYToRef(c,r){const D=Math.sin(c),W=Math.cos(c);return J.FromValuesToRef(W,0,-D,0,0,1,0,0,D,0,W,0,0,0,0,1,r),r._updateIdentityStatus(1===W&&0===D),r}static RotationZ(c){const r=new J;return J.RotationZToRef(c,r),r}static RotationZToRef(c,r){const D=Math.sin(c),W=Math.cos(c);return J.FromValuesToRef(W,D,0,0,-D,W,0,0,0,0,1,0,0,0,0,1,r),r._updateIdentityStatus(1===W&&0===D),r}static RotationAxis(c,r){const D=new J;return J.RotationAxisToRef(c,r,D),D}static RotationAxisToRef(c,r,D){const W=Math.sin(-r),B=Math.cos(-r),t=1-B;c=c.normalizeToRef(q.Zr[0]);const u=D.Ba;return u[0]=c._x*c._x*t+B,u[1]=c._x*c._y*t-c._z*W,u[2]=c._x*c._z*t+c._y*W,u[3]=0,u[4]=c._y*c._x*t+c._z*W,u[5]=c._y*c._y*t+B,u[6]=c._y*c._z*t-c._x*W,u[7]=0,u[8]=c._z*c._x*t-c._y*W,u[9]=c._z*c._y*t+c._x*W,u[10]=c._z*c._z*t+B,u[11]=0,u[12]=0,u[13]=0,u[14]=0,u[15]=1,D.markAsUpdated(),D}static RotationAlignToRef(c,r,D){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const t=k.Dot(r,c),u=D.Ba;if(t<-1+W.c)u[0]=-1,u[1]=0,u[2]=0,u[3]=0,u[4]=0,u[5]=B?1:-1,u[6]=0,u[7]=0,u[8]=0,u[9]=0,u[10]=B?-1:1,u[11]=0;else{const D=k.Cross(r,c),W=1/(1+t);u[0]=D._x*D._x*W+t,u[1]=D._y*D._x*W-D._z,u[2]=D._z*D._x*W+D._y,u[3]=0,u[4]=D._x*D._y*W+D._z,u[5]=D._y*D._y*W+t,u[6]=D._z*D._y*W-D._x,u[7]=0,u[8]=D._x*D._z*W-D._y,u[9]=D._y*D._z*W+D._x,u[10]=D._z*D._z*W+t,u[11]=0}return u[12]=0,u[13]=0,u[14]=0,u[15]=1,D.markAsUpdated(),D}static RotationYawPitchRoll(c,r,D){const W=new J;return J.RotationYawPitchRollToRef(c,r,D,W),W}static RotationYawPitchRollToRef(c,r,D,W){return Z.RotationYawPitchRollToRef(c,r,D,q.Quaternion[0]),q.Quaternion[0].toRotationMatrix(W),W}static Scaling(c,r,D){const W=new J;return J.ScalingToRef(c,r,D,W),W}static ScalingToRef(c,r,D,W){return J.FromValuesToRef(c,0,0,0,0,r,0,0,0,0,D,0,0,0,0,1,W),W._updateIdentityStatus(1===c&&1===r&&1===D),W}static Translation(c,r,D){const W=new J;return J.TranslationToRef(c,r,D,W),W}static TranslationToRef(c,r,D,W){return J.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,c,r,D,1,W),W._updateIdentityStatus(0===c&&0===r&&0===D),W}static Lerp(c,r,D){const W=new J;return J.LerpToRef(c,r,D,W),W}static LerpToRef(c,r,D,W){const B=W.Ba,t=c.m,u=r.m;for(let a=0;a<16;a++)B[a]=t[a]*(1-D)+u[a]*D;return W.markAsUpdated(),W}static DecomposeLerp(c,r,D){const W=new J;return J.DecomposeLerpToRef(c,r,D,W),W}static DecomposeLerpToRef(c,r,D,W){const B=q.Zr[0],t=q.Quaternion[0],u=q.Zr[1];c.decompose(B,t,u);const a=q.Zr[2],H=q.Quaternion[1],x=q.Zr[3];r.decompose(a,H,x);const M=q.Zr[4];k.LerpToRef(B,a,D,M);const E=q.Quaternion[2];Z.SlerpToRef(t,H,D,E);const m=q.Zr[5];return k.LerpToRef(u,x,D,m),J.ComposeToRef(M,E,m,W),W}static LookAtLH(c,r,D){const W=new J;return J.LookAtLHToRef(c,r,D,W),W}static LookAtLHToRef(c,r,D,W){const B=q.Zr[0],t=q.Zr[1],u=q.Zr[2];r.subtractToRef(c,u),u.normalize(),k.CrossToRef(D,u,B);const a=B.lengthSquared();0===a?B.x=1:B.normalizeFromLength(Math.sqrt(a)),k.CrossToRef(u,B,t),t.normalize();const H=-k.Dot(B,c),x=-k.Dot(t,c),M=-k.Dot(u,c);return J.FromValuesToRef(B._x,t._x,u._x,0,B._y,t._y,u._y,0,B._z,t._z,u._z,0,H,x,M,1,W),W}static LookAtRH(c,r,D){const W=new J;return J.LookAtRHToRef(c,r,D,W),W}static LookAtRHToRef(c,r,D,W){const B=q.Zr[0],t=q.Zr[1],u=q.Zr[2];c.subtractToRef(r,u),u.normalize(),k.CrossToRef(D,u,B);const a=B.lengthSquared();0===a?B.x=1:B.normalizeFromLength(Math.sqrt(a)),k.CrossToRef(u,B,t),t.normalize();const H=-k.Dot(B,c),x=-k.Dot(t,c),M=-k.Dot(u,c);return J.FromValuesToRef(B._x,t._x,u._x,0,B._y,t._y,u._y,0,B._z,t._z,u._z,0,H,x,M,1,W),W}static LookDirectionLH(c,r){const D=new J;return J.LookDirectionLHToRef(c,r,D),D}static LookDirectionLHToRef(c,r,D){const W=q.Zr[0];W.t(c),W.scaleInPlace(-1);const B=q.Zr[1];return k.CrossToRef(r,W,B),J.FromValuesToRef(B._x,B._y,B._z,0,r._x,r._y,r._z,0,W._x,W._y,W._z,0,0,0,0,1,D),D}static LookDirectionRH(c,r){const D=new J;return J.LookDirectionRHToRef(c,r,D),D}static LookDirectionRHToRef(c,r,D){const W=q.Zr[2];return k.CrossToRef(r,c,W),J.FromValuesToRef(W._x,W._y,W._z,0,r._x,r._y,r._z,0,c._x,c._y,c._z,0,0,0,0,1,D),D}static OrthoLH(c,r,D,W,B){const t=new J;return J.OrthoLHToRef(c,r,D,W,t,B),t}static OrthoLHToRef(c,r,D,W,B,t){const u=2/c,a=2/r,H=2/(W-D),x=-(W+D)/(W-D);return J.FromValuesToRef(u,0,0,0,0,a,0,0,0,0,H,0,0,0,x,1,B),t&&B.multiplyToRef(X,B),B._updateIdentityStatus(1===u&&1===a&&1===H&&0===x),B}static OrthoOffCenterLH(c,r,D,W,B,t,u){const a=new J;return J.OrthoOffCenterLHToRef(c,r,D,W,B,t,a,u),a}static OrthoOffCenterLHToRef(c,r,D,W,B,t,u,a){const H=2/(r-c),x=2/(W-D),M=2/(t-B),E=-(t+B)/(t-B),m=(c+r)/(c-r),Y=(W+D)/(D-W);return J.FromValuesToRef(H,0,0,0,0,x,0,0,0,0,M,0,m,Y,E,1,u),a&&u.multiplyToRef(X,u),u.markAsUpdated(),u}static ObliqueOffCenterLHToRef(c,r,D,W,B,t,u,a,H,x,M){const E=-u*Math.cos(a),m=-u*Math.sin(a);return J.TranslationToRef(0,0,-H,q.Matrix[1]),J.FromValuesToRef(1,0,0,0,0,1,0,0,E,m,1,0,0,0,0,1,q.Matrix[0]),q.Matrix[1].multiplyToRef(q.Matrix[0],q.Matrix[0]),J.TranslationToRef(0,0,H,q.Matrix[1]),q.Matrix[0].multiplyToRef(q.Matrix[1],q.Matrix[0]),J.OrthoOffCenterLHToRef(c,r,D,W,B,t,x,M),q.Matrix[0].multiplyToRef(x,x),x}static OrthoOffCenterRH(c,r,D,W,B,t,u){const a=new J;return J.OrthoOffCenterRHToRef(c,r,D,W,B,t,a,u),a}static OrthoOffCenterRHToRef(c,r,D,W,B,t,u,a){return J.OrthoOffCenterLHToRef(c,r,D,W,B,t,u,a),u.Ba[10]*=-1,u}static ObliqueOffCenterRHToRef(c,r,D,W,B,t,u,a,H,x,M){const E=u*Math.cos(a),m=u*Math.sin(a);return J.TranslationToRef(0,0,H,q.Matrix[1]),J.FromValuesToRef(1,0,0,0,0,1,0,0,E,m,1,0,0,0,0,1,q.Matrix[0]),q.Matrix[1].multiplyToRef(q.Matrix[0],q.Matrix[0]),J.TranslationToRef(0,0,-H,q.Matrix[1]),q.Matrix[0].multiplyToRef(q.Matrix[1],q.Matrix[0]),J.OrthoOffCenterRHToRef(c,r,D,W,B,t,x,M),q.Matrix[0].multiplyToRef(x,x),x}static PerspectiveLH(c,r,D,W,B){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const u=new J,a=2*D/c,H=2*D/r,x=(W+D)/(W-D),M=-2*W*D/(W-D),E=Math.tan(t);return J.FromValuesToRef(a,0,0,0,0,H,0,E,0,0,x,1,0,0,M,0,u),B&&u.multiplyToRef(X,u),u._updateIdentityStatus(!1),u}static PerspectiveFovLH(c,r,D,W,B){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,u=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=new J;return J.PerspectiveFovLHToRef(c,r,D,W,a,!0,B,t,u),a}static PerspectiveFovLHToRef(c,r,D,W,B){let t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,H=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const x=D,M=W,E=1/Math.tan(.5*c),m=t?E/r:E,Y=t?E:E*r,v=H&&0===x?-1:0!==M?(M+x)/(M-x):1,k=H&&0===x?2*M:0!==M?-2*M*x/(M-x):-2*x,w=Math.tan(a);return J.FromValuesToRef(m,0,0,0,0,Y,0,w,0,0,v,1,0,0,k,0,B),u&&B.multiplyToRef(X,B),B._updateIdentityStatus(!1),B}static PerspectiveFovReverseLHToRef(c,r,D,W,B){let t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const H=1/Math.tan(.5*c),x=t?H/r:H,M=t?H:H*r,E=Math.tan(a);return J.FromValuesToRef(x,0,0,0,0,M,0,E,0,0,-D,1,0,0,1,0,B),u&&B.multiplyToRef(X,B),B._updateIdentityStatus(!1),B}static PerspectiveFovRH(c,r,D,W,B){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,u=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=new J;return J.PerspectiveFovRHToRef(c,r,D,W,a,!0,B,t,u),a}static PerspectiveFovRHToRef(c,r,D,W,B){let t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,H=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const x=D,M=W,E=1/Math.tan(.5*c),m=t?E/r:E,Y=t?E:E*r,v=H&&0===x?1:0!==M?-(M+x)/(M-x):-1,k=H&&0===x?2*M:0!==M?-2*M*x/(M-x):-2*x,w=Math.tan(a);return J.FromValuesToRef(m,0,0,0,0,Y,0,w,0,0,v,-1,0,0,k,0,B),u&&B.multiplyToRef(X,B),B._updateIdentityStatus(!1),B}static PerspectiveFovReverseRHToRef(c,r,D,W,B){let t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const H=1/Math.tan(.5*c),x=t?H/r:H,M=t?H:H*r,E=Math.tan(a);return J.FromValuesToRef(x,0,0,0,0,M,0,E,0,0,-D,-1,0,0,-1,0,B),u&&B.multiplyToRef(X,B),B._updateIdentityStatus(!1),B}static GetFinalMatrix(c,r,D,W,B,t){const u=c.width,a=c.height,H=c.x,x=c.y,M=J.FromValues(u/2,0,0,0,0,-a/2,0,0,0,0,t-B,0,H+u/2,a/2+x,B,1),E=new J;return r.multiplyToRef(D,E),E.multiplyToRef(W,E),E.multiplyToRef(M,E)}static GetAsMatrix2x2(c){const r=c.m,D=[r[0],r[1],r[4],r[5]];return u.d.MatrixUse64Bits?D:new Float32Array(D)}static GetAsMatrix3x3(c){const r=c.m,D=[r[0],r[1],r[2],r[4],r[5],r[6],r[8],r[9],r[10]];return u.d.MatrixUse64Bits?D:new Float32Array(D)}static Transpose(c){const r=new J;return J.TransposeToRef(c,r),r}static TransposeToRef(c,r){const D=c.m,W=D[0],B=D[4],t=D[8],u=D[12],a=D[1],H=D[5],x=D[9],M=D[13],E=D[2],m=D[6],Y=D[10],v=D[14],k=D[3],w=D[7],Z=D[11],J=D[15],q=r.Ba;return q[0]=W,q[1]=B,q[2]=t,q[3]=u,q[4]=a,q[5]=H,q[6]=x,q[7]=M,q[8]=E,q[9]=m,q[10]=Y,q[11]=v,q[12]=k,q[13]=w,q[14]=Z,q[15]=J,r.markAsUpdated(),r._updateIdentityStatus(c._isIdentity,c._isIdentityDirty),r}static Reflection(c){const r=new J;return J.ReflectionToRef(c,r),r}static ReflectionToRef(c,r){c.normalize();const D=c.normal.x,W=c.normal.y,B=c.normal.z,t=-2*D,u=-2*W,a=-2*B;return J.FromValuesToRef(t*D+1,u*D,a*D,0,t*W,u*W+1,a*W,0,t*B,u*B,a*B+1,0,t*c.d,u*c.d,a*c.d,1,r),r}static FromXYZAxesToRef(c,r,D,W){return J.FromValuesToRef(c._x,c._y,c._z,0,r._x,r._y,r._z,0,D._x,D._y,D._z,0,0,0,0,1,W),W}static FromQuaternionToRef(c,r){const D=c._x*c._x,W=c._y*c._y,B=c._z*c._z,t=c._x*c._y,u=c._z*c._w,a=c._z*c._x,H=c._y*c._w,x=c._y*c._z,M=c._x*c._w;return r.Ba[0]=1-2*(W+B),r.Ba[1]=2*(t+u),r.Ba[2]=2*(a-H),r.Ba[3]=0,r.Ba[4]=2*(t-u),r.Ba[5]=1-2*(B+D),r.Ba[6]=2*(x+M),r.Ba[7]=0,r.Ba[8]=2*(a+H),r.Ba[9]=2*(x-M),r.Ba[10]=1-2*(W+D),r.Ba[11]=0,r.Ba[12]=0,r.Ba[13]=0,r.Ba[14]=0,r.Ba[15]=1,r.markAsUpdated(),r}}J._IdentityReadOnly=J.Identity(),Object.defineProperties(J.prototype,{dimension:{value:[4,4]},rank:{value:2}});class q{}q.Zr=(0,B.f)(11,k.Zero),q.Matrix=(0,B.f)(2,J.Identity),q.Quaternion=(0,B.f)(3,Z.Zero);class j{}j.Vector2=(0,B.f)(3,v.Zero),j.Zr=(0,B.f)(13,k.Zero),j.Vector4=(0,B.f)(3,w.Zero),j.Quaternion=(0,B.f)(3,Z.Zero),j.Matrix=(0,B.f)(8,J.Identity),(0,t.e)("BABYLON.Vector2",v),(0,t.e)("BABYLON.Vector3",k),(0,t.e)("BABYLON.Vector4",w),(0,t.e)("BABYLON.Matrix",J);const X=J.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11694:(c,r,D)=>{function W(c,r){const D=[];for(let W=0;W<c;++W)D.push(r());return D}function B(c,r){return W(c,r)}D.d(r,{d:()=>W,f:()=>B,h:()=>u});const t=["push","splice","pop","shift","unshift"];function u(c,r){const D=t.map((D=>function(c,r,D){const W=c[r];if("function"!==typeof W)return null;const B=function(){const W=c.length,t=B.previous.apply(c,arguments);return D(r,W),t};return W.next=B,B.previous=W,c[r]=B,()=>{const D=B.previous;if(!D)return;const W=B.next;W?(D.next=W,W.previous=D):(D.next=void 0,c[r]=D),B.next=void 0,B.previous=void 0}}(c,D,r)));return()=>{for(const c of D)null===c||void 0===c||c()}}}}]);