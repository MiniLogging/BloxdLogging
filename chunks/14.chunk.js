"use strict";(self.n52dyox90qa=self.n52dyox90qa||[]).push([[14],{11817:(E,t,z)=>{z.d(t,{c:()=>u,e:()=>R,g:()=>A,j:()=>X});const A=1/2.2,X=2.2,R=(1+Math.sqrt(5))/2,u=.001},11834:(E,t,z)=>{function A(E){return parseInt(E.toString().replace(/\W/g,""))}function X(E,t){let z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(E-t)<=z}function R(E,t,z){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return E<t-A||E>z+A}function u(E,t){return E===t?E:Math.random()*(t-E)+E}function p(E,t,z){return E+(t-E)*z}function C(E,t,z){let A=a(t-E,360);return A>180&&(A-=360),E+A*d(z)}function Z(E,t,z){let A=0;return A=E!=t?d((z-E)/(t-E)):0,A}function H(E,t,z,A,X){const R=X*X,u=X*R;return E*(2*u-3*R+1)+z*(-2*u+3*R)+t*(u-2*R+X)+A*(u-R)}function h(E,t,z,A,X){const R=X*X;return 6*(R-X)*E+(3*R-4*X+1)*t+6*(-R+X)*z+(3*R-2*X)*A}function d(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(z,Math.max(t,E))}function y(E){return E-=2*Math.PI*Math.floor((E+Math.PI)/(2*Math.PI))}function O(E){const t=E.toString(16);return E<=15?("0"+t).toUpperCase():t.toUpperCase()}function c(E){if(Math.log2)return Math.floor(Math.log2(E));if(E<0)return NaN;if(0===E)return-1/0;let t=0;if(E<1){for(;E<1;)t++,E*=2;t=-t}else if(E>1)for(;E>1;)t++,E=Math.floor(E/2);return t}function a(E,t){return E-Math.floor(E/t)*t}function L(E,t,z){return(E-t)/(z-t)}function mE(E,t,z){return E*(z-t)+t}function W(E,t){let z=a(t-E,360);return z>180&&(z-=360),z}function I(E,t){const z=a(E,2*t);return t-Math.abs(z-t)}function e(E,t,z){let A=d(z);return A=-2*A*A*A+3*A*A,t*A+E*(1-A)}function D(E,t,z){let A=0;return A=Math.abs(t-E)<=z?t:E+Math.sign(t-E)*z,A}function S(E,t,z){const A=W(E,t);let X=0;return X=-z<A&&A<z?t:D(E,t=E+A,z),X}function l(E,t,z){return(E-t)/(z-t)}function f(E,t,z){return(z-t)*E+t}function K(E,t){const z=E%t;return 0===z?t:K(t,z)}z.r(t),z.d(t,{Clamp:()=>d,DeltaAngle:()=>W,Denormalize:()=>mE,ExtractAsInt:()=>A,Hermite:()=>H,Hermite1stDerivative:()=>h,HighestCommonFactor:()=>K,ILog2:()=>c,InverseLerp:()=>Z,Lerp:()=>p,LerpAngle:()=>C,MoveTowards:()=>D,MoveTowardsAngle:()=>S,Normalize:()=>L,NormalizeRadians:()=>y,OutsideRange:()=>R,PercentToRange:()=>f,PingPong:()=>I,RandomRange:()=>u,RangeToPercent:()=>l,Repeat:()=>a,SmoothStep:()=>e,ToHex:()=>O,WithinEpsilon:()=>X})},11812:(E,t,z)=>{z.r(t),z.d(t,{Matrix:()=>mE,Quaternion:()=>L,TmpVectors:()=>I,Vector2:()=>O,Lt:()=>c,Vector4:()=>a});var A=z(11817),X=z(11826),R=z(11766),u=z(11745),p=z(11667),C=z(11834);class Z{}function H(E,t,z){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const X=E.upE(),R=t.upE(),u=X[0],p=X[1],C=X[2],Z=X[3],H=X[4],h=X[5],d=X[6],y=X[7],O=X[8],c=X[9],a=X[10],L=X[11],mE=X[12],W=X[13],I=X[14],e=X[15],D=R[0],S=R[1],l=R[2],f=R[3],K=R[4],F=R[5],B=R[6],b=R[7],x=R[8],J=R[9],V=R[10],r=R[11],i=R[12],g=R[13],o=R[14],Q=R[15];z[A]=u*D+p*K+C*x+Z*i,z[A+1]=u*S+p*F+C*J+Z*g,z[A+2]=u*l+p*B+C*V+Z*o,z[A+3]=u*f+p*b+C*r+Z*Q,z[A+4]=H*D+h*K+d*x+y*i,z[A+5]=H*S+h*F+d*J+y*g,z[A+6]=H*l+h*B+d*V+y*o,z[A+7]=H*f+h*b+d*r+y*Q,z[A+8]=O*D+c*K+a*x+L*i,z[A+9]=O*S+c*F+a*J+L*g,z[A+10]=O*l+c*B+a*V+L*o,z[A+11]=O*f+c*b+a*r+L*Q,z[A+12]=mE*D+W*K+I*x+e*i,z[A+13]=mE*S+W*F+I*J+e*g,z[A+14]=mE*l+W*B+I*V+e*o,z[A+15]=mE*f+W*b+I*r+e*Q}function h(E,t){let z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const A=E.upE();t[z]=A[0],t[z+1]=A[1],t[z+2]=A[2],t[z+3]=A[3],t[z+4]=A[4],t[z+5]=A[5],t[z+6]=A[6],t[z+7]=A[7],t[z+8]=A[8],t[z+9]=A[9],t[z+10]=A[10],t[z+11]=A[11],t[z+12]=A[12],t[z+13]=A[13],t[z+14]=A[14],t[z+15]=A[15]}function d(E,t){const z=E.upE(),A=z[0],X=z[1],R=z[2],u=z[3],p=z[4],C=z[5],Z=z[6],H=z[7],h=z[8],d=z[9],y=z[10],O=z[11],c=z[12],a=z[13],L=z[14],mE=z[15],W=y*mE-L*O,I=d*mE-a*O,e=d*L-a*y,D=h*mE-c*O,S=h*L-y*c,l=h*a-c*d,f=+(C*W-Z*I+H*e),K=-(p*W-Z*D+H*S),F=+(p*I-C*D+H*l),B=-(p*e-C*S+Z*l),b=A*f+X*K+R*F+u*B;if(0===b)return!1;const x=1/b,J=Z*mE-L*H,V=C*mE-a*H,r=C*L-a*Z,i=p*mE-c*H,g=p*L-c*Z,o=p*a-c*C,Q=Z*O-y*H,T=C*O-d*H,q=C*y-d*Z,M=p*O-h*H,w=p*y-h*Z,n=p*d-h*C,s=-(X*W-R*I+u*e),j=+(A*W-R*D+u*S),U=-(A*I-X*D+u*l),k=+(A*e-X*S+R*l),v=+(X*J-R*V+u*r),Y=-(A*J-R*i+u*g),G=+(A*V-X*i+u*o),N=-(A*r-X*g+R*o),P=-(X*Q-R*T+u*q),EE=+(A*Q-R*M+u*w),tE=-(A*T-X*M+u*n),zE=+(A*q-X*w+R*n);return t[0]=f*x,t[1]=s*x,t[2]=v*x,t[3]=P*x,t[4]=K*x,t[5]=j*x,t[6]=Y*x,t[7]=EE*x,t[8]=F*x,t[9]=U*x,t[10]=G*x,t[11]=tE*x,t[12]=B*x,t[13]=k*x,t[14]=N*x,t[15]=zE*x,!0}Z._UpdateFlagSeed=0;const y=E=>parseInt(E.toString().replace(/\W/g,""));class O{constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=E,this.y=t}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let E=y(this.x);return E=397*E^y(this.y),E}toArray(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[t]=this.x,E[t+1]=this.y,this}Dz(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(E,t,this),this}upE(){return[this.x,this.y]}R(E){return this.x=E.x,this.y=E.y,this}Op(E,t){return this.x=E,this.y=t,this}set(E,t){return this.Op(E,t)}ap(E){return this.Op(E,E)}add(E){return new O(this.x+E.x,this.y+E.y)}addToRef(E,t){return t.x=this.x+E.x,t.y=this.y+E.y,t}addInPlace(E){return this.x+=E.x,this.y+=E.y,this}addInPlaceFromFloats(E,t){return this.x+=E,this.y+=t,this}addVector3(E){return new O(this.x+E.x,this.y+E.y)}Wt(E){return new O(this.x-E.x,this.y-E.y)}subtractToRef(E,t){return t.x=this.x-E.x,t.y=this.y-E.y,t}kH(E){return this.x-=E.x,this.y-=E.y,this}multiplyInPlace(E){return this.x*=E.x,this.y*=E.y,this}multiply(E){return new O(this.x*E.x,this.y*E.y)}multiplyToRef(E,t){return t.x=this.x*E.x,t.y=this.y*E.y,t}multiplyByFloats(E,t){return new O(this.x*E,this.y*t)}divide(E){return new O(this.x/E.x,this.y/E.y)}divideToRef(E,t){return t.x=this.x/E.x,t.y=this.y/E.y,t}divideInPlace(E){return this.x=this.x/E.x,this.y=this.y/E.y,this}minimizeInPlace(E){return this.minimizeInPlaceFromFloats(E.x,E.y)}maximizeInPlace(E){return this.maximizeInPlaceFromFloats(E.x,E.y)}minimizeInPlaceFromFloats(E,t){return this.x=Math.min(E,this.x),this.y=Math.min(t,this.y),this}maximizeInPlaceFromFloats(E,t){return this.x=Math.max(E,this.x),this.y=Math.max(t,this.y),this}subtractFromFloats(E,t){return new O(this.x-E,this.y-t)}subtractFromFloatsToRef(E,t,z){return z.x=this.x-E,z.y=this.y-t,z}negate(){return new O(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(E){return E.x=-this.x,E.y=-this.y,E}scaleInPlace(E){return this.x*=E,this.y*=E,this}scale(E){return new O(this.x*E,this.y*E)}scaleToRef(E,t){return t.x=this.x*E,t.y=this.y*E,t}scaleAndAddToRef(E,t){return t.x+=this.x*E,t.y+=this.y*E,t}equals(E){return E&&this.x===E.x&&this.y===E.y}equalsWithEpsilon(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return E&&(0,C.WithinEpsilon)(this.x,E.x,t)&&(0,C.WithinEpsilon)(this.y,E.y,t)}equalsToFloats(E,t){return this.x===E&&this.y===t}floor(){return new O(Math.floor(this.x),Math.floor(this.y))}floorToRef(E){return E.x=Math.floor(this.x),E.y=Math.floor(this.y),E}fract(){return new O(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(E){return E.x=this.x-Math.floor(this.x),E.y=this.y-Math.floor(this.y),E}rotate(E){return this.rotateToRef(E,new O)}rotateToRef(E,t){const z=Math.cos(E),A=Math.sin(E);return t.x=z*this.x-A*this.y,t.y=A*this.x+z*this.y,t}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){const E=new O;return this.normalizeToRef(E),E}normalizeToRef(E){const t=this.length();return 0===t&&(E.x=this.x,E.y=this.y),this.scaleToRef(1/t,E)}clone(){return new O(this.x,this.y)}dot(E){return this.x*E.x+this.y*E.y}static Zero(){return new O(0,0)}static One(){return new O(1,1)}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new O((0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Op((0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t))}static get ZeroReadOnly(){return O._ZeroReadOnly}static St(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new O(E[t],E[t+1])}static FromArrayToRef(E,t,z){return z.x=E[t],z.y=E[t+1],z}static FromFloatsToRef(E,t,z){return z.Op(E,t),z}static CatmullRom(E,t,z,A,X){const R=X*X,u=X*R,p=.5*(2*t.x+(-E.x+z.x)*X+(2*E.x-5*t.x+4*z.x-A.x)*R+(-E.x+3*t.x-3*z.x+A.x)*u),C=.5*(2*t.y+(-E.y+z.y)*X+(2*E.y-5*t.y+4*z.y-A.y)*R+(-E.y+3*t.y-3*z.y+A.y)*u);return new O(p,C)}static ClampToRef(E,t,z,A){return A.x=(0,C.Clamp)(E.x,t.x,z.x),A.y=(0,C.Clamp)(E.y,t.y,z.y),A}static Clamp(E,t,z){const A=(0,C.Clamp)(E.x,t.x,z.x),X=(0,C.Clamp)(E.y,t.y,z.y);return new O(A,X)}static Hermite(E,t,z,A,X){const R=X*X,u=X*R,p=2*u-3*R+1,C=-2*u+3*R,Z=u-2*R+X,H=u-R,h=E.x*p+z.x*C+t.x*Z+A.x*H,d=E.y*p+z.y*C+t.y*Z+A.y*H;return new O(h,d)}static Hermite1stDerivative(E,t,z,A,X){return this.Hermite1stDerivativeToRef(E,t,z,A,X,new O)}static Hermite1stDerivativeToRef(E,t,z,A,X,R){const u=X*X;return R.x=6*(u-X)*E.x+(3*u-4*X+1)*t.x+6*(-u+X)*z.x+(3*u-2*X)*A.x,R.y=6*(u-X)*E.y+(3*u-4*X+1)*t.y+6*(-u+X)*z.y+(3*u-2*X)*A.y,R}static Lerp(E,t,z){return O.LerpToRef(E,t,z,new O)}static LerpToRef(E,t,z,A){return A.x=E.x+(t.x-E.x)*z,A.y=E.y+(t.y-E.y)*z,A}static Dot(E,t){return E.x*t.x+E.y*t.y}static Normalize(E){return O.NormalizeToRef(E,new O)}static NormalizeToRef(E,t){return E.normalizeToRef(t),t}static Minimize(E,t){const z=E.x<t.x?E.x:t.x,A=E.y<t.y?E.y:t.y;return new O(z,A)}static Maximize(E,t){const z=E.x>t.x?E.x:t.x,A=E.y>t.y?E.y:t.y;return new O(z,A)}static Transform(E,t){return O.TransformToRef(E,t,new O)}static TransformToRef(E,t,z){const A=t.m,X=E.x*A[0]+E.y*A[4]+A[12],R=E.x*A[1]+E.y*A[5]+A[13];return z.x=X,z.y=R,z}static PointInTriangle(E,t,z,A){const X=.5*(-z.y*A.x+t.y*(-z.x+A.x)+t.x*(z.y-A.y)+z.x*A.y),R=X<0?-1:1,u=(t.y*A.x-t.x*A.y+(A.y-t.y)*E.x+(t.x-A.x)*E.y)*R,p=(t.x*z.y-t.y*z.x+(t.y-z.y)*E.x+(z.x-t.x)*E.y)*R;return u>0&&p>0&&u+p<2*X*R}static Distance(E,t){return Math.sqrt(O.DistanceSquared(E,t))}static DistanceSquared(E,t){const z=E.x-t.x,A=E.y-t.y;return z*z+A*A}static Center(E,t){return O.CenterToRef(E,t,new O)}static CenterToRef(E,t,z){return z.Op((E.x+t.x)/2,(E.y+t.y)/2)}static DistanceOfPointFromSegment(E,t,z){const A=O.DistanceSquared(t,z);if(0===A)return O.Distance(E,t);const X=z.Wt(t),R=Math.max(0,Math.min(1,O.Dot(E.Wt(t),X)/A)),u=t.add(X.multiplyByFloats(R,R));return O.Distance(E,u)}}O._V8PerformanceHack=new O(.5,.5),O._ZeroReadOnly=O.Zero(),Object.defineProperties(O.prototype,{dimension:{value:[2]},rank:{value:1}});class c{get x(){return this._x}set x(E){this._x=E,this._isDirty=!0}get y(){return this._y}set y(E){this._y=E,this._isDirty=!0}get z(){return this._z}set z(E){this._z=E,this._isDirty=!0}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=E,this._y=t,this._z=z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Lt"}getHashCode(){let E=y(this._x);return E=397*E^y(this._y),E=397*E^y(this._z),E}upE(){return[this._x,this._y,this._z]}toArray(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[t]=this._x,E[t+1]=this._y,E[t+2]=this._z,this}Dz(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c.FromArrayToRef(E,t,this),this}toQuaternion(){return L.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(E){return this._x+=E._x,this._y+=E._y,this._z+=E._z,this._isDirty=!0,this}addInPlaceFromFloats(E,t,z){return this._x+=E,this._y+=t,this._z+=z,this._isDirty=!0,this}add(E){return new c(this._x+E._x,this._y+E._y,this._z+E._z)}addToRef(E,t){return t._x=this._x+E._x,t._y=this._y+E._y,t._z=this._z+E._z,t._isDirty=!0,t}kH(E){return this._x-=E._x,this._y-=E._y,this._z-=E._z,this._isDirty=!0,this}Wt(E){return new c(this._x-E._x,this._y-E._y,this._z-E._z)}subtractToRef(E,t){return this.subtractFromFloatsToRef(E._x,E._y,E._z,t)}subtractFromFloats(E,t,z){return new c(this._x-E,this._y-t,this._z-z)}subtractFromFloatsToRef(E,t,z,A){return A._x=this._x-E,A._y=this._y-t,A._z=this._z-z,A._isDirty=!0,A}negate(){return new c(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(E){return E._x=-1*this._x,E._y=-1*this._y,E._z=-1*this._z,E._isDirty=!0,E}scaleInPlace(E){return this._x*=E,this._y*=E,this._z*=E,this._isDirty=!0,this}scale(E){return new c(this._x*E,this._y*E,this._z*E)}scaleToRef(E,t){return t._x=this._x*E,t._y=this._y*E,t._z=this._z*E,t._isDirty=!0,t}getNormalToRef(E){const t=this.length();let z=Math.acos(this._y/t);const A=Math.atan2(this._z,this._x);z>Math.PI/2?z-=Math.PI/2:z+=Math.PI/2;const X=t*Math.sin(z)*Math.cos(A),R=t*Math.cos(z),u=t*Math.sin(z)*Math.sin(A);return E.set(X,R,u),E}applyRotationQuaternionToRef(E,t){const z=this._x,A=this._y,X=this._z,R=E._x,u=E._y,p=E._z,C=E._w,Z=2*(u*X-p*A),H=2*(p*z-R*X),h=2*(R*A-u*z);return t._x=z+C*Z+u*h-p*H,t._y=A+C*H+p*Z-R*h,t._z=X+C*h+R*H-u*Z,t._isDirty=!0,t}applyRotationQuaternionInPlace(E){return this.applyRotationQuaternionToRef(E,this)}applyRotationQuaternion(E){return this.applyRotationQuaternionToRef(E,new c)}scaleAndAddToRef(E,t){return t._x+=this._x*E,t._y+=this._y*E,t._z+=this._z*E,t._isDirty=!0,t}projectOnPlane(E,t){return this.projectOnPlaneToRef(E,t,new c)}projectOnPlaneToRef(E,t,z){const A=E.normal,X=E.d,R=W.Lt[0];this.subtractToRef(t,R),R.normalize();const u=c.Dot(R,A);if(Math.abs(u)<1e-10)z.ap(1/0);else{const E=-(c.Dot(t,A)+X)/u,p=R.scaleInPlace(E);t.addToRef(p,z)}return z}equals(E){return E&&this._x===E._x&&this._y===E._y&&this._z===E._z}equalsWithEpsilon(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return E&&(0,C.WithinEpsilon)(this._x,E._x,t)&&(0,C.WithinEpsilon)(this._y,E._y,t)&&(0,C.WithinEpsilon)(this._z,E._z,t)}equalsToFloats(E,t,z){return this._x===E&&this._y===t&&this._z===z}multiplyInPlace(E){return this._x*=E._x,this._y*=E._y,this._z*=E._z,this._isDirty=!0,this}multiply(E){return this.multiplyByFloats(E._x,E._y,E._z)}multiplyToRef(E,t){return t._x=this._x*E._x,t._y=this._y*E._y,t._z=this._z*E._z,t._isDirty=!0,t}multiplyByFloats(E,t,z){return new c(this._x*E,this._y*t,this._z*z)}divide(E){return new c(this._x/E._x,this._y/E._y,this._z/E._z)}divideToRef(E,t){return t._x=this._x/E._x,t._y=this._y/E._y,t._z=this._z/E._z,t._isDirty=!0,t}divideInPlace(E){return this._x=this._x/E._x,this._y=this._y/E._y,this._z=this._z/E._z,this._isDirty=!0,this}minimizeInPlace(E){return this.minimizeInPlaceFromFloats(E._x,E._y,E._z)}maximizeInPlace(E){return this.maximizeInPlaceFromFloats(E._x,E._y,E._z)}minimizeInPlaceFromFloats(E,t,z){return E<this._x&&(this.x=E),t<this._y&&(this.y=t),z<this._z&&(this.z=z),this}maximizeInPlaceFromFloats(E,t,z){return E>this._x&&(this.x=E),t>this._y&&(this.y=t),z>this._z&&(this.z=z),this}isNonUniformWithinEpsilon(E){const t=Math.abs(this._x),z=Math.abs(this._y);if(!(0,C.WithinEpsilon)(t,z,E))return!0;const A=Math.abs(this._z);return!(0,C.WithinEpsilon)(t,A,E)||!(0,C.WithinEpsilon)(z,A,E)}get isNonUniform(){const E=Math.abs(this._x);if(E!==Math.abs(this._y))return!0;return E!==Math.abs(this._z)}floorToRef(E){return E._x=Math.floor(this._x),E._y=Math.floor(this._y),E._z=Math.floor(this._z),E._isDirty=!0,E}floor(){return new c(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(E){return E._x=this._x-Math.floor(this._x),E._y=this._y-Math.floor(this._y),E._z=this._z-Math.floor(this._z),E._isDirty=!0,E}fract(){return new c(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(E){if("xyz"===(E=E.toLowerCase()))return this;const t=W.Lt[0].R(this);return this.x=t[E[0]],this.y=t[E[1]],this.z=t[E[2]],this}rotateByQuaternionToRef(E,t){return E.toRotationMatrix(W.Matrix[0]),c.TransformCoordinatesToRef(this,W.Matrix[0],t),t}rotateByQuaternionAroundPointToRef(E,t,z){return this.subtractToRef(t,W.Lt[0]),W.Lt[0].rotateByQuaternionToRef(E,W.Lt[0]),t.addToRef(W.Lt[0],z),z}cross(E){return c.CrossToRef(this,E,new c)}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){return this.normalizeToRef(new c)}normalizeToRef(E){const t=this.length();return 0===t||1===t?(E._x=this._x,E._y=this._y,E._z=this._z,E._isDirty=!0,E):this.scaleToRef(1/t,E)}clone(){return new c(this._x,this._y,this._z)}R(E){return this.Op(E._x,E._y,E._z)}Op(E,t,z){return this._x=E,this._y=t,this._z=z,this._isDirty=!0,this}set(E,t,z){return this.Op(E,t,z)}ap(E){return this._x=this._y=this._z=E,this._isDirty=!0,this}static GetClipFactor(E,t,z,A){const X=c.Dot(E,z);return(X-A)/(X-c.Dot(t,z))}static GetAngleBetweenVectors(E,t,z){const A=E.normalizeToRef(W.Lt[1]),X=t.normalizeToRef(W.Lt[2]);let R=c.Dot(A,X);R=(0,C.Clamp)(R,-1,1);const u=Math.acos(R),p=W.Lt[3];return c.CrossToRef(A,X,p),c.Dot(p,z)>0?isNaN(u)?0:u:isNaN(u)?-Math.PI:-Math.acos(R)}static GetAngleBetweenVectorsOnPlane(E,t,z){W.Lt[0].R(E);const A=W.Lt[0];W.Lt[1].R(t);const X=W.Lt[1];W.Lt[2].R(z);const R=W.Lt[2],u=W.Lt[3],p=W.Lt[4];A.normalize(),X.normalize(),R.normalize(),c.CrossToRef(R,A,u),c.CrossToRef(u,R,p);const Z=Math.atan2(c.Dot(X,u),c.Dot(X,p));return(0,C.NormalizeRadians)(Z)}static PitchYawRollToMoveBetweenPointsToRef(E,t,z){const A=I.Lt[0];return t.subtractToRef(E,A),z._y=Math.atan2(A.x,A.z)||0,z._x=Math.atan2(Math.sqrt(A.x**2+A.z**2),A.y)||0,z._z=0,z._isDirty=!0,z}static PitchYawRollToMoveBetweenPoints(E,t){const z=c.Zero();return c.PitchYawRollToMoveBetweenPointsToRef(E,t,z)}static SlerpToRef(E,t,z,X){z=(0,C.Clamp)(z,0,1);const R=W.Lt[0],u=W.Lt[1];R.R(E);const p=R.length();R.normalizeFromLength(p),u.R(t);const Z=u.length();u.normalizeFromLength(Z);const H=c.Dot(R,u);let h,d;if(H<1-A.c){const E=Math.acos(H),t=1/Math.sin(E);h=Math.sin((1-z)*E)*t,d=Math.sin(z*E)*t}else h=1-z,d=z;return R.scaleInPlace(h),u.scaleInPlace(d),X.R(R).addInPlace(u),X.scaleInPlace((0,C.Lerp)(p,Z,z)),X}static SmoothToRef(E,t,z,A,X){return c.SlerpToRef(E,t,0===A?1:z/A,X),X}static St(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new c(E[t],E[t+1],E[t+2])}static FromFloatArray(E,t){return c.St(E,t)}static FromArrayToRef(E,t,z){return z._x=E[t],z._y=E[t+1],z._z=E[t+2],z._isDirty=!0,z}static FromFloatArrayToRef(E,t,z){return c.FromArrayToRef(E,t,z)}static FromFloatsToRef(E,t,z,A){return A.Op(E,t,z),A}static Zero(){return new c(0,0,0)}static One(){return new c(1,1,1)}static Up(){return new c(0,1,0)}static get UpReadOnly(){return c._UpReadOnly}static get DownReadOnly(){return c._DownReadOnly}static get RightReadOnly(){return c._RightReadOnly}static get LeftReadOnly(){return c._LeftReadOnly}static get LeftHandedForwardReadOnly(){return c._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return c._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return c._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return c._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return c._ZeroReadOnly}static get OneReadOnly(){return c._OneReadOnly}static Down(){return new c(0,-1,0)}static Forward(){return new c(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new c(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new c(1,0,0)}static Left(){return new c(-1,0,0)}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new c((0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Op((0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t))}static TransformCoordinates(E,t){const z=c.Zero();return c.TransformCoordinatesToRef(E,t,z),z}static TransformCoordinatesToRef(E,t,z){return c.TransformCoordinatesFromFloatsToRef(E._x,E._y,E._z,t,z),z}static TransformCoordinatesFromFloatsToRef(E,t,z,A,X){const R=A.m,u=E*R[0]+t*R[4]+z*R[8]+R[12],p=E*R[1]+t*R[5]+z*R[9]+R[13],C=E*R[2]+t*R[6]+z*R[10]+R[14],Z=1/(E*R[3]+t*R[7]+z*R[11]+R[15]);return X._x=u*Z,X._y=p*Z,X._z=C*Z,X._isDirty=!0,X}static TransformNormal(E,t){const z=c.Zero();return c.TransformNormalToRef(E,t,z),z}static TransformNormalToRef(E,t,z){return this.TransformNormalFromFloatsToRef(E._x,E._y,E._z,t,z),z}static TransformNormalFromFloatsToRef(E,t,z,A,X){const R=A.m;return X._x=E*R[0]+t*R[4]+z*R[8],X._y=E*R[1]+t*R[5]+z*R[9],X._z=E*R[2]+t*R[6]+z*R[10],X._isDirty=!0,X}static CatmullRom(E,t,z,A,X){const R=X*X,u=X*R,p=.5*(2*t._x+(-E._x+z._x)*X+(2*E._x-5*t._x+4*z._x-A._x)*R+(-E._x+3*t._x-3*z._x+A._x)*u),C=.5*(2*t._y+(-E._y+z._y)*X+(2*E._y-5*t._y+4*z._y-A._y)*R+(-E._y+3*t._y-3*z._y+A._y)*u),Z=.5*(2*t._z+(-E._z+z._z)*X+(2*E._z-5*t._z+4*z._z-A._z)*R+(-E._z+3*t._z-3*z._z+A._z)*u);return new c(p,C,Z)}static Clamp(E,t,z){const A=new c;return c.ClampToRef(E,t,z,A),A}static ClampToRef(E,t,z,A){let X=E._x;X=X>z._x?z._x:X,X=X<t._x?t._x:X;let R=E._y;R=R>z._y?z._y:R,R=R<t._y?t._y:R;let u=E._z;return u=u>z._z?z._z:u,u=u<t._z?t._z:u,A.Op(X,R,u),A}static CheckExtends(E,t,z){t.minimizeInPlace(E),z.maximizeInPlace(E)}static Hermite(E,t,z,A,X){const R=X*X,u=X*R,p=2*u-3*R+1,C=-2*u+3*R,Z=u-2*R+X,H=u-R,h=E._x*p+z._x*C+t._x*Z+A._x*H,d=E._y*p+z._y*C+t._y*Z+A._y*H,y=E._z*p+z._z*C+t._z*Z+A._z*H;return new c(h,d,y)}static Hermite1stDerivative(E,t,z,A,X){const R=new c;return this.Hermite1stDerivativeToRef(E,t,z,A,X,R),R}static Hermite1stDerivativeToRef(E,t,z,A,X,R){const u=X*X;return R._x=6*(u-X)*E._x+(3*u-4*X+1)*t._x+6*(-u+X)*z._x+(3*u-2*X)*A._x,R._y=6*(u-X)*E._y+(3*u-4*X+1)*t._y+6*(-u+X)*z._y+(3*u-2*X)*A._y,R._z=6*(u-X)*E._z+(3*u-4*X+1)*t._z+6*(-u+X)*z._z+(3*u-2*X)*A._z,R._isDirty=!0,R}static Lerp(E,t,z){const A=new c(0,0,0);return c.LerpToRef(E,t,z,A),A}static LerpToRef(E,t,z,A){return A._x=E._x+(t._x-E._x)*z,A._y=E._y+(t._y-E._y)*z,A._z=E._z+(t._z-E._z)*z,A._isDirty=!0,A}static Dot(E,t){return E._x*t._x+E._y*t._y+E._z*t._z}dot(E){return this._x*E._x+this._y*E._y+this._z*E._z}static Cross(E,t){const z=new c;return c.CrossToRef(E,t,z),z}static CrossToRef(E,t,z){const A=E._y*t._z-E._z*t._y,X=E._z*t._x-E._x*t._z,R=E._x*t._y-E._y*t._x;return z.Op(A,X,R),z}static Normalize(E){const t=c.Zero();return c.NormalizeToRef(E,t),t}static NormalizeToRef(E,t){return E.normalizeToRef(t),t}static Project(E,t,z,A){const X=new c;return c.ProjectToRef(E,t,z,A,X),X}static ProjectToRef(E,t,z,A,X){var R;const u=A.width,C=A.height,Z=A.x,H=A.y,h=W.Matrix[1],d=null===(R=p.d.LastCreatedEngine)||void 0===R?void 0:R.isNDCHalfZRange,y=d?1:.5,O=d?0:.5;mE.FromValuesToRef(u/2,0,0,0,0,-C/2,0,0,0,0,y,0,Z+u/2,C/2+H,O,1,h);const a=W.Matrix[0];return t.multiplyToRef(z,a),a.multiplyToRef(h,a),c.TransformCoordinatesToRef(E,a,X),X}static Reflect(E,t){return this.ReflectToRef(E,t,new c)}static ReflectToRef(E,t,z){const A=I.Lt[0];return A.R(t).scaleInPlace(2*c.Dot(E,t)),z.R(E).kH(A)}static _UnprojectFromInvertedMatrixToRef(E,t,z){c.TransformCoordinatesToRef(E,t,z);const A=t.m,X=E._x*A[3]+E._y*A[7]+E._z*A[11]+A[15];return(0,C.WithinEpsilon)(X,1)&&z.scaleInPlace(1/X),z}static UnprojectFromTransform(E,t,z,A,X){return this.Unproject(E,t,z,A,X,mE.IdentityReadOnly)}static Unproject(E,t,z,A,X,R){const u=new c;return c.UnprojectToRef(E,t,z,A,X,R,u),u}static UnprojectToRef(E,t,z,A,X,R,u){return c.UnprojectFloatsToRef(E._x,E._y,E._z,t,z,A,X,R,u),u}static UnprojectFloatsToRef(E,t,z,A,X,R,u,C,Z){var H;const h=W.Matrix[0];R.multiplyToRef(u,h),h.multiplyToRef(C,h),h.invert();const d=W.Lt[0];return d.x=E/A*2-1,d.y=-(t/X*2-1),null!==(H=p.d.LastCreatedEngine)&&void 0!==H&&H.isNDCHalfZRange?d.z=z:d.z=2*z-1,c._UnprojectFromInvertedMatrixToRef(d,h,Z),Z}static Minimize(E,t){const z=new c;return z.R(E),z.minimizeInPlace(t),z}static Maximize(E,t){const z=new c;return z.R(E),z.maximizeInPlace(t),z}static Distance(E,t){return Math.sqrt(c.DistanceSquared(E,t))}static DistanceSquared(E,t){const z=E._x-t._x,A=E._y-t._y,X=E._z-t._z;return z*z+A*A+X*X}static ProjectOnTriangleToRef(E,t,z,X,R){const u=W.Lt[0],p=W.Lt[1],Z=W.Lt[2],H=W.Lt[3],h=W.Lt[4];z.subtractToRef(t,u),X.subtractToRef(t,p),X.subtractToRef(z,Z);const d=u.length(),y=p.length(),O=Z.length();if(d<A.c||y<A.c||O<A.c)return R.R(t),c.Distance(E,t);E.subtractToRef(t,h),c.CrossToRef(u,p,H);const a=H.length();if(a<A.c)return R.R(t),c.Distance(E,t);H.normalizeFromLength(a);let L=h.length();if(L<A.c)return R.R(t),0;h.normalizeFromLength(L);const mE=c.Dot(H,h),I=W.Lt[5],e=W.Lt[6];I.R(H).scaleInPlace(-L*mE),e.R(E).addInPlace(I);const D=W.Lt[4],S=W.Lt[5],l=W.Lt[7],f=W.Lt[8];D.R(u).scaleInPlace(1/d),f.R(p).scaleInPlace(1/y),D.addInPlace(f).scaleInPlace(-1),S.R(u).scaleInPlace(-1/d),f.R(Z).scaleInPlace(1/O),S.addInPlace(f).scaleInPlace(-1),l.R(Z).scaleInPlace(-1/O),f.R(p).scaleInPlace(-1/y),l.addInPlace(f).scaleInPlace(-1);const K=W.Lt[9];let F;K.R(e).kH(t),c.CrossToRef(D,K,f),F=c.Dot(f,H);const B=F;K.R(e).kH(z),c.CrossToRef(S,K,f),F=c.Dot(f,H);const b=F;K.R(e).kH(X),c.CrossToRef(l,K,f),F=c.Dot(f,H);const x=F,J=W.Lt[10];let V,r;B>0&&b<0?(J.R(u),V=t,r=z):b>0&&x<0?(J.R(Z),V=z,r=X):(J.R(p).scaleInPlace(-1),V=X,r=t);const i=W.Lt[9],g=W.Lt[4];V.subtractToRef(e,f),r.subtractToRef(e,i),c.CrossToRef(f,i,g);if(!(c.Dot(g,H)<0))return R.R(e),Math.abs(L*mE);const o=W.Lt[5];c.CrossToRef(J,g,o),o.normalize();const Q=W.Lt[9];Q.R(V).kH(e);const T=Q.length();if(T<A.c)return R.R(V),c.Distance(E,V);Q.normalizeFromLength(T);const q=c.Dot(o,Q),M=W.Lt[7];M.R(e).addInPlace(o.scaleInPlace(T*q)),f.R(M).kH(V),L=J.length(),J.normalizeFromLength(L);let w=c.Dot(f,J)/Math.max(L,A.c);return w=(0,C.Clamp)(w,0,1),M.R(V).addInPlace(J.scaleInPlace(w*L)),R.R(M),c.Distance(E,M)}static Center(E,t){return c.CenterToRef(E,t,c.Zero())}static CenterToRef(E,t,z){return z.Op((E._x+t._x)/2,(E._y+t._y)/2,(E._z+t._z)/2)}static RotationFromAxis(E,t,z){const A=new c;return c.RotationFromAxisToRef(E,t,z,A),A}static RotationFromAxisToRef(E,t,z,A){const X=W.Quaternion[0];return L.RotationQuaternionFromAxisToRef(E,t,z,X),X.toEulerAnglesToRef(A),A}}c._V8PerformanceHack=new c(.5,.5,.5),c._UpReadOnly=c.Up(),c._DownReadOnly=c.Down(),c._LeftHandedForwardReadOnly=c.Forward(!1),c._RightHandedForwardReadOnly=c.Forward(!0),c._LeftHandedBackwardReadOnly=c.Backward(!1),c._RightHandedBackwardReadOnly=c.Backward(!0),c._RightReadOnly=c.Right(),c._LeftReadOnly=c.Left(),c._ZeroReadOnly=c.Zero(),c._OneReadOnly=c.One(),Object.defineProperties(c.prototype,{dimension:{value:[3]},rank:{value:1}});class a{get x(){return this._x}set x(E){this._x=E,this._isDirty=!0}get y(){return this._y}set y(E){this._y=E,this._isDirty=!0}get z(){return this._z}set z(E){this._z=E,this._isDirty=!0}get w(){return this._w}set w(E){this._w=E,this._isDirty=!0}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=E,this._y=t,this._z=z,this._w=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let E=y(this._x);return E=397*E^y(this._y),E=397*E^y(this._z),E=397*E^y(this._w),E}upE(){return[this._x,this._y,this._z,this._w]}toArray(E,t){return void 0===t&&(t=0),E[t]=this._x,E[t+1]=this._y,E[t+2]=this._z,E[t+3]=this._w,this}Dz(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return a.FromArrayToRef(E,t,this),this}addInPlace(E){return this.x+=E._x,this.y+=E._y,this.z+=E._z,this.w+=E._w,this}addInPlaceFromFloats(E,t,z,A){return this.x+=E,this.y+=t,this.z+=z,this.w+=A,this}add(E){return new a(this._x+E.x,this._y+E.y,this._z+E.z,this._w+E.w)}addToRef(E,t){return t.x=this._x+E.x,t.y=this._y+E.y,t.z=this._z+E.z,t.w=this._w+E.w,t}kH(E){return this.x-=E.x,this.y-=E.y,this.z-=E.z,this.w-=E.w,this}Wt(E){return new a(this._x-E.x,this._y-E.y,this._z-E.z,this._w-E.w)}subtractToRef(E,t){return t.x=this._x-E.x,t.y=this._y-E.y,t.z=this._z-E.z,t.w=this._w-E.w,t}subtractFromFloats(E,t,z,A){return new a(this._x-E,this._y-t,this._z-z,this._w-A)}subtractFromFloatsToRef(E,t,z,A,X){return X.x=this._x-E,X.y=this._y-t,X.z=this._z-z,X.w=this._w-A,X}negate(){return new a(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(E){return E.x=-this._x,E.y=-this._y,E.z=-this._z,E.w=-this._w,E}scaleInPlace(E){return this.x*=E,this.y*=E,this.z*=E,this.w*=E,this}scale(E){return new a(this._x*E,this._y*E,this._z*E,this._w*E)}scaleToRef(E,t){return t.x=this._x*E,t.y=this._y*E,t.z=this._z*E,t.w=this._w*E,t}scaleAndAddToRef(E,t){return t.x+=this._x*E,t.y+=this._y*E,t.z+=this._z*E,t.w+=this._w*E,t}equals(E){return E&&this._x===E.x&&this._y===E.y&&this._z===E.z&&this._w===E.w}equalsWithEpsilon(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return E&&(0,C.WithinEpsilon)(this._x,E.x,t)&&(0,C.WithinEpsilon)(this._y,E.y,t)&&(0,C.WithinEpsilon)(this._z,E.z,t)&&(0,C.WithinEpsilon)(this._w,E.w,t)}equalsToFloats(E,t,z,A){return this._x===E&&this._y===t&&this._z===z&&this._w===A}multiplyInPlace(E){return this.x*=E.x,this.y*=E.y,this.z*=E.z,this.w*=E.w,this}multiply(E){return new a(this._x*E.x,this._y*E.y,this._z*E.z,this._w*E.w)}multiplyToRef(E,t){return t.x=this._x*E.x,t.y=this._y*E.y,t.z=this._z*E.z,t.w=this._w*E.w,t}multiplyByFloats(E,t,z,A){return new a(this._x*E,this._y*t,this._z*z,this._w*A)}divide(E){return new a(this._x/E.x,this._y/E.y,this._z/E.z,this._w/E.w)}divideToRef(E,t){return t.x=this._x/E.x,t.y=this._y/E.y,t.z=this._z/E.z,t.w=this._w/E.w,t}divideInPlace(E){return this.divideToRef(E,this)}minimizeInPlace(E){return E.x<this._x&&(this.x=E.x),E.y<this._y&&(this.y=E.y),E.z<this._z&&(this.z=E.z),E.w<this._w&&(this.w=E.w),this}maximizeInPlace(E){return E.x>this._x&&(this.x=E.x),E.y>this._y&&(this.y=E.y),E.z>this._z&&(this.z=E.z),E.w>this._w&&(this.w=E.w),this}minimizeInPlaceFromFloats(E,t,z,A){return this.x=Math.min(E,this._x),this.y=Math.min(t,this._y),this.z=Math.min(z,this._z),this.w=Math.min(A,this._w),this}maximizeInPlaceFromFloats(E,t,z,A){return this.x=Math.max(E,this._x),this.y=Math.max(t,this._y),this.z=Math.max(z,this._z),this.w=Math.max(A,this._w),this}floorToRef(E){return E.x=Math.floor(this._x),E.y=Math.floor(this._y),E.z=Math.floor(this._z),E.w=Math.floor(this._w),E}floor(){return new a(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(E){return E.x=this._x-Math.floor(this._x),E.y=this._y-Math.floor(this._y),E.z=this._z-Math.floor(this._z),E.w=this._w-Math.floor(this._w),E}fract(){return new a(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){return this.normalizeToRef(new a)}normalizeToRef(E){const t=this.length();return 0===t||1===t?(E.x=this._x,E.y=this._y,E.z=this._z,E.w=this._w,E):this.scaleToRef(1/t,E)}toVector3(){return new c(this._x,this._y,this._z)}clone(){return new a(this._x,this._y,this._z,this._w)}R(E){return this.x=E.x,this.y=E.y,this.z=E.z,this.w=E.w,this}Op(E,t,z,A){return this.x=E,this.y=t,this.z=z,this.w=A,this}set(E,t,z,A){return this.Op(E,t,z,A)}ap(E){return this.x=this.y=this.z=this.w=E,this}dot(E){return this._x*E.x+this._y*E.y+this._z*E.z+this._w*E.w}static St(E,t){return t||(t=0),new a(E[t],E[t+1],E[t+2],E[t+3])}static FromArrayToRef(E,t,z){return z.x=E[t],z.y=E[t+1],z.z=E[t+2],z.w=E[t+3],z}static FromFloatArrayToRef(E,t,z){return a.FromArrayToRef(E,t,z),z}static FromFloatsToRef(E,t,z,A,X){return X.x=E,X.y=t,X.z=z,X.w=A,X}static Zero(){return new a(0,0,0,0)}static One(){return new a(1,1,1,1)}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new a((0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,z=arguments.length>2?arguments[2]:void 0;return z.x=(0,C.RandomRange)(E,t),z.y=(0,C.RandomRange)(E,t),z.z=(0,C.RandomRange)(E,t),z.w=(0,C.RandomRange)(E,t),z}static Clamp(E,t,z){return a.ClampToRef(E,t,z,new a)}static ClampToRef(E,t,z,A){return A.x=(0,C.Clamp)(E.x,t.x,z.x),A.y=(0,C.Clamp)(E.y,t.y,z.y),A.z=(0,C.Clamp)(E.z,t.z,z.z),A.w=(0,C.Clamp)(E.w,t.w,z.w),A}static CheckExtends(E,t,z){t.minimizeInPlace(E),z.maximizeInPlace(E)}static get ZeroReadOnly(){return a._ZeroReadOnly}static Normalize(E){return a.NormalizeToRef(E,new a)}static NormalizeToRef(E,t){return E.normalizeToRef(t),t}static Minimize(E,t){const z=new a;return z.R(E),z.minimizeInPlace(t),z}static Maximize(E,t){const z=new a;return z.R(E),z.maximizeInPlace(t),z}static Distance(E,t){return Math.sqrt(a.DistanceSquared(E,t))}static DistanceSquared(E,t){const z=E.x-t.x,A=E.y-t.y,X=E.z-t.z,R=E.w-t.w;return z*z+A*A+X*X+R*R}static Center(E,t){return a.CenterToRef(E,t,new a)}static CenterToRef(E,t,z){return z.x=(E.x+t.x)/2,z.y=(E.y+t.y)/2,z.z=(E.z+t.z)/2,z.w=(E.w+t.w)/2,z}static TransformCoordinates(E,t){return a.TransformCoordinatesToRef(E,t,new a)}static TransformCoordinatesToRef(E,t,z){return a.TransformCoordinatesFromFloatsToRef(E._x,E._y,E._z,t,z),z}static TransformCoordinatesFromFloatsToRef(E,t,z,A,X){const R=A.m,u=E*R[0]+t*R[4]+z*R[8]+R[12],p=E*R[1]+t*R[5]+z*R[9]+R[13],C=E*R[2]+t*R[6]+z*R[10]+R[14],Z=E*R[3]+t*R[7]+z*R[11]+R[15];return X.x=u,X.y=p,X.z=C,X.w=Z,X}static TransformNormal(E,t){return a.TransformNormalToRef(E,t,new a)}static TransformNormalToRef(E,t,z){const A=t.m,X=E.x*A[0]+E.y*A[4]+E.z*A[8],R=E.x*A[1]+E.y*A[5]+E.z*A[9],u=E.x*A[2]+E.y*A[6]+E.z*A[10];return z.x=X,z.y=R,z.z=u,z.w=E.w,z}static TransformNormalFromFloatsToRef(E,t,z,A,X,R){const u=X.m;return R.x=E*u[0]+t*u[4]+z*u[8],R.y=E*u[1]+t*u[5]+z*u[9],R.z=E*u[2]+t*u[6]+z*u[10],R.w=A,R}static FromVector3(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new a(E._x,E._y,E._z,t)}static Dot(E,t){return E.x*t.x+E.y*t.y+E.z*t.z+E.w*t.w}}a._V8PerformanceHack=new a(.5,.5,.5,.5),a._ZeroReadOnly=a.Zero(),Object.defineProperties(a.prototype,{dimension:{value:[4]},rank:{value:1}});class L{get x(){return this._x}set x(E){this._x=E,this._isDirty=!0}get y(){return this._y}set y(E){this._y=E,this._isDirty=!0}get z(){return this._z}set z(E){this._z=E,this._isDirty=!0}get w(){return this._w}set w(E){this._w=E,this._isDirty=!0}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=E,this._y=t,this._z=z,this._w=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let E=y(this._x);return E=397*E^y(this._y),E=397*E^y(this._z),E=397*E^y(this._w),E}upE(){return[this._x,this._y,this._z,this._w]}toArray(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[t]=this._x,E[t+1]=this._y,E[t+2]=this._z,E[t+3]=this._w,this}Dz(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(E,t,this)}equals(E){return E&&this._x===E._x&&this._y===E._y&&this._z===E._z&&this._w===E._w}equalsWithEpsilon(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return E&&(0,C.WithinEpsilon)(this._x,E._x,t)&&(0,C.WithinEpsilon)(this._y,E._y,t)&&(0,C.WithinEpsilon)(this._z,E._z,t)&&(0,C.WithinEpsilon)(this._w,E._w,t)}isApprox(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return E&&((0,C.WithinEpsilon)(this._x,E._x,t)&&(0,C.WithinEpsilon)(this._y,E._y,t)&&(0,C.WithinEpsilon)(this._z,E._z,t)&&(0,C.WithinEpsilon)(this._w,E._w,t)||(0,C.WithinEpsilon)(this._x,-E._x,t)&&(0,C.WithinEpsilon)(this._y,-E._y,t)&&(0,C.WithinEpsilon)(this._z,-E._z,t)&&(0,C.WithinEpsilon)(this._w,-E._w,t))}clone(){return new L(this._x,this._y,this._z,this._w)}R(E){return this._x=E._x,this._y=E._y,this._z=E._z,this._w=E._w,this._isDirty=!0,this}Op(E,t,z,A){return this._x=E,this._y=t,this._z=z,this._w=A,this._isDirty=!0,this}set(E,t,z,A){return this.Op(E,t,z,A)}ap(E){return this.Op(E,E,E,E)}add(E){return new L(this._x+E._x,this._y+E._y,this._z+E._z,this._w+E._w)}addInPlace(E){return this._x+=E._x,this._y+=E._y,this._z+=E._z,this._w+=E._w,this._isDirty=!0,this}addToRef(E,t){return t._x=this._x+E._x,t._y=this._y+E._y,t._z=this._z+E._z,t._w=this._w+E._w,t._isDirty=!0,t}addInPlaceFromFloats(E,t,z,A){return this._x+=E,this._y+=t,this._z+=z,this._w+=A,this._isDirty=!0,this}subtractToRef(E,t){return t._x=this._x-E._x,t._y=this._y-E._y,t._z=this._z-E._z,t._w=this._w-E._w,t._isDirty=!0,t}subtractFromFloats(E,t,z,A){return this.subtractFromFloatsToRef(E,t,z,A,new L)}subtractFromFloatsToRef(E,t,z,A,X){return X._x=this._x-E,X._y=this._y-t,X._z=this._z-z,X._w=this._w-A,X._isDirty=!0,X}Wt(E){return new L(this._x-E._x,this._y-E._y,this._z-E._z,this._w-E._w)}kH(E){return this._x-=E._x,this._y-=E._y,this._z-=E._z,this._w-=E._w,this._isDirty=!0,this}scale(E){return new L(this._x*E,this._y*E,this._z*E,this._w*E)}scaleToRef(E,t){return t._x=this._x*E,t._y=this._y*E,t._z=this._z*E,t._w=this._w*E,t._isDirty=!0,t}scaleInPlace(E){return this._x*=E,this._y*=E,this._z*=E,this._w*=E,this._isDirty=!0,this}scaleAndAddToRef(E,t){return t._x+=this._x*E,t._y+=this._y*E,t._z+=this._z*E,t._w+=this._w*E,t._isDirty=!0,t}multiply(E){const t=new L(0,0,0,1);return this.multiplyToRef(E,t),t}multiplyToRef(E,t){const z=this._x*E._w+this._y*E._z-this._z*E._y+this._w*E._x,A=-this._x*E._z+this._y*E._w+this._z*E._x+this._w*E._y,X=this._x*E._y-this._y*E._x+this._z*E._w+this._w*E._z,R=-this._x*E._x-this._y*E._y-this._z*E._z+this._w*E._w;return t.Op(z,A,X,R),t}multiplyInPlace(E){return this.multiplyToRef(E,this)}multiplyByFloats(E,t,z,A){return this._x*=E,this._y*=t,this._z*=z,this._w*=A,this._isDirty=!0,this}divide(E){throw new ReferenceError("Can not divide a quaternion")}divideToRef(E,t){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(E){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new L)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(E){return E._x=-this._x,E._y=-this._y,E._z=-this._z,E._w=-this._w,E._isDirty=!0,E}equalsToFloats(E,t,z,A){return this._x===E&&this._y===t&&this._z===z&&this._w===A}floorToRef(E){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(E){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(E){return E.Op(-this._x,-this._y,-this._z,this._w),E}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new L(-this._x,-this._y,-this._z,this._w)}invert(){const E=this.conjugate(),t=this.lengthSquared();return 0==t||1==t||E.scaleInPlace(1/t),E}invertInPlace(){this.conjugateInPlace();const E=this.lengthSquared();return 0==E||1==E||this.scaleInPlace(1/E),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){const E=new L(0,0,0,1);return this.normalizeToRef(E),E}normalizeToRef(E){const t=this.length();return 0===t||1===t?E.Op(this._x,this._y,this._z,this._w):this.scaleToRef(1/t,E)}toEulerAngles(){const E=c.Zero();return this.toEulerAnglesToRef(E),E}toEulerAnglesToRef(E){const t=this._z,z=this._x,A=this._y,X=this._w,R=A*t-z*X,u=.4999999;if(R<-u)E._y=2*Math.atan2(A,X),E._x=Math.PI/2,E._z=0,E._isDirty=!0;else if(R>u)E._y=2*Math.atan2(A,X),E._x=-Math.PI/2,E._z=0,E._isDirty=!0;else{const u=X*X,p=t*t,C=z*z,Z=A*A;E._z=Math.atan2(2*(z*A+t*X),-p-C+Z+u),E._x=Math.asin(-2*R),E._y=Math.atan2(2*(t*z+A*X),p-C-Z+u),E._isDirty=!0}return E}toAlphaBetaGammaToRef(E){const t=this._z,z=this._x,A=this._y,X=this._w,R=Math.sqrt(z*z+A*A),u=Math.sqrt(t*t+X*X),p=2*Math.atan2(R,u),C=2*Math.atan2(t,X),Z=2*Math.atan2(A,z),H=(C+Z)/2,h=(C-Z)/2;return E.set(h,p,H),E}toRotationMatrix(E){return mE.FromQuaternionToRef(this,E),E}fromRotationMatrix(E){return L.FromRotationMatrixToRef(E,this),this}dot(E){return this._x*E._x+this._y*E._y+this._z*E._z+this._w*E._w}toAxisAngle(){const E=c.Zero();return{axis:E,angle:this.toAxisAngleToRef(E)}}toAxisAngleToRef(E){let t=0;const z=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),A=this._w;return z>0?(t=2*Math.atan2(z,A),E.set(this._x/z,this._y/z,this._z/z)):(t=0,E.set(1,0,0)),t}static FromRotationMatrix(E){const t=new L;return L.FromRotationMatrixToRef(E,t),t}static FromRotationMatrixToRef(E,t){const z=E.m,A=z[0],X=z[4],R=z[8],u=z[1],p=z[5],C=z[9],Z=z[2],H=z[6],h=z[10],d=A+p+h;let y;return d>0?(y=.5/Math.sqrt(d+1),t._w=.25/y,t._x=(H-C)*y,t._y=(R-Z)*y,t._z=(u-X)*y,t._isDirty=!0):A>p&&A>h?(y=2*Math.sqrt(1+A-p-h),t._w=(H-C)/y,t._x=.25*y,t._y=(X+u)/y,t._z=(R+Z)/y,t._isDirty=!0):p>h?(y=2*Math.sqrt(1+p-A-h),t._w=(R-Z)/y,t._x=(X+u)/y,t._y=.25*y,t._z=(C+H)/y,t._isDirty=!0):(y=2*Math.sqrt(1+h-A-p),t._w=(u-X)/y,t._x=(R+Z)/y,t._y=(C+H)/y,t._z=.25*y,t._isDirty=!0),t}static Dot(E,t){return E._x*t._x+E._y*t._y+E._z*t._z+E._w*t._w}static AreClose(E,t){let z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const A=L.Dot(E,t);return 1-A*A<=z}static SmoothToRef(E,t,z,A,X){let R=0===A?1:z/A;return R=(0,C.Clamp)(R,0,1),L.SlerpToRef(E,t,R,X),X}static Zero(){return new L(0,0,0,0)}static Inverse(E){return new L(-E._x,-E._y,-E._z,E._w)}static InverseToRef(E,t){return t.set(-E._x,-E._y,-E._z,E._w),t}static Identity(){return new L(0,0,0,1)}static IsIdentity(E){return E&&0===E._x&&0===E._y&&0===E._z&&1===E._w}static RotationAxis(E,t){return L.RotationAxisToRef(E,t,new L)}static RotationAxisToRef(E,t,z){z._w=Math.cos(t/2);const A=Math.sin(t/2)/E.length();return z._x=E._x*A,z._y=E._y*A,z._z=E._z*A,z._isDirty=!0,z}static St(E,t){return t||(t=0),new L(E[t],E[t+1],E[t+2],E[t+3])}static FromArrayToRef(E,t,z){return z._x=E[t],z._y=E[t+1],z._z=E[t+2],z._w=E[t+3],z._isDirty=!0,z}static FromFloatsToRef(E,t,z,A,X){return X.Op(E,t,z,A),X}static FromEulerAngles(E,t,z){const A=new L;return L.RotationYawPitchRollToRef(t,E,z,A),A}static FromEulerAnglesToRef(E,t,z,A){return L.RotationYawPitchRollToRef(t,E,z,A),A}static FromEulerVector(E){const t=new L;return L.RotationYawPitchRollToRef(E._y,E._x,E._z,t),t}static FromEulerVectorToRef(E,t){return L.RotationYawPitchRollToRef(E._y,E._x,E._z,t),t}static FromUnitVectorsToRef(E,t,z){let X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:A.c;const R=c.Dot(E,t)+1;return R<X?Math.abs(E.x)>Math.abs(E.z)?z.set(-E.y,E.x,0,0):z.set(0,-E.z,E.y,0):(c.CrossToRef(E,t,I.Lt[0]),z.set(I.Lt[0].x,I.Lt[0].y,I.Lt[0].z,R)),z.normalize()}static RotationYawPitchRoll(E,t,z){const A=new L;return L.RotationYawPitchRollToRef(E,t,z,A),A}static RotationYawPitchRollToRef(E,t,z,A){const X=.5*z,R=.5*t,u=.5*E,p=Math.sin(X),C=Math.cos(X),Z=Math.sin(R),H=Math.cos(R),h=Math.sin(u),d=Math.cos(u);return A._x=d*Z*C+h*H*p,A._y=h*H*C-d*Z*p,A._z=d*H*p-h*Z*C,A._w=d*H*C+h*Z*p,A._isDirty=!0,A}static RotationAlphaBetaGamma(E,t,z){const A=new L;return L.RotationAlphaBetaGammaToRef(E,t,z,A),A}static RotationAlphaBetaGammaToRef(E,t,z,A){const X=.5*(z+E),R=.5*(z-E),u=.5*t;return A._x=Math.cos(R)*Math.sin(u),A._y=Math.sin(R)*Math.sin(u),A._z=Math.sin(X)*Math.cos(u),A._w=Math.cos(X)*Math.cos(u),A._isDirty=!0,A}static RotationQuaternionFromAxis(E,t,z){const A=new L(0,0,0,0);return L.RotationQuaternionFromAxisToRef(E,t,z,A),A}static RotationQuaternionFromAxisToRef(E,t,z,A){const X=W.Matrix[0];return E=E.normalizeToRef(W.Lt[0]),t=t.normalizeToRef(W.Lt[1]),z=z.normalizeToRef(W.Lt[2]),mE.FromXYZAxesToRef(E,t,z,X),L.FromRotationMatrixToRef(X,A),A}static FromLookDirectionLH(E,t){const z=new L;return L.FromLookDirectionLHToRef(E,t,z),z}static FromLookDirectionLHToRef(E,t,z){const A=W.Matrix[0];return mE.LookDirectionLHToRef(E,t,A),L.FromRotationMatrixToRef(A,z),z}static FromLookDirectionRH(E,t){const z=new L;return L.FromLookDirectionRHToRef(E,t,z),z}static FromLookDirectionRHToRef(E,t,z){const A=W.Matrix[0];return mE.LookDirectionRHToRef(E,t,A),L.FromRotationMatrixToRef(A,z)}static Slerp(E,t,z){const A=L.Identity();return L.SlerpToRef(E,t,z,A),A}static SlerpToRef(E,t,z,A){let X,R,u=E._x*t._x+E._y*t._y+E._z*t._z+E._w*t._w,p=!1;if(u<0&&(p=!0,u=-u),u>.999999)R=1-z,X=p?-z:z;else{const E=Math.acos(u),t=1/Math.sin(E);R=Math.sin((1-z)*E)*t,X=p?-Math.sin(z*E)*t:Math.sin(z*E)*t}return A._x=R*E._x+X*t._x,A._y=R*E._y+X*t._y,A._z=R*E._z+X*t._z,A._w=R*E._w+X*t._w,A._isDirty=!0,A}static Hermite(E,t,z,A,X){const R=X*X,u=X*R,p=2*u-3*R+1,C=-2*u+3*R,Z=u-2*R+X,H=u-R,h=E._x*p+z._x*C+t._x*Z+A._x*H,d=E._y*p+z._y*C+t._y*Z+A._y*H,y=E._z*p+z._z*C+t._z*Z+A._z*H,O=E._w*p+z._w*C+t._w*Z+A._w*H;return new L(h,d,y,O)}static Hermite1stDerivative(E,t,z,A,X){const R=new L;return this.Hermite1stDerivativeToRef(E,t,z,A,X,R),R}static Hermite1stDerivativeToRef(E,t,z,A,X,R){const u=X*X;return R._x=6*(u-X)*E._x+(3*u-4*X+1)*t._x+6*(-u+X)*z._x+(3*u-2*X)*A._x,R._y=6*(u-X)*E._y+(3*u-4*X+1)*t._y+6*(-u+X)*z._y+(3*u-2*X)*A._y,R._z=6*(u-X)*E._z+(3*u-4*X+1)*t._z+6*(-u+X)*z._z+(3*u-2*X)*A._z,R._w=6*(u-X)*E._w+(3*u-4*X+1)*t._w+6*(-u+X)*z._w+(3*u-2*X)*A._w,R._isDirty=!0,R}static Normalize(E){const t=L.Zero();return L.NormalizeToRef(E,t),t}static NormalizeToRef(E,t){return E.normalizeToRef(t),t}static Clamp(E,t,z){const A=new L;return L.ClampToRef(E,t,z,A),A}static ClampToRef(E,t,z,A){return A.Op((0,C.Clamp)(E.x,t.x,z.x),(0,C.Clamp)(E.y,t.y,z.y),(0,C.Clamp)(E.z,t.z,z.z),(0,C.Clamp)(E.w,t.w,z.w))}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new L((0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Op((0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t),(0,C.RandomRange)(E,t))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(E,t){return Math.sqrt(L.DistanceSquared(E,t))}static DistanceSquared(E,t){const z=E.x-t.x,A=E.y-t.y,X=E.z-t.z,R=E.w-t.w;return z*z+A*A+X*X+R*R}static Center(E,t){return L.CenterToRef(E,t,L.Zero())}static CenterToRef(E,t,z){return z.Op((E.x+t.x)/2,(E.y+t.y)/2,(E.z+t.z)/2,(E.w+t.w)/2)}}L._V8PerformanceHack=new L(.5,.5,.5,.5),Object.defineProperties(L.prototype,{dimension:{value:[4]},rank:{value:1}});class mE{static get Use64Bits(){return u.c.MatrixUse64Bits}get m(){return this.Ep}markAsUpdated(){this.updateFlag=Z._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(E){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2],A=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=E,this._isIdentity3x2=E||z,this._isIdentityDirty=!this._isIdentity&&t,this._isIdentity3x2Dirty=!this._isIdentity3x2&&A}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,u.c.MatrixTrackPrecisionChange&&u.c.MatrixTrackedMatrices.push(this),this.Ep=new u.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const E=this.Ep;this._isIdentity=1===E[0]&&0===E[1]&&0===E[2]&&0===E[3]&&0===E[4]&&1===E[5]&&0===E[6]&&0===E[7]&&0===E[8]&&0===E[9]&&1===E[10]&&0===E[11]&&0===E[12]&&0===E[13]&&0===E[14]&&1===E[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Ep[0]||1!==this.Ep[5]||1!==this.Ep[15]||0!==this.Ep[1]||0!==this.Ep[2]||0!==this.Ep[3]||0!==this.Ep[4]||0!==this.Ep[6]||0!==this.Ep[7]||0!==this.Ep[8]||0!==this.Ep[9]||0!==this.Ep[10]||0!==this.Ep[11]||0!==this.Ep[12]||0!==this.Ep[13]||0!==this.Ep[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const E=this.Ep,t=E[0],z=E[1],A=E[2],X=E[3],R=E[4],u=E[5],p=E[6],C=E[7],Z=E[8],H=E[9],h=E[10],d=E[11],y=E[12],O=E[13],c=E[14],a=E[15],L=h*a-c*d,mE=H*a-O*d,W=H*c-O*h,I=Z*a-y*d,e=Z*c-h*y,D=Z*O-y*H;return t*+(u*L-p*mE+C*W)+z*-(R*L-p*I+C*e)+A*+(R*mE-u*I+C*D)+X*-(R*W-u*e+p*D)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!E)return this.Ep;const z=this.Ep;for(let A=0;A<16;A++)E[t+A]=z[A];return this}upE(){return this.Ep}Dz(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return mE.FromArrayToRef(E,t,this)}Op(){for(var E=arguments.length,t=new Array(E),z=0;z<E;z++)t[z]=arguments[z];return mE.FromArrayToRef(t,0,this)}set(){const E=this.Ep;for(let t=0;t<16;t++)E[t]=t<0||arguments.length<=t?void 0:arguments[t];return this.markAsUpdated(),this}ap(E){const t=this.Ep;for(let z=0;z<16;z++)t[z]=E;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return mE.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(E){const t=new mE;return this.addToRef(E,t),t}addToRef(E,t){const z=this.Ep,A=t.Ep,X=E.m;for(let R=0;R<16;R++)A[R]=z[R]+X[R];return t.markAsUpdated(),t}addToSelf(E){const t=this.Ep,z=E.m;return t[0]+=z[0],t[1]+=z[1],t[2]+=z[2],t[3]+=z[3],t[4]+=z[4],t[5]+=z[5],t[6]+=z[6],t[7]+=z[7],t[8]+=z[8],t[9]+=z[9],t[10]+=z[10],t[11]+=z[11],t[12]+=z[12],t[13]+=z[13],t[14]+=z[14],t[15]+=z[15],this.markAsUpdated(),this}addInPlace(E){const t=this.Ep,z=E.m;for(let A=0;A<16;A++)t[A]+=z[A];return this.markAsUpdated(),this}addInPlaceFromFloats(){const E=this.Ep;for(let t=0;t<16;t++)E[t]+=t<0||arguments.length<=t?void 0:arguments[t];return this.markAsUpdated(),this}Wt(E){const t=this.Ep,z=E.m;for(let A=0;A<16;A++)t[A]-=z[A];return this.markAsUpdated(),this}subtractToRef(E,t){const z=this.Ep,A=E.m,X=t.Ep;for(let R=0;R<16;R++)X[R]=z[R]-A[R];return t.markAsUpdated(),t}kH(E){const t=this.Ep,z=E.m;for(let A=0;A<16;A++)t[A]-=z[A];return this.markAsUpdated(),this}subtractFromFloats(){for(var E=arguments.length,t=new Array(E),z=0;z<E;z++)t[z]=arguments[z];return this.subtractFromFloatsToRef(...t,new mE)}subtractFromFloatsToRef(){for(var E=arguments.length,t=new Array(E),z=0;z<E;z++)t[z]=arguments[z];const A=t.pop(),X=this.Ep,R=A.Ep,u=t;for(let p=0;p<16;p++)R[p]=X[p]-u[p];return A.markAsUpdated(),A}invertToRef(E){return!0===this._isIdentity?(mE.IdentityToRef(E),E):(d(this,E.upE())?E.markAsUpdated():E.R(this),E)}addAtIndex(E,t){return this.Ep[E]+=t,this.markAsUpdated(),this}multiplyAtIndex(E,t){return this.Ep[E]*=t,this.markAsUpdated(),this}setTranslationFromFloats(E,t,z){return this.Ep[12]=E,this.Ep[13]=t,this.Ep[14]=z,this.markAsUpdated(),this}addTranslationFromFloats(E,t,z){return this.Ep[12]+=E,this.Ep[13]+=t,this.Ep[14]+=z,this.markAsUpdated(),this}setTranslation(E){return this.setTranslationFromFloats(E._x,E._y,E._z)}getTranslation(){return new c(this.Ep[12],this.Ep[13],this.Ep[14])}getTranslationToRef(E){return E.x=this.Ep[12],E.y=this.Ep[13],E.z=this.Ep[14],E}removeRotationAndScaling(){const E=this.m;return mE.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,E[12],E[13],E[14],E[15],this),this._updateIdentityStatus(0===E[12]&&0===E[13]&&0===E[14]&&1===E[15]),this}R(E){E.copyToArray(this.Ep);const t=E;return this.updateFlag=t.updateFlag,this._updateIdentityStatus(t._isIdentity,t._isIdentityDirty,t._isIdentity3x2,t._isIdentity3x2Dirty),this}copyToArray(E){return h(this,E,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(E){const t=new mE;return this.multiplyToRef(E,t),t}multiplyInPlace(E){const t=this.Ep,z=E.m;for(let A=0;A<16;A++)t[A]*=z[A];return this.markAsUpdated(),this}multiplyByFloats(){const E=this.Ep;for(let t=0;t<16;t++)E[t]*=t<0||arguments.length<=t?void 0:arguments[t];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var E=arguments.length,t=new Array(E),z=0;z<E;z++)t[z]=arguments[z];const A=t.pop(),X=this.Ep,R=A.Ep,u=t;for(let p=0;p<16;p++)R[p]=X[p]*u[p];return A.markAsUpdated(),A}multiplyToRef(E,t){return this._isIdentity?(t.R(E),t):E._isIdentity?(t.R(this),t):(this.multiplyToArray(E,t.Ep,0),t.markAsUpdated(),t)}multiplyToArray(E,t,z){return H(this,E,t,z),this}divide(E){return this.divideToRef(E,new mE)}divideToRef(E,t){const z=this.Ep,A=E.m,X=t.Ep;for(let R=0;R<16;R++)X[R]=z[R]/A[R];return t.markAsUpdated(),t}divideInPlace(E){const t=this.Ep,z=E.m;for(let A=0;A<16;A++)t[A]/=z[A];return this.markAsUpdated(),this}minimizeInPlace(E){const t=this.Ep,z=E.m;for(let A=0;A<16;A++)t[A]=Math.min(t[A],z[A]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const E=this.Ep;for(let t=0;t<16;t++)E[t]=Math.min(E[t],t<0||arguments.length<=t?void 0:arguments[t]);return this.markAsUpdated(),this}maximizeInPlace(E){const t=this.Ep,z=E.m;for(let A=0;A<16;A++)t[A]=Math.min(t[A],z[A]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const E=this.Ep;for(let t=0;t<16;t++)E[t]=Math.min(E[t],t<0||arguments.length<=t?void 0:arguments[t]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new mE)}negateInPlace(){const E=this.Ep;for(let t=0;t<16;t++)E[t]=-E[t];return this.markAsUpdated(),this}negateToRef(E){const t=this.Ep,z=E.Ep;for(let A=0;A<16;A++)z[A]=-t[A];return E.markAsUpdated(),E}equals(E){const t=E;if(!t)return!1;if((this._isIdentity||t._isIdentity)&&!this._isIdentityDirty&&!t._isIdentityDirty)return this._isIdentity&&t._isIdentity;const z=this.m,A=t.m;return z[0]===A[0]&&z[1]===A[1]&&z[2]===A[2]&&z[3]===A[3]&&z[4]===A[4]&&z[5]===A[5]&&z[6]===A[6]&&z[7]===A[7]&&z[8]===A[8]&&z[9]===A[9]&&z[10]===A[10]&&z[11]===A[11]&&z[12]===A[12]&&z[13]===A[13]&&z[14]===A[14]&&z[15]===A[15]}equalsWithEpsilon(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const z=this.Ep,A=E.m;for(let X=0;X<16;X++)if(!(0,C.WithinEpsilon)(z[X],A[X],t))return!1;return!0}equalsToFloats(){const E=this.Ep;for(let t=0;t<16;t++)if(E[t]!=(t<0||arguments.length<=t?void 0:arguments[t]))return!1;return!0}floor(){return this.floorToRef(new mE)}floorToRef(E){const t=this.Ep,z=E.Ep;for(let A=0;A<16;A++)z[A]=Math.floor(t[A]);return E.markAsUpdated(),E}fract(){return this.fractToRef(new mE)}fractToRef(E){const t=this.Ep,z=E.Ep;for(let A=0;A<16;A++)z[A]=t[A]-Math.floor(t[A]);return E.markAsUpdated(),E}clone(){const E=new mE;return E.R(this),E}getClassName(){return"Matrix"}getHashCode(){let E=y(this.Ep[0]);for(let t=1;t<16;t++)E=397*E^y(this.Ep[t]);return E}decomposeToTransformNode(E){return E.rotationQuaternion=E.rotationQuaternion||new L,this.decompose(E.cp,E.rotationQuaternion,E.position)}decompose(E,t,z,A){let X=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return z&&z.ap(0),E&&E.ap(1),t&&t.Op(0,0,0,1),!0;const R=this.Ep;if(z&&z.Op(R[12],R[13],R[14]),(E=E||W.Lt[0]).x=Math.sqrt(R[0]*R[0]+R[1]*R[1]+R[2]*R[2]),E.y=Math.sqrt(R[4]*R[4]+R[5]*R[5]+R[6]*R[6]),E.z=Math.sqrt(R[8]*R[8]+R[9]*R[9]+R[10]*R[10]),A){const t=(X?A.absoluteScaling.x:A.cp.x)<0?-1:1,z=(X?A.absoluteScaling.y:A.cp.y)<0?-1:1,R=(X?A.absoluteScaling.z:A.cp.z)<0?-1:1;E.x*=t,E.y*=z,E.z*=R}else this.determinant()<=0&&(E.y*=-1);if(0===E._x||0===E._y||0===E._z)return t&&t.Op(0,0,0,1),!1;if(t){const z=1/E._x,A=1/E._y,X=1/E._z;mE.FromValuesToRef(R[0]*z,R[1]*z,R[2]*z,0,R[4]*A,R[5]*A,R[6]*A,0,R[8]*X,R[9]*X,R[10]*X,0,0,0,0,1,W.Matrix[0]),L.FromRotationMatrixToRef(W.Matrix[0],t)}return!0}getRow(E){if(E<0||E>3)return null;const t=4*E;return new a(this.Ep[t+0],this.Ep[t+1],this.Ep[t+2],this.Ep[t+3])}getRowToRef(E,t){if(E>=0&&E<=3){const z=4*E;t.x=this.Ep[z+0],t.y=this.Ep[z+1],t.z=this.Ep[z+2],t.w=this.Ep[z+3]}return t}setRow(E,t){return this.setRowFromFloats(E,t.x,t.y,t.z,t.w)}transpose(){const E=new mE;return mE.TransposeToRef(this,E),E}transposeToRef(E){return mE.TransposeToRef(this,E),E}setRowFromFloats(E,t,z,A,X){if(E<0||E>3)return this;const R=4*E;return this.Ep[R+0]=t,this.Ep[R+1]=z,this.Ep[R+2]=A,this.Ep[R+3]=X,this.markAsUpdated(),this}scale(E){const t=new mE;return this.scaleToRef(E,t),t}scaleToRef(E,t){for(let z=0;z<16;z++)t.Ep[z]=this.Ep[z]*E;return t.markAsUpdated(),t}scaleAndAddToRef(E,t){for(let z=0;z<16;z++)t.Ep[z]+=this.Ep[z]*E;return t.markAsUpdated(),t}scaleInPlace(E){const t=this.Ep;for(let z=0;z<16;z++)t[z]*=E;return this.markAsUpdated(),this}toNormalMatrix(E){const t=W.Matrix[0];this.invertToRef(t),t.transposeToRef(E);const z=E.Ep;return mE.FromValuesToRef(z[0],z[1],z[2],0,z[4],z[5],z[6],0,z[8],z[9],z[10],0,0,0,0,1,E),E}getRotationMatrix(){const E=new mE;return this.getRotationMatrixToRef(E),E}getRotationMatrixToRef(E){const t=W.Lt[0];if(!this.decompose(t))return mE.IdentityToRef(E),E;const z=this.Ep,A=1/t._x,X=1/t._y,R=1/t._z;return mE.FromValuesToRef(z[0]*A,z[1]*A,z[2]*A,0,z[4]*X,z[5]*X,z[6]*X,0,z[8]*R,z[9]*R,z[10]*R,0,0,0,0,1,E),E}toggleModelMatrixHandInPlace(){const E=this.Ep;return E[2]*=-1,E[6]*=-1,E[8]*=-1,E[9]*=-1,E[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const E=this.Ep;return E[8]*=-1,E[9]*=-1,E[10]*=-1,E[11]*=-1,this.markAsUpdated(),this}static St(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const z=new mE;return mE.FromArrayToRef(E,t,z),z}static FromArrayToRef(E,t,z){for(let A=0;A<16;A++)z.Ep[A]=E[A+t];return z.markAsUpdated(),z}static FromFloat32ArrayToRefScaled(E,t,z,A){return A.Ep[0]=E[0+t]*z,A.Ep[1]=E[1+t]*z,A.Ep[2]=E[2+t]*z,A.Ep[3]=E[3+t]*z,A.Ep[4]=E[4+t]*z,A.Ep[5]=E[5+t]*z,A.Ep[6]=E[6+t]*z,A.Ep[7]=E[7+t]*z,A.Ep[8]=E[8+t]*z,A.Ep[9]=E[9+t]*z,A.Ep[10]=E[10+t]*z,A.Ep[11]=E[11+t]*z,A.Ep[12]=E[12+t]*z,A.Ep[13]=E[13+t]*z,A.Ep[14]=E[14+t]*z,A.Ep[15]=E[15+t]*z,A.markAsUpdated(),A}static get IdentityReadOnly(){return mE._IdentityReadOnly}static FromValuesToRef(E,t,z,A,X,R,u,p,C,Z,H,h,d,y,O,c,a){const L=a.Ep;L[0]=E,L[1]=t,L[2]=z,L[3]=A,L[4]=X,L[5]=R,L[6]=u,L[7]=p,L[8]=C,L[9]=Z,L[10]=H,L[11]=h,L[12]=d,L[13]=y,L[14]=O,L[15]=c,a.markAsUpdated()}static FromValues(E,t,z,A,X,R,u,p,C,Z,H,h,d,y,O,c){const a=new mE,L=a.Ep;return L[0]=E,L[1]=t,L[2]=z,L[3]=A,L[4]=X,L[5]=R,L[6]=u,L[7]=p,L[8]=C,L[9]=Z,L[10]=H,L[11]=h,L[12]=d,L[13]=y,L[14]=O,L[15]=c,a.markAsUpdated(),a}static Compose(E,t,z){const A=new mE;return mE.ComposeToRef(E,t,z,A),A}static ComposeToRef(E,t,z,A){const X=A.Ep,R=t._x,u=t._y,p=t._z,C=t._w,Z=R+R,H=u+u,h=p+p,d=R*Z,y=R*H,O=R*h,c=u*H,a=u*h,L=p*h,mE=C*Z,W=C*H,I=C*h,e=E._x,D=E._y,S=E._z;return X[0]=(1-(c+L))*e,X[1]=(y+I)*e,X[2]=(O-W)*e,X[3]=0,X[4]=(y-I)*D,X[5]=(1-(d+L))*D,X[6]=(a+mE)*D,X[7]=0,X[8]=(O+W)*S,X[9]=(a-mE)*S,X[10]=(1-(d+c))*S,X[11]=0,X[12]=z._x,X[13]=z._y,X[14]=z._z,X[15]=1,A.markAsUpdated(),A}static Identity(){const E=mE.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return E._updateIdentityStatus(!0),E}static IdentityToRef(E){return mE.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,E),E._updateIdentityStatus(!0),E}static Zero(){const E=mE.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return E._updateIdentityStatus(!1),E}static RotationX(E){const t=new mE;return mE.RotationXToRef(E,t),t}static Invert(E){const t=new mE;return E.invertToRef(t),t}static RotationXToRef(E,t){const z=Math.sin(E),A=Math.cos(E);return mE.FromValuesToRef(1,0,0,0,0,A,z,0,0,-z,A,0,0,0,0,1,t),t._updateIdentityStatus(1===A&&0===z),t}static RotationY(E){const t=new mE;return mE.RotationYToRef(E,t),t}static RotationYToRef(E,t){const z=Math.sin(E),A=Math.cos(E);return mE.FromValuesToRef(A,0,-z,0,0,1,0,0,z,0,A,0,0,0,0,1,t),t._updateIdentityStatus(1===A&&0===z),t}static RotationZ(E){const t=new mE;return mE.RotationZToRef(E,t),t}static RotationZToRef(E,t){const z=Math.sin(E),A=Math.cos(E);return mE.FromValuesToRef(A,z,0,0,-z,A,0,0,0,0,1,0,0,0,0,1,t),t._updateIdentityStatus(1===A&&0===z),t}static RotationAxis(E,t){const z=new mE;return mE.RotationAxisToRef(E,t,z),z}static RotationAxisToRef(E,t,z){const A=Math.sin(-t),X=Math.cos(-t),R=1-X;E=E.normalizeToRef(W.Lt[0]);const u=z.Ep;return u[0]=E._x*E._x*R+X,u[1]=E._x*E._y*R-E._z*A,u[2]=E._x*E._z*R+E._y*A,u[3]=0,u[4]=E._y*E._x*R+E._z*A,u[5]=E._y*E._y*R+X,u[6]=E._y*E._z*R-E._x*A,u[7]=0,u[8]=E._z*E._x*R-E._y*A,u[9]=E._z*E._y*R+E._x*A,u[10]=E._z*E._z*R+X,u[11]=0,u[12]=0,u[13]=0,u[14]=0,u[15]=1,z.markAsUpdated(),z}static RotationAlignToRef(E,t,z){let X=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const R=c.Dot(t,E),u=z.Ep;if(R<-1+A.c)u[0]=-1,u[1]=0,u[2]=0,u[3]=0,u[4]=0,u[5]=X?1:-1,u[6]=0,u[7]=0,u[8]=0,u[9]=0,u[10]=X?-1:1,u[11]=0;else{const z=c.Cross(t,E),A=1/(1+R);u[0]=z._x*z._x*A+R,u[1]=z._y*z._x*A-z._z,u[2]=z._z*z._x*A+z._y,u[3]=0,u[4]=z._x*z._y*A+z._z,u[5]=z._y*z._y*A+R,u[6]=z._z*z._y*A-z._x,u[7]=0,u[8]=z._x*z._z*A-z._y,u[9]=z._y*z._z*A+z._x,u[10]=z._z*z._z*A+R,u[11]=0}return u[12]=0,u[13]=0,u[14]=0,u[15]=1,z.markAsUpdated(),z}static RotationYawPitchRoll(E,t,z){const A=new mE;return mE.RotationYawPitchRollToRef(E,t,z,A),A}static RotationYawPitchRollToRef(E,t,z,A){return L.RotationYawPitchRollToRef(E,t,z,W.Quaternion[0]),W.Quaternion[0].toRotationMatrix(A),A}static Scaling(E,t,z){const A=new mE;return mE.ScalingToRef(E,t,z,A),A}static ScalingToRef(E,t,z,A){return mE.FromValuesToRef(E,0,0,0,0,t,0,0,0,0,z,0,0,0,0,1,A),A._updateIdentityStatus(1===E&&1===t&&1===z),A}static Translation(E,t,z){const A=new mE;return mE.TranslationToRef(E,t,z,A),A}static TranslationToRef(E,t,z,A){return mE.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,E,t,z,1,A),A._updateIdentityStatus(0===E&&0===t&&0===z),A}static Lerp(E,t,z){const A=new mE;return mE.LerpToRef(E,t,z,A),A}static LerpToRef(E,t,z,A){const X=A.Ep,R=E.m,u=t.m;for(let p=0;p<16;p++)X[p]=R[p]*(1-z)+u[p]*z;return A.markAsUpdated(),A}static DecomposeLerp(E,t,z){const A=new mE;return mE.DecomposeLerpToRef(E,t,z,A),A}static DecomposeLerpToRef(E,t,z,A){const X=W.Lt[0],R=W.Quaternion[0],u=W.Lt[1];E.decompose(X,R,u);const p=W.Lt[2],C=W.Quaternion[1],Z=W.Lt[3];t.decompose(p,C,Z);const H=W.Lt[4];c.LerpToRef(X,p,z,H);const h=W.Quaternion[2];L.SlerpToRef(R,C,z,h);const d=W.Lt[5];return c.LerpToRef(u,Z,z,d),mE.ComposeToRef(H,h,d,A),A}static LookAtLH(E,t,z){const A=new mE;return mE.LookAtLHToRef(E,t,z,A),A}static LookAtLHToRef(E,t,z,A){const X=W.Lt[0],R=W.Lt[1],u=W.Lt[2];t.subtractToRef(E,u),u.normalize(),c.CrossToRef(z,u,X);const p=X.lengthSquared();0===p?X.x=1:X.normalizeFromLength(Math.sqrt(p)),c.CrossToRef(u,X,R),R.normalize();const C=-c.Dot(X,E),Z=-c.Dot(R,E),H=-c.Dot(u,E);return mE.FromValuesToRef(X._x,R._x,u._x,0,X._y,R._y,u._y,0,X._z,R._z,u._z,0,C,Z,H,1,A),A}static LookAtRH(E,t,z){const A=new mE;return mE.LookAtRHToRef(E,t,z,A),A}static LookAtRHToRef(E,t,z,A){const X=W.Lt[0],R=W.Lt[1],u=W.Lt[2];E.subtractToRef(t,u),u.normalize(),c.CrossToRef(z,u,X);const p=X.lengthSquared();0===p?X.x=1:X.normalizeFromLength(Math.sqrt(p)),c.CrossToRef(u,X,R),R.normalize();const C=-c.Dot(X,E),Z=-c.Dot(R,E),H=-c.Dot(u,E);return mE.FromValuesToRef(X._x,R._x,u._x,0,X._y,R._y,u._y,0,X._z,R._z,u._z,0,C,Z,H,1,A),A}static LookDirectionLH(E,t){const z=new mE;return mE.LookDirectionLHToRef(E,t,z),z}static LookDirectionLHToRef(E,t,z){const A=W.Lt[0];A.R(E),A.scaleInPlace(-1);const X=W.Lt[1];return c.CrossToRef(t,A,X),mE.FromValuesToRef(X._x,X._y,X._z,0,t._x,t._y,t._z,0,A._x,A._y,A._z,0,0,0,0,1,z),z}static LookDirectionRH(E,t){const z=new mE;return mE.LookDirectionRHToRef(E,t,z),z}static LookDirectionRHToRef(E,t,z){const A=W.Lt[2];return c.CrossToRef(t,E,A),mE.FromValuesToRef(A._x,A._y,A._z,0,t._x,t._y,t._z,0,E._x,E._y,E._z,0,0,0,0,1,z),z}static OrthoLH(E,t,z,A,X){const R=new mE;return mE.OrthoLHToRef(E,t,z,A,R,X),R}static OrthoLHToRef(E,t,z,A,X,R){const u=2/E,p=2/t,C=2/(A-z),Z=-(A+z)/(A-z);return mE.FromValuesToRef(u,0,0,0,0,p,0,0,0,0,C,0,0,0,Z,1,X),R&&X.multiplyToRef(e,X),X._updateIdentityStatus(1===u&&1===p&&1===C&&0===Z),X}static OrthoOffCenterLH(E,t,z,A,X,R,u){const p=new mE;return mE.OrthoOffCenterLHToRef(E,t,z,A,X,R,p,u),p}static OrthoOffCenterLHToRef(E,t,z,A,X,R,u,p){const C=2/(t-E),Z=2/(A-z),H=2/(R-X),h=-(R+X)/(R-X),d=(E+t)/(E-t),y=(A+z)/(z-A);return mE.FromValuesToRef(C,0,0,0,0,Z,0,0,0,0,H,0,d,y,h,1,u),p&&u.multiplyToRef(e,u),u.markAsUpdated(),u}static ObliqueOffCenterLHToRef(E,t,z,A,X,R,u,p,C,Z,H){const h=-u*Math.cos(p),d=-u*Math.sin(p);return mE.TranslationToRef(0,0,-C,W.Matrix[1]),mE.FromValuesToRef(1,0,0,0,0,1,0,0,h,d,1,0,0,0,0,1,W.Matrix[0]),W.Matrix[1].multiplyToRef(W.Matrix[0],W.Matrix[0]),mE.TranslationToRef(0,0,C,W.Matrix[1]),W.Matrix[0].multiplyToRef(W.Matrix[1],W.Matrix[0]),mE.OrthoOffCenterLHToRef(E,t,z,A,X,R,Z,H),W.Matrix[0].multiplyToRef(Z,Z),Z}static OrthoOffCenterRH(E,t,z,A,X,R,u){const p=new mE;return mE.OrthoOffCenterRHToRef(E,t,z,A,X,R,p,u),p}static OrthoOffCenterRHToRef(E,t,z,A,X,R,u,p){return mE.OrthoOffCenterLHToRef(E,t,z,A,X,R,u,p),u.Ep[10]*=-1,u}static ObliqueOffCenterRHToRef(E,t,z,A,X,R,u,p,C,Z,H){const h=u*Math.cos(p),d=u*Math.sin(p);return mE.TranslationToRef(0,0,C,W.Matrix[1]),mE.FromValuesToRef(1,0,0,0,0,1,0,0,h,d,1,0,0,0,0,1,W.Matrix[0]),W.Matrix[1].multiplyToRef(W.Matrix[0],W.Matrix[0]),mE.TranslationToRef(0,0,-C,W.Matrix[1]),W.Matrix[0].multiplyToRef(W.Matrix[1],W.Matrix[0]),mE.OrthoOffCenterRHToRef(E,t,z,A,X,R,Z,H),W.Matrix[0].multiplyToRef(Z,Z),Z}static PerspectiveLH(E,t,z,A,X){let R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const u=new mE,p=2*z/E,C=2*z/t,Z=(A+z)/(A-z),H=-2*A*z/(A-z),h=Math.tan(R);return mE.FromValuesToRef(p,0,0,0,0,C,0,h,0,0,Z,1,0,0,H,0,u),X&&u.multiplyToRef(e,u),u._updateIdentityStatus(!1),u}static PerspectiveFovLH(E,t,z,A,X){let R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,u=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const p=new mE;return mE.PerspectiveFovLHToRef(E,t,z,A,p,!0,X,R,u),p}static PerspectiveFovLHToRef(E,t,z,A,X){let R=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,p=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,C=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const Z=z,H=A,h=1/Math.tan(.5*E),d=R?h/t:h,y=R?h:h*t,O=C&&0===Z?-1:0!==H?(H+Z)/(H-Z):1,c=C&&0===Z?2*H:0!==H?-2*H*Z/(H-Z):-2*Z,a=Math.tan(p);return mE.FromValuesToRef(d,0,0,0,0,y,0,a,0,0,O,1,0,0,c,0,X),u&&X.multiplyToRef(e,X),X._updateIdentityStatus(!1),X}static PerspectiveFovReverseLHToRef(E,t,z,A,X){let R=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,p=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const C=1/Math.tan(.5*E),Z=R?C/t:C,H=R?C:C*t,h=Math.tan(p);return mE.FromValuesToRef(Z,0,0,0,0,H,0,h,0,0,-z,1,0,0,1,0,X),u&&X.multiplyToRef(e,X),X._updateIdentityStatus(!1),X}static PerspectiveFovRH(E,t,z,A,X){let R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,u=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const p=new mE;return mE.PerspectiveFovRHToRef(E,t,z,A,p,!0,X,R,u),p}static PerspectiveFovRHToRef(E,t,z,A,X){let R=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,p=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,C=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const Z=z,H=A,h=1/Math.tan(.5*E),d=R?h/t:h,y=R?h:h*t,O=C&&0===Z?1:0!==H?-(H+Z)/(H-Z):-1,c=C&&0===Z?2*H:0!==H?-2*H*Z/(H-Z):-2*Z,a=Math.tan(p);return mE.FromValuesToRef(d,0,0,0,0,y,0,a,0,0,O,-1,0,0,c,0,X),u&&X.multiplyToRef(e,X),X._updateIdentityStatus(!1),X}static PerspectiveFovReverseRHToRef(E,t,z,A,X){let R=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],u=arguments.length>6?arguments[6]:void 0,p=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const C=1/Math.tan(.5*E),Z=R?C/t:C,H=R?C:C*t,h=Math.tan(p);return mE.FromValuesToRef(Z,0,0,0,0,H,0,h,0,0,-z,-1,0,0,-1,0,X),u&&X.multiplyToRef(e,X),X._updateIdentityStatus(!1),X}static GetFinalMatrix(E,t,z,A,X,R){const u=E.width,p=E.height,C=E.x,Z=E.y,H=mE.FromValues(u/2,0,0,0,0,-p/2,0,0,0,0,R-X,0,C+u/2,p/2+Z,X,1),h=new mE;return t.multiplyToRef(z,h),h.multiplyToRef(A,h),h.multiplyToRef(H,h)}static GetAsMatrix2x2(E){const t=E.m,z=[t[0],t[1],t[4],t[5]];return u.c.MatrixUse64Bits?z:new Float32Array(z)}static GetAsMatrix3x3(E){const t=E.m,z=[t[0],t[1],t[2],t[4],t[5],t[6],t[8],t[9],t[10]];return u.c.MatrixUse64Bits?z:new Float32Array(z)}static Transpose(E){const t=new mE;return mE.TransposeToRef(E,t),t}static TransposeToRef(E,t){const z=E.m,A=z[0],X=z[4],R=z[8],u=z[12],p=z[1],C=z[5],Z=z[9],H=z[13],h=z[2],d=z[6],y=z[10],O=z[14],c=z[3],a=z[7],L=z[11],mE=z[15],W=t.Ep;return W[0]=A,W[1]=X,W[2]=R,W[3]=u,W[4]=p,W[5]=C,W[6]=Z,W[7]=H,W[8]=h,W[9]=d,W[10]=y,W[11]=O,W[12]=c,W[13]=a,W[14]=L,W[15]=mE,t.markAsUpdated(),t._updateIdentityStatus(E._isIdentity,E._isIdentityDirty),t}static Reflection(E){const t=new mE;return mE.ReflectionToRef(E,t),t}static ReflectionToRef(E,t){E.normalize();const z=E.normal.x,A=E.normal.y,X=E.normal.z,R=-2*z,u=-2*A,p=-2*X;return mE.FromValuesToRef(R*z+1,u*z,p*z,0,R*A,u*A+1,p*A,0,R*X,u*X,p*X+1,0,R*E.d,u*E.d,p*E.d,1,t),t}static FromXYZAxesToRef(E,t,z,A){return mE.FromValuesToRef(E._x,E._y,E._z,0,t._x,t._y,t._z,0,z._x,z._y,z._z,0,0,0,0,1,A),A}static FromQuaternionToRef(E,t){const z=E._x*E._x,A=E._y*E._y,X=E._z*E._z,R=E._x*E._y,u=E._z*E._w,p=E._z*E._x,C=E._y*E._w,Z=E._y*E._z,H=E._x*E._w;return t.Ep[0]=1-2*(A+X),t.Ep[1]=2*(R+u),t.Ep[2]=2*(p-C),t.Ep[3]=0,t.Ep[4]=2*(R-u),t.Ep[5]=1-2*(X+z),t.Ep[6]=2*(Z+H),t.Ep[7]=0,t.Ep[8]=2*(p+C),t.Ep[9]=2*(Z-H),t.Ep[10]=1-2*(A+z),t.Ep[11]=0,t.Ep[12]=0,t.Ep[13]=0,t.Ep[14]=0,t.Ep[15]=1,t.markAsUpdated(),t}}mE._IdentityReadOnly=mE.Identity(),Object.defineProperties(mE.prototype,{dimension:{value:[4,4]},rank:{value:2}});class W{}W.Lt=(0,X.d)(11,c.Zero),W.Matrix=(0,X.d)(2,mE.Identity),W.Quaternion=(0,X.d)(3,L.Zero);class I{}I.Vector2=(0,X.d)(3,O.Zero),I.Lt=(0,X.d)(13,c.Zero),I.Vector4=(0,X.d)(3,a.Zero),I.Quaternion=(0,X.d)(3,L.Zero),I.Matrix=(0,X.d)(8,mE.Identity),(0,R.f)("BABYLON.Vector2",O),(0,R.f)("BABYLON.Vector3",c),(0,R.f)("BABYLON.Vector4",a),(0,R.f)("BABYLON.Matrix",mE);const e=mE.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11826:(E,t,z)=>{function A(E,t){const z=[];for(let A=0;A<E;++A)z.push(t());return z}function X(E,t){return A(E,t)}z.d(t,{c:()=>A,d:()=>X,h:()=>u});const R=["push","splice","pop","shift","unshift"];function u(E,t){const z=R.map((z=>function(E,t,z){const A=E[t];if("function"!==typeof A)return null;const X=function(){const A=E.length,R=X.previous.apply(E,arguments);return z(t,A),R};return A.next=X,X.previous=A,E[t]=X,()=>{const z=X.previous;if(!z)return;const A=X.next;A?(z.next=A,A.previous=z):(z.next=void 0,E[t]=z),X.next=void 0,X.previous=void 0}}(E,z,t)));return()=>{for(const E of z)null===E||void 0===E||E()}}}}]);