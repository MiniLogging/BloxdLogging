"use strict";(self.h6ljd275xwr=self.h6ljd275xwr||[]).push([[14],{11297:(n,y,H)=>{H.d(y,{e:()=>k,i:()=>h,k:()=>o,n:()=>G});const o=1/2.2,G=2.2,h=(1+Math.sqrt(5))/2,k=.001},11303:(n,y,H)=>{function o(n){return parseInt(n.toString().replace(/\W/g,""))}function G(n,y){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(n-y)<=H}function h(n,y,H){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return n<y-o||n>H+o}function k(n,y){return n===y?n:Math.random()*(y-n)+n}function i(n,y,H){return n+(y-n)*H}function B(n,y,H){let o=z(y-n,360);return o>180&&(o-=360),n+o*A(H)}function V(n,y,H){let o=0;return o=n!=y?A((H-n)/(y-n)):0,o}function q(n,y,H,o,G){const h=G*G,k=G*h;return n*(2*k-3*h+1)+H*(-2*k+3*h)+y*(k-2*h+G)+o*(k-h)}function b(n,y,H,o,G){const h=G*G;return 6*(h-G)*n+(3*h-4*G+1)*y+6*(-h+G)*H+(3*h-2*G)*o}function A(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(H,Math.max(y,n))}function U(n){return n-=2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function T(n){const y=n.toString(16);return n<=15?("0"+y).toUpperCase():y.toUpperCase()}function W(n){if(Math.log2)return Math.floor(Math.log2(n));if(n<0)return NaN;if(0===n)return-1/0;let y=0;if(n<1){for(;n<1;)y++,n*=2;y=-y}else if(n>1)for(;n>1;)y++,n=Math.floor(n/2);return y}function z(n,y){return n-Math.floor(n/y)*y}function Q(n,y,H){return(n-y)/(H-y)}function l(n,y,H){return n*(H-y)+y}function v(n,y){let H=z(y-n,360);return H>180&&(H-=360),H}function F(n,y){const H=z(n,2*y);return y-Math.abs(H-y)}function g(n,y,H){let o=A(H);return o=-2*o*o*o+3*o*o,y*o+n*(1-o)}function M(n,y,H){let o=0;return o=Math.abs(y-n)<=H?y:n+Math.sign(y-n)*H,o}function f(n,y,H){const o=v(n,y);let G=0;return G=-H<o&&o<H?y:M(n,y=n+o,H),G}function c(n,y,H){return(n-y)/(H-y)}function p(n,y,H){return(H-y)*n+y}function E(n,y){const H=n%y;return 0===H?y:E(y,H)}H.r(y),H.d(y,{Clamp:()=>A,DeltaAngle:()=>v,Denormalize:()=>l,ExtractAsInt:()=>o,Hermite:()=>q,Hermite1stDerivative:()=>b,HighestCommonFactor:()=>E,ILog2:()=>W,InverseLerp:()=>V,Lerp:()=>i,LerpAngle:()=>B,MoveTowards:()=>M,MoveTowardsAngle:()=>f,Normalize:()=>Q,NormalizeRadians:()=>U,OutsideRange:()=>h,PercentToRange:()=>p,PingPong:()=>F,RandomRange:()=>k,RangeToPercent:()=>c,Repeat:()=>z,SmoothStep:()=>g,ToHex:()=>T,WithinEpsilon:()=>G})},11288:(n,y,H)=>{H.r(y),H.d(y,{Matrix:()=>l,Quaternion:()=>Q,TmpVectors:()=>F,Vector2:()=>T,zy:()=>W,Vector4:()=>z});var o=H(11297),G=H(11300),h=H(11248),k=H(11223),i=H(11149),B=H(11303);class V{}function q(n,y,H){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const G=n.Ui(),h=y.Ui(),k=G[0],i=G[1],B=G[2],V=G[3],q=G[4],b=G[5],A=G[6],U=G[7],T=G[8],W=G[9],z=G[10],Q=G[11],l=G[12],v=G[13],F=G[14],g=G[15],M=h[0],f=h[1],c=h[2],p=h[3],E=h[4],X=h[5],d=h[6],a=h[7],O=h[8],e=h[9],w=h[10],j=h[11],I=h[12],R=h[13],C=h[14],S=h[15];H[o]=k*M+i*E+B*O+V*I,H[o+1]=k*f+i*X+B*e+V*R,H[o+2]=k*c+i*d+B*w+V*C,H[o+3]=k*p+i*a+B*j+V*S,H[o+4]=q*M+b*E+A*O+U*I,H[o+5]=q*f+b*X+A*e+U*R,H[o+6]=q*c+b*d+A*w+U*C,H[o+7]=q*p+b*a+A*j+U*S,H[o+8]=T*M+W*E+z*O+Q*I,H[o+9]=T*f+W*X+z*e+Q*R,H[o+10]=T*c+W*d+z*w+Q*C,H[o+11]=T*p+W*a+z*j+Q*S,H[o+12]=l*M+v*E+F*O+g*I,H[o+13]=l*f+v*X+F*e+g*R,H[o+14]=l*c+v*d+F*w+g*C,H[o+15]=l*p+v*a+F*j+g*S}function b(n,y){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const o=n.Ui();y[H]=o[0],y[H+1]=o[1],y[H+2]=o[2],y[H+3]=o[3],y[H+4]=o[4],y[H+5]=o[5],y[H+6]=o[6],y[H+7]=o[7],y[H+8]=o[8],y[H+9]=o[9],y[H+10]=o[10],y[H+11]=o[11],y[H+12]=o[12],y[H+13]=o[13],y[H+14]=o[14],y[H+15]=o[15]}function A(n,y){const H=n.Ui(),o=H[0],G=H[1],h=H[2],k=H[3],i=H[4],B=H[5],V=H[6],q=H[7],b=H[8],A=H[9],U=H[10],T=H[11],W=H[12],z=H[13],Q=H[14],l=H[15],v=U*l-Q*T,F=A*l-z*T,g=A*Q-z*U,M=b*l-W*T,f=b*Q-U*W,c=b*z-W*A,p=+(B*v-V*F+q*g),E=-(i*v-V*M+q*f),X=+(i*F-B*M+q*c),d=-(i*g-B*f+V*c),a=o*p+G*E+h*X+k*d;if(0===a)return!1;const O=1/a,e=V*l-Q*q,w=B*l-z*q,j=B*Q-z*V,I=i*l-W*q,R=i*Q-W*V,C=i*z-W*B,S=V*T-U*q,N=B*T-A*q,r=B*U-A*V,K=i*T-b*q,Y=i*U-b*V,D=i*A-b*B,Z=-(G*v-h*F+k*g),s=+(o*v-h*M+k*f),P=-(o*F-G*M+k*c),x=+(o*g-G*f+h*c),t=+(G*e-h*w+k*j),u=-(o*e-h*I+k*R),L=+(o*w-G*I+k*C),J=-(o*j-G*R+h*C),m=-(G*S-h*N+k*r),nn=+(o*S-h*K+k*Y),yn=-(o*N-G*K+k*D),Hn=+(o*r-G*Y+h*D);return y[0]=p*O,y[1]=Z*O,y[2]=t*O,y[3]=m*O,y[4]=E*O,y[5]=s*O,y[6]=u*O,y[7]=nn*O,y[8]=X*O,y[9]=P*O,y[10]=L*O,y[11]=yn*O,y[12]=d*O,y[13]=x*O,y[14]=J*O,y[15]=Hn*O,!0}V._UpdateFlagSeed=0;const U=n=>parseInt(n.toString().replace(/\W/g,""));class T{constructor(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=n,this.y=y}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let n=U(this.x);return n=397*n^U(this.y),n}toArray(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[y]=this.x,n[y+1]=this.y,this}vH(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return T.FromArrayToRef(n,y,this),this}Ui(){return[this.x,this.y]}B(n){return this.x=n.x,this.y=n.y,this}Mi(n,y){return this.x=n,this.y=y,this}set(n,y){return this.Mi(n,y)}ci(n){return this.Mi(n,n)}add(n){return new T(this.x+n.x,this.y+n.y)}addToRef(n,y){return y.x=this.x+n.x,y.y=this.y+n.y,y}addInPlace(n){return this.x+=n.x,this.y+=n.y,this}addInPlaceFromFloats(n,y){return this.x+=n,this.y+=y,this}addVector3(n){return new T(this.x+n.x,this.y+n.y)}Qy(n){return new T(this.x-n.x,this.y-n.y)}subtractToRef(n,y){return y.x=this.x-n.x,y.y=this.y-n.y,y}kb(n){return this.x-=n.x,this.y-=n.y,this}multiplyInPlace(n){return this.x*=n.x,this.y*=n.y,this}multiply(n){return new T(this.x*n.x,this.y*n.y)}multiplyToRef(n,y){return y.x=this.x*n.x,y.y=this.y*n.y,y}multiplyByFloats(n,y){return new T(this.x*n,this.y*y)}divide(n){return new T(this.x/n.x,this.y/n.y)}divideToRef(n,y){return y.x=this.x/n.x,y.y=this.y/n.y,y}divideInPlace(n){return this.x=this.x/n.x,this.y=this.y/n.y,this}minimizeInPlace(n){return this.minimizeInPlaceFromFloats(n.x,n.y)}maximizeInPlace(n){return this.maximizeInPlaceFromFloats(n.x,n.y)}minimizeInPlaceFromFloats(n,y){return this.x=Math.min(n,this.x),this.y=Math.min(y,this.y),this}maximizeInPlaceFromFloats(n,y){return this.x=Math.max(n,this.x),this.y=Math.max(y,this.y),this}subtractFromFloats(n,y){return new T(this.x-n,this.y-y)}subtractFromFloatsToRef(n,y,H){return H.x=this.x-n,H.y=this.y-y,H}negate(){return new T(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(n){return n.x=-this.x,n.y=-this.y,n}scaleInPlace(n){return this.x*=n,this.y*=n,this}scale(n){return new T(this.x*n,this.y*n)}scaleToRef(n,y){return y.x=this.x*n,y.y=this.y*n,y}scaleAndAddToRef(n,y){return y.x+=this.x*n,y.y+=this.y*n,y}equals(n){return n&&this.x===n.x&&this.y===n.y}equalsWithEpsilon(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.e;return n&&(0,B.WithinEpsilon)(this.x,n.x,y)&&(0,B.WithinEpsilon)(this.y,n.y,y)}equalsToFloats(n,y){return this.x===n&&this.y===y}floor(){return new T(Math.floor(this.x),Math.floor(this.y))}floorToRef(n){return n.x=Math.floor(this.x),n.y=Math.floor(this.y),n}fract(){return new T(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(n){return n.x=this.x-Math.floor(this.x),n.y=this.y-Math.floor(this.y),n}rotate(n){return this.rotateToRef(n,new T)}rotateToRef(n,y){const H=Math.cos(n),o=Math.sin(n);return y.x=H*this.x-o*this.y,y.y=o*this.x+H*this.y,y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(n){return 0===n||1===n?this:this.scaleInPlace(1/n)}normalizeToNew(){const n=new T;return this.normalizeToRef(n),n}normalizeToRef(n){const y=this.length();return 0===y&&(n.x=this.x,n.y=this.y),this.scaleToRef(1/y,n)}clone(){return new T(this.x,this.y)}dot(n){return this.x*n.x+this.y*n.y}static Zero(){return new T(0,0)}static One(){return new T(1,1)}static Random(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new T((0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y))}static RandomToRef(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Mi((0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y))}static get ZeroReadOnly(){return T._ZeroReadOnly}static gy(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new T(n[y],n[y+1])}static FromArrayToRef(n,y,H){return H.x=n[y],H.y=n[y+1],H}static FromFloatsToRef(n,y,H){return H.Mi(n,y),H}static CatmullRom(n,y,H,o,G){const h=G*G,k=G*h,i=.5*(2*y.x+(-n.x+H.x)*G+(2*n.x-5*y.x+4*H.x-o.x)*h+(-n.x+3*y.x-3*H.x+o.x)*k),B=.5*(2*y.y+(-n.y+H.y)*G+(2*n.y-5*y.y+4*H.y-o.y)*h+(-n.y+3*y.y-3*H.y+o.y)*k);return new T(i,B)}static ClampToRef(n,y,H,o){return o.x=(0,B.Clamp)(n.x,y.x,H.x),o.y=(0,B.Clamp)(n.y,y.y,H.y),o}static Clamp(n,y,H){const o=(0,B.Clamp)(n.x,y.x,H.x),G=(0,B.Clamp)(n.y,y.y,H.y);return new T(o,G)}static Hermite(n,y,H,o,G){const h=G*G,k=G*h,i=2*k-3*h+1,B=-2*k+3*h,V=k-2*h+G,q=k-h,b=n.x*i+H.x*B+y.x*V+o.x*q,A=n.y*i+H.y*B+y.y*V+o.y*q;return new T(b,A)}static Hermite1stDerivative(n,y,H,o,G){return this.Hermite1stDerivativeToRef(n,y,H,o,G,new T)}static Hermite1stDerivativeToRef(n,y,H,o,G,h){const k=G*G;return h.x=6*(k-G)*n.x+(3*k-4*G+1)*y.x+6*(-k+G)*H.x+(3*k-2*G)*o.x,h.y=6*(k-G)*n.y+(3*k-4*G+1)*y.y+6*(-k+G)*H.y+(3*k-2*G)*o.y,h}static Lerp(n,y,H){return T.LerpToRef(n,y,H,new T)}static LerpToRef(n,y,H,o){return o.x=n.x+(y.x-n.x)*H,o.y=n.y+(y.y-n.y)*H,o}static Dot(n,y){return n.x*y.x+n.y*y.y}static Normalize(n){return T.NormalizeToRef(n,new T)}static NormalizeToRef(n,y){return n.normalizeToRef(y),y}static Minimize(n,y){const H=n.x<y.x?n.x:y.x,o=n.y<y.y?n.y:y.y;return new T(H,o)}static Maximize(n,y){const H=n.x>y.x?n.x:y.x,o=n.y>y.y?n.y:y.y;return new T(H,o)}static Transform(n,y){return T.TransformToRef(n,y,new T)}static TransformToRef(n,y,H){const o=y.m,G=n.x*o[0]+n.y*o[4]+o[12],h=n.x*o[1]+n.y*o[5]+o[13];return H.x=G,H.y=h,H}static PointInTriangle(n,y,H,o){const G=.5*(-H.y*o.x+y.y*(-H.x+o.x)+y.x*(H.y-o.y)+H.x*o.y),h=G<0?-1:1,k=(y.y*o.x-y.x*o.y+(o.y-y.y)*n.x+(y.x-o.x)*n.y)*h,i=(y.x*H.y-y.y*H.x+(y.y-H.y)*n.x+(H.x-y.x)*n.y)*h;return k>0&&i>0&&k+i<2*G*h}static Distance(n,y){return Math.sqrt(T.DistanceSquared(n,y))}static DistanceSquared(n,y){const H=n.x-y.x,o=n.y-y.y;return H*H+o*o}static Center(n,y){return T.CenterToRef(n,y,new T)}static CenterToRef(n,y,H){return H.Mi((n.x+y.x)/2,(n.y+y.y)/2)}static DistanceOfPointFromSegment(n,y,H){const o=T.DistanceSquared(y,H);if(0===o)return T.Distance(n,y);const G=H.Qy(y),h=Math.max(0,Math.min(1,T.Dot(n.Qy(y),G)/o)),k=y.add(G.multiplyByFloats(h,h));return T.Distance(n,k)}}T._V8PerformanceHack=new T(.5,.5),T._ZeroReadOnly=T.Zero(),Object.defineProperties(T.prototype,{dimension:{value:[2]},rank:{value:1}});class W{get x(){return this._x}set x(n){this._x=n,this._isDirty=!0}get y(){return this._y}set y(n){this._y=n,this._isDirty=!0}get z(){return this._z}set z(n){this._z=n,this._isDirty=!0}constructor(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=n,this._y=y,this._z=H}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"zy"}getHashCode(){let n=U(this._x);return n=397*n^U(this._y),n=397*n^U(this._z),n}Ui(){return[this._x,this._y,this._z]}toArray(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[y]=this._x,n[y+1]=this._y,n[y+2]=this._z,this}vH(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return W.FromArrayToRef(n,y,this),this}toQuaternion(){return Q.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(n){return this._x+=n._x,this._y+=n._y,this._z+=n._z,this._isDirty=!0,this}addInPlaceFromFloats(n,y,H){return this._x+=n,this._y+=y,this._z+=H,this._isDirty=!0,this}add(n){return new W(this._x+n._x,this._y+n._y,this._z+n._z)}addToRef(n,y){return y._x=this._x+n._x,y._y=this._y+n._y,y._z=this._z+n._z,y._isDirty=!0,y}kb(n){return this._x-=n._x,this._y-=n._y,this._z-=n._z,this._isDirty=!0,this}Qy(n){return new W(this._x-n._x,this._y-n._y,this._z-n._z)}subtractToRef(n,y){return this.subtractFromFloatsToRef(n._x,n._y,n._z,y)}subtractFromFloats(n,y,H){return new W(this._x-n,this._y-y,this._z-H)}subtractFromFloatsToRef(n,y,H,o){return o._x=this._x-n,o._y=this._y-y,o._z=this._z-H,o._isDirty=!0,o}negate(){return new W(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(n){return n._x=-1*this._x,n._y=-1*this._y,n._z=-1*this._z,n._isDirty=!0,n}scaleInPlace(n){return this._x*=n,this._y*=n,this._z*=n,this._isDirty=!0,this}scale(n){return new W(this._x*n,this._y*n,this._z*n)}scaleToRef(n,y){return y._x=this._x*n,y._y=this._y*n,y._z=this._z*n,y._isDirty=!0,y}getNormalToRef(n){const y=this.length();let H=Math.acos(this._y/y);const o=Math.atan2(this._z,this._x);H>Math.PI/2?H-=Math.PI/2:H+=Math.PI/2;const G=y*Math.sin(H)*Math.cos(o),h=y*Math.cos(H),k=y*Math.sin(H)*Math.sin(o);return n.set(G,h,k),n}applyRotationQuaternionToRef(n,y){const H=this._x,o=this._y,G=this._z,h=n._x,k=n._y,i=n._z,B=n._w,V=2*(k*G-i*o),q=2*(i*H-h*G),b=2*(h*o-k*H);return y._x=H+B*V+k*b-i*q,y._y=o+B*q+i*V-h*b,y._z=G+B*b+h*q-k*V,y._isDirty=!0,y}applyRotationQuaternionInPlace(n){return this.applyRotationQuaternionToRef(n,this)}applyRotationQuaternion(n){return this.applyRotationQuaternionToRef(n,new W)}scaleAndAddToRef(n,y){return y._x+=this._x*n,y._y+=this._y*n,y._z+=this._z*n,y._isDirty=!0,y}projectOnPlane(n,y){return this.projectOnPlaneToRef(n,y,new W)}projectOnPlaneToRef(n,y,H){const o=n.normal,G=n.d,h=v.zy[0];this.subtractToRef(y,h),h.normalize();const k=W.Dot(h,o);if(Math.abs(k)<1e-10)H.ci(1/0);else{const n=-(W.Dot(y,o)+G)/k,i=h.scaleInPlace(n);y.addToRef(i,H)}return H}equals(n){return n&&this._x===n._x&&this._y===n._y&&this._z===n._z}equalsWithEpsilon(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.e;return n&&(0,B.WithinEpsilon)(this._x,n._x,y)&&(0,B.WithinEpsilon)(this._y,n._y,y)&&(0,B.WithinEpsilon)(this._z,n._z,y)}equalsToFloats(n,y,H){return this._x===n&&this._y===y&&this._z===H}multiplyInPlace(n){return this._x*=n._x,this._y*=n._y,this._z*=n._z,this._isDirty=!0,this}multiply(n){return this.multiplyByFloats(n._x,n._y,n._z)}multiplyToRef(n,y){return y._x=this._x*n._x,y._y=this._y*n._y,y._z=this._z*n._z,y._isDirty=!0,y}multiplyByFloats(n,y,H){return new W(this._x*n,this._y*y,this._z*H)}divide(n){return new W(this._x/n._x,this._y/n._y,this._z/n._z)}divideToRef(n,y){return y._x=this._x/n._x,y._y=this._y/n._y,y._z=this._z/n._z,y._isDirty=!0,y}divideInPlace(n){return this._x=this._x/n._x,this._y=this._y/n._y,this._z=this._z/n._z,this._isDirty=!0,this}minimizeInPlace(n){return this.minimizeInPlaceFromFloats(n._x,n._y,n._z)}maximizeInPlace(n){return this.maximizeInPlaceFromFloats(n._x,n._y,n._z)}minimizeInPlaceFromFloats(n,y,H){return n<this._x&&(this.x=n),y<this._y&&(this.y=y),H<this._z&&(this.z=H),this}maximizeInPlaceFromFloats(n,y,H){return n>this._x&&(this.x=n),y>this._y&&(this.y=y),H>this._z&&(this.z=H),this}isNonUniformWithinEpsilon(n){const y=Math.abs(this._x),H=Math.abs(this._y);if(!(0,B.WithinEpsilon)(y,H,n))return!0;const o=Math.abs(this._z);return!(0,B.WithinEpsilon)(y,o,n)||!(0,B.WithinEpsilon)(H,o,n)}get isNonUniform(){const n=Math.abs(this._x);if(n!==Math.abs(this._y))return!0;return n!==Math.abs(this._z)}floorToRef(n){return n._x=Math.floor(this._x),n._y=Math.floor(this._y),n._z=Math.floor(this._z),n._isDirty=!0,n}floor(){return new W(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(n){return n._x=this._x-Math.floor(this._x),n._y=this._y-Math.floor(this._y),n._z=this._z-Math.floor(this._z),n._isDirty=!0,n}fract(){return new W(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(n){if("xyz"===(n=n.toLowerCase()))return this;const y=v.zy[0].B(this);return this.x=y[n[0]],this.y=y[n[1]],this.z=y[n[2]],this}rotateByQuaternionToRef(n,y){return n.toRotationMatrix(v.Matrix[0]),W.TransformCoordinatesToRef(this,v.Matrix[0],y),y}rotateByQuaternionAroundPointToRef(n,y,H){return this.subtractToRef(y,v.zy[0]),v.zy[0].rotateByQuaternionToRef(n,v.zy[0]),y.addToRef(v.zy[0],H),H}cross(n){return W.CrossToRef(this,n,new W)}normalizeFromLength(n){return 0===n||1===n?this:this.scaleInPlace(1/n)}normalizeToNew(){return this.normalizeToRef(new W)}normalizeToRef(n){const y=this.length();return 0===y||1===y?(n._x=this._x,n._y=this._y,n._z=this._z,n._isDirty=!0,n):this.scaleToRef(1/y,n)}clone(){return new W(this._x,this._y,this._z)}B(n){return this.Mi(n._x,n._y,n._z)}Mi(n,y,H){return this._x=n,this._y=y,this._z=H,this._isDirty=!0,this}set(n,y,H){return this.Mi(n,y,H)}ci(n){return this._x=this._y=this._z=n,this._isDirty=!0,this}static GetClipFactor(n,y,H,o){const G=W.Dot(n,H);return(G-o)/(G-W.Dot(y,H))}static GetAngleBetweenVectors(n,y,H){const o=n.normalizeToRef(v.zy[1]),G=y.normalizeToRef(v.zy[2]);let h=W.Dot(o,G);h=(0,B.Clamp)(h,-1,1);const k=Math.acos(h),i=v.zy[3];return W.CrossToRef(o,G,i),W.Dot(i,H)>0?isNaN(k)?0:k:isNaN(k)?-Math.PI:-Math.acos(h)}static GetAngleBetweenVectorsOnPlane(n,y,H){v.zy[0].B(n);const o=v.zy[0];v.zy[1].B(y);const G=v.zy[1];v.zy[2].B(H);const h=v.zy[2],k=v.zy[3],i=v.zy[4];o.normalize(),G.normalize(),h.normalize(),W.CrossToRef(h,o,k),W.CrossToRef(k,h,i);const V=Math.atan2(W.Dot(G,k),W.Dot(G,i));return(0,B.NormalizeRadians)(V)}static PitchYawRollToMoveBetweenPointsToRef(n,y,H){const o=F.zy[0];return y.subtractToRef(n,o),H._y=Math.atan2(o.x,o.z)||0,H._x=Math.atan2(Math.sqrt(o.x**2+o.z**2),o.y)||0,H._z=0,H._isDirty=!0,H}static PitchYawRollToMoveBetweenPoints(n,y){const H=W.Zero();return W.PitchYawRollToMoveBetweenPointsToRef(n,y,H)}static SlerpToRef(n,y,H,G){H=(0,B.Clamp)(H,0,1);const h=v.zy[0],k=v.zy[1];h.B(n);const i=h.length();h.normalizeFromLength(i),k.B(y);const V=k.length();k.normalizeFromLength(V);const q=W.Dot(h,k);let b,A;if(q<1-o.e){const n=Math.acos(q),y=1/Math.sin(n);b=Math.sin((1-H)*n)*y,A=Math.sin(H*n)*y}else b=1-H,A=H;return h.scaleInPlace(b),k.scaleInPlace(A),G.B(h).addInPlace(k),G.scaleInPlace((0,B.Lerp)(i,V,H)),G}static SmoothToRef(n,y,H,o,G){return W.SlerpToRef(n,y,0===o?1:H/o,G),G}static gy(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new W(n[y],n[y+1],n[y+2])}static FromFloatArray(n,y){return W.gy(n,y)}static FromArrayToRef(n,y,H){return H._x=n[y],H._y=n[y+1],H._z=n[y+2],H._isDirty=!0,H}static FromFloatArrayToRef(n,y,H){return W.FromArrayToRef(n,y,H)}static FromFloatsToRef(n,y,H,o){return o.Mi(n,y,H),o}static Zero(){return new W(0,0,0)}static One(){return new W(1,1,1)}static Up(){return new W(0,1,0)}static get UpReadOnly(){return W._UpReadOnly}static get DownReadOnly(){return W._DownReadOnly}static get RightReadOnly(){return W._RightReadOnly}static get LeftReadOnly(){return W._LeftReadOnly}static get LeftHandedForwardReadOnly(){return W._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return W._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return W._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return W._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return W._ZeroReadOnly}static get OneReadOnly(){return W._OneReadOnly}static Down(){return new W(0,-1,0)}static Forward(){return new W(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new W(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new W(1,0,0)}static Left(){return new W(-1,0,0)}static Random(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new W((0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y))}static RandomToRef(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Mi((0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y))}static TransformCoordinates(n,y){const H=W.Zero();return W.TransformCoordinatesToRef(n,y,H),H}static TransformCoordinatesToRef(n,y,H){return W.TransformCoordinatesFromFloatsToRef(n._x,n._y,n._z,y,H),H}static TransformCoordinatesFromFloatsToRef(n,y,H,o,G){const h=o.m,k=n*h[0]+y*h[4]+H*h[8]+h[12],i=n*h[1]+y*h[5]+H*h[9]+h[13],B=n*h[2]+y*h[6]+H*h[10]+h[14],V=1/(n*h[3]+y*h[7]+H*h[11]+h[15]);return G._x=k*V,G._y=i*V,G._z=B*V,G._isDirty=!0,G}static TransformNormal(n,y){const H=W.Zero();return W.TransformNormalToRef(n,y,H),H}static TransformNormalToRef(n,y,H){return this.TransformNormalFromFloatsToRef(n._x,n._y,n._z,y,H),H}static TransformNormalFromFloatsToRef(n,y,H,o,G){const h=o.m;return G._x=n*h[0]+y*h[4]+H*h[8],G._y=n*h[1]+y*h[5]+H*h[9],G._z=n*h[2]+y*h[6]+H*h[10],G._isDirty=!0,G}static CatmullRom(n,y,H,o,G){const h=G*G,k=G*h,i=.5*(2*y._x+(-n._x+H._x)*G+(2*n._x-5*y._x+4*H._x-o._x)*h+(-n._x+3*y._x-3*H._x+o._x)*k),B=.5*(2*y._y+(-n._y+H._y)*G+(2*n._y-5*y._y+4*H._y-o._y)*h+(-n._y+3*y._y-3*H._y+o._y)*k),V=.5*(2*y._z+(-n._z+H._z)*G+(2*n._z-5*y._z+4*H._z-o._z)*h+(-n._z+3*y._z-3*H._z+o._z)*k);return new W(i,B,V)}static Clamp(n,y,H){const o=new W;return W.ClampToRef(n,y,H,o),o}static ClampToRef(n,y,H,o){let G=n._x;G=G>H._x?H._x:G,G=G<y._x?y._x:G;let h=n._y;h=h>H._y?H._y:h,h=h<y._y?y._y:h;let k=n._z;return k=k>H._z?H._z:k,k=k<y._z?y._z:k,o.Mi(G,h,k),o}static CheckExtends(n,y,H){y.minimizeInPlace(n),H.maximizeInPlace(n)}static Hermite(n,y,H,o,G){const h=G*G,k=G*h,i=2*k-3*h+1,B=-2*k+3*h,V=k-2*h+G,q=k-h,b=n._x*i+H._x*B+y._x*V+o._x*q,A=n._y*i+H._y*B+y._y*V+o._y*q,U=n._z*i+H._z*B+y._z*V+o._z*q;return new W(b,A,U)}static Hermite1stDerivative(n,y,H,o,G){const h=new W;return this.Hermite1stDerivativeToRef(n,y,H,o,G,h),h}static Hermite1stDerivativeToRef(n,y,H,o,G,h){const k=G*G;return h._x=6*(k-G)*n._x+(3*k-4*G+1)*y._x+6*(-k+G)*H._x+(3*k-2*G)*o._x,h._y=6*(k-G)*n._y+(3*k-4*G+1)*y._y+6*(-k+G)*H._y+(3*k-2*G)*o._y,h._z=6*(k-G)*n._z+(3*k-4*G+1)*y._z+6*(-k+G)*H._z+(3*k-2*G)*o._z,h._isDirty=!0,h}static Lerp(n,y,H){const o=new W(0,0,0);return W.LerpToRef(n,y,H,o),o}static LerpToRef(n,y,H,o){return o._x=n._x+(y._x-n._x)*H,o._y=n._y+(y._y-n._y)*H,o._z=n._z+(y._z-n._z)*H,o._isDirty=!0,o}static Dot(n,y){return n._x*y._x+n._y*y._y+n._z*y._z}dot(n){return this._x*n._x+this._y*n._y+this._z*n._z}static Cross(n,y){const H=new W;return W.CrossToRef(n,y,H),H}static CrossToRef(n,y,H){const o=n._y*y._z-n._z*y._y,G=n._z*y._x-n._x*y._z,h=n._x*y._y-n._y*y._x;return H.Mi(o,G,h),H}static Normalize(n){const y=W.Zero();return W.NormalizeToRef(n,y),y}static NormalizeToRef(n,y){return n.normalizeToRef(y),y}static Project(n,y,H,o){const G=new W;return W.ProjectToRef(n,y,H,o,G),G}static ProjectToRef(n,y,H,o,G){var h;const k=o.width,B=o.height,V=o.x,q=o.y,b=v.Matrix[1],A=null===(h=i.c.LastCreatedEngine)||void 0===h?void 0:h.isNDCHalfZRange,U=A?1:.5,T=A?0:.5;l.FromValuesToRef(k/2,0,0,0,0,-B/2,0,0,0,0,U,0,V+k/2,B/2+q,T,1,b);const z=v.Matrix[0];return y.multiplyToRef(H,z),z.multiplyToRef(b,z),W.TransformCoordinatesToRef(n,z,G),G}static Reflect(n,y){return this.ReflectToRef(n,y,new W)}static ReflectToRef(n,y,H){const o=F.zy[0];return o.B(y).scaleInPlace(2*W.Dot(n,y)),H.B(n).kb(o)}static _UnprojectFromInvertedMatrixToRef(n,y,H){W.TransformCoordinatesToRef(n,y,H);const o=y.m,G=n._x*o[3]+n._y*o[7]+n._z*o[11]+o[15];return(0,B.WithinEpsilon)(G,1)&&H.scaleInPlace(1/G),H}static UnprojectFromTransform(n,y,H,o,G){return this.Unproject(n,y,H,o,G,l.IdentityReadOnly)}static Unproject(n,y,H,o,G,h){const k=new W;return W.UnprojectToRef(n,y,H,o,G,h,k),k}static UnprojectToRef(n,y,H,o,G,h,k){return W.UnprojectFloatsToRef(n._x,n._y,n._z,y,H,o,G,h,k),k}static UnprojectFloatsToRef(n,y,H,o,G,h,k,B,V){var q;const b=v.Matrix[0];h.multiplyToRef(k,b),b.multiplyToRef(B,b),b.invert();const A=v.zy[0];return A.x=n/o*2-1,A.y=-(y/G*2-1),null!==(q=i.c.LastCreatedEngine)&&void 0!==q&&q.isNDCHalfZRange?A.z=H:A.z=2*H-1,W._UnprojectFromInvertedMatrixToRef(A,b,V),V}static Minimize(n,y){const H=new W;return H.B(n),H.minimizeInPlace(y),H}static Maximize(n,y){const H=new W;return H.B(n),H.maximizeInPlace(y),H}static Distance(n,y){return Math.sqrt(W.DistanceSquared(n,y))}static DistanceSquared(n,y){const H=n._x-y._x,o=n._y-y._y,G=n._z-y._z;return H*H+o*o+G*G}static ProjectOnTriangleToRef(n,y,H,G,h){const k=v.zy[0],i=v.zy[1],V=v.zy[2],q=v.zy[3],b=v.zy[4];H.subtractToRef(y,k),G.subtractToRef(y,i),G.subtractToRef(H,V);const A=k.length(),U=i.length(),T=V.length();if(A<o.e||U<o.e||T<o.e)return h.B(y),W.Distance(n,y);n.subtractToRef(y,b),W.CrossToRef(k,i,q);const z=q.length();if(z<o.e)return h.B(y),W.Distance(n,y);q.normalizeFromLength(z);let Q=b.length();if(Q<o.e)return h.B(y),0;b.normalizeFromLength(Q);const l=W.Dot(q,b),F=v.zy[5],g=v.zy[6];F.B(q).scaleInPlace(-Q*l),g.B(n).addInPlace(F);const M=v.zy[4],f=v.zy[5],c=v.zy[7],p=v.zy[8];M.B(k).scaleInPlace(1/A),p.B(i).scaleInPlace(1/U),M.addInPlace(p).scaleInPlace(-1),f.B(k).scaleInPlace(-1/A),p.B(V).scaleInPlace(1/T),f.addInPlace(p).scaleInPlace(-1),c.B(V).scaleInPlace(-1/T),p.B(i).scaleInPlace(-1/U),c.addInPlace(p).scaleInPlace(-1);const E=v.zy[9];let X;E.B(g).kb(y),W.CrossToRef(M,E,p),X=W.Dot(p,q);const d=X;E.B(g).kb(H),W.CrossToRef(f,E,p),X=W.Dot(p,q);const a=X;E.B(g).kb(G),W.CrossToRef(c,E,p),X=W.Dot(p,q);const O=X,e=v.zy[10];let w,j;d>0&&a<0?(e.B(k),w=y,j=H):a>0&&O<0?(e.B(V),w=H,j=G):(e.B(i).scaleInPlace(-1),w=G,j=y);const I=v.zy[9],R=v.zy[4];w.subtractToRef(g,p),j.subtractToRef(g,I),W.CrossToRef(p,I,R);if(!(W.Dot(R,q)<0))return h.B(g),Math.abs(Q*l);const C=v.zy[5];W.CrossToRef(e,R,C),C.normalize();const S=v.zy[9];S.B(w).kb(g);const N=S.length();if(N<o.e)return h.B(w),W.Distance(n,w);S.normalizeFromLength(N);const r=W.Dot(C,S),K=v.zy[7];K.B(g).addInPlace(C.scaleInPlace(N*r)),p.B(K).kb(w),Q=e.length(),e.normalizeFromLength(Q);let Y=W.Dot(p,e)/Math.max(Q,o.e);return Y=(0,B.Clamp)(Y,0,1),K.B(w).addInPlace(e.scaleInPlace(Y*Q)),h.B(K),W.Distance(n,K)}static Center(n,y){return W.CenterToRef(n,y,W.Zero())}static CenterToRef(n,y,H){return H.Mi((n._x+y._x)/2,(n._y+y._y)/2,(n._z+y._z)/2)}static RotationFromAxis(n,y,H){const o=new W;return W.RotationFromAxisToRef(n,y,H,o),o}static RotationFromAxisToRef(n,y,H,o){const G=v.Quaternion[0];return Q.RotationQuaternionFromAxisToRef(n,y,H,G),G.toEulerAnglesToRef(o),o}}W._V8PerformanceHack=new W(.5,.5,.5),W._UpReadOnly=W.Up(),W._DownReadOnly=W.Down(),W._LeftHandedForwardReadOnly=W.Forward(!1),W._RightHandedForwardReadOnly=W.Forward(!0),W._LeftHandedBackwardReadOnly=W.Backward(!1),W._RightHandedBackwardReadOnly=W.Backward(!0),W._RightReadOnly=W.Right(),W._LeftReadOnly=W.Left(),W._ZeroReadOnly=W.Zero(),W._OneReadOnly=W.One(),Object.defineProperties(W.prototype,{dimension:{value:[3]},rank:{value:1}});class z{get x(){return this._x}set x(n){this._x=n,this._isDirty=!0}get y(){return this._y}set y(n){this._y=n,this._isDirty=!0}get z(){return this._z}set z(n){this._z=n,this._isDirty=!0}get w(){return this._w}set w(n){this._w=n,this._isDirty=!0}constructor(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=n,this._y=y,this._z=H,this._w=o}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let n=U(this._x);return n=397*n^U(this._y),n=397*n^U(this._z),n=397*n^U(this._w),n}Ui(){return[this._x,this._y,this._z,this._w]}toArray(n,y){return void 0===y&&(y=0),n[y]=this._x,n[y+1]=this._y,n[y+2]=this._z,n[y+3]=this._w,this}vH(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z.FromArrayToRef(n,y,this),this}addInPlace(n){return this.x+=n._x,this.y+=n._y,this.z+=n._z,this.w+=n._w,this}addInPlaceFromFloats(n,y,H,o){return this.x+=n,this.y+=y,this.z+=H,this.w+=o,this}add(n){return new z(this._x+n.x,this._y+n.y,this._z+n.z,this._w+n.w)}addToRef(n,y){return y.x=this._x+n.x,y.y=this._y+n.y,y.z=this._z+n.z,y.w=this._w+n.w,y}kb(n){return this.x-=n.x,this.y-=n.y,this.z-=n.z,this.w-=n.w,this}Qy(n){return new z(this._x-n.x,this._y-n.y,this._z-n.z,this._w-n.w)}subtractToRef(n,y){return y.x=this._x-n.x,y.y=this._y-n.y,y.z=this._z-n.z,y.w=this._w-n.w,y}subtractFromFloats(n,y,H,o){return new z(this._x-n,this._y-y,this._z-H,this._w-o)}subtractFromFloatsToRef(n,y,H,o,G){return G.x=this._x-n,G.y=this._y-y,G.z=this._z-H,G.w=this._w-o,G}negate(){return new z(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(n){return n.x=-this._x,n.y=-this._y,n.z=-this._z,n.w=-this._w,n}scaleInPlace(n){return this.x*=n,this.y*=n,this.z*=n,this.w*=n,this}scale(n){return new z(this._x*n,this._y*n,this._z*n,this._w*n)}scaleToRef(n,y){return y.x=this._x*n,y.y=this._y*n,y.z=this._z*n,y.w=this._w*n,y}scaleAndAddToRef(n,y){return y.x+=this._x*n,y.y+=this._y*n,y.z+=this._z*n,y.w+=this._w*n,y}equals(n){return n&&this._x===n.x&&this._y===n.y&&this._z===n.z&&this._w===n.w}equalsWithEpsilon(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.e;return n&&(0,B.WithinEpsilon)(this._x,n.x,y)&&(0,B.WithinEpsilon)(this._y,n.y,y)&&(0,B.WithinEpsilon)(this._z,n.z,y)&&(0,B.WithinEpsilon)(this._w,n.w,y)}equalsToFloats(n,y,H,o){return this._x===n&&this._y===y&&this._z===H&&this._w===o}multiplyInPlace(n){return this.x*=n.x,this.y*=n.y,this.z*=n.z,this.w*=n.w,this}multiply(n){return new z(this._x*n.x,this._y*n.y,this._z*n.z,this._w*n.w)}multiplyToRef(n,y){return y.x=this._x*n.x,y.y=this._y*n.y,y.z=this._z*n.z,y.w=this._w*n.w,y}multiplyByFloats(n,y,H,o){return new z(this._x*n,this._y*y,this._z*H,this._w*o)}divide(n){return new z(this._x/n.x,this._y/n.y,this._z/n.z,this._w/n.w)}divideToRef(n,y){return y.x=this._x/n.x,y.y=this._y/n.y,y.z=this._z/n.z,y.w=this._w/n.w,y}divideInPlace(n){return this.divideToRef(n,this)}minimizeInPlace(n){return n.x<this._x&&(this.x=n.x),n.y<this._y&&(this.y=n.y),n.z<this._z&&(this.z=n.z),n.w<this._w&&(this.w=n.w),this}maximizeInPlace(n){return n.x>this._x&&(this.x=n.x),n.y>this._y&&(this.y=n.y),n.z>this._z&&(this.z=n.z),n.w>this._w&&(this.w=n.w),this}minimizeInPlaceFromFloats(n,y,H,o){return this.x=Math.min(n,this._x),this.y=Math.min(y,this._y),this.z=Math.min(H,this._z),this.w=Math.min(o,this._w),this}maximizeInPlaceFromFloats(n,y,H,o){return this.x=Math.max(n,this._x),this.y=Math.max(y,this._y),this.z=Math.max(H,this._z),this.w=Math.max(o,this._w),this}floorToRef(n){return n.x=Math.floor(this._x),n.y=Math.floor(this._y),n.z=Math.floor(this._z),n.w=Math.floor(this._w),n}floor(){return new z(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(n){return n.x=this._x-Math.floor(this._x),n.y=this._y-Math.floor(this._y),n.z=this._z-Math.floor(this._z),n.w=this._w-Math.floor(this._w),n}fract(){return new z(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(n){return 0===n||1===n?this:this.scaleInPlace(1/n)}normalizeToNew(){return this.normalizeToRef(new z)}normalizeToRef(n){const y=this.length();return 0===y||1===y?(n.x=this._x,n.y=this._y,n.z=this._z,n.w=this._w,n):this.scaleToRef(1/y,n)}toVector3(){return new W(this._x,this._y,this._z)}clone(){return new z(this._x,this._y,this._z,this._w)}B(n){return this.x=n.x,this.y=n.y,this.z=n.z,this.w=n.w,this}Mi(n,y,H,o){return this.x=n,this.y=y,this.z=H,this.w=o,this}set(n,y,H,o){return this.Mi(n,y,H,o)}ci(n){return this.x=this.y=this.z=this.w=n,this}dot(n){return this._x*n.x+this._y*n.y+this._z*n.z+this._w*n.w}static gy(n,y){return y||(y=0),new z(n[y],n[y+1],n[y+2],n[y+3])}static FromArrayToRef(n,y,H){return H.x=n[y],H.y=n[y+1],H.z=n[y+2],H.w=n[y+3],H}static FromFloatArrayToRef(n,y,H){return z.FromArrayToRef(n,y,H),H}static FromFloatsToRef(n,y,H,o,G){return G.x=n,G.y=y,G.z=H,G.w=o,G}static Zero(){return new z(0,0,0,0)}static One(){return new z(1,1,1,1)}static Random(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new z((0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y))}static RandomToRef(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0;return H.x=(0,B.RandomRange)(n,y),H.y=(0,B.RandomRange)(n,y),H.z=(0,B.RandomRange)(n,y),H.w=(0,B.RandomRange)(n,y),H}static Clamp(n,y,H){return z.ClampToRef(n,y,H,new z)}static ClampToRef(n,y,H,o){return o.x=(0,B.Clamp)(n.x,y.x,H.x),o.y=(0,B.Clamp)(n.y,y.y,H.y),o.z=(0,B.Clamp)(n.z,y.z,H.z),o.w=(0,B.Clamp)(n.w,y.w,H.w),o}static CheckExtends(n,y,H){y.minimizeInPlace(n),H.maximizeInPlace(n)}static get ZeroReadOnly(){return z._ZeroReadOnly}static Normalize(n){return z.NormalizeToRef(n,new z)}static NormalizeToRef(n,y){return n.normalizeToRef(y),y}static Minimize(n,y){const H=new z;return H.B(n),H.minimizeInPlace(y),H}static Maximize(n,y){const H=new z;return H.B(n),H.maximizeInPlace(y),H}static Distance(n,y){return Math.sqrt(z.DistanceSquared(n,y))}static DistanceSquared(n,y){const H=n.x-y.x,o=n.y-y.y,G=n.z-y.z,h=n.w-y.w;return H*H+o*o+G*G+h*h}static Center(n,y){return z.CenterToRef(n,y,new z)}static CenterToRef(n,y,H){return H.x=(n.x+y.x)/2,H.y=(n.y+y.y)/2,H.z=(n.z+y.z)/2,H.w=(n.w+y.w)/2,H}static TransformCoordinates(n,y){return z.TransformCoordinatesToRef(n,y,new z)}static TransformCoordinatesToRef(n,y,H){return z.TransformCoordinatesFromFloatsToRef(n._x,n._y,n._z,y,H),H}static TransformCoordinatesFromFloatsToRef(n,y,H,o,G){const h=o.m,k=n*h[0]+y*h[4]+H*h[8]+h[12],i=n*h[1]+y*h[5]+H*h[9]+h[13],B=n*h[2]+y*h[6]+H*h[10]+h[14],V=n*h[3]+y*h[7]+H*h[11]+h[15];return G.x=k,G.y=i,G.z=B,G.w=V,G}static TransformNormal(n,y){return z.TransformNormalToRef(n,y,new z)}static TransformNormalToRef(n,y,H){const o=y.m,G=n.x*o[0]+n.y*o[4]+n.z*o[8],h=n.x*o[1]+n.y*o[5]+n.z*o[9],k=n.x*o[2]+n.y*o[6]+n.z*o[10];return H.x=G,H.y=h,H.z=k,H.w=n.w,H}static TransformNormalFromFloatsToRef(n,y,H,o,G,h){const k=G.m;return h.x=n*k[0]+y*k[4]+H*k[8],h.y=n*k[1]+y*k[5]+H*k[9],h.z=n*k[2]+y*k[6]+H*k[10],h.w=o,h}static FromVector3(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new z(n._x,n._y,n._z,y)}static Dot(n,y){return n.x*y.x+n.y*y.y+n.z*y.z+n.w*y.w}}z._V8PerformanceHack=new z(.5,.5,.5,.5),z._ZeroReadOnly=z.Zero(),Object.defineProperties(z.prototype,{dimension:{value:[4]},rank:{value:1}});class Q{get x(){return this._x}set x(n){this._x=n,this._isDirty=!0}get y(){return this._y}set y(n){this._y=n,this._isDirty=!0}get z(){return this._z}set z(n){this._z=n,this._isDirty=!0}get w(){return this._w}set w(n){this._w=n,this._isDirty=!0}constructor(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=n,this._y=y,this._z=H,this._w=o}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let n=U(this._x);return n=397*n^U(this._y),n=397*n^U(this._z),n=397*n^U(this._w),n}Ui(){return[this._x,this._y,this._z,this._w]}toArray(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[y]=this._x,n[y+1]=this._y,n[y+2]=this._z,n[y+3]=this._w,this}vH(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(n,y,this)}equals(n){return n&&this._x===n._x&&this._y===n._y&&this._z===n._z&&this._w===n._w}equalsWithEpsilon(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.e;return n&&(0,B.WithinEpsilon)(this._x,n._x,y)&&(0,B.WithinEpsilon)(this._y,n._y,y)&&(0,B.WithinEpsilon)(this._z,n._z,y)&&(0,B.WithinEpsilon)(this._w,n._w,y)}isApprox(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.e;return n&&((0,B.WithinEpsilon)(this._x,n._x,y)&&(0,B.WithinEpsilon)(this._y,n._y,y)&&(0,B.WithinEpsilon)(this._z,n._z,y)&&(0,B.WithinEpsilon)(this._w,n._w,y)||(0,B.WithinEpsilon)(this._x,-n._x,y)&&(0,B.WithinEpsilon)(this._y,-n._y,y)&&(0,B.WithinEpsilon)(this._z,-n._z,y)&&(0,B.WithinEpsilon)(this._w,-n._w,y))}clone(){return new Q(this._x,this._y,this._z,this._w)}B(n){return this._x=n._x,this._y=n._y,this._z=n._z,this._w=n._w,this._isDirty=!0,this}Mi(n,y,H,o){return this._x=n,this._y=y,this._z=H,this._w=o,this._isDirty=!0,this}set(n,y,H,o){return this.Mi(n,y,H,o)}ci(n){return this.Mi(n,n,n,n)}add(n){return new Q(this._x+n._x,this._y+n._y,this._z+n._z,this._w+n._w)}addInPlace(n){return this._x+=n._x,this._y+=n._y,this._z+=n._z,this._w+=n._w,this._isDirty=!0,this}addToRef(n,y){return y._x=this._x+n._x,y._y=this._y+n._y,y._z=this._z+n._z,y._w=this._w+n._w,y._isDirty=!0,y}addInPlaceFromFloats(n,y,H,o){return this._x+=n,this._y+=y,this._z+=H,this._w+=o,this._isDirty=!0,this}subtractToRef(n,y){return y._x=this._x-n._x,y._y=this._y-n._y,y._z=this._z-n._z,y._w=this._w-n._w,y._isDirty=!0,y}subtractFromFloats(n,y,H,o){return this.subtractFromFloatsToRef(n,y,H,o,new Q)}subtractFromFloatsToRef(n,y,H,o,G){return G._x=this._x-n,G._y=this._y-y,G._z=this._z-H,G._w=this._w-o,G._isDirty=!0,G}Qy(n){return new Q(this._x-n._x,this._y-n._y,this._z-n._z,this._w-n._w)}kb(n){return this._x-=n._x,this._y-=n._y,this._z-=n._z,this._w-=n._w,this._isDirty=!0,this}scale(n){return new Q(this._x*n,this._y*n,this._z*n,this._w*n)}scaleToRef(n,y){return y._x=this._x*n,y._y=this._y*n,y._z=this._z*n,y._w=this._w*n,y._isDirty=!0,y}scaleInPlace(n){return this._x*=n,this._y*=n,this._z*=n,this._w*=n,this._isDirty=!0,this}scaleAndAddToRef(n,y){return y._x+=this._x*n,y._y+=this._y*n,y._z+=this._z*n,y._w+=this._w*n,y._isDirty=!0,y}multiply(n){const y=new Q(0,0,0,1);return this.multiplyToRef(n,y),y}multiplyToRef(n,y){const H=this._x*n._w+this._y*n._z-this._z*n._y+this._w*n._x,o=-this._x*n._z+this._y*n._w+this._z*n._x+this._w*n._y,G=this._x*n._y-this._y*n._x+this._z*n._w+this._w*n._z,h=-this._x*n._x-this._y*n._y-this._z*n._z+this._w*n._w;return y.Mi(H,o,G,h),y}multiplyInPlace(n){return this.multiplyToRef(n,this)}multiplyByFloats(n,y,H,o){return this._x*=n,this._y*=y,this._z*=H,this._w*=o,this._isDirty=!0,this}divide(n){throw new ReferenceError("Can not divide a quaternion")}divideToRef(n,y){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(n){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new Q)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(n){return n._x=-this._x,n._y=-this._y,n._z=-this._z,n._w=-this._w,n._isDirty=!0,n}equalsToFloats(n,y,H,o){return this._x===n&&this._y===y&&this._z===H&&this._w===o}floorToRef(n){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(n){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(n){return n.Mi(-this._x,-this._y,-this._z,this._w),n}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new Q(-this._x,-this._y,-this._z,this._w)}invert(){const n=this.conjugate(),y=this.lengthSquared();return 0==y||1==y||n.scaleInPlace(1/y),n}invertInPlace(){this.conjugateInPlace();const n=this.lengthSquared();return 0==n||1==n||this.scaleInPlace(1/n),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(n){return 0===n||1===n?this:this.scaleInPlace(1/n)}normalizeToNew(){const n=new Q(0,0,0,1);return this.normalizeToRef(n),n}normalizeToRef(n){const y=this.length();return 0===y||1===y?n.Mi(this._x,this._y,this._z,this._w):this.scaleToRef(1/y,n)}toEulerAngles(){const n=W.Zero();return this.toEulerAnglesToRef(n),n}toEulerAnglesToRef(n){const y=this._z,H=this._x,o=this._y,G=this._w,h=o*y-H*G,k=.4999999;if(h<-k)n._y=2*Math.atan2(o,G),n._x=Math.PI/2,n._z=0,n._isDirty=!0;else if(h>k)n._y=2*Math.atan2(o,G),n._x=-Math.PI/2,n._z=0,n._isDirty=!0;else{const k=G*G,i=y*y,B=H*H,V=o*o;n._z=Math.atan2(2*(H*o+y*G),-i-B+V+k),n._x=Math.asin(-2*h),n._y=Math.atan2(2*(y*H+o*G),i-B-V+k),n._isDirty=!0}return n}toAlphaBetaGammaToRef(n){const y=this._z,H=this._x,o=this._y,G=this._w,h=Math.sqrt(H*H+o*o),k=Math.sqrt(y*y+G*G),i=2*Math.atan2(h,k),B=2*Math.atan2(y,G),V=2*Math.atan2(o,H),q=(B+V)/2,b=(B-V)/2;return n.set(b,i,q),n}toRotationMatrix(n){return l.FromQuaternionToRef(this,n),n}fromRotationMatrix(n){return Q.FromRotationMatrixToRef(n,this),this}dot(n){return this._x*n._x+this._y*n._y+this._z*n._z+this._w*n._w}toAxisAngle(){const n=W.Zero();return{axis:n,angle:this.toAxisAngleToRef(n)}}toAxisAngleToRef(n){let y=0;const H=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),o=this._w;return H>0?(y=2*Math.atan2(H,o),n.set(this._x/H,this._y/H,this._z/H)):(y=0,n.set(1,0,0)),y}static FromRotationMatrix(n){const y=new Q;return Q.FromRotationMatrixToRef(n,y),y}static FromRotationMatrixToRef(n,y){const H=n.m,o=H[0],G=H[4],h=H[8],k=H[1],i=H[5],B=H[9],V=H[2],q=H[6],b=H[10],A=o+i+b;let U;return A>0?(U=.5/Math.sqrt(A+1),y._w=.25/U,y._x=(q-B)*U,y._y=(h-V)*U,y._z=(k-G)*U,y._isDirty=!0):o>i&&o>b?(U=2*Math.sqrt(1+o-i-b),y._w=(q-B)/U,y._x=.25*U,y._y=(G+k)/U,y._z=(h+V)/U,y._isDirty=!0):i>b?(U=2*Math.sqrt(1+i-o-b),y._w=(h-V)/U,y._x=(G+k)/U,y._y=.25*U,y._z=(B+q)/U,y._isDirty=!0):(U=2*Math.sqrt(1+b-o-i),y._w=(k-G)/U,y._x=(h+V)/U,y._y=(B+q)/U,y._z=.25*U,y._isDirty=!0),y}static Dot(n,y){return n._x*y._x+n._y*y._y+n._z*y._z+n._w*y._w}static AreClose(n,y){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const o=Q.Dot(n,y);return 1-o*o<=H}static SmoothToRef(n,y,H,o,G){let h=0===o?1:H/o;return h=(0,B.Clamp)(h,0,1),Q.SlerpToRef(n,y,h,G),G}static Zero(){return new Q(0,0,0,0)}static Inverse(n){return new Q(-n._x,-n._y,-n._z,n._w)}static InverseToRef(n,y){return y.set(-n._x,-n._y,-n._z,n._w),y}static Identity(){return new Q(0,0,0,1)}static IsIdentity(n){return n&&0===n._x&&0===n._y&&0===n._z&&1===n._w}static RotationAxis(n,y){return Q.RotationAxisToRef(n,y,new Q)}static RotationAxisToRef(n,y,H){H._w=Math.cos(y/2);const o=Math.sin(y/2)/n.length();return H._x=n._x*o,H._y=n._y*o,H._z=n._z*o,H._isDirty=!0,H}static gy(n,y){return y||(y=0),new Q(n[y],n[y+1],n[y+2],n[y+3])}static FromArrayToRef(n,y,H){return H._x=n[y],H._y=n[y+1],H._z=n[y+2],H._w=n[y+3],H._isDirty=!0,H}static FromFloatsToRef(n,y,H,o,G){return G.Mi(n,y,H,o),G}static FromEulerAngles(n,y,H){const o=new Q;return Q.RotationYawPitchRollToRef(y,n,H,o),o}static FromEulerAnglesToRef(n,y,H,o){return Q.RotationYawPitchRollToRef(y,n,H,o),o}static FromEulerVector(n){const y=new Q;return Q.RotationYawPitchRollToRef(n._y,n._x,n._z,y),y}static FromEulerVectorToRef(n,y){return Q.RotationYawPitchRollToRef(n._y,n._x,n._z,y),y}static FromUnitVectorsToRef(n,y,H){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:o.e;const h=W.Dot(n,y)+1;return h<G?Math.abs(n.x)>Math.abs(n.z)?H.set(-n.y,n.x,0,0):H.set(0,-n.z,n.y,0):(W.CrossToRef(n,y,F.zy[0]),H.set(F.zy[0].x,F.zy[0].y,F.zy[0].z,h)),H.normalize()}static RotationYawPitchRoll(n,y,H){const o=new Q;return Q.RotationYawPitchRollToRef(n,y,H,o),o}static RotationYawPitchRollToRef(n,y,H,o){const G=.5*H,h=.5*y,k=.5*n,i=Math.sin(G),B=Math.cos(G),V=Math.sin(h),q=Math.cos(h),b=Math.sin(k),A=Math.cos(k);return o._x=A*V*B+b*q*i,o._y=b*q*B-A*V*i,o._z=A*q*i-b*V*B,o._w=A*q*B+b*V*i,o._isDirty=!0,o}static RotationAlphaBetaGamma(n,y,H){const o=new Q;return Q.RotationAlphaBetaGammaToRef(n,y,H,o),o}static RotationAlphaBetaGammaToRef(n,y,H,o){const G=.5*(H+n),h=.5*(H-n),k=.5*y;return o._x=Math.cos(h)*Math.sin(k),o._y=Math.sin(h)*Math.sin(k),o._z=Math.sin(G)*Math.cos(k),o._w=Math.cos(G)*Math.cos(k),o._isDirty=!0,o}static RotationQuaternionFromAxis(n,y,H){const o=new Q(0,0,0,0);return Q.RotationQuaternionFromAxisToRef(n,y,H,o),o}static RotationQuaternionFromAxisToRef(n,y,H,o){const G=v.Matrix[0];return n=n.normalizeToRef(v.zy[0]),y=y.normalizeToRef(v.zy[1]),H=H.normalizeToRef(v.zy[2]),l.FromXYZAxesToRef(n,y,H,G),Q.FromRotationMatrixToRef(G,o),o}static FromLookDirectionLH(n,y){const H=new Q;return Q.FromLookDirectionLHToRef(n,y,H),H}static FromLookDirectionLHToRef(n,y,H){const o=v.Matrix[0];return l.LookDirectionLHToRef(n,y,o),Q.FromRotationMatrixToRef(o,H),H}static FromLookDirectionRH(n,y){const H=new Q;return Q.FromLookDirectionRHToRef(n,y,H),H}static FromLookDirectionRHToRef(n,y,H){const o=v.Matrix[0];return l.LookDirectionRHToRef(n,y,o),Q.FromRotationMatrixToRef(o,H)}static Slerp(n,y,H){const o=Q.Identity();return Q.SlerpToRef(n,y,H,o),o}static SlerpToRef(n,y,H,o){let G,h,k=n._x*y._x+n._y*y._y+n._z*y._z+n._w*y._w,i=!1;if(k<0&&(i=!0,k=-k),k>.999999)h=1-H,G=i?-H:H;else{const n=Math.acos(k),y=1/Math.sin(n);h=Math.sin((1-H)*n)*y,G=i?-Math.sin(H*n)*y:Math.sin(H*n)*y}return o._x=h*n._x+G*y._x,o._y=h*n._y+G*y._y,o._z=h*n._z+G*y._z,o._w=h*n._w+G*y._w,o._isDirty=!0,o}static Hermite(n,y,H,o,G){const h=G*G,k=G*h,i=2*k-3*h+1,B=-2*k+3*h,V=k-2*h+G,q=k-h,b=n._x*i+H._x*B+y._x*V+o._x*q,A=n._y*i+H._y*B+y._y*V+o._y*q,U=n._z*i+H._z*B+y._z*V+o._z*q,T=n._w*i+H._w*B+y._w*V+o._w*q;return new Q(b,A,U,T)}static Hermite1stDerivative(n,y,H,o,G){const h=new Q;return this.Hermite1stDerivativeToRef(n,y,H,o,G,h),h}static Hermite1stDerivativeToRef(n,y,H,o,G,h){const k=G*G;return h._x=6*(k-G)*n._x+(3*k-4*G+1)*y._x+6*(-k+G)*H._x+(3*k-2*G)*o._x,h._y=6*(k-G)*n._y+(3*k-4*G+1)*y._y+6*(-k+G)*H._y+(3*k-2*G)*o._y,h._z=6*(k-G)*n._z+(3*k-4*G+1)*y._z+6*(-k+G)*H._z+(3*k-2*G)*o._z,h._w=6*(k-G)*n._w+(3*k-4*G+1)*y._w+6*(-k+G)*H._w+(3*k-2*G)*o._w,h._isDirty=!0,h}static Normalize(n){const y=Q.Zero();return Q.NormalizeToRef(n,y),y}static NormalizeToRef(n,y){return n.normalizeToRef(y),y}static Clamp(n,y,H){const o=new Q;return Q.ClampToRef(n,y,H,o),o}static ClampToRef(n,y,H,o){return o.Mi((0,B.Clamp)(n.x,y.x,H.x),(0,B.Clamp)(n.y,y.y,H.y),(0,B.Clamp)(n.z,y.z,H.z),(0,B.Clamp)(n.w,y.w,H.w))}static Random(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Q((0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y))}static RandomToRef(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Mi((0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y),(0,B.RandomRange)(n,y))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(n,y){return Math.sqrt(Q.DistanceSquared(n,y))}static DistanceSquared(n,y){const H=n.x-y.x,o=n.y-y.y,G=n.z-y.z,h=n.w-y.w;return H*H+o*o+G*G+h*h}static Center(n,y){return Q.CenterToRef(n,y,Q.Zero())}static CenterToRef(n,y,H){return H.Mi((n.x+y.x)/2,(n.y+y.y)/2,(n.z+y.z)/2,(n.w+y.w)/2)}}Q._V8PerformanceHack=new Q(.5,.5,.5,.5),Object.defineProperties(Q.prototype,{dimension:{value:[4]},rank:{value:1}});class l{static get Use64Bits(){return k.b.MatrixUse64Bits}get m(){return this.jh}markAsUpdated(){this.updateFlag=V._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(n){let y=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=n,this._isIdentity3x2=n||H,this._isIdentityDirty=!this._isIdentity&&y,this._isIdentity3x2Dirty=!this._isIdentity3x2&&o}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,k.b.MatrixTrackPrecisionChange&&k.b.MatrixTrackedMatrices.push(this),this.jh=new k.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const n=this.jh;this._isIdentity=1===n[0]&&0===n[1]&&0===n[2]&&0===n[3]&&0===n[4]&&1===n[5]&&0===n[6]&&0===n[7]&&0===n[8]&&0===n[9]&&1===n[10]&&0===n[11]&&0===n[12]&&0===n[13]&&0===n[14]&&1===n[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.jh[0]||1!==this.jh[5]||1!==this.jh[15]||0!==this.jh[1]||0!==this.jh[2]||0!==this.jh[3]||0!==this.jh[4]||0!==this.jh[6]||0!==this.jh[7]||0!==this.jh[8]||0!==this.jh[9]||0!==this.jh[10]||0!==this.jh[11]||0!==this.jh[12]||0!==this.jh[13]||0!==this.jh[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const n=this.jh,y=n[0],H=n[1],o=n[2],G=n[3],h=n[4],k=n[5],i=n[6],B=n[7],V=n[8],q=n[9],b=n[10],A=n[11],U=n[12],T=n[13],W=n[14],z=n[15],Q=b*z-W*A,l=q*z-T*A,v=q*W-T*b,F=V*z-U*A,g=V*W-b*U,M=V*T-U*q;return y*+(k*Q-i*l+B*v)+H*-(h*Q-i*F+B*g)+o*+(h*l-k*F+B*M)+G*-(h*v-k*g+i*M)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!n)return this.jh;const H=this.jh;for(let o=0;o<16;o++)n[y+o]=H[o];return this}Ui(){return this.jh}vH(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(n,y,this)}Mi(){for(var n=arguments.length,y=new Array(n),H=0;H<n;H++)y[H]=arguments[H];return l.FromArrayToRef(y,0,this)}set(){const n=this.jh;for(let y=0;y<16;y++)n[y]=y<0||arguments.length<=y?void 0:arguments[y];return this.markAsUpdated(),this}ci(n){const y=this.jh;for(let H=0;H<16;H++)y[H]=n;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return l.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(n){const y=new l;return this.addToRef(n,y),y}addToRef(n,y){const H=this.jh,o=y.jh,G=n.m;for(let h=0;h<16;h++)o[h]=H[h]+G[h];return y.markAsUpdated(),y}addToSelf(n){const y=this.jh,H=n.m;return y[0]+=H[0],y[1]+=H[1],y[2]+=H[2],y[3]+=H[3],y[4]+=H[4],y[5]+=H[5],y[6]+=H[6],y[7]+=H[7],y[8]+=H[8],y[9]+=H[9],y[10]+=H[10],y[11]+=H[11],y[12]+=H[12],y[13]+=H[13],y[14]+=H[14],y[15]+=H[15],this.markAsUpdated(),this}addInPlace(n){const y=this.jh,H=n.m;for(let o=0;o<16;o++)y[o]+=H[o];return this.markAsUpdated(),this}addInPlaceFromFloats(){const n=this.jh;for(let y=0;y<16;y++)n[y]+=y<0||arguments.length<=y?void 0:arguments[y];return this.markAsUpdated(),this}Qy(n){const y=this.jh,H=n.m;for(let o=0;o<16;o++)y[o]-=H[o];return this.markAsUpdated(),this}subtractToRef(n,y){const H=this.jh,o=n.m,G=y.jh;for(let h=0;h<16;h++)G[h]=H[h]-o[h];return y.markAsUpdated(),y}kb(n){const y=this.jh,H=n.m;for(let o=0;o<16;o++)y[o]-=H[o];return this.markAsUpdated(),this}subtractFromFloats(){for(var n=arguments.length,y=new Array(n),H=0;H<n;H++)y[H]=arguments[H];return this.subtractFromFloatsToRef(...y,new l)}subtractFromFloatsToRef(){for(var n=arguments.length,y=new Array(n),H=0;H<n;H++)y[H]=arguments[H];const o=y.pop(),G=this.jh,h=o.jh,k=y;for(let i=0;i<16;i++)h[i]=G[i]-k[i];return o.markAsUpdated(),o}invertToRef(n){return!0===this._isIdentity?(l.IdentityToRef(n),n):(A(this,n.Ui())?n.markAsUpdated():n.B(this),n)}addAtIndex(n,y){return this.jh[n]+=y,this.markAsUpdated(),this}multiplyAtIndex(n,y){return this.jh[n]*=y,this.markAsUpdated(),this}setTranslationFromFloats(n,y,H){return this.jh[12]=n,this.jh[13]=y,this.jh[14]=H,this.markAsUpdated(),this}addTranslationFromFloats(n,y,H){return this.jh[12]+=n,this.jh[13]+=y,this.jh[14]+=H,this.markAsUpdated(),this}setTranslation(n){return this.setTranslationFromFloats(n._x,n._y,n._z)}getTranslation(){return new W(this.jh[12],this.jh[13],this.jh[14])}getTranslationToRef(n){return n.x=this.jh[12],n.y=this.jh[13],n.z=this.jh[14],n}removeRotationAndScaling(){const n=this.m;return l.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,n[12],n[13],n[14],n[15],this),this._updateIdentityStatus(0===n[12]&&0===n[13]&&0===n[14]&&1===n[15]),this}B(n){n.copyToArray(this.jh);const y=n;return this.updateFlag=y.updateFlag,this._updateIdentityStatus(y._isIdentity,y._isIdentityDirty,y._isIdentity3x2,y._isIdentity3x2Dirty),this}copyToArray(n){return b(this,n,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(n){const y=new l;return this.multiplyToRef(n,y),y}multiplyInPlace(n){const y=this.jh,H=n.m;for(let o=0;o<16;o++)y[o]*=H[o];return this.markAsUpdated(),this}multiplyByFloats(){const n=this.jh;for(let y=0;y<16;y++)n[y]*=y<0||arguments.length<=y?void 0:arguments[y];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var n=arguments.length,y=new Array(n),H=0;H<n;H++)y[H]=arguments[H];const o=y.pop(),G=this.jh,h=o.jh,k=y;for(let i=0;i<16;i++)h[i]=G[i]*k[i];return o.markAsUpdated(),o}multiplyToRef(n,y){return this._isIdentity?(y.B(n),y):n._isIdentity?(y.B(this),y):(this.multiplyToArray(n,y.jh,0),y.markAsUpdated(),y)}multiplyToArray(n,y,H){return q(this,n,y,H),this}divide(n){return this.divideToRef(n,new l)}divideToRef(n,y){const H=this.jh,o=n.m,G=y.jh;for(let h=0;h<16;h++)G[h]=H[h]/o[h];return y.markAsUpdated(),y}divideInPlace(n){const y=this.jh,H=n.m;for(let o=0;o<16;o++)y[o]/=H[o];return this.markAsUpdated(),this}minimizeInPlace(n){const y=this.jh,H=n.m;for(let o=0;o<16;o++)y[o]=Math.min(y[o],H[o]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const n=this.jh;for(let y=0;y<16;y++)n[y]=Math.min(n[y],y<0||arguments.length<=y?void 0:arguments[y]);return this.markAsUpdated(),this}maximizeInPlace(n){const y=this.jh,H=n.m;for(let o=0;o<16;o++)y[o]=Math.min(y[o],H[o]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const n=this.jh;for(let y=0;y<16;y++)n[y]=Math.min(n[y],y<0||arguments.length<=y?void 0:arguments[y]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new l)}negateInPlace(){const n=this.jh;for(let y=0;y<16;y++)n[y]=-n[y];return this.markAsUpdated(),this}negateToRef(n){const y=this.jh,H=n.jh;for(let o=0;o<16;o++)H[o]=-y[o];return n.markAsUpdated(),n}equals(n){const y=n;if(!y)return!1;if((this._isIdentity||y._isIdentity)&&!this._isIdentityDirty&&!y._isIdentityDirty)return this._isIdentity&&y._isIdentity;const H=this.m,o=y.m;return H[0]===o[0]&&H[1]===o[1]&&H[2]===o[2]&&H[3]===o[3]&&H[4]===o[4]&&H[5]===o[5]&&H[6]===o[6]&&H[7]===o[7]&&H[8]===o[8]&&H[9]===o[9]&&H[10]===o[10]&&H[11]===o[11]&&H[12]===o[12]&&H[13]===o[13]&&H[14]===o[14]&&H[15]===o[15]}equalsWithEpsilon(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=this.jh,o=n.m;for(let G=0;G<16;G++)if(!(0,B.WithinEpsilon)(H[G],o[G],y))return!1;return!0}equalsToFloats(){const n=this.jh;for(let y=0;y<16;y++)if(n[y]!=(y<0||arguments.length<=y?void 0:arguments[y]))return!1;return!0}floor(){return this.floorToRef(new l)}floorToRef(n){const y=this.jh,H=n.jh;for(let o=0;o<16;o++)H[o]=Math.floor(y[o]);return n.markAsUpdated(),n}fract(){return this.fractToRef(new l)}fractToRef(n){const y=this.jh,H=n.jh;for(let o=0;o<16;o++)H[o]=y[o]-Math.floor(y[o]);return n.markAsUpdated(),n}clone(){const n=new l;return n.B(this),n}getClassName(){return"Matrix"}getHashCode(){let n=U(this.jh[0]);for(let y=1;y<16;y++)n=397*n^U(this.jh[y]);return n}decomposeToTransformNode(n){return n.rotationQuaternion=n.rotationQuaternion||new Q,this.decompose(n.fi,n.rotationQuaternion,n.position)}decompose(n,y,H,o){let G=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return H&&H.ci(0),n&&n.ci(1),y&&y.Mi(0,0,0,1),!0;const h=this.jh;if(H&&H.Mi(h[12],h[13],h[14]),(n=n||v.zy[0]).x=Math.sqrt(h[0]*h[0]+h[1]*h[1]+h[2]*h[2]),n.y=Math.sqrt(h[4]*h[4]+h[5]*h[5]+h[6]*h[6]),n.z=Math.sqrt(h[8]*h[8]+h[9]*h[9]+h[10]*h[10]),o){const y=(G?o.absoluteScaling.x:o.fi.x)<0?-1:1,H=(G?o.absoluteScaling.y:o.fi.y)<0?-1:1,h=(G?o.absoluteScaling.z:o.fi.z)<0?-1:1;n.x*=y,n.y*=H,n.z*=h}else this.determinant()<=0&&(n.y*=-1);if(0===n._x||0===n._y||0===n._z)return y&&y.Mi(0,0,0,1),!1;if(y){const H=1/n._x,o=1/n._y,G=1/n._z;l.FromValuesToRef(h[0]*H,h[1]*H,h[2]*H,0,h[4]*o,h[5]*o,h[6]*o,0,h[8]*G,h[9]*G,h[10]*G,0,0,0,0,1,v.Matrix[0]),Q.FromRotationMatrixToRef(v.Matrix[0],y)}return!0}getRow(n){if(n<0||n>3)return null;const y=4*n;return new z(this.jh[y+0],this.jh[y+1],this.jh[y+2],this.jh[y+3])}getRowToRef(n,y){if(n>=0&&n<=3){const H=4*n;y.x=this.jh[H+0],y.y=this.jh[H+1],y.z=this.jh[H+2],y.w=this.jh[H+3]}return y}setRow(n,y){return this.setRowFromFloats(n,y.x,y.y,y.z,y.w)}transpose(){const n=new l;return l.TransposeToRef(this,n),n}transposeToRef(n){return l.TransposeToRef(this,n),n}setRowFromFloats(n,y,H,o,G){if(n<0||n>3)return this;const h=4*n;return this.jh[h+0]=y,this.jh[h+1]=H,this.jh[h+2]=o,this.jh[h+3]=G,this.markAsUpdated(),this}scale(n){const y=new l;return this.scaleToRef(n,y),y}scaleToRef(n,y){for(let H=0;H<16;H++)y.jh[H]=this.jh[H]*n;return y.markAsUpdated(),y}scaleAndAddToRef(n,y){for(let H=0;H<16;H++)y.jh[H]+=this.jh[H]*n;return y.markAsUpdated(),y}scaleInPlace(n){const y=this.jh;for(let H=0;H<16;H++)y[H]*=n;return this.markAsUpdated(),this}toNormalMatrix(n){const y=v.Matrix[0];this.invertToRef(y),y.transposeToRef(n);const H=n.jh;return l.FromValuesToRef(H[0],H[1],H[2],0,H[4],H[5],H[6],0,H[8],H[9],H[10],0,0,0,0,1,n),n}getRotationMatrix(){const n=new l;return this.getRotationMatrixToRef(n),n}getRotationMatrixToRef(n){const y=v.zy[0];if(!this.decompose(y))return l.IdentityToRef(n),n;const H=this.jh,o=1/y._x,G=1/y._y,h=1/y._z;return l.FromValuesToRef(H[0]*o,H[1]*o,H[2]*o,0,H[4]*G,H[5]*G,H[6]*G,0,H[8]*h,H[9]*h,H[10]*h,0,0,0,0,1,n),n}toggleModelMatrixHandInPlace(){const n=this.jh;return n[2]*=-1,n[6]*=-1,n[8]*=-1,n[9]*=-1,n[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const n=this.jh;return n[8]*=-1,n[9]*=-1,n[10]*=-1,n[11]*=-1,this.markAsUpdated(),this}static gy(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=new l;return l.FromArrayToRef(n,y,H),H}static FromArrayToRef(n,y,H){for(let o=0;o<16;o++)H.jh[o]=n[o+y];return H.markAsUpdated(),H}static FromFloat32ArrayToRefScaled(n,y,H,o){return o.jh[0]=n[0+y]*H,o.jh[1]=n[1+y]*H,o.jh[2]=n[2+y]*H,o.jh[3]=n[3+y]*H,o.jh[4]=n[4+y]*H,o.jh[5]=n[5+y]*H,o.jh[6]=n[6+y]*H,o.jh[7]=n[7+y]*H,o.jh[8]=n[8+y]*H,o.jh[9]=n[9+y]*H,o.jh[10]=n[10+y]*H,o.jh[11]=n[11+y]*H,o.jh[12]=n[12+y]*H,o.jh[13]=n[13+y]*H,o.jh[14]=n[14+y]*H,o.jh[15]=n[15+y]*H,o.markAsUpdated(),o}static get IdentityReadOnly(){return l._IdentityReadOnly}static FromValuesToRef(n,y,H,o,G,h,k,i,B,V,q,b,A,U,T,W,z){const Q=z.jh;Q[0]=n,Q[1]=y,Q[2]=H,Q[3]=o,Q[4]=G,Q[5]=h,Q[6]=k,Q[7]=i,Q[8]=B,Q[9]=V,Q[10]=q,Q[11]=b,Q[12]=A,Q[13]=U,Q[14]=T,Q[15]=W,z.markAsUpdated()}static FromValues(n,y,H,o,G,h,k,i,B,V,q,b,A,U,T,W){const z=new l,Q=z.jh;return Q[0]=n,Q[1]=y,Q[2]=H,Q[3]=o,Q[4]=G,Q[5]=h,Q[6]=k,Q[7]=i,Q[8]=B,Q[9]=V,Q[10]=q,Q[11]=b,Q[12]=A,Q[13]=U,Q[14]=T,Q[15]=W,z.markAsUpdated(),z}static Compose(n,y,H){const o=new l;return l.ComposeToRef(n,y,H,o),o}static ComposeToRef(n,y,H,o){const G=o.jh,h=y._x,k=y._y,i=y._z,B=y._w,V=h+h,q=k+k,b=i+i,A=h*V,U=h*q,T=h*b,W=k*q,z=k*b,Q=i*b,l=B*V,v=B*q,F=B*b,g=n._x,M=n._y,f=n._z;return G[0]=(1-(W+Q))*g,G[1]=(U+F)*g,G[2]=(T-v)*g,G[3]=0,G[4]=(U-F)*M,G[5]=(1-(A+Q))*M,G[6]=(z+l)*M,G[7]=0,G[8]=(T+v)*f,G[9]=(z-l)*f,G[10]=(1-(A+W))*f,G[11]=0,G[12]=H._x,G[13]=H._y,G[14]=H._z,G[15]=1,o.markAsUpdated(),o}static Identity(){const n=l.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return n._updateIdentityStatus(!0),n}static IdentityToRef(n){return l.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,n),n._updateIdentityStatus(!0),n}static Zero(){const n=l.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return n._updateIdentityStatus(!1),n}static RotationX(n){const y=new l;return l.RotationXToRef(n,y),y}static Invert(n){const y=new l;return n.invertToRef(y),y}static RotationXToRef(n,y){const H=Math.sin(n),o=Math.cos(n);return l.FromValuesToRef(1,0,0,0,0,o,H,0,0,-H,o,0,0,0,0,1,y),y._updateIdentityStatus(1===o&&0===H),y}static RotationY(n){const y=new l;return l.RotationYToRef(n,y),y}static RotationYToRef(n,y){const H=Math.sin(n),o=Math.cos(n);return l.FromValuesToRef(o,0,-H,0,0,1,0,0,H,0,o,0,0,0,0,1,y),y._updateIdentityStatus(1===o&&0===H),y}static RotationZ(n){const y=new l;return l.RotationZToRef(n,y),y}static RotationZToRef(n,y){const H=Math.sin(n),o=Math.cos(n);return l.FromValuesToRef(o,H,0,0,-H,o,0,0,0,0,1,0,0,0,0,1,y),y._updateIdentityStatus(1===o&&0===H),y}static RotationAxis(n,y){const H=new l;return l.RotationAxisToRef(n,y,H),H}static RotationAxisToRef(n,y,H){const o=Math.sin(-y),G=Math.cos(-y),h=1-G;n=n.normalizeToRef(v.zy[0]);const k=H.jh;return k[0]=n._x*n._x*h+G,k[1]=n._x*n._y*h-n._z*o,k[2]=n._x*n._z*h+n._y*o,k[3]=0,k[4]=n._y*n._x*h+n._z*o,k[5]=n._y*n._y*h+G,k[6]=n._y*n._z*h-n._x*o,k[7]=0,k[8]=n._z*n._x*h-n._y*o,k[9]=n._z*n._y*h+n._x*o,k[10]=n._z*n._z*h+G,k[11]=0,k[12]=0,k[13]=0,k[14]=0,k[15]=1,H.markAsUpdated(),H}static RotationAlignToRef(n,y,H){let G=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const h=W.Dot(y,n),k=H.jh;if(h<-1+o.e)k[0]=-1,k[1]=0,k[2]=0,k[3]=0,k[4]=0,k[5]=G?1:-1,k[6]=0,k[7]=0,k[8]=0,k[9]=0,k[10]=G?-1:1,k[11]=0;else{const H=W.Cross(y,n),o=1/(1+h);k[0]=H._x*H._x*o+h,k[1]=H._y*H._x*o-H._z,k[2]=H._z*H._x*o+H._y,k[3]=0,k[4]=H._x*H._y*o+H._z,k[5]=H._y*H._y*o+h,k[6]=H._z*H._y*o-H._x,k[7]=0,k[8]=H._x*H._z*o-H._y,k[9]=H._y*H._z*o+H._x,k[10]=H._z*H._z*o+h,k[11]=0}return k[12]=0,k[13]=0,k[14]=0,k[15]=1,H.markAsUpdated(),H}static RotationYawPitchRoll(n,y,H){const o=new l;return l.RotationYawPitchRollToRef(n,y,H,o),o}static RotationYawPitchRollToRef(n,y,H,o){return Q.RotationYawPitchRollToRef(n,y,H,v.Quaternion[0]),v.Quaternion[0].toRotationMatrix(o),o}static Scaling(n,y,H){const o=new l;return l.ScalingToRef(n,y,H,o),o}static ScalingToRef(n,y,H,o){return l.FromValuesToRef(n,0,0,0,0,y,0,0,0,0,H,0,0,0,0,1,o),o._updateIdentityStatus(1===n&&1===y&&1===H),o}static Translation(n,y,H){const o=new l;return l.TranslationToRef(n,y,H,o),o}static TranslationToRef(n,y,H,o){return l.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,n,y,H,1,o),o._updateIdentityStatus(0===n&&0===y&&0===H),o}static Lerp(n,y,H){const o=new l;return l.LerpToRef(n,y,H,o),o}static LerpToRef(n,y,H,o){const G=o.jh,h=n.m,k=y.m;for(let i=0;i<16;i++)G[i]=h[i]*(1-H)+k[i]*H;return o.markAsUpdated(),o}static DecomposeLerp(n,y,H){const o=new l;return l.DecomposeLerpToRef(n,y,H,o),o}static DecomposeLerpToRef(n,y,H,o){const G=v.zy[0],h=v.Quaternion[0],k=v.zy[1];n.decompose(G,h,k);const i=v.zy[2],B=v.Quaternion[1],V=v.zy[3];y.decompose(i,B,V);const q=v.zy[4];W.LerpToRef(G,i,H,q);const b=v.Quaternion[2];Q.SlerpToRef(h,B,H,b);const A=v.zy[5];return W.LerpToRef(k,V,H,A),l.ComposeToRef(q,b,A,o),o}static LookAtLH(n,y,H){const o=new l;return l.LookAtLHToRef(n,y,H,o),o}static LookAtLHToRef(n,y,H,o){const G=v.zy[0],h=v.zy[1],k=v.zy[2];y.subtractToRef(n,k),k.normalize(),W.CrossToRef(H,k,G);const i=G.lengthSquared();0===i?G.x=1:G.normalizeFromLength(Math.sqrt(i)),W.CrossToRef(k,G,h),h.normalize();const B=-W.Dot(G,n),V=-W.Dot(h,n),q=-W.Dot(k,n);return l.FromValuesToRef(G._x,h._x,k._x,0,G._y,h._y,k._y,0,G._z,h._z,k._z,0,B,V,q,1,o),o}static LookAtRH(n,y,H){const o=new l;return l.LookAtRHToRef(n,y,H,o),o}static LookAtRHToRef(n,y,H,o){const G=v.zy[0],h=v.zy[1],k=v.zy[2];n.subtractToRef(y,k),k.normalize(),W.CrossToRef(H,k,G);const i=G.lengthSquared();0===i?G.x=1:G.normalizeFromLength(Math.sqrt(i)),W.CrossToRef(k,G,h),h.normalize();const B=-W.Dot(G,n),V=-W.Dot(h,n),q=-W.Dot(k,n);return l.FromValuesToRef(G._x,h._x,k._x,0,G._y,h._y,k._y,0,G._z,h._z,k._z,0,B,V,q,1,o),o}static LookDirectionLH(n,y){const H=new l;return l.LookDirectionLHToRef(n,y,H),H}static LookDirectionLHToRef(n,y,H){const o=v.zy[0];o.B(n),o.scaleInPlace(-1);const G=v.zy[1];return W.CrossToRef(y,o,G),l.FromValuesToRef(G._x,G._y,G._z,0,y._x,y._y,y._z,0,o._x,o._y,o._z,0,0,0,0,1,H),H}static LookDirectionRH(n,y){const H=new l;return l.LookDirectionRHToRef(n,y,H),H}static LookDirectionRHToRef(n,y,H){const o=v.zy[2];return W.CrossToRef(y,n,o),l.FromValuesToRef(o._x,o._y,o._z,0,y._x,y._y,y._z,0,n._x,n._y,n._z,0,0,0,0,1,H),H}static OrthoLH(n,y,H,o,G){const h=new l;return l.OrthoLHToRef(n,y,H,o,h,G),h}static OrthoLHToRef(n,y,H,o,G,h){const k=2/n,i=2/y,B=2/(o-H),V=-(o+H)/(o-H);return l.FromValuesToRef(k,0,0,0,0,i,0,0,0,0,B,0,0,0,V,1,G),h&&G.multiplyToRef(g,G),G._updateIdentityStatus(1===k&&1===i&&1===B&&0===V),G}static OrthoOffCenterLH(n,y,H,o,G,h,k){const i=new l;return l.OrthoOffCenterLHToRef(n,y,H,o,G,h,i,k),i}static OrthoOffCenterLHToRef(n,y,H,o,G,h,k,i){const B=2/(y-n),V=2/(o-H),q=2/(h-G),b=-(h+G)/(h-G),A=(n+y)/(n-y),U=(o+H)/(H-o);return l.FromValuesToRef(B,0,0,0,0,V,0,0,0,0,q,0,A,U,b,1,k),i&&k.multiplyToRef(g,k),k.markAsUpdated(),k}static ObliqueOffCenterLHToRef(n,y,H,o,G,h,k,i,B,V,q){const b=-k*Math.cos(i),A=-k*Math.sin(i);return l.TranslationToRef(0,0,-B,v.Matrix[1]),l.FromValuesToRef(1,0,0,0,0,1,0,0,b,A,1,0,0,0,0,1,v.Matrix[0]),v.Matrix[1].multiplyToRef(v.Matrix[0],v.Matrix[0]),l.TranslationToRef(0,0,B,v.Matrix[1]),v.Matrix[0].multiplyToRef(v.Matrix[1],v.Matrix[0]),l.OrthoOffCenterLHToRef(n,y,H,o,G,h,V,q),v.Matrix[0].multiplyToRef(V,V),V}static OrthoOffCenterRH(n,y,H,o,G,h,k){const i=new l;return l.OrthoOffCenterRHToRef(n,y,H,o,G,h,i,k),i}static OrthoOffCenterRHToRef(n,y,H,o,G,h,k,i){return l.OrthoOffCenterLHToRef(n,y,H,o,G,h,k,i),k.jh[10]*=-1,k}static ObliqueOffCenterRHToRef(n,y,H,o,G,h,k,i,B,V,q){const b=k*Math.cos(i),A=k*Math.sin(i);return l.TranslationToRef(0,0,B,v.Matrix[1]),l.FromValuesToRef(1,0,0,0,0,1,0,0,b,A,1,0,0,0,0,1,v.Matrix[0]),v.Matrix[1].multiplyToRef(v.Matrix[0],v.Matrix[0]),l.TranslationToRef(0,0,-B,v.Matrix[1]),v.Matrix[0].multiplyToRef(v.Matrix[1],v.Matrix[0]),l.OrthoOffCenterRHToRef(n,y,H,o,G,h,V,q),v.Matrix[0].multiplyToRef(V,V),V}static PerspectiveLH(n,y,H,o,G){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const k=new l,i=2*H/n,B=2*H/y,V=(o+H)/(o-H),q=-2*o*H/(o-H),b=Math.tan(h);return l.FromValuesToRef(i,0,0,0,0,B,0,b,0,0,V,1,0,0,q,0,k),G&&k.multiplyToRef(g,k),k._updateIdentityStatus(!1),k}static PerspectiveFovLH(n,y,H,o,G){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,k=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const i=new l;return l.PerspectiveFovLHToRef(n,y,H,o,i,!0,G,h,k),i}static PerspectiveFovLHToRef(n,y,H,o,G){let h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,B=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const V=H,q=o,b=1/Math.tan(.5*n),A=h?b/y:b,U=h?b:b*y,T=B&&0===V?-1:0!==q?(q+V)/(q-V):1,W=B&&0===V?2*q:0!==q?-2*q*V/(q-V):-2*V,z=Math.tan(i);return l.FromValuesToRef(A,0,0,0,0,U,0,z,0,0,T,1,0,0,W,0,G),k&&G.multiplyToRef(g,G),G._updateIdentityStatus(!1),G}static PerspectiveFovReverseLHToRef(n,y,H,o,G){let h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const B=1/Math.tan(.5*n),V=h?B/y:B,q=h?B:B*y,b=Math.tan(i);return l.FromValuesToRef(V,0,0,0,0,q,0,b,0,0,-H,1,0,0,1,0,G),k&&G.multiplyToRef(g,G),G._updateIdentityStatus(!1),G}static PerspectiveFovRH(n,y,H,o,G){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,k=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const i=new l;return l.PerspectiveFovRHToRef(n,y,H,o,i,!0,G,h,k),i}static PerspectiveFovRHToRef(n,y,H,o,G){let h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,B=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const V=H,q=o,b=1/Math.tan(.5*n),A=h?b/y:b,U=h?b:b*y,T=B&&0===V?1:0!==q?-(q+V)/(q-V):-1,W=B&&0===V?2*q:0!==q?-2*q*V/(q-V):-2*V,z=Math.tan(i);return l.FromValuesToRef(A,0,0,0,0,U,0,z,0,0,T,-1,0,0,W,0,G),k&&G.multiplyToRef(g,G),G._updateIdentityStatus(!1),G}static PerspectiveFovReverseRHToRef(n,y,H,o,G){let h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const B=1/Math.tan(.5*n),V=h?B/y:B,q=h?B:B*y,b=Math.tan(i);return l.FromValuesToRef(V,0,0,0,0,q,0,b,0,0,-H,-1,0,0,-1,0,G),k&&G.multiplyToRef(g,G),G._updateIdentityStatus(!1),G}static GetFinalMatrix(n,y,H,o,G,h){const k=n.width,i=n.height,B=n.x,V=n.y,q=l.FromValues(k/2,0,0,0,0,-i/2,0,0,0,0,h-G,0,B+k/2,i/2+V,G,1),b=new l;return y.multiplyToRef(H,b),b.multiplyToRef(o,b),b.multiplyToRef(q,b)}static GetAsMatrix2x2(n){const y=n.m,H=[y[0],y[1],y[4],y[5]];return k.b.MatrixUse64Bits?H:new Float32Array(H)}static GetAsMatrix3x3(n){const y=n.m,H=[y[0],y[1],y[2],y[4],y[5],y[6],y[8],y[9],y[10]];return k.b.MatrixUse64Bits?H:new Float32Array(H)}static Transpose(n){const y=new l;return l.TransposeToRef(n,y),y}static TransposeToRef(n,y){const H=n.m,o=H[0],G=H[4],h=H[8],k=H[12],i=H[1],B=H[5],V=H[9],q=H[13],b=H[2],A=H[6],U=H[10],T=H[14],W=H[3],z=H[7],Q=H[11],l=H[15],v=y.jh;return v[0]=o,v[1]=G,v[2]=h,v[3]=k,v[4]=i,v[5]=B,v[6]=V,v[7]=q,v[8]=b,v[9]=A,v[10]=U,v[11]=T,v[12]=W,v[13]=z,v[14]=Q,v[15]=l,y.markAsUpdated(),y._updateIdentityStatus(n._isIdentity,n._isIdentityDirty),y}static Reflection(n){const y=new l;return l.ReflectionToRef(n,y),y}static ReflectionToRef(n,y){n.normalize();const H=n.normal.x,o=n.normal.y,G=n.normal.z,h=-2*H,k=-2*o,i=-2*G;return l.FromValuesToRef(h*H+1,k*H,i*H,0,h*o,k*o+1,i*o,0,h*G,k*G,i*G+1,0,h*n.d,k*n.d,i*n.d,1,y),y}static FromXYZAxesToRef(n,y,H,o){return l.FromValuesToRef(n._x,n._y,n._z,0,y._x,y._y,y._z,0,H._x,H._y,H._z,0,0,0,0,1,o),o}static FromQuaternionToRef(n,y){const H=n._x*n._x,o=n._y*n._y,G=n._z*n._z,h=n._x*n._y,k=n._z*n._w,i=n._z*n._x,B=n._y*n._w,V=n._y*n._z,q=n._x*n._w;return y.jh[0]=1-2*(o+G),y.jh[1]=2*(h+k),y.jh[2]=2*(i-B),y.jh[3]=0,y.jh[4]=2*(h-k),y.jh[5]=1-2*(G+H),y.jh[6]=2*(V+q),y.jh[7]=0,y.jh[8]=2*(i+B),y.jh[9]=2*(V-q),y.jh[10]=1-2*(o+H),y.jh[11]=0,y.jh[12]=0,y.jh[13]=0,y.jh[14]=0,y.jh[15]=1,y.markAsUpdated(),y}}l._IdentityReadOnly=l.Identity(),Object.defineProperties(l.prototype,{dimension:{value:[4,4]},rank:{value:2}});class v{}v.zy=(0,G.f)(11,W.Zero),v.Matrix=(0,G.f)(2,l.Identity),v.Quaternion=(0,G.f)(3,Q.Zero);class F{}F.Vector2=(0,G.f)(3,T.Zero),F.zy=(0,G.f)(13,W.Zero),F.Vector4=(0,G.f)(3,z.Zero),F.Quaternion=(0,G.f)(3,Q.Zero),F.Matrix=(0,G.f)(8,l.Identity),(0,h.h)("BABYLON.Vector2",T),(0,h.h)("BABYLON.Vector3",W),(0,h.h)("BABYLON.Vector4",z),(0,h.h)("BABYLON.Matrix",l);const g=l.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11300:(n,y,H)=>{function o(n,y){const H=[];for(let o=0;o<n;++o)H.push(y());return H}function G(n,y){return o(n,y)}H.d(y,{c:()=>o,f:()=>G,h:()=>k});const h=["push","splice","pop","shift","unshift"];function k(n,y){const H=h.map((H=>function(n,y,H){const o=n[y];if("function"!==typeof o)return null;const G=function(){const o=n.length,h=G.previous.apply(n,arguments);return H(y,o),h};return o.next=G,G.previous=o,n[y]=G,()=>{const H=G.previous;if(!H)return;const o=G.next;o?(H.next=o,o.previous=H):(H.next=void 0,n[y]=H),G.next=void 0,G.previous=void 0}}(n,H,y)));return()=>{for(const n of H)null===n||void 0===n||n()}}}}]);