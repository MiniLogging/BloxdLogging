"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[14],{12336:(E,U,g)=>{g.d(U,{c:()=>S,e:()=>D,f:()=>N,i:()=>L});const N=1/2.2,L=2.2,D=(1+Math.sqrt(5))/2,S=.001},12353:(E,U,g)=>{function N(E){return parseInt(E.toString().replace(/\W/g,""))}function L(E,U){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(E-U)<=g}function D(E,U,g){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return E<U-N||E>g+N}function S(E,U){return E===U?E:Math.random()*(U-E)+E}function u(E,U,g){return E+(U-E)*g}function s(E,U,g){let N=y(U-E,360);return N>180&&(N-=360),E+N*F(g)}function C(E,U,g){let N=0;return N=E!=U?F((g-E)/(U-E)):0,N}function B(E,U,g,N,L){const D=L*L,S=L*D;return E*(2*S-3*D+1)+g*(-2*S+3*D)+U*(S-2*D+L)+N*(S-D)}function P(E,U,g,N,L){const D=L*L;return 6*(D-L)*E+(3*D-4*L+1)*U+6*(-D+L)*g+(3*D-2*L)*N}function F(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(g,Math.max(U,E))}function f(E){return E-=2*Math.PI*Math.floor((E+Math.PI)/(2*Math.PI))}function d(E){const U=E.toString(16);return E<=15?("0"+U).toUpperCase():U.toUpperCase()}function I(E){if(Math.log2)return Math.floor(Math.log2(E));if(E<0)return NaN;if(0===E)return-1/0;let U=0;if(E<1){for(;E<1;)U++,E*=2;U=-U}else if(E>1)for(;E>1;)U++,E=Math.floor(E/2);return U}function y(E,U){return E-Math.floor(E/U)*U}function h(E,U,g){return(E-U)/(g-U)}function V(E,U,g){return E*(g-U)+U}function e(E,U){let g=y(U-E,360);return g>180&&(g-=360),g}function x(E,U){const g=y(E,2*U);return U-Math.abs(g-U)}function l(E,U,g){let N=F(g);return N=-2*N*N*N+3*N*N,U*N+E*(1-N)}function Y(E,U,g){let N=0;return N=Math.abs(U-E)<=g?U:E+Math.sign(U-E)*g,N}function t(E,U,g){const N=e(E,U);let L=0;return L=-g<N&&N<g?U:Y(E,U=E+N,g),L}function G(E,U,g){return(E-U)/(g-U)}function b(E,U,g){return(g-U)*E+U}function T(E,U){const g=E%U;return 0===g?U:T(U,g)}g.r(U),g.d(U,{Clamp:()=>F,DeltaAngle:()=>e,Denormalize:()=>V,ExtractAsInt:()=>N,Hermite:()=>B,Hermite1stDerivative:()=>P,HighestCommonFactor:()=>T,ILog2:()=>I,InverseLerp:()=>C,Lerp:()=>u,LerpAngle:()=>s,MoveTowards:()=>Y,MoveTowardsAngle:()=>t,Normalize:()=>h,NormalizeRadians:()=>f,OutsideRange:()=>D,PercentToRange:()=>b,PingPong:()=>x,RandomRange:()=>S,RangeToPercent:()=>G,Repeat:()=>y,SmoothStep:()=>l,ToHex:()=>d,WithinEpsilon:()=>L})},12334:(E,U,g)=>{g.r(U),g.d(U,{Matrix:()=>V,Quaternion:()=>h,TmpVectors:()=>x,Vector2:()=>d,dU:()=>I,Vector4:()=>y});var N=g(12336),L=g(12345),D=g(12292),S=g(12264),u=g(12205),s=g(12353);class C{}function B(E,U,g){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const L=E.Og(),D=U.Og(),S=L[0],u=L[1],s=L[2],C=L[3],B=L[4],P=L[5],F=L[6],f=L[7],d=L[8],I=L[9],y=L[10],h=L[11],V=L[12],e=L[13],x=L[14],l=L[15],Y=D[0],t=D[1],G=D[2],b=D[3],T=D[4],v=D[5],o=D[6],c=D[7],r=D[8],j=D[9],Z=D[10],A=D[11],w=D[12],a=D[13],J=D[14],q=D[15];g[N]=S*Y+u*T+s*r+C*w,g[N+1]=S*t+u*v+s*j+C*a,g[N+2]=S*G+u*o+s*Z+C*J,g[N+3]=S*b+u*c+s*A+C*q,g[N+4]=B*Y+P*T+F*r+f*w,g[N+5]=B*t+P*v+F*j+f*a,g[N+6]=B*G+P*o+F*Z+f*J,g[N+7]=B*b+P*c+F*A+f*q,g[N+8]=d*Y+I*T+y*r+h*w,g[N+9]=d*t+I*v+y*j+h*a,g[N+10]=d*G+I*o+y*Z+h*J,g[N+11]=d*b+I*c+y*A+h*q,g[N+12]=V*Y+e*T+x*r+l*w,g[N+13]=V*t+e*v+x*j+l*a,g[N+14]=V*G+e*o+x*Z+l*J,g[N+15]=V*b+e*c+x*A+l*q}function P(E,U){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const N=E.Og();U[g]=N[0],U[g+1]=N[1],U[g+2]=N[2],U[g+3]=N[3],U[g+4]=N[4],U[g+5]=N[5],U[g+6]=N[6],U[g+7]=N[7],U[g+8]=N[8],U[g+9]=N[9],U[g+10]=N[10],U[g+11]=N[11],U[g+12]=N[12],U[g+13]=N[13],U[g+14]=N[14],U[g+15]=N[15]}function F(E,U){const g=E.Og(),N=g[0],L=g[1],D=g[2],S=g[3],u=g[4],s=g[5],C=g[6],B=g[7],P=g[8],F=g[9],f=g[10],d=g[11],I=g[12],y=g[13],h=g[14],V=g[15],e=f*V-h*d,x=F*V-y*d,l=F*h-y*f,Y=P*V-I*d,t=P*h-f*I,G=P*y-I*F,b=+(s*e-C*x+B*l),T=-(u*e-C*Y+B*t),v=+(u*x-s*Y+B*G),o=-(u*l-s*t+C*G),c=N*b+L*T+D*v+S*o;if(0===c)return!1;const r=1/c,j=C*V-h*B,Z=s*V-y*B,A=s*h-y*C,w=u*V-I*B,a=u*h-I*C,J=u*y-I*s,q=C*d-f*B,M=s*d-F*B,mE=s*f-F*C,W=u*d-P*B,O=u*f-P*C,Q=u*F-P*s,R=-(L*e-D*x+S*l),n=+(N*e-D*Y+S*t),k=-(N*x-L*Y+S*G),z=+(N*l-L*t+D*G),i=+(L*j-D*Z+S*A),p=-(N*j-D*w+S*a),H=+(N*Z-L*w+S*J),K=-(N*A-L*a+D*J),X=-(L*q-D*M+S*mE),EE=+(N*q-D*W+S*O),UE=-(N*M-L*W+S*Q),gE=+(N*mE-L*O+D*Q);return U[0]=b*r,U[1]=R*r,U[2]=i*r,U[3]=X*r,U[4]=T*r,U[5]=n*r,U[6]=p*r,U[7]=EE*r,U[8]=v*r,U[9]=k*r,U[10]=H*r,U[11]=UE*r,U[12]=o*r,U[13]=z*r,U[14]=K*r,U[15]=gE*r,!0}C._UpdateFlagSeed=0;const f=E=>parseInt(E.toString().replace(/\W/g,""));class d{constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=E,this.y=U}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let E=f(this.x);return E=397*E^f(this.y),E}toArray(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[U]=this.x,E[U+1]=this.y,this}Yg(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return d.FromArrayToRef(E,U,this),this}Og(){return[this.x,this.y]}D(E){return this.x=E.x,this.y=E.y,this}du(E,U){return this.x=E,this.y=U,this}set(E,U){return this.du(E,U)}yu(E){return this.du(E,E)}add(E){return new d(this.x+E.x,this.y+E.y)}addToRef(E,U){return U.x=this.x+E.x,U.y=this.y+E.y,U}addInPlace(E){return this.x+=E.x,this.y+=E.y,this}addInPlaceFromFloats(E,U){return this.x+=E,this.y+=U,this}addVector3(E){return new d(this.x+E.x,this.y+E.y)}IU(E){return new d(this.x-E.x,this.y-E.y)}subtractToRef(E,U){return U.x=this.x-E.x,U.y=this.y-E.y,U}iB(E){return this.x-=E.x,this.y-=E.y,this}multiplyInPlace(E){return this.x*=E.x,this.y*=E.y,this}multiply(E){return new d(this.x*E.x,this.y*E.y)}multiplyToRef(E,U){return U.x=this.x*E.x,U.y=this.y*E.y,U}multiplyByFloats(E,U){return new d(this.x*E,this.y*U)}divide(E){return new d(this.x/E.x,this.y/E.y)}divideToRef(E,U){return U.x=this.x/E.x,U.y=this.y/E.y,U}divideInPlace(E){return this.x=this.x/E.x,this.y=this.y/E.y,this}minimizeInPlace(E){return this.minimizeInPlaceFromFloats(E.x,E.y)}maximizeInPlace(E){return this.maximizeInPlaceFromFloats(E.x,E.y)}minimizeInPlaceFromFloats(E,U){return this.x=Math.min(E,this.x),this.y=Math.min(U,this.y),this}maximizeInPlaceFromFloats(E,U){return this.x=Math.max(E,this.x),this.y=Math.max(U,this.y),this}subtractFromFloats(E,U){return new d(this.x-E,this.y-U)}subtractFromFloatsToRef(E,U,g){return g.x=this.x-E,g.y=this.y-U,g}negate(){return new d(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(E){return E.x=-this.x,E.y=-this.y,E}scaleInPlace(E){return this.x*=E,this.y*=E,this}scale(E){return new d(this.x*E,this.y*E)}scaleToRef(E,U){return U.x=this.x*E,U.y=this.y*E,U}scaleAndAddToRef(E,U){return U.x+=this.x*E,U.y+=this.y*E,U}equals(E){return E&&this.x===E.x&&this.y===E.y}equalsWithEpsilon(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.c;return E&&(0,s.WithinEpsilon)(this.x,E.x,U)&&(0,s.WithinEpsilon)(this.y,E.y,U)}equalsToFloats(E,U){return this.x===E&&this.y===U}floor(){return new d(Math.floor(this.x),Math.floor(this.y))}floorToRef(E){return E.x=Math.floor(this.x),E.y=Math.floor(this.y),E}fract(){return new d(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(E){return E.x=this.x-Math.floor(this.x),E.y=this.y-Math.floor(this.y),E}rotate(E){return this.rotateToRef(E,new d)}rotateToRef(E,U){const g=Math.cos(E),N=Math.sin(E);return U.x=g*this.x-N*this.y,U.y=N*this.x+g*this.y,U}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){const E=new d;return this.normalizeToRef(E),E}normalizeToRef(E){const U=this.length();return 0===U&&(E.x=this.x,E.y=this.y),this.scaleToRef(1/U,E)}clone(){return new d(this.x,this.y)}dot(E){return this.x*E.x+this.y*E.y}static Zero(){return new d(0,0)}static One(){return new d(1,1)}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new d((0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).du((0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U))}static get ZeroReadOnly(){return d._ZeroReadOnly}static eU(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new d(E[U],E[U+1])}static FromArrayToRef(E,U,g){return g.x=E[U],g.y=E[U+1],g}static FromFloatsToRef(E,U,g){return g.du(E,U),g}static CatmullRom(E,U,g,N,L){const D=L*L,S=L*D,u=.5*(2*U.x+(-E.x+g.x)*L+(2*E.x-5*U.x+4*g.x-N.x)*D+(-E.x+3*U.x-3*g.x+N.x)*S),s=.5*(2*U.y+(-E.y+g.y)*L+(2*E.y-5*U.y+4*g.y-N.y)*D+(-E.y+3*U.y-3*g.y+N.y)*S);return new d(u,s)}static ClampToRef(E,U,g,N){return N.x=(0,s.Clamp)(E.x,U.x,g.x),N.y=(0,s.Clamp)(E.y,U.y,g.y),N}static Clamp(E,U,g){const N=(0,s.Clamp)(E.x,U.x,g.x),L=(0,s.Clamp)(E.y,U.y,g.y);return new d(N,L)}static Hermite(E,U,g,N,L){const D=L*L,S=L*D,u=2*S-3*D+1,s=-2*S+3*D,C=S-2*D+L,B=S-D,P=E.x*u+g.x*s+U.x*C+N.x*B,F=E.y*u+g.y*s+U.y*C+N.y*B;return new d(P,F)}static Hermite1stDerivative(E,U,g,N,L){return this.Hermite1stDerivativeToRef(E,U,g,N,L,new d)}static Hermite1stDerivativeToRef(E,U,g,N,L,D){const S=L*L;return D.x=6*(S-L)*E.x+(3*S-4*L+1)*U.x+6*(-S+L)*g.x+(3*S-2*L)*N.x,D.y=6*(S-L)*E.y+(3*S-4*L+1)*U.y+6*(-S+L)*g.y+(3*S-2*L)*N.y,D}static Lerp(E,U,g){return d.LerpToRef(E,U,g,new d)}static LerpToRef(E,U,g,N){return N.x=E.x+(U.x-E.x)*g,N.y=E.y+(U.y-E.y)*g,N}static Dot(E,U){return E.x*U.x+E.y*U.y}static Normalize(E){return d.NormalizeToRef(E,new d)}static NormalizeToRef(E,U){return E.normalizeToRef(U),U}static Minimize(E,U){const g=E.x<U.x?E.x:U.x,N=E.y<U.y?E.y:U.y;return new d(g,N)}static Maximize(E,U){const g=E.x>U.x?E.x:U.x,N=E.y>U.y?E.y:U.y;return new d(g,N)}static Transform(E,U){return d.TransformToRef(E,U,new d)}static TransformToRef(E,U,g){const N=U.m,L=E.x*N[0]+E.y*N[4]+N[12],D=E.x*N[1]+E.y*N[5]+N[13];return g.x=L,g.y=D,g}static PointInTriangle(E,U,g,N){const L=.5*(-g.y*N.x+U.y*(-g.x+N.x)+U.x*(g.y-N.y)+g.x*N.y),D=L<0?-1:1,S=(U.y*N.x-U.x*N.y+(N.y-U.y)*E.x+(U.x-N.x)*E.y)*D,u=(U.x*g.y-U.y*g.x+(U.y-g.y)*E.x+(g.x-U.x)*E.y)*D;return S>0&&u>0&&S+u<2*L*D}static Distance(E,U){return Math.sqrt(d.DistanceSquared(E,U))}static DistanceSquared(E,U){const g=E.x-U.x,N=E.y-U.y;return g*g+N*N}static Center(E,U){return d.CenterToRef(E,U,new d)}static CenterToRef(E,U,g){return g.du((E.x+U.x)/2,(E.y+U.y)/2)}static DistanceOfPointFromSegment(E,U,g){const N=d.DistanceSquared(U,g);if(0===N)return d.Distance(E,U);const L=g.IU(U),D=Math.max(0,Math.min(1,d.Dot(E.IU(U),L)/N)),S=U.add(L.multiplyByFloats(D,D));return d.Distance(E,S)}}d._V8PerformanceHack=new d(.5,.5),d._ZeroReadOnly=d.Zero(),Object.defineProperties(d.prototype,{dimension:{value:[2]},rank:{value:1}});class I{get x(){return this._x}set x(E){this._x=E,this._isDirty=!0}get y(){return this._y}set y(E){this._y=E,this._isDirty=!0}get z(){return this._z}set z(E){this._z=E,this._isDirty=!0}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=E,this._y=U,this._z=g}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"dU"}getHashCode(){let E=f(this._x);return E=397*E^f(this._y),E=397*E^f(this._z),E}Og(){return[this._x,this._y,this._z]}toArray(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[U]=this._x,E[U+1]=this._y,E[U+2]=this._z,this}Yg(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I.FromArrayToRef(E,U,this),this}toQuaternion(){return h.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(E){return this._x+=E._x,this._y+=E._y,this._z+=E._z,this._isDirty=!0,this}addInPlaceFromFloats(E,U,g){return this._x+=E,this._y+=U,this._z+=g,this._isDirty=!0,this}add(E){return new I(this._x+E._x,this._y+E._y,this._z+E._z)}addToRef(E,U){return U._x=this._x+E._x,U._y=this._y+E._y,U._z=this._z+E._z,U._isDirty=!0,U}iB(E){return this._x-=E._x,this._y-=E._y,this._z-=E._z,this._isDirty=!0,this}IU(E){return new I(this._x-E._x,this._y-E._y,this._z-E._z)}subtractToRef(E,U){return this.subtractFromFloatsToRef(E._x,E._y,E._z,U)}subtractFromFloats(E,U,g){return new I(this._x-E,this._y-U,this._z-g)}subtractFromFloatsToRef(E,U,g,N){return N._x=this._x-E,N._y=this._y-U,N._z=this._z-g,N._isDirty=!0,N}negate(){return new I(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(E){return E._x=-1*this._x,E._y=-1*this._y,E._z=-1*this._z,E._isDirty=!0,E}scaleInPlace(E){return this._x*=E,this._y*=E,this._z*=E,this._isDirty=!0,this}scale(E){return new I(this._x*E,this._y*E,this._z*E)}scaleToRef(E,U){return U._x=this._x*E,U._y=this._y*E,U._z=this._z*E,U._isDirty=!0,U}getNormalToRef(E){const U=this.length();let g=Math.acos(this._y/U);const N=Math.atan2(this._z,this._x);g>Math.PI/2?g-=Math.PI/2:g+=Math.PI/2;const L=U*Math.sin(g)*Math.cos(N),D=U*Math.cos(g),S=U*Math.sin(g)*Math.sin(N);return E.set(L,D,S),E}applyRotationQuaternionToRef(E,U){const g=this._x,N=this._y,L=this._z,D=E._x,S=E._y,u=E._z,s=E._w,C=2*(S*L-u*N),B=2*(u*g-D*L),P=2*(D*N-S*g);return U._x=g+s*C+S*P-u*B,U._y=N+s*B+u*C-D*P,U._z=L+s*P+D*B-S*C,U._isDirty=!0,U}applyRotationQuaternionInPlace(E){return this.applyRotationQuaternionToRef(E,this)}applyRotationQuaternion(E){return this.applyRotationQuaternionToRef(E,new I)}scaleAndAddToRef(E,U){return U._x+=this._x*E,U._y+=this._y*E,U._z+=this._z*E,U._isDirty=!0,U}projectOnPlane(E,U){return this.projectOnPlaneToRef(E,U,new I)}projectOnPlaneToRef(E,U,g){const N=E.normal,L=E.d,D=e.dU[0];this.subtractToRef(U,D),D.normalize();const S=I.Dot(D,N);if(Math.abs(S)<1e-10)g.yu(1/0);else{const E=-(I.Dot(U,N)+L)/S,u=D.scaleInPlace(E);U.addToRef(u,g)}return g}equals(E){return E&&this._x===E._x&&this._y===E._y&&this._z===E._z}equalsWithEpsilon(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.c;return E&&(0,s.WithinEpsilon)(this._x,E._x,U)&&(0,s.WithinEpsilon)(this._y,E._y,U)&&(0,s.WithinEpsilon)(this._z,E._z,U)}equalsToFloats(E,U,g){return this._x===E&&this._y===U&&this._z===g}multiplyInPlace(E){return this._x*=E._x,this._y*=E._y,this._z*=E._z,this._isDirty=!0,this}multiply(E){return this.multiplyByFloats(E._x,E._y,E._z)}multiplyToRef(E,U){return U._x=this._x*E._x,U._y=this._y*E._y,U._z=this._z*E._z,U._isDirty=!0,U}multiplyByFloats(E,U,g){return new I(this._x*E,this._y*U,this._z*g)}divide(E){return new I(this._x/E._x,this._y/E._y,this._z/E._z)}divideToRef(E,U){return U._x=this._x/E._x,U._y=this._y/E._y,U._z=this._z/E._z,U._isDirty=!0,U}divideInPlace(E){return this._x=this._x/E._x,this._y=this._y/E._y,this._z=this._z/E._z,this._isDirty=!0,this}minimizeInPlace(E){return this.minimizeInPlaceFromFloats(E._x,E._y,E._z)}maximizeInPlace(E){return this.maximizeInPlaceFromFloats(E._x,E._y,E._z)}minimizeInPlaceFromFloats(E,U,g){return E<this._x&&(this.x=E),U<this._y&&(this.y=U),g<this._z&&(this.z=g),this}maximizeInPlaceFromFloats(E,U,g){return E>this._x&&(this.x=E),U>this._y&&(this.y=U),g>this._z&&(this.z=g),this}isNonUniformWithinEpsilon(E){const U=Math.abs(this._x),g=Math.abs(this._y);if(!(0,s.WithinEpsilon)(U,g,E))return!0;const N=Math.abs(this._z);return!(0,s.WithinEpsilon)(U,N,E)||!(0,s.WithinEpsilon)(g,N,E)}get isNonUniform(){const E=Math.abs(this._x);if(E!==Math.abs(this._y))return!0;return E!==Math.abs(this._z)}floorToRef(E){return E._x=Math.floor(this._x),E._y=Math.floor(this._y),E._z=Math.floor(this._z),E._isDirty=!0,E}floor(){return new I(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(E){return E._x=this._x-Math.floor(this._x),E._y=this._y-Math.floor(this._y),E._z=this._z-Math.floor(this._z),E._isDirty=!0,E}fract(){return new I(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(E){if("xyz"===(E=E.toLowerCase()))return this;const U=e.dU[0].D(this);return this.x=U[E[0]],this.y=U[E[1]],this.z=U[E[2]],this}rotateByQuaternionToRef(E,U){return E.toRotationMatrix(e.Matrix[0]),I.TransformCoordinatesToRef(this,e.Matrix[0],U),U}rotateByQuaternionAroundPointToRef(E,U,g){return this.subtractToRef(U,e.dU[0]),e.dU[0].rotateByQuaternionToRef(E,e.dU[0]),U.addToRef(e.dU[0],g),g}cross(E){return I.CrossToRef(this,E,new I)}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){return this.normalizeToRef(new I)}normalizeToRef(E){const U=this.length();return 0===U||1===U?(E._x=this._x,E._y=this._y,E._z=this._z,E._isDirty=!0,E):this.scaleToRef(1/U,E)}clone(){return new I(this._x,this._y,this._z)}D(E){return this.du(E._x,E._y,E._z)}du(E,U,g){return this._x=E,this._y=U,this._z=g,this._isDirty=!0,this}set(E,U,g){return this.du(E,U,g)}yu(E){return this._x=this._y=this._z=E,this._isDirty=!0,this}static GetClipFactor(E,U,g,N){const L=I.Dot(E,g);return(L-N)/(L-I.Dot(U,g))}static GetAngleBetweenVectors(E,U,g){const N=E.normalizeToRef(e.dU[1]),L=U.normalizeToRef(e.dU[2]);let D=I.Dot(N,L);D=(0,s.Clamp)(D,-1,1);const S=Math.acos(D),u=e.dU[3];return I.CrossToRef(N,L,u),I.Dot(u,g)>0?isNaN(S)?0:S:isNaN(S)?-Math.PI:-Math.acos(D)}static GetAngleBetweenVectorsOnPlane(E,U,g){e.dU[0].D(E);const N=e.dU[0];e.dU[1].D(U);const L=e.dU[1];e.dU[2].D(g);const D=e.dU[2],S=e.dU[3],u=e.dU[4];N.normalize(),L.normalize(),D.normalize(),I.CrossToRef(D,N,S),I.CrossToRef(S,D,u);const C=Math.atan2(I.Dot(L,S),I.Dot(L,u));return(0,s.NormalizeRadians)(C)}static PitchYawRollToMoveBetweenPointsToRef(E,U,g){const N=x.dU[0];return U.subtractToRef(E,N),g._y=Math.atan2(N.x,N.z)||0,g._x=Math.atan2(Math.sqrt(N.x**2+N.z**2),N.y)||0,g._z=0,g._isDirty=!0,g}static PitchYawRollToMoveBetweenPoints(E,U){const g=I.Zero();return I.PitchYawRollToMoveBetweenPointsToRef(E,U,g)}static SlerpToRef(E,U,g,L){g=(0,s.Clamp)(g,0,1);const D=e.dU[0],S=e.dU[1];D.D(E);const u=D.length();D.normalizeFromLength(u),S.D(U);const C=S.length();S.normalizeFromLength(C);const B=I.Dot(D,S);let P,F;if(B<1-N.c){const E=Math.acos(B),U=1/Math.sin(E);P=Math.sin((1-g)*E)*U,F=Math.sin(g*E)*U}else P=1-g,F=g;return D.scaleInPlace(P),S.scaleInPlace(F),L.D(D).addInPlace(S),L.scaleInPlace((0,s.Lerp)(u,C,g)),L}static SmoothToRef(E,U,g,N,L){return I.SlerpToRef(E,U,0===N?1:g/N,L),L}static eU(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new I(E[U],E[U+1],E[U+2])}static FromFloatArray(E,U){return I.eU(E,U)}static FromArrayToRef(E,U,g){return g._x=E[U],g._y=E[U+1],g._z=E[U+2],g._isDirty=!0,g}static FromFloatArrayToRef(E,U,g){return I.FromArrayToRef(E,U,g)}static FromFloatsToRef(E,U,g,N){return N.du(E,U,g),N}static Zero(){return new I(0,0,0)}static One(){return new I(1,1,1)}static Up(){return new I(0,1,0)}static get UpReadOnly(){return I._UpReadOnly}static get DownReadOnly(){return I._DownReadOnly}static get RightReadOnly(){return I._RightReadOnly}static get LeftReadOnly(){return I._LeftReadOnly}static get LeftHandedForwardReadOnly(){return I._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return I._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return I._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return I._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return I._ZeroReadOnly}static get OneReadOnly(){return I._OneReadOnly}static Down(){return new I(0,-1,0)}static Forward(){return new I(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new I(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new I(1,0,0)}static Left(){return new I(-1,0,0)}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new I((0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).du((0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U))}static TransformCoordinates(E,U){const g=I.Zero();return I.TransformCoordinatesToRef(E,U,g),g}static TransformCoordinatesToRef(E,U,g){return I.TransformCoordinatesFromFloatsToRef(E._x,E._y,E._z,U,g),g}static TransformCoordinatesFromFloatsToRef(E,U,g,N,L){const D=N.m,S=E*D[0]+U*D[4]+g*D[8]+D[12],u=E*D[1]+U*D[5]+g*D[9]+D[13],s=E*D[2]+U*D[6]+g*D[10]+D[14],C=1/(E*D[3]+U*D[7]+g*D[11]+D[15]);return L._x=S*C,L._y=u*C,L._z=s*C,L._isDirty=!0,L}static TransformNormal(E,U){const g=I.Zero();return I.TransformNormalToRef(E,U,g),g}static TransformNormalToRef(E,U,g){return this.TransformNormalFromFloatsToRef(E._x,E._y,E._z,U,g),g}static TransformNormalFromFloatsToRef(E,U,g,N,L){const D=N.m;return L._x=E*D[0]+U*D[4]+g*D[8],L._y=E*D[1]+U*D[5]+g*D[9],L._z=E*D[2]+U*D[6]+g*D[10],L._isDirty=!0,L}static CatmullRom(E,U,g,N,L){const D=L*L,S=L*D,u=.5*(2*U._x+(-E._x+g._x)*L+(2*E._x-5*U._x+4*g._x-N._x)*D+(-E._x+3*U._x-3*g._x+N._x)*S),s=.5*(2*U._y+(-E._y+g._y)*L+(2*E._y-5*U._y+4*g._y-N._y)*D+(-E._y+3*U._y-3*g._y+N._y)*S),C=.5*(2*U._z+(-E._z+g._z)*L+(2*E._z-5*U._z+4*g._z-N._z)*D+(-E._z+3*U._z-3*g._z+N._z)*S);return new I(u,s,C)}static Clamp(E,U,g){const N=new I;return I.ClampToRef(E,U,g,N),N}static ClampToRef(E,U,g,N){let L=E._x;L=L>g._x?g._x:L,L=L<U._x?U._x:L;let D=E._y;D=D>g._y?g._y:D,D=D<U._y?U._y:D;let S=E._z;return S=S>g._z?g._z:S,S=S<U._z?U._z:S,N.du(L,D,S),N}static CheckExtends(E,U,g){U.minimizeInPlace(E),g.maximizeInPlace(E)}static Hermite(E,U,g,N,L){const D=L*L,S=L*D,u=2*S-3*D+1,s=-2*S+3*D,C=S-2*D+L,B=S-D,P=E._x*u+g._x*s+U._x*C+N._x*B,F=E._y*u+g._y*s+U._y*C+N._y*B,f=E._z*u+g._z*s+U._z*C+N._z*B;return new I(P,F,f)}static Hermite1stDerivative(E,U,g,N,L){const D=new I;return this.Hermite1stDerivativeToRef(E,U,g,N,L,D),D}static Hermite1stDerivativeToRef(E,U,g,N,L,D){const S=L*L;return D._x=6*(S-L)*E._x+(3*S-4*L+1)*U._x+6*(-S+L)*g._x+(3*S-2*L)*N._x,D._y=6*(S-L)*E._y+(3*S-4*L+1)*U._y+6*(-S+L)*g._y+(3*S-2*L)*N._y,D._z=6*(S-L)*E._z+(3*S-4*L+1)*U._z+6*(-S+L)*g._z+(3*S-2*L)*N._z,D._isDirty=!0,D}static Lerp(E,U,g){const N=new I(0,0,0);return I.LerpToRef(E,U,g,N),N}static LerpToRef(E,U,g,N){return N._x=E._x+(U._x-E._x)*g,N._y=E._y+(U._y-E._y)*g,N._z=E._z+(U._z-E._z)*g,N._isDirty=!0,N}static Dot(E,U){return E._x*U._x+E._y*U._y+E._z*U._z}dot(E){return this._x*E._x+this._y*E._y+this._z*E._z}static Cross(E,U){const g=new I;return I.CrossToRef(E,U,g),g}static CrossToRef(E,U,g){const N=E._y*U._z-E._z*U._y,L=E._z*U._x-E._x*U._z,D=E._x*U._y-E._y*U._x;return g.du(N,L,D),g}static Normalize(E){const U=I.Zero();return I.NormalizeToRef(E,U),U}static NormalizeToRef(E,U){return E.normalizeToRef(U),U}static Project(E,U,g,N){const L=new I;return I.ProjectToRef(E,U,g,N,L),L}static ProjectToRef(E,U,g,N,L){var D;const S=N.width,s=N.height,C=N.x,B=N.y,P=e.Matrix[1],F=null===(D=u.b.LastCreatedEngine)||void 0===D?void 0:D.isNDCHalfZRange,f=F?1:.5,d=F?0:.5;V.FromValuesToRef(S/2,0,0,0,0,-s/2,0,0,0,0,f,0,C+S/2,s/2+B,d,1,P);const y=e.Matrix[0];return U.multiplyToRef(g,y),y.multiplyToRef(P,y),I.TransformCoordinatesToRef(E,y,L),L}static Reflect(E,U){return this.ReflectToRef(E,U,new I)}static ReflectToRef(E,U,g){const N=x.dU[0];return N.D(U).scaleInPlace(2*I.Dot(E,U)),g.D(E).iB(N)}static _UnprojectFromInvertedMatrixToRef(E,U,g){I.TransformCoordinatesToRef(E,U,g);const N=U.m,L=E._x*N[3]+E._y*N[7]+E._z*N[11]+N[15];return(0,s.WithinEpsilon)(L,1)&&g.scaleInPlace(1/L),g}static UnprojectFromTransform(E,U,g,N,L){return this.Unproject(E,U,g,N,L,V.IdentityReadOnly)}static Unproject(E,U,g,N,L,D){const S=new I;return I.UnprojectToRef(E,U,g,N,L,D,S),S}static UnprojectToRef(E,U,g,N,L,D,S){return I.UnprojectFloatsToRef(E._x,E._y,E._z,U,g,N,L,D,S),S}static UnprojectFloatsToRef(E,U,g,N,L,D,S,s,C){var B;const P=e.Matrix[0];D.multiplyToRef(S,P),P.multiplyToRef(s,P),P.invert();const F=e.dU[0];return F.x=E/N*2-1,F.y=-(U/L*2-1),null!==(B=u.b.LastCreatedEngine)&&void 0!==B&&B.isNDCHalfZRange?F.z=g:F.z=2*g-1,I._UnprojectFromInvertedMatrixToRef(F,P,C),C}static Minimize(E,U){const g=new I;return g.D(E),g.minimizeInPlace(U),g}static Maximize(E,U){const g=new I;return g.D(E),g.maximizeInPlace(U),g}static Distance(E,U){return Math.sqrt(I.DistanceSquared(E,U))}static DistanceSquared(E,U){const g=E._x-U._x,N=E._y-U._y,L=E._z-U._z;return g*g+N*N+L*L}static ProjectOnTriangleToRef(E,U,g,L,D){const S=e.dU[0],u=e.dU[1],C=e.dU[2],B=e.dU[3],P=e.dU[4];g.subtractToRef(U,S),L.subtractToRef(U,u),L.subtractToRef(g,C);const F=S.length(),f=u.length(),d=C.length();if(F<N.c||f<N.c||d<N.c)return D.D(U),I.Distance(E,U);E.subtractToRef(U,P),I.CrossToRef(S,u,B);const y=B.length();if(y<N.c)return D.D(U),I.Distance(E,U);B.normalizeFromLength(y);let h=P.length();if(h<N.c)return D.D(U),0;P.normalizeFromLength(h);const V=I.Dot(B,P),x=e.dU[5],l=e.dU[6];x.D(B).scaleInPlace(-h*V),l.D(E).addInPlace(x);const Y=e.dU[4],t=e.dU[5],G=e.dU[7],b=e.dU[8];Y.D(S).scaleInPlace(1/F),b.D(u).scaleInPlace(1/f),Y.addInPlace(b).scaleInPlace(-1),t.D(S).scaleInPlace(-1/F),b.D(C).scaleInPlace(1/d),t.addInPlace(b).scaleInPlace(-1),G.D(C).scaleInPlace(-1/d),b.D(u).scaleInPlace(-1/f),G.addInPlace(b).scaleInPlace(-1);const T=e.dU[9];let v;T.D(l).iB(U),I.CrossToRef(Y,T,b),v=I.Dot(b,B);const o=v;T.D(l).iB(g),I.CrossToRef(t,T,b),v=I.Dot(b,B);const c=v;T.D(l).iB(L),I.CrossToRef(G,T,b),v=I.Dot(b,B);const r=v,j=e.dU[10];let Z,A;o>0&&c<0?(j.D(S),Z=U,A=g):c>0&&r<0?(j.D(C),Z=g,A=L):(j.D(u).scaleInPlace(-1),Z=L,A=U);const w=e.dU[9],a=e.dU[4];Z.subtractToRef(l,b),A.subtractToRef(l,w),I.CrossToRef(b,w,a);if(!(I.Dot(a,B)<0))return D.D(l),Math.abs(h*V);const J=e.dU[5];I.CrossToRef(j,a,J),J.normalize();const q=e.dU[9];q.D(Z).iB(l);const M=q.length();if(M<N.c)return D.D(Z),I.Distance(E,Z);q.normalizeFromLength(M);const mE=I.Dot(J,q),W=e.dU[7];W.D(l).addInPlace(J.scaleInPlace(M*mE)),b.D(W).iB(Z),h=j.length(),j.normalizeFromLength(h);let O=I.Dot(b,j)/Math.max(h,N.c);return O=(0,s.Clamp)(O,0,1),W.D(Z).addInPlace(j.scaleInPlace(O*h)),D.D(W),I.Distance(E,W)}static Center(E,U){return I.CenterToRef(E,U,I.Zero())}static CenterToRef(E,U,g){return g.du((E._x+U._x)/2,(E._y+U._y)/2,(E._z+U._z)/2)}static RotationFromAxis(E,U,g){const N=new I;return I.RotationFromAxisToRef(E,U,g,N),N}static RotationFromAxisToRef(E,U,g,N){const L=e.Quaternion[0];return h.RotationQuaternionFromAxisToRef(E,U,g,L),L.toEulerAnglesToRef(N),N}}I._V8PerformanceHack=new I(.5,.5,.5),I._UpReadOnly=I.Up(),I._DownReadOnly=I.Down(),I._LeftHandedForwardReadOnly=I.Forward(!1),I._RightHandedForwardReadOnly=I.Forward(!0),I._LeftHandedBackwardReadOnly=I.Backward(!1),I._RightHandedBackwardReadOnly=I.Backward(!0),I._RightReadOnly=I.Right(),I._LeftReadOnly=I.Left(),I._ZeroReadOnly=I.Zero(),I._OneReadOnly=I.One(),Object.defineProperties(I.prototype,{dimension:{value:[3]},rank:{value:1}});class y{get x(){return this._x}set x(E){this._x=E,this._isDirty=!0}get y(){return this._y}set y(E){this._y=E,this._isDirty=!0}get z(){return this._z}set z(E){this._z=E,this._isDirty=!0}get w(){return this._w}set w(E){this._w=E,this._isDirty=!0}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=E,this._y=U,this._z=g,this._w=N}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let E=f(this._x);return E=397*E^f(this._y),E=397*E^f(this._z),E=397*E^f(this._w),E}Og(){return[this._x,this._y,this._z,this._w]}toArray(E,U){return void 0===U&&(U=0),E[U]=this._x,E[U+1]=this._y,E[U+2]=this._z,E[U+3]=this._w,this}Yg(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y.FromArrayToRef(E,U,this),this}addInPlace(E){return this.x+=E._x,this.y+=E._y,this.z+=E._z,this.w+=E._w,this}addInPlaceFromFloats(E,U,g,N){return this.x+=E,this.y+=U,this.z+=g,this.w+=N,this}add(E){return new y(this._x+E.x,this._y+E.y,this._z+E.z,this._w+E.w)}addToRef(E,U){return U.x=this._x+E.x,U.y=this._y+E.y,U.z=this._z+E.z,U.w=this._w+E.w,U}iB(E){return this.x-=E.x,this.y-=E.y,this.z-=E.z,this.w-=E.w,this}IU(E){return new y(this._x-E.x,this._y-E.y,this._z-E.z,this._w-E.w)}subtractToRef(E,U){return U.x=this._x-E.x,U.y=this._y-E.y,U.z=this._z-E.z,U.w=this._w-E.w,U}subtractFromFloats(E,U,g,N){return new y(this._x-E,this._y-U,this._z-g,this._w-N)}subtractFromFloatsToRef(E,U,g,N,L){return L.x=this._x-E,L.y=this._y-U,L.z=this._z-g,L.w=this._w-N,L}negate(){return new y(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(E){return E.x=-this._x,E.y=-this._y,E.z=-this._z,E.w=-this._w,E}scaleInPlace(E){return this.x*=E,this.y*=E,this.z*=E,this.w*=E,this}scale(E){return new y(this._x*E,this._y*E,this._z*E,this._w*E)}scaleToRef(E,U){return U.x=this._x*E,U.y=this._y*E,U.z=this._z*E,U.w=this._w*E,U}scaleAndAddToRef(E,U){return U.x+=this._x*E,U.y+=this._y*E,U.z+=this._z*E,U.w+=this._w*E,U}equals(E){return E&&this._x===E.x&&this._y===E.y&&this._z===E.z&&this._w===E.w}equalsWithEpsilon(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.c;return E&&(0,s.WithinEpsilon)(this._x,E.x,U)&&(0,s.WithinEpsilon)(this._y,E.y,U)&&(0,s.WithinEpsilon)(this._z,E.z,U)&&(0,s.WithinEpsilon)(this._w,E.w,U)}equalsToFloats(E,U,g,N){return this._x===E&&this._y===U&&this._z===g&&this._w===N}multiplyInPlace(E){return this.x*=E.x,this.y*=E.y,this.z*=E.z,this.w*=E.w,this}multiply(E){return new y(this._x*E.x,this._y*E.y,this._z*E.z,this._w*E.w)}multiplyToRef(E,U){return U.x=this._x*E.x,U.y=this._y*E.y,U.z=this._z*E.z,U.w=this._w*E.w,U}multiplyByFloats(E,U,g,N){return new y(this._x*E,this._y*U,this._z*g,this._w*N)}divide(E){return new y(this._x/E.x,this._y/E.y,this._z/E.z,this._w/E.w)}divideToRef(E,U){return U.x=this._x/E.x,U.y=this._y/E.y,U.z=this._z/E.z,U.w=this._w/E.w,U}divideInPlace(E){return this.divideToRef(E,this)}minimizeInPlace(E){return E.x<this._x&&(this.x=E.x),E.y<this._y&&(this.y=E.y),E.z<this._z&&(this.z=E.z),E.w<this._w&&(this.w=E.w),this}maximizeInPlace(E){return E.x>this._x&&(this.x=E.x),E.y>this._y&&(this.y=E.y),E.z>this._z&&(this.z=E.z),E.w>this._w&&(this.w=E.w),this}minimizeInPlaceFromFloats(E,U,g,N){return this.x=Math.min(E,this._x),this.y=Math.min(U,this._y),this.z=Math.min(g,this._z),this.w=Math.min(N,this._w),this}maximizeInPlaceFromFloats(E,U,g,N){return this.x=Math.max(E,this._x),this.y=Math.max(U,this._y),this.z=Math.max(g,this._z),this.w=Math.max(N,this._w),this}floorToRef(E){return E.x=Math.floor(this._x),E.y=Math.floor(this._y),E.z=Math.floor(this._z),E.w=Math.floor(this._w),E}floor(){return new y(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(E){return E.x=this._x-Math.floor(this._x),E.y=this._y-Math.floor(this._y),E.z=this._z-Math.floor(this._z),E.w=this._w-Math.floor(this._w),E}fract(){return new y(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){return this.normalizeToRef(new y)}normalizeToRef(E){const U=this.length();return 0===U||1===U?(E.x=this._x,E.y=this._y,E.z=this._z,E.w=this._w,E):this.scaleToRef(1/U,E)}toVector3(){return new I(this._x,this._y,this._z)}clone(){return new y(this._x,this._y,this._z,this._w)}D(E){return this.x=E.x,this.y=E.y,this.z=E.z,this.w=E.w,this}du(E,U,g,N){return this.x=E,this.y=U,this.z=g,this.w=N,this}set(E,U,g,N){return this.du(E,U,g,N)}yu(E){return this.x=this.y=this.z=this.w=E,this}dot(E){return this._x*E.x+this._y*E.y+this._z*E.z+this._w*E.w}static eU(E,U){return U||(U=0),new y(E[U],E[U+1],E[U+2],E[U+3])}static FromArrayToRef(E,U,g){return g.x=E[U],g.y=E[U+1],g.z=E[U+2],g.w=E[U+3],g}static FromFloatArrayToRef(E,U,g){return y.FromArrayToRef(E,U,g),g}static FromFloatsToRef(E,U,g,N,L){return L.x=E,L.y=U,L.z=g,L.w=N,L}static Zero(){return new y(0,0,0,0)}static One(){return new y(1,1,1,1)}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new y((0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,g=arguments.length>2?arguments[2]:void 0;return g.x=(0,s.RandomRange)(E,U),g.y=(0,s.RandomRange)(E,U),g.z=(0,s.RandomRange)(E,U),g.w=(0,s.RandomRange)(E,U),g}static Clamp(E,U,g){return y.ClampToRef(E,U,g,new y)}static ClampToRef(E,U,g,N){return N.x=(0,s.Clamp)(E.x,U.x,g.x),N.y=(0,s.Clamp)(E.y,U.y,g.y),N.z=(0,s.Clamp)(E.z,U.z,g.z),N.w=(0,s.Clamp)(E.w,U.w,g.w),N}static CheckExtends(E,U,g){U.minimizeInPlace(E),g.maximizeInPlace(E)}static get ZeroReadOnly(){return y._ZeroReadOnly}static Normalize(E){return y.NormalizeToRef(E,new y)}static NormalizeToRef(E,U){return E.normalizeToRef(U),U}static Minimize(E,U){const g=new y;return g.D(E),g.minimizeInPlace(U),g}static Maximize(E,U){const g=new y;return g.D(E),g.maximizeInPlace(U),g}static Distance(E,U){return Math.sqrt(y.DistanceSquared(E,U))}static DistanceSquared(E,U){const g=E.x-U.x,N=E.y-U.y,L=E.z-U.z,D=E.w-U.w;return g*g+N*N+L*L+D*D}static Center(E,U){return y.CenterToRef(E,U,new y)}static CenterToRef(E,U,g){return g.x=(E.x+U.x)/2,g.y=(E.y+U.y)/2,g.z=(E.z+U.z)/2,g.w=(E.w+U.w)/2,g}static TransformCoordinates(E,U){return y.TransformCoordinatesToRef(E,U,new y)}static TransformCoordinatesToRef(E,U,g){return y.TransformCoordinatesFromFloatsToRef(E._x,E._y,E._z,U,g),g}static TransformCoordinatesFromFloatsToRef(E,U,g,N,L){const D=N.m,S=E*D[0]+U*D[4]+g*D[8]+D[12],u=E*D[1]+U*D[5]+g*D[9]+D[13],s=E*D[2]+U*D[6]+g*D[10]+D[14],C=E*D[3]+U*D[7]+g*D[11]+D[15];return L.x=S,L.y=u,L.z=s,L.w=C,L}static TransformNormal(E,U){return y.TransformNormalToRef(E,U,new y)}static TransformNormalToRef(E,U,g){const N=U.m,L=E.x*N[0]+E.y*N[4]+E.z*N[8],D=E.x*N[1]+E.y*N[5]+E.z*N[9],S=E.x*N[2]+E.y*N[6]+E.z*N[10];return g.x=L,g.y=D,g.z=S,g.w=E.w,g}static TransformNormalFromFloatsToRef(E,U,g,N,L,D){const S=L.m;return D.x=E*S[0]+U*S[4]+g*S[8],D.y=E*S[1]+U*S[5]+g*S[9],D.z=E*S[2]+U*S[6]+g*S[10],D.w=N,D}static FromVector3(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new y(E._x,E._y,E._z,U)}static Dot(E,U){return E.x*U.x+E.y*U.y+E.z*U.z+E.w*U.w}}y._V8PerformanceHack=new y(.5,.5,.5,.5),y._ZeroReadOnly=y.Zero(),Object.defineProperties(y.prototype,{dimension:{value:[4]},rank:{value:1}});class h{get x(){return this._x}set x(E){this._x=E,this._isDirty=!0}get y(){return this._y}set y(E){this._y=E,this._isDirty=!0}get z(){return this._z}set z(E){this._z=E,this._isDirty=!0}get w(){return this._w}set w(E){this._w=E,this._isDirty=!0}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=E,this._y=U,this._z=g,this._w=N}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let E=f(this._x);return E=397*E^f(this._y),E=397*E^f(this._z),E=397*E^f(this._w),E}Og(){return[this._x,this._y,this._z,this._w]}toArray(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[U]=this._x,E[U+1]=this._y,E[U+2]=this._z,E[U+3]=this._w,this}Yg(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h.FromArrayToRef(E,U,this)}equals(E){return E&&this._x===E._x&&this._y===E._y&&this._z===E._z&&this._w===E._w}equalsWithEpsilon(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.c;return E&&(0,s.WithinEpsilon)(this._x,E._x,U)&&(0,s.WithinEpsilon)(this._y,E._y,U)&&(0,s.WithinEpsilon)(this._z,E._z,U)&&(0,s.WithinEpsilon)(this._w,E._w,U)}isApprox(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.c;return E&&((0,s.WithinEpsilon)(this._x,E._x,U)&&(0,s.WithinEpsilon)(this._y,E._y,U)&&(0,s.WithinEpsilon)(this._z,E._z,U)&&(0,s.WithinEpsilon)(this._w,E._w,U)||(0,s.WithinEpsilon)(this._x,-E._x,U)&&(0,s.WithinEpsilon)(this._y,-E._y,U)&&(0,s.WithinEpsilon)(this._z,-E._z,U)&&(0,s.WithinEpsilon)(this._w,-E._w,U))}clone(){return new h(this._x,this._y,this._z,this._w)}D(E){return this._x=E._x,this._y=E._y,this._z=E._z,this._w=E._w,this._isDirty=!0,this}du(E,U,g,N){return this._x=E,this._y=U,this._z=g,this._w=N,this._isDirty=!0,this}set(E,U,g,N){return this.du(E,U,g,N)}yu(E){return this.du(E,E,E,E)}add(E){return new h(this._x+E._x,this._y+E._y,this._z+E._z,this._w+E._w)}addInPlace(E){return this._x+=E._x,this._y+=E._y,this._z+=E._z,this._w+=E._w,this._isDirty=!0,this}addToRef(E,U){return U._x=this._x+E._x,U._y=this._y+E._y,U._z=this._z+E._z,U._w=this._w+E._w,U._isDirty=!0,U}addInPlaceFromFloats(E,U,g,N){return this._x+=E,this._y+=U,this._z+=g,this._w+=N,this._isDirty=!0,this}subtractToRef(E,U){return U._x=this._x-E._x,U._y=this._y-E._y,U._z=this._z-E._z,U._w=this._w-E._w,U._isDirty=!0,U}subtractFromFloats(E,U,g,N){return this.subtractFromFloatsToRef(E,U,g,N,new h)}subtractFromFloatsToRef(E,U,g,N,L){return L._x=this._x-E,L._y=this._y-U,L._z=this._z-g,L._w=this._w-N,L._isDirty=!0,L}IU(E){return new h(this._x-E._x,this._y-E._y,this._z-E._z,this._w-E._w)}iB(E){return this._x-=E._x,this._y-=E._y,this._z-=E._z,this._w-=E._w,this._isDirty=!0,this}scale(E){return new h(this._x*E,this._y*E,this._z*E,this._w*E)}scaleToRef(E,U){return U._x=this._x*E,U._y=this._y*E,U._z=this._z*E,U._w=this._w*E,U._isDirty=!0,U}scaleInPlace(E){return this._x*=E,this._y*=E,this._z*=E,this._w*=E,this._isDirty=!0,this}scaleAndAddToRef(E,U){return U._x+=this._x*E,U._y+=this._y*E,U._z+=this._z*E,U._w+=this._w*E,U._isDirty=!0,U}multiply(E){const U=new h(0,0,0,1);return this.multiplyToRef(E,U),U}multiplyToRef(E,U){const g=this._x*E._w+this._y*E._z-this._z*E._y+this._w*E._x,N=-this._x*E._z+this._y*E._w+this._z*E._x+this._w*E._y,L=this._x*E._y-this._y*E._x+this._z*E._w+this._w*E._z,D=-this._x*E._x-this._y*E._y-this._z*E._z+this._w*E._w;return U.du(g,N,L,D),U}multiplyInPlace(E){return this.multiplyToRef(E,this)}multiplyByFloats(E,U,g,N){return this._x*=E,this._y*=U,this._z*=g,this._w*=N,this._isDirty=!0,this}divide(E){throw new ReferenceError("Can not divide a quaternion")}divideToRef(E,U){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(E){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new h)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(E){return E._x=-this._x,E._y=-this._y,E._z=-this._z,E._w=-this._w,E._isDirty=!0,E}equalsToFloats(E,U,g,N){return this._x===E&&this._y===U&&this._z===g&&this._w===N}floorToRef(E){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(E){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(E){return E.du(-this._x,-this._y,-this._z,this._w),E}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new h(-this._x,-this._y,-this._z,this._w)}invert(){const E=this.conjugate(),U=this.lengthSquared();return 0==U||1==U||E.scaleInPlace(1/U),E}invertInPlace(){this.conjugateInPlace();const E=this.lengthSquared();return 0==E||1==E||this.scaleInPlace(1/E),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){const E=new h(0,0,0,1);return this.normalizeToRef(E),E}normalizeToRef(E){const U=this.length();return 0===U||1===U?E.du(this._x,this._y,this._z,this._w):this.scaleToRef(1/U,E)}toEulerAngles(){const E=I.Zero();return this.toEulerAnglesToRef(E),E}toEulerAnglesToRef(E){const U=this._z,g=this._x,N=this._y,L=this._w,D=N*U-g*L,S=.4999999;if(D<-S)E._y=2*Math.atan2(N,L),E._x=Math.PI/2,E._z=0,E._isDirty=!0;else if(D>S)E._y=2*Math.atan2(N,L),E._x=-Math.PI/2,E._z=0,E._isDirty=!0;else{const S=L*L,u=U*U,s=g*g,C=N*N;E._z=Math.atan2(2*(g*N+U*L),-u-s+C+S),E._x=Math.asin(-2*D),E._y=Math.atan2(2*(U*g+N*L),u-s-C+S),E._isDirty=!0}return E}toAlphaBetaGammaToRef(E){const U=this._z,g=this._x,N=this._y,L=this._w,D=Math.sqrt(g*g+N*N),S=Math.sqrt(U*U+L*L),u=2*Math.atan2(D,S),s=2*Math.atan2(U,L),C=2*Math.atan2(N,g),B=(s+C)/2,P=(s-C)/2;return E.set(P,u,B),E}toRotationMatrix(E){return V.FromQuaternionToRef(this,E),E}fromRotationMatrix(E){return h.FromRotationMatrixToRef(E,this),this}dot(E){return this._x*E._x+this._y*E._y+this._z*E._z+this._w*E._w}toAxisAngle(){const E=I.Zero();return{axis:E,angle:this.toAxisAngleToRef(E)}}toAxisAngleToRef(E){let U=0;const g=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),N=this._w;return g>0?(U=2*Math.atan2(g,N),E.set(this._x/g,this._y/g,this._z/g)):(U=0,E.set(1,0,0)),U}static FromRotationMatrix(E){const U=new h;return h.FromRotationMatrixToRef(E,U),U}static FromRotationMatrixToRef(E,U){const g=E.m,N=g[0],L=g[4],D=g[8],S=g[1],u=g[5],s=g[9],C=g[2],B=g[6],P=g[10],F=N+u+P;let f;return F>0?(f=.5/Math.sqrt(F+1),U._w=.25/f,U._x=(B-s)*f,U._y=(D-C)*f,U._z=(S-L)*f,U._isDirty=!0):N>u&&N>P?(f=2*Math.sqrt(1+N-u-P),U._w=(B-s)/f,U._x=.25*f,U._y=(L+S)/f,U._z=(D+C)/f,U._isDirty=!0):u>P?(f=2*Math.sqrt(1+u-N-P),U._w=(D-C)/f,U._x=(L+S)/f,U._y=.25*f,U._z=(s+B)/f,U._isDirty=!0):(f=2*Math.sqrt(1+P-N-u),U._w=(S-L)/f,U._x=(D+C)/f,U._y=(s+B)/f,U._z=.25*f,U._isDirty=!0),U}static Dot(E,U){return E._x*U._x+E._y*U._y+E._z*U._z+E._w*U._w}static AreClose(E,U){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const N=h.Dot(E,U);return 1-N*N<=g}static SmoothToRef(E,U,g,N,L){let D=0===N?1:g/N;return D=(0,s.Clamp)(D,0,1),h.SlerpToRef(E,U,D,L),L}static Zero(){return new h(0,0,0,0)}static Inverse(E){return new h(-E._x,-E._y,-E._z,E._w)}static InverseToRef(E,U){return U.set(-E._x,-E._y,-E._z,E._w),U}static Identity(){return new h(0,0,0,1)}static IsIdentity(E){return E&&0===E._x&&0===E._y&&0===E._z&&1===E._w}static RotationAxis(E,U){return h.RotationAxisToRef(E,U,new h)}static RotationAxisToRef(E,U,g){g._w=Math.cos(U/2);const N=Math.sin(U/2)/E.length();return g._x=E._x*N,g._y=E._y*N,g._z=E._z*N,g._isDirty=!0,g}static eU(E,U){return U||(U=0),new h(E[U],E[U+1],E[U+2],E[U+3])}static FromArrayToRef(E,U,g){return g._x=E[U],g._y=E[U+1],g._z=E[U+2],g._w=E[U+3],g._isDirty=!0,g}static FromFloatsToRef(E,U,g,N,L){return L.du(E,U,g,N),L}static FromEulerAngles(E,U,g){const N=new h;return h.RotationYawPitchRollToRef(U,E,g,N),N}static FromEulerAnglesToRef(E,U,g,N){return h.RotationYawPitchRollToRef(U,E,g,N),N}static FromEulerVector(E){const U=new h;return h.RotationYawPitchRollToRef(E._y,E._x,E._z,U),U}static FromEulerVectorToRef(E,U){return h.RotationYawPitchRollToRef(E._y,E._x,E._z,U),U}static FromUnitVectorsToRef(E,U,g){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N.c;const D=I.Dot(E,U)+1;return D<L?Math.abs(E.x)>Math.abs(E.z)?g.set(-E.y,E.x,0,0):g.set(0,-E.z,E.y,0):(I.CrossToRef(E,U,x.dU[0]),g.set(x.dU[0].x,x.dU[0].y,x.dU[0].z,D)),g.normalize()}static RotationYawPitchRoll(E,U,g){const N=new h;return h.RotationYawPitchRollToRef(E,U,g,N),N}static RotationYawPitchRollToRef(E,U,g,N){const L=.5*g,D=.5*U,S=.5*E,u=Math.sin(L),s=Math.cos(L),C=Math.sin(D),B=Math.cos(D),P=Math.sin(S),F=Math.cos(S);return N._x=F*C*s+P*B*u,N._y=P*B*s-F*C*u,N._z=F*B*u-P*C*s,N._w=F*B*s+P*C*u,N._isDirty=!0,N}static RotationAlphaBetaGamma(E,U,g){const N=new h;return h.RotationAlphaBetaGammaToRef(E,U,g,N),N}static RotationAlphaBetaGammaToRef(E,U,g,N){const L=.5*(g+E),D=.5*(g-E),S=.5*U;return N._x=Math.cos(D)*Math.sin(S),N._y=Math.sin(D)*Math.sin(S),N._z=Math.sin(L)*Math.cos(S),N._w=Math.cos(L)*Math.cos(S),N._isDirty=!0,N}static RotationQuaternionFromAxis(E,U,g){const N=new h(0,0,0,0);return h.RotationQuaternionFromAxisToRef(E,U,g,N),N}static RotationQuaternionFromAxisToRef(E,U,g,N){const L=e.Matrix[0];return E=E.normalizeToRef(e.dU[0]),U=U.normalizeToRef(e.dU[1]),g=g.normalizeToRef(e.dU[2]),V.FromXYZAxesToRef(E,U,g,L),h.FromRotationMatrixToRef(L,N),N}static FromLookDirectionLH(E,U){const g=new h;return h.FromLookDirectionLHToRef(E,U,g),g}static FromLookDirectionLHToRef(E,U,g){const N=e.Matrix[0];return V.LookDirectionLHToRef(E,U,N),h.FromRotationMatrixToRef(N,g),g}static FromLookDirectionRH(E,U){const g=new h;return h.FromLookDirectionRHToRef(E,U,g),g}static FromLookDirectionRHToRef(E,U,g){const N=e.Matrix[0];return V.LookDirectionRHToRef(E,U,N),h.FromRotationMatrixToRef(N,g)}static Slerp(E,U,g){const N=h.Identity();return h.SlerpToRef(E,U,g,N),N}static SlerpToRef(E,U,g,N){let L,D,S=E._x*U._x+E._y*U._y+E._z*U._z+E._w*U._w,u=!1;if(S<0&&(u=!0,S=-S),S>.999999)D=1-g,L=u?-g:g;else{const E=Math.acos(S),U=1/Math.sin(E);D=Math.sin((1-g)*E)*U,L=u?-Math.sin(g*E)*U:Math.sin(g*E)*U}return N._x=D*E._x+L*U._x,N._y=D*E._y+L*U._y,N._z=D*E._z+L*U._z,N._w=D*E._w+L*U._w,N._isDirty=!0,N}static Hermite(E,U,g,N,L){const D=L*L,S=L*D,u=2*S-3*D+1,s=-2*S+3*D,C=S-2*D+L,B=S-D,P=E._x*u+g._x*s+U._x*C+N._x*B,F=E._y*u+g._y*s+U._y*C+N._y*B,f=E._z*u+g._z*s+U._z*C+N._z*B,d=E._w*u+g._w*s+U._w*C+N._w*B;return new h(P,F,f,d)}static Hermite1stDerivative(E,U,g,N,L){const D=new h;return this.Hermite1stDerivativeToRef(E,U,g,N,L,D),D}static Hermite1stDerivativeToRef(E,U,g,N,L,D){const S=L*L;return D._x=6*(S-L)*E._x+(3*S-4*L+1)*U._x+6*(-S+L)*g._x+(3*S-2*L)*N._x,D._y=6*(S-L)*E._y+(3*S-4*L+1)*U._y+6*(-S+L)*g._y+(3*S-2*L)*N._y,D._z=6*(S-L)*E._z+(3*S-4*L+1)*U._z+6*(-S+L)*g._z+(3*S-2*L)*N._z,D._w=6*(S-L)*E._w+(3*S-4*L+1)*U._w+6*(-S+L)*g._w+(3*S-2*L)*N._w,D._isDirty=!0,D}static Normalize(E){const U=h.Zero();return h.NormalizeToRef(E,U),U}static NormalizeToRef(E,U){return E.normalizeToRef(U),U}static Clamp(E,U,g){const N=new h;return h.ClampToRef(E,U,g,N),N}static ClampToRef(E,U,g,N){return N.du((0,s.Clamp)(E.x,U.x,g.x),(0,s.Clamp)(E.y,U.y,g.y),(0,s.Clamp)(E.z,U.z,g.z),(0,s.Clamp)(E.w,U.w,g.w))}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new h((0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).du((0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U),(0,s.RandomRange)(E,U))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(E,U){return Math.sqrt(h.DistanceSquared(E,U))}static DistanceSquared(E,U){const g=E.x-U.x,N=E.y-U.y,L=E.z-U.z,D=E.w-U.w;return g*g+N*N+L*L+D*D}static Center(E,U){return h.CenterToRef(E,U,h.Zero())}static CenterToRef(E,U,g){return g.du((E.x+U.x)/2,(E.y+U.y)/2,(E.z+U.z)/2,(E.w+U.w)/2)}}h._V8PerformanceHack=new h(.5,.5,.5,.5),Object.defineProperties(h.prototype,{dimension:{value:[4]},rank:{value:1}});class V{static get Use64Bits(){return S.e.MatrixUse64Bits}get m(){return this.vg}markAsUpdated(){this.updateFlag=C._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(E){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1],g=arguments.length>2&&void 0!==arguments[2]&&arguments[2],N=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=E,this._isIdentity3x2=E||g,this._isIdentityDirty=!this._isIdentity&&U,this._isIdentity3x2Dirty=!this._isIdentity3x2&&N}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,S.e.MatrixTrackPrecisionChange&&S.e.MatrixTrackedMatrices.push(this),this.vg=new S.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const E=this.vg;this._isIdentity=1===E[0]&&0===E[1]&&0===E[2]&&0===E[3]&&0===E[4]&&1===E[5]&&0===E[6]&&0===E[7]&&0===E[8]&&0===E[9]&&1===E[10]&&0===E[11]&&0===E[12]&&0===E[13]&&0===E[14]&&1===E[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.vg[0]||1!==this.vg[5]||1!==this.vg[15]||0!==this.vg[1]||0!==this.vg[2]||0!==this.vg[3]||0!==this.vg[4]||0!==this.vg[6]||0!==this.vg[7]||0!==this.vg[8]||0!==this.vg[9]||0!==this.vg[10]||0!==this.vg[11]||0!==this.vg[12]||0!==this.vg[13]||0!==this.vg[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const E=this.vg,U=E[0],g=E[1],N=E[2],L=E[3],D=E[4],S=E[5],u=E[6],s=E[7],C=E[8],B=E[9],P=E[10],F=E[11],f=E[12],d=E[13],I=E[14],y=E[15],h=P*y-I*F,V=B*y-d*F,e=B*I-d*P,x=C*y-f*F,l=C*I-P*f,Y=C*d-f*B;return U*+(S*h-u*V+s*e)+g*-(D*h-u*x+s*l)+N*+(D*V-S*x+s*Y)+L*-(D*e-S*l+u*Y)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!E)return this.vg;const g=this.vg;for(let N=0;N<16;N++)E[U+N]=g[N];return this}Og(){return this.vg}Yg(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V.FromArrayToRef(E,U,this)}du(){for(var E=arguments.length,U=new Array(E),g=0;g<E;g++)U[g]=arguments[g];return V.FromArrayToRef(U,0,this)}set(){const E=this.vg;for(let U=0;U<16;U++)E[U]=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}yu(E){const U=this.vg;for(let g=0;g<16;g++)U[g]=E;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return V.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(E){const U=new V;return this.addToRef(E,U),U}addToRef(E,U){const g=this.vg,N=U.vg,L=E.m;for(let D=0;D<16;D++)N[D]=g[D]+L[D];return U.markAsUpdated(),U}addToSelf(E){const U=this.vg,g=E.m;return U[0]+=g[0],U[1]+=g[1],U[2]+=g[2],U[3]+=g[3],U[4]+=g[4],U[5]+=g[5],U[6]+=g[6],U[7]+=g[7],U[8]+=g[8],U[9]+=g[9],U[10]+=g[10],U[11]+=g[11],U[12]+=g[12],U[13]+=g[13],U[14]+=g[14],U[15]+=g[15],this.markAsUpdated(),this}addInPlace(E){const U=this.vg,g=E.m;for(let N=0;N<16;N++)U[N]+=g[N];return this.markAsUpdated(),this}addInPlaceFromFloats(){const E=this.vg;for(let U=0;U<16;U++)E[U]+=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}IU(E){const U=this.vg,g=E.m;for(let N=0;N<16;N++)U[N]-=g[N];return this.markAsUpdated(),this}subtractToRef(E,U){const g=this.vg,N=E.m,L=U.vg;for(let D=0;D<16;D++)L[D]=g[D]-N[D];return U.markAsUpdated(),U}iB(E){const U=this.vg,g=E.m;for(let N=0;N<16;N++)U[N]-=g[N];return this.markAsUpdated(),this}subtractFromFloats(){for(var E=arguments.length,U=new Array(E),g=0;g<E;g++)U[g]=arguments[g];return this.subtractFromFloatsToRef(...U,new V)}subtractFromFloatsToRef(){for(var E=arguments.length,U=new Array(E),g=0;g<E;g++)U[g]=arguments[g];const N=U.pop(),L=this.vg,D=N.vg,S=U;for(let u=0;u<16;u++)D[u]=L[u]-S[u];return N.markAsUpdated(),N}invertToRef(E){return!0===this._isIdentity?(V.IdentityToRef(E),E):(F(this,E.Og())?E.markAsUpdated():E.D(this),E)}addAtIndex(E,U){return this.vg[E]+=U,this.markAsUpdated(),this}multiplyAtIndex(E,U){return this.vg[E]*=U,this.markAsUpdated(),this}setTranslationFromFloats(E,U,g){return this.vg[12]=E,this.vg[13]=U,this.vg[14]=g,this.markAsUpdated(),this}addTranslationFromFloats(E,U,g){return this.vg[12]+=E,this.vg[13]+=U,this.vg[14]+=g,this.markAsUpdated(),this}setTranslation(E){return this.setTranslationFromFloats(E._x,E._y,E._z)}getTranslation(){return new I(this.vg[12],this.vg[13],this.vg[14])}getTranslationToRef(E){return E.x=this.vg[12],E.y=this.vg[13],E.z=this.vg[14],E}removeRotationAndScaling(){const E=this.m;return V.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,E[12],E[13],E[14],E[15],this),this._updateIdentityStatus(0===E[12]&&0===E[13]&&0===E[14]&&1===E[15]),this}D(E){E.copyToArray(this.vg);const U=E;return this.updateFlag=U.updateFlag,this._updateIdentityStatus(U._isIdentity,U._isIdentityDirty,U._isIdentity3x2,U._isIdentity3x2Dirty),this}copyToArray(E){return P(this,E,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(E){const U=new V;return this.multiplyToRef(E,U),U}multiplyInPlace(E){const U=this.vg,g=E.m;for(let N=0;N<16;N++)U[N]*=g[N];return this.markAsUpdated(),this}multiplyByFloats(){const E=this.vg;for(let U=0;U<16;U++)E[U]*=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var E=arguments.length,U=new Array(E),g=0;g<E;g++)U[g]=arguments[g];const N=U.pop(),L=this.vg,D=N.vg,S=U;for(let u=0;u<16;u++)D[u]=L[u]*S[u];return N.markAsUpdated(),N}multiplyToRef(E,U){return this._isIdentity?(U.D(E),U):E._isIdentity?(U.D(this),U):(this.multiplyToArray(E,U.vg,0),U.markAsUpdated(),U)}multiplyToArray(E,U,g){return B(this,E,U,g),this}divide(E){return this.divideToRef(E,new V)}divideToRef(E,U){const g=this.vg,N=E.m,L=U.vg;for(let D=0;D<16;D++)L[D]=g[D]/N[D];return U.markAsUpdated(),U}divideInPlace(E){const U=this.vg,g=E.m;for(let N=0;N<16;N++)U[N]/=g[N];return this.markAsUpdated(),this}minimizeInPlace(E){const U=this.vg,g=E.m;for(let N=0;N<16;N++)U[N]=Math.min(U[N],g[N]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const E=this.vg;for(let U=0;U<16;U++)E[U]=Math.min(E[U],U<0||arguments.length<=U?void 0:arguments[U]);return this.markAsUpdated(),this}maximizeInPlace(E){const U=this.vg,g=E.m;for(let N=0;N<16;N++)U[N]=Math.min(U[N],g[N]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const E=this.vg;for(let U=0;U<16;U++)E[U]=Math.min(E[U],U<0||arguments.length<=U?void 0:arguments[U]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new V)}negateInPlace(){const E=this.vg;for(let U=0;U<16;U++)E[U]=-E[U];return this.markAsUpdated(),this}negateToRef(E){const U=this.vg,g=E.vg;for(let N=0;N<16;N++)g[N]=-U[N];return E.markAsUpdated(),E}equals(E){const U=E;if(!U)return!1;if((this._isIdentity||U._isIdentity)&&!this._isIdentityDirty&&!U._isIdentityDirty)return this._isIdentity&&U._isIdentity;const g=this.m,N=U.m;return g[0]===N[0]&&g[1]===N[1]&&g[2]===N[2]&&g[3]===N[3]&&g[4]===N[4]&&g[5]===N[5]&&g[6]===N[6]&&g[7]===N[7]&&g[8]===N[8]&&g[9]===N[9]&&g[10]===N[10]&&g[11]===N[11]&&g[12]===N[12]&&g[13]===N[13]&&g[14]===N[14]&&g[15]===N[15]}equalsWithEpsilon(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const g=this.vg,N=E.m;for(let L=0;L<16;L++)if(!(0,s.WithinEpsilon)(g[L],N[L],U))return!1;return!0}equalsToFloats(){const E=this.vg;for(let U=0;U<16;U++)if(E[U]!=(U<0||arguments.length<=U?void 0:arguments[U]))return!1;return!0}floor(){return this.floorToRef(new V)}floorToRef(E){const U=this.vg,g=E.vg;for(let N=0;N<16;N++)g[N]=Math.floor(U[N]);return E.markAsUpdated(),E}fract(){return this.fractToRef(new V)}fractToRef(E){const U=this.vg,g=E.vg;for(let N=0;N<16;N++)g[N]=U[N]-Math.floor(U[N]);return E.markAsUpdated(),E}clone(){const E=new V;return E.D(this),E}getClassName(){return"Matrix"}getHashCode(){let E=f(this.vg[0]);for(let U=1;U<16;U++)E=397*E^f(this.vg[U]);return E}decomposeToTransformNode(E){return E.rotationQuaternion=E.rotationQuaternion||new h,this.decompose(E.Iu,E.rotationQuaternion,E.position)}decompose(E,U,g,N){let L=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return g&&g.yu(0),E&&E.yu(1),U&&U.du(0,0,0,1),!0;const D=this.vg;if(g&&g.du(D[12],D[13],D[14]),(E=E||e.dU[0]).x=Math.sqrt(D[0]*D[0]+D[1]*D[1]+D[2]*D[2]),E.y=Math.sqrt(D[4]*D[4]+D[5]*D[5]+D[6]*D[6]),E.z=Math.sqrt(D[8]*D[8]+D[9]*D[9]+D[10]*D[10]),N){const U=(L?N.absoluteScaling.x:N.Iu.x)<0?-1:1,g=(L?N.absoluteScaling.y:N.Iu.y)<0?-1:1,D=(L?N.absoluteScaling.z:N.Iu.z)<0?-1:1;E.x*=U,E.y*=g,E.z*=D}else this.determinant()<=0&&(E.y*=-1);if(0===E._x||0===E._y||0===E._z)return U&&U.du(0,0,0,1),!1;if(U){const g=1/E._x,N=1/E._y,L=1/E._z;V.FromValuesToRef(D[0]*g,D[1]*g,D[2]*g,0,D[4]*N,D[5]*N,D[6]*N,0,D[8]*L,D[9]*L,D[10]*L,0,0,0,0,1,e.Matrix[0]),h.FromRotationMatrixToRef(e.Matrix[0],U)}return!0}getRow(E){if(E<0||E>3)return null;const U=4*E;return new y(this.vg[U+0],this.vg[U+1],this.vg[U+2],this.vg[U+3])}getRowToRef(E,U){if(E>=0&&E<=3){const g=4*E;U.x=this.vg[g+0],U.y=this.vg[g+1],U.z=this.vg[g+2],U.w=this.vg[g+3]}return U}setRow(E,U){return this.setRowFromFloats(E,U.x,U.y,U.z,U.w)}transpose(){const E=new V;return V.TransposeToRef(this,E),E}transposeToRef(E){return V.TransposeToRef(this,E),E}setRowFromFloats(E,U,g,N,L){if(E<0||E>3)return this;const D=4*E;return this.vg[D+0]=U,this.vg[D+1]=g,this.vg[D+2]=N,this.vg[D+3]=L,this.markAsUpdated(),this}scale(E){const U=new V;return this.scaleToRef(E,U),U}scaleToRef(E,U){for(let g=0;g<16;g++)U.vg[g]=this.vg[g]*E;return U.markAsUpdated(),U}scaleAndAddToRef(E,U){for(let g=0;g<16;g++)U.vg[g]+=this.vg[g]*E;return U.markAsUpdated(),U}scaleInPlace(E){const U=this.vg;for(let g=0;g<16;g++)U[g]*=E;return this.markAsUpdated(),this}toNormalMatrix(E){const U=e.Matrix[0];this.invertToRef(U),U.transposeToRef(E);const g=E.vg;return V.FromValuesToRef(g[0],g[1],g[2],0,g[4],g[5],g[6],0,g[8],g[9],g[10],0,0,0,0,1,E),E}getRotationMatrix(){const E=new V;return this.getRotationMatrixToRef(E),E}getRotationMatrixToRef(E){const U=e.dU[0];if(!this.decompose(U))return V.IdentityToRef(E),E;const g=this.vg,N=1/U._x,L=1/U._y,D=1/U._z;return V.FromValuesToRef(g[0]*N,g[1]*N,g[2]*N,0,g[4]*L,g[5]*L,g[6]*L,0,g[8]*D,g[9]*D,g[10]*D,0,0,0,0,1,E),E}toggleModelMatrixHandInPlace(){const E=this.vg;return E[2]*=-1,E[6]*=-1,E[8]*=-1,E[9]*=-1,E[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const E=this.vg;return E[8]*=-1,E[9]*=-1,E[10]*=-1,E[11]*=-1,this.markAsUpdated(),this}static eU(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const g=new V;return V.FromArrayToRef(E,U,g),g}static FromArrayToRef(E,U,g){for(let N=0;N<16;N++)g.vg[N]=E[N+U];return g.markAsUpdated(),g}static FromFloat32ArrayToRefScaled(E,U,g,N){return N.vg[0]=E[0+U]*g,N.vg[1]=E[1+U]*g,N.vg[2]=E[2+U]*g,N.vg[3]=E[3+U]*g,N.vg[4]=E[4+U]*g,N.vg[5]=E[5+U]*g,N.vg[6]=E[6+U]*g,N.vg[7]=E[7+U]*g,N.vg[8]=E[8+U]*g,N.vg[9]=E[9+U]*g,N.vg[10]=E[10+U]*g,N.vg[11]=E[11+U]*g,N.vg[12]=E[12+U]*g,N.vg[13]=E[13+U]*g,N.vg[14]=E[14+U]*g,N.vg[15]=E[15+U]*g,N.markAsUpdated(),N}static get IdentityReadOnly(){return V._IdentityReadOnly}static FromValuesToRef(E,U,g,N,L,D,S,u,s,C,B,P,F,f,d,I,y){const h=y.vg;h[0]=E,h[1]=U,h[2]=g,h[3]=N,h[4]=L,h[5]=D,h[6]=S,h[7]=u,h[8]=s,h[9]=C,h[10]=B,h[11]=P,h[12]=F,h[13]=f,h[14]=d,h[15]=I,y.markAsUpdated()}static FromValues(E,U,g,N,L,D,S,u,s,C,B,P,F,f,d,I){const y=new V,h=y.vg;return h[0]=E,h[1]=U,h[2]=g,h[3]=N,h[4]=L,h[5]=D,h[6]=S,h[7]=u,h[8]=s,h[9]=C,h[10]=B,h[11]=P,h[12]=F,h[13]=f,h[14]=d,h[15]=I,y.markAsUpdated(),y}static Compose(E,U,g){const N=new V;return V.ComposeToRef(E,U,g,N),N}static ComposeToRef(E,U,g,N){const L=N.vg,D=U._x,S=U._y,u=U._z,s=U._w,C=D+D,B=S+S,P=u+u,F=D*C,f=D*B,d=D*P,I=S*B,y=S*P,h=u*P,V=s*C,e=s*B,x=s*P,l=E._x,Y=E._y,t=E._z;return L[0]=(1-(I+h))*l,L[1]=(f+x)*l,L[2]=(d-e)*l,L[3]=0,L[4]=(f-x)*Y,L[5]=(1-(F+h))*Y,L[6]=(y+V)*Y,L[7]=0,L[8]=(d+e)*t,L[9]=(y-V)*t,L[10]=(1-(F+I))*t,L[11]=0,L[12]=g._x,L[13]=g._y,L[14]=g._z,L[15]=1,N.markAsUpdated(),N}static Identity(){const E=V.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return E._updateIdentityStatus(!0),E}static IdentityToRef(E){return V.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,E),E._updateIdentityStatus(!0),E}static Zero(){const E=V.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return E._updateIdentityStatus(!1),E}static RotationX(E){const U=new V;return V.RotationXToRef(E,U),U}static Invert(E){const U=new V;return E.invertToRef(U),U}static RotationXToRef(E,U){const g=Math.sin(E),N=Math.cos(E);return V.FromValuesToRef(1,0,0,0,0,N,g,0,0,-g,N,0,0,0,0,1,U),U._updateIdentityStatus(1===N&&0===g),U}static RotationY(E){const U=new V;return V.RotationYToRef(E,U),U}static RotationYToRef(E,U){const g=Math.sin(E),N=Math.cos(E);return V.FromValuesToRef(N,0,-g,0,0,1,0,0,g,0,N,0,0,0,0,1,U),U._updateIdentityStatus(1===N&&0===g),U}static RotationZ(E){const U=new V;return V.RotationZToRef(E,U),U}static RotationZToRef(E,U){const g=Math.sin(E),N=Math.cos(E);return V.FromValuesToRef(N,g,0,0,-g,N,0,0,0,0,1,0,0,0,0,1,U),U._updateIdentityStatus(1===N&&0===g),U}static RotationAxis(E,U){const g=new V;return V.RotationAxisToRef(E,U,g),g}static RotationAxisToRef(E,U,g){const N=Math.sin(-U),L=Math.cos(-U),D=1-L;E=E.normalizeToRef(e.dU[0]);const S=g.vg;return S[0]=E._x*E._x*D+L,S[1]=E._x*E._y*D-E._z*N,S[2]=E._x*E._z*D+E._y*N,S[3]=0,S[4]=E._y*E._x*D+E._z*N,S[5]=E._y*E._y*D+L,S[6]=E._y*E._z*D-E._x*N,S[7]=0,S[8]=E._z*E._x*D-E._y*N,S[9]=E._z*E._y*D+E._x*N,S[10]=E._z*E._z*D+L,S[11]=0,S[12]=0,S[13]=0,S[14]=0,S[15]=1,g.markAsUpdated(),g}static RotationAlignToRef(E,U,g){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const D=I.Dot(U,E),S=g.vg;if(D<-1+N.c)S[0]=-1,S[1]=0,S[2]=0,S[3]=0,S[4]=0,S[5]=L?1:-1,S[6]=0,S[7]=0,S[8]=0,S[9]=0,S[10]=L?-1:1,S[11]=0;else{const g=I.Cross(U,E),N=1/(1+D);S[0]=g._x*g._x*N+D,S[1]=g._y*g._x*N-g._z,S[2]=g._z*g._x*N+g._y,S[3]=0,S[4]=g._x*g._y*N+g._z,S[5]=g._y*g._y*N+D,S[6]=g._z*g._y*N-g._x,S[7]=0,S[8]=g._x*g._z*N-g._y,S[9]=g._y*g._z*N+g._x,S[10]=g._z*g._z*N+D,S[11]=0}return S[12]=0,S[13]=0,S[14]=0,S[15]=1,g.markAsUpdated(),g}static RotationYawPitchRoll(E,U,g){const N=new V;return V.RotationYawPitchRollToRef(E,U,g,N),N}static RotationYawPitchRollToRef(E,U,g,N){return h.RotationYawPitchRollToRef(E,U,g,e.Quaternion[0]),e.Quaternion[0].toRotationMatrix(N),N}static Scaling(E,U,g){const N=new V;return V.ScalingToRef(E,U,g,N),N}static ScalingToRef(E,U,g,N){return V.FromValuesToRef(E,0,0,0,0,U,0,0,0,0,g,0,0,0,0,1,N),N._updateIdentityStatus(1===E&&1===U&&1===g),N}static Translation(E,U,g){const N=new V;return V.TranslationToRef(E,U,g,N),N}static TranslationToRef(E,U,g,N){return V.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,E,U,g,1,N),N._updateIdentityStatus(0===E&&0===U&&0===g),N}static Lerp(E,U,g){const N=new V;return V.LerpToRef(E,U,g,N),N}static LerpToRef(E,U,g,N){const L=N.vg,D=E.m,S=U.m;for(let u=0;u<16;u++)L[u]=D[u]*(1-g)+S[u]*g;return N.markAsUpdated(),N}static DecomposeLerp(E,U,g){const N=new V;return V.DecomposeLerpToRef(E,U,g,N),N}static DecomposeLerpToRef(E,U,g,N){const L=e.dU[0],D=e.Quaternion[0],S=e.dU[1];E.decompose(L,D,S);const u=e.dU[2],s=e.Quaternion[1],C=e.dU[3];U.decompose(u,s,C);const B=e.dU[4];I.LerpToRef(L,u,g,B);const P=e.Quaternion[2];h.SlerpToRef(D,s,g,P);const F=e.dU[5];return I.LerpToRef(S,C,g,F),V.ComposeToRef(B,P,F,N),N}static LookAtLH(E,U,g){const N=new V;return V.LookAtLHToRef(E,U,g,N),N}static LookAtLHToRef(E,U,g,N){const L=e.dU[0],D=e.dU[1],S=e.dU[2];U.subtractToRef(E,S),S.normalize(),I.CrossToRef(g,S,L);const u=L.lengthSquared();0===u?L.x=1:L.normalizeFromLength(Math.sqrt(u)),I.CrossToRef(S,L,D),D.normalize();const s=-I.Dot(L,E),C=-I.Dot(D,E),B=-I.Dot(S,E);return V.FromValuesToRef(L._x,D._x,S._x,0,L._y,D._y,S._y,0,L._z,D._z,S._z,0,s,C,B,1,N),N}static LookAtRH(E,U,g){const N=new V;return V.LookAtRHToRef(E,U,g,N),N}static LookAtRHToRef(E,U,g,N){const L=e.dU[0],D=e.dU[1],S=e.dU[2];E.subtractToRef(U,S),S.normalize(),I.CrossToRef(g,S,L);const u=L.lengthSquared();0===u?L.x=1:L.normalizeFromLength(Math.sqrt(u)),I.CrossToRef(S,L,D),D.normalize();const s=-I.Dot(L,E),C=-I.Dot(D,E),B=-I.Dot(S,E);return V.FromValuesToRef(L._x,D._x,S._x,0,L._y,D._y,S._y,0,L._z,D._z,S._z,0,s,C,B,1,N),N}static LookDirectionLH(E,U){const g=new V;return V.LookDirectionLHToRef(E,U,g),g}static LookDirectionLHToRef(E,U,g){const N=e.dU[0];N.D(E),N.scaleInPlace(-1);const L=e.dU[1];return I.CrossToRef(U,N,L),V.FromValuesToRef(L._x,L._y,L._z,0,U._x,U._y,U._z,0,N._x,N._y,N._z,0,0,0,0,1,g),g}static LookDirectionRH(E,U){const g=new V;return V.LookDirectionRHToRef(E,U,g),g}static LookDirectionRHToRef(E,U,g){const N=e.dU[2];return I.CrossToRef(U,E,N),V.FromValuesToRef(N._x,N._y,N._z,0,U._x,U._y,U._z,0,E._x,E._y,E._z,0,0,0,0,1,g),g}static OrthoLH(E,U,g,N,L){const D=new V;return V.OrthoLHToRef(E,U,g,N,D,L),D}static OrthoLHToRef(E,U,g,N,L,D){const S=2/E,u=2/U,s=2/(N-g),C=-(N+g)/(N-g);return V.FromValuesToRef(S,0,0,0,0,u,0,0,0,0,s,0,0,0,C,1,L),D&&L.multiplyToRef(l,L),L._updateIdentityStatus(1===S&&1===u&&1===s&&0===C),L}static OrthoOffCenterLH(E,U,g,N,L,D,S){const u=new V;return V.OrthoOffCenterLHToRef(E,U,g,N,L,D,u,S),u}static OrthoOffCenterLHToRef(E,U,g,N,L,D,S,u){const s=2/(U-E),C=2/(N-g),B=2/(D-L),P=-(D+L)/(D-L),F=(E+U)/(E-U),f=(N+g)/(g-N);return V.FromValuesToRef(s,0,0,0,0,C,0,0,0,0,B,0,F,f,P,1,S),u&&S.multiplyToRef(l,S),S.markAsUpdated(),S}static ObliqueOffCenterLHToRef(E,U,g,N,L,D,S,u,s,C,B){const P=-S*Math.cos(u),F=-S*Math.sin(u);return V.TranslationToRef(0,0,-s,e.Matrix[1]),V.FromValuesToRef(1,0,0,0,0,1,0,0,P,F,1,0,0,0,0,1,e.Matrix[0]),e.Matrix[1].multiplyToRef(e.Matrix[0],e.Matrix[0]),V.TranslationToRef(0,0,s,e.Matrix[1]),e.Matrix[0].multiplyToRef(e.Matrix[1],e.Matrix[0]),V.OrthoOffCenterLHToRef(E,U,g,N,L,D,C,B),e.Matrix[0].multiplyToRef(C,C),C}static OrthoOffCenterRH(E,U,g,N,L,D,S){const u=new V;return V.OrthoOffCenterRHToRef(E,U,g,N,L,D,u,S),u}static OrthoOffCenterRHToRef(E,U,g,N,L,D,S,u){return V.OrthoOffCenterLHToRef(E,U,g,N,L,D,S,u),S.vg[10]*=-1,S}static ObliqueOffCenterRHToRef(E,U,g,N,L,D,S,u,s,C,B){const P=S*Math.cos(u),F=S*Math.sin(u);return V.TranslationToRef(0,0,s,e.Matrix[1]),V.FromValuesToRef(1,0,0,0,0,1,0,0,P,F,1,0,0,0,0,1,e.Matrix[0]),e.Matrix[1].multiplyToRef(e.Matrix[0],e.Matrix[0]),V.TranslationToRef(0,0,-s,e.Matrix[1]),e.Matrix[0].multiplyToRef(e.Matrix[1],e.Matrix[0]),V.OrthoOffCenterRHToRef(E,U,g,N,L,D,C,B),e.Matrix[0].multiplyToRef(C,C),C}static PerspectiveLH(E,U,g,N,L){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const S=new V,u=2*g/E,s=2*g/U,C=(N+g)/(N-g),B=-2*N*g/(N-g),P=Math.tan(D);return V.FromValuesToRef(u,0,0,0,0,s,0,P,0,0,C,1,0,0,B,0,S),L&&S.multiplyToRef(l,S),S._updateIdentityStatus(!1),S}static PerspectiveFovLH(E,U,g,N,L){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,S=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const u=new V;return V.PerspectiveFovLHToRef(E,U,g,N,u,!0,L,D,S),u}static PerspectiveFovLHToRef(E,U,g,N,L){let D=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],S=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,s=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const C=g,B=N,P=1/Math.tan(.5*E),F=D?P/U:P,f=D?P:P*U,d=s&&0===C?-1:0!==B?(B+C)/(B-C):1,I=s&&0===C?2*B:0!==B?-2*B*C/(B-C):-2*C,y=Math.tan(u);return V.FromValuesToRef(F,0,0,0,0,f,0,y,0,0,d,1,0,0,I,0,L),S&&L.multiplyToRef(l,L),L._updateIdentityStatus(!1),L}static PerspectiveFovReverseLHToRef(E,U,g,N,L){let D=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],S=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const s=1/Math.tan(.5*E),C=D?s/U:s,B=D?s:s*U,P=Math.tan(u);return V.FromValuesToRef(C,0,0,0,0,B,0,P,0,0,-g,1,0,0,1,0,L),S&&L.multiplyToRef(l,L),L._updateIdentityStatus(!1),L}static PerspectiveFovRH(E,U,g,N,L){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,S=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const u=new V;return V.PerspectiveFovRHToRef(E,U,g,N,u,!0,L,D,S),u}static PerspectiveFovRHToRef(E,U,g,N,L){let D=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],S=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,s=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const C=g,B=N,P=1/Math.tan(.5*E),F=D?P/U:P,f=D?P:P*U,d=s&&0===C?1:0!==B?-(B+C)/(B-C):-1,I=s&&0===C?2*B:0!==B?-2*B*C/(B-C):-2*C,y=Math.tan(u);return V.FromValuesToRef(F,0,0,0,0,f,0,y,0,0,d,-1,0,0,I,0,L),S&&L.multiplyToRef(l,L),L._updateIdentityStatus(!1),L}static PerspectiveFovReverseRHToRef(E,U,g,N,L){let D=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],S=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const s=1/Math.tan(.5*E),C=D?s/U:s,B=D?s:s*U,P=Math.tan(u);return V.FromValuesToRef(C,0,0,0,0,B,0,P,0,0,-g,-1,0,0,-1,0,L),S&&L.multiplyToRef(l,L),L._updateIdentityStatus(!1),L}static GetFinalMatrix(E,U,g,N,L,D){const S=E.width,u=E.height,s=E.x,C=E.y,B=V.FromValues(S/2,0,0,0,0,-u/2,0,0,0,0,D-L,0,s+S/2,u/2+C,L,1),P=new V;return U.multiplyToRef(g,P),P.multiplyToRef(N,P),P.multiplyToRef(B,P)}static GetAsMatrix2x2(E){const U=E.m,g=[U[0],U[1],U[4],U[5]];return S.e.MatrixUse64Bits?g:new Float32Array(g)}static GetAsMatrix3x3(E){const U=E.m,g=[U[0],U[1],U[2],U[4],U[5],U[6],U[8],U[9],U[10]];return S.e.MatrixUse64Bits?g:new Float32Array(g)}static Transpose(E){const U=new V;return V.TransposeToRef(E,U),U}static TransposeToRef(E,U){const g=E.m,N=g[0],L=g[4],D=g[8],S=g[12],u=g[1],s=g[5],C=g[9],B=g[13],P=g[2],F=g[6],f=g[10],d=g[14],I=g[3],y=g[7],h=g[11],V=g[15],e=U.vg;return e[0]=N,e[1]=L,e[2]=D,e[3]=S,e[4]=u,e[5]=s,e[6]=C,e[7]=B,e[8]=P,e[9]=F,e[10]=f,e[11]=d,e[12]=I,e[13]=y,e[14]=h,e[15]=V,U.markAsUpdated(),U._updateIdentityStatus(E._isIdentity,E._isIdentityDirty),U}static Reflection(E){const U=new V;return V.ReflectionToRef(E,U),U}static ReflectionToRef(E,U){E.normalize();const g=E.normal.x,N=E.normal.y,L=E.normal.z,D=-2*g,S=-2*N,u=-2*L;return V.FromValuesToRef(D*g+1,S*g,u*g,0,D*N,S*N+1,u*N,0,D*L,S*L,u*L+1,0,D*E.d,S*E.d,u*E.d,1,U),U}static FromXYZAxesToRef(E,U,g,N){return V.FromValuesToRef(E._x,E._y,E._z,0,U._x,U._y,U._z,0,g._x,g._y,g._z,0,0,0,0,1,N),N}static FromQuaternionToRef(E,U){const g=E._x*E._x,N=E._y*E._y,L=E._z*E._z,D=E._x*E._y,S=E._z*E._w,u=E._z*E._x,s=E._y*E._w,C=E._y*E._z,B=E._x*E._w;return U.vg[0]=1-2*(N+L),U.vg[1]=2*(D+S),U.vg[2]=2*(u-s),U.vg[3]=0,U.vg[4]=2*(D-S),U.vg[5]=1-2*(L+g),U.vg[6]=2*(C+B),U.vg[7]=0,U.vg[8]=2*(u+s),U.vg[9]=2*(C-B),U.vg[10]=1-2*(N+g),U.vg[11]=0,U.vg[12]=0,U.vg[13]=0,U.vg[14]=0,U.vg[15]=1,U.markAsUpdated(),U}}V._IdentityReadOnly=V.Identity(),Object.defineProperties(V.prototype,{dimension:{value:[4,4]},rank:{value:2}});class e{}e.dU=(0,L.e)(11,I.Zero),e.Matrix=(0,L.e)(2,V.Identity),e.Quaternion=(0,L.e)(3,h.Zero);class x{}x.Vector2=(0,L.e)(3,d.Zero),x.dU=(0,L.e)(13,I.Zero),x.Vector4=(0,L.e)(3,y.Zero),x.Quaternion=(0,L.e)(3,h.Zero),x.Matrix=(0,L.e)(8,V.Identity),(0,D.f)("BABYLON.Vector2",d),(0,D.f)("BABYLON.Vector3",I),(0,D.f)("BABYLON.Vector4",y),(0,D.f)("BABYLON.Matrix",V);const l=V.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12345:(E,U,g)=>{function N(E,U){const g=[];for(let N=0;N<E;++N)g.push(U());return g}function L(E,U){return N(E,U)}g.d(U,{b:()=>N,e:()=>L,g:()=>S});const D=["push","splice","pop","shift","unshift"];function S(E,U){const g=D.map((g=>function(E,U,g){const N=E[U];if("function"!==typeof N)return null;const L=function(){const N=E.length,D=L.previous.apply(E,arguments);return g(U,N),D};return N.next=L,L.previous=N,E[U]=L,()=>{const g=L.previous;if(!g)return;const N=L.next;N?(g.next=N,N.previous=g):(g.next=void 0,E[U]=g),L.next=void 0,L.previous=void 0}}(E,g,U)));return()=>{for(const E of g)null===E||void 0===E||E()}}}}]);