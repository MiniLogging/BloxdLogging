"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{11147:(h,V,i)=>{i.d(V,{c:()=>g,d:()=>Y,h:()=>S,j:()=>l});const S=1/2.2,l=2.2,Y=(1+Math.sqrt(5))/2,g=.001},11162:(h,V,i)=>{function S(h){return parseInt(h.toString().replace(/\W/g,""))}function l(h,V){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(h-V)<=i}function Y(h,V,i){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return h<V-S||h>i+S}function g(h,V){return h===V?h:Math.random()*(V-h)+h}function q(h,V,i){return h+(V-h)*i}function B(h,V,i){let S=n(V-h,360);return S>180&&(S-=360),h+S*s(i)}function J(h,V,i){let S=0;return S=h!=V?s((i-h)/(V-h)):0,S}function I(h,V,i,S,l){const Y=l*l,g=l*Y;return h*(2*g-3*Y+1)+i*(-2*g+3*Y)+V*(g-2*Y+l)+S*(g-Y)}function v(h,V,i,S,l){const Y=l*l;return 6*(Y-l)*h+(3*Y-4*l+1)*V+6*(-Y+l)*i+(3*Y-2*l)*S}function s(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(i,Math.max(V,h))}function t(h){return h-=2*Math.PI*Math.floor((h+Math.PI)/(2*Math.PI))}function T(h){const V=h.toString(16);return h<=15?("0"+V).toUpperCase():V.toUpperCase()}function e(h){if(Math.log2)return Math.floor(Math.log2(h));if(h<0)return NaN;if(0===h)return-1/0;let V=0;if(h<1){for(;h<1;)V++,h*=2;V=-V}else if(h>1)for(;h>1;)V++,h=Math.floor(h/2);return V}function n(h,V){return h-Math.floor(h/V)*V}function c(h,V,i){return(h-V)/(i-V)}function f(h,V,i){return h*(i-V)+V}function P(h,V){let i=n(V-h,360);return i>180&&(i-=360),i}function L(h,V){const i=n(h,2*V);return V-Math.abs(i-V)}function U(h,V,i){let S=s(i);return S=-2*S*S*S+3*S*S,V*S+h*(1-S)}function X(h,V,i){let S=0;return S=Math.abs(V-h)<=i?V:h+Math.sign(V-h)*i,S}function D(h,V,i){const S=P(h,V);let l=0;return l=-i<S&&S<i?V:X(h,V=h+S,i),l}function O(h,V,i){return(h-V)/(i-V)}function o(h,V,i){return(i-V)*h+V}function M(h,V){const i=h%V;return 0===i?V:M(V,i)}i.r(V),i.d(V,{Clamp:()=>s,DeltaAngle:()=>P,Denormalize:()=>f,ExtractAsInt:()=>S,Hermite:()=>I,Hermite1stDerivative:()=>v,HighestCommonFactor:()=>M,ILog2:()=>e,InverseLerp:()=>J,Lerp:()=>q,LerpAngle:()=>B,MoveTowards:()=>X,MoveTowardsAngle:()=>D,Normalize:()=>c,NormalizeRadians:()=>t,OutsideRange:()=>Y,PercentToRange:()=>o,PingPong:()=>L,RandomRange:()=>g,RangeToPercent:()=>O,Repeat:()=>n,SmoothStep:()=>U,ToHex:()=>T,WithinEpsilon:()=>l})},11138:(h,V,i)=>{i.r(V),i.d(V,{Matrix:()=>f,Quaternion:()=>c,TmpVectors:()=>L,Vector2:()=>T,nV:()=>e,Vector4:()=>n});var S=i(11147),l=i(11156),Y=i(11091),g=i(11057),q=i(10988),B=i(11162);class J{}function I(h,V,i){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const l=h.Ng(),Y=V.Ng(),g=l[0],q=l[1],B=l[2],J=l[3],I=l[4],v=l[5],s=l[6],t=l[7],T=l[8],e=l[9],n=l[10],c=l[11],f=l[12],P=l[13],L=l[14],U=l[15],X=Y[0],D=Y[1],O=Y[2],o=Y[3],M=Y[4],F=Y[5],E=Y[6],H=Y[7],j=Y[8],m=Y[9],G=Y[10],w=Y[11],N=Y[12],r=Y[13],k=Y[14],R=Y[15];i[S]=g*X+q*M+B*j+J*N,i[S+1]=g*D+q*F+B*m+J*r,i[S+2]=g*O+q*E+B*G+J*k,i[S+3]=g*o+q*H+B*w+J*R,i[S+4]=I*X+v*M+s*j+t*N,i[S+5]=I*D+v*F+s*m+t*r,i[S+6]=I*O+v*E+s*G+t*k,i[S+7]=I*o+v*H+s*w+t*R,i[S+8]=T*X+e*M+n*j+c*N,i[S+9]=T*D+e*F+n*m+c*r,i[S+10]=T*O+e*E+n*G+c*k,i[S+11]=T*o+e*H+n*w+c*R,i[S+12]=f*X+P*M+L*j+U*N,i[S+13]=f*D+P*F+L*m+U*r,i[S+14]=f*O+P*E+L*G+U*k,i[S+15]=f*o+P*H+L*w+U*R}function v(h,V){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const S=h.Ng();V[i]=S[0],V[i+1]=S[1],V[i+2]=S[2],V[i+3]=S[3],V[i+4]=S[4],V[i+5]=S[5],V[i+6]=S[6],V[i+7]=S[7],V[i+8]=S[8],V[i+9]=S[9],V[i+10]=S[10],V[i+11]=S[11],V[i+12]=S[12],V[i+13]=S[13],V[i+14]=S[14],V[i+15]=S[15]}function s(h,V){const i=h.Ng(),S=i[0],l=i[1],Y=i[2],g=i[3],q=i[4],B=i[5],J=i[6],I=i[7],v=i[8],s=i[9],t=i[10],T=i[11],e=i[12],n=i[13],c=i[14],f=i[15],P=t*f-c*T,L=s*f-n*T,U=s*c-n*t,X=v*f-e*T,D=v*c-t*e,O=v*n-e*s,o=+(B*P-J*L+I*U),M=-(q*P-J*X+I*D),F=+(q*L-B*X+I*O),E=-(q*U-B*D+J*O),H=S*o+l*M+Y*F+g*E;if(0===H)return!1;const j=1/H,m=J*f-c*I,G=B*f-n*I,w=B*c-n*J,N=q*f-e*I,r=q*c-e*J,k=q*n-e*B,R=J*T-t*I,Z=B*T-s*I,z=B*t-s*J,d=q*T-v*I,x=q*t-v*J,y=q*s-v*B,Q=-(l*P-Y*L+g*U),A=+(S*P-Y*X+g*D),b=-(S*L-l*X+g*O),C=+(S*U-l*D+Y*O),u=+(l*m-Y*G+g*w),p=-(S*m-Y*N+g*r),W=+(S*G-l*N+g*k),a=-(S*w-l*r+Y*k),K=-(l*R-Y*Z+g*z),hh=+(S*R-Y*d+g*x),Vh=-(S*Z-l*d+g*y),ih=+(S*z-l*x+Y*y);return V[0]=o*j,V[1]=Q*j,V[2]=u*j,V[3]=K*j,V[4]=M*j,V[5]=A*j,V[6]=p*j,V[7]=hh*j,V[8]=F*j,V[9]=b*j,V[10]=W*j,V[11]=Vh*j,V[12]=E*j,V[13]=C*j,V[14]=a*j,V[15]=ih*j,!0}J._UpdateFlagSeed=0;const t=h=>parseInt(h.toString().replace(/\W/g,""));class T{constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=h,this.y=V}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let h=t(this.x);return h=397*h^t(this.y),h}toArray(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[V]=this.x,h[V+1]=this.y,this}ei(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return T.FromArrayToRef(h,V,this),this}Ng(){return[this.x,this.y]}l(h){return this.x=h.x,this.y=h.y,this}qq(h,V){return this.x=h,this.y=V,this}set(h,V){return this.qq(h,V)}Iq(h){return this.qq(h,h)}add(h){return new T(this.x+h.x,this.y+h.y)}addToRef(h,V){return V.x=this.x+h.x,V.y=this.y+h.y,V}addInPlace(h){return this.x+=h.x,this.y+=h.y,this}addInPlaceFromFloats(h,V){return this.x+=h,this.y+=V,this}addVector3(h){return new T(this.x+h.x,this.y+h.y)}cV(h){return new T(this.x-h.x,this.y-h.y)}subtractToRef(h,V){return V.x=this.x-h.x,V.y=this.y-h.y,V}mI(h){return this.x-=h.x,this.y-=h.y,this}multiplyInPlace(h){return this.x*=h.x,this.y*=h.y,this}multiply(h){return new T(this.x*h.x,this.y*h.y)}multiplyToRef(h,V){return V.x=this.x*h.x,V.y=this.y*h.y,V}multiplyByFloats(h,V){return new T(this.x*h,this.y*V)}divide(h){return new T(this.x/h.x,this.y/h.y)}divideToRef(h,V){return V.x=this.x/h.x,V.y=this.y/h.y,V}divideInPlace(h){return this.x=this.x/h.x,this.y=this.y/h.y,this}minimizeInPlace(h){return this.minimizeInPlaceFromFloats(h.x,h.y)}maximizeInPlace(h){return this.maximizeInPlaceFromFloats(h.x,h.y)}minimizeInPlaceFromFloats(h,V){return this.x=Math.min(h,this.x),this.y=Math.min(V,this.y),this}maximizeInPlaceFromFloats(h,V){return this.x=Math.max(h,this.x),this.y=Math.max(V,this.y),this}subtractFromFloats(h,V){return new T(this.x-h,this.y-V)}subtractFromFloatsToRef(h,V,i){return i.x=this.x-h,i.y=this.y-V,i}negate(){return new T(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(h){return h.x=-this.x,h.y=-this.y,h}scaleInPlace(h){return this.x*=h,this.y*=h,this}scale(h){return new T(this.x*h,this.y*h)}scaleToRef(h,V){return V.x=this.x*h,V.y=this.y*h,V}scaleAndAddToRef(h,V){return V.x+=this.x*h,V.y+=this.y*h,V}equals(h){return h&&this.x===h.x&&this.y===h.y}equalsWithEpsilon(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.c;return h&&(0,B.WithinEpsilon)(this.x,h.x,V)&&(0,B.WithinEpsilon)(this.y,h.y,V)}equalsToFloats(h,V){return this.x===h&&this.y===V}floor(){return new T(Math.floor(this.x),Math.floor(this.y))}floorToRef(h){return h.x=Math.floor(this.x),h.y=Math.floor(this.y),h}fract(){return new T(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(h){return h.x=this.x-Math.floor(this.x),h.y=this.y-Math.floor(this.y),h}rotate(h){return this.rotateToRef(h,new T)}rotateToRef(h,V){const i=Math.cos(h),S=Math.sin(h);return V.x=i*this.x-S*this.y,V.y=S*this.x+i*this.y,V}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){const h=new T;return this.normalizeToRef(h),h}normalizeToRef(h){const V=this.length();return 0===V&&(h.x=this.x,h.y=this.y),this.scaleToRef(1/V,h)}clone(){return new T(this.x,this.y)}dot(h){return this.x*h.x+this.y*h.y}static Zero(){return new T(0,0)}static One(){return new T(1,1)}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new T((0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).qq((0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V))}static get ZeroReadOnly(){return T._ZeroReadOnly}static UV(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new T(h[V],h[V+1])}static FromArrayToRef(h,V,i){return i.x=h[V],i.y=h[V+1],i}static FromFloatsToRef(h,V,i){return i.qq(h,V),i}static CatmullRom(h,V,i,S,l){const Y=l*l,g=l*Y,q=.5*(2*V.x+(-h.x+i.x)*l+(2*h.x-5*V.x+4*i.x-S.x)*Y+(-h.x+3*V.x-3*i.x+S.x)*g),B=.5*(2*V.y+(-h.y+i.y)*l+(2*h.y-5*V.y+4*i.y-S.y)*Y+(-h.y+3*V.y-3*i.y+S.y)*g);return new T(q,B)}static ClampToRef(h,V,i,S){return S.x=(0,B.Clamp)(h.x,V.x,i.x),S.y=(0,B.Clamp)(h.y,V.y,i.y),S}static Clamp(h,V,i){const S=(0,B.Clamp)(h.x,V.x,i.x),l=(0,B.Clamp)(h.y,V.y,i.y);return new T(S,l)}static Hermite(h,V,i,S,l){const Y=l*l,g=l*Y,q=2*g-3*Y+1,B=-2*g+3*Y,J=g-2*Y+l,I=g-Y,v=h.x*q+i.x*B+V.x*J+S.x*I,s=h.y*q+i.y*B+V.y*J+S.y*I;return new T(v,s)}static Hermite1stDerivative(h,V,i,S,l){return this.Hermite1stDerivativeToRef(h,V,i,S,l,new T)}static Hermite1stDerivativeToRef(h,V,i,S,l,Y){const g=l*l;return Y.x=6*(g-l)*h.x+(3*g-4*l+1)*V.x+6*(-g+l)*i.x+(3*g-2*l)*S.x,Y.y=6*(g-l)*h.y+(3*g-4*l+1)*V.y+6*(-g+l)*i.y+(3*g-2*l)*S.y,Y}static Lerp(h,V,i){return T.LerpToRef(h,V,i,new T)}static LerpToRef(h,V,i,S){return S.x=h.x+(V.x-h.x)*i,S.y=h.y+(V.y-h.y)*i,S}static Dot(h,V){return h.x*V.x+h.y*V.y}static Normalize(h){return T.NormalizeToRef(h,new T)}static NormalizeToRef(h,V){return h.normalizeToRef(V),V}static Minimize(h,V){const i=h.x<V.x?h.x:V.x,S=h.y<V.y?h.y:V.y;return new T(i,S)}static Maximize(h,V){const i=h.x>V.x?h.x:V.x,S=h.y>V.y?h.y:V.y;return new T(i,S)}static Transform(h,V){return T.TransformToRef(h,V,new T)}static TransformToRef(h,V,i){const S=V.m,l=h.x*S[0]+h.y*S[4]+S[12],Y=h.x*S[1]+h.y*S[5]+S[13];return i.x=l,i.y=Y,i}static PointInTriangle(h,V,i,S){const l=.5*(-i.y*S.x+V.y*(-i.x+S.x)+V.x*(i.y-S.y)+i.x*S.y),Y=l<0?-1:1,g=(V.y*S.x-V.x*S.y+(S.y-V.y)*h.x+(V.x-S.x)*h.y)*Y,q=(V.x*i.y-V.y*i.x+(V.y-i.y)*h.x+(i.x-V.x)*h.y)*Y;return g>0&&q>0&&g+q<2*l*Y}static Distance(h,V){return Math.sqrt(T.DistanceSquared(h,V))}static DistanceSquared(h,V){const i=h.x-V.x,S=h.y-V.y;return i*i+S*S}static Center(h,V){return T.CenterToRef(h,V,new T)}static CenterToRef(h,V,i){return i.qq((h.x+V.x)/2,(h.y+V.y)/2)}static DistanceOfPointFromSegment(h,V,i){const S=T.DistanceSquared(V,i);if(0===S)return T.Distance(h,V);const l=i.cV(V),Y=Math.max(0,Math.min(1,T.Dot(h.cV(V),l)/S)),g=V.add(l.multiplyByFloats(Y,Y));return T.Distance(h,g)}}T._V8PerformanceHack=new T(.5,.5),T._ZeroReadOnly=T.Zero(),Object.defineProperties(T.prototype,{dimension:{value:[2]},rank:{value:1}});class e{get x(){return this._x}set x(h){this._x=h,this._isDirty=!0}get y(){return this._y}set y(h){this._y=h,this._isDirty=!0}get z(){return this._z}set z(h){this._z=h,this._isDirty=!0}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=h,this._y=V,this._z=i}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"nV"}getHashCode(){let h=t(this._x);return h=397*h^t(this._y),h=397*h^t(this._z),h}Ng(){return[this._x,this._y,this._z]}toArray(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[V]=this._x,h[V+1]=this._y,h[V+2]=this._z,this}ei(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e.FromArrayToRef(h,V,this),this}toQuaternion(){return c.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(h){return this._x+=h._x,this._y+=h._y,this._z+=h._z,this._isDirty=!0,this}addInPlaceFromFloats(h,V,i){return this._x+=h,this._y+=V,this._z+=i,this._isDirty=!0,this}add(h){return new e(this._x+h._x,this._y+h._y,this._z+h._z)}addToRef(h,V){return V._x=this._x+h._x,V._y=this._y+h._y,V._z=this._z+h._z,V._isDirty=!0,V}mI(h){return this._x-=h._x,this._y-=h._y,this._z-=h._z,this._isDirty=!0,this}cV(h){return new e(this._x-h._x,this._y-h._y,this._z-h._z)}subtractToRef(h,V){return this.subtractFromFloatsToRef(h._x,h._y,h._z,V)}subtractFromFloats(h,V,i){return new e(this._x-h,this._y-V,this._z-i)}subtractFromFloatsToRef(h,V,i,S){return S._x=this._x-h,S._y=this._y-V,S._z=this._z-i,S._isDirty=!0,S}negate(){return new e(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(h){return h._x=-1*this._x,h._y=-1*this._y,h._z=-1*this._z,h._isDirty=!0,h}scaleInPlace(h){return this._x*=h,this._y*=h,this._z*=h,this._isDirty=!0,this}scale(h){return new e(this._x*h,this._y*h,this._z*h)}scaleToRef(h,V){return V._x=this._x*h,V._y=this._y*h,V._z=this._z*h,V._isDirty=!0,V}getNormalToRef(h){const V=this.length();let i=Math.acos(this._y/V);const S=Math.atan2(this._z,this._x);i>Math.PI/2?i-=Math.PI/2:i+=Math.PI/2;const l=V*Math.sin(i)*Math.cos(S),Y=V*Math.cos(i),g=V*Math.sin(i)*Math.sin(S);return h.set(l,Y,g),h}applyRotationQuaternionToRef(h,V){const i=this._x,S=this._y,l=this._z,Y=h._x,g=h._y,q=h._z,B=h._w,J=2*(g*l-q*S),I=2*(q*i-Y*l),v=2*(Y*S-g*i);return V._x=i+B*J+g*v-q*I,V._y=S+B*I+q*J-Y*v,V._z=l+B*v+Y*I-g*J,V._isDirty=!0,V}applyRotationQuaternionInPlace(h){return this.applyRotationQuaternionToRef(h,this)}applyRotationQuaternion(h){return this.applyRotationQuaternionToRef(h,new e)}scaleAndAddToRef(h,V){return V._x+=this._x*h,V._y+=this._y*h,V._z+=this._z*h,V._isDirty=!0,V}projectOnPlane(h,V){return this.projectOnPlaneToRef(h,V,new e)}projectOnPlaneToRef(h,V,i){const S=h.normal,l=h.d,Y=P.nV[0];this.subtractToRef(V,Y),Y.normalize();const g=e.Dot(Y,S);if(Math.abs(g)<1e-10)i.Iq(1/0);else{const h=-(e.Dot(V,S)+l)/g,q=Y.scaleInPlace(h);V.addToRef(q,i)}return i}equals(h){return h&&this._x===h._x&&this._y===h._y&&this._z===h._z}equalsWithEpsilon(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.c;return h&&(0,B.WithinEpsilon)(this._x,h._x,V)&&(0,B.WithinEpsilon)(this._y,h._y,V)&&(0,B.WithinEpsilon)(this._z,h._z,V)}equalsToFloats(h,V,i){return this._x===h&&this._y===V&&this._z===i}multiplyInPlace(h){return this._x*=h._x,this._y*=h._y,this._z*=h._z,this._isDirty=!0,this}multiply(h){return this.multiplyByFloats(h._x,h._y,h._z)}multiplyToRef(h,V){return V._x=this._x*h._x,V._y=this._y*h._y,V._z=this._z*h._z,V._isDirty=!0,V}multiplyByFloats(h,V,i){return new e(this._x*h,this._y*V,this._z*i)}divide(h){return new e(this._x/h._x,this._y/h._y,this._z/h._z)}divideToRef(h,V){return V._x=this._x/h._x,V._y=this._y/h._y,V._z=this._z/h._z,V._isDirty=!0,V}divideInPlace(h){return this._x=this._x/h._x,this._y=this._y/h._y,this._z=this._z/h._z,this._isDirty=!0,this}minimizeInPlace(h){return this.minimizeInPlaceFromFloats(h._x,h._y,h._z)}maximizeInPlace(h){return this.maximizeInPlaceFromFloats(h._x,h._y,h._z)}minimizeInPlaceFromFloats(h,V,i){return h<this._x&&(this.x=h),V<this._y&&(this.y=V),i<this._z&&(this.z=i),this}maximizeInPlaceFromFloats(h,V,i){return h>this._x&&(this.x=h),V>this._y&&(this.y=V),i>this._z&&(this.z=i),this}isNonUniformWithinEpsilon(h){const V=Math.abs(this._x),i=Math.abs(this._y);if(!(0,B.WithinEpsilon)(V,i,h))return!0;const S=Math.abs(this._z);return!(0,B.WithinEpsilon)(V,S,h)||!(0,B.WithinEpsilon)(i,S,h)}get isNonUniform(){const h=Math.abs(this._x);if(h!==Math.abs(this._y))return!0;return h!==Math.abs(this._z)}floorToRef(h){return h._x=Math.floor(this._x),h._y=Math.floor(this._y),h._z=Math.floor(this._z),h._isDirty=!0,h}floor(){return new e(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(h){return h._x=this._x-Math.floor(this._x),h._y=this._y-Math.floor(this._y),h._z=this._z-Math.floor(this._z),h._isDirty=!0,h}fract(){return new e(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(h){if("xyz"===(h=h.toLowerCase()))return this;const V=P.nV[0].l(this);return this.x=V[h[0]],this.y=V[h[1]],this.z=V[h[2]],this}rotateByQuaternionToRef(h,V){return h.toRotationMatrix(P.Matrix[0]),e.TransformCoordinatesToRef(this,P.Matrix[0],V),V}rotateByQuaternionAroundPointToRef(h,V,i){return this.subtractToRef(V,P.nV[0]),P.nV[0].rotateByQuaternionToRef(h,P.nV[0]),V.addToRef(P.nV[0],i),i}cross(h){return e.CrossToRef(this,h,new e)}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){return this.normalizeToRef(new e)}normalizeToRef(h){const V=this.length();return 0===V||1===V?(h._x=this._x,h._y=this._y,h._z=this._z,h._isDirty=!0,h):this.scaleToRef(1/V,h)}clone(){return new e(this._x,this._y,this._z)}l(h){return this.qq(h._x,h._y,h._z)}qq(h,V,i){return this._x=h,this._y=V,this._z=i,this._isDirty=!0,this}set(h,V,i){return this.qq(h,V,i)}Iq(h){return this._x=this._y=this._z=h,this._isDirty=!0,this}static GetClipFactor(h,V,i,S){const l=e.Dot(h,i);return(l-S)/(l-e.Dot(V,i))}static GetAngleBetweenVectors(h,V,i){const S=h.normalizeToRef(P.nV[1]),l=V.normalizeToRef(P.nV[2]);let Y=e.Dot(S,l);Y=(0,B.Clamp)(Y,-1,1);const g=Math.acos(Y),q=P.nV[3];return e.CrossToRef(S,l,q),e.Dot(q,i)>0?isNaN(g)?0:g:isNaN(g)?-Math.PI:-Math.acos(Y)}static GetAngleBetweenVectorsOnPlane(h,V,i){P.nV[0].l(h);const S=P.nV[0];P.nV[1].l(V);const l=P.nV[1];P.nV[2].l(i);const Y=P.nV[2],g=P.nV[3],q=P.nV[4];S.normalize(),l.normalize(),Y.normalize(),e.CrossToRef(Y,S,g),e.CrossToRef(g,Y,q);const J=Math.atan2(e.Dot(l,g),e.Dot(l,q));return(0,B.NormalizeRadians)(J)}static PitchYawRollToMoveBetweenPointsToRef(h,V,i){const S=L.nV[0];return V.subtractToRef(h,S),i._y=Math.atan2(S.x,S.z)||0,i._x=Math.atan2(Math.sqrt(S.x**2+S.z**2),S.y)||0,i._z=0,i._isDirty=!0,i}static PitchYawRollToMoveBetweenPoints(h,V){const i=e.Zero();return e.PitchYawRollToMoveBetweenPointsToRef(h,V,i)}static SlerpToRef(h,V,i,l){i=(0,B.Clamp)(i,0,1);const Y=P.nV[0],g=P.nV[1];Y.l(h);const q=Y.length();Y.normalizeFromLength(q),g.l(V);const J=g.length();g.normalizeFromLength(J);const I=e.Dot(Y,g);let v,s;if(I<1-S.c){const h=Math.acos(I),V=1/Math.sin(h);v=Math.sin((1-i)*h)*V,s=Math.sin(i*h)*V}else v=1-i,s=i;return Y.scaleInPlace(v),g.scaleInPlace(s),l.l(Y).addInPlace(g),l.scaleInPlace((0,B.Lerp)(q,J,i)),l}static SmoothToRef(h,V,i,S,l){return e.SlerpToRef(h,V,0===S?1:i/S,l),l}static UV(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new e(h[V],h[V+1],h[V+2])}static FromFloatArray(h,V){return e.UV(h,V)}static FromArrayToRef(h,V,i){return i._x=h[V],i._y=h[V+1],i._z=h[V+2],i._isDirty=!0,i}static FromFloatArrayToRef(h,V,i){return e.FromArrayToRef(h,V,i)}static FromFloatsToRef(h,V,i,S){return S.qq(h,V,i),S}static Zero(){return new e(0,0,0)}static One(){return new e(1,1,1)}static Up(){return new e(0,1,0)}static get UpReadOnly(){return e._UpReadOnly}static get DownReadOnly(){return e._DownReadOnly}static get RightReadOnly(){return e._RightReadOnly}static get LeftReadOnly(){return e._LeftReadOnly}static get LeftHandedForwardReadOnly(){return e._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return e._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return e._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return e._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return e._ZeroReadOnly}static get OneReadOnly(){return e._OneReadOnly}static Down(){return new e(0,-1,0)}static Forward(){return new e(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new e(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new e(1,0,0)}static Left(){return new e(-1,0,0)}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new e((0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).qq((0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V))}static TransformCoordinates(h,V){const i=e.Zero();return e.TransformCoordinatesToRef(h,V,i),i}static TransformCoordinatesToRef(h,V,i){return e.TransformCoordinatesFromFloatsToRef(h._x,h._y,h._z,V,i),i}static TransformCoordinatesFromFloatsToRef(h,V,i,S,l){const Y=S.m,g=h*Y[0]+V*Y[4]+i*Y[8]+Y[12],q=h*Y[1]+V*Y[5]+i*Y[9]+Y[13],B=h*Y[2]+V*Y[6]+i*Y[10]+Y[14],J=1/(h*Y[3]+V*Y[7]+i*Y[11]+Y[15]);return l._x=g*J,l._y=q*J,l._z=B*J,l._isDirty=!0,l}static TransformNormal(h,V){const i=e.Zero();return e.TransformNormalToRef(h,V,i),i}static TransformNormalToRef(h,V,i){return this.TransformNormalFromFloatsToRef(h._x,h._y,h._z,V,i),i}static TransformNormalFromFloatsToRef(h,V,i,S,l){const Y=S.m;return l._x=h*Y[0]+V*Y[4]+i*Y[8],l._y=h*Y[1]+V*Y[5]+i*Y[9],l._z=h*Y[2]+V*Y[6]+i*Y[10],l._isDirty=!0,l}static CatmullRom(h,V,i,S,l){const Y=l*l,g=l*Y,q=.5*(2*V._x+(-h._x+i._x)*l+(2*h._x-5*V._x+4*i._x-S._x)*Y+(-h._x+3*V._x-3*i._x+S._x)*g),B=.5*(2*V._y+(-h._y+i._y)*l+(2*h._y-5*V._y+4*i._y-S._y)*Y+(-h._y+3*V._y-3*i._y+S._y)*g),J=.5*(2*V._z+(-h._z+i._z)*l+(2*h._z-5*V._z+4*i._z-S._z)*Y+(-h._z+3*V._z-3*i._z+S._z)*g);return new e(q,B,J)}static Clamp(h,V,i){const S=new e;return e.ClampToRef(h,V,i,S),S}static ClampToRef(h,V,i,S){let l=h._x;l=l>i._x?i._x:l,l=l<V._x?V._x:l;let Y=h._y;Y=Y>i._y?i._y:Y,Y=Y<V._y?V._y:Y;let g=h._z;return g=g>i._z?i._z:g,g=g<V._z?V._z:g,S.qq(l,Y,g),S}static CheckExtends(h,V,i){V.minimizeInPlace(h),i.maximizeInPlace(h)}static Hermite(h,V,i,S,l){const Y=l*l,g=l*Y,q=2*g-3*Y+1,B=-2*g+3*Y,J=g-2*Y+l,I=g-Y,v=h._x*q+i._x*B+V._x*J+S._x*I,s=h._y*q+i._y*B+V._y*J+S._y*I,t=h._z*q+i._z*B+V._z*J+S._z*I;return new e(v,s,t)}static Hermite1stDerivative(h,V,i,S,l){const Y=new e;return this.Hermite1stDerivativeToRef(h,V,i,S,l,Y),Y}static Hermite1stDerivativeToRef(h,V,i,S,l,Y){const g=l*l;return Y._x=6*(g-l)*h._x+(3*g-4*l+1)*V._x+6*(-g+l)*i._x+(3*g-2*l)*S._x,Y._y=6*(g-l)*h._y+(3*g-4*l+1)*V._y+6*(-g+l)*i._y+(3*g-2*l)*S._y,Y._z=6*(g-l)*h._z+(3*g-4*l+1)*V._z+6*(-g+l)*i._z+(3*g-2*l)*S._z,Y._isDirty=!0,Y}static Lerp(h,V,i){const S=new e(0,0,0);return e.LerpToRef(h,V,i,S),S}static LerpToRef(h,V,i,S){return S._x=h._x+(V._x-h._x)*i,S._y=h._y+(V._y-h._y)*i,S._z=h._z+(V._z-h._z)*i,S._isDirty=!0,S}static Dot(h,V){return h._x*V._x+h._y*V._y+h._z*V._z}dot(h){return this._x*h._x+this._y*h._y+this._z*h._z}static Cross(h,V){const i=new e;return e.CrossToRef(h,V,i),i}static CrossToRef(h,V,i){const S=h._y*V._z-h._z*V._y,l=h._z*V._x-h._x*V._z,Y=h._x*V._y-h._y*V._x;return i.qq(S,l,Y),i}static Normalize(h){const V=e.Zero();return e.NormalizeToRef(h,V),V}static NormalizeToRef(h,V){return h.normalizeToRef(V),V}static Project(h,V,i,S){const l=new e;return e.ProjectToRef(h,V,i,S,l),l}static ProjectToRef(h,V,i,S,l){var Y;const g=S.width,B=S.height,J=S.x,I=S.y,v=P.Matrix[1],s=null===(Y=q.d.LastCreatedEngine)||void 0===Y?void 0:Y.isNDCHalfZRange,t=s?1:.5,T=s?0:.5;f.FromValuesToRef(g/2,0,0,0,0,-B/2,0,0,0,0,t,0,J+g/2,B/2+I,T,1,v);const n=P.Matrix[0];return V.multiplyToRef(i,n),n.multiplyToRef(v,n),e.TransformCoordinatesToRef(h,n,l),l}static Reflect(h,V){return this.ReflectToRef(h,V,new e)}static ReflectToRef(h,V,i){const S=L.nV[0];return S.l(V).scaleInPlace(2*e.Dot(h,V)),i.l(h).mI(S)}static _UnprojectFromInvertedMatrixToRef(h,V,i){e.TransformCoordinatesToRef(h,V,i);const S=V.m,l=h._x*S[3]+h._y*S[7]+h._z*S[11]+S[15];return(0,B.WithinEpsilon)(l,1)&&i.scaleInPlace(1/l),i}static UnprojectFromTransform(h,V,i,S,l){return this.Unproject(h,V,i,S,l,f.IdentityReadOnly)}static Unproject(h,V,i,S,l,Y){const g=new e;return e.UnprojectToRef(h,V,i,S,l,Y,g),g}static UnprojectToRef(h,V,i,S,l,Y,g){return e.UnprojectFloatsToRef(h._x,h._y,h._z,V,i,S,l,Y,g),g}static UnprojectFloatsToRef(h,V,i,S,l,Y,g,B,J){var I;const v=P.Matrix[0];Y.multiplyToRef(g,v),v.multiplyToRef(B,v),v.invert();const s=P.nV[0];return s.x=h/S*2-1,s.y=-(V/l*2-1),null!==(I=q.d.LastCreatedEngine)&&void 0!==I&&I.isNDCHalfZRange?s.z=i:s.z=2*i-1,e._UnprojectFromInvertedMatrixToRef(s,v,J),J}static Minimize(h,V){const i=new e;return i.l(h),i.minimizeInPlace(V),i}static Maximize(h,V){const i=new e;return i.l(h),i.maximizeInPlace(V),i}static Distance(h,V){return Math.sqrt(e.DistanceSquared(h,V))}static DistanceSquared(h,V){const i=h._x-V._x,S=h._y-V._y,l=h._z-V._z;return i*i+S*S+l*l}static ProjectOnTriangleToRef(h,V,i,l,Y){const g=P.nV[0],q=P.nV[1],J=P.nV[2],I=P.nV[3],v=P.nV[4];i.subtractToRef(V,g),l.subtractToRef(V,q),l.subtractToRef(i,J);const s=g.length(),t=q.length(),T=J.length();if(s<S.c||t<S.c||T<S.c)return Y.l(V),e.Distance(h,V);h.subtractToRef(V,v),e.CrossToRef(g,q,I);const n=I.length();if(n<S.c)return Y.l(V),e.Distance(h,V);I.normalizeFromLength(n);let c=v.length();if(c<S.c)return Y.l(V),0;v.normalizeFromLength(c);const f=e.Dot(I,v),L=P.nV[5],U=P.nV[6];L.l(I).scaleInPlace(-c*f),U.l(h).addInPlace(L);const X=P.nV[4],D=P.nV[5],O=P.nV[7],o=P.nV[8];X.l(g).scaleInPlace(1/s),o.l(q).scaleInPlace(1/t),X.addInPlace(o).scaleInPlace(-1),D.l(g).scaleInPlace(-1/s),o.l(J).scaleInPlace(1/T),D.addInPlace(o).scaleInPlace(-1),O.l(J).scaleInPlace(-1/T),o.l(q).scaleInPlace(-1/t),O.addInPlace(o).scaleInPlace(-1);const M=P.nV[9];let F;M.l(U).mI(V),e.CrossToRef(X,M,o),F=e.Dot(o,I);const E=F;M.l(U).mI(i),e.CrossToRef(D,M,o),F=e.Dot(o,I);const H=F;M.l(U).mI(l),e.CrossToRef(O,M,o),F=e.Dot(o,I);const j=F,m=P.nV[10];let G,w;E>0&&H<0?(m.l(g),G=V,w=i):H>0&&j<0?(m.l(J),G=i,w=l):(m.l(q).scaleInPlace(-1),G=l,w=V);const N=P.nV[9],r=P.nV[4];G.subtractToRef(U,o),w.subtractToRef(U,N),e.CrossToRef(o,N,r);if(!(e.Dot(r,I)<0))return Y.l(U),Math.abs(c*f);const k=P.nV[5];e.CrossToRef(m,r,k),k.normalize();const R=P.nV[9];R.l(G).mI(U);const Z=R.length();if(Z<S.c)return Y.l(G),e.Distance(h,G);R.normalizeFromLength(Z);const z=e.Dot(k,R),d=P.nV[7];d.l(U).addInPlace(k.scaleInPlace(Z*z)),o.l(d).mI(G),c=m.length(),m.normalizeFromLength(c);let x=e.Dot(o,m)/Math.max(c,S.c);return x=(0,B.Clamp)(x,0,1),d.l(G).addInPlace(m.scaleInPlace(x*c)),Y.l(d),e.Distance(h,d)}static Center(h,V){return e.CenterToRef(h,V,e.Zero())}static CenterToRef(h,V,i){return i.qq((h._x+V._x)/2,(h._y+V._y)/2,(h._z+V._z)/2)}static RotationFromAxis(h,V,i){const S=new e;return e.RotationFromAxisToRef(h,V,i,S),S}static RotationFromAxisToRef(h,V,i,S){const l=P.Quaternion[0];return c.RotationQuaternionFromAxisToRef(h,V,i,l),l.toEulerAnglesToRef(S),S}}e._V8PerformanceHack=new e(.5,.5,.5),e._UpReadOnly=e.Up(),e._DownReadOnly=e.Down(),e._LeftHandedForwardReadOnly=e.Forward(!1),e._RightHandedForwardReadOnly=e.Forward(!0),e._LeftHandedBackwardReadOnly=e.Backward(!1),e._RightHandedBackwardReadOnly=e.Backward(!0),e._RightReadOnly=e.Right(),e._LeftReadOnly=e.Left(),e._ZeroReadOnly=e.Zero(),e._OneReadOnly=e.One(),Object.defineProperties(e.prototype,{dimension:{value:[3]},rank:{value:1}});class n{get x(){return this._x}set x(h){this._x=h,this._isDirty=!0}get y(){return this._y}set y(h){this._y=h,this._isDirty=!0}get z(){return this._z}set z(h){this._z=h,this._isDirty=!0}get w(){return this._w}set w(h){this._w=h,this._isDirty=!0}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=h,this._y=V,this._z=i,this._w=S}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let h=t(this._x);return h=397*h^t(this._y),h=397*h^t(this._z),h=397*h^t(this._w),h}Ng(){return[this._x,this._y,this._z,this._w]}toArray(h,V){return void 0===V&&(V=0),h[V]=this._x,h[V+1]=this._y,h[V+2]=this._z,h[V+3]=this._w,this}ei(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n.FromArrayToRef(h,V,this),this}addInPlace(h){return this.x+=h._x,this.y+=h._y,this.z+=h._z,this.w+=h._w,this}addInPlaceFromFloats(h,V,i,S){return this.x+=h,this.y+=V,this.z+=i,this.w+=S,this}add(h){return new n(this._x+h.x,this._y+h.y,this._z+h.z,this._w+h.w)}addToRef(h,V){return V.x=this._x+h.x,V.y=this._y+h.y,V.z=this._z+h.z,V.w=this._w+h.w,V}mI(h){return this.x-=h.x,this.y-=h.y,this.z-=h.z,this.w-=h.w,this}cV(h){return new n(this._x-h.x,this._y-h.y,this._z-h.z,this._w-h.w)}subtractToRef(h,V){return V.x=this._x-h.x,V.y=this._y-h.y,V.z=this._z-h.z,V.w=this._w-h.w,V}subtractFromFloats(h,V,i,S){return new n(this._x-h,this._y-V,this._z-i,this._w-S)}subtractFromFloatsToRef(h,V,i,S,l){return l.x=this._x-h,l.y=this._y-V,l.z=this._z-i,l.w=this._w-S,l}negate(){return new n(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(h){return h.x=-this._x,h.y=-this._y,h.z=-this._z,h.w=-this._w,h}scaleInPlace(h){return this.x*=h,this.y*=h,this.z*=h,this.w*=h,this}scale(h){return new n(this._x*h,this._y*h,this._z*h,this._w*h)}scaleToRef(h,V){return V.x=this._x*h,V.y=this._y*h,V.z=this._z*h,V.w=this._w*h,V}scaleAndAddToRef(h,V){return V.x+=this._x*h,V.y+=this._y*h,V.z+=this._z*h,V.w+=this._w*h,V}equals(h){return h&&this._x===h.x&&this._y===h.y&&this._z===h.z&&this._w===h.w}equalsWithEpsilon(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.c;return h&&(0,B.WithinEpsilon)(this._x,h.x,V)&&(0,B.WithinEpsilon)(this._y,h.y,V)&&(0,B.WithinEpsilon)(this._z,h.z,V)&&(0,B.WithinEpsilon)(this._w,h.w,V)}equalsToFloats(h,V,i,S){return this._x===h&&this._y===V&&this._z===i&&this._w===S}multiplyInPlace(h){return this.x*=h.x,this.y*=h.y,this.z*=h.z,this.w*=h.w,this}multiply(h){return new n(this._x*h.x,this._y*h.y,this._z*h.z,this._w*h.w)}multiplyToRef(h,V){return V.x=this._x*h.x,V.y=this._y*h.y,V.z=this._z*h.z,V.w=this._w*h.w,V}multiplyByFloats(h,V,i,S){return new n(this._x*h,this._y*V,this._z*i,this._w*S)}divide(h){return new n(this._x/h.x,this._y/h.y,this._z/h.z,this._w/h.w)}divideToRef(h,V){return V.x=this._x/h.x,V.y=this._y/h.y,V.z=this._z/h.z,V.w=this._w/h.w,V}divideInPlace(h){return this.divideToRef(h,this)}minimizeInPlace(h){return h.x<this._x&&(this.x=h.x),h.y<this._y&&(this.y=h.y),h.z<this._z&&(this.z=h.z),h.w<this._w&&(this.w=h.w),this}maximizeInPlace(h){return h.x>this._x&&(this.x=h.x),h.y>this._y&&(this.y=h.y),h.z>this._z&&(this.z=h.z),h.w>this._w&&(this.w=h.w),this}minimizeInPlaceFromFloats(h,V,i,S){return this.x=Math.min(h,this._x),this.y=Math.min(V,this._y),this.z=Math.min(i,this._z),this.w=Math.min(S,this._w),this}maximizeInPlaceFromFloats(h,V,i,S){return this.x=Math.max(h,this._x),this.y=Math.max(V,this._y),this.z=Math.max(i,this._z),this.w=Math.max(S,this._w),this}floorToRef(h){return h.x=Math.floor(this._x),h.y=Math.floor(this._y),h.z=Math.floor(this._z),h.w=Math.floor(this._w),h}floor(){return new n(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(h){return h.x=this._x-Math.floor(this._x),h.y=this._y-Math.floor(this._y),h.z=this._z-Math.floor(this._z),h.w=this._w-Math.floor(this._w),h}fract(){return new n(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){return this.normalizeToRef(new n)}normalizeToRef(h){const V=this.length();return 0===V||1===V?(h.x=this._x,h.y=this._y,h.z=this._z,h.w=this._w,h):this.scaleToRef(1/V,h)}toVector3(){return new e(this._x,this._y,this._z)}clone(){return new n(this._x,this._y,this._z,this._w)}l(h){return this.x=h.x,this.y=h.y,this.z=h.z,this.w=h.w,this}qq(h,V,i,S){return this.x=h,this.y=V,this.z=i,this.w=S,this}set(h,V,i,S){return this.qq(h,V,i,S)}Iq(h){return this.x=this.y=this.z=this.w=h,this}dot(h){return this._x*h.x+this._y*h.y+this._z*h.z+this._w*h.w}static UV(h,V){return V||(V=0),new n(h[V],h[V+1],h[V+2],h[V+3])}static FromArrayToRef(h,V,i){return i.x=h[V],i.y=h[V+1],i.z=h[V+2],i.w=h[V+3],i}static FromFloatArrayToRef(h,V,i){return n.FromArrayToRef(h,V,i),i}static FromFloatsToRef(h,V,i,S,l){return l.x=h,l.y=V,l.z=i,l.w=S,l}static Zero(){return new n(0,0,0,0)}static One(){return new n(1,1,1,1)}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new n((0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0;return i.x=(0,B.RandomRange)(h,V),i.y=(0,B.RandomRange)(h,V),i.z=(0,B.RandomRange)(h,V),i.w=(0,B.RandomRange)(h,V),i}static Clamp(h,V,i){return n.ClampToRef(h,V,i,new n)}static ClampToRef(h,V,i,S){return S.x=(0,B.Clamp)(h.x,V.x,i.x),S.y=(0,B.Clamp)(h.y,V.y,i.y),S.z=(0,B.Clamp)(h.z,V.z,i.z),S.w=(0,B.Clamp)(h.w,V.w,i.w),S}static CheckExtends(h,V,i){V.minimizeInPlace(h),i.maximizeInPlace(h)}static get ZeroReadOnly(){return n._ZeroReadOnly}static Normalize(h){return n.NormalizeToRef(h,new n)}static NormalizeToRef(h,V){return h.normalizeToRef(V),V}static Minimize(h,V){const i=new n;return i.l(h),i.minimizeInPlace(V),i}static Maximize(h,V){const i=new n;return i.l(h),i.maximizeInPlace(V),i}static Distance(h,V){return Math.sqrt(n.DistanceSquared(h,V))}static DistanceSquared(h,V){const i=h.x-V.x,S=h.y-V.y,l=h.z-V.z,Y=h.w-V.w;return i*i+S*S+l*l+Y*Y}static Center(h,V){return n.CenterToRef(h,V,new n)}static CenterToRef(h,V,i){return i.x=(h.x+V.x)/2,i.y=(h.y+V.y)/2,i.z=(h.z+V.z)/2,i.w=(h.w+V.w)/2,i}static TransformCoordinates(h,V){return n.TransformCoordinatesToRef(h,V,new n)}static TransformCoordinatesToRef(h,V,i){return n.TransformCoordinatesFromFloatsToRef(h._x,h._y,h._z,V,i),i}static TransformCoordinatesFromFloatsToRef(h,V,i,S,l){const Y=S.m,g=h*Y[0]+V*Y[4]+i*Y[8]+Y[12],q=h*Y[1]+V*Y[5]+i*Y[9]+Y[13],B=h*Y[2]+V*Y[6]+i*Y[10]+Y[14],J=h*Y[3]+V*Y[7]+i*Y[11]+Y[15];return l.x=g,l.y=q,l.z=B,l.w=J,l}static TransformNormal(h,V){return n.TransformNormalToRef(h,V,new n)}static TransformNormalToRef(h,V,i){const S=V.m,l=h.x*S[0]+h.y*S[4]+h.z*S[8],Y=h.x*S[1]+h.y*S[5]+h.z*S[9],g=h.x*S[2]+h.y*S[6]+h.z*S[10];return i.x=l,i.y=Y,i.z=g,i.w=h.w,i}static TransformNormalFromFloatsToRef(h,V,i,S,l,Y){const g=l.m;return Y.x=h*g[0]+V*g[4]+i*g[8],Y.y=h*g[1]+V*g[5]+i*g[9],Y.z=h*g[2]+V*g[6]+i*g[10],Y.w=S,Y}static FromVector3(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new n(h._x,h._y,h._z,V)}static Dot(h,V){return h.x*V.x+h.y*V.y+h.z*V.z+h.w*V.w}}n._V8PerformanceHack=new n(.5,.5,.5,.5),n._ZeroReadOnly=n.Zero(),Object.defineProperties(n.prototype,{dimension:{value:[4]},rank:{value:1}});class c{get x(){return this._x}set x(h){this._x=h,this._isDirty=!0}get y(){return this._y}set y(h){this._y=h,this._isDirty=!0}get z(){return this._z}set z(h){this._z=h,this._isDirty=!0}get w(){return this._w}set w(h){this._w=h,this._isDirty=!0}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=h,this._y=V,this._z=i,this._w=S}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let h=t(this._x);return h=397*h^t(this._y),h=397*h^t(this._z),h=397*h^t(this._w),h}Ng(){return[this._x,this._y,this._z,this._w]}toArray(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[V]=this._x,h[V+1]=this._y,h[V+2]=this._z,h[V+3]=this._w,this}ei(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c.FromArrayToRef(h,V,this)}equals(h){return h&&this._x===h._x&&this._y===h._y&&this._z===h._z&&this._w===h._w}equalsWithEpsilon(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.c;return h&&(0,B.WithinEpsilon)(this._x,h._x,V)&&(0,B.WithinEpsilon)(this._y,h._y,V)&&(0,B.WithinEpsilon)(this._z,h._z,V)&&(0,B.WithinEpsilon)(this._w,h._w,V)}isApprox(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.c;return h&&((0,B.WithinEpsilon)(this._x,h._x,V)&&(0,B.WithinEpsilon)(this._y,h._y,V)&&(0,B.WithinEpsilon)(this._z,h._z,V)&&(0,B.WithinEpsilon)(this._w,h._w,V)||(0,B.WithinEpsilon)(this._x,-h._x,V)&&(0,B.WithinEpsilon)(this._y,-h._y,V)&&(0,B.WithinEpsilon)(this._z,-h._z,V)&&(0,B.WithinEpsilon)(this._w,-h._w,V))}clone(){return new c(this._x,this._y,this._z,this._w)}l(h){return this._x=h._x,this._y=h._y,this._z=h._z,this._w=h._w,this._isDirty=!0,this}qq(h,V,i,S){return this._x=h,this._y=V,this._z=i,this._w=S,this._isDirty=!0,this}set(h,V,i,S){return this.qq(h,V,i,S)}Iq(h){return this.qq(h,h,h,h)}add(h){return new c(this._x+h._x,this._y+h._y,this._z+h._z,this._w+h._w)}addInPlace(h){return this._x+=h._x,this._y+=h._y,this._z+=h._z,this._w+=h._w,this._isDirty=!0,this}addToRef(h,V){return V._x=this._x+h._x,V._y=this._y+h._y,V._z=this._z+h._z,V._w=this._w+h._w,V._isDirty=!0,V}addInPlaceFromFloats(h,V,i,S){return this._x+=h,this._y+=V,this._z+=i,this._w+=S,this._isDirty=!0,this}subtractToRef(h,V){return V._x=this._x-h._x,V._y=this._y-h._y,V._z=this._z-h._z,V._w=this._w-h._w,V._isDirty=!0,V}subtractFromFloats(h,V,i,S){return this.subtractFromFloatsToRef(h,V,i,S,new c)}subtractFromFloatsToRef(h,V,i,S,l){return l._x=this._x-h,l._y=this._y-V,l._z=this._z-i,l._w=this._w-S,l._isDirty=!0,l}cV(h){return new c(this._x-h._x,this._y-h._y,this._z-h._z,this._w-h._w)}mI(h){return this._x-=h._x,this._y-=h._y,this._z-=h._z,this._w-=h._w,this._isDirty=!0,this}scale(h){return new c(this._x*h,this._y*h,this._z*h,this._w*h)}scaleToRef(h,V){return V._x=this._x*h,V._y=this._y*h,V._z=this._z*h,V._w=this._w*h,V._isDirty=!0,V}scaleInPlace(h){return this._x*=h,this._y*=h,this._z*=h,this._w*=h,this._isDirty=!0,this}scaleAndAddToRef(h,V){return V._x+=this._x*h,V._y+=this._y*h,V._z+=this._z*h,V._w+=this._w*h,V._isDirty=!0,V}multiply(h){const V=new c(0,0,0,1);return this.multiplyToRef(h,V),V}multiplyToRef(h,V){const i=this._x*h._w+this._y*h._z-this._z*h._y+this._w*h._x,S=-this._x*h._z+this._y*h._w+this._z*h._x+this._w*h._y,l=this._x*h._y-this._y*h._x+this._z*h._w+this._w*h._z,Y=-this._x*h._x-this._y*h._y-this._z*h._z+this._w*h._w;return V.qq(i,S,l,Y),V}multiplyInPlace(h){return this.multiplyToRef(h,this)}multiplyByFloats(h,V,i,S){return this._x*=h,this._y*=V,this._z*=i,this._w*=S,this._isDirty=!0,this}divide(h){throw new ReferenceError("Can not divide a quaternion")}divideToRef(h,V){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(h){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new c)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(h){return h._x=-this._x,h._y=-this._y,h._z=-this._z,h._w=-this._w,h._isDirty=!0,h}equalsToFloats(h,V,i,S){return this._x===h&&this._y===V&&this._z===i&&this._w===S}floorToRef(h){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(h){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(h){return h.qq(-this._x,-this._y,-this._z,this._w),h}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new c(-this._x,-this._y,-this._z,this._w)}invert(){const h=this.conjugate(),V=this.lengthSquared();return 0==V||1==V||h.scaleInPlace(1/V),h}invertInPlace(){this.conjugateInPlace();const h=this.lengthSquared();return 0==h||1==h||this.scaleInPlace(1/h),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){const h=new c(0,0,0,1);return this.normalizeToRef(h),h}normalizeToRef(h){const V=this.length();return 0===V||1===V?h.qq(this._x,this._y,this._z,this._w):this.scaleToRef(1/V,h)}toEulerAngles(){const h=e.Zero();return this.toEulerAnglesToRef(h),h}toEulerAnglesToRef(h){const V=this._z,i=this._x,S=this._y,l=this._w,Y=S*V-i*l,g=.4999999;if(Y<-g)h._y=2*Math.atan2(S,l),h._x=Math.PI/2,h._z=0,h._isDirty=!0;else if(Y>g)h._y=2*Math.atan2(S,l),h._x=-Math.PI/2,h._z=0,h._isDirty=!0;else{const g=l*l,q=V*V,B=i*i,J=S*S;h._z=Math.atan2(2*(i*S+V*l),-q-B+J+g),h._x=Math.asin(-2*Y),h._y=Math.atan2(2*(V*i+S*l),q-B-J+g),h._isDirty=!0}return h}toAlphaBetaGammaToRef(h){const V=this._z,i=this._x,S=this._y,l=this._w,Y=Math.sqrt(i*i+S*S),g=Math.sqrt(V*V+l*l),q=2*Math.atan2(Y,g),B=2*Math.atan2(V,l),J=2*Math.atan2(S,i),I=(B+J)/2,v=(B-J)/2;return h.set(v,q,I),h}toRotationMatrix(h){return f.FromQuaternionToRef(this,h),h}fromRotationMatrix(h){return c.FromRotationMatrixToRef(h,this),this}dot(h){return this._x*h._x+this._y*h._y+this._z*h._z+this._w*h._w}toAxisAngle(){const h=e.Zero();return{axis:h,angle:this.toAxisAngleToRef(h)}}toAxisAngleToRef(h){let V=0;const i=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),S=this._w;return i>0?(V=2*Math.atan2(i,S),h.set(this._x/i,this._y/i,this._z/i)):(V=0,h.set(1,0,0)),V}static FromRotationMatrix(h){const V=new c;return c.FromRotationMatrixToRef(h,V),V}static FromRotationMatrixToRef(h,V){const i=h.m,S=i[0],l=i[4],Y=i[8],g=i[1],q=i[5],B=i[9],J=i[2],I=i[6],v=i[10],s=S+q+v;let t;return s>0?(t=.5/Math.sqrt(s+1),V._w=.25/t,V._x=(I-B)*t,V._y=(Y-J)*t,V._z=(g-l)*t,V._isDirty=!0):S>q&&S>v?(t=2*Math.sqrt(1+S-q-v),V._w=(I-B)/t,V._x=.25*t,V._y=(l+g)/t,V._z=(Y+J)/t,V._isDirty=!0):q>v?(t=2*Math.sqrt(1+q-S-v),V._w=(Y-J)/t,V._x=(l+g)/t,V._y=.25*t,V._z=(B+I)/t,V._isDirty=!0):(t=2*Math.sqrt(1+v-S-q),V._w=(g-l)/t,V._x=(Y+J)/t,V._y=(B+I)/t,V._z=.25*t,V._isDirty=!0),V}static Dot(h,V){return h._x*V._x+h._y*V._y+h._z*V._z+h._w*V._w}static AreClose(h,V){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const S=c.Dot(h,V);return 1-S*S<=i}static SmoothToRef(h,V,i,S,l){let Y=0===S?1:i/S;return Y=(0,B.Clamp)(Y,0,1),c.SlerpToRef(h,V,Y,l),l}static Zero(){return new c(0,0,0,0)}static Inverse(h){return new c(-h._x,-h._y,-h._z,h._w)}static InverseToRef(h,V){return V.set(-h._x,-h._y,-h._z,h._w),V}static Identity(){return new c(0,0,0,1)}static IsIdentity(h){return h&&0===h._x&&0===h._y&&0===h._z&&1===h._w}static RotationAxis(h,V){return c.RotationAxisToRef(h,V,new c)}static RotationAxisToRef(h,V,i){i._w=Math.cos(V/2);const S=Math.sin(V/2)/h.length();return i._x=h._x*S,i._y=h._y*S,i._z=h._z*S,i._isDirty=!0,i}static UV(h,V){return V||(V=0),new c(h[V],h[V+1],h[V+2],h[V+3])}static FromArrayToRef(h,V,i){return i._x=h[V],i._y=h[V+1],i._z=h[V+2],i._w=h[V+3],i._isDirty=!0,i}static FromFloatsToRef(h,V,i,S,l){return l.qq(h,V,i,S),l}static FromEulerAngles(h,V,i){const S=new c;return c.RotationYawPitchRollToRef(V,h,i,S),S}static FromEulerAnglesToRef(h,V,i,S){return c.RotationYawPitchRollToRef(V,h,i,S),S}static FromEulerVector(h){const V=new c;return c.RotationYawPitchRollToRef(h._y,h._x,h._z,V),V}static FromEulerVectorToRef(h,V){return c.RotationYawPitchRollToRef(h._y,h._x,h._z,V),V}static FromUnitVectorsToRef(h,V,i){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:S.c;const Y=e.Dot(h,V)+1;return Y<l?Math.abs(h.x)>Math.abs(h.z)?i.set(-h.y,h.x,0,0):i.set(0,-h.z,h.y,0):(e.CrossToRef(h,V,L.nV[0]),i.set(L.nV[0].x,L.nV[0].y,L.nV[0].z,Y)),i.normalize()}static RotationYawPitchRoll(h,V,i){const S=new c;return c.RotationYawPitchRollToRef(h,V,i,S),S}static RotationYawPitchRollToRef(h,V,i,S){const l=.5*i,Y=.5*V,g=.5*h,q=Math.sin(l),B=Math.cos(l),J=Math.sin(Y),I=Math.cos(Y),v=Math.sin(g),s=Math.cos(g);return S._x=s*J*B+v*I*q,S._y=v*I*B-s*J*q,S._z=s*I*q-v*J*B,S._w=s*I*B+v*J*q,S._isDirty=!0,S}static RotationAlphaBetaGamma(h,V,i){const S=new c;return c.RotationAlphaBetaGammaToRef(h,V,i,S),S}static RotationAlphaBetaGammaToRef(h,V,i,S){const l=.5*(i+h),Y=.5*(i-h),g=.5*V;return S._x=Math.cos(Y)*Math.sin(g),S._y=Math.sin(Y)*Math.sin(g),S._z=Math.sin(l)*Math.cos(g),S._w=Math.cos(l)*Math.cos(g),S._isDirty=!0,S}static RotationQuaternionFromAxis(h,V,i){const S=new c(0,0,0,0);return c.RotationQuaternionFromAxisToRef(h,V,i,S),S}static RotationQuaternionFromAxisToRef(h,V,i,S){const l=P.Matrix[0];return h=h.normalizeToRef(P.nV[0]),V=V.normalizeToRef(P.nV[1]),i=i.normalizeToRef(P.nV[2]),f.FromXYZAxesToRef(h,V,i,l),c.FromRotationMatrixToRef(l,S),S}static FromLookDirectionLH(h,V){const i=new c;return c.FromLookDirectionLHToRef(h,V,i),i}static FromLookDirectionLHToRef(h,V,i){const S=P.Matrix[0];return f.LookDirectionLHToRef(h,V,S),c.FromRotationMatrixToRef(S,i),i}static FromLookDirectionRH(h,V){const i=new c;return c.FromLookDirectionRHToRef(h,V,i),i}static FromLookDirectionRHToRef(h,V,i){const S=P.Matrix[0];return f.LookDirectionRHToRef(h,V,S),c.FromRotationMatrixToRef(S,i)}static Slerp(h,V,i){const S=c.Identity();return c.SlerpToRef(h,V,i,S),S}static SlerpToRef(h,V,i,S){let l,Y,g=h._x*V._x+h._y*V._y+h._z*V._z+h._w*V._w,q=!1;if(g<0&&(q=!0,g=-g),g>.999999)Y=1-i,l=q?-i:i;else{const h=Math.acos(g),V=1/Math.sin(h);Y=Math.sin((1-i)*h)*V,l=q?-Math.sin(i*h)*V:Math.sin(i*h)*V}return S._x=Y*h._x+l*V._x,S._y=Y*h._y+l*V._y,S._z=Y*h._z+l*V._z,S._w=Y*h._w+l*V._w,S._isDirty=!0,S}static Hermite(h,V,i,S,l){const Y=l*l,g=l*Y,q=2*g-3*Y+1,B=-2*g+3*Y,J=g-2*Y+l,I=g-Y,v=h._x*q+i._x*B+V._x*J+S._x*I,s=h._y*q+i._y*B+V._y*J+S._y*I,t=h._z*q+i._z*B+V._z*J+S._z*I,T=h._w*q+i._w*B+V._w*J+S._w*I;return new c(v,s,t,T)}static Hermite1stDerivative(h,V,i,S,l){const Y=new c;return this.Hermite1stDerivativeToRef(h,V,i,S,l,Y),Y}static Hermite1stDerivativeToRef(h,V,i,S,l,Y){const g=l*l;return Y._x=6*(g-l)*h._x+(3*g-4*l+1)*V._x+6*(-g+l)*i._x+(3*g-2*l)*S._x,Y._y=6*(g-l)*h._y+(3*g-4*l+1)*V._y+6*(-g+l)*i._y+(3*g-2*l)*S._y,Y._z=6*(g-l)*h._z+(3*g-4*l+1)*V._z+6*(-g+l)*i._z+(3*g-2*l)*S._z,Y._w=6*(g-l)*h._w+(3*g-4*l+1)*V._w+6*(-g+l)*i._w+(3*g-2*l)*S._w,Y._isDirty=!0,Y}static Normalize(h){const V=c.Zero();return c.NormalizeToRef(h,V),V}static NormalizeToRef(h,V){return h.normalizeToRef(V),V}static Clamp(h,V,i){const S=new c;return c.ClampToRef(h,V,i,S),S}static ClampToRef(h,V,i,S){return S.qq((0,B.Clamp)(h.x,V.x,i.x),(0,B.Clamp)(h.y,V.y,i.y),(0,B.Clamp)(h.z,V.z,i.z),(0,B.Clamp)(h.w,V.w,i.w))}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new c((0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).qq((0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V),(0,B.RandomRange)(h,V))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(h,V){return Math.sqrt(c.DistanceSquared(h,V))}static DistanceSquared(h,V){const i=h.x-V.x,S=h.y-V.y,l=h.z-V.z,Y=h.w-V.w;return i*i+S*S+l*l+Y*Y}static Center(h,V){return c.CenterToRef(h,V,c.Zero())}static CenterToRef(h,V,i){return i.qq((h.x+V.x)/2,(h.y+V.y)/2,(h.z+V.z)/2,(h.w+V.w)/2)}}c._V8PerformanceHack=new c(.5,.5,.5,.5),Object.defineProperties(c.prototype,{dimension:{value:[4]},rank:{value:1}});class f{static get Use64Bits(){return g.b.MatrixUse64Bits}get m(){return this.Tg}markAsUpdated(){this.updateFlag=J._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(h){let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],S=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=h,this._isIdentity3x2=h||i,this._isIdentityDirty=!this._isIdentity&&V,this._isIdentity3x2Dirty=!this._isIdentity3x2&&S}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,g.b.MatrixTrackPrecisionChange&&g.b.MatrixTrackedMatrices.push(this),this.Tg=new g.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const h=this.Tg;this._isIdentity=1===h[0]&&0===h[1]&&0===h[2]&&0===h[3]&&0===h[4]&&1===h[5]&&0===h[6]&&0===h[7]&&0===h[8]&&0===h[9]&&1===h[10]&&0===h[11]&&0===h[12]&&0===h[13]&&0===h[14]&&1===h[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Tg[0]||1!==this.Tg[5]||1!==this.Tg[15]||0!==this.Tg[1]||0!==this.Tg[2]||0!==this.Tg[3]||0!==this.Tg[4]||0!==this.Tg[6]||0!==this.Tg[7]||0!==this.Tg[8]||0!==this.Tg[9]||0!==this.Tg[10]||0!==this.Tg[11]||0!==this.Tg[12]||0!==this.Tg[13]||0!==this.Tg[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const h=this.Tg,V=h[0],i=h[1],S=h[2],l=h[3],Y=h[4],g=h[5],q=h[6],B=h[7],J=h[8],I=h[9],v=h[10],s=h[11],t=h[12],T=h[13],e=h[14],n=h[15],c=v*n-e*s,f=I*n-T*s,P=I*e-T*v,L=J*n-t*s,U=J*e-v*t,X=J*T-t*I;return V*+(g*c-q*f+B*P)+i*-(Y*c-q*L+B*U)+S*+(Y*f-g*L+B*X)+l*-(Y*P-g*U+q*X)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!h)return this.Tg;const i=this.Tg;for(let S=0;S<16;S++)h[V+S]=i[S];return this}Ng(){return this.Tg}ei(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f.FromArrayToRef(h,V,this)}qq(){for(var h=arguments.length,V=new Array(h),i=0;i<h;i++)V[i]=arguments[i];return f.FromArrayToRef(V,0,this)}set(){const h=this.Tg;for(let V=0;V<16;V++)h[V]=V<0||arguments.length<=V?void 0:arguments[V];return this.markAsUpdated(),this}Iq(h){const V=this.Tg;for(let i=0;i<16;i++)V[i]=h;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return f.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(h){const V=new f;return this.addToRef(h,V),V}addToRef(h,V){const i=this.Tg,S=V.Tg,l=h.m;for(let Y=0;Y<16;Y++)S[Y]=i[Y]+l[Y];return V.markAsUpdated(),V}addToSelf(h){const V=this.Tg,i=h.m;return V[0]+=i[0],V[1]+=i[1],V[2]+=i[2],V[3]+=i[3],V[4]+=i[4],V[5]+=i[5],V[6]+=i[6],V[7]+=i[7],V[8]+=i[8],V[9]+=i[9],V[10]+=i[10],V[11]+=i[11],V[12]+=i[12],V[13]+=i[13],V[14]+=i[14],V[15]+=i[15],this.markAsUpdated(),this}addInPlace(h){const V=this.Tg,i=h.m;for(let S=0;S<16;S++)V[S]+=i[S];return this.markAsUpdated(),this}addInPlaceFromFloats(){const h=this.Tg;for(let V=0;V<16;V++)h[V]+=V<0||arguments.length<=V?void 0:arguments[V];return this.markAsUpdated(),this}cV(h){const V=this.Tg,i=h.m;for(let S=0;S<16;S++)V[S]-=i[S];return this.markAsUpdated(),this}subtractToRef(h,V){const i=this.Tg,S=h.m,l=V.Tg;for(let Y=0;Y<16;Y++)l[Y]=i[Y]-S[Y];return V.markAsUpdated(),V}mI(h){const V=this.Tg,i=h.m;for(let S=0;S<16;S++)V[S]-=i[S];return this.markAsUpdated(),this}subtractFromFloats(){for(var h=arguments.length,V=new Array(h),i=0;i<h;i++)V[i]=arguments[i];return this.subtractFromFloatsToRef(...V,new f)}subtractFromFloatsToRef(){for(var h=arguments.length,V=new Array(h),i=0;i<h;i++)V[i]=arguments[i];const S=V.pop(),l=this.Tg,Y=S.Tg,g=V;for(let q=0;q<16;q++)Y[q]=l[q]-g[q];return S.markAsUpdated(),S}invertToRef(h){return!0===this._isIdentity?(f.IdentityToRef(h),h):(s(this,h.Ng())?h.markAsUpdated():h.l(this),h)}addAtIndex(h,V){return this.Tg[h]+=V,this.markAsUpdated(),this}multiplyAtIndex(h,V){return this.Tg[h]*=V,this.markAsUpdated(),this}setTranslationFromFloats(h,V,i){return this.Tg[12]=h,this.Tg[13]=V,this.Tg[14]=i,this.markAsUpdated(),this}addTranslationFromFloats(h,V,i){return this.Tg[12]+=h,this.Tg[13]+=V,this.Tg[14]+=i,this.markAsUpdated(),this}setTranslation(h){return this.setTranslationFromFloats(h._x,h._y,h._z)}getTranslation(){return new e(this.Tg[12],this.Tg[13],this.Tg[14])}getTranslationToRef(h){return h.x=this.Tg[12],h.y=this.Tg[13],h.z=this.Tg[14],h}removeRotationAndScaling(){const h=this.m;return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,h[12],h[13],h[14],h[15],this),this._updateIdentityStatus(0===h[12]&&0===h[13]&&0===h[14]&&1===h[15]),this}l(h){h.copyToArray(this.Tg);const V=h;return this.updateFlag=V.updateFlag,this._updateIdentityStatus(V._isIdentity,V._isIdentityDirty,V._isIdentity3x2,V._isIdentity3x2Dirty),this}copyToArray(h){return v(this,h,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(h){const V=new f;return this.multiplyToRef(h,V),V}multiplyInPlace(h){const V=this.Tg,i=h.m;for(let S=0;S<16;S++)V[S]*=i[S];return this.markAsUpdated(),this}multiplyByFloats(){const h=this.Tg;for(let V=0;V<16;V++)h[V]*=V<0||arguments.length<=V?void 0:arguments[V];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var h=arguments.length,V=new Array(h),i=0;i<h;i++)V[i]=arguments[i];const S=V.pop(),l=this.Tg,Y=S.Tg,g=V;for(let q=0;q<16;q++)Y[q]=l[q]*g[q];return S.markAsUpdated(),S}multiplyToRef(h,V){return this._isIdentity?(V.l(h),V):h._isIdentity?(V.l(this),V):(this.multiplyToArray(h,V.Tg,0),V.markAsUpdated(),V)}multiplyToArray(h,V,i){return I(this,h,V,i),this}divide(h){return this.divideToRef(h,new f)}divideToRef(h,V){const i=this.Tg,S=h.m,l=V.Tg;for(let Y=0;Y<16;Y++)l[Y]=i[Y]/S[Y];return V.markAsUpdated(),V}divideInPlace(h){const V=this.Tg,i=h.m;for(let S=0;S<16;S++)V[S]/=i[S];return this.markAsUpdated(),this}minimizeInPlace(h){const V=this.Tg,i=h.m;for(let S=0;S<16;S++)V[S]=Math.min(V[S],i[S]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const h=this.Tg;for(let V=0;V<16;V++)h[V]=Math.min(h[V],V<0||arguments.length<=V?void 0:arguments[V]);return this.markAsUpdated(),this}maximizeInPlace(h){const V=this.Tg,i=h.m;for(let S=0;S<16;S++)V[S]=Math.min(V[S],i[S]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const h=this.Tg;for(let V=0;V<16;V++)h[V]=Math.min(h[V],V<0||arguments.length<=V?void 0:arguments[V]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new f)}negateInPlace(){const h=this.Tg;for(let V=0;V<16;V++)h[V]=-h[V];return this.markAsUpdated(),this}negateToRef(h){const V=this.Tg,i=h.Tg;for(let S=0;S<16;S++)i[S]=-V[S];return h.markAsUpdated(),h}equals(h){const V=h;if(!V)return!1;if((this._isIdentity||V._isIdentity)&&!this._isIdentityDirty&&!V._isIdentityDirty)return this._isIdentity&&V._isIdentity;const i=this.m,S=V.m;return i[0]===S[0]&&i[1]===S[1]&&i[2]===S[2]&&i[3]===S[3]&&i[4]===S[4]&&i[5]===S[5]&&i[6]===S[6]&&i[7]===S[7]&&i[8]===S[8]&&i[9]===S[9]&&i[10]===S[10]&&i[11]===S[11]&&i[12]===S[12]&&i[13]===S[13]&&i[14]===S[14]&&i[15]===S[15]}equalsWithEpsilon(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const i=this.Tg,S=h.m;for(let l=0;l<16;l++)if(!(0,B.WithinEpsilon)(i[l],S[l],V))return!1;return!0}equalsToFloats(){const h=this.Tg;for(let V=0;V<16;V++)if(h[V]!=(V<0||arguments.length<=V?void 0:arguments[V]))return!1;return!0}floor(){return this.floorToRef(new f)}floorToRef(h){const V=this.Tg,i=h.Tg;for(let S=0;S<16;S++)i[S]=Math.floor(V[S]);return h.markAsUpdated(),h}fract(){return this.fractToRef(new f)}fractToRef(h){const V=this.Tg,i=h.Tg;for(let S=0;S<16;S++)i[S]=V[S]-Math.floor(V[S]);return h.markAsUpdated(),h}clone(){const h=new f;return h.l(this),h}getClassName(){return"Matrix"}getHashCode(){let h=t(this.Tg[0]);for(let V=1;V<16;V++)h=397*h^t(this.Tg[V]);return h}decomposeToTransformNode(h){return h.rotationQuaternion=h.rotationQuaternion||new c,this.decompose(h.Jq,h.rotationQuaternion,h.position)}decompose(h,V,i,S){let l=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return i&&i.Iq(0),h&&h.Iq(1),V&&V.qq(0,0,0,1),!0;const Y=this.Tg;if(i&&i.qq(Y[12],Y[13],Y[14]),(h=h||P.nV[0]).x=Math.sqrt(Y[0]*Y[0]+Y[1]*Y[1]+Y[2]*Y[2]),h.y=Math.sqrt(Y[4]*Y[4]+Y[5]*Y[5]+Y[6]*Y[6]),h.z=Math.sqrt(Y[8]*Y[8]+Y[9]*Y[9]+Y[10]*Y[10]),S){const V=(l?S.absoluteScaling.x:S.Jq.x)<0?-1:1,i=(l?S.absoluteScaling.y:S.Jq.y)<0?-1:1,Y=(l?S.absoluteScaling.z:S.Jq.z)<0?-1:1;h.x*=V,h.y*=i,h.z*=Y}else this.determinant()<=0&&(h.y*=-1);if(0===h._x||0===h._y||0===h._z)return V&&V.qq(0,0,0,1),!1;if(V){const i=1/h._x,S=1/h._y,l=1/h._z;f.FromValuesToRef(Y[0]*i,Y[1]*i,Y[2]*i,0,Y[4]*S,Y[5]*S,Y[6]*S,0,Y[8]*l,Y[9]*l,Y[10]*l,0,0,0,0,1,P.Matrix[0]),c.FromRotationMatrixToRef(P.Matrix[0],V)}return!0}getRow(h){if(h<0||h>3)return null;const V=4*h;return new n(this.Tg[V+0],this.Tg[V+1],this.Tg[V+2],this.Tg[V+3])}getRowToRef(h,V){if(h>=0&&h<=3){const i=4*h;V.x=this.Tg[i+0],V.y=this.Tg[i+1],V.z=this.Tg[i+2],V.w=this.Tg[i+3]}return V}setRow(h,V){return this.setRowFromFloats(h,V.x,V.y,V.z,V.w)}transpose(){const h=new f;return f.TransposeToRef(this,h),h}transposeToRef(h){return f.TransposeToRef(this,h),h}setRowFromFloats(h,V,i,S,l){if(h<0||h>3)return this;const Y=4*h;return this.Tg[Y+0]=V,this.Tg[Y+1]=i,this.Tg[Y+2]=S,this.Tg[Y+3]=l,this.markAsUpdated(),this}scale(h){const V=new f;return this.scaleToRef(h,V),V}scaleToRef(h,V){for(let i=0;i<16;i++)V.Tg[i]=this.Tg[i]*h;return V.markAsUpdated(),V}scaleAndAddToRef(h,V){for(let i=0;i<16;i++)V.Tg[i]+=this.Tg[i]*h;return V.markAsUpdated(),V}scaleInPlace(h){const V=this.Tg;for(let i=0;i<16;i++)V[i]*=h;return this.markAsUpdated(),this}toNormalMatrix(h){const V=P.Matrix[0];this.invertToRef(V),V.transposeToRef(h);const i=h.Tg;return f.FromValuesToRef(i[0],i[1],i[2],0,i[4],i[5],i[6],0,i[8],i[9],i[10],0,0,0,0,1,h),h}getRotationMatrix(){const h=new f;return this.getRotationMatrixToRef(h),h}getRotationMatrixToRef(h){const V=P.nV[0];if(!this.decompose(V))return f.IdentityToRef(h),h;const i=this.Tg,S=1/V._x,l=1/V._y,Y=1/V._z;return f.FromValuesToRef(i[0]*S,i[1]*S,i[2]*S,0,i[4]*l,i[5]*l,i[6]*l,0,i[8]*Y,i[9]*Y,i[10]*Y,0,0,0,0,1,h),h}toggleModelMatrixHandInPlace(){const h=this.Tg;return h[2]*=-1,h[6]*=-1,h[8]*=-1,h[9]*=-1,h[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const h=this.Tg;return h[8]*=-1,h[9]*=-1,h[10]*=-1,h[11]*=-1,this.markAsUpdated(),this}static UV(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const i=new f;return f.FromArrayToRef(h,V,i),i}static FromArrayToRef(h,V,i){for(let S=0;S<16;S++)i.Tg[S]=h[S+V];return i.markAsUpdated(),i}static FromFloat32ArrayToRefScaled(h,V,i,S){return S.Tg[0]=h[0+V]*i,S.Tg[1]=h[1+V]*i,S.Tg[2]=h[2+V]*i,S.Tg[3]=h[3+V]*i,S.Tg[4]=h[4+V]*i,S.Tg[5]=h[5+V]*i,S.Tg[6]=h[6+V]*i,S.Tg[7]=h[7+V]*i,S.Tg[8]=h[8+V]*i,S.Tg[9]=h[9+V]*i,S.Tg[10]=h[10+V]*i,S.Tg[11]=h[11+V]*i,S.Tg[12]=h[12+V]*i,S.Tg[13]=h[13+V]*i,S.Tg[14]=h[14+V]*i,S.Tg[15]=h[15+V]*i,S.markAsUpdated(),S}static get IdentityReadOnly(){return f._IdentityReadOnly}static FromValuesToRef(h,V,i,S,l,Y,g,q,B,J,I,v,s,t,T,e,n){const c=n.Tg;c[0]=h,c[1]=V,c[2]=i,c[3]=S,c[4]=l,c[5]=Y,c[6]=g,c[7]=q,c[8]=B,c[9]=J,c[10]=I,c[11]=v,c[12]=s,c[13]=t,c[14]=T,c[15]=e,n.markAsUpdated()}static FromValues(h,V,i,S,l,Y,g,q,B,J,I,v,s,t,T,e){const n=new f,c=n.Tg;return c[0]=h,c[1]=V,c[2]=i,c[3]=S,c[4]=l,c[5]=Y,c[6]=g,c[7]=q,c[8]=B,c[9]=J,c[10]=I,c[11]=v,c[12]=s,c[13]=t,c[14]=T,c[15]=e,n.markAsUpdated(),n}static Compose(h,V,i){const S=new f;return f.ComposeToRef(h,V,i,S),S}static ComposeToRef(h,V,i,S){const l=S.Tg,Y=V._x,g=V._y,q=V._z,B=V._w,J=Y+Y,I=g+g,v=q+q,s=Y*J,t=Y*I,T=Y*v,e=g*I,n=g*v,c=q*v,f=B*J,P=B*I,L=B*v,U=h._x,X=h._y,D=h._z;return l[0]=(1-(e+c))*U,l[1]=(t+L)*U,l[2]=(T-P)*U,l[3]=0,l[4]=(t-L)*X,l[5]=(1-(s+c))*X,l[6]=(n+f)*X,l[7]=0,l[8]=(T+P)*D,l[9]=(n-f)*D,l[10]=(1-(s+e))*D,l[11]=0,l[12]=i._x,l[13]=i._y,l[14]=i._z,l[15]=1,S.markAsUpdated(),S}static Identity(){const h=f.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return h._updateIdentityStatus(!0),h}static IdentityToRef(h){return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,h),h._updateIdentityStatus(!0),h}static Zero(){const h=f.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return h._updateIdentityStatus(!1),h}static RotationX(h){const V=new f;return f.RotationXToRef(h,V),V}static Invert(h){const V=new f;return h.invertToRef(V),V}static RotationXToRef(h,V){const i=Math.sin(h),S=Math.cos(h);return f.FromValuesToRef(1,0,0,0,0,S,i,0,0,-i,S,0,0,0,0,1,V),V._updateIdentityStatus(1===S&&0===i),V}static RotationY(h){const V=new f;return f.RotationYToRef(h,V),V}static RotationYToRef(h,V){const i=Math.sin(h),S=Math.cos(h);return f.FromValuesToRef(S,0,-i,0,0,1,0,0,i,0,S,0,0,0,0,1,V),V._updateIdentityStatus(1===S&&0===i),V}static RotationZ(h){const V=new f;return f.RotationZToRef(h,V),V}static RotationZToRef(h,V){const i=Math.sin(h),S=Math.cos(h);return f.FromValuesToRef(S,i,0,0,-i,S,0,0,0,0,1,0,0,0,0,1,V),V._updateIdentityStatus(1===S&&0===i),V}static RotationAxis(h,V){const i=new f;return f.RotationAxisToRef(h,V,i),i}static RotationAxisToRef(h,V,i){const S=Math.sin(-V),l=Math.cos(-V),Y=1-l;h=h.normalizeToRef(P.nV[0]);const g=i.Tg;return g[0]=h._x*h._x*Y+l,g[1]=h._x*h._y*Y-h._z*S,g[2]=h._x*h._z*Y+h._y*S,g[3]=0,g[4]=h._y*h._x*Y+h._z*S,g[5]=h._y*h._y*Y+l,g[6]=h._y*h._z*Y-h._x*S,g[7]=0,g[8]=h._z*h._x*Y-h._y*S,g[9]=h._z*h._y*Y+h._x*S,g[10]=h._z*h._z*Y+l,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,i.markAsUpdated(),i}static RotationAlignToRef(h,V,i){let l=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const Y=e.Dot(V,h),g=i.Tg;if(Y<-1+S.c)g[0]=-1,g[1]=0,g[2]=0,g[3]=0,g[4]=0,g[5]=l?1:-1,g[6]=0,g[7]=0,g[8]=0,g[9]=0,g[10]=l?-1:1,g[11]=0;else{const i=e.Cross(V,h),S=1/(1+Y);g[0]=i._x*i._x*S+Y,g[1]=i._y*i._x*S-i._z,g[2]=i._z*i._x*S+i._y,g[3]=0,g[4]=i._x*i._y*S+i._z,g[5]=i._y*i._y*S+Y,g[6]=i._z*i._y*S-i._x,g[7]=0,g[8]=i._x*i._z*S-i._y,g[9]=i._y*i._z*S+i._x,g[10]=i._z*i._z*S+Y,g[11]=0}return g[12]=0,g[13]=0,g[14]=0,g[15]=1,i.markAsUpdated(),i}static RotationYawPitchRoll(h,V,i){const S=new f;return f.RotationYawPitchRollToRef(h,V,i,S),S}static RotationYawPitchRollToRef(h,V,i,S){return c.RotationYawPitchRollToRef(h,V,i,P.Quaternion[0]),P.Quaternion[0].toRotationMatrix(S),S}static Scaling(h,V,i){const S=new f;return f.ScalingToRef(h,V,i,S),S}static ScalingToRef(h,V,i,S){return f.FromValuesToRef(h,0,0,0,0,V,0,0,0,0,i,0,0,0,0,1,S),S._updateIdentityStatus(1===h&&1===V&&1===i),S}static Translation(h,V,i){const S=new f;return f.TranslationToRef(h,V,i,S),S}static TranslationToRef(h,V,i,S){return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,h,V,i,1,S),S._updateIdentityStatus(0===h&&0===V&&0===i),S}static Lerp(h,V,i){const S=new f;return f.LerpToRef(h,V,i,S),S}static LerpToRef(h,V,i,S){const l=S.Tg,Y=h.m,g=V.m;for(let q=0;q<16;q++)l[q]=Y[q]*(1-i)+g[q]*i;return S.markAsUpdated(),S}static DecomposeLerp(h,V,i){const S=new f;return f.DecomposeLerpToRef(h,V,i,S),S}static DecomposeLerpToRef(h,V,i,S){const l=P.nV[0],Y=P.Quaternion[0],g=P.nV[1];h.decompose(l,Y,g);const q=P.nV[2],B=P.Quaternion[1],J=P.nV[3];V.decompose(q,B,J);const I=P.nV[4];e.LerpToRef(l,q,i,I);const v=P.Quaternion[2];c.SlerpToRef(Y,B,i,v);const s=P.nV[5];return e.LerpToRef(g,J,i,s),f.ComposeToRef(I,v,s,S),S}static LookAtLH(h,V,i){const S=new f;return f.LookAtLHToRef(h,V,i,S),S}static LookAtLHToRef(h,V,i,S){const l=P.nV[0],Y=P.nV[1],g=P.nV[2];V.subtractToRef(h,g),g.normalize(),e.CrossToRef(i,g,l);const q=l.lengthSquared();0===q?l.x=1:l.normalizeFromLength(Math.sqrt(q)),e.CrossToRef(g,l,Y),Y.normalize();const B=-e.Dot(l,h),J=-e.Dot(Y,h),I=-e.Dot(g,h);return f.FromValuesToRef(l._x,Y._x,g._x,0,l._y,Y._y,g._y,0,l._z,Y._z,g._z,0,B,J,I,1,S),S}static LookAtRH(h,V,i){const S=new f;return f.LookAtRHToRef(h,V,i,S),S}static LookAtRHToRef(h,V,i,S){const l=P.nV[0],Y=P.nV[1],g=P.nV[2];h.subtractToRef(V,g),g.normalize(),e.CrossToRef(i,g,l);const q=l.lengthSquared();0===q?l.x=1:l.normalizeFromLength(Math.sqrt(q)),e.CrossToRef(g,l,Y),Y.normalize();const B=-e.Dot(l,h),J=-e.Dot(Y,h),I=-e.Dot(g,h);return f.FromValuesToRef(l._x,Y._x,g._x,0,l._y,Y._y,g._y,0,l._z,Y._z,g._z,0,B,J,I,1,S),S}static LookDirectionLH(h,V){const i=new f;return f.LookDirectionLHToRef(h,V,i),i}static LookDirectionLHToRef(h,V,i){const S=P.nV[0];S.l(h),S.scaleInPlace(-1);const l=P.nV[1];return e.CrossToRef(V,S,l),f.FromValuesToRef(l._x,l._y,l._z,0,V._x,V._y,V._z,0,S._x,S._y,S._z,0,0,0,0,1,i),i}static LookDirectionRH(h,V){const i=new f;return f.LookDirectionRHToRef(h,V,i),i}static LookDirectionRHToRef(h,V,i){const S=P.nV[2];return e.CrossToRef(V,h,S),f.FromValuesToRef(S._x,S._y,S._z,0,V._x,V._y,V._z,0,h._x,h._y,h._z,0,0,0,0,1,i),i}static OrthoLH(h,V,i,S,l){const Y=new f;return f.OrthoLHToRef(h,V,i,S,Y,l),Y}static OrthoLHToRef(h,V,i,S,l,Y){const g=2/h,q=2/V,B=2/(S-i),J=-(S+i)/(S-i);return f.FromValuesToRef(g,0,0,0,0,q,0,0,0,0,B,0,0,0,J,1,l),Y&&l.multiplyToRef(U,l),l._updateIdentityStatus(1===g&&1===q&&1===B&&0===J),l}static OrthoOffCenterLH(h,V,i,S,l,Y,g){const q=new f;return f.OrthoOffCenterLHToRef(h,V,i,S,l,Y,q,g),q}static OrthoOffCenterLHToRef(h,V,i,S,l,Y,g,q){const B=2/(V-h),J=2/(S-i),I=2/(Y-l),v=-(Y+l)/(Y-l),s=(h+V)/(h-V),t=(S+i)/(i-S);return f.FromValuesToRef(B,0,0,0,0,J,0,0,0,0,I,0,s,t,v,1,g),q&&g.multiplyToRef(U,g),g.markAsUpdated(),g}static ObliqueOffCenterLHToRef(h,V,i,S,l,Y,g,q,B,J,I){const v=-g*Math.cos(q),s=-g*Math.sin(q);return f.TranslationToRef(0,0,-B,P.Matrix[1]),f.FromValuesToRef(1,0,0,0,0,1,0,0,v,s,1,0,0,0,0,1,P.Matrix[0]),P.Matrix[1].multiplyToRef(P.Matrix[0],P.Matrix[0]),f.TranslationToRef(0,0,B,P.Matrix[1]),P.Matrix[0].multiplyToRef(P.Matrix[1],P.Matrix[0]),f.OrthoOffCenterLHToRef(h,V,i,S,l,Y,J,I),P.Matrix[0].multiplyToRef(J,J),J}static OrthoOffCenterRH(h,V,i,S,l,Y,g){const q=new f;return f.OrthoOffCenterRHToRef(h,V,i,S,l,Y,q,g),q}static OrthoOffCenterRHToRef(h,V,i,S,l,Y,g,q){return f.OrthoOffCenterLHToRef(h,V,i,S,l,Y,g,q),g.Tg[10]*=-1,g}static ObliqueOffCenterRHToRef(h,V,i,S,l,Y,g,q,B,J,I){const v=g*Math.cos(q),s=g*Math.sin(q);return f.TranslationToRef(0,0,B,P.Matrix[1]),f.FromValuesToRef(1,0,0,0,0,1,0,0,v,s,1,0,0,0,0,1,P.Matrix[0]),P.Matrix[1].multiplyToRef(P.Matrix[0],P.Matrix[0]),f.TranslationToRef(0,0,-B,P.Matrix[1]),P.Matrix[0].multiplyToRef(P.Matrix[1],P.Matrix[0]),f.OrthoOffCenterRHToRef(h,V,i,S,l,Y,J,I),P.Matrix[0].multiplyToRef(J,J),J}static PerspectiveLH(h,V,i,S,l){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const g=new f,q=2*i/h,B=2*i/V,J=(S+i)/(S-i),I=-2*S*i/(S-i),v=Math.tan(Y);return f.FromValuesToRef(q,0,0,0,0,B,0,v,0,0,J,1,0,0,I,0,g),l&&g.multiplyToRef(U,g),g._updateIdentityStatus(!1),g}static PerspectiveFovLH(h,V,i,S,l){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const q=new f;return f.PerspectiveFovLHToRef(h,V,i,S,q,!0,l,Y,g),q}static PerspectiveFovLHToRef(h,V,i,S,l){let Y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,q=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,B=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const J=i,I=S,v=1/Math.tan(.5*h),s=Y?v/V:v,t=Y?v:v*V,T=B&&0===J?-1:0!==I?(I+J)/(I-J):1,e=B&&0===J?2*I:0!==I?-2*I*J/(I-J):-2*J,n=Math.tan(q);return f.FromValuesToRef(s,0,0,0,0,t,0,n,0,0,T,1,0,0,e,0,l),g&&l.multiplyToRef(U,l),l._updateIdentityStatus(!1),l}static PerspectiveFovReverseLHToRef(h,V,i,S,l){let Y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,q=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const B=1/Math.tan(.5*h),J=Y?B/V:B,I=Y?B:B*V,v=Math.tan(q);return f.FromValuesToRef(J,0,0,0,0,I,0,v,0,0,-i,1,0,0,1,0,l),g&&l.multiplyToRef(U,l),l._updateIdentityStatus(!1),l}static PerspectiveFovRH(h,V,i,S,l){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const q=new f;return f.PerspectiveFovRHToRef(h,V,i,S,q,!0,l,Y,g),q}static PerspectiveFovRHToRef(h,V,i,S,l){let Y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,q=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,B=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const J=i,I=S,v=1/Math.tan(.5*h),s=Y?v/V:v,t=Y?v:v*V,T=B&&0===J?1:0!==I?-(I+J)/(I-J):-1,e=B&&0===J?2*I:0!==I?-2*I*J/(I-J):-2*J,n=Math.tan(q);return f.FromValuesToRef(s,0,0,0,0,t,0,n,0,0,T,-1,0,0,e,0,l),g&&l.multiplyToRef(U,l),l._updateIdentityStatus(!1),l}static PerspectiveFovReverseRHToRef(h,V,i,S,l){let Y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,q=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const B=1/Math.tan(.5*h),J=Y?B/V:B,I=Y?B:B*V,v=Math.tan(q);return f.FromValuesToRef(J,0,0,0,0,I,0,v,0,0,-i,-1,0,0,-1,0,l),g&&l.multiplyToRef(U,l),l._updateIdentityStatus(!1),l}static GetFinalMatrix(h,V,i,S,l,Y){const g=h.width,q=h.height,B=h.x,J=h.y,I=f.FromValues(g/2,0,0,0,0,-q/2,0,0,0,0,Y-l,0,B+g/2,q/2+J,l,1),v=new f;return V.multiplyToRef(i,v),v.multiplyToRef(S,v),v.multiplyToRef(I,v)}static GetAsMatrix2x2(h){const V=h.m,i=[V[0],V[1],V[4],V[5]];return g.b.MatrixUse64Bits?i:new Float32Array(i)}static GetAsMatrix3x3(h){const V=h.m,i=[V[0],V[1],V[2],V[4],V[5],V[6],V[8],V[9],V[10]];return g.b.MatrixUse64Bits?i:new Float32Array(i)}static Transpose(h){const V=new f;return f.TransposeToRef(h,V),V}static TransposeToRef(h,V){const i=h.m,S=i[0],l=i[4],Y=i[8],g=i[12],q=i[1],B=i[5],J=i[9],I=i[13],v=i[2],s=i[6],t=i[10],T=i[14],e=i[3],n=i[7],c=i[11],f=i[15],P=V.Tg;return P[0]=S,P[1]=l,P[2]=Y,P[3]=g,P[4]=q,P[5]=B,P[6]=J,P[7]=I,P[8]=v,P[9]=s,P[10]=t,P[11]=T,P[12]=e,P[13]=n,P[14]=c,P[15]=f,V.markAsUpdated(),V._updateIdentityStatus(h._isIdentity,h._isIdentityDirty),V}static Reflection(h){const V=new f;return f.ReflectionToRef(h,V),V}static ReflectionToRef(h,V){h.normalize();const i=h.normal.x,S=h.normal.y,l=h.normal.z,Y=-2*i,g=-2*S,q=-2*l;return f.FromValuesToRef(Y*i+1,g*i,q*i,0,Y*S,g*S+1,q*S,0,Y*l,g*l,q*l+1,0,Y*h.d,g*h.d,q*h.d,1,V),V}static FromXYZAxesToRef(h,V,i,S){return f.FromValuesToRef(h._x,h._y,h._z,0,V._x,V._y,V._z,0,i._x,i._y,i._z,0,0,0,0,1,S),S}static FromQuaternionToRef(h,V){const i=h._x*h._x,S=h._y*h._y,l=h._z*h._z,Y=h._x*h._y,g=h._z*h._w,q=h._z*h._x,B=h._y*h._w,J=h._y*h._z,I=h._x*h._w;return V.Tg[0]=1-2*(S+l),V.Tg[1]=2*(Y+g),V.Tg[2]=2*(q-B),V.Tg[3]=0,V.Tg[4]=2*(Y-g),V.Tg[5]=1-2*(l+i),V.Tg[6]=2*(J+I),V.Tg[7]=0,V.Tg[8]=2*(q+B),V.Tg[9]=2*(J-I),V.Tg[10]=1-2*(S+i),V.Tg[11]=0,V.Tg[12]=0,V.Tg[13]=0,V.Tg[14]=0,V.Tg[15]=1,V.markAsUpdated(),V}}f._IdentityReadOnly=f.Identity(),Object.defineProperties(f.prototype,{dimension:{value:[4,4]},rank:{value:2}});class P{}P.nV=(0,l.d)(11,e.Zero),P.Matrix=(0,l.d)(2,f.Identity),P.Quaternion=(0,l.d)(3,c.Zero);class L{}L.Vector2=(0,l.d)(3,T.Zero),L.nV=(0,l.d)(13,e.Zero),L.Vector4=(0,l.d)(3,n.Zero),L.Quaternion=(0,l.d)(3,c.Zero),L.Matrix=(0,l.d)(8,f.Identity),(0,Y.f)("BABYLON.Vector2",T),(0,Y.f)("BABYLON.Vector3",e),(0,Y.f)("BABYLON.Vector4",n),(0,Y.f)("BABYLON.Matrix",f);const U=f.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11156:(h,V,i)=>{function S(h,V){const i=[];for(let S=0;S<h;++S)i.push(V());return i}function l(h,V){return S(h,V)}i.d(V,{c:()=>S,d:()=>l,e:()=>g});const Y=["push","splice","pop","shift","unshift"];function g(h,V){const i=Y.map((i=>function(h,V,i){const S=h[V];if("function"!==typeof S)return null;const l=function(){const S=h.length,Y=l.previous.apply(h,arguments);return i(V,S),Y};return S.next=l,l.previous=S,h[V]=l,()=>{const i=l.previous;if(!i)return;const S=l.next;S?(i.next=S,S.previous=i):(i.next=void 0,h[V]=i),l.next=void 0,l.previous=void 0}}(h,i,V)));return()=>{for(const h of i)null===h||void 0===h||h()}}}}]);