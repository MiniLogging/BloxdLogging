"use strict";(self.vb3rpbgyozo=self.vb3rpbgyozo||[]).push([[14],{12752:(q,I,l)=>{l.d(I,{d:()=>c,h:()=>O,i:()=>w,m:()=>t});const w=1/2.2,t=2.2,O=(1+Math.sqrt(5))/2,c=.001},12761:(q,I,l)=>{function w(q){return parseInt(q.toString().replace(/\W/g,""))}function t(q,I){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(q-I)<=l}function O(q,I,l){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return q<I-w||q>l+w}function c(q,I){return q===I?q:Math.random()*(I-q)+q}function a(q,I,l){return q+(I-q)*l}function F(q,I,l){let w=V(I-q,360);return w>180&&(w-=360),q+w*x(l)}function s(q,I,l){let w=0;return w=q!=I?x((l-q)/(I-q)):0,w}function Z(q,I,l,w,t){const O=t*t,c=t*O;return q*(2*c-3*O+1)+l*(-2*c+3*O)+I*(c-2*O+t)+w*(c-O)}function r(q,I,l,w,t){const O=t*t;return 6*(O-t)*q+(3*O-4*t+1)*I+6*(-O+t)*l+(3*O-2*t)*w}function x(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(l,Math.max(I,q))}function o(q){return q-=2*Math.PI*Math.floor((q+Math.PI)/(2*Math.PI))}function d(q){const I=q.toString(16);return q<=15?("0"+I).toUpperCase():I.toUpperCase()}function T(q){if(Math.log2)return Math.floor(Math.log2(q));if(q<0)return NaN;if(0===q)return-1/0;let I=0;if(q<1){for(;q<1;)I++,q*=2;I=-I}else if(q>1)for(;q>1;)I++,q=Math.floor(q/2);return I}function V(q,I){return q-Math.floor(q/I)*I}function U(q,I,l){return(q-I)/(l-I)}function B(q,I,l){return q*(l-I)+I}function v(q,I){let l=V(I-q,360);return l>180&&(l-=360),l}function k(q,I){const l=V(q,2*I);return I-Math.abs(l-I)}function C(q,I,l){let w=x(l);return w=-2*w*w*w+3*w*w,I*w+q*(1-w)}function R(q,I,l){let w=0;return w=Math.abs(I-q)<=l?I:q+Math.sign(I-q)*l,w}function W(q,I,l){const w=v(q,I);let t=0;return t=-l<w&&w<l?I:R(q,I=q+w,l),t}function e(q,I,l){return(q-I)/(l-I)}function i(q,I,l){return(l-I)*q+I}function S(q,I){const l=q%I;return 0===l?I:S(I,l)}l.r(I),l.d(I,{Clamp:()=>x,DeltaAngle:()=>v,Denormalize:()=>B,ExtractAsInt:()=>w,Hermite:()=>Z,Hermite1stDerivative:()=>r,HighestCommonFactor:()=>S,ILog2:()=>T,InverseLerp:()=>s,Lerp:()=>a,LerpAngle:()=>F,MoveTowards:()=>R,MoveTowardsAngle:()=>W,Normalize:()=>U,NormalizeRadians:()=>o,OutsideRange:()=>O,PercentToRange:()=>i,PingPong:()=>k,RandomRange:()=>c,RangeToPercent:()=>e,Repeat:()=>V,SmoothStep:()=>C,ToHex:()=>d,WithinEpsilon:()=>t})},12747:(q,I,l)=>{l.r(I),l.d(I,{Matrix:()=>B,Quaternion:()=>U,TmpVectors:()=>k,Vector2:()=>d,dI:()=>T,Vector4:()=>V});var w=l(12752),t=l(12757),O=l(12711),c=l(12683),a=l(12612),F=l(12761);class s{}function Z(q,I,l){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const t=q.Uc(),O=I.Uc(),c=t[0],a=t[1],F=t[2],s=t[3],Z=t[4],r=t[5],x=t[6],o=t[7],d=t[8],T=t[9],V=t[10],U=t[11],B=t[12],v=t[13],k=t[14],C=t[15],R=O[0],W=O[1],e=O[2],i=O[3],S=O[4],g=O[5],p=O[6],X=O[7],K=O[8],D=O[9],M=O[10],n=O[11],f=O[12],L=O[13],E=O[14],j=O[15];l[w]=c*R+a*S+F*K+s*f,l[w+1]=c*W+a*g+F*D+s*L,l[w+2]=c*e+a*p+F*M+s*E,l[w+3]=c*i+a*X+F*n+s*j,l[w+4]=Z*R+r*S+x*K+o*f,l[w+5]=Z*W+r*g+x*D+o*L,l[w+6]=Z*e+r*p+x*M+o*E,l[w+7]=Z*i+r*X+x*n+o*j,l[w+8]=d*R+T*S+V*K+U*f,l[w+9]=d*W+T*g+V*D+U*L,l[w+10]=d*e+T*p+V*M+U*E,l[w+11]=d*i+T*X+V*n+U*j,l[w+12]=B*R+v*S+k*K+C*f,l[w+13]=B*W+v*g+k*D+C*L,l[w+14]=B*e+v*p+k*M+C*E,l[w+15]=B*i+v*X+k*n+C*j}function r(q,I){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const w=q.Uc();I[l]=w[0],I[l+1]=w[1],I[l+2]=w[2],I[l+3]=w[3],I[l+4]=w[4],I[l+5]=w[5],I[l+6]=w[6],I[l+7]=w[7],I[l+8]=w[8],I[l+9]=w[9],I[l+10]=w[10],I[l+11]=w[11],I[l+12]=w[12],I[l+13]=w[13],I[l+14]=w[14],I[l+15]=w[15]}function x(q,I){const l=q.Uc(),w=l[0],t=l[1],O=l[2],c=l[3],a=l[4],F=l[5],s=l[6],Z=l[7],r=l[8],x=l[9],o=l[10],d=l[11],T=l[12],V=l[13],U=l[14],B=l[15],v=o*B-U*d,k=x*B-V*d,C=x*U-V*o,R=r*B-T*d,W=r*U-o*T,e=r*V-T*x,i=+(F*v-s*k+Z*C),S=-(a*v-s*R+Z*W),g=+(a*k-F*R+Z*e),p=-(a*C-F*W+s*e),X=w*i+t*S+O*g+c*p;if(0===X)return!1;const K=1/X,D=s*B-U*Z,M=F*B-V*Z,n=F*U-V*s,f=a*B-T*Z,L=a*U-T*s,E=a*V-T*F,j=s*d-o*Z,h=F*d-x*Z,u=F*o-x*s,P=a*d-r*Z,mq=a*o-r*s,Y=a*x-r*F,y=-(t*v-O*k+c*C),G=+(w*v-O*R+c*W),N=-(w*k-t*R+c*e),J=+(w*C-t*W+O*e),z=+(t*D-O*M+c*n),H=-(w*D-O*f+c*L),A=+(w*M-t*f+c*E),Q=-(w*n-t*L+O*E),b=-(t*j-O*h+c*u),qq=+(w*j-O*P+c*mq),Iq=-(w*h-t*P+c*Y),lq=+(w*u-t*mq+O*Y);return I[0]=i*K,I[1]=y*K,I[2]=z*K,I[3]=b*K,I[4]=S*K,I[5]=G*K,I[6]=H*K,I[7]=qq*K,I[8]=g*K,I[9]=N*K,I[10]=A*K,I[11]=Iq*K,I[12]=p*K,I[13]=J*K,I[14]=Q*K,I[15]=lq*K,!0}s._UpdateFlagSeed=0;const o=q=>parseInt(q.toString().replace(/\W/g,""));class d{constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=q,this.y=I}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let q=o(this.x);return q=397*q^o(this.y),q}toArray(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q[I]=this.x,q[I+1]=this.y,this}dl(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return d.FromArrayToRef(q,I,this),this}Uc(){return[this.x,this.y]}t(q){return this.x=q.x,this.y=q.y,this}gc(q,I){return this.x=q,this.y=I,this}set(q,I){return this.gc(q,I)}Kc(q){return this.gc(q,q)}add(q){return new d(this.x+q.x,this.y+q.y)}addToRef(q,I){return I.x=this.x+q.x,I.y=this.y+q.y,I}addInPlace(q){return this.x+=q.x,this.y+=q.y,this}addInPlaceFromFloats(q,I){return this.x+=q,this.y+=I,this}addVector3(q){return new d(this.x+q.x,this.y+q.y)}TI(q){return new d(this.x-q.x,this.y-q.y)}subtractToRef(q,I){return I.x=this.x-q.x,I.y=this.y-q.y,I}Sr(q){return this.x-=q.x,this.y-=q.y,this}multiplyInPlace(q){return this.x*=q.x,this.y*=q.y,this}multiply(q){return new d(this.x*q.x,this.y*q.y)}multiplyToRef(q,I){return I.x=this.x*q.x,I.y=this.y*q.y,I}multiplyByFloats(q,I){return new d(this.x*q,this.y*I)}divide(q){return new d(this.x/q.x,this.y/q.y)}divideToRef(q,I){return I.x=this.x/q.x,I.y=this.y/q.y,I}divideInPlace(q){return this.x=this.x/q.x,this.y=this.y/q.y,this}minimizeInPlace(q){return this.minimizeInPlaceFromFloats(q.x,q.y)}maximizeInPlace(q){return this.maximizeInPlaceFromFloats(q.x,q.y)}minimizeInPlaceFromFloats(q,I){return this.x=Math.min(q,this.x),this.y=Math.min(I,this.y),this}maximizeInPlaceFromFloats(q,I){return this.x=Math.max(q,this.x),this.y=Math.max(I,this.y),this}subtractFromFloats(q,I){return new d(this.x-q,this.y-I)}subtractFromFloatsToRef(q,I,l){return l.x=this.x-q,l.y=this.y-I,l}negate(){return new d(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(q){return q.x=-this.x,q.y=-this.y,q}scaleInPlace(q){return this.x*=q,this.y*=q,this}scale(q){return new d(this.x*q,this.y*q)}scaleToRef(q,I){return I.x=this.x*q,I.y=this.y*q,I}scaleAndAddToRef(q,I){return I.x+=this.x*q,I.y+=this.y*q,I}equals(q){return q&&this.x===q.x&&this.y===q.y}equalsWithEpsilon(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:w.d;return q&&(0,F.WithinEpsilon)(this.x,q.x,I)&&(0,F.WithinEpsilon)(this.y,q.y,I)}equalsToFloats(q,I){return this.x===q&&this.y===I}floor(){return new d(Math.floor(this.x),Math.floor(this.y))}floorToRef(q){return q.x=Math.floor(this.x),q.y=Math.floor(this.y),q}fract(){return new d(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(q){return q.x=this.x-Math.floor(this.x),q.y=this.y-Math.floor(this.y),q}rotate(q){return this.rotateToRef(q,new d)}rotateToRef(q,I){const l=Math.cos(q),w=Math.sin(q);return I.x=l*this.x-w*this.y,I.y=w*this.x+l*this.y,I}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(q){return 0===q||1===q?this:this.scaleInPlace(1/q)}normalizeToNew(){const q=new d;return this.normalizeToRef(q),q}normalizeToRef(q){const I=this.length();return 0===I&&(q.x=this.x,q.y=this.y),this.scaleToRef(1/I,q)}clone(){return new d(this.x,this.y)}dot(q){return this.x*q.x+this.y*q.y}static Zero(){return new d(0,0)}static One(){return new d(1,1)}static Random(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new d((0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I))}static RandomToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).gc((0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I))}static get ZeroReadOnly(){return d._ZeroReadOnly}static vI(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new d(q[I],q[I+1])}static FromArrayToRef(q,I,l){return l.x=q[I],l.y=q[I+1],l}static FromFloatsToRef(q,I,l){return l.gc(q,I),l}static CatmullRom(q,I,l,w,t){const O=t*t,c=t*O,a=.5*(2*I.x+(-q.x+l.x)*t+(2*q.x-5*I.x+4*l.x-w.x)*O+(-q.x+3*I.x-3*l.x+w.x)*c),F=.5*(2*I.y+(-q.y+l.y)*t+(2*q.y-5*I.y+4*l.y-w.y)*O+(-q.y+3*I.y-3*l.y+w.y)*c);return new d(a,F)}static ClampToRef(q,I,l,w){return w.x=(0,F.Clamp)(q.x,I.x,l.x),w.y=(0,F.Clamp)(q.y,I.y,l.y),w}static Clamp(q,I,l){const w=(0,F.Clamp)(q.x,I.x,l.x),t=(0,F.Clamp)(q.y,I.y,l.y);return new d(w,t)}static Hermite(q,I,l,w,t){const O=t*t,c=t*O,a=2*c-3*O+1,F=-2*c+3*O,s=c-2*O+t,Z=c-O,r=q.x*a+l.x*F+I.x*s+w.x*Z,x=q.y*a+l.y*F+I.y*s+w.y*Z;return new d(r,x)}static Hermite1stDerivative(q,I,l,w,t){return this.Hermite1stDerivativeToRef(q,I,l,w,t,new d)}static Hermite1stDerivativeToRef(q,I,l,w,t,O){const c=t*t;return O.x=6*(c-t)*q.x+(3*c-4*t+1)*I.x+6*(-c+t)*l.x+(3*c-2*t)*w.x,O.y=6*(c-t)*q.y+(3*c-4*t+1)*I.y+6*(-c+t)*l.y+(3*c-2*t)*w.y,O}static Lerp(q,I,l){return d.LerpToRef(q,I,l,new d)}static LerpToRef(q,I,l,w){return w.x=q.x+(I.x-q.x)*l,w.y=q.y+(I.y-q.y)*l,w}static Dot(q,I){return q.x*I.x+q.y*I.y}static Normalize(q){return d.NormalizeToRef(q,new d)}static NormalizeToRef(q,I){return q.normalizeToRef(I),I}static Minimize(q,I){const l=q.x<I.x?q.x:I.x,w=q.y<I.y?q.y:I.y;return new d(l,w)}static Maximize(q,I){const l=q.x>I.x?q.x:I.x,w=q.y>I.y?q.y:I.y;return new d(l,w)}static Transform(q,I){return d.TransformToRef(q,I,new d)}static TransformToRef(q,I,l){const w=I.m,t=q.x*w[0]+q.y*w[4]+w[12],O=q.x*w[1]+q.y*w[5]+w[13];return l.x=t,l.y=O,l}static PointInTriangle(q,I,l,w){const t=.5*(-l.y*w.x+I.y*(-l.x+w.x)+I.x*(l.y-w.y)+l.x*w.y),O=t<0?-1:1,c=(I.y*w.x-I.x*w.y+(w.y-I.y)*q.x+(I.x-w.x)*q.y)*O,a=(I.x*l.y-I.y*l.x+(I.y-l.y)*q.x+(l.x-I.x)*q.y)*O;return c>0&&a>0&&c+a<2*t*O}static Distance(q,I){return Math.sqrt(d.DistanceSquared(q,I))}static DistanceSquared(q,I){const l=q.x-I.x,w=q.y-I.y;return l*l+w*w}static Center(q,I){return d.CenterToRef(q,I,new d)}static CenterToRef(q,I,l){return l.gc((q.x+I.x)/2,(q.y+I.y)/2)}static DistanceOfPointFromSegment(q,I,l){const w=d.DistanceSquared(I,l);if(0===w)return d.Distance(q,I);const t=l.TI(I),O=Math.max(0,Math.min(1,d.Dot(q.TI(I),t)/w)),c=I.add(t.multiplyByFloats(O,O));return d.Distance(q,c)}}d._V8PerformanceHack=new d(.5,.5),d._ZeroReadOnly=d.Zero(),Object.defineProperties(d.prototype,{dimension:{value:[2]},rank:{value:1}});class T{get x(){return this._x}set x(q){this._x=q,this._isDirty=!0}get y(){return this._y}set y(q){this._y=q,this._isDirty=!0}get z(){return this._z}set z(q){this._z=q,this._isDirty=!0}constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=q,this._y=I,this._z=l}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"dI"}getHashCode(){let q=o(this._x);return q=397*q^o(this._y),q=397*q^o(this._z),q}Uc(){return[this._x,this._y,this._z]}toArray(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q[I]=this._x,q[I+1]=this._y,q[I+2]=this._z,this}dl(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return T.FromArrayToRef(q,I,this),this}toQuaternion(){return U.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(q){return this._x+=q._x,this._y+=q._y,this._z+=q._z,this._isDirty=!0,this}addInPlaceFromFloats(q,I,l){return this._x+=q,this._y+=I,this._z+=l,this._isDirty=!0,this}add(q){return new T(this._x+q._x,this._y+q._y,this._z+q._z)}addToRef(q,I){return I._x=this._x+q._x,I._y=this._y+q._y,I._z=this._z+q._z,I._isDirty=!0,I}Sr(q){return this._x-=q._x,this._y-=q._y,this._z-=q._z,this._isDirty=!0,this}TI(q){return new T(this._x-q._x,this._y-q._y,this._z-q._z)}subtractToRef(q,I){return this.subtractFromFloatsToRef(q._x,q._y,q._z,I)}subtractFromFloats(q,I,l){return new T(this._x-q,this._y-I,this._z-l)}subtractFromFloatsToRef(q,I,l,w){return w._x=this._x-q,w._y=this._y-I,w._z=this._z-l,w._isDirty=!0,w}negate(){return new T(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(q){return q._x=-1*this._x,q._y=-1*this._y,q._z=-1*this._z,q._isDirty=!0,q}scaleInPlace(q){return this._x*=q,this._y*=q,this._z*=q,this._isDirty=!0,this}scale(q){return new T(this._x*q,this._y*q,this._z*q)}scaleToRef(q,I){return I._x=this._x*q,I._y=this._y*q,I._z=this._z*q,I._isDirty=!0,I}getNormalToRef(q){const I=this.length();let l=Math.acos(this._y/I);const w=Math.atan2(this._z,this._x);l>Math.PI/2?l-=Math.PI/2:l+=Math.PI/2;const t=I*Math.sin(l)*Math.cos(w),O=I*Math.cos(l),c=I*Math.sin(l)*Math.sin(w);return q.set(t,O,c),q}applyRotationQuaternionToRef(q,I){const l=this._x,w=this._y,t=this._z,O=q._x,c=q._y,a=q._z,F=q._w,s=2*(c*t-a*w),Z=2*(a*l-O*t),r=2*(O*w-c*l);return I._x=l+F*s+c*r-a*Z,I._y=w+F*Z+a*s-O*r,I._z=t+F*r+O*Z-c*s,I._isDirty=!0,I}applyRotationQuaternionInPlace(q){return this.applyRotationQuaternionToRef(q,this)}applyRotationQuaternion(q){return this.applyRotationQuaternionToRef(q,new T)}scaleAndAddToRef(q,I){return I._x+=this._x*q,I._y+=this._y*q,I._z+=this._z*q,I._isDirty=!0,I}projectOnPlane(q,I){return this.projectOnPlaneToRef(q,I,new T)}projectOnPlaneToRef(q,I,l){const w=q.normal,t=q.d,O=v.dI[0];this.subtractToRef(I,O),O.normalize();const c=T.Dot(O,w);if(Math.abs(c)<1e-10)l.Kc(1/0);else{const q=-(T.Dot(I,w)+t)/c,a=O.scaleInPlace(q);I.addToRef(a,l)}return l}equals(q){return q&&this._x===q._x&&this._y===q._y&&this._z===q._z}equalsWithEpsilon(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:w.d;return q&&(0,F.WithinEpsilon)(this._x,q._x,I)&&(0,F.WithinEpsilon)(this._y,q._y,I)&&(0,F.WithinEpsilon)(this._z,q._z,I)}equalsToFloats(q,I,l){return this._x===q&&this._y===I&&this._z===l}multiplyInPlace(q){return this._x*=q._x,this._y*=q._y,this._z*=q._z,this._isDirty=!0,this}multiply(q){return this.multiplyByFloats(q._x,q._y,q._z)}multiplyToRef(q,I){return I._x=this._x*q._x,I._y=this._y*q._y,I._z=this._z*q._z,I._isDirty=!0,I}multiplyByFloats(q,I,l){return new T(this._x*q,this._y*I,this._z*l)}divide(q){return new T(this._x/q._x,this._y/q._y,this._z/q._z)}divideToRef(q,I){return I._x=this._x/q._x,I._y=this._y/q._y,I._z=this._z/q._z,I._isDirty=!0,I}divideInPlace(q){return this._x=this._x/q._x,this._y=this._y/q._y,this._z=this._z/q._z,this._isDirty=!0,this}minimizeInPlace(q){return this.minimizeInPlaceFromFloats(q._x,q._y,q._z)}maximizeInPlace(q){return this.maximizeInPlaceFromFloats(q._x,q._y,q._z)}minimizeInPlaceFromFloats(q,I,l){return q<this._x&&(this.x=q),I<this._y&&(this.y=I),l<this._z&&(this.z=l),this}maximizeInPlaceFromFloats(q,I,l){return q>this._x&&(this.x=q),I>this._y&&(this.y=I),l>this._z&&(this.z=l),this}isNonUniformWithinEpsilon(q){const I=Math.abs(this._x),l=Math.abs(this._y);if(!(0,F.WithinEpsilon)(I,l,q))return!0;const w=Math.abs(this._z);return!(0,F.WithinEpsilon)(I,w,q)||!(0,F.WithinEpsilon)(l,w,q)}get isNonUniform(){const q=Math.abs(this._x);if(q!==Math.abs(this._y))return!0;return q!==Math.abs(this._z)}floorToRef(q){return q._x=Math.floor(this._x),q._y=Math.floor(this._y),q._z=Math.floor(this._z),q._isDirty=!0,q}floor(){return new T(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(q){return q._x=this._x-Math.floor(this._x),q._y=this._y-Math.floor(this._y),q._z=this._z-Math.floor(this._z),q._isDirty=!0,q}fract(){return new T(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(q){if("xyz"===(q=q.toLowerCase()))return this;const I=v.dI[0].t(this);return this.x=I[q[0]],this.y=I[q[1]],this.z=I[q[2]],this}rotateByQuaternionToRef(q,I){return q.toRotationMatrix(v.Matrix[0]),T.TransformCoordinatesToRef(this,v.Matrix[0],I),I}rotateByQuaternionAroundPointToRef(q,I,l){return this.subtractToRef(I,v.dI[0]),v.dI[0].rotateByQuaternionToRef(q,v.dI[0]),I.addToRef(v.dI[0],l),l}cross(q){return T.CrossToRef(this,q,new T)}normalizeFromLength(q){return 0===q||1===q?this:this.scaleInPlace(1/q)}normalizeToNew(){return this.normalizeToRef(new T)}normalizeToRef(q){const I=this.length();return 0===I||1===I?(q._x=this._x,q._y=this._y,q._z=this._z,q._isDirty=!0,q):this.scaleToRef(1/I,q)}clone(){return new T(this._x,this._y,this._z)}t(q){return this.gc(q._x,q._y,q._z)}gc(q,I,l){return this._x=q,this._y=I,this._z=l,this._isDirty=!0,this}set(q,I,l){return this.gc(q,I,l)}Kc(q){return this._x=this._y=this._z=q,this._isDirty=!0,this}static GetClipFactor(q,I,l,w){const t=T.Dot(q,l);return(t-w)/(t-T.Dot(I,l))}static GetAngleBetweenVectors(q,I,l){const w=q.normalizeToRef(v.dI[1]),t=I.normalizeToRef(v.dI[2]);let O=T.Dot(w,t);O=(0,F.Clamp)(O,-1,1);const c=Math.acos(O),a=v.dI[3];return T.CrossToRef(w,t,a),T.Dot(a,l)>0?isNaN(c)?0:c:isNaN(c)?-Math.PI:-Math.acos(O)}static GetAngleBetweenVectorsOnPlane(q,I,l){v.dI[0].t(q);const w=v.dI[0];v.dI[1].t(I);const t=v.dI[1];v.dI[2].t(l);const O=v.dI[2],c=v.dI[3],a=v.dI[4];w.normalize(),t.normalize(),O.normalize(),T.CrossToRef(O,w,c),T.CrossToRef(c,O,a);const s=Math.atan2(T.Dot(t,c),T.Dot(t,a));return(0,F.NormalizeRadians)(s)}static PitchYawRollToMoveBetweenPointsToRef(q,I,l){const w=k.dI[0];return I.subtractToRef(q,w),l._y=Math.atan2(w.x,w.z)||0,l._x=Math.atan2(Math.sqrt(w.x**2+w.z**2),w.y)||0,l._z=0,l._isDirty=!0,l}static PitchYawRollToMoveBetweenPoints(q,I){const l=T.Zero();return T.PitchYawRollToMoveBetweenPointsToRef(q,I,l)}static SlerpToRef(q,I,l,t){l=(0,F.Clamp)(l,0,1);const O=v.dI[0],c=v.dI[1];O.t(q);const a=O.length();O.normalizeFromLength(a),c.t(I);const s=c.length();c.normalizeFromLength(s);const Z=T.Dot(O,c);let r,x;if(Z<1-w.d){const q=Math.acos(Z),I=1/Math.sin(q);r=Math.sin((1-l)*q)*I,x=Math.sin(l*q)*I}else r=1-l,x=l;return O.scaleInPlace(r),c.scaleInPlace(x),t.t(O).addInPlace(c),t.scaleInPlace((0,F.Lerp)(a,s,l)),t}static SmoothToRef(q,I,l,w,t){return T.SlerpToRef(q,I,0===w?1:l/w,t),t}static vI(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new T(q[I],q[I+1],q[I+2])}static FromFloatArray(q,I){return T.vI(q,I)}static FromArrayToRef(q,I,l){return l._x=q[I],l._y=q[I+1],l._z=q[I+2],l._isDirty=!0,l}static FromFloatArrayToRef(q,I,l){return T.FromArrayToRef(q,I,l)}static FromFloatsToRef(q,I,l,w){return w.gc(q,I,l),w}static Zero(){return new T(0,0,0)}static One(){return new T(1,1,1)}static Up(){return new T(0,1,0)}static get UpReadOnly(){return T._UpReadOnly}static get DownReadOnly(){return T._DownReadOnly}static get RightReadOnly(){return T._RightReadOnly}static get LeftReadOnly(){return T._LeftReadOnly}static get LeftHandedForwardReadOnly(){return T._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return T._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return T._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return T._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return T._ZeroReadOnly}static get OneReadOnly(){return T._OneReadOnly}static Down(){return new T(0,-1,0)}static Forward(){return new T(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new T(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new T(1,0,0)}static Left(){return new T(-1,0,0)}static Random(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new T((0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I))}static RandomToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).gc((0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I))}static TransformCoordinates(q,I){const l=T.Zero();return T.TransformCoordinatesToRef(q,I,l),l}static TransformCoordinatesToRef(q,I,l){return T.TransformCoordinatesFromFloatsToRef(q._x,q._y,q._z,I,l),l}static TransformCoordinatesFromFloatsToRef(q,I,l,w,t){const O=w.m,c=q*O[0]+I*O[4]+l*O[8]+O[12],a=q*O[1]+I*O[5]+l*O[9]+O[13],F=q*O[2]+I*O[6]+l*O[10]+O[14],s=1/(q*O[3]+I*O[7]+l*O[11]+O[15]);return t._x=c*s,t._y=a*s,t._z=F*s,t._isDirty=!0,t}static TransformNormal(q,I){const l=T.Zero();return T.TransformNormalToRef(q,I,l),l}static TransformNormalToRef(q,I,l){return this.TransformNormalFromFloatsToRef(q._x,q._y,q._z,I,l),l}static TransformNormalFromFloatsToRef(q,I,l,w,t){const O=w.m;return t._x=q*O[0]+I*O[4]+l*O[8],t._y=q*O[1]+I*O[5]+l*O[9],t._z=q*O[2]+I*O[6]+l*O[10],t._isDirty=!0,t}static CatmullRom(q,I,l,w,t){const O=t*t,c=t*O,a=.5*(2*I._x+(-q._x+l._x)*t+(2*q._x-5*I._x+4*l._x-w._x)*O+(-q._x+3*I._x-3*l._x+w._x)*c),F=.5*(2*I._y+(-q._y+l._y)*t+(2*q._y-5*I._y+4*l._y-w._y)*O+(-q._y+3*I._y-3*l._y+w._y)*c),s=.5*(2*I._z+(-q._z+l._z)*t+(2*q._z-5*I._z+4*l._z-w._z)*O+(-q._z+3*I._z-3*l._z+w._z)*c);return new T(a,F,s)}static Clamp(q,I,l){const w=new T;return T.ClampToRef(q,I,l,w),w}static ClampToRef(q,I,l,w){let t=q._x;t=t>l._x?l._x:t,t=t<I._x?I._x:t;let O=q._y;O=O>l._y?l._y:O,O=O<I._y?I._y:O;let c=q._z;return c=c>l._z?l._z:c,c=c<I._z?I._z:c,w.gc(t,O,c),w}static CheckExtends(q,I,l){I.minimizeInPlace(q),l.maximizeInPlace(q)}static Hermite(q,I,l,w,t){const O=t*t,c=t*O,a=2*c-3*O+1,F=-2*c+3*O,s=c-2*O+t,Z=c-O,r=q._x*a+l._x*F+I._x*s+w._x*Z,x=q._y*a+l._y*F+I._y*s+w._y*Z,o=q._z*a+l._z*F+I._z*s+w._z*Z;return new T(r,x,o)}static Hermite1stDerivative(q,I,l,w,t){const O=new T;return this.Hermite1stDerivativeToRef(q,I,l,w,t,O),O}static Hermite1stDerivativeToRef(q,I,l,w,t,O){const c=t*t;return O._x=6*(c-t)*q._x+(3*c-4*t+1)*I._x+6*(-c+t)*l._x+(3*c-2*t)*w._x,O._y=6*(c-t)*q._y+(3*c-4*t+1)*I._y+6*(-c+t)*l._y+(3*c-2*t)*w._y,O._z=6*(c-t)*q._z+(3*c-4*t+1)*I._z+6*(-c+t)*l._z+(3*c-2*t)*w._z,O._isDirty=!0,O}static Lerp(q,I,l){const w=new T(0,0,0);return T.LerpToRef(q,I,l,w),w}static LerpToRef(q,I,l,w){return w._x=q._x+(I._x-q._x)*l,w._y=q._y+(I._y-q._y)*l,w._z=q._z+(I._z-q._z)*l,w._isDirty=!0,w}static Dot(q,I){return q._x*I._x+q._y*I._y+q._z*I._z}dot(q){return this._x*q._x+this._y*q._y+this._z*q._z}static Cross(q,I){const l=new T;return T.CrossToRef(q,I,l),l}static CrossToRef(q,I,l){const w=q._y*I._z-q._z*I._y,t=q._z*I._x-q._x*I._z,O=q._x*I._y-q._y*I._x;return l.gc(w,t,O),l}static Normalize(q){const I=T.Zero();return T.NormalizeToRef(q,I),I}static NormalizeToRef(q,I){return q.normalizeToRef(I),I}static Project(q,I,l,w){const t=new T;return T.ProjectToRef(q,I,l,w,t),t}static ProjectToRef(q,I,l,w,t){var O;const c=w.width,F=w.height,s=w.x,Z=w.y,r=v.Matrix[1],x=null===(O=a.e.LastCreatedEngine)||void 0===O?void 0:O.isNDCHalfZRange,o=x?1:.5,d=x?0:.5;B.FromValuesToRef(c/2,0,0,0,0,-F/2,0,0,0,0,o,0,s+c/2,F/2+Z,d,1,r);const V=v.Matrix[0];return I.multiplyToRef(l,V),V.multiplyToRef(r,V),T.TransformCoordinatesToRef(q,V,t),t}static Reflect(q,I){return this.ReflectToRef(q,I,new T)}static ReflectToRef(q,I,l){const w=k.dI[0];return w.t(I).scaleInPlace(2*T.Dot(q,I)),l.t(q).Sr(w)}static _UnprojectFromInvertedMatrixToRef(q,I,l){T.TransformCoordinatesToRef(q,I,l);const w=I.m,t=q._x*w[3]+q._y*w[7]+q._z*w[11]+w[15];return(0,F.WithinEpsilon)(t,1)&&l.scaleInPlace(1/t),l}static UnprojectFromTransform(q,I,l,w,t){return this.Unproject(q,I,l,w,t,B.IdentityReadOnly)}static Unproject(q,I,l,w,t,O){const c=new T;return T.UnprojectToRef(q,I,l,w,t,O,c),c}static UnprojectToRef(q,I,l,w,t,O,c){return T.UnprojectFloatsToRef(q._x,q._y,q._z,I,l,w,t,O,c),c}static UnprojectFloatsToRef(q,I,l,w,t,O,c,F,s){var Z;const r=v.Matrix[0];O.multiplyToRef(c,r),r.multiplyToRef(F,r),r.invert();const x=v.dI[0];return x.x=q/w*2-1,x.y=-(I/t*2-1),null!==(Z=a.e.LastCreatedEngine)&&void 0!==Z&&Z.isNDCHalfZRange?x.z=l:x.z=2*l-1,T._UnprojectFromInvertedMatrixToRef(x,r,s),s}static Minimize(q,I){const l=new T;return l.t(q),l.minimizeInPlace(I),l}static Maximize(q,I){const l=new T;return l.t(q),l.maximizeInPlace(I),l}static Distance(q,I){return Math.sqrt(T.DistanceSquared(q,I))}static DistanceSquared(q,I){const l=q._x-I._x,w=q._y-I._y,t=q._z-I._z;return l*l+w*w+t*t}static ProjectOnTriangleToRef(q,I,l,t,O){const c=v.dI[0],a=v.dI[1],s=v.dI[2],Z=v.dI[3],r=v.dI[4];l.subtractToRef(I,c),t.subtractToRef(I,a),t.subtractToRef(l,s);const x=c.length(),o=a.length(),d=s.length();if(x<w.d||o<w.d||d<w.d)return O.t(I),T.Distance(q,I);q.subtractToRef(I,r),T.CrossToRef(c,a,Z);const V=Z.length();if(V<w.d)return O.t(I),T.Distance(q,I);Z.normalizeFromLength(V);let U=r.length();if(U<w.d)return O.t(I),0;r.normalizeFromLength(U);const B=T.Dot(Z,r),k=v.dI[5],C=v.dI[6];k.t(Z).scaleInPlace(-U*B),C.t(q).addInPlace(k);const R=v.dI[4],W=v.dI[5],e=v.dI[7],i=v.dI[8];R.t(c).scaleInPlace(1/x),i.t(a).scaleInPlace(1/o),R.addInPlace(i).scaleInPlace(-1),W.t(c).scaleInPlace(-1/x),i.t(s).scaleInPlace(1/d),W.addInPlace(i).scaleInPlace(-1),e.t(s).scaleInPlace(-1/d),i.t(a).scaleInPlace(-1/o),e.addInPlace(i).scaleInPlace(-1);const S=v.dI[9];let g;S.t(C).Sr(I),T.CrossToRef(R,S,i),g=T.Dot(i,Z);const p=g;S.t(C).Sr(l),T.CrossToRef(W,S,i),g=T.Dot(i,Z);const X=g;S.t(C).Sr(t),T.CrossToRef(e,S,i),g=T.Dot(i,Z);const K=g,D=v.dI[10];let M,n;p>0&&X<0?(D.t(c),M=I,n=l):X>0&&K<0?(D.t(s),M=l,n=t):(D.t(a).scaleInPlace(-1),M=t,n=I);const f=v.dI[9],L=v.dI[4];M.subtractToRef(C,i),n.subtractToRef(C,f),T.CrossToRef(i,f,L);if(!(T.Dot(L,Z)<0))return O.t(C),Math.abs(U*B);const E=v.dI[5];T.CrossToRef(D,L,E),E.normalize();const j=v.dI[9];j.t(M).Sr(C);const h=j.length();if(h<w.d)return O.t(M),T.Distance(q,M);j.normalizeFromLength(h);const u=T.Dot(E,j),P=v.dI[7];P.t(C).addInPlace(E.scaleInPlace(h*u)),i.t(P).Sr(M),U=D.length(),D.normalizeFromLength(U);let mq=T.Dot(i,D)/Math.max(U,w.d);return mq=(0,F.Clamp)(mq,0,1),P.t(M).addInPlace(D.scaleInPlace(mq*U)),O.t(P),T.Distance(q,P)}static Center(q,I){return T.CenterToRef(q,I,T.Zero())}static CenterToRef(q,I,l){return l.gc((q._x+I._x)/2,(q._y+I._y)/2,(q._z+I._z)/2)}static RotationFromAxis(q,I,l){const w=new T;return T.RotationFromAxisToRef(q,I,l,w),w}static RotationFromAxisToRef(q,I,l,w){const t=v.Quaternion[0];return U.RotationQuaternionFromAxisToRef(q,I,l,t),t.toEulerAnglesToRef(w),w}}T._V8PerformanceHack=new T(.5,.5,.5),T._UpReadOnly=T.Up(),T._DownReadOnly=T.Down(),T._LeftHandedForwardReadOnly=T.Forward(!1),T._RightHandedForwardReadOnly=T.Forward(!0),T._LeftHandedBackwardReadOnly=T.Backward(!1),T._RightHandedBackwardReadOnly=T.Backward(!0),T._RightReadOnly=T.Right(),T._LeftReadOnly=T.Left(),T._ZeroReadOnly=T.Zero(),T._OneReadOnly=T.One(),Object.defineProperties(T.prototype,{dimension:{value:[3]},rank:{value:1}});class V{get x(){return this._x}set x(q){this._x=q,this._isDirty=!0}get y(){return this._y}set y(q){this._y=q,this._isDirty=!0}get z(){return this._z}set z(q){this._z=q,this._isDirty=!0}get w(){return this._w}set w(q){this._w=q,this._isDirty=!0}constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=q,this._y=I,this._z=l,this._w=w}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let q=o(this._x);return q=397*q^o(this._y),q=397*q^o(this._z),q=397*q^o(this._w),q}Uc(){return[this._x,this._y,this._z,this._w]}toArray(q,I){return void 0===I&&(I=0),q[I]=this._x,q[I+1]=this._y,q[I+2]=this._z,q[I+3]=this._w,this}dl(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V.FromArrayToRef(q,I,this),this}addInPlace(q){return this.x+=q._x,this.y+=q._y,this.z+=q._z,this.w+=q._w,this}addInPlaceFromFloats(q,I,l,w){return this.x+=q,this.y+=I,this.z+=l,this.w+=w,this}add(q){return new V(this._x+q.x,this._y+q.y,this._z+q.z,this._w+q.w)}addToRef(q,I){return I.x=this._x+q.x,I.y=this._y+q.y,I.z=this._z+q.z,I.w=this._w+q.w,I}Sr(q){return this.x-=q.x,this.y-=q.y,this.z-=q.z,this.w-=q.w,this}TI(q){return new V(this._x-q.x,this._y-q.y,this._z-q.z,this._w-q.w)}subtractToRef(q,I){return I.x=this._x-q.x,I.y=this._y-q.y,I.z=this._z-q.z,I.w=this._w-q.w,I}subtractFromFloats(q,I,l,w){return new V(this._x-q,this._y-I,this._z-l,this._w-w)}subtractFromFloatsToRef(q,I,l,w,t){return t.x=this._x-q,t.y=this._y-I,t.z=this._z-l,t.w=this._w-w,t}negate(){return new V(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(q){return q.x=-this._x,q.y=-this._y,q.z=-this._z,q.w=-this._w,q}scaleInPlace(q){return this.x*=q,this.y*=q,this.z*=q,this.w*=q,this}scale(q){return new V(this._x*q,this._y*q,this._z*q,this._w*q)}scaleToRef(q,I){return I.x=this._x*q,I.y=this._y*q,I.z=this._z*q,I.w=this._w*q,I}scaleAndAddToRef(q,I){return I.x+=this._x*q,I.y+=this._y*q,I.z+=this._z*q,I.w+=this._w*q,I}equals(q){return q&&this._x===q.x&&this._y===q.y&&this._z===q.z&&this._w===q.w}equalsWithEpsilon(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:w.d;return q&&(0,F.WithinEpsilon)(this._x,q.x,I)&&(0,F.WithinEpsilon)(this._y,q.y,I)&&(0,F.WithinEpsilon)(this._z,q.z,I)&&(0,F.WithinEpsilon)(this._w,q.w,I)}equalsToFloats(q,I,l,w){return this._x===q&&this._y===I&&this._z===l&&this._w===w}multiplyInPlace(q){return this.x*=q.x,this.y*=q.y,this.z*=q.z,this.w*=q.w,this}multiply(q){return new V(this._x*q.x,this._y*q.y,this._z*q.z,this._w*q.w)}multiplyToRef(q,I){return I.x=this._x*q.x,I.y=this._y*q.y,I.z=this._z*q.z,I.w=this._w*q.w,I}multiplyByFloats(q,I,l,w){return new V(this._x*q,this._y*I,this._z*l,this._w*w)}divide(q){return new V(this._x/q.x,this._y/q.y,this._z/q.z,this._w/q.w)}divideToRef(q,I){return I.x=this._x/q.x,I.y=this._y/q.y,I.z=this._z/q.z,I.w=this._w/q.w,I}divideInPlace(q){return this.divideToRef(q,this)}minimizeInPlace(q){return q.x<this._x&&(this.x=q.x),q.y<this._y&&(this.y=q.y),q.z<this._z&&(this.z=q.z),q.w<this._w&&(this.w=q.w),this}maximizeInPlace(q){return q.x>this._x&&(this.x=q.x),q.y>this._y&&(this.y=q.y),q.z>this._z&&(this.z=q.z),q.w>this._w&&(this.w=q.w),this}minimizeInPlaceFromFloats(q,I,l,w){return this.x=Math.min(q,this._x),this.y=Math.min(I,this._y),this.z=Math.min(l,this._z),this.w=Math.min(w,this._w),this}maximizeInPlaceFromFloats(q,I,l,w){return this.x=Math.max(q,this._x),this.y=Math.max(I,this._y),this.z=Math.max(l,this._z),this.w=Math.max(w,this._w),this}floorToRef(q){return q.x=Math.floor(this._x),q.y=Math.floor(this._y),q.z=Math.floor(this._z),q.w=Math.floor(this._w),q}floor(){return new V(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(q){return q.x=this._x-Math.floor(this._x),q.y=this._y-Math.floor(this._y),q.z=this._z-Math.floor(this._z),q.w=this._w-Math.floor(this._w),q}fract(){return new V(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(q){return 0===q||1===q?this:this.scaleInPlace(1/q)}normalizeToNew(){return this.normalizeToRef(new V)}normalizeToRef(q){const I=this.length();return 0===I||1===I?(q.x=this._x,q.y=this._y,q.z=this._z,q.w=this._w,q):this.scaleToRef(1/I,q)}toVector3(){return new T(this._x,this._y,this._z)}clone(){return new V(this._x,this._y,this._z,this._w)}t(q){return this.x=q.x,this.y=q.y,this.z=q.z,this.w=q.w,this}gc(q,I,l,w){return this.x=q,this.y=I,this.z=l,this.w=w,this}set(q,I,l,w){return this.gc(q,I,l,w)}Kc(q){return this.x=this.y=this.z=this.w=q,this}dot(q){return this._x*q.x+this._y*q.y+this._z*q.z+this._w*q.w}static vI(q,I){return I||(I=0),new V(q[I],q[I+1],q[I+2],q[I+3])}static FromArrayToRef(q,I,l){return l.x=q[I],l.y=q[I+1],l.z=q[I+2],l.w=q[I+3],l}static FromFloatArrayToRef(q,I,l){return V.FromArrayToRef(q,I,l),l}static FromFloatsToRef(q,I,l,w,t){return t.x=q,t.y=I,t.z=l,t.w=w,t}static Zero(){return new V(0,0,0,0)}static One(){return new V(1,1,1,1)}static Random(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new V((0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I))}static RandomToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,l=arguments.length>2?arguments[2]:void 0;return l.x=(0,F.RandomRange)(q,I),l.y=(0,F.RandomRange)(q,I),l.z=(0,F.RandomRange)(q,I),l.w=(0,F.RandomRange)(q,I),l}static Clamp(q,I,l){return V.ClampToRef(q,I,l,new V)}static ClampToRef(q,I,l,w){return w.x=(0,F.Clamp)(q.x,I.x,l.x),w.y=(0,F.Clamp)(q.y,I.y,l.y),w.z=(0,F.Clamp)(q.z,I.z,l.z),w.w=(0,F.Clamp)(q.w,I.w,l.w),w}static CheckExtends(q,I,l){I.minimizeInPlace(q),l.maximizeInPlace(q)}static get ZeroReadOnly(){return V._ZeroReadOnly}static Normalize(q){return V.NormalizeToRef(q,new V)}static NormalizeToRef(q,I){return q.normalizeToRef(I),I}static Minimize(q,I){const l=new V;return l.t(q),l.minimizeInPlace(I),l}static Maximize(q,I){const l=new V;return l.t(q),l.maximizeInPlace(I),l}static Distance(q,I){return Math.sqrt(V.DistanceSquared(q,I))}static DistanceSquared(q,I){const l=q.x-I.x,w=q.y-I.y,t=q.z-I.z,O=q.w-I.w;return l*l+w*w+t*t+O*O}static Center(q,I){return V.CenterToRef(q,I,new V)}static CenterToRef(q,I,l){return l.x=(q.x+I.x)/2,l.y=(q.y+I.y)/2,l.z=(q.z+I.z)/2,l.w=(q.w+I.w)/2,l}static TransformCoordinates(q,I){return V.TransformCoordinatesToRef(q,I,new V)}static TransformCoordinatesToRef(q,I,l){return V.TransformCoordinatesFromFloatsToRef(q._x,q._y,q._z,I,l),l}static TransformCoordinatesFromFloatsToRef(q,I,l,w,t){const O=w.m,c=q*O[0]+I*O[4]+l*O[8]+O[12],a=q*O[1]+I*O[5]+l*O[9]+O[13],F=q*O[2]+I*O[6]+l*O[10]+O[14],s=q*O[3]+I*O[7]+l*O[11]+O[15];return t.x=c,t.y=a,t.z=F,t.w=s,t}static TransformNormal(q,I){return V.TransformNormalToRef(q,I,new V)}static TransformNormalToRef(q,I,l){const w=I.m,t=q.x*w[0]+q.y*w[4]+q.z*w[8],O=q.x*w[1]+q.y*w[5]+q.z*w[9],c=q.x*w[2]+q.y*w[6]+q.z*w[10];return l.x=t,l.y=O,l.z=c,l.w=q.w,l}static TransformNormalFromFloatsToRef(q,I,l,w,t,O){const c=t.m;return O.x=q*c[0]+I*c[4]+l*c[8],O.y=q*c[1]+I*c[5]+l*c[9],O.z=q*c[2]+I*c[6]+l*c[10],O.w=w,O}static FromVector3(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new V(q._x,q._y,q._z,I)}static Dot(q,I){return q.x*I.x+q.y*I.y+q.z*I.z+q.w*I.w}}V._V8PerformanceHack=new V(.5,.5,.5,.5),V._ZeroReadOnly=V.Zero(),Object.defineProperties(V.prototype,{dimension:{value:[4]},rank:{value:1}});class U{get x(){return this._x}set x(q){this._x=q,this._isDirty=!0}get y(){return this._y}set y(q){this._y=q,this._isDirty=!0}get z(){return this._z}set z(q){this._z=q,this._isDirty=!0}get w(){return this._w}set w(q){this._w=q,this._isDirty=!0}constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=q,this._y=I,this._z=l,this._w=w}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let q=o(this._x);return q=397*q^o(this._y),q=397*q^o(this._z),q=397*q^o(this._w),q}Uc(){return[this._x,this._y,this._z,this._w]}toArray(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q[I]=this._x,q[I+1]=this._y,q[I+2]=this._z,q[I+3]=this._w,this}dl(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U.FromArrayToRef(q,I,this)}equals(q){return q&&this._x===q._x&&this._y===q._y&&this._z===q._z&&this._w===q._w}equalsWithEpsilon(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:w.d;return q&&(0,F.WithinEpsilon)(this._x,q._x,I)&&(0,F.WithinEpsilon)(this._y,q._y,I)&&(0,F.WithinEpsilon)(this._z,q._z,I)&&(0,F.WithinEpsilon)(this._w,q._w,I)}isApprox(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:w.d;return q&&((0,F.WithinEpsilon)(this._x,q._x,I)&&(0,F.WithinEpsilon)(this._y,q._y,I)&&(0,F.WithinEpsilon)(this._z,q._z,I)&&(0,F.WithinEpsilon)(this._w,q._w,I)||(0,F.WithinEpsilon)(this._x,-q._x,I)&&(0,F.WithinEpsilon)(this._y,-q._y,I)&&(0,F.WithinEpsilon)(this._z,-q._z,I)&&(0,F.WithinEpsilon)(this._w,-q._w,I))}clone(){return new U(this._x,this._y,this._z,this._w)}t(q){return this._x=q._x,this._y=q._y,this._z=q._z,this._w=q._w,this._isDirty=!0,this}gc(q,I,l,w){return this._x=q,this._y=I,this._z=l,this._w=w,this._isDirty=!0,this}set(q,I,l,w){return this.gc(q,I,l,w)}Kc(q){return this.gc(q,q,q,q)}add(q){return new U(this._x+q._x,this._y+q._y,this._z+q._z,this._w+q._w)}addInPlace(q){return this._x+=q._x,this._y+=q._y,this._z+=q._z,this._w+=q._w,this._isDirty=!0,this}addToRef(q,I){return I._x=this._x+q._x,I._y=this._y+q._y,I._z=this._z+q._z,I._w=this._w+q._w,I._isDirty=!0,I}addInPlaceFromFloats(q,I,l,w){return this._x+=q,this._y+=I,this._z+=l,this._w+=w,this._isDirty=!0,this}subtractToRef(q,I){return I._x=this._x-q._x,I._y=this._y-q._y,I._z=this._z-q._z,I._w=this._w-q._w,I._isDirty=!0,I}subtractFromFloats(q,I,l,w){return this.subtractFromFloatsToRef(q,I,l,w,new U)}subtractFromFloatsToRef(q,I,l,w,t){return t._x=this._x-q,t._y=this._y-I,t._z=this._z-l,t._w=this._w-w,t._isDirty=!0,t}TI(q){return new U(this._x-q._x,this._y-q._y,this._z-q._z,this._w-q._w)}Sr(q){return this._x-=q._x,this._y-=q._y,this._z-=q._z,this._w-=q._w,this._isDirty=!0,this}scale(q){return new U(this._x*q,this._y*q,this._z*q,this._w*q)}scaleToRef(q,I){return I._x=this._x*q,I._y=this._y*q,I._z=this._z*q,I._w=this._w*q,I._isDirty=!0,I}scaleInPlace(q){return this._x*=q,this._y*=q,this._z*=q,this._w*=q,this._isDirty=!0,this}scaleAndAddToRef(q,I){return I._x+=this._x*q,I._y+=this._y*q,I._z+=this._z*q,I._w+=this._w*q,I._isDirty=!0,I}multiply(q){const I=new U(0,0,0,1);return this.multiplyToRef(q,I),I}multiplyToRef(q,I){const l=this._x*q._w+this._y*q._z-this._z*q._y+this._w*q._x,w=-this._x*q._z+this._y*q._w+this._z*q._x+this._w*q._y,t=this._x*q._y-this._y*q._x+this._z*q._w+this._w*q._z,O=-this._x*q._x-this._y*q._y-this._z*q._z+this._w*q._w;return I.gc(l,w,t,O),I}multiplyInPlace(q){return this.multiplyToRef(q,this)}multiplyByFloats(q,I,l,w){return this._x*=q,this._y*=I,this._z*=l,this._w*=w,this._isDirty=!0,this}divide(q){throw new ReferenceError("Can not divide a quaternion")}divideToRef(q,I){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(q){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new U)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(q){return q._x=-this._x,q._y=-this._y,q._z=-this._z,q._w=-this._w,q._isDirty=!0,q}equalsToFloats(q,I,l,w){return this._x===q&&this._y===I&&this._z===l&&this._w===w}floorToRef(q){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(q){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(q){return q.gc(-this._x,-this._y,-this._z,this._w),q}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new U(-this._x,-this._y,-this._z,this._w)}invert(){const q=this.conjugate(),I=this.lengthSquared();return 0==I||1==I||q.scaleInPlace(1/I),q}invertInPlace(){this.conjugateInPlace();const q=this.lengthSquared();return 0==q||1==q||this.scaleInPlace(1/q),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(q){return 0===q||1===q?this:this.scaleInPlace(1/q)}normalizeToNew(){const q=new U(0,0,0,1);return this.normalizeToRef(q),q}normalizeToRef(q){const I=this.length();return 0===I||1===I?q.gc(this._x,this._y,this._z,this._w):this.scaleToRef(1/I,q)}toEulerAngles(){const q=T.Zero();return this.toEulerAnglesToRef(q),q}toEulerAnglesToRef(q){const I=this._z,l=this._x,w=this._y,t=this._w,O=w*I-l*t,c=.4999999;if(O<-c)q._y=2*Math.atan2(w,t),q._x=Math.PI/2,q._z=0,q._isDirty=!0;else if(O>c)q._y=2*Math.atan2(w,t),q._x=-Math.PI/2,q._z=0,q._isDirty=!0;else{const c=t*t,a=I*I,F=l*l,s=w*w;q._z=Math.atan2(2*(l*w+I*t),-a-F+s+c),q._x=Math.asin(-2*O),q._y=Math.atan2(2*(I*l+w*t),a-F-s+c),q._isDirty=!0}return q}toAlphaBetaGammaToRef(q){const I=this._z,l=this._x,w=this._y,t=this._w,O=Math.sqrt(l*l+w*w),c=Math.sqrt(I*I+t*t),a=2*Math.atan2(O,c),F=2*Math.atan2(I,t),s=2*Math.atan2(w,l),Z=(F+s)/2,r=(F-s)/2;return q.set(r,a,Z),q}toRotationMatrix(q){return B.FromQuaternionToRef(this,q),q}fromRotationMatrix(q){return U.FromRotationMatrixToRef(q,this),this}dot(q){return this._x*q._x+this._y*q._y+this._z*q._z+this._w*q._w}toAxisAngle(){const q=T.Zero();return{axis:q,angle:this.toAxisAngleToRef(q)}}toAxisAngleToRef(q){let I=0;const l=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),w=this._w;return l>0?(I=2*Math.atan2(l,w),q.set(this._x/l,this._y/l,this._z/l)):(I=0,q.set(1,0,0)),I}static FromRotationMatrix(q){const I=new U;return U.FromRotationMatrixToRef(q,I),I}static FromRotationMatrixToRef(q,I){const l=q.m,w=l[0],t=l[4],O=l[8],c=l[1],a=l[5],F=l[9],s=l[2],Z=l[6],r=l[10],x=w+a+r;let o;return x>0?(o=.5/Math.sqrt(x+1),I._w=.25/o,I._x=(Z-F)*o,I._y=(O-s)*o,I._z=(c-t)*o,I._isDirty=!0):w>a&&w>r?(o=2*Math.sqrt(1+w-a-r),I._w=(Z-F)/o,I._x=.25*o,I._y=(t+c)/o,I._z=(O+s)/o,I._isDirty=!0):a>r?(o=2*Math.sqrt(1+a-w-r),I._w=(O-s)/o,I._x=(t+c)/o,I._y=.25*o,I._z=(F+Z)/o,I._isDirty=!0):(o=2*Math.sqrt(1+r-w-a),I._w=(c-t)/o,I._x=(O+s)/o,I._y=(F+Z)/o,I._z=.25*o,I._isDirty=!0),I}static Dot(q,I){return q._x*I._x+q._y*I._y+q._z*I._z+q._w*I._w}static AreClose(q,I){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const w=U.Dot(q,I);return 1-w*w<=l}static SmoothToRef(q,I,l,w,t){let O=0===w?1:l/w;return O=(0,F.Clamp)(O,0,1),U.SlerpToRef(q,I,O,t),t}static Zero(){return new U(0,0,0,0)}static Inverse(q){return new U(-q._x,-q._y,-q._z,q._w)}static InverseToRef(q,I){return I.set(-q._x,-q._y,-q._z,q._w),I}static Identity(){return new U(0,0,0,1)}static IsIdentity(q){return q&&0===q._x&&0===q._y&&0===q._z&&1===q._w}static RotationAxis(q,I){return U.RotationAxisToRef(q,I,new U)}static RotationAxisToRef(q,I,l){l._w=Math.cos(I/2);const w=Math.sin(I/2)/q.length();return l._x=q._x*w,l._y=q._y*w,l._z=q._z*w,l._isDirty=!0,l}static vI(q,I){return I||(I=0),new U(q[I],q[I+1],q[I+2],q[I+3])}static FromArrayToRef(q,I,l){return l._x=q[I],l._y=q[I+1],l._z=q[I+2],l._w=q[I+3],l._isDirty=!0,l}static FromFloatsToRef(q,I,l,w,t){return t.gc(q,I,l,w),t}static FromEulerAngles(q,I,l){const w=new U;return U.RotationYawPitchRollToRef(I,q,l,w),w}static FromEulerAnglesToRef(q,I,l,w){return U.RotationYawPitchRollToRef(I,q,l,w),w}static FromEulerVector(q){const I=new U;return U.RotationYawPitchRollToRef(q._y,q._x,q._z,I),I}static FromEulerVectorToRef(q,I){return U.RotationYawPitchRollToRef(q._y,q._x,q._z,I),I}static FromUnitVectorsToRef(q,I,l){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:w.d;const O=T.Dot(q,I)+1;return O<t?Math.abs(q.x)>Math.abs(q.z)?l.set(-q.y,q.x,0,0):l.set(0,-q.z,q.y,0):(T.CrossToRef(q,I,k.dI[0]),l.set(k.dI[0].x,k.dI[0].y,k.dI[0].z,O)),l.normalize()}static RotationYawPitchRoll(q,I,l){const w=new U;return U.RotationYawPitchRollToRef(q,I,l,w),w}static RotationYawPitchRollToRef(q,I,l,w){const t=.5*l,O=.5*I,c=.5*q,a=Math.sin(t),F=Math.cos(t),s=Math.sin(O),Z=Math.cos(O),r=Math.sin(c),x=Math.cos(c);return w._x=x*s*F+r*Z*a,w._y=r*Z*F-x*s*a,w._z=x*Z*a-r*s*F,w._w=x*Z*F+r*s*a,w._isDirty=!0,w}static RotationAlphaBetaGamma(q,I,l){const w=new U;return U.RotationAlphaBetaGammaToRef(q,I,l,w),w}static RotationAlphaBetaGammaToRef(q,I,l,w){const t=.5*(l+q),O=.5*(l-q),c=.5*I;return w._x=Math.cos(O)*Math.sin(c),w._y=Math.sin(O)*Math.sin(c),w._z=Math.sin(t)*Math.cos(c),w._w=Math.cos(t)*Math.cos(c),w._isDirty=!0,w}static RotationQuaternionFromAxis(q,I,l){const w=new U(0,0,0,0);return U.RotationQuaternionFromAxisToRef(q,I,l,w),w}static RotationQuaternionFromAxisToRef(q,I,l,w){const t=v.Matrix[0];return q=q.normalizeToRef(v.dI[0]),I=I.normalizeToRef(v.dI[1]),l=l.normalizeToRef(v.dI[2]),B.FromXYZAxesToRef(q,I,l,t),U.FromRotationMatrixToRef(t,w),w}static FromLookDirectionLH(q,I){const l=new U;return U.FromLookDirectionLHToRef(q,I,l),l}static FromLookDirectionLHToRef(q,I,l){const w=v.Matrix[0];return B.LookDirectionLHToRef(q,I,w),U.FromRotationMatrixToRef(w,l),l}static FromLookDirectionRH(q,I){const l=new U;return U.FromLookDirectionRHToRef(q,I,l),l}static FromLookDirectionRHToRef(q,I,l){const w=v.Matrix[0];return B.LookDirectionRHToRef(q,I,w),U.FromRotationMatrixToRef(w,l)}static Slerp(q,I,l){const w=U.Identity();return U.SlerpToRef(q,I,l,w),w}static SlerpToRef(q,I,l,w){let t,O,c=q._x*I._x+q._y*I._y+q._z*I._z+q._w*I._w,a=!1;if(c<0&&(a=!0,c=-c),c>.999999)O=1-l,t=a?-l:l;else{const q=Math.acos(c),I=1/Math.sin(q);O=Math.sin((1-l)*q)*I,t=a?-Math.sin(l*q)*I:Math.sin(l*q)*I}return w._x=O*q._x+t*I._x,w._y=O*q._y+t*I._y,w._z=O*q._z+t*I._z,w._w=O*q._w+t*I._w,w._isDirty=!0,w}static Hermite(q,I,l,w,t){const O=t*t,c=t*O,a=2*c-3*O+1,F=-2*c+3*O,s=c-2*O+t,Z=c-O,r=q._x*a+l._x*F+I._x*s+w._x*Z,x=q._y*a+l._y*F+I._y*s+w._y*Z,o=q._z*a+l._z*F+I._z*s+w._z*Z,d=q._w*a+l._w*F+I._w*s+w._w*Z;return new U(r,x,o,d)}static Hermite1stDerivative(q,I,l,w,t){const O=new U;return this.Hermite1stDerivativeToRef(q,I,l,w,t,O),O}static Hermite1stDerivativeToRef(q,I,l,w,t,O){const c=t*t;return O._x=6*(c-t)*q._x+(3*c-4*t+1)*I._x+6*(-c+t)*l._x+(3*c-2*t)*w._x,O._y=6*(c-t)*q._y+(3*c-4*t+1)*I._y+6*(-c+t)*l._y+(3*c-2*t)*w._y,O._z=6*(c-t)*q._z+(3*c-4*t+1)*I._z+6*(-c+t)*l._z+(3*c-2*t)*w._z,O._w=6*(c-t)*q._w+(3*c-4*t+1)*I._w+6*(-c+t)*l._w+(3*c-2*t)*w._w,O._isDirty=!0,O}static Normalize(q){const I=U.Zero();return U.NormalizeToRef(q,I),I}static NormalizeToRef(q,I){return q.normalizeToRef(I),I}static Clamp(q,I,l){const w=new U;return U.ClampToRef(q,I,l,w),w}static ClampToRef(q,I,l,w){return w.gc((0,F.Clamp)(q.x,I.x,l.x),(0,F.Clamp)(q.y,I.y,l.y),(0,F.Clamp)(q.z,I.z,l.z),(0,F.Clamp)(q.w,I.w,l.w))}static Random(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new U((0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I))}static RandomToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).gc((0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I),(0,F.RandomRange)(q,I))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(q,I){return Math.sqrt(U.DistanceSquared(q,I))}static DistanceSquared(q,I){const l=q.x-I.x,w=q.y-I.y,t=q.z-I.z,O=q.w-I.w;return l*l+w*w+t*t+O*O}static Center(q,I){return U.CenterToRef(q,I,U.Zero())}static CenterToRef(q,I,l){return l.gc((q.x+I.x)/2,(q.y+I.y)/2,(q.z+I.z)/2,(q.w+I.w)/2)}}U._V8PerformanceHack=new U(.5,.5,.5,.5),Object.defineProperties(U.prototype,{dimension:{value:[4]},rank:{value:1}});class B{static get Use64Bits(){return c.b.MatrixUse64Bits}get m(){return this.ac}markAsUpdated(){this.updateFlag=s._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(q){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],w=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=q,this._isIdentity3x2=q||l,this._isIdentityDirty=!this._isIdentity&&I,this._isIdentity3x2Dirty=!this._isIdentity3x2&&w}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,c.b.MatrixTrackPrecisionChange&&c.b.MatrixTrackedMatrices.push(this),this.ac=new c.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const q=this.ac;this._isIdentity=1===q[0]&&0===q[1]&&0===q[2]&&0===q[3]&&0===q[4]&&1===q[5]&&0===q[6]&&0===q[7]&&0===q[8]&&0===q[9]&&1===q[10]&&0===q[11]&&0===q[12]&&0===q[13]&&0===q[14]&&1===q[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ac[0]||1!==this.ac[5]||1!==this.ac[15]||0!==this.ac[1]||0!==this.ac[2]||0!==this.ac[3]||0!==this.ac[4]||0!==this.ac[6]||0!==this.ac[7]||0!==this.ac[8]||0!==this.ac[9]||0!==this.ac[10]||0!==this.ac[11]||0!==this.ac[12]||0!==this.ac[13]||0!==this.ac[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const q=this.ac,I=q[0],l=q[1],w=q[2],t=q[3],O=q[4],c=q[5],a=q[6],F=q[7],s=q[8],Z=q[9],r=q[10],x=q[11],o=q[12],d=q[13],T=q[14],V=q[15],U=r*V-T*x,B=Z*V-d*x,v=Z*T-d*r,k=s*V-o*x,C=s*T-r*o,R=s*d-o*Z;return I*+(c*U-a*B+F*v)+l*-(O*U-a*k+F*C)+w*+(O*B-c*k+F*R)+t*-(O*v-c*C+a*R)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!q)return this.ac;const l=this.ac;for(let w=0;w<16;w++)q[I+w]=l[w];return this}Uc(){return this.ac}dl(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B.FromArrayToRef(q,I,this)}gc(){for(var q=arguments.length,I=new Array(q),l=0;l<q;l++)I[l]=arguments[l];return B.FromArrayToRef(I,0,this)}set(){const q=this.ac;for(let I=0;I<16;I++)q[I]=I<0||arguments.length<=I?void 0:arguments[I];return this.markAsUpdated(),this}Kc(q){const I=this.ac;for(let l=0;l<16;l++)I[l]=q;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return B.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(q){const I=new B;return this.addToRef(q,I),I}addToRef(q,I){const l=this.ac,w=I.ac,t=q.m;for(let O=0;O<16;O++)w[O]=l[O]+t[O];return I.markAsUpdated(),I}addToSelf(q){const I=this.ac,l=q.m;return I[0]+=l[0],I[1]+=l[1],I[2]+=l[2],I[3]+=l[3],I[4]+=l[4],I[5]+=l[5],I[6]+=l[6],I[7]+=l[7],I[8]+=l[8],I[9]+=l[9],I[10]+=l[10],I[11]+=l[11],I[12]+=l[12],I[13]+=l[13],I[14]+=l[14],I[15]+=l[15],this.markAsUpdated(),this}addInPlace(q){const I=this.ac,l=q.m;for(let w=0;w<16;w++)I[w]+=l[w];return this.markAsUpdated(),this}addInPlaceFromFloats(){const q=this.ac;for(let I=0;I<16;I++)q[I]+=I<0||arguments.length<=I?void 0:arguments[I];return this.markAsUpdated(),this}TI(q){const I=this.ac,l=q.m;for(let w=0;w<16;w++)I[w]-=l[w];return this.markAsUpdated(),this}subtractToRef(q,I){const l=this.ac,w=q.m,t=I.ac;for(let O=0;O<16;O++)t[O]=l[O]-w[O];return I.markAsUpdated(),I}Sr(q){const I=this.ac,l=q.m;for(let w=0;w<16;w++)I[w]-=l[w];return this.markAsUpdated(),this}subtractFromFloats(){for(var q=arguments.length,I=new Array(q),l=0;l<q;l++)I[l]=arguments[l];return this.subtractFromFloatsToRef(...I,new B)}subtractFromFloatsToRef(){for(var q=arguments.length,I=new Array(q),l=0;l<q;l++)I[l]=arguments[l];const w=I.pop(),t=this.ac,O=w.ac,c=I;for(let a=0;a<16;a++)O[a]=t[a]-c[a];return w.markAsUpdated(),w}invertToRef(q){return!0===this._isIdentity?(B.IdentityToRef(q),q):(x(this,q.Uc())?q.markAsUpdated():q.t(this),q)}addAtIndex(q,I){return this.ac[q]+=I,this.markAsUpdated(),this}multiplyAtIndex(q,I){return this.ac[q]*=I,this.markAsUpdated(),this}setTranslationFromFloats(q,I,l){return this.ac[12]=q,this.ac[13]=I,this.ac[14]=l,this.markAsUpdated(),this}addTranslationFromFloats(q,I,l){return this.ac[12]+=q,this.ac[13]+=I,this.ac[14]+=l,this.markAsUpdated(),this}setTranslation(q){return this.setTranslationFromFloats(q._x,q._y,q._z)}getTranslation(){return new T(this.ac[12],this.ac[13],this.ac[14])}getTranslationToRef(q){return q.x=this.ac[12],q.y=this.ac[13],q.z=this.ac[14],q}removeRotationAndScaling(){const q=this.m;return B.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,q[12],q[13],q[14],q[15],this),this._updateIdentityStatus(0===q[12]&&0===q[13]&&0===q[14]&&1===q[15]),this}t(q){q.copyToArray(this.ac);const I=q;return this.updateFlag=I.updateFlag,this._updateIdentityStatus(I._isIdentity,I._isIdentityDirty,I._isIdentity3x2,I._isIdentity3x2Dirty),this}copyToArray(q){return r(this,q,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(q){const I=new B;return this.multiplyToRef(q,I),I}multiplyInPlace(q){const I=this.ac,l=q.m;for(let w=0;w<16;w++)I[w]*=l[w];return this.markAsUpdated(),this}multiplyByFloats(){const q=this.ac;for(let I=0;I<16;I++)q[I]*=I<0||arguments.length<=I?void 0:arguments[I];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var q=arguments.length,I=new Array(q),l=0;l<q;l++)I[l]=arguments[l];const w=I.pop(),t=this.ac,O=w.ac,c=I;for(let a=0;a<16;a++)O[a]=t[a]*c[a];return w.markAsUpdated(),w}multiplyToRef(q,I){return this._isIdentity?(I.t(q),I):q._isIdentity?(I.t(this),I):(this.multiplyToArray(q,I.ac,0),I.markAsUpdated(),I)}multiplyToArray(q,I,l){return Z(this,q,I,l),this}divide(q){return this.divideToRef(q,new B)}divideToRef(q,I){const l=this.ac,w=q.m,t=I.ac;for(let O=0;O<16;O++)t[O]=l[O]/w[O];return I.markAsUpdated(),I}divideInPlace(q){const I=this.ac,l=q.m;for(let w=0;w<16;w++)I[w]/=l[w];return this.markAsUpdated(),this}minimizeInPlace(q){const I=this.ac,l=q.m;for(let w=0;w<16;w++)I[w]=Math.min(I[w],l[w]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const q=this.ac;for(let I=0;I<16;I++)q[I]=Math.min(q[I],I<0||arguments.length<=I?void 0:arguments[I]);return this.markAsUpdated(),this}maximizeInPlace(q){const I=this.ac,l=q.m;for(let w=0;w<16;w++)I[w]=Math.min(I[w],l[w]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const q=this.ac;for(let I=0;I<16;I++)q[I]=Math.min(q[I],I<0||arguments.length<=I?void 0:arguments[I]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new B)}negateInPlace(){const q=this.ac;for(let I=0;I<16;I++)q[I]=-q[I];return this.markAsUpdated(),this}negateToRef(q){const I=this.ac,l=q.ac;for(let w=0;w<16;w++)l[w]=-I[w];return q.markAsUpdated(),q}equals(q){const I=q;if(!I)return!1;if((this._isIdentity||I._isIdentity)&&!this._isIdentityDirty&&!I._isIdentityDirty)return this._isIdentity&&I._isIdentity;const l=this.m,w=I.m;return l[0]===w[0]&&l[1]===w[1]&&l[2]===w[2]&&l[3]===w[3]&&l[4]===w[4]&&l[5]===w[5]&&l[6]===w[6]&&l[7]===w[7]&&l[8]===w[8]&&l[9]===w[9]&&l[10]===w[10]&&l[11]===w[11]&&l[12]===w[12]&&l[13]===w[13]&&l[14]===w[14]&&l[15]===w[15]}equalsWithEpsilon(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const l=this.ac,w=q.m;for(let t=0;t<16;t++)if(!(0,F.WithinEpsilon)(l[t],w[t],I))return!1;return!0}equalsToFloats(){const q=this.ac;for(let I=0;I<16;I++)if(q[I]!=(I<0||arguments.length<=I?void 0:arguments[I]))return!1;return!0}floor(){return this.floorToRef(new B)}floorToRef(q){const I=this.ac,l=q.ac;for(let w=0;w<16;w++)l[w]=Math.floor(I[w]);return q.markAsUpdated(),q}fract(){return this.fractToRef(new B)}fractToRef(q){const I=this.ac,l=q.ac;for(let w=0;w<16;w++)l[w]=I[w]-Math.floor(I[w]);return q.markAsUpdated(),q}clone(){const q=new B;return q.t(this),q}getClassName(){return"Matrix"}getHashCode(){let q=o(this.ac[0]);for(let I=1;I<16;I++)q=397*q^o(this.ac[I]);return q}decomposeToTransformNode(q){return q.rotationQuaternion=q.rotationQuaternion||new U,this.decompose(q.Xc,q.rotationQuaternion,q.position)}decompose(q,I,l,w){let t=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return l&&l.Kc(0),q&&q.Kc(1),I&&I.gc(0,0,0,1),!0;const O=this.ac;if(l&&l.gc(O[12],O[13],O[14]),(q=q||v.dI[0]).x=Math.sqrt(O[0]*O[0]+O[1]*O[1]+O[2]*O[2]),q.y=Math.sqrt(O[4]*O[4]+O[5]*O[5]+O[6]*O[6]),q.z=Math.sqrt(O[8]*O[8]+O[9]*O[9]+O[10]*O[10]),w){const I=(t?w.absoluteScaling.x:w.Xc.x)<0?-1:1,l=(t?w.absoluteScaling.y:w.Xc.y)<0?-1:1,O=(t?w.absoluteScaling.z:w.Xc.z)<0?-1:1;q.x*=I,q.y*=l,q.z*=O}else this.determinant()<=0&&(q.y*=-1);if(0===q._x||0===q._y||0===q._z)return I&&I.gc(0,0,0,1),!1;if(I){const l=1/q._x,w=1/q._y,t=1/q._z;B.FromValuesToRef(O[0]*l,O[1]*l,O[2]*l,0,O[4]*w,O[5]*w,O[6]*w,0,O[8]*t,O[9]*t,O[10]*t,0,0,0,0,1,v.Matrix[0]),U.FromRotationMatrixToRef(v.Matrix[0],I)}return!0}getRow(q){if(q<0||q>3)return null;const I=4*q;return new V(this.ac[I+0],this.ac[I+1],this.ac[I+2],this.ac[I+3])}getRowToRef(q,I){if(q>=0&&q<=3){const l=4*q;I.x=this.ac[l+0],I.y=this.ac[l+1],I.z=this.ac[l+2],I.w=this.ac[l+3]}return I}setRow(q,I){return this.setRowFromFloats(q,I.x,I.y,I.z,I.w)}transpose(){const q=new B;return B.TransposeToRef(this,q),q}transposeToRef(q){return B.TransposeToRef(this,q),q}setRowFromFloats(q,I,l,w,t){if(q<0||q>3)return this;const O=4*q;return this.ac[O+0]=I,this.ac[O+1]=l,this.ac[O+2]=w,this.ac[O+3]=t,this.markAsUpdated(),this}scale(q){const I=new B;return this.scaleToRef(q,I),I}scaleToRef(q,I){for(let l=0;l<16;l++)I.ac[l]=this.ac[l]*q;return I.markAsUpdated(),I}scaleAndAddToRef(q,I){for(let l=0;l<16;l++)I.ac[l]+=this.ac[l]*q;return I.markAsUpdated(),I}scaleInPlace(q){const I=this.ac;for(let l=0;l<16;l++)I[l]*=q;return this.markAsUpdated(),this}toNormalMatrix(q){const I=v.Matrix[0];this.invertToRef(I),I.transposeToRef(q);const l=q.ac;return B.FromValuesToRef(l[0],l[1],l[2],0,l[4],l[5],l[6],0,l[8],l[9],l[10],0,0,0,0,1,q),q}getRotationMatrix(){const q=new B;return this.getRotationMatrixToRef(q),q}getRotationMatrixToRef(q){const I=v.dI[0];if(!this.decompose(I))return B.IdentityToRef(q),q;const l=this.ac,w=1/I._x,t=1/I._y,O=1/I._z;return B.FromValuesToRef(l[0]*w,l[1]*w,l[2]*w,0,l[4]*t,l[5]*t,l[6]*t,0,l[8]*O,l[9]*O,l[10]*O,0,0,0,0,1,q),q}toggleModelMatrixHandInPlace(){const q=this.ac;return q[2]*=-1,q[6]*=-1,q[8]*=-1,q[9]*=-1,q[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const q=this.ac;return q[8]*=-1,q[9]*=-1,q[10]*=-1,q[11]*=-1,this.markAsUpdated(),this}static vI(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const l=new B;return B.FromArrayToRef(q,I,l),l}static FromArrayToRef(q,I,l){for(let w=0;w<16;w++)l.ac[w]=q[w+I];return l.markAsUpdated(),l}static FromFloat32ArrayToRefScaled(q,I,l,w){return w.ac[0]=q[0+I]*l,w.ac[1]=q[1+I]*l,w.ac[2]=q[2+I]*l,w.ac[3]=q[3+I]*l,w.ac[4]=q[4+I]*l,w.ac[5]=q[5+I]*l,w.ac[6]=q[6+I]*l,w.ac[7]=q[7+I]*l,w.ac[8]=q[8+I]*l,w.ac[9]=q[9+I]*l,w.ac[10]=q[10+I]*l,w.ac[11]=q[11+I]*l,w.ac[12]=q[12+I]*l,w.ac[13]=q[13+I]*l,w.ac[14]=q[14+I]*l,w.ac[15]=q[15+I]*l,w.markAsUpdated(),w}static get IdentityReadOnly(){return B._IdentityReadOnly}static FromValuesToRef(q,I,l,w,t,O,c,a,F,s,Z,r,x,o,d,T,V){const U=V.ac;U[0]=q,U[1]=I,U[2]=l,U[3]=w,U[4]=t,U[5]=O,U[6]=c,U[7]=a,U[8]=F,U[9]=s,U[10]=Z,U[11]=r,U[12]=x,U[13]=o,U[14]=d,U[15]=T,V.markAsUpdated()}static FromValues(q,I,l,w,t,O,c,a,F,s,Z,r,x,o,d,T){const V=new B,U=V.ac;return U[0]=q,U[1]=I,U[2]=l,U[3]=w,U[4]=t,U[5]=O,U[6]=c,U[7]=a,U[8]=F,U[9]=s,U[10]=Z,U[11]=r,U[12]=x,U[13]=o,U[14]=d,U[15]=T,V.markAsUpdated(),V}static Compose(q,I,l){const w=new B;return B.ComposeToRef(q,I,l,w),w}static ComposeToRef(q,I,l,w){const t=w.ac,O=I._x,c=I._y,a=I._z,F=I._w,s=O+O,Z=c+c,r=a+a,x=O*s,o=O*Z,d=O*r,T=c*Z,V=c*r,U=a*r,B=F*s,v=F*Z,k=F*r,C=q._x,R=q._y,W=q._z;return t[0]=(1-(T+U))*C,t[1]=(o+k)*C,t[2]=(d-v)*C,t[3]=0,t[4]=(o-k)*R,t[5]=(1-(x+U))*R,t[6]=(V+B)*R,t[7]=0,t[8]=(d+v)*W,t[9]=(V-B)*W,t[10]=(1-(x+T))*W,t[11]=0,t[12]=l._x,t[13]=l._y,t[14]=l._z,t[15]=1,w.markAsUpdated(),w}static Identity(){const q=B.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return q._updateIdentityStatus(!0),q}static IdentityToRef(q){return B.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,q),q._updateIdentityStatus(!0),q}static Zero(){const q=B.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return q._updateIdentityStatus(!1),q}static RotationX(q){const I=new B;return B.RotationXToRef(q,I),I}static Invert(q){const I=new B;return q.invertToRef(I),I}static RotationXToRef(q,I){const l=Math.sin(q),w=Math.cos(q);return B.FromValuesToRef(1,0,0,0,0,w,l,0,0,-l,w,0,0,0,0,1,I),I._updateIdentityStatus(1===w&&0===l),I}static RotationY(q){const I=new B;return B.RotationYToRef(q,I),I}static RotationYToRef(q,I){const l=Math.sin(q),w=Math.cos(q);return B.FromValuesToRef(w,0,-l,0,0,1,0,0,l,0,w,0,0,0,0,1,I),I._updateIdentityStatus(1===w&&0===l),I}static RotationZ(q){const I=new B;return B.RotationZToRef(q,I),I}static RotationZToRef(q,I){const l=Math.sin(q),w=Math.cos(q);return B.FromValuesToRef(w,l,0,0,-l,w,0,0,0,0,1,0,0,0,0,1,I),I._updateIdentityStatus(1===w&&0===l),I}static RotationAxis(q,I){const l=new B;return B.RotationAxisToRef(q,I,l),l}static RotationAxisToRef(q,I,l){const w=Math.sin(-I),t=Math.cos(-I),O=1-t;q=q.normalizeToRef(v.dI[0]);const c=l.ac;return c[0]=q._x*q._x*O+t,c[1]=q._x*q._y*O-q._z*w,c[2]=q._x*q._z*O+q._y*w,c[3]=0,c[4]=q._y*q._x*O+q._z*w,c[5]=q._y*q._y*O+t,c[6]=q._y*q._z*O-q._x*w,c[7]=0,c[8]=q._z*q._x*O-q._y*w,c[9]=q._z*q._y*O+q._x*w,c[10]=q._z*q._z*O+t,c[11]=0,c[12]=0,c[13]=0,c[14]=0,c[15]=1,l.markAsUpdated(),l}static RotationAlignToRef(q,I,l){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const O=T.Dot(I,q),c=l.ac;if(O<-1+w.d)c[0]=-1,c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[5]=t?1:-1,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[10]=t?-1:1,c[11]=0;else{const l=T.Cross(I,q),w=1/(1+O);c[0]=l._x*l._x*w+O,c[1]=l._y*l._x*w-l._z,c[2]=l._z*l._x*w+l._y,c[3]=0,c[4]=l._x*l._y*w+l._z,c[5]=l._y*l._y*w+O,c[6]=l._z*l._y*w-l._x,c[7]=0,c[8]=l._x*l._z*w-l._y,c[9]=l._y*l._z*w+l._x,c[10]=l._z*l._z*w+O,c[11]=0}return c[12]=0,c[13]=0,c[14]=0,c[15]=1,l.markAsUpdated(),l}static RotationYawPitchRoll(q,I,l){const w=new B;return B.RotationYawPitchRollToRef(q,I,l,w),w}static RotationYawPitchRollToRef(q,I,l,w){return U.RotationYawPitchRollToRef(q,I,l,v.Quaternion[0]),v.Quaternion[0].toRotationMatrix(w),w}static Scaling(q,I,l){const w=new B;return B.ScalingToRef(q,I,l,w),w}static ScalingToRef(q,I,l,w){return B.FromValuesToRef(q,0,0,0,0,I,0,0,0,0,l,0,0,0,0,1,w),w._updateIdentityStatus(1===q&&1===I&&1===l),w}static Translation(q,I,l){const w=new B;return B.TranslationToRef(q,I,l,w),w}static TranslationToRef(q,I,l,w){return B.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,q,I,l,1,w),w._updateIdentityStatus(0===q&&0===I&&0===l),w}static Lerp(q,I,l){const w=new B;return B.LerpToRef(q,I,l,w),w}static LerpToRef(q,I,l,w){const t=w.ac,O=q.m,c=I.m;for(let a=0;a<16;a++)t[a]=O[a]*(1-l)+c[a]*l;return w.markAsUpdated(),w}static DecomposeLerp(q,I,l){const w=new B;return B.DecomposeLerpToRef(q,I,l,w),w}static DecomposeLerpToRef(q,I,l,w){const t=v.dI[0],O=v.Quaternion[0],c=v.dI[1];q.decompose(t,O,c);const a=v.dI[2],F=v.Quaternion[1],s=v.dI[3];I.decompose(a,F,s);const Z=v.dI[4];T.LerpToRef(t,a,l,Z);const r=v.Quaternion[2];U.SlerpToRef(O,F,l,r);const x=v.dI[5];return T.LerpToRef(c,s,l,x),B.ComposeToRef(Z,r,x,w),w}static LookAtLH(q,I,l){const w=new B;return B.LookAtLHToRef(q,I,l,w),w}static LookAtLHToRef(q,I,l,w){const t=v.dI[0],O=v.dI[1],c=v.dI[2];I.subtractToRef(q,c),c.normalize(),T.CrossToRef(l,c,t);const a=t.lengthSquared();0===a?t.x=1:t.normalizeFromLength(Math.sqrt(a)),T.CrossToRef(c,t,O),O.normalize();const F=-T.Dot(t,q),s=-T.Dot(O,q),Z=-T.Dot(c,q);return B.FromValuesToRef(t._x,O._x,c._x,0,t._y,O._y,c._y,0,t._z,O._z,c._z,0,F,s,Z,1,w),w}static LookAtRH(q,I,l){const w=new B;return B.LookAtRHToRef(q,I,l,w),w}static LookAtRHToRef(q,I,l,w){const t=v.dI[0],O=v.dI[1],c=v.dI[2];q.subtractToRef(I,c),c.normalize(),T.CrossToRef(l,c,t);const a=t.lengthSquared();0===a?t.x=1:t.normalizeFromLength(Math.sqrt(a)),T.CrossToRef(c,t,O),O.normalize();const F=-T.Dot(t,q),s=-T.Dot(O,q),Z=-T.Dot(c,q);return B.FromValuesToRef(t._x,O._x,c._x,0,t._y,O._y,c._y,0,t._z,O._z,c._z,0,F,s,Z,1,w),w}static LookDirectionLH(q,I){const l=new B;return B.LookDirectionLHToRef(q,I,l),l}static LookDirectionLHToRef(q,I,l){const w=v.dI[0];w.t(q),w.scaleInPlace(-1);const t=v.dI[1];return T.CrossToRef(I,w,t),B.FromValuesToRef(t._x,t._y,t._z,0,I._x,I._y,I._z,0,w._x,w._y,w._z,0,0,0,0,1,l),l}static LookDirectionRH(q,I){const l=new B;return B.LookDirectionRHToRef(q,I,l),l}static LookDirectionRHToRef(q,I,l){const w=v.dI[2];return T.CrossToRef(I,q,w),B.FromValuesToRef(w._x,w._y,w._z,0,I._x,I._y,I._z,0,q._x,q._y,q._z,0,0,0,0,1,l),l}static OrthoLH(q,I,l,w,t){const O=new B;return B.OrthoLHToRef(q,I,l,w,O,t),O}static OrthoLHToRef(q,I,l,w,t,O){const c=2/q,a=2/I,F=2/(w-l),s=-(w+l)/(w-l);return B.FromValuesToRef(c,0,0,0,0,a,0,0,0,0,F,0,0,0,s,1,t),O&&t.multiplyToRef(C,t),t._updateIdentityStatus(1===c&&1===a&&1===F&&0===s),t}static OrthoOffCenterLH(q,I,l,w,t,O,c){const a=new B;return B.OrthoOffCenterLHToRef(q,I,l,w,t,O,a,c),a}static OrthoOffCenterLHToRef(q,I,l,w,t,O,c,a){const F=2/(I-q),s=2/(w-l),Z=2/(O-t),r=-(O+t)/(O-t),x=(q+I)/(q-I),o=(w+l)/(l-w);return B.FromValuesToRef(F,0,0,0,0,s,0,0,0,0,Z,0,x,o,r,1,c),a&&c.multiplyToRef(C,c),c.markAsUpdated(),c}static ObliqueOffCenterLHToRef(q,I,l,w,t,O,c,a,F,s,Z){const r=-c*Math.cos(a),x=-c*Math.sin(a);return B.TranslationToRef(0,0,-F,v.Matrix[1]),B.FromValuesToRef(1,0,0,0,0,1,0,0,r,x,1,0,0,0,0,1,v.Matrix[0]),v.Matrix[1].multiplyToRef(v.Matrix[0],v.Matrix[0]),B.TranslationToRef(0,0,F,v.Matrix[1]),v.Matrix[0].multiplyToRef(v.Matrix[1],v.Matrix[0]),B.OrthoOffCenterLHToRef(q,I,l,w,t,O,s,Z),v.Matrix[0].multiplyToRef(s,s),s}static OrthoOffCenterRH(q,I,l,w,t,O,c){const a=new B;return B.OrthoOffCenterRHToRef(q,I,l,w,t,O,a,c),a}static OrthoOffCenterRHToRef(q,I,l,w,t,O,c,a){return B.OrthoOffCenterLHToRef(q,I,l,w,t,O,c,a),c.ac[10]*=-1,c}static ObliqueOffCenterRHToRef(q,I,l,w,t,O,c,a,F,s,Z){const r=c*Math.cos(a),x=c*Math.sin(a);return B.TranslationToRef(0,0,F,v.Matrix[1]),B.FromValuesToRef(1,0,0,0,0,1,0,0,r,x,1,0,0,0,0,1,v.Matrix[0]),v.Matrix[1].multiplyToRef(v.Matrix[0],v.Matrix[0]),B.TranslationToRef(0,0,-F,v.Matrix[1]),v.Matrix[0].multiplyToRef(v.Matrix[1],v.Matrix[0]),B.OrthoOffCenterRHToRef(q,I,l,w,t,O,s,Z),v.Matrix[0].multiplyToRef(s,s),s}static PerspectiveLH(q,I,l,w,t){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const c=new B,a=2*l/q,F=2*l/I,s=(w+l)/(w-l),Z=-2*w*l/(w-l),r=Math.tan(O);return B.FromValuesToRef(a,0,0,0,0,F,0,r,0,0,s,1,0,0,Z,0,c),t&&c.multiplyToRef(C,c),c._updateIdentityStatus(!1),c}static PerspectiveFovLH(q,I,l,w,t){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,c=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=new B;return B.PerspectiveFovLHToRef(q,I,l,w,a,!0,t,O,c),a}static PerspectiveFovLHToRef(q,I,l,w,t){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],c=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,F=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const s=l,Z=w,r=1/Math.tan(.5*q),x=O?r/I:r,o=O?r:r*I,d=F&&0===s?-1:0!==Z?(Z+s)/(Z-s):1,T=F&&0===s?2*Z:0!==Z?-2*Z*s/(Z-s):-2*s,V=Math.tan(a);return B.FromValuesToRef(x,0,0,0,0,o,0,V,0,0,d,1,0,0,T,0,t),c&&t.multiplyToRef(C,t),t._updateIdentityStatus(!1),t}static PerspectiveFovReverseLHToRef(q,I,l,w,t){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],c=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const F=1/Math.tan(.5*q),s=O?F/I:F,Z=O?F:F*I,r=Math.tan(a);return B.FromValuesToRef(s,0,0,0,0,Z,0,r,0,0,-l,1,0,0,1,0,t),c&&t.multiplyToRef(C,t),t._updateIdentityStatus(!1),t}static PerspectiveFovRH(q,I,l,w,t){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,c=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=new B;return B.PerspectiveFovRHToRef(q,I,l,w,a,!0,t,O,c),a}static PerspectiveFovRHToRef(q,I,l,w,t){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],c=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,F=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const s=l,Z=w,r=1/Math.tan(.5*q),x=O?r/I:r,o=O?r:r*I,d=F&&0===s?1:0!==Z?-(Z+s)/(Z-s):-1,T=F&&0===s?2*Z:0!==Z?-2*Z*s/(Z-s):-2*s,V=Math.tan(a);return B.FromValuesToRef(x,0,0,0,0,o,0,V,0,0,d,-1,0,0,T,0,t),c&&t.multiplyToRef(C,t),t._updateIdentityStatus(!1),t}static PerspectiveFovReverseRHToRef(q,I,l,w,t){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],c=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const F=1/Math.tan(.5*q),s=O?F/I:F,Z=O?F:F*I,r=Math.tan(a);return B.FromValuesToRef(s,0,0,0,0,Z,0,r,0,0,-l,-1,0,0,-1,0,t),c&&t.multiplyToRef(C,t),t._updateIdentityStatus(!1),t}static GetFinalMatrix(q,I,l,w,t,O){const c=q.width,a=q.height,F=q.x,s=q.y,Z=B.FromValues(c/2,0,0,0,0,-a/2,0,0,0,0,O-t,0,F+c/2,a/2+s,t,1),r=new B;return I.multiplyToRef(l,r),r.multiplyToRef(w,r),r.multiplyToRef(Z,r)}static GetAsMatrix2x2(q){const I=q.m,l=[I[0],I[1],I[4],I[5]];return c.b.MatrixUse64Bits?l:new Float32Array(l)}static GetAsMatrix3x3(q){const I=q.m,l=[I[0],I[1],I[2],I[4],I[5],I[6],I[8],I[9],I[10]];return c.b.MatrixUse64Bits?l:new Float32Array(l)}static Transpose(q){const I=new B;return B.TransposeToRef(q,I),I}static TransposeToRef(q,I){const l=q.m,w=l[0],t=l[4],O=l[8],c=l[12],a=l[1],F=l[5],s=l[9],Z=l[13],r=l[2],x=l[6],o=l[10],d=l[14],T=l[3],V=l[7],U=l[11],B=l[15],v=I.ac;return v[0]=w,v[1]=t,v[2]=O,v[3]=c,v[4]=a,v[5]=F,v[6]=s,v[7]=Z,v[8]=r,v[9]=x,v[10]=o,v[11]=d,v[12]=T,v[13]=V,v[14]=U,v[15]=B,I.markAsUpdated(),I._updateIdentityStatus(q._isIdentity,q._isIdentityDirty),I}static Reflection(q){const I=new B;return B.ReflectionToRef(q,I),I}static ReflectionToRef(q,I){q.normalize();const l=q.normal.x,w=q.normal.y,t=q.normal.z,O=-2*l,c=-2*w,a=-2*t;return B.FromValuesToRef(O*l+1,c*l,a*l,0,O*w,c*w+1,a*w,0,O*t,c*t,a*t+1,0,O*q.d,c*q.d,a*q.d,1,I),I}static FromXYZAxesToRef(q,I,l,w){return B.FromValuesToRef(q._x,q._y,q._z,0,I._x,I._y,I._z,0,l._x,l._y,l._z,0,0,0,0,1,w),w}static FromQuaternionToRef(q,I){const l=q._x*q._x,w=q._y*q._y,t=q._z*q._z,O=q._x*q._y,c=q._z*q._w,a=q._z*q._x,F=q._y*q._w,s=q._y*q._z,Z=q._x*q._w;return I.ac[0]=1-2*(w+t),I.ac[1]=2*(O+c),I.ac[2]=2*(a-F),I.ac[3]=0,I.ac[4]=2*(O-c),I.ac[5]=1-2*(t+l),I.ac[6]=2*(s+Z),I.ac[7]=0,I.ac[8]=2*(a+F),I.ac[9]=2*(s-Z),I.ac[10]=1-2*(w+l),I.ac[11]=0,I.ac[12]=0,I.ac[13]=0,I.ac[14]=0,I.ac[15]=1,I.markAsUpdated(),I}}B._IdentityReadOnly=B.Identity(),Object.defineProperties(B.prototype,{dimension:{value:[4,4]},rank:{value:2}});class v{}v.dI=(0,t.h)(11,T.Zero),v.Matrix=(0,t.h)(2,B.Identity),v.Quaternion=(0,t.h)(3,U.Zero);class k{}k.Vector2=(0,t.h)(3,d.Zero),k.dI=(0,t.h)(13,T.Zero),k.Vector4=(0,t.h)(3,V.Zero),k.Quaternion=(0,t.h)(3,U.Zero),k.Matrix=(0,t.h)(8,B.Identity),(0,O.e)("BABYLON.Vector2",d),(0,O.e)("BABYLON.Vector3",T),(0,O.e)("BABYLON.Vector4",V),(0,O.e)("BABYLON.Matrix",B);const C=B.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12757:(q,I,l)=>{function w(q,I){const l=[];for(let w=0;w<q;++w)l.push(I());return l}function t(q,I){return w(q,I)}l.d(I,{d:()=>w,h:()=>t,i:()=>c});const O=["push","splice","pop","shift","unshift"];function c(q,I){const l=O.map((l=>function(q,I,l){const w=q[I];if("function"!==typeof w)return null;const t=function(){const w=q.length,O=t.previous.apply(q,arguments);return l(I,w),O};return w.next=t,t.previous=w,q[I]=t,()=>{const l=t.previous;if(!l)return;const w=t.next;w?(l.next=w,w.previous=l):(l.next=void 0,q[I]=l),t.next=void 0,t.previous=void 0}}(q,l,I)));return()=>{for(const q of l)null===q||void 0===q||q()}}}}]);