"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[14],{11597:(U,X,b)=>{b.d(X,{d:()=>Q,f:()=>w,g:()=>F,k:()=>E});const F=1/2.2,E=2.2,w=(1+Math.sqrt(5))/2,Q=.001},11608:(U,X,b)=>{function F(U){return parseInt(U.toString().replace(/\W/g,""))}function E(U,X){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(U-X)<=b}function w(U,X,b){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return U<X-F||U>b+F}function Q(U,X){return U===X?U:Math.random()*(X-U)+U}function z(U,X,b){return U+(X-U)*b}function q(U,X,b){let F=x(X-U,360);return F>180&&(F-=360),U+F*n(b)}function p(U,X,b){let F=0;return F=U!=X?n((b-U)/(X-U)):0,F}function S(U,X,b,F,E){const w=E*E,Q=E*w;return U*(2*Q-3*w+1)+b*(-2*Q+3*w)+X*(Q-2*w+E)+F*(Q-w)}function R(U,X,b,F,E){const w=E*E;return 6*(w-E)*U+(3*w-4*E+1)*X+6*(-w+E)*b+(3*w-2*E)*F}function n(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(b,Math.max(X,U))}function a(U){return U-=2*Math.PI*Math.floor((U+Math.PI)/(2*Math.PI))}function J(U){const X=U.toString(16);return U<=15?("0"+X).toUpperCase():X.toUpperCase()}function m(U){if(Math.log2)return Math.floor(Math.log2(U));if(U<0)return NaN;if(0===U)return-1/0;let X=0;if(U<1){for(;U<1;)X++,U*=2;X=-X}else if(U>1)for(;U>1;)X++,U=Math.floor(U/2);return X}function x(U,X){return U-Math.floor(U/X)*X}function I(U,X,b){return(U-X)/(b-X)}function O(U,X,b){return U*(b-X)+X}function N(U,X){let b=x(X-U,360);return b>180&&(b-=360),b}function u(U,X){const b=x(U,2*X);return X-Math.abs(b-X)}function i(U,X,b){let F=n(b);return F=-2*F*F*F+3*F*F,X*F+U*(1-F)}function P(U,X,b){let F=0;return F=Math.abs(X-U)<=b?X:U+Math.sign(X-U)*b,F}function f(U,X,b){const F=N(U,X);let E=0;return E=-b<F&&F<b?X:P(U,X=U+F,b),E}function j(U,X,b){return(U-X)/(b-X)}function e(U,X,b){return(b-X)*U+X}function l(U,X){const b=U%X;return 0===b?X:l(X,b)}b.r(X),b.d(X,{Clamp:()=>n,DeltaAngle:()=>N,Denormalize:()=>O,ExtractAsInt:()=>F,Hermite:()=>S,Hermite1stDerivative:()=>R,HighestCommonFactor:()=>l,ILog2:()=>m,InverseLerp:()=>p,Lerp:()=>z,LerpAngle:()=>q,MoveTowards:()=>P,MoveTowardsAngle:()=>f,Normalize:()=>I,NormalizeRadians:()=>a,OutsideRange:()=>w,PercentToRange:()=>e,PingPong:()=>u,RandomRange:()=>Q,RangeToPercent:()=>j,Repeat:()=>x,SmoothStep:()=>i,ToHex:()=>J,WithinEpsilon:()=>E})},11593:(U,X,b)=>{b.r(X),b.d(X,{Matrix:()=>O,Quaternion:()=>I,TmpVectors:()=>u,Vector2:()=>J,JX:()=>m,Vector4:()=>x});var F=b(11597),E=b(11600),w=b(11551),Q=b(11519),z=b(11442),q=b(11608);class p{}function S(U,X,b){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const E=U.Jb(),w=X.Jb(),Q=E[0],z=E[1],q=E[2],p=E[3],S=E[4],R=E[5],n=E[6],a=E[7],J=E[8],m=E[9],x=E[10],I=E[11],O=E[12],N=E[13],u=E[14],i=E[15],P=w[0],f=w[1],j=w[2],e=w[3],l=w[4],d=w[5],k=w[6],v=w[7],A=w[8],s=w[9],h=w[10],B=w[11],o=w[12],y=w[13],t=w[14],W=w[15];b[F]=Q*P+z*l+q*A+p*o,b[F+1]=Q*f+z*d+q*s+p*y,b[F+2]=Q*j+z*k+q*h+p*t,b[F+3]=Q*e+z*v+q*B+p*W,b[F+4]=S*P+R*l+n*A+a*o,b[F+5]=S*f+R*d+n*s+a*y,b[F+6]=S*j+R*k+n*h+a*t,b[F+7]=S*e+R*v+n*B+a*W,b[F+8]=J*P+m*l+x*A+I*o,b[F+9]=J*f+m*d+x*s+I*y,b[F+10]=J*j+m*k+x*h+I*t,b[F+11]=J*e+m*v+x*B+I*W,b[F+12]=O*P+N*l+u*A+i*o,b[F+13]=O*f+N*d+u*s+i*y,b[F+14]=O*j+N*k+u*h+i*t,b[F+15]=O*e+N*v+u*B+i*W}function R(U,X){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const F=U.Jb();X[b]=F[0],X[b+1]=F[1],X[b+2]=F[2],X[b+3]=F[3],X[b+4]=F[4],X[b+5]=F[5],X[b+6]=F[6],X[b+7]=F[7],X[b+8]=F[8],X[b+9]=F[9],X[b+10]=F[10],X[b+11]=F[11],X[b+12]=F[12],X[b+13]=F[13],X[b+14]=F[14],X[b+15]=F[15]}function n(U,X){const b=U.Jb(),F=b[0],E=b[1],w=b[2],Q=b[3],z=b[4],q=b[5],p=b[6],S=b[7],R=b[8],n=b[9],a=b[10],J=b[11],m=b[12],x=b[13],I=b[14],O=b[15],N=a*O-I*J,u=n*O-x*J,i=n*I-x*a,P=R*O-m*J,f=R*I-a*m,j=R*x-m*n,e=+(q*N-p*u+S*i),l=-(z*N-p*P+S*f),d=+(z*u-q*P+S*j),k=-(z*i-q*f+p*j),v=F*e+E*l+w*d+Q*k;if(0===v)return!1;const A=1/v,s=p*O-I*S,h=q*O-x*S,B=q*I-x*p,o=z*O-m*S,y=z*I-m*p,t=z*x-m*q,W=p*J-a*S,Y=q*J-n*S,K=q*a-n*p,V=z*J-R*S,g=z*a-R*p,L=z*n-R*q,D=-(E*N-w*u+Q*i),G=+(F*N-w*P+Q*f),Z=-(F*u-E*P+Q*j),c=+(F*i-E*f+w*j),r=+(E*s-w*h+Q*B),M=-(F*s-w*o+Q*y),H=+(F*h-E*o+Q*t),T=-(F*B-E*y+w*t),C=-(E*W-w*Y+Q*K),UU=+(F*W-w*V+Q*g),XU=-(F*Y-E*V+Q*L),bU=+(F*K-E*g+w*L);return X[0]=e*A,X[1]=D*A,X[2]=r*A,X[3]=C*A,X[4]=l*A,X[5]=G*A,X[6]=M*A,X[7]=UU*A,X[8]=d*A,X[9]=Z*A,X[10]=H*A,X[11]=XU*A,X[12]=k*A,X[13]=c*A,X[14]=T*A,X[15]=bU*A,!0}p._UpdateFlagSeed=0;const a=U=>parseInt(U.toString().replace(/\W/g,""));class J{constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=U,this.y=X}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let U=a(this.x);return U=397*U^a(this.y),U}toArray(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U[X]=this.x,U[X+1]=this.y,this}qF(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(U,X,this),this}Jb(){return[this.x,this.y]}q(U){return this.x=U.x,this.y=U.y,this}Pb(U,X){return this.x=U,this.y=X,this}set(U,X){return this.Pb(U,X)}jb(U){return this.Pb(U,U)}add(U){return new J(this.x+U.x,this.y+U.y)}addToRef(U,X){return X.x=this.x+U.x,X.y=this.y+U.y,X}addInPlace(U){return this.x+=U.x,this.y+=U.y,this}addInPlaceFromFloats(U,X){return this.x+=U,this.y+=X,this}addVector3(U){return new J(this.x+U.x,this.y+U.y)}mX(U){return new J(this.x-U.x,this.y-U.y)}subtractToRef(U,X){return X.x=this.x-U.x,X.y=this.y-U.y,X}pR(U){return this.x-=U.x,this.y-=U.y,this}multiplyInPlace(U){return this.x*=U.x,this.y*=U.y,this}multiply(U){return new J(this.x*U.x,this.y*U.y)}multiplyToRef(U,X){return X.x=this.x*U.x,X.y=this.y*U.y,X}multiplyByFloats(U,X){return new J(this.x*U,this.y*X)}divide(U){return new J(this.x/U.x,this.y/U.y)}divideToRef(U,X){return X.x=this.x/U.x,X.y=this.y/U.y,X}divideInPlace(U){return this.x=this.x/U.x,this.y=this.y/U.y,this}minimizeInPlace(U){return this.minimizeInPlaceFromFloats(U.x,U.y)}maximizeInPlace(U){return this.maximizeInPlaceFromFloats(U.x,U.y)}minimizeInPlaceFromFloats(U,X){return this.x=Math.min(U,this.x),this.y=Math.min(X,this.y),this}maximizeInPlaceFromFloats(U,X){return this.x=Math.max(U,this.x),this.y=Math.max(X,this.y),this}subtractFromFloats(U,X){return new J(this.x-U,this.y-X)}subtractFromFloatsToRef(U,X,b){return b.x=this.x-U,b.y=this.y-X,b}negate(){return new J(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(U){return U.x=-this.x,U.y=-this.y,U}scaleInPlace(U){return this.x*=U,this.y*=U,this}scale(U){return new J(this.x*U,this.y*U)}scaleToRef(U,X){return X.x=this.x*U,X.y=this.y*U,X}scaleAndAddToRef(U,X){return X.x+=this.x*U,X.y+=this.y*U,X}equals(U){return U&&this.x===U.x&&this.y===U.y}equalsWithEpsilon(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.d;return U&&(0,q.WithinEpsilon)(this.x,U.x,X)&&(0,q.WithinEpsilon)(this.y,U.y,X)}equalsToFloats(U,X){return this.x===U&&this.y===X}floor(){return new J(Math.floor(this.x),Math.floor(this.y))}floorToRef(U){return U.x=Math.floor(this.x),U.y=Math.floor(this.y),U}fract(){return new J(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(U){return U.x=this.x-Math.floor(this.x),U.y=this.y-Math.floor(this.y),U}rotate(U){return this.rotateToRef(U,new J)}rotateToRef(U,X){const b=Math.cos(U),F=Math.sin(U);return X.x=b*this.x-F*this.y,X.y=F*this.x+b*this.y,X}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(U){return 0===U||1===U?this:this.scaleInPlace(1/U)}normalizeToNew(){const U=new J;return this.normalizeToRef(U),U}normalizeToRef(U){const X=this.length();return 0===X&&(U.x=this.x,U.y=this.y),this.scaleToRef(1/X,U)}clone(){return new J(this.x,this.y)}dot(U){return this.x*U.x+this.y*U.y}static Zero(){return new J(0,0)}static One(){return new J(1,1)}static Random(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new J((0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X))}static RandomToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Pb((0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X))}static get ZeroReadOnly(){return J._ZeroReadOnly}static uX(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new J(U[X],U[X+1])}static FromArrayToRef(U,X,b){return b.x=U[X],b.y=U[X+1],b}static FromFloatsToRef(U,X,b){return b.Pb(U,X),b}static CatmullRom(U,X,b,F,E){const w=E*E,Q=E*w,z=.5*(2*X.x+(-U.x+b.x)*E+(2*U.x-5*X.x+4*b.x-F.x)*w+(-U.x+3*X.x-3*b.x+F.x)*Q),q=.5*(2*X.y+(-U.y+b.y)*E+(2*U.y-5*X.y+4*b.y-F.y)*w+(-U.y+3*X.y-3*b.y+F.y)*Q);return new J(z,q)}static ClampToRef(U,X,b,F){return F.x=(0,q.Clamp)(U.x,X.x,b.x),F.y=(0,q.Clamp)(U.y,X.y,b.y),F}static Clamp(U,X,b){const F=(0,q.Clamp)(U.x,X.x,b.x),E=(0,q.Clamp)(U.y,X.y,b.y);return new J(F,E)}static Hermite(U,X,b,F,E){const w=E*E,Q=E*w,z=2*Q-3*w+1,q=-2*Q+3*w,p=Q-2*w+E,S=Q-w,R=U.x*z+b.x*q+X.x*p+F.x*S,n=U.y*z+b.y*q+X.y*p+F.y*S;return new J(R,n)}static Hermite1stDerivative(U,X,b,F,E){return this.Hermite1stDerivativeToRef(U,X,b,F,E,new J)}static Hermite1stDerivativeToRef(U,X,b,F,E,w){const Q=E*E;return w.x=6*(Q-E)*U.x+(3*Q-4*E+1)*X.x+6*(-Q+E)*b.x+(3*Q-2*E)*F.x,w.y=6*(Q-E)*U.y+(3*Q-4*E+1)*X.y+6*(-Q+E)*b.y+(3*Q-2*E)*F.y,w}static Lerp(U,X,b){return J.LerpToRef(U,X,b,new J)}static LerpToRef(U,X,b,F){return F.x=U.x+(X.x-U.x)*b,F.y=U.y+(X.y-U.y)*b,F}static Dot(U,X){return U.x*X.x+U.y*X.y}static Normalize(U){return J.NormalizeToRef(U,new J)}static NormalizeToRef(U,X){return U.normalizeToRef(X),X}static Minimize(U,X){const b=U.x<X.x?U.x:X.x,F=U.y<X.y?U.y:X.y;return new J(b,F)}static Maximize(U,X){const b=U.x>X.x?U.x:X.x,F=U.y>X.y?U.y:X.y;return new J(b,F)}static Transform(U,X){return J.TransformToRef(U,X,new J)}static TransformToRef(U,X,b){const F=X.m,E=U.x*F[0]+U.y*F[4]+F[12],w=U.x*F[1]+U.y*F[5]+F[13];return b.x=E,b.y=w,b}static PointInTriangle(U,X,b,F){const E=.5*(-b.y*F.x+X.y*(-b.x+F.x)+X.x*(b.y-F.y)+b.x*F.y),w=E<0?-1:1,Q=(X.y*F.x-X.x*F.y+(F.y-X.y)*U.x+(X.x-F.x)*U.y)*w,z=(X.x*b.y-X.y*b.x+(X.y-b.y)*U.x+(b.x-X.x)*U.y)*w;return Q>0&&z>0&&Q+z<2*E*w}static Distance(U,X){return Math.sqrt(J.DistanceSquared(U,X))}static DistanceSquared(U,X){const b=U.x-X.x,F=U.y-X.y;return b*b+F*F}static Center(U,X){return J.CenterToRef(U,X,new J)}static CenterToRef(U,X,b){return b.Pb((U.x+X.x)/2,(U.y+X.y)/2)}static DistanceOfPointFromSegment(U,X,b){const F=J.DistanceSquared(X,b);if(0===F)return J.Distance(U,X);const E=b.mX(X),w=Math.max(0,Math.min(1,J.Dot(U.mX(X),E)/F)),Q=X.add(E.multiplyByFloats(w,w));return J.Distance(U,Q)}}J._V8PerformanceHack=new J(.5,.5),J._ZeroReadOnly=J.Zero(),Object.defineProperties(J.prototype,{dimension:{value:[2]},rank:{value:1}});class m{get x(){return this._x}set x(U){this._x=U,this._isDirty=!0}get y(){return this._y}set y(U){this._y=U,this._isDirty=!0}get z(){return this._z}set z(U){this._z=U,this._isDirty=!0}constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=U,this._y=X,this._z=b}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"JX"}getHashCode(){let U=a(this._x);return U=397*U^a(this._y),U=397*U^a(this._z),U}Jb(){return[this._x,this._y,this._z]}toArray(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U[X]=this._x,U[X+1]=this._y,U[X+2]=this._z,this}qF(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return m.FromArrayToRef(U,X,this),this}toQuaternion(){return I.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(U){return this._x+=U._x,this._y+=U._y,this._z+=U._z,this._isDirty=!0,this}addInPlaceFromFloats(U,X,b){return this._x+=U,this._y+=X,this._z+=b,this._isDirty=!0,this}add(U){return new m(this._x+U._x,this._y+U._y,this._z+U._z)}addToRef(U,X){return X._x=this._x+U._x,X._y=this._y+U._y,X._z=this._z+U._z,X._isDirty=!0,X}pR(U){return this._x-=U._x,this._y-=U._y,this._z-=U._z,this._isDirty=!0,this}mX(U){return new m(this._x-U._x,this._y-U._y,this._z-U._z)}subtractToRef(U,X){return this.subtractFromFloatsToRef(U._x,U._y,U._z,X)}subtractFromFloats(U,X,b){return new m(this._x-U,this._y-X,this._z-b)}subtractFromFloatsToRef(U,X,b,F){return F._x=this._x-U,F._y=this._y-X,F._z=this._z-b,F._isDirty=!0,F}negate(){return new m(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(U){return U._x=-1*this._x,U._y=-1*this._y,U._z=-1*this._z,U._isDirty=!0,U}scaleInPlace(U){return this._x*=U,this._y*=U,this._z*=U,this._isDirty=!0,this}scale(U){return new m(this._x*U,this._y*U,this._z*U)}scaleToRef(U,X){return X._x=this._x*U,X._y=this._y*U,X._z=this._z*U,X._isDirty=!0,X}getNormalToRef(U){const X=this.length();let b=Math.acos(this._y/X);const F=Math.atan2(this._z,this._x);b>Math.PI/2?b-=Math.PI/2:b+=Math.PI/2;const E=X*Math.sin(b)*Math.cos(F),w=X*Math.cos(b),Q=X*Math.sin(b)*Math.sin(F);return U.set(E,w,Q),U}applyRotationQuaternionToRef(U,X){const b=this._x,F=this._y,E=this._z,w=U._x,Q=U._y,z=U._z,q=U._w,p=2*(Q*E-z*F),S=2*(z*b-w*E),R=2*(w*F-Q*b);return X._x=b+q*p+Q*R-z*S,X._y=F+q*S+z*p-w*R,X._z=E+q*R+w*S-Q*p,X._isDirty=!0,X}applyRotationQuaternionInPlace(U){return this.applyRotationQuaternionToRef(U,this)}applyRotationQuaternion(U){return this.applyRotationQuaternionToRef(U,new m)}scaleAndAddToRef(U,X){return X._x+=this._x*U,X._y+=this._y*U,X._z+=this._z*U,X._isDirty=!0,X}projectOnPlane(U,X){return this.projectOnPlaneToRef(U,X,new m)}projectOnPlaneToRef(U,X,b){const F=U.normal,E=U.d,w=N.JX[0];this.subtractToRef(X,w),w.normalize();const Q=m.Dot(w,F);if(Math.abs(Q)<1e-10)b.jb(1/0);else{const U=-(m.Dot(X,F)+E)/Q,z=w.scaleInPlace(U);X.addToRef(z,b)}return b}equals(U){return U&&this._x===U._x&&this._y===U._y&&this._z===U._z}equalsWithEpsilon(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.d;return U&&(0,q.WithinEpsilon)(this._x,U._x,X)&&(0,q.WithinEpsilon)(this._y,U._y,X)&&(0,q.WithinEpsilon)(this._z,U._z,X)}equalsToFloats(U,X,b){return this._x===U&&this._y===X&&this._z===b}multiplyInPlace(U){return this._x*=U._x,this._y*=U._y,this._z*=U._z,this._isDirty=!0,this}multiply(U){return this.multiplyByFloats(U._x,U._y,U._z)}multiplyToRef(U,X){return X._x=this._x*U._x,X._y=this._y*U._y,X._z=this._z*U._z,X._isDirty=!0,X}multiplyByFloats(U,X,b){return new m(this._x*U,this._y*X,this._z*b)}divide(U){return new m(this._x/U._x,this._y/U._y,this._z/U._z)}divideToRef(U,X){return X._x=this._x/U._x,X._y=this._y/U._y,X._z=this._z/U._z,X._isDirty=!0,X}divideInPlace(U){return this._x=this._x/U._x,this._y=this._y/U._y,this._z=this._z/U._z,this._isDirty=!0,this}minimizeInPlace(U){return this.minimizeInPlaceFromFloats(U._x,U._y,U._z)}maximizeInPlace(U){return this.maximizeInPlaceFromFloats(U._x,U._y,U._z)}minimizeInPlaceFromFloats(U,X,b){return U<this._x&&(this.x=U),X<this._y&&(this.y=X),b<this._z&&(this.z=b),this}maximizeInPlaceFromFloats(U,X,b){return U>this._x&&(this.x=U),X>this._y&&(this.y=X),b>this._z&&(this.z=b),this}isNonUniformWithinEpsilon(U){const X=Math.abs(this._x),b=Math.abs(this._y);if(!(0,q.WithinEpsilon)(X,b,U))return!0;const F=Math.abs(this._z);return!(0,q.WithinEpsilon)(X,F,U)||!(0,q.WithinEpsilon)(b,F,U)}get isNonUniform(){const U=Math.abs(this._x);if(U!==Math.abs(this._y))return!0;return U!==Math.abs(this._z)}floorToRef(U){return U._x=Math.floor(this._x),U._y=Math.floor(this._y),U._z=Math.floor(this._z),U._isDirty=!0,U}floor(){return new m(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(U){return U._x=this._x-Math.floor(this._x),U._y=this._y-Math.floor(this._y),U._z=this._z-Math.floor(this._z),U._isDirty=!0,U}fract(){return new m(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(U){if("xyz"===(U=U.toLowerCase()))return this;const X=N.JX[0].q(this);return this.x=X[U[0]],this.y=X[U[1]],this.z=X[U[2]],this}rotateByQuaternionToRef(U,X){return U.toRotationMatrix(N.Matrix[0]),m.TransformCoordinatesToRef(this,N.Matrix[0],X),X}rotateByQuaternionAroundPointToRef(U,X,b){return this.subtractToRef(X,N.JX[0]),N.JX[0].rotateByQuaternionToRef(U,N.JX[0]),X.addToRef(N.JX[0],b),b}cross(U){return m.CrossToRef(this,U,new m)}normalizeFromLength(U){return 0===U||1===U?this:this.scaleInPlace(1/U)}normalizeToNew(){return this.normalizeToRef(new m)}normalizeToRef(U){const X=this.length();return 0===X||1===X?(U._x=this._x,U._y=this._y,U._z=this._z,U._isDirty=!0,U):this.scaleToRef(1/X,U)}clone(){return new m(this._x,this._y,this._z)}q(U){return this.Pb(U._x,U._y,U._z)}Pb(U,X,b){return this._x=U,this._y=X,this._z=b,this._isDirty=!0,this}set(U,X,b){return this.Pb(U,X,b)}jb(U){return this._x=this._y=this._z=U,this._isDirty=!0,this}static GetClipFactor(U,X,b,F){const E=m.Dot(U,b);return(E-F)/(E-m.Dot(X,b))}static GetAngleBetweenVectors(U,X,b){const F=U.normalizeToRef(N.JX[1]),E=X.normalizeToRef(N.JX[2]);let w=m.Dot(F,E);w=(0,q.Clamp)(w,-1,1);const Q=Math.acos(w),z=N.JX[3];return m.CrossToRef(F,E,z),m.Dot(z,b)>0?isNaN(Q)?0:Q:isNaN(Q)?-Math.PI:-Math.acos(w)}static GetAngleBetweenVectorsOnPlane(U,X,b){N.JX[0].q(U);const F=N.JX[0];N.JX[1].q(X);const E=N.JX[1];N.JX[2].q(b);const w=N.JX[2],Q=N.JX[3],z=N.JX[4];F.normalize(),E.normalize(),w.normalize(),m.CrossToRef(w,F,Q),m.CrossToRef(Q,w,z);const p=Math.atan2(m.Dot(E,Q),m.Dot(E,z));return(0,q.NormalizeRadians)(p)}static PitchYawRollToMoveBetweenPointsToRef(U,X,b){const F=u.JX[0];return X.subtractToRef(U,F),b._y=Math.atan2(F.x,F.z)||0,b._x=Math.atan2(Math.sqrt(F.x**2+F.z**2),F.y)||0,b._z=0,b._isDirty=!0,b}static PitchYawRollToMoveBetweenPoints(U,X){const b=m.Zero();return m.PitchYawRollToMoveBetweenPointsToRef(U,X,b)}static SlerpToRef(U,X,b,E){b=(0,q.Clamp)(b,0,1);const w=N.JX[0],Q=N.JX[1];w.q(U);const z=w.length();w.normalizeFromLength(z),Q.q(X);const p=Q.length();Q.normalizeFromLength(p);const S=m.Dot(w,Q);let R,n;if(S<1-F.d){const U=Math.acos(S),X=1/Math.sin(U);R=Math.sin((1-b)*U)*X,n=Math.sin(b*U)*X}else R=1-b,n=b;return w.scaleInPlace(R),Q.scaleInPlace(n),E.q(w).addInPlace(Q),E.scaleInPlace((0,q.Lerp)(z,p,b)),E}static SmoothToRef(U,X,b,F,E){return m.SlerpToRef(U,X,0===F?1:b/F,E),E}static uX(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new m(U[X],U[X+1],U[X+2])}static FromFloatArray(U,X){return m.uX(U,X)}static FromArrayToRef(U,X,b){return b._x=U[X],b._y=U[X+1],b._z=U[X+2],b._isDirty=!0,b}static FromFloatArrayToRef(U,X,b){return m.FromArrayToRef(U,X,b)}static FromFloatsToRef(U,X,b,F){return F.Pb(U,X,b),F}static Zero(){return new m(0,0,0)}static One(){return new m(1,1,1)}static Up(){return new m(0,1,0)}static get UpReadOnly(){return m._UpReadOnly}static get DownReadOnly(){return m._DownReadOnly}static get RightReadOnly(){return m._RightReadOnly}static get LeftReadOnly(){return m._LeftReadOnly}static get LeftHandedForwardReadOnly(){return m._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return m._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return m._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return m._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return m._ZeroReadOnly}static get OneReadOnly(){return m._OneReadOnly}static Down(){return new m(0,-1,0)}static Forward(){return new m(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new m(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new m(1,0,0)}static Left(){return new m(-1,0,0)}static Random(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new m((0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X))}static RandomToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Pb((0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X))}static TransformCoordinates(U,X){const b=m.Zero();return m.TransformCoordinatesToRef(U,X,b),b}static TransformCoordinatesToRef(U,X,b){return m.TransformCoordinatesFromFloatsToRef(U._x,U._y,U._z,X,b),b}static TransformCoordinatesFromFloatsToRef(U,X,b,F,E){const w=F.m,Q=U*w[0]+X*w[4]+b*w[8]+w[12],z=U*w[1]+X*w[5]+b*w[9]+w[13],q=U*w[2]+X*w[6]+b*w[10]+w[14],p=1/(U*w[3]+X*w[7]+b*w[11]+w[15]);return E._x=Q*p,E._y=z*p,E._z=q*p,E._isDirty=!0,E}static TransformNormal(U,X){const b=m.Zero();return m.TransformNormalToRef(U,X,b),b}static TransformNormalToRef(U,X,b){return this.TransformNormalFromFloatsToRef(U._x,U._y,U._z,X,b),b}static TransformNormalFromFloatsToRef(U,X,b,F,E){const w=F.m;return E._x=U*w[0]+X*w[4]+b*w[8],E._y=U*w[1]+X*w[5]+b*w[9],E._z=U*w[2]+X*w[6]+b*w[10],E._isDirty=!0,E}static CatmullRom(U,X,b,F,E){const w=E*E,Q=E*w,z=.5*(2*X._x+(-U._x+b._x)*E+(2*U._x-5*X._x+4*b._x-F._x)*w+(-U._x+3*X._x-3*b._x+F._x)*Q),q=.5*(2*X._y+(-U._y+b._y)*E+(2*U._y-5*X._y+4*b._y-F._y)*w+(-U._y+3*X._y-3*b._y+F._y)*Q),p=.5*(2*X._z+(-U._z+b._z)*E+(2*U._z-5*X._z+4*b._z-F._z)*w+(-U._z+3*X._z-3*b._z+F._z)*Q);return new m(z,q,p)}static Clamp(U,X,b){const F=new m;return m.ClampToRef(U,X,b,F),F}static ClampToRef(U,X,b,F){let E=U._x;E=E>b._x?b._x:E,E=E<X._x?X._x:E;let w=U._y;w=w>b._y?b._y:w,w=w<X._y?X._y:w;let Q=U._z;return Q=Q>b._z?b._z:Q,Q=Q<X._z?X._z:Q,F.Pb(E,w,Q),F}static CheckExtends(U,X,b){X.minimizeInPlace(U),b.maximizeInPlace(U)}static Hermite(U,X,b,F,E){const w=E*E,Q=E*w,z=2*Q-3*w+1,q=-2*Q+3*w,p=Q-2*w+E,S=Q-w,R=U._x*z+b._x*q+X._x*p+F._x*S,n=U._y*z+b._y*q+X._y*p+F._y*S,a=U._z*z+b._z*q+X._z*p+F._z*S;return new m(R,n,a)}static Hermite1stDerivative(U,X,b,F,E){const w=new m;return this.Hermite1stDerivativeToRef(U,X,b,F,E,w),w}static Hermite1stDerivativeToRef(U,X,b,F,E,w){const Q=E*E;return w._x=6*(Q-E)*U._x+(3*Q-4*E+1)*X._x+6*(-Q+E)*b._x+(3*Q-2*E)*F._x,w._y=6*(Q-E)*U._y+(3*Q-4*E+1)*X._y+6*(-Q+E)*b._y+(3*Q-2*E)*F._y,w._z=6*(Q-E)*U._z+(3*Q-4*E+1)*X._z+6*(-Q+E)*b._z+(3*Q-2*E)*F._z,w._isDirty=!0,w}static Lerp(U,X,b){const F=new m(0,0,0);return m.LerpToRef(U,X,b,F),F}static LerpToRef(U,X,b,F){return F._x=U._x+(X._x-U._x)*b,F._y=U._y+(X._y-U._y)*b,F._z=U._z+(X._z-U._z)*b,F._isDirty=!0,F}static Dot(U,X){return U._x*X._x+U._y*X._y+U._z*X._z}dot(U){return this._x*U._x+this._y*U._y+this._z*U._z}static Cross(U,X){const b=new m;return m.CrossToRef(U,X,b),b}static CrossToRef(U,X,b){const F=U._y*X._z-U._z*X._y,E=U._z*X._x-U._x*X._z,w=U._x*X._y-U._y*X._x;return b.Pb(F,E,w),b}static Normalize(U){const X=m.Zero();return m.NormalizeToRef(U,X),X}static NormalizeToRef(U,X){return U.normalizeToRef(X),X}static Project(U,X,b,F){const E=new m;return m.ProjectToRef(U,X,b,F,E),E}static ProjectToRef(U,X,b,F,E){var w;const Q=F.width,q=F.height,p=F.x,S=F.y,R=N.Matrix[1],n=null===(w=z.c.LastCreatedEngine)||void 0===w?void 0:w.isNDCHalfZRange,a=n?1:.5,J=n?0:.5;O.FromValuesToRef(Q/2,0,0,0,0,-q/2,0,0,0,0,a,0,p+Q/2,q/2+S,J,1,R);const x=N.Matrix[0];return X.multiplyToRef(b,x),x.multiplyToRef(R,x),m.TransformCoordinatesToRef(U,x,E),E}static Reflect(U,X){return this.ReflectToRef(U,X,new m)}static ReflectToRef(U,X,b){const F=u.JX[0];return F.q(X).scaleInPlace(2*m.Dot(U,X)),b.q(U).pR(F)}static _UnprojectFromInvertedMatrixToRef(U,X,b){m.TransformCoordinatesToRef(U,X,b);const F=X.m,E=U._x*F[3]+U._y*F[7]+U._z*F[11]+F[15];return(0,q.WithinEpsilon)(E,1)&&b.scaleInPlace(1/E),b}static UnprojectFromTransform(U,X,b,F,E){return this.Unproject(U,X,b,F,E,O.IdentityReadOnly)}static Unproject(U,X,b,F,E,w){const Q=new m;return m.UnprojectToRef(U,X,b,F,E,w,Q),Q}static UnprojectToRef(U,X,b,F,E,w,Q){return m.UnprojectFloatsToRef(U._x,U._y,U._z,X,b,F,E,w,Q),Q}static UnprojectFloatsToRef(U,X,b,F,E,w,Q,q,p){var S;const R=N.Matrix[0];w.multiplyToRef(Q,R),R.multiplyToRef(q,R),R.invert();const n=N.JX[0];return n.x=U/F*2-1,n.y=-(X/E*2-1),null!==(S=z.c.LastCreatedEngine)&&void 0!==S&&S.isNDCHalfZRange?n.z=b:n.z=2*b-1,m._UnprojectFromInvertedMatrixToRef(n,R,p),p}static Minimize(U,X){const b=new m;return b.q(U),b.minimizeInPlace(X),b}static Maximize(U,X){const b=new m;return b.q(U),b.maximizeInPlace(X),b}static Distance(U,X){return Math.sqrt(m.DistanceSquared(U,X))}static DistanceSquared(U,X){const b=U._x-X._x,F=U._y-X._y,E=U._z-X._z;return b*b+F*F+E*E}static ProjectOnTriangleToRef(U,X,b,E,w){const Q=N.JX[0],z=N.JX[1],p=N.JX[2],S=N.JX[3],R=N.JX[4];b.subtractToRef(X,Q),E.subtractToRef(X,z),E.subtractToRef(b,p);const n=Q.length(),a=z.length(),J=p.length();if(n<F.d||a<F.d||J<F.d)return w.q(X),m.Distance(U,X);U.subtractToRef(X,R),m.CrossToRef(Q,z,S);const x=S.length();if(x<F.d)return w.q(X),m.Distance(U,X);S.normalizeFromLength(x);let I=R.length();if(I<F.d)return w.q(X),0;R.normalizeFromLength(I);const O=m.Dot(S,R),u=N.JX[5],i=N.JX[6];u.q(S).scaleInPlace(-I*O),i.q(U).addInPlace(u);const P=N.JX[4],f=N.JX[5],j=N.JX[7],e=N.JX[8];P.q(Q).scaleInPlace(1/n),e.q(z).scaleInPlace(1/a),P.addInPlace(e).scaleInPlace(-1),f.q(Q).scaleInPlace(-1/n),e.q(p).scaleInPlace(1/J),f.addInPlace(e).scaleInPlace(-1),j.q(p).scaleInPlace(-1/J),e.q(z).scaleInPlace(-1/a),j.addInPlace(e).scaleInPlace(-1);const l=N.JX[9];let d;l.q(i).pR(X),m.CrossToRef(P,l,e),d=m.Dot(e,S);const k=d;l.q(i).pR(b),m.CrossToRef(f,l,e),d=m.Dot(e,S);const v=d;l.q(i).pR(E),m.CrossToRef(j,l,e),d=m.Dot(e,S);const A=d,s=N.JX[10];let h,B;k>0&&v<0?(s.q(Q),h=X,B=b):v>0&&A<0?(s.q(p),h=b,B=E):(s.q(z).scaleInPlace(-1),h=E,B=X);const o=N.JX[9],y=N.JX[4];h.subtractToRef(i,e),B.subtractToRef(i,o),m.CrossToRef(e,o,y);if(!(m.Dot(y,S)<0))return w.q(i),Math.abs(I*O);const t=N.JX[5];m.CrossToRef(s,y,t),t.normalize();const W=N.JX[9];W.q(h).pR(i);const Y=W.length();if(Y<F.d)return w.q(h),m.Distance(U,h);W.normalizeFromLength(Y);const K=m.Dot(t,W),V=N.JX[7];V.q(i).addInPlace(t.scaleInPlace(Y*K)),e.q(V).pR(h),I=s.length(),s.normalizeFromLength(I);let g=m.Dot(e,s)/Math.max(I,F.d);return g=(0,q.Clamp)(g,0,1),V.q(h).addInPlace(s.scaleInPlace(g*I)),w.q(V),m.Distance(U,V)}static Center(U,X){return m.CenterToRef(U,X,m.Zero())}static CenterToRef(U,X,b){return b.Pb((U._x+X._x)/2,(U._y+X._y)/2,(U._z+X._z)/2)}static RotationFromAxis(U,X,b){const F=new m;return m.RotationFromAxisToRef(U,X,b,F),F}static RotationFromAxisToRef(U,X,b,F){const E=N.Quaternion[0];return I.RotationQuaternionFromAxisToRef(U,X,b,E),E.toEulerAnglesToRef(F),F}}m._V8PerformanceHack=new m(.5,.5,.5),m._UpReadOnly=m.Up(),m._DownReadOnly=m.Down(),m._LeftHandedForwardReadOnly=m.Forward(!1),m._RightHandedForwardReadOnly=m.Forward(!0),m._LeftHandedBackwardReadOnly=m.Backward(!1),m._RightHandedBackwardReadOnly=m.Backward(!0),m._RightReadOnly=m.Right(),m._LeftReadOnly=m.Left(),m._ZeroReadOnly=m.Zero(),m._OneReadOnly=m.One(),Object.defineProperties(m.prototype,{dimension:{value:[3]},rank:{value:1}});class x{get x(){return this._x}set x(U){this._x=U,this._isDirty=!0}get y(){return this._y}set y(U){this._y=U,this._isDirty=!0}get z(){return this._z}set z(U){this._z=U,this._isDirty=!0}get w(){return this._w}set w(U){this._w=U,this._isDirty=!0}constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=U,this._y=X,this._z=b,this._w=F}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let U=a(this._x);return U=397*U^a(this._y),U=397*U^a(this._z),U=397*U^a(this._w),U}Jb(){return[this._x,this._y,this._z,this._w]}toArray(U,X){return void 0===X&&(X=0),U[X]=this._x,U[X+1]=this._y,U[X+2]=this._z,U[X+3]=this._w,this}qF(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return x.FromArrayToRef(U,X,this),this}addInPlace(U){return this.x+=U._x,this.y+=U._y,this.z+=U._z,this.w+=U._w,this}addInPlaceFromFloats(U,X,b,F){return this.x+=U,this.y+=X,this.z+=b,this.w+=F,this}add(U){return new x(this._x+U.x,this._y+U.y,this._z+U.z,this._w+U.w)}addToRef(U,X){return X.x=this._x+U.x,X.y=this._y+U.y,X.z=this._z+U.z,X.w=this._w+U.w,X}pR(U){return this.x-=U.x,this.y-=U.y,this.z-=U.z,this.w-=U.w,this}mX(U){return new x(this._x-U.x,this._y-U.y,this._z-U.z,this._w-U.w)}subtractToRef(U,X){return X.x=this._x-U.x,X.y=this._y-U.y,X.z=this._z-U.z,X.w=this._w-U.w,X}subtractFromFloats(U,X,b,F){return new x(this._x-U,this._y-X,this._z-b,this._w-F)}subtractFromFloatsToRef(U,X,b,F,E){return E.x=this._x-U,E.y=this._y-X,E.z=this._z-b,E.w=this._w-F,E}negate(){return new x(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(U){return U.x=-this._x,U.y=-this._y,U.z=-this._z,U.w=-this._w,U}scaleInPlace(U){return this.x*=U,this.y*=U,this.z*=U,this.w*=U,this}scale(U){return new x(this._x*U,this._y*U,this._z*U,this._w*U)}scaleToRef(U,X){return X.x=this._x*U,X.y=this._y*U,X.z=this._z*U,X.w=this._w*U,X}scaleAndAddToRef(U,X){return X.x+=this._x*U,X.y+=this._y*U,X.z+=this._z*U,X.w+=this._w*U,X}equals(U){return U&&this._x===U.x&&this._y===U.y&&this._z===U.z&&this._w===U.w}equalsWithEpsilon(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.d;return U&&(0,q.WithinEpsilon)(this._x,U.x,X)&&(0,q.WithinEpsilon)(this._y,U.y,X)&&(0,q.WithinEpsilon)(this._z,U.z,X)&&(0,q.WithinEpsilon)(this._w,U.w,X)}equalsToFloats(U,X,b,F){return this._x===U&&this._y===X&&this._z===b&&this._w===F}multiplyInPlace(U){return this.x*=U.x,this.y*=U.y,this.z*=U.z,this.w*=U.w,this}multiply(U){return new x(this._x*U.x,this._y*U.y,this._z*U.z,this._w*U.w)}multiplyToRef(U,X){return X.x=this._x*U.x,X.y=this._y*U.y,X.z=this._z*U.z,X.w=this._w*U.w,X}multiplyByFloats(U,X,b,F){return new x(this._x*U,this._y*X,this._z*b,this._w*F)}divide(U){return new x(this._x/U.x,this._y/U.y,this._z/U.z,this._w/U.w)}divideToRef(U,X){return X.x=this._x/U.x,X.y=this._y/U.y,X.z=this._z/U.z,X.w=this._w/U.w,X}divideInPlace(U){return this.divideToRef(U,this)}minimizeInPlace(U){return U.x<this._x&&(this.x=U.x),U.y<this._y&&(this.y=U.y),U.z<this._z&&(this.z=U.z),U.w<this._w&&(this.w=U.w),this}maximizeInPlace(U){return U.x>this._x&&(this.x=U.x),U.y>this._y&&(this.y=U.y),U.z>this._z&&(this.z=U.z),U.w>this._w&&(this.w=U.w),this}minimizeInPlaceFromFloats(U,X,b,F){return this.x=Math.min(U,this._x),this.y=Math.min(X,this._y),this.z=Math.min(b,this._z),this.w=Math.min(F,this._w),this}maximizeInPlaceFromFloats(U,X,b,F){return this.x=Math.max(U,this._x),this.y=Math.max(X,this._y),this.z=Math.max(b,this._z),this.w=Math.max(F,this._w),this}floorToRef(U){return U.x=Math.floor(this._x),U.y=Math.floor(this._y),U.z=Math.floor(this._z),U.w=Math.floor(this._w),U}floor(){return new x(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(U){return U.x=this._x-Math.floor(this._x),U.y=this._y-Math.floor(this._y),U.z=this._z-Math.floor(this._z),U.w=this._w-Math.floor(this._w),U}fract(){return new x(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(U){return 0===U||1===U?this:this.scaleInPlace(1/U)}normalizeToNew(){return this.normalizeToRef(new x)}normalizeToRef(U){const X=this.length();return 0===X||1===X?(U.x=this._x,U.y=this._y,U.z=this._z,U.w=this._w,U):this.scaleToRef(1/X,U)}toVector3(){return new m(this._x,this._y,this._z)}clone(){return new x(this._x,this._y,this._z,this._w)}q(U){return this.x=U.x,this.y=U.y,this.z=U.z,this.w=U.w,this}Pb(U,X,b,F){return this.x=U,this.y=X,this.z=b,this.w=F,this}set(U,X,b,F){return this.Pb(U,X,b,F)}jb(U){return this.x=this.y=this.z=this.w=U,this}dot(U){return this._x*U.x+this._y*U.y+this._z*U.z+this._w*U.w}static uX(U,X){return X||(X=0),new x(U[X],U[X+1],U[X+2],U[X+3])}static FromArrayToRef(U,X,b){return b.x=U[X],b.y=U[X+1],b.z=U[X+2],b.w=U[X+3],b}static FromFloatArrayToRef(U,X,b){return x.FromArrayToRef(U,X,b),b}static FromFloatsToRef(U,X,b,F,E){return E.x=U,E.y=X,E.z=b,E.w=F,E}static Zero(){return new x(0,0,0,0)}static One(){return new x(1,1,1,1)}static Random(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new x((0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X))}static RandomToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.x=(0,q.RandomRange)(U,X),b.y=(0,q.RandomRange)(U,X),b.z=(0,q.RandomRange)(U,X),b.w=(0,q.RandomRange)(U,X),b}static Clamp(U,X,b){return x.ClampToRef(U,X,b,new x)}static ClampToRef(U,X,b,F){return F.x=(0,q.Clamp)(U.x,X.x,b.x),F.y=(0,q.Clamp)(U.y,X.y,b.y),F.z=(0,q.Clamp)(U.z,X.z,b.z),F.w=(0,q.Clamp)(U.w,X.w,b.w),F}static CheckExtends(U,X,b){X.minimizeInPlace(U),b.maximizeInPlace(U)}static get ZeroReadOnly(){return x._ZeroReadOnly}static Normalize(U){return x.NormalizeToRef(U,new x)}static NormalizeToRef(U,X){return U.normalizeToRef(X),X}static Minimize(U,X){const b=new x;return b.q(U),b.minimizeInPlace(X),b}static Maximize(U,X){const b=new x;return b.q(U),b.maximizeInPlace(X),b}static Distance(U,X){return Math.sqrt(x.DistanceSquared(U,X))}static DistanceSquared(U,X){const b=U.x-X.x,F=U.y-X.y,E=U.z-X.z,w=U.w-X.w;return b*b+F*F+E*E+w*w}static Center(U,X){return x.CenterToRef(U,X,new x)}static CenterToRef(U,X,b){return b.x=(U.x+X.x)/2,b.y=(U.y+X.y)/2,b.z=(U.z+X.z)/2,b.w=(U.w+X.w)/2,b}static TransformCoordinates(U,X){return x.TransformCoordinatesToRef(U,X,new x)}static TransformCoordinatesToRef(U,X,b){return x.TransformCoordinatesFromFloatsToRef(U._x,U._y,U._z,X,b),b}static TransformCoordinatesFromFloatsToRef(U,X,b,F,E){const w=F.m,Q=U*w[0]+X*w[4]+b*w[8]+w[12],z=U*w[1]+X*w[5]+b*w[9]+w[13],q=U*w[2]+X*w[6]+b*w[10]+w[14],p=U*w[3]+X*w[7]+b*w[11]+w[15];return E.x=Q,E.y=z,E.z=q,E.w=p,E}static TransformNormal(U,X){return x.TransformNormalToRef(U,X,new x)}static TransformNormalToRef(U,X,b){const F=X.m,E=U.x*F[0]+U.y*F[4]+U.z*F[8],w=U.x*F[1]+U.y*F[5]+U.z*F[9],Q=U.x*F[2]+U.y*F[6]+U.z*F[10];return b.x=E,b.y=w,b.z=Q,b.w=U.w,b}static TransformNormalFromFloatsToRef(U,X,b,F,E,w){const Q=E.m;return w.x=U*Q[0]+X*Q[4]+b*Q[8],w.y=U*Q[1]+X*Q[5]+b*Q[9],w.z=U*Q[2]+X*Q[6]+b*Q[10],w.w=F,w}static FromVector3(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new x(U._x,U._y,U._z,X)}static Dot(U,X){return U.x*X.x+U.y*X.y+U.z*X.z+U.w*X.w}}x._V8PerformanceHack=new x(.5,.5,.5,.5),x._ZeroReadOnly=x.Zero(),Object.defineProperties(x.prototype,{dimension:{value:[4]},rank:{value:1}});class I{get x(){return this._x}set x(U){this._x=U,this._isDirty=!0}get y(){return this._y}set y(U){this._y=U,this._isDirty=!0}get z(){return this._z}set z(U){this._z=U,this._isDirty=!0}get w(){return this._w}set w(U){this._w=U,this._isDirty=!0}constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=U,this._y=X,this._z=b,this._w=F}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let U=a(this._x);return U=397*U^a(this._y),U=397*U^a(this._z),U=397*U^a(this._w),U}Jb(){return[this._x,this._y,this._z,this._w]}toArray(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U[X]=this._x,U[X+1]=this._y,U[X+2]=this._z,U[X+3]=this._w,this}qF(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I.FromArrayToRef(U,X,this)}equals(U){return U&&this._x===U._x&&this._y===U._y&&this._z===U._z&&this._w===U._w}equalsWithEpsilon(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.d;return U&&(0,q.WithinEpsilon)(this._x,U._x,X)&&(0,q.WithinEpsilon)(this._y,U._y,X)&&(0,q.WithinEpsilon)(this._z,U._z,X)&&(0,q.WithinEpsilon)(this._w,U._w,X)}isApprox(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.d;return U&&((0,q.WithinEpsilon)(this._x,U._x,X)&&(0,q.WithinEpsilon)(this._y,U._y,X)&&(0,q.WithinEpsilon)(this._z,U._z,X)&&(0,q.WithinEpsilon)(this._w,U._w,X)||(0,q.WithinEpsilon)(this._x,-U._x,X)&&(0,q.WithinEpsilon)(this._y,-U._y,X)&&(0,q.WithinEpsilon)(this._z,-U._z,X)&&(0,q.WithinEpsilon)(this._w,-U._w,X))}clone(){return new I(this._x,this._y,this._z,this._w)}q(U){return this._x=U._x,this._y=U._y,this._z=U._z,this._w=U._w,this._isDirty=!0,this}Pb(U,X,b,F){return this._x=U,this._y=X,this._z=b,this._w=F,this._isDirty=!0,this}set(U,X,b,F){return this.Pb(U,X,b,F)}jb(U){return this.Pb(U,U,U,U)}add(U){return new I(this._x+U._x,this._y+U._y,this._z+U._z,this._w+U._w)}addInPlace(U){return this._x+=U._x,this._y+=U._y,this._z+=U._z,this._w+=U._w,this._isDirty=!0,this}addToRef(U,X){return X._x=this._x+U._x,X._y=this._y+U._y,X._z=this._z+U._z,X._w=this._w+U._w,X._isDirty=!0,X}addInPlaceFromFloats(U,X,b,F){return this._x+=U,this._y+=X,this._z+=b,this._w+=F,this._isDirty=!0,this}subtractToRef(U,X){return X._x=this._x-U._x,X._y=this._y-U._y,X._z=this._z-U._z,X._w=this._w-U._w,X._isDirty=!0,X}subtractFromFloats(U,X,b,F){return this.subtractFromFloatsToRef(U,X,b,F,new I)}subtractFromFloatsToRef(U,X,b,F,E){return E._x=this._x-U,E._y=this._y-X,E._z=this._z-b,E._w=this._w-F,E._isDirty=!0,E}mX(U){return new I(this._x-U._x,this._y-U._y,this._z-U._z,this._w-U._w)}pR(U){return this._x-=U._x,this._y-=U._y,this._z-=U._z,this._w-=U._w,this._isDirty=!0,this}scale(U){return new I(this._x*U,this._y*U,this._z*U,this._w*U)}scaleToRef(U,X){return X._x=this._x*U,X._y=this._y*U,X._z=this._z*U,X._w=this._w*U,X._isDirty=!0,X}scaleInPlace(U){return this._x*=U,this._y*=U,this._z*=U,this._w*=U,this._isDirty=!0,this}scaleAndAddToRef(U,X){return X._x+=this._x*U,X._y+=this._y*U,X._z+=this._z*U,X._w+=this._w*U,X._isDirty=!0,X}multiply(U){const X=new I(0,0,0,1);return this.multiplyToRef(U,X),X}multiplyToRef(U,X){const b=this._x*U._w+this._y*U._z-this._z*U._y+this._w*U._x,F=-this._x*U._z+this._y*U._w+this._z*U._x+this._w*U._y,E=this._x*U._y-this._y*U._x+this._z*U._w+this._w*U._z,w=-this._x*U._x-this._y*U._y-this._z*U._z+this._w*U._w;return X.Pb(b,F,E,w),X}multiplyInPlace(U){return this.multiplyToRef(U,this)}multiplyByFloats(U,X,b,F){return this._x*=U,this._y*=X,this._z*=b,this._w*=F,this._isDirty=!0,this}divide(U){throw new ReferenceError("Can not divide a quaternion")}divideToRef(U,X){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(U){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new I)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(U){return U._x=-this._x,U._y=-this._y,U._z=-this._z,U._w=-this._w,U._isDirty=!0,U}equalsToFloats(U,X,b,F){return this._x===U&&this._y===X&&this._z===b&&this._w===F}floorToRef(U){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(U){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(U){return U.Pb(-this._x,-this._y,-this._z,this._w),U}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new I(-this._x,-this._y,-this._z,this._w)}invert(){const U=this.conjugate(),X=this.lengthSquared();return 0==X||1==X||U.scaleInPlace(1/X),U}invertInPlace(){this.conjugateInPlace();const U=this.lengthSquared();return 0==U||1==U||this.scaleInPlace(1/U),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(U){return 0===U||1===U?this:this.scaleInPlace(1/U)}normalizeToNew(){const U=new I(0,0,0,1);return this.normalizeToRef(U),U}normalizeToRef(U){const X=this.length();return 0===X||1===X?U.Pb(this._x,this._y,this._z,this._w):this.scaleToRef(1/X,U)}toEulerAngles(){const U=m.Zero();return this.toEulerAnglesToRef(U),U}toEulerAnglesToRef(U){const X=this._z,b=this._x,F=this._y,E=this._w,w=F*X-b*E,Q=.4999999;if(w<-Q)U._y=2*Math.atan2(F,E),U._x=Math.PI/2,U._z=0,U._isDirty=!0;else if(w>Q)U._y=2*Math.atan2(F,E),U._x=-Math.PI/2,U._z=0,U._isDirty=!0;else{const Q=E*E,z=X*X,q=b*b,p=F*F;U._z=Math.atan2(2*(b*F+X*E),-z-q+p+Q),U._x=Math.asin(-2*w),U._y=Math.atan2(2*(X*b+F*E),z-q-p+Q),U._isDirty=!0}return U}toAlphaBetaGammaToRef(U){const X=this._z,b=this._x,F=this._y,E=this._w,w=Math.sqrt(b*b+F*F),Q=Math.sqrt(X*X+E*E),z=2*Math.atan2(w,Q),q=2*Math.atan2(X,E),p=2*Math.atan2(F,b),S=(q+p)/2,R=(q-p)/2;return U.set(R,z,S),U}toRotationMatrix(U){return O.FromQuaternionToRef(this,U),U}fromRotationMatrix(U){return I.FromRotationMatrixToRef(U,this),this}dot(U){return this._x*U._x+this._y*U._y+this._z*U._z+this._w*U._w}toAxisAngle(){const U=m.Zero();return{axis:U,angle:this.toAxisAngleToRef(U)}}toAxisAngleToRef(U){let X=0;const b=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),F=this._w;return b>0?(X=2*Math.atan2(b,F),U.set(this._x/b,this._y/b,this._z/b)):(X=0,U.set(1,0,0)),X}static FromRotationMatrix(U){const X=new I;return I.FromRotationMatrixToRef(U,X),X}static FromRotationMatrixToRef(U,X){const b=U.m,F=b[0],E=b[4],w=b[8],Q=b[1],z=b[5],q=b[9],p=b[2],S=b[6],R=b[10],n=F+z+R;let a;return n>0?(a=.5/Math.sqrt(n+1),X._w=.25/a,X._x=(S-q)*a,X._y=(w-p)*a,X._z=(Q-E)*a,X._isDirty=!0):F>z&&F>R?(a=2*Math.sqrt(1+F-z-R),X._w=(S-q)/a,X._x=.25*a,X._y=(E+Q)/a,X._z=(w+p)/a,X._isDirty=!0):z>R?(a=2*Math.sqrt(1+z-F-R),X._w=(w-p)/a,X._x=(E+Q)/a,X._y=.25*a,X._z=(q+S)/a,X._isDirty=!0):(a=2*Math.sqrt(1+R-F-z),X._w=(Q-E)/a,X._x=(w+p)/a,X._y=(q+S)/a,X._z=.25*a,X._isDirty=!0),X}static Dot(U,X){return U._x*X._x+U._y*X._y+U._z*X._z+U._w*X._w}static AreClose(U,X){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const F=I.Dot(U,X);return 1-F*F<=b}static SmoothToRef(U,X,b,F,E){let w=0===F?1:b/F;return w=(0,q.Clamp)(w,0,1),I.SlerpToRef(U,X,w,E),E}static Zero(){return new I(0,0,0,0)}static Inverse(U){return new I(-U._x,-U._y,-U._z,U._w)}static InverseToRef(U,X){return X.set(-U._x,-U._y,-U._z,U._w),X}static Identity(){return new I(0,0,0,1)}static IsIdentity(U){return U&&0===U._x&&0===U._y&&0===U._z&&1===U._w}static RotationAxis(U,X){return I.RotationAxisToRef(U,X,new I)}static RotationAxisToRef(U,X,b){b._w=Math.cos(X/2);const F=Math.sin(X/2)/U.length();return b._x=U._x*F,b._y=U._y*F,b._z=U._z*F,b._isDirty=!0,b}static uX(U,X){return X||(X=0),new I(U[X],U[X+1],U[X+2],U[X+3])}static FromArrayToRef(U,X,b){return b._x=U[X],b._y=U[X+1],b._z=U[X+2],b._w=U[X+3],b._isDirty=!0,b}static FromFloatsToRef(U,X,b,F,E){return E.Pb(U,X,b,F),E}static FromEulerAngles(U,X,b){const F=new I;return I.RotationYawPitchRollToRef(X,U,b,F),F}static FromEulerAnglesToRef(U,X,b,F){return I.RotationYawPitchRollToRef(X,U,b,F),F}static FromEulerVector(U){const X=new I;return I.RotationYawPitchRollToRef(U._y,U._x,U._z,X),X}static FromEulerVectorToRef(U,X){return I.RotationYawPitchRollToRef(U._y,U._x,U._z,X),X}static FromUnitVectorsToRef(U,X,b){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:F.d;const w=m.Dot(U,X)+1;return w<E?Math.abs(U.x)>Math.abs(U.z)?b.set(-U.y,U.x,0,0):b.set(0,-U.z,U.y,0):(m.CrossToRef(U,X,u.JX[0]),b.set(u.JX[0].x,u.JX[0].y,u.JX[0].z,w)),b.normalize()}static RotationYawPitchRoll(U,X,b){const F=new I;return I.RotationYawPitchRollToRef(U,X,b,F),F}static RotationYawPitchRollToRef(U,X,b,F){const E=.5*b,w=.5*X,Q=.5*U,z=Math.sin(E),q=Math.cos(E),p=Math.sin(w),S=Math.cos(w),R=Math.sin(Q),n=Math.cos(Q);return F._x=n*p*q+R*S*z,F._y=R*S*q-n*p*z,F._z=n*S*z-R*p*q,F._w=n*S*q+R*p*z,F._isDirty=!0,F}static RotationAlphaBetaGamma(U,X,b){const F=new I;return I.RotationAlphaBetaGammaToRef(U,X,b,F),F}static RotationAlphaBetaGammaToRef(U,X,b,F){const E=.5*(b+U),w=.5*(b-U),Q=.5*X;return F._x=Math.cos(w)*Math.sin(Q),F._y=Math.sin(w)*Math.sin(Q),F._z=Math.sin(E)*Math.cos(Q),F._w=Math.cos(E)*Math.cos(Q),F._isDirty=!0,F}static RotationQuaternionFromAxis(U,X,b){const F=new I(0,0,0,0);return I.RotationQuaternionFromAxisToRef(U,X,b,F),F}static RotationQuaternionFromAxisToRef(U,X,b,F){const E=N.Matrix[0];return U=U.normalizeToRef(N.JX[0]),X=X.normalizeToRef(N.JX[1]),b=b.normalizeToRef(N.JX[2]),O.FromXYZAxesToRef(U,X,b,E),I.FromRotationMatrixToRef(E,F),F}static FromLookDirectionLH(U,X){const b=new I;return I.FromLookDirectionLHToRef(U,X,b),b}static FromLookDirectionLHToRef(U,X,b){const F=N.Matrix[0];return O.LookDirectionLHToRef(U,X,F),I.FromRotationMatrixToRef(F,b),b}static FromLookDirectionRH(U,X){const b=new I;return I.FromLookDirectionRHToRef(U,X,b),b}static FromLookDirectionRHToRef(U,X,b){const F=N.Matrix[0];return O.LookDirectionRHToRef(U,X,F),I.FromRotationMatrixToRef(F,b)}static Slerp(U,X,b){const F=I.Identity();return I.SlerpToRef(U,X,b,F),F}static SlerpToRef(U,X,b,F){let E,w,Q=U._x*X._x+U._y*X._y+U._z*X._z+U._w*X._w,z=!1;if(Q<0&&(z=!0,Q=-Q),Q>.999999)w=1-b,E=z?-b:b;else{const U=Math.acos(Q),X=1/Math.sin(U);w=Math.sin((1-b)*U)*X,E=z?-Math.sin(b*U)*X:Math.sin(b*U)*X}return F._x=w*U._x+E*X._x,F._y=w*U._y+E*X._y,F._z=w*U._z+E*X._z,F._w=w*U._w+E*X._w,F._isDirty=!0,F}static Hermite(U,X,b,F,E){const w=E*E,Q=E*w,z=2*Q-3*w+1,q=-2*Q+3*w,p=Q-2*w+E,S=Q-w,R=U._x*z+b._x*q+X._x*p+F._x*S,n=U._y*z+b._y*q+X._y*p+F._y*S,a=U._z*z+b._z*q+X._z*p+F._z*S,J=U._w*z+b._w*q+X._w*p+F._w*S;return new I(R,n,a,J)}static Hermite1stDerivative(U,X,b,F,E){const w=new I;return this.Hermite1stDerivativeToRef(U,X,b,F,E,w),w}static Hermite1stDerivativeToRef(U,X,b,F,E,w){const Q=E*E;return w._x=6*(Q-E)*U._x+(3*Q-4*E+1)*X._x+6*(-Q+E)*b._x+(3*Q-2*E)*F._x,w._y=6*(Q-E)*U._y+(3*Q-4*E+1)*X._y+6*(-Q+E)*b._y+(3*Q-2*E)*F._y,w._z=6*(Q-E)*U._z+(3*Q-4*E+1)*X._z+6*(-Q+E)*b._z+(3*Q-2*E)*F._z,w._w=6*(Q-E)*U._w+(3*Q-4*E+1)*X._w+6*(-Q+E)*b._w+(3*Q-2*E)*F._w,w._isDirty=!0,w}static Normalize(U){const X=I.Zero();return I.NormalizeToRef(U,X),X}static NormalizeToRef(U,X){return U.normalizeToRef(X),X}static Clamp(U,X,b){const F=new I;return I.ClampToRef(U,X,b,F),F}static ClampToRef(U,X,b,F){return F.Pb((0,q.Clamp)(U.x,X.x,b.x),(0,q.Clamp)(U.y,X.y,b.y),(0,q.Clamp)(U.z,X.z,b.z),(0,q.Clamp)(U.w,X.w,b.w))}static Random(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new I((0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X))}static RandomToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Pb((0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X),(0,q.RandomRange)(U,X))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(U,X){return Math.sqrt(I.DistanceSquared(U,X))}static DistanceSquared(U,X){const b=U.x-X.x,F=U.y-X.y,E=U.z-X.z,w=U.w-X.w;return b*b+F*F+E*E+w*w}static Center(U,X){return I.CenterToRef(U,X,I.Zero())}static CenterToRef(U,X,b){return b.Pb((U.x+X.x)/2,(U.y+X.y)/2,(U.z+X.z)/2,(U.w+X.w)/2)}}I._V8PerformanceHack=new I(.5,.5,.5,.5),Object.defineProperties(I.prototype,{dimension:{value:[4]},rank:{value:1}});class O{static get Use64Bits(){return Q.e.MatrixUse64Bits}get m(){return this.zb}markAsUpdated(){this.updateFlag=p._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(U){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],F=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=U,this._isIdentity3x2=U||b,this._isIdentityDirty=!this._isIdentity&&X,this._isIdentity3x2Dirty=!this._isIdentity3x2&&F}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,Q.e.MatrixTrackPrecisionChange&&Q.e.MatrixTrackedMatrices.push(this),this.zb=new Q.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const U=this.zb;this._isIdentity=1===U[0]&&0===U[1]&&0===U[2]&&0===U[3]&&0===U[4]&&1===U[5]&&0===U[6]&&0===U[7]&&0===U[8]&&0===U[9]&&1===U[10]&&0===U[11]&&0===U[12]&&0===U[13]&&0===U[14]&&1===U[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.zb[0]||1!==this.zb[5]||1!==this.zb[15]||0!==this.zb[1]||0!==this.zb[2]||0!==this.zb[3]||0!==this.zb[4]||0!==this.zb[6]||0!==this.zb[7]||0!==this.zb[8]||0!==this.zb[9]||0!==this.zb[10]||0!==this.zb[11]||0!==this.zb[12]||0!==this.zb[13]||0!==this.zb[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const U=this.zb,X=U[0],b=U[1],F=U[2],E=U[3],w=U[4],Q=U[5],z=U[6],q=U[7],p=U[8],S=U[9],R=U[10],n=U[11],a=U[12],J=U[13],m=U[14],x=U[15],I=R*x-m*n,O=S*x-J*n,N=S*m-J*R,u=p*x-a*n,i=p*m-R*a,P=p*J-a*S;return X*+(Q*I-z*O+q*N)+b*-(w*I-z*u+q*i)+F*+(w*O-Q*u+q*P)+E*-(w*N-Q*i+z*P)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!U)return this.zb;const b=this.zb;for(let F=0;F<16;F++)U[X+F]=b[F];return this}Jb(){return this.zb}qF(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(U,X,this)}Pb(){for(var U=arguments.length,X=new Array(U),b=0;b<U;b++)X[b]=arguments[b];return O.FromArrayToRef(X,0,this)}set(){const U=this.zb;for(let X=0;X<16;X++)U[X]=X<0||arguments.length<=X?void 0:arguments[X];return this.markAsUpdated(),this}jb(U){const X=this.zb;for(let b=0;b<16;b++)X[b]=U;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return O.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(U){const X=new O;return this.addToRef(U,X),X}addToRef(U,X){const b=this.zb,F=X.zb,E=U.m;for(let w=0;w<16;w++)F[w]=b[w]+E[w];return X.markAsUpdated(),X}addToSelf(U){const X=this.zb,b=U.m;return X[0]+=b[0],X[1]+=b[1],X[2]+=b[2],X[3]+=b[3],X[4]+=b[4],X[5]+=b[5],X[6]+=b[6],X[7]+=b[7],X[8]+=b[8],X[9]+=b[9],X[10]+=b[10],X[11]+=b[11],X[12]+=b[12],X[13]+=b[13],X[14]+=b[14],X[15]+=b[15],this.markAsUpdated(),this}addInPlace(U){const X=this.zb,b=U.m;for(let F=0;F<16;F++)X[F]+=b[F];return this.markAsUpdated(),this}addInPlaceFromFloats(){const U=this.zb;for(let X=0;X<16;X++)U[X]+=X<0||arguments.length<=X?void 0:arguments[X];return this.markAsUpdated(),this}mX(U){const X=this.zb,b=U.m;for(let F=0;F<16;F++)X[F]-=b[F];return this.markAsUpdated(),this}subtractToRef(U,X){const b=this.zb,F=U.m,E=X.zb;for(let w=0;w<16;w++)E[w]=b[w]-F[w];return X.markAsUpdated(),X}pR(U){const X=this.zb,b=U.m;for(let F=0;F<16;F++)X[F]-=b[F];return this.markAsUpdated(),this}subtractFromFloats(){for(var U=arguments.length,X=new Array(U),b=0;b<U;b++)X[b]=arguments[b];return this.subtractFromFloatsToRef(...X,new O)}subtractFromFloatsToRef(){for(var U=arguments.length,X=new Array(U),b=0;b<U;b++)X[b]=arguments[b];const F=X.pop(),E=this.zb,w=F.zb,Q=X;for(let z=0;z<16;z++)w[z]=E[z]-Q[z];return F.markAsUpdated(),F}invertToRef(U){return!0===this._isIdentity?(O.IdentityToRef(U),U):(n(this,U.Jb())?U.markAsUpdated():U.q(this),U)}addAtIndex(U,X){return this.zb[U]+=X,this.markAsUpdated(),this}multiplyAtIndex(U,X){return this.zb[U]*=X,this.markAsUpdated(),this}setTranslationFromFloats(U,X,b){return this.zb[12]=U,this.zb[13]=X,this.zb[14]=b,this.markAsUpdated(),this}addTranslationFromFloats(U,X,b){return this.zb[12]+=U,this.zb[13]+=X,this.zb[14]+=b,this.markAsUpdated(),this}setTranslation(U){return this.setTranslationFromFloats(U._x,U._y,U._z)}getTranslation(){return new m(this.zb[12],this.zb[13],this.zb[14])}getTranslationToRef(U){return U.x=this.zb[12],U.y=this.zb[13],U.z=this.zb[14],U}removeRotationAndScaling(){const U=this.m;return O.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,U[12],U[13],U[14],U[15],this),this._updateIdentityStatus(0===U[12]&&0===U[13]&&0===U[14]&&1===U[15]),this}q(U){U.copyToArray(this.zb);const X=U;return this.updateFlag=X.updateFlag,this._updateIdentityStatus(X._isIdentity,X._isIdentityDirty,X._isIdentity3x2,X._isIdentity3x2Dirty),this}copyToArray(U){return R(this,U,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(U){const X=new O;return this.multiplyToRef(U,X),X}multiplyInPlace(U){const X=this.zb,b=U.m;for(let F=0;F<16;F++)X[F]*=b[F];return this.markAsUpdated(),this}multiplyByFloats(){const U=this.zb;for(let X=0;X<16;X++)U[X]*=X<0||arguments.length<=X?void 0:arguments[X];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var U=arguments.length,X=new Array(U),b=0;b<U;b++)X[b]=arguments[b];const F=X.pop(),E=this.zb,w=F.zb,Q=X;for(let z=0;z<16;z++)w[z]=E[z]*Q[z];return F.markAsUpdated(),F}multiplyToRef(U,X){return this._isIdentity?(X.q(U),X):U._isIdentity?(X.q(this),X):(this.multiplyToArray(U,X.zb,0),X.markAsUpdated(),X)}multiplyToArray(U,X,b){return S(this,U,X,b),this}divide(U){return this.divideToRef(U,new O)}divideToRef(U,X){const b=this.zb,F=U.m,E=X.zb;for(let w=0;w<16;w++)E[w]=b[w]/F[w];return X.markAsUpdated(),X}divideInPlace(U){const X=this.zb,b=U.m;for(let F=0;F<16;F++)X[F]/=b[F];return this.markAsUpdated(),this}minimizeInPlace(U){const X=this.zb,b=U.m;for(let F=0;F<16;F++)X[F]=Math.min(X[F],b[F]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const U=this.zb;for(let X=0;X<16;X++)U[X]=Math.min(U[X],X<0||arguments.length<=X?void 0:arguments[X]);return this.markAsUpdated(),this}maximizeInPlace(U){const X=this.zb,b=U.m;for(let F=0;F<16;F++)X[F]=Math.min(X[F],b[F]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const U=this.zb;for(let X=0;X<16;X++)U[X]=Math.min(U[X],X<0||arguments.length<=X?void 0:arguments[X]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new O)}negateInPlace(){const U=this.zb;for(let X=0;X<16;X++)U[X]=-U[X];return this.markAsUpdated(),this}negateToRef(U){const X=this.zb,b=U.zb;for(let F=0;F<16;F++)b[F]=-X[F];return U.markAsUpdated(),U}equals(U){const X=U;if(!X)return!1;if((this._isIdentity||X._isIdentity)&&!this._isIdentityDirty&&!X._isIdentityDirty)return this._isIdentity&&X._isIdentity;const b=this.m,F=X.m;return b[0]===F[0]&&b[1]===F[1]&&b[2]===F[2]&&b[3]===F[3]&&b[4]===F[4]&&b[5]===F[5]&&b[6]===F[6]&&b[7]===F[7]&&b[8]===F[8]&&b[9]===F[9]&&b[10]===F[10]&&b[11]===F[11]&&b[12]===F[12]&&b[13]===F[13]&&b[14]===F[14]&&b[15]===F[15]}equalsWithEpsilon(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=this.zb,F=U.m;for(let E=0;E<16;E++)if(!(0,q.WithinEpsilon)(b[E],F[E],X))return!1;return!0}equalsToFloats(){const U=this.zb;for(let X=0;X<16;X++)if(U[X]!=(X<0||arguments.length<=X?void 0:arguments[X]))return!1;return!0}floor(){return this.floorToRef(new O)}floorToRef(U){const X=this.zb,b=U.zb;for(let F=0;F<16;F++)b[F]=Math.floor(X[F]);return U.markAsUpdated(),U}fract(){return this.fractToRef(new O)}fractToRef(U){const X=this.zb,b=U.zb;for(let F=0;F<16;F++)b[F]=X[F]-Math.floor(X[F]);return U.markAsUpdated(),U}clone(){const U=new O;return U.q(this),U}getClassName(){return"Matrix"}getHashCode(){let U=a(this.zb[0]);for(let X=1;X<16;X++)U=397*U^a(this.zb[X]);return U}decomposeToTransformNode(U){return U.rotationQuaternion=U.rotationQuaternion||new I,this.decompose(U.fb,U.rotationQuaternion,U.position)}decompose(U,X,b,F){let E=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return b&&b.jb(0),U&&U.jb(1),X&&X.Pb(0,0,0,1),!0;const w=this.zb;if(b&&b.Pb(w[12],w[13],w[14]),(U=U||N.JX[0]).x=Math.sqrt(w[0]*w[0]+w[1]*w[1]+w[2]*w[2]),U.y=Math.sqrt(w[4]*w[4]+w[5]*w[5]+w[6]*w[6]),U.z=Math.sqrt(w[8]*w[8]+w[9]*w[9]+w[10]*w[10]),F){const X=(E?F.absoluteScaling.x:F.fb.x)<0?-1:1,b=(E?F.absoluteScaling.y:F.fb.y)<0?-1:1,w=(E?F.absoluteScaling.z:F.fb.z)<0?-1:1;U.x*=X,U.y*=b,U.z*=w}else this.determinant()<=0&&(U.y*=-1);if(0===U._x||0===U._y||0===U._z)return X&&X.Pb(0,0,0,1),!1;if(X){const b=1/U._x,F=1/U._y,E=1/U._z;O.FromValuesToRef(w[0]*b,w[1]*b,w[2]*b,0,w[4]*F,w[5]*F,w[6]*F,0,w[8]*E,w[9]*E,w[10]*E,0,0,0,0,1,N.Matrix[0]),I.FromRotationMatrixToRef(N.Matrix[0],X)}return!0}getRow(U){if(U<0||U>3)return null;const X=4*U;return new x(this.zb[X+0],this.zb[X+1],this.zb[X+2],this.zb[X+3])}getRowToRef(U,X){if(U>=0&&U<=3){const b=4*U;X.x=this.zb[b+0],X.y=this.zb[b+1],X.z=this.zb[b+2],X.w=this.zb[b+3]}return X}setRow(U,X){return this.setRowFromFloats(U,X.x,X.y,X.z,X.w)}transpose(){const U=new O;return O.TransposeToRef(this,U),U}transposeToRef(U){return O.TransposeToRef(this,U),U}setRowFromFloats(U,X,b,F,E){if(U<0||U>3)return this;const w=4*U;return this.zb[w+0]=X,this.zb[w+1]=b,this.zb[w+2]=F,this.zb[w+3]=E,this.markAsUpdated(),this}scale(U){const X=new O;return this.scaleToRef(U,X),X}scaleToRef(U,X){for(let b=0;b<16;b++)X.zb[b]=this.zb[b]*U;return X.markAsUpdated(),X}scaleAndAddToRef(U,X){for(let b=0;b<16;b++)X.zb[b]+=this.zb[b]*U;return X.markAsUpdated(),X}scaleInPlace(U){const X=this.zb;for(let b=0;b<16;b++)X[b]*=U;return this.markAsUpdated(),this}toNormalMatrix(U){const X=N.Matrix[0];this.invertToRef(X),X.transposeToRef(U);const b=U.zb;return O.FromValuesToRef(b[0],b[1],b[2],0,b[4],b[5],b[6],0,b[8],b[9],b[10],0,0,0,0,1,U),U}getRotationMatrix(){const U=new O;return this.getRotationMatrixToRef(U),U}getRotationMatrixToRef(U){const X=N.JX[0];if(!this.decompose(X))return O.IdentityToRef(U),U;const b=this.zb,F=1/X._x,E=1/X._y,w=1/X._z;return O.FromValuesToRef(b[0]*F,b[1]*F,b[2]*F,0,b[4]*E,b[5]*E,b[6]*E,0,b[8]*w,b[9]*w,b[10]*w,0,0,0,0,1,U),U}toggleModelMatrixHandInPlace(){const U=this.zb;return U[2]*=-1,U[6]*=-1,U[8]*=-1,U[9]*=-1,U[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const U=this.zb;return U[8]*=-1,U[9]*=-1,U[10]*=-1,U[11]*=-1,this.markAsUpdated(),this}static uX(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=new O;return O.FromArrayToRef(U,X,b),b}static FromArrayToRef(U,X,b){for(let F=0;F<16;F++)b.zb[F]=U[F+X];return b.markAsUpdated(),b}static FromFloat32ArrayToRefScaled(U,X,b,F){return F.zb[0]=U[0+X]*b,F.zb[1]=U[1+X]*b,F.zb[2]=U[2+X]*b,F.zb[3]=U[3+X]*b,F.zb[4]=U[4+X]*b,F.zb[5]=U[5+X]*b,F.zb[6]=U[6+X]*b,F.zb[7]=U[7+X]*b,F.zb[8]=U[8+X]*b,F.zb[9]=U[9+X]*b,F.zb[10]=U[10+X]*b,F.zb[11]=U[11+X]*b,F.zb[12]=U[12+X]*b,F.zb[13]=U[13+X]*b,F.zb[14]=U[14+X]*b,F.zb[15]=U[15+X]*b,F.markAsUpdated(),F}static get IdentityReadOnly(){return O._IdentityReadOnly}static FromValuesToRef(U,X,b,F,E,w,Q,z,q,p,S,R,n,a,J,m,x){const I=x.zb;I[0]=U,I[1]=X,I[2]=b,I[3]=F,I[4]=E,I[5]=w,I[6]=Q,I[7]=z,I[8]=q,I[9]=p,I[10]=S,I[11]=R,I[12]=n,I[13]=a,I[14]=J,I[15]=m,x.markAsUpdated()}static FromValues(U,X,b,F,E,w,Q,z,q,p,S,R,n,a,J,m){const x=new O,I=x.zb;return I[0]=U,I[1]=X,I[2]=b,I[3]=F,I[4]=E,I[5]=w,I[6]=Q,I[7]=z,I[8]=q,I[9]=p,I[10]=S,I[11]=R,I[12]=n,I[13]=a,I[14]=J,I[15]=m,x.markAsUpdated(),x}static Compose(U,X,b){const F=new O;return O.ComposeToRef(U,X,b,F),F}static ComposeToRef(U,X,b,F){const E=F.zb,w=X._x,Q=X._y,z=X._z,q=X._w,p=w+w,S=Q+Q,R=z+z,n=w*p,a=w*S,J=w*R,m=Q*S,x=Q*R,I=z*R,O=q*p,N=q*S,u=q*R,i=U._x,P=U._y,f=U._z;return E[0]=(1-(m+I))*i,E[1]=(a+u)*i,E[2]=(J-N)*i,E[3]=0,E[4]=(a-u)*P,E[5]=(1-(n+I))*P,E[6]=(x+O)*P,E[7]=0,E[8]=(J+N)*f,E[9]=(x-O)*f,E[10]=(1-(n+m))*f,E[11]=0,E[12]=b._x,E[13]=b._y,E[14]=b._z,E[15]=1,F.markAsUpdated(),F}static Identity(){const U=O.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return U._updateIdentityStatus(!0),U}static IdentityToRef(U){return O.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,U),U._updateIdentityStatus(!0),U}static Zero(){const U=O.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return U._updateIdentityStatus(!1),U}static RotationX(U){const X=new O;return O.RotationXToRef(U,X),X}static Invert(U){const X=new O;return U.invertToRef(X),X}static RotationXToRef(U,X){const b=Math.sin(U),F=Math.cos(U);return O.FromValuesToRef(1,0,0,0,0,F,b,0,0,-b,F,0,0,0,0,1,X),X._updateIdentityStatus(1===F&&0===b),X}static RotationY(U){const X=new O;return O.RotationYToRef(U,X),X}static RotationYToRef(U,X){const b=Math.sin(U),F=Math.cos(U);return O.FromValuesToRef(F,0,-b,0,0,1,0,0,b,0,F,0,0,0,0,1,X),X._updateIdentityStatus(1===F&&0===b),X}static RotationZ(U){const X=new O;return O.RotationZToRef(U,X),X}static RotationZToRef(U,X){const b=Math.sin(U),F=Math.cos(U);return O.FromValuesToRef(F,b,0,0,-b,F,0,0,0,0,1,0,0,0,0,1,X),X._updateIdentityStatus(1===F&&0===b),X}static RotationAxis(U,X){const b=new O;return O.RotationAxisToRef(U,X,b),b}static RotationAxisToRef(U,X,b){const F=Math.sin(-X),E=Math.cos(-X),w=1-E;U=U.normalizeToRef(N.JX[0]);const Q=b.zb;return Q[0]=U._x*U._x*w+E,Q[1]=U._x*U._y*w-U._z*F,Q[2]=U._x*U._z*w+U._y*F,Q[3]=0,Q[4]=U._y*U._x*w+U._z*F,Q[5]=U._y*U._y*w+E,Q[6]=U._y*U._z*w-U._x*F,Q[7]=0,Q[8]=U._z*U._x*w-U._y*F,Q[9]=U._z*U._y*w+U._x*F,Q[10]=U._z*U._z*w+E,Q[11]=0,Q[12]=0,Q[13]=0,Q[14]=0,Q[15]=1,b.markAsUpdated(),b}static RotationAlignToRef(U,X,b){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const w=m.Dot(X,U),Q=b.zb;if(w<-1+F.d)Q[0]=-1,Q[1]=0,Q[2]=0,Q[3]=0,Q[4]=0,Q[5]=E?1:-1,Q[6]=0,Q[7]=0,Q[8]=0,Q[9]=0,Q[10]=E?-1:1,Q[11]=0;else{const b=m.Cross(X,U),F=1/(1+w);Q[0]=b._x*b._x*F+w,Q[1]=b._y*b._x*F-b._z,Q[2]=b._z*b._x*F+b._y,Q[3]=0,Q[4]=b._x*b._y*F+b._z,Q[5]=b._y*b._y*F+w,Q[6]=b._z*b._y*F-b._x,Q[7]=0,Q[8]=b._x*b._z*F-b._y,Q[9]=b._y*b._z*F+b._x,Q[10]=b._z*b._z*F+w,Q[11]=0}return Q[12]=0,Q[13]=0,Q[14]=0,Q[15]=1,b.markAsUpdated(),b}static RotationYawPitchRoll(U,X,b){const F=new O;return O.RotationYawPitchRollToRef(U,X,b,F),F}static RotationYawPitchRollToRef(U,X,b,F){return I.RotationYawPitchRollToRef(U,X,b,N.Quaternion[0]),N.Quaternion[0].toRotationMatrix(F),F}static Scaling(U,X,b){const F=new O;return O.ScalingToRef(U,X,b,F),F}static ScalingToRef(U,X,b,F){return O.FromValuesToRef(U,0,0,0,0,X,0,0,0,0,b,0,0,0,0,1,F),F._updateIdentityStatus(1===U&&1===X&&1===b),F}static Translation(U,X,b){const F=new O;return O.TranslationToRef(U,X,b,F),F}static TranslationToRef(U,X,b,F){return O.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,U,X,b,1,F),F._updateIdentityStatus(0===U&&0===X&&0===b),F}static Lerp(U,X,b){const F=new O;return O.LerpToRef(U,X,b,F),F}static LerpToRef(U,X,b,F){const E=F.zb,w=U.m,Q=X.m;for(let z=0;z<16;z++)E[z]=w[z]*(1-b)+Q[z]*b;return F.markAsUpdated(),F}static DecomposeLerp(U,X,b){const F=new O;return O.DecomposeLerpToRef(U,X,b,F),F}static DecomposeLerpToRef(U,X,b,F){const E=N.JX[0],w=N.Quaternion[0],Q=N.JX[1];U.decompose(E,w,Q);const z=N.JX[2],q=N.Quaternion[1],p=N.JX[3];X.decompose(z,q,p);const S=N.JX[4];m.LerpToRef(E,z,b,S);const R=N.Quaternion[2];I.SlerpToRef(w,q,b,R);const n=N.JX[5];return m.LerpToRef(Q,p,b,n),O.ComposeToRef(S,R,n,F),F}static LookAtLH(U,X,b){const F=new O;return O.LookAtLHToRef(U,X,b,F),F}static LookAtLHToRef(U,X,b,F){const E=N.JX[0],w=N.JX[1],Q=N.JX[2];X.subtractToRef(U,Q),Q.normalize(),m.CrossToRef(b,Q,E);const z=E.lengthSquared();0===z?E.x=1:E.normalizeFromLength(Math.sqrt(z)),m.CrossToRef(Q,E,w),w.normalize();const q=-m.Dot(E,U),p=-m.Dot(w,U),S=-m.Dot(Q,U);return O.FromValuesToRef(E._x,w._x,Q._x,0,E._y,w._y,Q._y,0,E._z,w._z,Q._z,0,q,p,S,1,F),F}static LookAtRH(U,X,b){const F=new O;return O.LookAtRHToRef(U,X,b,F),F}static LookAtRHToRef(U,X,b,F){const E=N.JX[0],w=N.JX[1],Q=N.JX[2];U.subtractToRef(X,Q),Q.normalize(),m.CrossToRef(b,Q,E);const z=E.lengthSquared();0===z?E.x=1:E.normalizeFromLength(Math.sqrt(z)),m.CrossToRef(Q,E,w),w.normalize();const q=-m.Dot(E,U),p=-m.Dot(w,U),S=-m.Dot(Q,U);return O.FromValuesToRef(E._x,w._x,Q._x,0,E._y,w._y,Q._y,0,E._z,w._z,Q._z,0,q,p,S,1,F),F}static LookDirectionLH(U,X){const b=new O;return O.LookDirectionLHToRef(U,X,b),b}static LookDirectionLHToRef(U,X,b){const F=N.JX[0];F.q(U),F.scaleInPlace(-1);const E=N.JX[1];return m.CrossToRef(X,F,E),O.FromValuesToRef(E._x,E._y,E._z,0,X._x,X._y,X._z,0,F._x,F._y,F._z,0,0,0,0,1,b),b}static LookDirectionRH(U,X){const b=new O;return O.LookDirectionRHToRef(U,X,b),b}static LookDirectionRHToRef(U,X,b){const F=N.JX[2];return m.CrossToRef(X,U,F),O.FromValuesToRef(F._x,F._y,F._z,0,X._x,X._y,X._z,0,U._x,U._y,U._z,0,0,0,0,1,b),b}static OrthoLH(U,X,b,F,E){const w=new O;return O.OrthoLHToRef(U,X,b,F,w,E),w}static OrthoLHToRef(U,X,b,F,E,w){const Q=2/U,z=2/X,q=2/(F-b),p=-(F+b)/(F-b);return O.FromValuesToRef(Q,0,0,0,0,z,0,0,0,0,q,0,0,0,p,1,E),w&&E.multiplyToRef(i,E),E._updateIdentityStatus(1===Q&&1===z&&1===q&&0===p),E}static OrthoOffCenterLH(U,X,b,F,E,w,Q){const z=new O;return O.OrthoOffCenterLHToRef(U,X,b,F,E,w,z,Q),z}static OrthoOffCenterLHToRef(U,X,b,F,E,w,Q,z){const q=2/(X-U),p=2/(F-b),S=2/(w-E),R=-(w+E)/(w-E),n=(U+X)/(U-X),a=(F+b)/(b-F);return O.FromValuesToRef(q,0,0,0,0,p,0,0,0,0,S,0,n,a,R,1,Q),z&&Q.multiplyToRef(i,Q),Q.markAsUpdated(),Q}static ObliqueOffCenterLHToRef(U,X,b,F,E,w,Q,z,q,p,S){const R=-Q*Math.cos(z),n=-Q*Math.sin(z);return O.TranslationToRef(0,0,-q,N.Matrix[1]),O.FromValuesToRef(1,0,0,0,0,1,0,0,R,n,1,0,0,0,0,1,N.Matrix[0]),N.Matrix[1].multiplyToRef(N.Matrix[0],N.Matrix[0]),O.TranslationToRef(0,0,q,N.Matrix[1]),N.Matrix[0].multiplyToRef(N.Matrix[1],N.Matrix[0]),O.OrthoOffCenterLHToRef(U,X,b,F,E,w,p,S),N.Matrix[0].multiplyToRef(p,p),p}static OrthoOffCenterRH(U,X,b,F,E,w,Q){const z=new O;return O.OrthoOffCenterRHToRef(U,X,b,F,E,w,z,Q),z}static OrthoOffCenterRHToRef(U,X,b,F,E,w,Q,z){return O.OrthoOffCenterLHToRef(U,X,b,F,E,w,Q,z),Q.zb[10]*=-1,Q}static ObliqueOffCenterRHToRef(U,X,b,F,E,w,Q,z,q,p,S){const R=Q*Math.cos(z),n=Q*Math.sin(z);return O.TranslationToRef(0,0,q,N.Matrix[1]),O.FromValuesToRef(1,0,0,0,0,1,0,0,R,n,1,0,0,0,0,1,N.Matrix[0]),N.Matrix[1].multiplyToRef(N.Matrix[0],N.Matrix[0]),O.TranslationToRef(0,0,-q,N.Matrix[1]),N.Matrix[0].multiplyToRef(N.Matrix[1],N.Matrix[0]),O.OrthoOffCenterRHToRef(U,X,b,F,E,w,p,S),N.Matrix[0].multiplyToRef(p,p),p}static PerspectiveLH(U,X,b,F,E){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const Q=new O,z=2*b/U,q=2*b/X,p=(F+b)/(F-b),S=-2*F*b/(F-b),R=Math.tan(w);return O.FromValuesToRef(z,0,0,0,0,q,0,R,0,0,p,1,0,0,S,0,Q),E&&Q.multiplyToRef(i,Q),Q._updateIdentityStatus(!1),Q}static PerspectiveFovLH(U,X,b,F,E){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const z=new O;return O.PerspectiveFovLHToRef(U,X,b,F,z,!0,E,w,Q),z}static PerspectiveFovLHToRef(U,X,b,F,E){let w=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,z=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,q=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const p=b,S=F,R=1/Math.tan(.5*U),n=w?R/X:R,a=w?R:R*X,J=q&&0===p?-1:0!==S?(S+p)/(S-p):1,m=q&&0===p?2*S:0!==S?-2*S*p/(S-p):-2*p,x=Math.tan(z);return O.FromValuesToRef(n,0,0,0,0,a,0,x,0,0,J,1,0,0,m,0,E),Q&&E.multiplyToRef(i,E),E._updateIdentityStatus(!1),E}static PerspectiveFovReverseLHToRef(U,X,b,F,E){let w=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,z=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const q=1/Math.tan(.5*U),p=w?q/X:q,S=w?q:q*X,R=Math.tan(z);return O.FromValuesToRef(p,0,0,0,0,S,0,R,0,0,-b,1,0,0,1,0,E),Q&&E.multiplyToRef(i,E),E._updateIdentityStatus(!1),E}static PerspectiveFovRH(U,X,b,F,E){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const z=new O;return O.PerspectiveFovRHToRef(U,X,b,F,z,!0,E,w,Q),z}static PerspectiveFovRHToRef(U,X,b,F,E){let w=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,z=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,q=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const p=b,S=F,R=1/Math.tan(.5*U),n=w?R/X:R,a=w?R:R*X,J=q&&0===p?1:0!==S?-(S+p)/(S-p):-1,m=q&&0===p?2*S:0!==S?-2*S*p/(S-p):-2*p,x=Math.tan(z);return O.FromValuesToRef(n,0,0,0,0,a,0,x,0,0,J,-1,0,0,m,0,E),Q&&E.multiplyToRef(i,E),E._updateIdentityStatus(!1),E}static PerspectiveFovReverseRHToRef(U,X,b,F,E){let w=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,z=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const q=1/Math.tan(.5*U),p=w?q/X:q,S=w?q:q*X,R=Math.tan(z);return O.FromValuesToRef(p,0,0,0,0,S,0,R,0,0,-b,-1,0,0,-1,0,E),Q&&E.multiplyToRef(i,E),E._updateIdentityStatus(!1),E}static GetFinalMatrix(U,X,b,F,E,w){const Q=U.width,z=U.height,q=U.x,p=U.y,S=O.FromValues(Q/2,0,0,0,0,-z/2,0,0,0,0,w-E,0,q+Q/2,z/2+p,E,1),R=new O;return X.multiplyToRef(b,R),R.multiplyToRef(F,R),R.multiplyToRef(S,R)}static GetAsMatrix2x2(U){const X=U.m,b=[X[0],X[1],X[4],X[5]];return Q.e.MatrixUse64Bits?b:new Float32Array(b)}static GetAsMatrix3x3(U){const X=U.m,b=[X[0],X[1],X[2],X[4],X[5],X[6],X[8],X[9],X[10]];return Q.e.MatrixUse64Bits?b:new Float32Array(b)}static Transpose(U){const X=new O;return O.TransposeToRef(U,X),X}static TransposeToRef(U,X){const b=U.m,F=b[0],E=b[4],w=b[8],Q=b[12],z=b[1],q=b[5],p=b[9],S=b[13],R=b[2],n=b[6],a=b[10],J=b[14],m=b[3],x=b[7],I=b[11],O=b[15],N=X.zb;return N[0]=F,N[1]=E,N[2]=w,N[3]=Q,N[4]=z,N[5]=q,N[6]=p,N[7]=S,N[8]=R,N[9]=n,N[10]=a,N[11]=J,N[12]=m,N[13]=x,N[14]=I,N[15]=O,X.markAsUpdated(),X._updateIdentityStatus(U._isIdentity,U._isIdentityDirty),X}static Reflection(U){const X=new O;return O.ReflectionToRef(U,X),X}static ReflectionToRef(U,X){U.normalize();const b=U.normal.x,F=U.normal.y,E=U.normal.z,w=-2*b,Q=-2*F,z=-2*E;return O.FromValuesToRef(w*b+1,Q*b,z*b,0,w*F,Q*F+1,z*F,0,w*E,Q*E,z*E+1,0,w*U.d,Q*U.d,z*U.d,1,X),X}static FromXYZAxesToRef(U,X,b,F){return O.FromValuesToRef(U._x,U._y,U._z,0,X._x,X._y,X._z,0,b._x,b._y,b._z,0,0,0,0,1,F),F}static FromQuaternionToRef(U,X){const b=U._x*U._x,F=U._y*U._y,E=U._z*U._z,w=U._x*U._y,Q=U._z*U._w,z=U._z*U._x,q=U._y*U._w,p=U._y*U._z,S=U._x*U._w;return X.zb[0]=1-2*(F+E),X.zb[1]=2*(w+Q),X.zb[2]=2*(z-q),X.zb[3]=0,X.zb[4]=2*(w-Q),X.zb[5]=1-2*(E+b),X.zb[6]=2*(p+S),X.zb[7]=0,X.zb[8]=2*(z+q),X.zb[9]=2*(p-S),X.zb[10]=1-2*(F+b),X.zb[11]=0,X.zb[12]=0,X.zb[13]=0,X.zb[14]=0,X.zb[15]=1,X.markAsUpdated(),X}}O._IdentityReadOnly=O.Identity(),Object.defineProperties(O.prototype,{dimension:{value:[4,4]},rank:{value:2}});class N{}N.JX=(0,E.g)(11,m.Zero),N.Matrix=(0,E.g)(2,O.Identity),N.Quaternion=(0,E.g)(3,I.Zero);class u{}u.Vector2=(0,E.g)(3,J.Zero),u.JX=(0,E.g)(13,m.Zero),u.Vector4=(0,E.g)(3,x.Zero),u.Quaternion=(0,E.g)(3,I.Zero),u.Matrix=(0,E.g)(8,O.Identity),(0,w.f)("BABYLON.Vector2",J),(0,w.f)("BABYLON.Vector3",m),(0,w.f)("BABYLON.Vector4",x),(0,w.f)("BABYLON.Matrix",O);const i=O.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11600:(U,X,b)=>{function F(U,X){const b=[];for(let F=0;F<U;++F)b.push(X());return b}function E(U,X){return F(U,X)}b.d(X,{e:()=>F,g:()=>E,i:()=>Q});const w=["push","splice","pop","shift","unshift"];function Q(U,X){const b=w.map((b=>function(U,X,b){const F=U[X];if("function"!==typeof F)return null;const E=function(){const F=U.length,w=E.previous.apply(U,arguments);return b(X,F),w};return F.next=E,E.previous=F,U[X]=E,()=>{const b=E.previous;if(!b)return;const F=E.next;F?(b.next=F,F.previous=b):(b.next=void 0,U[X]=b),E.next=void 0,E.previous=void 0}}(U,b,X)));return()=>{for(const U of b)null===U||void 0===U||U()}}}}]);