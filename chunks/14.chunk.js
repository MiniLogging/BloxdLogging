"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{11187:(P,f,Y)=>{Y.d(f,{c:()=>L,g:()=>m,i:()=>C,k:()=>q});const C=1/2.2,q=2.2,m=(1+Math.sqrt(5))/2,L=.001},11198:(P,f,Y)=>{function C(P){return parseInt(P.toString().replace(/\W/g,""))}function q(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(P-f)<=Y}function m(P,f,Y){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return P<f-C||P>Y+C}function L(P,f){return P===f?P:Math.random()*(f-P)+P}function o(P,f,Y){return P+(f-P)*Y}function w(P,f,Y){let C=S(f-P,360);return C>180&&(C-=360),P+C*r(Y)}function d(P,f,Y){let C=0;return C=P!=f?r((Y-P)/(f-P)):0,C}function R(P,f,Y,C,q){const m=q*q,L=q*m;return P*(2*L-3*m+1)+Y*(-2*L+3*m)+f*(L-2*m+q)+C*(L-m)}function y(P,f,Y,C,q){const m=q*q;return 6*(m-q)*P+(3*m-4*q+1)*f+6*(-m+q)*Y+(3*m-2*q)*C}function r(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(Y,Math.max(f,P))}function i(P){return P-=2*Math.PI*Math.floor((P+Math.PI)/(2*Math.PI))}function u(P){const f=P.toString(16);return P<=15?("0"+f).toUpperCase():f.toUpperCase()}function g(P){if(Math.log2)return Math.floor(Math.log2(P));if(P<0)return NaN;if(0===P)return-1/0;let f=0;if(P<1){for(;P<1;)f++,P*=2;f=-f}else if(P>1)for(;P>1;)f++,P=Math.floor(P/2);return f}function S(P,f){return P-Math.floor(P/f)*f}function K(P,f,Y){return(P-f)/(Y-f)}function M(P,f,Y){return P*(Y-f)+f}function V(P,f){let Y=S(f-P,360);return Y>180&&(Y-=360),Y}function O(P,f){const Y=S(P,2*f);return f-Math.abs(Y-f)}function n(P,f,Y){let C=r(Y);return C=-2*C*C*C+3*C*C,f*C+P*(1-C)}function l(P,f,Y){let C=0;return C=Math.abs(f-P)<=Y?f:P+Math.sign(f-P)*Y,C}function v(P,f,Y){const C=V(P,f);let q=0;return q=-Y<C&&C<Y?f:l(P,f=P+C,Y),q}function c(P,f,Y){return(P-f)/(Y-f)}function T(P,f,Y){return(Y-f)*P+f}function U(P,f){const Y=P%f;return 0===Y?f:U(f,Y)}Y.r(f),Y.d(f,{Clamp:()=>r,DeltaAngle:()=>V,Denormalize:()=>M,ExtractAsInt:()=>C,Hermite:()=>R,Hermite1stDerivative:()=>y,HighestCommonFactor:()=>U,ILog2:()=>g,InverseLerp:()=>d,Lerp:()=>o,LerpAngle:()=>w,MoveTowards:()=>l,MoveTowardsAngle:()=>v,Normalize:()=>K,NormalizeRadians:()=>i,OutsideRange:()=>m,PercentToRange:()=>T,PingPong:()=>O,RandomRange:()=>L,RangeToPercent:()=>c,Repeat:()=>S,SmoothStep:()=>n,ToHex:()=>u,WithinEpsilon:()=>q})},11179:(P,f,Y)=>{Y.r(f),Y.d(f,{Matrix:()=>M,Quaternion:()=>K,TmpVectors:()=>O,Vector2:()=>u,Of:()=>g,Vector4:()=>S});var C=Y(11187),q=Y(11196),m=Y(11134),L=Y(11112),o=Y(11052),w=Y(11198);class d{}function R(P,f,Y){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const q=P.If(),m=f.If(),L=q[0],o=q[1],w=q[2],d=q[3],R=q[4],y=q[5],r=q[6],i=q[7],u=q[8],g=q[9],S=q[10],K=q[11],M=q[12],V=q[13],O=q[14],n=q[15],l=m[0],v=m[1],c=m[2],T=m[3],U=m[4],D=m[5],j=m[6],e=m[7],s=m[8],a=m[9],Q=m[10],J=m[11],N=m[12],I=m[13],X=m[14],x=m[15];Y[C]=L*l+o*U+w*s+d*N,Y[C+1]=L*v+o*D+w*a+d*I,Y[C+2]=L*c+o*j+w*Q+d*X,Y[C+3]=L*T+o*e+w*J+d*x,Y[C+4]=R*l+y*U+r*s+i*N,Y[C+5]=R*v+y*D+r*a+i*I,Y[C+6]=R*c+y*j+r*Q+i*X,Y[C+7]=R*T+y*e+r*J+i*x,Y[C+8]=u*l+g*U+S*s+K*N,Y[C+9]=u*v+g*D+S*a+K*I,Y[C+10]=u*c+g*j+S*Q+K*X,Y[C+11]=u*T+g*e+S*J+K*x,Y[C+12]=M*l+V*U+O*s+n*N,Y[C+13]=M*v+V*D+O*a+n*I,Y[C+14]=M*c+V*j+O*Q+n*X,Y[C+15]=M*T+V*e+O*J+n*x}function y(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const C=P.If();f[Y]=C[0],f[Y+1]=C[1],f[Y+2]=C[2],f[Y+3]=C[3],f[Y+4]=C[4],f[Y+5]=C[5],f[Y+6]=C[6],f[Y+7]=C[7],f[Y+8]=C[8],f[Y+9]=C[9],f[Y+10]=C[10],f[Y+11]=C[11],f[Y+12]=C[12],f[Y+13]=C[13],f[Y+14]=C[14],f[Y+15]=C[15]}function r(P,f){const Y=P.If(),C=Y[0],q=Y[1],m=Y[2],L=Y[3],o=Y[4],w=Y[5],d=Y[6],R=Y[7],y=Y[8],r=Y[9],i=Y[10],u=Y[11],g=Y[12],S=Y[13],K=Y[14],M=Y[15],V=i*M-K*u,O=r*M-S*u,n=r*K-S*i,l=y*M-g*u,v=y*K-i*g,c=y*S-g*r,T=+(w*V-d*O+R*n),U=-(o*V-d*l+R*v),D=+(o*O-w*l+R*c),j=-(o*n-w*v+d*c),e=C*T+q*U+m*D+L*j;if(0===e)return!1;const s=1/e,a=d*M-K*R,Q=w*M-S*R,J=w*K-S*d,N=o*M-g*R,I=o*K-g*d,X=o*S-g*w,x=d*u-i*R,k=w*u-r*R,Z=w*i-r*d,A=o*u-y*R,E=o*i-y*d,t=o*r-y*w,G=-(q*V-m*O+L*n),z=+(C*V-m*l+L*v),B=-(C*O-q*l+L*c),b=+(C*n-q*v+m*c),H=+(q*a-m*Q+L*J),W=-(C*a-m*N+L*I),p=+(C*Q-q*N+L*X),h=-(C*J-q*I+m*X),F=-(q*x-m*k+L*Z),PP=+(C*x-m*A+L*E),fP=-(C*k-q*A+L*t),YP=+(C*Z-q*E+m*t);return f[0]=T*s,f[1]=G*s,f[2]=H*s,f[3]=F*s,f[4]=U*s,f[5]=z*s,f[6]=W*s,f[7]=PP*s,f[8]=D*s,f[9]=B*s,f[10]=p*s,f[11]=fP*s,f[12]=j*s,f[13]=b*s,f[14]=h*s,f[15]=YP*s,!0}d._UpdateFlagSeed=0;const i=P=>parseInt(P.toString().replace(/\W/g,""));class u{constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=P,this.y=f}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let P=i(this.x);return P=397*P^i(this.y),P}toArray(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[f]=this.x,P[f+1]=this.y,this}jY(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(P,f,this),this}If(){return[this.x,this.y]}q(P){return this.x=P.x,this.y=P.y,this}do(P,f){return this.x=P,this.y=f,this}set(P,f){return this.do(P,f)}yo(P){return this.do(P,P)}add(P){return new u(this.x+P.x,this.y+P.y)}addToRef(P,f){return f.x=this.x+P.x,f.y=this.y+P.y,f}addInPlace(P){return this.x+=P.x,this.y+=P.y,this}addInPlaceFromFloats(P,f){return this.x+=P,this.y+=f,this}addVector3(P){return new u(this.x+P.x,this.y+P.y)}nf(P){return new u(this.x-P.x,this.y-P.y)}subtractToRef(P,f){return f.x=this.x-P.x,f.y=this.y-P.y,f}Ly(P){return this.x-=P.x,this.y-=P.y,this}multiplyInPlace(P){return this.x*=P.x,this.y*=P.y,this}multiply(P){return new u(this.x*P.x,this.y*P.y)}multiplyToRef(P,f){return f.x=this.x*P.x,f.y=this.y*P.y,f}multiplyByFloats(P,f){return new u(this.x*P,this.y*f)}divide(P){return new u(this.x/P.x,this.y/P.y)}divideToRef(P,f){return f.x=this.x/P.x,f.y=this.y/P.y,f}divideInPlace(P){return this.x=this.x/P.x,this.y=this.y/P.y,this}minimizeInPlace(P){return this.minimizeInPlaceFromFloats(P.x,P.y)}maximizeInPlace(P){return this.maximizeInPlaceFromFloats(P.x,P.y)}minimizeInPlaceFromFloats(P,f){return this.x=Math.min(P,this.x),this.y=Math.min(f,this.y),this}maximizeInPlaceFromFloats(P,f){return this.x=Math.max(P,this.x),this.y=Math.max(f,this.y),this}subtractFromFloats(P,f){return new u(this.x-P,this.y-f)}subtractFromFloatsToRef(P,f,Y){return Y.x=this.x-P,Y.y=this.y-f,Y}negate(){return new u(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(P){return P.x=-this.x,P.y=-this.y,P}scaleInPlace(P){return this.x*=P,this.y*=P,this}scale(P){return new u(this.x*P,this.y*P)}scaleToRef(P,f){return f.x=this.x*P,f.y=this.y*P,f}scaleAndAddToRef(P,f){return f.x+=this.x*P,f.y+=this.y*P,f}equals(P){return P&&this.x===P.x&&this.y===P.y}equalsWithEpsilon(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.c;return P&&(0,w.WithinEpsilon)(this.x,P.x,f)&&(0,w.WithinEpsilon)(this.y,P.y,f)}equalsToFloats(P,f){return this.x===P&&this.y===f}floor(){return new u(Math.floor(this.x),Math.floor(this.y))}floorToRef(P){return P.x=Math.floor(this.x),P.y=Math.floor(this.y),P}fract(){return new u(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(P){return P.x=this.x-Math.floor(this.x),P.y=this.y-Math.floor(this.y),P}rotate(P){return this.rotateToRef(P,new u)}rotateToRef(P,f){const Y=Math.cos(P),C=Math.sin(P);return f.x=Y*this.x-C*this.y,f.y=C*this.x+Y*this.y,f}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){const P=new u;return this.normalizeToRef(P),P}normalizeToRef(P){const f=this.length();return 0===f&&(P.x=this.x,P.y=this.y),this.scaleToRef(1/f,P)}clone(){return new u(this.x,this.y)}dot(P){return this.x*P.x+this.y*P.y}static Zero(){return new u(0,0)}static One(){return new u(1,1)}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new u((0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).do((0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f))}static get ZeroReadOnly(){return u._ZeroReadOnly}static ef(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new u(P[f],P[f+1])}static FromArrayToRef(P,f,Y){return Y.x=P[f],Y.y=P[f+1],Y}static FromFloatsToRef(P,f,Y){return Y.do(P,f),Y}static CatmullRom(P,f,Y,C,q){const m=q*q,L=q*m,o=.5*(2*f.x+(-P.x+Y.x)*q+(2*P.x-5*f.x+4*Y.x-C.x)*m+(-P.x+3*f.x-3*Y.x+C.x)*L),w=.5*(2*f.y+(-P.y+Y.y)*q+(2*P.y-5*f.y+4*Y.y-C.y)*m+(-P.y+3*f.y-3*Y.y+C.y)*L);return new u(o,w)}static ClampToRef(P,f,Y,C){return C.x=(0,w.Clamp)(P.x,f.x,Y.x),C.y=(0,w.Clamp)(P.y,f.y,Y.y),C}static Clamp(P,f,Y){const C=(0,w.Clamp)(P.x,f.x,Y.x),q=(0,w.Clamp)(P.y,f.y,Y.y);return new u(C,q)}static Hermite(P,f,Y,C,q){const m=q*q,L=q*m,o=2*L-3*m+1,w=-2*L+3*m,d=L-2*m+q,R=L-m,y=P.x*o+Y.x*w+f.x*d+C.x*R,r=P.y*o+Y.y*w+f.y*d+C.y*R;return new u(y,r)}static Hermite1stDerivative(P,f,Y,C,q){return this.Hermite1stDerivativeToRef(P,f,Y,C,q,new u)}static Hermite1stDerivativeToRef(P,f,Y,C,q,m){const L=q*q;return m.x=6*(L-q)*P.x+(3*L-4*q+1)*f.x+6*(-L+q)*Y.x+(3*L-2*q)*C.x,m.y=6*(L-q)*P.y+(3*L-4*q+1)*f.y+6*(-L+q)*Y.y+(3*L-2*q)*C.y,m}static Lerp(P,f,Y){return u.LerpToRef(P,f,Y,new u)}static LerpToRef(P,f,Y,C){return C.x=P.x+(f.x-P.x)*Y,C.y=P.y+(f.y-P.y)*Y,C}static Dot(P,f){return P.x*f.x+P.y*f.y}static Normalize(P){return u.NormalizeToRef(P,new u)}static NormalizeToRef(P,f){return P.normalizeToRef(f),f}static Minimize(P,f){const Y=P.x<f.x?P.x:f.x,C=P.y<f.y?P.y:f.y;return new u(Y,C)}static Maximize(P,f){const Y=P.x>f.x?P.x:f.x,C=P.y>f.y?P.y:f.y;return new u(Y,C)}static Transform(P,f){return u.TransformToRef(P,f,new u)}static TransformToRef(P,f,Y){const C=f.m,q=P.x*C[0]+P.y*C[4]+C[12],m=P.x*C[1]+P.y*C[5]+C[13];return Y.x=q,Y.y=m,Y}static PointInTriangle(P,f,Y,C){const q=.5*(-Y.y*C.x+f.y*(-Y.x+C.x)+f.x*(Y.y-C.y)+Y.x*C.y),m=q<0?-1:1,L=(f.y*C.x-f.x*C.y+(C.y-f.y)*P.x+(f.x-C.x)*P.y)*m,o=(f.x*Y.y-f.y*Y.x+(f.y-Y.y)*P.x+(Y.x-f.x)*P.y)*m;return L>0&&o>0&&L+o<2*q*m}static Distance(P,f){return Math.sqrt(u.DistanceSquared(P,f))}static DistanceSquared(P,f){const Y=P.x-f.x,C=P.y-f.y;return Y*Y+C*C}static Center(P,f){return u.CenterToRef(P,f,new u)}static CenterToRef(P,f,Y){return Y.do((P.x+f.x)/2,(P.y+f.y)/2)}static DistanceOfPointFromSegment(P,f,Y){const C=u.DistanceSquared(f,Y);if(0===C)return u.Distance(P,f);const q=Y.nf(f),m=Math.max(0,Math.min(1,u.Dot(P.nf(f),q)/C)),L=f.add(q.multiplyByFloats(m,m));return u.Distance(P,L)}}u._V8PerformanceHack=new u(.5,.5),u._ZeroReadOnly=u.Zero(),Object.defineProperties(u.prototype,{dimension:{value:[2]},rank:{value:1}});class g{get x(){return this._x}set x(P){this._x=P,this._isDirty=!0}get y(){return this._y}set y(P){this._y=P,this._isDirty=!0}get z(){return this._z}set z(P){this._z=P,this._isDirty=!0}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=P,this._y=f,this._z=Y}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Of"}getHashCode(){let P=i(this._x);return P=397*P^i(this._y),P=397*P^i(this._z),P}If(){return[this._x,this._y,this._z]}toArray(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[f]=this._x,P[f+1]=this._y,P[f+2]=this._z,this}jY(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g.FromArrayToRef(P,f,this),this}toQuaternion(){return K.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(P){return this._x+=P._x,this._y+=P._y,this._z+=P._z,this._isDirty=!0,this}addInPlaceFromFloats(P,f,Y){return this._x+=P,this._y+=f,this._z+=Y,this._isDirty=!0,this}add(P){return new g(this._x+P._x,this._y+P._y,this._z+P._z)}addToRef(P,f){return f._x=this._x+P._x,f._y=this._y+P._y,f._z=this._z+P._z,f._isDirty=!0,f}Ly(P){return this._x-=P._x,this._y-=P._y,this._z-=P._z,this._isDirty=!0,this}nf(P){return new g(this._x-P._x,this._y-P._y,this._z-P._z)}subtractToRef(P,f){return this.subtractFromFloatsToRef(P._x,P._y,P._z,f)}subtractFromFloats(P,f,Y){return new g(this._x-P,this._y-f,this._z-Y)}subtractFromFloatsToRef(P,f,Y,C){return C._x=this._x-P,C._y=this._y-f,C._z=this._z-Y,C._isDirty=!0,C}negate(){return new g(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(P){return P._x=-1*this._x,P._y=-1*this._y,P._z=-1*this._z,P._isDirty=!0,P}scaleInPlace(P){return this._x*=P,this._y*=P,this._z*=P,this._isDirty=!0,this}scale(P){return new g(this._x*P,this._y*P,this._z*P)}scaleToRef(P,f){return f._x=this._x*P,f._y=this._y*P,f._z=this._z*P,f._isDirty=!0,f}getNormalToRef(P){const f=this.length();let Y=Math.acos(this._y/f);const C=Math.atan2(this._z,this._x);Y>Math.PI/2?Y-=Math.PI/2:Y+=Math.PI/2;const q=f*Math.sin(Y)*Math.cos(C),m=f*Math.cos(Y),L=f*Math.sin(Y)*Math.sin(C);return P.set(q,m,L),P}applyRotationQuaternionToRef(P,f){const Y=this._x,C=this._y,q=this._z,m=P._x,L=P._y,o=P._z,w=P._w,d=2*(L*q-o*C),R=2*(o*Y-m*q),y=2*(m*C-L*Y);return f._x=Y+w*d+L*y-o*R,f._y=C+w*R+o*d-m*y,f._z=q+w*y+m*R-L*d,f._isDirty=!0,f}applyRotationQuaternionInPlace(P){return this.applyRotationQuaternionToRef(P,this)}applyRotationQuaternion(P){return this.applyRotationQuaternionToRef(P,new g)}scaleAndAddToRef(P,f){return f._x+=this._x*P,f._y+=this._y*P,f._z+=this._z*P,f._isDirty=!0,f}projectOnPlane(P,f){return this.projectOnPlaneToRef(P,f,new g)}projectOnPlaneToRef(P,f,Y){const C=P.normal,q=P.d,m=V.Of[0];this.subtractToRef(f,m),m.normalize();const L=g.Dot(m,C);if(Math.abs(L)<1e-10)Y.yo(1/0);else{const P=-(g.Dot(f,C)+q)/L,o=m.scaleInPlace(P);f.addToRef(o,Y)}return Y}equals(P){return P&&this._x===P._x&&this._y===P._y&&this._z===P._z}equalsWithEpsilon(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.c;return P&&(0,w.WithinEpsilon)(this._x,P._x,f)&&(0,w.WithinEpsilon)(this._y,P._y,f)&&(0,w.WithinEpsilon)(this._z,P._z,f)}equalsToFloats(P,f,Y){return this._x===P&&this._y===f&&this._z===Y}multiplyInPlace(P){return this._x*=P._x,this._y*=P._y,this._z*=P._z,this._isDirty=!0,this}multiply(P){return this.multiplyByFloats(P._x,P._y,P._z)}multiplyToRef(P,f){return f._x=this._x*P._x,f._y=this._y*P._y,f._z=this._z*P._z,f._isDirty=!0,f}multiplyByFloats(P,f,Y){return new g(this._x*P,this._y*f,this._z*Y)}divide(P){return new g(this._x/P._x,this._y/P._y,this._z/P._z)}divideToRef(P,f){return f._x=this._x/P._x,f._y=this._y/P._y,f._z=this._z/P._z,f._isDirty=!0,f}divideInPlace(P){return this._x=this._x/P._x,this._y=this._y/P._y,this._z=this._z/P._z,this._isDirty=!0,this}minimizeInPlace(P){return this.minimizeInPlaceFromFloats(P._x,P._y,P._z)}maximizeInPlace(P){return this.maximizeInPlaceFromFloats(P._x,P._y,P._z)}minimizeInPlaceFromFloats(P,f,Y){return P<this._x&&(this.x=P),f<this._y&&(this.y=f),Y<this._z&&(this.z=Y),this}maximizeInPlaceFromFloats(P,f,Y){return P>this._x&&(this.x=P),f>this._y&&(this.y=f),Y>this._z&&(this.z=Y),this}isNonUniformWithinEpsilon(P){const f=Math.abs(this._x),Y=Math.abs(this._y);if(!(0,w.WithinEpsilon)(f,Y,P))return!0;const C=Math.abs(this._z);return!(0,w.WithinEpsilon)(f,C,P)||!(0,w.WithinEpsilon)(Y,C,P)}get isNonUniform(){const P=Math.abs(this._x);if(P!==Math.abs(this._y))return!0;return P!==Math.abs(this._z)}floorToRef(P){return P._x=Math.floor(this._x),P._y=Math.floor(this._y),P._z=Math.floor(this._z),P._isDirty=!0,P}floor(){return new g(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(P){return P._x=this._x-Math.floor(this._x),P._y=this._y-Math.floor(this._y),P._z=this._z-Math.floor(this._z),P._isDirty=!0,P}fract(){return new g(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(P){if("xyz"===(P=P.toLowerCase()))return this;const f=V.Of[0].q(this);return this.x=f[P[0]],this.y=f[P[1]],this.z=f[P[2]],this}rotateByQuaternionToRef(P,f){return P.toRotationMatrix(V.Matrix[0]),g.TransformCoordinatesToRef(this,V.Matrix[0],f),f}rotateByQuaternionAroundPointToRef(P,f,Y){return this.subtractToRef(f,V.Of[0]),V.Of[0].rotateByQuaternionToRef(P,V.Of[0]),f.addToRef(V.Of[0],Y),Y}cross(P){return g.CrossToRef(this,P,new g)}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){return this.normalizeToRef(new g)}normalizeToRef(P){const f=this.length();return 0===f||1===f?(P._x=this._x,P._y=this._y,P._z=this._z,P._isDirty=!0,P):this.scaleToRef(1/f,P)}clone(){return new g(this._x,this._y,this._z)}q(P){return this.do(P._x,P._y,P._z)}do(P,f,Y){return this._x=P,this._y=f,this._z=Y,this._isDirty=!0,this}set(P,f,Y){return this.do(P,f,Y)}yo(P){return this._x=this._y=this._z=P,this._isDirty=!0,this}static GetClipFactor(P,f,Y,C){const q=g.Dot(P,Y);return(q-C)/(q-g.Dot(f,Y))}static GetAngleBetweenVectors(P,f,Y){const C=P.normalizeToRef(V.Of[1]),q=f.normalizeToRef(V.Of[2]);let m=g.Dot(C,q);m=(0,w.Clamp)(m,-1,1);const L=Math.acos(m),o=V.Of[3];return g.CrossToRef(C,q,o),g.Dot(o,Y)>0?isNaN(L)?0:L:isNaN(L)?-Math.PI:-Math.acos(m)}static GetAngleBetweenVectorsOnPlane(P,f,Y){V.Of[0].q(P);const C=V.Of[0];V.Of[1].q(f);const q=V.Of[1];V.Of[2].q(Y);const m=V.Of[2],L=V.Of[3],o=V.Of[4];C.normalize(),q.normalize(),m.normalize(),g.CrossToRef(m,C,L),g.CrossToRef(L,m,o);const d=Math.atan2(g.Dot(q,L),g.Dot(q,o));return(0,w.NormalizeRadians)(d)}static PitchYawRollToMoveBetweenPointsToRef(P,f,Y){const C=O.Of[0];return f.subtractToRef(P,C),Y._y=Math.atan2(C.x,C.z)||0,Y._x=Math.atan2(Math.sqrt(C.x**2+C.z**2),C.y)||0,Y._z=0,Y._isDirty=!0,Y}static PitchYawRollToMoveBetweenPoints(P,f){const Y=g.Zero();return g.PitchYawRollToMoveBetweenPointsToRef(P,f,Y)}static SlerpToRef(P,f,Y,q){Y=(0,w.Clamp)(Y,0,1);const m=V.Of[0],L=V.Of[1];m.q(P);const o=m.length();m.normalizeFromLength(o),L.q(f);const d=L.length();L.normalizeFromLength(d);const R=g.Dot(m,L);let y,r;if(R<1-C.c){const P=Math.acos(R),f=1/Math.sin(P);y=Math.sin((1-Y)*P)*f,r=Math.sin(Y*P)*f}else y=1-Y,r=Y;return m.scaleInPlace(y),L.scaleInPlace(r),q.q(m).addInPlace(L),q.scaleInPlace((0,w.Lerp)(o,d,Y)),q}static SmoothToRef(P,f,Y,C,q){return g.SlerpToRef(P,f,0===C?1:Y/C,q),q}static ef(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new g(P[f],P[f+1],P[f+2])}static FromFloatArray(P,f){return g.ef(P,f)}static FromArrayToRef(P,f,Y){return Y._x=P[f],Y._y=P[f+1],Y._z=P[f+2],Y._isDirty=!0,Y}static FromFloatArrayToRef(P,f,Y){return g.FromArrayToRef(P,f,Y)}static FromFloatsToRef(P,f,Y,C){return C.do(P,f,Y),C}static Zero(){return new g(0,0,0)}static One(){return new g(1,1,1)}static Up(){return new g(0,1,0)}static get UpReadOnly(){return g._UpReadOnly}static get DownReadOnly(){return g._DownReadOnly}static get RightReadOnly(){return g._RightReadOnly}static get LeftReadOnly(){return g._LeftReadOnly}static get LeftHandedForwardReadOnly(){return g._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return g._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return g._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return g._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return g._ZeroReadOnly}static get OneReadOnly(){return g._OneReadOnly}static Down(){return new g(0,-1,0)}static Forward(){return new g(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new g(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new g(1,0,0)}static Left(){return new g(-1,0,0)}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new g((0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).do((0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f))}static TransformCoordinates(P,f){const Y=g.Zero();return g.TransformCoordinatesToRef(P,f,Y),Y}static TransformCoordinatesToRef(P,f,Y){return g.TransformCoordinatesFromFloatsToRef(P._x,P._y,P._z,f,Y),Y}static TransformCoordinatesFromFloatsToRef(P,f,Y,C,q){const m=C.m,L=P*m[0]+f*m[4]+Y*m[8]+m[12],o=P*m[1]+f*m[5]+Y*m[9]+m[13],w=P*m[2]+f*m[6]+Y*m[10]+m[14],d=1/(P*m[3]+f*m[7]+Y*m[11]+m[15]);return q._x=L*d,q._y=o*d,q._z=w*d,q._isDirty=!0,q}static TransformNormal(P,f){const Y=g.Zero();return g.TransformNormalToRef(P,f,Y),Y}static TransformNormalToRef(P,f,Y){return this.TransformNormalFromFloatsToRef(P._x,P._y,P._z,f,Y),Y}static TransformNormalFromFloatsToRef(P,f,Y,C,q){const m=C.m;return q._x=P*m[0]+f*m[4]+Y*m[8],q._y=P*m[1]+f*m[5]+Y*m[9],q._z=P*m[2]+f*m[6]+Y*m[10],q._isDirty=!0,q}static CatmullRom(P,f,Y,C,q){const m=q*q,L=q*m,o=.5*(2*f._x+(-P._x+Y._x)*q+(2*P._x-5*f._x+4*Y._x-C._x)*m+(-P._x+3*f._x-3*Y._x+C._x)*L),w=.5*(2*f._y+(-P._y+Y._y)*q+(2*P._y-5*f._y+4*Y._y-C._y)*m+(-P._y+3*f._y-3*Y._y+C._y)*L),d=.5*(2*f._z+(-P._z+Y._z)*q+(2*P._z-5*f._z+4*Y._z-C._z)*m+(-P._z+3*f._z-3*Y._z+C._z)*L);return new g(o,w,d)}static Clamp(P,f,Y){const C=new g;return g.ClampToRef(P,f,Y,C),C}static ClampToRef(P,f,Y,C){let q=P._x;q=q>Y._x?Y._x:q,q=q<f._x?f._x:q;let m=P._y;m=m>Y._y?Y._y:m,m=m<f._y?f._y:m;let L=P._z;return L=L>Y._z?Y._z:L,L=L<f._z?f._z:L,C.do(q,m,L),C}static CheckExtends(P,f,Y){f.minimizeInPlace(P),Y.maximizeInPlace(P)}static Hermite(P,f,Y,C,q){const m=q*q,L=q*m,o=2*L-3*m+1,w=-2*L+3*m,d=L-2*m+q,R=L-m,y=P._x*o+Y._x*w+f._x*d+C._x*R,r=P._y*o+Y._y*w+f._y*d+C._y*R,i=P._z*o+Y._z*w+f._z*d+C._z*R;return new g(y,r,i)}static Hermite1stDerivative(P,f,Y,C,q){const m=new g;return this.Hermite1stDerivativeToRef(P,f,Y,C,q,m),m}static Hermite1stDerivativeToRef(P,f,Y,C,q,m){const L=q*q;return m._x=6*(L-q)*P._x+(3*L-4*q+1)*f._x+6*(-L+q)*Y._x+(3*L-2*q)*C._x,m._y=6*(L-q)*P._y+(3*L-4*q+1)*f._y+6*(-L+q)*Y._y+(3*L-2*q)*C._y,m._z=6*(L-q)*P._z+(3*L-4*q+1)*f._z+6*(-L+q)*Y._z+(3*L-2*q)*C._z,m._isDirty=!0,m}static Lerp(P,f,Y){const C=new g(0,0,0);return g.LerpToRef(P,f,Y,C),C}static LerpToRef(P,f,Y,C){return C._x=P._x+(f._x-P._x)*Y,C._y=P._y+(f._y-P._y)*Y,C._z=P._z+(f._z-P._z)*Y,C._isDirty=!0,C}static Dot(P,f){return P._x*f._x+P._y*f._y+P._z*f._z}dot(P){return this._x*P._x+this._y*P._y+this._z*P._z}static Cross(P,f){const Y=new g;return g.CrossToRef(P,f,Y),Y}static CrossToRef(P,f,Y){const C=P._y*f._z-P._z*f._y,q=P._z*f._x-P._x*f._z,m=P._x*f._y-P._y*f._x;return Y.do(C,q,m),Y}static Normalize(P){const f=g.Zero();return g.NormalizeToRef(P,f),f}static NormalizeToRef(P,f){return P.normalizeToRef(f),f}static Project(P,f,Y,C){const q=new g;return g.ProjectToRef(P,f,Y,C,q),q}static ProjectToRef(P,f,Y,C,q){var m;const L=C.width,w=C.height,d=C.x,R=C.y,y=V.Matrix[1],r=null===(m=o.e.LastCreatedEngine)||void 0===m?void 0:m.isNDCHalfZRange,i=r?1:.5,u=r?0:.5;M.FromValuesToRef(L/2,0,0,0,0,-w/2,0,0,0,0,i,0,d+L/2,w/2+R,u,1,y);const S=V.Matrix[0];return f.multiplyToRef(Y,S),S.multiplyToRef(y,S),g.TransformCoordinatesToRef(P,S,q),q}static Reflect(P,f){return this.ReflectToRef(P,f,new g)}static ReflectToRef(P,f,Y){const C=O.Of[0];return C.q(f).scaleInPlace(2*g.Dot(P,f)),Y.q(P).Ly(C)}static _UnprojectFromInvertedMatrixToRef(P,f,Y){g.TransformCoordinatesToRef(P,f,Y);const C=f.m,q=P._x*C[3]+P._y*C[7]+P._z*C[11]+C[15];return(0,w.WithinEpsilon)(q,1)&&Y.scaleInPlace(1/q),Y}static UnprojectFromTransform(P,f,Y,C,q){return this.Unproject(P,f,Y,C,q,M.IdentityReadOnly)}static Unproject(P,f,Y,C,q,m){const L=new g;return g.UnprojectToRef(P,f,Y,C,q,m,L),L}static UnprojectToRef(P,f,Y,C,q,m,L){return g.UnprojectFloatsToRef(P._x,P._y,P._z,f,Y,C,q,m,L),L}static UnprojectFloatsToRef(P,f,Y,C,q,m,L,w,d){var R;const y=V.Matrix[0];m.multiplyToRef(L,y),y.multiplyToRef(w,y),y.invert();const r=V.Of[0];return r.x=P/C*2-1,r.y=-(f/q*2-1),null!==(R=o.e.LastCreatedEngine)&&void 0!==R&&R.isNDCHalfZRange?r.z=Y:r.z=2*Y-1,g._UnprojectFromInvertedMatrixToRef(r,y,d),d}static Minimize(P,f){const Y=new g;return Y.q(P),Y.minimizeInPlace(f),Y}static Maximize(P,f){const Y=new g;return Y.q(P),Y.maximizeInPlace(f),Y}static Distance(P,f){return Math.sqrt(g.DistanceSquared(P,f))}static DistanceSquared(P,f){const Y=P._x-f._x,C=P._y-f._y,q=P._z-f._z;return Y*Y+C*C+q*q}static ProjectOnTriangleToRef(P,f,Y,q,m){const L=V.Of[0],o=V.Of[1],d=V.Of[2],R=V.Of[3],y=V.Of[4];Y.subtractToRef(f,L),q.subtractToRef(f,o),q.subtractToRef(Y,d);const r=L.length(),i=o.length(),u=d.length();if(r<C.c||i<C.c||u<C.c)return m.q(f),g.Distance(P,f);P.subtractToRef(f,y),g.CrossToRef(L,o,R);const S=R.length();if(S<C.c)return m.q(f),g.Distance(P,f);R.normalizeFromLength(S);let K=y.length();if(K<C.c)return m.q(f),0;y.normalizeFromLength(K);const M=g.Dot(R,y),O=V.Of[5],n=V.Of[6];O.q(R).scaleInPlace(-K*M),n.q(P).addInPlace(O);const l=V.Of[4],v=V.Of[5],c=V.Of[7],T=V.Of[8];l.q(L).scaleInPlace(1/r),T.q(o).scaleInPlace(1/i),l.addInPlace(T).scaleInPlace(-1),v.q(L).scaleInPlace(-1/r),T.q(d).scaleInPlace(1/u),v.addInPlace(T).scaleInPlace(-1),c.q(d).scaleInPlace(-1/u),T.q(o).scaleInPlace(-1/i),c.addInPlace(T).scaleInPlace(-1);const U=V.Of[9];let D;U.q(n).Ly(f),g.CrossToRef(l,U,T),D=g.Dot(T,R);const j=D;U.q(n).Ly(Y),g.CrossToRef(v,U,T),D=g.Dot(T,R);const e=D;U.q(n).Ly(q),g.CrossToRef(c,U,T),D=g.Dot(T,R);const s=D,a=V.Of[10];let Q,J;j>0&&e<0?(a.q(L),Q=f,J=Y):e>0&&s<0?(a.q(d),Q=Y,J=q):(a.q(o).scaleInPlace(-1),Q=q,J=f);const N=V.Of[9],I=V.Of[4];Q.subtractToRef(n,T),J.subtractToRef(n,N),g.CrossToRef(T,N,I);if(!(g.Dot(I,R)<0))return m.q(n),Math.abs(K*M);const X=V.Of[5];g.CrossToRef(a,I,X),X.normalize();const x=V.Of[9];x.q(Q).Ly(n);const k=x.length();if(k<C.c)return m.q(Q),g.Distance(P,Q);x.normalizeFromLength(k);const Z=g.Dot(X,x),A=V.Of[7];A.q(n).addInPlace(X.scaleInPlace(k*Z)),T.q(A).Ly(Q),K=a.length(),a.normalizeFromLength(K);let E=g.Dot(T,a)/Math.max(K,C.c);return E=(0,w.Clamp)(E,0,1),A.q(Q).addInPlace(a.scaleInPlace(E*K)),m.q(A),g.Distance(P,A)}static Center(P,f){return g.CenterToRef(P,f,g.Zero())}static CenterToRef(P,f,Y){return Y.do((P._x+f._x)/2,(P._y+f._y)/2,(P._z+f._z)/2)}static RotationFromAxis(P,f,Y){const C=new g;return g.RotationFromAxisToRef(P,f,Y,C),C}static RotationFromAxisToRef(P,f,Y,C){const q=V.Quaternion[0];return K.RotationQuaternionFromAxisToRef(P,f,Y,q),q.toEulerAnglesToRef(C),C}}g._V8PerformanceHack=new g(.5,.5,.5),g._UpReadOnly=g.Up(),g._DownReadOnly=g.Down(),g._LeftHandedForwardReadOnly=g.Forward(!1),g._RightHandedForwardReadOnly=g.Forward(!0),g._LeftHandedBackwardReadOnly=g.Backward(!1),g._RightHandedBackwardReadOnly=g.Backward(!0),g._RightReadOnly=g.Right(),g._LeftReadOnly=g.Left(),g._ZeroReadOnly=g.Zero(),g._OneReadOnly=g.One(),Object.defineProperties(g.prototype,{dimension:{value:[3]},rank:{value:1}});class S{get x(){return this._x}set x(P){this._x=P,this._isDirty=!0}get y(){return this._y}set y(P){this._y=P,this._isDirty=!0}get z(){return this._z}set z(P){this._z=P,this._isDirty=!0}get w(){return this._w}set w(P){this._w=P,this._isDirty=!0}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=P,this._y=f,this._z=Y,this._w=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let P=i(this._x);return P=397*P^i(this._y),P=397*P^i(this._z),P=397*P^i(this._w),P}If(){return[this._x,this._y,this._z,this._w]}toArray(P,f){return void 0===f&&(f=0),P[f]=this._x,P[f+1]=this._y,P[f+2]=this._z,P[f+3]=this._w,this}jY(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(P,f,this),this}addInPlace(P){return this.x+=P._x,this.y+=P._y,this.z+=P._z,this.w+=P._w,this}addInPlaceFromFloats(P,f,Y,C){return this.x+=P,this.y+=f,this.z+=Y,this.w+=C,this}add(P){return new S(this._x+P.x,this._y+P.y,this._z+P.z,this._w+P.w)}addToRef(P,f){return f.x=this._x+P.x,f.y=this._y+P.y,f.z=this._z+P.z,f.w=this._w+P.w,f}Ly(P){return this.x-=P.x,this.y-=P.y,this.z-=P.z,this.w-=P.w,this}nf(P){return new S(this._x-P.x,this._y-P.y,this._z-P.z,this._w-P.w)}subtractToRef(P,f){return f.x=this._x-P.x,f.y=this._y-P.y,f.z=this._z-P.z,f.w=this._w-P.w,f}subtractFromFloats(P,f,Y,C){return new S(this._x-P,this._y-f,this._z-Y,this._w-C)}subtractFromFloatsToRef(P,f,Y,C,q){return q.x=this._x-P,q.y=this._y-f,q.z=this._z-Y,q.w=this._w-C,q}negate(){return new S(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(P){return P.x=-this._x,P.y=-this._y,P.z=-this._z,P.w=-this._w,P}scaleInPlace(P){return this.x*=P,this.y*=P,this.z*=P,this.w*=P,this}scale(P){return new S(this._x*P,this._y*P,this._z*P,this._w*P)}scaleToRef(P,f){return f.x=this._x*P,f.y=this._y*P,f.z=this._z*P,f.w=this._w*P,f}scaleAndAddToRef(P,f){return f.x+=this._x*P,f.y+=this._y*P,f.z+=this._z*P,f.w+=this._w*P,f}equals(P){return P&&this._x===P.x&&this._y===P.y&&this._z===P.z&&this._w===P.w}equalsWithEpsilon(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.c;return P&&(0,w.WithinEpsilon)(this._x,P.x,f)&&(0,w.WithinEpsilon)(this._y,P.y,f)&&(0,w.WithinEpsilon)(this._z,P.z,f)&&(0,w.WithinEpsilon)(this._w,P.w,f)}equalsToFloats(P,f,Y,C){return this._x===P&&this._y===f&&this._z===Y&&this._w===C}multiplyInPlace(P){return this.x*=P.x,this.y*=P.y,this.z*=P.z,this.w*=P.w,this}multiply(P){return new S(this._x*P.x,this._y*P.y,this._z*P.z,this._w*P.w)}multiplyToRef(P,f){return f.x=this._x*P.x,f.y=this._y*P.y,f.z=this._z*P.z,f.w=this._w*P.w,f}multiplyByFloats(P,f,Y,C){return new S(this._x*P,this._y*f,this._z*Y,this._w*C)}divide(P){return new S(this._x/P.x,this._y/P.y,this._z/P.z,this._w/P.w)}divideToRef(P,f){return f.x=this._x/P.x,f.y=this._y/P.y,f.z=this._z/P.z,f.w=this._w/P.w,f}divideInPlace(P){return this.divideToRef(P,this)}minimizeInPlace(P){return P.x<this._x&&(this.x=P.x),P.y<this._y&&(this.y=P.y),P.z<this._z&&(this.z=P.z),P.w<this._w&&(this.w=P.w),this}maximizeInPlace(P){return P.x>this._x&&(this.x=P.x),P.y>this._y&&(this.y=P.y),P.z>this._z&&(this.z=P.z),P.w>this._w&&(this.w=P.w),this}minimizeInPlaceFromFloats(P,f,Y,C){return this.x=Math.min(P,this._x),this.y=Math.min(f,this._y),this.z=Math.min(Y,this._z),this.w=Math.min(C,this._w),this}maximizeInPlaceFromFloats(P,f,Y,C){return this.x=Math.max(P,this._x),this.y=Math.max(f,this._y),this.z=Math.max(Y,this._z),this.w=Math.max(C,this._w),this}floorToRef(P){return P.x=Math.floor(this._x),P.y=Math.floor(this._y),P.z=Math.floor(this._z),P.w=Math.floor(this._w),P}floor(){return new S(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(P){return P.x=this._x-Math.floor(this._x),P.y=this._y-Math.floor(this._y),P.z=this._z-Math.floor(this._z),P.w=this._w-Math.floor(this._w),P}fract(){return new S(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){return this.normalizeToRef(new S)}normalizeToRef(P){const f=this.length();return 0===f||1===f?(P.x=this._x,P.y=this._y,P.z=this._z,P.w=this._w,P):this.scaleToRef(1/f,P)}toVector3(){return new g(this._x,this._y,this._z)}clone(){return new S(this._x,this._y,this._z,this._w)}q(P){return this.x=P.x,this.y=P.y,this.z=P.z,this.w=P.w,this}do(P,f,Y,C){return this.x=P,this.y=f,this.z=Y,this.w=C,this}set(P,f,Y,C){return this.do(P,f,Y,C)}yo(P){return this.x=this.y=this.z=this.w=P,this}dot(P){return this._x*P.x+this._y*P.y+this._z*P.z+this._w*P.w}static ef(P,f){return f||(f=0),new S(P[f],P[f+1],P[f+2],P[f+3])}static FromArrayToRef(P,f,Y){return Y.x=P[f],Y.y=P[f+1],Y.z=P[f+2],Y.w=P[f+3],Y}static FromFloatArrayToRef(P,f,Y){return S.FromArrayToRef(P,f,Y),Y}static FromFloatsToRef(P,f,Y,C,q){return q.x=P,q.y=f,q.z=Y,q.w=C,q}static Zero(){return new S(0,0,0,0)}static One(){return new S(1,1,1,1)}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new S((0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Y=arguments.length>2?arguments[2]:void 0;return Y.x=(0,w.RandomRange)(P,f),Y.y=(0,w.RandomRange)(P,f),Y.z=(0,w.RandomRange)(P,f),Y.w=(0,w.RandomRange)(P,f),Y}static Clamp(P,f,Y){return S.ClampToRef(P,f,Y,new S)}static ClampToRef(P,f,Y,C){return C.x=(0,w.Clamp)(P.x,f.x,Y.x),C.y=(0,w.Clamp)(P.y,f.y,Y.y),C.z=(0,w.Clamp)(P.z,f.z,Y.z),C.w=(0,w.Clamp)(P.w,f.w,Y.w),C}static CheckExtends(P,f,Y){f.minimizeInPlace(P),Y.maximizeInPlace(P)}static get ZeroReadOnly(){return S._ZeroReadOnly}static Normalize(P){return S.NormalizeToRef(P,new S)}static NormalizeToRef(P,f){return P.normalizeToRef(f),f}static Minimize(P,f){const Y=new S;return Y.q(P),Y.minimizeInPlace(f),Y}static Maximize(P,f){const Y=new S;return Y.q(P),Y.maximizeInPlace(f),Y}static Distance(P,f){return Math.sqrt(S.DistanceSquared(P,f))}static DistanceSquared(P,f){const Y=P.x-f.x,C=P.y-f.y,q=P.z-f.z,m=P.w-f.w;return Y*Y+C*C+q*q+m*m}static Center(P,f){return S.CenterToRef(P,f,new S)}static CenterToRef(P,f,Y){return Y.x=(P.x+f.x)/2,Y.y=(P.y+f.y)/2,Y.z=(P.z+f.z)/2,Y.w=(P.w+f.w)/2,Y}static TransformCoordinates(P,f){return S.TransformCoordinatesToRef(P,f,new S)}static TransformCoordinatesToRef(P,f,Y){return S.TransformCoordinatesFromFloatsToRef(P._x,P._y,P._z,f,Y),Y}static TransformCoordinatesFromFloatsToRef(P,f,Y,C,q){const m=C.m,L=P*m[0]+f*m[4]+Y*m[8]+m[12],o=P*m[1]+f*m[5]+Y*m[9]+m[13],w=P*m[2]+f*m[6]+Y*m[10]+m[14],d=P*m[3]+f*m[7]+Y*m[11]+m[15];return q.x=L,q.y=o,q.z=w,q.w=d,q}static TransformNormal(P,f){return S.TransformNormalToRef(P,f,new S)}static TransformNormalToRef(P,f,Y){const C=f.m,q=P.x*C[0]+P.y*C[4]+P.z*C[8],m=P.x*C[1]+P.y*C[5]+P.z*C[9],L=P.x*C[2]+P.y*C[6]+P.z*C[10];return Y.x=q,Y.y=m,Y.z=L,Y.w=P.w,Y}static TransformNormalFromFloatsToRef(P,f,Y,C,q,m){const L=q.m;return m.x=P*L[0]+f*L[4]+Y*L[8],m.y=P*L[1]+f*L[5]+Y*L[9],m.z=P*L[2]+f*L[6]+Y*L[10],m.w=C,m}static FromVector3(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new S(P._x,P._y,P._z,f)}static Dot(P,f){return P.x*f.x+P.y*f.y+P.z*f.z+P.w*f.w}}S._V8PerformanceHack=new S(.5,.5,.5,.5),S._ZeroReadOnly=S.Zero(),Object.defineProperties(S.prototype,{dimension:{value:[4]},rank:{value:1}});class K{get x(){return this._x}set x(P){this._x=P,this._isDirty=!0}get y(){return this._y}set y(P){this._y=P,this._isDirty=!0}get z(){return this._z}set z(P){this._z=P,this._isDirty=!0}get w(){return this._w}set w(P){this._w=P,this._isDirty=!0}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=P,this._y=f,this._z=Y,this._w=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let P=i(this._x);return P=397*P^i(this._y),P=397*P^i(this._z),P=397*P^i(this._w),P}If(){return[this._x,this._y,this._z,this._w]}toArray(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[f]=this._x,P[f+1]=this._y,P[f+2]=this._z,P[f+3]=this._w,this}jY(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(P,f,this)}equals(P){return P&&this._x===P._x&&this._y===P._y&&this._z===P._z&&this._w===P._w}equalsWithEpsilon(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.c;return P&&(0,w.WithinEpsilon)(this._x,P._x,f)&&(0,w.WithinEpsilon)(this._y,P._y,f)&&(0,w.WithinEpsilon)(this._z,P._z,f)&&(0,w.WithinEpsilon)(this._w,P._w,f)}isApprox(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.c;return P&&((0,w.WithinEpsilon)(this._x,P._x,f)&&(0,w.WithinEpsilon)(this._y,P._y,f)&&(0,w.WithinEpsilon)(this._z,P._z,f)&&(0,w.WithinEpsilon)(this._w,P._w,f)||(0,w.WithinEpsilon)(this._x,-P._x,f)&&(0,w.WithinEpsilon)(this._y,-P._y,f)&&(0,w.WithinEpsilon)(this._z,-P._z,f)&&(0,w.WithinEpsilon)(this._w,-P._w,f))}clone(){return new K(this._x,this._y,this._z,this._w)}q(P){return this._x=P._x,this._y=P._y,this._z=P._z,this._w=P._w,this._isDirty=!0,this}do(P,f,Y,C){return this._x=P,this._y=f,this._z=Y,this._w=C,this._isDirty=!0,this}set(P,f,Y,C){return this.do(P,f,Y,C)}yo(P){return this.do(P,P,P,P)}add(P){return new K(this._x+P._x,this._y+P._y,this._z+P._z,this._w+P._w)}addInPlace(P){return this._x+=P._x,this._y+=P._y,this._z+=P._z,this._w+=P._w,this._isDirty=!0,this}addToRef(P,f){return f._x=this._x+P._x,f._y=this._y+P._y,f._z=this._z+P._z,f._w=this._w+P._w,f._isDirty=!0,f}addInPlaceFromFloats(P,f,Y,C){return this._x+=P,this._y+=f,this._z+=Y,this._w+=C,this._isDirty=!0,this}subtractToRef(P,f){return f._x=this._x-P._x,f._y=this._y-P._y,f._z=this._z-P._z,f._w=this._w-P._w,f._isDirty=!0,f}subtractFromFloats(P,f,Y,C){return this.subtractFromFloatsToRef(P,f,Y,C,new K)}subtractFromFloatsToRef(P,f,Y,C,q){return q._x=this._x-P,q._y=this._y-f,q._z=this._z-Y,q._w=this._w-C,q._isDirty=!0,q}nf(P){return new K(this._x-P._x,this._y-P._y,this._z-P._z,this._w-P._w)}Ly(P){return this._x-=P._x,this._y-=P._y,this._z-=P._z,this._w-=P._w,this._isDirty=!0,this}scale(P){return new K(this._x*P,this._y*P,this._z*P,this._w*P)}scaleToRef(P,f){return f._x=this._x*P,f._y=this._y*P,f._z=this._z*P,f._w=this._w*P,f._isDirty=!0,f}scaleInPlace(P){return this._x*=P,this._y*=P,this._z*=P,this._w*=P,this._isDirty=!0,this}scaleAndAddToRef(P,f){return f._x+=this._x*P,f._y+=this._y*P,f._z+=this._z*P,f._w+=this._w*P,f._isDirty=!0,f}multiply(P){const f=new K(0,0,0,1);return this.multiplyToRef(P,f),f}multiplyToRef(P,f){const Y=this._x*P._w+this._y*P._z-this._z*P._y+this._w*P._x,C=-this._x*P._z+this._y*P._w+this._z*P._x+this._w*P._y,q=this._x*P._y-this._y*P._x+this._z*P._w+this._w*P._z,m=-this._x*P._x-this._y*P._y-this._z*P._z+this._w*P._w;return f.do(Y,C,q,m),f}multiplyInPlace(P){return this.multiplyToRef(P,this)}multiplyByFloats(P,f,Y,C){return this._x*=P,this._y*=f,this._z*=Y,this._w*=C,this._isDirty=!0,this}divide(P){throw new ReferenceError("Can not divide a quaternion")}divideToRef(P,f){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(P){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new K)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(P){return P._x=-this._x,P._y=-this._y,P._z=-this._z,P._w=-this._w,P._isDirty=!0,P}equalsToFloats(P,f,Y,C){return this._x===P&&this._y===f&&this._z===Y&&this._w===C}floorToRef(P){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(P){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(P){return P.do(-this._x,-this._y,-this._z,this._w),P}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new K(-this._x,-this._y,-this._z,this._w)}invert(){const P=this.conjugate(),f=this.lengthSquared();return 0==f||1==f||P.scaleInPlace(1/f),P}invertInPlace(){this.conjugateInPlace();const P=this.lengthSquared();return 0==P||1==P||this.scaleInPlace(1/P),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(P){return 0===P||1===P?this:this.scaleInPlace(1/P)}normalizeToNew(){const P=new K(0,0,0,1);return this.normalizeToRef(P),P}normalizeToRef(P){const f=this.length();return 0===f||1===f?P.do(this._x,this._y,this._z,this._w):this.scaleToRef(1/f,P)}toEulerAngles(){const P=g.Zero();return this.toEulerAnglesToRef(P),P}toEulerAnglesToRef(P){const f=this._z,Y=this._x,C=this._y,q=this._w,m=C*f-Y*q,L=.4999999;if(m<-L)P._y=2*Math.atan2(C,q),P._x=Math.PI/2,P._z=0,P._isDirty=!0;else if(m>L)P._y=2*Math.atan2(C,q),P._x=-Math.PI/2,P._z=0,P._isDirty=!0;else{const L=q*q,o=f*f,w=Y*Y,d=C*C;P._z=Math.atan2(2*(Y*C+f*q),-o-w+d+L),P._x=Math.asin(-2*m),P._y=Math.atan2(2*(f*Y+C*q),o-w-d+L),P._isDirty=!0}return P}toAlphaBetaGammaToRef(P){const f=this._z,Y=this._x,C=this._y,q=this._w,m=Math.sqrt(Y*Y+C*C),L=Math.sqrt(f*f+q*q),o=2*Math.atan2(m,L),w=2*Math.atan2(f,q),d=2*Math.atan2(C,Y),R=(w+d)/2,y=(w-d)/2;return P.set(y,o,R),P}toRotationMatrix(P){return M.FromQuaternionToRef(this,P),P}fromRotationMatrix(P){return K.FromRotationMatrixToRef(P,this),this}dot(P){return this._x*P._x+this._y*P._y+this._z*P._z+this._w*P._w}toAxisAngle(){const P=g.Zero();return{axis:P,angle:this.toAxisAngleToRef(P)}}toAxisAngleToRef(P){let f=0;const Y=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),C=this._w;return Y>0?(f=2*Math.atan2(Y,C),P.set(this._x/Y,this._y/Y,this._z/Y)):(f=0,P.set(1,0,0)),f}static FromRotationMatrix(P){const f=new K;return K.FromRotationMatrixToRef(P,f),f}static FromRotationMatrixToRef(P,f){const Y=P.m,C=Y[0],q=Y[4],m=Y[8],L=Y[1],o=Y[5],w=Y[9],d=Y[2],R=Y[6],y=Y[10],r=C+o+y;let i;return r>0?(i=.5/Math.sqrt(r+1),f._w=.25/i,f._x=(R-w)*i,f._y=(m-d)*i,f._z=(L-q)*i,f._isDirty=!0):C>o&&C>y?(i=2*Math.sqrt(1+C-o-y),f._w=(R-w)/i,f._x=.25*i,f._y=(q+L)/i,f._z=(m+d)/i,f._isDirty=!0):o>y?(i=2*Math.sqrt(1+o-C-y),f._w=(m-d)/i,f._x=(q+L)/i,f._y=.25*i,f._z=(w+R)/i,f._isDirty=!0):(i=2*Math.sqrt(1+y-C-o),f._w=(L-q)/i,f._x=(m+d)/i,f._y=(w+R)/i,f._z=.25*i,f._isDirty=!0),f}static Dot(P,f){return P._x*f._x+P._y*f._y+P._z*f._z+P._w*f._w}static AreClose(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const C=K.Dot(P,f);return 1-C*C<=Y}static SmoothToRef(P,f,Y,C,q){let m=0===C?1:Y/C;return m=(0,w.Clamp)(m,0,1),K.SlerpToRef(P,f,m,q),q}static Zero(){return new K(0,0,0,0)}static Inverse(P){return new K(-P._x,-P._y,-P._z,P._w)}static InverseToRef(P,f){return f.set(-P._x,-P._y,-P._z,P._w),f}static Identity(){return new K(0,0,0,1)}static IsIdentity(P){return P&&0===P._x&&0===P._y&&0===P._z&&1===P._w}static RotationAxis(P,f){return K.RotationAxisToRef(P,f,new K)}static RotationAxisToRef(P,f,Y){Y._w=Math.cos(f/2);const C=Math.sin(f/2)/P.length();return Y._x=P._x*C,Y._y=P._y*C,Y._z=P._z*C,Y._isDirty=!0,Y}static ef(P,f){return f||(f=0),new K(P[f],P[f+1],P[f+2],P[f+3])}static FromArrayToRef(P,f,Y){return Y._x=P[f],Y._y=P[f+1],Y._z=P[f+2],Y._w=P[f+3],Y._isDirty=!0,Y}static FromFloatsToRef(P,f,Y,C,q){return q.do(P,f,Y,C),q}static FromEulerAngles(P,f,Y){const C=new K;return K.RotationYawPitchRollToRef(f,P,Y,C),C}static FromEulerAnglesToRef(P,f,Y,C){return K.RotationYawPitchRollToRef(f,P,Y,C),C}static FromEulerVector(P){const f=new K;return K.RotationYawPitchRollToRef(P._y,P._x,P._z,f),f}static FromEulerVectorToRef(P,f){return K.RotationYawPitchRollToRef(P._y,P._x,P._z,f),f}static FromUnitVectorsToRef(P,f,Y){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C.c;const m=g.Dot(P,f)+1;return m<q?Math.abs(P.x)>Math.abs(P.z)?Y.set(-P.y,P.x,0,0):Y.set(0,-P.z,P.y,0):(g.CrossToRef(P,f,O.Of[0]),Y.set(O.Of[0].x,O.Of[0].y,O.Of[0].z,m)),Y.normalize()}static RotationYawPitchRoll(P,f,Y){const C=new K;return K.RotationYawPitchRollToRef(P,f,Y,C),C}static RotationYawPitchRollToRef(P,f,Y,C){const q=.5*Y,m=.5*f,L=.5*P,o=Math.sin(q),w=Math.cos(q),d=Math.sin(m),R=Math.cos(m),y=Math.sin(L),r=Math.cos(L);return C._x=r*d*w+y*R*o,C._y=y*R*w-r*d*o,C._z=r*R*o-y*d*w,C._w=r*R*w+y*d*o,C._isDirty=!0,C}static RotationAlphaBetaGamma(P,f,Y){const C=new K;return K.RotationAlphaBetaGammaToRef(P,f,Y,C),C}static RotationAlphaBetaGammaToRef(P,f,Y,C){const q=.5*(Y+P),m=.5*(Y-P),L=.5*f;return C._x=Math.cos(m)*Math.sin(L),C._y=Math.sin(m)*Math.sin(L),C._z=Math.sin(q)*Math.cos(L),C._w=Math.cos(q)*Math.cos(L),C._isDirty=!0,C}static RotationQuaternionFromAxis(P,f,Y){const C=new K(0,0,0,0);return K.RotationQuaternionFromAxisToRef(P,f,Y,C),C}static RotationQuaternionFromAxisToRef(P,f,Y,C){const q=V.Matrix[0];return P=P.normalizeToRef(V.Of[0]),f=f.normalizeToRef(V.Of[1]),Y=Y.normalizeToRef(V.Of[2]),M.FromXYZAxesToRef(P,f,Y,q),K.FromRotationMatrixToRef(q,C),C}static FromLookDirectionLH(P,f){const Y=new K;return K.FromLookDirectionLHToRef(P,f,Y),Y}static FromLookDirectionLHToRef(P,f,Y){const C=V.Matrix[0];return M.LookDirectionLHToRef(P,f,C),K.FromRotationMatrixToRef(C,Y),Y}static FromLookDirectionRH(P,f){const Y=new K;return K.FromLookDirectionRHToRef(P,f,Y),Y}static FromLookDirectionRHToRef(P,f,Y){const C=V.Matrix[0];return M.LookDirectionRHToRef(P,f,C),K.FromRotationMatrixToRef(C,Y)}static Slerp(P,f,Y){const C=K.Identity();return K.SlerpToRef(P,f,Y,C),C}static SlerpToRef(P,f,Y,C){let q,m,L=P._x*f._x+P._y*f._y+P._z*f._z+P._w*f._w,o=!1;if(L<0&&(o=!0,L=-L),L>.999999)m=1-Y,q=o?-Y:Y;else{const P=Math.acos(L),f=1/Math.sin(P);m=Math.sin((1-Y)*P)*f,q=o?-Math.sin(Y*P)*f:Math.sin(Y*P)*f}return C._x=m*P._x+q*f._x,C._y=m*P._y+q*f._y,C._z=m*P._z+q*f._z,C._w=m*P._w+q*f._w,C._isDirty=!0,C}static Hermite(P,f,Y,C,q){const m=q*q,L=q*m,o=2*L-3*m+1,w=-2*L+3*m,d=L-2*m+q,R=L-m,y=P._x*o+Y._x*w+f._x*d+C._x*R,r=P._y*o+Y._y*w+f._y*d+C._y*R,i=P._z*o+Y._z*w+f._z*d+C._z*R,u=P._w*o+Y._w*w+f._w*d+C._w*R;return new K(y,r,i,u)}static Hermite1stDerivative(P,f,Y,C,q){const m=new K;return this.Hermite1stDerivativeToRef(P,f,Y,C,q,m),m}static Hermite1stDerivativeToRef(P,f,Y,C,q,m){const L=q*q;return m._x=6*(L-q)*P._x+(3*L-4*q+1)*f._x+6*(-L+q)*Y._x+(3*L-2*q)*C._x,m._y=6*(L-q)*P._y+(3*L-4*q+1)*f._y+6*(-L+q)*Y._y+(3*L-2*q)*C._y,m._z=6*(L-q)*P._z+(3*L-4*q+1)*f._z+6*(-L+q)*Y._z+(3*L-2*q)*C._z,m._w=6*(L-q)*P._w+(3*L-4*q+1)*f._w+6*(-L+q)*Y._w+(3*L-2*q)*C._w,m._isDirty=!0,m}static Normalize(P){const f=K.Zero();return K.NormalizeToRef(P,f),f}static NormalizeToRef(P,f){return P.normalizeToRef(f),f}static Clamp(P,f,Y){const C=new K;return K.ClampToRef(P,f,Y,C),C}static ClampToRef(P,f,Y,C){return C.do((0,w.Clamp)(P.x,f.x,Y.x),(0,w.Clamp)(P.y,f.y,Y.y),(0,w.Clamp)(P.z,f.z,Y.z),(0,w.Clamp)(P.w,f.w,Y.w))}static Random(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new K((0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f))}static RandomToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).do((0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f),(0,w.RandomRange)(P,f))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(P,f){return Math.sqrt(K.DistanceSquared(P,f))}static DistanceSquared(P,f){const Y=P.x-f.x,C=P.y-f.y,q=P.z-f.z,m=P.w-f.w;return Y*Y+C*C+q*q+m*m}static Center(P,f){return K.CenterToRef(P,f,K.Zero())}static CenterToRef(P,f,Y){return Y.do((P.x+f.x)/2,(P.y+f.y)/2,(P.z+f.z)/2,(P.w+f.w)/2)}}K._V8PerformanceHack=new K(.5,.5,.5,.5),Object.defineProperties(K.prototype,{dimension:{value:[4]},rank:{value:1}});class M{static get Use64Bits(){return L.b.MatrixUse64Bits}get m(){return this.cf}markAsUpdated(){this.updateFlag=d._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(P){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=P,this._isIdentity3x2=P||Y,this._isIdentityDirty=!this._isIdentity&&f,this._isIdentity3x2Dirty=!this._isIdentity3x2&&C}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,L.b.MatrixTrackPrecisionChange&&L.b.MatrixTrackedMatrices.push(this),this.cf=new L.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const P=this.cf;this._isIdentity=1===P[0]&&0===P[1]&&0===P[2]&&0===P[3]&&0===P[4]&&1===P[5]&&0===P[6]&&0===P[7]&&0===P[8]&&0===P[9]&&1===P[10]&&0===P[11]&&0===P[12]&&0===P[13]&&0===P[14]&&1===P[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.cf[0]||1!==this.cf[5]||1!==this.cf[15]||0!==this.cf[1]||0!==this.cf[2]||0!==this.cf[3]||0!==this.cf[4]||0!==this.cf[6]||0!==this.cf[7]||0!==this.cf[8]||0!==this.cf[9]||0!==this.cf[10]||0!==this.cf[11]||0!==this.cf[12]||0!==this.cf[13]||0!==this.cf[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const P=this.cf,f=P[0],Y=P[1],C=P[2],q=P[3],m=P[4],L=P[5],o=P[6],w=P[7],d=P[8],R=P[9],y=P[10],r=P[11],i=P[12],u=P[13],g=P[14],S=P[15],K=y*S-g*r,M=R*S-u*r,V=R*g-u*y,O=d*S-i*r,n=d*g-y*i,l=d*u-i*R;return f*+(L*K-o*M+w*V)+Y*-(m*K-o*O+w*n)+C*+(m*M-L*O+w*l)+q*-(m*V-L*n+o*l)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!P)return this.cf;const Y=this.cf;for(let C=0;C<16;C++)P[f+C]=Y[C];return this}If(){return this.cf}jY(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M.FromArrayToRef(P,f,this)}do(){for(var P=arguments.length,f=new Array(P),Y=0;Y<P;Y++)f[Y]=arguments[Y];return M.FromArrayToRef(f,0,this)}set(){const P=this.cf;for(let f=0;f<16;f++)P[f]=f<0||arguments.length<=f?void 0:arguments[f];return this.markAsUpdated(),this}yo(P){const f=this.cf;for(let Y=0;Y<16;Y++)f[Y]=P;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return M.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(P){const f=new M;return this.addToRef(P,f),f}addToRef(P,f){const Y=this.cf,C=f.cf,q=P.m;for(let m=0;m<16;m++)C[m]=Y[m]+q[m];return f.markAsUpdated(),f}addToSelf(P){const f=this.cf,Y=P.m;return f[0]+=Y[0],f[1]+=Y[1],f[2]+=Y[2],f[3]+=Y[3],f[4]+=Y[4],f[5]+=Y[5],f[6]+=Y[6],f[7]+=Y[7],f[8]+=Y[8],f[9]+=Y[9],f[10]+=Y[10],f[11]+=Y[11],f[12]+=Y[12],f[13]+=Y[13],f[14]+=Y[14],f[15]+=Y[15],this.markAsUpdated(),this}addInPlace(P){const f=this.cf,Y=P.m;for(let C=0;C<16;C++)f[C]+=Y[C];return this.markAsUpdated(),this}addInPlaceFromFloats(){const P=this.cf;for(let f=0;f<16;f++)P[f]+=f<0||arguments.length<=f?void 0:arguments[f];return this.markAsUpdated(),this}nf(P){const f=this.cf,Y=P.m;for(let C=0;C<16;C++)f[C]-=Y[C];return this.markAsUpdated(),this}subtractToRef(P,f){const Y=this.cf,C=P.m,q=f.cf;for(let m=0;m<16;m++)q[m]=Y[m]-C[m];return f.markAsUpdated(),f}Ly(P){const f=this.cf,Y=P.m;for(let C=0;C<16;C++)f[C]-=Y[C];return this.markAsUpdated(),this}subtractFromFloats(){for(var P=arguments.length,f=new Array(P),Y=0;Y<P;Y++)f[Y]=arguments[Y];return this.subtractFromFloatsToRef(...f,new M)}subtractFromFloatsToRef(){for(var P=arguments.length,f=new Array(P),Y=0;Y<P;Y++)f[Y]=arguments[Y];const C=f.pop(),q=this.cf,m=C.cf,L=f;for(let o=0;o<16;o++)m[o]=q[o]-L[o];return C.markAsUpdated(),C}invertToRef(P){return!0===this._isIdentity?(M.IdentityToRef(P),P):(r(this,P.If())?P.markAsUpdated():P.q(this),P)}addAtIndex(P,f){return this.cf[P]+=f,this.markAsUpdated(),this}multiplyAtIndex(P,f){return this.cf[P]*=f,this.markAsUpdated(),this}setTranslationFromFloats(P,f,Y){return this.cf[12]=P,this.cf[13]=f,this.cf[14]=Y,this.markAsUpdated(),this}addTranslationFromFloats(P,f,Y){return this.cf[12]+=P,this.cf[13]+=f,this.cf[14]+=Y,this.markAsUpdated(),this}setTranslation(P){return this.setTranslationFromFloats(P._x,P._y,P._z)}getTranslation(){return new g(this.cf[12],this.cf[13],this.cf[14])}getTranslationToRef(P){return P.x=this.cf[12],P.y=this.cf[13],P.z=this.cf[14],P}removeRotationAndScaling(){const P=this.m;return M.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,P[12],P[13],P[14],P[15],this),this._updateIdentityStatus(0===P[12]&&0===P[13]&&0===P[14]&&1===P[15]),this}q(P){P.copyToArray(this.cf);const f=P;return this.updateFlag=f.updateFlag,this._updateIdentityStatus(f._isIdentity,f._isIdentityDirty,f._isIdentity3x2,f._isIdentity3x2Dirty),this}copyToArray(P){return y(this,P,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(P){const f=new M;return this.multiplyToRef(P,f),f}multiplyInPlace(P){const f=this.cf,Y=P.m;for(let C=0;C<16;C++)f[C]*=Y[C];return this.markAsUpdated(),this}multiplyByFloats(){const P=this.cf;for(let f=0;f<16;f++)P[f]*=f<0||arguments.length<=f?void 0:arguments[f];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var P=arguments.length,f=new Array(P),Y=0;Y<P;Y++)f[Y]=arguments[Y];const C=f.pop(),q=this.cf,m=C.cf,L=f;for(let o=0;o<16;o++)m[o]=q[o]*L[o];return C.markAsUpdated(),C}multiplyToRef(P,f){return this._isIdentity?(f.q(P),f):P._isIdentity?(f.q(this),f):(this.multiplyToArray(P,f.cf,0),f.markAsUpdated(),f)}multiplyToArray(P,f,Y){return R(this,P,f,Y),this}divide(P){return this.divideToRef(P,new M)}divideToRef(P,f){const Y=this.cf,C=P.m,q=f.cf;for(let m=0;m<16;m++)q[m]=Y[m]/C[m];return f.markAsUpdated(),f}divideInPlace(P){const f=this.cf,Y=P.m;for(let C=0;C<16;C++)f[C]/=Y[C];return this.markAsUpdated(),this}minimizeInPlace(P){const f=this.cf,Y=P.m;for(let C=0;C<16;C++)f[C]=Math.min(f[C],Y[C]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const P=this.cf;for(let f=0;f<16;f++)P[f]=Math.min(P[f],f<0||arguments.length<=f?void 0:arguments[f]);return this.markAsUpdated(),this}maximizeInPlace(P){const f=this.cf,Y=P.m;for(let C=0;C<16;C++)f[C]=Math.min(f[C],Y[C]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const P=this.cf;for(let f=0;f<16;f++)P[f]=Math.min(P[f],f<0||arguments.length<=f?void 0:arguments[f]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new M)}negateInPlace(){const P=this.cf;for(let f=0;f<16;f++)P[f]=-P[f];return this.markAsUpdated(),this}negateToRef(P){const f=this.cf,Y=P.cf;for(let C=0;C<16;C++)Y[C]=-f[C];return P.markAsUpdated(),P}equals(P){const f=P;if(!f)return!1;if((this._isIdentity||f._isIdentity)&&!this._isIdentityDirty&&!f._isIdentityDirty)return this._isIdentity&&f._isIdentity;const Y=this.m,C=f.m;return Y[0]===C[0]&&Y[1]===C[1]&&Y[2]===C[2]&&Y[3]===C[3]&&Y[4]===C[4]&&Y[5]===C[5]&&Y[6]===C[6]&&Y[7]===C[7]&&Y[8]===C[8]&&Y[9]===C[9]&&Y[10]===C[10]&&Y[11]===C[11]&&Y[12]===C[12]&&Y[13]===C[13]&&Y[14]===C[14]&&Y[15]===C[15]}equalsWithEpsilon(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Y=this.cf,C=P.m;for(let q=0;q<16;q++)if(!(0,w.WithinEpsilon)(Y[q],C[q],f))return!1;return!0}equalsToFloats(){const P=this.cf;for(let f=0;f<16;f++)if(P[f]!=(f<0||arguments.length<=f?void 0:arguments[f]))return!1;return!0}floor(){return this.floorToRef(new M)}floorToRef(P){const f=this.cf,Y=P.cf;for(let C=0;C<16;C++)Y[C]=Math.floor(f[C]);return P.markAsUpdated(),P}fract(){return this.fractToRef(new M)}fractToRef(P){const f=this.cf,Y=P.cf;for(let C=0;C<16;C++)Y[C]=f[C]-Math.floor(f[C]);return P.markAsUpdated(),P}clone(){const P=new M;return P.q(this),P}getClassName(){return"Matrix"}getHashCode(){let P=i(this.cf[0]);for(let f=1;f<16;f++)P=397*P^i(this.cf[f]);return P}decomposeToTransformNode(P){return P.rotationQuaternion=P.rotationQuaternion||new K,this.decompose(P.Ro,P.rotationQuaternion,P.position)}decompose(P,f,Y,C){let q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return Y&&Y.yo(0),P&&P.yo(1),f&&f.do(0,0,0,1),!0;const m=this.cf;if(Y&&Y.do(m[12],m[13],m[14]),(P=P||V.Of[0]).x=Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]),P.y=Math.sqrt(m[4]*m[4]+m[5]*m[5]+m[6]*m[6]),P.z=Math.sqrt(m[8]*m[8]+m[9]*m[9]+m[10]*m[10]),C){const f=(q?C.absoluteScaling.x:C.Ro.x)<0?-1:1,Y=(q?C.absoluteScaling.y:C.Ro.y)<0?-1:1,m=(q?C.absoluteScaling.z:C.Ro.z)<0?-1:1;P.x*=f,P.y*=Y,P.z*=m}else this.determinant()<=0&&(P.y*=-1);if(0===P._x||0===P._y||0===P._z)return f&&f.do(0,0,0,1),!1;if(f){const Y=1/P._x,C=1/P._y,q=1/P._z;M.FromValuesToRef(m[0]*Y,m[1]*Y,m[2]*Y,0,m[4]*C,m[5]*C,m[6]*C,0,m[8]*q,m[9]*q,m[10]*q,0,0,0,0,1,V.Matrix[0]),K.FromRotationMatrixToRef(V.Matrix[0],f)}return!0}getRow(P){if(P<0||P>3)return null;const f=4*P;return new S(this.cf[f+0],this.cf[f+1],this.cf[f+2],this.cf[f+3])}getRowToRef(P,f){if(P>=0&&P<=3){const Y=4*P;f.x=this.cf[Y+0],f.y=this.cf[Y+1],f.z=this.cf[Y+2],f.w=this.cf[Y+3]}return f}setRow(P,f){return this.setRowFromFloats(P,f.x,f.y,f.z,f.w)}transpose(){const P=new M;return M.TransposeToRef(this,P),P}transposeToRef(P){return M.TransposeToRef(this,P),P}setRowFromFloats(P,f,Y,C,q){if(P<0||P>3)return this;const m=4*P;return this.cf[m+0]=f,this.cf[m+1]=Y,this.cf[m+2]=C,this.cf[m+3]=q,this.markAsUpdated(),this}scale(P){const f=new M;return this.scaleToRef(P,f),f}scaleToRef(P,f){for(let Y=0;Y<16;Y++)f.cf[Y]=this.cf[Y]*P;return f.markAsUpdated(),f}scaleAndAddToRef(P,f){for(let Y=0;Y<16;Y++)f.cf[Y]+=this.cf[Y]*P;return f.markAsUpdated(),f}scaleInPlace(P){const f=this.cf;for(let Y=0;Y<16;Y++)f[Y]*=P;return this.markAsUpdated(),this}toNormalMatrix(P){const f=V.Matrix[0];this.invertToRef(f),f.transposeToRef(P);const Y=P.cf;return M.FromValuesToRef(Y[0],Y[1],Y[2],0,Y[4],Y[5],Y[6],0,Y[8],Y[9],Y[10],0,0,0,0,1,P),P}getRotationMatrix(){const P=new M;return this.getRotationMatrixToRef(P),P}getRotationMatrixToRef(P){const f=V.Of[0];if(!this.decompose(f))return M.IdentityToRef(P),P;const Y=this.cf,C=1/f._x,q=1/f._y,m=1/f._z;return M.FromValuesToRef(Y[0]*C,Y[1]*C,Y[2]*C,0,Y[4]*q,Y[5]*q,Y[6]*q,0,Y[8]*m,Y[9]*m,Y[10]*m,0,0,0,0,1,P),P}toggleModelMatrixHandInPlace(){const P=this.cf;return P[2]*=-1,P[6]*=-1,P[8]*=-1,P[9]*=-1,P[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const P=this.cf;return P[8]*=-1,P[9]*=-1,P[10]*=-1,P[11]*=-1,this.markAsUpdated(),this}static ef(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Y=new M;return M.FromArrayToRef(P,f,Y),Y}static FromArrayToRef(P,f,Y){for(let C=0;C<16;C++)Y.cf[C]=P[C+f];return Y.markAsUpdated(),Y}static FromFloat32ArrayToRefScaled(P,f,Y,C){return C.cf[0]=P[0+f]*Y,C.cf[1]=P[1+f]*Y,C.cf[2]=P[2+f]*Y,C.cf[3]=P[3+f]*Y,C.cf[4]=P[4+f]*Y,C.cf[5]=P[5+f]*Y,C.cf[6]=P[6+f]*Y,C.cf[7]=P[7+f]*Y,C.cf[8]=P[8+f]*Y,C.cf[9]=P[9+f]*Y,C.cf[10]=P[10+f]*Y,C.cf[11]=P[11+f]*Y,C.cf[12]=P[12+f]*Y,C.cf[13]=P[13+f]*Y,C.cf[14]=P[14+f]*Y,C.cf[15]=P[15+f]*Y,C.markAsUpdated(),C}static get IdentityReadOnly(){return M._IdentityReadOnly}static FromValuesToRef(P,f,Y,C,q,m,L,o,w,d,R,y,r,i,u,g,S){const K=S.cf;K[0]=P,K[1]=f,K[2]=Y,K[3]=C,K[4]=q,K[5]=m,K[6]=L,K[7]=o,K[8]=w,K[9]=d,K[10]=R,K[11]=y,K[12]=r,K[13]=i,K[14]=u,K[15]=g,S.markAsUpdated()}static FromValues(P,f,Y,C,q,m,L,o,w,d,R,y,r,i,u,g){const S=new M,K=S.cf;return K[0]=P,K[1]=f,K[2]=Y,K[3]=C,K[4]=q,K[5]=m,K[6]=L,K[7]=o,K[8]=w,K[9]=d,K[10]=R,K[11]=y,K[12]=r,K[13]=i,K[14]=u,K[15]=g,S.markAsUpdated(),S}static Compose(P,f,Y){const C=new M;return M.ComposeToRef(P,f,Y,C),C}static ComposeToRef(P,f,Y,C){const q=C.cf,m=f._x,L=f._y,o=f._z,w=f._w,d=m+m,R=L+L,y=o+o,r=m*d,i=m*R,u=m*y,g=L*R,S=L*y,K=o*y,M=w*d,V=w*R,O=w*y,n=P._x,l=P._y,v=P._z;return q[0]=(1-(g+K))*n,q[1]=(i+O)*n,q[2]=(u-V)*n,q[3]=0,q[4]=(i-O)*l,q[5]=(1-(r+K))*l,q[6]=(S+M)*l,q[7]=0,q[8]=(u+V)*v,q[9]=(S-M)*v,q[10]=(1-(r+g))*v,q[11]=0,q[12]=Y._x,q[13]=Y._y,q[14]=Y._z,q[15]=1,C.markAsUpdated(),C}static Identity(){const P=M.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return P._updateIdentityStatus(!0),P}static IdentityToRef(P){return M.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,P),P._updateIdentityStatus(!0),P}static Zero(){const P=M.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return P._updateIdentityStatus(!1),P}static RotationX(P){const f=new M;return M.RotationXToRef(P,f),f}static Invert(P){const f=new M;return P.invertToRef(f),f}static RotationXToRef(P,f){const Y=Math.sin(P),C=Math.cos(P);return M.FromValuesToRef(1,0,0,0,0,C,Y,0,0,-Y,C,0,0,0,0,1,f),f._updateIdentityStatus(1===C&&0===Y),f}static RotationY(P){const f=new M;return M.RotationYToRef(P,f),f}static RotationYToRef(P,f){const Y=Math.sin(P),C=Math.cos(P);return M.FromValuesToRef(C,0,-Y,0,0,1,0,0,Y,0,C,0,0,0,0,1,f),f._updateIdentityStatus(1===C&&0===Y),f}static RotationZ(P){const f=new M;return M.RotationZToRef(P,f),f}static RotationZToRef(P,f){const Y=Math.sin(P),C=Math.cos(P);return M.FromValuesToRef(C,Y,0,0,-Y,C,0,0,0,0,1,0,0,0,0,1,f),f._updateIdentityStatus(1===C&&0===Y),f}static RotationAxis(P,f){const Y=new M;return M.RotationAxisToRef(P,f,Y),Y}static RotationAxisToRef(P,f,Y){const C=Math.sin(-f),q=Math.cos(-f),m=1-q;P=P.normalizeToRef(V.Of[0]);const L=Y.cf;return L[0]=P._x*P._x*m+q,L[1]=P._x*P._y*m-P._z*C,L[2]=P._x*P._z*m+P._y*C,L[3]=0,L[4]=P._y*P._x*m+P._z*C,L[5]=P._y*P._y*m+q,L[6]=P._y*P._z*m-P._x*C,L[7]=0,L[8]=P._z*P._x*m-P._y*C,L[9]=P._z*P._y*m+P._x*C,L[10]=P._z*P._z*m+q,L[11]=0,L[12]=0,L[13]=0,L[14]=0,L[15]=1,Y.markAsUpdated(),Y}static RotationAlignToRef(P,f,Y){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const m=g.Dot(f,P),L=Y.cf;if(m<-1+C.c)L[0]=-1,L[1]=0,L[2]=0,L[3]=0,L[4]=0,L[5]=q?1:-1,L[6]=0,L[7]=0,L[8]=0,L[9]=0,L[10]=q?-1:1,L[11]=0;else{const Y=g.Cross(f,P),C=1/(1+m);L[0]=Y._x*Y._x*C+m,L[1]=Y._y*Y._x*C-Y._z,L[2]=Y._z*Y._x*C+Y._y,L[3]=0,L[4]=Y._x*Y._y*C+Y._z,L[5]=Y._y*Y._y*C+m,L[6]=Y._z*Y._y*C-Y._x,L[7]=0,L[8]=Y._x*Y._z*C-Y._y,L[9]=Y._y*Y._z*C+Y._x,L[10]=Y._z*Y._z*C+m,L[11]=0}return L[12]=0,L[13]=0,L[14]=0,L[15]=1,Y.markAsUpdated(),Y}static RotationYawPitchRoll(P,f,Y){const C=new M;return M.RotationYawPitchRollToRef(P,f,Y,C),C}static RotationYawPitchRollToRef(P,f,Y,C){return K.RotationYawPitchRollToRef(P,f,Y,V.Quaternion[0]),V.Quaternion[0].toRotationMatrix(C),C}static Scaling(P,f,Y){const C=new M;return M.ScalingToRef(P,f,Y,C),C}static ScalingToRef(P,f,Y,C){return M.FromValuesToRef(P,0,0,0,0,f,0,0,0,0,Y,0,0,0,0,1,C),C._updateIdentityStatus(1===P&&1===f&&1===Y),C}static Translation(P,f,Y){const C=new M;return M.TranslationToRef(P,f,Y,C),C}static TranslationToRef(P,f,Y,C){return M.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,P,f,Y,1,C),C._updateIdentityStatus(0===P&&0===f&&0===Y),C}static Lerp(P,f,Y){const C=new M;return M.LerpToRef(P,f,Y,C),C}static LerpToRef(P,f,Y,C){const q=C.cf,m=P.m,L=f.m;for(let o=0;o<16;o++)q[o]=m[o]*(1-Y)+L[o]*Y;return C.markAsUpdated(),C}static DecomposeLerp(P,f,Y){const C=new M;return M.DecomposeLerpToRef(P,f,Y,C),C}static DecomposeLerpToRef(P,f,Y,C){const q=V.Of[0],m=V.Quaternion[0],L=V.Of[1];P.decompose(q,m,L);const o=V.Of[2],w=V.Quaternion[1],d=V.Of[3];f.decompose(o,w,d);const R=V.Of[4];g.LerpToRef(q,o,Y,R);const y=V.Quaternion[2];K.SlerpToRef(m,w,Y,y);const r=V.Of[5];return g.LerpToRef(L,d,Y,r),M.ComposeToRef(R,y,r,C),C}static LookAtLH(P,f,Y){const C=new M;return M.LookAtLHToRef(P,f,Y,C),C}static LookAtLHToRef(P,f,Y,C){const q=V.Of[0],m=V.Of[1],L=V.Of[2];f.subtractToRef(P,L),L.normalize(),g.CrossToRef(Y,L,q);const o=q.lengthSquared();0===o?q.x=1:q.normalizeFromLength(Math.sqrt(o)),g.CrossToRef(L,q,m),m.normalize();const w=-g.Dot(q,P),d=-g.Dot(m,P),R=-g.Dot(L,P);return M.FromValuesToRef(q._x,m._x,L._x,0,q._y,m._y,L._y,0,q._z,m._z,L._z,0,w,d,R,1,C),C}static LookAtRH(P,f,Y){const C=new M;return M.LookAtRHToRef(P,f,Y,C),C}static LookAtRHToRef(P,f,Y,C){const q=V.Of[0],m=V.Of[1],L=V.Of[2];P.subtractToRef(f,L),L.normalize(),g.CrossToRef(Y,L,q);const o=q.lengthSquared();0===o?q.x=1:q.normalizeFromLength(Math.sqrt(o)),g.CrossToRef(L,q,m),m.normalize();const w=-g.Dot(q,P),d=-g.Dot(m,P),R=-g.Dot(L,P);return M.FromValuesToRef(q._x,m._x,L._x,0,q._y,m._y,L._y,0,q._z,m._z,L._z,0,w,d,R,1,C),C}static LookDirectionLH(P,f){const Y=new M;return M.LookDirectionLHToRef(P,f,Y),Y}static LookDirectionLHToRef(P,f,Y){const C=V.Of[0];C.q(P),C.scaleInPlace(-1);const q=V.Of[1];return g.CrossToRef(f,C,q),M.FromValuesToRef(q._x,q._y,q._z,0,f._x,f._y,f._z,0,C._x,C._y,C._z,0,0,0,0,1,Y),Y}static LookDirectionRH(P,f){const Y=new M;return M.LookDirectionRHToRef(P,f,Y),Y}static LookDirectionRHToRef(P,f,Y){const C=V.Of[2];return g.CrossToRef(f,P,C),M.FromValuesToRef(C._x,C._y,C._z,0,f._x,f._y,f._z,0,P._x,P._y,P._z,0,0,0,0,1,Y),Y}static OrthoLH(P,f,Y,C,q){const m=new M;return M.OrthoLHToRef(P,f,Y,C,m,q),m}static OrthoLHToRef(P,f,Y,C,q,m){const L=2/P,o=2/f,w=2/(C-Y),d=-(C+Y)/(C-Y);return M.FromValuesToRef(L,0,0,0,0,o,0,0,0,0,w,0,0,0,d,1,q),m&&q.multiplyToRef(n,q),q._updateIdentityStatus(1===L&&1===o&&1===w&&0===d),q}static OrthoOffCenterLH(P,f,Y,C,q,m,L){const o=new M;return M.OrthoOffCenterLHToRef(P,f,Y,C,q,m,o,L),o}static OrthoOffCenterLHToRef(P,f,Y,C,q,m,L,o){const w=2/(f-P),d=2/(C-Y),R=2/(m-q),y=-(m+q)/(m-q),r=(P+f)/(P-f),i=(C+Y)/(Y-C);return M.FromValuesToRef(w,0,0,0,0,d,0,0,0,0,R,0,r,i,y,1,L),o&&L.multiplyToRef(n,L),L.markAsUpdated(),L}static ObliqueOffCenterLHToRef(P,f,Y,C,q,m,L,o,w,d,R){const y=-L*Math.cos(o),r=-L*Math.sin(o);return M.TranslationToRef(0,0,-w,V.Matrix[1]),M.FromValuesToRef(1,0,0,0,0,1,0,0,y,r,1,0,0,0,0,1,V.Matrix[0]),V.Matrix[1].multiplyToRef(V.Matrix[0],V.Matrix[0]),M.TranslationToRef(0,0,w,V.Matrix[1]),V.Matrix[0].multiplyToRef(V.Matrix[1],V.Matrix[0]),M.OrthoOffCenterLHToRef(P,f,Y,C,q,m,d,R),V.Matrix[0].multiplyToRef(d,d),d}static OrthoOffCenterRH(P,f,Y,C,q,m,L){const o=new M;return M.OrthoOffCenterRHToRef(P,f,Y,C,q,m,o,L),o}static OrthoOffCenterRHToRef(P,f,Y,C,q,m,L,o){return M.OrthoOffCenterLHToRef(P,f,Y,C,q,m,L,o),L.cf[10]*=-1,L}static ObliqueOffCenterRHToRef(P,f,Y,C,q,m,L,o,w,d,R){const y=L*Math.cos(o),r=L*Math.sin(o);return M.TranslationToRef(0,0,w,V.Matrix[1]),M.FromValuesToRef(1,0,0,0,0,1,0,0,y,r,1,0,0,0,0,1,V.Matrix[0]),V.Matrix[1].multiplyToRef(V.Matrix[0],V.Matrix[0]),M.TranslationToRef(0,0,-w,V.Matrix[1]),V.Matrix[0].multiplyToRef(V.Matrix[1],V.Matrix[0]),M.OrthoOffCenterRHToRef(P,f,Y,C,q,m,d,R),V.Matrix[0].multiplyToRef(d,d),d}static PerspectiveLH(P,f,Y,C,q){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const L=new M,o=2*Y/P,w=2*Y/f,d=(C+Y)/(C-Y),R=-2*C*Y/(C-Y),y=Math.tan(m);return M.FromValuesToRef(o,0,0,0,0,w,0,y,0,0,d,1,0,0,R,0,L),q&&L.multiplyToRef(n,L),L._updateIdentityStatus(!1),L}static PerspectiveFovLH(P,f,Y,C,q){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,L=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const o=new M;return M.PerspectiveFovLHToRef(P,f,Y,C,o,!0,q,m,L),o}static PerspectiveFovLHToRef(P,f,Y,C,q){let m=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],L=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,w=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const d=Y,R=C,y=1/Math.tan(.5*P),r=m?y/f:y,i=m?y:y*f,u=w&&0===d?-1:0!==R?(R+d)/(R-d):1,g=w&&0===d?2*R:0!==R?-2*R*d/(R-d):-2*d,S=Math.tan(o);return M.FromValuesToRef(r,0,0,0,0,i,0,S,0,0,u,1,0,0,g,0,q),L&&q.multiplyToRef(n,q),q._updateIdentityStatus(!1),q}static PerspectiveFovReverseLHToRef(P,f,Y,C,q){let m=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],L=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const w=1/Math.tan(.5*P),d=m?w/f:w,R=m?w:w*f,y=Math.tan(o);return M.FromValuesToRef(d,0,0,0,0,R,0,y,0,0,-Y,1,0,0,1,0,q),L&&q.multiplyToRef(n,q),q._updateIdentityStatus(!1),q}static PerspectiveFovRH(P,f,Y,C,q){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,L=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const o=new M;return M.PerspectiveFovRHToRef(P,f,Y,C,o,!0,q,m,L),o}static PerspectiveFovRHToRef(P,f,Y,C,q){let m=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],L=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,w=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const d=Y,R=C,y=1/Math.tan(.5*P),r=m?y/f:y,i=m?y:y*f,u=w&&0===d?1:0!==R?-(R+d)/(R-d):-1,g=w&&0===d?2*R:0!==R?-2*R*d/(R-d):-2*d,S=Math.tan(o);return M.FromValuesToRef(r,0,0,0,0,i,0,S,0,0,u,-1,0,0,g,0,q),L&&q.multiplyToRef(n,q),q._updateIdentityStatus(!1),q}static PerspectiveFovReverseRHToRef(P,f,Y,C,q){let m=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],L=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const w=1/Math.tan(.5*P),d=m?w/f:w,R=m?w:w*f,y=Math.tan(o);return M.FromValuesToRef(d,0,0,0,0,R,0,y,0,0,-Y,-1,0,0,-1,0,q),L&&q.multiplyToRef(n,q),q._updateIdentityStatus(!1),q}static GetFinalMatrix(P,f,Y,C,q,m){const L=P.width,o=P.height,w=P.x,d=P.y,R=M.FromValues(L/2,0,0,0,0,-o/2,0,0,0,0,m-q,0,w+L/2,o/2+d,q,1),y=new M;return f.multiplyToRef(Y,y),y.multiplyToRef(C,y),y.multiplyToRef(R,y)}static GetAsMatrix2x2(P){const f=P.m,Y=[f[0],f[1],f[4],f[5]];return L.b.MatrixUse64Bits?Y:new Float32Array(Y)}static GetAsMatrix3x3(P){const f=P.m,Y=[f[0],f[1],f[2],f[4],f[5],f[6],f[8],f[9],f[10]];return L.b.MatrixUse64Bits?Y:new Float32Array(Y)}static Transpose(P){const f=new M;return M.TransposeToRef(P,f),f}static TransposeToRef(P,f){const Y=P.m,C=Y[0],q=Y[4],m=Y[8],L=Y[12],o=Y[1],w=Y[5],d=Y[9],R=Y[13],y=Y[2],r=Y[6],i=Y[10],u=Y[14],g=Y[3],S=Y[7],K=Y[11],M=Y[15],V=f.cf;return V[0]=C,V[1]=q,V[2]=m,V[3]=L,V[4]=o,V[5]=w,V[6]=d,V[7]=R,V[8]=y,V[9]=r,V[10]=i,V[11]=u,V[12]=g,V[13]=S,V[14]=K,V[15]=M,f.markAsUpdated(),f._updateIdentityStatus(P._isIdentity,P._isIdentityDirty),f}static Reflection(P){const f=new M;return M.ReflectionToRef(P,f),f}static ReflectionToRef(P,f){P.normalize();const Y=P.normal.x,C=P.normal.y,q=P.normal.z,m=-2*Y,L=-2*C,o=-2*q;return M.FromValuesToRef(m*Y+1,L*Y,o*Y,0,m*C,L*C+1,o*C,0,m*q,L*q,o*q+1,0,m*P.d,L*P.d,o*P.d,1,f),f}static FromXYZAxesToRef(P,f,Y,C){return M.FromValuesToRef(P._x,P._y,P._z,0,f._x,f._y,f._z,0,Y._x,Y._y,Y._z,0,0,0,0,1,C),C}static FromQuaternionToRef(P,f){const Y=P._x*P._x,C=P._y*P._y,q=P._z*P._z,m=P._x*P._y,L=P._z*P._w,o=P._z*P._x,w=P._y*P._w,d=P._y*P._z,R=P._x*P._w;return f.cf[0]=1-2*(C+q),f.cf[1]=2*(m+L),f.cf[2]=2*(o-w),f.cf[3]=0,f.cf[4]=2*(m-L),f.cf[5]=1-2*(q+Y),f.cf[6]=2*(d+R),f.cf[7]=0,f.cf[8]=2*(o+w),f.cf[9]=2*(d-R),f.cf[10]=1-2*(C+Y),f.cf[11]=0,f.cf[12]=0,f.cf[13]=0,f.cf[14]=0,f.cf[15]=1,f.markAsUpdated(),f}}M._IdentityReadOnly=M.Identity(),Object.defineProperties(M.prototype,{dimension:{value:[4,4]},rank:{value:2}});class V{}V.Of=(0,q.g)(11,g.Zero),V.Matrix=(0,q.g)(2,M.Identity),V.Quaternion=(0,q.g)(3,K.Zero);class O{}O.Vector2=(0,q.g)(3,u.Zero),O.Of=(0,q.g)(13,g.Zero),O.Vector4=(0,q.g)(3,S.Zero),O.Quaternion=(0,q.g)(3,K.Zero),O.Matrix=(0,q.g)(8,M.Identity),(0,m.d)("BABYLON.Vector2",u),(0,m.d)("BABYLON.Vector3",g),(0,m.d)("BABYLON.Vector4",S),(0,m.d)("BABYLON.Matrix",M);const n=M.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11196:(P,f,Y)=>{function C(P,f){const Y=[];for(let C=0;C<P;++C)Y.push(f());return Y}function q(P,f){return C(P,f)}Y.d(f,{d:()=>C,g:()=>q,i:()=>L});const m=["push","splice","pop","shift","unshift"];function L(P,f){const Y=m.map((Y=>function(P,f,Y){const C=P[f];if("function"!==typeof C)return null;const q=function(){const C=P.length,m=q.previous.apply(P,arguments);return Y(f,C),m};return C.next=q,q.previous=C,P[f]=q,()=>{const Y=q.previous;if(!Y)return;const C=q.next;C?(Y.next=C,C.previous=Y):(Y.next=void 0,P[f]=Y),q.next=void 0,q.previous=void 0}}(P,Y,f)));return()=>{for(const P of Y)null===P||void 0===P||P()}}}}]);