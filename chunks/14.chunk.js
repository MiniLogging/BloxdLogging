"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[14],{11382:(B,E,v)=>{v.d(E,{e:()=>c,h:()=>q,i:()=>z,j:()=>o});const z=1/2.2,o=2.2,q=(1+Math.sqrt(5))/2,c=.001},11394:(B,E,v)=>{function z(B){return parseInt(B.toString().replace(/\W/g,""))}function o(B,E){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(B-E)<=v}function q(B,E,v){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return B<E-z||B>v+z}function c(B,E){return B===E?B:Math.random()*(E-B)+B}function S(B,E,v){return B+(E-B)*v}function x(B,E,v){let z=a(E-B,360);return z>180&&(z-=360),B+z*Q(v)}function D(B,E,v){let z=0;return z=B!=E?Q((v-B)/(E-B)):0,z}function h(B,E,v,z,o){const q=o*o,c=o*q;return B*(2*c-3*q+1)+v*(-2*c+3*q)+E*(c-2*q+o)+z*(c-q)}function y(B,E,v,z,o){const q=o*o;return 6*(q-o)*B+(3*q-4*o+1)*E+6*(-q+o)*v+(3*q-2*o)*z}function Q(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(v,Math.max(E,B))}function P(B){return B-=2*Math.PI*Math.floor((B+Math.PI)/(2*Math.PI))}function G(B){const E=B.toString(16);return B<=15?("0"+E).toUpperCase():E.toUpperCase()}function Y(B){if(Math.log2)return Math.floor(Math.log2(B));if(B<0)return NaN;if(0===B)return-1/0;let E=0;if(B<1){for(;B<1;)E++,B*=2;E=-E}else if(B>1)for(;B>1;)E++,B=Math.floor(B/2);return E}function a(B,E){return B-Math.floor(B/E)*E}function m(B,E,v){return(B-E)/(v-E)}function g(B,E,v){return B*(v-E)+E}function V(B,E){let v=a(E-B,360);return v>180&&(v-=360),v}function T(B,E){const v=a(B,2*E);return E-Math.abs(v-E)}function N(B,E,v){let z=Q(v);return z=-2*z*z*z+3*z*z,E*z+B*(1-z)}function X(B,E,v){let z=0;return z=Math.abs(E-B)<=v?E:B+Math.sign(E-B)*v,z}function r(B,E,v){const z=V(B,E);let o=0;return o=-v<z&&z<v?E:X(B,E=B+z,v),o}function i(B,E,v){return(B-E)/(v-E)}function u(B,E,v){return(v-E)*B+E}function I(B,E){const v=B%E;return 0===v?E:I(E,v)}v.r(E),v.d(E,{Clamp:()=>Q,DeltaAngle:()=>V,Denormalize:()=>g,ExtractAsInt:()=>z,Hermite:()=>h,Hermite1stDerivative:()=>y,HighestCommonFactor:()=>I,ILog2:()=>Y,InverseLerp:()=>D,Lerp:()=>S,LerpAngle:()=>x,MoveTowards:()=>X,MoveTowardsAngle:()=>r,Normalize:()=>m,NormalizeRadians:()=>P,OutsideRange:()=>q,PercentToRange:()=>u,PingPong:()=>T,RandomRange:()=>c,RangeToPercent:()=>i,Repeat:()=>a,SmoothStep:()=>N,ToHex:()=>G,WithinEpsilon:()=>o})},11380:(B,E,v)=>{v.r(E),v.d(E,{Matrix:()=>g,Quaternion:()=>m,TmpVectors:()=>T,Vector2:()=>G,GE:()=>Y,Vector4:()=>a});var z=v(11382),o=v(11385),q=v(11345),c=v(11314),S=v(11242),x=v(11394);class D{}function h(B,E,v){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const o=B.cc(),q=E.cc(),c=o[0],S=o[1],x=o[2],D=o[3],h=o[4],y=o[5],Q=o[6],P=o[7],G=o[8],Y=o[9],a=o[10],m=o[11],g=o[12],V=o[13],T=o[14],N=o[15],X=q[0],r=q[1],i=q[2],u=q[3],I=q[4],K=q[5],C=q[6],f=q[7],A=q[8],l=q[9],d=q[10],t=q[11],p=q[12],H=q[13],j=q[14],R=q[15];v[z]=c*X+S*I+x*A+D*p,v[z+1]=c*r+S*K+x*l+D*H,v[z+2]=c*i+S*C+x*d+D*j,v[z+3]=c*u+S*f+x*t+D*R,v[z+4]=h*X+y*I+Q*A+P*p,v[z+5]=h*r+y*K+Q*l+P*H,v[z+6]=h*i+y*C+Q*d+P*j,v[z+7]=h*u+y*f+Q*t+P*R,v[z+8]=G*X+Y*I+a*A+m*p,v[z+9]=G*r+Y*K+a*l+m*H,v[z+10]=G*i+Y*C+a*d+m*j,v[z+11]=G*u+Y*f+a*t+m*R,v[z+12]=g*X+V*I+T*A+N*p,v[z+13]=g*r+V*K+T*l+N*H,v[z+14]=g*i+V*C+T*d+N*j,v[z+15]=g*u+V*f+T*t+N*R}function y(B,E){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const z=B.cc();E[v]=z[0],E[v+1]=z[1],E[v+2]=z[2],E[v+3]=z[3],E[v+4]=z[4],E[v+5]=z[5],E[v+6]=z[6],E[v+7]=z[7],E[v+8]=z[8],E[v+9]=z[9],E[v+10]=z[10],E[v+11]=z[11],E[v+12]=z[12],E[v+13]=z[13],E[v+14]=z[14],E[v+15]=z[15]}function Q(B,E){const v=B.cc(),z=v[0],o=v[1],q=v[2],c=v[3],S=v[4],x=v[5],D=v[6],h=v[7],y=v[8],Q=v[9],P=v[10],G=v[11],Y=v[12],a=v[13],m=v[14],g=v[15],V=P*g-m*G,T=Q*g-a*G,N=Q*m-a*P,X=y*g-Y*G,r=y*m-P*Y,i=y*a-Y*Q,u=+(x*V-D*T+h*N),I=-(S*V-D*X+h*r),K=+(S*T-x*X+h*i),C=-(S*N-x*r+D*i),f=z*u+o*I+q*K+c*C;if(0===f)return!1;const A=1/f,l=D*g-m*h,d=x*g-a*h,t=x*m-a*D,p=S*g-Y*h,H=S*m-Y*D,j=S*a-Y*x,R=D*G-P*h,b=x*G-Q*h,F=x*P-Q*D,W=S*G-y*h,w=S*P-y*D,n=S*Q-y*x,U=-(o*V-q*T+c*N),s=+(z*V-q*X+c*r),J=-(z*T-o*X+c*i),O=+(z*N-o*r+q*i),e=+(o*l-q*d+c*t),k=-(z*l-q*p+c*H),L=+(z*d-o*p+c*j),M=-(z*t-o*H+q*j),Z=-(o*R-q*b+c*F),BB=+(z*R-q*W+c*w),EB=-(z*b-o*W+c*n),vB=+(z*F-o*w+q*n);return E[0]=u*A,E[1]=U*A,E[2]=e*A,E[3]=Z*A,E[4]=I*A,E[5]=s*A,E[6]=k*A,E[7]=BB*A,E[8]=K*A,E[9]=J*A,E[10]=L*A,E[11]=EB*A,E[12]=C*A,E[13]=O*A,E[14]=M*A,E[15]=vB*A,!0}D._UpdateFlagSeed=0;const P=B=>parseInt(B.toString().replace(/\W/g,""));class G{constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=B,this.y=E}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let B=P(this.x);return B=397*B^P(this.y),B}toArray(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[E]=this.x,B[E+1]=this.y,this}Qv(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G.FromArrayToRef(B,E,this),this}cc(){return[this.x,this.y]}S(B){return this.x=B.x,this.y=B.y,this}Yc(B,E){return this.x=B,this.y=E,this}set(B,E){return this.Yc(B,E)}mc(B){return this.Yc(B,B)}add(B){return new G(this.x+B.x,this.y+B.y)}addToRef(B,E){return E.x=this.x+B.x,E.y=this.y+B.y,E}addInPlace(B){return this.x+=B.x,this.y+=B.y,this}addInPlaceFromFloats(B,E){return this.x+=B,this.y+=E,this}addVector3(B){return new G(this.x+B.x,this.y+B.y)}YE(B){return new G(this.x-B.x,this.y-B.y)}subtractToRef(B,E){return E.x=this.x-B.x,E.y=this.y-B.y,E}wy(B){return this.x-=B.x,this.y-=B.y,this}multiplyInPlace(B){return this.x*=B.x,this.y*=B.y,this}multiply(B){return new G(this.x*B.x,this.y*B.y)}multiplyToRef(B,E){return E.x=this.x*B.x,E.y=this.y*B.y,E}multiplyByFloats(B,E){return new G(this.x*B,this.y*E)}divide(B){return new G(this.x/B.x,this.y/B.y)}divideToRef(B,E){return E.x=this.x/B.x,E.y=this.y/B.y,E}divideInPlace(B){return this.x=this.x/B.x,this.y=this.y/B.y,this}minimizeInPlace(B){return this.minimizeInPlaceFromFloats(B.x,B.y)}maximizeInPlace(B){return this.maximizeInPlaceFromFloats(B.x,B.y)}minimizeInPlaceFromFloats(B,E){return this.x=Math.min(B,this.x),this.y=Math.min(E,this.y),this}maximizeInPlaceFromFloats(B,E){return this.x=Math.max(B,this.x),this.y=Math.max(E,this.y),this}subtractFromFloats(B,E){return new G(this.x-B,this.y-E)}subtractFromFloatsToRef(B,E,v){return v.x=this.x-B,v.y=this.y-E,v}negate(){return new G(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(B){return B.x=-this.x,B.y=-this.y,B}scaleInPlace(B){return this.x*=B,this.y*=B,this}scale(B){return new G(this.x*B,this.y*B)}scaleToRef(B,E){return E.x=this.x*B,E.y=this.y*B,E}scaleAndAddToRef(B,E){return E.x+=this.x*B,E.y+=this.y*B,E}equals(B){return B&&this.x===B.x&&this.y===B.y}equalsWithEpsilon(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.e;return B&&(0,x.WithinEpsilon)(this.x,B.x,E)&&(0,x.WithinEpsilon)(this.y,B.y,E)}equalsToFloats(B,E){return this.x===B&&this.y===E}floor(){return new G(Math.floor(this.x),Math.floor(this.y))}floorToRef(B){return B.x=Math.floor(this.x),B.y=Math.floor(this.y),B}fract(){return new G(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(B){return B.x=this.x-Math.floor(this.x),B.y=this.y-Math.floor(this.y),B}rotate(B){return this.rotateToRef(B,new G)}rotateToRef(B,E){const v=Math.cos(B),z=Math.sin(B);return E.x=v*this.x-z*this.y,E.y=z*this.x+v*this.y,E}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){const B=new G;return this.normalizeToRef(B),B}normalizeToRef(B){const E=this.length();return 0===E&&(B.x=this.x,B.y=this.y),this.scaleToRef(1/E,B)}clone(){return new G(this.x,this.y)}dot(B){return this.x*B.x+this.y*B.y}static Zero(){return new G(0,0)}static One(){return new G(1,1)}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new G((0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Yc((0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E))}static get ZeroReadOnly(){return G._ZeroReadOnly}static VE(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new G(B[E],B[E+1])}static FromArrayToRef(B,E,v){return v.x=B[E],v.y=B[E+1],v}static FromFloatsToRef(B,E,v){return v.Yc(B,E),v}static CatmullRom(B,E,v,z,o){const q=o*o,c=o*q,S=.5*(2*E.x+(-B.x+v.x)*o+(2*B.x-5*E.x+4*v.x-z.x)*q+(-B.x+3*E.x-3*v.x+z.x)*c),x=.5*(2*E.y+(-B.y+v.y)*o+(2*B.y-5*E.y+4*v.y-z.y)*q+(-B.y+3*E.y-3*v.y+z.y)*c);return new G(S,x)}static ClampToRef(B,E,v,z){return z.x=(0,x.Clamp)(B.x,E.x,v.x),z.y=(0,x.Clamp)(B.y,E.y,v.y),z}static Clamp(B,E,v){const z=(0,x.Clamp)(B.x,E.x,v.x),o=(0,x.Clamp)(B.y,E.y,v.y);return new G(z,o)}static Hermite(B,E,v,z,o){const q=o*o,c=o*q,S=2*c-3*q+1,x=-2*c+3*q,D=c-2*q+o,h=c-q,y=B.x*S+v.x*x+E.x*D+z.x*h,Q=B.y*S+v.y*x+E.y*D+z.y*h;return new G(y,Q)}static Hermite1stDerivative(B,E,v,z,o){return this.Hermite1stDerivativeToRef(B,E,v,z,o,new G)}static Hermite1stDerivativeToRef(B,E,v,z,o,q){const c=o*o;return q.x=6*(c-o)*B.x+(3*c-4*o+1)*E.x+6*(-c+o)*v.x+(3*c-2*o)*z.x,q.y=6*(c-o)*B.y+(3*c-4*o+1)*E.y+6*(-c+o)*v.y+(3*c-2*o)*z.y,q}static Lerp(B,E,v){return G.LerpToRef(B,E,v,new G)}static LerpToRef(B,E,v,z){return z.x=B.x+(E.x-B.x)*v,z.y=B.y+(E.y-B.y)*v,z}static Dot(B,E){return B.x*E.x+B.y*E.y}static Normalize(B){return G.NormalizeToRef(B,new G)}static NormalizeToRef(B,E){return B.normalizeToRef(E),E}static Minimize(B,E){const v=B.x<E.x?B.x:E.x,z=B.y<E.y?B.y:E.y;return new G(v,z)}static Maximize(B,E){const v=B.x>E.x?B.x:E.x,z=B.y>E.y?B.y:E.y;return new G(v,z)}static Transform(B,E){return G.TransformToRef(B,E,new G)}static TransformToRef(B,E,v){const z=E.m,o=B.x*z[0]+B.y*z[4]+z[12],q=B.x*z[1]+B.y*z[5]+z[13];return v.x=o,v.y=q,v}static PointInTriangle(B,E,v,z){const o=.5*(-v.y*z.x+E.y*(-v.x+z.x)+E.x*(v.y-z.y)+v.x*z.y),q=o<0?-1:1,c=(E.y*z.x-E.x*z.y+(z.y-E.y)*B.x+(E.x-z.x)*B.y)*q,S=(E.x*v.y-E.y*v.x+(E.y-v.y)*B.x+(v.x-E.x)*B.y)*q;return c>0&&S>0&&c+S<2*o*q}static Distance(B,E){return Math.sqrt(G.DistanceSquared(B,E))}static DistanceSquared(B,E){const v=B.x-E.x,z=B.y-E.y;return v*v+z*z}static Center(B,E){return G.CenterToRef(B,E,new G)}static CenterToRef(B,E,v){return v.Yc((B.x+E.x)/2,(B.y+E.y)/2)}static DistanceOfPointFromSegment(B,E,v){const z=G.DistanceSquared(E,v);if(0===z)return G.Distance(B,E);const o=v.YE(E),q=Math.max(0,Math.min(1,G.Dot(B.YE(E),o)/z)),c=E.add(o.multiplyByFloats(q,q));return G.Distance(B,c)}}G._V8PerformanceHack=new G(.5,.5),G._ZeroReadOnly=G.Zero(),Object.defineProperties(G.prototype,{dimension:{value:[2]},rank:{value:1}});class Y{get x(){return this._x}set x(B){this._x=B,this._isDirty=!0}get y(){return this._y}set y(B){this._y=B,this._isDirty=!0}get z(){return this._z}set z(B){this._z=B,this._isDirty=!0}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=B,this._y=E,this._z=v}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"GE"}getHashCode(){let B=P(this._x);return B=397*B^P(this._y),B=397*B^P(this._z),B}cc(){return[this._x,this._y,this._z]}toArray(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[E]=this._x,B[E+1]=this._y,B[E+2]=this._z,this}Qv(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y.FromArrayToRef(B,E,this),this}toQuaternion(){return m.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(B){return this._x+=B._x,this._y+=B._y,this._z+=B._z,this._isDirty=!0,this}addInPlaceFromFloats(B,E,v){return this._x+=B,this._y+=E,this._z+=v,this._isDirty=!0,this}add(B){return new Y(this._x+B._x,this._y+B._y,this._z+B._z)}addToRef(B,E){return E._x=this._x+B._x,E._y=this._y+B._y,E._z=this._z+B._z,E._isDirty=!0,E}wy(B){return this._x-=B._x,this._y-=B._y,this._z-=B._z,this._isDirty=!0,this}YE(B){return new Y(this._x-B._x,this._y-B._y,this._z-B._z)}subtractToRef(B,E){return this.subtractFromFloatsToRef(B._x,B._y,B._z,E)}subtractFromFloats(B,E,v){return new Y(this._x-B,this._y-E,this._z-v)}subtractFromFloatsToRef(B,E,v,z){return z._x=this._x-B,z._y=this._y-E,z._z=this._z-v,z._isDirty=!0,z}negate(){return new Y(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(B){return B._x=-1*this._x,B._y=-1*this._y,B._z=-1*this._z,B._isDirty=!0,B}scaleInPlace(B){return this._x*=B,this._y*=B,this._z*=B,this._isDirty=!0,this}scale(B){return new Y(this._x*B,this._y*B,this._z*B)}scaleToRef(B,E){return E._x=this._x*B,E._y=this._y*B,E._z=this._z*B,E._isDirty=!0,E}getNormalToRef(B){const E=this.length();let v=Math.acos(this._y/E);const z=Math.atan2(this._z,this._x);v>Math.PI/2?v-=Math.PI/2:v+=Math.PI/2;const o=E*Math.sin(v)*Math.cos(z),q=E*Math.cos(v),c=E*Math.sin(v)*Math.sin(z);return B.set(o,q,c),B}applyRotationQuaternionToRef(B,E){const v=this._x,z=this._y,o=this._z,q=B._x,c=B._y,S=B._z,x=B._w,D=2*(c*o-S*z),h=2*(S*v-q*o),y=2*(q*z-c*v);return E._x=v+x*D+c*y-S*h,E._y=z+x*h+S*D-q*y,E._z=o+x*y+q*h-c*D,E._isDirty=!0,E}applyRotationQuaternionInPlace(B){return this.applyRotationQuaternionToRef(B,this)}applyRotationQuaternion(B){return this.applyRotationQuaternionToRef(B,new Y)}scaleAndAddToRef(B,E){return E._x+=this._x*B,E._y+=this._y*B,E._z+=this._z*B,E._isDirty=!0,E}projectOnPlane(B,E){return this.projectOnPlaneToRef(B,E,new Y)}projectOnPlaneToRef(B,E,v){const z=B.normal,o=B.d,q=V.GE[0];this.subtractToRef(E,q),q.normalize();const c=Y.Dot(q,z);if(Math.abs(c)<1e-10)v.mc(1/0);else{const B=-(Y.Dot(E,z)+o)/c,S=q.scaleInPlace(B);E.addToRef(S,v)}return v}equals(B){return B&&this._x===B._x&&this._y===B._y&&this._z===B._z}equalsWithEpsilon(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.e;return B&&(0,x.WithinEpsilon)(this._x,B._x,E)&&(0,x.WithinEpsilon)(this._y,B._y,E)&&(0,x.WithinEpsilon)(this._z,B._z,E)}equalsToFloats(B,E,v){return this._x===B&&this._y===E&&this._z===v}multiplyInPlace(B){return this._x*=B._x,this._y*=B._y,this._z*=B._z,this._isDirty=!0,this}multiply(B){return this.multiplyByFloats(B._x,B._y,B._z)}multiplyToRef(B,E){return E._x=this._x*B._x,E._y=this._y*B._y,E._z=this._z*B._z,E._isDirty=!0,E}multiplyByFloats(B,E,v){return new Y(this._x*B,this._y*E,this._z*v)}divide(B){return new Y(this._x/B._x,this._y/B._y,this._z/B._z)}divideToRef(B,E){return E._x=this._x/B._x,E._y=this._y/B._y,E._z=this._z/B._z,E._isDirty=!0,E}divideInPlace(B){return this._x=this._x/B._x,this._y=this._y/B._y,this._z=this._z/B._z,this._isDirty=!0,this}minimizeInPlace(B){return this.minimizeInPlaceFromFloats(B._x,B._y,B._z)}maximizeInPlace(B){return this.maximizeInPlaceFromFloats(B._x,B._y,B._z)}minimizeInPlaceFromFloats(B,E,v){return B<this._x&&(this.x=B),E<this._y&&(this.y=E),v<this._z&&(this.z=v),this}maximizeInPlaceFromFloats(B,E,v){return B>this._x&&(this.x=B),E>this._y&&(this.y=E),v>this._z&&(this.z=v),this}isNonUniformWithinEpsilon(B){const E=Math.abs(this._x),v=Math.abs(this._y);if(!(0,x.WithinEpsilon)(E,v,B))return!0;const z=Math.abs(this._z);return!(0,x.WithinEpsilon)(E,z,B)||!(0,x.WithinEpsilon)(v,z,B)}get isNonUniform(){const B=Math.abs(this._x);if(B!==Math.abs(this._y))return!0;return B!==Math.abs(this._z)}floorToRef(B){return B._x=Math.floor(this._x),B._y=Math.floor(this._y),B._z=Math.floor(this._z),B._isDirty=!0,B}floor(){return new Y(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(B){return B._x=this._x-Math.floor(this._x),B._y=this._y-Math.floor(this._y),B._z=this._z-Math.floor(this._z),B._isDirty=!0,B}fract(){return new Y(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(B){if("xyz"===(B=B.toLowerCase()))return this;const E=V.GE[0].S(this);return this.x=E[B[0]],this.y=E[B[1]],this.z=E[B[2]],this}rotateByQuaternionToRef(B,E){return B.toRotationMatrix(V.Matrix[0]),Y.TransformCoordinatesToRef(this,V.Matrix[0],E),E}rotateByQuaternionAroundPointToRef(B,E,v){return this.subtractToRef(E,V.GE[0]),V.GE[0].rotateByQuaternionToRef(B,V.GE[0]),E.addToRef(V.GE[0],v),v}cross(B){return Y.CrossToRef(this,B,new Y)}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){return this.normalizeToRef(new Y)}normalizeToRef(B){const E=this.length();return 0===E||1===E?(B._x=this._x,B._y=this._y,B._z=this._z,B._isDirty=!0,B):this.scaleToRef(1/E,B)}clone(){return new Y(this._x,this._y,this._z)}S(B){return this.Yc(B._x,B._y,B._z)}Yc(B,E,v){return this._x=B,this._y=E,this._z=v,this._isDirty=!0,this}set(B,E,v){return this.Yc(B,E,v)}mc(B){return this._x=this._y=this._z=B,this._isDirty=!0,this}static GetClipFactor(B,E,v,z){const o=Y.Dot(B,v);return(o-z)/(o-Y.Dot(E,v))}static GetAngleBetweenVectors(B,E,v){const z=B.normalizeToRef(V.GE[1]),o=E.normalizeToRef(V.GE[2]);let q=Y.Dot(z,o);q=(0,x.Clamp)(q,-1,1);const c=Math.acos(q),S=V.GE[3];return Y.CrossToRef(z,o,S),Y.Dot(S,v)>0?isNaN(c)?0:c:isNaN(c)?-Math.PI:-Math.acos(q)}static GetAngleBetweenVectorsOnPlane(B,E,v){V.GE[0].S(B);const z=V.GE[0];V.GE[1].S(E);const o=V.GE[1];V.GE[2].S(v);const q=V.GE[2],c=V.GE[3],S=V.GE[4];z.normalize(),o.normalize(),q.normalize(),Y.CrossToRef(q,z,c),Y.CrossToRef(c,q,S);const D=Math.atan2(Y.Dot(o,c),Y.Dot(o,S));return(0,x.NormalizeRadians)(D)}static PitchYawRollToMoveBetweenPointsToRef(B,E,v){const z=T.GE[0];return E.subtractToRef(B,z),v._y=Math.atan2(z.x,z.z)||0,v._x=Math.atan2(Math.sqrt(z.x**2+z.z**2),z.y)||0,v._z=0,v._isDirty=!0,v}static PitchYawRollToMoveBetweenPoints(B,E){const v=Y.Zero();return Y.PitchYawRollToMoveBetweenPointsToRef(B,E,v)}static SlerpToRef(B,E,v,o){v=(0,x.Clamp)(v,0,1);const q=V.GE[0],c=V.GE[1];q.S(B);const S=q.length();q.normalizeFromLength(S),c.S(E);const D=c.length();c.normalizeFromLength(D);const h=Y.Dot(q,c);let y,Q;if(h<1-z.e){const B=Math.acos(h),E=1/Math.sin(B);y=Math.sin((1-v)*B)*E,Q=Math.sin(v*B)*E}else y=1-v,Q=v;return q.scaleInPlace(y),c.scaleInPlace(Q),o.S(q).addInPlace(c),o.scaleInPlace((0,x.Lerp)(S,D,v)),o}static SmoothToRef(B,E,v,z,o){return Y.SlerpToRef(B,E,0===z?1:v/z,o),o}static VE(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Y(B[E],B[E+1],B[E+2])}static FromFloatArray(B,E){return Y.VE(B,E)}static FromArrayToRef(B,E,v){return v._x=B[E],v._y=B[E+1],v._z=B[E+2],v._isDirty=!0,v}static FromFloatArrayToRef(B,E,v){return Y.FromArrayToRef(B,E,v)}static FromFloatsToRef(B,E,v,z){return z.Yc(B,E,v),z}static Zero(){return new Y(0,0,0)}static One(){return new Y(1,1,1)}static Up(){return new Y(0,1,0)}static get UpReadOnly(){return Y._UpReadOnly}static get DownReadOnly(){return Y._DownReadOnly}static get RightReadOnly(){return Y._RightReadOnly}static get LeftReadOnly(){return Y._LeftReadOnly}static get LeftHandedForwardReadOnly(){return Y._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return Y._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return Y._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return Y._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return Y._ZeroReadOnly}static get OneReadOnly(){return Y._OneReadOnly}static Down(){return new Y(0,-1,0)}static Forward(){return new Y(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new Y(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new Y(1,0,0)}static Left(){return new Y(-1,0,0)}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Y((0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Yc((0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E))}static TransformCoordinates(B,E){const v=Y.Zero();return Y.TransformCoordinatesToRef(B,E,v),v}static TransformCoordinatesToRef(B,E,v){return Y.TransformCoordinatesFromFloatsToRef(B._x,B._y,B._z,E,v),v}static TransformCoordinatesFromFloatsToRef(B,E,v,z,o){const q=z.m,c=B*q[0]+E*q[4]+v*q[8]+q[12],S=B*q[1]+E*q[5]+v*q[9]+q[13],x=B*q[2]+E*q[6]+v*q[10]+q[14],D=1/(B*q[3]+E*q[7]+v*q[11]+q[15]);return o._x=c*D,o._y=S*D,o._z=x*D,o._isDirty=!0,o}static TransformNormal(B,E){const v=Y.Zero();return Y.TransformNormalToRef(B,E,v),v}static TransformNormalToRef(B,E,v){return this.TransformNormalFromFloatsToRef(B._x,B._y,B._z,E,v),v}static TransformNormalFromFloatsToRef(B,E,v,z,o){const q=z.m;return o._x=B*q[0]+E*q[4]+v*q[8],o._y=B*q[1]+E*q[5]+v*q[9],o._z=B*q[2]+E*q[6]+v*q[10],o._isDirty=!0,o}static CatmullRom(B,E,v,z,o){const q=o*o,c=o*q,S=.5*(2*E._x+(-B._x+v._x)*o+(2*B._x-5*E._x+4*v._x-z._x)*q+(-B._x+3*E._x-3*v._x+z._x)*c),x=.5*(2*E._y+(-B._y+v._y)*o+(2*B._y-5*E._y+4*v._y-z._y)*q+(-B._y+3*E._y-3*v._y+z._y)*c),D=.5*(2*E._z+(-B._z+v._z)*o+(2*B._z-5*E._z+4*v._z-z._z)*q+(-B._z+3*E._z-3*v._z+z._z)*c);return new Y(S,x,D)}static Clamp(B,E,v){const z=new Y;return Y.ClampToRef(B,E,v,z),z}static ClampToRef(B,E,v,z){let o=B._x;o=o>v._x?v._x:o,o=o<E._x?E._x:o;let q=B._y;q=q>v._y?v._y:q,q=q<E._y?E._y:q;let c=B._z;return c=c>v._z?v._z:c,c=c<E._z?E._z:c,z.Yc(o,q,c),z}static CheckExtends(B,E,v){E.minimizeInPlace(B),v.maximizeInPlace(B)}static Hermite(B,E,v,z,o){const q=o*o,c=o*q,S=2*c-3*q+1,x=-2*c+3*q,D=c-2*q+o,h=c-q,y=B._x*S+v._x*x+E._x*D+z._x*h,Q=B._y*S+v._y*x+E._y*D+z._y*h,P=B._z*S+v._z*x+E._z*D+z._z*h;return new Y(y,Q,P)}static Hermite1stDerivative(B,E,v,z,o){const q=new Y;return this.Hermite1stDerivativeToRef(B,E,v,z,o,q),q}static Hermite1stDerivativeToRef(B,E,v,z,o,q){const c=o*o;return q._x=6*(c-o)*B._x+(3*c-4*o+1)*E._x+6*(-c+o)*v._x+(3*c-2*o)*z._x,q._y=6*(c-o)*B._y+(3*c-4*o+1)*E._y+6*(-c+o)*v._y+(3*c-2*o)*z._y,q._z=6*(c-o)*B._z+(3*c-4*o+1)*E._z+6*(-c+o)*v._z+(3*c-2*o)*z._z,q._isDirty=!0,q}static Lerp(B,E,v){const z=new Y(0,0,0);return Y.LerpToRef(B,E,v,z),z}static LerpToRef(B,E,v,z){return z._x=B._x+(E._x-B._x)*v,z._y=B._y+(E._y-B._y)*v,z._z=B._z+(E._z-B._z)*v,z._isDirty=!0,z}static Dot(B,E){return B._x*E._x+B._y*E._y+B._z*E._z}dot(B){return this._x*B._x+this._y*B._y+this._z*B._z}static Cross(B,E){const v=new Y;return Y.CrossToRef(B,E,v),v}static CrossToRef(B,E,v){const z=B._y*E._z-B._z*E._y,o=B._z*E._x-B._x*E._z,q=B._x*E._y-B._y*E._x;return v.Yc(z,o,q),v}static Normalize(B){const E=Y.Zero();return Y.NormalizeToRef(B,E),E}static NormalizeToRef(B,E){return B.normalizeToRef(E),E}static Project(B,E,v,z){const o=new Y;return Y.ProjectToRef(B,E,v,z,o),o}static ProjectToRef(B,E,v,z,o){var q;const c=z.width,x=z.height,D=z.x,h=z.y,y=V.Matrix[1],Q=null===(q=S.b.LastCreatedEngine)||void 0===q?void 0:q.isNDCHalfZRange,P=Q?1:.5,G=Q?0:.5;g.FromValuesToRef(c/2,0,0,0,0,-x/2,0,0,0,0,P,0,D+c/2,x/2+h,G,1,y);const a=V.Matrix[0];return E.multiplyToRef(v,a),a.multiplyToRef(y,a),Y.TransformCoordinatesToRef(B,a,o),o}static Reflect(B,E){return this.ReflectToRef(B,E,new Y)}static ReflectToRef(B,E,v){const z=T.GE[0];return z.S(E).scaleInPlace(2*Y.Dot(B,E)),v.S(B).wy(z)}static _UnprojectFromInvertedMatrixToRef(B,E,v){Y.TransformCoordinatesToRef(B,E,v);const z=E.m,o=B._x*z[3]+B._y*z[7]+B._z*z[11]+z[15];return(0,x.WithinEpsilon)(o,1)&&v.scaleInPlace(1/o),v}static UnprojectFromTransform(B,E,v,z,o){return this.Unproject(B,E,v,z,o,g.IdentityReadOnly)}static Unproject(B,E,v,z,o,q){const c=new Y;return Y.UnprojectToRef(B,E,v,z,o,q,c),c}static UnprojectToRef(B,E,v,z,o,q,c){return Y.UnprojectFloatsToRef(B._x,B._y,B._z,E,v,z,o,q,c),c}static UnprojectFloatsToRef(B,E,v,z,o,q,c,x,D){var h;const y=V.Matrix[0];q.multiplyToRef(c,y),y.multiplyToRef(x,y),y.invert();const Q=V.GE[0];return Q.x=B/z*2-1,Q.y=-(E/o*2-1),null!==(h=S.b.LastCreatedEngine)&&void 0!==h&&h.isNDCHalfZRange?Q.z=v:Q.z=2*v-1,Y._UnprojectFromInvertedMatrixToRef(Q,y,D),D}static Minimize(B,E){const v=new Y;return v.S(B),v.minimizeInPlace(E),v}static Maximize(B,E){const v=new Y;return v.S(B),v.maximizeInPlace(E),v}static Distance(B,E){return Math.sqrt(Y.DistanceSquared(B,E))}static DistanceSquared(B,E){const v=B._x-E._x,z=B._y-E._y,o=B._z-E._z;return v*v+z*z+o*o}static ProjectOnTriangleToRef(B,E,v,o,q){const c=V.GE[0],S=V.GE[1],D=V.GE[2],h=V.GE[3],y=V.GE[4];v.subtractToRef(E,c),o.subtractToRef(E,S),o.subtractToRef(v,D);const Q=c.length(),P=S.length(),G=D.length();if(Q<z.e||P<z.e||G<z.e)return q.S(E),Y.Distance(B,E);B.subtractToRef(E,y),Y.CrossToRef(c,S,h);const a=h.length();if(a<z.e)return q.S(E),Y.Distance(B,E);h.normalizeFromLength(a);let m=y.length();if(m<z.e)return q.S(E),0;y.normalizeFromLength(m);const g=Y.Dot(h,y),T=V.GE[5],N=V.GE[6];T.S(h).scaleInPlace(-m*g),N.S(B).addInPlace(T);const X=V.GE[4],r=V.GE[5],i=V.GE[7],u=V.GE[8];X.S(c).scaleInPlace(1/Q),u.S(S).scaleInPlace(1/P),X.addInPlace(u).scaleInPlace(-1),r.S(c).scaleInPlace(-1/Q),u.S(D).scaleInPlace(1/G),r.addInPlace(u).scaleInPlace(-1),i.S(D).scaleInPlace(-1/G),u.S(S).scaleInPlace(-1/P),i.addInPlace(u).scaleInPlace(-1);const I=V.GE[9];let K;I.S(N).wy(E),Y.CrossToRef(X,I,u),K=Y.Dot(u,h);const C=K;I.S(N).wy(v),Y.CrossToRef(r,I,u),K=Y.Dot(u,h);const f=K;I.S(N).wy(o),Y.CrossToRef(i,I,u),K=Y.Dot(u,h);const A=K,l=V.GE[10];let d,t;C>0&&f<0?(l.S(c),d=E,t=v):f>0&&A<0?(l.S(D),d=v,t=o):(l.S(S).scaleInPlace(-1),d=o,t=E);const p=V.GE[9],H=V.GE[4];d.subtractToRef(N,u),t.subtractToRef(N,p),Y.CrossToRef(u,p,H);if(!(Y.Dot(H,h)<0))return q.S(N),Math.abs(m*g);const j=V.GE[5];Y.CrossToRef(l,H,j),j.normalize();const R=V.GE[9];R.S(d).wy(N);const b=R.length();if(b<z.e)return q.S(d),Y.Distance(B,d);R.normalizeFromLength(b);const F=Y.Dot(j,R),W=V.GE[7];W.S(N).addInPlace(j.scaleInPlace(b*F)),u.S(W).wy(d),m=l.length(),l.normalizeFromLength(m);let w=Y.Dot(u,l)/Math.max(m,z.e);return w=(0,x.Clamp)(w,0,1),W.S(d).addInPlace(l.scaleInPlace(w*m)),q.S(W),Y.Distance(B,W)}static Center(B,E){return Y.CenterToRef(B,E,Y.Zero())}static CenterToRef(B,E,v){return v.Yc((B._x+E._x)/2,(B._y+E._y)/2,(B._z+E._z)/2)}static RotationFromAxis(B,E,v){const z=new Y;return Y.RotationFromAxisToRef(B,E,v,z),z}static RotationFromAxisToRef(B,E,v,z){const o=V.Quaternion[0];return m.RotationQuaternionFromAxisToRef(B,E,v,o),o.toEulerAnglesToRef(z),z}}Y._V8PerformanceHack=new Y(.5,.5,.5),Y._UpReadOnly=Y.Up(),Y._DownReadOnly=Y.Down(),Y._LeftHandedForwardReadOnly=Y.Forward(!1),Y._RightHandedForwardReadOnly=Y.Forward(!0),Y._LeftHandedBackwardReadOnly=Y.Backward(!1),Y._RightHandedBackwardReadOnly=Y.Backward(!0),Y._RightReadOnly=Y.Right(),Y._LeftReadOnly=Y.Left(),Y._ZeroReadOnly=Y.Zero(),Y._OneReadOnly=Y.One(),Object.defineProperties(Y.prototype,{dimension:{value:[3]},rank:{value:1}});class a{get x(){return this._x}set x(B){this._x=B,this._isDirty=!0}get y(){return this._y}set y(B){this._y=B,this._isDirty=!0}get z(){return this._z}set z(B){this._z=B,this._isDirty=!0}get w(){return this._w}set w(B){this._w=B,this._isDirty=!0}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=B,this._y=E,this._z=v,this._w=z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let B=P(this._x);return B=397*B^P(this._y),B=397*B^P(this._z),B=397*B^P(this._w),B}cc(){return[this._x,this._y,this._z,this._w]}toArray(B,E){return void 0===E&&(E=0),B[E]=this._x,B[E+1]=this._y,B[E+2]=this._z,B[E+3]=this._w,this}Qv(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return a.FromArrayToRef(B,E,this),this}addInPlace(B){return this.x+=B._x,this.y+=B._y,this.z+=B._z,this.w+=B._w,this}addInPlaceFromFloats(B,E,v,z){return this.x+=B,this.y+=E,this.z+=v,this.w+=z,this}add(B){return new a(this._x+B.x,this._y+B.y,this._z+B.z,this._w+B.w)}addToRef(B,E){return E.x=this._x+B.x,E.y=this._y+B.y,E.z=this._z+B.z,E.w=this._w+B.w,E}wy(B){return this.x-=B.x,this.y-=B.y,this.z-=B.z,this.w-=B.w,this}YE(B){return new a(this._x-B.x,this._y-B.y,this._z-B.z,this._w-B.w)}subtractToRef(B,E){return E.x=this._x-B.x,E.y=this._y-B.y,E.z=this._z-B.z,E.w=this._w-B.w,E}subtractFromFloats(B,E,v,z){return new a(this._x-B,this._y-E,this._z-v,this._w-z)}subtractFromFloatsToRef(B,E,v,z,o){return o.x=this._x-B,o.y=this._y-E,o.z=this._z-v,o.w=this._w-z,o}negate(){return new a(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(B){return B.x=-this._x,B.y=-this._y,B.z=-this._z,B.w=-this._w,B}scaleInPlace(B){return this.x*=B,this.y*=B,this.z*=B,this.w*=B,this}scale(B){return new a(this._x*B,this._y*B,this._z*B,this._w*B)}scaleToRef(B,E){return E.x=this._x*B,E.y=this._y*B,E.z=this._z*B,E.w=this._w*B,E}scaleAndAddToRef(B,E){return E.x+=this._x*B,E.y+=this._y*B,E.z+=this._z*B,E.w+=this._w*B,E}equals(B){return B&&this._x===B.x&&this._y===B.y&&this._z===B.z&&this._w===B.w}equalsWithEpsilon(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.e;return B&&(0,x.WithinEpsilon)(this._x,B.x,E)&&(0,x.WithinEpsilon)(this._y,B.y,E)&&(0,x.WithinEpsilon)(this._z,B.z,E)&&(0,x.WithinEpsilon)(this._w,B.w,E)}equalsToFloats(B,E,v,z){return this._x===B&&this._y===E&&this._z===v&&this._w===z}multiplyInPlace(B){return this.x*=B.x,this.y*=B.y,this.z*=B.z,this.w*=B.w,this}multiply(B){return new a(this._x*B.x,this._y*B.y,this._z*B.z,this._w*B.w)}multiplyToRef(B,E){return E.x=this._x*B.x,E.y=this._y*B.y,E.z=this._z*B.z,E.w=this._w*B.w,E}multiplyByFloats(B,E,v,z){return new a(this._x*B,this._y*E,this._z*v,this._w*z)}divide(B){return new a(this._x/B.x,this._y/B.y,this._z/B.z,this._w/B.w)}divideToRef(B,E){return E.x=this._x/B.x,E.y=this._y/B.y,E.z=this._z/B.z,E.w=this._w/B.w,E}divideInPlace(B){return this.divideToRef(B,this)}minimizeInPlace(B){return B.x<this._x&&(this.x=B.x),B.y<this._y&&(this.y=B.y),B.z<this._z&&(this.z=B.z),B.w<this._w&&(this.w=B.w),this}maximizeInPlace(B){return B.x>this._x&&(this.x=B.x),B.y>this._y&&(this.y=B.y),B.z>this._z&&(this.z=B.z),B.w>this._w&&(this.w=B.w),this}minimizeInPlaceFromFloats(B,E,v,z){return this.x=Math.min(B,this._x),this.y=Math.min(E,this._y),this.z=Math.min(v,this._z),this.w=Math.min(z,this._w),this}maximizeInPlaceFromFloats(B,E,v,z){return this.x=Math.max(B,this._x),this.y=Math.max(E,this._y),this.z=Math.max(v,this._z),this.w=Math.max(z,this._w),this}floorToRef(B){return B.x=Math.floor(this._x),B.y=Math.floor(this._y),B.z=Math.floor(this._z),B.w=Math.floor(this._w),B}floor(){return new a(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(B){return B.x=this._x-Math.floor(this._x),B.y=this._y-Math.floor(this._y),B.z=this._z-Math.floor(this._z),B.w=this._w-Math.floor(this._w),B}fract(){return new a(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){return this.normalizeToRef(new a)}normalizeToRef(B){const E=this.length();return 0===E||1===E?(B.x=this._x,B.y=this._y,B.z=this._z,B.w=this._w,B):this.scaleToRef(1/E,B)}toVector3(){return new Y(this._x,this._y,this._z)}clone(){return new a(this._x,this._y,this._z,this._w)}S(B){return this.x=B.x,this.y=B.y,this.z=B.z,this.w=B.w,this}Yc(B,E,v,z){return this.x=B,this.y=E,this.z=v,this.w=z,this}set(B,E,v,z){return this.Yc(B,E,v,z)}mc(B){return this.x=this.y=this.z=this.w=B,this}dot(B){return this._x*B.x+this._y*B.y+this._z*B.z+this._w*B.w}static VE(B,E){return E||(E=0),new a(B[E],B[E+1],B[E+2],B[E+3])}static FromArrayToRef(B,E,v){return v.x=B[E],v.y=B[E+1],v.z=B[E+2],v.w=B[E+3],v}static FromFloatArrayToRef(B,E,v){return a.FromArrayToRef(B,E,v),v}static FromFloatsToRef(B,E,v,z,o){return o.x=B,o.y=E,o.z=v,o.w=z,o}static Zero(){return new a(0,0,0,0)}static One(){return new a(1,1,1,1)}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new a((0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,v=arguments.length>2?arguments[2]:void 0;return v.x=(0,x.RandomRange)(B,E),v.y=(0,x.RandomRange)(B,E),v.z=(0,x.RandomRange)(B,E),v.w=(0,x.RandomRange)(B,E),v}static Clamp(B,E,v){return a.ClampToRef(B,E,v,new a)}static ClampToRef(B,E,v,z){return z.x=(0,x.Clamp)(B.x,E.x,v.x),z.y=(0,x.Clamp)(B.y,E.y,v.y),z.z=(0,x.Clamp)(B.z,E.z,v.z),z.w=(0,x.Clamp)(B.w,E.w,v.w),z}static CheckExtends(B,E,v){E.minimizeInPlace(B),v.maximizeInPlace(B)}static get ZeroReadOnly(){return a._ZeroReadOnly}static Normalize(B){return a.NormalizeToRef(B,new a)}static NormalizeToRef(B,E){return B.normalizeToRef(E),E}static Minimize(B,E){const v=new a;return v.S(B),v.minimizeInPlace(E),v}static Maximize(B,E){const v=new a;return v.S(B),v.maximizeInPlace(E),v}static Distance(B,E){return Math.sqrt(a.DistanceSquared(B,E))}static DistanceSquared(B,E){const v=B.x-E.x,z=B.y-E.y,o=B.z-E.z,q=B.w-E.w;return v*v+z*z+o*o+q*q}static Center(B,E){return a.CenterToRef(B,E,new a)}static CenterToRef(B,E,v){return v.x=(B.x+E.x)/2,v.y=(B.y+E.y)/2,v.z=(B.z+E.z)/2,v.w=(B.w+E.w)/2,v}static TransformCoordinates(B,E){return a.TransformCoordinatesToRef(B,E,new a)}static TransformCoordinatesToRef(B,E,v){return a.TransformCoordinatesFromFloatsToRef(B._x,B._y,B._z,E,v),v}static TransformCoordinatesFromFloatsToRef(B,E,v,z,o){const q=z.m,c=B*q[0]+E*q[4]+v*q[8]+q[12],S=B*q[1]+E*q[5]+v*q[9]+q[13],x=B*q[2]+E*q[6]+v*q[10]+q[14],D=B*q[3]+E*q[7]+v*q[11]+q[15];return o.x=c,o.y=S,o.z=x,o.w=D,o}static TransformNormal(B,E){return a.TransformNormalToRef(B,E,new a)}static TransformNormalToRef(B,E,v){const z=E.m,o=B.x*z[0]+B.y*z[4]+B.z*z[8],q=B.x*z[1]+B.y*z[5]+B.z*z[9],c=B.x*z[2]+B.y*z[6]+B.z*z[10];return v.x=o,v.y=q,v.z=c,v.w=B.w,v}static TransformNormalFromFloatsToRef(B,E,v,z,o,q){const c=o.m;return q.x=B*c[0]+E*c[4]+v*c[8],q.y=B*c[1]+E*c[5]+v*c[9],q.z=B*c[2]+E*c[6]+v*c[10],q.w=z,q}static FromVector3(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new a(B._x,B._y,B._z,E)}static Dot(B,E){return B.x*E.x+B.y*E.y+B.z*E.z+B.w*E.w}}a._V8PerformanceHack=new a(.5,.5,.5,.5),a._ZeroReadOnly=a.Zero(),Object.defineProperties(a.prototype,{dimension:{value:[4]},rank:{value:1}});class m{get x(){return this._x}set x(B){this._x=B,this._isDirty=!0}get y(){return this._y}set y(B){this._y=B,this._isDirty=!0}get z(){return this._z}set z(B){this._z=B,this._isDirty=!0}get w(){return this._w}set w(B){this._w=B,this._isDirty=!0}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=B,this._y=E,this._z=v,this._w=z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let B=P(this._x);return B=397*B^P(this._y),B=397*B^P(this._z),B=397*B^P(this._w),B}cc(){return[this._x,this._y,this._z,this._w]}toArray(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[E]=this._x,B[E+1]=this._y,B[E+2]=this._z,B[E+3]=this._w,this}Qv(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return m.FromArrayToRef(B,E,this)}equals(B){return B&&this._x===B._x&&this._y===B._y&&this._z===B._z&&this._w===B._w}equalsWithEpsilon(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.e;return B&&(0,x.WithinEpsilon)(this._x,B._x,E)&&(0,x.WithinEpsilon)(this._y,B._y,E)&&(0,x.WithinEpsilon)(this._z,B._z,E)&&(0,x.WithinEpsilon)(this._w,B._w,E)}isApprox(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.e;return B&&((0,x.WithinEpsilon)(this._x,B._x,E)&&(0,x.WithinEpsilon)(this._y,B._y,E)&&(0,x.WithinEpsilon)(this._z,B._z,E)&&(0,x.WithinEpsilon)(this._w,B._w,E)||(0,x.WithinEpsilon)(this._x,-B._x,E)&&(0,x.WithinEpsilon)(this._y,-B._y,E)&&(0,x.WithinEpsilon)(this._z,-B._z,E)&&(0,x.WithinEpsilon)(this._w,-B._w,E))}clone(){return new m(this._x,this._y,this._z,this._w)}S(B){return this._x=B._x,this._y=B._y,this._z=B._z,this._w=B._w,this._isDirty=!0,this}Yc(B,E,v,z){return this._x=B,this._y=E,this._z=v,this._w=z,this._isDirty=!0,this}set(B,E,v,z){return this.Yc(B,E,v,z)}mc(B){return this.Yc(B,B,B,B)}add(B){return new m(this._x+B._x,this._y+B._y,this._z+B._z,this._w+B._w)}addInPlace(B){return this._x+=B._x,this._y+=B._y,this._z+=B._z,this._w+=B._w,this._isDirty=!0,this}addToRef(B,E){return E._x=this._x+B._x,E._y=this._y+B._y,E._z=this._z+B._z,E._w=this._w+B._w,E._isDirty=!0,E}addInPlaceFromFloats(B,E,v,z){return this._x+=B,this._y+=E,this._z+=v,this._w+=z,this._isDirty=!0,this}subtractToRef(B,E){return E._x=this._x-B._x,E._y=this._y-B._y,E._z=this._z-B._z,E._w=this._w-B._w,E._isDirty=!0,E}subtractFromFloats(B,E,v,z){return this.subtractFromFloatsToRef(B,E,v,z,new m)}subtractFromFloatsToRef(B,E,v,z,o){return o._x=this._x-B,o._y=this._y-E,o._z=this._z-v,o._w=this._w-z,o._isDirty=!0,o}YE(B){return new m(this._x-B._x,this._y-B._y,this._z-B._z,this._w-B._w)}wy(B){return this._x-=B._x,this._y-=B._y,this._z-=B._z,this._w-=B._w,this._isDirty=!0,this}scale(B){return new m(this._x*B,this._y*B,this._z*B,this._w*B)}scaleToRef(B,E){return E._x=this._x*B,E._y=this._y*B,E._z=this._z*B,E._w=this._w*B,E._isDirty=!0,E}scaleInPlace(B){return this._x*=B,this._y*=B,this._z*=B,this._w*=B,this._isDirty=!0,this}scaleAndAddToRef(B,E){return E._x+=this._x*B,E._y+=this._y*B,E._z+=this._z*B,E._w+=this._w*B,E._isDirty=!0,E}multiply(B){const E=new m(0,0,0,1);return this.multiplyToRef(B,E),E}multiplyToRef(B,E){const v=this._x*B._w+this._y*B._z-this._z*B._y+this._w*B._x,z=-this._x*B._z+this._y*B._w+this._z*B._x+this._w*B._y,o=this._x*B._y-this._y*B._x+this._z*B._w+this._w*B._z,q=-this._x*B._x-this._y*B._y-this._z*B._z+this._w*B._w;return E.Yc(v,z,o,q),E}multiplyInPlace(B){return this.multiplyToRef(B,this)}multiplyByFloats(B,E,v,z){return this._x*=B,this._y*=E,this._z*=v,this._w*=z,this._isDirty=!0,this}divide(B){throw new ReferenceError("Can not divide a quaternion")}divideToRef(B,E){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(B){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new m)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(B){return B._x=-this._x,B._y=-this._y,B._z=-this._z,B._w=-this._w,B._isDirty=!0,B}equalsToFloats(B,E,v,z){return this._x===B&&this._y===E&&this._z===v&&this._w===z}floorToRef(B){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(B){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(B){return B.Yc(-this._x,-this._y,-this._z,this._w),B}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new m(-this._x,-this._y,-this._z,this._w)}invert(){const B=this.conjugate(),E=this.lengthSquared();return 0==E||1==E||B.scaleInPlace(1/E),B}invertInPlace(){this.conjugateInPlace();const B=this.lengthSquared();return 0==B||1==B||this.scaleInPlace(1/B),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){const B=new m(0,0,0,1);return this.normalizeToRef(B),B}normalizeToRef(B){const E=this.length();return 0===E||1===E?B.Yc(this._x,this._y,this._z,this._w):this.scaleToRef(1/E,B)}toEulerAngles(){const B=Y.Zero();return this.toEulerAnglesToRef(B),B}toEulerAnglesToRef(B){const E=this._z,v=this._x,z=this._y,o=this._w,q=z*E-v*o,c=.4999999;if(q<-c)B._y=2*Math.atan2(z,o),B._x=Math.PI/2,B._z=0,B._isDirty=!0;else if(q>c)B._y=2*Math.atan2(z,o),B._x=-Math.PI/2,B._z=0,B._isDirty=!0;else{const c=o*o,S=E*E,x=v*v,D=z*z;B._z=Math.atan2(2*(v*z+E*o),-S-x+D+c),B._x=Math.asin(-2*q),B._y=Math.atan2(2*(E*v+z*o),S-x-D+c),B._isDirty=!0}return B}toAlphaBetaGammaToRef(B){const E=this._z,v=this._x,z=this._y,o=this._w,q=Math.sqrt(v*v+z*z),c=Math.sqrt(E*E+o*o),S=2*Math.atan2(q,c),x=2*Math.atan2(E,o),D=2*Math.atan2(z,v),h=(x+D)/2,y=(x-D)/2;return B.set(y,S,h),B}toRotationMatrix(B){return g.FromQuaternionToRef(this,B),B}fromRotationMatrix(B){return m.FromRotationMatrixToRef(B,this),this}dot(B){return this._x*B._x+this._y*B._y+this._z*B._z+this._w*B._w}toAxisAngle(){const B=Y.Zero();return{axis:B,angle:this.toAxisAngleToRef(B)}}toAxisAngleToRef(B){let E=0;const v=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),z=this._w;return v>0?(E=2*Math.atan2(v,z),B.set(this._x/v,this._y/v,this._z/v)):(E=0,B.set(1,0,0)),E}static FromRotationMatrix(B){const E=new m;return m.FromRotationMatrixToRef(B,E),E}static FromRotationMatrixToRef(B,E){const v=B.m,z=v[0],o=v[4],q=v[8],c=v[1],S=v[5],x=v[9],D=v[2],h=v[6],y=v[10],Q=z+S+y;let P;return Q>0?(P=.5/Math.sqrt(Q+1),E._w=.25/P,E._x=(h-x)*P,E._y=(q-D)*P,E._z=(c-o)*P,E._isDirty=!0):z>S&&z>y?(P=2*Math.sqrt(1+z-S-y),E._w=(h-x)/P,E._x=.25*P,E._y=(o+c)/P,E._z=(q+D)/P,E._isDirty=!0):S>y?(P=2*Math.sqrt(1+S-z-y),E._w=(q-D)/P,E._x=(o+c)/P,E._y=.25*P,E._z=(x+h)/P,E._isDirty=!0):(P=2*Math.sqrt(1+y-z-S),E._w=(c-o)/P,E._x=(q+D)/P,E._y=(x+h)/P,E._z=.25*P,E._isDirty=!0),E}static Dot(B,E){return B._x*E._x+B._y*E._y+B._z*E._z+B._w*E._w}static AreClose(B,E){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const z=m.Dot(B,E);return 1-z*z<=v}static SmoothToRef(B,E,v,z,o){let q=0===z?1:v/z;return q=(0,x.Clamp)(q,0,1),m.SlerpToRef(B,E,q,o),o}static Zero(){return new m(0,0,0,0)}static Inverse(B){return new m(-B._x,-B._y,-B._z,B._w)}static InverseToRef(B,E){return E.set(-B._x,-B._y,-B._z,B._w),E}static Identity(){return new m(0,0,0,1)}static IsIdentity(B){return B&&0===B._x&&0===B._y&&0===B._z&&1===B._w}static RotationAxis(B,E){return m.RotationAxisToRef(B,E,new m)}static RotationAxisToRef(B,E,v){v._w=Math.cos(E/2);const z=Math.sin(E/2)/B.length();return v._x=B._x*z,v._y=B._y*z,v._z=B._z*z,v._isDirty=!0,v}static VE(B,E){return E||(E=0),new m(B[E],B[E+1],B[E+2],B[E+3])}static FromArrayToRef(B,E,v){return v._x=B[E],v._y=B[E+1],v._z=B[E+2],v._w=B[E+3],v._isDirty=!0,v}static FromFloatsToRef(B,E,v,z,o){return o.Yc(B,E,v,z),o}static FromEulerAngles(B,E,v){const z=new m;return m.RotationYawPitchRollToRef(E,B,v,z),z}static FromEulerAnglesToRef(B,E,v,z){return m.RotationYawPitchRollToRef(E,B,v,z),z}static FromEulerVector(B){const E=new m;return m.RotationYawPitchRollToRef(B._y,B._x,B._z,E),E}static FromEulerVectorToRef(B,E){return m.RotationYawPitchRollToRef(B._y,B._x,B._z,E),E}static FromUnitVectorsToRef(B,E,v){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z.e;const q=Y.Dot(B,E)+1;return q<o?Math.abs(B.x)>Math.abs(B.z)?v.set(-B.y,B.x,0,0):v.set(0,-B.z,B.y,0):(Y.CrossToRef(B,E,T.GE[0]),v.set(T.GE[0].x,T.GE[0].y,T.GE[0].z,q)),v.normalize()}static RotationYawPitchRoll(B,E,v){const z=new m;return m.RotationYawPitchRollToRef(B,E,v,z),z}static RotationYawPitchRollToRef(B,E,v,z){const o=.5*v,q=.5*E,c=.5*B,S=Math.sin(o),x=Math.cos(o),D=Math.sin(q),h=Math.cos(q),y=Math.sin(c),Q=Math.cos(c);return z._x=Q*D*x+y*h*S,z._y=y*h*x-Q*D*S,z._z=Q*h*S-y*D*x,z._w=Q*h*x+y*D*S,z._isDirty=!0,z}static RotationAlphaBetaGamma(B,E,v){const z=new m;return m.RotationAlphaBetaGammaToRef(B,E,v,z),z}static RotationAlphaBetaGammaToRef(B,E,v,z){const o=.5*(v+B),q=.5*(v-B),c=.5*E;return z._x=Math.cos(q)*Math.sin(c),z._y=Math.sin(q)*Math.sin(c),z._z=Math.sin(o)*Math.cos(c),z._w=Math.cos(o)*Math.cos(c),z._isDirty=!0,z}static RotationQuaternionFromAxis(B,E,v){const z=new m(0,0,0,0);return m.RotationQuaternionFromAxisToRef(B,E,v,z),z}static RotationQuaternionFromAxisToRef(B,E,v,z){const o=V.Matrix[0];return B=B.normalizeToRef(V.GE[0]),E=E.normalizeToRef(V.GE[1]),v=v.normalizeToRef(V.GE[2]),g.FromXYZAxesToRef(B,E,v,o),m.FromRotationMatrixToRef(o,z),z}static FromLookDirectionLH(B,E){const v=new m;return m.FromLookDirectionLHToRef(B,E,v),v}static FromLookDirectionLHToRef(B,E,v){const z=V.Matrix[0];return g.LookDirectionLHToRef(B,E,z),m.FromRotationMatrixToRef(z,v),v}static FromLookDirectionRH(B,E){const v=new m;return m.FromLookDirectionRHToRef(B,E,v),v}static FromLookDirectionRHToRef(B,E,v){const z=V.Matrix[0];return g.LookDirectionRHToRef(B,E,z),m.FromRotationMatrixToRef(z,v)}static Slerp(B,E,v){const z=m.Identity();return m.SlerpToRef(B,E,v,z),z}static SlerpToRef(B,E,v,z){let o,q,c=B._x*E._x+B._y*E._y+B._z*E._z+B._w*E._w,S=!1;if(c<0&&(S=!0,c=-c),c>.999999)q=1-v,o=S?-v:v;else{const B=Math.acos(c),E=1/Math.sin(B);q=Math.sin((1-v)*B)*E,o=S?-Math.sin(v*B)*E:Math.sin(v*B)*E}return z._x=q*B._x+o*E._x,z._y=q*B._y+o*E._y,z._z=q*B._z+o*E._z,z._w=q*B._w+o*E._w,z._isDirty=!0,z}static Hermite(B,E,v,z,o){const q=o*o,c=o*q,S=2*c-3*q+1,x=-2*c+3*q,D=c-2*q+o,h=c-q,y=B._x*S+v._x*x+E._x*D+z._x*h,Q=B._y*S+v._y*x+E._y*D+z._y*h,P=B._z*S+v._z*x+E._z*D+z._z*h,G=B._w*S+v._w*x+E._w*D+z._w*h;return new m(y,Q,P,G)}static Hermite1stDerivative(B,E,v,z,o){const q=new m;return this.Hermite1stDerivativeToRef(B,E,v,z,o,q),q}static Hermite1stDerivativeToRef(B,E,v,z,o,q){const c=o*o;return q._x=6*(c-o)*B._x+(3*c-4*o+1)*E._x+6*(-c+o)*v._x+(3*c-2*o)*z._x,q._y=6*(c-o)*B._y+(3*c-4*o+1)*E._y+6*(-c+o)*v._y+(3*c-2*o)*z._y,q._z=6*(c-o)*B._z+(3*c-4*o+1)*E._z+6*(-c+o)*v._z+(3*c-2*o)*z._z,q._w=6*(c-o)*B._w+(3*c-4*o+1)*E._w+6*(-c+o)*v._w+(3*c-2*o)*z._w,q._isDirty=!0,q}static Normalize(B){const E=m.Zero();return m.NormalizeToRef(B,E),E}static NormalizeToRef(B,E){return B.normalizeToRef(E),E}static Clamp(B,E,v){const z=new m;return m.ClampToRef(B,E,v,z),z}static ClampToRef(B,E,v,z){return z.Yc((0,x.Clamp)(B.x,E.x,v.x),(0,x.Clamp)(B.y,E.y,v.y),(0,x.Clamp)(B.z,E.z,v.z),(0,x.Clamp)(B.w,E.w,v.w))}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new m((0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Yc((0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E),(0,x.RandomRange)(B,E))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(B,E){return Math.sqrt(m.DistanceSquared(B,E))}static DistanceSquared(B,E){const v=B.x-E.x,z=B.y-E.y,o=B.z-E.z,q=B.w-E.w;return v*v+z*z+o*o+q*q}static Center(B,E){return m.CenterToRef(B,E,m.Zero())}static CenterToRef(B,E,v){return v.Yc((B.x+E.x)/2,(B.y+E.y)/2,(B.z+E.z)/2,(B.w+E.w)/2)}}m._V8PerformanceHack=new m(.5,.5,.5,.5),Object.defineProperties(m.prototype,{dimension:{value:[4]},rank:{value:1}});class g{static get Use64Bits(){return c.c.MatrixUse64Bits}get m(){return this.Bc}markAsUpdated(){this.updateFlag=D._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(B){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1],v=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=B,this._isIdentity3x2=B||v,this._isIdentityDirty=!this._isIdentity&&E,this._isIdentity3x2Dirty=!this._isIdentity3x2&&z}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,c.c.MatrixTrackPrecisionChange&&c.c.MatrixTrackedMatrices.push(this),this.Bc=new c.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const B=this.Bc;this._isIdentity=1===B[0]&&0===B[1]&&0===B[2]&&0===B[3]&&0===B[4]&&1===B[5]&&0===B[6]&&0===B[7]&&0===B[8]&&0===B[9]&&1===B[10]&&0===B[11]&&0===B[12]&&0===B[13]&&0===B[14]&&1===B[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Bc[0]||1!==this.Bc[5]||1!==this.Bc[15]||0!==this.Bc[1]||0!==this.Bc[2]||0!==this.Bc[3]||0!==this.Bc[4]||0!==this.Bc[6]||0!==this.Bc[7]||0!==this.Bc[8]||0!==this.Bc[9]||0!==this.Bc[10]||0!==this.Bc[11]||0!==this.Bc[12]||0!==this.Bc[13]||0!==this.Bc[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const B=this.Bc,E=B[0],v=B[1],z=B[2],o=B[3],q=B[4],c=B[5],S=B[6],x=B[7],D=B[8],h=B[9],y=B[10],Q=B[11],P=B[12],G=B[13],Y=B[14],a=B[15],m=y*a-Y*Q,g=h*a-G*Q,V=h*Y-G*y,T=D*a-P*Q,N=D*Y-y*P,X=D*G-P*h;return E*+(c*m-S*g+x*V)+v*-(q*m-S*T+x*N)+z*+(q*g-c*T+x*X)+o*-(q*V-c*N+S*X)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!B)return this.Bc;const v=this.Bc;for(let z=0;z<16;z++)B[E+z]=v[z];return this}cc(){return this.Bc}Qv(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g.FromArrayToRef(B,E,this)}Yc(){for(var B=arguments.length,E=new Array(B),v=0;v<B;v++)E[v]=arguments[v];return g.FromArrayToRef(E,0,this)}set(){const B=this.Bc;for(let E=0;E<16;E++)B[E]=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}mc(B){const E=this.Bc;for(let v=0;v<16;v++)E[v]=B;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return g.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(B){const E=new g;return this.addToRef(B,E),E}addToRef(B,E){const v=this.Bc,z=E.Bc,o=B.m;for(let q=0;q<16;q++)z[q]=v[q]+o[q];return E.markAsUpdated(),E}addToSelf(B){const E=this.Bc,v=B.m;return E[0]+=v[0],E[1]+=v[1],E[2]+=v[2],E[3]+=v[3],E[4]+=v[4],E[5]+=v[5],E[6]+=v[6],E[7]+=v[7],E[8]+=v[8],E[9]+=v[9],E[10]+=v[10],E[11]+=v[11],E[12]+=v[12],E[13]+=v[13],E[14]+=v[14],E[15]+=v[15],this.markAsUpdated(),this}addInPlace(B){const E=this.Bc,v=B.m;for(let z=0;z<16;z++)E[z]+=v[z];return this.markAsUpdated(),this}addInPlaceFromFloats(){const B=this.Bc;for(let E=0;E<16;E++)B[E]+=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}YE(B){const E=this.Bc,v=B.m;for(let z=0;z<16;z++)E[z]-=v[z];return this.markAsUpdated(),this}subtractToRef(B,E){const v=this.Bc,z=B.m,o=E.Bc;for(let q=0;q<16;q++)o[q]=v[q]-z[q];return E.markAsUpdated(),E}wy(B){const E=this.Bc,v=B.m;for(let z=0;z<16;z++)E[z]-=v[z];return this.markAsUpdated(),this}subtractFromFloats(){for(var B=arguments.length,E=new Array(B),v=0;v<B;v++)E[v]=arguments[v];return this.subtractFromFloatsToRef(...E,new g)}subtractFromFloatsToRef(){for(var B=arguments.length,E=new Array(B),v=0;v<B;v++)E[v]=arguments[v];const z=E.pop(),o=this.Bc,q=z.Bc,c=E;for(let S=0;S<16;S++)q[S]=o[S]-c[S];return z.markAsUpdated(),z}invertToRef(B){return!0===this._isIdentity?(g.IdentityToRef(B),B):(Q(this,B.cc())?B.markAsUpdated():B.S(this),B)}addAtIndex(B,E){return this.Bc[B]+=E,this.markAsUpdated(),this}multiplyAtIndex(B,E){return this.Bc[B]*=E,this.markAsUpdated(),this}setTranslationFromFloats(B,E,v){return this.Bc[12]=B,this.Bc[13]=E,this.Bc[14]=v,this.markAsUpdated(),this}addTranslationFromFloats(B,E,v){return this.Bc[12]+=B,this.Bc[13]+=E,this.Bc[14]+=v,this.markAsUpdated(),this}setTranslation(B){return this.setTranslationFromFloats(B._x,B._y,B._z)}getTranslation(){return new Y(this.Bc[12],this.Bc[13],this.Bc[14])}getTranslationToRef(B){return B.x=this.Bc[12],B.y=this.Bc[13],B.z=this.Bc[14],B}removeRotationAndScaling(){const B=this.m;return g.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,B[12],B[13],B[14],B[15],this),this._updateIdentityStatus(0===B[12]&&0===B[13]&&0===B[14]&&1===B[15]),this}S(B){B.copyToArray(this.Bc);const E=B;return this.updateFlag=E.updateFlag,this._updateIdentityStatus(E._isIdentity,E._isIdentityDirty,E._isIdentity3x2,E._isIdentity3x2Dirty),this}copyToArray(B){return y(this,B,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(B){const E=new g;return this.multiplyToRef(B,E),E}multiplyInPlace(B){const E=this.Bc,v=B.m;for(let z=0;z<16;z++)E[z]*=v[z];return this.markAsUpdated(),this}multiplyByFloats(){const B=this.Bc;for(let E=0;E<16;E++)B[E]*=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var B=arguments.length,E=new Array(B),v=0;v<B;v++)E[v]=arguments[v];const z=E.pop(),o=this.Bc,q=z.Bc,c=E;for(let S=0;S<16;S++)q[S]=o[S]*c[S];return z.markAsUpdated(),z}multiplyToRef(B,E){return this._isIdentity?(E.S(B),E):B._isIdentity?(E.S(this),E):(this.multiplyToArray(B,E.Bc,0),E.markAsUpdated(),E)}multiplyToArray(B,E,v){return h(this,B,E,v),this}divide(B){return this.divideToRef(B,new g)}divideToRef(B,E){const v=this.Bc,z=B.m,o=E.Bc;for(let q=0;q<16;q++)o[q]=v[q]/z[q];return E.markAsUpdated(),E}divideInPlace(B){const E=this.Bc,v=B.m;for(let z=0;z<16;z++)E[z]/=v[z];return this.markAsUpdated(),this}minimizeInPlace(B){const E=this.Bc,v=B.m;for(let z=0;z<16;z++)E[z]=Math.min(E[z],v[z]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const B=this.Bc;for(let E=0;E<16;E++)B[E]=Math.min(B[E],E<0||arguments.length<=E?void 0:arguments[E]);return this.markAsUpdated(),this}maximizeInPlace(B){const E=this.Bc,v=B.m;for(let z=0;z<16;z++)E[z]=Math.min(E[z],v[z]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const B=this.Bc;for(let E=0;E<16;E++)B[E]=Math.min(B[E],E<0||arguments.length<=E?void 0:arguments[E]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new g)}negateInPlace(){const B=this.Bc;for(let E=0;E<16;E++)B[E]=-B[E];return this.markAsUpdated(),this}negateToRef(B){const E=this.Bc,v=B.Bc;for(let z=0;z<16;z++)v[z]=-E[z];return B.markAsUpdated(),B}equals(B){const E=B;if(!E)return!1;if((this._isIdentity||E._isIdentity)&&!this._isIdentityDirty&&!E._isIdentityDirty)return this._isIdentity&&E._isIdentity;const v=this.m,z=E.m;return v[0]===z[0]&&v[1]===z[1]&&v[2]===z[2]&&v[3]===z[3]&&v[4]===z[4]&&v[5]===z[5]&&v[6]===z[6]&&v[7]===z[7]&&v[8]===z[8]&&v[9]===z[9]&&v[10]===z[10]&&v[11]===z[11]&&v[12]===z[12]&&v[13]===z[13]&&v[14]===z[14]&&v[15]===z[15]}equalsWithEpsilon(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const v=this.Bc,z=B.m;for(let o=0;o<16;o++)if(!(0,x.WithinEpsilon)(v[o],z[o],E))return!1;return!0}equalsToFloats(){const B=this.Bc;for(let E=0;E<16;E++)if(B[E]!=(E<0||arguments.length<=E?void 0:arguments[E]))return!1;return!0}floor(){return this.floorToRef(new g)}floorToRef(B){const E=this.Bc,v=B.Bc;for(let z=0;z<16;z++)v[z]=Math.floor(E[z]);return B.markAsUpdated(),B}fract(){return this.fractToRef(new g)}fractToRef(B){const E=this.Bc,v=B.Bc;for(let z=0;z<16;z++)v[z]=E[z]-Math.floor(E[z]);return B.markAsUpdated(),B}clone(){const B=new g;return B.S(this),B}getClassName(){return"Matrix"}getHashCode(){let B=P(this.Bc[0]);for(let E=1;E<16;E++)B=397*B^P(this.Bc[E]);return B}decomposeToTransformNode(B){return B.rotationQuaternion=B.rotationQuaternion||new m,this.decompose(B.ac,B.rotationQuaternion,B.position)}decompose(B,E,v,z){let o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return v&&v.mc(0),B&&B.mc(1),E&&E.Yc(0,0,0,1),!0;const q=this.Bc;if(v&&v.Yc(q[12],q[13],q[14]),(B=B||V.GE[0]).x=Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]),B.y=Math.sqrt(q[4]*q[4]+q[5]*q[5]+q[6]*q[6]),B.z=Math.sqrt(q[8]*q[8]+q[9]*q[9]+q[10]*q[10]),z){const E=(o?z.absoluteScaling.x:z.ac.x)<0?-1:1,v=(o?z.absoluteScaling.y:z.ac.y)<0?-1:1,q=(o?z.absoluteScaling.z:z.ac.z)<0?-1:1;B.x*=E,B.y*=v,B.z*=q}else this.determinant()<=0&&(B.y*=-1);if(0===B._x||0===B._y||0===B._z)return E&&E.Yc(0,0,0,1),!1;if(E){const v=1/B._x,z=1/B._y,o=1/B._z;g.FromValuesToRef(q[0]*v,q[1]*v,q[2]*v,0,q[4]*z,q[5]*z,q[6]*z,0,q[8]*o,q[9]*o,q[10]*o,0,0,0,0,1,V.Matrix[0]),m.FromRotationMatrixToRef(V.Matrix[0],E)}return!0}getRow(B){if(B<0||B>3)return null;const E=4*B;return new a(this.Bc[E+0],this.Bc[E+1],this.Bc[E+2],this.Bc[E+3])}getRowToRef(B,E){if(B>=0&&B<=3){const v=4*B;E.x=this.Bc[v+0],E.y=this.Bc[v+1],E.z=this.Bc[v+2],E.w=this.Bc[v+3]}return E}setRow(B,E){return this.setRowFromFloats(B,E.x,E.y,E.z,E.w)}transpose(){const B=new g;return g.TransposeToRef(this,B),B}transposeToRef(B){return g.TransposeToRef(this,B),B}setRowFromFloats(B,E,v,z,o){if(B<0||B>3)return this;const q=4*B;return this.Bc[q+0]=E,this.Bc[q+1]=v,this.Bc[q+2]=z,this.Bc[q+3]=o,this.markAsUpdated(),this}scale(B){const E=new g;return this.scaleToRef(B,E),E}scaleToRef(B,E){for(let v=0;v<16;v++)E.Bc[v]=this.Bc[v]*B;return E.markAsUpdated(),E}scaleAndAddToRef(B,E){for(let v=0;v<16;v++)E.Bc[v]+=this.Bc[v]*B;return E.markAsUpdated(),E}scaleInPlace(B){const E=this.Bc;for(let v=0;v<16;v++)E[v]*=B;return this.markAsUpdated(),this}toNormalMatrix(B){const E=V.Matrix[0];this.invertToRef(E),E.transposeToRef(B);const v=B.Bc;return g.FromValuesToRef(v[0],v[1],v[2],0,v[4],v[5],v[6],0,v[8],v[9],v[10],0,0,0,0,1,B),B}getRotationMatrix(){const B=new g;return this.getRotationMatrixToRef(B),B}getRotationMatrixToRef(B){const E=V.GE[0];if(!this.decompose(E))return g.IdentityToRef(B),B;const v=this.Bc,z=1/E._x,o=1/E._y,q=1/E._z;return g.FromValuesToRef(v[0]*z,v[1]*z,v[2]*z,0,v[4]*o,v[5]*o,v[6]*o,0,v[8]*q,v[9]*q,v[10]*q,0,0,0,0,1,B),B}toggleModelMatrixHandInPlace(){const B=this.Bc;return B[2]*=-1,B[6]*=-1,B[8]*=-1,B[9]*=-1,B[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const B=this.Bc;return B[8]*=-1,B[9]*=-1,B[10]*=-1,B[11]*=-1,this.markAsUpdated(),this}static VE(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const v=new g;return g.FromArrayToRef(B,E,v),v}static FromArrayToRef(B,E,v){for(let z=0;z<16;z++)v.Bc[z]=B[z+E];return v.markAsUpdated(),v}static FromFloat32ArrayToRefScaled(B,E,v,z){return z.Bc[0]=B[0+E]*v,z.Bc[1]=B[1+E]*v,z.Bc[2]=B[2+E]*v,z.Bc[3]=B[3+E]*v,z.Bc[4]=B[4+E]*v,z.Bc[5]=B[5+E]*v,z.Bc[6]=B[6+E]*v,z.Bc[7]=B[7+E]*v,z.Bc[8]=B[8+E]*v,z.Bc[9]=B[9+E]*v,z.Bc[10]=B[10+E]*v,z.Bc[11]=B[11+E]*v,z.Bc[12]=B[12+E]*v,z.Bc[13]=B[13+E]*v,z.Bc[14]=B[14+E]*v,z.Bc[15]=B[15+E]*v,z.markAsUpdated(),z}static get IdentityReadOnly(){return g._IdentityReadOnly}static FromValuesToRef(B,E,v,z,o,q,c,S,x,D,h,y,Q,P,G,Y,a){const m=a.Bc;m[0]=B,m[1]=E,m[2]=v,m[3]=z,m[4]=o,m[5]=q,m[6]=c,m[7]=S,m[8]=x,m[9]=D,m[10]=h,m[11]=y,m[12]=Q,m[13]=P,m[14]=G,m[15]=Y,a.markAsUpdated()}static FromValues(B,E,v,z,o,q,c,S,x,D,h,y,Q,P,G,Y){const a=new g,m=a.Bc;return m[0]=B,m[1]=E,m[2]=v,m[3]=z,m[4]=o,m[5]=q,m[6]=c,m[7]=S,m[8]=x,m[9]=D,m[10]=h,m[11]=y,m[12]=Q,m[13]=P,m[14]=G,m[15]=Y,a.markAsUpdated(),a}static Compose(B,E,v){const z=new g;return g.ComposeToRef(B,E,v,z),z}static ComposeToRef(B,E,v,z){const o=z.Bc,q=E._x,c=E._y,S=E._z,x=E._w,D=q+q,h=c+c,y=S+S,Q=q*D,P=q*h,G=q*y,Y=c*h,a=c*y,m=S*y,g=x*D,V=x*h,T=x*y,N=B._x,X=B._y,r=B._z;return o[0]=(1-(Y+m))*N,o[1]=(P+T)*N,o[2]=(G-V)*N,o[3]=0,o[4]=(P-T)*X,o[5]=(1-(Q+m))*X,o[6]=(a+g)*X,o[7]=0,o[8]=(G+V)*r,o[9]=(a-g)*r,o[10]=(1-(Q+Y))*r,o[11]=0,o[12]=v._x,o[13]=v._y,o[14]=v._z,o[15]=1,z.markAsUpdated(),z}static Identity(){const B=g.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return B._updateIdentityStatus(!0),B}static IdentityToRef(B){return g.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,B),B._updateIdentityStatus(!0),B}static Zero(){const B=g.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return B._updateIdentityStatus(!1),B}static RotationX(B){const E=new g;return g.RotationXToRef(B,E),E}static Invert(B){const E=new g;return B.invertToRef(E),E}static RotationXToRef(B,E){const v=Math.sin(B),z=Math.cos(B);return g.FromValuesToRef(1,0,0,0,0,z,v,0,0,-v,z,0,0,0,0,1,E),E._updateIdentityStatus(1===z&&0===v),E}static RotationY(B){const E=new g;return g.RotationYToRef(B,E),E}static RotationYToRef(B,E){const v=Math.sin(B),z=Math.cos(B);return g.FromValuesToRef(z,0,-v,0,0,1,0,0,v,0,z,0,0,0,0,1,E),E._updateIdentityStatus(1===z&&0===v),E}static RotationZ(B){const E=new g;return g.RotationZToRef(B,E),E}static RotationZToRef(B,E){const v=Math.sin(B),z=Math.cos(B);return g.FromValuesToRef(z,v,0,0,-v,z,0,0,0,0,1,0,0,0,0,1,E),E._updateIdentityStatus(1===z&&0===v),E}static RotationAxis(B,E){const v=new g;return g.RotationAxisToRef(B,E,v),v}static RotationAxisToRef(B,E,v){const z=Math.sin(-E),o=Math.cos(-E),q=1-o;B=B.normalizeToRef(V.GE[0]);const c=v.Bc;return c[0]=B._x*B._x*q+o,c[1]=B._x*B._y*q-B._z*z,c[2]=B._x*B._z*q+B._y*z,c[3]=0,c[4]=B._y*B._x*q+B._z*z,c[5]=B._y*B._y*q+o,c[6]=B._y*B._z*q-B._x*z,c[7]=0,c[8]=B._z*B._x*q-B._y*z,c[9]=B._z*B._y*q+B._x*z,c[10]=B._z*B._z*q+o,c[11]=0,c[12]=0,c[13]=0,c[14]=0,c[15]=1,v.markAsUpdated(),v}static RotationAlignToRef(B,E,v){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const q=Y.Dot(E,B),c=v.Bc;if(q<-1+z.e)c[0]=-1,c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[5]=o?1:-1,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[10]=o?-1:1,c[11]=0;else{const v=Y.Cross(E,B),z=1/(1+q);c[0]=v._x*v._x*z+q,c[1]=v._y*v._x*z-v._z,c[2]=v._z*v._x*z+v._y,c[3]=0,c[4]=v._x*v._y*z+v._z,c[5]=v._y*v._y*z+q,c[6]=v._z*v._y*z-v._x,c[7]=0,c[8]=v._x*v._z*z-v._y,c[9]=v._y*v._z*z+v._x,c[10]=v._z*v._z*z+q,c[11]=0}return c[12]=0,c[13]=0,c[14]=0,c[15]=1,v.markAsUpdated(),v}static RotationYawPitchRoll(B,E,v){const z=new g;return g.RotationYawPitchRollToRef(B,E,v,z),z}static RotationYawPitchRollToRef(B,E,v,z){return m.RotationYawPitchRollToRef(B,E,v,V.Quaternion[0]),V.Quaternion[0].toRotationMatrix(z),z}static Scaling(B,E,v){const z=new g;return g.ScalingToRef(B,E,v,z),z}static ScalingToRef(B,E,v,z){return g.FromValuesToRef(B,0,0,0,0,E,0,0,0,0,v,0,0,0,0,1,z),z._updateIdentityStatus(1===B&&1===E&&1===v),z}static Translation(B,E,v){const z=new g;return g.TranslationToRef(B,E,v,z),z}static TranslationToRef(B,E,v,z){return g.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,B,E,v,1,z),z._updateIdentityStatus(0===B&&0===E&&0===v),z}static Lerp(B,E,v){const z=new g;return g.LerpToRef(B,E,v,z),z}static LerpToRef(B,E,v,z){const o=z.Bc,q=B.m,c=E.m;for(let S=0;S<16;S++)o[S]=q[S]*(1-v)+c[S]*v;return z.markAsUpdated(),z}static DecomposeLerp(B,E,v){const z=new g;return g.DecomposeLerpToRef(B,E,v,z),z}static DecomposeLerpToRef(B,E,v,z){const o=V.GE[0],q=V.Quaternion[0],c=V.GE[1];B.decompose(o,q,c);const S=V.GE[2],x=V.Quaternion[1],D=V.GE[3];E.decompose(S,x,D);const h=V.GE[4];Y.LerpToRef(o,S,v,h);const y=V.Quaternion[2];m.SlerpToRef(q,x,v,y);const Q=V.GE[5];return Y.LerpToRef(c,D,v,Q),g.ComposeToRef(h,y,Q,z),z}static LookAtLH(B,E,v){const z=new g;return g.LookAtLHToRef(B,E,v,z),z}static LookAtLHToRef(B,E,v,z){const o=V.GE[0],q=V.GE[1],c=V.GE[2];E.subtractToRef(B,c),c.normalize(),Y.CrossToRef(v,c,o);const S=o.lengthSquared();0===S?o.x=1:o.normalizeFromLength(Math.sqrt(S)),Y.CrossToRef(c,o,q),q.normalize();const x=-Y.Dot(o,B),D=-Y.Dot(q,B),h=-Y.Dot(c,B);return g.FromValuesToRef(o._x,q._x,c._x,0,o._y,q._y,c._y,0,o._z,q._z,c._z,0,x,D,h,1,z),z}static LookAtRH(B,E,v){const z=new g;return g.LookAtRHToRef(B,E,v,z),z}static LookAtRHToRef(B,E,v,z){const o=V.GE[0],q=V.GE[1],c=V.GE[2];B.subtractToRef(E,c),c.normalize(),Y.CrossToRef(v,c,o);const S=o.lengthSquared();0===S?o.x=1:o.normalizeFromLength(Math.sqrt(S)),Y.CrossToRef(c,o,q),q.normalize();const x=-Y.Dot(o,B),D=-Y.Dot(q,B),h=-Y.Dot(c,B);return g.FromValuesToRef(o._x,q._x,c._x,0,o._y,q._y,c._y,0,o._z,q._z,c._z,0,x,D,h,1,z),z}static LookDirectionLH(B,E){const v=new g;return g.LookDirectionLHToRef(B,E,v),v}static LookDirectionLHToRef(B,E,v){const z=V.GE[0];z.S(B),z.scaleInPlace(-1);const o=V.GE[1];return Y.CrossToRef(E,z,o),g.FromValuesToRef(o._x,o._y,o._z,0,E._x,E._y,E._z,0,z._x,z._y,z._z,0,0,0,0,1,v),v}static LookDirectionRH(B,E){const v=new g;return g.LookDirectionRHToRef(B,E,v),v}static LookDirectionRHToRef(B,E,v){const z=V.GE[2];return Y.CrossToRef(E,B,z),g.FromValuesToRef(z._x,z._y,z._z,0,E._x,E._y,E._z,0,B._x,B._y,B._z,0,0,0,0,1,v),v}static OrthoLH(B,E,v,z,o){const q=new g;return g.OrthoLHToRef(B,E,v,z,q,o),q}static OrthoLHToRef(B,E,v,z,o,q){const c=2/B,S=2/E,x=2/(z-v),D=-(z+v)/(z-v);return g.FromValuesToRef(c,0,0,0,0,S,0,0,0,0,x,0,0,0,D,1,o),q&&o.multiplyToRef(N,o),o._updateIdentityStatus(1===c&&1===S&&1===x&&0===D),o}static OrthoOffCenterLH(B,E,v,z,o,q,c){const S=new g;return g.OrthoOffCenterLHToRef(B,E,v,z,o,q,S,c),S}static OrthoOffCenterLHToRef(B,E,v,z,o,q,c,S){const x=2/(E-B),D=2/(z-v),h=2/(q-o),y=-(q+o)/(q-o),Q=(B+E)/(B-E),P=(z+v)/(v-z);return g.FromValuesToRef(x,0,0,0,0,D,0,0,0,0,h,0,Q,P,y,1,c),S&&c.multiplyToRef(N,c),c.markAsUpdated(),c}static ObliqueOffCenterLHToRef(B,E,v,z,o,q,c,S,x,D,h){const y=-c*Math.cos(S),Q=-c*Math.sin(S);return g.TranslationToRef(0,0,-x,V.Matrix[1]),g.FromValuesToRef(1,0,0,0,0,1,0,0,y,Q,1,0,0,0,0,1,V.Matrix[0]),V.Matrix[1].multiplyToRef(V.Matrix[0],V.Matrix[0]),g.TranslationToRef(0,0,x,V.Matrix[1]),V.Matrix[0].multiplyToRef(V.Matrix[1],V.Matrix[0]),g.OrthoOffCenterLHToRef(B,E,v,z,o,q,D,h),V.Matrix[0].multiplyToRef(D,D),D}static OrthoOffCenterRH(B,E,v,z,o,q,c){const S=new g;return g.OrthoOffCenterRHToRef(B,E,v,z,o,q,S,c),S}static OrthoOffCenterRHToRef(B,E,v,z,o,q,c,S){return g.OrthoOffCenterLHToRef(B,E,v,z,o,q,c,S),c.Bc[10]*=-1,c}static ObliqueOffCenterRHToRef(B,E,v,z,o,q,c,S,x,D,h){const y=c*Math.cos(S),Q=c*Math.sin(S);return g.TranslationToRef(0,0,x,V.Matrix[1]),g.FromValuesToRef(1,0,0,0,0,1,0,0,y,Q,1,0,0,0,0,1,V.Matrix[0]),V.Matrix[1].multiplyToRef(V.Matrix[0],V.Matrix[0]),g.TranslationToRef(0,0,-x,V.Matrix[1]),V.Matrix[0].multiplyToRef(V.Matrix[1],V.Matrix[0]),g.OrthoOffCenterRHToRef(B,E,v,z,o,q,D,h),V.Matrix[0].multiplyToRef(D,D),D}static PerspectiveLH(B,E,v,z,o){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const c=new g,S=2*v/B,x=2*v/E,D=(z+v)/(z-v),h=-2*z*v/(z-v),y=Math.tan(q);return g.FromValuesToRef(S,0,0,0,0,x,0,y,0,0,D,1,0,0,h,0,c),o&&c.multiplyToRef(N,c),c._updateIdentityStatus(!1),c}static PerspectiveFovLH(B,E,v,z,o){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,c=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const S=new g;return g.PerspectiveFovLHToRef(B,E,v,z,S,!0,o,q,c),S}static PerspectiveFovLHToRef(B,E,v,z,o){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],c=arguments.length>6?arguments[6]:void 0,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,x=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const D=v,h=z,y=1/Math.tan(.5*B),Q=q?y/E:y,P=q?y:y*E,G=x&&0===D?-1:0!==h?(h+D)/(h-D):1,Y=x&&0===D?2*h:0!==h?-2*h*D/(h-D):-2*D,a=Math.tan(S);return g.FromValuesToRef(Q,0,0,0,0,P,0,a,0,0,G,1,0,0,Y,0,o),c&&o.multiplyToRef(N,o),o._updateIdentityStatus(!1),o}static PerspectiveFovReverseLHToRef(B,E,v,z,o){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],c=arguments.length>6?arguments[6]:void 0,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const x=1/Math.tan(.5*B),D=q?x/E:x,h=q?x:x*E,y=Math.tan(S);return g.FromValuesToRef(D,0,0,0,0,h,0,y,0,0,-v,1,0,0,1,0,o),c&&o.multiplyToRef(N,o),o._updateIdentityStatus(!1),o}static PerspectiveFovRH(B,E,v,z,o){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,c=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const S=new g;return g.PerspectiveFovRHToRef(B,E,v,z,S,!0,o,q,c),S}static PerspectiveFovRHToRef(B,E,v,z,o){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],c=arguments.length>6?arguments[6]:void 0,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,x=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const D=v,h=z,y=1/Math.tan(.5*B),Q=q?y/E:y,P=q?y:y*E,G=x&&0===D?1:0!==h?-(h+D)/(h-D):-1,Y=x&&0===D?2*h:0!==h?-2*h*D/(h-D):-2*D,a=Math.tan(S);return g.FromValuesToRef(Q,0,0,0,0,P,0,a,0,0,G,-1,0,0,Y,0,o),c&&o.multiplyToRef(N,o),o._updateIdentityStatus(!1),o}static PerspectiveFovReverseRHToRef(B,E,v,z,o){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],c=arguments.length>6?arguments[6]:void 0,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const x=1/Math.tan(.5*B),D=q?x/E:x,h=q?x:x*E,y=Math.tan(S);return g.FromValuesToRef(D,0,0,0,0,h,0,y,0,0,-v,-1,0,0,-1,0,o),c&&o.multiplyToRef(N,o),o._updateIdentityStatus(!1),o}static GetFinalMatrix(B,E,v,z,o,q){const c=B.width,S=B.height,x=B.x,D=B.y,h=g.FromValues(c/2,0,0,0,0,-S/2,0,0,0,0,q-o,0,x+c/2,S/2+D,o,1),y=new g;return E.multiplyToRef(v,y),y.multiplyToRef(z,y),y.multiplyToRef(h,y)}static GetAsMatrix2x2(B){const E=B.m,v=[E[0],E[1],E[4],E[5]];return c.c.MatrixUse64Bits?v:new Float32Array(v)}static GetAsMatrix3x3(B){const E=B.m,v=[E[0],E[1],E[2],E[4],E[5],E[6],E[8],E[9],E[10]];return c.c.MatrixUse64Bits?v:new Float32Array(v)}static Transpose(B){const E=new g;return g.TransposeToRef(B,E),E}static TransposeToRef(B,E){const v=B.m,z=v[0],o=v[4],q=v[8],c=v[12],S=v[1],x=v[5],D=v[9],h=v[13],y=v[2],Q=v[6],P=v[10],G=v[14],Y=v[3],a=v[7],m=v[11],g=v[15],V=E.Bc;return V[0]=z,V[1]=o,V[2]=q,V[3]=c,V[4]=S,V[5]=x,V[6]=D,V[7]=h,V[8]=y,V[9]=Q,V[10]=P,V[11]=G,V[12]=Y,V[13]=a,V[14]=m,V[15]=g,E.markAsUpdated(),E._updateIdentityStatus(B._isIdentity,B._isIdentityDirty),E}static Reflection(B){const E=new g;return g.ReflectionToRef(B,E),E}static ReflectionToRef(B,E){B.normalize();const v=B.normal.x,z=B.normal.y,o=B.normal.z,q=-2*v,c=-2*z,S=-2*o;return g.FromValuesToRef(q*v+1,c*v,S*v,0,q*z,c*z+1,S*z,0,q*o,c*o,S*o+1,0,q*B.d,c*B.d,S*B.d,1,E),E}static FromXYZAxesToRef(B,E,v,z){return g.FromValuesToRef(B._x,B._y,B._z,0,E._x,E._y,E._z,0,v._x,v._y,v._z,0,0,0,0,1,z),z}static FromQuaternionToRef(B,E){const v=B._x*B._x,z=B._y*B._y,o=B._z*B._z,q=B._x*B._y,c=B._z*B._w,S=B._z*B._x,x=B._y*B._w,D=B._y*B._z,h=B._x*B._w;return E.Bc[0]=1-2*(z+o),E.Bc[1]=2*(q+c),E.Bc[2]=2*(S-x),E.Bc[3]=0,E.Bc[4]=2*(q-c),E.Bc[5]=1-2*(o+v),E.Bc[6]=2*(D+h),E.Bc[7]=0,E.Bc[8]=2*(S+x),E.Bc[9]=2*(D-h),E.Bc[10]=1-2*(z+v),E.Bc[11]=0,E.Bc[12]=0,E.Bc[13]=0,E.Bc[14]=0,E.Bc[15]=1,E.markAsUpdated(),E}}g._IdentityReadOnly=g.Identity(),Object.defineProperties(g.prototype,{dimension:{value:[4,4]},rank:{value:2}});class V{}V.GE=(0,o.c)(11,Y.Zero),V.Matrix=(0,o.c)(2,g.Identity),V.Quaternion=(0,o.c)(3,m.Zero);class T{}T.Vector2=(0,o.c)(3,G.Zero),T.GE=(0,o.c)(13,Y.Zero),T.Vector4=(0,o.c)(3,a.Zero),T.Quaternion=(0,o.c)(3,m.Zero),T.Matrix=(0,o.c)(8,g.Identity),(0,q.f)("BABYLON.Vector2",G),(0,q.f)("BABYLON.Vector3",Y),(0,q.f)("BABYLON.Vector4",a),(0,q.f)("BABYLON.Matrix",g);const N=g.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11385:(B,E,v)=>{function z(B,E){const v=[];for(let z=0;z<B;++z)v.push(E());return v}function o(B,E){return z(B,E)}v.d(E,{b:()=>z,c:()=>o,f:()=>c});const q=["push","splice","pop","shift","unshift"];function c(B,E){const v=q.map((v=>function(B,E,v){const z=B[E];if("function"!==typeof z)return null;const o=function(){const z=B.length,q=o.previous.apply(B,arguments);return v(E,z),q};return z.next=o,o.previous=z,B[E]=o,()=>{const v=o.previous;if(!v)return;const z=o.next;z?(v.next=z,z.previous=v):(v.next=void 0,B[E]=v),o.next=void 0,o.previous=void 0}}(B,v,E)));return()=>{for(const B of v)null===B||void 0===B||B()}}}}]);