"use strict";(self.kdlk57exiqh=self.kdlk57exiqh||[]).push([[14],{12253:(i,x,e)=>{e.d(x,{e:()=>Y,h:()=>a,l:()=>j,m:()=>E});const j=1/2.2,E=2.2,a=(1+Math.sqrt(5))/2,Y=.001},12264:(i,x,e)=>{function j(i){return parseInt(i.toString().replace(/\W/g,""))}function E(i,x){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(i-x)<=e}function a(i,x,e){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return i<x-j||i>e+j}function Y(i,x){return i===x?i:Math.random()*(x-i)+i}function J(i,x,e){return i+(x-i)*e}function u(i,x,e){let j=z(x-i,360);return j>180&&(j-=360),i+j*K(e)}function b(i,x,e){let j=0;return j=i!=x?K((e-i)/(x-i)):0,j}function g(i,x,e,j,E){const a=E*E,Y=E*a;return i*(2*Y-3*a+1)+e*(-2*Y+3*a)+x*(Y-2*a+E)+j*(Y-a)}function A(i,x,e,j,E){const a=E*E;return 6*(a-E)*i+(3*a-4*E+1)*x+6*(-a+E)*e+(3*a-2*E)*j}function K(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(e,Math.max(x,i))}function L(i){return i-=2*Math.PI*Math.floor((i+Math.PI)/(2*Math.PI))}function o(i){const x=i.toString(16);return i<=15?("0"+x).toUpperCase():x.toUpperCase()}function M(i){if(Math.log2)return Math.floor(Math.log2(i));if(i<0)return NaN;if(0===i)return-1/0;let x=0;if(i<1){for(;i<1;)x++,i*=2;x=-x}else if(i>1)for(;i>1;)x++,i=Math.floor(i/2);return x}function z(i,x){return i-Math.floor(i/x)*x}function T(i,x,e){return(i-x)/(e-x)}function Q(i,x,e){return i*(e-x)+x}function t(i,x){let e=z(x-i,360);return e>180&&(e-=360),e}function V(i,x){const e=z(i,2*x);return x-Math.abs(e-x)}function S(i,x,e){let j=K(e);return j=-2*j*j*j+3*j*j,x*j+i*(1-j)}function f(i,x,e){let j=0;return j=Math.abs(x-i)<=e?x:i+Math.sign(x-i)*e,j}function w(i,x,e){const j=t(i,x);let E=0;return E=-e<j&&j<e?x:f(i,x=i+j,e),E}function O(i,x,e){return(i-x)/(e-x)}function l(i,x,e){return(e-x)*i+x}function Z(i,x){const e=i%x;return 0===e?x:Z(x,e)}e.r(x),e.d(x,{Clamp:()=>K,DeltaAngle:()=>t,Denormalize:()=>Q,ExtractAsInt:()=>j,Hermite:()=>g,Hermite1stDerivative:()=>A,HighestCommonFactor:()=>Z,ILog2:()=>M,InverseLerp:()=>b,Lerp:()=>J,LerpAngle:()=>u,MoveTowards:()=>f,MoveTowardsAngle:()=>w,Normalize:()=>T,NormalizeRadians:()=>L,OutsideRange:()=>a,PercentToRange:()=>l,PingPong:()=>V,RandomRange:()=>Y,RangeToPercent:()=>O,Repeat:()=>z,SmoothStep:()=>S,ToHex:()=>o,WithinEpsilon:()=>E})},12250:(i,x,e)=>{e.r(x),e.d(x,{Matrix:()=>Q,Quaternion:()=>T,TmpVectors:()=>V,Vector2:()=>o,KJ:()=>M,Vector4:()=>z});var j=e(12253),E=e(12259),a=e(12204),Y=e(12173),J=e(12108),u=e(12264);class b{}function g(i,x,e){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const E=i.de(),a=x.de(),Y=E[0],J=E[1],u=E[2],b=E[3],g=E[4],A=E[5],K=E[6],L=E[7],o=E[8],M=E[9],z=E[10],T=E[11],Q=E[12],t=E[13],V=E[14],S=E[15],f=a[0],w=a[1],O=a[2],l=a[3],Z=a[4],B=a[5],k=a[6],N=a[7],mi=a[8],X=a[9],C=a[10],n=a[11],I=a[12],d=a[13],p=a[14],H=a[15];e[j]=Y*f+J*Z+u*mi+b*I,e[j+1]=Y*w+J*B+u*X+b*d,e[j+2]=Y*O+J*k+u*C+b*p,e[j+3]=Y*l+J*N+u*n+b*H,e[j+4]=g*f+A*Z+K*mi+L*I,e[j+5]=g*w+A*B+K*X+L*d,e[j+6]=g*O+A*k+K*C+L*p,e[j+7]=g*l+A*N+K*n+L*H,e[j+8]=o*f+M*Z+z*mi+T*I,e[j+9]=o*w+M*B+z*X+T*d,e[j+10]=o*O+M*k+z*C+T*p,e[j+11]=o*l+M*N+z*n+T*H,e[j+12]=Q*f+t*Z+V*mi+S*I,e[j+13]=Q*w+t*B+V*X+S*d,e[j+14]=Q*O+t*k+V*C+S*p,e[j+15]=Q*l+t*N+V*n+S*H}function A(i,x){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const j=i.de();x[e]=j[0],x[e+1]=j[1],x[e+2]=j[2],x[e+3]=j[3],x[e+4]=j[4],x[e+5]=j[5],x[e+6]=j[6],x[e+7]=j[7],x[e+8]=j[8],x[e+9]=j[9],x[e+10]=j[10],x[e+11]=j[11],x[e+12]=j[12],x[e+13]=j[13],x[e+14]=j[14],x[e+15]=j[15]}function K(i,x){const e=i.de(),j=e[0],E=e[1],a=e[2],Y=e[3],J=e[4],u=e[5],b=e[6],g=e[7],A=e[8],K=e[9],L=e[10],o=e[11],M=e[12],z=e[13],T=e[14],Q=e[15],t=L*Q-T*o,V=K*Q-z*o,S=K*T-z*L,f=A*Q-M*o,w=A*T-L*M,O=A*z-M*K,l=+(u*t-b*V+g*S),Z=-(J*t-b*f+g*w),B=+(J*V-u*f+g*O),k=-(J*S-u*w+b*O),N=j*l+E*Z+a*B+Y*k;if(0===N)return!1;const mi=1/N,X=b*Q-T*g,C=u*Q-z*g,n=u*T-z*b,I=J*Q-M*g,d=J*T-M*b,p=J*z-M*u,H=b*o-L*g,U=u*o-K*g,D=u*L-K*b,h=J*o-A*g,F=J*L-A*b,R=J*K-A*u,y=-(E*t-a*V+Y*S),r=+(j*t-a*f+Y*w),c=-(j*V-E*f+Y*O),P=+(j*S-E*w+a*O),q=+(E*X-a*C+Y*n),W=-(j*X-a*I+Y*d),G=+(j*C-E*I+Y*p),v=-(j*n-E*d+a*p),s=-(E*H-a*U+Y*D),ii=+(j*H-a*h+Y*F),xi=-(j*U-E*h+Y*R),ei=+(j*D-E*F+a*R);return x[0]=l*mi,x[1]=y*mi,x[2]=q*mi,x[3]=s*mi,x[4]=Z*mi,x[5]=r*mi,x[6]=W*mi,x[7]=ii*mi,x[8]=B*mi,x[9]=c*mi,x[10]=G*mi,x[11]=xi*mi,x[12]=k*mi,x[13]=P*mi,x[14]=v*mi,x[15]=ei*mi,!0}b._UpdateFlagSeed=0;const L=i=>parseInt(i.toString().replace(/\W/g,""));class o{constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=i,this.y=x}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let i=L(this.x);return i=397*i^L(this.y),i}toArray(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return i[x]=this.x,i[x+1]=this.y,this}AJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o.FromArrayToRef(i,x,this),this}de(){return[this.x,this.y]}A(i){return this.x=i.x,this.y=i.y,this}fJ(i,x){return this.x=i,this.y=x,this}set(i,x){return this.fJ(i,x)}OJ(i){return this.fJ(i,i)}add(i){return new o(this.x+i.x,this.y+i.y)}addToRef(i,x){return x.x=this.x+i.x,x.y=this.y+i.y,x}addInPlace(i){return this.x+=i.x,this.y+=i.y,this}addInPlaceFromFloats(i,x){return this.x+=i,this.y+=x,this}addVector3(i){return new o(this.x+i.x,this.y+i.y)}Cx(i){return new o(this.x-i.x,this.y-i.y)}subtractToRef(i,x){return x.x=this.x-i.x,x.y=this.y-i.y,x}jK(i){return this.x-=i.x,this.y-=i.y,this}multiplyInPlace(i){return this.x*=i.x,this.y*=i.y,this}multiply(i){return new o(this.x*i.x,this.y*i.y)}multiplyToRef(i,x){return x.x=this.x*i.x,x.y=this.y*i.y,x}multiplyByFloats(i,x){return new o(this.x*i,this.y*x)}divide(i){return new o(this.x/i.x,this.y/i.y)}divideToRef(i,x){return x.x=this.x/i.x,x.y=this.y/i.y,x}divideInPlace(i){return this.x=this.x/i.x,this.y=this.y/i.y,this}minimizeInPlace(i){return this.minimizeInPlaceFromFloats(i.x,i.y)}maximizeInPlace(i){return this.maximizeInPlaceFromFloats(i.x,i.y)}minimizeInPlaceFromFloats(i,x){return this.x=Math.min(i,this.x),this.y=Math.min(x,this.y),this}maximizeInPlaceFromFloats(i,x){return this.x=Math.max(i,this.x),this.y=Math.max(x,this.y),this}subtractFromFloats(i,x){return new o(this.x-i,this.y-x)}subtractFromFloatsToRef(i,x,e){return e.x=this.x-i,e.y=this.y-x,e}negate(){return new o(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(i){return i.x=-this.x,i.y=-this.y,i}scaleInPlace(i){return this.x*=i,this.y*=i,this}scale(i){return new o(this.x*i,this.y*i)}scaleToRef(i,x){return x.x=this.x*i,x.y=this.y*i,x}scaleAndAddToRef(i,x){return x.x+=this.x*i,x.y+=this.y*i,x}equals(i){return i&&this.x===i.x&&this.y===i.y}equalsWithEpsilon(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.e;return i&&(0,u.WithinEpsilon)(this.x,i.x,x)&&(0,u.WithinEpsilon)(this.y,i.y,x)}equalsToFloats(i,x){return this.x===i&&this.y===x}floor(){return new o(Math.floor(this.x),Math.floor(this.y))}floorToRef(i){return i.x=Math.floor(this.x),i.y=Math.floor(this.y),i}fract(){return new o(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(i){return i.x=this.x-Math.floor(this.x),i.y=this.y-Math.floor(this.y),i}rotate(i){return this.rotateToRef(i,new o)}rotateToRef(i,x){const e=Math.cos(i),j=Math.sin(i);return x.x=e*this.x-j*this.y,x.y=j*this.x+e*this.y,x}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(i){return 0===i||1===i?this:this.scaleInPlace(1/i)}normalizeToNew(){const i=new o;return this.normalizeToRef(i),i}normalizeToRef(i){const x=this.length();return 0===x&&(i.x=this.x,i.y=this.y),this.scaleToRef(1/x,i)}clone(){return new o(this.x,this.y)}dot(i){return this.x*i.x+this.y*i.y}static Zero(){return new o(0,0)}static One(){return new o(1,1)}static Random(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new o((0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x))}static RandomToRef(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fJ((0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x))}static get ZeroReadOnly(){return o._ZeroReadOnly}static zJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new o(i[x],i[x+1])}static FromArrayToRef(i,x,e){return e.x=i[x],e.y=i[x+1],e}static FromFloatsToRef(i,x,e){return e.fJ(i,x),e}static CatmullRom(i,x,e,j,E){const a=E*E,Y=E*a,J=.5*(2*x.x+(-i.x+e.x)*E+(2*i.x-5*x.x+4*e.x-j.x)*a+(-i.x+3*x.x-3*e.x+j.x)*Y),u=.5*(2*x.y+(-i.y+e.y)*E+(2*i.y-5*x.y+4*e.y-j.y)*a+(-i.y+3*x.y-3*e.y+j.y)*Y);return new o(J,u)}static ClampToRef(i,x,e,j){return j.x=(0,u.Clamp)(i.x,x.x,e.x),j.y=(0,u.Clamp)(i.y,x.y,e.y),j}static Clamp(i,x,e){const j=(0,u.Clamp)(i.x,x.x,e.x),E=(0,u.Clamp)(i.y,x.y,e.y);return new o(j,E)}static Hermite(i,x,e,j,E){const a=E*E,Y=E*a,J=2*Y-3*a+1,u=-2*Y+3*a,b=Y-2*a+E,g=Y-a,A=i.x*J+e.x*u+x.x*b+j.x*g,K=i.y*J+e.y*u+x.y*b+j.y*g;return new o(A,K)}static Hermite1stDerivative(i,x,e,j,E){return this.Hermite1stDerivativeToRef(i,x,e,j,E,new o)}static Hermite1stDerivativeToRef(i,x,e,j,E,a){const Y=E*E;return a.x=6*(Y-E)*i.x+(3*Y-4*E+1)*x.x+6*(-Y+E)*e.x+(3*Y-2*E)*j.x,a.y=6*(Y-E)*i.y+(3*Y-4*E+1)*x.y+6*(-Y+E)*e.y+(3*Y-2*E)*j.y,a}static Lerp(i,x,e){return o.LerpToRef(i,x,e,new o)}static LerpToRef(i,x,e,j){return j.x=i.x+(x.x-i.x)*e,j.y=i.y+(x.y-i.y)*e,j}static Dot(i,x){return i.x*x.x+i.y*x.y}static Normalize(i){return o.NormalizeToRef(i,new o)}static NormalizeToRef(i,x){return i.normalizeToRef(x),x}static Minimize(i,x){const e=i.x<x.x?i.x:x.x,j=i.y<x.y?i.y:x.y;return new o(e,j)}static Maximize(i,x){const e=i.x>x.x?i.x:x.x,j=i.y>x.y?i.y:x.y;return new o(e,j)}static Transform(i,x){return o.TransformToRef(i,x,new o)}static TransformToRef(i,x,e){const j=x.m,E=i.x*j[0]+i.y*j[4]+j[12],a=i.x*j[1]+i.y*j[5]+j[13];return e.x=E,e.y=a,e}static PointInTriangle(i,x,e,j){const E=.5*(-e.y*j.x+x.y*(-e.x+j.x)+x.x*(e.y-j.y)+e.x*j.y),a=E<0?-1:1,Y=(x.y*j.x-x.x*j.y+(j.y-x.y)*i.x+(x.x-j.x)*i.y)*a,J=(x.x*e.y-x.y*e.x+(x.y-e.y)*i.x+(e.x-x.x)*i.y)*a;return Y>0&&J>0&&Y+J<2*E*a}static Distance(i,x){return Math.sqrt(o.DistanceSquared(i,x))}static DistanceSquared(i,x){const e=i.x-x.x,j=i.y-x.y;return e*e+j*j}static Center(i,x){return o.CenterToRef(i,x,new o)}static CenterToRef(i,x,e){return e.fJ((i.x+x.x)/2,(i.y+x.y)/2)}static DistanceOfPointFromSegment(i,x,e){const j=o.DistanceSquared(x,e);if(0===j)return o.Distance(i,x);const E=e.Cx(x),a=Math.max(0,Math.min(1,o.Dot(i.Cx(x),E)/j)),Y=x.add(E.multiplyByFloats(a,a));return o.Distance(i,Y)}}o._V8PerformanceHack=new o(.5,.5),o._ZeroReadOnly=o.Zero(),Object.defineProperties(o.prototype,{dimension:{value:[2]},rank:{value:1}});class M{get x(){return this._x}set x(i){this._x=i,this._isDirty=!0}get y(){return this._y}set y(i){this._y=i,this._isDirty=!0}get z(){return this._z}set z(i){this._z=i,this._isDirty=!0}constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=i,this._y=x,this._z=e}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"KJ"}getHashCode(){let i=L(this._x);return i=397*i^L(this._y),i=397*i^L(this._z),i}de(){return[this._x,this._y,this._z]}toArray(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return i[x]=this._x,i[x+1]=this._y,i[x+2]=this._z,this}AJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M.FromArrayToRef(i,x,this),this}toQuaternion(){return T.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(i){return this._x+=i._x,this._y+=i._y,this._z+=i._z,this._isDirty=!0,this}addInPlaceFromFloats(i,x,e){return this._x+=i,this._y+=x,this._z+=e,this._isDirty=!0,this}add(i){return new M(this._x+i._x,this._y+i._y,this._z+i._z)}addToRef(i,x){return x._x=this._x+i._x,x._y=this._y+i._y,x._z=this._z+i._z,x._isDirty=!0,x}jK(i){return this._x-=i._x,this._y-=i._y,this._z-=i._z,this._isDirty=!0,this}Cx(i){return new M(this._x-i._x,this._y-i._y,this._z-i._z)}subtractToRef(i,x){return this.subtractFromFloatsToRef(i._x,i._y,i._z,x)}subtractFromFloats(i,x,e){return new M(this._x-i,this._y-x,this._z-e)}subtractFromFloatsToRef(i,x,e,j){return j._x=this._x-i,j._y=this._y-x,j._z=this._z-e,j._isDirty=!0,j}negate(){return new M(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(i){return i._x=-1*this._x,i._y=-1*this._y,i._z=-1*this._z,i._isDirty=!0,i}scaleInPlace(i){return this._x*=i,this._y*=i,this._z*=i,this._isDirty=!0,this}scale(i){return new M(this._x*i,this._y*i,this._z*i)}scaleToRef(i,x){return x._x=this._x*i,x._y=this._y*i,x._z=this._z*i,x._isDirty=!0,x}getNormalToRef(i){const x=this.length();let e=Math.acos(this._y/x);const j=Math.atan2(this._z,this._x);e>Math.PI/2?e-=Math.PI/2:e+=Math.PI/2;const E=x*Math.sin(e)*Math.cos(j),a=x*Math.cos(e),Y=x*Math.sin(e)*Math.sin(j);return i.set(E,a,Y),i}applyRotationQuaternionToRef(i,x){const e=this._x,j=this._y,E=this._z,a=i._x,Y=i._y,J=i._z,u=i._w,b=2*(Y*E-J*j),g=2*(J*e-a*E),A=2*(a*j-Y*e);return x._x=e+u*b+Y*A-J*g,x._y=j+u*g+J*b-a*A,x._z=E+u*A+a*g-Y*b,x._isDirty=!0,x}applyRotationQuaternionInPlace(i){return this.applyRotationQuaternionToRef(i,this)}applyRotationQuaternion(i){return this.applyRotationQuaternionToRef(i,new M)}scaleAndAddToRef(i,x){return x._x+=this._x*i,x._y+=this._y*i,x._z+=this._z*i,x._isDirty=!0,x}projectOnPlane(i,x){return this.projectOnPlaneToRef(i,x,new M)}projectOnPlaneToRef(i,x,e){const j=i.normal,E=i.d,a=t.KJ[0];this.subtractToRef(x,a),a.normalize();const Y=M.Dot(a,j);if(Math.abs(Y)<1e-10)e.OJ(1/0);else{const i=-(M.Dot(x,j)+E)/Y,J=a.scaleInPlace(i);x.addToRef(J,e)}return e}equals(i){return i&&this._x===i._x&&this._y===i._y&&this._z===i._z}equalsWithEpsilon(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.e;return i&&(0,u.WithinEpsilon)(this._x,i._x,x)&&(0,u.WithinEpsilon)(this._y,i._y,x)&&(0,u.WithinEpsilon)(this._z,i._z,x)}equalsToFloats(i,x,e){return this._x===i&&this._y===x&&this._z===e}multiplyInPlace(i){return this._x*=i._x,this._y*=i._y,this._z*=i._z,this._isDirty=!0,this}multiply(i){return this.multiplyByFloats(i._x,i._y,i._z)}multiplyToRef(i,x){return x._x=this._x*i._x,x._y=this._y*i._y,x._z=this._z*i._z,x._isDirty=!0,x}multiplyByFloats(i,x,e){return new M(this._x*i,this._y*x,this._z*e)}divide(i){return new M(this._x/i._x,this._y/i._y,this._z/i._z)}divideToRef(i,x){return x._x=this._x/i._x,x._y=this._y/i._y,x._z=this._z/i._z,x._isDirty=!0,x}divideInPlace(i){return this._x=this._x/i._x,this._y=this._y/i._y,this._z=this._z/i._z,this._isDirty=!0,this}minimizeInPlace(i){return this.minimizeInPlaceFromFloats(i._x,i._y,i._z)}maximizeInPlace(i){return this.maximizeInPlaceFromFloats(i._x,i._y,i._z)}minimizeInPlaceFromFloats(i,x,e){return i<this._x&&(this.x=i),x<this._y&&(this.y=x),e<this._z&&(this.z=e),this}maximizeInPlaceFromFloats(i,x,e){return i>this._x&&(this.x=i),x>this._y&&(this.y=x),e>this._z&&(this.z=e),this}isNonUniformWithinEpsilon(i){const x=Math.abs(this._x),e=Math.abs(this._y);if(!(0,u.WithinEpsilon)(x,e,i))return!0;const j=Math.abs(this._z);return!(0,u.WithinEpsilon)(x,j,i)||!(0,u.WithinEpsilon)(e,j,i)}get isNonUniform(){const i=Math.abs(this._x);if(i!==Math.abs(this._y))return!0;return i!==Math.abs(this._z)}floorToRef(i){return i._x=Math.floor(this._x),i._y=Math.floor(this._y),i._z=Math.floor(this._z),i._isDirty=!0,i}floor(){return new M(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(i){return i._x=this._x-Math.floor(this._x),i._y=this._y-Math.floor(this._y),i._z=this._z-Math.floor(this._z),i._isDirty=!0,i}fract(){return new M(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(i){if("xyz"===(i=i.toLowerCase()))return this;const x=t.KJ[0].A(this);return this.x=x[i[0]],this.y=x[i[1]],this.z=x[i[2]],this}rotateByQuaternionToRef(i,x){return i.toRotationMatrix(t.Matrix[0]),M.TransformCoordinatesToRef(this,t.Matrix[0],x),x}rotateByQuaternionAroundPointToRef(i,x,e){return this.subtractToRef(x,t.KJ[0]),t.KJ[0].rotateByQuaternionToRef(i,t.KJ[0]),x.addToRef(t.KJ[0],e),e}cross(i){return M.CrossToRef(this,i,new M)}normalizeFromLength(i){return 0===i||1===i?this:this.scaleInPlace(1/i)}normalizeToNew(){return this.normalizeToRef(new M)}normalizeToRef(i){const x=this.length();return 0===x||1===x?(i._x=this._x,i._y=this._y,i._z=this._z,i._isDirty=!0,i):this.scaleToRef(1/x,i)}clone(){return new M(this._x,this._y,this._z)}A(i){return this.fJ(i._x,i._y,i._z)}fJ(i,x,e){return this._x=i,this._y=x,this._z=e,this._isDirty=!0,this}set(i,x,e){return this.fJ(i,x,e)}OJ(i){return this._x=this._y=this._z=i,this._isDirty=!0,this}static GetClipFactor(i,x,e,j){const E=M.Dot(i,e);return(E-j)/(E-M.Dot(x,e))}static GetAngleBetweenVectors(i,x,e){const j=i.normalizeToRef(t.KJ[1]),E=x.normalizeToRef(t.KJ[2]);let a=M.Dot(j,E);a=(0,u.Clamp)(a,-1,1);const Y=Math.acos(a),J=t.KJ[3];return M.CrossToRef(j,E,J),M.Dot(J,e)>0?isNaN(Y)?0:Y:isNaN(Y)?-Math.PI:-Math.acos(a)}static GetAngleBetweenVectorsOnPlane(i,x,e){t.KJ[0].A(i);const j=t.KJ[0];t.KJ[1].A(x);const E=t.KJ[1];t.KJ[2].A(e);const a=t.KJ[2],Y=t.KJ[3],J=t.KJ[4];j.normalize(),E.normalize(),a.normalize(),M.CrossToRef(a,j,Y),M.CrossToRef(Y,a,J);const b=Math.atan2(M.Dot(E,Y),M.Dot(E,J));return(0,u.NormalizeRadians)(b)}static PitchYawRollToMoveBetweenPointsToRef(i,x,e){const j=V.KJ[0];return x.subtractToRef(i,j),e._y=Math.atan2(j.x,j.z)||0,e._x=Math.atan2(Math.sqrt(j.x**2+j.z**2),j.y)||0,e._z=0,e._isDirty=!0,e}static PitchYawRollToMoveBetweenPoints(i,x){const e=M.Zero();return M.PitchYawRollToMoveBetweenPointsToRef(i,x,e)}static SlerpToRef(i,x,e,E){e=(0,u.Clamp)(e,0,1);const a=t.KJ[0],Y=t.KJ[1];a.A(i);const J=a.length();a.normalizeFromLength(J),Y.A(x);const b=Y.length();Y.normalizeFromLength(b);const g=M.Dot(a,Y);let A,K;if(g<1-j.e){const i=Math.acos(g),x=1/Math.sin(i);A=Math.sin((1-e)*i)*x,K=Math.sin(e*i)*x}else A=1-e,K=e;return a.scaleInPlace(A),Y.scaleInPlace(K),E.A(a).addInPlace(Y),E.scaleInPlace((0,u.Lerp)(J,b,e)),E}static SmoothToRef(i,x,e,j,E){return M.SlerpToRef(i,x,0===j?1:e/j,E),E}static zJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new M(i[x],i[x+1],i[x+2])}static FromFloatArray(i,x){return M.zJ(i,x)}static FromArrayToRef(i,x,e){return e._x=i[x],e._y=i[x+1],e._z=i[x+2],e._isDirty=!0,e}static FromFloatArrayToRef(i,x,e){return M.FromArrayToRef(i,x,e)}static FromFloatsToRef(i,x,e,j){return j.fJ(i,x,e),j}static Zero(){return new M(0,0,0)}static One(){return new M(1,1,1)}static Up(){return new M(0,1,0)}static get UpReadOnly(){return M._UpReadOnly}static get DownReadOnly(){return M._DownReadOnly}static get RightReadOnly(){return M._RightReadOnly}static get LeftReadOnly(){return M._LeftReadOnly}static get LeftHandedForwardReadOnly(){return M._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return M._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return M._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return M._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return M._ZeroReadOnly}static get OneReadOnly(){return M._OneReadOnly}static Down(){return new M(0,-1,0)}static Forward(){return new M(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new M(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new M(1,0,0)}static Left(){return new M(-1,0,0)}static Random(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new M((0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x))}static RandomToRef(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fJ((0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x))}static TransformCoordinates(i,x){const e=M.Zero();return M.TransformCoordinatesToRef(i,x,e),e}static TransformCoordinatesToRef(i,x,e){return M.TransformCoordinatesFromFloatsToRef(i._x,i._y,i._z,x,e),e}static TransformCoordinatesFromFloatsToRef(i,x,e,j,E){const a=j.m,Y=i*a[0]+x*a[4]+e*a[8]+a[12],J=i*a[1]+x*a[5]+e*a[9]+a[13],u=i*a[2]+x*a[6]+e*a[10]+a[14],b=1/(i*a[3]+x*a[7]+e*a[11]+a[15]);return E._x=Y*b,E._y=J*b,E._z=u*b,E._isDirty=!0,E}static TransformNormal(i,x){const e=M.Zero();return M.TransformNormalToRef(i,x,e),e}static TransformNormalToRef(i,x,e){return this.TransformNormalFromFloatsToRef(i._x,i._y,i._z,x,e),e}static TransformNormalFromFloatsToRef(i,x,e,j,E){const a=j.m;return E._x=i*a[0]+x*a[4]+e*a[8],E._y=i*a[1]+x*a[5]+e*a[9],E._z=i*a[2]+x*a[6]+e*a[10],E._isDirty=!0,E}static CatmullRom(i,x,e,j,E){const a=E*E,Y=E*a,J=.5*(2*x._x+(-i._x+e._x)*E+(2*i._x-5*x._x+4*e._x-j._x)*a+(-i._x+3*x._x-3*e._x+j._x)*Y),u=.5*(2*x._y+(-i._y+e._y)*E+(2*i._y-5*x._y+4*e._y-j._y)*a+(-i._y+3*x._y-3*e._y+j._y)*Y),b=.5*(2*x._z+(-i._z+e._z)*E+(2*i._z-5*x._z+4*e._z-j._z)*a+(-i._z+3*x._z-3*e._z+j._z)*Y);return new M(J,u,b)}static Clamp(i,x,e){const j=new M;return M.ClampToRef(i,x,e,j),j}static ClampToRef(i,x,e,j){let E=i._x;E=E>e._x?e._x:E,E=E<x._x?x._x:E;let a=i._y;a=a>e._y?e._y:a,a=a<x._y?x._y:a;let Y=i._z;return Y=Y>e._z?e._z:Y,Y=Y<x._z?x._z:Y,j.fJ(E,a,Y),j}static CheckExtends(i,x,e){x.minimizeInPlace(i),e.maximizeInPlace(i)}static Hermite(i,x,e,j,E){const a=E*E,Y=E*a,J=2*Y-3*a+1,u=-2*Y+3*a,b=Y-2*a+E,g=Y-a,A=i._x*J+e._x*u+x._x*b+j._x*g,K=i._y*J+e._y*u+x._y*b+j._y*g,L=i._z*J+e._z*u+x._z*b+j._z*g;return new M(A,K,L)}static Hermite1stDerivative(i,x,e,j,E){const a=new M;return this.Hermite1stDerivativeToRef(i,x,e,j,E,a),a}static Hermite1stDerivativeToRef(i,x,e,j,E,a){const Y=E*E;return a._x=6*(Y-E)*i._x+(3*Y-4*E+1)*x._x+6*(-Y+E)*e._x+(3*Y-2*E)*j._x,a._y=6*(Y-E)*i._y+(3*Y-4*E+1)*x._y+6*(-Y+E)*e._y+(3*Y-2*E)*j._y,a._z=6*(Y-E)*i._z+(3*Y-4*E+1)*x._z+6*(-Y+E)*e._z+(3*Y-2*E)*j._z,a._isDirty=!0,a}static Lerp(i,x,e){const j=new M(0,0,0);return M.LerpToRef(i,x,e,j),j}static LerpToRef(i,x,e,j){return j._x=i._x+(x._x-i._x)*e,j._y=i._y+(x._y-i._y)*e,j._z=i._z+(x._z-i._z)*e,j._isDirty=!0,j}static Dot(i,x){return i._x*x._x+i._y*x._y+i._z*x._z}dot(i){return this._x*i._x+this._y*i._y+this._z*i._z}static Cross(i,x){const e=new M;return M.CrossToRef(i,x,e),e}static CrossToRef(i,x,e){const j=i._y*x._z-i._z*x._y,E=i._z*x._x-i._x*x._z,a=i._x*x._y-i._y*x._x;return e.fJ(j,E,a),e}static Normalize(i){const x=M.Zero();return M.NormalizeToRef(i,x),x}static NormalizeToRef(i,x){return i.normalizeToRef(x),x}static Project(i,x,e,j){const E=new M;return M.ProjectToRef(i,x,e,j,E),E}static ProjectToRef(i,x,e,j,E){var a;const Y=j.width,u=j.height,b=j.x,g=j.y,A=t.Matrix[1],K=null===(a=J.e.LastCreatedEngine)||void 0===a?void 0:a.isNDCHalfZRange,L=K?1:.5,o=K?0:.5;Q.FromValuesToRef(Y/2,0,0,0,0,-u/2,0,0,0,0,L,0,b+Y/2,u/2+g,o,1,A);const z=t.Matrix[0];return x.multiplyToRef(e,z),z.multiplyToRef(A,z),M.TransformCoordinatesToRef(i,z,E),E}static Reflect(i,x){return this.ReflectToRef(i,x,new M)}static ReflectToRef(i,x,e){const j=V.KJ[0];return j.A(x).scaleInPlace(2*M.Dot(i,x)),e.A(i).jK(j)}static _UnprojectFromInvertedMatrixToRef(i,x,e){M.TransformCoordinatesToRef(i,x,e);const j=x.m,E=i._x*j[3]+i._y*j[7]+i._z*j[11]+j[15];return(0,u.WithinEpsilon)(E,1)&&e.scaleInPlace(1/E),e}static UnprojectFromTransform(i,x,e,j,E){return this.Unproject(i,x,e,j,E,Q.IdentityReadOnly)}static Unproject(i,x,e,j,E,a){const Y=new M;return M.UnprojectToRef(i,x,e,j,E,a,Y),Y}static UnprojectToRef(i,x,e,j,E,a,Y){return M.UnprojectFloatsToRef(i._x,i._y,i._z,x,e,j,E,a,Y),Y}static UnprojectFloatsToRef(i,x,e,j,E,a,Y,u,b){var g;const A=t.Matrix[0];a.multiplyToRef(Y,A),A.multiplyToRef(u,A),A.invert();const K=t.KJ[0];return K.x=i/j*2-1,K.y=-(x/E*2-1),null!==(g=J.e.LastCreatedEngine)&&void 0!==g&&g.isNDCHalfZRange?K.z=e:K.z=2*e-1,M._UnprojectFromInvertedMatrixToRef(K,A,b),b}static Minimize(i,x){const e=new M;return e.A(i),e.minimizeInPlace(x),e}static Maximize(i,x){const e=new M;return e.A(i),e.maximizeInPlace(x),e}static Distance(i,x){return Math.sqrt(M.DistanceSquared(i,x))}static DistanceSquared(i,x){const e=i._x-x._x,j=i._y-x._y,E=i._z-x._z;return e*e+j*j+E*E}static ProjectOnTriangleToRef(i,x,e,E,a){const Y=t.KJ[0],J=t.KJ[1],b=t.KJ[2],g=t.KJ[3],A=t.KJ[4];e.subtractToRef(x,Y),E.subtractToRef(x,J),E.subtractToRef(e,b);const K=Y.length(),L=J.length(),o=b.length();if(K<j.e||L<j.e||o<j.e)return a.A(x),M.Distance(i,x);i.subtractToRef(x,A),M.CrossToRef(Y,J,g);const z=g.length();if(z<j.e)return a.A(x),M.Distance(i,x);g.normalizeFromLength(z);let T=A.length();if(T<j.e)return a.A(x),0;A.normalizeFromLength(T);const Q=M.Dot(g,A),V=t.KJ[5],S=t.KJ[6];V.A(g).scaleInPlace(-T*Q),S.A(i).addInPlace(V);const f=t.KJ[4],w=t.KJ[5],O=t.KJ[7],l=t.KJ[8];f.A(Y).scaleInPlace(1/K),l.A(J).scaleInPlace(1/L),f.addInPlace(l).scaleInPlace(-1),w.A(Y).scaleInPlace(-1/K),l.A(b).scaleInPlace(1/o),w.addInPlace(l).scaleInPlace(-1),O.A(b).scaleInPlace(-1/o),l.A(J).scaleInPlace(-1/L),O.addInPlace(l).scaleInPlace(-1);const Z=t.KJ[9];let B;Z.A(S).jK(x),M.CrossToRef(f,Z,l),B=M.Dot(l,g);const k=B;Z.A(S).jK(e),M.CrossToRef(w,Z,l),B=M.Dot(l,g);const N=B;Z.A(S).jK(E),M.CrossToRef(O,Z,l),B=M.Dot(l,g);const mi=B,X=t.KJ[10];let C,n;k>0&&N<0?(X.A(Y),C=x,n=e):N>0&&mi<0?(X.A(b),C=e,n=E):(X.A(J).scaleInPlace(-1),C=E,n=x);const I=t.KJ[9],d=t.KJ[4];C.subtractToRef(S,l),n.subtractToRef(S,I),M.CrossToRef(l,I,d);if(!(M.Dot(d,g)<0))return a.A(S),Math.abs(T*Q);const p=t.KJ[5];M.CrossToRef(X,d,p),p.normalize();const H=t.KJ[9];H.A(C).jK(S);const U=H.length();if(U<j.e)return a.A(C),M.Distance(i,C);H.normalizeFromLength(U);const D=M.Dot(p,H),h=t.KJ[7];h.A(S).addInPlace(p.scaleInPlace(U*D)),l.A(h).jK(C),T=X.length(),X.normalizeFromLength(T);let F=M.Dot(l,X)/Math.max(T,j.e);return F=(0,u.Clamp)(F,0,1),h.A(C).addInPlace(X.scaleInPlace(F*T)),a.A(h),M.Distance(i,h)}static Center(i,x){return M.CenterToRef(i,x,M.Zero())}static CenterToRef(i,x,e){return e.fJ((i._x+x._x)/2,(i._y+x._y)/2,(i._z+x._z)/2)}static RotationFromAxis(i,x,e){const j=new M;return M.RotationFromAxisToRef(i,x,e,j),j}static RotationFromAxisToRef(i,x,e,j){const E=t.Quaternion[0];return T.RotationQuaternionFromAxisToRef(i,x,e,E),E.toEulerAnglesToRef(j),j}}M._V8PerformanceHack=new M(.5,.5,.5),M._UpReadOnly=M.Up(),M._DownReadOnly=M.Down(),M._LeftHandedForwardReadOnly=M.Forward(!1),M._RightHandedForwardReadOnly=M.Forward(!0),M._LeftHandedBackwardReadOnly=M.Backward(!1),M._RightHandedBackwardReadOnly=M.Backward(!0),M._RightReadOnly=M.Right(),M._LeftReadOnly=M.Left(),M._ZeroReadOnly=M.Zero(),M._OneReadOnly=M.One(),Object.defineProperties(M.prototype,{dimension:{value:[3]},rank:{value:1}});class z{get x(){return this._x}set x(i){this._x=i,this._isDirty=!0}get y(){return this._y}set y(i){this._y=i,this._isDirty=!0}get z(){return this._z}set z(i){this._z=i,this._isDirty=!0}get w(){return this._w}set w(i){this._w=i,this._isDirty=!0}constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=i,this._y=x,this._z=e,this._w=j}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let i=L(this._x);return i=397*i^L(this._y),i=397*i^L(this._z),i=397*i^L(this._w),i}de(){return[this._x,this._y,this._z,this._w]}toArray(i,x){return void 0===x&&(x=0),i[x]=this._x,i[x+1]=this._y,i[x+2]=this._z,i[x+3]=this._w,this}AJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z.FromArrayToRef(i,x,this),this}addInPlace(i){return this.x+=i._x,this.y+=i._y,this.z+=i._z,this.w+=i._w,this}addInPlaceFromFloats(i,x,e,j){return this.x+=i,this.y+=x,this.z+=e,this.w+=j,this}add(i){return new z(this._x+i.x,this._y+i.y,this._z+i.z,this._w+i.w)}addToRef(i,x){return x.x=this._x+i.x,x.y=this._y+i.y,x.z=this._z+i.z,x.w=this._w+i.w,x}jK(i){return this.x-=i.x,this.y-=i.y,this.z-=i.z,this.w-=i.w,this}Cx(i){return new z(this._x-i.x,this._y-i.y,this._z-i.z,this._w-i.w)}subtractToRef(i,x){return x.x=this._x-i.x,x.y=this._y-i.y,x.z=this._z-i.z,x.w=this._w-i.w,x}subtractFromFloats(i,x,e,j){return new z(this._x-i,this._y-x,this._z-e,this._w-j)}subtractFromFloatsToRef(i,x,e,j,E){return E.x=this._x-i,E.y=this._y-x,E.z=this._z-e,E.w=this._w-j,E}negate(){return new z(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(i){return i.x=-this._x,i.y=-this._y,i.z=-this._z,i.w=-this._w,i}scaleInPlace(i){return this.x*=i,this.y*=i,this.z*=i,this.w*=i,this}scale(i){return new z(this._x*i,this._y*i,this._z*i,this._w*i)}scaleToRef(i,x){return x.x=this._x*i,x.y=this._y*i,x.z=this._z*i,x.w=this._w*i,x}scaleAndAddToRef(i,x){return x.x+=this._x*i,x.y+=this._y*i,x.z+=this._z*i,x.w+=this._w*i,x}equals(i){return i&&this._x===i.x&&this._y===i.y&&this._z===i.z&&this._w===i.w}equalsWithEpsilon(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.e;return i&&(0,u.WithinEpsilon)(this._x,i.x,x)&&(0,u.WithinEpsilon)(this._y,i.y,x)&&(0,u.WithinEpsilon)(this._z,i.z,x)&&(0,u.WithinEpsilon)(this._w,i.w,x)}equalsToFloats(i,x,e,j){return this._x===i&&this._y===x&&this._z===e&&this._w===j}multiplyInPlace(i){return this.x*=i.x,this.y*=i.y,this.z*=i.z,this.w*=i.w,this}multiply(i){return new z(this._x*i.x,this._y*i.y,this._z*i.z,this._w*i.w)}multiplyToRef(i,x){return x.x=this._x*i.x,x.y=this._y*i.y,x.z=this._z*i.z,x.w=this._w*i.w,x}multiplyByFloats(i,x,e,j){return new z(this._x*i,this._y*x,this._z*e,this._w*j)}divide(i){return new z(this._x/i.x,this._y/i.y,this._z/i.z,this._w/i.w)}divideToRef(i,x){return x.x=this._x/i.x,x.y=this._y/i.y,x.z=this._z/i.z,x.w=this._w/i.w,x}divideInPlace(i){return this.divideToRef(i,this)}minimizeInPlace(i){return i.x<this._x&&(this.x=i.x),i.y<this._y&&(this.y=i.y),i.z<this._z&&(this.z=i.z),i.w<this._w&&(this.w=i.w),this}maximizeInPlace(i){return i.x>this._x&&(this.x=i.x),i.y>this._y&&(this.y=i.y),i.z>this._z&&(this.z=i.z),i.w>this._w&&(this.w=i.w),this}minimizeInPlaceFromFloats(i,x,e,j){return this.x=Math.min(i,this._x),this.y=Math.min(x,this._y),this.z=Math.min(e,this._z),this.w=Math.min(j,this._w),this}maximizeInPlaceFromFloats(i,x,e,j){return this.x=Math.max(i,this._x),this.y=Math.max(x,this._y),this.z=Math.max(e,this._z),this.w=Math.max(j,this._w),this}floorToRef(i){return i.x=Math.floor(this._x),i.y=Math.floor(this._y),i.z=Math.floor(this._z),i.w=Math.floor(this._w),i}floor(){return new z(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(i){return i.x=this._x-Math.floor(this._x),i.y=this._y-Math.floor(this._y),i.z=this._z-Math.floor(this._z),i.w=this._w-Math.floor(this._w),i}fract(){return new z(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(i){return 0===i||1===i?this:this.scaleInPlace(1/i)}normalizeToNew(){return this.normalizeToRef(new z)}normalizeToRef(i){const x=this.length();return 0===x||1===x?(i.x=this._x,i.y=this._y,i.z=this._z,i.w=this._w,i):this.scaleToRef(1/x,i)}toVector3(){return new M(this._x,this._y,this._z)}clone(){return new z(this._x,this._y,this._z,this._w)}A(i){return this.x=i.x,this.y=i.y,this.z=i.z,this.w=i.w,this}fJ(i,x,e,j){return this.x=i,this.y=x,this.z=e,this.w=j,this}set(i,x,e,j){return this.fJ(i,x,e,j)}OJ(i){return this.x=this.y=this.z=this.w=i,this}dot(i){return this._x*i.x+this._y*i.y+this._z*i.z+this._w*i.w}static zJ(i,x){return x||(x=0),new z(i[x],i[x+1],i[x+2],i[x+3])}static FromArrayToRef(i,x,e){return e.x=i[x],e.y=i[x+1],e.z=i[x+2],e.w=i[x+3],e}static FromFloatArrayToRef(i,x,e){return z.FromArrayToRef(i,x,e),e}static FromFloatsToRef(i,x,e,j,E){return E.x=i,E.y=x,E.z=e,E.w=j,E}static Zero(){return new z(0,0,0,0)}static One(){return new z(1,1,1,1)}static Random(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new z((0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x))}static RandomToRef(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,e=arguments.length>2?arguments[2]:void 0;return e.x=(0,u.RandomRange)(i,x),e.y=(0,u.RandomRange)(i,x),e.z=(0,u.RandomRange)(i,x),e.w=(0,u.RandomRange)(i,x),e}static Clamp(i,x,e){return z.ClampToRef(i,x,e,new z)}static ClampToRef(i,x,e,j){return j.x=(0,u.Clamp)(i.x,x.x,e.x),j.y=(0,u.Clamp)(i.y,x.y,e.y),j.z=(0,u.Clamp)(i.z,x.z,e.z),j.w=(0,u.Clamp)(i.w,x.w,e.w),j}static CheckExtends(i,x,e){x.minimizeInPlace(i),e.maximizeInPlace(i)}static get ZeroReadOnly(){return z._ZeroReadOnly}static Normalize(i){return z.NormalizeToRef(i,new z)}static NormalizeToRef(i,x){return i.normalizeToRef(x),x}static Minimize(i,x){const e=new z;return e.A(i),e.minimizeInPlace(x),e}static Maximize(i,x){const e=new z;return e.A(i),e.maximizeInPlace(x),e}static Distance(i,x){return Math.sqrt(z.DistanceSquared(i,x))}static DistanceSquared(i,x){const e=i.x-x.x,j=i.y-x.y,E=i.z-x.z,a=i.w-x.w;return e*e+j*j+E*E+a*a}static Center(i,x){return z.CenterToRef(i,x,new z)}static CenterToRef(i,x,e){return e.x=(i.x+x.x)/2,e.y=(i.y+x.y)/2,e.z=(i.z+x.z)/2,e.w=(i.w+x.w)/2,e}static TransformCoordinates(i,x){return z.TransformCoordinatesToRef(i,x,new z)}static TransformCoordinatesToRef(i,x,e){return z.TransformCoordinatesFromFloatsToRef(i._x,i._y,i._z,x,e),e}static TransformCoordinatesFromFloatsToRef(i,x,e,j,E){const a=j.m,Y=i*a[0]+x*a[4]+e*a[8]+a[12],J=i*a[1]+x*a[5]+e*a[9]+a[13],u=i*a[2]+x*a[6]+e*a[10]+a[14],b=i*a[3]+x*a[7]+e*a[11]+a[15];return E.x=Y,E.y=J,E.z=u,E.w=b,E}static TransformNormal(i,x){return z.TransformNormalToRef(i,x,new z)}static TransformNormalToRef(i,x,e){const j=x.m,E=i.x*j[0]+i.y*j[4]+i.z*j[8],a=i.x*j[1]+i.y*j[5]+i.z*j[9],Y=i.x*j[2]+i.y*j[6]+i.z*j[10];return e.x=E,e.y=a,e.z=Y,e.w=i.w,e}static TransformNormalFromFloatsToRef(i,x,e,j,E,a){const Y=E.m;return a.x=i*Y[0]+x*Y[4]+e*Y[8],a.y=i*Y[1]+x*Y[5]+e*Y[9],a.z=i*Y[2]+x*Y[6]+e*Y[10],a.w=j,a}static FromVector3(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new z(i._x,i._y,i._z,x)}static Dot(i,x){return i.x*x.x+i.y*x.y+i.z*x.z+i.w*x.w}}z._V8PerformanceHack=new z(.5,.5,.5,.5),z._ZeroReadOnly=z.Zero(),Object.defineProperties(z.prototype,{dimension:{value:[4]},rank:{value:1}});class T{get x(){return this._x}set x(i){this._x=i,this._isDirty=!0}get y(){return this._y}set y(i){this._y=i,this._isDirty=!0}get z(){return this._z}set z(i){this._z=i,this._isDirty=!0}get w(){return this._w}set w(i){this._w=i,this._isDirty=!0}constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=i,this._y=x,this._z=e,this._w=j}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let i=L(this._x);return i=397*i^L(this._y),i=397*i^L(this._z),i=397*i^L(this._w),i}de(){return[this._x,this._y,this._z,this._w]}toArray(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return i[x]=this._x,i[x+1]=this._y,i[x+2]=this._z,i[x+3]=this._w,this}AJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return T.FromArrayToRef(i,x,this)}equals(i){return i&&this._x===i._x&&this._y===i._y&&this._z===i._z&&this._w===i._w}equalsWithEpsilon(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.e;return i&&(0,u.WithinEpsilon)(this._x,i._x,x)&&(0,u.WithinEpsilon)(this._y,i._y,x)&&(0,u.WithinEpsilon)(this._z,i._z,x)&&(0,u.WithinEpsilon)(this._w,i._w,x)}isApprox(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.e;return i&&((0,u.WithinEpsilon)(this._x,i._x,x)&&(0,u.WithinEpsilon)(this._y,i._y,x)&&(0,u.WithinEpsilon)(this._z,i._z,x)&&(0,u.WithinEpsilon)(this._w,i._w,x)||(0,u.WithinEpsilon)(this._x,-i._x,x)&&(0,u.WithinEpsilon)(this._y,-i._y,x)&&(0,u.WithinEpsilon)(this._z,-i._z,x)&&(0,u.WithinEpsilon)(this._w,-i._w,x))}clone(){return new T(this._x,this._y,this._z,this._w)}A(i){return this._x=i._x,this._y=i._y,this._z=i._z,this._w=i._w,this._isDirty=!0,this}fJ(i,x,e,j){return this._x=i,this._y=x,this._z=e,this._w=j,this._isDirty=!0,this}set(i,x,e,j){return this.fJ(i,x,e,j)}OJ(i){return this.fJ(i,i,i,i)}add(i){return new T(this._x+i._x,this._y+i._y,this._z+i._z,this._w+i._w)}addInPlace(i){return this._x+=i._x,this._y+=i._y,this._z+=i._z,this._w+=i._w,this._isDirty=!0,this}addToRef(i,x){return x._x=this._x+i._x,x._y=this._y+i._y,x._z=this._z+i._z,x._w=this._w+i._w,x._isDirty=!0,x}addInPlaceFromFloats(i,x,e,j){return this._x+=i,this._y+=x,this._z+=e,this._w+=j,this._isDirty=!0,this}subtractToRef(i,x){return x._x=this._x-i._x,x._y=this._y-i._y,x._z=this._z-i._z,x._w=this._w-i._w,x._isDirty=!0,x}subtractFromFloats(i,x,e,j){return this.subtractFromFloatsToRef(i,x,e,j,new T)}subtractFromFloatsToRef(i,x,e,j,E){return E._x=this._x-i,E._y=this._y-x,E._z=this._z-e,E._w=this._w-j,E._isDirty=!0,E}Cx(i){return new T(this._x-i._x,this._y-i._y,this._z-i._z,this._w-i._w)}jK(i){return this._x-=i._x,this._y-=i._y,this._z-=i._z,this._w-=i._w,this._isDirty=!0,this}scale(i){return new T(this._x*i,this._y*i,this._z*i,this._w*i)}scaleToRef(i,x){return x._x=this._x*i,x._y=this._y*i,x._z=this._z*i,x._w=this._w*i,x._isDirty=!0,x}scaleInPlace(i){return this._x*=i,this._y*=i,this._z*=i,this._w*=i,this._isDirty=!0,this}scaleAndAddToRef(i,x){return x._x+=this._x*i,x._y+=this._y*i,x._z+=this._z*i,x._w+=this._w*i,x._isDirty=!0,x}multiply(i){const x=new T(0,0,0,1);return this.multiplyToRef(i,x),x}multiplyToRef(i,x){const e=this._x*i._w+this._y*i._z-this._z*i._y+this._w*i._x,j=-this._x*i._z+this._y*i._w+this._z*i._x+this._w*i._y,E=this._x*i._y-this._y*i._x+this._z*i._w+this._w*i._z,a=-this._x*i._x-this._y*i._y-this._z*i._z+this._w*i._w;return x.fJ(e,j,E,a),x}multiplyInPlace(i){return this.multiplyToRef(i,this)}multiplyByFloats(i,x,e,j){return this._x*=i,this._y*=x,this._z*=e,this._w*=j,this._isDirty=!0,this}divide(i){throw new ReferenceError("Can not divide a quaternion")}divideToRef(i,x){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(i){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new T)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(i){return i._x=-this._x,i._y=-this._y,i._z=-this._z,i._w=-this._w,i._isDirty=!0,i}equalsToFloats(i,x,e,j){return this._x===i&&this._y===x&&this._z===e&&this._w===j}floorToRef(i){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(i){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(i){return i.fJ(-this._x,-this._y,-this._z,this._w),i}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new T(-this._x,-this._y,-this._z,this._w)}invert(){const i=this.conjugate(),x=this.lengthSquared();return 0==x||1==x||i.scaleInPlace(1/x),i}invertInPlace(){this.conjugateInPlace();const i=this.lengthSquared();return 0==i||1==i||this.scaleInPlace(1/i),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(i){return 0===i||1===i?this:this.scaleInPlace(1/i)}normalizeToNew(){const i=new T(0,0,0,1);return this.normalizeToRef(i),i}normalizeToRef(i){const x=this.length();return 0===x||1===x?i.fJ(this._x,this._y,this._z,this._w):this.scaleToRef(1/x,i)}toEulerAngles(){const i=M.Zero();return this.toEulerAnglesToRef(i),i}toEulerAnglesToRef(i){const x=this._z,e=this._x,j=this._y,E=this._w,a=j*x-e*E,Y=.4999999;if(a<-Y)i._y=2*Math.atan2(j,E),i._x=Math.PI/2,i._z=0,i._isDirty=!0;else if(a>Y)i._y=2*Math.atan2(j,E),i._x=-Math.PI/2,i._z=0,i._isDirty=!0;else{const Y=E*E,J=x*x,u=e*e,b=j*j;i._z=Math.atan2(2*(e*j+x*E),-J-u+b+Y),i._x=Math.asin(-2*a),i._y=Math.atan2(2*(x*e+j*E),J-u-b+Y),i._isDirty=!0}return i}toAlphaBetaGammaToRef(i){const x=this._z,e=this._x,j=this._y,E=this._w,a=Math.sqrt(e*e+j*j),Y=Math.sqrt(x*x+E*E),J=2*Math.atan2(a,Y),u=2*Math.atan2(x,E),b=2*Math.atan2(j,e),g=(u+b)/2,A=(u-b)/2;return i.set(A,J,g),i}toRotationMatrix(i){return Q.FromQuaternionToRef(this,i),i}fromRotationMatrix(i){return T.FromRotationMatrixToRef(i,this),this}dot(i){return this._x*i._x+this._y*i._y+this._z*i._z+this._w*i._w}toAxisAngle(){const i=M.Zero();return{axis:i,angle:this.toAxisAngleToRef(i)}}toAxisAngleToRef(i){let x=0;const e=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),j=this._w;return e>0?(x=2*Math.atan2(e,j),i.set(this._x/e,this._y/e,this._z/e)):(x=0,i.set(1,0,0)),x}static FromRotationMatrix(i){const x=new T;return T.FromRotationMatrixToRef(i,x),x}static FromRotationMatrixToRef(i,x){const e=i.m,j=e[0],E=e[4],a=e[8],Y=e[1],J=e[5],u=e[9],b=e[2],g=e[6],A=e[10],K=j+J+A;let L;return K>0?(L=.5/Math.sqrt(K+1),x._w=.25/L,x._x=(g-u)*L,x._y=(a-b)*L,x._z=(Y-E)*L,x._isDirty=!0):j>J&&j>A?(L=2*Math.sqrt(1+j-J-A),x._w=(g-u)/L,x._x=.25*L,x._y=(E+Y)/L,x._z=(a+b)/L,x._isDirty=!0):J>A?(L=2*Math.sqrt(1+J-j-A),x._w=(a-b)/L,x._x=(E+Y)/L,x._y=.25*L,x._z=(u+g)/L,x._isDirty=!0):(L=2*Math.sqrt(1+A-j-J),x._w=(Y-E)/L,x._x=(a+b)/L,x._y=(u+g)/L,x._z=.25*L,x._isDirty=!0),x}static Dot(i,x){return i._x*x._x+i._y*x._y+i._z*x._z+i._w*x._w}static AreClose(i,x){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const j=T.Dot(i,x);return 1-j*j<=e}static SmoothToRef(i,x,e,j,E){let a=0===j?1:e/j;return a=(0,u.Clamp)(a,0,1),T.SlerpToRef(i,x,a,E),E}static Zero(){return new T(0,0,0,0)}static Inverse(i){return new T(-i._x,-i._y,-i._z,i._w)}static InverseToRef(i,x){return x.set(-i._x,-i._y,-i._z,i._w),x}static Identity(){return new T(0,0,0,1)}static IsIdentity(i){return i&&0===i._x&&0===i._y&&0===i._z&&1===i._w}static RotationAxis(i,x){return T.RotationAxisToRef(i,x,new T)}static RotationAxisToRef(i,x,e){e._w=Math.cos(x/2);const j=Math.sin(x/2)/i.length();return e._x=i._x*j,e._y=i._y*j,e._z=i._z*j,e._isDirty=!0,e}static zJ(i,x){return x||(x=0),new T(i[x],i[x+1],i[x+2],i[x+3])}static FromArrayToRef(i,x,e){return e._x=i[x],e._y=i[x+1],e._z=i[x+2],e._w=i[x+3],e._isDirty=!0,e}static FromFloatsToRef(i,x,e,j,E){return E.fJ(i,x,e,j),E}static FromEulerAngles(i,x,e){const j=new T;return T.RotationYawPitchRollToRef(x,i,e,j),j}static FromEulerAnglesToRef(i,x,e,j){return T.RotationYawPitchRollToRef(x,i,e,j),j}static FromEulerVector(i){const x=new T;return T.RotationYawPitchRollToRef(i._y,i._x,i._z,x),x}static FromEulerVectorToRef(i,x){return T.RotationYawPitchRollToRef(i._y,i._x,i._z,x),x}static FromUnitVectorsToRef(i,x,e){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:j.e;const a=M.Dot(i,x)+1;return a<E?Math.abs(i.x)>Math.abs(i.z)?e.set(-i.y,i.x,0,0):e.set(0,-i.z,i.y,0):(M.CrossToRef(i,x,V.KJ[0]),e.set(V.KJ[0].x,V.KJ[0].y,V.KJ[0].z,a)),e.normalize()}static RotationYawPitchRoll(i,x,e){const j=new T;return T.RotationYawPitchRollToRef(i,x,e,j),j}static RotationYawPitchRollToRef(i,x,e,j){const E=.5*e,a=.5*x,Y=.5*i,J=Math.sin(E),u=Math.cos(E),b=Math.sin(a),g=Math.cos(a),A=Math.sin(Y),K=Math.cos(Y);return j._x=K*b*u+A*g*J,j._y=A*g*u-K*b*J,j._z=K*g*J-A*b*u,j._w=K*g*u+A*b*J,j._isDirty=!0,j}static RotationAlphaBetaGamma(i,x,e){const j=new T;return T.RotationAlphaBetaGammaToRef(i,x,e,j),j}static RotationAlphaBetaGammaToRef(i,x,e,j){const E=.5*(e+i),a=.5*(e-i),Y=.5*x;return j._x=Math.cos(a)*Math.sin(Y),j._y=Math.sin(a)*Math.sin(Y),j._z=Math.sin(E)*Math.cos(Y),j._w=Math.cos(E)*Math.cos(Y),j._isDirty=!0,j}static RotationQuaternionFromAxis(i,x,e){const j=new T(0,0,0,0);return T.RotationQuaternionFromAxisToRef(i,x,e,j),j}static RotationQuaternionFromAxisToRef(i,x,e,j){const E=t.Matrix[0];return i=i.normalizeToRef(t.KJ[0]),x=x.normalizeToRef(t.KJ[1]),e=e.normalizeToRef(t.KJ[2]),Q.FromXYZAxesToRef(i,x,e,E),T.FromRotationMatrixToRef(E,j),j}static FromLookDirectionLH(i,x){const e=new T;return T.FromLookDirectionLHToRef(i,x,e),e}static FromLookDirectionLHToRef(i,x,e){const j=t.Matrix[0];return Q.LookDirectionLHToRef(i,x,j),T.FromRotationMatrixToRef(j,e),e}static FromLookDirectionRH(i,x){const e=new T;return T.FromLookDirectionRHToRef(i,x,e),e}static FromLookDirectionRHToRef(i,x,e){const j=t.Matrix[0];return Q.LookDirectionRHToRef(i,x,j),T.FromRotationMatrixToRef(j,e)}static Slerp(i,x,e){const j=T.Identity();return T.SlerpToRef(i,x,e,j),j}static SlerpToRef(i,x,e,j){let E,a,Y=i._x*x._x+i._y*x._y+i._z*x._z+i._w*x._w,J=!1;if(Y<0&&(J=!0,Y=-Y),Y>.999999)a=1-e,E=J?-e:e;else{const i=Math.acos(Y),x=1/Math.sin(i);a=Math.sin((1-e)*i)*x,E=J?-Math.sin(e*i)*x:Math.sin(e*i)*x}return j._x=a*i._x+E*x._x,j._y=a*i._y+E*x._y,j._z=a*i._z+E*x._z,j._w=a*i._w+E*x._w,j._isDirty=!0,j}static Hermite(i,x,e,j,E){const a=E*E,Y=E*a,J=2*Y-3*a+1,u=-2*Y+3*a,b=Y-2*a+E,g=Y-a,A=i._x*J+e._x*u+x._x*b+j._x*g,K=i._y*J+e._y*u+x._y*b+j._y*g,L=i._z*J+e._z*u+x._z*b+j._z*g,o=i._w*J+e._w*u+x._w*b+j._w*g;return new T(A,K,L,o)}static Hermite1stDerivative(i,x,e,j,E){const a=new T;return this.Hermite1stDerivativeToRef(i,x,e,j,E,a),a}static Hermite1stDerivativeToRef(i,x,e,j,E,a){const Y=E*E;return a._x=6*(Y-E)*i._x+(3*Y-4*E+1)*x._x+6*(-Y+E)*e._x+(3*Y-2*E)*j._x,a._y=6*(Y-E)*i._y+(3*Y-4*E+1)*x._y+6*(-Y+E)*e._y+(3*Y-2*E)*j._y,a._z=6*(Y-E)*i._z+(3*Y-4*E+1)*x._z+6*(-Y+E)*e._z+(3*Y-2*E)*j._z,a._w=6*(Y-E)*i._w+(3*Y-4*E+1)*x._w+6*(-Y+E)*e._w+(3*Y-2*E)*j._w,a._isDirty=!0,a}static Normalize(i){const x=T.Zero();return T.NormalizeToRef(i,x),x}static NormalizeToRef(i,x){return i.normalizeToRef(x),x}static Clamp(i,x,e){const j=new T;return T.ClampToRef(i,x,e,j),j}static ClampToRef(i,x,e,j){return j.fJ((0,u.Clamp)(i.x,x.x,e.x),(0,u.Clamp)(i.y,x.y,e.y),(0,u.Clamp)(i.z,x.z,e.z),(0,u.Clamp)(i.w,x.w,e.w))}static Random(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new T((0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x))}static RandomToRef(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fJ((0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x),(0,u.RandomRange)(i,x))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(i,x){return Math.sqrt(T.DistanceSquared(i,x))}static DistanceSquared(i,x){const e=i.x-x.x,j=i.y-x.y,E=i.z-x.z,a=i.w-x.w;return e*e+j*j+E*E+a*a}static Center(i,x){return T.CenterToRef(i,x,T.Zero())}static CenterToRef(i,x,e){return e.fJ((i.x+x.x)/2,(i.y+x.y)/2,(i.z+x.z)/2,(i.w+x.w)/2)}}T._V8PerformanceHack=new T(.5,.5,.5,.5),Object.defineProperties(T.prototype,{dimension:{value:[4]},rank:{value:1}});class Q{static get Use64Bits(){return Y.e.MatrixUse64Bits}get m(){return this.Ze}markAsUpdated(){this.updateFlag=b._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(i){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=arguments.length>2&&void 0!==arguments[2]&&arguments[2],j=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=i,this._isIdentity3x2=i||e,this._isIdentityDirty=!this._isIdentity&&x,this._isIdentity3x2Dirty=!this._isIdentity3x2&&j}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,Y.e.MatrixTrackPrecisionChange&&Y.e.MatrixTrackedMatrices.push(this),this.Ze=new Y.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const i=this.Ze;this._isIdentity=1===i[0]&&0===i[1]&&0===i[2]&&0===i[3]&&0===i[4]&&1===i[5]&&0===i[6]&&0===i[7]&&0===i[8]&&0===i[9]&&1===i[10]&&0===i[11]&&0===i[12]&&0===i[13]&&0===i[14]&&1===i[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Ze[0]||1!==this.Ze[5]||1!==this.Ze[15]||0!==this.Ze[1]||0!==this.Ze[2]||0!==this.Ze[3]||0!==this.Ze[4]||0!==this.Ze[6]||0!==this.Ze[7]||0!==this.Ze[8]||0!==this.Ze[9]||0!==this.Ze[10]||0!==this.Ze[11]||0!==this.Ze[12]||0!==this.Ze[13]||0!==this.Ze[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const i=this.Ze,x=i[0],e=i[1],j=i[2],E=i[3],a=i[4],Y=i[5],J=i[6],u=i[7],b=i[8],g=i[9],A=i[10],K=i[11],L=i[12],o=i[13],M=i[14],z=i[15],T=A*z-M*K,Q=g*z-o*K,t=g*M-o*A,V=b*z-L*K,S=b*M-A*L,f=b*o-L*g;return x*+(Y*T-J*Q+u*t)+e*-(a*T-J*V+u*S)+j*+(a*Q-Y*V+u*f)+E*-(a*t-Y*S+J*f)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!i)return this.Ze;const e=this.Ze;for(let j=0;j<16;j++)i[x+j]=e[j];return this}de(){return this.Ze}AJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(i,x,this)}fJ(){for(var i=arguments.length,x=new Array(i),e=0;e<i;e++)x[e]=arguments[e];return Q.FromArrayToRef(x,0,this)}set(){const i=this.Ze;for(let x=0;x<16;x++)i[x]=x<0||arguments.length<=x?void 0:arguments[x];return this.markAsUpdated(),this}OJ(i){const x=this.Ze;for(let e=0;e<16;e++)x[e]=i;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return Q.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(i){const x=new Q;return this.addToRef(i,x),x}addToRef(i,x){const e=this.Ze,j=x.Ze,E=i.m;for(let a=0;a<16;a++)j[a]=e[a]+E[a];return x.markAsUpdated(),x}addToSelf(i){const x=this.Ze,e=i.m;return x[0]+=e[0],x[1]+=e[1],x[2]+=e[2],x[3]+=e[3],x[4]+=e[4],x[5]+=e[5],x[6]+=e[6],x[7]+=e[7],x[8]+=e[8],x[9]+=e[9],x[10]+=e[10],x[11]+=e[11],x[12]+=e[12],x[13]+=e[13],x[14]+=e[14],x[15]+=e[15],this.markAsUpdated(),this}addInPlace(i){const x=this.Ze,e=i.m;for(let j=0;j<16;j++)x[j]+=e[j];return this.markAsUpdated(),this}addInPlaceFromFloats(){const i=this.Ze;for(let x=0;x<16;x++)i[x]+=x<0||arguments.length<=x?void 0:arguments[x];return this.markAsUpdated(),this}Cx(i){const x=this.Ze,e=i.m;for(let j=0;j<16;j++)x[j]-=e[j];return this.markAsUpdated(),this}subtractToRef(i,x){const e=this.Ze,j=i.m,E=x.Ze;for(let a=0;a<16;a++)E[a]=e[a]-j[a];return x.markAsUpdated(),x}jK(i){const x=this.Ze,e=i.m;for(let j=0;j<16;j++)x[j]-=e[j];return this.markAsUpdated(),this}subtractFromFloats(){for(var i=arguments.length,x=new Array(i),e=0;e<i;e++)x[e]=arguments[e];return this.subtractFromFloatsToRef(...x,new Q)}subtractFromFloatsToRef(){for(var i=arguments.length,x=new Array(i),e=0;e<i;e++)x[e]=arguments[e];const j=x.pop(),E=this.Ze,a=j.Ze,Y=x;for(let J=0;J<16;J++)a[J]=E[J]-Y[J];return j.markAsUpdated(),j}invertToRef(i){return!0===this._isIdentity?(Q.IdentityToRef(i),i):(K(this,i.de())?i.markAsUpdated():i.A(this),i)}addAtIndex(i,x){return this.Ze[i]+=x,this.markAsUpdated(),this}multiplyAtIndex(i,x){return this.Ze[i]*=x,this.markAsUpdated(),this}setTranslationFromFloats(i,x,e){return this.Ze[12]=i,this.Ze[13]=x,this.Ze[14]=e,this.markAsUpdated(),this}addTranslationFromFloats(i,x,e){return this.Ze[12]+=i,this.Ze[13]+=x,this.Ze[14]+=e,this.markAsUpdated(),this}setTranslation(i){return this.setTranslationFromFloats(i._x,i._y,i._z)}getTranslation(){return new M(this.Ze[12],this.Ze[13],this.Ze[14])}getTranslationToRef(i){return i.x=this.Ze[12],i.y=this.Ze[13],i.z=this.Ze[14],i}removeRotationAndScaling(){const i=this.m;return Q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,i[12],i[13],i[14],i[15],this),this._updateIdentityStatus(0===i[12]&&0===i[13]&&0===i[14]&&1===i[15]),this}A(i){i.copyToArray(this.Ze);const x=i;return this.updateFlag=x.updateFlag,this._updateIdentityStatus(x._isIdentity,x._isIdentityDirty,x._isIdentity3x2,x._isIdentity3x2Dirty),this}copyToArray(i){return A(this,i,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(i){const x=new Q;return this.multiplyToRef(i,x),x}multiplyInPlace(i){const x=this.Ze,e=i.m;for(let j=0;j<16;j++)x[j]*=e[j];return this.markAsUpdated(),this}multiplyByFloats(){const i=this.Ze;for(let x=0;x<16;x++)i[x]*=x<0||arguments.length<=x?void 0:arguments[x];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var i=arguments.length,x=new Array(i),e=0;e<i;e++)x[e]=arguments[e];const j=x.pop(),E=this.Ze,a=j.Ze,Y=x;for(let J=0;J<16;J++)a[J]=E[J]*Y[J];return j.markAsUpdated(),j}multiplyToRef(i,x){return this._isIdentity?(x.A(i),x):i._isIdentity?(x.A(this),x):(this.multiplyToArray(i,x.Ze,0),x.markAsUpdated(),x)}multiplyToArray(i,x,e){return g(this,i,x,e),this}divide(i){return this.divideToRef(i,new Q)}divideToRef(i,x){const e=this.Ze,j=i.m,E=x.Ze;for(let a=0;a<16;a++)E[a]=e[a]/j[a];return x.markAsUpdated(),x}divideInPlace(i){const x=this.Ze,e=i.m;for(let j=0;j<16;j++)x[j]/=e[j];return this.markAsUpdated(),this}minimizeInPlace(i){const x=this.Ze,e=i.m;for(let j=0;j<16;j++)x[j]=Math.min(x[j],e[j]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const i=this.Ze;for(let x=0;x<16;x++)i[x]=Math.min(i[x],x<0||arguments.length<=x?void 0:arguments[x]);return this.markAsUpdated(),this}maximizeInPlace(i){const x=this.Ze,e=i.m;for(let j=0;j<16;j++)x[j]=Math.min(x[j],e[j]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const i=this.Ze;for(let x=0;x<16;x++)i[x]=Math.min(i[x],x<0||arguments.length<=x?void 0:arguments[x]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new Q)}negateInPlace(){const i=this.Ze;for(let x=0;x<16;x++)i[x]=-i[x];return this.markAsUpdated(),this}negateToRef(i){const x=this.Ze,e=i.Ze;for(let j=0;j<16;j++)e[j]=-x[j];return i.markAsUpdated(),i}equals(i){const x=i;if(!x)return!1;if((this._isIdentity||x._isIdentity)&&!this._isIdentityDirty&&!x._isIdentityDirty)return this._isIdentity&&x._isIdentity;const e=this.m,j=x.m;return e[0]===j[0]&&e[1]===j[1]&&e[2]===j[2]&&e[3]===j[3]&&e[4]===j[4]&&e[5]===j[5]&&e[6]===j[6]&&e[7]===j[7]&&e[8]===j[8]&&e[9]===j[9]&&e[10]===j[10]&&e[11]===j[11]&&e[12]===j[12]&&e[13]===j[13]&&e[14]===j[14]&&e[15]===j[15]}equalsWithEpsilon(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const e=this.Ze,j=i.m;for(let E=0;E<16;E++)if(!(0,u.WithinEpsilon)(e[E],j[E],x))return!1;return!0}equalsToFloats(){const i=this.Ze;for(let x=0;x<16;x++)if(i[x]!=(x<0||arguments.length<=x?void 0:arguments[x]))return!1;return!0}floor(){return this.floorToRef(new Q)}floorToRef(i){const x=this.Ze,e=i.Ze;for(let j=0;j<16;j++)e[j]=Math.floor(x[j]);return i.markAsUpdated(),i}fract(){return this.fractToRef(new Q)}fractToRef(i){const x=this.Ze,e=i.Ze;for(let j=0;j<16;j++)e[j]=x[j]-Math.floor(x[j]);return i.markAsUpdated(),i}clone(){const i=new Q;return i.A(this),i}getClassName(){return"Matrix"}getHashCode(){let i=L(this.Ze[0]);for(let x=1;x<16;x++)i=397*i^L(this.Ze[x]);return i}decomposeToTransformNode(i){return i.rotationQuaternion=i.rotationQuaternion||new T,this.decompose(i.wJ,i.rotationQuaternion,i.position)}decompose(i,x,e,j){let E=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return e&&e.OJ(0),i&&i.OJ(1),x&&x.fJ(0,0,0,1),!0;const a=this.Ze;if(e&&e.fJ(a[12],a[13],a[14]),(i=i||t.KJ[0]).x=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]),i.y=Math.sqrt(a[4]*a[4]+a[5]*a[5]+a[6]*a[6]),i.z=Math.sqrt(a[8]*a[8]+a[9]*a[9]+a[10]*a[10]),j){const x=(E?j.absoluteScaling.x:j.wJ.x)<0?-1:1,e=(E?j.absoluteScaling.y:j.wJ.y)<0?-1:1,a=(E?j.absoluteScaling.z:j.wJ.z)<0?-1:1;i.x*=x,i.y*=e,i.z*=a}else this.determinant()<=0&&(i.y*=-1);if(0===i._x||0===i._y||0===i._z)return x&&x.fJ(0,0,0,1),!1;if(x){const e=1/i._x,j=1/i._y,E=1/i._z;Q.FromValuesToRef(a[0]*e,a[1]*e,a[2]*e,0,a[4]*j,a[5]*j,a[6]*j,0,a[8]*E,a[9]*E,a[10]*E,0,0,0,0,1,t.Matrix[0]),T.FromRotationMatrixToRef(t.Matrix[0],x)}return!0}getRow(i){if(i<0||i>3)return null;const x=4*i;return new z(this.Ze[x+0],this.Ze[x+1],this.Ze[x+2],this.Ze[x+3])}getRowToRef(i,x){if(i>=0&&i<=3){const e=4*i;x.x=this.Ze[e+0],x.y=this.Ze[e+1],x.z=this.Ze[e+2],x.w=this.Ze[e+3]}return x}setRow(i,x){return this.setRowFromFloats(i,x.x,x.y,x.z,x.w)}transpose(){const i=new Q;return Q.TransposeToRef(this,i),i}transposeToRef(i){return Q.TransposeToRef(this,i),i}setRowFromFloats(i,x,e,j,E){if(i<0||i>3)return this;const a=4*i;return this.Ze[a+0]=x,this.Ze[a+1]=e,this.Ze[a+2]=j,this.Ze[a+3]=E,this.markAsUpdated(),this}scale(i){const x=new Q;return this.scaleToRef(i,x),x}scaleToRef(i,x){for(let e=0;e<16;e++)x.Ze[e]=this.Ze[e]*i;return x.markAsUpdated(),x}scaleAndAddToRef(i,x){for(let e=0;e<16;e++)x.Ze[e]+=this.Ze[e]*i;return x.markAsUpdated(),x}scaleInPlace(i){const x=this.Ze;for(let e=0;e<16;e++)x[e]*=i;return this.markAsUpdated(),this}toNormalMatrix(i){const x=t.Matrix[0];this.invertToRef(x),x.transposeToRef(i);const e=i.Ze;return Q.FromValuesToRef(e[0],e[1],e[2],0,e[4],e[5],e[6],0,e[8],e[9],e[10],0,0,0,0,1,i),i}getRotationMatrix(){const i=new Q;return this.getRotationMatrixToRef(i),i}getRotationMatrixToRef(i){const x=t.KJ[0];if(!this.decompose(x))return Q.IdentityToRef(i),i;const e=this.Ze,j=1/x._x,E=1/x._y,a=1/x._z;return Q.FromValuesToRef(e[0]*j,e[1]*j,e[2]*j,0,e[4]*E,e[5]*E,e[6]*E,0,e[8]*a,e[9]*a,e[10]*a,0,0,0,0,1,i),i}toggleModelMatrixHandInPlace(){const i=this.Ze;return i[2]*=-1,i[6]*=-1,i[8]*=-1,i[9]*=-1,i[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const i=this.Ze;return i[8]*=-1,i[9]*=-1,i[10]*=-1,i[11]*=-1,this.markAsUpdated(),this}static zJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const e=new Q;return Q.FromArrayToRef(i,x,e),e}static FromArrayToRef(i,x,e){for(let j=0;j<16;j++)e.Ze[j]=i[j+x];return e.markAsUpdated(),e}static FromFloat32ArrayToRefScaled(i,x,e,j){return j.Ze[0]=i[0+x]*e,j.Ze[1]=i[1+x]*e,j.Ze[2]=i[2+x]*e,j.Ze[3]=i[3+x]*e,j.Ze[4]=i[4+x]*e,j.Ze[5]=i[5+x]*e,j.Ze[6]=i[6+x]*e,j.Ze[7]=i[7+x]*e,j.Ze[8]=i[8+x]*e,j.Ze[9]=i[9+x]*e,j.Ze[10]=i[10+x]*e,j.Ze[11]=i[11+x]*e,j.Ze[12]=i[12+x]*e,j.Ze[13]=i[13+x]*e,j.Ze[14]=i[14+x]*e,j.Ze[15]=i[15+x]*e,j.markAsUpdated(),j}static get IdentityReadOnly(){return Q._IdentityReadOnly}static FromValuesToRef(i,x,e,j,E,a,Y,J,u,b,g,A,K,L,o,M,z){const T=z.Ze;T[0]=i,T[1]=x,T[2]=e,T[3]=j,T[4]=E,T[5]=a,T[6]=Y,T[7]=J,T[8]=u,T[9]=b,T[10]=g,T[11]=A,T[12]=K,T[13]=L,T[14]=o,T[15]=M,z.markAsUpdated()}static FromValues(i,x,e,j,E,a,Y,J,u,b,g,A,K,L,o,M){const z=new Q,T=z.Ze;return T[0]=i,T[1]=x,T[2]=e,T[3]=j,T[4]=E,T[5]=a,T[6]=Y,T[7]=J,T[8]=u,T[9]=b,T[10]=g,T[11]=A,T[12]=K,T[13]=L,T[14]=o,T[15]=M,z.markAsUpdated(),z}static Compose(i,x,e){const j=new Q;return Q.ComposeToRef(i,x,e,j),j}static ComposeToRef(i,x,e,j){const E=j.Ze,a=x._x,Y=x._y,J=x._z,u=x._w,b=a+a,g=Y+Y,A=J+J,K=a*b,L=a*g,o=a*A,M=Y*g,z=Y*A,T=J*A,Q=u*b,t=u*g,V=u*A,S=i._x,f=i._y,w=i._z;return E[0]=(1-(M+T))*S,E[1]=(L+V)*S,E[2]=(o-t)*S,E[3]=0,E[4]=(L-V)*f,E[5]=(1-(K+T))*f,E[6]=(z+Q)*f,E[7]=0,E[8]=(o+t)*w,E[9]=(z-Q)*w,E[10]=(1-(K+M))*w,E[11]=0,E[12]=e._x,E[13]=e._y,E[14]=e._z,E[15]=1,j.markAsUpdated(),j}static Identity(){const i=Q.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return i._updateIdentityStatus(!0),i}static IdentityToRef(i){return Q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,i),i._updateIdentityStatus(!0),i}static Zero(){const i=Q.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return i._updateIdentityStatus(!1),i}static RotationX(i){const x=new Q;return Q.RotationXToRef(i,x),x}static Invert(i){const x=new Q;return i.invertToRef(x),x}static RotationXToRef(i,x){const e=Math.sin(i),j=Math.cos(i);return Q.FromValuesToRef(1,0,0,0,0,j,e,0,0,-e,j,0,0,0,0,1,x),x._updateIdentityStatus(1===j&&0===e),x}static RotationY(i){const x=new Q;return Q.RotationYToRef(i,x),x}static RotationYToRef(i,x){const e=Math.sin(i),j=Math.cos(i);return Q.FromValuesToRef(j,0,-e,0,0,1,0,0,e,0,j,0,0,0,0,1,x),x._updateIdentityStatus(1===j&&0===e),x}static RotationZ(i){const x=new Q;return Q.RotationZToRef(i,x),x}static RotationZToRef(i,x){const e=Math.sin(i),j=Math.cos(i);return Q.FromValuesToRef(j,e,0,0,-e,j,0,0,0,0,1,0,0,0,0,1,x),x._updateIdentityStatus(1===j&&0===e),x}static RotationAxis(i,x){const e=new Q;return Q.RotationAxisToRef(i,x,e),e}static RotationAxisToRef(i,x,e){const j=Math.sin(-x),E=Math.cos(-x),a=1-E;i=i.normalizeToRef(t.KJ[0]);const Y=e.Ze;return Y[0]=i._x*i._x*a+E,Y[1]=i._x*i._y*a-i._z*j,Y[2]=i._x*i._z*a+i._y*j,Y[3]=0,Y[4]=i._y*i._x*a+i._z*j,Y[5]=i._y*i._y*a+E,Y[6]=i._y*i._z*a-i._x*j,Y[7]=0,Y[8]=i._z*i._x*a-i._y*j,Y[9]=i._z*i._y*a+i._x*j,Y[10]=i._z*i._z*a+E,Y[11]=0,Y[12]=0,Y[13]=0,Y[14]=0,Y[15]=1,e.markAsUpdated(),e}static RotationAlignToRef(i,x,e){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=M.Dot(x,i),Y=e.Ze;if(a<-1+j.e)Y[0]=-1,Y[1]=0,Y[2]=0,Y[3]=0,Y[4]=0,Y[5]=E?1:-1,Y[6]=0,Y[7]=0,Y[8]=0,Y[9]=0,Y[10]=E?-1:1,Y[11]=0;else{const e=M.Cross(x,i),j=1/(1+a);Y[0]=e._x*e._x*j+a,Y[1]=e._y*e._x*j-e._z,Y[2]=e._z*e._x*j+e._y,Y[3]=0,Y[4]=e._x*e._y*j+e._z,Y[5]=e._y*e._y*j+a,Y[6]=e._z*e._y*j-e._x,Y[7]=0,Y[8]=e._x*e._z*j-e._y,Y[9]=e._y*e._z*j+e._x,Y[10]=e._z*e._z*j+a,Y[11]=0}return Y[12]=0,Y[13]=0,Y[14]=0,Y[15]=1,e.markAsUpdated(),e}static RotationYawPitchRoll(i,x,e){const j=new Q;return Q.RotationYawPitchRollToRef(i,x,e,j),j}static RotationYawPitchRollToRef(i,x,e,j){return T.RotationYawPitchRollToRef(i,x,e,t.Quaternion[0]),t.Quaternion[0].toRotationMatrix(j),j}static Scaling(i,x,e){const j=new Q;return Q.ScalingToRef(i,x,e,j),j}static ScalingToRef(i,x,e,j){return Q.FromValuesToRef(i,0,0,0,0,x,0,0,0,0,e,0,0,0,0,1,j),j._updateIdentityStatus(1===i&&1===x&&1===e),j}static Translation(i,x,e){const j=new Q;return Q.TranslationToRef(i,x,e,j),j}static TranslationToRef(i,x,e,j){return Q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,i,x,e,1,j),j._updateIdentityStatus(0===i&&0===x&&0===e),j}static Lerp(i,x,e){const j=new Q;return Q.LerpToRef(i,x,e,j),j}static LerpToRef(i,x,e,j){const E=j.Ze,a=i.m,Y=x.m;for(let J=0;J<16;J++)E[J]=a[J]*(1-e)+Y[J]*e;return j.markAsUpdated(),j}static DecomposeLerp(i,x,e){const j=new Q;return Q.DecomposeLerpToRef(i,x,e,j),j}static DecomposeLerpToRef(i,x,e,j){const E=t.KJ[0],a=t.Quaternion[0],Y=t.KJ[1];i.decompose(E,a,Y);const J=t.KJ[2],u=t.Quaternion[1],b=t.KJ[3];x.decompose(J,u,b);const g=t.KJ[4];M.LerpToRef(E,J,e,g);const A=t.Quaternion[2];T.SlerpToRef(a,u,e,A);const K=t.KJ[5];return M.LerpToRef(Y,b,e,K),Q.ComposeToRef(g,A,K,j),j}static LookAtLH(i,x,e){const j=new Q;return Q.LookAtLHToRef(i,x,e,j),j}static LookAtLHToRef(i,x,e,j){const E=t.KJ[0],a=t.KJ[1],Y=t.KJ[2];x.subtractToRef(i,Y),Y.normalize(),M.CrossToRef(e,Y,E);const J=E.lengthSquared();0===J?E.x=1:E.normalizeFromLength(Math.sqrt(J)),M.CrossToRef(Y,E,a),a.normalize();const u=-M.Dot(E,i),b=-M.Dot(a,i),g=-M.Dot(Y,i);return Q.FromValuesToRef(E._x,a._x,Y._x,0,E._y,a._y,Y._y,0,E._z,a._z,Y._z,0,u,b,g,1,j),j}static LookAtRH(i,x,e){const j=new Q;return Q.LookAtRHToRef(i,x,e,j),j}static LookAtRHToRef(i,x,e,j){const E=t.KJ[0],a=t.KJ[1],Y=t.KJ[2];i.subtractToRef(x,Y),Y.normalize(),M.CrossToRef(e,Y,E);const J=E.lengthSquared();0===J?E.x=1:E.normalizeFromLength(Math.sqrt(J)),M.CrossToRef(Y,E,a),a.normalize();const u=-M.Dot(E,i),b=-M.Dot(a,i),g=-M.Dot(Y,i);return Q.FromValuesToRef(E._x,a._x,Y._x,0,E._y,a._y,Y._y,0,E._z,a._z,Y._z,0,u,b,g,1,j),j}static LookDirectionLH(i,x){const e=new Q;return Q.LookDirectionLHToRef(i,x,e),e}static LookDirectionLHToRef(i,x,e){const j=t.KJ[0];j.A(i),j.scaleInPlace(-1);const E=t.KJ[1];return M.CrossToRef(x,j,E),Q.FromValuesToRef(E._x,E._y,E._z,0,x._x,x._y,x._z,0,j._x,j._y,j._z,0,0,0,0,1,e),e}static LookDirectionRH(i,x){const e=new Q;return Q.LookDirectionRHToRef(i,x,e),e}static LookDirectionRHToRef(i,x,e){const j=t.KJ[2];return M.CrossToRef(x,i,j),Q.FromValuesToRef(j._x,j._y,j._z,0,x._x,x._y,x._z,0,i._x,i._y,i._z,0,0,0,0,1,e),e}static OrthoLH(i,x,e,j,E){const a=new Q;return Q.OrthoLHToRef(i,x,e,j,a,E),a}static OrthoLHToRef(i,x,e,j,E,a){const Y=2/i,J=2/x,u=2/(j-e),b=-(j+e)/(j-e);return Q.FromValuesToRef(Y,0,0,0,0,J,0,0,0,0,u,0,0,0,b,1,E),a&&E.multiplyToRef(S,E),E._updateIdentityStatus(1===Y&&1===J&&1===u&&0===b),E}static OrthoOffCenterLH(i,x,e,j,E,a,Y){const J=new Q;return Q.OrthoOffCenterLHToRef(i,x,e,j,E,a,J,Y),J}static OrthoOffCenterLHToRef(i,x,e,j,E,a,Y,J){const u=2/(x-i),b=2/(j-e),g=2/(a-E),A=-(a+E)/(a-E),K=(i+x)/(i-x),L=(j+e)/(e-j);return Q.FromValuesToRef(u,0,0,0,0,b,0,0,0,0,g,0,K,L,A,1,Y),J&&Y.multiplyToRef(S,Y),Y.markAsUpdated(),Y}static ObliqueOffCenterLHToRef(i,x,e,j,E,a,Y,J,u,b,g){const A=-Y*Math.cos(J),K=-Y*Math.sin(J);return Q.TranslationToRef(0,0,-u,t.Matrix[1]),Q.FromValuesToRef(1,0,0,0,0,1,0,0,A,K,1,0,0,0,0,1,t.Matrix[0]),t.Matrix[1].multiplyToRef(t.Matrix[0],t.Matrix[0]),Q.TranslationToRef(0,0,u,t.Matrix[1]),t.Matrix[0].multiplyToRef(t.Matrix[1],t.Matrix[0]),Q.OrthoOffCenterLHToRef(i,x,e,j,E,a,b,g),t.Matrix[0].multiplyToRef(b,b),b}static OrthoOffCenterRH(i,x,e,j,E,a,Y){const J=new Q;return Q.OrthoOffCenterRHToRef(i,x,e,j,E,a,J,Y),J}static OrthoOffCenterRHToRef(i,x,e,j,E,a,Y,J){return Q.OrthoOffCenterLHToRef(i,x,e,j,E,a,Y,J),Y.Ze[10]*=-1,Y}static ObliqueOffCenterRHToRef(i,x,e,j,E,a,Y,J,u,b,g){const A=Y*Math.cos(J),K=Y*Math.sin(J);return Q.TranslationToRef(0,0,u,t.Matrix[1]),Q.FromValuesToRef(1,0,0,0,0,1,0,0,A,K,1,0,0,0,0,1,t.Matrix[0]),t.Matrix[1].multiplyToRef(t.Matrix[0],t.Matrix[0]),Q.TranslationToRef(0,0,-u,t.Matrix[1]),t.Matrix[0].multiplyToRef(t.Matrix[1],t.Matrix[0]),Q.OrthoOffCenterRHToRef(i,x,e,j,E,a,b,g),t.Matrix[0].multiplyToRef(b,b),b}static PerspectiveLH(i,x,e,j,E){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const Y=new Q,J=2*e/i,u=2*e/x,b=(j+e)/(j-e),g=-2*j*e/(j-e),A=Math.tan(a);return Q.FromValuesToRef(J,0,0,0,0,u,0,A,0,0,b,1,0,0,g,0,Y),E&&Y.multiplyToRef(S,Y),Y._updateIdentityStatus(!1),Y}static PerspectiveFovLH(i,x,e,j,E){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const J=new Q;return Q.PerspectiveFovLHToRef(i,x,e,j,J,!0,E,a,Y),J}static PerspectiveFovLHToRef(i,x,e,j,E){let a=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const b=e,g=j,A=1/Math.tan(.5*i),K=a?A/x:A,L=a?A:A*x,o=u&&0===b?-1:0!==g?(g+b)/(g-b):1,M=u&&0===b?2*g:0!==g?-2*g*b/(g-b):-2*b,z=Math.tan(J);return Q.FromValuesToRef(K,0,0,0,0,L,0,z,0,0,o,1,0,0,M,0,E),Y&&E.multiplyToRef(S,E),E._updateIdentityStatus(!1),E}static PerspectiveFovReverseLHToRef(i,x,e,j,E){let a=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const u=1/Math.tan(.5*i),b=a?u/x:u,g=a?u:u*x,A=Math.tan(J);return Q.FromValuesToRef(b,0,0,0,0,g,0,A,0,0,-e,1,0,0,1,0,E),Y&&E.multiplyToRef(S,E),E._updateIdentityStatus(!1),E}static PerspectiveFovRH(i,x,e,j,E){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const J=new Q;return Q.PerspectiveFovRHToRef(i,x,e,j,J,!0,E,a,Y),J}static PerspectiveFovRHToRef(i,x,e,j,E){let a=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const b=e,g=j,A=1/Math.tan(.5*i),K=a?A/x:A,L=a?A:A*x,o=u&&0===b?1:0!==g?-(g+b)/(g-b):-1,M=u&&0===b?2*g:0!==g?-2*g*b/(g-b):-2*b,z=Math.tan(J);return Q.FromValuesToRef(K,0,0,0,0,L,0,z,0,0,o,-1,0,0,M,0,E),Y&&E.multiplyToRef(S,E),E._updateIdentityStatus(!1),E}static PerspectiveFovReverseRHToRef(i,x,e,j,E){let a=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const u=1/Math.tan(.5*i),b=a?u/x:u,g=a?u:u*x,A=Math.tan(J);return Q.FromValuesToRef(b,0,0,0,0,g,0,A,0,0,-e,-1,0,0,-1,0,E),Y&&E.multiplyToRef(S,E),E._updateIdentityStatus(!1),E}static GetFinalMatrix(i,x,e,j,E,a){const Y=i.width,J=i.height,u=i.x,b=i.y,g=Q.FromValues(Y/2,0,0,0,0,-J/2,0,0,0,0,a-E,0,u+Y/2,J/2+b,E,1),A=new Q;return x.multiplyToRef(e,A),A.multiplyToRef(j,A),A.multiplyToRef(g,A)}static GetAsMatrix2x2(i){const x=i.m,e=[x[0],x[1],x[4],x[5]];return Y.e.MatrixUse64Bits?e:new Float32Array(e)}static GetAsMatrix3x3(i){const x=i.m,e=[x[0],x[1],x[2],x[4],x[5],x[6],x[8],x[9],x[10]];return Y.e.MatrixUse64Bits?e:new Float32Array(e)}static Transpose(i){const x=new Q;return Q.TransposeToRef(i,x),x}static TransposeToRef(i,x){const e=i.m,j=e[0],E=e[4],a=e[8],Y=e[12],J=e[1],u=e[5],b=e[9],g=e[13],A=e[2],K=e[6],L=e[10],o=e[14],M=e[3],z=e[7],T=e[11],Q=e[15],t=x.Ze;return t[0]=j,t[1]=E,t[2]=a,t[3]=Y,t[4]=J,t[5]=u,t[6]=b,t[7]=g,t[8]=A,t[9]=K,t[10]=L,t[11]=o,t[12]=M,t[13]=z,t[14]=T,t[15]=Q,x.markAsUpdated(),x._updateIdentityStatus(i._isIdentity,i._isIdentityDirty),x}static Reflection(i){const x=new Q;return Q.ReflectionToRef(i,x),x}static ReflectionToRef(i,x){i.normalize();const e=i.normal.x,j=i.normal.y,E=i.normal.z,a=-2*e,Y=-2*j,J=-2*E;return Q.FromValuesToRef(a*e+1,Y*e,J*e,0,a*j,Y*j+1,J*j,0,a*E,Y*E,J*E+1,0,a*i.d,Y*i.d,J*i.d,1,x),x}static FromXYZAxesToRef(i,x,e,j){return Q.FromValuesToRef(i._x,i._y,i._z,0,x._x,x._y,x._z,0,e._x,e._y,e._z,0,0,0,0,1,j),j}static FromQuaternionToRef(i,x){const e=i._x*i._x,j=i._y*i._y,E=i._z*i._z,a=i._x*i._y,Y=i._z*i._w,J=i._z*i._x,u=i._y*i._w,b=i._y*i._z,g=i._x*i._w;return x.Ze[0]=1-2*(j+E),x.Ze[1]=2*(a+Y),x.Ze[2]=2*(J-u),x.Ze[3]=0,x.Ze[4]=2*(a-Y),x.Ze[5]=1-2*(E+e),x.Ze[6]=2*(b+g),x.Ze[7]=0,x.Ze[8]=2*(J+u),x.Ze[9]=2*(b-g),x.Ze[10]=1-2*(j+e),x.Ze[11]=0,x.Ze[12]=0,x.Ze[13]=0,x.Ze[14]=0,x.Ze[15]=1,x.markAsUpdated(),x}}Q._IdentityReadOnly=Q.Identity(),Object.defineProperties(Q.prototype,{dimension:{value:[4,4]},rank:{value:2}});class t{}t.KJ=(0,E.h)(11,M.Zero),t.Matrix=(0,E.h)(2,Q.Identity),t.Quaternion=(0,E.h)(3,T.Zero);class V{}V.Vector2=(0,E.h)(3,o.Zero),V.KJ=(0,E.h)(13,M.Zero),V.Vector4=(0,E.h)(3,z.Zero),V.Quaternion=(0,E.h)(3,T.Zero),V.Matrix=(0,E.h)(8,Q.Identity),(0,a.f)("BABYLON.Vector2",o),(0,a.f)("BABYLON.Vector3",M),(0,a.f)("BABYLON.Vector4",z),(0,a.f)("BABYLON.Matrix",Q);const S=Q.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12259:(i,x,e)=>{function j(i,x){const e=[];for(let j=0;j<i;++j)e.push(x());return e}function E(i,x){return j(i,x)}e.d(x,{d:()=>j,h:()=>E,i:()=>Y});const a=["push","splice","pop","shift","unshift"];function Y(i,x){const e=a.map((e=>function(i,x,e){const j=i[x];if("function"!==typeof j)return null;const E=function(){const j=i.length,a=E.previous.apply(i,arguments);return e(x,j),a};return j.next=E,E.previous=j,i[x]=E,()=>{const e=E.previous;if(!e)return;const j=E.next;j?(e.next=j,j.previous=e):(e.next=void 0,i[x]=e),E.next=void 0,E.previous=void 0}}(i,e,x)));return()=>{for(const i of e)null===i||void 0===i||i()}}}}]);