"use strict";(self.n4ygn1cq9vg=self.n4ygn1cq9vg||[]).push([[14],{12429:(e,d,v)=>{v.d(d,{e:()=>B,i:()=>L,l:()=>P,p:()=>p});const P=1/2.2,p=2.2,L=(1+Math.sqrt(5))/2,B=.001},12440:(e,d,v)=>{function P(e){return parseInt(e.toString().replace(/\W/g,""))}function p(e,d){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(e-d)<=v}function L(e,d,v){let P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return e<d-P||e>v+P}function B(e,d){return e===d?e:Math.random()*(d-e)+e}function X(e,d,v){return e+(d-e)*v}function z(e,d,v){let P=U(d-e,360);return P>180&&(P-=360),e+P*g(v)}function W(e,d,v){let P=0;return P=e!=d?g((v-e)/(d-e)):0,P}function V(e,d,v,P,p){const L=p*p,B=p*L;return e*(2*B-3*L+1)+v*(-2*B+3*L)+d*(B-2*L+p)+P*(B-L)}function k(e,d,v,P,p){const L=p*p;return 6*(L-p)*e+(3*L-4*p+1)*d+6*(-L+p)*v+(3*L-2*p)*P}function g(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(v,Math.max(d,e))}function F(e){return e-=2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function w(e){const d=e.toString(16);return e<=15?("0"+d).toUpperCase():d.toUpperCase()}function G(e){if(Math.log2)return Math.floor(Math.log2(e));if(e<0)return NaN;if(0===e)return-1/0;let d=0;if(e<1){for(;e<1;)d++,e*=2;d=-d}else if(e>1)for(;e>1;)d++,e=Math.floor(e/2);return d}function U(e,d){return e-Math.floor(e/d)*d}function D(e,d,v){return(e-d)/(v-d)}function C(e,d,v){return e*(v-d)+d}function q(e,d){let v=U(d-e,360);return v>180&&(v-=360),v}function h(e,d){const v=U(e,2*d);return d-Math.abs(v-d)}function l(e,d,v){let P=g(v);return P=-2*P*P*P+3*P*P,d*P+e*(1-P)}function n(e,d,v){let P=0;return P=Math.abs(d-e)<=v?d:e+Math.sign(d-e)*v,P}function A(e,d,v){const P=q(e,d);let p=0;return p=-v<P&&P<v?d:n(e,d=e+P,v),p}function x(e,d,v){return(e-d)/(v-d)}function i(e,d,v){return(v-d)*e+d}function me(e,d){const v=e%d;return 0===v?d:me(d,v)}v.r(d),v.d(d,{Clamp:()=>g,DeltaAngle:()=>q,Denormalize:()=>C,ExtractAsInt:()=>P,Hermite:()=>V,Hermite1stDerivative:()=>k,HighestCommonFactor:()=>me,ILog2:()=>G,InverseLerp:()=>W,Lerp:()=>X,LerpAngle:()=>z,MoveTowards:()=>n,MoveTowardsAngle:()=>A,Normalize:()=>D,NormalizeRadians:()=>F,OutsideRange:()=>L,PercentToRange:()=>i,PingPong:()=>h,RandomRange:()=>B,RangeToPercent:()=>x,Repeat:()=>U,SmoothStep:()=>l,ToHex:()=>w,WithinEpsilon:()=>p})},12420:(e,d,v)=>{v.r(d),v.d(d,{Matrix:()=>C,Quaternion:()=>D,TmpVectors:()=>h,Vector2:()=>w,mv:()=>G,Vector4:()=>U});var P=v(12429),p=v(12433),L=v(12381),B=v(12350),X=v(12281),z=v(12440);class W{}function V(e,d,v){let P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const p=e.Yd(),L=d.Yd(),B=p[0],X=p[1],z=p[2],W=p[3],V=p[4],k=p[5],g=p[6],F=p[7],w=p[8],G=p[9],U=p[10],D=p[11],C=p[12],q=p[13],h=p[14],l=p[15],n=L[0],A=L[1],x=L[2],i=L[3],me=L[4],r=L[5],Z=L[6],f=L[7],T=L[8],S=L[9],o=L[10],K=L[11],Q=L[12],N=L[13],u=L[14],O=L[15];v[P]=B*n+X*me+z*T+W*Q,v[P+1]=B*A+X*r+z*S+W*N,v[P+2]=B*x+X*Z+z*o+W*u,v[P+3]=B*i+X*f+z*K+W*O,v[P+4]=V*n+k*me+g*T+F*Q,v[P+5]=V*A+k*r+g*S+F*N,v[P+6]=V*x+k*Z+g*o+F*u,v[P+7]=V*i+k*f+g*K+F*O,v[P+8]=w*n+G*me+U*T+D*Q,v[P+9]=w*A+G*r+U*S+D*N,v[P+10]=w*x+G*Z+U*o+D*u,v[P+11]=w*i+G*f+U*K+D*O,v[P+12]=C*n+q*me+h*T+l*Q,v[P+13]=C*A+q*r+h*S+l*N,v[P+14]=C*x+q*Z+h*o+l*u,v[P+15]=C*i+q*f+h*K+l*O}function k(e,d){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const P=e.Yd();d[v]=P[0],d[v+1]=P[1],d[v+2]=P[2],d[v+3]=P[3],d[v+4]=P[4],d[v+5]=P[5],d[v+6]=P[6],d[v+7]=P[7],d[v+8]=P[8],d[v+9]=P[9],d[v+10]=P[10],d[v+11]=P[11],d[v+12]=P[12],d[v+13]=P[13],d[v+14]=P[14],d[v+15]=P[15]}function g(e,d){const v=e.Yd(),P=v[0],p=v[1],L=v[2],B=v[3],X=v[4],z=v[5],W=v[6],V=v[7],k=v[8],g=v[9],F=v[10],w=v[11],G=v[12],U=v[13],D=v[14],C=v[15],q=F*C-D*w,h=g*C-U*w,l=g*D-U*F,n=k*C-G*w,A=k*D-F*G,x=k*U-G*g,i=+(z*q-W*h+V*l),me=-(X*q-W*n+V*A),r=+(X*h-z*n+V*x),Z=-(X*l-z*A+W*x),f=P*i+p*me+L*r+B*Z;if(0===f)return!1;const T=1/f,S=W*C-D*V,o=z*C-U*V,K=z*D-U*W,Q=X*C-G*V,N=X*D-G*W,u=X*U-G*z,O=W*w-F*V,R=z*w-g*V,Y=z*F-g*W,H=X*w-k*V,a=X*F-k*W,t=X*g-k*z,I=-(p*q-L*h+B*l),c=+(P*q-L*n+B*A),b=-(P*h-p*n+B*x),M=+(P*l-p*A+L*x),s=+(p*S-L*o+B*K),y=-(P*S-L*Q+B*N),j=+(P*o-p*Q+B*u),J=-(P*K-p*N+L*u),E=-(p*O-L*R+B*Y),ee=+(P*O-L*H+B*a),de=-(P*R-p*H+B*t),ve=+(P*Y-p*a+L*t);return d[0]=i*T,d[1]=I*T,d[2]=s*T,d[3]=E*T,d[4]=me*T,d[5]=c*T,d[6]=y*T,d[7]=ee*T,d[8]=r*T,d[9]=b*T,d[10]=j*T,d[11]=de*T,d[12]=Z*T,d[13]=M*T,d[14]=J*T,d[15]=ve*T,!0}W._UpdateFlagSeed=0;const F=e=>parseInt(e.toString().replace(/\W/g,""));class w{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=e,this.y=d}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let e=F(this.x);return e=397*e^F(this.y),e}toArray(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e[d]=this.x,e[d+1]=this.y,this}Yv(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w.FromArrayToRef(e,d,this),this}Yd(){return[this.x,this.y]}L(e){return this.x=e.x,this.y=e.y,this}Ed(e,d){return this.x=e,this.y=d,this}set(e,d){return this.Ed(e,d)}dp(e){return this.Ed(e,e)}add(e){return new w(this.x+e.x,this.y+e.y)}addToRef(e,d){return d.x=this.x+e.x,d.y=this.y+e.y,d}addInPlace(e){return this.x+=e.x,this.y+=e.y,this}addInPlaceFromFloats(e,d){return this.x+=e,this.y+=d,this}addVector3(e){return new w(this.x+e.x,this.y+e.y)}Zd(e){return new w(this.x-e.x,this.y-e.y)}subtractToRef(e,d){return d.x=this.x-e.x,d.y=this.y-e.y,d}JV(e){return this.x-=e.x,this.y-=e.y,this}multiplyInPlace(e){return this.x*=e.x,this.y*=e.y,this}multiply(e){return new w(this.x*e.x,this.y*e.y)}multiplyToRef(e,d){return d.x=this.x*e.x,d.y=this.y*e.y,d}multiplyByFloats(e,d){return new w(this.x*e,this.y*d)}divide(e){return new w(this.x/e.x,this.y/e.y)}divideToRef(e,d){return d.x=this.x/e.x,d.y=this.y/e.y,d}divideInPlace(e){return this.x=this.x/e.x,this.y=this.y/e.y,this}minimizeInPlace(e){return this.minimizeInPlaceFromFloats(e.x,e.y)}maximizeInPlace(e){return this.maximizeInPlaceFromFloats(e.x,e.y)}minimizeInPlaceFromFloats(e,d){return this.x=Math.min(e,this.x),this.y=Math.min(d,this.y),this}maximizeInPlaceFromFloats(e,d){return this.x=Math.max(e,this.x),this.y=Math.max(d,this.y),this}subtractFromFloats(e,d){return new w(this.x-e,this.y-d)}subtractFromFloatsToRef(e,d,v){return v.x=this.x-e,v.y=this.y-d,v}negate(){return new w(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(e){return e.x=-this.x,e.y=-this.y,e}scaleInPlace(e){return this.x*=e,this.y*=e,this}scale(e){return new w(this.x*e,this.y*e)}scaleToRef(e,d){return d.x=this.x*e,d.y=this.y*e,d}scaleAndAddToRef(e,d){return d.x+=this.x*e,d.y+=this.y*e,d}equals(e){return e&&this.x===e.x&&this.y===e.y}equalsWithEpsilon(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:P.e;return e&&(0,z.WithinEpsilon)(this.x,e.x,d)&&(0,z.WithinEpsilon)(this.y,e.y,d)}equalsToFloats(e,d){return this.x===e&&this.y===d}floor(){return new w(Math.floor(this.x),Math.floor(this.y))}floorToRef(e){return e.x=Math.floor(this.x),e.y=Math.floor(this.y),e}fract(){return new w(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(e){return e.x=this.x-Math.floor(this.x),e.y=this.y-Math.floor(this.y),e}rotate(e){return this.rotateToRef(e,new w)}rotateToRef(e,d){const v=Math.cos(e),P=Math.sin(e);return d.x=v*this.x-P*this.y,d.y=P*this.x+v*this.y,d}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(e){return 0===e||1===e?this:this.scaleInPlace(1/e)}normalizeToNew(){const e=new w;return this.normalizeToRef(e),e}normalizeToRef(e){const d=this.length();return 0===d&&(e.x=this.x,e.y=this.y),this.scaleToRef(1/d,e)}clone(){return new w(this.x,this.y)}dot(e){return this.x*e.x+this.y*e.y}static Zero(){return new w(0,0)}static One(){return new w(1,1)}static Random(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new w((0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d))}static RandomToRef(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ed((0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d))}static get ZeroReadOnly(){return w._ZeroReadOnly}static Nd(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new w(e[d],e[d+1])}static FromArrayToRef(e,d,v){return v.x=e[d],v.y=e[d+1],v}static FromFloatsToRef(e,d,v){return v.Ed(e,d),v}static CatmullRom(e,d,v,P,p){const L=p*p,B=p*L,X=.5*(2*d.x+(-e.x+v.x)*p+(2*e.x-5*d.x+4*v.x-P.x)*L+(-e.x+3*d.x-3*v.x+P.x)*B),z=.5*(2*d.y+(-e.y+v.y)*p+(2*e.y-5*d.y+4*v.y-P.y)*L+(-e.y+3*d.y-3*v.y+P.y)*B);return new w(X,z)}static ClampToRef(e,d,v,P){return P.x=(0,z.Clamp)(e.x,d.x,v.x),P.y=(0,z.Clamp)(e.y,d.y,v.y),P}static Clamp(e,d,v){const P=(0,z.Clamp)(e.x,d.x,v.x),p=(0,z.Clamp)(e.y,d.y,v.y);return new w(P,p)}static Hermite(e,d,v,P,p){const L=p*p,B=p*L,X=2*B-3*L+1,z=-2*B+3*L,W=B-2*L+p,V=B-L,k=e.x*X+v.x*z+d.x*W+P.x*V,g=e.y*X+v.y*z+d.y*W+P.y*V;return new w(k,g)}static Hermite1stDerivative(e,d,v,P,p){return this.Hermite1stDerivativeToRef(e,d,v,P,p,new w)}static Hermite1stDerivativeToRef(e,d,v,P,p,L){const B=p*p;return L.x=6*(B-p)*e.x+(3*B-4*p+1)*d.x+6*(-B+p)*v.x+(3*B-2*p)*P.x,L.y=6*(B-p)*e.y+(3*B-4*p+1)*d.y+6*(-B+p)*v.y+(3*B-2*p)*P.y,L}static Lerp(e,d,v){return w.LerpToRef(e,d,v,new w)}static LerpToRef(e,d,v,P){return P.x=e.x+(d.x-e.x)*v,P.y=e.y+(d.y-e.y)*v,P}static Dot(e,d){return e.x*d.x+e.y*d.y}static Normalize(e){return w.NormalizeToRef(e,new w)}static NormalizeToRef(e,d){return e.normalizeToRef(d),d}static Minimize(e,d){const v=e.x<d.x?e.x:d.x,P=e.y<d.y?e.y:d.y;return new w(v,P)}static Maximize(e,d){const v=e.x>d.x?e.x:d.x,P=e.y>d.y?e.y:d.y;return new w(v,P)}static Transform(e,d){return w.TransformToRef(e,d,new w)}static TransformToRef(e,d,v){const P=d.m,p=e.x*P[0]+e.y*P[4]+P[12],L=e.x*P[1]+e.y*P[5]+P[13];return v.x=p,v.y=L,v}static PointInTriangle(e,d,v,P){const p=.5*(-v.y*P.x+d.y*(-v.x+P.x)+d.x*(v.y-P.y)+v.x*P.y),L=p<0?-1:1,B=(d.y*P.x-d.x*P.y+(P.y-d.y)*e.x+(d.x-P.x)*e.y)*L,X=(d.x*v.y-d.y*v.x+(d.y-v.y)*e.x+(v.x-d.x)*e.y)*L;return B>0&&X>0&&B+X<2*p*L}static Distance(e,d){return Math.sqrt(w.DistanceSquared(e,d))}static DistanceSquared(e,d){const v=e.x-d.x,P=e.y-d.y;return v*v+P*P}static Center(e,d){return w.CenterToRef(e,d,new w)}static CenterToRef(e,d,v){return v.Ed((e.x+d.x)/2,(e.y+d.y)/2)}static DistanceOfPointFromSegment(e,d,v){const P=w.DistanceSquared(d,v);if(0===P)return w.Distance(e,d);const p=v.Zd(d),L=Math.max(0,Math.min(1,w.Dot(e.Zd(d),p)/P)),B=d.add(p.multiplyByFloats(L,L));return w.Distance(e,B)}}w._V8PerformanceHack=new w(.5,.5),w._ZeroReadOnly=w.Zero(),Object.defineProperties(w.prototype,{dimension:{value:[2]},rank:{value:1}});class G{get x(){return this._x}set x(e){this._x=e,this._isDirty=!0}get y(){return this._y}set y(e){this._y=e,this._isDirty=!0}get z(){return this._z}set z(e){this._z=e,this._isDirty=!0}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=e,this._y=d,this._z=v}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"mv"}getHashCode(){let e=F(this._x);return e=397*e^F(this._y),e=397*e^F(this._z),e}Yd(){return[this._x,this._y,this._z]}toArray(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e[d]=this._x,e[d+1]=this._y,e[d+2]=this._z,this}Yv(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G.FromArrayToRef(e,d,this),this}toQuaternion(){return D.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(e){return this._x+=e._x,this._y+=e._y,this._z+=e._z,this._isDirty=!0,this}addInPlaceFromFloats(e,d,v){return this._x+=e,this._y+=d,this._z+=v,this._isDirty=!0,this}add(e){return new G(this._x+e._x,this._y+e._y,this._z+e._z)}addToRef(e,d){return d._x=this._x+e._x,d._y=this._y+e._y,d._z=this._z+e._z,d._isDirty=!0,d}JV(e){return this._x-=e._x,this._y-=e._y,this._z-=e._z,this._isDirty=!0,this}Zd(e){return new G(this._x-e._x,this._y-e._y,this._z-e._z)}subtractToRef(e,d){return this.subtractFromFloatsToRef(e._x,e._y,e._z,d)}subtractFromFloats(e,d,v){return new G(this._x-e,this._y-d,this._z-v)}subtractFromFloatsToRef(e,d,v,P){return P._x=this._x-e,P._y=this._y-d,P._z=this._z-v,P._isDirty=!0,P}negate(){return new G(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(e){return e._x=-1*this._x,e._y=-1*this._y,e._z=-1*this._z,e._isDirty=!0,e}scaleInPlace(e){return this._x*=e,this._y*=e,this._z*=e,this._isDirty=!0,this}scale(e){return new G(this._x*e,this._y*e,this._z*e)}scaleToRef(e,d){return d._x=this._x*e,d._y=this._y*e,d._z=this._z*e,d._isDirty=!0,d}getNormalToRef(e){const d=this.length();let v=Math.acos(this._y/d);const P=Math.atan2(this._z,this._x);v>Math.PI/2?v-=Math.PI/2:v+=Math.PI/2;const p=d*Math.sin(v)*Math.cos(P),L=d*Math.cos(v),B=d*Math.sin(v)*Math.sin(P);return e.set(p,L,B),e}applyRotationQuaternionToRef(e,d){const v=this._x,P=this._y,p=this._z,L=e._x,B=e._y,X=e._z,z=e._w,W=2*(B*p-X*P),V=2*(X*v-L*p),k=2*(L*P-B*v);return d._x=v+z*W+B*k-X*V,d._y=P+z*V+X*W-L*k,d._z=p+z*k+L*V-B*W,d._isDirty=!0,d}applyRotationQuaternionInPlace(e){return this.applyRotationQuaternionToRef(e,this)}applyRotationQuaternion(e){return this.applyRotationQuaternionToRef(e,new G)}scaleAndAddToRef(e,d){return d._x+=this._x*e,d._y+=this._y*e,d._z+=this._z*e,d._isDirty=!0,d}projectOnPlane(e,d){return this.projectOnPlaneToRef(e,d,new G)}projectOnPlaneToRef(e,d,v){const P=e.normal,p=e.d,L=q.mv[0];this.subtractToRef(d,L),L.normalize();const B=G.Dot(L,P);if(Math.abs(B)<1e-10)v.dp(1/0);else{const e=-(G.Dot(d,P)+p)/B,X=L.scaleInPlace(e);d.addToRef(X,v)}return v}equals(e){return e&&this._x===e._x&&this._y===e._y&&this._z===e._z}equalsWithEpsilon(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:P.e;return e&&(0,z.WithinEpsilon)(this._x,e._x,d)&&(0,z.WithinEpsilon)(this._y,e._y,d)&&(0,z.WithinEpsilon)(this._z,e._z,d)}equalsToFloats(e,d,v){return this._x===e&&this._y===d&&this._z===v}multiplyInPlace(e){return this._x*=e._x,this._y*=e._y,this._z*=e._z,this._isDirty=!0,this}multiply(e){return this.multiplyByFloats(e._x,e._y,e._z)}multiplyToRef(e,d){return d._x=this._x*e._x,d._y=this._y*e._y,d._z=this._z*e._z,d._isDirty=!0,d}multiplyByFloats(e,d,v){return new G(this._x*e,this._y*d,this._z*v)}divide(e){return new G(this._x/e._x,this._y/e._y,this._z/e._z)}divideToRef(e,d){return d._x=this._x/e._x,d._y=this._y/e._y,d._z=this._z/e._z,d._isDirty=!0,d}divideInPlace(e){return this._x=this._x/e._x,this._y=this._y/e._y,this._z=this._z/e._z,this._isDirty=!0,this}minimizeInPlace(e){return this.minimizeInPlaceFromFloats(e._x,e._y,e._z)}maximizeInPlace(e){return this.maximizeInPlaceFromFloats(e._x,e._y,e._z)}minimizeInPlaceFromFloats(e,d,v){return e<this._x&&(this.x=e),d<this._y&&(this.y=d),v<this._z&&(this.z=v),this}maximizeInPlaceFromFloats(e,d,v){return e>this._x&&(this.x=e),d>this._y&&(this.y=d),v>this._z&&(this.z=v),this}isNonUniformWithinEpsilon(e){const d=Math.abs(this._x),v=Math.abs(this._y);if(!(0,z.WithinEpsilon)(d,v,e))return!0;const P=Math.abs(this._z);return!(0,z.WithinEpsilon)(d,P,e)||!(0,z.WithinEpsilon)(v,P,e)}get isNonUniform(){const e=Math.abs(this._x);if(e!==Math.abs(this._y))return!0;return e!==Math.abs(this._z)}floorToRef(e){return e._x=Math.floor(this._x),e._y=Math.floor(this._y),e._z=Math.floor(this._z),e._isDirty=!0,e}floor(){return new G(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(e){return e._x=this._x-Math.floor(this._x),e._y=this._y-Math.floor(this._y),e._z=this._z-Math.floor(this._z),e._isDirty=!0,e}fract(){return new G(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(e){if("xyz"===(e=e.toLowerCase()))return this;const d=q.mv[0].L(this);return this.x=d[e[0]],this.y=d[e[1]],this.z=d[e[2]],this}rotateByQuaternionToRef(e,d){return e.toRotationMatrix(q.Matrix[0]),G.TransformCoordinatesToRef(this,q.Matrix[0],d),d}rotateByQuaternionAroundPointToRef(e,d,v){return this.subtractToRef(d,q.mv[0]),q.mv[0].rotateByQuaternionToRef(e,q.mv[0]),d.addToRef(q.mv[0],v),v}cross(e){return G.CrossToRef(this,e,new G)}normalizeFromLength(e){return 0===e||1===e?this:this.scaleInPlace(1/e)}normalizeToNew(){return this.normalizeToRef(new G)}normalizeToRef(e){const d=this.length();return 0===d||1===d?(e._x=this._x,e._y=this._y,e._z=this._z,e._isDirty=!0,e):this.scaleToRef(1/d,e)}clone(){return new G(this._x,this._y,this._z)}L(e){return this.Ed(e._x,e._y,e._z)}Ed(e,d,v){return this._x=e,this._y=d,this._z=v,this._isDirty=!0,this}set(e,d,v){return this.Ed(e,d,v)}dp(e){return this._x=this._y=this._z=e,this._isDirty=!0,this}static GetClipFactor(e,d,v,P){const p=G.Dot(e,v);return(p-P)/(p-G.Dot(d,v))}static GetAngleBetweenVectors(e,d,v){const P=e.normalizeToRef(q.mv[1]),p=d.normalizeToRef(q.mv[2]);let L=G.Dot(P,p);L=(0,z.Clamp)(L,-1,1);const B=Math.acos(L),X=q.mv[3];return G.CrossToRef(P,p,X),G.Dot(X,v)>0?isNaN(B)?0:B:isNaN(B)?-Math.PI:-Math.acos(L)}static GetAngleBetweenVectorsOnPlane(e,d,v){q.mv[0].L(e);const P=q.mv[0];q.mv[1].L(d);const p=q.mv[1];q.mv[2].L(v);const L=q.mv[2],B=q.mv[3],X=q.mv[4];P.normalize(),p.normalize(),L.normalize(),G.CrossToRef(L,P,B),G.CrossToRef(B,L,X);const W=Math.atan2(G.Dot(p,B),G.Dot(p,X));return(0,z.NormalizeRadians)(W)}static PitchYawRollToMoveBetweenPointsToRef(e,d,v){const P=h.mv[0];return d.subtractToRef(e,P),v._y=Math.atan2(P.x,P.z)||0,v._x=Math.atan2(Math.sqrt(P.x**2+P.z**2),P.y)||0,v._z=0,v._isDirty=!0,v}static PitchYawRollToMoveBetweenPoints(e,d){const v=G.Zero();return G.PitchYawRollToMoveBetweenPointsToRef(e,d,v)}static SlerpToRef(e,d,v,p){v=(0,z.Clamp)(v,0,1);const L=q.mv[0],B=q.mv[1];L.L(e);const X=L.length();L.normalizeFromLength(X),B.L(d);const W=B.length();B.normalizeFromLength(W);const V=G.Dot(L,B);let k,g;if(V<1-P.e){const e=Math.acos(V),d=1/Math.sin(e);k=Math.sin((1-v)*e)*d,g=Math.sin(v*e)*d}else k=1-v,g=v;return L.scaleInPlace(k),B.scaleInPlace(g),p.L(L).addInPlace(B),p.scaleInPlace((0,z.Lerp)(X,W,v)),p}static SmoothToRef(e,d,v,P,p){return G.SlerpToRef(e,d,0===P?1:v/P,p),p}static Nd(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new G(e[d],e[d+1],e[d+2])}static FromFloatArray(e,d){return G.Nd(e,d)}static FromArrayToRef(e,d,v){return v._x=e[d],v._y=e[d+1],v._z=e[d+2],v._isDirty=!0,v}static FromFloatArrayToRef(e,d,v){return G.FromArrayToRef(e,d,v)}static FromFloatsToRef(e,d,v,P){return P.Ed(e,d,v),P}static Zero(){return new G(0,0,0)}static One(){return new G(1,1,1)}static Up(){return new G(0,1,0)}static get UpReadOnly(){return G._UpReadOnly}static get DownReadOnly(){return G._DownReadOnly}static get RightReadOnly(){return G._RightReadOnly}static get LeftReadOnly(){return G._LeftReadOnly}static get LeftHandedForwardReadOnly(){return G._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return G._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return G._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return G._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return G._ZeroReadOnly}static get OneReadOnly(){return G._OneReadOnly}static Down(){return new G(0,-1,0)}static Forward(){return new G(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new G(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new G(1,0,0)}static Left(){return new G(-1,0,0)}static Random(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new G((0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d))}static RandomToRef(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ed((0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d))}static TransformCoordinates(e,d){const v=G.Zero();return G.TransformCoordinatesToRef(e,d,v),v}static TransformCoordinatesToRef(e,d,v){return G.TransformCoordinatesFromFloatsToRef(e._x,e._y,e._z,d,v),v}static TransformCoordinatesFromFloatsToRef(e,d,v,P,p){const L=P.m,B=e*L[0]+d*L[4]+v*L[8]+L[12],X=e*L[1]+d*L[5]+v*L[9]+L[13],z=e*L[2]+d*L[6]+v*L[10]+L[14],W=1/(e*L[3]+d*L[7]+v*L[11]+L[15]);return p._x=B*W,p._y=X*W,p._z=z*W,p._isDirty=!0,p}static TransformNormal(e,d){const v=G.Zero();return G.TransformNormalToRef(e,d,v),v}static TransformNormalToRef(e,d,v){return this.TransformNormalFromFloatsToRef(e._x,e._y,e._z,d,v),v}static TransformNormalFromFloatsToRef(e,d,v,P,p){const L=P.m;return p._x=e*L[0]+d*L[4]+v*L[8],p._y=e*L[1]+d*L[5]+v*L[9],p._z=e*L[2]+d*L[6]+v*L[10],p._isDirty=!0,p}static CatmullRom(e,d,v,P,p){const L=p*p,B=p*L,X=.5*(2*d._x+(-e._x+v._x)*p+(2*e._x-5*d._x+4*v._x-P._x)*L+(-e._x+3*d._x-3*v._x+P._x)*B),z=.5*(2*d._y+(-e._y+v._y)*p+(2*e._y-5*d._y+4*v._y-P._y)*L+(-e._y+3*d._y-3*v._y+P._y)*B),W=.5*(2*d._z+(-e._z+v._z)*p+(2*e._z-5*d._z+4*v._z-P._z)*L+(-e._z+3*d._z-3*v._z+P._z)*B);return new G(X,z,W)}static Clamp(e,d,v){const P=new G;return G.ClampToRef(e,d,v,P),P}static ClampToRef(e,d,v,P){let p=e._x;p=p>v._x?v._x:p,p=p<d._x?d._x:p;let L=e._y;L=L>v._y?v._y:L,L=L<d._y?d._y:L;let B=e._z;return B=B>v._z?v._z:B,B=B<d._z?d._z:B,P.Ed(p,L,B),P}static CheckExtends(e,d,v){d.minimizeInPlace(e),v.maximizeInPlace(e)}static Hermite(e,d,v,P,p){const L=p*p,B=p*L,X=2*B-3*L+1,z=-2*B+3*L,W=B-2*L+p,V=B-L,k=e._x*X+v._x*z+d._x*W+P._x*V,g=e._y*X+v._y*z+d._y*W+P._y*V,F=e._z*X+v._z*z+d._z*W+P._z*V;return new G(k,g,F)}static Hermite1stDerivative(e,d,v,P,p){const L=new G;return this.Hermite1stDerivativeToRef(e,d,v,P,p,L),L}static Hermite1stDerivativeToRef(e,d,v,P,p,L){const B=p*p;return L._x=6*(B-p)*e._x+(3*B-4*p+1)*d._x+6*(-B+p)*v._x+(3*B-2*p)*P._x,L._y=6*(B-p)*e._y+(3*B-4*p+1)*d._y+6*(-B+p)*v._y+(3*B-2*p)*P._y,L._z=6*(B-p)*e._z+(3*B-4*p+1)*d._z+6*(-B+p)*v._z+(3*B-2*p)*P._z,L._isDirty=!0,L}static Lerp(e,d,v){const P=new G(0,0,0);return G.LerpToRef(e,d,v,P),P}static LerpToRef(e,d,v,P){return P._x=e._x+(d._x-e._x)*v,P._y=e._y+(d._y-e._y)*v,P._z=e._z+(d._z-e._z)*v,P._isDirty=!0,P}static Dot(e,d){return e._x*d._x+e._y*d._y+e._z*d._z}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z}static Cross(e,d){const v=new G;return G.CrossToRef(e,d,v),v}static CrossToRef(e,d,v){const P=e._y*d._z-e._z*d._y,p=e._z*d._x-e._x*d._z,L=e._x*d._y-e._y*d._x;return v.Ed(P,p,L),v}static Normalize(e){const d=G.Zero();return G.NormalizeToRef(e,d),d}static NormalizeToRef(e,d){return e.normalizeToRef(d),d}static Project(e,d,v,P){const p=new G;return G.ProjectToRef(e,d,v,P,p),p}static ProjectToRef(e,d,v,P,p){var L;const B=P.width,z=P.height,W=P.x,V=P.y,k=q.Matrix[1],g=null===(L=X.c.LastCreatedEngine)||void 0===L?void 0:L.isNDCHalfZRange,F=g?1:.5,w=g?0:.5;C.FromValuesToRef(B/2,0,0,0,0,-z/2,0,0,0,0,F,0,W+B/2,z/2+V,w,1,k);const U=q.Matrix[0];return d.multiplyToRef(v,U),U.multiplyToRef(k,U),G.TransformCoordinatesToRef(e,U,p),p}static Reflect(e,d){return this.ReflectToRef(e,d,new G)}static ReflectToRef(e,d,v){const P=h.mv[0];return P.L(d).scaleInPlace(2*G.Dot(e,d)),v.L(e).JV(P)}static _UnprojectFromInvertedMatrixToRef(e,d,v){G.TransformCoordinatesToRef(e,d,v);const P=d.m,p=e._x*P[3]+e._y*P[7]+e._z*P[11]+P[15];return(0,z.WithinEpsilon)(p,1)&&v.scaleInPlace(1/p),v}static UnprojectFromTransform(e,d,v,P,p){return this.Unproject(e,d,v,P,p,C.IdentityReadOnly)}static Unproject(e,d,v,P,p,L){const B=new G;return G.UnprojectToRef(e,d,v,P,p,L,B),B}static UnprojectToRef(e,d,v,P,p,L,B){return G.UnprojectFloatsToRef(e._x,e._y,e._z,d,v,P,p,L,B),B}static UnprojectFloatsToRef(e,d,v,P,p,L,B,z,W){var V;const k=q.Matrix[0];L.multiplyToRef(B,k),k.multiplyToRef(z,k),k.invert();const g=q.mv[0];return g.x=e/P*2-1,g.y=-(d/p*2-1),null!==(V=X.c.LastCreatedEngine)&&void 0!==V&&V.isNDCHalfZRange?g.z=v:g.z=2*v-1,G._UnprojectFromInvertedMatrixToRef(g,k,W),W}static Minimize(e,d){const v=new G;return v.L(e),v.minimizeInPlace(d),v}static Maximize(e,d){const v=new G;return v.L(e),v.maximizeInPlace(d),v}static Distance(e,d){return Math.sqrt(G.DistanceSquared(e,d))}static DistanceSquared(e,d){const v=e._x-d._x,P=e._y-d._y,p=e._z-d._z;return v*v+P*P+p*p}static ProjectOnTriangleToRef(e,d,v,p,L){const B=q.mv[0],X=q.mv[1],W=q.mv[2],V=q.mv[3],k=q.mv[4];v.subtractToRef(d,B),p.subtractToRef(d,X),p.subtractToRef(v,W);const g=B.length(),F=X.length(),w=W.length();if(g<P.e||F<P.e||w<P.e)return L.L(d),G.Distance(e,d);e.subtractToRef(d,k),G.CrossToRef(B,X,V);const U=V.length();if(U<P.e)return L.L(d),G.Distance(e,d);V.normalizeFromLength(U);let D=k.length();if(D<P.e)return L.L(d),0;k.normalizeFromLength(D);const C=G.Dot(V,k),h=q.mv[5],l=q.mv[6];h.L(V).scaleInPlace(-D*C),l.L(e).addInPlace(h);const n=q.mv[4],A=q.mv[5],x=q.mv[7],i=q.mv[8];n.L(B).scaleInPlace(1/g),i.L(X).scaleInPlace(1/F),n.addInPlace(i).scaleInPlace(-1),A.L(B).scaleInPlace(-1/g),i.L(W).scaleInPlace(1/w),A.addInPlace(i).scaleInPlace(-1),x.L(W).scaleInPlace(-1/w),i.L(X).scaleInPlace(-1/F),x.addInPlace(i).scaleInPlace(-1);const me=q.mv[9];let r;me.L(l).JV(d),G.CrossToRef(n,me,i),r=G.Dot(i,V);const Z=r;me.L(l).JV(v),G.CrossToRef(A,me,i),r=G.Dot(i,V);const f=r;me.L(l).JV(p),G.CrossToRef(x,me,i),r=G.Dot(i,V);const T=r,S=q.mv[10];let o,K;Z>0&&f<0?(S.L(B),o=d,K=v):f>0&&T<0?(S.L(W),o=v,K=p):(S.L(X).scaleInPlace(-1),o=p,K=d);const Q=q.mv[9],N=q.mv[4];o.subtractToRef(l,i),K.subtractToRef(l,Q),G.CrossToRef(i,Q,N);if(!(G.Dot(N,V)<0))return L.L(l),Math.abs(D*C);const u=q.mv[5];G.CrossToRef(S,N,u),u.normalize();const O=q.mv[9];O.L(o).JV(l);const R=O.length();if(R<P.e)return L.L(o),G.Distance(e,o);O.normalizeFromLength(R);const Y=G.Dot(u,O),H=q.mv[7];H.L(l).addInPlace(u.scaleInPlace(R*Y)),i.L(H).JV(o),D=S.length(),S.normalizeFromLength(D);let a=G.Dot(i,S)/Math.max(D,P.e);return a=(0,z.Clamp)(a,0,1),H.L(o).addInPlace(S.scaleInPlace(a*D)),L.L(H),G.Distance(e,H)}static Center(e,d){return G.CenterToRef(e,d,G.Zero())}static CenterToRef(e,d,v){return v.Ed((e._x+d._x)/2,(e._y+d._y)/2,(e._z+d._z)/2)}static RotationFromAxis(e,d,v){const P=new G;return G.RotationFromAxisToRef(e,d,v,P),P}static RotationFromAxisToRef(e,d,v,P){const p=q.Quaternion[0];return D.RotationQuaternionFromAxisToRef(e,d,v,p),p.toEulerAnglesToRef(P),P}}G._V8PerformanceHack=new G(.5,.5,.5),G._UpReadOnly=G.Up(),G._DownReadOnly=G.Down(),G._LeftHandedForwardReadOnly=G.Forward(!1),G._RightHandedForwardReadOnly=G.Forward(!0),G._LeftHandedBackwardReadOnly=G.Backward(!1),G._RightHandedBackwardReadOnly=G.Backward(!0),G._RightReadOnly=G.Right(),G._LeftReadOnly=G.Left(),G._ZeroReadOnly=G.Zero(),G._OneReadOnly=G.One(),Object.defineProperties(G.prototype,{dimension:{value:[3]},rank:{value:1}});class U{get x(){return this._x}set x(e){this._x=e,this._isDirty=!0}get y(){return this._y}set y(e){this._y=e,this._isDirty=!0}get z(){return this._z}set z(e){this._z=e,this._isDirty=!0}get w(){return this._w}set w(e){this._w=e,this._isDirty=!0}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=e,this._y=d,this._z=v,this._w=P}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let e=F(this._x);return e=397*e^F(this._y),e=397*e^F(this._z),e=397*e^F(this._w),e}Yd(){return[this._x,this._y,this._z,this._w]}toArray(e,d){return void 0===d&&(d=0),e[d]=this._x,e[d+1]=this._y,e[d+2]=this._z,e[d+3]=this._w,this}Yv(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U.FromArrayToRef(e,d,this),this}addInPlace(e){return this.x+=e._x,this.y+=e._y,this.z+=e._z,this.w+=e._w,this}addInPlaceFromFloats(e,d,v,P){return this.x+=e,this.y+=d,this.z+=v,this.w+=P,this}add(e){return new U(this._x+e.x,this._y+e.y,this._z+e.z,this._w+e.w)}addToRef(e,d){return d.x=this._x+e.x,d.y=this._y+e.y,d.z=this._z+e.z,d.w=this._w+e.w,d}JV(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}Zd(e){return new U(this._x-e.x,this._y-e.y,this._z-e.z,this._w-e.w)}subtractToRef(e,d){return d.x=this._x-e.x,d.y=this._y-e.y,d.z=this._z-e.z,d.w=this._w-e.w,d}subtractFromFloats(e,d,v,P){return new U(this._x-e,this._y-d,this._z-v,this._w-P)}subtractFromFloatsToRef(e,d,v,P,p){return p.x=this._x-e,p.y=this._y-d,p.z=this._z-v,p.w=this._w-P,p}negate(){return new U(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(e){return e.x=-this._x,e.y=-this._y,e.z=-this._z,e.w=-this._w,e}scaleInPlace(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}scale(e){return new U(this._x*e,this._y*e,this._z*e,this._w*e)}scaleToRef(e,d){return d.x=this._x*e,d.y=this._y*e,d.z=this._z*e,d.w=this._w*e,d}scaleAndAddToRef(e,d){return d.x+=this._x*e,d.y+=this._y*e,d.z+=this._z*e,d.w+=this._w*e,d}equals(e){return e&&this._x===e.x&&this._y===e.y&&this._z===e.z&&this._w===e.w}equalsWithEpsilon(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:P.e;return e&&(0,z.WithinEpsilon)(this._x,e.x,d)&&(0,z.WithinEpsilon)(this._y,e.y,d)&&(0,z.WithinEpsilon)(this._z,e.z,d)&&(0,z.WithinEpsilon)(this._w,e.w,d)}equalsToFloats(e,d,v,P){return this._x===e&&this._y===d&&this._z===v&&this._w===P}multiplyInPlace(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiply(e){return new U(this._x*e.x,this._y*e.y,this._z*e.z,this._w*e.w)}multiplyToRef(e,d){return d.x=this._x*e.x,d.y=this._y*e.y,d.z=this._z*e.z,d.w=this._w*e.w,d}multiplyByFloats(e,d,v,P){return new U(this._x*e,this._y*d,this._z*v,this._w*P)}divide(e){return new U(this._x/e.x,this._y/e.y,this._z/e.z,this._w/e.w)}divideToRef(e,d){return d.x=this._x/e.x,d.y=this._y/e.y,d.z=this._z/e.z,d.w=this._w/e.w,d}divideInPlace(e){return this.divideToRef(e,this)}minimizeInPlace(e){return e.x<this._x&&(this.x=e.x),e.y<this._y&&(this.y=e.y),e.z<this._z&&(this.z=e.z),e.w<this._w&&(this.w=e.w),this}maximizeInPlace(e){return e.x>this._x&&(this.x=e.x),e.y>this._y&&(this.y=e.y),e.z>this._z&&(this.z=e.z),e.w>this._w&&(this.w=e.w),this}minimizeInPlaceFromFloats(e,d,v,P){return this.x=Math.min(e,this._x),this.y=Math.min(d,this._y),this.z=Math.min(v,this._z),this.w=Math.min(P,this._w),this}maximizeInPlaceFromFloats(e,d,v,P){return this.x=Math.max(e,this._x),this.y=Math.max(d,this._y),this.z=Math.max(v,this._z),this.w=Math.max(P,this._w),this}floorToRef(e){return e.x=Math.floor(this._x),e.y=Math.floor(this._y),e.z=Math.floor(this._z),e.w=Math.floor(this._w),e}floor(){return new U(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(e){return e.x=this._x-Math.floor(this._x),e.y=this._y-Math.floor(this._y),e.z=this._z-Math.floor(this._z),e.w=this._w-Math.floor(this._w),e}fract(){return new U(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(e){return 0===e||1===e?this:this.scaleInPlace(1/e)}normalizeToNew(){return this.normalizeToRef(new U)}normalizeToRef(e){const d=this.length();return 0===d||1===d?(e.x=this._x,e.y=this._y,e.z=this._z,e.w=this._w,e):this.scaleToRef(1/d,e)}toVector3(){return new G(this._x,this._y,this._z)}clone(){return new U(this._x,this._y,this._z,this._w)}L(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}Ed(e,d,v,P){return this.x=e,this.y=d,this.z=v,this.w=P,this}set(e,d,v,P){return this.Ed(e,d,v,P)}dp(e){return this.x=this.y=this.z=this.w=e,this}dot(e){return this._x*e.x+this._y*e.y+this._z*e.z+this._w*e.w}static Nd(e,d){return d||(d=0),new U(e[d],e[d+1],e[d+2],e[d+3])}static FromArrayToRef(e,d,v){return v.x=e[d],v.y=e[d+1],v.z=e[d+2],v.w=e[d+3],v}static FromFloatArrayToRef(e,d,v){return U.FromArrayToRef(e,d,v),v}static FromFloatsToRef(e,d,v,P,p){return p.x=e,p.y=d,p.z=v,p.w=P,p}static Zero(){return new U(0,0,0,0)}static One(){return new U(1,1,1,1)}static Random(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new U((0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d))}static RandomToRef(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,v=arguments.length>2?arguments[2]:void 0;return v.x=(0,z.RandomRange)(e,d),v.y=(0,z.RandomRange)(e,d),v.z=(0,z.RandomRange)(e,d),v.w=(0,z.RandomRange)(e,d),v}static Clamp(e,d,v){return U.ClampToRef(e,d,v,new U)}static ClampToRef(e,d,v,P){return P.x=(0,z.Clamp)(e.x,d.x,v.x),P.y=(0,z.Clamp)(e.y,d.y,v.y),P.z=(0,z.Clamp)(e.z,d.z,v.z),P.w=(0,z.Clamp)(e.w,d.w,v.w),P}static CheckExtends(e,d,v){d.minimizeInPlace(e),v.maximizeInPlace(e)}static get ZeroReadOnly(){return U._ZeroReadOnly}static Normalize(e){return U.NormalizeToRef(e,new U)}static NormalizeToRef(e,d){return e.normalizeToRef(d),d}static Minimize(e,d){const v=new U;return v.L(e),v.minimizeInPlace(d),v}static Maximize(e,d){const v=new U;return v.L(e),v.maximizeInPlace(d),v}static Distance(e,d){return Math.sqrt(U.DistanceSquared(e,d))}static DistanceSquared(e,d){const v=e.x-d.x,P=e.y-d.y,p=e.z-d.z,L=e.w-d.w;return v*v+P*P+p*p+L*L}static Center(e,d){return U.CenterToRef(e,d,new U)}static CenterToRef(e,d,v){return v.x=(e.x+d.x)/2,v.y=(e.y+d.y)/2,v.z=(e.z+d.z)/2,v.w=(e.w+d.w)/2,v}static TransformCoordinates(e,d){return U.TransformCoordinatesToRef(e,d,new U)}static TransformCoordinatesToRef(e,d,v){return U.TransformCoordinatesFromFloatsToRef(e._x,e._y,e._z,d,v),v}static TransformCoordinatesFromFloatsToRef(e,d,v,P,p){const L=P.m,B=e*L[0]+d*L[4]+v*L[8]+L[12],X=e*L[1]+d*L[5]+v*L[9]+L[13],z=e*L[2]+d*L[6]+v*L[10]+L[14],W=e*L[3]+d*L[7]+v*L[11]+L[15];return p.x=B,p.y=X,p.z=z,p.w=W,p}static TransformNormal(e,d){return U.TransformNormalToRef(e,d,new U)}static TransformNormalToRef(e,d,v){const P=d.m,p=e.x*P[0]+e.y*P[4]+e.z*P[8],L=e.x*P[1]+e.y*P[5]+e.z*P[9],B=e.x*P[2]+e.y*P[6]+e.z*P[10];return v.x=p,v.y=L,v.z=B,v.w=e.w,v}static TransformNormalFromFloatsToRef(e,d,v,P,p,L){const B=p.m;return L.x=e*B[0]+d*B[4]+v*B[8],L.y=e*B[1]+d*B[5]+v*B[9],L.z=e*B[2]+d*B[6]+v*B[10],L.w=P,L}static FromVector3(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new U(e._x,e._y,e._z,d)}static Dot(e,d){return e.x*d.x+e.y*d.y+e.z*d.z+e.w*d.w}}U._V8PerformanceHack=new U(.5,.5,.5,.5),U._ZeroReadOnly=U.Zero(),Object.defineProperties(U.prototype,{dimension:{value:[4]},rank:{value:1}});class D{get x(){return this._x}set x(e){this._x=e,this._isDirty=!0}get y(){return this._y}set y(e){this._y=e,this._isDirty=!0}get z(){return this._z}set z(e){this._z=e,this._isDirty=!0}get w(){return this._w}set w(e){this._w=e,this._isDirty=!0}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=e,this._y=d,this._z=v,this._w=P}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let e=F(this._x);return e=397*e^F(this._y),e=397*e^F(this._z),e=397*e^F(this._w),e}Yd(){return[this._x,this._y,this._z,this._w]}toArray(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e[d]=this._x,e[d+1]=this._y,e[d+2]=this._z,e[d+3]=this._w,this}Yv(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D.FromArrayToRef(e,d,this)}equals(e){return e&&this._x===e._x&&this._y===e._y&&this._z===e._z&&this._w===e._w}equalsWithEpsilon(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:P.e;return e&&(0,z.WithinEpsilon)(this._x,e._x,d)&&(0,z.WithinEpsilon)(this._y,e._y,d)&&(0,z.WithinEpsilon)(this._z,e._z,d)&&(0,z.WithinEpsilon)(this._w,e._w,d)}isApprox(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:P.e;return e&&((0,z.WithinEpsilon)(this._x,e._x,d)&&(0,z.WithinEpsilon)(this._y,e._y,d)&&(0,z.WithinEpsilon)(this._z,e._z,d)&&(0,z.WithinEpsilon)(this._w,e._w,d)||(0,z.WithinEpsilon)(this._x,-e._x,d)&&(0,z.WithinEpsilon)(this._y,-e._y,d)&&(0,z.WithinEpsilon)(this._z,-e._z,d)&&(0,z.WithinEpsilon)(this._w,-e._w,d))}clone(){return new D(this._x,this._y,this._z,this._w)}L(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._w=e._w,this._isDirty=!0,this}Ed(e,d,v,P){return this._x=e,this._y=d,this._z=v,this._w=P,this._isDirty=!0,this}set(e,d,v,P){return this.Ed(e,d,v,P)}dp(e){return this.Ed(e,e,e,e)}add(e){return new D(this._x+e._x,this._y+e._y,this._z+e._z,this._w+e._w)}addInPlace(e){return this._x+=e._x,this._y+=e._y,this._z+=e._z,this._w+=e._w,this._isDirty=!0,this}addToRef(e,d){return d._x=this._x+e._x,d._y=this._y+e._y,d._z=this._z+e._z,d._w=this._w+e._w,d._isDirty=!0,d}addInPlaceFromFloats(e,d,v,P){return this._x+=e,this._y+=d,this._z+=v,this._w+=P,this._isDirty=!0,this}subtractToRef(e,d){return d._x=this._x-e._x,d._y=this._y-e._y,d._z=this._z-e._z,d._w=this._w-e._w,d._isDirty=!0,d}subtractFromFloats(e,d,v,P){return this.subtractFromFloatsToRef(e,d,v,P,new D)}subtractFromFloatsToRef(e,d,v,P,p){return p._x=this._x-e,p._y=this._y-d,p._z=this._z-v,p._w=this._w-P,p._isDirty=!0,p}Zd(e){return new D(this._x-e._x,this._y-e._y,this._z-e._z,this._w-e._w)}JV(e){return this._x-=e._x,this._y-=e._y,this._z-=e._z,this._w-=e._w,this._isDirty=!0,this}scale(e){return new D(this._x*e,this._y*e,this._z*e,this._w*e)}scaleToRef(e,d){return d._x=this._x*e,d._y=this._y*e,d._z=this._z*e,d._w=this._w*e,d._isDirty=!0,d}scaleInPlace(e){return this._x*=e,this._y*=e,this._z*=e,this._w*=e,this._isDirty=!0,this}scaleAndAddToRef(e,d){return d._x+=this._x*e,d._y+=this._y*e,d._z+=this._z*e,d._w+=this._w*e,d._isDirty=!0,d}multiply(e){const d=new D(0,0,0,1);return this.multiplyToRef(e,d),d}multiplyToRef(e,d){const v=this._x*e._w+this._y*e._z-this._z*e._y+this._w*e._x,P=-this._x*e._z+this._y*e._w+this._z*e._x+this._w*e._y,p=this._x*e._y-this._y*e._x+this._z*e._w+this._w*e._z,L=-this._x*e._x-this._y*e._y-this._z*e._z+this._w*e._w;return d.Ed(v,P,p,L),d}multiplyInPlace(e){return this.multiplyToRef(e,this)}multiplyByFloats(e,d,v,P){return this._x*=e,this._y*=d,this._z*=v,this._w*=P,this._isDirty=!0,this}divide(e){throw new ReferenceError("Can not divide a quaternion")}divideToRef(e,d){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(e){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new D)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(e){return e._x=-this._x,e._y=-this._y,e._z=-this._z,e._w=-this._w,e._isDirty=!0,e}equalsToFloats(e,d,v,P){return this._x===e&&this._y===d&&this._z===v&&this._w===P}floorToRef(e){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(e){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(e){return e.Ed(-this._x,-this._y,-this._z,this._w),e}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new D(-this._x,-this._y,-this._z,this._w)}invert(){const e=this.conjugate(),d=this.lengthSquared();return 0==d||1==d||e.scaleInPlace(1/d),e}invertInPlace(){this.conjugateInPlace();const e=this.lengthSquared();return 0==e||1==e||this.scaleInPlace(1/e),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(e){return 0===e||1===e?this:this.scaleInPlace(1/e)}normalizeToNew(){const e=new D(0,0,0,1);return this.normalizeToRef(e),e}normalizeToRef(e){const d=this.length();return 0===d||1===d?e.Ed(this._x,this._y,this._z,this._w):this.scaleToRef(1/d,e)}toEulerAngles(){const e=G.Zero();return this.toEulerAnglesToRef(e),e}toEulerAnglesToRef(e){const d=this._z,v=this._x,P=this._y,p=this._w,L=P*d-v*p,B=.4999999;if(L<-B)e._y=2*Math.atan2(P,p),e._x=Math.PI/2,e._z=0,e._isDirty=!0;else if(L>B)e._y=2*Math.atan2(P,p),e._x=-Math.PI/2,e._z=0,e._isDirty=!0;else{const B=p*p,X=d*d,z=v*v,W=P*P;e._z=Math.atan2(2*(v*P+d*p),-X-z+W+B),e._x=Math.asin(-2*L),e._y=Math.atan2(2*(d*v+P*p),X-z-W+B),e._isDirty=!0}return e}toAlphaBetaGammaToRef(e){const d=this._z,v=this._x,P=this._y,p=this._w,L=Math.sqrt(v*v+P*P),B=Math.sqrt(d*d+p*p),X=2*Math.atan2(L,B),z=2*Math.atan2(d,p),W=2*Math.atan2(P,v),V=(z+W)/2,k=(z-W)/2;return e.set(k,X,V),e}toRotationMatrix(e){return C.FromQuaternionToRef(this,e),e}fromRotationMatrix(e){return D.FromRotationMatrixToRef(e,this),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}toAxisAngle(){const e=G.Zero();return{axis:e,angle:this.toAxisAngleToRef(e)}}toAxisAngleToRef(e){let d=0;const v=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),P=this._w;return v>0?(d=2*Math.atan2(v,P),e.set(this._x/v,this._y/v,this._z/v)):(d=0,e.set(1,0,0)),d}static FromRotationMatrix(e){const d=new D;return D.FromRotationMatrixToRef(e,d),d}static FromRotationMatrixToRef(e,d){const v=e.m,P=v[0],p=v[4],L=v[8],B=v[1],X=v[5],z=v[9],W=v[2],V=v[6],k=v[10],g=P+X+k;let F;return g>0?(F=.5/Math.sqrt(g+1),d._w=.25/F,d._x=(V-z)*F,d._y=(L-W)*F,d._z=(B-p)*F,d._isDirty=!0):P>X&&P>k?(F=2*Math.sqrt(1+P-X-k),d._w=(V-z)/F,d._x=.25*F,d._y=(p+B)/F,d._z=(L+W)/F,d._isDirty=!0):X>k?(F=2*Math.sqrt(1+X-P-k),d._w=(L-W)/F,d._x=(p+B)/F,d._y=.25*F,d._z=(z+V)/F,d._isDirty=!0):(F=2*Math.sqrt(1+k-P-X),d._w=(B-p)/F,d._x=(L+W)/F,d._y=(z+V)/F,d._z=.25*F,d._isDirty=!0),d}static Dot(e,d){return e._x*d._x+e._y*d._y+e._z*d._z+e._w*d._w}static AreClose(e,d){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const P=D.Dot(e,d);return 1-P*P<=v}static SmoothToRef(e,d,v,P,p){let L=0===P?1:v/P;return L=(0,z.Clamp)(L,0,1),D.SlerpToRef(e,d,L,p),p}static Zero(){return new D(0,0,0,0)}static Inverse(e){return new D(-e._x,-e._y,-e._z,e._w)}static InverseToRef(e,d){return d.set(-e._x,-e._y,-e._z,e._w),d}static Identity(){return new D(0,0,0,1)}static IsIdentity(e){return e&&0===e._x&&0===e._y&&0===e._z&&1===e._w}static RotationAxis(e,d){return D.RotationAxisToRef(e,d,new D)}static RotationAxisToRef(e,d,v){v._w=Math.cos(d/2);const P=Math.sin(d/2)/e.length();return v._x=e._x*P,v._y=e._y*P,v._z=e._z*P,v._isDirty=!0,v}static Nd(e,d){return d||(d=0),new D(e[d],e[d+1],e[d+2],e[d+3])}static FromArrayToRef(e,d,v){return v._x=e[d],v._y=e[d+1],v._z=e[d+2],v._w=e[d+3],v._isDirty=!0,v}static FromFloatsToRef(e,d,v,P,p){return p.Ed(e,d,v,P),p}static FromEulerAngles(e,d,v){const P=new D;return D.RotationYawPitchRollToRef(d,e,v,P),P}static FromEulerAnglesToRef(e,d,v,P){return D.RotationYawPitchRollToRef(d,e,v,P),P}static FromEulerVector(e){const d=new D;return D.RotationYawPitchRollToRef(e._y,e._x,e._z,d),d}static FromEulerVectorToRef(e,d){return D.RotationYawPitchRollToRef(e._y,e._x,e._z,d),d}static FromUnitVectorsToRef(e,d,v){let p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P.e;const L=G.Dot(e,d)+1;return L<p?Math.abs(e.x)>Math.abs(e.z)?v.set(-e.y,e.x,0,0):v.set(0,-e.z,e.y,0):(G.CrossToRef(e,d,h.mv[0]),v.set(h.mv[0].x,h.mv[0].y,h.mv[0].z,L)),v.normalize()}static RotationYawPitchRoll(e,d,v){const P=new D;return D.RotationYawPitchRollToRef(e,d,v,P),P}static RotationYawPitchRollToRef(e,d,v,P){const p=.5*v,L=.5*d,B=.5*e,X=Math.sin(p),z=Math.cos(p),W=Math.sin(L),V=Math.cos(L),k=Math.sin(B),g=Math.cos(B);return P._x=g*W*z+k*V*X,P._y=k*V*z-g*W*X,P._z=g*V*X-k*W*z,P._w=g*V*z+k*W*X,P._isDirty=!0,P}static RotationAlphaBetaGamma(e,d,v){const P=new D;return D.RotationAlphaBetaGammaToRef(e,d,v,P),P}static RotationAlphaBetaGammaToRef(e,d,v,P){const p=.5*(v+e),L=.5*(v-e),B=.5*d;return P._x=Math.cos(L)*Math.sin(B),P._y=Math.sin(L)*Math.sin(B),P._z=Math.sin(p)*Math.cos(B),P._w=Math.cos(p)*Math.cos(B),P._isDirty=!0,P}static RotationQuaternionFromAxis(e,d,v){const P=new D(0,0,0,0);return D.RotationQuaternionFromAxisToRef(e,d,v,P),P}static RotationQuaternionFromAxisToRef(e,d,v,P){const p=q.Matrix[0];return e=e.normalizeToRef(q.mv[0]),d=d.normalizeToRef(q.mv[1]),v=v.normalizeToRef(q.mv[2]),C.FromXYZAxesToRef(e,d,v,p),D.FromRotationMatrixToRef(p,P),P}static FromLookDirectionLH(e,d){const v=new D;return D.FromLookDirectionLHToRef(e,d,v),v}static FromLookDirectionLHToRef(e,d,v){const P=q.Matrix[0];return C.LookDirectionLHToRef(e,d,P),D.FromRotationMatrixToRef(P,v),v}static FromLookDirectionRH(e,d){const v=new D;return D.FromLookDirectionRHToRef(e,d,v),v}static FromLookDirectionRHToRef(e,d,v){const P=q.Matrix[0];return C.LookDirectionRHToRef(e,d,P),D.FromRotationMatrixToRef(P,v)}static Slerp(e,d,v){const P=D.Identity();return D.SlerpToRef(e,d,v,P),P}static SlerpToRef(e,d,v,P){let p,L,B=e._x*d._x+e._y*d._y+e._z*d._z+e._w*d._w,X=!1;if(B<0&&(X=!0,B=-B),B>.999999)L=1-v,p=X?-v:v;else{const e=Math.acos(B),d=1/Math.sin(e);L=Math.sin((1-v)*e)*d,p=X?-Math.sin(v*e)*d:Math.sin(v*e)*d}return P._x=L*e._x+p*d._x,P._y=L*e._y+p*d._y,P._z=L*e._z+p*d._z,P._w=L*e._w+p*d._w,P._isDirty=!0,P}static Hermite(e,d,v,P,p){const L=p*p,B=p*L,X=2*B-3*L+1,z=-2*B+3*L,W=B-2*L+p,V=B-L,k=e._x*X+v._x*z+d._x*W+P._x*V,g=e._y*X+v._y*z+d._y*W+P._y*V,F=e._z*X+v._z*z+d._z*W+P._z*V,w=e._w*X+v._w*z+d._w*W+P._w*V;return new D(k,g,F,w)}static Hermite1stDerivative(e,d,v,P,p){const L=new D;return this.Hermite1stDerivativeToRef(e,d,v,P,p,L),L}static Hermite1stDerivativeToRef(e,d,v,P,p,L){const B=p*p;return L._x=6*(B-p)*e._x+(3*B-4*p+1)*d._x+6*(-B+p)*v._x+(3*B-2*p)*P._x,L._y=6*(B-p)*e._y+(3*B-4*p+1)*d._y+6*(-B+p)*v._y+(3*B-2*p)*P._y,L._z=6*(B-p)*e._z+(3*B-4*p+1)*d._z+6*(-B+p)*v._z+(3*B-2*p)*P._z,L._w=6*(B-p)*e._w+(3*B-4*p+1)*d._w+6*(-B+p)*v._w+(3*B-2*p)*P._w,L._isDirty=!0,L}static Normalize(e){const d=D.Zero();return D.NormalizeToRef(e,d),d}static NormalizeToRef(e,d){return e.normalizeToRef(d),d}static Clamp(e,d,v){const P=new D;return D.ClampToRef(e,d,v,P),P}static ClampToRef(e,d,v,P){return P.Ed((0,z.Clamp)(e.x,d.x,v.x),(0,z.Clamp)(e.y,d.y,v.y),(0,z.Clamp)(e.z,d.z,v.z),(0,z.Clamp)(e.w,d.w,v.w))}static Random(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new D((0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d))}static RandomToRef(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ed((0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d),(0,z.RandomRange)(e,d))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(e,d){return Math.sqrt(D.DistanceSquared(e,d))}static DistanceSquared(e,d){const v=e.x-d.x,P=e.y-d.y,p=e.z-d.z,L=e.w-d.w;return v*v+P*P+p*p+L*L}static Center(e,d){return D.CenterToRef(e,d,D.Zero())}static CenterToRef(e,d,v){return v.Ed((e.x+d.x)/2,(e.y+d.y)/2,(e.z+d.z)/2,(e.w+d.w)/2)}}D._V8PerformanceHack=new D(.5,.5,.5,.5),Object.defineProperties(D.prototype,{dimension:{value:[4]},rank:{value:1}});class C{static get Use64Bits(){return B.b.MatrixUse64Bits}get m(){return this.ld}markAsUpdated(){this.updateFlag=W._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(e){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1],v=arguments.length>2&&void 0!==arguments[2]&&arguments[2],P=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=e,this._isIdentity3x2=e||v,this._isIdentityDirty=!this._isIdentity&&d,this._isIdentity3x2Dirty=!this._isIdentity3x2&&P}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,B.b.MatrixTrackPrecisionChange&&B.b.MatrixTrackedMatrices.push(this),this.ld=new B.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const e=this.ld;this._isIdentity=1===e[0]&&0===e[1]&&0===e[2]&&0===e[3]&&0===e[4]&&1===e[5]&&0===e[6]&&0===e[7]&&0===e[8]&&0===e[9]&&1===e[10]&&0===e[11]&&0===e[12]&&0===e[13]&&0===e[14]&&1===e[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ld[0]||1!==this.ld[5]||1!==this.ld[15]||0!==this.ld[1]||0!==this.ld[2]||0!==this.ld[3]||0!==this.ld[4]||0!==this.ld[6]||0!==this.ld[7]||0!==this.ld[8]||0!==this.ld[9]||0!==this.ld[10]||0!==this.ld[11]||0!==this.ld[12]||0!==this.ld[13]||0!==this.ld[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const e=this.ld,d=e[0],v=e[1],P=e[2],p=e[3],L=e[4],B=e[5],X=e[6],z=e[7],W=e[8],V=e[9],k=e[10],g=e[11],F=e[12],w=e[13],G=e[14],U=e[15],D=k*U-G*g,C=V*U-w*g,q=V*G-w*k,h=W*U-F*g,l=W*G-k*F,n=W*w-F*V;return d*+(B*D-X*C+z*q)+v*-(L*D-X*h+z*l)+P*+(L*C-B*h+z*n)+p*-(L*q-B*l+X*n)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e)return this.ld;const v=this.ld;for(let P=0;P<16;P++)e[d+P]=v[P];return this}Yd(){return this.ld}Yv(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C.FromArrayToRef(e,d,this)}Ed(){for(var e=arguments.length,d=new Array(e),v=0;v<e;v++)d[v]=arguments[v];return C.FromArrayToRef(d,0,this)}set(){const e=this.ld;for(let d=0;d<16;d++)e[d]=d<0||arguments.length<=d?void 0:arguments[d];return this.markAsUpdated(),this}dp(e){const d=this.ld;for(let v=0;v<16;v++)d[v]=e;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return C.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(e){const d=new C;return this.addToRef(e,d),d}addToRef(e,d){const v=this.ld,P=d.ld,p=e.m;for(let L=0;L<16;L++)P[L]=v[L]+p[L];return d.markAsUpdated(),d}addToSelf(e){const d=this.ld,v=e.m;return d[0]+=v[0],d[1]+=v[1],d[2]+=v[2],d[3]+=v[3],d[4]+=v[4],d[5]+=v[5],d[6]+=v[6],d[7]+=v[7],d[8]+=v[8],d[9]+=v[9],d[10]+=v[10],d[11]+=v[11],d[12]+=v[12],d[13]+=v[13],d[14]+=v[14],d[15]+=v[15],this.markAsUpdated(),this}addInPlace(e){const d=this.ld,v=e.m;for(let P=0;P<16;P++)d[P]+=v[P];return this.markAsUpdated(),this}addInPlaceFromFloats(){const e=this.ld;for(let d=0;d<16;d++)e[d]+=d<0||arguments.length<=d?void 0:arguments[d];return this.markAsUpdated(),this}Zd(e){const d=this.ld,v=e.m;for(let P=0;P<16;P++)d[P]-=v[P];return this.markAsUpdated(),this}subtractToRef(e,d){const v=this.ld,P=e.m,p=d.ld;for(let L=0;L<16;L++)p[L]=v[L]-P[L];return d.markAsUpdated(),d}JV(e){const d=this.ld,v=e.m;for(let P=0;P<16;P++)d[P]-=v[P];return this.markAsUpdated(),this}subtractFromFloats(){for(var e=arguments.length,d=new Array(e),v=0;v<e;v++)d[v]=arguments[v];return this.subtractFromFloatsToRef(...d,new C)}subtractFromFloatsToRef(){for(var e=arguments.length,d=new Array(e),v=0;v<e;v++)d[v]=arguments[v];const P=d.pop(),p=this.ld,L=P.ld,B=d;for(let X=0;X<16;X++)L[X]=p[X]-B[X];return P.markAsUpdated(),P}invertToRef(e){return!0===this._isIdentity?(C.IdentityToRef(e),e):(g(this,e.Yd())?e.markAsUpdated():e.L(this),e)}addAtIndex(e,d){return this.ld[e]+=d,this.markAsUpdated(),this}multiplyAtIndex(e,d){return this.ld[e]*=d,this.markAsUpdated(),this}setTranslationFromFloats(e,d,v){return this.ld[12]=e,this.ld[13]=d,this.ld[14]=v,this.markAsUpdated(),this}addTranslationFromFloats(e,d,v){return this.ld[12]+=e,this.ld[13]+=d,this.ld[14]+=v,this.markAsUpdated(),this}setTranslation(e){return this.setTranslationFromFloats(e._x,e._y,e._z)}getTranslation(){return new G(this.ld[12],this.ld[13],this.ld[14])}getTranslationToRef(e){return e.x=this.ld[12],e.y=this.ld[13],e.z=this.ld[14],e}removeRotationAndScaling(){const e=this.m;return C.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,e[12],e[13],e[14],e[15],this),this._updateIdentityStatus(0===e[12]&&0===e[13]&&0===e[14]&&1===e[15]),this}L(e){e.copyToArray(this.ld);const d=e;return this.updateFlag=d.updateFlag,this._updateIdentityStatus(d._isIdentity,d._isIdentityDirty,d._isIdentity3x2,d._isIdentity3x2Dirty),this}copyToArray(e){return k(this,e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(e){const d=new C;return this.multiplyToRef(e,d),d}multiplyInPlace(e){const d=this.ld,v=e.m;for(let P=0;P<16;P++)d[P]*=v[P];return this.markAsUpdated(),this}multiplyByFloats(){const e=this.ld;for(let d=0;d<16;d++)e[d]*=d<0||arguments.length<=d?void 0:arguments[d];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var e=arguments.length,d=new Array(e),v=0;v<e;v++)d[v]=arguments[v];const P=d.pop(),p=this.ld,L=P.ld,B=d;for(let X=0;X<16;X++)L[X]=p[X]*B[X];return P.markAsUpdated(),P}multiplyToRef(e,d){return this._isIdentity?(d.L(e),d):e._isIdentity?(d.L(this),d):(this.multiplyToArray(e,d.ld,0),d.markAsUpdated(),d)}multiplyToArray(e,d,v){return V(this,e,d,v),this}divide(e){return this.divideToRef(e,new C)}divideToRef(e,d){const v=this.ld,P=e.m,p=d.ld;for(let L=0;L<16;L++)p[L]=v[L]/P[L];return d.markAsUpdated(),d}divideInPlace(e){const d=this.ld,v=e.m;for(let P=0;P<16;P++)d[P]/=v[P];return this.markAsUpdated(),this}minimizeInPlace(e){const d=this.ld,v=e.m;for(let P=0;P<16;P++)d[P]=Math.min(d[P],v[P]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const e=this.ld;for(let d=0;d<16;d++)e[d]=Math.min(e[d],d<0||arguments.length<=d?void 0:arguments[d]);return this.markAsUpdated(),this}maximizeInPlace(e){const d=this.ld,v=e.m;for(let P=0;P<16;P++)d[P]=Math.min(d[P],v[P]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const e=this.ld;for(let d=0;d<16;d++)e[d]=Math.min(e[d],d<0||arguments.length<=d?void 0:arguments[d]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new C)}negateInPlace(){const e=this.ld;for(let d=0;d<16;d++)e[d]=-e[d];return this.markAsUpdated(),this}negateToRef(e){const d=this.ld,v=e.ld;for(let P=0;P<16;P++)v[P]=-d[P];return e.markAsUpdated(),e}equals(e){const d=e;if(!d)return!1;if((this._isIdentity||d._isIdentity)&&!this._isIdentityDirty&&!d._isIdentityDirty)return this._isIdentity&&d._isIdentity;const v=this.m,P=d.m;return v[0]===P[0]&&v[1]===P[1]&&v[2]===P[2]&&v[3]===P[3]&&v[4]===P[4]&&v[5]===P[5]&&v[6]===P[6]&&v[7]===P[7]&&v[8]===P[8]&&v[9]===P[9]&&v[10]===P[10]&&v[11]===P[11]&&v[12]===P[12]&&v[13]===P[13]&&v[14]===P[14]&&v[15]===P[15]}equalsWithEpsilon(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const v=this.ld,P=e.m;for(let p=0;p<16;p++)if(!(0,z.WithinEpsilon)(v[p],P[p],d))return!1;return!0}equalsToFloats(){const e=this.ld;for(let d=0;d<16;d++)if(e[d]!=(d<0||arguments.length<=d?void 0:arguments[d]))return!1;return!0}floor(){return this.floorToRef(new C)}floorToRef(e){const d=this.ld,v=e.ld;for(let P=0;P<16;P++)v[P]=Math.floor(d[P]);return e.markAsUpdated(),e}fract(){return this.fractToRef(new C)}fractToRef(e){const d=this.ld,v=e.ld;for(let P=0;P<16;P++)v[P]=d[P]-Math.floor(d[P]);return e.markAsUpdated(),e}clone(){const e=new C;return e.L(this),e}getClassName(){return"Matrix"}getHashCode(){let e=F(this.ld[0]);for(let d=1;d<16;d++)e=397*e^F(this.ld[d]);return e}decomposeToTransformNode(e){return e.rotationQuaternion=e.rotationQuaternion||new D,this.decompose(e.tv,e.rotationQuaternion,e.position)}decompose(e,d,v,P){let p=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return v&&v.dp(0),e&&e.dp(1),d&&d.Ed(0,0,0,1),!0;const L=this.ld;if(v&&v.Ed(L[12],L[13],L[14]),(e=e||q.mv[0]).x=Math.sqrt(L[0]*L[0]+L[1]*L[1]+L[2]*L[2]),e.y=Math.sqrt(L[4]*L[4]+L[5]*L[5]+L[6]*L[6]),e.z=Math.sqrt(L[8]*L[8]+L[9]*L[9]+L[10]*L[10]),P){const d=(p?P.absoluteScaling.x:P.tv.x)<0?-1:1,v=(p?P.absoluteScaling.y:P.tv.y)<0?-1:1,L=(p?P.absoluteScaling.z:P.tv.z)<0?-1:1;e.x*=d,e.y*=v,e.z*=L}else this.determinant()<=0&&(e.y*=-1);if(0===e._x||0===e._y||0===e._z)return d&&d.Ed(0,0,0,1),!1;if(d){const v=1/e._x,P=1/e._y,p=1/e._z;C.FromValuesToRef(L[0]*v,L[1]*v,L[2]*v,0,L[4]*P,L[5]*P,L[6]*P,0,L[8]*p,L[9]*p,L[10]*p,0,0,0,0,1,q.Matrix[0]),D.FromRotationMatrixToRef(q.Matrix[0],d)}return!0}getRow(e){if(e<0||e>3)return null;const d=4*e;return new U(this.ld[d+0],this.ld[d+1],this.ld[d+2],this.ld[d+3])}getRowToRef(e,d){if(e>=0&&e<=3){const v=4*e;d.x=this.ld[v+0],d.y=this.ld[v+1],d.z=this.ld[v+2],d.w=this.ld[v+3]}return d}setRow(e,d){return this.setRowFromFloats(e,d.x,d.y,d.z,d.w)}transpose(){const e=new C;return C.TransposeToRef(this,e),e}transposeToRef(e){return C.TransposeToRef(this,e),e}setRowFromFloats(e,d,v,P,p){if(e<0||e>3)return this;const L=4*e;return this.ld[L+0]=d,this.ld[L+1]=v,this.ld[L+2]=P,this.ld[L+3]=p,this.markAsUpdated(),this}scale(e){const d=new C;return this.scaleToRef(e,d),d}scaleToRef(e,d){for(let v=0;v<16;v++)d.ld[v]=this.ld[v]*e;return d.markAsUpdated(),d}scaleAndAddToRef(e,d){for(let v=0;v<16;v++)d.ld[v]+=this.ld[v]*e;return d.markAsUpdated(),d}scaleInPlace(e){const d=this.ld;for(let v=0;v<16;v++)d[v]*=e;return this.markAsUpdated(),this}toNormalMatrix(e){const d=q.Matrix[0];this.invertToRef(d),d.transposeToRef(e);const v=e.ld;return C.FromValuesToRef(v[0],v[1],v[2],0,v[4],v[5],v[6],0,v[8],v[9],v[10],0,0,0,0,1,e),e}getRotationMatrix(){const e=new C;return this.getRotationMatrixToRef(e),e}getRotationMatrixToRef(e){const d=q.mv[0];if(!this.decompose(d))return C.IdentityToRef(e),e;const v=this.ld,P=1/d._x,p=1/d._y,L=1/d._z;return C.FromValuesToRef(v[0]*P,v[1]*P,v[2]*P,0,v[4]*p,v[5]*p,v[6]*p,0,v[8]*L,v[9]*L,v[10]*L,0,0,0,0,1,e),e}toggleModelMatrixHandInPlace(){const e=this.ld;return e[2]*=-1,e[6]*=-1,e[8]*=-1,e[9]*=-1,e[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const e=this.ld;return e[8]*=-1,e[9]*=-1,e[10]*=-1,e[11]*=-1,this.markAsUpdated(),this}static Nd(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const v=new C;return C.FromArrayToRef(e,d,v),v}static FromArrayToRef(e,d,v){for(let P=0;P<16;P++)v.ld[P]=e[P+d];return v.markAsUpdated(),v}static FromFloat32ArrayToRefScaled(e,d,v,P){return P.ld[0]=e[0+d]*v,P.ld[1]=e[1+d]*v,P.ld[2]=e[2+d]*v,P.ld[3]=e[3+d]*v,P.ld[4]=e[4+d]*v,P.ld[5]=e[5+d]*v,P.ld[6]=e[6+d]*v,P.ld[7]=e[7+d]*v,P.ld[8]=e[8+d]*v,P.ld[9]=e[9+d]*v,P.ld[10]=e[10+d]*v,P.ld[11]=e[11+d]*v,P.ld[12]=e[12+d]*v,P.ld[13]=e[13+d]*v,P.ld[14]=e[14+d]*v,P.ld[15]=e[15+d]*v,P.markAsUpdated(),P}static get IdentityReadOnly(){return C._IdentityReadOnly}static FromValuesToRef(e,d,v,P,p,L,B,X,z,W,V,k,g,F,w,G,U){const D=U.ld;D[0]=e,D[1]=d,D[2]=v,D[3]=P,D[4]=p,D[5]=L,D[6]=B,D[7]=X,D[8]=z,D[9]=W,D[10]=V,D[11]=k,D[12]=g,D[13]=F,D[14]=w,D[15]=G,U.markAsUpdated()}static FromValues(e,d,v,P,p,L,B,X,z,W,V,k,g,F,w,G){const U=new C,D=U.ld;return D[0]=e,D[1]=d,D[2]=v,D[3]=P,D[4]=p,D[5]=L,D[6]=B,D[7]=X,D[8]=z,D[9]=W,D[10]=V,D[11]=k,D[12]=g,D[13]=F,D[14]=w,D[15]=G,U.markAsUpdated(),U}static Compose(e,d,v){const P=new C;return C.ComposeToRef(e,d,v,P),P}static ComposeToRef(e,d,v,P){const p=P.ld,L=d._x,B=d._y,X=d._z,z=d._w,W=L+L,V=B+B,k=X+X,g=L*W,F=L*V,w=L*k,G=B*V,U=B*k,D=X*k,C=z*W,q=z*V,h=z*k,l=e._x,n=e._y,A=e._z;return p[0]=(1-(G+D))*l,p[1]=(F+h)*l,p[2]=(w-q)*l,p[3]=0,p[4]=(F-h)*n,p[5]=(1-(g+D))*n,p[6]=(U+C)*n,p[7]=0,p[8]=(w+q)*A,p[9]=(U-C)*A,p[10]=(1-(g+G))*A,p[11]=0,p[12]=v._x,p[13]=v._y,p[14]=v._z,p[15]=1,P.markAsUpdated(),P}static Identity(){const e=C.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return e._updateIdentityStatus(!0),e}static IdentityToRef(e){return C.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,e),e._updateIdentityStatus(!0),e}static Zero(){const e=C.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return e._updateIdentityStatus(!1),e}static RotationX(e){const d=new C;return C.RotationXToRef(e,d),d}static Invert(e){const d=new C;return e.invertToRef(d),d}static RotationXToRef(e,d){const v=Math.sin(e),P=Math.cos(e);return C.FromValuesToRef(1,0,0,0,0,P,v,0,0,-v,P,0,0,0,0,1,d),d._updateIdentityStatus(1===P&&0===v),d}static RotationY(e){const d=new C;return C.RotationYToRef(e,d),d}static RotationYToRef(e,d){const v=Math.sin(e),P=Math.cos(e);return C.FromValuesToRef(P,0,-v,0,0,1,0,0,v,0,P,0,0,0,0,1,d),d._updateIdentityStatus(1===P&&0===v),d}static RotationZ(e){const d=new C;return C.RotationZToRef(e,d),d}static RotationZToRef(e,d){const v=Math.sin(e),P=Math.cos(e);return C.FromValuesToRef(P,v,0,0,-v,P,0,0,0,0,1,0,0,0,0,1,d),d._updateIdentityStatus(1===P&&0===v),d}static RotationAxis(e,d){const v=new C;return C.RotationAxisToRef(e,d,v),v}static RotationAxisToRef(e,d,v){const P=Math.sin(-d),p=Math.cos(-d),L=1-p;e=e.normalizeToRef(q.mv[0]);const B=v.ld;return B[0]=e._x*e._x*L+p,B[1]=e._x*e._y*L-e._z*P,B[2]=e._x*e._z*L+e._y*P,B[3]=0,B[4]=e._y*e._x*L+e._z*P,B[5]=e._y*e._y*L+p,B[6]=e._y*e._z*L-e._x*P,B[7]=0,B[8]=e._z*e._x*L-e._y*P,B[9]=e._z*e._y*L+e._x*P,B[10]=e._z*e._z*L+p,B[11]=0,B[12]=0,B[13]=0,B[14]=0,B[15]=1,v.markAsUpdated(),v}static RotationAlignToRef(e,d,v){let p=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const L=G.Dot(d,e),B=v.ld;if(L<-1+P.e)B[0]=-1,B[1]=0,B[2]=0,B[3]=0,B[4]=0,B[5]=p?1:-1,B[6]=0,B[7]=0,B[8]=0,B[9]=0,B[10]=p?-1:1,B[11]=0;else{const v=G.Cross(d,e),P=1/(1+L);B[0]=v._x*v._x*P+L,B[1]=v._y*v._x*P-v._z,B[2]=v._z*v._x*P+v._y,B[3]=0,B[4]=v._x*v._y*P+v._z,B[5]=v._y*v._y*P+L,B[6]=v._z*v._y*P-v._x,B[7]=0,B[8]=v._x*v._z*P-v._y,B[9]=v._y*v._z*P+v._x,B[10]=v._z*v._z*P+L,B[11]=0}return B[12]=0,B[13]=0,B[14]=0,B[15]=1,v.markAsUpdated(),v}static RotationYawPitchRoll(e,d,v){const P=new C;return C.RotationYawPitchRollToRef(e,d,v,P),P}static RotationYawPitchRollToRef(e,d,v,P){return D.RotationYawPitchRollToRef(e,d,v,q.Quaternion[0]),q.Quaternion[0].toRotationMatrix(P),P}static Scaling(e,d,v){const P=new C;return C.ScalingToRef(e,d,v,P),P}static ScalingToRef(e,d,v,P){return C.FromValuesToRef(e,0,0,0,0,d,0,0,0,0,v,0,0,0,0,1,P),P._updateIdentityStatus(1===e&&1===d&&1===v),P}static Translation(e,d,v){const P=new C;return C.TranslationToRef(e,d,v,P),P}static TranslationToRef(e,d,v,P){return C.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,e,d,v,1,P),P._updateIdentityStatus(0===e&&0===d&&0===v),P}static Lerp(e,d,v){const P=new C;return C.LerpToRef(e,d,v,P),P}static LerpToRef(e,d,v,P){const p=P.ld,L=e.m,B=d.m;for(let X=0;X<16;X++)p[X]=L[X]*(1-v)+B[X]*v;return P.markAsUpdated(),P}static DecomposeLerp(e,d,v){const P=new C;return C.DecomposeLerpToRef(e,d,v,P),P}static DecomposeLerpToRef(e,d,v,P){const p=q.mv[0],L=q.Quaternion[0],B=q.mv[1];e.decompose(p,L,B);const X=q.mv[2],z=q.Quaternion[1],W=q.mv[3];d.decompose(X,z,W);const V=q.mv[4];G.LerpToRef(p,X,v,V);const k=q.Quaternion[2];D.SlerpToRef(L,z,v,k);const g=q.mv[5];return G.LerpToRef(B,W,v,g),C.ComposeToRef(V,k,g,P),P}static LookAtLH(e,d,v){const P=new C;return C.LookAtLHToRef(e,d,v,P),P}static LookAtLHToRef(e,d,v,P){const p=q.mv[0],L=q.mv[1],B=q.mv[2];d.subtractToRef(e,B),B.normalize(),G.CrossToRef(v,B,p);const X=p.lengthSquared();0===X?p.x=1:p.normalizeFromLength(Math.sqrt(X)),G.CrossToRef(B,p,L),L.normalize();const z=-G.Dot(p,e),W=-G.Dot(L,e),V=-G.Dot(B,e);return C.FromValuesToRef(p._x,L._x,B._x,0,p._y,L._y,B._y,0,p._z,L._z,B._z,0,z,W,V,1,P),P}static LookAtRH(e,d,v){const P=new C;return C.LookAtRHToRef(e,d,v,P),P}static LookAtRHToRef(e,d,v,P){const p=q.mv[0],L=q.mv[1],B=q.mv[2];e.subtractToRef(d,B),B.normalize(),G.CrossToRef(v,B,p);const X=p.lengthSquared();0===X?p.x=1:p.normalizeFromLength(Math.sqrt(X)),G.CrossToRef(B,p,L),L.normalize();const z=-G.Dot(p,e),W=-G.Dot(L,e),V=-G.Dot(B,e);return C.FromValuesToRef(p._x,L._x,B._x,0,p._y,L._y,B._y,0,p._z,L._z,B._z,0,z,W,V,1,P),P}static LookDirectionLH(e,d){const v=new C;return C.LookDirectionLHToRef(e,d,v),v}static LookDirectionLHToRef(e,d,v){const P=q.mv[0];P.L(e),P.scaleInPlace(-1);const p=q.mv[1];return G.CrossToRef(d,P,p),C.FromValuesToRef(p._x,p._y,p._z,0,d._x,d._y,d._z,0,P._x,P._y,P._z,0,0,0,0,1,v),v}static LookDirectionRH(e,d){const v=new C;return C.LookDirectionRHToRef(e,d,v),v}static LookDirectionRHToRef(e,d,v){const P=q.mv[2];return G.CrossToRef(d,e,P),C.FromValuesToRef(P._x,P._y,P._z,0,d._x,d._y,d._z,0,e._x,e._y,e._z,0,0,0,0,1,v),v}static OrthoLH(e,d,v,P,p){const L=new C;return C.OrthoLHToRef(e,d,v,P,L,p),L}static OrthoLHToRef(e,d,v,P,p,L){const B=2/e,X=2/d,z=2/(P-v),W=-(P+v)/(P-v);return C.FromValuesToRef(B,0,0,0,0,X,0,0,0,0,z,0,0,0,W,1,p),L&&p.multiplyToRef(l,p),p._updateIdentityStatus(1===B&&1===X&&1===z&&0===W),p}static OrthoOffCenterLH(e,d,v,P,p,L,B){const X=new C;return C.OrthoOffCenterLHToRef(e,d,v,P,p,L,X,B),X}static OrthoOffCenterLHToRef(e,d,v,P,p,L,B,X){const z=2/(d-e),W=2/(P-v),V=2/(L-p),k=-(L+p)/(L-p),g=(e+d)/(e-d),F=(P+v)/(v-P);return C.FromValuesToRef(z,0,0,0,0,W,0,0,0,0,V,0,g,F,k,1,B),X&&B.multiplyToRef(l,B),B.markAsUpdated(),B}static ObliqueOffCenterLHToRef(e,d,v,P,p,L,B,X,z,W,V){const k=-B*Math.cos(X),g=-B*Math.sin(X);return C.TranslationToRef(0,0,-z,q.Matrix[1]),C.FromValuesToRef(1,0,0,0,0,1,0,0,k,g,1,0,0,0,0,1,q.Matrix[0]),q.Matrix[1].multiplyToRef(q.Matrix[0],q.Matrix[0]),C.TranslationToRef(0,0,z,q.Matrix[1]),q.Matrix[0].multiplyToRef(q.Matrix[1],q.Matrix[0]),C.OrthoOffCenterLHToRef(e,d,v,P,p,L,W,V),q.Matrix[0].multiplyToRef(W,W),W}static OrthoOffCenterRH(e,d,v,P,p,L,B){const X=new C;return C.OrthoOffCenterRHToRef(e,d,v,P,p,L,X,B),X}static OrthoOffCenterRHToRef(e,d,v,P,p,L,B,X){return C.OrthoOffCenterLHToRef(e,d,v,P,p,L,B,X),B.ld[10]*=-1,B}static ObliqueOffCenterRHToRef(e,d,v,P,p,L,B,X,z,W,V){const k=B*Math.cos(X),g=B*Math.sin(X);return C.TranslationToRef(0,0,z,q.Matrix[1]),C.FromValuesToRef(1,0,0,0,0,1,0,0,k,g,1,0,0,0,0,1,q.Matrix[0]),q.Matrix[1].multiplyToRef(q.Matrix[0],q.Matrix[0]),C.TranslationToRef(0,0,-z,q.Matrix[1]),q.Matrix[0].multiplyToRef(q.Matrix[1],q.Matrix[0]),C.OrthoOffCenterRHToRef(e,d,v,P,p,L,W,V),q.Matrix[0].multiplyToRef(W,W),W}static PerspectiveLH(e,d,v,P,p){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const B=new C,X=2*v/e,z=2*v/d,W=(P+v)/(P-v),V=-2*P*v/(P-v),k=Math.tan(L);return C.FromValuesToRef(X,0,0,0,0,z,0,k,0,0,W,1,0,0,V,0,B),p&&B.multiplyToRef(l,B),B._updateIdentityStatus(!1),B}static PerspectiveFovLH(e,d,v,P,p){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,B=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const X=new C;return C.PerspectiveFovLHToRef(e,d,v,P,X,!0,p,L,B),X}static PerspectiveFovLHToRef(e,d,v,P,p){let L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,z=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const W=v,V=P,k=1/Math.tan(.5*e),g=L?k/d:k,F=L?k:k*d,w=z&&0===W?-1:0!==V?(V+W)/(V-W):1,G=z&&0===W?2*V:0!==V?-2*V*W/(V-W):-2*W,U=Math.tan(X);return C.FromValuesToRef(g,0,0,0,0,F,0,U,0,0,w,1,0,0,G,0,p),B&&p.multiplyToRef(l,p),p._updateIdentityStatus(!1),p}static PerspectiveFovReverseLHToRef(e,d,v,P,p){let L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const z=1/Math.tan(.5*e),W=L?z/d:z,V=L?z:z*d,k=Math.tan(X);return C.FromValuesToRef(W,0,0,0,0,V,0,k,0,0,-v,1,0,0,1,0,p),B&&p.multiplyToRef(l,p),p._updateIdentityStatus(!1),p}static PerspectiveFovRH(e,d,v,P,p){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,B=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const X=new C;return C.PerspectiveFovRHToRef(e,d,v,P,X,!0,p,L,B),X}static PerspectiveFovRHToRef(e,d,v,P,p){let L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,z=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const W=v,V=P,k=1/Math.tan(.5*e),g=L?k/d:k,F=L?k:k*d,w=z&&0===W?1:0!==V?-(V+W)/(V-W):-1,G=z&&0===W?2*V:0!==V?-2*V*W/(V-W):-2*W,U=Math.tan(X);return C.FromValuesToRef(g,0,0,0,0,F,0,U,0,0,w,-1,0,0,G,0,p),B&&p.multiplyToRef(l,p),p._updateIdentityStatus(!1),p}static PerspectiveFovReverseRHToRef(e,d,v,P,p){let L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const z=1/Math.tan(.5*e),W=L?z/d:z,V=L?z:z*d,k=Math.tan(X);return C.FromValuesToRef(W,0,0,0,0,V,0,k,0,0,-v,-1,0,0,-1,0,p),B&&p.multiplyToRef(l,p),p._updateIdentityStatus(!1),p}static GetFinalMatrix(e,d,v,P,p,L){const B=e.width,X=e.height,z=e.x,W=e.y,V=C.FromValues(B/2,0,0,0,0,-X/2,0,0,0,0,L-p,0,z+B/2,X/2+W,p,1),k=new C;return d.multiplyToRef(v,k),k.multiplyToRef(P,k),k.multiplyToRef(V,k)}static GetAsMatrix2x2(e){const d=e.m,v=[d[0],d[1],d[4],d[5]];return B.b.MatrixUse64Bits?v:new Float32Array(v)}static GetAsMatrix3x3(e){const d=e.m,v=[d[0],d[1],d[2],d[4],d[5],d[6],d[8],d[9],d[10]];return B.b.MatrixUse64Bits?v:new Float32Array(v)}static Transpose(e){const d=new C;return C.TransposeToRef(e,d),d}static TransposeToRef(e,d){const v=e.m,P=v[0],p=v[4],L=v[8],B=v[12],X=v[1],z=v[5],W=v[9],V=v[13],k=v[2],g=v[6],F=v[10],w=v[14],G=v[3],U=v[7],D=v[11],C=v[15],q=d.ld;return q[0]=P,q[1]=p,q[2]=L,q[3]=B,q[4]=X,q[5]=z,q[6]=W,q[7]=V,q[8]=k,q[9]=g,q[10]=F,q[11]=w,q[12]=G,q[13]=U,q[14]=D,q[15]=C,d.markAsUpdated(),d._updateIdentityStatus(e._isIdentity,e._isIdentityDirty),d}static Reflection(e){const d=new C;return C.ReflectionToRef(e,d),d}static ReflectionToRef(e,d){e.normalize();const v=e.normal.x,P=e.normal.y,p=e.normal.z,L=-2*v,B=-2*P,X=-2*p;return C.FromValuesToRef(L*v+1,B*v,X*v,0,L*P,B*P+1,X*P,0,L*p,B*p,X*p+1,0,L*e.d,B*e.d,X*e.d,1,d),d}static FromXYZAxesToRef(e,d,v,P){return C.FromValuesToRef(e._x,e._y,e._z,0,d._x,d._y,d._z,0,v._x,v._y,v._z,0,0,0,0,1,P),P}static FromQuaternionToRef(e,d){const v=e._x*e._x,P=e._y*e._y,p=e._z*e._z,L=e._x*e._y,B=e._z*e._w,X=e._z*e._x,z=e._y*e._w,W=e._y*e._z,V=e._x*e._w;return d.ld[0]=1-2*(P+p),d.ld[1]=2*(L+B),d.ld[2]=2*(X-z),d.ld[3]=0,d.ld[4]=2*(L-B),d.ld[5]=1-2*(p+v),d.ld[6]=2*(W+V),d.ld[7]=0,d.ld[8]=2*(X+z),d.ld[9]=2*(W-V),d.ld[10]=1-2*(P+v),d.ld[11]=0,d.ld[12]=0,d.ld[13]=0,d.ld[14]=0,d.ld[15]=1,d.markAsUpdated(),d}}C._IdentityReadOnly=C.Identity(),Object.defineProperties(C.prototype,{dimension:{value:[4,4]},rank:{value:2}});class q{}q.mv=(0,p.f)(11,G.Zero),q.Matrix=(0,p.f)(2,C.Identity),q.Quaternion=(0,p.f)(3,D.Zero);class h{}h.Vector2=(0,p.f)(3,w.Zero),h.mv=(0,p.f)(13,G.Zero),h.Vector4=(0,p.f)(3,U.Zero),h.Quaternion=(0,p.f)(3,D.Zero),h.Matrix=(0,p.f)(8,C.Identity),(0,L.h)("BABYLON.Vector2",w),(0,L.h)("BABYLON.Vector3",G),(0,L.h)("BABYLON.Vector4",U),(0,L.h)("BABYLON.Matrix",C);const l=C.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12433:(e,d,v)=>{function P(e,d){const v=[];for(let P=0;P<e;++P)v.push(d());return v}function p(e,d){return P(e,d)}v.d(d,{e:()=>P,f:()=>p,h:()=>B});const L=["push","splice","pop","shift","unshift"];function B(e,d){const v=L.map((v=>function(e,d,v){const P=e[d];if("function"!==typeof P)return null;const p=function(){const P=e.length,L=p.previous.apply(e,arguments);return v(d,P),L};return P.next=p,p.previous=P,e[d]=p,()=>{const v=p.previous;if(!v)return;const P=p.next;P?(v.next=P,P.previous=v):(v.next=void 0,e[d]=v),p.next=void 0,p.previous=void 0}}(e,v,d)));return()=>{for(const e of v)null===e||void 0===e||e()}}}}]);