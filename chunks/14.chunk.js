"use strict";(self.gpkvekif0vo=self.gpkvekif0vo||[]).push([[14],{12397:(a,O,i)=>{i.d(O,{e:()=>q,f:()=>G,g:()=>H,i:()=>b});const H=1/2.2,b=2.2,G=(1+Math.sqrt(5))/2,q=.001},12412:(a,O,i)=>{function H(a){return parseInt(a.toString().replace(/\W/g,""))}function b(a,O){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(a-O)<=i}function G(a,O,i){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return a<O-H||a>i+H}function q(a,O){return a===O?a:Math.random()*(O-a)+a}function Q(a,O,i){return a+(O-a)*i}function k(a,O,i){let H=r(O-a,360);return H>180&&(H-=360),a+H*h(i)}function I(a,O,i){let H=0;return H=a!=O?h((i-a)/(O-a)):0,H}function P(a,O,i,H,b){const G=b*b,q=b*G;return a*(2*q-3*G+1)+i*(-2*q+3*G)+O*(q-2*G+b)+H*(q-G)}function e(a,O,i,H,b){const G=b*b;return 6*(G-b)*a+(3*G-4*b+1)*O+6*(-G+b)*i+(3*G-2*b)*H}function h(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(i,Math.max(O,a))}function j(a){return a-=2*Math.PI*Math.floor((a+Math.PI)/(2*Math.PI))}function Z(a){const O=a.toString(16);return a<=15?("0"+O).toUpperCase():O.toUpperCase()}function F(a){if(Math.log2)return Math.floor(Math.log2(a));if(a<0)return NaN;if(0===a)return-1/0;let O=0;if(a<1){for(;a<1;)O++,a*=2;O=-O}else if(a>1)for(;a>1;)O++,a=Math.floor(a/2);return O}function r(a,O){return a-Math.floor(a/O)*O}function J(a,O,i){return(a-O)/(i-O)}function ma(a,O,i){return a*(i-O)+O}function M(a,O){let i=r(O-a,360);return i>180&&(i-=360),i}function C(a,O){const i=r(a,2*O);return O-Math.abs(i-O)}function n(a,O,i){let H=h(i);return H=-2*H*H*H+3*H*H,O*H+a*(1-H)}function D(a,O,i){let H=0;return H=Math.abs(O-a)<=i?O:a+Math.sign(O-a)*i,H}function U(a,O,i){const H=M(a,O);let b=0;return b=-i<H&&H<i?O:D(a,O=a+H,i),b}function y(a,O,i){return(a-O)/(i-O)}function w(a,O,i){return(i-O)*a+O}function K(a,O){const i=a%O;return 0===i?O:K(O,i)}i.r(O),i.d(O,{Clamp:()=>h,DeltaAngle:()=>M,Denormalize:()=>ma,ExtractAsInt:()=>H,Hermite:()=>P,Hermite1stDerivative:()=>e,HighestCommonFactor:()=>K,ILog2:()=>F,InverseLerp:()=>I,Lerp:()=>Q,LerpAngle:()=>k,MoveTowards:()=>D,MoveTowardsAngle:()=>U,Normalize:()=>J,NormalizeRadians:()=>j,OutsideRange:()=>G,PercentToRange:()=>w,PingPong:()=>C,RandomRange:()=>q,RangeToPercent:()=>y,Repeat:()=>r,SmoothStep:()=>n,ToHex:()=>Z,WithinEpsilon:()=>b})},12395:(a,O,i)=>{i.r(O),i.d(O,{Matrix:()=>ma,Quaternion:()=>J,TmpVectors:()=>C,Vector2:()=>Z,ZO:()=>F,Vector4:()=>r});var H=i(12397),b=i(12403),G=i(12346),q=i(12308),Q=i(12236),k=i(12412);class I{}function P(a,O,i){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const b=a.Cb(),G=O.Cb(),q=b[0],Q=b[1],k=b[2],I=b[3],P=b[4],e=b[5],h=b[6],j=b[7],Z=b[8],F=b[9],r=b[10],J=b[11],ma=b[12],M=b[13],C=b[14],n=b[15],D=G[0],U=G[1],y=G[2],w=G[3],K=G[4],S=G[5],f=G[6],B=G[7],T=G[8],A=G[9],E=G[10],l=G[11],W=G[12],u=G[13],c=G[14],R=G[15];i[H]=q*D+Q*K+k*T+I*W,i[H+1]=q*U+Q*S+k*A+I*u,i[H+2]=q*y+Q*f+k*E+I*c,i[H+3]=q*w+Q*B+k*l+I*R,i[H+4]=P*D+e*K+h*T+j*W,i[H+5]=P*U+e*S+h*A+j*u,i[H+6]=P*y+e*f+h*E+j*c,i[H+7]=P*w+e*B+h*l+j*R,i[H+8]=Z*D+F*K+r*T+J*W,i[H+9]=Z*U+F*S+r*A+J*u,i[H+10]=Z*y+F*f+r*E+J*c,i[H+11]=Z*w+F*B+r*l+J*R,i[H+12]=ma*D+M*K+C*T+n*W,i[H+13]=ma*U+M*S+C*A+n*u,i[H+14]=ma*y+M*f+C*E+n*c,i[H+15]=ma*w+M*B+C*l+n*R}function e(a,O){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const H=a.Cb();O[i]=H[0],O[i+1]=H[1],O[i+2]=H[2],O[i+3]=H[3],O[i+4]=H[4],O[i+5]=H[5],O[i+6]=H[6],O[i+7]=H[7],O[i+8]=H[8],O[i+9]=H[9],O[i+10]=H[10],O[i+11]=H[11],O[i+12]=H[12],O[i+13]=H[13],O[i+14]=H[14],O[i+15]=H[15]}function h(a,O){const i=a.Cb(),H=i[0],b=i[1],G=i[2],q=i[3],Q=i[4],k=i[5],I=i[6],P=i[7],e=i[8],h=i[9],j=i[10],Z=i[11],F=i[12],r=i[13],J=i[14],ma=i[15],M=j*ma-J*Z,C=h*ma-r*Z,n=h*J-r*j,D=e*ma-F*Z,U=e*J-j*F,y=e*r-F*h,w=+(k*M-I*C+P*n),K=-(Q*M-I*D+P*U),S=+(Q*C-k*D+P*y),f=-(Q*n-k*U+I*y),B=H*w+b*K+G*S+q*f;if(0===B)return!1;const T=1/B,A=I*ma-J*P,E=k*ma-r*P,l=k*J-r*I,W=Q*ma-F*P,u=Q*J-F*I,c=Q*r-F*k,R=I*Z-j*P,z=k*Z-h*P,x=k*j-h*I,g=Q*Z-e*P,N=Q*j-e*I,v=Q*h-e*k,X=-(b*M-G*C+q*n),p=+(H*M-G*D+q*U),o=-(H*C-b*D+q*y),d=+(H*n-b*U+G*y),Y=+(b*A-G*E+q*l),L=-(H*A-G*W+q*u),s=+(H*E-b*W+q*c),t=-(H*l-b*u+G*c),V=-(b*R-G*z+q*x),aa=+(H*R-G*g+q*N),Oa=-(H*z-b*g+q*v),ia=+(H*x-b*N+G*v);return O[0]=w*T,O[1]=X*T,O[2]=Y*T,O[3]=V*T,O[4]=K*T,O[5]=p*T,O[6]=L*T,O[7]=aa*T,O[8]=S*T,O[9]=o*T,O[10]=s*T,O[11]=Oa*T,O[12]=f*T,O[13]=d*T,O[14]=t*T,O[15]=ia*T,!0}I._UpdateFlagSeed=0;const j=a=>parseInt(a.toString().replace(/\W/g,""));class Z{constructor(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=a,this.y=O}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let a=j(this.x);return a=397*a^j(this.y),a}toArray(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return a[O]=this.x,a[O+1]=this.y,this}hi(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z.FromArrayToRef(a,O,this),this}Cb(){return[this.x,this.y]}q(a){return this.x=a.x,this.y=a.y,this}fb(a,O){return this.x=a,this.y=O,this}set(a,O){return this.fb(a,O)}Tb(a){return this.fb(a,a)}add(a){return new Z(this.x+a.x,this.y+a.y)}addToRef(a,O){return O.x=this.x+a.x,O.y=this.y+a.y,O}addInPlace(a){return this.x+=a.x,this.y+=a.y,this}addInPlaceFromFloats(a,O){return this.x+=a,this.y+=O,this}addVector3(a){return new Z(this.x+a.x,this.y+a.y)}FO(a){return new Z(this.x-a.x,this.y-a.y)}subtractToRef(a,O){return O.x=this.x-a.x,O.y=this.y-a.y,O}ne(a){return this.x-=a.x,this.y-=a.y,this}multiplyInPlace(a){return this.x*=a.x,this.y*=a.y,this}multiply(a){return new Z(this.x*a.x,this.y*a.y)}multiplyToRef(a,O){return O.x=this.x*a.x,O.y=this.y*a.y,O}multiplyByFloats(a,O){return new Z(this.x*a,this.y*O)}divide(a){return new Z(this.x/a.x,this.y/a.y)}divideToRef(a,O){return O.x=this.x/a.x,O.y=this.y/a.y,O}divideInPlace(a){return this.x=this.x/a.x,this.y=this.y/a.y,this}minimizeInPlace(a){return this.minimizeInPlaceFromFloats(a.x,a.y)}maximizeInPlace(a){return this.maximizeInPlaceFromFloats(a.x,a.y)}minimizeInPlaceFromFloats(a,O){return this.x=Math.min(a,this.x),this.y=Math.min(O,this.y),this}maximizeInPlaceFromFloats(a,O){return this.x=Math.max(a,this.x),this.y=Math.max(O,this.y),this}subtractFromFloats(a,O){return new Z(this.x-a,this.y-O)}subtractFromFloatsToRef(a,O,i){return i.x=this.x-a,i.y=this.y-O,i}negate(){return new Z(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(a){return a.x=-this.x,a.y=-this.y,a}scaleInPlace(a){return this.x*=a,this.y*=a,this}scale(a){return new Z(this.x*a,this.y*a)}scaleToRef(a,O){return O.x=this.x*a,O.y=this.y*a,O}scaleAndAddToRef(a,O){return O.x+=this.x*a,O.y+=this.y*a,O}equals(a){return a&&this.x===a.x&&this.y===a.y}equalsWithEpsilon(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.e;return a&&(0,k.WithinEpsilon)(this.x,a.x,O)&&(0,k.WithinEpsilon)(this.y,a.y,O)}equalsToFloats(a,O){return this.x===a&&this.y===O}floor(){return new Z(Math.floor(this.x),Math.floor(this.y))}floorToRef(a){return a.x=Math.floor(this.x),a.y=Math.floor(this.y),a}fract(){return new Z(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(a){return a.x=this.x-Math.floor(this.x),a.y=this.y-Math.floor(this.y),a}rotate(a){return this.rotateToRef(a,new Z)}rotateToRef(a,O){const i=Math.cos(a),H=Math.sin(a);return O.x=i*this.x-H*this.y,O.y=H*this.x+i*this.y,O}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(a){return 0===a||1===a?this:this.scaleInPlace(1/a)}normalizeToNew(){const a=new Z;return this.normalizeToRef(a),a}normalizeToRef(a){const O=this.length();return 0===O&&(a.x=this.x,a.y=this.y),this.scaleToRef(1/O,a)}clone(){return new Z(this.x,this.y)}dot(a){return this.x*a.x+this.y*a.y}static Zero(){return new Z(0,0)}static One(){return new Z(1,1)}static Random(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Z((0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O))}static RandomToRef(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fb((0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O))}static get ZeroReadOnly(){return Z._ZeroReadOnly}static MO(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Z(a[O],a[O+1])}static FromArrayToRef(a,O,i){return i.x=a[O],i.y=a[O+1],i}static FromFloatsToRef(a,O,i){return i.fb(a,O),i}static CatmullRom(a,O,i,H,b){const G=b*b,q=b*G,Q=.5*(2*O.x+(-a.x+i.x)*b+(2*a.x-5*O.x+4*i.x-H.x)*G+(-a.x+3*O.x-3*i.x+H.x)*q),k=.5*(2*O.y+(-a.y+i.y)*b+(2*a.y-5*O.y+4*i.y-H.y)*G+(-a.y+3*O.y-3*i.y+H.y)*q);return new Z(Q,k)}static ClampToRef(a,O,i,H){return H.x=(0,k.Clamp)(a.x,O.x,i.x),H.y=(0,k.Clamp)(a.y,O.y,i.y),H}static Clamp(a,O,i){const H=(0,k.Clamp)(a.x,O.x,i.x),b=(0,k.Clamp)(a.y,O.y,i.y);return new Z(H,b)}static Hermite(a,O,i,H,b){const G=b*b,q=b*G,Q=2*q-3*G+1,k=-2*q+3*G,I=q-2*G+b,P=q-G,e=a.x*Q+i.x*k+O.x*I+H.x*P,h=a.y*Q+i.y*k+O.y*I+H.y*P;return new Z(e,h)}static Hermite1stDerivative(a,O,i,H,b){return this.Hermite1stDerivativeToRef(a,O,i,H,b,new Z)}static Hermite1stDerivativeToRef(a,O,i,H,b,G){const q=b*b;return G.x=6*(q-b)*a.x+(3*q-4*b+1)*O.x+6*(-q+b)*i.x+(3*q-2*b)*H.x,G.y=6*(q-b)*a.y+(3*q-4*b+1)*O.y+6*(-q+b)*i.y+(3*q-2*b)*H.y,G}static Lerp(a,O,i){return Z.LerpToRef(a,O,i,new Z)}static LerpToRef(a,O,i,H){return H.x=a.x+(O.x-a.x)*i,H.y=a.y+(O.y-a.y)*i,H}static Dot(a,O){return a.x*O.x+a.y*O.y}static Normalize(a){return Z.NormalizeToRef(a,new Z)}static NormalizeToRef(a,O){return a.normalizeToRef(O),O}static Minimize(a,O){const i=a.x<O.x?a.x:O.x,H=a.y<O.y?a.y:O.y;return new Z(i,H)}static Maximize(a,O){const i=a.x>O.x?a.x:O.x,H=a.y>O.y?a.y:O.y;return new Z(i,H)}static Transform(a,O){return Z.TransformToRef(a,O,new Z)}static TransformToRef(a,O,i){const H=O.m,b=a.x*H[0]+a.y*H[4]+H[12],G=a.x*H[1]+a.y*H[5]+H[13];return i.x=b,i.y=G,i}static PointInTriangle(a,O,i,H){const b=.5*(-i.y*H.x+O.y*(-i.x+H.x)+O.x*(i.y-H.y)+i.x*H.y),G=b<0?-1:1,q=(O.y*H.x-O.x*H.y+(H.y-O.y)*a.x+(O.x-H.x)*a.y)*G,Q=(O.x*i.y-O.y*i.x+(O.y-i.y)*a.x+(i.x-O.x)*a.y)*G;return q>0&&Q>0&&q+Q<2*b*G}static Distance(a,O){return Math.sqrt(Z.DistanceSquared(a,O))}static DistanceSquared(a,O){const i=a.x-O.x,H=a.y-O.y;return i*i+H*H}static Center(a,O){return Z.CenterToRef(a,O,new Z)}static CenterToRef(a,O,i){return i.fb((a.x+O.x)/2,(a.y+O.y)/2)}static DistanceOfPointFromSegment(a,O,i){const H=Z.DistanceSquared(O,i);if(0===H)return Z.Distance(a,O);const b=i.FO(O),G=Math.max(0,Math.min(1,Z.Dot(a.FO(O),b)/H)),q=O.add(b.multiplyByFloats(G,G));return Z.Distance(a,q)}}Z._V8PerformanceHack=new Z(.5,.5),Z._ZeroReadOnly=Z.Zero(),Object.defineProperties(Z.prototype,{dimension:{value:[2]},rank:{value:1}});class F{get x(){return this._x}set x(a){this._x=a,this._isDirty=!0}get y(){return this._y}set y(a){this._y=a,this._isDirty=!0}get z(){return this._z}set z(a){this._z=a,this._isDirty=!0}constructor(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=a,this._y=O,this._z=i}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"ZO"}getHashCode(){let a=j(this._x);return a=397*a^j(this._y),a=397*a^j(this._z),a}Cb(){return[this._x,this._y,this._z]}toArray(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return a[O]=this._x,a[O+1]=this._y,a[O+2]=this._z,this}hi(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(a,O,this),this}toQuaternion(){return J.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(a){return this._x+=a._x,this._y+=a._y,this._z+=a._z,this._isDirty=!0,this}addInPlaceFromFloats(a,O,i){return this._x+=a,this._y+=O,this._z+=i,this._isDirty=!0,this}add(a){return new F(this._x+a._x,this._y+a._y,this._z+a._z)}addToRef(a,O){return O._x=this._x+a._x,O._y=this._y+a._y,O._z=this._z+a._z,O._isDirty=!0,O}ne(a){return this._x-=a._x,this._y-=a._y,this._z-=a._z,this._isDirty=!0,this}FO(a){return new F(this._x-a._x,this._y-a._y,this._z-a._z)}subtractToRef(a,O){return this.subtractFromFloatsToRef(a._x,a._y,a._z,O)}subtractFromFloats(a,O,i){return new F(this._x-a,this._y-O,this._z-i)}subtractFromFloatsToRef(a,O,i,H){return H._x=this._x-a,H._y=this._y-O,H._z=this._z-i,H._isDirty=!0,H}negate(){return new F(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(a){return a._x=-1*this._x,a._y=-1*this._y,a._z=-1*this._z,a._isDirty=!0,a}scaleInPlace(a){return this._x*=a,this._y*=a,this._z*=a,this._isDirty=!0,this}scale(a){return new F(this._x*a,this._y*a,this._z*a)}scaleToRef(a,O){return O._x=this._x*a,O._y=this._y*a,O._z=this._z*a,O._isDirty=!0,O}getNormalToRef(a){const O=this.length();let i=Math.acos(this._y/O);const H=Math.atan2(this._z,this._x);i>Math.PI/2?i-=Math.PI/2:i+=Math.PI/2;const b=O*Math.sin(i)*Math.cos(H),G=O*Math.cos(i),q=O*Math.sin(i)*Math.sin(H);return a.set(b,G,q),a}applyRotationQuaternionToRef(a,O){const i=this._x,H=this._y,b=this._z,G=a._x,q=a._y,Q=a._z,k=a._w,I=2*(q*b-Q*H),P=2*(Q*i-G*b),e=2*(G*H-q*i);return O._x=i+k*I+q*e-Q*P,O._y=H+k*P+Q*I-G*e,O._z=b+k*e+G*P-q*I,O._isDirty=!0,O}applyRotationQuaternionInPlace(a){return this.applyRotationQuaternionToRef(a,this)}applyRotationQuaternion(a){return this.applyRotationQuaternionToRef(a,new F)}scaleAndAddToRef(a,O){return O._x+=this._x*a,O._y+=this._y*a,O._z+=this._z*a,O._isDirty=!0,O}projectOnPlane(a,O){return this.projectOnPlaneToRef(a,O,new F)}projectOnPlaneToRef(a,O,i){const H=a.normal,b=a.d,G=M.ZO[0];this.subtractToRef(O,G),G.normalize();const q=F.Dot(G,H);if(Math.abs(q)<1e-10)i.Tb(1/0);else{const a=-(F.Dot(O,H)+b)/q,Q=G.scaleInPlace(a);O.addToRef(Q,i)}return i}equals(a){return a&&this._x===a._x&&this._y===a._y&&this._z===a._z}equalsWithEpsilon(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.e;return a&&(0,k.WithinEpsilon)(this._x,a._x,O)&&(0,k.WithinEpsilon)(this._y,a._y,O)&&(0,k.WithinEpsilon)(this._z,a._z,O)}equalsToFloats(a,O,i){return this._x===a&&this._y===O&&this._z===i}multiplyInPlace(a){return this._x*=a._x,this._y*=a._y,this._z*=a._z,this._isDirty=!0,this}multiply(a){return this.multiplyByFloats(a._x,a._y,a._z)}multiplyToRef(a,O){return O._x=this._x*a._x,O._y=this._y*a._y,O._z=this._z*a._z,O._isDirty=!0,O}multiplyByFloats(a,O,i){return new F(this._x*a,this._y*O,this._z*i)}divide(a){return new F(this._x/a._x,this._y/a._y,this._z/a._z)}divideToRef(a,O){return O._x=this._x/a._x,O._y=this._y/a._y,O._z=this._z/a._z,O._isDirty=!0,O}divideInPlace(a){return this._x=this._x/a._x,this._y=this._y/a._y,this._z=this._z/a._z,this._isDirty=!0,this}minimizeInPlace(a){return this.minimizeInPlaceFromFloats(a._x,a._y,a._z)}maximizeInPlace(a){return this.maximizeInPlaceFromFloats(a._x,a._y,a._z)}minimizeInPlaceFromFloats(a,O,i){return a<this._x&&(this.x=a),O<this._y&&(this.y=O),i<this._z&&(this.z=i),this}maximizeInPlaceFromFloats(a,O,i){return a>this._x&&(this.x=a),O>this._y&&(this.y=O),i>this._z&&(this.z=i),this}isNonUniformWithinEpsilon(a){const O=Math.abs(this._x),i=Math.abs(this._y);if(!(0,k.WithinEpsilon)(O,i,a))return!0;const H=Math.abs(this._z);return!(0,k.WithinEpsilon)(O,H,a)||!(0,k.WithinEpsilon)(i,H,a)}get isNonUniform(){const a=Math.abs(this._x);if(a!==Math.abs(this._y))return!0;return a!==Math.abs(this._z)}floorToRef(a){return a._x=Math.floor(this._x),a._y=Math.floor(this._y),a._z=Math.floor(this._z),a._isDirty=!0,a}floor(){return new F(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(a){return a._x=this._x-Math.floor(this._x),a._y=this._y-Math.floor(this._y),a._z=this._z-Math.floor(this._z),a._isDirty=!0,a}fract(){return new F(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(a){if("xyz"===(a=a.toLowerCase()))return this;const O=M.ZO[0].q(this);return this.x=O[a[0]],this.y=O[a[1]],this.z=O[a[2]],this}rotateByQuaternionToRef(a,O){return a.toRotationMatrix(M.Matrix[0]),F.TransformCoordinatesToRef(this,M.Matrix[0],O),O}rotateByQuaternionAroundPointToRef(a,O,i){return this.subtractToRef(O,M.ZO[0]),M.ZO[0].rotateByQuaternionToRef(a,M.ZO[0]),O.addToRef(M.ZO[0],i),i}cross(a){return F.CrossToRef(this,a,new F)}normalizeFromLength(a){return 0===a||1===a?this:this.scaleInPlace(1/a)}normalizeToNew(){return this.normalizeToRef(new F)}normalizeToRef(a){const O=this.length();return 0===O||1===O?(a._x=this._x,a._y=this._y,a._z=this._z,a._isDirty=!0,a):this.scaleToRef(1/O,a)}clone(){return new F(this._x,this._y,this._z)}q(a){return this.fb(a._x,a._y,a._z)}fb(a,O,i){return this._x=a,this._y=O,this._z=i,this._isDirty=!0,this}set(a,O,i){return this.fb(a,O,i)}Tb(a){return this._x=this._y=this._z=a,this._isDirty=!0,this}static GetClipFactor(a,O,i,H){const b=F.Dot(a,i);return(b-H)/(b-F.Dot(O,i))}static GetAngleBetweenVectors(a,O,i){const H=a.normalizeToRef(M.ZO[1]),b=O.normalizeToRef(M.ZO[2]);let G=F.Dot(H,b);G=(0,k.Clamp)(G,-1,1);const q=Math.acos(G),Q=M.ZO[3];return F.CrossToRef(H,b,Q),F.Dot(Q,i)>0?isNaN(q)?0:q:isNaN(q)?-Math.PI:-Math.acos(G)}static GetAngleBetweenVectorsOnPlane(a,O,i){M.ZO[0].q(a);const H=M.ZO[0];M.ZO[1].q(O);const b=M.ZO[1];M.ZO[2].q(i);const G=M.ZO[2],q=M.ZO[3],Q=M.ZO[4];H.normalize(),b.normalize(),G.normalize(),F.CrossToRef(G,H,q),F.CrossToRef(q,G,Q);const I=Math.atan2(F.Dot(b,q),F.Dot(b,Q));return(0,k.NormalizeRadians)(I)}static PitchYawRollToMoveBetweenPointsToRef(a,O,i){const H=C.ZO[0];return O.subtractToRef(a,H),i._y=Math.atan2(H.x,H.z)||0,i._x=Math.atan2(Math.sqrt(H.x**2+H.z**2),H.y)||0,i._z=0,i._isDirty=!0,i}static PitchYawRollToMoveBetweenPoints(a,O){const i=F.Zero();return F.PitchYawRollToMoveBetweenPointsToRef(a,O,i)}static SlerpToRef(a,O,i,b){i=(0,k.Clamp)(i,0,1);const G=M.ZO[0],q=M.ZO[1];G.q(a);const Q=G.length();G.normalizeFromLength(Q),q.q(O);const I=q.length();q.normalizeFromLength(I);const P=F.Dot(G,q);let e,h;if(P<1-H.e){const a=Math.acos(P),O=1/Math.sin(a);e=Math.sin((1-i)*a)*O,h=Math.sin(i*a)*O}else e=1-i,h=i;return G.scaleInPlace(e),q.scaleInPlace(h),b.q(G).addInPlace(q),b.scaleInPlace((0,k.Lerp)(Q,I,i)),b}static SmoothToRef(a,O,i,H,b){return F.SlerpToRef(a,O,0===H?1:i/H,b),b}static MO(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(a[O],a[O+1],a[O+2])}static FromFloatArray(a,O){return F.MO(a,O)}static FromArrayToRef(a,O,i){return i._x=a[O],i._y=a[O+1],i._z=a[O+2],i._isDirty=!0,i}static FromFloatArrayToRef(a,O,i){return F.FromArrayToRef(a,O,i)}static FromFloatsToRef(a,O,i,H){return H.fb(a,O,i),H}static Zero(){return new F(0,0,0)}static One(){return new F(1,1,1)}static Up(){return new F(0,1,0)}static get UpReadOnly(){return F._UpReadOnly}static get DownReadOnly(){return F._DownReadOnly}static get RightReadOnly(){return F._RightReadOnly}static get LeftReadOnly(){return F._LeftReadOnly}static get LeftHandedForwardReadOnly(){return F._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return F._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return F._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return F._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return F._ZeroReadOnly}static get OneReadOnly(){return F._OneReadOnly}static Down(){return new F(0,-1,0)}static Forward(){return new F(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new F(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new F(1,0,0)}static Left(){return new F(-1,0,0)}static Random(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F((0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O))}static RandomToRef(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fb((0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O))}static TransformCoordinates(a,O){const i=F.Zero();return F.TransformCoordinatesToRef(a,O,i),i}static TransformCoordinatesToRef(a,O,i){return F.TransformCoordinatesFromFloatsToRef(a._x,a._y,a._z,O,i),i}static TransformCoordinatesFromFloatsToRef(a,O,i,H,b){const G=H.m,q=a*G[0]+O*G[4]+i*G[8]+G[12],Q=a*G[1]+O*G[5]+i*G[9]+G[13],k=a*G[2]+O*G[6]+i*G[10]+G[14],I=1/(a*G[3]+O*G[7]+i*G[11]+G[15]);return b._x=q*I,b._y=Q*I,b._z=k*I,b._isDirty=!0,b}static TransformNormal(a,O){const i=F.Zero();return F.TransformNormalToRef(a,O,i),i}static TransformNormalToRef(a,O,i){return this.TransformNormalFromFloatsToRef(a._x,a._y,a._z,O,i),i}static TransformNormalFromFloatsToRef(a,O,i,H,b){const G=H.m;return b._x=a*G[0]+O*G[4]+i*G[8],b._y=a*G[1]+O*G[5]+i*G[9],b._z=a*G[2]+O*G[6]+i*G[10],b._isDirty=!0,b}static CatmullRom(a,O,i,H,b){const G=b*b,q=b*G,Q=.5*(2*O._x+(-a._x+i._x)*b+(2*a._x-5*O._x+4*i._x-H._x)*G+(-a._x+3*O._x-3*i._x+H._x)*q),k=.5*(2*O._y+(-a._y+i._y)*b+(2*a._y-5*O._y+4*i._y-H._y)*G+(-a._y+3*O._y-3*i._y+H._y)*q),I=.5*(2*O._z+(-a._z+i._z)*b+(2*a._z-5*O._z+4*i._z-H._z)*G+(-a._z+3*O._z-3*i._z+H._z)*q);return new F(Q,k,I)}static Clamp(a,O,i){const H=new F;return F.ClampToRef(a,O,i,H),H}static ClampToRef(a,O,i,H){let b=a._x;b=b>i._x?i._x:b,b=b<O._x?O._x:b;let G=a._y;G=G>i._y?i._y:G,G=G<O._y?O._y:G;let q=a._z;return q=q>i._z?i._z:q,q=q<O._z?O._z:q,H.fb(b,G,q),H}static CheckExtends(a,O,i){O.minimizeInPlace(a),i.maximizeInPlace(a)}static Hermite(a,O,i,H,b){const G=b*b,q=b*G,Q=2*q-3*G+1,k=-2*q+3*G,I=q-2*G+b,P=q-G,e=a._x*Q+i._x*k+O._x*I+H._x*P,h=a._y*Q+i._y*k+O._y*I+H._y*P,j=a._z*Q+i._z*k+O._z*I+H._z*P;return new F(e,h,j)}static Hermite1stDerivative(a,O,i,H,b){const G=new F;return this.Hermite1stDerivativeToRef(a,O,i,H,b,G),G}static Hermite1stDerivativeToRef(a,O,i,H,b,G){const q=b*b;return G._x=6*(q-b)*a._x+(3*q-4*b+1)*O._x+6*(-q+b)*i._x+(3*q-2*b)*H._x,G._y=6*(q-b)*a._y+(3*q-4*b+1)*O._y+6*(-q+b)*i._y+(3*q-2*b)*H._y,G._z=6*(q-b)*a._z+(3*q-4*b+1)*O._z+6*(-q+b)*i._z+(3*q-2*b)*H._z,G._isDirty=!0,G}static Lerp(a,O,i){const H=new F(0,0,0);return F.LerpToRef(a,O,i,H),H}static LerpToRef(a,O,i,H){return H._x=a._x+(O._x-a._x)*i,H._y=a._y+(O._y-a._y)*i,H._z=a._z+(O._z-a._z)*i,H._isDirty=!0,H}static Dot(a,O){return a._x*O._x+a._y*O._y+a._z*O._z}dot(a){return this._x*a._x+this._y*a._y+this._z*a._z}static Cross(a,O){const i=new F;return F.CrossToRef(a,O,i),i}static CrossToRef(a,O,i){const H=a._y*O._z-a._z*O._y,b=a._z*O._x-a._x*O._z,G=a._x*O._y-a._y*O._x;return i.fb(H,b,G),i}static Normalize(a){const O=F.Zero();return F.NormalizeToRef(a,O),O}static NormalizeToRef(a,O){return a.normalizeToRef(O),O}static Project(a,O,i,H){const b=new F;return F.ProjectToRef(a,O,i,H,b),b}static ProjectToRef(a,O,i,H,b){var G;const q=H.width,k=H.height,I=H.x,P=H.y,e=M.Matrix[1],h=null===(G=Q.b.LastCreatedEngine)||void 0===G?void 0:G.isNDCHalfZRange,j=h?1:.5,Z=h?0:.5;ma.FromValuesToRef(q/2,0,0,0,0,-k/2,0,0,0,0,j,0,I+q/2,k/2+P,Z,1,e);const r=M.Matrix[0];return O.multiplyToRef(i,r),r.multiplyToRef(e,r),F.TransformCoordinatesToRef(a,r,b),b}static Reflect(a,O){return this.ReflectToRef(a,O,new F)}static ReflectToRef(a,O,i){const H=C.ZO[0];return H.q(O).scaleInPlace(2*F.Dot(a,O)),i.q(a).ne(H)}static _UnprojectFromInvertedMatrixToRef(a,O,i){F.TransformCoordinatesToRef(a,O,i);const H=O.m,b=a._x*H[3]+a._y*H[7]+a._z*H[11]+H[15];return(0,k.WithinEpsilon)(b,1)&&i.scaleInPlace(1/b),i}static UnprojectFromTransform(a,O,i,H,b){return this.Unproject(a,O,i,H,b,ma.IdentityReadOnly)}static Unproject(a,O,i,H,b,G){const q=new F;return F.UnprojectToRef(a,O,i,H,b,G,q),q}static UnprojectToRef(a,O,i,H,b,G,q){return F.UnprojectFloatsToRef(a._x,a._y,a._z,O,i,H,b,G,q),q}static UnprojectFloatsToRef(a,O,i,H,b,G,q,k,I){var P;const e=M.Matrix[0];G.multiplyToRef(q,e),e.multiplyToRef(k,e),e.invert();const h=M.ZO[0];return h.x=a/H*2-1,h.y=-(O/b*2-1),null!==(P=Q.b.LastCreatedEngine)&&void 0!==P&&P.isNDCHalfZRange?h.z=i:h.z=2*i-1,F._UnprojectFromInvertedMatrixToRef(h,e,I),I}static Minimize(a,O){const i=new F;return i.q(a),i.minimizeInPlace(O),i}static Maximize(a,O){const i=new F;return i.q(a),i.maximizeInPlace(O),i}static Distance(a,O){return Math.sqrt(F.DistanceSquared(a,O))}static DistanceSquared(a,O){const i=a._x-O._x,H=a._y-O._y,b=a._z-O._z;return i*i+H*H+b*b}static ProjectOnTriangleToRef(a,O,i,b,G){const q=M.ZO[0],Q=M.ZO[1],I=M.ZO[2],P=M.ZO[3],e=M.ZO[4];i.subtractToRef(O,q),b.subtractToRef(O,Q),b.subtractToRef(i,I);const h=q.length(),j=Q.length(),Z=I.length();if(h<H.e||j<H.e||Z<H.e)return G.q(O),F.Distance(a,O);a.subtractToRef(O,e),F.CrossToRef(q,Q,P);const r=P.length();if(r<H.e)return G.q(O),F.Distance(a,O);P.normalizeFromLength(r);let J=e.length();if(J<H.e)return G.q(O),0;e.normalizeFromLength(J);const ma=F.Dot(P,e),C=M.ZO[5],n=M.ZO[6];C.q(P).scaleInPlace(-J*ma),n.q(a).addInPlace(C);const D=M.ZO[4],U=M.ZO[5],y=M.ZO[7],w=M.ZO[8];D.q(q).scaleInPlace(1/h),w.q(Q).scaleInPlace(1/j),D.addInPlace(w).scaleInPlace(-1),U.q(q).scaleInPlace(-1/h),w.q(I).scaleInPlace(1/Z),U.addInPlace(w).scaleInPlace(-1),y.q(I).scaleInPlace(-1/Z),w.q(Q).scaleInPlace(-1/j),y.addInPlace(w).scaleInPlace(-1);const K=M.ZO[9];let S;K.q(n).ne(O),F.CrossToRef(D,K,w),S=F.Dot(w,P);const f=S;K.q(n).ne(i),F.CrossToRef(U,K,w),S=F.Dot(w,P);const B=S;K.q(n).ne(b),F.CrossToRef(y,K,w),S=F.Dot(w,P);const T=S,A=M.ZO[10];let E,l;f>0&&B<0?(A.q(q),E=O,l=i):B>0&&T<0?(A.q(I),E=i,l=b):(A.q(Q).scaleInPlace(-1),E=b,l=O);const W=M.ZO[9],u=M.ZO[4];E.subtractToRef(n,w),l.subtractToRef(n,W),F.CrossToRef(w,W,u);if(!(F.Dot(u,P)<0))return G.q(n),Math.abs(J*ma);const c=M.ZO[5];F.CrossToRef(A,u,c),c.normalize();const R=M.ZO[9];R.q(E).ne(n);const z=R.length();if(z<H.e)return G.q(E),F.Distance(a,E);R.normalizeFromLength(z);const x=F.Dot(c,R),g=M.ZO[7];g.q(n).addInPlace(c.scaleInPlace(z*x)),w.q(g).ne(E),J=A.length(),A.normalizeFromLength(J);let N=F.Dot(w,A)/Math.max(J,H.e);return N=(0,k.Clamp)(N,0,1),g.q(E).addInPlace(A.scaleInPlace(N*J)),G.q(g),F.Distance(a,g)}static Center(a,O){return F.CenterToRef(a,O,F.Zero())}static CenterToRef(a,O,i){return i.fb((a._x+O._x)/2,(a._y+O._y)/2,(a._z+O._z)/2)}static RotationFromAxis(a,O,i){const H=new F;return F.RotationFromAxisToRef(a,O,i,H),H}static RotationFromAxisToRef(a,O,i,H){const b=M.Quaternion[0];return J.RotationQuaternionFromAxisToRef(a,O,i,b),b.toEulerAnglesToRef(H),H}}F._V8PerformanceHack=new F(.5,.5,.5),F._UpReadOnly=F.Up(),F._DownReadOnly=F.Down(),F._LeftHandedForwardReadOnly=F.Forward(!1),F._RightHandedForwardReadOnly=F.Forward(!0),F._LeftHandedBackwardReadOnly=F.Backward(!1),F._RightHandedBackwardReadOnly=F.Backward(!0),F._RightReadOnly=F.Right(),F._LeftReadOnly=F.Left(),F._ZeroReadOnly=F.Zero(),F._OneReadOnly=F.One(),Object.defineProperties(F.prototype,{dimension:{value:[3]},rank:{value:1}});class r{get x(){return this._x}set x(a){this._x=a,this._isDirty=!0}get y(){return this._y}set y(a){this._y=a,this._isDirty=!0}get z(){return this._z}set z(a){this._z=a,this._isDirty=!0}get w(){return this._w}set w(a){this._w=a,this._isDirty=!0}constructor(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=a,this._y=O,this._z=i,this._w=H}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let a=j(this._x);return a=397*a^j(this._y),a=397*a^j(this._z),a=397*a^j(this._w),a}Cb(){return[this._x,this._y,this._z,this._w]}toArray(a,O){return void 0===O&&(O=0),a[O]=this._x,a[O+1]=this._y,a[O+2]=this._z,a[O+3]=this._w,this}hi(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r.FromArrayToRef(a,O,this),this}addInPlace(a){return this.x+=a._x,this.y+=a._y,this.z+=a._z,this.w+=a._w,this}addInPlaceFromFloats(a,O,i,H){return this.x+=a,this.y+=O,this.z+=i,this.w+=H,this}add(a){return new r(this._x+a.x,this._y+a.y,this._z+a.z,this._w+a.w)}addToRef(a,O){return O.x=this._x+a.x,O.y=this._y+a.y,O.z=this._z+a.z,O.w=this._w+a.w,O}ne(a){return this.x-=a.x,this.y-=a.y,this.z-=a.z,this.w-=a.w,this}FO(a){return new r(this._x-a.x,this._y-a.y,this._z-a.z,this._w-a.w)}subtractToRef(a,O){return O.x=this._x-a.x,O.y=this._y-a.y,O.z=this._z-a.z,O.w=this._w-a.w,O}subtractFromFloats(a,O,i,H){return new r(this._x-a,this._y-O,this._z-i,this._w-H)}subtractFromFloatsToRef(a,O,i,H,b){return b.x=this._x-a,b.y=this._y-O,b.z=this._z-i,b.w=this._w-H,b}negate(){return new r(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(a){return a.x=-this._x,a.y=-this._y,a.z=-this._z,a.w=-this._w,a}scaleInPlace(a){return this.x*=a,this.y*=a,this.z*=a,this.w*=a,this}scale(a){return new r(this._x*a,this._y*a,this._z*a,this._w*a)}scaleToRef(a,O){return O.x=this._x*a,O.y=this._y*a,O.z=this._z*a,O.w=this._w*a,O}scaleAndAddToRef(a,O){return O.x+=this._x*a,O.y+=this._y*a,O.z+=this._z*a,O.w+=this._w*a,O}equals(a){return a&&this._x===a.x&&this._y===a.y&&this._z===a.z&&this._w===a.w}equalsWithEpsilon(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.e;return a&&(0,k.WithinEpsilon)(this._x,a.x,O)&&(0,k.WithinEpsilon)(this._y,a.y,O)&&(0,k.WithinEpsilon)(this._z,a.z,O)&&(0,k.WithinEpsilon)(this._w,a.w,O)}equalsToFloats(a,O,i,H){return this._x===a&&this._y===O&&this._z===i&&this._w===H}multiplyInPlace(a){return this.x*=a.x,this.y*=a.y,this.z*=a.z,this.w*=a.w,this}multiply(a){return new r(this._x*a.x,this._y*a.y,this._z*a.z,this._w*a.w)}multiplyToRef(a,O){return O.x=this._x*a.x,O.y=this._y*a.y,O.z=this._z*a.z,O.w=this._w*a.w,O}multiplyByFloats(a,O,i,H){return new r(this._x*a,this._y*O,this._z*i,this._w*H)}divide(a){return new r(this._x/a.x,this._y/a.y,this._z/a.z,this._w/a.w)}divideToRef(a,O){return O.x=this._x/a.x,O.y=this._y/a.y,O.z=this._z/a.z,O.w=this._w/a.w,O}divideInPlace(a){return this.divideToRef(a,this)}minimizeInPlace(a){return a.x<this._x&&(this.x=a.x),a.y<this._y&&(this.y=a.y),a.z<this._z&&(this.z=a.z),a.w<this._w&&(this.w=a.w),this}maximizeInPlace(a){return a.x>this._x&&(this.x=a.x),a.y>this._y&&(this.y=a.y),a.z>this._z&&(this.z=a.z),a.w>this._w&&(this.w=a.w),this}minimizeInPlaceFromFloats(a,O,i,H){return this.x=Math.min(a,this._x),this.y=Math.min(O,this._y),this.z=Math.min(i,this._z),this.w=Math.min(H,this._w),this}maximizeInPlaceFromFloats(a,O,i,H){return this.x=Math.max(a,this._x),this.y=Math.max(O,this._y),this.z=Math.max(i,this._z),this.w=Math.max(H,this._w),this}floorToRef(a){return a.x=Math.floor(this._x),a.y=Math.floor(this._y),a.z=Math.floor(this._z),a.w=Math.floor(this._w),a}floor(){return new r(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(a){return a.x=this._x-Math.floor(this._x),a.y=this._y-Math.floor(this._y),a.z=this._z-Math.floor(this._z),a.w=this._w-Math.floor(this._w),a}fract(){return new r(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(a){return 0===a||1===a?this:this.scaleInPlace(1/a)}normalizeToNew(){return this.normalizeToRef(new r)}normalizeToRef(a){const O=this.length();return 0===O||1===O?(a.x=this._x,a.y=this._y,a.z=this._z,a.w=this._w,a):this.scaleToRef(1/O,a)}toVector3(){return new F(this._x,this._y,this._z)}clone(){return new r(this._x,this._y,this._z,this._w)}q(a){return this.x=a.x,this.y=a.y,this.z=a.z,this.w=a.w,this}fb(a,O,i,H){return this.x=a,this.y=O,this.z=i,this.w=H,this}set(a,O,i,H){return this.fb(a,O,i,H)}Tb(a){return this.x=this.y=this.z=this.w=a,this}dot(a){return this._x*a.x+this._y*a.y+this._z*a.z+this._w*a.w}static MO(a,O){return O||(O=0),new r(a[O],a[O+1],a[O+2],a[O+3])}static FromArrayToRef(a,O,i){return i.x=a[O],i.y=a[O+1],i.z=a[O+2],i.w=a[O+3],i}static FromFloatArrayToRef(a,O,i){return r.FromArrayToRef(a,O,i),i}static FromFloatsToRef(a,O,i,H,b){return b.x=a,b.y=O,b.z=i,b.w=H,b}static Zero(){return new r(0,0,0,0)}static One(){return new r(1,1,1,1)}static Random(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new r((0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O))}static RandomToRef(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0;return i.x=(0,k.RandomRange)(a,O),i.y=(0,k.RandomRange)(a,O),i.z=(0,k.RandomRange)(a,O),i.w=(0,k.RandomRange)(a,O),i}static Clamp(a,O,i){return r.ClampToRef(a,O,i,new r)}static ClampToRef(a,O,i,H){return H.x=(0,k.Clamp)(a.x,O.x,i.x),H.y=(0,k.Clamp)(a.y,O.y,i.y),H.z=(0,k.Clamp)(a.z,O.z,i.z),H.w=(0,k.Clamp)(a.w,O.w,i.w),H}static CheckExtends(a,O,i){O.minimizeInPlace(a),i.maximizeInPlace(a)}static get ZeroReadOnly(){return r._ZeroReadOnly}static Normalize(a){return r.NormalizeToRef(a,new r)}static NormalizeToRef(a,O){return a.normalizeToRef(O),O}static Minimize(a,O){const i=new r;return i.q(a),i.minimizeInPlace(O),i}static Maximize(a,O){const i=new r;return i.q(a),i.maximizeInPlace(O),i}static Distance(a,O){return Math.sqrt(r.DistanceSquared(a,O))}static DistanceSquared(a,O){const i=a.x-O.x,H=a.y-O.y,b=a.z-O.z,G=a.w-O.w;return i*i+H*H+b*b+G*G}static Center(a,O){return r.CenterToRef(a,O,new r)}static CenterToRef(a,O,i){return i.x=(a.x+O.x)/2,i.y=(a.y+O.y)/2,i.z=(a.z+O.z)/2,i.w=(a.w+O.w)/2,i}static TransformCoordinates(a,O){return r.TransformCoordinatesToRef(a,O,new r)}static TransformCoordinatesToRef(a,O,i){return r.TransformCoordinatesFromFloatsToRef(a._x,a._y,a._z,O,i),i}static TransformCoordinatesFromFloatsToRef(a,O,i,H,b){const G=H.m,q=a*G[0]+O*G[4]+i*G[8]+G[12],Q=a*G[1]+O*G[5]+i*G[9]+G[13],k=a*G[2]+O*G[6]+i*G[10]+G[14],I=a*G[3]+O*G[7]+i*G[11]+G[15];return b.x=q,b.y=Q,b.z=k,b.w=I,b}static TransformNormal(a,O){return r.TransformNormalToRef(a,O,new r)}static TransformNormalToRef(a,O,i){const H=O.m,b=a.x*H[0]+a.y*H[4]+a.z*H[8],G=a.x*H[1]+a.y*H[5]+a.z*H[9],q=a.x*H[2]+a.y*H[6]+a.z*H[10];return i.x=b,i.y=G,i.z=q,i.w=a.w,i}static TransformNormalFromFloatsToRef(a,O,i,H,b,G){const q=b.m;return G.x=a*q[0]+O*q[4]+i*q[8],G.y=a*q[1]+O*q[5]+i*q[9],G.z=a*q[2]+O*q[6]+i*q[10],G.w=H,G}static FromVector3(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new r(a._x,a._y,a._z,O)}static Dot(a,O){return a.x*O.x+a.y*O.y+a.z*O.z+a.w*O.w}}r._V8PerformanceHack=new r(.5,.5,.5,.5),r._ZeroReadOnly=r.Zero(),Object.defineProperties(r.prototype,{dimension:{value:[4]},rank:{value:1}});class J{get x(){return this._x}set x(a){this._x=a,this._isDirty=!0}get y(){return this._y}set y(a){this._y=a,this._isDirty=!0}get z(){return this._z}set z(a){this._z=a,this._isDirty=!0}get w(){return this._w}set w(a){this._w=a,this._isDirty=!0}constructor(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=a,this._y=O,this._z=i,this._w=H}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let a=j(this._x);return a=397*a^j(this._y),a=397*a^j(this._z),a=397*a^j(this._w),a}Cb(){return[this._x,this._y,this._z,this._w]}toArray(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return a[O]=this._x,a[O+1]=this._y,a[O+2]=this._z,a[O+3]=this._w,this}hi(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(a,O,this)}equals(a){return a&&this._x===a._x&&this._y===a._y&&this._z===a._z&&this._w===a._w}equalsWithEpsilon(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.e;return a&&(0,k.WithinEpsilon)(this._x,a._x,O)&&(0,k.WithinEpsilon)(this._y,a._y,O)&&(0,k.WithinEpsilon)(this._z,a._z,O)&&(0,k.WithinEpsilon)(this._w,a._w,O)}isApprox(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.e;return a&&((0,k.WithinEpsilon)(this._x,a._x,O)&&(0,k.WithinEpsilon)(this._y,a._y,O)&&(0,k.WithinEpsilon)(this._z,a._z,O)&&(0,k.WithinEpsilon)(this._w,a._w,O)||(0,k.WithinEpsilon)(this._x,-a._x,O)&&(0,k.WithinEpsilon)(this._y,-a._y,O)&&(0,k.WithinEpsilon)(this._z,-a._z,O)&&(0,k.WithinEpsilon)(this._w,-a._w,O))}clone(){return new J(this._x,this._y,this._z,this._w)}q(a){return this._x=a._x,this._y=a._y,this._z=a._z,this._w=a._w,this._isDirty=!0,this}fb(a,O,i,H){return this._x=a,this._y=O,this._z=i,this._w=H,this._isDirty=!0,this}set(a,O,i,H){return this.fb(a,O,i,H)}Tb(a){return this.fb(a,a,a,a)}add(a){return new J(this._x+a._x,this._y+a._y,this._z+a._z,this._w+a._w)}addInPlace(a){return this._x+=a._x,this._y+=a._y,this._z+=a._z,this._w+=a._w,this._isDirty=!0,this}addToRef(a,O){return O._x=this._x+a._x,O._y=this._y+a._y,O._z=this._z+a._z,O._w=this._w+a._w,O._isDirty=!0,O}addInPlaceFromFloats(a,O,i,H){return this._x+=a,this._y+=O,this._z+=i,this._w+=H,this._isDirty=!0,this}subtractToRef(a,O){return O._x=this._x-a._x,O._y=this._y-a._y,O._z=this._z-a._z,O._w=this._w-a._w,O._isDirty=!0,O}subtractFromFloats(a,O,i,H){return this.subtractFromFloatsToRef(a,O,i,H,new J)}subtractFromFloatsToRef(a,O,i,H,b){return b._x=this._x-a,b._y=this._y-O,b._z=this._z-i,b._w=this._w-H,b._isDirty=!0,b}FO(a){return new J(this._x-a._x,this._y-a._y,this._z-a._z,this._w-a._w)}ne(a){return this._x-=a._x,this._y-=a._y,this._z-=a._z,this._w-=a._w,this._isDirty=!0,this}scale(a){return new J(this._x*a,this._y*a,this._z*a,this._w*a)}scaleToRef(a,O){return O._x=this._x*a,O._y=this._y*a,O._z=this._z*a,O._w=this._w*a,O._isDirty=!0,O}scaleInPlace(a){return this._x*=a,this._y*=a,this._z*=a,this._w*=a,this._isDirty=!0,this}scaleAndAddToRef(a,O){return O._x+=this._x*a,O._y+=this._y*a,O._z+=this._z*a,O._w+=this._w*a,O._isDirty=!0,O}multiply(a){const O=new J(0,0,0,1);return this.multiplyToRef(a,O),O}multiplyToRef(a,O){const i=this._x*a._w+this._y*a._z-this._z*a._y+this._w*a._x,H=-this._x*a._z+this._y*a._w+this._z*a._x+this._w*a._y,b=this._x*a._y-this._y*a._x+this._z*a._w+this._w*a._z,G=-this._x*a._x-this._y*a._y-this._z*a._z+this._w*a._w;return O.fb(i,H,b,G),O}multiplyInPlace(a){return this.multiplyToRef(a,this)}multiplyByFloats(a,O,i,H){return this._x*=a,this._y*=O,this._z*=i,this._w*=H,this._isDirty=!0,this}divide(a){throw new ReferenceError("Can not divide a quaternion")}divideToRef(a,O){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(a){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new J)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(a){return a._x=-this._x,a._y=-this._y,a._z=-this._z,a._w=-this._w,a._isDirty=!0,a}equalsToFloats(a,O,i,H){return this._x===a&&this._y===O&&this._z===i&&this._w===H}floorToRef(a){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(a){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(a){return a.fb(-this._x,-this._y,-this._z,this._w),a}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new J(-this._x,-this._y,-this._z,this._w)}invert(){const a=this.conjugate(),O=this.lengthSquared();return 0==O||1==O||a.scaleInPlace(1/O),a}invertInPlace(){this.conjugateInPlace();const a=this.lengthSquared();return 0==a||1==a||this.scaleInPlace(1/a),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(a){return 0===a||1===a?this:this.scaleInPlace(1/a)}normalizeToNew(){const a=new J(0,0,0,1);return this.normalizeToRef(a),a}normalizeToRef(a){const O=this.length();return 0===O||1===O?a.fb(this._x,this._y,this._z,this._w):this.scaleToRef(1/O,a)}toEulerAngles(){const a=F.Zero();return this.toEulerAnglesToRef(a),a}toEulerAnglesToRef(a){const O=this._z,i=this._x,H=this._y,b=this._w,G=H*O-i*b,q=.4999999;if(G<-q)a._y=2*Math.atan2(H,b),a._x=Math.PI/2,a._z=0,a._isDirty=!0;else if(G>q)a._y=2*Math.atan2(H,b),a._x=-Math.PI/2,a._z=0,a._isDirty=!0;else{const q=b*b,Q=O*O,k=i*i,I=H*H;a._z=Math.atan2(2*(i*H+O*b),-Q-k+I+q),a._x=Math.asin(-2*G),a._y=Math.atan2(2*(O*i+H*b),Q-k-I+q),a._isDirty=!0}return a}toAlphaBetaGammaToRef(a){const O=this._z,i=this._x,H=this._y,b=this._w,G=Math.sqrt(i*i+H*H),q=Math.sqrt(O*O+b*b),Q=2*Math.atan2(G,q),k=2*Math.atan2(O,b),I=2*Math.atan2(H,i),P=(k+I)/2,e=(k-I)/2;return a.set(e,Q,P),a}toRotationMatrix(a){return ma.FromQuaternionToRef(this,a),a}fromRotationMatrix(a){return J.FromRotationMatrixToRef(a,this),this}dot(a){return this._x*a._x+this._y*a._y+this._z*a._z+this._w*a._w}toAxisAngle(){const a=F.Zero();return{axis:a,angle:this.toAxisAngleToRef(a)}}toAxisAngleToRef(a){let O=0;const i=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),H=this._w;return i>0?(O=2*Math.atan2(i,H),a.set(this._x/i,this._y/i,this._z/i)):(O=0,a.set(1,0,0)),O}static FromRotationMatrix(a){const O=new J;return J.FromRotationMatrixToRef(a,O),O}static FromRotationMatrixToRef(a,O){const i=a.m,H=i[0],b=i[4],G=i[8],q=i[1],Q=i[5],k=i[9],I=i[2],P=i[6],e=i[10],h=H+Q+e;let j;return h>0?(j=.5/Math.sqrt(h+1),O._w=.25/j,O._x=(P-k)*j,O._y=(G-I)*j,O._z=(q-b)*j,O._isDirty=!0):H>Q&&H>e?(j=2*Math.sqrt(1+H-Q-e),O._w=(P-k)/j,O._x=.25*j,O._y=(b+q)/j,O._z=(G+I)/j,O._isDirty=!0):Q>e?(j=2*Math.sqrt(1+Q-H-e),O._w=(G-I)/j,O._x=(b+q)/j,O._y=.25*j,O._z=(k+P)/j,O._isDirty=!0):(j=2*Math.sqrt(1+e-H-Q),O._w=(q-b)/j,O._x=(G+I)/j,O._y=(k+P)/j,O._z=.25*j,O._isDirty=!0),O}static Dot(a,O){return a._x*O._x+a._y*O._y+a._z*O._z+a._w*O._w}static AreClose(a,O){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const H=J.Dot(a,O);return 1-H*H<=i}static SmoothToRef(a,O,i,H,b){let G=0===H?1:i/H;return G=(0,k.Clamp)(G,0,1),J.SlerpToRef(a,O,G,b),b}static Zero(){return new J(0,0,0,0)}static Inverse(a){return new J(-a._x,-a._y,-a._z,a._w)}static InverseToRef(a,O){return O.set(-a._x,-a._y,-a._z,a._w),O}static Identity(){return new J(0,0,0,1)}static IsIdentity(a){return a&&0===a._x&&0===a._y&&0===a._z&&1===a._w}static RotationAxis(a,O){return J.RotationAxisToRef(a,O,new J)}static RotationAxisToRef(a,O,i){i._w=Math.cos(O/2);const H=Math.sin(O/2)/a.length();return i._x=a._x*H,i._y=a._y*H,i._z=a._z*H,i._isDirty=!0,i}static MO(a,O){return O||(O=0),new J(a[O],a[O+1],a[O+2],a[O+3])}static FromArrayToRef(a,O,i){return i._x=a[O],i._y=a[O+1],i._z=a[O+2],i._w=a[O+3],i._isDirty=!0,i}static FromFloatsToRef(a,O,i,H,b){return b.fb(a,O,i,H),b}static FromEulerAngles(a,O,i){const H=new J;return J.RotationYawPitchRollToRef(O,a,i,H),H}static FromEulerAnglesToRef(a,O,i,H){return J.RotationYawPitchRollToRef(O,a,i,H),H}static FromEulerVector(a){const O=new J;return J.RotationYawPitchRollToRef(a._y,a._x,a._z,O),O}static FromEulerVectorToRef(a,O){return J.RotationYawPitchRollToRef(a._y,a._x,a._z,O),O}static FromUnitVectorsToRef(a,O,i){let b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:H.e;const G=F.Dot(a,O)+1;return G<b?Math.abs(a.x)>Math.abs(a.z)?i.set(-a.y,a.x,0,0):i.set(0,-a.z,a.y,0):(F.CrossToRef(a,O,C.ZO[0]),i.set(C.ZO[0].x,C.ZO[0].y,C.ZO[0].z,G)),i.normalize()}static RotationYawPitchRoll(a,O,i){const H=new J;return J.RotationYawPitchRollToRef(a,O,i,H),H}static RotationYawPitchRollToRef(a,O,i,H){const b=.5*i,G=.5*O,q=.5*a,Q=Math.sin(b),k=Math.cos(b),I=Math.sin(G),P=Math.cos(G),e=Math.sin(q),h=Math.cos(q);return H._x=h*I*k+e*P*Q,H._y=e*P*k-h*I*Q,H._z=h*P*Q-e*I*k,H._w=h*P*k+e*I*Q,H._isDirty=!0,H}static RotationAlphaBetaGamma(a,O,i){const H=new J;return J.RotationAlphaBetaGammaToRef(a,O,i,H),H}static RotationAlphaBetaGammaToRef(a,O,i,H){const b=.5*(i+a),G=.5*(i-a),q=.5*O;return H._x=Math.cos(G)*Math.sin(q),H._y=Math.sin(G)*Math.sin(q),H._z=Math.sin(b)*Math.cos(q),H._w=Math.cos(b)*Math.cos(q),H._isDirty=!0,H}static RotationQuaternionFromAxis(a,O,i){const H=new J(0,0,0,0);return J.RotationQuaternionFromAxisToRef(a,O,i,H),H}static RotationQuaternionFromAxisToRef(a,O,i,H){const b=M.Matrix[0];return a=a.normalizeToRef(M.ZO[0]),O=O.normalizeToRef(M.ZO[1]),i=i.normalizeToRef(M.ZO[2]),ma.FromXYZAxesToRef(a,O,i,b),J.FromRotationMatrixToRef(b,H),H}static FromLookDirectionLH(a,O){const i=new J;return J.FromLookDirectionLHToRef(a,O,i),i}static FromLookDirectionLHToRef(a,O,i){const H=M.Matrix[0];return ma.LookDirectionLHToRef(a,O,H),J.FromRotationMatrixToRef(H,i),i}static FromLookDirectionRH(a,O){const i=new J;return J.FromLookDirectionRHToRef(a,O,i),i}static FromLookDirectionRHToRef(a,O,i){const H=M.Matrix[0];return ma.LookDirectionRHToRef(a,O,H),J.FromRotationMatrixToRef(H,i)}static Slerp(a,O,i){const H=J.Identity();return J.SlerpToRef(a,O,i,H),H}static SlerpToRef(a,O,i,H){let b,G,q=a._x*O._x+a._y*O._y+a._z*O._z+a._w*O._w,Q=!1;if(q<0&&(Q=!0,q=-q),q>.999999)G=1-i,b=Q?-i:i;else{const a=Math.acos(q),O=1/Math.sin(a);G=Math.sin((1-i)*a)*O,b=Q?-Math.sin(i*a)*O:Math.sin(i*a)*O}return H._x=G*a._x+b*O._x,H._y=G*a._y+b*O._y,H._z=G*a._z+b*O._z,H._w=G*a._w+b*O._w,H._isDirty=!0,H}static Hermite(a,O,i,H,b){const G=b*b,q=b*G,Q=2*q-3*G+1,k=-2*q+3*G,I=q-2*G+b,P=q-G,e=a._x*Q+i._x*k+O._x*I+H._x*P,h=a._y*Q+i._y*k+O._y*I+H._y*P,j=a._z*Q+i._z*k+O._z*I+H._z*P,Z=a._w*Q+i._w*k+O._w*I+H._w*P;return new J(e,h,j,Z)}static Hermite1stDerivative(a,O,i,H,b){const G=new J;return this.Hermite1stDerivativeToRef(a,O,i,H,b,G),G}static Hermite1stDerivativeToRef(a,O,i,H,b,G){const q=b*b;return G._x=6*(q-b)*a._x+(3*q-4*b+1)*O._x+6*(-q+b)*i._x+(3*q-2*b)*H._x,G._y=6*(q-b)*a._y+(3*q-4*b+1)*O._y+6*(-q+b)*i._y+(3*q-2*b)*H._y,G._z=6*(q-b)*a._z+(3*q-4*b+1)*O._z+6*(-q+b)*i._z+(3*q-2*b)*H._z,G._w=6*(q-b)*a._w+(3*q-4*b+1)*O._w+6*(-q+b)*i._w+(3*q-2*b)*H._w,G._isDirty=!0,G}static Normalize(a){const O=J.Zero();return J.NormalizeToRef(a,O),O}static NormalizeToRef(a,O){return a.normalizeToRef(O),O}static Clamp(a,O,i){const H=new J;return J.ClampToRef(a,O,i,H),H}static ClampToRef(a,O,i,H){return H.fb((0,k.Clamp)(a.x,O.x,i.x),(0,k.Clamp)(a.y,O.y,i.y),(0,k.Clamp)(a.z,O.z,i.z),(0,k.Clamp)(a.w,O.w,i.w))}static Random(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new J((0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O))}static RandomToRef(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fb((0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O),(0,k.RandomRange)(a,O))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(a,O){return Math.sqrt(J.DistanceSquared(a,O))}static DistanceSquared(a,O){const i=a.x-O.x,H=a.y-O.y,b=a.z-O.z,G=a.w-O.w;return i*i+H*H+b*b+G*G}static Center(a,O){return J.CenterToRef(a,O,J.Zero())}static CenterToRef(a,O,i){return i.fb((a.x+O.x)/2,(a.y+O.y)/2,(a.z+O.z)/2,(a.w+O.w)/2)}}J._V8PerformanceHack=new J(.5,.5,.5,.5),Object.defineProperties(J.prototype,{dimension:{value:[4]},rank:{value:1}});class ma{static get Use64Bits(){return q.d.MatrixUse64Bits}get m(){return this.jb}markAsUpdated(){this.updateFlag=I._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(a){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=a,this._isIdentity3x2=a||i,this._isIdentityDirty=!this._isIdentity&&O,this._isIdentity3x2Dirty=!this._isIdentity3x2&&H}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,q.d.MatrixTrackPrecisionChange&&q.d.MatrixTrackedMatrices.push(this),this.jb=new q.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const a=this.jb;this._isIdentity=1===a[0]&&0===a[1]&&0===a[2]&&0===a[3]&&0===a[4]&&1===a[5]&&0===a[6]&&0===a[7]&&0===a[8]&&0===a[9]&&1===a[10]&&0===a[11]&&0===a[12]&&0===a[13]&&0===a[14]&&1===a[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.jb[0]||1!==this.jb[5]||1!==this.jb[15]||0!==this.jb[1]||0!==this.jb[2]||0!==this.jb[3]||0!==this.jb[4]||0!==this.jb[6]||0!==this.jb[7]||0!==this.jb[8]||0!==this.jb[9]||0!==this.jb[10]||0!==this.jb[11]||0!==this.jb[12]||0!==this.jb[13]||0!==this.jb[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const a=this.jb,O=a[0],i=a[1],H=a[2],b=a[3],G=a[4],q=a[5],Q=a[6],k=a[7],I=a[8],P=a[9],e=a[10],h=a[11],j=a[12],Z=a[13],F=a[14],r=a[15],J=e*r-F*h,ma=P*r-Z*h,M=P*F-Z*e,C=I*r-j*h,n=I*F-e*j,D=I*Z-j*P;return O*+(q*J-Q*ma+k*M)+i*-(G*J-Q*C+k*n)+H*+(G*ma-q*C+k*D)+b*-(G*M-q*n+Q*D)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!a)return this.jb;const i=this.jb;for(let H=0;H<16;H++)a[O+H]=i[H];return this}Cb(){return this.jb}hi(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return ma.FromArrayToRef(a,O,this)}fb(){for(var a=arguments.length,O=new Array(a),i=0;i<a;i++)O[i]=arguments[i];return ma.FromArrayToRef(O,0,this)}set(){const a=this.jb;for(let O=0;O<16;O++)a[O]=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}Tb(a){const O=this.jb;for(let i=0;i<16;i++)O[i]=a;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return ma.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(a){const O=new ma;return this.addToRef(a,O),O}addToRef(a,O){const i=this.jb,H=O.jb,b=a.m;for(let G=0;G<16;G++)H[G]=i[G]+b[G];return O.markAsUpdated(),O}addToSelf(a){const O=this.jb,i=a.m;return O[0]+=i[0],O[1]+=i[1],O[2]+=i[2],O[3]+=i[3],O[4]+=i[4],O[5]+=i[5],O[6]+=i[6],O[7]+=i[7],O[8]+=i[8],O[9]+=i[9],O[10]+=i[10],O[11]+=i[11],O[12]+=i[12],O[13]+=i[13],O[14]+=i[14],O[15]+=i[15],this.markAsUpdated(),this}addInPlace(a){const O=this.jb,i=a.m;for(let H=0;H<16;H++)O[H]+=i[H];return this.markAsUpdated(),this}addInPlaceFromFloats(){const a=this.jb;for(let O=0;O<16;O++)a[O]+=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}FO(a){const O=this.jb,i=a.m;for(let H=0;H<16;H++)O[H]-=i[H];return this.markAsUpdated(),this}subtractToRef(a,O){const i=this.jb,H=a.m,b=O.jb;for(let G=0;G<16;G++)b[G]=i[G]-H[G];return O.markAsUpdated(),O}ne(a){const O=this.jb,i=a.m;for(let H=0;H<16;H++)O[H]-=i[H];return this.markAsUpdated(),this}subtractFromFloats(){for(var a=arguments.length,O=new Array(a),i=0;i<a;i++)O[i]=arguments[i];return this.subtractFromFloatsToRef(...O,new ma)}subtractFromFloatsToRef(){for(var a=arguments.length,O=new Array(a),i=0;i<a;i++)O[i]=arguments[i];const H=O.pop(),b=this.jb,G=H.jb,q=O;for(let Q=0;Q<16;Q++)G[Q]=b[Q]-q[Q];return H.markAsUpdated(),H}invertToRef(a){return!0===this._isIdentity?(ma.IdentityToRef(a),a):(h(this,a.Cb())?a.markAsUpdated():a.q(this),a)}addAtIndex(a,O){return this.jb[a]+=O,this.markAsUpdated(),this}multiplyAtIndex(a,O){return this.jb[a]*=O,this.markAsUpdated(),this}setTranslationFromFloats(a,O,i){return this.jb[12]=a,this.jb[13]=O,this.jb[14]=i,this.markAsUpdated(),this}addTranslationFromFloats(a,O,i){return this.jb[12]+=a,this.jb[13]+=O,this.jb[14]+=i,this.markAsUpdated(),this}setTranslation(a){return this.setTranslationFromFloats(a._x,a._y,a._z)}getTranslation(){return new F(this.jb[12],this.jb[13],this.jb[14])}getTranslationToRef(a){return a.x=this.jb[12],a.y=this.jb[13],a.z=this.jb[14],a}removeRotationAndScaling(){const a=this.m;return ma.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,a[12],a[13],a[14],a[15],this),this._updateIdentityStatus(0===a[12]&&0===a[13]&&0===a[14]&&1===a[15]),this}q(a){a.copyToArray(this.jb);const O=a;return this.updateFlag=O.updateFlag,this._updateIdentityStatus(O._isIdentity,O._isIdentityDirty,O._isIdentity3x2,O._isIdentity3x2Dirty),this}copyToArray(a){return e(this,a,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(a){const O=new ma;return this.multiplyToRef(a,O),O}multiplyInPlace(a){const O=this.jb,i=a.m;for(let H=0;H<16;H++)O[H]*=i[H];return this.markAsUpdated(),this}multiplyByFloats(){const a=this.jb;for(let O=0;O<16;O++)a[O]*=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var a=arguments.length,O=new Array(a),i=0;i<a;i++)O[i]=arguments[i];const H=O.pop(),b=this.jb,G=H.jb,q=O;for(let Q=0;Q<16;Q++)G[Q]=b[Q]*q[Q];return H.markAsUpdated(),H}multiplyToRef(a,O){return this._isIdentity?(O.q(a),O):a._isIdentity?(O.q(this),O):(this.multiplyToArray(a,O.jb,0),O.markAsUpdated(),O)}multiplyToArray(a,O,i){return P(this,a,O,i),this}divide(a){return this.divideToRef(a,new ma)}divideToRef(a,O){const i=this.jb,H=a.m,b=O.jb;for(let G=0;G<16;G++)b[G]=i[G]/H[G];return O.markAsUpdated(),O}divideInPlace(a){const O=this.jb,i=a.m;for(let H=0;H<16;H++)O[H]/=i[H];return this.markAsUpdated(),this}minimizeInPlace(a){const O=this.jb,i=a.m;for(let H=0;H<16;H++)O[H]=Math.min(O[H],i[H]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const a=this.jb;for(let O=0;O<16;O++)a[O]=Math.min(a[O],O<0||arguments.length<=O?void 0:arguments[O]);return this.markAsUpdated(),this}maximizeInPlace(a){const O=this.jb,i=a.m;for(let H=0;H<16;H++)O[H]=Math.min(O[H],i[H]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const a=this.jb;for(let O=0;O<16;O++)a[O]=Math.min(a[O],O<0||arguments.length<=O?void 0:arguments[O]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new ma)}negateInPlace(){const a=this.jb;for(let O=0;O<16;O++)a[O]=-a[O];return this.markAsUpdated(),this}negateToRef(a){const O=this.jb,i=a.jb;for(let H=0;H<16;H++)i[H]=-O[H];return a.markAsUpdated(),a}equals(a){const O=a;if(!O)return!1;if((this._isIdentity||O._isIdentity)&&!this._isIdentityDirty&&!O._isIdentityDirty)return this._isIdentity&&O._isIdentity;const i=this.m,H=O.m;return i[0]===H[0]&&i[1]===H[1]&&i[2]===H[2]&&i[3]===H[3]&&i[4]===H[4]&&i[5]===H[5]&&i[6]===H[6]&&i[7]===H[7]&&i[8]===H[8]&&i[9]===H[9]&&i[10]===H[10]&&i[11]===H[11]&&i[12]===H[12]&&i[13]===H[13]&&i[14]===H[14]&&i[15]===H[15]}equalsWithEpsilon(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const i=this.jb,H=a.m;for(let b=0;b<16;b++)if(!(0,k.WithinEpsilon)(i[b],H[b],O))return!1;return!0}equalsToFloats(){const a=this.jb;for(let O=0;O<16;O++)if(a[O]!=(O<0||arguments.length<=O?void 0:arguments[O]))return!1;return!0}floor(){return this.floorToRef(new ma)}floorToRef(a){const O=this.jb,i=a.jb;for(let H=0;H<16;H++)i[H]=Math.floor(O[H]);return a.markAsUpdated(),a}fract(){return this.fractToRef(new ma)}fractToRef(a){const O=this.jb,i=a.jb;for(let H=0;H<16;H++)i[H]=O[H]-Math.floor(O[H]);return a.markAsUpdated(),a}clone(){const a=new ma;return a.q(this),a}getClassName(){return"Matrix"}getHashCode(){let a=j(this.jb[0]);for(let O=1;O<16;O++)a=397*a^j(this.jb[O]);return a}decomposeToTransformNode(a){return a.rotationQuaternion=a.rotationQuaternion||new J,this.decompose(a.Bb,a.rotationQuaternion,a.position)}decompose(a,O,i,H){let b=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return i&&i.Tb(0),a&&a.Tb(1),O&&O.fb(0,0,0,1),!0;const G=this.jb;if(i&&i.fb(G[12],G[13],G[14]),(a=a||M.ZO[0]).x=Math.sqrt(G[0]*G[0]+G[1]*G[1]+G[2]*G[2]),a.y=Math.sqrt(G[4]*G[4]+G[5]*G[5]+G[6]*G[6]),a.z=Math.sqrt(G[8]*G[8]+G[9]*G[9]+G[10]*G[10]),H){const O=(b?H.absoluteScaling.x:H.Bb.x)<0?-1:1,i=(b?H.absoluteScaling.y:H.Bb.y)<0?-1:1,G=(b?H.absoluteScaling.z:H.Bb.z)<0?-1:1;a.x*=O,a.y*=i,a.z*=G}else this.determinant()<=0&&(a.y*=-1);if(0===a._x||0===a._y||0===a._z)return O&&O.fb(0,0,0,1),!1;if(O){const i=1/a._x,H=1/a._y,b=1/a._z;ma.FromValuesToRef(G[0]*i,G[1]*i,G[2]*i,0,G[4]*H,G[5]*H,G[6]*H,0,G[8]*b,G[9]*b,G[10]*b,0,0,0,0,1,M.Matrix[0]),J.FromRotationMatrixToRef(M.Matrix[0],O)}return!0}getRow(a){if(a<0||a>3)return null;const O=4*a;return new r(this.jb[O+0],this.jb[O+1],this.jb[O+2],this.jb[O+3])}getRowToRef(a,O){if(a>=0&&a<=3){const i=4*a;O.x=this.jb[i+0],O.y=this.jb[i+1],O.z=this.jb[i+2],O.w=this.jb[i+3]}return O}setRow(a,O){return this.setRowFromFloats(a,O.x,O.y,O.z,O.w)}transpose(){const a=new ma;return ma.TransposeToRef(this,a),a}transposeToRef(a){return ma.TransposeToRef(this,a),a}setRowFromFloats(a,O,i,H,b){if(a<0||a>3)return this;const G=4*a;return this.jb[G+0]=O,this.jb[G+1]=i,this.jb[G+2]=H,this.jb[G+3]=b,this.markAsUpdated(),this}scale(a){const O=new ma;return this.scaleToRef(a,O),O}scaleToRef(a,O){for(let i=0;i<16;i++)O.jb[i]=this.jb[i]*a;return O.markAsUpdated(),O}scaleAndAddToRef(a,O){for(let i=0;i<16;i++)O.jb[i]+=this.jb[i]*a;return O.markAsUpdated(),O}scaleInPlace(a){const O=this.jb;for(let i=0;i<16;i++)O[i]*=a;return this.markAsUpdated(),this}toNormalMatrix(a){const O=M.Matrix[0];this.invertToRef(O),O.transposeToRef(a);const i=a.jb;return ma.FromValuesToRef(i[0],i[1],i[2],0,i[4],i[5],i[6],0,i[8],i[9],i[10],0,0,0,0,1,a),a}getRotationMatrix(){const a=new ma;return this.getRotationMatrixToRef(a),a}getRotationMatrixToRef(a){const O=M.ZO[0];if(!this.decompose(O))return ma.IdentityToRef(a),a;const i=this.jb,H=1/O._x,b=1/O._y,G=1/O._z;return ma.FromValuesToRef(i[0]*H,i[1]*H,i[2]*H,0,i[4]*b,i[5]*b,i[6]*b,0,i[8]*G,i[9]*G,i[10]*G,0,0,0,0,1,a),a}toggleModelMatrixHandInPlace(){const a=this.jb;return a[2]*=-1,a[6]*=-1,a[8]*=-1,a[9]*=-1,a[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const a=this.jb;return a[8]*=-1,a[9]*=-1,a[10]*=-1,a[11]*=-1,this.markAsUpdated(),this}static MO(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const i=new ma;return ma.FromArrayToRef(a,O,i),i}static FromArrayToRef(a,O,i){for(let H=0;H<16;H++)i.jb[H]=a[H+O];return i.markAsUpdated(),i}static FromFloat32ArrayToRefScaled(a,O,i,H){return H.jb[0]=a[0+O]*i,H.jb[1]=a[1+O]*i,H.jb[2]=a[2+O]*i,H.jb[3]=a[3+O]*i,H.jb[4]=a[4+O]*i,H.jb[5]=a[5+O]*i,H.jb[6]=a[6+O]*i,H.jb[7]=a[7+O]*i,H.jb[8]=a[8+O]*i,H.jb[9]=a[9+O]*i,H.jb[10]=a[10+O]*i,H.jb[11]=a[11+O]*i,H.jb[12]=a[12+O]*i,H.jb[13]=a[13+O]*i,H.jb[14]=a[14+O]*i,H.jb[15]=a[15+O]*i,H.markAsUpdated(),H}static get IdentityReadOnly(){return ma._IdentityReadOnly}static FromValuesToRef(a,O,i,H,b,G,q,Q,k,I,P,e,h,j,Z,F,r){const J=r.jb;J[0]=a,J[1]=O,J[2]=i,J[3]=H,J[4]=b,J[5]=G,J[6]=q,J[7]=Q,J[8]=k,J[9]=I,J[10]=P,J[11]=e,J[12]=h,J[13]=j,J[14]=Z,J[15]=F,r.markAsUpdated()}static FromValues(a,O,i,H,b,G,q,Q,k,I,P,e,h,j,Z,F){const r=new ma,J=r.jb;return J[0]=a,J[1]=O,J[2]=i,J[3]=H,J[4]=b,J[5]=G,J[6]=q,J[7]=Q,J[8]=k,J[9]=I,J[10]=P,J[11]=e,J[12]=h,J[13]=j,J[14]=Z,J[15]=F,r.markAsUpdated(),r}static Compose(a,O,i){const H=new ma;return ma.ComposeToRef(a,O,i,H),H}static ComposeToRef(a,O,i,H){const b=H.jb,G=O._x,q=O._y,Q=O._z,k=O._w,I=G+G,P=q+q,e=Q+Q,h=G*I,j=G*P,Z=G*e,F=q*P,r=q*e,J=Q*e,ma=k*I,M=k*P,C=k*e,n=a._x,D=a._y,U=a._z;return b[0]=(1-(F+J))*n,b[1]=(j+C)*n,b[2]=(Z-M)*n,b[3]=0,b[4]=(j-C)*D,b[5]=(1-(h+J))*D,b[6]=(r+ma)*D,b[7]=0,b[8]=(Z+M)*U,b[9]=(r-ma)*U,b[10]=(1-(h+F))*U,b[11]=0,b[12]=i._x,b[13]=i._y,b[14]=i._z,b[15]=1,H.markAsUpdated(),H}static Identity(){const a=ma.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return a._updateIdentityStatus(!0),a}static IdentityToRef(a){return ma.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,a),a._updateIdentityStatus(!0),a}static Zero(){const a=ma.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return a._updateIdentityStatus(!1),a}static RotationX(a){const O=new ma;return ma.RotationXToRef(a,O),O}static Invert(a){const O=new ma;return a.invertToRef(O),O}static RotationXToRef(a,O){const i=Math.sin(a),H=Math.cos(a);return ma.FromValuesToRef(1,0,0,0,0,H,i,0,0,-i,H,0,0,0,0,1,O),O._updateIdentityStatus(1===H&&0===i),O}static RotationY(a){const O=new ma;return ma.RotationYToRef(a,O),O}static RotationYToRef(a,O){const i=Math.sin(a),H=Math.cos(a);return ma.FromValuesToRef(H,0,-i,0,0,1,0,0,i,0,H,0,0,0,0,1,O),O._updateIdentityStatus(1===H&&0===i),O}static RotationZ(a){const O=new ma;return ma.RotationZToRef(a,O),O}static RotationZToRef(a,O){const i=Math.sin(a),H=Math.cos(a);return ma.FromValuesToRef(H,i,0,0,-i,H,0,0,0,0,1,0,0,0,0,1,O),O._updateIdentityStatus(1===H&&0===i),O}static RotationAxis(a,O){const i=new ma;return ma.RotationAxisToRef(a,O,i),i}static RotationAxisToRef(a,O,i){const H=Math.sin(-O),b=Math.cos(-O),G=1-b;a=a.normalizeToRef(M.ZO[0]);const q=i.jb;return q[0]=a._x*a._x*G+b,q[1]=a._x*a._y*G-a._z*H,q[2]=a._x*a._z*G+a._y*H,q[3]=0,q[4]=a._y*a._x*G+a._z*H,q[5]=a._y*a._y*G+b,q[6]=a._y*a._z*G-a._x*H,q[7]=0,q[8]=a._z*a._x*G-a._y*H,q[9]=a._z*a._y*G+a._x*H,q[10]=a._z*a._z*G+b,q[11]=0,q[12]=0,q[13]=0,q[14]=0,q[15]=1,i.markAsUpdated(),i}static RotationAlignToRef(a,O,i){let b=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const G=F.Dot(O,a),q=i.jb;if(G<-1+H.e)q[0]=-1,q[1]=0,q[2]=0,q[3]=0,q[4]=0,q[5]=b?1:-1,q[6]=0,q[7]=0,q[8]=0,q[9]=0,q[10]=b?-1:1,q[11]=0;else{const i=F.Cross(O,a),H=1/(1+G);q[0]=i._x*i._x*H+G,q[1]=i._y*i._x*H-i._z,q[2]=i._z*i._x*H+i._y,q[3]=0,q[4]=i._x*i._y*H+i._z,q[5]=i._y*i._y*H+G,q[6]=i._z*i._y*H-i._x,q[7]=0,q[8]=i._x*i._z*H-i._y,q[9]=i._y*i._z*H+i._x,q[10]=i._z*i._z*H+G,q[11]=0}return q[12]=0,q[13]=0,q[14]=0,q[15]=1,i.markAsUpdated(),i}static RotationYawPitchRoll(a,O,i){const H=new ma;return ma.RotationYawPitchRollToRef(a,O,i,H),H}static RotationYawPitchRollToRef(a,O,i,H){return J.RotationYawPitchRollToRef(a,O,i,M.Quaternion[0]),M.Quaternion[0].toRotationMatrix(H),H}static Scaling(a,O,i){const H=new ma;return ma.ScalingToRef(a,O,i,H),H}static ScalingToRef(a,O,i,H){return ma.FromValuesToRef(a,0,0,0,0,O,0,0,0,0,i,0,0,0,0,1,H),H._updateIdentityStatus(1===a&&1===O&&1===i),H}static Translation(a,O,i){const H=new ma;return ma.TranslationToRef(a,O,i,H),H}static TranslationToRef(a,O,i,H){return ma.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,a,O,i,1,H),H._updateIdentityStatus(0===a&&0===O&&0===i),H}static Lerp(a,O,i){const H=new ma;return ma.LerpToRef(a,O,i,H),H}static LerpToRef(a,O,i,H){const b=H.jb,G=a.m,q=O.m;for(let Q=0;Q<16;Q++)b[Q]=G[Q]*(1-i)+q[Q]*i;return H.markAsUpdated(),H}static DecomposeLerp(a,O,i){const H=new ma;return ma.DecomposeLerpToRef(a,O,i,H),H}static DecomposeLerpToRef(a,O,i,H){const b=M.ZO[0],G=M.Quaternion[0],q=M.ZO[1];a.decompose(b,G,q);const Q=M.ZO[2],k=M.Quaternion[1],I=M.ZO[3];O.decompose(Q,k,I);const P=M.ZO[4];F.LerpToRef(b,Q,i,P);const e=M.Quaternion[2];J.SlerpToRef(G,k,i,e);const h=M.ZO[5];return F.LerpToRef(q,I,i,h),ma.ComposeToRef(P,e,h,H),H}static LookAtLH(a,O,i){const H=new ma;return ma.LookAtLHToRef(a,O,i,H),H}static LookAtLHToRef(a,O,i,H){const b=M.ZO[0],G=M.ZO[1],q=M.ZO[2];O.subtractToRef(a,q),q.normalize(),F.CrossToRef(i,q,b);const Q=b.lengthSquared();0===Q?b.x=1:b.normalizeFromLength(Math.sqrt(Q)),F.CrossToRef(q,b,G),G.normalize();const k=-F.Dot(b,a),I=-F.Dot(G,a),P=-F.Dot(q,a);return ma.FromValuesToRef(b._x,G._x,q._x,0,b._y,G._y,q._y,0,b._z,G._z,q._z,0,k,I,P,1,H),H}static LookAtRH(a,O,i){const H=new ma;return ma.LookAtRHToRef(a,O,i,H),H}static LookAtRHToRef(a,O,i,H){const b=M.ZO[0],G=M.ZO[1],q=M.ZO[2];a.subtractToRef(O,q),q.normalize(),F.CrossToRef(i,q,b);const Q=b.lengthSquared();0===Q?b.x=1:b.normalizeFromLength(Math.sqrt(Q)),F.CrossToRef(q,b,G),G.normalize();const k=-F.Dot(b,a),I=-F.Dot(G,a),P=-F.Dot(q,a);return ma.FromValuesToRef(b._x,G._x,q._x,0,b._y,G._y,q._y,0,b._z,G._z,q._z,0,k,I,P,1,H),H}static LookDirectionLH(a,O){const i=new ma;return ma.LookDirectionLHToRef(a,O,i),i}static LookDirectionLHToRef(a,O,i){const H=M.ZO[0];H.q(a),H.scaleInPlace(-1);const b=M.ZO[1];return F.CrossToRef(O,H,b),ma.FromValuesToRef(b._x,b._y,b._z,0,O._x,O._y,O._z,0,H._x,H._y,H._z,0,0,0,0,1,i),i}static LookDirectionRH(a,O){const i=new ma;return ma.LookDirectionRHToRef(a,O,i),i}static LookDirectionRHToRef(a,O,i){const H=M.ZO[2];return F.CrossToRef(O,a,H),ma.FromValuesToRef(H._x,H._y,H._z,0,O._x,O._y,O._z,0,a._x,a._y,a._z,0,0,0,0,1,i),i}static OrthoLH(a,O,i,H,b){const G=new ma;return ma.OrthoLHToRef(a,O,i,H,G,b),G}static OrthoLHToRef(a,O,i,H,b,G){const q=2/a,Q=2/O,k=2/(H-i),I=-(H+i)/(H-i);return ma.FromValuesToRef(q,0,0,0,0,Q,0,0,0,0,k,0,0,0,I,1,b),G&&b.multiplyToRef(n,b),b._updateIdentityStatus(1===q&&1===Q&&1===k&&0===I),b}static OrthoOffCenterLH(a,O,i,H,b,G,q){const Q=new ma;return ma.OrthoOffCenterLHToRef(a,O,i,H,b,G,Q,q),Q}static OrthoOffCenterLHToRef(a,O,i,H,b,G,q,Q){const k=2/(O-a),I=2/(H-i),P=2/(G-b),e=-(G+b)/(G-b),h=(a+O)/(a-O),j=(H+i)/(i-H);return ma.FromValuesToRef(k,0,0,0,0,I,0,0,0,0,P,0,h,j,e,1,q),Q&&q.multiplyToRef(n,q),q.markAsUpdated(),q}static ObliqueOffCenterLHToRef(a,O,i,H,b,G,q,Q,k,I,P){const e=-q*Math.cos(Q),h=-q*Math.sin(Q);return ma.TranslationToRef(0,0,-k,M.Matrix[1]),ma.FromValuesToRef(1,0,0,0,0,1,0,0,e,h,1,0,0,0,0,1,M.Matrix[0]),M.Matrix[1].multiplyToRef(M.Matrix[0],M.Matrix[0]),ma.TranslationToRef(0,0,k,M.Matrix[1]),M.Matrix[0].multiplyToRef(M.Matrix[1],M.Matrix[0]),ma.OrthoOffCenterLHToRef(a,O,i,H,b,G,I,P),M.Matrix[0].multiplyToRef(I,I),I}static OrthoOffCenterRH(a,O,i,H,b,G,q){const Q=new ma;return ma.OrthoOffCenterRHToRef(a,O,i,H,b,G,Q,q),Q}static OrthoOffCenterRHToRef(a,O,i,H,b,G,q,Q){return ma.OrthoOffCenterLHToRef(a,O,i,H,b,G,q,Q),q.jb[10]*=-1,q}static ObliqueOffCenterRHToRef(a,O,i,H,b,G,q,Q,k,I,P){const e=q*Math.cos(Q),h=q*Math.sin(Q);return ma.TranslationToRef(0,0,k,M.Matrix[1]),ma.FromValuesToRef(1,0,0,0,0,1,0,0,e,h,1,0,0,0,0,1,M.Matrix[0]),M.Matrix[1].multiplyToRef(M.Matrix[0],M.Matrix[0]),ma.TranslationToRef(0,0,-k,M.Matrix[1]),M.Matrix[0].multiplyToRef(M.Matrix[1],M.Matrix[0]),ma.OrthoOffCenterRHToRef(a,O,i,H,b,G,I,P),M.Matrix[0].multiplyToRef(I,I),I}static PerspectiveLH(a,O,i,H,b){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const q=new ma,Q=2*i/a,k=2*i/O,I=(H+i)/(H-i),P=-2*H*i/(H-i),e=Math.tan(G);return ma.FromValuesToRef(Q,0,0,0,0,k,0,e,0,0,I,1,0,0,P,0,q),b&&q.multiplyToRef(n,q),q._updateIdentityStatus(!1),q}static PerspectiveFovLH(a,O,i,H,b){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const Q=new ma;return ma.PerspectiveFovLHToRef(a,O,i,H,Q,!0,b,G,q),Q}static PerspectiveFovLHToRef(a,O,i,H,b){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,Q=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,k=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const I=i,P=H,e=1/Math.tan(.5*a),h=G?e/O:e,j=G?e:e*O,Z=k&&0===I?-1:0!==P?(P+I)/(P-I):1,F=k&&0===I?2*P:0!==P?-2*P*I/(P-I):-2*I,r=Math.tan(Q);return ma.FromValuesToRef(h,0,0,0,0,j,0,r,0,0,Z,1,0,0,F,0,b),q&&b.multiplyToRef(n,b),b._updateIdentityStatus(!1),b}static PerspectiveFovReverseLHToRef(a,O,i,H,b){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,Q=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const k=1/Math.tan(.5*a),I=G?k/O:k,P=G?k:k*O,e=Math.tan(Q);return ma.FromValuesToRef(I,0,0,0,0,P,0,e,0,0,-i,1,0,0,1,0,b),q&&b.multiplyToRef(n,b),b._updateIdentityStatus(!1),b}static PerspectiveFovRH(a,O,i,H,b){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const Q=new ma;return ma.PerspectiveFovRHToRef(a,O,i,H,Q,!0,b,G,q),Q}static PerspectiveFovRHToRef(a,O,i,H,b){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,Q=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,k=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const I=i,P=H,e=1/Math.tan(.5*a),h=G?e/O:e,j=G?e:e*O,Z=k&&0===I?1:0!==P?-(P+I)/(P-I):-1,F=k&&0===I?2*P:0!==P?-2*P*I/(P-I):-2*I,r=Math.tan(Q);return ma.FromValuesToRef(h,0,0,0,0,j,0,r,0,0,Z,-1,0,0,F,0,b),q&&b.multiplyToRef(n,b),b._updateIdentityStatus(!1),b}static PerspectiveFovReverseRHToRef(a,O,i,H,b){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,Q=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const k=1/Math.tan(.5*a),I=G?k/O:k,P=G?k:k*O,e=Math.tan(Q);return ma.FromValuesToRef(I,0,0,0,0,P,0,e,0,0,-i,-1,0,0,-1,0,b),q&&b.multiplyToRef(n,b),b._updateIdentityStatus(!1),b}static GetFinalMatrix(a,O,i,H,b,G){const q=a.width,Q=a.height,k=a.x,I=a.y,P=ma.FromValues(q/2,0,0,0,0,-Q/2,0,0,0,0,G-b,0,k+q/2,Q/2+I,b,1),e=new ma;return O.multiplyToRef(i,e),e.multiplyToRef(H,e),e.multiplyToRef(P,e)}static GetAsMatrix2x2(a){const O=a.m,i=[O[0],O[1],O[4],O[5]];return q.d.MatrixUse64Bits?i:new Float32Array(i)}static GetAsMatrix3x3(a){const O=a.m,i=[O[0],O[1],O[2],O[4],O[5],O[6],O[8],O[9],O[10]];return q.d.MatrixUse64Bits?i:new Float32Array(i)}static Transpose(a){const O=new ma;return ma.TransposeToRef(a,O),O}static TransposeToRef(a,O){const i=a.m,H=i[0],b=i[4],G=i[8],q=i[12],Q=i[1],k=i[5],I=i[9],P=i[13],e=i[2],h=i[6],j=i[10],Z=i[14],F=i[3],r=i[7],J=i[11],ma=i[15],M=O.jb;return M[0]=H,M[1]=b,M[2]=G,M[3]=q,M[4]=Q,M[5]=k,M[6]=I,M[7]=P,M[8]=e,M[9]=h,M[10]=j,M[11]=Z,M[12]=F,M[13]=r,M[14]=J,M[15]=ma,O.markAsUpdated(),O._updateIdentityStatus(a._isIdentity,a._isIdentityDirty),O}static Reflection(a){const O=new ma;return ma.ReflectionToRef(a,O),O}static ReflectionToRef(a,O){a.normalize();const i=a.normal.x,H=a.normal.y,b=a.normal.z,G=-2*i,q=-2*H,Q=-2*b;return ma.FromValuesToRef(G*i+1,q*i,Q*i,0,G*H,q*H+1,Q*H,0,G*b,q*b,Q*b+1,0,G*a.d,q*a.d,Q*a.d,1,O),O}static FromXYZAxesToRef(a,O,i,H){return ma.FromValuesToRef(a._x,a._y,a._z,0,O._x,O._y,O._z,0,i._x,i._y,i._z,0,0,0,0,1,H),H}static FromQuaternionToRef(a,O){const i=a._x*a._x,H=a._y*a._y,b=a._z*a._z,G=a._x*a._y,q=a._z*a._w,Q=a._z*a._x,k=a._y*a._w,I=a._y*a._z,P=a._x*a._w;return O.jb[0]=1-2*(H+b),O.jb[1]=2*(G+q),O.jb[2]=2*(Q-k),O.jb[3]=0,O.jb[4]=2*(G-q),O.jb[5]=1-2*(b+i),O.jb[6]=2*(I+P),O.jb[7]=0,O.jb[8]=2*(Q+k),O.jb[9]=2*(I-P),O.jb[10]=1-2*(H+i),O.jb[11]=0,O.jb[12]=0,O.jb[13]=0,O.jb[14]=0,O.jb[15]=1,O.markAsUpdated(),O}}ma._IdentityReadOnly=ma.Identity(),Object.defineProperties(ma.prototype,{dimension:{value:[4,4]},rank:{value:2}});class M{}M.ZO=(0,b.f)(11,F.Zero),M.Matrix=(0,b.f)(2,ma.Identity),M.Quaternion=(0,b.f)(3,J.Zero);class C{}C.Vector2=(0,b.f)(3,Z.Zero),C.ZO=(0,b.f)(13,F.Zero),C.Vector4=(0,b.f)(3,r.Zero),C.Quaternion=(0,b.f)(3,J.Zero),C.Matrix=(0,b.f)(8,ma.Identity),(0,G.h)("BABYLON.Vector2",Z),(0,G.h)("BABYLON.Vector3",F),(0,G.h)("BABYLON.Vector4",r),(0,G.h)("BABYLON.Matrix",ma);const n=ma.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12403:(a,O,i)=>{function H(a,O){const i=[];for(let H=0;H<a;++H)i.push(O());return i}function b(a,O){return H(a,O)}i.d(O,{e:()=>H,f:()=>b,j:()=>q});const G=["push","splice","pop","shift","unshift"];function q(a,O){const i=G.map((i=>function(a,O,i){const H=a[O];if("function"!==typeof H)return null;const b=function(){const H=a.length,G=b.previous.apply(a,arguments);return i(O,H),G};return H.next=b,b.previous=H,a[O]=b,()=>{const i=b.previous;if(!i)return;const H=b.next;H?(i.next=H,H.previous=i):(i.next=void 0,a[O]=i),b.next=void 0,b.previous=void 0}}(a,i,O)));return()=>{for(const a of i)null===a||void 0===a||a()}}}}]);