"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{2467:(K,Y,l)=>{l.r(Y),l.d(Y,{_ExrTextureLoader:()=>j});var v=l(492),U=l(695);const d=65536,A=14,c=65537,t=16384;var Z,m;!function(K){K[K.NO_COMPRESSION=0]="NO_COMPRESSION",K[K.RLE_COMPRESSION=1]="RLE_COMPRESSION",K[K.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",K[K.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",K[K.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",K[K.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(Z||(Z={})),function(K){K[K.INCREASING_Y=0]="INCREASING_Y",K[K.DECREASING_Y=1]="DECREASING_Y"}(m||(m={}));const V=function(){const K=new ArrayBuffer(4),Y=new Float32Array(K),l=new Uint32Array(K),v=new Uint32Array(512),U=new Uint32Array(512);for(let t=0;t<256;++t){const K=t-127;K<-27?(v[t]=0,v[256|t]=32768,U[t]=24,U[256|t]=24):K<-14?(v[t]=1024>>-K-14,v[256|t]=1024>>-K-14|32768,U[t]=-K-1,U[256|t]=-K-1):K<=15?(v[t]=K+15<<10,v[256|t]=K+15<<10|32768,U[t]=13,U[256|t]=13):K<128?(v[t]=31744,v[256|t]=64512,U[t]=24,U[256|t]=24):(v[t]=31744,v[256|t]=64512,U[t]=13,U[256|t]=13)}const d=new Uint32Array(2048),A=new Uint32Array(64),c=new Uint32Array(64);for(let t=1;t<1024;++t){let K=t<<13,Y=0;for(;0===(8388608&K);)K<<=1,Y-=8388608;K&=-8388609,Y+=947912704,d[t]=K|Y}for(let t=1024;t<2048;++t)d[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)A[t]=t<<23;A[31]=1199570944,A[32]=2147483648;for(let t=33;t<63;++t)A[t]=2147483648+(t-32<<23);A[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(c[t]=1024);return{floatView:Y,uint32View:l,baseTable:v,shiftTable:U,mantissaTable:d,exponentTable:A,offsetTable:c}}();function M(K,Y){const l=new Uint8Array(K);let v=0;for(;0!=l[Y.value+v];)v+=1;const U=(new TextDecoder).decode(l.slice(Y.value,Y.value+v));return Y.value=Y.value+v+1,U}function u(K,Y){const l=K.getInt32(Y.value,!0);return Y.value+=4,l}function o(K,Y){const l=K.getUint32(Y.value,!0);return Y.value+=4,l}function W(K,Y){const l=K.getUint8(Y.value);return Y.value+=1,l}function g(K,Y){const l=K.getUint16(Y.value,!0);return Y.value+=2,l}function J(K,Y){const l=K[Y.value];return Y.value+=1,l}function n(K,Y){let l;return l="getBigInt64"in DataView.prototype?Number(K.getBigInt64(Y.value,!0)):K.getUint32(Y.value+4,!0)+Number(K.getUint32(Y.value,!0)<<32),Y.value+=8,l}function R(K,Y){const l=K.getFloat32(Y.value,!0);return Y.value+=4,l}function H(K,Y){return function(K){const Y=(31744&K)>>10,l=1023&K;return(K>>15?-1:1)*(Y?31===Y?l?NaN:1/0:Math.pow(2,Y-15)*(1+l/1024):l/1024*6103515625e-14)}(g(K,Y))}function z(K,Y){return function(K){if(Math.abs(K)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");K=(0,U.d)(K,-65504,65504),V.floatView[0]=K;const Y=V.uint32View[0],l=Y>>23&511;return V.baseTable[l]+((8388607&Y)>>V.shiftTable[l])}(R(K,Y))}function r(K,Y,l,v){switch(l){case"string":case"stringvector":case"iccProfile":return function(K,Y,l){const v=(new TextDecoder).decode(new Uint8Array(K).slice(Y.value,Y.value+l));return Y.value=Y.value+l,v}(K.buffer,Y,v);case"chlist":return function(K,Y,l){const v=Y.value,U=[];for(;Y.value<v+l-1;){const l=M(K.buffer,Y),v=u(K,Y),d=W(K,Y);Y.value+=3;const A=u(K,Y),c=u(K,Y);U.push({name:l,pixelType:v,pLinear:d,xSampling:A,ySampling:c})}return Y.value+=1,U}(K,Y,v);case"chromaticities":return function(K,Y){return{redX:R(K,Y),redY:R(K,Y),greenX:R(K,Y),greenY:R(K,Y),blueX:R(K,Y),blueY:R(K,Y),whiteX:R(K,Y),whiteY:R(K,Y)}}(K,Y);case"compression":return function(K,Y){return W(K,Y)}(K,Y);case"box2i":return function(K,Y){return{xMin:u(K,Y),yMin:u(K,Y),xMax:u(K,Y),yMax:u(K,Y)}}(K,Y);case"lineOrder":return function(K,Y){const l=W(K,Y);return m[l]}(K,Y);case"float":return R(K,Y);case"v2f":return function(K,Y){return[R(K,Y),R(K,Y)]}(K,Y);case"v3f":return function(K,Y){return[R(K,Y),R(K,Y),R(K,Y)]}(K,Y);case"int":return u(K,Y);case"rational":return function(K,Y){return[u(K,Y),o(K,Y)]}(K,Y);case"timecode":return function(K,Y){return[o(K,Y),o(K,Y)]}(K,Y);case"preview":return Y.value+=v,"skipped";default:return void(Y.value+=v)}}function E(K){for(let Y=1;Y<K.length;Y++){const l=K[Y-1]+K[Y]-128;K[Y]=l}}function y(K,Y){let l=0,v=Math.floor((K.length+1)/2),U=0;const d=K.length-1;for(;!(U>d)&&(Y[U++]=K[l++],!(U>d));)Y[U++]=K[v++]}function T(K,Y,l,v,U){for(;l<K;)Y=Y<<8|J(v,U),l+=8;return{l:Y>>(l-=K)&(1<<K)-1,c:Y,lc:l}}function e(K,Y,l,v){return{c:K=K<<8|J(l,v),lc:Y+=8}}function i(K,Y,l,v,U,d,A,c,t){if(K==Y){if(v<8){const K=e(l,v,U,d);l=K.c,v=K.lc}let K=l>>(v-=8);if(K=new Uint8Array([K])[0],c.value+K>t)return null;const Y=A[c.value-1];for(;K-- >0;)A[c.value++]=Y}else{if(!(c.value<t))return null;A[c.value++]=K}return{c:l,lc:v}}const D=new Array(59);function B(K,Y,l,v,U,d){const A=Y;let t=0,Z=0;for(;v<=U;v++){if(A.value-Y.value>l)return;let c=T(6,t,Z,K,A);const m=c.l;if(t=c.c,Z=c.lc,d[v]=m,63==m){if(A.value-Y.value>l)throw new Error("Error in HufUnpackEncTable");c=T(8,t,Z,K,A);let m=c.l+6;if(t=c.c,Z=c.lc,v+m>U+1)throw new Error("Error in HufUnpackEncTable");for(;m--;)d[v++]=0;v--}else if(m>=59){let K=m-59+2;if(v+K>U+1)throw new Error("Error in HufUnpackEncTable");for(;K--;)d[v++]=0;v--}}!function(K){for(let l=0;l<=58;++l)D[l]=0;for(let l=0;l<c;++l)D[K[l]]+=1;let Y=0;for(let l=58;l>0;--l){const K=Y+D[l]>>1;D[l]=Y,Y=K}for(let l=0;l<c;++l){const Y=K[l];Y>0&&(K[l]=Y|D[Y]++<<6)}}(d)}function P(K){return 63&K}function G(K){return K>>6}function Q(K,Y,l,v,U,d){const Z=l.value,m=o(Y,l),V=o(Y,l);l.value+=4;const M=o(Y,l);if(l.value+=4,m<0||m>=c||V<0||V>=c)throw new Error("Wrong HUF_ENCSIZE");const u=new Array(c),W=new Array(t);!function(K){for(let Y=0;Y<t;Y++)K[Y]={},K[Y].len=0,K[Y].lit=0,K[Y].p=null}(W);if(B(K,l,v-(l.value-Z),m,V,u),M>8*(v-(l.value-Z)))throw new Error("Wrong hufUncompress");!function(K,Y,l,v){for(;Y<=l;Y++){const l=G(K[Y]),U=P(K[Y]);if(l>>U)throw new Error("Invalid table entry");if(U>A){const K=v[l>>U-A];if(K.len)throw new Error("Invalid table entry");if(K.lit++,K.p){const Y=K.p;K.p=new Array(K.lit);for(let l=0;l<K.lit-1;++l)K.p[l]=Y[l]}else K.p=new Array(1);K.p[K.lit-1]=Y}else if(U){let K=0;for(let d=1<<A-U;d>0;d--){const d=v[(l<<A-U)+K];if(d.len||d.p)throw new Error("Invalid table entry");d.len=U,d.lit=Y,K++}}}}(u,m,V,W),function(K,Y,l,v,U,d,c,t,Z){let m=0,V=0;const M=c,u=Math.trunc(v.value+(U+7)/8);for(;v.value<u;){let U=e(m,V,l,v);for(m=U.c,V=U.lc;V>=A;){const c=Y[m>>V-A&16383];if(c.len){V-=c.len;const K=i(c.lit,d,m,V,l,v,t,Z,M);K&&(m=K.c,V=K.lc)}else{if(!c.p)throw new Error("hufDecode issues");let Y;for(Y=0;Y<c.lit;Y++){const A=P(K[c.p[Y]]);for(;V<A&&v.value<u;)U=e(m,V,l,v),m=U.c,V=U.lc;if(V>=A&&G(K[c.p[Y]])==(m>>V-A&(1<<A)-1)){V-=A;const K=i(c.p[Y],d,m,V,l,v,t,Z,M);K&&(m=K.c,V=K.lc);break}}if(Y==c.lit)throw new Error("HufDecode issues")}}}const o=8-U&7;for(m>>=o,V-=o;V>0;){const K=Y[m<<A-V&16383];if(!K.len)throw new Error("HufDecode issues");{V-=K.len;const Y=i(K.lit,d,m,V,l,v,t,Z,M);Y&&(m=Y.c,V=Y.lc)}}}(u,W,K,l,M,V,d,U,{value:0})}function X(K){return 65535&K}function f(K){const Y=X(K);return Y>32767?Y-65536:Y}function w(K,Y){const l=f(K),v=f(Y),U=l+(1&v)+(v>>1);return{a:U,b:U-v}}function k(K,Y){const l=X(K),v=X(Y),U=l-(v>>1)&65535;return{a:v+U-32768&65535,b:U}}function I(K,Y,l,v,U,d,A){const c=A<16384,t=l>U?U:l;let Z,m,V=1;for(;V<=t;)V<<=1;for(V>>=1,Z=V,V>>=1;V>=1;){m=0;const A=m+d*(U-Z),t=d*V,M=d*Z,u=v*V,o=v*Z;let W,g,J,n;for(;m<=A;m+=M){let U=m;const d=m+v*(l-Z);for(;U<=d;U+=o){const l=U+u,v=U+t,d=v+u;if(c){let A=w(K[U+Y],K[v+Y]);W=A.a,J=A.b,A=w(K[l+Y],K[d+Y]),g=A.a,n=A.b,A=w(W,g),K[U+Y]=A.a,K[l+Y]=A.b,A=w(J,n),K[v+Y]=A.a,K[d+Y]=A.b}else{let A=k(K[U+Y],K[v+Y]);W=A.a,J=A.b,A=k(K[l+Y],K[d+Y]),g=A.a,n=A.b,A=k(W,g),K[U+Y]=A.a,K[l+Y]=A.b,A=k(J,n),K[v+Y]=A.a,K[d+Y]=A.b}}if(l&V){const l=U+t;let v;v=c?w(K[U+Y],K[l+Y]):k(K[U+Y],K[l+Y]),W=v.a,K[l+Y]=v.b,K[U+Y]=W}}if(U&V){let U=m;const d=m+v*(l-Z);for(;U<=d;U+=o){const l=U+u;let v;v=c?w(K[U+Y],K[l+Y]):k(K[U+Y],K[l+Y]),W=v.a,K[l+Y]=v.b,K[U+Y]=W}}Z=V,V>>=1}return m}function L(K){return new DataView(K.array.buffer,K.offset.value,K.size)}function a(K){const Y=K.viewer.buffer.slice(K.offset.value,K.offset.value+K.size),l=new Uint8Array(function(K){let Y=K.byteLength;const l=new Array;let v=0;const U=new DataView(K);for(;Y>0;){const K=U.getInt8(v++);if(K<0){const d=-K;Y-=d+1;for(let K=0;K<d;K++)l.push(U.getUint8(v++))}else{const d=K;Y-=2;const A=U.getUint8(v++);for(let K=0;K<d+1;K++)l.push(A)}}return l}(Y)),v=new Uint8Array(l.length);return E(l),y(l,v),new DataView(v.buffer)}function F(K){const Y=K.array.slice(K.offset.value,K.offset.value+K.size),l=fflate.unzlibSync(Y),v=new Uint8Array(l.length);return E(l),y(l,v),new DataView(v.buffer)}function s(K){const Y=K.array.slice(K.offset.value,K.offset.value+K.size),l=fflate.unzlibSync(Y),v=K.lines*K.channels*K.width,U=1==K.type?new Uint16Array(v):new Uint32Array(v);let d=0,A=0;const c=new Array(4);for(let t=0;t<K.lines;t++)for(let Y=0;Y<K.channels;Y++){let Y=0;switch(K.type){case 1:c[0]=d,c[1]=c[0]+K.width,d=c[1]+K.width;for(let v=0;v<K.width;++v){Y+=l[c[0]++]<<8|l[c[1]++],U[A]=Y,A++}break;case 2:c[0]=d,c[1]=c[0]+K.width,c[2]=c[1]+K.width,d=c[2]+K.width;for(let v=0;v<K.width;++v){Y+=l[c[0]++]<<24|l[c[1]++]<<16|l[c[2]++]<<8,U[A]=Y,A++}}}return new DataView(U.buffer)}function b(K){const Y=K.viewer,l={value:K.offset.value},v=new Uint16Array(K.width*K.scanlineBlockSize*(K.channels*K.type)),U=new Uint8Array(8192);let A=0;const c=new Array(K.channels);for(let d=0;d<K.channels;d++)c[d]={},c[d].start=A,c[d].end=c[d].start,c[d].nx=K.width,c[d].ny=K.lines,c[d].size=K.type,A+=c[d].nx*c[d].ny*c[d].size;const t=g(Y,l),Z=g(Y,l);if(Z>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(t<=Z)for(let d=0;d<Z-t+1;d++)U[d+t]=W(Y,l);const m=new Uint16Array(d),V=function(K,Y){let l=0;for(let U=0;U<d;++U)(0==U||K[U>>3]&1<<(7&U))&&(Y[l++]=U);const v=l-1;for(;l<d;)Y[l++]=0;return v}(U,m),M=o(Y,l);Q(K.array,Y,l,M,v,A);for(let d=0;d<K.channels;++d){const K=c[d];for(let Y=0;Y<c[d].size;++Y)I(v,K.start+Y,K.nx,K.size,K.ny,K.nx*K.size,V)}!function(K,Y,l){for(let v=0;v<l;++v)Y[v]=K[Y[v]]}(m,v,A);let u=0;const J=new Uint8Array(v.buffer.byteLength);for(let d=0;d<K.lines;d++)for(let Y=0;Y<K.channels;Y++){const K=c[Y],l=K.nx*K.size,U=new Uint8Array(v.buffer,2*K.end,2*l);J.set(U,u),u+=2*l,K.end+=l}return new DataView(J.buffer)}var x,C=l(475);!function(K){K[K.Float=0]="Float",K[K.HalfFloat=1]="HalfFloat"}(x||(x={}));class N{}N.DefaultOutputType=x.HalfFloat,N.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class j{constructor(){this.supportCascades=!1}loadCubeData(K,Y,l,v,U){throw".exr not supported in Cube."}async loadData(K,Y,l){const U=new DataView(K.buffer),d={value:0},A=function(K,Y){if(20000630!=K.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const l=K.getUint8(4),U=K.getUint8(5),d={singleTile:!!(2&U),longName:!!(4&U),deepFormat:!!(8&U),multiPart:!!(16&U)};Y.value=8;const A={};let c=!0;for(;c;){const l=M(K.buffer,Y);if(l){const U=M(K.buffer,Y),d=r(K,Y,U,o(K,Y));void 0===d?v.e.Warn(`Unknown header attribute type ${U}'.`):A[l]=d}else c=!1}if(0!=(-5&U))throw new Error("Unsupported file format");return{version:l,spec:d,...A}}(U,d),c=await async function(K,Y,l,v){const U={size:0,viewer:Y,array:new Uint8Array(Y.buffer),offset:l,width:K.dataWindow.xMax-K.dataWindow.xMin+1,height:K.dataWindow.yMax-K.dataWindow.yMin+1,channels:K.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(K.compression){case Z.NO_COMPRESSION:U.lines=1,U.uncompress=L;break;case Z.RLE_COMPRESSION:U.lines=1,U.uncompress=a;break;case Z.ZIPS_COMPRESSION:U.lines=1,U.uncompress=F,await C.d.LoadScriptAsync(N.FFLATEUrl);break;case Z.ZIP_COMPRESSION:U.lines=16,U.uncompress=F,await C.d.LoadScriptAsync(N.FFLATEUrl);break;case Z.PIZ_COMPRESSION:U.lines=32,U.uncompress=b;break;case Z.PXR24_COMPRESSION:U.lines=16,U.uncompress=s,await C.d.LoadScriptAsync(N.FFLATEUrl);break;default:throw new Error(Z[K.compression]+" is unsupported")}U.scanlineBlockSize=U.lines;const d={};for(const Z of K.channels)switch(Z.name){case"Y":case"R":case"G":case"B":case"A":d[Z.name]=!0,U.type=Z.pixelType}let A=!1;if(d.R&&d.G&&d.B)A=!d.A,U.outputChannels=4,U.decodeChannels={R:0,G:1,B:2,A:3};else{if(!d.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");U.outputChannels=1,U.decodeChannels={Y:0}}if(1===U.type)switch(v){case x.Float:U.getter=H,U.inputSize=2;break;case x.HalfFloat:U.getter=g,U.inputSize=2}else{if(2!==U.type)throw new Error("Unsupported pixelType "+U.type+" for "+K.compression);switch(v){case x.Float:U.getter=R,U.inputSize=4;break;case x.HalfFloat:U.getter=z,U.inputSize=4}}U.blockCount=U.height/U.scanlineBlockSize;for(let Z=0;Z<U.blockCount;Z++)n(Y,l);const c=U.width*U.height*U.outputChannels;switch(v){case x.Float:U.byteArray=new Float32Array(c),U.textureType=1,A&&U.byteArray.fill(1,0,c);break;case x.HalfFloat:U.byteArray=new Uint16Array(c),U.textureType=2,A&&U.byteArray.fill(15360,0,c);break;default:throw new Error("Unsupported type: "+v)}let t=0;for(const Z of K.channels)void 0!==U.decodeChannels[Z.name]&&(U.channelLineOffsets[Z.name]=t*U.width),t+=2*Z.pixelType;return U.bytesPerLine=U.width*t,U.outLineWidth=U.width*U.outputChannels,"INCREASING_Y"===K.lineOrder?U.scanOrder=K=>K:U.scanOrder=K=>U.height-1-K,4==U.outputChannels?(U.format=5,U.linearSpace=!0):(U.format=6,U.linearSpace=!1),U}(A,U,d,N.DefaultOutputType);!function(K,Y,l,v){const U={value:0};for(let d=0;d<K.height/K.scanlineBlockSize;d++){const A=u(l,v)-Y.dataWindow.yMin;K.size=o(l,v),K.lines=A+K.scanlineBlockSize>K.height?K.height-A:K.scanlineBlockSize;const c=K.size<K.lines*K.bytesPerLine&&K.uncompress?K.uncompress(K):L(K);v.value+=K.size;for(let l=0;l<K.scanlineBlockSize;l++){const v=d*K.scanlineBlockSize,A=l+K.scanOrder(v);if(A>=K.height)continue;const t=l*K.bytesPerLine,Z=(K.height-1-A)*K.outLineWidth;for(let l=0;l<K.channels;l++){const v=Y.channels[l].name,d=K.channelLineOffsets[v],A=K.decodeChannels[v];if(void 0!==A){U.value=t+d;for(let Y=0;Y<K.width;Y++){const l=Z+Y*K.outputChannels+A;K.byteArray&&(K.byteArray[l]=K.getter(c,U))}}}}}}(c,A,U,d);l(A.dataWindow.xMax-A.dataWindow.xMin+1,A.dataWindow.yMax-A.dataWindow.yMin+1,Y.generateMipMaps,!1,(()=>{const K=Y.getEngine();Y.format=A.format,Y.type=c.textureType,Y.invertY=!1,Y._gammaSpace=!A.linearSpace,c.byteArray&&K._uploadDataToTextureDirectly(Y,c.byteArray,0,0,void 0,!0)}))}}}}]);