"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[14],{11648:(F,P,f)=>{f.d(P,{e:()=>H,i:()=>q,j:()=>c,l:()=>N});const c=1/2.2,N=2.2,q=(1+Math.sqrt(5))/2,H=.001},11664:(F,P,f)=>{function c(F){return parseInt(F.toString().replace(/\W/g,""))}function N(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(F-P)<=f}function q(F,P,f){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return F<P-c||F>f+c}function H(F,P){return F===P?F:Math.random()*(P-F)+F}function A(F,P,f){return F+(P-F)*f}function o(F,P,f){let c=L(P-F,360);return c>180&&(c-=360),F+c*T(f)}function j(F,P,f){let c=0;return c=F!=P?T((f-F)/(P-F)):0,c}function i(F,P,f,c,N){const q=N*N,H=N*q;return F*(2*H-3*q+1)+f*(-2*H+3*q)+P*(H-2*q+N)+c*(H-q)}function u(F,P,f,c,N){const q=N*N;return 6*(q-N)*F+(3*q-4*N+1)*P+6*(-q+N)*f+(3*q-2*N)*c}function T(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(f,Math.max(P,F))}function Y(F){return F-=2*Math.PI*Math.floor((F+Math.PI)/(2*Math.PI))}function t(F){const P=F.toString(16);return F<=15?("0"+P).toUpperCase():P.toUpperCase()}function C(F){if(Math.log2)return Math.floor(Math.log2(F));if(F<0)return NaN;if(0===F)return-1/0;let P=0;if(F<1){for(;F<1;)P++,F*=2;P=-P}else if(F>1)for(;F>1;)P++,F=Math.floor(F/2);return P}function L(F,P){return F-Math.floor(F/P)*P}function J(F,P,f){return(F-P)/(f-P)}function B(F,P,f){return F*(f-P)+P}function z(F,P){let f=L(P-F,360);return f>180&&(f-=360),f}function Z(F,P){const f=L(F,2*P);return P-Math.abs(f-P)}function R(F,P,f){let c=T(f);return c=-2*c*c*c+3*c*c,P*c+F*(1-c)}function y(F,P,f){let c=0;return c=Math.abs(P-F)<=f?P:F+Math.sign(P-F)*f,c}function O(F,P,f){const c=z(F,P);let N=0;return N=-f<c&&c<f?P:y(F,P=F+c,f),N}function d(F,P,f){return(F-P)/(f-P)}function M(F,P,f){return(f-P)*F+P}function V(F,P){const f=F%P;return 0===f?P:V(P,f)}f.r(P),f.d(P,{Clamp:()=>T,DeltaAngle:()=>z,Denormalize:()=>B,ExtractAsInt:()=>c,Hermite:()=>i,Hermite1stDerivative:()=>u,HighestCommonFactor:()=>V,ILog2:()=>C,InverseLerp:()=>j,Lerp:()=>A,LerpAngle:()=>o,MoveTowards:()=>y,MoveTowardsAngle:()=>O,Normalize:()=>J,NormalizeRadians:()=>Y,OutsideRange:()=>q,PercentToRange:()=>M,PingPong:()=>Z,RandomRange:()=>H,RangeToPercent:()=>d,Repeat:()=>L,SmoothStep:()=>R,ToHex:()=>t,WithinEpsilon:()=>N})},11639:(F,P,f)=>{f.r(P),f.d(P,{Matrix:()=>B,Quaternion:()=>J,TmpVectors:()=>Z,Vector2:()=>t,tP:()=>C,Vector4:()=>L});var c=f(11648),N=f(11655),q=f(11587),H=f(11563),A=f(11501),o=f(11664);class j{}function i(F,P,f){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const N=F.pf(),q=P.pf(),H=N[0],A=N[1],o=N[2],j=N[3],i=N[4],u=N[5],T=N[6],Y=N[7],t=N[8],C=N[9],L=N[10],J=N[11],B=N[12],z=N[13],Z=N[14],R=N[15],y=q[0],O=q[1],d=q[2],M=q[3],V=q[4],Q=q[5],K=q[6],x=q[7],k=q[8],I=q[9],E=q[10],r=q[11],n=q[12],p=q[13],U=q[14],e=q[15];f[c]=H*y+A*V+o*k+j*n,f[c+1]=H*O+A*Q+o*I+j*p,f[c+2]=H*d+A*K+o*E+j*U,f[c+3]=H*M+A*x+o*r+j*e,f[c+4]=i*y+u*V+T*k+Y*n,f[c+5]=i*O+u*Q+T*I+Y*p,f[c+6]=i*d+u*K+T*E+Y*U,f[c+7]=i*M+u*x+T*r+Y*e,f[c+8]=t*y+C*V+L*k+J*n,f[c+9]=t*O+C*Q+L*I+J*p,f[c+10]=t*d+C*K+L*E+J*U,f[c+11]=t*M+C*x+L*r+J*e,f[c+12]=B*y+z*V+Z*k+R*n,f[c+13]=B*O+z*Q+Z*I+R*p,f[c+14]=B*d+z*K+Z*E+R*U,f[c+15]=B*M+z*x+Z*r+R*e}function u(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const c=F.pf();P[f]=c[0],P[f+1]=c[1],P[f+2]=c[2],P[f+3]=c[3],P[f+4]=c[4],P[f+5]=c[5],P[f+6]=c[6],P[f+7]=c[7],P[f+8]=c[8],P[f+9]=c[9],P[f+10]=c[10],P[f+11]=c[11],P[f+12]=c[12],P[f+13]=c[13],P[f+14]=c[14],P[f+15]=c[15]}function T(F,P){const f=F.pf(),c=f[0],N=f[1],q=f[2],H=f[3],A=f[4],o=f[5],j=f[6],i=f[7],u=f[8],T=f[9],Y=f[10],t=f[11],C=f[12],L=f[13],J=f[14],B=f[15],z=Y*B-J*t,Z=T*B-L*t,R=T*J-L*Y,y=u*B-C*t,O=u*J-Y*C,d=u*L-C*T,M=+(o*z-j*Z+i*R),V=-(A*z-j*y+i*O),Q=+(A*Z-o*y+i*d),K=-(A*R-o*O+j*d),x=c*M+N*V+q*Q+H*K;if(0===x)return!1;const k=1/x,I=j*B-J*i,E=o*B-L*i,r=o*J-L*j,n=A*B-C*i,p=A*J-C*j,U=A*L-C*o,e=j*t-Y*i,D=o*t-T*i,l=o*Y-T*j,W=A*t-u*i,b=A*Y-u*j,v=A*T-u*o,s=-(N*z-q*Z+H*R),X=+(c*z-q*y+H*O),m=-(c*Z-N*y+H*d),a=+(c*R-N*O+q*d),w=+(N*I-q*E+H*r),g=-(c*I-q*n+H*p),G=+(c*E-N*n+H*U),h=-(c*r-N*p+q*U),S=-(N*e-q*D+H*l),FF=+(c*e-q*W+H*b),PF=-(c*D-N*W+H*v),fF=+(c*l-N*b+q*v);return P[0]=M*k,P[1]=s*k,P[2]=w*k,P[3]=S*k,P[4]=V*k,P[5]=X*k,P[6]=g*k,P[7]=FF*k,P[8]=Q*k,P[9]=m*k,P[10]=G*k,P[11]=PF*k,P[12]=K*k,P[13]=a*k,P[14]=h*k,P[15]=fF*k,!0}j._UpdateFlagSeed=0;const Y=F=>parseInt(F.toString().replace(/\W/g,""));class t{constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=F,this.y=P}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let F=Y(this.x);return F=397*F^Y(this.y),F}toArray(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F[P]=this.x,F[P+1]=this.y,this}Zf(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(F,P,this),this}pf(){return[this.x,this.y]}q(F){return this.x=F.x,this.y=F.y,this}fc(F,P){return this.x=F,this.y=P,this}set(F,P){return this.fc(F,P)}Nc(F){return this.fc(F,F)}add(F){return new t(this.x+F.x,this.y+F.y)}addToRef(F,P){return P.x=this.x+F.x,P.y=this.y+F.y,P}addInPlace(F){return this.x+=F.x,this.y+=F.y,this}addInPlaceFromFloats(F,P){return this.x+=F,this.y+=P,this}addVector3(F){return new t(this.x+F.x,this.y+F.y)}CP(F){return new t(this.x-F.x,this.y-F.y)}subtractToRef(F,P){return P.x=this.x-F.x,P.y=this.y-F.y,P}Ou(F){return this.x-=F.x,this.y-=F.y,this}multiplyInPlace(F){return this.x*=F.x,this.y*=F.y,this}multiply(F){return new t(this.x*F.x,this.y*F.y)}multiplyToRef(F,P){return P.x=this.x*F.x,P.y=this.y*F.y,P}multiplyByFloats(F,P){return new t(this.x*F,this.y*P)}divide(F){return new t(this.x/F.x,this.y/F.y)}divideToRef(F,P){return P.x=this.x/F.x,P.y=this.y/F.y,P}divideInPlace(F){return this.x=this.x/F.x,this.y=this.y/F.y,this}minimizeInPlace(F){return this.minimizeInPlaceFromFloats(F.x,F.y)}maximizeInPlace(F){return this.maximizeInPlaceFromFloats(F.x,F.y)}minimizeInPlaceFromFloats(F,P){return this.x=Math.min(F,this.x),this.y=Math.min(P,this.y),this}maximizeInPlaceFromFloats(F,P){return this.x=Math.max(F,this.x),this.y=Math.max(P,this.y),this}subtractFromFloats(F,P){return new t(this.x-F,this.y-P)}subtractFromFloatsToRef(F,P,f){return f.x=this.x-F,f.y=this.y-P,f}negate(){return new t(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(F){return F.x=-this.x,F.y=-this.y,F}scaleInPlace(F){return this.x*=F,this.y*=F,this}scale(F){return new t(this.x*F,this.y*F)}scaleToRef(F,P){return P.x=this.x*F,P.y=this.y*F,P}scaleAndAddToRef(F,P){return P.x+=this.x*F,P.y+=this.y*F,P}equals(F){return F&&this.x===F.x&&this.y===F.y}equalsWithEpsilon(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.e;return F&&(0,o.WithinEpsilon)(this.x,F.x,P)&&(0,o.WithinEpsilon)(this.y,F.y,P)}equalsToFloats(F,P){return this.x===F&&this.y===P}floor(){return new t(Math.floor(this.x),Math.floor(this.y))}floorToRef(F){return F.x=Math.floor(this.x),F.y=Math.floor(this.y),F}fract(){return new t(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(F){return F.x=this.x-Math.floor(this.x),F.y=this.y-Math.floor(this.y),F}rotate(F){return this.rotateToRef(F,new t)}rotateToRef(F,P){const f=Math.cos(F),c=Math.sin(F);return P.x=f*this.x-c*this.y,P.y=c*this.x+f*this.y,P}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(F){return 0===F||1===F?this:this.scaleInPlace(1/F)}normalizeToNew(){const F=new t;return this.normalizeToRef(F),F}normalizeToRef(F){const P=this.length();return 0===P&&(F.x=this.x,F.y=this.y),this.scaleToRef(1/P,F)}clone(){return new t(this.x,this.y)}dot(F){return this.x*F.x+this.y*F.y}static Zero(){return new t(0,0)}static One(){return new t(1,1)}static Random(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new t((0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P))}static RandomToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fc((0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P))}static get ZeroReadOnly(){return t._ZeroReadOnly}static zP(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new t(F[P],F[P+1])}static FromArrayToRef(F,P,f){return f.x=F[P],f.y=F[P+1],f}static FromFloatsToRef(F,P,f){return f.fc(F,P),f}static CatmullRom(F,P,f,c,N){const q=N*N,H=N*q,A=.5*(2*P.x+(-F.x+f.x)*N+(2*F.x-5*P.x+4*f.x-c.x)*q+(-F.x+3*P.x-3*f.x+c.x)*H),o=.5*(2*P.y+(-F.y+f.y)*N+(2*F.y-5*P.y+4*f.y-c.y)*q+(-F.y+3*P.y-3*f.y+c.y)*H);return new t(A,o)}static ClampToRef(F,P,f,c){return c.x=(0,o.Clamp)(F.x,P.x,f.x),c.y=(0,o.Clamp)(F.y,P.y,f.y),c}static Clamp(F,P,f){const c=(0,o.Clamp)(F.x,P.x,f.x),N=(0,o.Clamp)(F.y,P.y,f.y);return new t(c,N)}static Hermite(F,P,f,c,N){const q=N*N,H=N*q,A=2*H-3*q+1,o=-2*H+3*q,j=H-2*q+N,i=H-q,u=F.x*A+f.x*o+P.x*j+c.x*i,T=F.y*A+f.y*o+P.y*j+c.y*i;return new t(u,T)}static Hermite1stDerivative(F,P,f,c,N){return this.Hermite1stDerivativeToRef(F,P,f,c,N,new t)}static Hermite1stDerivativeToRef(F,P,f,c,N,q){const H=N*N;return q.x=6*(H-N)*F.x+(3*H-4*N+1)*P.x+6*(-H+N)*f.x+(3*H-2*N)*c.x,q.y=6*(H-N)*F.y+(3*H-4*N+1)*P.y+6*(-H+N)*f.y+(3*H-2*N)*c.y,q}static Lerp(F,P,f){return t.LerpToRef(F,P,f,new t)}static LerpToRef(F,P,f,c){return c.x=F.x+(P.x-F.x)*f,c.y=F.y+(P.y-F.y)*f,c}static Dot(F,P){return F.x*P.x+F.y*P.y}static Normalize(F){return t.NormalizeToRef(F,new t)}static NormalizeToRef(F,P){return F.normalizeToRef(P),P}static Minimize(F,P){const f=F.x<P.x?F.x:P.x,c=F.y<P.y?F.y:P.y;return new t(f,c)}static Maximize(F,P){const f=F.x>P.x?F.x:P.x,c=F.y>P.y?F.y:P.y;return new t(f,c)}static Transform(F,P){return t.TransformToRef(F,P,new t)}static TransformToRef(F,P,f){const c=P.m,N=F.x*c[0]+F.y*c[4]+c[12],q=F.x*c[1]+F.y*c[5]+c[13];return f.x=N,f.y=q,f}static PointInTriangle(F,P,f,c){const N=.5*(-f.y*c.x+P.y*(-f.x+c.x)+P.x*(f.y-c.y)+f.x*c.y),q=N<0?-1:1,H=(P.y*c.x-P.x*c.y+(c.y-P.y)*F.x+(P.x-c.x)*F.y)*q,A=(P.x*f.y-P.y*f.x+(P.y-f.y)*F.x+(f.x-P.x)*F.y)*q;return H>0&&A>0&&H+A<2*N*q}static Distance(F,P){return Math.sqrt(t.DistanceSquared(F,P))}static DistanceSquared(F,P){const f=F.x-P.x,c=F.y-P.y;return f*f+c*c}static Center(F,P){return t.CenterToRef(F,P,new t)}static CenterToRef(F,P,f){return f.fc((F.x+P.x)/2,(F.y+P.y)/2)}static DistanceOfPointFromSegment(F,P,f){const c=t.DistanceSquared(P,f);if(0===c)return t.Distance(F,P);const N=f.CP(P),q=Math.max(0,Math.min(1,t.Dot(F.CP(P),N)/c)),H=P.add(N.multiplyByFloats(q,q));return t.Distance(F,H)}}t._V8PerformanceHack=new t(.5,.5),t._ZeroReadOnly=t.Zero(),Object.defineProperties(t.prototype,{dimension:{value:[2]},rank:{value:1}});class C{get x(){return this._x}set x(F){this._x=F,this._isDirty=!0}get y(){return this._y}set y(F){this._y=F,this._isDirty=!0}get z(){return this._z}set z(F){this._z=F,this._isDirty=!0}constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=F,this._y=P,this._z=f}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"tP"}getHashCode(){let F=Y(this._x);return F=397*F^Y(this._y),F=397*F^Y(this._z),F}pf(){return[this._x,this._y,this._z]}toArray(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F[P]=this._x,F[P+1]=this._y,F[P+2]=this._z,this}Zf(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C.FromArrayToRef(F,P,this),this}toQuaternion(){return J.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(F){return this._x+=F._x,this._y+=F._y,this._z+=F._z,this._isDirty=!0,this}addInPlaceFromFloats(F,P,f){return this._x+=F,this._y+=P,this._z+=f,this._isDirty=!0,this}add(F){return new C(this._x+F._x,this._y+F._y,this._z+F._z)}addToRef(F,P){return P._x=this._x+F._x,P._y=this._y+F._y,P._z=this._z+F._z,P._isDirty=!0,P}Ou(F){return this._x-=F._x,this._y-=F._y,this._z-=F._z,this._isDirty=!0,this}CP(F){return new C(this._x-F._x,this._y-F._y,this._z-F._z)}subtractToRef(F,P){return this.subtractFromFloatsToRef(F._x,F._y,F._z,P)}subtractFromFloats(F,P,f){return new C(this._x-F,this._y-P,this._z-f)}subtractFromFloatsToRef(F,P,f,c){return c._x=this._x-F,c._y=this._y-P,c._z=this._z-f,c._isDirty=!0,c}negate(){return new C(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(F){return F._x=-1*this._x,F._y=-1*this._y,F._z=-1*this._z,F._isDirty=!0,F}scaleInPlace(F){return this._x*=F,this._y*=F,this._z*=F,this._isDirty=!0,this}scale(F){return new C(this._x*F,this._y*F,this._z*F)}scaleToRef(F,P){return P._x=this._x*F,P._y=this._y*F,P._z=this._z*F,P._isDirty=!0,P}getNormalToRef(F){const P=this.length();let f=Math.acos(this._y/P);const c=Math.atan2(this._z,this._x);f>Math.PI/2?f-=Math.PI/2:f+=Math.PI/2;const N=P*Math.sin(f)*Math.cos(c),q=P*Math.cos(f),H=P*Math.sin(f)*Math.sin(c);return F.set(N,q,H),F}applyRotationQuaternionToRef(F,P){const f=this._x,c=this._y,N=this._z,q=F._x,H=F._y,A=F._z,o=F._w,j=2*(H*N-A*c),i=2*(A*f-q*N),u=2*(q*c-H*f);return P._x=f+o*j+H*u-A*i,P._y=c+o*i+A*j-q*u,P._z=N+o*u+q*i-H*j,P._isDirty=!0,P}applyRotationQuaternionInPlace(F){return this.applyRotationQuaternionToRef(F,this)}applyRotationQuaternion(F){return this.applyRotationQuaternionToRef(F,new C)}scaleAndAddToRef(F,P){return P._x+=this._x*F,P._y+=this._y*F,P._z+=this._z*F,P._isDirty=!0,P}projectOnPlane(F,P){return this.projectOnPlaneToRef(F,P,new C)}projectOnPlaneToRef(F,P,f){const c=F.normal,N=F.d,q=z.tP[0];this.subtractToRef(P,q),q.normalize();const H=C.Dot(q,c);if(Math.abs(H)<1e-10)f.Nc(1/0);else{const F=-(C.Dot(P,c)+N)/H,A=q.scaleInPlace(F);P.addToRef(A,f)}return f}equals(F){return F&&this._x===F._x&&this._y===F._y&&this._z===F._z}equalsWithEpsilon(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.e;return F&&(0,o.WithinEpsilon)(this._x,F._x,P)&&(0,o.WithinEpsilon)(this._y,F._y,P)&&(0,o.WithinEpsilon)(this._z,F._z,P)}equalsToFloats(F,P,f){return this._x===F&&this._y===P&&this._z===f}multiplyInPlace(F){return this._x*=F._x,this._y*=F._y,this._z*=F._z,this._isDirty=!0,this}multiply(F){return this.multiplyByFloats(F._x,F._y,F._z)}multiplyToRef(F,P){return P._x=this._x*F._x,P._y=this._y*F._y,P._z=this._z*F._z,P._isDirty=!0,P}multiplyByFloats(F,P,f){return new C(this._x*F,this._y*P,this._z*f)}divide(F){return new C(this._x/F._x,this._y/F._y,this._z/F._z)}divideToRef(F,P){return P._x=this._x/F._x,P._y=this._y/F._y,P._z=this._z/F._z,P._isDirty=!0,P}divideInPlace(F){return this._x=this._x/F._x,this._y=this._y/F._y,this._z=this._z/F._z,this._isDirty=!0,this}minimizeInPlace(F){return this.minimizeInPlaceFromFloats(F._x,F._y,F._z)}maximizeInPlace(F){return this.maximizeInPlaceFromFloats(F._x,F._y,F._z)}minimizeInPlaceFromFloats(F,P,f){return F<this._x&&(this.x=F),P<this._y&&(this.y=P),f<this._z&&(this.z=f),this}maximizeInPlaceFromFloats(F,P,f){return F>this._x&&(this.x=F),P>this._y&&(this.y=P),f>this._z&&(this.z=f),this}isNonUniformWithinEpsilon(F){const P=Math.abs(this._x),f=Math.abs(this._y);if(!(0,o.WithinEpsilon)(P,f,F))return!0;const c=Math.abs(this._z);return!(0,o.WithinEpsilon)(P,c,F)||!(0,o.WithinEpsilon)(f,c,F)}get isNonUniform(){const F=Math.abs(this._x);if(F!==Math.abs(this._y))return!0;return F!==Math.abs(this._z)}floorToRef(F){return F._x=Math.floor(this._x),F._y=Math.floor(this._y),F._z=Math.floor(this._z),F._isDirty=!0,F}floor(){return new C(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(F){return F._x=this._x-Math.floor(this._x),F._y=this._y-Math.floor(this._y),F._z=this._z-Math.floor(this._z),F._isDirty=!0,F}fract(){return new C(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(F){if("xyz"===(F=F.toLowerCase()))return this;const P=z.tP[0].q(this);return this.x=P[F[0]],this.y=P[F[1]],this.z=P[F[2]],this}rotateByQuaternionToRef(F,P){return F.toRotationMatrix(z.Matrix[0]),C.TransformCoordinatesToRef(this,z.Matrix[0],P),P}rotateByQuaternionAroundPointToRef(F,P,f){return this.subtractToRef(P,z.tP[0]),z.tP[0].rotateByQuaternionToRef(F,z.tP[0]),P.addToRef(z.tP[0],f),f}cross(F){return C.CrossToRef(this,F,new C)}normalizeFromLength(F){return 0===F||1===F?this:this.scaleInPlace(1/F)}normalizeToNew(){return this.normalizeToRef(new C)}normalizeToRef(F){const P=this.length();return 0===P||1===P?(F._x=this._x,F._y=this._y,F._z=this._z,F._isDirty=!0,F):this.scaleToRef(1/P,F)}clone(){return new C(this._x,this._y,this._z)}q(F){return this.fc(F._x,F._y,F._z)}fc(F,P,f){return this._x=F,this._y=P,this._z=f,this._isDirty=!0,this}set(F,P,f){return this.fc(F,P,f)}Nc(F){return this._x=this._y=this._z=F,this._isDirty=!0,this}static GetClipFactor(F,P,f,c){const N=C.Dot(F,f);return(N-c)/(N-C.Dot(P,f))}static GetAngleBetweenVectors(F,P,f){const c=F.normalizeToRef(z.tP[1]),N=P.normalizeToRef(z.tP[2]);let q=C.Dot(c,N);q=(0,o.Clamp)(q,-1,1);const H=Math.acos(q),A=z.tP[3];return C.CrossToRef(c,N,A),C.Dot(A,f)>0?isNaN(H)?0:H:isNaN(H)?-Math.PI:-Math.acos(q)}static GetAngleBetweenVectorsOnPlane(F,P,f){z.tP[0].q(F);const c=z.tP[0];z.tP[1].q(P);const N=z.tP[1];z.tP[2].q(f);const q=z.tP[2],H=z.tP[3],A=z.tP[4];c.normalize(),N.normalize(),q.normalize(),C.CrossToRef(q,c,H),C.CrossToRef(H,q,A);const j=Math.atan2(C.Dot(N,H),C.Dot(N,A));return(0,o.NormalizeRadians)(j)}static PitchYawRollToMoveBetweenPointsToRef(F,P,f){const c=Z.tP[0];return P.subtractToRef(F,c),f._y=Math.atan2(c.x,c.z)||0,f._x=Math.atan2(Math.sqrt(c.x**2+c.z**2),c.y)||0,f._z=0,f._isDirty=!0,f}static PitchYawRollToMoveBetweenPoints(F,P){const f=C.Zero();return C.PitchYawRollToMoveBetweenPointsToRef(F,P,f)}static SlerpToRef(F,P,f,N){f=(0,o.Clamp)(f,0,1);const q=z.tP[0],H=z.tP[1];q.q(F);const A=q.length();q.normalizeFromLength(A),H.q(P);const j=H.length();H.normalizeFromLength(j);const i=C.Dot(q,H);let u,T;if(i<1-c.e){const F=Math.acos(i),P=1/Math.sin(F);u=Math.sin((1-f)*F)*P,T=Math.sin(f*F)*P}else u=1-f,T=f;return q.scaleInPlace(u),H.scaleInPlace(T),N.q(q).addInPlace(H),N.scaleInPlace((0,o.Lerp)(A,j,f)),N}static SmoothToRef(F,P,f,c,N){return C.SlerpToRef(F,P,0===c?1:f/c,N),N}static zP(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new C(F[P],F[P+1],F[P+2])}static FromFloatArray(F,P){return C.zP(F,P)}static FromArrayToRef(F,P,f){return f._x=F[P],f._y=F[P+1],f._z=F[P+2],f._isDirty=!0,f}static FromFloatArrayToRef(F,P,f){return C.FromArrayToRef(F,P,f)}static FromFloatsToRef(F,P,f,c){return c.fc(F,P,f),c}static Zero(){return new C(0,0,0)}static One(){return new C(1,1,1)}static Up(){return new C(0,1,0)}static get UpReadOnly(){return C._UpReadOnly}static get DownReadOnly(){return C._DownReadOnly}static get RightReadOnly(){return C._RightReadOnly}static get LeftReadOnly(){return C._LeftReadOnly}static get LeftHandedForwardReadOnly(){return C._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return C._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return C._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return C._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return C._ZeroReadOnly}static get OneReadOnly(){return C._OneReadOnly}static Down(){return new C(0,-1,0)}static Forward(){return new C(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new C(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new C(1,0,0)}static Left(){return new C(-1,0,0)}static Random(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new C((0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P))}static RandomToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fc((0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P))}static TransformCoordinates(F,P){const f=C.Zero();return C.TransformCoordinatesToRef(F,P,f),f}static TransformCoordinatesToRef(F,P,f){return C.TransformCoordinatesFromFloatsToRef(F._x,F._y,F._z,P,f),f}static TransformCoordinatesFromFloatsToRef(F,P,f,c,N){const q=c.m,H=F*q[0]+P*q[4]+f*q[8]+q[12],A=F*q[1]+P*q[5]+f*q[9]+q[13],o=F*q[2]+P*q[6]+f*q[10]+q[14],j=1/(F*q[3]+P*q[7]+f*q[11]+q[15]);return N._x=H*j,N._y=A*j,N._z=o*j,N._isDirty=!0,N}static TransformNormal(F,P){const f=C.Zero();return C.TransformNormalToRef(F,P,f),f}static TransformNormalToRef(F,P,f){return this.TransformNormalFromFloatsToRef(F._x,F._y,F._z,P,f),f}static TransformNormalFromFloatsToRef(F,P,f,c,N){const q=c.m;return N._x=F*q[0]+P*q[4]+f*q[8],N._y=F*q[1]+P*q[5]+f*q[9],N._z=F*q[2]+P*q[6]+f*q[10],N._isDirty=!0,N}static CatmullRom(F,P,f,c,N){const q=N*N,H=N*q,A=.5*(2*P._x+(-F._x+f._x)*N+(2*F._x-5*P._x+4*f._x-c._x)*q+(-F._x+3*P._x-3*f._x+c._x)*H),o=.5*(2*P._y+(-F._y+f._y)*N+(2*F._y-5*P._y+4*f._y-c._y)*q+(-F._y+3*P._y-3*f._y+c._y)*H),j=.5*(2*P._z+(-F._z+f._z)*N+(2*F._z-5*P._z+4*f._z-c._z)*q+(-F._z+3*P._z-3*f._z+c._z)*H);return new C(A,o,j)}static Clamp(F,P,f){const c=new C;return C.ClampToRef(F,P,f,c),c}static ClampToRef(F,P,f,c){let N=F._x;N=N>f._x?f._x:N,N=N<P._x?P._x:N;let q=F._y;q=q>f._y?f._y:q,q=q<P._y?P._y:q;let H=F._z;return H=H>f._z?f._z:H,H=H<P._z?P._z:H,c.fc(N,q,H),c}static CheckExtends(F,P,f){P.minimizeInPlace(F),f.maximizeInPlace(F)}static Hermite(F,P,f,c,N){const q=N*N,H=N*q,A=2*H-3*q+1,o=-2*H+3*q,j=H-2*q+N,i=H-q,u=F._x*A+f._x*o+P._x*j+c._x*i,T=F._y*A+f._y*o+P._y*j+c._y*i,Y=F._z*A+f._z*o+P._z*j+c._z*i;return new C(u,T,Y)}static Hermite1stDerivative(F,P,f,c,N){const q=new C;return this.Hermite1stDerivativeToRef(F,P,f,c,N,q),q}static Hermite1stDerivativeToRef(F,P,f,c,N,q){const H=N*N;return q._x=6*(H-N)*F._x+(3*H-4*N+1)*P._x+6*(-H+N)*f._x+(3*H-2*N)*c._x,q._y=6*(H-N)*F._y+(3*H-4*N+1)*P._y+6*(-H+N)*f._y+(3*H-2*N)*c._y,q._z=6*(H-N)*F._z+(3*H-4*N+1)*P._z+6*(-H+N)*f._z+(3*H-2*N)*c._z,q._isDirty=!0,q}static Lerp(F,P,f){const c=new C(0,0,0);return C.LerpToRef(F,P,f,c),c}static LerpToRef(F,P,f,c){return c._x=F._x+(P._x-F._x)*f,c._y=F._y+(P._y-F._y)*f,c._z=F._z+(P._z-F._z)*f,c._isDirty=!0,c}static Dot(F,P){return F._x*P._x+F._y*P._y+F._z*P._z}dot(F){return this._x*F._x+this._y*F._y+this._z*F._z}static Cross(F,P){const f=new C;return C.CrossToRef(F,P,f),f}static CrossToRef(F,P,f){const c=F._y*P._z-F._z*P._y,N=F._z*P._x-F._x*P._z,q=F._x*P._y-F._y*P._x;return f.fc(c,N,q),f}static Normalize(F){const P=C.Zero();return C.NormalizeToRef(F,P),P}static NormalizeToRef(F,P){return F.normalizeToRef(P),P}static Project(F,P,f,c){const N=new C;return C.ProjectToRef(F,P,f,c,N),N}static ProjectToRef(F,P,f,c,N){var q;const H=c.width,o=c.height,j=c.x,i=c.y,u=z.Matrix[1],T=null===(q=A.b.LastCreatedEngine)||void 0===q?void 0:q.isNDCHalfZRange,Y=T?1:.5,t=T?0:.5;B.FromValuesToRef(H/2,0,0,0,0,-o/2,0,0,0,0,Y,0,j+H/2,o/2+i,t,1,u);const L=z.Matrix[0];return P.multiplyToRef(f,L),L.multiplyToRef(u,L),C.TransformCoordinatesToRef(F,L,N),N}static Reflect(F,P){return this.ReflectToRef(F,P,new C)}static ReflectToRef(F,P,f){const c=Z.tP[0];return c.q(P).scaleInPlace(2*C.Dot(F,P)),f.q(F).Ou(c)}static _UnprojectFromInvertedMatrixToRef(F,P,f){C.TransformCoordinatesToRef(F,P,f);const c=P.m,N=F._x*c[3]+F._y*c[7]+F._z*c[11]+c[15];return(0,o.WithinEpsilon)(N,1)&&f.scaleInPlace(1/N),f}static UnprojectFromTransform(F,P,f,c,N){return this.Unproject(F,P,f,c,N,B.IdentityReadOnly)}static Unproject(F,P,f,c,N,q){const H=new C;return C.UnprojectToRef(F,P,f,c,N,q,H),H}static UnprojectToRef(F,P,f,c,N,q,H){return C.UnprojectFloatsToRef(F._x,F._y,F._z,P,f,c,N,q,H),H}static UnprojectFloatsToRef(F,P,f,c,N,q,H,o,j){var i;const u=z.Matrix[0];q.multiplyToRef(H,u),u.multiplyToRef(o,u),u.invert();const T=z.tP[0];return T.x=F/c*2-1,T.y=-(P/N*2-1),null!==(i=A.b.LastCreatedEngine)&&void 0!==i&&i.isNDCHalfZRange?T.z=f:T.z=2*f-1,C._UnprojectFromInvertedMatrixToRef(T,u,j),j}static Minimize(F,P){const f=new C;return f.q(F),f.minimizeInPlace(P),f}static Maximize(F,P){const f=new C;return f.q(F),f.maximizeInPlace(P),f}static Distance(F,P){return Math.sqrt(C.DistanceSquared(F,P))}static DistanceSquared(F,P){const f=F._x-P._x,c=F._y-P._y,N=F._z-P._z;return f*f+c*c+N*N}static ProjectOnTriangleToRef(F,P,f,N,q){const H=z.tP[0],A=z.tP[1],j=z.tP[2],i=z.tP[3],u=z.tP[4];f.subtractToRef(P,H),N.subtractToRef(P,A),N.subtractToRef(f,j);const T=H.length(),Y=A.length(),t=j.length();if(T<c.e||Y<c.e||t<c.e)return q.q(P),C.Distance(F,P);F.subtractToRef(P,u),C.CrossToRef(H,A,i);const L=i.length();if(L<c.e)return q.q(P),C.Distance(F,P);i.normalizeFromLength(L);let J=u.length();if(J<c.e)return q.q(P),0;u.normalizeFromLength(J);const B=C.Dot(i,u),Z=z.tP[5],R=z.tP[6];Z.q(i).scaleInPlace(-J*B),R.q(F).addInPlace(Z);const y=z.tP[4],O=z.tP[5],d=z.tP[7],M=z.tP[8];y.q(H).scaleInPlace(1/T),M.q(A).scaleInPlace(1/Y),y.addInPlace(M).scaleInPlace(-1),O.q(H).scaleInPlace(-1/T),M.q(j).scaleInPlace(1/t),O.addInPlace(M).scaleInPlace(-1),d.q(j).scaleInPlace(-1/t),M.q(A).scaleInPlace(-1/Y),d.addInPlace(M).scaleInPlace(-1);const V=z.tP[9];let Q;V.q(R).Ou(P),C.CrossToRef(y,V,M),Q=C.Dot(M,i);const K=Q;V.q(R).Ou(f),C.CrossToRef(O,V,M),Q=C.Dot(M,i);const x=Q;V.q(R).Ou(N),C.CrossToRef(d,V,M),Q=C.Dot(M,i);const k=Q,I=z.tP[10];let E,r;K>0&&x<0?(I.q(H),E=P,r=f):x>0&&k<0?(I.q(j),E=f,r=N):(I.q(A).scaleInPlace(-1),E=N,r=P);const n=z.tP[9],p=z.tP[4];E.subtractToRef(R,M),r.subtractToRef(R,n),C.CrossToRef(M,n,p);if(!(C.Dot(p,i)<0))return q.q(R),Math.abs(J*B);const U=z.tP[5];C.CrossToRef(I,p,U),U.normalize();const e=z.tP[9];e.q(E).Ou(R);const D=e.length();if(D<c.e)return q.q(E),C.Distance(F,E);e.normalizeFromLength(D);const l=C.Dot(U,e),W=z.tP[7];W.q(R).addInPlace(U.scaleInPlace(D*l)),M.q(W).Ou(E),J=I.length(),I.normalizeFromLength(J);let b=C.Dot(M,I)/Math.max(J,c.e);return b=(0,o.Clamp)(b,0,1),W.q(E).addInPlace(I.scaleInPlace(b*J)),q.q(W),C.Distance(F,W)}static Center(F,P){return C.CenterToRef(F,P,C.Zero())}static CenterToRef(F,P,f){return f.fc((F._x+P._x)/2,(F._y+P._y)/2,(F._z+P._z)/2)}static RotationFromAxis(F,P,f){const c=new C;return C.RotationFromAxisToRef(F,P,f,c),c}static RotationFromAxisToRef(F,P,f,c){const N=z.Quaternion[0];return J.RotationQuaternionFromAxisToRef(F,P,f,N),N.toEulerAnglesToRef(c),c}}C._V8PerformanceHack=new C(.5,.5,.5),C._UpReadOnly=C.Up(),C._DownReadOnly=C.Down(),C._LeftHandedForwardReadOnly=C.Forward(!1),C._RightHandedForwardReadOnly=C.Forward(!0),C._LeftHandedBackwardReadOnly=C.Backward(!1),C._RightHandedBackwardReadOnly=C.Backward(!0),C._RightReadOnly=C.Right(),C._LeftReadOnly=C.Left(),C._ZeroReadOnly=C.Zero(),C._OneReadOnly=C.One(),Object.defineProperties(C.prototype,{dimension:{value:[3]},rank:{value:1}});class L{get x(){return this._x}set x(F){this._x=F,this._isDirty=!0}get y(){return this._y}set y(F){this._y=F,this._isDirty=!0}get z(){return this._z}set z(F){this._z=F,this._isDirty=!0}get w(){return this._w}set w(F){this._w=F,this._isDirty=!0}constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=F,this._y=P,this._z=f,this._w=c}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let F=Y(this._x);return F=397*F^Y(this._y),F=397*F^Y(this._z),F=397*F^Y(this._w),F}pf(){return[this._x,this._y,this._z,this._w]}toArray(F,P){return void 0===P&&(P=0),F[P]=this._x,F[P+1]=this._y,F[P+2]=this._z,F[P+3]=this._w,this}Zf(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(F,P,this),this}addInPlace(F){return this.x+=F._x,this.y+=F._y,this.z+=F._z,this.w+=F._w,this}addInPlaceFromFloats(F,P,f,c){return this.x+=F,this.y+=P,this.z+=f,this.w+=c,this}add(F){return new L(this._x+F.x,this._y+F.y,this._z+F.z,this._w+F.w)}addToRef(F,P){return P.x=this._x+F.x,P.y=this._y+F.y,P.z=this._z+F.z,P.w=this._w+F.w,P}Ou(F){return this.x-=F.x,this.y-=F.y,this.z-=F.z,this.w-=F.w,this}CP(F){return new L(this._x-F.x,this._y-F.y,this._z-F.z,this._w-F.w)}subtractToRef(F,P){return P.x=this._x-F.x,P.y=this._y-F.y,P.z=this._z-F.z,P.w=this._w-F.w,P}subtractFromFloats(F,P,f,c){return new L(this._x-F,this._y-P,this._z-f,this._w-c)}subtractFromFloatsToRef(F,P,f,c,N){return N.x=this._x-F,N.y=this._y-P,N.z=this._z-f,N.w=this._w-c,N}negate(){return new L(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(F){return F.x=-this._x,F.y=-this._y,F.z=-this._z,F.w=-this._w,F}scaleInPlace(F){return this.x*=F,this.y*=F,this.z*=F,this.w*=F,this}scale(F){return new L(this._x*F,this._y*F,this._z*F,this._w*F)}scaleToRef(F,P){return P.x=this._x*F,P.y=this._y*F,P.z=this._z*F,P.w=this._w*F,P}scaleAndAddToRef(F,P){return P.x+=this._x*F,P.y+=this._y*F,P.z+=this._z*F,P.w+=this._w*F,P}equals(F){return F&&this._x===F.x&&this._y===F.y&&this._z===F.z&&this._w===F.w}equalsWithEpsilon(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.e;return F&&(0,o.WithinEpsilon)(this._x,F.x,P)&&(0,o.WithinEpsilon)(this._y,F.y,P)&&(0,o.WithinEpsilon)(this._z,F.z,P)&&(0,o.WithinEpsilon)(this._w,F.w,P)}equalsToFloats(F,P,f,c){return this._x===F&&this._y===P&&this._z===f&&this._w===c}multiplyInPlace(F){return this.x*=F.x,this.y*=F.y,this.z*=F.z,this.w*=F.w,this}multiply(F){return new L(this._x*F.x,this._y*F.y,this._z*F.z,this._w*F.w)}multiplyToRef(F,P){return P.x=this._x*F.x,P.y=this._y*F.y,P.z=this._z*F.z,P.w=this._w*F.w,P}multiplyByFloats(F,P,f,c){return new L(this._x*F,this._y*P,this._z*f,this._w*c)}divide(F){return new L(this._x/F.x,this._y/F.y,this._z/F.z,this._w/F.w)}divideToRef(F,P){return P.x=this._x/F.x,P.y=this._y/F.y,P.z=this._z/F.z,P.w=this._w/F.w,P}divideInPlace(F){return this.divideToRef(F,this)}minimizeInPlace(F){return F.x<this._x&&(this.x=F.x),F.y<this._y&&(this.y=F.y),F.z<this._z&&(this.z=F.z),F.w<this._w&&(this.w=F.w),this}maximizeInPlace(F){return F.x>this._x&&(this.x=F.x),F.y>this._y&&(this.y=F.y),F.z>this._z&&(this.z=F.z),F.w>this._w&&(this.w=F.w),this}minimizeInPlaceFromFloats(F,P,f,c){return this.x=Math.min(F,this._x),this.y=Math.min(P,this._y),this.z=Math.min(f,this._z),this.w=Math.min(c,this._w),this}maximizeInPlaceFromFloats(F,P,f,c){return this.x=Math.max(F,this._x),this.y=Math.max(P,this._y),this.z=Math.max(f,this._z),this.w=Math.max(c,this._w),this}floorToRef(F){return F.x=Math.floor(this._x),F.y=Math.floor(this._y),F.z=Math.floor(this._z),F.w=Math.floor(this._w),F}floor(){return new L(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(F){return F.x=this._x-Math.floor(this._x),F.y=this._y-Math.floor(this._y),F.z=this._z-Math.floor(this._z),F.w=this._w-Math.floor(this._w),F}fract(){return new L(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(F){return 0===F||1===F?this:this.scaleInPlace(1/F)}normalizeToNew(){return this.normalizeToRef(new L)}normalizeToRef(F){const P=this.length();return 0===P||1===P?(F.x=this._x,F.y=this._y,F.z=this._z,F.w=this._w,F):this.scaleToRef(1/P,F)}toVector3(){return new C(this._x,this._y,this._z)}clone(){return new L(this._x,this._y,this._z,this._w)}q(F){return this.x=F.x,this.y=F.y,this.z=F.z,this.w=F.w,this}fc(F,P,f,c){return this.x=F,this.y=P,this.z=f,this.w=c,this}set(F,P,f,c){return this.fc(F,P,f,c)}Nc(F){return this.x=this.y=this.z=this.w=F,this}dot(F){return this._x*F.x+this._y*F.y+this._z*F.z+this._w*F.w}static zP(F,P){return P||(P=0),new L(F[P],F[P+1],F[P+2],F[P+3])}static FromArrayToRef(F,P,f){return f.x=F[P],f.y=F[P+1],f.z=F[P+2],f.w=F[P+3],f}static FromFloatArrayToRef(F,P,f){return L.FromArrayToRef(F,P,f),f}static FromFloatsToRef(F,P,f,c,N){return N.x=F,N.y=P,N.z=f,N.w=c,N}static Zero(){return new L(0,0,0,0)}static One(){return new L(1,1,1,1)}static Random(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new L((0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P))}static RandomToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,f=arguments.length>2?arguments[2]:void 0;return f.x=(0,o.RandomRange)(F,P),f.y=(0,o.RandomRange)(F,P),f.z=(0,o.RandomRange)(F,P),f.w=(0,o.RandomRange)(F,P),f}static Clamp(F,P,f){return L.ClampToRef(F,P,f,new L)}static ClampToRef(F,P,f,c){return c.x=(0,o.Clamp)(F.x,P.x,f.x),c.y=(0,o.Clamp)(F.y,P.y,f.y),c.z=(0,o.Clamp)(F.z,P.z,f.z),c.w=(0,o.Clamp)(F.w,P.w,f.w),c}static CheckExtends(F,P,f){P.minimizeInPlace(F),f.maximizeInPlace(F)}static get ZeroReadOnly(){return L._ZeroReadOnly}static Normalize(F){return L.NormalizeToRef(F,new L)}static NormalizeToRef(F,P){return F.normalizeToRef(P),P}static Minimize(F,P){const f=new L;return f.q(F),f.minimizeInPlace(P),f}static Maximize(F,P){const f=new L;return f.q(F),f.maximizeInPlace(P),f}static Distance(F,P){return Math.sqrt(L.DistanceSquared(F,P))}static DistanceSquared(F,P){const f=F.x-P.x,c=F.y-P.y,N=F.z-P.z,q=F.w-P.w;return f*f+c*c+N*N+q*q}static Center(F,P){return L.CenterToRef(F,P,new L)}static CenterToRef(F,P,f){return f.x=(F.x+P.x)/2,f.y=(F.y+P.y)/2,f.z=(F.z+P.z)/2,f.w=(F.w+P.w)/2,f}static TransformCoordinates(F,P){return L.TransformCoordinatesToRef(F,P,new L)}static TransformCoordinatesToRef(F,P,f){return L.TransformCoordinatesFromFloatsToRef(F._x,F._y,F._z,P,f),f}static TransformCoordinatesFromFloatsToRef(F,P,f,c,N){const q=c.m,H=F*q[0]+P*q[4]+f*q[8]+q[12],A=F*q[1]+P*q[5]+f*q[9]+q[13],o=F*q[2]+P*q[6]+f*q[10]+q[14],j=F*q[3]+P*q[7]+f*q[11]+q[15];return N.x=H,N.y=A,N.z=o,N.w=j,N}static TransformNormal(F,P){return L.TransformNormalToRef(F,P,new L)}static TransformNormalToRef(F,P,f){const c=P.m,N=F.x*c[0]+F.y*c[4]+F.z*c[8],q=F.x*c[1]+F.y*c[5]+F.z*c[9],H=F.x*c[2]+F.y*c[6]+F.z*c[10];return f.x=N,f.y=q,f.z=H,f.w=F.w,f}static TransformNormalFromFloatsToRef(F,P,f,c,N,q){const H=N.m;return q.x=F*H[0]+P*H[4]+f*H[8],q.y=F*H[1]+P*H[5]+f*H[9],q.z=F*H[2]+P*H[6]+f*H[10],q.w=c,q}static FromVector3(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new L(F._x,F._y,F._z,P)}static Dot(F,P){return F.x*P.x+F.y*P.y+F.z*P.z+F.w*P.w}}L._V8PerformanceHack=new L(.5,.5,.5,.5),L._ZeroReadOnly=L.Zero(),Object.defineProperties(L.prototype,{dimension:{value:[4]},rank:{value:1}});class J{get x(){return this._x}set x(F){this._x=F,this._isDirty=!0}get y(){return this._y}set y(F){this._y=F,this._isDirty=!0}get z(){return this._z}set z(F){this._z=F,this._isDirty=!0}get w(){return this._w}set w(F){this._w=F,this._isDirty=!0}constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=F,this._y=P,this._z=f,this._w=c}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let F=Y(this._x);return F=397*F^Y(this._y),F=397*F^Y(this._z),F=397*F^Y(this._w),F}pf(){return[this._x,this._y,this._z,this._w]}toArray(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F[P]=this._x,F[P+1]=this._y,F[P+2]=this._z,F[P+3]=this._w,this}Zf(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(F,P,this)}equals(F){return F&&this._x===F._x&&this._y===F._y&&this._z===F._z&&this._w===F._w}equalsWithEpsilon(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.e;return F&&(0,o.WithinEpsilon)(this._x,F._x,P)&&(0,o.WithinEpsilon)(this._y,F._y,P)&&(0,o.WithinEpsilon)(this._z,F._z,P)&&(0,o.WithinEpsilon)(this._w,F._w,P)}isApprox(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.e;return F&&((0,o.WithinEpsilon)(this._x,F._x,P)&&(0,o.WithinEpsilon)(this._y,F._y,P)&&(0,o.WithinEpsilon)(this._z,F._z,P)&&(0,o.WithinEpsilon)(this._w,F._w,P)||(0,o.WithinEpsilon)(this._x,-F._x,P)&&(0,o.WithinEpsilon)(this._y,-F._y,P)&&(0,o.WithinEpsilon)(this._z,-F._z,P)&&(0,o.WithinEpsilon)(this._w,-F._w,P))}clone(){return new J(this._x,this._y,this._z,this._w)}q(F){return this._x=F._x,this._y=F._y,this._z=F._z,this._w=F._w,this._isDirty=!0,this}fc(F,P,f,c){return this._x=F,this._y=P,this._z=f,this._w=c,this._isDirty=!0,this}set(F,P,f,c){return this.fc(F,P,f,c)}Nc(F){return this.fc(F,F,F,F)}add(F){return new J(this._x+F._x,this._y+F._y,this._z+F._z,this._w+F._w)}addInPlace(F){return this._x+=F._x,this._y+=F._y,this._z+=F._z,this._w+=F._w,this._isDirty=!0,this}addToRef(F,P){return P._x=this._x+F._x,P._y=this._y+F._y,P._z=this._z+F._z,P._w=this._w+F._w,P._isDirty=!0,P}addInPlaceFromFloats(F,P,f,c){return this._x+=F,this._y+=P,this._z+=f,this._w+=c,this._isDirty=!0,this}subtractToRef(F,P){return P._x=this._x-F._x,P._y=this._y-F._y,P._z=this._z-F._z,P._w=this._w-F._w,P._isDirty=!0,P}subtractFromFloats(F,P,f,c){return this.subtractFromFloatsToRef(F,P,f,c,new J)}subtractFromFloatsToRef(F,P,f,c,N){return N._x=this._x-F,N._y=this._y-P,N._z=this._z-f,N._w=this._w-c,N._isDirty=!0,N}CP(F){return new J(this._x-F._x,this._y-F._y,this._z-F._z,this._w-F._w)}Ou(F){return this._x-=F._x,this._y-=F._y,this._z-=F._z,this._w-=F._w,this._isDirty=!0,this}scale(F){return new J(this._x*F,this._y*F,this._z*F,this._w*F)}scaleToRef(F,P){return P._x=this._x*F,P._y=this._y*F,P._z=this._z*F,P._w=this._w*F,P._isDirty=!0,P}scaleInPlace(F){return this._x*=F,this._y*=F,this._z*=F,this._w*=F,this._isDirty=!0,this}scaleAndAddToRef(F,P){return P._x+=this._x*F,P._y+=this._y*F,P._z+=this._z*F,P._w+=this._w*F,P._isDirty=!0,P}multiply(F){const P=new J(0,0,0,1);return this.multiplyToRef(F,P),P}multiplyToRef(F,P){const f=this._x*F._w+this._y*F._z-this._z*F._y+this._w*F._x,c=-this._x*F._z+this._y*F._w+this._z*F._x+this._w*F._y,N=this._x*F._y-this._y*F._x+this._z*F._w+this._w*F._z,q=-this._x*F._x-this._y*F._y-this._z*F._z+this._w*F._w;return P.fc(f,c,N,q),P}multiplyInPlace(F){return this.multiplyToRef(F,this)}multiplyByFloats(F,P,f,c){return this._x*=F,this._y*=P,this._z*=f,this._w*=c,this._isDirty=!0,this}divide(F){throw new ReferenceError("Can not divide a quaternion")}divideToRef(F,P){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(F){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new J)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(F){return F._x=-this._x,F._y=-this._y,F._z=-this._z,F._w=-this._w,F._isDirty=!0,F}equalsToFloats(F,P,f,c){return this._x===F&&this._y===P&&this._z===f&&this._w===c}floorToRef(F){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(F){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(F){return F.fc(-this._x,-this._y,-this._z,this._w),F}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new J(-this._x,-this._y,-this._z,this._w)}invert(){const F=this.conjugate(),P=this.lengthSquared();return 0==P||1==P||F.scaleInPlace(1/P),F}invertInPlace(){this.conjugateInPlace();const F=this.lengthSquared();return 0==F||1==F||this.scaleInPlace(1/F),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(F){return 0===F||1===F?this:this.scaleInPlace(1/F)}normalizeToNew(){const F=new J(0,0,0,1);return this.normalizeToRef(F),F}normalizeToRef(F){const P=this.length();return 0===P||1===P?F.fc(this._x,this._y,this._z,this._w):this.scaleToRef(1/P,F)}toEulerAngles(){const F=C.Zero();return this.toEulerAnglesToRef(F),F}toEulerAnglesToRef(F){const P=this._z,f=this._x,c=this._y,N=this._w,q=c*P-f*N,H=.4999999;if(q<-H)F._y=2*Math.atan2(c,N),F._x=Math.PI/2,F._z=0,F._isDirty=!0;else if(q>H)F._y=2*Math.atan2(c,N),F._x=-Math.PI/2,F._z=0,F._isDirty=!0;else{const H=N*N,A=P*P,o=f*f,j=c*c;F._z=Math.atan2(2*(f*c+P*N),-A-o+j+H),F._x=Math.asin(-2*q),F._y=Math.atan2(2*(P*f+c*N),A-o-j+H),F._isDirty=!0}return F}toAlphaBetaGammaToRef(F){const P=this._z,f=this._x,c=this._y,N=this._w,q=Math.sqrt(f*f+c*c),H=Math.sqrt(P*P+N*N),A=2*Math.atan2(q,H),o=2*Math.atan2(P,N),j=2*Math.atan2(c,f),i=(o+j)/2,u=(o-j)/2;return F.set(u,A,i),F}toRotationMatrix(F){return B.FromQuaternionToRef(this,F),F}fromRotationMatrix(F){return J.FromRotationMatrixToRef(F,this),this}dot(F){return this._x*F._x+this._y*F._y+this._z*F._z+this._w*F._w}toAxisAngle(){const F=C.Zero();return{axis:F,angle:this.toAxisAngleToRef(F)}}toAxisAngleToRef(F){let P=0;const f=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),c=this._w;return f>0?(P=2*Math.atan2(f,c),F.set(this._x/f,this._y/f,this._z/f)):(P=0,F.set(1,0,0)),P}static FromRotationMatrix(F){const P=new J;return J.FromRotationMatrixToRef(F,P),P}static FromRotationMatrixToRef(F,P){const f=F.m,c=f[0],N=f[4],q=f[8],H=f[1],A=f[5],o=f[9],j=f[2],i=f[6],u=f[10],T=c+A+u;let Y;return T>0?(Y=.5/Math.sqrt(T+1),P._w=.25/Y,P._x=(i-o)*Y,P._y=(q-j)*Y,P._z=(H-N)*Y,P._isDirty=!0):c>A&&c>u?(Y=2*Math.sqrt(1+c-A-u),P._w=(i-o)/Y,P._x=.25*Y,P._y=(N+H)/Y,P._z=(q+j)/Y,P._isDirty=!0):A>u?(Y=2*Math.sqrt(1+A-c-u),P._w=(q-j)/Y,P._x=(N+H)/Y,P._y=.25*Y,P._z=(o+i)/Y,P._isDirty=!0):(Y=2*Math.sqrt(1+u-c-A),P._w=(H-N)/Y,P._x=(q+j)/Y,P._y=(o+i)/Y,P._z=.25*Y,P._isDirty=!0),P}static Dot(F,P){return F._x*P._x+F._y*P._y+F._z*P._z+F._w*P._w}static AreClose(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const c=J.Dot(F,P);return 1-c*c<=f}static SmoothToRef(F,P,f,c,N){let q=0===c?1:f/c;return q=(0,o.Clamp)(q,0,1),J.SlerpToRef(F,P,q,N),N}static Zero(){return new J(0,0,0,0)}static Inverse(F){return new J(-F._x,-F._y,-F._z,F._w)}static InverseToRef(F,P){return P.set(-F._x,-F._y,-F._z,F._w),P}static Identity(){return new J(0,0,0,1)}static IsIdentity(F){return F&&0===F._x&&0===F._y&&0===F._z&&1===F._w}static RotationAxis(F,P){return J.RotationAxisToRef(F,P,new J)}static RotationAxisToRef(F,P,f){f._w=Math.cos(P/2);const c=Math.sin(P/2)/F.length();return f._x=F._x*c,f._y=F._y*c,f._z=F._z*c,f._isDirty=!0,f}static zP(F,P){return P||(P=0),new J(F[P],F[P+1],F[P+2],F[P+3])}static FromArrayToRef(F,P,f){return f._x=F[P],f._y=F[P+1],f._z=F[P+2],f._w=F[P+3],f._isDirty=!0,f}static FromFloatsToRef(F,P,f,c,N){return N.fc(F,P,f,c),N}static FromEulerAngles(F,P,f){const c=new J;return J.RotationYawPitchRollToRef(P,F,f,c),c}static FromEulerAnglesToRef(F,P,f,c){return J.RotationYawPitchRollToRef(P,F,f,c),c}static FromEulerVector(F){const P=new J;return J.RotationYawPitchRollToRef(F._y,F._x,F._z,P),P}static FromEulerVectorToRef(F,P){return J.RotationYawPitchRollToRef(F._y,F._x,F._z,P),P}static FromUnitVectorsToRef(F,P,f){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c.e;const q=C.Dot(F,P)+1;return q<N?Math.abs(F.x)>Math.abs(F.z)?f.set(-F.y,F.x,0,0):f.set(0,-F.z,F.y,0):(C.CrossToRef(F,P,Z.tP[0]),f.set(Z.tP[0].x,Z.tP[0].y,Z.tP[0].z,q)),f.normalize()}static RotationYawPitchRoll(F,P,f){const c=new J;return J.RotationYawPitchRollToRef(F,P,f,c),c}static RotationYawPitchRollToRef(F,P,f,c){const N=.5*f,q=.5*P,H=.5*F,A=Math.sin(N),o=Math.cos(N),j=Math.sin(q),i=Math.cos(q),u=Math.sin(H),T=Math.cos(H);return c._x=T*j*o+u*i*A,c._y=u*i*o-T*j*A,c._z=T*i*A-u*j*o,c._w=T*i*o+u*j*A,c._isDirty=!0,c}static RotationAlphaBetaGamma(F,P,f){const c=new J;return J.RotationAlphaBetaGammaToRef(F,P,f,c),c}static RotationAlphaBetaGammaToRef(F,P,f,c){const N=.5*(f+F),q=.5*(f-F),H=.5*P;return c._x=Math.cos(q)*Math.sin(H),c._y=Math.sin(q)*Math.sin(H),c._z=Math.sin(N)*Math.cos(H),c._w=Math.cos(N)*Math.cos(H),c._isDirty=!0,c}static RotationQuaternionFromAxis(F,P,f){const c=new J(0,0,0,0);return J.RotationQuaternionFromAxisToRef(F,P,f,c),c}static RotationQuaternionFromAxisToRef(F,P,f,c){const N=z.Matrix[0];return F=F.normalizeToRef(z.tP[0]),P=P.normalizeToRef(z.tP[1]),f=f.normalizeToRef(z.tP[2]),B.FromXYZAxesToRef(F,P,f,N),J.FromRotationMatrixToRef(N,c),c}static FromLookDirectionLH(F,P){const f=new J;return J.FromLookDirectionLHToRef(F,P,f),f}static FromLookDirectionLHToRef(F,P,f){const c=z.Matrix[0];return B.LookDirectionLHToRef(F,P,c),J.FromRotationMatrixToRef(c,f),f}static FromLookDirectionRH(F,P){const f=new J;return J.FromLookDirectionRHToRef(F,P,f),f}static FromLookDirectionRHToRef(F,P,f){const c=z.Matrix[0];return B.LookDirectionRHToRef(F,P,c),J.FromRotationMatrixToRef(c,f)}static Slerp(F,P,f){const c=J.Identity();return J.SlerpToRef(F,P,f,c),c}static SlerpToRef(F,P,f,c){let N,q,H=F._x*P._x+F._y*P._y+F._z*P._z+F._w*P._w,A=!1;if(H<0&&(A=!0,H=-H),H>.999999)q=1-f,N=A?-f:f;else{const F=Math.acos(H),P=1/Math.sin(F);q=Math.sin((1-f)*F)*P,N=A?-Math.sin(f*F)*P:Math.sin(f*F)*P}return c._x=q*F._x+N*P._x,c._y=q*F._y+N*P._y,c._z=q*F._z+N*P._z,c._w=q*F._w+N*P._w,c._isDirty=!0,c}static Hermite(F,P,f,c,N){const q=N*N,H=N*q,A=2*H-3*q+1,o=-2*H+3*q,j=H-2*q+N,i=H-q,u=F._x*A+f._x*o+P._x*j+c._x*i,T=F._y*A+f._y*o+P._y*j+c._y*i,Y=F._z*A+f._z*o+P._z*j+c._z*i,t=F._w*A+f._w*o+P._w*j+c._w*i;return new J(u,T,Y,t)}static Hermite1stDerivative(F,P,f,c,N){const q=new J;return this.Hermite1stDerivativeToRef(F,P,f,c,N,q),q}static Hermite1stDerivativeToRef(F,P,f,c,N,q){const H=N*N;return q._x=6*(H-N)*F._x+(3*H-4*N+1)*P._x+6*(-H+N)*f._x+(3*H-2*N)*c._x,q._y=6*(H-N)*F._y+(3*H-4*N+1)*P._y+6*(-H+N)*f._y+(3*H-2*N)*c._y,q._z=6*(H-N)*F._z+(3*H-4*N+1)*P._z+6*(-H+N)*f._z+(3*H-2*N)*c._z,q._w=6*(H-N)*F._w+(3*H-4*N+1)*P._w+6*(-H+N)*f._w+(3*H-2*N)*c._w,q._isDirty=!0,q}static Normalize(F){const P=J.Zero();return J.NormalizeToRef(F,P),P}static NormalizeToRef(F,P){return F.normalizeToRef(P),P}static Clamp(F,P,f){const c=new J;return J.ClampToRef(F,P,f,c),c}static ClampToRef(F,P,f,c){return c.fc((0,o.Clamp)(F.x,P.x,f.x),(0,o.Clamp)(F.y,P.y,f.y),(0,o.Clamp)(F.z,P.z,f.z),(0,o.Clamp)(F.w,P.w,f.w))}static Random(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new J((0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P))}static RandomToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).fc((0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P),(0,o.RandomRange)(F,P))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(F,P){return Math.sqrt(J.DistanceSquared(F,P))}static DistanceSquared(F,P){const f=F.x-P.x,c=F.y-P.y,N=F.z-P.z,q=F.w-P.w;return f*f+c*c+N*N+q*q}static Center(F,P){return J.CenterToRef(F,P,J.Zero())}static CenterToRef(F,P,f){return f.fc((F.x+P.x)/2,(F.y+P.y)/2,(F.z+P.z)/2,(F.w+P.w)/2)}}J._V8PerformanceHack=new J(.5,.5,.5,.5),Object.defineProperties(J.prototype,{dimension:{value:[4]},rank:{value:1}});class B{static get Use64Bits(){return H.e.MatrixUse64Bits}get m(){return this.Qf}markAsUpdated(){this.updateFlag=j._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(F){let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1],f=arguments.length>2&&void 0!==arguments[2]&&arguments[2],c=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=F,this._isIdentity3x2=F||f,this._isIdentityDirty=!this._isIdentity&&P,this._isIdentity3x2Dirty=!this._isIdentity3x2&&c}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,H.e.MatrixTrackPrecisionChange&&H.e.MatrixTrackedMatrices.push(this),this.Qf=new H.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const F=this.Qf;this._isIdentity=1===F[0]&&0===F[1]&&0===F[2]&&0===F[3]&&0===F[4]&&1===F[5]&&0===F[6]&&0===F[7]&&0===F[8]&&0===F[9]&&1===F[10]&&0===F[11]&&0===F[12]&&0===F[13]&&0===F[14]&&1===F[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Qf[0]||1!==this.Qf[5]||1!==this.Qf[15]||0!==this.Qf[1]||0!==this.Qf[2]||0!==this.Qf[3]||0!==this.Qf[4]||0!==this.Qf[6]||0!==this.Qf[7]||0!==this.Qf[8]||0!==this.Qf[9]||0!==this.Qf[10]||0!==this.Qf[11]||0!==this.Qf[12]||0!==this.Qf[13]||0!==this.Qf[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const F=this.Qf,P=F[0],f=F[1],c=F[2],N=F[3],q=F[4],H=F[5],A=F[6],o=F[7],j=F[8],i=F[9],u=F[10],T=F[11],Y=F[12],t=F[13],C=F[14],L=F[15],J=u*L-C*T,B=i*L-t*T,z=i*C-t*u,Z=j*L-Y*T,R=j*C-u*Y,y=j*t-Y*i;return P*+(H*J-A*B+o*z)+f*-(q*J-A*Z+o*R)+c*+(q*B-H*Z+o*y)+N*-(q*z-H*R+A*y)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!F)return this.Qf;const f=this.Qf;for(let c=0;c<16;c++)F[P+c]=f[c];return this}pf(){return this.Qf}Zf(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B.FromArrayToRef(F,P,this)}fc(){for(var F=arguments.length,P=new Array(F),f=0;f<F;f++)P[f]=arguments[f];return B.FromArrayToRef(P,0,this)}set(){const F=this.Qf;for(let P=0;P<16;P++)F[P]=P<0||arguments.length<=P?void 0:arguments[P];return this.markAsUpdated(),this}Nc(F){const P=this.Qf;for(let f=0;f<16;f++)P[f]=F;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return B.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(F){const P=new B;return this.addToRef(F,P),P}addToRef(F,P){const f=this.Qf,c=P.Qf,N=F.m;for(let q=0;q<16;q++)c[q]=f[q]+N[q];return P.markAsUpdated(),P}addToSelf(F){const P=this.Qf,f=F.m;return P[0]+=f[0],P[1]+=f[1],P[2]+=f[2],P[3]+=f[3],P[4]+=f[4],P[5]+=f[5],P[6]+=f[6],P[7]+=f[7],P[8]+=f[8],P[9]+=f[9],P[10]+=f[10],P[11]+=f[11],P[12]+=f[12],P[13]+=f[13],P[14]+=f[14],P[15]+=f[15],this.markAsUpdated(),this}addInPlace(F){const P=this.Qf,f=F.m;for(let c=0;c<16;c++)P[c]+=f[c];return this.markAsUpdated(),this}addInPlaceFromFloats(){const F=this.Qf;for(let P=0;P<16;P++)F[P]+=P<0||arguments.length<=P?void 0:arguments[P];return this.markAsUpdated(),this}CP(F){const P=this.Qf,f=F.m;for(let c=0;c<16;c++)P[c]-=f[c];return this.markAsUpdated(),this}subtractToRef(F,P){const f=this.Qf,c=F.m,N=P.Qf;for(let q=0;q<16;q++)N[q]=f[q]-c[q];return P.markAsUpdated(),P}Ou(F){const P=this.Qf,f=F.m;for(let c=0;c<16;c++)P[c]-=f[c];return this.markAsUpdated(),this}subtractFromFloats(){for(var F=arguments.length,P=new Array(F),f=0;f<F;f++)P[f]=arguments[f];return this.subtractFromFloatsToRef(...P,new B)}subtractFromFloatsToRef(){for(var F=arguments.length,P=new Array(F),f=0;f<F;f++)P[f]=arguments[f];const c=P.pop(),N=this.Qf,q=c.Qf,H=P;for(let A=0;A<16;A++)q[A]=N[A]-H[A];return c.markAsUpdated(),c}invertToRef(F){return!0===this._isIdentity?(B.IdentityToRef(F),F):(T(this,F.pf())?F.markAsUpdated():F.q(this),F)}addAtIndex(F,P){return this.Qf[F]+=P,this.markAsUpdated(),this}multiplyAtIndex(F,P){return this.Qf[F]*=P,this.markAsUpdated(),this}setTranslationFromFloats(F,P,f){return this.Qf[12]=F,this.Qf[13]=P,this.Qf[14]=f,this.markAsUpdated(),this}addTranslationFromFloats(F,P,f){return this.Qf[12]+=F,this.Qf[13]+=P,this.Qf[14]+=f,this.markAsUpdated(),this}setTranslation(F){return this.setTranslationFromFloats(F._x,F._y,F._z)}getTranslation(){return new C(this.Qf[12],this.Qf[13],this.Qf[14])}getTranslationToRef(F){return F.x=this.Qf[12],F.y=this.Qf[13],F.z=this.Qf[14],F}removeRotationAndScaling(){const F=this.m;return B.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,F[12],F[13],F[14],F[15],this),this._updateIdentityStatus(0===F[12]&&0===F[13]&&0===F[14]&&1===F[15]),this}q(F){F.copyToArray(this.Qf);const P=F;return this.updateFlag=P.updateFlag,this._updateIdentityStatus(P._isIdentity,P._isIdentityDirty,P._isIdentity3x2,P._isIdentity3x2Dirty),this}copyToArray(F){return u(this,F,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(F){const P=new B;return this.multiplyToRef(F,P),P}multiplyInPlace(F){const P=this.Qf,f=F.m;for(let c=0;c<16;c++)P[c]*=f[c];return this.markAsUpdated(),this}multiplyByFloats(){const F=this.Qf;for(let P=0;P<16;P++)F[P]*=P<0||arguments.length<=P?void 0:arguments[P];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var F=arguments.length,P=new Array(F),f=0;f<F;f++)P[f]=arguments[f];const c=P.pop(),N=this.Qf,q=c.Qf,H=P;for(let A=0;A<16;A++)q[A]=N[A]*H[A];return c.markAsUpdated(),c}multiplyToRef(F,P){return this._isIdentity?(P.q(F),P):F._isIdentity?(P.q(this),P):(this.multiplyToArray(F,P.Qf,0),P.markAsUpdated(),P)}multiplyToArray(F,P,f){return i(this,F,P,f),this}divide(F){return this.divideToRef(F,new B)}divideToRef(F,P){const f=this.Qf,c=F.m,N=P.Qf;for(let q=0;q<16;q++)N[q]=f[q]/c[q];return P.markAsUpdated(),P}divideInPlace(F){const P=this.Qf,f=F.m;for(let c=0;c<16;c++)P[c]/=f[c];return this.markAsUpdated(),this}minimizeInPlace(F){const P=this.Qf,f=F.m;for(let c=0;c<16;c++)P[c]=Math.min(P[c],f[c]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const F=this.Qf;for(let P=0;P<16;P++)F[P]=Math.min(F[P],P<0||arguments.length<=P?void 0:arguments[P]);return this.markAsUpdated(),this}maximizeInPlace(F){const P=this.Qf,f=F.m;for(let c=0;c<16;c++)P[c]=Math.min(P[c],f[c]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const F=this.Qf;for(let P=0;P<16;P++)F[P]=Math.min(F[P],P<0||arguments.length<=P?void 0:arguments[P]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new B)}negateInPlace(){const F=this.Qf;for(let P=0;P<16;P++)F[P]=-F[P];return this.markAsUpdated(),this}negateToRef(F){const P=this.Qf,f=F.Qf;for(let c=0;c<16;c++)f[c]=-P[c];return F.markAsUpdated(),F}equals(F){const P=F;if(!P)return!1;if((this._isIdentity||P._isIdentity)&&!this._isIdentityDirty&&!P._isIdentityDirty)return this._isIdentity&&P._isIdentity;const f=this.m,c=P.m;return f[0]===c[0]&&f[1]===c[1]&&f[2]===c[2]&&f[3]===c[3]&&f[4]===c[4]&&f[5]===c[5]&&f[6]===c[6]&&f[7]===c[7]&&f[8]===c[8]&&f[9]===c[9]&&f[10]===c[10]&&f[11]===c[11]&&f[12]===c[12]&&f[13]===c[13]&&f[14]===c[14]&&f[15]===c[15]}equalsWithEpsilon(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const f=this.Qf,c=F.m;for(let N=0;N<16;N++)if(!(0,o.WithinEpsilon)(f[N],c[N],P))return!1;return!0}equalsToFloats(){const F=this.Qf;for(let P=0;P<16;P++)if(F[P]!=(P<0||arguments.length<=P?void 0:arguments[P]))return!1;return!0}floor(){return this.floorToRef(new B)}floorToRef(F){const P=this.Qf,f=F.Qf;for(let c=0;c<16;c++)f[c]=Math.floor(P[c]);return F.markAsUpdated(),F}fract(){return this.fractToRef(new B)}fractToRef(F){const P=this.Qf,f=F.Qf;for(let c=0;c<16;c++)f[c]=P[c]-Math.floor(P[c]);return F.markAsUpdated(),F}clone(){const F=new B;return F.q(this),F}getClassName(){return"Matrix"}getHashCode(){let F=Y(this.Qf[0]);for(let P=1;P<16;P++)F=397*F^Y(this.Qf[P]);return F}decomposeToTransformNode(F){return F.rotationQuaternion=F.rotationQuaternion||new J,this.decompose(F.cc,F.rotationQuaternion,F.position)}decompose(F,P,f,c){let N=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return f&&f.Nc(0),F&&F.Nc(1),P&&P.fc(0,0,0,1),!0;const q=this.Qf;if(f&&f.fc(q[12],q[13],q[14]),(F=F||z.tP[0]).x=Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]),F.y=Math.sqrt(q[4]*q[4]+q[5]*q[5]+q[6]*q[6]),F.z=Math.sqrt(q[8]*q[8]+q[9]*q[9]+q[10]*q[10]),c){const P=(N?c.absoluteScaling.x:c.cc.x)<0?-1:1,f=(N?c.absoluteScaling.y:c.cc.y)<0?-1:1,q=(N?c.absoluteScaling.z:c.cc.z)<0?-1:1;F.x*=P,F.y*=f,F.z*=q}else this.determinant()<=0&&(F.y*=-1);if(0===F._x||0===F._y||0===F._z)return P&&P.fc(0,0,0,1),!1;if(P){const f=1/F._x,c=1/F._y,N=1/F._z;B.FromValuesToRef(q[0]*f,q[1]*f,q[2]*f,0,q[4]*c,q[5]*c,q[6]*c,0,q[8]*N,q[9]*N,q[10]*N,0,0,0,0,1,z.Matrix[0]),J.FromRotationMatrixToRef(z.Matrix[0],P)}return!0}getRow(F){if(F<0||F>3)return null;const P=4*F;return new L(this.Qf[P+0],this.Qf[P+1],this.Qf[P+2],this.Qf[P+3])}getRowToRef(F,P){if(F>=0&&F<=3){const f=4*F;P.x=this.Qf[f+0],P.y=this.Qf[f+1],P.z=this.Qf[f+2],P.w=this.Qf[f+3]}return P}setRow(F,P){return this.setRowFromFloats(F,P.x,P.y,P.z,P.w)}transpose(){const F=new B;return B.TransposeToRef(this,F),F}transposeToRef(F){return B.TransposeToRef(this,F),F}setRowFromFloats(F,P,f,c,N){if(F<0||F>3)return this;const q=4*F;return this.Qf[q+0]=P,this.Qf[q+1]=f,this.Qf[q+2]=c,this.Qf[q+3]=N,this.markAsUpdated(),this}scale(F){const P=new B;return this.scaleToRef(F,P),P}scaleToRef(F,P){for(let f=0;f<16;f++)P.Qf[f]=this.Qf[f]*F;return P.markAsUpdated(),P}scaleAndAddToRef(F,P){for(let f=0;f<16;f++)P.Qf[f]+=this.Qf[f]*F;return P.markAsUpdated(),P}scaleInPlace(F){const P=this.Qf;for(let f=0;f<16;f++)P[f]*=F;return this.markAsUpdated(),this}toNormalMatrix(F){const P=z.Matrix[0];this.invertToRef(P),P.transposeToRef(F);const f=F.Qf;return B.FromValuesToRef(f[0],f[1],f[2],0,f[4],f[5],f[6],0,f[8],f[9],f[10],0,0,0,0,1,F),F}getRotationMatrix(){const F=new B;return this.getRotationMatrixToRef(F),F}getRotationMatrixToRef(F){const P=z.tP[0];if(!this.decompose(P))return B.IdentityToRef(F),F;const f=this.Qf,c=1/P._x,N=1/P._y,q=1/P._z;return B.FromValuesToRef(f[0]*c,f[1]*c,f[2]*c,0,f[4]*N,f[5]*N,f[6]*N,0,f[8]*q,f[9]*q,f[10]*q,0,0,0,0,1,F),F}toggleModelMatrixHandInPlace(){const F=this.Qf;return F[2]*=-1,F[6]*=-1,F[8]*=-1,F[9]*=-1,F[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const F=this.Qf;return F[8]*=-1,F[9]*=-1,F[10]*=-1,F[11]*=-1,this.markAsUpdated(),this}static zP(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const f=new B;return B.FromArrayToRef(F,P,f),f}static FromArrayToRef(F,P,f){for(let c=0;c<16;c++)f.Qf[c]=F[c+P];return f.markAsUpdated(),f}static FromFloat32ArrayToRefScaled(F,P,f,c){return c.Qf[0]=F[0+P]*f,c.Qf[1]=F[1+P]*f,c.Qf[2]=F[2+P]*f,c.Qf[3]=F[3+P]*f,c.Qf[4]=F[4+P]*f,c.Qf[5]=F[5+P]*f,c.Qf[6]=F[6+P]*f,c.Qf[7]=F[7+P]*f,c.Qf[8]=F[8+P]*f,c.Qf[9]=F[9+P]*f,c.Qf[10]=F[10+P]*f,c.Qf[11]=F[11+P]*f,c.Qf[12]=F[12+P]*f,c.Qf[13]=F[13+P]*f,c.Qf[14]=F[14+P]*f,c.Qf[15]=F[15+P]*f,c.markAsUpdated(),c}static get IdentityReadOnly(){return B._IdentityReadOnly}static FromValuesToRef(F,P,f,c,N,q,H,A,o,j,i,u,T,Y,t,C,L){const J=L.Qf;J[0]=F,J[1]=P,J[2]=f,J[3]=c,J[4]=N,J[5]=q,J[6]=H,J[7]=A,J[8]=o,J[9]=j,J[10]=i,J[11]=u,J[12]=T,J[13]=Y,J[14]=t,J[15]=C,L.markAsUpdated()}static FromValues(F,P,f,c,N,q,H,A,o,j,i,u,T,Y,t,C){const L=new B,J=L.Qf;return J[0]=F,J[1]=P,J[2]=f,J[3]=c,J[4]=N,J[5]=q,J[6]=H,J[7]=A,J[8]=o,J[9]=j,J[10]=i,J[11]=u,J[12]=T,J[13]=Y,J[14]=t,J[15]=C,L.markAsUpdated(),L}static Compose(F,P,f){const c=new B;return B.ComposeToRef(F,P,f,c),c}static ComposeToRef(F,P,f,c){const N=c.Qf,q=P._x,H=P._y,A=P._z,o=P._w,j=q+q,i=H+H,u=A+A,T=q*j,Y=q*i,t=q*u,C=H*i,L=H*u,J=A*u,B=o*j,z=o*i,Z=o*u,R=F._x,y=F._y,O=F._z;return N[0]=(1-(C+J))*R,N[1]=(Y+Z)*R,N[2]=(t-z)*R,N[3]=0,N[4]=(Y-Z)*y,N[5]=(1-(T+J))*y,N[6]=(L+B)*y,N[7]=0,N[8]=(t+z)*O,N[9]=(L-B)*O,N[10]=(1-(T+C))*O,N[11]=0,N[12]=f._x,N[13]=f._y,N[14]=f._z,N[15]=1,c.markAsUpdated(),c}static Identity(){const F=B.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return F._updateIdentityStatus(!0),F}static IdentityToRef(F){return B.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,F),F._updateIdentityStatus(!0),F}static Zero(){const F=B.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return F._updateIdentityStatus(!1),F}static RotationX(F){const P=new B;return B.RotationXToRef(F,P),P}static Invert(F){const P=new B;return F.invertToRef(P),P}static RotationXToRef(F,P){const f=Math.sin(F),c=Math.cos(F);return B.FromValuesToRef(1,0,0,0,0,c,f,0,0,-f,c,0,0,0,0,1,P),P._updateIdentityStatus(1===c&&0===f),P}static RotationY(F){const P=new B;return B.RotationYToRef(F,P),P}static RotationYToRef(F,P){const f=Math.sin(F),c=Math.cos(F);return B.FromValuesToRef(c,0,-f,0,0,1,0,0,f,0,c,0,0,0,0,1,P),P._updateIdentityStatus(1===c&&0===f),P}static RotationZ(F){const P=new B;return B.RotationZToRef(F,P),P}static RotationZToRef(F,P){const f=Math.sin(F),c=Math.cos(F);return B.FromValuesToRef(c,f,0,0,-f,c,0,0,0,0,1,0,0,0,0,1,P),P._updateIdentityStatus(1===c&&0===f),P}static RotationAxis(F,P){const f=new B;return B.RotationAxisToRef(F,P,f),f}static RotationAxisToRef(F,P,f){const c=Math.sin(-P),N=Math.cos(-P),q=1-N;F=F.normalizeToRef(z.tP[0]);const H=f.Qf;return H[0]=F._x*F._x*q+N,H[1]=F._x*F._y*q-F._z*c,H[2]=F._x*F._z*q+F._y*c,H[3]=0,H[4]=F._y*F._x*q+F._z*c,H[5]=F._y*F._y*q+N,H[6]=F._y*F._z*q-F._x*c,H[7]=0,H[8]=F._z*F._x*q-F._y*c,H[9]=F._z*F._y*q+F._x*c,H[10]=F._z*F._z*q+N,H[11]=0,H[12]=0,H[13]=0,H[14]=0,H[15]=1,f.markAsUpdated(),f}static RotationAlignToRef(F,P,f){let N=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const q=C.Dot(P,F),H=f.Qf;if(q<-1+c.e)H[0]=-1,H[1]=0,H[2]=0,H[3]=0,H[4]=0,H[5]=N?1:-1,H[6]=0,H[7]=0,H[8]=0,H[9]=0,H[10]=N?-1:1,H[11]=0;else{const f=C.Cross(P,F),c=1/(1+q);H[0]=f._x*f._x*c+q,H[1]=f._y*f._x*c-f._z,H[2]=f._z*f._x*c+f._y,H[3]=0,H[4]=f._x*f._y*c+f._z,H[5]=f._y*f._y*c+q,H[6]=f._z*f._y*c-f._x,H[7]=0,H[8]=f._x*f._z*c-f._y,H[9]=f._y*f._z*c+f._x,H[10]=f._z*f._z*c+q,H[11]=0}return H[12]=0,H[13]=0,H[14]=0,H[15]=1,f.markAsUpdated(),f}static RotationYawPitchRoll(F,P,f){const c=new B;return B.RotationYawPitchRollToRef(F,P,f,c),c}static RotationYawPitchRollToRef(F,P,f,c){return J.RotationYawPitchRollToRef(F,P,f,z.Quaternion[0]),z.Quaternion[0].toRotationMatrix(c),c}static Scaling(F,P,f){const c=new B;return B.ScalingToRef(F,P,f,c),c}static ScalingToRef(F,P,f,c){return B.FromValuesToRef(F,0,0,0,0,P,0,0,0,0,f,0,0,0,0,1,c),c._updateIdentityStatus(1===F&&1===P&&1===f),c}static Translation(F,P,f){const c=new B;return B.TranslationToRef(F,P,f,c),c}static TranslationToRef(F,P,f,c){return B.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,F,P,f,1,c),c._updateIdentityStatus(0===F&&0===P&&0===f),c}static Lerp(F,P,f){const c=new B;return B.LerpToRef(F,P,f,c),c}static LerpToRef(F,P,f,c){const N=c.Qf,q=F.m,H=P.m;for(let A=0;A<16;A++)N[A]=q[A]*(1-f)+H[A]*f;return c.markAsUpdated(),c}static DecomposeLerp(F,P,f){const c=new B;return B.DecomposeLerpToRef(F,P,f,c),c}static DecomposeLerpToRef(F,P,f,c){const N=z.tP[0],q=z.Quaternion[0],H=z.tP[1];F.decompose(N,q,H);const A=z.tP[2],o=z.Quaternion[1],j=z.tP[3];P.decompose(A,o,j);const i=z.tP[4];C.LerpToRef(N,A,f,i);const u=z.Quaternion[2];J.SlerpToRef(q,o,f,u);const T=z.tP[5];return C.LerpToRef(H,j,f,T),B.ComposeToRef(i,u,T,c),c}static LookAtLH(F,P,f){const c=new B;return B.LookAtLHToRef(F,P,f,c),c}static LookAtLHToRef(F,P,f,c){const N=z.tP[0],q=z.tP[1],H=z.tP[2];P.subtractToRef(F,H),H.normalize(),C.CrossToRef(f,H,N);const A=N.lengthSquared();0===A?N.x=1:N.normalizeFromLength(Math.sqrt(A)),C.CrossToRef(H,N,q),q.normalize();const o=-C.Dot(N,F),j=-C.Dot(q,F),i=-C.Dot(H,F);return B.FromValuesToRef(N._x,q._x,H._x,0,N._y,q._y,H._y,0,N._z,q._z,H._z,0,o,j,i,1,c),c}static LookAtRH(F,P,f){const c=new B;return B.LookAtRHToRef(F,P,f,c),c}static LookAtRHToRef(F,P,f,c){const N=z.tP[0],q=z.tP[1],H=z.tP[2];F.subtractToRef(P,H),H.normalize(),C.CrossToRef(f,H,N);const A=N.lengthSquared();0===A?N.x=1:N.normalizeFromLength(Math.sqrt(A)),C.CrossToRef(H,N,q),q.normalize();const o=-C.Dot(N,F),j=-C.Dot(q,F),i=-C.Dot(H,F);return B.FromValuesToRef(N._x,q._x,H._x,0,N._y,q._y,H._y,0,N._z,q._z,H._z,0,o,j,i,1,c),c}static LookDirectionLH(F,P){const f=new B;return B.LookDirectionLHToRef(F,P,f),f}static LookDirectionLHToRef(F,P,f){const c=z.tP[0];c.q(F),c.scaleInPlace(-1);const N=z.tP[1];return C.CrossToRef(P,c,N),B.FromValuesToRef(N._x,N._y,N._z,0,P._x,P._y,P._z,0,c._x,c._y,c._z,0,0,0,0,1,f),f}static LookDirectionRH(F,P){const f=new B;return B.LookDirectionRHToRef(F,P,f),f}static LookDirectionRHToRef(F,P,f){const c=z.tP[2];return C.CrossToRef(P,F,c),B.FromValuesToRef(c._x,c._y,c._z,0,P._x,P._y,P._z,0,F._x,F._y,F._z,0,0,0,0,1,f),f}static OrthoLH(F,P,f,c,N){const q=new B;return B.OrthoLHToRef(F,P,f,c,q,N),q}static OrthoLHToRef(F,P,f,c,N,q){const H=2/F,A=2/P,o=2/(c-f),j=-(c+f)/(c-f);return B.FromValuesToRef(H,0,0,0,0,A,0,0,0,0,o,0,0,0,j,1,N),q&&N.multiplyToRef(R,N),N._updateIdentityStatus(1===H&&1===A&&1===o&&0===j),N}static OrthoOffCenterLH(F,P,f,c,N,q,H){const A=new B;return B.OrthoOffCenterLHToRef(F,P,f,c,N,q,A,H),A}static OrthoOffCenterLHToRef(F,P,f,c,N,q,H,A){const o=2/(P-F),j=2/(c-f),i=2/(q-N),u=-(q+N)/(q-N),T=(F+P)/(F-P),Y=(c+f)/(f-c);return B.FromValuesToRef(o,0,0,0,0,j,0,0,0,0,i,0,T,Y,u,1,H),A&&H.multiplyToRef(R,H),H.markAsUpdated(),H}static ObliqueOffCenterLHToRef(F,P,f,c,N,q,H,A,o,j,i){const u=-H*Math.cos(A),T=-H*Math.sin(A);return B.TranslationToRef(0,0,-o,z.Matrix[1]),B.FromValuesToRef(1,0,0,0,0,1,0,0,u,T,1,0,0,0,0,1,z.Matrix[0]),z.Matrix[1].multiplyToRef(z.Matrix[0],z.Matrix[0]),B.TranslationToRef(0,0,o,z.Matrix[1]),z.Matrix[0].multiplyToRef(z.Matrix[1],z.Matrix[0]),B.OrthoOffCenterLHToRef(F,P,f,c,N,q,j,i),z.Matrix[0].multiplyToRef(j,j),j}static OrthoOffCenterRH(F,P,f,c,N,q,H){const A=new B;return B.OrthoOffCenterRHToRef(F,P,f,c,N,q,A,H),A}static OrthoOffCenterRHToRef(F,P,f,c,N,q,H,A){return B.OrthoOffCenterLHToRef(F,P,f,c,N,q,H,A),H.Qf[10]*=-1,H}static ObliqueOffCenterRHToRef(F,P,f,c,N,q,H,A,o,j,i){const u=H*Math.cos(A),T=H*Math.sin(A);return B.TranslationToRef(0,0,o,z.Matrix[1]),B.FromValuesToRef(1,0,0,0,0,1,0,0,u,T,1,0,0,0,0,1,z.Matrix[0]),z.Matrix[1].multiplyToRef(z.Matrix[0],z.Matrix[0]),B.TranslationToRef(0,0,-o,z.Matrix[1]),z.Matrix[0].multiplyToRef(z.Matrix[1],z.Matrix[0]),B.OrthoOffCenterRHToRef(F,P,f,c,N,q,j,i),z.Matrix[0].multiplyToRef(j,j),j}static PerspectiveLH(F,P,f,c,N){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const H=new B,A=2*f/F,o=2*f/P,j=(c+f)/(c-f),i=-2*c*f/(c-f),u=Math.tan(q);return B.FromValuesToRef(A,0,0,0,0,o,0,u,0,0,j,1,0,0,i,0,H),N&&H.multiplyToRef(R,H),H._updateIdentityStatus(!1),H}static PerspectiveFovLH(F,P,f,c,N){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,H=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const A=new B;return B.PerspectiveFovLHToRef(F,P,f,c,A,!0,N,q,H),A}static PerspectiveFovLHToRef(F,P,f,c,N){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],H=arguments.length>6?arguments[6]:void 0,A=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,o=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const j=f,i=c,u=1/Math.tan(.5*F),T=q?u/P:u,Y=q?u:u*P,t=o&&0===j?-1:0!==i?(i+j)/(i-j):1,C=o&&0===j?2*i:0!==i?-2*i*j/(i-j):-2*j,L=Math.tan(A);return B.FromValuesToRef(T,0,0,0,0,Y,0,L,0,0,t,1,0,0,C,0,N),H&&N.multiplyToRef(R,N),N._updateIdentityStatus(!1),N}static PerspectiveFovReverseLHToRef(F,P,f,c,N){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],H=arguments.length>6?arguments[6]:void 0,A=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const o=1/Math.tan(.5*F),j=q?o/P:o,i=q?o:o*P,u=Math.tan(A);return B.FromValuesToRef(j,0,0,0,0,i,0,u,0,0,-f,1,0,0,1,0,N),H&&N.multiplyToRef(R,N),N._updateIdentityStatus(!1),N}static PerspectiveFovRH(F,P,f,c,N){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,H=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const A=new B;return B.PerspectiveFovRHToRef(F,P,f,c,A,!0,N,q,H),A}static PerspectiveFovRHToRef(F,P,f,c,N){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],H=arguments.length>6?arguments[6]:void 0,A=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,o=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const j=f,i=c,u=1/Math.tan(.5*F),T=q?u/P:u,Y=q?u:u*P,t=o&&0===j?1:0!==i?-(i+j)/(i-j):-1,C=o&&0===j?2*i:0!==i?-2*i*j/(i-j):-2*j,L=Math.tan(A);return B.FromValuesToRef(T,0,0,0,0,Y,0,L,0,0,t,-1,0,0,C,0,N),H&&N.multiplyToRef(R,N),N._updateIdentityStatus(!1),N}static PerspectiveFovReverseRHToRef(F,P,f,c,N){let q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],H=arguments.length>6?arguments[6]:void 0,A=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const o=1/Math.tan(.5*F),j=q?o/P:o,i=q?o:o*P,u=Math.tan(A);return B.FromValuesToRef(j,0,0,0,0,i,0,u,0,0,-f,-1,0,0,-1,0,N),H&&N.multiplyToRef(R,N),N._updateIdentityStatus(!1),N}static GetFinalMatrix(F,P,f,c,N,q){const H=F.width,A=F.height,o=F.x,j=F.y,i=B.FromValues(H/2,0,0,0,0,-A/2,0,0,0,0,q-N,0,o+H/2,A/2+j,N,1),u=new B;return P.multiplyToRef(f,u),u.multiplyToRef(c,u),u.multiplyToRef(i,u)}static GetAsMatrix2x2(F){const P=F.m,f=[P[0],P[1],P[4],P[5]];return H.e.MatrixUse64Bits?f:new Float32Array(f)}static GetAsMatrix3x3(F){const P=F.m,f=[P[0],P[1],P[2],P[4],P[5],P[6],P[8],P[9],P[10]];return H.e.MatrixUse64Bits?f:new Float32Array(f)}static Transpose(F){const P=new B;return B.TransposeToRef(F,P),P}static TransposeToRef(F,P){const f=F.m,c=f[0],N=f[4],q=f[8],H=f[12],A=f[1],o=f[5],j=f[9],i=f[13],u=f[2],T=f[6],Y=f[10],t=f[14],C=f[3],L=f[7],J=f[11],B=f[15],z=P.Qf;return z[0]=c,z[1]=N,z[2]=q,z[3]=H,z[4]=A,z[5]=o,z[6]=j,z[7]=i,z[8]=u,z[9]=T,z[10]=Y,z[11]=t,z[12]=C,z[13]=L,z[14]=J,z[15]=B,P.markAsUpdated(),P._updateIdentityStatus(F._isIdentity,F._isIdentityDirty),P}static Reflection(F){const P=new B;return B.ReflectionToRef(F,P),P}static ReflectionToRef(F,P){F.normalize();const f=F.normal.x,c=F.normal.y,N=F.normal.z,q=-2*f,H=-2*c,A=-2*N;return B.FromValuesToRef(q*f+1,H*f,A*f,0,q*c,H*c+1,A*c,0,q*N,H*N,A*N+1,0,q*F.d,H*F.d,A*F.d,1,P),P}static FromXYZAxesToRef(F,P,f,c){return B.FromValuesToRef(F._x,F._y,F._z,0,P._x,P._y,P._z,0,f._x,f._y,f._z,0,0,0,0,1,c),c}static FromQuaternionToRef(F,P){const f=F._x*F._x,c=F._y*F._y,N=F._z*F._z,q=F._x*F._y,H=F._z*F._w,A=F._z*F._x,o=F._y*F._w,j=F._y*F._z,i=F._x*F._w;return P.Qf[0]=1-2*(c+N),P.Qf[1]=2*(q+H),P.Qf[2]=2*(A-o),P.Qf[3]=0,P.Qf[4]=2*(q-H),P.Qf[5]=1-2*(N+f),P.Qf[6]=2*(j+i),P.Qf[7]=0,P.Qf[8]=2*(A+o),P.Qf[9]=2*(j-i),P.Qf[10]=1-2*(c+f),P.Qf[11]=0,P.Qf[12]=0,P.Qf[13]=0,P.Qf[14]=0,P.Qf[15]=1,P.markAsUpdated(),P}}B._IdentityReadOnly=B.Identity(),Object.defineProperties(B.prototype,{dimension:{value:[4,4]},rank:{value:2}});class z{}z.tP=(0,N.f)(11,C.Zero),z.Matrix=(0,N.f)(2,B.Identity),z.Quaternion=(0,N.f)(3,J.Zero);class Z{}Z.Vector2=(0,N.f)(3,t.Zero),Z.tP=(0,N.f)(13,C.Zero),Z.Vector4=(0,N.f)(3,L.Zero),Z.Quaternion=(0,N.f)(3,J.Zero),Z.Matrix=(0,N.f)(8,B.Identity),(0,q.f)("BABYLON.Vector2",t),(0,q.f)("BABYLON.Vector3",C),(0,q.f)("BABYLON.Vector4",L),(0,q.f)("BABYLON.Matrix",B);const R=B.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11655:(F,P,f)=>{function c(F,P){const f=[];for(let c=0;c<F;++c)f.push(P());return f}function N(F,P){return c(F,P)}f.d(P,{e:()=>c,f:()=>N,i:()=>H});const q=["push","splice","pop","shift","unshift"];function H(F,P){const f=q.map((f=>function(F,P,f){const c=F[P];if("function"!==typeof c)return null;const N=function(){const c=F.length,q=N.previous.apply(F,arguments);return f(P,c),q};return c.next=N,N.previous=c,F[P]=N,()=>{const f=N.previous;if(!f)return;const c=N.next;c?(f.next=c,c.previous=f):(f.next=void 0,F[P]=f),N.next=void 0,N.previous=void 0}}(F,f,P)));return()=>{for(const F of f)null===F||void 0===F||F()}}}}]);