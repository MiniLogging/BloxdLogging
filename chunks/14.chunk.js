"use strict";(self.ipz2em9uj1g=self.ipz2em9uj1g||[]).push([[14],{12595:(r,O,W)=>{W.d(O,{c:()=>T,g:()=>C,h:()=>q,i:()=>Q});const q=1/2.2,Q=2.2,C=(1+Math.sqrt(5))/2,T=.001},12602:(r,O,W)=>{function q(r){return parseInt(r.toString().replace(/\W/g,""))}function Q(r,O){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(r-O)<=W}function C(r,O,W){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return r<O-q||r>W+q}function T(r,O){return r===O?r:Math.random()*(O-r)+r}function h(r,O,W){return r+(O-r)*W}function J(r,O,W){let q=b(O-r,360);return q>180&&(q-=360),r+q*g(W)}function mr(r,O,W){let q=0;return q=r!=O?g((W-r)/(O-r)):0,q}function d(r,O,W,q,Q){const C=Q*Q,T=Q*C;return r*(2*T-3*C+1)+W*(-2*T+3*C)+O*(T-2*C+Q)+q*(T-C)}function v(r,O,W,q,Q){const C=Q*Q;return 6*(C-Q)*r+(3*C-4*Q+1)*O+6*(-C+Q)*W+(3*C-2*Q)*q}function g(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(W,Math.max(O,r))}function K(r){return r-=2*Math.PI*Math.floor((r+Math.PI)/(2*Math.PI))}function U(r){const O=r.toString(16);return r<=15?("0"+O).toUpperCase():O.toUpperCase()}function P(r){if(Math.log2)return Math.floor(Math.log2(r));if(r<0)return NaN;if(0===r)return-1/0;let O=0;if(r<1){for(;r<1;)O++,r*=2;O=-O}else if(r>1)for(;r>1;)O++,r=Math.floor(r/2);return O}function b(r,O){return r-Math.floor(r/O)*O}function e(r,O,W){return(r-O)/(W-O)}function Y(r,O,W){return r*(W-O)+O}function G(r,O){let W=b(O-r,360);return W>180&&(W-=360),W}function X(r,O){const W=b(r,2*O);return O-Math.abs(W-O)}function S(r,O,W){let q=g(W);return q=-2*q*q*q+3*q*q,O*q+r*(1-q)}function o(r,O,W){let q=0;return q=Math.abs(O-r)<=W?O:r+Math.sign(O-r)*W,q}function N(r,O,W){const q=G(r,O);let Q=0;return Q=-W<q&&q<W?O:o(r,O=r+q,W),Q}function D(r,O,W){return(r-O)/(W-O)}function p(r,O,W){return(W-O)*r+O}function z(r,O){const W=r%O;return 0===W?O:z(O,W)}W.r(O),W.d(O,{Clamp:()=>g,DeltaAngle:()=>G,Denormalize:()=>Y,ExtractAsInt:()=>q,Hermite:()=>d,Hermite1stDerivative:()=>v,HighestCommonFactor:()=>z,ILog2:()=>P,InverseLerp:()=>mr,Lerp:()=>h,LerpAngle:()=>J,MoveTowards:()=>o,MoveTowardsAngle:()=>N,Normalize:()=>e,NormalizeRadians:()=>K,OutsideRange:()=>C,PercentToRange:()=>p,PingPong:()=>X,RandomRange:()=>T,RangeToPercent:()=>D,Repeat:()=>b,SmoothStep:()=>S,ToHex:()=>U,WithinEpsilon:()=>Q})},12591:(r,O,W)=>{W.r(O),W.d(O,{Matrix:()=>Y,Quaternion:()=>e,TmpVectors:()=>X,Vector2:()=>U,eO:()=>P,Vector4:()=>b});var q=W(12595),Q=W(12600),C=W(12560),T=W(12533),h=W(12484),J=W(12602);class mr{}function d(r,O,W){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const Q=r.Yh(),C=O.Yh(),T=Q[0],h=Q[1],J=Q[2],mr=Q[3],d=Q[4],v=Q[5],g=Q[6],K=Q[7],U=Q[8],P=Q[9],b=Q[10],e=Q[11],Y=Q[12],G=Q[13],X=Q[14],S=Q[15],o=C[0],N=C[1],D=C[2],p=C[3],z=C[4],L=C[5],M=C[6],k=C[7],s=C[8],B=C[9],Z=C[10],E=C[11],R=C[12],V=C[13],a=C[14],t=C[15];W[q]=T*o+h*z+J*s+mr*R,W[q+1]=T*N+h*L+J*B+mr*V,W[q+2]=T*D+h*M+J*Z+mr*a,W[q+3]=T*p+h*k+J*E+mr*t,W[q+4]=d*o+v*z+g*s+K*R,W[q+5]=d*N+v*L+g*B+K*V,W[q+6]=d*D+v*M+g*Z+K*a,W[q+7]=d*p+v*k+g*E+K*t,W[q+8]=U*o+P*z+b*s+e*R,W[q+9]=U*N+P*L+b*B+e*V,W[q+10]=U*D+P*M+b*Z+e*a,W[q+11]=U*p+P*k+b*E+e*t,W[q+12]=Y*o+G*z+X*s+S*R,W[q+13]=Y*N+G*L+X*B+S*V,W[q+14]=Y*D+G*M+X*Z+S*a,W[q+15]=Y*p+G*k+X*E+S*t}function v(r,O){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const q=r.Yh();O[W]=q[0],O[W+1]=q[1],O[W+2]=q[2],O[W+3]=q[3],O[W+4]=q[4],O[W+5]=q[5],O[W+6]=q[6],O[W+7]=q[7],O[W+8]=q[8],O[W+9]=q[9],O[W+10]=q[10],O[W+11]=q[11],O[W+12]=q[12],O[W+13]=q[13],O[W+14]=q[14],O[W+15]=q[15]}function g(r,O){const W=r.Yh(),q=W[0],Q=W[1],C=W[2],T=W[3],h=W[4],J=W[5],mr=W[6],d=W[7],v=W[8],g=W[9],K=W[10],U=W[11],P=W[12],b=W[13],e=W[14],Y=W[15],G=K*Y-e*U,X=g*Y-b*U,S=g*e-b*K,o=v*Y-P*U,N=v*e-K*P,D=v*b-P*g,p=+(J*G-mr*X+d*S),z=-(h*G-mr*o+d*N),L=+(h*X-J*o+d*D),M=-(h*S-J*N+mr*D),k=q*p+Q*z+C*L+T*M;if(0===k)return!1;const s=1/k,B=mr*Y-e*d,Z=J*Y-b*d,E=J*e-b*mr,R=h*Y-P*d,V=h*e-P*mr,a=h*b-P*J,t=mr*U-K*d,i=J*U-g*d,l=J*K-g*mr,y=h*U-v*d,w=h*K-v*mr,u=h*g-v*J,n=-(Q*G-C*X+T*S),f=+(q*G-C*o+T*N),F=-(q*X-Q*o+T*D),j=+(q*S-Q*N+C*D),H=+(Q*B-C*Z+T*E),A=-(q*B-C*R+T*V),x=+(q*Z-Q*R+T*a),I=-(q*E-Q*V+C*a),c=-(Q*t-C*i+T*l),rr=+(q*t-C*y+T*w),Or=-(q*i-Q*y+T*u),Wr=+(q*l-Q*w+C*u);return O[0]=p*s,O[1]=n*s,O[2]=H*s,O[3]=c*s,O[4]=z*s,O[5]=f*s,O[6]=A*s,O[7]=rr*s,O[8]=L*s,O[9]=F*s,O[10]=x*s,O[11]=Or*s,O[12]=M*s,O[13]=j*s,O[14]=I*s,O[15]=Wr*s,!0}mr._UpdateFlagSeed=0;const K=r=>parseInt(r.toString().replace(/\W/g,""));class U{constructor(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=r,this.y=O}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let r=K(this.x);return r=397*r^K(this.y),r}toArray(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r[O]=this.x,r[O+1]=this.y,this}eW(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U.FromArrayToRef(r,O,this),this}Yh(){return[this.x,this.y]}C(r){return this.x=r.x,this.y=r.y,this}zh(r,O){return this.x=r,this.y=O,this}set(r,O){return this.zh(r,O)}Mh(r){return this.zh(r,r)}add(r){return new U(this.x+r.x,this.y+r.y)}addToRef(r,O){return O.x=this.x+r.x,O.y=this.y+r.y,O}addInPlace(r){return this.x+=r.x,this.y+=r.y,this}addInPlaceFromFloats(r,O){return this.x+=r,this.y+=O,this}addVector3(r){return new U(this.x+r.x,this.y+r.y)}YO(r){return new U(this.x-r.x,this.y-r.y)}subtractToRef(r,O){return O.x=this.x-r.x,O.y=this.y-r.y,O}yv(r){return this.x-=r.x,this.y-=r.y,this}multiplyInPlace(r){return this.x*=r.x,this.y*=r.y,this}multiply(r){return new U(this.x*r.x,this.y*r.y)}multiplyToRef(r,O){return O.x=this.x*r.x,O.y=this.y*r.y,O}multiplyByFloats(r,O){return new U(this.x*r,this.y*O)}divide(r){return new U(this.x/r.x,this.y/r.y)}divideToRef(r,O){return O.x=this.x/r.x,O.y=this.y/r.y,O}divideInPlace(r){return this.x=this.x/r.x,this.y=this.y/r.y,this}minimizeInPlace(r){return this.minimizeInPlaceFromFloats(r.x,r.y)}maximizeInPlace(r){return this.maximizeInPlaceFromFloats(r.x,r.y)}minimizeInPlaceFromFloats(r,O){return this.x=Math.min(r,this.x),this.y=Math.min(O,this.y),this}maximizeInPlaceFromFloats(r,O){return this.x=Math.max(r,this.x),this.y=Math.max(O,this.y),this}subtractFromFloats(r,O){return new U(this.x-r,this.y-O)}subtractFromFloatsToRef(r,O,W){return W.x=this.x-r,W.y=this.y-O,W}negate(){return new U(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(r){return r.x=-this.x,r.y=-this.y,r}scaleInPlace(r){return this.x*=r,this.y*=r,this}scale(r){return new U(this.x*r,this.y*r)}scaleToRef(r,O){return O.x=this.x*r,O.y=this.y*r,O}scaleAndAddToRef(r,O){return O.x+=this.x*r,O.y+=this.y*r,O}equals(r){return r&&this.x===r.x&&this.y===r.y}equalsWithEpsilon(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.c;return r&&(0,J.WithinEpsilon)(this.x,r.x,O)&&(0,J.WithinEpsilon)(this.y,r.y,O)}equalsToFloats(r,O){return this.x===r&&this.y===O}floor(){return new U(Math.floor(this.x),Math.floor(this.y))}floorToRef(r){return r.x=Math.floor(this.x),r.y=Math.floor(this.y),r}fract(){return new U(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(r){return r.x=this.x-Math.floor(this.x),r.y=this.y-Math.floor(this.y),r}rotate(r){return this.rotateToRef(r,new U)}rotateToRef(r,O){const W=Math.cos(r),q=Math.sin(r);return O.x=W*this.x-q*this.y,O.y=q*this.x+W*this.y,O}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(r){return 0===r||1===r?this:this.scaleInPlace(1/r)}normalizeToNew(){const r=new U;return this.normalizeToRef(r),r}normalizeToRef(r){const O=this.length();return 0===O&&(r.x=this.x,r.y=this.y),this.scaleToRef(1/O,r)}clone(){return new U(this.x,this.y)}dot(r){return this.x*r.x+this.y*r.y}static Zero(){return new U(0,0)}static One(){return new U(1,1)}static Random(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new U((0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O))}static RandomToRef(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).zh((0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O))}static get ZeroReadOnly(){return U._ZeroReadOnly}static oO(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new U(r[O],r[O+1])}static FromArrayToRef(r,O,W){return W.x=r[O],W.y=r[O+1],W}static FromFloatsToRef(r,O,W){return W.zh(r,O),W}static CatmullRom(r,O,W,q,Q){const C=Q*Q,T=Q*C,h=.5*(2*O.x+(-r.x+W.x)*Q+(2*r.x-5*O.x+4*W.x-q.x)*C+(-r.x+3*O.x-3*W.x+q.x)*T),J=.5*(2*O.y+(-r.y+W.y)*Q+(2*r.y-5*O.y+4*W.y-q.y)*C+(-r.y+3*O.y-3*W.y+q.y)*T);return new U(h,J)}static ClampToRef(r,O,W,q){return q.x=(0,J.Clamp)(r.x,O.x,W.x),q.y=(0,J.Clamp)(r.y,O.y,W.y),q}static Clamp(r,O,W){const q=(0,J.Clamp)(r.x,O.x,W.x),Q=(0,J.Clamp)(r.y,O.y,W.y);return new U(q,Q)}static Hermite(r,O,W,q,Q){const C=Q*Q,T=Q*C,h=2*T-3*C+1,J=-2*T+3*C,mr=T-2*C+Q,d=T-C,v=r.x*h+W.x*J+O.x*mr+q.x*d,g=r.y*h+W.y*J+O.y*mr+q.y*d;return new U(v,g)}static Hermite1stDerivative(r,O,W,q,Q){return this.Hermite1stDerivativeToRef(r,O,W,q,Q,new U)}static Hermite1stDerivativeToRef(r,O,W,q,Q,C){const T=Q*Q;return C.x=6*(T-Q)*r.x+(3*T-4*Q+1)*O.x+6*(-T+Q)*W.x+(3*T-2*Q)*q.x,C.y=6*(T-Q)*r.y+(3*T-4*Q+1)*O.y+6*(-T+Q)*W.y+(3*T-2*Q)*q.y,C}static Lerp(r,O,W){return U.LerpToRef(r,O,W,new U)}static LerpToRef(r,O,W,q){return q.x=r.x+(O.x-r.x)*W,q.y=r.y+(O.y-r.y)*W,q}static Dot(r,O){return r.x*O.x+r.y*O.y}static Normalize(r){return U.NormalizeToRef(r,new U)}static NormalizeToRef(r,O){return r.normalizeToRef(O),O}static Minimize(r,O){const W=r.x<O.x?r.x:O.x,q=r.y<O.y?r.y:O.y;return new U(W,q)}static Maximize(r,O){const W=r.x>O.x?r.x:O.x,q=r.y>O.y?r.y:O.y;return new U(W,q)}static Transform(r,O){return U.TransformToRef(r,O,new U)}static TransformToRef(r,O,W){const q=O.m,Q=r.x*q[0]+r.y*q[4]+q[12],C=r.x*q[1]+r.y*q[5]+q[13];return W.x=Q,W.y=C,W}static PointInTriangle(r,O,W,q){const Q=.5*(-W.y*q.x+O.y*(-W.x+q.x)+O.x*(W.y-q.y)+W.x*q.y),C=Q<0?-1:1,T=(O.y*q.x-O.x*q.y+(q.y-O.y)*r.x+(O.x-q.x)*r.y)*C,h=(O.x*W.y-O.y*W.x+(O.y-W.y)*r.x+(W.x-O.x)*r.y)*C;return T>0&&h>0&&T+h<2*Q*C}static Distance(r,O){return Math.sqrt(U.DistanceSquared(r,O))}static DistanceSquared(r,O){const W=r.x-O.x,q=r.y-O.y;return W*W+q*q}static Center(r,O){return U.CenterToRef(r,O,new U)}static CenterToRef(r,O,W){return W.zh((r.x+O.x)/2,(r.y+O.y)/2)}static DistanceOfPointFromSegment(r,O,W){const q=U.DistanceSquared(O,W);if(0===q)return U.Distance(r,O);const Q=W.YO(O),C=Math.max(0,Math.min(1,U.Dot(r.YO(O),Q)/q)),T=O.add(Q.multiplyByFloats(C,C));return U.Distance(r,T)}}U._V8PerformanceHack=new U(.5,.5),U._ZeroReadOnly=U.Zero(),Object.defineProperties(U.prototype,{dimension:{value:[2]},rank:{value:1}});class P{get x(){return this._x}set x(r){this._x=r,this._isDirty=!0}get y(){return this._y}set y(r){this._y=r,this._isDirty=!0}get z(){return this._z}set z(r){this._z=r,this._isDirty=!0}constructor(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=r,this._y=O,this._z=W}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"eO"}getHashCode(){let r=K(this._x);return r=397*r^K(this._y),r=397*r^K(this._z),r}Yh(){return[this._x,this._y,this._z]}toArray(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r[O]=this._x,r[O+1]=this._y,r[O+2]=this._z,this}eW(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(r,O,this),this}toQuaternion(){return e.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(r){return this._x+=r._x,this._y+=r._y,this._z+=r._z,this._isDirty=!0,this}addInPlaceFromFloats(r,O,W){return this._x+=r,this._y+=O,this._z+=W,this._isDirty=!0,this}add(r){return new P(this._x+r._x,this._y+r._y,this._z+r._z)}addToRef(r,O){return O._x=this._x+r._x,O._y=this._y+r._y,O._z=this._z+r._z,O._isDirty=!0,O}yv(r){return this._x-=r._x,this._y-=r._y,this._z-=r._z,this._isDirty=!0,this}YO(r){return new P(this._x-r._x,this._y-r._y,this._z-r._z)}subtractToRef(r,O){return this.subtractFromFloatsToRef(r._x,r._y,r._z,O)}subtractFromFloats(r,O,W){return new P(this._x-r,this._y-O,this._z-W)}subtractFromFloatsToRef(r,O,W,q){return q._x=this._x-r,q._y=this._y-O,q._z=this._z-W,q._isDirty=!0,q}negate(){return new P(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(r){return r._x=-1*this._x,r._y=-1*this._y,r._z=-1*this._z,r._isDirty=!0,r}scaleInPlace(r){return this._x*=r,this._y*=r,this._z*=r,this._isDirty=!0,this}scale(r){return new P(this._x*r,this._y*r,this._z*r)}scaleToRef(r,O){return O._x=this._x*r,O._y=this._y*r,O._z=this._z*r,O._isDirty=!0,O}getNormalToRef(r){const O=this.length();let W=Math.acos(this._y/O);const q=Math.atan2(this._z,this._x);W>Math.PI/2?W-=Math.PI/2:W+=Math.PI/2;const Q=O*Math.sin(W)*Math.cos(q),C=O*Math.cos(W),T=O*Math.sin(W)*Math.sin(q);return r.set(Q,C,T),r}applyRotationQuaternionToRef(r,O){const W=this._x,q=this._y,Q=this._z,C=r._x,T=r._y,h=r._z,J=r._w,mr=2*(T*Q-h*q),d=2*(h*W-C*Q),v=2*(C*q-T*W);return O._x=W+J*mr+T*v-h*d,O._y=q+J*d+h*mr-C*v,O._z=Q+J*v+C*d-T*mr,O._isDirty=!0,O}applyRotationQuaternionInPlace(r){return this.applyRotationQuaternionToRef(r,this)}applyRotationQuaternion(r){return this.applyRotationQuaternionToRef(r,new P)}scaleAndAddToRef(r,O){return O._x+=this._x*r,O._y+=this._y*r,O._z+=this._z*r,O._isDirty=!0,O}projectOnPlane(r,O){return this.projectOnPlaneToRef(r,O,new P)}projectOnPlaneToRef(r,O,W){const q=r.normal,Q=r.d,C=G.eO[0];this.subtractToRef(O,C),C.normalize();const T=P.Dot(C,q);if(Math.abs(T)<1e-10)W.Mh(1/0);else{const r=-(P.Dot(O,q)+Q)/T,h=C.scaleInPlace(r);O.addToRef(h,W)}return W}equals(r){return r&&this._x===r._x&&this._y===r._y&&this._z===r._z}equalsWithEpsilon(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.c;return r&&(0,J.WithinEpsilon)(this._x,r._x,O)&&(0,J.WithinEpsilon)(this._y,r._y,O)&&(0,J.WithinEpsilon)(this._z,r._z,O)}equalsToFloats(r,O,W){return this._x===r&&this._y===O&&this._z===W}multiplyInPlace(r){return this._x*=r._x,this._y*=r._y,this._z*=r._z,this._isDirty=!0,this}multiply(r){return this.multiplyByFloats(r._x,r._y,r._z)}multiplyToRef(r,O){return O._x=this._x*r._x,O._y=this._y*r._y,O._z=this._z*r._z,O._isDirty=!0,O}multiplyByFloats(r,O,W){return new P(this._x*r,this._y*O,this._z*W)}divide(r){return new P(this._x/r._x,this._y/r._y,this._z/r._z)}divideToRef(r,O){return O._x=this._x/r._x,O._y=this._y/r._y,O._z=this._z/r._z,O._isDirty=!0,O}divideInPlace(r){return this._x=this._x/r._x,this._y=this._y/r._y,this._z=this._z/r._z,this._isDirty=!0,this}minimizeInPlace(r){return this.minimizeInPlaceFromFloats(r._x,r._y,r._z)}maximizeInPlace(r){return this.maximizeInPlaceFromFloats(r._x,r._y,r._z)}minimizeInPlaceFromFloats(r,O,W){return r<this._x&&(this.x=r),O<this._y&&(this.y=O),W<this._z&&(this.z=W),this}maximizeInPlaceFromFloats(r,O,W){return r>this._x&&(this.x=r),O>this._y&&(this.y=O),W>this._z&&(this.z=W),this}isNonUniformWithinEpsilon(r){const O=Math.abs(this._x),W=Math.abs(this._y);if(!(0,J.WithinEpsilon)(O,W,r))return!0;const q=Math.abs(this._z);return!(0,J.WithinEpsilon)(O,q,r)||!(0,J.WithinEpsilon)(W,q,r)}get isNonUniform(){const r=Math.abs(this._x);if(r!==Math.abs(this._y))return!0;return r!==Math.abs(this._z)}floorToRef(r){return r._x=Math.floor(this._x),r._y=Math.floor(this._y),r._z=Math.floor(this._z),r._isDirty=!0,r}floor(){return new P(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(r){return r._x=this._x-Math.floor(this._x),r._y=this._y-Math.floor(this._y),r._z=this._z-Math.floor(this._z),r._isDirty=!0,r}fract(){return new P(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(r){if("xyz"===(r=r.toLowerCase()))return this;const O=G.eO[0].C(this);return this.x=O[r[0]],this.y=O[r[1]],this.z=O[r[2]],this}rotateByQuaternionToRef(r,O){return r.toRotationMatrix(G.Matrix[0]),P.TransformCoordinatesToRef(this,G.Matrix[0],O),O}rotateByQuaternionAroundPointToRef(r,O,W){return this.subtractToRef(O,G.eO[0]),G.eO[0].rotateByQuaternionToRef(r,G.eO[0]),O.addToRef(G.eO[0],W),W}cross(r){return P.CrossToRef(this,r,new P)}normalizeFromLength(r){return 0===r||1===r?this:this.scaleInPlace(1/r)}normalizeToNew(){return this.normalizeToRef(new P)}normalizeToRef(r){const O=this.length();return 0===O||1===O?(r._x=this._x,r._y=this._y,r._z=this._z,r._isDirty=!0,r):this.scaleToRef(1/O,r)}clone(){return new P(this._x,this._y,this._z)}C(r){return this.zh(r._x,r._y,r._z)}zh(r,O,W){return this._x=r,this._y=O,this._z=W,this._isDirty=!0,this}set(r,O,W){return this.zh(r,O,W)}Mh(r){return this._x=this._y=this._z=r,this._isDirty=!0,this}static GetClipFactor(r,O,W,q){const Q=P.Dot(r,W);return(Q-q)/(Q-P.Dot(O,W))}static GetAngleBetweenVectors(r,O,W){const q=r.normalizeToRef(G.eO[1]),Q=O.normalizeToRef(G.eO[2]);let C=P.Dot(q,Q);C=(0,J.Clamp)(C,-1,1);const T=Math.acos(C),h=G.eO[3];return P.CrossToRef(q,Q,h),P.Dot(h,W)>0?isNaN(T)?0:T:isNaN(T)?-Math.PI:-Math.acos(C)}static GetAngleBetweenVectorsOnPlane(r,O,W){G.eO[0].C(r);const q=G.eO[0];G.eO[1].C(O);const Q=G.eO[1];G.eO[2].C(W);const C=G.eO[2],T=G.eO[3],h=G.eO[4];q.normalize(),Q.normalize(),C.normalize(),P.CrossToRef(C,q,T),P.CrossToRef(T,C,h);const mr=Math.atan2(P.Dot(Q,T),P.Dot(Q,h));return(0,J.NormalizeRadians)(mr)}static PitchYawRollToMoveBetweenPointsToRef(r,O,W){const q=X.eO[0];return O.subtractToRef(r,q),W._y=Math.atan2(q.x,q.z)||0,W._x=Math.atan2(Math.sqrt(q.x**2+q.z**2),q.y)||0,W._z=0,W._isDirty=!0,W}static PitchYawRollToMoveBetweenPoints(r,O){const W=P.Zero();return P.PitchYawRollToMoveBetweenPointsToRef(r,O,W)}static SlerpToRef(r,O,W,Q){W=(0,J.Clamp)(W,0,1);const C=G.eO[0],T=G.eO[1];C.C(r);const h=C.length();C.normalizeFromLength(h),T.C(O);const mr=T.length();T.normalizeFromLength(mr);const d=P.Dot(C,T);let v,g;if(d<1-q.c){const r=Math.acos(d),O=1/Math.sin(r);v=Math.sin((1-W)*r)*O,g=Math.sin(W*r)*O}else v=1-W,g=W;return C.scaleInPlace(v),T.scaleInPlace(g),Q.C(C).addInPlace(T),Q.scaleInPlace((0,J.Lerp)(h,mr,W)),Q}static SmoothToRef(r,O,W,q,Q){return P.SlerpToRef(r,O,0===q?1:W/q,Q),Q}static oO(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new P(r[O],r[O+1],r[O+2])}static FromFloatArray(r,O){return P.oO(r,O)}static FromArrayToRef(r,O,W){return W._x=r[O],W._y=r[O+1],W._z=r[O+2],W._isDirty=!0,W}static FromFloatArrayToRef(r,O,W){return P.FromArrayToRef(r,O,W)}static FromFloatsToRef(r,O,W,q){return q.zh(r,O,W),q}static Zero(){return new P(0,0,0)}static One(){return new P(1,1,1)}static Up(){return new P(0,1,0)}static get UpReadOnly(){return P._UpReadOnly}static get DownReadOnly(){return P._DownReadOnly}static get RightReadOnly(){return P._RightReadOnly}static get LeftReadOnly(){return P._LeftReadOnly}static get LeftHandedForwardReadOnly(){return P._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return P._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return P._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return P._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return P._ZeroReadOnly}static get OneReadOnly(){return P._OneReadOnly}static Down(){return new P(0,-1,0)}static Forward(){return new P(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new P(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new P(1,0,0)}static Left(){return new P(-1,0,0)}static Random(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new P((0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O))}static RandomToRef(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).zh((0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O))}static TransformCoordinates(r,O){const W=P.Zero();return P.TransformCoordinatesToRef(r,O,W),W}static TransformCoordinatesToRef(r,O,W){return P.TransformCoordinatesFromFloatsToRef(r._x,r._y,r._z,O,W),W}static TransformCoordinatesFromFloatsToRef(r,O,W,q,Q){const C=q.m,T=r*C[0]+O*C[4]+W*C[8]+C[12],h=r*C[1]+O*C[5]+W*C[9]+C[13],J=r*C[2]+O*C[6]+W*C[10]+C[14],mr=1/(r*C[3]+O*C[7]+W*C[11]+C[15]);return Q._x=T*mr,Q._y=h*mr,Q._z=J*mr,Q._isDirty=!0,Q}static TransformNormal(r,O){const W=P.Zero();return P.TransformNormalToRef(r,O,W),W}static TransformNormalToRef(r,O,W){return this.TransformNormalFromFloatsToRef(r._x,r._y,r._z,O,W),W}static TransformNormalFromFloatsToRef(r,O,W,q,Q){const C=q.m;return Q._x=r*C[0]+O*C[4]+W*C[8],Q._y=r*C[1]+O*C[5]+W*C[9],Q._z=r*C[2]+O*C[6]+W*C[10],Q._isDirty=!0,Q}static CatmullRom(r,O,W,q,Q){const C=Q*Q,T=Q*C,h=.5*(2*O._x+(-r._x+W._x)*Q+(2*r._x-5*O._x+4*W._x-q._x)*C+(-r._x+3*O._x-3*W._x+q._x)*T),J=.5*(2*O._y+(-r._y+W._y)*Q+(2*r._y-5*O._y+4*W._y-q._y)*C+(-r._y+3*O._y-3*W._y+q._y)*T),mr=.5*(2*O._z+(-r._z+W._z)*Q+(2*r._z-5*O._z+4*W._z-q._z)*C+(-r._z+3*O._z-3*W._z+q._z)*T);return new P(h,J,mr)}static Clamp(r,O,W){const q=new P;return P.ClampToRef(r,O,W,q),q}static ClampToRef(r,O,W,q){let Q=r._x;Q=Q>W._x?W._x:Q,Q=Q<O._x?O._x:Q;let C=r._y;C=C>W._y?W._y:C,C=C<O._y?O._y:C;let T=r._z;return T=T>W._z?W._z:T,T=T<O._z?O._z:T,q.zh(Q,C,T),q}static CheckExtends(r,O,W){O.minimizeInPlace(r),W.maximizeInPlace(r)}static Hermite(r,O,W,q,Q){const C=Q*Q,T=Q*C,h=2*T-3*C+1,J=-2*T+3*C,mr=T-2*C+Q,d=T-C,v=r._x*h+W._x*J+O._x*mr+q._x*d,g=r._y*h+W._y*J+O._y*mr+q._y*d,K=r._z*h+W._z*J+O._z*mr+q._z*d;return new P(v,g,K)}static Hermite1stDerivative(r,O,W,q,Q){const C=new P;return this.Hermite1stDerivativeToRef(r,O,W,q,Q,C),C}static Hermite1stDerivativeToRef(r,O,W,q,Q,C){const T=Q*Q;return C._x=6*(T-Q)*r._x+(3*T-4*Q+1)*O._x+6*(-T+Q)*W._x+(3*T-2*Q)*q._x,C._y=6*(T-Q)*r._y+(3*T-4*Q+1)*O._y+6*(-T+Q)*W._y+(3*T-2*Q)*q._y,C._z=6*(T-Q)*r._z+(3*T-4*Q+1)*O._z+6*(-T+Q)*W._z+(3*T-2*Q)*q._z,C._isDirty=!0,C}static Lerp(r,O,W){const q=new P(0,0,0);return P.LerpToRef(r,O,W,q),q}static LerpToRef(r,O,W,q){return q._x=r._x+(O._x-r._x)*W,q._y=r._y+(O._y-r._y)*W,q._z=r._z+(O._z-r._z)*W,q._isDirty=!0,q}static Dot(r,O){return r._x*O._x+r._y*O._y+r._z*O._z}dot(r){return this._x*r._x+this._y*r._y+this._z*r._z}static Cross(r,O){const W=new P;return P.CrossToRef(r,O,W),W}static CrossToRef(r,O,W){const q=r._y*O._z-r._z*O._y,Q=r._z*O._x-r._x*O._z,C=r._x*O._y-r._y*O._x;return W.zh(q,Q,C),W}static Normalize(r){const O=P.Zero();return P.NormalizeToRef(r,O),O}static NormalizeToRef(r,O){return r.normalizeToRef(O),O}static Project(r,O,W,q){const Q=new P;return P.ProjectToRef(r,O,W,q,Q),Q}static ProjectToRef(r,O,W,q,Q){var C;const T=q.width,J=q.height,mr=q.x,d=q.y,v=G.Matrix[1],g=null===(C=h.d.LastCreatedEngine)||void 0===C?void 0:C.isNDCHalfZRange,K=g?1:.5,U=g?0:.5;Y.FromValuesToRef(T/2,0,0,0,0,-J/2,0,0,0,0,K,0,mr+T/2,J/2+d,U,1,v);const b=G.Matrix[0];return O.multiplyToRef(W,b),b.multiplyToRef(v,b),P.TransformCoordinatesToRef(r,b,Q),Q}static Reflect(r,O){return this.ReflectToRef(r,O,new P)}static ReflectToRef(r,O,W){const q=X.eO[0];return q.C(O).scaleInPlace(2*P.Dot(r,O)),W.C(r).yv(q)}static _UnprojectFromInvertedMatrixToRef(r,O,W){P.TransformCoordinatesToRef(r,O,W);const q=O.m,Q=r._x*q[3]+r._y*q[7]+r._z*q[11]+q[15];return(0,J.WithinEpsilon)(Q,1)&&W.scaleInPlace(1/Q),W}static UnprojectFromTransform(r,O,W,q,Q){return this.Unproject(r,O,W,q,Q,Y.IdentityReadOnly)}static Unproject(r,O,W,q,Q,C){const T=new P;return P.UnprojectToRef(r,O,W,q,Q,C,T),T}static UnprojectToRef(r,O,W,q,Q,C,T){return P.UnprojectFloatsToRef(r._x,r._y,r._z,O,W,q,Q,C,T),T}static UnprojectFloatsToRef(r,O,W,q,Q,C,T,J,mr){var d;const v=G.Matrix[0];C.multiplyToRef(T,v),v.multiplyToRef(J,v),v.invert();const g=G.eO[0];return g.x=r/q*2-1,g.y=-(O/Q*2-1),null!==(d=h.d.LastCreatedEngine)&&void 0!==d&&d.isNDCHalfZRange?g.z=W:g.z=2*W-1,P._UnprojectFromInvertedMatrixToRef(g,v,mr),mr}static Minimize(r,O){const W=new P;return W.C(r),W.minimizeInPlace(O),W}static Maximize(r,O){const W=new P;return W.C(r),W.maximizeInPlace(O),W}static Distance(r,O){return Math.sqrt(P.DistanceSquared(r,O))}static DistanceSquared(r,O){const W=r._x-O._x,q=r._y-O._y,Q=r._z-O._z;return W*W+q*q+Q*Q}static ProjectOnTriangleToRef(r,O,W,Q,C){const T=G.eO[0],h=G.eO[1],mr=G.eO[2],d=G.eO[3],v=G.eO[4];W.subtractToRef(O,T),Q.subtractToRef(O,h),Q.subtractToRef(W,mr);const g=T.length(),K=h.length(),U=mr.length();if(g<q.c||K<q.c||U<q.c)return C.C(O),P.Distance(r,O);r.subtractToRef(O,v),P.CrossToRef(T,h,d);const b=d.length();if(b<q.c)return C.C(O),P.Distance(r,O);d.normalizeFromLength(b);let e=v.length();if(e<q.c)return C.C(O),0;v.normalizeFromLength(e);const Y=P.Dot(d,v),X=G.eO[5],S=G.eO[6];X.C(d).scaleInPlace(-e*Y),S.C(r).addInPlace(X);const o=G.eO[4],N=G.eO[5],D=G.eO[7],p=G.eO[8];o.C(T).scaleInPlace(1/g),p.C(h).scaleInPlace(1/K),o.addInPlace(p).scaleInPlace(-1),N.C(T).scaleInPlace(-1/g),p.C(mr).scaleInPlace(1/U),N.addInPlace(p).scaleInPlace(-1),D.C(mr).scaleInPlace(-1/U),p.C(h).scaleInPlace(-1/K),D.addInPlace(p).scaleInPlace(-1);const z=G.eO[9];let L;z.C(S).yv(O),P.CrossToRef(o,z,p),L=P.Dot(p,d);const M=L;z.C(S).yv(W),P.CrossToRef(N,z,p),L=P.Dot(p,d);const k=L;z.C(S).yv(Q),P.CrossToRef(D,z,p),L=P.Dot(p,d);const s=L,B=G.eO[10];let Z,E;M>0&&k<0?(B.C(T),Z=O,E=W):k>0&&s<0?(B.C(mr),Z=W,E=Q):(B.C(h).scaleInPlace(-1),Z=Q,E=O);const R=G.eO[9],V=G.eO[4];Z.subtractToRef(S,p),E.subtractToRef(S,R),P.CrossToRef(p,R,V);if(!(P.Dot(V,d)<0))return C.C(S),Math.abs(e*Y);const a=G.eO[5];P.CrossToRef(B,V,a),a.normalize();const t=G.eO[9];t.C(Z).yv(S);const i=t.length();if(i<q.c)return C.C(Z),P.Distance(r,Z);t.normalizeFromLength(i);const l=P.Dot(a,t),y=G.eO[7];y.C(S).addInPlace(a.scaleInPlace(i*l)),p.C(y).yv(Z),e=B.length(),B.normalizeFromLength(e);let w=P.Dot(p,B)/Math.max(e,q.c);return w=(0,J.Clamp)(w,0,1),y.C(Z).addInPlace(B.scaleInPlace(w*e)),C.C(y),P.Distance(r,y)}static Center(r,O){return P.CenterToRef(r,O,P.Zero())}static CenterToRef(r,O,W){return W.zh((r._x+O._x)/2,(r._y+O._y)/2,(r._z+O._z)/2)}static RotationFromAxis(r,O,W){const q=new P;return P.RotationFromAxisToRef(r,O,W,q),q}static RotationFromAxisToRef(r,O,W,q){const Q=G.Quaternion[0];return e.RotationQuaternionFromAxisToRef(r,O,W,Q),Q.toEulerAnglesToRef(q),q}}P._V8PerformanceHack=new P(.5,.5,.5),P._UpReadOnly=P.Up(),P._DownReadOnly=P.Down(),P._LeftHandedForwardReadOnly=P.Forward(!1),P._RightHandedForwardReadOnly=P.Forward(!0),P._LeftHandedBackwardReadOnly=P.Backward(!1),P._RightHandedBackwardReadOnly=P.Backward(!0),P._RightReadOnly=P.Right(),P._LeftReadOnly=P.Left(),P._ZeroReadOnly=P.Zero(),P._OneReadOnly=P.One(),Object.defineProperties(P.prototype,{dimension:{value:[3]},rank:{value:1}});class b{get x(){return this._x}set x(r){this._x=r,this._isDirty=!0}get y(){return this._y}set y(r){this._y=r,this._isDirty=!0}get z(){return this._z}set z(r){this._z=r,this._isDirty=!0}get w(){return this._w}set w(r){this._w=r,this._isDirty=!0}constructor(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=r,this._y=O,this._z=W,this._w=q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let r=K(this._x);return r=397*r^K(this._y),r=397*r^K(this._z),r=397*r^K(this._w),r}Yh(){return[this._x,this._y,this._z,this._w]}toArray(r,O){return void 0===O&&(O=0),r[O]=this._x,r[O+1]=this._y,r[O+2]=this._z,r[O+3]=this._w,this}eW(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b.FromArrayToRef(r,O,this),this}addInPlace(r){return this.x+=r._x,this.y+=r._y,this.z+=r._z,this.w+=r._w,this}addInPlaceFromFloats(r,O,W,q){return this.x+=r,this.y+=O,this.z+=W,this.w+=q,this}add(r){return new b(this._x+r.x,this._y+r.y,this._z+r.z,this._w+r.w)}addToRef(r,O){return O.x=this._x+r.x,O.y=this._y+r.y,O.z=this._z+r.z,O.w=this._w+r.w,O}yv(r){return this.x-=r.x,this.y-=r.y,this.z-=r.z,this.w-=r.w,this}YO(r){return new b(this._x-r.x,this._y-r.y,this._z-r.z,this._w-r.w)}subtractToRef(r,O){return O.x=this._x-r.x,O.y=this._y-r.y,O.z=this._z-r.z,O.w=this._w-r.w,O}subtractFromFloats(r,O,W,q){return new b(this._x-r,this._y-O,this._z-W,this._w-q)}subtractFromFloatsToRef(r,O,W,q,Q){return Q.x=this._x-r,Q.y=this._y-O,Q.z=this._z-W,Q.w=this._w-q,Q}negate(){return new b(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(r){return r.x=-this._x,r.y=-this._y,r.z=-this._z,r.w=-this._w,r}scaleInPlace(r){return this.x*=r,this.y*=r,this.z*=r,this.w*=r,this}scale(r){return new b(this._x*r,this._y*r,this._z*r,this._w*r)}scaleToRef(r,O){return O.x=this._x*r,O.y=this._y*r,O.z=this._z*r,O.w=this._w*r,O}scaleAndAddToRef(r,O){return O.x+=this._x*r,O.y+=this._y*r,O.z+=this._z*r,O.w+=this._w*r,O}equals(r){return r&&this._x===r.x&&this._y===r.y&&this._z===r.z&&this._w===r.w}equalsWithEpsilon(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.c;return r&&(0,J.WithinEpsilon)(this._x,r.x,O)&&(0,J.WithinEpsilon)(this._y,r.y,O)&&(0,J.WithinEpsilon)(this._z,r.z,O)&&(0,J.WithinEpsilon)(this._w,r.w,O)}equalsToFloats(r,O,W,q){return this._x===r&&this._y===O&&this._z===W&&this._w===q}multiplyInPlace(r){return this.x*=r.x,this.y*=r.y,this.z*=r.z,this.w*=r.w,this}multiply(r){return new b(this._x*r.x,this._y*r.y,this._z*r.z,this._w*r.w)}multiplyToRef(r,O){return O.x=this._x*r.x,O.y=this._y*r.y,O.z=this._z*r.z,O.w=this._w*r.w,O}multiplyByFloats(r,O,W,q){return new b(this._x*r,this._y*O,this._z*W,this._w*q)}divide(r){return new b(this._x/r.x,this._y/r.y,this._z/r.z,this._w/r.w)}divideToRef(r,O){return O.x=this._x/r.x,O.y=this._y/r.y,O.z=this._z/r.z,O.w=this._w/r.w,O}divideInPlace(r){return this.divideToRef(r,this)}minimizeInPlace(r){return r.x<this._x&&(this.x=r.x),r.y<this._y&&(this.y=r.y),r.z<this._z&&(this.z=r.z),r.w<this._w&&(this.w=r.w),this}maximizeInPlace(r){return r.x>this._x&&(this.x=r.x),r.y>this._y&&(this.y=r.y),r.z>this._z&&(this.z=r.z),r.w>this._w&&(this.w=r.w),this}minimizeInPlaceFromFloats(r,O,W,q){return this.x=Math.min(r,this._x),this.y=Math.min(O,this._y),this.z=Math.min(W,this._z),this.w=Math.min(q,this._w),this}maximizeInPlaceFromFloats(r,O,W,q){return this.x=Math.max(r,this._x),this.y=Math.max(O,this._y),this.z=Math.max(W,this._z),this.w=Math.max(q,this._w),this}floorToRef(r){return r.x=Math.floor(this._x),r.y=Math.floor(this._y),r.z=Math.floor(this._z),r.w=Math.floor(this._w),r}floor(){return new b(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(r){return r.x=this._x-Math.floor(this._x),r.y=this._y-Math.floor(this._y),r.z=this._z-Math.floor(this._z),r.w=this._w-Math.floor(this._w),r}fract(){return new b(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(r){return 0===r||1===r?this:this.scaleInPlace(1/r)}normalizeToNew(){return this.normalizeToRef(new b)}normalizeToRef(r){const O=this.length();return 0===O||1===O?(r.x=this._x,r.y=this._y,r.z=this._z,r.w=this._w,r):this.scaleToRef(1/O,r)}toVector3(){return new P(this._x,this._y,this._z)}clone(){return new b(this._x,this._y,this._z,this._w)}C(r){return this.x=r.x,this.y=r.y,this.z=r.z,this.w=r.w,this}zh(r,O,W,q){return this.x=r,this.y=O,this.z=W,this.w=q,this}set(r,O,W,q){return this.zh(r,O,W,q)}Mh(r){return this.x=this.y=this.z=this.w=r,this}dot(r){return this._x*r.x+this._y*r.y+this._z*r.z+this._w*r.w}static oO(r,O){return O||(O=0),new b(r[O],r[O+1],r[O+2],r[O+3])}static FromArrayToRef(r,O,W){return W.x=r[O],W.y=r[O+1],W.z=r[O+2],W.w=r[O+3],W}static FromFloatArrayToRef(r,O,W){return b.FromArrayToRef(r,O,W),W}static FromFloatsToRef(r,O,W,q,Q){return Q.x=r,Q.y=O,Q.z=W,Q.w=q,Q}static Zero(){return new b(0,0,0,0)}static One(){return new b(1,1,1,1)}static Random(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new b((0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O))}static RandomToRef(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,W=arguments.length>2?arguments[2]:void 0;return W.x=(0,J.RandomRange)(r,O),W.y=(0,J.RandomRange)(r,O),W.z=(0,J.RandomRange)(r,O),W.w=(0,J.RandomRange)(r,O),W}static Clamp(r,O,W){return b.ClampToRef(r,O,W,new b)}static ClampToRef(r,O,W,q){return q.x=(0,J.Clamp)(r.x,O.x,W.x),q.y=(0,J.Clamp)(r.y,O.y,W.y),q.z=(0,J.Clamp)(r.z,O.z,W.z),q.w=(0,J.Clamp)(r.w,O.w,W.w),q}static CheckExtends(r,O,W){O.minimizeInPlace(r),W.maximizeInPlace(r)}static get ZeroReadOnly(){return b._ZeroReadOnly}static Normalize(r){return b.NormalizeToRef(r,new b)}static NormalizeToRef(r,O){return r.normalizeToRef(O),O}static Minimize(r,O){const W=new b;return W.C(r),W.minimizeInPlace(O),W}static Maximize(r,O){const W=new b;return W.C(r),W.maximizeInPlace(O),W}static Distance(r,O){return Math.sqrt(b.DistanceSquared(r,O))}static DistanceSquared(r,O){const W=r.x-O.x,q=r.y-O.y,Q=r.z-O.z,C=r.w-O.w;return W*W+q*q+Q*Q+C*C}static Center(r,O){return b.CenterToRef(r,O,new b)}static CenterToRef(r,O,W){return W.x=(r.x+O.x)/2,W.y=(r.y+O.y)/2,W.z=(r.z+O.z)/2,W.w=(r.w+O.w)/2,W}static TransformCoordinates(r,O){return b.TransformCoordinatesToRef(r,O,new b)}static TransformCoordinatesToRef(r,O,W){return b.TransformCoordinatesFromFloatsToRef(r._x,r._y,r._z,O,W),W}static TransformCoordinatesFromFloatsToRef(r,O,W,q,Q){const C=q.m,T=r*C[0]+O*C[4]+W*C[8]+C[12],h=r*C[1]+O*C[5]+W*C[9]+C[13],J=r*C[2]+O*C[6]+W*C[10]+C[14],mr=r*C[3]+O*C[7]+W*C[11]+C[15];return Q.x=T,Q.y=h,Q.z=J,Q.w=mr,Q}static TransformNormal(r,O){return b.TransformNormalToRef(r,O,new b)}static TransformNormalToRef(r,O,W){const q=O.m,Q=r.x*q[0]+r.y*q[4]+r.z*q[8],C=r.x*q[1]+r.y*q[5]+r.z*q[9],T=r.x*q[2]+r.y*q[6]+r.z*q[10];return W.x=Q,W.y=C,W.z=T,W.w=r.w,W}static TransformNormalFromFloatsToRef(r,O,W,q,Q,C){const T=Q.m;return C.x=r*T[0]+O*T[4]+W*T[8],C.y=r*T[1]+O*T[5]+W*T[9],C.z=r*T[2]+O*T[6]+W*T[10],C.w=q,C}static FromVector3(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new b(r._x,r._y,r._z,O)}static Dot(r,O){return r.x*O.x+r.y*O.y+r.z*O.z+r.w*O.w}}b._V8PerformanceHack=new b(.5,.5,.5,.5),b._ZeroReadOnly=b.Zero(),Object.defineProperties(b.prototype,{dimension:{value:[4]},rank:{value:1}});class e{get x(){return this._x}set x(r){this._x=r,this._isDirty=!0}get y(){return this._y}set y(r){this._y=r,this._isDirty=!0}get z(){return this._z}set z(r){this._z=r,this._isDirty=!0}get w(){return this._w}set w(r){this._w=r,this._isDirty=!0}constructor(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=r,this._y=O,this._z=W,this._w=q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let r=K(this._x);return r=397*r^K(this._y),r=397*r^K(this._z),r=397*r^K(this._w),r}Yh(){return[this._x,this._y,this._z,this._w]}toArray(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r[O]=this._x,r[O+1]=this._y,r[O+2]=this._z,r[O+3]=this._w,this}eW(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e.FromArrayToRef(r,O,this)}equals(r){return r&&this._x===r._x&&this._y===r._y&&this._z===r._z&&this._w===r._w}equalsWithEpsilon(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.c;return r&&(0,J.WithinEpsilon)(this._x,r._x,O)&&(0,J.WithinEpsilon)(this._y,r._y,O)&&(0,J.WithinEpsilon)(this._z,r._z,O)&&(0,J.WithinEpsilon)(this._w,r._w,O)}isApprox(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.c;return r&&((0,J.WithinEpsilon)(this._x,r._x,O)&&(0,J.WithinEpsilon)(this._y,r._y,O)&&(0,J.WithinEpsilon)(this._z,r._z,O)&&(0,J.WithinEpsilon)(this._w,r._w,O)||(0,J.WithinEpsilon)(this._x,-r._x,O)&&(0,J.WithinEpsilon)(this._y,-r._y,O)&&(0,J.WithinEpsilon)(this._z,-r._z,O)&&(0,J.WithinEpsilon)(this._w,-r._w,O))}clone(){return new e(this._x,this._y,this._z,this._w)}C(r){return this._x=r._x,this._y=r._y,this._z=r._z,this._w=r._w,this._isDirty=!0,this}zh(r,O,W,q){return this._x=r,this._y=O,this._z=W,this._w=q,this._isDirty=!0,this}set(r,O,W,q){return this.zh(r,O,W,q)}Mh(r){return this.zh(r,r,r,r)}add(r){return new e(this._x+r._x,this._y+r._y,this._z+r._z,this._w+r._w)}addInPlace(r){return this._x+=r._x,this._y+=r._y,this._z+=r._z,this._w+=r._w,this._isDirty=!0,this}addToRef(r,O){return O._x=this._x+r._x,O._y=this._y+r._y,O._z=this._z+r._z,O._w=this._w+r._w,O._isDirty=!0,O}addInPlaceFromFloats(r,O,W,q){return this._x+=r,this._y+=O,this._z+=W,this._w+=q,this._isDirty=!0,this}subtractToRef(r,O){return O._x=this._x-r._x,O._y=this._y-r._y,O._z=this._z-r._z,O._w=this._w-r._w,O._isDirty=!0,O}subtractFromFloats(r,O,W,q){return this.subtractFromFloatsToRef(r,O,W,q,new e)}subtractFromFloatsToRef(r,O,W,q,Q){return Q._x=this._x-r,Q._y=this._y-O,Q._z=this._z-W,Q._w=this._w-q,Q._isDirty=!0,Q}YO(r){return new e(this._x-r._x,this._y-r._y,this._z-r._z,this._w-r._w)}yv(r){return this._x-=r._x,this._y-=r._y,this._z-=r._z,this._w-=r._w,this._isDirty=!0,this}scale(r){return new e(this._x*r,this._y*r,this._z*r,this._w*r)}scaleToRef(r,O){return O._x=this._x*r,O._y=this._y*r,O._z=this._z*r,O._w=this._w*r,O._isDirty=!0,O}scaleInPlace(r){return this._x*=r,this._y*=r,this._z*=r,this._w*=r,this._isDirty=!0,this}scaleAndAddToRef(r,O){return O._x+=this._x*r,O._y+=this._y*r,O._z+=this._z*r,O._w+=this._w*r,O._isDirty=!0,O}multiply(r){const O=new e(0,0,0,1);return this.multiplyToRef(r,O),O}multiplyToRef(r,O){const W=this._x*r._w+this._y*r._z-this._z*r._y+this._w*r._x,q=-this._x*r._z+this._y*r._w+this._z*r._x+this._w*r._y,Q=this._x*r._y-this._y*r._x+this._z*r._w+this._w*r._z,C=-this._x*r._x-this._y*r._y-this._z*r._z+this._w*r._w;return O.zh(W,q,Q,C),O}multiplyInPlace(r){return this.multiplyToRef(r,this)}multiplyByFloats(r,O,W,q){return this._x*=r,this._y*=O,this._z*=W,this._w*=q,this._isDirty=!0,this}divide(r){throw new ReferenceError("Can not divide a quaternion")}divideToRef(r,O){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(r){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new e)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(r){return r._x=-this._x,r._y=-this._y,r._z=-this._z,r._w=-this._w,r._isDirty=!0,r}equalsToFloats(r,O,W,q){return this._x===r&&this._y===O&&this._z===W&&this._w===q}floorToRef(r){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(r){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(r){return r.zh(-this._x,-this._y,-this._z,this._w),r}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new e(-this._x,-this._y,-this._z,this._w)}invert(){const r=this.conjugate(),O=this.lengthSquared();return 0==O||1==O||r.scaleInPlace(1/O),r}invertInPlace(){this.conjugateInPlace();const r=this.lengthSquared();return 0==r||1==r||this.scaleInPlace(1/r),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(r){return 0===r||1===r?this:this.scaleInPlace(1/r)}normalizeToNew(){const r=new e(0,0,0,1);return this.normalizeToRef(r),r}normalizeToRef(r){const O=this.length();return 0===O||1===O?r.zh(this._x,this._y,this._z,this._w):this.scaleToRef(1/O,r)}toEulerAngles(){const r=P.Zero();return this.toEulerAnglesToRef(r),r}toEulerAnglesToRef(r){const O=this._z,W=this._x,q=this._y,Q=this._w,C=q*O-W*Q,T=.4999999;if(C<-T)r._y=2*Math.atan2(q,Q),r._x=Math.PI/2,r._z=0,r._isDirty=!0;else if(C>T)r._y=2*Math.atan2(q,Q),r._x=-Math.PI/2,r._z=0,r._isDirty=!0;else{const T=Q*Q,h=O*O,J=W*W,mr=q*q;r._z=Math.atan2(2*(W*q+O*Q),-h-J+mr+T),r._x=Math.asin(-2*C),r._y=Math.atan2(2*(O*W+q*Q),h-J-mr+T),r._isDirty=!0}return r}toAlphaBetaGammaToRef(r){const O=this._z,W=this._x,q=this._y,Q=this._w,C=Math.sqrt(W*W+q*q),T=Math.sqrt(O*O+Q*Q),h=2*Math.atan2(C,T),J=2*Math.atan2(O,Q),mr=2*Math.atan2(q,W),d=(J+mr)/2,v=(J-mr)/2;return r.set(v,h,d),r}toRotationMatrix(r){return Y.FromQuaternionToRef(this,r),r}fromRotationMatrix(r){return e.FromRotationMatrixToRef(r,this),this}dot(r){return this._x*r._x+this._y*r._y+this._z*r._z+this._w*r._w}toAxisAngle(){const r=P.Zero();return{axis:r,angle:this.toAxisAngleToRef(r)}}toAxisAngleToRef(r){let O=0;const W=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),q=this._w;return W>0?(O=2*Math.atan2(W,q),r.set(this._x/W,this._y/W,this._z/W)):(O=0,r.set(1,0,0)),O}static FromRotationMatrix(r){const O=new e;return e.FromRotationMatrixToRef(r,O),O}static FromRotationMatrixToRef(r,O){const W=r.m,q=W[0],Q=W[4],C=W[8],T=W[1],h=W[5],J=W[9],mr=W[2],d=W[6],v=W[10],g=q+h+v;let K;return g>0?(K=.5/Math.sqrt(g+1),O._w=.25/K,O._x=(d-J)*K,O._y=(C-mr)*K,O._z=(T-Q)*K,O._isDirty=!0):q>h&&q>v?(K=2*Math.sqrt(1+q-h-v),O._w=(d-J)/K,O._x=.25*K,O._y=(Q+T)/K,O._z=(C+mr)/K,O._isDirty=!0):h>v?(K=2*Math.sqrt(1+h-q-v),O._w=(C-mr)/K,O._x=(Q+T)/K,O._y=.25*K,O._z=(J+d)/K,O._isDirty=!0):(K=2*Math.sqrt(1+v-q-h),O._w=(T-Q)/K,O._x=(C+mr)/K,O._y=(J+d)/K,O._z=.25*K,O._isDirty=!0),O}static Dot(r,O){return r._x*O._x+r._y*O._y+r._z*O._z+r._w*O._w}static AreClose(r,O){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const q=e.Dot(r,O);return 1-q*q<=W}static SmoothToRef(r,O,W,q,Q){let C=0===q?1:W/q;return C=(0,J.Clamp)(C,0,1),e.SlerpToRef(r,O,C,Q),Q}static Zero(){return new e(0,0,0,0)}static Inverse(r){return new e(-r._x,-r._y,-r._z,r._w)}static InverseToRef(r,O){return O.set(-r._x,-r._y,-r._z,r._w),O}static Identity(){return new e(0,0,0,1)}static IsIdentity(r){return r&&0===r._x&&0===r._y&&0===r._z&&1===r._w}static RotationAxis(r,O){return e.RotationAxisToRef(r,O,new e)}static RotationAxisToRef(r,O,W){W._w=Math.cos(O/2);const q=Math.sin(O/2)/r.length();return W._x=r._x*q,W._y=r._y*q,W._z=r._z*q,W._isDirty=!0,W}static oO(r,O){return O||(O=0),new e(r[O],r[O+1],r[O+2],r[O+3])}static FromArrayToRef(r,O,W){return W._x=r[O],W._y=r[O+1],W._z=r[O+2],W._w=r[O+3],W._isDirty=!0,W}static FromFloatsToRef(r,O,W,q,Q){return Q.zh(r,O,W,q),Q}static FromEulerAngles(r,O,W){const q=new e;return e.RotationYawPitchRollToRef(O,r,W,q),q}static FromEulerAnglesToRef(r,O,W,q){return e.RotationYawPitchRollToRef(O,r,W,q),q}static FromEulerVector(r){const O=new e;return e.RotationYawPitchRollToRef(r._y,r._x,r._z,O),O}static FromEulerVectorToRef(r,O){return e.RotationYawPitchRollToRef(r._y,r._x,r._z,O),O}static FromUnitVectorsToRef(r,O,W){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:q.c;const C=P.Dot(r,O)+1;return C<Q?Math.abs(r.x)>Math.abs(r.z)?W.set(-r.y,r.x,0,0):W.set(0,-r.z,r.y,0):(P.CrossToRef(r,O,X.eO[0]),W.set(X.eO[0].x,X.eO[0].y,X.eO[0].z,C)),W.normalize()}static RotationYawPitchRoll(r,O,W){const q=new e;return e.RotationYawPitchRollToRef(r,O,W,q),q}static RotationYawPitchRollToRef(r,O,W,q){const Q=.5*W,C=.5*O,T=.5*r,h=Math.sin(Q),J=Math.cos(Q),mr=Math.sin(C),d=Math.cos(C),v=Math.sin(T),g=Math.cos(T);return q._x=g*mr*J+v*d*h,q._y=v*d*J-g*mr*h,q._z=g*d*h-v*mr*J,q._w=g*d*J+v*mr*h,q._isDirty=!0,q}static RotationAlphaBetaGamma(r,O,W){const q=new e;return e.RotationAlphaBetaGammaToRef(r,O,W,q),q}static RotationAlphaBetaGammaToRef(r,O,W,q){const Q=.5*(W+r),C=.5*(W-r),T=.5*O;return q._x=Math.cos(C)*Math.sin(T),q._y=Math.sin(C)*Math.sin(T),q._z=Math.sin(Q)*Math.cos(T),q._w=Math.cos(Q)*Math.cos(T),q._isDirty=!0,q}static RotationQuaternionFromAxis(r,O,W){const q=new e(0,0,0,0);return e.RotationQuaternionFromAxisToRef(r,O,W,q),q}static RotationQuaternionFromAxisToRef(r,O,W,q){const Q=G.Matrix[0];return r=r.normalizeToRef(G.eO[0]),O=O.normalizeToRef(G.eO[1]),W=W.normalizeToRef(G.eO[2]),Y.FromXYZAxesToRef(r,O,W,Q),e.FromRotationMatrixToRef(Q,q),q}static FromLookDirectionLH(r,O){const W=new e;return e.FromLookDirectionLHToRef(r,O,W),W}static FromLookDirectionLHToRef(r,O,W){const q=G.Matrix[0];return Y.LookDirectionLHToRef(r,O,q),e.FromRotationMatrixToRef(q,W),W}static FromLookDirectionRH(r,O){const W=new e;return e.FromLookDirectionRHToRef(r,O,W),W}static FromLookDirectionRHToRef(r,O,W){const q=G.Matrix[0];return Y.LookDirectionRHToRef(r,O,q),e.FromRotationMatrixToRef(q,W)}static Slerp(r,O,W){const q=e.Identity();return e.SlerpToRef(r,O,W,q),q}static SlerpToRef(r,O,W,q){let Q,C,T=r._x*O._x+r._y*O._y+r._z*O._z+r._w*O._w,h=!1;if(T<0&&(h=!0,T=-T),T>.999999)C=1-W,Q=h?-W:W;else{const r=Math.acos(T),O=1/Math.sin(r);C=Math.sin((1-W)*r)*O,Q=h?-Math.sin(W*r)*O:Math.sin(W*r)*O}return q._x=C*r._x+Q*O._x,q._y=C*r._y+Q*O._y,q._z=C*r._z+Q*O._z,q._w=C*r._w+Q*O._w,q._isDirty=!0,q}static Hermite(r,O,W,q,Q){const C=Q*Q,T=Q*C,h=2*T-3*C+1,J=-2*T+3*C,mr=T-2*C+Q,d=T-C,v=r._x*h+W._x*J+O._x*mr+q._x*d,g=r._y*h+W._y*J+O._y*mr+q._y*d,K=r._z*h+W._z*J+O._z*mr+q._z*d,U=r._w*h+W._w*J+O._w*mr+q._w*d;return new e(v,g,K,U)}static Hermite1stDerivative(r,O,W,q,Q){const C=new e;return this.Hermite1stDerivativeToRef(r,O,W,q,Q,C),C}static Hermite1stDerivativeToRef(r,O,W,q,Q,C){const T=Q*Q;return C._x=6*(T-Q)*r._x+(3*T-4*Q+1)*O._x+6*(-T+Q)*W._x+(3*T-2*Q)*q._x,C._y=6*(T-Q)*r._y+(3*T-4*Q+1)*O._y+6*(-T+Q)*W._y+(3*T-2*Q)*q._y,C._z=6*(T-Q)*r._z+(3*T-4*Q+1)*O._z+6*(-T+Q)*W._z+(3*T-2*Q)*q._z,C._w=6*(T-Q)*r._w+(3*T-4*Q+1)*O._w+6*(-T+Q)*W._w+(3*T-2*Q)*q._w,C._isDirty=!0,C}static Normalize(r){const O=e.Zero();return e.NormalizeToRef(r,O),O}static NormalizeToRef(r,O){return r.normalizeToRef(O),O}static Clamp(r,O,W){const q=new e;return e.ClampToRef(r,O,W,q),q}static ClampToRef(r,O,W,q){return q.zh((0,J.Clamp)(r.x,O.x,W.x),(0,J.Clamp)(r.y,O.y,W.y),(0,J.Clamp)(r.z,O.z,W.z),(0,J.Clamp)(r.w,O.w,W.w))}static Random(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new e((0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O))}static RandomToRef(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).zh((0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O),(0,J.RandomRange)(r,O))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(r,O){return Math.sqrt(e.DistanceSquared(r,O))}static DistanceSquared(r,O){const W=r.x-O.x,q=r.y-O.y,Q=r.z-O.z,C=r.w-O.w;return W*W+q*q+Q*Q+C*C}static Center(r,O){return e.CenterToRef(r,O,e.Zero())}static CenterToRef(r,O,W){return W.zh((r.x+O.x)/2,(r.y+O.y)/2,(r.z+O.z)/2,(r.w+O.w)/2)}}e._V8PerformanceHack=new e(.5,.5,.5,.5),Object.defineProperties(e.prototype,{dimension:{value:[4]},rank:{value:1}});class Y{static get Use64Bits(){return T.e.MatrixUse64Bits}get m(){return this.gh}markAsUpdated(){this.updateFlag=mr._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(r){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1],W=arguments.length>2&&void 0!==arguments[2]&&arguments[2],q=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=r,this._isIdentity3x2=r||W,this._isIdentityDirty=!this._isIdentity&&O,this._isIdentity3x2Dirty=!this._isIdentity3x2&&q}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,T.e.MatrixTrackPrecisionChange&&T.e.MatrixTrackedMatrices.push(this),this.gh=new T.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const r=this.gh;this._isIdentity=1===r[0]&&0===r[1]&&0===r[2]&&0===r[3]&&0===r[4]&&1===r[5]&&0===r[6]&&0===r[7]&&0===r[8]&&0===r[9]&&1===r[10]&&0===r[11]&&0===r[12]&&0===r[13]&&0===r[14]&&1===r[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.gh[0]||1!==this.gh[5]||1!==this.gh[15]||0!==this.gh[1]||0!==this.gh[2]||0!==this.gh[3]||0!==this.gh[4]||0!==this.gh[6]||0!==this.gh[7]||0!==this.gh[8]||0!==this.gh[9]||0!==this.gh[10]||0!==this.gh[11]||0!==this.gh[12]||0!==this.gh[13]||0!==this.gh[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const r=this.gh,O=r[0],W=r[1],q=r[2],Q=r[3],C=r[4],T=r[5],h=r[6],J=r[7],mr=r[8],d=r[9],v=r[10],g=r[11],K=r[12],U=r[13],P=r[14],b=r[15],e=v*b-P*g,Y=d*b-U*g,G=d*P-U*v,X=mr*b-K*g,S=mr*P-v*K,o=mr*U-K*d;return O*+(T*e-h*Y+J*G)+W*-(C*e-h*X+J*S)+q*+(C*Y-T*X+J*o)+Q*-(C*G-T*S+h*o)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!r)return this.gh;const W=this.gh;for(let q=0;q<16;q++)r[O+q]=W[q];return this}Yh(){return this.gh}eW(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y.FromArrayToRef(r,O,this)}zh(){for(var r=arguments.length,O=new Array(r),W=0;W<r;W++)O[W]=arguments[W];return Y.FromArrayToRef(O,0,this)}set(){const r=this.gh;for(let O=0;O<16;O++)r[O]=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}Mh(r){const O=this.gh;for(let W=0;W<16;W++)O[W]=r;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return Y.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(r){const O=new Y;return this.addToRef(r,O),O}addToRef(r,O){const W=this.gh,q=O.gh,Q=r.m;for(let C=0;C<16;C++)q[C]=W[C]+Q[C];return O.markAsUpdated(),O}addToSelf(r){const O=this.gh,W=r.m;return O[0]+=W[0],O[1]+=W[1],O[2]+=W[2],O[3]+=W[3],O[4]+=W[4],O[5]+=W[5],O[6]+=W[6],O[7]+=W[7],O[8]+=W[8],O[9]+=W[9],O[10]+=W[10],O[11]+=W[11],O[12]+=W[12],O[13]+=W[13],O[14]+=W[14],O[15]+=W[15],this.markAsUpdated(),this}addInPlace(r){const O=this.gh,W=r.m;for(let q=0;q<16;q++)O[q]+=W[q];return this.markAsUpdated(),this}addInPlaceFromFloats(){const r=this.gh;for(let O=0;O<16;O++)r[O]+=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}YO(r){const O=this.gh,W=r.m;for(let q=0;q<16;q++)O[q]-=W[q];return this.markAsUpdated(),this}subtractToRef(r,O){const W=this.gh,q=r.m,Q=O.gh;for(let C=0;C<16;C++)Q[C]=W[C]-q[C];return O.markAsUpdated(),O}yv(r){const O=this.gh,W=r.m;for(let q=0;q<16;q++)O[q]-=W[q];return this.markAsUpdated(),this}subtractFromFloats(){for(var r=arguments.length,O=new Array(r),W=0;W<r;W++)O[W]=arguments[W];return this.subtractFromFloatsToRef(...O,new Y)}subtractFromFloatsToRef(){for(var r=arguments.length,O=new Array(r),W=0;W<r;W++)O[W]=arguments[W];const q=O.pop(),Q=this.gh,C=q.gh,T=O;for(let h=0;h<16;h++)C[h]=Q[h]-T[h];return q.markAsUpdated(),q}invertToRef(r){return!0===this._isIdentity?(Y.IdentityToRef(r),r):(g(this,r.Yh())?r.markAsUpdated():r.C(this),r)}addAtIndex(r,O){return this.gh[r]+=O,this.markAsUpdated(),this}multiplyAtIndex(r,O){return this.gh[r]*=O,this.markAsUpdated(),this}setTranslationFromFloats(r,O,W){return this.gh[12]=r,this.gh[13]=O,this.gh[14]=W,this.markAsUpdated(),this}addTranslationFromFloats(r,O,W){return this.gh[12]+=r,this.gh[13]+=O,this.gh[14]+=W,this.markAsUpdated(),this}setTranslation(r){return this.setTranslationFromFloats(r._x,r._y,r._z)}getTranslation(){return new P(this.gh[12],this.gh[13],this.gh[14])}getTranslationToRef(r){return r.x=this.gh[12],r.y=this.gh[13],r.z=this.gh[14],r}removeRotationAndScaling(){const r=this.m;return Y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,r[12],r[13],r[14],r[15],this),this._updateIdentityStatus(0===r[12]&&0===r[13]&&0===r[14]&&1===r[15]),this}C(r){r.copyToArray(this.gh);const O=r;return this.updateFlag=O.updateFlag,this._updateIdentityStatus(O._isIdentity,O._isIdentityDirty,O._isIdentity3x2,O._isIdentity3x2Dirty),this}copyToArray(r){return v(this,r,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(r){const O=new Y;return this.multiplyToRef(r,O),O}multiplyInPlace(r){const O=this.gh,W=r.m;for(let q=0;q<16;q++)O[q]*=W[q];return this.markAsUpdated(),this}multiplyByFloats(){const r=this.gh;for(let O=0;O<16;O++)r[O]*=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var r=arguments.length,O=new Array(r),W=0;W<r;W++)O[W]=arguments[W];const q=O.pop(),Q=this.gh,C=q.gh,T=O;for(let h=0;h<16;h++)C[h]=Q[h]*T[h];return q.markAsUpdated(),q}multiplyToRef(r,O){return this._isIdentity?(O.C(r),O):r._isIdentity?(O.C(this),O):(this.multiplyToArray(r,O.gh,0),O.markAsUpdated(),O)}multiplyToArray(r,O,W){return d(this,r,O,W),this}divide(r){return this.divideToRef(r,new Y)}divideToRef(r,O){const W=this.gh,q=r.m,Q=O.gh;for(let C=0;C<16;C++)Q[C]=W[C]/q[C];return O.markAsUpdated(),O}divideInPlace(r){const O=this.gh,W=r.m;for(let q=0;q<16;q++)O[q]/=W[q];return this.markAsUpdated(),this}minimizeInPlace(r){const O=this.gh,W=r.m;for(let q=0;q<16;q++)O[q]=Math.min(O[q],W[q]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const r=this.gh;for(let O=0;O<16;O++)r[O]=Math.min(r[O],O<0||arguments.length<=O?void 0:arguments[O]);return this.markAsUpdated(),this}maximizeInPlace(r){const O=this.gh,W=r.m;for(let q=0;q<16;q++)O[q]=Math.min(O[q],W[q]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const r=this.gh;for(let O=0;O<16;O++)r[O]=Math.min(r[O],O<0||arguments.length<=O?void 0:arguments[O]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new Y)}negateInPlace(){const r=this.gh;for(let O=0;O<16;O++)r[O]=-r[O];return this.markAsUpdated(),this}negateToRef(r){const O=this.gh,W=r.gh;for(let q=0;q<16;q++)W[q]=-O[q];return r.markAsUpdated(),r}equals(r){const O=r;if(!O)return!1;if((this._isIdentity||O._isIdentity)&&!this._isIdentityDirty&&!O._isIdentityDirty)return this._isIdentity&&O._isIdentity;const W=this.m,q=O.m;return W[0]===q[0]&&W[1]===q[1]&&W[2]===q[2]&&W[3]===q[3]&&W[4]===q[4]&&W[5]===q[5]&&W[6]===q[6]&&W[7]===q[7]&&W[8]===q[8]&&W[9]===q[9]&&W[10]===q[10]&&W[11]===q[11]&&W[12]===q[12]&&W[13]===q[13]&&W[14]===q[14]&&W[15]===q[15]}equalsWithEpsilon(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const W=this.gh,q=r.m;for(let Q=0;Q<16;Q++)if(!(0,J.WithinEpsilon)(W[Q],q[Q],O))return!1;return!0}equalsToFloats(){const r=this.gh;for(let O=0;O<16;O++)if(r[O]!=(O<0||arguments.length<=O?void 0:arguments[O]))return!1;return!0}floor(){return this.floorToRef(new Y)}floorToRef(r){const O=this.gh,W=r.gh;for(let q=0;q<16;q++)W[q]=Math.floor(O[q]);return r.markAsUpdated(),r}fract(){return this.fractToRef(new Y)}fractToRef(r){const O=this.gh,W=r.gh;for(let q=0;q<16;q++)W[q]=O[q]-Math.floor(O[q]);return r.markAsUpdated(),r}clone(){const r=new Y;return r.C(this),r}getClassName(){return"Matrix"}getHashCode(){let r=K(this.gh[0]);for(let O=1;O<16;O++)r=397*r^K(this.gh[O]);return r}decomposeToTransformNode(r){return r.rotationQuaternion=r.rotationQuaternion||new e,this.decompose(r.Lh,r.rotationQuaternion,r.position)}decompose(r,O,W,q){let Q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return W&&W.Mh(0),r&&r.Mh(1),O&&O.zh(0,0,0,1),!0;const C=this.gh;if(W&&W.zh(C[12],C[13],C[14]),(r=r||G.eO[0]).x=Math.sqrt(C[0]*C[0]+C[1]*C[1]+C[2]*C[2]),r.y=Math.sqrt(C[4]*C[4]+C[5]*C[5]+C[6]*C[6]),r.z=Math.sqrt(C[8]*C[8]+C[9]*C[9]+C[10]*C[10]),q){const O=(Q?q.absoluteScaling.x:q.Lh.x)<0?-1:1,W=(Q?q.absoluteScaling.y:q.Lh.y)<0?-1:1,C=(Q?q.absoluteScaling.z:q.Lh.z)<0?-1:1;r.x*=O,r.y*=W,r.z*=C}else this.determinant()<=0&&(r.y*=-1);if(0===r._x||0===r._y||0===r._z)return O&&O.zh(0,0,0,1),!1;if(O){const W=1/r._x,q=1/r._y,Q=1/r._z;Y.FromValuesToRef(C[0]*W,C[1]*W,C[2]*W,0,C[4]*q,C[5]*q,C[6]*q,0,C[8]*Q,C[9]*Q,C[10]*Q,0,0,0,0,1,G.Matrix[0]),e.FromRotationMatrixToRef(G.Matrix[0],O)}return!0}getRow(r){if(r<0||r>3)return null;const O=4*r;return new b(this.gh[O+0],this.gh[O+1],this.gh[O+2],this.gh[O+3])}getRowToRef(r,O){if(r>=0&&r<=3){const W=4*r;O.x=this.gh[W+0],O.y=this.gh[W+1],O.z=this.gh[W+2],O.w=this.gh[W+3]}return O}setRow(r,O){return this.setRowFromFloats(r,O.x,O.y,O.z,O.w)}transpose(){const r=new Y;return Y.TransposeToRef(this,r),r}transposeToRef(r){return Y.TransposeToRef(this,r),r}setRowFromFloats(r,O,W,q,Q){if(r<0||r>3)return this;const C=4*r;return this.gh[C+0]=O,this.gh[C+1]=W,this.gh[C+2]=q,this.gh[C+3]=Q,this.markAsUpdated(),this}scale(r){const O=new Y;return this.scaleToRef(r,O),O}scaleToRef(r,O){for(let W=0;W<16;W++)O.gh[W]=this.gh[W]*r;return O.markAsUpdated(),O}scaleAndAddToRef(r,O){for(let W=0;W<16;W++)O.gh[W]+=this.gh[W]*r;return O.markAsUpdated(),O}scaleInPlace(r){const O=this.gh;for(let W=0;W<16;W++)O[W]*=r;return this.markAsUpdated(),this}toNormalMatrix(r){const O=G.Matrix[0];this.invertToRef(O),O.transposeToRef(r);const W=r.gh;return Y.FromValuesToRef(W[0],W[1],W[2],0,W[4],W[5],W[6],0,W[8],W[9],W[10],0,0,0,0,1,r),r}getRotationMatrix(){const r=new Y;return this.getRotationMatrixToRef(r),r}getRotationMatrixToRef(r){const O=G.eO[0];if(!this.decompose(O))return Y.IdentityToRef(r),r;const W=this.gh,q=1/O._x,Q=1/O._y,C=1/O._z;return Y.FromValuesToRef(W[0]*q,W[1]*q,W[2]*q,0,W[4]*Q,W[5]*Q,W[6]*Q,0,W[8]*C,W[9]*C,W[10]*C,0,0,0,0,1,r),r}toggleModelMatrixHandInPlace(){const r=this.gh;return r[2]*=-1,r[6]*=-1,r[8]*=-1,r[9]*=-1,r[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const r=this.gh;return r[8]*=-1,r[9]*=-1,r[10]*=-1,r[11]*=-1,this.markAsUpdated(),this}static oO(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const W=new Y;return Y.FromArrayToRef(r,O,W),W}static FromArrayToRef(r,O,W){for(let q=0;q<16;q++)W.gh[q]=r[q+O];return W.markAsUpdated(),W}static FromFloat32ArrayToRefScaled(r,O,W,q){return q.gh[0]=r[0+O]*W,q.gh[1]=r[1+O]*W,q.gh[2]=r[2+O]*W,q.gh[3]=r[3+O]*W,q.gh[4]=r[4+O]*W,q.gh[5]=r[5+O]*W,q.gh[6]=r[6+O]*W,q.gh[7]=r[7+O]*W,q.gh[8]=r[8+O]*W,q.gh[9]=r[9+O]*W,q.gh[10]=r[10+O]*W,q.gh[11]=r[11+O]*W,q.gh[12]=r[12+O]*W,q.gh[13]=r[13+O]*W,q.gh[14]=r[14+O]*W,q.gh[15]=r[15+O]*W,q.markAsUpdated(),q}static get IdentityReadOnly(){return Y._IdentityReadOnly}static FromValuesToRef(r,O,W,q,Q,C,T,h,J,mr,d,v,g,K,U,P,b){const e=b.gh;e[0]=r,e[1]=O,e[2]=W,e[3]=q,e[4]=Q,e[5]=C,e[6]=T,e[7]=h,e[8]=J,e[9]=mr,e[10]=d,e[11]=v,e[12]=g,e[13]=K,e[14]=U,e[15]=P,b.markAsUpdated()}static FromValues(r,O,W,q,Q,C,T,h,J,mr,d,v,g,K,U,P){const b=new Y,e=b.gh;return e[0]=r,e[1]=O,e[2]=W,e[3]=q,e[4]=Q,e[5]=C,e[6]=T,e[7]=h,e[8]=J,e[9]=mr,e[10]=d,e[11]=v,e[12]=g,e[13]=K,e[14]=U,e[15]=P,b.markAsUpdated(),b}static Compose(r,O,W){const q=new Y;return Y.ComposeToRef(r,O,W,q),q}static ComposeToRef(r,O,W,q){const Q=q.gh,C=O._x,T=O._y,h=O._z,J=O._w,mr=C+C,d=T+T,v=h+h,g=C*mr,K=C*d,U=C*v,P=T*d,b=T*v,e=h*v,Y=J*mr,G=J*d,X=J*v,S=r._x,o=r._y,N=r._z;return Q[0]=(1-(P+e))*S,Q[1]=(K+X)*S,Q[2]=(U-G)*S,Q[3]=0,Q[4]=(K-X)*o,Q[5]=(1-(g+e))*o,Q[6]=(b+Y)*o,Q[7]=0,Q[8]=(U+G)*N,Q[9]=(b-Y)*N,Q[10]=(1-(g+P))*N,Q[11]=0,Q[12]=W._x,Q[13]=W._y,Q[14]=W._z,Q[15]=1,q.markAsUpdated(),q}static Identity(){const r=Y.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return r._updateIdentityStatus(!0),r}static IdentityToRef(r){return Y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,r),r._updateIdentityStatus(!0),r}static Zero(){const r=Y.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return r._updateIdentityStatus(!1),r}static RotationX(r){const O=new Y;return Y.RotationXToRef(r,O),O}static Invert(r){const O=new Y;return r.invertToRef(O),O}static RotationXToRef(r,O){const W=Math.sin(r),q=Math.cos(r);return Y.FromValuesToRef(1,0,0,0,0,q,W,0,0,-W,q,0,0,0,0,1,O),O._updateIdentityStatus(1===q&&0===W),O}static RotationY(r){const O=new Y;return Y.RotationYToRef(r,O),O}static RotationYToRef(r,O){const W=Math.sin(r),q=Math.cos(r);return Y.FromValuesToRef(q,0,-W,0,0,1,0,0,W,0,q,0,0,0,0,1,O),O._updateIdentityStatus(1===q&&0===W),O}static RotationZ(r){const O=new Y;return Y.RotationZToRef(r,O),O}static RotationZToRef(r,O){const W=Math.sin(r),q=Math.cos(r);return Y.FromValuesToRef(q,W,0,0,-W,q,0,0,0,0,1,0,0,0,0,1,O),O._updateIdentityStatus(1===q&&0===W),O}static RotationAxis(r,O){const W=new Y;return Y.RotationAxisToRef(r,O,W),W}static RotationAxisToRef(r,O,W){const q=Math.sin(-O),Q=Math.cos(-O),C=1-Q;r=r.normalizeToRef(G.eO[0]);const T=W.gh;return T[0]=r._x*r._x*C+Q,T[1]=r._x*r._y*C-r._z*q,T[2]=r._x*r._z*C+r._y*q,T[3]=0,T[4]=r._y*r._x*C+r._z*q,T[5]=r._y*r._y*C+Q,T[6]=r._y*r._z*C-r._x*q,T[7]=0,T[8]=r._z*r._x*C-r._y*q,T[9]=r._z*r._y*C+r._x*q,T[10]=r._z*r._z*C+Q,T[11]=0,T[12]=0,T[13]=0,T[14]=0,T[15]=1,W.markAsUpdated(),W}static RotationAlignToRef(r,O,W){let Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const C=P.Dot(O,r),T=W.gh;if(C<-1+q.c)T[0]=-1,T[1]=0,T[2]=0,T[3]=0,T[4]=0,T[5]=Q?1:-1,T[6]=0,T[7]=0,T[8]=0,T[9]=0,T[10]=Q?-1:1,T[11]=0;else{const W=P.Cross(O,r),q=1/(1+C);T[0]=W._x*W._x*q+C,T[1]=W._y*W._x*q-W._z,T[2]=W._z*W._x*q+W._y,T[3]=0,T[4]=W._x*W._y*q+W._z,T[5]=W._y*W._y*q+C,T[6]=W._z*W._y*q-W._x,T[7]=0,T[8]=W._x*W._z*q-W._y,T[9]=W._y*W._z*q+W._x,T[10]=W._z*W._z*q+C,T[11]=0}return T[12]=0,T[13]=0,T[14]=0,T[15]=1,W.markAsUpdated(),W}static RotationYawPitchRoll(r,O,W){const q=new Y;return Y.RotationYawPitchRollToRef(r,O,W,q),q}static RotationYawPitchRollToRef(r,O,W,q){return e.RotationYawPitchRollToRef(r,O,W,G.Quaternion[0]),G.Quaternion[0].toRotationMatrix(q),q}static Scaling(r,O,W){const q=new Y;return Y.ScalingToRef(r,O,W,q),q}static ScalingToRef(r,O,W,q){return Y.FromValuesToRef(r,0,0,0,0,O,0,0,0,0,W,0,0,0,0,1,q),q._updateIdentityStatus(1===r&&1===O&&1===W),q}static Translation(r,O,W){const q=new Y;return Y.TranslationToRef(r,O,W,q),q}static TranslationToRef(r,O,W,q){return Y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,r,O,W,1,q),q._updateIdentityStatus(0===r&&0===O&&0===W),q}static Lerp(r,O,W){const q=new Y;return Y.LerpToRef(r,O,W,q),q}static LerpToRef(r,O,W,q){const Q=q.gh,C=r.m,T=O.m;for(let h=0;h<16;h++)Q[h]=C[h]*(1-W)+T[h]*W;return q.markAsUpdated(),q}static DecomposeLerp(r,O,W){const q=new Y;return Y.DecomposeLerpToRef(r,O,W,q),q}static DecomposeLerpToRef(r,O,W,q){const Q=G.eO[0],C=G.Quaternion[0],T=G.eO[1];r.decompose(Q,C,T);const h=G.eO[2],J=G.Quaternion[1],mr=G.eO[3];O.decompose(h,J,mr);const d=G.eO[4];P.LerpToRef(Q,h,W,d);const v=G.Quaternion[2];e.SlerpToRef(C,J,W,v);const g=G.eO[5];return P.LerpToRef(T,mr,W,g),Y.ComposeToRef(d,v,g,q),q}static LookAtLH(r,O,W){const q=new Y;return Y.LookAtLHToRef(r,O,W,q),q}static LookAtLHToRef(r,O,W,q){const Q=G.eO[0],C=G.eO[1],T=G.eO[2];O.subtractToRef(r,T),T.normalize(),P.CrossToRef(W,T,Q);const h=Q.lengthSquared();0===h?Q.x=1:Q.normalizeFromLength(Math.sqrt(h)),P.CrossToRef(T,Q,C),C.normalize();const J=-P.Dot(Q,r),mr=-P.Dot(C,r),d=-P.Dot(T,r);return Y.FromValuesToRef(Q._x,C._x,T._x,0,Q._y,C._y,T._y,0,Q._z,C._z,T._z,0,J,mr,d,1,q),q}static LookAtRH(r,O,W){const q=new Y;return Y.LookAtRHToRef(r,O,W,q),q}static LookAtRHToRef(r,O,W,q){const Q=G.eO[0],C=G.eO[1],T=G.eO[2];r.subtractToRef(O,T),T.normalize(),P.CrossToRef(W,T,Q);const h=Q.lengthSquared();0===h?Q.x=1:Q.normalizeFromLength(Math.sqrt(h)),P.CrossToRef(T,Q,C),C.normalize();const J=-P.Dot(Q,r),mr=-P.Dot(C,r),d=-P.Dot(T,r);return Y.FromValuesToRef(Q._x,C._x,T._x,0,Q._y,C._y,T._y,0,Q._z,C._z,T._z,0,J,mr,d,1,q),q}static LookDirectionLH(r,O){const W=new Y;return Y.LookDirectionLHToRef(r,O,W),W}static LookDirectionLHToRef(r,O,W){const q=G.eO[0];q.C(r),q.scaleInPlace(-1);const Q=G.eO[1];return P.CrossToRef(O,q,Q),Y.FromValuesToRef(Q._x,Q._y,Q._z,0,O._x,O._y,O._z,0,q._x,q._y,q._z,0,0,0,0,1,W),W}static LookDirectionRH(r,O){const W=new Y;return Y.LookDirectionRHToRef(r,O,W),W}static LookDirectionRHToRef(r,O,W){const q=G.eO[2];return P.CrossToRef(O,r,q),Y.FromValuesToRef(q._x,q._y,q._z,0,O._x,O._y,O._z,0,r._x,r._y,r._z,0,0,0,0,1,W),W}static OrthoLH(r,O,W,q,Q){const C=new Y;return Y.OrthoLHToRef(r,O,W,q,C,Q),C}static OrthoLHToRef(r,O,W,q,Q,C){const T=2/r,h=2/O,J=2/(q-W),mr=-(q+W)/(q-W);return Y.FromValuesToRef(T,0,0,0,0,h,0,0,0,0,J,0,0,0,mr,1,Q),C&&Q.multiplyToRef(S,Q),Q._updateIdentityStatus(1===T&&1===h&&1===J&&0===mr),Q}static OrthoOffCenterLH(r,O,W,q,Q,C,T){const h=new Y;return Y.OrthoOffCenterLHToRef(r,O,W,q,Q,C,h,T),h}static OrthoOffCenterLHToRef(r,O,W,q,Q,C,T,h){const J=2/(O-r),mr=2/(q-W),d=2/(C-Q),v=-(C+Q)/(C-Q),g=(r+O)/(r-O),K=(q+W)/(W-q);return Y.FromValuesToRef(J,0,0,0,0,mr,0,0,0,0,d,0,g,K,v,1,T),h&&T.multiplyToRef(S,T),T.markAsUpdated(),T}static ObliqueOffCenterLHToRef(r,O,W,q,Q,C,T,h,J,mr,d){const v=-T*Math.cos(h),g=-T*Math.sin(h);return Y.TranslationToRef(0,0,-J,G.Matrix[1]),Y.FromValuesToRef(1,0,0,0,0,1,0,0,v,g,1,0,0,0,0,1,G.Matrix[0]),G.Matrix[1].multiplyToRef(G.Matrix[0],G.Matrix[0]),Y.TranslationToRef(0,0,J,G.Matrix[1]),G.Matrix[0].multiplyToRef(G.Matrix[1],G.Matrix[0]),Y.OrthoOffCenterLHToRef(r,O,W,q,Q,C,mr,d),G.Matrix[0].multiplyToRef(mr,mr),mr}static OrthoOffCenterRH(r,O,W,q,Q,C,T){const h=new Y;return Y.OrthoOffCenterRHToRef(r,O,W,q,Q,C,h,T),h}static OrthoOffCenterRHToRef(r,O,W,q,Q,C,T,h){return Y.OrthoOffCenterLHToRef(r,O,W,q,Q,C,T,h),T.gh[10]*=-1,T}static ObliqueOffCenterRHToRef(r,O,W,q,Q,C,T,h,J,mr,d){const v=T*Math.cos(h),g=T*Math.sin(h);return Y.TranslationToRef(0,0,J,G.Matrix[1]),Y.FromValuesToRef(1,0,0,0,0,1,0,0,v,g,1,0,0,0,0,1,G.Matrix[0]),G.Matrix[1].multiplyToRef(G.Matrix[0],G.Matrix[0]),Y.TranslationToRef(0,0,-J,G.Matrix[1]),G.Matrix[0].multiplyToRef(G.Matrix[1],G.Matrix[0]),Y.OrthoOffCenterRHToRef(r,O,W,q,Q,C,mr,d),G.Matrix[0].multiplyToRef(mr,mr),mr}static PerspectiveLH(r,O,W,q,Q){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const T=new Y,h=2*W/r,J=2*W/O,mr=(q+W)/(q-W),d=-2*q*W/(q-W),v=Math.tan(C);return Y.FromValuesToRef(h,0,0,0,0,J,0,v,0,0,mr,1,0,0,d,0,T),Q&&T.multiplyToRef(S,T),T._updateIdentityStatus(!1),T}static PerspectiveFovLH(r,O,W,q,Q){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,T=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const h=new Y;return Y.PerspectiveFovLHToRef(r,O,W,q,h,!0,Q,C,T),h}static PerspectiveFovLHToRef(r,O,W,q,Q){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],T=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,J=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const mr=W,d=q,v=1/Math.tan(.5*r),g=C?v/O:v,K=C?v:v*O,U=J&&0===mr?-1:0!==d?(d+mr)/(d-mr):1,P=J&&0===mr?2*d:0!==d?-2*d*mr/(d-mr):-2*mr,b=Math.tan(h);return Y.FromValuesToRef(g,0,0,0,0,K,0,b,0,0,U,1,0,0,P,0,Q),T&&Q.multiplyToRef(S,Q),Q._updateIdentityStatus(!1),Q}static PerspectiveFovReverseLHToRef(r,O,W,q,Q){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],T=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const J=1/Math.tan(.5*r),mr=C?J/O:J,d=C?J:J*O,v=Math.tan(h);return Y.FromValuesToRef(mr,0,0,0,0,d,0,v,0,0,-W,1,0,0,1,0,Q),T&&Q.multiplyToRef(S,Q),Q._updateIdentityStatus(!1),Q}static PerspectiveFovRH(r,O,W,q,Q){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,T=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const h=new Y;return Y.PerspectiveFovRHToRef(r,O,W,q,h,!0,Q,C,T),h}static PerspectiveFovRHToRef(r,O,W,q,Q){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],T=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,J=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const mr=W,d=q,v=1/Math.tan(.5*r),g=C?v/O:v,K=C?v:v*O,U=J&&0===mr?1:0!==d?-(d+mr)/(d-mr):-1,P=J&&0===mr?2*d:0!==d?-2*d*mr/(d-mr):-2*mr,b=Math.tan(h);return Y.FromValuesToRef(g,0,0,0,0,K,0,b,0,0,U,-1,0,0,P,0,Q),T&&Q.multiplyToRef(S,Q),Q._updateIdentityStatus(!1),Q}static PerspectiveFovReverseRHToRef(r,O,W,q,Q){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],T=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const J=1/Math.tan(.5*r),mr=C?J/O:J,d=C?J:J*O,v=Math.tan(h);return Y.FromValuesToRef(mr,0,0,0,0,d,0,v,0,0,-W,-1,0,0,-1,0,Q),T&&Q.multiplyToRef(S,Q),Q._updateIdentityStatus(!1),Q}static GetFinalMatrix(r,O,W,q,Q,C){const T=r.width,h=r.height,J=r.x,mr=r.y,d=Y.FromValues(T/2,0,0,0,0,-h/2,0,0,0,0,C-Q,0,J+T/2,h/2+mr,Q,1),v=new Y;return O.multiplyToRef(W,v),v.multiplyToRef(q,v),v.multiplyToRef(d,v)}static GetAsMatrix2x2(r){const O=r.m,W=[O[0],O[1],O[4],O[5]];return T.e.MatrixUse64Bits?W:new Float32Array(W)}static GetAsMatrix3x3(r){const O=r.m,W=[O[0],O[1],O[2],O[4],O[5],O[6],O[8],O[9],O[10]];return T.e.MatrixUse64Bits?W:new Float32Array(W)}static Transpose(r){const O=new Y;return Y.TransposeToRef(r,O),O}static TransposeToRef(r,O){const W=r.m,q=W[0],Q=W[4],C=W[8],T=W[12],h=W[1],J=W[5],mr=W[9],d=W[13],v=W[2],g=W[6],K=W[10],U=W[14],P=W[3],b=W[7],e=W[11],Y=W[15],G=O.gh;return G[0]=q,G[1]=Q,G[2]=C,G[3]=T,G[4]=h,G[5]=J,G[6]=mr,G[7]=d,G[8]=v,G[9]=g,G[10]=K,G[11]=U,G[12]=P,G[13]=b,G[14]=e,G[15]=Y,O.markAsUpdated(),O._updateIdentityStatus(r._isIdentity,r._isIdentityDirty),O}static Reflection(r){const O=new Y;return Y.ReflectionToRef(r,O),O}static ReflectionToRef(r,O){r.normalize();const W=r.normal.x,q=r.normal.y,Q=r.normal.z,C=-2*W,T=-2*q,h=-2*Q;return Y.FromValuesToRef(C*W+1,T*W,h*W,0,C*q,T*q+1,h*q,0,C*Q,T*Q,h*Q+1,0,C*r.d,T*r.d,h*r.d,1,O),O}static FromXYZAxesToRef(r,O,W,q){return Y.FromValuesToRef(r._x,r._y,r._z,0,O._x,O._y,O._z,0,W._x,W._y,W._z,0,0,0,0,1,q),q}static FromQuaternionToRef(r,O){const W=r._x*r._x,q=r._y*r._y,Q=r._z*r._z,C=r._x*r._y,T=r._z*r._w,h=r._z*r._x,J=r._y*r._w,mr=r._y*r._z,d=r._x*r._w;return O.gh[0]=1-2*(q+Q),O.gh[1]=2*(C+T),O.gh[2]=2*(h-J),O.gh[3]=0,O.gh[4]=2*(C-T),O.gh[5]=1-2*(Q+W),O.gh[6]=2*(mr+d),O.gh[7]=0,O.gh[8]=2*(h+J),O.gh[9]=2*(mr-d),O.gh[10]=1-2*(q+W),O.gh[11]=0,O.gh[12]=0,O.gh[13]=0,O.gh[14]=0,O.gh[15]=1,O.markAsUpdated(),O}}Y._IdentityReadOnly=Y.Identity(),Object.defineProperties(Y.prototype,{dimension:{value:[4,4]},rank:{value:2}});class G{}G.eO=(0,Q.h)(11,P.Zero),G.Matrix=(0,Q.h)(2,Y.Identity),G.Quaternion=(0,Q.h)(3,e.Zero);class X{}X.Vector2=(0,Q.h)(3,U.Zero),X.eO=(0,Q.h)(13,P.Zero),X.Vector4=(0,Q.h)(3,b.Zero),X.Quaternion=(0,Q.h)(3,e.Zero),X.Matrix=(0,Q.h)(8,Y.Identity),(0,C.e)("BABYLON.Vector2",U),(0,C.e)("BABYLON.Vector3",P),(0,C.e)("BABYLON.Vector4",b),(0,C.e)("BABYLON.Matrix",Y);const S=Y.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12600:(r,O,W)=>{function q(r,O){const W=[];for(let q=0;q<r;++q)W.push(O());return W}function Q(r,O){return q(r,O)}W.d(O,{d:()=>q,h:()=>Q,k:()=>T});const C=["push","splice","pop","shift","unshift"];function T(r,O){const W=C.map((W=>function(r,O,W){const q=r[O];if("function"!==typeof q)return null;const Q=function(){const q=r.length,C=Q.previous.apply(r,arguments);return W(O,q),C};return q.next=Q,Q.previous=q,r[O]=Q,()=>{const W=Q.previous;if(!W)return;const q=Q.next;q?(W.next=q,q.previous=W):(W.next=void 0,r[O]=W),Q.next=void 0,Q.previous=void 0}}(r,W,O)));return()=>{for(const r of W)null===r||void 0===r||r()}}}}]);