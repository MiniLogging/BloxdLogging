"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{2190:(j,H,s)=>{s.r(H),s.d(H,{_ExrTextureLoader:()=>f});var i=s(514),B=s(708);const e=65536,k=14,V=65537,C=16384;var L,U;!function(j){j[j.NO_COMPRESSION=0]="NO_COMPRESSION",j[j.RLE_COMPRESSION=1]="RLE_COMPRESSION",j[j.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",j[j.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",j[j.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",j[j.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(L||(L={})),function(j){j[j.INCREASING_Y=0]="INCREASING_Y",j[j.DECREASING_Y=1]="DECREASING_Y"}(U||(U={}));const x=function(){const j=new ArrayBuffer(4),H=new Float32Array(j),s=new Uint32Array(j),i=new Uint32Array(512),B=new Uint32Array(512);for(let C=0;C<256;++C){const j=C-127;j<-27?(i[C]=0,i[256|C]=32768,B[C]=24,B[256|C]=24):j<-14?(i[C]=1024>>-j-14,i[256|C]=1024>>-j-14|32768,B[C]=-j-1,B[256|C]=-j-1):j<=15?(i[C]=j+15<<10,i[256|C]=j+15<<10|32768,B[C]=13,B[256|C]=13):j<128?(i[C]=31744,i[256|C]=64512,B[C]=24,B[256|C]=24):(i[C]=31744,i[256|C]=64512,B[C]=13,B[256|C]=13)}const e=new Uint32Array(2048),k=new Uint32Array(64),V=new Uint32Array(64);for(let C=1;C<1024;++C){let j=C<<13,H=0;for(;0===(8388608&j);)j<<=1,H-=8388608;j&=-8388609,H+=947912704,e[C]=j|H}for(let C=1024;C<2048;++C)e[C]=939524096+(C-1024<<13);for(let C=1;C<31;++C)k[C]=C<<23;k[31]=1199570944,k[32]=2147483648;for(let C=33;C<63;++C)k[C]=2147483648+(C-32<<23);k[63]=3347054592;for(let C=1;C<64;++C)32!==C&&(V[C]=1024);return{floatView:H,uint32View:s,baseTable:i,shiftTable:B,mantissaTable:e,exponentTable:k,offsetTable:V}}();function p(j,H){const s=new Uint8Array(j);let i=0;for(;0!=s[H.value+i];)i+=1;const B=(new TextDecoder).decode(s.slice(H.value,H.value+i));return H.value=H.value+i+1,B}function a(j,H){const s=j.getInt32(H.value,!0);return H.value+=4,s}function E(j,H){const s=j.getUint32(H.value,!0);return H.value+=4,s}function r(j,H){const s=j.getUint8(H.value);return H.value+=1,s}function q(j,H){const s=j.getUint16(H.value,!0);return H.value+=2,s}function J(j,H){const s=j[H.value];return H.value+=1,s}function h(j,H){let s;return s="getBigInt64"in DataView.prototype?Number(j.getBigInt64(H.value,!0)):j.getUint32(H.value+4,!0)+Number(j.getUint32(H.value,!0)<<32),H.value+=8,s}function o(j,H){const s=j.getFloat32(H.value,!0);return H.value+=4,s}function R(j,H){return function(j){const H=(31744&j)>>10,s=1023&j;return(j>>15?-1:1)*(H?31===H?s?NaN:1/0:Math.pow(2,H-15)*(1+s/1024):s/1024*6103515625e-14)}(q(j,H))}function Y(j,H){return function(j){if(Math.abs(j)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");j=(0,B.e)(j,-65504,65504),x.floatView[0]=j;const H=x.uint32View[0],s=H>>23&511;return x.baseTable[s]+((8388607&H)>>x.shiftTable[s])}(o(j,H))}function v(j,H,s,i){switch(s){case"string":case"stringvector":case"iccProfile":return function(j,H,s){const i=(new TextDecoder).decode(new Uint8Array(j).slice(H.value,H.value+s));return H.value=H.value+s,i}(j.buffer,H,i);case"chlist":return function(j,H,s){const i=H.value,B=[];for(;H.value<i+s-1;){const s=p(j.buffer,H),i=a(j,H),e=r(j,H);H.value+=3;const k=a(j,H),V=a(j,H);B.push({name:s,pixelType:i,pLinear:e,xSampling:k,ySampling:V})}return H.value+=1,B}(j,H,i);case"chromaticities":return function(j,H){return{redX:o(j,H),redY:o(j,H),greenX:o(j,H),greenY:o(j,H),blueX:o(j,H),blueY:o(j,H),whiteX:o(j,H),whiteY:o(j,H)}}(j,H);case"compression":return function(j,H){return r(j,H)}(j,H);case"box2i":return function(j,H){return{xMin:a(j,H),yMin:a(j,H),xMax:a(j,H),yMax:a(j,H)}}(j,H);case"lineOrder":return function(j,H){const s=r(j,H);return U[s]}(j,H);case"float":return o(j,H);case"v2f":return function(j,H){return[o(j,H),o(j,H)]}(j,H);case"v3f":return function(j,H){return[o(j,H),o(j,H),o(j,H)]}(j,H);case"int":return a(j,H);case"rational":return function(j,H){return[a(j,H),E(j,H)]}(j,H);case"timecode":return function(j,H){return[E(j,H),E(j,H)]}(j,H);case"preview":return H.value+=i,"skipped";default:return void(H.value+=i)}}function c(j){for(let H=1;H<j.length;H++){const s=j[H-1]+j[H]-128;j[H]=s}}function z(j,H){let s=0,i=Math.floor((j.length+1)/2),B=0;const e=j.length-1;for(;!(B>e)&&(H[B++]=j[s++],!(B>e));)H[B++]=j[i++]}function K(j,H,s,i,B){for(;s<j;)H=H<<8|J(i,B),s+=8;return{l:H>>(s-=j)&(1<<j)-1,c:H,lc:s}}function W(j,H,s,i){return{c:j=j<<8|J(s,i),lc:H+=8}}function P(j,H,s,i,B,e,k,V,C){if(j==H){if(i<8){const j=W(s,i,B,e);s=j.c,i=j.lc}let j=s>>(i-=8);if(j=new Uint8Array([j])[0],V.value+j>C)return null;const H=k[V.value-1];for(;j-- >0;)k[V.value++]=H}else{if(!(V.value<C))return null;k[V.value++]=j}return{c:s,lc:i}}const O=new Array(59);function d(j,H,s,i,B,e){const k=H;let C=0,L=0;for(;i<=B;i++){if(k.value-H.value>s)return;let V=K(6,C,L,j,k);const U=V.l;if(C=V.c,L=V.lc,e[i]=U,63==U){if(k.value-H.value>s)throw new Error("Error in HufUnpackEncTable");V=K(8,C,L,j,k);let U=V.l+6;if(C=V.c,L=V.lc,i+U>B+1)throw new Error("Error in HufUnpackEncTable");for(;U--;)e[i++]=0;i--}else if(U>=59){let j=U-59+2;if(i+j>B+1)throw new Error("Error in HufUnpackEncTable");for(;j--;)e[i++]=0;i--}}!function(j){for(let s=0;s<=58;++s)O[s]=0;for(let s=0;s<V;++s)O[j[s]]+=1;let H=0;for(let s=58;s>0;--s){const j=H+O[s]>>1;O[s]=H,H=j}for(let s=0;s<V;++s){const H=j[s];H>0&&(j[s]=H|O[H]++<<6)}}(e)}function F(j){return 63&j}function m(j){return j>>6}function G(j,H,s,i,B,e){const L=s.value,U=E(H,s),x=E(H,s);s.value+=4;const p=E(H,s);if(s.value+=4,U<0||U>=V||x<0||x>=V)throw new Error("Wrong HUF_ENCSIZE");const a=new Array(V),r=new Array(C);!function(j){for(let H=0;H<C;H++)j[H]={},j[H].len=0,j[H].lit=0,j[H].p=null}(r);if(d(j,s,i-(s.value-L),U,x,a),p>8*(i-(s.value-L)))throw new Error("Wrong hufUncompress");!function(j,H,s,i){for(;H<=s;H++){const s=m(j[H]),B=F(j[H]);if(s>>B)throw new Error("Invalid table entry");if(B>k){const j=i[s>>B-k];if(j.len)throw new Error("Invalid table entry");if(j.lit++,j.p){const H=j.p;j.p=new Array(j.lit);for(let s=0;s<j.lit-1;++s)j.p[s]=H[s]}else j.p=new Array(1);j.p[j.lit-1]=H}else if(B){let j=0;for(let e=1<<k-B;e>0;e--){const e=i[(s<<k-B)+j];if(e.len||e.p)throw new Error("Invalid table entry");e.len=B,e.lit=H,j++}}}}(a,U,x,r),function(j,H,s,i,B,e,V,C,L){let U=0,x=0;const p=V,a=Math.trunc(i.value+(B+7)/8);for(;i.value<a;){let B=W(U,x,s,i);for(U=B.c,x=B.lc;x>=k;){const V=H[U>>x-k&16383];if(V.len){x-=V.len;const j=P(V.lit,e,U,x,s,i,C,L,p);j&&(U=j.c,x=j.lc)}else{if(!V.p)throw new Error("hufDecode issues");let H;for(H=0;H<V.lit;H++){const k=F(j[V.p[H]]);for(;x<k&&i.value<a;)B=W(U,x,s,i),U=B.c,x=B.lc;if(x>=k&&m(j[V.p[H]])==(U>>x-k&(1<<k)-1)){x-=k;const j=P(V.p[H],e,U,x,s,i,C,L,p);j&&(U=j.c,x=j.lc);break}}if(H==V.lit)throw new Error("HufDecode issues")}}}const E=8-B&7;for(U>>=E,x-=E;x>0;){const j=H[U<<k-x&16383];if(!j.len)throw new Error("HufDecode issues");{x-=j.len;const H=P(j.lit,e,U,x,s,i,C,L,p);H&&(U=H.c,x=H.lc)}}}(a,r,j,s,p,x,e,B,{value:0})}function M(j){return 65535&j}function b(j){const H=M(j);return H>32767?H-65536:H}function n(j,H){const s=b(j),i=b(H),B=s+(1&i)+(i>>1);return{a:B,b:B-i}}function t(j,H){const s=M(j),i=M(H),B=s-(i>>1)&65535;return{a:i+B-32768&65535,b:B}}function u(j,H,s,i,B,e,k){const V=k<16384,C=s>B?B:s;let L,U,x=1;for(;x<=C;)x<<=1;for(x>>=1,L=x,x>>=1;x>=1;){U=0;const k=U+e*(B-L),C=e*x,p=e*L,a=i*x,E=i*L;let r,q,J,h;for(;U<=k;U+=p){let B=U;const e=U+i*(s-L);for(;B<=e;B+=E){const s=B+a,i=B+C,e=i+a;if(V){let k=n(j[B+H],j[i+H]);r=k.a,J=k.b,k=n(j[s+H],j[e+H]),q=k.a,h=k.b,k=n(r,q),j[B+H]=k.a,j[s+H]=k.b,k=n(J,h),j[i+H]=k.a,j[e+H]=k.b}else{let k=t(j[B+H],j[i+H]);r=k.a,J=k.b,k=t(j[s+H],j[e+H]),q=k.a,h=k.b,k=t(r,q),j[B+H]=k.a,j[s+H]=k.b,k=t(J,h),j[i+H]=k.a,j[e+H]=k.b}}if(s&x){const s=B+C;let i;i=V?n(j[B+H],j[s+H]):t(j[B+H],j[s+H]),r=i.a,j[s+H]=i.b,j[B+H]=r}}if(B&x){let B=U;const e=U+i*(s-L);for(;B<=e;B+=E){const s=B+a;let i;i=V?n(j[B+H],j[s+H]):t(j[B+H],j[s+H]),r=i.a,j[s+H]=i.b,j[B+H]=r}}L=x,x>>=1}return U}function S(j){return new DataView(j.array.buffer,j.offset.value,j.size)}function T(j){const H=j.viewer.buffer.slice(j.offset.value,j.offset.value+j.size),s=new Uint8Array(function(j){let H=j.byteLength;const s=new Array;let i=0;const B=new DataView(j);for(;H>0;){const j=B.getInt8(i++);if(j<0){const e=-j;H-=e+1;for(let j=0;j<e;j++)s.push(B.getUint8(i++))}else{const e=j;H-=2;const k=B.getUint8(i++);for(let j=0;j<e+1;j++)s.push(k)}}return s}(H)),i=new Uint8Array(s.length);return c(s),z(s,i),new DataView(i.buffer)}function Z(j){const H=j.array.slice(j.offset.value,j.offset.value+j.size),s=fflate.unzlibSync(H),i=new Uint8Array(s.length);return c(s),z(s,i),new DataView(i.buffer)}function N(j){const H=j.array.slice(j.offset.value,j.offset.value+j.size),s=fflate.unzlibSync(H),i=j.lines*j.channels*j.width,B=1==j.type?new Uint16Array(i):new Uint32Array(i);let e=0,k=0;const V=new Array(4);for(let C=0;C<j.lines;C++)for(let H=0;H<j.channels;H++){let H=0;switch(j.type){case 1:V[0]=e,V[1]=V[0]+j.width,e=V[1]+j.width;for(let i=0;i<j.width;++i){H+=s[V[0]++]<<8|s[V[1]++],B[k]=H,k++}break;case 2:V[0]=e,V[1]=V[0]+j.width,V[2]=V[1]+j.width,e=V[2]+j.width;for(let i=0;i<j.width;++i){H+=s[V[0]++]<<24|s[V[1]++]<<16|s[V[2]++]<<8,B[k]=H,k++}}}return new DataView(B.buffer)}function D(j){const H=j.viewer,s={value:j.offset.value},i=new Uint16Array(j.width*j.scanlineBlockSize*(j.channels*j.type)),B=new Uint8Array(8192);let k=0;const V=new Array(j.channels);for(let e=0;e<j.channels;e++)V[e]={},V[e].start=k,V[e].end=V[e].start,V[e].nx=j.width,V[e].ny=j.lines,V[e].size=j.type,k+=V[e].nx*V[e].ny*V[e].size;const C=q(H,s),L=q(H,s);if(L>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(C<=L)for(let e=0;e<L-C+1;e++)B[e+C]=r(H,s);const U=new Uint16Array(e),x=function(j,H){let s=0;for(let B=0;B<e;++B)(0==B||j[B>>3]&1<<(7&B))&&(H[s++]=B);const i=s-1;for(;s<e;)H[s++]=0;return i}(B,U),p=E(H,s);G(j.array,H,s,p,i,k);for(let e=0;e<j.channels;++e){const j=V[e];for(let H=0;H<V[e].size;++H)u(i,j.start+H,j.nx,j.size,j.ny,j.nx*j.size,x)}!function(j,H,s){for(let i=0;i<s;++i)H[i]=j[H[i]]}(U,i,k);let a=0;const J=new Uint8Array(i.buffer.byteLength);for(let e=0;e<j.lines;e++)for(let H=0;H<j.channels;H++){const j=V[H],s=j.nx*j.size,B=new Uint8Array(i.buffer,2*j.end,2*s);J.set(B,a),a+=2*s,j.end+=s}return new DataView(J.buffer)}var y,A=s(504);!function(j){j[j.Float=0]="Float",j[j.HalfFloat=1]="HalfFloat"}(y||(y={}));class I{}I.DefaultOutputType=y.HalfFloat,I.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class f{constructor(){this.supportCascades=!1}loadCubeData(j,H,s,i,B){throw".exr not supported in Cube."}async loadData(j,H,s){const B=new DataView(j.buffer),e={value:0},k=function(j,H){if(20000630!=j.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const s=j.getUint8(4),B=j.getUint8(5),e={singleTile:!!(2&B),longName:!!(4&B),deepFormat:!!(8&B),multiPart:!!(16&B)};H.value=8;const k={};let V=!0;for(;V;){const s=p(j.buffer,H);if(s){const B=p(j.buffer,H),e=v(j,H,B,E(j,H));void 0===e?i.b.Warn(`Unknown header attribute type ${B}'.`):k[s]=e}else V=!1}if(0!=(-5&B))throw new Error("Unsupported file format");return{version:s,spec:e,...k}}(B,e),V=await async function(j,H,s,i){const B={size:0,viewer:H,array:new Uint8Array(H.buffer),offset:s,width:j.dataWindow.xMax-j.dataWindow.xMin+1,height:j.dataWindow.yMax-j.dataWindow.yMin+1,channels:j.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(j.compression){case L.NO_COMPRESSION:B.lines=1,B.uncompress=S;break;case L.RLE_COMPRESSION:B.lines=1,B.uncompress=T;break;case L.ZIPS_COMPRESSION:B.lines=1,B.uncompress=Z,await A.f.LoadScriptAsync(I.FFLATEUrl);break;case L.ZIP_COMPRESSION:B.lines=16,B.uncompress=Z,await A.f.LoadScriptAsync(I.FFLATEUrl);break;case L.PIZ_COMPRESSION:B.lines=32,B.uncompress=D;break;case L.PXR24_COMPRESSION:B.lines=16,B.uncompress=N,await A.f.LoadScriptAsync(I.FFLATEUrl);break;default:throw new Error(L[j.compression]+" is unsupported")}B.scanlineBlockSize=B.lines;const e={};for(const L of j.channels)switch(L.name){case"Y":case"R":case"G":case"B":case"A":e[L.name]=!0,B.type=L.pixelType}let k=!1;if(e.R&&e.G&&e.B)k=!e.A,B.outputChannels=4,B.decodeChannels={R:0,G:1,B:2,A:3};else{if(!e.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");B.outputChannels=1,B.decodeChannels={Y:0}}if(1===B.type)switch(i){case y.Float:B.getter=R,B.inputSize=2;break;case y.HalfFloat:B.getter=q,B.inputSize=2}else{if(2!==B.type)throw new Error("Unsupported pixelType "+B.type+" for "+j.compression);switch(i){case y.Float:B.getter=o,B.inputSize=4;break;case y.HalfFloat:B.getter=Y,B.inputSize=4}}B.blockCount=B.height/B.scanlineBlockSize;for(let L=0;L<B.blockCount;L++)h(H,s);const V=B.width*B.height*B.outputChannels;switch(i){case y.Float:B.byteArray=new Float32Array(V),B.textureType=1,k&&B.byteArray.fill(1,0,V);break;case y.HalfFloat:B.byteArray=new Uint16Array(V),B.textureType=2,k&&B.byteArray.fill(15360,0,V);break;default:throw new Error("Unsupported type: "+i)}let C=0;for(const L of j.channels)void 0!==B.decodeChannels[L.name]&&(B.channelLineOffsets[L.name]=C*B.width),C+=2*L.pixelType;return B.bytesPerLine=B.width*C,B.outLineWidth=B.width*B.outputChannels,"INCREASING_Y"===j.lineOrder?B.scanOrder=j=>j:B.scanOrder=j=>B.height-1-j,4==B.outputChannels?(B.format=5,B.linearSpace=!0):(B.format=6,B.linearSpace=!1),B}(k,B,e,I.DefaultOutputType);!function(j,H,s,i){const B={value:0};for(let e=0;e<j.height/j.scanlineBlockSize;e++){const k=a(s,i)-H.dataWindow.yMin;j.size=E(s,i),j.lines=k+j.scanlineBlockSize>j.height?j.height-k:j.scanlineBlockSize;const V=j.size<j.lines*j.bytesPerLine&&j.uncompress?j.uncompress(j):S(j);i.value+=j.size;for(let s=0;s<j.scanlineBlockSize;s++){const i=e*j.scanlineBlockSize,k=s+j.scanOrder(i);if(k>=j.height)continue;const C=s*j.bytesPerLine,L=(j.height-1-k)*j.outLineWidth;for(let s=0;s<j.channels;s++){const i=H.channels[s].name,e=j.channelLineOffsets[i],k=j.decodeChannels[i];if(void 0!==k){B.value=C+e;for(let H=0;H<j.width;H++){const s=L+H*j.outputChannels+k;j.byteArray&&(j.byteArray[s]=j.getter(V,B))}}}}}}(V,k,B,e);s(k.dataWindow.xMax-k.dataWindow.xMin+1,k.dataWindow.yMax-k.dataWindow.yMin+1,H.generateMipMaps,!1,(()=>{const j=H.getEngine();H.format=k.format,H.type=V.textureType,H.invertY=!1,H._gammaSpace=!k.linearSpace,V.byteArray&&j._uploadDataToTextureDirectly(H,V.byteArray,0,0,void 0,!0)}))}}}}]);