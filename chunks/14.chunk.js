"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[14],{12974:(M,A,O)=>{O.d(A,{e:()=>X,g:()=>Q,k:()=>S,n:()=>z});const S=1/2.2,z=2.2,Q=(1+Math.sqrt(5))/2,X=.001},12980:(M,A,O)=>{function S(M){return parseInt(M.toString().replace(/\W/g,""))}function z(M,A){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(M-A)<=O}function Q(M,A,O){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return M<A-S||M>O+S}function X(M,A){return M===A?M:Math.random()*(A-M)+M}function c(M,A,O){return M+(A-M)*O}function j(M,A,O){let S=d(A-M,360);return S>180&&(S-=360),M+S*T(O)}function B(M,A,O){let S=0;return S=M!=A?T((O-M)/(A-M)):0,S}function g(M,A,O,S,z){const Q=z*z,X=z*Q;return M*(2*X-3*Q+1)+O*(-2*X+3*Q)+A*(X-2*Q+z)+S*(X-Q)}function e(M,A,O,S,z){const Q=z*z;return 6*(Q-z)*M+(3*Q-4*z+1)*A+6*(-Q+z)*O+(3*Q-2*z)*S}function T(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(O,Math.max(A,M))}function J(M){return M-=2*Math.PI*Math.floor((M+Math.PI)/(2*Math.PI))}function K(M){const A=M.toString(16);return M<=15?("0"+A).toUpperCase():A.toUpperCase()}function G(M){if(Math.log2)return Math.floor(Math.log2(M));if(M<0)return NaN;if(0===M)return-1/0;let A=0;if(M<1){for(;M<1;)A++,M*=2;A=-A}else if(M>1)for(;M>1;)A++,M=Math.floor(M/2);return A}function d(M,A){return M-Math.floor(M/A)*A}function w(M,A,O){return(M-A)/(O-A)}function I(M,A,O){return M*(O-A)+A}function b(M,A){let O=d(A-M,360);return O>180&&(O-=360),O}function s(M,A){const O=d(M,2*A);return A-Math.abs(O-A)}function Y(M,A,O){let S=T(O);return S=-2*S*S*S+3*S*S,A*S+M*(1-S)}function E(M,A,O){let S=0;return S=Math.abs(A-M)<=O?A:M+Math.sign(A-M)*O,S}function H(M,A,O){const S=b(M,A);let z=0;return z=-O<S&&S<O?A:E(M,A=M+S,O),z}function C(M,A,O){return(M-A)/(O-A)}function f(M,A,O){return(O-A)*M+A}function D(M,A){const O=M%A;return 0===O?A:D(A,O)}O.r(A),O.d(A,{Clamp:()=>T,DeltaAngle:()=>b,Denormalize:()=>I,ExtractAsInt:()=>S,Hermite:()=>g,Hermite1stDerivative:()=>e,HighestCommonFactor:()=>D,ILog2:()=>G,InverseLerp:()=>B,Lerp:()=>c,LerpAngle:()=>j,MoveTowards:()=>E,MoveTowardsAngle:()=>H,Normalize:()=>w,NormalizeRadians:()=>J,OutsideRange:()=>Q,PercentToRange:()=>f,PingPong:()=>s,RandomRange:()=>X,RangeToPercent:()=>C,Repeat:()=>d,SmoothStep:()=>Y,ToHex:()=>K,WithinEpsilon:()=>z})},12970:(M,A,O)=>{O.r(A),O.d(A,{Matrix:()=>I,Quaternion:()=>w,TmpVectors:()=>s,Vector2:()=>K,GA:()=>G,Vector4:()=>d});var S=O(12974),z=O(12977),Q=O(12919),X=O(12883),c=O(12811),j=O(12980);class B{}function g(M,A,O){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const z=M.gc(),Q=A.gc(),X=z[0],c=z[1],j=z[2],B=z[3],g=z[4],e=z[5],T=z[6],J=z[7],K=z[8],G=z[9],d=z[10],w=z[11],I=z[12],b=z[13],s=z[14],Y=z[15],E=Q[0],H=Q[1],C=Q[2],f=Q[3],D=Q[4],F=Q[5],N=Q[6],y=Q[7],h=Q[8],u=Q[9],i=Q[10],U=Q[11],L=Q[12],t=Q[13],x=Q[14],o=Q[15];O[S]=X*E+c*D+j*h+B*L,O[S+1]=X*H+c*F+j*u+B*t,O[S+2]=X*C+c*N+j*i+B*x,O[S+3]=X*f+c*y+j*U+B*o,O[S+4]=g*E+e*D+T*h+J*L,O[S+5]=g*H+e*F+T*u+J*t,O[S+6]=g*C+e*N+T*i+J*x,O[S+7]=g*f+e*y+T*U+J*o,O[S+8]=K*E+G*D+d*h+w*L,O[S+9]=K*H+G*F+d*u+w*t,O[S+10]=K*C+G*N+d*i+w*x,O[S+11]=K*f+G*y+d*U+w*o,O[S+12]=I*E+b*D+s*h+Y*L,O[S+13]=I*H+b*F+s*u+Y*t,O[S+14]=I*C+b*N+s*i+Y*x,O[S+15]=I*f+b*y+s*U+Y*o}function e(M,A){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const S=M.gc();A[O]=S[0],A[O+1]=S[1],A[O+2]=S[2],A[O+3]=S[3],A[O+4]=S[4],A[O+5]=S[5],A[O+6]=S[6],A[O+7]=S[7],A[O+8]=S[8],A[O+9]=S[9],A[O+10]=S[10],A[O+11]=S[11],A[O+12]=S[12],A[O+13]=S[13],A[O+14]=S[14],A[O+15]=S[15]}function T(M,A){const O=M.gc(),S=O[0],z=O[1],Q=O[2],X=O[3],c=O[4],j=O[5],B=O[6],g=O[7],e=O[8],T=O[9],J=O[10],K=O[11],G=O[12],d=O[13],w=O[14],I=O[15],b=J*I-w*K,s=T*I-d*K,Y=T*w-d*J,E=e*I-G*K,H=e*w-J*G,C=e*d-G*T,f=+(j*b-B*s+g*Y),D=-(c*b-B*E+g*H),F=+(c*s-j*E+g*C),N=-(c*Y-j*H+B*C),y=S*f+z*D+Q*F+X*N;if(0===y)return!1;const h=1/y,u=B*I-w*g,i=j*I-d*g,U=j*w-d*B,L=c*I-G*g,t=c*w-G*B,x=c*d-G*j,o=B*K-J*g,p=j*K-T*g,v=j*J-T*B,q=c*K-e*g,r=c*J-e*B,n=c*T-e*j,a=-(z*b-Q*s+X*Y),V=+(S*b-Q*E+X*H),Z=-(S*s-z*E+X*C),P=+(S*Y-z*H+Q*C),mM=+(z*u-Q*i+X*U),R=-(S*u-Q*L+X*t),k=+(S*i-z*L+X*x),W=-(S*U-z*t+Q*x),l=-(z*o-Q*p+X*v),MM=+(S*o-Q*q+X*r),AM=-(S*p-z*q+X*n),OM=+(S*v-z*r+Q*n);return A[0]=f*h,A[1]=a*h,A[2]=mM*h,A[3]=l*h,A[4]=D*h,A[5]=V*h,A[6]=R*h,A[7]=MM*h,A[8]=F*h,A[9]=Z*h,A[10]=k*h,A[11]=AM*h,A[12]=N*h,A[13]=P*h,A[14]=W*h,A[15]=OM*h,!0}B._UpdateFlagSeed=0;const J=M=>parseInt(M.toString().replace(/\W/g,""));class K{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=M,this.y=A}toString(){return"{X: ".concat(this.x," Y: ").concat(this.y,"}")}getClassName(){return"Vector2"}getHashCode(){let M=J(this.x);return M=397*M^J(this.y),M}toArray(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[A]=this.x,M[A+1]=this.y,this}GO(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(M,A,this),this}gc(){return[this.x,this.y]}S(M){return this.x=M.x,this.y=M.y,this}Yc(M,A){return this.x=M,this.y=A,this}set(M,A){return this.Yc(M,A)}Hc(M){return this.Yc(M,M)}add(M){return new K(this.x+M.x,this.y+M.y)}addToRef(M,A){return A.x=this.x+M.x,A.y=this.y+M.y,A}addInPlace(M){return this.x+=M.x,this.y+=M.y,this}addInPlaceFromFloats(M,A){return this.x+=M,this.y+=A,this}addVector3(M){return new K(this.x+M.x,this.y+M.y)}dA(M){return new K(this.x-M.x,this.y-M.y)}subtractToRef(M,A){return A.x=this.x-M.x,A.y=this.y-M.y,A}KT(M){return this.x-=M.x,this.y-=M.y,this}multiplyInPlace(M){return this.x*=M.x,this.y*=M.y,this}multiply(M){return new K(this.x*M.x,this.y*M.y)}multiplyToRef(M,A){return A.x=this.x*M.x,A.y=this.y*M.y,A}multiplyByFloats(M,A){return new K(this.x*M,this.y*A)}divide(M){return new K(this.x/M.x,this.y/M.y)}divideToRef(M,A){return A.x=this.x/M.x,A.y=this.y/M.y,A}divideInPlace(M){return this.x=this.x/M.x,this.y=this.y/M.y,this}minimizeInPlace(M){return this.minimizeInPlaceFromFloats(M.x,M.y)}maximizeInPlace(M){return this.maximizeInPlaceFromFloats(M.x,M.y)}minimizeInPlaceFromFloats(M,A){return this.x=Math.min(M,this.x),this.y=Math.min(A,this.y),this}maximizeInPlaceFromFloats(M,A){return this.x=Math.max(M,this.x),this.y=Math.max(A,this.y),this}subtractFromFloats(M,A){return new K(this.x-M,this.y-A)}subtractFromFloatsToRef(M,A,O){return O.x=this.x-M,O.y=this.y-A,O}negate(){return new K(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(M){return M.x=-this.x,M.y=-this.y,M}scaleInPlace(M){return this.x*=M,this.y*=M,this}scale(M){return new K(this.x*M,this.y*M)}scaleToRef(M,A){return A.x=this.x*M,A.y=this.y*M,A}scaleAndAddToRef(M,A){return A.x+=this.x*M,A.y+=this.y*M,A}equals(M){return M&&this.x===M.x&&this.y===M.y}equalsWithEpsilon(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.e;return M&&(0,j.WithinEpsilon)(this.x,M.x,A)&&(0,j.WithinEpsilon)(this.y,M.y,A)}equalsToFloats(M,A){return this.x===M&&this.y===A}floor(){return new K(Math.floor(this.x),Math.floor(this.y))}floorToRef(M){return M.x=Math.floor(this.x),M.y=Math.floor(this.y),M}fract(){return new K(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(M){return M.x=this.x-Math.floor(this.x),M.y=this.y-Math.floor(this.y),M}rotate(M){return this.rotateToRef(M,new K)}rotateToRef(M,A){const O=Math.cos(M),S=Math.sin(M);return A.x=O*this.x-S*this.y,A.y=S*this.x+O*this.y,A}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){const M=new K;return this.normalizeToRef(M),M}normalizeToRef(M){const A=this.length();return 0===A&&(M.x=this.x,M.y=this.y),this.scaleToRef(1/A,M)}clone(){return new K(this.x,this.y)}dot(M){return this.x*M.x+this.y*M.y}static Zero(){return new K(0,0)}static One(){return new K(1,1)}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new K((0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Yc((0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A))}static get ZeroReadOnly(){return K._ZeroReadOnly}static sA(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new K(M[A],M[A+1])}static FromArrayToRef(M,A,O){return O.x=M[A],O.y=M[A+1],O}static FromFloatsToRef(M,A,O){return O.Yc(M,A),O}static CatmullRom(M,A,O,S,z){const Q=z*z,X=z*Q,c=.5*(2*A.x+(-M.x+O.x)*z+(2*M.x-5*A.x+4*O.x-S.x)*Q+(-M.x+3*A.x-3*O.x+S.x)*X),j=.5*(2*A.y+(-M.y+O.y)*z+(2*M.y-5*A.y+4*O.y-S.y)*Q+(-M.y+3*A.y-3*O.y+S.y)*X);return new K(c,j)}static ClampToRef(M,A,O,S){return S.x=(0,j.Clamp)(M.x,A.x,O.x),S.y=(0,j.Clamp)(M.y,A.y,O.y),S}static Clamp(M,A,O){const S=(0,j.Clamp)(M.x,A.x,O.x),z=(0,j.Clamp)(M.y,A.y,O.y);return new K(S,z)}static Hermite(M,A,O,S,z){const Q=z*z,X=z*Q,c=2*X-3*Q+1,j=-2*X+3*Q,B=X-2*Q+z,g=X-Q,e=M.x*c+O.x*j+A.x*B+S.x*g,T=M.y*c+O.y*j+A.y*B+S.y*g;return new K(e,T)}static Hermite1stDerivative(M,A,O,S,z){return this.Hermite1stDerivativeToRef(M,A,O,S,z,new K)}static Hermite1stDerivativeToRef(M,A,O,S,z,Q){const X=z*z;return Q.x=6*(X-z)*M.x+(3*X-4*z+1)*A.x+6*(-X+z)*O.x+(3*X-2*z)*S.x,Q.y=6*(X-z)*M.y+(3*X-4*z+1)*A.y+6*(-X+z)*O.y+(3*X-2*z)*S.y,Q}static Lerp(M,A,O){return K.LerpToRef(M,A,O,new K)}static LerpToRef(M,A,O,S){return S.x=M.x+(A.x-M.x)*O,S.y=M.y+(A.y-M.y)*O,S}static Dot(M,A){return M.x*A.x+M.y*A.y}static Normalize(M){return K.NormalizeToRef(M,new K)}static NormalizeToRef(M,A){return M.normalizeToRef(A),A}static Minimize(M,A){const O=M.x<A.x?M.x:A.x,S=M.y<A.y?M.y:A.y;return new K(O,S)}static Maximize(M,A){const O=M.x>A.x?M.x:A.x,S=M.y>A.y?M.y:A.y;return new K(O,S)}static Transform(M,A){return K.TransformToRef(M,A,new K)}static TransformToRef(M,A,O){const S=A.m,z=M.x*S[0]+M.y*S[4]+S[12],Q=M.x*S[1]+M.y*S[5]+S[13];return O.x=z,O.y=Q,O}static PointInTriangle(M,A,O,S){const z=.5*(-O.y*S.x+A.y*(-O.x+S.x)+A.x*(O.y-S.y)+O.x*S.y),Q=z<0?-1:1,X=(A.y*S.x-A.x*S.y+(S.y-A.y)*M.x+(A.x-S.x)*M.y)*Q,c=(A.x*O.y-A.y*O.x+(A.y-O.y)*M.x+(O.x-A.x)*M.y)*Q;return X>0&&c>0&&X+c<2*z*Q}static Distance(M,A){return Math.sqrt(K.DistanceSquared(M,A))}static DistanceSquared(M,A){const O=M.x-A.x,S=M.y-A.y;return O*O+S*S}static Center(M,A){return K.CenterToRef(M,A,new K)}static CenterToRef(M,A,O){return O.Yc((M.x+A.x)/2,(M.y+A.y)/2)}static DistanceOfPointFromSegment(M,A,O){const S=K.DistanceSquared(A,O);if(0===S)return K.Distance(M,A);const z=O.dA(A),Q=Math.max(0,Math.min(1,K.Dot(M.dA(A),z)/S)),X=A.add(z.multiplyByFloats(Q,Q));return K.Distance(M,X)}}K._V8PerformanceHack=new K(.5,.5),K._ZeroReadOnly=K.Zero(),Object.defineProperties(K.prototype,{dimension:{value:[2]},rank:{value:1}});class G{get x(){return this._x}set x(M){this._x=M,this._isDirty=!0}get y(){return this._y}set y(M){this._y=M,this._isDirty=!0}get z(){return this._z}set z(M){this._z=M,this._isDirty=!0}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=M,this._y=A,this._z=O}toString(){return"{X: ".concat(this._x," Y: ").concat(this._y," Z: ").concat(this._z,"}")}getClassName(){return"GA"}getHashCode(){let M=J(this._x);return M=397*M^J(this._y),M=397*M^J(this._z),M}gc(){return[this._x,this._y,this._z]}toArray(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[A]=this._x,M[A+1]=this._y,M[A+2]=this._z,this}GO(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G.FromArrayToRef(M,A,this),this}toQuaternion(){return w.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(M){return this._x+=M._x,this._y+=M._y,this._z+=M._z,this._isDirty=!0,this}addInPlaceFromFloats(M,A,O){return this._x+=M,this._y+=A,this._z+=O,this._isDirty=!0,this}add(M){return new G(this._x+M._x,this._y+M._y,this._z+M._z)}addToRef(M,A){return A._x=this._x+M._x,A._y=this._y+M._y,A._z=this._z+M._z,A._isDirty=!0,A}KT(M){return this._x-=M._x,this._y-=M._y,this._z-=M._z,this._isDirty=!0,this}dA(M){return new G(this._x-M._x,this._y-M._y,this._z-M._z)}subtractToRef(M,A){return this.subtractFromFloatsToRef(M._x,M._y,M._z,A)}subtractFromFloats(M,A,O){return new G(this._x-M,this._y-A,this._z-O)}subtractFromFloatsToRef(M,A,O,S){return S._x=this._x-M,S._y=this._y-A,S._z=this._z-O,S._isDirty=!0,S}negate(){return new G(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(M){return M._x=-1*this._x,M._y=-1*this._y,M._z=-1*this._z,M._isDirty=!0,M}scaleInPlace(M){return this._x*=M,this._y*=M,this._z*=M,this._isDirty=!0,this}scale(M){return new G(this._x*M,this._y*M,this._z*M)}scaleToRef(M,A){return A._x=this._x*M,A._y=this._y*M,A._z=this._z*M,A._isDirty=!0,A}getNormalToRef(M){const A=this.length();let O=Math.acos(this._y/A);const S=Math.atan2(this._z,this._x);O>Math.PI/2?O-=Math.PI/2:O+=Math.PI/2;const z=A*Math.sin(O)*Math.cos(S),Q=A*Math.cos(O),X=A*Math.sin(O)*Math.sin(S);return M.set(z,Q,X),M}applyRotationQuaternionToRef(M,A){const O=this._x,S=this._y,z=this._z,Q=M._x,X=M._y,c=M._z,j=M._w,B=2*(X*z-c*S),g=2*(c*O-Q*z),e=2*(Q*S-X*O);return A._x=O+j*B+X*e-c*g,A._y=S+j*g+c*B-Q*e,A._z=z+j*e+Q*g-X*B,A._isDirty=!0,A}applyRotationQuaternionInPlace(M){return this.applyRotationQuaternionToRef(M,this)}applyRotationQuaternion(M){return this.applyRotationQuaternionToRef(M,new G)}scaleAndAddToRef(M,A){return A._x+=this._x*M,A._y+=this._y*M,A._z+=this._z*M,A._isDirty=!0,A}projectOnPlane(M,A){return this.projectOnPlaneToRef(M,A,new G)}projectOnPlaneToRef(M,A,O){const S=M.normal,z=M.d,Q=b.GA[0];this.subtractToRef(A,Q),Q.normalize();const X=G.Dot(Q,S);if(Math.abs(X)<1e-10)O.Hc(1/0);else{const M=-(G.Dot(A,S)+z)/X,c=Q.scaleInPlace(M);A.addToRef(c,O)}return O}equals(M){return M&&this._x===M._x&&this._y===M._y&&this._z===M._z}equalsWithEpsilon(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.e;return M&&(0,j.WithinEpsilon)(this._x,M._x,A)&&(0,j.WithinEpsilon)(this._y,M._y,A)&&(0,j.WithinEpsilon)(this._z,M._z,A)}equalsToFloats(M,A,O){return this._x===M&&this._y===A&&this._z===O}multiplyInPlace(M){return this._x*=M._x,this._y*=M._y,this._z*=M._z,this._isDirty=!0,this}multiply(M){return this.multiplyByFloats(M._x,M._y,M._z)}multiplyToRef(M,A){return A._x=this._x*M._x,A._y=this._y*M._y,A._z=this._z*M._z,A._isDirty=!0,A}multiplyByFloats(M,A,O){return new G(this._x*M,this._y*A,this._z*O)}divide(M){return new G(this._x/M._x,this._y/M._y,this._z/M._z)}divideToRef(M,A){return A._x=this._x/M._x,A._y=this._y/M._y,A._z=this._z/M._z,A._isDirty=!0,A}divideInPlace(M){return this._x=this._x/M._x,this._y=this._y/M._y,this._z=this._z/M._z,this._isDirty=!0,this}minimizeInPlace(M){return this.minimizeInPlaceFromFloats(M._x,M._y,M._z)}maximizeInPlace(M){return this.maximizeInPlaceFromFloats(M._x,M._y,M._z)}minimizeInPlaceFromFloats(M,A,O){return M<this._x&&(this.x=M),A<this._y&&(this.y=A),O<this._z&&(this.z=O),this}maximizeInPlaceFromFloats(M,A,O){return M>this._x&&(this.x=M),A>this._y&&(this.y=A),O>this._z&&(this.z=O),this}isNonUniformWithinEpsilon(M){const A=Math.abs(this._x),O=Math.abs(this._y);if(!(0,j.WithinEpsilon)(A,O,M))return!0;const S=Math.abs(this._z);return!(0,j.WithinEpsilon)(A,S,M)||!(0,j.WithinEpsilon)(O,S,M)}get isNonUniform(){const M=Math.abs(this._x);if(M!==Math.abs(this._y))return!0;return M!==Math.abs(this._z)}floorToRef(M){return M._x=Math.floor(this._x),M._y=Math.floor(this._y),M._z=Math.floor(this._z),M._isDirty=!0,M}floor(){return new G(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(M){return M._x=this._x-Math.floor(this._x),M._y=this._y-Math.floor(this._y),M._z=this._z-Math.floor(this._z),M._isDirty=!0,M}fract(){return new G(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(M){if("xyz"===(M=M.toLowerCase()))return this;const A=b.GA[0].S(this);return this.x=A[M[0]],this.y=A[M[1]],this.z=A[M[2]],this}rotateByQuaternionToRef(M,A){return M.toRotationMatrix(b.Matrix[0]),G.TransformCoordinatesToRef(this,b.Matrix[0],A),A}rotateByQuaternionAroundPointToRef(M,A,O){return this.subtractToRef(A,b.GA[0]),b.GA[0].rotateByQuaternionToRef(M,b.GA[0]),A.addToRef(b.GA[0],O),O}cross(M){return G.CrossToRef(this,M,new G)}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){return this.normalizeToRef(new G)}normalizeToRef(M){const A=this.length();return 0===A||1===A?(M._x=this._x,M._y=this._y,M._z=this._z,M._isDirty=!0,M):this.scaleToRef(1/A,M)}clone(){return new G(this._x,this._y,this._z)}S(M){return this.Yc(M._x,M._y,M._z)}Yc(M,A,O){return this._x=M,this._y=A,this._z=O,this._isDirty=!0,this}set(M,A,O){return this.Yc(M,A,O)}Hc(M){return this._x=this._y=this._z=M,this._isDirty=!0,this}static GetClipFactor(M,A,O,S){const z=G.Dot(M,O);return(z-S)/(z-G.Dot(A,O))}static GetAngleBetweenVectors(M,A,O){const S=M.normalizeToRef(b.GA[1]),z=A.normalizeToRef(b.GA[2]);let Q=G.Dot(S,z);Q=(0,j.Clamp)(Q,-1,1);const X=Math.acos(Q),c=b.GA[3];return G.CrossToRef(S,z,c),G.Dot(c,O)>0?isNaN(X)?0:X:isNaN(X)?-Math.PI:-Math.acos(Q)}static GetAngleBetweenVectorsOnPlane(M,A,O){b.GA[0].S(M);const S=b.GA[0];b.GA[1].S(A);const z=b.GA[1];b.GA[2].S(O);const Q=b.GA[2],X=b.GA[3],c=b.GA[4];S.normalize(),z.normalize(),Q.normalize(),G.CrossToRef(Q,S,X),G.CrossToRef(X,Q,c);const B=Math.atan2(G.Dot(z,X),G.Dot(z,c));return(0,j.NormalizeRadians)(B)}static PitchYawRollToMoveBetweenPointsToRef(M,A,O){const S=s.GA[0];return A.subtractToRef(M,S),O._y=Math.atan2(S.x,S.z)||0,O._x=Math.atan2(Math.sqrt(S.x**2+S.z**2),S.y)||0,O._z=0,O._isDirty=!0,O}static PitchYawRollToMoveBetweenPoints(M,A){const O=G.Zero();return G.PitchYawRollToMoveBetweenPointsToRef(M,A,O)}static SlerpToRef(M,A,O,z){O=(0,j.Clamp)(O,0,1);const Q=b.GA[0],X=b.GA[1];Q.S(M);const c=Q.length();Q.normalizeFromLength(c),X.S(A);const B=X.length();X.normalizeFromLength(B);const g=G.Dot(Q,X);let e,T;if(g<1-S.e){const M=Math.acos(g),A=1/Math.sin(M);e=Math.sin((1-O)*M)*A,T=Math.sin(O*M)*A}else e=1-O,T=O;return Q.scaleInPlace(e),X.scaleInPlace(T),z.S(Q).addInPlace(X),z.scaleInPlace((0,j.Lerp)(c,B,O)),z}static SmoothToRef(M,A,O,S,z){return G.SlerpToRef(M,A,0===S?1:O/S,z),z}static sA(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new G(M[A],M[A+1],M[A+2])}static FromFloatArray(M,A){return G.sA(M,A)}static FromArrayToRef(M,A,O){return O._x=M[A],O._y=M[A+1],O._z=M[A+2],O._isDirty=!0,O}static FromFloatArrayToRef(M,A,O){return G.FromArrayToRef(M,A,O)}static FromFloatsToRef(M,A,O,S){return S.Yc(M,A,O),S}static Zero(){return new G(0,0,0)}static One(){return new G(1,1,1)}static Up(){return new G(0,1,0)}static get UpReadOnly(){return G._UpReadOnly}static get DownReadOnly(){return G._DownReadOnly}static get RightReadOnly(){return G._RightReadOnly}static get LeftReadOnly(){return G._LeftReadOnly}static get LeftHandedForwardReadOnly(){return G._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return G._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return G._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return G._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return G._ZeroReadOnly}static get OneReadOnly(){return G._OneReadOnly}static Down(){return new G(0,-1,0)}static Forward(){return new G(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new G(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new G(1,0,0)}static Left(){return new G(-1,0,0)}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new G((0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Yc((0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A))}static TransformCoordinates(M,A){const O=G.Zero();return G.TransformCoordinatesToRef(M,A,O),O}static TransformCoordinatesToRef(M,A,O){return G.TransformCoordinatesFromFloatsToRef(M._x,M._y,M._z,A,O),O}static TransformCoordinatesFromFloatsToRef(M,A,O,S,z){const Q=S.m,X=M*Q[0]+A*Q[4]+O*Q[8]+Q[12],c=M*Q[1]+A*Q[5]+O*Q[9]+Q[13],j=M*Q[2]+A*Q[6]+O*Q[10]+Q[14],B=1/(M*Q[3]+A*Q[7]+O*Q[11]+Q[15]);return z._x=X*B,z._y=c*B,z._z=j*B,z._isDirty=!0,z}static TransformNormal(M,A){const O=G.Zero();return G.TransformNormalToRef(M,A,O),O}static TransformNormalToRef(M,A,O){return this.TransformNormalFromFloatsToRef(M._x,M._y,M._z,A,O),O}static TransformNormalFromFloatsToRef(M,A,O,S,z){const Q=S.m;return z._x=M*Q[0]+A*Q[4]+O*Q[8],z._y=M*Q[1]+A*Q[5]+O*Q[9],z._z=M*Q[2]+A*Q[6]+O*Q[10],z._isDirty=!0,z}static CatmullRom(M,A,O,S,z){const Q=z*z,X=z*Q,c=.5*(2*A._x+(-M._x+O._x)*z+(2*M._x-5*A._x+4*O._x-S._x)*Q+(-M._x+3*A._x-3*O._x+S._x)*X),j=.5*(2*A._y+(-M._y+O._y)*z+(2*M._y-5*A._y+4*O._y-S._y)*Q+(-M._y+3*A._y-3*O._y+S._y)*X),B=.5*(2*A._z+(-M._z+O._z)*z+(2*M._z-5*A._z+4*O._z-S._z)*Q+(-M._z+3*A._z-3*O._z+S._z)*X);return new G(c,j,B)}static Clamp(M,A,O){const S=new G;return G.ClampToRef(M,A,O,S),S}static ClampToRef(M,A,O,S){let z=M._x;z=z>O._x?O._x:z,z=z<A._x?A._x:z;let Q=M._y;Q=Q>O._y?O._y:Q,Q=Q<A._y?A._y:Q;let X=M._z;return X=X>O._z?O._z:X,X=X<A._z?A._z:X,S.Yc(z,Q,X),S}static CheckExtends(M,A,O){A.minimizeInPlace(M),O.maximizeInPlace(M)}static Hermite(M,A,O,S,z){const Q=z*z,X=z*Q,c=2*X-3*Q+1,j=-2*X+3*Q,B=X-2*Q+z,g=X-Q,e=M._x*c+O._x*j+A._x*B+S._x*g,T=M._y*c+O._y*j+A._y*B+S._y*g,J=M._z*c+O._z*j+A._z*B+S._z*g;return new G(e,T,J)}static Hermite1stDerivative(M,A,O,S,z){const Q=new G;return this.Hermite1stDerivativeToRef(M,A,O,S,z,Q),Q}static Hermite1stDerivativeToRef(M,A,O,S,z,Q){const X=z*z;return Q._x=6*(X-z)*M._x+(3*X-4*z+1)*A._x+6*(-X+z)*O._x+(3*X-2*z)*S._x,Q._y=6*(X-z)*M._y+(3*X-4*z+1)*A._y+6*(-X+z)*O._y+(3*X-2*z)*S._y,Q._z=6*(X-z)*M._z+(3*X-4*z+1)*A._z+6*(-X+z)*O._z+(3*X-2*z)*S._z,Q._isDirty=!0,Q}static Lerp(M,A,O){const S=new G(0,0,0);return G.LerpToRef(M,A,O,S),S}static LerpToRef(M,A,O,S){return S._x=M._x+(A._x-M._x)*O,S._y=M._y+(A._y-M._y)*O,S._z=M._z+(A._z-M._z)*O,S._isDirty=!0,S}static Dot(M,A){return M._x*A._x+M._y*A._y+M._z*A._z}dot(M){return this._x*M._x+this._y*M._y+this._z*M._z}static Cross(M,A){const O=new G;return G.CrossToRef(M,A,O),O}static CrossToRef(M,A,O){const S=M._y*A._z-M._z*A._y,z=M._z*A._x-M._x*A._z,Q=M._x*A._y-M._y*A._x;return O.Yc(S,z,Q),O}static Normalize(M){const A=G.Zero();return G.NormalizeToRef(M,A),A}static NormalizeToRef(M,A){return M.normalizeToRef(A),A}static Project(M,A,O,S){const z=new G;return G.ProjectToRef(M,A,O,S,z),z}static ProjectToRef(M,A,O,S,z){var Q;const X=S.width,j=S.height,B=S.x,g=S.y,e=b.Matrix[1],T=null===(Q=c.d.LastCreatedEngine)||void 0===Q?void 0:Q.isNDCHalfZRange,J=T?1:.5,K=T?0:.5;I.FromValuesToRef(X/2,0,0,0,0,-j/2,0,0,0,0,J,0,B+X/2,j/2+g,K,1,e);const d=b.Matrix[0];return A.multiplyToRef(O,d),d.multiplyToRef(e,d),G.TransformCoordinatesToRef(M,d,z),z}static Reflect(M,A){return this.ReflectToRef(M,A,new G)}static ReflectToRef(M,A,O){const S=s.GA[0];return S.S(A).scaleInPlace(2*G.Dot(M,A)),O.S(M).KT(S)}static _UnprojectFromInvertedMatrixToRef(M,A,O){G.TransformCoordinatesToRef(M,A,O);const S=A.m,z=M._x*S[3]+M._y*S[7]+M._z*S[11]+S[15];return(0,j.WithinEpsilon)(z,1)&&O.scaleInPlace(1/z),O}static UnprojectFromTransform(M,A,O,S,z){return this.Unproject(M,A,O,S,z,I.IdentityReadOnly)}static Unproject(M,A,O,S,z,Q){const X=new G;return G.UnprojectToRef(M,A,O,S,z,Q,X),X}static UnprojectToRef(M,A,O,S,z,Q,X){return G.UnprojectFloatsToRef(M._x,M._y,M._z,A,O,S,z,Q,X),X}static UnprojectFloatsToRef(M,A,O,S,z,Q,X,j,B){var g;const e=b.Matrix[0];Q.multiplyToRef(X,e),e.multiplyToRef(j,e),e.invert();const T=b.GA[0];return T.x=M/S*2-1,T.y=-(A/z*2-1),null!==(g=c.d.LastCreatedEngine)&&void 0!==g&&g.isNDCHalfZRange?T.z=O:T.z=2*O-1,G._UnprojectFromInvertedMatrixToRef(T,e,B),B}static Minimize(M,A){const O=new G;return O.S(M),O.minimizeInPlace(A),O}static Maximize(M,A){const O=new G;return O.S(M),O.maximizeInPlace(A),O}static Distance(M,A){return Math.sqrt(G.DistanceSquared(M,A))}static DistanceSquared(M,A){const O=M._x-A._x,S=M._y-A._y,z=M._z-A._z;return O*O+S*S+z*z}static ProjectOnTriangleToRef(M,A,O,z,Q){const X=b.GA[0],c=b.GA[1],B=b.GA[2],g=b.GA[3],e=b.GA[4];O.subtractToRef(A,X),z.subtractToRef(A,c),z.subtractToRef(O,B);const T=X.length(),J=c.length(),K=B.length();if(T<S.e||J<S.e||K<S.e)return Q.S(A),G.Distance(M,A);M.subtractToRef(A,e),G.CrossToRef(X,c,g);const d=g.length();if(d<S.e)return Q.S(A),G.Distance(M,A);g.normalizeFromLength(d);let w=e.length();if(w<S.e)return Q.S(A),0;e.normalizeFromLength(w);const I=G.Dot(g,e),s=b.GA[5],Y=b.GA[6];s.S(g).scaleInPlace(-w*I),Y.S(M).addInPlace(s);const E=b.GA[4],H=b.GA[5],C=b.GA[7],f=b.GA[8];E.S(X).scaleInPlace(1/T),f.S(c).scaleInPlace(1/J),E.addInPlace(f).scaleInPlace(-1),H.S(X).scaleInPlace(-1/T),f.S(B).scaleInPlace(1/K),H.addInPlace(f).scaleInPlace(-1),C.S(B).scaleInPlace(-1/K),f.S(c).scaleInPlace(-1/J),C.addInPlace(f).scaleInPlace(-1);const D=b.GA[9];let F;D.S(Y).KT(A),G.CrossToRef(E,D,f),F=G.Dot(f,g);const N=F;D.S(Y).KT(O),G.CrossToRef(H,D,f),F=G.Dot(f,g);const y=F;D.S(Y).KT(z),G.CrossToRef(C,D,f),F=G.Dot(f,g);const h=F,u=b.GA[10];let i,U;N>0&&y<0?(u.S(X),i=A,U=O):y>0&&h<0?(u.S(B),i=O,U=z):(u.S(c).scaleInPlace(-1),i=z,U=A);const L=b.GA[9],t=b.GA[4];i.subtractToRef(Y,f),U.subtractToRef(Y,L),G.CrossToRef(f,L,t);if(!(G.Dot(t,g)<0))return Q.S(Y),Math.abs(w*I);const x=b.GA[5];G.CrossToRef(u,t,x),x.normalize();const o=b.GA[9];o.S(i).KT(Y);const p=o.length();if(p<S.e)return Q.S(i),G.Distance(M,i);o.normalizeFromLength(p);const v=G.Dot(x,o),q=b.GA[7];q.S(Y).addInPlace(x.scaleInPlace(p*v)),f.S(q).KT(i),w=u.length(),u.normalizeFromLength(w);let r=G.Dot(f,u)/Math.max(w,S.e);return r=(0,j.Clamp)(r,0,1),q.S(i).addInPlace(u.scaleInPlace(r*w)),Q.S(q),G.Distance(M,q)}static Center(M,A){return G.CenterToRef(M,A,G.Zero())}static CenterToRef(M,A,O){return O.Yc((M._x+A._x)/2,(M._y+A._y)/2,(M._z+A._z)/2)}static RotationFromAxis(M,A,O){const S=new G;return G.RotationFromAxisToRef(M,A,O,S),S}static RotationFromAxisToRef(M,A,O,S){const z=b.Quaternion[0];return w.RotationQuaternionFromAxisToRef(M,A,O,z),z.toEulerAnglesToRef(S),S}}G._V8PerformanceHack=new G(.5,.5,.5),G._UpReadOnly=G.Up(),G._DownReadOnly=G.Down(),G._LeftHandedForwardReadOnly=G.Forward(!1),G._RightHandedForwardReadOnly=G.Forward(!0),G._LeftHandedBackwardReadOnly=G.Backward(!1),G._RightHandedBackwardReadOnly=G.Backward(!0),G._RightReadOnly=G.Right(),G._LeftReadOnly=G.Left(),G._ZeroReadOnly=G.Zero(),G._OneReadOnly=G.One(),Object.defineProperties(G.prototype,{dimension:{value:[3]},rank:{value:1}});class d{get x(){return this._x}set x(M){this._x=M,this._isDirty=!0}get y(){return this._y}set y(M){this._y=M,this._isDirty=!0}get z(){return this._z}set z(M){this._z=M,this._isDirty=!0}get w(){return this._w}set w(M){this._w=M,this._isDirty=!0}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=M,this._y=A,this._z=O,this._w=S}toString(){return"{X: ".concat(this._x," Y: ").concat(this._y," Z: ").concat(this._z," W: ").concat(this._w,"}")}getClassName(){return"Vector4"}getHashCode(){let M=J(this._x);return M=397*M^J(this._y),M=397*M^J(this._z),M=397*M^J(this._w),M}gc(){return[this._x,this._y,this._z,this._w]}toArray(M,A){return void 0===A&&(A=0),M[A]=this._x,M[A+1]=this._y,M[A+2]=this._z,M[A+3]=this._w,this}GO(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return d.FromArrayToRef(M,A,this),this}addInPlace(M){return this.x+=M._x,this.y+=M._y,this.z+=M._z,this.w+=M._w,this}addInPlaceFromFloats(M,A,O,S){return this.x+=M,this.y+=A,this.z+=O,this.w+=S,this}add(M){return new d(this._x+M.x,this._y+M.y,this._z+M.z,this._w+M.w)}addToRef(M,A){return A.x=this._x+M.x,A.y=this._y+M.y,A.z=this._z+M.z,A.w=this._w+M.w,A}KT(M){return this.x-=M.x,this.y-=M.y,this.z-=M.z,this.w-=M.w,this}dA(M){return new d(this._x-M.x,this._y-M.y,this._z-M.z,this._w-M.w)}subtractToRef(M,A){return A.x=this._x-M.x,A.y=this._y-M.y,A.z=this._z-M.z,A.w=this._w-M.w,A}subtractFromFloats(M,A,O,S){return new d(this._x-M,this._y-A,this._z-O,this._w-S)}subtractFromFloatsToRef(M,A,O,S,z){return z.x=this._x-M,z.y=this._y-A,z.z=this._z-O,z.w=this._w-S,z}negate(){return new d(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(M){return M.x=-this._x,M.y=-this._y,M.z=-this._z,M.w=-this._w,M}scaleInPlace(M){return this.x*=M,this.y*=M,this.z*=M,this.w*=M,this}scale(M){return new d(this._x*M,this._y*M,this._z*M,this._w*M)}scaleToRef(M,A){return A.x=this._x*M,A.y=this._y*M,A.z=this._z*M,A.w=this._w*M,A}scaleAndAddToRef(M,A){return A.x+=this._x*M,A.y+=this._y*M,A.z+=this._z*M,A.w+=this._w*M,A}equals(M){return M&&this._x===M.x&&this._y===M.y&&this._z===M.z&&this._w===M.w}equalsWithEpsilon(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.e;return M&&(0,j.WithinEpsilon)(this._x,M.x,A)&&(0,j.WithinEpsilon)(this._y,M.y,A)&&(0,j.WithinEpsilon)(this._z,M.z,A)&&(0,j.WithinEpsilon)(this._w,M.w,A)}equalsToFloats(M,A,O,S){return this._x===M&&this._y===A&&this._z===O&&this._w===S}multiplyInPlace(M){return this.x*=M.x,this.y*=M.y,this.z*=M.z,this.w*=M.w,this}multiply(M){return new d(this._x*M.x,this._y*M.y,this._z*M.z,this._w*M.w)}multiplyToRef(M,A){return A.x=this._x*M.x,A.y=this._y*M.y,A.z=this._z*M.z,A.w=this._w*M.w,A}multiplyByFloats(M,A,O,S){return new d(this._x*M,this._y*A,this._z*O,this._w*S)}divide(M){return new d(this._x/M.x,this._y/M.y,this._z/M.z,this._w/M.w)}divideToRef(M,A){return A.x=this._x/M.x,A.y=this._y/M.y,A.z=this._z/M.z,A.w=this._w/M.w,A}divideInPlace(M){return this.divideToRef(M,this)}minimizeInPlace(M){return M.x<this._x&&(this.x=M.x),M.y<this._y&&(this.y=M.y),M.z<this._z&&(this.z=M.z),M.w<this._w&&(this.w=M.w),this}maximizeInPlace(M){return M.x>this._x&&(this.x=M.x),M.y>this._y&&(this.y=M.y),M.z>this._z&&(this.z=M.z),M.w>this._w&&(this.w=M.w),this}minimizeInPlaceFromFloats(M,A,O,S){return this.x=Math.min(M,this._x),this.y=Math.min(A,this._y),this.z=Math.min(O,this._z),this.w=Math.min(S,this._w),this}maximizeInPlaceFromFloats(M,A,O,S){return this.x=Math.max(M,this._x),this.y=Math.max(A,this._y),this.z=Math.max(O,this._z),this.w=Math.max(S,this._w),this}floorToRef(M){return M.x=Math.floor(this._x),M.y=Math.floor(this._y),M.z=Math.floor(this._z),M.w=Math.floor(this._w),M}floor(){return new d(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(M){return M.x=this._x-Math.floor(this._x),M.y=this._y-Math.floor(this._y),M.z=this._z-Math.floor(this._z),M.w=this._w-Math.floor(this._w),M}fract(){return new d(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){return this.normalizeToRef(new d)}normalizeToRef(M){const A=this.length();return 0===A||1===A?(M.x=this._x,M.y=this._y,M.z=this._z,M.w=this._w,M):this.scaleToRef(1/A,M)}toVector3(){return new G(this._x,this._y,this._z)}clone(){return new d(this._x,this._y,this._z,this._w)}S(M){return this.x=M.x,this.y=M.y,this.z=M.z,this.w=M.w,this}Yc(M,A,O,S){return this.x=M,this.y=A,this.z=O,this.w=S,this}set(M,A,O,S){return this.Yc(M,A,O,S)}Hc(M){return this.x=this.y=this.z=this.w=M,this}dot(M){return this._x*M.x+this._y*M.y+this._z*M.z+this._w*M.w}static sA(M,A){return A||(A=0),new d(M[A],M[A+1],M[A+2],M[A+3])}static FromArrayToRef(M,A,O){return O.x=M[A],O.y=M[A+1],O.z=M[A+2],O.w=M[A+3],O}static FromFloatArrayToRef(M,A,O){return d.FromArrayToRef(M,A,O),O}static FromFloatsToRef(M,A,O,S,z){return z.x=M,z.y=A,z.z=O,z.w=S,z}static Zero(){return new d(0,0,0,0)}static One(){return new d(1,1,1,1)}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new d((0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,O=arguments.length>2?arguments[2]:void 0;return O.x=(0,j.RandomRange)(M,A),O.y=(0,j.RandomRange)(M,A),O.z=(0,j.RandomRange)(M,A),O.w=(0,j.RandomRange)(M,A),O}static Clamp(M,A,O){return d.ClampToRef(M,A,O,new d)}static ClampToRef(M,A,O,S){return S.x=(0,j.Clamp)(M.x,A.x,O.x),S.y=(0,j.Clamp)(M.y,A.y,O.y),S.z=(0,j.Clamp)(M.z,A.z,O.z),S.w=(0,j.Clamp)(M.w,A.w,O.w),S}static CheckExtends(M,A,O){A.minimizeInPlace(M),O.maximizeInPlace(M)}static get ZeroReadOnly(){return d._ZeroReadOnly}static Normalize(M){return d.NormalizeToRef(M,new d)}static NormalizeToRef(M,A){return M.normalizeToRef(A),A}static Minimize(M,A){const O=new d;return O.S(M),O.minimizeInPlace(A),O}static Maximize(M,A){const O=new d;return O.S(M),O.maximizeInPlace(A),O}static Distance(M,A){return Math.sqrt(d.DistanceSquared(M,A))}static DistanceSquared(M,A){const O=M.x-A.x,S=M.y-A.y,z=M.z-A.z,Q=M.w-A.w;return O*O+S*S+z*z+Q*Q}static Center(M,A){return d.CenterToRef(M,A,new d)}static CenterToRef(M,A,O){return O.x=(M.x+A.x)/2,O.y=(M.y+A.y)/2,O.z=(M.z+A.z)/2,O.w=(M.w+A.w)/2,O}static TransformCoordinates(M,A){return d.TransformCoordinatesToRef(M,A,new d)}static TransformCoordinatesToRef(M,A,O){return d.TransformCoordinatesFromFloatsToRef(M._x,M._y,M._z,A,O),O}static TransformCoordinatesFromFloatsToRef(M,A,O,S,z){const Q=S.m,X=M*Q[0]+A*Q[4]+O*Q[8]+Q[12],c=M*Q[1]+A*Q[5]+O*Q[9]+Q[13],j=M*Q[2]+A*Q[6]+O*Q[10]+Q[14],B=M*Q[3]+A*Q[7]+O*Q[11]+Q[15];return z.x=X,z.y=c,z.z=j,z.w=B,z}static TransformNormal(M,A){return d.TransformNormalToRef(M,A,new d)}static TransformNormalToRef(M,A,O){const S=A.m,z=M.x*S[0]+M.y*S[4]+M.z*S[8],Q=M.x*S[1]+M.y*S[5]+M.z*S[9],X=M.x*S[2]+M.y*S[6]+M.z*S[10];return O.x=z,O.y=Q,O.z=X,O.w=M.w,O}static TransformNormalFromFloatsToRef(M,A,O,S,z,Q){const X=z.m;return Q.x=M*X[0]+A*X[4]+O*X[8],Q.y=M*X[1]+A*X[5]+O*X[9],Q.z=M*X[2]+A*X[6]+O*X[10],Q.w=S,Q}static FromVector3(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new d(M._x,M._y,M._z,A)}static Dot(M,A){return M.x*A.x+M.y*A.y+M.z*A.z+M.w*A.w}}d._V8PerformanceHack=new d(.5,.5,.5,.5),d._ZeroReadOnly=d.Zero(),Object.defineProperties(d.prototype,{dimension:{value:[4]},rank:{value:1}});class w{get x(){return this._x}set x(M){this._x=M,this._isDirty=!0}get y(){return this._y}set y(M){this._y=M,this._isDirty=!0}get z(){return this._z}set z(M){this._z=M,this._isDirty=!0}get w(){return this._w}set w(M){this._w=M,this._isDirty=!0}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=M,this._y=A,this._z=O,this._w=S}toString(){return"{X: ".concat(this._x," Y: ").concat(this._y," Z: ").concat(this._z," W: ").concat(this._w,"}")}getClassName(){return"Quaternion"}getHashCode(){let M=J(this._x);return M=397*M^J(this._y),M=397*M^J(this._z),M=397*M^J(this._w),M}gc(){return[this._x,this._y,this._z,this._w]}toArray(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[A]=this._x,M[A+1]=this._y,M[A+2]=this._z,M[A+3]=this._w,this}GO(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w.FromArrayToRef(M,A,this)}equals(M){return M&&this._x===M._x&&this._y===M._y&&this._z===M._z&&this._w===M._w}equalsWithEpsilon(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.e;return M&&(0,j.WithinEpsilon)(this._x,M._x,A)&&(0,j.WithinEpsilon)(this._y,M._y,A)&&(0,j.WithinEpsilon)(this._z,M._z,A)&&(0,j.WithinEpsilon)(this._w,M._w,A)}isApprox(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.e;return M&&((0,j.WithinEpsilon)(this._x,M._x,A)&&(0,j.WithinEpsilon)(this._y,M._y,A)&&(0,j.WithinEpsilon)(this._z,M._z,A)&&(0,j.WithinEpsilon)(this._w,M._w,A)||(0,j.WithinEpsilon)(this._x,-M._x,A)&&(0,j.WithinEpsilon)(this._y,-M._y,A)&&(0,j.WithinEpsilon)(this._z,-M._z,A)&&(0,j.WithinEpsilon)(this._w,-M._w,A))}clone(){return new w(this._x,this._y,this._z,this._w)}S(M){return this._x=M._x,this._y=M._y,this._z=M._z,this._w=M._w,this._isDirty=!0,this}Yc(M,A,O,S){return this._x=M,this._y=A,this._z=O,this._w=S,this._isDirty=!0,this}set(M,A,O,S){return this.Yc(M,A,O,S)}Hc(M){return this.Yc(M,M,M,M)}add(M){return new w(this._x+M._x,this._y+M._y,this._z+M._z,this._w+M._w)}addInPlace(M){return this._x+=M._x,this._y+=M._y,this._z+=M._z,this._w+=M._w,this._isDirty=!0,this}addToRef(M,A){return A._x=this._x+M._x,A._y=this._y+M._y,A._z=this._z+M._z,A._w=this._w+M._w,A._isDirty=!0,A}addInPlaceFromFloats(M,A,O,S){return this._x+=M,this._y+=A,this._z+=O,this._w+=S,this._isDirty=!0,this}subtractToRef(M,A){return A._x=this._x-M._x,A._y=this._y-M._y,A._z=this._z-M._z,A._w=this._w-M._w,A._isDirty=!0,A}subtractFromFloats(M,A,O,S){return this.subtractFromFloatsToRef(M,A,O,S,new w)}subtractFromFloatsToRef(M,A,O,S,z){return z._x=this._x-M,z._y=this._y-A,z._z=this._z-O,z._w=this._w-S,z._isDirty=!0,z}dA(M){return new w(this._x-M._x,this._y-M._y,this._z-M._z,this._w-M._w)}KT(M){return this._x-=M._x,this._y-=M._y,this._z-=M._z,this._w-=M._w,this._isDirty=!0,this}scale(M){return new w(this._x*M,this._y*M,this._z*M,this._w*M)}scaleToRef(M,A){return A._x=this._x*M,A._y=this._y*M,A._z=this._z*M,A._w=this._w*M,A._isDirty=!0,A}scaleInPlace(M){return this._x*=M,this._y*=M,this._z*=M,this._w*=M,this._isDirty=!0,this}scaleAndAddToRef(M,A){return A._x+=this._x*M,A._y+=this._y*M,A._z+=this._z*M,A._w+=this._w*M,A._isDirty=!0,A}multiply(M){const A=new w(0,0,0,1);return this.multiplyToRef(M,A),A}multiplyToRef(M,A){const O=this._x*M._w+this._y*M._z-this._z*M._y+this._w*M._x,S=-this._x*M._z+this._y*M._w+this._z*M._x+this._w*M._y,z=this._x*M._y-this._y*M._x+this._z*M._w+this._w*M._z,Q=-this._x*M._x-this._y*M._y-this._z*M._z+this._w*M._w;return A.Yc(O,S,z,Q),A}multiplyInPlace(M){return this.multiplyToRef(M,this)}multiplyByFloats(M,A,O,S){return this._x*=M,this._y*=A,this._z*=O,this._w*=S,this._isDirty=!0,this}divide(M){throw new ReferenceError("Can not divide a quaternion")}divideToRef(M,A){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(M){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new w)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(M){return M._x=-this._x,M._y=-this._y,M._z=-this._z,M._w=-this._w,M._isDirty=!0,M}equalsToFloats(M,A,O,S){return this._x===M&&this._y===A&&this._z===O&&this._w===S}floorToRef(M){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(M){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(M){return M.Yc(-this._x,-this._y,-this._z,this._w),M}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new w(-this._x,-this._y,-this._z,this._w)}invert(){const M=this.conjugate(),A=this.lengthSquared();return 0==A||1==A||M.scaleInPlace(1/A),M}invertInPlace(){this.conjugateInPlace();const M=this.lengthSquared();return 0==M||1==M||this.scaleInPlace(1/M),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){const M=new w(0,0,0,1);return this.normalizeToRef(M),M}normalizeToRef(M){const A=this.length();return 0===A||1===A?M.Yc(this._x,this._y,this._z,this._w):this.scaleToRef(1/A,M)}toEulerAngles(){const M=G.Zero();return this.toEulerAnglesToRef(M),M}toEulerAnglesToRef(M){const A=this._z,O=this._x,S=this._y,z=this._w,Q=S*A-O*z,X=.4999999;if(Q<-X)M._y=2*Math.atan2(S,z),M._x=Math.PI/2,M._z=0,M._isDirty=!0;else if(Q>X)M._y=2*Math.atan2(S,z),M._x=-Math.PI/2,M._z=0,M._isDirty=!0;else{const X=z*z,c=A*A,j=O*O,B=S*S;M._z=Math.atan2(2*(O*S+A*z),-c-j+B+X),M._x=Math.asin(-2*Q),M._y=Math.atan2(2*(A*O+S*z),c-j-B+X),M._isDirty=!0}return M}toAlphaBetaGammaToRef(M){const A=this._z,O=this._x,S=this._y,z=this._w,Q=Math.sqrt(O*O+S*S),X=Math.sqrt(A*A+z*z),c=2*Math.atan2(Q,X),j=2*Math.atan2(A,z),B=2*Math.atan2(S,O),g=(j+B)/2,e=(j-B)/2;return M.set(e,c,g),M}toRotationMatrix(M){return I.FromQuaternionToRef(this,M),M}fromRotationMatrix(M){return w.FromRotationMatrixToRef(M,this),this}dot(M){return this._x*M._x+this._y*M._y+this._z*M._z+this._w*M._w}toAxisAngle(){const M=G.Zero();return{axis:M,angle:this.toAxisAngleToRef(M)}}toAxisAngleToRef(M){let A=0;const O=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),S=this._w;return O>0?(A=2*Math.atan2(O,S),M.set(this._x/O,this._y/O,this._z/O)):(A=0,M.set(1,0,0)),A}static FromRotationMatrix(M){const A=new w;return w.FromRotationMatrixToRef(M,A),A}static FromRotationMatrixToRef(M,A){const O=M.m,S=O[0],z=O[4],Q=O[8],X=O[1],c=O[5],j=O[9],B=O[2],g=O[6],e=O[10],T=S+c+e;let J;return T>0?(J=.5/Math.sqrt(T+1),A._w=.25/J,A._x=(g-j)*J,A._y=(Q-B)*J,A._z=(X-z)*J,A._isDirty=!0):S>c&&S>e?(J=2*Math.sqrt(1+S-c-e),A._w=(g-j)/J,A._x=.25*J,A._y=(z+X)/J,A._z=(Q+B)/J,A._isDirty=!0):c>e?(J=2*Math.sqrt(1+c-S-e),A._w=(Q-B)/J,A._x=(z+X)/J,A._y=.25*J,A._z=(j+g)/J,A._isDirty=!0):(J=2*Math.sqrt(1+e-S-c),A._w=(X-z)/J,A._x=(Q+B)/J,A._y=(j+g)/J,A._z=.25*J,A._isDirty=!0),A}static Dot(M,A){return M._x*A._x+M._y*A._y+M._z*A._z+M._w*A._w}static AreClose(M,A){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const S=w.Dot(M,A);return 1-S*S<=O}static SmoothToRef(M,A,O,S,z){let Q=0===S?1:O/S;return Q=(0,j.Clamp)(Q,0,1),w.SlerpToRef(M,A,Q,z),z}static Zero(){return new w(0,0,0,0)}static Inverse(M){return new w(-M._x,-M._y,-M._z,M._w)}static InverseToRef(M,A){return A.set(-M._x,-M._y,-M._z,M._w),A}static Identity(){return new w(0,0,0,1)}static IsIdentity(M){return M&&0===M._x&&0===M._y&&0===M._z&&1===M._w}static RotationAxis(M,A){return w.RotationAxisToRef(M,A,new w)}static RotationAxisToRef(M,A,O){O._w=Math.cos(A/2);const S=Math.sin(A/2)/M.length();return O._x=M._x*S,O._y=M._y*S,O._z=M._z*S,O._isDirty=!0,O}static sA(M,A){return A||(A=0),new w(M[A],M[A+1],M[A+2],M[A+3])}static FromArrayToRef(M,A,O){return O._x=M[A],O._y=M[A+1],O._z=M[A+2],O._w=M[A+3],O._isDirty=!0,O}static FromFloatsToRef(M,A,O,S,z){return z.Yc(M,A,O,S),z}static FromEulerAngles(M,A,O){const S=new w;return w.RotationYawPitchRollToRef(A,M,O,S),S}static FromEulerAnglesToRef(M,A,O,S){return w.RotationYawPitchRollToRef(A,M,O,S),S}static FromEulerVector(M){const A=new w;return w.RotationYawPitchRollToRef(M._y,M._x,M._z,A),A}static FromEulerVectorToRef(M,A){return w.RotationYawPitchRollToRef(M._y,M._x,M._z,A),A}static FromUnitVectorsToRef(M,A,O){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:S.e;const Q=G.Dot(M,A)+1;return Q<z?Math.abs(M.x)>Math.abs(M.z)?O.set(-M.y,M.x,0,0):O.set(0,-M.z,M.y,0):(G.CrossToRef(M,A,s.GA[0]),O.set(s.GA[0].x,s.GA[0].y,s.GA[0].z,Q)),O.normalize()}static RotationYawPitchRoll(M,A,O){const S=new w;return w.RotationYawPitchRollToRef(M,A,O,S),S}static RotationYawPitchRollToRef(M,A,O,S){const z=.5*O,Q=.5*A,X=.5*M,c=Math.sin(z),j=Math.cos(z),B=Math.sin(Q),g=Math.cos(Q),e=Math.sin(X),T=Math.cos(X);return S._x=T*B*j+e*g*c,S._y=e*g*j-T*B*c,S._z=T*g*c-e*B*j,S._w=T*g*j+e*B*c,S._isDirty=!0,S}static RotationAlphaBetaGamma(M,A,O){const S=new w;return w.RotationAlphaBetaGammaToRef(M,A,O,S),S}static RotationAlphaBetaGammaToRef(M,A,O,S){const z=.5*(O+M),Q=.5*(O-M),X=.5*A;return S._x=Math.cos(Q)*Math.sin(X),S._y=Math.sin(Q)*Math.sin(X),S._z=Math.sin(z)*Math.cos(X),S._w=Math.cos(z)*Math.cos(X),S._isDirty=!0,S}static RotationQuaternionFromAxis(M,A,O){const S=new w(0,0,0,0);return w.RotationQuaternionFromAxisToRef(M,A,O,S),S}static RotationQuaternionFromAxisToRef(M,A,O,S){const z=b.Matrix[0];return M=M.normalizeToRef(b.GA[0]),A=A.normalizeToRef(b.GA[1]),O=O.normalizeToRef(b.GA[2]),I.FromXYZAxesToRef(M,A,O,z),w.FromRotationMatrixToRef(z,S),S}static FromLookDirectionLH(M,A){const O=new w;return w.FromLookDirectionLHToRef(M,A,O),O}static FromLookDirectionLHToRef(M,A,O){const S=b.Matrix[0];return I.LookDirectionLHToRef(M,A,S),w.FromRotationMatrixToRef(S,O),O}static FromLookDirectionRH(M,A){const O=new w;return w.FromLookDirectionRHToRef(M,A,O),O}static FromLookDirectionRHToRef(M,A,O){const S=b.Matrix[0];return I.LookDirectionRHToRef(M,A,S),w.FromRotationMatrixToRef(S,O)}static Slerp(M,A,O){const S=w.Identity();return w.SlerpToRef(M,A,O,S),S}static SlerpToRef(M,A,O,S){let z,Q,X=M._x*A._x+M._y*A._y+M._z*A._z+M._w*A._w,c=!1;if(X<0&&(c=!0,X=-X),X>.999999)Q=1-O,z=c?-O:O;else{const M=Math.acos(X),A=1/Math.sin(M);Q=Math.sin((1-O)*M)*A,z=c?-Math.sin(O*M)*A:Math.sin(O*M)*A}return S._x=Q*M._x+z*A._x,S._y=Q*M._y+z*A._y,S._z=Q*M._z+z*A._z,S._w=Q*M._w+z*A._w,S._isDirty=!0,S}static Hermite(M,A,O,S,z){const Q=z*z,X=z*Q,c=2*X-3*Q+1,j=-2*X+3*Q,B=X-2*Q+z,g=X-Q,e=M._x*c+O._x*j+A._x*B+S._x*g,T=M._y*c+O._y*j+A._y*B+S._y*g,J=M._z*c+O._z*j+A._z*B+S._z*g,K=M._w*c+O._w*j+A._w*B+S._w*g;return new w(e,T,J,K)}static Hermite1stDerivative(M,A,O,S,z){const Q=new w;return this.Hermite1stDerivativeToRef(M,A,O,S,z,Q),Q}static Hermite1stDerivativeToRef(M,A,O,S,z,Q){const X=z*z;return Q._x=6*(X-z)*M._x+(3*X-4*z+1)*A._x+6*(-X+z)*O._x+(3*X-2*z)*S._x,Q._y=6*(X-z)*M._y+(3*X-4*z+1)*A._y+6*(-X+z)*O._y+(3*X-2*z)*S._y,Q._z=6*(X-z)*M._z+(3*X-4*z+1)*A._z+6*(-X+z)*O._z+(3*X-2*z)*S._z,Q._w=6*(X-z)*M._w+(3*X-4*z+1)*A._w+6*(-X+z)*O._w+(3*X-2*z)*S._w,Q._isDirty=!0,Q}static Normalize(M){const A=w.Zero();return w.NormalizeToRef(M,A),A}static NormalizeToRef(M,A){return M.normalizeToRef(A),A}static Clamp(M,A,O){const S=new w;return w.ClampToRef(M,A,O,S),S}static ClampToRef(M,A,O,S){return S.Yc((0,j.Clamp)(M.x,A.x,O.x),(0,j.Clamp)(M.y,A.y,O.y),(0,j.Clamp)(M.z,A.z,O.z),(0,j.Clamp)(M.w,A.w,O.w))}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new w((0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Yc((0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A),(0,j.RandomRange)(M,A))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(M,A){return Math.sqrt(w.DistanceSquared(M,A))}static DistanceSquared(M,A){const O=M.x-A.x,S=M.y-A.y,z=M.z-A.z,Q=M.w-A.w;return O*O+S*S+z*z+Q*Q}static Center(M,A){return w.CenterToRef(M,A,w.Zero())}static CenterToRef(M,A,O){return O.Yc((M.x+A.x)/2,(M.y+A.y)/2,(M.z+A.z)/2,(M.w+A.w)/2)}}w._V8PerformanceHack=new w(.5,.5,.5,.5),Object.defineProperties(w.prototype,{dimension:{value:[4]},rank:{value:1}});class I{static get Use64Bits(){return X.c.MatrixUse64Bits}get m(){return this.zc}markAsUpdated(){this.updateFlag=B._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(M){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1],O=arguments.length>2&&void 0!==arguments[2]&&arguments[2],S=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=M,this._isIdentity3x2=M||O,this._isIdentityDirty=!this._isIdentity&&A,this._isIdentity3x2Dirty=!this._isIdentity3x2&&S}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,X.c.MatrixTrackPrecisionChange&&X.c.MatrixTrackedMatrices.push(this),this.zc=new X.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const M=this.zc;this._isIdentity=1===M[0]&&0===M[1]&&0===M[2]&&0===M[3]&&0===M[4]&&1===M[5]&&0===M[6]&&0===M[7]&&0===M[8]&&0===M[9]&&1===M[10]&&0===M[11]&&0===M[12]&&0===M[13]&&0===M[14]&&1===M[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.zc[0]||1!==this.zc[5]||1!==this.zc[15]||0!==this.zc[1]||0!==this.zc[2]||0!==this.zc[3]||0!==this.zc[4]||0!==this.zc[6]||0!==this.zc[7]||0!==this.zc[8]||0!==this.zc[9]||0!==this.zc[10]||0!==this.zc[11]||0!==this.zc[12]||0!==this.zc[13]||0!==this.zc[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const M=this.zc,A=M[0],O=M[1],S=M[2],z=M[3],Q=M[4],X=M[5],c=M[6],j=M[7],B=M[8],g=M[9],e=M[10],T=M[11],J=M[12],K=M[13],G=M[14],d=M[15],w=e*d-G*T,I=g*d-K*T,b=g*G-K*e,s=B*d-J*T,Y=B*G-e*J,E=B*K-J*g;return A*+(X*w-c*I+j*b)+O*-(Q*w-c*s+j*Y)+S*+(Q*I-X*s+j*E)+z*-(Q*b-X*Y+c*E)}toString(){return"{".concat(this.m[0],", ").concat(this.m[1],", ").concat(this.m[2],", ").concat(this.m[3],"\n").concat(this.m[4],", ").concat(this.m[5],", ").concat(this.m[6],", ").concat(this.m[7],"\n").concat(this.m[8],", ").concat(this.m[9],", ").concat(this.m[10],", ").concat(this.m[11],"\n").concat(this.m[12],", ").concat(this.m[13],", ").concat(this.m[14],", ").concat(this.m[15],"}")}toArray(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!M)return this.zc;const O=this.zc;for(let S=0;S<16;S++)M[A+S]=O[S];return this}gc(){return this.zc}GO(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I.FromArrayToRef(M,A,this)}Yc(){for(var M=arguments.length,A=new Array(M),O=0;O<M;O++)A[O]=arguments[O];return I.FromArrayToRef(A,0,this)}set(){const M=this.zc;for(let A=0;A<16;A++)M[A]=A<0||arguments.length<=A?void 0:arguments[A];return this.markAsUpdated(),this}Hc(M){const A=this.zc;for(let O=0;O<16;O++)A[O]=M;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return I.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(M){const A=new I;return this.addToRef(M,A),A}addToRef(M,A){const O=this.zc,S=A.zc,z=M.m;for(let Q=0;Q<16;Q++)S[Q]=O[Q]+z[Q];return A.markAsUpdated(),A}addToSelf(M){const A=this.zc,O=M.m;return A[0]+=O[0],A[1]+=O[1],A[2]+=O[2],A[3]+=O[3],A[4]+=O[4],A[5]+=O[5],A[6]+=O[6],A[7]+=O[7],A[8]+=O[8],A[9]+=O[9],A[10]+=O[10],A[11]+=O[11],A[12]+=O[12],A[13]+=O[13],A[14]+=O[14],A[15]+=O[15],this.markAsUpdated(),this}addInPlace(M){const A=this.zc,O=M.m;for(let S=0;S<16;S++)A[S]+=O[S];return this.markAsUpdated(),this}addInPlaceFromFloats(){const M=this.zc;for(let A=0;A<16;A++)M[A]+=A<0||arguments.length<=A?void 0:arguments[A];return this.markAsUpdated(),this}dA(M){const A=this.zc,O=M.m;for(let S=0;S<16;S++)A[S]-=O[S];return this.markAsUpdated(),this}subtractToRef(M,A){const O=this.zc,S=M.m,z=A.zc;for(let Q=0;Q<16;Q++)z[Q]=O[Q]-S[Q];return A.markAsUpdated(),A}KT(M){const A=this.zc,O=M.m;for(let S=0;S<16;S++)A[S]-=O[S];return this.markAsUpdated(),this}subtractFromFloats(){for(var M=arguments.length,A=new Array(M),O=0;O<M;O++)A[O]=arguments[O];return this.subtractFromFloatsToRef(...A,new I)}subtractFromFloatsToRef(){for(var M=arguments.length,A=new Array(M),O=0;O<M;O++)A[O]=arguments[O];const S=A.pop(),z=this.zc,Q=S.zc,X=A;for(let c=0;c<16;c++)Q[c]=z[c]-X[c];return S.markAsUpdated(),S}invertToRef(M){return!0===this._isIdentity?(I.IdentityToRef(M),M):(T(this,M.gc())?M.markAsUpdated():M.S(this),M)}addAtIndex(M,A){return this.zc[M]+=A,this.markAsUpdated(),this}multiplyAtIndex(M,A){return this.zc[M]*=A,this.markAsUpdated(),this}setTranslationFromFloats(M,A,O){return this.zc[12]=M,this.zc[13]=A,this.zc[14]=O,this.markAsUpdated(),this}addTranslationFromFloats(M,A,O){return this.zc[12]+=M,this.zc[13]+=A,this.zc[14]+=O,this.markAsUpdated(),this}setTranslation(M){return this.setTranslationFromFloats(M._x,M._y,M._z)}getTranslation(){return new G(this.zc[12],this.zc[13],this.zc[14])}getTranslationToRef(M){return M.x=this.zc[12],M.y=this.zc[13],M.z=this.zc[14],M}removeRotationAndScaling(){const M=this.m;return I.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,M[12],M[13],M[14],M[15],this),this._updateIdentityStatus(0===M[12]&&0===M[13]&&0===M[14]&&1===M[15]),this}S(M){M.copyToArray(this.zc);const A=M;return this.updateFlag=A.updateFlag,this._updateIdentityStatus(A._isIdentity,A._isIdentityDirty,A._isIdentity3x2,A._isIdentity3x2Dirty),this}copyToArray(M){return e(this,M,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(M){const A=new I;return this.multiplyToRef(M,A),A}multiplyInPlace(M){const A=this.zc,O=M.m;for(let S=0;S<16;S++)A[S]*=O[S];return this.markAsUpdated(),this}multiplyByFloats(){const M=this.zc;for(let A=0;A<16;A++)M[A]*=A<0||arguments.length<=A?void 0:arguments[A];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var M=arguments.length,A=new Array(M),O=0;O<M;O++)A[O]=arguments[O];const S=A.pop(),z=this.zc,Q=S.zc,X=A;for(let c=0;c<16;c++)Q[c]=z[c]*X[c];return S.markAsUpdated(),S}multiplyToRef(M,A){return this._isIdentity?(A.S(M),A):M._isIdentity?(A.S(this),A):(this.multiplyToArray(M,A.zc,0),A.markAsUpdated(),A)}multiplyToArray(M,A,O){return g(this,M,A,O),this}divide(M){return this.divideToRef(M,new I)}divideToRef(M,A){const O=this.zc,S=M.m,z=A.zc;for(let Q=0;Q<16;Q++)z[Q]=O[Q]/S[Q];return A.markAsUpdated(),A}divideInPlace(M){const A=this.zc,O=M.m;for(let S=0;S<16;S++)A[S]/=O[S];return this.markAsUpdated(),this}minimizeInPlace(M){const A=this.zc,O=M.m;for(let S=0;S<16;S++)A[S]=Math.min(A[S],O[S]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const M=this.zc;for(let A=0;A<16;A++)M[A]=Math.min(M[A],A<0||arguments.length<=A?void 0:arguments[A]);return this.markAsUpdated(),this}maximizeInPlace(M){const A=this.zc,O=M.m;for(let S=0;S<16;S++)A[S]=Math.min(A[S],O[S]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const M=this.zc;for(let A=0;A<16;A++)M[A]=Math.min(M[A],A<0||arguments.length<=A?void 0:arguments[A]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new I)}negateInPlace(){const M=this.zc;for(let A=0;A<16;A++)M[A]=-M[A];return this.markAsUpdated(),this}negateToRef(M){const A=this.zc,O=M.zc;for(let S=0;S<16;S++)O[S]=-A[S];return M.markAsUpdated(),M}equals(M){const A=M;if(!A)return!1;if((this._isIdentity||A._isIdentity)&&!this._isIdentityDirty&&!A._isIdentityDirty)return this._isIdentity&&A._isIdentity;const O=this.m,S=A.m;return O[0]===S[0]&&O[1]===S[1]&&O[2]===S[2]&&O[3]===S[3]&&O[4]===S[4]&&O[5]===S[5]&&O[6]===S[6]&&O[7]===S[7]&&O[8]===S[8]&&O[9]===S[9]&&O[10]===S[10]&&O[11]===S[11]&&O[12]===S[12]&&O[13]===S[13]&&O[14]===S[14]&&O[15]===S[15]}equalsWithEpsilon(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const O=this.zc,S=M.m;for(let z=0;z<16;z++)if(!(0,j.WithinEpsilon)(O[z],S[z],A))return!1;return!0}equalsToFloats(){const M=this.zc;for(let A=0;A<16;A++)if(M[A]!=(A<0||arguments.length<=A?void 0:arguments[A]))return!1;return!0}floor(){return this.floorToRef(new I)}floorToRef(M){const A=this.zc,O=M.zc;for(let S=0;S<16;S++)O[S]=Math.floor(A[S]);return M.markAsUpdated(),M}fract(){return this.fractToRef(new I)}fractToRef(M){const A=this.zc,O=M.zc;for(let S=0;S<16;S++)O[S]=A[S]-Math.floor(A[S]);return M.markAsUpdated(),M}clone(){const M=new I;return M.S(this),M}getClassName(){return"Matrix"}getHashCode(){let M=J(this.zc[0]);for(let A=1;A<16;A++)M=397*M^J(this.zc[A]);return M}decomposeToTransformNode(M){return M.rotationQuaternion=M.rotationQuaternion||new w,this.decompose(M.Ec,M.rotationQuaternion,M.position)}decompose(M,A,O,S){let z=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return O&&O.Hc(0),M&&M.Hc(1),A&&A.Yc(0,0,0,1),!0;const Q=this.zc;if(O&&O.Yc(Q[12],Q[13],Q[14]),(M=M||b.GA[0]).x=Math.sqrt(Q[0]*Q[0]+Q[1]*Q[1]+Q[2]*Q[2]),M.y=Math.sqrt(Q[4]*Q[4]+Q[5]*Q[5]+Q[6]*Q[6]),M.z=Math.sqrt(Q[8]*Q[8]+Q[9]*Q[9]+Q[10]*Q[10]),S){const A=(z?S.absoluteScaling.x:S.Ec.x)<0?-1:1,O=(z?S.absoluteScaling.y:S.Ec.y)<0?-1:1,Q=(z?S.absoluteScaling.z:S.Ec.z)<0?-1:1;M.x*=A,M.y*=O,M.z*=Q}else this.determinant()<=0&&(M.y*=-1);if(0===M._x||0===M._y||0===M._z)return A&&A.Yc(0,0,0,1),!1;if(A){const O=1/M._x,S=1/M._y,z=1/M._z;I.FromValuesToRef(Q[0]*O,Q[1]*O,Q[2]*O,0,Q[4]*S,Q[5]*S,Q[6]*S,0,Q[8]*z,Q[9]*z,Q[10]*z,0,0,0,0,1,b.Matrix[0]),w.FromRotationMatrixToRef(b.Matrix[0],A)}return!0}getRow(M){if(M<0||M>3)return null;const A=4*M;return new d(this.zc[A+0],this.zc[A+1],this.zc[A+2],this.zc[A+3])}getRowToRef(M,A){if(M>=0&&M<=3){const O=4*M;A.x=this.zc[O+0],A.y=this.zc[O+1],A.z=this.zc[O+2],A.w=this.zc[O+3]}return A}setRow(M,A){return this.setRowFromFloats(M,A.x,A.y,A.z,A.w)}transpose(){const M=new I;return I.TransposeToRef(this,M),M}transposeToRef(M){return I.TransposeToRef(this,M),M}setRowFromFloats(M,A,O,S,z){if(M<0||M>3)return this;const Q=4*M;return this.zc[Q+0]=A,this.zc[Q+1]=O,this.zc[Q+2]=S,this.zc[Q+3]=z,this.markAsUpdated(),this}scale(M){const A=new I;return this.scaleToRef(M,A),A}scaleToRef(M,A){for(let O=0;O<16;O++)A.zc[O]=this.zc[O]*M;return A.markAsUpdated(),A}scaleAndAddToRef(M,A){for(let O=0;O<16;O++)A.zc[O]+=this.zc[O]*M;return A.markAsUpdated(),A}scaleInPlace(M){const A=this.zc;for(let O=0;O<16;O++)A[O]*=M;return this.markAsUpdated(),this}toNormalMatrix(M){const A=b.Matrix[0];this.invertToRef(A),A.transposeToRef(M);const O=M.zc;return I.FromValuesToRef(O[0],O[1],O[2],0,O[4],O[5],O[6],0,O[8],O[9],O[10],0,0,0,0,1,M),M}getRotationMatrix(){const M=new I;return this.getRotationMatrixToRef(M),M}getRotationMatrixToRef(M){const A=b.GA[0];if(!this.decompose(A))return I.IdentityToRef(M),M;const O=this.zc,S=1/A._x,z=1/A._y,Q=1/A._z;return I.FromValuesToRef(O[0]*S,O[1]*S,O[2]*S,0,O[4]*z,O[5]*z,O[6]*z,0,O[8]*Q,O[9]*Q,O[10]*Q,0,0,0,0,1,M),M}toggleModelMatrixHandInPlace(){const M=this.zc;return M[2]*=-1,M[6]*=-1,M[8]*=-1,M[9]*=-1,M[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const M=this.zc;return M[8]*=-1,M[9]*=-1,M[10]*=-1,M[11]*=-1,this.markAsUpdated(),this}static sA(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const O=new I;return I.FromArrayToRef(M,A,O),O}static FromArrayToRef(M,A,O){for(let S=0;S<16;S++)O.zc[S]=M[S+A];return O.markAsUpdated(),O}static FromFloat32ArrayToRefScaled(M,A,O,S){return S.zc[0]=M[0+A]*O,S.zc[1]=M[1+A]*O,S.zc[2]=M[2+A]*O,S.zc[3]=M[3+A]*O,S.zc[4]=M[4+A]*O,S.zc[5]=M[5+A]*O,S.zc[6]=M[6+A]*O,S.zc[7]=M[7+A]*O,S.zc[8]=M[8+A]*O,S.zc[9]=M[9+A]*O,S.zc[10]=M[10+A]*O,S.zc[11]=M[11+A]*O,S.zc[12]=M[12+A]*O,S.zc[13]=M[13+A]*O,S.zc[14]=M[14+A]*O,S.zc[15]=M[15+A]*O,S.markAsUpdated(),S}static get IdentityReadOnly(){return I._IdentityReadOnly}static FromValuesToRef(M,A,O,S,z,Q,X,c,j,B,g,e,T,J,K,G,d){const w=d.zc;w[0]=M,w[1]=A,w[2]=O,w[3]=S,w[4]=z,w[5]=Q,w[6]=X,w[7]=c,w[8]=j,w[9]=B,w[10]=g,w[11]=e,w[12]=T,w[13]=J,w[14]=K,w[15]=G,d.markAsUpdated()}static FromValues(M,A,O,S,z,Q,X,c,j,B,g,e,T,J,K,G){const d=new I,w=d.zc;return w[0]=M,w[1]=A,w[2]=O,w[3]=S,w[4]=z,w[5]=Q,w[6]=X,w[7]=c,w[8]=j,w[9]=B,w[10]=g,w[11]=e,w[12]=T,w[13]=J,w[14]=K,w[15]=G,d.markAsUpdated(),d}static Compose(M,A,O){const S=new I;return I.ComposeToRef(M,A,O,S),S}static ComposeToRef(M,A,O,S){const z=S.zc,Q=A._x,X=A._y,c=A._z,j=A._w,B=Q+Q,g=X+X,e=c+c,T=Q*B,J=Q*g,K=Q*e,G=X*g,d=X*e,w=c*e,I=j*B,b=j*g,s=j*e,Y=M._x,E=M._y,H=M._z;return z[0]=(1-(G+w))*Y,z[1]=(J+s)*Y,z[2]=(K-b)*Y,z[3]=0,z[4]=(J-s)*E,z[5]=(1-(T+w))*E,z[6]=(d+I)*E,z[7]=0,z[8]=(K+b)*H,z[9]=(d-I)*H,z[10]=(1-(T+G))*H,z[11]=0,z[12]=O._x,z[13]=O._y,z[14]=O._z,z[15]=1,S.markAsUpdated(),S}static Identity(){const M=I.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return M._updateIdentityStatus(!0),M}static IdentityToRef(M){return I.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,M),M._updateIdentityStatus(!0),M}static Zero(){const M=I.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return M._updateIdentityStatus(!1),M}static RotationX(M){const A=new I;return I.RotationXToRef(M,A),A}static Invert(M){const A=new I;return M.invertToRef(A),A}static RotationXToRef(M,A){const O=Math.sin(M),S=Math.cos(M);return I.FromValuesToRef(1,0,0,0,0,S,O,0,0,-O,S,0,0,0,0,1,A),A._updateIdentityStatus(1===S&&0===O),A}static RotationY(M){const A=new I;return I.RotationYToRef(M,A),A}static RotationYToRef(M,A){const O=Math.sin(M),S=Math.cos(M);return I.FromValuesToRef(S,0,-O,0,0,1,0,0,O,0,S,0,0,0,0,1,A),A._updateIdentityStatus(1===S&&0===O),A}static RotationZ(M){const A=new I;return I.RotationZToRef(M,A),A}static RotationZToRef(M,A){const O=Math.sin(M),S=Math.cos(M);return I.FromValuesToRef(S,O,0,0,-O,S,0,0,0,0,1,0,0,0,0,1,A),A._updateIdentityStatus(1===S&&0===O),A}static RotationAxis(M,A){const O=new I;return I.RotationAxisToRef(M,A,O),O}static RotationAxisToRef(M,A,O){const S=Math.sin(-A),z=Math.cos(-A),Q=1-z;M=M.normalizeToRef(b.GA[0]);const X=O.zc;return X[0]=M._x*M._x*Q+z,X[1]=M._x*M._y*Q-M._z*S,X[2]=M._x*M._z*Q+M._y*S,X[3]=0,X[4]=M._y*M._x*Q+M._z*S,X[5]=M._y*M._y*Q+z,X[6]=M._y*M._z*Q-M._x*S,X[7]=0,X[8]=M._z*M._x*Q-M._y*S,X[9]=M._z*M._y*Q+M._x*S,X[10]=M._z*M._z*Q+z,X[11]=0,X[12]=0,X[13]=0,X[14]=0,X[15]=1,O.markAsUpdated(),O}static RotationAlignToRef(M,A,O){let z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const Q=G.Dot(A,M),X=O.zc;if(Q<-1+S.e)X[0]=-1,X[1]=0,X[2]=0,X[3]=0,X[4]=0,X[5]=z?1:-1,X[6]=0,X[7]=0,X[8]=0,X[9]=0,X[10]=z?-1:1,X[11]=0;else{const O=G.Cross(A,M),S=1/(1+Q);X[0]=O._x*O._x*S+Q,X[1]=O._y*O._x*S-O._z,X[2]=O._z*O._x*S+O._y,X[3]=0,X[4]=O._x*O._y*S+O._z,X[5]=O._y*O._y*S+Q,X[6]=O._z*O._y*S-O._x,X[7]=0,X[8]=O._x*O._z*S-O._y,X[9]=O._y*O._z*S+O._x,X[10]=O._z*O._z*S+Q,X[11]=0}return X[12]=0,X[13]=0,X[14]=0,X[15]=1,O.markAsUpdated(),O}static RotationYawPitchRoll(M,A,O){const S=new I;return I.RotationYawPitchRollToRef(M,A,O,S),S}static RotationYawPitchRollToRef(M,A,O,S){return w.RotationYawPitchRollToRef(M,A,O,b.Quaternion[0]),b.Quaternion[0].toRotationMatrix(S),S}static Scaling(M,A,O){const S=new I;return I.ScalingToRef(M,A,O,S),S}static ScalingToRef(M,A,O,S){return I.FromValuesToRef(M,0,0,0,0,A,0,0,0,0,O,0,0,0,0,1,S),S._updateIdentityStatus(1===M&&1===A&&1===O),S}static Translation(M,A,O){const S=new I;return I.TranslationToRef(M,A,O,S),S}static TranslationToRef(M,A,O,S){return I.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,M,A,O,1,S),S._updateIdentityStatus(0===M&&0===A&&0===O),S}static Lerp(M,A,O){const S=new I;return I.LerpToRef(M,A,O,S),S}static LerpToRef(M,A,O,S){const z=S.zc,Q=M.m,X=A.m;for(let c=0;c<16;c++)z[c]=Q[c]*(1-O)+X[c]*O;return S.markAsUpdated(),S}static DecomposeLerp(M,A,O){const S=new I;return I.DecomposeLerpToRef(M,A,O,S),S}static DecomposeLerpToRef(M,A,O,S){const z=b.GA[0],Q=b.Quaternion[0],X=b.GA[1];M.decompose(z,Q,X);const c=b.GA[2],j=b.Quaternion[1],B=b.GA[3];A.decompose(c,j,B);const g=b.GA[4];G.LerpToRef(z,c,O,g);const e=b.Quaternion[2];w.SlerpToRef(Q,j,O,e);const T=b.GA[5];return G.LerpToRef(X,B,O,T),I.ComposeToRef(g,e,T,S),S}static LookAtLH(M,A,O){const S=new I;return I.LookAtLHToRef(M,A,O,S),S}static LookAtLHToRef(M,A,O,S){const z=b.GA[0],Q=b.GA[1],X=b.GA[2];A.subtractToRef(M,X),X.normalize(),G.CrossToRef(O,X,z);const c=z.lengthSquared();0===c?z.x=1:z.normalizeFromLength(Math.sqrt(c)),G.CrossToRef(X,z,Q),Q.normalize();const j=-G.Dot(z,M),B=-G.Dot(Q,M),g=-G.Dot(X,M);return I.FromValuesToRef(z._x,Q._x,X._x,0,z._y,Q._y,X._y,0,z._z,Q._z,X._z,0,j,B,g,1,S),S}static LookAtRH(M,A,O){const S=new I;return I.LookAtRHToRef(M,A,O,S),S}static LookAtRHToRef(M,A,O,S){const z=b.GA[0],Q=b.GA[1],X=b.GA[2];M.subtractToRef(A,X),X.normalize(),G.CrossToRef(O,X,z);const c=z.lengthSquared();0===c?z.x=1:z.normalizeFromLength(Math.sqrt(c)),G.CrossToRef(X,z,Q),Q.normalize();const j=-G.Dot(z,M),B=-G.Dot(Q,M),g=-G.Dot(X,M);return I.FromValuesToRef(z._x,Q._x,X._x,0,z._y,Q._y,X._y,0,z._z,Q._z,X._z,0,j,B,g,1,S),S}static LookDirectionLH(M,A){const O=new I;return I.LookDirectionLHToRef(M,A,O),O}static LookDirectionLHToRef(M,A,O){const S=b.GA[0];S.S(M),S.scaleInPlace(-1);const z=b.GA[1];return G.CrossToRef(A,S,z),I.FromValuesToRef(z._x,z._y,z._z,0,A._x,A._y,A._z,0,S._x,S._y,S._z,0,0,0,0,1,O),O}static LookDirectionRH(M,A){const O=new I;return I.LookDirectionRHToRef(M,A,O),O}static LookDirectionRHToRef(M,A,O){const S=b.GA[2];return G.CrossToRef(A,M,S),I.FromValuesToRef(S._x,S._y,S._z,0,A._x,A._y,A._z,0,M._x,M._y,M._z,0,0,0,0,1,O),O}static OrthoLH(M,A,O,S,z){const Q=new I;return I.OrthoLHToRef(M,A,O,S,Q,z),Q}static OrthoLHToRef(M,A,O,S,z,Q){const X=2/M,c=2/A,j=2/(S-O),B=-(S+O)/(S-O);return I.FromValuesToRef(X,0,0,0,0,c,0,0,0,0,j,0,0,0,B,1,z),Q&&z.multiplyToRef(Y,z),z._updateIdentityStatus(1===X&&1===c&&1===j&&0===B),z}static OrthoOffCenterLH(M,A,O,S,z,Q,X){const c=new I;return I.OrthoOffCenterLHToRef(M,A,O,S,z,Q,c,X),c}static OrthoOffCenterLHToRef(M,A,O,S,z,Q,X,c){const j=2/(A-M),B=2/(S-O),g=2/(Q-z),e=-(Q+z)/(Q-z),T=(M+A)/(M-A),J=(S+O)/(O-S);return I.FromValuesToRef(j,0,0,0,0,B,0,0,0,0,g,0,T,J,e,1,X),c&&X.multiplyToRef(Y,X),X.markAsUpdated(),X}static ObliqueOffCenterLHToRef(M,A,O,S,z,Q,X,c,j,B,g){const e=-X*Math.cos(c),T=-X*Math.sin(c);return I.TranslationToRef(0,0,-j,b.Matrix[1]),I.FromValuesToRef(1,0,0,0,0,1,0,0,e,T,1,0,0,0,0,1,b.Matrix[0]),b.Matrix[1].multiplyToRef(b.Matrix[0],b.Matrix[0]),I.TranslationToRef(0,0,j,b.Matrix[1]),b.Matrix[0].multiplyToRef(b.Matrix[1],b.Matrix[0]),I.OrthoOffCenterLHToRef(M,A,O,S,z,Q,B,g),b.Matrix[0].multiplyToRef(B,B),B}static OrthoOffCenterRH(M,A,O,S,z,Q,X){const c=new I;return I.OrthoOffCenterRHToRef(M,A,O,S,z,Q,c,X),c}static OrthoOffCenterRHToRef(M,A,O,S,z,Q,X,c){return I.OrthoOffCenterLHToRef(M,A,O,S,z,Q,X,c),X.zc[10]*=-1,X}static ObliqueOffCenterRHToRef(M,A,O,S,z,Q,X,c,j,B,g){const e=X*Math.cos(c),T=X*Math.sin(c);return I.TranslationToRef(0,0,j,b.Matrix[1]),I.FromValuesToRef(1,0,0,0,0,1,0,0,e,T,1,0,0,0,0,1,b.Matrix[0]),b.Matrix[1].multiplyToRef(b.Matrix[0],b.Matrix[0]),I.TranslationToRef(0,0,-j,b.Matrix[1]),b.Matrix[0].multiplyToRef(b.Matrix[1],b.Matrix[0]),I.OrthoOffCenterRHToRef(M,A,O,S,z,Q,B,g),b.Matrix[0].multiplyToRef(B,B),B}static PerspectiveLH(M,A,O,S,z){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const X=new I,c=2*O/M,j=2*O/A,B=(S+O)/(S-O),g=-2*S*O/(S-O),e=Math.tan(Q);return I.FromValuesToRef(c,0,0,0,0,j,0,e,0,0,B,1,0,0,g,0,X),z&&X.multiplyToRef(Y,X),X._updateIdentityStatus(!1),X}static PerspectiveFovLH(M,A,O,S,z){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,X=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const c=new I;return I.PerspectiveFovLHToRef(M,A,O,S,c,!0,z,Q,X),c}static PerspectiveFovLHToRef(M,A,O,S,z){let Q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],X=arguments.length>6?arguments[6]:void 0,c=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,j=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const B=O,g=S,e=1/Math.tan(.5*M),T=Q?e/A:e,J=Q?e:e*A,K=j&&0===B?-1:0!==g?(g+B)/(g-B):1,G=j&&0===B?2*g:0!==g?-2*g*B/(g-B):-2*B,d=Math.tan(c);return I.FromValuesToRef(T,0,0,0,0,J,0,d,0,0,K,1,0,0,G,0,z),X&&z.multiplyToRef(Y,z),z._updateIdentityStatus(!1),z}static PerspectiveFovReverseLHToRef(M,A,O,S,z){let Q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],X=arguments.length>6?arguments[6]:void 0,c=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const j=1/Math.tan(.5*M),B=Q?j/A:j,g=Q?j:j*A,e=Math.tan(c);return I.FromValuesToRef(B,0,0,0,0,g,0,e,0,0,-O,1,0,0,1,0,z),X&&z.multiplyToRef(Y,z),z._updateIdentityStatus(!1),z}static PerspectiveFovRH(M,A,O,S,z){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,X=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const c=new I;return I.PerspectiveFovRHToRef(M,A,O,S,c,!0,z,Q,X),c}static PerspectiveFovRHToRef(M,A,O,S,z){let Q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],X=arguments.length>6?arguments[6]:void 0,c=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,j=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const B=O,g=S,e=1/Math.tan(.5*M),T=Q?e/A:e,J=Q?e:e*A,K=j&&0===B?1:0!==g?-(g+B)/(g-B):-1,G=j&&0===B?2*g:0!==g?-2*g*B/(g-B):-2*B,d=Math.tan(c);return I.FromValuesToRef(T,0,0,0,0,J,0,d,0,0,K,-1,0,0,G,0,z),X&&z.multiplyToRef(Y,z),z._updateIdentityStatus(!1),z}static PerspectiveFovReverseRHToRef(M,A,O,S,z){let Q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],X=arguments.length>6?arguments[6]:void 0,c=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const j=1/Math.tan(.5*M),B=Q?j/A:j,g=Q?j:j*A,e=Math.tan(c);return I.FromValuesToRef(B,0,0,0,0,g,0,e,0,0,-O,-1,0,0,-1,0,z),X&&z.multiplyToRef(Y,z),z._updateIdentityStatus(!1),z}static GetFinalMatrix(M,A,O,S,z,Q){const X=M.width,c=M.height,j=M.x,B=M.y,g=I.FromValues(X/2,0,0,0,0,-c/2,0,0,0,0,Q-z,0,j+X/2,c/2+B,z,1),e=new I;return A.multiplyToRef(O,e),e.multiplyToRef(S,e),e.multiplyToRef(g,e)}static GetAsMatrix2x2(M){const A=M.m,O=[A[0],A[1],A[4],A[5]];return X.c.MatrixUse64Bits?O:new Float32Array(O)}static GetAsMatrix3x3(M){const A=M.m,O=[A[0],A[1],A[2],A[4],A[5],A[6],A[8],A[9],A[10]];return X.c.MatrixUse64Bits?O:new Float32Array(O)}static Transpose(M){const A=new I;return I.TransposeToRef(M,A),A}static TransposeToRef(M,A){const O=M.m,S=O[0],z=O[4],Q=O[8],X=O[12],c=O[1],j=O[5],B=O[9],g=O[13],e=O[2],T=O[6],J=O[10],K=O[14],G=O[3],d=O[7],w=O[11],I=O[15],b=A.zc;return b[0]=S,b[1]=z,b[2]=Q,b[3]=X,b[4]=c,b[5]=j,b[6]=B,b[7]=g,b[8]=e,b[9]=T,b[10]=J,b[11]=K,b[12]=G,b[13]=d,b[14]=w,b[15]=I,A.markAsUpdated(),A._updateIdentityStatus(M._isIdentity,M._isIdentityDirty),A}static Reflection(M){const A=new I;return I.ReflectionToRef(M,A),A}static ReflectionToRef(M,A){M.normalize();const O=M.normal.x,S=M.normal.y,z=M.normal.z,Q=-2*O,X=-2*S,c=-2*z;return I.FromValuesToRef(Q*O+1,X*O,c*O,0,Q*S,X*S+1,c*S,0,Q*z,X*z,c*z+1,0,Q*M.d,X*M.d,c*M.d,1,A),A}static FromXYZAxesToRef(M,A,O,S){return I.FromValuesToRef(M._x,M._y,M._z,0,A._x,A._y,A._z,0,O._x,O._y,O._z,0,0,0,0,1,S),S}static FromQuaternionToRef(M,A){const O=M._x*M._x,S=M._y*M._y,z=M._z*M._z,Q=M._x*M._y,X=M._z*M._w,c=M._z*M._x,j=M._y*M._w,B=M._y*M._z,g=M._x*M._w;return A.zc[0]=1-2*(S+z),A.zc[1]=2*(Q+X),A.zc[2]=2*(c-j),A.zc[3]=0,A.zc[4]=2*(Q-X),A.zc[5]=1-2*(z+O),A.zc[6]=2*(B+g),A.zc[7]=0,A.zc[8]=2*(c+j),A.zc[9]=2*(B-g),A.zc[10]=1-2*(S+O),A.zc[11]=0,A.zc[12]=0,A.zc[13]=0,A.zc[14]=0,A.zc[15]=1,A.markAsUpdated(),A}}I._IdentityReadOnly=I.Identity(),Object.defineProperties(I.prototype,{dimension:{value:[4,4]},rank:{value:2}});class b{}b.GA=(0,z.c)(11,G.Zero),b.Matrix=(0,z.c)(2,I.Identity),b.Quaternion=(0,z.c)(3,w.Zero);class s{}s.Vector2=(0,z.c)(3,K.Zero),s.GA=(0,z.c)(13,G.Zero),s.Vector4=(0,z.c)(3,d.Zero),s.Quaternion=(0,z.c)(3,w.Zero),s.Matrix=(0,z.c)(8,I.Identity),(0,Q.g)("BABYLON.Vector2",K),(0,Q.g)("BABYLON.Vector3",G),(0,Q.g)("BABYLON.Vector4",d),(0,Q.g)("BABYLON.Matrix",I);const Y=I.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12977:(M,A,O)=>{function S(M,A){const O=[];for(let S=0;S<M;++S)O.push(A());return O}function z(M,A){return S(M,A)}O.d(A,{b:()=>S,c:()=>z,f:()=>X});const Q=["push","splice","pop","shift","unshift"];function X(M,A){const O=Q.map((O=>function(M,A,O){const S=M[A];if("function"!==typeof S)return null;const z=function(){const S=M.length,Q=z.previous.apply(M,arguments);return O(A,S),Q};return S.next=z,z.previous=S,M[A]=z,()=>{const O=z.previous;if(!O)return;const S=z.next;S?(O.next=S,S.previous=O):(O.next=void 0,M[A]=O),z.next=void 0,z.previous=void 0}}(M,O,A)));return()=>{for(const M of O)null===M||void 0===M||M()}}}}]);