"use strict";(self["9jl1vn4ei5r"]=self["9jl1vn4ei5r"]||[]).push([[14],{11798:(M,p,b)=>{b.d(p,{d:()=>k,f:()=>B,i:()=>Q,l:()=>q});const Q=1/2.2,q=2.2,B=(1+Math.sqrt(5))/2,k=.001},11806:(M,p,b)=>{function Q(M){return parseInt(M.toString().replace(/\W/g,""))}function q(M,p){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(M-p)<=b}function B(M,p,b){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return M<p-Q||M>b+Q}function k(M,p){return M===p?M:Math.random()*(p-M)+M}function u(M,p,b){return M+(p-M)*b}function T(M,p,b){let Q=j(p-M,360);return Q>180&&(Q-=360),M+Q*o(b)}function O(M,p,b){let Q=0;return Q=M!=p?o((b-M)/(p-M)):0,Q}function H(M,p,b,Q,q){const B=q*q,k=q*B;return M*(2*k-3*B+1)+b*(-2*k+3*B)+p*(k-2*B+q)+Q*(k-B)}function F(M,p,b,Q,q){const B=q*q;return 6*(B-q)*M+(3*B-4*q+1)*p+6*(-B+q)*b+(3*B-2*q)*Q}function o(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(b,Math.max(p,M))}function W(M){return M-=2*Math.PI*Math.floor((M+Math.PI)/(2*Math.PI))}function i(M){const p=M.toString(16);return M<=15?("0"+p).toUpperCase():p.toUpperCase()}function A(M){if(Math.log2)return Math.floor(Math.log2(M));if(M<0)return NaN;if(0===M)return-1/0;let p=0;if(M<1){for(;M<1;)p++,M*=2;p=-p}else if(M>1)for(;M>1;)p++,M=Math.floor(M/2);return p}function j(M,p){return M-Math.floor(M/p)*p}function K(M,p,b){return(M-p)/(b-p)}function D(M,p,b){return M*(b-p)+p}function a(M,p){let b=j(p-M,360);return b>180&&(b-=360),b}function s(M,p){const b=j(M,2*p);return p-Math.abs(b-p)}function S(M,p,b){let Q=o(b);return Q=-2*Q*Q*Q+3*Q*Q,p*Q+M*(1-Q)}function f(M,p,b){let Q=0;return Q=Math.abs(p-M)<=b?p:M+Math.sign(p-M)*b,Q}function R(M,p,b){const Q=a(M,p);let q=0;return q=-b<Q&&Q<b?p:f(M,p=M+Q,b),q}function y(M,p,b){return(M-p)/(b-p)}function x(M,p,b){return(b-p)*M+p}function P(M,p){const b=M%p;return 0===b?p:P(p,b)}b.r(p),b.d(p,{Clamp:()=>o,DeltaAngle:()=>a,Denormalize:()=>D,ExtractAsInt:()=>Q,Hermite:()=>H,Hermite1stDerivative:()=>F,HighestCommonFactor:()=>P,ILog2:()=>A,InverseLerp:()=>O,Lerp:()=>u,LerpAngle:()=>T,MoveTowards:()=>f,MoveTowardsAngle:()=>R,Normalize:()=>K,NormalizeRadians:()=>W,OutsideRange:()=>B,PercentToRange:()=>x,PingPong:()=>s,RandomRange:()=>k,RangeToPercent:()=>y,Repeat:()=>j,SmoothStep:()=>S,ToHex:()=>i,WithinEpsilon:()=>q})},11796:(M,p,b)=>{b.r(p),b.d(p,{Matrix:()=>D,Quaternion:()=>K,TmpVectors:()=>s,Vector2:()=>i,Ap:()=>A,Vector4:()=>j});var Q=b(11798),q=b(11800),B=b(11757),k=b(11722),u=b(11664),T=b(11806);class O{}function H(M,p,b){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const q=M.Ob(),B=p.Ob(),k=q[0],u=q[1],T=q[2],O=q[3],H=q[4],F=q[5],o=q[6],W=q[7],i=q[8],A=q[9],j=q[10],K=q[11],D=q[12],a=q[13],s=q[14],S=q[15],f=B[0],R=B[1],y=B[2],x=B[3],P=B[4],L=B[5],N=B[6],r=B[7],Y=B[8],w=B[9],E=B[10],n=B[11],g=B[12],U=B[13],c=B[14],d=B[15];b[Q]=k*f+u*P+T*Y+O*g,b[Q+1]=k*R+u*L+T*w+O*U,b[Q+2]=k*y+u*N+T*E+O*c,b[Q+3]=k*x+u*r+T*n+O*d,b[Q+4]=H*f+F*P+o*Y+W*g,b[Q+5]=H*R+F*L+o*w+W*U,b[Q+6]=H*y+F*N+o*E+W*c,b[Q+7]=H*x+F*r+o*n+W*d,b[Q+8]=i*f+A*P+j*Y+K*g,b[Q+9]=i*R+A*L+j*w+K*U,b[Q+10]=i*y+A*N+j*E+K*c,b[Q+11]=i*x+A*r+j*n+K*d,b[Q+12]=D*f+a*P+s*Y+S*g,b[Q+13]=D*R+a*L+s*w+S*U,b[Q+14]=D*y+a*N+s*E+S*c,b[Q+15]=D*x+a*r+s*n+S*d}function F(M,p){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const Q=M.Ob();p[b]=Q[0],p[b+1]=Q[1],p[b+2]=Q[2],p[b+3]=Q[3],p[b+4]=Q[4],p[b+5]=Q[5],p[b+6]=Q[6],p[b+7]=Q[7],p[b+8]=Q[8],p[b+9]=Q[9],p[b+10]=Q[10],p[b+11]=Q[11],p[b+12]=Q[12],p[b+13]=Q[13],p[b+14]=Q[14],p[b+15]=Q[15]}function o(M,p){const b=M.Ob(),Q=b[0],q=b[1],B=b[2],k=b[3],u=b[4],T=b[5],O=b[6],H=b[7],F=b[8],o=b[9],W=b[10],i=b[11],A=b[12],j=b[13],K=b[14],D=b[15],a=W*D-K*i,s=o*D-j*i,S=o*K-j*W,f=F*D-A*i,R=F*K-W*A,y=F*j-A*o,x=+(T*a-O*s+H*S),P=-(u*a-O*f+H*R),L=+(u*s-T*f+H*y),N=-(u*S-T*R+O*y),r=Q*x+q*P+B*L+k*N;if(0===r)return!1;const Y=1/r,w=O*D-K*H,E=T*D-j*H,n=T*K-j*O,g=u*D-A*H,U=u*K-A*O,c=u*j-A*T,d=O*i-W*H,V=T*i-o*H,h=T*W-o*O,I=u*i-F*H,Z=u*W-F*O,J=u*o-F*T,v=-(q*a-B*s+k*S),z=+(Q*a-B*f+k*R),t=-(Q*s-q*f+k*y),e=+(Q*S-q*R+B*y),G=+(q*w-B*E+k*n),mM=-(Q*w-B*g+k*U),C=+(Q*E-q*g+k*c),X=-(Q*n-q*U+B*c),l=-(q*d-B*V+k*h),MM=+(Q*d-B*I+k*Z),pM=-(Q*V-q*I+k*J),bM=+(Q*h-q*Z+B*J);return p[0]=x*Y,p[1]=v*Y,p[2]=G*Y,p[3]=l*Y,p[4]=P*Y,p[5]=z*Y,p[6]=mM*Y,p[7]=MM*Y,p[8]=L*Y,p[9]=t*Y,p[10]=C*Y,p[11]=pM*Y,p[12]=N*Y,p[13]=e*Y,p[14]=X*Y,p[15]=bM*Y,!0}O._UpdateFlagSeed=0;const W=M=>parseInt(M.toString().replace(/\W/g,""));class i{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=M,this.y=p}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let M=W(this.x);return M=397*M^W(this.y),M}toArray(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[p]=this.x,M[p+1]=this.y,this}oQ(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return i.FromArrayToRef(M,p,this),this}Ob(){return[this.x,this.y]}B(M){return this.x=M.x,this.y=M.y,this}Db(M,p){return this.x=M,this.y=p,this}set(M,p){return this.Db(M,p)}sb(M){return this.Db(M,M)}add(M){return new i(this.x+M.x,this.y+M.y)}addToRef(M,p){return p.x=this.x+M.x,p.y=this.y+M.y,p}addInPlace(M){return this.x+=M.x,this.y+=M.y,this}addInPlaceFromFloats(M,p){return this.x+=M,this.y+=p,this}addVector3(M){return new i(this.x+M.x,this.y+M.y)}jp(M){return new i(this.x-M.x,this.y-M.y)}subtractToRef(M,p){return p.x=this.x-M.x,p.y=this.y-M.y,p}TF(M){return this.x-=M.x,this.y-=M.y,this}multiplyInPlace(M){return this.x*=M.x,this.y*=M.y,this}multiply(M){return new i(this.x*M.x,this.y*M.y)}multiplyToRef(M,p){return p.x=this.x*M.x,p.y=this.y*M.y,p}multiplyByFloats(M,p){return new i(this.x*M,this.y*p)}divide(M){return new i(this.x/M.x,this.y/M.y)}divideToRef(M,p){return p.x=this.x/M.x,p.y=this.y/M.y,p}divideInPlace(M){return this.x=this.x/M.x,this.y=this.y/M.y,this}minimizeInPlace(M){return this.minimizeInPlaceFromFloats(M.x,M.y)}maximizeInPlace(M){return this.maximizeInPlaceFromFloats(M.x,M.y)}minimizeInPlaceFromFloats(M,p){return this.x=Math.min(M,this.x),this.y=Math.min(p,this.y),this}maximizeInPlaceFromFloats(M,p){return this.x=Math.max(M,this.x),this.y=Math.max(p,this.y),this}subtractFromFloats(M,p){return new i(this.x-M,this.y-p)}subtractFromFloatsToRef(M,p,b){return b.x=this.x-M,b.y=this.y-p,b}negate(){return new i(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(M){return M.x=-this.x,M.y=-this.y,M}scaleInPlace(M){return this.x*=M,this.y*=M,this}scale(M){return new i(this.x*M,this.y*M)}scaleToRef(M,p){return p.x=this.x*M,p.y=this.y*M,p}scaleAndAddToRef(M,p){return p.x+=this.x*M,p.y+=this.y*M,p}equals(M){return M&&this.x===M.x&&this.y===M.y}equalsWithEpsilon(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.d;return M&&(0,T.WithinEpsilon)(this.x,M.x,p)&&(0,T.WithinEpsilon)(this.y,M.y,p)}equalsToFloats(M,p){return this.x===M&&this.y===p}floor(){return new i(Math.floor(this.x),Math.floor(this.y))}floorToRef(M){return M.x=Math.floor(this.x),M.y=Math.floor(this.y),M}fract(){return new i(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(M){return M.x=this.x-Math.floor(this.x),M.y=this.y-Math.floor(this.y),M}rotate(M){return this.rotateToRef(M,new i)}rotateToRef(M,p){const b=Math.cos(M),Q=Math.sin(M);return p.x=b*this.x-Q*this.y,p.y=Q*this.x+b*this.y,p}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){const M=new i;return this.normalizeToRef(M),M}normalizeToRef(M){const p=this.length();return 0===p&&(M.x=this.x,M.y=this.y),this.scaleToRef(1/p,M)}clone(){return new i(this.x,this.y)}dot(M){return this.x*M.x+this.y*M.y}static Zero(){return new i(0,0)}static One(){return new i(1,1)}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new i((0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Db((0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p))}static get ZeroReadOnly(){return i._ZeroReadOnly}static sp(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new i(M[p],M[p+1])}static FromArrayToRef(M,p,b){return b.x=M[p],b.y=M[p+1],b}static FromFloatsToRef(M,p,b){return b.Db(M,p),b}static CatmullRom(M,p,b,Q,q){const B=q*q,k=q*B,u=.5*(2*p.x+(-M.x+b.x)*q+(2*M.x-5*p.x+4*b.x-Q.x)*B+(-M.x+3*p.x-3*b.x+Q.x)*k),T=.5*(2*p.y+(-M.y+b.y)*q+(2*M.y-5*p.y+4*b.y-Q.y)*B+(-M.y+3*p.y-3*b.y+Q.y)*k);return new i(u,T)}static ClampToRef(M,p,b,Q){return Q.x=(0,T.Clamp)(M.x,p.x,b.x),Q.y=(0,T.Clamp)(M.y,p.y,b.y),Q}static Clamp(M,p,b){const Q=(0,T.Clamp)(M.x,p.x,b.x),q=(0,T.Clamp)(M.y,p.y,b.y);return new i(Q,q)}static Hermite(M,p,b,Q,q){const B=q*q,k=q*B,u=2*k-3*B+1,T=-2*k+3*B,O=k-2*B+q,H=k-B,F=M.x*u+b.x*T+p.x*O+Q.x*H,o=M.y*u+b.y*T+p.y*O+Q.y*H;return new i(F,o)}static Hermite1stDerivative(M,p,b,Q,q){return this.Hermite1stDerivativeToRef(M,p,b,Q,q,new i)}static Hermite1stDerivativeToRef(M,p,b,Q,q,B){const k=q*q;return B.x=6*(k-q)*M.x+(3*k-4*q+1)*p.x+6*(-k+q)*b.x+(3*k-2*q)*Q.x,B.y=6*(k-q)*M.y+(3*k-4*q+1)*p.y+6*(-k+q)*b.y+(3*k-2*q)*Q.y,B}static Lerp(M,p,b){return i.LerpToRef(M,p,b,new i)}static LerpToRef(M,p,b,Q){return Q.x=M.x+(p.x-M.x)*b,Q.y=M.y+(p.y-M.y)*b,Q}static Dot(M,p){return M.x*p.x+M.y*p.y}static Normalize(M){return i.NormalizeToRef(M,new i)}static NormalizeToRef(M,p){return M.normalizeToRef(p),p}static Minimize(M,p){const b=M.x<p.x?M.x:p.x,Q=M.y<p.y?M.y:p.y;return new i(b,Q)}static Maximize(M,p){const b=M.x>p.x?M.x:p.x,Q=M.y>p.y?M.y:p.y;return new i(b,Q)}static Transform(M,p){return i.TransformToRef(M,p,new i)}static TransformToRef(M,p,b){const Q=p.m,q=M.x*Q[0]+M.y*Q[4]+Q[12],B=M.x*Q[1]+M.y*Q[5]+Q[13];return b.x=q,b.y=B,b}static PointInTriangle(M,p,b,Q){const q=.5*(-b.y*Q.x+p.y*(-b.x+Q.x)+p.x*(b.y-Q.y)+b.x*Q.y),B=q<0?-1:1,k=(p.y*Q.x-p.x*Q.y+(Q.y-p.y)*M.x+(p.x-Q.x)*M.y)*B,u=(p.x*b.y-p.y*b.x+(p.y-b.y)*M.x+(b.x-p.x)*M.y)*B;return k>0&&u>0&&k+u<2*q*B}static Distance(M,p){return Math.sqrt(i.DistanceSquared(M,p))}static DistanceSquared(M,p){const b=M.x-p.x,Q=M.y-p.y;return b*b+Q*Q}static Center(M,p){return i.CenterToRef(M,p,new i)}static CenterToRef(M,p,b){return b.Db((M.x+p.x)/2,(M.y+p.y)/2)}static DistanceOfPointFromSegment(M,p,b){const Q=i.DistanceSquared(p,b);if(0===Q)return i.Distance(M,p);const q=b.jp(p),B=Math.max(0,Math.min(1,i.Dot(M.jp(p),q)/Q)),k=p.add(q.multiplyByFloats(B,B));return i.Distance(M,k)}}i._V8PerformanceHack=new i(.5,.5),i._ZeroReadOnly=i.Zero(),Object.defineProperties(i.prototype,{dimension:{value:[2]},rank:{value:1}});class A{get x(){return this._x}set x(M){this._x=M,this._isDirty=!0}get y(){return this._y}set y(M){this._y=M,this._isDirty=!0}get z(){return this._z}set z(M){this._z=M,this._isDirty=!0}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=M,this._y=p,this._z=b}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Ap"}getHashCode(){let M=W(this._x);return M=397*M^W(this._y),M=397*M^W(this._z),M}Ob(){return[this._x,this._y,this._z]}toArray(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[p]=this._x,M[p+1]=this._y,M[p+2]=this._z,this}oQ(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return A.FromArrayToRef(M,p,this),this}toQuaternion(){return K.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(M){return this._x+=M._x,this._y+=M._y,this._z+=M._z,this._isDirty=!0,this}addInPlaceFromFloats(M,p,b){return this._x+=M,this._y+=p,this._z+=b,this._isDirty=!0,this}add(M){return new A(this._x+M._x,this._y+M._y,this._z+M._z)}addToRef(M,p){return p._x=this._x+M._x,p._y=this._y+M._y,p._z=this._z+M._z,p._isDirty=!0,p}TF(M){return this._x-=M._x,this._y-=M._y,this._z-=M._z,this._isDirty=!0,this}jp(M){return new A(this._x-M._x,this._y-M._y,this._z-M._z)}subtractToRef(M,p){return this.subtractFromFloatsToRef(M._x,M._y,M._z,p)}subtractFromFloats(M,p,b){return new A(this._x-M,this._y-p,this._z-b)}subtractFromFloatsToRef(M,p,b,Q){return Q._x=this._x-M,Q._y=this._y-p,Q._z=this._z-b,Q._isDirty=!0,Q}negate(){return new A(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(M){return M._x=-1*this._x,M._y=-1*this._y,M._z=-1*this._z,M._isDirty=!0,M}scaleInPlace(M){return this._x*=M,this._y*=M,this._z*=M,this._isDirty=!0,this}scale(M){return new A(this._x*M,this._y*M,this._z*M)}scaleToRef(M,p){return p._x=this._x*M,p._y=this._y*M,p._z=this._z*M,p._isDirty=!0,p}getNormalToRef(M){const p=this.length();let b=Math.acos(this._y/p);const Q=Math.atan2(this._z,this._x);b>Math.PI/2?b-=Math.PI/2:b+=Math.PI/2;const q=p*Math.sin(b)*Math.cos(Q),B=p*Math.cos(b),k=p*Math.sin(b)*Math.sin(Q);return M.set(q,B,k),M}applyRotationQuaternionToRef(M,p){const b=this._x,Q=this._y,q=this._z,B=M._x,k=M._y,u=M._z,T=M._w,O=2*(k*q-u*Q),H=2*(u*b-B*q),F=2*(B*Q-k*b);return p._x=b+T*O+k*F-u*H,p._y=Q+T*H+u*O-B*F,p._z=q+T*F+B*H-k*O,p._isDirty=!0,p}applyRotationQuaternionInPlace(M){return this.applyRotationQuaternionToRef(M,this)}applyRotationQuaternion(M){return this.applyRotationQuaternionToRef(M,new A)}scaleAndAddToRef(M,p){return p._x+=this._x*M,p._y+=this._y*M,p._z+=this._z*M,p._isDirty=!0,p}projectOnPlane(M,p){return this.projectOnPlaneToRef(M,p,new A)}projectOnPlaneToRef(M,p,b){const Q=M.normal,q=M.d,B=a.Ap[0];this.subtractToRef(p,B),B.normalize();const k=A.Dot(B,Q);if(Math.abs(k)<1e-10)b.sb(1/0);else{const M=-(A.Dot(p,Q)+q)/k,u=B.scaleInPlace(M);p.addToRef(u,b)}return b}equals(M){return M&&this._x===M._x&&this._y===M._y&&this._z===M._z}equalsWithEpsilon(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.d;return M&&(0,T.WithinEpsilon)(this._x,M._x,p)&&(0,T.WithinEpsilon)(this._y,M._y,p)&&(0,T.WithinEpsilon)(this._z,M._z,p)}equalsToFloats(M,p,b){return this._x===M&&this._y===p&&this._z===b}multiplyInPlace(M){return this._x*=M._x,this._y*=M._y,this._z*=M._z,this._isDirty=!0,this}multiply(M){return this.multiplyByFloats(M._x,M._y,M._z)}multiplyToRef(M,p){return p._x=this._x*M._x,p._y=this._y*M._y,p._z=this._z*M._z,p._isDirty=!0,p}multiplyByFloats(M,p,b){return new A(this._x*M,this._y*p,this._z*b)}divide(M){return new A(this._x/M._x,this._y/M._y,this._z/M._z)}divideToRef(M,p){return p._x=this._x/M._x,p._y=this._y/M._y,p._z=this._z/M._z,p._isDirty=!0,p}divideInPlace(M){return this._x=this._x/M._x,this._y=this._y/M._y,this._z=this._z/M._z,this._isDirty=!0,this}minimizeInPlace(M){return this.minimizeInPlaceFromFloats(M._x,M._y,M._z)}maximizeInPlace(M){return this.maximizeInPlaceFromFloats(M._x,M._y,M._z)}minimizeInPlaceFromFloats(M,p,b){return M<this._x&&(this.x=M),p<this._y&&(this.y=p),b<this._z&&(this.z=b),this}maximizeInPlaceFromFloats(M,p,b){return M>this._x&&(this.x=M),p>this._y&&(this.y=p),b>this._z&&(this.z=b),this}isNonUniformWithinEpsilon(M){const p=Math.abs(this._x),b=Math.abs(this._y);if(!(0,T.WithinEpsilon)(p,b,M))return!0;const Q=Math.abs(this._z);return!(0,T.WithinEpsilon)(p,Q,M)||!(0,T.WithinEpsilon)(b,Q,M)}get isNonUniform(){const M=Math.abs(this._x);if(M!==Math.abs(this._y))return!0;return M!==Math.abs(this._z)}floorToRef(M){return M._x=Math.floor(this._x),M._y=Math.floor(this._y),M._z=Math.floor(this._z),M._isDirty=!0,M}floor(){return new A(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(M){return M._x=this._x-Math.floor(this._x),M._y=this._y-Math.floor(this._y),M._z=this._z-Math.floor(this._z),M._isDirty=!0,M}fract(){return new A(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(M){if("xyz"===(M=M.toLowerCase()))return this;const p=a.Ap[0].B(this);return this.x=p[M[0]],this.y=p[M[1]],this.z=p[M[2]],this}rotateByQuaternionToRef(M,p){return M.toRotationMatrix(a.Matrix[0]),A.TransformCoordinatesToRef(this,a.Matrix[0],p),p}rotateByQuaternionAroundPointToRef(M,p,b){return this.subtractToRef(p,a.Ap[0]),a.Ap[0].rotateByQuaternionToRef(M,a.Ap[0]),p.addToRef(a.Ap[0],b),b}cross(M){return A.CrossToRef(this,M,new A)}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){return this.normalizeToRef(new A)}normalizeToRef(M){const p=this.length();return 0===p||1===p?(M._x=this._x,M._y=this._y,M._z=this._z,M._isDirty=!0,M):this.scaleToRef(1/p,M)}clone(){return new A(this._x,this._y,this._z)}B(M){return this.Db(M._x,M._y,M._z)}Db(M,p,b){return this._x=M,this._y=p,this._z=b,this._isDirty=!0,this}set(M,p,b){return this.Db(M,p,b)}sb(M){return this._x=this._y=this._z=M,this._isDirty=!0,this}static GetClipFactor(M,p,b,Q){const q=A.Dot(M,b);return(q-Q)/(q-A.Dot(p,b))}static GetAngleBetweenVectors(M,p,b){const Q=M.normalizeToRef(a.Ap[1]),q=p.normalizeToRef(a.Ap[2]);let B=A.Dot(Q,q);B=(0,T.Clamp)(B,-1,1);const k=Math.acos(B),u=a.Ap[3];return A.CrossToRef(Q,q,u),A.Dot(u,b)>0?isNaN(k)?0:k:isNaN(k)?-Math.PI:-Math.acos(B)}static GetAngleBetweenVectorsOnPlane(M,p,b){a.Ap[0].B(M);const Q=a.Ap[0];a.Ap[1].B(p);const q=a.Ap[1];a.Ap[2].B(b);const B=a.Ap[2],k=a.Ap[3],u=a.Ap[4];Q.normalize(),q.normalize(),B.normalize(),A.CrossToRef(B,Q,k),A.CrossToRef(k,B,u);const O=Math.atan2(A.Dot(q,k),A.Dot(q,u));return(0,T.NormalizeRadians)(O)}static PitchYawRollToMoveBetweenPointsToRef(M,p,b){const Q=s.Ap[0];return p.subtractToRef(M,Q),b._y=Math.atan2(Q.x,Q.z)||0,b._x=Math.atan2(Math.sqrt(Q.x**2+Q.z**2),Q.y)||0,b._z=0,b._isDirty=!0,b}static PitchYawRollToMoveBetweenPoints(M,p){const b=A.Zero();return A.PitchYawRollToMoveBetweenPointsToRef(M,p,b)}static SlerpToRef(M,p,b,q){b=(0,T.Clamp)(b,0,1);const B=a.Ap[0],k=a.Ap[1];B.B(M);const u=B.length();B.normalizeFromLength(u),k.B(p);const O=k.length();k.normalizeFromLength(O);const H=A.Dot(B,k);let F,o;if(H<1-Q.d){const M=Math.acos(H),p=1/Math.sin(M);F=Math.sin((1-b)*M)*p,o=Math.sin(b*M)*p}else F=1-b,o=b;return B.scaleInPlace(F),k.scaleInPlace(o),q.B(B).addInPlace(k),q.scaleInPlace((0,T.Lerp)(u,O,b)),q}static SmoothToRef(M,p,b,Q,q){return A.SlerpToRef(M,p,0===Q?1:b/Q,q),q}static sp(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new A(M[p],M[p+1],M[p+2])}static FromFloatArray(M,p){return A.sp(M,p)}static FromArrayToRef(M,p,b){return b._x=M[p],b._y=M[p+1],b._z=M[p+2],b._isDirty=!0,b}static FromFloatArrayToRef(M,p,b){return A.FromArrayToRef(M,p,b)}static FromFloatsToRef(M,p,b,Q){return Q.Db(M,p,b),Q}static Zero(){return new A(0,0,0)}static One(){return new A(1,1,1)}static Up(){return new A(0,1,0)}static get UpReadOnly(){return A._UpReadOnly}static get DownReadOnly(){return A._DownReadOnly}static get RightReadOnly(){return A._RightReadOnly}static get LeftReadOnly(){return A._LeftReadOnly}static get LeftHandedForwardReadOnly(){return A._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return A._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return A._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return A._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return A._ZeroReadOnly}static get OneReadOnly(){return A._OneReadOnly}static Down(){return new A(0,-1,0)}static Forward(){return new A(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new A(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new A(1,0,0)}static Left(){return new A(-1,0,0)}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new A((0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Db((0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p))}static TransformCoordinates(M,p){const b=A.Zero();return A.TransformCoordinatesToRef(M,p,b),b}static TransformCoordinatesToRef(M,p,b){return A.TransformCoordinatesFromFloatsToRef(M._x,M._y,M._z,p,b),b}static TransformCoordinatesFromFloatsToRef(M,p,b,Q,q){const B=Q.m,k=M*B[0]+p*B[4]+b*B[8]+B[12],u=M*B[1]+p*B[5]+b*B[9]+B[13],T=M*B[2]+p*B[6]+b*B[10]+B[14],O=1/(M*B[3]+p*B[7]+b*B[11]+B[15]);return q._x=k*O,q._y=u*O,q._z=T*O,q._isDirty=!0,q}static TransformNormal(M,p){const b=A.Zero();return A.TransformNormalToRef(M,p,b),b}static TransformNormalToRef(M,p,b){return this.TransformNormalFromFloatsToRef(M._x,M._y,M._z,p,b),b}static TransformNormalFromFloatsToRef(M,p,b,Q,q){const B=Q.m;return q._x=M*B[0]+p*B[4]+b*B[8],q._y=M*B[1]+p*B[5]+b*B[9],q._z=M*B[2]+p*B[6]+b*B[10],q._isDirty=!0,q}static CatmullRom(M,p,b,Q,q){const B=q*q,k=q*B,u=.5*(2*p._x+(-M._x+b._x)*q+(2*M._x-5*p._x+4*b._x-Q._x)*B+(-M._x+3*p._x-3*b._x+Q._x)*k),T=.5*(2*p._y+(-M._y+b._y)*q+(2*M._y-5*p._y+4*b._y-Q._y)*B+(-M._y+3*p._y-3*b._y+Q._y)*k),O=.5*(2*p._z+(-M._z+b._z)*q+(2*M._z-5*p._z+4*b._z-Q._z)*B+(-M._z+3*p._z-3*b._z+Q._z)*k);return new A(u,T,O)}static Clamp(M,p,b){const Q=new A;return A.ClampToRef(M,p,b,Q),Q}static ClampToRef(M,p,b,Q){let q=M._x;q=q>b._x?b._x:q,q=q<p._x?p._x:q;let B=M._y;B=B>b._y?b._y:B,B=B<p._y?p._y:B;let k=M._z;return k=k>b._z?b._z:k,k=k<p._z?p._z:k,Q.Db(q,B,k),Q}static CheckExtends(M,p,b){p.minimizeInPlace(M),b.maximizeInPlace(M)}static Hermite(M,p,b,Q,q){const B=q*q,k=q*B,u=2*k-3*B+1,T=-2*k+3*B,O=k-2*B+q,H=k-B,F=M._x*u+b._x*T+p._x*O+Q._x*H,o=M._y*u+b._y*T+p._y*O+Q._y*H,W=M._z*u+b._z*T+p._z*O+Q._z*H;return new A(F,o,W)}static Hermite1stDerivative(M,p,b,Q,q){const B=new A;return this.Hermite1stDerivativeToRef(M,p,b,Q,q,B),B}static Hermite1stDerivativeToRef(M,p,b,Q,q,B){const k=q*q;return B._x=6*(k-q)*M._x+(3*k-4*q+1)*p._x+6*(-k+q)*b._x+(3*k-2*q)*Q._x,B._y=6*(k-q)*M._y+(3*k-4*q+1)*p._y+6*(-k+q)*b._y+(3*k-2*q)*Q._y,B._z=6*(k-q)*M._z+(3*k-4*q+1)*p._z+6*(-k+q)*b._z+(3*k-2*q)*Q._z,B._isDirty=!0,B}static Lerp(M,p,b){const Q=new A(0,0,0);return A.LerpToRef(M,p,b,Q),Q}static LerpToRef(M,p,b,Q){return Q._x=M._x+(p._x-M._x)*b,Q._y=M._y+(p._y-M._y)*b,Q._z=M._z+(p._z-M._z)*b,Q._isDirty=!0,Q}static Dot(M,p){return M._x*p._x+M._y*p._y+M._z*p._z}dot(M){return this._x*M._x+this._y*M._y+this._z*M._z}static Cross(M,p){const b=new A;return A.CrossToRef(M,p,b),b}static CrossToRef(M,p,b){const Q=M._y*p._z-M._z*p._y,q=M._z*p._x-M._x*p._z,B=M._x*p._y-M._y*p._x;return b.Db(Q,q,B),b}static Normalize(M){const p=A.Zero();return A.NormalizeToRef(M,p),p}static NormalizeToRef(M,p){return M.normalizeToRef(p),p}static Project(M,p,b,Q){const q=new A;return A.ProjectToRef(M,p,b,Q,q),q}static ProjectToRef(M,p,b,Q,q){var B;const k=Q.width,T=Q.height,O=Q.x,H=Q.y,F=a.Matrix[1],o=null===(B=u.c.LastCreatedEngine)||void 0===B?void 0:B.isNDCHalfZRange,W=o?1:.5,i=o?0:.5;D.FromValuesToRef(k/2,0,0,0,0,-T/2,0,0,0,0,W,0,O+k/2,T/2+H,i,1,F);const j=a.Matrix[0];return p.multiplyToRef(b,j),j.multiplyToRef(F,j),A.TransformCoordinatesToRef(M,j,q),q}static Reflect(M,p){return this.ReflectToRef(M,p,new A)}static ReflectToRef(M,p,b){const Q=s.Ap[0];return Q.B(p).scaleInPlace(2*A.Dot(M,p)),b.B(M).TF(Q)}static _UnprojectFromInvertedMatrixToRef(M,p,b){A.TransformCoordinatesToRef(M,p,b);const Q=p.m,q=M._x*Q[3]+M._y*Q[7]+M._z*Q[11]+Q[15];return(0,T.WithinEpsilon)(q,1)&&b.scaleInPlace(1/q),b}static UnprojectFromTransform(M,p,b,Q,q){return this.Unproject(M,p,b,Q,q,D.IdentityReadOnly)}static Unproject(M,p,b,Q,q,B){const k=new A;return A.UnprojectToRef(M,p,b,Q,q,B,k),k}static UnprojectToRef(M,p,b,Q,q,B,k){return A.UnprojectFloatsToRef(M._x,M._y,M._z,p,b,Q,q,B,k),k}static UnprojectFloatsToRef(M,p,b,Q,q,B,k,T,O){var H;const F=a.Matrix[0];B.multiplyToRef(k,F),F.multiplyToRef(T,F),F.invert();const o=a.Ap[0];return o.x=M/Q*2-1,o.y=-(p/q*2-1),null!==(H=u.c.LastCreatedEngine)&&void 0!==H&&H.isNDCHalfZRange?o.z=b:o.z=2*b-1,A._UnprojectFromInvertedMatrixToRef(o,F,O),O}static Minimize(M,p){const b=new A;return b.B(M),b.minimizeInPlace(p),b}static Maximize(M,p){const b=new A;return b.B(M),b.maximizeInPlace(p),b}static Distance(M,p){return Math.sqrt(A.DistanceSquared(M,p))}static DistanceSquared(M,p){const b=M._x-p._x,Q=M._y-p._y,q=M._z-p._z;return b*b+Q*Q+q*q}static ProjectOnTriangleToRef(M,p,b,q,B){const k=a.Ap[0],u=a.Ap[1],O=a.Ap[2],H=a.Ap[3],F=a.Ap[4];b.subtractToRef(p,k),q.subtractToRef(p,u),q.subtractToRef(b,O);const o=k.length(),W=u.length(),i=O.length();if(o<Q.d||W<Q.d||i<Q.d)return B.B(p),A.Distance(M,p);M.subtractToRef(p,F),A.CrossToRef(k,u,H);const j=H.length();if(j<Q.d)return B.B(p),A.Distance(M,p);H.normalizeFromLength(j);let K=F.length();if(K<Q.d)return B.B(p),0;F.normalizeFromLength(K);const D=A.Dot(H,F),s=a.Ap[5],S=a.Ap[6];s.B(H).scaleInPlace(-K*D),S.B(M).addInPlace(s);const f=a.Ap[4],R=a.Ap[5],y=a.Ap[7],x=a.Ap[8];f.B(k).scaleInPlace(1/o),x.B(u).scaleInPlace(1/W),f.addInPlace(x).scaleInPlace(-1),R.B(k).scaleInPlace(-1/o),x.B(O).scaleInPlace(1/i),R.addInPlace(x).scaleInPlace(-1),y.B(O).scaleInPlace(-1/i),x.B(u).scaleInPlace(-1/W),y.addInPlace(x).scaleInPlace(-1);const P=a.Ap[9];let L;P.B(S).TF(p),A.CrossToRef(f,P,x),L=A.Dot(x,H);const N=L;P.B(S).TF(b),A.CrossToRef(R,P,x),L=A.Dot(x,H);const r=L;P.B(S).TF(q),A.CrossToRef(y,P,x),L=A.Dot(x,H);const Y=L,w=a.Ap[10];let E,n;N>0&&r<0?(w.B(k),E=p,n=b):r>0&&Y<0?(w.B(O),E=b,n=q):(w.B(u).scaleInPlace(-1),E=q,n=p);const g=a.Ap[9],U=a.Ap[4];E.subtractToRef(S,x),n.subtractToRef(S,g),A.CrossToRef(x,g,U);if(!(A.Dot(U,H)<0))return B.B(S),Math.abs(K*D);const c=a.Ap[5];A.CrossToRef(w,U,c),c.normalize();const d=a.Ap[9];d.B(E).TF(S);const V=d.length();if(V<Q.d)return B.B(E),A.Distance(M,E);d.normalizeFromLength(V);const h=A.Dot(c,d),I=a.Ap[7];I.B(S).addInPlace(c.scaleInPlace(V*h)),x.B(I).TF(E),K=w.length(),w.normalizeFromLength(K);let Z=A.Dot(x,w)/Math.max(K,Q.d);return Z=(0,T.Clamp)(Z,0,1),I.B(E).addInPlace(w.scaleInPlace(Z*K)),B.B(I),A.Distance(M,I)}static Center(M,p){return A.CenterToRef(M,p,A.Zero())}static CenterToRef(M,p,b){return b.Db((M._x+p._x)/2,(M._y+p._y)/2,(M._z+p._z)/2)}static RotationFromAxis(M,p,b){const Q=new A;return A.RotationFromAxisToRef(M,p,b,Q),Q}static RotationFromAxisToRef(M,p,b,Q){const q=a.Quaternion[0];return K.RotationQuaternionFromAxisToRef(M,p,b,q),q.toEulerAnglesToRef(Q),Q}}A._V8PerformanceHack=new A(.5,.5,.5),A._UpReadOnly=A.Up(),A._DownReadOnly=A.Down(),A._LeftHandedForwardReadOnly=A.Forward(!1),A._RightHandedForwardReadOnly=A.Forward(!0),A._LeftHandedBackwardReadOnly=A.Backward(!1),A._RightHandedBackwardReadOnly=A.Backward(!0),A._RightReadOnly=A.Right(),A._LeftReadOnly=A.Left(),A._ZeroReadOnly=A.Zero(),A._OneReadOnly=A.One(),Object.defineProperties(A.prototype,{dimension:{value:[3]},rank:{value:1}});class j{get x(){return this._x}set x(M){this._x=M,this._isDirty=!0}get y(){return this._y}set y(M){this._y=M,this._isDirty=!0}get z(){return this._z}set z(M){this._z=M,this._isDirty=!0}get w(){return this._w}set w(M){this._w=M,this._isDirty=!0}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=M,this._y=p,this._z=b,this._w=Q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let M=W(this._x);return M=397*M^W(this._y),M=397*M^W(this._z),M=397*M^W(this._w),M}Ob(){return[this._x,this._y,this._z,this._w]}toArray(M,p){return void 0===p&&(p=0),M[p]=this._x,M[p+1]=this._y,M[p+2]=this._z,M[p+3]=this._w,this}oQ(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return j.FromArrayToRef(M,p,this),this}addInPlace(M){return this.x+=M._x,this.y+=M._y,this.z+=M._z,this.w+=M._w,this}addInPlaceFromFloats(M,p,b,Q){return this.x+=M,this.y+=p,this.z+=b,this.w+=Q,this}add(M){return new j(this._x+M.x,this._y+M.y,this._z+M.z,this._w+M.w)}addToRef(M,p){return p.x=this._x+M.x,p.y=this._y+M.y,p.z=this._z+M.z,p.w=this._w+M.w,p}TF(M){return this.x-=M.x,this.y-=M.y,this.z-=M.z,this.w-=M.w,this}jp(M){return new j(this._x-M.x,this._y-M.y,this._z-M.z,this._w-M.w)}subtractToRef(M,p){return p.x=this._x-M.x,p.y=this._y-M.y,p.z=this._z-M.z,p.w=this._w-M.w,p}subtractFromFloats(M,p,b,Q){return new j(this._x-M,this._y-p,this._z-b,this._w-Q)}subtractFromFloatsToRef(M,p,b,Q,q){return q.x=this._x-M,q.y=this._y-p,q.z=this._z-b,q.w=this._w-Q,q}negate(){return new j(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(M){return M.x=-this._x,M.y=-this._y,M.z=-this._z,M.w=-this._w,M}scaleInPlace(M){return this.x*=M,this.y*=M,this.z*=M,this.w*=M,this}scale(M){return new j(this._x*M,this._y*M,this._z*M,this._w*M)}scaleToRef(M,p){return p.x=this._x*M,p.y=this._y*M,p.z=this._z*M,p.w=this._w*M,p}scaleAndAddToRef(M,p){return p.x+=this._x*M,p.y+=this._y*M,p.z+=this._z*M,p.w+=this._w*M,p}equals(M){return M&&this._x===M.x&&this._y===M.y&&this._z===M.z&&this._w===M.w}equalsWithEpsilon(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.d;return M&&(0,T.WithinEpsilon)(this._x,M.x,p)&&(0,T.WithinEpsilon)(this._y,M.y,p)&&(0,T.WithinEpsilon)(this._z,M.z,p)&&(0,T.WithinEpsilon)(this._w,M.w,p)}equalsToFloats(M,p,b,Q){return this._x===M&&this._y===p&&this._z===b&&this._w===Q}multiplyInPlace(M){return this.x*=M.x,this.y*=M.y,this.z*=M.z,this.w*=M.w,this}multiply(M){return new j(this._x*M.x,this._y*M.y,this._z*M.z,this._w*M.w)}multiplyToRef(M,p){return p.x=this._x*M.x,p.y=this._y*M.y,p.z=this._z*M.z,p.w=this._w*M.w,p}multiplyByFloats(M,p,b,Q){return new j(this._x*M,this._y*p,this._z*b,this._w*Q)}divide(M){return new j(this._x/M.x,this._y/M.y,this._z/M.z,this._w/M.w)}divideToRef(M,p){return p.x=this._x/M.x,p.y=this._y/M.y,p.z=this._z/M.z,p.w=this._w/M.w,p}divideInPlace(M){return this.divideToRef(M,this)}minimizeInPlace(M){return M.x<this._x&&(this.x=M.x),M.y<this._y&&(this.y=M.y),M.z<this._z&&(this.z=M.z),M.w<this._w&&(this.w=M.w),this}maximizeInPlace(M){return M.x>this._x&&(this.x=M.x),M.y>this._y&&(this.y=M.y),M.z>this._z&&(this.z=M.z),M.w>this._w&&(this.w=M.w),this}minimizeInPlaceFromFloats(M,p,b,Q){return this.x=Math.min(M,this._x),this.y=Math.min(p,this._y),this.z=Math.min(b,this._z),this.w=Math.min(Q,this._w),this}maximizeInPlaceFromFloats(M,p,b,Q){return this.x=Math.max(M,this._x),this.y=Math.max(p,this._y),this.z=Math.max(b,this._z),this.w=Math.max(Q,this._w),this}floorToRef(M){return M.x=Math.floor(this._x),M.y=Math.floor(this._y),M.z=Math.floor(this._z),M.w=Math.floor(this._w),M}floor(){return new j(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(M){return M.x=this._x-Math.floor(this._x),M.y=this._y-Math.floor(this._y),M.z=this._z-Math.floor(this._z),M.w=this._w-Math.floor(this._w),M}fract(){return new j(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){return this.normalizeToRef(new j)}normalizeToRef(M){const p=this.length();return 0===p||1===p?(M.x=this._x,M.y=this._y,M.z=this._z,M.w=this._w,M):this.scaleToRef(1/p,M)}toVector3(){return new A(this._x,this._y,this._z)}clone(){return new j(this._x,this._y,this._z,this._w)}B(M){return this.x=M.x,this.y=M.y,this.z=M.z,this.w=M.w,this}Db(M,p,b,Q){return this.x=M,this.y=p,this.z=b,this.w=Q,this}set(M,p,b,Q){return this.Db(M,p,b,Q)}sb(M){return this.x=this.y=this.z=this.w=M,this}dot(M){return this._x*M.x+this._y*M.y+this._z*M.z+this._w*M.w}static sp(M,p){return p||(p=0),new j(M[p],M[p+1],M[p+2],M[p+3])}static FromArrayToRef(M,p,b){return b.x=M[p],b.y=M[p+1],b.z=M[p+2],b.w=M[p+3],b}static FromFloatArrayToRef(M,p,b){return j.FromArrayToRef(M,p,b),b}static FromFloatsToRef(M,p,b,Q,q){return q.x=M,q.y=p,q.z=b,q.w=Q,q}static Zero(){return new j(0,0,0,0)}static One(){return new j(1,1,1,1)}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new j((0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.x=(0,T.RandomRange)(M,p),b.y=(0,T.RandomRange)(M,p),b.z=(0,T.RandomRange)(M,p),b.w=(0,T.RandomRange)(M,p),b}static Clamp(M,p,b){return j.ClampToRef(M,p,b,new j)}static ClampToRef(M,p,b,Q){return Q.x=(0,T.Clamp)(M.x,p.x,b.x),Q.y=(0,T.Clamp)(M.y,p.y,b.y),Q.z=(0,T.Clamp)(M.z,p.z,b.z),Q.w=(0,T.Clamp)(M.w,p.w,b.w),Q}static CheckExtends(M,p,b){p.minimizeInPlace(M),b.maximizeInPlace(M)}static get ZeroReadOnly(){return j._ZeroReadOnly}static Normalize(M){return j.NormalizeToRef(M,new j)}static NormalizeToRef(M,p){return M.normalizeToRef(p),p}static Minimize(M,p){const b=new j;return b.B(M),b.minimizeInPlace(p),b}static Maximize(M,p){const b=new j;return b.B(M),b.maximizeInPlace(p),b}static Distance(M,p){return Math.sqrt(j.DistanceSquared(M,p))}static DistanceSquared(M,p){const b=M.x-p.x,Q=M.y-p.y,q=M.z-p.z,B=M.w-p.w;return b*b+Q*Q+q*q+B*B}static Center(M,p){return j.CenterToRef(M,p,new j)}static CenterToRef(M,p,b){return b.x=(M.x+p.x)/2,b.y=(M.y+p.y)/2,b.z=(M.z+p.z)/2,b.w=(M.w+p.w)/2,b}static TransformCoordinates(M,p){return j.TransformCoordinatesToRef(M,p,new j)}static TransformCoordinatesToRef(M,p,b){return j.TransformCoordinatesFromFloatsToRef(M._x,M._y,M._z,p,b),b}static TransformCoordinatesFromFloatsToRef(M,p,b,Q,q){const B=Q.m,k=M*B[0]+p*B[4]+b*B[8]+B[12],u=M*B[1]+p*B[5]+b*B[9]+B[13],T=M*B[2]+p*B[6]+b*B[10]+B[14],O=M*B[3]+p*B[7]+b*B[11]+B[15];return q.x=k,q.y=u,q.z=T,q.w=O,q}static TransformNormal(M,p){return j.TransformNormalToRef(M,p,new j)}static TransformNormalToRef(M,p,b){const Q=p.m,q=M.x*Q[0]+M.y*Q[4]+M.z*Q[8],B=M.x*Q[1]+M.y*Q[5]+M.z*Q[9],k=M.x*Q[2]+M.y*Q[6]+M.z*Q[10];return b.x=q,b.y=B,b.z=k,b.w=M.w,b}static TransformNormalFromFloatsToRef(M,p,b,Q,q,B){const k=q.m;return B.x=M*k[0]+p*k[4]+b*k[8],B.y=M*k[1]+p*k[5]+b*k[9],B.z=M*k[2]+p*k[6]+b*k[10],B.w=Q,B}static FromVector3(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new j(M._x,M._y,M._z,p)}static Dot(M,p){return M.x*p.x+M.y*p.y+M.z*p.z+M.w*p.w}}j._V8PerformanceHack=new j(.5,.5,.5,.5),j._ZeroReadOnly=j.Zero(),Object.defineProperties(j.prototype,{dimension:{value:[4]},rank:{value:1}});class K{get x(){return this._x}set x(M){this._x=M,this._isDirty=!0}get y(){return this._y}set y(M){this._y=M,this._isDirty=!0}get z(){return this._z}set z(M){this._z=M,this._isDirty=!0}get w(){return this._w}set w(M){this._w=M,this._isDirty=!0}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=M,this._y=p,this._z=b,this._w=Q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let M=W(this._x);return M=397*M^W(this._y),M=397*M^W(this._z),M=397*M^W(this._w),M}Ob(){return[this._x,this._y,this._z,this._w]}toArray(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[p]=this._x,M[p+1]=this._y,M[p+2]=this._z,M[p+3]=this._w,this}oQ(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(M,p,this)}equals(M){return M&&this._x===M._x&&this._y===M._y&&this._z===M._z&&this._w===M._w}equalsWithEpsilon(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.d;return M&&(0,T.WithinEpsilon)(this._x,M._x,p)&&(0,T.WithinEpsilon)(this._y,M._y,p)&&(0,T.WithinEpsilon)(this._z,M._z,p)&&(0,T.WithinEpsilon)(this._w,M._w,p)}isApprox(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.d;return M&&((0,T.WithinEpsilon)(this._x,M._x,p)&&(0,T.WithinEpsilon)(this._y,M._y,p)&&(0,T.WithinEpsilon)(this._z,M._z,p)&&(0,T.WithinEpsilon)(this._w,M._w,p)||(0,T.WithinEpsilon)(this._x,-M._x,p)&&(0,T.WithinEpsilon)(this._y,-M._y,p)&&(0,T.WithinEpsilon)(this._z,-M._z,p)&&(0,T.WithinEpsilon)(this._w,-M._w,p))}clone(){return new K(this._x,this._y,this._z,this._w)}B(M){return this._x=M._x,this._y=M._y,this._z=M._z,this._w=M._w,this._isDirty=!0,this}Db(M,p,b,Q){return this._x=M,this._y=p,this._z=b,this._w=Q,this._isDirty=!0,this}set(M,p,b,Q){return this.Db(M,p,b,Q)}sb(M){return this.Db(M,M,M,M)}add(M){return new K(this._x+M._x,this._y+M._y,this._z+M._z,this._w+M._w)}addInPlace(M){return this._x+=M._x,this._y+=M._y,this._z+=M._z,this._w+=M._w,this._isDirty=!0,this}addToRef(M,p){return p._x=this._x+M._x,p._y=this._y+M._y,p._z=this._z+M._z,p._w=this._w+M._w,p._isDirty=!0,p}addInPlaceFromFloats(M,p,b,Q){return this._x+=M,this._y+=p,this._z+=b,this._w+=Q,this._isDirty=!0,this}subtractToRef(M,p){return p._x=this._x-M._x,p._y=this._y-M._y,p._z=this._z-M._z,p._w=this._w-M._w,p._isDirty=!0,p}subtractFromFloats(M,p,b,Q){return this.subtractFromFloatsToRef(M,p,b,Q,new K)}subtractFromFloatsToRef(M,p,b,Q,q){return q._x=this._x-M,q._y=this._y-p,q._z=this._z-b,q._w=this._w-Q,q._isDirty=!0,q}jp(M){return new K(this._x-M._x,this._y-M._y,this._z-M._z,this._w-M._w)}TF(M){return this._x-=M._x,this._y-=M._y,this._z-=M._z,this._w-=M._w,this._isDirty=!0,this}scale(M){return new K(this._x*M,this._y*M,this._z*M,this._w*M)}scaleToRef(M,p){return p._x=this._x*M,p._y=this._y*M,p._z=this._z*M,p._w=this._w*M,p._isDirty=!0,p}scaleInPlace(M){return this._x*=M,this._y*=M,this._z*=M,this._w*=M,this._isDirty=!0,this}scaleAndAddToRef(M,p){return p._x+=this._x*M,p._y+=this._y*M,p._z+=this._z*M,p._w+=this._w*M,p._isDirty=!0,p}multiply(M){const p=new K(0,0,0,1);return this.multiplyToRef(M,p),p}multiplyToRef(M,p){const b=this._x*M._w+this._y*M._z-this._z*M._y+this._w*M._x,Q=-this._x*M._z+this._y*M._w+this._z*M._x+this._w*M._y,q=this._x*M._y-this._y*M._x+this._z*M._w+this._w*M._z,B=-this._x*M._x-this._y*M._y-this._z*M._z+this._w*M._w;return p.Db(b,Q,q,B),p}multiplyInPlace(M){return this.multiplyToRef(M,this)}multiplyByFloats(M,p,b,Q){return this._x*=M,this._y*=p,this._z*=b,this._w*=Q,this._isDirty=!0,this}divide(M){throw new ReferenceError("Can not divide a quaternion")}divideToRef(M,p){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(M){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new K)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(M){return M._x=-this._x,M._y=-this._y,M._z=-this._z,M._w=-this._w,M._isDirty=!0,M}equalsToFloats(M,p,b,Q){return this._x===M&&this._y===p&&this._z===b&&this._w===Q}floorToRef(M){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(M){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(M){return M.Db(-this._x,-this._y,-this._z,this._w),M}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new K(-this._x,-this._y,-this._z,this._w)}invert(){const M=this.conjugate(),p=this.lengthSquared();return 0==p||1==p||M.scaleInPlace(1/p),M}invertInPlace(){this.conjugateInPlace();const M=this.lengthSquared();return 0==M||1==M||this.scaleInPlace(1/M),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){const M=new K(0,0,0,1);return this.normalizeToRef(M),M}normalizeToRef(M){const p=this.length();return 0===p||1===p?M.Db(this._x,this._y,this._z,this._w):this.scaleToRef(1/p,M)}toEulerAngles(){const M=A.Zero();return this.toEulerAnglesToRef(M),M}toEulerAnglesToRef(M){const p=this._z,b=this._x,Q=this._y,q=this._w,B=Q*p-b*q,k=.4999999;if(B<-k)M._y=2*Math.atan2(Q,q),M._x=Math.PI/2,M._z=0,M._isDirty=!0;else if(B>k)M._y=2*Math.atan2(Q,q),M._x=-Math.PI/2,M._z=0,M._isDirty=!0;else{const k=q*q,u=p*p,T=b*b,O=Q*Q;M._z=Math.atan2(2*(b*Q+p*q),-u-T+O+k),M._x=Math.asin(-2*B),M._y=Math.atan2(2*(p*b+Q*q),u-T-O+k),M._isDirty=!0}return M}toAlphaBetaGammaToRef(M){const p=this._z,b=this._x,Q=this._y,q=this._w,B=Math.sqrt(b*b+Q*Q),k=Math.sqrt(p*p+q*q),u=2*Math.atan2(B,k),T=2*Math.atan2(p,q),O=2*Math.atan2(Q,b),H=(T+O)/2,F=(T-O)/2;return M.set(F,u,H),M}toRotationMatrix(M){return D.FromQuaternionToRef(this,M),M}fromRotationMatrix(M){return K.FromRotationMatrixToRef(M,this),this}dot(M){return this._x*M._x+this._y*M._y+this._z*M._z+this._w*M._w}toAxisAngle(){const M=A.Zero();return{axis:M,angle:this.toAxisAngleToRef(M)}}toAxisAngleToRef(M){let p=0;const b=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),Q=this._w;return b>0?(p=2*Math.atan2(b,Q),M.set(this._x/b,this._y/b,this._z/b)):(p=0,M.set(1,0,0)),p}static FromRotationMatrix(M){const p=new K;return K.FromRotationMatrixToRef(M,p),p}static FromRotationMatrixToRef(M,p){const b=M.m,Q=b[0],q=b[4],B=b[8],k=b[1],u=b[5],T=b[9],O=b[2],H=b[6],F=b[10],o=Q+u+F;let W;return o>0?(W=.5/Math.sqrt(o+1),p._w=.25/W,p._x=(H-T)*W,p._y=(B-O)*W,p._z=(k-q)*W,p._isDirty=!0):Q>u&&Q>F?(W=2*Math.sqrt(1+Q-u-F),p._w=(H-T)/W,p._x=.25*W,p._y=(q+k)/W,p._z=(B+O)/W,p._isDirty=!0):u>F?(W=2*Math.sqrt(1+u-Q-F),p._w=(B-O)/W,p._x=(q+k)/W,p._y=.25*W,p._z=(T+H)/W,p._isDirty=!0):(W=2*Math.sqrt(1+F-Q-u),p._w=(k-q)/W,p._x=(B+O)/W,p._y=(T+H)/W,p._z=.25*W,p._isDirty=!0),p}static Dot(M,p){return M._x*p._x+M._y*p._y+M._z*p._z+M._w*p._w}static AreClose(M,p){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const Q=K.Dot(M,p);return 1-Q*Q<=b}static SmoothToRef(M,p,b,Q,q){let B=0===Q?1:b/Q;return B=(0,T.Clamp)(B,0,1),K.SlerpToRef(M,p,B,q),q}static Zero(){return new K(0,0,0,0)}static Inverse(M){return new K(-M._x,-M._y,-M._z,M._w)}static InverseToRef(M,p){return p.set(-M._x,-M._y,-M._z,M._w),p}static Identity(){return new K(0,0,0,1)}static IsIdentity(M){return M&&0===M._x&&0===M._y&&0===M._z&&1===M._w}static RotationAxis(M,p){return K.RotationAxisToRef(M,p,new K)}static RotationAxisToRef(M,p,b){b._w=Math.cos(p/2);const Q=Math.sin(p/2)/M.length();return b._x=M._x*Q,b._y=M._y*Q,b._z=M._z*Q,b._isDirty=!0,b}static sp(M,p){return p||(p=0),new K(M[p],M[p+1],M[p+2],M[p+3])}static FromArrayToRef(M,p,b){return b._x=M[p],b._y=M[p+1],b._z=M[p+2],b._w=M[p+3],b._isDirty=!0,b}static FromFloatsToRef(M,p,b,Q,q){return q.Db(M,p,b,Q),q}static FromEulerAngles(M,p,b){const Q=new K;return K.RotationYawPitchRollToRef(p,M,b,Q),Q}static FromEulerAnglesToRef(M,p,b,Q){return K.RotationYawPitchRollToRef(p,M,b,Q),Q}static FromEulerVector(M){const p=new K;return K.RotationYawPitchRollToRef(M._y,M._x,M._z,p),p}static FromEulerVectorToRef(M,p){return K.RotationYawPitchRollToRef(M._y,M._x,M._z,p),p}static FromUnitVectorsToRef(M,p,b){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Q.d;const B=A.Dot(M,p)+1;return B<q?Math.abs(M.x)>Math.abs(M.z)?b.set(-M.y,M.x,0,0):b.set(0,-M.z,M.y,0):(A.CrossToRef(M,p,s.Ap[0]),b.set(s.Ap[0].x,s.Ap[0].y,s.Ap[0].z,B)),b.normalize()}static RotationYawPitchRoll(M,p,b){const Q=new K;return K.RotationYawPitchRollToRef(M,p,b,Q),Q}static RotationYawPitchRollToRef(M,p,b,Q){const q=.5*b,B=.5*p,k=.5*M,u=Math.sin(q),T=Math.cos(q),O=Math.sin(B),H=Math.cos(B),F=Math.sin(k),o=Math.cos(k);return Q._x=o*O*T+F*H*u,Q._y=F*H*T-o*O*u,Q._z=o*H*u-F*O*T,Q._w=o*H*T+F*O*u,Q._isDirty=!0,Q}static RotationAlphaBetaGamma(M,p,b){const Q=new K;return K.RotationAlphaBetaGammaToRef(M,p,b,Q),Q}static RotationAlphaBetaGammaToRef(M,p,b,Q){const q=.5*(b+M),B=.5*(b-M),k=.5*p;return Q._x=Math.cos(B)*Math.sin(k),Q._y=Math.sin(B)*Math.sin(k),Q._z=Math.sin(q)*Math.cos(k),Q._w=Math.cos(q)*Math.cos(k),Q._isDirty=!0,Q}static RotationQuaternionFromAxis(M,p,b){const Q=new K(0,0,0,0);return K.RotationQuaternionFromAxisToRef(M,p,b,Q),Q}static RotationQuaternionFromAxisToRef(M,p,b,Q){const q=a.Matrix[0];return M=M.normalizeToRef(a.Ap[0]),p=p.normalizeToRef(a.Ap[1]),b=b.normalizeToRef(a.Ap[2]),D.FromXYZAxesToRef(M,p,b,q),K.FromRotationMatrixToRef(q,Q),Q}static FromLookDirectionLH(M,p){const b=new K;return K.FromLookDirectionLHToRef(M,p,b),b}static FromLookDirectionLHToRef(M,p,b){const Q=a.Matrix[0];return D.LookDirectionLHToRef(M,p,Q),K.FromRotationMatrixToRef(Q,b),b}static FromLookDirectionRH(M,p){const b=new K;return K.FromLookDirectionRHToRef(M,p,b),b}static FromLookDirectionRHToRef(M,p,b){const Q=a.Matrix[0];return D.LookDirectionRHToRef(M,p,Q),K.FromRotationMatrixToRef(Q,b)}static Slerp(M,p,b){const Q=K.Identity();return K.SlerpToRef(M,p,b,Q),Q}static SlerpToRef(M,p,b,Q){let q,B,k=M._x*p._x+M._y*p._y+M._z*p._z+M._w*p._w,u=!1;if(k<0&&(u=!0,k=-k),k>.999999)B=1-b,q=u?-b:b;else{const M=Math.acos(k),p=1/Math.sin(M);B=Math.sin((1-b)*M)*p,q=u?-Math.sin(b*M)*p:Math.sin(b*M)*p}return Q._x=B*M._x+q*p._x,Q._y=B*M._y+q*p._y,Q._z=B*M._z+q*p._z,Q._w=B*M._w+q*p._w,Q._isDirty=!0,Q}static Hermite(M,p,b,Q,q){const B=q*q,k=q*B,u=2*k-3*B+1,T=-2*k+3*B,O=k-2*B+q,H=k-B,F=M._x*u+b._x*T+p._x*O+Q._x*H,o=M._y*u+b._y*T+p._y*O+Q._y*H,W=M._z*u+b._z*T+p._z*O+Q._z*H,i=M._w*u+b._w*T+p._w*O+Q._w*H;return new K(F,o,W,i)}static Hermite1stDerivative(M,p,b,Q,q){const B=new K;return this.Hermite1stDerivativeToRef(M,p,b,Q,q,B),B}static Hermite1stDerivativeToRef(M,p,b,Q,q,B){const k=q*q;return B._x=6*(k-q)*M._x+(3*k-4*q+1)*p._x+6*(-k+q)*b._x+(3*k-2*q)*Q._x,B._y=6*(k-q)*M._y+(3*k-4*q+1)*p._y+6*(-k+q)*b._y+(3*k-2*q)*Q._y,B._z=6*(k-q)*M._z+(3*k-4*q+1)*p._z+6*(-k+q)*b._z+(3*k-2*q)*Q._z,B._w=6*(k-q)*M._w+(3*k-4*q+1)*p._w+6*(-k+q)*b._w+(3*k-2*q)*Q._w,B._isDirty=!0,B}static Normalize(M){const p=K.Zero();return K.NormalizeToRef(M,p),p}static NormalizeToRef(M,p){return M.normalizeToRef(p),p}static Clamp(M,p,b){const Q=new K;return K.ClampToRef(M,p,b,Q),Q}static ClampToRef(M,p,b,Q){return Q.Db((0,T.Clamp)(M.x,p.x,b.x),(0,T.Clamp)(M.y,p.y,b.y),(0,T.Clamp)(M.z,p.z,b.z),(0,T.Clamp)(M.w,p.w,b.w))}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new K((0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Db((0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p),(0,T.RandomRange)(M,p))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(M,p){return Math.sqrt(K.DistanceSquared(M,p))}static DistanceSquared(M,p){const b=M.x-p.x,Q=M.y-p.y,q=M.z-p.z,B=M.w-p.w;return b*b+Q*Q+q*q+B*B}static Center(M,p){return K.CenterToRef(M,p,K.Zero())}static CenterToRef(M,p,b){return b.Db((M.x+p.x)/2,(M.y+p.y)/2,(M.z+p.z)/2,(M.w+p.w)/2)}}K._V8PerformanceHack=new K(.5,.5,.5,.5),Object.defineProperties(K.prototype,{dimension:{value:[4]},rank:{value:1}});class D{static get Use64Bits(){return k.d.MatrixUse64Bits}get m(){return this.Qb}markAsUpdated(){this.updateFlag=O._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(M){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=M,this._isIdentity3x2=M||b,this._isIdentityDirty=!this._isIdentity&&p,this._isIdentity3x2Dirty=!this._isIdentity3x2&&Q}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,k.d.MatrixTrackPrecisionChange&&k.d.MatrixTrackedMatrices.push(this),this.Qb=new k.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const M=this.Qb;this._isIdentity=1===M[0]&&0===M[1]&&0===M[2]&&0===M[3]&&0===M[4]&&1===M[5]&&0===M[6]&&0===M[7]&&0===M[8]&&0===M[9]&&1===M[10]&&0===M[11]&&0===M[12]&&0===M[13]&&0===M[14]&&1===M[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Qb[0]||1!==this.Qb[5]||1!==this.Qb[15]||0!==this.Qb[1]||0!==this.Qb[2]||0!==this.Qb[3]||0!==this.Qb[4]||0!==this.Qb[6]||0!==this.Qb[7]||0!==this.Qb[8]||0!==this.Qb[9]||0!==this.Qb[10]||0!==this.Qb[11]||0!==this.Qb[12]||0!==this.Qb[13]||0!==this.Qb[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const M=this.Qb,p=M[0],b=M[1],Q=M[2],q=M[3],B=M[4],k=M[5],u=M[6],T=M[7],O=M[8],H=M[9],F=M[10],o=M[11],W=M[12],i=M[13],A=M[14],j=M[15],K=F*j-A*o,D=H*j-i*o,a=H*A-i*F,s=O*j-W*o,S=O*A-F*W,f=O*i-W*H;return p*+(k*K-u*D+T*a)+b*-(B*K-u*s+T*S)+Q*+(B*D-k*s+T*f)+q*-(B*a-k*S+u*f)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!M)return this.Qb;const b=this.Qb;for(let Q=0;Q<16;Q++)M[p+Q]=b[Q];return this}Ob(){return this.Qb}oQ(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D.FromArrayToRef(M,p,this)}Db(){for(var M=arguments.length,p=new Array(M),b=0;b<M;b++)p[b]=arguments[b];return D.FromArrayToRef(p,0,this)}set(){const M=this.Qb;for(let p=0;p<16;p++)M[p]=p<0||arguments.length<=p?void 0:arguments[p];return this.markAsUpdated(),this}sb(M){const p=this.Qb;for(let b=0;b<16;b++)p[b]=M;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return D.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(M){const p=new D;return this.addToRef(M,p),p}addToRef(M,p){const b=this.Qb,Q=p.Qb,q=M.m;for(let B=0;B<16;B++)Q[B]=b[B]+q[B];return p.markAsUpdated(),p}addToSelf(M){const p=this.Qb,b=M.m;return p[0]+=b[0],p[1]+=b[1],p[2]+=b[2],p[3]+=b[3],p[4]+=b[4],p[5]+=b[5],p[6]+=b[6],p[7]+=b[7],p[8]+=b[8],p[9]+=b[9],p[10]+=b[10],p[11]+=b[11],p[12]+=b[12],p[13]+=b[13],p[14]+=b[14],p[15]+=b[15],this.markAsUpdated(),this}addInPlace(M){const p=this.Qb,b=M.m;for(let Q=0;Q<16;Q++)p[Q]+=b[Q];return this.markAsUpdated(),this}addInPlaceFromFloats(){const M=this.Qb;for(let p=0;p<16;p++)M[p]+=p<0||arguments.length<=p?void 0:arguments[p];return this.markAsUpdated(),this}jp(M){const p=this.Qb,b=M.m;for(let Q=0;Q<16;Q++)p[Q]-=b[Q];return this.markAsUpdated(),this}subtractToRef(M,p){const b=this.Qb,Q=M.m,q=p.Qb;for(let B=0;B<16;B++)q[B]=b[B]-Q[B];return p.markAsUpdated(),p}TF(M){const p=this.Qb,b=M.m;for(let Q=0;Q<16;Q++)p[Q]-=b[Q];return this.markAsUpdated(),this}subtractFromFloats(){for(var M=arguments.length,p=new Array(M),b=0;b<M;b++)p[b]=arguments[b];return this.subtractFromFloatsToRef(...p,new D)}subtractFromFloatsToRef(){for(var M=arguments.length,p=new Array(M),b=0;b<M;b++)p[b]=arguments[b];const Q=p.pop(),q=this.Qb,B=Q.Qb,k=p;for(let u=0;u<16;u++)B[u]=q[u]-k[u];return Q.markAsUpdated(),Q}invertToRef(M){return!0===this._isIdentity?(D.IdentityToRef(M),M):(o(this,M.Ob())?M.markAsUpdated():M.B(this),M)}addAtIndex(M,p){return this.Qb[M]+=p,this.markAsUpdated(),this}multiplyAtIndex(M,p){return this.Qb[M]*=p,this.markAsUpdated(),this}setTranslationFromFloats(M,p,b){return this.Qb[12]=M,this.Qb[13]=p,this.Qb[14]=b,this.markAsUpdated(),this}addTranslationFromFloats(M,p,b){return this.Qb[12]+=M,this.Qb[13]+=p,this.Qb[14]+=b,this.markAsUpdated(),this}setTranslation(M){return this.setTranslationFromFloats(M._x,M._y,M._z)}getTranslation(){return new A(this.Qb[12],this.Qb[13],this.Qb[14])}getTranslationToRef(M){return M.x=this.Qb[12],M.y=this.Qb[13],M.z=this.Qb[14],M}removeRotationAndScaling(){const M=this.m;return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,M[12],M[13],M[14],M[15],this),this._updateIdentityStatus(0===M[12]&&0===M[13]&&0===M[14]&&1===M[15]),this}B(M){M.copyToArray(this.Qb);const p=M;return this.updateFlag=p.updateFlag,this._updateIdentityStatus(p._isIdentity,p._isIdentityDirty,p._isIdentity3x2,p._isIdentity3x2Dirty),this}copyToArray(M){return F(this,M,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(M){const p=new D;return this.multiplyToRef(M,p),p}multiplyInPlace(M){const p=this.Qb,b=M.m;for(let Q=0;Q<16;Q++)p[Q]*=b[Q];return this.markAsUpdated(),this}multiplyByFloats(){const M=this.Qb;for(let p=0;p<16;p++)M[p]*=p<0||arguments.length<=p?void 0:arguments[p];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var M=arguments.length,p=new Array(M),b=0;b<M;b++)p[b]=arguments[b];const Q=p.pop(),q=this.Qb,B=Q.Qb,k=p;for(let u=0;u<16;u++)B[u]=q[u]*k[u];return Q.markAsUpdated(),Q}multiplyToRef(M,p){return this._isIdentity?(p.B(M),p):M._isIdentity?(p.B(this),p):(this.multiplyToArray(M,p.Qb,0),p.markAsUpdated(),p)}multiplyToArray(M,p,b){return H(this,M,p,b),this}divide(M){return this.divideToRef(M,new D)}divideToRef(M,p){const b=this.Qb,Q=M.m,q=p.Qb;for(let B=0;B<16;B++)q[B]=b[B]/Q[B];return p.markAsUpdated(),p}divideInPlace(M){const p=this.Qb,b=M.m;for(let Q=0;Q<16;Q++)p[Q]/=b[Q];return this.markAsUpdated(),this}minimizeInPlace(M){const p=this.Qb,b=M.m;for(let Q=0;Q<16;Q++)p[Q]=Math.min(p[Q],b[Q]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const M=this.Qb;for(let p=0;p<16;p++)M[p]=Math.min(M[p],p<0||arguments.length<=p?void 0:arguments[p]);return this.markAsUpdated(),this}maximizeInPlace(M){const p=this.Qb,b=M.m;for(let Q=0;Q<16;Q++)p[Q]=Math.min(p[Q],b[Q]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const M=this.Qb;for(let p=0;p<16;p++)M[p]=Math.min(M[p],p<0||arguments.length<=p?void 0:arguments[p]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new D)}negateInPlace(){const M=this.Qb;for(let p=0;p<16;p++)M[p]=-M[p];return this.markAsUpdated(),this}negateToRef(M){const p=this.Qb,b=M.Qb;for(let Q=0;Q<16;Q++)b[Q]=-p[Q];return M.markAsUpdated(),M}equals(M){const p=M;if(!p)return!1;if((this._isIdentity||p._isIdentity)&&!this._isIdentityDirty&&!p._isIdentityDirty)return this._isIdentity&&p._isIdentity;const b=this.m,Q=p.m;return b[0]===Q[0]&&b[1]===Q[1]&&b[2]===Q[2]&&b[3]===Q[3]&&b[4]===Q[4]&&b[5]===Q[5]&&b[6]===Q[6]&&b[7]===Q[7]&&b[8]===Q[8]&&b[9]===Q[9]&&b[10]===Q[10]&&b[11]===Q[11]&&b[12]===Q[12]&&b[13]===Q[13]&&b[14]===Q[14]&&b[15]===Q[15]}equalsWithEpsilon(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=this.Qb,Q=M.m;for(let q=0;q<16;q++)if(!(0,T.WithinEpsilon)(b[q],Q[q],p))return!1;return!0}equalsToFloats(){const M=this.Qb;for(let p=0;p<16;p++)if(M[p]!=(p<0||arguments.length<=p?void 0:arguments[p]))return!1;return!0}floor(){return this.floorToRef(new D)}floorToRef(M){const p=this.Qb,b=M.Qb;for(let Q=0;Q<16;Q++)b[Q]=Math.floor(p[Q]);return M.markAsUpdated(),M}fract(){return this.fractToRef(new D)}fractToRef(M){const p=this.Qb,b=M.Qb;for(let Q=0;Q<16;Q++)b[Q]=p[Q]-Math.floor(p[Q]);return M.markAsUpdated(),M}clone(){const M=new D;return M.B(this),M}getClassName(){return"Matrix"}getHashCode(){let M=W(this.Qb[0]);for(let p=1;p<16;p++)M=397*M^W(this.Qb[p]);return M}decomposeToTransformNode(M){return M.rotationQuaternion=M.rotationQuaternion||new K,this.decompose(M.ab,M.rotationQuaternion,M.position)}decompose(M,p,b,Q){let q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return b&&b.sb(0),M&&M.sb(1),p&&p.Db(0,0,0,1),!0;const B=this.Qb;if(b&&b.Db(B[12],B[13],B[14]),(M=M||a.Ap[0]).x=Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]),M.y=Math.sqrt(B[4]*B[4]+B[5]*B[5]+B[6]*B[6]),M.z=Math.sqrt(B[8]*B[8]+B[9]*B[9]+B[10]*B[10]),Q){const p=(q?Q.absoluteScaling.x:Q.ab.x)<0?-1:1,b=(q?Q.absoluteScaling.y:Q.ab.y)<0?-1:1,B=(q?Q.absoluteScaling.z:Q.ab.z)<0?-1:1;M.x*=p,M.y*=b,M.z*=B}else this.determinant()<=0&&(M.y*=-1);if(0===M._x||0===M._y||0===M._z)return p&&p.Db(0,0,0,1),!1;if(p){const b=1/M._x,Q=1/M._y,q=1/M._z;D.FromValuesToRef(B[0]*b,B[1]*b,B[2]*b,0,B[4]*Q,B[5]*Q,B[6]*Q,0,B[8]*q,B[9]*q,B[10]*q,0,0,0,0,1,a.Matrix[0]),K.FromRotationMatrixToRef(a.Matrix[0],p)}return!0}getRow(M){if(M<0||M>3)return null;const p=4*M;return new j(this.Qb[p+0],this.Qb[p+1],this.Qb[p+2],this.Qb[p+3])}getRowToRef(M,p){if(M>=0&&M<=3){const b=4*M;p.x=this.Qb[b+0],p.y=this.Qb[b+1],p.z=this.Qb[b+2],p.w=this.Qb[b+3]}return p}setRow(M,p){return this.setRowFromFloats(M,p.x,p.y,p.z,p.w)}transpose(){const M=new D;return D.TransposeToRef(this,M),M}transposeToRef(M){return D.TransposeToRef(this,M),M}setRowFromFloats(M,p,b,Q,q){if(M<0||M>3)return this;const B=4*M;return this.Qb[B+0]=p,this.Qb[B+1]=b,this.Qb[B+2]=Q,this.Qb[B+3]=q,this.markAsUpdated(),this}scale(M){const p=new D;return this.scaleToRef(M,p),p}scaleToRef(M,p){for(let b=0;b<16;b++)p.Qb[b]=this.Qb[b]*M;return p.markAsUpdated(),p}scaleAndAddToRef(M,p){for(let b=0;b<16;b++)p.Qb[b]+=this.Qb[b]*M;return p.markAsUpdated(),p}scaleInPlace(M){const p=this.Qb;for(let b=0;b<16;b++)p[b]*=M;return this.markAsUpdated(),this}toNormalMatrix(M){const p=a.Matrix[0];this.invertToRef(p),p.transposeToRef(M);const b=M.Qb;return D.FromValuesToRef(b[0],b[1],b[2],0,b[4],b[5],b[6],0,b[8],b[9],b[10],0,0,0,0,1,M),M}getRotationMatrix(){const M=new D;return this.getRotationMatrixToRef(M),M}getRotationMatrixToRef(M){const p=a.Ap[0];if(!this.decompose(p))return D.IdentityToRef(M),M;const b=this.Qb,Q=1/p._x,q=1/p._y,B=1/p._z;return D.FromValuesToRef(b[0]*Q,b[1]*Q,b[2]*Q,0,b[4]*q,b[5]*q,b[6]*q,0,b[8]*B,b[9]*B,b[10]*B,0,0,0,0,1,M),M}toggleModelMatrixHandInPlace(){const M=this.Qb;return M[2]*=-1,M[6]*=-1,M[8]*=-1,M[9]*=-1,M[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const M=this.Qb;return M[8]*=-1,M[9]*=-1,M[10]*=-1,M[11]*=-1,this.markAsUpdated(),this}static sp(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=new D;return D.FromArrayToRef(M,p,b),b}static FromArrayToRef(M,p,b){for(let Q=0;Q<16;Q++)b.Qb[Q]=M[Q+p];return b.markAsUpdated(),b}static FromFloat32ArrayToRefScaled(M,p,b,Q){return Q.Qb[0]=M[0+p]*b,Q.Qb[1]=M[1+p]*b,Q.Qb[2]=M[2+p]*b,Q.Qb[3]=M[3+p]*b,Q.Qb[4]=M[4+p]*b,Q.Qb[5]=M[5+p]*b,Q.Qb[6]=M[6+p]*b,Q.Qb[7]=M[7+p]*b,Q.Qb[8]=M[8+p]*b,Q.Qb[9]=M[9+p]*b,Q.Qb[10]=M[10+p]*b,Q.Qb[11]=M[11+p]*b,Q.Qb[12]=M[12+p]*b,Q.Qb[13]=M[13+p]*b,Q.Qb[14]=M[14+p]*b,Q.Qb[15]=M[15+p]*b,Q.markAsUpdated(),Q}static get IdentityReadOnly(){return D._IdentityReadOnly}static FromValuesToRef(M,p,b,Q,q,B,k,u,T,O,H,F,o,W,i,A,j){const K=j.Qb;K[0]=M,K[1]=p,K[2]=b,K[3]=Q,K[4]=q,K[5]=B,K[6]=k,K[7]=u,K[8]=T,K[9]=O,K[10]=H,K[11]=F,K[12]=o,K[13]=W,K[14]=i,K[15]=A,j.markAsUpdated()}static FromValues(M,p,b,Q,q,B,k,u,T,O,H,F,o,W,i,A){const j=new D,K=j.Qb;return K[0]=M,K[1]=p,K[2]=b,K[3]=Q,K[4]=q,K[5]=B,K[6]=k,K[7]=u,K[8]=T,K[9]=O,K[10]=H,K[11]=F,K[12]=o,K[13]=W,K[14]=i,K[15]=A,j.markAsUpdated(),j}static Compose(M,p,b){const Q=new D;return D.ComposeToRef(M,p,b,Q),Q}static ComposeToRef(M,p,b,Q){const q=Q.Qb,B=p._x,k=p._y,u=p._z,T=p._w,O=B+B,H=k+k,F=u+u,o=B*O,W=B*H,i=B*F,A=k*H,j=k*F,K=u*F,D=T*O,a=T*H,s=T*F,S=M._x,f=M._y,R=M._z;return q[0]=(1-(A+K))*S,q[1]=(W+s)*S,q[2]=(i-a)*S,q[3]=0,q[4]=(W-s)*f,q[5]=(1-(o+K))*f,q[6]=(j+D)*f,q[7]=0,q[8]=(i+a)*R,q[9]=(j-D)*R,q[10]=(1-(o+A))*R,q[11]=0,q[12]=b._x,q[13]=b._y,q[14]=b._z,q[15]=1,Q.markAsUpdated(),Q}static Identity(){const M=D.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return M._updateIdentityStatus(!0),M}static IdentityToRef(M){return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,M),M._updateIdentityStatus(!0),M}static Zero(){const M=D.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return M._updateIdentityStatus(!1),M}static RotationX(M){const p=new D;return D.RotationXToRef(M,p),p}static Invert(M){const p=new D;return M.invertToRef(p),p}static RotationXToRef(M,p){const b=Math.sin(M),Q=Math.cos(M);return D.FromValuesToRef(1,0,0,0,0,Q,b,0,0,-b,Q,0,0,0,0,1,p),p._updateIdentityStatus(1===Q&&0===b),p}static RotationY(M){const p=new D;return D.RotationYToRef(M,p),p}static RotationYToRef(M,p){const b=Math.sin(M),Q=Math.cos(M);return D.FromValuesToRef(Q,0,-b,0,0,1,0,0,b,0,Q,0,0,0,0,1,p),p._updateIdentityStatus(1===Q&&0===b),p}static RotationZ(M){const p=new D;return D.RotationZToRef(M,p),p}static RotationZToRef(M,p){const b=Math.sin(M),Q=Math.cos(M);return D.FromValuesToRef(Q,b,0,0,-b,Q,0,0,0,0,1,0,0,0,0,1,p),p._updateIdentityStatus(1===Q&&0===b),p}static RotationAxis(M,p){const b=new D;return D.RotationAxisToRef(M,p,b),b}static RotationAxisToRef(M,p,b){const Q=Math.sin(-p),q=Math.cos(-p),B=1-q;M=M.normalizeToRef(a.Ap[0]);const k=b.Qb;return k[0]=M._x*M._x*B+q,k[1]=M._x*M._y*B-M._z*Q,k[2]=M._x*M._z*B+M._y*Q,k[3]=0,k[4]=M._y*M._x*B+M._z*Q,k[5]=M._y*M._y*B+q,k[6]=M._y*M._z*B-M._x*Q,k[7]=0,k[8]=M._z*M._x*B-M._y*Q,k[9]=M._z*M._y*B+M._x*Q,k[10]=M._z*M._z*B+q,k[11]=0,k[12]=0,k[13]=0,k[14]=0,k[15]=1,b.markAsUpdated(),b}static RotationAlignToRef(M,p,b){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const B=A.Dot(p,M),k=b.Qb;if(B<-1+Q.d)k[0]=-1,k[1]=0,k[2]=0,k[3]=0,k[4]=0,k[5]=q?1:-1,k[6]=0,k[7]=0,k[8]=0,k[9]=0,k[10]=q?-1:1,k[11]=0;else{const b=A.Cross(p,M),Q=1/(1+B);k[0]=b._x*b._x*Q+B,k[1]=b._y*b._x*Q-b._z,k[2]=b._z*b._x*Q+b._y,k[3]=0,k[4]=b._x*b._y*Q+b._z,k[5]=b._y*b._y*Q+B,k[6]=b._z*b._y*Q-b._x,k[7]=0,k[8]=b._x*b._z*Q-b._y,k[9]=b._y*b._z*Q+b._x,k[10]=b._z*b._z*Q+B,k[11]=0}return k[12]=0,k[13]=0,k[14]=0,k[15]=1,b.markAsUpdated(),b}static RotationYawPitchRoll(M,p,b){const Q=new D;return D.RotationYawPitchRollToRef(M,p,b,Q),Q}static RotationYawPitchRollToRef(M,p,b,Q){return K.RotationYawPitchRollToRef(M,p,b,a.Quaternion[0]),a.Quaternion[0].toRotationMatrix(Q),Q}static Scaling(M,p,b){const Q=new D;return D.ScalingToRef(M,p,b,Q),Q}static ScalingToRef(M,p,b,Q){return D.FromValuesToRef(M,0,0,0,0,p,0,0,0,0,b,0,0,0,0,1,Q),Q._updateIdentityStatus(1===M&&1===p&&1===b),Q}static Translation(M,p,b){const Q=new D;return D.TranslationToRef(M,p,b,Q),Q}static TranslationToRef(M,p,b,Q){return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,M,p,b,1,Q),Q._updateIdentityStatus(0===M&&0===p&&0===b),Q}static Lerp(M,p,b){const Q=new D;return D.LerpToRef(M,p,b,Q),Q}static LerpToRef(M,p,b,Q){const q=Q.Qb,B=M.m,k=p.m;for(let u=0;u<16;u++)q[u]=B[u]*(1-b)+k[u]*b;return Q.markAsUpdated(),Q}static DecomposeLerp(M,p,b){const Q=new D;return D.DecomposeLerpToRef(M,p,b,Q),Q}static DecomposeLerpToRef(M,p,b,Q){const q=a.Ap[0],B=a.Quaternion[0],k=a.Ap[1];M.decompose(q,B,k);const u=a.Ap[2],T=a.Quaternion[1],O=a.Ap[3];p.decompose(u,T,O);const H=a.Ap[4];A.LerpToRef(q,u,b,H);const F=a.Quaternion[2];K.SlerpToRef(B,T,b,F);const o=a.Ap[5];return A.LerpToRef(k,O,b,o),D.ComposeToRef(H,F,o,Q),Q}static LookAtLH(M,p,b){const Q=new D;return D.LookAtLHToRef(M,p,b,Q),Q}static LookAtLHToRef(M,p,b,Q){const q=a.Ap[0],B=a.Ap[1],k=a.Ap[2];p.subtractToRef(M,k),k.normalize(),A.CrossToRef(b,k,q);const u=q.lengthSquared();0===u?q.x=1:q.normalizeFromLength(Math.sqrt(u)),A.CrossToRef(k,q,B),B.normalize();const T=-A.Dot(q,M),O=-A.Dot(B,M),H=-A.Dot(k,M);return D.FromValuesToRef(q._x,B._x,k._x,0,q._y,B._y,k._y,0,q._z,B._z,k._z,0,T,O,H,1,Q),Q}static LookAtRH(M,p,b){const Q=new D;return D.LookAtRHToRef(M,p,b,Q),Q}static LookAtRHToRef(M,p,b,Q){const q=a.Ap[0],B=a.Ap[1],k=a.Ap[2];M.subtractToRef(p,k),k.normalize(),A.CrossToRef(b,k,q);const u=q.lengthSquared();0===u?q.x=1:q.normalizeFromLength(Math.sqrt(u)),A.CrossToRef(k,q,B),B.normalize();const T=-A.Dot(q,M),O=-A.Dot(B,M),H=-A.Dot(k,M);return D.FromValuesToRef(q._x,B._x,k._x,0,q._y,B._y,k._y,0,q._z,B._z,k._z,0,T,O,H,1,Q),Q}static LookDirectionLH(M,p){const b=new D;return D.LookDirectionLHToRef(M,p,b),b}static LookDirectionLHToRef(M,p,b){const Q=a.Ap[0];Q.B(M),Q.scaleInPlace(-1);const q=a.Ap[1];return A.CrossToRef(p,Q,q),D.FromValuesToRef(q._x,q._y,q._z,0,p._x,p._y,p._z,0,Q._x,Q._y,Q._z,0,0,0,0,1,b),b}static LookDirectionRH(M,p){const b=new D;return D.LookDirectionRHToRef(M,p,b),b}static LookDirectionRHToRef(M,p,b){const Q=a.Ap[2];return A.CrossToRef(p,M,Q),D.FromValuesToRef(Q._x,Q._y,Q._z,0,p._x,p._y,p._z,0,M._x,M._y,M._z,0,0,0,0,1,b),b}static OrthoLH(M,p,b,Q,q){const B=new D;return D.OrthoLHToRef(M,p,b,Q,B,q),B}static OrthoLHToRef(M,p,b,Q,q,B){const k=2/M,u=2/p,T=2/(Q-b),O=-(Q+b)/(Q-b);return D.FromValuesToRef(k,0,0,0,0,u,0,0,0,0,T,0,0,0,O,1,q),B&&q.multiplyToRef(S,q),q._updateIdentityStatus(1===k&&1===u&&1===T&&0===O),q}static OrthoOffCenterLH(M,p,b,Q,q,B,k){const u=new D;return D.OrthoOffCenterLHToRef(M,p,b,Q,q,B,u,k),u}static OrthoOffCenterLHToRef(M,p,b,Q,q,B,k,u){const T=2/(p-M),O=2/(Q-b),H=2/(B-q),F=-(B+q)/(B-q),o=(M+p)/(M-p),W=(Q+b)/(b-Q);return D.FromValuesToRef(T,0,0,0,0,O,0,0,0,0,H,0,o,W,F,1,k),u&&k.multiplyToRef(S,k),k.markAsUpdated(),k}static ObliqueOffCenterLHToRef(M,p,b,Q,q,B,k,u,T,O,H){const F=-k*Math.cos(u),o=-k*Math.sin(u);return D.TranslationToRef(0,0,-T,a.Matrix[1]),D.FromValuesToRef(1,0,0,0,0,1,0,0,F,o,1,0,0,0,0,1,a.Matrix[0]),a.Matrix[1].multiplyToRef(a.Matrix[0],a.Matrix[0]),D.TranslationToRef(0,0,T,a.Matrix[1]),a.Matrix[0].multiplyToRef(a.Matrix[1],a.Matrix[0]),D.OrthoOffCenterLHToRef(M,p,b,Q,q,B,O,H),a.Matrix[0].multiplyToRef(O,O),O}static OrthoOffCenterRH(M,p,b,Q,q,B,k){const u=new D;return D.OrthoOffCenterRHToRef(M,p,b,Q,q,B,u,k),u}static OrthoOffCenterRHToRef(M,p,b,Q,q,B,k,u){return D.OrthoOffCenterLHToRef(M,p,b,Q,q,B,k,u),k.Qb[10]*=-1,k}static ObliqueOffCenterRHToRef(M,p,b,Q,q,B,k,u,T,O,H){const F=k*Math.cos(u),o=k*Math.sin(u);return D.TranslationToRef(0,0,T,a.Matrix[1]),D.FromValuesToRef(1,0,0,0,0,1,0,0,F,o,1,0,0,0,0,1,a.Matrix[0]),a.Matrix[1].multiplyToRef(a.Matrix[0],a.Matrix[0]),D.TranslationToRef(0,0,-T,a.Matrix[1]),a.Matrix[0].multiplyToRef(a.Matrix[1],a.Matrix[0]),D.OrthoOffCenterRHToRef(M,p,b,Q,q,B,O,H),a.Matrix[0].multiplyToRef(O,O),O}static PerspectiveLH(M,p,b,Q,q){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const k=new D,u=2*b/M,T=2*b/p,O=(Q+b)/(Q-b),H=-2*Q*b/(Q-b),F=Math.tan(B);return D.FromValuesToRef(u,0,0,0,0,T,0,F,0,0,O,1,0,0,H,0,k),q&&k.multiplyToRef(S,k),k._updateIdentityStatus(!1),k}static PerspectiveFovLH(M,p,b,Q,q){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,k=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const u=new D;return D.PerspectiveFovLHToRef(M,p,b,Q,u,!0,q,B,k),u}static PerspectiveFovLHToRef(M,p,b,Q,q){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,T=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const O=b,H=Q,F=1/Math.tan(.5*M),o=B?F/p:F,W=B?F:F*p,i=T&&0===O?-1:0!==H?(H+O)/(H-O):1,A=T&&0===O?2*H:0!==H?-2*H*O/(H-O):-2*O,j=Math.tan(u);return D.FromValuesToRef(o,0,0,0,0,W,0,j,0,0,i,1,0,0,A,0,q),k&&q.multiplyToRef(S,q),q._updateIdentityStatus(!1),q}static PerspectiveFovReverseLHToRef(M,p,b,Q,q){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const T=1/Math.tan(.5*M),O=B?T/p:T,H=B?T:T*p,F=Math.tan(u);return D.FromValuesToRef(O,0,0,0,0,H,0,F,0,0,-b,1,0,0,1,0,q),k&&q.multiplyToRef(S,q),q._updateIdentityStatus(!1),q}static PerspectiveFovRH(M,p,b,Q,q){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,k=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const u=new D;return D.PerspectiveFovRHToRef(M,p,b,Q,u,!0,q,B,k),u}static PerspectiveFovRHToRef(M,p,b,Q,q){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,T=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const O=b,H=Q,F=1/Math.tan(.5*M),o=B?F/p:F,W=B?F:F*p,i=T&&0===O?1:0!==H?-(H+O)/(H-O):-1,A=T&&0===O?2*H:0!==H?-2*H*O/(H-O):-2*O,j=Math.tan(u);return D.FromValuesToRef(o,0,0,0,0,W,0,j,0,0,i,-1,0,0,A,0,q),k&&q.multiplyToRef(S,q),q._updateIdentityStatus(!1),q}static PerspectiveFovReverseRHToRef(M,p,b,Q,q){let B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],k=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const T=1/Math.tan(.5*M),O=B?T/p:T,H=B?T:T*p,F=Math.tan(u);return D.FromValuesToRef(O,0,0,0,0,H,0,F,0,0,-b,-1,0,0,-1,0,q),k&&q.multiplyToRef(S,q),q._updateIdentityStatus(!1),q}static GetFinalMatrix(M,p,b,Q,q,B){const k=M.width,u=M.height,T=M.x,O=M.y,H=D.FromValues(k/2,0,0,0,0,-u/2,0,0,0,0,B-q,0,T+k/2,u/2+O,q,1),F=new D;return p.multiplyToRef(b,F),F.multiplyToRef(Q,F),F.multiplyToRef(H,F)}static GetAsMatrix2x2(M){const p=M.m,b=[p[0],p[1],p[4],p[5]];return k.d.MatrixUse64Bits?b:new Float32Array(b)}static GetAsMatrix3x3(M){const p=M.m,b=[p[0],p[1],p[2],p[4],p[5],p[6],p[8],p[9],p[10]];return k.d.MatrixUse64Bits?b:new Float32Array(b)}static Transpose(M){const p=new D;return D.TransposeToRef(M,p),p}static TransposeToRef(M,p){const b=M.m,Q=b[0],q=b[4],B=b[8],k=b[12],u=b[1],T=b[5],O=b[9],H=b[13],F=b[2],o=b[6],W=b[10],i=b[14],A=b[3],j=b[7],K=b[11],D=b[15],a=p.Qb;return a[0]=Q,a[1]=q,a[2]=B,a[3]=k,a[4]=u,a[5]=T,a[6]=O,a[7]=H,a[8]=F,a[9]=o,a[10]=W,a[11]=i,a[12]=A,a[13]=j,a[14]=K,a[15]=D,p.markAsUpdated(),p._updateIdentityStatus(M._isIdentity,M._isIdentityDirty),p}static Reflection(M){const p=new D;return D.ReflectionToRef(M,p),p}static ReflectionToRef(M,p){M.normalize();const b=M.normal.x,Q=M.normal.y,q=M.normal.z,B=-2*b,k=-2*Q,u=-2*q;return D.FromValuesToRef(B*b+1,k*b,u*b,0,B*Q,k*Q+1,u*Q,0,B*q,k*q,u*q+1,0,B*M.d,k*M.d,u*M.d,1,p),p}static FromXYZAxesToRef(M,p,b,Q){return D.FromValuesToRef(M._x,M._y,M._z,0,p._x,p._y,p._z,0,b._x,b._y,b._z,0,0,0,0,1,Q),Q}static FromQuaternionToRef(M,p){const b=M._x*M._x,Q=M._y*M._y,q=M._z*M._z,B=M._x*M._y,k=M._z*M._w,u=M._z*M._x,T=M._y*M._w,O=M._y*M._z,H=M._x*M._w;return p.Qb[0]=1-2*(Q+q),p.Qb[1]=2*(B+k),p.Qb[2]=2*(u-T),p.Qb[3]=0,p.Qb[4]=2*(B-k),p.Qb[5]=1-2*(q+b),p.Qb[6]=2*(O+H),p.Qb[7]=0,p.Qb[8]=2*(u+T),p.Qb[9]=2*(O-H),p.Qb[10]=1-2*(Q+b),p.Qb[11]=0,p.Qb[12]=0,p.Qb[13]=0,p.Qb[14]=0,p.Qb[15]=1,p.markAsUpdated(),p}}D._IdentityReadOnly=D.Identity(),Object.defineProperties(D.prototype,{dimension:{value:[4,4]},rank:{value:2}});class a{}a.Ap=(0,q.f)(11,A.Zero),a.Matrix=(0,q.f)(2,D.Identity),a.Quaternion=(0,q.f)(3,K.Zero);class s{}s.Vector2=(0,q.f)(3,i.Zero),s.Ap=(0,q.f)(13,A.Zero),s.Vector4=(0,q.f)(3,j.Zero),s.Quaternion=(0,q.f)(3,K.Zero),s.Matrix=(0,q.f)(8,D.Identity),(0,B.g)("BABYLON.Vector2",i),(0,B.g)("BABYLON.Vector3",A),(0,B.g)("BABYLON.Vector4",j),(0,B.g)("BABYLON.Matrix",D);const S=D.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11800:(M,p,b)=>{function Q(M,p){const b=[];for(let Q=0;Q<M;++Q)b.push(p());return b}function q(M,p){return Q(M,p)}b.d(p,{e:()=>Q,f:()=>q,g:()=>k});const B=["push","splice","pop","shift","unshift"];function k(M,p){const b=B.map((b=>function(M,p,b){const Q=M[p];if("function"!==typeof Q)return null;const q=function(){const Q=M.length,B=q.previous.apply(M,arguments);return b(p,Q),B};return Q.next=q,q.previous=Q,M[p]=q,()=>{const b=q.previous;if(!b)return;const Q=q.next;Q?(b.next=Q,Q.previous=b):(b.next=void 0,M[p]=b),q.next=void 0,q.previous=void 0}}(M,b,p)));return()=>{for(const M of b)null===M||void 0===M||M()}}}}]);