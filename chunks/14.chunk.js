"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{11188:(Z,x,F)=>{F.d(x,{e:()=>Y,h:()=>f,j:()=>u,l:()=>G});const u=1/2.2,G=2.2,f=(1+Math.sqrt(5))/2,Y=.001},11194:(Z,x,F)=>{function u(Z){return parseInt(Z.toString().replace(/\W/g,""))}function G(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Z-x)<=F}function f(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Z<x-u||Z>F+u}function Y(Z,x){return Z===x?Z:Math.random()*(x-Z)+Z}function j(Z,x,F){return Z+(x-Z)*F}function d(Z,x,F){let u=k(x-Z,360);return u>180&&(u-=360),Z+u*s(F)}function t(Z,x,F){let u=0;return u=Z!=x?s((F-Z)/(x-Z)):0,u}function o(Z,x,F,u,G){const f=G*G,Y=G*f;return Z*(2*Y-3*f+1)+F*(-2*Y+3*f)+x*(Y-2*f+G)+u*(Y-f)}function c(Z,x,F,u,G){const f=G*G;return 6*(f-G)*Z+(3*f-4*G+1)*x+6*(-f+G)*F+(3*f-2*G)*u}function s(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(F,Math.max(x,Z))}function J(Z){return Z-=2*Math.PI*Math.floor((Z+Math.PI)/(2*Math.PI))}function p(Z){const x=Z.toString(16);return Z<=15?("0"+x).toUpperCase():x.toUpperCase()}function U(Z){if(Math.log2)return Math.floor(Math.log2(Z));if(Z<0)return NaN;if(0===Z)return-1/0;let x=0;if(Z<1){for(;Z<1;)x++,Z*=2;x=-x}else if(Z>1)for(;Z>1;)x++,Z=Math.floor(Z/2);return x}function k(Z,x){return Z-Math.floor(Z/x)*x}function M(Z,x,F){return(Z-x)/(F-x)}function m(Z,x,F){return Z*(F-x)+x}function C(Z,x){let F=k(x-Z,360);return F>180&&(F-=360),F}function L(Z,x){const F=k(Z,2*x);return x-Math.abs(F-x)}function H(Z,x,F){let u=s(F);return u=-2*u*u*u+3*u*u,x*u+Z*(1-u)}function S(Z,x,F){let u=0;return u=Math.abs(x-Z)<=F?x:Z+Math.sign(x-Z)*F,u}function K(Z,x,F){const u=C(Z,x);let G=0;return G=-F<u&&u<F?x:S(Z,x=Z+u,F),G}function y(Z,x,F){return(Z-x)/(F-x)}function q(Z,x,F){return(F-x)*Z+x}function R(Z,x){const F=Z%x;return 0===F?x:R(x,F)}F.r(x),F.d(x,{Clamp:()=>s,DeltaAngle:()=>C,Denormalize:()=>m,ExtractAsInt:()=>u,Hermite:()=>o,Hermite1stDerivative:()=>c,HighestCommonFactor:()=>R,ILog2:()=>U,InverseLerp:()=>t,Lerp:()=>j,LerpAngle:()=>d,MoveTowards:()=>S,MoveTowardsAngle:()=>K,Normalize:()=>M,NormalizeRadians:()=>J,OutsideRange:()=>f,PercentToRange:()=>q,PingPong:()=>L,RandomRange:()=>Y,RangeToPercent:()=>y,Repeat:()=>k,SmoothStep:()=>H,ToHex:()=>p,WithinEpsilon:()=>G})},11179:(Z,x,F)=>{F.r(x),F.d(x,{Matrix:()=>m,Quaternion:()=>M,TmpVectors:()=>L,Vector2:()=>p,kx:()=>U,Vector4:()=>k});var u=F(11188),G=F(11192),f=F(11136),Y=F(11110),j=F(11037),d=F(11194);class t{}function o(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const G=Z.Wf(),f=x.Wf(),Y=G[0],j=G[1],d=G[2],t=G[3],o=G[4],c=G[5],s=G[6],J=G[7],p=G[8],U=G[9],k=G[10],M=G[11],m=G[12],C=G[13],L=G[14],H=G[15],S=f[0],K=f[1],y=f[2],q=f[3],R=f[4],B=f[5],v=f[6],l=f[7],i=f[8],e=f[9],b=f[10],E=f[11],w=f[12],T=f[13],N=f[14],W=f[15];F[u]=Y*S+j*R+d*i+t*w,F[u+1]=Y*K+j*B+d*e+t*T,F[u+2]=Y*y+j*v+d*b+t*N,F[u+3]=Y*q+j*l+d*E+t*W,F[u+4]=o*S+c*R+s*i+J*w,F[u+5]=o*K+c*B+s*e+J*T,F[u+6]=o*y+c*v+s*b+J*N,F[u+7]=o*q+c*l+s*E+J*W,F[u+8]=p*S+U*R+k*i+M*w,F[u+9]=p*K+U*B+k*e+M*T,F[u+10]=p*y+U*v+k*b+M*N,F[u+11]=p*q+U*l+k*E+M*W,F[u+12]=m*S+C*R+L*i+H*w,F[u+13]=m*K+C*B+L*e+H*T,F[u+14]=m*y+C*v+L*b+H*N,F[u+15]=m*q+C*l+L*E+H*W}function c(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const u=Z.Wf();x[F]=u[0],x[F+1]=u[1],x[F+2]=u[2],x[F+3]=u[3],x[F+4]=u[4],x[F+5]=u[5],x[F+6]=u[6],x[F+7]=u[7],x[F+8]=u[8],x[F+9]=u[9],x[F+10]=u[10],x[F+11]=u[11],x[F+12]=u[12],x[F+13]=u[13],x[F+14]=u[14],x[F+15]=u[15]}function s(Z,x){const F=Z.Wf(),u=F[0],G=F[1],f=F[2],Y=F[3],j=F[4],d=F[5],t=F[6],o=F[7],c=F[8],s=F[9],J=F[10],p=F[11],U=F[12],k=F[13],M=F[14],m=F[15],C=J*m-M*p,L=s*m-k*p,H=s*M-k*J,S=c*m-U*p,K=c*M-J*U,y=c*k-U*s,q=+(d*C-t*L+o*H),R=-(j*C-t*S+o*K),B=+(j*L-d*S+o*y),v=-(j*H-d*K+t*y),l=u*q+G*R+f*B+Y*v;if(0===l)return!1;const i=1/l,e=t*m-M*o,b=d*m-k*o,E=d*M-k*t,w=j*m-U*o,T=j*M-U*t,N=j*k-U*d,W=t*p-J*o,A=d*p-s*o,h=d*J-s*t,X=j*p-c*o,D=j*J-c*t,Q=j*s-c*d,g=-(G*C-f*L+Y*H),O=+(u*C-f*S+Y*K),n=-(u*L-G*S+Y*y),V=+(u*H-G*K+f*y),a=+(G*e-f*b+Y*E),I=-(u*e-f*w+Y*T),r=+(u*b-G*w+Y*N),z=-(u*E-G*T+f*N),P=-(G*W-f*A+Y*h),ZZ=+(u*W-f*X+Y*D),xZ=-(u*A-G*X+Y*Q),FZ=+(u*h-G*D+f*Q);return x[0]=q*i,x[1]=g*i,x[2]=a*i,x[3]=P*i,x[4]=R*i,x[5]=O*i,x[6]=I*i,x[7]=ZZ*i,x[8]=B*i,x[9]=n*i,x[10]=r*i,x[11]=xZ*i,x[12]=v*i,x[13]=V*i,x[14]=z*i,x[15]=FZ*i,!0}t._UpdateFlagSeed=0;const J=Z=>parseInt(Z.toString().replace(/\W/g,""));class p{constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=Z,this.y=x}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let Z=J(this.x);return Z=397*Z^J(this.y),Z}toArray(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[x]=this.x,Z[x+1]=this.y,this}mF(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p.FromArrayToRef(Z,x,this),this}Wf(){return[this.x,this.y]}G(Z){return this.x=Z.x,this.y=Z.y,this}Jj(Z,x){return this.x=Z,this.y=x,this}set(Z,x){return this.Jj(Z,x)}Uj(Z){return this.Jj(Z,Z)}add(Z){return new p(this.x+Z.x,this.y+Z.y)}addToRef(Z,x){return x.x=this.x+Z.x,x.y=this.y+Z.y,x}addInPlace(Z){return this.x+=Z.x,this.y+=Z.y,this}addInPlaceFromFloats(Z,x){return this.x+=Z,this.y+=x,this}addVector3(Z){return new p(this.x+Z.x,this.y+Z.y)}Mx(Z){return new p(this.x-Z.x,this.y-Z.y)}subtractToRef(Z,x){return x.x=this.x-Z.x,x.y=this.y-Z.y,x}Dc(Z){return this.x-=Z.x,this.y-=Z.y,this}multiplyInPlace(Z){return this.x*=Z.x,this.y*=Z.y,this}multiply(Z){return new p(this.x*Z.x,this.y*Z.y)}multiplyToRef(Z,x){return x.x=this.x*Z.x,x.y=this.y*Z.y,x}multiplyByFloats(Z,x){return new p(this.x*Z,this.y*x)}divide(Z){return new p(this.x/Z.x,this.y/Z.y)}divideToRef(Z,x){return x.x=this.x/Z.x,x.y=this.y/Z.y,x}divideInPlace(Z){return this.x=this.x/Z.x,this.y=this.y/Z.y,this}minimizeInPlace(Z){return this.minimizeInPlaceFromFloats(Z.x,Z.y)}maximizeInPlace(Z){return this.maximizeInPlaceFromFloats(Z.x,Z.y)}minimizeInPlaceFromFloats(Z,x){return this.x=Math.min(Z,this.x),this.y=Math.min(x,this.y),this}maximizeInPlaceFromFloats(Z,x){return this.x=Math.max(Z,this.x),this.y=Math.max(x,this.y),this}subtractFromFloats(Z,x){return new p(this.x-Z,this.y-x)}subtractFromFloatsToRef(Z,x,F){return F.x=this.x-Z,F.y=this.y-x,F}negate(){return new p(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(Z){return Z.x=-this.x,Z.y=-this.y,Z}scaleInPlace(Z){return this.x*=Z,this.y*=Z,this}scale(Z){return new p(this.x*Z,this.y*Z)}scaleToRef(Z,x){return x.x=this.x*Z,x.y=this.y*Z,x}scaleAndAddToRef(Z,x){return x.x+=this.x*Z,x.y+=this.y*Z,x}equals(Z){return Z&&this.x===Z.x&&this.y===Z.y}equalsWithEpsilon(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.e;return Z&&(0,d.WithinEpsilon)(this.x,Z.x,x)&&(0,d.WithinEpsilon)(this.y,Z.y,x)}equalsToFloats(Z,x){return this.x===Z&&this.y===x}floor(){return new p(Math.floor(this.x),Math.floor(this.y))}floorToRef(Z){return Z.x=Math.floor(this.x),Z.y=Math.floor(this.y),Z}fract(){return new p(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(Z){return Z.x=this.x-Math.floor(this.x),Z.y=this.y-Math.floor(this.y),Z}rotate(Z){return this.rotateToRef(Z,new p)}rotateToRef(Z,x){const F=Math.cos(Z),u=Math.sin(Z);return x.x=F*this.x-u*this.y,x.y=u*this.x+F*this.y,x}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){const Z=new p;return this.normalizeToRef(Z),Z}normalizeToRef(Z){const x=this.length();return 0===x&&(Z.x=this.x,Z.y=this.y),this.scaleToRef(1/x,Z)}clone(){return new p(this.x,this.y)}dot(Z){return this.x*Z.x+this.y*Z.y}static Zero(){return new p(0,0)}static One(){return new p(1,1)}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new p((0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Jj((0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x))}static get ZeroReadOnly(){return p._ZeroReadOnly}static Hx(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new p(Z[x],Z[x+1])}static FromArrayToRef(Z,x,F){return F.x=Z[x],F.y=Z[x+1],F}static FromFloatsToRef(Z,x,F){return F.Jj(Z,x),F}static CatmullRom(Z,x,F,u,G){const f=G*G,Y=G*f,j=.5*(2*x.x+(-Z.x+F.x)*G+(2*Z.x-5*x.x+4*F.x-u.x)*f+(-Z.x+3*x.x-3*F.x+u.x)*Y),d=.5*(2*x.y+(-Z.y+F.y)*G+(2*Z.y-5*x.y+4*F.y-u.y)*f+(-Z.y+3*x.y-3*F.y+u.y)*Y);return new p(j,d)}static ClampToRef(Z,x,F,u){return u.x=(0,d.Clamp)(Z.x,x.x,F.x),u.y=(0,d.Clamp)(Z.y,x.y,F.y),u}static Clamp(Z,x,F){const u=(0,d.Clamp)(Z.x,x.x,F.x),G=(0,d.Clamp)(Z.y,x.y,F.y);return new p(u,G)}static Hermite(Z,x,F,u,G){const f=G*G,Y=G*f,j=2*Y-3*f+1,d=-2*Y+3*f,t=Y-2*f+G,o=Y-f,c=Z.x*j+F.x*d+x.x*t+u.x*o,s=Z.y*j+F.y*d+x.y*t+u.y*o;return new p(c,s)}static Hermite1stDerivative(Z,x,F,u,G){return this.Hermite1stDerivativeToRef(Z,x,F,u,G,new p)}static Hermite1stDerivativeToRef(Z,x,F,u,G,f){const Y=G*G;return f.x=6*(Y-G)*Z.x+(3*Y-4*G+1)*x.x+6*(-Y+G)*F.x+(3*Y-2*G)*u.x,f.y=6*(Y-G)*Z.y+(3*Y-4*G+1)*x.y+6*(-Y+G)*F.y+(3*Y-2*G)*u.y,f}static Lerp(Z,x,F){return p.LerpToRef(Z,x,F,new p)}static LerpToRef(Z,x,F,u){return u.x=Z.x+(x.x-Z.x)*F,u.y=Z.y+(x.y-Z.y)*F,u}static Dot(Z,x){return Z.x*x.x+Z.y*x.y}static Normalize(Z){return p.NormalizeToRef(Z,new p)}static NormalizeToRef(Z,x){return Z.normalizeToRef(x),x}static Minimize(Z,x){const F=Z.x<x.x?Z.x:x.x,u=Z.y<x.y?Z.y:x.y;return new p(F,u)}static Maximize(Z,x){const F=Z.x>x.x?Z.x:x.x,u=Z.y>x.y?Z.y:x.y;return new p(F,u)}static Transform(Z,x){return p.TransformToRef(Z,x,new p)}static TransformToRef(Z,x,F){const u=x.m,G=Z.x*u[0]+Z.y*u[4]+u[12],f=Z.x*u[1]+Z.y*u[5]+u[13];return F.x=G,F.y=f,F}static PointInTriangle(Z,x,F,u){const G=.5*(-F.y*u.x+x.y*(-F.x+u.x)+x.x*(F.y-u.y)+F.x*u.y),f=G<0?-1:1,Y=(x.y*u.x-x.x*u.y+(u.y-x.y)*Z.x+(x.x-u.x)*Z.y)*f,j=(x.x*F.y-x.y*F.x+(x.y-F.y)*Z.x+(F.x-x.x)*Z.y)*f;return Y>0&&j>0&&Y+j<2*G*f}static Distance(Z,x){return Math.sqrt(p.DistanceSquared(Z,x))}static DistanceSquared(Z,x){const F=Z.x-x.x,u=Z.y-x.y;return F*F+u*u}static Center(Z,x){return p.CenterToRef(Z,x,new p)}static CenterToRef(Z,x,F){return F.Jj((Z.x+x.x)/2,(Z.y+x.y)/2)}static DistanceOfPointFromSegment(Z,x,F){const u=p.DistanceSquared(x,F);if(0===u)return p.Distance(Z,x);const G=F.Mx(x),f=Math.max(0,Math.min(1,p.Dot(Z.Mx(x),G)/u)),Y=x.add(G.multiplyByFloats(f,f));return p.Distance(Z,Y)}}p._V8PerformanceHack=new p(.5,.5),p._ZeroReadOnly=p.Zero(),Object.defineProperties(p.prototype,{dimension:{value:[2]},rank:{value:1}});class U{get x(){return this._x}set x(Z){this._x=Z,this._isDirty=!0}get y(){return this._y}set y(Z){this._y=Z,this._isDirty=!0}get z(){return this._z}set z(Z){this._z=Z,this._isDirty=!0}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=Z,this._y=x,this._z=F}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"kx"}getHashCode(){let Z=J(this._x);return Z=397*Z^J(this._y),Z=397*Z^J(this._z),Z}Wf(){return[this._x,this._y,this._z]}toArray(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[x]=this._x,Z[x+1]=this._y,Z[x+2]=this._z,this}mF(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U.FromArrayToRef(Z,x,this),this}toQuaternion(){return M.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(Z){return this._x+=Z._x,this._y+=Z._y,this._z+=Z._z,this._isDirty=!0,this}addInPlaceFromFloats(Z,x,F){return this._x+=Z,this._y+=x,this._z+=F,this._isDirty=!0,this}add(Z){return new U(this._x+Z._x,this._y+Z._y,this._z+Z._z)}addToRef(Z,x){return x._x=this._x+Z._x,x._y=this._y+Z._y,x._z=this._z+Z._z,x._isDirty=!0,x}Dc(Z){return this._x-=Z._x,this._y-=Z._y,this._z-=Z._z,this._isDirty=!0,this}Mx(Z){return new U(this._x-Z._x,this._y-Z._y,this._z-Z._z)}subtractToRef(Z,x){return this.subtractFromFloatsToRef(Z._x,Z._y,Z._z,x)}subtractFromFloats(Z,x,F){return new U(this._x-Z,this._y-x,this._z-F)}subtractFromFloatsToRef(Z,x,F,u){return u._x=this._x-Z,u._y=this._y-x,u._z=this._z-F,u._isDirty=!0,u}negate(){return new U(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(Z){return Z._x=-1*this._x,Z._y=-1*this._y,Z._z=-1*this._z,Z._isDirty=!0,Z}scaleInPlace(Z){return this._x*=Z,this._y*=Z,this._z*=Z,this._isDirty=!0,this}scale(Z){return new U(this._x*Z,this._y*Z,this._z*Z)}scaleToRef(Z,x){return x._x=this._x*Z,x._y=this._y*Z,x._z=this._z*Z,x._isDirty=!0,x}getNormalToRef(Z){const x=this.length();let F=Math.acos(this._y/x);const u=Math.atan2(this._z,this._x);F>Math.PI/2?F-=Math.PI/2:F+=Math.PI/2;const G=x*Math.sin(F)*Math.cos(u),f=x*Math.cos(F),Y=x*Math.sin(F)*Math.sin(u);return Z.set(G,f,Y),Z}applyRotationQuaternionToRef(Z,x){const F=this._x,u=this._y,G=this._z,f=Z._x,Y=Z._y,j=Z._z,d=Z._w,t=2*(Y*G-j*u),o=2*(j*F-f*G),c=2*(f*u-Y*F);return x._x=F+d*t+Y*c-j*o,x._y=u+d*o+j*t-f*c,x._z=G+d*c+f*o-Y*t,x._isDirty=!0,x}applyRotationQuaternionInPlace(Z){return this.applyRotationQuaternionToRef(Z,this)}applyRotationQuaternion(Z){return this.applyRotationQuaternionToRef(Z,new U)}scaleAndAddToRef(Z,x){return x._x+=this._x*Z,x._y+=this._y*Z,x._z+=this._z*Z,x._isDirty=!0,x}projectOnPlane(Z,x){return this.projectOnPlaneToRef(Z,x,new U)}projectOnPlaneToRef(Z,x,F){const u=Z.normal,G=Z.d,f=C.kx[0];this.subtractToRef(x,f),f.normalize();const Y=U.Dot(f,u);if(Math.abs(Y)<1e-10)F.Uj(1/0);else{const Z=-(U.Dot(x,u)+G)/Y,j=f.scaleInPlace(Z);x.addToRef(j,F)}return F}equals(Z){return Z&&this._x===Z._x&&this._y===Z._y&&this._z===Z._z}equalsWithEpsilon(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.e;return Z&&(0,d.WithinEpsilon)(this._x,Z._x,x)&&(0,d.WithinEpsilon)(this._y,Z._y,x)&&(0,d.WithinEpsilon)(this._z,Z._z,x)}equalsToFloats(Z,x,F){return this._x===Z&&this._y===x&&this._z===F}multiplyInPlace(Z){return this._x*=Z._x,this._y*=Z._y,this._z*=Z._z,this._isDirty=!0,this}multiply(Z){return this.multiplyByFloats(Z._x,Z._y,Z._z)}multiplyToRef(Z,x){return x._x=this._x*Z._x,x._y=this._y*Z._y,x._z=this._z*Z._z,x._isDirty=!0,x}multiplyByFloats(Z,x,F){return new U(this._x*Z,this._y*x,this._z*F)}divide(Z){return new U(this._x/Z._x,this._y/Z._y,this._z/Z._z)}divideToRef(Z,x){return x._x=this._x/Z._x,x._y=this._y/Z._y,x._z=this._z/Z._z,x._isDirty=!0,x}divideInPlace(Z){return this._x=this._x/Z._x,this._y=this._y/Z._y,this._z=this._z/Z._z,this._isDirty=!0,this}minimizeInPlace(Z){return this.minimizeInPlaceFromFloats(Z._x,Z._y,Z._z)}maximizeInPlace(Z){return this.maximizeInPlaceFromFloats(Z._x,Z._y,Z._z)}minimizeInPlaceFromFloats(Z,x,F){return Z<this._x&&(this.x=Z),x<this._y&&(this.y=x),F<this._z&&(this.z=F),this}maximizeInPlaceFromFloats(Z,x,F){return Z>this._x&&(this.x=Z),x>this._y&&(this.y=x),F>this._z&&(this.z=F),this}isNonUniformWithinEpsilon(Z){const x=Math.abs(this._x),F=Math.abs(this._y);if(!(0,d.WithinEpsilon)(x,F,Z))return!0;const u=Math.abs(this._z);return!(0,d.WithinEpsilon)(x,u,Z)||!(0,d.WithinEpsilon)(F,u,Z)}get isNonUniform(){const Z=Math.abs(this._x);if(Z!==Math.abs(this._y))return!0;return Z!==Math.abs(this._z)}floorToRef(Z){return Z._x=Math.floor(this._x),Z._y=Math.floor(this._y),Z._z=Math.floor(this._z),Z._isDirty=!0,Z}floor(){return new U(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(Z){return Z._x=this._x-Math.floor(this._x),Z._y=this._y-Math.floor(this._y),Z._z=this._z-Math.floor(this._z),Z._isDirty=!0,Z}fract(){return new U(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(Z){if("xyz"===(Z=Z.toLowerCase()))return this;const x=C.kx[0].G(this);return this.x=x[Z[0]],this.y=x[Z[1]],this.z=x[Z[2]],this}rotateByQuaternionToRef(Z,x){return Z.toRotationMatrix(C.Matrix[0]),U.TransformCoordinatesToRef(this,C.Matrix[0],x),x}rotateByQuaternionAroundPointToRef(Z,x,F){return this.subtractToRef(x,C.kx[0]),C.kx[0].rotateByQuaternionToRef(Z,C.kx[0]),x.addToRef(C.kx[0],F),F}cross(Z){return U.CrossToRef(this,Z,new U)}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){return this.normalizeToRef(new U)}normalizeToRef(Z){const x=this.length();return 0===x||1===x?(Z._x=this._x,Z._y=this._y,Z._z=this._z,Z._isDirty=!0,Z):this.scaleToRef(1/x,Z)}clone(){return new U(this._x,this._y,this._z)}G(Z){return this.Jj(Z._x,Z._y,Z._z)}Jj(Z,x,F){return this._x=Z,this._y=x,this._z=F,this._isDirty=!0,this}set(Z,x,F){return this.Jj(Z,x,F)}Uj(Z){return this._x=this._y=this._z=Z,this._isDirty=!0,this}static GetClipFactor(Z,x,F,u){const G=U.Dot(Z,F);return(G-u)/(G-U.Dot(x,F))}static GetAngleBetweenVectors(Z,x,F){const u=Z.normalizeToRef(C.kx[1]),G=x.normalizeToRef(C.kx[2]);let f=U.Dot(u,G);f=(0,d.Clamp)(f,-1,1);const Y=Math.acos(f),j=C.kx[3];return U.CrossToRef(u,G,j),U.Dot(j,F)>0?isNaN(Y)?0:Y:isNaN(Y)?-Math.PI:-Math.acos(f)}static GetAngleBetweenVectorsOnPlane(Z,x,F){C.kx[0].G(Z);const u=C.kx[0];C.kx[1].G(x);const G=C.kx[1];C.kx[2].G(F);const f=C.kx[2],Y=C.kx[3],j=C.kx[4];u.normalize(),G.normalize(),f.normalize(),U.CrossToRef(f,u,Y),U.CrossToRef(Y,f,j);const t=Math.atan2(U.Dot(G,Y),U.Dot(G,j));return(0,d.NormalizeRadians)(t)}static PitchYawRollToMoveBetweenPointsToRef(Z,x,F){const u=L.kx[0];return x.subtractToRef(Z,u),F._y=Math.atan2(u.x,u.z)||0,F._x=Math.atan2(Math.sqrt(u.x**2+u.z**2),u.y)||0,F._z=0,F._isDirty=!0,F}static PitchYawRollToMoveBetweenPoints(Z,x){const F=U.Zero();return U.PitchYawRollToMoveBetweenPointsToRef(Z,x,F)}static SlerpToRef(Z,x,F,G){F=(0,d.Clamp)(F,0,1);const f=C.kx[0],Y=C.kx[1];f.G(Z);const j=f.length();f.normalizeFromLength(j),Y.G(x);const t=Y.length();Y.normalizeFromLength(t);const o=U.Dot(f,Y);let c,s;if(o<1-u.e){const Z=Math.acos(o),x=1/Math.sin(Z);c=Math.sin((1-F)*Z)*x,s=Math.sin(F*Z)*x}else c=1-F,s=F;return f.scaleInPlace(c),Y.scaleInPlace(s),G.G(f).addInPlace(Y),G.scaleInPlace((0,d.Lerp)(j,t,F)),G}static SmoothToRef(Z,x,F,u,G){return U.SlerpToRef(Z,x,0===u?1:F/u,G),G}static Hx(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new U(Z[x],Z[x+1],Z[x+2])}static FromFloatArray(Z,x){return U.Hx(Z,x)}static FromArrayToRef(Z,x,F){return F._x=Z[x],F._y=Z[x+1],F._z=Z[x+2],F._isDirty=!0,F}static FromFloatArrayToRef(Z,x,F){return U.FromArrayToRef(Z,x,F)}static FromFloatsToRef(Z,x,F,u){return u.Jj(Z,x,F),u}static Zero(){return new U(0,0,0)}static One(){return new U(1,1,1)}static Up(){return new U(0,1,0)}static get UpReadOnly(){return U._UpReadOnly}static get DownReadOnly(){return U._DownReadOnly}static get RightReadOnly(){return U._RightReadOnly}static get LeftReadOnly(){return U._LeftReadOnly}static get LeftHandedForwardReadOnly(){return U._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return U._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return U._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return U._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return U._ZeroReadOnly}static get OneReadOnly(){return U._OneReadOnly}static Down(){return new U(0,-1,0)}static Forward(){return new U(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new U(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new U(1,0,0)}static Left(){return new U(-1,0,0)}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new U((0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Jj((0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x))}static TransformCoordinates(Z,x){const F=U.Zero();return U.TransformCoordinatesToRef(Z,x,F),F}static TransformCoordinatesToRef(Z,x,F){return U.TransformCoordinatesFromFloatsToRef(Z._x,Z._y,Z._z,x,F),F}static TransformCoordinatesFromFloatsToRef(Z,x,F,u,G){const f=u.m,Y=Z*f[0]+x*f[4]+F*f[8]+f[12],j=Z*f[1]+x*f[5]+F*f[9]+f[13],d=Z*f[2]+x*f[6]+F*f[10]+f[14],t=1/(Z*f[3]+x*f[7]+F*f[11]+f[15]);return G._x=Y*t,G._y=j*t,G._z=d*t,G._isDirty=!0,G}static TransformNormal(Z,x){const F=U.Zero();return U.TransformNormalToRef(Z,x,F),F}static TransformNormalToRef(Z,x,F){return this.TransformNormalFromFloatsToRef(Z._x,Z._y,Z._z,x,F),F}static TransformNormalFromFloatsToRef(Z,x,F,u,G){const f=u.m;return G._x=Z*f[0]+x*f[4]+F*f[8],G._y=Z*f[1]+x*f[5]+F*f[9],G._z=Z*f[2]+x*f[6]+F*f[10],G._isDirty=!0,G}static CatmullRom(Z,x,F,u,G){const f=G*G,Y=G*f,j=.5*(2*x._x+(-Z._x+F._x)*G+(2*Z._x-5*x._x+4*F._x-u._x)*f+(-Z._x+3*x._x-3*F._x+u._x)*Y),d=.5*(2*x._y+(-Z._y+F._y)*G+(2*Z._y-5*x._y+4*F._y-u._y)*f+(-Z._y+3*x._y-3*F._y+u._y)*Y),t=.5*(2*x._z+(-Z._z+F._z)*G+(2*Z._z-5*x._z+4*F._z-u._z)*f+(-Z._z+3*x._z-3*F._z+u._z)*Y);return new U(j,d,t)}static Clamp(Z,x,F){const u=new U;return U.ClampToRef(Z,x,F,u),u}static ClampToRef(Z,x,F,u){let G=Z._x;G=G>F._x?F._x:G,G=G<x._x?x._x:G;let f=Z._y;f=f>F._y?F._y:f,f=f<x._y?x._y:f;let Y=Z._z;return Y=Y>F._z?F._z:Y,Y=Y<x._z?x._z:Y,u.Jj(G,f,Y),u}static CheckExtends(Z,x,F){x.minimizeInPlace(Z),F.maximizeInPlace(Z)}static Hermite(Z,x,F,u,G){const f=G*G,Y=G*f,j=2*Y-3*f+1,d=-2*Y+3*f,t=Y-2*f+G,o=Y-f,c=Z._x*j+F._x*d+x._x*t+u._x*o,s=Z._y*j+F._y*d+x._y*t+u._y*o,J=Z._z*j+F._z*d+x._z*t+u._z*o;return new U(c,s,J)}static Hermite1stDerivative(Z,x,F,u,G){const f=new U;return this.Hermite1stDerivativeToRef(Z,x,F,u,G,f),f}static Hermite1stDerivativeToRef(Z,x,F,u,G,f){const Y=G*G;return f._x=6*(Y-G)*Z._x+(3*Y-4*G+1)*x._x+6*(-Y+G)*F._x+(3*Y-2*G)*u._x,f._y=6*(Y-G)*Z._y+(3*Y-4*G+1)*x._y+6*(-Y+G)*F._y+(3*Y-2*G)*u._y,f._z=6*(Y-G)*Z._z+(3*Y-4*G+1)*x._z+6*(-Y+G)*F._z+(3*Y-2*G)*u._z,f._isDirty=!0,f}static Lerp(Z,x,F){const u=new U(0,0,0);return U.LerpToRef(Z,x,F,u),u}static LerpToRef(Z,x,F,u){return u._x=Z._x+(x._x-Z._x)*F,u._y=Z._y+(x._y-Z._y)*F,u._z=Z._z+(x._z-Z._z)*F,u._isDirty=!0,u}static Dot(Z,x){return Z._x*x._x+Z._y*x._y+Z._z*x._z}dot(Z){return this._x*Z._x+this._y*Z._y+this._z*Z._z}static Cross(Z,x){const F=new U;return U.CrossToRef(Z,x,F),F}static CrossToRef(Z,x,F){const u=Z._y*x._z-Z._z*x._y,G=Z._z*x._x-Z._x*x._z,f=Z._x*x._y-Z._y*x._x;return F.Jj(u,G,f),F}static Normalize(Z){const x=U.Zero();return U.NormalizeToRef(Z,x),x}static NormalizeToRef(Z,x){return Z.normalizeToRef(x),x}static Project(Z,x,F,u){const G=new U;return U.ProjectToRef(Z,x,F,u,G),G}static ProjectToRef(Z,x,F,u,G){var f;const Y=u.width,d=u.height,t=u.x,o=u.y,c=C.Matrix[1],s=null===(f=j.c.LastCreatedEngine)||void 0===f?void 0:f.isNDCHalfZRange,J=s?1:.5,p=s?0:.5;m.FromValuesToRef(Y/2,0,0,0,0,-d/2,0,0,0,0,J,0,t+Y/2,d/2+o,p,1,c);const k=C.Matrix[0];return x.multiplyToRef(F,k),k.multiplyToRef(c,k),U.TransformCoordinatesToRef(Z,k,G),G}static Reflect(Z,x){return this.ReflectToRef(Z,x,new U)}static ReflectToRef(Z,x,F){const u=L.kx[0];return u.G(x).scaleInPlace(2*U.Dot(Z,x)),F.G(Z).Dc(u)}static _UnprojectFromInvertedMatrixToRef(Z,x,F){U.TransformCoordinatesToRef(Z,x,F);const u=x.m,G=Z._x*u[3]+Z._y*u[7]+Z._z*u[11]+u[15];return(0,d.WithinEpsilon)(G,1)&&F.scaleInPlace(1/G),F}static UnprojectFromTransform(Z,x,F,u,G){return this.Unproject(Z,x,F,u,G,m.IdentityReadOnly)}static Unproject(Z,x,F,u,G,f){const Y=new U;return U.UnprojectToRef(Z,x,F,u,G,f,Y),Y}static UnprojectToRef(Z,x,F,u,G,f,Y){return U.UnprojectFloatsToRef(Z._x,Z._y,Z._z,x,F,u,G,f,Y),Y}static UnprojectFloatsToRef(Z,x,F,u,G,f,Y,d,t){var o;const c=C.Matrix[0];f.multiplyToRef(Y,c),c.multiplyToRef(d,c),c.invert();const s=C.kx[0];return s.x=Z/u*2-1,s.y=-(x/G*2-1),null!==(o=j.c.LastCreatedEngine)&&void 0!==o&&o.isNDCHalfZRange?s.z=F:s.z=2*F-1,U._UnprojectFromInvertedMatrixToRef(s,c,t),t}static Minimize(Z,x){const F=new U;return F.G(Z),F.minimizeInPlace(x),F}static Maximize(Z,x){const F=new U;return F.G(Z),F.maximizeInPlace(x),F}static Distance(Z,x){return Math.sqrt(U.DistanceSquared(Z,x))}static DistanceSquared(Z,x){const F=Z._x-x._x,u=Z._y-x._y,G=Z._z-x._z;return F*F+u*u+G*G}static ProjectOnTriangleToRef(Z,x,F,G,f){const Y=C.kx[0],j=C.kx[1],t=C.kx[2],o=C.kx[3],c=C.kx[4];F.subtractToRef(x,Y),G.subtractToRef(x,j),G.subtractToRef(F,t);const s=Y.length(),J=j.length(),p=t.length();if(s<u.e||J<u.e||p<u.e)return f.G(x),U.Distance(Z,x);Z.subtractToRef(x,c),U.CrossToRef(Y,j,o);const k=o.length();if(k<u.e)return f.G(x),U.Distance(Z,x);o.normalizeFromLength(k);let M=c.length();if(M<u.e)return f.G(x),0;c.normalizeFromLength(M);const m=U.Dot(o,c),L=C.kx[5],H=C.kx[6];L.G(o).scaleInPlace(-M*m),H.G(Z).addInPlace(L);const S=C.kx[4],K=C.kx[5],y=C.kx[7],q=C.kx[8];S.G(Y).scaleInPlace(1/s),q.G(j).scaleInPlace(1/J),S.addInPlace(q).scaleInPlace(-1),K.G(Y).scaleInPlace(-1/s),q.G(t).scaleInPlace(1/p),K.addInPlace(q).scaleInPlace(-1),y.G(t).scaleInPlace(-1/p),q.G(j).scaleInPlace(-1/J),y.addInPlace(q).scaleInPlace(-1);const R=C.kx[9];let B;R.G(H).Dc(x),U.CrossToRef(S,R,q),B=U.Dot(q,o);const v=B;R.G(H).Dc(F),U.CrossToRef(K,R,q),B=U.Dot(q,o);const l=B;R.G(H).Dc(G),U.CrossToRef(y,R,q),B=U.Dot(q,o);const i=B,e=C.kx[10];let b,E;v>0&&l<0?(e.G(Y),b=x,E=F):l>0&&i<0?(e.G(t),b=F,E=G):(e.G(j).scaleInPlace(-1),b=G,E=x);const w=C.kx[9],T=C.kx[4];b.subtractToRef(H,q),E.subtractToRef(H,w),U.CrossToRef(q,w,T);if(!(U.Dot(T,o)<0))return f.G(H),Math.abs(M*m);const N=C.kx[5];U.CrossToRef(e,T,N),N.normalize();const W=C.kx[9];W.G(b).Dc(H);const A=W.length();if(A<u.e)return f.G(b),U.Distance(Z,b);W.normalizeFromLength(A);const h=U.Dot(N,W),X=C.kx[7];X.G(H).addInPlace(N.scaleInPlace(A*h)),q.G(X).Dc(b),M=e.length(),e.normalizeFromLength(M);let D=U.Dot(q,e)/Math.max(M,u.e);return D=(0,d.Clamp)(D,0,1),X.G(b).addInPlace(e.scaleInPlace(D*M)),f.G(X),U.Distance(Z,X)}static Center(Z,x){return U.CenterToRef(Z,x,U.Zero())}static CenterToRef(Z,x,F){return F.Jj((Z._x+x._x)/2,(Z._y+x._y)/2,(Z._z+x._z)/2)}static RotationFromAxis(Z,x,F){const u=new U;return U.RotationFromAxisToRef(Z,x,F,u),u}static RotationFromAxisToRef(Z,x,F,u){const G=C.Quaternion[0];return M.RotationQuaternionFromAxisToRef(Z,x,F,G),G.toEulerAnglesToRef(u),u}}U._V8PerformanceHack=new U(.5,.5,.5),U._UpReadOnly=U.Up(),U._DownReadOnly=U.Down(),U._LeftHandedForwardReadOnly=U.Forward(!1),U._RightHandedForwardReadOnly=U.Forward(!0),U._LeftHandedBackwardReadOnly=U.Backward(!1),U._RightHandedBackwardReadOnly=U.Backward(!0),U._RightReadOnly=U.Right(),U._LeftReadOnly=U.Left(),U._ZeroReadOnly=U.Zero(),U._OneReadOnly=U.One(),Object.defineProperties(U.prototype,{dimension:{value:[3]},rank:{value:1}});class k{get x(){return this._x}set x(Z){this._x=Z,this._isDirty=!0}get y(){return this._y}set y(Z){this._y=Z,this._isDirty=!0}get z(){return this._z}set z(Z){this._z=Z,this._isDirty=!0}get w(){return this._w}set w(Z){this._w=Z,this._isDirty=!0}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=Z,this._y=x,this._z=F,this._w=u}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let Z=J(this._x);return Z=397*Z^J(this._y),Z=397*Z^J(this._z),Z=397*Z^J(this._w),Z}Wf(){return[this._x,this._y,this._z,this._w]}toArray(Z,x){return void 0===x&&(x=0),Z[x]=this._x,Z[x+1]=this._y,Z[x+2]=this._z,Z[x+3]=this._w,this}mF(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k.FromArrayToRef(Z,x,this),this}addInPlace(Z){return this.x+=Z._x,this.y+=Z._y,this.z+=Z._z,this.w+=Z._w,this}addInPlaceFromFloats(Z,x,F,u){return this.x+=Z,this.y+=x,this.z+=F,this.w+=u,this}add(Z){return new k(this._x+Z.x,this._y+Z.y,this._z+Z.z,this._w+Z.w)}addToRef(Z,x){return x.x=this._x+Z.x,x.y=this._y+Z.y,x.z=this._z+Z.z,x.w=this._w+Z.w,x}Dc(Z){return this.x-=Z.x,this.y-=Z.y,this.z-=Z.z,this.w-=Z.w,this}Mx(Z){return new k(this._x-Z.x,this._y-Z.y,this._z-Z.z,this._w-Z.w)}subtractToRef(Z,x){return x.x=this._x-Z.x,x.y=this._y-Z.y,x.z=this._z-Z.z,x.w=this._w-Z.w,x}subtractFromFloats(Z,x,F,u){return new k(this._x-Z,this._y-x,this._z-F,this._w-u)}subtractFromFloatsToRef(Z,x,F,u,G){return G.x=this._x-Z,G.y=this._y-x,G.z=this._z-F,G.w=this._w-u,G}negate(){return new k(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(Z){return Z.x=-this._x,Z.y=-this._y,Z.z=-this._z,Z.w=-this._w,Z}scaleInPlace(Z){return this.x*=Z,this.y*=Z,this.z*=Z,this.w*=Z,this}scale(Z){return new k(this._x*Z,this._y*Z,this._z*Z,this._w*Z)}scaleToRef(Z,x){return x.x=this._x*Z,x.y=this._y*Z,x.z=this._z*Z,x.w=this._w*Z,x}scaleAndAddToRef(Z,x){return x.x+=this._x*Z,x.y+=this._y*Z,x.z+=this._z*Z,x.w+=this._w*Z,x}equals(Z){return Z&&this._x===Z.x&&this._y===Z.y&&this._z===Z.z&&this._w===Z.w}equalsWithEpsilon(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.e;return Z&&(0,d.WithinEpsilon)(this._x,Z.x,x)&&(0,d.WithinEpsilon)(this._y,Z.y,x)&&(0,d.WithinEpsilon)(this._z,Z.z,x)&&(0,d.WithinEpsilon)(this._w,Z.w,x)}equalsToFloats(Z,x,F,u){return this._x===Z&&this._y===x&&this._z===F&&this._w===u}multiplyInPlace(Z){return this.x*=Z.x,this.y*=Z.y,this.z*=Z.z,this.w*=Z.w,this}multiply(Z){return new k(this._x*Z.x,this._y*Z.y,this._z*Z.z,this._w*Z.w)}multiplyToRef(Z,x){return x.x=this._x*Z.x,x.y=this._y*Z.y,x.z=this._z*Z.z,x.w=this._w*Z.w,x}multiplyByFloats(Z,x,F,u){return new k(this._x*Z,this._y*x,this._z*F,this._w*u)}divide(Z){return new k(this._x/Z.x,this._y/Z.y,this._z/Z.z,this._w/Z.w)}divideToRef(Z,x){return x.x=this._x/Z.x,x.y=this._y/Z.y,x.z=this._z/Z.z,x.w=this._w/Z.w,x}divideInPlace(Z){return this.divideToRef(Z,this)}minimizeInPlace(Z){return Z.x<this._x&&(this.x=Z.x),Z.y<this._y&&(this.y=Z.y),Z.z<this._z&&(this.z=Z.z),Z.w<this._w&&(this.w=Z.w),this}maximizeInPlace(Z){return Z.x>this._x&&(this.x=Z.x),Z.y>this._y&&(this.y=Z.y),Z.z>this._z&&(this.z=Z.z),Z.w>this._w&&(this.w=Z.w),this}minimizeInPlaceFromFloats(Z,x,F,u){return this.x=Math.min(Z,this._x),this.y=Math.min(x,this._y),this.z=Math.min(F,this._z),this.w=Math.min(u,this._w),this}maximizeInPlaceFromFloats(Z,x,F,u){return this.x=Math.max(Z,this._x),this.y=Math.max(x,this._y),this.z=Math.max(F,this._z),this.w=Math.max(u,this._w),this}floorToRef(Z){return Z.x=Math.floor(this._x),Z.y=Math.floor(this._y),Z.z=Math.floor(this._z),Z.w=Math.floor(this._w),Z}floor(){return new k(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(Z){return Z.x=this._x-Math.floor(this._x),Z.y=this._y-Math.floor(this._y),Z.z=this._z-Math.floor(this._z),Z.w=this._w-Math.floor(this._w),Z}fract(){return new k(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){return this.normalizeToRef(new k)}normalizeToRef(Z){const x=this.length();return 0===x||1===x?(Z.x=this._x,Z.y=this._y,Z.z=this._z,Z.w=this._w,Z):this.scaleToRef(1/x,Z)}toVector3(){return new U(this._x,this._y,this._z)}clone(){return new k(this._x,this._y,this._z,this._w)}G(Z){return this.x=Z.x,this.y=Z.y,this.z=Z.z,this.w=Z.w,this}Jj(Z,x,F,u){return this.x=Z,this.y=x,this.z=F,this.w=u,this}set(Z,x,F,u){return this.Jj(Z,x,F,u)}Uj(Z){return this.x=this.y=this.z=this.w=Z,this}dot(Z){return this._x*Z.x+this._y*Z.y+this._z*Z.z+this._w*Z.w}static Hx(Z,x){return x||(x=0),new k(Z[x],Z[x+1],Z[x+2],Z[x+3])}static FromArrayToRef(Z,x,F){return F.x=Z[x],F.y=Z[x+1],F.z=Z[x+2],F.w=Z[x+3],F}static FromFloatArrayToRef(Z,x,F){return k.FromArrayToRef(Z,x,F),F}static FromFloatsToRef(Z,x,F,u,G){return G.x=Z,G.y=x,G.z=F,G.w=u,G}static Zero(){return new k(0,0,0,0)}static One(){return new k(1,1,1,1)}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new k((0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0;return F.x=(0,d.RandomRange)(Z,x),F.y=(0,d.RandomRange)(Z,x),F.z=(0,d.RandomRange)(Z,x),F.w=(0,d.RandomRange)(Z,x),F}static Clamp(Z,x,F){return k.ClampToRef(Z,x,F,new k)}static ClampToRef(Z,x,F,u){return u.x=(0,d.Clamp)(Z.x,x.x,F.x),u.y=(0,d.Clamp)(Z.y,x.y,F.y),u.z=(0,d.Clamp)(Z.z,x.z,F.z),u.w=(0,d.Clamp)(Z.w,x.w,F.w),u}static CheckExtends(Z,x,F){x.minimizeInPlace(Z),F.maximizeInPlace(Z)}static get ZeroReadOnly(){return k._ZeroReadOnly}static Normalize(Z){return k.NormalizeToRef(Z,new k)}static NormalizeToRef(Z,x){return Z.normalizeToRef(x),x}static Minimize(Z,x){const F=new k;return F.G(Z),F.minimizeInPlace(x),F}static Maximize(Z,x){const F=new k;return F.G(Z),F.maximizeInPlace(x),F}static Distance(Z,x){return Math.sqrt(k.DistanceSquared(Z,x))}static DistanceSquared(Z,x){const F=Z.x-x.x,u=Z.y-x.y,G=Z.z-x.z,f=Z.w-x.w;return F*F+u*u+G*G+f*f}static Center(Z,x){return k.CenterToRef(Z,x,new k)}static CenterToRef(Z,x,F){return F.x=(Z.x+x.x)/2,F.y=(Z.y+x.y)/2,F.z=(Z.z+x.z)/2,F.w=(Z.w+x.w)/2,F}static TransformCoordinates(Z,x){return k.TransformCoordinatesToRef(Z,x,new k)}static TransformCoordinatesToRef(Z,x,F){return k.TransformCoordinatesFromFloatsToRef(Z._x,Z._y,Z._z,x,F),F}static TransformCoordinatesFromFloatsToRef(Z,x,F,u,G){const f=u.m,Y=Z*f[0]+x*f[4]+F*f[8]+f[12],j=Z*f[1]+x*f[5]+F*f[9]+f[13],d=Z*f[2]+x*f[6]+F*f[10]+f[14],t=Z*f[3]+x*f[7]+F*f[11]+f[15];return G.x=Y,G.y=j,G.z=d,G.w=t,G}static TransformNormal(Z,x){return k.TransformNormalToRef(Z,x,new k)}static TransformNormalToRef(Z,x,F){const u=x.m,G=Z.x*u[0]+Z.y*u[4]+Z.z*u[8],f=Z.x*u[1]+Z.y*u[5]+Z.z*u[9],Y=Z.x*u[2]+Z.y*u[6]+Z.z*u[10];return F.x=G,F.y=f,F.z=Y,F.w=Z.w,F}static TransformNormalFromFloatsToRef(Z,x,F,u,G,f){const Y=G.m;return f.x=Z*Y[0]+x*Y[4]+F*Y[8],f.y=Z*Y[1]+x*Y[5]+F*Y[9],f.z=Z*Y[2]+x*Y[6]+F*Y[10],f.w=u,f}static FromVector3(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new k(Z._x,Z._y,Z._z,x)}static Dot(Z,x){return Z.x*x.x+Z.y*x.y+Z.z*x.z+Z.w*x.w}}k._V8PerformanceHack=new k(.5,.5,.5,.5),k._ZeroReadOnly=k.Zero(),Object.defineProperties(k.prototype,{dimension:{value:[4]},rank:{value:1}});class M{get x(){return this._x}set x(Z){this._x=Z,this._isDirty=!0}get y(){return this._y}set y(Z){this._y=Z,this._isDirty=!0}get z(){return this._z}set z(Z){this._z=Z,this._isDirty=!0}get w(){return this._w}set w(Z){this._w=Z,this._isDirty=!0}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=Z,this._y=x,this._z=F,this._w=u}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let Z=J(this._x);return Z=397*Z^J(this._y),Z=397*Z^J(this._z),Z=397*Z^J(this._w),Z}Wf(){return[this._x,this._y,this._z,this._w]}toArray(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[x]=this._x,Z[x+1]=this._y,Z[x+2]=this._z,Z[x+3]=this._w,this}mF(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M.FromArrayToRef(Z,x,this)}equals(Z){return Z&&this._x===Z._x&&this._y===Z._y&&this._z===Z._z&&this._w===Z._w}equalsWithEpsilon(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.e;return Z&&(0,d.WithinEpsilon)(this._x,Z._x,x)&&(0,d.WithinEpsilon)(this._y,Z._y,x)&&(0,d.WithinEpsilon)(this._z,Z._z,x)&&(0,d.WithinEpsilon)(this._w,Z._w,x)}isApprox(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.e;return Z&&((0,d.WithinEpsilon)(this._x,Z._x,x)&&(0,d.WithinEpsilon)(this._y,Z._y,x)&&(0,d.WithinEpsilon)(this._z,Z._z,x)&&(0,d.WithinEpsilon)(this._w,Z._w,x)||(0,d.WithinEpsilon)(this._x,-Z._x,x)&&(0,d.WithinEpsilon)(this._y,-Z._y,x)&&(0,d.WithinEpsilon)(this._z,-Z._z,x)&&(0,d.WithinEpsilon)(this._w,-Z._w,x))}clone(){return new M(this._x,this._y,this._z,this._w)}G(Z){return this._x=Z._x,this._y=Z._y,this._z=Z._z,this._w=Z._w,this._isDirty=!0,this}Jj(Z,x,F,u){return this._x=Z,this._y=x,this._z=F,this._w=u,this._isDirty=!0,this}set(Z,x,F,u){return this.Jj(Z,x,F,u)}Uj(Z){return this.Jj(Z,Z,Z,Z)}add(Z){return new M(this._x+Z._x,this._y+Z._y,this._z+Z._z,this._w+Z._w)}addInPlace(Z){return this._x+=Z._x,this._y+=Z._y,this._z+=Z._z,this._w+=Z._w,this._isDirty=!0,this}addToRef(Z,x){return x._x=this._x+Z._x,x._y=this._y+Z._y,x._z=this._z+Z._z,x._w=this._w+Z._w,x._isDirty=!0,x}addInPlaceFromFloats(Z,x,F,u){return this._x+=Z,this._y+=x,this._z+=F,this._w+=u,this._isDirty=!0,this}subtractToRef(Z,x){return x._x=this._x-Z._x,x._y=this._y-Z._y,x._z=this._z-Z._z,x._w=this._w-Z._w,x._isDirty=!0,x}subtractFromFloats(Z,x,F,u){return this.subtractFromFloatsToRef(Z,x,F,u,new M)}subtractFromFloatsToRef(Z,x,F,u,G){return G._x=this._x-Z,G._y=this._y-x,G._z=this._z-F,G._w=this._w-u,G._isDirty=!0,G}Mx(Z){return new M(this._x-Z._x,this._y-Z._y,this._z-Z._z,this._w-Z._w)}Dc(Z){return this._x-=Z._x,this._y-=Z._y,this._z-=Z._z,this._w-=Z._w,this._isDirty=!0,this}scale(Z){return new M(this._x*Z,this._y*Z,this._z*Z,this._w*Z)}scaleToRef(Z,x){return x._x=this._x*Z,x._y=this._y*Z,x._z=this._z*Z,x._w=this._w*Z,x._isDirty=!0,x}scaleInPlace(Z){return this._x*=Z,this._y*=Z,this._z*=Z,this._w*=Z,this._isDirty=!0,this}scaleAndAddToRef(Z,x){return x._x+=this._x*Z,x._y+=this._y*Z,x._z+=this._z*Z,x._w+=this._w*Z,x._isDirty=!0,x}multiply(Z){const x=new M(0,0,0,1);return this.multiplyToRef(Z,x),x}multiplyToRef(Z,x){const F=this._x*Z._w+this._y*Z._z-this._z*Z._y+this._w*Z._x,u=-this._x*Z._z+this._y*Z._w+this._z*Z._x+this._w*Z._y,G=this._x*Z._y-this._y*Z._x+this._z*Z._w+this._w*Z._z,f=-this._x*Z._x-this._y*Z._y-this._z*Z._z+this._w*Z._w;return x.Jj(F,u,G,f),x}multiplyInPlace(Z){return this.multiplyToRef(Z,this)}multiplyByFloats(Z,x,F,u){return this._x*=Z,this._y*=x,this._z*=F,this._w*=u,this._isDirty=!0,this}divide(Z){throw new ReferenceError("Can not divide a quaternion")}divideToRef(Z,x){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(Z){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new M)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(Z){return Z._x=-this._x,Z._y=-this._y,Z._z=-this._z,Z._w=-this._w,Z._isDirty=!0,Z}equalsToFloats(Z,x,F,u){return this._x===Z&&this._y===x&&this._z===F&&this._w===u}floorToRef(Z){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(Z){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(Z){return Z.Jj(-this._x,-this._y,-this._z,this._w),Z}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new M(-this._x,-this._y,-this._z,this._w)}invert(){const Z=this.conjugate(),x=this.lengthSquared();return 0==x||1==x||Z.scaleInPlace(1/x),Z}invertInPlace(){this.conjugateInPlace();const Z=this.lengthSquared();return 0==Z||1==Z||this.scaleInPlace(1/Z),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(Z){return 0===Z||1===Z?this:this.scaleInPlace(1/Z)}normalizeToNew(){const Z=new M(0,0,0,1);return this.normalizeToRef(Z),Z}normalizeToRef(Z){const x=this.length();return 0===x||1===x?Z.Jj(this._x,this._y,this._z,this._w):this.scaleToRef(1/x,Z)}toEulerAngles(){const Z=U.Zero();return this.toEulerAnglesToRef(Z),Z}toEulerAnglesToRef(Z){const x=this._z,F=this._x,u=this._y,G=this._w,f=u*x-F*G,Y=.4999999;if(f<-Y)Z._y=2*Math.atan2(u,G),Z._x=Math.PI/2,Z._z=0,Z._isDirty=!0;else if(f>Y)Z._y=2*Math.atan2(u,G),Z._x=-Math.PI/2,Z._z=0,Z._isDirty=!0;else{const Y=G*G,j=x*x,d=F*F,t=u*u;Z._z=Math.atan2(2*(F*u+x*G),-j-d+t+Y),Z._x=Math.asin(-2*f),Z._y=Math.atan2(2*(x*F+u*G),j-d-t+Y),Z._isDirty=!0}return Z}toAlphaBetaGammaToRef(Z){const x=this._z,F=this._x,u=this._y,G=this._w,f=Math.sqrt(F*F+u*u),Y=Math.sqrt(x*x+G*G),j=2*Math.atan2(f,Y),d=2*Math.atan2(x,G),t=2*Math.atan2(u,F),o=(d+t)/2,c=(d-t)/2;return Z.set(c,j,o),Z}toRotationMatrix(Z){return m.FromQuaternionToRef(this,Z),Z}fromRotationMatrix(Z){return M.FromRotationMatrixToRef(Z,this),this}dot(Z){return this._x*Z._x+this._y*Z._y+this._z*Z._z+this._w*Z._w}toAxisAngle(){const Z=U.Zero();return{axis:Z,angle:this.toAxisAngleToRef(Z)}}toAxisAngleToRef(Z){let x=0;const F=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),u=this._w;return F>0?(x=2*Math.atan2(F,u),Z.set(this._x/F,this._y/F,this._z/F)):(x=0,Z.set(1,0,0)),x}static FromRotationMatrix(Z){const x=new M;return M.FromRotationMatrixToRef(Z,x),x}static FromRotationMatrixToRef(Z,x){const F=Z.m,u=F[0],G=F[4],f=F[8],Y=F[1],j=F[5],d=F[9],t=F[2],o=F[6],c=F[10],s=u+j+c;let J;return s>0?(J=.5/Math.sqrt(s+1),x._w=.25/J,x._x=(o-d)*J,x._y=(f-t)*J,x._z=(Y-G)*J,x._isDirty=!0):u>j&&u>c?(J=2*Math.sqrt(1+u-j-c),x._w=(o-d)/J,x._x=.25*J,x._y=(G+Y)/J,x._z=(f+t)/J,x._isDirty=!0):j>c?(J=2*Math.sqrt(1+j-u-c),x._w=(f-t)/J,x._x=(G+Y)/J,x._y=.25*J,x._z=(d+o)/J,x._isDirty=!0):(J=2*Math.sqrt(1+c-u-j),x._w=(Y-G)/J,x._x=(f+t)/J,x._y=(d+o)/J,x._z=.25*J,x._isDirty=!0),x}static Dot(Z,x){return Z._x*x._x+Z._y*x._y+Z._z*x._z+Z._w*x._w}static AreClose(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const u=M.Dot(Z,x);return 1-u*u<=F}static SmoothToRef(Z,x,F,u,G){let f=0===u?1:F/u;return f=(0,d.Clamp)(f,0,1),M.SlerpToRef(Z,x,f,G),G}static Zero(){return new M(0,0,0,0)}static Inverse(Z){return new M(-Z._x,-Z._y,-Z._z,Z._w)}static InverseToRef(Z,x){return x.set(-Z._x,-Z._y,-Z._z,Z._w),x}static Identity(){return new M(0,0,0,1)}static IsIdentity(Z){return Z&&0===Z._x&&0===Z._y&&0===Z._z&&1===Z._w}static RotationAxis(Z,x){return M.RotationAxisToRef(Z,x,new M)}static RotationAxisToRef(Z,x,F){F._w=Math.cos(x/2);const u=Math.sin(x/2)/Z.length();return F._x=Z._x*u,F._y=Z._y*u,F._z=Z._z*u,F._isDirty=!0,F}static Hx(Z,x){return x||(x=0),new M(Z[x],Z[x+1],Z[x+2],Z[x+3])}static FromArrayToRef(Z,x,F){return F._x=Z[x],F._y=Z[x+1],F._z=Z[x+2],F._w=Z[x+3],F._isDirty=!0,F}static FromFloatsToRef(Z,x,F,u,G){return G.Jj(Z,x,F,u),G}static FromEulerAngles(Z,x,F){const u=new M;return M.RotationYawPitchRollToRef(x,Z,F,u),u}static FromEulerAnglesToRef(Z,x,F,u){return M.RotationYawPitchRollToRef(x,Z,F,u),u}static FromEulerVector(Z){const x=new M;return M.RotationYawPitchRollToRef(Z._y,Z._x,Z._z,x),x}static FromEulerVectorToRef(Z,x){return M.RotationYawPitchRollToRef(Z._y,Z._x,Z._z,x),x}static FromUnitVectorsToRef(Z,x,F){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:u.e;const f=U.Dot(Z,x)+1;return f<G?Math.abs(Z.x)>Math.abs(Z.z)?F.set(-Z.y,Z.x,0,0):F.set(0,-Z.z,Z.y,0):(U.CrossToRef(Z,x,L.kx[0]),F.set(L.kx[0].x,L.kx[0].y,L.kx[0].z,f)),F.normalize()}static RotationYawPitchRoll(Z,x,F){const u=new M;return M.RotationYawPitchRollToRef(Z,x,F,u),u}static RotationYawPitchRollToRef(Z,x,F,u){const G=.5*F,f=.5*x,Y=.5*Z,j=Math.sin(G),d=Math.cos(G),t=Math.sin(f),o=Math.cos(f),c=Math.sin(Y),s=Math.cos(Y);return u._x=s*t*d+c*o*j,u._y=c*o*d-s*t*j,u._z=s*o*j-c*t*d,u._w=s*o*d+c*t*j,u._isDirty=!0,u}static RotationAlphaBetaGamma(Z,x,F){const u=new M;return M.RotationAlphaBetaGammaToRef(Z,x,F,u),u}static RotationAlphaBetaGammaToRef(Z,x,F,u){const G=.5*(F+Z),f=.5*(F-Z),Y=.5*x;return u._x=Math.cos(f)*Math.sin(Y),u._y=Math.sin(f)*Math.sin(Y),u._z=Math.sin(G)*Math.cos(Y),u._w=Math.cos(G)*Math.cos(Y),u._isDirty=!0,u}static RotationQuaternionFromAxis(Z,x,F){const u=new M(0,0,0,0);return M.RotationQuaternionFromAxisToRef(Z,x,F,u),u}static RotationQuaternionFromAxisToRef(Z,x,F,u){const G=C.Matrix[0];return Z=Z.normalizeToRef(C.kx[0]),x=x.normalizeToRef(C.kx[1]),F=F.normalizeToRef(C.kx[2]),m.FromXYZAxesToRef(Z,x,F,G),M.FromRotationMatrixToRef(G,u),u}static FromLookDirectionLH(Z,x){const F=new M;return M.FromLookDirectionLHToRef(Z,x,F),F}static FromLookDirectionLHToRef(Z,x,F){const u=C.Matrix[0];return m.LookDirectionLHToRef(Z,x,u),M.FromRotationMatrixToRef(u,F),F}static FromLookDirectionRH(Z,x){const F=new M;return M.FromLookDirectionRHToRef(Z,x,F),F}static FromLookDirectionRHToRef(Z,x,F){const u=C.Matrix[0];return m.LookDirectionRHToRef(Z,x,u),M.FromRotationMatrixToRef(u,F)}static Slerp(Z,x,F){const u=M.Identity();return M.SlerpToRef(Z,x,F,u),u}static SlerpToRef(Z,x,F,u){let G,f,Y=Z._x*x._x+Z._y*x._y+Z._z*x._z+Z._w*x._w,j=!1;if(Y<0&&(j=!0,Y=-Y),Y>.999999)f=1-F,G=j?-F:F;else{const Z=Math.acos(Y),x=1/Math.sin(Z);f=Math.sin((1-F)*Z)*x,G=j?-Math.sin(F*Z)*x:Math.sin(F*Z)*x}return u._x=f*Z._x+G*x._x,u._y=f*Z._y+G*x._y,u._z=f*Z._z+G*x._z,u._w=f*Z._w+G*x._w,u._isDirty=!0,u}static Hermite(Z,x,F,u,G){const f=G*G,Y=G*f,j=2*Y-3*f+1,d=-2*Y+3*f,t=Y-2*f+G,o=Y-f,c=Z._x*j+F._x*d+x._x*t+u._x*o,s=Z._y*j+F._y*d+x._y*t+u._y*o,J=Z._z*j+F._z*d+x._z*t+u._z*o,p=Z._w*j+F._w*d+x._w*t+u._w*o;return new M(c,s,J,p)}static Hermite1stDerivative(Z,x,F,u,G){const f=new M;return this.Hermite1stDerivativeToRef(Z,x,F,u,G,f),f}static Hermite1stDerivativeToRef(Z,x,F,u,G,f){const Y=G*G;return f._x=6*(Y-G)*Z._x+(3*Y-4*G+1)*x._x+6*(-Y+G)*F._x+(3*Y-2*G)*u._x,f._y=6*(Y-G)*Z._y+(3*Y-4*G+1)*x._y+6*(-Y+G)*F._y+(3*Y-2*G)*u._y,f._z=6*(Y-G)*Z._z+(3*Y-4*G+1)*x._z+6*(-Y+G)*F._z+(3*Y-2*G)*u._z,f._w=6*(Y-G)*Z._w+(3*Y-4*G+1)*x._w+6*(-Y+G)*F._w+(3*Y-2*G)*u._w,f._isDirty=!0,f}static Normalize(Z){const x=M.Zero();return M.NormalizeToRef(Z,x),x}static NormalizeToRef(Z,x){return Z.normalizeToRef(x),x}static Clamp(Z,x,F){const u=new M;return M.ClampToRef(Z,x,F,u),u}static ClampToRef(Z,x,F,u){return u.Jj((0,d.Clamp)(Z.x,x.x,F.x),(0,d.Clamp)(Z.y,x.y,F.y),(0,d.Clamp)(Z.z,x.z,F.z),(0,d.Clamp)(Z.w,x.w,F.w))}static Random(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new M((0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x))}static RandomToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Jj((0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x),(0,d.RandomRange)(Z,x))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(Z,x){return Math.sqrt(M.DistanceSquared(Z,x))}static DistanceSquared(Z,x){const F=Z.x-x.x,u=Z.y-x.y,G=Z.z-x.z,f=Z.w-x.w;return F*F+u*u+G*G+f*f}static Center(Z,x){return M.CenterToRef(Z,x,M.Zero())}static CenterToRef(Z,x,F){return F.Jj((Z.x+x.x)/2,(Z.y+x.y)/2,(Z.z+x.z)/2,(Z.w+x.w)/2)}}M._V8PerformanceHack=new M(.5,.5,.5,.5),Object.defineProperties(M.prototype,{dimension:{value:[4]},rank:{value:1}});class m{static get Use64Bits(){return Y.b.MatrixUse64Bits}get m(){return this.Mf}markAsUpdated(){this.updateFlag=t._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(Z){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],u=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=Z,this._isIdentity3x2=Z||F,this._isIdentityDirty=!this._isIdentity&&x,this._isIdentity3x2Dirty=!this._isIdentity3x2&&u}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,Y.b.MatrixTrackPrecisionChange&&Y.b.MatrixTrackedMatrices.push(this),this.Mf=new Y.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const Z=this.Mf;this._isIdentity=1===Z[0]&&0===Z[1]&&0===Z[2]&&0===Z[3]&&0===Z[4]&&1===Z[5]&&0===Z[6]&&0===Z[7]&&0===Z[8]&&0===Z[9]&&1===Z[10]&&0===Z[11]&&0===Z[12]&&0===Z[13]&&0===Z[14]&&1===Z[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Mf[0]||1!==this.Mf[5]||1!==this.Mf[15]||0!==this.Mf[1]||0!==this.Mf[2]||0!==this.Mf[3]||0!==this.Mf[4]||0!==this.Mf[6]||0!==this.Mf[7]||0!==this.Mf[8]||0!==this.Mf[9]||0!==this.Mf[10]||0!==this.Mf[11]||0!==this.Mf[12]||0!==this.Mf[13]||0!==this.Mf[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const Z=this.Mf,x=Z[0],F=Z[1],u=Z[2],G=Z[3],f=Z[4],Y=Z[5],j=Z[6],d=Z[7],t=Z[8],o=Z[9],c=Z[10],s=Z[11],J=Z[12],p=Z[13],U=Z[14],k=Z[15],M=c*k-U*s,m=o*k-p*s,C=o*U-p*c,L=t*k-J*s,H=t*U-c*J,S=t*p-J*o;return x*+(Y*M-j*m+d*C)+F*-(f*M-j*L+d*H)+u*+(f*m-Y*L+d*S)+G*-(f*C-Y*H+j*S)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!Z)return this.Mf;const F=this.Mf;for(let u=0;u<16;u++)Z[x+u]=F[u];return this}Wf(){return this.Mf}mF(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return m.FromArrayToRef(Z,x,this)}Jj(){for(var Z=arguments.length,x=new Array(Z),F=0;F<Z;F++)x[F]=arguments[F];return m.FromArrayToRef(x,0,this)}set(){const Z=this.Mf;for(let x=0;x<16;x++)Z[x]=x<0||arguments.length<=x?void 0:arguments[x];return this.markAsUpdated(),this}Uj(Z){const x=this.Mf;for(let F=0;F<16;F++)x[F]=Z;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return m.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(Z){const x=new m;return this.addToRef(Z,x),x}addToRef(Z,x){const F=this.Mf,u=x.Mf,G=Z.m;for(let f=0;f<16;f++)u[f]=F[f]+G[f];return x.markAsUpdated(),x}addToSelf(Z){const x=this.Mf,F=Z.m;return x[0]+=F[0],x[1]+=F[1],x[2]+=F[2],x[3]+=F[3],x[4]+=F[4],x[5]+=F[5],x[6]+=F[6],x[7]+=F[7],x[8]+=F[8],x[9]+=F[9],x[10]+=F[10],x[11]+=F[11],x[12]+=F[12],x[13]+=F[13],x[14]+=F[14],x[15]+=F[15],this.markAsUpdated(),this}addInPlace(Z){const x=this.Mf,F=Z.m;for(let u=0;u<16;u++)x[u]+=F[u];return this.markAsUpdated(),this}addInPlaceFromFloats(){const Z=this.Mf;for(let x=0;x<16;x++)Z[x]+=x<0||arguments.length<=x?void 0:arguments[x];return this.markAsUpdated(),this}Mx(Z){const x=this.Mf,F=Z.m;for(let u=0;u<16;u++)x[u]-=F[u];return this.markAsUpdated(),this}subtractToRef(Z,x){const F=this.Mf,u=Z.m,G=x.Mf;for(let f=0;f<16;f++)G[f]=F[f]-u[f];return x.markAsUpdated(),x}Dc(Z){const x=this.Mf,F=Z.m;for(let u=0;u<16;u++)x[u]-=F[u];return this.markAsUpdated(),this}subtractFromFloats(){for(var Z=arguments.length,x=new Array(Z),F=0;F<Z;F++)x[F]=arguments[F];return this.subtractFromFloatsToRef(...x,new m)}subtractFromFloatsToRef(){for(var Z=arguments.length,x=new Array(Z),F=0;F<Z;F++)x[F]=arguments[F];const u=x.pop(),G=this.Mf,f=u.Mf,Y=x;for(let j=0;j<16;j++)f[j]=G[j]-Y[j];return u.markAsUpdated(),u}invertToRef(Z){return!0===this._isIdentity?(m.IdentityToRef(Z),Z):(s(this,Z.Wf())?Z.markAsUpdated():Z.G(this),Z)}addAtIndex(Z,x){return this.Mf[Z]+=x,this.markAsUpdated(),this}multiplyAtIndex(Z,x){return this.Mf[Z]*=x,this.markAsUpdated(),this}setTranslationFromFloats(Z,x,F){return this.Mf[12]=Z,this.Mf[13]=x,this.Mf[14]=F,this.markAsUpdated(),this}addTranslationFromFloats(Z,x,F){return this.Mf[12]+=Z,this.Mf[13]+=x,this.Mf[14]+=F,this.markAsUpdated(),this}setTranslation(Z){return this.setTranslationFromFloats(Z._x,Z._y,Z._z)}getTranslation(){return new U(this.Mf[12],this.Mf[13],this.Mf[14])}getTranslationToRef(Z){return Z.x=this.Mf[12],Z.y=this.Mf[13],Z.z=this.Mf[14],Z}removeRotationAndScaling(){const Z=this.m;return m.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,Z[12],Z[13],Z[14],Z[15],this),this._updateIdentityStatus(0===Z[12]&&0===Z[13]&&0===Z[14]&&1===Z[15]),this}G(Z){Z.copyToArray(this.Mf);const x=Z;return this.updateFlag=x.updateFlag,this._updateIdentityStatus(x._isIdentity,x._isIdentityDirty,x._isIdentity3x2,x._isIdentity3x2Dirty),this}copyToArray(Z){return c(this,Z,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(Z){const x=new m;return this.multiplyToRef(Z,x),x}multiplyInPlace(Z){const x=this.Mf,F=Z.m;for(let u=0;u<16;u++)x[u]*=F[u];return this.markAsUpdated(),this}multiplyByFloats(){const Z=this.Mf;for(let x=0;x<16;x++)Z[x]*=x<0||arguments.length<=x?void 0:arguments[x];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var Z=arguments.length,x=new Array(Z),F=0;F<Z;F++)x[F]=arguments[F];const u=x.pop(),G=this.Mf,f=u.Mf,Y=x;for(let j=0;j<16;j++)f[j]=G[j]*Y[j];return u.markAsUpdated(),u}multiplyToRef(Z,x){return this._isIdentity?(x.G(Z),x):Z._isIdentity?(x.G(this),x):(this.multiplyToArray(Z,x.Mf,0),x.markAsUpdated(),x)}multiplyToArray(Z,x,F){return o(this,Z,x,F),this}divide(Z){return this.divideToRef(Z,new m)}divideToRef(Z,x){const F=this.Mf,u=Z.m,G=x.Mf;for(let f=0;f<16;f++)G[f]=F[f]/u[f];return x.markAsUpdated(),x}divideInPlace(Z){const x=this.Mf,F=Z.m;for(let u=0;u<16;u++)x[u]/=F[u];return this.markAsUpdated(),this}minimizeInPlace(Z){const x=this.Mf,F=Z.m;for(let u=0;u<16;u++)x[u]=Math.min(x[u],F[u]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const Z=this.Mf;for(let x=0;x<16;x++)Z[x]=Math.min(Z[x],x<0||arguments.length<=x?void 0:arguments[x]);return this.markAsUpdated(),this}maximizeInPlace(Z){const x=this.Mf,F=Z.m;for(let u=0;u<16;u++)x[u]=Math.min(x[u],F[u]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const Z=this.Mf;for(let x=0;x<16;x++)Z[x]=Math.min(Z[x],x<0||arguments.length<=x?void 0:arguments[x]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new m)}negateInPlace(){const Z=this.Mf;for(let x=0;x<16;x++)Z[x]=-Z[x];return this.markAsUpdated(),this}negateToRef(Z){const x=this.Mf,F=Z.Mf;for(let u=0;u<16;u++)F[u]=-x[u];return Z.markAsUpdated(),Z}equals(Z){const x=Z;if(!x)return!1;if((this._isIdentity||x._isIdentity)&&!this._isIdentityDirty&&!x._isIdentityDirty)return this._isIdentity&&x._isIdentity;const F=this.m,u=x.m;return F[0]===u[0]&&F[1]===u[1]&&F[2]===u[2]&&F[3]===u[3]&&F[4]===u[4]&&F[5]===u[5]&&F[6]===u[6]&&F[7]===u[7]&&F[8]===u[8]&&F[9]===u[9]&&F[10]===u[10]&&F[11]===u[11]&&F[12]===u[12]&&F[13]===u[13]&&F[14]===u[14]&&F[15]===u[15]}equalsWithEpsilon(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const F=this.Mf,u=Z.m;for(let G=0;G<16;G++)if(!(0,d.WithinEpsilon)(F[G],u[G],x))return!1;return!0}equalsToFloats(){const Z=this.Mf;for(let x=0;x<16;x++)if(Z[x]!=(x<0||arguments.length<=x?void 0:arguments[x]))return!1;return!0}floor(){return this.floorToRef(new m)}floorToRef(Z){const x=this.Mf,F=Z.Mf;for(let u=0;u<16;u++)F[u]=Math.floor(x[u]);return Z.markAsUpdated(),Z}fract(){return this.fractToRef(new m)}fractToRef(Z){const x=this.Mf,F=Z.Mf;for(let u=0;u<16;u++)F[u]=x[u]-Math.floor(x[u]);return Z.markAsUpdated(),Z}clone(){const Z=new m;return Z.G(this),Z}getClassName(){return"Matrix"}getHashCode(){let Z=J(this.Mf[0]);for(let x=1;x<16;x++)Z=397*Z^J(this.Mf[x]);return Z}decomposeToTransformNode(Z){return Z.rotationQuaternion=Z.rotationQuaternion||new M,this.decompose(Z.pj,Z.rotationQuaternion,Z.position)}decompose(Z,x,F,u){let G=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return F&&F.Uj(0),Z&&Z.Uj(1),x&&x.Jj(0,0,0,1),!0;const f=this.Mf;if(F&&F.Jj(f[12],f[13],f[14]),(Z=Z||C.kx[0]).x=Math.sqrt(f[0]*f[0]+f[1]*f[1]+f[2]*f[2]),Z.y=Math.sqrt(f[4]*f[4]+f[5]*f[5]+f[6]*f[6]),Z.z=Math.sqrt(f[8]*f[8]+f[9]*f[9]+f[10]*f[10]),u){const x=(G?u.absoluteScaling.x:u.pj.x)<0?-1:1,F=(G?u.absoluteScaling.y:u.pj.y)<0?-1:1,f=(G?u.absoluteScaling.z:u.pj.z)<0?-1:1;Z.x*=x,Z.y*=F,Z.z*=f}else this.determinant()<=0&&(Z.y*=-1);if(0===Z._x||0===Z._y||0===Z._z)return x&&x.Jj(0,0,0,1),!1;if(x){const F=1/Z._x,u=1/Z._y,G=1/Z._z;m.FromValuesToRef(f[0]*F,f[1]*F,f[2]*F,0,f[4]*u,f[5]*u,f[6]*u,0,f[8]*G,f[9]*G,f[10]*G,0,0,0,0,1,C.Matrix[0]),M.FromRotationMatrixToRef(C.Matrix[0],x)}return!0}getRow(Z){if(Z<0||Z>3)return null;const x=4*Z;return new k(this.Mf[x+0],this.Mf[x+1],this.Mf[x+2],this.Mf[x+3])}getRowToRef(Z,x){if(Z>=0&&Z<=3){const F=4*Z;x.x=this.Mf[F+0],x.y=this.Mf[F+1],x.z=this.Mf[F+2],x.w=this.Mf[F+3]}return x}setRow(Z,x){return this.setRowFromFloats(Z,x.x,x.y,x.z,x.w)}transpose(){const Z=new m;return m.TransposeToRef(this,Z),Z}transposeToRef(Z){return m.TransposeToRef(this,Z),Z}setRowFromFloats(Z,x,F,u,G){if(Z<0||Z>3)return this;const f=4*Z;return this.Mf[f+0]=x,this.Mf[f+1]=F,this.Mf[f+2]=u,this.Mf[f+3]=G,this.markAsUpdated(),this}scale(Z){const x=new m;return this.scaleToRef(Z,x),x}scaleToRef(Z,x){for(let F=0;F<16;F++)x.Mf[F]=this.Mf[F]*Z;return x.markAsUpdated(),x}scaleAndAddToRef(Z,x){for(let F=0;F<16;F++)x.Mf[F]+=this.Mf[F]*Z;return x.markAsUpdated(),x}scaleInPlace(Z){const x=this.Mf;for(let F=0;F<16;F++)x[F]*=Z;return this.markAsUpdated(),this}toNormalMatrix(Z){const x=C.Matrix[0];this.invertToRef(x),x.transposeToRef(Z);const F=Z.Mf;return m.FromValuesToRef(F[0],F[1],F[2],0,F[4],F[5],F[6],0,F[8],F[9],F[10],0,0,0,0,1,Z),Z}getRotationMatrix(){const Z=new m;return this.getRotationMatrixToRef(Z),Z}getRotationMatrixToRef(Z){const x=C.kx[0];if(!this.decompose(x))return m.IdentityToRef(Z),Z;const F=this.Mf,u=1/x._x,G=1/x._y,f=1/x._z;return m.FromValuesToRef(F[0]*u,F[1]*u,F[2]*u,0,F[4]*G,F[5]*G,F[6]*G,0,F[8]*f,F[9]*f,F[10]*f,0,0,0,0,1,Z),Z}toggleModelMatrixHandInPlace(){const Z=this.Mf;return Z[2]*=-1,Z[6]*=-1,Z[8]*=-1,Z[9]*=-1,Z[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const Z=this.Mf;return Z[8]*=-1,Z[9]*=-1,Z[10]*=-1,Z[11]*=-1,this.markAsUpdated(),this}static Hx(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const F=new m;return m.FromArrayToRef(Z,x,F),F}static FromArrayToRef(Z,x,F){for(let u=0;u<16;u++)F.Mf[u]=Z[u+x];return F.markAsUpdated(),F}static FromFloat32ArrayToRefScaled(Z,x,F,u){return u.Mf[0]=Z[0+x]*F,u.Mf[1]=Z[1+x]*F,u.Mf[2]=Z[2+x]*F,u.Mf[3]=Z[3+x]*F,u.Mf[4]=Z[4+x]*F,u.Mf[5]=Z[5+x]*F,u.Mf[6]=Z[6+x]*F,u.Mf[7]=Z[7+x]*F,u.Mf[8]=Z[8+x]*F,u.Mf[9]=Z[9+x]*F,u.Mf[10]=Z[10+x]*F,u.Mf[11]=Z[11+x]*F,u.Mf[12]=Z[12+x]*F,u.Mf[13]=Z[13+x]*F,u.Mf[14]=Z[14+x]*F,u.Mf[15]=Z[15+x]*F,u.markAsUpdated(),u}static get IdentityReadOnly(){return m._IdentityReadOnly}static FromValuesToRef(Z,x,F,u,G,f,Y,j,d,t,o,c,s,J,p,U,k){const M=k.Mf;M[0]=Z,M[1]=x,M[2]=F,M[3]=u,M[4]=G,M[5]=f,M[6]=Y,M[7]=j,M[8]=d,M[9]=t,M[10]=o,M[11]=c,M[12]=s,M[13]=J,M[14]=p,M[15]=U,k.markAsUpdated()}static FromValues(Z,x,F,u,G,f,Y,j,d,t,o,c,s,J,p,U){const k=new m,M=k.Mf;return M[0]=Z,M[1]=x,M[2]=F,M[3]=u,M[4]=G,M[5]=f,M[6]=Y,M[7]=j,M[8]=d,M[9]=t,M[10]=o,M[11]=c,M[12]=s,M[13]=J,M[14]=p,M[15]=U,k.markAsUpdated(),k}static Compose(Z,x,F){const u=new m;return m.ComposeToRef(Z,x,F,u),u}static ComposeToRef(Z,x,F,u){const G=u.Mf,f=x._x,Y=x._y,j=x._z,d=x._w,t=f+f,o=Y+Y,c=j+j,s=f*t,J=f*o,p=f*c,U=Y*o,k=Y*c,M=j*c,m=d*t,C=d*o,L=d*c,H=Z._x,S=Z._y,K=Z._z;return G[0]=(1-(U+M))*H,G[1]=(J+L)*H,G[2]=(p-C)*H,G[3]=0,G[4]=(J-L)*S,G[5]=(1-(s+M))*S,G[6]=(k+m)*S,G[7]=0,G[8]=(p+C)*K,G[9]=(k-m)*K,G[10]=(1-(s+U))*K,G[11]=0,G[12]=F._x,G[13]=F._y,G[14]=F._z,G[15]=1,u.markAsUpdated(),u}static Identity(){const Z=m.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return Z._updateIdentityStatus(!0),Z}static IdentityToRef(Z){return m.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,Z),Z._updateIdentityStatus(!0),Z}static Zero(){const Z=m.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return Z._updateIdentityStatus(!1),Z}static RotationX(Z){const x=new m;return m.RotationXToRef(Z,x),x}static Invert(Z){const x=new m;return Z.invertToRef(x),x}static RotationXToRef(Z,x){const F=Math.sin(Z),u=Math.cos(Z);return m.FromValuesToRef(1,0,0,0,0,u,F,0,0,-F,u,0,0,0,0,1,x),x._updateIdentityStatus(1===u&&0===F),x}static RotationY(Z){const x=new m;return m.RotationYToRef(Z,x),x}static RotationYToRef(Z,x){const F=Math.sin(Z),u=Math.cos(Z);return m.FromValuesToRef(u,0,-F,0,0,1,0,0,F,0,u,0,0,0,0,1,x),x._updateIdentityStatus(1===u&&0===F),x}static RotationZ(Z){const x=new m;return m.RotationZToRef(Z,x),x}static RotationZToRef(Z,x){const F=Math.sin(Z),u=Math.cos(Z);return m.FromValuesToRef(u,F,0,0,-F,u,0,0,0,0,1,0,0,0,0,1,x),x._updateIdentityStatus(1===u&&0===F),x}static RotationAxis(Z,x){const F=new m;return m.RotationAxisToRef(Z,x,F),F}static RotationAxisToRef(Z,x,F){const u=Math.sin(-x),G=Math.cos(-x),f=1-G;Z=Z.normalizeToRef(C.kx[0]);const Y=F.Mf;return Y[0]=Z._x*Z._x*f+G,Y[1]=Z._x*Z._y*f-Z._z*u,Y[2]=Z._x*Z._z*f+Z._y*u,Y[3]=0,Y[4]=Z._y*Z._x*f+Z._z*u,Y[5]=Z._y*Z._y*f+G,Y[6]=Z._y*Z._z*f-Z._x*u,Y[7]=0,Y[8]=Z._z*Z._x*f-Z._y*u,Y[9]=Z._z*Z._y*f+Z._x*u,Y[10]=Z._z*Z._z*f+G,Y[11]=0,Y[12]=0,Y[13]=0,Y[14]=0,Y[15]=1,F.markAsUpdated(),F}static RotationAlignToRef(Z,x,F){let G=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const f=U.Dot(x,Z),Y=F.Mf;if(f<-1+u.e)Y[0]=-1,Y[1]=0,Y[2]=0,Y[3]=0,Y[4]=0,Y[5]=G?1:-1,Y[6]=0,Y[7]=0,Y[8]=0,Y[9]=0,Y[10]=G?-1:1,Y[11]=0;else{const F=U.Cross(x,Z),u=1/(1+f);Y[0]=F._x*F._x*u+f,Y[1]=F._y*F._x*u-F._z,Y[2]=F._z*F._x*u+F._y,Y[3]=0,Y[4]=F._x*F._y*u+F._z,Y[5]=F._y*F._y*u+f,Y[6]=F._z*F._y*u-F._x,Y[7]=0,Y[8]=F._x*F._z*u-F._y,Y[9]=F._y*F._z*u+F._x,Y[10]=F._z*F._z*u+f,Y[11]=0}return Y[12]=0,Y[13]=0,Y[14]=0,Y[15]=1,F.markAsUpdated(),F}static RotationYawPitchRoll(Z,x,F){const u=new m;return m.RotationYawPitchRollToRef(Z,x,F,u),u}static RotationYawPitchRollToRef(Z,x,F,u){return M.RotationYawPitchRollToRef(Z,x,F,C.Quaternion[0]),C.Quaternion[0].toRotationMatrix(u),u}static Scaling(Z,x,F){const u=new m;return m.ScalingToRef(Z,x,F,u),u}static ScalingToRef(Z,x,F,u){return m.FromValuesToRef(Z,0,0,0,0,x,0,0,0,0,F,0,0,0,0,1,u),u._updateIdentityStatus(1===Z&&1===x&&1===F),u}static Translation(Z,x,F){const u=new m;return m.TranslationToRef(Z,x,F,u),u}static TranslationToRef(Z,x,F,u){return m.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,Z,x,F,1,u),u._updateIdentityStatus(0===Z&&0===x&&0===F),u}static Lerp(Z,x,F){const u=new m;return m.LerpToRef(Z,x,F,u),u}static LerpToRef(Z,x,F,u){const G=u.Mf,f=Z.m,Y=x.m;for(let j=0;j<16;j++)G[j]=f[j]*(1-F)+Y[j]*F;return u.markAsUpdated(),u}static DecomposeLerp(Z,x,F){const u=new m;return m.DecomposeLerpToRef(Z,x,F,u),u}static DecomposeLerpToRef(Z,x,F,u){const G=C.kx[0],f=C.Quaternion[0],Y=C.kx[1];Z.decompose(G,f,Y);const j=C.kx[2],d=C.Quaternion[1],t=C.kx[3];x.decompose(j,d,t);const o=C.kx[4];U.LerpToRef(G,j,F,o);const c=C.Quaternion[2];M.SlerpToRef(f,d,F,c);const s=C.kx[5];return U.LerpToRef(Y,t,F,s),m.ComposeToRef(o,c,s,u),u}static LookAtLH(Z,x,F){const u=new m;return m.LookAtLHToRef(Z,x,F,u),u}static LookAtLHToRef(Z,x,F,u){const G=C.kx[0],f=C.kx[1],Y=C.kx[2];x.subtractToRef(Z,Y),Y.normalize(),U.CrossToRef(F,Y,G);const j=G.lengthSquared();0===j?G.x=1:G.normalizeFromLength(Math.sqrt(j)),U.CrossToRef(Y,G,f),f.normalize();const d=-U.Dot(G,Z),t=-U.Dot(f,Z),o=-U.Dot(Y,Z);return m.FromValuesToRef(G._x,f._x,Y._x,0,G._y,f._y,Y._y,0,G._z,f._z,Y._z,0,d,t,o,1,u),u}static LookAtRH(Z,x,F){const u=new m;return m.LookAtRHToRef(Z,x,F,u),u}static LookAtRHToRef(Z,x,F,u){const G=C.kx[0],f=C.kx[1],Y=C.kx[2];Z.subtractToRef(x,Y),Y.normalize(),U.CrossToRef(F,Y,G);const j=G.lengthSquared();0===j?G.x=1:G.normalizeFromLength(Math.sqrt(j)),U.CrossToRef(Y,G,f),f.normalize();const d=-U.Dot(G,Z),t=-U.Dot(f,Z),o=-U.Dot(Y,Z);return m.FromValuesToRef(G._x,f._x,Y._x,0,G._y,f._y,Y._y,0,G._z,f._z,Y._z,0,d,t,o,1,u),u}static LookDirectionLH(Z,x){const F=new m;return m.LookDirectionLHToRef(Z,x,F),F}static LookDirectionLHToRef(Z,x,F){const u=C.kx[0];u.G(Z),u.scaleInPlace(-1);const G=C.kx[1];return U.CrossToRef(x,u,G),m.FromValuesToRef(G._x,G._y,G._z,0,x._x,x._y,x._z,0,u._x,u._y,u._z,0,0,0,0,1,F),F}static LookDirectionRH(Z,x){const F=new m;return m.LookDirectionRHToRef(Z,x,F),F}static LookDirectionRHToRef(Z,x,F){const u=C.kx[2];return U.CrossToRef(x,Z,u),m.FromValuesToRef(u._x,u._y,u._z,0,x._x,x._y,x._z,0,Z._x,Z._y,Z._z,0,0,0,0,1,F),F}static OrthoLH(Z,x,F,u,G){const f=new m;return m.OrthoLHToRef(Z,x,F,u,f,G),f}static OrthoLHToRef(Z,x,F,u,G,f){const Y=2/Z,j=2/x,d=2/(u-F),t=-(u+F)/(u-F);return m.FromValuesToRef(Y,0,0,0,0,j,0,0,0,0,d,0,0,0,t,1,G),f&&G.multiplyToRef(H,G),G._updateIdentityStatus(1===Y&&1===j&&1===d&&0===t),G}static OrthoOffCenterLH(Z,x,F,u,G,f,Y){const j=new m;return m.OrthoOffCenterLHToRef(Z,x,F,u,G,f,j,Y),j}static OrthoOffCenterLHToRef(Z,x,F,u,G,f,Y,j){const d=2/(x-Z),t=2/(u-F),o=2/(f-G),c=-(f+G)/(f-G),s=(Z+x)/(Z-x),J=(u+F)/(F-u);return m.FromValuesToRef(d,0,0,0,0,t,0,0,0,0,o,0,s,J,c,1,Y),j&&Y.multiplyToRef(H,Y),Y.markAsUpdated(),Y}static ObliqueOffCenterLHToRef(Z,x,F,u,G,f,Y,j,d,t,o){const c=-Y*Math.cos(j),s=-Y*Math.sin(j);return m.TranslationToRef(0,0,-d,C.Matrix[1]),m.FromValuesToRef(1,0,0,0,0,1,0,0,c,s,1,0,0,0,0,1,C.Matrix[0]),C.Matrix[1].multiplyToRef(C.Matrix[0],C.Matrix[0]),m.TranslationToRef(0,0,d,C.Matrix[1]),C.Matrix[0].multiplyToRef(C.Matrix[1],C.Matrix[0]),m.OrthoOffCenterLHToRef(Z,x,F,u,G,f,t,o),C.Matrix[0].multiplyToRef(t,t),t}static OrthoOffCenterRH(Z,x,F,u,G,f,Y){const j=new m;return m.OrthoOffCenterRHToRef(Z,x,F,u,G,f,j,Y),j}static OrthoOffCenterRHToRef(Z,x,F,u,G,f,Y,j){return m.OrthoOffCenterLHToRef(Z,x,F,u,G,f,Y,j),Y.Mf[10]*=-1,Y}static ObliqueOffCenterRHToRef(Z,x,F,u,G,f,Y,j,d,t,o){const c=Y*Math.cos(j),s=Y*Math.sin(j);return m.TranslationToRef(0,0,d,C.Matrix[1]),m.FromValuesToRef(1,0,0,0,0,1,0,0,c,s,1,0,0,0,0,1,C.Matrix[0]),C.Matrix[1].multiplyToRef(C.Matrix[0],C.Matrix[0]),m.TranslationToRef(0,0,-d,C.Matrix[1]),C.Matrix[0].multiplyToRef(C.Matrix[1],C.Matrix[0]),m.OrthoOffCenterRHToRef(Z,x,F,u,G,f,t,o),C.Matrix[0].multiplyToRef(t,t),t}static PerspectiveLH(Z,x,F,u,G){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const Y=new m,j=2*F/Z,d=2*F/x,t=(u+F)/(u-F),o=-2*u*F/(u-F),c=Math.tan(f);return m.FromValuesToRef(j,0,0,0,0,d,0,c,0,0,t,1,0,0,o,0,Y),G&&Y.multiplyToRef(H,Y),Y._updateIdentityStatus(!1),Y}static PerspectiveFovLH(Z,x,F,u,G){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const j=new m;return m.PerspectiveFovLHToRef(Z,x,F,u,j,!0,G,f,Y),j}static PerspectiveFovLHToRef(Z,x,F,u,G){let f=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,j=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,d=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const t=F,o=u,c=1/Math.tan(.5*Z),s=f?c/x:c,J=f?c:c*x,p=d&&0===t?-1:0!==o?(o+t)/(o-t):1,U=d&&0===t?2*o:0!==o?-2*o*t/(o-t):-2*t,k=Math.tan(j);return m.FromValuesToRef(s,0,0,0,0,J,0,k,0,0,p,1,0,0,U,0,G),Y&&G.multiplyToRef(H,G),G._updateIdentityStatus(!1),G}static PerspectiveFovReverseLHToRef(Z,x,F,u,G){let f=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,j=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const d=1/Math.tan(.5*Z),t=f?d/x:d,o=f?d:d*x,c=Math.tan(j);return m.FromValuesToRef(t,0,0,0,0,o,0,c,0,0,-F,1,0,0,1,0,G),Y&&G.multiplyToRef(H,G),G._updateIdentityStatus(!1),G}static PerspectiveFovRH(Z,x,F,u,G){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const j=new m;return m.PerspectiveFovRHToRef(Z,x,F,u,j,!0,G,f,Y),j}static PerspectiveFovRHToRef(Z,x,F,u,G){let f=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,j=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,d=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const t=F,o=u,c=1/Math.tan(.5*Z),s=f?c/x:c,J=f?c:c*x,p=d&&0===t?1:0!==o?-(o+t)/(o-t):-1,U=d&&0===t?2*o:0!==o?-2*o*t/(o-t):-2*t,k=Math.tan(j);return m.FromValuesToRef(s,0,0,0,0,J,0,k,0,0,p,-1,0,0,U,0,G),Y&&G.multiplyToRef(H,G),G._updateIdentityStatus(!1),G}static PerspectiveFovReverseRHToRef(Z,x,F,u,G){let f=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,j=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const d=1/Math.tan(.5*Z),t=f?d/x:d,o=f?d:d*x,c=Math.tan(j);return m.FromValuesToRef(t,0,0,0,0,o,0,c,0,0,-F,-1,0,0,-1,0,G),Y&&G.multiplyToRef(H,G),G._updateIdentityStatus(!1),G}static GetFinalMatrix(Z,x,F,u,G,f){const Y=Z.width,j=Z.height,d=Z.x,t=Z.y,o=m.FromValues(Y/2,0,0,0,0,-j/2,0,0,0,0,f-G,0,d+Y/2,j/2+t,G,1),c=new m;return x.multiplyToRef(F,c),c.multiplyToRef(u,c),c.multiplyToRef(o,c)}static GetAsMatrix2x2(Z){const x=Z.m,F=[x[0],x[1],x[4],x[5]];return Y.b.MatrixUse64Bits?F:new Float32Array(F)}static GetAsMatrix3x3(Z){const x=Z.m,F=[x[0],x[1],x[2],x[4],x[5],x[6],x[8],x[9],x[10]];return Y.b.MatrixUse64Bits?F:new Float32Array(F)}static Transpose(Z){const x=new m;return m.TransposeToRef(Z,x),x}static TransposeToRef(Z,x){const F=Z.m,u=F[0],G=F[4],f=F[8],Y=F[12],j=F[1],d=F[5],t=F[9],o=F[13],c=F[2],s=F[6],J=F[10],p=F[14],U=F[3],k=F[7],M=F[11],m=F[15],C=x.Mf;return C[0]=u,C[1]=G,C[2]=f,C[3]=Y,C[4]=j,C[5]=d,C[6]=t,C[7]=o,C[8]=c,C[9]=s,C[10]=J,C[11]=p,C[12]=U,C[13]=k,C[14]=M,C[15]=m,x.markAsUpdated(),x._updateIdentityStatus(Z._isIdentity,Z._isIdentityDirty),x}static Reflection(Z){const x=new m;return m.ReflectionToRef(Z,x),x}static ReflectionToRef(Z,x){Z.normalize();const F=Z.normal.x,u=Z.normal.y,G=Z.normal.z,f=-2*F,Y=-2*u,j=-2*G;return m.FromValuesToRef(f*F+1,Y*F,j*F,0,f*u,Y*u+1,j*u,0,f*G,Y*G,j*G+1,0,f*Z.d,Y*Z.d,j*Z.d,1,x),x}static FromXYZAxesToRef(Z,x,F,u){return m.FromValuesToRef(Z._x,Z._y,Z._z,0,x._x,x._y,x._z,0,F._x,F._y,F._z,0,0,0,0,1,u),u}static FromQuaternionToRef(Z,x){const F=Z._x*Z._x,u=Z._y*Z._y,G=Z._z*Z._z,f=Z._x*Z._y,Y=Z._z*Z._w,j=Z._z*Z._x,d=Z._y*Z._w,t=Z._y*Z._z,o=Z._x*Z._w;return x.Mf[0]=1-2*(u+G),x.Mf[1]=2*(f+Y),x.Mf[2]=2*(j-d),x.Mf[3]=0,x.Mf[4]=2*(f-Y),x.Mf[5]=1-2*(G+F),x.Mf[6]=2*(t+o),x.Mf[7]=0,x.Mf[8]=2*(j+d),x.Mf[9]=2*(t-o),x.Mf[10]=1-2*(u+F),x.Mf[11]=0,x.Mf[12]=0,x.Mf[13]=0,x.Mf[14]=0,x.Mf[15]=1,x.markAsUpdated(),x}}m._IdentityReadOnly=m.Identity(),Object.defineProperties(m.prototype,{dimension:{value:[4,4]},rank:{value:2}});class C{}C.kx=(0,G.d)(11,U.Zero),C.Matrix=(0,G.d)(2,m.Identity),C.Quaternion=(0,G.d)(3,M.Zero);class L{}L.Vector2=(0,G.d)(3,p.Zero),L.kx=(0,G.d)(13,U.Zero),L.Vector4=(0,G.d)(3,k.Zero),L.Quaternion=(0,G.d)(3,M.Zero),L.Matrix=(0,G.d)(8,m.Identity),(0,f.g)("BABYLON.Vector2",p),(0,f.g)("BABYLON.Vector3",U),(0,f.g)("BABYLON.Vector4",k),(0,f.g)("BABYLON.Matrix",m);const H=m.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11192:(Z,x,F)=>{function u(Z,x){const F=[];for(let u=0;u<Z;++u)F.push(x());return F}function G(Z,x){return u(Z,x)}F.d(x,{b:()=>u,d:()=>G,e:()=>Y});const f=["push","splice","pop","shift","unshift"];function Y(Z,x){const F=f.map((F=>function(Z,x,F){const u=Z[x];if("function"!==typeof u)return null;const G=function(){const u=Z.length,f=G.previous.apply(Z,arguments);return F(x,u),f};return u.next=G,G.previous=u,Z[x]=G,()=>{const F=G.previous;if(!F)return;const u=G.next;u?(F.next=u,u.previous=F):(F.next=void 0,Z[x]=F),G.next=void 0,G.previous=void 0}}(Z,F,x)));return()=>{for(const Z of F)null===Z||void 0===Z||Z()}}}}]);