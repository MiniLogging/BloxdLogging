"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{11188:(g,w,q)=>{q.d(w,{c:()=>S,d:()=>r,f:()=>R,h:()=>o});const R=1/2.2,o=2.2,r=(1+Math.sqrt(5))/2,S=.001},11195:(g,w,q)=>{function R(g){return parseInt(g.toString().replace(/\W/g,""))}function o(g,w){let q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(g-w)<=q}function r(g,w,q){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return g<w-R||g>q+R}function S(g,w){return g===w?g:Math.random()*(w-g)+g}function i(g,w,q){return g+(w-g)*q}function T(g,w,q){let R=l(w-g,360);return R>180&&(R-=360),g+R*e(q)}function z(g,w,q){let R=0;return R=g!=w?e((q-g)/(w-g)):0,R}function t(g,w,q,R,o){const r=o*o,S=o*r;return g*(2*S-3*r+1)+q*(-2*S+3*r)+w*(S-2*r+o)+R*(S-r)}function m(g,w,q,R,o){const r=o*o;return 6*(r-o)*g+(3*r-4*o+1)*w+6*(-r+o)*q+(3*r-2*o)*R}function e(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(q,Math.max(w,g))}function y(g){return g-=2*Math.PI*Math.floor((g+Math.PI)/(2*Math.PI))}function L(g){const w=g.toString(16);return g<=15?("0"+w).toUpperCase():w.toUpperCase()}function A(g){if(Math.log2)return Math.floor(Math.log2(g));if(g<0)return NaN;if(0===g)return-1/0;let w=0;if(g<1){for(;g<1;)w++,g*=2;w=-w}else if(g>1)for(;g>1;)w++,g=Math.floor(g/2);return w}function l(g,w){return g-Math.floor(g/w)*w}function J(g,w,q){return(g-w)/(q-w)}function x(g,w,q){return g*(q-w)+w}function G(g,w){let q=l(w-g,360);return q>180&&(q-=360),q}function d(g,w){const q=l(g,2*w);return w-Math.abs(q-w)}function D(g,w,q){let R=e(q);return R=-2*R*R*R+3*R*R,w*R+g*(1-R)}function U(g,w,q){let R=0;return R=Math.abs(w-g)<=q?w:g+Math.sign(w-g)*q,R}function N(g,w,q){const R=G(g,w);let o=0;return o=-q<R&&R<q?w:U(g,w=g+R,q),o}function a(g,w,q){return(g-w)/(q-w)}function H(g,w,q){return(q-w)*g+w}function C(g,w){const q=g%w;return 0===q?w:C(w,q)}q.r(w),q.d(w,{Clamp:()=>e,DeltaAngle:()=>G,Denormalize:()=>x,ExtractAsInt:()=>R,Hermite:()=>t,Hermite1stDerivative:()=>m,HighestCommonFactor:()=>C,ILog2:()=>A,InverseLerp:()=>z,Lerp:()=>i,LerpAngle:()=>T,MoveTowards:()=>U,MoveTowardsAngle:()=>N,Normalize:()=>J,NormalizeRadians:()=>y,OutsideRange:()=>r,PercentToRange:()=>H,PingPong:()=>d,RandomRange:()=>S,RangeToPercent:()=>a,Repeat:()=>l,SmoothStep:()=>D,ToHex:()=>L,WithinEpsilon:()=>o})},11180:(g,w,q)=>{q.r(w),q.d(w,{Matrix:()=>x,Quaternion:()=>J,TmpVectors:()=>d,Vector2:()=>L,ew:()=>A,Vector4:()=>l});var R=q(11188),o=q(11192),r=q(11128),S=q(11101),i=q(11034),T=q(11195);class z{}function t(g,w,q){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const o=g.qi(),r=w.qi(),S=o[0],i=o[1],T=o[2],z=o[3],t=o[4],m=o[5],e=o[6],y=o[7],L=o[8],A=o[9],l=o[10],J=o[11],x=o[12],G=o[13],d=o[14],D=o[15],U=r[0],N=r[1],a=r[2],H=r[3],C=r[4],c=r[5],P=r[6],j=r[7],M=r[8],V=r[9],s=r[10],h=r[11],v=r[12],b=r[13],B=r[14],f=r[15];q[R]=S*U+i*C+T*M+z*v,q[R+1]=S*N+i*c+T*V+z*b,q[R+2]=S*a+i*P+T*s+z*B,q[R+3]=S*H+i*j+T*h+z*f,q[R+4]=t*U+m*C+e*M+y*v,q[R+5]=t*N+m*c+e*V+y*b,q[R+6]=t*a+m*P+e*s+y*B,q[R+7]=t*H+m*j+e*h+y*f,q[R+8]=L*U+A*C+l*M+J*v,q[R+9]=L*N+A*c+l*V+J*b,q[R+10]=L*a+A*P+l*s+J*B,q[R+11]=L*H+A*j+l*h+J*f,q[R+12]=x*U+G*C+d*M+D*v,q[R+13]=x*N+G*c+d*V+D*b,q[R+14]=x*a+G*P+d*s+D*B,q[R+15]=x*H+G*j+d*h+D*f}function m(g,w){let q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const R=g.qi();w[q]=R[0],w[q+1]=R[1],w[q+2]=R[2],w[q+3]=R[3],w[q+4]=R[4],w[q+5]=R[5],w[q+6]=R[6],w[q+7]=R[7],w[q+8]=R[8],w[q+9]=R[9],w[q+10]=R[10],w[q+11]=R[11],w[q+12]=R[12],w[q+13]=R[13],w[q+14]=R[14],w[q+15]=R[15]}function e(g,w){const q=g.qi(),R=q[0],o=q[1],r=q[2],S=q[3],i=q[4],T=q[5],z=q[6],t=q[7],m=q[8],e=q[9],y=q[10],L=q[11],A=q[12],l=q[13],J=q[14],x=q[15],G=y*x-J*L,d=e*x-l*L,D=e*J-l*y,U=m*x-A*L,N=m*J-y*A,a=m*l-A*e,H=+(T*G-z*d+t*D),C=-(i*G-z*U+t*N),c=+(i*d-T*U+t*a),P=-(i*D-T*N+z*a),j=R*H+o*C+r*c+S*P;if(0===j)return!1;const M=1/j,V=z*x-J*t,s=T*x-l*t,h=T*J-l*z,v=i*x-A*t,b=i*J-A*z,B=i*l-A*T,f=z*L-y*t,O=T*L-e*t,E=T*y-e*z,Q=i*L-m*t,X=i*y-m*z,K=i*e-m*T,Y=-(o*G-r*d+S*D),F=+(R*G-r*U+S*N),u=-(R*d-o*U+S*a),n=+(R*D-o*N+r*a),W=+(o*V-r*s+S*h),p=-(R*V-r*v+S*b),Z=+(R*s-o*v+S*B),I=-(R*h-o*b+r*B),k=-(o*f-r*O+S*E),gg=+(R*f-r*Q+S*X),wg=-(R*O-o*Q+S*K),qg=+(R*E-o*X+r*K);return w[0]=H*M,w[1]=Y*M,w[2]=W*M,w[3]=k*M,w[4]=C*M,w[5]=F*M,w[6]=p*M,w[7]=gg*M,w[8]=c*M,w[9]=u*M,w[10]=Z*M,w[11]=wg*M,w[12]=P*M,w[13]=n*M,w[14]=I*M,w[15]=qg*M,!0}z._UpdateFlagSeed=0;const y=g=>parseInt(g.toString().replace(/\W/g,""));class L{constructor(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=g,this.y=w}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let g=y(this.x);return g=397*g^y(this.y),g}toArray(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g[w]=this.x,g[w+1]=this.y,this}yq(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(g,w,this),this}qi(){return[this.x,this.y]}T(g){return this.x=g.x,this.y=g.y,this}mi(g,w){return this.x=g,this.y=w,this}set(g,w){return this.mi(g,w)}yi(g){return this.mi(g,g)}add(g){return new L(this.x+g.x,this.y+g.y)}addToRef(g,w){return w.x=this.x+g.x,w.y=this.y+g.y,w}addInPlace(g){return this.x+=g.x,this.y+=g.y,this}addInPlaceFromFloats(g,w){return this.x+=g,this.y+=w,this}addVector3(g){return new L(this.x+g.x,this.y+g.y)}yw(g){return new L(this.x-g.x,this.y-g.y)}subtractToRef(g,w){return w.x=this.x-g.x,w.y=this.y-g.y,w}Yt(g){return this.x-=g.x,this.y-=g.y,this}multiplyInPlace(g){return this.x*=g.x,this.y*=g.y,this}multiply(g){return new L(this.x*g.x,this.y*g.y)}multiplyToRef(g,w){return w.x=this.x*g.x,w.y=this.y*g.y,w}multiplyByFloats(g,w){return new L(this.x*g,this.y*w)}divide(g){return new L(this.x/g.x,this.y/g.y)}divideToRef(g,w){return w.x=this.x/g.x,w.y=this.y/g.y,w}divideInPlace(g){return this.x=this.x/g.x,this.y=this.y/g.y,this}minimizeInPlace(g){return this.minimizeInPlaceFromFloats(g.x,g.y)}maximizeInPlace(g){return this.maximizeInPlaceFromFloats(g.x,g.y)}minimizeInPlaceFromFloats(g,w){return this.x=Math.min(g,this.x),this.y=Math.min(w,this.y),this}maximizeInPlaceFromFloats(g,w){return this.x=Math.max(g,this.x),this.y=Math.max(w,this.y),this}subtractFromFloats(g,w){return new L(this.x-g,this.y-w)}subtractFromFloatsToRef(g,w,q){return q.x=this.x-g,q.y=this.y-w,q}negate(){return new L(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(g){return g.x=-this.x,g.y=-this.y,g}scaleInPlace(g){return this.x*=g,this.y*=g,this}scale(g){return new L(this.x*g,this.y*g)}scaleToRef(g,w){return w.x=this.x*g,w.y=this.y*g,w}scaleAndAddToRef(g,w){return w.x+=this.x*g,w.y+=this.y*g,w}equals(g){return g&&this.x===g.x&&this.y===g.y}equalsWithEpsilon(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.c;return g&&(0,T.WithinEpsilon)(this.x,g.x,w)&&(0,T.WithinEpsilon)(this.y,g.y,w)}equalsToFloats(g,w){return this.x===g&&this.y===w}floor(){return new L(Math.floor(this.x),Math.floor(this.y))}floorToRef(g){return g.x=Math.floor(this.x),g.y=Math.floor(this.y),g}fract(){return new L(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(g){return g.x=this.x-Math.floor(this.x),g.y=this.y-Math.floor(this.y),g}rotate(g){return this.rotateToRef(g,new L)}rotateToRef(g,w){const q=Math.cos(g),R=Math.sin(g);return w.x=q*this.x-R*this.y,w.y=R*this.x+q*this.y,w}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(g){return 0===g||1===g?this:this.scaleInPlace(1/g)}normalizeToNew(){const g=new L;return this.normalizeToRef(g),g}normalizeToRef(g){const w=this.length();return 0===w&&(g.x=this.x,g.y=this.y),this.scaleToRef(1/w,g)}clone(){return new L(this.x,this.y)}dot(g){return this.x*g.x+this.y*g.y}static Zero(){return new L(0,0)}static One(){return new L(1,1)}static Random(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new L((0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w))}static RandomToRef(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).mi((0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w))}static get ZeroReadOnly(){return L._ZeroReadOnly}static Ri(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new L(g[w],g[w+1])}static FromArrayToRef(g,w,q){return q.x=g[w],q.y=g[w+1],q}static FromFloatsToRef(g,w,q){return q.mi(g,w),q}static CatmullRom(g,w,q,R,o){const r=o*o,S=o*r,i=.5*(2*w.x+(-g.x+q.x)*o+(2*g.x-5*w.x+4*q.x-R.x)*r+(-g.x+3*w.x-3*q.x+R.x)*S),T=.5*(2*w.y+(-g.y+q.y)*o+(2*g.y-5*w.y+4*q.y-R.y)*r+(-g.y+3*w.y-3*q.y+R.y)*S);return new L(i,T)}static ClampToRef(g,w,q,R){return R.x=(0,T.Clamp)(g.x,w.x,q.x),R.y=(0,T.Clamp)(g.y,w.y,q.y),R}static Clamp(g,w,q){const R=(0,T.Clamp)(g.x,w.x,q.x),o=(0,T.Clamp)(g.y,w.y,q.y);return new L(R,o)}static Hermite(g,w,q,R,o){const r=o*o,S=o*r,i=2*S-3*r+1,T=-2*S+3*r,z=S-2*r+o,t=S-r,m=g.x*i+q.x*T+w.x*z+R.x*t,e=g.y*i+q.y*T+w.y*z+R.y*t;return new L(m,e)}static Hermite1stDerivative(g,w,q,R,o){return this.Hermite1stDerivativeToRef(g,w,q,R,o,new L)}static Hermite1stDerivativeToRef(g,w,q,R,o,r){const S=o*o;return r.x=6*(S-o)*g.x+(3*S-4*o+1)*w.x+6*(-S+o)*q.x+(3*S-2*o)*R.x,r.y=6*(S-o)*g.y+(3*S-4*o+1)*w.y+6*(-S+o)*q.y+(3*S-2*o)*R.y,r}static Lerp(g,w,q){return L.LerpToRef(g,w,q,new L)}static LerpToRef(g,w,q,R){return R.x=g.x+(w.x-g.x)*q,R.y=g.y+(w.y-g.y)*q,R}static Dot(g,w){return g.x*w.x+g.y*w.y}static Normalize(g){return L.NormalizeToRef(g,new L)}static NormalizeToRef(g,w){return g.normalizeToRef(w),w}static Minimize(g,w){const q=g.x<w.x?g.x:w.x,R=g.y<w.y?g.y:w.y;return new L(q,R)}static Maximize(g,w){const q=g.x>w.x?g.x:w.x,R=g.y>w.y?g.y:w.y;return new L(q,R)}static Transform(g,w){return L.TransformToRef(g,w,new L)}static TransformToRef(g,w,q){const R=w.m,o=g.x*R[0]+g.y*R[4]+R[12],r=g.x*R[1]+g.y*R[5]+R[13];return q.x=o,q.y=r,q}static PointInTriangle(g,w,q,R){const o=.5*(-q.y*R.x+w.y*(-q.x+R.x)+w.x*(q.y-R.y)+q.x*R.y),r=o<0?-1:1,S=(w.y*R.x-w.x*R.y+(R.y-w.y)*g.x+(w.x-R.x)*g.y)*r,i=(w.x*q.y-w.y*q.x+(w.y-q.y)*g.x+(q.x-w.x)*g.y)*r;return S>0&&i>0&&S+i<2*o*r}static Distance(g,w){return Math.sqrt(L.DistanceSquared(g,w))}static DistanceSquared(g,w){const q=g.x-w.x,R=g.y-w.y;return q*q+R*R}static Center(g,w){return L.CenterToRef(g,w,new L)}static CenterToRef(g,w,q){return q.mi((g.x+w.x)/2,(g.y+w.y)/2)}static DistanceOfPointFromSegment(g,w,q){const R=L.DistanceSquared(w,q);if(0===R)return L.Distance(g,w);const o=q.yw(w),r=Math.max(0,Math.min(1,L.Dot(g.yw(w),o)/R)),S=w.add(o.multiplyByFloats(r,r));return L.Distance(g,S)}}L._V8PerformanceHack=new L(.5,.5),L._ZeroReadOnly=L.Zero(),Object.defineProperties(L.prototype,{dimension:{value:[2]},rank:{value:1}});class A{get x(){return this._x}set x(g){this._x=g,this._isDirty=!0}get y(){return this._y}set y(g){this._y=g,this._isDirty=!0}get z(){return this._z}set z(g){this._z=g,this._isDirty=!0}constructor(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=g,this._y=w,this._z=q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"ew"}getHashCode(){let g=y(this._x);return g=397*g^y(this._y),g=397*g^y(this._z),g}qi(){return[this._x,this._y,this._z]}toArray(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g[w]=this._x,g[w+1]=this._y,g[w+2]=this._z,this}yq(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return A.FromArrayToRef(g,w,this),this}toQuaternion(){return J.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(g){return this._x+=g._x,this._y+=g._y,this._z+=g._z,this._isDirty=!0,this}addInPlaceFromFloats(g,w,q){return this._x+=g,this._y+=w,this._z+=q,this._isDirty=!0,this}add(g){return new A(this._x+g._x,this._y+g._y,this._z+g._z)}addToRef(g,w){return w._x=this._x+g._x,w._y=this._y+g._y,w._z=this._z+g._z,w._isDirty=!0,w}Yt(g){return this._x-=g._x,this._y-=g._y,this._z-=g._z,this._isDirty=!0,this}yw(g){return new A(this._x-g._x,this._y-g._y,this._z-g._z)}subtractToRef(g,w){return this.subtractFromFloatsToRef(g._x,g._y,g._z,w)}subtractFromFloats(g,w,q){return new A(this._x-g,this._y-w,this._z-q)}subtractFromFloatsToRef(g,w,q,R){return R._x=this._x-g,R._y=this._y-w,R._z=this._z-q,R._isDirty=!0,R}negate(){return new A(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(g){return g._x=-1*this._x,g._y=-1*this._y,g._z=-1*this._z,g._isDirty=!0,g}scaleInPlace(g){return this._x*=g,this._y*=g,this._z*=g,this._isDirty=!0,this}scale(g){return new A(this._x*g,this._y*g,this._z*g)}scaleToRef(g,w){return w._x=this._x*g,w._y=this._y*g,w._z=this._z*g,w._isDirty=!0,w}getNormalToRef(g){const w=this.length();let q=Math.acos(this._y/w);const R=Math.atan2(this._z,this._x);q>Math.PI/2?q-=Math.PI/2:q+=Math.PI/2;const o=w*Math.sin(q)*Math.cos(R),r=w*Math.cos(q),S=w*Math.sin(q)*Math.sin(R);return g.set(o,r,S),g}applyRotationQuaternionToRef(g,w){const q=this._x,R=this._y,o=this._z,r=g._x,S=g._y,i=g._z,T=g._w,z=2*(S*o-i*R),t=2*(i*q-r*o),m=2*(r*R-S*q);return w._x=q+T*z+S*m-i*t,w._y=R+T*t+i*z-r*m,w._z=o+T*m+r*t-S*z,w._isDirty=!0,w}applyRotationQuaternionInPlace(g){return this.applyRotationQuaternionToRef(g,this)}applyRotationQuaternion(g){return this.applyRotationQuaternionToRef(g,new A)}scaleAndAddToRef(g,w){return w._x+=this._x*g,w._y+=this._y*g,w._z+=this._z*g,w._isDirty=!0,w}projectOnPlane(g,w){return this.projectOnPlaneToRef(g,w,new A)}projectOnPlaneToRef(g,w,q){const R=g.Lw,o=g.d,r=G.ew[0];this.subtractToRef(w,r),r.normalize();const S=A.Dot(r,R);if(Math.abs(S)<1e-10)q.yi(1/0);else{const g=-(A.Dot(w,R)+o)/S,i=r.scaleInPlace(g);w.addToRef(i,q)}return q}equals(g){return g&&this._x===g._x&&this._y===g._y&&this._z===g._z}equalsWithEpsilon(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.c;return g&&(0,T.WithinEpsilon)(this._x,g._x,w)&&(0,T.WithinEpsilon)(this._y,g._y,w)&&(0,T.WithinEpsilon)(this._z,g._z,w)}equalsToFloats(g,w,q){return this._x===g&&this._y===w&&this._z===q}multiplyInPlace(g){return this._x*=g._x,this._y*=g._y,this._z*=g._z,this._isDirty=!0,this}multiply(g){return this.multiplyByFloats(g._x,g._y,g._z)}multiplyToRef(g,w){return w._x=this._x*g._x,w._y=this._y*g._y,w._z=this._z*g._z,w._isDirty=!0,w}multiplyByFloats(g,w,q){return new A(this._x*g,this._y*w,this._z*q)}divide(g){return new A(this._x/g._x,this._y/g._y,this._z/g._z)}divideToRef(g,w){return w._x=this._x/g._x,w._y=this._y/g._y,w._z=this._z/g._z,w._isDirty=!0,w}divideInPlace(g){return this._x=this._x/g._x,this._y=this._y/g._y,this._z=this._z/g._z,this._isDirty=!0,this}minimizeInPlace(g){return this.minimizeInPlaceFromFloats(g._x,g._y,g._z)}maximizeInPlace(g){return this.maximizeInPlaceFromFloats(g._x,g._y,g._z)}minimizeInPlaceFromFloats(g,w,q){return g<this._x&&(this.x=g),w<this._y&&(this.y=w),q<this._z&&(this.z=q),this}maximizeInPlaceFromFloats(g,w,q){return g>this._x&&(this.x=g),w>this._y&&(this.y=w),q>this._z&&(this.z=q),this}isNonUniformWithinEpsilon(g){const w=Math.abs(this._x),q=Math.abs(this._y);if(!(0,T.WithinEpsilon)(w,q,g))return!0;const R=Math.abs(this._z);return!(0,T.WithinEpsilon)(w,R,g)||!(0,T.WithinEpsilon)(q,R,g)}get isNonUniform(){const g=Math.abs(this._x);if(g!==Math.abs(this._y))return!0;return g!==Math.abs(this._z)}floorToRef(g){return g._x=Math.floor(this._x),g._y=Math.floor(this._y),g._z=Math.floor(this._z),g._isDirty=!0,g}floor(){return new A(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(g){return g._x=this._x-Math.floor(this._x),g._y=this._y-Math.floor(this._y),g._z=this._z-Math.floor(this._z),g._isDirty=!0,g}fract(){return new A(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(g){if("xyz"===(g=g.toLowerCase()))return this;const w=G.ew[0].T(this);return this.x=w[g[0]],this.y=w[g[1]],this.z=w[g[2]],this}rotateByQuaternionToRef(g,w){return g.toRotationMatrix(G.Matrix[0]),A.TransformCoordinatesToRef(this,G.Matrix[0],w),w}rotateByQuaternionAroundPointToRef(g,w,q){return this.subtractToRef(w,G.ew[0]),G.ew[0].rotateByQuaternionToRef(g,G.ew[0]),w.addToRef(G.ew[0],q),q}cross(g){return A.CrossToRef(this,g,new A)}normalizeFromLength(g){return 0===g||1===g?this:this.scaleInPlace(1/g)}normalizeToNew(){return this.normalizeToRef(new A)}normalizeToRef(g){const w=this.length();return 0===w||1===w?(g._x=this._x,g._y=this._y,g._z=this._z,g._isDirty=!0,g):this.scaleToRef(1/w,g)}clone(){return new A(this._x,this._y,this._z)}T(g){return this.mi(g._x,g._y,g._z)}mi(g,w,q){return this._x=g,this._y=w,this._z=q,this._isDirty=!0,this}set(g,w,q){return this.mi(g,w,q)}yi(g){return this._x=this._y=this._z=g,this._isDirty=!0,this}static GetClipFactor(g,w,q,R){const o=A.Dot(g,q);return(o-R)/(o-A.Dot(w,q))}static GetAngleBetweenVectors(g,w,q){const R=g.normalizeToRef(G.ew[1]),o=w.normalizeToRef(G.ew[2]);let r=A.Dot(R,o);r=(0,T.Clamp)(r,-1,1);const S=Math.acos(r),i=G.ew[3];return A.CrossToRef(R,o,i),A.Dot(i,q)>0?isNaN(S)?0:S:isNaN(S)?-Math.PI:-Math.acos(r)}static GetAngleBetweenVectorsOnPlane(g,w,q){G.ew[0].T(g);const R=G.ew[0];G.ew[1].T(w);const o=G.ew[1];G.ew[2].T(q);const r=G.ew[2],S=G.ew[3],i=G.ew[4];R.normalize(),o.normalize(),r.normalize(),A.CrossToRef(r,R,S),A.CrossToRef(S,r,i);const z=Math.atan2(A.Dot(o,S),A.Dot(o,i));return(0,T.NormalizeRadians)(z)}static PitchYawRollToMoveBetweenPointsToRef(g,w,q){const R=d.ew[0];return w.subtractToRef(g,R),q._y=Math.atan2(R.x,R.z)||0,q._x=Math.atan2(Math.sqrt(R.x**2+R.z**2),R.y)||0,q._z=0,q._isDirty=!0,q}static PitchYawRollToMoveBetweenPoints(g,w){const q=A.Zero();return A.PitchYawRollToMoveBetweenPointsToRef(g,w,q)}static SlerpToRef(g,w,q,o){q=(0,T.Clamp)(q,0,1);const r=G.ew[0],S=G.ew[1];r.T(g);const i=r.length();r.normalizeFromLength(i),S.T(w);const z=S.length();S.normalizeFromLength(z);const t=A.Dot(r,S);let m,e;if(t<1-R.c){const g=Math.acos(t),w=1/Math.sin(g);m=Math.sin((1-q)*g)*w,e=Math.sin(q*g)*w}else m=1-q,e=q;return r.scaleInPlace(m),S.scaleInPlace(e),o.T(r).addInPlace(S),o.scaleInPlace((0,T.Lerp)(i,z,q)),o}static SmoothToRef(g,w,q,R,o){return A.SlerpToRef(g,w,0===R?1:q/R,o),o}static Ri(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new A(g[w],g[w+1],g[w+2])}static FromFloatArray(g,w){return A.Ri(g,w)}static FromArrayToRef(g,w,q){return q._x=g[w],q._y=g[w+1],q._z=g[w+2],q._isDirty=!0,q}static FromFloatArrayToRef(g,w,q){return A.FromArrayToRef(g,w,q)}static FromFloatsToRef(g,w,q,R){return R.mi(g,w,q),R}static Zero(){return new A(0,0,0)}static One(){return new A(1,1,1)}static Up(){return new A(0,1,0)}static get UpReadOnly(){return A._UpReadOnly}static get DownReadOnly(){return A._DownReadOnly}static get RightReadOnly(){return A._RightReadOnly}static get LeftReadOnly(){return A._LeftReadOnly}static get LeftHandedForwardReadOnly(){return A._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return A._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return A._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return A._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return A._ZeroReadOnly}static get OneReadOnly(){return A._OneReadOnly}static Down(){return new A(0,-1,0)}static Forward(){return new A(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new A(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new A(1,0,0)}static Left(){return new A(-1,0,0)}static Random(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new A((0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w))}static RandomToRef(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).mi((0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w))}static TransformCoordinates(g,w){const q=A.Zero();return A.TransformCoordinatesToRef(g,w,q),q}static TransformCoordinatesToRef(g,w,q){return A.TransformCoordinatesFromFloatsToRef(g._x,g._y,g._z,w,q),q}static TransformCoordinatesFromFloatsToRef(g,w,q,R,o){const r=R.m,S=g*r[0]+w*r[4]+q*r[8]+r[12],i=g*r[1]+w*r[5]+q*r[9]+r[13],T=g*r[2]+w*r[6]+q*r[10]+r[14],z=1/(g*r[3]+w*r[7]+q*r[11]+r[15]);return o._x=S*z,o._y=i*z,o._z=T*z,o._isDirty=!0,o}static TransformNormal(g,w){const q=A.Zero();return A.TransformNormalToRef(g,w,q),q}static TransformNormalToRef(g,w,q){return this.TransformNormalFromFloatsToRef(g._x,g._y,g._z,w,q),q}static TransformNormalFromFloatsToRef(g,w,q,R,o){const r=R.m;return o._x=g*r[0]+w*r[4]+q*r[8],o._y=g*r[1]+w*r[5]+q*r[9],o._z=g*r[2]+w*r[6]+q*r[10],o._isDirty=!0,o}static CatmullRom(g,w,q,R,o){const r=o*o,S=o*r,i=.5*(2*w._x+(-g._x+q._x)*o+(2*g._x-5*w._x+4*q._x-R._x)*r+(-g._x+3*w._x-3*q._x+R._x)*S),T=.5*(2*w._y+(-g._y+q._y)*o+(2*g._y-5*w._y+4*q._y-R._y)*r+(-g._y+3*w._y-3*q._y+R._y)*S),z=.5*(2*w._z+(-g._z+q._z)*o+(2*g._z-5*w._z+4*q._z-R._z)*r+(-g._z+3*w._z-3*q._z+R._z)*S);return new A(i,T,z)}static Clamp(g,w,q){const R=new A;return A.ClampToRef(g,w,q,R),R}static ClampToRef(g,w,q,R){let o=g._x;o=o>q._x?q._x:o,o=o<w._x?w._x:o;let r=g._y;r=r>q._y?q._y:r,r=r<w._y?w._y:r;let S=g._z;return S=S>q._z?q._z:S,S=S<w._z?w._z:S,R.mi(o,r,S),R}static CheckExtends(g,w,q){w.minimizeInPlace(g),q.maximizeInPlace(g)}static Hermite(g,w,q,R,o){const r=o*o,S=o*r,i=2*S-3*r+1,T=-2*S+3*r,z=S-2*r+o,t=S-r,m=g._x*i+q._x*T+w._x*z+R._x*t,e=g._y*i+q._y*T+w._y*z+R._y*t,y=g._z*i+q._z*T+w._z*z+R._z*t;return new A(m,e,y)}static Hermite1stDerivative(g,w,q,R,o){const r=new A;return this.Hermite1stDerivativeToRef(g,w,q,R,o,r),r}static Hermite1stDerivativeToRef(g,w,q,R,o,r){const S=o*o;return r._x=6*(S-o)*g._x+(3*S-4*o+1)*w._x+6*(-S+o)*q._x+(3*S-2*o)*R._x,r._y=6*(S-o)*g._y+(3*S-4*o+1)*w._y+6*(-S+o)*q._y+(3*S-2*o)*R._y,r._z=6*(S-o)*g._z+(3*S-4*o+1)*w._z+6*(-S+o)*q._z+(3*S-2*o)*R._z,r._isDirty=!0,r}static Lerp(g,w,q){const R=new A(0,0,0);return A.LerpToRef(g,w,q,R),R}static LerpToRef(g,w,q,R){return R._x=g._x+(w._x-g._x)*q,R._y=g._y+(w._y-g._y)*q,R._z=g._z+(w._z-g._z)*q,R._isDirty=!0,R}static Dot(g,w){return g._x*w._x+g._y*w._y+g._z*w._z}dot(g){return this._x*g._x+this._y*g._y+this._z*g._z}static Cross(g,w){const q=new A;return A.CrossToRef(g,w,q),q}static CrossToRef(g,w,q){const R=g._y*w._z-g._z*w._y,o=g._z*w._x-g._x*w._z,r=g._x*w._y-g._y*w._x;return q.mi(R,o,r),q}static Normalize(g){const w=A.Zero();return A.NormalizeToRef(g,w),w}static NormalizeToRef(g,w){return g.normalizeToRef(w),w}static Project(g,w,q,R){const o=new A;return A.ProjectToRef(g,w,q,R,o),o}static ProjectToRef(g,w,q,R,o){var r;const S=R.width,T=R.height,z=R.x,t=R.y,m=G.Matrix[1],e=null===(r=i.c.LastCreatedEngine)||void 0===r?void 0:r.isNDCHalfZRange,y=e?1:.5,L=e?0:.5;x.FromValuesToRef(S/2,0,0,0,0,-T/2,0,0,0,0,y,0,z+S/2,T/2+t,L,1,m);const l=G.Matrix[0];return w.multiplyToRef(q,l),l.multiplyToRef(m,l),A.TransformCoordinatesToRef(g,l,o),o}static Reflect(g,w){return this.ReflectToRef(g,w,new A)}static ReflectToRef(g,w,q){const R=d.ew[0];return R.T(w).scaleInPlace(2*A.Dot(g,w)),q.T(g).Yt(R)}static _UnprojectFromInvertedMatrixToRef(g,w,q){A.TransformCoordinatesToRef(g,w,q);const R=w.m,o=g._x*R[3]+g._y*R[7]+g._z*R[11]+R[15];return(0,T.WithinEpsilon)(o,1)&&q.scaleInPlace(1/o),q}static UnprojectFromTransform(g,w,q,R,o){return this.Unproject(g,w,q,R,o,x.IdentityReadOnly)}static Unproject(g,w,q,R,o,r){const S=new A;return A.UnprojectToRef(g,w,q,R,o,r,S),S}static UnprojectToRef(g,w,q,R,o,r,S){return A.UnprojectFloatsToRef(g._x,g._y,g._z,w,q,R,o,r,S),S}static UnprojectFloatsToRef(g,w,q,R,o,r,S,T,z){var t;const m=G.Matrix[0];r.multiplyToRef(S,m),m.multiplyToRef(T,m),m.invert();const e=G.ew[0];return e.x=g/R*2-1,e.y=-(w/o*2-1),null!==(t=i.c.LastCreatedEngine)&&void 0!==t&&t.isNDCHalfZRange?e.z=q:e.z=2*q-1,A._UnprojectFromInvertedMatrixToRef(e,m,z),z}static Minimize(g,w){const q=new A;return q.T(g),q.minimizeInPlace(w),q}static Maximize(g,w){const q=new A;return q.T(g),q.maximizeInPlace(w),q}static Distance(g,w){return Math.sqrt(A.DistanceSquared(g,w))}static DistanceSquared(g,w){const q=g._x-w._x,R=g._y-w._y,o=g._z-w._z;return q*q+R*R+o*o}static ProjectOnTriangleToRef(g,w,q,o,r){const S=G.ew[0],i=G.ew[1],z=G.ew[2],t=G.ew[3],m=G.ew[4];q.subtractToRef(w,S),o.subtractToRef(w,i),o.subtractToRef(q,z);const e=S.length(),y=i.length(),L=z.length();if(e<R.c||y<R.c||L<R.c)return r.T(w),A.Distance(g,w);g.subtractToRef(w,m),A.CrossToRef(S,i,t);const l=t.length();if(l<R.c)return r.T(w),A.Distance(g,w);t.normalizeFromLength(l);let J=m.length();if(J<R.c)return r.T(w),0;m.normalizeFromLength(J);const x=A.Dot(t,m),d=G.ew[5],D=G.ew[6];d.T(t).scaleInPlace(-J*x),D.T(g).addInPlace(d);const U=G.ew[4],N=G.ew[5],a=G.ew[7],H=G.ew[8];U.T(S).scaleInPlace(1/e),H.T(i).scaleInPlace(1/y),U.addInPlace(H).scaleInPlace(-1),N.T(S).scaleInPlace(-1/e),H.T(z).scaleInPlace(1/L),N.addInPlace(H).scaleInPlace(-1),a.T(z).scaleInPlace(-1/L),H.T(i).scaleInPlace(-1/y),a.addInPlace(H).scaleInPlace(-1);const C=G.ew[9];let c;C.T(D).Yt(w),A.CrossToRef(U,C,H),c=A.Dot(H,t);const P=c;C.T(D).Yt(q),A.CrossToRef(N,C,H),c=A.Dot(H,t);const j=c;C.T(D).Yt(o),A.CrossToRef(a,C,H),c=A.Dot(H,t);const M=c,V=G.ew[10];let s,h;P>0&&j<0?(V.T(S),s=w,h=q):j>0&&M<0?(V.T(z),s=q,h=o):(V.T(i).scaleInPlace(-1),s=o,h=w);const v=G.ew[9],b=G.ew[4];s.subtractToRef(D,H),h.subtractToRef(D,v),A.CrossToRef(H,v,b);if(!(A.Dot(b,t)<0))return r.T(D),Math.abs(J*x);const B=G.ew[5];A.CrossToRef(V,b,B),B.normalize();const f=G.ew[9];f.T(s).Yt(D);const O=f.length();if(O<R.c)return r.T(s),A.Distance(g,s);f.normalizeFromLength(O);const E=A.Dot(B,f),Q=G.ew[7];Q.T(D).addInPlace(B.scaleInPlace(O*E)),H.T(Q).Yt(s),J=V.length(),V.normalizeFromLength(J);let X=A.Dot(H,V)/Math.max(J,R.c);return X=(0,T.Clamp)(X,0,1),Q.T(s).addInPlace(V.scaleInPlace(X*J)),r.T(Q),A.Distance(g,Q)}static Center(g,w){return A.CenterToRef(g,w,A.Zero())}static CenterToRef(g,w,q){return q.mi((g._x+w._x)/2,(g._y+w._y)/2,(g._z+w._z)/2)}static RotationFromAxis(g,w,q){const R=new A;return A.RotationFromAxisToRef(g,w,q,R),R}static RotationFromAxisToRef(g,w,q,R){const o=G.Quaternion[0];return J.RotationQuaternionFromAxisToRef(g,w,q,o),o.toEulerAnglesToRef(R),R}}A._V8PerformanceHack=new A(.5,.5,.5),A._UpReadOnly=A.Up(),A._DownReadOnly=A.Down(),A._LeftHandedForwardReadOnly=A.Forward(!1),A._RightHandedForwardReadOnly=A.Forward(!0),A._LeftHandedBackwardReadOnly=A.Backward(!1),A._RightHandedBackwardReadOnly=A.Backward(!0),A._RightReadOnly=A.Right(),A._LeftReadOnly=A.Left(),A._ZeroReadOnly=A.Zero(),A._OneReadOnly=A.One(),Object.defineProperties(A.prototype,{dimension:{value:[3]},rank:{value:1}});class l{get x(){return this._x}set x(g){this._x=g,this._isDirty=!0}get y(){return this._y}set y(g){this._y=g,this._isDirty=!0}get z(){return this._z}set z(g){this._z=g,this._isDirty=!0}get w(){return this._w}set w(g){this._w=g,this._isDirty=!0}constructor(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=g,this._y=w,this._z=q,this._w=R}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let g=y(this._x);return g=397*g^y(this._y),g=397*g^y(this._z),g=397*g^y(this._w),g}qi(){return[this._x,this._y,this._z,this._w]}toArray(g,w){return void 0===w&&(w=0),g[w]=this._x,g[w+1]=this._y,g[w+2]=this._z,g[w+3]=this._w,this}yq(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(g,w,this),this}addInPlace(g){return this.x+=g._x,this.y+=g._y,this.z+=g._z,this.w+=g._w,this}addInPlaceFromFloats(g,w,q,R){return this.x+=g,this.y+=w,this.z+=q,this.w+=R,this}add(g){return new l(this._x+g.x,this._y+g.y,this._z+g.z,this._w+g.w)}addToRef(g,w){return w.x=this._x+g.x,w.y=this._y+g.y,w.z=this._z+g.z,w.w=this._w+g.w,w}Yt(g){return this.x-=g.x,this.y-=g.y,this.z-=g.z,this.w-=g.w,this}yw(g){return new l(this._x-g.x,this._y-g.y,this._z-g.z,this._w-g.w)}subtractToRef(g,w){return w.x=this._x-g.x,w.y=this._y-g.y,w.z=this._z-g.z,w.w=this._w-g.w,w}subtractFromFloats(g,w,q,R){return new l(this._x-g,this._y-w,this._z-q,this._w-R)}subtractFromFloatsToRef(g,w,q,R,o){return o.x=this._x-g,o.y=this._y-w,o.z=this._z-q,o.w=this._w-R,o}negate(){return new l(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(g){return g.x=-this._x,g.y=-this._y,g.z=-this._z,g.w=-this._w,g}scaleInPlace(g){return this.x*=g,this.y*=g,this.z*=g,this.w*=g,this}scale(g){return new l(this._x*g,this._y*g,this._z*g,this._w*g)}scaleToRef(g,w){return w.x=this._x*g,w.y=this._y*g,w.z=this._z*g,w.w=this._w*g,w}scaleAndAddToRef(g,w){return w.x+=this._x*g,w.y+=this._y*g,w.z+=this._z*g,w.w+=this._w*g,w}equals(g){return g&&this._x===g.x&&this._y===g.y&&this._z===g.z&&this._w===g.w}equalsWithEpsilon(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.c;return g&&(0,T.WithinEpsilon)(this._x,g.x,w)&&(0,T.WithinEpsilon)(this._y,g.y,w)&&(0,T.WithinEpsilon)(this._z,g.z,w)&&(0,T.WithinEpsilon)(this._w,g.w,w)}equalsToFloats(g,w,q,R){return this._x===g&&this._y===w&&this._z===q&&this._w===R}multiplyInPlace(g){return this.x*=g.x,this.y*=g.y,this.z*=g.z,this.w*=g.w,this}multiply(g){return new l(this._x*g.x,this._y*g.y,this._z*g.z,this._w*g.w)}multiplyToRef(g,w){return w.x=this._x*g.x,w.y=this._y*g.y,w.z=this._z*g.z,w.w=this._w*g.w,w}multiplyByFloats(g,w,q,R){return new l(this._x*g,this._y*w,this._z*q,this._w*R)}divide(g){return new l(this._x/g.x,this._y/g.y,this._z/g.z,this._w/g.w)}divideToRef(g,w){return w.x=this._x/g.x,w.y=this._y/g.y,w.z=this._z/g.z,w.w=this._w/g.w,w}divideInPlace(g){return this.divideToRef(g,this)}minimizeInPlace(g){return g.x<this._x&&(this.x=g.x),g.y<this._y&&(this.y=g.y),g.z<this._z&&(this.z=g.z),g.w<this._w&&(this.w=g.w),this}maximizeInPlace(g){return g.x>this._x&&(this.x=g.x),g.y>this._y&&(this.y=g.y),g.z>this._z&&(this.z=g.z),g.w>this._w&&(this.w=g.w),this}minimizeInPlaceFromFloats(g,w,q,R){return this.x=Math.min(g,this._x),this.y=Math.min(w,this._y),this.z=Math.min(q,this._z),this.w=Math.min(R,this._w),this}maximizeInPlaceFromFloats(g,w,q,R){return this.x=Math.max(g,this._x),this.y=Math.max(w,this._y),this.z=Math.max(q,this._z),this.w=Math.max(R,this._w),this}floorToRef(g){return g.x=Math.floor(this._x),g.y=Math.floor(this._y),g.z=Math.floor(this._z),g.w=Math.floor(this._w),g}floor(){return new l(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(g){return g.x=this._x-Math.floor(this._x),g.y=this._y-Math.floor(this._y),g.z=this._z-Math.floor(this._z),g.w=this._w-Math.floor(this._w),g}fract(){return new l(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(g){return 0===g||1===g?this:this.scaleInPlace(1/g)}normalizeToNew(){return this.normalizeToRef(new l)}normalizeToRef(g){const w=this.length();return 0===w||1===w?(g.x=this._x,g.y=this._y,g.z=this._z,g.w=this._w,g):this.scaleToRef(1/w,g)}toVector3(){return new A(this._x,this._y,this._z)}clone(){return new l(this._x,this._y,this._z,this._w)}T(g){return this.x=g.x,this.y=g.y,this.z=g.z,this.w=g.w,this}mi(g,w,q,R){return this.x=g,this.y=w,this.z=q,this.w=R,this}set(g,w,q,R){return this.mi(g,w,q,R)}yi(g){return this.x=this.y=this.z=this.w=g,this}dot(g){return this._x*g.x+this._y*g.y+this._z*g.z+this._w*g.w}static Ri(g,w){return w||(w=0),new l(g[w],g[w+1],g[w+2],g[w+3])}static FromArrayToRef(g,w,q){return q.x=g[w],q.y=g[w+1],q.z=g[w+2],q.w=g[w+3],q}static FromFloatArrayToRef(g,w,q){return l.FromArrayToRef(g,w,q),q}static FromFloatsToRef(g,w,q,R,o){return o.x=g,o.y=w,o.z=q,o.w=R,o}static Zero(){return new l(0,0,0,0)}static One(){return new l(1,1,1,1)}static Random(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new l((0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w))}static RandomToRef(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,q=arguments.length>2?arguments[2]:void 0;return q.x=(0,T.RandomRange)(g,w),q.y=(0,T.RandomRange)(g,w),q.z=(0,T.RandomRange)(g,w),q.w=(0,T.RandomRange)(g,w),q}static Clamp(g,w,q){return l.ClampToRef(g,w,q,new l)}static ClampToRef(g,w,q,R){return R.x=(0,T.Clamp)(g.x,w.x,q.x),R.y=(0,T.Clamp)(g.y,w.y,q.y),R.z=(0,T.Clamp)(g.z,w.z,q.z),R.w=(0,T.Clamp)(g.w,w.w,q.w),R}static CheckExtends(g,w,q){w.minimizeInPlace(g),q.maximizeInPlace(g)}static get ZeroReadOnly(){return l._ZeroReadOnly}static Normalize(g){return l.NormalizeToRef(g,new l)}static NormalizeToRef(g,w){return g.normalizeToRef(w),w}static Minimize(g,w){const q=new l;return q.T(g),q.minimizeInPlace(w),q}static Maximize(g,w){const q=new l;return q.T(g),q.maximizeInPlace(w),q}static Distance(g,w){return Math.sqrt(l.DistanceSquared(g,w))}static DistanceSquared(g,w){const q=g.x-w.x,R=g.y-w.y,o=g.z-w.z,r=g.w-w.w;return q*q+R*R+o*o+r*r}static Center(g,w){return l.CenterToRef(g,w,new l)}static CenterToRef(g,w,q){return q.x=(g.x+w.x)/2,q.y=(g.y+w.y)/2,q.z=(g.z+w.z)/2,q.w=(g.w+w.w)/2,q}static TransformCoordinates(g,w){return l.TransformCoordinatesToRef(g,w,new l)}static TransformCoordinatesToRef(g,w,q){return l.TransformCoordinatesFromFloatsToRef(g._x,g._y,g._z,w,q),q}static TransformCoordinatesFromFloatsToRef(g,w,q,R,o){const r=R.m,S=g*r[0]+w*r[4]+q*r[8]+r[12],i=g*r[1]+w*r[5]+q*r[9]+r[13],T=g*r[2]+w*r[6]+q*r[10]+r[14],z=g*r[3]+w*r[7]+q*r[11]+r[15];return o.x=S,o.y=i,o.z=T,o.w=z,o}static TransformNormal(g,w){return l.TransformNormalToRef(g,w,new l)}static TransformNormalToRef(g,w,q){const R=w.m,o=g.x*R[0]+g.y*R[4]+g.z*R[8],r=g.x*R[1]+g.y*R[5]+g.z*R[9],S=g.x*R[2]+g.y*R[6]+g.z*R[10];return q.x=o,q.y=r,q.z=S,q.w=g.w,q}static TransformNormalFromFloatsToRef(g,w,q,R,o,r){const S=o.m;return r.x=g*S[0]+w*S[4]+q*S[8],r.y=g*S[1]+w*S[5]+q*S[9],r.z=g*S[2]+w*S[6]+q*S[10],r.w=R,r}static FromVector3(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new l(g._x,g._y,g._z,w)}static Dot(g,w){return g.x*w.x+g.y*w.y+g.z*w.z+g.w*w.w}}l._V8PerformanceHack=new l(.5,.5,.5,.5),l._ZeroReadOnly=l.Zero(),Object.defineProperties(l.prototype,{dimension:{value:[4]},rank:{value:1}});class J{get x(){return this._x}set x(g){this._x=g,this._isDirty=!0}get y(){return this._y}set y(g){this._y=g,this._isDirty=!0}get z(){return this._z}set z(g){this._z=g,this._isDirty=!0}get w(){return this._w}set w(g){this._w=g,this._isDirty=!0}constructor(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=g,this._y=w,this._z=q,this._w=R}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let g=y(this._x);return g=397*g^y(this._y),g=397*g^y(this._z),g=397*g^y(this._w),g}qi(){return[this._x,this._y,this._z,this._w]}toArray(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g[w]=this._x,g[w+1]=this._y,g[w+2]=this._z,g[w+3]=this._w,this}yq(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(g,w,this)}equals(g){return g&&this._x===g._x&&this._y===g._y&&this._z===g._z&&this._w===g._w}equalsWithEpsilon(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.c;return g&&(0,T.WithinEpsilon)(this._x,g._x,w)&&(0,T.WithinEpsilon)(this._y,g._y,w)&&(0,T.WithinEpsilon)(this._z,g._z,w)&&(0,T.WithinEpsilon)(this._w,g._w,w)}isApprox(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.c;return g&&((0,T.WithinEpsilon)(this._x,g._x,w)&&(0,T.WithinEpsilon)(this._y,g._y,w)&&(0,T.WithinEpsilon)(this._z,g._z,w)&&(0,T.WithinEpsilon)(this._w,g._w,w)||(0,T.WithinEpsilon)(this._x,-g._x,w)&&(0,T.WithinEpsilon)(this._y,-g._y,w)&&(0,T.WithinEpsilon)(this._z,-g._z,w)&&(0,T.WithinEpsilon)(this._w,-g._w,w))}clone(){return new J(this._x,this._y,this._z,this._w)}T(g){return this._x=g._x,this._y=g._y,this._z=g._z,this._w=g._w,this._isDirty=!0,this}mi(g,w,q,R){return this._x=g,this._y=w,this._z=q,this._w=R,this._isDirty=!0,this}set(g,w,q,R){return this.mi(g,w,q,R)}yi(g){return this.mi(g,g,g,g)}add(g){return new J(this._x+g._x,this._y+g._y,this._z+g._z,this._w+g._w)}addInPlace(g){return this._x+=g._x,this._y+=g._y,this._z+=g._z,this._w+=g._w,this._isDirty=!0,this}addToRef(g,w){return w._x=this._x+g._x,w._y=this._y+g._y,w._z=this._z+g._z,w._w=this._w+g._w,w._isDirty=!0,w}addInPlaceFromFloats(g,w,q,R){return this._x+=g,this._y+=w,this._z+=q,this._w+=R,this._isDirty=!0,this}subtractToRef(g,w){return w._x=this._x-g._x,w._y=this._y-g._y,w._z=this._z-g._z,w._w=this._w-g._w,w._isDirty=!0,w}subtractFromFloats(g,w,q,R){return this.subtractFromFloatsToRef(g,w,q,R,new J)}subtractFromFloatsToRef(g,w,q,R,o){return o._x=this._x-g,o._y=this._y-w,o._z=this._z-q,o._w=this._w-R,o._isDirty=!0,o}yw(g){return new J(this._x-g._x,this._y-g._y,this._z-g._z,this._w-g._w)}Yt(g){return this._x-=g._x,this._y-=g._y,this._z-=g._z,this._w-=g._w,this._isDirty=!0,this}scale(g){return new J(this._x*g,this._y*g,this._z*g,this._w*g)}scaleToRef(g,w){return w._x=this._x*g,w._y=this._y*g,w._z=this._z*g,w._w=this._w*g,w._isDirty=!0,w}scaleInPlace(g){return this._x*=g,this._y*=g,this._z*=g,this._w*=g,this._isDirty=!0,this}scaleAndAddToRef(g,w){return w._x+=this._x*g,w._y+=this._y*g,w._z+=this._z*g,w._w+=this._w*g,w._isDirty=!0,w}multiply(g){const w=new J(0,0,0,1);return this.multiplyToRef(g,w),w}multiplyToRef(g,w){const q=this._x*g._w+this._y*g._z-this._z*g._y+this._w*g._x,R=-this._x*g._z+this._y*g._w+this._z*g._x+this._w*g._y,o=this._x*g._y-this._y*g._x+this._z*g._w+this._w*g._z,r=-this._x*g._x-this._y*g._y-this._z*g._z+this._w*g._w;return w.mi(q,R,o,r),w}multiplyInPlace(g){return this.multiplyToRef(g,this)}multiplyByFloats(g,w,q,R){return this._x*=g,this._y*=w,this._z*=q,this._w*=R,this._isDirty=!0,this}divide(g){throw new ReferenceError("Can not divide a quaternion")}divideToRef(g,w){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(g){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new J)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(g){return g._x=-this._x,g._y=-this._y,g._z=-this._z,g._w=-this._w,g._isDirty=!0,g}equalsToFloats(g,w,q,R){return this._x===g&&this._y===w&&this._z===q&&this._w===R}floorToRef(g){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(g){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(g){return g.mi(-this._x,-this._y,-this._z,this._w),g}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new J(-this._x,-this._y,-this._z,this._w)}invert(){const g=this.conjugate(),w=this.lengthSquared();return 0==w||1==w||g.scaleInPlace(1/w),g}invertInPlace(){this.conjugateInPlace();const g=this.lengthSquared();return 0==g||1==g||this.scaleInPlace(1/g),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(g){return 0===g||1===g?this:this.scaleInPlace(1/g)}normalizeToNew(){const g=new J(0,0,0,1);return this.normalizeToRef(g),g}normalizeToRef(g){const w=this.length();return 0===w||1===w?g.mi(this._x,this._y,this._z,this._w):this.scaleToRef(1/w,g)}toEulerAngles(){const g=A.Zero();return this.toEulerAnglesToRef(g),g}toEulerAnglesToRef(g){const w=this._z,q=this._x,R=this._y,o=this._w,r=R*w-q*o,S=.4999999;if(r<-S)g._y=2*Math.atan2(R,o),g._x=Math.PI/2,g._z=0,g._isDirty=!0;else if(r>S)g._y=2*Math.atan2(R,o),g._x=-Math.PI/2,g._z=0,g._isDirty=!0;else{const S=o*o,i=w*w,T=q*q,z=R*R;g._z=Math.atan2(2*(q*R+w*o),-i-T+z+S),g._x=Math.asin(-2*r),g._y=Math.atan2(2*(w*q+R*o),i-T-z+S),g._isDirty=!0}return g}toAlphaBetaGammaToRef(g){const w=this._z,q=this._x,R=this._y,o=this._w,r=Math.sqrt(q*q+R*R),S=Math.sqrt(w*w+o*o),i=2*Math.atan2(r,S),T=2*Math.atan2(w,o),z=2*Math.atan2(R,q),t=(T+z)/2,m=(T-z)/2;return g.set(m,i,t),g}toRotationMatrix(g){return x.FromQuaternionToRef(this,g),g}fromRotationMatrix(g){return J.FromRotationMatrixToRef(g,this),this}dot(g){return this._x*g._x+this._y*g._y+this._z*g._z+this._w*g._w}toAxisAngle(){const g=A.Zero();return{axis:g,angle:this.toAxisAngleToRef(g)}}toAxisAngleToRef(g){let w=0;const q=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),R=this._w;return q>0?(w=2*Math.atan2(q,R),g.set(this._x/q,this._y/q,this._z/q)):(w=0,g.set(1,0,0)),w}static FromRotationMatrix(g){const w=new J;return J.FromRotationMatrixToRef(g,w),w}static FromRotationMatrixToRef(g,w){const q=g.m,R=q[0],o=q[4],r=q[8],S=q[1],i=q[5],T=q[9],z=q[2],t=q[6],m=q[10],e=R+i+m;let y;return e>0?(y=.5/Math.sqrt(e+1),w._w=.25/y,w._x=(t-T)*y,w._y=(r-z)*y,w._z=(S-o)*y,w._isDirty=!0):R>i&&R>m?(y=2*Math.sqrt(1+R-i-m),w._w=(t-T)/y,w._x=.25*y,w._y=(o+S)/y,w._z=(r+z)/y,w._isDirty=!0):i>m?(y=2*Math.sqrt(1+i-R-m),w._w=(r-z)/y,w._x=(o+S)/y,w._y=.25*y,w._z=(T+t)/y,w._isDirty=!0):(y=2*Math.sqrt(1+m-R-i),w._w=(S-o)/y,w._x=(r+z)/y,w._y=(T+t)/y,w._z=.25*y,w._isDirty=!0),w}static Dot(g,w){return g._x*w._x+g._y*w._y+g._z*w._z+g._w*w._w}static AreClose(g,w){let q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const R=J.Dot(g,w);return 1-R*R<=q}static SmoothToRef(g,w,q,R,o){let r=0===R?1:q/R;return r=(0,T.Clamp)(r,0,1),J.SlerpToRef(g,w,r,o),o}static Zero(){return new J(0,0,0,0)}static Inverse(g){return new J(-g._x,-g._y,-g._z,g._w)}static InverseToRef(g,w){return w.set(-g._x,-g._y,-g._z,g._w),w}static Identity(){return new J(0,0,0,1)}static IsIdentity(g){return g&&0===g._x&&0===g._y&&0===g._z&&1===g._w}static RotationAxis(g,w){return J.RotationAxisToRef(g,w,new J)}static RotationAxisToRef(g,w,q){q._w=Math.cos(w/2);const R=Math.sin(w/2)/g.length();return q._x=g._x*R,q._y=g._y*R,q._z=g._z*R,q._isDirty=!0,q}static Ri(g,w){return w||(w=0),new J(g[w],g[w+1],g[w+2],g[w+3])}static FromArrayToRef(g,w,q){return q._x=g[w],q._y=g[w+1],q._z=g[w+2],q._w=g[w+3],q._isDirty=!0,q}static FromFloatsToRef(g,w,q,R,o){return o.mi(g,w,q,R),o}static FromEulerAngles(g,w,q){const R=new J;return J.RotationYawPitchRollToRef(w,g,q,R),R}static FromEulerAnglesToRef(g,w,q,R){return J.RotationYawPitchRollToRef(w,g,q,R),R}static FromEulerVector(g){const w=new J;return J.RotationYawPitchRollToRef(g._y,g._x,g._z,w),w}static FromEulerVectorToRef(g,w){return J.RotationYawPitchRollToRef(g._y,g._x,g._z,w),w}static FromUnitVectorsToRef(g,w,q){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:R.c;const r=A.Dot(g,w)+1;return r<o?Math.abs(g.x)>Math.abs(g.z)?q.set(-g.y,g.x,0,0):q.set(0,-g.z,g.y,0):(A.CrossToRef(g,w,d.ew[0]),q.set(d.ew[0].x,d.ew[0].y,d.ew[0].z,r)),q.normalize()}static RotationYawPitchRoll(g,w,q){const R=new J;return J.RotationYawPitchRollToRef(g,w,q,R),R}static RotationYawPitchRollToRef(g,w,q,R){const o=.5*q,r=.5*w,S=.5*g,i=Math.sin(o),T=Math.cos(o),z=Math.sin(r),t=Math.cos(r),m=Math.sin(S),e=Math.cos(S);return R._x=e*z*T+m*t*i,R._y=m*t*T-e*z*i,R._z=e*t*i-m*z*T,R._w=e*t*T+m*z*i,R._isDirty=!0,R}static RotationAlphaBetaGamma(g,w,q){const R=new J;return J.RotationAlphaBetaGammaToRef(g,w,q,R),R}static RotationAlphaBetaGammaToRef(g,w,q,R){const o=.5*(q+g),r=.5*(q-g),S=.5*w;return R._x=Math.cos(r)*Math.sin(S),R._y=Math.sin(r)*Math.sin(S),R._z=Math.sin(o)*Math.cos(S),R._w=Math.cos(o)*Math.cos(S),R._isDirty=!0,R}static RotationQuaternionFromAxis(g,w,q){const R=new J(0,0,0,0);return J.RotationQuaternionFromAxisToRef(g,w,q,R),R}static RotationQuaternionFromAxisToRef(g,w,q,R){const o=G.Matrix[0];return g=g.normalizeToRef(G.ew[0]),w=w.normalizeToRef(G.ew[1]),q=q.normalizeToRef(G.ew[2]),x.FromXYZAxesToRef(g,w,q,o),J.FromRotationMatrixToRef(o,R),R}static FromLookDirectionLH(g,w){const q=new J;return J.FromLookDirectionLHToRef(g,w,q),q}static FromLookDirectionLHToRef(g,w,q){const R=G.Matrix[0];return x.LookDirectionLHToRef(g,w,R),J.FromRotationMatrixToRef(R,q),q}static FromLookDirectionRH(g,w){const q=new J;return J.FromLookDirectionRHToRef(g,w,q),q}static FromLookDirectionRHToRef(g,w,q){const R=G.Matrix[0];return x.LookDirectionRHToRef(g,w,R),J.FromRotationMatrixToRef(R,q)}static Slerp(g,w,q){const R=J.Identity();return J.SlerpToRef(g,w,q,R),R}static SlerpToRef(g,w,q,R){let o,r,S=g._x*w._x+g._y*w._y+g._z*w._z+g._w*w._w,i=!1;if(S<0&&(i=!0,S=-S),S>.999999)r=1-q,o=i?-q:q;else{const g=Math.acos(S),w=1/Math.sin(g);r=Math.sin((1-q)*g)*w,o=i?-Math.sin(q*g)*w:Math.sin(q*g)*w}return R._x=r*g._x+o*w._x,R._y=r*g._y+o*w._y,R._z=r*g._z+o*w._z,R._w=r*g._w+o*w._w,R._isDirty=!0,R}static Hermite(g,w,q,R,o){const r=o*o,S=o*r,i=2*S-3*r+1,T=-2*S+3*r,z=S-2*r+o,t=S-r,m=g._x*i+q._x*T+w._x*z+R._x*t,e=g._y*i+q._y*T+w._y*z+R._y*t,y=g._z*i+q._z*T+w._z*z+R._z*t,L=g._w*i+q._w*T+w._w*z+R._w*t;return new J(m,e,y,L)}static Hermite1stDerivative(g,w,q,R,o){const r=new J;return this.Hermite1stDerivativeToRef(g,w,q,R,o,r),r}static Hermite1stDerivativeToRef(g,w,q,R,o,r){const S=o*o;return r._x=6*(S-o)*g._x+(3*S-4*o+1)*w._x+6*(-S+o)*q._x+(3*S-2*o)*R._x,r._y=6*(S-o)*g._y+(3*S-4*o+1)*w._y+6*(-S+o)*q._y+(3*S-2*o)*R._y,r._z=6*(S-o)*g._z+(3*S-4*o+1)*w._z+6*(-S+o)*q._z+(3*S-2*o)*R._z,r._w=6*(S-o)*g._w+(3*S-4*o+1)*w._w+6*(-S+o)*q._w+(3*S-2*o)*R._w,r._isDirty=!0,r}static Normalize(g){const w=J.Zero();return J.NormalizeToRef(g,w),w}static NormalizeToRef(g,w){return g.normalizeToRef(w),w}static Clamp(g,w,q){const R=new J;return J.ClampToRef(g,w,q,R),R}static ClampToRef(g,w,q,R){return R.mi((0,T.Clamp)(g.x,w.x,q.x),(0,T.Clamp)(g.y,w.y,q.y),(0,T.Clamp)(g.z,w.z,q.z),(0,T.Clamp)(g.w,w.w,q.w))}static Random(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new J((0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w))}static RandomToRef(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).mi((0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w),(0,T.RandomRange)(g,w))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(g,w){return Math.sqrt(J.DistanceSquared(g,w))}static DistanceSquared(g,w){const q=g.x-w.x,R=g.y-w.y,o=g.z-w.z,r=g.w-w.w;return q*q+R*R+o*o+r*r}static Center(g,w){return J.CenterToRef(g,w,J.Zero())}static CenterToRef(g,w,q){return q.mi((g.x+w.x)/2,(g.y+w.y)/2,(g.z+w.z)/2,(g.w+w.w)/2)}}J._V8PerformanceHack=new J(.5,.5,.5,.5),Object.defineProperties(J.prototype,{dimension:{value:[4]},rank:{value:1}});class x{static get Use64Bits(){return S.b.MatrixUse64Bits}get m(){return this.pS}markAsUpdated(){this.updateFlag=z._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(g){let w=arguments.length>1&&void 0!==arguments[1]&&arguments[1],q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],R=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=g,this._isIdentity3x2=g||q,this._isIdentityDirty=!this._isIdentity&&w,this._isIdentity3x2Dirty=!this._isIdentity3x2&&R}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,S.b.MatrixTrackPrecisionChange&&S.b.MatrixTrackedMatrices.push(this),this.pS=new S.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const g=this.pS;this._isIdentity=1===g[0]&&0===g[1]&&0===g[2]&&0===g[3]&&0===g[4]&&1===g[5]&&0===g[6]&&0===g[7]&&0===g[8]&&0===g[9]&&1===g[10]&&0===g[11]&&0===g[12]&&0===g[13]&&0===g[14]&&1===g[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.pS[0]||1!==this.pS[5]||1!==this.pS[15]||0!==this.pS[1]||0!==this.pS[2]||0!==this.pS[3]||0!==this.pS[4]||0!==this.pS[6]||0!==this.pS[7]||0!==this.pS[8]||0!==this.pS[9]||0!==this.pS[10]||0!==this.pS[11]||0!==this.pS[12]||0!==this.pS[13]||0!==this.pS[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const g=this.pS,w=g[0],q=g[1],R=g[2],o=g[3],r=g[4],S=g[5],i=g[6],T=g[7],z=g[8],t=g[9],m=g[10],e=g[11],y=g[12],L=g[13],A=g[14],l=g[15],J=m*l-A*e,x=t*l-L*e,G=t*A-L*m,d=z*l-y*e,D=z*A-m*y,U=z*L-y*t;return w*+(S*J-i*x+T*G)+q*-(r*J-i*d+T*D)+R*+(r*x-S*d+T*U)+o*-(r*G-S*D+i*U)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!g)return this.pS;const q=this.pS;for(let R=0;R<16;R++)g[w+R]=q[R];return this}qi(){return this.pS}yq(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return x.FromArrayToRef(g,w,this)}mi(){for(var g=arguments.length,w=new Array(g),q=0;q<g;q++)w[q]=arguments[q];return x.FromArrayToRef(w,0,this)}set(){const g=this.pS;for(let w=0;w<16;w++)g[w]=w<0||arguments.length<=w?void 0:arguments[w];return this.markAsUpdated(),this}yi(g){const w=this.pS;for(let q=0;q<16;q++)w[q]=g;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return x.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(g){const w=new x;return this.addToRef(g,w),w}addToRef(g,w){const q=this.pS,R=w.pS,o=g.m;for(let r=0;r<16;r++)R[r]=q[r]+o[r];return w.markAsUpdated(),w}addToSelf(g){const w=this.pS,q=g.m;return w[0]+=q[0],w[1]+=q[1],w[2]+=q[2],w[3]+=q[3],w[4]+=q[4],w[5]+=q[5],w[6]+=q[6],w[7]+=q[7],w[8]+=q[8],w[9]+=q[9],w[10]+=q[10],w[11]+=q[11],w[12]+=q[12],w[13]+=q[13],w[14]+=q[14],w[15]+=q[15],this.markAsUpdated(),this}addInPlace(g){const w=this.pS,q=g.m;for(let R=0;R<16;R++)w[R]+=q[R];return this.markAsUpdated(),this}addInPlaceFromFloats(){const g=this.pS;for(let w=0;w<16;w++)g[w]+=w<0||arguments.length<=w?void 0:arguments[w];return this.markAsUpdated(),this}yw(g){const w=this.pS,q=g.m;for(let R=0;R<16;R++)w[R]-=q[R];return this.markAsUpdated(),this}subtractToRef(g,w){const q=this.pS,R=g.m,o=w.pS;for(let r=0;r<16;r++)o[r]=q[r]-R[r];return w.markAsUpdated(),w}Yt(g){const w=this.pS,q=g.m;for(let R=0;R<16;R++)w[R]-=q[R];return this.markAsUpdated(),this}subtractFromFloats(){for(var g=arguments.length,w=new Array(g),q=0;q<g;q++)w[q]=arguments[q];return this.subtractFromFloatsToRef(...w,new x)}subtractFromFloatsToRef(){for(var g=arguments.length,w=new Array(g),q=0;q<g;q++)w[q]=arguments[q];const R=w.pop(),o=this.pS,r=R.pS,S=w;for(let i=0;i<16;i++)r[i]=o[i]-S[i];return R.markAsUpdated(),R}invertToRef(g){return!0===this._isIdentity?(x.IdentityToRef(g),g):(e(this,g.qi())?g.markAsUpdated():g.T(this),g)}addAtIndex(g,w){return this.pS[g]+=w,this.markAsUpdated(),this}multiplyAtIndex(g,w){return this.pS[g]*=w,this.markAsUpdated(),this}setTranslationFromFloats(g,w,q){return this.pS[12]=g,this.pS[13]=w,this.pS[14]=q,this.markAsUpdated(),this}addTranslationFromFloats(g,w,q){return this.pS[12]+=g,this.pS[13]+=w,this.pS[14]+=q,this.markAsUpdated(),this}setTranslation(g){return this.setTranslationFromFloats(g._x,g._y,g._z)}getTranslation(){return new A(this.pS[12],this.pS[13],this.pS[14])}getTranslationToRef(g){return g.x=this.pS[12],g.y=this.pS[13],g.z=this.pS[14],g}removeRotationAndScaling(){const g=this.m;return x.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,g[12],g[13],g[14],g[15],this),this._updateIdentityStatus(0===g[12]&&0===g[13]&&0===g[14]&&1===g[15]),this}T(g){g.copyToArray(this.pS);const w=g;return this.updateFlag=w.updateFlag,this._updateIdentityStatus(w._isIdentity,w._isIdentityDirty,w._isIdentity3x2,w._isIdentity3x2Dirty),this}copyToArray(g){return m(this,g,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(g){const w=new x;return this.multiplyToRef(g,w),w}multiplyInPlace(g){const w=this.pS,q=g.m;for(let R=0;R<16;R++)w[R]*=q[R];return this.markAsUpdated(),this}multiplyByFloats(){const g=this.pS;for(let w=0;w<16;w++)g[w]*=w<0||arguments.length<=w?void 0:arguments[w];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var g=arguments.length,w=new Array(g),q=0;q<g;q++)w[q]=arguments[q];const R=w.pop(),o=this.pS,r=R.pS,S=w;for(let i=0;i<16;i++)r[i]=o[i]*S[i];return R.markAsUpdated(),R}multiplyToRef(g,w){return this._isIdentity?(w.T(g),w):g._isIdentity?(w.T(this),w):(this.multiplyToArray(g,w.pS,0),w.markAsUpdated(),w)}multiplyToArray(g,w,q){return t(this,g,w,q),this}divide(g){return this.divideToRef(g,new x)}divideToRef(g,w){const q=this.pS,R=g.m,o=w.pS;for(let r=0;r<16;r++)o[r]=q[r]/R[r];return w.markAsUpdated(),w}divideInPlace(g){const w=this.pS,q=g.m;for(let R=0;R<16;R++)w[R]/=q[R];return this.markAsUpdated(),this}minimizeInPlace(g){const w=this.pS,q=g.m;for(let R=0;R<16;R++)w[R]=Math.min(w[R],q[R]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const g=this.pS;for(let w=0;w<16;w++)g[w]=Math.min(g[w],w<0||arguments.length<=w?void 0:arguments[w]);return this.markAsUpdated(),this}maximizeInPlace(g){const w=this.pS,q=g.m;for(let R=0;R<16;R++)w[R]=Math.min(w[R],q[R]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const g=this.pS;for(let w=0;w<16;w++)g[w]=Math.min(g[w],w<0||arguments.length<=w?void 0:arguments[w]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new x)}negateInPlace(){const g=this.pS;for(let w=0;w<16;w++)g[w]=-g[w];return this.markAsUpdated(),this}negateToRef(g){const w=this.pS,q=g.pS;for(let R=0;R<16;R++)q[R]=-w[R];return g.markAsUpdated(),g}equals(g){const w=g;if(!w)return!1;if((this._isIdentity||w._isIdentity)&&!this._isIdentityDirty&&!w._isIdentityDirty)return this._isIdentity&&w._isIdentity;const q=this.m,R=w.m;return q[0]===R[0]&&q[1]===R[1]&&q[2]===R[2]&&q[3]===R[3]&&q[4]===R[4]&&q[5]===R[5]&&q[6]===R[6]&&q[7]===R[7]&&q[8]===R[8]&&q[9]===R[9]&&q[10]===R[10]&&q[11]===R[11]&&q[12]===R[12]&&q[13]===R[13]&&q[14]===R[14]&&q[15]===R[15]}equalsWithEpsilon(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const q=this.pS,R=g.m;for(let o=0;o<16;o++)if(!(0,T.WithinEpsilon)(q[o],R[o],w))return!1;return!0}equalsToFloats(){const g=this.pS;for(let w=0;w<16;w++)if(g[w]!=(w<0||arguments.length<=w?void 0:arguments[w]))return!1;return!0}floor(){return this.floorToRef(new x)}floorToRef(g){const w=this.pS,q=g.pS;for(let R=0;R<16;R++)q[R]=Math.floor(w[R]);return g.markAsUpdated(),g}fract(){return this.fractToRef(new x)}fractToRef(g){const w=this.pS,q=g.pS;for(let R=0;R<16;R++)q[R]=w[R]-Math.floor(w[R]);return g.markAsUpdated(),g}clone(){const g=new x;return g.T(this),g}getClassName(){return"Matrix"}getHashCode(){let g=y(this.pS[0]);for(let w=1;w<16;w++)g=397*g^y(this.pS[w]);return g}decomposeToTransformNode(g){return g.rotationQuaternion=g.rotationQuaternion||new J,this.decompose(g.ei,g.rotationQuaternion,g.position)}decompose(g,w,q,R){let o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return q&&q.yi(0),g&&g.yi(1),w&&w.mi(0,0,0,1),!0;const r=this.pS;if(q&&q.mi(r[12],r[13],r[14]),(g=g||G.ew[0]).x=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]),g.y=Math.sqrt(r[4]*r[4]+r[5]*r[5]+r[6]*r[6]),g.z=Math.sqrt(r[8]*r[8]+r[9]*r[9]+r[10]*r[10]),R){const w=(o?R.absoluteScaling.x:R.ei.x)<0?-1:1,q=(o?R.absoluteScaling.y:R.ei.y)<0?-1:1,r=(o?R.absoluteScaling.z:R.ei.z)<0?-1:1;g.x*=w,g.y*=q,g.z*=r}else this.determinant()<=0&&(g.y*=-1);if(0===g._x||0===g._y||0===g._z)return w&&w.mi(0,0,0,1),!1;if(w){const q=1/g._x,R=1/g._y,o=1/g._z;x.FromValuesToRef(r[0]*q,r[1]*q,r[2]*q,0,r[4]*R,r[5]*R,r[6]*R,0,r[8]*o,r[9]*o,r[10]*o,0,0,0,0,1,G.Matrix[0]),J.FromRotationMatrixToRef(G.Matrix[0],w)}return!0}getRow(g){if(g<0||g>3)return null;const w=4*g;return new l(this.pS[w+0],this.pS[w+1],this.pS[w+2],this.pS[w+3])}getRowToRef(g,w){if(g>=0&&g<=3){const q=4*g;w.x=this.pS[q+0],w.y=this.pS[q+1],w.z=this.pS[q+2],w.w=this.pS[q+3]}return w}setRow(g,w){return this.setRowFromFloats(g,w.x,w.y,w.z,w.w)}transpose(){const g=new x;return x.TransposeToRef(this,g),g}transposeToRef(g){return x.TransposeToRef(this,g),g}setRowFromFloats(g,w,q,R,o){if(g<0||g>3)return this;const r=4*g;return this.pS[r+0]=w,this.pS[r+1]=q,this.pS[r+2]=R,this.pS[r+3]=o,this.markAsUpdated(),this}scale(g){const w=new x;return this.scaleToRef(g,w),w}scaleToRef(g,w){for(let q=0;q<16;q++)w.pS[q]=this.pS[q]*g;return w.markAsUpdated(),w}scaleAndAddToRef(g,w){for(let q=0;q<16;q++)w.pS[q]+=this.pS[q]*g;return w.markAsUpdated(),w}scaleInPlace(g){const w=this.pS;for(let q=0;q<16;q++)w[q]*=g;return this.markAsUpdated(),this}toNormalMatrix(g){const w=G.Matrix[0];this.invertToRef(w),w.transposeToRef(g);const q=g.pS;return x.FromValuesToRef(q[0],q[1],q[2],0,q[4],q[5],q[6],0,q[8],q[9],q[10],0,0,0,0,1,g),g}getRotationMatrix(){const g=new x;return this.getRotationMatrixToRef(g),g}getRotationMatrixToRef(g){const w=G.ew[0];if(!this.decompose(w))return x.IdentityToRef(g),g;const q=this.pS,R=1/w._x,o=1/w._y,r=1/w._z;return x.FromValuesToRef(q[0]*R,q[1]*R,q[2]*R,0,q[4]*o,q[5]*o,q[6]*o,0,q[8]*r,q[9]*r,q[10]*r,0,0,0,0,1,g),g}toggleModelMatrixHandInPlace(){const g=this.pS;return g[2]*=-1,g[6]*=-1,g[8]*=-1,g[9]*=-1,g[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const g=this.pS;return g[8]*=-1,g[9]*=-1,g[10]*=-1,g[11]*=-1,this.markAsUpdated(),this}static Ri(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const q=new x;return x.FromArrayToRef(g,w,q),q}static FromArrayToRef(g,w,q){for(let R=0;R<16;R++)q.pS[R]=g[R+w];return q.markAsUpdated(),q}static FromFloat32ArrayToRefScaled(g,w,q,R){return R.pS[0]=g[0+w]*q,R.pS[1]=g[1+w]*q,R.pS[2]=g[2+w]*q,R.pS[3]=g[3+w]*q,R.pS[4]=g[4+w]*q,R.pS[5]=g[5+w]*q,R.pS[6]=g[6+w]*q,R.pS[7]=g[7+w]*q,R.pS[8]=g[8+w]*q,R.pS[9]=g[9+w]*q,R.pS[10]=g[10+w]*q,R.pS[11]=g[11+w]*q,R.pS[12]=g[12+w]*q,R.pS[13]=g[13+w]*q,R.pS[14]=g[14+w]*q,R.pS[15]=g[15+w]*q,R.markAsUpdated(),R}static get IdentityReadOnly(){return x._IdentityReadOnly}static FromValuesToRef(g,w,q,R,o,r,S,i,T,z,t,m,e,y,L,A,l){const J=l.pS;J[0]=g,J[1]=w,J[2]=q,J[3]=R,J[4]=o,J[5]=r,J[6]=S,J[7]=i,J[8]=T,J[9]=z,J[10]=t,J[11]=m,J[12]=e,J[13]=y,J[14]=L,J[15]=A,l.markAsUpdated()}static FromValues(g,w,q,R,o,r,S,i,T,z,t,m,e,y,L,A){const l=new x,J=l.pS;return J[0]=g,J[1]=w,J[2]=q,J[3]=R,J[4]=o,J[5]=r,J[6]=S,J[7]=i,J[8]=T,J[9]=z,J[10]=t,J[11]=m,J[12]=e,J[13]=y,J[14]=L,J[15]=A,l.markAsUpdated(),l}static Compose(g,w,q){const R=new x;return x.ComposeToRef(g,w,q,R),R}static ComposeToRef(g,w,q,R){const o=R.pS,r=w._x,S=w._y,i=w._z,T=w._w,z=r+r,t=S+S,m=i+i,e=r*z,y=r*t,L=r*m,A=S*t,l=S*m,J=i*m,x=T*z,G=T*t,d=T*m,D=g._x,U=g._y,N=g._z;return o[0]=(1-(A+J))*D,o[1]=(y+d)*D,o[2]=(L-G)*D,o[3]=0,o[4]=(y-d)*U,o[5]=(1-(e+J))*U,o[6]=(l+x)*U,o[7]=0,o[8]=(L+G)*N,o[9]=(l-x)*N,o[10]=(1-(e+A))*N,o[11]=0,o[12]=q._x,o[13]=q._y,o[14]=q._z,o[15]=1,R.markAsUpdated(),R}static Identity(){const g=x.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return g._updateIdentityStatus(!0),g}static IdentityToRef(g){return x.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,g),g._updateIdentityStatus(!0),g}static Zero(){const g=x.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return g._updateIdentityStatus(!1),g}static RotationX(g){const w=new x;return x.RotationXToRef(g,w),w}static Invert(g){const w=new x;return g.invertToRef(w),w}static RotationXToRef(g,w){const q=Math.sin(g),R=Math.cos(g);return x.FromValuesToRef(1,0,0,0,0,R,q,0,0,-q,R,0,0,0,0,1,w),w._updateIdentityStatus(1===R&&0===q),w}static RotationY(g){const w=new x;return x.RotationYToRef(g,w),w}static RotationYToRef(g,w){const q=Math.sin(g),R=Math.cos(g);return x.FromValuesToRef(R,0,-q,0,0,1,0,0,q,0,R,0,0,0,0,1,w),w._updateIdentityStatus(1===R&&0===q),w}static RotationZ(g){const w=new x;return x.RotationZToRef(g,w),w}static RotationZToRef(g,w){const q=Math.sin(g),R=Math.cos(g);return x.FromValuesToRef(R,q,0,0,-q,R,0,0,0,0,1,0,0,0,0,1,w),w._updateIdentityStatus(1===R&&0===q),w}static RotationAxis(g,w){const q=new x;return x.RotationAxisToRef(g,w,q),q}static RotationAxisToRef(g,w,q){const R=Math.sin(-w),o=Math.cos(-w),r=1-o;g=g.normalizeToRef(G.ew[0]);const S=q.pS;return S[0]=g._x*g._x*r+o,S[1]=g._x*g._y*r-g._z*R,S[2]=g._x*g._z*r+g._y*R,S[3]=0,S[4]=g._y*g._x*r+g._z*R,S[5]=g._y*g._y*r+o,S[6]=g._y*g._z*r-g._x*R,S[7]=0,S[8]=g._z*g._x*r-g._y*R,S[9]=g._z*g._y*r+g._x*R,S[10]=g._z*g._z*r+o,S[11]=0,S[12]=0,S[13]=0,S[14]=0,S[15]=1,q.markAsUpdated(),q}static RotationAlignToRef(g,w,q){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=A.Dot(w,g),S=q.pS;if(r<-1+R.c)S[0]=-1,S[1]=0,S[2]=0,S[3]=0,S[4]=0,S[5]=o?1:-1,S[6]=0,S[7]=0,S[8]=0,S[9]=0,S[10]=o?-1:1,S[11]=0;else{const q=A.Cross(w,g),R=1/(1+r);S[0]=q._x*q._x*R+r,S[1]=q._y*q._x*R-q._z,S[2]=q._z*q._x*R+q._y,S[3]=0,S[4]=q._x*q._y*R+q._z,S[5]=q._y*q._y*R+r,S[6]=q._z*q._y*R-q._x,S[7]=0,S[8]=q._x*q._z*R-q._y,S[9]=q._y*q._z*R+q._x,S[10]=q._z*q._z*R+r,S[11]=0}return S[12]=0,S[13]=0,S[14]=0,S[15]=1,q.markAsUpdated(),q}static RotationYawPitchRoll(g,w,q){const R=new x;return x.RotationYawPitchRollToRef(g,w,q,R),R}static RotationYawPitchRollToRef(g,w,q,R){return J.RotationYawPitchRollToRef(g,w,q,G.Quaternion[0]),G.Quaternion[0].toRotationMatrix(R),R}static Scaling(g,w,q){const R=new x;return x.ScalingToRef(g,w,q,R),R}static ScalingToRef(g,w,q,R){return x.FromValuesToRef(g,0,0,0,0,w,0,0,0,0,q,0,0,0,0,1,R),R._updateIdentityStatus(1===g&&1===w&&1===q),R}static Translation(g,w,q){const R=new x;return x.TranslationToRef(g,w,q,R),R}static TranslationToRef(g,w,q,R){return x.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,g,w,q,1,R),R._updateIdentityStatus(0===g&&0===w&&0===q),R}static Lerp(g,w,q){const R=new x;return x.LerpToRef(g,w,q,R),R}static LerpToRef(g,w,q,R){const o=R.pS,r=g.m,S=w.m;for(let i=0;i<16;i++)o[i]=r[i]*(1-q)+S[i]*q;return R.markAsUpdated(),R}static DecomposeLerp(g,w,q){const R=new x;return x.DecomposeLerpToRef(g,w,q,R),R}static DecomposeLerpToRef(g,w,q,R){const o=G.ew[0],r=G.Quaternion[0],S=G.ew[1];g.decompose(o,r,S);const i=G.ew[2],T=G.Quaternion[1],z=G.ew[3];w.decompose(i,T,z);const t=G.ew[4];A.LerpToRef(o,i,q,t);const m=G.Quaternion[2];J.SlerpToRef(r,T,q,m);const e=G.ew[5];return A.LerpToRef(S,z,q,e),x.ComposeToRef(t,m,e,R),R}static LookAtLH(g,w,q){const R=new x;return x.LookAtLHToRef(g,w,q,R),R}static LookAtLHToRef(g,w,q,R){const o=G.ew[0],r=G.ew[1],S=G.ew[2];w.subtractToRef(g,S),S.normalize(),A.CrossToRef(q,S,o);const i=o.lengthSquared();0===i?o.x=1:o.normalizeFromLength(Math.sqrt(i)),A.CrossToRef(S,o,r),r.normalize();const T=-A.Dot(o,g),z=-A.Dot(r,g),t=-A.Dot(S,g);return x.FromValuesToRef(o._x,r._x,S._x,0,o._y,r._y,S._y,0,o._z,r._z,S._z,0,T,z,t,1,R),R}static LookAtRH(g,w,q){const R=new x;return x.LookAtRHToRef(g,w,q,R),R}static LookAtRHToRef(g,w,q,R){const o=G.ew[0],r=G.ew[1],S=G.ew[2];g.subtractToRef(w,S),S.normalize(),A.CrossToRef(q,S,o);const i=o.lengthSquared();0===i?o.x=1:o.normalizeFromLength(Math.sqrt(i)),A.CrossToRef(S,o,r),r.normalize();const T=-A.Dot(o,g),z=-A.Dot(r,g),t=-A.Dot(S,g);return x.FromValuesToRef(o._x,r._x,S._x,0,o._y,r._y,S._y,0,o._z,r._z,S._z,0,T,z,t,1,R),R}static LookDirectionLH(g,w){const q=new x;return x.LookDirectionLHToRef(g,w,q),q}static LookDirectionLHToRef(g,w,q){const R=G.ew[0];R.T(g),R.scaleInPlace(-1);const o=G.ew[1];return A.CrossToRef(w,R,o),x.FromValuesToRef(o._x,o._y,o._z,0,w._x,w._y,w._z,0,R._x,R._y,R._z,0,0,0,0,1,q),q}static LookDirectionRH(g,w){const q=new x;return x.LookDirectionRHToRef(g,w,q),q}static LookDirectionRHToRef(g,w,q){const R=G.ew[2];return A.CrossToRef(w,g,R),x.FromValuesToRef(R._x,R._y,R._z,0,w._x,w._y,w._z,0,g._x,g._y,g._z,0,0,0,0,1,q),q}static OrthoLH(g,w,q,R,o){const r=new x;return x.OrthoLHToRef(g,w,q,R,r,o),r}static OrthoLHToRef(g,w,q,R,o,r){const S=2/g,i=2/w,T=2/(R-q),z=-(R+q)/(R-q);return x.FromValuesToRef(S,0,0,0,0,i,0,0,0,0,T,0,0,0,z,1,o),r&&o.multiplyToRef(D,o),o._updateIdentityStatus(1===S&&1===i&&1===T&&0===z),o}static OrthoOffCenterLH(g,w,q,R,o,r,S){const i=new x;return x.OrthoOffCenterLHToRef(g,w,q,R,o,r,i,S),i}static OrthoOffCenterLHToRef(g,w,q,R,o,r,S,i){const T=2/(w-g),z=2/(R-q),t=2/(r-o),m=-(r+o)/(r-o),e=(g+w)/(g-w),y=(R+q)/(q-R);return x.FromValuesToRef(T,0,0,0,0,z,0,0,0,0,t,0,e,y,m,1,S),i&&S.multiplyToRef(D,S),S.markAsUpdated(),S}static ObliqueOffCenterLHToRef(g,w,q,R,o,r,S,i,T,z,t){const m=-S*Math.cos(i),e=-S*Math.sin(i);return x.TranslationToRef(0,0,-T,G.Matrix[1]),x.FromValuesToRef(1,0,0,0,0,1,0,0,m,e,1,0,0,0,0,1,G.Matrix[0]),G.Matrix[1].multiplyToRef(G.Matrix[0],G.Matrix[0]),x.TranslationToRef(0,0,T,G.Matrix[1]),G.Matrix[0].multiplyToRef(G.Matrix[1],G.Matrix[0]),x.OrthoOffCenterLHToRef(g,w,q,R,o,r,z,t),G.Matrix[0].multiplyToRef(z,z),z}static OrthoOffCenterRH(g,w,q,R,o,r,S){const i=new x;return x.OrthoOffCenterRHToRef(g,w,q,R,o,r,i,S),i}static OrthoOffCenterRHToRef(g,w,q,R,o,r,S,i){return x.OrthoOffCenterLHToRef(g,w,q,R,o,r,S,i),S.pS[10]*=-1,S}static ObliqueOffCenterRHToRef(g,w,q,R,o,r,S,i,T,z,t){const m=S*Math.cos(i),e=S*Math.sin(i);return x.TranslationToRef(0,0,T,G.Matrix[1]),x.FromValuesToRef(1,0,0,0,0,1,0,0,m,e,1,0,0,0,0,1,G.Matrix[0]),G.Matrix[1].multiplyToRef(G.Matrix[0],G.Matrix[0]),x.TranslationToRef(0,0,-T,G.Matrix[1]),G.Matrix[0].multiplyToRef(G.Matrix[1],G.Matrix[0]),x.OrthoOffCenterRHToRef(g,w,q,R,o,r,z,t),G.Matrix[0].multiplyToRef(z,z),z}static PerspectiveLH(g,w,q,R,o){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const S=new x,i=2*q/g,T=2*q/w,z=(R+q)/(R-q),t=-2*R*q/(R-q),m=Math.tan(r);return x.FromValuesToRef(i,0,0,0,0,T,0,m,0,0,z,1,0,0,t,0,S),o&&S.multiplyToRef(D,S),S._updateIdentityStatus(!1),S}static PerspectiveFovLH(g,w,q,R,o){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,S=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const i=new x;return x.PerspectiveFovLHToRef(g,w,q,R,i,!0,o,r,S),i}static PerspectiveFovLHToRef(g,w,q,R,o){let r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],S=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,T=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const z=q,t=R,m=1/Math.tan(.5*g),e=r?m/w:m,y=r?m:m*w,L=T&&0===z?-1:0!==t?(t+z)/(t-z):1,A=T&&0===z?2*t:0!==t?-2*t*z/(t-z):-2*z,l=Math.tan(i);return x.FromValuesToRef(e,0,0,0,0,y,0,l,0,0,L,1,0,0,A,0,o),S&&o.multiplyToRef(D,o),o._updateIdentityStatus(!1),o}static PerspectiveFovReverseLHToRef(g,w,q,R,o){let r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],S=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const T=1/Math.tan(.5*g),z=r?T/w:T,t=r?T:T*w,m=Math.tan(i);return x.FromValuesToRef(z,0,0,0,0,t,0,m,0,0,-q,1,0,0,1,0,o),S&&o.multiplyToRef(D,o),o._updateIdentityStatus(!1),o}static PerspectiveFovRH(g,w,q,R,o){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,S=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const i=new x;return x.PerspectiveFovRHToRef(g,w,q,R,i,!0,o,r,S),i}static PerspectiveFovRHToRef(g,w,q,R,o){let r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],S=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,T=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const z=q,t=R,m=1/Math.tan(.5*g),e=r?m/w:m,y=r?m:m*w,L=T&&0===z?1:0!==t?-(t+z)/(t-z):-1,A=T&&0===z?2*t:0!==t?-2*t*z/(t-z):-2*z,l=Math.tan(i);return x.FromValuesToRef(e,0,0,0,0,y,0,l,0,0,L,-1,0,0,A,0,o),S&&o.multiplyToRef(D,o),o._updateIdentityStatus(!1),o}static PerspectiveFovReverseRHToRef(g,w,q,R,o){let r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],S=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const T=1/Math.tan(.5*g),z=r?T/w:T,t=r?T:T*w,m=Math.tan(i);return x.FromValuesToRef(z,0,0,0,0,t,0,m,0,0,-q,-1,0,0,-1,0,o),S&&o.multiplyToRef(D,o),o._updateIdentityStatus(!1),o}static GetFinalMatrix(g,w,q,R,o,r){const S=g.width,i=g.height,T=g.x,z=g.y,t=x.FromValues(S/2,0,0,0,0,-i/2,0,0,0,0,r-o,0,T+S/2,i/2+z,o,1),m=new x;return w.multiplyToRef(q,m),m.multiplyToRef(R,m),m.multiplyToRef(t,m)}static GetAsMatrix2x2(g){const w=g.m,q=[w[0],w[1],w[4],w[5]];return S.b.MatrixUse64Bits?q:new Float32Array(q)}static GetAsMatrix3x3(g){const w=g.m,q=[w[0],w[1],w[2],w[4],w[5],w[6],w[8],w[9],w[10]];return S.b.MatrixUse64Bits?q:new Float32Array(q)}static Transpose(g){const w=new x;return x.TransposeToRef(g,w),w}static TransposeToRef(g,w){const q=g.m,R=q[0],o=q[4],r=q[8],S=q[12],i=q[1],T=q[5],z=q[9],t=q[13],m=q[2],e=q[6],y=q[10],L=q[14],A=q[3],l=q[7],J=q[11],x=q[15],G=w.pS;return G[0]=R,G[1]=o,G[2]=r,G[3]=S,G[4]=i,G[5]=T,G[6]=z,G[7]=t,G[8]=m,G[9]=e,G[10]=y,G[11]=L,G[12]=A,G[13]=l,G[14]=J,G[15]=x,w.markAsUpdated(),w._updateIdentityStatus(g._isIdentity,g._isIdentityDirty),w}static Reflection(g){const w=new x;return x.ReflectionToRef(g,w),w}static ReflectionToRef(g,w){g.normalize();const q=g.Lw.x,R=g.Lw.y,o=g.Lw.z,r=-2*q,S=-2*R,i=-2*o;return x.FromValuesToRef(r*q+1,S*q,i*q,0,r*R,S*R+1,i*R,0,r*o,S*o,i*o+1,0,r*g.d,S*g.d,i*g.d,1,w),w}static FromXYZAxesToRef(g,w,q,R){return x.FromValuesToRef(g._x,g._y,g._z,0,w._x,w._y,w._z,0,q._x,q._y,q._z,0,0,0,0,1,R),R}static FromQuaternionToRef(g,w){const q=g._x*g._x,R=g._y*g._y,o=g._z*g._z,r=g._x*g._y,S=g._z*g._w,i=g._z*g._x,T=g._y*g._w,z=g._y*g._z,t=g._x*g._w;return w.pS[0]=1-2*(R+o),w.pS[1]=2*(r+S),w.pS[2]=2*(i-T),w.pS[3]=0,w.pS[4]=2*(r-S),w.pS[5]=1-2*(o+q),w.pS[6]=2*(z+t),w.pS[7]=0,w.pS[8]=2*(i+T),w.pS[9]=2*(z-t),w.pS[10]=1-2*(R+q),w.pS[11]=0,w.pS[12]=0,w.pS[13]=0,w.pS[14]=0,w.pS[15]=1,w.markAsUpdated(),w}}x._IdentityReadOnly=x.Identity(),Object.defineProperties(x.prototype,{dimension:{value:[4,4]},rank:{value:2}});class G{}G.ew=(0,o.g)(11,A.Zero),G.Matrix=(0,o.g)(2,x.Identity),G.Quaternion=(0,o.g)(3,J.Zero);class d{}d.Vector2=(0,o.g)(3,L.Zero),d.ew=(0,o.g)(13,A.Zero),d.Vector4=(0,o.g)(3,l.Zero),d.Quaternion=(0,o.g)(3,J.Zero),d.Matrix=(0,o.g)(8,x.Identity),(0,r.g)("BABYLON.Vector2",L),(0,r.g)("BABYLON.Vector3",A),(0,r.g)("BABYLON.Vector4",l),(0,r.g)("BABYLON.Matrix",x);const D=x.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11192:(g,w,q)=>{function R(g,w){const q=[];for(let R=0;R<g;++R)q.push(w());return q}function o(g,w){return R(g,w)}q.d(w,{e:()=>R,g:()=>o,h:()=>S});const r=["push","splice","pop","shift","unshift"];function S(g,w){const q=r.map((q=>function(g,w,q){const R=g[w];if("function"!==typeof R)return null;const o=function(){const R=g.length,r=o.previous.apply(g,arguments);return q(w,R),r};return R.next=o,o.previous=R,g[w]=o,()=>{const q=o.previous;if(!q)return;const R=o.next;R?(q.next=R,R.previous=q):(q.next=void 0,g[w]=q),o.next=void 0,o.previous=void 0}}(g,q,w)));return()=>{for(const g of q)null===g||void 0===g||g()}}}}]);