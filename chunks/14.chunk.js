"use strict";(self.hmihoa2fs98=self.hmihoa2fs98||[]).push([[14],{11688:(b,d,P)=>{P.d(d,{c:()=>q,f:()=>i,h:()=>G,j:()=>W});const G=1/2.2,W=2.2,i=(1+Math.sqrt(5))/2,q=.001},11700:(b,d,P)=>{function G(b){return parseInt(b.toString().replace(/\W/g,""))}function W(b,d){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(b-d)<=P}function i(b,d,P){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return b<d-G||b>P+G}function q(b,d){return b===d?b:Math.random()*(d-b)+b}function C(b,d,P){return b+(d-b)*P}function J(b,d,P){let G=r(d-b,360);return G>180&&(G-=360),b+G*s(P)}function L(b,d,P){let G=0;return G=b!=d?s((P-b)/(d-b)):0,G}function x(b,d,P,G,W){const i=W*W,q=W*i;return b*(2*q-3*i+1)+P*(-2*q+3*i)+d*(q-2*i+W)+G*(q-i)}function Y(b,d,P,G,W){const i=W*W;return 6*(i-W)*b+(3*i-4*W+1)*d+6*(-i+W)*P+(3*i-2*W)*G}function s(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(P,Math.max(d,b))}function E(b){return b-=2*Math.PI*Math.floor((b+Math.PI)/(2*Math.PI))}function w(b){const d=b.toString(16);return b<=15?("0"+d).toUpperCase():d.toUpperCase()}function t(b){if(Math.log2)return Math.floor(Math.log2(b));if(b<0)return NaN;if(0===b)return-1/0;let d=0;if(b<1){for(;b<1;)d++,b*=2;d=-d}else if(b>1)for(;b>1;)d++,b=Math.floor(b/2);return d}function r(b,d){return b-Math.floor(b/d)*d}function B(b,d,P){return(b-d)/(P-d)}function n(b,d,P){return b*(P-d)+d}function Z(b,d){let P=r(d-b,360);return P>180&&(P-=360),P}function o(b,d){const P=r(b,2*d);return d-Math.abs(P-d)}function A(b,d,P){let G=s(P);return G=-2*G*G*G+3*G*G,d*G+b*(1-G)}function f(b,d,P){let G=0;return G=Math.abs(d-b)<=P?d:b+Math.sign(d-b)*P,G}function g(b,d,P){const G=Z(b,d);let W=0;return W=-P<G&&G<P?d:f(b,d=b+G,P),W}function X(b,d,P){return(b-d)/(P-d)}function u(b,d,P){return(P-d)*b+d}function M(b,d){const P=b%d;return 0===P?d:M(d,P)}P.r(d),P.d(d,{Clamp:()=>s,DeltaAngle:()=>Z,Denormalize:()=>n,ExtractAsInt:()=>G,Hermite:()=>x,Hermite1stDerivative:()=>Y,HighestCommonFactor:()=>M,ILog2:()=>t,InverseLerp:()=>L,Lerp:()=>C,LerpAngle:()=>J,MoveTowards:()=>f,MoveTowardsAngle:()=>g,Normalize:()=>B,NormalizeRadians:()=>E,OutsideRange:()=>i,PercentToRange:()=>u,PingPong:()=>o,RandomRange:()=>q,RangeToPercent:()=>X,Repeat:()=>r,SmoothStep:()=>A,ToHex:()=>w,WithinEpsilon:()=>W})},11681:(b,d,P)=>{P.r(d),P.d(d,{Matrix:()=>n,Quaternion:()=>B,TmpVectors:()=>o,Vector2:()=>w,ed:()=>t,Vector4:()=>r});var G=P(11688),W=P(11691),i=P(11639),q=P(11614),C=P(11535),J=P(11700);class L{}function x(b,d,P){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const W=b.jd(),i=d.jd(),q=W[0],C=W[1],J=W[2],L=W[3],x=W[4],Y=W[5],s=W[6],E=W[7],w=W[8],t=W[9],r=W[10],B=W[11],n=W[12],Z=W[13],o=W[14],A=W[15],f=i[0],g=i[1],X=i[2],u=i[3],M=i[4],e=i[5],R=i[6],U=i[7],H=i[8],p=i[9],S=i[10],l=i[11],N=i[12],j=i[13],a=i[14],O=i[15];P[G]=q*f+C*M+J*H+L*N,P[G+1]=q*g+C*e+J*p+L*j,P[G+2]=q*X+C*R+J*S+L*a,P[G+3]=q*u+C*U+J*l+L*O,P[G+4]=x*f+Y*M+s*H+E*N,P[G+5]=x*g+Y*e+s*p+E*j,P[G+6]=x*X+Y*R+s*S+E*a,P[G+7]=x*u+Y*U+s*l+E*O,P[G+8]=w*f+t*M+r*H+B*N,P[G+9]=w*g+t*e+r*p+B*j,P[G+10]=w*X+t*R+r*S+B*a,P[G+11]=w*u+t*U+r*l+B*O,P[G+12]=n*f+Z*M+o*H+A*N,P[G+13]=n*g+Z*e+o*p+A*j,P[G+14]=n*X+Z*R+o*S+A*a,P[G+15]=n*u+Z*U+o*l+A*O}function Y(b,d){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const G=b.jd();d[P]=G[0],d[P+1]=G[1],d[P+2]=G[2],d[P+3]=G[3],d[P+4]=G[4],d[P+5]=G[5],d[P+6]=G[6],d[P+7]=G[7],d[P+8]=G[8],d[P+9]=G[9],d[P+10]=G[10],d[P+11]=G[11],d[P+12]=G[12],d[P+13]=G[13],d[P+14]=G[14],d[P+15]=G[15]}function s(b,d){const P=b.jd(),G=P[0],W=P[1],i=P[2],q=P[3],C=P[4],J=P[5],L=P[6],x=P[7],Y=P[8],s=P[9],E=P[10],w=P[11],t=P[12],r=P[13],B=P[14],n=P[15],Z=E*n-B*w,o=s*n-r*w,A=s*B-r*E,f=Y*n-t*w,g=Y*B-E*t,X=Y*r-t*s,u=+(J*Z-L*o+x*A),M=-(C*Z-L*f+x*g),e=+(C*o-J*f+x*X),R=-(C*A-J*g+L*X),U=G*u+W*M+i*e+q*R;if(0===U)return!1;const H=1/U,p=L*n-B*x,S=J*n-r*x,l=J*B-r*L,N=C*n-t*x,j=C*B-t*L,a=C*r-t*J,O=L*w-E*x,V=J*w-s*x,y=J*E-s*L,c=C*w-Y*x,D=C*E-Y*L,z=C*s-Y*J,Q=-(W*Z-i*o+q*A),I=+(G*Z-i*f+q*g),m=-(G*o-W*f+q*X),v=+(G*A-W*g+i*X),F=+(W*p-i*S+q*l),h=-(G*p-i*N+q*j),T=+(G*S-W*N+q*a),K=-(G*l-W*j+i*a),k=-(W*O-i*V+q*y),bb=+(G*O-i*c+q*D),db=-(G*V-W*c+q*z),Pb=+(G*y-W*D+i*z);return d[0]=u*H,d[1]=Q*H,d[2]=F*H,d[3]=k*H,d[4]=M*H,d[5]=I*H,d[6]=h*H,d[7]=bb*H,d[8]=e*H,d[9]=m*H,d[10]=T*H,d[11]=db*H,d[12]=R*H,d[13]=v*H,d[14]=K*H,d[15]=Pb*H,!0}L._UpdateFlagSeed=0;const E=b=>parseInt(b.toString().replace(/\W/g,""));class w{constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=b,this.y=d}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let b=E(this.x);return b=397*b^E(this.y),b}toArray(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[d]=this.x,b[d+1]=this.y,this}DP(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w.FromArrayToRef(b,d,this),this}jd(){return[this.x,this.y]}q(b){return this.x=b.x,this.y=b.y,this}Fd(b,d){return this.x=b,this.y=d,this}set(b,d){return this.Fd(b,d)}kd(b){return this.Fd(b,b)}add(b){return new w(this.x+b.x,this.y+b.y)}addToRef(b,d){return d.x=this.x+b.x,d.y=this.y+b.y,d}addInPlace(b){return this.x+=b.x,this.y+=b.y,this}addInPlaceFromFloats(b,d){return this.x+=b,this.y+=d,this}addVector3(b){return new w(this.x+b.x,this.y+b.y)}Rd(b){return new w(this.x-b.x,this.y-b.y)}subtractToRef(b,d){return d.x=this.x-b.x,d.y=this.y-b.y,d}GY(b){return this.x-=b.x,this.y-=b.y,this}multiplyInPlace(b){return this.x*=b.x,this.y*=b.y,this}multiply(b){return new w(this.x*b.x,this.y*b.y)}multiplyToRef(b,d){return d.x=this.x*b.x,d.y=this.y*b.y,d}multiplyByFloats(b,d){return new w(this.x*b,this.y*d)}divide(b){return new w(this.x/b.x,this.y/b.y)}divideToRef(b,d){return d.x=this.x/b.x,d.y=this.y/b.y,d}divideInPlace(b){return this.x=this.x/b.x,this.y=this.y/b.y,this}minimizeInPlace(b){return this.minimizeInPlaceFromFloats(b.x,b.y)}maximizeInPlace(b){return this.maximizeInPlaceFromFloats(b.x,b.y)}minimizeInPlaceFromFloats(b,d){return this.x=Math.min(b,this.x),this.y=Math.min(d,this.y),this}maximizeInPlaceFromFloats(b,d){return this.x=Math.max(b,this.x),this.y=Math.max(d,this.y),this}subtractFromFloats(b,d){return new w(this.x-b,this.y-d)}subtractFromFloatsToRef(b,d,P){return P.x=this.x-b,P.y=this.y-d,P}negate(){return new w(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(b){return b.x=-this.x,b.y=-this.y,b}scaleInPlace(b){return this.x*=b,this.y*=b,this}scale(b){return new w(this.x*b,this.y*b)}scaleToRef(b,d){return d.x=this.x*b,d.y=this.y*b,d}scaleAndAddToRef(b,d){return d.x+=this.x*b,d.y+=this.y*b,d}equals(b){return b&&this.x===b.x&&this.y===b.y}equalsWithEpsilon(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return b&&(0,J.WithinEpsilon)(this.x,b.x,d)&&(0,J.WithinEpsilon)(this.y,b.y,d)}equalsToFloats(b,d){return this.x===b&&this.y===d}floor(){return new w(Math.floor(this.x),Math.floor(this.y))}floorToRef(b){return b.x=Math.floor(this.x),b.y=Math.floor(this.y),b}fract(){return new w(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(b){return b.x=this.x-Math.floor(this.x),b.y=this.y-Math.floor(this.y),b}rotate(b){return this.rotateToRef(b,new w)}rotateToRef(b,d){const P=Math.cos(b),G=Math.sin(b);return d.x=P*this.x-G*this.y,d.y=G*this.x+P*this.y,d}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){const b=new w;return this.normalizeToRef(b),b}normalizeToRef(b){const d=this.length();return 0===d&&(b.x=this.x,b.y=this.y),this.scaleToRef(1/d,b)}clone(){return new w(this.x,this.y)}dot(b){return this.x*b.x+this.y*b.y}static Zero(){return new w(0,0)}static One(){return new w(1,1)}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new w((0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Fd((0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d))}static get ZeroReadOnly(){return w._ZeroReadOnly}static Od(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new w(b[d],b[d+1])}static FromArrayToRef(b,d,P){return P.x=b[d],P.y=b[d+1],P}static FromFloatsToRef(b,d,P){return P.Fd(b,d),P}static CatmullRom(b,d,P,G,W){const i=W*W,q=W*i,C=.5*(2*d.x+(-b.x+P.x)*W+(2*b.x-5*d.x+4*P.x-G.x)*i+(-b.x+3*d.x-3*P.x+G.x)*q),J=.5*(2*d.y+(-b.y+P.y)*W+(2*b.y-5*d.y+4*P.y-G.y)*i+(-b.y+3*d.y-3*P.y+G.y)*q);return new w(C,J)}static ClampToRef(b,d,P,G){return G.x=(0,J.Clamp)(b.x,d.x,P.x),G.y=(0,J.Clamp)(b.y,d.y,P.y),G}static Clamp(b,d,P){const G=(0,J.Clamp)(b.x,d.x,P.x),W=(0,J.Clamp)(b.y,d.y,P.y);return new w(G,W)}static Hermite(b,d,P,G,W){const i=W*W,q=W*i,C=2*q-3*i+1,J=-2*q+3*i,L=q-2*i+W,x=q-i,Y=b.x*C+P.x*J+d.x*L+G.x*x,s=b.y*C+P.y*J+d.y*L+G.y*x;return new w(Y,s)}static Hermite1stDerivative(b,d,P,G,W){return this.Hermite1stDerivativeToRef(b,d,P,G,W,new w)}static Hermite1stDerivativeToRef(b,d,P,G,W,i){const q=W*W;return i.x=6*(q-W)*b.x+(3*q-4*W+1)*d.x+6*(-q+W)*P.x+(3*q-2*W)*G.x,i.y=6*(q-W)*b.y+(3*q-4*W+1)*d.y+6*(-q+W)*P.y+(3*q-2*W)*G.y,i}static Lerp(b,d,P){return w.LerpToRef(b,d,P,new w)}static LerpToRef(b,d,P,G){return G.x=b.x+(d.x-b.x)*P,G.y=b.y+(d.y-b.y)*P,G}static Dot(b,d){return b.x*d.x+b.y*d.y}static Normalize(b){return w.NormalizeToRef(b,new w)}static NormalizeToRef(b,d){return b.normalizeToRef(d),d}static Minimize(b,d){const P=b.x<d.x?b.x:d.x,G=b.y<d.y?b.y:d.y;return new w(P,G)}static Maximize(b,d){const P=b.x>d.x?b.x:d.x,G=b.y>d.y?b.y:d.y;return new w(P,G)}static Transform(b,d){return w.TransformToRef(b,d,new w)}static TransformToRef(b,d,P){const G=d.m,W=b.x*G[0]+b.y*G[4]+G[12],i=b.x*G[1]+b.y*G[5]+G[13];return P.x=W,P.y=i,P}static PointInTriangle(b,d,P,G){const W=.5*(-P.y*G.x+d.y*(-P.x+G.x)+d.x*(P.y-G.y)+P.x*G.y),i=W<0?-1:1,q=(d.y*G.x-d.x*G.y+(G.y-d.y)*b.x+(d.x-G.x)*b.y)*i,C=(d.x*P.y-d.y*P.x+(d.y-P.y)*b.x+(P.x-d.x)*b.y)*i;return q>0&&C>0&&q+C<2*W*i}static Distance(b,d){return Math.sqrt(w.DistanceSquared(b,d))}static DistanceSquared(b,d){const P=b.x-d.x,G=b.y-d.y;return P*P+G*G}static Center(b,d){return w.CenterToRef(b,d,new w)}static CenterToRef(b,d,P){return P.Fd((b.x+d.x)/2,(b.y+d.y)/2)}static DistanceOfPointFromSegment(b,d,P){const G=w.DistanceSquared(d,P);if(0===G)return w.Distance(b,d);const W=P.Rd(d),i=Math.max(0,Math.min(1,w.Dot(b.Rd(d),W)/G)),q=d.add(W.multiplyByFloats(i,i));return w.Distance(b,q)}}w._V8PerformanceHack=new w(.5,.5),w._ZeroReadOnly=w.Zero(),Object.defineProperties(w.prototype,{dimension:{value:[2]},rank:{value:1}});class t{get x(){return this._x}set x(b){this._x=b,this._isDirty=!0}get y(){return this._y}set y(b){this._y=b,this._isDirty=!0}get z(){return this._z}set z(b){this._z=b,this._isDirty=!0}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=b,this._y=d,this._z=P}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"ed"}getHashCode(){let b=E(this._x);return b=397*b^E(this._y),b=397*b^E(this._z),b}jd(){return[this._x,this._y,this._z]}toArray(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[d]=this._x,b[d+1]=this._y,b[d+2]=this._z,this}DP(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(b,d,this),this}toQuaternion(){return B.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(b){return this._x+=b._x,this._y+=b._y,this._z+=b._z,this._isDirty=!0,this}addInPlaceFromFloats(b,d,P){return this._x+=b,this._y+=d,this._z+=P,this._isDirty=!0,this}add(b){return new t(this._x+b._x,this._y+b._y,this._z+b._z)}addToRef(b,d){return d._x=this._x+b._x,d._y=this._y+b._y,d._z=this._z+b._z,d._isDirty=!0,d}GY(b){return this._x-=b._x,this._y-=b._y,this._z-=b._z,this._isDirty=!0,this}Rd(b){return new t(this._x-b._x,this._y-b._y,this._z-b._z)}subtractToRef(b,d){return this.subtractFromFloatsToRef(b._x,b._y,b._z,d)}subtractFromFloats(b,d,P){return new t(this._x-b,this._y-d,this._z-P)}subtractFromFloatsToRef(b,d,P,G){return G._x=this._x-b,G._y=this._y-d,G._z=this._z-P,G._isDirty=!0,G}negate(){return new t(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(b){return b._x=-1*this._x,b._y=-1*this._y,b._z=-1*this._z,b._isDirty=!0,b}scaleInPlace(b){return this._x*=b,this._y*=b,this._z*=b,this._isDirty=!0,this}scale(b){return new t(this._x*b,this._y*b,this._z*b)}scaleToRef(b,d){return d._x=this._x*b,d._y=this._y*b,d._z=this._z*b,d._isDirty=!0,d}getNormalToRef(b){const d=this.length();let P=Math.acos(this._y/d);const G=Math.atan2(this._z,this._x);P>Math.PI/2?P-=Math.PI/2:P+=Math.PI/2;const W=d*Math.sin(P)*Math.cos(G),i=d*Math.cos(P),q=d*Math.sin(P)*Math.sin(G);return b.set(W,i,q),b}applyRotationQuaternionToRef(b,d){const P=this._x,G=this._y,W=this._z,i=b._x,q=b._y,C=b._z,J=b._w,L=2*(q*W-C*G),x=2*(C*P-i*W),Y=2*(i*G-q*P);return d._x=P+J*L+q*Y-C*x,d._y=G+J*x+C*L-i*Y,d._z=W+J*Y+i*x-q*L,d._isDirty=!0,d}applyRotationQuaternionInPlace(b){return this.applyRotationQuaternionToRef(b,this)}applyRotationQuaternion(b){return this.applyRotationQuaternionToRef(b,new t)}scaleAndAddToRef(b,d){return d._x+=this._x*b,d._y+=this._y*b,d._z+=this._z*b,d._isDirty=!0,d}projectOnPlane(b,d){return this.projectOnPlaneToRef(b,d,new t)}projectOnPlaneToRef(b,d,P){const G=b.normal,W=b.d,i=Z.ed[0];this.subtractToRef(d,i),i.normalize();const q=t.Dot(i,G);if(Math.abs(q)<1e-10)P.kd(1/0);else{const b=-(t.Dot(d,G)+W)/q,C=i.scaleInPlace(b);d.addToRef(C,P)}return P}equals(b){return b&&this._x===b._x&&this._y===b._y&&this._z===b._z}equalsWithEpsilon(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return b&&(0,J.WithinEpsilon)(this._x,b._x,d)&&(0,J.WithinEpsilon)(this._y,b._y,d)&&(0,J.WithinEpsilon)(this._z,b._z,d)}equalsToFloats(b,d,P){return this._x===b&&this._y===d&&this._z===P}multiplyInPlace(b){return this._x*=b._x,this._y*=b._y,this._z*=b._z,this._isDirty=!0,this}multiply(b){return this.multiplyByFloats(b._x,b._y,b._z)}multiplyToRef(b,d){return d._x=this._x*b._x,d._y=this._y*b._y,d._z=this._z*b._z,d._isDirty=!0,d}multiplyByFloats(b,d,P){return new t(this._x*b,this._y*d,this._z*P)}divide(b){return new t(this._x/b._x,this._y/b._y,this._z/b._z)}divideToRef(b,d){return d._x=this._x/b._x,d._y=this._y/b._y,d._z=this._z/b._z,d._isDirty=!0,d}divideInPlace(b){return this._x=this._x/b._x,this._y=this._y/b._y,this._z=this._z/b._z,this._isDirty=!0,this}minimizeInPlace(b){return this.minimizeInPlaceFromFloats(b._x,b._y,b._z)}maximizeInPlace(b){return this.maximizeInPlaceFromFloats(b._x,b._y,b._z)}minimizeInPlaceFromFloats(b,d,P){return b<this._x&&(this.x=b),d<this._y&&(this.y=d),P<this._z&&(this.z=P),this}maximizeInPlaceFromFloats(b,d,P){return b>this._x&&(this.x=b),d>this._y&&(this.y=d),P>this._z&&(this.z=P),this}isNonUniformWithinEpsilon(b){const d=Math.abs(this._x),P=Math.abs(this._y);if(!(0,J.WithinEpsilon)(d,P,b))return!0;const G=Math.abs(this._z);return!(0,J.WithinEpsilon)(d,G,b)||!(0,J.WithinEpsilon)(P,G,b)}get isNonUniform(){const b=Math.abs(this._x);if(b!==Math.abs(this._y))return!0;return b!==Math.abs(this._z)}floorToRef(b){return b._x=Math.floor(this._x),b._y=Math.floor(this._y),b._z=Math.floor(this._z),b._isDirty=!0,b}floor(){return new t(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(b){return b._x=this._x-Math.floor(this._x),b._y=this._y-Math.floor(this._y),b._z=this._z-Math.floor(this._z),b._isDirty=!0,b}fract(){return new t(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(b){if("xyz"===(b=b.toLowerCase()))return this;const d=Z.ed[0].q(this);return this.x=d[b[0]],this.y=d[b[1]],this.z=d[b[2]],this}rotateByQuaternionToRef(b,d){return b.toRotationMatrix(Z.Matrix[0]),t.TransformCoordinatesToRef(this,Z.Matrix[0],d),d}rotateByQuaternionAroundPointToRef(b,d,P){return this.subtractToRef(d,Z.ed[0]),Z.ed[0].rotateByQuaternionToRef(b,Z.ed[0]),d.addToRef(Z.ed[0],P),P}cross(b){return t.CrossToRef(this,b,new t)}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){return this.normalizeToRef(new t)}normalizeToRef(b){const d=this.length();return 0===d||1===d?(b._x=this._x,b._y=this._y,b._z=this._z,b._isDirty=!0,b):this.scaleToRef(1/d,b)}clone(){return new t(this._x,this._y,this._z)}q(b){return this.Fd(b._x,b._y,b._z)}Fd(b,d,P){return this._x=b,this._y=d,this._z=P,this._isDirty=!0,this}set(b,d,P){return this.Fd(b,d,P)}kd(b){return this._x=this._y=this._z=b,this._isDirty=!0,this}static GetClipFactor(b,d,P,G){const W=t.Dot(b,P);return(W-G)/(W-t.Dot(d,P))}static GetAngleBetweenVectors(b,d,P){const G=b.normalizeToRef(Z.ed[1]),W=d.normalizeToRef(Z.ed[2]);let i=t.Dot(G,W);i=(0,J.Clamp)(i,-1,1);const q=Math.acos(i),C=Z.ed[3];return t.CrossToRef(G,W,C),t.Dot(C,P)>0?isNaN(q)?0:q:isNaN(q)?-Math.PI:-Math.acos(i)}static GetAngleBetweenVectorsOnPlane(b,d,P){Z.ed[0].q(b);const G=Z.ed[0];Z.ed[1].q(d);const W=Z.ed[1];Z.ed[2].q(P);const i=Z.ed[2],q=Z.ed[3],C=Z.ed[4];G.normalize(),W.normalize(),i.normalize(),t.CrossToRef(i,G,q),t.CrossToRef(q,i,C);const L=Math.atan2(t.Dot(W,q),t.Dot(W,C));return(0,J.NormalizeRadians)(L)}static PitchYawRollToMoveBetweenPointsToRef(b,d,P){const G=o.ed[0];return d.subtractToRef(b,G),P._y=Math.atan2(G.x,G.z)||0,P._x=Math.atan2(Math.sqrt(G.x**2+G.z**2),G.y)||0,P._z=0,P._isDirty=!0,P}static PitchYawRollToMoveBetweenPoints(b,d){const P=t.Zero();return t.PitchYawRollToMoveBetweenPointsToRef(b,d,P)}static SlerpToRef(b,d,P,W){P=(0,J.Clamp)(P,0,1);const i=Z.ed[0],q=Z.ed[1];i.q(b);const C=i.length();i.normalizeFromLength(C),q.q(d);const L=q.length();q.normalizeFromLength(L);const x=t.Dot(i,q);let Y,s;if(x<1-G.c){const b=Math.acos(x),d=1/Math.sin(b);Y=Math.sin((1-P)*b)*d,s=Math.sin(P*b)*d}else Y=1-P,s=P;return i.scaleInPlace(Y),q.scaleInPlace(s),W.q(i).addInPlace(q),W.scaleInPlace((0,J.Lerp)(C,L,P)),W}static SmoothToRef(b,d,P,G,W){return t.SlerpToRef(b,d,0===G?1:P/G,W),W}static Od(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new t(b[d],b[d+1],b[d+2])}static FromFloatArray(b,d){return t.Od(b,d)}static FromArrayToRef(b,d,P){return P._x=b[d],P._y=b[d+1],P._z=b[d+2],P._isDirty=!0,P}static FromFloatArrayToRef(b,d,P){return t.FromArrayToRef(b,d,P)}static FromFloatsToRef(b,d,P,G){return G.Fd(b,d,P),G}static Zero(){return new t(0,0,0)}static One(){return new t(1,1,1)}static Up(){return new t(0,1,0)}static get UpReadOnly(){return t._UpReadOnly}static get DownReadOnly(){return t._DownReadOnly}static get RightReadOnly(){return t._RightReadOnly}static get LeftReadOnly(){return t._LeftReadOnly}static get LeftHandedForwardReadOnly(){return t._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return t._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return t._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return t._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return t._ZeroReadOnly}static get OneReadOnly(){return t._OneReadOnly}static Down(){return new t(0,-1,0)}static Forward(){return new t(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new t(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new t(1,0,0)}static Left(){return new t(-1,0,0)}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new t((0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Fd((0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d))}static TransformCoordinates(b,d){const P=t.Zero();return t.TransformCoordinatesToRef(b,d,P),P}static TransformCoordinatesToRef(b,d,P){return t.TransformCoordinatesFromFloatsToRef(b._x,b._y,b._z,d,P),P}static TransformCoordinatesFromFloatsToRef(b,d,P,G,W){const i=G.m,q=b*i[0]+d*i[4]+P*i[8]+i[12],C=b*i[1]+d*i[5]+P*i[9]+i[13],J=b*i[2]+d*i[6]+P*i[10]+i[14],L=1/(b*i[3]+d*i[7]+P*i[11]+i[15]);return W._x=q*L,W._y=C*L,W._z=J*L,W._isDirty=!0,W}static TransformNormal(b,d){const P=t.Zero();return t.TransformNormalToRef(b,d,P),P}static TransformNormalToRef(b,d,P){return this.TransformNormalFromFloatsToRef(b._x,b._y,b._z,d,P),P}static TransformNormalFromFloatsToRef(b,d,P,G,W){const i=G.m;return W._x=b*i[0]+d*i[4]+P*i[8],W._y=b*i[1]+d*i[5]+P*i[9],W._z=b*i[2]+d*i[6]+P*i[10],W._isDirty=!0,W}static CatmullRom(b,d,P,G,W){const i=W*W,q=W*i,C=.5*(2*d._x+(-b._x+P._x)*W+(2*b._x-5*d._x+4*P._x-G._x)*i+(-b._x+3*d._x-3*P._x+G._x)*q),J=.5*(2*d._y+(-b._y+P._y)*W+(2*b._y-5*d._y+4*P._y-G._y)*i+(-b._y+3*d._y-3*P._y+G._y)*q),L=.5*(2*d._z+(-b._z+P._z)*W+(2*b._z-5*d._z+4*P._z-G._z)*i+(-b._z+3*d._z-3*P._z+G._z)*q);return new t(C,J,L)}static Clamp(b,d,P){const G=new t;return t.ClampToRef(b,d,P,G),G}static ClampToRef(b,d,P,G){let W=b._x;W=W>P._x?P._x:W,W=W<d._x?d._x:W;let i=b._y;i=i>P._y?P._y:i,i=i<d._y?d._y:i;let q=b._z;return q=q>P._z?P._z:q,q=q<d._z?d._z:q,G.Fd(W,i,q),G}static CheckExtends(b,d,P){d.minimizeInPlace(b),P.maximizeInPlace(b)}static Hermite(b,d,P,G,W){const i=W*W,q=W*i,C=2*q-3*i+1,J=-2*q+3*i,L=q-2*i+W,x=q-i,Y=b._x*C+P._x*J+d._x*L+G._x*x,s=b._y*C+P._y*J+d._y*L+G._y*x,E=b._z*C+P._z*J+d._z*L+G._z*x;return new t(Y,s,E)}static Hermite1stDerivative(b,d,P,G,W){const i=new t;return this.Hermite1stDerivativeToRef(b,d,P,G,W,i),i}static Hermite1stDerivativeToRef(b,d,P,G,W,i){const q=W*W;return i._x=6*(q-W)*b._x+(3*q-4*W+1)*d._x+6*(-q+W)*P._x+(3*q-2*W)*G._x,i._y=6*(q-W)*b._y+(3*q-4*W+1)*d._y+6*(-q+W)*P._y+(3*q-2*W)*G._y,i._z=6*(q-W)*b._z+(3*q-4*W+1)*d._z+6*(-q+W)*P._z+(3*q-2*W)*G._z,i._isDirty=!0,i}static Lerp(b,d,P){const G=new t(0,0,0);return t.LerpToRef(b,d,P,G),G}static LerpToRef(b,d,P,G){return G._x=b._x+(d._x-b._x)*P,G._y=b._y+(d._y-b._y)*P,G._z=b._z+(d._z-b._z)*P,G._isDirty=!0,G}static Dot(b,d){return b._x*d._x+b._y*d._y+b._z*d._z}dot(b){return this._x*b._x+this._y*b._y+this._z*b._z}static Cross(b,d){const P=new t;return t.CrossToRef(b,d,P),P}static CrossToRef(b,d,P){const G=b._y*d._z-b._z*d._y,W=b._z*d._x-b._x*d._z,i=b._x*d._y-b._y*d._x;return P.Fd(G,W,i),P}static Normalize(b){const d=t.Zero();return t.NormalizeToRef(b,d),d}static NormalizeToRef(b,d){return b.normalizeToRef(d),d}static Project(b,d,P,G){const W=new t;return t.ProjectToRef(b,d,P,G,W),W}static ProjectToRef(b,d,P,G,W){var i;const q=G.width,J=G.height,L=G.x,x=G.y,Y=Z.Matrix[1],s=null===(i=C.e.LastCreatedEngine)||void 0===i?void 0:i.isNDCHalfZRange,E=s?1:.5,w=s?0:.5;n.FromValuesToRef(q/2,0,0,0,0,-J/2,0,0,0,0,E,0,L+q/2,J/2+x,w,1,Y);const r=Z.Matrix[0];return d.multiplyToRef(P,r),r.multiplyToRef(Y,r),t.TransformCoordinatesToRef(b,r,W),W}static Reflect(b,d){return this.ReflectToRef(b,d,new t)}static ReflectToRef(b,d,P){const G=o.ed[0];return G.q(d).scaleInPlace(2*t.Dot(b,d)),P.q(b).GY(G)}static _UnprojectFromInvertedMatrixToRef(b,d,P){t.TransformCoordinatesToRef(b,d,P);const G=d.m,W=b._x*G[3]+b._y*G[7]+b._z*G[11]+G[15];return(0,J.WithinEpsilon)(W,1)&&P.scaleInPlace(1/W),P}static UnprojectFromTransform(b,d,P,G,W){return this.Unproject(b,d,P,G,W,n.IdentityReadOnly)}static Unproject(b,d,P,G,W,i){const q=new t;return t.UnprojectToRef(b,d,P,G,W,i,q),q}static UnprojectToRef(b,d,P,G,W,i,q){return t.UnprojectFloatsToRef(b._x,b._y,b._z,d,P,G,W,i,q),q}static UnprojectFloatsToRef(b,d,P,G,W,i,q,J,L){var x;const Y=Z.Matrix[0];i.multiplyToRef(q,Y),Y.multiplyToRef(J,Y),Y.invert();const s=Z.ed[0];return s.x=b/G*2-1,s.y=-(d/W*2-1),null!==(x=C.e.LastCreatedEngine)&&void 0!==x&&x.isNDCHalfZRange?s.z=P:s.z=2*P-1,t._UnprojectFromInvertedMatrixToRef(s,Y,L),L}static Minimize(b,d){const P=new t;return P.q(b),P.minimizeInPlace(d),P}static Maximize(b,d){const P=new t;return P.q(b),P.maximizeInPlace(d),P}static Distance(b,d){return Math.sqrt(t.DistanceSquared(b,d))}static DistanceSquared(b,d){const P=b._x-d._x,G=b._y-d._y,W=b._z-d._z;return P*P+G*G+W*W}static ProjectOnTriangleToRef(b,d,P,W,i){const q=Z.ed[0],C=Z.ed[1],L=Z.ed[2],x=Z.ed[3],Y=Z.ed[4];P.subtractToRef(d,q),W.subtractToRef(d,C),W.subtractToRef(P,L);const s=q.length(),E=C.length(),w=L.length();if(s<G.c||E<G.c||w<G.c)return i.q(d),t.Distance(b,d);b.subtractToRef(d,Y),t.CrossToRef(q,C,x);const r=x.length();if(r<G.c)return i.q(d),t.Distance(b,d);x.normalizeFromLength(r);let B=Y.length();if(B<G.c)return i.q(d),0;Y.normalizeFromLength(B);const n=t.Dot(x,Y),o=Z.ed[5],A=Z.ed[6];o.q(x).scaleInPlace(-B*n),A.q(b).addInPlace(o);const f=Z.ed[4],g=Z.ed[5],X=Z.ed[7],u=Z.ed[8];f.q(q).scaleInPlace(1/s),u.q(C).scaleInPlace(1/E),f.addInPlace(u).scaleInPlace(-1),g.q(q).scaleInPlace(-1/s),u.q(L).scaleInPlace(1/w),g.addInPlace(u).scaleInPlace(-1),X.q(L).scaleInPlace(-1/w),u.q(C).scaleInPlace(-1/E),X.addInPlace(u).scaleInPlace(-1);const M=Z.ed[9];let e;M.q(A).GY(d),t.CrossToRef(f,M,u),e=t.Dot(u,x);const R=e;M.q(A).GY(P),t.CrossToRef(g,M,u),e=t.Dot(u,x);const U=e;M.q(A).GY(W),t.CrossToRef(X,M,u),e=t.Dot(u,x);const H=e,p=Z.ed[10];let S,l;R>0&&U<0?(p.q(q),S=d,l=P):U>0&&H<0?(p.q(L),S=P,l=W):(p.q(C).scaleInPlace(-1),S=W,l=d);const N=Z.ed[9],j=Z.ed[4];S.subtractToRef(A,u),l.subtractToRef(A,N),t.CrossToRef(u,N,j);if(!(t.Dot(j,x)<0))return i.q(A),Math.abs(B*n);const a=Z.ed[5];t.CrossToRef(p,j,a),a.normalize();const O=Z.ed[9];O.q(S).GY(A);const V=O.length();if(V<G.c)return i.q(S),t.Distance(b,S);O.normalizeFromLength(V);const y=t.Dot(a,O),c=Z.ed[7];c.q(A).addInPlace(a.scaleInPlace(V*y)),u.q(c).GY(S),B=p.length(),p.normalizeFromLength(B);let D=t.Dot(u,p)/Math.max(B,G.c);return D=(0,J.Clamp)(D,0,1),c.q(S).addInPlace(p.scaleInPlace(D*B)),i.q(c),t.Distance(b,c)}static Center(b,d){return t.CenterToRef(b,d,t.Zero())}static CenterToRef(b,d,P){return P.Fd((b._x+d._x)/2,(b._y+d._y)/2,(b._z+d._z)/2)}static RotationFromAxis(b,d,P){const G=new t;return t.RotationFromAxisToRef(b,d,P,G),G}static RotationFromAxisToRef(b,d,P,G){const W=Z.Quaternion[0];return B.RotationQuaternionFromAxisToRef(b,d,P,W),W.toEulerAnglesToRef(G),G}}t._V8PerformanceHack=new t(.5,.5,.5),t._UpReadOnly=t.Up(),t._DownReadOnly=t.Down(),t._LeftHandedForwardReadOnly=t.Forward(!1),t._RightHandedForwardReadOnly=t.Forward(!0),t._LeftHandedBackwardReadOnly=t.Backward(!1),t._RightHandedBackwardReadOnly=t.Backward(!0),t._RightReadOnly=t.Right(),t._LeftReadOnly=t.Left(),t._ZeroReadOnly=t.Zero(),t._OneReadOnly=t.One(),Object.defineProperties(t.prototype,{dimension:{value:[3]},rank:{value:1}});class r{get x(){return this._x}set x(b){this._x=b,this._isDirty=!0}get y(){return this._y}set y(b){this._y=b,this._isDirty=!0}get z(){return this._z}set z(b){this._z=b,this._isDirty=!0}get w(){return this._w}set w(b){this._w=b,this._isDirty=!0}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=b,this._y=d,this._z=P,this._w=G}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let b=E(this._x);return b=397*b^E(this._y),b=397*b^E(this._z),b=397*b^E(this._w),b}jd(){return[this._x,this._y,this._z,this._w]}toArray(b,d){return void 0===d&&(d=0),b[d]=this._x,b[d+1]=this._y,b[d+2]=this._z,b[d+3]=this._w,this}DP(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r.FromArrayToRef(b,d,this),this}addInPlace(b){return this.x+=b._x,this.y+=b._y,this.z+=b._z,this.w+=b._w,this}addInPlaceFromFloats(b,d,P,G){return this.x+=b,this.y+=d,this.z+=P,this.w+=G,this}add(b){return new r(this._x+b.x,this._y+b.y,this._z+b.z,this._w+b.w)}addToRef(b,d){return d.x=this._x+b.x,d.y=this._y+b.y,d.z=this._z+b.z,d.w=this._w+b.w,d}GY(b){return this.x-=b.x,this.y-=b.y,this.z-=b.z,this.w-=b.w,this}Rd(b){return new r(this._x-b.x,this._y-b.y,this._z-b.z,this._w-b.w)}subtractToRef(b,d){return d.x=this._x-b.x,d.y=this._y-b.y,d.z=this._z-b.z,d.w=this._w-b.w,d}subtractFromFloats(b,d,P,G){return new r(this._x-b,this._y-d,this._z-P,this._w-G)}subtractFromFloatsToRef(b,d,P,G,W){return W.x=this._x-b,W.y=this._y-d,W.z=this._z-P,W.w=this._w-G,W}negate(){return new r(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(b){return b.x=-this._x,b.y=-this._y,b.z=-this._z,b.w=-this._w,b}scaleInPlace(b){return this.x*=b,this.y*=b,this.z*=b,this.w*=b,this}scale(b){return new r(this._x*b,this._y*b,this._z*b,this._w*b)}scaleToRef(b,d){return d.x=this._x*b,d.y=this._y*b,d.z=this._z*b,d.w=this._w*b,d}scaleAndAddToRef(b,d){return d.x+=this._x*b,d.y+=this._y*b,d.z+=this._z*b,d.w+=this._w*b,d}equals(b){return b&&this._x===b.x&&this._y===b.y&&this._z===b.z&&this._w===b.w}equalsWithEpsilon(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return b&&(0,J.WithinEpsilon)(this._x,b.x,d)&&(0,J.WithinEpsilon)(this._y,b.y,d)&&(0,J.WithinEpsilon)(this._z,b.z,d)&&(0,J.WithinEpsilon)(this._w,b.w,d)}equalsToFloats(b,d,P,G){return this._x===b&&this._y===d&&this._z===P&&this._w===G}multiplyInPlace(b){return this.x*=b.x,this.y*=b.y,this.z*=b.z,this.w*=b.w,this}multiply(b){return new r(this._x*b.x,this._y*b.y,this._z*b.z,this._w*b.w)}multiplyToRef(b,d){return d.x=this._x*b.x,d.y=this._y*b.y,d.z=this._z*b.z,d.w=this._w*b.w,d}multiplyByFloats(b,d,P,G){return new r(this._x*b,this._y*d,this._z*P,this._w*G)}divide(b){return new r(this._x/b.x,this._y/b.y,this._z/b.z,this._w/b.w)}divideToRef(b,d){return d.x=this._x/b.x,d.y=this._y/b.y,d.z=this._z/b.z,d.w=this._w/b.w,d}divideInPlace(b){return this.divideToRef(b,this)}minimizeInPlace(b){return b.x<this._x&&(this.x=b.x),b.y<this._y&&(this.y=b.y),b.z<this._z&&(this.z=b.z),b.w<this._w&&(this.w=b.w),this}maximizeInPlace(b){return b.x>this._x&&(this.x=b.x),b.y>this._y&&(this.y=b.y),b.z>this._z&&(this.z=b.z),b.w>this._w&&(this.w=b.w),this}minimizeInPlaceFromFloats(b,d,P,G){return this.x=Math.min(b,this._x),this.y=Math.min(d,this._y),this.z=Math.min(P,this._z),this.w=Math.min(G,this._w),this}maximizeInPlaceFromFloats(b,d,P,G){return this.x=Math.max(b,this._x),this.y=Math.max(d,this._y),this.z=Math.max(P,this._z),this.w=Math.max(G,this._w),this}floorToRef(b){return b.x=Math.floor(this._x),b.y=Math.floor(this._y),b.z=Math.floor(this._z),b.w=Math.floor(this._w),b}floor(){return new r(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(b){return b.x=this._x-Math.floor(this._x),b.y=this._y-Math.floor(this._y),b.z=this._z-Math.floor(this._z),b.w=this._w-Math.floor(this._w),b}fract(){return new r(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){return this.normalizeToRef(new r)}normalizeToRef(b){const d=this.length();return 0===d||1===d?(b.x=this._x,b.y=this._y,b.z=this._z,b.w=this._w,b):this.scaleToRef(1/d,b)}toVector3(){return new t(this._x,this._y,this._z)}clone(){return new r(this._x,this._y,this._z,this._w)}q(b){return this.x=b.x,this.y=b.y,this.z=b.z,this.w=b.w,this}Fd(b,d,P,G){return this.x=b,this.y=d,this.z=P,this.w=G,this}set(b,d,P,G){return this.Fd(b,d,P,G)}kd(b){return this.x=this.y=this.z=this.w=b,this}dot(b){return this._x*b.x+this._y*b.y+this._z*b.z+this._w*b.w}static Od(b,d){return d||(d=0),new r(b[d],b[d+1],b[d+2],b[d+3])}static FromArrayToRef(b,d,P){return P.x=b[d],P.y=b[d+1],P.z=b[d+2],P.w=b[d+3],P}static FromFloatArrayToRef(b,d,P){return r.FromArrayToRef(b,d,P),P}static FromFloatsToRef(b,d,P,G,W){return W.x=b,W.y=d,W.z=P,W.w=G,W}static Zero(){return new r(0,0,0,0)}static One(){return new r(1,1,1,1)}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new r((0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0;return P.x=(0,J.RandomRange)(b,d),P.y=(0,J.RandomRange)(b,d),P.z=(0,J.RandomRange)(b,d),P.w=(0,J.RandomRange)(b,d),P}static Clamp(b,d,P){return r.ClampToRef(b,d,P,new r)}static ClampToRef(b,d,P,G){return G.x=(0,J.Clamp)(b.x,d.x,P.x),G.y=(0,J.Clamp)(b.y,d.y,P.y),G.z=(0,J.Clamp)(b.z,d.z,P.z),G.w=(0,J.Clamp)(b.w,d.w,P.w),G}static CheckExtends(b,d,P){d.minimizeInPlace(b),P.maximizeInPlace(b)}static get ZeroReadOnly(){return r._ZeroReadOnly}static Normalize(b){return r.NormalizeToRef(b,new r)}static NormalizeToRef(b,d){return b.normalizeToRef(d),d}static Minimize(b,d){const P=new r;return P.q(b),P.minimizeInPlace(d),P}static Maximize(b,d){const P=new r;return P.q(b),P.maximizeInPlace(d),P}static Distance(b,d){return Math.sqrt(r.DistanceSquared(b,d))}static DistanceSquared(b,d){const P=b.x-d.x,G=b.y-d.y,W=b.z-d.z,i=b.w-d.w;return P*P+G*G+W*W+i*i}static Center(b,d){return r.CenterToRef(b,d,new r)}static CenterToRef(b,d,P){return P.x=(b.x+d.x)/2,P.y=(b.y+d.y)/2,P.z=(b.z+d.z)/2,P.w=(b.w+d.w)/2,P}static TransformCoordinates(b,d){return r.TransformCoordinatesToRef(b,d,new r)}static TransformCoordinatesToRef(b,d,P){return r.TransformCoordinatesFromFloatsToRef(b._x,b._y,b._z,d,P),P}static TransformCoordinatesFromFloatsToRef(b,d,P,G,W){const i=G.m,q=b*i[0]+d*i[4]+P*i[8]+i[12],C=b*i[1]+d*i[5]+P*i[9]+i[13],J=b*i[2]+d*i[6]+P*i[10]+i[14],L=b*i[3]+d*i[7]+P*i[11]+i[15];return W.x=q,W.y=C,W.z=J,W.w=L,W}static TransformNormal(b,d){return r.TransformNormalToRef(b,d,new r)}static TransformNormalToRef(b,d,P){const G=d.m,W=b.x*G[0]+b.y*G[4]+b.z*G[8],i=b.x*G[1]+b.y*G[5]+b.z*G[9],q=b.x*G[2]+b.y*G[6]+b.z*G[10];return P.x=W,P.y=i,P.z=q,P.w=b.w,P}static TransformNormalFromFloatsToRef(b,d,P,G,W,i){const q=W.m;return i.x=b*q[0]+d*q[4]+P*q[8],i.y=b*q[1]+d*q[5]+P*q[9],i.z=b*q[2]+d*q[6]+P*q[10],i.w=G,i}static FromVector3(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new r(b._x,b._y,b._z,d)}static Dot(b,d){return b.x*d.x+b.y*d.y+b.z*d.z+b.w*d.w}}r._V8PerformanceHack=new r(.5,.5,.5,.5),r._ZeroReadOnly=r.Zero(),Object.defineProperties(r.prototype,{dimension:{value:[4]},rank:{value:1}});class B{get x(){return this._x}set x(b){this._x=b,this._isDirty=!0}get y(){return this._y}set y(b){this._y=b,this._isDirty=!0}get z(){return this._z}set z(b){this._z=b,this._isDirty=!0}get w(){return this._w}set w(b){this._w=b,this._isDirty=!0}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=b,this._y=d,this._z=P,this._w=G}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let b=E(this._x);return b=397*b^E(this._y),b=397*b^E(this._z),b=397*b^E(this._w),b}jd(){return[this._x,this._y,this._z,this._w]}toArray(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[d]=this._x,b[d+1]=this._y,b[d+2]=this._z,b[d+3]=this._w,this}DP(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B.FromArrayToRef(b,d,this)}equals(b){return b&&this._x===b._x&&this._y===b._y&&this._z===b._z&&this._w===b._w}equalsWithEpsilon(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return b&&(0,J.WithinEpsilon)(this._x,b._x,d)&&(0,J.WithinEpsilon)(this._y,b._y,d)&&(0,J.WithinEpsilon)(this._z,b._z,d)&&(0,J.WithinEpsilon)(this._w,b._w,d)}isApprox(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return b&&((0,J.WithinEpsilon)(this._x,b._x,d)&&(0,J.WithinEpsilon)(this._y,b._y,d)&&(0,J.WithinEpsilon)(this._z,b._z,d)&&(0,J.WithinEpsilon)(this._w,b._w,d)||(0,J.WithinEpsilon)(this._x,-b._x,d)&&(0,J.WithinEpsilon)(this._y,-b._y,d)&&(0,J.WithinEpsilon)(this._z,-b._z,d)&&(0,J.WithinEpsilon)(this._w,-b._w,d))}clone(){return new B(this._x,this._y,this._z,this._w)}q(b){return this._x=b._x,this._y=b._y,this._z=b._z,this._w=b._w,this._isDirty=!0,this}Fd(b,d,P,G){return this._x=b,this._y=d,this._z=P,this._w=G,this._isDirty=!0,this}set(b,d,P,G){return this.Fd(b,d,P,G)}kd(b){return this.Fd(b,b,b,b)}add(b){return new B(this._x+b._x,this._y+b._y,this._z+b._z,this._w+b._w)}addInPlace(b){return this._x+=b._x,this._y+=b._y,this._z+=b._z,this._w+=b._w,this._isDirty=!0,this}addToRef(b,d){return d._x=this._x+b._x,d._y=this._y+b._y,d._z=this._z+b._z,d._w=this._w+b._w,d._isDirty=!0,d}addInPlaceFromFloats(b,d,P,G){return this._x+=b,this._y+=d,this._z+=P,this._w+=G,this._isDirty=!0,this}subtractToRef(b,d){return d._x=this._x-b._x,d._y=this._y-b._y,d._z=this._z-b._z,d._w=this._w-b._w,d._isDirty=!0,d}subtractFromFloats(b,d,P,G){return this.subtractFromFloatsToRef(b,d,P,G,new B)}subtractFromFloatsToRef(b,d,P,G,W){return W._x=this._x-b,W._y=this._y-d,W._z=this._z-P,W._w=this._w-G,W._isDirty=!0,W}Rd(b){return new B(this._x-b._x,this._y-b._y,this._z-b._z,this._w-b._w)}GY(b){return this._x-=b._x,this._y-=b._y,this._z-=b._z,this._w-=b._w,this._isDirty=!0,this}scale(b){return new B(this._x*b,this._y*b,this._z*b,this._w*b)}scaleToRef(b,d){return d._x=this._x*b,d._y=this._y*b,d._z=this._z*b,d._w=this._w*b,d._isDirty=!0,d}scaleInPlace(b){return this._x*=b,this._y*=b,this._z*=b,this._w*=b,this._isDirty=!0,this}scaleAndAddToRef(b,d){return d._x+=this._x*b,d._y+=this._y*b,d._z+=this._z*b,d._w+=this._w*b,d._isDirty=!0,d}multiply(b){const d=new B(0,0,0,1);return this.multiplyToRef(b,d),d}multiplyToRef(b,d){const P=this._x*b._w+this._y*b._z-this._z*b._y+this._w*b._x,G=-this._x*b._z+this._y*b._w+this._z*b._x+this._w*b._y,W=this._x*b._y-this._y*b._x+this._z*b._w+this._w*b._z,i=-this._x*b._x-this._y*b._y-this._z*b._z+this._w*b._w;return d.Fd(P,G,W,i),d}multiplyInPlace(b){return this.multiplyToRef(b,this)}multiplyByFloats(b,d,P,G){return this._x*=b,this._y*=d,this._z*=P,this._w*=G,this._isDirty=!0,this}divide(b){throw new ReferenceError("Can not divide a quaternion")}divideToRef(b,d){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(b){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new B)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(b){return b._x=-this._x,b._y=-this._y,b._z=-this._z,b._w=-this._w,b._isDirty=!0,b}equalsToFloats(b,d,P,G){return this._x===b&&this._y===d&&this._z===P&&this._w===G}floorToRef(b){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(b){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(b){return b.Fd(-this._x,-this._y,-this._z,this._w),b}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new B(-this._x,-this._y,-this._z,this._w)}invert(){const b=this.conjugate(),d=this.lengthSquared();return 0==d||1==d||b.scaleInPlace(1/d),b}invertInPlace(){this.conjugateInPlace();const b=this.lengthSquared();return 0==b||1==b||this.scaleInPlace(1/b),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(b){return 0===b||1===b?this:this.scaleInPlace(1/b)}normalizeToNew(){const b=new B(0,0,0,1);return this.normalizeToRef(b),b}normalizeToRef(b){const d=this.length();return 0===d||1===d?b.Fd(this._x,this._y,this._z,this._w):this.scaleToRef(1/d,b)}toEulerAngles(){const b=t.Zero();return this.toEulerAnglesToRef(b),b}toEulerAnglesToRef(b){const d=this._z,P=this._x,G=this._y,W=this._w,i=G*d-P*W,q=.4999999;if(i<-q)b._y=2*Math.atan2(G,W),b._x=Math.PI/2,b._z=0,b._isDirty=!0;else if(i>q)b._y=2*Math.atan2(G,W),b._x=-Math.PI/2,b._z=0,b._isDirty=!0;else{const q=W*W,C=d*d,J=P*P,L=G*G;b._z=Math.atan2(2*(P*G+d*W),-C-J+L+q),b._x=Math.asin(-2*i),b._y=Math.atan2(2*(d*P+G*W),C-J-L+q),b._isDirty=!0}return b}toAlphaBetaGammaToRef(b){const d=this._z,P=this._x,G=this._y,W=this._w,i=Math.sqrt(P*P+G*G),q=Math.sqrt(d*d+W*W),C=2*Math.atan2(i,q),J=2*Math.atan2(d,W),L=2*Math.atan2(G,P),x=(J+L)/2,Y=(J-L)/2;return b.set(Y,C,x),b}toRotationMatrix(b){return n.FromQuaternionToRef(this,b),b}fromRotationMatrix(b){return B.FromRotationMatrixToRef(b,this),this}dot(b){return this._x*b._x+this._y*b._y+this._z*b._z+this._w*b._w}toAxisAngle(){const b=t.Zero();return{axis:b,angle:this.toAxisAngleToRef(b)}}toAxisAngleToRef(b){let d=0;const P=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),G=this._w;return P>0?(d=2*Math.atan2(P,G),b.set(this._x/P,this._y/P,this._z/P)):(d=0,b.set(1,0,0)),d}static FromRotationMatrix(b){const d=new B;return B.FromRotationMatrixToRef(b,d),d}static FromRotationMatrixToRef(b,d){const P=b.m,G=P[0],W=P[4],i=P[8],q=P[1],C=P[5],J=P[9],L=P[2],x=P[6],Y=P[10],s=G+C+Y;let E;return s>0?(E=.5/Math.sqrt(s+1),d._w=.25/E,d._x=(x-J)*E,d._y=(i-L)*E,d._z=(q-W)*E,d._isDirty=!0):G>C&&G>Y?(E=2*Math.sqrt(1+G-C-Y),d._w=(x-J)/E,d._x=.25*E,d._y=(W+q)/E,d._z=(i+L)/E,d._isDirty=!0):C>Y?(E=2*Math.sqrt(1+C-G-Y),d._w=(i-L)/E,d._x=(W+q)/E,d._y=.25*E,d._z=(J+x)/E,d._isDirty=!0):(E=2*Math.sqrt(1+Y-G-C),d._w=(q-W)/E,d._x=(i+L)/E,d._y=(J+x)/E,d._z=.25*E,d._isDirty=!0),d}static Dot(b,d){return b._x*d._x+b._y*d._y+b._z*d._z+b._w*d._w}static AreClose(b,d){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const G=B.Dot(b,d);return 1-G*G<=P}static SmoothToRef(b,d,P,G,W){let i=0===G?1:P/G;return i=(0,J.Clamp)(i,0,1),B.SlerpToRef(b,d,i,W),W}static Zero(){return new B(0,0,0,0)}static Inverse(b){return new B(-b._x,-b._y,-b._z,b._w)}static InverseToRef(b,d){return d.set(-b._x,-b._y,-b._z,b._w),d}static Identity(){return new B(0,0,0,1)}static IsIdentity(b){return b&&0===b._x&&0===b._y&&0===b._z&&1===b._w}static RotationAxis(b,d){return B.RotationAxisToRef(b,d,new B)}static RotationAxisToRef(b,d,P){P._w=Math.cos(d/2);const G=Math.sin(d/2)/b.length();return P._x=b._x*G,P._y=b._y*G,P._z=b._z*G,P._isDirty=!0,P}static Od(b,d){return d||(d=0),new B(b[d],b[d+1],b[d+2],b[d+3])}static FromArrayToRef(b,d,P){return P._x=b[d],P._y=b[d+1],P._z=b[d+2],P._w=b[d+3],P._isDirty=!0,P}static FromFloatsToRef(b,d,P,G,W){return W.Fd(b,d,P,G),W}static FromEulerAngles(b,d,P){const G=new B;return B.RotationYawPitchRollToRef(d,b,P,G),G}static FromEulerAnglesToRef(b,d,P,G){return B.RotationYawPitchRollToRef(d,b,P,G),G}static FromEulerVector(b){const d=new B;return B.RotationYawPitchRollToRef(b._y,b._x,b._z,d),d}static FromEulerVectorToRef(b,d){return B.RotationYawPitchRollToRef(b._y,b._x,b._z,d),d}static FromUnitVectorsToRef(b,d,P){let W=arguments.length>3&&void 0!==arguments[3]?arguments[3]:G.c;const i=t.Dot(b,d)+1;return i<W?Math.abs(b.x)>Math.abs(b.z)?P.set(-b.y,b.x,0,0):P.set(0,-b.z,b.y,0):(t.CrossToRef(b,d,o.ed[0]),P.set(o.ed[0].x,o.ed[0].y,o.ed[0].z,i)),P.normalize()}static RotationYawPitchRoll(b,d,P){const G=new B;return B.RotationYawPitchRollToRef(b,d,P,G),G}static RotationYawPitchRollToRef(b,d,P,G){const W=.5*P,i=.5*d,q=.5*b,C=Math.sin(W),J=Math.cos(W),L=Math.sin(i),x=Math.cos(i),Y=Math.sin(q),s=Math.cos(q);return G._x=s*L*J+Y*x*C,G._y=Y*x*J-s*L*C,G._z=s*x*C-Y*L*J,G._w=s*x*J+Y*L*C,G._isDirty=!0,G}static RotationAlphaBetaGamma(b,d,P){const G=new B;return B.RotationAlphaBetaGammaToRef(b,d,P,G),G}static RotationAlphaBetaGammaToRef(b,d,P,G){const W=.5*(P+b),i=.5*(P-b),q=.5*d;return G._x=Math.cos(i)*Math.sin(q),G._y=Math.sin(i)*Math.sin(q),G._z=Math.sin(W)*Math.cos(q),G._w=Math.cos(W)*Math.cos(q),G._isDirty=!0,G}static RotationQuaternionFromAxis(b,d,P){const G=new B(0,0,0,0);return B.RotationQuaternionFromAxisToRef(b,d,P,G),G}static RotationQuaternionFromAxisToRef(b,d,P,G){const W=Z.Matrix[0];return b=b.normalizeToRef(Z.ed[0]),d=d.normalizeToRef(Z.ed[1]),P=P.normalizeToRef(Z.ed[2]),n.FromXYZAxesToRef(b,d,P,W),B.FromRotationMatrixToRef(W,G),G}static FromLookDirectionLH(b,d){const P=new B;return B.FromLookDirectionLHToRef(b,d,P),P}static FromLookDirectionLHToRef(b,d,P){const G=Z.Matrix[0];return n.LookDirectionLHToRef(b,d,G),B.FromRotationMatrixToRef(G,P),P}static FromLookDirectionRH(b,d){const P=new B;return B.FromLookDirectionRHToRef(b,d,P),P}static FromLookDirectionRHToRef(b,d,P){const G=Z.Matrix[0];return n.LookDirectionRHToRef(b,d,G),B.FromRotationMatrixToRef(G,P)}static Slerp(b,d,P){const G=B.Identity();return B.SlerpToRef(b,d,P,G),G}static SlerpToRef(b,d,P,G){let W,i,q=b._x*d._x+b._y*d._y+b._z*d._z+b._w*d._w,C=!1;if(q<0&&(C=!0,q=-q),q>.999999)i=1-P,W=C?-P:P;else{const b=Math.acos(q),d=1/Math.sin(b);i=Math.sin((1-P)*b)*d,W=C?-Math.sin(P*b)*d:Math.sin(P*b)*d}return G._x=i*b._x+W*d._x,G._y=i*b._y+W*d._y,G._z=i*b._z+W*d._z,G._w=i*b._w+W*d._w,G._isDirty=!0,G}static Hermite(b,d,P,G,W){const i=W*W,q=W*i,C=2*q-3*i+1,J=-2*q+3*i,L=q-2*i+W,x=q-i,Y=b._x*C+P._x*J+d._x*L+G._x*x,s=b._y*C+P._y*J+d._y*L+G._y*x,E=b._z*C+P._z*J+d._z*L+G._z*x,w=b._w*C+P._w*J+d._w*L+G._w*x;return new B(Y,s,E,w)}static Hermite1stDerivative(b,d,P,G,W){const i=new B;return this.Hermite1stDerivativeToRef(b,d,P,G,W,i),i}static Hermite1stDerivativeToRef(b,d,P,G,W,i){const q=W*W;return i._x=6*(q-W)*b._x+(3*q-4*W+1)*d._x+6*(-q+W)*P._x+(3*q-2*W)*G._x,i._y=6*(q-W)*b._y+(3*q-4*W+1)*d._y+6*(-q+W)*P._y+(3*q-2*W)*G._y,i._z=6*(q-W)*b._z+(3*q-4*W+1)*d._z+6*(-q+W)*P._z+(3*q-2*W)*G._z,i._w=6*(q-W)*b._w+(3*q-4*W+1)*d._w+6*(-q+W)*P._w+(3*q-2*W)*G._w,i._isDirty=!0,i}static Normalize(b){const d=B.Zero();return B.NormalizeToRef(b,d),d}static NormalizeToRef(b,d){return b.normalizeToRef(d),d}static Clamp(b,d,P){const G=new B;return B.ClampToRef(b,d,P,G),G}static ClampToRef(b,d,P,G){return G.Fd((0,J.Clamp)(b.x,d.x,P.x),(0,J.Clamp)(b.y,d.y,P.y),(0,J.Clamp)(b.z,d.z,P.z),(0,J.Clamp)(b.w,d.w,P.w))}static Random(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new B((0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d))}static RandomToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Fd((0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d),(0,J.RandomRange)(b,d))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(b,d){return Math.sqrt(B.DistanceSquared(b,d))}static DistanceSquared(b,d){const P=b.x-d.x,G=b.y-d.y,W=b.z-d.z,i=b.w-d.w;return P*P+G*G+W*W+i*i}static Center(b,d){return B.CenterToRef(b,d,B.Zero())}static CenterToRef(b,d,P){return P.Fd((b.x+d.x)/2,(b.y+d.y)/2,(b.z+d.z)/2,(b.w+d.w)/2)}}B._V8PerformanceHack=new B(.5,.5,.5,.5),Object.defineProperties(B.prototype,{dimension:{value:[4]},rank:{value:1}});class n{static get Use64Bits(){return q.c.MatrixUse64Bits}get m(){return this.od}markAsUpdated(){this.updateFlag=L._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(b){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],G=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=b,this._isIdentity3x2=b||P,this._isIdentityDirty=!this._isIdentity&&d,this._isIdentity3x2Dirty=!this._isIdentity3x2&&G}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,q.c.MatrixTrackPrecisionChange&&q.c.MatrixTrackedMatrices.push(this),this.od=new q.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const b=this.od;this._isIdentity=1===b[0]&&0===b[1]&&0===b[2]&&0===b[3]&&0===b[4]&&1===b[5]&&0===b[6]&&0===b[7]&&0===b[8]&&0===b[9]&&1===b[10]&&0===b[11]&&0===b[12]&&0===b[13]&&0===b[14]&&1===b[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.od[0]||1!==this.od[5]||1!==this.od[15]||0!==this.od[1]||0!==this.od[2]||0!==this.od[3]||0!==this.od[4]||0!==this.od[6]||0!==this.od[7]||0!==this.od[8]||0!==this.od[9]||0!==this.od[10]||0!==this.od[11]||0!==this.od[12]||0!==this.od[13]||0!==this.od[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const b=this.od,d=b[0],P=b[1],G=b[2],W=b[3],i=b[4],q=b[5],C=b[6],J=b[7],L=b[8],x=b[9],Y=b[10],s=b[11],E=b[12],w=b[13],t=b[14],r=b[15],B=Y*r-t*s,n=x*r-w*s,Z=x*t-w*Y,o=L*r-E*s,A=L*t-Y*E,f=L*w-E*x;return d*+(q*B-C*n+J*Z)+P*-(i*B-C*o+J*A)+G*+(i*n-q*o+J*f)+W*-(i*Z-q*A+C*f)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!b)return this.od;const P=this.od;for(let G=0;G<16;G++)b[d+G]=P[G];return this}jd(){return this.od}DP(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n.FromArrayToRef(b,d,this)}Fd(){for(var b=arguments.length,d=new Array(b),P=0;P<b;P++)d[P]=arguments[P];return n.FromArrayToRef(d,0,this)}set(){const b=this.od;for(let d=0;d<16;d++)b[d]=d<0||arguments.length<=d?void 0:arguments[d];return this.markAsUpdated(),this}kd(b){const d=this.od;for(let P=0;P<16;P++)d[P]=b;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return n.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(b){const d=new n;return this.addToRef(b,d),d}addToRef(b,d){const P=this.od,G=d.od,W=b.m;for(let i=0;i<16;i++)G[i]=P[i]+W[i];return d.markAsUpdated(),d}addToSelf(b){const d=this.od,P=b.m;return d[0]+=P[0],d[1]+=P[1],d[2]+=P[2],d[3]+=P[3],d[4]+=P[4],d[5]+=P[5],d[6]+=P[6],d[7]+=P[7],d[8]+=P[8],d[9]+=P[9],d[10]+=P[10],d[11]+=P[11],d[12]+=P[12],d[13]+=P[13],d[14]+=P[14],d[15]+=P[15],this.markAsUpdated(),this}addInPlace(b){const d=this.od,P=b.m;for(let G=0;G<16;G++)d[G]+=P[G];return this.markAsUpdated(),this}addInPlaceFromFloats(){const b=this.od;for(let d=0;d<16;d++)b[d]+=d<0||arguments.length<=d?void 0:arguments[d];return this.markAsUpdated(),this}Rd(b){const d=this.od,P=b.m;for(let G=0;G<16;G++)d[G]-=P[G];return this.markAsUpdated(),this}subtractToRef(b,d){const P=this.od,G=b.m,W=d.od;for(let i=0;i<16;i++)W[i]=P[i]-G[i];return d.markAsUpdated(),d}GY(b){const d=this.od,P=b.m;for(let G=0;G<16;G++)d[G]-=P[G];return this.markAsUpdated(),this}subtractFromFloats(){for(var b=arguments.length,d=new Array(b),P=0;P<b;P++)d[P]=arguments[P];return this.subtractFromFloatsToRef(...d,new n)}subtractFromFloatsToRef(){for(var b=arguments.length,d=new Array(b),P=0;P<b;P++)d[P]=arguments[P];const G=d.pop(),W=this.od,i=G.od,q=d;for(let C=0;C<16;C++)i[C]=W[C]-q[C];return G.markAsUpdated(),G}invertToRef(b){return!0===this._isIdentity?(n.IdentityToRef(b),b):(s(this,b.jd())?b.markAsUpdated():b.q(this),b)}addAtIndex(b,d){return this.od[b]+=d,this.markAsUpdated(),this}multiplyAtIndex(b,d){return this.od[b]*=d,this.markAsUpdated(),this}setTranslationFromFloats(b,d,P){return this.od[12]=b,this.od[13]=d,this.od[14]=P,this.markAsUpdated(),this}addTranslationFromFloats(b,d,P){return this.od[12]+=b,this.od[13]+=d,this.od[14]+=P,this.markAsUpdated(),this}setTranslation(b){return this.setTranslationFromFloats(b._x,b._y,b._z)}getTranslation(){return new t(this.od[12],this.od[13],this.od[14])}getTranslationToRef(b){return b.x=this.od[12],b.y=this.od[13],b.z=this.od[14],b}removeRotationAndScaling(){const b=this.m;return n.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,b[12],b[13],b[14],b[15],this),this._updateIdentityStatus(0===b[12]&&0===b[13]&&0===b[14]&&1===b[15]),this}q(b){b.copyToArray(this.od);const d=b;return this.updateFlag=d.updateFlag,this._updateIdentityStatus(d._isIdentity,d._isIdentityDirty,d._isIdentity3x2,d._isIdentity3x2Dirty),this}copyToArray(b){return Y(this,b,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(b){const d=new n;return this.multiplyToRef(b,d),d}multiplyInPlace(b){const d=this.od,P=b.m;for(let G=0;G<16;G++)d[G]*=P[G];return this.markAsUpdated(),this}multiplyByFloats(){const b=this.od;for(let d=0;d<16;d++)b[d]*=d<0||arguments.length<=d?void 0:arguments[d];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var b=arguments.length,d=new Array(b),P=0;P<b;P++)d[P]=arguments[P];const G=d.pop(),W=this.od,i=G.od,q=d;for(let C=0;C<16;C++)i[C]=W[C]*q[C];return G.markAsUpdated(),G}multiplyToRef(b,d){return this._isIdentity?(d.q(b),d):b._isIdentity?(d.q(this),d):(this.multiplyToArray(b,d.od,0),d.markAsUpdated(),d)}multiplyToArray(b,d,P){return x(this,b,d,P),this}divide(b){return this.divideToRef(b,new n)}divideToRef(b,d){const P=this.od,G=b.m,W=d.od;for(let i=0;i<16;i++)W[i]=P[i]/G[i];return d.markAsUpdated(),d}divideInPlace(b){const d=this.od,P=b.m;for(let G=0;G<16;G++)d[G]/=P[G];return this.markAsUpdated(),this}minimizeInPlace(b){const d=this.od,P=b.m;for(let G=0;G<16;G++)d[G]=Math.min(d[G],P[G]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const b=this.od;for(let d=0;d<16;d++)b[d]=Math.min(b[d],d<0||arguments.length<=d?void 0:arguments[d]);return this.markAsUpdated(),this}maximizeInPlace(b){const d=this.od,P=b.m;for(let G=0;G<16;G++)d[G]=Math.min(d[G],P[G]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const b=this.od;for(let d=0;d<16;d++)b[d]=Math.min(b[d],d<0||arguments.length<=d?void 0:arguments[d]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new n)}negateInPlace(){const b=this.od;for(let d=0;d<16;d++)b[d]=-b[d];return this.markAsUpdated(),this}negateToRef(b){const d=this.od,P=b.od;for(let G=0;G<16;G++)P[G]=-d[G];return b.markAsUpdated(),b}equals(b){const d=b;if(!d)return!1;if((this._isIdentity||d._isIdentity)&&!this._isIdentityDirty&&!d._isIdentityDirty)return this._isIdentity&&d._isIdentity;const P=this.m,G=d.m;return P[0]===G[0]&&P[1]===G[1]&&P[2]===G[2]&&P[3]===G[3]&&P[4]===G[4]&&P[5]===G[5]&&P[6]===G[6]&&P[7]===G[7]&&P[8]===G[8]&&P[9]===G[9]&&P[10]===G[10]&&P[11]===G[11]&&P[12]===G[12]&&P[13]===G[13]&&P[14]===G[14]&&P[15]===G[15]}equalsWithEpsilon(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=this.od,G=b.m;for(let W=0;W<16;W++)if(!(0,J.WithinEpsilon)(P[W],G[W],d))return!1;return!0}equalsToFloats(){const b=this.od;for(let d=0;d<16;d++)if(b[d]!=(d<0||arguments.length<=d?void 0:arguments[d]))return!1;return!0}floor(){return this.floorToRef(new n)}floorToRef(b){const d=this.od,P=b.od;for(let G=0;G<16;G++)P[G]=Math.floor(d[G]);return b.markAsUpdated(),b}fract(){return this.fractToRef(new n)}fractToRef(b){const d=this.od,P=b.od;for(let G=0;G<16;G++)P[G]=d[G]-Math.floor(d[G]);return b.markAsUpdated(),b}clone(){const b=new n;return b.q(this),b}getClassName(){return"Matrix"}getHashCode(){let b=E(this.od[0]);for(let d=1;d<16;d++)b=397*b^E(this.od[d]);return b}decomposeToTransformNode(b){return b.rotationQuaternion=b.rotationQuaternion||new B,this.decompose(b.hd,b.rotationQuaternion,b.position)}decompose(b,d,P,G){let W=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return P&&P.kd(0),b&&b.kd(1),d&&d.Fd(0,0,0,1),!0;const i=this.od;if(P&&P.Fd(i[12],i[13],i[14]),(b=b||Z.ed[0]).x=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]),b.y=Math.sqrt(i[4]*i[4]+i[5]*i[5]+i[6]*i[6]),b.z=Math.sqrt(i[8]*i[8]+i[9]*i[9]+i[10]*i[10]),G){const d=(W?G.absoluteScaling.x:G.hd.x)<0?-1:1,P=(W?G.absoluteScaling.y:G.hd.y)<0?-1:1,i=(W?G.absoluteScaling.z:G.hd.z)<0?-1:1;b.x*=d,b.y*=P,b.z*=i}else this.determinant()<=0&&(b.y*=-1);if(0===b._x||0===b._y||0===b._z)return d&&d.Fd(0,0,0,1),!1;if(d){const P=1/b._x,G=1/b._y,W=1/b._z;n.FromValuesToRef(i[0]*P,i[1]*P,i[2]*P,0,i[4]*G,i[5]*G,i[6]*G,0,i[8]*W,i[9]*W,i[10]*W,0,0,0,0,1,Z.Matrix[0]),B.FromRotationMatrixToRef(Z.Matrix[0],d)}return!0}getRow(b){if(b<0||b>3)return null;const d=4*b;return new r(this.od[d+0],this.od[d+1],this.od[d+2],this.od[d+3])}getRowToRef(b,d){if(b>=0&&b<=3){const P=4*b;d.x=this.od[P+0],d.y=this.od[P+1],d.z=this.od[P+2],d.w=this.od[P+3]}return d}setRow(b,d){return this.setRowFromFloats(b,d.x,d.y,d.z,d.w)}transpose(){const b=new n;return n.TransposeToRef(this,b),b}transposeToRef(b){return n.TransposeToRef(this,b),b}setRowFromFloats(b,d,P,G,W){if(b<0||b>3)return this;const i=4*b;return this.od[i+0]=d,this.od[i+1]=P,this.od[i+2]=G,this.od[i+3]=W,this.markAsUpdated(),this}scale(b){const d=new n;return this.scaleToRef(b,d),d}scaleToRef(b,d){for(let P=0;P<16;P++)d.od[P]=this.od[P]*b;return d.markAsUpdated(),d}scaleAndAddToRef(b,d){for(let P=0;P<16;P++)d.od[P]+=this.od[P]*b;return d.markAsUpdated(),d}scaleInPlace(b){const d=this.od;for(let P=0;P<16;P++)d[P]*=b;return this.markAsUpdated(),this}toNormalMatrix(b){const d=Z.Matrix[0];this.invertToRef(d),d.transposeToRef(b);const P=b.od;return n.FromValuesToRef(P[0],P[1],P[2],0,P[4],P[5],P[6],0,P[8],P[9],P[10],0,0,0,0,1,b),b}getRotationMatrix(){const b=new n;return this.getRotationMatrixToRef(b),b}getRotationMatrixToRef(b){const d=Z.ed[0];if(!this.decompose(d))return n.IdentityToRef(b),b;const P=this.od,G=1/d._x,W=1/d._y,i=1/d._z;return n.FromValuesToRef(P[0]*G,P[1]*G,P[2]*G,0,P[4]*W,P[5]*W,P[6]*W,0,P[8]*i,P[9]*i,P[10]*i,0,0,0,0,1,b),b}toggleModelMatrixHandInPlace(){const b=this.od;return b[2]*=-1,b[6]*=-1,b[8]*=-1,b[9]*=-1,b[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const b=this.od;return b[8]*=-1,b[9]*=-1,b[10]*=-1,b[11]*=-1,this.markAsUpdated(),this}static Od(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=new n;return n.FromArrayToRef(b,d,P),P}static FromArrayToRef(b,d,P){for(let G=0;G<16;G++)P.od[G]=b[G+d];return P.markAsUpdated(),P}static FromFloat32ArrayToRefScaled(b,d,P,G){return G.od[0]=b[0+d]*P,G.od[1]=b[1+d]*P,G.od[2]=b[2+d]*P,G.od[3]=b[3+d]*P,G.od[4]=b[4+d]*P,G.od[5]=b[5+d]*P,G.od[6]=b[6+d]*P,G.od[7]=b[7+d]*P,G.od[8]=b[8+d]*P,G.od[9]=b[9+d]*P,G.od[10]=b[10+d]*P,G.od[11]=b[11+d]*P,G.od[12]=b[12+d]*P,G.od[13]=b[13+d]*P,G.od[14]=b[14+d]*P,G.od[15]=b[15+d]*P,G.markAsUpdated(),G}static get IdentityReadOnly(){return n._IdentityReadOnly}static FromValuesToRef(b,d,P,G,W,i,q,C,J,L,x,Y,s,E,w,t,r){const B=r.od;B[0]=b,B[1]=d,B[2]=P,B[3]=G,B[4]=W,B[5]=i,B[6]=q,B[7]=C,B[8]=J,B[9]=L,B[10]=x,B[11]=Y,B[12]=s,B[13]=E,B[14]=w,B[15]=t,r.markAsUpdated()}static FromValues(b,d,P,G,W,i,q,C,J,L,x,Y,s,E,w,t){const r=new n,B=r.od;return B[0]=b,B[1]=d,B[2]=P,B[3]=G,B[4]=W,B[5]=i,B[6]=q,B[7]=C,B[8]=J,B[9]=L,B[10]=x,B[11]=Y,B[12]=s,B[13]=E,B[14]=w,B[15]=t,r.markAsUpdated(),r}static Compose(b,d,P){const G=new n;return n.ComposeToRef(b,d,P,G),G}static ComposeToRef(b,d,P,G){const W=G.od,i=d._x,q=d._y,C=d._z,J=d._w,L=i+i,x=q+q,Y=C+C,s=i*L,E=i*x,w=i*Y,t=q*x,r=q*Y,B=C*Y,n=J*L,Z=J*x,o=J*Y,A=b._x,f=b._y,g=b._z;return W[0]=(1-(t+B))*A,W[1]=(E+o)*A,W[2]=(w-Z)*A,W[3]=0,W[4]=(E-o)*f,W[5]=(1-(s+B))*f,W[6]=(r+n)*f,W[7]=0,W[8]=(w+Z)*g,W[9]=(r-n)*g,W[10]=(1-(s+t))*g,W[11]=0,W[12]=P._x,W[13]=P._y,W[14]=P._z,W[15]=1,G.markAsUpdated(),G}static Identity(){const b=n.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return b._updateIdentityStatus(!0),b}static IdentityToRef(b){return n.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,b),b._updateIdentityStatus(!0),b}static Zero(){const b=n.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return b._updateIdentityStatus(!1),b}static RotationX(b){const d=new n;return n.RotationXToRef(b,d),d}static Invert(b){const d=new n;return b.invertToRef(d),d}static RotationXToRef(b,d){const P=Math.sin(b),G=Math.cos(b);return n.FromValuesToRef(1,0,0,0,0,G,P,0,0,-P,G,0,0,0,0,1,d),d._updateIdentityStatus(1===G&&0===P),d}static RotationY(b){const d=new n;return n.RotationYToRef(b,d),d}static RotationYToRef(b,d){const P=Math.sin(b),G=Math.cos(b);return n.FromValuesToRef(G,0,-P,0,0,1,0,0,P,0,G,0,0,0,0,1,d),d._updateIdentityStatus(1===G&&0===P),d}static RotationZ(b){const d=new n;return n.RotationZToRef(b,d),d}static RotationZToRef(b,d){const P=Math.sin(b),G=Math.cos(b);return n.FromValuesToRef(G,P,0,0,-P,G,0,0,0,0,1,0,0,0,0,1,d),d._updateIdentityStatus(1===G&&0===P),d}static RotationAxis(b,d){const P=new n;return n.RotationAxisToRef(b,d,P),P}static RotationAxisToRef(b,d,P){const G=Math.sin(-d),W=Math.cos(-d),i=1-W;b=b.normalizeToRef(Z.ed[0]);const q=P.od;return q[0]=b._x*b._x*i+W,q[1]=b._x*b._y*i-b._z*G,q[2]=b._x*b._z*i+b._y*G,q[3]=0,q[4]=b._y*b._x*i+b._z*G,q[5]=b._y*b._y*i+W,q[6]=b._y*b._z*i-b._x*G,q[7]=0,q[8]=b._z*b._x*i-b._y*G,q[9]=b._z*b._y*i+b._x*G,q[10]=b._z*b._z*i+W,q[11]=0,q[12]=0,q[13]=0,q[14]=0,q[15]=1,P.markAsUpdated(),P}static RotationAlignToRef(b,d,P){let W=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const i=t.Dot(d,b),q=P.od;if(i<-1+G.c)q[0]=-1,q[1]=0,q[2]=0,q[3]=0,q[4]=0,q[5]=W?1:-1,q[6]=0,q[7]=0,q[8]=0,q[9]=0,q[10]=W?-1:1,q[11]=0;else{const P=t.Cross(d,b),G=1/(1+i);q[0]=P._x*P._x*G+i,q[1]=P._y*P._x*G-P._z,q[2]=P._z*P._x*G+P._y,q[3]=0,q[4]=P._x*P._y*G+P._z,q[5]=P._y*P._y*G+i,q[6]=P._z*P._y*G-P._x,q[7]=0,q[8]=P._x*P._z*G-P._y,q[9]=P._y*P._z*G+P._x,q[10]=P._z*P._z*G+i,q[11]=0}return q[12]=0,q[13]=0,q[14]=0,q[15]=1,P.markAsUpdated(),P}static RotationYawPitchRoll(b,d,P){const G=new n;return n.RotationYawPitchRollToRef(b,d,P,G),G}static RotationYawPitchRollToRef(b,d,P,G){return B.RotationYawPitchRollToRef(b,d,P,Z.Quaternion[0]),Z.Quaternion[0].toRotationMatrix(G),G}static Scaling(b,d,P){const G=new n;return n.ScalingToRef(b,d,P,G),G}static ScalingToRef(b,d,P,G){return n.FromValuesToRef(b,0,0,0,0,d,0,0,0,0,P,0,0,0,0,1,G),G._updateIdentityStatus(1===b&&1===d&&1===P),G}static Translation(b,d,P){const G=new n;return n.TranslationToRef(b,d,P,G),G}static TranslationToRef(b,d,P,G){return n.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,b,d,P,1,G),G._updateIdentityStatus(0===b&&0===d&&0===P),G}static Lerp(b,d,P){const G=new n;return n.LerpToRef(b,d,P,G),G}static LerpToRef(b,d,P,G){const W=G.od,i=b.m,q=d.m;for(let C=0;C<16;C++)W[C]=i[C]*(1-P)+q[C]*P;return G.markAsUpdated(),G}static DecomposeLerp(b,d,P){const G=new n;return n.DecomposeLerpToRef(b,d,P,G),G}static DecomposeLerpToRef(b,d,P,G){const W=Z.ed[0],i=Z.Quaternion[0],q=Z.ed[1];b.decompose(W,i,q);const C=Z.ed[2],J=Z.Quaternion[1],L=Z.ed[3];d.decompose(C,J,L);const x=Z.ed[4];t.LerpToRef(W,C,P,x);const Y=Z.Quaternion[2];B.SlerpToRef(i,J,P,Y);const s=Z.ed[5];return t.LerpToRef(q,L,P,s),n.ComposeToRef(x,Y,s,G),G}static LookAtLH(b,d,P){const G=new n;return n.LookAtLHToRef(b,d,P,G),G}static LookAtLHToRef(b,d,P,G){const W=Z.ed[0],i=Z.ed[1],q=Z.ed[2];d.subtractToRef(b,q),q.normalize(),t.CrossToRef(P,q,W);const C=W.lengthSquared();0===C?W.x=1:W.normalizeFromLength(Math.sqrt(C)),t.CrossToRef(q,W,i),i.normalize();const J=-t.Dot(W,b),L=-t.Dot(i,b),x=-t.Dot(q,b);return n.FromValuesToRef(W._x,i._x,q._x,0,W._y,i._y,q._y,0,W._z,i._z,q._z,0,J,L,x,1,G),G}static LookAtRH(b,d,P){const G=new n;return n.LookAtRHToRef(b,d,P,G),G}static LookAtRHToRef(b,d,P,G){const W=Z.ed[0],i=Z.ed[1],q=Z.ed[2];b.subtractToRef(d,q),q.normalize(),t.CrossToRef(P,q,W);const C=W.lengthSquared();0===C?W.x=1:W.normalizeFromLength(Math.sqrt(C)),t.CrossToRef(q,W,i),i.normalize();const J=-t.Dot(W,b),L=-t.Dot(i,b),x=-t.Dot(q,b);return n.FromValuesToRef(W._x,i._x,q._x,0,W._y,i._y,q._y,0,W._z,i._z,q._z,0,J,L,x,1,G),G}static LookDirectionLH(b,d){const P=new n;return n.LookDirectionLHToRef(b,d,P),P}static LookDirectionLHToRef(b,d,P){const G=Z.ed[0];G.q(b),G.scaleInPlace(-1);const W=Z.ed[1];return t.CrossToRef(d,G,W),n.FromValuesToRef(W._x,W._y,W._z,0,d._x,d._y,d._z,0,G._x,G._y,G._z,0,0,0,0,1,P),P}static LookDirectionRH(b,d){const P=new n;return n.LookDirectionRHToRef(b,d,P),P}static LookDirectionRHToRef(b,d,P){const G=Z.ed[2];return t.CrossToRef(d,b,G),n.FromValuesToRef(G._x,G._y,G._z,0,d._x,d._y,d._z,0,b._x,b._y,b._z,0,0,0,0,1,P),P}static OrthoLH(b,d,P,G,W){const i=new n;return n.OrthoLHToRef(b,d,P,G,i,W),i}static OrthoLHToRef(b,d,P,G,W,i){const q=2/b,C=2/d,J=2/(G-P),L=-(G+P)/(G-P);return n.FromValuesToRef(q,0,0,0,0,C,0,0,0,0,J,0,0,0,L,1,W),i&&W.multiplyToRef(A,W),W._updateIdentityStatus(1===q&&1===C&&1===J&&0===L),W}static OrthoOffCenterLH(b,d,P,G,W,i,q){const C=new n;return n.OrthoOffCenterLHToRef(b,d,P,G,W,i,C,q),C}static OrthoOffCenterLHToRef(b,d,P,G,W,i,q,C){const J=2/(d-b),L=2/(G-P),x=2/(i-W),Y=-(i+W)/(i-W),s=(b+d)/(b-d),E=(G+P)/(P-G);return n.FromValuesToRef(J,0,0,0,0,L,0,0,0,0,x,0,s,E,Y,1,q),C&&q.multiplyToRef(A,q),q.markAsUpdated(),q}static ObliqueOffCenterLHToRef(b,d,P,G,W,i,q,C,J,L,x){const Y=-q*Math.cos(C),s=-q*Math.sin(C);return n.TranslationToRef(0,0,-J,Z.Matrix[1]),n.FromValuesToRef(1,0,0,0,0,1,0,0,Y,s,1,0,0,0,0,1,Z.Matrix[0]),Z.Matrix[1].multiplyToRef(Z.Matrix[0],Z.Matrix[0]),n.TranslationToRef(0,0,J,Z.Matrix[1]),Z.Matrix[0].multiplyToRef(Z.Matrix[1],Z.Matrix[0]),n.OrthoOffCenterLHToRef(b,d,P,G,W,i,L,x),Z.Matrix[0].multiplyToRef(L,L),L}static OrthoOffCenterRH(b,d,P,G,W,i,q){const C=new n;return n.OrthoOffCenterRHToRef(b,d,P,G,W,i,C,q),C}static OrthoOffCenterRHToRef(b,d,P,G,W,i,q,C){return n.OrthoOffCenterLHToRef(b,d,P,G,W,i,q,C),q.od[10]*=-1,q}static ObliqueOffCenterRHToRef(b,d,P,G,W,i,q,C,J,L,x){const Y=q*Math.cos(C),s=q*Math.sin(C);return n.TranslationToRef(0,0,J,Z.Matrix[1]),n.FromValuesToRef(1,0,0,0,0,1,0,0,Y,s,1,0,0,0,0,1,Z.Matrix[0]),Z.Matrix[1].multiplyToRef(Z.Matrix[0],Z.Matrix[0]),n.TranslationToRef(0,0,-J,Z.Matrix[1]),Z.Matrix[0].multiplyToRef(Z.Matrix[1],Z.Matrix[0]),n.OrthoOffCenterRHToRef(b,d,P,G,W,i,L,x),Z.Matrix[0].multiplyToRef(L,L),L}static PerspectiveLH(b,d,P,G,W){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const q=new n,C=2*P/b,J=2*P/d,L=(G+P)/(G-P),x=-2*G*P/(G-P),Y=Math.tan(i);return n.FromValuesToRef(C,0,0,0,0,J,0,Y,0,0,L,1,0,0,x,0,q),W&&q.multiplyToRef(A,q),q._updateIdentityStatus(!1),q}static PerspectiveFovLH(b,d,P,G,W){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const C=new n;return n.PerspectiveFovLHToRef(b,d,P,G,C,!0,W,i,q),C}static PerspectiveFovLHToRef(b,d,P,G,W){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,C=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,J=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const L=P,x=G,Y=1/Math.tan(.5*b),s=i?Y/d:Y,E=i?Y:Y*d,w=J&&0===L?-1:0!==x?(x+L)/(x-L):1,t=J&&0===L?2*x:0!==x?-2*x*L/(x-L):-2*L,r=Math.tan(C);return n.FromValuesToRef(s,0,0,0,0,E,0,r,0,0,w,1,0,0,t,0,W),q&&W.multiplyToRef(A,W),W._updateIdentityStatus(!1),W}static PerspectiveFovReverseLHToRef(b,d,P,G,W){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,C=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const J=1/Math.tan(.5*b),L=i?J/d:J,x=i?J:J*d,Y=Math.tan(C);return n.FromValuesToRef(L,0,0,0,0,x,0,Y,0,0,-P,1,0,0,1,0,W),q&&W.multiplyToRef(A,W),W._updateIdentityStatus(!1),W}static PerspectiveFovRH(b,d,P,G,W){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const C=new n;return n.PerspectiveFovRHToRef(b,d,P,G,C,!0,W,i,q),C}static PerspectiveFovRHToRef(b,d,P,G,W){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,C=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,J=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const L=P,x=G,Y=1/Math.tan(.5*b),s=i?Y/d:Y,E=i?Y:Y*d,w=J&&0===L?1:0!==x?-(x+L)/(x-L):-1,t=J&&0===L?2*x:0!==x?-2*x*L/(x-L):-2*L,r=Math.tan(C);return n.FromValuesToRef(s,0,0,0,0,E,0,r,0,0,w,-1,0,0,t,0,W),q&&W.multiplyToRef(A,W),W._updateIdentityStatus(!1),W}static PerspectiveFovReverseRHToRef(b,d,P,G,W){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,C=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const J=1/Math.tan(.5*b),L=i?J/d:J,x=i?J:J*d,Y=Math.tan(C);return n.FromValuesToRef(L,0,0,0,0,x,0,Y,0,0,-P,-1,0,0,-1,0,W),q&&W.multiplyToRef(A,W),W._updateIdentityStatus(!1),W}static GetFinalMatrix(b,d,P,G,W,i){const q=b.width,C=b.height,J=b.x,L=b.y,x=n.FromValues(q/2,0,0,0,0,-C/2,0,0,0,0,i-W,0,J+q/2,C/2+L,W,1),Y=new n;return d.multiplyToRef(P,Y),Y.multiplyToRef(G,Y),Y.multiplyToRef(x,Y)}static GetAsMatrix2x2(b){const d=b.m,P=[d[0],d[1],d[4],d[5]];return q.c.MatrixUse64Bits?P:new Float32Array(P)}static GetAsMatrix3x3(b){const d=b.m,P=[d[0],d[1],d[2],d[4],d[5],d[6],d[8],d[9],d[10]];return q.c.MatrixUse64Bits?P:new Float32Array(P)}static Transpose(b){const d=new n;return n.TransposeToRef(b,d),d}static TransposeToRef(b,d){const P=b.m,G=P[0],W=P[4],i=P[8],q=P[12],C=P[1],J=P[5],L=P[9],x=P[13],Y=P[2],s=P[6],E=P[10],w=P[14],t=P[3],r=P[7],B=P[11],n=P[15],Z=d.od;return Z[0]=G,Z[1]=W,Z[2]=i,Z[3]=q,Z[4]=C,Z[5]=J,Z[6]=L,Z[7]=x,Z[8]=Y,Z[9]=s,Z[10]=E,Z[11]=w,Z[12]=t,Z[13]=r,Z[14]=B,Z[15]=n,d.markAsUpdated(),d._updateIdentityStatus(b._isIdentity,b._isIdentityDirty),d}static Reflection(b){const d=new n;return n.ReflectionToRef(b,d),d}static ReflectionToRef(b,d){b.normalize();const P=b.normal.x,G=b.normal.y,W=b.normal.z,i=-2*P,q=-2*G,C=-2*W;return n.FromValuesToRef(i*P+1,q*P,C*P,0,i*G,q*G+1,C*G,0,i*W,q*W,C*W+1,0,i*b.d,q*b.d,C*b.d,1,d),d}static FromXYZAxesToRef(b,d,P,G){return n.FromValuesToRef(b._x,b._y,b._z,0,d._x,d._y,d._z,0,P._x,P._y,P._z,0,0,0,0,1,G),G}static FromQuaternionToRef(b,d){const P=b._x*b._x,G=b._y*b._y,W=b._z*b._z,i=b._x*b._y,q=b._z*b._w,C=b._z*b._x,J=b._y*b._w,L=b._y*b._z,x=b._x*b._w;return d.od[0]=1-2*(G+W),d.od[1]=2*(i+q),d.od[2]=2*(C-J),d.od[3]=0,d.od[4]=2*(i-q),d.od[5]=1-2*(W+P),d.od[6]=2*(L+x),d.od[7]=0,d.od[8]=2*(C+J),d.od[9]=2*(L-x),d.od[10]=1-2*(G+P),d.od[11]=0,d.od[12]=0,d.od[13]=0,d.od[14]=0,d.od[15]=1,d.markAsUpdated(),d}}n._IdentityReadOnly=n.Identity(),Object.defineProperties(n.prototype,{dimension:{value:[4,4]},rank:{value:2}});class Z{}Z.ed=(0,W.d)(11,t.Zero),Z.Matrix=(0,W.d)(2,n.Identity),Z.Quaternion=(0,W.d)(3,B.Zero);class o{}o.Vector2=(0,W.d)(3,w.Zero),o.ed=(0,W.d)(13,t.Zero),o.Vector4=(0,W.d)(3,r.Zero),o.Quaternion=(0,W.d)(3,B.Zero),o.Matrix=(0,W.d)(8,n.Identity),(0,i.f)("BABYLON.Vector2",w),(0,i.f)("BABYLON.Vector3",t),(0,i.f)("BABYLON.Vector4",r),(0,i.f)("BABYLON.Matrix",n);const A=n.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11691:(b,d,P)=>{function G(b,d){const P=[];for(let G=0;G<b;++G)P.push(d());return P}function W(b,d){return G(b,d)}P.d(d,{b:()=>G,d:()=>W,f:()=>q});const i=["push","splice","pop","shift","unshift"];function q(b,d){const P=i.map((P=>function(b,d,P){const G=b[d];if("function"!==typeof G)return null;const W=function(){const G=b.length,i=W.previous.apply(b,arguments);return P(d,G),i};return G.next=W,W.previous=G,b[d]=W,()=>{const P=W.previous;if(!P)return;const G=W.next;G?(P.next=G,G.previous=P):(P.next=void 0,b[d]=P),W.next=void 0,W.previous=void 0}}(b,P,d)));return()=>{for(const b of P)null===b||void 0===b||b()}}}}]);