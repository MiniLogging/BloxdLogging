"use strict";(self["269hv5nclphh"]=self["269hv5nclphh"]||[]).push([[14],{12391:(E,H,d)=>{d.d(H,{c:()=>g,f:()=>I,j:()=>n,n:()=>Z});const n=1/2.2,Z=2.2,I=(1+Math.sqrt(5))/2,g=.001},12406:(E,H,d)=>{function n(E){return parseInt(E.toString().replace(/\W/g,""))}function Z(E,H){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(E-H)<=d}function I(E,H,d){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return E<H-n||E>d+n}function g(E,H){return E===H?E:Math.random()*(H-E)+E}function l(E,H,d){return E+(H-E)*d}function r(E,H,d){let n=Q(H-E,360);return n>180&&(n-=360),E+n*V(d)}function t(E,H,d){let n=0;return n=E!=H?V((d-E)/(H-E)):0,n}function S(E,H,d,n,Z){const I=Z*Z,g=Z*I;return E*(2*g-3*I+1)+d*(-2*g+3*I)+H*(g-2*I+Z)+n*(g-I)}function M(E,H,d,n,Z){const I=Z*Z;return 6*(I-Z)*E+(3*I-4*Z+1)*H+6*(-I+Z)*d+(3*I-2*Z)*n}function V(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(d,Math.max(H,E))}function C(E){return E-=2*Math.PI*Math.floor((E+Math.PI)/(2*Math.PI))}function w(E){const H=E.toString(16);return E<=15?("0"+H).toUpperCase():H.toUpperCase()}function R(E){if(Math.log2)return Math.floor(Math.log2(E));if(E<0)return NaN;if(0===E)return-1/0;let H=0;if(E<1){for(;E<1;)H++,E*=2;H=-H}else if(E>1)for(;E>1;)H++,E=Math.floor(E/2);return H}function Q(E,H){return E-Math.floor(E/H)*H}function L(E,H,d){return(E-H)/(d-H)}function D(E,H,d){return E*(d-H)+H}function e(E,H){let d=Q(H-E,360);return d>180&&(d-=360),d}function s(E,H){const d=Q(E,2*H);return H-Math.abs(d-H)}function i(E,H,d){let n=V(d);return n=-2*n*n*n+3*n*n,H*n+E*(1-n)}function p(E,H,d){let n=0;return n=Math.abs(H-E)<=d?H:E+Math.sign(H-E)*d,n}function f(E,H,d){const n=e(E,H);let Z=0;return Z=-d<n&&n<d?H:p(E,H=E+n,d),Z}function P(E,H,d){return(E-H)/(d-H)}function j(E,H,d){return(d-H)*E+H}function X(E,H){const d=E%H;return 0===d?H:X(H,d)}d.r(H),d.d(H,{Clamp:()=>V,DeltaAngle:()=>e,Denormalize:()=>D,ExtractAsInt:()=>n,Hermite:()=>S,Hermite1stDerivative:()=>M,HighestCommonFactor:()=>X,ILog2:()=>R,InverseLerp:()=>t,Lerp:()=>l,LerpAngle:()=>r,MoveTowards:()=>p,MoveTowardsAngle:()=>f,Normalize:()=>L,NormalizeRadians:()=>C,OutsideRange:()=>I,PercentToRange:()=>j,PingPong:()=>s,RandomRange:()=>g,RangeToPercent:()=>P,Repeat:()=>Q,SmoothStep:()=>i,ToHex:()=>w,WithinEpsilon:()=>Z})},12384:(E,H,d)=>{d.r(H),d.d(H,{Matrix:()=>D,Quaternion:()=>L,TmpVectors:()=>s,Vector2:()=>w,wH:()=>R,Vector4:()=>Q});var n=d(12391),Z=d(12399),I=d(12344),g=d(12321),l=d(12268),r=d(12406);class t{}function S(E,H,d){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const Z=E.kd(),I=H.kd(),g=Z[0],l=Z[1],r=Z[2],t=Z[3],S=Z[4],M=Z[5],V=Z[6],C=Z[7],w=Z[8],R=Z[9],Q=Z[10],L=Z[11],D=Z[12],e=Z[13],s=Z[14],i=Z[15],p=I[0],f=I[1],P=I[2],j=I[3],X=I[4],W=I[5],U=I[6],Y=I[7],c=I[8],u=I[9],o=I[10],F=I[11],a=I[12],k=I[13],O=I[14],G=I[15];d[n]=g*p+l*X+r*c+t*a,d[n+1]=g*f+l*W+r*u+t*k,d[n+2]=g*P+l*U+r*o+t*O,d[n+3]=g*j+l*Y+r*F+t*G,d[n+4]=S*p+M*X+V*c+C*a,d[n+5]=S*f+M*W+V*u+C*k,d[n+6]=S*P+M*U+V*o+C*O,d[n+7]=S*j+M*Y+V*F+C*G,d[n+8]=w*p+R*X+Q*c+L*a,d[n+9]=w*f+R*W+Q*u+L*k,d[n+10]=w*P+R*U+Q*o+L*O,d[n+11]=w*j+R*Y+Q*F+L*G,d[n+12]=D*p+e*X+s*c+i*a,d[n+13]=D*f+e*W+s*u+i*k,d[n+14]=D*P+e*U+s*o+i*O,d[n+15]=D*j+e*Y+s*F+i*G}function M(E,H){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const n=E.kd();H[d]=n[0],H[d+1]=n[1],H[d+2]=n[2],H[d+3]=n[3],H[d+4]=n[4],H[d+5]=n[5],H[d+6]=n[6],H[d+7]=n[7],H[d+8]=n[8],H[d+9]=n[9],H[d+10]=n[10],H[d+11]=n[11],H[d+12]=n[12],H[d+13]=n[13],H[d+14]=n[14],H[d+15]=n[15]}function V(E,H){const d=E.kd(),n=d[0],Z=d[1],I=d[2],g=d[3],l=d[4],r=d[5],t=d[6],S=d[7],M=d[8],V=d[9],C=d[10],w=d[11],R=d[12],Q=d[13],L=d[14],D=d[15],e=C*D-L*w,s=V*D-Q*w,i=V*L-Q*C,p=M*D-R*w,f=M*L-C*R,P=M*Q-R*V,j=+(r*e-t*s+S*i),X=-(l*e-t*p+S*f),W=+(l*s-r*p+S*P),U=-(l*i-r*f+t*P),Y=n*j+Z*X+I*W+g*U;if(0===Y)return!1;const c=1/Y,u=t*D-L*S,o=r*D-Q*S,F=r*L-Q*t,a=l*D-R*S,k=l*L-R*t,O=l*Q-R*r,G=t*w-C*S,x=r*w-V*S,q=r*C-V*t,b=l*w-M*S,h=l*C-M*t,y=l*V-M*r,v=-(Z*e-I*s+g*i),z=+(n*e-I*p+g*f),K=-(n*s-Z*p+g*P),N=+(n*i-Z*f+I*P),mE=+(Z*u-I*o+g*F),T=-(n*u-I*a+g*k),A=+(n*o-Z*a+g*O),B=-(n*F-Z*k+I*O),J=-(Z*G-I*x+g*q),EE=+(n*G-I*b+g*h),HE=-(n*x-Z*b+g*y),dE=+(n*q-Z*h+I*y);return H[0]=j*c,H[1]=v*c,H[2]=mE*c,H[3]=J*c,H[4]=X*c,H[5]=z*c,H[6]=T*c,H[7]=EE*c,H[8]=W*c,H[9]=K*c,H[10]=A*c,H[11]=HE*c,H[12]=U*c,H[13]=N*c,H[14]=B*c,H[15]=dE*c,!0}t._UpdateFlagSeed=0;const C=E=>parseInt(E.toString().replace(/\W/g,""));class w{constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=E,this.y=H}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let E=C(this.x);return E=397*E^C(this.y),E}toArray(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[H]=this.x,E[H+1]=this.y,this}Xd(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w.FromArrayToRef(E,H,this),this}kd(){return[this.x,this.y]}l(E){return this.x=E.x,this.y=E.y,this}en(E,H){return this.x=E,this.y=H,this}set(E,H){return this.en(E,H)}ng(E){return this.en(E,E)}add(E){return new w(this.x+E.x,this.y+E.y)}addToRef(E,H){return H.x=this.x+E.x,H.y=this.y+E.y,H}addInPlace(E){return this.x+=E.x,this.y+=E.y,this}addInPlaceFromFloats(E,H){return this.x+=E,this.y+=H,this}addVector3(E){return new w(this.x+E.x,this.y+E.y)}RH(E){return new w(this.x-E.x,this.y-E.y)}subtractToRef(E,H){return H.x=this.x-E.x,H.y=this.y-E.y,H}MM(E){return this.x-=E.x,this.y-=E.y,this}multiplyInPlace(E){return this.x*=E.x,this.y*=E.y,this}multiply(E){return new w(this.x*E.x,this.y*E.y)}multiplyToRef(E,H){return H.x=this.x*E.x,H.y=this.y*E.y,H}multiplyByFloats(E,H){return new w(this.x*E,this.y*H)}divide(E){return new w(this.x/E.x,this.y/E.y)}divideToRef(E,H){return H.x=this.x/E.x,H.y=this.y/E.y,H}divideInPlace(E){return this.x=this.x/E.x,this.y=this.y/E.y,this}minimizeInPlace(E){return this.minimizeInPlaceFromFloats(E.x,E.y)}maximizeInPlace(E){return this.maximizeInPlaceFromFloats(E.x,E.y)}minimizeInPlaceFromFloats(E,H){return this.x=Math.min(E,this.x),this.y=Math.min(H,this.y),this}maximizeInPlaceFromFloats(E,H){return this.x=Math.max(E,this.x),this.y=Math.max(H,this.y),this}subtractFromFloats(E,H){return new w(this.x-E,this.y-H)}subtractFromFloatsToRef(E,H,d){return d.x=this.x-E,d.y=this.y-H,d}negate(){return new w(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(E){return E.x=-this.x,E.y=-this.y,E}scaleInPlace(E){return this.x*=E,this.y*=E,this}scale(E){return new w(this.x*E,this.y*E)}scaleToRef(E,H){return H.x=this.x*E,H.y=this.y*E,H}scaleAndAddToRef(E,H){return H.x+=this.x*E,H.y+=this.y*E,H}equals(E){return E&&this.x===E.x&&this.y===E.y}equalsWithEpsilon(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.c;return E&&(0,r.WithinEpsilon)(this.x,E.x,H)&&(0,r.WithinEpsilon)(this.y,E.y,H)}equalsToFloats(E,H){return this.x===E&&this.y===H}floor(){return new w(Math.floor(this.x),Math.floor(this.y))}floorToRef(E){return E.x=Math.floor(this.x),E.y=Math.floor(this.y),E}fract(){return new w(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(E){return E.x=this.x-Math.floor(this.x),E.y=this.y-Math.floor(this.y),E}rotate(E){return this.rotateToRef(E,new w)}rotateToRef(E,H){const d=Math.cos(E),n=Math.sin(E);return H.x=d*this.x-n*this.y,H.y=n*this.x+d*this.y,H}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){const E=new w;return this.normalizeToRef(E),E}normalizeToRef(E){const H=this.length();return 0===H&&(E.x=this.x,E.y=this.y),this.scaleToRef(1/H,E)}clone(){return new w(this.x,this.y)}dot(E){return this.x*E.x+this.y*E.y}static Zero(){return new w(0,0)}static One(){return new w(1,1)}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new w((0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).en((0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H))}static get ZeroReadOnly(){return w._ZeroReadOnly}static eH(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new w(E[H],E[H+1])}static FromArrayToRef(E,H,d){return d.x=E[H],d.y=E[H+1],d}static FromFloatsToRef(E,H,d){return d.en(E,H),d}static CatmullRom(E,H,d,n,Z){const I=Z*Z,g=Z*I,l=.5*(2*H.x+(-E.x+d.x)*Z+(2*E.x-5*H.x+4*d.x-n.x)*I+(-E.x+3*H.x-3*d.x+n.x)*g),r=.5*(2*H.y+(-E.y+d.y)*Z+(2*E.y-5*H.y+4*d.y-n.y)*I+(-E.y+3*H.y-3*d.y+n.y)*g);return new w(l,r)}static ClampToRef(E,H,d,n){return n.x=(0,r.Clamp)(E.x,H.x,d.x),n.y=(0,r.Clamp)(E.y,H.y,d.y),n}static Clamp(E,H,d){const n=(0,r.Clamp)(E.x,H.x,d.x),Z=(0,r.Clamp)(E.y,H.y,d.y);return new w(n,Z)}static Hermite(E,H,d,n,Z){const I=Z*Z,g=Z*I,l=2*g-3*I+1,r=-2*g+3*I,t=g-2*I+Z,S=g-I,M=E.x*l+d.x*r+H.x*t+n.x*S,V=E.y*l+d.y*r+H.y*t+n.y*S;return new w(M,V)}static Hermite1stDerivative(E,H,d,n,Z){return this.Hermite1stDerivativeToRef(E,H,d,n,Z,new w)}static Hermite1stDerivativeToRef(E,H,d,n,Z,I){const g=Z*Z;return I.x=6*(g-Z)*E.x+(3*g-4*Z+1)*H.x+6*(-g+Z)*d.x+(3*g-2*Z)*n.x,I.y=6*(g-Z)*E.y+(3*g-4*Z+1)*H.y+6*(-g+Z)*d.y+(3*g-2*Z)*n.y,I}static Lerp(E,H,d){return w.LerpToRef(E,H,d,new w)}static LerpToRef(E,H,d,n){return n.x=E.x+(H.x-E.x)*d,n.y=E.y+(H.y-E.y)*d,n}static Dot(E,H){return E.x*H.x+E.y*H.y}static Normalize(E){return w.NormalizeToRef(E,new w)}static NormalizeToRef(E,H){return E.normalizeToRef(H),H}static Minimize(E,H){const d=E.x<H.x?E.x:H.x,n=E.y<H.y?E.y:H.y;return new w(d,n)}static Maximize(E,H){const d=E.x>H.x?E.x:H.x,n=E.y>H.y?E.y:H.y;return new w(d,n)}static Transform(E,H){return w.TransformToRef(E,H,new w)}static TransformToRef(E,H,d){const n=H.m,Z=E.x*n[0]+E.y*n[4]+n[12],I=E.x*n[1]+E.y*n[5]+n[13];return d.x=Z,d.y=I,d}static PointInTriangle(E,H,d,n){const Z=.5*(-d.y*n.x+H.y*(-d.x+n.x)+H.x*(d.y-n.y)+d.x*n.y),I=Z<0?-1:1,g=(H.y*n.x-H.x*n.y+(n.y-H.y)*E.x+(H.x-n.x)*E.y)*I,l=(H.x*d.y-H.y*d.x+(H.y-d.y)*E.x+(d.x-H.x)*E.y)*I;return g>0&&l>0&&g+l<2*Z*I}static Distance(E,H){return Math.sqrt(w.DistanceSquared(E,H))}static DistanceSquared(E,H){const d=E.x-H.x,n=E.y-H.y;return d*d+n*n}static Center(E,H){return w.CenterToRef(E,H,new w)}static CenterToRef(E,H,d){return d.en((E.x+H.x)/2,(E.y+H.y)/2)}static DistanceOfPointFromSegment(E,H,d){const n=w.DistanceSquared(H,d);if(0===n)return w.Distance(E,H);const Z=d.RH(H),I=Math.max(0,Math.min(1,w.Dot(E.RH(H),Z)/n)),g=H.add(Z.multiplyByFloats(I,I));return w.Distance(E,g)}}w._V8PerformanceHack=new w(.5,.5),w._ZeroReadOnly=w.Zero(),Object.defineProperties(w.prototype,{dimension:{value:[2]},rank:{value:1}});class R{get x(){return this._x}set x(E){this._x=E,this._isDirty=!0}get y(){return this._y}set y(E){this._y=E,this._isDirty=!0}get z(){return this._z}set z(E){this._z=E,this._isDirty=!0}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=E,this._y=H,this._z=d}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"wH"}getHashCode(){let E=C(this._x);return E=397*E^C(this._y),E=397*E^C(this._z),E}kd(){return[this._x,this._y,this._z]}toArray(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[H]=this._x,E[H+1]=this._y,E[H+2]=this._z,this}Xd(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R.FromArrayToRef(E,H,this),this}toQuaternion(){return L.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(E){return this._x+=E._x,this._y+=E._y,this._z+=E._z,this._isDirty=!0,this}addInPlaceFromFloats(E,H,d){return this._x+=E,this._y+=H,this._z+=d,this._isDirty=!0,this}add(E){return new R(this._x+E._x,this._y+E._y,this._z+E._z)}addToRef(E,H){return H._x=this._x+E._x,H._y=this._y+E._y,H._z=this._z+E._z,H._isDirty=!0,H}MM(E){return this._x-=E._x,this._y-=E._y,this._z-=E._z,this._isDirty=!0,this}RH(E){return new R(this._x-E._x,this._y-E._y,this._z-E._z)}subtractToRef(E,H){return this.subtractFromFloatsToRef(E._x,E._y,E._z,H)}subtractFromFloats(E,H,d){return new R(this._x-E,this._y-H,this._z-d)}subtractFromFloatsToRef(E,H,d,n){return n._x=this._x-E,n._y=this._y-H,n._z=this._z-d,n._isDirty=!0,n}negate(){return new R(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(E){return E._x=-1*this._x,E._y=-1*this._y,E._z=-1*this._z,E._isDirty=!0,E}scaleInPlace(E){return this._x*=E,this._y*=E,this._z*=E,this._isDirty=!0,this}scale(E){return new R(this._x*E,this._y*E,this._z*E)}scaleToRef(E,H){return H._x=this._x*E,H._y=this._y*E,H._z=this._z*E,H._isDirty=!0,H}getNormalToRef(E){const H=this.length();let d=Math.acos(this._y/H);const n=Math.atan2(this._z,this._x);d>Math.PI/2?d-=Math.PI/2:d+=Math.PI/2;const Z=H*Math.sin(d)*Math.cos(n),I=H*Math.cos(d),g=H*Math.sin(d)*Math.sin(n);return E.set(Z,I,g),E}applyRotationQuaternionToRef(E,H){const d=this._x,n=this._y,Z=this._z,I=E._x,g=E._y,l=E._z,r=E._w,t=2*(g*Z-l*n),S=2*(l*d-I*Z),M=2*(I*n-g*d);return H._x=d+r*t+g*M-l*S,H._y=n+r*S+l*t-I*M,H._z=Z+r*M+I*S-g*t,H._isDirty=!0,H}applyRotationQuaternionInPlace(E){return this.applyRotationQuaternionToRef(E,this)}applyRotationQuaternion(E){return this.applyRotationQuaternionToRef(E,new R)}scaleAndAddToRef(E,H){return H._x+=this._x*E,H._y+=this._y*E,H._z+=this._z*E,H._isDirty=!0,H}projectOnPlane(E,H){return this.projectOnPlaneToRef(E,H,new R)}projectOnPlaneToRef(E,H,d){const n=E.normal,Z=E.d,I=e.wH[0];this.subtractToRef(H,I),I.normalize();const g=R.Dot(I,n);if(Math.abs(g)<1e-10)d.ng(1/0);else{const E=-(R.Dot(H,n)+Z)/g,l=I.scaleInPlace(E);H.addToRef(l,d)}return d}equals(E){return E&&this._x===E._x&&this._y===E._y&&this._z===E._z}equalsWithEpsilon(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.c;return E&&(0,r.WithinEpsilon)(this._x,E._x,H)&&(0,r.WithinEpsilon)(this._y,E._y,H)&&(0,r.WithinEpsilon)(this._z,E._z,H)}equalsToFloats(E,H,d){return this._x===E&&this._y===H&&this._z===d}multiplyInPlace(E){return this._x*=E._x,this._y*=E._y,this._z*=E._z,this._isDirty=!0,this}multiply(E){return this.multiplyByFloats(E._x,E._y,E._z)}multiplyToRef(E,H){return H._x=this._x*E._x,H._y=this._y*E._y,H._z=this._z*E._z,H._isDirty=!0,H}multiplyByFloats(E,H,d){return new R(this._x*E,this._y*H,this._z*d)}divide(E){return new R(this._x/E._x,this._y/E._y,this._z/E._z)}divideToRef(E,H){return H._x=this._x/E._x,H._y=this._y/E._y,H._z=this._z/E._z,H._isDirty=!0,H}divideInPlace(E){return this._x=this._x/E._x,this._y=this._y/E._y,this._z=this._z/E._z,this._isDirty=!0,this}minimizeInPlace(E){return this.minimizeInPlaceFromFloats(E._x,E._y,E._z)}maximizeInPlace(E){return this.maximizeInPlaceFromFloats(E._x,E._y,E._z)}minimizeInPlaceFromFloats(E,H,d){return E<this._x&&(this.x=E),H<this._y&&(this.y=H),d<this._z&&(this.z=d),this}maximizeInPlaceFromFloats(E,H,d){return E>this._x&&(this.x=E),H>this._y&&(this.y=H),d>this._z&&(this.z=d),this}isNonUniformWithinEpsilon(E){const H=Math.abs(this._x),d=Math.abs(this._y);if(!(0,r.WithinEpsilon)(H,d,E))return!0;const n=Math.abs(this._z);return!(0,r.WithinEpsilon)(H,n,E)||!(0,r.WithinEpsilon)(d,n,E)}get isNonUniform(){const E=Math.abs(this._x);if(E!==Math.abs(this._y))return!0;return E!==Math.abs(this._z)}floorToRef(E){return E._x=Math.floor(this._x),E._y=Math.floor(this._y),E._z=Math.floor(this._z),E._isDirty=!0,E}floor(){return new R(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(E){return E._x=this._x-Math.floor(this._x),E._y=this._y-Math.floor(this._y),E._z=this._z-Math.floor(this._z),E._isDirty=!0,E}fract(){return new R(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(E){if("xyz"===(E=E.toLowerCase()))return this;const H=e.wH[0].l(this);return this.x=H[E[0]],this.y=H[E[1]],this.z=H[E[2]],this}rotateByQuaternionToRef(E,H){return E.toRotationMatrix(e.Matrix[0]),R.TransformCoordinatesToRef(this,e.Matrix[0],H),H}rotateByQuaternionAroundPointToRef(E,H,d){return this.subtractToRef(H,e.wH[0]),e.wH[0].rotateByQuaternionToRef(E,e.wH[0]),H.addToRef(e.wH[0],d),d}cross(E){return R.CrossToRef(this,E,new R)}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){return this.normalizeToRef(new R)}normalizeToRef(E){const H=this.length();return 0===H||1===H?(E._x=this._x,E._y=this._y,E._z=this._z,E._isDirty=!0,E):this.scaleToRef(1/H,E)}clone(){return new R(this._x,this._y,this._z)}l(E){return this.en(E._x,E._y,E._z)}en(E,H,d){return this._x=E,this._y=H,this._z=d,this._isDirty=!0,this}set(E,H,d){return this.en(E,H,d)}ng(E){return this._x=this._y=this._z=E,this._isDirty=!0,this}static GetClipFactor(E,H,d,n){const Z=R.Dot(E,d);return(Z-n)/(Z-R.Dot(H,d))}static GetAngleBetweenVectors(E,H,d){const n=E.normalizeToRef(e.wH[1]),Z=H.normalizeToRef(e.wH[2]);let I=R.Dot(n,Z);I=(0,r.Clamp)(I,-1,1);const g=Math.acos(I),l=e.wH[3];return R.CrossToRef(n,Z,l),R.Dot(l,d)>0?isNaN(g)?0:g:isNaN(g)?-Math.PI:-Math.acos(I)}static GetAngleBetweenVectorsOnPlane(E,H,d){e.wH[0].l(E);const n=e.wH[0];e.wH[1].l(H);const Z=e.wH[1];e.wH[2].l(d);const I=e.wH[2],g=e.wH[3],l=e.wH[4];n.normalize(),Z.normalize(),I.normalize(),R.CrossToRef(I,n,g),R.CrossToRef(g,I,l);const t=Math.atan2(R.Dot(Z,g),R.Dot(Z,l));return(0,r.NormalizeRadians)(t)}static PitchYawRollToMoveBetweenPointsToRef(E,H,d){const n=s.wH[0];return H.subtractToRef(E,n),d._y=Math.atan2(n.x,n.z)||0,d._x=Math.atan2(Math.sqrt(n.x**2+n.z**2),n.y)||0,d._z=0,d._isDirty=!0,d}static PitchYawRollToMoveBetweenPoints(E,H){const d=R.Zero();return R.PitchYawRollToMoveBetweenPointsToRef(E,H,d)}static SlerpToRef(E,H,d,Z){d=(0,r.Clamp)(d,0,1);const I=e.wH[0],g=e.wH[1];I.l(E);const l=I.length();I.normalizeFromLength(l),g.l(H);const t=g.length();g.normalizeFromLength(t);const S=R.Dot(I,g);let M,V;if(S<1-n.c){const E=Math.acos(S),H=1/Math.sin(E);M=Math.sin((1-d)*E)*H,V=Math.sin(d*E)*H}else M=1-d,V=d;return I.scaleInPlace(M),g.scaleInPlace(V),Z.l(I).addInPlace(g),Z.scaleInPlace((0,r.Lerp)(l,t,d)),Z}static SmoothToRef(E,H,d,n,Z){return R.SlerpToRef(E,H,0===n?1:d/n,Z),Z}static eH(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new R(E[H],E[H+1],E[H+2])}static FromFloatArray(E,H){return R.eH(E,H)}static FromArrayToRef(E,H,d){return d._x=E[H],d._y=E[H+1],d._z=E[H+2],d._isDirty=!0,d}static FromFloatArrayToRef(E,H,d){return R.FromArrayToRef(E,H,d)}static FromFloatsToRef(E,H,d,n){return n.en(E,H,d),n}static Zero(){return new R(0,0,0)}static One(){return new R(1,1,1)}static Up(){return new R(0,1,0)}static get UpReadOnly(){return R._UpReadOnly}static get DownReadOnly(){return R._DownReadOnly}static get RightReadOnly(){return R._RightReadOnly}static get LeftReadOnly(){return R._LeftReadOnly}static get LeftHandedForwardReadOnly(){return R._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return R._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return R._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return R._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return R._ZeroReadOnly}static get OneReadOnly(){return R._OneReadOnly}static Down(){return new R(0,-1,0)}static Forward(){return new R(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new R(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new R(1,0,0)}static Left(){return new R(-1,0,0)}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new R((0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).en((0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H))}static TransformCoordinates(E,H){const d=R.Zero();return R.TransformCoordinatesToRef(E,H,d),d}static TransformCoordinatesToRef(E,H,d){return R.TransformCoordinatesFromFloatsToRef(E._x,E._y,E._z,H,d),d}static TransformCoordinatesFromFloatsToRef(E,H,d,n,Z){const I=n.m,g=E*I[0]+H*I[4]+d*I[8]+I[12],l=E*I[1]+H*I[5]+d*I[9]+I[13],r=E*I[2]+H*I[6]+d*I[10]+I[14],t=1/(E*I[3]+H*I[7]+d*I[11]+I[15]);return Z._x=g*t,Z._y=l*t,Z._z=r*t,Z._isDirty=!0,Z}static TransformNormal(E,H){const d=R.Zero();return R.TransformNormalToRef(E,H,d),d}static TransformNormalToRef(E,H,d){return this.TransformNormalFromFloatsToRef(E._x,E._y,E._z,H,d),d}static TransformNormalFromFloatsToRef(E,H,d,n,Z){const I=n.m;return Z._x=E*I[0]+H*I[4]+d*I[8],Z._y=E*I[1]+H*I[5]+d*I[9],Z._z=E*I[2]+H*I[6]+d*I[10],Z._isDirty=!0,Z}static CatmullRom(E,H,d,n,Z){const I=Z*Z,g=Z*I,l=.5*(2*H._x+(-E._x+d._x)*Z+(2*E._x-5*H._x+4*d._x-n._x)*I+(-E._x+3*H._x-3*d._x+n._x)*g),r=.5*(2*H._y+(-E._y+d._y)*Z+(2*E._y-5*H._y+4*d._y-n._y)*I+(-E._y+3*H._y-3*d._y+n._y)*g),t=.5*(2*H._z+(-E._z+d._z)*Z+(2*E._z-5*H._z+4*d._z-n._z)*I+(-E._z+3*H._z-3*d._z+n._z)*g);return new R(l,r,t)}static Clamp(E,H,d){const n=new R;return R.ClampToRef(E,H,d,n),n}static ClampToRef(E,H,d,n){let Z=E._x;Z=Z>d._x?d._x:Z,Z=Z<H._x?H._x:Z;let I=E._y;I=I>d._y?d._y:I,I=I<H._y?H._y:I;let g=E._z;return g=g>d._z?d._z:g,g=g<H._z?H._z:g,n.en(Z,I,g),n}static CheckExtends(E,H,d){H.minimizeInPlace(E),d.maximizeInPlace(E)}static Hermite(E,H,d,n,Z){const I=Z*Z,g=Z*I,l=2*g-3*I+1,r=-2*g+3*I,t=g-2*I+Z,S=g-I,M=E._x*l+d._x*r+H._x*t+n._x*S,V=E._y*l+d._y*r+H._y*t+n._y*S,C=E._z*l+d._z*r+H._z*t+n._z*S;return new R(M,V,C)}static Hermite1stDerivative(E,H,d,n,Z){const I=new R;return this.Hermite1stDerivativeToRef(E,H,d,n,Z,I),I}static Hermite1stDerivativeToRef(E,H,d,n,Z,I){const g=Z*Z;return I._x=6*(g-Z)*E._x+(3*g-4*Z+1)*H._x+6*(-g+Z)*d._x+(3*g-2*Z)*n._x,I._y=6*(g-Z)*E._y+(3*g-4*Z+1)*H._y+6*(-g+Z)*d._y+(3*g-2*Z)*n._y,I._z=6*(g-Z)*E._z+(3*g-4*Z+1)*H._z+6*(-g+Z)*d._z+(3*g-2*Z)*n._z,I._isDirty=!0,I}static Lerp(E,H,d){const n=new R(0,0,0);return R.LerpToRef(E,H,d,n),n}static LerpToRef(E,H,d,n){return n._x=E._x+(H._x-E._x)*d,n._y=E._y+(H._y-E._y)*d,n._z=E._z+(H._z-E._z)*d,n._isDirty=!0,n}static Dot(E,H){return E._x*H._x+E._y*H._y+E._z*H._z}dot(E){return this._x*E._x+this._y*E._y+this._z*E._z}static Cross(E,H){const d=new R;return R.CrossToRef(E,H,d),d}static CrossToRef(E,H,d){const n=E._y*H._z-E._z*H._y,Z=E._z*H._x-E._x*H._z,I=E._x*H._y-E._y*H._x;return d.en(n,Z,I),d}static Normalize(E){const H=R.Zero();return R.NormalizeToRef(E,H),H}static NormalizeToRef(E,H){return E.normalizeToRef(H),H}static Project(E,H,d,n){const Z=new R;return R.ProjectToRef(E,H,d,n,Z),Z}static ProjectToRef(E,H,d,n,Z){var I;const g=n.width,r=n.height,t=n.x,S=n.y,M=e.Matrix[1],V=null===(I=l.b.LastCreatedEngine)||void 0===I?void 0:I.isNDCHalfZRange,C=V?1:.5,w=V?0:.5;D.FromValuesToRef(g/2,0,0,0,0,-r/2,0,0,0,0,C,0,t+g/2,r/2+S,w,1,M);const Q=e.Matrix[0];return H.multiplyToRef(d,Q),Q.multiplyToRef(M,Q),R.TransformCoordinatesToRef(E,Q,Z),Z}static Reflect(E,H){return this.ReflectToRef(E,H,new R)}static ReflectToRef(E,H,d){const n=s.wH[0];return n.l(H).scaleInPlace(2*R.Dot(E,H)),d.l(E).MM(n)}static _UnprojectFromInvertedMatrixToRef(E,H,d){R.TransformCoordinatesToRef(E,H,d);const n=H.m,Z=E._x*n[3]+E._y*n[7]+E._z*n[11]+n[15];return(0,r.WithinEpsilon)(Z,1)&&d.scaleInPlace(1/Z),d}static UnprojectFromTransform(E,H,d,n,Z){return this.Unproject(E,H,d,n,Z,D.IdentityReadOnly)}static Unproject(E,H,d,n,Z,I){const g=new R;return R.UnprojectToRef(E,H,d,n,Z,I,g),g}static UnprojectToRef(E,H,d,n,Z,I,g){return R.UnprojectFloatsToRef(E._x,E._y,E._z,H,d,n,Z,I,g),g}static UnprojectFloatsToRef(E,H,d,n,Z,I,g,r,t){var S;const M=e.Matrix[0];I.multiplyToRef(g,M),M.multiplyToRef(r,M),M.invert();const V=e.wH[0];return V.x=E/n*2-1,V.y=-(H/Z*2-1),null!==(S=l.b.LastCreatedEngine)&&void 0!==S&&S.isNDCHalfZRange?V.z=d:V.z=2*d-1,R._UnprojectFromInvertedMatrixToRef(V,M,t),t}static Minimize(E,H){const d=new R;return d.l(E),d.minimizeInPlace(H),d}static Maximize(E,H){const d=new R;return d.l(E),d.maximizeInPlace(H),d}static Distance(E,H){return Math.sqrt(R.DistanceSquared(E,H))}static DistanceSquared(E,H){const d=E._x-H._x,n=E._y-H._y,Z=E._z-H._z;return d*d+n*n+Z*Z}static ProjectOnTriangleToRef(E,H,d,Z,I){const g=e.wH[0],l=e.wH[1],t=e.wH[2],S=e.wH[3],M=e.wH[4];d.subtractToRef(H,g),Z.subtractToRef(H,l),Z.subtractToRef(d,t);const V=g.length(),C=l.length(),w=t.length();if(V<n.c||C<n.c||w<n.c)return I.l(H),R.Distance(E,H);E.subtractToRef(H,M),R.CrossToRef(g,l,S);const Q=S.length();if(Q<n.c)return I.l(H),R.Distance(E,H);S.normalizeFromLength(Q);let L=M.length();if(L<n.c)return I.l(H),0;M.normalizeFromLength(L);const D=R.Dot(S,M),s=e.wH[5],i=e.wH[6];s.l(S).scaleInPlace(-L*D),i.l(E).addInPlace(s);const p=e.wH[4],f=e.wH[5],P=e.wH[7],j=e.wH[8];p.l(g).scaleInPlace(1/V),j.l(l).scaleInPlace(1/C),p.addInPlace(j).scaleInPlace(-1),f.l(g).scaleInPlace(-1/V),j.l(t).scaleInPlace(1/w),f.addInPlace(j).scaleInPlace(-1),P.l(t).scaleInPlace(-1/w),j.l(l).scaleInPlace(-1/C),P.addInPlace(j).scaleInPlace(-1);const X=e.wH[9];let W;X.l(i).MM(H),R.CrossToRef(p,X,j),W=R.Dot(j,S);const U=W;X.l(i).MM(d),R.CrossToRef(f,X,j),W=R.Dot(j,S);const Y=W;X.l(i).MM(Z),R.CrossToRef(P,X,j),W=R.Dot(j,S);const c=W,u=e.wH[10];let o,F;U>0&&Y<0?(u.l(g),o=H,F=d):Y>0&&c<0?(u.l(t),o=d,F=Z):(u.l(l).scaleInPlace(-1),o=Z,F=H);const a=e.wH[9],k=e.wH[4];o.subtractToRef(i,j),F.subtractToRef(i,a),R.CrossToRef(j,a,k);if(!(R.Dot(k,S)<0))return I.l(i),Math.abs(L*D);const O=e.wH[5];R.CrossToRef(u,k,O),O.normalize();const G=e.wH[9];G.l(o).MM(i);const x=G.length();if(x<n.c)return I.l(o),R.Distance(E,o);G.normalizeFromLength(x);const q=R.Dot(O,G),b=e.wH[7];b.l(i).addInPlace(O.scaleInPlace(x*q)),j.l(b).MM(o),L=u.length(),u.normalizeFromLength(L);let h=R.Dot(j,u)/Math.max(L,n.c);return h=(0,r.Clamp)(h,0,1),b.l(o).addInPlace(u.scaleInPlace(h*L)),I.l(b),R.Distance(E,b)}static Center(E,H){return R.CenterToRef(E,H,R.Zero())}static CenterToRef(E,H,d){return d.en((E._x+H._x)/2,(E._y+H._y)/2,(E._z+H._z)/2)}static RotationFromAxis(E,H,d){const n=new R;return R.RotationFromAxisToRef(E,H,d,n),n}static RotationFromAxisToRef(E,H,d,n){const Z=e.Quaternion[0];return L.RotationQuaternionFromAxisToRef(E,H,d,Z),Z.toEulerAnglesToRef(n),n}}R._V8PerformanceHack=new R(.5,.5,.5),R._UpReadOnly=R.Up(),R._DownReadOnly=R.Down(),R._LeftHandedForwardReadOnly=R.Forward(!1),R._RightHandedForwardReadOnly=R.Forward(!0),R._LeftHandedBackwardReadOnly=R.Backward(!1),R._RightHandedBackwardReadOnly=R.Backward(!0),R._RightReadOnly=R.Right(),R._LeftReadOnly=R.Left(),R._ZeroReadOnly=R.Zero(),R._OneReadOnly=R.One(),Object.defineProperties(R.prototype,{dimension:{value:[3]},rank:{value:1}});class Q{get x(){return this._x}set x(E){this._x=E,this._isDirty=!0}get y(){return this._y}set y(E){this._y=E,this._isDirty=!0}get z(){return this._z}set z(E){this._z=E,this._isDirty=!0}get w(){return this._w}set w(E){this._w=E,this._isDirty=!0}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=E,this._y=H,this._z=d,this._w=n}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let E=C(this._x);return E=397*E^C(this._y),E=397*E^C(this._z),E=397*E^C(this._w),E}kd(){return[this._x,this._y,this._z,this._w]}toArray(E,H){return void 0===H&&(H=0),E[H]=this._x,E[H+1]=this._y,E[H+2]=this._z,E[H+3]=this._w,this}Xd(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(E,H,this),this}addInPlace(E){return this.x+=E._x,this.y+=E._y,this.z+=E._z,this.w+=E._w,this}addInPlaceFromFloats(E,H,d,n){return this.x+=E,this.y+=H,this.z+=d,this.w+=n,this}add(E){return new Q(this._x+E.x,this._y+E.y,this._z+E.z,this._w+E.w)}addToRef(E,H){return H.x=this._x+E.x,H.y=this._y+E.y,H.z=this._z+E.z,H.w=this._w+E.w,H}MM(E){return this.x-=E.x,this.y-=E.y,this.z-=E.z,this.w-=E.w,this}RH(E){return new Q(this._x-E.x,this._y-E.y,this._z-E.z,this._w-E.w)}subtractToRef(E,H){return H.x=this._x-E.x,H.y=this._y-E.y,H.z=this._z-E.z,H.w=this._w-E.w,H}subtractFromFloats(E,H,d,n){return new Q(this._x-E,this._y-H,this._z-d,this._w-n)}subtractFromFloatsToRef(E,H,d,n,Z){return Z.x=this._x-E,Z.y=this._y-H,Z.z=this._z-d,Z.w=this._w-n,Z}negate(){return new Q(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(E){return E.x=-this._x,E.y=-this._y,E.z=-this._z,E.w=-this._w,E}scaleInPlace(E){return this.x*=E,this.y*=E,this.z*=E,this.w*=E,this}scale(E){return new Q(this._x*E,this._y*E,this._z*E,this._w*E)}scaleToRef(E,H){return H.x=this._x*E,H.y=this._y*E,H.z=this._z*E,H.w=this._w*E,H}scaleAndAddToRef(E,H){return H.x+=this._x*E,H.y+=this._y*E,H.z+=this._z*E,H.w+=this._w*E,H}equals(E){return E&&this._x===E.x&&this._y===E.y&&this._z===E.z&&this._w===E.w}equalsWithEpsilon(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.c;return E&&(0,r.WithinEpsilon)(this._x,E.x,H)&&(0,r.WithinEpsilon)(this._y,E.y,H)&&(0,r.WithinEpsilon)(this._z,E.z,H)&&(0,r.WithinEpsilon)(this._w,E.w,H)}equalsToFloats(E,H,d,n){return this._x===E&&this._y===H&&this._z===d&&this._w===n}multiplyInPlace(E){return this.x*=E.x,this.y*=E.y,this.z*=E.z,this.w*=E.w,this}multiply(E){return new Q(this._x*E.x,this._y*E.y,this._z*E.z,this._w*E.w)}multiplyToRef(E,H){return H.x=this._x*E.x,H.y=this._y*E.y,H.z=this._z*E.z,H.w=this._w*E.w,H}multiplyByFloats(E,H,d,n){return new Q(this._x*E,this._y*H,this._z*d,this._w*n)}divide(E){return new Q(this._x/E.x,this._y/E.y,this._z/E.z,this._w/E.w)}divideToRef(E,H){return H.x=this._x/E.x,H.y=this._y/E.y,H.z=this._z/E.z,H.w=this._w/E.w,H}divideInPlace(E){return this.divideToRef(E,this)}minimizeInPlace(E){return E.x<this._x&&(this.x=E.x),E.y<this._y&&(this.y=E.y),E.z<this._z&&(this.z=E.z),E.w<this._w&&(this.w=E.w),this}maximizeInPlace(E){return E.x>this._x&&(this.x=E.x),E.y>this._y&&(this.y=E.y),E.z>this._z&&(this.z=E.z),E.w>this._w&&(this.w=E.w),this}minimizeInPlaceFromFloats(E,H,d,n){return this.x=Math.min(E,this._x),this.y=Math.min(H,this._y),this.z=Math.min(d,this._z),this.w=Math.min(n,this._w),this}maximizeInPlaceFromFloats(E,H,d,n){return this.x=Math.max(E,this._x),this.y=Math.max(H,this._y),this.z=Math.max(d,this._z),this.w=Math.max(n,this._w),this}floorToRef(E){return E.x=Math.floor(this._x),E.y=Math.floor(this._y),E.z=Math.floor(this._z),E.w=Math.floor(this._w),E}floor(){return new Q(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(E){return E.x=this._x-Math.floor(this._x),E.y=this._y-Math.floor(this._y),E.z=this._z-Math.floor(this._z),E.w=this._w-Math.floor(this._w),E}fract(){return new Q(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){return this.normalizeToRef(new Q)}normalizeToRef(E){const H=this.length();return 0===H||1===H?(E.x=this._x,E.y=this._y,E.z=this._z,E.w=this._w,E):this.scaleToRef(1/H,E)}toVector3(){return new R(this._x,this._y,this._z)}clone(){return new Q(this._x,this._y,this._z,this._w)}l(E){return this.x=E.x,this.y=E.y,this.z=E.z,this.w=E.w,this}en(E,H,d,n){return this.x=E,this.y=H,this.z=d,this.w=n,this}set(E,H,d,n){return this.en(E,H,d,n)}ng(E){return this.x=this.y=this.z=this.w=E,this}dot(E){return this._x*E.x+this._y*E.y+this._z*E.z+this._w*E.w}static eH(E,H){return H||(H=0),new Q(E[H],E[H+1],E[H+2],E[H+3])}static FromArrayToRef(E,H,d){return d.x=E[H],d.y=E[H+1],d.z=E[H+2],d.w=E[H+3],d}static FromFloatArrayToRef(E,H,d){return Q.FromArrayToRef(E,H,d),d}static FromFloatsToRef(E,H,d,n,Z){return Z.x=E,Z.y=H,Z.z=d,Z.w=n,Z}static Zero(){return new Q(0,0,0,0)}static One(){return new Q(1,1,1,1)}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Q((0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,d=arguments.length>2?arguments[2]:void 0;return d.x=(0,r.RandomRange)(E,H),d.y=(0,r.RandomRange)(E,H),d.z=(0,r.RandomRange)(E,H),d.w=(0,r.RandomRange)(E,H),d}static Clamp(E,H,d){return Q.ClampToRef(E,H,d,new Q)}static ClampToRef(E,H,d,n){return n.x=(0,r.Clamp)(E.x,H.x,d.x),n.y=(0,r.Clamp)(E.y,H.y,d.y),n.z=(0,r.Clamp)(E.z,H.z,d.z),n.w=(0,r.Clamp)(E.w,H.w,d.w),n}static CheckExtends(E,H,d){H.minimizeInPlace(E),d.maximizeInPlace(E)}static get ZeroReadOnly(){return Q._ZeroReadOnly}static Normalize(E){return Q.NormalizeToRef(E,new Q)}static NormalizeToRef(E,H){return E.normalizeToRef(H),H}static Minimize(E,H){const d=new Q;return d.l(E),d.minimizeInPlace(H),d}static Maximize(E,H){const d=new Q;return d.l(E),d.maximizeInPlace(H),d}static Distance(E,H){return Math.sqrt(Q.DistanceSquared(E,H))}static DistanceSquared(E,H){const d=E.x-H.x,n=E.y-H.y,Z=E.z-H.z,I=E.w-H.w;return d*d+n*n+Z*Z+I*I}static Center(E,H){return Q.CenterToRef(E,H,new Q)}static CenterToRef(E,H,d){return d.x=(E.x+H.x)/2,d.y=(E.y+H.y)/2,d.z=(E.z+H.z)/2,d.w=(E.w+H.w)/2,d}static TransformCoordinates(E,H){return Q.TransformCoordinatesToRef(E,H,new Q)}static TransformCoordinatesToRef(E,H,d){return Q.TransformCoordinatesFromFloatsToRef(E._x,E._y,E._z,H,d),d}static TransformCoordinatesFromFloatsToRef(E,H,d,n,Z){const I=n.m,g=E*I[0]+H*I[4]+d*I[8]+I[12],l=E*I[1]+H*I[5]+d*I[9]+I[13],r=E*I[2]+H*I[6]+d*I[10]+I[14],t=E*I[3]+H*I[7]+d*I[11]+I[15];return Z.x=g,Z.y=l,Z.z=r,Z.w=t,Z}static TransformNormal(E,H){return Q.TransformNormalToRef(E,H,new Q)}static TransformNormalToRef(E,H,d){const n=H.m,Z=E.x*n[0]+E.y*n[4]+E.z*n[8],I=E.x*n[1]+E.y*n[5]+E.z*n[9],g=E.x*n[2]+E.y*n[6]+E.z*n[10];return d.x=Z,d.y=I,d.z=g,d.w=E.w,d}static TransformNormalFromFloatsToRef(E,H,d,n,Z,I){const g=Z.m;return I.x=E*g[0]+H*g[4]+d*g[8],I.y=E*g[1]+H*g[5]+d*g[9],I.z=E*g[2]+H*g[6]+d*g[10],I.w=n,I}static FromVector3(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(E._x,E._y,E._z,H)}static Dot(E,H){return E.x*H.x+E.y*H.y+E.z*H.z+E.w*H.w}}Q._V8PerformanceHack=new Q(.5,.5,.5,.5),Q._ZeroReadOnly=Q.Zero(),Object.defineProperties(Q.prototype,{dimension:{value:[4]},rank:{value:1}});class L{get x(){return this._x}set x(E){this._x=E,this._isDirty=!0}get y(){return this._y}set y(E){this._y=E,this._isDirty=!0}get z(){return this._z}set z(E){this._z=E,this._isDirty=!0}get w(){return this._w}set w(E){this._w=E,this._isDirty=!0}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=E,this._y=H,this._z=d,this._w=n}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let E=C(this._x);return E=397*E^C(this._y),E=397*E^C(this._z),E=397*E^C(this._w),E}kd(){return[this._x,this._y,this._z,this._w]}toArray(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[H]=this._x,E[H+1]=this._y,E[H+2]=this._z,E[H+3]=this._w,this}Xd(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(E,H,this)}equals(E){return E&&this._x===E._x&&this._y===E._y&&this._z===E._z&&this._w===E._w}equalsWithEpsilon(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.c;return E&&(0,r.WithinEpsilon)(this._x,E._x,H)&&(0,r.WithinEpsilon)(this._y,E._y,H)&&(0,r.WithinEpsilon)(this._z,E._z,H)&&(0,r.WithinEpsilon)(this._w,E._w,H)}isApprox(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.c;return E&&((0,r.WithinEpsilon)(this._x,E._x,H)&&(0,r.WithinEpsilon)(this._y,E._y,H)&&(0,r.WithinEpsilon)(this._z,E._z,H)&&(0,r.WithinEpsilon)(this._w,E._w,H)||(0,r.WithinEpsilon)(this._x,-E._x,H)&&(0,r.WithinEpsilon)(this._y,-E._y,H)&&(0,r.WithinEpsilon)(this._z,-E._z,H)&&(0,r.WithinEpsilon)(this._w,-E._w,H))}clone(){return new L(this._x,this._y,this._z,this._w)}l(E){return this._x=E._x,this._y=E._y,this._z=E._z,this._w=E._w,this._isDirty=!0,this}en(E,H,d,n){return this._x=E,this._y=H,this._z=d,this._w=n,this._isDirty=!0,this}set(E,H,d,n){return this.en(E,H,d,n)}ng(E){return this.en(E,E,E,E)}add(E){return new L(this._x+E._x,this._y+E._y,this._z+E._z,this._w+E._w)}addInPlace(E){return this._x+=E._x,this._y+=E._y,this._z+=E._z,this._w+=E._w,this._isDirty=!0,this}addToRef(E,H){return H._x=this._x+E._x,H._y=this._y+E._y,H._z=this._z+E._z,H._w=this._w+E._w,H._isDirty=!0,H}addInPlaceFromFloats(E,H,d,n){return this._x+=E,this._y+=H,this._z+=d,this._w+=n,this._isDirty=!0,this}subtractToRef(E,H){return H._x=this._x-E._x,H._y=this._y-E._y,H._z=this._z-E._z,H._w=this._w-E._w,H._isDirty=!0,H}subtractFromFloats(E,H,d,n){return this.subtractFromFloatsToRef(E,H,d,n,new L)}subtractFromFloatsToRef(E,H,d,n,Z){return Z._x=this._x-E,Z._y=this._y-H,Z._z=this._z-d,Z._w=this._w-n,Z._isDirty=!0,Z}RH(E){return new L(this._x-E._x,this._y-E._y,this._z-E._z,this._w-E._w)}MM(E){return this._x-=E._x,this._y-=E._y,this._z-=E._z,this._w-=E._w,this._isDirty=!0,this}scale(E){return new L(this._x*E,this._y*E,this._z*E,this._w*E)}scaleToRef(E,H){return H._x=this._x*E,H._y=this._y*E,H._z=this._z*E,H._w=this._w*E,H._isDirty=!0,H}scaleInPlace(E){return this._x*=E,this._y*=E,this._z*=E,this._w*=E,this._isDirty=!0,this}scaleAndAddToRef(E,H){return H._x+=this._x*E,H._y+=this._y*E,H._z+=this._z*E,H._w+=this._w*E,H._isDirty=!0,H}multiply(E){const H=new L(0,0,0,1);return this.multiplyToRef(E,H),H}multiplyToRef(E,H){const d=this._x*E._w+this._y*E._z-this._z*E._y+this._w*E._x,n=-this._x*E._z+this._y*E._w+this._z*E._x+this._w*E._y,Z=this._x*E._y-this._y*E._x+this._z*E._w+this._w*E._z,I=-this._x*E._x-this._y*E._y-this._z*E._z+this._w*E._w;return H.en(d,n,Z,I),H}multiplyInPlace(E){return this.multiplyToRef(E,this)}multiplyByFloats(E,H,d,n){return this._x*=E,this._y*=H,this._z*=d,this._w*=n,this._isDirty=!0,this}divide(E){throw new ReferenceError("Can not divide a quaternion")}divideToRef(E,H){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(E){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new L)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(E){return E._x=-this._x,E._y=-this._y,E._z=-this._z,E._w=-this._w,E._isDirty=!0,E}equalsToFloats(E,H,d,n){return this._x===E&&this._y===H&&this._z===d&&this._w===n}floorToRef(E){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(E){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(E){return E.en(-this._x,-this._y,-this._z,this._w),E}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new L(-this._x,-this._y,-this._z,this._w)}invert(){const E=this.conjugate(),H=this.lengthSquared();return 0==H||1==H||E.scaleInPlace(1/H),E}invertInPlace(){this.conjugateInPlace();const E=this.lengthSquared();return 0==E||1==E||this.scaleInPlace(1/E),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(E){return 0===E||1===E?this:this.scaleInPlace(1/E)}normalizeToNew(){const E=new L(0,0,0,1);return this.normalizeToRef(E),E}normalizeToRef(E){const H=this.length();return 0===H||1===H?E.en(this._x,this._y,this._z,this._w):this.scaleToRef(1/H,E)}toEulerAngles(){const E=R.Zero();return this.toEulerAnglesToRef(E),E}toEulerAnglesToRef(E){const H=this._z,d=this._x,n=this._y,Z=this._w,I=n*H-d*Z,g=.4999999;if(I<-g)E._y=2*Math.atan2(n,Z),E._x=Math.PI/2,E._z=0,E._isDirty=!0;else if(I>g)E._y=2*Math.atan2(n,Z),E._x=-Math.PI/2,E._z=0,E._isDirty=!0;else{const g=Z*Z,l=H*H,r=d*d,t=n*n;E._z=Math.atan2(2*(d*n+H*Z),-l-r+t+g),E._x=Math.asin(-2*I),E._y=Math.atan2(2*(H*d+n*Z),l-r-t+g),E._isDirty=!0}return E}toAlphaBetaGammaToRef(E){const H=this._z,d=this._x,n=this._y,Z=this._w,I=Math.sqrt(d*d+n*n),g=Math.sqrt(H*H+Z*Z),l=2*Math.atan2(I,g),r=2*Math.atan2(H,Z),t=2*Math.atan2(n,d),S=(r+t)/2,M=(r-t)/2;return E.set(M,l,S),E}toRotationMatrix(E){return D.FromQuaternionToRef(this,E),E}fromRotationMatrix(E){return L.FromRotationMatrixToRef(E,this),this}dot(E){return this._x*E._x+this._y*E._y+this._z*E._z+this._w*E._w}toAxisAngle(){const E=R.Zero();return{axis:E,angle:this.toAxisAngleToRef(E)}}toAxisAngleToRef(E){let H=0;const d=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),n=this._w;return d>0?(H=2*Math.atan2(d,n),E.set(this._x/d,this._y/d,this._z/d)):(H=0,E.set(1,0,0)),H}static FromRotationMatrix(E){const H=new L;return L.FromRotationMatrixToRef(E,H),H}static FromRotationMatrixToRef(E,H){const d=E.m,n=d[0],Z=d[4],I=d[8],g=d[1],l=d[5],r=d[9],t=d[2],S=d[6],M=d[10],V=n+l+M;let C;return V>0?(C=.5/Math.sqrt(V+1),H._w=.25/C,H._x=(S-r)*C,H._y=(I-t)*C,H._z=(g-Z)*C,H._isDirty=!0):n>l&&n>M?(C=2*Math.sqrt(1+n-l-M),H._w=(S-r)/C,H._x=.25*C,H._y=(Z+g)/C,H._z=(I+t)/C,H._isDirty=!0):l>M?(C=2*Math.sqrt(1+l-n-M),H._w=(I-t)/C,H._x=(Z+g)/C,H._y=.25*C,H._z=(r+S)/C,H._isDirty=!0):(C=2*Math.sqrt(1+M-n-l),H._w=(g-Z)/C,H._x=(I+t)/C,H._y=(r+S)/C,H._z=.25*C,H._isDirty=!0),H}static Dot(E,H){return E._x*H._x+E._y*H._y+E._z*H._z+E._w*H._w}static AreClose(E,H){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const n=L.Dot(E,H);return 1-n*n<=d}static SmoothToRef(E,H,d,n,Z){let I=0===n?1:d/n;return I=(0,r.Clamp)(I,0,1),L.SlerpToRef(E,H,I,Z),Z}static Zero(){return new L(0,0,0,0)}static Inverse(E){return new L(-E._x,-E._y,-E._z,E._w)}static InverseToRef(E,H){return H.set(-E._x,-E._y,-E._z,E._w),H}static Identity(){return new L(0,0,0,1)}static IsIdentity(E){return E&&0===E._x&&0===E._y&&0===E._z&&1===E._w}static RotationAxis(E,H){return L.RotationAxisToRef(E,H,new L)}static RotationAxisToRef(E,H,d){d._w=Math.cos(H/2);const n=Math.sin(H/2)/E.length();return d._x=E._x*n,d._y=E._y*n,d._z=E._z*n,d._isDirty=!0,d}static eH(E,H){return H||(H=0),new L(E[H],E[H+1],E[H+2],E[H+3])}static FromArrayToRef(E,H,d){return d._x=E[H],d._y=E[H+1],d._z=E[H+2],d._w=E[H+3],d._isDirty=!0,d}static FromFloatsToRef(E,H,d,n,Z){return Z.en(E,H,d,n),Z}static FromEulerAngles(E,H,d){const n=new L;return L.RotationYawPitchRollToRef(H,E,d,n),n}static FromEulerAnglesToRef(E,H,d,n){return L.RotationYawPitchRollToRef(H,E,d,n),n}static FromEulerVector(E){const H=new L;return L.RotationYawPitchRollToRef(E._y,E._x,E._z,H),H}static FromEulerVectorToRef(E,H){return L.RotationYawPitchRollToRef(E._y,E._x,E._z,H),H}static FromUnitVectorsToRef(E,H,d){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n.c;const I=R.Dot(E,H)+1;return I<Z?Math.abs(E.x)>Math.abs(E.z)?d.set(-E.y,E.x,0,0):d.set(0,-E.z,E.y,0):(R.CrossToRef(E,H,s.wH[0]),d.set(s.wH[0].x,s.wH[0].y,s.wH[0].z,I)),d.normalize()}static RotationYawPitchRoll(E,H,d){const n=new L;return L.RotationYawPitchRollToRef(E,H,d,n),n}static RotationYawPitchRollToRef(E,H,d,n){const Z=.5*d,I=.5*H,g=.5*E,l=Math.sin(Z),r=Math.cos(Z),t=Math.sin(I),S=Math.cos(I),M=Math.sin(g),V=Math.cos(g);return n._x=V*t*r+M*S*l,n._y=M*S*r-V*t*l,n._z=V*S*l-M*t*r,n._w=V*S*r+M*t*l,n._isDirty=!0,n}static RotationAlphaBetaGamma(E,H,d){const n=new L;return L.RotationAlphaBetaGammaToRef(E,H,d,n),n}static RotationAlphaBetaGammaToRef(E,H,d,n){const Z=.5*(d+E),I=.5*(d-E),g=.5*H;return n._x=Math.cos(I)*Math.sin(g),n._y=Math.sin(I)*Math.sin(g),n._z=Math.sin(Z)*Math.cos(g),n._w=Math.cos(Z)*Math.cos(g),n._isDirty=!0,n}static RotationQuaternionFromAxis(E,H,d){const n=new L(0,0,0,0);return L.RotationQuaternionFromAxisToRef(E,H,d,n),n}static RotationQuaternionFromAxisToRef(E,H,d,n){const Z=e.Matrix[0];return E=E.normalizeToRef(e.wH[0]),H=H.normalizeToRef(e.wH[1]),d=d.normalizeToRef(e.wH[2]),D.FromXYZAxesToRef(E,H,d,Z),L.FromRotationMatrixToRef(Z,n),n}static FromLookDirectionLH(E,H){const d=new L;return L.FromLookDirectionLHToRef(E,H,d),d}static FromLookDirectionLHToRef(E,H,d){const n=e.Matrix[0];return D.LookDirectionLHToRef(E,H,n),L.FromRotationMatrixToRef(n,d),d}static FromLookDirectionRH(E,H){const d=new L;return L.FromLookDirectionRHToRef(E,H,d),d}static FromLookDirectionRHToRef(E,H,d){const n=e.Matrix[0];return D.LookDirectionRHToRef(E,H,n),L.FromRotationMatrixToRef(n,d)}static Slerp(E,H,d){const n=L.Identity();return L.SlerpToRef(E,H,d,n),n}static SlerpToRef(E,H,d,n){let Z,I,g=E._x*H._x+E._y*H._y+E._z*H._z+E._w*H._w,l=!1;if(g<0&&(l=!0,g=-g),g>.999999)I=1-d,Z=l?-d:d;else{const E=Math.acos(g),H=1/Math.sin(E);I=Math.sin((1-d)*E)*H,Z=l?-Math.sin(d*E)*H:Math.sin(d*E)*H}return n._x=I*E._x+Z*H._x,n._y=I*E._y+Z*H._y,n._z=I*E._z+Z*H._z,n._w=I*E._w+Z*H._w,n._isDirty=!0,n}static Hermite(E,H,d,n,Z){const I=Z*Z,g=Z*I,l=2*g-3*I+1,r=-2*g+3*I,t=g-2*I+Z,S=g-I,M=E._x*l+d._x*r+H._x*t+n._x*S,V=E._y*l+d._y*r+H._y*t+n._y*S,C=E._z*l+d._z*r+H._z*t+n._z*S,w=E._w*l+d._w*r+H._w*t+n._w*S;return new L(M,V,C,w)}static Hermite1stDerivative(E,H,d,n,Z){const I=new L;return this.Hermite1stDerivativeToRef(E,H,d,n,Z,I),I}static Hermite1stDerivativeToRef(E,H,d,n,Z,I){const g=Z*Z;return I._x=6*(g-Z)*E._x+(3*g-4*Z+1)*H._x+6*(-g+Z)*d._x+(3*g-2*Z)*n._x,I._y=6*(g-Z)*E._y+(3*g-4*Z+1)*H._y+6*(-g+Z)*d._y+(3*g-2*Z)*n._y,I._z=6*(g-Z)*E._z+(3*g-4*Z+1)*H._z+6*(-g+Z)*d._z+(3*g-2*Z)*n._z,I._w=6*(g-Z)*E._w+(3*g-4*Z+1)*H._w+6*(-g+Z)*d._w+(3*g-2*Z)*n._w,I._isDirty=!0,I}static Normalize(E){const H=L.Zero();return L.NormalizeToRef(E,H),H}static NormalizeToRef(E,H){return E.normalizeToRef(H),H}static Clamp(E,H,d){const n=new L;return L.ClampToRef(E,H,d,n),n}static ClampToRef(E,H,d,n){return n.en((0,r.Clamp)(E.x,H.x,d.x),(0,r.Clamp)(E.y,H.y,d.y),(0,r.Clamp)(E.z,H.z,d.z),(0,r.Clamp)(E.w,H.w,d.w))}static Random(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new L((0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H))}static RandomToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).en((0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H),(0,r.RandomRange)(E,H))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(E,H){return Math.sqrt(L.DistanceSquared(E,H))}static DistanceSquared(E,H){const d=E.x-H.x,n=E.y-H.y,Z=E.z-H.z,I=E.w-H.w;return d*d+n*n+Z*Z+I*I}static Center(E,H){return L.CenterToRef(E,H,L.Zero())}static CenterToRef(E,H,d){return d.en((E.x+H.x)/2,(E.y+H.y)/2,(E.z+H.z)/2,(E.w+H.w)/2)}}L._V8PerformanceHack=new L(.5,.5,.5,.5),Object.defineProperties(L.prototype,{dimension:{value:[4]},rank:{value:1}});class D{static get Use64Bits(){return g.b.MatrixUse64Bits}get m(){return this.sd}markAsUpdated(){this.updateFlag=t._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(E){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],d=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=E,this._isIdentity3x2=E||d,this._isIdentityDirty=!this._isIdentity&&H,this._isIdentity3x2Dirty=!this._isIdentity3x2&&n}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,g.b.MatrixTrackPrecisionChange&&g.b.MatrixTrackedMatrices.push(this),this.sd=new g.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const E=this.sd;this._isIdentity=1===E[0]&&0===E[1]&&0===E[2]&&0===E[3]&&0===E[4]&&1===E[5]&&0===E[6]&&0===E[7]&&0===E[8]&&0===E[9]&&1===E[10]&&0===E[11]&&0===E[12]&&0===E[13]&&0===E[14]&&1===E[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.sd[0]||1!==this.sd[5]||1!==this.sd[15]||0!==this.sd[1]||0!==this.sd[2]||0!==this.sd[3]||0!==this.sd[4]||0!==this.sd[6]||0!==this.sd[7]||0!==this.sd[8]||0!==this.sd[9]||0!==this.sd[10]||0!==this.sd[11]||0!==this.sd[12]||0!==this.sd[13]||0!==this.sd[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const E=this.sd,H=E[0],d=E[1],n=E[2],Z=E[3],I=E[4],g=E[5],l=E[6],r=E[7],t=E[8],S=E[9],M=E[10],V=E[11],C=E[12],w=E[13],R=E[14],Q=E[15],L=M*Q-R*V,D=S*Q-w*V,e=S*R-w*M,s=t*Q-C*V,i=t*R-M*C,p=t*w-C*S;return H*+(g*L-l*D+r*e)+d*-(I*L-l*s+r*i)+n*+(I*D-g*s+r*p)+Z*-(I*e-g*i+l*p)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!E)return this.sd;const d=this.sd;for(let n=0;n<16;n++)E[H+n]=d[n];return this}kd(){return this.sd}Xd(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D.FromArrayToRef(E,H,this)}en(){for(var E=arguments.length,H=new Array(E),d=0;d<E;d++)H[d]=arguments[d];return D.FromArrayToRef(H,0,this)}set(){const E=this.sd;for(let H=0;H<16;H++)E[H]=H<0||arguments.length<=H?void 0:arguments[H];return this.markAsUpdated(),this}ng(E){const H=this.sd;for(let d=0;d<16;d++)H[d]=E;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return D.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(E){const H=new D;return this.addToRef(E,H),H}addToRef(E,H){const d=this.sd,n=H.sd,Z=E.m;for(let I=0;I<16;I++)n[I]=d[I]+Z[I];return H.markAsUpdated(),H}addToSelf(E){const H=this.sd,d=E.m;return H[0]+=d[0],H[1]+=d[1],H[2]+=d[2],H[3]+=d[3],H[4]+=d[4],H[5]+=d[5],H[6]+=d[6],H[7]+=d[7],H[8]+=d[8],H[9]+=d[9],H[10]+=d[10],H[11]+=d[11],H[12]+=d[12],H[13]+=d[13],H[14]+=d[14],H[15]+=d[15],this.markAsUpdated(),this}addInPlace(E){const H=this.sd,d=E.m;for(let n=0;n<16;n++)H[n]+=d[n];return this.markAsUpdated(),this}addInPlaceFromFloats(){const E=this.sd;for(let H=0;H<16;H++)E[H]+=H<0||arguments.length<=H?void 0:arguments[H];return this.markAsUpdated(),this}RH(E){const H=this.sd,d=E.m;for(let n=0;n<16;n++)H[n]-=d[n];return this.markAsUpdated(),this}subtractToRef(E,H){const d=this.sd,n=E.m,Z=H.sd;for(let I=0;I<16;I++)Z[I]=d[I]-n[I];return H.markAsUpdated(),H}MM(E){const H=this.sd,d=E.m;for(let n=0;n<16;n++)H[n]-=d[n];return this.markAsUpdated(),this}subtractFromFloats(){for(var E=arguments.length,H=new Array(E),d=0;d<E;d++)H[d]=arguments[d];return this.subtractFromFloatsToRef(...H,new D)}subtractFromFloatsToRef(){for(var E=arguments.length,H=new Array(E),d=0;d<E;d++)H[d]=arguments[d];const n=H.pop(),Z=this.sd,I=n.sd,g=H;for(let l=0;l<16;l++)I[l]=Z[l]-g[l];return n.markAsUpdated(),n}invertToRef(E){return!0===this._isIdentity?(D.IdentityToRef(E),E):(V(this,E.kd())?E.markAsUpdated():E.l(this),E)}addAtIndex(E,H){return this.sd[E]+=H,this.markAsUpdated(),this}multiplyAtIndex(E,H){return this.sd[E]*=H,this.markAsUpdated(),this}setTranslationFromFloats(E,H,d){return this.sd[12]=E,this.sd[13]=H,this.sd[14]=d,this.markAsUpdated(),this}addTranslationFromFloats(E,H,d){return this.sd[12]+=E,this.sd[13]+=H,this.sd[14]+=d,this.markAsUpdated(),this}setTranslation(E){return this.setTranslationFromFloats(E._x,E._y,E._z)}getTranslation(){return new R(this.sd[12],this.sd[13],this.sd[14])}getTranslationToRef(E){return E.x=this.sd[12],E.y=this.sd[13],E.z=this.sd[14],E}removeRotationAndScaling(){const E=this.m;return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,E[12],E[13],E[14],E[15],this),this._updateIdentityStatus(0===E[12]&&0===E[13]&&0===E[14]&&1===E[15]),this}l(E){E.copyToArray(this.sd);const H=E;return this.updateFlag=H.updateFlag,this._updateIdentityStatus(H._isIdentity,H._isIdentityDirty,H._isIdentity3x2,H._isIdentity3x2Dirty),this}copyToArray(E){return M(this,E,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(E){const H=new D;return this.multiplyToRef(E,H),H}multiplyInPlace(E){const H=this.sd,d=E.m;for(let n=0;n<16;n++)H[n]*=d[n];return this.markAsUpdated(),this}multiplyByFloats(){const E=this.sd;for(let H=0;H<16;H++)E[H]*=H<0||arguments.length<=H?void 0:arguments[H];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var E=arguments.length,H=new Array(E),d=0;d<E;d++)H[d]=arguments[d];const n=H.pop(),Z=this.sd,I=n.sd,g=H;for(let l=0;l<16;l++)I[l]=Z[l]*g[l];return n.markAsUpdated(),n}multiplyToRef(E,H){return this._isIdentity?(H.l(E),H):E._isIdentity?(H.l(this),H):(this.multiplyToArray(E,H.sd,0),H.markAsUpdated(),H)}multiplyToArray(E,H,d){return S(this,E,H,d),this}divide(E){return this.divideToRef(E,new D)}divideToRef(E,H){const d=this.sd,n=E.m,Z=H.sd;for(let I=0;I<16;I++)Z[I]=d[I]/n[I];return H.markAsUpdated(),H}divideInPlace(E){const H=this.sd,d=E.m;for(let n=0;n<16;n++)H[n]/=d[n];return this.markAsUpdated(),this}minimizeInPlace(E){const H=this.sd,d=E.m;for(let n=0;n<16;n++)H[n]=Math.min(H[n],d[n]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const E=this.sd;for(let H=0;H<16;H++)E[H]=Math.min(E[H],H<0||arguments.length<=H?void 0:arguments[H]);return this.markAsUpdated(),this}maximizeInPlace(E){const H=this.sd,d=E.m;for(let n=0;n<16;n++)H[n]=Math.min(H[n],d[n]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const E=this.sd;for(let H=0;H<16;H++)E[H]=Math.min(E[H],H<0||arguments.length<=H?void 0:arguments[H]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new D)}negateInPlace(){const E=this.sd;for(let H=0;H<16;H++)E[H]=-E[H];return this.markAsUpdated(),this}negateToRef(E){const H=this.sd,d=E.sd;for(let n=0;n<16;n++)d[n]=-H[n];return E.markAsUpdated(),E}equals(E){const H=E;if(!H)return!1;if((this._isIdentity||H._isIdentity)&&!this._isIdentityDirty&&!H._isIdentityDirty)return this._isIdentity&&H._isIdentity;const d=this.m,n=H.m;return d[0]===n[0]&&d[1]===n[1]&&d[2]===n[2]&&d[3]===n[3]&&d[4]===n[4]&&d[5]===n[5]&&d[6]===n[6]&&d[7]===n[7]&&d[8]===n[8]&&d[9]===n[9]&&d[10]===n[10]&&d[11]===n[11]&&d[12]===n[12]&&d[13]===n[13]&&d[14]===n[14]&&d[15]===n[15]}equalsWithEpsilon(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const d=this.sd,n=E.m;for(let Z=0;Z<16;Z++)if(!(0,r.WithinEpsilon)(d[Z],n[Z],H))return!1;return!0}equalsToFloats(){const E=this.sd;for(let H=0;H<16;H++)if(E[H]!=(H<0||arguments.length<=H?void 0:arguments[H]))return!1;return!0}floor(){return this.floorToRef(new D)}floorToRef(E){const H=this.sd,d=E.sd;for(let n=0;n<16;n++)d[n]=Math.floor(H[n]);return E.markAsUpdated(),E}fract(){return this.fractToRef(new D)}fractToRef(E){const H=this.sd,d=E.sd;for(let n=0;n<16;n++)d[n]=H[n]-Math.floor(H[n]);return E.markAsUpdated(),E}clone(){const E=new D;return E.l(this),E}getClassName(){return"Matrix"}getHashCode(){let E=C(this.sd[0]);for(let H=1;H<16;H++)E=397*E^C(this.sd[H]);return E}decomposeToTransformNode(E){return E.rotationQuaternion=E.rotationQuaternion||new L,this.decompose(E.mg,E.rotationQuaternion,E.position)}decompose(E,H,d,n){let Z=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return d&&d.ng(0),E&&E.ng(1),H&&H.en(0,0,0,1),!0;const I=this.sd;if(d&&d.en(I[12],I[13],I[14]),(E=E||e.wH[0]).x=Math.sqrt(I[0]*I[0]+I[1]*I[1]+I[2]*I[2]),E.y=Math.sqrt(I[4]*I[4]+I[5]*I[5]+I[6]*I[6]),E.z=Math.sqrt(I[8]*I[8]+I[9]*I[9]+I[10]*I[10]),n){const H=(Z?n.absoluteScaling.x:n.mg.x)<0?-1:1,d=(Z?n.absoluteScaling.y:n.mg.y)<0?-1:1,I=(Z?n.absoluteScaling.z:n.mg.z)<0?-1:1;E.x*=H,E.y*=d,E.z*=I}else this.determinant()<=0&&(E.y*=-1);if(0===E._x||0===E._y||0===E._z)return H&&H.en(0,0,0,1),!1;if(H){const d=1/E._x,n=1/E._y,Z=1/E._z;D.FromValuesToRef(I[0]*d,I[1]*d,I[2]*d,0,I[4]*n,I[5]*n,I[6]*n,0,I[8]*Z,I[9]*Z,I[10]*Z,0,0,0,0,1,e.Matrix[0]),L.FromRotationMatrixToRef(e.Matrix[0],H)}return!0}getRow(E){if(E<0||E>3)return null;const H=4*E;return new Q(this.sd[H+0],this.sd[H+1],this.sd[H+2],this.sd[H+3])}getRowToRef(E,H){if(E>=0&&E<=3){const d=4*E;H.x=this.sd[d+0],H.y=this.sd[d+1],H.z=this.sd[d+2],H.w=this.sd[d+3]}return H}setRow(E,H){return this.setRowFromFloats(E,H.x,H.y,H.z,H.w)}transpose(){const E=new D;return D.TransposeToRef(this,E),E}transposeToRef(E){return D.TransposeToRef(this,E),E}setRowFromFloats(E,H,d,n,Z){if(E<0||E>3)return this;const I=4*E;return this.sd[I+0]=H,this.sd[I+1]=d,this.sd[I+2]=n,this.sd[I+3]=Z,this.markAsUpdated(),this}scale(E){const H=new D;return this.scaleToRef(E,H),H}scaleToRef(E,H){for(let d=0;d<16;d++)H.sd[d]=this.sd[d]*E;return H.markAsUpdated(),H}scaleAndAddToRef(E,H){for(let d=0;d<16;d++)H.sd[d]+=this.sd[d]*E;return H.markAsUpdated(),H}scaleInPlace(E){const H=this.sd;for(let d=0;d<16;d++)H[d]*=E;return this.markAsUpdated(),this}toNormalMatrix(E){const H=e.Matrix[0];this.invertToRef(H),H.transposeToRef(E);const d=E.sd;return D.FromValuesToRef(d[0],d[1],d[2],0,d[4],d[5],d[6],0,d[8],d[9],d[10],0,0,0,0,1,E),E}getRotationMatrix(){const E=new D;return this.getRotationMatrixToRef(E),E}getRotationMatrixToRef(E){const H=e.wH[0];if(!this.decompose(H))return D.IdentityToRef(E),E;const d=this.sd,n=1/H._x,Z=1/H._y,I=1/H._z;return D.FromValuesToRef(d[0]*n,d[1]*n,d[2]*n,0,d[4]*Z,d[5]*Z,d[6]*Z,0,d[8]*I,d[9]*I,d[10]*I,0,0,0,0,1,E),E}toggleModelMatrixHandInPlace(){const E=this.sd;return E[2]*=-1,E[6]*=-1,E[8]*=-1,E[9]*=-1,E[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const E=this.sd;return E[8]*=-1,E[9]*=-1,E[10]*=-1,E[11]*=-1,this.markAsUpdated(),this}static eH(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const d=new D;return D.FromArrayToRef(E,H,d),d}static FromArrayToRef(E,H,d){for(let n=0;n<16;n++)d.sd[n]=E[n+H];return d.markAsUpdated(),d}static FromFloat32ArrayToRefScaled(E,H,d,n){return n.sd[0]=E[0+H]*d,n.sd[1]=E[1+H]*d,n.sd[2]=E[2+H]*d,n.sd[3]=E[3+H]*d,n.sd[4]=E[4+H]*d,n.sd[5]=E[5+H]*d,n.sd[6]=E[6+H]*d,n.sd[7]=E[7+H]*d,n.sd[8]=E[8+H]*d,n.sd[9]=E[9+H]*d,n.sd[10]=E[10+H]*d,n.sd[11]=E[11+H]*d,n.sd[12]=E[12+H]*d,n.sd[13]=E[13+H]*d,n.sd[14]=E[14+H]*d,n.sd[15]=E[15+H]*d,n.markAsUpdated(),n}static get IdentityReadOnly(){return D._IdentityReadOnly}static FromValuesToRef(E,H,d,n,Z,I,g,l,r,t,S,M,V,C,w,R,Q){const L=Q.sd;L[0]=E,L[1]=H,L[2]=d,L[3]=n,L[4]=Z,L[5]=I,L[6]=g,L[7]=l,L[8]=r,L[9]=t,L[10]=S,L[11]=M,L[12]=V,L[13]=C,L[14]=w,L[15]=R,Q.markAsUpdated()}static FromValues(E,H,d,n,Z,I,g,l,r,t,S,M,V,C,w,R){const Q=new D,L=Q.sd;return L[0]=E,L[1]=H,L[2]=d,L[3]=n,L[4]=Z,L[5]=I,L[6]=g,L[7]=l,L[8]=r,L[9]=t,L[10]=S,L[11]=M,L[12]=V,L[13]=C,L[14]=w,L[15]=R,Q.markAsUpdated(),Q}static Compose(E,H,d){const n=new D;return D.ComposeToRef(E,H,d,n),n}static ComposeToRef(E,H,d,n){const Z=n.sd,I=H._x,g=H._y,l=H._z,r=H._w,t=I+I,S=g+g,M=l+l,V=I*t,C=I*S,w=I*M,R=g*S,Q=g*M,L=l*M,D=r*t,e=r*S,s=r*M,i=E._x,p=E._y,f=E._z;return Z[0]=(1-(R+L))*i,Z[1]=(C+s)*i,Z[2]=(w-e)*i,Z[3]=0,Z[4]=(C-s)*p,Z[5]=(1-(V+L))*p,Z[6]=(Q+D)*p,Z[7]=0,Z[8]=(w+e)*f,Z[9]=(Q-D)*f,Z[10]=(1-(V+R))*f,Z[11]=0,Z[12]=d._x,Z[13]=d._y,Z[14]=d._z,Z[15]=1,n.markAsUpdated(),n}static Identity(){const E=D.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return E._updateIdentityStatus(!0),E}static IdentityToRef(E){return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,E),E._updateIdentityStatus(!0),E}static Zero(){const E=D.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return E._updateIdentityStatus(!1),E}static RotationX(E){const H=new D;return D.RotationXToRef(E,H),H}static Invert(E){const H=new D;return E.invertToRef(H),H}static RotationXToRef(E,H){const d=Math.sin(E),n=Math.cos(E);return D.FromValuesToRef(1,0,0,0,0,n,d,0,0,-d,n,0,0,0,0,1,H),H._updateIdentityStatus(1===n&&0===d),H}static RotationY(E){const H=new D;return D.RotationYToRef(E,H),H}static RotationYToRef(E,H){const d=Math.sin(E),n=Math.cos(E);return D.FromValuesToRef(n,0,-d,0,0,1,0,0,d,0,n,0,0,0,0,1,H),H._updateIdentityStatus(1===n&&0===d),H}static RotationZ(E){const H=new D;return D.RotationZToRef(E,H),H}static RotationZToRef(E,H){const d=Math.sin(E),n=Math.cos(E);return D.FromValuesToRef(n,d,0,0,-d,n,0,0,0,0,1,0,0,0,0,1,H),H._updateIdentityStatus(1===n&&0===d),H}static RotationAxis(E,H){const d=new D;return D.RotationAxisToRef(E,H,d),d}static RotationAxisToRef(E,H,d){const n=Math.sin(-H),Z=Math.cos(-H),I=1-Z;E=E.normalizeToRef(e.wH[0]);const g=d.sd;return g[0]=E._x*E._x*I+Z,g[1]=E._x*E._y*I-E._z*n,g[2]=E._x*E._z*I+E._y*n,g[3]=0,g[4]=E._y*E._x*I+E._z*n,g[5]=E._y*E._y*I+Z,g[6]=E._y*E._z*I-E._x*n,g[7]=0,g[8]=E._z*E._x*I-E._y*n,g[9]=E._z*E._y*I+E._x*n,g[10]=E._z*E._z*I+Z,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,d.markAsUpdated(),d}static RotationAlignToRef(E,H,d){let Z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const I=R.Dot(H,E),g=d.sd;if(I<-1+n.c)g[0]=-1,g[1]=0,g[2]=0,g[3]=0,g[4]=0,g[5]=Z?1:-1,g[6]=0,g[7]=0,g[8]=0,g[9]=0,g[10]=Z?-1:1,g[11]=0;else{const d=R.Cross(H,E),n=1/(1+I);g[0]=d._x*d._x*n+I,g[1]=d._y*d._x*n-d._z,g[2]=d._z*d._x*n+d._y,g[3]=0,g[4]=d._x*d._y*n+d._z,g[5]=d._y*d._y*n+I,g[6]=d._z*d._y*n-d._x,g[7]=0,g[8]=d._x*d._z*n-d._y,g[9]=d._y*d._z*n+d._x,g[10]=d._z*d._z*n+I,g[11]=0}return g[12]=0,g[13]=0,g[14]=0,g[15]=1,d.markAsUpdated(),d}static RotationYawPitchRoll(E,H,d){const n=new D;return D.RotationYawPitchRollToRef(E,H,d,n),n}static RotationYawPitchRollToRef(E,H,d,n){return L.RotationYawPitchRollToRef(E,H,d,e.Quaternion[0]),e.Quaternion[0].toRotationMatrix(n),n}static Scaling(E,H,d){const n=new D;return D.ScalingToRef(E,H,d,n),n}static ScalingToRef(E,H,d,n){return D.FromValuesToRef(E,0,0,0,0,H,0,0,0,0,d,0,0,0,0,1,n),n._updateIdentityStatus(1===E&&1===H&&1===d),n}static Translation(E,H,d){const n=new D;return D.TranslationToRef(E,H,d,n),n}static TranslationToRef(E,H,d,n){return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,E,H,d,1,n),n._updateIdentityStatus(0===E&&0===H&&0===d),n}static Lerp(E,H,d){const n=new D;return D.LerpToRef(E,H,d,n),n}static LerpToRef(E,H,d,n){const Z=n.sd,I=E.m,g=H.m;for(let l=0;l<16;l++)Z[l]=I[l]*(1-d)+g[l]*d;return n.markAsUpdated(),n}static DecomposeLerp(E,H,d){const n=new D;return D.DecomposeLerpToRef(E,H,d,n),n}static DecomposeLerpToRef(E,H,d,n){const Z=e.wH[0],I=e.Quaternion[0],g=e.wH[1];E.decompose(Z,I,g);const l=e.wH[2],r=e.Quaternion[1],t=e.wH[3];H.decompose(l,r,t);const S=e.wH[4];R.LerpToRef(Z,l,d,S);const M=e.Quaternion[2];L.SlerpToRef(I,r,d,M);const V=e.wH[5];return R.LerpToRef(g,t,d,V),D.ComposeToRef(S,M,V,n),n}static LookAtLH(E,H,d){const n=new D;return D.LookAtLHToRef(E,H,d,n),n}static LookAtLHToRef(E,H,d,n){const Z=e.wH[0],I=e.wH[1],g=e.wH[2];H.subtractToRef(E,g),g.normalize(),R.CrossToRef(d,g,Z);const l=Z.lengthSquared();0===l?Z.x=1:Z.normalizeFromLength(Math.sqrt(l)),R.CrossToRef(g,Z,I),I.normalize();const r=-R.Dot(Z,E),t=-R.Dot(I,E),S=-R.Dot(g,E);return D.FromValuesToRef(Z._x,I._x,g._x,0,Z._y,I._y,g._y,0,Z._z,I._z,g._z,0,r,t,S,1,n),n}static LookAtRH(E,H,d){const n=new D;return D.LookAtRHToRef(E,H,d,n),n}static LookAtRHToRef(E,H,d,n){const Z=e.wH[0],I=e.wH[1],g=e.wH[2];E.subtractToRef(H,g),g.normalize(),R.CrossToRef(d,g,Z);const l=Z.lengthSquared();0===l?Z.x=1:Z.normalizeFromLength(Math.sqrt(l)),R.CrossToRef(g,Z,I),I.normalize();const r=-R.Dot(Z,E),t=-R.Dot(I,E),S=-R.Dot(g,E);return D.FromValuesToRef(Z._x,I._x,g._x,0,Z._y,I._y,g._y,0,Z._z,I._z,g._z,0,r,t,S,1,n),n}static LookDirectionLH(E,H){const d=new D;return D.LookDirectionLHToRef(E,H,d),d}static LookDirectionLHToRef(E,H,d){const n=e.wH[0];n.l(E),n.scaleInPlace(-1);const Z=e.wH[1];return R.CrossToRef(H,n,Z),D.FromValuesToRef(Z._x,Z._y,Z._z,0,H._x,H._y,H._z,0,n._x,n._y,n._z,0,0,0,0,1,d),d}static LookDirectionRH(E,H){const d=new D;return D.LookDirectionRHToRef(E,H,d),d}static LookDirectionRHToRef(E,H,d){const n=e.wH[2];return R.CrossToRef(H,E,n),D.FromValuesToRef(n._x,n._y,n._z,0,H._x,H._y,H._z,0,E._x,E._y,E._z,0,0,0,0,1,d),d}static OrthoLH(E,H,d,n,Z){const I=new D;return D.OrthoLHToRef(E,H,d,n,I,Z),I}static OrthoLHToRef(E,H,d,n,Z,I){const g=2/E,l=2/H,r=2/(n-d),t=-(n+d)/(n-d);return D.FromValuesToRef(g,0,0,0,0,l,0,0,0,0,r,0,0,0,t,1,Z),I&&Z.multiplyToRef(i,Z),Z._updateIdentityStatus(1===g&&1===l&&1===r&&0===t),Z}static OrthoOffCenterLH(E,H,d,n,Z,I,g){const l=new D;return D.OrthoOffCenterLHToRef(E,H,d,n,Z,I,l,g),l}static OrthoOffCenterLHToRef(E,H,d,n,Z,I,g,l){const r=2/(H-E),t=2/(n-d),S=2/(I-Z),M=-(I+Z)/(I-Z),V=(E+H)/(E-H),C=(n+d)/(d-n);return D.FromValuesToRef(r,0,0,0,0,t,0,0,0,0,S,0,V,C,M,1,g),l&&g.multiplyToRef(i,g),g.markAsUpdated(),g}static ObliqueOffCenterLHToRef(E,H,d,n,Z,I,g,l,r,t,S){const M=-g*Math.cos(l),V=-g*Math.sin(l);return D.TranslationToRef(0,0,-r,e.Matrix[1]),D.FromValuesToRef(1,0,0,0,0,1,0,0,M,V,1,0,0,0,0,1,e.Matrix[0]),e.Matrix[1].multiplyToRef(e.Matrix[0],e.Matrix[0]),D.TranslationToRef(0,0,r,e.Matrix[1]),e.Matrix[0].multiplyToRef(e.Matrix[1],e.Matrix[0]),D.OrthoOffCenterLHToRef(E,H,d,n,Z,I,t,S),e.Matrix[0].multiplyToRef(t,t),t}static OrthoOffCenterRH(E,H,d,n,Z,I,g){const l=new D;return D.OrthoOffCenterRHToRef(E,H,d,n,Z,I,l,g),l}static OrthoOffCenterRHToRef(E,H,d,n,Z,I,g,l){return D.OrthoOffCenterLHToRef(E,H,d,n,Z,I,g,l),g.sd[10]*=-1,g}static ObliqueOffCenterRHToRef(E,H,d,n,Z,I,g,l,r,t,S){const M=g*Math.cos(l),V=g*Math.sin(l);return D.TranslationToRef(0,0,r,e.Matrix[1]),D.FromValuesToRef(1,0,0,0,0,1,0,0,M,V,1,0,0,0,0,1,e.Matrix[0]),e.Matrix[1].multiplyToRef(e.Matrix[0],e.Matrix[0]),D.TranslationToRef(0,0,-r,e.Matrix[1]),e.Matrix[0].multiplyToRef(e.Matrix[1],e.Matrix[0]),D.OrthoOffCenterRHToRef(E,H,d,n,Z,I,t,S),e.Matrix[0].multiplyToRef(t,t),t}static PerspectiveLH(E,H,d,n,Z){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const g=new D,l=2*d/E,r=2*d/H,t=(n+d)/(n-d),S=-2*n*d/(n-d),M=Math.tan(I);return D.FromValuesToRef(l,0,0,0,0,r,0,M,0,0,t,1,0,0,S,0,g),Z&&g.multiplyToRef(i,g),g._updateIdentityStatus(!1),g}static PerspectiveFovLH(E,H,d,n,Z){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const l=new D;return D.PerspectiveFovLHToRef(E,H,d,n,l,!0,Z,I,g),l}static PerspectiveFovLHToRef(E,H,d,n,Z){let I=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,r=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const t=d,S=n,M=1/Math.tan(.5*E),V=I?M/H:M,C=I?M:M*H,w=r&&0===t?-1:0!==S?(S+t)/(S-t):1,R=r&&0===t?2*S:0!==S?-2*S*t/(S-t):-2*t,Q=Math.tan(l);return D.FromValuesToRef(V,0,0,0,0,C,0,Q,0,0,w,1,0,0,R,0,Z),g&&Z.multiplyToRef(i,Z),Z._updateIdentityStatus(!1),Z}static PerspectiveFovReverseLHToRef(E,H,d,n,Z){let I=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const r=1/Math.tan(.5*E),t=I?r/H:r,S=I?r:r*H,M=Math.tan(l);return D.FromValuesToRef(t,0,0,0,0,S,0,M,0,0,-d,1,0,0,1,0,Z),g&&Z.multiplyToRef(i,Z),Z._updateIdentityStatus(!1),Z}static PerspectiveFovRH(E,H,d,n,Z){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const l=new D;return D.PerspectiveFovRHToRef(E,H,d,n,l,!0,Z,I,g),l}static PerspectiveFovRHToRef(E,H,d,n,Z){let I=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,r=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const t=d,S=n,M=1/Math.tan(.5*E),V=I?M/H:M,C=I?M:M*H,w=r&&0===t?1:0!==S?-(S+t)/(S-t):-1,R=r&&0===t?2*S:0!==S?-2*S*t/(S-t):-2*t,Q=Math.tan(l);return D.FromValuesToRef(V,0,0,0,0,C,0,Q,0,0,w,-1,0,0,R,0,Z),g&&Z.multiplyToRef(i,Z),Z._updateIdentityStatus(!1),Z}static PerspectiveFovReverseRHToRef(E,H,d,n,Z){let I=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],g=arguments.length>6?arguments[6]:void 0,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const r=1/Math.tan(.5*E),t=I?r/H:r,S=I?r:r*H,M=Math.tan(l);return D.FromValuesToRef(t,0,0,0,0,S,0,M,0,0,-d,-1,0,0,-1,0,Z),g&&Z.multiplyToRef(i,Z),Z._updateIdentityStatus(!1),Z}static GetFinalMatrix(E,H,d,n,Z,I){const g=E.width,l=E.height,r=E.x,t=E.y,S=D.FromValues(g/2,0,0,0,0,-l/2,0,0,0,0,I-Z,0,r+g/2,l/2+t,Z,1),M=new D;return H.multiplyToRef(d,M),M.multiplyToRef(n,M),M.multiplyToRef(S,M)}static GetAsMatrix2x2(E){const H=E.m,d=[H[0],H[1],H[4],H[5]];return g.b.MatrixUse64Bits?d:new Float32Array(d)}static GetAsMatrix3x3(E){const H=E.m,d=[H[0],H[1],H[2],H[4],H[5],H[6],H[8],H[9],H[10]];return g.b.MatrixUse64Bits?d:new Float32Array(d)}static Transpose(E){const H=new D;return D.TransposeToRef(E,H),H}static TransposeToRef(E,H){const d=E.m,n=d[0],Z=d[4],I=d[8],g=d[12],l=d[1],r=d[5],t=d[9],S=d[13],M=d[2],V=d[6],C=d[10],w=d[14],R=d[3],Q=d[7],L=d[11],D=d[15],e=H.sd;return e[0]=n,e[1]=Z,e[2]=I,e[3]=g,e[4]=l,e[5]=r,e[6]=t,e[7]=S,e[8]=M,e[9]=V,e[10]=C,e[11]=w,e[12]=R,e[13]=Q,e[14]=L,e[15]=D,H.markAsUpdated(),H._updateIdentityStatus(E._isIdentity,E._isIdentityDirty),H}static Reflection(E){const H=new D;return D.ReflectionToRef(E,H),H}static ReflectionToRef(E,H){E.normalize();const d=E.normal.x,n=E.normal.y,Z=E.normal.z,I=-2*d,g=-2*n,l=-2*Z;return D.FromValuesToRef(I*d+1,g*d,l*d,0,I*n,g*n+1,l*n,0,I*Z,g*Z,l*Z+1,0,I*E.d,g*E.d,l*E.d,1,H),H}static FromXYZAxesToRef(E,H,d,n){return D.FromValuesToRef(E._x,E._y,E._z,0,H._x,H._y,H._z,0,d._x,d._y,d._z,0,0,0,0,1,n),n}static FromQuaternionToRef(E,H){const d=E._x*E._x,n=E._y*E._y,Z=E._z*E._z,I=E._x*E._y,g=E._z*E._w,l=E._z*E._x,r=E._y*E._w,t=E._y*E._z,S=E._x*E._w;return H.sd[0]=1-2*(n+Z),H.sd[1]=2*(I+g),H.sd[2]=2*(l-r),H.sd[3]=0,H.sd[4]=2*(I-g),H.sd[5]=1-2*(Z+d),H.sd[6]=2*(t+S),H.sd[7]=0,H.sd[8]=2*(l+r),H.sd[9]=2*(t-S),H.sd[10]=1-2*(n+d),H.sd[11]=0,H.sd[12]=0,H.sd[13]=0,H.sd[14]=0,H.sd[15]=1,H.markAsUpdated(),H}}D._IdentityReadOnly=D.Identity(),Object.defineProperties(D.prototype,{dimension:{value:[4,4]},rank:{value:2}});class e{}e.wH=(0,Z.f)(11,R.Zero),e.Matrix=(0,Z.f)(2,D.Identity),e.Quaternion=(0,Z.f)(3,L.Zero);class s{}s.Vector2=(0,Z.f)(3,w.Zero),s.wH=(0,Z.f)(13,R.Zero),s.Vector4=(0,Z.f)(3,Q.Zero),s.Quaternion=(0,Z.f)(3,L.Zero),s.Matrix=(0,Z.f)(8,D.Identity),(0,I.e)("BABYLON.Vector2",w),(0,I.e)("BABYLON.Vector3",R),(0,I.e)("BABYLON.Vector4",Q),(0,I.e)("BABYLON.Matrix",D);const i=D.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12399:(E,H,d)=>{function n(E,H){const d=[];for(let n=0;n<E;++n)d.push(H());return d}function Z(E,H){return n(E,H)}d.d(H,{e:()=>n,f:()=>Z,h:()=>g});const I=["push","splice","pop","shift","unshift"];function g(E,H){const d=I.map((d=>function(E,H,d){const n=E[H];if("function"!==typeof n)return null;const Z=function(){const n=E.length,I=Z.previous.apply(E,arguments);return d(H,n),I};return n.next=Z,Z.previous=n,E[H]=Z,()=>{const d=Z.previous;if(!d)return;const n=Z.next;n?(d.next=n,n.previous=d):(d.next=void 0,E[H]=d),Z.next=void 0,Z.previous=void 0}}(E,d,H)));return()=>{for(const E of d)null===E||void 0===E||E()}}}}]);