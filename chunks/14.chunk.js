"use strict";(self.wy695la1oic=self.wy695la1oic||[]).push([[14],{11377:(S,v,D)=>{D.d(v,{e:()=>m,f:()=>N,i:()=>z,m:()=>e});const z=1/2.2,e=2.2,N=(1+Math.sqrt(5))/2,m=.001},11393:(S,v,D)=>{function z(S){return parseInt(S.toString().replace(/\W/g,""))}function e(S,v){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(S-v)<=D}function N(S,v,D){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return S<v-z||S>D+z}function m(S,v){return S===v?S:Math.random()*(v-S)+S}function B(S,v,D){return S+(v-S)*D}function g(S,v,D){let z=I(v-S,360);return z>180&&(z-=360),S+z*w(D)}function E(S,v,D){let z=0;return z=S!=v?w((D-S)/(v-S)):0,z}function h(S,v,D,z,e){const N=e*e,m=e*N;return S*(2*m-3*N+1)+D*(-2*m+3*N)+v*(m-2*N+e)+z*(m-N)}function A(S,v,D,z,e){const N=e*e;return 6*(N-e)*S+(3*N-4*e+1)*v+6*(-N+e)*D+(3*N-2*e)*z}function w(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(D,Math.max(v,S))}function n(S){return S-=2*Math.PI*Math.floor((S+Math.PI)/(2*Math.PI))}function R(S){const v=S.toString(16);return S<=15?("0"+v).toUpperCase():v.toUpperCase()}function O(S){if(Math.log2)return Math.floor(Math.log2(S));if(S<0)return NaN;if(0===S)return-1/0;let v=0;if(S<1){for(;S<1;)v++,S*=2;v=-v}else if(S>1)for(;S>1;)v++,S=Math.floor(S/2);return v}function I(S,v){return S-Math.floor(S/v)*v}function K(S,v,D){return(S-v)/(D-v)}function q(S,v,D){return S*(D-v)+v}function u(S,v){let D=I(v-S,360);return D>180&&(D-=360),D}function s(S,v){const D=I(S,2*v);return v-Math.abs(D-v)}function r(S,v,D){let z=w(D);return z=-2*z*z*z+3*z*z,v*z+S*(1-z)}function d(S,v,D){let z=0;return z=Math.abs(v-S)<=D?v:S+Math.sign(v-S)*D,z}function x(S,v,D){const z=u(S,v);let e=0;return e=-D<z&&z<D?v:d(S,v=S+z,D),e}function W(S,v,D){return(S-v)/(D-v)}function p(S,v,D){return(D-v)*S+v}function b(S,v){const D=S%v;return 0===D?v:b(v,D)}D.r(v),D.d(v,{Clamp:()=>w,DeltaAngle:()=>u,Denormalize:()=>q,ExtractAsInt:()=>z,Hermite:()=>h,Hermite1stDerivative:()=>A,HighestCommonFactor:()=>b,ILog2:()=>O,InverseLerp:()=>E,Lerp:()=>B,LerpAngle:()=>g,MoveTowards:()=>d,MoveTowardsAngle:()=>x,Normalize:()=>K,NormalizeRadians:()=>n,OutsideRange:()=>N,PercentToRange:()=>p,PingPong:()=>s,RandomRange:()=>m,RangeToPercent:()=>W,Repeat:()=>I,SmoothStep:()=>r,ToHex:()=>R,WithinEpsilon:()=>e})},11371:(S,v,D)=>{D.r(v),D.d(v,{Matrix:()=>q,Quaternion:()=>K,TmpVectors:()=>s,Vector2:()=>R,Rv:()=>O,Vector4:()=>I});var z=D(11377),e=D(11386),N=D(11329),m=D(11294),B=D(11222),g=D(11393);class E{}function h(S,v,D){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const e=S.Oe(),N=v.Oe(),m=e[0],B=e[1],g=e[2],E=e[3],h=e[4],A=e[5],w=e[6],n=e[7],R=e[8],O=e[9],I=e[10],K=e[11],q=e[12],u=e[13],s=e[14],r=e[15],d=N[0],x=N[1],W=N[2],p=N[3],b=N[4],k=N[5],Z=N[6],i=N[7],t=N[8],X=N[9],a=N[10],o=N[11],M=N[12],c=N[13],J=N[14],H=N[15];D[z]=m*d+B*b+g*t+E*M,D[z+1]=m*x+B*k+g*X+E*c,D[z+2]=m*W+B*Z+g*a+E*J,D[z+3]=m*p+B*i+g*o+E*H,D[z+4]=h*d+A*b+w*t+n*M,D[z+5]=h*x+A*k+w*X+n*c,D[z+6]=h*W+A*Z+w*a+n*J,D[z+7]=h*p+A*i+w*o+n*H,D[z+8]=R*d+O*b+I*t+K*M,D[z+9]=R*x+O*k+I*X+K*c,D[z+10]=R*W+O*Z+I*a+K*J,D[z+11]=R*p+O*i+I*o+K*H,D[z+12]=q*d+u*b+s*t+r*M,D[z+13]=q*x+u*k+s*X+r*c,D[z+14]=q*W+u*Z+s*a+r*J,D[z+15]=q*p+u*i+s*o+r*H}function A(S,v){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const z=S.Oe();v[D]=z[0],v[D+1]=z[1],v[D+2]=z[2],v[D+3]=z[3],v[D+4]=z[4],v[D+5]=z[5],v[D+6]=z[6],v[D+7]=z[7],v[D+8]=z[8],v[D+9]=z[9],v[D+10]=z[10],v[D+11]=z[11],v[D+12]=z[12],v[D+13]=z[13],v[D+14]=z[14],v[D+15]=z[15]}function w(S,v){const D=S.Oe(),z=D[0],e=D[1],N=D[2],m=D[3],B=D[4],g=D[5],E=D[6],h=D[7],A=D[8],w=D[9],n=D[10],R=D[11],O=D[12],I=D[13],K=D[14],q=D[15],u=n*q-K*R,s=w*q-I*R,r=w*K-I*n,d=A*q-O*R,x=A*K-n*O,W=A*I-O*w,p=+(g*u-E*s+h*r),b=-(B*u-E*d+h*x),k=+(B*s-g*d+h*W),Z=-(B*r-g*x+E*W),i=z*p+e*b+N*k+m*Z;if(0===i)return!1;const t=1/i,X=E*q-K*h,a=g*q-I*h,o=g*K-I*E,M=B*q-O*h,c=B*K-O*E,J=B*I-O*g,H=E*R-n*h,T=g*R-w*h,G=g*n-w*E,Y=B*R-A*h,j=B*n-A*E,V=B*w-A*g,U=-(e*u-N*s+m*r),y=+(z*u-N*d+m*x),f=-(z*s-e*d+m*W),C=+(z*r-e*x+N*W),F=+(e*X-N*a+m*o),l=-(z*X-N*M+m*c),P=+(z*a-e*M+m*J),Q=-(z*o-e*c+N*J),L=-(e*H-N*T+m*G),SS=+(z*H-N*Y+m*j),vS=-(z*T-e*Y+m*V),DS=+(z*G-e*j+N*V);return v[0]=p*t,v[1]=U*t,v[2]=F*t,v[3]=L*t,v[4]=b*t,v[5]=y*t,v[6]=l*t,v[7]=SS*t,v[8]=k*t,v[9]=f*t,v[10]=P*t,v[11]=vS*t,v[12]=Z*t,v[13]=C*t,v[14]=Q*t,v[15]=DS*t,!0}E._UpdateFlagSeed=0;const n=S=>parseInt(S.toString().replace(/\W/g,""));class R{constructor(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=S,this.y=v}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let S=n(this.x);return S=397*S^n(this.y),S}toArray(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S[v]=this.x,S[v+1]=this.y,this}RD(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R.FromArrayToRef(S,v,this),this}Oe(){return[this.x,this.y]}N(S){return this.x=S.x,this.y=S.y,this}oe(S,v){return this.x=S,this.y=v,this}set(S,v){return this.oe(S,v)}Je(S){return this.oe(S,S)}add(S){return new R(this.x+S.x,this.y+S.y)}addToRef(S,v){return v.x=this.x+S.x,v.y=this.y+S.y,v}addInPlace(S){return this.x+=S.x,this.y+=S.y,this}addInPlaceFromFloats(S,v){return this.x+=S,this.y+=v,this}addVector3(S){return new R(this.x+S.x,this.y+S.y)}Ov(S){return new R(this.x-S.x,this.y-S.y)}subtractToRef(S,v){return v.x=this.x-S.x,v.y=this.y-S.y,v}tA(S){return this.x-=S.x,this.y-=S.y,this}multiplyInPlace(S){return this.x*=S.x,this.y*=S.y,this}multiply(S){return new R(this.x*S.x,this.y*S.y)}multiplyToRef(S,v){return v.x=this.x*S.x,v.y=this.y*S.y,v}multiplyByFloats(S,v){return new R(this.x*S,this.y*v)}divide(S){return new R(this.x/S.x,this.y/S.y)}divideToRef(S,v){return v.x=this.x/S.x,v.y=this.y/S.y,v}divideInPlace(S){return this.x=this.x/S.x,this.y=this.y/S.y,this}minimizeInPlace(S){return this.minimizeInPlaceFromFloats(S.x,S.y)}maximizeInPlace(S){return this.maximizeInPlaceFromFloats(S.x,S.y)}minimizeInPlaceFromFloats(S,v){return this.x=Math.min(S,this.x),this.y=Math.min(v,this.y),this}maximizeInPlaceFromFloats(S,v){return this.x=Math.max(S,this.x),this.y=Math.max(v,this.y),this}subtractFromFloats(S,v){return new R(this.x-S,this.y-v)}subtractFromFloatsToRef(S,v,D){return D.x=this.x-S,D.y=this.y-v,D}negate(){return new R(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(S){return S.x=-this.x,S.y=-this.y,S}scaleInPlace(S){return this.x*=S,this.y*=S,this}scale(S){return new R(this.x*S,this.y*S)}scaleToRef(S,v){return v.x=this.x*S,v.y=this.y*S,v}scaleAndAddToRef(S,v){return v.x+=this.x*S,v.y+=this.y*S,v}equals(S){return S&&this.x===S.x&&this.y===S.y}equalsWithEpsilon(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.e;return S&&(0,g.WithinEpsilon)(this.x,S.x,v)&&(0,g.WithinEpsilon)(this.y,S.y,v)}equalsToFloats(S,v){return this.x===S&&this.y===v}floor(){return new R(Math.floor(this.x),Math.floor(this.y))}floorToRef(S){return S.x=Math.floor(this.x),S.y=Math.floor(this.y),S}fract(){return new R(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(S){return S.x=this.x-Math.floor(this.x),S.y=this.y-Math.floor(this.y),S}rotate(S){return this.rotateToRef(S,new R)}rotateToRef(S,v){const D=Math.cos(S),z=Math.sin(S);return v.x=D*this.x-z*this.y,v.y=z*this.x+D*this.y,v}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(S){return 0===S||1===S?this:this.scaleInPlace(1/S)}normalizeToNew(){const S=new R;return this.normalizeToRef(S),S}normalizeToRef(S){const v=this.length();return 0===v&&(S.x=this.x,S.y=this.y),this.scaleToRef(1/v,S)}clone(){return new R(this.x,this.y)}dot(S){return this.x*S.x+this.y*S.y}static Zero(){return new R(0,0)}static One(){return new R(1,1)}static Random(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new R((0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v))}static RandomToRef(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).oe((0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v))}static get ZeroReadOnly(){return R._ZeroReadOnly}static uv(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new R(S[v],S[v+1])}static FromArrayToRef(S,v,D){return D.x=S[v],D.y=S[v+1],D}static FromFloatsToRef(S,v,D){return D.oe(S,v),D}static CatmullRom(S,v,D,z,e){const N=e*e,m=e*N,B=.5*(2*v.x+(-S.x+D.x)*e+(2*S.x-5*v.x+4*D.x-z.x)*N+(-S.x+3*v.x-3*D.x+z.x)*m),g=.5*(2*v.y+(-S.y+D.y)*e+(2*S.y-5*v.y+4*D.y-z.y)*N+(-S.y+3*v.y-3*D.y+z.y)*m);return new R(B,g)}static ClampToRef(S,v,D,z){return z.x=(0,g.Clamp)(S.x,v.x,D.x),z.y=(0,g.Clamp)(S.y,v.y,D.y),z}static Clamp(S,v,D){const z=(0,g.Clamp)(S.x,v.x,D.x),e=(0,g.Clamp)(S.y,v.y,D.y);return new R(z,e)}static Hermite(S,v,D,z,e){const N=e*e,m=e*N,B=2*m-3*N+1,g=-2*m+3*N,E=m-2*N+e,h=m-N,A=S.x*B+D.x*g+v.x*E+z.x*h,w=S.y*B+D.y*g+v.y*E+z.y*h;return new R(A,w)}static Hermite1stDerivative(S,v,D,z,e){return this.Hermite1stDerivativeToRef(S,v,D,z,e,new R)}static Hermite1stDerivativeToRef(S,v,D,z,e,N){const m=e*e;return N.x=6*(m-e)*S.x+(3*m-4*e+1)*v.x+6*(-m+e)*D.x+(3*m-2*e)*z.x,N.y=6*(m-e)*S.y+(3*m-4*e+1)*v.y+6*(-m+e)*D.y+(3*m-2*e)*z.y,N}static Lerp(S,v,D){return R.LerpToRef(S,v,D,new R)}static LerpToRef(S,v,D,z){return z.x=S.x+(v.x-S.x)*D,z.y=S.y+(v.y-S.y)*D,z}static Dot(S,v){return S.x*v.x+S.y*v.y}static Normalize(S){return R.NormalizeToRef(S,new R)}static NormalizeToRef(S,v){return S.normalizeToRef(v),v}static Minimize(S,v){const D=S.x<v.x?S.x:v.x,z=S.y<v.y?S.y:v.y;return new R(D,z)}static Maximize(S,v){const D=S.x>v.x?S.x:v.x,z=S.y>v.y?S.y:v.y;return new R(D,z)}static Transform(S,v){return R.TransformToRef(S,v,new R)}static TransformToRef(S,v,D){const z=v.m,e=S.x*z[0]+S.y*z[4]+z[12],N=S.x*z[1]+S.y*z[5]+z[13];return D.x=e,D.y=N,D}static PointInTriangle(S,v,D,z){const e=.5*(-D.y*z.x+v.y*(-D.x+z.x)+v.x*(D.y-z.y)+D.x*z.y),N=e<0?-1:1,m=(v.y*z.x-v.x*z.y+(z.y-v.y)*S.x+(v.x-z.x)*S.y)*N,B=(v.x*D.y-v.y*D.x+(v.y-D.y)*S.x+(D.x-v.x)*S.y)*N;return m>0&&B>0&&m+B<2*e*N}static Distance(S,v){return Math.sqrt(R.DistanceSquared(S,v))}static DistanceSquared(S,v){const D=S.x-v.x,z=S.y-v.y;return D*D+z*z}static Center(S,v){return R.CenterToRef(S,v,new R)}static CenterToRef(S,v,D){return D.oe((S.x+v.x)/2,(S.y+v.y)/2)}static DistanceOfPointFromSegment(S,v,D){const z=R.DistanceSquared(v,D);if(0===z)return R.Distance(S,v);const e=D.Ov(v),N=Math.max(0,Math.min(1,R.Dot(S.Ov(v),e)/z)),m=v.add(e.multiplyByFloats(N,N));return R.Distance(S,m)}}R._V8PerformanceHack=new R(.5,.5),R._ZeroReadOnly=R.Zero(),Object.defineProperties(R.prototype,{dimension:{value:[2]},rank:{value:1}});class O{get x(){return this._x}set x(S){this._x=S,this._isDirty=!0}get y(){return this._y}set y(S){this._y=S,this._isDirty=!0}get z(){return this._z}set z(S){this._z=S,this._isDirty=!0}constructor(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=S,this._y=v,this._z=D}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Rv"}getHashCode(){let S=n(this._x);return S=397*S^n(this._y),S=397*S^n(this._z),S}Oe(){return[this._x,this._y,this._z]}toArray(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S[v]=this._x,S[v+1]=this._y,S[v+2]=this._z,this}RD(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(S,v,this),this}toQuaternion(){return K.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(S){return this._x+=S._x,this._y+=S._y,this._z+=S._z,this._isDirty=!0,this}addInPlaceFromFloats(S,v,D){return this._x+=S,this._y+=v,this._z+=D,this._isDirty=!0,this}add(S){return new O(this._x+S._x,this._y+S._y,this._z+S._z)}addToRef(S,v){return v._x=this._x+S._x,v._y=this._y+S._y,v._z=this._z+S._z,v._isDirty=!0,v}tA(S){return this._x-=S._x,this._y-=S._y,this._z-=S._z,this._isDirty=!0,this}Ov(S){return new O(this._x-S._x,this._y-S._y,this._z-S._z)}subtractToRef(S,v){return this.subtractFromFloatsToRef(S._x,S._y,S._z,v)}subtractFromFloats(S,v,D){return new O(this._x-S,this._y-v,this._z-D)}subtractFromFloatsToRef(S,v,D,z){return z._x=this._x-S,z._y=this._y-v,z._z=this._z-D,z._isDirty=!0,z}negate(){return new O(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(S){return S._x=-1*this._x,S._y=-1*this._y,S._z=-1*this._z,S._isDirty=!0,S}scaleInPlace(S){return this._x*=S,this._y*=S,this._z*=S,this._isDirty=!0,this}scale(S){return new O(this._x*S,this._y*S,this._z*S)}scaleToRef(S,v){return v._x=this._x*S,v._y=this._y*S,v._z=this._z*S,v._isDirty=!0,v}getNormalToRef(S){const v=this.length();let D=Math.acos(this._y/v);const z=Math.atan2(this._z,this._x);D>Math.PI/2?D-=Math.PI/2:D+=Math.PI/2;const e=v*Math.sin(D)*Math.cos(z),N=v*Math.cos(D),m=v*Math.sin(D)*Math.sin(z);return S.set(e,N,m),S}applyRotationQuaternionToRef(S,v){const D=this._x,z=this._y,e=this._z,N=S._x,m=S._y,B=S._z,g=S._w,E=2*(m*e-B*z),h=2*(B*D-N*e),A=2*(N*z-m*D);return v._x=D+g*E+m*A-B*h,v._y=z+g*h+B*E-N*A,v._z=e+g*A+N*h-m*E,v._isDirty=!0,v}applyRotationQuaternionInPlace(S){return this.applyRotationQuaternionToRef(S,this)}applyRotationQuaternion(S){return this.applyRotationQuaternionToRef(S,new O)}scaleAndAddToRef(S,v){return v._x+=this._x*S,v._y+=this._y*S,v._z+=this._z*S,v._isDirty=!0,v}projectOnPlane(S,v){return this.projectOnPlaneToRef(S,v,new O)}projectOnPlaneToRef(S,v,D){const z=S.normal,e=S.d,N=u.Rv[0];this.subtractToRef(v,N),N.normalize();const m=O.Dot(N,z);if(Math.abs(m)<1e-10)D.Je(1/0);else{const S=-(O.Dot(v,z)+e)/m,B=N.scaleInPlace(S);v.addToRef(B,D)}return D}equals(S){return S&&this._x===S._x&&this._y===S._y&&this._z===S._z}equalsWithEpsilon(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.e;return S&&(0,g.WithinEpsilon)(this._x,S._x,v)&&(0,g.WithinEpsilon)(this._y,S._y,v)&&(0,g.WithinEpsilon)(this._z,S._z,v)}equalsToFloats(S,v,D){return this._x===S&&this._y===v&&this._z===D}multiplyInPlace(S){return this._x*=S._x,this._y*=S._y,this._z*=S._z,this._isDirty=!0,this}multiply(S){return this.multiplyByFloats(S._x,S._y,S._z)}multiplyToRef(S,v){return v._x=this._x*S._x,v._y=this._y*S._y,v._z=this._z*S._z,v._isDirty=!0,v}multiplyByFloats(S,v,D){return new O(this._x*S,this._y*v,this._z*D)}divide(S){return new O(this._x/S._x,this._y/S._y,this._z/S._z)}divideToRef(S,v){return v._x=this._x/S._x,v._y=this._y/S._y,v._z=this._z/S._z,v._isDirty=!0,v}divideInPlace(S){return this._x=this._x/S._x,this._y=this._y/S._y,this._z=this._z/S._z,this._isDirty=!0,this}minimizeInPlace(S){return this.minimizeInPlaceFromFloats(S._x,S._y,S._z)}maximizeInPlace(S){return this.maximizeInPlaceFromFloats(S._x,S._y,S._z)}minimizeInPlaceFromFloats(S,v,D){return S<this._x&&(this.x=S),v<this._y&&(this.y=v),D<this._z&&(this.z=D),this}maximizeInPlaceFromFloats(S,v,D){return S>this._x&&(this.x=S),v>this._y&&(this.y=v),D>this._z&&(this.z=D),this}isNonUniformWithinEpsilon(S){const v=Math.abs(this._x),D=Math.abs(this._y);if(!(0,g.WithinEpsilon)(v,D,S))return!0;const z=Math.abs(this._z);return!(0,g.WithinEpsilon)(v,z,S)||!(0,g.WithinEpsilon)(D,z,S)}get isNonUniform(){const S=Math.abs(this._x);if(S!==Math.abs(this._y))return!0;return S!==Math.abs(this._z)}floorToRef(S){return S._x=Math.floor(this._x),S._y=Math.floor(this._y),S._z=Math.floor(this._z),S._isDirty=!0,S}floor(){return new O(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(S){return S._x=this._x-Math.floor(this._x),S._y=this._y-Math.floor(this._y),S._z=this._z-Math.floor(this._z),S._isDirty=!0,S}fract(){return new O(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(S){if("xyz"===(S=S.toLowerCase()))return this;const v=u.Rv[0].N(this);return this.x=v[S[0]],this.y=v[S[1]],this.z=v[S[2]],this}rotateByQuaternionToRef(S,v){return S.toRotationMatrix(u.Matrix[0]),O.TransformCoordinatesToRef(this,u.Matrix[0],v),v}rotateByQuaternionAroundPointToRef(S,v,D){return this.subtractToRef(v,u.Rv[0]),u.Rv[0].rotateByQuaternionToRef(S,u.Rv[0]),v.addToRef(u.Rv[0],D),D}cross(S){return O.CrossToRef(this,S,new O)}normalizeFromLength(S){return 0===S||1===S?this:this.scaleInPlace(1/S)}normalizeToNew(){return this.normalizeToRef(new O)}normalizeToRef(S){const v=this.length();return 0===v||1===v?(S._x=this._x,S._y=this._y,S._z=this._z,S._isDirty=!0,S):this.scaleToRef(1/v,S)}clone(){return new O(this._x,this._y,this._z)}N(S){return this.oe(S._x,S._y,S._z)}oe(S,v,D){return this._x=S,this._y=v,this._z=D,this._isDirty=!0,this}set(S,v,D){return this.oe(S,v,D)}Je(S){return this._x=this._y=this._z=S,this._isDirty=!0,this}static GetClipFactor(S,v,D,z){const e=O.Dot(S,D);return(e-z)/(e-O.Dot(v,D))}static GetAngleBetweenVectors(S,v,D){const z=S.normalizeToRef(u.Rv[1]),e=v.normalizeToRef(u.Rv[2]);let N=O.Dot(z,e);N=(0,g.Clamp)(N,-1,1);const m=Math.acos(N),B=u.Rv[3];return O.CrossToRef(z,e,B),O.Dot(B,D)>0?isNaN(m)?0:m:isNaN(m)?-Math.PI:-Math.acos(N)}static GetAngleBetweenVectorsOnPlane(S,v,D){u.Rv[0].N(S);const z=u.Rv[0];u.Rv[1].N(v);const e=u.Rv[1];u.Rv[2].N(D);const N=u.Rv[2],m=u.Rv[3],B=u.Rv[4];z.normalize(),e.normalize(),N.normalize(),O.CrossToRef(N,z,m),O.CrossToRef(m,N,B);const E=Math.atan2(O.Dot(e,m),O.Dot(e,B));return(0,g.NormalizeRadians)(E)}static PitchYawRollToMoveBetweenPointsToRef(S,v,D){const z=s.Rv[0];return v.subtractToRef(S,z),D._y=Math.atan2(z.x,z.z)||0,D._x=Math.atan2(Math.sqrt(z.x**2+z.z**2),z.y)||0,D._z=0,D._isDirty=!0,D}static PitchYawRollToMoveBetweenPoints(S,v){const D=O.Zero();return O.PitchYawRollToMoveBetweenPointsToRef(S,v,D)}static SlerpToRef(S,v,D,e){D=(0,g.Clamp)(D,0,1);const N=u.Rv[0],m=u.Rv[1];N.N(S);const B=N.length();N.normalizeFromLength(B),m.N(v);const E=m.length();m.normalizeFromLength(E);const h=O.Dot(N,m);let A,w;if(h<1-z.e){const S=Math.acos(h),v=1/Math.sin(S);A=Math.sin((1-D)*S)*v,w=Math.sin(D*S)*v}else A=1-D,w=D;return N.scaleInPlace(A),m.scaleInPlace(w),e.N(N).addInPlace(m),e.scaleInPlace((0,g.Lerp)(B,E,D)),e}static SmoothToRef(S,v,D,z,e){return O.SlerpToRef(S,v,0===z?1:D/z,e),e}static uv(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new O(S[v],S[v+1],S[v+2])}static FromFloatArray(S,v){return O.uv(S,v)}static FromArrayToRef(S,v,D){return D._x=S[v],D._y=S[v+1],D._z=S[v+2],D._isDirty=!0,D}static FromFloatArrayToRef(S,v,D){return O.FromArrayToRef(S,v,D)}static FromFloatsToRef(S,v,D,z){return z.oe(S,v,D),z}static Zero(){return new O(0,0,0)}static One(){return new O(1,1,1)}static Up(){return new O(0,1,0)}static get UpReadOnly(){return O._UpReadOnly}static get DownReadOnly(){return O._DownReadOnly}static get RightReadOnly(){return O._RightReadOnly}static get LeftReadOnly(){return O._LeftReadOnly}static get LeftHandedForwardReadOnly(){return O._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return O._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return O._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return O._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return O._ZeroReadOnly}static get OneReadOnly(){return O._OneReadOnly}static Down(){return new O(0,-1,0)}static Forward(){return new O(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new O(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new O(1,0,0)}static Left(){return new O(-1,0,0)}static Random(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new O((0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v))}static RandomToRef(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).oe((0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v))}static TransformCoordinates(S,v){const D=O.Zero();return O.TransformCoordinatesToRef(S,v,D),D}static TransformCoordinatesToRef(S,v,D){return O.TransformCoordinatesFromFloatsToRef(S._x,S._y,S._z,v,D),D}static TransformCoordinatesFromFloatsToRef(S,v,D,z,e){const N=z.m,m=S*N[0]+v*N[4]+D*N[8]+N[12],B=S*N[1]+v*N[5]+D*N[9]+N[13],g=S*N[2]+v*N[6]+D*N[10]+N[14],E=1/(S*N[3]+v*N[7]+D*N[11]+N[15]);return e._x=m*E,e._y=B*E,e._z=g*E,e._isDirty=!0,e}static TransformNormal(S,v){const D=O.Zero();return O.TransformNormalToRef(S,v,D),D}static TransformNormalToRef(S,v,D){return this.TransformNormalFromFloatsToRef(S._x,S._y,S._z,v,D),D}static TransformNormalFromFloatsToRef(S,v,D,z,e){const N=z.m;return e._x=S*N[0]+v*N[4]+D*N[8],e._y=S*N[1]+v*N[5]+D*N[9],e._z=S*N[2]+v*N[6]+D*N[10],e._isDirty=!0,e}static CatmullRom(S,v,D,z,e){const N=e*e,m=e*N,B=.5*(2*v._x+(-S._x+D._x)*e+(2*S._x-5*v._x+4*D._x-z._x)*N+(-S._x+3*v._x-3*D._x+z._x)*m),g=.5*(2*v._y+(-S._y+D._y)*e+(2*S._y-5*v._y+4*D._y-z._y)*N+(-S._y+3*v._y-3*D._y+z._y)*m),E=.5*(2*v._z+(-S._z+D._z)*e+(2*S._z-5*v._z+4*D._z-z._z)*N+(-S._z+3*v._z-3*D._z+z._z)*m);return new O(B,g,E)}static Clamp(S,v,D){const z=new O;return O.ClampToRef(S,v,D,z),z}static ClampToRef(S,v,D,z){let e=S._x;e=e>D._x?D._x:e,e=e<v._x?v._x:e;let N=S._y;N=N>D._y?D._y:N,N=N<v._y?v._y:N;let m=S._z;return m=m>D._z?D._z:m,m=m<v._z?v._z:m,z.oe(e,N,m),z}static CheckExtends(S,v,D){v.minimizeInPlace(S),D.maximizeInPlace(S)}static Hermite(S,v,D,z,e){const N=e*e,m=e*N,B=2*m-3*N+1,g=-2*m+3*N,E=m-2*N+e,h=m-N,A=S._x*B+D._x*g+v._x*E+z._x*h,w=S._y*B+D._y*g+v._y*E+z._y*h,n=S._z*B+D._z*g+v._z*E+z._z*h;return new O(A,w,n)}static Hermite1stDerivative(S,v,D,z,e){const N=new O;return this.Hermite1stDerivativeToRef(S,v,D,z,e,N),N}static Hermite1stDerivativeToRef(S,v,D,z,e,N){const m=e*e;return N._x=6*(m-e)*S._x+(3*m-4*e+1)*v._x+6*(-m+e)*D._x+(3*m-2*e)*z._x,N._y=6*(m-e)*S._y+(3*m-4*e+1)*v._y+6*(-m+e)*D._y+(3*m-2*e)*z._y,N._z=6*(m-e)*S._z+(3*m-4*e+1)*v._z+6*(-m+e)*D._z+(3*m-2*e)*z._z,N._isDirty=!0,N}static Lerp(S,v,D){const z=new O(0,0,0);return O.LerpToRef(S,v,D,z),z}static LerpToRef(S,v,D,z){return z._x=S._x+(v._x-S._x)*D,z._y=S._y+(v._y-S._y)*D,z._z=S._z+(v._z-S._z)*D,z._isDirty=!0,z}static Dot(S,v){return S._x*v._x+S._y*v._y+S._z*v._z}dot(S){return this._x*S._x+this._y*S._y+this._z*S._z}static Cross(S,v){const D=new O;return O.CrossToRef(S,v,D),D}static CrossToRef(S,v,D){const z=S._y*v._z-S._z*v._y,e=S._z*v._x-S._x*v._z,N=S._x*v._y-S._y*v._x;return D.oe(z,e,N),D}static Normalize(S){const v=O.Zero();return O.NormalizeToRef(S,v),v}static NormalizeToRef(S,v){return S.normalizeToRef(v),v}static Project(S,v,D,z){const e=new O;return O.ProjectToRef(S,v,D,z,e),e}static ProjectToRef(S,v,D,z,e){var N;const m=z.width,g=z.height,E=z.x,h=z.y,A=u.Matrix[1],w=null===(N=B.c.LastCreatedEngine)||void 0===N?void 0:N.isNDCHalfZRange,n=w?1:.5,R=w?0:.5;q.FromValuesToRef(m/2,0,0,0,0,-g/2,0,0,0,0,n,0,E+m/2,g/2+h,R,1,A);const I=u.Matrix[0];return v.multiplyToRef(D,I),I.multiplyToRef(A,I),O.TransformCoordinatesToRef(S,I,e),e}static Reflect(S,v){return this.ReflectToRef(S,v,new O)}static ReflectToRef(S,v,D){const z=s.Rv[0];return z.N(v).scaleInPlace(2*O.Dot(S,v)),D.N(S).tA(z)}static _UnprojectFromInvertedMatrixToRef(S,v,D){O.TransformCoordinatesToRef(S,v,D);const z=v.m,e=S._x*z[3]+S._y*z[7]+S._z*z[11]+z[15];return(0,g.WithinEpsilon)(e,1)&&D.scaleInPlace(1/e),D}static UnprojectFromTransform(S,v,D,z,e){return this.Unproject(S,v,D,z,e,q.IdentityReadOnly)}static Unproject(S,v,D,z,e,N){const m=new O;return O.UnprojectToRef(S,v,D,z,e,N,m),m}static UnprojectToRef(S,v,D,z,e,N,m){return O.UnprojectFloatsToRef(S._x,S._y,S._z,v,D,z,e,N,m),m}static UnprojectFloatsToRef(S,v,D,z,e,N,m,g,E){var h;const A=u.Matrix[0];N.multiplyToRef(m,A),A.multiplyToRef(g,A),A.invert();const w=u.Rv[0];return w.x=S/z*2-1,w.y=-(v/e*2-1),null!==(h=B.c.LastCreatedEngine)&&void 0!==h&&h.isNDCHalfZRange?w.z=D:w.z=2*D-1,O._UnprojectFromInvertedMatrixToRef(w,A,E),E}static Minimize(S,v){const D=new O;return D.N(S),D.minimizeInPlace(v),D}static Maximize(S,v){const D=new O;return D.N(S),D.maximizeInPlace(v),D}static Distance(S,v){return Math.sqrt(O.DistanceSquared(S,v))}static DistanceSquared(S,v){const D=S._x-v._x,z=S._y-v._y,e=S._z-v._z;return D*D+z*z+e*e}static ProjectOnTriangleToRef(S,v,D,e,N){const m=u.Rv[0],B=u.Rv[1],E=u.Rv[2],h=u.Rv[3],A=u.Rv[4];D.subtractToRef(v,m),e.subtractToRef(v,B),e.subtractToRef(D,E);const w=m.length(),n=B.length(),R=E.length();if(w<z.e||n<z.e||R<z.e)return N.N(v),O.Distance(S,v);S.subtractToRef(v,A),O.CrossToRef(m,B,h);const I=h.length();if(I<z.e)return N.N(v),O.Distance(S,v);h.normalizeFromLength(I);let K=A.length();if(K<z.e)return N.N(v),0;A.normalizeFromLength(K);const q=O.Dot(h,A),s=u.Rv[5],r=u.Rv[6];s.N(h).scaleInPlace(-K*q),r.N(S).addInPlace(s);const d=u.Rv[4],x=u.Rv[5],W=u.Rv[7],p=u.Rv[8];d.N(m).scaleInPlace(1/w),p.N(B).scaleInPlace(1/n),d.addInPlace(p).scaleInPlace(-1),x.N(m).scaleInPlace(-1/w),p.N(E).scaleInPlace(1/R),x.addInPlace(p).scaleInPlace(-1),W.N(E).scaleInPlace(-1/R),p.N(B).scaleInPlace(-1/n),W.addInPlace(p).scaleInPlace(-1);const b=u.Rv[9];let k;b.N(r).tA(v),O.CrossToRef(d,b,p),k=O.Dot(p,h);const Z=k;b.N(r).tA(D),O.CrossToRef(x,b,p),k=O.Dot(p,h);const i=k;b.N(r).tA(e),O.CrossToRef(W,b,p),k=O.Dot(p,h);const t=k,X=u.Rv[10];let a,o;Z>0&&i<0?(X.N(m),a=v,o=D):i>0&&t<0?(X.N(E),a=D,o=e):(X.N(B).scaleInPlace(-1),a=e,o=v);const M=u.Rv[9],c=u.Rv[4];a.subtractToRef(r,p),o.subtractToRef(r,M),O.CrossToRef(p,M,c);if(!(O.Dot(c,h)<0))return N.N(r),Math.abs(K*q);const J=u.Rv[5];O.CrossToRef(X,c,J),J.normalize();const H=u.Rv[9];H.N(a).tA(r);const T=H.length();if(T<z.e)return N.N(a),O.Distance(S,a);H.normalizeFromLength(T);const G=O.Dot(J,H),Y=u.Rv[7];Y.N(r).addInPlace(J.scaleInPlace(T*G)),p.N(Y).tA(a),K=X.length(),X.normalizeFromLength(K);let j=O.Dot(p,X)/Math.max(K,z.e);return j=(0,g.Clamp)(j,0,1),Y.N(a).addInPlace(X.scaleInPlace(j*K)),N.N(Y),O.Distance(S,Y)}static Center(S,v){return O.CenterToRef(S,v,O.Zero())}static CenterToRef(S,v,D){return D.oe((S._x+v._x)/2,(S._y+v._y)/2,(S._z+v._z)/2)}static RotationFromAxis(S,v,D){const z=new O;return O.RotationFromAxisToRef(S,v,D,z),z}static RotationFromAxisToRef(S,v,D,z){const e=u.Quaternion[0];return K.RotationQuaternionFromAxisToRef(S,v,D,e),e.toEulerAnglesToRef(z),z}}O._V8PerformanceHack=new O(.5,.5,.5),O._UpReadOnly=O.Up(),O._DownReadOnly=O.Down(),O._LeftHandedForwardReadOnly=O.Forward(!1),O._RightHandedForwardReadOnly=O.Forward(!0),O._LeftHandedBackwardReadOnly=O.Backward(!1),O._RightHandedBackwardReadOnly=O.Backward(!0),O._RightReadOnly=O.Right(),O._LeftReadOnly=O.Left(),O._ZeroReadOnly=O.Zero(),O._OneReadOnly=O.One(),Object.defineProperties(O.prototype,{dimension:{value:[3]},rank:{value:1}});class I{get x(){return this._x}set x(S){this._x=S,this._isDirty=!0}get y(){return this._y}set y(S){this._y=S,this._isDirty=!0}get z(){return this._z}set z(S){this._z=S,this._isDirty=!0}get w(){return this._w}set w(S){this._w=S,this._isDirty=!0}constructor(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=S,this._y=v,this._z=D,this._w=z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let S=n(this._x);return S=397*S^n(this._y),S=397*S^n(this._z),S=397*S^n(this._w),S}Oe(){return[this._x,this._y,this._z,this._w]}toArray(S,v){return void 0===v&&(v=0),S[v]=this._x,S[v+1]=this._y,S[v+2]=this._z,S[v+3]=this._w,this}RD(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I.FromArrayToRef(S,v,this),this}addInPlace(S){return this.x+=S._x,this.y+=S._y,this.z+=S._z,this.w+=S._w,this}addInPlaceFromFloats(S,v,D,z){return this.x+=S,this.y+=v,this.z+=D,this.w+=z,this}add(S){return new I(this._x+S.x,this._y+S.y,this._z+S.z,this._w+S.w)}addToRef(S,v){return v.x=this._x+S.x,v.y=this._y+S.y,v.z=this._z+S.z,v.w=this._w+S.w,v}tA(S){return this.x-=S.x,this.y-=S.y,this.z-=S.z,this.w-=S.w,this}Ov(S){return new I(this._x-S.x,this._y-S.y,this._z-S.z,this._w-S.w)}subtractToRef(S,v){return v.x=this._x-S.x,v.y=this._y-S.y,v.z=this._z-S.z,v.w=this._w-S.w,v}subtractFromFloats(S,v,D,z){return new I(this._x-S,this._y-v,this._z-D,this._w-z)}subtractFromFloatsToRef(S,v,D,z,e){return e.x=this._x-S,e.y=this._y-v,e.z=this._z-D,e.w=this._w-z,e}negate(){return new I(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(S){return S.x=-this._x,S.y=-this._y,S.z=-this._z,S.w=-this._w,S}scaleInPlace(S){return this.x*=S,this.y*=S,this.z*=S,this.w*=S,this}scale(S){return new I(this._x*S,this._y*S,this._z*S,this._w*S)}scaleToRef(S,v){return v.x=this._x*S,v.y=this._y*S,v.z=this._z*S,v.w=this._w*S,v}scaleAndAddToRef(S,v){return v.x+=this._x*S,v.y+=this._y*S,v.z+=this._z*S,v.w+=this._w*S,v}equals(S){return S&&this._x===S.x&&this._y===S.y&&this._z===S.z&&this._w===S.w}equalsWithEpsilon(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.e;return S&&(0,g.WithinEpsilon)(this._x,S.x,v)&&(0,g.WithinEpsilon)(this._y,S.y,v)&&(0,g.WithinEpsilon)(this._z,S.z,v)&&(0,g.WithinEpsilon)(this._w,S.w,v)}equalsToFloats(S,v,D,z){return this._x===S&&this._y===v&&this._z===D&&this._w===z}multiplyInPlace(S){return this.x*=S.x,this.y*=S.y,this.z*=S.z,this.w*=S.w,this}multiply(S){return new I(this._x*S.x,this._y*S.y,this._z*S.z,this._w*S.w)}multiplyToRef(S,v){return v.x=this._x*S.x,v.y=this._y*S.y,v.z=this._z*S.z,v.w=this._w*S.w,v}multiplyByFloats(S,v,D,z){return new I(this._x*S,this._y*v,this._z*D,this._w*z)}divide(S){return new I(this._x/S.x,this._y/S.y,this._z/S.z,this._w/S.w)}divideToRef(S,v){return v.x=this._x/S.x,v.y=this._y/S.y,v.z=this._z/S.z,v.w=this._w/S.w,v}divideInPlace(S){return this.divideToRef(S,this)}minimizeInPlace(S){return S.x<this._x&&(this.x=S.x),S.y<this._y&&(this.y=S.y),S.z<this._z&&(this.z=S.z),S.w<this._w&&(this.w=S.w),this}maximizeInPlace(S){return S.x>this._x&&(this.x=S.x),S.y>this._y&&(this.y=S.y),S.z>this._z&&(this.z=S.z),S.w>this._w&&(this.w=S.w),this}minimizeInPlaceFromFloats(S,v,D,z){return this.x=Math.min(S,this._x),this.y=Math.min(v,this._y),this.z=Math.min(D,this._z),this.w=Math.min(z,this._w),this}maximizeInPlaceFromFloats(S,v,D,z){return this.x=Math.max(S,this._x),this.y=Math.max(v,this._y),this.z=Math.max(D,this._z),this.w=Math.max(z,this._w),this}floorToRef(S){return S.x=Math.floor(this._x),S.y=Math.floor(this._y),S.z=Math.floor(this._z),S.w=Math.floor(this._w),S}floor(){return new I(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(S){return S.x=this._x-Math.floor(this._x),S.y=this._y-Math.floor(this._y),S.z=this._z-Math.floor(this._z),S.w=this._w-Math.floor(this._w),S}fract(){return new I(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(S){return 0===S||1===S?this:this.scaleInPlace(1/S)}normalizeToNew(){return this.normalizeToRef(new I)}normalizeToRef(S){const v=this.length();return 0===v||1===v?(S.x=this._x,S.y=this._y,S.z=this._z,S.w=this._w,S):this.scaleToRef(1/v,S)}toVector3(){return new O(this._x,this._y,this._z)}clone(){return new I(this._x,this._y,this._z,this._w)}N(S){return this.x=S.x,this.y=S.y,this.z=S.z,this.w=S.w,this}oe(S,v,D,z){return this.x=S,this.y=v,this.z=D,this.w=z,this}set(S,v,D,z){return this.oe(S,v,D,z)}Je(S){return this.x=this.y=this.z=this.w=S,this}dot(S){return this._x*S.x+this._y*S.y+this._z*S.z+this._w*S.w}static uv(S,v){return v||(v=0),new I(S[v],S[v+1],S[v+2],S[v+3])}static FromArrayToRef(S,v,D){return D.x=S[v],D.y=S[v+1],D.z=S[v+2],D.w=S[v+3],D}static FromFloatArrayToRef(S,v,D){return I.FromArrayToRef(S,v,D),D}static FromFloatsToRef(S,v,D,z,e){return e.x=S,e.y=v,e.z=D,e.w=z,e}static Zero(){return new I(0,0,0,0)}static One(){return new I(1,1,1,1)}static Random(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new I((0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v))}static RandomToRef(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,D=arguments.length>2?arguments[2]:void 0;return D.x=(0,g.RandomRange)(S,v),D.y=(0,g.RandomRange)(S,v),D.z=(0,g.RandomRange)(S,v),D.w=(0,g.RandomRange)(S,v),D}static Clamp(S,v,D){return I.ClampToRef(S,v,D,new I)}static ClampToRef(S,v,D,z){return z.x=(0,g.Clamp)(S.x,v.x,D.x),z.y=(0,g.Clamp)(S.y,v.y,D.y),z.z=(0,g.Clamp)(S.z,v.z,D.z),z.w=(0,g.Clamp)(S.w,v.w,D.w),z}static CheckExtends(S,v,D){v.minimizeInPlace(S),D.maximizeInPlace(S)}static get ZeroReadOnly(){return I._ZeroReadOnly}static Normalize(S){return I.NormalizeToRef(S,new I)}static NormalizeToRef(S,v){return S.normalizeToRef(v),v}static Minimize(S,v){const D=new I;return D.N(S),D.minimizeInPlace(v),D}static Maximize(S,v){const D=new I;return D.N(S),D.maximizeInPlace(v),D}static Distance(S,v){return Math.sqrt(I.DistanceSquared(S,v))}static DistanceSquared(S,v){const D=S.x-v.x,z=S.y-v.y,e=S.z-v.z,N=S.w-v.w;return D*D+z*z+e*e+N*N}static Center(S,v){return I.CenterToRef(S,v,new I)}static CenterToRef(S,v,D){return D.x=(S.x+v.x)/2,D.y=(S.y+v.y)/2,D.z=(S.z+v.z)/2,D.w=(S.w+v.w)/2,D}static TransformCoordinates(S,v){return I.TransformCoordinatesToRef(S,v,new I)}static TransformCoordinatesToRef(S,v,D){return I.TransformCoordinatesFromFloatsToRef(S._x,S._y,S._z,v,D),D}static TransformCoordinatesFromFloatsToRef(S,v,D,z,e){const N=z.m,m=S*N[0]+v*N[4]+D*N[8]+N[12],B=S*N[1]+v*N[5]+D*N[9]+N[13],g=S*N[2]+v*N[6]+D*N[10]+N[14],E=S*N[3]+v*N[7]+D*N[11]+N[15];return e.x=m,e.y=B,e.z=g,e.w=E,e}static TransformNormal(S,v){return I.TransformNormalToRef(S,v,new I)}static TransformNormalToRef(S,v,D){const z=v.m,e=S.x*z[0]+S.y*z[4]+S.z*z[8],N=S.x*z[1]+S.y*z[5]+S.z*z[9],m=S.x*z[2]+S.y*z[6]+S.z*z[10];return D.x=e,D.y=N,D.z=m,D.w=S.w,D}static TransformNormalFromFloatsToRef(S,v,D,z,e,N){const m=e.m;return N.x=S*m[0]+v*m[4]+D*m[8],N.y=S*m[1]+v*m[5]+D*m[9],N.z=S*m[2]+v*m[6]+D*m[10],N.w=z,N}static FromVector3(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new I(S._x,S._y,S._z,v)}static Dot(S,v){return S.x*v.x+S.y*v.y+S.z*v.z+S.w*v.w}}I._V8PerformanceHack=new I(.5,.5,.5,.5),I._ZeroReadOnly=I.Zero(),Object.defineProperties(I.prototype,{dimension:{value:[4]},rank:{value:1}});class K{get x(){return this._x}set x(S){this._x=S,this._isDirty=!0}get y(){return this._y}set y(S){this._y=S,this._isDirty=!0}get z(){return this._z}set z(S){this._z=S,this._isDirty=!0}get w(){return this._w}set w(S){this._w=S,this._isDirty=!0}constructor(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=S,this._y=v,this._z=D,this._w=z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let S=n(this._x);return S=397*S^n(this._y),S=397*S^n(this._z),S=397*S^n(this._w),S}Oe(){return[this._x,this._y,this._z,this._w]}toArray(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S[v]=this._x,S[v+1]=this._y,S[v+2]=this._z,S[v+3]=this._w,this}RD(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(S,v,this)}equals(S){return S&&this._x===S._x&&this._y===S._y&&this._z===S._z&&this._w===S._w}equalsWithEpsilon(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.e;return S&&(0,g.WithinEpsilon)(this._x,S._x,v)&&(0,g.WithinEpsilon)(this._y,S._y,v)&&(0,g.WithinEpsilon)(this._z,S._z,v)&&(0,g.WithinEpsilon)(this._w,S._w,v)}isApprox(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.e;return S&&((0,g.WithinEpsilon)(this._x,S._x,v)&&(0,g.WithinEpsilon)(this._y,S._y,v)&&(0,g.WithinEpsilon)(this._z,S._z,v)&&(0,g.WithinEpsilon)(this._w,S._w,v)||(0,g.WithinEpsilon)(this._x,-S._x,v)&&(0,g.WithinEpsilon)(this._y,-S._y,v)&&(0,g.WithinEpsilon)(this._z,-S._z,v)&&(0,g.WithinEpsilon)(this._w,-S._w,v))}clone(){return new K(this._x,this._y,this._z,this._w)}N(S){return this._x=S._x,this._y=S._y,this._z=S._z,this._w=S._w,this._isDirty=!0,this}oe(S,v,D,z){return this._x=S,this._y=v,this._z=D,this._w=z,this._isDirty=!0,this}set(S,v,D,z){return this.oe(S,v,D,z)}Je(S){return this.oe(S,S,S,S)}add(S){return new K(this._x+S._x,this._y+S._y,this._z+S._z,this._w+S._w)}addInPlace(S){return this._x+=S._x,this._y+=S._y,this._z+=S._z,this._w+=S._w,this._isDirty=!0,this}addToRef(S,v){return v._x=this._x+S._x,v._y=this._y+S._y,v._z=this._z+S._z,v._w=this._w+S._w,v._isDirty=!0,v}addInPlaceFromFloats(S,v,D,z){return this._x+=S,this._y+=v,this._z+=D,this._w+=z,this._isDirty=!0,this}subtractToRef(S,v){return v._x=this._x-S._x,v._y=this._y-S._y,v._z=this._z-S._z,v._w=this._w-S._w,v._isDirty=!0,v}subtractFromFloats(S,v,D,z){return this.subtractFromFloatsToRef(S,v,D,z,new K)}subtractFromFloatsToRef(S,v,D,z,e){return e._x=this._x-S,e._y=this._y-v,e._z=this._z-D,e._w=this._w-z,e._isDirty=!0,e}Ov(S){return new K(this._x-S._x,this._y-S._y,this._z-S._z,this._w-S._w)}tA(S){return this._x-=S._x,this._y-=S._y,this._z-=S._z,this._w-=S._w,this._isDirty=!0,this}scale(S){return new K(this._x*S,this._y*S,this._z*S,this._w*S)}scaleToRef(S,v){return v._x=this._x*S,v._y=this._y*S,v._z=this._z*S,v._w=this._w*S,v._isDirty=!0,v}scaleInPlace(S){return this._x*=S,this._y*=S,this._z*=S,this._w*=S,this._isDirty=!0,this}scaleAndAddToRef(S,v){return v._x+=this._x*S,v._y+=this._y*S,v._z+=this._z*S,v._w+=this._w*S,v._isDirty=!0,v}multiply(S){const v=new K(0,0,0,1);return this.multiplyToRef(S,v),v}multiplyToRef(S,v){const D=this._x*S._w+this._y*S._z-this._z*S._y+this._w*S._x,z=-this._x*S._z+this._y*S._w+this._z*S._x+this._w*S._y,e=this._x*S._y-this._y*S._x+this._z*S._w+this._w*S._z,N=-this._x*S._x-this._y*S._y-this._z*S._z+this._w*S._w;return v.oe(D,z,e,N),v}multiplyInPlace(S){return this.multiplyToRef(S,this)}multiplyByFloats(S,v,D,z){return this._x*=S,this._y*=v,this._z*=D,this._w*=z,this._isDirty=!0,this}divide(S){throw new ReferenceError("Can not divide a quaternion")}divideToRef(S,v){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(S){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new K)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(S){return S._x=-this._x,S._y=-this._y,S._z=-this._z,S._w=-this._w,S._isDirty=!0,S}equalsToFloats(S,v,D,z){return this._x===S&&this._y===v&&this._z===D&&this._w===z}floorToRef(S){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(S){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(S){return S.oe(-this._x,-this._y,-this._z,this._w),S}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new K(-this._x,-this._y,-this._z,this._w)}invert(){const S=this.conjugate(),v=this.lengthSquared();return 0==v||1==v||S.scaleInPlace(1/v),S}invertInPlace(){this.conjugateInPlace();const S=this.lengthSquared();return 0==S||1==S||this.scaleInPlace(1/S),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(S){return 0===S||1===S?this:this.scaleInPlace(1/S)}normalizeToNew(){const S=new K(0,0,0,1);return this.normalizeToRef(S),S}normalizeToRef(S){const v=this.length();return 0===v||1===v?S.oe(this._x,this._y,this._z,this._w):this.scaleToRef(1/v,S)}toEulerAngles(){const S=O.Zero();return this.toEulerAnglesToRef(S),S}toEulerAnglesToRef(S){const v=this._z,D=this._x,z=this._y,e=this._w,N=z*v-D*e,m=.4999999;if(N<-m)S._y=2*Math.atan2(z,e),S._x=Math.PI/2,S._z=0,S._isDirty=!0;else if(N>m)S._y=2*Math.atan2(z,e),S._x=-Math.PI/2,S._z=0,S._isDirty=!0;else{const m=e*e,B=v*v,g=D*D,E=z*z;S._z=Math.atan2(2*(D*z+v*e),-B-g+E+m),S._x=Math.asin(-2*N),S._y=Math.atan2(2*(v*D+z*e),B-g-E+m),S._isDirty=!0}return S}toAlphaBetaGammaToRef(S){const v=this._z,D=this._x,z=this._y,e=this._w,N=Math.sqrt(D*D+z*z),m=Math.sqrt(v*v+e*e),B=2*Math.atan2(N,m),g=2*Math.atan2(v,e),E=2*Math.atan2(z,D),h=(g+E)/2,A=(g-E)/2;return S.set(A,B,h),S}toRotationMatrix(S){return q.FromQuaternionToRef(this,S),S}fromRotationMatrix(S){return K.FromRotationMatrixToRef(S,this),this}dot(S){return this._x*S._x+this._y*S._y+this._z*S._z+this._w*S._w}toAxisAngle(){const S=O.Zero();return{axis:S,angle:this.toAxisAngleToRef(S)}}toAxisAngleToRef(S){let v=0;const D=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),z=this._w;return D>0?(v=2*Math.atan2(D,z),S.set(this._x/D,this._y/D,this._z/D)):(v=0,S.set(1,0,0)),v}static FromRotationMatrix(S){const v=new K;return K.FromRotationMatrixToRef(S,v),v}static FromRotationMatrixToRef(S,v){const D=S.m,z=D[0],e=D[4],N=D[8],m=D[1],B=D[5],g=D[9],E=D[2],h=D[6],A=D[10],w=z+B+A;let n;return w>0?(n=.5/Math.sqrt(w+1),v._w=.25/n,v._x=(h-g)*n,v._y=(N-E)*n,v._z=(m-e)*n,v._isDirty=!0):z>B&&z>A?(n=2*Math.sqrt(1+z-B-A),v._w=(h-g)/n,v._x=.25*n,v._y=(e+m)/n,v._z=(N+E)/n,v._isDirty=!0):B>A?(n=2*Math.sqrt(1+B-z-A),v._w=(N-E)/n,v._x=(e+m)/n,v._y=.25*n,v._z=(g+h)/n,v._isDirty=!0):(n=2*Math.sqrt(1+A-z-B),v._w=(m-e)/n,v._x=(N+E)/n,v._y=(g+h)/n,v._z=.25*n,v._isDirty=!0),v}static Dot(S,v){return S._x*v._x+S._y*v._y+S._z*v._z+S._w*v._w}static AreClose(S,v){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const z=K.Dot(S,v);return 1-z*z<=D}static SmoothToRef(S,v,D,z,e){let N=0===z?1:D/z;return N=(0,g.Clamp)(N,0,1),K.SlerpToRef(S,v,N,e),e}static Zero(){return new K(0,0,0,0)}static Inverse(S){return new K(-S._x,-S._y,-S._z,S._w)}static InverseToRef(S,v){return v.set(-S._x,-S._y,-S._z,S._w),v}static Identity(){return new K(0,0,0,1)}static IsIdentity(S){return S&&0===S._x&&0===S._y&&0===S._z&&1===S._w}static RotationAxis(S,v){return K.RotationAxisToRef(S,v,new K)}static RotationAxisToRef(S,v,D){D._w=Math.cos(v/2);const z=Math.sin(v/2)/S.length();return D._x=S._x*z,D._y=S._y*z,D._z=S._z*z,D._isDirty=!0,D}static uv(S,v){return v||(v=0),new K(S[v],S[v+1],S[v+2],S[v+3])}static FromArrayToRef(S,v,D){return D._x=S[v],D._y=S[v+1],D._z=S[v+2],D._w=S[v+3],D._isDirty=!0,D}static FromFloatsToRef(S,v,D,z,e){return e.oe(S,v,D,z),e}static FromEulerAngles(S,v,D){const z=new K;return K.RotationYawPitchRollToRef(v,S,D,z),z}static FromEulerAnglesToRef(S,v,D,z){return K.RotationYawPitchRollToRef(v,S,D,z),z}static FromEulerVector(S){const v=new K;return K.RotationYawPitchRollToRef(S._y,S._x,S._z,v),v}static FromEulerVectorToRef(S,v){return K.RotationYawPitchRollToRef(S._y,S._x,S._z,v),v}static FromUnitVectorsToRef(S,v,D){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z.e;const N=O.Dot(S,v)+1;return N<e?Math.abs(S.x)>Math.abs(S.z)?D.set(-S.y,S.x,0,0):D.set(0,-S.z,S.y,0):(O.CrossToRef(S,v,s.Rv[0]),D.set(s.Rv[0].x,s.Rv[0].y,s.Rv[0].z,N)),D.normalize()}static RotationYawPitchRoll(S,v,D){const z=new K;return K.RotationYawPitchRollToRef(S,v,D,z),z}static RotationYawPitchRollToRef(S,v,D,z){const e=.5*D,N=.5*v,m=.5*S,B=Math.sin(e),g=Math.cos(e),E=Math.sin(N),h=Math.cos(N),A=Math.sin(m),w=Math.cos(m);return z._x=w*E*g+A*h*B,z._y=A*h*g-w*E*B,z._z=w*h*B-A*E*g,z._w=w*h*g+A*E*B,z._isDirty=!0,z}static RotationAlphaBetaGamma(S,v,D){const z=new K;return K.RotationAlphaBetaGammaToRef(S,v,D,z),z}static RotationAlphaBetaGammaToRef(S,v,D,z){const e=.5*(D+S),N=.5*(D-S),m=.5*v;return z._x=Math.cos(N)*Math.sin(m),z._y=Math.sin(N)*Math.sin(m),z._z=Math.sin(e)*Math.cos(m),z._w=Math.cos(e)*Math.cos(m),z._isDirty=!0,z}static RotationQuaternionFromAxis(S,v,D){const z=new K(0,0,0,0);return K.RotationQuaternionFromAxisToRef(S,v,D,z),z}static RotationQuaternionFromAxisToRef(S,v,D,z){const e=u.Matrix[0];return S=S.normalizeToRef(u.Rv[0]),v=v.normalizeToRef(u.Rv[1]),D=D.normalizeToRef(u.Rv[2]),q.FromXYZAxesToRef(S,v,D,e),K.FromRotationMatrixToRef(e,z),z}static FromLookDirectionLH(S,v){const D=new K;return K.FromLookDirectionLHToRef(S,v,D),D}static FromLookDirectionLHToRef(S,v,D){const z=u.Matrix[0];return q.LookDirectionLHToRef(S,v,z),K.FromRotationMatrixToRef(z,D),D}static FromLookDirectionRH(S,v){const D=new K;return K.FromLookDirectionRHToRef(S,v,D),D}static FromLookDirectionRHToRef(S,v,D){const z=u.Matrix[0];return q.LookDirectionRHToRef(S,v,z),K.FromRotationMatrixToRef(z,D)}static Slerp(S,v,D){const z=K.Identity();return K.SlerpToRef(S,v,D,z),z}static SlerpToRef(S,v,D,z){let e,N,m=S._x*v._x+S._y*v._y+S._z*v._z+S._w*v._w,B=!1;if(m<0&&(B=!0,m=-m),m>.999999)N=1-D,e=B?-D:D;else{const S=Math.acos(m),v=1/Math.sin(S);N=Math.sin((1-D)*S)*v,e=B?-Math.sin(D*S)*v:Math.sin(D*S)*v}return z._x=N*S._x+e*v._x,z._y=N*S._y+e*v._y,z._z=N*S._z+e*v._z,z._w=N*S._w+e*v._w,z._isDirty=!0,z}static Hermite(S,v,D,z,e){const N=e*e,m=e*N,B=2*m-3*N+1,g=-2*m+3*N,E=m-2*N+e,h=m-N,A=S._x*B+D._x*g+v._x*E+z._x*h,w=S._y*B+D._y*g+v._y*E+z._y*h,n=S._z*B+D._z*g+v._z*E+z._z*h,R=S._w*B+D._w*g+v._w*E+z._w*h;return new K(A,w,n,R)}static Hermite1stDerivative(S,v,D,z,e){const N=new K;return this.Hermite1stDerivativeToRef(S,v,D,z,e,N),N}static Hermite1stDerivativeToRef(S,v,D,z,e,N){const m=e*e;return N._x=6*(m-e)*S._x+(3*m-4*e+1)*v._x+6*(-m+e)*D._x+(3*m-2*e)*z._x,N._y=6*(m-e)*S._y+(3*m-4*e+1)*v._y+6*(-m+e)*D._y+(3*m-2*e)*z._y,N._z=6*(m-e)*S._z+(3*m-4*e+1)*v._z+6*(-m+e)*D._z+(3*m-2*e)*z._z,N._w=6*(m-e)*S._w+(3*m-4*e+1)*v._w+6*(-m+e)*D._w+(3*m-2*e)*z._w,N._isDirty=!0,N}static Normalize(S){const v=K.Zero();return K.NormalizeToRef(S,v),v}static NormalizeToRef(S,v){return S.normalizeToRef(v),v}static Clamp(S,v,D){const z=new K;return K.ClampToRef(S,v,D,z),z}static ClampToRef(S,v,D,z){return z.oe((0,g.Clamp)(S.x,v.x,D.x),(0,g.Clamp)(S.y,v.y,D.y),(0,g.Clamp)(S.z,v.z,D.z),(0,g.Clamp)(S.w,v.w,D.w))}static Random(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new K((0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v))}static RandomToRef(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).oe((0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v),(0,g.RandomRange)(S,v))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(S,v){return Math.sqrt(K.DistanceSquared(S,v))}static DistanceSquared(S,v){const D=S.x-v.x,z=S.y-v.y,e=S.z-v.z,N=S.w-v.w;return D*D+z*z+e*e+N*N}static Center(S,v){return K.CenterToRef(S,v,K.Zero())}static CenterToRef(S,v,D){return D.oe((S.x+v.x)/2,(S.y+v.y)/2,(S.z+v.z)/2,(S.w+v.w)/2)}}K._V8PerformanceHack=new K(.5,.5,.5,.5),Object.defineProperties(K.prototype,{dimension:{value:[4]},rank:{value:1}});class q{static get Use64Bits(){return m.e.MatrixUse64Bits}get m(){return this.ve}markAsUpdated(){this.updateFlag=E._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(S){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1],D=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=S,this._isIdentity3x2=S||D,this._isIdentityDirty=!this._isIdentity&&v,this._isIdentity3x2Dirty=!this._isIdentity3x2&&z}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,m.e.MatrixTrackPrecisionChange&&m.e.MatrixTrackedMatrices.push(this),this.ve=new m.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const S=this.ve;this._isIdentity=1===S[0]&&0===S[1]&&0===S[2]&&0===S[3]&&0===S[4]&&1===S[5]&&0===S[6]&&0===S[7]&&0===S[8]&&0===S[9]&&1===S[10]&&0===S[11]&&0===S[12]&&0===S[13]&&0===S[14]&&1===S[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ve[0]||1!==this.ve[5]||1!==this.ve[15]||0!==this.ve[1]||0!==this.ve[2]||0!==this.ve[3]||0!==this.ve[4]||0!==this.ve[6]||0!==this.ve[7]||0!==this.ve[8]||0!==this.ve[9]||0!==this.ve[10]||0!==this.ve[11]||0!==this.ve[12]||0!==this.ve[13]||0!==this.ve[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const S=this.ve,v=S[0],D=S[1],z=S[2],e=S[3],N=S[4],m=S[5],B=S[6],g=S[7],E=S[8],h=S[9],A=S[10],w=S[11],n=S[12],R=S[13],O=S[14],I=S[15],K=A*I-O*w,q=h*I-R*w,u=h*O-R*A,s=E*I-n*w,r=E*O-A*n,d=E*R-n*h;return v*+(m*K-B*q+g*u)+D*-(N*K-B*s+g*r)+z*+(N*q-m*s+g*d)+e*-(N*u-m*r+B*d)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!S)return this.ve;const D=this.ve;for(let z=0;z<16;z++)S[v+z]=D[z];return this}Oe(){return this.ve}RD(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q.FromArrayToRef(S,v,this)}oe(){for(var S=arguments.length,v=new Array(S),D=0;D<S;D++)v[D]=arguments[D];return q.FromArrayToRef(v,0,this)}set(){const S=this.ve;for(let v=0;v<16;v++)S[v]=v<0||arguments.length<=v?void 0:arguments[v];return this.markAsUpdated(),this}Je(S){const v=this.ve;for(let D=0;D<16;D++)v[D]=S;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return q.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(S){const v=new q;return this.addToRef(S,v),v}addToRef(S,v){const D=this.ve,z=v.ve,e=S.m;for(let N=0;N<16;N++)z[N]=D[N]+e[N];return v.markAsUpdated(),v}addToSelf(S){const v=this.ve,D=S.m;return v[0]+=D[0],v[1]+=D[1],v[2]+=D[2],v[3]+=D[3],v[4]+=D[4],v[5]+=D[5],v[6]+=D[6],v[7]+=D[7],v[8]+=D[8],v[9]+=D[9],v[10]+=D[10],v[11]+=D[11],v[12]+=D[12],v[13]+=D[13],v[14]+=D[14],v[15]+=D[15],this.markAsUpdated(),this}addInPlace(S){const v=this.ve,D=S.m;for(let z=0;z<16;z++)v[z]+=D[z];return this.markAsUpdated(),this}addInPlaceFromFloats(){const S=this.ve;for(let v=0;v<16;v++)S[v]+=v<0||arguments.length<=v?void 0:arguments[v];return this.markAsUpdated(),this}Ov(S){const v=this.ve,D=S.m;for(let z=0;z<16;z++)v[z]-=D[z];return this.markAsUpdated(),this}subtractToRef(S,v){const D=this.ve,z=S.m,e=v.ve;for(let N=0;N<16;N++)e[N]=D[N]-z[N];return v.markAsUpdated(),v}tA(S){const v=this.ve,D=S.m;for(let z=0;z<16;z++)v[z]-=D[z];return this.markAsUpdated(),this}subtractFromFloats(){for(var S=arguments.length,v=new Array(S),D=0;D<S;D++)v[D]=arguments[D];return this.subtractFromFloatsToRef(...v,new q)}subtractFromFloatsToRef(){for(var S=arguments.length,v=new Array(S),D=0;D<S;D++)v[D]=arguments[D];const z=v.pop(),e=this.ve,N=z.ve,m=v;for(let B=0;B<16;B++)N[B]=e[B]-m[B];return z.markAsUpdated(),z}invertToRef(S){return!0===this._isIdentity?(q.IdentityToRef(S),S):(w(this,S.Oe())?S.markAsUpdated():S.N(this),S)}addAtIndex(S,v){return this.ve[S]+=v,this.markAsUpdated(),this}multiplyAtIndex(S,v){return this.ve[S]*=v,this.markAsUpdated(),this}setTranslationFromFloats(S,v,D){return this.ve[12]=S,this.ve[13]=v,this.ve[14]=D,this.markAsUpdated(),this}addTranslationFromFloats(S,v,D){return this.ve[12]+=S,this.ve[13]+=v,this.ve[14]+=D,this.markAsUpdated(),this}setTranslation(S){return this.setTranslationFromFloats(S._x,S._y,S._z)}getTranslation(){return new O(this.ve[12],this.ve[13],this.ve[14])}getTranslationToRef(S){return S.x=this.ve[12],S.y=this.ve[13],S.z=this.ve[14],S}removeRotationAndScaling(){const S=this.m;return q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,S[12],S[13],S[14],S[15],this),this._updateIdentityStatus(0===S[12]&&0===S[13]&&0===S[14]&&1===S[15]),this}N(S){S.copyToArray(this.ve);const v=S;return this.updateFlag=v.updateFlag,this._updateIdentityStatus(v._isIdentity,v._isIdentityDirty,v._isIdentity3x2,v._isIdentity3x2Dirty),this}copyToArray(S){return A(this,S,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(S){const v=new q;return this.multiplyToRef(S,v),v}multiplyInPlace(S){const v=this.ve,D=S.m;for(let z=0;z<16;z++)v[z]*=D[z];return this.markAsUpdated(),this}multiplyByFloats(){const S=this.ve;for(let v=0;v<16;v++)S[v]*=v<0||arguments.length<=v?void 0:arguments[v];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var S=arguments.length,v=new Array(S),D=0;D<S;D++)v[D]=arguments[D];const z=v.pop(),e=this.ve,N=z.ve,m=v;for(let B=0;B<16;B++)N[B]=e[B]*m[B];return z.markAsUpdated(),z}multiplyToRef(S,v){return this._isIdentity?(v.N(S),v):S._isIdentity?(v.N(this),v):(this.multiplyToArray(S,v.ve,0),v.markAsUpdated(),v)}multiplyToArray(S,v,D){return h(this,S,v,D),this}divide(S){return this.divideToRef(S,new q)}divideToRef(S,v){const D=this.ve,z=S.m,e=v.ve;for(let N=0;N<16;N++)e[N]=D[N]/z[N];return v.markAsUpdated(),v}divideInPlace(S){const v=this.ve,D=S.m;for(let z=0;z<16;z++)v[z]/=D[z];return this.markAsUpdated(),this}minimizeInPlace(S){const v=this.ve,D=S.m;for(let z=0;z<16;z++)v[z]=Math.min(v[z],D[z]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const S=this.ve;for(let v=0;v<16;v++)S[v]=Math.min(S[v],v<0||arguments.length<=v?void 0:arguments[v]);return this.markAsUpdated(),this}maximizeInPlace(S){const v=this.ve,D=S.m;for(let z=0;z<16;z++)v[z]=Math.min(v[z],D[z]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const S=this.ve;for(let v=0;v<16;v++)S[v]=Math.min(S[v],v<0||arguments.length<=v?void 0:arguments[v]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new q)}negateInPlace(){const S=this.ve;for(let v=0;v<16;v++)S[v]=-S[v];return this.markAsUpdated(),this}negateToRef(S){const v=this.ve,D=S.ve;for(let z=0;z<16;z++)D[z]=-v[z];return S.markAsUpdated(),S}equals(S){const v=S;if(!v)return!1;if((this._isIdentity||v._isIdentity)&&!this._isIdentityDirty&&!v._isIdentityDirty)return this._isIdentity&&v._isIdentity;const D=this.m,z=v.m;return D[0]===z[0]&&D[1]===z[1]&&D[2]===z[2]&&D[3]===z[3]&&D[4]===z[4]&&D[5]===z[5]&&D[6]===z[6]&&D[7]===z[7]&&D[8]===z[8]&&D[9]===z[9]&&D[10]===z[10]&&D[11]===z[11]&&D[12]===z[12]&&D[13]===z[13]&&D[14]===z[14]&&D[15]===z[15]}equalsWithEpsilon(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const D=this.ve,z=S.m;for(let e=0;e<16;e++)if(!(0,g.WithinEpsilon)(D[e],z[e],v))return!1;return!0}equalsToFloats(){const S=this.ve;for(let v=0;v<16;v++)if(S[v]!=(v<0||arguments.length<=v?void 0:arguments[v]))return!1;return!0}floor(){return this.floorToRef(new q)}floorToRef(S){const v=this.ve,D=S.ve;for(let z=0;z<16;z++)D[z]=Math.floor(v[z]);return S.markAsUpdated(),S}fract(){return this.fractToRef(new q)}fractToRef(S){const v=this.ve,D=S.ve;for(let z=0;z<16;z++)D[z]=v[z]-Math.floor(v[z]);return S.markAsUpdated(),S}clone(){const S=new q;return S.N(this),S}getClassName(){return"Matrix"}getHashCode(){let S=n(this.ve[0]);for(let v=1;v<16;v++)S=397*S^n(this.ve[v]);return S}decomposeToTransformNode(S){return S.rotationQuaternion=S.rotationQuaternion||new K,this.decompose(S.Me,S.rotationQuaternion,S.position)}decompose(S,v,D,z){let e=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return D&&D.Je(0),S&&S.Je(1),v&&v.oe(0,0,0,1),!0;const N=this.ve;if(D&&D.oe(N[12],N[13],N[14]),(S=S||u.Rv[0]).x=Math.sqrt(N[0]*N[0]+N[1]*N[1]+N[2]*N[2]),S.y=Math.sqrt(N[4]*N[4]+N[5]*N[5]+N[6]*N[6]),S.z=Math.sqrt(N[8]*N[8]+N[9]*N[9]+N[10]*N[10]),z){const v=(e?z.absoluteScaling.x:z.Me.x)<0?-1:1,D=(e?z.absoluteScaling.y:z.Me.y)<0?-1:1,N=(e?z.absoluteScaling.z:z.Me.z)<0?-1:1;S.x*=v,S.y*=D,S.z*=N}else this.determinant()<=0&&(S.y*=-1);if(0===S._x||0===S._y||0===S._z)return v&&v.oe(0,0,0,1),!1;if(v){const D=1/S._x,z=1/S._y,e=1/S._z;q.FromValuesToRef(N[0]*D,N[1]*D,N[2]*D,0,N[4]*z,N[5]*z,N[6]*z,0,N[8]*e,N[9]*e,N[10]*e,0,0,0,0,1,u.Matrix[0]),K.FromRotationMatrixToRef(u.Matrix[0],v)}return!0}getRow(S){if(S<0||S>3)return null;const v=4*S;return new I(this.ve[v+0],this.ve[v+1],this.ve[v+2],this.ve[v+3])}getRowToRef(S,v){if(S>=0&&S<=3){const D=4*S;v.x=this.ve[D+0],v.y=this.ve[D+1],v.z=this.ve[D+2],v.w=this.ve[D+3]}return v}setRow(S,v){return this.setRowFromFloats(S,v.x,v.y,v.z,v.w)}transpose(){const S=new q;return q.TransposeToRef(this,S),S}transposeToRef(S){return q.TransposeToRef(this,S),S}setRowFromFloats(S,v,D,z,e){if(S<0||S>3)return this;const N=4*S;return this.ve[N+0]=v,this.ve[N+1]=D,this.ve[N+2]=z,this.ve[N+3]=e,this.markAsUpdated(),this}scale(S){const v=new q;return this.scaleToRef(S,v),v}scaleToRef(S,v){for(let D=0;D<16;D++)v.ve[D]=this.ve[D]*S;return v.markAsUpdated(),v}scaleAndAddToRef(S,v){for(let D=0;D<16;D++)v.ve[D]+=this.ve[D]*S;return v.markAsUpdated(),v}scaleInPlace(S){const v=this.ve;for(let D=0;D<16;D++)v[D]*=S;return this.markAsUpdated(),this}toNormalMatrix(S){const v=u.Matrix[0];this.invertToRef(v),v.transposeToRef(S);const D=S.ve;return q.FromValuesToRef(D[0],D[1],D[2],0,D[4],D[5],D[6],0,D[8],D[9],D[10],0,0,0,0,1,S),S}getRotationMatrix(){const S=new q;return this.getRotationMatrixToRef(S),S}getRotationMatrixToRef(S){const v=u.Rv[0];if(!this.decompose(v))return q.IdentityToRef(S),S;const D=this.ve,z=1/v._x,e=1/v._y,N=1/v._z;return q.FromValuesToRef(D[0]*z,D[1]*z,D[2]*z,0,D[4]*e,D[5]*e,D[6]*e,0,D[8]*N,D[9]*N,D[10]*N,0,0,0,0,1,S),S}toggleModelMatrixHandInPlace(){const S=this.ve;return S[2]*=-1,S[6]*=-1,S[8]*=-1,S[9]*=-1,S[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const S=this.ve;return S[8]*=-1,S[9]*=-1,S[10]*=-1,S[11]*=-1,this.markAsUpdated(),this}static uv(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const D=new q;return q.FromArrayToRef(S,v,D),D}static FromArrayToRef(S,v,D){for(let z=0;z<16;z++)D.ve[z]=S[z+v];return D.markAsUpdated(),D}static FromFloat32ArrayToRefScaled(S,v,D,z){return z.ve[0]=S[0+v]*D,z.ve[1]=S[1+v]*D,z.ve[2]=S[2+v]*D,z.ve[3]=S[3+v]*D,z.ve[4]=S[4+v]*D,z.ve[5]=S[5+v]*D,z.ve[6]=S[6+v]*D,z.ve[7]=S[7+v]*D,z.ve[8]=S[8+v]*D,z.ve[9]=S[9+v]*D,z.ve[10]=S[10+v]*D,z.ve[11]=S[11+v]*D,z.ve[12]=S[12+v]*D,z.ve[13]=S[13+v]*D,z.ve[14]=S[14+v]*D,z.ve[15]=S[15+v]*D,z.markAsUpdated(),z}static get IdentityReadOnly(){return q._IdentityReadOnly}static FromValuesToRef(S,v,D,z,e,N,m,B,g,E,h,A,w,n,R,O,I){const K=I.ve;K[0]=S,K[1]=v,K[2]=D,K[3]=z,K[4]=e,K[5]=N,K[6]=m,K[7]=B,K[8]=g,K[9]=E,K[10]=h,K[11]=A,K[12]=w,K[13]=n,K[14]=R,K[15]=O,I.markAsUpdated()}static FromValues(S,v,D,z,e,N,m,B,g,E,h,A,w,n,R,O){const I=new q,K=I.ve;return K[0]=S,K[1]=v,K[2]=D,K[3]=z,K[4]=e,K[5]=N,K[6]=m,K[7]=B,K[8]=g,K[9]=E,K[10]=h,K[11]=A,K[12]=w,K[13]=n,K[14]=R,K[15]=O,I.markAsUpdated(),I}static Compose(S,v,D){const z=new q;return q.ComposeToRef(S,v,D,z),z}static ComposeToRef(S,v,D,z){const e=z.ve,N=v._x,m=v._y,B=v._z,g=v._w,E=N+N,h=m+m,A=B+B,w=N*E,n=N*h,R=N*A,O=m*h,I=m*A,K=B*A,q=g*E,u=g*h,s=g*A,r=S._x,d=S._y,x=S._z;return e[0]=(1-(O+K))*r,e[1]=(n+s)*r,e[2]=(R-u)*r,e[3]=0,e[4]=(n-s)*d,e[5]=(1-(w+K))*d,e[6]=(I+q)*d,e[7]=0,e[8]=(R+u)*x,e[9]=(I-q)*x,e[10]=(1-(w+O))*x,e[11]=0,e[12]=D._x,e[13]=D._y,e[14]=D._z,e[15]=1,z.markAsUpdated(),z}static Identity(){const S=q.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return S._updateIdentityStatus(!0),S}static IdentityToRef(S){return q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,S),S._updateIdentityStatus(!0),S}static Zero(){const S=q.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return S._updateIdentityStatus(!1),S}static RotationX(S){const v=new q;return q.RotationXToRef(S,v),v}static Invert(S){const v=new q;return S.invertToRef(v),v}static RotationXToRef(S,v){const D=Math.sin(S),z=Math.cos(S);return q.FromValuesToRef(1,0,0,0,0,z,D,0,0,-D,z,0,0,0,0,1,v),v._updateIdentityStatus(1===z&&0===D),v}static RotationY(S){const v=new q;return q.RotationYToRef(S,v),v}static RotationYToRef(S,v){const D=Math.sin(S),z=Math.cos(S);return q.FromValuesToRef(z,0,-D,0,0,1,0,0,D,0,z,0,0,0,0,1,v),v._updateIdentityStatus(1===z&&0===D),v}static RotationZ(S){const v=new q;return q.RotationZToRef(S,v),v}static RotationZToRef(S,v){const D=Math.sin(S),z=Math.cos(S);return q.FromValuesToRef(z,D,0,0,-D,z,0,0,0,0,1,0,0,0,0,1,v),v._updateIdentityStatus(1===z&&0===D),v}static RotationAxis(S,v){const D=new q;return q.RotationAxisToRef(S,v,D),D}static RotationAxisToRef(S,v,D){const z=Math.sin(-v),e=Math.cos(-v),N=1-e;S=S.normalizeToRef(u.Rv[0]);const m=D.ve;return m[0]=S._x*S._x*N+e,m[1]=S._x*S._y*N-S._z*z,m[2]=S._x*S._z*N+S._y*z,m[3]=0,m[4]=S._y*S._x*N+S._z*z,m[5]=S._y*S._y*N+e,m[6]=S._y*S._z*N-S._x*z,m[7]=0,m[8]=S._z*S._x*N-S._y*z,m[9]=S._z*S._y*N+S._x*z,m[10]=S._z*S._z*N+e,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,D.markAsUpdated(),D}static RotationAlignToRef(S,v,D){let e=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const N=O.Dot(v,S),m=D.ve;if(N<-1+z.e)m[0]=-1,m[1]=0,m[2]=0,m[3]=0,m[4]=0,m[5]=e?1:-1,m[6]=0,m[7]=0,m[8]=0,m[9]=0,m[10]=e?-1:1,m[11]=0;else{const D=O.Cross(v,S),z=1/(1+N);m[0]=D._x*D._x*z+N,m[1]=D._y*D._x*z-D._z,m[2]=D._z*D._x*z+D._y,m[3]=0,m[4]=D._x*D._y*z+D._z,m[5]=D._y*D._y*z+N,m[6]=D._z*D._y*z-D._x,m[7]=0,m[8]=D._x*D._z*z-D._y,m[9]=D._y*D._z*z+D._x,m[10]=D._z*D._z*z+N,m[11]=0}return m[12]=0,m[13]=0,m[14]=0,m[15]=1,D.markAsUpdated(),D}static RotationYawPitchRoll(S,v,D){const z=new q;return q.RotationYawPitchRollToRef(S,v,D,z),z}static RotationYawPitchRollToRef(S,v,D,z){return K.RotationYawPitchRollToRef(S,v,D,u.Quaternion[0]),u.Quaternion[0].toRotationMatrix(z),z}static Scaling(S,v,D){const z=new q;return q.ScalingToRef(S,v,D,z),z}static ScalingToRef(S,v,D,z){return q.FromValuesToRef(S,0,0,0,0,v,0,0,0,0,D,0,0,0,0,1,z),z._updateIdentityStatus(1===S&&1===v&&1===D),z}static Translation(S,v,D){const z=new q;return q.TranslationToRef(S,v,D,z),z}static TranslationToRef(S,v,D,z){return q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,S,v,D,1,z),z._updateIdentityStatus(0===S&&0===v&&0===D),z}static Lerp(S,v,D){const z=new q;return q.LerpToRef(S,v,D,z),z}static LerpToRef(S,v,D,z){const e=z.ve,N=S.m,m=v.m;for(let B=0;B<16;B++)e[B]=N[B]*(1-D)+m[B]*D;return z.markAsUpdated(),z}static DecomposeLerp(S,v,D){const z=new q;return q.DecomposeLerpToRef(S,v,D,z),z}static DecomposeLerpToRef(S,v,D,z){const e=u.Rv[0],N=u.Quaternion[0],m=u.Rv[1];S.decompose(e,N,m);const B=u.Rv[2],g=u.Quaternion[1],E=u.Rv[3];v.decompose(B,g,E);const h=u.Rv[4];O.LerpToRef(e,B,D,h);const A=u.Quaternion[2];K.SlerpToRef(N,g,D,A);const w=u.Rv[5];return O.LerpToRef(m,E,D,w),q.ComposeToRef(h,A,w,z),z}static LookAtLH(S,v,D){const z=new q;return q.LookAtLHToRef(S,v,D,z),z}static LookAtLHToRef(S,v,D,z){const e=u.Rv[0],N=u.Rv[1],m=u.Rv[2];v.subtractToRef(S,m),m.normalize(),O.CrossToRef(D,m,e);const B=e.lengthSquared();0===B?e.x=1:e.normalizeFromLength(Math.sqrt(B)),O.CrossToRef(m,e,N),N.normalize();const g=-O.Dot(e,S),E=-O.Dot(N,S),h=-O.Dot(m,S);return q.FromValuesToRef(e._x,N._x,m._x,0,e._y,N._y,m._y,0,e._z,N._z,m._z,0,g,E,h,1,z),z}static LookAtRH(S,v,D){const z=new q;return q.LookAtRHToRef(S,v,D,z),z}static LookAtRHToRef(S,v,D,z){const e=u.Rv[0],N=u.Rv[1],m=u.Rv[2];S.subtractToRef(v,m),m.normalize(),O.CrossToRef(D,m,e);const B=e.lengthSquared();0===B?e.x=1:e.normalizeFromLength(Math.sqrt(B)),O.CrossToRef(m,e,N),N.normalize();const g=-O.Dot(e,S),E=-O.Dot(N,S),h=-O.Dot(m,S);return q.FromValuesToRef(e._x,N._x,m._x,0,e._y,N._y,m._y,0,e._z,N._z,m._z,0,g,E,h,1,z),z}static LookDirectionLH(S,v){const D=new q;return q.LookDirectionLHToRef(S,v,D),D}static LookDirectionLHToRef(S,v,D){const z=u.Rv[0];z.N(S),z.scaleInPlace(-1);const e=u.Rv[1];return O.CrossToRef(v,z,e),q.FromValuesToRef(e._x,e._y,e._z,0,v._x,v._y,v._z,0,z._x,z._y,z._z,0,0,0,0,1,D),D}static LookDirectionRH(S,v){const D=new q;return q.LookDirectionRHToRef(S,v,D),D}static LookDirectionRHToRef(S,v,D){const z=u.Rv[2];return O.CrossToRef(v,S,z),q.FromValuesToRef(z._x,z._y,z._z,0,v._x,v._y,v._z,0,S._x,S._y,S._z,0,0,0,0,1,D),D}static OrthoLH(S,v,D,z,e){const N=new q;return q.OrthoLHToRef(S,v,D,z,N,e),N}static OrthoLHToRef(S,v,D,z,e,N){const m=2/S,B=2/v,g=2/(z-D),E=-(z+D)/(z-D);return q.FromValuesToRef(m,0,0,0,0,B,0,0,0,0,g,0,0,0,E,1,e),N&&e.multiplyToRef(r,e),e._updateIdentityStatus(1===m&&1===B&&1===g&&0===E),e}static OrthoOffCenterLH(S,v,D,z,e,N,m){const B=new q;return q.OrthoOffCenterLHToRef(S,v,D,z,e,N,B,m),B}static OrthoOffCenterLHToRef(S,v,D,z,e,N,m,B){const g=2/(v-S),E=2/(z-D),h=2/(N-e),A=-(N+e)/(N-e),w=(S+v)/(S-v),n=(z+D)/(D-z);return q.FromValuesToRef(g,0,0,0,0,E,0,0,0,0,h,0,w,n,A,1,m),B&&m.multiplyToRef(r,m),m.markAsUpdated(),m}static ObliqueOffCenterLHToRef(S,v,D,z,e,N,m,B,g,E,h){const A=-m*Math.cos(B),w=-m*Math.sin(B);return q.TranslationToRef(0,0,-g,u.Matrix[1]),q.FromValuesToRef(1,0,0,0,0,1,0,0,A,w,1,0,0,0,0,1,u.Matrix[0]),u.Matrix[1].multiplyToRef(u.Matrix[0],u.Matrix[0]),q.TranslationToRef(0,0,g,u.Matrix[1]),u.Matrix[0].multiplyToRef(u.Matrix[1],u.Matrix[0]),q.OrthoOffCenterLHToRef(S,v,D,z,e,N,E,h),u.Matrix[0].multiplyToRef(E,E),E}static OrthoOffCenterRH(S,v,D,z,e,N,m){const B=new q;return q.OrthoOffCenterRHToRef(S,v,D,z,e,N,B,m),B}static OrthoOffCenterRHToRef(S,v,D,z,e,N,m,B){return q.OrthoOffCenterLHToRef(S,v,D,z,e,N,m,B),m.ve[10]*=-1,m}static ObliqueOffCenterRHToRef(S,v,D,z,e,N,m,B,g,E,h){const A=m*Math.cos(B),w=m*Math.sin(B);return q.TranslationToRef(0,0,g,u.Matrix[1]),q.FromValuesToRef(1,0,0,0,0,1,0,0,A,w,1,0,0,0,0,1,u.Matrix[0]),u.Matrix[1].multiplyToRef(u.Matrix[0],u.Matrix[0]),q.TranslationToRef(0,0,-g,u.Matrix[1]),u.Matrix[0].multiplyToRef(u.Matrix[1],u.Matrix[0]),q.OrthoOffCenterRHToRef(S,v,D,z,e,N,E,h),u.Matrix[0].multiplyToRef(E,E),E}static PerspectiveLH(S,v,D,z,e){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const m=new q,B=2*D/S,g=2*D/v,E=(z+D)/(z-D),h=-2*z*D/(z-D),A=Math.tan(N);return q.FromValuesToRef(B,0,0,0,0,g,0,A,0,0,E,1,0,0,h,0,m),e&&m.multiplyToRef(r,m),m._updateIdentityStatus(!1),m}static PerspectiveFovLH(S,v,D,z,e){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,m=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const B=new q;return q.PerspectiveFovLHToRef(S,v,D,z,B,!0,e,N,m),B}static PerspectiveFovLHToRef(S,v,D,z,e){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],m=arguments.length>6?arguments[6]:void 0,B=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,g=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const E=D,h=z,A=1/Math.tan(.5*S),w=N?A/v:A,n=N?A:A*v,R=g&&0===E?-1:0!==h?(h+E)/(h-E):1,O=g&&0===E?2*h:0!==h?-2*h*E/(h-E):-2*E,I=Math.tan(B);return q.FromValuesToRef(w,0,0,0,0,n,0,I,0,0,R,1,0,0,O,0,e),m&&e.multiplyToRef(r,e),e._updateIdentityStatus(!1),e}static PerspectiveFovReverseLHToRef(S,v,D,z,e){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],m=arguments.length>6?arguments[6]:void 0,B=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const g=1/Math.tan(.5*S),E=N?g/v:g,h=N?g:g*v,A=Math.tan(B);return q.FromValuesToRef(E,0,0,0,0,h,0,A,0,0,-D,1,0,0,1,0,e),m&&e.multiplyToRef(r,e),e._updateIdentityStatus(!1),e}static PerspectiveFovRH(S,v,D,z,e){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,m=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const B=new q;return q.PerspectiveFovRHToRef(S,v,D,z,B,!0,e,N,m),B}static PerspectiveFovRHToRef(S,v,D,z,e){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],m=arguments.length>6?arguments[6]:void 0,B=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,g=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const E=D,h=z,A=1/Math.tan(.5*S),w=N?A/v:A,n=N?A:A*v,R=g&&0===E?1:0!==h?-(h+E)/(h-E):-1,O=g&&0===E?2*h:0!==h?-2*h*E/(h-E):-2*E,I=Math.tan(B);return q.FromValuesToRef(w,0,0,0,0,n,0,I,0,0,R,-1,0,0,O,0,e),m&&e.multiplyToRef(r,e),e._updateIdentityStatus(!1),e}static PerspectiveFovReverseRHToRef(S,v,D,z,e){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],m=arguments.length>6?arguments[6]:void 0,B=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const g=1/Math.tan(.5*S),E=N?g/v:g,h=N?g:g*v,A=Math.tan(B);return q.FromValuesToRef(E,0,0,0,0,h,0,A,0,0,-D,-1,0,0,-1,0,e),m&&e.multiplyToRef(r,e),e._updateIdentityStatus(!1),e}static GetFinalMatrix(S,v,D,z,e,N){const m=S.width,B=S.height,g=S.x,E=S.y,h=q.FromValues(m/2,0,0,0,0,-B/2,0,0,0,0,N-e,0,g+m/2,B/2+E,e,1),A=new q;return v.multiplyToRef(D,A),A.multiplyToRef(z,A),A.multiplyToRef(h,A)}static GetAsMatrix2x2(S){const v=S.m,D=[v[0],v[1],v[4],v[5]];return m.e.MatrixUse64Bits?D:new Float32Array(D)}static GetAsMatrix3x3(S){const v=S.m,D=[v[0],v[1],v[2],v[4],v[5],v[6],v[8],v[9],v[10]];return m.e.MatrixUse64Bits?D:new Float32Array(D)}static Transpose(S){const v=new q;return q.TransposeToRef(S,v),v}static TransposeToRef(S,v){const D=S.m,z=D[0],e=D[4],N=D[8],m=D[12],B=D[1],g=D[5],E=D[9],h=D[13],A=D[2],w=D[6],n=D[10],R=D[14],O=D[3],I=D[7],K=D[11],q=D[15],u=v.ve;return u[0]=z,u[1]=e,u[2]=N,u[3]=m,u[4]=B,u[5]=g,u[6]=E,u[7]=h,u[8]=A,u[9]=w,u[10]=n,u[11]=R,u[12]=O,u[13]=I,u[14]=K,u[15]=q,v.markAsUpdated(),v._updateIdentityStatus(S._isIdentity,S._isIdentityDirty),v}static Reflection(S){const v=new q;return q.ReflectionToRef(S,v),v}static ReflectionToRef(S,v){S.normalize();const D=S.normal.x,z=S.normal.y,e=S.normal.z,N=-2*D,m=-2*z,B=-2*e;return q.FromValuesToRef(N*D+1,m*D,B*D,0,N*z,m*z+1,B*z,0,N*e,m*e,B*e+1,0,N*S.d,m*S.d,B*S.d,1,v),v}static FromXYZAxesToRef(S,v,D,z){return q.FromValuesToRef(S._x,S._y,S._z,0,v._x,v._y,v._z,0,D._x,D._y,D._z,0,0,0,0,1,z),z}static FromQuaternionToRef(S,v){const D=S._x*S._x,z=S._y*S._y,e=S._z*S._z,N=S._x*S._y,m=S._z*S._w,B=S._z*S._x,g=S._y*S._w,E=S._y*S._z,h=S._x*S._w;return v.ve[0]=1-2*(z+e),v.ve[1]=2*(N+m),v.ve[2]=2*(B-g),v.ve[3]=0,v.ve[4]=2*(N-m),v.ve[5]=1-2*(e+D),v.ve[6]=2*(E+h),v.ve[7]=0,v.ve[8]=2*(B+g),v.ve[9]=2*(E-h),v.ve[10]=1-2*(z+D),v.ve[11]=0,v.ve[12]=0,v.ve[13]=0,v.ve[14]=0,v.ve[15]=1,v.markAsUpdated(),v}}q._IdentityReadOnly=q.Identity(),Object.defineProperties(q.prototype,{dimension:{value:[4,4]},rank:{value:2}});class u{}u.Rv=(0,e.e)(11,O.Zero),u.Matrix=(0,e.e)(2,q.Identity),u.Quaternion=(0,e.e)(3,K.Zero);class s{}s.Vector2=(0,e.e)(3,R.Zero),s.Rv=(0,e.e)(13,O.Zero),s.Vector4=(0,e.e)(3,I.Zero),s.Quaternion=(0,e.e)(3,K.Zero),s.Matrix=(0,e.e)(8,q.Identity),(0,N.f)("BABYLON.Vector2",R),(0,N.f)("BABYLON.Vector3",O),(0,N.f)("BABYLON.Vector4",I),(0,N.f)("BABYLON.Matrix",q);const r=q.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11386:(S,v,D)=>{function z(S,v){const D=[];for(let z=0;z<S;++z)D.push(v());return D}function e(S,v){return z(S,v)}D.d(v,{d:()=>z,e:()=>e,h:()=>m});const N=["push","splice","pop","shift","unshift"];function m(S,v){const D=N.map((D=>function(S,v,D){const z=S[v];if("function"!==typeof z)return null;const e=function(){const z=S.length,N=e.previous.apply(S,arguments);return D(v,z),N};return z.next=e,e.previous=z,S[v]=e,()=>{const D=e.previous;if(!D)return;const z=e.next;z?(D.next=z,z.previous=D):(D.next=void 0,S[v]=D),e.next=void 0,e.previous=void 0}}(S,D,v)));return()=>{for(const S of D)null===S||void 0===S||S()}}}}]);