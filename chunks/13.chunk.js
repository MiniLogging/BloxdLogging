"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12730:(a,R,Y)=>{Y.r(R),Y.d(R,{_BasisTextureLoader:()=>v});var T,c=Y(10741),K=Y(11286),g=Y(10865);function t(){const a=0,R=1,Y=2,T=3,c=6,K=8,g=9,t=10,U=14;let b=null;function C(a,R,Y,T,c){const K=a.getImageTranscodedSizeInBytes(R,Y,T);let g=new Uint8Array(K);if(!a.transcodeImage(g,R,Y,T,1,0))return null;if(c){g=function(a,R,Y,T){const c=new Uint16Array(4),K=new Uint16Array(Y*T),g=Y/4,t=T/4;for(let U=0;U<t;U++)for(let T=0;T<g;T++){const t=R+8*(U*g+T);c[0]=a[t]|a[t+1]<<8,c[1]=a[t+2]|a[t+3]<<8,c[2]=(2*(31&c[0])+1*(31&c[1]))/3|(2*(2016&c[0])+1*(2016&c[1]))/3&2016|(2*(63488&c[0])+1*(63488&c[1]))/3&63488,c[3]=(2*(31&c[1])+1*(31&c[0]))/3|(2*(2016&c[1])+1*(2016&c[0]))/3&2016|(2*(63488&c[1])+1*(63488&c[0]))/3&63488;for(let R=0;R<4;R++){const g=a[t+4+R];let b=(4*U+R)*Y+4*T;K[b++]=c[3&g],K[b++]=c[g>>2&3],K[b++]=c[g>>4&3],K[b++]=c[g>>6&3]}}return K}(g,0,a.getImageWidth(R,Y)+3&-4,a.getImageHeight(R,Y)+3&-4)}return g}onmessage=e=>{if("init"===e.data.action){if(e.data.url)try{importScripts(e.data.url)}catch(Z){postMessage({action:"error",error:Z})}b||(b=BASIS({wasmBinary:e.data.wasmBinary})),null!==b&&b.then((a=>{BASIS=a,a.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===e.data.action){const b=e.data.config,Z=e.data.imageData,W=new BASIS.BasisFile(Z),o=function(a){const R=a.getHasAlpha(),Y=a.getNumImages(),T=[];for(let c=0;c<Y;c++){const R={levels:[]},Y=a.getNumLevels(c);for(let T=0;T<Y;T++){const Y={width:a.getImageWidth(c,T),height:a.getImageHeight(c,T)};R.levels.push(Y)}T.push(R)}return{ue:R,images:T}}(W);let i=e.data.ignoreSupportedFormats?null:function(b,C){let e=null;b.supportedCompressionFormats&&(e=b.supportedCompressionFormats.astc?t:b.supportedCompressionFormats.bc7?c:b.supportedCompressionFormats.s3tc?C.ue?T:Y:b.supportedCompressionFormats.pvrtc?C.ue?g:K:b.supportedCompressionFormats.etc2?R:b.supportedCompressionFormats.etc1?a:U);return e}(e.data.config,o),d=!1;null===i&&(d=!0,i=o.ue?T:Y);let v=!0;W.startTranscoding()||(v=!1);const A=[];for(let a=0;a<o.images.length&&v;a++){const R=o.images[a];if(void 0===b.loadSingleImage||b.loadSingleImage===a){let Y=R.levels.length;!1===b.loadMipmapLevels&&(Y=1);for(let T=0;T<Y;T++){const Y=R.levels[T],c=C(W,a,T,i,d);if(!c){v=!1;break}Y.transcodedPixels=c,A.push(Y.transcodedPixels.buffer)}}}W.close(),W.delete(),d&&(i=-1),v?postMessage({action:"transcode",success:v,id:e.data.id,fileInfo:o,format:i},A):postMessage({action:"transcode",success:v,id:e.data.id})}}}!function(a){a[a.cTFETC1=0]="cTFETC1",a[a.cTFETC2=1]="cTFETC2",a[a.cTFBC1=2]="cTFBC1",a[a.cTFBC3=3]="cTFBC3",a[a.cTFBC4=4]="cTFBC4",a[a.cTFBC5=5]="cTFBC5",a[a.cTFBC7=6]="cTFBC7",a[a.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",a[a.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",a[a.cTFASTC_4x4=10]="cTFASTC_4x4",a[a.cTFATC_RGB=11]="cTFATC_RGB",a[a.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",a[a.cTFRGBA32=13]="cTFRGBA32",a[a.cTFRGB565=14]="cTFRGB565",a[a.cTFBGR565=15]="cTFBGR565",a[a.cTFRGBA4444=16]="cTFRGBA4444",a[a.cTFFXT1_RGB=17]="cTFFXT1_RGB",a[a.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",a[a.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",a[a.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",a[a.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(T||(T={}));const U={JSModuleURL:`${c.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${c.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let b=null,C=null,e=0;const Z=()=>(b||(b=new Promise(((a,R)=>{C?a(C):c.h.LoadFileAsync(c.h.GetBabylonScriptURL(U.WasmModuleURL)).then((Y=>{if("function"!==typeof URL)return R("Basis transcoder requires an environment with a URL constructor");const T=URL.createObjectURL(new Blob([`(${t})()`],{type:"application/javascript"}));C=new Worker(T),function(a,R,Y){return new Promise(((T,K)=>{const g=R=>{"init"===R.data.action?(a.removeEventListener("message",g),T(a)):"error"===R.data.action&&K(R.data.error||"error initializing worker")};a.addEventListener("message",g),a.postMessage({action:"init",url:Y?c.h.GetBabylonScriptURL(Y):void 0,wasmBinary:R},[R])}))}(C,Y,U.JSModuleURL).then(a,R)})).catch(R)}))),b),W=(a,R)=>{const Y=a instanceof ArrayBuffer?new Uint8Array(a):a;return new Promise(((a,T)=>{Z().then((()=>{const c=e++,K=R=>{"transcode"===R.data.action&&R.data.id===c&&(C.removeEventListener("message",K),R.data.success?a(R.data):T("Transcode is not supported on this device"))};C.addEventListener("message",K);const g=new Uint8Array(Y.byteLength);g.set(new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength)),C.postMessage({action:"transcode",id:c,imageData:g,config:R,ignoreSupportedFormats:false},[g.buffer])}),(a=>{T(a)}))}))},o=(a,R)=>{var Y;let T=null===(Y=R._gl)||void 0===Y?void 0:Y.TEXTURE_2D;var c;a.isCube&&(T=null===(c=R._gl)||void 0===c?void 0:c.TEXTURE_CUBE_MAP);R._bindTextureDirectly(T,a,!0)},i=(a,R)=>{const Y=a.getEngine();for(let t=0;t<R.fileInfo.images.length;t++){const U=R.fileInfo.images[t].levels[0];if(a._invertVScale=a.invertY,-1===R.format||R.format===T.cTFRGB565)if(a.type=10,a.format=4,!Y._features.basisNeedsPOT||Math.log2(U.width)%1===0&&Math.log2(U.height)%1===0)a._invertVScale=!a.invertY,a.width=U.width+3&-4,a.height=U.height+3&-4,a.samplingMode=2,o(a,Y),Y._uploadDataToTextureDirectly(a,new Uint16Array(U.transcodedPixels.buffer),t,0,4,!0);else{const R=new g.d(Y,2);a._invertVScale=a.invertY,R.type=10,R.format=4,R.width=U.width+3&-4,R.height=U.height+3&-4,o(R,Y),Y._uploadDataToTextureDirectly(R,new Uint16Array(U.transcodedPixels.buffer),t,0,4,!0),Y._rescaleTexture(R,a,Y.scenes[0],Y._getInternalFormat(4),(()=>{Y._releaseTexture(R),o(a,Y)}))}else{a.width=U.width,a.height=U.height,a.generateMipMaps=R.fileInfo.images[t].levels.length>1;const T=d.GetInternalFormatFromBasisFormat(R.format,Y);a.format=T,o(a,Y),R.fileInfo.images[t].levels.forEach(((R,c)=>{Y._uploadCompressedDataToTextureDirectly(a,T,R.width,R.height,R.transcodedPixels,t,c)})),!Y._features.basisNeedsPOT||Math.log2(a.width)%1===0&&Math.log2(a.height)%1===0||(c.h.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),a._cachedWrapU=K.b.CLAMP_ADDRESSMODE,a._cachedWrapV=K.b.CLAMP_ADDRESSMODE)}}},d={JSModuleURL:U.JSModuleURL,WasmModuleURL:U.WasmModuleURL,GetInternalFormatFromBasisFormat:(a,R)=>{let Y;switch(a){case T.cTFETC1:Y=36196;break;case T.cTFBC1:Y=33776;break;case T.cTFBC4:Y=33779;break;case T.cTFASTC_4x4:Y=37808;break;case T.cTFETC2:Y=37496;break;case T.cTFBC7:Y=36492}if(void 0===Y)throw"The chosen Basis transcoder format is not currently supported";return Y},TranscodeAsync:W,LoadTextureFromTranscodeResult:i};Object.defineProperty(d,"JSModuleURL",{get:function(){return U.JSModuleURL},set:function(a){U.JSModuleURL=a}}),Object.defineProperty(d,"WasmModuleURL",{get:function(){return U.WasmModuleURL},set:function(a){U.WasmModuleURL=a}});class v{constructor(){this.supportCascades=!1}loadCubeData(a,R,Y,T,K){if(Array.isArray(a))return;const g=R.getEngine().getCaps(),t={supportedCompressionFormats:{etc1:!!g.etc1,s3tc:!!g.s3tc,pvrtc:!!g.pvrtc,etc2:!!g.etc2,astc:!!g.astc,bc7:!!g.bptc}};W(a,t).then((a=>{const Y=a.fileInfo.images[0].levels.length>1&&R.generateMipMaps;i(R,a),R.getEngine()._setCubeMapTextureParams(R,Y),R.isReady=!0,R.onLoadedObservable.notifyObservers(R),R.onLoadedObservable.clear(),T&&T()})).catch((a=>{c.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),R.isReady=!0,K&&K(a)}))}loadData(a,R,Y){const T=R.getEngine().getCaps(),K={supportedCompressionFormats:{etc1:!!T.etc1,s3tc:!!T.s3tc,pvrtc:!!T.pvrtc,etc2:!!T.etc2,astc:!!T.astc,bc7:!!T.bptc}};W(a,K).then((a=>{const T=a.fileInfo.images[0].levels[0],c=a.fileInfo.images[0].levels.length>1&&R.generateMipMaps;Y(T.width,T.height,c,-1!==a.format,(()=>{i(R,a)}))})).catch((a=>{c.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),c.h.Warn(`Failed to transcode Basis file: ${a}`),Y(0,0,!1,!1,(()=>{}),!0)}))}}}}]);