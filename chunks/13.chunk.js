"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{13224:(V,p,W)=>{W.r(p),W.d(p,{_BasisTextureLoader:()=>U});var N,d=W(10848),E=W(11452),z=W(10983);function S(){const V=0,p=1,W=2,N=3,d=6,E=8,z=9,S=10,Q=14;let J=null;function i(V,p,W,N,d){const E=V.getImageTranscodedSizeInBytes(p,W,N);let z=new Uint8Array(E);if(!V.transcodeImage(z,p,W,N,1,0))return null;if(d){z=function(V,p,W,N){const d=new Uint16Array(4),E=new Uint16Array(W*N),z=W/4,S=N/4;for(let Q=0;Q<S;Q++)for(let N=0;N<z;N++){const S=p+8*(Q*z+N);d[0]=V[S]|V[S+1]<<8,d[1]=V[S+2]|V[S+3]<<8,d[2]=(2*(31&d[0])+1*(31&d[1]))/3|(2*(2016&d[0])+1*(2016&d[1]))/3&2016|(2*(63488&d[0])+1*(63488&d[1]))/3&63488,d[3]=(2*(31&d[1])+1*(31&d[0]))/3|(2*(2016&d[1])+1*(2016&d[0]))/3&2016|(2*(63488&d[1])+1*(63488&d[0]))/3&63488;for(let p=0;p<4;p++){const z=V[S+4+p];let J=(4*Q+p)*W+4*N;E[J++]=d[3&z],E[J++]=d[z>>2&3],E[J++]=d[z>>4&3],E[J++]=d[z>>6&3]}}return E}(z,0,V.getImageWidth(p,W)+3&-4,V.getImageHeight(p,W)+3&-4)}return z}onmessage=l=>{if("init"===l.data.action){if(l.data.url)try{importScripts(l.data.url)}catch(j){postMessage({action:"error",error:j})}J||(J=BASIS({wasmBinary:l.data.wasmBinary})),null!==J&&J.then((V=>{BASIS=V,V.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===l.data.action){const J=l.data.config,j=l.data.imageData,k=new BASIS.BasisFile(j),u=function(V){const p=V.getHasAlpha(),W=V.getNumImages(),N=[];for(let d=0;d<W;d++){const p={levels:[]},W=V.getNumLevels(d);for(let N=0;N<W;N++){const W={width:V.getImageWidth(d,N),height:V.getImageHeight(d,N)};p.levels.push(W)}N.push(p)}return{xe:p,images:N}}(k);let f=l.data.ignoreSupportedFormats?null:function(J,i){let l=null;J.supportedCompressionFormats&&(l=J.supportedCompressionFormats.astc?S:J.supportedCompressionFormats.bc7?d:J.supportedCompressionFormats.s3tc?i.xe?N:W:J.supportedCompressionFormats.pvrtc?i.xe?z:E:J.supportedCompressionFormats.etc2?p:J.supportedCompressionFormats.etc1?V:Q);return l}(l.data.config,u),O=!1;null===f&&(O=!0,f=u.xe?N:W);let U=!0;k.startTranscoding()||(U=!1);const F=[];for(let V=0;V<u.images.length&&U;V++){const p=u.images[V];if(void 0===J.loadSingleImage||J.loadSingleImage===V){let W=p.levels.length;!1===J.loadMipmapLevels&&(W=1);for(let N=0;N<W;N++){const W=p.levels[N],d=i(k,V,N,f,O);if(!d){U=!1;break}W.transcodedPixels=d,F.push(W.transcodedPixels.buffer)}}}k.close(),k.delete(),O&&(f=-1),U?postMessage({action:"transcode",success:U,id:l.data.id,fileInfo:u,format:f},F):postMessage({action:"transcode",success:U,id:l.data.id})}}}!function(V){V[V.cTFETC1=0]="cTFETC1",V[V.cTFETC2=1]="cTFETC2",V[V.cTFBC1=2]="cTFBC1",V[V.cTFBC3=3]="cTFBC3",V[V.cTFBC4=4]="cTFBC4",V[V.cTFBC5=5]="cTFBC5",V[V.cTFBC7=6]="cTFBC7",V[V.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",V[V.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",V[V.cTFASTC_4x4=10]="cTFASTC_4x4",V[V.cTFATC_RGB=11]="cTFATC_RGB",V[V.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",V[V.cTFRGBA32=13]="cTFRGBA32",V[V.cTFRGB565=14]="cTFRGB565",V[V.cTFBGR565=15]="cTFBGR565",V[V.cTFRGBA4444=16]="cTFRGBA4444",V[V.cTFFXT1_RGB=17]="cTFFXT1_RGB",V[V.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",V[V.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",V[V.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",V[V.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(N||(N={}));const Q={JSModuleURL:`${d.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${d.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let J=null,i=null,l=0;const j=()=>(J||(J=new Promise(((V,p)=>{i?V(i):d.e.LoadFileAsync(d.e.GetBabylonScriptURL(Q.WasmModuleURL)).then((W=>{if("function"!==typeof URL)return p("Basis transcoder requires an environment with a URL constructor");const N=URL.createObjectURL(new Blob([`(${S})()`],{type:"application/javascript"}));i=new Worker(N),function(V,p,W){return new Promise(((N,E)=>{const z=p=>{"init"===p.data.action?(V.removeEventListener("message",z),N(V)):"error"===p.data.action&&E(p.data.error||"error initializing worker")};V.addEventListener("message",z),V.postMessage({action:"init",url:W?d.e.GetBabylonScriptURL(W):void 0,wasmBinary:p},[p])}))}(i,W,Q.JSModuleURL).then(V,p)})).catch(p)}))),J),k=(V,p)=>{const W=V instanceof ArrayBuffer?new Uint8Array(V):V;return new Promise(((V,N)=>{j().then((()=>{const d=l++,E=p=>{"transcode"===p.data.action&&p.data.id===d&&(i.removeEventListener("message",E),p.data.success?V(p.data):N("Transcode is not supported on this device"))};i.addEventListener("message",E);const z=new Uint8Array(W.byteLength);z.set(new Uint8Array(W.buffer,W.byteOffset,W.byteLength)),i.postMessage({action:"transcode",id:d,imageData:z,config:p,ignoreSupportedFormats:false},[z.buffer])}),(V=>{N(V)}))}))},u=(V,p)=>{var W;let N=null===(W=p._gl)||void 0===W?void 0:W.TEXTURE_2D;var d;V.isCube&&(N=null===(d=p._gl)||void 0===d?void 0:d.TEXTURE_CUBE_MAP);p._bindTextureDirectly(N,V,!0)},f=(V,p)=>{const W=V.getEngine();for(let S=0;S<p.fileInfo.images.length;S++){const Q=p.fileInfo.images[S].levels[0];if(V._invertVScale=V.invertY,-1===p.format||p.format===N.cTFRGB565)if(V.type=10,V.format=4,!W._features.basisNeedsPOT||Math.log2(Q.width)%1===0&&Math.log2(Q.height)%1===0)V._invertVScale=!V.invertY,V.width=Q.width+3&-4,V.height=Q.height+3&-4,V.samplingMode=2,u(V,W),W._uploadDataToTextureDirectly(V,new Uint16Array(Q.transcodedPixels.buffer),S,0,4,!0);else{const p=new z.e(W,2);V._invertVScale=V.invertY,p.type=10,p.format=4,p.width=Q.width+3&-4,p.height=Q.height+3&-4,u(p,W),W._uploadDataToTextureDirectly(p,new Uint16Array(Q.transcodedPixels.buffer),S,0,4,!0),W._rescaleTexture(p,V,W.scenes[0],W._getInternalFormat(4),(()=>{W._releaseTexture(p),u(V,W)}))}else{V.width=Q.width,V.height=Q.height,V.generateMipMaps=p.fileInfo.images[S].levels.length>1;const N=O.GetInternalFormatFromBasisFormat(p.format,W);V.format=N,u(V,W),p.fileInfo.images[S].levels.forEach(((p,d)=>{W._uploadCompressedDataToTextureDirectly(V,N,p.width,p.height,p.transcodedPixels,S,d)})),!W._features.basisNeedsPOT||Math.log2(V.width)%1===0&&Math.log2(V.height)%1===0||(d.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),V._cachedWrapU=E.d.CLAMP_ADDRESSMODE,V._cachedWrapV=E.d.CLAMP_ADDRESSMODE)}}},O={JSModuleURL:Q.JSModuleURL,WasmModuleURL:Q.WasmModuleURL,GetInternalFormatFromBasisFormat:(V,p)=>{let W;switch(V){case N.cTFETC1:W=36196;break;case N.cTFBC1:W=33776;break;case N.cTFBC4:W=33779;break;case N.cTFASTC_4x4:W=37808;break;case N.cTFETC2:W=37496;break;case N.cTFBC7:W=36492}if(void 0===W)throw"The chosen Basis transcoder format is not currently supported";return W},TranscodeAsync:k,LoadTextureFromTranscodeResult:f};Object.defineProperty(O,"JSModuleURL",{get:function(){return Q.JSModuleURL},set:function(V){Q.JSModuleURL=V}}),Object.defineProperty(O,"WasmModuleURL",{get:function(){return Q.WasmModuleURL},set:function(V){Q.WasmModuleURL=V}});class U{constructor(){this.supportCascades=!1}loadCubeData(V,p,W,N,E){if(Array.isArray(V))return;const z=p.getEngine().getCaps(),S={supportedCompressionFormats:{etc1:!!z.etc1,s3tc:!!z.s3tc,pvrtc:!!z.pvrtc,etc2:!!z.etc2,astc:!!z.astc,bc7:!!z.bptc}};k(V,S).then((V=>{const W=V.fileInfo.images[0].levels.length>1&&p.generateMipMaps;f(p,V),p.getEngine()._setCubeMapTextureParams(p,W),p.isReady=!0,p.onLoadedObservable.notifyObservers(p),p.onLoadedObservable.clear(),N&&N()})).catch((V=>{d.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),p.isReady=!0,E&&E(V)}))}loadData(V,p,W){const N=p.getEngine().getCaps(),E={supportedCompressionFormats:{etc1:!!N.etc1,s3tc:!!N.s3tc,pvrtc:!!N.pvrtc,etc2:!!N.etc2,astc:!!N.astc,bc7:!!N.bptc}};k(V,E).then((V=>{const N=V.fileInfo.images[0].levels[0],d=V.fileInfo.images[0].levels.length>1&&p.generateMipMaps;W(N.width,N.height,d,-1!==V.format,(()=>{f(p,V)}))})).catch((V=>{d.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),d.e.Warn(`Failed to transcode Basis file: ${V}`),W(0,0,!1,!1,(()=>{}),!0)}))}}}}]);