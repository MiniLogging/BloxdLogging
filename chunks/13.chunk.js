"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{13095:(H,c,y)=>{y.r(c),y.d(c,{_BasisTextureLoader:()=>h});var Z,F=y(10754),P=y(11304),S=y(10877);function n(){const H=0,c=1,y=2,Z=3,F=6,P=8,S=9,n=10,O=14;let a=null;function i(H,c,y,Z,F){const P=H.getImageTranscodedSizeInBytes(c,y,Z);let S=new Uint8Array(P);if(!H.transcodeImage(S,c,y,Z,1,0))return null;if(F){S=function(H,c,y,Z){const F=new Uint16Array(4),P=new Uint16Array(y*Z),S=y/4,n=Z/4;for(let O=0;O<n;O++)for(let Z=0;Z<S;Z++){const n=c+8*(O*S+Z);F[0]=H[n]|H[n+1]<<8,F[1]=H[n+2]|H[n+3]<<8,F[2]=(2*(31&F[0])+1*(31&F[1]))/3|(2*(2016&F[0])+1*(2016&F[1]))/3&2016|(2*(63488&F[0])+1*(63488&F[1]))/3&63488,F[3]=(2*(31&F[1])+1*(31&F[0]))/3|(2*(2016&F[1])+1*(2016&F[0]))/3&2016|(2*(63488&F[1])+1*(63488&F[0]))/3&63488;for(let c=0;c<4;c++){const S=H[n+4+c];let a=(4*O+c)*y+4*Z;P[a++]=F[3&S],P[a++]=F[S>>2&3],P[a++]=F[S>>4&3],P[a++]=F[S>>6&3]}}return P}(S,0,H.getImageWidth(c,y)+3&-4,H.getImageHeight(c,y)+3&-4)}return S}onmessage=C=>{if("init"===C.data.action){if(C.data.url)try{importScripts(C.data.url)}catch(g){postMessage({action:"error",error:g})}a||(a=BASIS({wasmBinary:C.data.wasmBinary})),null!==a&&a.then((H=>{BASIS=H,H.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===C.data.action){const a=C.data.config,g=C.data.imageData,v=new BASIS.BasisFile(g),m=function(H){const c=H.getHasAlpha(),y=H.getNumImages(),Z=[];for(let F=0;F<y;F++){const c={levels:[]},y=H.getNumLevels(F);for(let Z=0;Z<y;Z++){const y={width:H.getImageWidth(F,Z),height:H.getImageHeight(F,Z)};c.levels.push(y)}Z.push(c)}return{pe:c,images:Z}}(v);let z=C.data.ignoreSupportedFormats?null:function(a,i){let C=null;a.supportedCompressionFormats&&(C=a.supportedCompressionFormats.astc?n:a.supportedCompressionFormats.bc7?F:a.supportedCompressionFormats.s3tc?i.pe?Z:y:a.supportedCompressionFormats.pvrtc?i.pe?S:P:a.supportedCompressionFormats.etc2?c:a.supportedCompressionFormats.etc1?H:O);return C}(C.data.config,m),V=!1;null===z&&(V=!0,z=m.pe?Z:y);let h=!0;v.startTranscoding()||(h=!1);const Q=[];for(let H=0;H<m.images.length&&h;H++){const c=m.images[H];if(void 0===a.loadSingleImage||a.loadSingleImage===H){let y=c.levels.length;!1===a.loadMipmapLevels&&(y=1);for(let Z=0;Z<y;Z++){const y=c.levels[Z],F=i(v,H,Z,z,V);if(!F){h=!1;break}y.transcodedPixels=F,Q.push(y.transcodedPixels.buffer)}}}v.close(),v.delete(),V&&(z=-1),h?postMessage({action:"transcode",success:h,id:C.data.id,fileInfo:m,format:z},Q):postMessage({action:"transcode",success:h,id:C.data.id})}}}!function(H){H[H.cTFETC1=0]="cTFETC1",H[H.cTFETC2=1]="cTFETC2",H[H.cTFBC1=2]="cTFBC1",H[H.cTFBC3=3]="cTFBC3",H[H.cTFBC4=4]="cTFBC4",H[H.cTFBC5=5]="cTFBC5",H[H.cTFBC7=6]="cTFBC7",H[H.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",H[H.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",H[H.cTFASTC_4x4=10]="cTFASTC_4x4",H[H.cTFATC_RGB=11]="cTFATC_RGB",H[H.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",H[H.cTFRGBA32=13]="cTFRGBA32",H[H.cTFRGB565=14]="cTFRGB565",H[H.cTFBGR565=15]="cTFBGR565",H[H.cTFRGBA4444=16]="cTFRGBA4444",H[H.cTFFXT1_RGB=17]="cTFFXT1_RGB",H[H.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",H[H.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",H[H.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",H[H.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(Z||(Z={}));const O={JSModuleURL:`${F.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${F.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let a=null,i=null,C=0;const g=()=>(a||(a=new Promise(((H,c)=>{i?H(i):F.c.LoadFileAsync(F.c.GetBabylonScriptURL(O.WasmModuleURL)).then((y=>{if("function"!==typeof URL)return c("Basis transcoder requires an environment with a URL constructor");const Z=URL.createObjectURL(new Blob([`(${n})()`],{type:"application/javascript"}));i=new Worker(Z),function(H,c,y){return new Promise(((Z,P)=>{const S=c=>{"init"===c.data.action?(H.removeEventListener("message",S),Z(H)):"error"===c.data.action&&P(c.data.error||"error initializing worker")};H.addEventListener("message",S),H.postMessage({action:"init",url:y?F.c.GetBabylonScriptURL(y):void 0,wasmBinary:c},[c])}))}(i,y,O.JSModuleURL).then(H,c)})).catch(c)}))),a),v=(H,c)=>{const y=H instanceof ArrayBuffer?new Uint8Array(H):H;return new Promise(((H,Z)=>{g().then((()=>{const F=C++,P=c=>{"transcode"===c.data.action&&c.data.id===F&&(i.removeEventListener("message",P),c.data.success?H(c.data):Z("Transcode is not supported on this device"))};i.addEventListener("message",P);const S=new Uint8Array(y.byteLength);S.set(new Uint8Array(y.buffer,y.byteOffset,y.byteLength)),i.postMessage({action:"transcode",id:F,imageData:S,config:c,ignoreSupportedFormats:false},[S.buffer])}),(H=>{Z(H)}))}))},m=(H,c)=>{var y;let Z=null===(y=c._gl)||void 0===y?void 0:y.TEXTURE_2D;var F;H.isCube&&(Z=null===(F=c._gl)||void 0===F?void 0:F.TEXTURE_CUBE_MAP);c._bindTextureDirectly(Z,H,!0)},z=(H,c)=>{const y=H.getEngine();for(let n=0;n<c.fileInfo.images.length;n++){const O=c.fileInfo.images[n].levels[0];if(H._invertVScale=H.invertY,-1===c.format||c.format===Z.cTFRGB565)if(H.type=10,H.format=4,!y._features.basisNeedsPOT||Math.log2(O.width)%1===0&&Math.log2(O.height)%1===0)H._invertVScale=!H.invertY,H.width=O.width+3&-4,H.height=O.height+3&-4,H.samplingMode=2,m(H,y),y._uploadDataToTextureDirectly(H,new Uint16Array(O.transcodedPixels.buffer),n,0,4,!0);else{const c=new S.b(y,2);H._invertVScale=H.invertY,c.type=10,c.format=4,c.width=O.width+3&-4,c.height=O.height+3&-4,m(c,y),y._uploadDataToTextureDirectly(c,new Uint16Array(O.transcodedPixels.buffer),n,0,4,!0),y._rescaleTexture(c,H,y.scenes[0],y._getInternalFormat(4),(()=>{y._releaseTexture(c),m(H,y)}))}else{H.width=O.width,H.height=O.height,H.generateMipMaps=c.fileInfo.images[n].levels.length>1;const Z=V.GetInternalFormatFromBasisFormat(c.format,y);H.format=Z,m(H,y),c.fileInfo.images[n].levels.forEach(((c,F)=>{y._uploadCompressedDataToTextureDirectly(H,Z,c.width,c.height,c.transcodedPixels,n,F)})),!y._features.basisNeedsPOT||Math.log2(H.width)%1===0&&Math.log2(H.height)%1===0||(F.c.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),H._cachedWrapU=P.d.CLAMP_ADDRESSMODE,H._cachedWrapV=P.d.CLAMP_ADDRESSMODE)}}},V={JSModuleURL:O.JSModuleURL,WasmModuleURL:O.WasmModuleURL,GetInternalFormatFromBasisFormat:(H,c)=>{let y;switch(H){case Z.cTFETC1:y=36196;break;case Z.cTFBC1:y=33776;break;case Z.cTFBC4:y=33779;break;case Z.cTFASTC_4x4:y=37808;break;case Z.cTFETC2:y=37496;break;case Z.cTFBC7:y=36492}if(void 0===y)throw"The chosen Basis transcoder format is not currently supported";return y},TranscodeAsync:v,LoadTextureFromTranscodeResult:z};Object.defineProperty(V,"JSModuleURL",{get:function(){return O.JSModuleURL},set:function(H){O.JSModuleURL=H}}),Object.defineProperty(V,"WasmModuleURL",{get:function(){return O.WasmModuleURL},set:function(H){O.WasmModuleURL=H}});class h{constructor(){this.supportCascades=!1}loadCubeData(H,c,y,Z,P){if(Array.isArray(H))return;const S=c.getEngine().getCaps(),n={supportedCompressionFormats:{etc1:!!S.etc1,s3tc:!!S.s3tc,pvrtc:!!S.pvrtc,etc2:!!S.etc2,astc:!!S.astc,bc7:!!S.bptc}};v(H,n).then((H=>{const y=H.fileInfo.images[0].levels.length>1&&c.generateMipMaps;z(c,H),c.getEngine()._setCubeMapTextureParams(c,y),c.isReady=!0,c.onLoadedObservable.notifyObservers(c),c.onLoadedObservable.clear(),Z&&Z()})).catch((H=>{F.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),c.isReady=!0,P&&P(H)}))}loadData(H,c,y){const Z=c.getEngine().getCaps(),P={supportedCompressionFormats:{etc1:!!Z.etc1,s3tc:!!Z.s3tc,pvrtc:!!Z.pvrtc,etc2:!!Z.etc2,astc:!!Z.astc,bc7:!!Z.bptc}};v(H,P).then((H=>{const Z=H.fileInfo.images[0].levels[0],F=H.fileInfo.images[0].levels.length>1&&c.generateMipMaps;y(Z.width,Z.height,F,-1!==H.format,(()=>{z(c,H)}))})).catch((H=>{F.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),F.c.Warn(`Failed to transcode Basis file: ${H}`),y(0,0,!1,!1,(()=>{}),!0)}))}}}}]);