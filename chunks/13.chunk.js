"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{2248:(v,d,Q)=>{Q.r(d),Q.d(d,{_HDRTextureLoader:()=>u});var n=Q(651);class T{static ConvertPanoramaToCubemap(v,d,Q,n){let T=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!v)throw"ConvertPanoramaToCubemap: input cannot be null";if(v.length!=d*Q*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(n,this.FACE_FRONT,v,d,Q,T),back:this.CreateCubemapTexture(n,this.FACE_BACK,v,d,Q,T),left:this.CreateCubemapTexture(n,this.FACE_LEFT,v,d,Q,T),right:this.CreateCubemapTexture(n,this.FACE_RIGHT,v,d,Q,T),up:this.CreateCubemapTexture(n,this.FACE_UP,v,d,Q,T),down:this.CreateCubemapTexture(n,this.FACE_DOWN,v,d,Q,T),size:n,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(v,d,Q,n,T){let L=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const e=new ArrayBuffer(v*v*4*3),F=new Float32Array(e),r=L?Math.max(1,Math.round(n/4/v)):1,C=1/r,u=C*C,y=d[1].Wd(d[0]).scale(C/v),z=d[3].Wd(d[2]).scale(C/v),B=1/v;let X=0;for(let m=0;m<v;m++)for(let L=0;L<r;L++){let L=d[0],e=d[2];for(let d=0;d<v;d++)for(let C=0;C<r;C++){const r=e.Wd(L).scale(X).add(L);r.normalize();const C=this.CalcProjectionSpherical(r,Q,n,T);F[m*v*3+3*d+0]+=C.r*u,F[m*v*3+3*d+1]+=C.g*u,F[m*v*3+3*d+2]+=C.b*u,L=L.add(y),e=e.add(z)}X+=B*C}return F}static CalcProjectionSpherical(v,d,Q,n){let T=Math.atan2(v.z,v.x);const L=Math.acos(v.y);for(;T<-Math.PI;)T+=2*Math.PI;for(;T>Math.PI;)T-=2*Math.PI;let e=T/Math.PI;const F=L/Math.PI;e=.5*e+.5;let r=Math.round(e*Q);r<0?r=0:r>=Q&&(r=Q-1);let C=Math.round(F*n);C<0?C=0:C>=n&&(C=n-1);const u=n-C-1;return{r:d[u*Q*3+3*r+0],g:d[u*Q*3+3*r+1],b:d[u*Q*3+3*r+2]}}}function L(v,d,Q,n,T,L){T>0?(T=function(v,d){return d>1023?v*Math.pow(2,1023)*Math.pow(2,d-1023):d<-1074?v*Math.pow(2,-1074)*Math.pow(2,d+1074):v*Math.pow(2,d)}(1,T-136),v[L+0]=d*T,v[L+1]=Q*T,v[L+2]=n*T):(v[L+0]=0,v[L+1]=0,v[L+2]=0)}function e(v,d){let Q="",n="";for(let T=d;T<v.length-d&&(n=String.fromCharCode(v[T]),"\n"!=n);T++)Q+=n;return Q}function F(v){let d=0,Q=0,n=e(v,0);if("#"!=n[0]||"?"!=n[1])throw"Bad HDR Format.";let T=!1,L=!1,F=0;do{F+=n.length+1,n=e(v,F),"FORMAT=32-bit_rle_rgbe"==n?L=!0:0==n.length&&(T=!0)}while(!T);if(!L)throw"HDR Bad header format, unsupported FORMAT";F+=n.length+1,n=e(v,F);const r=/^-Y (.*) \+X (.*)$/g.exec(n);if(!r||r.length<3)throw"HDR Bad header format, no size";if(Q=parseInt(r[2]),d=parseInt(r[1]),Q<8||Q>32767)throw"HDR Bad header format, unsupported size";return F+=n.length+1,{height:d,width:Q,dataPosition:F}}function r(v,d){return function(v,d){let Q=d.height;const n=d.width;let T,e,F,r,u,y=d.dataPosition,z=0,B=0,X=0;const m=new ArrayBuffer(4*n),V=new Uint8Array(m),h=new ArrayBuffer(d.width*d.height*4*3),S=new Float32Array(h);for(;Q>0;){if(T=v[y++],e=v[y++],F=v[y++],r=v[y++],2!=T||2!=e||128&F||d.width<8||d.width>32767)return C(v,d);if((F<<8|r)!=n)throw"HDR Bad header format, wrong scan line width";for(z=0,X=0;X<4;X++)for(B=(X+1)*n;z<B;)if(T=v[y++],e=v[y++],T>128){if(u=T-128,0==u||u>B-z)throw"HDR Bad Format, bad scanline data (run)";for(;u-- >0;)V[z++]=e}else{if(u=T,0==u||u>B-z)throw"HDR Bad Format, bad scanline data (non-run)";if(V[z++]=e,--u>0)for(let d=0;d<u;d++)V[z++]=v[y++]}for(X=0;X<n;X++)T=V[X],e=V[X+n],F=V[X+2*n],r=V[X+3*n],L(S,T,e,F,r,(d.height-Q)*n*3+3*X);Q--}return S}(v,d)}function C(v,d){let Q=d.height;const n=d.width;let T,e,F,r,C,u=d.dataPosition;const y=new ArrayBuffer(d.width*d.height*4*3),z=new Float32Array(y);for(;Q>0;){for(C=0;C<d.width;C++)T=v[u++],e=v[u++],F=v[u++],r=v[u++],L(z,T,e,F,r,(d.height-Q)*n*3+3*C);Q--}return z}T.FACE_LEFT=[new n.j(-1,-1,-1),new n.j(1,-1,-1),new n.j(-1,1,-1),new n.j(1,1,-1)],T.FACE_RIGHT=[new n.j(1,-1,1),new n.j(-1,-1,1),new n.j(1,1,1),new n.j(-1,1,1)],T.FACE_FRONT=[new n.j(1,-1,-1),new n.j(1,-1,1),new n.j(1,1,-1),new n.j(1,1,1)],T.FACE_BACK=[new n.j(-1,-1,1),new n.j(-1,-1,-1),new n.j(-1,1,1),new n.j(-1,1,-1)],T.FACE_DOWN=[new n.j(1,1,-1),new n.j(1,1,1),new n.j(-1,1,-1),new n.j(-1,1,1)],T.FACE_UP=[new n.j(-1,-1,-1),new n.j(-1,-1,1),new n.j(1,-1,-1),new n.j(1,-1,1)];class u{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(v,d,Q){const n=new Uint8Array(v.buffer,v.byteOffset,v.byteLength),T=F(n),L=r(n,T),e=T.width*T.height,C=new Float32Array(4*e);for(let F=0;F<e;F+=1)C[4*F]=L[3*F],C[4*F+1]=L[3*F+1],C[4*F+2]=L[3*F+2],C[4*F+3]=1;Q(T.width,T.height,d.generateMipMaps,!1,(()=>{const v=d.getEngine();d.type=1,d.format=5,d._gammaSpace=!1,v._uploadDataToTextureDirectly(d,C)}))}}}}]);