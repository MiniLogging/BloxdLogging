"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{13033:(v,y,n)=>{n.r(y),n.d(y,{_BasisTextureLoader:()=>h});var B,J=n(10791),P=n(11281),b=n(10885);function Y(){const v=0,y=1,n=2,B=3,J=6,P=8,b=9,Y=10,l=14;let a=null;function Z(v,y,n,B,J){const P=v.getImageTranscodedSizeInBytes(y,n,B);let b=new Uint8Array(P);if(!v.transcodeImage(b,y,n,B,1,0))return null;if(J){b=function(v,y,n,B){const J=new Uint16Array(4),P=new Uint16Array(n*B),b=n/4,Y=B/4;for(let l=0;l<Y;l++)for(let B=0;B<b;B++){const Y=y+8*(l*b+B);J[0]=v[Y]|v[Y+1]<<8,J[1]=v[Y+2]|v[Y+3]<<8,J[2]=(2*(31&J[0])+1*(31&J[1]))/3|(2*(2016&J[0])+1*(2016&J[1]))/3&2016|(2*(63488&J[0])+1*(63488&J[1]))/3&63488,J[3]=(2*(31&J[1])+1*(31&J[0]))/3|(2*(2016&J[1])+1*(2016&J[0]))/3&2016|(2*(63488&J[1])+1*(63488&J[0]))/3&63488;for(let y=0;y<4;y++){const b=v[Y+4+y];let a=(4*l+y)*n+4*B;P[a++]=J[3&b],P[a++]=J[b>>2&3],P[a++]=J[b>>4&3],P[a++]=J[b>>6&3]}}return P}(b,0,v.getImageWidth(y,n)+3&-4,v.getImageHeight(y,n)+3&-4)}return b}onmessage=x=>{if("init"===x.data.action){if(x.data.url)try{importScripts(x.data.url)}catch(f){postMessage({action:"error",error:f})}a||(a=BASIS({wasmBinary:x.data.wasmBinary})),null!==a&&a.then((v=>{BASIS=v,v.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===x.data.action){const a=x.data.config,f=x.data.imageData,N=new BASIS.BasisFile(f),i=function(v){const y=v.getHasAlpha(),n=v.getNumImages(),B=[];for(let J=0;J<n;J++){const y={levels:[]},n=v.getNumLevels(J);for(let B=0;B<n;B++){const n={width:v.getImageWidth(J,B),height:v.getImageHeight(J,B)};y.levels.push(n)}B.push(y)}return{Pe:y,images:B}}(N);let g=x.data.ignoreSupportedFormats?null:function(a,Z){let x=null;a.supportedCompressionFormats&&(x=a.supportedCompressionFormats.astc?Y:a.supportedCompressionFormats.bc7?J:a.supportedCompressionFormats.s3tc?Z.Pe?B:n:a.supportedCompressionFormats.pvrtc?Z.Pe?b:P:a.supportedCompressionFormats.etc2?y:a.supportedCompressionFormats.etc1?v:l);return x}(x.data.config,i),c=!1;null===g&&(c=!0,g=i.Pe?B:n);let h=!0;N.startTranscoding()||(h=!1);const E=[];for(let v=0;v<i.images.length&&h;v++){const y=i.images[v];if(void 0===a.loadSingleImage||a.loadSingleImage===v){let n=y.levels.length;!1===a.loadMipmapLevels&&(n=1);for(let B=0;B<n;B++){const n=y.levels[B],J=Z(N,v,B,g,c);if(!J){h=!1;break}n.transcodedPixels=J,E.push(n.transcodedPixels.buffer)}}}N.close(),N.delete(),c&&(g=-1),h?postMessage({action:"transcode",success:h,id:x.data.id,fileInfo:i,format:g},E):postMessage({action:"transcode",success:h,id:x.data.id})}}}!function(v){v[v.cTFETC1=0]="cTFETC1",v[v.cTFETC2=1]="cTFETC2",v[v.cTFBC1=2]="cTFBC1",v[v.cTFBC3=3]="cTFBC3",v[v.cTFBC4=4]="cTFBC4",v[v.cTFBC5=5]="cTFBC5",v[v.cTFBC7=6]="cTFBC7",v[v.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",v[v.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",v[v.cTFASTC_4x4=10]="cTFASTC_4x4",v[v.cTFATC_RGB=11]="cTFATC_RGB",v[v.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",v[v.cTFRGBA32=13]="cTFRGBA32",v[v.cTFRGB565=14]="cTFRGB565",v[v.cTFBGR565=15]="cTFBGR565",v[v.cTFRGBA4444=16]="cTFRGBA4444",v[v.cTFFXT1_RGB=17]="cTFFXT1_RGB",v[v.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",v[v.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",v[v.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",v[v.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(B||(B={}));const l={JSModuleURL:`${J.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${J.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let a=null,Z=null,x=0;const f=()=>(a||(a=new Promise(((v,y)=>{Z?v(Z):J.g.LoadFileAsync(J.g.GetBabylonScriptURL(l.WasmModuleURL)).then((n=>{if("function"!==typeof URL)return y("Basis transcoder requires an environment with a URL constructor");const B=URL.createObjectURL(new Blob([`(${Y})()`],{type:"application/javascript"}));Z=new Worker(B),function(v,y,n){return new Promise(((B,P)=>{const b=y=>{"init"===y.data.action?(v.removeEventListener("message",b),B(v)):"error"===y.data.action&&P(y.data.error||"error initializing worker")};v.addEventListener("message",b),v.postMessage({action:"init",url:n?J.g.GetBabylonScriptURL(n):void 0,wasmBinary:y},[y])}))}(Z,n,l.JSModuleURL).then(v,y)})).catch(y)}))),a),N=(v,y)=>{const n=v instanceof ArrayBuffer?new Uint8Array(v):v;return new Promise(((v,B)=>{f().then((()=>{const J=x++,P=y=>{"transcode"===y.data.action&&y.data.id===J&&(Z.removeEventListener("message",P),y.data.success?v(y.data):B("Transcode is not supported on this device"))};Z.addEventListener("message",P);const b=new Uint8Array(n.byteLength);b.set(new Uint8Array(n.buffer,n.byteOffset,n.byteLength)),Z.postMessage({action:"transcode",id:J,imageData:b,config:y,ignoreSupportedFormats:false},[b.buffer])}),(v=>{B(v)}))}))},i=(v,y)=>{var n;let B=null===(n=y._gl)||void 0===n?void 0:n.TEXTURE_2D;var J;v.isCube&&(B=null===(J=y._gl)||void 0===J?void 0:J.TEXTURE_CUBE_MAP);y._bindTextureDirectly(B,v,!0)},g=(v,y)=>{const n=v.getEngine();for(let Y=0;Y<y.fileInfo.images.length;Y++){const l=y.fileInfo.images[Y].levels[0];if(v._invertVScale=v.invertY,-1===y.format||y.format===B.cTFRGB565)if(v.type=10,v.format=4,!n._features.basisNeedsPOT||Math.log2(l.width)%1===0&&Math.log2(l.height)%1===0)v._invertVScale=!v.invertY,v.width=l.width+3&-4,v.height=l.height+3&-4,v.samplingMode=2,i(v,n),n._uploadDataToTextureDirectly(v,new Uint16Array(l.transcodedPixels.buffer),Y,0,4,!0);else{const y=new b.b(n,2);v._invertVScale=v.invertY,y.type=10,y.format=4,y.width=l.width+3&-4,y.height=l.height+3&-4,i(y,n),n._uploadDataToTextureDirectly(y,new Uint16Array(l.transcodedPixels.buffer),Y,0,4,!0),n._rescaleTexture(y,v,n.scenes[0],n._getInternalFormat(4),(()=>{n._releaseTexture(y),i(v,n)}))}else{v.width=l.width,v.height=l.height,v.generateMipMaps=y.fileInfo.images[Y].levels.length>1;const B=c.GetInternalFormatFromBasisFormat(y.format,n);v.format=B,i(v,n),y.fileInfo.images[Y].levels.forEach(((y,J)=>{n._uploadCompressedDataToTextureDirectly(v,B,y.width,y.height,y.transcodedPixels,Y,J)})),!n._features.basisNeedsPOT||Math.log2(v.width)%1===0&&Math.log2(v.height)%1===0||(J.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),v._cachedWrapU=P.b.CLAMP_ADDRESSMODE,v._cachedWrapV=P.b.CLAMP_ADDRESSMODE)}}},c={JSModuleURL:l.JSModuleURL,WasmModuleURL:l.WasmModuleURL,GetInternalFormatFromBasisFormat:(v,y)=>{let n;switch(v){case B.cTFETC1:n=36196;break;case B.cTFBC1:n=33776;break;case B.cTFBC4:n=33779;break;case B.cTFASTC_4x4:n=37808;break;case B.cTFETC2:n=37496;break;case B.cTFBC7:n=36492}if(void 0===n)throw"The chosen Basis transcoder format is not currently supported";return n},TranscodeAsync:N,LoadTextureFromTranscodeResult:g};Object.defineProperty(c,"JSModuleURL",{get:function(){return l.JSModuleURL},set:function(v){l.JSModuleURL=v}}),Object.defineProperty(c,"WasmModuleURL",{get:function(){return l.WasmModuleURL},set:function(v){l.WasmModuleURL=v}});class h{constructor(){this.supportCascades=!1}loadCubeData(v,y,n,B,P){if(Array.isArray(v))return;const b=y.getEngine().getCaps(),Y={supportedCompressionFormats:{etc1:!!b.etc1,s3tc:!!b.s3tc,pvrtc:!!b.pvrtc,etc2:!!b.etc2,astc:!!b.astc,bc7:!!b.bptc}};N(v,Y).then((v=>{const n=v.fileInfo.images[0].levels.length>1&&y.generateMipMaps;g(y,v),y.getEngine()._setCubeMapTextureParams(y,n),y.isReady=!0,y.onLoadedObservable.notifyObservers(y),y.onLoadedObservable.clear(),B&&B()})).catch((v=>{J.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),y.isReady=!0,P&&P(v)}))}loadData(v,y,n){const B=y.getEngine().getCaps(),P={supportedCompressionFormats:{etc1:!!B.etc1,s3tc:!!B.s3tc,pvrtc:!!B.pvrtc,etc2:!!B.etc2,astc:!!B.astc,bc7:!!B.bptc}};N(v,P).then((v=>{const B=v.fileInfo.images[0].levels[0],J=v.fileInfo.images[0].levels.length>1&&y.generateMipMaps;n(B.width,B.height,J,-1!==v.format,(()=>{g(y,v)}))})).catch((v=>{J.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),J.g.Warn(`Failed to transcode Basis file: ${v}`),n(0,0,!1,!1,(()=>{}),!0)}))}}}}]);