"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{13010:(H,p,V)=>{V.r(p),V.d(p,{_BasisTextureLoader:()=>y});var c,C=V(10765),E=V(11288),z=V(10904);function w(){const H=0,p=1,V=2,c=3,C=6,E=8,z=9,w=10,t=14;let Q=null;function P(H,p,V,c,C){const E=H.getImageTranscodedSizeInBytes(p,V,c);let z=new Uint8Array(E);if(!H.transcodeImage(z,p,V,c,1,0))return null;if(C){z=function(H,p,V,c){const C=new Uint16Array(4),E=new Uint16Array(V*c),z=V/4,w=c/4;for(let t=0;t<w;t++)for(let c=0;c<z;c++){const w=p+8*(t*z+c);C[0]=H[w]|H[w+1]<<8,C[1]=H[w+2]|H[w+3]<<8,C[2]=(2*(31&C[0])+1*(31&C[1]))/3|(2*(2016&C[0])+1*(2016&C[1]))/3&2016|(2*(63488&C[0])+1*(63488&C[1]))/3&63488,C[3]=(2*(31&C[1])+1*(31&C[0]))/3|(2*(2016&C[1])+1*(2016&C[0]))/3&2016|(2*(63488&C[1])+1*(63488&C[0]))/3&63488;for(let p=0;p<4;p++){const z=H[w+4+p];let Q=(4*t+p)*V+4*c;E[Q++]=C[3&z],E[Q++]=C[z>>2&3],E[Q++]=C[z>>4&3],E[Q++]=C[z>>6&3]}}return E}(z,0,H.getImageWidth(p,V)+3&-4,H.getImageHeight(p,V)+3&-4)}return z}onmessage=U=>{if("init"===U.data.action){if(U.data.url)try{importScripts(U.data.url)}catch(J){postMessage({action:"error",error:J})}Q||(Q=BASIS({wasmBinary:U.data.wasmBinary})),null!==Q&&Q.then((H=>{BASIS=H,H.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===U.data.action){const Q=U.data.config,J=U.data.imageData,l=new BASIS.BasisFile(J),N=function(H){const p=H.getHasAlpha(),V=H.getNumImages(),c=[];for(let C=0;C<V;C++){const p={levels:[]},V=H.getNumLevels(C);for(let c=0;c<V;c++){const V={width:H.getImageWidth(C,c),height:H.getImageHeight(C,c)};p.levels.push(V)}c.push(p)}return{Ee:p,images:c}}(l);let Z=U.data.ignoreSupportedFormats?null:function(Q,P){let U=null;Q.supportedCompressionFormats&&(U=Q.supportedCompressionFormats.astc?w:Q.supportedCompressionFormats.bc7?C:Q.supportedCompressionFormats.s3tc?P.Ee?c:V:Q.supportedCompressionFormats.pvrtc?P.Ee?z:E:Q.supportedCompressionFormats.etc2?p:Q.supportedCompressionFormats.etc1?H:t);return U}(U.data.config,N),Y=!1;null===Z&&(Y=!0,Z=N.Ee?c:V);let y=!0;l.startTranscoding()||(y=!1);const M=[];for(let H=0;H<N.images.length&&y;H++){const p=N.images[H];if(void 0===Q.loadSingleImage||Q.loadSingleImage===H){let V=p.levels.length;!1===Q.loadMipmapLevels&&(V=1);for(let c=0;c<V;c++){const V=p.levels[c],C=P(l,H,c,Z,Y);if(!C){y=!1;break}V.transcodedPixels=C,M.push(V.transcodedPixels.buffer)}}}l.close(),l.delete(),Y&&(Z=-1),y?postMessage({action:"transcode",success:y,id:U.data.id,fileInfo:N,format:Z},M):postMessage({action:"transcode",success:y,id:U.data.id})}}}!function(H){H[H.cTFETC1=0]="cTFETC1",H[H.cTFETC2=1]="cTFETC2",H[H.cTFBC1=2]="cTFBC1",H[H.cTFBC3=3]="cTFBC3",H[H.cTFBC4=4]="cTFBC4",H[H.cTFBC5=5]="cTFBC5",H[H.cTFBC7=6]="cTFBC7",H[H.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",H[H.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",H[H.cTFASTC_4x4=10]="cTFASTC_4x4",H[H.cTFATC_RGB=11]="cTFATC_RGB",H[H.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",H[H.cTFRGBA32=13]="cTFRGBA32",H[H.cTFRGB565=14]="cTFRGB565",H[H.cTFBGR565=15]="cTFBGR565",H[H.cTFRGBA4444=16]="cTFRGBA4444",H[H.cTFFXT1_RGB=17]="cTFFXT1_RGB",H[H.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",H[H.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",H[H.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",H[H.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(c||(c={}));const t={JSModuleURL:`${C.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${C.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let Q=null,P=null,U=0;const J=()=>(Q||(Q=new Promise(((H,p)=>{P?H(P):C.c.LoadFileAsync(C.c.GetBabylonScriptURL(t.WasmModuleURL)).then((V=>{if("function"!==typeof URL)return p("Basis transcoder requires an environment with a URL constructor");const c=URL.createObjectURL(new Blob([`(${w})()`],{type:"application/javascript"}));P=new Worker(c),function(H,p,V){return new Promise(((c,E)=>{const z=p=>{"init"===p.data.action?(H.removeEventListener("message",z),c(H)):"error"===p.data.action&&E(p.data.error||"error initializing worker")};H.addEventListener("message",z),H.postMessage({action:"init",url:V?C.c.GetBabylonScriptURL(V):void 0,wasmBinary:p},[p])}))}(P,V,t.JSModuleURL).then(H,p)})).catch(p)}))),Q),l=(H,p)=>{const V=H instanceof ArrayBuffer?new Uint8Array(H):H;return new Promise(((H,c)=>{J().then((()=>{const C=U++,E=p=>{"transcode"===p.data.action&&p.data.id===C&&(P.removeEventListener("message",E),p.data.success?H(p.data):c("Transcode is not supported on this device"))};P.addEventListener("message",E);const z=new Uint8Array(V.byteLength);z.set(new Uint8Array(V.buffer,V.byteOffset,V.byteLength)),P.postMessage({action:"transcode",id:C,imageData:z,config:p,ignoreSupportedFormats:false},[z.buffer])}),(H=>{c(H)}))}))},N=(H,p)=>{var V;let c=null===(V=p._gl)||void 0===V?void 0:V.TEXTURE_2D;var C;H.isCube&&(c=null===(C=p._gl)||void 0===C?void 0:C.TEXTURE_CUBE_MAP);p._bindTextureDirectly(c,H,!0)},Z=(H,p)=>{const V=H.getEngine();for(let w=0;w<p.fileInfo.images.length;w++){const t=p.fileInfo.images[w].levels[0];if(H._invertVScale=H.invertY,-1===p.format||p.format===c.cTFRGB565)if(H.type=10,H.format=4,!V._features.basisNeedsPOT||Math.log2(t.width)%1===0&&Math.log2(t.height)%1===0)H._invertVScale=!H.invertY,H.width=t.width+3&-4,H.height=t.height+3&-4,H.samplingMode=2,N(H,V),V._uploadDataToTextureDirectly(H,new Uint16Array(t.transcodedPixels.buffer),w,0,4,!0);else{const p=new z.e(V,2);H._invertVScale=H.invertY,p.type=10,p.format=4,p.width=t.width+3&-4,p.height=t.height+3&-4,N(p,V),V._uploadDataToTextureDirectly(p,new Uint16Array(t.transcodedPixels.buffer),w,0,4,!0),V._rescaleTexture(p,H,V.scenes[0],V._getInternalFormat(4),(()=>{V._releaseTexture(p),N(H,V)}))}else{H.width=t.width,H.height=t.height,H.generateMipMaps=p.fileInfo.images[w].levels.length>1;const c=Y.GetInternalFormatFromBasisFormat(p.format,V);H.format=c,N(H,V),p.fileInfo.images[w].levels.forEach(((p,C)=>{V._uploadCompressedDataToTextureDirectly(H,c,p.width,p.height,p.transcodedPixels,w,C)})),!V._features.basisNeedsPOT||Math.log2(H.width)%1===0&&Math.log2(H.height)%1===0||(C.c.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),H._cachedWrapU=E.b.CLAMP_ADDRESSMODE,H._cachedWrapV=E.b.CLAMP_ADDRESSMODE)}}},Y={JSModuleURL:t.JSModuleURL,WasmModuleURL:t.WasmModuleURL,GetInternalFormatFromBasisFormat:(H,p)=>{let V;switch(H){case c.cTFETC1:V=36196;break;case c.cTFBC1:V=33776;break;case c.cTFBC4:V=33779;break;case c.cTFASTC_4x4:V=37808;break;case c.cTFETC2:V=37496;break;case c.cTFBC7:V=36492}if(void 0===V)throw"The chosen Basis transcoder format is not currently supported";return V},TranscodeAsync:l,LoadTextureFromTranscodeResult:Z};Object.defineProperty(Y,"JSModuleURL",{get:function(){return t.JSModuleURL},set:function(H){t.JSModuleURL=H}}),Object.defineProperty(Y,"WasmModuleURL",{get:function(){return t.WasmModuleURL},set:function(H){t.WasmModuleURL=H}});class y{constructor(){this.supportCascades=!1}loadCubeData(H,p,V,c,E){if(Array.isArray(H))return;const z=p.getEngine().getCaps(),w={supportedCompressionFormats:{etc1:!!z.etc1,s3tc:!!z.s3tc,pvrtc:!!z.pvrtc,etc2:!!z.etc2,astc:!!z.astc,bc7:!!z.bptc}};l(H,w).then((H=>{const V=H.fileInfo.images[0].levels.length>1&&p.generateMipMaps;Z(p,H),p.getEngine()._setCubeMapTextureParams(p,V),p.isReady=!0,p.onLoadedObservable.notifyObservers(p),p.onLoadedObservable.clear(),c&&c()})).catch((H=>{C.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),p.isReady=!0,E&&E(H)}))}loadData(H,p,V){const c=p.getEngine().getCaps(),E={supportedCompressionFormats:{etc1:!!c.etc1,s3tc:!!c.s3tc,pvrtc:!!c.pvrtc,etc2:!!c.etc2,astc:!!c.astc,bc7:!!c.bptc}};l(H,E).then((H=>{const c=H.fileInfo.images[0].levels[0],C=H.fileInfo.images[0].levels.length>1&&p.generateMipMaps;V(c.width,c.height,C,-1!==H.format,(()=>{Z(p,H)}))})).catch((H=>{C.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),C.c.Warn(`Failed to transcode Basis file: ${H}`),V(0,0,!1,!1,(()=>{}),!0)}))}}}}]);