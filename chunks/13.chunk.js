"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12603:(z,a,K)=>{K.r(a),K.d(a,{_BasisTextureLoader:()=>C});var v,T=K(10631),m=K(11134),p=K(10748);function j(){const z=0,a=1,K=2,v=3,T=6,m=8,p=9,j=10,s=14;let M=null;function r(z,a,K,v,T){const m=z.getImageTranscodedSizeInBytes(a,K,v);let p=new Uint8Array(m);if(!z.transcodeImage(p,a,K,v,1,0))return null;if(T){p=function(z,a,K,v){const T=new Uint16Array(4),m=new Uint16Array(K*v),p=K/4,j=v/4;for(let s=0;s<j;s++)for(let v=0;v<p;v++){const j=a+8*(s*p+v);T[0]=z[j]|z[j+1]<<8,T[1]=z[j+2]|z[j+3]<<8,T[2]=(2*(31&T[0])+1*(31&T[1]))/3|(2*(2016&T[0])+1*(2016&T[1]))/3&2016|(2*(63488&T[0])+1*(63488&T[1]))/3&63488,T[3]=(2*(31&T[1])+1*(31&T[0]))/3|(2*(2016&T[1])+1*(2016&T[0]))/3&2016|(2*(63488&T[1])+1*(63488&T[0]))/3&63488;for(let a=0;a<4;a++){const p=z[j+4+a];let M=(4*s+a)*K+4*v;m[M++]=T[3&p],m[M++]=T[p>>2&3],m[M++]=T[p>>4&3],m[M++]=T[p>>6&3]}}return m}(p,0,z.getImageWidth(a,K)+3&-4,z.getImageHeight(a,K)+3&-4)}return p}onmessage=W=>{if("init"===W.data.action){if(W.data.url)try{importScripts(W.data.url)}catch(F){postMessage({action:"error",error:F})}M||(M=BASIS({wasmBinary:W.data.wasmBinary})),null!==M&&M.then((z=>{BASIS=z,z.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===W.data.action){const M=W.data.config,F=W.data.imageData,G=new BASIS.BasisFile(F),l=function(z){const a=z.getHasAlpha(),K=z.getNumImages(),v=[];for(let T=0;T<K;T++){const a={levels:[]},K=z.getNumLevels(T);for(let v=0;v<K;v++){const K={width:z.getImageWidth(T,v),height:z.getImageHeight(T,v)};a.levels.push(K)}v.push(a)}return{me:a,images:v}}(G);let V=W.data.ignoreSupportedFormats?null:function(M,r){let W=null;M.supportedCompressionFormats&&(W=M.supportedCompressionFormats.astc?j:M.supportedCompressionFormats.bc7?T:M.supportedCompressionFormats.s3tc?r.me?v:K:M.supportedCompressionFormats.pvrtc?r.me?p:m:M.supportedCompressionFormats.etc2?a:M.supportedCompressionFormats.etc1?z:s);return W}(W.data.config,l),c=!1;null===V&&(c=!0,V=l.me?v:K);let C=!0;G.startTranscoding()||(C=!1);const w=[];for(let z=0;z<l.images.length&&C;z++){const a=l.images[z];if(void 0===M.loadSingleImage||M.loadSingleImage===z){let K=a.levels.length;!1===M.loadMipmapLevels&&(K=1);for(let v=0;v<K;v++){const K=a.levels[v],T=r(G,z,v,V,c);if(!T){C=!1;break}K.transcodedPixels=T,w.push(K.transcodedPixels.buffer)}}}G.close(),G.delete(),c&&(V=-1),C?postMessage({action:"transcode",success:C,id:W.data.id,fileInfo:l,format:V},w):postMessage({action:"transcode",success:C,id:W.data.id})}}}!function(z){z[z.cTFETC1=0]="cTFETC1",z[z.cTFETC2=1]="cTFETC2",z[z.cTFBC1=2]="cTFBC1",z[z.cTFBC3=3]="cTFBC3",z[z.cTFBC4=4]="cTFBC4",z[z.cTFBC5=5]="cTFBC5",z[z.cTFBC7=6]="cTFBC7",z[z.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",z[z.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",z[z.cTFASTC_4x4=10]="cTFASTC_4x4",z[z.cTFATC_RGB=11]="cTFATC_RGB",z[z.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",z[z.cTFRGBA32=13]="cTFRGBA32",z[z.cTFRGB565=14]="cTFRGB565",z[z.cTFBGR565=15]="cTFBGR565",z[z.cTFRGBA4444=16]="cTFRGBA4444",z[z.cTFFXT1_RGB=17]="cTFFXT1_RGB",z[z.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",z[z.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",z[z.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",z[z.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(v||(v={}));const s={JSModuleURL:`${T.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${T.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let M=null,r=null,W=0;const F=()=>(M||(M=new Promise(((z,a)=>{r?z(r):T.h.LoadFileAsync(T.h.GetBabylonScriptURL(s.WasmModuleURL)).then((K=>{if("function"!==typeof URL)return a("Basis transcoder requires an environment with a URL constructor");const v=URL.createObjectURL(new Blob([`(${j})()`],{type:"application/javascript"}));r=new Worker(v),function(z,a,K){return new Promise(((v,m)=>{const p=a=>{"init"===a.data.action?(z.removeEventListener("message",p),v(z)):"error"===a.data.action&&m(a.data.error||"error initializing worker")};z.addEventListener("message",p),z.postMessage({action:"init",url:K?T.h.GetBabylonScriptURL(K):void 0,wasmBinary:a},[a])}))}(r,K,s.JSModuleURL).then(z,a)})).catch(a)}))),M),G=(z,a)=>{const K=z instanceof ArrayBuffer?new Uint8Array(z):z;return new Promise(((z,v)=>{F().then((()=>{const T=W++,m=a=>{"transcode"===a.data.action&&a.data.id===T&&(r.removeEventListener("message",m),a.data.success?z(a.data):v("Transcode is not supported on this device"))};r.addEventListener("message",m);const p=new Uint8Array(K.byteLength);p.set(new Uint8Array(K.buffer,K.byteOffset,K.byteLength)),r.postMessage({action:"transcode",id:T,imageData:p,config:a,ignoreSupportedFormats:false},[p.buffer])}),(z=>{v(z)}))}))},l=(z,a)=>{var K;let v=null===(K=a._gl)||void 0===K?void 0:K.TEXTURE_2D;var T;z.isCube&&(v=null===(T=a._gl)||void 0===T?void 0:T.TEXTURE_CUBE_MAP);a._bindTextureDirectly(v,z,!0)},V=(z,a)=>{const K=z.getEngine();for(let j=0;j<a.fileInfo.images.length;j++){const s=a.fileInfo.images[j].levels[0];if(z._invertVScale=z.invertY,-1===a.format||a.format===v.cTFRGB565)if(z.type=10,z.format=4,!K._features.basisNeedsPOT||Math.log2(s.width)%1===0&&Math.log2(s.height)%1===0)z._invertVScale=!z.invertY,z.width=s.width+3&-4,z.height=s.height+3&-4,z.samplingMode=2,l(z,K),K._uploadDataToTextureDirectly(z,new Uint16Array(s.transcodedPixels.buffer),j,0,4,!0);else{const a=new p.b(K,2);z._invertVScale=z.invertY,a.type=10,a.format=4,a.width=s.width+3&-4,a.height=s.height+3&-4,l(a,K),K._uploadDataToTextureDirectly(a,new Uint16Array(s.transcodedPixels.buffer),j,0,4,!0),K._rescaleTexture(a,z,K.scenes[0],K._getInternalFormat(4),(()=>{K._releaseTexture(a),l(z,K)}))}else{z.width=s.width,z.height=s.height,z.generateMipMaps=a.fileInfo.images[j].levels.length>1;const v=c.GetInternalFormatFromBasisFormat(a.format,K);z.format=v,l(z,K),a.fileInfo.images[j].levels.forEach(((a,T)=>{K._uploadCompressedDataToTextureDirectly(z,v,a.width,a.height,a.transcodedPixels,j,T)})),!K._features.basisNeedsPOT||Math.log2(z.width)%1===0&&Math.log2(z.height)%1===0||(T.h.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),z._cachedWrapU=m.d.CLAMP_ADDRESSMODE,z._cachedWrapV=m.d.CLAMP_ADDRESSMODE)}}},c={JSModuleURL:s.JSModuleURL,WasmModuleURL:s.WasmModuleURL,GetInternalFormatFromBasisFormat:(z,a)=>{let K;switch(z){case v.cTFETC1:K=36196;break;case v.cTFBC1:K=33776;break;case v.cTFBC4:K=33779;break;case v.cTFASTC_4x4:K=37808;break;case v.cTFETC2:K=37496;break;case v.cTFBC7:K=36492}if(void 0===K)throw"The chosen Basis transcoder format is not currently supported";return K},TranscodeAsync:G,LoadTextureFromTranscodeResult:V};Object.defineProperty(c,"JSModuleURL",{get:function(){return s.JSModuleURL},set:function(z){s.JSModuleURL=z}}),Object.defineProperty(c,"WasmModuleURL",{get:function(){return s.WasmModuleURL},set:function(z){s.WasmModuleURL=z}});class C{constructor(){this.supportCascades=!1}loadCubeData(z,a,K,v,m){if(Array.isArray(z))return;const p=a.getEngine().getCaps(),j={supportedCompressionFormats:{etc1:!!p.etc1,s3tc:!!p.s3tc,pvrtc:!!p.pvrtc,etc2:!!p.etc2,astc:!!p.astc,bc7:!!p.bptc}};G(z,j).then((z=>{const K=z.fileInfo.images[0].levels.length>1&&a.generateMipMaps;V(a,z),a.getEngine()._setCubeMapTextureParams(a,K),a.isReady=!0,a.onLoadedObservable.notifyObservers(a),a.onLoadedObservable.clear(),v&&v()})).catch((z=>{T.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),a.isReady=!0,m&&m(z)}))}loadData(z,a,K){const v=a.getEngine().getCaps(),m={supportedCompressionFormats:{etc1:!!v.etc1,s3tc:!!v.s3tc,pvrtc:!!v.pvrtc,etc2:!!v.etc2,astc:!!v.astc,bc7:!!v.bptc}};G(z,m).then((z=>{const v=z.fileInfo.images[0].levels[0],T=z.fileInfo.images[0].levels.length>1&&a.generateMipMaps;K(v.width,v.height,T,-1!==z.format,(()=>{V(a,z)}))})).catch((z=>{T.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),T.h.Warn(`Failed to transcode Basis file: ${z}`),K(0,0,!1,!1,(()=>{}),!0)}))}}}}]);