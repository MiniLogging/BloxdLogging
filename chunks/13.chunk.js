"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{13110:(a,v,p)=>{p.r(v),p.d(v,{_BasisTextureLoader:()=>R});var P,b=p(10889),L=p(11460),t=p(11005);function V(){const a=0,v=1,p=2,P=3,b=6,L=8,t=9,V=10,K=14;let C=null;function F(a,v,p,P,b){const L=a.getImageTranscodedSizeInBytes(v,p,P);let t=new Uint8Array(L);if(!a.transcodeImage(t,v,p,P,1,0))return null;if(b){t=function(a,v,p,P){const b=new Uint16Array(4),L=new Uint16Array(p*P),t=p/4,V=P/4;for(let K=0;K<V;K++)for(let P=0;P<t;P++){const V=v+8*(K*t+P);b[0]=a[V]|a[V+1]<<8,b[1]=a[V+2]|a[V+3]<<8,b[2]=(2*(31&b[0])+1*(31&b[1]))/3|(2*(2016&b[0])+1*(2016&b[1]))/3&2016|(2*(63488&b[0])+1*(63488&b[1]))/3&63488,b[3]=(2*(31&b[1])+1*(31&b[0]))/3|(2*(2016&b[1])+1*(2016&b[0]))/3&2016|(2*(63488&b[1])+1*(63488&b[0]))/3&63488;for(let v=0;v<4;v++){const t=a[V+4+v];let C=(4*K+v)*p+4*P;L[C++]=b[3&t],L[C++]=b[t>>2&3],L[C++]=b[t>>4&3],L[C++]=b[t>>6&3]}}return L}(t,0,a.getImageWidth(v,p)+3&-4,a.getImageHeight(v,p)+3&-4)}return t}onmessage=u=>{if("init"===u.data.action){if(u.data.url)try{importScripts(u.data.url)}catch(c){postMessage({action:"error",error:c})}C||(C=BASIS({wasmBinary:u.data.wasmBinary})),null!==C&&C.then((a=>{BASIS=a,a.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===u.data.action){const C=u.data.config,c=u.data.imageData,f=new BASIS.BasisFile(c),H=function(a){const v=a.getHasAlpha(),p=a.getNumImages(),P=[];for(let b=0;b<p;b++){const v={levels:[]},p=a.getNumLevels(b);for(let P=0;P<p;P++){const p={width:a.getImageWidth(b,P),height:a.getImageHeight(b,P)};v.levels.push(p)}P.push(v)}return{Ge:v,images:P}}(f);let A=u.data.ignoreSupportedFormats?null:function(C,F){let u=null;C.supportedCompressionFormats&&(u=C.supportedCompressionFormats.astc?V:C.supportedCompressionFormats.bc7?b:C.supportedCompressionFormats.s3tc?F.Ge?P:p:C.supportedCompressionFormats.pvrtc?F.Ge?t:L:C.supportedCompressionFormats.etc2?v:C.supportedCompressionFormats.etc1?a:K);return u}(u.data.config,H),h=!1;null===A&&(h=!0,A=H.Ge?P:p);let R=!0;f.startTranscoding()||(R=!1);const X=[];for(let a=0;a<H.images.length&&R;a++){const v=H.images[a];if(void 0===C.loadSingleImage||C.loadSingleImage===a){let p=v.levels.length;!1===C.loadMipmapLevels&&(p=1);for(let P=0;P<p;P++){const p=v.levels[P],b=F(f,a,P,A,h);if(!b){R=!1;break}p.transcodedPixels=b,X.push(p.transcodedPixels.buffer)}}}f.close(),f.delete(),h&&(A=-1),R?postMessage({action:"transcode",success:R,id:u.data.id,fileInfo:H,format:A},X):postMessage({action:"transcode",success:R,id:u.data.id})}}}!function(a){a[a.cTFETC1=0]="cTFETC1",a[a.cTFETC2=1]="cTFETC2",a[a.cTFBC1=2]="cTFBC1",a[a.cTFBC3=3]="cTFBC3",a[a.cTFBC4=4]="cTFBC4",a[a.cTFBC5=5]="cTFBC5",a[a.cTFBC7=6]="cTFBC7",a[a.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",a[a.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",a[a.cTFASTC_4x4=10]="cTFASTC_4x4",a[a.cTFATC_RGB=11]="cTFATC_RGB",a[a.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",a[a.cTFRGBA32=13]="cTFRGBA32",a[a.cTFRGB565=14]="cTFRGB565",a[a.cTFBGR565=15]="cTFBGR565",a[a.cTFRGBA4444=16]="cTFRGBA4444",a[a.cTFFXT1_RGB=17]="cTFFXT1_RGB",a[a.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",a[a.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",a[a.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",a[a.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(P||(P={}));const K={JSModuleURL:`${b.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${b.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let C=null,F=null,u=0;const c=()=>(C||(C=new Promise(((a,v)=>{F?a(F):b.e.LoadFileAsync(b.e.GetBabylonScriptURL(K.WasmModuleURL)).then((p=>{if("function"!==typeof URL)return v("Basis transcoder requires an environment with a URL constructor");const P=URL.createObjectURL(new Blob([`(${V})()`],{type:"application/javascript"}));F=new Worker(P),function(a,v,p){return new Promise(((P,L)=>{const t=v=>{"init"===v.data.action?(a.removeEventListener("message",t),P(a)):"error"===v.data.action&&L(v.data.error||"error initializing worker")};a.addEventListener("message",t),a.postMessage({action:"init",url:p?b.e.GetBabylonScriptURL(p):void 0,wasmBinary:v},[v])}))}(F,p,K.JSModuleURL).then(a,v)})).catch(v)}))),C),f=(a,v)=>{const p=a instanceof ArrayBuffer?new Uint8Array(a):a;return new Promise(((a,P)=>{c().then((()=>{const b=u++,L=v=>{"transcode"===v.data.action&&v.data.id===b&&(F.removeEventListener("message",L),v.data.success?a(v.data):P("Transcode is not supported on this device"))};F.addEventListener("message",L);const t=new Uint8Array(p.byteLength);t.set(new Uint8Array(p.buffer,p.byteOffset,p.byteLength)),F.postMessage({action:"transcode",id:b,imageData:t,config:v,ignoreSupportedFormats:false},[t.buffer])}),(a=>{P(a)}))}))},H=(a,v)=>{var p;let P=null===(p=v._gl)||void 0===p?void 0:p.TEXTURE_2D;var b;a.isCube&&(P=null===(b=v._gl)||void 0===b?void 0:b.TEXTURE_CUBE_MAP);v._bindTextureDirectly(P,a,!0)},A=(a,v)=>{const p=a.getEngine();for(let V=0;V<v.fileInfo.images.length;V++){const K=v.fileInfo.images[V].levels[0];if(a._invertVScale=a.invertY,-1===v.format||v.format===P.cTFRGB565)if(a.type=10,a.format=4,!p._features.basisNeedsPOT||Math.log2(K.width)%1===0&&Math.log2(K.height)%1===0)a._invertVScale=!a.invertY,a.width=K.width+3&-4,a.height=K.height+3&-4,a.samplingMode=2,H(a,p),p._uploadDataToTextureDirectly(a,new Uint16Array(K.transcodedPixels.buffer),V,0,4,!0);else{const v=new t.d(p,2);a._invertVScale=a.invertY,v.type=10,v.format=4,v.width=K.width+3&-4,v.height=K.height+3&-4,H(v,p),p._uploadDataToTextureDirectly(v,new Uint16Array(K.transcodedPixels.buffer),V,0,4,!0),p._rescaleTexture(v,a,p.scenes[0],p._getInternalFormat(4),(()=>{p._releaseTexture(v),H(a,p)}))}else{a.width=K.width,a.height=K.height,a.generateMipMaps=v.fileInfo.images[V].levels.length>1;const P=h.GetInternalFormatFromBasisFormat(v.format,p);a.format=P,H(a,p),v.fileInfo.images[V].levels.forEach(((v,b)=>{p._uploadCompressedDataToTextureDirectly(a,P,v.width,v.height,v.transcodedPixels,V,b)})),!p._features.basisNeedsPOT||Math.log2(a.width)%1===0&&Math.log2(a.height)%1===0||(b.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),a._cachedWrapU=L.c.CLAMP_ADDRESSMODE,a._cachedWrapV=L.c.CLAMP_ADDRESSMODE)}}},h={JSModuleURL:K.JSModuleURL,WasmModuleURL:K.WasmModuleURL,GetInternalFormatFromBasisFormat:(a,v)=>{let p;switch(a){case P.cTFETC1:p=36196;break;case P.cTFBC1:p=33776;break;case P.cTFBC4:p=33779;break;case P.cTFASTC_4x4:p=37808;break;case P.cTFETC2:p=37496;break;case P.cTFBC7:p=36492}if(void 0===p)throw"The chosen Basis transcoder format is not currently supported";return p},TranscodeAsync:f,LoadTextureFromTranscodeResult:A};Object.defineProperty(h,"JSModuleURL",{get:function(){return K.JSModuleURL},set:function(a){K.JSModuleURL=a}}),Object.defineProperty(h,"WasmModuleURL",{get:function(){return K.WasmModuleURL},set:function(a){K.WasmModuleURL=a}});class R{constructor(){this.supportCascades=!1}loadCubeData(a,v,p,P,L){if(Array.isArray(a))return;const t=v.getEngine().getCaps(),V={supportedCompressionFormats:{etc1:!!t.etc1,s3tc:!!t.s3tc,pvrtc:!!t.pvrtc,etc2:!!t.etc2,astc:!!t.astc,bc7:!!t.bptc}};f(a,V).then((a=>{const p=a.fileInfo.images[0].levels.length>1&&v.generateMipMaps;A(v,a),v.getEngine()._setCubeMapTextureParams(v,p),v.isReady=!0,v.onLoadedObservable.notifyObservers(v),v.onLoadedObservable.clear(),P&&P()})).catch((a=>{b.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),v.isReady=!0,L&&L(a)}))}loadData(a,v,p){const P=v.getEngine().getCaps(),L={supportedCompressionFormats:{etc1:!!P.etc1,s3tc:!!P.s3tc,pvrtc:!!P.pvrtc,etc2:!!P.etc2,astc:!!P.astc,bc7:!!P.bptc}};f(a,L).then((a=>{const P=a.fileInfo.images[0].levels[0],b=a.fileInfo.images[0].levels.length>1&&v.generateMipMaps;p(P.width,P.height,b,-1!==a.format,(()=>{A(v,a)}))})).catch((a=>{b.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),b.e.Warn(`Failed to transcode Basis file: ${a}`),p(0,0,!1,!1,(()=>{}),!0)}))}}}}]);