"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{2254:(U,W,l)=>{l.r(W),l.d(W,{_HDRTextureLoader:()=>q});var M=l(706);class t{static ConvertPanoramaToCubemap(U,W,l,M){let t=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!U)throw"ConvertPanoramaToCubemap: input cannot be null";if(U.length!=W*l*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(M,this.FACE_FRONT,U,W,l,t),back:this.CreateCubemapTexture(M,this.FACE_BACK,U,W,l,t),left:this.CreateCubemapTexture(M,this.FACE_LEFT,U,W,l,t),right:this.CreateCubemapTexture(M,this.FACE_RIGHT,U,W,l,t),up:this.CreateCubemapTexture(M,this.FACE_UP,U,W,l,t),down:this.CreateCubemapTexture(M,this.FACE_DOWN,U,W,l,t),size:M,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(U,W,l,M,t){let L=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const p=new ArrayBuffer(U*U*4*3),B=new Float32Array(p),k=L?Math.max(1,Math.round(M/4/U)):1,A=1/k,q=A*A,y=W[1].de(W[0]).scale(A/U),j=W[3].de(W[2]).scale(A/U),s=1/U;let w=0;for(let K=0;K<U;K++)for(let L=0;L<k;L++){let L=W[0],p=W[2];for(let W=0;W<U;W++)for(let A=0;A<k;A++){const k=p.de(L).scale(w).add(L);k.normalize();const A=this.CalcProjectionSpherical(k,l,M,t);B[K*U*3+3*W+0]+=A.r*q,B[K*U*3+3*W+1]+=A.g*q,B[K*U*3+3*W+2]+=A.b*q,L=L.add(y),p=p.add(j)}w+=s*A}return B}static CalcProjectionSpherical(U,W,l,M){let t=Math.atan2(U.z,U.x);const L=Math.acos(U.y);for(;t<-Math.PI;)t+=2*Math.PI;for(;t>Math.PI;)t-=2*Math.PI;let p=t/Math.PI;const B=L/Math.PI;p=.5*p+.5;let k=Math.round(p*l);k<0?k=0:k>=l&&(k=l-1);let A=Math.round(B*M);A<0?A=0:A>=M&&(A=M-1);const q=M-A-1;return{r:W[q*l*3+3*k+0],g:W[q*l*3+3*k+1],b:W[q*l*3+3*k+2]}}}function L(U,W,l,M,t,L){t>0?(t=function(U,W){return W>1023?U*Math.pow(2,1023)*Math.pow(2,W-1023):W<-1074?U*Math.pow(2,-1074)*Math.pow(2,W+1074):U*Math.pow(2,W)}(1,t-136),U[L+0]=W*t,U[L+1]=l*t,U[L+2]=M*t):(U[L+0]=0,U[L+1]=0,U[L+2]=0)}function p(U,W){let l="",M="";for(let t=W;t<U.length-W&&(M=String.fromCharCode(U[t]),"\n"!=M);t++)l+=M;return l}function B(U){let W=0,l=0,M=p(U,0);if("#"!=M[0]||"?"!=M[1])throw"Bad HDR Format.";let t=!1,L=!1,B=0;do{B+=M.length+1,M=p(U,B),"FORMAT=32-bit_rle_rgbe"==M?L=!0:0==M.length&&(t=!0)}while(!t);if(!L)throw"HDR Bad header format, unsupported FORMAT";B+=M.length+1,M=p(U,B);const k=/^-Y (.*) \+X (.*)$/g.exec(M);if(!k||k.length<3)throw"HDR Bad header format, no size";if(l=parseInt(k[2]),W=parseInt(k[1]),l<8||l>32767)throw"HDR Bad header format, unsupported size";return B+=M.length+1,{height:W,width:l,dataPosition:B}}function k(U,W){return function(U,W){let l=W.height;const M=W.width;let t,p,B,k,q,y=W.dataPosition,j=0,s=0,w=0;const K=new ArrayBuffer(4*M),r=new Uint8Array(K),m=new ArrayBuffer(W.width*W.height*4*3),f=new Float32Array(m);for(;l>0;){if(t=U[y++],p=U[y++],B=U[y++],k=U[y++],2!=t||2!=p||128&B||W.width<8||W.width>32767)return A(U,W);if((B<<8|k)!=M)throw"HDR Bad header format, wrong scan line width";for(j=0,w=0;w<4;w++)for(s=(w+1)*M;j<s;)if(t=U[y++],p=U[y++],t>128){if(q=t-128,0==q||q>s-j)throw"HDR Bad Format, bad scanline data (run)";for(;q-- >0;)r[j++]=p}else{if(q=t,0==q||q>s-j)throw"HDR Bad Format, bad scanline data (non-run)";if(r[j++]=p,--q>0)for(let W=0;W<q;W++)r[j++]=U[y++]}for(w=0;w<M;w++)t=r[w],p=r[w+M],B=r[w+2*M],k=r[w+3*M],L(f,t,p,B,k,(W.height-l)*M*3+3*w);l--}return f}(U,W)}function A(U,W){let l=W.height;const M=W.width;let t,p,B,k,A,q=W.dataPosition;const y=new ArrayBuffer(W.width*W.height*4*3),j=new Float32Array(y);for(;l>0;){for(A=0;A<W.width;A++)t=U[q++],p=U[q++],B=U[q++],k=U[q++],L(j,t,p,B,k,(W.height-l)*M*3+3*A);l--}return j}t.FACE_LEFT=[new M.l(-1,-1,-1),new M.l(1,-1,-1),new M.l(-1,1,-1),new M.l(1,1,-1)],t.FACE_RIGHT=[new M.l(1,-1,1),new M.l(-1,-1,1),new M.l(1,1,1),new M.l(-1,1,1)],t.FACE_FRONT=[new M.l(1,-1,-1),new M.l(1,-1,1),new M.l(1,1,-1),new M.l(1,1,1)],t.FACE_BACK=[new M.l(-1,-1,1),new M.l(-1,-1,-1),new M.l(-1,1,1),new M.l(-1,1,-1)],t.FACE_DOWN=[new M.l(1,1,-1),new M.l(1,1,1),new M.l(-1,1,-1),new M.l(-1,1,1)],t.FACE_UP=[new M.l(-1,-1,-1),new M.l(-1,-1,1),new M.l(1,-1,-1),new M.l(1,-1,1)];class q{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(U,W,l){const M=new Uint8Array(U.buffer,U.byteOffset,U.byteLength),t=B(M),L=k(M,t),p=t.width*t.height,A=new Float32Array(4*p);for(let B=0;B<p;B+=1)A[4*B]=L[3*B],A[4*B+1]=L[3*B+1],A[4*B+2]=L[3*B+2],A[4*B+3]=1;l(t.width,t.height,W.generateMipMaps,!1,(()=>{const U=W.getEngine();W.type=1,W.format=5,W._gammaSpace=!1,U._uploadDataToTextureDirectly(W,A)}))}}}}]);