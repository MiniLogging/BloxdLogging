"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12700:(Y,j,X)=>{X.r(j),X.d(j,{_BasisTextureLoader:()=>C});var u,K=X(10748),U=X(11281),I=X(10862);function y(){const Y=0,j=1,X=2,u=3,K=6,U=8,I=9,y=10,T=14;let E=null;function e(Y,j,X,u,K){const U=Y.getImageTranscodedSizeInBytes(j,X,u);let I=new Uint8Array(U);if(!Y.transcodeImage(I,j,X,u,1,0))return null;if(K){I=function(Y,j,X,u){const K=new Uint16Array(4),U=new Uint16Array(X*u),I=X/4,y=u/4;for(let T=0;T<y;T++)for(let u=0;u<I;u++){const y=j+8*(T*I+u);K[0]=Y[y]|Y[y+1]<<8,K[1]=Y[y+2]|Y[y+3]<<8,K[2]=(2*(31&K[0])+1*(31&K[1]))/3|(2*(2016&K[0])+1*(2016&K[1]))/3&2016|(2*(63488&K[0])+1*(63488&K[1]))/3&63488,K[3]=(2*(31&K[1])+1*(31&K[0]))/3|(2*(2016&K[1])+1*(2016&K[0]))/3&2016|(2*(63488&K[1])+1*(63488&K[0]))/3&63488;for(let j=0;j<4;j++){const I=Y[y+4+j];let E=(4*T+j)*X+4*u;U[E++]=K[3&I],U[E++]=K[I>>2&3],U[E++]=K[I>>4&3],U[E++]=K[I>>6&3]}}return U}(I,0,Y.getImageWidth(j,X)+3&-4,Y.getImageHeight(j,X)+3&-4)}return I}onmessage=a=>{if("init"===a.data.action){if(a.data.url)try{importScripts(a.data.url)}catch(N){postMessage({action:"error",error:N})}E||(E=BASIS({wasmBinary:a.data.wasmBinary})),null!==E&&E.then((Y=>{BASIS=Y,Y.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===a.data.action){const E=a.data.config,N=a.data.imageData,d=new BASIS.BasisFile(N),i=function(Y){const j=Y.getHasAlpha(),X=Y.getNumImages(),u=[];for(let K=0;K<X;K++){const j={levels:[]},X=Y.getNumLevels(K);for(let u=0;u<X;u++){const X={width:Y.getImageWidth(K,u),height:Y.getImageHeight(K,u)};j.levels.push(X)}u.push(j)}return{fc:j,images:u}}(d);let M=a.data.ignoreSupportedFormats?null:function(E,e){let a=null;E.supportedCompressionFormats&&(a=E.supportedCompressionFormats.astc?y:E.supportedCompressionFormats.bc7?K:E.supportedCompressionFormats.s3tc?e.fc?u:X:E.supportedCompressionFormats.pvrtc?e.fc?I:U:E.supportedCompressionFormats.etc2?j:E.supportedCompressionFormats.etc1?Y:T);return a}(a.data.config,i),R=!1;null===M&&(R=!0,M=i.fc?u:X);let C=!0;d.startTranscoding()||(C=!1);const O=[];for(let Y=0;Y<i.images.length&&C;Y++){const j=i.images[Y];if(void 0===E.loadSingleImage||E.loadSingleImage===Y){let X=j.levels.length;!1===E.loadMipmapLevels&&(X=1);for(let u=0;u<X;u++){const X=j.levels[u],K=e(d,Y,u,M,R);if(!K){C=!1;break}X.transcodedPixels=K,O.push(X.transcodedPixels.buffer)}}}d.close(),d.delete(),R&&(M=-1),C?postMessage({action:"transcode",success:C,id:a.data.id,fileInfo:i,format:M},O):postMessage({action:"transcode",success:C,id:a.data.id})}}}!function(Y){Y[Y.cTFETC1=0]="cTFETC1",Y[Y.cTFETC2=1]="cTFETC2",Y[Y.cTFBC1=2]="cTFBC1",Y[Y.cTFBC3=3]="cTFBC3",Y[Y.cTFBC4=4]="cTFBC4",Y[Y.cTFBC5=5]="cTFBC5",Y[Y.cTFBC7=6]="cTFBC7",Y[Y.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Y[Y.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Y[Y.cTFASTC_4x4=10]="cTFASTC_4x4",Y[Y.cTFATC_RGB=11]="cTFATC_RGB",Y[Y.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Y[Y.cTFRGBA32=13]="cTFRGBA32",Y[Y.cTFRGB565=14]="cTFRGB565",Y[Y.cTFBGR565=15]="cTFBGR565",Y[Y.cTFRGBA4444=16]="cTFRGBA4444",Y[Y.cTFFXT1_RGB=17]="cTFFXT1_RGB",Y[Y.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Y[Y.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Y[Y.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Y[Y.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(u||(u={}));const T={JSModuleURL:`${K.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${K.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let E=null,e=null,a=0;const N=()=>(E||(E=new Promise(((Y,j)=>{e?Y(e):K.c.LoadFileAsync(K.c.GetBabylonScriptURL(T.WasmModuleURL)).then((X=>{if("function"!==typeof URL)return j("Basis transcoder requires an environment with a URL constructor");const u=URL.createObjectURL(new Blob([`(${y})()`],{type:"application/javascript"}));e=new Worker(u),function(Y,j,X){return new Promise(((u,U)=>{const I=j=>{"init"===j.data.action?(Y.removeEventListener("message",I),u(Y)):"error"===j.data.action&&U(j.data.error||"error initializing worker")};Y.addEventListener("message",I),Y.postMessage({action:"init",url:X?K.c.GetBabylonScriptURL(X):void 0,wasmBinary:j},[j])}))}(e,X,T.JSModuleURL).then(Y,j)})).catch(j)}))),E),d=(Y,j)=>{const X=Y instanceof ArrayBuffer?new Uint8Array(Y):Y;return new Promise(((Y,u)=>{N().then((()=>{const K=a++,U=j=>{"transcode"===j.data.action&&j.data.id===K&&(e.removeEventListener("message",U),j.data.success?Y(j.data):u("Transcode is not supported on this device"))};e.addEventListener("message",U);const I=new Uint8Array(X.byteLength);I.set(new Uint8Array(X.buffer,X.byteOffset,X.byteLength)),e.postMessage({action:"transcode",id:K,imageData:I,config:j,ignoreSupportedFormats:false},[I.buffer])}),(Y=>{u(Y)}))}))},i=(Y,j)=>{var X;let u=null===(X=j._gl)||void 0===X?void 0:X.TEXTURE_2D;var K;Y.isCube&&(u=null===(K=j._gl)||void 0===K?void 0:K.TEXTURE_CUBE_MAP);j._bindTextureDirectly(u,Y,!0)},M=(Y,j)=>{const X=Y.getEngine();for(let y=0;y<j.fileInfo.images.length;y++){const T=j.fileInfo.images[y].levels[0];if(Y._invertVScale=Y.invertY,-1===j.format||j.format===u.cTFRGB565)if(Y.type=10,Y.format=4,!X._features.basisNeedsPOT||Math.log2(T.width)%1===0&&Math.log2(T.height)%1===0)Y._invertVScale=!Y.invertY,Y.width=T.width+3&-4,Y.height=T.height+3&-4,Y.samplingMode=2,i(Y,X),X._uploadDataToTextureDirectly(Y,new Uint16Array(T.transcodedPixels.buffer),y,0,4,!0);else{const j=new I.e(X,2);Y._invertVScale=Y.invertY,j.type=10,j.format=4,j.width=T.width+3&-4,j.height=T.height+3&-4,i(j,X),X._uploadDataToTextureDirectly(j,new Uint16Array(T.transcodedPixels.buffer),y,0,4,!0),X._rescaleTexture(j,Y,X.scenes[0],X._getInternalFormat(4),(()=>{X._releaseTexture(j),i(Y,X)}))}else{Y.width=T.width,Y.height=T.height,Y.generateMipMaps=j.fileInfo.images[y].levels.length>1;const u=R.GetInternalFormatFromBasisFormat(j.format,X);Y.format=u,i(Y,X),j.fileInfo.images[y].levels.forEach(((j,K)=>{X._uploadCompressedDataToTextureDirectly(Y,u,j.width,j.height,j.transcodedPixels,y,K)})),!X._features.basisNeedsPOT||Math.log2(Y.width)%1===0&&Math.log2(Y.height)%1===0||(K.c.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Y._cachedWrapU=U.e.CLAMP_ADDRESSMODE,Y._cachedWrapV=U.e.CLAMP_ADDRESSMODE)}}},R={JSModuleURL:T.JSModuleURL,WasmModuleURL:T.WasmModuleURL,GetInternalFormatFromBasisFormat:(Y,j)=>{let X;switch(Y){case u.cTFETC1:X=36196;break;case u.cTFBC1:X=33776;break;case u.cTFBC4:X=33779;break;case u.cTFASTC_4x4:X=37808;break;case u.cTFETC2:X=37496;break;case u.cTFBC7:X=36492}if(void 0===X)throw"The chosen Basis transcoder format is not currently supported";return X},TranscodeAsync:d,LoadTextureFromTranscodeResult:M};Object.defineProperty(R,"JSModuleURL",{get:function(){return T.JSModuleURL},set:function(Y){T.JSModuleURL=Y}}),Object.defineProperty(R,"WasmModuleURL",{get:function(){return T.WasmModuleURL},set:function(Y){T.WasmModuleURL=Y}});class C{constructor(){this.supportCascades=!1}loadCubeData(Y,j,X,u,U){if(Array.isArray(Y))return;const I=j.getEngine().getCaps(),y={supportedCompressionFormats:{etc1:!!I.etc1,s3tc:!!I.s3tc,pvrtc:!!I.pvrtc,etc2:!!I.etc2,astc:!!I.astc,bc7:!!I.bptc}};d(Y,y).then((Y=>{const X=Y.fileInfo.images[0].levels.length>1&&j.generateMipMaps;M(j,Y),j.getEngine()._setCubeMapTextureParams(j,X),j.isReady=!0,j.onLoadedObservable.notifyObservers(j),j.onLoadedObservable.clear(),u&&u()})).catch((Y=>{K.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),j.isReady=!0,U&&U(Y)}))}loadData(Y,j,X){const u=j.getEngine().getCaps(),U={supportedCompressionFormats:{etc1:!!u.etc1,s3tc:!!u.s3tc,pvrtc:!!u.pvrtc,etc2:!!u.etc2,astc:!!u.astc,bc7:!!u.bptc}};d(Y,U).then((Y=>{const u=Y.fileInfo.images[0].levels[0],K=Y.fileInfo.images[0].levels.length>1&&j.generateMipMaps;X(u.width,u.height,K,-1!==Y.format,(()=>{M(j,Y)}))})).catch((Y=>{K.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),K.c.Warn(`Failed to transcode Basis file: ${Y}`),X(0,0,!1,!1,(()=>{}),!0)}))}}}}]);