"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12860:(V,O,Z)=>{Z.r(O),Z.d(O,{_BasisTextureLoader:()=>U});var d,p=Z(10900),r=Z(11467),Y=Z(11013);function m(){const V=0,O=1,Z=2,d=3,p=6,r=8,Y=9,m=10,a=14;let R=null;function i(V,O,Z,d,p){const r=V.getImageTranscodedSizeInBytes(O,Z,d);let Y=new Uint8Array(r);if(!V.transcodeImage(Y,O,Z,d,1,0))return null;if(p){Y=function(V,O,Z,d){const p=new Uint16Array(4),r=new Uint16Array(Z*d),Y=Z/4,m=d/4;for(let a=0;a<m;a++)for(let d=0;d<Y;d++){const m=O+8*(a*Y+d);p[0]=V[m]|V[m+1]<<8,p[1]=V[m+2]|V[m+3]<<8,p[2]=(2*(31&p[0])+1*(31&p[1]))/3|(2*(2016&p[0])+1*(2016&p[1]))/3&2016|(2*(63488&p[0])+1*(63488&p[1]))/3&63488,p[3]=(2*(31&p[1])+1*(31&p[0]))/3|(2*(2016&p[1])+1*(2016&p[0]))/3&2016|(2*(63488&p[1])+1*(63488&p[0]))/3&63488;for(let O=0;O<4;O++){const Y=V[m+4+O];let R=(4*a+O)*Z+4*d;r[R++]=p[3&Y],r[R++]=p[Y>>2&3],r[R++]=p[Y>>4&3],r[R++]=p[Y>>6&3]}}return r}(Y,0,V.getImageWidth(O,Z)+3&-4,V.getImageHeight(O,Z)+3&-4)}return Y}onmessage=M=>{if("init"===M.data.action){if(M.data.url)try{importScripts(M.data.url)}catch(c){postMessage({action:"error",error:c})}R||(R=BASIS({wasmBinary:M.data.wasmBinary})),null!==R&&R.then((V=>{BASIS=V,V.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===M.data.action){const R=M.data.config,c=M.data.imageData,W=new BASIS.BasisFile(c),F=function(V){const O=V.getHasAlpha(),Z=V.getNumImages(),d=[];for(let p=0;p<Z;p++){const O={levels:[]},Z=V.getNumLevels(p);for(let d=0;d<Z;d++){const Z={width:V.getImageWidth(p,d),height:V.getImageHeight(p,d)};O.levels.push(Z)}d.push(O)}return{uc:O,images:d}}(W);let Q=M.data.ignoreSupportedFormats?null:function(R,i){let M=null;R.supportedCompressionFormats&&(M=R.supportedCompressionFormats.astc?m:R.supportedCompressionFormats.bc7?p:R.supportedCompressionFormats.s3tc?i.uc?d:Z:R.supportedCompressionFormats.pvrtc?i.uc?Y:r:R.supportedCompressionFormats.etc2?O:R.supportedCompressionFormats.etc1?V:a);return M}(M.data.config,F),b=!1;null===Q&&(b=!0,Q=F.uc?d:Z);let U=!0;W.startTranscoding()||(U=!1);const H=[];for(let V=0;V<F.images.length&&U;V++){const O=F.images[V];if(void 0===R.loadSingleImage||R.loadSingleImage===V){let Z=O.levels.length;!1===R.loadMipmapLevels&&(Z=1);for(let d=0;d<Z;d++){const Z=O.levels[d],p=i(W,V,d,Q,b);if(!p){U=!1;break}Z.transcodedPixels=p,H.push(Z.transcodedPixels.buffer)}}}W.close(),W.delete(),b&&(Q=-1),U?postMessage({action:"transcode",success:U,id:M.data.id,fileInfo:F,format:Q},H):postMessage({action:"transcode",success:U,id:M.data.id})}}}!function(V){V[V.cTFETC1=0]="cTFETC1",V[V.cTFETC2=1]="cTFETC2",V[V.cTFBC1=2]="cTFBC1",V[V.cTFBC3=3]="cTFBC3",V[V.cTFBC4=4]="cTFBC4",V[V.cTFBC5=5]="cTFBC5",V[V.cTFBC7=6]="cTFBC7",V[V.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",V[V.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",V[V.cTFASTC_4x4=10]="cTFASTC_4x4",V[V.cTFATC_RGB=11]="cTFATC_RGB",V[V.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",V[V.cTFRGBA32=13]="cTFRGBA32",V[V.cTFRGB565=14]="cTFRGB565",V[V.cTFBGR565=15]="cTFBGR565",V[V.cTFRGBA4444=16]="cTFRGBA4444",V[V.cTFFXT1_RGB=17]="cTFFXT1_RGB",V[V.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",V[V.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",V[V.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",V[V.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(d||(d={}));const a={JSModuleURL:`${p.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${p.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let R=null,i=null,M=0;const c=()=>(R||(R=new Promise(((V,O)=>{i?V(i):p.e.LoadFileAsync(p.e.GetBabylonScriptURL(a.WasmModuleURL)).then((Z=>{if("function"!==typeof URL)return O("Basis transcoder requires an environment with a URL constructor");const d=URL.createObjectURL(new Blob([`(${m})()`],{type:"application/javascript"}));i=new Worker(d),function(V,O,Z){return new Promise(((d,r)=>{const Y=O=>{"init"===O.data.action?(V.removeEventListener("message",Y),d(V)):"error"===O.data.action&&r(O.data.error||"error initializing worker")};V.addEventListener("message",Y),V.postMessage({action:"init",url:Z?p.e.GetBabylonScriptURL(Z):void 0,wasmBinary:O},[O])}))}(i,Z,a.JSModuleURL).then(V,O)})).catch(O)}))),R),W=(V,O)=>{const Z=V instanceof ArrayBuffer?new Uint8Array(V):V;return new Promise(((V,d)=>{c().then((()=>{const p=M++,r=O=>{"transcode"===O.data.action&&O.data.id===p&&(i.removeEventListener("message",r),O.data.success?V(O.data):d("Transcode is not supported on this device"))};i.addEventListener("message",r);const Y=new Uint8Array(Z.byteLength);Y.set(new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength)),i.postMessage({action:"transcode",id:p,imageData:Y,config:O,ignoreSupportedFormats:false},[Y.buffer])}),(V=>{d(V)}))}))},F=(V,O)=>{var Z;let d=null===(Z=O._gl)||void 0===Z?void 0:Z.TEXTURE_2D;var p;V.isCube&&(d=null===(p=O._gl)||void 0===p?void 0:p.TEXTURE_CUBE_MAP);O._bindTextureDirectly(d,V,!0)},Q=(V,O)=>{const Z=V.getEngine();for(let m=0;m<O.fileInfo.images.length;m++){const a=O.fileInfo.images[m].levels[0];if(V._invertVScale=V.invertY,-1===O.format||O.format===d.cTFRGB565)if(V.type=10,V.format=4,!Z._features.basisNeedsPOT||Math.log2(a.width)%1===0&&Math.log2(a.height)%1===0)V._invertVScale=!V.invertY,V.width=a.width+3&-4,V.height=a.height+3&-4,V.samplingMode=2,F(V,Z),Z._uploadDataToTextureDirectly(V,new Uint16Array(a.transcodedPixels.buffer),m,0,4,!0);else{const O=new Y.d(Z,2);V._invertVScale=V.invertY,O.type=10,O.format=4,O.width=a.width+3&-4,O.height=a.height+3&-4,F(O,Z),Z._uploadDataToTextureDirectly(O,new Uint16Array(a.transcodedPixels.buffer),m,0,4,!0),Z._rescaleTexture(O,V,Z.scenes[0],Z._getInternalFormat(4),(()=>{Z._releaseTexture(O),F(V,Z)}))}else{V.width=a.width,V.height=a.height,V.generateMipMaps=O.fileInfo.images[m].levels.length>1;const d=b.GetInternalFormatFromBasisFormat(O.format,Z);V.format=d,F(V,Z),O.fileInfo.images[m].levels.forEach(((O,p)=>{Z._uploadCompressedDataToTextureDirectly(V,d,O.width,O.height,O.transcodedPixels,m,p)})),!Z._features.basisNeedsPOT||Math.log2(V.width)%1===0&&Math.log2(V.height)%1===0||(p.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),V._cachedWrapU=r.b.CLAMP_ADDRESSMODE,V._cachedWrapV=r.b.CLAMP_ADDRESSMODE)}}},b={JSModuleURL:a.JSModuleURL,WasmModuleURL:a.WasmModuleURL,GetInternalFormatFromBasisFormat:(V,O)=>{let Z;switch(V){case d.cTFETC1:Z=36196;break;case d.cTFBC1:Z=33776;break;case d.cTFBC4:Z=33779;break;case d.cTFASTC_4x4:Z=37808;break;case d.cTFETC2:Z=37496;break;case d.cTFBC7:Z=36492}if(void 0===Z)throw"The chosen Basis transcoder format is not currently supported";return Z},TranscodeAsync:W,LoadTextureFromTranscodeResult:Q};Object.defineProperty(b,"JSModuleURL",{get:function(){return a.JSModuleURL},set:function(V){a.JSModuleURL=V}}),Object.defineProperty(b,"WasmModuleURL",{get:function(){return a.WasmModuleURL},set:function(V){a.WasmModuleURL=V}});class U{constructor(){this.supportCascades=!1}loadCubeData(V,O,Z,d,r){if(Array.isArray(V))return;const Y=O.getEngine().getCaps(),m={supportedCompressionFormats:{etc1:!!Y.etc1,s3tc:!!Y.s3tc,pvrtc:!!Y.pvrtc,etc2:!!Y.etc2,astc:!!Y.astc,bc7:!!Y.bptc}};W(V,m).then((V=>{const Z=V.fileInfo.images[0].levels.length>1&&O.generateMipMaps;Q(O,V),O.getEngine()._setCubeMapTextureParams(O,Z),O.isReady=!0,O.onLoadedObservable.notifyObservers(O),O.onLoadedObservable.clear(),d&&d()})).catch((V=>{p.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),O.isReady=!0,r&&r(V)}))}loadData(V,O,Z){const d=O.getEngine().getCaps(),r={supportedCompressionFormats:{etc1:!!d.etc1,s3tc:!!d.s3tc,pvrtc:!!d.pvrtc,etc2:!!d.etc2,astc:!!d.astc,bc7:!!d.bptc}};W(V,r).then((V=>{const d=V.fileInfo.images[0].levels[0],p=V.fileInfo.images[0].levels.length>1&&O.generateMipMaps;Z(d.width,d.height,p,-1!==V.format,(()=>{Q(O,V)}))})).catch((V=>{p.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),p.e.Warn(`Failed to transcode Basis file: ${V}`),Z(0,0,!1,!1,(()=>{}),!0)}))}}}}]);