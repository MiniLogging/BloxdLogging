"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{13020:(y,g,f)=>{f.r(g),f.d(g,{_BasisTextureLoader:()=>B});var p,S=f(10714),k=f(11267),i=f(10845);function H(){const y=0,g=1,f=2,p=3,S=6,k=8,i=9,H=10,U=14;let l=null;function c(y,g,f,p,S){const k=y.getImageTranscodedSizeInBytes(g,f,p);let i=new Uint8Array(k);if(!y.transcodeImage(i,g,f,p,1,0))return null;if(S){i=function(y,g,f,p){const S=new Uint16Array(4),k=new Uint16Array(f*p),i=f/4,H=p/4;for(let U=0;U<H;U++)for(let p=0;p<i;p++){const H=g+8*(U*i+p);S[0]=y[H]|y[H+1]<<8,S[1]=y[H+2]|y[H+3]<<8,S[2]=(2*(31&S[0])+1*(31&S[1]))/3|(2*(2016&S[0])+1*(2016&S[1]))/3&2016|(2*(63488&S[0])+1*(63488&S[1]))/3&63488,S[3]=(2*(31&S[1])+1*(31&S[0]))/3|(2*(2016&S[1])+1*(2016&S[0]))/3&2016|(2*(63488&S[1])+1*(63488&S[0]))/3&63488;for(let g=0;g<4;g++){const i=y[H+4+g];let l=(4*U+g)*f+4*p;k[l++]=S[3&i],k[l++]=S[i>>2&3],k[l++]=S[i>>4&3],k[l++]=S[i>>6&3]}}return k}(i,0,y.getImageWidth(g,f)+3&-4,y.getImageHeight(g,f)+3&-4)}return i}onmessage=Z=>{if("init"===Z.data.action){if(Z.data.url)try{importScripts(Z.data.url)}catch(C){postMessage({action:"error",error:C})}l||(l=BASIS({wasmBinary:Z.data.wasmBinary})),null!==l&&l.then((y=>{BASIS=y,y.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===Z.data.action){const l=Z.data.config,C=Z.data.imageData,q=new BASIS.BasisFile(C),W=function(y){const g=y.getHasAlpha(),f=y.getNumImages(),p=[];for(let S=0;S<f;S++){const g={levels:[]},f=y.getNumLevels(S);for(let p=0;p<f;p++){const f={width:y.getImageWidth(S,p),height:y.getImageHeight(S,p)};g.levels.push(f)}p.push(g)}return{Be:g,images:p}}(q);let j=Z.data.ignoreSupportedFormats?null:function(l,c){let Z=null;l.supportedCompressionFormats&&(Z=l.supportedCompressionFormats.astc?H:l.supportedCompressionFormats.bc7?S:l.supportedCompressionFormats.s3tc?c.Be?p:f:l.supportedCompressionFormats.pvrtc?c.Be?i:k:l.supportedCompressionFormats.etc2?g:l.supportedCompressionFormats.etc1?y:U);return Z}(Z.data.config,W),P=!1;null===j&&(P=!0,j=W.Be?p:f);let B=!0;q.startTranscoding()||(B=!1);const R=[];for(let y=0;y<W.images.length&&B;y++){const g=W.images[y];if(void 0===l.loadSingleImage||l.loadSingleImage===y){let f=g.levels.length;!1===l.loadMipmapLevels&&(f=1);for(let p=0;p<f;p++){const f=g.levels[p],S=c(q,y,p,j,P);if(!S){B=!1;break}f.transcodedPixels=S,R.push(f.transcodedPixels.buffer)}}}q.close(),q.delete(),P&&(j=-1),B?postMessage({action:"transcode",success:B,id:Z.data.id,fileInfo:W,format:j},R):postMessage({action:"transcode",success:B,id:Z.data.id})}}}!function(y){y[y.cTFETC1=0]="cTFETC1",y[y.cTFETC2=1]="cTFETC2",y[y.cTFBC1=2]="cTFBC1",y[y.cTFBC3=3]="cTFBC3",y[y.cTFBC4=4]="cTFBC4",y[y.cTFBC5=5]="cTFBC5",y[y.cTFBC7=6]="cTFBC7",y[y.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",y[y.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",y[y.cTFASTC_4x4=10]="cTFASTC_4x4",y[y.cTFATC_RGB=11]="cTFATC_RGB",y[y.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",y[y.cTFRGBA32=13]="cTFRGBA32",y[y.cTFRGB565=14]="cTFRGB565",y[y.cTFBGR565=15]="cTFBGR565",y[y.cTFRGBA4444=16]="cTFRGBA4444",y[y.cTFFXT1_RGB=17]="cTFFXT1_RGB",y[y.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",y[y.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",y[y.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",y[y.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(p||(p={}));const U={JSModuleURL:`${S.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${S.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let l=null,c=null,Z=0;const C=()=>(l||(l=new Promise(((y,g)=>{c?y(c):S.e.LoadFileAsync(S.e.GetBabylonScriptURL(U.WasmModuleURL)).then((f=>{if("function"!==typeof URL)return g("Basis transcoder requires an environment with a URL constructor");const p=URL.createObjectURL(new Blob([`(${H})()`],{type:"application/javascript"}));c=new Worker(p),function(y,g,f){return new Promise(((p,k)=>{const i=g=>{"init"===g.data.action?(y.removeEventListener("message",i),p(y)):"error"===g.data.action&&k(g.data.error||"error initializing worker")};y.addEventListener("message",i),y.postMessage({action:"init",url:f?S.e.GetBabylonScriptURL(f):void 0,wasmBinary:g},[g])}))}(c,f,U.JSModuleURL).then(y,g)})).catch(g)}))),l),q=(y,g)=>{const f=y instanceof ArrayBuffer?new Uint8Array(y):y;return new Promise(((y,p)=>{C().then((()=>{const S=Z++,k=g=>{"transcode"===g.data.action&&g.data.id===S&&(c.removeEventListener("message",k),g.data.success?y(g.data):p("Transcode is not supported on this device"))};c.addEventListener("message",k);const i=new Uint8Array(f.byteLength);i.set(new Uint8Array(f.buffer,f.byteOffset,f.byteLength)),c.postMessage({action:"transcode",id:S,imageData:i,config:g,ignoreSupportedFormats:false},[i.buffer])}),(y=>{p(y)}))}))},W=(y,g)=>{var f;let p=null===(f=g._gl)||void 0===f?void 0:f.TEXTURE_2D;var S;y.isCube&&(p=null===(S=g._gl)||void 0===S?void 0:S.TEXTURE_CUBE_MAP);g._bindTextureDirectly(p,y,!0)},j=(y,g)=>{const f=y.getEngine();for(let H=0;H<g.fileInfo.images.length;H++){const U=g.fileInfo.images[H].levels[0];if(y._invertVScale=y.invertY,-1===g.format||g.format===p.cTFRGB565)if(y.type=10,y.format=4,!f._features.basisNeedsPOT||Math.log2(U.width)%1===0&&Math.log2(U.height)%1===0)y._invertVScale=!y.invertY,y.width=U.width+3&-4,y.height=U.height+3&-4,y.samplingMode=2,W(y,f),f._uploadDataToTextureDirectly(y,new Uint16Array(U.transcodedPixels.buffer),H,0,4,!0);else{const g=new i.d(f,2);y._invertVScale=y.invertY,g.type=10,g.format=4,g.width=U.width+3&-4,g.height=U.height+3&-4,W(g,f),f._uploadDataToTextureDirectly(g,new Uint16Array(U.transcodedPixels.buffer),H,0,4,!0),f._rescaleTexture(g,y,f.scenes[0],f._getInternalFormat(4),(()=>{f._releaseTexture(g),W(y,f)}))}else{y.width=U.width,y.height=U.height,y.generateMipMaps=g.fileInfo.images[H].levels.length>1;const p=P.GetInternalFormatFromBasisFormat(g.format,f);y.format=p,W(y,f),g.fileInfo.images[H].levels.forEach(((g,S)=>{f._uploadCompressedDataToTextureDirectly(y,p,g.width,g.height,g.transcodedPixels,H,S)})),!f._features.basisNeedsPOT||Math.log2(y.width)%1===0&&Math.log2(y.height)%1===0||(S.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),y._cachedWrapU=k.c.CLAMP_ADDRESSMODE,y._cachedWrapV=k.c.CLAMP_ADDRESSMODE)}}},P={JSModuleURL:U.JSModuleURL,WasmModuleURL:U.WasmModuleURL,GetInternalFormatFromBasisFormat:(y,g)=>{let f;switch(y){case p.cTFETC1:f=36196;break;case p.cTFBC1:f=33776;break;case p.cTFBC4:f=33779;break;case p.cTFASTC_4x4:f=37808;break;case p.cTFETC2:f=37496;break;case p.cTFBC7:f=36492}if(void 0===f)throw"The chosen Basis transcoder format is not currently supported";return f},TranscodeAsync:q,LoadTextureFromTranscodeResult:j};Object.defineProperty(P,"JSModuleURL",{get:function(){return U.JSModuleURL},set:function(y){U.JSModuleURL=y}}),Object.defineProperty(P,"WasmModuleURL",{get:function(){return U.WasmModuleURL},set:function(y){U.WasmModuleURL=y}});class B{constructor(){this.supportCascades=!1}loadCubeData(y,g,f,p,k){if(Array.isArray(y))return;const i=g.getEngine().getCaps(),H={supportedCompressionFormats:{etc1:!!i.etc1,s3tc:!!i.s3tc,pvrtc:!!i.pvrtc,etc2:!!i.etc2,astc:!!i.astc,bc7:!!i.bptc}};q(y,H).then((y=>{const f=y.fileInfo.images[0].levels.length>1&&g.generateMipMaps;j(g,y),g.getEngine()._setCubeMapTextureParams(g,f),g.isReady=!0,g.onLoadedObservable.notifyObservers(g),g.onLoadedObservable.clear(),p&&p()})).catch((y=>{S.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),g.isReady=!0,k&&k(y)}))}loadData(y,g,f){const p=g.getEngine().getCaps(),k={supportedCompressionFormats:{etc1:!!p.etc1,s3tc:!!p.s3tc,pvrtc:!!p.pvrtc,etc2:!!p.etc2,astc:!!p.astc,bc7:!!p.bptc}};q(y,k).then((y=>{const p=y.fileInfo.images[0].levels[0],S=y.fileInfo.images[0].levels.length>1&&g.generateMipMaps;f(p.width,p.height,S,-1!==y.format,(()=>{j(g,y)}))})).catch((y=>{S.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),S.e.Warn(`Failed to transcode Basis file: ${y}`),f(0,0,!1,!1,(()=>{}),!0)}))}}}}]);