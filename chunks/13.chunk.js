"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{2479:(Z,U,n)=>{n.r(U),n.d(U,{_HDRTextureLoader:()=>d});var i=n(702);class B{static ConvertPanoramaToCubemap(Z,U,n,i){let B=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Z)throw"ConvertPanoramaToCubemap: input cannot be null";if(Z.length!=U*n*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(i,this.FACE_FRONT,Z,U,n,B),back:this.CreateCubemapTexture(i,this.FACE_BACK,Z,U,n,B),left:this.CreateCubemapTexture(i,this.FACE_LEFT,Z,U,n,B),right:this.CreateCubemapTexture(i,this.FACE_RIGHT,Z,U,n,B),up:this.CreateCubemapTexture(i,this.FACE_UP,Z,U,n,B),down:this.CreateCubemapTexture(i,this.FACE_DOWN,Z,U,n,B),size:i,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(Z,U,n,i,B){let l=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const H=new ArrayBuffer(Z*Z*4*3),V=new Float32Array(H),G=l?Math.max(1,Math.round(i/4/Z)):1,R=1/G,d=R*R,F=U[1].Qg(U[0]).scale(R/Z),y=U[3].Qg(U[2]).scale(R/Z),S=1/Z;let q=0;for(let c=0;c<Z;c++)for(let l=0;l<G;l++){let l=U[0],H=U[2];for(let U=0;U<Z;U++)for(let R=0;R<G;R++){const G=H.Qg(l).scale(q).add(l);G.normalize();const R=this.CalcProjectionSpherical(G,n,i,B);V[c*Z*3+3*U+0]+=R.r*d,V[c*Z*3+3*U+1]+=R.g*d,V[c*Z*3+3*U+2]+=R.b*d,l=l.add(F),H=H.add(y)}q+=S*R}return V}static CalcProjectionSpherical(Z,U,n,i){let B=Math.atan2(Z.z,Z.x);const l=Math.acos(Z.y);for(;B<-Math.PI;)B+=2*Math.PI;for(;B>Math.PI;)B-=2*Math.PI;let H=B/Math.PI;const V=l/Math.PI;H=.5*H+.5;let G=Math.round(H*n);G<0?G=0:G>=n&&(G=n-1);let R=Math.round(V*i);R<0?R=0:R>=i&&(R=i-1);const d=i-R-1;return{r:U[d*n*3+3*G+0],g:U[d*n*3+3*G+1],b:U[d*n*3+3*G+2]}}}function l(Z,U,n,i,B,l){B>0?(B=function(Z,U){return U>1023?Z*Math.pow(2,1023)*Math.pow(2,U-1023):U<-1074?Z*Math.pow(2,-1074)*Math.pow(2,U+1074):Z*Math.pow(2,U)}(1,B-136),Z[l+0]=U*B,Z[l+1]=n*B,Z[l+2]=i*B):(Z[l+0]=0,Z[l+1]=0,Z[l+2]=0)}function H(Z,U){let n="",i="";for(let B=U;B<Z.length-U&&(i=String.fromCharCode(Z[B]),"\n"!=i);B++)n+=i;return n}function V(Z){let U=0,n=0,i=H(Z,0);if("#"!=i[0]||"?"!=i[1])throw"Bad HDR Format.";let B=!1,l=!1,V=0;do{V+=i.length+1,i=H(Z,V),"FORMAT=32-bit_rle_rgbe"==i?l=!0:0==i.length&&(B=!0)}while(!B);if(!l)throw"HDR Bad header format, unsupported FORMAT";V+=i.length+1,i=H(Z,V);const G=/^-Y (.*) \+X (.*)$/g.exec(i);if(!G||G.length<3)throw"HDR Bad header format, no size";if(n=parseInt(G[2]),U=parseInt(G[1]),n<8||n>32767)throw"HDR Bad header format, unsupported size";return V+=i.length+1,{height:U,width:n,dataPosition:V}}function G(Z,U){return function(Z,U){let n=U.height;const i=U.width;let B,H,V,G,d,F=U.dataPosition,y=0,S=0,q=0;const c=new ArrayBuffer(4*i),s=new Uint8Array(c),z=new ArrayBuffer(U.width*U.height*4*3),O=new Float32Array(z);for(;n>0;){if(B=Z[F++],H=Z[F++],V=Z[F++],G=Z[F++],2!=B||2!=H||128&V||U.width<8||U.width>32767)return R(Z,U);if((V<<8|G)!=i)throw"HDR Bad header format, wrong scan line width";for(y=0,q=0;q<4;q++)for(S=(q+1)*i;y<S;)if(B=Z[F++],H=Z[F++],B>128){if(d=B-128,0==d||d>S-y)throw"HDR Bad Format, bad scanline data (run)";for(;d-- >0;)s[y++]=H}else{if(d=B,0==d||d>S-y)throw"HDR Bad Format, bad scanline data (non-run)";if(s[y++]=H,--d>0)for(let U=0;U<d;U++)s[y++]=Z[F++]}for(q=0;q<i;q++)B=s[q],H=s[q+i],V=s[q+2*i],G=s[q+3*i],l(O,B,H,V,G,(U.height-n)*i*3+3*q);n--}return O}(Z,U)}function R(Z,U){let n=U.height;const i=U.width;let B,H,V,G,R,d=U.dataPosition;const F=new ArrayBuffer(U.width*U.height*4*3),y=new Float32Array(F);for(;n>0;){for(R=0;R<U.width;R++)B=Z[d++],H=Z[d++],V=Z[d++],G=Z[d++],l(y,B,H,V,G,(U.height-n)*i*3+3*R);n--}return y}B.FACE_LEFT=[new i.k(-1,-1,-1),new i.k(1,-1,-1),new i.k(-1,1,-1),new i.k(1,1,-1)],B.FACE_RIGHT=[new i.k(1,-1,1),new i.k(-1,-1,1),new i.k(1,1,1),new i.k(-1,1,1)],B.FACE_FRONT=[new i.k(1,-1,-1),new i.k(1,-1,1),new i.k(1,1,-1),new i.k(1,1,1)],B.FACE_BACK=[new i.k(-1,-1,1),new i.k(-1,-1,-1),new i.k(-1,1,1),new i.k(-1,1,-1)],B.FACE_DOWN=[new i.k(1,1,-1),new i.k(1,1,1),new i.k(-1,1,-1),new i.k(-1,1,1)],B.FACE_UP=[new i.k(-1,-1,-1),new i.k(-1,-1,1),new i.k(1,-1,-1),new i.k(1,-1,1)];class d{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(Z,U,n){const i=new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength),B=V(i),l=G(i,B),H=B.width*B.height,R=new Float32Array(4*H);for(let V=0;V<H;V+=1)R[4*V]=l[3*V],R[4*V+1]=l[3*V+1],R[4*V+2]=l[3*V+2],R[4*V+3]=1;n(B.width,B.height,U.generateMipMaps,!1,(()=>{const Z=U.getEngine();U.type=1,U.format=5,U._gammaSpace=!1,Z._uploadDataToTextureDirectly(U,R)}))}}}}]);