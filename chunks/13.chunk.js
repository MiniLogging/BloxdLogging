"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12652:(K,q,p)=>{p.r(q),p.d(q,{_BasisTextureLoader:()=>f});var Z,z=p(10696),S=p(11213),X=p(10807);function y(){const K=0,q=1,p=2,Z=3,z=6,S=8,X=9,y=10,V=14;let C=null;function h(K,q,p,Z,z){const S=K.getImageTranscodedSizeInBytes(q,p,Z);let X=new Uint8Array(S);if(!K.transcodeImage(X,q,p,Z,1,0))return null;if(z){X=function(K,q,p,Z){const z=new Uint16Array(4),S=new Uint16Array(p*Z),X=p/4,y=Z/4;for(let V=0;V<y;V++)for(let Z=0;Z<X;Z++){const y=q+8*(V*X+Z);z[0]=K[y]|K[y+1]<<8,z[1]=K[y+2]|K[y+3]<<8,z[2]=(2*(31&z[0])+1*(31&z[1]))/3|(2*(2016&z[0])+1*(2016&z[1]))/3&2016|(2*(63488&z[0])+1*(63488&z[1]))/3&63488,z[3]=(2*(31&z[1])+1*(31&z[0]))/3|(2*(2016&z[1])+1*(2016&z[0]))/3&2016|(2*(63488&z[1])+1*(63488&z[0]))/3&63488;for(let q=0;q<4;q++){const X=K[y+4+q];let C=(4*V+q)*p+4*Z;S[C++]=z[3&X],S[C++]=z[X>>2&3],S[C++]=z[X>>4&3],S[C++]=z[X>>6&3]}}return S}(X,0,K.getImageWidth(q,p)+3&-4,K.getImageHeight(q,p)+3&-4)}return X}onmessage=U=>{if("init"===U.data.action){if(U.data.url)try{importScripts(U.data.url)}catch(Y){postMessage({action:"error",error:Y})}C||(C=BASIS({wasmBinary:U.data.wasmBinary})),null!==C&&C.then((K=>{BASIS=K,K.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===U.data.action){const C=U.data.config,Y=U.data.imageData,k=new BASIS.BasisFile(Y),F=function(K){const q=K.getHasAlpha(),p=K.getNumImages(),Z=[];for(let z=0;z<p;z++){const q={levels:[]},p=K.getNumLevels(z);for(let Z=0;Z<p;Z++){const p={width:K.getImageWidth(z,Z),height:K.getImageHeight(z,Z)};q.levels.push(p)}Z.push(q)}return{Ke:q,images:Z}}(k);let x=U.data.ignoreSupportedFormats?null:function(C,h){let U=null;C.supportedCompressionFormats&&(U=C.supportedCompressionFormats.astc?y:C.supportedCompressionFormats.bc7?z:C.supportedCompressionFormats.s3tc?h.Ke?Z:p:C.supportedCompressionFormats.pvrtc?h.Ke?X:S:C.supportedCompressionFormats.etc2?q:C.supportedCompressionFormats.etc1?K:V);return U}(U.data.config,F),t=!1;null===x&&(t=!0,x=F.Ke?Z:p);let f=!0;k.startTranscoding()||(f=!1);const E=[];for(let K=0;K<F.images.length&&f;K++){const q=F.images[K];if(void 0===C.loadSingleImage||C.loadSingleImage===K){let p=q.levels.length;!1===C.loadMipmapLevels&&(p=1);for(let Z=0;Z<p;Z++){const p=q.levels[Z],z=h(k,K,Z,x,t);if(!z){f=!1;break}p.transcodedPixels=z,E.push(p.transcodedPixels.buffer)}}}k.close(),k.delete(),t&&(x=-1),f?postMessage({action:"transcode",success:f,id:U.data.id,fileInfo:F,format:x},E):postMessage({action:"transcode",success:f,id:U.data.id})}}}!function(K){K[K.cTFETC1=0]="cTFETC1",K[K.cTFETC2=1]="cTFETC2",K[K.cTFBC1=2]="cTFBC1",K[K.cTFBC3=3]="cTFBC3",K[K.cTFBC4=4]="cTFBC4",K[K.cTFBC5=5]="cTFBC5",K[K.cTFBC7=6]="cTFBC7",K[K.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",K[K.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",K[K.cTFASTC_4x4=10]="cTFASTC_4x4",K[K.cTFATC_RGB=11]="cTFATC_RGB",K[K.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",K[K.cTFRGBA32=13]="cTFRGBA32",K[K.cTFRGB565=14]="cTFRGB565",K[K.cTFBGR565=15]="cTFBGR565",K[K.cTFRGBA4444=16]="cTFRGBA4444",K[K.cTFFXT1_RGB=17]="cTFFXT1_RGB",K[K.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",K[K.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",K[K.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",K[K.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(Z||(Z={}));const V={JSModuleURL:`${z.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${z.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let C=null,h=null,U=0;const Y=()=>(C||(C=new Promise(((K,q)=>{h?K(h):z.h.LoadFileAsync(z.h.GetBabylonScriptURL(V.WasmModuleURL)).then((p=>{if("function"!==typeof URL)return q("Basis transcoder requires an environment with a URL constructor");const Z=URL.createObjectURL(new Blob([`(${y})()`],{type:"application/javascript"}));h=new Worker(Z),function(K,q,p){return new Promise(((Z,S)=>{const X=q=>{"init"===q.data.action?(K.removeEventListener("message",X),Z(K)):"error"===q.data.action&&S(q.data.error||"error initializing worker")};K.addEventListener("message",X),K.postMessage({action:"init",url:p?z.h.GetBabylonScriptURL(p):void 0,wasmBinary:q},[q])}))}(h,p,V.JSModuleURL).then(K,q)})).catch(q)}))),C),k=(K,q)=>{const p=K instanceof ArrayBuffer?new Uint8Array(K):K;return new Promise(((K,Z)=>{Y().then((()=>{const z=U++,S=q=>{"transcode"===q.data.action&&q.data.id===z&&(h.removeEventListener("message",S),q.data.success?K(q.data):Z("Transcode is not supported on this device"))};h.addEventListener("message",S);const X=new Uint8Array(p.byteLength);X.set(new Uint8Array(p.buffer,p.byteOffset,p.byteLength)),h.postMessage({action:"transcode",id:z,imageData:X,config:q,ignoreSupportedFormats:false},[X.buffer])}),(K=>{Z(K)}))}))},F=(K,q)=>{var p;let Z=null===(p=q._gl)||void 0===p?void 0:p.TEXTURE_2D;var z;K.isCube&&(Z=null===(z=q._gl)||void 0===z?void 0:z.TEXTURE_CUBE_MAP);q._bindTextureDirectly(Z,K,!0)},x=(K,q)=>{const p=K.getEngine();for(let y=0;y<q.fileInfo.images.length;y++){const V=q.fileInfo.images[y].levels[0];if(K._invertVScale=K.invertY,-1===q.format||q.format===Z.cTFRGB565)if(K.type=10,K.format=4,!p._features.basisNeedsPOT||Math.log2(V.width)%1===0&&Math.log2(V.height)%1===0)K._invertVScale=!K.invertY,K.width=V.width+3&-4,K.height=V.height+3&-4,K.samplingMode=2,F(K,p),p._uploadDataToTextureDirectly(K,new Uint16Array(V.transcodedPixels.buffer),y,0,4,!0);else{const q=new X.c(p,2);K._invertVScale=K.invertY,q.type=10,q.format=4,q.width=V.width+3&-4,q.height=V.height+3&-4,F(q,p),p._uploadDataToTextureDirectly(q,new Uint16Array(V.transcodedPixels.buffer),y,0,4,!0),p._rescaleTexture(q,K,p.scenes[0],p._getInternalFormat(4),(()=>{p._releaseTexture(q),F(K,p)}))}else{K.width=V.width,K.height=V.height,K.generateMipMaps=q.fileInfo.images[y].levels.length>1;const Z=t.GetInternalFormatFromBasisFormat(q.format,p);K.format=Z,F(K,p),q.fileInfo.images[y].levels.forEach(((q,z)=>{p._uploadCompressedDataToTextureDirectly(K,Z,q.width,q.height,q.transcodedPixels,y,z)})),!p._features.basisNeedsPOT||Math.log2(K.width)%1===0&&Math.log2(K.height)%1===0||(z.h.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),K._cachedWrapU=S.e.CLAMP_ADDRESSMODE,K._cachedWrapV=S.e.CLAMP_ADDRESSMODE)}}},t={JSModuleURL:V.JSModuleURL,WasmModuleURL:V.WasmModuleURL,GetInternalFormatFromBasisFormat:(K,q)=>{let p;switch(K){case Z.cTFETC1:p=36196;break;case Z.cTFBC1:p=33776;break;case Z.cTFBC4:p=33779;break;case Z.cTFASTC_4x4:p=37808;break;case Z.cTFETC2:p=37496;break;case Z.cTFBC7:p=36492}if(void 0===p)throw"The chosen Basis transcoder format is not currently supported";return p},TranscodeAsync:k,LoadTextureFromTranscodeResult:x};Object.defineProperty(t,"JSModuleURL",{get:function(){return V.JSModuleURL},set:function(K){V.JSModuleURL=K}}),Object.defineProperty(t,"WasmModuleURL",{get:function(){return V.WasmModuleURL},set:function(K){V.WasmModuleURL=K}});class f{constructor(){this.supportCascades=!1}loadCubeData(K,q,p,Z,S){if(Array.isArray(K))return;const X=q.getEngine().getCaps(),y={supportedCompressionFormats:{etc1:!!X.etc1,s3tc:!!X.s3tc,pvrtc:!!X.pvrtc,etc2:!!X.etc2,astc:!!X.astc,bc7:!!X.bptc}};k(K,y).then((K=>{const p=K.fileInfo.images[0].levels.length>1&&q.generateMipMaps;x(q,K),q.getEngine()._setCubeMapTextureParams(q,p),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),Z&&Z()})).catch((K=>{z.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),q.isReady=!0,S&&S(K)}))}loadData(K,q,p){const Z=q.getEngine().getCaps(),S={supportedCompressionFormats:{etc1:!!Z.etc1,s3tc:!!Z.s3tc,pvrtc:!!Z.pvrtc,etc2:!!Z.etc2,astc:!!Z.astc,bc7:!!Z.bptc}};k(K,S).then((K=>{const Z=K.fileInfo.images[0].levels[0],z=K.fileInfo.images[0].levels.length>1&&q.generateMipMaps;p(Z.width,Z.height,z,-1!==K.format,(()=>{x(q,K)}))})).catch((K=>{z.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),z.h.Warn(`Failed to transcode Basis file: ${K}`),p(0,0,!1,!1,(()=>{}),!0)}))}}}}]);