"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12730:(E,Y,C)=>{C.r(Y),C.d(Y,{_BasisTextureLoader:()=>Z});var P,K=C(10737),m=C(11276),u=C(10849);function T(){const E=0,Y=1,C=2,P=3,K=6,m=8,u=9,T=10,a=14;let J=null;function t(E,Y,C,P,K){const m=E.getImageTranscodedSizeInBytes(Y,C,P);let u=new Uint8Array(m);if(!E.transcodeImage(u,Y,C,P,1,0))return null;if(K){u=function(E,Y,C,P){const K=new Uint16Array(4),m=new Uint16Array(C*P),u=C/4,T=P/4;for(let a=0;a<T;a++)for(let P=0;P<u;P++){const T=Y+8*(a*u+P);K[0]=E[T]|E[T+1]<<8,K[1]=E[T+2]|E[T+3]<<8,K[2]=(2*(31&K[0])+1*(31&K[1]))/3|(2*(2016&K[0])+1*(2016&K[1]))/3&2016|(2*(63488&K[0])+1*(63488&K[1]))/3&63488,K[3]=(2*(31&K[1])+1*(31&K[0]))/3|(2*(2016&K[1])+1*(2016&K[0]))/3&2016|(2*(63488&K[1])+1*(63488&K[0]))/3&63488;for(let Y=0;Y<4;Y++){const u=E[T+4+Y];let J=(4*a+Y)*C+4*P;m[J++]=K[3&u],m[J++]=K[u>>2&3],m[J++]=K[u>>4&3],m[J++]=K[u>>6&3]}}return m}(u,0,E.getImageWidth(Y,C)+3&-4,E.getImageHeight(Y,C)+3&-4)}return u}onmessage=p=>{if("init"===p.data.action){if(p.data.url)try{importScripts(p.data.url)}catch(W){postMessage({action:"error",error:W})}J||(J=BASIS({wasmBinary:p.data.wasmBinary})),null!==J&&J.then((E=>{BASIS=E,E.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===p.data.action){const J=p.data.config,W=p.data.imageData,k=new BASIS.BasisFile(W),y=function(E){const Y=E.getHasAlpha(),C=E.getNumImages(),P=[];for(let K=0;K<C;K++){const Y={levels:[]},C=E.getNumLevels(K);for(let P=0;P<C;P++){const C={width:E.getImageWidth(K,P),height:E.getImageHeight(K,P)};Y.levels.push(C)}P.push(Y)}return{He:Y,images:P}}(k);let v=p.data.ignoreSupportedFormats?null:function(J,t){let p=null;J.supportedCompressionFormats&&(p=J.supportedCompressionFormats.astc?T:J.supportedCompressionFormats.bc7?K:J.supportedCompressionFormats.s3tc?t.He?P:C:J.supportedCompressionFormats.pvrtc?t.He?u:m:J.supportedCompressionFormats.etc2?Y:J.supportedCompressionFormats.etc1?E:a);return p}(p.data.config,y),V=!1;null===v&&(V=!0,v=y.He?P:C);let Z=!0;k.startTranscoding()||(Z=!1);const M=[];for(let E=0;E<y.images.length&&Z;E++){const Y=y.images[E];if(void 0===J.loadSingleImage||J.loadSingleImage===E){let C=Y.levels.length;!1===J.loadMipmapLevels&&(C=1);for(let P=0;P<C;P++){const C=Y.levels[P],K=t(k,E,P,v,V);if(!K){Z=!1;break}C.transcodedPixels=K,M.push(C.transcodedPixels.buffer)}}}k.close(),k.delete(),V&&(v=-1),Z?postMessage({action:"transcode",success:Z,id:p.data.id,fileInfo:y,format:v},M):postMessage({action:"transcode",success:Z,id:p.data.id})}}}!function(E){E[E.cTFETC1=0]="cTFETC1",E[E.cTFETC2=1]="cTFETC2",E[E.cTFBC1=2]="cTFBC1",E[E.cTFBC3=3]="cTFBC3",E[E.cTFBC4=4]="cTFBC4",E[E.cTFBC5=5]="cTFBC5",E[E.cTFBC7=6]="cTFBC7",E[E.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",E[E.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",E[E.cTFASTC_4x4=10]="cTFASTC_4x4",E[E.cTFATC_RGB=11]="cTFATC_RGB",E[E.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",E[E.cTFRGBA32=13]="cTFRGBA32",E[E.cTFRGB565=14]="cTFRGB565",E[E.cTFBGR565=15]="cTFBGR565",E[E.cTFRGBA4444=16]="cTFRGBA4444",E[E.cTFFXT1_RGB=17]="cTFFXT1_RGB",E[E.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",E[E.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",E[E.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",E[E.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(P||(P={}));const a={JSModuleURL:`${K.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${K.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let J=null,t=null,p=0;const W=()=>(J||(J=new Promise(((E,Y)=>{t?E(t):K.e.LoadFileAsync(K.e.GetBabylonScriptURL(a.WasmModuleURL)).then((C=>{if("function"!==typeof URL)return Y("Basis transcoder requires an environment with a URL constructor");const P=URL.createObjectURL(new Blob([`(${T})()`],{type:"application/javascript"}));t=new Worker(P),function(E,Y,C){return new Promise(((P,m)=>{const u=Y=>{"init"===Y.data.action?(E.removeEventListener("message",u),P(E)):"error"===Y.data.action&&m(Y.data.error||"error initializing worker")};E.addEventListener("message",u),E.postMessage({action:"init",url:C?K.e.GetBabylonScriptURL(C):void 0,wasmBinary:Y},[Y])}))}(t,C,a.JSModuleURL).then(E,Y)})).catch(Y)}))),J),k=(E,Y)=>{const C=E instanceof ArrayBuffer?new Uint8Array(E):E;return new Promise(((E,P)=>{W().then((()=>{const K=p++,m=Y=>{"transcode"===Y.data.action&&Y.data.id===K&&(t.removeEventListener("message",m),Y.data.success?E(Y.data):P("Transcode is not supported on this device"))};t.addEventListener("message",m);const u=new Uint8Array(C.byteLength);u.set(new Uint8Array(C.buffer,C.byteOffset,C.byteLength)),t.postMessage({action:"transcode",id:K,imageData:u,config:Y,ignoreSupportedFormats:false},[u.buffer])}),(E=>{P(E)}))}))},y=(E,Y)=>{var C;let P=null===(C=Y._gl)||void 0===C?void 0:C.TEXTURE_2D;var K;E.isCube&&(P=null===(K=Y._gl)||void 0===K?void 0:K.TEXTURE_CUBE_MAP);Y._bindTextureDirectly(P,E,!0)},v=(E,Y)=>{const C=E.getEngine();for(let T=0;T<Y.fileInfo.images.length;T++){const a=Y.fileInfo.images[T].levels[0];if(E._invertVScale=E.invertY,-1===Y.format||Y.format===P.cTFRGB565)if(E.type=10,E.format=4,!C._features.basisNeedsPOT||Math.log2(a.width)%1===0&&Math.log2(a.height)%1===0)E._invertVScale=!E.invertY,E.width=a.width+3&-4,E.height=a.height+3&-4,E.samplingMode=2,y(E,C),C._uploadDataToTextureDirectly(E,new Uint16Array(a.transcodedPixels.buffer),T,0,4,!0);else{const Y=new u.c(C,2);E._invertVScale=E.invertY,Y.type=10,Y.format=4,Y.width=a.width+3&-4,Y.height=a.height+3&-4,y(Y,C),C._uploadDataToTextureDirectly(Y,new Uint16Array(a.transcodedPixels.buffer),T,0,4,!0),C._rescaleTexture(Y,E,C.scenes[0],C._getInternalFormat(4),(()=>{C._releaseTexture(Y),y(E,C)}))}else{E.width=a.width,E.height=a.height,E.generateMipMaps=Y.fileInfo.images[T].levels.length>1;const P=V.GetInternalFormatFromBasisFormat(Y.format,C);E.format=P,y(E,C),Y.fileInfo.images[T].levels.forEach(((Y,K)=>{C._uploadCompressedDataToTextureDirectly(E,P,Y.width,Y.height,Y.transcodedPixels,T,K)})),!C._features.basisNeedsPOT||Math.log2(E.width)%1===0&&Math.log2(E.height)%1===0||(K.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),E._cachedWrapU=m.c.CLAMP_ADDRESSMODE,E._cachedWrapV=m.c.CLAMP_ADDRESSMODE)}}},V={JSModuleURL:a.JSModuleURL,WasmModuleURL:a.WasmModuleURL,GetInternalFormatFromBasisFormat:(E,Y)=>{let C;switch(E){case P.cTFETC1:C=36196;break;case P.cTFBC1:C=33776;break;case P.cTFBC4:C=33779;break;case P.cTFASTC_4x4:C=37808;break;case P.cTFETC2:C=37496;break;case P.cTFBC7:C=36492}if(void 0===C)throw"The chosen Basis transcoder format is not currently supported";return C},TranscodeAsync:k,LoadTextureFromTranscodeResult:v};Object.defineProperty(V,"JSModuleURL",{get:function(){return a.JSModuleURL},set:function(E){a.JSModuleURL=E}}),Object.defineProperty(V,"WasmModuleURL",{get:function(){return a.WasmModuleURL},set:function(E){a.WasmModuleURL=E}});class Z{constructor(){this.supportCascades=!1}loadCubeData(E,Y,C,P,m){if(Array.isArray(E))return;const u=Y.getEngine().getCaps(),T={supportedCompressionFormats:{etc1:!!u.etc1,s3tc:!!u.s3tc,pvrtc:!!u.pvrtc,etc2:!!u.etc2,astc:!!u.astc,bc7:!!u.bptc}};k(E,T).then((E=>{const C=E.fileInfo.images[0].levels.length>1&&Y.generateMipMaps;v(Y,E),Y.getEngine()._setCubeMapTextureParams(Y,C),Y.isReady=!0,Y.onLoadedObservable.notifyObservers(Y),Y.onLoadedObservable.clear(),P&&P()})).catch((E=>{K.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Y.isReady=!0,m&&m(E)}))}loadData(E,Y,C){const P=Y.getEngine().getCaps(),m={supportedCompressionFormats:{etc1:!!P.etc1,s3tc:!!P.s3tc,pvrtc:!!P.pvrtc,etc2:!!P.etc2,astc:!!P.astc,bc7:!!P.bptc}};k(E,m).then((E=>{const P=E.fileInfo.images[0].levels[0],K=E.fileInfo.images[0].levels.length>1&&Y.generateMipMaps;C(P.width,P.height,K,-1!==E.format,(()=>{v(Y,E)}))})).catch((E=>{K.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),K.e.Warn(`Failed to transcode Basis file: ${E}`),C(0,0,!1,!1,(()=>{}),!0)}))}}}}]);