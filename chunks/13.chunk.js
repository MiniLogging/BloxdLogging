"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12909:(O,f,y)=>{y.r(f),y.d(f,{_BasisTextureLoader:()=>w});var S,H=y(10995),b=y(11509),h=y(11126);function v(){const O=0,f=1,y=2,S=3,H=6,b=8,h=9,v=10,N=14;let m=null;function t(O,f,y,S,H){const b=O.getImageTranscodedSizeInBytes(f,y,S);let h=new Uint8Array(b);if(!O.transcodeImage(h,f,y,S,1,0))return null;if(H){h=function(O,f,y,S){const H=new Uint16Array(4),b=new Uint16Array(y*S),h=y/4,v=S/4;for(let N=0;N<v;N++)for(let S=0;S<h;S++){const v=f+8*(N*h+S);H[0]=O[v]|O[v+1]<<8,H[1]=O[v+2]|O[v+3]<<8,H[2]=(2*(31&H[0])+1*(31&H[1]))/3|(2*(2016&H[0])+1*(2016&H[1]))/3&2016|(2*(63488&H[0])+1*(63488&H[1]))/3&63488,H[3]=(2*(31&H[1])+1*(31&H[0]))/3|(2*(2016&H[1])+1*(2016&H[0]))/3&2016|(2*(63488&H[1])+1*(63488&H[0]))/3&63488;for(let f=0;f<4;f++){const h=O[v+4+f];let m=(4*N+f)*y+4*S;b[m++]=H[3&h],b[m++]=H[h>>2&3],b[m++]=H[h>>4&3],b[m++]=H[h>>6&3]}}return b}(h,0,O.getImageWidth(f,y)+3&-4,O.getImageHeight(f,y)+3&-4)}return h}onmessage=q=>{if("init"===q.data.action){if(q.data.url)try{importScripts(q.data.url)}catch(F){postMessage({action:"error",error:F})}m||(m=BASIS({wasmBinary:q.data.wasmBinary})),null!==m&&m.then((O=>{BASIS=O,O.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===q.data.action){const m=q.data.config,F=q.data.imageData,I=new BASIS.BasisFile(F),A=function(O){const f=O.getHasAlpha(),y=O.getNumImages(),S=[];for(let H=0;H<y;H++){const f={levels:[]},y=O.getNumLevels(H);for(let S=0;S<y;S++){const y={width:O.getImageWidth(H,S),height:O.getImageHeight(H,S)};f.levels.push(y)}S.push(f)}return{ke:f,images:S}}(I);let J=q.data.ignoreSupportedFormats?null:function(m,t){let q=null;m.supportedCompressionFormats&&(q=m.supportedCompressionFormats.astc?v:m.supportedCompressionFormats.bc7?H:m.supportedCompressionFormats.s3tc?t.ke?S:y:m.supportedCompressionFormats.pvrtc?t.ke?h:b:m.supportedCompressionFormats.etc2?f:m.supportedCompressionFormats.etc1?O:N);return q}(q.data.config,A),X=!1;null===J&&(X=!0,J=A.ke?S:y);let w=!0;I.startTranscoding()||(w=!1);const B=[];for(let O=0;O<A.images.length&&w;O++){const f=A.images[O];if(void 0===m.loadSingleImage||m.loadSingleImage===O){let y=f.levels.length;!1===m.loadMipmapLevels&&(y=1);for(let S=0;S<y;S++){const y=f.levels[S],H=t(I,O,S,J,X);if(!H){w=!1;break}y.transcodedPixels=H,B.push(y.transcodedPixels.buffer)}}}I.close(),I.delete(),X&&(J=-1),w?postMessage({action:"transcode",success:w,id:q.data.id,fileInfo:A,format:J},B):postMessage({action:"transcode",success:w,id:q.data.id})}}}!function(O){O[O.cTFETC1=0]="cTFETC1",O[O.cTFETC2=1]="cTFETC2",O[O.cTFBC1=2]="cTFBC1",O[O.cTFBC3=3]="cTFBC3",O[O.cTFBC4=4]="cTFBC4",O[O.cTFBC5=5]="cTFBC5",O[O.cTFBC7=6]="cTFBC7",O[O.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",O[O.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",O[O.cTFASTC_4x4=10]="cTFASTC_4x4",O[O.cTFATC_RGB=11]="cTFATC_RGB",O[O.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",O[O.cTFRGBA32=13]="cTFRGBA32",O[O.cTFRGB565=14]="cTFRGB565",O[O.cTFBGR565=15]="cTFBGR565",O[O.cTFRGBA4444=16]="cTFRGBA4444",O[O.cTFFXT1_RGB=17]="cTFFXT1_RGB",O[O.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",O[O.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",O[O.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",O[O.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(S||(S={}));const N={JSModuleURL:`${H.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${H.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let m=null,t=null,q=0;const F=()=>(m||(m=new Promise(((O,f)=>{t?O(t):H.d.LoadFileAsync(H.d.GetBabylonScriptURL(N.WasmModuleURL)).then((y=>{if("function"!==typeof URL)return f("Basis transcoder requires an environment with a URL constructor");const S=URL.createObjectURL(new Blob([`(${v})()`],{type:"application/javascript"}));t=new Worker(S),function(O,f,y){return new Promise(((S,b)=>{const h=f=>{"init"===f.data.action?(O.removeEventListener("message",h),S(O)):"error"===f.data.action&&b(f.data.error||"error initializing worker")};O.addEventListener("message",h),O.postMessage({action:"init",url:y?H.d.GetBabylonScriptURL(y):void 0,wasmBinary:f},[f])}))}(t,y,N.JSModuleURL).then(O,f)})).catch(f)}))),m),I=(O,f)=>{const y=O instanceof ArrayBuffer?new Uint8Array(O):O;return new Promise(((O,S)=>{F().then((()=>{const H=q++,b=f=>{"transcode"===f.data.action&&f.data.id===H&&(t.removeEventListener("message",b),f.data.success?O(f.data):S("Transcode is not supported on this device"))};t.addEventListener("message",b);const h=new Uint8Array(y.byteLength);h.set(new Uint8Array(y.buffer,y.byteOffset,y.byteLength)),t.postMessage({action:"transcode",id:H,imageData:h,config:f,ignoreSupportedFormats:false},[h.buffer])}),(O=>{S(O)}))}))},A=(O,f)=>{var y;let S=null===(y=f._gl)||void 0===y?void 0:y.TEXTURE_2D;var H;O.isCube&&(S=null===(H=f._gl)||void 0===H?void 0:H.TEXTURE_CUBE_MAP);f._bindTextureDirectly(S,O,!0)},J=(O,f)=>{const y=O.getEngine();for(let v=0;v<f.fileInfo.images.length;v++){const N=f.fileInfo.images[v].levels[0];if(O._invertVScale=O.invertY,-1===f.format||f.format===S.cTFRGB565)if(O.type=10,O.format=4,!y._features.basisNeedsPOT||Math.log2(N.width)%1===0&&Math.log2(N.height)%1===0)O._invertVScale=!O.invertY,O.width=N.width+3&-4,O.height=N.height+3&-4,O.samplingMode=2,A(O,y),y._uploadDataToTextureDirectly(O,new Uint16Array(N.transcodedPixels.buffer),v,0,4,!0);else{const f=new h.c(y,2);O._invertVScale=O.invertY,f.type=10,f.format=4,f.width=N.width+3&-4,f.height=N.height+3&-4,A(f,y),y._uploadDataToTextureDirectly(f,new Uint16Array(N.transcodedPixels.buffer),v,0,4,!0),y._rescaleTexture(f,O,y.scenes[0],y._getInternalFormat(4),(()=>{y._releaseTexture(f),A(O,y)}))}else{O.width=N.width,O.height=N.height,O.generateMipMaps=f.fileInfo.images[v].levels.length>1;const S=X.GetInternalFormatFromBasisFormat(f.format,y);O.format=S,A(O,y),f.fileInfo.images[v].levels.forEach(((f,H)=>{y._uploadCompressedDataToTextureDirectly(O,S,f.width,f.height,f.transcodedPixels,v,H)})),!y._features.basisNeedsPOT||Math.log2(O.width)%1===0&&Math.log2(O.height)%1===0||(H.d.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),O._cachedWrapU=b.e.CLAMP_ADDRESSMODE,O._cachedWrapV=b.e.CLAMP_ADDRESSMODE)}}},X={JSModuleURL:N.JSModuleURL,WasmModuleURL:N.WasmModuleURL,GetInternalFormatFromBasisFormat:(O,f)=>{let y;switch(O){case S.cTFETC1:y=36196;break;case S.cTFBC1:y=33776;break;case S.cTFBC4:y=33779;break;case S.cTFASTC_4x4:y=37808;break;case S.cTFETC2:y=37496;break;case S.cTFBC7:y=36492}if(void 0===y)throw"The chosen Basis transcoder format is not currently supported";return y},TranscodeAsync:I,LoadTextureFromTranscodeResult:J};Object.defineProperty(X,"JSModuleURL",{get:function(){return N.JSModuleURL},set:function(O){N.JSModuleURL=O}}),Object.defineProperty(X,"WasmModuleURL",{get:function(){return N.WasmModuleURL},set:function(O){N.WasmModuleURL=O}});class w{constructor(){this.supportCascades=!1}loadCubeData(O,f,y,S,b){if(Array.isArray(O))return;const h=f.getEngine().getCaps(),v={supportedCompressionFormats:{etc1:!!h.etc1,s3tc:!!h.s3tc,pvrtc:!!h.pvrtc,etc2:!!h.etc2,astc:!!h.astc,bc7:!!h.bptc}};I(O,v).then((O=>{const y=O.fileInfo.images[0].levels.length>1&&f.generateMipMaps;J(f,O),f.getEngine()._setCubeMapTextureParams(f,y),f.isReady=!0,f.onLoadedObservable.notifyObservers(f),f.onLoadedObservable.clear(),S&&S()})).catch((O=>{H.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),f.isReady=!0,b&&b(O)}))}loadData(O,f,y){const S=f.getEngine().getCaps(),b={supportedCompressionFormats:{etc1:!!S.etc1,s3tc:!!S.s3tc,pvrtc:!!S.pvrtc,etc2:!!S.etc2,astc:!!S.astc,bc7:!!S.bptc}};I(O,b).then((O=>{const S=O.fileInfo.images[0].levels[0],H=O.fileInfo.images[0].levels.length>1&&f.generateMipMaps;y(S.width,S.height,H,-1!==O.format,(()=>{J(f,O)}))})).catch((O=>{H.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),H.d.Warn(`Failed to transcode Basis file: ${O}`),y(0,0,!1,!1,(()=>{}),!0)}))}}}}]);