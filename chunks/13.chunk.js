"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12566:(u,G,s)=>{s.r(G),s.d(G,{_BasisTextureLoader:()=>r});var T,z=s(10564),O=s(11102),m=s(10683);function f(){const u=0,G=1,s=2,T=3,z=6,O=8,m=9,f=10,C=14;let x=null;function g(u,G,s,T,z){const O=u.getImageTranscodedSizeInBytes(G,s,T);let m=new Uint8Array(O);if(!u.transcodeImage(m,G,s,T,1,0))return null;if(z){m=function(u,G,s,T){const z=new Uint16Array(4),O=new Uint16Array(s*T),m=s/4,f=T/4;for(let C=0;C<f;C++)for(let T=0;T<m;T++){const f=G+8*(C*m+T);z[0]=u[f]|u[f+1]<<8,z[1]=u[f+2]|u[f+3]<<8,z[2]=(2*(31&z[0])+1*(31&z[1]))/3|(2*(2016&z[0])+1*(2016&z[1]))/3&2016|(2*(63488&z[0])+1*(63488&z[1]))/3&63488,z[3]=(2*(31&z[1])+1*(31&z[0]))/3|(2*(2016&z[1])+1*(2016&z[0]))/3&2016|(2*(63488&z[1])+1*(63488&z[0]))/3&63488;for(let G=0;G<4;G++){const m=u[f+4+G];let x=(4*C+G)*s+4*T;O[x++]=z[3&m],O[x++]=z[m>>2&3],O[x++]=z[m>>4&3],O[x++]=z[m>>6&3]}}return O}(m,0,u.getImageWidth(G,s)+3&-4,u.getImageHeight(G,s)+3&-4)}return m}onmessage=b=>{if("init"===b.data.action){if(b.data.url)try{importScripts(b.data.url)}catch(Q){postMessage({action:"error",error:Q})}x||(x=BASIS({wasmBinary:b.data.wasmBinary})),null!==x&&x.then((u=>{BASIS=u,u.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===b.data.action){const x=b.data.config,Q=b.data.imageData,Y=new BASIS.BasisFile(Q),n=function(u){const G=u.getHasAlpha(),s=u.getNumImages(),T=[];for(let z=0;z<s;z++){const G={levels:[]},s=u.getNumLevels(z);for(let T=0;T<s;T++){const s={width:u.getImageWidth(z,T),height:u.getImageHeight(z,T)};G.levels.push(s)}T.push(G)}return{nc:G,images:T}}(Y);let V=b.data.ignoreSupportedFormats?null:function(x,g){let b=null;x.supportedCompressionFormats&&(b=x.supportedCompressionFormats.astc?f:x.supportedCompressionFormats.bc7?z:x.supportedCompressionFormats.s3tc?g.nc?T:s:x.supportedCompressionFormats.pvrtc?g.nc?m:O:x.supportedCompressionFormats.etc2?G:x.supportedCompressionFormats.etc1?u:C);return b}(b.data.config,n),F=!1;null===V&&(F=!0,V=n.nc?T:s);let r=!0;Y.startTranscoding()||(r=!1);const c=[];for(let u=0;u<n.images.length&&r;u++){const G=n.images[u];if(void 0===x.loadSingleImage||x.loadSingleImage===u){let s=G.levels.length;!1===x.loadMipmapLevels&&(s=1);for(let T=0;T<s;T++){const s=G.levels[T],z=g(Y,u,T,V,F);if(!z){r=!1;break}s.transcodedPixels=z,c.push(s.transcodedPixels.buffer)}}}Y.close(),Y.delete(),F&&(V=-1),r?postMessage({action:"transcode",success:r,id:b.data.id,fileInfo:n,format:V},c):postMessage({action:"transcode",success:r,id:b.data.id})}}}!function(u){u[u.cTFETC1=0]="cTFETC1",u[u.cTFETC2=1]="cTFETC2",u[u.cTFBC1=2]="cTFBC1",u[u.cTFBC3=3]="cTFBC3",u[u.cTFBC4=4]="cTFBC4",u[u.cTFBC5=5]="cTFBC5",u[u.cTFBC7=6]="cTFBC7",u[u.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",u[u.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",u[u.cTFASTC_4x4=10]="cTFASTC_4x4",u[u.cTFATC_RGB=11]="cTFATC_RGB",u[u.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",u[u.cTFRGBA32=13]="cTFRGBA32",u[u.cTFRGB565=14]="cTFRGB565",u[u.cTFBGR565=15]="cTFBGR565",u[u.cTFRGBA4444=16]="cTFRGBA4444",u[u.cTFFXT1_RGB=17]="cTFFXT1_RGB",u[u.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",u[u.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",u[u.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",u[u.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(T||(T={}));const C={JSModuleURL:`${z.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${z.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let x=null,g=null,b=0;const Q=()=>(x||(x=new Promise(((u,G)=>{g?u(g):z.e.LoadFileAsync(z.e.GetBabylonScriptURL(C.WasmModuleURL)).then((s=>{if("function"!==typeof URL)return G("Basis transcoder requires an environment with a URL constructor");const T=URL.createObjectURL(new Blob([`(${f})()`],{type:"application/javascript"}));g=new Worker(T),function(u,G,s){return new Promise(((T,O)=>{const m=G=>{"init"===G.data.action?(u.removeEventListener("message",m),T(u)):"error"===G.data.action&&O(G.data.error||"error initializing worker")};u.addEventListener("message",m),u.postMessage({action:"init",url:s?z.e.GetBabylonScriptURL(s):void 0,wasmBinary:G},[G])}))}(g,s,C.JSModuleURL).then(u,G)})).catch(G)}))),x),Y=(u,G)=>{const s=u instanceof ArrayBuffer?new Uint8Array(u):u;return new Promise(((u,T)=>{Q().then((()=>{const z=b++,O=G=>{"transcode"===G.data.action&&G.data.id===z&&(g.removeEventListener("message",O),G.data.success?u(G.data):T("Transcode is not supported on this device"))};g.addEventListener("message",O);const m=new Uint8Array(s.byteLength);m.set(new Uint8Array(s.buffer,s.byteOffset,s.byteLength)),g.postMessage({action:"transcode",id:z,imageData:m,config:G,ignoreSupportedFormats:false},[m.buffer])}),(u=>{T(u)}))}))},n=(u,G)=>{var s;let T=null===(s=G._gl)||void 0===s?void 0:s.TEXTURE_2D;var z;u.isCube&&(T=null===(z=G._gl)||void 0===z?void 0:z.TEXTURE_CUBE_MAP);G._bindTextureDirectly(T,u,!0)},V=(u,G)=>{const s=u.getEngine();for(let f=0;f<G.fileInfo.images.length;f++){const C=G.fileInfo.images[f].levels[0];if(u._invertVScale=u.invertY,-1===G.format||G.format===T.cTFRGB565)if(u.type=10,u.format=4,!s._features.basisNeedsPOT||Math.log2(C.width)%1===0&&Math.log2(C.height)%1===0)u._invertVScale=!u.invertY,u.width=C.width+3&-4,u.height=C.height+3&-4,u.samplingMode=2,n(u,s),s._uploadDataToTextureDirectly(u,new Uint16Array(C.transcodedPixels.buffer),f,0,4,!0);else{const G=new m.d(s,2);u._invertVScale=u.invertY,G.type=10,G.format=4,G.width=C.width+3&-4,G.height=C.height+3&-4,n(G,s),s._uploadDataToTextureDirectly(G,new Uint16Array(C.transcodedPixels.buffer),f,0,4,!0),s._rescaleTexture(G,u,s.scenes[0],s._getInternalFormat(4),(()=>{s._releaseTexture(G),n(u,s)}))}else{u.width=C.width,u.height=C.height,u.generateMipMaps=G.fileInfo.images[f].levels.length>1;const T=F.GetInternalFormatFromBasisFormat(G.format,s);u.format=T,n(u,s),G.fileInfo.images[f].levels.forEach(((G,z)=>{s._uploadCompressedDataToTextureDirectly(u,T,G.width,G.height,G.transcodedPixels,f,z)})),!s._features.basisNeedsPOT||Math.log2(u.width)%1===0&&Math.log2(u.height)%1===0||(z.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),u._cachedWrapU=O.b.CLAMP_ADDRESSMODE,u._cachedWrapV=O.b.CLAMP_ADDRESSMODE)}}},F={JSModuleURL:C.JSModuleURL,WasmModuleURL:C.WasmModuleURL,GetInternalFormatFromBasisFormat:(u,G)=>{let s;switch(u){case T.cTFETC1:s=36196;break;case T.cTFBC1:s=33776;break;case T.cTFBC4:s=33779;break;case T.cTFASTC_4x4:s=37808;break;case T.cTFETC2:s=37496;break;case T.cTFBC7:s=36492}if(void 0===s)throw"The chosen Basis transcoder format is not currently supported";return s},TranscodeAsync:Y,LoadTextureFromTranscodeResult:V};Object.defineProperty(F,"JSModuleURL",{get:function(){return C.JSModuleURL},set:function(u){C.JSModuleURL=u}}),Object.defineProperty(F,"WasmModuleURL",{get:function(){return C.WasmModuleURL},set:function(u){C.WasmModuleURL=u}});class r{constructor(){this.supportCascades=!1}loadCubeData(u,G,s,T,O){if(Array.isArray(u))return;const m=G.getEngine().getCaps(),f={supportedCompressionFormats:{etc1:!!m.etc1,s3tc:!!m.s3tc,pvrtc:!!m.pvrtc,etc2:!!m.etc2,astc:!!m.astc,bc7:!!m.bptc}};Y(u,f).then((u=>{const s=u.fileInfo.images[0].levels.length>1&&G.generateMipMaps;V(G,u),G.getEngine()._setCubeMapTextureParams(G,s),G.isReady=!0,G.onLoadedObservable.notifyObservers(G),G.onLoadedObservable.clear(),T&&T()})).catch((u=>{z.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),G.isReady=!0,O&&O(u)}))}loadData(u,G,s){const T=G.getEngine().getCaps(),O={supportedCompressionFormats:{etc1:!!T.etc1,s3tc:!!T.s3tc,pvrtc:!!T.pvrtc,etc2:!!T.etc2,astc:!!T.astc,bc7:!!T.bptc}};Y(u,O).then((u=>{const T=u.fileInfo.images[0].levels[0],z=u.fileInfo.images[0].levels.length>1&&G.generateMipMaps;s(T.width,T.height,z,-1!==u.format,(()=>{V(G,u)}))})).catch((u=>{z.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),z.e.Warn(`Failed to transcode Basis file: ${u}`),s(0,0,!1,!1,(()=>{}),!0)}))}}}}]);