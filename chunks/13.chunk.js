"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{2208:(L,j,P)=>{P.r(j),P.d(j,{_HDRTextureLoader:()=>S});var A=P(656);class R{static ConvertPanoramaToCubemap(L,j,P,A){let R=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!L)throw"ConvertPanoramaToCubemap: input cannot be null";if(L.length!=j*P*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(A,this.FACE_FRONT,L,j,P,R),back:this.CreateCubemapTexture(A,this.FACE_BACK,L,j,P,R),left:this.CreateCubemapTexture(A,this.FACE_LEFT,L,j,P,R),right:this.CreateCubemapTexture(A,this.FACE_RIGHT,L,j,P,R),up:this.CreateCubemapTexture(A,this.FACE_UP,L,j,P,R),down:this.CreateCubemapTexture(A,this.FACE_DOWN,L,j,P,R),size:A,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(L,j,P,A,R){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const Y=new ArrayBuffer(L*L*4*3),u=new Float32Array(Y),a=o?Math.max(1,Math.round(A/4/L)):1,D=1/a,S=D*D,g=j[1].xg(j[0]).scale(D/L),V=j[3].xg(j[2]).scale(D/L),N=1/L;let C=0;for(let b=0;b<L;b++)for(let o=0;o<a;o++){let o=j[0],Y=j[2];for(let j=0;j<L;j++)for(let D=0;D<a;D++){const a=Y.xg(o).scale(C).add(o);a.normalize();const D=this.CalcProjectionSpherical(a,P,A,R);u[b*L*3+3*j+0]+=D.r*S,u[b*L*3+3*j+1]+=D.g*S,u[b*L*3+3*j+2]+=D.b*S,o=o.add(g),Y=Y.add(V)}C+=N*D}return u}static CalcProjectionSpherical(L,j,P,A){let R=Math.atan2(L.z,L.x);const o=Math.acos(L.y);for(;R<-Math.PI;)R+=2*Math.PI;for(;R>Math.PI;)R-=2*Math.PI;let Y=R/Math.PI;const u=o/Math.PI;Y=.5*Y+.5;let a=Math.round(Y*P);a<0?a=0:a>=P&&(a=P-1);let D=Math.round(u*A);D<0?D=0:D>=A&&(D=A-1);const S=A-D-1;return{r:j[S*P*3+3*a+0],g:j[S*P*3+3*a+1],b:j[S*P*3+3*a+2]}}}function o(L,j,P,A,R,o){R>0?(R=function(L,j){return j>1023?L*Math.pow(2,1023)*Math.pow(2,j-1023):j<-1074?L*Math.pow(2,-1074)*Math.pow(2,j+1074):L*Math.pow(2,j)}(1,R-136),L[o+0]=j*R,L[o+1]=P*R,L[o+2]=A*R):(L[o+0]=0,L[o+1]=0,L[o+2]=0)}function Y(L,j){let P="",A="";for(let R=j;R<L.length-j&&(A=String.fromCharCode(L[R]),"\n"!=A);R++)P+=A;return P}function u(L){let j=0,P=0,A=Y(L,0);if("#"!=A[0]||"?"!=A[1])throw"Bad HDR Format.";let R=!1,o=!1,u=0;do{u+=A.length+1,A=Y(L,u),"FORMAT=32-bit_rle_rgbe"==A?o=!0:0==A.length&&(R=!0)}while(!R);if(!o)throw"HDR Bad header format, unsupported FORMAT";u+=A.length+1,A=Y(L,u);const a=/^-Y (.*) \+X (.*)$/g.exec(A);if(!a||a.length<3)throw"HDR Bad header format, no size";if(P=parseInt(a[2]),j=parseInt(a[1]),P<8||P>32767)throw"HDR Bad header format, unsupported size";return u+=A.length+1,{height:j,width:P,dataPosition:u}}function a(L,j){return function(L,j){let P=j.height;const A=j.width;let R,Y,u,a,S,g=j.dataPosition,V=0,N=0,C=0;const b=new ArrayBuffer(4*A),f=new Uint8Array(b),h=new ArrayBuffer(j.width*j.height*4*3),K=new Float32Array(h);for(;P>0;){if(R=L[g++],Y=L[g++],u=L[g++],a=L[g++],2!=R||2!=Y||128&u||j.width<8||j.width>32767)return D(L,j);if((u<<8|a)!=A)throw"HDR Bad header format, wrong scan line width";for(V=0,C=0;C<4;C++)for(N=(C+1)*A;V<N;)if(R=L[g++],Y=L[g++],R>128){if(S=R-128,0==S||S>N-V)throw"HDR Bad Format, bad scanline data (run)";for(;S-- >0;)f[V++]=Y}else{if(S=R,0==S||S>N-V)throw"HDR Bad Format, bad scanline data (non-run)";if(f[V++]=Y,--S>0)for(let j=0;j<S;j++)f[V++]=L[g++]}for(C=0;C<A;C++)R=f[C],Y=f[C+A],u=f[C+2*A],a=f[C+3*A],o(K,R,Y,u,a,(j.height-P)*A*3+3*C);P--}return K}(L,j)}function D(L,j){let P=j.height;const A=j.width;let R,Y,u,a,D,S=j.dataPosition;const g=new ArrayBuffer(j.width*j.height*4*3),V=new Float32Array(g);for(;P>0;){for(D=0;D<j.width;D++)R=L[S++],Y=L[S++],u=L[S++],a=L[S++],o(V,R,Y,u,a,(j.height-P)*A*3+3*D);P--}return V}R.FACE_LEFT=[new A.r(-1,-1,-1),new A.r(1,-1,-1),new A.r(-1,1,-1),new A.r(1,1,-1)],R.FACE_RIGHT=[new A.r(1,-1,1),new A.r(-1,-1,1),new A.r(1,1,1),new A.r(-1,1,1)],R.FACE_FRONT=[new A.r(1,-1,-1),new A.r(1,-1,1),new A.r(1,1,-1),new A.r(1,1,1)],R.FACE_BACK=[new A.r(-1,-1,1),new A.r(-1,-1,-1),new A.r(-1,1,1),new A.r(-1,1,-1)],R.FACE_DOWN=[new A.r(1,1,-1),new A.r(1,1,1),new A.r(-1,1,-1),new A.r(-1,1,1)],R.FACE_UP=[new A.r(-1,-1,-1),new A.r(-1,-1,1),new A.r(1,-1,-1),new A.r(1,-1,1)];class S{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(L,j,P){const A=new Uint8Array(L.buffer,L.byteOffset,L.byteLength),R=u(A),o=a(A,R),Y=R.width*R.height,D=new Float32Array(4*Y);for(let u=0;u<Y;u+=1)D[4*u]=o[3*u],D[4*u+1]=o[3*u+1],D[4*u+2]=o[3*u+2],D[4*u+3]=1;P(R.width,R.height,j.generateMipMaps,!1,(()=>{const L=j.getEngine();j.type=1,j.format=5,j._gammaSpace=!1,L._uploadDataToTextureDirectly(j,D)}))}}}}]);