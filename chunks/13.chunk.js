"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{2509:(R,x,H)=>{H.r(x),H.d(x,{_HDRTextureLoader:()=>V});var k=H(661);class c{static ConvertPanoramaToCubemap(R,x,H,k){let c=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!R)throw"ConvertPanoramaToCubemap: input cannot be null";if(R.length!=x*H*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(k,this.FACE_FRONT,R,x,H,c),back:this.CreateCubemapTexture(k,this.FACE_BACK,R,x,H,c),left:this.CreateCubemapTexture(k,this.FACE_LEFT,R,x,H,c),right:this.CreateCubemapTexture(k,this.FACE_RIGHT,R,x,H,c),up:this.CreateCubemapTexture(k,this.FACE_UP,R,x,H,c),down:this.CreateCubemapTexture(k,this.FACE_DOWN,R,x,H,c),size:k,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(R,x,H,k,c){let t=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const A=new ArrayBuffer(R*R*4*3),D=new Float32Array(A),U=t?Math.max(1,Math.round(k/4/R)):1,J=1/U,V=J*J,n=x[1].Pg(x[0]).scale(J/R),g=x[3].Pg(x[2]).scale(J/R),I=1/R;let i=0;for(let q=0;q<R;q++)for(let t=0;t<U;t++){let t=x[0],A=x[2];for(let x=0;x<R;x++)for(let J=0;J<U;J++){const U=A.Pg(t).scale(i).add(t);U.normalize();const J=this.CalcProjectionSpherical(U,H,k,c);D[q*R*3+3*x+0]+=J.r*V,D[q*R*3+3*x+1]+=J.g*V,D[q*R*3+3*x+2]+=J.b*V,t=t.add(n),A=A.add(g)}i+=I*J}return D}static CalcProjectionSpherical(R,x,H,k){let c=Math.atan2(R.z,R.x);const t=Math.acos(R.y);for(;c<-Math.PI;)c+=2*Math.PI;for(;c>Math.PI;)c-=2*Math.PI;let A=c/Math.PI;const D=t/Math.PI;A=.5*A+.5;let U=Math.round(A*H);U<0?U=0:U>=H&&(U=H-1);let J=Math.round(D*k);J<0?J=0:J>=k&&(J=k-1);const V=k-J-1;return{r:x[V*H*3+3*U+0],g:x[V*H*3+3*U+1],b:x[V*H*3+3*U+2]}}}function t(R,x,H,k,c,t){c>0?(c=function(R,x){return x>1023?R*Math.pow(2,1023)*Math.pow(2,x-1023):x<-1074?R*Math.pow(2,-1074)*Math.pow(2,x+1074):R*Math.pow(2,x)}(1,c-136),R[t+0]=x*c,R[t+1]=H*c,R[t+2]=k*c):(R[t+0]=0,R[t+1]=0,R[t+2]=0)}function A(R,x){let H="",k="";for(let c=x;c<R.length-x&&(k=String.fromCharCode(R[c]),"\n"!=k);c++)H+=k;return H}function D(R){let x=0,H=0,k=A(R,0);if("#"!=k[0]||"?"!=k[1])throw"Bad HDR Format.";let c=!1,t=!1,D=0;do{D+=k.length+1,k=A(R,D),"FORMAT=32-bit_rle_rgbe"==k?t=!0:0==k.length&&(c=!0)}while(!c);if(!t)throw"HDR Bad header format, unsupported FORMAT";D+=k.length+1,k=A(R,D);const U=/^-Y (.*) \+X (.*)$/g.exec(k);if(!U||U.length<3)throw"HDR Bad header format, no size";if(H=parseInt(U[2]),x=parseInt(U[1]),H<8||H>32767)throw"HDR Bad header format, unsupported size";return D+=k.length+1,{height:x,width:H,dataPosition:D}}function U(R,x){return function(R,x){let H=x.height;const k=x.width;let c,A,D,U,V,n=x.dataPosition,g=0,I=0,i=0;const q=new ArrayBuffer(4*k),S=new Uint8Array(q),L=new ArrayBuffer(x.width*x.height*4*3),b=new Float32Array(L);for(;H>0;){if(c=R[n++],A=R[n++],D=R[n++],U=R[n++],2!=c||2!=A||128&D||x.width<8||x.width>32767)return J(R,x);if((D<<8|U)!=k)throw"HDR Bad header format, wrong scan line width";for(g=0,i=0;i<4;i++)for(I=(i+1)*k;g<I;)if(c=R[n++],A=R[n++],c>128){if(V=c-128,0==V||V>I-g)throw"HDR Bad Format, bad scanline data (run)";for(;V-- >0;)S[g++]=A}else{if(V=c,0==V||V>I-g)throw"HDR Bad Format, bad scanline data (non-run)";if(S[g++]=A,--V>0)for(let x=0;x<V;x++)S[g++]=R[n++]}for(i=0;i<k;i++)c=S[i],A=S[i+k],D=S[i+2*k],U=S[i+3*k],t(b,c,A,D,U,(x.height-H)*k*3+3*i);H--}return b}(R,x)}function J(R,x){let H=x.height;const k=x.width;let c,A,D,U,J,V=x.dataPosition;const n=new ArrayBuffer(x.width*x.height*4*3),g=new Float32Array(n);for(;H>0;){for(J=0;J<x.width;J++)c=R[V++],A=R[V++],D=R[V++],U=R[V++],t(g,c,A,D,U,(x.height-H)*k*3+3*J);H--}return g}c.FACE_LEFT=[new k.o(-1,-1,-1),new k.o(1,-1,-1),new k.o(-1,1,-1),new k.o(1,1,-1)],c.FACE_RIGHT=[new k.o(1,-1,1),new k.o(-1,-1,1),new k.o(1,1,1),new k.o(-1,1,1)],c.FACE_FRONT=[new k.o(1,-1,-1),new k.o(1,-1,1),new k.o(1,1,-1),new k.o(1,1,1)],c.FACE_BACK=[new k.o(-1,-1,1),new k.o(-1,-1,-1),new k.o(-1,1,1),new k.o(-1,1,-1)],c.FACE_DOWN=[new k.o(1,1,-1),new k.o(1,1,1),new k.o(-1,1,-1),new k.o(-1,1,1)],c.FACE_UP=[new k.o(-1,-1,-1),new k.o(-1,-1,1),new k.o(1,-1,-1),new k.o(1,-1,1)];class V{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(R,x,H){const k=new Uint8Array(R.buffer,R.byteOffset,R.byteLength),c=D(k),t=U(k,c),A=c.width*c.height,J=new Float32Array(4*A);for(let D=0;D<A;D+=1)J[4*D]=t[3*D],J[4*D+1]=t[3*D+1],J[4*D+2]=t[3*D+2],J[4*D+3]=1;H(c.width,c.height,x.generateMipMaps,!1,(()=>{const R=x.getEngine();x.type=1,x.format=5,x._gammaSpace=!1,R._uploadDataToTextureDirectly(x,J)}))}}}}]);