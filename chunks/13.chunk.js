"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{2585:(Q,X,C)=>{C.r(X),C.d(X,{_HDRTextureLoader:()=>U});var l=C(668);class h{static ConvertPanoramaToCubemap(Q,X,C,l){let h=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Q)throw"ConvertPanoramaToCubemap: input cannot be null";if(Q.length!=X*C*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(l,this.FACE_FRONT,Q,X,C,h),back:this.CreateCubemapTexture(l,this.FACE_BACK,Q,X,C,h),left:this.CreateCubemapTexture(l,this.FACE_LEFT,Q,X,C,h),right:this.CreateCubemapTexture(l,this.FACE_RIGHT,Q,X,C,h),up:this.CreateCubemapTexture(l,this.FACE_UP,Q,X,C,h),down:this.CreateCubemapTexture(l,this.FACE_DOWN,Q,X,C,h),size:l,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(Q,X,C,l,h){let M=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const f=new ArrayBuffer(Q*Q*4*3),O=new Float32Array(f),m=M?Math.max(1,Math.round(l/4/Q)):1,W=1/m,U=W*W,L=X[1].Od(X[0]).scale(W/Q),w=X[3].Od(X[2]).scale(W/Q),i=1/Q;let a=0;for(let F=0;F<Q;F++)for(let M=0;M<m;M++){let M=X[0],f=X[2];for(let X=0;X<Q;X++)for(let W=0;W<m;W++){const m=f.Od(M).scale(a).add(M);m.normalize();const W=this.CalcProjectionSpherical(m,C,l,h);O[F*Q*3+3*X+0]+=W.r*U,O[F*Q*3+3*X+1]+=W.g*U,O[F*Q*3+3*X+2]+=W.b*U,M=M.add(L),f=f.add(w)}a+=i*W}return O}static CalcProjectionSpherical(Q,X,C,l){let h=Math.atan2(Q.z,Q.x);const M=Math.acos(Q.y);for(;h<-Math.PI;)h+=2*Math.PI;for(;h>Math.PI;)h-=2*Math.PI;let f=h/Math.PI;const O=M/Math.PI;f=.5*f+.5;let m=Math.round(f*C);m<0?m=0:m>=C&&(m=C-1);let W=Math.round(O*l);W<0?W=0:W>=l&&(W=l-1);const U=l-W-1;return{r:X[U*C*3+3*m+0],g:X[U*C*3+3*m+1],b:X[U*C*3+3*m+2]}}}function M(Q,X,C,l,h,M){h>0?(h=function(Q,X){return X>1023?Q*Math.pow(2,1023)*Math.pow(2,X-1023):X<-1074?Q*Math.pow(2,-1074)*Math.pow(2,X+1074):Q*Math.pow(2,X)}(1,h-136),Q[M+0]=X*h,Q[M+1]=C*h,Q[M+2]=l*h):(Q[M+0]=0,Q[M+1]=0,Q[M+2]=0)}function f(Q,X){let C="",l="";for(let h=X;h<Q.length-X&&(l=String.fromCharCode(Q[h]),"\n"!=l);h++)C+=l;return C}function O(Q){let X=0,C=0,l=f(Q,0);if("#"!=l[0]||"?"!=l[1])throw"Bad HDR Format.";let h=!1,M=!1,O=0;do{O+=l.length+1,l=f(Q,O),"FORMAT=32-bit_rle_rgbe"==l?M=!0:0==l.length&&(h=!0)}while(!h);if(!M)throw"HDR Bad header format, unsupported FORMAT";O+=l.length+1,l=f(Q,O);const m=/^-Y (.*) \+X (.*)$/g.exec(l);if(!m||m.length<3)throw"HDR Bad header format, no size";if(C=parseInt(m[2]),X=parseInt(m[1]),C<8||C>32767)throw"HDR Bad header format, unsupported size";return O+=l.length+1,{height:X,width:C,dataPosition:O}}function m(Q,X){return function(Q,X){let C=X.height;const l=X.width;let h,f,O,m,U,L=X.dataPosition,w=0,i=0,a=0;const F=new ArrayBuffer(4*l),s=new Uint8Array(F),z=new ArrayBuffer(X.width*X.height*4*3),x=new Float32Array(z);for(;C>0;){if(h=Q[L++],f=Q[L++],O=Q[L++],m=Q[L++],2!=h||2!=f||128&O||X.width<8||X.width>32767)return W(Q,X);if((O<<8|m)!=l)throw"HDR Bad header format, wrong scan line width";for(w=0,a=0;a<4;a++)for(i=(a+1)*l;w<i;)if(h=Q[L++],f=Q[L++],h>128){if(U=h-128,0==U||U>i-w)throw"HDR Bad Format, bad scanline data (run)";for(;U-- >0;)s[w++]=f}else{if(U=h,0==U||U>i-w)throw"HDR Bad Format, bad scanline data (non-run)";if(s[w++]=f,--U>0)for(let X=0;X<U;X++)s[w++]=Q[L++]}for(a=0;a<l;a++)h=s[a],f=s[a+l],O=s[a+2*l],m=s[a+3*l],M(x,h,f,O,m,(X.height-C)*l*3+3*a);C--}return x}(Q,X)}function W(Q,X){let C=X.height;const l=X.width;let h,f,O,m,W,U=X.dataPosition;const L=new ArrayBuffer(X.width*X.height*4*3),w=new Float32Array(L);for(;C>0;){for(W=0;W<X.width;W++)h=Q[U++],f=Q[U++],O=Q[U++],m=Q[U++],M(w,h,f,O,m,(X.height-C)*l*3+3*W);C--}return w}h.FACE_LEFT=[new l.k(-1,-1,-1),new l.k(1,-1,-1),new l.k(-1,1,-1),new l.k(1,1,-1)],h.FACE_RIGHT=[new l.k(1,-1,1),new l.k(-1,-1,1),new l.k(1,1,1),new l.k(-1,1,1)],h.FACE_FRONT=[new l.k(1,-1,-1),new l.k(1,-1,1),new l.k(1,1,-1),new l.k(1,1,1)],h.FACE_BACK=[new l.k(-1,-1,1),new l.k(-1,-1,-1),new l.k(-1,1,1),new l.k(-1,1,-1)],h.FACE_DOWN=[new l.k(1,1,-1),new l.k(1,1,1),new l.k(-1,1,-1),new l.k(-1,1,1)],h.FACE_UP=[new l.k(-1,-1,-1),new l.k(-1,-1,1),new l.k(1,-1,-1),new l.k(1,-1,1)];class U{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(Q,X,C){const l=new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength),h=O(l),M=m(l,h),f=h.width*h.height,W=new Float32Array(4*f);for(let O=0;O<f;O+=1)W[4*O]=M[3*O],W[4*O+1]=M[3*O+1],W[4*O+2]=M[3*O+2],W[4*O+3]=1;C(h.width,h.height,X.generateMipMaps,!1,(()=>{const Q=X.getEngine();X.type=1,X.format=5,X._gammaSpace=!1,Q._uploadDataToTextureDirectly(X,W)}))}}}}]);