"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12823:(N,q,R)=>{R.r(q),R.d(q,{_BasisTextureLoader:()=>V});var z,v=R(10888),B=R(11402),F=R(10985);function S(){const N=0,q=1,R=2,z=3,v=6,B=8,F=9,S=10,A=14;let y=null;function E(N,q,R,z,v){const B=N.getImageTranscodedSizeInBytes(q,R,z);let F=new Uint8Array(B);if(!N.transcodeImage(F,q,R,z,1,0))return null;if(v){F=function(N,q,R,z){const v=new Uint16Array(4),B=new Uint16Array(R*z),F=R/4,S=z/4;for(let A=0;A<S;A++)for(let z=0;z<F;z++){const S=q+8*(A*F+z);v[0]=N[S]|N[S+1]<<8,v[1]=N[S+2]|N[S+3]<<8,v[2]=(2*(31&v[0])+1*(31&v[1]))/3|(2*(2016&v[0])+1*(2016&v[1]))/3&2016|(2*(63488&v[0])+1*(63488&v[1]))/3&63488,v[3]=(2*(31&v[1])+1*(31&v[0]))/3|(2*(2016&v[1])+1*(2016&v[0]))/3&2016|(2*(63488&v[1])+1*(63488&v[0]))/3&63488;for(let q=0;q<4;q++){const F=N[S+4+q];let y=(4*A+q)*R+4*z;B[y++]=v[3&F],B[y++]=v[F>>2&3],B[y++]=v[F>>4&3],B[y++]=v[F>>6&3]}}return B}(F,0,N.getImageWidth(q,R)+3&-4,N.getImageHeight(q,R)+3&-4)}return F}onmessage=t=>{if("init"===t.data.action){if(t.data.url)try{importScripts(t.data.url)}catch(x){postMessage({action:"error",error:x})}y||(y=BASIS({wasmBinary:t.data.wasmBinary})),null!==y&&y.then((N=>{BASIS=N,N.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===t.data.action){const y=t.data.config,x=t.data.imageData,e=new BASIS.BasisFile(x),b=function(N){const q=N.getHasAlpha(),R=N.getNumImages(),z=[];for(let v=0;v<R;v++){const q={levels:[]},R=N.getNumLevels(v);for(let z=0;z<R;z++){const R={width:N.getImageWidth(v,z),height:N.getImageHeight(v,z)};q.levels.push(R)}z.push(q)}return{Fe:q,images:z}}(e);let f=t.data.ignoreSupportedFormats?null:function(y,E){let t=null;y.supportedCompressionFormats&&(t=y.supportedCompressionFormats.astc?S:y.supportedCompressionFormats.bc7?v:y.supportedCompressionFormats.s3tc?E.Fe?z:R:y.supportedCompressionFormats.pvrtc?E.Fe?F:B:y.supportedCompressionFormats.etc2?q:y.supportedCompressionFormats.etc1?N:A);return t}(t.data.config,b),D=!1;null===f&&(D=!0,f=b.Fe?z:R);let V=!0;e.startTranscoding()||(V=!1);const H=[];for(let N=0;N<b.images.length&&V;N++){const q=b.images[N];if(void 0===y.loadSingleImage||y.loadSingleImage===N){let R=q.levels.length;!1===y.loadMipmapLevels&&(R=1);for(let z=0;z<R;z++){const R=q.levels[z],v=E(e,N,z,f,D);if(!v){V=!1;break}R.transcodedPixels=v,H.push(R.transcodedPixels.buffer)}}}e.close(),e.delete(),D&&(f=-1),V?postMessage({action:"transcode",success:V,id:t.data.id,fileInfo:b,format:f},H):postMessage({action:"transcode",success:V,id:t.data.id})}}}!function(N){N[N.cTFETC1=0]="cTFETC1",N[N.cTFETC2=1]="cTFETC2",N[N.cTFBC1=2]="cTFBC1",N[N.cTFBC3=3]="cTFBC3",N[N.cTFBC4=4]="cTFBC4",N[N.cTFBC5=5]="cTFBC5",N[N.cTFBC7=6]="cTFBC7",N[N.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",N[N.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",N[N.cTFASTC_4x4=10]="cTFASTC_4x4",N[N.cTFATC_RGB=11]="cTFATC_RGB",N[N.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",N[N.cTFRGBA32=13]="cTFRGBA32",N[N.cTFRGB565=14]="cTFRGB565",N[N.cTFBGR565=15]="cTFBGR565",N[N.cTFRGBA4444=16]="cTFRGBA4444",N[N.cTFFXT1_RGB=17]="cTFFXT1_RGB",N[N.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",N[N.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",N[N.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",N[N.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(z||(z={}));const A={JSModuleURL:`${v.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${v.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let y=null,E=null,t=0;const x=()=>(y||(y=new Promise(((N,q)=>{E?N(E):v.f.LoadFileAsync(v.f.GetBabylonScriptURL(A.WasmModuleURL)).then((R=>{if("function"!==typeof URL)return q("Basis transcoder requires an environment with a URL constructor");const z=URL.createObjectURL(new Blob([`(${S})()`],{type:"application/javascript"}));E=new Worker(z),function(N,q,R){return new Promise(((z,B)=>{const F=q=>{"init"===q.data.action?(N.removeEventListener("message",F),z(N)):"error"===q.data.action&&B(q.data.error||"error initializing worker")};N.addEventListener("message",F),N.postMessage({action:"init",url:R?v.f.GetBabylonScriptURL(R):void 0,wasmBinary:q},[q])}))}(E,R,A.JSModuleURL).then(N,q)})).catch(q)}))),y),e=(N,q)=>{const R=N instanceof ArrayBuffer?new Uint8Array(N):N;return new Promise(((N,z)=>{x().then((()=>{const v=t++,B=q=>{"transcode"===q.data.action&&q.data.id===v&&(E.removeEventListener("message",B),q.data.success?N(q.data):z("Transcode is not supported on this device"))};E.addEventListener("message",B);const F=new Uint8Array(R.byteLength);F.set(new Uint8Array(R.buffer,R.byteOffset,R.byteLength)),E.postMessage({action:"transcode",id:v,imageData:F,config:q,ignoreSupportedFormats:false},[F.buffer])}),(N=>{z(N)}))}))},b=(N,q)=>{var R;let z=null===(R=q._gl)||void 0===R?void 0:R.TEXTURE_2D;var v;N.isCube&&(z=null===(v=q._gl)||void 0===v?void 0:v.TEXTURE_CUBE_MAP);q._bindTextureDirectly(z,N,!0)},f=(N,q)=>{const R=N.getEngine();for(let S=0;S<q.fileInfo.images.length;S++){const A=q.fileInfo.images[S].levels[0];if(N._invertVScale=N.invertY,-1===q.format||q.format===z.cTFRGB565)if(N.type=10,N.format=4,!R._features.basisNeedsPOT||Math.log2(A.width)%1===0&&Math.log2(A.height)%1===0)N._invertVScale=!N.invertY,N.width=A.width+3&-4,N.height=A.height+3&-4,N.samplingMode=2,b(N,R),R._uploadDataToTextureDirectly(N,new Uint16Array(A.transcodedPixels.buffer),S,0,4,!0);else{const q=new F.c(R,2);N._invertVScale=N.invertY,q.type=10,q.format=4,q.width=A.width+3&-4,q.height=A.height+3&-4,b(q,R),R._uploadDataToTextureDirectly(q,new Uint16Array(A.transcodedPixels.buffer),S,0,4,!0),R._rescaleTexture(q,N,R.scenes[0],R._getInternalFormat(4),(()=>{R._releaseTexture(q),b(N,R)}))}else{N.width=A.width,N.height=A.height,N.generateMipMaps=q.fileInfo.images[S].levels.length>1;const z=D.GetInternalFormatFromBasisFormat(q.format,R);N.format=z,b(N,R),q.fileInfo.images[S].levels.forEach(((q,v)=>{R._uploadCompressedDataToTextureDirectly(N,z,q.width,q.height,q.transcodedPixels,S,v)})),!R._features.basisNeedsPOT||Math.log2(N.width)%1===0&&Math.log2(N.height)%1===0||(v.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),N._cachedWrapU=B.c.CLAMP_ADDRESSMODE,N._cachedWrapV=B.c.CLAMP_ADDRESSMODE)}}},D={JSModuleURL:A.JSModuleURL,WasmModuleURL:A.WasmModuleURL,GetInternalFormatFromBasisFormat:(N,q)=>{let R;switch(N){case z.cTFETC1:R=36196;break;case z.cTFBC1:R=33776;break;case z.cTFBC4:R=33779;break;case z.cTFASTC_4x4:R=37808;break;case z.cTFETC2:R=37496;break;case z.cTFBC7:R=36492}if(void 0===R)throw"The chosen Basis transcoder format is not currently supported";return R},TranscodeAsync:e,LoadTextureFromTranscodeResult:f};Object.defineProperty(D,"JSModuleURL",{get:function(){return A.JSModuleURL},set:function(N){A.JSModuleURL=N}}),Object.defineProperty(D,"WasmModuleURL",{get:function(){return A.WasmModuleURL},set:function(N){A.WasmModuleURL=N}});class V{constructor(){this.supportCascades=!1}loadCubeData(N,q,R,z,B){if(Array.isArray(N))return;const F=q.getEngine().getCaps(),S={supportedCompressionFormats:{etc1:!!F.etc1,s3tc:!!F.s3tc,pvrtc:!!F.pvrtc,etc2:!!F.etc2,astc:!!F.astc,bc7:!!F.bptc}};e(N,S).then((N=>{const R=N.fileInfo.images[0].levels.length>1&&q.generateMipMaps;f(q,N),q.getEngine()._setCubeMapTextureParams(q,R),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),z&&z()})).catch((N=>{v.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),q.isReady=!0,B&&B(N)}))}loadData(N,q,R){const z=q.getEngine().getCaps(),B={supportedCompressionFormats:{etc1:!!z.etc1,s3tc:!!z.s3tc,pvrtc:!!z.pvrtc,etc2:!!z.etc2,astc:!!z.astc,bc7:!!z.bptc}};e(N,B).then((N=>{const z=N.fileInfo.images[0].levels[0],v=N.fileInfo.images[0].levels.length>1&&q.generateMipMaps;R(z.width,z.height,v,-1!==N.format,(()=>{f(q,N)}))})).catch((N=>{v.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),v.f.Warn(`Failed to transcode Basis file: ${N}`),R(0,0,!1,!1,(()=>{}),!0)}))}}}}]);