"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12738:(R,q,L)=>{L.r(q),L.d(q,{_BasisTextureLoader:()=>c});var B,N=L(10757),h=L(11277),Z=L(10867);function z(){const R=0,q=1,L=2,B=3,N=6,h=8,Z=9,z=10,Y=14;let F=null;function C(R,q,L,B,N){const h=R.getImageTranscodedSizeInBytes(q,L,B);let Z=new Uint8Array(h);if(!R.transcodeImage(Z,q,L,B,1,0))return null;if(N){Z=function(R,q,L,B){const N=new Uint16Array(4),h=new Uint16Array(L*B),Z=L/4,z=B/4;for(let Y=0;Y<z;Y++)for(let B=0;B<Z;B++){const z=q+8*(Y*Z+B);N[0]=R[z]|R[z+1]<<8,N[1]=R[z+2]|R[z+3]<<8,N[2]=(2*(31&N[0])+1*(31&N[1]))/3|(2*(2016&N[0])+1*(2016&N[1]))/3&2016|(2*(63488&N[0])+1*(63488&N[1]))/3&63488,N[3]=(2*(31&N[1])+1*(31&N[0]))/3|(2*(2016&N[1])+1*(2016&N[0]))/3&2016|(2*(63488&N[1])+1*(63488&N[0]))/3&63488;for(let q=0;q<4;q++){const Z=R[z+4+q];let F=(4*Y+q)*L+4*B;h[F++]=N[3&Z],h[F++]=N[Z>>2&3],h[F++]=N[Z>>4&3],h[F++]=N[Z>>6&3]}}return h}(Z,0,R.getImageWidth(q,L)+3&-4,R.getImageHeight(q,L)+3&-4)}return Z}onmessage=e=>{if("init"===e.data.action){if(e.data.url)try{importScripts(e.data.url)}catch(y){postMessage({action:"error",error:y})}F||(F=BASIS({wasmBinary:e.data.wasmBinary})),null!==F&&F.then((R=>{BASIS=R,R.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===e.data.action){const F=e.data.config,y=e.data.imageData,U=new BASIS.BasisFile(y),n=function(R){const q=R.getHasAlpha(),L=R.getNumImages(),B=[];for(let N=0;N<L;N++){const q={levels:[]},L=R.getNumLevels(N);for(let B=0;B<L;B++){const L={width:R.getImageWidth(N,B),height:R.getImageHeight(N,B)};q.levels.push(L)}B.push(q)}return{je:q,images:B}}(U);let r=e.data.ignoreSupportedFormats?null:function(F,C){let e=null;F.supportedCompressionFormats&&(e=F.supportedCompressionFormats.astc?z:F.supportedCompressionFormats.bc7?N:F.supportedCompressionFormats.s3tc?C.je?B:L:F.supportedCompressionFormats.pvrtc?C.je?Z:h:F.supportedCompressionFormats.etc2?q:F.supportedCompressionFormats.etc1?R:Y);return e}(e.data.config,n),p=!1;null===r&&(p=!0,r=n.je?B:L);let c=!0;U.startTranscoding()||(c=!1);const d=[];for(let R=0;R<n.images.length&&c;R++){const q=n.images[R];if(void 0===F.loadSingleImage||F.loadSingleImage===R){let L=q.levels.length;!1===F.loadMipmapLevels&&(L=1);for(let B=0;B<L;B++){const L=q.levels[B],N=C(U,R,B,r,p);if(!N){c=!1;break}L.transcodedPixels=N,d.push(L.transcodedPixels.buffer)}}}U.close(),U.delete(),p&&(r=-1),c?postMessage({action:"transcode",success:c,id:e.data.id,fileInfo:n,format:r},d):postMessage({action:"transcode",success:c,id:e.data.id})}}}!function(R){R[R.cTFETC1=0]="cTFETC1",R[R.cTFETC2=1]="cTFETC2",R[R.cTFBC1=2]="cTFBC1",R[R.cTFBC3=3]="cTFBC3",R[R.cTFBC4=4]="cTFBC4",R[R.cTFBC5=5]="cTFBC5",R[R.cTFBC7=6]="cTFBC7",R[R.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",R[R.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",R[R.cTFASTC_4x4=10]="cTFASTC_4x4",R[R.cTFATC_RGB=11]="cTFATC_RGB",R[R.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",R[R.cTFRGBA32=13]="cTFRGBA32",R[R.cTFRGB565=14]="cTFRGB565",R[R.cTFBGR565=15]="cTFBGR565",R[R.cTFRGBA4444=16]="cTFRGBA4444",R[R.cTFFXT1_RGB=17]="cTFFXT1_RGB",R[R.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",R[R.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",R[R.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",R[R.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(B||(B={}));const Y={JSModuleURL:`${N.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${N.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let F=null,C=null,e=0;const y=()=>(F||(F=new Promise(((R,q)=>{C?R(C):N.f.LoadFileAsync(N.f.GetBabylonScriptURL(Y.WasmModuleURL)).then((L=>{if("function"!==typeof URL)return q("Basis transcoder requires an environment with a URL constructor");const B=URL.createObjectURL(new Blob([`(${z})()`],{type:"application/javascript"}));C=new Worker(B),function(R,q,L){return new Promise(((B,h)=>{const Z=q=>{"init"===q.data.action?(R.removeEventListener("message",Z),B(R)):"error"===q.data.action&&h(q.data.error||"error initializing worker")};R.addEventListener("message",Z),R.postMessage({action:"init",url:L?N.f.GetBabylonScriptURL(L):void 0,wasmBinary:q},[q])}))}(C,L,Y.JSModuleURL).then(R,q)})).catch(q)}))),F),U=(R,q)=>{const L=R instanceof ArrayBuffer?new Uint8Array(R):R;return new Promise(((R,B)=>{y().then((()=>{const N=e++,h=q=>{"transcode"===q.data.action&&q.data.id===N&&(C.removeEventListener("message",h),q.data.success?R(q.data):B("Transcode is not supported on this device"))};C.addEventListener("message",h);const Z=new Uint8Array(L.byteLength);Z.set(new Uint8Array(L.buffer,L.byteOffset,L.byteLength)),C.postMessage({action:"transcode",id:N,imageData:Z,config:q,ignoreSupportedFormats:false},[Z.buffer])}),(R=>{B(R)}))}))},n=(R,q)=>{var L;let B=null===(L=q._gl)||void 0===L?void 0:L.TEXTURE_2D;var N;R.isCube&&(B=null===(N=q._gl)||void 0===N?void 0:N.TEXTURE_CUBE_MAP);q._bindTextureDirectly(B,R,!0)},r=(R,q)=>{const L=R.getEngine();for(let z=0;z<q.fileInfo.images.length;z++){const Y=q.fileInfo.images[z].levels[0];if(R._invertVScale=R.invertY,-1===q.format||q.format===B.cTFRGB565)if(R.type=10,R.format=4,!L._features.basisNeedsPOT||Math.log2(Y.width)%1===0&&Math.log2(Y.height)%1===0)R._invertVScale=!R.invertY,R.width=Y.width+3&-4,R.height=Y.height+3&-4,R.samplingMode=2,n(R,L),L._uploadDataToTextureDirectly(R,new Uint16Array(Y.transcodedPixels.buffer),z,0,4,!0);else{const q=new Z.b(L,2);R._invertVScale=R.invertY,q.type=10,q.format=4,q.width=Y.width+3&-4,q.height=Y.height+3&-4,n(q,L),L._uploadDataToTextureDirectly(q,new Uint16Array(Y.transcodedPixels.buffer),z,0,4,!0),L._rescaleTexture(q,R,L.scenes[0],L._getInternalFormat(4),(()=>{L._releaseTexture(q),n(R,L)}))}else{R.width=Y.width,R.height=Y.height,R.generateMipMaps=q.fileInfo.images[z].levels.length>1;const B=p.GetInternalFormatFromBasisFormat(q.format,L);R.format=B,n(R,L),q.fileInfo.images[z].levels.forEach(((q,N)=>{L._uploadCompressedDataToTextureDirectly(R,B,q.width,q.height,q.transcodedPixels,z,N)})),!L._features.basisNeedsPOT||Math.log2(R.width)%1===0&&Math.log2(R.height)%1===0||(N.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),R._cachedWrapU=h.c.CLAMP_ADDRESSMODE,R._cachedWrapV=h.c.CLAMP_ADDRESSMODE)}}},p={JSModuleURL:Y.JSModuleURL,WasmModuleURL:Y.WasmModuleURL,GetInternalFormatFromBasisFormat:(R,q)=>{let L;switch(R){case B.cTFETC1:L=36196;break;case B.cTFBC1:L=33776;break;case B.cTFBC4:L=33779;break;case B.cTFASTC_4x4:L=37808;break;case B.cTFETC2:L=37496;break;case B.cTFBC7:L=36492}if(void 0===L)throw"The chosen Basis transcoder format is not currently supported";return L},TranscodeAsync:U,LoadTextureFromTranscodeResult:r};Object.defineProperty(p,"JSModuleURL",{get:function(){return Y.JSModuleURL},set:function(R){Y.JSModuleURL=R}}),Object.defineProperty(p,"WasmModuleURL",{get:function(){return Y.WasmModuleURL},set:function(R){Y.WasmModuleURL=R}});class c{constructor(){this.supportCascades=!1}loadCubeData(R,q,L,B,h){if(Array.isArray(R))return;const Z=q.getEngine().getCaps(),z={supportedCompressionFormats:{etc1:!!Z.etc1,s3tc:!!Z.s3tc,pvrtc:!!Z.pvrtc,etc2:!!Z.etc2,astc:!!Z.astc,bc7:!!Z.bptc}};U(R,z).then((R=>{const L=R.fileInfo.images[0].levels.length>1&&q.generateMipMaps;r(q,R),q.getEngine()._setCubeMapTextureParams(q,L),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),B&&B()})).catch((R=>{N.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),q.isReady=!0,h&&h(R)}))}loadData(R,q,L){const B=q.getEngine().getCaps(),h={supportedCompressionFormats:{etc1:!!B.etc1,s3tc:!!B.s3tc,pvrtc:!!B.pvrtc,etc2:!!B.etc2,astc:!!B.astc,bc7:!!B.bptc}};U(R,h).then((R=>{const B=R.fileInfo.images[0].levels[0],N=R.fileInfo.images[0].levels.length>1&&q.generateMipMaps;L(B.width,B.height,N,-1!==R.format,(()=>{r(q,R)}))})).catch((R=>{N.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),N.f.Warn(`Failed to transcode Basis file: ${R}`),L(0,0,!1,!1,(()=>{}),!0)}))}}}}]);