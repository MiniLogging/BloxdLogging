"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12761:(d,t,A)=>{A.r(t),A.d(t,{_BasisTextureLoader:()=>U});var w,N=A(10727),p=A(11264),B=A(10861);function X(){const d=0,t=1,A=2,w=3,N=6,p=8,B=9,X=10,W=14;let a=null;function D(d,t,A,w,N){const p=d.getImageTranscodedSizeInBytes(t,A,w);let B=new Uint8Array(p);if(!d.transcodeImage(B,t,A,w,1,0))return null;if(N){B=function(d,t,A,w){const N=new Uint16Array(4),p=new Uint16Array(A*w),B=A/4,X=w/4;for(let W=0;W<X;W++)for(let w=0;w<B;w++){const X=t+8*(W*B+w);N[0]=d[X]|d[X+1]<<8,N[1]=d[X+2]|d[X+3]<<8,N[2]=(2*(31&N[0])+1*(31&N[1]))/3|(2*(2016&N[0])+1*(2016&N[1]))/3&2016|(2*(63488&N[0])+1*(63488&N[1]))/3&63488,N[3]=(2*(31&N[1])+1*(31&N[0]))/3|(2*(2016&N[1])+1*(2016&N[0]))/3&2016|(2*(63488&N[1])+1*(63488&N[0]))/3&63488;for(let t=0;t<4;t++){const B=d[X+4+t];let a=(4*W+t)*A+4*w;p[a++]=N[3&B],p[a++]=N[B>>2&3],p[a++]=N[B>>4&3],p[a++]=N[B>>6&3]}}return p}(B,0,d.getImageWidth(t,A)+3&-4,d.getImageHeight(t,A)+3&-4)}return B}onmessage=i=>{if("init"===i.data.action){if(i.data.url)try{importScripts(i.data.url)}catch(k){postMessage({action:"error",error:k})}a||(a=BASIS({wasmBinary:i.data.wasmBinary})),null!==a&&a.then((d=>{BASIS=d,d.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===i.data.action){const a=i.data.config,k=i.data.imageData,b=new BASIS.BasisFile(k),Q=function(d){const t=d.getHasAlpha(),A=d.getNumImages(),w=[];for(let N=0;N<A;N++){const t={levels:[]},A=d.getNumLevels(N);for(let w=0;w<A;w++){const A={width:d.getImageWidth(N,w),height:d.getImageHeight(N,w)};t.levels.push(A)}w.push(t)}return{uc:t,images:w}}(b);let P=i.data.ignoreSupportedFormats?null:function(a,D){let i=null;a.supportedCompressionFormats&&(i=a.supportedCompressionFormats.astc?X:a.supportedCompressionFormats.bc7?N:a.supportedCompressionFormats.s3tc?D.uc?w:A:a.supportedCompressionFormats.pvrtc?D.uc?B:p:a.supportedCompressionFormats.etc2?t:a.supportedCompressionFormats.etc1?d:W);return i}(i.data.config,Q),J=!1;null===P&&(J=!0,P=Q.uc?w:A);let U=!0;b.startTranscoding()||(U=!1);const T=[];for(let d=0;d<Q.images.length&&U;d++){const t=Q.images[d];if(void 0===a.loadSingleImage||a.loadSingleImage===d){let A=t.levels.length;!1===a.loadMipmapLevels&&(A=1);for(let w=0;w<A;w++){const A=t.levels[w],N=D(b,d,w,P,J);if(!N){U=!1;break}A.transcodedPixels=N,T.push(A.transcodedPixels.buffer)}}}b.close(),b.delete(),J&&(P=-1),U?postMessage({action:"transcode",success:U,id:i.data.id,fileInfo:Q,format:P},T):postMessage({action:"transcode",success:U,id:i.data.id})}}}!function(d){d[d.cTFETC1=0]="cTFETC1",d[d.cTFETC2=1]="cTFETC2",d[d.cTFBC1=2]="cTFBC1",d[d.cTFBC3=3]="cTFBC3",d[d.cTFBC4=4]="cTFBC4",d[d.cTFBC5=5]="cTFBC5",d[d.cTFBC7=6]="cTFBC7",d[d.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",d[d.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",d[d.cTFASTC_4x4=10]="cTFASTC_4x4",d[d.cTFATC_RGB=11]="cTFATC_RGB",d[d.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",d[d.cTFRGBA32=13]="cTFRGBA32",d[d.cTFRGB565=14]="cTFRGB565",d[d.cTFBGR565=15]="cTFBGR565",d[d.cTFRGBA4444=16]="cTFRGBA4444",d[d.cTFFXT1_RGB=17]="cTFFXT1_RGB",d[d.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",d[d.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",d[d.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",d[d.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(w||(w={}));const W={JSModuleURL:`${N.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${N.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let a=null,D=null,i=0;const k=()=>(a||(a=new Promise(((d,t)=>{D?d(D):N.g.LoadFileAsync(N.g.GetBabylonScriptURL(W.WasmModuleURL)).then((A=>{if("function"!==typeof URL)return t("Basis transcoder requires an environment with a URL constructor");const w=URL.createObjectURL(new Blob([`(${X})()`],{type:"application/javascript"}));D=new Worker(w),function(d,t,A){return new Promise(((w,p)=>{const B=t=>{"init"===t.data.action?(d.removeEventListener("message",B),w(d)):"error"===t.data.action&&p(t.data.error||"error initializing worker")};d.addEventListener("message",B),d.postMessage({action:"init",url:A?N.g.GetBabylonScriptURL(A):void 0,wasmBinary:t},[t])}))}(D,A,W.JSModuleURL).then(d,t)})).catch(t)}))),a),b=(d,t)=>{const A=d instanceof ArrayBuffer?new Uint8Array(d):d;return new Promise(((d,w)=>{k().then((()=>{const N=i++,p=t=>{"transcode"===t.data.action&&t.data.id===N&&(D.removeEventListener("message",p),t.data.success?d(t.data):w("Transcode is not supported on this device"))};D.addEventListener("message",p);const B=new Uint8Array(A.byteLength);B.set(new Uint8Array(A.buffer,A.byteOffset,A.byteLength)),D.postMessage({action:"transcode",id:N,imageData:B,config:t,ignoreSupportedFormats:false},[B.buffer])}),(d=>{w(d)}))}))},Q=(d,t)=>{var A;let w=null===(A=t._gl)||void 0===A?void 0:A.TEXTURE_2D;var N;d.isCube&&(w=null===(N=t._gl)||void 0===N?void 0:N.TEXTURE_CUBE_MAP);t._bindTextureDirectly(w,d,!0)},P=(d,t)=>{const A=d.getEngine();for(let X=0;X<t.fileInfo.images.length;X++){const W=t.fileInfo.images[X].levels[0];if(d._invertVScale=d.invertY,-1===t.format||t.format===w.cTFRGB565)if(d.type=10,d.format=4,!A._features.basisNeedsPOT||Math.log2(W.width)%1===0&&Math.log2(W.height)%1===0)d._invertVScale=!d.invertY,d.width=W.width+3&-4,d.height=W.height+3&-4,d.samplingMode=2,Q(d,A),A._uploadDataToTextureDirectly(d,new Uint16Array(W.transcodedPixels.buffer),X,0,4,!0);else{const t=new B.c(A,2);d._invertVScale=d.invertY,t.type=10,t.format=4,t.width=W.width+3&-4,t.height=W.height+3&-4,Q(t,A),A._uploadDataToTextureDirectly(t,new Uint16Array(W.transcodedPixels.buffer),X,0,4,!0),A._rescaleTexture(t,d,A.scenes[0],A._getInternalFormat(4),(()=>{A._releaseTexture(t),Q(d,A)}))}else{d.width=W.width,d.height=W.height,d.generateMipMaps=t.fileInfo.images[X].levels.length>1;const w=J.GetInternalFormatFromBasisFormat(t.format,A);d.format=w,Q(d,A),t.fileInfo.images[X].levels.forEach(((t,N)=>{A._uploadCompressedDataToTextureDirectly(d,w,t.width,t.height,t.transcodedPixels,X,N)})),!A._features.basisNeedsPOT||Math.log2(d.width)%1===0&&Math.log2(d.height)%1===0||(N.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),d._cachedWrapU=p.c.CLAMP_ADDRESSMODE,d._cachedWrapV=p.c.CLAMP_ADDRESSMODE)}}},J={JSModuleURL:W.JSModuleURL,WasmModuleURL:W.WasmModuleURL,GetInternalFormatFromBasisFormat:(d,t)=>{let A;switch(d){case w.cTFETC1:A=36196;break;case w.cTFBC1:A=33776;break;case w.cTFBC4:A=33779;break;case w.cTFASTC_4x4:A=37808;break;case w.cTFETC2:A=37496;break;case w.cTFBC7:A=36492}if(void 0===A)throw"The chosen Basis transcoder format is not currently supported";return A},TranscodeAsync:b,LoadTextureFromTranscodeResult:P};Object.defineProperty(J,"JSModuleURL",{get:function(){return W.JSModuleURL},set:function(d){W.JSModuleURL=d}}),Object.defineProperty(J,"WasmModuleURL",{get:function(){return W.WasmModuleURL},set:function(d){W.WasmModuleURL=d}});class U{constructor(){this.supportCascades=!1}loadCubeData(d,t,A,w,p){if(Array.isArray(d))return;const B=t.getEngine().getCaps(),X={supportedCompressionFormats:{etc1:!!B.etc1,s3tc:!!B.s3tc,pvrtc:!!B.pvrtc,etc2:!!B.etc2,astc:!!B.astc,bc7:!!B.bptc}};b(d,X).then((d=>{const A=d.fileInfo.images[0].levels.length>1&&t.generateMipMaps;P(t,d),t.getEngine()._setCubeMapTextureParams(t,A),t.isReady=!0,t.onLoadedObservable.notifyObservers(t),t.onLoadedObservable.clear(),w&&w()})).catch((d=>{N.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),t.isReady=!0,p&&p(d)}))}loadData(d,t,A){const w=t.getEngine().getCaps(),p={supportedCompressionFormats:{etc1:!!w.etc1,s3tc:!!w.s3tc,pvrtc:!!w.pvrtc,etc2:!!w.etc2,astc:!!w.astc,bc7:!!w.bptc}};b(d,p).then((d=>{const w=d.fileInfo.images[0].levels[0],N=d.fileInfo.images[0].levels.length>1&&t.generateMipMaps;A(w.width,w.height,N,-1!==d.format,(()=>{P(t,d)}))})).catch((d=>{N.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),N.g.Warn(`Failed to transcode Basis file: ${d}`),A(0,0,!1,!1,(()=>{}),!0)}))}}}}]);