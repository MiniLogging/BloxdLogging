"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12695:(A,e,E)=>{E.r(e),E.d(e,{_BasisTextureLoader:()=>z});var Q,x=E(10715),t=E(11235),H=E(10838);function h(){const A=0,e=1,E=2,Q=3,x=6,t=8,H=9,h=10,Y=14;let F=null;function w(A,e,E,Q,x){const t=A.getImageTranscodedSizeInBytes(e,E,Q);let H=new Uint8Array(t);if(!A.transcodeImage(H,e,E,Q,1,0))return null;if(x){H=function(A,e,E,Q){const x=new Uint16Array(4),t=new Uint16Array(E*Q),H=E/4,h=Q/4;for(let Y=0;Y<h;Y++)for(let Q=0;Q<H;Q++){const h=e+8*(Y*H+Q);x[0]=A[h]|A[h+1]<<8,x[1]=A[h+2]|A[h+3]<<8,x[2]=(2*(31&x[0])+1*(31&x[1]))/3|(2*(2016&x[0])+1*(2016&x[1]))/3&2016|(2*(63488&x[0])+1*(63488&x[1]))/3&63488,x[3]=(2*(31&x[1])+1*(31&x[0]))/3|(2*(2016&x[1])+1*(2016&x[0]))/3&2016|(2*(63488&x[1])+1*(63488&x[0]))/3&63488;for(let e=0;e<4;e++){const H=A[h+4+e];let F=(4*Y+e)*E+4*Q;t[F++]=x[3&H],t[F++]=x[H>>2&3],t[F++]=x[H>>4&3],t[F++]=x[H>>6&3]}}return t}(H,0,A.getImageWidth(e,E)+3&-4,A.getImageHeight(e,E)+3&-4)}return H}onmessage=r=>{if("init"===r.data.action){if(r.data.url)try{importScripts(r.data.url)}catch(S){postMessage({action:"error",error:S})}F||(F=BASIS({wasmBinary:r.data.wasmBinary})),null!==F&&F.then((A=>{BASIS=A,A.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===r.data.action){const F=r.data.config,S=r.data.imageData,v=new BASIS.BasisFile(S),c=function(A){const e=A.getHasAlpha(),E=A.getNumImages(),Q=[];for(let x=0;x<E;x++){const e={levels:[]},E=A.getNumLevels(x);for(let Q=0;Q<E;Q++){const E={width:A.getImageWidth(x,Q),height:A.getImageHeight(x,Q)};e.levels.push(E)}Q.push(e)}return{Pe:e,images:Q}}(v);let D=r.data.ignoreSupportedFormats?null:function(F,w){let r=null;F.supportedCompressionFormats&&(r=F.supportedCompressionFormats.astc?h:F.supportedCompressionFormats.bc7?x:F.supportedCompressionFormats.s3tc?w.Pe?Q:E:F.supportedCompressionFormats.pvrtc?w.Pe?H:t:F.supportedCompressionFormats.etc2?e:F.supportedCompressionFormats.etc1?A:Y);return r}(r.data.config,c),a=!1;null===D&&(a=!0,D=c.Pe?Q:E);let z=!0;v.startTranscoding()||(z=!1);const I=[];for(let A=0;A<c.images.length&&z;A++){const e=c.images[A];if(void 0===F.loadSingleImage||F.loadSingleImage===A){let E=e.levels.length;!1===F.loadMipmapLevels&&(E=1);for(let Q=0;Q<E;Q++){const E=e.levels[Q],x=w(v,A,Q,D,a);if(!x){z=!1;break}E.transcodedPixels=x,I.push(E.transcodedPixels.buffer)}}}v.close(),v.delete(),a&&(D=-1),z?postMessage({action:"transcode",success:z,id:r.data.id,fileInfo:c,format:D},I):postMessage({action:"transcode",success:z,id:r.data.id})}}}!function(A){A[A.cTFETC1=0]="cTFETC1",A[A.cTFETC2=1]="cTFETC2",A[A.cTFBC1=2]="cTFBC1",A[A.cTFBC3=3]="cTFBC3",A[A.cTFBC4=4]="cTFBC4",A[A.cTFBC5=5]="cTFBC5",A[A.cTFBC7=6]="cTFBC7",A[A.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",A[A.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",A[A.cTFASTC_4x4=10]="cTFASTC_4x4",A[A.cTFATC_RGB=11]="cTFATC_RGB",A[A.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",A[A.cTFRGBA32=13]="cTFRGBA32",A[A.cTFRGB565=14]="cTFRGB565",A[A.cTFBGR565=15]="cTFBGR565",A[A.cTFRGBA4444=16]="cTFRGBA4444",A[A.cTFFXT1_RGB=17]="cTFFXT1_RGB",A[A.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",A[A.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",A[A.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",A[A.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(Q||(Q={}));const Y={JSModuleURL:`${x.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${x.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let F=null,w=null,r=0;const S=()=>(F||(F=new Promise(((A,e)=>{w?A(w):x.c.LoadFileAsync(x.c.GetBabylonScriptURL(Y.WasmModuleURL)).then((E=>{if("function"!==typeof URL)return e("Basis transcoder requires an environment with a URL constructor");const Q=URL.createObjectURL(new Blob([`(${h})()`],{type:"application/javascript"}));w=new Worker(Q),function(A,e,E){return new Promise(((Q,t)=>{const H=e=>{"init"===e.data.action?(A.removeEventListener("message",H),Q(A)):"error"===e.data.action&&t(e.data.error||"error initializing worker")};A.addEventListener("message",H),A.postMessage({action:"init",url:E?x.c.GetBabylonScriptURL(E):void 0,wasmBinary:e},[e])}))}(w,E,Y.JSModuleURL).then(A,e)})).catch(e)}))),F),v=(A,e)=>{const E=A instanceof ArrayBuffer?new Uint8Array(A):A;return new Promise(((A,Q)=>{S().then((()=>{const x=r++,t=e=>{"transcode"===e.data.action&&e.data.id===x&&(w.removeEventListener("message",t),e.data.success?A(e.data):Q("Transcode is not supported on this device"))};w.addEventListener("message",t);const H=new Uint8Array(E.byteLength);H.set(new Uint8Array(E.buffer,E.byteOffset,E.byteLength)),w.postMessage({action:"transcode",id:x,imageData:H,config:e,ignoreSupportedFormats:false},[H.buffer])}),(A=>{Q(A)}))}))},c=(A,e)=>{var E;let Q=null===(E=e._gl)||void 0===E?void 0:E.TEXTURE_2D;var x;A.isCube&&(Q=null===(x=e._gl)||void 0===x?void 0:x.TEXTURE_CUBE_MAP);e._bindTextureDirectly(Q,A,!0)},D=(A,e)=>{const E=A.getEngine();for(let h=0;h<e.fileInfo.images.length;h++){const Y=e.fileInfo.images[h].levels[0];if(A._invertVScale=A.invertY,-1===e.format||e.format===Q.cTFRGB565)if(A.type=10,A.format=4,!E._features.basisNeedsPOT||Math.log2(Y.width)%1===0&&Math.log2(Y.height)%1===0)A._invertVScale=!A.invertY,A.width=Y.width+3&-4,A.height=Y.height+3&-4,A.samplingMode=2,c(A,E),E._uploadDataToTextureDirectly(A,new Uint16Array(Y.transcodedPixels.buffer),h,0,4,!0);else{const e=new H.c(E,2);A._invertVScale=A.invertY,e.type=10,e.format=4,e.width=Y.width+3&-4,e.height=Y.height+3&-4,c(e,E),E._uploadDataToTextureDirectly(e,new Uint16Array(Y.transcodedPixels.buffer),h,0,4,!0),E._rescaleTexture(e,A,E.scenes[0],E._getInternalFormat(4),(()=>{E._releaseTexture(e),c(A,E)}))}else{A.width=Y.width,A.height=Y.height,A.generateMipMaps=e.fileInfo.images[h].levels.length>1;const Q=a.GetInternalFormatFromBasisFormat(e.format,E);A.format=Q,c(A,E),e.fileInfo.images[h].levels.forEach(((e,x)=>{E._uploadCompressedDataToTextureDirectly(A,Q,e.width,e.height,e.transcodedPixels,h,x)})),!E._features.basisNeedsPOT||Math.log2(A.width)%1===0&&Math.log2(A.height)%1===0||(x.c.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),A._cachedWrapU=t.e.CLAMP_ADDRESSMODE,A._cachedWrapV=t.e.CLAMP_ADDRESSMODE)}}},a={JSModuleURL:Y.JSModuleURL,WasmModuleURL:Y.WasmModuleURL,GetInternalFormatFromBasisFormat:(A,e)=>{let E;switch(A){case Q.cTFETC1:E=36196;break;case Q.cTFBC1:E=33776;break;case Q.cTFBC4:E=33779;break;case Q.cTFASTC_4x4:E=37808;break;case Q.cTFETC2:E=37496;break;case Q.cTFBC7:E=36492}if(void 0===E)throw"The chosen Basis transcoder format is not currently supported";return E},TranscodeAsync:v,LoadTextureFromTranscodeResult:D};Object.defineProperty(a,"JSModuleURL",{get:function(){return Y.JSModuleURL},set:function(A){Y.JSModuleURL=A}}),Object.defineProperty(a,"WasmModuleURL",{get:function(){return Y.WasmModuleURL},set:function(A){Y.WasmModuleURL=A}});class z{constructor(){this.supportCascades=!1}loadCubeData(A,e,E,Q,t){if(Array.isArray(A))return;const H=e.getEngine().getCaps(),h={supportedCompressionFormats:{etc1:!!H.etc1,s3tc:!!H.s3tc,pvrtc:!!H.pvrtc,etc2:!!H.etc2,astc:!!H.astc,bc7:!!H.bptc}};v(A,h).then((A=>{const E=A.fileInfo.images[0].levels.length>1&&e.generateMipMaps;D(e,A),e.getEngine()._setCubeMapTextureParams(e,E),e.isReady=!0,e.onLoadedObservable.notifyObservers(e),e.onLoadedObservable.clear(),Q&&Q()})).catch((A=>{x.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),e.isReady=!0,t&&t(A)}))}loadData(A,e,E){const Q=e.getEngine().getCaps(),t={supportedCompressionFormats:{etc1:!!Q.etc1,s3tc:!!Q.s3tc,pvrtc:!!Q.pvrtc,etc2:!!Q.etc2,astc:!!Q.astc,bc7:!!Q.bptc}};v(A,t).then((A=>{const Q=A.fileInfo.images[0].levels[0],x=A.fileInfo.images[0].levels.length>1&&e.generateMipMaps;E(Q.width,Q.height,x,-1!==A.format,(()=>{D(e,A)}))})).catch((A=>{x.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),x.c.Warn(`Failed to transcode Basis file: ${A}`),E(0,0,!1,!1,(()=>{}),!0)}))}}}}]);