"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12727:(h,b,I)=>{I.r(b),I.d(b,{_BasisTextureLoader:()=>i});var g,O=I(10824),T=I(11359),N=I(10944);function V(){const h=0,b=1,I=2,g=3,O=6,T=8,N=9,V=10,M=14;let y=null;function q(h,b,I,g,O){const T=h.getImageTranscodedSizeInBytes(b,I,g);let N=new Uint8Array(T);if(!h.transcodeImage(N,b,I,g,1,0))return null;if(O){N=function(h,b,I,g){const O=new Uint16Array(4),T=new Uint16Array(I*g),N=I/4,V=g/4;for(let M=0;M<V;M++)for(let g=0;g<N;g++){const V=b+8*(M*N+g);O[0]=h[V]|h[V+1]<<8,O[1]=h[V+2]|h[V+3]<<8,O[2]=(2*(31&O[0])+1*(31&O[1]))/3|(2*(2016&O[0])+1*(2016&O[1]))/3&2016|(2*(63488&O[0])+1*(63488&O[1]))/3&63488,O[3]=(2*(31&O[1])+1*(31&O[0]))/3|(2*(2016&O[1])+1*(2016&O[0]))/3&2016|(2*(63488&O[1])+1*(63488&O[0]))/3&63488;for(let b=0;b<4;b++){const N=h[V+4+b];let y=(4*M+b)*I+4*g;T[y++]=O[3&N],T[y++]=O[N>>2&3],T[y++]=O[N>>4&3],T[y++]=O[N>>6&3]}}return T}(N,0,h.getImageWidth(b,I)+3&-4,h.getImageHeight(b,I)+3&-4)}return N}onmessage=e=>{if("init"===e.data.action){if(e.data.url)try{importScripts(e.data.url)}catch(P){postMessage({action:"error",error:P})}y||(y=BASIS({wasmBinary:e.data.wasmBinary})),null!==y&&y.then((h=>{BASIS=h,h.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===e.data.action){const y=e.data.config,P=e.data.imageData,K=new BASIS.BasisFile(P),o=function(h){const b=h.getHasAlpha(),I=h.getNumImages(),g=[];for(let O=0;O<I;O++){const b={levels:[]},I=h.getNumLevels(O);for(let g=0;g<I;g++){const I={width:h.getImageWidth(O,g),height:h.getImageHeight(O,g)};b.levels.push(I)}g.push(b)}return{oe:b,images:g}}(K);let R=e.data.ignoreSupportedFormats?null:function(y,q){let e=null;y.supportedCompressionFormats&&(e=y.supportedCompressionFormats.astc?V:y.supportedCompressionFormats.bc7?O:y.supportedCompressionFormats.s3tc?q.oe?g:I:y.supportedCompressionFormats.pvrtc?q.oe?N:T:y.supportedCompressionFormats.etc2?b:y.supportedCompressionFormats.etc1?h:M);return e}(e.data.config,o),L=!1;null===R&&(L=!0,R=o.oe?g:I);let i=!0;K.startTranscoding()||(i=!1);const w=[];for(let h=0;h<o.images.length&&i;h++){const b=o.images[h];if(void 0===y.loadSingleImage||y.loadSingleImage===h){let I=b.levels.length;!1===y.loadMipmapLevels&&(I=1);for(let g=0;g<I;g++){const I=b.levels[g],O=q(K,h,g,R,L);if(!O){i=!1;break}I.transcodedPixels=O,w.push(I.transcodedPixels.buffer)}}}K.close(),K.delete(),L&&(R=-1),i?postMessage({action:"transcode",success:i,id:e.data.id,fileInfo:o,format:R},w):postMessage({action:"transcode",success:i,id:e.data.id})}}}!function(h){h[h.cTFETC1=0]="cTFETC1",h[h.cTFETC2=1]="cTFETC2",h[h.cTFBC1=2]="cTFBC1",h[h.cTFBC3=3]="cTFBC3",h[h.cTFBC4=4]="cTFBC4",h[h.cTFBC5=5]="cTFBC5",h[h.cTFBC7=6]="cTFBC7",h[h.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",h[h.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",h[h.cTFASTC_4x4=10]="cTFASTC_4x4",h[h.cTFATC_RGB=11]="cTFATC_RGB",h[h.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",h[h.cTFRGBA32=13]="cTFRGBA32",h[h.cTFRGB565=14]="cTFRGB565",h[h.cTFBGR565=15]="cTFBGR565",h[h.cTFRGBA4444=16]="cTFRGBA4444",h[h.cTFFXT1_RGB=17]="cTFFXT1_RGB",h[h.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",h[h.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",h[h.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",h[h.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(g||(g={}));const M={JSModuleURL:`${O.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${O.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let y=null,q=null,e=0;const P=()=>(y||(y=new Promise(((h,b)=>{q?h(q):O.c.LoadFileAsync(O.c.GetBabylonScriptURL(M.WasmModuleURL)).then((I=>{if("function"!==typeof URL)return b("Basis transcoder requires an environment with a URL constructor");const g=URL.createObjectURL(new Blob([`(${V})()`],{type:"application/javascript"}));q=new Worker(g),function(h,b,I){return new Promise(((g,T)=>{const N=b=>{"init"===b.data.action?(h.removeEventListener("message",N),g(h)):"error"===b.data.action&&T(b.data.error||"error initializing worker")};h.addEventListener("message",N),h.postMessage({action:"init",url:I?O.c.GetBabylonScriptURL(I):void 0,wasmBinary:b},[b])}))}(q,I,M.JSModuleURL).then(h,b)})).catch(b)}))),y),K=(h,b)=>{const I=h instanceof ArrayBuffer?new Uint8Array(h):h;return new Promise(((h,g)=>{P().then((()=>{const O=e++,T=b=>{"transcode"===b.data.action&&b.data.id===O&&(q.removeEventListener("message",T),b.data.success?h(b.data):g("Transcode is not supported on this device"))};q.addEventListener("message",T);const N=new Uint8Array(I.byteLength);N.set(new Uint8Array(I.buffer,I.byteOffset,I.byteLength)),q.postMessage({action:"transcode",id:O,imageData:N,config:b,ignoreSupportedFormats:false},[N.buffer])}),(h=>{g(h)}))}))},o=(h,b)=>{var I;let g=null===(I=b._gl)||void 0===I?void 0:I.TEXTURE_2D;var O;h.isCube&&(g=null===(O=b._gl)||void 0===O?void 0:O.TEXTURE_CUBE_MAP);b._bindTextureDirectly(g,h,!0)},R=(h,b)=>{const I=h.getEngine();for(let V=0;V<b.fileInfo.images.length;V++){const M=b.fileInfo.images[V].levels[0];if(h._invertVScale=h.invertY,-1===b.format||b.format===g.cTFRGB565)if(h.type=10,h.format=4,!I._features.basisNeedsPOT||Math.log2(M.width)%1===0&&Math.log2(M.height)%1===0)h._invertVScale=!h.invertY,h.width=M.width+3&-4,h.height=M.height+3&-4,h.samplingMode=2,o(h,I),I._uploadDataToTextureDirectly(h,new Uint16Array(M.transcodedPixels.buffer),V,0,4,!0);else{const b=new N.c(I,2);h._invertVScale=h.invertY,b.type=10,b.format=4,b.width=M.width+3&-4,b.height=M.height+3&-4,o(b,I),I._uploadDataToTextureDirectly(b,new Uint16Array(M.transcodedPixels.buffer),V,0,4,!0),I._rescaleTexture(b,h,I.scenes[0],I._getInternalFormat(4),(()=>{I._releaseTexture(b),o(h,I)}))}else{h.width=M.width,h.height=M.height,h.generateMipMaps=b.fileInfo.images[V].levels.length>1;const g=L.GetInternalFormatFromBasisFormat(b.format,I);h.format=g,o(h,I),b.fileInfo.images[V].levels.forEach(((b,O)=>{I._uploadCompressedDataToTextureDirectly(h,g,b.width,b.height,b.transcodedPixels,V,O)})),!I._features.basisNeedsPOT||Math.log2(h.width)%1===0&&Math.log2(h.height)%1===0||(O.c.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),h._cachedWrapU=T.c.CLAMP_ADDRESSMODE,h._cachedWrapV=T.c.CLAMP_ADDRESSMODE)}}},L={JSModuleURL:M.JSModuleURL,WasmModuleURL:M.WasmModuleURL,GetInternalFormatFromBasisFormat:(h,b)=>{let I;switch(h){case g.cTFETC1:I=36196;break;case g.cTFBC1:I=33776;break;case g.cTFBC4:I=33779;break;case g.cTFASTC_4x4:I=37808;break;case g.cTFETC2:I=37496;break;case g.cTFBC7:I=36492}if(void 0===I)throw"The chosen Basis transcoder format is not currently supported";return I},TranscodeAsync:K,LoadTextureFromTranscodeResult:R};Object.defineProperty(L,"JSModuleURL",{get:function(){return M.JSModuleURL},set:function(h){M.JSModuleURL=h}}),Object.defineProperty(L,"WasmModuleURL",{get:function(){return M.WasmModuleURL},set:function(h){M.WasmModuleURL=h}});class i{constructor(){this.supportCascades=!1}loadCubeData(h,b,I,g,T){if(Array.isArray(h))return;const N=b.getEngine().getCaps(),V={supportedCompressionFormats:{etc1:!!N.etc1,s3tc:!!N.s3tc,pvrtc:!!N.pvrtc,etc2:!!N.etc2,astc:!!N.astc,bc7:!!N.bptc}};K(h,V).then((h=>{const I=h.fileInfo.images[0].levels.length>1&&b.generateMipMaps;R(b,h),b.getEngine()._setCubeMapTextureParams(b,I),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),g&&g()})).catch((h=>{O.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),b.isReady=!0,T&&T(h)}))}loadData(h,b,I){const g=b.getEngine().getCaps(),T={supportedCompressionFormats:{etc1:!!g.etc1,s3tc:!!g.s3tc,pvrtc:!!g.pvrtc,etc2:!!g.etc2,astc:!!g.astc,bc7:!!g.bptc}};K(h,T).then((h=>{const g=h.fileInfo.images[0].levels[0],O=h.fileInfo.images[0].levels.length>1&&b.generateMipMaps;I(g.width,g.height,O,-1!==h.format,(()=>{R(b,h)}))})).catch((h=>{O.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),O.c.Warn(`Failed to transcode Basis file: ${h}`),I(0,0,!1,!1,(()=>{}),!0)}))}}}}]);