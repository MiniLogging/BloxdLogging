"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12771:(Z,J,E)=>{E.r(J),E.d(J,{_BasisTextureLoader:()=>K});var O,i=E(10899),Y=E(11397),C=E(11016);function d(){const Z=0,J=1,E=2,O=3,i=6,Y=8,C=9,d=10,z=14;let g=null;function A(Z,J,E,O,i){const Y=Z.getImageTranscodedSizeInBytes(J,E,O);let C=new Uint8Array(Y);if(!Z.transcodeImage(C,J,E,O,1,0))return null;if(i){C=function(Z,J,E,O){const i=new Uint16Array(4),Y=new Uint16Array(E*O),C=E/4,d=O/4;for(let z=0;z<d;z++)for(let O=0;O<C;O++){const d=J+8*(z*C+O);i[0]=Z[d]|Z[d+1]<<8,i[1]=Z[d+2]|Z[d+3]<<8,i[2]=(2*(31&i[0])+1*(31&i[1]))/3|(2*(2016&i[0])+1*(2016&i[1]))/3&2016|(2*(63488&i[0])+1*(63488&i[1]))/3&63488,i[3]=(2*(31&i[1])+1*(31&i[0]))/3|(2*(2016&i[1])+1*(2016&i[0]))/3&2016|(2*(63488&i[1])+1*(63488&i[0]))/3&63488;for(let J=0;J<4;J++){const C=Z[d+4+J];let g=(4*z+J)*E+4*O;Y[g++]=i[3&C],Y[g++]=i[C>>2&3],Y[g++]=i[C>>4&3],Y[g++]=i[C>>6&3]}}return Y}(C,0,Z.getImageWidth(J,E)+3&-4,Z.getImageHeight(J,E)+3&-4)}return C}onmessage=R=>{if("init"===R.data.action){if(R.data.url)try{importScripts(R.data.url)}catch(h){postMessage({action:"error",error:h})}g||(g=BASIS({wasmBinary:R.data.wasmBinary})),null!==g&&g.then((Z=>{BASIS=Z,Z.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===R.data.action){const g=R.data.config,h=R.data.imageData,L=new BASIS.BasisFile(h),v=function(Z){const J=Z.getHasAlpha(),E=Z.getNumImages(),O=[];for(let i=0;i<E;i++){const J={levels:[]},E=Z.getNumLevels(i);for(let O=0;O<E;O++){const E={width:Z.getImageWidth(i,O),height:Z.getImageHeight(i,O)};J.levels.push(E)}O.push(J)}return{fe:J,images:O}}(L);let X=R.data.ignoreSupportedFormats?null:function(g,A){let R=null;g.supportedCompressionFormats&&(R=g.supportedCompressionFormats.astc?d:g.supportedCompressionFormats.bc7?i:g.supportedCompressionFormats.s3tc?A.fe?O:E:g.supportedCompressionFormats.pvrtc?A.fe?C:Y:g.supportedCompressionFormats.etc2?J:g.supportedCompressionFormats.etc1?Z:z);return R}(R.data.config,v),l=!1;null===X&&(l=!0,X=v.fe?O:E);let K=!0;L.startTranscoding()||(K=!1);const T=[];for(let Z=0;Z<v.images.length&&K;Z++){const J=v.images[Z];if(void 0===g.loadSingleImage||g.loadSingleImage===Z){let E=J.levels.length;!1===g.loadMipmapLevels&&(E=1);for(let O=0;O<E;O++){const E=J.levels[O],i=A(L,Z,O,X,l);if(!i){K=!1;break}E.transcodedPixels=i,T.push(E.transcodedPixels.buffer)}}}L.close(),L.delete(),l&&(X=-1),K?postMessage({action:"transcode",success:K,id:R.data.id,fileInfo:v,format:X},T):postMessage({action:"transcode",success:K,id:R.data.id})}}}!function(Z){Z[Z.cTFETC1=0]="cTFETC1",Z[Z.cTFETC2=1]="cTFETC2",Z[Z.cTFBC1=2]="cTFBC1",Z[Z.cTFBC3=3]="cTFBC3",Z[Z.cTFBC4=4]="cTFBC4",Z[Z.cTFBC5=5]="cTFBC5",Z[Z.cTFBC7=6]="cTFBC7",Z[Z.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Z[Z.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Z[Z.cTFASTC_4x4=10]="cTFASTC_4x4",Z[Z.cTFATC_RGB=11]="cTFATC_RGB",Z[Z.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Z[Z.cTFRGBA32=13]="cTFRGBA32",Z[Z.cTFRGB565=14]="cTFRGB565",Z[Z.cTFBGR565=15]="cTFBGR565",Z[Z.cTFRGBA4444=16]="cTFRGBA4444",Z[Z.cTFFXT1_RGB=17]="cTFFXT1_RGB",Z[Z.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Z[Z.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Z[Z.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Z[Z.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(O||(O={}));const z={JSModuleURL:`${i.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${i.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let g=null,A=null,R=0;const h=()=>(g||(g=new Promise(((Z,J)=>{A?Z(A):i.f.LoadFileAsync(i.f.GetBabylonScriptURL(z.WasmModuleURL)).then((E=>{if("function"!==typeof URL)return J("Basis transcoder requires an environment with a URL constructor");const O=URL.createObjectURL(new Blob([`(${d})()`],{type:"application/javascript"}));A=new Worker(O),function(Z,J,E){return new Promise(((O,Y)=>{const C=J=>{"init"===J.data.action?(Z.removeEventListener("message",C),O(Z)):"error"===J.data.action&&Y(J.data.error||"error initializing worker")};Z.addEventListener("message",C),Z.postMessage({action:"init",url:E?i.f.GetBabylonScriptURL(E):void 0,wasmBinary:J},[J])}))}(A,E,z.JSModuleURL).then(Z,J)})).catch(J)}))),g),L=(Z,J)=>{const E=Z instanceof ArrayBuffer?new Uint8Array(Z):Z;return new Promise(((Z,O)=>{h().then((()=>{const i=R++,Y=J=>{"transcode"===J.data.action&&J.data.id===i&&(A.removeEventListener("message",Y),J.data.success?Z(J.data):O("Transcode is not supported on this device"))};A.addEventListener("message",Y);const C=new Uint8Array(E.byteLength);C.set(new Uint8Array(E.buffer,E.byteOffset,E.byteLength)),A.postMessage({action:"transcode",id:i,imageData:C,config:J,ignoreSupportedFormats:false},[C.buffer])}),(Z=>{O(Z)}))}))},v=(Z,J)=>{var E;let O=null===(E=J._gl)||void 0===E?void 0:E.TEXTURE_2D;var i;Z.isCube&&(O=null===(i=J._gl)||void 0===i?void 0:i.TEXTURE_CUBE_MAP);J._bindTextureDirectly(O,Z,!0)},X=(Z,J)=>{const E=Z.getEngine();for(let d=0;d<J.fileInfo.images.length;d++){const z=J.fileInfo.images[d].levels[0];if(Z._invertVScale=Z.invertY,-1===J.format||J.format===O.cTFRGB565)if(Z.type=10,Z.format=4,!E._features.basisNeedsPOT||Math.log2(z.width)%1===0&&Math.log2(z.height)%1===0)Z._invertVScale=!Z.invertY,Z.width=z.width+3&-4,Z.height=z.height+3&-4,Z.samplingMode=2,v(Z,E),E._uploadDataToTextureDirectly(Z,new Uint16Array(z.transcodedPixels.buffer),d,0,4,!0);else{const J=new C.c(E,2);Z._invertVScale=Z.invertY,J.type=10,J.format=4,J.width=z.width+3&-4,J.height=z.height+3&-4,v(J,E),E._uploadDataToTextureDirectly(J,new Uint16Array(z.transcodedPixels.buffer),d,0,4,!0),E._rescaleTexture(J,Z,E.scenes[0],E._getInternalFormat(4),(()=>{E._releaseTexture(J),v(Z,E)}))}else{Z.width=z.width,Z.height=z.height,Z.generateMipMaps=J.fileInfo.images[d].levels.length>1;const O=l.GetInternalFormatFromBasisFormat(J.format,E);Z.format=O,v(Z,E),J.fileInfo.images[d].levels.forEach(((J,i)=>{E._uploadCompressedDataToTextureDirectly(Z,O,J.width,J.height,J.transcodedPixels,d,i)})),!E._features.basisNeedsPOT||Math.log2(Z.width)%1===0&&Math.log2(Z.height)%1===0||(i.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Z._cachedWrapU=Y.b.CLAMP_ADDRESSMODE,Z._cachedWrapV=Y.b.CLAMP_ADDRESSMODE)}}},l={JSModuleURL:z.JSModuleURL,WasmModuleURL:z.WasmModuleURL,GetInternalFormatFromBasisFormat:(Z,J)=>{let E;switch(Z){case O.cTFETC1:E=36196;break;case O.cTFBC1:E=33776;break;case O.cTFBC4:E=33779;break;case O.cTFASTC_4x4:E=37808;break;case O.cTFETC2:E=37496;break;case O.cTFBC7:E=36492}if(void 0===E)throw"The chosen Basis transcoder format is not currently supported";return E},TranscodeAsync:L,LoadTextureFromTranscodeResult:X};Object.defineProperty(l,"JSModuleURL",{get:function(){return z.JSModuleURL},set:function(Z){z.JSModuleURL=Z}}),Object.defineProperty(l,"WasmModuleURL",{get:function(){return z.WasmModuleURL},set:function(Z){z.WasmModuleURL=Z}});class K{constructor(){this.supportCascades=!1}loadCubeData(Z,J,E,O,Y){if(Array.isArray(Z))return;const C=J.getEngine().getCaps(),d={supportedCompressionFormats:{etc1:!!C.etc1,s3tc:!!C.s3tc,pvrtc:!!C.pvrtc,etc2:!!C.etc2,astc:!!C.astc,bc7:!!C.bptc}};L(Z,d).then((Z=>{const E=Z.fileInfo.images[0].levels.length>1&&J.generateMipMaps;X(J,Z),J.getEngine()._setCubeMapTextureParams(J,E),J.isReady=!0,J.onLoadedObservable.notifyObservers(J),J.onLoadedObservable.clear(),O&&O()})).catch((Z=>{i.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),J.isReady=!0,Y&&Y(Z)}))}loadData(Z,J,E){const O=J.getEngine().getCaps(),Y={supportedCompressionFormats:{etc1:!!O.etc1,s3tc:!!O.s3tc,pvrtc:!!O.pvrtc,etc2:!!O.etc2,astc:!!O.astc,bc7:!!O.bptc}};L(Z,Y).then((Z=>{const O=Z.fileInfo.images[0].levels[0],i=Z.fileInfo.images[0].levels.length>1&&J.generateMipMaps;E(O.width,O.height,i,-1!==Z.format,(()=>{X(J,Z)}))})).catch((Z=>{i.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),i.f.Warn(`Failed to transcode Basis file: ${Z}`),E(0,0,!1,!1,(()=>{}),!0)}))}}}}]);