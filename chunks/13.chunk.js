"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12618:(K,b,e)=>{e.r(b),e.d(b,{_BasisTextureLoader:()=>D});var z,k=e(10686),j=e(11161),T=e(10780);function F(){const K=0,b=1,e=2,z=3,k=6,j=8,T=9,F=10,l=14;let Y=null;function A(K,b,e,z,k){const j=K.getImageTranscodedSizeInBytes(b,e,z);let T=new Uint8Array(j);if(!K.transcodeImage(T,b,e,z,1,0))return null;if(k){T=function(K,b,e,z){const k=new Uint16Array(4),j=new Uint16Array(e*z),T=e/4,F=z/4;for(let l=0;l<F;l++)for(let z=0;z<T;z++){const F=b+8*(l*T+z);k[0]=K[F]|K[F+1]<<8,k[1]=K[F+2]|K[F+3]<<8,k[2]=(2*(31&k[0])+1*(31&k[1]))/3|(2*(2016&k[0])+1*(2016&k[1]))/3&2016|(2*(63488&k[0])+1*(63488&k[1]))/3&63488,k[3]=(2*(31&k[1])+1*(31&k[0]))/3|(2*(2016&k[1])+1*(2016&k[0]))/3&2016|(2*(63488&k[1])+1*(63488&k[0]))/3&63488;for(let b=0;b<4;b++){const T=K[F+4+b];let Y=(4*l+b)*e+4*z;j[Y++]=k[3&T],j[Y++]=k[T>>2&3],j[Y++]=k[T>>4&3],j[Y++]=k[T>>6&3]}}return j}(T,0,K.getImageWidth(b,e)+3&-4,K.getImageHeight(b,e)+3&-4)}return T}onmessage=X=>{if("init"===X.data.action){if(X.data.url)try{importScripts(X.data.url)}catch(t){postMessage({action:"error",error:t})}Y||(Y=BASIS({wasmBinary:X.data.wasmBinary})),null!==Y&&Y.then((K=>{BASIS=K,K.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===X.data.action){const Y=X.data.config,t=X.data.imageData,U=new BASIS.BasisFile(t),B=function(K){const b=K.getHasAlpha(),e=K.getNumImages(),z=[];for(let k=0;k<e;k++){const b={levels:[]},e=K.getNumLevels(k);for(let z=0;z<e;z++){const e={width:K.getImageWidth(k,z),height:K.getImageHeight(k,z)};b.levels.push(e)}z.push(b)}return{ke:b,images:z}}(U);let u=X.data.ignoreSupportedFormats?null:function(Y,A){let X=null;Y.supportedCompressionFormats&&(X=Y.supportedCompressionFormats.astc?F:Y.supportedCompressionFormats.bc7?k:Y.supportedCompressionFormats.s3tc?A.ke?z:e:Y.supportedCompressionFormats.pvrtc?A.ke?T:j:Y.supportedCompressionFormats.etc2?b:Y.supportedCompressionFormats.etc1?K:l);return X}(X.data.config,B),m=!1;null===u&&(m=!0,u=B.ke?z:e);let D=!0;U.startTranscoding()||(D=!1);const I=[];for(let K=0;K<B.images.length&&D;K++){const b=B.images[K];if(void 0===Y.loadSingleImage||Y.loadSingleImage===K){let e=b.levels.length;!1===Y.loadMipmapLevels&&(e=1);for(let z=0;z<e;z++){const e=b.levels[z],k=A(U,K,z,u,m);if(!k){D=!1;break}e.transcodedPixels=k,I.push(e.transcodedPixels.buffer)}}}U.close(),U.delete(),m&&(u=-1),D?postMessage({action:"transcode",success:D,id:X.data.id,fileInfo:B,format:u},I):postMessage({action:"transcode",success:D,id:X.data.id})}}}!function(K){K[K.cTFETC1=0]="cTFETC1",K[K.cTFETC2=1]="cTFETC2",K[K.cTFBC1=2]="cTFBC1",K[K.cTFBC3=3]="cTFBC3",K[K.cTFBC4=4]="cTFBC4",K[K.cTFBC5=5]="cTFBC5",K[K.cTFBC7=6]="cTFBC7",K[K.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",K[K.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",K[K.cTFASTC_4x4=10]="cTFASTC_4x4",K[K.cTFATC_RGB=11]="cTFATC_RGB",K[K.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",K[K.cTFRGBA32=13]="cTFRGBA32",K[K.cTFRGB565=14]="cTFRGB565",K[K.cTFBGR565=15]="cTFBGR565",K[K.cTFRGBA4444=16]="cTFRGBA4444",K[K.cTFFXT1_RGB=17]="cTFFXT1_RGB",K[K.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",K[K.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",K[K.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",K[K.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(z||(z={}));const l={JSModuleURL:`${k.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${k.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let Y=null,A=null,X=0;const t=()=>(Y||(Y=new Promise(((K,b)=>{A?K(A):k.f.LoadFileAsync(k.f.GetBabylonScriptURL(l.WasmModuleURL)).then((e=>{if("function"!==typeof URL)return b("Basis transcoder requires an environment with a URL constructor");const z=URL.createObjectURL(new Blob([`(${F})()`],{type:"application/javascript"}));A=new Worker(z),function(K,b,e){return new Promise(((z,j)=>{const T=b=>{"init"===b.data.action?(K.removeEventListener("message",T),z(K)):"error"===b.data.action&&j(b.data.error||"error initializing worker")};K.addEventListener("message",T),K.postMessage({action:"init",url:e?k.f.GetBabylonScriptURL(e):void 0,wasmBinary:b},[b])}))}(A,e,l.JSModuleURL).then(K,b)})).catch(b)}))),Y),U=(K,b)=>{const e=K instanceof ArrayBuffer?new Uint8Array(K):K;return new Promise(((K,z)=>{t().then((()=>{const k=X++,j=b=>{"transcode"===b.data.action&&b.data.id===k&&(A.removeEventListener("message",j),b.data.success?K(b.data):z("Transcode is not supported on this device"))};A.addEventListener("message",j);const T=new Uint8Array(e.byteLength);T.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),A.postMessage({action:"transcode",id:k,imageData:T,config:b,ignoreSupportedFormats:false},[T.buffer])}),(K=>{z(K)}))}))},B=(K,b)=>{var e;let z=null===(e=b._gl)||void 0===e?void 0:e.TEXTURE_2D;var k;K.isCube&&(z=null===(k=b._gl)||void 0===k?void 0:k.TEXTURE_CUBE_MAP);b._bindTextureDirectly(z,K,!0)},u=(K,b)=>{const e=K.getEngine();for(let F=0;F<b.fileInfo.images.length;F++){const l=b.fileInfo.images[F].levels[0];if(K._invertVScale=K.invertY,-1===b.format||b.format===z.cTFRGB565)if(K.type=10,K.format=4,!e._features.basisNeedsPOT||Math.log2(l.width)%1===0&&Math.log2(l.height)%1===0)K._invertVScale=!K.invertY,K.width=l.width+3&-4,K.height=l.height+3&-4,K.samplingMode=2,B(K,e),e._uploadDataToTextureDirectly(K,new Uint16Array(l.transcodedPixels.buffer),F,0,4,!0);else{const b=new T.e(e,2);K._invertVScale=K.invertY,b.type=10,b.format=4,b.width=l.width+3&-4,b.height=l.height+3&-4,B(b,e),e._uploadDataToTextureDirectly(b,new Uint16Array(l.transcodedPixels.buffer),F,0,4,!0),e._rescaleTexture(b,K,e.scenes[0],e._getInternalFormat(4),(()=>{e._releaseTexture(b),B(K,e)}))}else{K.width=l.width,K.height=l.height,K.generateMipMaps=b.fileInfo.images[F].levels.length>1;const z=m.GetInternalFormatFromBasisFormat(b.format,e);K.format=z,B(K,e),b.fileInfo.images[F].levels.forEach(((b,k)=>{e._uploadCompressedDataToTextureDirectly(K,z,b.width,b.height,b.transcodedPixels,F,k)})),!e._features.basisNeedsPOT||Math.log2(K.width)%1===0&&Math.log2(K.height)%1===0||(k.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),K._cachedWrapU=j.c.CLAMP_ADDRESSMODE,K._cachedWrapV=j.c.CLAMP_ADDRESSMODE)}}},m={JSModuleURL:l.JSModuleURL,WasmModuleURL:l.WasmModuleURL,GetInternalFormatFromBasisFormat:(K,b)=>{let e;switch(K){case z.cTFETC1:e=36196;break;case z.cTFBC1:e=33776;break;case z.cTFBC4:e=33779;break;case z.cTFASTC_4x4:e=37808;break;case z.cTFETC2:e=37496;break;case z.cTFBC7:e=36492}if(void 0===e)throw"The chosen Basis transcoder format is not currently supported";return e},TranscodeAsync:U,LoadTextureFromTranscodeResult:u};Object.defineProperty(m,"JSModuleURL",{get:function(){return l.JSModuleURL},set:function(K){l.JSModuleURL=K}}),Object.defineProperty(m,"WasmModuleURL",{get:function(){return l.WasmModuleURL},set:function(K){l.WasmModuleURL=K}});class D{constructor(){this.supportCascades=!1}loadCubeData(K,b,e,z,j){if(Array.isArray(K))return;const T=b.getEngine().getCaps(),F={supportedCompressionFormats:{etc1:!!T.etc1,s3tc:!!T.s3tc,pvrtc:!!T.pvrtc,etc2:!!T.etc2,astc:!!T.astc,bc7:!!T.bptc}};U(K,F).then((K=>{const e=K.fileInfo.images[0].levels.length>1&&b.generateMipMaps;u(b,K),b.getEngine()._setCubeMapTextureParams(b,e),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),z&&z()})).catch((K=>{k.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),b.isReady=!0,j&&j(K)}))}loadData(K,b,e){const z=b.getEngine().getCaps(),j={supportedCompressionFormats:{etc1:!!z.etc1,s3tc:!!z.s3tc,pvrtc:!!z.pvrtc,etc2:!!z.etc2,astc:!!z.astc,bc7:!!z.bptc}};U(K,j).then((K=>{const z=K.fileInfo.images[0].levels[0],k=K.fileInfo.images[0].levels.length>1&&b.generateMipMaps;e(z.width,z.height,k,-1!==K.format,(()=>{u(b,K)}))})).catch((K=>{k.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),k.f.Warn(`Failed to transcode Basis file: ${K}`),e(0,0,!1,!1,(()=>{}),!0)}))}}}}]);