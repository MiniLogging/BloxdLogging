"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[13],{12835:(E,b,h)=>{h.r(b),h.d(b,{_BasisTextureLoader:()=>S});var a,k=h(10821),G=h(11376),V=h(10939);function l(){const E=0,b=1,h=2,a=3,k=6,G=8,V=9,l=10,O=14;let v=null;function s(E,b,h,a,k){const G=E.getImageTranscodedSizeInBytes(b,h,a);let V=new Uint8Array(G);if(!E.transcodeImage(V,b,h,a,1,0))return null;if(k){V=function(E,b,h,a){const k=new Uint16Array(4),G=new Uint16Array(h*a),V=h/4,l=a/4;for(let O=0;O<l;O++)for(let a=0;a<V;a++){const l=b+8*(O*V+a);k[0]=E[l]|E[l+1]<<8,k[1]=E[l+2]|E[l+3]<<8,k[2]=(2*(31&k[0])+1*(31&k[1]))/3|(2*(2016&k[0])+1*(2016&k[1]))/3&2016|(2*(63488&k[0])+1*(63488&k[1]))/3&63488,k[3]=(2*(31&k[1])+1*(31&k[0]))/3|(2*(2016&k[1])+1*(2016&k[0]))/3&2016|(2*(63488&k[1])+1*(63488&k[0]))/3&63488;for(let b=0;b<4;b++){const V=E[l+4+b];let v=(4*O+b)*h+4*a;G[v++]=k[3&V],G[v++]=k[V>>2&3],G[v++]=k[V>>4&3],G[v++]=k[V>>6&3]}}return G}(V,0,E.getImageWidth(b,h)+3&-4,E.getImageHeight(b,h)+3&-4)}return V}onmessage=U=>{if("init"===U.data.action){if(U.data.url)try{importScripts(U.data.url)}catch(B){postMessage({action:"error",error:B})}v||(v=BASIS({wasmBinary:U.data.wasmBinary})),null!==v&&v.then((E=>{BASIS=E,E.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===U.data.action){const v=U.data.config,B=U.data.imageData,o=new BASIS.BasisFile(B),u=function(E){const b=E.getHasAlpha(),h=E.getNumImages(),a=[];for(let k=0;k<h;k++){const b={levels:[]},h=E.getNumLevels(k);for(let a=0;a<h;a++){const h={width:E.getImageWidth(k,a),height:E.getImageHeight(k,a)};b.levels.push(h)}a.push(b)}return{Ie:b,images:a}}(o);let D=U.data.ignoreSupportedFormats?null:function(v,s){let U=null;v.supportedCompressionFormats&&(U=v.supportedCompressionFormats.astc?l:v.supportedCompressionFormats.bc7?k:v.supportedCompressionFormats.s3tc?s.Ie?a:h:v.supportedCompressionFormats.pvrtc?s.Ie?V:G:v.supportedCompressionFormats.etc2?b:v.supportedCompressionFormats.etc1?E:O);return U}(U.data.config,u),g=!1;null===D&&(g=!0,D=u.Ie?a:h);let S=!0;o.startTranscoding()||(S=!1);const M=[];for(let E=0;E<u.images.length&&S;E++){const b=u.images[E];if(void 0===v.loadSingleImage||v.loadSingleImage===E){let h=b.levels.length;!1===v.loadMipmapLevels&&(h=1);for(let a=0;a<h;a++){const h=b.levels[a],k=s(o,E,a,D,g);if(!k){S=!1;break}h.transcodedPixels=k,M.push(h.transcodedPixels.buffer)}}}o.close(),o.delete(),g&&(D=-1),S?postMessage({action:"transcode",success:S,id:U.data.id,fileInfo:u,format:D},M):postMessage({action:"transcode",success:S,id:U.data.id})}}}!function(E){E[E.cTFETC1=0]="cTFETC1",E[E.cTFETC2=1]="cTFETC2",E[E.cTFBC1=2]="cTFBC1",E[E.cTFBC3=3]="cTFBC3",E[E.cTFBC4=4]="cTFBC4",E[E.cTFBC5=5]="cTFBC5",E[E.cTFBC7=6]="cTFBC7",E[E.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",E[E.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",E[E.cTFASTC_4x4=10]="cTFASTC_4x4",E[E.cTFATC_RGB=11]="cTFATC_RGB",E[E.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",E[E.cTFRGBA32=13]="cTFRGBA32",E[E.cTFRGB565=14]="cTFRGB565",E[E.cTFBGR565=15]="cTFBGR565",E[E.cTFRGBA4444=16]="cTFRGBA4444",E[E.cTFFXT1_RGB=17]="cTFFXT1_RGB",E[E.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",E[E.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",E[E.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",E[E.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(a||(a={}));const O={JSModuleURL:`${k.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${k.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let v=null,s=null,U=0;const B=()=>(v||(v=new Promise(((E,b)=>{s?E(s):k.g.LoadFileAsync(k.g.GetBabylonScriptURL(O.WasmModuleURL)).then((h=>{if("function"!==typeof URL)return b("Basis transcoder requires an environment with a URL constructor");const a=URL.createObjectURL(new Blob([`(${l})()`],{type:"application/javascript"}));s=new Worker(a),function(E,b,h){return new Promise(((a,G)=>{const V=b=>{"init"===b.data.action?(E.removeEventListener("message",V),a(E)):"error"===b.data.action&&G(b.data.error||"error initializing worker")};E.addEventListener("message",V),E.postMessage({action:"init",url:h?k.g.GetBabylonScriptURL(h):void 0,wasmBinary:b},[b])}))}(s,h,O.JSModuleURL).then(E,b)})).catch(b)}))),v),o=(E,b)=>{const h=E instanceof ArrayBuffer?new Uint8Array(E):E;return new Promise(((E,a)=>{B().then((()=>{const k=U++,G=b=>{"transcode"===b.data.action&&b.data.id===k&&(s.removeEventListener("message",G),b.data.success?E(b.data):a("Transcode is not supported on this device"))};s.addEventListener("message",G);const V=new Uint8Array(h.byteLength);V.set(new Uint8Array(h.buffer,h.byteOffset,h.byteLength)),s.postMessage({action:"transcode",id:k,imageData:V,config:b,ignoreSupportedFormats:false},[V.buffer])}),(E=>{a(E)}))}))},u=(E,b)=>{var h;let a=null===(h=b._gl)||void 0===h?void 0:h.TEXTURE_2D;var k;E.isCube&&(a=null===(k=b._gl)||void 0===k?void 0:k.TEXTURE_CUBE_MAP);b._bindTextureDirectly(a,E,!0)},D=(E,b)=>{const h=E.getEngine();for(let l=0;l<b.fileInfo.images.length;l++){const O=b.fileInfo.images[l].levels[0];if(E._invertVScale=E.invertY,-1===b.format||b.format===a.cTFRGB565)if(E.type=10,E.format=4,!h._features.basisNeedsPOT||Math.log2(O.width)%1===0&&Math.log2(O.height)%1===0)E._invertVScale=!E.invertY,E.width=O.width+3&-4,E.height=O.height+3&-4,E.samplingMode=2,u(E,h),h._uploadDataToTextureDirectly(E,new Uint16Array(O.transcodedPixels.buffer),l,0,4,!0);else{const b=new V.b(h,2);E._invertVScale=E.invertY,b.type=10,b.format=4,b.width=O.width+3&-4,b.height=O.height+3&-4,u(b,h),h._uploadDataToTextureDirectly(b,new Uint16Array(O.transcodedPixels.buffer),l,0,4,!0),h._rescaleTexture(b,E,h.scenes[0],h._getInternalFormat(4),(()=>{h._releaseTexture(b),u(E,h)}))}else{E.width=O.width,E.height=O.height,E.generateMipMaps=b.fileInfo.images[l].levels.length>1;const a=g.GetInternalFormatFromBasisFormat(b.format,h);E.format=a,u(E,h),b.fileInfo.images[l].levels.forEach(((b,k)=>{h._uploadCompressedDataToTextureDirectly(E,a,b.width,b.height,b.transcodedPixels,l,k)})),!h._features.basisNeedsPOT||Math.log2(E.width)%1===0&&Math.log2(E.height)%1===0||(k.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),E._cachedWrapU=G.b.CLAMP_ADDRESSMODE,E._cachedWrapV=G.b.CLAMP_ADDRESSMODE)}}},g={JSModuleURL:O.JSModuleURL,WasmModuleURL:O.WasmModuleURL,GetInternalFormatFromBasisFormat:(E,b)=>{let h;switch(E){case a.cTFETC1:h=36196;break;case a.cTFBC1:h=33776;break;case a.cTFBC4:h=33779;break;case a.cTFASTC_4x4:h=37808;break;case a.cTFETC2:h=37496;break;case a.cTFBC7:h=36492}if(void 0===h)throw"The chosen Basis transcoder format is not currently supported";return h},TranscodeAsync:o,LoadTextureFromTranscodeResult:D};Object.defineProperty(g,"JSModuleURL",{get:function(){return O.JSModuleURL},set:function(E){O.JSModuleURL=E}}),Object.defineProperty(g,"WasmModuleURL",{get:function(){return O.WasmModuleURL},set:function(E){O.WasmModuleURL=E}});class S{constructor(){this.supportCascades=!1}loadCubeData(E,b,h,a,G){if(Array.isArray(E))return;const V=b.getEngine().getCaps(),l={supportedCompressionFormats:{etc1:!!V.etc1,s3tc:!!V.s3tc,pvrtc:!!V.pvrtc,etc2:!!V.etc2,astc:!!V.astc,bc7:!!V.bptc}};o(E,l).then((E=>{const h=E.fileInfo.images[0].levels.length>1&&b.generateMipMaps;D(b,E),b.getEngine()._setCubeMapTextureParams(b,h),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),a&&a()})).catch((E=>{k.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),b.isReady=!0,G&&G(E)}))}loadData(E,b,h){const a=b.getEngine().getCaps(),G={supportedCompressionFormats:{etc1:!!a.etc1,s3tc:!!a.s3tc,pvrtc:!!a.pvrtc,etc2:!!a.etc2,astc:!!a.astc,bc7:!!a.bptc}};o(E,G).then((E=>{const a=E.fileInfo.images[0].levels[0],k=E.fileInfo.images[0].levels.length>1&&b.generateMipMaps;h(a.width,a.height,k,-1!==E.format,(()=>{D(b,E)}))})).catch((E=>{k.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),k.g.Warn(`Failed to transcode Basis file: ${E}`),h(0,0,!1,!1,(()=>{}),!0)}))}}}}]);