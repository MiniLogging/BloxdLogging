"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[93],{14976:(F,P,f)=>{f.r(P),f.d(P,{FlowGraphJsonPointerParserBlock:()=>u});var c=f(13258),N=f(13265);const q=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class H{constructor(F,P){this.path=F,this.ownerBlock=P,this.templatedInputs=[];let f=q.exec(F);const H=new Set;for(;f;){const[,A]=f;if(H.has(A))throw new Error("Duplicate template variable detected.");H.add(A),this.templatedInputs.push(P.registerDataInput(A,N.h,new c.b(0))),f=q.exec(F)}}getAccessor(F,P){let f=this.path;for(const c of this.templatedInputs){const F=c.getValue(P).value;if("number"!==typeof F||F<0)throw new Error("Invalid value for templated input.");f=f.replace(`{${c.name}}`,F.toString())}return F.convert(f)}}var A=f(11587),o=f(11639),j=f(11690),i=f(14843);class u extends i.c{constructor(F){super(N.c,F),this.config=F,this.object=this.registerDataOutput("object",N.c),this.propertyName=this.registerDataOutput("propertyName",N.c),this.setterFunction=this.registerDataOutput("setFunction",N.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",N.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",N.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new H(F.jsonPointer,this)}_doOperation(F){var P,f,c;const N=this.templateComponent.getAccessor(this.config.pathConverter,F),q=N.info.get(N.object),H=null===(P=(f=N.info).getTarget)||void 0===P?void 0:P.call(f,N.object),A=null===(c=N.info.getPropertyName)||void 0===c?void 0:c[0](N.object);if(!H)throw new Error("Object is undefined");return this.object.setValue(H,F),A&&this.propertyName.setValue(A,F),q}_setPropertyValue(F,P,f,c){var N,q;const H=this.templateComponent.getAccessor(this.config.pathConverter,c),A=H.info.type;A.startsWith("Color")&&(f=T(f,A)),null===(N=(q=H.info).set)||void 0===N||N.call(q,f,H.object)}_getPropertyValue(F,P,f){const c=this.templateComponent.getAccessor(this.config.pathConverter,f),N=c.info.type,q=c.info.get(c.object);return N.startsWith("Color")?function(F){if(F instanceof j.BP)return new o.tP(F.r,F.g,F.b);if(F instanceof j.qc)return new o.Vector4(F.r,F.g,F.b,F.a);throw new Error("Invalid color type")}(q):q}_getInterpolationAnimationPropertyInfo(F,P,f){const c=this.templateComponent.getAccessor(this.config.pathConverter,f);return(F,P,f,N)=>{var q;const H=[],A=c.info.type;return A.startsWith("Color")&&(F=F.map((F=>({frame:F.frame,value:T(F.value,A)})))),null===(q=c.info.interpolation)||void 0===q||q.forEach(((P,q)=>{var A;const o=(null===(A=c.info.getPropertyName)||void 0===A?void 0:A[q](c.object))||"Animation-interpolation-"+q;let j=F;f!==P.type&&(j=F.map((F=>({frame:F.frame,value:P.getValue(void 0,F.value.pf?F.value.pf():[F.value],0,1)}))));const i=P.buildAnimations(c.object,o,60,j);for(const F of i)N&&F.babylonAnimation.setEasingFunction(N),H.push(F.babylonAnimation)})),H}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function T(F,P){return F.getClassName().startsWith("Color")?F:"BP"===P?new j.BP(F.x,F.y,F.z):"qc"===P?new j.qc(F.x,F.y,F.z,F.w):F}(0,A.f)("FlowGraphJsonPointerParserBlock",u)},14843:(F,P,f)=>{f.d(P,{c:()=>A});var c=f(13287),N=f(13265);const q="cachedOperationValue",H="cachedExecutionId";class A extends c.c{constructor(F,P){super(P),this.value=this.registerDataOutput("value",F),this.isValid=this.registerDataOutput("isValid",N.g)}_updateOutputs(F){const P=F._getExecutionVariable(this,H,-1),f=F._getExecutionVariable(this,q,null);if(void 0!==f&&null!==f&&P===F.executionId)this.isValid.setValue(!0,F),this.value.setValue(f,F);else try{const P=this._doOperation(F);if(void 0===P||null===P)return void this.isValid.setValue(!1,F);F._setExecutionVariable(this,q,P),F._setExecutionVariable(this,H,F.executionId),this.value.setValue(P,F),this.isValid.setValue(!0,F)}catch(c){this.isValid.setValue(!1,F)}}}}}]);