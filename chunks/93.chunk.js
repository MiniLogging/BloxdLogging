"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[93],{14561:(B,I,C)=>{C.r(I),C.d(I,{FlowGraphJsonPointerParserBlock:()=>R});var M=C(12895),x=C(12901);const y=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class f{constructor(B,I){this.path=B,this.ownerBlock=I,this.templatedInputs=[];let C=y.exec(B);const f=new Set;for(;C;){const[,L]=C;if(f.has(L))throw new Error("Duplicate template variable detected.");f.add(L),this.templatedInputs.push(I.registerDataInput(L,x.f,new M.b(0))),C=y.exec(B)}}getAccessor(B,I){let C=this.path;for(const M of this.templatedInputs){const B=M.getValue(I).value;if("number"!==typeof B||B<0)throw new Error("Invalid value for templated input.");C=C.replace(`{${M.name}}`,B.toString())}return B.convert(C)}}var L=C(11149),e=C(11194),g=C(11239),N=C(14408);class R extends N.b{constructor(B){super(x.b,B),this.config=B,this.object=this.registerDataOutput("object",x.b),this.propertyName=this.registerDataOutput("propertyName",x.b),this.setterFunction=this.registerDataOutput("setFunction",x.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",x.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",x.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new f(B.jsonPointer,this)}_doOperation(B){var I,C,M;const x=this.templateComponent.getAccessor(this.config.pathConverter,B),y=x.info.get(x.object),f=null===(I=(C=x.info).getTarget)||void 0===I?void 0:I.call(C,x.object),L=null===(M=x.info.getPropertyName)||void 0===M?void 0:M[0](x.object);if(!f)throw new Error("Object is undefined");return this.object.setValue(f,B),L&&this.propertyName.setValue(L,B),y}_setPropertyValue(B,I,C,M){var x,y;const f=this.templateComponent.getAccessor(this.config.pathConverter,M),L=f.info.type;L.startsWith("Color")&&(C=H(C,L)),null===(x=(y=f.info).set)||void 0===x||x.call(y,C,f.object)}_getPropertyValue(B,I,C){const M=this.templateComponent.getAccessor(this.config.pathConverter,C),x=M.info.type,y=M.info.get(M.object);return x.startsWith("Color")?function(B){if(B instanceof g.SI)return new e.HI(B.r,B.g,B.b);if(B instanceof g.Pf)return new e.Vector4(B.r,B.g,B.b,B.a);throw new Error("Invalid color type")}(y):y}_getInterpolationAnimationPropertyInfo(B,I,C){const M=this.templateComponent.getAccessor(this.config.pathConverter,C);return(B,I,C,x)=>{var y;const f=[],L=M.info.type;return L.startsWith("Color")&&(B=B.map((B=>({frame:B.frame,value:H(B.value,L)})))),null===(y=M.info.interpolation)||void 0===y||y.forEach(((I,y)=>{var L;const e=(null===(L=M.info.getPropertyName)||void 0===L?void 0:L[y](M.object))||"Animation-interpolation-"+y;let g=B;C!==I.type&&(g=B.map((B=>({frame:B.frame,value:I.getValue(void 0,B.value.Df?B.value.Df():[B.value],0,1)}))));const N=I.buildAnimations(M.object,e,60,g);for(const B of N)x&&B.babylonAnimation.setEasingFunction(x),f.push(B.babylonAnimation)})),f}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function H(B,I){return B.getClassName().startsWith("Color")?B:"SI"===I?new g.SI(B.x,B.y,B.z):"Pf"===I?new g.Pf(B.x,B.y,B.z,B.w):B}(0,L.h)("FlowGraphJsonPointerParserBlock",R)},14408:(B,I,C)=>{C.d(I,{b:()=>L});var M=C(12927),x=C(12901);const y="cachedOperationValue",f="cachedExecutionId";class L extends M.e{constructor(B,I){super(I),this.value=this.registerDataOutput("value",B),this.isValid=this.registerDataOutput("isValid",x.e)}_updateOutputs(B){const I=B._getExecutionVariable(this,f,-1),C=B._getExecutionVariable(this,y,null);if(void 0!==C&&null!==C&&I===B.executionId)this.isValid.setValue(!0,B),this.value.setValue(C,B);else try{const I=this._doOperation(B);if(void 0===I||null===I)return void this.isValid.setValue(!1,B);B._setExecutionVariable(this,y,I),B._setExecutionVariable(this,f,B.executionId),this.value.setValue(I,B),this.isValid.setValue(!0,B)}catch(M){this.isValid.setValue(!1,B)}}}}}]);