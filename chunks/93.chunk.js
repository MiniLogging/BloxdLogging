"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[93],{14532:(R,J,B)=>{B.r(J),B.d(J,{FlowGraphJsonPointerParserBlock:()=>l});var Q=B(12892),h=B(12894);const y=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class N{constructor(R,J){this.path=R,this.ownerBlock=J,this.templatedInputs=[];let B=y.exec(R);const N=new Set;for(;B;){const[,r]=B;if(N.has(r))throw new Error("Duplicate template variable detected.");N.add(r),this.templatedInputs.push(J.registerDataInput(r,h.k,new Q.d(0))),B=y.exec(R)}}getAccessor(R,J){let B=this.path;for(const Q of this.templatedInputs){const R=Q.getValue(J).value;if("number"!==typeof R||R<0)throw new Error("Invalid value for templated input.");B=B.replace(`{${Q.name}}`,R.toString())}return R.convert(B)}}var r=B(11142),q=B(11186),e=B(11224),D=B(14390);class l extends D.d{constructor(R){super(h.e,R),this.config=R,this.object=this.registerDataOutput("object",h.e),this.propertyName=this.registerDataOutput("propertyName",h.e),this.setterFunction=this.registerDataOutput("setFunction",h.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",h.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",h.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new N(R.jsonPointer,this)}_doOperation(R){var J,B,Q;const h=this.templateComponent.getAccessor(this.config.pathConverter,R),y=h.info.get(h.object),N=null===(J=(B=h.info).getTarget)||void 0===J?void 0:J.call(B,h.object),r=null===(Q=h.info.getPropertyName)||void 0===Q?void 0:Q[0](h.object);if(!N)throw new Error("Object is undefined");return this.object.setValue(N,R),r&&this.propertyName.setValue(r,R),y}_setPropertyValue(R,J,B,Q){var h,y;const N=this.templateComponent.getAccessor(this.config.pathConverter,Q),r=N.info.type;r.startsWith("Color")&&(B=E(B,r)),null===(h=(y=N.info).set)||void 0===h||h.call(y,B,N.object)}_getPropertyValue(R,J,B){const Q=this.templateComponent.getAccessor(this.config.pathConverter,B),h=Q.info.type,y=Q.info.get(Q.object);return h.startsWith("Color")?function(R){if(R instanceof e.SJ)return new q.nJ(R.r,R.g,R.b);if(R instanceof e.ar)return new q.Vector4(R.r,R.g,R.b,R.a);throw new Error("Invalid color type")}(y):y}_getInterpolationAnimationPropertyInfo(R,J,B){const Q=this.templateComponent.getAccessor(this.config.pathConverter,B);return(R,J,B,h)=>{var y;const N=[],r=Q.info.type;return r.startsWith("Color")&&(R=R.map((R=>({frame:R.frame,value:E(R.value,r)})))),null===(y=Q.info.interpolation)||void 0===y||y.forEach(((J,y)=>{var r;const q=(null===(r=Q.info.getPropertyName)||void 0===r?void 0:r[y](Q.object))||"Animation-interpolation-"+y;let e=R;B!==J.type&&(e=R.map((R=>({frame:R.frame,value:J.getValue(void 0,R.value.Ch?R.value.Ch():[R.value],0,1)}))));const D=J.buildAnimations(Q.object,q,60,e);for(const R of D)h&&R.babylonAnimation.setEasingFunction(h),N.push(R.babylonAnimation)})),N}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function E(R,J){return R.getClassName().startsWith("Color")?R:"SJ"===J?new e.SJ(R.x,R.y,R.z):"ar"===J?new e.ar(R.x,R.y,R.z,R.w):R}(0,r.h)("FlowGraphJsonPointerParserBlock",l)},14390:(R,J,B)=>{B.d(J,{d:()=>r});var Q=B(12922),h=B(12894);const y="cachedOperationValue",N="cachedExecutionId";class r extends Q.c{constructor(R,J){super(J),this.value=this.registerDataOutput("value",R),this.isValid=this.registerDataOutput("isValid",h.g)}_updateOutputs(R){const J=R._getExecutionVariable(this,N,-1),B=R._getExecutionVariable(this,y,null);if(void 0!==B&&null!==B&&J===R.executionId)this.isValid.setValue(!0,R),this.value.setValue(B,R);else try{const J=this._doOperation(R);if(void 0===J||null===J)return void this.isValid.setValue(!1,R);R._setExecutionVariable(this,y,J),R._setExecutionVariable(this,N,R.executionId),this.value.setValue(J,R),this.isValid.setValue(!0,R)}catch(Q){this.isValid.setValue(!1,R)}}}}}]);