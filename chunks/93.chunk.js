"use strict";(self.ra6kpa9z1sg=self.ra6kpa9z1sg||[]).push([[93],{16162:(p,b,M)=>{M.r(b),M.d(b,{FlowGraphJsonPointerParserBlock:()=>x});var h=M(14311),Q=M(14316);const mp=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class y{constructor(p,b){this.path=p,this.ownerBlock=b,this.templatedInputs=[];let M=mp.exec(p);const y=new Set;for(;M;){const[,P]=M;if(y.has(P))throw new Error("Duplicate template variable detected.");y.add(P),this.templatedInputs.push(b.registerDataInput(P,Q.k,new h.e(0))),M=mp.exec(p)}}getAccessor(p,b){let M=this.path;for(const h of this.templatedInputs){const p=h.getValue(b).value;if("number"!==typeof p||p<0)throw new Error("Invalid value for templated input.");M=M.replace(`{${h.name}}`,p.toString())}return p.convert(M)}}var P=M(12730),w=M(12777),t=M(12820),z=M(16006);class x extends z.e{constructor(p){super(Q.e,p),this.config=p,this.object=this.registerDataOutput("object",Q.e),this.propertyName=this.registerDataOutput("propertyName",Q.e),this.setterFunction=this.registerDataOutput("setFunction",Q.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",Q.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",Q.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new y(p.jsonPointer,this)}_doOperation(p){var b,M,h;const Q=this.templateComponent.getAccessor(this.config.pathConverter,p),mp=Q.info.get(Q.object),y=null===(b=(M=Q.info).getTarget)||void 0===b?void 0:b.call(M,Q.object),P=null===(h=Q.info.getPropertyName)||void 0===h?void 0:h[0](Q.object);if(!y)throw new Error("Object is undefined");return this.object.setValue(y,p),P&&this.propertyName.setValue(P,p),mp}_setPropertyValue(p,b,M,h){var Q,mp;const y=this.templateComponent.getAccessor(this.config.pathConverter,h),P=y.info.type;P.startsWith("Color")&&(M=S(M,P)),null===(Q=(mp=y.info).set)||void 0===Q||Q.call(mp,M,y.object)}_getPropertyValue(p,b,M){const h=this.templateComponent.getAccessor(this.config.pathConverter,M),Q=h.info.type,mp=h.info.get(h.object);return Q.startsWith("Color")?function(p){if(p instanceof t.wM)return new w.QM(p.r,p.g,p.b);if(p instanceof t.Hb)return new w.Vector4(p.r,p.g,p.b,p.a);throw new Error("Invalid color type")}(mp):mp}_getInterpolationAnimationPropertyInfo(p,b,M){const h=this.templateComponent.getAccessor(this.config.pathConverter,M);return(p,b,M,Q)=>{var mp;const y=[],P=h.info.type;return P.startsWith("Color")&&(p=p.map((p=>({frame:p.frame,value:S(p.value,P)})))),null===(mp=h.info.interpolation)||void 0===mp||mp.forEach(((b,mp)=>{var P;const w=(null===(P=h.info.getPropertyName)||void 0===P?void 0:P[mp](h.object))||"Animation-interpolation-"+mp;let t=p;M!==b.type&&(t=p.map((p=>({frame:p.frame,value:b.getValue(void 0,p.value.ub?p.value.ub():[p.value],0,1)}))));const z=b.buildAnimations(h.object,w,60,t);for(const p of z)Q&&p.babylonAnimation.setEasingFunction(Q),y.push(p.babylonAnimation)})),y}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function S(p,b){return p.getClassName().startsWith("Color")?p:"wM"===b?new t.wM(p.x,p.y,p.z):"Hb"===b?new t.Hb(p.x,p.y,p.z,p.w):p}(0,P.c)("FlowGraphJsonPointerParserBlock",x)},16006:(p,b,M)=>{M.d(b,{e:()=>P});var h=M(14341),Q=M(14316);const mp="cachedOperationValue",y="cachedExecutionId";class P extends h.d{constructor(p,b){super(b),this.value=this.registerDataOutput("value",p),this.isValid=this.registerDataOutput("isValid",Q.g)}_updateOutputs(p){const b=p._getExecutionVariable(this,y,-1),M=p._getExecutionVariable(this,mp,null);if(void 0!==M&&null!==M&&b===p.executionId)this.isValid.setValue(!0,p),this.value.setValue(M,p);else try{const b=this._doOperation(p);if(void 0===b||null===b)return void this.isValid.setValue(!1,p);p._setExecutionVariable(this,mp,b),p._setExecutionVariable(this,y,p.executionId),this.value.setValue(b,p),this.isValid.setValue(!0,p)}catch(h){this.isValid.setValue(!1,p)}}}}}]);