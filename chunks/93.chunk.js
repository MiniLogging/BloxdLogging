"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[93],{14438:(P,e,n)=>{n.r(e),n.d(e,{FlowGraphJsonPointerParserBlock:()=>q});var H=n(12812),S=n(12819);const p=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class k{constructor(P,e){this.path=P,this.ownerBlock=e,this.templatedInputs=[];let n=p.exec(P);const k=new Set;for(;n;){const[,m]=n;if(k.has(m))throw new Error("Duplicate template variable detected.");k.add(m),this.templatedInputs.push(e.registerDataInput(m,S.e,new H.e(0))),n=p.exec(P)}}getAccessor(P,e){let n=this.path;for(const H of this.templatedInputs){const P=H.getValue(e).value;if("number"!==typeof P||P<0)throw new Error("Invalid value for templated input.");n=n.replace(`{${H.name}}`,P.toString())}return P.convert(n)}}var m=n(11096),t=n(11133),C=n(11183),R=n(14286);class q extends R.c{constructor(P){super(S.b,P),this.config=P,this.object=this.registerDataOutput("object",S.b),this.propertyName=this.registerDataOutput("propertyName",S.b),this.setterFunction=this.registerDataOutput("setFunction",S.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",S.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",S.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new k(P.jsonPointer,this)}_doOperation(P){var e,n,H;const S=this.templateComponent.getAccessor(this.config.pathConverter,P),p=S.info.get(S.object),k=null===(e=(n=S.info).getTarget)||void 0===e?void 0:e.call(n,S.object),m=null===(H=S.info.getPropertyName)||void 0===H?void 0:H[0](S.object);if(!k)throw new Error("Object is undefined");return this.object.setValue(k,P),m&&this.propertyName.setValue(m,P),p}_setPropertyValue(P,e,n,H){var S,p;const k=this.templateComponent.getAccessor(this.config.pathConverter,H),m=k.info.type;m.startsWith("Color")&&(n=A(n,m)),null===(S=(p=k.info).set)||void 0===S||S.call(p,n,k.object)}_getPropertyValue(P,e,n){const H=this.templateComponent.getAccessor(this.config.pathConverter,n),S=H.info.type,p=H.info.get(H.object);return S.startsWith("Color")?function(P){if(P instanceof C.Ne)return new t.Ie(P.r,P.g,P.b);if(P instanceof C.wm)return new t.Vector4(P.r,P.g,P.b,P.a);throw new Error("Invalid color type")}(p):p}_getInterpolationAnimationPropertyInfo(P,e,n){const H=this.templateComponent.getAccessor(this.config.pathConverter,n);return(P,e,n,S)=>{var p;const k=[],m=H.info.type;return m.startsWith("Color")&&(P=P.map((P=>({frame:P.frame,value:A(P.value,m)})))),null===(p=H.info.interpolation)||void 0===p||p.forEach(((e,p)=>{var m;const t=(null===(m=H.info.getPropertyName)||void 0===m?void 0:m[p](H.object))||"Animation-interpolation-"+p;let C=P;n!==e.type&&(C=P.map((P=>({frame:P.frame,value:e.getValue(void 0,P.value.fe?P.value.fe():[P.value],0,1)}))));const R=e.buildAnimations(H.object,t,60,C);for(const P of R)S&&P.babylonAnimation.setEasingFunction(S),k.push(P.babylonAnimation)})),k}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function A(P,e){return P.getClassName().startsWith("Color")?P:"Ne"===e?new C.Ne(P.x,P.y,P.z):"wm"===e?new C.wm(P.x,P.y,P.z,P.w):P}(0,m.h)("FlowGraphJsonPointerParserBlock",q)},14286:(P,e,n)=>{n.d(e,{c:()=>m});var H=n(12841),S=n(12819);const p="cachedOperationValue",k="cachedExecutionId";class m extends H.c{constructor(P,e){super(e),this.value=this.registerDataOutput("value",P),this.isValid=this.registerDataOutput("isValid",S.d)}_updateOutputs(P){const e=P._getExecutionVariable(this,k,-1),n=P._getExecutionVariable(this,p,null);if(void 0!==n&&null!==n&&e===P.executionId)this.isValid.setValue(!0,P),this.value.setValue(n,P);else try{const e=this._doOperation(P);if(void 0===e||null===e)return void this.isValid.setValue(!1,P);P._setExecutionVariable(this,p,e),P._setExecutionVariable(this,k,P.executionId),this.value.setValue(e,P),this.isValid.setValue(!0,P)}catch(H){this.isValid.setValue(!1,P)}}}}}]);