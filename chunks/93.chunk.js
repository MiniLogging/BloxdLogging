"use strict";(self.fwuvyyymhp8=self.fwuvyyymhp8||[]).push([[93],{15729:(N,U,V)=>{V.r(U),V.d(U,{FlowGraphJsonPointerParserBlock:()=>p});var A=V(14031),t=V(14036);const n=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class q{constructor(N,U){this.path=N,this.ownerBlock=U,this.templatedInputs=[];let V=n.exec(N);const q=new Set;for(;V;){const[,i]=V;if(q.has(i))throw new Error("Duplicate template variable detected.");q.add(i),this.templatedInputs.push(U.registerDataInput(i,t.g,new A.b(0))),V=n.exec(N)}}getAccessor(N,U){let V=this.path;for(const A of this.templatedInputs){const N=A.getValue(U).value;if("number"!==typeof N||N<0)throw new Error("Invalid value for templated input.");V=V.replace(`{${A.name}}`,N.toString())}return N.convert(V)}}var i=V(12344),z=V(12383),S=V(12426),E=V(15590);class p extends E.c{constructor(N){super(t.b,N),this.config=N,this.object=this.registerDataOutput("object",t.b),this.propertyName=this.registerDataOutput("propertyName",t.b),this.setterFunction=this.registerDataOutput("setFunction",t.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",t.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",t.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new q(N.jsonPointer,this)}_doOperation(N){var U,V,A;const t=this.templateComponent.getAccessor(this.config.pathConverter,N),n=t.info.get(t.object),q=null===(U=(V=t.info).getTarget)||void 0===U?void 0:U.call(V,t.object),i=null===(A=t.info.getPropertyName)||void 0===A?void 0:A[0](t.object);if(!q)throw new Error("Object is undefined");return this.object.setValue(q,N),i&&this.propertyName.setValue(i,N),n}_setPropertyValue(N,U,V,A){var t,n;const q=this.templateComponent.getAccessor(this.config.pathConverter,A),i=q.info.type;i.startsWith("Color")&&(V=k(V,i)),null===(t=(n=q.info).set)||void 0===t||t.call(n,V,q.object)}_getPropertyValue(N,U,V){const A=this.templateComponent.getAccessor(this.config.pathConverter,V),t=A.info.type,n=A.info.get(A.object);return t.startsWith("Color")?function(N){if(N instanceof S.rU)return new z.CU(N.r,N.g,N.b);if(N instanceof S.Yi)return new z.Vector4(N.r,N.g,N.b,N.a);throw new Error("Invalid color type")}(n):n}_getInterpolationAnimationPropertyInfo(N,U,V){const A=this.templateComponent.getAccessor(this.config.pathConverter,V);return(N,U,V,t)=>{var n;const q=[],i=A.info.type;return i.startsWith("Color")&&(N=N.map((N=>({frame:N.frame,value:k(N.value,i)})))),null===(n=A.info.interpolation)||void 0===n||n.forEach(((U,n)=>{var i;const z=(null===(i=A.info.getPropertyName)||void 0===i?void 0:i[n](A.object))||"Animation-interpolation-"+n;let S=N;V!==U.type&&(S=N.map((N=>({frame:N.frame,value:U.getValue(void 0,N.value.pi?N.value.pi():[N.value],0,1)}))));const E=U.buildAnimations(A.object,z,60,S);for(const N of E)t&&N.babylonAnimation.setEasingFunction(t),q.push(N.babylonAnimation)})),q}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function k(N,U){return N.getClassName().startsWith("Color")?N:"rU"===U?new S.rU(N.x,N.y,N.z):"Yi"===U?new S.Yi(N.x,N.y,N.z,N.w):N}(0,i.e)("FlowGraphJsonPointerParserBlock",p)},15590:(N,U,V)=>{V.d(U,{c:()=>i});var A=V(14058),t=V(14036);const n="cachedOperationValue",q="cachedExecutionId";class i extends A.c{constructor(N,U){super(U),this.value=this.registerDataOutput("value",N),this.isValid=this.registerDataOutput("isValid",t.d)}_updateOutputs(N){const U=N._getExecutionVariable(this,q,-1),V=N._getExecutionVariable(this,n,null);if(void 0!==V&&null!==V&&U===N.executionId)this.isValid.setValue(!0,N),this.value.setValue(V,N);else try{const U=this._doOperation(N);if(void 0===U||null===U)return void this.isValid.setValue(!1,N);N._setExecutionVariable(this,n,U),N._setExecutionVariable(this,q,N.executionId),this.value.setValue(U,N),this.isValid.setValue(!0,N)}catch(A){this.isValid.setValue(!1,N)}}}}}]);