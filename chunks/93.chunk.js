"use strict";(self.hwpa2z1pqte=self.hwpa2z1pqte||[]).push([[93],{16317:(h,R,l)=>{l.r(R),l.d(R,{FlowGraphJsonPointerParserBlock:()=>c});var j=l(14591),a=l(14597);const D=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class U{constructor(h,R){this.path=h,this.ownerBlock=R,this.templatedInputs=[];let l=D.exec(h);const U=new Set;for(;l;){const[,F]=l;if(U.has(F))throw new Error("Duplicate template variable detected.");U.add(F),this.templatedInputs.push(R.registerDataInput(F,a.i,new j.c(0))),l=D.exec(h)}}getAccessor(h,R){let l=this.path;for(const j of this.templatedInputs){const h=j.getValue(R).value;if("number"!==typeof h||h<0)throw new Error("Invalid value for templated input.");l=l.replace(`{${j.name}}`,h.toString())}return h.convert(l)}}var F=l(12852),w=l(12900),mh=l(12952),u=l(16163);class c extends u.d{constructor(h){super(a.c,h),this.config=h,this.object=this.registerDataOutput("object",a.c),this.propertyName=this.registerDataOutput("propertyName",a.c),this.setterFunction=this.registerDataOutput("setFunction",a.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",a.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",a.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new U(h.jsonPointer,this)}_doOperation(h){var R,l,j;const a=this.templateComponent.getAccessor(this.config.pathConverter,h),D=a.info.get(a.object),U=null===(R=(l=a.info).getTarget)||void 0===R?void 0:R.call(l,a.object),F=null===(j=a.info.getPropertyName)||void 0===j?void 0:j[0](a.object);if(!U)throw new Error("Object is undefined");return this.object.setValue(U,h),F&&this.propertyName.setValue(F,h),D}_setPropertyValue(h,R,l,j){var a,D;const U=this.templateComponent.getAccessor(this.config.pathConverter,j),F=U.info.type;F.startsWith("Color")&&(l=J(l,F)),null===(a=(D=U.info).set)||void 0===a||a.call(D,l,U.object)}_getPropertyValue(h,R,l){const j=this.templateComponent.getAccessor(this.config.pathConverter,l),a=j.info.type,D=j.info.get(j.object);return a.startsWith("Color")?function(h){if(h instanceof mh.xR)return new w.tR(h.r,h.g,h.b);if(h instanceof mh.bF)return new w.Vector4(h.r,h.g,h.b,h.a);throw new Error("Invalid color type")}(D):D}_getInterpolationAnimationPropertyInfo(h,R,l){const j=this.templateComponent.getAccessor(this.config.pathConverter,l);return(h,R,l,a)=>{var D;const U=[],F=j.info.type;return F.startsWith("Color")&&(h=h.map((h=>({frame:h.frame,value:J(h.value,F)})))),null===(D=j.info.interpolation)||void 0===D||D.forEach(((R,D)=>{var F;const w=(null===(F=j.info.getPropertyName)||void 0===F?void 0:F[D](j.object))||"Animation-interpolation-"+D;let mh=h;l!==R.type&&(mh=h.map((h=>({frame:h.frame,value:R.getValue(void 0,h.value.sF?h.value.sF():[h.value],0,1)}))));const u=R.buildAnimations(j.object,w,60,mh);for(const h of u)a&&h.babylonAnimation.setEasingFunction(a),U.push(h.babylonAnimation)})),U}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function J(h,R){return h.getClassName().startsWith("Color")?h:"xR"===R?new mh.xR(h.x,h.y,h.z):"bF"===R?new mh.bF(h.x,h.y,h.z,h.w):h}(0,F.f)("FlowGraphJsonPointerParserBlock",c)},16163:(h,R,l)=>{l.d(R,{d:()=>F});var j=l(14620),a=l(14597);const D="cachedOperationValue",U="cachedExecutionId";class F extends j.e{constructor(h,R){super(R),this.value=this.registerDataOutput("value",h),this.isValid=this.registerDataOutput("isValid",a.g)}_updateOutputs(h){const R=h._getExecutionVariable(this,U,-1),l=h._getExecutionVariable(this,D,null);if(void 0!==l&&null!==l&&R===h.executionId)this.isValid.setValue(!0,h),this.value.setValue(l,h);else try{const R=this._doOperation(h);if(void 0===R||null===R)return void this.isValid.setValue(!1,h);h._setExecutionVariable(this,D,R),h._setExecutionVariable(this,U,h.executionId),this.value.setValue(R,h),this.isValid.setValue(!0,h)}catch(j){this.isValid.setValue(!1,h)}}}}}]);