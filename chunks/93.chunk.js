"use strict";(self.xeuzlpp225k=self.xeuzlpp225k||[]).push([[93],{14680:(k,Q,i)=>{i.r(Q),i.d(Q,{FlowGraphJsonPointerParserBlock:()=>G});var Z=i(13060),U=i(13064);const C=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class B{constructor(k,Q){this.path=k,this.ownerBlock=Q,this.templatedInputs=[];let i=C.exec(k);const B=new Set;for(;i;){const[,o]=i;if(B.has(o))throw new Error("Duplicate template variable detected.");B.add(o),this.templatedInputs.push(Q.registerDataInput(o,U.h,new Z.e(0))),i=C.exec(k)}}getAccessor(k,Q){let i=this.path;for(const Z of this.templatedInputs){const k=Z.getValue(Q).value;if("number"!==typeof k||k<0)throw new Error("Invalid value for templated input.");i=i.replace(`{${Z.name}}`,k.toString())}return k.convert(i)}}var o=i(11253),m=i(11298),O=i(11348),J=i(14536);class G extends J.e{constructor(k){super(U.b,k),this.config=k,this.object=this.registerDataOutput("object",U.b),this.propertyName=this.registerDataOutput("propertyName",U.b),this.setterFunction=this.registerDataOutput("setFunction",U.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",U.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",U.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new B(k.jsonPointer,this)}_doOperation(k){var Q,i,Z;const U=this.templateComponent.getAccessor(this.config.pathConverter,k),C=U.info.get(U.object),B=null===(Q=(i=U.info).getTarget)||void 0===Q?void 0:Q.call(i,U.object),o=null===(Z=U.info.getPropertyName)||void 0===Z?void 0:Z[0](U.object);if(!B)throw new Error("Object is undefined");return this.object.setValue(B,k),o&&this.propertyName.setValue(o,k),C}_setPropertyValue(k,Q,i,Z){var U,C;const B=this.templateComponent.getAccessor(this.config.pathConverter,Z),o=B.info.type;o.startsWith("Color")&&(i=H(i,o)),null===(U=(C=B.info).set)||void 0===U||U.call(C,i,B.object)}_getPropertyValue(k,Q,i){const Z=this.templateComponent.getAccessor(this.config.pathConverter,i),U=Z.info.type,C=Z.info.get(Z.object);return U.startsWith("Color")?function(k){if(k instanceof O.cQ)return new m.zQ(k.r,k.g,k.b);if(k instanceof O.Fo)return new m.Vector4(k.r,k.g,k.b,k.a);throw new Error("Invalid color type")}(C):C}_getInterpolationAnimationPropertyInfo(k,Q,i){const Z=this.templateComponent.getAccessor(this.config.pathConverter,i);return(k,Q,i,U)=>{var C;const B=[],o=Z.info.type;return o.startsWith("Color")&&(k=k.map((k=>({frame:k.frame,value:H(k.value,o)})))),null===(C=Z.info.interpolation)||void 0===C||C.forEach(((Q,C)=>{var o;const m=(null===(o=Z.info.getPropertyName)||void 0===o?void 0:o[C](Z.object))||"Animation-interpolation-"+C;let O=k;i!==Q.type&&(O=k.map((k=>({frame:k.frame,value:Q.getValue(void 0,k.value.Zo?k.value.Zo():[k.value],0,1)}))));const J=Q.buildAnimations(Z.object,m,60,O);for(const k of J)U&&k.babylonAnimation.setEasingFunction(U),B.push(k.babylonAnimation)})),B}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function H(k,Q){return k.getClassName().startsWith("Color")?k:"cQ"===Q?new O.cQ(k.x,k.y,k.z):"Fo"===Q?new O.Fo(k.x,k.y,k.z,k.w):k}(0,o.e)("FlowGraphJsonPointerParserBlock",G)},14536:(k,Q,i)=>{i.d(Q,{e:()=>o});var Z=i(13084),U=i(13064);const C="cachedOperationValue",B="cachedExecutionId";class o extends Z.e{constructor(k,Q){super(Q),this.value=this.registerDataOutput("value",k),this.isValid=this.registerDataOutput("isValid",U.f)}_updateOutputs(k){const Q=k._getExecutionVariable(this,B,-1),i=k._getExecutionVariable(this,C,null);if(void 0!==i&&null!==i&&Q===k.executionId)this.isValid.setValue(!0,k),this.value.setValue(i,k);else try{const Q=this._doOperation(k);if(void 0===Q||null===Q)return void this.isValid.setValue(!1,k);k._setExecutionVariable(this,C,Q),k._setExecutionVariable(this,B,k.executionId),this.value.setValue(Q,k),this.isValid.setValue(!0,k)}catch(Z){this.isValid.setValue(!1,k)}}}}}]);