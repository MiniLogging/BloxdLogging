"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[93],{14503:(q,S,b)=>{b.r(S),b.d(S,{FlowGraphJsonPointerParserBlock:()=>l});var z=b(12836),C=b(12839);const v=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class U{constructor(q,S){this.path=q,this.ownerBlock=S,this.templatedInputs=[];let b=v.exec(q);const U=new Set;for(;b;){const[,g]=b;if(U.has(g))throw new Error("Duplicate template variable detected.");U.add(g),this.templatedInputs.push(S.registerDataInput(g,C.h,new z.d(0))),b=v.exec(q)}}getAccessor(q,S){let b=this.path;for(const z of this.templatedInputs){const q=z.getValue(S).value;if("number"!==typeof q||q<0)throw new Error("Invalid value for templated input.");b=b.replace(`{${z.name}}`,q.toString())}return q.convert(b)}}var g=b(11058),r=b(11103),I=b(11150),V=b(14353);class l extends V.d{constructor(q){super(C.d,q),this.config=q,this.object=this.registerDataOutput("object",C.d),this.propertyName=this.registerDataOutput("propertyName",C.d),this.setterFunction=this.registerDataOutput("setFunction",C.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",C.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",C.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new U(q.jsonPointer,this)}_doOperation(q){var S,b,z;const C=this.templateComponent.getAccessor(this.config.pathConverter,q),v=C.info.get(C.object),U=null===(S=(b=C.info).getTarget)||void 0===S?void 0:S.call(b,C.object),g=null===(z=C.info.getPropertyName)||void 0===z?void 0:z[0](C.object);if(!U)throw new Error("Object is undefined");return this.object.setValue(U,q),g&&this.propertyName.setValue(g,q),v}_setPropertyValue(q,S,b,z){var C,v;const U=this.templateComponent.getAccessor(this.config.pathConverter,z),g=U.info.type;g.startsWith("Color")&&(b=y(b,g)),null===(C=(v=U.info).set)||void 0===C||C.call(v,b,U.object)}_getPropertyValue(q,S,b){const z=this.templateComponent.getAccessor(this.config.pathConverter,b),C=z.info.type,v=z.info.get(z.object);return C.startsWith("Color")?function(q){if(q instanceof I.HS)return new r.yS(q.r,q.g,q.b);if(q instanceof I.b)return new r.Vector4(q.r,q.g,q.b,q.a);throw new Error("Invalid color type")}(v):v}_getInterpolationAnimationPropertyInfo(q,S,b){const z=this.templateComponent.getAccessor(this.config.pathConverter,b);return(q,S,b,C)=>{var v;const U=[],g=z.info.type;return g.startsWith("Color")&&(q=q.map((q=>({frame:q.frame,value:y(q.value,g)})))),null===(v=z.info.interpolation)||void 0===v||v.forEach(((S,v)=>{var g;const r=(null===(g=z.info.getPropertyName)||void 0===g?void 0:g[v](z.object))||"Animation-interpolation-"+v;let I=q;b!==S.type&&(I=q.map((q=>({frame:q.frame,value:S.getValue(void 0,q.value.Zb?q.value.Zb():[q.value],0,1)}))));const V=S.buildAnimations(z.object,r,60,I);for(const q of V)C&&q.babylonAnimation.setEasingFunction(C),U.push(q.babylonAnimation)})),U}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function y(q,S){return q.getClassName().startsWith("Color")?q:"HS"===S?new I.HS(q.x,q.y,q.z):"Jb"===S?new I.b(q.x,q.y,q.z,q.w):q}(0,g.f)("FlowGraphJsonPointerParserBlock",l)},14353:(q,S,b)=>{b.d(S,{d:()=>g});var z=b(12852),C=b(12839);const v="cachedOperationValue",U="cachedExecutionId";class g extends z.c{constructor(q,S){super(S),this.value=this.registerDataOutput("value",q),this.isValid=this.registerDataOutput("isValid",C.f)}_updateOutputs(q){const S=q._getExecutionVariable(this,U,-1),b=q._getExecutionVariable(this,v,null);if(void 0!==b&&null!==b&&S===q.executionId)this.isValid.setValue(!0,q),this.value.setValue(b,q);else try{const S=this._doOperation(q);if(void 0===S||null===S)return void this.isValid.setValue(!1,q);q._setExecutionVariable(this,v,S),q._setExecutionVariable(this,U,q.executionId),this.value.setValue(S,q),this.isValid.setValue(!0,q)}catch(z){this.isValid.setValue(!1,q)}}}}}]);