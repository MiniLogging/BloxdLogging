"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[93],{14731:(B,E,v)=>{v.r(E),v.d(E,{FlowGraphJsonPointerParserBlock:()=>y});var z=v(13099),o=v(13102);const q=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class c{constructor(B,E){this.path=B,this.ownerBlock=E,this.templatedInputs=[];let v=q.exec(B);const c=new Set;for(;v;){const[,S]=v;if(c.has(S))throw new Error("Duplicate template variable detected.");c.add(S),this.templatedInputs.push(E.registerDataInput(S,o.g,new z.d(0))),v=q.exec(B)}}getAccessor(B,E){let v=this.path;for(const z of this.templatedInputs){const B=z.getValue(E).value;if("number"!==typeof B||B<0)throw new Error("Invalid value for templated input.");v=v.replace(`{${z.name}}`,B.toString())}return B.convert(v)}}var S=v(11345),x=v(11380),D=v(11417),h=v(14588);class y extends h.b{constructor(B){super(o.c,B),this.config=B,this.object=this.registerDataOutput("object",o.c),this.propertyName=this.registerDataOutput("propertyName",o.c),this.setterFunction=this.registerDataOutput("setFunction",o.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",o.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",o.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new c(B.jsonPointer,this)}_doOperation(B){var E,v,z;const o=this.templateComponent.getAccessor(this.config.pathConverter,B),q=o.info.get(o.object),c=null===(E=(v=o.info).getTarget)||void 0===E?void 0:E.call(v,o.object),S=null===(z=o.info.getPropertyName)||void 0===z?void 0:z[0](o.object);if(!c)throw new Error("Object is undefined");return this.object.setValue(c,B),S&&this.propertyName.setValue(S,B),q}_setPropertyValue(B,E,v,z){var o,q;const c=this.templateComponent.getAccessor(this.config.pathConverter,z),S=c.info.type;S.startsWith("Color")&&(v=Q(v,S)),null===(o=(q=c.info).set)||void 0===o||o.call(q,v,c.object)}_getPropertyValue(B,E,v){const z=this.templateComponent.getAccessor(this.config.pathConverter,v),o=z.info.type,q=z.info.get(z.object);return o.startsWith("Color")?function(B){if(B instanceof D.gE)return new x.GE(B.r,B.g,B.b);if(B instanceof D.gc)return new x.Vector4(B.r,B.g,B.b,B.a);throw new Error("Invalid color type")}(q):q}_getInterpolationAnimationPropertyInfo(B,E,v){const z=this.templateComponent.getAccessor(this.config.pathConverter,v);return(B,E,v,o)=>{var q;const c=[],S=z.info.type;return S.startsWith("Color")&&(B=B.map((B=>({frame:B.frame,value:Q(B.value,S)})))),null===(q=z.info.interpolation)||void 0===q||q.forEach(((E,q)=>{var S;const x=(null===(S=z.info.getPropertyName)||void 0===S?void 0:S[q](z.object))||"Animation-interpolation-"+q;let D=B;v!==E.type&&(D=B.map((B=>({frame:B.frame,value:E.getValue(void 0,B.value.cc?B.value.cc():[B.value],0,1)}))));const h=E.buildAnimations(z.object,x,60,D);for(const B of h)o&&B.babylonAnimation.setEasingFunction(o),c.push(B.babylonAnimation)})),c}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function Q(B,E){return B.getClassName().startsWith("Color")?B:"gE"===E?new D.gE(B.x,B.y,B.z):"gc"===E?new D.gc(B.x,B.y,B.z,B.w):B}(0,S.f)("FlowGraphJsonPointerParserBlock",y)},14588:(B,E,v)=>{v.d(E,{b:()=>S});var z=v(13121),o=v(13102);const q="cachedOperationValue",c="cachedExecutionId";class S extends z.c{constructor(B,E){super(E),this.value=this.registerDataOutput("value",B),this.isValid=this.registerDataOutput("isValid",o.f)}_updateOutputs(B){const E=B._getExecutionVariable(this,c,-1),v=B._getExecutionVariable(this,q,null);if(void 0!==v&&null!==v&&E===B.executionId)this.isValid.setValue(!0,B),this.value.setValue(v,B);else try{const E=this._doOperation(B);if(void 0===E||null===E)return void this.isValid.setValue(!1,B);B._setExecutionVariable(this,q,E),B._setExecutionVariable(this,c,B.executionId),this.value.setValue(E,B),this.isValid.setValue(!0,B)}catch(z){this.isValid.setValue(!1,B)}}}}}]);