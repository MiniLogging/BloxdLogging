"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[93],{14667:(H,O,S)=>{S.r(O),S.d(O,{FlowGraphJsonPointerParserBlock:()=>h});var t=S(13030),q=S(13035);const p=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class G{constructor(H,O){this.path=H,this.ownerBlock=O,this.templatedInputs=[];let S=p.exec(H);const G=new Set;for(;S;){const[,U]=S;if(G.has(U))throw new Error("Duplicate template variable detected.");G.add(U),this.templatedInputs.push(O.registerDataInput(U,q.l,new t.d(0))),S=p.exec(H)}}getAccessor(H,O){let S=this.path;for(const t of this.templatedInputs){const H=t.getValue(O).value;if("number"!==typeof H||H<0)throw new Error("Invalid value for templated input.");S=S.replace(`{${t.name}}`,H.toString())}return H.convert(S)}}var U=S(11262),V=S(11301),w=S(11355),o=S(14517);class h extends o.e{constructor(H){super(q.e,H),this.config=H,this.object=this.registerDataOutput("object",q.e),this.propertyName=this.registerDataOutput("propertyName",q.e),this.setterFunction=this.registerDataOutput("setFunction",q.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",q.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",q.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new G(H.jsonPointer,this)}_doOperation(H){var O,S,t;const q=this.templateComponent.getAccessor(this.config.pathConverter,H),p=q.info.get(q.object),G=null===(O=(S=q.info).getTarget)||void 0===O?void 0:O.call(S,q.object),U=null===(t=q.info.getPropertyName)||void 0===t?void 0:t[0](q.object);if(!G)throw new Error("Object is undefined");return this.object.setValue(G,H),U&&this.propertyName.setValue(U,H),p}_setPropertyValue(H,O,S,t){var q,p;const G=this.templateComponent.getAccessor(this.config.pathConverter,t),U=G.info.type;U.startsWith("Color")&&(S=a(S,U)),null===(q=(p=G.info).set)||void 0===q||q.call(p,S,G.object)}_getPropertyValue(H,O,S){const t=this.templateComponent.getAccessor(this.config.pathConverter,S),q=t.info.type,p=t.info.get(t.object);return q.startsWith("Color")?function(H){if(H instanceof w.TO)return new V.eO(H.r,H.g,H.b);if(H instanceof w.EU)return new V.Vector4(H.r,H.g,H.b,H.a);throw new Error("Invalid color type")}(p):p}_getInterpolationAnimationPropertyInfo(H,O,S){const t=this.templateComponent.getAccessor(this.config.pathConverter,S);return(H,O,S,q)=>{var p;const G=[],U=t.info.type;return U.startsWith("Color")&&(H=H.map((H=>({frame:H.frame,value:a(H.value,U)})))),null===(p=t.info.interpolation)||void 0===p||p.forEach(((O,p)=>{var U;const V=(null===(U=t.info.getPropertyName)||void 0===U?void 0:U[p](t.object))||"Animation-interpolation-"+p;let w=H;S!==O.type&&(w=H.map((H=>({frame:H.frame,value:O.getValue(void 0,H.value.pU?H.value.pU():[H.value],0,1)}))));const o=O.buildAnimations(t.object,V,60,w);for(const H of o)q&&H.babylonAnimation.setEasingFunction(q),G.push(H.babylonAnimation)})),G}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function a(H,O){return H.getClassName().startsWith("Color")?H:"TO"===O?new w.TO(H.x,H.y,H.z):"EU"===O?new w.EU(H.x,H.y,H.z,H.w):H}(0,U.g)("FlowGraphJsonPointerParserBlock",h)},14517:(H,O,S)=>{S.d(O,{e:()=>U});var t=S(13063),q=S(13035);const p="cachedOperationValue",G="cachedExecutionId";class U extends t.c{constructor(H,O){super(O),this.value=this.registerDataOutput("value",H),this.isValid=this.registerDataOutput("isValid",q.i)}_updateOutputs(H){const O=H._getExecutionVariable(this,G,-1),S=H._getExecutionVariable(this,p,null);if(void 0!==S&&null!==S&&O===H.executionId)this.isValid.setValue(!0,H),this.value.setValue(S,H);else try{const O=this._doOperation(H);if(void 0===O||null===O)return void this.isValid.setValue(!1,H);H._setExecutionVariable(this,p,O),H._setExecutionVariable(this,G,H.executionId),this.value.setValue(O,H),this.isValid.setValue(!0,H)}catch(t){this.isValid.setValue(!1,H)}}}}}]);