"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[93],{15125:(C,U,K)=>{K.r(U),K.d(U,{FlowGraphJsonPointerParserBlock:()=>p});var m=K(13508),O=K(13514);const X=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class A{constructor(C,U){this.path=C,this.ownerBlock=U,this.templatedInputs=[];let K=X.exec(C);const A=new Set;for(;K;){const[,e]=K;if(A.has(e))throw new Error("Duplicate template variable detected.");A.add(e),this.templatedInputs.push(U.registerDataInput(e,O.i,new m.d(0))),K=X.exec(C)}}getAccessor(C,U){let K=this.path;for(const m of this.templatedInputs){const C=m.getValue(U).value;if("number"!==typeof C||C<0)throw new Error("Invalid value for templated input.");K=K.replace(`{${m.name}}`,C.toString())}return C.convert(K)}}var e=K(11789),t=K(11827),z=K(11879),j=K(14989);class p extends j.b{constructor(C){super(O.c,C),this.config=C,this.object=this.registerDataOutput("object",O.c),this.propertyName=this.registerDataOutput("propertyName",O.c),this.setterFunction=this.registerDataOutput("setFunction",O.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",O.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",O.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new A(C.jsonPointer,this)}_doOperation(C){var U,K,m;const O=this.templateComponent.getAccessor(this.config.pathConverter,C),X=O.info.get(O.object),A=null===(U=(K=O.info).getTarget)||void 0===U?void 0:U.call(K,O.object),e=null===(m=O.info.getPropertyName)||void 0===m?void 0:m[0](O.object);if(!A)throw new Error("Object is undefined");return this.object.setValue(A,C),e&&this.propertyName.setValue(e,C),X}_setPropertyValue(C,U,K,m){var O,X;const A=this.templateComponent.getAccessor(this.config.pathConverter,m),e=A.info.type;e.startsWith("Color")&&(K=E(K,e)),null===(O=(X=A.info).set)||void 0===O||O.call(X,K,A.object)}_getPropertyValue(C,U,K){const m=this.templateComponent.getAccessor(this.config.pathConverter,K),O=m.info.type,X=m.info.get(m.object);return O.startsWith("Color")?function(C){if(C instanceof z.fU)return new t.bU(C.r,C.g,C.b);if(C instanceof z.ve)return new t.Vector4(C.r,C.g,C.b,C.a);throw new Error("Invalid color type")}(X):X}_getInterpolationAnimationPropertyInfo(C,U,K){const m=this.templateComponent.getAccessor(this.config.pathConverter,K);return(C,U,K,O)=>{var X;const A=[],e=m.info.type;return e.startsWith("Color")&&(C=C.map((C=>({frame:C.frame,value:E(C.value,e)})))),null===(X=m.info.interpolation)||void 0===X||X.forEach(((U,X)=>{var e;const t=(null===(e=m.info.getPropertyName)||void 0===e?void 0:e[X](m.object))||"Animation-interpolation-"+X;let z=C;K!==U.type&&(z=C.map((C=>({frame:C.frame,value:U.getValue(void 0,C.value.Oe?C.value.Oe():[C.value],0,1)}))));const j=U.buildAnimations(m.object,t,60,z);for(const C of j)O&&C.babylonAnimation.setEasingFunction(O),A.push(C.babylonAnimation)})),A}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function E(C,U){return C.getClassName().startsWith("Color")?C:"fU"===U?new z.fU(C.x,C.y,C.z):"ve"===U?new z.ve(C.x,C.y,C.z,C.w):C}(0,e.h)("FlowGraphJsonPointerParserBlock",p)},14989:(C,U,K)=>{K.d(U,{b:()=>e});var m=K(13539),O=K(13514);const X="cachedOperationValue",A="cachedExecutionId";class e extends m.e{constructor(C,U){super(U),this.value=this.registerDataOutput("value",C),this.isValid=this.registerDataOutput("isValid",O.f)}_updateOutputs(C){const U=C._getExecutionVariable(this,A,-1),K=C._getExecutionVariable(this,X,null);if(void 0!==K&&null!==K&&U===C.executionId)this.isValid.setValue(!0,C),this.value.setValue(K,C);else try{const U=this._doOperation(C);if(void 0===U||null===U)return void this.isValid.setValue(!1,C);C._setExecutionVariable(this,X,U),C._setExecutionVariable(this,A,C.executionId),this.value.setValue(U,C),this.isValid.setValue(!0,C)}catch(m){this.isValid.setValue(!1,C)}}}}}]);