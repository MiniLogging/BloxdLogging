"use strict";(self.wy695la1oic=self.wy695la1oic||[]).push([[93],{14800:(S,v,D)=>{D.r(v),D.d(v,{FlowGraphJsonPointerParserBlock:()=>A});var z=D(13103),e=D(13108);const N=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class m{constructor(S,v){this.path=S,this.ownerBlock=v,this.templatedInputs=[];let D=N.exec(S);const m=new Set;for(;D;){const[,B]=D;if(m.has(B))throw new Error("Duplicate template variable detected.");m.add(B),this.templatedInputs.push(v.registerDataInput(B,e.i,new z.b(0))),D=N.exec(S)}}getAccessor(S,v){let D=this.path;for(const z of this.templatedInputs){const S=z.getValue(v).value;if("number"!==typeof S||S<0)throw new Error("Invalid value for templated input.");D=D.replace(`{${z.name}}`,S.toString())}return S.convert(D)}}var B=D(11329),g=D(11371),E=D(11425),h=D(14647);class A extends h.e{constructor(S){super(e.d,S),this.config=S,this.object=this.registerDataOutput("object",e.d),this.propertyName=this.registerDataOutput("propertyName",e.d),this.setterFunction=this.registerDataOutput("setFunction",e.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",e.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",e.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new m(S.jsonPointer,this)}_doOperation(S){var v,D,z;const e=this.templateComponent.getAccessor(this.config.pathConverter,S),N=e.info.get(e.object),m=null===(v=(D=e.info).getTarget)||void 0===v?void 0:v.call(D,e.object),B=null===(z=e.info.getPropertyName)||void 0===z?void 0:z[0](e.object);if(!m)throw new Error("Object is undefined");return this.object.setValue(m,S),B&&this.propertyName.setValue(B,S),N}_setPropertyValue(S,v,D,z){var e,N;const m=this.templateComponent.getAccessor(this.config.pathConverter,z),B=m.info.type;B.startsWith("Color")&&(D=w(D,B)),null===(e=(N=m.info).set)||void 0===e||e.call(N,D,m.object)}_getPropertyValue(S,v,D){const z=this.templateComponent.getAccessor(this.config.pathConverter,D),e=z.info.type,N=z.info.get(z.object);return e.startsWith("Color")?function(S){if(S instanceof E.qv)return new g.Rv(S.r,S.g,S.b);if(S instanceof E.Ge)return new g.Vector4(S.r,S.g,S.b,S.a);throw new Error("Invalid color type")}(N):N}_getInterpolationAnimationPropertyInfo(S,v,D){const z=this.templateComponent.getAccessor(this.config.pathConverter,D);return(S,v,D,e)=>{var N;const m=[],B=z.info.type;return B.startsWith("Color")&&(S=S.map((S=>({frame:S.frame,value:w(S.value,B)})))),null===(N=z.info.interpolation)||void 0===N||N.forEach(((v,N)=>{var B;const g=(null===(B=z.info.getPropertyName)||void 0===B?void 0:B[N](z.object))||"Animation-interpolation-"+N;let E=S;D!==v.type&&(E=S.map((S=>({frame:S.frame,value:v.getValue(void 0,S.value.Oe?S.value.Oe():[S.value],0,1)}))));const h=v.buildAnimations(z.object,g,60,E);for(const S of h)e&&S.babylonAnimation.setEasingFunction(e),m.push(S.babylonAnimation)})),m}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function w(S,v){return S.getClassName().startsWith("Color")?S:"qv"===v?new E.qv(S.x,S.y,S.z):"Ge"===v?new E.Ge(S.x,S.y,S.z,S.w):S}(0,B.f)("FlowGraphJsonPointerParserBlock",A)},14647:(S,v,D)=>{D.d(v,{e:()=>B});var z=D(13123),e=D(13108);const N="cachedOperationValue",m="cachedExecutionId";class B extends z.d{constructor(S,v){super(v),this.value=this.registerDataOutput("value",S),this.isValid=this.registerDataOutput("isValid",e.e)}_updateOutputs(S){const v=S._getExecutionVariable(this,m,-1),D=S._getExecutionVariable(this,N,null);if(void 0!==D&&null!==D&&v===S.executionId)this.isValid.setValue(!0,S),this.value.setValue(D,S);else try{const v=this._doOperation(S);if(void 0===v||null===v)return void this.isValid.setValue(!1,S);S._setExecutionVariable(this,N,v),S._setExecutionVariable(this,m,S.executionId),this.value.setValue(v,S),this.isValid.setValue(!0,S)}catch(z){this.isValid.setValue(!1,S)}}}}}]);