"use strict";(self.b15p7b72fr8=self.b15p7b72fr8||[]).push([[93],{16023:(s,k,h)=>{h.r(k),h.d(k,{FlowGraphJsonPointerParserBlock:()=>S});var A=h(14313),g=h(14315);const ms=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class i{constructor(s,k){this.path=s,this.ownerBlock=k,this.templatedInputs=[];let h=ms.exec(s);const i=new Set;for(;h;){const[,K]=h;if(i.has(K))throw new Error("Duplicate template variable detected.");i.add(K),this.templatedInputs.push(k.registerDataInput(K,g.e,new A.c(0))),h=ms.exec(s)}}getAccessor(s,k){let h=this.path;for(const A of this.templatedInputs){const s=A.getValue(k).value;if("number"!==typeof s||s<0)throw new Error("Invalid value for templated input.");h=h.replace(`{${A.name}}`,s.toString())}return s.convert(h)}}var K=h(12543),H=h(12590),O=h(12636),c=h(15871);class S extends c.e{constructor(s){super(g.c,s),this.config=s,this.object=this.registerDataOutput("object",g.c),this.propertyName=this.registerDataOutput("propertyName",g.c),this.setterFunction=this.registerDataOutput("setFunction",g.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",g.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",g.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new i(s.jsonPointer,this)}_doOperation(s){var k,h,A;const g=this.templateComponent.getAccessor(this.config.pathConverter,s),ms=g.info.get(g.object),i=null===(k=(h=g.info).getTarget)||void 0===k?void 0:k.call(h,g.object),K=null===(A=g.info.getPropertyName)||void 0===A?void 0:A[0](g.object);if(!i)throw new Error("Object is undefined");return this.object.setValue(i,s),K&&this.propertyName.setValue(K,s),ms}_setPropertyValue(s,k,h,A){var g,ms;const i=this.templateComponent.getAccessor(this.config.pathConverter,A),K=i.info.type;K.startsWith("Color")&&(h=a(h,K)),null===(g=(ms=i.info).set)||void 0===g||g.call(ms,h,i.object)}_getPropertyValue(s,k,h){const A=this.templateComponent.getAccessor(this.config.pathConverter,h),g=A.info.type,ms=A.info.get(A.object);return g.startsWith("Color")?function(s){if(s instanceof O.Bk)return new H.Pk(s.r,s.g,s.b);if(s instanceof O.jg)return new H.Vector4(s.r,s.g,s.b,s.a);throw new Error("Invalid color type")}(ms):ms}_getInterpolationAnimationPropertyInfo(s,k,h){const A=this.templateComponent.getAccessor(this.config.pathConverter,h);return(s,k,h,g)=>{var ms;const i=[],K=A.info.type;return K.startsWith("Color")&&(s=s.map((s=>({frame:s.frame,value:a(s.value,K)})))),null===(ms=A.info.interpolation)||void 0===ms||ms.forEach(((k,ms)=>{var K;const H=(null===(K=A.info.getPropertyName)||void 0===K?void 0:K[ms](A.object))||"Animation-interpolation-"+ms;let O=s;h!==k.type&&(O=s.map((s=>({frame:s.frame,value:k.getValue(void 0,s.value.yh?s.value.yh():[s.value],0,1)}))));const c=k.buildAnimations(A.object,H,60,O);for(const s of c)g&&s.babylonAnimation.setEasingFunction(g),i.push(s.babylonAnimation)})),i}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function a(s,k){return s.getClassName().startsWith("Color")?s:"Bk"===k?new O.Bk(s.x,s.y,s.z):"jg"===k?new O.jg(s.x,s.y,s.z,s.w):s}(0,K.f)("FlowGraphJsonPointerParserBlock",S)},15871:(s,k,h)=>{h.d(k,{e:()=>K});var A=h(14325),g=h(14315);const ms="cachedOperationValue",i="cachedExecutionId";class K extends A.e{constructor(s,k){super(k),this.value=this.registerDataOutput("value",s),this.isValid=this.registerDataOutput("isValid",g.d)}_updateOutputs(s){const k=s._getExecutionVariable(this,i,-1),h=s._getExecutionVariable(this,ms,null);if(void 0!==h&&null!==h&&k===s.executionId)this.isValid.setValue(!0,s),this.value.setValue(h,s);else try{const k=this._doOperation(s);if(void 0===k||null===k)return void this.isValid.setValue(!1,s);s._setExecutionVariable(this,ms,k),s._setExecutionVariable(this,i,s.executionId),this.value.setValue(k,s),this.isValid.setValue(!0,s)}catch(A){this.isValid.setValue(!1,s)}}}}}]);