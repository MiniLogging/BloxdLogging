"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[93],{14559:(k,h,o)=>{o.r(h),o.d(h,{FlowGraphJsonPointerParserBlock:()=>K});var x=o(12928),I=o(12936);const q=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class Y{constructor(k,h){this.path=k,this.ownerBlock=h,this.templatedInputs=[];let o=q.exec(k);const Y=new Set;for(;o;){const[,J]=o;if(Y.has(J))throw new Error("Duplicate template variable detected.");Y.add(J),this.templatedInputs.push(h.registerDataInput(J,I.j,new x.c(0))),o=q.exec(k)}}getAccessor(k,h){let o=this.path;for(const x of this.templatedInputs){const k=x.getValue(h).value;if("number"!==typeof k||k<0)throw new Error("Invalid value for templated input.");o=o.replace(`{${x.name}}`,k.toString())}return k.convert(o)}}var J=o(11199),G=o(11239),l=o(11281),A=o(14409);class K extends A.c{constructor(k){super(I.d,k),this.config=k,this.object=this.registerDataOutput("object",I.d),this.propertyName=this.registerDataOutput("propertyName",I.d),this.setterFunction=this.registerDataOutput("setFunction",I.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",I.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",I.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new Y(k.jsonPointer,this)}_doOperation(k){var h,o,x;const I=this.templateComponent.getAccessor(this.config.pathConverter,k),q=I.info.get(I.object),Y=null===(h=(o=I.info).getTarget)||void 0===h?void 0:h.call(o,I.object),J=null===(x=I.info.getPropertyName)||void 0===x?void 0:x[0](I.object);if(!Y)throw new Error("Object is undefined");return this.object.setValue(Y,k),J&&this.propertyName.setValue(J,k),q}_setPropertyValue(k,h,o,x){var I,q;const Y=this.templateComponent.getAccessor(this.config.pathConverter,x),J=Y.info.type;J.startsWith("Color")&&(o=a(o,J)),null===(I=(q=Y.info).set)||void 0===I||I.call(q,o,Y.object)}_getPropertyValue(k,h,o){const x=this.templateComponent.getAccessor(this.config.pathConverter,o),I=x.info.type,q=x.info.get(x.object);return I.startsWith("Color")?function(k){if(k instanceof l.Zh)return new G.Vh(k.r,k.g,k.b);if(k instanceof l.RJ)return new G.Vector4(k.r,k.g,k.b,k.a);throw new Error("Invalid color type")}(q):q}_getInterpolationAnimationPropertyInfo(k,h,o){const x=this.templateComponent.getAccessor(this.config.pathConverter,o);return(k,h,o,I)=>{var q;const Y=[],J=x.info.type;return J.startsWith("Color")&&(k=k.map((k=>({frame:k.frame,value:a(k.value,J)})))),null===(q=x.info.interpolation)||void 0===q||q.forEach(((h,q)=>{var J;const G=(null===(J=x.info.getPropertyName)||void 0===J?void 0:J[q](x.object))||"Animation-interpolation-"+q;let l=k;o!==h.type&&(l=k.map((k=>({frame:k.frame,value:h.getValue(void 0,k.value.rh?k.value.rh():[k.value],0,1)}))));const A=h.buildAnimations(x.object,G,60,l);for(const k of A)I&&k.babylonAnimation.setEasingFunction(I),Y.push(k.babylonAnimation)})),Y}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function a(k,h){return k.getClassName().startsWith("Color")?k:"Zh"===h?new l.Zh(k.x,k.y,k.z):"RJ"===h?new l.RJ(k.x,k.y,k.z,k.w):k}(0,J.g)("FlowGraphJsonPointerParserBlock",K)},14409:(k,h,o)=>{o.d(h,{c:()=>J});var x=o(12961),I=o(12936);const q="cachedOperationValue",Y="cachedExecutionId";class J extends x.b{constructor(k,h){super(h),this.value=this.registerDataOutput("value",k),this.isValid=this.registerDataOutput("isValid",I.h)}_updateOutputs(k){const h=k._getExecutionVariable(this,Y,-1),o=k._getExecutionVariable(this,q,null);if(void 0!==o&&null!==o&&h===k.executionId)this.isValid.setValue(!0,k),this.value.setValue(o,k);else try{const h=this._doOperation(k);if(void 0===h||null===h)return void this.isValid.setValue(!1,k);k._setExecutionVariable(this,q,h),k._setExecutionVariable(this,Y,k.executionId),this.value.setValue(h,k),this.isValid.setValue(!0,k)}catch(x){this.isValid.setValue(!1,k)}}}}}]);