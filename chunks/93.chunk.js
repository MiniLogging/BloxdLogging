"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[93],{14953:(U,X,b)=>{b.r(X),b.d(X,{FlowGraphJsonPointerParserBlock:()=>R});var F=b(13276),E=b(13281);const w=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class Q{constructor(U,X){this.path=U,this.ownerBlock=X,this.templatedInputs=[];let b=w.exec(U);const Q=new Set;for(;b;){const[,z]=b;if(Q.has(z))throw new Error("Duplicate template variable detected.");Q.add(z),this.templatedInputs.push(X.registerDataInput(z,E.h,new F.e(0))),b=w.exec(U)}}getAccessor(U,X){let b=this.path;for(const F of this.templatedInputs){const U=F.getValue(X).value;if("number"!==typeof U||U<0)throw new Error("Invalid value for templated input.");b=b.replace(`{${F.name}}`,U.toString())}return U.convert(b)}}var z=b(11551),q=b(11593),p=b(11636),S=b(14831);class R extends S.e{constructor(U){super(E.b,U),this.config=U,this.object=this.registerDataOutput("object",E.b),this.propertyName=this.registerDataOutput("propertyName",E.b),this.setterFunction=this.registerDataOutput("setFunction",E.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",E.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",E.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new Q(U.jsonPointer,this)}_doOperation(U){var X,b,F;const E=this.templateComponent.getAccessor(this.config.pathConverter,U),w=E.info.get(E.object),Q=null===(X=(b=E.info).getTarget)||void 0===X?void 0:X.call(b,E.object),z=null===(F=E.info.getPropertyName)||void 0===F?void 0:F[0](E.object);if(!Q)throw new Error("Object is undefined");return this.object.setValue(Q,U),z&&this.propertyName.setValue(z,U),w}_setPropertyValue(U,X,b,F){var E,w;const Q=this.templateComponent.getAccessor(this.config.pathConverter,F),z=Q.info.type;z.startsWith("Color")&&(b=n(b,z)),null===(E=(w=Q.info).set)||void 0===E||E.call(w,b,Q.object)}_getPropertyValue(U,X,b){const F=this.templateComponent.getAccessor(this.config.pathConverter,b),E=F.info.type,w=F.info.get(F.object);return E.startsWith("Color")?function(U){if(U instanceof p.NX)return new q.JX(U.r,U.g,U.b);if(U instanceof p.eb)return new q.Vector4(U.r,U.g,U.b,U.a);throw new Error("Invalid color type")}(w):w}_getInterpolationAnimationPropertyInfo(U,X,b){const F=this.templateComponent.getAccessor(this.config.pathConverter,b);return(U,X,b,E)=>{var w;const Q=[],z=F.info.type;return z.startsWith("Color")&&(U=U.map((U=>({frame:U.frame,value:n(U.value,z)})))),null===(w=F.info.interpolation)||void 0===w||w.forEach(((X,w)=>{var z;const q=(null===(z=F.info.getPropertyName)||void 0===z?void 0:z[w](F.object))||"Animation-interpolation-"+w;let p=U;b!==X.type&&(p=U.map((U=>({frame:U.frame,value:X.getValue(void 0,U.value.Jb?U.value.Jb():[U.value],0,1)}))));const S=X.buildAnimations(F.object,q,60,p);for(const U of S)E&&U.babylonAnimation.setEasingFunction(E),Q.push(U.babylonAnimation)})),Q}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function n(U,X){return U.getClassName().startsWith("Color")?U:"NX"===X?new p.NX(U.x,U.y,U.z):"eb"===X?new p.eb(U.x,U.y,U.z,U.w):U}(0,z.f)("FlowGraphJsonPointerParserBlock",R)},14831:(U,X,b)=>{b.d(X,{e:()=>z});var F=b(13308),E=b(13281);const w="cachedOperationValue",Q="cachedExecutionId";class z extends F.d{constructor(U,X){super(X),this.value=this.registerDataOutput("value",U),this.isValid=this.registerDataOutput("isValid",E.e)}_updateOutputs(U){const X=U._getExecutionVariable(this,Q,-1),b=U._getExecutionVariable(this,w,null);if(void 0!==b&&null!==b&&X===U.executionId)this.isValid.setValue(!0,U),this.value.setValue(b,U);else try{const X=this._doOperation(U);if(void 0===X||null===X)return void this.isValid.setValue(!1,U);U._setExecutionVariable(this,w,X),U._setExecutionVariable(this,Q,U.executionId),this.value.setValue(X,U),this.isValid.setValue(!0,U)}catch(F){this.isValid.setValue(!1,U)}}}}}]);