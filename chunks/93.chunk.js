"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[93],{14618:(Z,x,F)=>{F.r(x),F.d(x,{FlowGraphJsonPointerParserBlock:()=>c});var u=F(12949),G=F(12954);const f=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class Y{constructor(Z,x){this.path=Z,this.ownerBlock=x,this.templatedInputs=[];let F=f.exec(Z);const Y=new Set;for(;F;){const[,j]=F;if(Y.has(j))throw new Error("Duplicate template variable detected.");Y.add(j),this.templatedInputs.push(x.registerDataInput(j,G.g,new u.d(0))),F=f.exec(Z)}}getAccessor(Z,x){let F=this.path;for(const u of this.templatedInputs){const Z=u.getValue(x).value;if("number"!==typeof Z||Z<0)throw new Error("Invalid value for templated input.");F=F.replace(`{${u.name}}`,Z.toString())}return Z.convert(F)}}var j=F(11136),d=F(11179),t=F(11230),o=F(14476);class c extends o.c{constructor(Z){super(G.d,Z),this.config=Z,this.object=this.registerDataOutput("object",G.d),this.propertyName=this.registerDataOutput("propertyName",G.d),this.setterFunction=this.registerDataOutput("setFunction",G.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",G.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",G.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new Y(Z.jsonPointer,this)}_doOperation(Z){var x,F,u;const G=this.templateComponent.getAccessor(this.config.pathConverter,Z),f=G.info.get(G.object),Y=null===(x=(F=G.info).getTarget)||void 0===x?void 0:x.call(F,G.object),j=null===(u=G.info.getPropertyName)||void 0===u?void 0:u[0](G.object);if(!Y)throw new Error("Object is undefined");return this.object.setValue(Y,Z),j&&this.propertyName.setValue(j,Z),f}_setPropertyValue(Z,x,F,u){var G,f;const Y=this.templateComponent.getAccessor(this.config.pathConverter,u),j=Y.info.type;j.startsWith("Color")&&(F=s(F,j)),null===(G=(f=Y.info).set)||void 0===G||G.call(f,F,Y.object)}_getPropertyValue(Z,x,F){const u=this.templateComponent.getAccessor(this.config.pathConverter,F),G=u.info.type,f=u.info.get(u.object);return G.startsWith("Color")?function(Z){if(Z instanceof t.Lx)return new d.kx(Z.r,Z.g,Z.b);if(Z instanceof t.kj)return new d.Vector4(Z.r,Z.g,Z.b,Z.a);throw new Error("Invalid color type")}(f):f}_getInterpolationAnimationPropertyInfo(Z,x,F){const u=this.templateComponent.getAccessor(this.config.pathConverter,F);return(Z,x,F,G)=>{var f;const Y=[],j=u.info.type;return j.startsWith("Color")&&(Z=Z.map((Z=>({frame:Z.frame,value:s(Z.value,j)})))),null===(f=u.info.interpolation)||void 0===f||f.forEach(((x,f)=>{var j;const d=(null===(j=u.info.getPropertyName)||void 0===j?void 0:j[f](u.object))||"Animation-interpolation-"+f;let t=Z;F!==x.type&&(t=Z.map((Z=>({frame:Z.frame,value:x.getValue(void 0,Z.value.Wf?Z.value.Wf():[Z.value],0,1)}))));const o=x.buildAnimations(u.object,d,60,t);for(const Z of o)G&&Z.babylonAnimation.setEasingFunction(G),Y.push(Z.babylonAnimation)})),Y}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function s(Z,x){return Z.getClassName().startsWith("Color")?Z:"Lx"===x?new t.Lx(Z.x,Z.y,Z.z):"kj"===x?new t.kj(Z.x,Z.y,Z.z,Z.w):Z}(0,j.g)("FlowGraphJsonPointerParserBlock",c)},14476:(Z,x,F)=>{F.d(x,{c:()=>j});var u=F(12977),G=F(12954);const f="cachedOperationValue",Y="cachedExecutionId";class j extends u.e{constructor(Z,x){super(x),this.value=this.registerDataOutput("value",Z),this.isValid=this.registerDataOutput("isValid",G.f)}_updateOutputs(Z){const x=Z._getExecutionVariable(this,Y,-1),F=Z._getExecutionVariable(this,f,null);if(void 0!==F&&null!==F&&x===Z.executionId)this.isValid.setValue(!0,Z),this.value.setValue(F,Z);else try{const x=this._doOperation(Z);if(void 0===x||null===x)return void this.isValid.setValue(!1,Z);Z._setExecutionVariable(this,f,x),Z._setExecutionVariable(this,Y,Z.executionId),this.value.setValue(x,Z),this.isValid.setValue(!0,Z)}catch(u){this.isValid.setValue(!1,Z)}}}}}]);