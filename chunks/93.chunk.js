"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[93],{16206:(I,x,L)=>{L.r(x),L.d(x,{FlowGraphJsonPointerParserBlock:()=>Q});var F=L(14493),X=L(14498);const G=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class Y{constructor(I,x){this.path=I,this.ownerBlock=x,this.templatedInputs=[];let L=G.exec(I);const Y=new Set;for(;L;){const[,p]=L;if(Y.has(p))throw new Error("Duplicate template variable detected.");Y.add(p),this.templatedInputs.push(x.registerDataInput(p,X.l,new F.b(0))),L=G.exec(I)}}getAccessor(I,x){let L=this.path;for(const F of this.templatedInputs){const I=F.getValue(x).value;if("number"!==typeof I||I<0)throw new Error("Invalid value for templated input.");L=L.replace(`{${F.name}}`,I.toString())}return I.convert(L)}}var p=L(12938),B=L(12983),l=L(13020),W=L(16077);class Q extends W.c{constructor(I){super(X.e,I),this.config=I,this.object=this.registerDataOutput("object",X.e),this.propertyName=this.registerDataOutput("propertyName",X.e),this.setterFunction=this.registerDataOutput("setFunction",X.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",X.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",X.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new Y(I.jsonPointer,this)}_doOperation(I){var x,L,F;const X=this.templateComponent.getAccessor(this.config.pathConverter,I),G=X.info.get(X.object),Y=null===(x=(L=X.info).getTarget)||void 0===x?void 0:x.call(L,X.object),p=null===(F=X.info.getPropertyName)||void 0===F?void 0:F[0](X.object);if(!Y)throw new Error("Object is undefined");return this.object.setValue(Y,I),p&&this.propertyName.setValue(p,I),G}_setPropertyValue(I,x,L,F){var X,G;const Y=this.templateComponent.getAccessor(this.config.pathConverter,F),p=Y.info.type;p.startsWith("Color")&&(L=e(L,p)),null===(X=(G=Y.info).set)||void 0===X||X.call(G,L,Y.object)}_getPropertyValue(I,x,L){const F=this.templateComponent.getAccessor(this.config.pathConverter,L),X=F.info.type,G=F.info.get(F.object);return X.startsWith("Color")?function(I){if(I instanceof l.Tx)return new B.sx(I.r,I.g,I.b);if(I instanceof l.lB)return new B.Vector4(I.r,I.g,I.b,I.a);throw new Error("Invalid color type")}(G):G}_getInterpolationAnimationPropertyInfo(I,x,L){const F=this.templateComponent.getAccessor(this.config.pathConverter,L);return(I,x,L,X)=>{var G;const Y=[],p=F.info.type;return p.startsWith("Color")&&(I=I.map((I=>({frame:I.frame,value:e(I.value,p)})))),null===(G=F.info.interpolation)||void 0===G||G.forEach(((x,G)=>{var p;const B=(null===(p=F.info.getPropertyName)||void 0===p?void 0:p[G](F.object))||"Animation-interpolation-"+G;let l=I;L!==x.type&&(l=I.map((I=>({frame:I.frame,value:x.getValue(void 0,I.value.Cp?I.value.Cp():[I.value],0,1)}))));const W=x.buildAnimations(F.object,B,60,l);for(const I of W)X&&I.babylonAnimation.setEasingFunction(X),Y.push(I.babylonAnimation)})),Y}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function e(I,x){return I.getClassName().startsWith("Color")?I:"Tx"===x?new l.Tx(I.x,I.y,I.z):"lB"===x?new l.lB(I.x,I.y,I.z,I.w):I}(0,p.d)("FlowGraphJsonPointerParserBlock",Q)},16077:(I,x,L)=>{L.d(x,{c:()=>p});var F=L(14514),X=L(14498);const G="cachedOperationValue",Y="cachedExecutionId";class p extends F.e{constructor(I,x){super(x),this.value=this.registerDataOutput("value",I),this.isValid=this.registerDataOutput("isValid",X.i)}_updateOutputs(I){const x=I._getExecutionVariable(this,Y,-1),L=I._getExecutionVariable(this,G,null);if(void 0!==L&&null!==L&&x===I.executionId)this.isValid.setValue(!0,I),this.value.setValue(L,I);else try{const x=this._doOperation(I);if(void 0===x||null===x)return void this.isValid.setValue(!1,I);I._setExecutionVariable(this,G,x),I._setExecutionVariable(this,Y,I.executionId),this.value.setValue(x,I),this.isValid.setValue(!0,I)}catch(F){this.isValid.setValue(!1,I)}}}}}]);