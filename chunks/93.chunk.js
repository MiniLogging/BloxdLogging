"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[93],{14461:(g,w,q)=>{q.r(w),q.d(w,{FlowGraphJsonPointerParserBlock:()=>m});var R=q(12828),o=q(12836);const r=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class S{constructor(g,w){this.path=g,this.ownerBlock=w,this.templatedInputs=[];let q=r.exec(g);const S=new Set;for(;q;){const[,i]=q;if(S.has(i))throw new Error("Duplicate template variable detected.");S.add(i),this.templatedInputs.push(w.registerDataInput(i,o.l,new R.b(0))),q=r.exec(g)}}getAccessor(g,w){let q=this.path;for(const R of this.templatedInputs){const g=R.getValue(w).value;if("number"!==typeof g||g<0)throw new Error("Invalid value for templated input.");q=q.replace(`{${R.name}}`,g.toString())}return g.convert(q)}}var i=q(11128),T=q(11180),z=q(11235),t=q(14333);class m extends t.d{constructor(g){super(o.d,g),this.config=g,this.object=this.registerDataOutput("object",o.d),this.propertyName=this.registerDataOutput("propertyName",o.d),this.setterFunction=this.registerDataOutput("setFunction",o.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",o.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",o.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new S(g.jsonPointer,this)}_doOperation(g){var w,q,R;const o=this.templateComponent.getAccessor(this.config.pathConverter,g),r=o.info.get(o.object),S=null===(w=(q=o.info).getTarget)||void 0===w?void 0:w.call(q,o.object),i=null===(R=o.info.getPropertyName)||void 0===R?void 0:R[0](o.object);if(!S)throw new Error("Object is undefined");return this.object.setValue(S,g),i&&this.propertyName.setValue(i,g),r}_setPropertyValue(g,w,q,R){var o,r;const S=this.templateComponent.getAccessor(this.config.pathConverter,R),i=S.info.type;i.startsWith("Color")&&(q=e(q,i)),null===(o=(r=S.info).set)||void 0===o||o.call(r,q,S.object)}_getPropertyValue(g,w,q){const R=this.templateComponent.getAccessor(this.config.pathConverter,q),o=R.info.type,r=R.info.get(R.object);return o.startsWith("Color")?function(g){if(g instanceof z.Jw)return new T.ew(g.r,g.g,g.b);if(g instanceof z.d)return new T.Vector4(g.r,g.g,g.b,g.a);throw new Error("Invalid color type")}(r):r}_getInterpolationAnimationPropertyInfo(g,w,q){const R=this.templateComponent.getAccessor(this.config.pathConverter,q);return(g,w,q,o)=>{var r;const S=[],i=R.info.type;return i.startsWith("Color")&&(g=g.map((g=>({frame:g.frame,value:e(g.value,i)})))),null===(r=R.info.interpolation)||void 0===r||r.forEach(((w,r)=>{var i;const T=(null===(i=R.info.getPropertyName)||void 0===i?void 0:i[r](R.object))||"Animation-interpolation-"+r;let z=g;q!==w.type&&(z=g.map((g=>({frame:g.frame,value:w.getValue(void 0,g.value.qi?g.value.qi():[g.value],0,1)}))));const t=w.buildAnimations(R.object,T,60,z);for(const g of t)o&&g.babylonAnimation.setEasingFunction(o),S.push(g.babylonAnimation)})),S}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function e(g,w){return g.getClassName().startsWith("Color")?g:"Jw"===w?new z.Jw(g.x,g.y,g.z):"ci"===w?new z.d(g.x,g.y,g.z,g.w):g}(0,i.g)("FlowGraphJsonPointerParserBlock",m)},14333:(g,w,q)=>{q.d(w,{d:()=>i});var R=q(12863),o=q(12836);const r="cachedOperationValue",S="cachedExecutionId";class i extends R.e{constructor(g,w){super(w),this.value=this.registerDataOutput("value",g),this.isValid=this.registerDataOutput("isValid",o.h)}_updateOutputs(g){const w=g._getExecutionVariable(this,S,-1),q=g._getExecutionVariable(this,r,null);if(void 0!==q&&null!==q&&w===g.executionId)this.isValid.setValue(!0,g),this.value.setValue(q,g);else try{const w=this._doOperation(g);if(void 0===w||null===w)return void this.isValid.setValue(!1,g);g._setExecutionVariable(this,r,w),g._setExecutionVariable(this,S,g.executionId),this.value.setValue(w,g),this.isValid.setValue(!0,g)}catch(R){this.isValid.setValue(!1,g)}}}}}]);