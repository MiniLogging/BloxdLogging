"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[93],{15805:(U,G,C)=>{C.r(G),C.d(G,{FlowGraphJsonPointerParserBlock:()=>T});var L=C(14130),X=C(14134);const l=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class t{constructor(U,G){this.path=U,this.ownerBlock=G,this.templatedInputs=[];let C=l.exec(U);const t=new Set;for(;C;){const[,E]=C;if(t.has(E))throw new Error("Duplicate template variable detected.");t.add(E),this.templatedInputs.push(G.registerDataInput(E,X.k,new L.c(0))),C=l.exec(U)}}getAccessor(U,G){let C=this.path;for(const L of this.templatedInputs){const U=L.getValue(G).value;if("number"!==typeof U||U<0)throw new Error("Invalid value for templated input.");C=C.replace("{".concat(L.name,"}"),U.toString())}return U.convert(C)}}var E=C(12850),K=C(12896),P=C(12934),O=C(15668);class T extends O.c{constructor(U){super(X.c,U),this.config=U,this.object=this.registerDataOutput("object",X.c),this.propertyName=this.registerDataOutput("propertyName",X.c),this.setterFunction=this.registerDataOutput("setFunction",X.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",X.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",X.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new t(U.jsonPointer,this)}_doOperation(U){var G,C,L;const X=this.templateComponent.getAccessor(this.config.pathConverter,U),l=X.info.get(X.object),t=null===(G=(C=X.info).getTarget)||void 0===G?void 0:G.call(C,X.object),E=null===(L=X.info.getPropertyName)||void 0===L?void 0:L[0](X.object);if(!t)throw new Error("Object is undefined");return this.object.setValue(t,U),E&&this.propertyName.setValue(E,U),l}_setPropertyValue(U,G,C,L){var X,l;const t=this.templateComponent.getAccessor(this.config.pathConverter,L),E=t.info.type;E.startsWith("Color")&&(C=D(C,E)),null===(X=(l=t.info).set)||void 0===X||X.call(l,C,t.object)}_getPropertyValue(U,G,C){const L=this.templateComponent.getAccessor(this.config.pathConverter,C),X=L.info.type,l=L.info.get(L.object);return X.startsWith("Color")?function(U){if(U instanceof P.hG)return new K.pG(U.r,U.g,U.b);if(U instanceof P.JE)return new K.Vector4(U.r,U.g,U.b,U.a);throw new Error("Invalid color type")}(l):l}_getInterpolationAnimationPropertyInfo(U,G,C){const L=this.templateComponent.getAccessor(this.config.pathConverter,C);return(U,G,C,X)=>{var l;const t=[],E=L.info.type;return E.startsWith("Color")&&(U=U.map((U=>({frame:U.frame,value:D(U.value,E)})))),null===(l=L.info.interpolation)||void 0===l||l.forEach(((G,l)=>{var E;const K=(null===(E=L.info.getPropertyName)||void 0===E?void 0:E[l](L.object))||"Animation-interpolation-"+l;let P=U;C!==G.type&&(P=U.map((U=>({frame:U.frame,value:G.getValue(void 0,U.value.sE?U.value.sE():[U.value],0,1)}))));const O=G.buildAnimations(L.object,K,60,P);for(const U of O)X&&U.babylonAnimation.setEasingFunction(X),t.push(U.babylonAnimation)})),t}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function D(U,G){return U.getClassName().startsWith("Color")?U:"hG"===G?new P.hG(U.x,U.y,U.z):"JE"===G?new P.JE(U.x,U.y,U.z,U.w):U}(0,E.e)("FlowGraphJsonPointerParserBlock",T)},15668:(U,G,C)=>{C.d(G,{c:()=>E});var L=C(14154),X=C(14134);const l="cachedOperationValue",t="cachedExecutionId";class E extends L.b{constructor(U,G){super(G),this.value=this.registerDataOutput("value",U),this.isValid=this.registerDataOutput("isValid",X.g)}_updateOutputs(U){const G=U._getExecutionVariable(this,t,-1),C=U._getExecutionVariable(this,l,null);if(void 0!==C&&null!==C&&G===U.executionId)this.isValid.setValue(!0,U),this.value.setValue(C,U);else try{const G=this._doOperation(U);if(void 0===G||null===G)return void this.isValid.setValue(!1,U);U._setExecutionVariable(this,l,G),U._setExecutionVariable(this,t,U.executionId),this.value.setValue(G,U),this.isValid.setValue(!0,U)}catch(L){this.isValid.setValue(!1,U)}}}}}]);