"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[93],{14531:(h,V,i)=>{i.r(V),i.d(V,{FlowGraphJsonPointerParserBlock:()=>v});var S=i(12800),l=i(12805);const Y=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class g{constructor(h,V){this.path=h,this.ownerBlock=V,this.templatedInputs=[];let i=Y.exec(h);const g=new Set;for(;i;){const[,q]=i;if(g.has(q))throw new Error("Duplicate template variable detected.");g.add(q),this.templatedInputs.push(V.registerDataInput(q,l.i,new S.b(0))),i=Y.exec(h)}}getAccessor(h,V){let i=this.path;for(const S of this.templatedInputs){const h=S.getValue(V).value;if("number"!==typeof h||h<0)throw new Error("Invalid value for templated input.");i=i.replace(`{${S.name}}`,h.toString())}return h.convert(i)}}var q=i(11091),B=i(11138),J=i(11189),I=i(14382);class v extends I.d{constructor(h){super(l.c,h),this.config=h,this.object=this.registerDataOutput("object",l.c),this.propertyName=this.registerDataOutput("propertyName",l.c),this.setterFunction=this.registerDataOutput("setFunction",l.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",l.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",l.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new g(h.jsonPointer,this)}_doOperation(h){var V,i,S;const l=this.templateComponent.getAccessor(this.config.pathConverter,h),Y=l.info.get(l.object),g=null===(V=(i=l.info).getTarget)||void 0===V?void 0:V.call(i,l.object),q=null===(S=l.info.getPropertyName)||void 0===S?void 0:S[0](l.object);if(!g)throw new Error("Object is undefined");return this.object.setValue(g,h),q&&this.propertyName.setValue(q,h),Y}_setPropertyValue(h,V,i,S){var l,Y;const g=this.templateComponent.getAccessor(this.config.pathConverter,S),q=g.info.type;q.startsWith("Color")&&(i=s(i,q)),null===(l=(Y=g.info).set)||void 0===l||l.call(Y,i,g.object)}_getPropertyValue(h,V,i){const S=this.templateComponent.getAccessor(this.config.pathConverter,i),l=S.info.type,Y=S.info.get(S.object);return l.startsWith("Color")?function(h){if(h instanceof J.LV)return new B.nV(h.r,h.g,h.b);if(h instanceof J.vq)return new B.Vector4(h.r,h.g,h.b,h.a);throw new Error("Invalid color type")}(Y):Y}_getInterpolationAnimationPropertyInfo(h,V,i){const S=this.templateComponent.getAccessor(this.config.pathConverter,i);return(h,V,i,l)=>{var Y;const g=[],q=S.info.type;return q.startsWith("Color")&&(h=h.map((h=>({frame:h.frame,value:s(h.value,q)})))),null===(Y=S.info.interpolation)||void 0===Y||Y.forEach(((V,Y)=>{var q;const B=(null===(q=S.info.getPropertyName)||void 0===q?void 0:q[Y](S.object))||"Animation-interpolation-"+Y;let J=h;i!==V.type&&(J=h.map((h=>({frame:h.frame,value:V.getValue(void 0,h.value.Ng?h.value.Ng():[h.value],0,1)}))));const I=V.buildAnimations(S.object,B,60,J);for(const h of I)l&&h.babylonAnimation.setEasingFunction(l),g.push(h.babylonAnimation)})),g}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function s(h,V){return h.getClassName().startsWith("Color")?h:"LV"===V?new J.LV(h.x,h.y,h.z):"vq"===V?new J.vq(h.x,h.y,h.z,h.w):h}(0,q.f)("FlowGraphJsonPointerParserBlock",v)},14382:(h,V,i)=>{i.d(V,{d:()=>q});var S=i(12827),l=i(12805);const Y="cachedOperationValue",g="cachedExecutionId";class q extends S.c{constructor(h,V){super(V),this.value=this.registerDataOutput("value",h),this.isValid=this.registerDataOutput("isValid",l.f)}_updateOutputs(h){const V=h._getExecutionVariable(this,g,-1),i=h._getExecutionVariable(this,Y,null);if(void 0!==i&&null!==i&&V===h.executionId)this.isValid.setValue(!0,h),this.value.setValue(i,h);else try{const V=this._doOperation(h);if(void 0===V||null===V)return void this.isValid.setValue(!1,h);h._setExecutionVariable(this,Y,V),h._setExecutionVariable(this,g,h.executionId),this.value.setValue(V,h),this.isValid.setValue(!0,h)}catch(S){this.isValid.setValue(!1,h)}}}}}]);