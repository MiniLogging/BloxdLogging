"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[93],{14571:(P,f,Y)=>{Y.r(f),Y.d(f,{FlowGraphJsonPointerParserBlock:()=>y});var C=Y(12908),q=Y(12917);const m=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class L{constructor(P,f){this.path=P,this.ownerBlock=f,this.templatedInputs=[];let Y=m.exec(P);const L=new Set;for(;Y;){const[,o]=Y;if(L.has(o))throw new Error("Duplicate template variable detected.");L.add(o),this.templatedInputs.push(f.registerDataInput(o,q.f,new C.c(0))),Y=m.exec(P)}}getAccessor(P,f){let Y=this.path;for(const C of this.templatedInputs){const P=C.getValue(f).value;if("number"!==typeof P||P<0)throw new Error("Invalid value for templated input.");Y=Y.replace(`{${C.name}}`,P.toString())}return P.convert(Y)}}var o=Y(11134),w=Y(11179),d=Y(11228),R=Y(14410);class y extends R.c{constructor(P){super(q.d,P),this.config=P,this.object=this.registerDataOutput("object",q.d),this.propertyName=this.registerDataOutput("propertyName",q.d),this.setterFunction=this.registerDataOutput("setFunction",q.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",q.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",q.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new L(P.jsonPointer,this)}_doOperation(P){var f,Y,C;const q=this.templateComponent.getAccessor(this.config.pathConverter,P),m=q.info.get(q.object),L=null===(f=(Y=q.info).getTarget)||void 0===f?void 0:f.call(Y,q.object),o=null===(C=q.info.getPropertyName)||void 0===C?void 0:C[0](q.object);if(!L)throw new Error("Object is undefined");return this.object.setValue(L,P),o&&this.propertyName.setValue(o,P),m}_setPropertyValue(P,f,Y,C){var q,m;const L=this.templateComponent.getAccessor(this.config.pathConverter,C),o=L.info.type;o.startsWith("Color")&&(Y=r(Y,o)),null===(q=(m=L.info).set)||void 0===q||q.call(m,Y,L.object)}_getPropertyValue(P,f,Y){const C=this.templateComponent.getAccessor(this.config.pathConverter,Y),q=C.info.type,m=C.info.get(C.object);return q.startsWith("Color")?function(P){if(P instanceof d.Df)return new w.Of(P.r,P.g,P.b);if(P instanceof d.ro)return new w.Vector4(P.r,P.g,P.b,P.a);throw new Error("Invalid color type")}(m):m}_getInterpolationAnimationPropertyInfo(P,f,Y){const C=this.templateComponent.getAccessor(this.config.pathConverter,Y);return(P,f,Y,q)=>{var m;const L=[],o=C.info.type;return o.startsWith("Color")&&(P=P.map((P=>({frame:P.frame,value:r(P.value,o)})))),null===(m=C.info.interpolation)||void 0===m||m.forEach(((f,m)=>{var o;const w=(null===(o=C.info.getPropertyName)||void 0===o?void 0:o[m](C.object))||"Animation-interpolation-"+m;let d=P;Y!==f.type&&(d=P.map((P=>({frame:P.frame,value:f.getValue(void 0,P.value.If?P.value.If():[P.value],0,1)}))));const R=f.buildAnimations(C.object,w,60,d);for(const P of R)q&&P.babylonAnimation.setEasingFunction(q),L.push(P.babylonAnimation)})),L}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function r(P,f){return P.getClassName().startsWith("Color")?P:"Df"===f?new d.Df(P.x,P.y,P.z):"ro"===f?new d.ro(P.x,P.y,P.z,P.w):P}(0,o.d)("FlowGraphJsonPointerParserBlock",y)},14410:(P,f,Y)=>{Y.d(f,{c:()=>o});var C=Y(12947),q=Y(12917);const m="cachedOperationValue",L="cachedExecutionId";class o extends C.b{constructor(P,f){super(f),this.value=this.registerDataOutput("value",P),this.isValid=this.registerDataOutput("isValid",q.e)}_updateOutputs(P){const f=P._getExecutionVariable(this,L,-1),Y=P._getExecutionVariable(this,m,null);if(void 0!==Y&&null!==Y&&f===P.executionId)this.isValid.setValue(!0,P),this.value.setValue(Y,P);else try{const f=this._doOperation(P);if(void 0===f||null===f)return void this.isValid.setValue(!1,P);P._setExecutionVariable(this,m,f),P._setExecutionVariable(this,L,P.executionId),this.value.setValue(f,P),this.isValid.setValue(!0,P)}catch(C){this.isValid.setValue(!1,P)}}}}}]);