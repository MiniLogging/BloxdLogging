"use strict";(self.g111kvdsqxc=self.g111kvdsqxc||[]).push([[93],{14641:(K,H,M)=>{M.r(H),M.d(H,{FlowGraphJsonPointerParserBlock:()=>z});var q=M(12996),w=M(13004);const u=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class y{constructor(K,H){this.path=K,this.ownerBlock=H,this.templatedInputs=[];let M=u.exec(K);const y=new Set;for(;M;){const[,h]=M;if(y.has(h))throw new Error("Duplicate template variable detected.");y.add(h),this.templatedInputs.push(H.registerDataInput(h,w.l,new q.e(0))),M=u.exec(K)}}getAccessor(K,H){let M=this.path;for(const q of this.templatedInputs){const K=q.getValue(H).value;if("number"!==typeof K||K<0)throw new Error("Invalid value for templated input.");M=M.replace(`{${q.name}}`,K.toString())}return K.convert(M)}}var h=M(11242),W=M(11290),I=M(11329),f=M(14485);class z extends f.b{constructor(K){super(w.d,K),this.config=K,this.object=this.registerDataOutput("object",w.d),this.propertyName=this.registerDataOutput("propertyName",w.d),this.setterFunction=this.registerDataOutput("setFunction",w.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",w.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",w.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new y(K.jsonPointer,this)}_doOperation(K){var H,M,q;const w=this.templateComponent.getAccessor(this.config.pathConverter,K),u=w.info.get(w.object),y=null===(H=(M=w.info).getTarget)||void 0===H?void 0:H.call(M,w.object),h=null===(q=w.info.getPropertyName)||void 0===q?void 0:q[0](w.object);if(!y)throw new Error("Object is undefined");return this.object.setValue(y,K),h&&this.propertyName.setValue(h,K),u}_setPropertyValue(K,H,M,q){var w,u;const y=this.templateComponent.getAccessor(this.config.pathConverter,q),h=y.info.type;h.startsWith("Color")&&(M=G(M,h)),null===(w=(u=y.info).set)||void 0===w||w.call(u,M,y.object)}_getPropertyValue(K,H,M){const q=this.templateComponent.getAccessor(this.config.pathConverter,M),w=q.info.type,u=q.info.get(q.object);return w.startsWith("Color")?function(K){if(K instanceof I.CH)return new W.OH(K.r,K.g,K.b);if(K instanceof I.Ch)return new W.Vector4(K.r,K.g,K.b,K.a);throw new Error("Invalid color type")}(u):u}_getInterpolationAnimationPropertyInfo(K,H,M){const q=this.templateComponent.getAccessor(this.config.pathConverter,M);return(K,H,M,w)=>{var u;const y=[],h=q.info.type;return h.startsWith("Color")&&(K=K.map((K=>({frame:K.frame,value:G(K.value,h)})))),null===(u=q.info.interpolation)||void 0===u||u.forEach(((H,u)=>{var h;const W=(null===(h=q.info.getPropertyName)||void 0===h?void 0:h[u](q.object))||"Animation-interpolation-"+u;let I=K;M!==H.type&&(I=K.map((K=>({frame:K.frame,value:H.getValue(void 0,K.value.hh?K.value.hh():[K.value],0,1)}))));const f=H.buildAnimations(q.object,W,60,I);for(const K of f)w&&K.babylonAnimation.setEasingFunction(w),y.push(K.babylonAnimation)})),y}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function G(K,H){return K.getClassName().startsWith("Color")?K:"CH"===H?new I.CH(K.x,K.y,K.z):"Ch"===H?new I.Ch(K.x,K.y,K.z,K.w):K}(0,h.f)("FlowGraphJsonPointerParserBlock",z)},14485:(K,H,M)=>{M.d(H,{b:()=>h});var q=M(13021),w=M(13004);const u="cachedOperationValue",y="cachedExecutionId";class h extends q.b{constructor(K,H){super(H),this.value=this.registerDataOutput("value",K),this.isValid=this.registerDataOutput("isValid",w.h)}_updateOutputs(K){const H=K._getExecutionVariable(this,y,-1),M=K._getExecutionVariable(this,u,null);if(void 0!==M&&null!==M&&H===K.executionId)this.isValid.setValue(!0,K),this.value.setValue(M,K);else try{const H=this._doOperation(K);if(void 0===H||null===H)return void this.isValid.setValue(!1,K);K._setExecutionVariable(this,u,H),K._setExecutionVariable(this,y,K.executionId),this.value.setValue(H,K),this.isValid.setValue(!0,K)}catch(q){this.isValid.setValue(!1,K)}}}}}]);