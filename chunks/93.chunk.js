"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[93],{15748:(M,Z,P)=>{P.r(Z),P.d(Z,{FlowGraphJsonPointerParserBlock:()=>O});var x=P(14067),c=P(14073);const w=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class v{constructor(M,Z){this.path=M,this.ownerBlock=Z,this.templatedInputs=[];let P=w.exec(M);const v=new Set;for(;P;){const[,G]=P;if(v.has(G))throw new Error("Duplicate template variable detected.");v.add(G),this.templatedInputs.push(Z.registerDataInput(G,c.j,new x.e(0))),P=w.exec(M)}}getAccessor(M,Z){let P=this.path;for(const x of this.templatedInputs){const M=x.getValue(Z).value;if("number"!==typeof M||M<0)throw new Error("Invalid value for templated input.");P=P.replace(`{${x.name}}`,M.toString())}return M.convert(P)}}var G=P(12317),mM=P(12373),K=P(12406),d=P(15610);class O extends d.e{constructor(M){super(c.e,M),this.config=M,this.object=this.registerDataOutput("object",c.e),this.propertyName=this.registerDataOutput("propertyName",c.e),this.setterFunction=this.registerDataOutput("setFunction",c.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",c.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",c.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new v(M.jsonPointer,this)}_doOperation(M){var Z,P,x;const c=this.templateComponent.getAccessor(this.config.pathConverter,M),w=c.info.get(c.object),v=null===(Z=(P=c.info).getTarget)||void 0===Z?void 0:Z.call(P,c.object),G=null===(x=c.info.getPropertyName)||void 0===x?void 0:x[0](c.object);if(!v)throw new Error("Object is undefined");return this.object.setValue(v,M),G&&this.propertyName.setValue(G,M),w}_setPropertyValue(M,Z,P,x){var c,w;const v=this.templateComponent.getAccessor(this.config.pathConverter,x),G=v.info.type;G.startsWith("Color")&&(P=H(P,G)),null===(c=(w=v.info).set)||void 0===c||c.call(w,P,v.object)}_getPropertyValue(M,Z,P){const x=this.templateComponent.getAccessor(this.config.pathConverter,P),c=x.info.type,w=x.info.get(x.object);return c.startsWith("Color")?function(M){if(M instanceof K.uZ)return new mM.BZ(M.r,M.g,M.b);if(M instanceof K.Ic)return new mM.Vector4(M.r,M.g,M.b,M.a);throw new Error("Invalid color type")}(w):w}_getInterpolationAnimationPropertyInfo(M,Z,P){const x=this.templateComponent.getAccessor(this.config.pathConverter,P);return(M,Z,P,c)=>{var w;const v=[],G=x.info.type;return G.startsWith("Color")&&(M=M.map((M=>({frame:M.frame,value:H(M.value,G)})))),null===(w=x.info.interpolation)||void 0===w||w.forEach(((Z,w)=>{var G;const mM=(null===(G=x.info.getPropertyName)||void 0===G?void 0:G[w](x.object))||"Animation-interpolation-"+w;let K=M;P!==Z.type&&(K=M.map((M=>({frame:M.frame,value:Z.getValue(void 0,M.value.nc?M.value.nc():[M.value],0,1)}))));const d=Z.buildAnimations(x.object,mM,60,K);for(const M of d)c&&M.babylonAnimation.setEasingFunction(c),v.push(M.babylonAnimation)})),v}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function H(M,Z){return M.getClassName().startsWith("Color")?M:"uZ"===Z?new K.uZ(M.x,M.y,M.z):"Ic"===Z?new K.Ic(M.x,M.y,M.z,M.w):M}(0,G.g)("FlowGraphJsonPointerParserBlock",O)},15610:(M,Z,P)=>{P.d(Z,{e:()=>G});var x=P(14093),c=P(14073);const w="cachedOperationValue",v="cachedExecutionId";class G extends x.c{constructor(M,Z){super(Z),this.value=this.registerDataOutput("value",M),this.isValid=this.registerDataOutput("isValid",c.g)}_updateOutputs(M){const Z=M._getExecutionVariable(this,v,-1),P=M._getExecutionVariable(this,w,null);if(void 0!==P&&null!==P&&Z===M.executionId)this.isValid.setValue(!0,M),this.value.setValue(P,M);else try{const Z=this._doOperation(M);if(void 0===Z||null===Z)return void this.isValid.setValue(!1,M);M._setExecutionVariable(this,w,Z),M._setExecutionVariable(this,v,M.executionId),this.value.setValue(Z,M),this.isValid.setValue(!0,M)}catch(x){this.isValid.setValue(!1,M)}}}}}]);