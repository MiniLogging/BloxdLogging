"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[93],{14609:(o,H,n)=>{n.r(H),n.d(H,{FlowGraphJsonPointerParserBlock:()=>c});var E=n(12929),k=n(12933);const g=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class O{constructor(o,H){this.path=o,this.ownerBlock=H,this.templatedInputs=[];let n=g.exec(o);const O=new Set;for(;n;){const[,Y]=n;if(O.has(Y))throw new Error("Duplicate template variable detected.");O.add(Y),this.templatedInputs.push(H.registerDataInput(Y,k.e,new E.c(0))),n=g.exec(o)}}getAccessor(o,H){let n=this.path;for(const E of this.templatedInputs){const o=E.getValue(H).value;if("number"!==typeof o||o<0)throw new Error("Invalid value for templated input.");n=n.replace(`{${E.name}}`,o.toString())}return o.convert(n)}}var Y=n(11140),y=n(11189),S=n(11238),G=n(14464);class c extends G.d{constructor(o){super(k.b,o),this.config=o,this.object=this.registerDataOutput("object",k.b),this.propertyName=this.registerDataOutput("propertyName",k.b),this.setterFunction=this.registerDataOutput("setFunction",k.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",k.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",k.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new O(o.jsonPointer,this)}_doOperation(o){var H,n,E;const k=this.templateComponent.getAccessor(this.config.pathConverter,o),g=k.info.get(k.object),O=null===(H=(n=k.info).getTarget)||void 0===H?void 0:H.call(n,k.object),Y=null===(E=k.info.getPropertyName)||void 0===E?void 0:E[0](k.object);if(!O)throw new Error("Object is undefined");return this.object.setValue(O,o),Y&&this.propertyName.setValue(Y,o),g}_setPropertyValue(o,H,n,E){var k,g;const O=this.templateComponent.getAccessor(this.config.pathConverter,E),Y=O.info.type;Y.startsWith("Color")&&(n=A(n,Y)),null===(k=(g=O.info).set)||void 0===k||k.call(g,n,O.object)}_getPropertyValue(o,H,n){const E=this.templateComponent.getAccessor(this.config.pathConverter,n),k=E.info.type,g=E.info.get(E.object);return k.startsWith("Color")?function(o){if(o instanceof S.NH)return new y.xH(o.r,o.g,o.b);if(o instanceof S.d)return new y.Vector4(o.r,o.g,o.b,o.a);throw new Error("Invalid color type")}(g):g}_getInterpolationAnimationPropertyInfo(o,H,n){const E=this.templateComponent.getAccessor(this.config.pathConverter,n);return(o,H,n,k)=>{var g;const O=[],Y=E.info.type;return Y.startsWith("Color")&&(o=o.map((o=>({frame:o.frame,value:A(o.value,Y)})))),null===(g=E.info.interpolation)||void 0===g||g.forEach(((H,g)=>{var Y;const y=(null===(Y=E.info.getPropertyName)||void 0===Y?void 0:Y[g](E.object))||"Animation-interpolation-"+g;let S=o;n!==H.type&&(S=o.map((o=>({frame:o.frame,value:H.getValue(void 0,o.value.bg?o.value.bg():[o.value],0,1)}))));const G=H.buildAnimations(E.object,y,60,S);for(const o of G)k&&o.babylonAnimation.setEasingFunction(k),O.push(o.babylonAnimation)})),O}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function A(o,H){return o.getClassName().startsWith("Color")?o:"NH"===H?new S.NH(o.x,o.y,o.z):"dY"===H?new S.d(o.x,o.y,o.z,o.w):o}(0,Y.e)("FlowGraphJsonPointerParserBlock",c)},14464:(o,H,n)=>{n.d(H,{d:()=>Y});var E=n(12956),k=n(12933);const g="cachedOperationValue",O="cachedExecutionId";class Y extends E.c{constructor(o,H){super(H),this.value=this.registerDataOutput("value",o),this.isValid=this.registerDataOutput("isValid",k.d)}_updateOutputs(o){const H=o._getExecutionVariable(this,O,-1),n=o._getExecutionVariable(this,g,null);if(void 0!==n&&null!==n&&H===o.executionId)this.isValid.setValue(!0,o),this.value.setValue(n,o);else try{const H=this._doOperation(o);if(void 0===H||null===H)return void this.isValid.setValue(!1,o);o._setExecutionVariable(this,g,H),o._setExecutionVariable(this,O,o.executionId),this.value.setValue(H,o),this.isValid.setValue(!0,o)}catch(E){this.isValid.setValue(!1,o)}}}}}]);