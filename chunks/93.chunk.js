"use strict";(self.gpkvekif0vo=self.gpkvekif0vo||[]).push([[93],{15768:(a,O,i)=>{i.r(O),i.d(O,{FlowGraphJsonPointerParserBlock:()=>e});var H=i(14115),b=i(14124);const G=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class q{constructor(a,O){this.path=a,this.ownerBlock=O,this.templatedInputs=[];let i=G.exec(a);const q=new Set;for(;i;){const[,Q]=i;if(q.has(Q))throw new Error("Duplicate template variable detected.");q.add(Q),this.templatedInputs.push(O.registerDataInput(Q,b.l,new H.d(0))),i=G.exec(a)}}getAccessor(a,O){let i=this.path;for(const H of this.templatedInputs){const a=H.getValue(O).value;if("number"!==typeof a||a<0)throw new Error("Invalid value for templated input.");i=i.replace(`{${H.name}}`,a.toString())}return a.convert(i)}}var Q=i(12346),k=i(12395),I=i(12436),P=i(15631);class e extends P.b{constructor(a){super(b.e,a),this.config=a,this.object=this.registerDataOutput("object",b.e),this.propertyName=this.registerDataOutput("propertyName",b.e),this.setterFunction=this.registerDataOutput("setFunction",b.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",b.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",b.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new q(a.jsonPointer,this)}_doOperation(a){var O,i,H;const b=this.templateComponent.getAccessor(this.config.pathConverter,a),G=b.info.get(b.object),q=null===(O=(i=b.info).getTarget)||void 0===O?void 0:O.call(i,b.object),Q=null===(H=b.info.getPropertyName)||void 0===H?void 0:H[0](b.object);if(!q)throw new Error("Object is undefined");return this.object.setValue(q,a),Q&&this.propertyName.setValue(Q,a),G}_setPropertyValue(a,O,i,H){var b,G;const q=this.templateComponent.getAccessor(this.config.pathConverter,H),Q=q.info.type;Q.startsWith("Color")&&(i=h(i,Q)),null===(b=(G=q.info).set)||void 0===b||b.call(G,i,q.object)}_getPropertyValue(a,O,i){const H=this.templateComponent.getAccessor(this.config.pathConverter,i),b=H.info.type,G=H.info.get(H.object);return b.startsWith("Color")?function(a){if(a instanceof I.mi)return new k.ZO(a.r,a.g,a.b);if(a instanceof I.Ab)return new k.Vector4(a.r,a.g,a.b,a.a);throw new Error("Invalid color type")}(G):G}_getInterpolationAnimationPropertyInfo(a,O,i){const H=this.templateComponent.getAccessor(this.config.pathConverter,i);return(a,O,i,b)=>{var G;const q=[],Q=H.info.type;return Q.startsWith("Color")&&(a=a.map((a=>({frame:a.frame,value:h(a.value,Q)})))),null===(G=H.info.interpolation)||void 0===G||G.forEach(((O,G)=>{var Q;const k=(null===(Q=H.info.getPropertyName)||void 0===Q?void 0:Q[G](H.object))||"Animation-interpolation-"+G;let I=a;i!==O.type&&(I=a.map((a=>({frame:a.frame,value:O.getValue(void 0,a.value.Cb?a.value.Cb():[a.value],0,1)}))));const P=O.buildAnimations(H.object,k,60,I);for(const a of P)b&&a.babylonAnimation.setEasingFunction(b),q.push(a.babylonAnimation)})),q}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function h(a,O){return a.getClassName().startsWith("Color")?a:"mi"===O?new I.mi(a.x,a.y,a.z):"Ab"===O?new I.Ab(a.x,a.y,a.z,a.w):a}(0,Q.h)("FlowGraphJsonPointerParserBlock",e)},15631:(a,O,i)=>{i.d(O,{b:()=>Q});var H=i(14139),b=i(14124);const G="cachedOperationValue",q="cachedExecutionId";class Q extends H.c{constructor(a,O){super(O),this.value=this.registerDataOutput("value",a),this.isValid=this.registerDataOutput("isValid",b.h)}_updateOutputs(a){const O=a._getExecutionVariable(this,q,-1),i=a._getExecutionVariable(this,G,null);if(void 0!==i&&null!==i&&O===a.executionId)this.isValid.setValue(!0,a),this.value.setValue(i,a);else try{const O=this._doOperation(a);if(void 0===O||null===O)return void this.isValid.setValue(!1,a);a._setExecutionVariable(this,G,O),a._setExecutionVariable(this,q,a.executionId),this.value.setValue(O,a),this.isValid.setValue(!0,a)}catch(H){this.isValid.setValue(!1,a)}}}}}]);