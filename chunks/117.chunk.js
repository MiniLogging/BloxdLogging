"use strict";(self.v2pspxy442l=self.v2pspxy442l||[]).push([[117],{15819:(l,a,N)=>{N.r(a),N.d(a,{EasingFunctionType:()=>U,FlowGraphEasingBlock:()=>S});var U,c=N(14599),K=N(14171),Z=N(14145),w=N(12394);!function(l){l[l.CircleEase=0]="CircleEase",l[l.BackEase=1]="BackEase",l[l.BounceEase=2]="BounceEase",l[l.CubicEase=3]="CubicEase",l[l.ElasticEase=4]="ElasticEase",l[l.ExponentialEase=5]="ExponentialEase",l[l.PowerEase=6]="PowerEase",l[l.QuadraticEase=7]="QuadraticEase",l[l.QuarticEase=8]="QuarticEase",l[l.QuinticEase=9]="QuinticEase",l[l.SineEase=10]="SineEase",l[l.BezierCurveEase=11]="BezierCurveEase"}(U||(U={}));class S extends K.e{constructor(l){super(l),this.config=l,this._easingFunctions={},this.type=this.registerDataInput("type",Z.d,11),this.mode=this.registerDataInput("mode",Z.t,0),this.parameters=this.registerDataInput("parameters",Z.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",Z.d)}_updateOutputs(l){const a=this.type.getValue(l),N=this.mode.getValue(l),U=this.parameters.getValue(l);if(void 0===a||void 0===N)return;const K=`${a}-${N}-${U.join("-")}`;if(!this._easingFunctions[K]){const l=function(l){for(var a=arguments.length,N=new Array(a>1?a-1:0),U=1;U<a;U++)N[U-1]=arguments[U];switch(l){case 11:return new c.f(...N);case 0:return new c.i;case 1:return new c.e(...N);case 2:return new c.h(...N);case 3:return new c.j;case 4:return new c.q(...N);case 5:return new c.t(...N);default:throw new Error("Easing type not yet implemented")}}(a,...U);l.setEasingMode(N),this._easingFunctions[K]=l}this.easingFunction.setValue(this._easingFunctions[K],l)}getClassName(){return"FlowGraphEasingBlock"}}(0,w.g)("FlowGraphEasingBlock",S)}}]);