"use strict";(self["9x1utqq1axc"]=self["9x1utqq1axc"]||[]).push([[117],{15683:(y,c,A)=>{A.r(c),A.d(c,{EasingFunctionType:()=>l,FlowGraphEasingBlock:()=>h});var l,w=A(14473),N=A(14010),p=A(13993),W=A(12283);!function(y){y[y.CircleEase=0]="CircleEase",y[y.BackEase=1]="BackEase",y[y.BounceEase=2]="BounceEase",y[y.CubicEase=3]="CubicEase",y[y.ElasticEase=4]="ElasticEase",y[y.ExponentialEase=5]="ExponentialEase",y[y.PowerEase=6]="PowerEase",y[y.QuadraticEase=7]="QuadraticEase",y[y.QuarticEase=8]="QuarticEase",y[y.QuinticEase=9]="QuinticEase",y[y.SineEase=10]="SineEase",y[y.BezierCurveEase=11]="BezierCurveEase"}(l||(l={}));class h extends N.e{constructor(y){super(y),this.config=y,this._easingFunctions={},this.type=this.registerDataInput("type",p.e,11),this.mode=this.registerDataInput("mode",p.s,0),this.parameters=this.registerDataInput("parameters",p.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",p.e)}_updateOutputs(y){const c=this.type.getValue(y),A=this.mode.getValue(y),l=this.parameters.getValue(y);if(void 0===c||void 0===A)return;const N=`${c}-${A}-${l.join("-")}`;if(!this._easingFunctions[N]){const y=function(y){for(var c=arguments.length,A=new Array(c>1?c-1:0),l=1;l<c;l++)A[l-1]=arguments[l];switch(y){case 11:return new w.f(...A);case 0:return new w.h;case 1:return new w.e(...A);case 2:return new w.g(...A);case 3:return new w.i;case 4:return new w.m(...A);case 5:return new w.n(...A);default:throw new Error("Easing type not yet implemented")}}(c,...l);y.setEasingMode(A),this._easingFunctions[N]=y}this.easingFunction.setValue(this._easingFunctions[N],y)}getClassName(){return"FlowGraphEasingBlock"}}(0,W.f)("FlowGraphEasingBlock",h)}}]);