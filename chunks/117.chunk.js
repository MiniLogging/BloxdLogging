"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[117],{14551:(R,J,B)=>{B.r(J),B.d(J,{EasingFunctionType:()=>Q,FlowGraphEasingBlock:()=>q});var Q,h=B(13361),y=B(12922),N=B(12894),r=B(11142);!function(R){R[R.CircleEase=0]="CircleEase",R[R.BackEase=1]="BackEase",R[R.BounceEase=2]="BounceEase",R[R.CubicEase=3]="CubicEase",R[R.ElasticEase=4]="ElasticEase",R[R.ExponentialEase=5]="ExponentialEase",R[R.PowerEase=6]="PowerEase",R[R.QuadraticEase=7]="QuadraticEase",R[R.QuarticEase=8]="QuarticEase",R[R.QuinticEase=9]="QuinticEase",R[R.SineEase=10]="SineEase",R[R.BezierCurveEase=11]="BezierCurveEase"}(Q||(Q={}));class q extends y.c{constructor(R){super(R),this.config=R,this._easingFunctions={},this.type=this.registerDataInput("type",N.e,11),this.mode=this.registerDataInput("mode",N.t,0),this.parameters=this.registerDataInput("parameters",N.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",N.e)}_updateOutputs(R){const J=this.type.getValue(R),B=this.mode.getValue(R),Q=this.parameters.getValue(R);if(void 0===J||void 0===B)return;const y=`${J}-${B}-${Q.join("-")}`;if(!this._easingFunctions[y]){const R=function(R){for(var J=arguments.length,B=new Array(J>1?J-1:0),Q=1;Q<J;Q++)B[Q-1]=arguments[Q];switch(R){case 11:return new h.g(...B);case 0:return new h.m;case 1:return new h.c(...B);case 2:return new h.k(...B);case 3:return new h.p;case 4:return new h.u(...B);case 5:return new h.y(...B);default:throw new Error("Easing type not yet implemented")}}(J,...Q);R.setEasingMode(B),this._easingFunctions[y]=R}this.easingFunction.setValue(this._easingFunctions[y],R)}getClassName(){return"FlowGraphEasingBlock"}}(0,r.h)("FlowGraphEasingBlock",q)}}]);