"use strict";(self.hwpa2z1pqte=self.hwpa2z1pqte||[]).push([[117],{16338:(h,R,l)=>{l.r(R),l.d(R,{EasingFunctionType:()=>j,FlowGraphEasingBlock:()=>w});var j,a=l(15084),D=l(14620),U=l(14597),F=l(12852);!function(h){h[h.CircleEase=0]="CircleEase",h[h.BackEase=1]="BackEase",h[h.BounceEase=2]="BounceEase",h[h.CubicEase=3]="CubicEase",h[h.ElasticEase=4]="ElasticEase",h[h.ExponentialEase=5]="ExponentialEase",h[h.PowerEase=6]="PowerEase",h[h.QuadraticEase=7]="QuadraticEase",h[h.QuarticEase=8]="QuarticEase",h[h.QuinticEase=9]="QuinticEase",h[h.SineEase=10]="SineEase",h[h.BezierCurveEase=11]="BezierCurveEase"}(j||(j={}));class w extends D.e{constructor(h){super(h),this.config=h,this._easingFunctions={},this.type=this.registerDataInput("type",U.c,11),this.mode=this.registerDataInput("mode",U.r,0),this.parameters=this.registerDataInput("parameters",U.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",U.c)}_updateOutputs(h){const R=this.type.getValue(h),l=this.mode.getValue(h),j=this.parameters.getValue(h);if(void 0===R||void 0===l)return;const D=`${R}-${l}-${j.join("-")}`;if(!this._easingFunctions[D]){const h=function(h){for(var R=arguments.length,l=new Array(R>1?R-1:0),j=1;j<R;j++)l[j-1]=arguments[j];switch(h){case 11:return new a.g(...l);case 0:return new a.l;case 1:return new a.e(...l);case 2:return new a.k(...l);case 3:return new a.m;case 4:return new a.u(...l);case 5:return new a.y(...l);default:throw new Error("Easing type not yet implemented")}}(R,...j);h.setEasingMode(l),this._easingFunctions[D]=h}this.easingFunction.setValue(this._easingFunctions[D],h)}getClassName(){return"FlowGraphEasingBlock"}}(0,F.f)("FlowGraphEasingBlock",w)}}]);