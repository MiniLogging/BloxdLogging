"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[117],{16054:(K,A,T)=>{T.r(A),T.d(A,{EasingFunctionType:()=>G,FlowGraphEasingBlock:()=>C});var G,B=T(14867),L=T(14262),f=T(14237),O=T(12651);!function(K){K[K.CircleEase=0]="CircleEase",K[K.BackEase=1]="BackEase",K[K.BounceEase=2]="BounceEase",K[K.CubicEase=3]="CubicEase",K[K.ElasticEase=4]="ElasticEase",K[K.ExponentialEase=5]="ExponentialEase",K[K.PowerEase=6]="PowerEase",K[K.QuadraticEase=7]="QuadraticEase",K[K.QuarticEase=8]="QuarticEase",K[K.QuinticEase=9]="QuinticEase",K[K.SineEase=10]="SineEase",K[K.BezierCurveEase=11]="BezierCurveEase"}(G||(G={}));class C extends L.e{constructor(K){super(K),this.config=K,this._easingFunctions={},this.type=this.registerDataInput("type",f.b,11),this.mode=this.registerDataInput("mode",f.q,0),this.parameters=this.registerDataInput("parameters",f.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",f.b)}_updateOutputs(K){const A=this.type.getValue(K),T=this.mode.getValue(K),G=this.parameters.getValue(K);if(void 0===A||void 0===T)return;const L=`${A}-${T}-${G.join("-")}`;if(!this._easingFunctions[L]){const K=function(K){for(var A=arguments.length,T=new Array(A>1?A-1:0),G=1;G<A;G++)T[G-1]=arguments[G];switch(K){case 11:return new B.d(...T);case 0:return new B.k;case 1:return new B.c(...T);case 2:return new B.g(...T);case 3:return new B.l;case 4:return new B.r(...T);case 5:return new B.s(...T);default:throw new Error("Easing type not yet implemented")}}(A,...G);K.setEasingMode(T),this._easingFunctions[L]=K}this.easingFunction.setValue(this._easingFunctions[L],K)}getClassName(){return"FlowGraphEasingBlock"}}(0,O.c)("FlowGraphEasingBlock",C)}}]);