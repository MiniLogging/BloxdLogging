"use strict";(self.g111kvdsqxc=self.g111kvdsqxc||[]).push([[117],{14666:(K,H,M)=>{M.r(H),M.d(H,{EasingFunctionType:()=>q,FlowGraphEasingBlock:()=>W});var q,w=M(13458),u=M(13021),y=M(13004),h=M(11242);!function(K){K[K.CircleEase=0]="CircleEase",K[K.BackEase=1]="BackEase",K[K.BounceEase=2]="BounceEase",K[K.CubicEase=3]="CubicEase",K[K.ElasticEase=4]="ElasticEase",K[K.ExponentialEase=5]="ExponentialEase",K[K.PowerEase=6]="PowerEase",K[K.QuadraticEase=7]="QuadraticEase",K[K.QuarticEase=8]="QuarticEase",K[K.QuinticEase=9]="QuinticEase",K[K.SineEase=10]="SineEase",K[K.BezierCurveEase=11]="BezierCurveEase"}(q||(q={}));class W extends u.b{constructor(K){super(K),this.config=K,this._easingFunctions={},this.type=this.registerDataInput("type",y.d,11),this.mode=this.registerDataInput("mode",y.x,0),this.parameters=this.registerDataInput("parameters",y.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",y.d)}_updateOutputs(K){const H=this.type.getValue(K),M=this.mode.getValue(K),q=this.parameters.getValue(K);if(void 0===H||void 0===M)return;const u=`${H}-${M}-${q.join("-")}`;if(!this._easingFunctions[u]){const K=function(K){for(var H=arguments.length,M=new Array(H>1?H-1:0),q=1;q<H;q++)M[q-1]=arguments[q];switch(K){case 11:return new w.e(...M);case 0:return new w.j;case 1:return new w.c(...M);case 2:return new w.h(...M);case 3:return new w.k;case 4:return new w.p(...M);case 5:return new w.t(...M);default:throw new Error("Easing type not yet implemented")}}(H,...q);K.setEasingMode(M),this._easingFunctions[u]=K}this.easingFunction.setValue(this._easingFunctions[u],K)}getClassName(){return"FlowGraphEasingBlock"}}(0,h.f)("FlowGraphEasingBlock",W)}}]);