"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[117],{15851:(u,R,I)=>{I.r(R),I.d(R,{EasingFunctionType:()=>B,FlowGraphEasingBlock:()=>s});var B,U=I(14607),K=I(14181),C=I(14160),D=I(12433);!function(u){u[u.CircleEase=0]="CircleEase",u[u.BackEase=1]="BackEase",u[u.BounceEase=2]="BounceEase",u[u.CubicEase=3]="CubicEase",u[u.ElasticEase=4]="ElasticEase",u[u.ExponentialEase=5]="ExponentialEase",u[u.PowerEase=6]="PowerEase",u[u.QuadraticEase=7]="QuadraticEase",u[u.QuarticEase=8]="QuarticEase",u[u.QuinticEase=9]="QuinticEase",u[u.SineEase=10]="SineEase",u[u.BezierCurveEase=11]="BezierCurveEase"}(B||(B={}));class s extends K.d{constructor(u){super(u),this.config=u,this._easingFunctions={},this.type=this.registerDataInput("type",C.c,11),this.mode=this.registerDataInput("mode",C.u,0),this.parameters=this.registerDataInput("parameters",C.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",C.c)}_updateOutputs(u){const R=this.type.getValue(u),I=this.mode.getValue(u),B=this.parameters.getValue(u);if(void 0===R||void 0===I)return;const K=`${R}-${I}-${B.join("-")}`;if(!this._easingFunctions[K]){const u=function(u){for(var R=arguments.length,I=new Array(R>1?R-1:0),B=1;B<R;B++)I[B-1]=arguments[B];switch(u){case 11:return new U.f(...I);case 0:return new U.k;case 1:return new U.e(...I);case 2:return new U.i(...I);case 3:return new U.l;case 4:return new U.q(...I);case 5:return new U.s(...I);default:throw new Error("Easing type not yet implemented")}}(R,...B);u.setEasingMode(I),this._easingFunctions[K]=u}this.easingFunction.setValue(this._easingFunctions[K],u)}getClassName(){return"FlowGraphEasingBlock"}}(0,D.e)("FlowGraphEasingBlock",s)}}]);