"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[117],{15201:(Z,h,V)=>{V.r(h),V.d(h,{EasingFunctionType:()=>v,FlowGraphEasingBlock:()=>a});var v,A=V(13975),H=V(13480),K=V(13459),d=V(11691);!function(Z){Z[Z.CircleEase=0]="CircleEase",Z[Z.BackEase=1]="BackEase",Z[Z.BounceEase=2]="BounceEase",Z[Z.CubicEase=3]="CubicEase",Z[Z.ElasticEase=4]="ElasticEase",Z[Z.ExponentialEase=5]="ExponentialEase",Z[Z.PowerEase=6]="PowerEase",Z[Z.QuadraticEase=7]="QuadraticEase",Z[Z.QuarticEase=8]="QuarticEase",Z[Z.QuinticEase=9]="QuinticEase",Z[Z.SineEase=10]="SineEase",Z[Z.BezierCurveEase=11]="BezierCurveEase"}(v||(v={}));class a extends H.d{constructor(Z){super(Z),this.config=Z,this._easingFunctions={},this.type=this.registerDataInput("type",K.c,11),this.mode=this.registerDataInput("mode",K.t,0),this.parameters=this.registerDataInput("parameters",K.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",K.c)}_updateOutputs(Z){const h=this.type.getValue(Z),V=this.mode.getValue(Z),v=this.parameters.getValue(Z);if(void 0===h||void 0===V)return;const H=`${h}-${V}-${v.join("-")}`;if(!this._easingFunctions[H]){const Z=function(Z){for(var h=arguments.length,V=new Array(h>1?h-1:0),v=1;v<h;v++)V[v-1]=arguments[v];switch(Z){case 11:return new A.f(...V);case 0:return new A.n;case 1:return new A.e(...V);case 2:return new A.j(...V);case 3:return new A.q;case 4:return new A.w(...V);case 5:return new A.x(...V);default:throw new Error("Easing type not yet implemented")}}(h,...v);Z.setEasingMode(V),this._easingFunctions[H]=Z}this.easingFunction.setValue(this._easingFunctions[H],Z)}getClassName(){return"FlowGraphEasingBlock"}}(0,d.i)("FlowGraphEasingBlock",a)}}]);