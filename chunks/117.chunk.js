"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[117],{15702:(y,S,I)=>{I.r(S),I.d(S,{EasingFunctionType:()=>V,FlowGraphEasingBlock:()=>F});var V,i=I(14501),A=I(14058),B=I(14033),d=I(12282);!function(y){y[y.CircleEase=0]="CircleEase",y[y.BackEase=1]="BackEase",y[y.BounceEase=2]="BounceEase",y[y.CubicEase=3]="CubicEase",y[y.ElasticEase=4]="ElasticEase",y[y.ExponentialEase=5]="ExponentialEase",y[y.PowerEase=6]="PowerEase",y[y.QuadraticEase=7]="QuadraticEase",y[y.QuarticEase=8]="QuarticEase",y[y.QuinticEase=9]="QuinticEase",y[y.SineEase=10]="SineEase",y[y.BezierCurveEase=11]="BezierCurveEase"}(V||(V={}));class F extends A.d{constructor(y){super(y),this.config=y,this._easingFunctions={},this.type=this.registerDataInput("type",B.c,11),this.mode=this.registerDataInput("mode",B.t,0),this.parameters=this.registerDataInput("parameters",B.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",B.c)}_updateOutputs(y){const S=this.type.getValue(y),I=this.mode.getValue(y),V=this.parameters.getValue(y);if(void 0===S||void 0===I)return;const A=`${S}-${I}-${V.join("-")}`;if(!this._easingFunctions[A]){const y=function(y){for(var S=arguments.length,I=new Array(S>1?S-1:0),V=1;V<S;V++)I[V-1]=arguments[V];switch(y){case 11:return new i.d(...I);case 0:return new i.k;case 1:return new i.b(...I);case 2:return new i.g(...I);case 3:return new i.n;case 4:return new i.q(...I);case 5:return new i.s(...I);default:throw new Error("Easing type not yet implemented")}}(S,...V);y.setEasingMode(I),this._easingFunctions[A]=y}this.easingFunction.setValue(this._easingFunctions[A],y)}getClassName(){return"FlowGraphEasingBlock"}}(0,d.e)("FlowGraphEasingBlock",F)}}]);