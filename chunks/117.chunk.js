"use strict";(self.fjf2z1c8il8=self.fjf2z1c8il8||[]).push([[117],{15945:(g,i,a)=>{a.r(i),a.d(i,{EasingFunctionType:()=>n,FlowGraphEasingBlock:()=>e});var n,L=a(14691),d=a(14234),b=a(14214),k=a(12415);!function(g){g[g.CircleEase=0]="CircleEase",g[g.BackEase=1]="BackEase",g[g.BounceEase=2]="BounceEase",g[g.CubicEase=3]="CubicEase",g[g.ElasticEase=4]="ElasticEase",g[g.ExponentialEase=5]="ExponentialEase",g[g.PowerEase=6]="PowerEase",g[g.QuadraticEase=7]="QuadraticEase",g[g.QuarticEase=8]="QuarticEase",g[g.QuinticEase=9]="QuinticEase",g[g.SineEase=10]="SineEase",g[g.BezierCurveEase=11]="BezierCurveEase"}(n||(n={}));class e extends d.c{constructor(g){super(g),this.config=g,this._easingFunctions={},this.type=this.registerDataInput("type",b.d,11),this.mode=this.registerDataInput("mode",b.q,0),this.parameters=this.registerDataInput("parameters",b.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",b.d)}_updateOutputs(g){const i=this.type.getValue(g),a=this.mode.getValue(g),n=this.parameters.getValue(g);if(void 0===i||void 0===a)return;const d=`${i}-${a}-${n.join("-")}`;if(!this._easingFunctions[d]){const g=function(g){for(var i=arguments.length,a=new Array(i>1?i-1:0),n=1;n<i;n++)a[n-1]=arguments[n];switch(g){case 11:return new L.i(...a);case 0:return new L.n;case 1:return new L.e(...a);case 2:return new L.l(...a);case 3:return new L.r;case 4:return new L.x(...a);case 5:return new L.A(...a);default:throw new Error("Easing type not yet implemented")}}(i,...n);g.setEasingMode(a),this._easingFunctions[d]=g}this.easingFunction.setValue(this._easingFunctions[d],g)}getClassName(){return"FlowGraphEasingBlock"}}(0,k.e)("FlowGraphEasingBlock",e)}}]);