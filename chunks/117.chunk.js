"use strict";(self["269hv5nclphh"]=self["269hv5nclphh"]||[]).push([[117],{15769:(E,H,d)=>{d.r(H),d.d(H,{EasingFunctionType:()=>n,FlowGraphEasingBlock:()=>r});var n,Z=d(14545),I=d(14125),g=d(14103),l=d(12344);!function(E){E[E.CircleEase=0]="CircleEase",E[E.BackEase=1]="BackEase",E[E.BounceEase=2]="BounceEase",E[E.CubicEase=3]="CubicEase",E[E.ElasticEase=4]="ElasticEase",E[E.ExponentialEase=5]="ExponentialEase",E[E.PowerEase=6]="PowerEase",E[E.QuadraticEase=7]="QuadraticEase",E[E.QuarticEase=8]="QuarticEase",E[E.QuinticEase=9]="QuinticEase",E[E.SineEase=10]="SineEase",E[E.BezierCurveEase=11]="BezierCurveEase"}(n||(n={}));class r extends I.c{constructor(E){super(E),this.config=E,this._easingFunctions={},this.type=this.registerDataInput("type",g.e,11),this.mode=this.registerDataInput("mode",g.r,0),this.parameters=this.registerDataInput("parameters",g.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",g.e)}_updateOutputs(E){const H=this.type.getValue(E),d=this.mode.getValue(E),n=this.parameters.getValue(E);if(void 0===H||void 0===d)return;const I=`${H}-${d}-${n.join("-")}`;if(!this._easingFunctions[I]){const E=function(E){for(var H=arguments.length,d=new Array(H>1?H-1:0),n=1;n<H;n++)d[n-1]=arguments[n];switch(E){case 11:return new Z.d(...d);case 0:return new Z.i;case 1:return new Z.b(...d);case 2:return new Z.e(...d);case 3:return new Z.l;case 4:return new Z.r(...d);case 5:return new Z.t(...d);default:throw new Error("Easing type not yet implemented")}}(H,...n);E.setEasingMode(d),this._easingFunctions[I]=E}this.easingFunction.setValue(this._easingFunctions[I],E)}getClassName(){return"FlowGraphEasingBlock"}}(0,l.e)("FlowGraphEasingBlock",r)}}]);