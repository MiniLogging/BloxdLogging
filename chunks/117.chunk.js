"use strict";(self["7c63p8lin4r"]=self["7c63p8lin4r"]||[]).push([[117],{15917:(z,u,U)=>{U.r(u),U.d(u,{EasingFunctionType:()=>J,FlowGraphEasingBlock:()=>P});var J,v=U(14729),f=U(14218),g=U(14196),w=U(12875);!function(z){z[z.CircleEase=0]="CircleEase",z[z.BackEase=1]="BackEase",z[z.BounceEase=2]="BounceEase",z[z.CubicEase=3]="CubicEase",z[z.ElasticEase=4]="ElasticEase",z[z.ExponentialEase=5]="ExponentialEase",z[z.PowerEase=6]="PowerEase",z[z.QuadraticEase=7]="QuadraticEase",z[z.QuarticEase=8]="QuarticEase",z[z.QuinticEase=9]="QuinticEase",z[z.SineEase=10]="SineEase",z[z.BezierCurveEase=11]="BezierCurveEase"}(J||(J={}));class P extends f.b{constructor(z){super(z),this.config=z,this._easingFunctions={},this.type=this.registerDataInput("type",g.e,11),this.mode=this.registerDataInput("mode",g.x,0),this.parameters=this.registerDataInput("parameters",g.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",g.e)}_updateOutputs(z){const u=this.type.getValue(z),U=this.mode.getValue(z),J=this.parameters.getValue(z);if(void 0===u||void 0===U)return;const f="".concat(u,"-").concat(U,"-").concat(J.join("-"));if(!this._easingFunctions[f]){const z=function(z){for(var u=arguments.length,U=new Array(u>1?u-1:0),J=1;J<u;J++)U[J-1]=arguments[J];switch(z){case 11:return new v.d(...U);case 0:return new v.j;case 1:return new v.b(...U);case 2:return new v.h(...U);case 3:return new v.k;case 4:return new v.o(...U);case 5:return new v.r(...U);default:throw new Error("Easing type not yet implemented")}}(u,...J);z.setEasingMode(U),this._easingFunctions[f]=z}this.easingFunction.setValue(this._easingFunctions[f],z)}getClassName(){return"FlowGraphEasingBlock"}}(0,w.f)("FlowGraphEasingBlock",P)}}]);