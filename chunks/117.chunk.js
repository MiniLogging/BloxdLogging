"use strict";(self.gpkvekif0vo=self.gpkvekif0vo||[]).push([[117],{15785:(a,O,i)=>{i.r(O),i.d(O,{EasingFunctionType:()=>H,FlowGraphEasingBlock:()=>k});var H,b=i(14576),G=i(14139),q=i(14124),Q=i(12346);!function(a){a[a.CircleEase=0]="CircleEase",a[a.BackEase=1]="BackEase",a[a.BounceEase=2]="BounceEase",a[a.CubicEase=3]="CubicEase",a[a.ElasticEase=4]="ElasticEase",a[a.ExponentialEase=5]="ExponentialEase",a[a.PowerEase=6]="PowerEase",a[a.QuadraticEase=7]="QuadraticEase",a[a.QuarticEase=8]="QuarticEase",a[a.QuinticEase=9]="QuinticEase",a[a.SineEase=10]="SineEase",a[a.BezierCurveEase=11]="BezierCurveEase"}(H||(H={}));class k extends G.c{constructor(a){super(a),this.config=a,this._easingFunctions={},this.type=this.registerDataInput("type",q.e,11),this.mode=this.registerDataInput("mode",q.t,0),this.parameters=this.registerDataInput("parameters",q.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",q.e)}_updateOutputs(a){const O=this.type.getValue(a),i=this.mode.getValue(a),H=this.parameters.getValue(a);if(void 0===O||void 0===i)return;const G=`${O}-${i}-${H.join("-")}`;if(!this._easingFunctions[G]){const a=function(a){for(var O=arguments.length,i=new Array(O>1?O-1:0),H=1;H<O;H++)i[H-1]=arguments[H];switch(a){case 11:return new b.e(...i);case 0:return new b.k;case 1:return new b.b(...i);case 2:return new b.g(...i);case 3:return new b.m;case 4:return new b.t(...i);case 5:return new b.v(...i);default:throw new Error("Easing type not yet implemented")}}(O,...H);a.setEasingMode(i),this._easingFunctions[G]=a}this.easingFunction.setValue(this._easingFunctions[G],a)}getClassName(){return"FlowGraphEasingBlock"}}(0,Q.h)("FlowGraphEasingBlock",k)}}]);