"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[117],{14621:(o,H,n)=>{n.r(H),n.d(H,{EasingFunctionType:()=>E,FlowGraphEasingBlock:()=>y});var E,k=n(13415),g=n(12956),O=n(12933),Y=n(11140);!function(o){o[o.CircleEase=0]="CircleEase",o[o.BackEase=1]="BackEase",o[o.BounceEase=2]="BounceEase",o[o.CubicEase=3]="CubicEase",o[o.ElasticEase=4]="ElasticEase",o[o.ExponentialEase=5]="ExponentialEase",o[o.PowerEase=6]="PowerEase",o[o.QuadraticEase=7]="QuadraticEase",o[o.QuarticEase=8]="QuarticEase",o[o.QuinticEase=9]="QuinticEase",o[o.SineEase=10]="SineEase",o[o.BezierCurveEase=11]="BezierCurveEase"}(E||(E={}));class y extends g.c{constructor(o){super(o),this.config=o,this._easingFunctions={},this.type=this.registerDataInput("type",O.b,11),this.mode=this.registerDataInput("mode",O.r,0),this.parameters=this.registerDataInput("parameters",O.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",O.b)}_updateOutputs(o){const H=this.type.getValue(o),n=this.mode.getValue(o),E=this.parameters.getValue(o);if(void 0===H||void 0===n)return;const g=`${H}-${n}-${E.join("-")}`;if(!this._easingFunctions[g]){const o=function(o){for(var H=arguments.length,n=new Array(H>1?H-1:0),E=1;E<H;E++)n[E-1]=arguments[E];switch(o){case 11:return new k.c(...n);case 0:return new k.h;case 1:return new k.b(...n);case 2:return new k.e(...n);case 3:return new k.i;case 4:return new k.p(...n);case 5:return new k.s(...n);default:throw new Error("Easing type not yet implemented")}}(H,...E);o.setEasingMode(n),this._easingFunctions[g]=o}this.easingFunction.setValue(this._easingFunctions[g],o)}getClassName(){return"FlowGraphEasingBlock"}}(0,Y.e)("FlowGraphEasingBlock",y)}}]);