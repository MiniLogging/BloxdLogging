"use strict";(self.wy695la1oic=self.wy695la1oic||[]).push([[117],{14816:(S,v,D)=>{D.r(v),D.d(v,{EasingFunctionType:()=>z,FlowGraphEasingBlock:()=>g});var z,e=D(13549),N=D(13123),m=D(13108),B=D(11329);!function(S){S[S.CircleEase=0]="CircleEase",S[S.BackEase=1]="BackEase",S[S.BounceEase=2]="BounceEase",S[S.CubicEase=3]="CubicEase",S[S.ElasticEase=4]="ElasticEase",S[S.ExponentialEase=5]="ExponentialEase",S[S.PowerEase=6]="PowerEase",S[S.QuadraticEase=7]="QuadraticEase",S[S.QuarticEase=8]="QuarticEase",S[S.QuinticEase=9]="QuinticEase",S[S.SineEase=10]="SineEase",S[S.BezierCurveEase=11]="BezierCurveEase"}(z||(z={}));class g extends N.d{constructor(S){super(S),this.config=S,this._easingFunctions={},this.type=this.registerDataInput("type",m.d,11),this.mode=this.registerDataInput("mode",m.q,0),this.parameters=this.registerDataInput("parameters",m.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",m.d)}_updateOutputs(S){const v=this.type.getValue(S),D=this.mode.getValue(S),z=this.parameters.getValue(S);if(void 0===v||void 0===D)return;const N=`${v}-${D}-${z.join("-")}`;if(!this._easingFunctions[N]){const S=function(S){for(var v=arguments.length,D=new Array(v>1?v-1:0),z=1;z<v;z++)D[z-1]=arguments[z];switch(S){case 11:return new e.h(...D);case 0:return new e.j;case 1:return new e.d(...D);case 2:return new e.i(...D);case 3:return new e.n;case 4:return new e.t(...D);case 5:return new e.v(...D);default:throw new Error("Easing type not yet implemented")}}(v,...z);S.setEasingMode(D),this._easingFunctions[N]=S}this.easingFunction.setValue(this._easingFunctions[N],S)}getClassName(){return"FlowGraphEasingBlock"}}(0,B.f)("FlowGraphEasingBlock",g)}}]);