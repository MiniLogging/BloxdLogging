"use strict";(self["2fwzcez286e"]=self["2fwzcez286e"]||[]).push([[117],{16417:(B,u,F)=>{F.r(u),F.d(u,{EasingFunctionType:()=>Z,FlowGraphEasingBlock:()=>e});var Z,V=F(15155),p=F(14720),G=F(14701),R=F(12949);!function(B){B[B.CircleEase=0]="CircleEase",B[B.BackEase=1]="BackEase",B[B.BounceEase=2]="BounceEase",B[B.CubicEase=3]="CubicEase",B[B.ElasticEase=4]="ElasticEase",B[B.ExponentialEase=5]="ExponentialEase",B[B.PowerEase=6]="PowerEase",B[B.QuadraticEase=7]="QuadraticEase",B[B.QuarticEase=8]="QuarticEase",B[B.QuinticEase=9]="QuinticEase",B[B.SineEase=10]="SineEase",B[B.BezierCurveEase=11]="BezierCurveEase"}(Z||(Z={}));class e extends p.e{constructor(B){super(B),this.config=B,this._easingFunctions={},this.type=this.registerDataInput("type",G.c,11),this.mode=this.registerDataInput("mode",G.u,0),this.parameters=this.registerDataInput("parameters",G.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",G.c)}_updateOutputs(B){const u=this.type.getValue(B),F=this.mode.getValue(B),Z=this.parameters.getValue(B);if(void 0===u||void 0===F)return;const p=`${u}-${F}-${Z.join("-")}`;if(!this._easingFunctions[p]){const B=function(B){for(var u=arguments.length,F=new Array(u>1?u-1:0),Z=1;Z<u;Z++)F[Z-1]=arguments[Z];switch(B){case 11:return new V.i(...F);case 0:return new V.p;case 1:return new V.e(...F);case 2:return new V.m(...F);case 3:return new V.t;case 4:return new V.y(...F);case 5:return new V.C(...F);default:throw new Error("Easing type not yet implemented")}}(u,...Z);B.setEasingMode(F),this._easingFunctions[p]=B}this.easingFunction.setValue(this._easingFunctions[p],B)}getClassName(){return"FlowGraphEasingBlock"}}(0,R.f)("FlowGraphEasingBlock",e)}}]);