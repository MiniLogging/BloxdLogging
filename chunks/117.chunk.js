"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[117],{14787:(m,S,h)=>{h.r(S),h.d(S,{EasingFunctionType:()=>l,FlowGraphEasingBlock:()=>q});var l,M=h(13540),O=h(13074),u=h(13060),b=h(11293);!function(m){m[m.CircleEase=0]="CircleEase",m[m.BackEase=1]="BackEase",m[m.BounceEase=2]="BounceEase",m[m.CubicEase=3]="CubicEase",m[m.ElasticEase=4]="ElasticEase",m[m.ExponentialEase=5]="ExponentialEase",m[m.PowerEase=6]="PowerEase",m[m.QuadraticEase=7]="QuadraticEase",m[m.QuarticEase=8]="QuarticEase",m[m.QuinticEase=9]="QuinticEase",m[m.SineEase=10]="SineEase",m[m.BezierCurveEase=11]="BezierCurveEase"}(l||(l={}));class q extends O.d{constructor(m){super(m),this.config=m,this._easingFunctions={},this.type=this.registerDataInput("type",u.b,11),this.mode=this.registerDataInput("mode",u.p,0),this.parameters=this.registerDataInput("parameters",u.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",u.b)}_updateOutputs(m){const S=this.type.getValue(m),h=this.mode.getValue(m),l=this.parameters.getValue(m);if(void 0===S||void 0===h)return;const O=`${S}-${h}-${l.join("-")}`;if(!this._easingFunctions[O]){const m=function(m){for(var S=arguments.length,h=new Array(S>1?S-1:0),l=1;l<S;l++)h[l-1]=arguments[l];switch(m){case 11:return new M.f(...h);case 0:return new M.j;case 1:return new M.e(...h);case 2:return new M.h(...h);case 3:return new M.m;case 4:return new M.r(...h);case 5:return new M.u(...h);default:throw new Error("Easing type not yet implemented")}}(S,...l);m.setEasingMode(h),this._easingFunctions[O]=m}this.easingFunction.setValue(this._easingFunctions[O],m)}getClassName(){return"FlowGraphEasingBlock"}}(0,b.e)("FlowGraphEasingBlock",q)}}]);