"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[117],{14680:(H,O,S)=>{S.r(O),S.d(O,{EasingFunctionType:()=>t,FlowGraphEasingBlock:()=>V});var t,q=S(13467),p=S(13063),G=S(13035),U=S(11262);!function(H){H[H.CircleEase=0]="CircleEase",H[H.BackEase=1]="BackEase",H[H.BounceEase=2]="BounceEase",H[H.CubicEase=3]="CubicEase",H[H.ElasticEase=4]="ElasticEase",H[H.ExponentialEase=5]="ExponentialEase",H[H.PowerEase=6]="PowerEase",H[H.QuadraticEase=7]="QuadraticEase",H[H.QuarticEase=8]="QuarticEase",H[H.QuinticEase=9]="QuinticEase",H[H.SineEase=10]="SineEase",H[H.BezierCurveEase=11]="BezierCurveEase"}(t||(t={}));class V extends p.c{constructor(H){super(H),this.config=H,this._easingFunctions={},this.type=this.registerDataInput("type",G.e,11),this.mode=this.registerDataInput("mode",G.t,0),this.parameters=this.registerDataInput("parameters",G.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",G.e)}_updateOutputs(H){const O=this.type.getValue(H),S=this.mode.getValue(H),t=this.parameters.getValue(H);if(void 0===O||void 0===S)return;const p=`${O}-${S}-${t.join("-")}`;if(!this._easingFunctions[p]){const H=function(H){for(var O=arguments.length,S=new Array(O>1?O-1:0),t=1;t<O;t++)S[t-1]=arguments[t];switch(H){case 11:return new q.d(...S);case 0:return new q.j;case 1:return new q.c(...S);case 2:return new q.g(...S);case 3:return new q.n;case 4:return new q.r(...S);case 5:return new q.s(...S);default:throw new Error("Easing type not yet implemented")}}(O,...t);H.setEasingMode(S),this._easingFunctions[p]=H}this.easingFunction.setValue(this._easingFunctions[p],H)}getClassName(){return"FlowGraphEasingBlock"}}(0,U.g)("FlowGraphEasingBlock",V)}}]);