"use strict";(self.kdlk57exiqh=self.kdlk57exiqh||[]).push([[117],{15526:(i,x,e)=>{e.r(x),e.d(x,{EasingFunctionType:()=>j,FlowGraphEasingBlock:()=>u});var j,E=e(14347),a=e(13900),Y=e(13874),J=e(12204);!function(i){i[i.CircleEase=0]="CircleEase",i[i.BackEase=1]="BackEase",i[i.BounceEase=2]="BounceEase",i[i.CubicEase=3]="CubicEase",i[i.ElasticEase=4]="ElasticEase",i[i.ExponentialEase=5]="ExponentialEase",i[i.PowerEase=6]="PowerEase",i[i.QuadraticEase=7]="QuadraticEase",i[i.QuarticEase=8]="QuarticEase",i[i.QuinticEase=9]="QuinticEase",i[i.SineEase=10]="SineEase",i[i.BezierCurveEase=11]="BezierCurveEase"}(j||(j={}));class u extends a.e{constructor(i){super(i),this.config=i,this._easingFunctions={},this.type=this.registerDataInput("type",Y.c,11),this.mode=this.registerDataInput("mode",Y.q,0),this.parameters=this.registerDataInput("parameters",Y.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",Y.c)}_updateOutputs(i){const x=this.type.getValue(i),e=this.mode.getValue(i),j=this.parameters.getValue(i);if(void 0===x||void 0===e)return;const a=`${x}-${e}-${j.join("-")}`;if(!this._easingFunctions[a]){const i=function(i){for(var x=arguments.length,e=new Array(x>1?x-1:0),j=1;j<x;j++)e[j-1]=arguments[j];switch(i){case 11:return new E.g(...e);case 0:return new E.n;case 1:return new E.e(...e);case 2:return new E.k(...e);case 3:return new E.q;case 4:return new E.v(...e);case 5:return new E.z(...e);default:throw new Error("Easing type not yet implemented")}}(x,...j);i.setEasingMode(e),this._easingFunctions[a]=i}this.easingFunction.setValue(this._easingFunctions[a],i)}getClassName(){return"FlowGraphEasingBlock"}}(0,J.f)("FlowGraphEasingBlock",u)}}]);