"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[117],{16360:(Y,c,h)=>{h.r(c),h.d(c,{EasingFunctionType:()=>C,FlowGraphEasingBlock:()=>H});var C,E=h(15122),N=h(14482),Q=h(14459),b=h(12825);!function(Y){Y[Y.CircleEase=0]="CircleEase",Y[Y.BackEase=1]="BackEase",Y[Y.BounceEase=2]="BounceEase",Y[Y.CubicEase=3]="CubicEase",Y[Y.ElasticEase=4]="ElasticEase",Y[Y.ExponentialEase=5]="ExponentialEase",Y[Y.PowerEase=6]="PowerEase",Y[Y.QuadraticEase=7]="QuadraticEase",Y[Y.QuarticEase=8]="QuarticEase",Y[Y.QuinticEase=9]="QuinticEase",Y[Y.SineEase=10]="SineEase",Y[Y.BezierCurveEase=11]="BezierCurveEase"}(C||(C={}));class H extends N.b{constructor(Y){super(Y),this.config=Y,this._easingFunctions={},this.type=this.registerDataInput("type",Q.c,11),this.mode=this.registerDataInput("mode",Q.n,0),this.parameters=this.registerDataInput("parameters",Q.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",Q.c)}_updateOutputs(Y){const c=this.type.getValue(Y),h=this.mode.getValue(Y),C=this.parameters.getValue(Y);if(void 0===c||void 0===h)return;const N=`${c}-${h}-${C.join("-")}`;if(!this._easingFunctions[N]){const Y=function(Y){for(var c=arguments.length,h=new Array(c>1?c-1:0),C=1;C<c;C++)h[C-1]=arguments[C];switch(Y){case 11:return new E.g(...h);case 0:return new E.l;case 1:return new E.d(...h);case 2:return new E.h(...h);case 3:return new E.n;case 4:return new E.v(...h);case 5:return new E.x(...h);default:throw new Error("Easing type not yet implemented")}}(c,...C);Y.setEasingMode(h),this._easingFunctions[N]=Y}this.easingFunction.setValue(this._easingFunctions[N],Y)}getClassName(){return"FlowGraphEasingBlock"}}(0,b.e)("FlowGraphEasingBlock",H)}}]);