"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[117],{14578:(k,h,o)=>{o.r(h),o.d(h,{EasingFunctionType:()=>x,FlowGraphEasingBlock:()=>G});var x,I=o(13384),q=o(12961),Y=o(12936),J=o(11199);!function(k){k[k.CircleEase=0]="CircleEase",k[k.BackEase=1]="BackEase",k[k.BounceEase=2]="BounceEase",k[k.CubicEase=3]="CubicEase",k[k.ElasticEase=4]="ElasticEase",k[k.ExponentialEase=5]="ExponentialEase",k[k.PowerEase=6]="PowerEase",k[k.QuadraticEase=7]="QuadraticEase",k[k.QuarticEase=8]="QuarticEase",k[k.QuinticEase=9]="QuinticEase",k[k.SineEase=10]="SineEase",k[k.BezierCurveEase=11]="BezierCurveEase"}(x||(x={}));class G extends q.b{constructor(k){super(k),this.config=k,this._easingFunctions={},this.type=this.registerDataInput("type",Y.d,11),this.mode=this.registerDataInput("mode",Y.o,0),this.parameters=this.registerDataInput("parameters",Y.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",Y.d)}_updateOutputs(k){const h=this.type.getValue(k),o=this.mode.getValue(k),x=this.parameters.getValue(k);if(void 0===h||void 0===o)return;const q=`${h}-${o}-${x.join("-")}`;if(!this._easingFunctions[q]){const k=function(k){for(var h=arguments.length,o=new Array(h>1?h-1:0),x=1;x<h;x++)o[x-1]=arguments[x];switch(k){case 11:return new I.i(...o);case 0:return new I.m;case 1:return new I.e(...o);case 2:return new I.l(...o);case 3:return new I.q;case 4:return new I.u(...o);case 5:return new I.v(...o);default:throw new Error("Easing type not yet implemented")}}(h,...x);k.setEasingMode(o),this._easingFunctions[q]=k}this.easingFunction.setValue(this._easingFunctions[q],k)}getClassName(){return"FlowGraphEasingBlock"}}(0,J.g)("FlowGraphEasingBlock",G)}}]);