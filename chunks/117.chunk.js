"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[117],{14578:(P,f,Y)=>{Y.r(f),Y.d(f,{EasingFunctionType:()=>C,FlowGraphEasingBlock:()=>w});var C,q=Y(13360),m=Y(12947),L=Y(12917),o=Y(11134);!function(P){P[P.CircleEase=0]="CircleEase",P[P.BackEase=1]="BackEase",P[P.BounceEase=2]="BounceEase",P[P.CubicEase=3]="CubicEase",P[P.ElasticEase=4]="ElasticEase",P[P.ExponentialEase=5]="ExponentialEase",P[P.PowerEase=6]="PowerEase",P[P.QuadraticEase=7]="QuadraticEase",P[P.QuarticEase=8]="QuarticEase",P[P.QuinticEase=9]="QuinticEase",P[P.SineEase=10]="SineEase",P[P.BezierCurveEase=11]="BezierCurveEase"}(C||(C={}));class w extends m.b{constructor(P){super(P),this.config=P,this._easingFunctions={},this.type=this.registerDataInput("type",L.d,11),this.mode=this.registerDataInput("mode",L.o,0),this.parameters=this.registerDataInput("parameters",L.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",L.d)}_updateOutputs(P){const f=this.type.getValue(P),Y=this.mode.getValue(P),C=this.parameters.getValue(P);if(void 0===f||void 0===Y)return;const m=`${f}-${Y}-${C.join("-")}`;if(!this._easingFunctions[m]){const P=function(P){for(var f=arguments.length,Y=new Array(f>1?f-1:0),C=1;C<f;C++)Y[C-1]=arguments[C];switch(P){case 11:return new q.g(...Y);case 0:return new q.k;case 1:return new q.d(...Y);case 2:return new q.i(...Y);case 3:return new q.m;case 4:return new q.r(...Y);case 5:return new q.t(...Y);default:throw new Error("Easing type not yet implemented")}}(f,...C);P.setEasingMode(Y),this._easingFunctions[m]=P}this.easingFunction.setValue(this._easingFunctions[m],P)}getClassName(){return"FlowGraphEasingBlock"}}(0,o.d)("FlowGraphEasingBlock",w)}}]);