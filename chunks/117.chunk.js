"use strict";(self.ra6kpa9z1sg=self.ra6kpa9z1sg||[]).push([[117],{16181:(p,b,M)=>{M.r(b),M.d(b,{EasingFunctionType:()=>h,FlowGraphEasingBlock:()=>w});var h,Q=M(14938),mp=M(14341),y=M(14316),P=M(12730);!function(p){p[p.CircleEase=0]="CircleEase",p[p.BackEase=1]="BackEase",p[p.BounceEase=2]="BounceEase",p[p.CubicEase=3]="CubicEase",p[p.ElasticEase=4]="ElasticEase",p[p.ExponentialEase=5]="ExponentialEase",p[p.PowerEase=6]="PowerEase",p[p.QuadraticEase=7]="QuadraticEase",p[p.QuarticEase=8]="QuarticEase",p[p.QuinticEase=9]="QuinticEase",p[p.SineEase=10]="SineEase",p[p.BezierCurveEase=11]="BezierCurveEase"}(h||(h={}));class w extends mp.d{constructor(p){super(p),this.config=p,this._easingFunctions={},this.type=this.registerDataInput("type",y.e,11),this.mode=this.registerDataInput("mode",y.t,0),this.parameters=this.registerDataInput("parameters",y.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",y.e)}_updateOutputs(p){const b=this.type.getValue(p),M=this.mode.getValue(p),h=this.parameters.getValue(p);if(void 0===b||void 0===M)return;const mp=`${b}-${M}-${h.join("-")}`;if(!this._easingFunctions[mp]){const p=function(p){for(var b=arguments.length,M=new Array(b>1?b-1:0),h=1;h<b;h++)M[h-1]=arguments[h];switch(p){case 11:return new Q.e(...M);case 0:return new Q.m;case 1:return new Q.b(...M);case 2:return new Q.i(...M);case 3:return new Q.n;case 4:return new Q.v(...M);case 5:return new Q.y(...M);default:throw new Error("Easing type not yet implemented")}}(b,...h);p.setEasingMode(M),this._easingFunctions[mp]=p}this.easingFunction.setValue(this._easingFunctions[mp],p)}getClassName(){return"FlowGraphEasingBlock"}}(0,P.c)("FlowGraphEasingBlock",w)}}]);