"use strict";(self.n52dyox90qa=self.n52dyox90qa||[]).push([[117],{15137:(E,t,z)=>{z.r(t),z.d(t,{EasingFunctionType:()=>A,FlowGraphEasingBlock:()=>C});var A,X=z(13916),R=z(13480),u=z(13458),p=z(11766);!function(E){E[E.CircleEase=0]="CircleEase",E[E.BackEase=1]="BackEase",E[E.BounceEase=2]="BounceEase",E[E.CubicEase=3]="CubicEase",E[E.ElasticEase=4]="ElasticEase",E[E.ExponentialEase=5]="ExponentialEase",E[E.PowerEase=6]="PowerEase",E[E.QuadraticEase=7]="QuadraticEase",E[E.QuarticEase=8]="QuarticEase",E[E.QuinticEase=9]="QuinticEase",E[E.SineEase=10]="SineEase",E[E.BezierCurveEase=11]="BezierCurveEase"}(A||(A={}));class C extends R.c{constructor(E){super(E),this.config=E,this._easingFunctions={},this.type=this.registerDataInput("type",u.c,11),this.mode=this.registerDataInput("mode",u.p,0),this.parameters=this.registerDataInput("parameters",u.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",u.c)}_updateOutputs(E){const t=this.type.getValue(E),z=this.mode.getValue(E),A=this.parameters.getValue(E);if(void 0===t||void 0===z)return;const R=`${t}-${z}-${A.join("-")}`;if(!this._easingFunctions[R]){const E=function(E){for(var t=arguments.length,z=new Array(t>1?t-1:0),A=1;A<t;A++)z[A-1]=arguments[A];switch(E){case 11:return new X.f(...z);case 0:return new X.l;case 1:return new X.d(...z);case 2:return new X.h(...z);case 3:return new X.n;case 4:return new X.u(...z);case 5:return new X.w(...z);default:throw new Error("Easing type not yet implemented")}}(t,...A);E.setEasingMode(z),this._easingFunctions[R]=E}this.easingFunction.setValue(this._easingFunctions[R],E)}getClassName(){return"FlowGraphEasingBlock"}}(0,p.f)("FlowGraphEasingBlock",C)}}]);