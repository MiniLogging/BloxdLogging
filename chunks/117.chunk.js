"use strict";(self.ex92n20nlz8=self.ex92n20nlz8||[]).push([[117],{15932:(I,g,b)=>{b.r(g),b.d(g,{EasingFunctionType:()=>e,FlowGraphEasingBlock:()=>o});var e,c=b(14726),z=b(14295),M=b(14282),J=b(12558);!function(I){I[I.CircleEase=0]="CircleEase",I[I.BackEase=1]="BackEase",I[I.BounceEase=2]="BounceEase",I[I.CubicEase=3]="CubicEase",I[I.ElasticEase=4]="ElasticEase",I[I.ExponentialEase=5]="ExponentialEase",I[I.PowerEase=6]="PowerEase",I[I.QuadraticEase=7]="QuadraticEase",I[I.QuarticEase=8]="QuarticEase",I[I.QuinticEase=9]="QuinticEase",I[I.SineEase=10]="SineEase",I[I.BezierCurveEase=11]="BezierCurveEase"}(e||(e={}));class o extends z.d{constructor(I){super(I),this.config=I,this._easingFunctions={},this.type=this.registerDataInput("type",M.c,11),this.mode=this.registerDataInput("mode",M.t,0),this.parameters=this.registerDataInput("parameters",M.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",M.c)}_updateOutputs(I){const g=this.type.getValue(I),b=this.mode.getValue(I),e=this.parameters.getValue(I);if(void 0===g||void 0===b)return;const z=`${g}-${b}-${e.join("-")}`;if(!this._easingFunctions[z]){const I=function(I){for(var g=arguments.length,b=new Array(g>1?g-1:0),e=1;e<g;e++)b[e-1]=arguments[e];switch(I){case 11:return new c.c(...b);case 0:return new c.h;case 1:return new c.b(...b);case 2:return new c.e(...b);case 3:return new c.l;case 4:return new c.n(...b);case 5:return new c.r(...b);default:throw new Error("Easing type not yet implemented")}}(g,...e);I.setEasingMode(b),this._easingFunctions[z]=I}this.easingFunction.setValue(this._easingFunctions[z],I)}getClassName(){return"FlowGraphEasingBlock"}}(0,J.g)("FlowGraphEasingBlock",o)}}]);