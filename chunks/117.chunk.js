"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[117],{14547:(h,V,i)=>{i.r(V),i.d(V,{EasingFunctionType:()=>S,FlowGraphEasingBlock:()=>B});var S,l=i(13259),Y=i(12827),g=i(12805),q=i(11091);!function(h){h[h.CircleEase=0]="CircleEase",h[h.BackEase=1]="BackEase",h[h.BounceEase=2]="BounceEase",h[h.CubicEase=3]="CubicEase",h[h.ElasticEase=4]="ElasticEase",h[h.ExponentialEase=5]="ExponentialEase",h[h.PowerEase=6]="PowerEase",h[h.QuadraticEase=7]="QuadraticEase",h[h.QuarticEase=8]="QuarticEase",h[h.QuinticEase=9]="QuinticEase",h[h.SineEase=10]="SineEase",h[h.BezierCurveEase=11]="BezierCurveEase"}(S||(S={}));class B extends Y.c{constructor(h){super(h),this.config=h,this._easingFunctions={},this.type=this.registerDataInput("type",g.c,11),this.mode=this.registerDataInput("mode",g.u,0),this.parameters=this.registerDataInput("parameters",g.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",g.c)}_updateOutputs(h){const V=this.type.getValue(h),i=this.mode.getValue(h),S=this.parameters.getValue(h);if(void 0===V||void 0===i)return;const Y=`${V}-${i}-${S.join("-")}`;if(!this._easingFunctions[Y]){const h=function(h){for(var V=arguments.length,i=new Array(V>1?V-1:0),S=1;S<V;S++)i[S-1]=arguments[S];switch(h){case 11:return new l.c(...i);case 0:return new l.g;case 1:return new l.b(...i);case 2:return new l.e(...i);case 3:return new l.k;case 4:return new l.p(...i);case 5:return new l.s(...i);default:throw new Error("Easing type not yet implemented")}}(V,...S);h.setEasingMode(i),this._easingFunctions[Y]=h}this.easingFunction.setValue(this._easingFunctions[Y],h)}getClassName(){return"FlowGraphEasingBlock"}}(0,q.f)("FlowGraphEasingBlock",B)}}]);