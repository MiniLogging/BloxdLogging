"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[117],{14630:(F,b,Q)=>{Q.r(b),Q.d(b,{EasingFunctionType:()=>C,FlowGraphEasingBlock:()=>Z});var C,z=Q(13413),t=Q(12972),g=Q(12951),W=Q(11265);!function(F){F[F.CircleEase=0]="CircleEase",F[F.BackEase=1]="BackEase",F[F.BounceEase=2]="BounceEase",F[F.CubicEase=3]="CubicEase",F[F.ElasticEase=4]="ElasticEase",F[F.ExponentialEase=5]="ExponentialEase",F[F.PowerEase=6]="PowerEase",F[F.QuadraticEase=7]="QuadraticEase",F[F.QuarticEase=8]="QuarticEase",F[F.QuinticEase=9]="QuinticEase",F[F.SineEase=10]="SineEase",F[F.BezierCurveEase=11]="BezierCurveEase"}(C||(C={}));class Z extends t.b{constructor(F){super(F),this.config=F,this._easingFunctions={},this.type=this.registerDataInput("type",g.b,11),this.mode=this.registerDataInput("mode",g.m,0),this.parameters=this.registerDataInput("parameters",g.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",g.b)}_updateOutputs(F){const b=this.type.getValue(F),Q=this.mode.getValue(F),C=this.parameters.getValue(F);if(void 0===b||void 0===Q)return;const t=`${b}-${Q}-${C.join("-")}`;if(!this._easingFunctions[t]){const F=function(F){for(var b=arguments.length,Q=new Array(b>1?b-1:0),C=1;C<b;C++)Q[C-1]=arguments[C];switch(F){case 11:return new z.e(...Q);case 0:return new z.i;case 1:return new z.c(...Q);case 2:return new z.f(...Q);case 3:return new z.k;case 4:return new z.n(...Q);case 5:return new z.q(...Q);default:throw new Error("Easing type not yet implemented")}}(b,...C);F.setEasingMode(Q),this._easingFunctions[t]=F}this.easingFunction.setValue(this._easingFunctions[t],F)}getClassName(){return"FlowGraphEasingBlock"}}(0,W.g)("FlowGraphEasingBlock",Z)}}]);