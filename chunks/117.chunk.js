"use strict";(self.vb3rpbgyozo=self.vb3rpbgyozo||[]).push([[117],{16170:(q,I,l)=>{l.r(I),l.d(I,{EasingFunctionType:()=>w,FlowGraphEasingBlock:()=>F});var w,t=l(14921),O=l(14457),c=l(14441),a=l(12711);!function(q){q[q.CircleEase=0]="CircleEase",q[q.BackEase=1]="BackEase",q[q.BounceEase=2]="BounceEase",q[q.CubicEase=3]="CubicEase",q[q.ElasticEase=4]="ElasticEase",q[q.ExponentialEase=5]="ExponentialEase",q[q.PowerEase=6]="PowerEase",q[q.QuadraticEase=7]="QuadraticEase",q[q.QuarticEase=8]="QuarticEase",q[q.QuinticEase=9]="QuinticEase",q[q.SineEase=10]="SineEase",q[q.BezierCurveEase=11]="BezierCurveEase"}(w||(w={}));class F extends O.c{constructor(q){super(q),this.config=q,this._easingFunctions={},this.type=this.registerDataInput("type",c.e,11),this.mode=this.registerDataInput("mode",c.v,0),this.parameters=this.registerDataInput("parameters",c.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",c.e)}_updateOutputs(q){const I=this.type.getValue(q),l=this.mode.getValue(q),w=this.parameters.getValue(q);if(void 0===I||void 0===l)return;const O=`${I}-${l}-${w.join("-")}`;if(!this._easingFunctions[O]){const q=function(q){for(var I=arguments.length,l=new Array(I>1?I-1:0),w=1;w<I;w++)l[w-1]=arguments[w];switch(q){case 11:return new t.f(...l);case 0:return new t.n;case 1:return new t.b(...l);case 2:return new t.j(...l);case 3:return new t.o;case 4:return new t.v(...l);case 5:return new t.z(...l);default:throw new Error("Easing type not yet implemented")}}(I,...w);q.setEasingMode(l),this._easingFunctions[O]=q}this.easingFunction.setValue(this._easingFunctions[O],q)}getClassName(){return"FlowGraphEasingBlock"}}(0,a.e)("FlowGraphEasingBlock",F)}}]);