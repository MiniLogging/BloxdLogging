"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[117],{14525:(q,S,b)=>{b.r(S),b.d(S,{EasingFunctionType:()=>z,FlowGraphEasingBlock:()=>r});var z,C=b(13281),v=b(12852),U=b(12839),g=b(11058);!function(q){q[q.CircleEase=0]="CircleEase",q[q.BackEase=1]="BackEase",q[q.BounceEase=2]="BounceEase",q[q.CubicEase=3]="CubicEase",q[q.ElasticEase=4]="ElasticEase",q[q.ExponentialEase=5]="ExponentialEase",q[q.PowerEase=6]="PowerEase",q[q.QuadraticEase=7]="QuadraticEase",q[q.QuarticEase=8]="QuarticEase",q[q.QuinticEase=9]="QuinticEase",q[q.SineEase=10]="SineEase",q[q.BezierCurveEase=11]="BezierCurveEase"}(z||(z={}));class r extends v.c{constructor(q){super(q),this.config=q,this._easingFunctions={},this.type=this.registerDataInput("type",U.d,11),this.mode=this.registerDataInput("mode",U.o,0),this.parameters=this.registerDataInput("parameters",U.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",U.d)}_updateOutputs(q){const S=this.type.getValue(q),b=this.mode.getValue(q),z=this.parameters.getValue(q);if(void 0===S||void 0===b)return;const v=`${S}-${b}-${z.join("-")}`;if(!this._easingFunctions[v]){const q=function(q){for(var S=arguments.length,b=new Array(S>1?S-1:0),z=1;z<S;z++)b[z-1]=arguments[z];switch(q){case 11:return new C.f(...b);case 0:return new C.l;case 1:return new C.e(...b);case 2:return new C.i(...b);case 3:return new C.o;case 4:return new C.r(...b);case 5:return new C.v(...b);default:throw new Error("Easing type not yet implemented")}}(S,...z);q.setEasingMode(b),this._easingFunctions[v]=q}this.easingFunction.setValue(this._easingFunctions[v],q)}getClassName(){return"FlowGraphEasingBlock"}}(0,g.f)("FlowGraphEasingBlock",r)}}]);