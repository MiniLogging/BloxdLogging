"use strict";(self.zy41qorie9=self.zy41qorie9||[]).push([[117],{15534:(Z,l,C)=>{C.r(l),C.d(l,{EasingFunctionType:()=>B,FlowGraphEasingBlock:()=>W});var B,x=C(14272),b=C(13853),K=C(13830),f=C(12400);!function(Z){Z[Z.CircleEase=0]="CircleEase",Z[Z.BackEase=1]="BackEase",Z[Z.BounceEase=2]="BounceEase",Z[Z.CubicEase=3]="CubicEase",Z[Z.ElasticEase=4]="ElasticEase",Z[Z.ExponentialEase=5]="ExponentialEase",Z[Z.PowerEase=6]="PowerEase",Z[Z.QuadraticEase=7]="QuadraticEase",Z[Z.QuarticEase=8]="QuarticEase",Z[Z.QuinticEase=9]="QuinticEase",Z[Z.SineEase=10]="SineEase",Z[Z.BezierCurveEase=11]="BezierCurveEase"}(B||(B={}));class W extends b.d{constructor(Z){super(Z),this.config=Z,this._easingFunctions={},this.type=this.registerDataInput("type",K.c,11),this.mode=this.registerDataInput("mode",K.o,0),this.parameters=this.registerDataInput("parameters",K.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",K.c)}_updateOutputs(Z){const l=this.type.getValue(Z),C=this.mode.getValue(Z),B=this.parameters.getValue(Z);if(void 0===l||void 0===C)return;const b=`${l}-${C}-${B.join("-")}`;if(!this._easingFunctions[b]){const Z=function(Z){for(var l=arguments.length,C=new Array(l>1?l-1:0),B=1;B<l;B++)C[B-1]=arguments[B];switch(Z){case 11:return new x.c(...C);case 0:return new x.e;case 1:return new x.b(...C);case 2:return new x.d(...C);case 3:return new x.h;case 4:return new x.j(...C);case 5:return new x.l(...C);default:throw new Error("Easing type not yet implemented")}}(l,...B);Z.setEasingMode(C),this._easingFunctions[b]=Z}this.easingFunction.setValue(this._easingFunctions[b],Z)}getClassName(){return"FlowGraphEasingBlock"}}(0,f.c)("FlowGraphEasingBlock",W)}}]);