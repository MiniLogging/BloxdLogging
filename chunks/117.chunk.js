"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[117],{15779:(V,h,mV)=>{mV.r(h),mV.d(h,{EasingFunctionType:()=>t,FlowGraphEasingBlock:()=>C});var t,L=mV(14542),N=mV(14123),A=mV(14109),k=mV(12388);!function(V){V[V.CircleEase=0]="CircleEase",V[V.BackEase=1]="BackEase",V[V.BounceEase=2]="BounceEase",V[V.CubicEase=3]="CubicEase",V[V.ElasticEase=4]="ElasticEase",V[V.ExponentialEase=5]="ExponentialEase",V[V.PowerEase=6]="PowerEase",V[V.QuadraticEase=7]="QuadraticEase",V[V.QuarticEase=8]="QuarticEase",V[V.QuinticEase=9]="QuinticEase",V[V.SineEase=10]="SineEase",V[V.BezierCurveEase=11]="BezierCurveEase"}(t||(t={}));class C extends N.e{constructor(V){super(V),this.config=V,this._easingFunctions={},this.type=this.registerDataInput("type",A.e,11),this.mode=this.registerDataInput("mode",A.r,0),this.parameters=this.registerDataInput("parameters",A.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",A.e)}_updateOutputs(V){const h=this.type.getValue(V),mV=this.mode.getValue(V),t=this.parameters.getValue(V);if(void 0===h||void 0===mV)return;const N=`${h}-${mV}-${t.join("-")}`;if(!this._easingFunctions[N]){const V=function(V){for(var h=arguments.length,mV=new Array(h>1?h-1:0),t=1;t<h;t++)mV[t-1]=arguments[t];switch(V){case 11:return new L.f(...mV);case 0:return new L.m;case 1:return new L.d(...mV);case 2:return new L.i(...mV);case 3:return new L.o;case 4:return new L.v(...mV);case 5:return new L.x(...mV);default:throw new Error("Easing type not yet implemented")}}(h,...t);V.setEasingMode(mV),this._easingFunctions[N]=V}this.easingFunction.setValue(this._easingFunctions[N],V)}getClassName(){return"FlowGraphEasingBlock"}}(0,k.i)("FlowGraphEasingBlock",C)}}]);