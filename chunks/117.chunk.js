"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[117],{14632:(Z,x,F)=>{F.r(x),F.d(x,{EasingFunctionType:()=>u,FlowGraphEasingBlock:()=>d});var u,G=F(13414),f=F(12977),Y=F(12954),j=F(11136);!function(Z){Z[Z.CircleEase=0]="CircleEase",Z[Z.BackEase=1]="BackEase",Z[Z.BounceEase=2]="BounceEase",Z[Z.CubicEase=3]="CubicEase",Z[Z.ElasticEase=4]="ElasticEase",Z[Z.ExponentialEase=5]="ExponentialEase",Z[Z.PowerEase=6]="PowerEase",Z[Z.QuadraticEase=7]="QuadraticEase",Z[Z.QuarticEase=8]="QuarticEase",Z[Z.QuinticEase=9]="QuinticEase",Z[Z.SineEase=10]="SineEase",Z[Z.BezierCurveEase=11]="BezierCurveEase"}(u||(u={}));class d extends f.e{constructor(Z){super(Z),this.config=Z,this._easingFunctions={},this.type=this.registerDataInput("type",Y.d,11),this.mode=this.registerDataInput("mode",Y.u,0),this.parameters=this.registerDataInput("parameters",Y.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",Y.d)}_updateOutputs(Z){const x=this.type.getValue(Z),F=this.mode.getValue(Z),u=this.parameters.getValue(Z);if(void 0===x||void 0===F)return;const f=`${x}-${F}-${u.join("-")}`;if(!this._easingFunctions[f]){const Z=function(Z){for(var x=arguments.length,F=new Array(x>1?x-1:0),u=1;u<x;u++)F[u-1]=arguments[u];switch(Z){case 11:return new G.e(...F);case 0:return new G.j;case 1:return new G.d(...F);case 2:return new G.f(...F);case 3:return new G.n;case 4:return new G.p(...F);case 5:return new G.r(...F);default:throw new Error("Easing type not yet implemented")}}(x,...u);Z.setEasingMode(F),this._easingFunctions[f]=Z}this.easingFunction.setValue(this._easingFunctions[f],Z)}getClassName(){return"FlowGraphEasingBlock"}}(0,j.g)("FlowGraphEasingBlock",d)}}]);