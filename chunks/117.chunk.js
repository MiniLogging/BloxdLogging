"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[117],{16011:(M,A,O)=>{O.r(A),O.d(A,{EasingFunctionType:()=>S,FlowGraphEasingBlock:()=>j});var S,z=O(14761),Q=O(14255),X=O(14238),c=O(12919);!function(M){M[M.CircleEase=0]="CircleEase",M[M.BackEase=1]="BackEase",M[M.BounceEase=2]="BounceEase",M[M.CubicEase=3]="CubicEase",M[M.ElasticEase=4]="ElasticEase",M[M.ExponentialEase=5]="ExponentialEase",M[M.PowerEase=6]="PowerEase",M[M.QuadraticEase=7]="QuadraticEase",M[M.QuarticEase=8]="QuarticEase",M[M.QuinticEase=9]="QuinticEase",M[M.SineEase=10]="SineEase",M[M.BezierCurveEase=11]="BezierCurveEase"}(S||(S={}));class j extends Q.c{constructor(M){super(M),this.config=M,this._easingFunctions={},this.type=this.registerDataInput("type",X.b,11),this.mode=this.registerDataInput("mode",X.t,0),this.parameters=this.registerDataInput("parameters",X.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",X.b)}_updateOutputs(M){const A=this.type.getValue(M),O=this.mode.getValue(M),S=this.parameters.getValue(M);if(void 0===A||void 0===O)return;const Q="".concat(A,"-").concat(O,"-").concat(S.join("-"));if(!this._easingFunctions[Q]){const M=function(M){for(var A=arguments.length,O=new Array(A>1?A-1:0),S=1;S<A;S++)O[S-1]=arguments[S];switch(M){case 11:return new z.e(...O);case 0:return new z.m;case 1:return new z.b(...O);case 2:return new z.i(...O);case 3:return new z.q;case 4:return new z.w(...O);case 5:return new z.y(...O);default:throw new Error("Easing type not yet implemented")}}(A,...S);M.setEasingMode(O),this._easingFunctions[Q]=M}this.easingFunction.setValue(this._easingFunctions[Q],M)}getClassName(){return"FlowGraphEasingBlock"}}(0,c.g)("FlowGraphEasingBlock",j)}}]);