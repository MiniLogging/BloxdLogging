"use strict";(self["9jl1vn4ei5r"]=self["9jl1vn4ei5r"]||[]).push([[117],{15122:(M,p,b)=>{b.r(p),b.d(p,{EasingFunctionType:()=>Q,FlowGraphEasingBlock:()=>T});var Q,q=b(13897),B=b(13492),k=b(13477),u=b(11757);!function(M){M[M.CircleEase=0]="CircleEase",M[M.BackEase=1]="BackEase",M[M.BounceEase=2]="BounceEase",M[M.CubicEase=3]="CubicEase",M[M.ElasticEase=4]="ElasticEase",M[M.ExponentialEase=5]="ExponentialEase",M[M.PowerEase=6]="PowerEase",M[M.QuadraticEase=7]="QuadraticEase",M[M.QuarticEase=8]="QuarticEase",M[M.QuinticEase=9]="QuinticEase",M[M.SineEase=10]="SineEase",M[M.BezierCurveEase=11]="BezierCurveEase"}(Q||(Q={}));class T extends B.b{constructor(M){super(M),this.config=M,this._easingFunctions={},this.type=this.registerDataInput("type",k.c,11),this.mode=this.registerDataInput("mode",k.q,0),this.parameters=this.registerDataInput("parameters",k.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",k.c)}_updateOutputs(M){const p=this.type.getValue(M),b=this.mode.getValue(M),Q=this.parameters.getValue(M);if(void 0===p||void 0===b)return;const B=`${p}-${b}-${Q.join("-")}`;if(!this._easingFunctions[B]){const M=function(M){for(var p=arguments.length,b=new Array(p>1?p-1:0),Q=1;Q<p;Q++)b[Q-1]=arguments[Q];switch(M){case 11:return new q.h(...b);case 0:return new q.k;case 1:return new q.d(...b);case 2:return new q.i(...b);case 3:return new q.m;case 4:return new q.t(...b);case 5:return new q.w(...b);default:throw new Error("Easing type not yet implemented")}}(p,...Q);M.setEasingMode(b),this._easingFunctions[B]=M}this.easingFunction.setValue(this._easingFunctions[B],M)}getClassName(){return"FlowGraphEasingBlock"}}(0,u.g)("FlowGraphEasingBlock",T)}}]);