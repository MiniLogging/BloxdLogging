"use strict";(self.fwuvyyymhp8=self.fwuvyyymhp8||[]).push([[117],{15741:(N,U,V)=>{V.r(U),V.d(U,{EasingFunctionType:()=>A,FlowGraphEasingBlock:()=>z});var A,t=V(14505),n=V(14058),q=V(14036),i=V(12344);!function(N){N[N.CircleEase=0]="CircleEase",N[N.BackEase=1]="BackEase",N[N.BounceEase=2]="BounceEase",N[N.CubicEase=3]="CubicEase",N[N.ElasticEase=4]="ElasticEase",N[N.ExponentialEase=5]="ExponentialEase",N[N.PowerEase=6]="PowerEase",N[N.QuadraticEase=7]="QuadraticEase",N[N.QuarticEase=8]="QuarticEase",N[N.QuinticEase=9]="QuinticEase",N[N.SineEase=10]="SineEase",N[N.BezierCurveEase=11]="BezierCurveEase"}(A||(A={}));class z extends n.c{constructor(N){super(N),this.config=N,this._easingFunctions={},this.type=this.registerDataInput("type",q.b,11),this.mode=this.registerDataInput("mode",q.p,0),this.parameters=this.registerDataInput("parameters",q.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",q.b)}_updateOutputs(N){const U=this.type.getValue(N),V=this.mode.getValue(N),A=this.parameters.getValue(N);if(void 0===U||void 0===V)return;const n=`${U}-${V}-${A.join("-")}`;if(!this._easingFunctions[n]){const N=function(N){for(var U=arguments.length,V=new Array(U>1?U-1:0),A=1;A<U;A++)V[A-1]=arguments[A];switch(N){case 11:return new t.e(...V);case 0:return new t.k;case 1:return new t.c(...V);case 2:return new t.h(...V);case 3:return new t.n;case 4:return new t.r(...V);case 5:return new t.s(...V);default:throw new Error("Easing type not yet implemented")}}(U,...A);N.setEasingMode(V),this._easingFunctions[n]=N}this.easingFunction.setValue(this._easingFunctions[n],N)}getClassName(){return"FlowGraphEasingBlock"}}(0,i.e)("FlowGraphEasingBlock",z)}}]);