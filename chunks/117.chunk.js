"use strict";(self.h66iwo8dvgq=self.h66iwo8dvgq||[]).push([[117],{15386:(b,X,P)=>{P.r(X),P.d(X,{EasingFunctionType:()=>Q,FlowGraphEasingBlock:()=>u});var Q,S=P(14094),d=P(13647),N=P(13631),a=P(11802);!function(b){b[b.CircleEase=0]="CircleEase",b[b.BackEase=1]="BackEase",b[b.BounceEase=2]="BounceEase",b[b.CubicEase=3]="CubicEase",b[b.ElasticEase=4]="ElasticEase",b[b.ExponentialEase=5]="ExponentialEase",b[b.PowerEase=6]="PowerEase",b[b.QuadraticEase=7]="QuadraticEase",b[b.QuarticEase=8]="QuarticEase",b[b.QuinticEase=9]="QuinticEase",b[b.SineEase=10]="SineEase",b[b.BezierCurveEase=11]="BezierCurveEase"}(Q||(Q={}));class u extends d.c{constructor(b){super(b),this.config=b,this._easingFunctions={},this.type=this.registerDataInput("type",N.e,11),this.mode=this.registerDataInput("mode",N.t,0),this.parameters=this.registerDataInput("parameters",N.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",N.e)}_updateOutputs(b){const X=this.type.getValue(b),P=this.mode.getValue(b),Q=this.parameters.getValue(b);if(void 0===X||void 0===P)return;const d=`${X}-${P}-${Q.join("-")}`;if(!this._easingFunctions[d]){const b=function(b){for(var X=arguments.length,P=new Array(X>1?X-1:0),Q=1;Q<X;Q++)P[Q-1]=arguments[Q];switch(b){case 11:return new S.h(...P);case 0:return new S.l;case 1:return new S.d(...P);case 2:return new S.i(...P);case 3:return new S.m;case 4:return new S.q(...P);case 5:return new S.u(...P);default:throw new Error("Easing type not yet implemented")}}(X,...Q);b.setEasingMode(P),this._easingFunctions[d]=b}this.easingFunction.setValue(this._easingFunctions[d],b)}getClassName(){return"FlowGraphEasingBlock"}}(0,a.h)("FlowGraphEasingBlock",u)}}]);