"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[117],{14745:(B,E,v)=>{v.r(E),v.d(E,{EasingFunctionType:()=>z,FlowGraphEasingBlock:()=>x});var z,o=v(13541),q=v(13121),c=v(13102),S=v(11345);!function(B){B[B.CircleEase=0]="CircleEase",B[B.BackEase=1]="BackEase",B[B.BounceEase=2]="BounceEase",B[B.CubicEase=3]="CubicEase",B[B.ElasticEase=4]="ElasticEase",B[B.ExponentialEase=5]="ExponentialEase",B[B.PowerEase=6]="PowerEase",B[B.QuadraticEase=7]="QuadraticEase",B[B.QuarticEase=8]="QuarticEase",B[B.QuinticEase=9]="QuinticEase",B[B.SineEase=10]="SineEase",B[B.BezierCurveEase=11]="BezierCurveEase"}(z||(z={}));class x extends q.c{constructor(B){super(B),this.config=B,this._easingFunctions={},this.type=this.registerDataInput("type",c.c,11),this.mode=this.registerDataInput("mode",c.v,0),this.parameters=this.registerDataInput("parameters",c.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",c.c)}_updateOutputs(B){const E=this.type.getValue(B),v=this.mode.getValue(B),z=this.parameters.getValue(B);if(void 0===E||void 0===v)return;const q=`${E}-${v}-${z.join("-")}`;if(!this._easingFunctions[q]){const B=function(B){for(var E=arguments.length,v=new Array(E>1?E-1:0),z=1;z<E;z++)v[z-1]=arguments[z];switch(B){case 11:return new o.f(...v);case 0:return new o.m;case 1:return new o.d(...v);case 2:return new o.j(...v);case 3:return new o.o;case 4:return new o.w(...v);case 5:return new o.x(...v);default:throw new Error("Easing type not yet implemented")}}(E,...z);B.setEasingMode(v),this._easingFunctions[q]=B}this.easingFunction.setValue(this._easingFunctions[q],B)}getClassName(){return"FlowGraphEasingBlock"}}(0,S.f)("FlowGraphEasingBlock",x)}}]);