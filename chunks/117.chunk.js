"use strict";(self.nyfa010khv=self.nyfa010khv||[]).push([[117],{15503:(L,r,p)=>{p.r(r),p.d(r,{EasingFunctionType:()=>J,FlowGraphEasingBlock:()=>G});var J,i=p(14297),n=p(13882),j=p(13868),z=p(12087);!function(L){L[L.CircleEase=0]="CircleEase",L[L.BackEase=1]="BackEase",L[L.BounceEase=2]="BounceEase",L[L.CubicEase=3]="CubicEase",L[L.ElasticEase=4]="ElasticEase",L[L.ExponentialEase=5]="ExponentialEase",L[L.PowerEase=6]="PowerEase",L[L.QuadraticEase=7]="QuadraticEase",L[L.QuarticEase=8]="QuarticEase",L[L.QuinticEase=9]="QuinticEase",L[L.SineEase=10]="SineEase",L[L.BezierCurveEase=11]="BezierCurveEase"}(J||(J={}));class G extends n.b{constructor(L){super(L),this.config=L,this._easingFunctions={},this.type=this.registerDataInput("type",j.d,11),this.mode=this.registerDataInput("mode",j.v,0),this.parameters=this.registerDataInput("parameters",j.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",j.d)}_updateOutputs(L){const r=this.type.getValue(L),p=this.mode.getValue(L),J=this.parameters.getValue(L);if(void 0===r||void 0===p)return;const n=`${r}-${p}-${J.join("-")}`;if(!this._easingFunctions[n]){const L=function(L){for(var r=arguments.length,p=new Array(r>1?r-1:0),J=1;J<r;J++)p[J-1]=arguments[J];switch(L){case 11:return new i.e(...p);case 0:return new i.m;case 1:return new i.c(...p);case 2:return new i.i(...p);case 3:return new i.n;case 4:return new i.r(...p);case 5:return new i.t(...p);default:throw new Error("Easing type not yet implemented")}}(r,...J);L.setEasingMode(p),this._easingFunctions[n]=L}this.easingFunction.setValue(this._easingFunctions[n],L)}getClassName(){return"FlowGraphEasingBlock"}}(0,z.e)("FlowGraphEasingBlock",G)}}]);