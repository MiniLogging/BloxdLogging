"use strict";(self.b15p7b72fr8=self.b15p7b72fr8||[]).push([[117],{16038:(s,k,h)=>{h.r(k),h.d(k,{EasingFunctionType:()=>A,FlowGraphEasingBlock:()=>H});var A,g=h(14774),ms=h(14325),i=h(14315),K=h(12543);!function(s){s[s.CircleEase=0]="CircleEase",s[s.BackEase=1]="BackEase",s[s.BounceEase=2]="BounceEase",s[s.CubicEase=3]="CubicEase",s[s.ElasticEase=4]="ElasticEase",s[s.ExponentialEase=5]="ExponentialEase",s[s.PowerEase=6]="PowerEase",s[s.QuadraticEase=7]="QuadraticEase",s[s.QuarticEase=8]="QuarticEase",s[s.QuinticEase=9]="QuinticEase",s[s.SineEase=10]="SineEase",s[s.BezierCurveEase=11]="BezierCurveEase"}(A||(A={}));class H extends ms.e{constructor(s){super(s),this.config=s,this._easingFunctions={},this.type=this.registerDataInput("type",i.c,11),this.mode=this.registerDataInput("mode",i.m,0),this.parameters=this.registerDataInput("parameters",i.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",i.c)}_updateOutputs(s){const k=this.type.getValue(s),h=this.mode.getValue(s),A=this.parameters.getValue(s);if(void 0===k||void 0===h)return;const ms=`${k}-${h}-${A.join("-")}`;if(!this._easingFunctions[ms]){const s=function(s){for(var k=arguments.length,h=new Array(k>1?k-1:0),A=1;A<k;A++)h[A-1]=arguments[A];switch(s){case 11:return new g.g(...h);case 0:return new g.j;case 1:return new g.e(...h);case 2:return new g.i(...h);case 3:return new g.l;case 4:return new g.p(...h);case 5:return new g.s(...h);default:throw new Error("Easing type not yet implemented")}}(k,...A);s.setEasingMode(h),this._easingFunctions[ms]=s}this.easingFunction.setValue(this._easingFunctions[ms],s)}getClassName(){return"FlowGraphEasingBlock"}}(0,K.f)("FlowGraphEasingBlock",H)}}]);