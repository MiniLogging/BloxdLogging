"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[117],{16037:(L,U,x)=>{x.r(U),x.d(U,{EasingFunctionType:()=>mL,FlowGraphEasingBlock:()=>o});var mL,p=x(14785),G=x(14371),F=x(14348),a=x(12547);!function(L){L[L.CircleEase=0]="CircleEase",L[L.BackEase=1]="BackEase",L[L.BounceEase=2]="BounceEase",L[L.CubicEase=3]="CubicEase",L[L.ElasticEase=4]="ElasticEase",L[L.ExponentialEase=5]="ExponentialEase",L[L.PowerEase=6]="PowerEase",L[L.QuadraticEase=7]="QuadraticEase",L[L.QuarticEase=8]="QuarticEase",L[L.QuinticEase=9]="QuinticEase",L[L.SineEase=10]="SineEase",L[L.BezierCurveEase=11]="BezierCurveEase"}(mL||(mL={}));class o extends G.e{constructor(L){super(L),this.config=L,this._easingFunctions={},this.type=this.registerDataInput("type",F.c,11),this.mode=this.registerDataInput("mode",F.u,0),this.parameters=this.registerDataInput("parameters",F.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",F.c)}_updateOutputs(L){const U=this.type.getValue(L),x=this.mode.getValue(L),mL=this.parameters.getValue(L);if(void 0===U||void 0===x)return;const G=`${U}-${x}-${mL.join("-")}`;if(!this._easingFunctions[G]){const L=function(L){for(var U=arguments.length,x=new Array(U>1?U-1:0),mL=1;mL<U;mL++)x[mL-1]=arguments[mL];switch(L){case 11:return new p.e(...x);case 0:return new p.l;case 1:return new p.c(...x);case 2:return new p.i(...x);case 3:return new p.n;case 4:return new p.v(...x);case 5:return new p.y(...x);default:throw new Error("Easing type not yet implemented")}}(U,...mL);L.setEasingMode(x),this._easingFunctions[G]=L}this.easingFunction.setValue(this._easingFunctions[G],L)}getClassName(){return"FlowGraphEasingBlock"}}(0,a.d)("FlowGraphEasingBlock",o)}}]);