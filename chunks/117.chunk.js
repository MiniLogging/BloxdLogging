"use strict";(self["3nlrbof8msu"]=self["3nlrbof8msu"]||[]).push([[117],{16140:(t,b,Z)=>{Z.r(b),Z.d(b,{EasingFunctionType:()=>J,FlowGraphEasingBlock:()=>C});var J,S=Z(14906),P=Z(14432),v=Z(14405),h=Z(12688);!function(t){t[t.CircleEase=0]="CircleEase",t[t.BackEase=1]="BackEase",t[t.BounceEase=2]="BounceEase",t[t.CubicEase=3]="CubicEase",t[t.ElasticEase=4]="ElasticEase",t[t.ExponentialEase=5]="ExponentialEase",t[t.PowerEase=6]="PowerEase",t[t.QuadraticEase=7]="QuadraticEase",t[t.QuarticEase=8]="QuarticEase",t[t.QuinticEase=9]="QuinticEase",t[t.SineEase=10]="SineEase",t[t.BezierCurveEase=11]="BezierCurveEase"}(J||(J={}));class C extends P.e{constructor(t){super(t),this.config=t,this._easingFunctions={},this.type=this.registerDataInput("type",v.c,11),this.mode=this.registerDataInput("mode",v.q,0),this.parameters=this.registerDataInput("parameters",v.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",v.c)}_updateOutputs(t){const b=this.type.getValue(t),Z=this.mode.getValue(t),J=this.parameters.getValue(t);if(void 0===b||void 0===Z)return;const P=`${b}-${Z}-${J.join("-")}`;if(!this._easingFunctions[P]){const t=function(t){for(var b=arguments.length,Z=new Array(b>1?b-1:0),J=1;J<b;J++)Z[J-1]=arguments[J];switch(t){case 11:return new S.i(...Z);case 0:return new S.n;case 1:return new S.e(...Z);case 2:return new S.l(...Z);case 3:return new S.p;case 4:return new S.v(...Z);case 5:return new S.y(...Z);default:throw new Error("Easing type not yet implemented")}}(b,...J);t.setEasingMode(Z),this._easingFunctions[P]=t}this.easingFunction.setValue(this._easingFunctions[P],t)}getClassName(){return"FlowGraphEasingBlock"}}(0,h.f)("FlowGraphEasingBlock",C)}}]);