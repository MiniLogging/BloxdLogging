"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[117],{15141:(C,U,K)=>{K.r(U),K.d(U,{EasingFunctionType:()=>m,FlowGraphEasingBlock:()=>t});var m,O=K(13975),X=K(13539),A=K(13514),e=K(11789);!function(C){C[C.CircleEase=0]="CircleEase",C[C.BackEase=1]="BackEase",C[C.BounceEase=2]="BounceEase",C[C.CubicEase=3]="CubicEase",C[C.ElasticEase=4]="ElasticEase",C[C.ExponentialEase=5]="ExponentialEase",C[C.PowerEase=6]="PowerEase",C[C.QuadraticEase=7]="QuadraticEase",C[C.QuarticEase=8]="QuarticEase",C[C.QuinticEase=9]="QuinticEase",C[C.SineEase=10]="SineEase",C[C.BezierCurveEase=11]="BezierCurveEase"}(m||(m={}));class t extends X.e{constructor(C){super(C),this.config=C,this._easingFunctions={},this.type=this.registerDataInput("type",A.c,11),this.mode=this.registerDataInput("mode",A.w,0),this.parameters=this.registerDataInput("parameters",A.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",A.c)}_updateOutputs(C){const U=this.type.getValue(C),K=this.mode.getValue(C),m=this.parameters.getValue(C);if(void 0===U||void 0===K)return;const X=`${U}-${K}-${m.join("-")}`;if(!this._easingFunctions[X]){const C=function(C){for(var U=arguments.length,K=new Array(U>1?U-1:0),m=1;m<U;m++)K[m-1]=arguments[m];switch(C){case 11:return new O.g(...K);case 0:return new O.l;case 1:return new O.c(...K);case 2:return new O.k(...K);case 3:return new O.p;case 4:return new O.s(...K);case 5:return new O.w(...K);default:throw new Error("Easing type not yet implemented")}}(U,...m);C.setEasingMode(K),this._easingFunctions[X]=C}this.easingFunction.setValue(this._easingFunctions[X],C)}getClassName(){return"FlowGraphEasingBlock"}}(0,e.h)("FlowGraphEasingBlock",t)}}]);