"use strict";(self.xeuzlpp225k=self.xeuzlpp225k||[]).push([[117],{14699:(k,Q,i)=>{i.r(Q),i.d(Q,{EasingFunctionType:()=>Z,FlowGraphEasingBlock:()=>m});var Z,U=i(13520),C=i(13084),B=i(13064),o=i(11253);!function(k){k[k.CircleEase=0]="CircleEase",k[k.BackEase=1]="BackEase",k[k.BounceEase=2]="BounceEase",k[k.CubicEase=3]="CubicEase",k[k.ElasticEase=4]="ElasticEase",k[k.ExponentialEase=5]="ExponentialEase",k[k.PowerEase=6]="PowerEase",k[k.QuadraticEase=7]="QuadraticEase",k[k.QuarticEase=8]="QuarticEase",k[k.QuinticEase=9]="QuinticEase",k[k.SineEase=10]="SineEase",k[k.BezierCurveEase=11]="BezierCurveEase"}(Z||(Z={}));class m extends C.e{constructor(k){super(k),this.config=k,this._easingFunctions={},this.type=this.registerDataInput("type",B.b,11),this.mode=this.registerDataInput("mode",B.o,0),this.parameters=this.registerDataInput("parameters",B.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",B.b)}_updateOutputs(k){const Q=this.type.getValue(k),i=this.mode.getValue(k),Z=this.parameters.getValue(k);if(void 0===Q||void 0===i)return;const C=`${Q}-${i}-${Z.join("-")}`;if(!this._easingFunctions[C]){const k=function(k){for(var Q=arguments.length,i=new Array(Q>1?Q-1:0),Z=1;Z<Q;Z++)i[Z-1]=arguments[Z];switch(k){case 11:return new U.e(...i);case 0:return new U.j;case 1:return new U.d(...i);case 2:return new U.f(...i);case 3:return new U.k;case 4:return new U.s(...i);case 5:return new U.t(...i);default:throw new Error("Easing type not yet implemented")}}(Q,...Z);k.setEasingMode(i),this._easingFunctions[C]=k}this.easingFunction.setValue(this._easingFunctions[C],k)}getClassName(){return"FlowGraphEasingBlock"}}(0,o.e)("FlowGraphEasingBlock",m)}}]);