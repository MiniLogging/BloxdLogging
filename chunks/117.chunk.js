"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[117],{15688:(H,u,J)=>{J.r(u),J.d(u,{EasingFunctionType:()=>O,FlowGraphEasingBlock:()=>B});var O,U=J(14472),h=J(14041),w=J(14018),g=J(12304);!function(H){H[H.CircleEase=0]="CircleEase",H[H.BackEase=1]="BackEase",H[H.BounceEase=2]="BounceEase",H[H.CubicEase=3]="CubicEase",H[H.ElasticEase=4]="ElasticEase",H[H.ExponentialEase=5]="ExponentialEase",H[H.PowerEase=6]="PowerEase",H[H.QuadraticEase=7]="QuadraticEase",H[H.QuarticEase=8]="QuarticEase",H[H.QuinticEase=9]="QuinticEase",H[H.SineEase=10]="SineEase",H[H.BezierCurveEase=11]="BezierCurveEase"}(O||(O={}));class B extends h.b{constructor(H){super(H),this.config=H,this._easingFunctions={},this.type=this.registerDataInput("type",w.d,11),this.mode=this.registerDataInput("mode",w.z,0),this.parameters=this.registerDataInput("parameters",w.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",w.d)}_updateOutputs(H){const u=this.type.getValue(H),J=this.mode.getValue(H),O=this.parameters.getValue(H);if(void 0===u||void 0===J)return;const h=`${u}-${J}-${O.join("-")}`;if(!this._easingFunctions[h]){const H=function(H){for(var u=arguments.length,J=new Array(u>1?u-1:0),O=1;O<u;O++)J[O-1]=arguments[O];switch(H){case 11:return new U.g(...J);case 0:return new U.l;case 1:return new U.e(...J);case 2:return new U.k(...J);case 3:return new U.n;case 4:return new U.t(...J);case 5:return new U.u(...J);default:throw new Error("Easing type not yet implemented")}}(u,...O);H.setEasingMode(J),this._easingFunctions[h]=H}this.easingFunction.setValue(this._easingFunctions[h],H)}getClassName(){return"FlowGraphEasingBlock"}}(0,g.f)("FlowGraphEasingBlock",B)}}]);