"use strict";(self.bbj0x35f849=self.bbj0x35f849||[]).push([[117],{14529:(N,q,C)=>{C.r(q),C.d(q,{EasingFunctionType:()=>d,FlowGraphEasingBlock:()=>w});var d,U=C(13264),W=C(12856),a=C(12831),F=C(11076);!function(N){N[N.CircleEase=0]="CircleEase",N[N.BackEase=1]="BackEase",N[N.BounceEase=2]="BounceEase",N[N.CubicEase=3]="CubicEase",N[N.ElasticEase=4]="ElasticEase",N[N.ExponentialEase=5]="ExponentialEase",N[N.PowerEase=6]="PowerEase",N[N.QuadraticEase=7]="QuadraticEase",N[N.QuarticEase=8]="QuarticEase",N[N.QuinticEase=9]="QuinticEase",N[N.SineEase=10]="SineEase",N[N.BezierCurveEase=11]="BezierCurveEase"}(d||(d={}));class w extends W.d{constructor(N){super(N),this.config=N,this._easingFunctions={},this.type=this.registerDataInput("type",a.b,11),this.mode=this.registerDataInput("mode",a.r,0),this.parameters=this.registerDataInput("parameters",a.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",a.b)}_updateOutputs(N){const q=this.type.getValue(N),C=this.mode.getValue(N),d=this.parameters.getValue(N);if(void 0===q||void 0===C)return;const W=`${q}-${C}-${d.join("-")}`;if(!this._easingFunctions[W]){const N=function(N){for(var q=arguments.length,C=new Array(q>1?q-1:0),d=1;d<q;d++)C[d-1]=arguments[d];switch(N){case 11:return new U.f(...C);case 0:return new U.k;case 1:return new U.e(...C);case 2:return new U.h(...C);case 3:return new U.n;case 4:return new U.q(...C);case 5:return new U.s(...C);default:throw new Error("Easing type not yet implemented")}}(q,...d);N.setEasingMode(C),this._easingFunctions[W]=N}this.easingFunction.setValue(this._easingFunctions[W],N)}getClassName(){return"FlowGraphEasingBlock"}}(0,F.h)("FlowGraphEasingBlock",w)}}]);