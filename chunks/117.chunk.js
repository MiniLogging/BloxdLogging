"use strict";(self["9s4i8ue3jq"]=self["9s4i8ue3jq"]||[]).push([[117],{16189:(a,c,o)=>{o.r(c),o.d(c,{EasingFunctionType:()=>s,FlowGraphEasingBlock:()=>G});var s,q=o(14962),t=o(14423),i=o(14394),p=o(12776);!function(a){a[a.CircleEase=0]="CircleEase",a[a.BackEase=1]="BackEase",a[a.BounceEase=2]="BounceEase",a[a.CubicEase=3]="CubicEase",a[a.ElasticEase=4]="ElasticEase",a[a.ExponentialEase=5]="ExponentialEase",a[a.PowerEase=6]="PowerEase",a[a.QuadraticEase=7]="QuadraticEase",a[a.QuarticEase=8]="QuarticEase",a[a.QuinticEase=9]="QuinticEase",a[a.SineEase=10]="SineEase",a[a.BezierCurveEase=11]="BezierCurveEase"}(s||(s={}));class G extends t.e{constructor(a){super(a),this.config=a,this._easingFunctions={},this.type=this.registerDataInput("type",i.c,11),this.mode=this.registerDataInput("mode",i.o,0),this.parameters=this.registerDataInput("parameters",i.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",i.c)}_updateOutputs(a){const c=this.type.getValue(a),o=this.mode.getValue(a),s=this.parameters.getValue(a);if(void 0===c||void 0===o)return;const t=`${c}-${o}-${s.join("-")}`;if(!this._easingFunctions[t]){const a=function(a){for(var c=arguments.length,o=new Array(c>1?c-1:0),s=1;s<c;s++)o[s-1]=arguments[s];switch(a){case 11:return new q.f(...o);case 0:return new q.m;case 1:return new q.b(...o);case 2:return new q.i(...o);case 3:return new q.o;case 4:return new q.t(...o);case 5:return new q.u(...o);default:throw new Error("Easing type not yet implemented")}}(c,...s);a.setEasingMode(o),this._easingFunctions[t]=a}this.easingFunction.setValue(this._easingFunctions[t],a)}getClassName(){return"FlowGraphEasingBlock"}}(0,p.d)("FlowGraphEasingBlock",G)}}]);