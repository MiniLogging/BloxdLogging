"use strict";(self.i6szn8jgzh=self.i6szn8jgzh||[]).push([[117],{15270:(b,n,i)=>{i.r(n),i.d(n,{EasingFunctionType:()=>e,FlowGraphEasingBlock:()=>L});var e,V=i(14009),Q=i(13547),U=i(13522),Y=i(11734);!function(b){b[b.CircleEase=0]="CircleEase",b[b.BackEase=1]="BackEase",b[b.BounceEase=2]="BounceEase",b[b.CubicEase=3]="CubicEase",b[b.ElasticEase=4]="ElasticEase",b[b.ExponentialEase=5]="ExponentialEase",b[b.PowerEase=6]="PowerEase",b[b.QuadraticEase=7]="QuadraticEase",b[b.QuarticEase=8]="QuarticEase",b[b.QuinticEase=9]="QuinticEase",b[b.SineEase=10]="SineEase",b[b.BezierCurveEase=11]="BezierCurveEase"}(e||(e={}));class L extends Q.c{constructor(b){super(b),this.config=b,this._easingFunctions={},this.type=this.registerDataInput("type",U.c,11),this.mode=this.registerDataInput("mode",U.q,0),this.parameters=this.registerDataInput("parameters",U.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",U.c)}_updateOutputs(b){const n=this.type.getValue(b),i=this.mode.getValue(b),e=this.parameters.getValue(b);if(void 0===n||void 0===i)return;const Q=`${n}-${i}-${e.join("-")}`;if(!this._easingFunctions[Q]){const b=function(b){for(var n=arguments.length,i=new Array(n>1?n-1:0),e=1;e<n;e++)i[e-1]=arguments[e];switch(b){case 11:return new V.c(...i);case 0:return new V.k;case 1:return new V.b(...i);case 2:return new V.g(...i);case 3:return new V.n;case 4:return new V.r(...i);case 5:return new V.s(...i);default:throw new Error("Easing type not yet implemented")}}(n,...e);b.setEasingMode(i),this._easingFunctions[Q]=b}this.easingFunction.setValue(this._easingFunctions[Q],b)}getClassName(){return"FlowGraphEasingBlock"}}(0,Y.i)("FlowGraphEasingBlock",L)}}]);