"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[117],{14996:(F,P,f)=>{f.r(P),f.d(P,{EasingFunctionType:()=>c,FlowGraphEasingBlock:()=>o});var c,N=f(13738),q=f(13287),H=f(13265),A=f(11587);!function(F){F[F.CircleEase=0]="CircleEase",F[F.BackEase=1]="BackEase",F[F.BounceEase=2]="BounceEase",F[F.CubicEase=3]="CubicEase",F[F.ElasticEase=4]="ElasticEase",F[F.ExponentialEase=5]="ExponentialEase",F[F.PowerEase=6]="PowerEase",F[F.QuadraticEase=7]="QuadraticEase",F[F.QuarticEase=8]="QuarticEase",F[F.QuinticEase=9]="QuinticEase",F[F.SineEase=10]="SineEase",F[F.BezierCurveEase=11]="BezierCurveEase"}(c||(c={}));class o extends q.c{constructor(F){super(F),this.config=F,this._easingFunctions={},this.type=this.registerDataInput("type",H.c,11),this.mode=this.registerDataInput("mode",H.o,0),this.parameters=this.registerDataInput("parameters",H.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",H.c)}_updateOutputs(F){const P=this.type.getValue(F),f=this.mode.getValue(F),c=this.parameters.getValue(F);if(void 0===P||void 0===f)return;const q=`${P}-${f}-${c.join("-")}`;if(!this._easingFunctions[q]){const F=function(F){for(var P=arguments.length,f=new Array(P>1?P-1:0),c=1;c<P;c++)f[c-1]=arguments[c];switch(F){case 11:return new N.f(...f);case 0:return new N.h;case 1:return new N.d(...f);case 2:return new N.g(...f);case 3:return new N.i;case 4:return new N.l(...f);case 5:return new N.p(...f);default:throw new Error("Easing type not yet implemented")}}(P,...c);F.setEasingMode(f),this._easingFunctions[q]=F}this.easingFunction.setValue(this._easingFunctions[q],F)}getClassName(){return"FlowGraphEasingBlock"}}(0,A.f)("FlowGraphEasingBlock",o)}}]);