"use strict";(self["9d4d30r2sf"]=self["9d4d30r2sf"]||[]).push([[117],{15877:(o,v,V)=>{V.r(v),V.d(v,{EasingFunctionType:()=>g,FlowGraphEasingBlock:()=>n});var g,E=V(14705),I=V(14259),Q=V(14241),U=V(12449);!function(o){o[o.CircleEase=0]="CircleEase",o[o.BackEase=1]="BackEase",o[o.BounceEase=2]="BounceEase",o[o.CubicEase=3]="CubicEase",o[o.ElasticEase=4]="ElasticEase",o[o.ExponentialEase=5]="ExponentialEase",o[o.PowerEase=6]="PowerEase",o[o.QuadraticEase=7]="QuadraticEase",o[o.QuarticEase=8]="QuarticEase",o[o.QuinticEase=9]="QuinticEase",o[o.SineEase=10]="SineEase",o[o.BezierCurveEase=11]="BezierCurveEase"}(g||(g={}));class n extends I.b{constructor(o){super(o),this.config=o,this._easingFunctions={},this.type=this.registerDataInput("type",Q.e,11),this.mode=this.registerDataInput("mode",Q.t,0),this.parameters=this.registerDataInput("parameters",Q.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",Q.e)}_updateOutputs(o){const v=this.type.getValue(o),V=this.mode.getValue(o),g=this.parameters.getValue(o);if(void 0===v||void 0===V)return;const I=`${v}-${V}-${g.join("-")}`;if(!this._easingFunctions[I]){const o=function(o){for(var v=arguments.length,V=new Array(v>1?v-1:0),g=1;g<v;g++)V[g-1]=arguments[g];switch(o){case 11:return new E.f(...V);case 0:return new E.l;case 1:return new E.c(...V);case 2:return new E.j(...V);case 3:return new E.n;case 4:return new E.v(...V);case 5:return new E.x(...V);default:throw new Error("Easing type not yet implemented")}}(v,...g);o.setEasingMode(V),this._easingFunctions[I]=o}this.easingFunction.setValue(this._easingFunctions[I],o)}getClassName(){return"FlowGraphEasingBlock"}}(0,U.h)("FlowGraphEasingBlock",n)}}]);