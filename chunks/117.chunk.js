"use strict";(self.fyqbdzs5tyo=self.fyqbdzs5tyo||[]).push([[117],{14543:(V,I,A)=>{A.r(I),A.d(I,{EasingFunctionType:()=>B,FlowGraphEasingBlock:()=>c});var B,F=A(13389),E=A(12979),Y=A(12954),H=A(11189);!function(V){V[V.CircleEase=0]="CircleEase",V[V.BackEase=1]="BackEase",V[V.BounceEase=2]="BounceEase",V[V.CubicEase=3]="CubicEase",V[V.ElasticEase=4]="ElasticEase",V[V.ExponentialEase=5]="ExponentialEase",V[V.PowerEase=6]="PowerEase",V[V.QuadraticEase=7]="QuadraticEase",V[V.QuarticEase=8]="QuarticEase",V[V.QuinticEase=9]="QuinticEase",V[V.SineEase=10]="SineEase",V[V.BezierCurveEase=11]="BezierCurveEase"}(B||(B={}));class c extends E.d{constructor(V){super(V),this.config=V,this._easingFunctions={},this.type=this.registerDataInput("type",Y.e,11),this.mode=this.registerDataInput("mode",Y.v,0),this.parameters=this.registerDataInput("parameters",Y.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",Y.e)}_updateOutputs(V){const I=this.type.getValue(V),A=this.mode.getValue(V),B=this.parameters.getValue(V);if(void 0===I||void 0===A)return;const E=`${I}-${A}-${B.join("-")}`;if(!this._easingFunctions[E]){const V=function(V){for(var I=arguments.length,A=new Array(I>1?I-1:0),B=1;B<I;B++)A[B-1]=arguments[B];switch(V){case 11:return new F.f(...A);case 0:return new F.j;case 1:return new F.d(...A);case 2:return new F.i(...A);case 3:return new F.k;case 4:return new F.p(...A);case 5:return new F.t(...A);default:throw new Error("Easing type not yet implemented")}}(I,...B);V.setEasingMode(A),this._easingFunctions[E]=V}this.easingFunction.setValue(this._easingFunctions[E],V)}getClassName(){return"FlowGraphEasingBlock"}}(0,H.e)("FlowGraphEasingBlock",c)}}]);