"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[117],{15772:(M,Z,P)=>{P.r(Z),P.d(Z,{EasingFunctionType:()=>x,FlowGraphEasingBlock:()=>mM});var x,c=P(14564),w=P(14093),v=P(14073),G=P(12317);!function(M){M[M.CircleEase=0]="CircleEase",M[M.BackEase=1]="BackEase",M[M.BounceEase=2]="BounceEase",M[M.CubicEase=3]="CubicEase",M[M.ElasticEase=4]="ElasticEase",M[M.ExponentialEase=5]="ExponentialEase",M[M.PowerEase=6]="PowerEase",M[M.QuadraticEase=7]="QuadraticEase",M[M.QuarticEase=8]="QuarticEase",M[M.QuinticEase=9]="QuinticEase",M[M.SineEase=10]="SineEase",M[M.BezierCurveEase=11]="BezierCurveEase"}(x||(x={}));class mM extends w.c{constructor(M){super(M),this.config=M,this._easingFunctions={},this.type=this.registerDataInput("type",v.e,11),this.mode=this.registerDataInput("mode",v.u,0),this.parameters=this.registerDataInput("parameters",v.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",v.e)}_updateOutputs(M){const Z=this.type.getValue(M),P=this.mode.getValue(M),x=this.parameters.getValue(M);if(void 0===Z||void 0===P)return;const w=`${Z}-${P}-${x.join("-")}`;if(!this._easingFunctions[w]){const M=function(M){for(var Z=arguments.length,P=new Array(Z>1?Z-1:0),x=1;x<Z;x++)P[x-1]=arguments[x];switch(M){case 11:return new c.d(...P);case 0:return new c.i;case 1:return new c.c(...P);case 2:return new c.h(...P);case 3:return new c.k;case 4:return new c.o(...P);case 5:return new c.s(...P);default:throw new Error("Easing type not yet implemented")}}(Z,...x);M.setEasingMode(P),this._easingFunctions[w]=M}this.easingFunction.setValue(this._easingFunctions[w],M)}getClassName(){return"FlowGraphEasingBlock"}}(0,G.g)("FlowGraphEasingBlock",mM)}}]);