"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[117],{15781:(E,U,g)=>{g.r(U),g.d(U,{EasingFunctionType:()=>N,FlowGraphEasingBlock:()=>s});var N,L=g(14551),D=g(14077),S=g(14058),u=g(12292);!function(E){E[E.CircleEase=0]="CircleEase",E[E.BackEase=1]="BackEase",E[E.BounceEase=2]="BounceEase",E[E.CubicEase=3]="CubicEase",E[E.ElasticEase=4]="ElasticEase",E[E.ExponentialEase=5]="ExponentialEase",E[E.PowerEase=6]="PowerEase",E[E.QuadraticEase=7]="QuadraticEase",E[E.QuarticEase=8]="QuarticEase",E[E.QuinticEase=9]="QuinticEase",E[E.SineEase=10]="SineEase",E[E.BezierCurveEase=11]="BezierCurveEase"}(N||(N={}));class s extends D.b{constructor(E){super(E),this.config=E,this._easingFunctions={},this.type=this.registerDataInput("type",S.e,11),this.mode=this.registerDataInput("mode",S.t,0),this.parameters=this.registerDataInput("parameters",S.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",S.e)}_updateOutputs(E){const U=this.type.getValue(E),g=this.mode.getValue(E),N=this.parameters.getValue(E);if(void 0===U||void 0===g)return;const D=`${U}-${g}-${N.join("-")}`;if(!this._easingFunctions[D]){const E=function(E){for(var U=arguments.length,g=new Array(U>1?U-1:0),N=1;N<U;N++)g[N-1]=arguments[N];switch(E){case 11:return new L.g(...g);case 0:return new L.l;case 1:return new L.d(...g);case 2:return new L.h(...g);case 3:return new L.n;case 4:return new L.s(...g);case 5:return new L.v(...g);default:throw new Error("Easing type not yet implemented")}}(U,...N);E.setEasingMode(g),this._easingFunctions[D]=E}this.easingFunction.setValue(this._easingFunctions[D],E)}getClassName(){return"FlowGraphEasingBlock"}}(0,u.f)("FlowGraphEasingBlock",s)}}]);