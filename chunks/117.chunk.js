"use strict";(self.ksd6jhs1yr=self.ksd6jhs1yr||[]).push([[117],{15780:(C,c,d)=>{d.r(c),d.d(c,{EasingFunctionType:()=>b,FlowGraphEasingBlock:()=>p});var b,X=d(14607),P=d(14158),V=d(14126),R=d(12345);!function(C){C[C.CircleEase=0]="CircleEase",C[C.BackEase=1]="BackEase",C[C.BounceEase=2]="BounceEase",C[C.CubicEase=3]="CubicEase",C[C.ElasticEase=4]="ElasticEase",C[C.ExponentialEase=5]="ExponentialEase",C[C.PowerEase=6]="PowerEase",C[C.QuadraticEase=7]="QuadraticEase",C[C.QuarticEase=8]="QuarticEase",C[C.QuinticEase=9]="QuinticEase",C[C.SineEase=10]="SineEase",C[C.BezierCurveEase=11]="BezierCurveEase"}(b||(b={}));class p extends P.e{constructor(C){super(C),this.config=C,this._easingFunctions={},this.type=this.registerDataInput("type",V.b,11),this.mode=this.registerDataInput("mode",V.q,0),this.parameters=this.registerDataInput("parameters",V.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",V.b)}_updateOutputs(C){const c=this.type.getValue(C),d=this.mode.getValue(C),b=this.parameters.getValue(C);if(void 0===c||void 0===d)return;const P=`${c}-${d}-${b.join("-")}`;if(!this._easingFunctions[P]){const C=function(C){for(var c=arguments.length,d=new Array(c>1?c-1:0),b=1;b<c;b++)d[b-1]=arguments[b];switch(C){case 11:return new X.h(...d);case 0:return new X.k;case 1:return new X.d(...d);case 2:return new X.j(...d);case 3:return new X.m;case 4:return new X.t(...d);case 5:return new X.u(...d);default:throw new Error("Easing type not yet implemented")}}(c,...b);C.setEasingMode(d),this._easingFunctions[P]=C}this.easingFunction.setValue(this._easingFunctions[P],C)}getClassName(){return"FlowGraphEasingBlock"}}(0,R.e)("FlowGraphEasingBlock",p)}}]);