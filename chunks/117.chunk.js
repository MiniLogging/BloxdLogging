"use strict";(self.mo7o6813fhb=self.mo7o6813fhb||[]).push([[117],{15543:(t,U,y)=>{y.r(U),y.d(U,{EasingFunctionType:()=>I,FlowGraphEasingBlock:()=>P});var I,r=y(14307),Y=y(13865),mt=y(13845),X=y(12338);!function(t){t[t.CircleEase=0]="CircleEase",t[t.BackEase=1]="BackEase",t[t.BounceEase=2]="BounceEase",t[t.CubicEase=3]="CubicEase",t[t.ElasticEase=4]="ElasticEase",t[t.ExponentialEase=5]="ExponentialEase",t[t.PowerEase=6]="PowerEase",t[t.QuadraticEase=7]="QuadraticEase",t[t.QuarticEase=8]="QuarticEase",t[t.QuinticEase=9]="QuinticEase",t[t.SineEase=10]="SineEase",t[t.BezierCurveEase=11]="BezierCurveEase"}(I||(I={}));class P extends Y.c{constructor(t){super(t),this.config=t,this._easingFunctions={},this.type=this.registerDataInput("type",mt.e,11),this.mode=this.registerDataInput("mode",mt.w,0),this.parameters=this.registerDataInput("parameters",mt.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",mt.e)}_updateOutputs(t){const U=this.type.getValue(t),y=this.mode.getValue(t),I=this.parameters.getValue(t);if(void 0===U||void 0===y)return;const Y=`${U}-${y}-${I.join("-")}`;if(!this._easingFunctions[Y]){const t=function(t){for(var U=arguments.length,y=new Array(U>1?U-1:0),I=1;I<U;I++)y[I-1]=arguments[I];switch(t){case 11:return new r.e(...y);case 0:return new r.i;case 1:return new r.b(...y);case 2:return new r.g(...y);case 3:return new r.j;case 4:return new r.q(...y);case 5:return new r.u(...y);default:throw new Error("Easing type not yet implemented")}}(U,...I);t.setEasingMode(y),this._easingFunctions[Y]=t}this.easingFunction.setValue(this._easingFunctions[Y],t)}getClassName(){return"FlowGraphEasingBlock"}}(0,X.f)("FlowGraphEasingBlock",P)}}]);