"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[117],{15820:(U,G,C)=>{C.r(G),C.d(G,{EasingFunctionType:()=>L,FlowGraphEasingBlock:()=>K});var L,X=C(14629),l=C(14154),t=C(14134),E=C(12850);!function(U){U[U.CircleEase=0]="CircleEase",U[U.BackEase=1]="BackEase",U[U.BounceEase=2]="BounceEase",U[U.CubicEase=3]="CubicEase",U[U.ElasticEase=4]="ElasticEase",U[U.ExponentialEase=5]="ExponentialEase",U[U.PowerEase=6]="PowerEase",U[U.QuadraticEase=7]="QuadraticEase",U[U.QuarticEase=8]="QuarticEase",U[U.QuinticEase=9]="QuinticEase",U[U.SineEase=10]="SineEase",U[U.BezierCurveEase=11]="BezierCurveEase"}(L||(L={}));class K extends l.b{constructor(U){super(U),this.config=U,this._easingFunctions={},this.type=this.registerDataInput("type",t.c,11),this.mode=this.registerDataInput("mode",t.y,0),this.parameters=this.registerDataInput("parameters",t.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",t.c)}_updateOutputs(U){const G=this.type.getValue(U),C=this.mode.getValue(U),L=this.parameters.getValue(U);if(void 0===G||void 0===C)return;const l="".concat(G,"-").concat(C,"-").concat(L.join("-"));if(!this._easingFunctions[l]){const U=function(U){for(var G=arguments.length,C=new Array(G>1?G-1:0),L=1;L<G;L++)C[L-1]=arguments[L];switch(U){case 11:return new X.i(...C);case 0:return new X.m;case 1:return new X.e(...C);case 2:return new X.j(...C);case 3:return new X.n;case 4:return new X.r(...C);case 5:return new X.t(...C);default:throw new Error("Easing type not yet implemented")}}(G,...L);U.setEasingMode(C),this._easingFunctions[l]=U}this.easingFunction.setValue(this._easingFunctions[l],U)}getClassName(){return"FlowGraphEasingBlock"}}(0,E.e)("FlowGraphEasingBlock",K)}}]);