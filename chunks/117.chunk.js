"use strict";(self.hmihoa2fs98=self.hmihoa2fs98||[]).push([[117],{15041:(b,d,P)=>{P.r(d),P.d(d,{EasingFunctionType:()=>G,FlowGraphEasingBlock:()=>J});var G,W=P(13803),i=P(13386),q=P(13365),C=P(11639);!function(b){b[b.CircleEase=0]="CircleEase",b[b.BackEase=1]="BackEase",b[b.BounceEase=2]="BounceEase",b[b.CubicEase=3]="CubicEase",b[b.ElasticEase=4]="ElasticEase",b[b.ExponentialEase=5]="ExponentialEase",b[b.PowerEase=6]="PowerEase",b[b.QuadraticEase=7]="QuadraticEase",b[b.QuarticEase=8]="QuarticEase",b[b.QuinticEase=9]="QuinticEase",b[b.SineEase=10]="SineEase",b[b.BezierCurveEase=11]="BezierCurveEase"}(G||(G={}));class J extends i.b{constructor(b){super(b),this.config=b,this._easingFunctions={},this.type=this.registerDataInput("type",q.b,11),this.mode=this.registerDataInput("mode",q.p,0),this.parameters=this.registerDataInput("parameters",q.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",q.b)}_updateOutputs(b){const d=this.type.getValue(b),P=this.mode.getValue(b),G=this.parameters.getValue(b);if(void 0===d||void 0===P)return;const i=`${d}-${P}-${G.join("-")}`;if(!this._easingFunctions[i]){const b=function(b){for(var d=arguments.length,P=new Array(d>1?d-1:0),G=1;G<d;G++)P[G-1]=arguments[G];switch(b){case 11:return new W.e(...P);case 0:return new W.j;case 1:return new W.c(...P);case 2:return new W.g(...P);case 3:return new W.l;case 4:return new W.r(...P);case 5:return new W.u(...P);default:throw new Error("Easing type not yet implemented")}}(d,...G);b.setEasingMode(P),this._easingFunctions[i]=b}this.easingFunction.setValue(this._easingFunctions[i],b)}getClassName(){return"FlowGraphEasingBlock"}}(0,C.f)("FlowGraphEasingBlock",J)}}]);