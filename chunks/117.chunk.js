"use strict";(self.vfdo5lmva5i=self.vfdo5lmva5i||[]).push([[117],{15232:(w,o,H)=>{H.r(o),H.d(o,{EasingFunctionType:()=>h,FlowGraphEasingBlock:()=>X});var h,E=H(13944),e=H(13475),D=H(13455),t=H(11666);!function(w){w[w.CircleEase=0]="CircleEase",w[w.BackEase=1]="BackEase",w[w.BounceEase=2]="BounceEase",w[w.CubicEase=3]="CubicEase",w[w.ElasticEase=4]="ElasticEase",w[w.ExponentialEase=5]="ExponentialEase",w[w.PowerEase=6]="PowerEase",w[w.QuadraticEase=7]="QuadraticEase",w[w.QuarticEase=8]="QuarticEase",w[w.QuinticEase=9]="QuinticEase",w[w.SineEase=10]="SineEase",w[w.BezierCurveEase=11]="BezierCurveEase"}(h||(h={}));class X extends e.c{constructor(w){super(w),this.config=w,this._easingFunctions={},this.type=this.registerDataInput("type",D.e,11),this.mode=this.registerDataInput("mode",D.p,0),this.parameters=this.registerDataInput("parameters",D.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",D.e)}_updateOutputs(w){const o=this.type.getValue(w),H=this.mode.getValue(w),h=this.parameters.getValue(w);if(void 0===o||void 0===H)return;const e=`${o}-${H}-${h.join("-")}`;if(!this._easingFunctions[e]){const w=function(w){for(var o=arguments.length,H=new Array(o>1?o-1:0),h=1;h<o;h++)H[h-1]=arguments[h];switch(w){case 11:return new E.h(...H);case 0:return new E.m;case 1:return new E.e(...H);case 2:return new E.i(...H);case 3:return new E.o;case 4:return new E.q(...H);case 5:return new E.r(...H);default:throw new Error("Easing type not yet implemented")}}(o,...h);w.setEasingMode(H),this._easingFunctions[e]=w}this.easingFunction.setValue(this._easingFunctions[e],w)}getClassName(){return"FlowGraphEasingBlock"}}(0,t.g)("FlowGraphEasingBlock",X)}}]);