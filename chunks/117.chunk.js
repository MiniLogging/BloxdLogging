"use strict";(self["686i8587bmi"]=self["686i8587bmi"]||[]).push([[117],{16234:(h,d,T)=>{T.r(d),T.d(d,{EasingFunctionType:()=>Y,FlowGraphEasingBlock:()=>F});var Y,y=T(15003),C=T(14548),n=T(14528),X=T(12714);!function(h){h[h.CircleEase=0]="CircleEase",h[h.BackEase=1]="BackEase",h[h.BounceEase=2]="BounceEase",h[h.CubicEase=3]="CubicEase",h[h.ElasticEase=4]="ElasticEase",h[h.ExponentialEase=5]="ExponentialEase",h[h.PowerEase=6]="PowerEase",h[h.QuadraticEase=7]="QuadraticEase",h[h.QuarticEase=8]="QuarticEase",h[h.QuinticEase=9]="QuinticEase",h[h.SineEase=10]="SineEase",h[h.BezierCurveEase=11]="BezierCurveEase"}(Y||(Y={}));class F extends C.e{constructor(h){super(h),this.config=h,this._easingFunctions={},this.type=this.registerDataInput("type",n.b,11),this.mode=this.registerDataInput("mode",n.s,0),this.parameters=this.registerDataInput("parameters",n.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",n.b)}_updateOutputs(h){const d=this.type.getValue(h),T=this.mode.getValue(h),Y=this.parameters.getValue(h);if(void 0===d||void 0===T)return;const C=`${d}-${T}-${Y.join("-")}`;if(!this._easingFunctions[C]){const h=function(h){for(var d=arguments.length,T=new Array(d>1?d-1:0),Y=1;Y<d;Y++)T[Y-1]=arguments[Y];switch(h){case 11:return new y.d(...T);case 0:return new y.j;case 1:return new y.b(...T);case 2:return new y.h(...T);case 3:return new y.l;case 4:return new y.p(...T);case 5:return new y.s(...T);default:throw new Error("Easing type not yet implemented")}}(d,...Y);h.setEasingMode(T),this._easingFunctions[C]=h}this.easingFunction.setValue(this._easingFunctions[C],h)}getClassName(){return"FlowGraphEasingBlock"}}(0,X.e)("FlowGraphEasingBlock",F)}}]);