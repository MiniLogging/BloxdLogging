"use strict";(self.u4k1rqylno=self.u4k1rqylno||[]).push([[117],{15069:(e,E,H)=>{H.r(E),H.d(E,{EasingFunctionType:()=>N,FlowGraphEasingBlock:()=>D});var N,u=H(13877),z=H(13441),P=H(13415),M=H(11690);!function(e){e[e.CircleEase=0]="CircleEase",e[e.BackEase=1]="BackEase",e[e.BounceEase=2]="BounceEase",e[e.CubicEase=3]="CubicEase",e[e.ElasticEase=4]="ElasticEase",e[e.ExponentialEase=5]="ExponentialEase",e[e.PowerEase=6]="PowerEase",e[e.QuadraticEase=7]="QuadraticEase",e[e.QuarticEase=8]="QuarticEase",e[e.QuinticEase=9]="QuinticEase",e[e.SineEase=10]="SineEase",e[e.BezierCurveEase=11]="BezierCurveEase"}(N||(N={}));class D extends z.b{constructor(e){super(e),this.config=e,this._easingFunctions={},this.type=this.registerDataInput("type",P.b,11),this.mode=this.registerDataInput("mode",P.t,0),this.parameters=this.registerDataInput("parameters",P.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",P.b)}_updateOutputs(e){const E=this.type.getValue(e),H=this.mode.getValue(e),N=this.parameters.getValue(e);if(void 0===E||void 0===H)return;const z=`${E}-${H}-${N.join("-")}`;if(!this._easingFunctions[z]){const e=function(e){for(var E=arguments.length,H=new Array(E>1?E-1:0),N=1;N<E;N++)H[N-1]=arguments[N];switch(e){case 11:return new u.c(...H);case 0:return new u.g;case 1:return new u.b(...H);case 2:return new u.f(...H);case 3:return new u.i;case 4:return new u.n(...H);case 5:return new u.o(...H);default:throw new Error("Easing type not yet implemented")}}(E,...N);e.setEasingMode(H),this._easingFunctions[z]=e}this.easingFunction.setValue(this._easingFunctions[z],e)}getClassName(){return"FlowGraphEasingBlock"}}(0,M.g)("FlowGraphEasingBlock",D)}}]);