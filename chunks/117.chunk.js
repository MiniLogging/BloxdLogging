"use strict";(self.ynu1yiqvs98=self.ynu1yiqvs98||[]).push([[117],{14512:(I,E,j)=>{j.r(E),j.d(E,{EasingFunctionType:()=>e,FlowGraphEasingBlock:()=>U});var e,w=j(13276),z=j(12834),h=j(12819),t=j(11073);!function(I){I[I.CircleEase=0]="CircleEase",I[I.BackEase=1]="BackEase",I[I.BounceEase=2]="BounceEase",I[I.CubicEase=3]="CubicEase",I[I.ElasticEase=4]="ElasticEase",I[I.ExponentialEase=5]="ExponentialEase",I[I.PowerEase=6]="PowerEase",I[I.QuadraticEase=7]="QuadraticEase",I[I.QuarticEase=8]="QuarticEase",I[I.QuinticEase=9]="QuinticEase",I[I.SineEase=10]="SineEase",I[I.BezierCurveEase=11]="BezierCurveEase"}(e||(e={}));class U extends z.e{constructor(I){super(I),this.config=I,this._easingFunctions={},this.type=this.registerDataInput("type",h.e,11),this.mode=this.registerDataInput("mode",h.t,0),this.parameters=this.registerDataInput("parameters",h.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",h.e)}_updateOutputs(I){const E=this.type.getValue(I),j=this.mode.getValue(I),e=this.parameters.getValue(I);if(void 0===E||void 0===j)return;const z=`${E}-${j}-${e.join("-")}`;if(!this._easingFunctions[z]){const I=function(I){for(var E=arguments.length,j=new Array(E>1?E-1:0),e=1;e<E;e++)j[e-1]=arguments[e];switch(I){case 11:return new w.g(...j);case 0:return new w.m;case 1:return new w.c(...j);case 2:return new w.j(...j);case 3:return new w.q;case 4:return new w.v(...j);case 5:return new w.y(...j);default:throw new Error("Easing type not yet implemented")}}(E,...e);I.setEasingMode(j),this._easingFunctions[z]=I}this.easingFunction.setValue(this._easingFunctions[z],I)}getClassName(){return"FlowGraphEasingBlock"}}(0,t.h)("FlowGraphEasingBlock",U)}}]);