"use strict";(self["1kjc9ee3uyt"]=self["1kjc9ee3uyt"]||[]).push([[117],{14954:(w,E,G)=>{G.r(E),G.d(E,{EasingFunctionType:()=>P,FlowGraphEasingBlock:()=>U});var P,h=G(13729),B=G(13298),y=G(13281),x=G(11646);!function(w){w[w.CircleEase=0]="CircleEase",w[w.BackEase=1]="BackEase",w[w.BounceEase=2]="BounceEase",w[w.CubicEase=3]="CubicEase",w[w.ElasticEase=4]="ElasticEase",w[w.ExponentialEase=5]="ExponentialEase",w[w.PowerEase=6]="PowerEase",w[w.QuadraticEase=7]="QuadraticEase",w[w.QuarticEase=8]="QuarticEase",w[w.QuinticEase=9]="QuinticEase",w[w.SineEase=10]="SineEase",w[w.BezierCurveEase=11]="BezierCurveEase"}(P||(P={}));class U extends B.d{constructor(w){super(w),this.config=w,this._easingFunctions={},this.type=this.registerDataInput("type",y.c,11),this.mode=this.registerDataInput("mode",y.r,0),this.parameters=this.registerDataInput("parameters",y.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",y.c)}_updateOutputs(w){const E=this.type.getValue(w),G=this.mode.getValue(w),P=this.parameters.getValue(w);if(void 0===E||void 0===G)return;const B=`${E}-${G}-${P.join("-")}`;if(!this._easingFunctions[B]){const w=function(w){for(var E=arguments.length,G=new Array(E>1?E-1:0),P=1;P<E;P++)G[P-1]=arguments[P];switch(w){case 11:return new h.f(...G);case 0:return new h.k;case 1:return new h.d(...G);case 2:return new h.j(...G);case 3:return new h.n;case 4:return new h.t(...G);case 5:return new h.x(...G);default:throw new Error("Easing type not yet implemented")}}(E,...P);w.setEasingMode(G),this._easingFunctions[B]=w}this.easingFunction.setValue(this._easingFunctions[B],w)}getClassName(){return"FlowGraphEasingBlock"}}(0,x.g)("FlowGraphEasingBlock",U)}}]);