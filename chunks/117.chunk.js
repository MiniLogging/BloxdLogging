"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[117],{14452:(P,e,n)=>{n.r(e),n.d(e,{EasingFunctionType:()=>H,FlowGraphEasingBlock:()=>t});var H,S=n(13271),p=n(12841),k=n(12819),m=n(11096);!function(P){P[P.CircleEase=0]="CircleEase",P[P.BackEase=1]="BackEase",P[P.BounceEase=2]="BounceEase",P[P.CubicEase=3]="CubicEase",P[P.ElasticEase=4]="ElasticEase",P[P.ExponentialEase=5]="ExponentialEase",P[P.PowerEase=6]="PowerEase",P[P.QuadraticEase=7]="QuadraticEase",P[P.QuarticEase=8]="QuarticEase",P[P.QuinticEase=9]="QuinticEase",P[P.SineEase=10]="SineEase",P[P.BezierCurveEase=11]="BezierCurveEase"}(H||(H={}));class t extends p.c{constructor(P){super(P),this.config=P,this._easingFunctions={},this.type=this.registerDataInput("type",k.b,11),this.mode=this.registerDataInput("mode",k.r,0),this.parameters=this.registerDataInput("parameters",k.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",k.b)}_updateOutputs(P){const e=this.type.getValue(P),n=this.mode.getValue(P),H=this.parameters.getValue(P);if(void 0===e||void 0===n)return;const p=`${e}-${n}-${H.join("-")}`;if(!this._easingFunctions[p]){const P=function(P){for(var e=arguments.length,n=new Array(e>1?e-1:0),H=1;H<e;H++)n[H-1]=arguments[H];switch(P){case 11:return new S.c(...n);case 0:return new S.j;case 1:return new S.b(...n);case 2:return new S.g(...n);case 3:return new S.m;case 4:return new S.p(...n);case 5:return new S.r(...n);default:throw new Error("Easing type not yet implemented")}}(e,...H);P.setEasingMode(n),this._easingFunctions[p]=P}this.easingFunction.setValue(this._easingFunctions[p],P)}getClassName(){return"FlowGraphEasingBlock"}}(0,m.h)("FlowGraphEasingBlock",t)}}]);