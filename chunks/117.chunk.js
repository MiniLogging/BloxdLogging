"use strict";(self.n4ygn1cq9vg=self.n4ygn1cq9vg||[]).push([[117],{15834:(e,d,v)=>{v.r(d),v.d(d,{EasingFunctionType:()=>P,FlowGraphEasingBlock:()=>z});var P,p=v(14606),L=v(14195),B=v(14181),X=v(12381);!function(e){e[e.CircleEase=0]="CircleEase",e[e.BackEase=1]="BackEase",e[e.BounceEase=2]="BounceEase",e[e.CubicEase=3]="CubicEase",e[e.ElasticEase=4]="ElasticEase",e[e.ExponentialEase=5]="ExponentialEase",e[e.PowerEase=6]="PowerEase",e[e.QuadraticEase=7]="QuadraticEase",e[e.QuarticEase=8]="QuarticEase",e[e.QuinticEase=9]="QuinticEase",e[e.SineEase=10]="SineEase",e[e.BezierCurveEase=11]="BezierCurveEase"}(P||(P={}));class z extends L.e{constructor(e){super(e),this.config=e,this._easingFunctions={},this.type=this.registerDataInput("type",B.b,11),this.mode=this.registerDataInput("mode",B.n,0),this.parameters=this.registerDataInput("parameters",B.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",B.b)}_updateOutputs(e){const d=this.type.getValue(e),v=this.mode.getValue(e),P=this.parameters.getValue(e);if(void 0===d||void 0===v)return;const L=`${d}-${v}-${P.join("-")}`;if(!this._easingFunctions[L]){const e=function(e){for(var d=arguments.length,v=new Array(d>1?d-1:0),P=1;P<d;P++)v[P-1]=arguments[P];switch(e){case 11:return new p.i(...v);case 0:return new p.p;case 1:return new p.e(...v);case 2:return new p.l(...v);case 3:return new p.q;case 4:return new p.x(...v);case 5:return new p.y(...v);default:throw new Error("Easing type not yet implemented")}}(d,...P);e.setEasingMode(v),this._easingFunctions[L]=e}this.easingFunction.setValue(this._easingFunctions[L],e)}getClassName(){return"FlowGraphEasingBlock"}}(0,X.h)("FlowGraphEasingBlock",z)}}]);