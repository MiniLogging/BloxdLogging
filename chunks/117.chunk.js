"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[117],{14471:(g,w,q)=>{q.r(w),q.d(w,{EasingFunctionType:()=>R,FlowGraphEasingBlock:()=>T});var R,o=q(13271),r=q(12863),S=q(12836),i=q(11128);!function(g){g[g.CircleEase=0]="CircleEase",g[g.BackEase=1]="BackEase",g[g.BounceEase=2]="BounceEase",g[g.CubicEase=3]="CubicEase",g[g.ElasticEase=4]="ElasticEase",g[g.ExponentialEase=5]="ExponentialEase",g[g.PowerEase=6]="PowerEase",g[g.QuadraticEase=7]="QuadraticEase",g[g.QuarticEase=8]="QuarticEase",g[g.QuinticEase=9]="QuinticEase",g[g.SineEase=10]="SineEase",g[g.BezierCurveEase=11]="BezierCurveEase"}(R||(R={}));class T extends r.e{constructor(g){super(g),this.config=g,this._easingFunctions={},this.type=this.registerDataInput("type",S.d,11),this.mode=this.registerDataInput("mode",S.w,0),this.parameters=this.registerDataInput("parameters",S.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",S.d)}_updateOutputs(g){const w=this.type.getValue(g),q=this.mode.getValue(g),R=this.parameters.getValue(g);if(void 0===w||void 0===q)return;const r=`${w}-${q}-${R.join("-")}`;if(!this._easingFunctions[r]){const g=function(g){for(var w=arguments.length,q=new Array(w>1?w-1:0),R=1;R<w;R++)q[R-1]=arguments[R];switch(g){case 11:return new o.f(...q);case 0:return new o.k;case 1:return new o.b(...q);case 2:return new o.j(...q);case 3:return new o.n;case 4:return new o.s(...q);case 5:return new o.t(...q);default:throw new Error("Easing type not yet implemented")}}(w,...R);g.setEasingMode(q),this._easingFunctions[r]=g}this.easingFunction.setValue(this._easingFunctions[r],g)}getClassName(){return"FlowGraphEasingBlock"}}(0,i.g)("FlowGraphEasingBlock",T)}}]);