"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[117],{16291:(Y,b,C)=>{C.r(b),C.d(b,{EasingFunctionType:()=>R,FlowGraphEasingBlock:()=>g});var R,q=C(15050),A=C(14437),E=C(14424),B=C(12790);!function(Y){Y[Y.CircleEase=0]="CircleEase",Y[Y.BackEase=1]="BackEase",Y[Y.BounceEase=2]="BounceEase",Y[Y.CubicEase=3]="CubicEase",Y[Y.ElasticEase=4]="ElasticEase",Y[Y.ExponentialEase=5]="ExponentialEase",Y[Y.PowerEase=6]="PowerEase",Y[Y.QuadraticEase=7]="QuadraticEase",Y[Y.QuarticEase=8]="QuarticEase",Y[Y.QuinticEase=9]="QuinticEase",Y[Y.SineEase=10]="SineEase",Y[Y.BezierCurveEase=11]="BezierCurveEase"}(R||(R={}));class g extends A.e{constructor(Y){super(Y),this.config=Y,this._easingFunctions={},this.type=this.registerDataInput("type",E.b,11),this.mode=this.registerDataInput("mode",E.q,0),this.parameters=this.registerDataInput("parameters",E.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",E.b)}_updateOutputs(Y){const b=this.type.getValue(Y),C=this.mode.getValue(Y),R=this.parameters.getValue(Y);if(void 0===b||void 0===C)return;const A=`${b}-${C}-${R.join("-")}`;if(!this._easingFunctions[A]){const Y=function(Y){for(var b=arguments.length,C=new Array(b>1?b-1:0),R=1;R<b;R++)C[R-1]=arguments[R];switch(Y){case 11:return new q.e(...C);case 0:return new q.h;case 1:return new q.b(...C);case 2:return new q.g(...C);case 3:return new q.i;case 4:return new q.o(...C);case 5:return new q.q(...C);default:throw new Error("Easing type not yet implemented")}}(b,...R);Y.setEasingMode(C),this._easingFunctions[A]=Y}this.easingFunction.setValue(this._easingFunctions[A],Y)}getClassName(){return"FlowGraphEasingBlock"}}(0,B.g)("FlowGraphEasingBlock",g)}}]);