"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[117],{14968:(U,X,b)=>{b.r(X),b.d(X,{EasingFunctionType:()=>F,FlowGraphEasingBlock:()=>q});var F,E=b(13777),w=b(13308),Q=b(13281),z=b(11551);!function(U){U[U.CircleEase=0]="CircleEase",U[U.BackEase=1]="BackEase",U[U.BounceEase=2]="BounceEase",U[U.CubicEase=3]="CubicEase",U[U.ElasticEase=4]="ElasticEase",U[U.ExponentialEase=5]="ExponentialEase",U[U.PowerEase=6]="PowerEase",U[U.QuadraticEase=7]="QuadraticEase",U[U.QuarticEase=8]="QuarticEase",U[U.QuinticEase=9]="QuinticEase",U[U.SineEase=10]="SineEase",U[U.BezierCurveEase=11]="BezierCurveEase"}(F||(F={}));class q extends w.d{constructor(U){super(U),this.config=U,this._easingFunctions={},this.type=this.registerDataInput("type",Q.b,11),this.mode=this.registerDataInput("mode",Q.s,0),this.parameters=this.registerDataInput("parameters",Q.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",Q.b)}_updateOutputs(U){const X=this.type.getValue(U),b=this.mode.getValue(U),F=this.parameters.getValue(U);if(void 0===X||void 0===b)return;const w=`${X}-${b}-${F.join("-")}`;if(!this._easingFunctions[w]){const U=function(U){for(var X=arguments.length,b=new Array(X>1?X-1:0),F=1;F<X;F++)b[F-1]=arguments[F];switch(U){case 11:return new E.h(...b);case 0:return new E.m;case 1:return new E.e(...b);case 2:return new E.j(...b);case 3:return new E.p;case 4:return new E.u(...b);case 5:return new E.w(...b);default:throw new Error("Easing type not yet implemented")}}(X,...F);U.setEasingMode(b),this._easingFunctions[w]=U}this.easingFunction.setValue(this._easingFunctions[w],U)}getClassName(){return"FlowGraphEasingBlock"}}(0,z.f)("FlowGraphEasingBlock",q)}}]);