"use strict";(self.ozi0exxand9=self.ozi0exxand9||[]).push([[117],{14709:(f,v,Z)=>{Z.r(v),Z.d(v,{EasingFunctionType:()=>V,FlowGraphEasingBlock:()=>C});var V,h=Z(13550),J=Z(13149),l=Z(13123),e=Z(11372);!function(f){f[f.CircleEase=0]="CircleEase",f[f.BackEase=1]="BackEase",f[f.BounceEase=2]="BounceEase",f[f.CubicEase=3]="CubicEase",f[f.ElasticEase=4]="ElasticEase",f[f.ExponentialEase=5]="ExponentialEase",f[f.PowerEase=6]="PowerEase",f[f.QuadraticEase=7]="QuadraticEase",f[f.QuarticEase=8]="QuarticEase",f[f.QuinticEase=9]="QuinticEase",f[f.SineEase=10]="SineEase",f[f.BezierCurveEase=11]="BezierCurveEase"}(V||(V={}));class C extends J.c{constructor(f){super(f),this.config=f,this._easingFunctions={},this.type=this.registerDataInput("type",l.d,11),this.mode=this.registerDataInput("mode",l.v,0),this.parameters=this.registerDataInput("parameters",l.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",l.d)}_updateOutputs(f){const v=this.type.getValue(f),Z=this.mode.getValue(f),V=this.parameters.getValue(f);if(void 0===v||void 0===Z)return;const J=`${v}-${Z}-${V.join("-")}`;if(!this._easingFunctions[J]){const f=function(f){for(var v=arguments.length,Z=new Array(v>1?v-1:0),V=1;V<v;V++)Z[V-1]=arguments[V];switch(f){case 11:return new h.e(...Z);case 0:return new h.k;case 1:return new h.c(...Z);case 2:return new h.g(...Z);case 3:return new h.m;case 4:return new h.r(...Z);case 5:return new h.s(...Z);default:throw new Error("Easing type not yet implemented")}}(v,...V);f.setEasingMode(Z),this._easingFunctions[J]=f}this.easingFunction.setValue(this._easingFunctions[J],f)}getClassName(){return"FlowGraphEasingBlock"}}(0,e.h)("FlowGraphEasingBlock",C)}}]);