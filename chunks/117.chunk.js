"use strict";(self.h6ljd275xwr=self.h6ljd275xwr||[]).push([[117],{14750:(n,y,H)=>{H.r(y),H.d(y,{EasingFunctionType:()=>o,FlowGraphEasingBlock:()=>B});var o,G=H(13569),h=H(13146),k=H(13117),i=H(11248);!function(n){n[n.CircleEase=0]="CircleEase",n[n.BackEase=1]="BackEase",n[n.BounceEase=2]="BounceEase",n[n.CubicEase=3]="CubicEase",n[n.ElasticEase=4]="ElasticEase",n[n.ExponentialEase=5]="ExponentialEase",n[n.PowerEase=6]="PowerEase",n[n.QuadraticEase=7]="QuadraticEase",n[n.QuarticEase=8]="QuarticEase",n[n.QuinticEase=9]="QuinticEase",n[n.SineEase=10]="SineEase",n[n.BezierCurveEase=11]="BezierCurveEase"}(o||(o={}));class B extends h.c{constructor(n){super(n),this.config=n,this._easingFunctions={},this.type=this.registerDataInput("type",k.c,11),this.mode=this.registerDataInput("mode",k.p,0),this.parameters=this.registerDataInput("parameters",k.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",k.c)}_updateOutputs(n){const y=this.type.getValue(n),H=this.mode.getValue(n),o=this.parameters.getValue(n);if(void 0===y||void 0===H)return;const h=`${y}-${H}-${o.join("-")}`;if(!this._easingFunctions[h]){const n=function(n){for(var y=arguments.length,H=new Array(y>1?y-1:0),o=1;o<y;o++)H[o-1]=arguments[o];switch(n){case 11:return new G.d(...H);case 0:return new G.i;case 1:return new G.c(...H);case 2:return new G.e(...H);case 3:return new G.k;case 4:return new G.p(...H);case 5:return new G.t(...H);default:throw new Error("Easing type not yet implemented")}}(y,...o);n.setEasingMode(H),this._easingFunctions[h]=n}this.easingFunction.setValue(this._easingFunctions[h],n)}getClassName(){return"FlowGraphEasingBlock"}}(0,i.h)("FlowGraphEasingBlock",B)}}]);