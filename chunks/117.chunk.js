"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[117],{14573:(B,I,C)=>{C.r(I),C.d(I,{EasingFunctionType:()=>M,FlowGraphEasingBlock:()=>e});var M,x=C(13350),y=C(12927),f=C(12901),L=C(11149);!function(B){B[B.CircleEase=0]="CircleEase",B[B.BackEase=1]="BackEase",B[B.BounceEase=2]="BounceEase",B[B.CubicEase=3]="CubicEase",B[B.ElasticEase=4]="ElasticEase",B[B.ExponentialEase=5]="ExponentialEase",B[B.PowerEase=6]="PowerEase",B[B.QuadraticEase=7]="QuadraticEase",B[B.QuarticEase=8]="QuarticEase",B[B.QuinticEase=9]="QuinticEase",B[B.SineEase=10]="SineEase",B[B.BezierCurveEase=11]="BezierCurveEase"}(M||(M={}));class e extends y.e{constructor(B){super(B),this.config=B,this._easingFunctions={},this.type=this.registerDataInput("type",f.b,11),this.mode=this.registerDataInput("mode",f.m,0),this.parameters=this.registerDataInput("parameters",f.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",f.b)}_updateOutputs(B){const I=this.type.getValue(B),C=this.mode.getValue(B),M=this.parameters.getValue(B);if(void 0===I||void 0===C)return;const y=`${I}-${C}-${M.join("-")}`;if(!this._easingFunctions[y]){const B=function(B){for(var I=arguments.length,C=new Array(I>1?I-1:0),M=1;M<I;M++)C[M-1]=arguments[M];switch(B){case 11:return new x.g(...C);case 0:return new x.m;case 1:return new x.d(...C);case 2:return new x.k(...C);case 3:return new x.q;case 4:return new x.u(...C);case 5:return new x.v(...C);default:throw new Error("Easing type not yet implemented")}}(I,...M);B.setEasingMode(C),this._easingFunctions[y]=B}this.easingFunction.setValue(this._easingFunctions[y],B)}getClassName(){return"FlowGraphEasingBlock"}}(0,L.h)("FlowGraphEasingBlock",e)}}]);