"use strict";(self.rsqbdnwe5e=self.rsqbdnwe5e||[]).push([[117],{15700:(N,p,T)=>{T.r(p),T.d(p,{EasingFunctionType:()=>A,FlowGraphEasingBlock:()=>y});var A,a=T(14505),C=T(14108),U=T(14082),X=T(12331);!function(N){N[N.CircleEase=0]="CircleEase",N[N.BackEase=1]="BackEase",N[N.BounceEase=2]="BounceEase",N[N.CubicEase=3]="CubicEase",N[N.ElasticEase=4]="ElasticEase",N[N.ExponentialEase=5]="ExponentialEase",N[N.PowerEase=6]="PowerEase",N[N.QuadraticEase=7]="QuadraticEase",N[N.QuarticEase=8]="QuarticEase",N[N.QuinticEase=9]="QuinticEase",N[N.SineEase=10]="SineEase",N[N.BezierCurveEase=11]="BezierCurveEase"}(A||(A={}));class y extends C.c{constructor(N){super(N),this.config=N,this._easingFunctions={},this.type=this.registerDataInput("type",U.d,11),this.mode=this.registerDataInput("mode",U.r,0),this.parameters=this.registerDataInput("parameters",U.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",U.d)}_updateOutputs(N){const p=this.type.getValue(N),T=this.mode.getValue(N),A=this.parameters.getValue(N);if(void 0===p||void 0===T)return;const C=`${p}-${T}-${A.join("-")}`;if(!this._easingFunctions[C]){const N=function(N){for(var p=arguments.length,T=new Array(p>1?p-1:0),A=1;A<p;A++)T[A-1]=arguments[A];switch(N){case 11:return new a.h(...T);case 0:return new a.k;case 1:return new a.e(...T);case 2:return new a.i(...T);case 3:return new a.m;case 4:return new a.q(...T);case 5:return new a.r(...T);default:throw new Error("Easing type not yet implemented")}}(p,...A);N.setEasingMode(T),this._easingFunctions[C]=N}this.easingFunction.setValue(this._easingFunctions[C],N)}getClassName(){return"FlowGraphEasingBlock"}}(0,X.d)("FlowGraphEasingBlock",y)}}]);