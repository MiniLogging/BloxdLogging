"use strict";(self.ipz2em9uj1g=self.ipz2em9uj1g||[]).push([[117],{16029:(r,O,W)=>{W.r(O),W.d(O,{EasingFunctionType:()=>q,FlowGraphEasingBlock:()=>J});var q,Q=W(14772),C=W(14297),T=W(14274),h=W(12560);!function(r){r[r.CircleEase=0]="CircleEase",r[r.BackEase=1]="BackEase",r[r.BounceEase=2]="BounceEase",r[r.CubicEase=3]="CubicEase",r[r.ElasticEase=4]="ElasticEase",r[r.ExponentialEase=5]="ExponentialEase",r[r.PowerEase=6]="PowerEase",r[r.QuadraticEase=7]="QuadraticEase",r[r.QuarticEase=8]="QuarticEase",r[r.QuinticEase=9]="QuinticEase",r[r.SineEase=10]="SineEase",r[r.BezierCurveEase=11]="BezierCurveEase"}(q||(q={}));class J extends C.d{constructor(r){super(r),this.config=r,this._easingFunctions={},this.type=this.registerDataInput("type",T.c,11),this.mode=this.registerDataInput("mode",T.r,0),this.parameters=this.registerDataInput("parameters",T.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",T.c)}_updateOutputs(r){const O=this.type.getValue(r),W=this.mode.getValue(r),q=this.parameters.getValue(r);if(void 0===O||void 0===W)return;const C=`${O}-${W}-${q.join("-")}`;if(!this._easingFunctions[C]){const r=function(r){for(var O=arguments.length,W=new Array(O>1?O-1:0),q=1;q<O;q++)W[q-1]=arguments[q];switch(r){case 11:return new Q.h(...W);case 0:return new Q.j;case 1:return new Q.e(...W);case 2:return new Q.i(...W);case 3:return new Q.k;case 4:return new Q.o(...W);case 5:return new Q.p(...W);default:throw new Error("Easing type not yet implemented")}}(O,...q);r.setEasingMode(W),this._easingFunctions[C]=r}this.easingFunction.setValue(this._easingFunctions[C],r)}getClassName(){return"FlowGraphEasingBlock"}}(0,h.e)("FlowGraphEasingBlock",J)}}]);