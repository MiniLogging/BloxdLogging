"use strict";(self.uw9p3pwwsje=self.uw9p3pwwsje||[]).push([[117],{16057:(D,h,o)=>{o.r(h),o.d(h,{EasingFunctionType:()=>H,FlowGraphEasingBlock:()=>t});var H,g=o(14876),j=o(14386),M=o(14362),R=o(12793);!function(D){D[D.CircleEase=0]="CircleEase",D[D.BackEase=1]="BackEase",D[D.BounceEase=2]="BounceEase",D[D.CubicEase=3]="CubicEase",D[D.ElasticEase=4]="ElasticEase",D[D.ExponentialEase=5]="ExponentialEase",D[D.PowerEase=6]="PowerEase",D[D.QuadraticEase=7]="QuadraticEase",D[D.QuarticEase=8]="QuarticEase",D[D.QuinticEase=9]="QuinticEase",D[D.SineEase=10]="SineEase",D[D.BezierCurveEase=11]="BezierCurveEase"}(H||(H={}));class t extends j.e{constructor(D){super(D),this.config=D,this._easingFunctions={},this.type=this.registerDataInput("type",M.c,11),this.mode=this.registerDataInput("mode",M.q,0),this.parameters=this.registerDataInput("parameters",M.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",M.c)}_updateOutputs(D){const h=this.type.getValue(D),o=this.mode.getValue(D),H=this.parameters.getValue(D);if(void 0===h||void 0===o)return;const j=`${h}-${o}-${H.join("-")}`;if(!this._easingFunctions[j]){const D=function(D){for(var h=arguments.length,o=new Array(h>1?h-1:0),H=1;H<h;H++)o[H-1]=arguments[H];switch(D){case 11:return new g.e(...o);case 0:return new g.l;case 1:return new g.d(...o);case 2:return new g.h(...o);case 3:return new g.m;case 4:return new g.r(...o);case 5:return new g.v(...o);default:throw new Error("Easing type not yet implemented")}}(h,...H);D.setEasingMode(o),this._easingFunctions[j]=D}this.easingFunction.setValue(this._easingFunctions[j],D)}getClassName(){return"FlowGraphEasingBlock"}}(0,R.g)("FlowGraphEasingBlock",t)}}]);