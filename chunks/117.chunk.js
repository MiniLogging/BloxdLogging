"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[117],{16217:(I,x,L)=>{L.r(x),L.d(x,{EasingFunctionType:()=>F,FlowGraphEasingBlock:()=>B});var F,X=L(15056),G=L(14514),Y=L(14498),p=L(12938);!function(I){I[I.CircleEase=0]="CircleEase",I[I.BackEase=1]="BackEase",I[I.BounceEase=2]="BounceEase",I[I.CubicEase=3]="CubicEase",I[I.ElasticEase=4]="ElasticEase",I[I.ExponentialEase=5]="ExponentialEase",I[I.PowerEase=6]="PowerEase",I[I.QuadraticEase=7]="QuadraticEase",I[I.QuarticEase=8]="QuarticEase",I[I.QuinticEase=9]="QuinticEase",I[I.SineEase=10]="SineEase",I[I.BezierCurveEase=11]="BezierCurveEase"}(F||(F={}));class B extends G.e{constructor(I){super(I),this.config=I,this._easingFunctions={},this.type=this.registerDataInput("type",Y.e,11),this.mode=this.registerDataInput("mode",Y.x,0),this.parameters=this.registerDataInput("parameters",Y.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",Y.e)}_updateOutputs(I){const x=this.type.getValue(I),L=this.mode.getValue(I),F=this.parameters.getValue(I);if(void 0===x||void 0===L)return;const G=`${x}-${L}-${F.join("-")}`;if(!this._easingFunctions[G]){const I=function(I){for(var x=arguments.length,L=new Array(x>1?x-1:0),F=1;F<x;F++)L[F-1]=arguments[F];switch(I){case 11:return new X.f(...L);case 0:return new X.k;case 1:return new X.e(...L);case 2:return new X.g(...L);case 3:return new X.l;case 4:return new X.p(...L);case 5:return new X.s(...L);default:throw new Error("Easing type not yet implemented")}}(x,...F);I.setEasingMode(L),this._easingFunctions[G]=I}this.easingFunction.setValue(this._easingFunctions[G],I)}getClassName(){return"FlowGraphEasingBlock"}}(0,p.d)("FlowGraphEasingBlock",B)}}]);