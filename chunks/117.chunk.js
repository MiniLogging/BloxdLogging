"use strict";(self.fkqm0epoq5=self.fkqm0epoq5||[]).push([[117],{15008:(D,l,G)=>{G.r(l),G.d(l,{EasingFunctionType:()=>V,FlowGraphEasingBlock:()=>t});var V,N=G(13845),M=G(13442),b=G(13423),X=G(11667);!function(D){D[D.CircleEase=0]="CircleEase",D[D.BackEase=1]="BackEase",D[D.BounceEase=2]="BounceEase",D[D.CubicEase=3]="CubicEase",D[D.ElasticEase=4]="ElasticEase",D[D.ExponentialEase=5]="ExponentialEase",D[D.PowerEase=6]="PowerEase",D[D.QuadraticEase=7]="QuadraticEase",D[D.QuarticEase=8]="QuarticEase",D[D.QuinticEase=9]="QuinticEase",D[D.SineEase=10]="SineEase",D[D.BezierCurveEase=11]="BezierCurveEase"}(V||(V={}));class t extends M.c{constructor(D){super(D),this.config=D,this._easingFunctions={},this.type=this.registerDataInput("type",b.d,11),this.mode=this.registerDataInput("mode",b.o,0),this.parameters=this.registerDataInput("parameters",b.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",b.d)}_updateOutputs(D){const l=this.type.getValue(D),G=this.mode.getValue(D),V=this.parameters.getValue(D);if(void 0===l||void 0===G)return;const M=`${l}-${G}-${V.join("-")}`;if(!this._easingFunctions[M]){const D=function(D){for(var l=arguments.length,G=new Array(l>1?l-1:0),V=1;V<l;V++)G[V-1]=arguments[V];switch(D){case 11:return new N.h(...G);case 0:return new N.k;case 1:return new N.e(...G);case 2:return new N.i(...G);case 3:return new N.o;case 4:return new N.v(...G);case 5:return new N.x(...G);default:throw new Error("Easing type not yet implemented")}}(l,...V);D.setEasingMode(G),this._easingFunctions[M]=D}this.easingFunction.setValue(this._easingFunctions[M],D)}getClassName(){return"FlowGraphEasingBlock"}}(0,X.c)("FlowGraphEasingBlock",t)}}]);