"use strict";(self.c2c3ycupenc=self.c2c3ycupenc||[]).push([[117],{15098:(c,r,D)=>{D.r(r),D.d(r,{EasingFunctionType:()=>W,FlowGraphEasingBlock:()=>H});var W,B=D(13862),t=D(13408),u=D(13392),a=D(11637);!function(c){c[c.CircleEase=0]="CircleEase",c[c.BackEase=1]="BackEase",c[c.BounceEase=2]="BounceEase",c[c.CubicEase=3]="CubicEase",c[c.ElasticEase=4]="ElasticEase",c[c.ExponentialEase=5]="ExponentialEase",c[c.PowerEase=6]="PowerEase",c[c.QuadraticEase=7]="QuadraticEase",c[c.QuarticEase=8]="QuarticEase",c[c.QuinticEase=9]="QuinticEase",c[c.SineEase=10]="SineEase",c[c.BezierCurveEase=11]="BezierCurveEase"}(W||(W={}));class H extends t.d{constructor(c){super(c),this.config=c,this._easingFunctions={},this.type=this.registerDataInput("type",u.c,11),this.mode=this.registerDataInput("mode",u.u,0),this.parameters=this.registerDataInput("parameters",u.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",u.c)}_updateOutputs(c){const r=this.type.getValue(c),D=this.mode.getValue(c),W=this.parameters.getValue(c);if(void 0===r||void 0===D)return;const t=`${r}-${D}-${W.join("-")}`;if(!this._easingFunctions[t]){const c=function(c){for(var r=arguments.length,D=new Array(r>1?r-1:0),W=1;W<r;W++)D[W-1]=arguments[W];switch(c){case 11:return new B.g(...D);case 0:return new B.j;case 1:return new B.d(...D);case 2:return new B.i(...D);case 3:return new B.n;case 4:return new B.p(...D);case 5:return new B.t(...D);default:throw new Error("Easing type not yet implemented")}}(r,...W);c.setEasingMode(D),this._easingFunctions[t]=c}this.easingFunction.setValue(this._easingFunctions[t],c)}getClassName(){return"FlowGraphEasingBlock"}}(0,a.e)("FlowGraphEasingBlock",H)}}]);