"use strict";(self.bjbkv7h3qsd=self.bjbkv7h3qsd||[]).push([[117],{14629:(G,A,j)=>{j.r(A),j.d(A,{EasingFunctionType:()=>u,FlowGraphEasingBlock:()=>O});var u,k=j(13336),B=j(12905),x=j(12880),s=j(11181);!function(G){G[G.CircleEase=0]="CircleEase",G[G.BackEase=1]="BackEase",G[G.BounceEase=2]="BounceEase",G[G.CubicEase=3]="CubicEase",G[G.ElasticEase=4]="ElasticEase",G[G.ExponentialEase=5]="ExponentialEase",G[G.PowerEase=6]="PowerEase",G[G.QuadraticEase=7]="QuadraticEase",G[G.QuarticEase=8]="QuarticEase",G[G.QuinticEase=9]="QuinticEase",G[G.SineEase=10]="SineEase",G[G.BezierCurveEase=11]="BezierCurveEase"}(u||(u={}));class O extends B.c{constructor(G){super(G),this.config=G,this._easingFunctions={},this.type=this.registerDataInput("type",x.c,11),this.mode=this.registerDataInput("mode",x.s,0),this.parameters=this.registerDataInput("parameters",x.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",x.c)}_updateOutputs(G){const A=this.type.getValue(G),j=this.mode.getValue(G),u=this.parameters.getValue(G);if(void 0===A||void 0===j)return;const B=`${A}-${j}-${u.join("-")}`;if(!this._easingFunctions[B]){const G=function(G){for(var A=arguments.length,j=new Array(A>1?A-1:0),u=1;u<A;u++)j[u-1]=arguments[u];switch(G){case 11:return new k.e(...j);case 0:return new k.i;case 1:return new k.d(...j);case 2:return new k.h(...j);case 3:return new k.m;case 4:return new k.r(...j);case 5:return new k.t(...j);default:throw new Error("Easing type not yet implemented")}}(A,...u);G.setEasingMode(j),this._easingFunctions[B]=G}this.easingFunction.setValue(this._easingFunctions[B],G)}getClassName(){return"FlowGraphEasingBlock"}}(0,s.h)("FlowGraphEasingBlock",O)}}]);