"use strict";(self["80dd64vgxnn"]=self["80dd64vgxnn"]||[]).push([[117],{15969:(mm,o,u)=>{u.r(o),u.d(o,{EasingFunctionType:()=>f,FlowGraphEasingBlock:()=>p});var f,B=u(14785),O=u(14280),r=u(14257),w=u(12702);!function(mm){mm[mm.CircleEase=0]="CircleEase",mm[mm.BackEase=1]="BackEase",mm[mm.BounceEase=2]="BounceEase",mm[mm.CubicEase=3]="CubicEase",mm[mm.ElasticEase=4]="ElasticEase",mm[mm.ExponentialEase=5]="ExponentialEase",mm[mm.PowerEase=6]="PowerEase",mm[mm.QuadraticEase=7]="QuadraticEase",mm[mm.QuarticEase=8]="QuarticEase",mm[mm.QuinticEase=9]="QuinticEase",mm[mm.SineEase=10]="SineEase",mm[mm.BezierCurveEase=11]="BezierCurveEase"}(f||(f={}));class p extends O.e{constructor(mm){super(mm),this.config=mm,this._easingFunctions={},this.type=this.registerDataInput("type",r.b,11),this.mode=this.registerDataInput("mode",r.r,0),this.parameters=this.registerDataInput("parameters",r.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",r.b)}_updateOutputs(mm){const o=this.type.getValue(mm),u=this.mode.getValue(mm),f=this.parameters.getValue(mm);if(void 0===o||void 0===u)return;const O=`${o}-${u}-${f.join("-")}`;if(!this._easingFunctions[O]){const mm=function(mm){for(var o=arguments.length,u=new Array(o>1?o-1:0),f=1;f<o;f++)u[f-1]=arguments[f];switch(mm){case 11:return new B.g(...u);case 0:return new B.m;case 1:return new B.d(...u);case 2:return new B.k(...u);case 3:return new B.p;case 4:return new B.t(...u);case 5:return new B.w(...u);default:throw new Error("Easing type not yet implemented")}}(o,...f);mm.setEasingMode(u),this._easingFunctions[O]=mm}this.easingFunction.setValue(this._easingFunctions[O],mm)}getClassName(){return"FlowGraphEasingBlock"}}(0,w.c)("FlowGraphEasingBlock",p)}}]);