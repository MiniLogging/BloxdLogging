"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[117],{15532:(I,O,C)=>{C.r(O),C.d(O,{EasingFunctionType:()=>j,FlowGraphEasingBlock:()=>U});var j,K=C(14348),i=C(13906),y=C(13886),S=C(12226);!function(I){I[I.CircleEase=0]="CircleEase",I[I.BackEase=1]="BackEase",I[I.BounceEase=2]="BounceEase",I[I.CubicEase=3]="CubicEase",I[I.ElasticEase=4]="ElasticEase",I[I.ExponentialEase=5]="ExponentialEase",I[I.PowerEase=6]="PowerEase",I[I.QuadraticEase=7]="QuadraticEase",I[I.QuarticEase=8]="QuarticEase",I[I.QuinticEase=9]="QuinticEase",I[I.SineEase=10]="SineEase",I[I.BezierCurveEase=11]="BezierCurveEase"}(j||(j={}));class U extends i.d{constructor(I){super(I),this.config=I,this._easingFunctions={},this.type=this.registerDataInput("type",y.d,11),this.mode=this.registerDataInput("mode",y.u,0),this.parameters=this.registerDataInput("parameters",y.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",y.d)}_updateOutputs(I){const O=this.type.getValue(I),C=this.mode.getValue(I),j=this.parameters.getValue(I);if(void 0===O||void 0===C)return;const i=`${O}-${C}-${j.join("-")}`;if(!this._easingFunctions[i]){const I=function(I){for(var O=arguments.length,C=new Array(O>1?O-1:0),j=1;j<O;j++)C[j-1]=arguments[j];switch(I){case 11:return new K.d(...C);case 0:return new K.f;case 1:return new K.b(...C);case 2:return new K.e(...C);case 3:return new K.g;case 4:return new K.l(...C);case 5:return new K.n(...C);default:throw new Error("Easing type not yet implemented")}}(O,...j);I.setEasingMode(C),this._easingFunctions[i]=I}this.easingFunction.setValue(this._easingFunctions[i],I)}getClassName(){return"FlowGraphEasingBlock"}}(0,S.e)("FlowGraphEasingBlock",U)}}]);