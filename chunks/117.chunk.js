"use strict";(self["5dou0t7wntc"]=self["5dou0t7wntc"]||[]).push([[117],{15135:(K,O,F)=>{F.r(O),F.d(O,{EasingFunctionType:()=>f,FlowGraphEasingBlock:()=>c});var f,r=F(13880),l=F(13471),q=F(13441),J=F(11661);!function(K){K[K.CircleEase=0]="CircleEase",K[K.BackEase=1]="BackEase",K[K.BounceEase=2]="BounceEase",K[K.CubicEase=3]="CubicEase",K[K.ElasticEase=4]="ElasticEase",K[K.ExponentialEase=5]="ExponentialEase",K[K.PowerEase=6]="PowerEase",K[K.QuadraticEase=7]="QuadraticEase",K[K.QuarticEase=8]="QuarticEase",K[K.QuinticEase=9]="QuinticEase",K[K.SineEase=10]="SineEase",K[K.BezierCurveEase=11]="BezierCurveEase"}(f||(f={}));class c extends l.e{constructor(K){super(K),this.config=K,this._easingFunctions={},this.type=this.registerDataInput("type",q.d,11),this.mode=this.registerDataInput("mode",q.s,0),this.parameters=this.registerDataInput("parameters",q.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",q.d)}_updateOutputs(K){const O=this.type.getValue(K),F=this.mode.getValue(K),f=this.parameters.getValue(K);if(void 0===O||void 0===F)return;const l=`${O}-${F}-${f.join("-")}`;if(!this._easingFunctions[l]){const K=function(K){for(var O=arguments.length,F=new Array(O>1?O-1:0),f=1;f<O;f++)F[f-1]=arguments[f];switch(K){case 11:return new r.e(...F);case 0:return new r.m;case 1:return new r.d(...F);case 2:return new r.i(...F);case 3:return new r.q;case 4:return new r.t(...F);case 5:return new r.w(...F);default:throw new Error("Easing type not yet implemented")}}(O,...f);K.setEasingMode(F),this._easingFunctions[l]=K}this.easingFunction.setValue(this._easingFunctions[l],K)}getClassName(){return"FlowGraphEasingBlock"}}(0,J.g)("FlowGraphEasingBlock",c)}}]);