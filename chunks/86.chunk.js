"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[86],{15852:(L,U,x)=>{x.r(U),x.d(U,{FlowGraphReceiveCustomEventBlock:()=>a});var mL=x(14388),p=x(12382),G=x(12547),F=x(14336);class a extends mL.e{constructor(L){super(L),this.config=L,this.initPriority=1;for(const U in this.config.eventData)this.registerDataOutput(U,this.config.eventData[U].type)}_preparePendingTasks(L){const U=L.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(U&&U.hasObservers()&&U.observers.length>F.b.MaxEventsPerType)return void this._reportError(L,`FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${F.b.MaxEventsPerType}.`);const x=U.add((U=>{const x=Object.keys(U);for(const p of x){var mL;null===(mL=this.getDataOutput(p))||void 0===mL||mL.setValue(U[p],L)}this._execute(L)}));L._setExecutionVariable(this,"_eventObserver",x)}_cancelPendingTasks(L){const U=L.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(U){const x=L._getExecutionVariable(this,"_eventObserver",null);U.remove(x)}else p.Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`)}_executeEvent(L,U){return!0}getClassName(){return"FlowGraphReceiveCustomEventBlock"}}(0,G.d)("FlowGraphReceiveCustomEventBlock",a)}}]);