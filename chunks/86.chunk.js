"use strict";(self["2fwzcez286e"]=self["2fwzcez286e"]||[]).push([[86],{16218:(B,u,F)=>{F.r(u),F.d(u,{FlowGraphReceiveCustomEventBlock:()=>R});var Z=F(14734),V=F(12802),p=F(12949),G=F(14683);class R extends Z.b{constructor(B){super(B),this.config=B,this.initPriority=1;for(const u in this.config.eventData)this.registerDataOutput(u,this.config.eventData[u].type)}_preparePendingTasks(B){const u=B.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(u&&u.hasObservers()&&u.observers.length>G.e.MaxEventsPerType)return void this._reportError(B,`FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${G.e.MaxEventsPerType}.`);const F=u.add((u=>{const F=Object.keys(u);for(const V of F){var Z;null===(Z=this.getDataOutput(V))||void 0===Z||Z.setValue(u[V],B)}this._execute(B)}));B._setExecutionVariable(this,"_eventObserver",F)}_cancelPendingTasks(B){const u=B.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(u){const F=B._getExecutionVariable(this,"_eventObserver",null);u.remove(F)}else V.Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`)}_executeEvent(B,u){return!0}getClassName(){return"FlowGraphReceiveCustomEventBlock"}}(0,p.f)("FlowGraphReceiveCustomEventBlock",R)}}]);