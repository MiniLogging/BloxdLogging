"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[86],{15592:(V,h,mV)=>{mV.r(h),mV.d(h,{FlowGraphReceiveCustomEventBlock:()=>k});var t=mV(14137),L=mV(12253),N=mV(12388),A=mV(14097);class k extends t.e{constructor(V){super(V),this.config=V,this.initPriority=1;for(const h in this.config.eventData)this.registerDataOutput(h,this.config.eventData[h].type)}_preparePendingTasks(V){const h=V.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(h&&h.hasObservers()&&h.observers.length>A.e.MaxEventsPerType)return void this._reportError(V,`FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${A.e.MaxEventsPerType}.`);const mV=h.add((h=>{const mV=Object.keys(h);for(const L of mV){var t;null===(t=this.getDataOutput(L))||void 0===t||t.setValue(h[L],V)}this._execute(V)}));V._setExecutionVariable(this,"_eventObserver",mV)}_cancelPendingTasks(V){const h=V.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(h){const mV=V._getExecutionVariable(this,"_eventObserver",null);h.remove(mV)}else L.Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`)}_executeEvent(V,h){return!0}getClassName(){return"FlowGraphReceiveCustomEventBlock"}}(0,N.i)("FlowGraphReceiveCustomEventBlock",k)}}]);