"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[86],{15340:(I,O,C)=>{C.r(O),C.d(O,{FlowGraphReceiveCustomEventBlock:()=>S});var j=C(13931),K=C(12083),i=C(12226),y=C(13866);class S extends j.b{constructor(I){super(I),this.config=I,this.initPriority=1;for(const O in this.config.eventData)this.registerDataOutput(O,this.config.eventData[O].type)}_preparePendingTasks(I){const O=I.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(O&&O.hasObservers()&&O.observers.length>y.e.MaxEventsPerType)return void this._reportError(I,`FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${y.e.MaxEventsPerType}.`);const C=O.add((O=>{const C=Object.keys(O);for(const K of C){var j;null===(j=this.getDataOutput(K))||void 0===j||j.setValue(O[K],I)}this._execute(I)}));I._setExecutionVariable(this,"_eventObserver",C)}_cancelPendingTasks(I){const O=I.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(O){const C=I._getExecutionVariable(this,"_eventObserver",null);O.remove(C)}else K.Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`)}_executeEvent(I,O){return!0}getClassName(){return"FlowGraphReceiveCustomEventBlock"}}(0,i.e)("FlowGraphReceiveCustomEventBlock",S)}}]);