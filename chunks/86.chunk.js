"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[86],{14562:(B,E,v)=>{v.r(E),v.d(E,{FlowGraphReceiveCustomEventBlock:()=>S});var z=v(13135),o=v(11193),q=v(11345),c=v(13083);class S extends z.b{constructor(B){super(B),this.config=B,this.initPriority=1;for(const E in this.config.eventData)this.registerDataOutput(E,this.config.eventData[E].type)}_preparePendingTasks(B){const E=B.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(E&&E.hasObservers()&&E.observers.length>c.b.MaxEventsPerType)return void this._reportError(B,`FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${c.b.MaxEventsPerType}.`);const v=E.add((E=>{const v=Object.keys(E);for(const o of v){var z;null===(z=this.getDataOutput(o))||void 0===z||z.setValue(E[o],B)}this._execute(B)}));B._setExecutionVariable(this,"_eventObserver",v)}_cancelPendingTasks(B){const E=B.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(E){const v=B._getExecutionVariable(this,"_eventObserver",null);E.remove(v)}else o.Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`)}_executeEvent(B,E){return!0}getClassName(){return"FlowGraphReceiveCustomEventBlock"}}(0,q.f)("FlowGraphReceiveCustomEventBlock",S)}}]);