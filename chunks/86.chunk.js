"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[86],{15825:(M,A,O)=>{O.r(A),O.d(A,{FlowGraphReceiveCustomEventBlock:()=>c});var S=O(14280),z=O(12768),Q=O(12919),X=O(14223);class c extends S.e{constructor(M){super(M),this.config=M,this.initPriority=1;for(const A in this.config.eventData)this.registerDataOutput(A,this.config.eventData[A].type)}_preparePendingTasks(M){const A=M.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(A&&A.hasObservers()&&A.observers.length>X.e.MaxEventsPerType)return void this._reportError(M,"FlowGraphReceiveCustomEventBlock: Too many observers for event ".concat(this.config.eventId,". Max is ").concat(X.e.MaxEventsPerType,"."));const O=A.add((A=>{const O=Object.keys(A);for(const z of O){var S;null===(S=this.getDataOutput(z))||void 0===S||S.setValue(A[z],M)}this._execute(M)}));M._setExecutionVariable(this,"_eventObserver",O)}_cancelPendingTasks(M){const A=M.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(A){const O=M._getExecutionVariable(this,"_eventObserver",null);A.remove(O)}else z.Tools.Warn("FlowGraphReceiveCustomEventBlock: Missing observable for event ".concat(this.config.eventId))}_executeEvent(M,A){return!0}getClassName(){return"FlowGraphReceiveCustomEventBlock"}}(0,Q.g)("FlowGraphReceiveCustomEventBlock",c)}}]);