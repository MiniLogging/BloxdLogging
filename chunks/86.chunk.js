"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[86],{14391:(k,h,o)=>{o.r(h),o.d(h,{FlowGraphReceiveCustomEventBlock:()=>J});var x=o(12981),I=o(11078),q=o(11199),Y=o(12921);class J extends x.e{constructor(k){super(k),this.config=k,this.initPriority=1;for(const h in this.config.eventData)this.registerDataOutput(h,this.config.eventData[h].type)}_preparePendingTasks(k){const h=k.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(h&&h.hasObservers()&&h.observers.length>Y.b.MaxEventsPerType)return void this._reportError(k,`FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${Y.b.MaxEventsPerType}.`);const o=h.add((h=>{const o=Object.keys(h);for(const I of o){var x;null===(x=this.getDataOutput(I))||void 0===x||x.setValue(h[I],k)}this._execute(k)}));k._setExecutionVariable(this,"_eventObserver",o)}_cancelPendingTasks(k){const h=k.configuration.coordinator.getCustomEventObservable(this.config.eventId);if(h){const o=k._getExecutionVariable(this,"_eventObserver",null);h.remove(o)}else I.Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`)}_executeEvent(k,h){return!0}getClassName(){return"FlowGraphReceiveCustomEventBlock"}}(0,q.g)("FlowGraphReceiveCustomEventBlock",J)}}]);