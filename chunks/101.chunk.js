"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[101],{14342:(t,q,S)=>{S.r(q),S.d(q,{EasingFunctionType:()=>o,FlowGraphEasingBlock:()=>e});var o,B=S(13198),z=S(12946),L=S(12927),r=S(622);!function(t){t[t.CircleEase=0]="CircleEase",t[t.BackEase=1]="BackEase",t[t.BounceEase=2]="BounceEase",t[t.CubicEase=3]="CubicEase",t[t.ElasticEase=4]="ElasticEase",t[t.ExponentialEase=5]="ExponentialEase",t[t.PowerEase=6]="PowerEase",t[t.QuadraticEase=7]="QuadraticEase",t[t.QuarticEase=8]="QuarticEase",t[t.QuinticEase=9]="QuinticEase",t[t.SineEase=10]="SineEase",t[t.BezierCurveEase=11]="BezierCurveEase"}(o||(o={}));class e extends z.d{constructor(t){super(t),this.config=t,this._easingFunctions={},this.type=this.registerDataInput("type",L.b,11),this.mode=this.registerDataInput("mode",L.v,0),this.parameters=this.registerDataInput("parameters",L.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",L.b)}_updateOutputs(t){const q=this.type.getValue(t),S=this.mode.getValue(t),o=this.parameters.getValue(t);if(void 0===q||void 0===S)return;const z=`${q}-${S}-${o.join("-")}`;if(!this._easingFunctions[z]){const t=function(t){for(var q=arguments.length,S=new Array(q>1?q-1:0),o=1;o<q;o++)S[o-1]=arguments[o];switch(t){case 11:return new B.e(...S);case 0:return new B.j;case 1:return new B.d(...S);case 2:return new B.h(...S);case 3:return new B.m;case 4:return new B.q(...S);case 5:return new B.s(...S);default:throw new Error("Easing type not yet implemented")}}(q,...o);t.setEasingMode(S),this._easingFunctions[z]=t}this.easingFunction.setValue(this._easingFunctions[z],t)}getClassName(){return"FlowGraphEasingBlock"}}(0,r.c)("FlowGraphEasingBlock",e)}}]);