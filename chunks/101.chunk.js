"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[101],{14138:(U,W,l)=>{l.r(W),l.d(W,{EasingFunctionType:()=>M,FlowGraphEasingBlock:()=>k});var M,t=l(12995),L=l(12739),p=l(12704),B=l(655);!function(U){U[U.CircleEase=0]="CircleEase",U[U.BackEase=1]="BackEase",U[U.BounceEase=2]="BounceEase",U[U.CubicEase=3]="CubicEase",U[U.ElasticEase=4]="ElasticEase",U[U.ExponentialEase=5]="ExponentialEase",U[U.PowerEase=6]="PowerEase",U[U.QuadraticEase=7]="QuadraticEase",U[U.QuarticEase=8]="QuarticEase",U[U.QuinticEase=9]="QuinticEase",U[U.SineEase=10]="SineEase",U[U.BezierCurveEase=11]="BezierCurveEase"}(M||(M={}));class k extends L.e{constructor(U){super(U),this.config=U,this._easingFunctions={},this.type=this.registerDataInput("type",p.d,11),this.mode=this.registerDataInput("mode",p.s,0),this.parameters=this.registerDataInput("parameters",p.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",p.d)}_updateOutputs(U){const W=this.type.getValue(U),l=this.mode.getValue(U),M=this.parameters.getValue(U);if(void 0===W||void 0===l)return;const L=`${W}-${l}-${M.join("-")}`;if(!this._easingFunctions[L]){const U=function(U){for(var W=arguments.length,l=new Array(W>1?W-1:0),M=1;M<W;M++)l[M-1]=arguments[M];switch(U){case 11:return new t.d(...l);case 0:return new t.g;case 1:return new t.b(...l);case 2:return new t.f(...l);case 3:return new t.j;case 4:return new t.q(...l);case 5:return new t.t(...l);default:throw new Error("Easing type not yet implemented")}}(W,...M);U.setEasingMode(l),this._easingFunctions[L]=U}this.easingFunction.setValue(this._easingFunctions[L],U)}getClassName(){return"FlowGraphEasingBlock"}}(0,B.f)("FlowGraphEasingBlock",k)}}]);