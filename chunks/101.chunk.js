"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[101],{14233:(Z,U,n)=>{n.r(U),n.d(U,{EasingFunctionType:()=>i,FlowGraphEasingBlock:()=>G});var i,B=n(13089),l=n(12837),H=n(12826),V=n(633);!function(Z){Z[Z.CircleEase=0]="CircleEase",Z[Z.BackEase=1]="BackEase",Z[Z.BounceEase=2]="BounceEase",Z[Z.CubicEase=3]="CubicEase",Z[Z.ElasticEase=4]="ElasticEase",Z[Z.ExponentialEase=5]="ExponentialEase",Z[Z.PowerEase=6]="PowerEase",Z[Z.QuadraticEase=7]="QuadraticEase",Z[Z.QuarticEase=8]="QuarticEase",Z[Z.QuinticEase=9]="QuinticEase",Z[Z.SineEase=10]="SineEase",Z[Z.BezierCurveEase=11]="BezierCurveEase"}(i||(i={}));class G extends l.b{constructor(Z){super(Z),this.config=Z,this._easingFunctions={},this.type=this.registerDataInput("type",H.b,11),this.mode=this.registerDataInput("mode",H.s,0),this.parameters=this.registerDataInput("parameters",H.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",H.b)}_updateOutputs(Z){const U=this.type.getValue(Z),n=this.mode.getValue(Z),i=this.parameters.getValue(Z);if(void 0===U||void 0===n)return;const l=`${U}-${n}-${i.join("-")}`;if(!this._easingFunctions[l]){const Z=function(Z){for(var U=arguments.length,n=new Array(U>1?U-1:0),i=1;i<U;i++)n[i-1]=arguments[i];switch(Z){case 11:return new B.h(...n);case 0:return new B.m;case 1:return new B.d(...n);case 2:return new B.l(...n);case 3:return new B.p;case 4:return new B.s(...n);case 5:return new B.w(...n);default:throw new Error("Easing type not yet implemented")}}(U,...i);Z.setEasingMode(n),this._easingFunctions[l]=Z}this.easingFunction.setValue(this._easingFunctions[l],Z)}getClassName(){return"FlowGraphEasingBlock"}}(0,V.g)("FlowGraphEasingBlock",G)}}]);