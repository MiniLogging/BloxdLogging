"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[101],{14486:(Q,X,C)=>{C.r(X),C.d(X,{EasingFunctionType:()=>l,FlowGraphEasingBlock:()=>m});var l,h=C(13372),M=C(13092),f=C(13063),O=C(620);!function(Q){Q[Q.CircleEase=0]="CircleEase",Q[Q.BackEase=1]="BackEase",Q[Q.BounceEase=2]="BounceEase",Q[Q.CubicEase=3]="CubicEase",Q[Q.ElasticEase=4]="ElasticEase",Q[Q.ExponentialEase=5]="ExponentialEase",Q[Q.PowerEase=6]="PowerEase",Q[Q.QuadraticEase=7]="QuadraticEase",Q[Q.QuarticEase=8]="QuarticEase",Q[Q.QuinticEase=9]="QuinticEase",Q[Q.SineEase=10]="SineEase",Q[Q.BezierCurveEase=11]="BezierCurveEase"}(l||(l={}));class m extends M.c{constructor(Q){super(Q),this.config=Q,this._easingFunctions={},this.type=this.registerDataInput("type",f.d,11),this.mode=this.registerDataInput("mode",f.p,0),this.parameters=this.registerDataInput("parameters",f.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",f.d)}_updateOutputs(Q){const X=this.type.getValue(Q),C=this.mode.getValue(Q),l=this.parameters.getValue(Q);if(void 0===X||void 0===C)return;const M=`${X}-${C}-${l.join("-")}`;if(!this._easingFunctions[M]){const Q=function(Q){for(var X=arguments.length,C=new Array(X>1?X-1:0),l=1;l<X;l++)C[l-1]=arguments[l];switch(Q){case 11:return new h.h(...C);case 0:return new h.o;case 1:return new h.e(...C);case 2:return new h.l(...C);case 3:return new h.p;case 4:return new h.t(...C);case 5:return new h.w(...C);default:throw new Error("Easing type not yet implemented")}}(X,...l);Q.setEasingMode(C),this._easingFunctions[M]=Q}this.easingFunction.setValue(this._easingFunctions[M],Q)}getClassName(){return"FlowGraphEasingBlock"}}(0,O.g)("FlowGraphEasingBlock",m)}}]);