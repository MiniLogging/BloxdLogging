"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[101],{13911:(L,j,P)=>{P.r(j),P.d(j,{EasingFunctionType:()=>A,FlowGraphEasingBlock:()=>a});var A,R=P(12752),o=P(12523),Y=P(12510),u=P(606);!function(L){L[L.CircleEase=0]="CircleEase",L[L.BackEase=1]="BackEase",L[L.BounceEase=2]="BounceEase",L[L.CubicEase=3]="CubicEase",L[L.ElasticEase=4]="ElasticEase",L[L.ExponentialEase=5]="ExponentialEase",L[L.PowerEase=6]="PowerEase",L[L.QuadraticEase=7]="QuadraticEase",L[L.QuarticEase=8]="QuarticEase",L[L.QuinticEase=9]="QuinticEase",L[L.SineEase=10]="SineEase",L[L.BezierCurveEase=11]="BezierCurveEase"}(A||(A={}));class a extends o.d{constructor(L){super(L),this.config=L,this._easingFunctions={},this.type=this.registerDataInput("type",Y.d,11),this.mode=this.registerDataInput("mode",Y.p,0),this.parameters=this.registerDataInput("parameters",Y.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",Y.d)}_updateOutputs(L){const j=this.type.getValue(L),P=this.mode.getValue(L),A=this.parameters.getValue(L);if(void 0===j||void 0===P)return;const o=`${j}-${P}-${A.join("-")}`;if(!this._easingFunctions[o]){const L=function(L){for(var j=arguments.length,P=new Array(j>1?j-1:0),A=1;A<j;A++)P[A-1]=arguments[A];switch(L){case 11:return new R.f(...P);case 0:return new R.l;case 1:return new R.e(...P);case 2:return new R.j(...P);case 3:return new R.n;case 4:return new R.v(...P);case 5:return new R.w(...P);default:throw new Error("Easing type not yet implemented")}}(j,...A);L.setEasingMode(P),this._easingFunctions[o]=L}this.easingFunction.setValue(this._easingFunctions[o],L)}getClassName(){return"FlowGraphEasingBlock"}}(0,u.h)("FlowGraphEasingBlock",a)}}]);