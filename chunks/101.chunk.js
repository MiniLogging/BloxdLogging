"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[101],{14218:(c,b,A)=>{A.r(b),A.d(b,{EasingFunctionType:()=>o,FlowGraphEasingBlock:()=>L});var o,t=A(13028),n=A(12789),h=A(12763),s=A(633);!function(c){c[c.CircleEase=0]="CircleEase",c[c.BackEase=1]="BackEase",c[c.BounceEase=2]="BounceEase",c[c.CubicEase=3]="CubicEase",c[c.ElasticEase=4]="ElasticEase",c[c.ExponentialEase=5]="ExponentialEase",c[c.PowerEase=6]="PowerEase",c[c.QuadraticEase=7]="QuadraticEase",c[c.QuarticEase=8]="QuarticEase",c[c.QuinticEase=9]="QuinticEase",c[c.SineEase=10]="SineEase",c[c.BezierCurveEase=11]="BezierCurveEase"}(o||(o={}));class L extends n.d{constructor(c){super(c),this.config=c,this._easingFunctions={},this.type=this.registerDataInput("type",h.e,11),this.mode=this.registerDataInput("mode",h.t,0),this.parameters=this.registerDataInput("parameters",h.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",h.e)}_updateOutputs(c){const b=this.type.getValue(c),A=this.mode.getValue(c),o=this.parameters.getValue(c);if(void 0===b||void 0===A)return;const n=`${b}-${A}-${o.join("-")}`;if(!this._easingFunctions[n]){const c=function(c){for(var b=arguments.length,A=new Array(b>1?b-1:0),o=1;o<b;o++)A[o-1]=arguments[o];switch(c){case 11:return new t.f(...A);case 0:return new t.k;case 1:return new t.b(...A);case 2:return new t.i(...A);case 3:return new t.m;case 4:return new t.r(...A);case 5:return new t.s(...A);default:throw new Error("Easing type not yet implemented")}}(b,...o);c.setEasingMode(A),this._easingFunctions[n]=c}this.easingFunction.setValue(this._easingFunctions[n],c)}getClassName(){return"FlowGraphEasingBlock"}}(0,s.d)("FlowGraphEasingBlock",L)}}]);