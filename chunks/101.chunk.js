"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[101],{14350:(v,d,Q)=>{Q.r(d),Q.d(d,{EasingFunctionType:()=>n,FlowGraphEasingBlock:()=>r});var n,T=Q(13173),L=Q(12934),e=Q(12908),F=Q(591);!function(v){v[v.CircleEase=0]="CircleEase",v[v.BackEase=1]="BackEase",v[v.BounceEase=2]="BounceEase",v[v.CubicEase=3]="CubicEase",v[v.ElasticEase=4]="ElasticEase",v[v.ExponentialEase=5]="ExponentialEase",v[v.PowerEase=6]="PowerEase",v[v.QuadraticEase=7]="QuadraticEase",v[v.QuarticEase=8]="QuarticEase",v[v.QuinticEase=9]="QuinticEase",v[v.SineEase=10]="SineEase",v[v.BezierCurveEase=11]="BezierCurveEase"}(n||(n={}));class r extends L.b{constructor(v){super(v),this.config=v,this._easingFunctions={},this.type=this.registerDataInput("type",e.c,11),this.mode=this.registerDataInput("mode",e.u,0),this.parameters=this.registerDataInput("parameters",e.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",e.c)}_updateOutputs(v){const d=this.type.getValue(v),Q=this.mode.getValue(v),n=this.parameters.getValue(v);if(void 0===d||void 0===Q)return;const L=`${d}-${Q}-${n.join("-")}`;if(!this._easingFunctions[L]){const v=function(v){for(var d=arguments.length,Q=new Array(d>1?d-1:0),n=1;n<d;n++)Q[n-1]=arguments[n];switch(v){case 11:return new T.g(...Q);case 0:return new T.j;case 1:return new T.d(...Q);case 2:return new T.h(...Q);case 3:return new T.m;case 4:return new T.t(...Q);case 5:return new T.v(...Q);default:throw new Error("Easing type not yet implemented")}}(d,...n);v.setEasingMode(Q),this._easingFunctions[L]=v}this.easingFunction.setValue(this._easingFunctions[L],v)}getClassName(){return"FlowGraphEasingBlock"}}(0,F.f)("FlowGraphEasingBlock",r)}}]);