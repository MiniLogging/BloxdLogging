"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[101],{14633:(R,x,H)=>{H.r(x),H.d(x,{EasingFunctionType:()=>k,FlowGraphEasingBlock:()=>U});var k,c=H(13518),t=H(13268),A=H(13246),D=H(610);!function(R){R[R.CircleEase=0]="CircleEase",R[R.BackEase=1]="BackEase",R[R.BounceEase=2]="BounceEase",R[R.CubicEase=3]="CubicEase",R[R.ElasticEase=4]="ElasticEase",R[R.ExponentialEase=5]="ExponentialEase",R[R.PowerEase=6]="PowerEase",R[R.QuadraticEase=7]="QuadraticEase",R[R.QuarticEase=8]="QuarticEase",R[R.QuinticEase=9]="QuinticEase",R[R.SineEase=10]="SineEase",R[R.BezierCurveEase=11]="BezierCurveEase"}(k||(k={}));class U extends t.b{constructor(R){super(R),this.config=R,this._easingFunctions={},this.type=this.registerDataInput("type",A.b,11),this.mode=this.registerDataInput("mode",A.m,0),this.parameters=this.registerDataInput("parameters",A.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",A.b)}_updateOutputs(R){const x=this.type.getValue(R),H=this.mode.getValue(R),k=this.parameters.getValue(R);if(void 0===x||void 0===H)return;const t=`${x}-${H}-${k.join("-")}`;if(!this._easingFunctions[t]){const R=function(R){for(var x=arguments.length,H=new Array(x>1?x-1:0),k=1;k<x;k++)H[k-1]=arguments[k];switch(R){case 11:return new c.e(...H);case 0:return new c.g;case 1:return new c.d(...H);case 2:return new c.f(...H);case 3:return new c.h;case 4:return new c.l(...H);case 5:return new c.n(...H);default:throw new Error("Easing type not yet implemented")}}(x,...k);R.setEasingMode(H),this._easingFunctions[t]=R}this.easingFunction.setValue(this._easingFunctions[t],R)}getClassName(){return"FlowGraphEasingBlock"}}(0,D.h)("FlowGraphEasingBlock",U)}}]);