"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{13118:(a,v,p)=>{p.r(v),p.d(v,{_HDRTextureLoader:()=>F});var P=p(11240);class b{static ConvertPanoramaToCubemap(a,v,p,P){let b=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!a)throw"ConvertPanoramaToCubemap: input cannot be null";if(a.length!=v*p*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(P,this.FACE_FRONT,a,v,p,b),back:this.CreateCubemapTexture(P,this.FACE_BACK,a,v,p,b),left:this.CreateCubemapTexture(P,this.FACE_LEFT,a,v,p,b),right:this.CreateCubemapTexture(P,this.FACE_RIGHT,a,v,p,b),up:this.CreateCubemapTexture(P,this.FACE_UP,a,v,p,b),down:this.CreateCubemapTexture(P,this.FACE_DOWN,a,v,p,b),size:P,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(a,v,p,P,b){let L=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const t=new ArrayBuffer(a*a*4*3),V=new Float32Array(t),K=L?Math.max(1,Math.round(P/4/a)):1,C=1/K,F=C*C,u=v[1].od(v[0]).scale(C/a),c=v[3].od(v[2]).scale(C/a),f=1/a;let H=0;for(let A=0;A<a;A++)for(let L=0;L<K;L++){let L=v[0],t=v[2];for(let v=0;v<a;v++)for(let C=0;C<K;C++){const K=t.od(L).scale(H).add(L);K.normalize();const C=this.CalcProjectionSpherical(K,p,P,b);V[A*a*3+3*v+0]+=C.r*F,V[A*a*3+3*v+1]+=C.g*F,V[A*a*3+3*v+2]+=C.b*F,L=L.add(u),t=t.add(c)}H+=f*C}return V}static CalcProjectionSpherical(a,v,p,P){let b=Math.atan2(a.z,a.x);const L=Math.acos(a.y);for(;b<-Math.PI;)b+=2*Math.PI;for(;b>Math.PI;)b-=2*Math.PI;let t=b/Math.PI;const V=L/Math.PI;t=.5*t+.5;let K=Math.round(t*p);K<0?K=0:K>=p&&(K=p-1);let C=Math.round(V*P);C<0?C=0:C>=P&&(C=P-1);const F=P-C-1;return{r:v[F*p*3+3*K+0],g:v[F*p*3+3*K+1],b:v[F*p*3+3*K+2]}}}function L(a,v,p,P,b,L){b>0?(b=function(a,v){return v>1023?a*Math.pow(2,1023)*Math.pow(2,v-1023):v<-1074?a*Math.pow(2,-1074)*Math.pow(2,v+1074):a*Math.pow(2,v)}(1,b-136),a[L+0]=v*b,a[L+1]=p*b,a[L+2]=P*b):(a[L+0]=0,a[L+1]=0,a[L+2]=0)}function t(a,v){let p="",P="";for(let b=v;b<a.length-v&&(P=String.fromCharCode(a[b]),"\n"!=P);b++)p+=P;return p}function V(a){let v=0,p=0,P=t(a,0);if("#"!=P[0]||"?"!=P[1])throw"Bad HDR Format.";let b=!1,L=!1,V=0;do{V+=P.length+1,P=t(a,V),"FORMAT=32-bit_rle_rgbe"==P?L=!0:0==P.length&&(b=!0)}while(!b);if(!L)throw"HDR Bad header format, unsupported FORMAT";V+=P.length+1,P=t(a,V);const K=/^-Y (.*) \+X (.*)$/g.exec(P);if(!K||K.length<3)throw"HDR Bad header format, no size";if(p=parseInt(K[2]),v=parseInt(K[1]),p<8||p>32767)throw"HDR Bad header format, unsupported size";return V+=P.length+1,{height:v,width:p,dataPosition:V}}function K(a,v){return function(a,v){let p=v.height;const P=v.width;let b,t,V,K,F,u=v.dataPosition,c=0,f=0,H=0;const A=new ArrayBuffer(4*P),h=new Uint8Array(A),R=new ArrayBuffer(v.width*v.height*4*3),X=new Float32Array(R);for(;p>0;){if(b=a[u++],t=a[u++],V=a[u++],K=a[u++],2!=b||2!=t||128&V||v.width<8||v.width>32767)return C(a,v);if((V<<8|K)!=P)throw"HDR Bad header format, wrong scan line width";for(c=0,H=0;H<4;H++)for(f=(H+1)*P;c<f;)if(b=a[u++],t=a[u++],b>128){if(F=b-128,0==F||F>f-c)throw"HDR Bad Format, bad scanline data (run)";for(;F-- >0;)h[c++]=t}else{if(F=b,0==F||F>f-c)throw"HDR Bad Format, bad scanline data (non-run)";if(h[c++]=t,--F>0)for(let v=0;v<F;v++)h[c++]=a[u++]}for(H=0;H<P;H++)b=h[H],t=h[H+P],V=h[H+2*P],K=h[H+3*P],L(X,b,t,V,K,(v.height-p)*P*3+3*H);p--}return X}(a,v)}function C(a,v){let p=v.height;const P=v.width;let b,t,V,K,C,F=v.dataPosition;const u=new ArrayBuffer(v.width*v.height*4*3),c=new Float32Array(u);for(;p>0;){for(C=0;C<v.width;C++)b=a[F++],t=a[F++],V=a[F++],K=a[F++],L(c,b,t,V,K,(v.height-p)*P*3+3*C);p--}return c}b.FACE_LEFT=[new P.s(-1,-1,-1),new P.s(1,-1,-1),new P.s(-1,1,-1),new P.s(1,1,-1)],b.FACE_RIGHT=[new P.s(1,-1,1),new P.s(-1,-1,1),new P.s(1,1,1),new P.s(-1,1,1)],b.FACE_FRONT=[new P.s(1,-1,-1),new P.s(1,-1,1),new P.s(1,1,-1),new P.s(1,1,1)],b.FACE_BACK=[new P.s(-1,-1,1),new P.s(-1,-1,-1),new P.s(-1,1,1),new P.s(-1,1,-1)],b.FACE_DOWN=[new P.s(1,1,-1),new P.s(1,1,1),new P.s(-1,1,-1),new P.s(-1,1,1)],b.FACE_UP=[new P.s(-1,-1,-1),new P.s(-1,-1,1),new P.s(1,-1,-1),new P.s(1,-1,1)];class F{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(a,v,p){const P=new Uint8Array(a.buffer,a.byteOffset,a.byteLength),b=V(P),L=K(P,b),t=b.width*b.height,C=new Float32Array(4*t);for(let V=0;V<t;V+=1)C[4*V]=L[3*V],C[4*V+1]=L[3*V+1],C[4*V+2]=L[3*V+2],C[4*V+3]=1;p(b.width,b.height,v.generateMipMaps,!1,(()=>{const a=v.getEngine();v.type=1,v.format=5,v._gammaSpace=!1,a._uploadDataToTextureDirectly(v,C)}))}}}}]);