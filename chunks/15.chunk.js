"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12661:(K,q,p)=>{p.r(q),p.d(q,{_HDRTextureLoader:()=>h});var Z=p(11005);class z{static ConvertPanoramaToCubemap(K,q,p,Z){let z=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!K)throw"ConvertPanoramaToCubemap: input cannot be null";if(K.length!=q*p*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(Z,this.FACE_FRONT,K,q,p,z),back:this.CreateCubemapTexture(Z,this.FACE_BACK,K,q,p,z),left:this.CreateCubemapTexture(Z,this.FACE_LEFT,K,q,p,z),right:this.CreateCubemapTexture(Z,this.FACE_RIGHT,K,q,p,z),up:this.CreateCubemapTexture(Z,this.FACE_UP,K,q,p,z),down:this.CreateCubemapTexture(Z,this.FACE_DOWN,K,q,p,z),size:Z,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(K,q,p,Z,z){let S=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const X=new ArrayBuffer(K*K*4*3),y=new Float32Array(X),V=S?Math.max(1,Math.round(Z/4/K)):1,C=1/V,h=C*C,U=q[1].kd(q[0]).scale(C/K),Y=q[3].kd(q[2]).scale(C/K),k=1/K;let F=0;for(let x=0;x<K;x++)for(let S=0;S<V;S++){let S=q[0],X=q[2];for(let q=0;q<K;q++)for(let C=0;C<V;C++){const V=X.kd(S).scale(F).add(S);V.normalize();const C=this.CalcProjectionSpherical(V,p,Z,z);y[x*K*3+3*q+0]+=C.r*h,y[x*K*3+3*q+1]+=C.g*h,y[x*K*3+3*q+2]+=C.b*h,S=S.add(U),X=X.add(Y)}F+=k*C}return y}static CalcProjectionSpherical(K,q,p,Z){let z=Math.atan2(K.z,K.x);const S=Math.acos(K.y);for(;z<-Math.PI;)z+=2*Math.PI;for(;z>Math.PI;)z-=2*Math.PI;let X=z/Math.PI;const y=S/Math.PI;X=.5*X+.5;let V=Math.round(X*p);V<0?V=0:V>=p&&(V=p-1);let C=Math.round(y*Z);C<0?C=0:C>=Z&&(C=Z-1);const h=Z-C-1;return{r:q[h*p*3+3*V+0],g:q[h*p*3+3*V+1],b:q[h*p*3+3*V+2]}}}function S(K,q,p,Z,z,S){z>0?(z=function(K,q){return q>1023?K*Math.pow(2,1023)*Math.pow(2,q-1023):q<-1074?K*Math.pow(2,-1074)*Math.pow(2,q+1074):K*Math.pow(2,q)}(1,z-136),K[S+0]=q*z,K[S+1]=p*z,K[S+2]=Z*z):(K[S+0]=0,K[S+1]=0,K[S+2]=0)}function X(K,q){let p="",Z="";for(let z=q;z<K.length-q&&(Z=String.fromCharCode(K[z]),"\n"!=Z);z++)p+=Z;return p}function y(K){let q=0,p=0,Z=X(K,0);if("#"!=Z[0]||"?"!=Z[1])throw"Bad HDR Format.";let z=!1,S=!1,y=0;do{y+=Z.length+1,Z=X(K,y),"FORMAT=32-bit_rle_rgbe"==Z?S=!0:0==Z.length&&(z=!0)}while(!z);if(!S)throw"HDR Bad header format, unsupported FORMAT";y+=Z.length+1,Z=X(K,y);const V=/^-Y (.*) \+X (.*)$/g.exec(Z);if(!V||V.length<3)throw"HDR Bad header format, no size";if(p=parseInt(V[2]),q=parseInt(V[1]),p<8||p>32767)throw"HDR Bad header format, unsupported size";return y+=Z.length+1,{height:q,width:p,dataPosition:y}}function V(K,q){return function(K,q){let p=q.height;const Z=q.width;let z,X,y,V,h,U=q.dataPosition,Y=0,k=0,F=0;const x=new ArrayBuffer(4*Z),t=new Uint8Array(x),f=new ArrayBuffer(q.width*q.height*4*3),E=new Float32Array(f);for(;p>0;){if(z=K[U++],X=K[U++],y=K[U++],V=K[U++],2!=z||2!=X||128&y||q.width<8||q.width>32767)return C(K,q);if((y<<8|V)!=Z)throw"HDR Bad header format, wrong scan line width";for(Y=0,F=0;F<4;F++)for(k=(F+1)*Z;Y<k;)if(z=K[U++],X=K[U++],z>128){if(h=z-128,0==h||h>k-Y)throw"HDR Bad Format, bad scanline data (run)";for(;h-- >0;)t[Y++]=X}else{if(h=z,0==h||h>k-Y)throw"HDR Bad Format, bad scanline data (non-run)";if(t[Y++]=X,--h>0)for(let q=0;q<h;q++)t[Y++]=K[U++]}for(F=0;F<Z;F++)z=t[F],X=t[F+Z],y=t[F+2*Z],V=t[F+3*Z],S(E,z,X,y,V,(q.height-p)*Z*3+3*F);p--}return E}(K,q)}function C(K,q){let p=q.height;const Z=q.width;let z,X,y,V,C,h=q.dataPosition;const U=new ArrayBuffer(q.width*q.height*4*3),Y=new Float32Array(U);for(;p>0;){for(C=0;C<q.width;C++)z=K[h++],X=K[h++],y=K[h++],V=K[h++],S(Y,z,X,y,V,(q.height-p)*Z*3+3*C);p--}return Y}z.FACE_LEFT=[new Z.m(-1,-1,-1),new Z.m(1,-1,-1),new Z.m(-1,1,-1),new Z.m(1,1,-1)],z.FACE_RIGHT=[new Z.m(1,-1,1),new Z.m(-1,-1,1),new Z.m(1,1,1),new Z.m(-1,1,1)],z.FACE_FRONT=[new Z.m(1,-1,-1),new Z.m(1,-1,1),new Z.m(1,1,-1),new Z.m(1,1,1)],z.FACE_BACK=[new Z.m(-1,-1,1),new Z.m(-1,-1,-1),new Z.m(-1,1,1),new Z.m(-1,1,-1)],z.FACE_DOWN=[new Z.m(1,1,-1),new Z.m(1,1,1),new Z.m(-1,1,-1),new Z.m(-1,1,1)],z.FACE_UP=[new Z.m(-1,-1,-1),new Z.m(-1,-1,1),new Z.m(1,-1,-1),new Z.m(1,-1,1)];class h{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(K,q,p){const Z=new Uint8Array(K.buffer,K.byteOffset,K.byteLength),z=y(Z),S=V(Z,z),X=z.width*z.height,C=new Float32Array(4*X);for(let y=0;y<X;y+=1)C[4*y]=S[3*y],C[4*y+1]=S[3*y+1],C[4*y+2]=S[3*y+2],C[4*y+3]=1;p(z.width,z.height,q.generateMipMaps,!1,(()=>{const K=q.getEngine();q.type=1,q.format=5,q._gammaSpace=!1,K._uploadDataToTextureDirectly(q,C)}))}}}}]);