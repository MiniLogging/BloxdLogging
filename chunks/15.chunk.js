"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12709:(Y,j,X)=>{X.r(j),X.d(j,{_HDRTextureLoader:()=>e});var u=X(11062);class K{static ConvertPanoramaToCubemap(Y,j,X,u){let K=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Y)throw"ConvertPanoramaToCubemap: input cannot be null";if(Y.length!=j*X*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(u,this.FACE_FRONT,Y,j,X,K),back:this.CreateCubemapTexture(u,this.FACE_BACK,Y,j,X,K),left:this.CreateCubemapTexture(u,this.FACE_LEFT,Y,j,X,K),right:this.CreateCubemapTexture(u,this.FACE_RIGHT,Y,j,X,K),up:this.CreateCubemapTexture(u,this.FACE_UP,Y,j,X,K),down:this.CreateCubemapTexture(u,this.FACE_DOWN,Y,j,X,K),size:u,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(Y,j,X,u,K){let U=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const I=new ArrayBuffer(Y*Y*4*3),y=new Float32Array(I),T=U?Math.max(1,Math.round(u/4/Y)):1,E=1/T,e=E*E,a=j[1].Ec(j[0]).scale(E/Y),N=j[3].Ec(j[2]).scale(E/Y),d=1/Y;let i=0;for(let M=0;M<Y;M++)for(let U=0;U<T;U++){let U=j[0],I=j[2];for(let j=0;j<Y;j++)for(let E=0;E<T;E++){const T=I.Ec(U).scale(i).add(U);T.normalize();const E=this.CalcProjectionSpherical(T,X,u,K);y[M*Y*3+3*j+0]+=E.r*e,y[M*Y*3+3*j+1]+=E.g*e,y[M*Y*3+3*j+2]+=E.b*e,U=U.add(a),I=I.add(N)}i+=d*E}return y}static CalcProjectionSpherical(Y,j,X,u){let K=Math.atan2(Y.z,Y.x);const U=Math.acos(Y.y);for(;K<-Math.PI;)K+=2*Math.PI;for(;K>Math.PI;)K-=2*Math.PI;let I=K/Math.PI;const y=U/Math.PI;I=.5*I+.5;let T=Math.round(I*X);T<0?T=0:T>=X&&(T=X-1);let E=Math.round(y*u);E<0?E=0:E>=u&&(E=u-1);const e=u-E-1;return{r:j[e*X*3+3*T+0],g:j[e*X*3+3*T+1],b:j[e*X*3+3*T+2]}}}function U(Y,j,X,u,K,U){K>0?(K=function(Y,j){return j>1023?Y*Math.pow(2,1023)*Math.pow(2,j-1023):j<-1074?Y*Math.pow(2,-1074)*Math.pow(2,j+1074):Y*Math.pow(2,j)}(1,K-136),Y[U+0]=j*K,Y[U+1]=X*K,Y[U+2]=u*K):(Y[U+0]=0,Y[U+1]=0,Y[U+2]=0)}function I(Y,j){let X="",u="";for(let K=j;K<Y.length-j&&(u=String.fromCharCode(Y[K]),"\n"!=u);K++)X+=u;return X}function y(Y){let j=0,X=0,u=I(Y,0);if("#"!=u[0]||"?"!=u[1])throw"Bad HDR Format.";let K=!1,U=!1,y=0;do{y+=u.length+1,u=I(Y,y),"FORMAT=32-bit_rle_rgbe"==u?U=!0:0==u.length&&(K=!0)}while(!K);if(!U)throw"HDR Bad header format, unsupported FORMAT";y+=u.length+1,u=I(Y,y);const T=/^-Y (.*) \+X (.*)$/g.exec(u);if(!T||T.length<3)throw"HDR Bad header format, no size";if(X=parseInt(T[2]),j=parseInt(T[1]),X<8||X>32767)throw"HDR Bad header format, unsupported size";return y+=u.length+1,{height:j,width:X,dataPosition:y}}function T(Y,j){return function(Y,j){let X=j.height;const u=j.width;let K,I,y,T,e,a=j.dataPosition,N=0,d=0,i=0;const M=new ArrayBuffer(4*u),R=new Uint8Array(M),C=new ArrayBuffer(j.width*j.height*4*3),O=new Float32Array(C);for(;X>0;){if(K=Y[a++],I=Y[a++],y=Y[a++],T=Y[a++],2!=K||2!=I||128&y||j.width<8||j.width>32767)return E(Y,j);if((y<<8|T)!=u)throw"HDR Bad header format, wrong scan line width";for(N=0,i=0;i<4;i++)for(d=(i+1)*u;N<d;)if(K=Y[a++],I=Y[a++],K>128){if(e=K-128,0==e||e>d-N)throw"HDR Bad Format, bad scanline data (run)";for(;e-- >0;)R[N++]=I}else{if(e=K,0==e||e>d-N)throw"HDR Bad Format, bad scanline data (non-run)";if(R[N++]=I,--e>0)for(let j=0;j<e;j++)R[N++]=Y[a++]}for(i=0;i<u;i++)K=R[i],I=R[i+u],y=R[i+2*u],T=R[i+3*u],U(O,K,I,y,T,(j.height-X)*u*3+3*i);X--}return O}(Y,j)}function E(Y,j){let X=j.height;const u=j.width;let K,I,y,T,E,e=j.dataPosition;const a=new ArrayBuffer(j.width*j.height*4*3),N=new Float32Array(a);for(;X>0;){for(E=0;E<j.width;E++)K=Y[e++],I=Y[e++],y=Y[e++],T=Y[e++],U(N,K,I,y,T,(j.height-X)*u*3+3*E);X--}return N}K.FACE_LEFT=[new u.m(-1,-1,-1),new u.m(1,-1,-1),new u.m(-1,1,-1),new u.m(1,1,-1)],K.FACE_RIGHT=[new u.m(1,-1,1),new u.m(-1,-1,1),new u.m(1,1,1),new u.m(-1,1,1)],K.FACE_FRONT=[new u.m(1,-1,-1),new u.m(1,-1,1),new u.m(1,1,-1),new u.m(1,1,1)],K.FACE_BACK=[new u.m(-1,-1,1),new u.m(-1,-1,-1),new u.m(-1,1,1),new u.m(-1,1,-1)],K.FACE_DOWN=[new u.m(1,1,-1),new u.m(1,1,1),new u.m(-1,1,-1),new u.m(-1,1,1)],K.FACE_UP=[new u.m(-1,-1,-1),new u.m(-1,-1,1),new u.m(1,-1,-1),new u.m(1,-1,1)];class e{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(Y,j,X){const u=new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength),K=y(u),U=T(u,K),I=K.width*K.height,E=new Float32Array(4*I);for(let y=0;y<I;y+=1)E[4*y]=U[3*y],E[4*y+1]=U[3*y+1],E[4*y+2]=U[3*y+2],E[4*y+3]=1;X(K.width,K.height,j.generateMipMaps,!1,(()=>{const Y=j.getEngine();j.type=1,j.format=5,j._gammaSpace=!1,Y._uploadDataToTextureDirectly(j,E)}))}}}}]);