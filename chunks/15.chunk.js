"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{2568:(U,M,b)=>{b.r(M),b.d(M,{ReadExrDataAsync:()=>PU,_ExrTextureLoader:()=>xU});var a=b(497),A=b(682);const H=4,W=4,y=1,O=2,e=8,x=65536,P=x>>3,Z=14,C=65537,r=1<<Z,B=r-1,J=59,F=63,f=2+F-J;var L,z;!function(U){U[U.NO_COMPRESSION=0]="NO_COMPRESSION",U[U.RLE_COMPRESSION=1]="RLE_COMPRESSION",U[U.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",U[U.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",U[U.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",U[U.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(L||(L={})),function(U){U[U.INCREASING_Y=0]="INCREASING_Y",U[U.DECREASING_Y=1]="DECREASING_Y"}(z||(z={}));const o=function(){const U=new ArrayBuffer(4),M=new Float32Array(U),b=new Uint32Array(U),a=new Uint32Array(512),A=new Uint32Array(512);for(let O=0;O<256;++O){const U=O-127;U<-27?(a[O]=0,a[256|O]=32768,A[O]=24,A[256|O]=24):U<-14?(a[O]=1024>>-U-14,a[256|O]=1024>>-U-14|32768,A[O]=-U-1,A[256|O]=-U-1):U<=15?(a[O]=U+15<<10,a[256|O]=U+15<<10|32768,A[O]=13,A[256|O]=13):U<128?(a[O]=31744,a[256|O]=64512,A[O]=24,A[256|O]=24):(a[O]=31744,a[256|O]=64512,A[O]=13,A[256|O]=13)}const H=new Uint32Array(2048),W=new Uint32Array(64),y=new Uint32Array(64);for(let O=1;O<1024;++O){let U=O<<13,M=0;for(;0===(8388608&U);)U<<=1,M-=8388608;U&=-8388609,M+=947912704,H[O]=U|M}for(let O=1024;O<2048;++O)H[O]=939524096+(O-1024<<13);for(let O=1;O<31;++O)W[O]=O<<23;W[31]=1199570944,W[32]=2147483648;for(let O=33;O<63;++O)W[O]=2147483648+(O-32<<23);W[63]=3347054592;for(let O=1;O<64;++O)32!==O&&(y[O]=1024);return{floatView:M,uint32View:b,baseTable:a,shiftTable:A,mantissaTable:H,exponentTable:W,offsetTable:y}}();function S(U,M){const b=new Uint8Array(U);let a=0;for(;0!=b[M.value+a];)a+=1;const A=(new TextDecoder).decode(b.slice(M.value,M.value+a));return M.value=M.value+a+1,A}function h(U,M){const b=U.getInt32(M.value,!0);return M.value+=H,b}function i(U,M){const b=U.getUint32(M.value,!0);return M.value+=H,b}function Y(U,M){const b=U.getUint8(M.value);return M.value+=y,b}function d(U,M){const b=U.getUint16(M.value,!0);return M.value+=O,b}function s(U,M){const b=U[M.value];return M.value+=y,b}function q(U,M){let b;return b="getBigInt64"in DataView.prototype?Number(U.getBigInt64(M.value,!0)):U.getUint32(M.value+4,!0)+Number(U.getUint32(M.value,!0)<<32),M.value+=e,b}function m(U,M){const b=U.getFloat32(M.value,!0);return M.value+=W,b}function n(U,M){return function(U){const M=(31744&U)>>10,b=1023&U;return(U>>15?-1:1)*(M?31===M?b?NaN:1/0:Math.pow(2,M-15)*(1+b/1024):b/1024*6103515625e-14)}(d(U,M))}function E(U,M){return function(U){if(Math.abs(U)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");U=(0,A.b)(U,-65504,65504),o.floatView[0]=U;const M=o.uint32View[0],b=M>>23&511;return o.baseTable[b]+((8388607&M)>>o.shiftTable[b])}(m(U,M))}function X(U,M,b,a){switch(b){case"string":case"stringvector":case"iccProfile":return function(U,M,b){const a=(new TextDecoder).decode(new Uint8Array(U).slice(M.value,M.value+b));return M.value=M.value+b,a}(U.buffer,M,a);case"chlist":return function(U,M,b){const a=M.value,A=[];for(;M.value<a+b-1;){const b=S(U.buffer,M),a=h(U,M),H=Y(U,M);M.value+=3;const W=h(U,M),y=h(U,M);A.push({name:b,pixelType:a,pLinear:H,xSampling:W,ySampling:y})}return M.value+=1,A}(U,M,a);case"chromaticities":return function(U,M){return{redX:m(U,M),redY:m(U,M),greenX:m(U,M),greenY:m(U,M),blueX:m(U,M),blueY:m(U,M),whiteX:m(U,M),whiteY:m(U,M)}}(U,M);case"compression":return function(U,M){return Y(U,M)}(U,M);case"box2i":return function(U,M){return{xMin:h(U,M),yMin:h(U,M),xMax:h(U,M),yMax:h(U,M)}}(U,M);case"lineOrder":return function(U,M){const b=Y(U,M);return z[b]}(U,M);case"float":return m(U,M);case"v2f":return function(U,M){return[m(U,M),m(U,M)]}(U,M);case"v3f":return function(U,M){return[m(U,M),m(U,M),m(U,M)]}(U,M);case"int":return h(U,M);case"rational":return function(U,M){return[h(U,M),i(U,M)]}(U,M);case"timecode":return function(U,M){return[i(U,M),i(U,M)]}(U,M);case"preview":return M.value+=a,"skipped";default:return void(M.value+=a)}}function Q(U){for(let M=1;M<U.length;M++){const b=U[M-1]+U[M]-128;U[M]=b}}function I(U,M){let b=0,a=Math.floor((U.length+1)/2),A=0;const H=U.length-1;for(;!(A>H)&&(M[A++]=U[b++],!(A>H));)M[A++]=U[a++]}const v=20000630;function t(U,M){if(U.getUint32(0,!0)!=v)throw new Error("Incorrect OpenEXR format");const b=U.getUint8(4),A=U.getUint8(5),H={singleTile:!!(2&A),longName:!!(4&A),deepFormat:!!(8&A),multiPart:!!(16&A)};M.value=8;const W={};let y=!0;for(;y;){const b=S(U.buffer,M);if(b){const A=S(U.buffer,M),H=X(U,M,A,i(U,M));void 0===H?a.b.Warn(`Unknown header attribute type ${A}'.`):W[b]=H}else y=!1}if(0!=(-5&A))throw new Error("Unsupported file format");return{version:b,spec:H,...W}}const V=32768,k=65535;function N(U,M,b,a,A){for(;b<U;)M=M<<8|s(a,A),b+=8;return{l:M>>(b-=U)&(1<<U)-1,c:M,lc:b}}function R(U,M,b,a){return{c:U=U<<8|s(b,a),lc:M+=8}}function j(U,M,b,a,A,H,W,y,O){if(U==M){if(a<8){const U=R(b,a,A,H);b=U.c,a=U.lc}let U=b>>(a-=8);if(U=new Uint8Array([U])[0],y.value+U>O)return null;const M=W[y.value-1];for(;U-- >0;)W[y.value++]=M}else{if(!(y.value<O))return null;W[y.value++]=U}return{c:b,lc:a}}const p=new Array(59);function g(U,M,b,a,A,H){const W=M;let y=0,O=0;for(;a<=A;a++){if(W.value-M.value>b)return;let e=N(6,y,O,U,W);const x=e.l;if(y=e.c,O=e.lc,H[a]=x,x==F){if(W.value-M.value>b)throw new Error("Error in HufUnpackEncTable");e=N(8,y,O,U,W);let x=e.l+f;if(y=e.c,O=e.lc,a+x>A+1)throw new Error("Error in HufUnpackEncTable");for(;x--;)H[a++]=0;a--}else if(x>=J){let U=x-J+2;if(a+U>A+1)throw new Error("Error in HufUnpackEncTable");for(;U--;)H[a++]=0;a--}}!function(U){for(let b=0;b<=58;++b)p[b]=0;for(let b=0;b<C;++b)p[U[b]]+=1;let M=0;for(let b=58;b>0;--b){const U=M+p[b]>>1;p[b]=M,M=U}for(let b=0;b<C;++b){const M=U[b];M>0&&(U[b]=M|p[M]++<<6)}}(H)}function K(U){return 63&U}function w(U){return U>>6}function T(U,M,b,a,A,H){const W=b.value,y=i(M,b),O=i(M,b);b.value+=4;const e=i(M,b);if(b.value+=4,y<0||y>=C||O<0||O>=C)throw new Error("Wrong HUF_ENCSIZE");const x=new Array(C),P=new Array(r);!function(U){for(let M=0;M<r;M++)U[M]={},U[M].len=0,U[M].lit=0,U[M].p=null}(P);if(g(U,b,a-(b.value-W),y,O,x),e>8*(a-(b.value-W)))throw new Error("Wrong hufUncompress");!function(U,M,b,a){for(;M<=b;M++){const b=w(U[M]),A=K(U[M]);if(b>>A)throw new Error("Invalid table entry");if(A>Z){const U=a[b>>A-Z];if(U.len)throw new Error("Invalid table entry");if(U.lit++,U.p){const M=U.p;U.p=new Array(U.lit);for(let b=0;b<U.lit-1;++b)U.p[b]=M[b]}else U.p=new Array(1);U.p[U.lit-1]=M}else if(A){let U=0;for(let H=1<<Z-A;H>0;H--){const H=a[(b<<Z-A)+U];if(H.len||H.p)throw new Error("Invalid table entry");H.len=A,H.lit=M,U++}}}}(x,y,O,P),function(U,M,b,a,A,H,W,y,O){let e=0,x=0;const P=W,C=Math.trunc(a.value+(A+7)/8);for(;a.value<C;){let A=R(e,x,b,a);for(e=A.c,x=A.lc;x>=Z;){const W=M[e>>x-Z&B];if(W.len){x-=W.len;const U=j(W.lit,H,e,x,b,a,y,O,P);U&&(e=U.c,x=U.lc)}else{if(!W.p)throw new Error("hufDecode issues");let M;for(M=0;M<W.lit;M++){const Z=K(U[W.p[M]]);for(;x<Z&&a.value<C;)A=R(e,x,b,a),e=A.c,x=A.lc;if(x>=Z&&w(U[W.p[M]])==(e>>x-Z&(1<<Z)-1)){x-=Z;const U=j(W.p[M],H,e,x,b,a,y,O,P);U&&(e=U.c,x=U.lc);break}}if(M==W.lit)throw new Error("HufDecode issues")}}}const r=8-A&7;for(e>>=r,x-=r;x>0;){const U=M[e<<Z-x&B];if(!U.len)throw new Error("HufDecode issues");{x-=U.len;const M=j(U.lit,H,e,x,b,a,y,O,P);M&&(e=M.c,x=M.lc)}}}(x,P,U,b,e,O,H,A,{value:0})}function G(U){return 65535&U}function l(U){const M=G(U);return M>32767?M-65536:M}function D(U,M){const b=l(U),a=l(M),A=b+(1&a)+(a>>1);return{a:A,b:A-a}}function u(U,M){const b=G(U),a=G(M),A=b-(a>>1)&k;return{a:a+A-V&k,b:A}}function c(U,M,b,a,A,H,W){const y=W<16384,O=b>A?A:b;let e,x,P=1;for(;P<=O;)P<<=1;for(P>>=1,e=P,P>>=1;P>=1;){x=0;const W=x+H*(A-e),O=H*P,Z=H*e,C=a*P,r=a*e;let B,J,F,f;for(;x<=W;x+=Z){let A=x;const H=x+a*(b-e);for(;A<=H;A+=r){const b=A+C,a=A+O,H=a+C;if(y){let W=D(U[A+M],U[a+M]);B=W.a,F=W.b,W=D(U[b+M],U[H+M]),J=W.a,f=W.b,W=D(B,J),U[A+M]=W.a,U[b+M]=W.b,W=D(F,f),U[a+M]=W.a,U[H+M]=W.b}else{let W=u(U[A+M],U[a+M]);B=W.a,F=W.b,W=u(U[b+M],U[H+M]),J=W.a,f=W.b,W=u(B,J),U[A+M]=W.a,U[b+M]=W.b,W=u(F,f),U[a+M]=W.a,U[H+M]=W.b}}if(b&P){const b=A+O;let a;a=y?D(U[A+M],U[b+M]):u(U[A+M],U[b+M]),B=a.a,U[b+M]=a.b,U[A+M]=B}}if(A&P){let A=x;const H=x+a*(b-e);for(;A<=H;A+=r){const b=A+C;let a;a=y?D(U[A+M],U[b+M]):u(U[A+M],U[b+M]),B=a.a,U[b+M]=a.b,U[A+M]=B}}e=P,P>>=1}return x}function UU(U){return new DataView(U.array.buffer,U.offset.value,U.size)}function MU(U){const M=U.viewer.buffer.slice(U.offset.value,U.offset.value+U.size),b=new Uint8Array(function(U){let M=U.byteLength;const b=[];let a=0;const A=new DataView(U);for(;M>0;){const U=A.getInt8(a++);if(U<0){const H=-U;M-=H+1;for(let U=0;U<H;U++)b.push(A.getUint8(a++))}else{const H=U;M-=2;const W=A.getUint8(a++);for(let U=0;U<H+1;U++)b.push(W)}}return b}(M)),a=new Uint8Array(b.length);return Q(b),I(b,a),new DataView(a.buffer)}function bU(U){const M=U.array.slice(U.offset.value,U.offset.value+U.size),b=fflate.unzlibSync(M),a=new Uint8Array(b.length);return Q(b),I(b,a),new DataView(a.buffer)}function aU(U){const M=U.array.slice(U.offset.value,U.offset.value+U.size),b=fflate.unzlibSync(M),a=U.lines*U.channels*U.width,A=1==U.type?new Uint16Array(a):new Uint32Array(a);let H=0,W=0;const y=new Array(4);for(let O=0;O<U.lines;O++)for(let M=0;M<U.channels;M++){let M=0;switch(U.type){case 1:y[0]=H,y[1]=y[0]+U.width,H=y[1]+U.width;for(let a=0;a<U.width;++a){M+=b[y[0]++]<<8|b[y[1]++],A[W]=M,W++}break;case 2:y[0]=H,y[1]=y[0]+U.width,y[2]=y[1]+U.width,H=y[2]+U.width;for(let a=0;a<U.width;++a){M+=b[y[0]++]<<24|b[y[1]++]<<16|b[y[2]++]<<8,A[W]=M,W++}}}return new DataView(A.buffer)}function AU(U){const M=U.viewer,b={value:U.offset.value},a=new Uint16Array(U.width*U.scanlineBlockSize*(U.channels*U.type)),A=new Uint8Array(P);let H=0;const W=new Array(U.channels);for(let O=0;O<U.channels;O++)W[O]={},W[O].start=H,W[O].end=W[O].start,W[O].nx=U.width,W[O].ny=U.lines,W[O].size=U.type,H+=W[O].nx*W[O].ny*W[O].size;const y=d(M,b),e=d(M,b);if(e>=P)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(y<=e)for(let O=0;O<e-y+1;O++)A[O+y]=Y(M,b);const Z=new Uint16Array(x),C=function(U,M){let b=0;for(let A=0;A<x;++A)(0==A||U[A>>3]&1<<(7&A))&&(M[b++]=A);const a=b-1;for(;b<x;)M[b++]=0;return a}(A,Z),r=i(M,b);T(U.array,M,b,r,a,H);for(let O=0;O<U.channels;++O){const U=W[O];for(let M=0;M<W[O].size;++M)c(a,U.start+M,U.nx,U.size,U.ny,U.nx*U.size,C)}!function(U,M,b){for(let a=0;a<b;++a)M[a]=U[M[a]]}(Z,a,H);let B=0;const J=new Uint8Array(a.buffer.byteLength);for(let x=0;x<U.lines;x++)for(let M=0;M<U.channels;M++){const U=W[M],b=U.nx*U.size,A=new Uint8Array(a.buffer,U.end*O,b*O);J.set(A,B),B+=b*O,U.end+=b}return new DataView(J.buffer)}var HU,WU=b(479);!function(U){U[U.Float=0]="Float",U[U.HalfFloat=1]="HalfFloat"}(HU||(HU={}));class yU{}async function OU(U,M,b,a){const A={size:0,viewer:M,array:new Uint8Array(M.buffer),offset:b,width:U.dataWindow.xMax-U.dataWindow.xMin+1,height:U.dataWindow.yMax-U.dataWindow.yMin+1,channels:U.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(U.compression){case L.NO_COMPRESSION:A.lines=1,A.uncompress=UU;break;case L.RLE_COMPRESSION:A.lines=1,A.uncompress=MU;break;case L.ZIPS_COMPRESSION:A.lines=1,A.uncompress=bU,await WU.d.LoadScriptAsync(yU.FFLATEUrl);break;case L.ZIP_COMPRESSION:A.lines=16,A.uncompress=bU,await WU.d.LoadScriptAsync(yU.FFLATEUrl);break;case L.PIZ_COMPRESSION:A.lines=32,A.uncompress=AU;break;case L.PXR24_COMPRESSION:A.lines=16,A.uncompress=aU,await WU.d.LoadScriptAsync(yU.FFLATEUrl);break;default:throw new Error(L[U.compression]+" is unsupported")}A.scanlineBlockSize=A.lines;const H={};for(const W of U.channels)switch(W.name){case"R":case"G":case"B":case"A":case"Y":H[W.name]=!0,A.type=W.pixelType}let y=!1;if(H.R&&H.G&&H.B&&H.A)A.outputChannels=4,A.decodeChannels={R:0,G:1,B:2,A:3};else if(H.R&&H.G&&H.B)y=!0,A.outputChannels=4,A.decodeChannels={R:0,G:1,B:2,A:3};else if(H.R&&H.G)A.outputChannels=2,A.decodeChannels={R:0,G:1};else if(H.R)A.outputChannels=1,A.decodeChannels={R:0};else{if(!H.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");A.outputChannels=1,A.decodeChannels={Y:0}}if(1===A.type)switch(a){case HU.Float:A.getter=n,A.inputSize=O;break;case HU.HalfFloat:A.getter=d,A.inputSize=O}else{if(2!==A.type)throw new Error("Unsupported pixelType "+A.type+" for "+U.compression);switch(a){case HU.Float:A.getter=m,A.inputSize=W;break;case HU.HalfFloat:A.getter=E,A.inputSize=W}}A.blockCount=A.height/A.scanlineBlockSize;for(let W=0;W<A.blockCount;W++)q(M,b);const e=A.width*A.height*A.outputChannels;switch(a){case HU.Float:A.byteArray=new Float32Array(e),A.textureType=1,y&&A.byteArray.fill(1,0,e);break;case HU.HalfFloat:A.byteArray=new Uint16Array(e),A.textureType=2,y&&A.byteArray.fill(15360,0,e);break;default:throw new Error("Unsupported type: "+a)}let x=0;for(const W of U.channels)void 0!==A.decodeChannels[W.name]&&(A.channelLineOffsets[W.name]=x*A.width),x+=2*W.pixelType;return A.bytesPerLine=A.width*x,A.outLineWidth=A.width*A.outputChannels,"INCREASING_Y"===U.lineOrder?A.scanOrder=U=>U:A.scanOrder=U=>A.height-1-U,4==A.outputChannels?(A.format=5,A.linearSpace=!0):(A.format=6,A.linearSpace=!1),A}function eU(U,M,b,a){const A={value:0};for(let H=0;H<U.height/U.scanlineBlockSize;H++){const W=h(b,a)-M.dataWindow.yMin;U.size=i(b,a),U.lines=W+U.scanlineBlockSize>U.height?U.height-W:U.scanlineBlockSize;const y=U.size<U.lines*U.bytesPerLine&&U.uncompress?U.uncompress(U):UU(U);a.value+=U.size;for(let b=0;b<U.scanlineBlockSize;b++){const a=H*U.scanlineBlockSize,W=b+U.scanOrder(a);if(W>=U.height)continue;const O=b*U.bytesPerLine,e=(U.height-1-W)*U.outLineWidth;for(let b=0;b<U.channels;b++){const a=M.channels[b].name,H=U.channelLineOffsets[a],W=U.decodeChannels[a];if(void 0!==W){A.value=O+H;for(let M=0;M<U.width;M++){const b=e+M*U.outputChannels+W;U.byteArray&&(U.byteArray[b]=U.getter(y,A))}}}}}}yU.DefaultOutputType=HU.HalfFloat,yU.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class xU{constructor(){this.supportCascades=!1}loadCubeData(U,M,b,a,A){throw".exr not supported in Cube."}loadData(U,M,b){const A=new DataView(U.buffer),H={value:0},W=t(A,H);OU(W,A,H,yU.DefaultOutputType).then((U=>{eU(U,W,A,H);const a=W.dataWindow.xMax-W.dataWindow.xMin+1,y=W.dataWindow.yMax-W.dataWindow.yMin+1;b(a,y,M.generateMipMaps,!1,(()=>{const b=M.getEngine();M.format=W.format,M.type=U.textureType,M.invertY=!1,M._gammaSpace=!W.linearSpace,U.byteArray&&b._uploadDataToTextureDirectly(M,U.byteArray,0,0,void 0,!0)}))})).catch((U=>{a.b.Error("Failed to load EXR texture: ",U)}))}}async function PU(U){const M=new DataView(U),b={value:0},A=t(M,b);try{const U=await OU(A,M,b,HU.Float);return eU(U,A,M,b),U.byteArray?{width:A.dataWindow.xMax-A.dataWindow.xMin+1,height:A.dataWindow.yMax-A.dataWindow.yMin+1,data:new Float32Array(U.byteArray)}:(a.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(H){a.b.Error("Failed to load EXR data: ",H)}return{width:0,height:0,data:null}}}}]);