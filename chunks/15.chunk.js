"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{2586:(W,F,c)=>{c.r(F),c.d(F,{ReadExrDataAsync:()=>jW,_ExrTextureLoader:()=>xW});var T=c(520),Y=c(712);const Z=4,w=4,A=1,u=2,s=8,x=65536,j=x>>3,N=14,q=65537,y=1<<N,i=y-1,e=59,I=63,E=2+I-e;var O,z;!function(W){W[W.NO_COMPRESSION=0]="NO_COMPRESSION",W[W.RLE_COMPRESSION=1]="RLE_COMPRESSION",W[W.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",W[W.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",W[W.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",W[W.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(O||(O={})),function(W){W[W.INCREASING_Y=0]="INCREASING_Y",W[W.DECREASING_Y=1]="DECREASING_Y"}(z||(z={}));const G=function(){const W=new ArrayBuffer(4),F=new Float32Array(W),c=new Uint32Array(W),T=new Uint32Array(512),Y=new Uint32Array(512);for(let u=0;u<256;++u){const W=u-127;W<-27?(T[u]=0,T[256|u]=32768,Y[u]=24,Y[256|u]=24):W<-14?(T[u]=1024>>-W-14,T[256|u]=1024>>-W-14|32768,Y[u]=-W-1,Y[256|u]=-W-1):W<=15?(T[u]=W+15<<10,T[256|u]=W+15<<10|32768,Y[u]=13,Y[256|u]=13):W<128?(T[u]=31744,T[256|u]=64512,Y[u]=24,Y[256|u]=24):(T[u]=31744,T[256|u]=64512,Y[u]=13,Y[256|u]=13)}const Z=new Uint32Array(2048),w=new Uint32Array(64),A=new Uint32Array(64);for(let u=1;u<1024;++u){let W=u<<13,F=0;for(;0===(8388608&W);)W<<=1,F-=8388608;W&=-8388609,F+=947912704,Z[u]=W|F}for(let u=1024;u<2048;++u)Z[u]=939524096+(u-1024<<13);for(let u=1;u<31;++u)w[u]=u<<23;w[31]=1199570944,w[32]=2147483648;for(let u=33;u<63;++u)w[u]=2147483648+(u-32<<23);w[63]=3347054592;for(let u=1;u<64;++u)32!==u&&(A[u]=1024);return{floatView:F,uint32View:c,baseTable:T,shiftTable:Y,mantissaTable:Z,exponentTable:w,offsetTable:A}}();function D(W,F){const c=new Uint8Array(W);let T=0;for(;0!=c[F.value+T];)T+=1;const Y=(new TextDecoder).decode(c.slice(F.value,F.value+T));return F.value=F.value+T+1,Y}function v(W,F){const c=W.getInt32(F.value,!0);return F.value+=Z,c}function C(W,F){const c=W.getUint32(F.value,!0);return F.value+=Z,c}function n(W,F){const c=W.getUint8(F.value);return F.value+=A,c}function X(W,F){const c=W.getUint16(F.value,!0);return F.value+=u,c}function g(W,F){const c=W[F.value];return F.value+=A,c}function S(W,F){let c;return c="getBigInt64"in DataView.prototype?Number(W.getBigInt64(F.value,!0)):W.getUint32(F.value+4,!0)+Number(W.getUint32(F.value,!0)<<32),F.value+=s,c}function U(W,F){const c=W.getFloat32(F.value,!0);return F.value+=w,c}function o(W,F){return function(W){const F=(31744&W)>>10,c=1023&W;return(W>>15?-1:1)*(F?31===F?c?NaN:1/0:Math.pow(2,F-15)*(1+c/1024):c/1024*6103515625e-14)}(X(W,F))}function K(W,F){return function(W){if(Math.abs(W)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");W=(0,Y.c)(W,-65504,65504),G.floatView[0]=W;const F=G.uint32View[0],c=F>>23&511;return G.baseTable[c]+((8388607&F)>>G.shiftTable[c])}(U(W,F))}function V(W,F,c,T){switch(c){case"string":case"stringvector":case"iccProfile":return function(W,F,c){const T=(new TextDecoder).decode(new Uint8Array(W).slice(F.value,F.value+c));return F.value=F.value+c,T}(W.buffer,F,T);case"chlist":return function(W,F,c){const T=F.value,Y=[];for(;F.value<T+c-1;){const c=D(W.buffer,F),T=v(W,F),Z=n(W,F);F.value+=3;const w=v(W,F),A=v(W,F);Y.push({name:c,pixelType:T,pLinear:Z,xSampling:w,ySampling:A})}return F.value+=1,Y}(W,F,T);case"chromaticities":return function(W,F){return{redX:U(W,F),redY:U(W,F),greenX:U(W,F),greenY:U(W,F),blueX:U(W,F),blueY:U(W,F),whiteX:U(W,F),whiteY:U(W,F)}}(W,F);case"compression":return function(W,F){return n(W,F)}(W,F);case"box2i":return function(W,F){return{xMin:v(W,F),yMin:v(W,F),xMax:v(W,F),yMax:v(W,F)}}(W,F);case"lineOrder":return function(W,F){const c=n(W,F);return z[c]}(W,F);case"float":return U(W,F);case"v2f":return function(W,F){return[U(W,F),U(W,F)]}(W,F);case"v3f":return function(W,F){return[U(W,F),U(W,F),U(W,F)]}(W,F);case"int":return v(W,F);case"rational":return function(W,F){return[v(W,F),C(W,F)]}(W,F);case"timecode":return function(W,F){return[C(W,F),C(W,F)]}(W,F);case"preview":return F.value+=T,"skipped";default:return void(F.value+=T)}}function d(W){for(let F=1;F<W.length;F++){const c=W[F-1]+W[F]-128;W[F]=c}}function L(W,F){let c=0,T=Math.floor((W.length+1)/2),Y=0;const Z=W.length-1;for(;!(Y>Z)&&(F[Y++]=W[c++],!(Y>Z));)F[Y++]=W[T++]}const H=20000630;function k(W,F){if(W.getUint32(0,!0)!=H)throw new Error("Incorrect OpenEXR format");const c=W.getUint8(4),Y=W.getUint8(5),Z={singleTile:!!(2&Y),longName:!!(4&Y),deepFormat:!!(8&Y),multiPart:!!(16&Y)};F.value=8;const w={};let A=!0;for(;A;){const c=D(W.buffer,F);if(c){const Y=D(W.buffer,F),Z=V(W,F,Y,C(W,F));void 0===Z?T.e.Warn(`Unknown header attribute type ${Y}'.`):w[c]=Z}else A=!1}if(0!=(-5&Y))throw new Error("Unsupported file format");return{version:c,spec:Z,...w}}const m=32768,r=65535;function b(W,F,c,T,Y){for(;c<W;)F=F<<8|g(T,Y),c+=8;return{l:F>>(c-=W)&(1<<W)-1,c:F,lc:c}}function R(W,F,c,T){return{c:W=W<<8|g(c,T),lc:F+=8}}function f(W,F,c,T,Y,Z,w,A,u){if(W==F){if(T<8){const W=R(c,T,Y,Z);c=W.c,T=W.lc}let W=c>>(T-=8);if(W=new Uint8Array([W])[0],A.value+W>u)return null;const F=w[A.value-1];for(;W-- >0;)w[A.value++]=F}else{if(!(A.value<u))return null;w[A.value++]=W}return{c:c,lc:T}}const P=new Array(59);function p(W,F,c,T,Y,Z){const w=F;let A=0,u=0;for(;T<=Y;T++){if(w.value-F.value>c)return;let s=b(6,A,u,W,w);const x=s.l;if(A=s.c,u=s.lc,Z[T]=x,x==I){if(w.value-F.value>c)throw new Error("Error in HufUnpackEncTable");s=b(8,A,u,W,w);let x=s.l+E;if(A=s.c,u=s.lc,T+x>Y+1)throw new Error("Error in HufUnpackEncTable");for(;x--;)Z[T++]=0;T--}else if(x>=e){let W=x-e+2;if(T+W>Y+1)throw new Error("Error in HufUnpackEncTable");for(;W--;)Z[T++]=0;T--}}!function(W){for(let c=0;c<=58;++c)P[c]=0;for(let c=0;c<q;++c)P[W[c]]+=1;let F=0;for(let c=58;c>0;--c){const W=F+P[c]>>1;P[c]=F,F=W}for(let c=0;c<q;++c){const F=W[c];F>0&&(W[c]=F|P[F]++<<6)}}(Z)}function t(W){return 63&W}function M(W){return W>>6}function Q(W,F,c,T,Y,Z){const w=c.value,A=C(F,c),u=C(F,c);c.value+=4;const s=C(F,c);if(c.value+=4,A<0||A>=q||u<0||u>=q)throw new Error("Wrong HUF_ENCSIZE");const x=new Array(q),j=new Array(y);!function(W){for(let F=0;F<y;F++)W[F]={},W[F].len=0,W[F].lit=0,W[F].p=null}(j);if(p(W,c,T-(c.value-w),A,u,x),s>8*(T-(c.value-w)))throw new Error("Wrong hufUncompress");!function(W,F,c,T){for(;F<=c;F++){const c=M(W[F]),Y=t(W[F]);if(c>>Y)throw new Error("Invalid table entry");if(Y>N){const W=T[c>>Y-N];if(W.len)throw new Error("Invalid table entry");if(W.lit++,W.p){const F=W.p;W.p=new Array(W.lit);for(let c=0;c<W.lit-1;++c)W.p[c]=F[c]}else W.p=new Array(1);W.p[W.lit-1]=F}else if(Y){let W=0;for(let Z=1<<N-Y;Z>0;Z--){const Z=T[(c<<N-Y)+W];if(Z.len||Z.p)throw new Error("Invalid table entry");Z.len=Y,Z.lit=F,W++}}}}(x,A,u,j),function(W,F,c,T,Y,Z,w,A,u){let s=0,x=0;const j=w,q=Math.trunc(T.value+(Y+7)/8);for(;T.value<q;){let Y=R(s,x,c,T);for(s=Y.c,x=Y.lc;x>=N;){const w=F[s>>x-N&i];if(w.len){x-=w.len;const W=f(w.lit,Z,s,x,c,T,A,u,j);W&&(s=W.c,x=W.lc)}else{if(!w.p)throw new Error("hufDecode issues");let F;for(F=0;F<w.lit;F++){const N=t(W[w.p[F]]);for(;x<N&&T.value<q;)Y=R(s,x,c,T),s=Y.c,x=Y.lc;if(x>=N&&M(W[w.p[F]])==(s>>x-N&(1<<N)-1)){x-=N;const W=f(w.p[F],Z,s,x,c,T,A,u,j);W&&(s=W.c,x=W.lc);break}}if(F==w.lit)throw new Error("HufDecode issues")}}}const y=8-Y&7;for(s>>=y,x-=y;x>0;){const W=F[s<<N-x&i];if(!W.len)throw new Error("HufDecode issues");{x-=W.len;const F=f(W.lit,Z,s,x,c,T,A,u,j);F&&(s=F.c,x=F.lc)}}}(x,j,W,c,s,u,Z,Y,{value:0})}function J(W){return 65535&W}function B(W){const F=J(W);return F>32767?F-65536:F}function a(W,F){const c=B(W),T=B(F),Y=c+(1&T)+(T>>1);return{a:Y,b:Y-T}}function l(W,F){const c=J(W),T=J(F),Y=c-(T>>1)&r;return{a:T+Y-m&r,b:Y}}function h(W,F,c,T,Y,Z,w){const A=w<16384,u=c>Y?Y:c;let s,x,j=1;for(;j<=u;)j<<=1;for(j>>=1,s=j,j>>=1;j>=1;){x=0;const w=x+Z*(Y-s),u=Z*j,N=Z*s,q=T*j,y=T*s;let i,e,I,E;for(;x<=w;x+=N){let Y=x;const Z=x+T*(c-s);for(;Y<=Z;Y+=y){const c=Y+q,T=Y+u,Z=T+q;if(A){let w=a(W[Y+F],W[T+F]);i=w.a,I=w.b,w=a(W[c+F],W[Z+F]),e=w.a,E=w.b,w=a(i,e),W[Y+F]=w.a,W[c+F]=w.b,w=a(I,E),W[T+F]=w.a,W[Z+F]=w.b}else{let w=l(W[Y+F],W[T+F]);i=w.a,I=w.b,w=l(W[c+F],W[Z+F]),e=w.a,E=w.b,w=l(i,e),W[Y+F]=w.a,W[c+F]=w.b,w=l(I,E),W[T+F]=w.a,W[Z+F]=w.b}}if(c&j){const c=Y+u;let T;T=A?a(W[Y+F],W[c+F]):l(W[Y+F],W[c+F]),i=T.a,W[c+F]=T.b,W[Y+F]=i}}if(Y&j){let Y=x;const Z=x+T*(c-s);for(;Y<=Z;Y+=y){const c=Y+q;let T;T=A?a(W[Y+F],W[c+F]):l(W[Y+F],W[c+F]),i=T.a,W[c+F]=T.b,W[Y+F]=i}}s=j,j>>=1}return x}function WW(W){return new DataView(W.array.buffer,W.offset.value,W.size)}function FW(W){const F=W.viewer.buffer.slice(W.offset.value,W.offset.value+W.size),c=new Uint8Array(function(W){let F=W.byteLength;const c=[];let T=0;const Y=new DataView(W);for(;F>0;){const W=Y.getInt8(T++);if(W<0){const Z=-W;F-=Z+1;for(let W=0;W<Z;W++)c.push(Y.getUint8(T++))}else{const Z=W;F-=2;const w=Y.getUint8(T++);for(let W=0;W<Z+1;W++)c.push(w)}}return c}(F)),T=new Uint8Array(c.length);return d(c),L(c,T),new DataView(T.buffer)}function cW(W){const F=W.array.slice(W.offset.value,W.offset.value+W.size),c=fflate.unzlibSync(F),T=new Uint8Array(c.length);return d(c),L(c,T),new DataView(T.buffer)}function TW(W){const F=W.array.slice(W.offset.value,W.offset.value+W.size),c=fflate.unzlibSync(F),T=W.lines*W.channels*W.width,Y=1==W.type?new Uint16Array(T):new Uint32Array(T);let Z=0,w=0;const A=new Array(4);for(let u=0;u<W.lines;u++)for(let F=0;F<W.channels;F++){let F=0;switch(W.type){case 1:A[0]=Z,A[1]=A[0]+W.width,Z=A[1]+W.width;for(let T=0;T<W.width;++T){F+=c[A[0]++]<<8|c[A[1]++],Y[w]=F,w++}break;case 2:A[0]=Z,A[1]=A[0]+W.width,A[2]=A[1]+W.width,Z=A[2]+W.width;for(let T=0;T<W.width;++T){F+=c[A[0]++]<<24|c[A[1]++]<<16|c[A[2]++]<<8,Y[w]=F,w++}}}return new DataView(Y.buffer)}function YW(W){const F=W.viewer,c={value:W.offset.value},T=new Uint16Array(W.width*W.scanlineBlockSize*(W.channels*W.type)),Y=new Uint8Array(j);let Z=0;const w=new Array(W.channels);for(let u=0;u<W.channels;u++)w[u]={},w[u].start=Z,w[u].end=w[u].start,w[u].nx=W.width,w[u].ny=W.lines,w[u].size=W.type,Z+=w[u].nx*w[u].ny*w[u].size;const A=X(F,c),s=X(F,c);if(s>=j)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(A<=s)for(let u=0;u<s-A+1;u++)Y[u+A]=n(F,c);const N=new Uint16Array(x),q=function(W,F){let c=0;for(let Y=0;Y<x;++Y)(0==Y||W[Y>>3]&1<<(7&Y))&&(F[c++]=Y);const T=c-1;for(;c<x;)F[c++]=0;return T}(Y,N),y=C(F,c);Q(W.array,F,c,y,T,Z);for(let u=0;u<W.channels;++u){const W=w[u];for(let F=0;F<w[u].size;++F)h(T,W.start+F,W.nx,W.size,W.ny,W.nx*W.size,q)}!function(W,F,c){for(let T=0;T<c;++T)F[T]=W[F[T]]}(N,T,Z);let i=0;const e=new Uint8Array(T.buffer.byteLength);for(let x=0;x<W.lines;x++)for(let F=0;F<W.channels;F++){const W=w[F],c=W.nx*W.size,Y=new Uint8Array(T.buffer,W.end*u,c*u);e.set(Y,i),i+=c*u,W.end+=c}return new DataView(e.buffer)}var ZW,wW=c(514);!function(W){W[W.Float=0]="Float",W[W.HalfFloat=1]="HalfFloat"}(ZW||(ZW={}));class AW{}async function uW(W,F,c,T){const Y={size:0,viewer:F,array:new Uint8Array(F.buffer),offset:c,width:W.dataWindow.xMax-W.dataWindow.xMin+1,height:W.dataWindow.yMax-W.dataWindow.yMin+1,channels:W.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(W.compression){case O.NO_COMPRESSION:Y.lines=1,Y.uncompress=WW;break;case O.RLE_COMPRESSION:Y.lines=1,Y.uncompress=FW;break;case O.ZIPS_COMPRESSION:Y.lines=1,Y.uncompress=cW,await wW.d.LoadScriptAsync(AW.FFLATEUrl);break;case O.ZIP_COMPRESSION:Y.lines=16,Y.uncompress=cW,await wW.d.LoadScriptAsync(AW.FFLATEUrl);break;case O.PIZ_COMPRESSION:Y.lines=32,Y.uncompress=YW;break;case O.PXR24_COMPRESSION:Y.lines=16,Y.uncompress=TW,await wW.d.LoadScriptAsync(AW.FFLATEUrl);break;default:throw new Error(O[W.compression]+" is unsupported")}Y.scanlineBlockSize=Y.lines;const Z={};for(const w of W.channels)switch(w.name){case"R":case"G":case"B":case"A":case"Y":Z[w.name]=!0,Y.type=w.pixelType}let A=!1;if(Z.R&&Z.G&&Z.B&&Z.A)Y.outputChannels=4,Y.decodeChannels={R:0,G:1,B:2,A:3};else if(Z.R&&Z.G&&Z.B)A=!0,Y.outputChannels=4,Y.decodeChannels={R:0,G:1,B:2,A:3};else if(Z.R&&Z.G)Y.outputChannels=2,Y.decodeChannels={R:0,G:1};else if(Z.R)Y.outputChannels=1,Y.decodeChannels={R:0};else{if(!Z.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");Y.outputChannels=1,Y.decodeChannels={Y:0}}if(1===Y.type)switch(T){case ZW.Float:Y.getter=o,Y.inputSize=u;break;case ZW.HalfFloat:Y.getter=X,Y.inputSize=u}else{if(2!==Y.type)throw new Error("Unsupported pixelType "+Y.type+" for "+W.compression);switch(T){case ZW.Float:Y.getter=U,Y.inputSize=w;break;case ZW.HalfFloat:Y.getter=K,Y.inputSize=w}}Y.blockCount=Y.height/Y.scanlineBlockSize;for(let w=0;w<Y.blockCount;w++)S(F,c);const s=Y.width*Y.height*Y.outputChannels;switch(T){case ZW.Float:Y.byteArray=new Float32Array(s),Y.textureType=1,A&&Y.byteArray.fill(1,0,s);break;case ZW.HalfFloat:Y.byteArray=new Uint16Array(s),Y.textureType=2,A&&Y.byteArray.fill(15360,0,s);break;default:throw new Error("Unsupported type: "+T)}let x=0;for(const w of W.channels)void 0!==Y.decodeChannels[w.name]&&(Y.channelLineOffsets[w.name]=x*Y.width),x+=2*w.pixelType;return Y.bytesPerLine=Y.width*x,Y.outLineWidth=Y.width*Y.outputChannels,"INCREASING_Y"===W.lineOrder?Y.scanOrder=W=>W:Y.scanOrder=W=>Y.height-1-W,4==Y.outputChannels?(Y.format=5,Y.linearSpace=!0):(Y.format=6,Y.linearSpace=!1),Y}function sW(W,F,c,T){const Y={value:0};for(let Z=0;Z<W.height/W.scanlineBlockSize;Z++){const w=v(c,T)-F.dataWindow.yMin;W.size=C(c,T),W.lines=w+W.scanlineBlockSize>W.height?W.height-w:W.scanlineBlockSize;const A=W.size<W.lines*W.bytesPerLine&&W.uncompress?W.uncompress(W):WW(W);T.value+=W.size;for(let c=0;c<W.scanlineBlockSize;c++){const T=Z*W.scanlineBlockSize,w=c+W.scanOrder(T);if(w>=W.height)continue;const u=c*W.bytesPerLine,s=(W.height-1-w)*W.outLineWidth;for(let c=0;c<W.channels;c++){const T=F.channels[c].name,Z=W.channelLineOffsets[T],w=W.decodeChannels[T];if(void 0!==w){Y.value=u+Z;for(let F=0;F<W.width;F++){const c=s+F*W.outputChannels+w;W.byteArray&&(W.byteArray[c]=W.getter(A,Y))}}}}}}AW.DefaultOutputType=ZW.HalfFloat,AW.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class xW{constructor(){this.supportCascades=!1}loadCubeData(W,F,c,T,Y){throw".exr not supported in Cube."}loadData(W,F,c){const Y=new DataView(W.buffer),Z={value:0},w=k(Y,Z);uW(w,Y,Z,AW.DefaultOutputType).then((W=>{sW(W,w,Y,Z);const T=w.dataWindow.xMax-w.dataWindow.xMin+1,A=w.dataWindow.yMax-w.dataWindow.yMin+1;c(T,A,F.generateMipMaps,!1,(()=>{const c=F.getEngine();F.format=w.format,F.type=W.textureType,F.invertY=!1,F._gammaSpace=!w.linearSpace,W.byteArray&&c._uploadDataToTextureDirectly(F,W.byteArray,0,0,void 0,!0)}))})).catch((W=>{T.e.Error("Failed to load EXR texture: ",W)}))}}async function jW(W){const F=new DataView(W),c={value:0},Y=k(F,c);try{const W=await uW(Y,F,c,ZW.Float);return sW(W,Y,F,c),W.byteArray?{width:Y.dataWindow.xMax-Y.dataWindow.xMin+1,height:Y.dataWindow.yMax-Y.dataWindow.yMin+1,data:new Float32Array(W.byteArray)}:(T.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(Z){T.e.Error("Failed to load EXR data: ",Z)}return{width:0,height:0,data:null}}}}]);