"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{2520:(A,X,s)=>{s.r(X),s.d(X,{ReadExrDataAsync:()=>vA,_ExrTextureLoader:()=>YA});var N=s(470),f=s(696);const E=4,g=4,K=1,r=2,i=8,Y=65536,v=Y>>3,c=14,M=65537,d=1<<c,Q=d-1,w=59,R=63,C=2+R-w;var J,a;!function(A){A[A.NO_COMPRESSION=0]="NO_COMPRESSION",A[A.RLE_COMPRESSION=1]="RLE_COMPRESSION",A[A.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",A[A.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",A[A.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",A[A.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(J||(J={})),function(A){A[A.INCREASING_Y=0]="INCREASING_Y",A[A.DECREASING_Y=1]="DECREASING_Y"}(a||(a={}));const u=function(){const A=new ArrayBuffer(4),X=new Float32Array(A),s=new Uint32Array(A),N=new Uint32Array(512),f=new Uint32Array(512);for(let r=0;r<256;++r){const A=r-127;A<-27?(N[r]=0,N[256|r]=32768,f[r]=24,f[256|r]=24):A<-14?(N[r]=1024>>-A-14,N[256|r]=1024>>-A-14|32768,f[r]=-A-1,f[256|r]=-A-1):A<=15?(N[r]=A+15<<10,N[256|r]=A+15<<10|32768,f[r]=13,f[256|r]=13):A<128?(N[r]=31744,N[256|r]=64512,f[r]=24,f[256|r]=24):(N[r]=31744,N[256|r]=64512,f[r]=13,f[256|r]=13)}const E=new Uint32Array(2048),g=new Uint32Array(64),K=new Uint32Array(64);for(let r=1;r<1024;++r){let A=r<<13,X=0;for(;0===(8388608&A);)A<<=1,X-=8388608;A&=-8388609,X+=947912704,E[r]=A|X}for(let r=1024;r<2048;++r)E[r]=939524096+(r-1024<<13);for(let r=1;r<31;++r)g[r]=r<<23;g[31]=1199570944,g[32]=2147483648;for(let r=33;r<63;++r)g[r]=2147483648+(r-32<<23);g[63]=3347054592;for(let r=1;r<64;++r)32!==r&&(K[r]=1024);return{floatView:X,uint32View:s,baseTable:N,shiftTable:f,mantissaTable:E,exponentTable:g,offsetTable:K}}();function z(A,X){const s=new Uint8Array(A);let N=0;for(;0!=s[X.value+N];)N+=1;const f=(new TextDecoder).decode(s.slice(X.value,X.value+N));return X.value=X.value+N+1,f}function m(A,X){const s=A.getInt32(X.value,!0);return X.value+=E,s}function b(A,X){const s=A.getUint32(X.value,!0);return X.value+=E,s}function y(A,X){const s=A.getUint8(X.value);return X.value+=K,s}function j(A,X){const s=A.getUint16(X.value,!0);return X.value+=r,s}function G(A,X){const s=A[X.value];return X.value+=K,s}function V(A,X){let s;return s="getBigInt64"in DataView.prototype?Number(A.getBigInt64(X.value,!0)):A.getUint32(X.value+4,!0)+Number(A.getUint32(X.value,!0)<<32),X.value+=i,s}function D(A,X){const s=A.getFloat32(X.value,!0);return X.value+=g,s}function O(A,X){return function(A){const X=(31744&A)>>10,s=1023&A;return(A>>15?-1:1)*(X?31===X?s?NaN:1/0:Math.pow(2,X-15)*(1+s/1024):s/1024*6103515625e-14)}(j(A,X))}function P(A,X){return function(A){if(Math.abs(A)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");A=(0,f.c)(A,-65504,65504),u.floatView[0]=A;const X=u.uint32View[0],s=X>>23&511;return u.baseTable[s]+((8388607&X)>>u.shiftTable[s])}(D(A,X))}function l(A,X,s,N){switch(s){case"string":case"stringvector":case"iccProfile":return function(A,X,s){const N=(new TextDecoder).decode(new Uint8Array(A).slice(X.value,X.value+s));return X.value=X.value+s,N}(A.buffer,X,N);case"chlist":return function(A,X,s){const N=X.value,f=[];for(;X.value<N+s-1;){const s=z(A.buffer,X),N=m(A,X),E=y(A,X);X.value+=3;const g=m(A,X),K=m(A,X);f.push({name:s,pixelType:N,pLinear:E,xSampling:g,ySampling:K})}return X.value+=1,f}(A,X,N);case"chromaticities":return function(A,X){return{redX:D(A,X),redY:D(A,X),greenX:D(A,X),greenY:D(A,X),blueX:D(A,X),blueY:D(A,X),whiteX:D(A,X),whiteY:D(A,X)}}(A,X);case"compression":return function(A,X){return y(A,X)}(A,X);case"box2i":return function(A,X){return{xMin:m(A,X),yMin:m(A,X),xMax:m(A,X),yMax:m(A,X)}}(A,X);case"lineOrder":return function(A,X){const s=y(A,X);return a[s]}(A,X);case"float":return D(A,X);case"v2f":return function(A,X){return[D(A,X),D(A,X)]}(A,X);case"v3f":return function(A,X){return[D(A,X),D(A,X),D(A,X)]}(A,X);case"int":return m(A,X);case"rational":return function(A,X){return[m(A,X),b(A,X)]}(A,X);case"timecode":return function(A,X){return[b(A,X),b(A,X)]}(A,X);case"preview":return X.value+=N,"skipped";default:return void(X.value+=N)}}function n(A){for(let X=1;X<A.length;X++){const s=A[X-1]+A[X]-128;A[X]=s}}function U(A,X){let s=0,N=Math.floor((A.length+1)/2),f=0;const E=A.length-1;for(;!(f>E)&&(X[f++]=A[s++],!(f>E));)X[f++]=A[N++]}const t=20000630;function e(A,X){if(A.getUint32(0,!0)!=t)throw new Error("Incorrect OpenEXR format");const s=A.getUint8(4),f=A.getUint8(5),E={singleTile:!!(2&f),longName:!!(4&f),deepFormat:!!(8&f),multiPart:!!(16&f)};X.value=8;const g={};let K=!0;for(;K;){const s=z(A.buffer,X);if(s){const f=z(A.buffer,X),E=l(A,X,f,b(A,X));void 0===E?N.b.Warn(`Unknown header attribute type ${f}'.`):g[s]=E}else K=!1}if(0!=(-5&f))throw new Error("Unsupported file format");return{version:s,spec:E,...g}}const T=32768,I=65535;function L(A,X,s,N,f){for(;s<A;)X=X<<8|G(N,f),s+=8;return{l:X>>(s-=A)&(1<<A)-1,c:X,lc:s}}function k(A,X,s,N){return{c:A=A<<8|G(s,N),lc:X+=8}}function x(A,X,s,N,f,E,g,K,r){if(A==X){if(N<8){const A=k(s,N,f,E);s=A.c,N=A.lc}let A=s>>(N-=8);if(A=new Uint8Array([A])[0],K.value+A>r)return null;const X=g[K.value-1];for(;A-- >0;)g[K.value++]=X}else{if(!(K.value<r))return null;g[K.value++]=A}return{c:s,lc:N}}const H=new Array(59);function F(A,X,s,N,f,E){const g=X;let K=0,r=0;for(;N<=f;N++){if(g.value-X.value>s)return;let i=L(6,K,r,A,g);const Y=i.l;if(K=i.c,r=i.lc,E[N]=Y,Y==R){if(g.value-X.value>s)throw new Error("Error in HufUnpackEncTable");i=L(8,K,r,A,g);let Y=i.l+C;if(K=i.c,r=i.lc,N+Y>f+1)throw new Error("Error in HufUnpackEncTable");for(;Y--;)E[N++]=0;N--}else if(Y>=w){let A=Y-w+2;if(N+A>f+1)throw new Error("Error in HufUnpackEncTable");for(;A--;)E[N++]=0;N--}}!function(A){for(let s=0;s<=58;++s)H[s]=0;for(let s=0;s<M;++s)H[A[s]]+=1;let X=0;for(let s=58;s>0;--s){const A=X+H[s]>>1;H[s]=X,X=A}for(let s=0;s<M;++s){const X=A[s];X>0&&(A[s]=X|H[X]++<<6)}}(E)}function q(A){return 63&A}function S(A){return A>>6}function p(A,X,s,N,f,E){const g=s.value,K=b(X,s),r=b(X,s);s.value+=4;const i=b(X,s);if(s.value+=4,K<0||K>=M||r<0||r>=M)throw new Error("Wrong HUF_ENCSIZE");const Y=new Array(M),v=new Array(d);!function(A){for(let X=0;X<d;X++)A[X]={},A[X].len=0,A[X].lit=0,A[X].p=null}(v);if(F(A,s,N-(s.value-g),K,r,Y),i>8*(N-(s.value-g)))throw new Error("Wrong hufUncompress");!function(A,X,s,N){for(;X<=s;X++){const s=S(A[X]),f=q(A[X]);if(s>>f)throw new Error("Invalid table entry");if(f>c){const A=N[s>>f-c];if(A.len)throw new Error("Invalid table entry");if(A.lit++,A.p){const X=A.p;A.p=new Array(A.lit);for(let s=0;s<A.lit-1;++s)A.p[s]=X[s]}else A.p=new Array(1);A.p[A.lit-1]=X}else if(f){let A=0;for(let E=1<<c-f;E>0;E--){const E=N[(s<<c-f)+A];if(E.len||E.p)throw new Error("Invalid table entry");E.len=f,E.lit=X,A++}}}}(Y,K,r,v),function(A,X,s,N,f,E,g,K,r){let i=0,Y=0;const v=g,M=Math.trunc(N.value+(f+7)/8);for(;N.value<M;){let f=k(i,Y,s,N);for(i=f.c,Y=f.lc;Y>=c;){const g=X[i>>Y-c&Q];if(g.len){Y-=g.len;const A=x(g.lit,E,i,Y,s,N,K,r,v);A&&(i=A.c,Y=A.lc)}else{if(!g.p)throw new Error("hufDecode issues");let X;for(X=0;X<g.lit;X++){const c=q(A[g.p[X]]);for(;Y<c&&N.value<M;)f=k(i,Y,s,N),i=f.c,Y=f.lc;if(Y>=c&&S(A[g.p[X]])==(i>>Y-c&(1<<c)-1)){Y-=c;const A=x(g.p[X],E,i,Y,s,N,K,r,v);A&&(i=A.c,Y=A.lc);break}}if(X==g.lit)throw new Error("HufDecode issues")}}}const d=8-f&7;for(i>>=d,Y-=d;Y>0;){const A=X[i<<c-Y&Q];if(!A.len)throw new Error("HufDecode issues");{Y-=A.len;const X=x(A.lit,E,i,Y,s,N,K,r,v);X&&(i=X.c,Y=X.lc)}}}(Y,v,A,s,i,r,E,f,{value:0})}function B(A){return 65535&A}function Z(A){const X=B(A);return X>32767?X-65536:X}function o(A,X){const s=Z(A),N=Z(X),f=s+(1&N)+(N>>1);return{a:f,b:f-N}}function W(A,X){const s=B(A),N=B(X),f=s-(N>>1)&I;return{a:N+f-T&I,b:f}}function h(A,X,s,N,f,E,g){const K=g<16384,r=s>f?f:s;let i,Y,v=1;for(;v<=r;)v<<=1;for(v>>=1,i=v,v>>=1;v>=1;){Y=0;const g=Y+E*(f-i),r=E*v,c=E*i,M=N*v,d=N*i;let Q,w,R,C;for(;Y<=g;Y+=c){let f=Y;const E=Y+N*(s-i);for(;f<=E;f+=d){const s=f+M,N=f+r,E=N+M;if(K){let g=o(A[f+X],A[N+X]);Q=g.a,R=g.b,g=o(A[s+X],A[E+X]),w=g.a,C=g.b,g=o(Q,w),A[f+X]=g.a,A[s+X]=g.b,g=o(R,C),A[N+X]=g.a,A[E+X]=g.b}else{let g=W(A[f+X],A[N+X]);Q=g.a,R=g.b,g=W(A[s+X],A[E+X]),w=g.a,C=g.b,g=W(Q,w),A[f+X]=g.a,A[s+X]=g.b,g=W(R,C),A[N+X]=g.a,A[E+X]=g.b}}if(s&v){const s=f+r;let N;N=K?o(A[f+X],A[s+X]):W(A[f+X],A[s+X]),Q=N.a,A[s+X]=N.b,A[f+X]=Q}}if(f&v){let f=Y;const E=Y+N*(s-i);for(;f<=E;f+=d){const s=f+M;let N;N=K?o(A[f+X],A[s+X]):W(A[f+X],A[s+X]),Q=N.a,A[s+X]=N.b,A[f+X]=Q}}i=v,v>>=1}return Y}function AA(A){return new DataView(A.array.buffer,A.offset.value,A.size)}function XA(A){const X=A.viewer.buffer.slice(A.offset.value,A.offset.value+A.size),s=new Uint8Array(function(A){let X=A.byteLength;const s=[];let N=0;const f=new DataView(A);for(;X>0;){const A=f.getInt8(N++);if(A<0){const E=-A;X-=E+1;for(let A=0;A<E;A++)s.push(f.getUint8(N++))}else{const E=A;X-=2;const g=f.getUint8(N++);for(let A=0;A<E+1;A++)s.push(g)}}return s}(X)),N=new Uint8Array(s.length);return n(s),U(s,N),new DataView(N.buffer)}function sA(A){const X=A.array.slice(A.offset.value,A.offset.value+A.size),s=fflate.unzlibSync(X),N=new Uint8Array(s.length);return n(s),U(s,N),new DataView(N.buffer)}function NA(A){const X=A.array.slice(A.offset.value,A.offset.value+A.size),s=fflate.unzlibSync(X),N=A.lines*A.channels*A.width,f=1==A.type?new Uint16Array(N):new Uint32Array(N);let E=0,g=0;const K=new Array(4);for(let r=0;r<A.lines;r++)for(let X=0;X<A.channels;X++){let X=0;switch(A.type){case 1:K[0]=E,K[1]=K[0]+A.width,E=K[1]+A.width;for(let N=0;N<A.width;++N){X+=s[K[0]++]<<8|s[K[1]++],f[g]=X,g++}break;case 2:K[0]=E,K[1]=K[0]+A.width,K[2]=K[1]+A.width,E=K[2]+A.width;for(let N=0;N<A.width;++N){X+=s[K[0]++]<<24|s[K[1]++]<<16|s[K[2]++]<<8,f[g]=X,g++}}}return new DataView(f.buffer)}function fA(A){const X=A.viewer,s={value:A.offset.value},N=new Uint16Array(A.width*A.scanlineBlockSize*(A.channels*A.type)),f=new Uint8Array(v);let E=0;const g=new Array(A.channels);for(let r=0;r<A.channels;r++)g[r]={},g[r].start=E,g[r].end=g[r].start,g[r].nx=A.width,g[r].ny=A.lines,g[r].size=A.type,E+=g[r].nx*g[r].ny*g[r].size;const K=j(X,s),i=j(X,s);if(i>=v)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(K<=i)for(let r=0;r<i-K+1;r++)f[r+K]=y(X,s);const c=new Uint16Array(Y),M=function(A,X){let s=0;for(let f=0;f<Y;++f)(0==f||A[f>>3]&1<<(7&f))&&(X[s++]=f);const N=s-1;for(;s<Y;)X[s++]=0;return N}(f,c),d=b(X,s);p(A.array,X,s,d,N,E);for(let r=0;r<A.channels;++r){const A=g[r];for(let X=0;X<g[r].size;++X)h(N,A.start+X,A.nx,A.size,A.ny,A.nx*A.size,M)}!function(A,X,s){for(let N=0;N<s;++N)X[N]=A[X[N]]}(c,N,E);let Q=0;const w=new Uint8Array(N.buffer.byteLength);for(let Y=0;Y<A.lines;Y++)for(let X=0;X<A.channels;X++){const A=g[X],s=A.nx*A.size,f=new Uint8Array(N.buffer,A.end*r,s*r);w.set(f,Q),Q+=s*r,A.end+=s}return new DataView(w.buffer)}var EA,gA=s(456);!function(A){A[A.Float=0]="Float",A[A.HalfFloat=1]="HalfFloat"}(EA||(EA={}));class KA{}async function rA(A,X,s,N){const f={size:0,viewer:X,array:new Uint8Array(X.buffer),offset:s,width:A.dataWindow.xMax-A.dataWindow.xMin+1,height:A.dataWindow.yMax-A.dataWindow.yMin+1,channels:A.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(A.compression){case J.NO_COMPRESSION:f.lines=1,f.uncompress=AA;break;case J.RLE_COMPRESSION:f.lines=1,f.uncompress=XA;break;case J.ZIPS_COMPRESSION:f.lines=1,f.uncompress=sA,await gA.d.LoadScriptAsync(KA.FFLATEUrl);break;case J.ZIP_COMPRESSION:f.lines=16,f.uncompress=sA,await gA.d.LoadScriptAsync(KA.FFLATEUrl);break;case J.PIZ_COMPRESSION:f.lines=32,f.uncompress=fA;break;case J.PXR24_COMPRESSION:f.lines=16,f.uncompress=NA,await gA.d.LoadScriptAsync(KA.FFLATEUrl);break;default:throw new Error(J[A.compression]+" is unsupported")}f.scanlineBlockSize=f.lines;const E={};for(const g of A.channels)switch(g.name){case"R":case"G":case"B":case"A":case"Y":E[g.name]=!0,f.type=g.pixelType}let K=!1;if(E.R&&E.G&&E.B&&E.A)f.outputChannels=4,f.decodeChannels={R:0,G:1,B:2,A:3};else if(E.R&&E.G&&E.B)K=!0,f.outputChannels=4,f.decodeChannels={R:0,G:1,B:2,A:3};else if(E.R&&E.G)f.outputChannels=2,f.decodeChannels={R:0,G:1};else if(E.R)f.outputChannels=1,f.decodeChannels={R:0};else{if(!E.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");f.outputChannels=1,f.decodeChannels={Y:0}}if(1===f.type)switch(N){case EA.Float:f.getter=O,f.inputSize=r;break;case EA.HalfFloat:f.getter=j,f.inputSize=r}else{if(2!==f.type)throw new Error("Unsupported pixelType "+f.type+" for "+A.compression);switch(N){case EA.Float:f.getter=D,f.inputSize=g;break;case EA.HalfFloat:f.getter=P,f.inputSize=g}}f.blockCount=f.height/f.scanlineBlockSize;for(let g=0;g<f.blockCount;g++)V(X,s);const i=f.width*f.height*f.outputChannels;switch(N){case EA.Float:f.byteArray=new Float32Array(i),f.textureType=1,K&&f.byteArray.fill(1,0,i);break;case EA.HalfFloat:f.byteArray=new Uint16Array(i),f.textureType=2,K&&f.byteArray.fill(15360,0,i);break;default:throw new Error("Unsupported type: "+N)}let Y=0;for(const g of A.channels)void 0!==f.decodeChannels[g.name]&&(f.channelLineOffsets[g.name]=Y*f.width),Y+=2*g.pixelType;return f.bytesPerLine=f.width*Y,f.outLineWidth=f.width*f.outputChannels,"INCREASING_Y"===A.lineOrder?f.scanOrder=A=>A:f.scanOrder=A=>f.height-1-A,4==f.outputChannels?(f.format=5,f.linearSpace=!0):(f.format=6,f.linearSpace=!1),f}function iA(A,X,s,N){const f={value:0};for(let E=0;E<A.height/A.scanlineBlockSize;E++){const g=m(s,N)-X.dataWindow.yMin;A.size=b(s,N),A.lines=g+A.scanlineBlockSize>A.height?A.height-g:A.scanlineBlockSize;const K=A.size<A.lines*A.bytesPerLine&&A.uncompress?A.uncompress(A):AA(A);N.value+=A.size;for(let s=0;s<A.scanlineBlockSize;s++){const N=E*A.scanlineBlockSize,g=s+A.scanOrder(N);if(g>=A.height)continue;const r=s*A.bytesPerLine,i=(A.height-1-g)*A.outLineWidth;for(let s=0;s<A.channels;s++){const N=X.channels[s].name,E=A.channelLineOffsets[N],g=A.decodeChannels[N];if(void 0!==g){f.value=r+E;for(let X=0;X<A.width;X++){const s=i+X*A.outputChannels+g;A.byteArray&&(A.byteArray[s]=A.getter(K,f))}}}}}}KA.DefaultOutputType=EA.HalfFloat,KA.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class YA{constructor(){this.supportCascades=!1}loadCubeData(A,X,s,N,f){throw".exr not supported in Cube."}loadData(A,X,s){const f=new DataView(A.buffer),E={value:0},g=e(f,E);rA(g,f,E,KA.DefaultOutputType).then((A=>{iA(A,g,f,E);const N=g.dataWindow.xMax-g.dataWindow.xMin+1,K=g.dataWindow.yMax-g.dataWindow.yMin+1;s(N,K,X.generateMipMaps,!1,(()=>{const s=X.getEngine();X.format=g.format,X.type=A.textureType,X.invertY=!1,X._gammaSpace=!g.linearSpace,A.byteArray&&s._uploadDataToTextureDirectly(X,A.byteArray,0,0,void 0,!0)}))})).catch((A=>{N.b.Error("Failed to load EXR texture: ",A)}))}}async function vA(A){const X=new DataView(A),s={value:0},f=e(X,s);try{const A=await rA(f,X,s,EA.Float);return iA(A,f,X,s),A.byteArray?{width:f.dataWindow.xMax-f.dataWindow.xMin+1,height:f.dataWindow.yMax-f.dataWindow.yMin+1,data:new Float32Array(A.byteArray)}:(N.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(E){N.b.Error("Failed to load EXR data: ",E)}return{width:0,height:0,data:null}}}}]);