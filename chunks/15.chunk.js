"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12847:(E,b,h)=>{h.r(b),h.d(b,{_HDRTextureLoader:()=>s});var a=h(11175);class k{static ConvertPanoramaToCubemap(E,b,h,a){let k=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!E)throw"ConvertPanoramaToCubemap: input cannot be null";if(E.length!=b*h*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(a,this.FACE_FRONT,E,b,h,k),back:this.CreateCubemapTexture(a,this.FACE_BACK,E,b,h,k),left:this.CreateCubemapTexture(a,this.FACE_LEFT,E,b,h,k),right:this.CreateCubemapTexture(a,this.FACE_RIGHT,E,b,h,k),up:this.CreateCubemapTexture(a,this.FACE_UP,E,b,h,k),down:this.CreateCubemapTexture(a,this.FACE_DOWN,E,b,h,k),size:a,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(E,b,h,a,k){let G=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const V=new ArrayBuffer(E*E*4*3),l=new Float32Array(V),O=G?Math.max(1,Math.round(a/4/E)):1,v=1/O,s=v*v,U=b[1].Xc(b[0]).scale(v/E),B=b[3].Xc(b[2]).scale(v/E),o=1/E;let u=0;for(let D=0;D<E;D++)for(let G=0;G<O;G++){let G=b[0],V=b[2];for(let b=0;b<E;b++)for(let v=0;v<O;v++){const O=V.Xc(G).scale(u).add(G);O.normalize();const v=this.CalcProjectionSpherical(O,h,a,k);l[D*E*3+3*b+0]+=v.r*s,l[D*E*3+3*b+1]+=v.g*s,l[D*E*3+3*b+2]+=v.b*s,G=G.add(U),V=V.add(B)}u+=o*v}return l}static CalcProjectionSpherical(E,b,h,a){let k=Math.atan2(E.z,E.x);const G=Math.acos(E.y);for(;k<-Math.PI;)k+=2*Math.PI;for(;k>Math.PI;)k-=2*Math.PI;let V=k/Math.PI;const l=G/Math.PI;V=.5*V+.5;let O=Math.round(V*h);O<0?O=0:O>=h&&(O=h-1);let v=Math.round(l*a);v<0?v=0:v>=a&&(v=a-1);const s=a-v-1;return{r:b[s*h*3+3*O+0],g:b[s*h*3+3*O+1],b:b[s*h*3+3*O+2]}}}function G(E,b,h,a,k,G){k>0?(k=function(E,b){return b>1023?E*Math.pow(2,1023)*Math.pow(2,b-1023):b<-1074?E*Math.pow(2,-1074)*Math.pow(2,b+1074):E*Math.pow(2,b)}(1,k-136),E[G+0]=b*k,E[G+1]=h*k,E[G+2]=a*k):(E[G+0]=0,E[G+1]=0,E[G+2]=0)}function V(E,b){let h="",a="";for(let k=b;k<E.length-b&&(a=String.fromCharCode(E[k]),"\n"!=a);k++)h+=a;return h}function l(E){let b=0,h=0,a=V(E,0);if("#"!=a[0]||"?"!=a[1])throw"Bad HDR Format.";let k=!1,G=!1,l=0;do{l+=a.length+1,a=V(E,l),"FORMAT=32-bit_rle_rgbe"==a?G=!0:0==a.length&&(k=!0)}while(!k);if(!G)throw"HDR Bad header format, unsupported FORMAT";l+=a.length+1,a=V(E,l);const O=/^-Y (.*) \+X (.*)$/g.exec(a);if(!O||O.length<3)throw"HDR Bad header format, no size";if(h=parseInt(O[2]),b=parseInt(O[1]),h<8||h>32767)throw"HDR Bad header format, unsupported size";return l+=a.length+1,{height:b,width:h,dataPosition:l}}function O(E,b){return function(E,b){let h=b.height;const a=b.width;let k,V,l,O,s,U=b.dataPosition,B=0,o=0,u=0;const D=new ArrayBuffer(4*a),g=new Uint8Array(D),S=new ArrayBuffer(b.width*b.height*4*3),M=new Float32Array(S);for(;h>0;){if(k=E[U++],V=E[U++],l=E[U++],O=E[U++],2!=k||2!=V||128&l||b.width<8||b.width>32767)return v(E,b);if((l<<8|O)!=a)throw"HDR Bad header format, wrong scan line width";for(B=0,u=0;u<4;u++)for(o=(u+1)*a;B<o;)if(k=E[U++],V=E[U++],k>128){if(s=k-128,0==s||s>o-B)throw"HDR Bad Format, bad scanline data (run)";for(;s-- >0;)g[B++]=V}else{if(s=k,0==s||s>o-B)throw"HDR Bad Format, bad scanline data (non-run)";if(g[B++]=V,--s>0)for(let b=0;b<s;b++)g[B++]=E[U++]}for(u=0;u<a;u++)k=g[u],V=g[u+a],l=g[u+2*a],O=g[u+3*a],G(M,k,V,l,O,(b.height-h)*a*3+3*u);h--}return M}(E,b)}function v(E,b){let h=b.height;const a=b.width;let k,V,l,O,v,s=b.dataPosition;const U=new ArrayBuffer(b.width*b.height*4*3),B=new Float32Array(U);for(;h>0;){for(v=0;v<b.width;v++)k=E[s++],V=E[s++],l=E[s++],O=E[s++],G(B,k,V,l,O,(b.height-h)*a*3+3*v);h--}return B}k.FACE_LEFT=[new a.k(-1,-1,-1),new a.k(1,-1,-1),new a.k(-1,1,-1),new a.k(1,1,-1)],k.FACE_RIGHT=[new a.k(1,-1,1),new a.k(-1,-1,1),new a.k(1,1,1),new a.k(-1,1,1)],k.FACE_FRONT=[new a.k(1,-1,-1),new a.k(1,-1,1),new a.k(1,1,-1),new a.k(1,1,1)],k.FACE_BACK=[new a.k(-1,-1,1),new a.k(-1,-1,-1),new a.k(-1,1,1),new a.k(-1,1,-1)],k.FACE_DOWN=[new a.k(1,1,-1),new a.k(1,1,1),new a.k(-1,1,-1),new a.k(-1,1,1)],k.FACE_UP=[new a.k(-1,-1,-1),new a.k(-1,-1,1),new a.k(1,-1,-1),new a.k(1,-1,1)];class s{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(E,b,h){const a=new Uint8Array(E.buffer,E.byteOffset,E.byteLength),k=l(a),G=O(a,k),V=k.width*k.height,v=new Float32Array(4*V);for(let l=0;l<V;l+=1)v[4*l]=G[3*l],v[4*l+1]=G[3*l+1],v[4*l+2]=G[3*l+2],v[4*l+3]=1;h(k.width,k.height,b.generateMipMaps,!1,(()=>{const E=b.getEngine();b.type=1,b.format=5,b._gammaSpace=!1,E._uploadDataToTextureDirectly(b,v)}))}}}}]);