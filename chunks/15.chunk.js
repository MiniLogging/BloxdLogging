"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12744:(h,b,I)=>{I.r(b),I.d(b,{_HDRTextureLoader:()=>q});var g=I(11146);class O{static ConvertPanoramaToCubemap(h,b,I,g){let O=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!h)throw"ConvertPanoramaToCubemap: input cannot be null";if(h.length!=b*I*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(g,this.FACE_FRONT,h,b,I,O),back:this.CreateCubemapTexture(g,this.FACE_BACK,h,b,I,O),left:this.CreateCubemapTexture(g,this.FACE_LEFT,h,b,I,O),right:this.CreateCubemapTexture(g,this.FACE_RIGHT,h,b,I,O),up:this.CreateCubemapTexture(g,this.FACE_UP,h,b,I,O),down:this.CreateCubemapTexture(g,this.FACE_DOWN,h,b,I,O),size:g,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(h,b,I,g,O){let T=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const N=new ArrayBuffer(h*h*4*3),V=new Float32Array(N),M=T?Math.max(1,Math.round(g/4/h)):1,y=1/M,q=y*y,e=b[1].tc(b[0]).scale(y/h),P=b[3].tc(b[2]).scale(y/h),K=1/h;let o=0;for(let R=0;R<h;R++)for(let T=0;T<M;T++){let T=b[0],N=b[2];for(let b=0;b<h;b++)for(let y=0;y<M;y++){const M=N.tc(T).scale(o).add(T);M.normalize();const y=this.CalcProjectionSpherical(M,I,g,O);V[R*h*3+3*b+0]+=y.r*q,V[R*h*3+3*b+1]+=y.g*q,V[R*h*3+3*b+2]+=y.b*q,T=T.add(e),N=N.add(P)}o+=K*y}return V}static CalcProjectionSpherical(h,b,I,g){let O=Math.atan2(h.z,h.x);const T=Math.acos(h.y);for(;O<-Math.PI;)O+=2*Math.PI;for(;O>Math.PI;)O-=2*Math.PI;let N=O/Math.PI;const V=T/Math.PI;N=.5*N+.5;let M=Math.round(N*I);M<0?M=0:M>=I&&(M=I-1);let y=Math.round(V*g);y<0?y=0:y>=g&&(y=g-1);const q=g-y-1;return{r:b[q*I*3+3*M+0],g:b[q*I*3+3*M+1],b:b[q*I*3+3*M+2]}}}function T(h,b,I,g,O,T){O>0?(O=function(h,b){return b>1023?h*Math.pow(2,1023)*Math.pow(2,b-1023):b<-1074?h*Math.pow(2,-1074)*Math.pow(2,b+1074):h*Math.pow(2,b)}(1,O-136),h[T+0]=b*O,h[T+1]=I*O,h[T+2]=g*O):(h[T+0]=0,h[T+1]=0,h[T+2]=0)}function N(h,b){let I="",g="";for(let O=b;O<h.length-b&&(g=String.fromCharCode(h[O]),"\n"!=g);O++)I+=g;return I}function V(h){let b=0,I=0,g=N(h,0);if("#"!=g[0]||"?"!=g[1])throw"Bad HDR Format.";let O=!1,T=!1,V=0;do{V+=g.length+1,g=N(h,V),"FORMAT=32-bit_rle_rgbe"==g?T=!0:0==g.length&&(O=!0)}while(!O);if(!T)throw"HDR Bad header format, unsupported FORMAT";V+=g.length+1,g=N(h,V);const M=/^-Y (.*) \+X (.*)$/g.exec(g);if(!M||M.length<3)throw"HDR Bad header format, no size";if(I=parseInt(M[2]),b=parseInt(M[1]),I<8||I>32767)throw"HDR Bad header format, unsupported size";return V+=g.length+1,{height:b,width:I,dataPosition:V}}function M(h,b){return function(h,b){let I=b.height;const g=b.width;let O,N,V,M,q,e=b.dataPosition,P=0,K=0,o=0;const R=new ArrayBuffer(4*g),L=new Uint8Array(R),i=new ArrayBuffer(b.width*b.height*4*3),w=new Float32Array(i);for(;I>0;){if(O=h[e++],N=h[e++],V=h[e++],M=h[e++],2!=O||2!=N||128&V||b.width<8||b.width>32767)return y(h,b);if((V<<8|M)!=g)throw"HDR Bad header format, wrong scan line width";for(P=0,o=0;o<4;o++)for(K=(o+1)*g;P<K;)if(O=h[e++],N=h[e++],O>128){if(q=O-128,0==q||q>K-P)throw"HDR Bad Format, bad scanline data (run)";for(;q-- >0;)L[P++]=N}else{if(q=O,0==q||q>K-P)throw"HDR Bad Format, bad scanline data (non-run)";if(L[P++]=N,--q>0)for(let b=0;b<q;b++)L[P++]=h[e++]}for(o=0;o<g;o++)O=L[o],N=L[o+g],V=L[o+2*g],M=L[o+3*g],T(w,O,N,V,M,(b.height-I)*g*3+3*o);I--}return w}(h,b)}function y(h,b){let I=b.height;const g=b.width;let O,N,V,M,y,q=b.dataPosition;const e=new ArrayBuffer(b.width*b.height*4*3),P=new Float32Array(e);for(;I>0;){for(y=0;y<b.width;y++)O=h[q++],N=h[q++],V=h[q++],M=h[q++],T(P,O,N,V,M,(b.height-I)*g*3+3*y);I--}return P}O.FACE_LEFT=[new g.m(-1,-1,-1),new g.m(1,-1,-1),new g.m(-1,1,-1),new g.m(1,1,-1)],O.FACE_RIGHT=[new g.m(1,-1,1),new g.m(-1,-1,1),new g.m(1,1,1),new g.m(-1,1,1)],O.FACE_FRONT=[new g.m(1,-1,-1),new g.m(1,-1,1),new g.m(1,1,-1),new g.m(1,1,1)],O.FACE_BACK=[new g.m(-1,-1,1),new g.m(-1,-1,-1),new g.m(-1,1,1),new g.m(-1,1,-1)],O.FACE_DOWN=[new g.m(1,1,-1),new g.m(1,1,1),new g.m(-1,1,-1),new g.m(-1,1,1)],O.FACE_UP=[new g.m(-1,-1,-1),new g.m(-1,-1,1),new g.m(1,-1,-1),new g.m(1,-1,1)];class q{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(h,b,I){const g=new Uint8Array(h.buffer,h.byteOffset,h.byteLength),O=V(g),T=M(g,O),N=O.width*O.height,y=new Float32Array(4*N);for(let V=0;V<N;V+=1)y[4*V]=T[3*V],y[4*V+1]=T[3*V+1],y[4*V+2]=T[3*V+2],y[4*V+3]=1;I(O.width,O.height,b.generateMipMaps,!1,(()=>{const h=b.getEngine();b.type=1,b.format=5,b._gammaSpace=!1,h._uploadDataToTextureDirectly(b,y)}))}}}}]);