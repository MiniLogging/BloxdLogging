"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{2625:(u,F,z)=>{z.r(F),z.d(F,{ReadExrDataAsync:()=>Wu,_ExrTextureLoader:()=>ju});var p=z(541),b=z(749);const R=4,c=4,I=1,G=2,X=8,j=65536,W=j>>3,E=14,L=65537,k=1<<E,N=k-1,Y=59,e=63,d=2+e-Y;var C,r;!function(u){u[u.NO_COMPRESSION=0]="NO_COMPRESSION",u[u.RLE_COMPRESSION=1]="RLE_COMPRESSION",u[u.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",u[u.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",u[u.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",u[u.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(C||(C={})),function(u){u[u.INCREASING_Y=0]="INCREASING_Y",u[u.DECREASING_Y=1]="DECREASING_Y"}(r||(r={}));const f=function(){const u=new ArrayBuffer(4),F=new Float32Array(u),z=new Uint32Array(u),p=new Uint32Array(512),b=new Uint32Array(512);for(let G=0;G<256;++G){const u=G-127;u<-27?(p[G]=0,p[256|G]=32768,b[G]=24,b[256|G]=24):u<-14?(p[G]=1024>>-u-14,p[256|G]=1024>>-u-14|32768,b[G]=-u-1,b[256|G]=-u-1):u<=15?(p[G]=u+15<<10,p[256|G]=u+15<<10|32768,b[G]=13,b[256|G]=13):u<128?(p[G]=31744,p[256|G]=64512,b[G]=24,b[256|G]=24):(p[G]=31744,p[256|G]=64512,b[G]=13,b[256|G]=13)}const R=new Uint32Array(2048),c=new Uint32Array(64),I=new Uint32Array(64);for(let G=1;G<1024;++G){let u=G<<13,F=0;for(;0===(8388608&u);)u<<=1,F-=8388608;u&=-8388609,F+=947912704,R[G]=u|F}for(let G=1024;G<2048;++G)R[G]=939524096+(G-1024<<13);for(let G=1;G<31;++G)c[G]=G<<23;c[31]=1199570944,c[32]=2147483648;for(let G=33;G<63;++G)c[G]=2147483648+(G-32<<23);c[63]=3347054592;for(let G=1;G<64;++G)32!==G&&(I[G]=1024);return{floatView:F,uint32View:z,baseTable:p,shiftTable:b,mantissaTable:R,exponentTable:c,offsetTable:I}}();function n(u,F){const z=new Uint8Array(u);let p=0;for(;0!=z[F.value+p];)p+=1;const b=(new TextDecoder).decode(z.slice(F.value,F.value+p));return F.value=F.value+p+1,b}function T(u,F){const z=u.getInt32(F.value,!0);return F.value+=R,z}function H(u,F){const z=u.getUint32(F.value,!0);return F.value+=R,z}function y(u,F){const z=u.getUint8(F.value);return F.value+=I,z}function U(u,F){const z=u.getUint16(F.value,!0);return F.value+=G,z}function a(u,F){const z=u[F.value];return F.value+=I,z}function J(u,F){let z;return z="getBigInt64"in DataView.prototype?Number(u.getBigInt64(F.value,!0)):u.getUint32(F.value+4,!0)+Number(u.getUint32(F.value,!0)<<32),F.value+=X,z}function q(u,F){const z=u.getFloat32(F.value,!0);return F.value+=c,z}function Q(u,F){return function(u){const F=(31744&u)>>10,z=1023&u;return(u>>15?-1:1)*(F?31===F?z?NaN:1/0:Math.pow(2,F-15)*(1+z/1024):z/1024*6103515625e-14)}(U(u,F))}function l(u,F){return function(u){if(Math.abs(u)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");u=(0,b.e)(u,-65504,65504),f.floatView[0]=u;const F=f.uint32View[0],z=F>>23&511;return f.baseTable[z]+((8388607&F)>>f.shiftTable[z])}(q(u,F))}function Z(u,F,z,p){switch(z){case"string":case"stringvector":case"iccProfile":return function(u,F,z){const p=(new TextDecoder).decode(new Uint8Array(u).slice(F.value,F.value+z));return F.value=F.value+z,p}(u.buffer,F,p);case"chlist":return function(u,F,z){const p=F.value,b=[];for(;F.value<p+z-1;){const z=n(u.buffer,F),p=T(u,F),R=y(u,F);F.value+=3;const c=T(u,F),I=T(u,F);b.push({name:z,pixelType:p,pLinear:R,xSampling:c,ySampling:I})}return F.value+=1,b}(u,F,p);case"chromaticities":return function(u,F){return{redX:q(u,F),redY:q(u,F),greenX:q(u,F),greenY:q(u,F),blueX:q(u,F),blueY:q(u,F),whiteX:q(u,F),whiteY:q(u,F)}}(u,F);case"compression":return function(u,F){return y(u,F)}(u,F);case"box2i":return function(u,F){return{xMin:T(u,F),yMin:T(u,F),xMax:T(u,F),yMax:T(u,F)}}(u,F);case"lineOrder":return function(u,F){const z=y(u,F);return r[z]}(u,F);case"float":return q(u,F);case"v2f":return function(u,F){return[q(u,F),q(u,F)]}(u,F);case"v3f":return function(u,F){return[q(u,F),q(u,F),q(u,F)]}(u,F);case"int":return T(u,F);case"rational":return function(u,F){return[T(u,F),H(u,F)]}(u,F);case"timecode":return function(u,F){return[H(u,F),H(u,F)]}(u,F);case"preview":return F.value+=p,"skipped";default:return void(F.value+=p)}}function s(u){for(let F=1;F<u.length;F++){const z=u[F-1]+u[F]-128;u[F]=z}}function o(u,F){let z=0,p=Math.floor((u.length+1)/2),b=0;const R=u.length-1;for(;!(b>R)&&(F[b++]=u[z++],!(b>R));)F[b++]=u[p++]}const v=20000630;function m(u,F){if(u.getUint32(0,!0)!=v)throw new Error("Incorrect OpenEXR format");const z=u.getUint8(4),b=u.getUint8(5),R={singleTile:!!(2&b),longName:!!(4&b),deepFormat:!!(8&b),multiPart:!!(16&b)};F.value=8;const c={};let I=!0;for(;I;){const z=n(u.buffer,F);if(z){const b=n(u.buffer,F),R=Z(u,F,b,H(u,F));void 0===R?p.b.Warn(`Unknown header attribute type ${b}'.`):c[z]=R}else I=!1}if(0!=(-5&b))throw new Error("Unsupported file format");return{version:z,spec:R,...c}}const A=32768,B=65535;function g(u,F,z,p,b){for(;z<u;)F=F<<8|a(p,b),z+=8;return{l:F>>(z-=u)&(1<<u)-1,c:F,lc:z}}function S(u,F,z,p){return{c:u=u<<8|a(z,p),lc:F+=8}}function P(u,F,z,p,b,R,c,I,G){if(u==F){if(p<8){const u=S(z,p,b,R);z=u.c,p=u.lc}let u=z>>(p-=8);if(u=new Uint8Array([u])[0],I.value+u>G)return null;const F=c[I.value-1];for(;u-- >0;)c[I.value++]=F}else{if(!(I.value<G))return null;c[I.value++]=u}return{c:z,lc:p}}const h=new Array(59);function K(u,F,z,p,b,R){const c=F;let I=0,G=0;for(;p<=b;p++){if(c.value-F.value>z)return;let X=g(6,I,G,u,c);const j=X.l;if(I=X.c,G=X.lc,R[p]=j,j==e){if(c.value-F.value>z)throw new Error("Error in HufUnpackEncTable");X=g(8,I,G,u,c);let j=X.l+d;if(I=X.c,G=X.lc,p+j>b+1)throw new Error("Error in HufUnpackEncTable");for(;j--;)R[p++]=0;p--}else if(j>=Y){let u=j-Y+2;if(p+u>b+1)throw new Error("Error in HufUnpackEncTable");for(;u--;)R[p++]=0;p--}}!function(u){for(let z=0;z<=58;++z)h[z]=0;for(let z=0;z<L;++z)h[u[z]]+=1;let F=0;for(let z=58;z>0;--z){const u=F+h[z]>>1;h[z]=F,F=u}for(let z=0;z<L;++z){const F=u[z];F>0&&(u[z]=F|h[F]++<<6)}}(R)}function x(u){return 63&u}function D(u){return u>>6}function V(u,F,z,p,b,R){const c=z.value,I=H(F,z),G=H(F,z);z.value+=4;const X=H(F,z);if(z.value+=4,I<0||I>=L||G<0||G>=L)throw new Error("Wrong HUF_ENCSIZE");const j=new Array(L),W=new Array(k);!function(u){for(let F=0;F<k;F++)u[F]={},u[F].len=0,u[F].lit=0,u[F].p=null}(W);if(K(u,z,p-(z.value-c),I,G,j),X>8*(p-(z.value-c)))throw new Error("Wrong hufUncompress");!function(u,F,z,p){for(;F<=z;F++){const z=D(u[F]),b=x(u[F]);if(z>>b)throw new Error("Invalid table entry");if(b>E){const u=p[z>>b-E];if(u.len)throw new Error("Invalid table entry");if(u.lit++,u.p){const F=u.p;u.p=new Array(u.lit);for(let z=0;z<u.lit-1;++z)u.p[z]=F[z]}else u.p=new Array(1);u.p[u.lit-1]=F}else if(b){let u=0;for(let R=1<<E-b;R>0;R--){const R=p[(z<<E-b)+u];if(R.len||R.p)throw new Error("Invalid table entry");R.len=b,R.lit=F,u++}}}}(j,I,G,W),function(u,F,z,p,b,R,c,I,G){let X=0,j=0;const W=c,L=Math.trunc(p.value+(b+7)/8);for(;p.value<L;){let b=S(X,j,z,p);for(X=b.c,j=b.lc;j>=E;){const c=F[X>>j-E&N];if(c.len){j-=c.len;const u=P(c.lit,R,X,j,z,p,I,G,W);u&&(X=u.c,j=u.lc)}else{if(!c.p)throw new Error("hufDecode issues");let F;for(F=0;F<c.lit;F++){const E=x(u[c.p[F]]);for(;j<E&&p.value<L;)b=S(X,j,z,p),X=b.c,j=b.lc;if(j>=E&&D(u[c.p[F]])==(X>>j-E&(1<<E)-1)){j-=E;const u=P(c.p[F],R,X,j,z,p,I,G,W);u&&(X=u.c,j=u.lc);break}}if(F==c.lit)throw new Error("HufDecode issues")}}}const k=8-b&7;for(X>>=k,j-=k;j>0;){const u=F[X<<E-j&N];if(!u.len)throw new Error("HufDecode issues");{j-=u.len;const F=P(u.lit,R,X,j,z,p,I,G,W);F&&(X=F.c,j=F.lc)}}}(j,W,u,z,X,G,R,b,{value:0})}function M(u){return 65535&u}function O(u){const F=M(u);return F>32767?F-65536:F}function i(u,F){const z=O(u),p=O(F),b=z+(1&p)+(p>>1);return{a:b,b:b-p}}function w(u,F){const z=M(u),p=M(F),b=z-(p>>1)&B;return{a:p+b-A&B,b:b}}function t(u,F,z,p,b,R,c){const I=c<16384,G=z>b?b:z;let X,j,W=1;for(;W<=G;)W<<=1;for(W>>=1,X=W,W>>=1;W>=1;){j=0;const c=j+R*(b-X),G=R*W,E=R*X,L=p*W,k=p*X;let N,Y,e,d;for(;j<=c;j+=E){let b=j;const R=j+p*(z-X);for(;b<=R;b+=k){const z=b+L,p=b+G,R=p+L;if(I){let c=i(u[b+F],u[p+F]);N=c.a,e=c.b,c=i(u[z+F],u[R+F]),Y=c.a,d=c.b,c=i(N,Y),u[b+F]=c.a,u[z+F]=c.b,c=i(e,d),u[p+F]=c.a,u[R+F]=c.b}else{let c=w(u[b+F],u[p+F]);N=c.a,e=c.b,c=w(u[z+F],u[R+F]),Y=c.a,d=c.b,c=w(N,Y),u[b+F]=c.a,u[z+F]=c.b,c=w(e,d),u[p+F]=c.a,u[R+F]=c.b}}if(z&W){const z=b+G;let p;p=I?i(u[b+F],u[z+F]):w(u[b+F],u[z+F]),N=p.a,u[z+F]=p.b,u[b+F]=N}}if(b&W){let b=j;const R=j+p*(z-X);for(;b<=R;b+=k){const z=b+L;let p;p=I?i(u[b+F],u[z+F]):w(u[b+F],u[z+F]),N=p.a,u[z+F]=p.b,u[b+F]=N}}X=W,W>>=1}return j}function uu(u){return new DataView(u.array.buffer,u.offset.value,u.size)}function Fu(u){const F=u.viewer.buffer.slice(u.offset.value,u.offset.value+u.size),z=new Uint8Array(function(u){let F=u.byteLength;const z=[];let p=0;const b=new DataView(u);for(;F>0;){const u=b.getInt8(p++);if(u<0){const R=-u;F-=R+1;for(let u=0;u<R;u++)z.push(b.getUint8(p++))}else{const R=u;F-=2;const c=b.getUint8(p++);for(let u=0;u<R+1;u++)z.push(c)}}return z}(F)),p=new Uint8Array(z.length);return s(z),o(z,p),new DataView(p.buffer)}function zu(u){const F=u.array.slice(u.offset.value,u.offset.value+u.size),z=fflate.unzlibSync(F),p=new Uint8Array(z.length);return s(z),o(z,p),new DataView(p.buffer)}function pu(u){const F=u.array.slice(u.offset.value,u.offset.value+u.size),z=fflate.unzlibSync(F),p=u.lines*u.channels*u.width,b=1==u.type?new Uint16Array(p):new Uint32Array(p);let R=0,c=0;const I=new Array(4);for(let G=0;G<u.lines;G++)for(let F=0;F<u.channels;F++){let F=0;switch(u.type){case 1:I[0]=R,I[1]=I[0]+u.width,R=I[1]+u.width;for(let p=0;p<u.width;++p){F+=z[I[0]++]<<8|z[I[1]++],b[c]=F,c++}break;case 2:I[0]=R,I[1]=I[0]+u.width,I[2]=I[1]+u.width,R=I[2]+u.width;for(let p=0;p<u.width;++p){F+=z[I[0]++]<<24|z[I[1]++]<<16|z[I[2]++]<<8,b[c]=F,c++}}}return new DataView(b.buffer)}function bu(u){const F=u.viewer,z={value:u.offset.value},p=new Uint16Array(u.width*u.scanlineBlockSize*(u.channels*u.type)),b=new Uint8Array(W);let R=0;const c=new Array(u.channels);for(let G=0;G<u.channels;G++)c[G]={},c[G].start=R,c[G].end=c[G].start,c[G].nx=u.width,c[G].ny=u.lines,c[G].size=u.type,R+=c[G].nx*c[G].ny*c[G].size;const I=U(F,z),X=U(F,z);if(X>=W)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(I<=X)for(let G=0;G<X-I+1;G++)b[G+I]=y(F,z);const E=new Uint16Array(j),L=function(u,F){let z=0;for(let b=0;b<j;++b)(0==b||u[b>>3]&1<<(7&b))&&(F[z++]=b);const p=z-1;for(;z<j;)F[z++]=0;return p}(b,E),k=H(F,z);V(u.array,F,z,k,p,R);for(let G=0;G<u.channels;++G){const u=c[G];for(let F=0;F<c[G].size;++F)t(p,u.start+F,u.nx,u.size,u.ny,u.nx*u.size,L)}!function(u,F,z){for(let p=0;p<z;++p)F[p]=u[F[p]]}(E,p,R);let N=0;const Y=new Uint8Array(p.buffer.byteLength);for(let j=0;j<u.lines;j++)for(let F=0;F<u.channels;F++){const u=c[F],z=u.nx*u.size,b=new Uint8Array(p.buffer,u.end*G,z*G);Y.set(b,N),N+=z*G,u.end+=z}return new DataView(Y.buffer)}var Ru,cu=z(528);!function(u){u[u.Float=0]="Float",u[u.HalfFloat=1]="HalfFloat"}(Ru||(Ru={}));class Iu{}async function Gu(u,F,z,p){const b={size:0,viewer:F,array:new Uint8Array(F.buffer),offset:z,width:u.dataWindow.xMax-u.dataWindow.xMin+1,height:u.dataWindow.yMax-u.dataWindow.yMin+1,channels:u.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(u.compression){case C.NO_COMPRESSION:b.lines=1,b.uncompress=uu;break;case C.RLE_COMPRESSION:b.lines=1,b.uncompress=Fu;break;case C.ZIPS_COMPRESSION:b.lines=1,b.uncompress=zu,await cu.e.LoadScriptAsync(Iu.FFLATEUrl);break;case C.ZIP_COMPRESSION:b.lines=16,b.uncompress=zu,await cu.e.LoadScriptAsync(Iu.FFLATEUrl);break;case C.PIZ_COMPRESSION:b.lines=32,b.uncompress=bu;break;case C.PXR24_COMPRESSION:b.lines=16,b.uncompress=pu,await cu.e.LoadScriptAsync(Iu.FFLATEUrl);break;default:throw new Error(C[u.compression]+" is unsupported")}b.scanlineBlockSize=b.lines;const R={};for(const c of u.channels)switch(c.name){case"R":case"G":case"B":case"A":case"Y":R[c.name]=!0,b.type=c.pixelType}let I=!1;if(R.R&&R.G&&R.B&&R.A)b.outputChannels=4,b.decodeChannels={R:0,G:1,B:2,A:3};else if(R.R&&R.G&&R.B)I=!0,b.outputChannels=4,b.decodeChannels={R:0,G:1,B:2,A:3};else if(R.R&&R.G)b.outputChannels=2,b.decodeChannels={R:0,G:1};else if(R.R)b.outputChannels=1,b.decodeChannels={R:0};else{if(!R.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");b.outputChannels=1,b.decodeChannels={Y:0}}if(1===b.type)switch(p){case Ru.Float:b.getter=Q,b.inputSize=G;break;case Ru.HalfFloat:b.getter=U,b.inputSize=G}else{if(2!==b.type)throw new Error("Unsupported pixelType "+b.type+" for "+u.compression);switch(p){case Ru.Float:b.getter=q,b.inputSize=c;break;case Ru.HalfFloat:b.getter=l,b.inputSize=c}}b.blockCount=b.height/b.scanlineBlockSize;for(let c=0;c<b.blockCount;c++)J(F,z);const X=b.width*b.height*b.outputChannels;switch(p){case Ru.Float:b.byteArray=new Float32Array(X),b.textureType=1,I&&b.byteArray.fill(1,0,X);break;case Ru.HalfFloat:b.byteArray=new Uint16Array(X),b.textureType=2,I&&b.byteArray.fill(15360,0,X);break;default:throw new Error("Unsupported type: "+p)}let j=0;for(const c of u.channels)void 0!==b.decodeChannels[c.name]&&(b.channelLineOffsets[c.name]=j*b.width),j+=2*c.pixelType;return b.bytesPerLine=b.width*j,b.outLineWidth=b.width*b.outputChannels,"INCREASING_Y"===u.lineOrder?b.scanOrder=u=>u:b.scanOrder=u=>b.height-1-u,4==b.outputChannels?(b.format=5,b.linearSpace=!0):(b.format=6,b.linearSpace=!1),b}function Xu(u,F,z,p){const b={value:0};for(let R=0;R<u.height/u.scanlineBlockSize;R++){const c=T(z,p)-F.dataWindow.yMin;u.size=H(z,p),u.lines=c+u.scanlineBlockSize>u.height?u.height-c:u.scanlineBlockSize;const I=u.size<u.lines*u.bytesPerLine&&u.uncompress?u.uncompress(u):uu(u);p.value+=u.size;for(let z=0;z<u.scanlineBlockSize;z++){const p=R*u.scanlineBlockSize,c=z+u.scanOrder(p);if(c>=u.height)continue;const G=z*u.bytesPerLine,X=(u.height-1-c)*u.outLineWidth;for(let z=0;z<u.channels;z++){const p=F.channels[z].name,R=u.channelLineOffsets[p],c=u.decodeChannels[p];if(void 0!==c){b.value=G+R;for(let F=0;F<u.width;F++){const z=X+F*u.outputChannels+c;u.byteArray&&(u.byteArray[z]=u.getter(I,b))}}}}}}Iu.DefaultOutputType=Ru.HalfFloat,Iu.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class ju{constructor(){this.supportCascades=!1}loadCubeData(u,F,z,p,b){throw".exr not supported in Cube."}loadData(u,F,z){const b=new DataView(u.buffer),R={value:0},c=m(b,R);Gu(c,b,R,Iu.DefaultOutputType).then((u=>{Xu(u,c,b,R);const p=c.dataWindow.xMax-c.dataWindow.xMin+1,I=c.dataWindow.yMax-c.dataWindow.yMin+1;z(p,I,F.generateMipMaps,!1,(()=>{const z=F.getEngine();F.format=c.format,F.type=u.textureType,F.invertY=!1,F._gammaSpace=!c.linearSpace,u.byteArray&&z._uploadDataToTextureDirectly(F,u.byteArray,0,0,void 0,!0)}))})).catch((u=>{p.b.Error("Failed to load EXR texture: ",u)}))}}async function Wu(u){const F=new DataView(u),z={value:0},b=m(F,z);try{const u=await Gu(b,F,z,Ru.Float);return Xu(u,b,F,z),u.byteArray?{width:b.dataWindow.xMax-b.dataWindow.xMin+1,height:b.dataWindow.yMax-b.dataWindow.yMin+1,data:new Float32Array(u.byteArray)}:(p.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(R){p.b.Error("Failed to load EXR data: ",R)}return{width:0,height:0,data:null}}}}]);