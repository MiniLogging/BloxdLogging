"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12744:(a,R,Y)=>{Y.r(R),Y.d(R,{_HDRTextureLoader:()=>C});var T=Y(11076);class c{static ConvertPanoramaToCubemap(a,R,Y,T){let c=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!a)throw"ConvertPanoramaToCubemap: input cannot be null";if(a.length!=R*Y*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(T,this.FACE_FRONT,a,R,Y,c),back:this.CreateCubemapTexture(T,this.FACE_BACK,a,R,Y,c),left:this.CreateCubemapTexture(T,this.FACE_LEFT,a,R,Y,c),right:this.CreateCubemapTexture(T,this.FACE_RIGHT,a,R,Y,c),up:this.CreateCubemapTexture(T,this.FACE_UP,a,R,Y,c),down:this.CreateCubemapTexture(T,this.FACE_DOWN,a,R,Y,c),size:T,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(a,R,Y,T,c){let K=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const g=new ArrayBuffer(a*a*4*3),t=new Float32Array(g),U=K?Math.max(1,Math.round(T/4/a)):1,b=1/U,C=b*b,e=R[1].Vc(R[0]).scale(b/a),Z=R[3].Vc(R[2]).scale(b/a),W=1/a;let o=0;for(let i=0;i<a;i++)for(let K=0;K<U;K++){let K=R[0],g=R[2];for(let R=0;R<a;R++)for(let b=0;b<U;b++){const U=g.Vc(K).scale(o).add(K);U.normalize();const b=this.CalcProjectionSpherical(U,Y,T,c);t[i*a*3+3*R+0]+=b.r*C,t[i*a*3+3*R+1]+=b.g*C,t[i*a*3+3*R+2]+=b.b*C,K=K.add(e),g=g.add(Z)}o+=W*b}return t}static CalcProjectionSpherical(a,R,Y,T){let c=Math.atan2(a.z,a.x);const K=Math.acos(a.y);for(;c<-Math.PI;)c+=2*Math.PI;for(;c>Math.PI;)c-=2*Math.PI;let g=c/Math.PI;const t=K/Math.PI;g=.5*g+.5;let U=Math.round(g*Y);U<0?U=0:U>=Y&&(U=Y-1);let b=Math.round(t*T);b<0?b=0:b>=T&&(b=T-1);const C=T-b-1;return{r:R[C*Y*3+3*U+0],g:R[C*Y*3+3*U+1],b:R[C*Y*3+3*U+2]}}}function K(a,R,Y,T,c,K){c>0?(c=function(a,R){return R>1023?a*Math.pow(2,1023)*Math.pow(2,R-1023):R<-1074?a*Math.pow(2,-1074)*Math.pow(2,R+1074):a*Math.pow(2,R)}(1,c-136),a[K+0]=R*c,a[K+1]=Y*c,a[K+2]=T*c):(a[K+0]=0,a[K+1]=0,a[K+2]=0)}function g(a,R){let Y="",T="";for(let c=R;c<a.length-R&&(T=String.fromCharCode(a[c]),"\n"!=T);c++)Y+=T;return Y}function t(a){let R=0,Y=0,T=g(a,0);if("#"!=T[0]||"?"!=T[1])throw"Bad HDR Format.";let c=!1,K=!1,t=0;do{t+=T.length+1,T=g(a,t),"FORMAT=32-bit_rle_rgbe"==T?K=!0:0==T.length&&(c=!0)}while(!c);if(!K)throw"HDR Bad header format, unsupported FORMAT";t+=T.length+1,T=g(a,t);const U=/^-Y (.*) \+X (.*)$/g.exec(T);if(!U||U.length<3)throw"HDR Bad header format, no size";if(Y=parseInt(U[2]),R=parseInt(U[1]),Y<8||Y>32767)throw"HDR Bad header format, unsupported size";return t+=T.length+1,{height:R,width:Y,dataPosition:t}}function U(a,R){return function(a,R){let Y=R.height;const T=R.width;let c,g,t,U,C,e=R.dataPosition,Z=0,W=0,o=0;const i=new ArrayBuffer(4*T),d=new Uint8Array(i),v=new ArrayBuffer(R.width*R.height*4*3),A=new Float32Array(v);for(;Y>0;){if(c=a[e++],g=a[e++],t=a[e++],U=a[e++],2!=c||2!=g||128&t||R.width<8||R.width>32767)return b(a,R);if((t<<8|U)!=T)throw"HDR Bad header format, wrong scan line width";for(Z=0,o=0;o<4;o++)for(W=(o+1)*T;Z<W;)if(c=a[e++],g=a[e++],c>128){if(C=c-128,0==C||C>W-Z)throw"HDR Bad Format, bad scanline data (run)";for(;C-- >0;)d[Z++]=g}else{if(C=c,0==C||C>W-Z)throw"HDR Bad Format, bad scanline data (non-run)";if(d[Z++]=g,--C>0)for(let R=0;R<C;R++)d[Z++]=a[e++]}for(o=0;o<T;o++)c=d[o],g=d[o+T],t=d[o+2*T],U=d[o+3*T],K(A,c,g,t,U,(R.height-Y)*T*3+3*o);Y--}return A}(a,R)}function b(a,R){let Y=R.height;const T=R.width;let c,g,t,U,b,C=R.dataPosition;const e=new ArrayBuffer(R.width*R.height*4*3),Z=new Float32Array(e);for(;Y>0;){for(b=0;b<R.width;b++)c=a[C++],g=a[C++],t=a[C++],U=a[C++],K(Z,c,g,t,U,(R.height-Y)*T*3+3*b);Y--}return Z}c.FACE_LEFT=[new T.m(-1,-1,-1),new T.m(1,-1,-1),new T.m(-1,1,-1),new T.m(1,1,-1)],c.FACE_RIGHT=[new T.m(1,-1,1),new T.m(-1,-1,1),new T.m(1,1,1),new T.m(-1,1,1)],c.FACE_FRONT=[new T.m(1,-1,-1),new T.m(1,-1,1),new T.m(1,1,-1),new T.m(1,1,1)],c.FACE_BACK=[new T.m(-1,-1,1),new T.m(-1,-1,-1),new T.m(-1,1,1),new T.m(-1,1,-1)],c.FACE_DOWN=[new T.m(1,1,-1),new T.m(1,1,1),new T.m(-1,1,-1),new T.m(-1,1,1)],c.FACE_UP=[new T.m(-1,-1,-1),new T.m(-1,-1,1),new T.m(1,-1,-1),new T.m(1,-1,1)];class C{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(a,R,Y){const T=new Uint8Array(a.buffer,a.byteOffset,a.byteLength),c=t(T),K=U(T,c),g=c.width*c.height,b=new Float32Array(4*g);for(let t=0;t<g;t+=1)b[4*t]=K[3*t],b[4*t+1]=K[3*t+1],b[4*t+2]=K[3*t+2],b[4*t+3]=1;Y(c.width,c.height,R.generateMipMaps,!1,(()=>{const a=R.getEngine();R.type=1,R.format=5,R._gammaSpace=!1,a._uploadDataToTextureDirectly(R,b)}))}}}}]);