"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12747:(E,Y,C)=>{C.r(Y),C.d(Y,{_HDRTextureLoader:()=>t});var P=C(11064);class K{static ConvertPanoramaToCubemap(E,Y,C,P){let K=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!E)throw"ConvertPanoramaToCubemap: input cannot be null";if(E.length!=Y*C*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(P,this.FACE_FRONT,E,Y,C,K),back:this.CreateCubemapTexture(P,this.FACE_BACK,E,Y,C,K),left:this.CreateCubemapTexture(P,this.FACE_LEFT,E,Y,C,K),right:this.CreateCubemapTexture(P,this.FACE_RIGHT,E,Y,C,K),up:this.CreateCubemapTexture(P,this.FACE_UP,E,Y,C,K),down:this.CreateCubemapTexture(P,this.FACE_DOWN,E,Y,C,K),size:P,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(E,Y,C,P,K){let m=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const u=new ArrayBuffer(E*E*4*3),T=new Float32Array(u),a=m?Math.max(1,Math.round(P/4/E)):1,J=1/a,t=J*J,p=Y[1].md(Y[0]).scale(J/E),W=Y[3].md(Y[2]).scale(J/E),k=1/E;let y=0;for(let v=0;v<E;v++)for(let m=0;m<a;m++){let m=Y[0],u=Y[2];for(let Y=0;Y<E;Y++)for(let J=0;J<a;J++){const a=u.md(m).scale(y).add(m);a.normalize();const J=this.CalcProjectionSpherical(a,C,P,K);T[v*E*3+3*Y+0]+=J.r*t,T[v*E*3+3*Y+1]+=J.g*t,T[v*E*3+3*Y+2]+=J.b*t,m=m.add(p),u=u.add(W)}y+=k*J}return T}static CalcProjectionSpherical(E,Y,C,P){let K=Math.atan2(E.z,E.x);const m=Math.acos(E.y);for(;K<-Math.PI;)K+=2*Math.PI;for(;K>Math.PI;)K-=2*Math.PI;let u=K/Math.PI;const T=m/Math.PI;u=.5*u+.5;let a=Math.round(u*C);a<0?a=0:a>=C&&(a=C-1);let J=Math.round(T*P);J<0?J=0:J>=P&&(J=P-1);const t=P-J-1;return{r:Y[t*C*3+3*a+0],g:Y[t*C*3+3*a+1],b:Y[t*C*3+3*a+2]}}}function m(E,Y,C,P,K,m){K>0?(K=function(E,Y){return Y>1023?E*Math.pow(2,1023)*Math.pow(2,Y-1023):Y<-1074?E*Math.pow(2,-1074)*Math.pow(2,Y+1074):E*Math.pow(2,Y)}(1,K-136),E[m+0]=Y*K,E[m+1]=C*K,E[m+2]=P*K):(E[m+0]=0,E[m+1]=0,E[m+2]=0)}function u(E,Y){let C="",P="";for(let K=Y;K<E.length-Y&&(P=String.fromCharCode(E[K]),"\n"!=P);K++)C+=P;return C}function T(E){let Y=0,C=0,P=u(E,0);if("#"!=P[0]||"?"!=P[1])throw"Bad HDR Format.";let K=!1,m=!1,T=0;do{T+=P.length+1,P=u(E,T),"FORMAT=32-bit_rle_rgbe"==P?m=!0:0==P.length&&(K=!0)}while(!K);if(!m)throw"HDR Bad header format, unsupported FORMAT";T+=P.length+1,P=u(E,T);const a=/^-Y (.*) \+X (.*)$/g.exec(P);if(!a||a.length<3)throw"HDR Bad header format, no size";if(C=parseInt(a[2]),Y=parseInt(a[1]),C<8||C>32767)throw"HDR Bad header format, unsupported size";return T+=P.length+1,{height:Y,width:C,dataPosition:T}}function a(E,Y){return function(E,Y){let C=Y.height;const P=Y.width;let K,u,T,a,t,p=Y.dataPosition,W=0,k=0,y=0;const v=new ArrayBuffer(4*P),V=new Uint8Array(v),Z=new ArrayBuffer(Y.width*Y.height*4*3),M=new Float32Array(Z);for(;C>0;){if(K=E[p++],u=E[p++],T=E[p++],a=E[p++],2!=K||2!=u||128&T||Y.width<8||Y.width>32767)return J(E,Y);if((T<<8|a)!=P)throw"HDR Bad header format, wrong scan line width";for(W=0,y=0;y<4;y++)for(k=(y+1)*P;W<k;)if(K=E[p++],u=E[p++],K>128){if(t=K-128,0==t||t>k-W)throw"HDR Bad Format, bad scanline data (run)";for(;t-- >0;)V[W++]=u}else{if(t=K,0==t||t>k-W)throw"HDR Bad Format, bad scanline data (non-run)";if(V[W++]=u,--t>0)for(let Y=0;Y<t;Y++)V[W++]=E[p++]}for(y=0;y<P;y++)K=V[y],u=V[y+P],T=V[y+2*P],a=V[y+3*P],m(M,K,u,T,a,(Y.height-C)*P*3+3*y);C--}return M}(E,Y)}function J(E,Y){let C=Y.height;const P=Y.width;let K,u,T,a,J,t=Y.dataPosition;const p=new ArrayBuffer(Y.width*Y.height*4*3),W=new Float32Array(p);for(;C>0;){for(J=0;J<Y.width;J++)K=E[t++],u=E[t++],T=E[t++],a=E[t++],m(W,K,u,T,a,(Y.height-C)*P*3+3*J);C--}return W}K.FACE_LEFT=[new P.m(-1,-1,-1),new P.m(1,-1,-1),new P.m(-1,1,-1),new P.m(1,1,-1)],K.FACE_RIGHT=[new P.m(1,-1,1),new P.m(-1,-1,1),new P.m(1,1,1),new P.m(-1,1,1)],K.FACE_FRONT=[new P.m(1,-1,-1),new P.m(1,-1,1),new P.m(1,1,-1),new P.m(1,1,1)],K.FACE_BACK=[new P.m(-1,-1,1),new P.m(-1,-1,-1),new P.m(-1,1,1),new P.m(-1,1,-1)],K.FACE_DOWN=[new P.m(1,1,-1),new P.m(1,1,1),new P.m(-1,1,-1),new P.m(-1,1,1)],K.FACE_UP=[new P.m(-1,-1,-1),new P.m(-1,-1,1),new P.m(1,-1,-1),new P.m(1,-1,1)];class t{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(E,Y,C){const P=new Uint8Array(E.buffer,E.byteOffset,E.byteLength),K=T(P),m=a(P,K),u=K.width*K.height,J=new Float32Array(4*u);for(let T=0;T<u;T+=1)J[4*T]=m[3*T],J[4*T+1]=m[3*T+1],J[4*T+2]=m[3*T+2],J[4*T+3]=1;C(K.width,K.height,Y.generateMipMaps,!1,(()=>{const E=Y.getEngine();Y.type=1,Y.format=5,Y._gammaSpace=!1,E._uploadDataToTextureDirectly(Y,J)}))}}}}]);