"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{2699:(P,Q,O)=>{O.r(Q),O.d(Q,{ReadExrDataAsync:()=>LP,_ExrTextureLoader:()=>CP});var b=O(561),F=O(778);const g=4,m=4,q=1,R=2,X=8,C=65536,L=C>>3,G=14,A=65537,j=1<<G,w=j-1,W=59,r=63,K=2+r-W;var T,x;!function(P){P[P.NO_COMPRESSION=0]="NO_COMPRESSION",P[P.RLE_COMPRESSION=1]="RLE_COMPRESSION",P[P.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",P[P.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",P[P.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",P[P.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(T||(T={})),function(P){P[P.INCREASING_Y=0]="INCREASING_Y",P[P.DECREASING_Y=1]="DECREASING_Y"}(x||(x={}));const u=function(){const P=new ArrayBuffer(4),Q=new Float32Array(P),O=new Uint32Array(P),b=new Uint32Array(512),F=new Uint32Array(512);for(let R=0;R<256;++R){const P=R-127;P<-27?(b[R]=0,b[256|R]=32768,F[R]=24,F[256|R]=24):P<-14?(b[R]=1024>>-P-14,b[256|R]=1024>>-P-14|32768,F[R]=-P-1,F[256|R]=-P-1):P<=15?(b[R]=P+15<<10,b[256|R]=P+15<<10|32768,F[R]=13,F[256|R]=13):P<128?(b[R]=31744,b[256|R]=64512,F[R]=24,F[256|R]=24):(b[R]=31744,b[256|R]=64512,F[R]=13,F[256|R]=13)}const g=new Uint32Array(2048),m=new Uint32Array(64),q=new Uint32Array(64);for(let R=1;R<1024;++R){let P=R<<13,Q=0;for(;0===(8388608&P);)P<<=1,Q-=8388608;P&=-8388609,Q+=947912704,g[R]=P|Q}for(let R=1024;R<2048;++R)g[R]=939524096+(R-1024<<13);for(let R=1;R<31;++R)m[R]=R<<23;m[31]=1199570944,m[32]=2147483648;for(let R=33;R<63;++R)m[R]=2147483648+(R-32<<23);m[63]=3347054592;for(let R=1;R<64;++R)32!==R&&(q[R]=1024);return{floatView:Q,uint32View:O,baseTable:b,shiftTable:F,mantissaTable:g,exponentTable:m,offsetTable:q}}();function H(P,Q){const O=new Uint8Array(P);let b=0;for(;0!=O[Q.value+b];)b+=1;const F=(new TextDecoder).decode(O.slice(Q.value,Q.value+b));return Q.value=Q.value+b+1,F}function t(P,Q){const O=P.getInt32(Q.value,!0);return Q.value+=g,O}function B(P,Q){const O=P.getUint32(Q.value,!0);return Q.value+=g,O}function I(P,Q){const O=P.getUint8(Q.value);return Q.value+=q,O}function l(P,Q){const O=P.getUint16(Q.value,!0);return Q.value+=R,O}function M(P,Q){const O=P[Q.value];return Q.value+=q,O}function S(P,Q){let O;return O="getBigInt64"in DataView.prototype?Number(P.getBigInt64(Q.value,!0)):P.getUint32(Q.value+4,!0)+Number(P.getUint32(Q.value,!0)<<32),Q.value+=X,O}function o(P,Q){const O=P.getFloat32(Q.value,!0);return Q.value+=m,O}function z(P,Q){return function(P){const Q=(31744&P)>>10,O=1023&P;return(P>>15?-1:1)*(Q?31===Q?O?NaN:1/0:Math.pow(2,Q-15)*(1+O/1024):O/1024*6103515625e-14)}(l(P,Q))}function a(P,Q){return function(P){if(Math.abs(P)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");P=(0,F.e)(P,-65504,65504),u.floatView[0]=P;const Q=u.uint32View[0],O=Q>>23&511;return u.baseTable[O]+((8388607&Q)>>u.shiftTable[O])}(o(P,Q))}function y(P,Q,O,b){switch(O){case"string":case"stringvector":case"iccProfile":return function(P,Q,O){const b=(new TextDecoder).decode(new Uint8Array(P).slice(Q.value,Q.value+O));return Q.value=Q.value+O,b}(P.buffer,Q,b);case"chlist":return function(P,Q,O){const b=Q.value,F=[];for(;Q.value<b+O-1;){const O=H(P.buffer,Q),b=t(P,Q),g=I(P,Q);Q.value+=3;const m=t(P,Q),q=t(P,Q);F.push({name:O,pixelType:b,pLinear:g,xSampling:m,ySampling:q})}return Q.value+=1,F}(P,Q,b);case"chromaticities":return function(P,Q){return{redX:o(P,Q),redY:o(P,Q),greenX:o(P,Q),greenY:o(P,Q),blueX:o(P,Q),blueY:o(P,Q),whiteX:o(P,Q),whiteY:o(P,Q)}}(P,Q);case"compression":return function(P,Q){return I(P,Q)}(P,Q);case"box2i":return function(P,Q){return{xMin:t(P,Q),yMin:t(P,Q),xMax:t(P,Q),yMax:t(P,Q)}}(P,Q);case"lineOrder":return function(P,Q){const O=I(P,Q);return x[O]}(P,Q);case"float":return o(P,Q);case"v2f":return function(P,Q){return[o(P,Q),o(P,Q)]}(P,Q);case"v3f":return function(P,Q){return[o(P,Q),o(P,Q),o(P,Q)]}(P,Q);case"int":return t(P,Q);case"rational":return function(P,Q){return[t(P,Q),B(P,Q)]}(P,Q);case"timecode":return function(P,Q){return[B(P,Q),B(P,Q)]}(P,Q);case"preview":return Q.value+=b,"skipped";default:return void(Q.value+=b)}}function c(P){for(let Q=1;Q<P.length;Q++){const O=P[Q-1]+P[Q]-128;P[Q]=O}}function h(P,Q){let O=0,b=Math.floor((P.length+1)/2),F=0;const g=P.length-1;for(;!(F>g)&&(Q[F++]=P[O++],!(F>g));)Q[F++]=P[b++]}const V=20000630;function s(P,Q){if(P.getUint32(0,!0)!=V)throw new Error("Incorrect OpenEXR format");const O=P.getUint8(4),F=P.getUint8(5),g={singleTile:!!(2&F),longName:!!(4&F),deepFormat:!!(8&F),multiPart:!!(16&F)};Q.value=8;const m={};let q=!0;for(;q;){const O=H(P.buffer,Q);if(O){const F=H(P.buffer,Q),g=y(P,Q,F,B(P,Q));void 0===g?b.d.Warn(`Unknown header attribute type ${F}'.`):m[O]=g}else q=!1}if(0!=(-5&F))throw new Error("Unsupported file format");return{version:O,spec:g,...m}}const J=32768,e=65535;function i(P,Q,O,b,F){for(;O<P;)Q=Q<<8|M(b,F),O+=8;return{l:Q>>(O-=P)&(1<<P)-1,c:Q,lc:O}}function Y(P,Q,O,b){return{c:P=P<<8|M(O,b),lc:Q+=8}}function p(P,Q,O,b,F,g,m,q,R){if(P==Q){if(b<8){const P=Y(O,b,F,g);O=P.c,b=P.lc}let P=O>>(b-=8);if(P=new Uint8Array([P])[0],q.value+P>R)return null;const Q=m[q.value-1];for(;P-- >0;)m[q.value++]=Q}else{if(!(q.value<R))return null;m[q.value++]=P}return{c:O,lc:b}}const D=new Array(59);function d(P,Q,O,b,F,g){const m=Q;let q=0,R=0;for(;b<=F;b++){if(m.value-Q.value>O)return;let X=i(6,q,R,P,m);const C=X.l;if(q=X.c,R=X.lc,g[b]=C,C==r){if(m.value-Q.value>O)throw new Error("Error in HufUnpackEncTable");X=i(8,q,R,P,m);let C=X.l+K;if(q=X.c,R=X.lc,b+C>F+1)throw new Error("Error in HufUnpackEncTable");for(;C--;)g[b++]=0;b--}else if(C>=W){let P=C-W+2;if(b+P>F+1)throw new Error("Error in HufUnpackEncTable");for(;P--;)g[b++]=0;b--}}!function(P){for(let O=0;O<=58;++O)D[O]=0;for(let O=0;O<A;++O)D[P[O]]+=1;let Q=0;for(let O=58;O>0;--O){const P=Q+D[O]>>1;D[O]=Q,Q=P}for(let O=0;O<A;++O){const Q=P[O];Q>0&&(P[O]=Q|D[Q]++<<6)}}(g)}function N(P){return 63&P}function f(P){return P>>6}function n(P,Q,O,b,F,g){const m=O.value,q=B(Q,O),R=B(Q,O);O.value+=4;const X=B(Q,O);if(O.value+=4,q<0||q>=A||R<0||R>=A)throw new Error("Wrong HUF_ENCSIZE");const C=new Array(A),L=new Array(j);!function(P){for(let Q=0;Q<j;Q++)P[Q]={},P[Q].len=0,P[Q].lit=0,P[Q].p=null}(L);if(d(P,O,b-(O.value-m),q,R,C),X>8*(b-(O.value-m)))throw new Error("Wrong hufUncompress");!function(P,Q,O,b){for(;Q<=O;Q++){const O=f(P[Q]),F=N(P[Q]);if(O>>F)throw new Error("Invalid table entry");if(F>G){const P=b[O>>F-G];if(P.len)throw new Error("Invalid table entry");if(P.lit++,P.p){const Q=P.p;P.p=new Array(P.lit);for(let O=0;O<P.lit-1;++O)P.p[O]=Q[O]}else P.p=new Array(1);P.p[P.lit-1]=Q}else if(F){let P=0;for(let g=1<<G-F;g>0;g--){const g=b[(O<<G-F)+P];if(g.len||g.p)throw new Error("Invalid table entry");g.len=F,g.lit=Q,P++}}}}(C,q,R,L),function(P,Q,O,b,F,g,m,q,R){let X=0,C=0;const L=m,A=Math.trunc(b.value+(F+7)/8);for(;b.value<A;){let F=Y(X,C,O,b);for(X=F.c,C=F.lc;C>=G;){const m=Q[X>>C-G&w];if(m.len){C-=m.len;const P=p(m.lit,g,X,C,O,b,q,R,L);P&&(X=P.c,C=P.lc)}else{if(!m.p)throw new Error("hufDecode issues");let Q;for(Q=0;Q<m.lit;Q++){const G=N(P[m.p[Q]]);for(;C<G&&b.value<A;)F=Y(X,C,O,b),X=F.c,C=F.lc;if(C>=G&&f(P[m.p[Q]])==(X>>C-G&(1<<G)-1)){C-=G;const P=p(m.p[Q],g,X,C,O,b,q,R,L);P&&(X=P.c,C=P.lc);break}}if(Q==m.lit)throw new Error("HufDecode issues")}}}const j=8-F&7;for(X>>=j,C-=j;C>0;){const P=Q[X<<G-C&w];if(!P.len)throw new Error("HufDecode issues");{C-=P.len;const Q=p(P.lit,g,X,C,O,b,q,R,L);Q&&(X=Q.c,C=Q.lc)}}}(C,L,P,O,X,R,g,F,{value:0})}function Z(P){return 65535&P}function U(P){const Q=Z(P);return Q>32767?Q-65536:Q}function E(P,Q){const O=U(P),b=U(Q),F=O+(1&b)+(b>>1);return{a:F,b:F-b}}function k(P,Q){const O=Z(P),b=Z(Q),F=O-(b>>1)&e;return{a:b+F-J&e,b:F}}function v(P,Q,O,b,F,g,m){const q=m<16384,R=O>F?F:O;let X,C,L=1;for(;L<=R;)L<<=1;for(L>>=1,X=L,L>>=1;L>=1;){C=0;const m=C+g*(F-X),R=g*L,G=g*X,A=b*L,j=b*X;let w,W,r,K;for(;C<=m;C+=G){let F=C;const g=C+b*(O-X);for(;F<=g;F+=j){const O=F+A,b=F+R,g=b+A;if(q){let m=E(P[F+Q],P[b+Q]);w=m.a,r=m.b,m=E(P[O+Q],P[g+Q]),W=m.a,K=m.b,m=E(w,W),P[F+Q]=m.a,P[O+Q]=m.b,m=E(r,K),P[b+Q]=m.a,P[g+Q]=m.b}else{let m=k(P[F+Q],P[b+Q]);w=m.a,r=m.b,m=k(P[O+Q],P[g+Q]),W=m.a,K=m.b,m=k(w,W),P[F+Q]=m.a,P[O+Q]=m.b,m=k(r,K),P[b+Q]=m.a,P[g+Q]=m.b}}if(O&L){const O=F+R;let b;b=q?E(P[F+Q],P[O+Q]):k(P[F+Q],P[O+Q]),w=b.a,P[O+Q]=b.b,P[F+Q]=w}}if(F&L){let F=C;const g=C+b*(O-X);for(;F<=g;F+=j){const O=F+A;let b;b=q?E(P[F+Q],P[O+Q]):k(P[F+Q],P[O+Q]),w=b.a,P[O+Q]=b.b,P[F+Q]=w}}X=L,L>>=1}return C}function PP(P){return new DataView(P.array.buffer,P.offset.value,P.size)}function QP(P){const Q=P.viewer.buffer.slice(P.offset.value,P.offset.value+P.size),O=new Uint8Array(function(P){let Q=P.byteLength;const O=[];let b=0;const F=new DataView(P);for(;Q>0;){const P=F.getInt8(b++);if(P<0){const g=-P;Q-=g+1;for(let P=0;P<g;P++)O.push(F.getUint8(b++))}else{const g=P;Q-=2;const m=F.getUint8(b++);for(let P=0;P<g+1;P++)O.push(m)}}return O}(Q)),b=new Uint8Array(O.length);return c(O),h(O,b),new DataView(b.buffer)}function OP(P){const Q=P.array.slice(P.offset.value,P.offset.value+P.size),O=fflate.unzlibSync(Q),b=new Uint8Array(O.length);return c(O),h(O,b),new DataView(b.buffer)}function bP(P){const Q=P.array.slice(P.offset.value,P.offset.value+P.size),O=fflate.unzlibSync(Q),b=P.lines*P.channels*P.width,F=1==P.type?new Uint16Array(b):new Uint32Array(b);let g=0,m=0;const q=new Array(4);for(let R=0;R<P.lines;R++)for(let Q=0;Q<P.channels;Q++){let Q=0;switch(P.type){case 1:q[0]=g,q[1]=q[0]+P.width,g=q[1]+P.width;for(let b=0;b<P.width;++b){Q+=O[q[0]++]<<8|O[q[1]++],F[m]=Q,m++}break;case 2:q[0]=g,q[1]=q[0]+P.width,q[2]=q[1]+P.width,g=q[2]+P.width;for(let b=0;b<P.width;++b){Q+=O[q[0]++]<<24|O[q[1]++]<<16|O[q[2]++]<<8,F[m]=Q,m++}}}return new DataView(F.buffer)}function FP(P){const Q=P.viewer,O={value:P.offset.value},b=new Uint16Array(P.width*P.scanlineBlockSize*(P.channels*P.type)),F=new Uint8Array(L);let g=0;const m=new Array(P.channels);for(let R=0;R<P.channels;R++)m[R]={},m[R].start=g,m[R].end=m[R].start,m[R].nx=P.width,m[R].ny=P.lines,m[R].size=P.type,g+=m[R].nx*m[R].ny*m[R].size;const q=l(Q,O),X=l(Q,O);if(X>=L)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(q<=X)for(let R=0;R<X-q+1;R++)F[R+q]=I(Q,O);const G=new Uint16Array(C),A=function(P,Q){let O=0;for(let F=0;F<C;++F)(0==F||P[F>>3]&1<<(7&F))&&(Q[O++]=F);const b=O-1;for(;O<C;)Q[O++]=0;return b}(F,G),j=B(Q,O);n(P.array,Q,O,j,b,g);for(let R=0;R<P.channels;++R){const P=m[R];for(let Q=0;Q<m[R].size;++Q)v(b,P.start+Q,P.nx,P.size,P.ny,P.nx*P.size,A)}!function(P,Q,O){for(let b=0;b<O;++b)Q[b]=P[Q[b]]}(G,b,g);let w=0;const W=new Uint8Array(b.buffer.byteLength);for(let C=0;C<P.lines;C++)for(let Q=0;Q<P.channels;Q++){const P=m[Q],O=P.nx*P.size,F=new Uint8Array(b.buffer,P.end*R,O*R);W.set(F,w),w+=O*R,P.end+=O}return new DataView(W.buffer)}var gP,mP=O(545);!function(P){P[P.Float=0]="Float",P[P.HalfFloat=1]="HalfFloat"}(gP||(gP={}));class qP{}async function RP(P,Q,O,b){const F={size:0,viewer:Q,array:new Uint8Array(Q.buffer),offset:O,width:P.dataWindow.xMax-P.dataWindow.xMin+1,height:P.dataWindow.yMax-P.dataWindow.yMin+1,channels:P.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(P.compression){case T.NO_COMPRESSION:F.lines=1,F.uncompress=PP;break;case T.RLE_COMPRESSION:F.lines=1,F.uncompress=QP;break;case T.ZIPS_COMPRESSION:F.lines=1,F.uncompress=OP,await mP.d.LoadScriptAsync(qP.FFLATEUrl);break;case T.ZIP_COMPRESSION:F.lines=16,F.uncompress=OP,await mP.d.LoadScriptAsync(qP.FFLATEUrl);break;case T.PIZ_COMPRESSION:F.lines=32,F.uncompress=FP;break;case T.PXR24_COMPRESSION:F.lines=16,F.uncompress=bP,await mP.d.LoadScriptAsync(qP.FFLATEUrl);break;default:throw new Error(T[P.compression]+" is unsupported")}F.scanlineBlockSize=F.lines;const g={};for(const m of P.channels)switch(m.name){case"R":case"G":case"B":case"A":case"Y":g[m.name]=!0,F.type=m.pixelType}let q=!1;if(g.R&&g.G&&g.B&&g.A)F.outputChannels=4,F.decodeChannels={R:0,G:1,B:2,A:3};else if(g.R&&g.G&&g.B)q=!0,F.outputChannels=4,F.decodeChannels={R:0,G:1,B:2,A:3};else if(g.R&&g.G)F.outputChannels=2,F.decodeChannels={R:0,G:1};else if(g.R)F.outputChannels=1,F.decodeChannels={R:0};else{if(!g.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");F.outputChannels=1,F.decodeChannels={Y:0}}if(1===F.type)switch(b){case gP.Float:F.getter=z,F.inputSize=R;break;case gP.HalfFloat:F.getter=l,F.inputSize=R}else{if(2!==F.type)throw new Error("Unsupported pixelType "+F.type+" for "+P.compression);switch(b){case gP.Float:F.getter=o,F.inputSize=m;break;case gP.HalfFloat:F.getter=a,F.inputSize=m}}F.blockCount=F.height/F.scanlineBlockSize;for(let m=0;m<F.blockCount;m++)S(Q,O);const X=F.width*F.height*F.outputChannels;switch(b){case gP.Float:F.byteArray=new Float32Array(X),F.textureType=1,q&&F.byteArray.fill(1,0,X);break;case gP.HalfFloat:F.byteArray=new Uint16Array(X),F.textureType=2,q&&F.byteArray.fill(15360,0,X);break;default:throw new Error("Unsupported type: "+b)}let C=0;for(const m of P.channels)void 0!==F.decodeChannels[m.name]&&(F.channelLineOffsets[m.name]=C*F.width),C+=2*m.pixelType;return F.bytesPerLine=F.width*C,F.outLineWidth=F.width*F.outputChannels,"INCREASING_Y"===P.lineOrder?F.scanOrder=P=>P:F.scanOrder=P=>F.height-1-P,4==F.outputChannels?(F.format=5,F.linearSpace=!0):(F.format=6,F.linearSpace=!1),F}function XP(P,Q,O,b){const F={value:0};for(let g=0;g<P.height/P.scanlineBlockSize;g++){const m=t(O,b)-Q.dataWindow.yMin;P.size=B(O,b),P.lines=m+P.scanlineBlockSize>P.height?P.height-m:P.scanlineBlockSize;const q=P.size<P.lines*P.bytesPerLine&&P.uncompress?P.uncompress(P):PP(P);b.value+=P.size;for(let O=0;O<P.scanlineBlockSize;O++){const b=g*P.scanlineBlockSize,m=O+P.scanOrder(b);if(m>=P.height)continue;const R=O*P.bytesPerLine,X=(P.height-1-m)*P.outLineWidth;for(let O=0;O<P.channels;O++){const b=Q.channels[O].name,g=P.channelLineOffsets[b],m=P.decodeChannels[b];if(void 0!==m){F.value=R+g;for(let Q=0;Q<P.width;Q++){const O=X+Q*P.outputChannels+m;P.byteArray&&(P.byteArray[O]=P.getter(q,F))}}}}}}qP.DefaultOutputType=gP.HalfFloat,qP.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class CP{constructor(){this.supportCascades=!1}loadCubeData(P,Q,O,b,F){throw".exr not supported in Cube."}loadData(P,Q,O){const F=new DataView(P.buffer),g={value:0},m=s(F,g);RP(m,F,g,qP.DefaultOutputType).then((P=>{XP(P,m,F,g);const b=m.dataWindow.xMax-m.dataWindow.xMin+1,q=m.dataWindow.yMax-m.dataWindow.yMin+1;O(b,q,Q.generateMipMaps,!1,(()=>{const O=Q.getEngine();Q.format=m.format,Q.type=P.textureType,Q.invertY=!1,Q._gammaSpace=!m.linearSpace,P.byteArray&&O._uploadDataToTextureDirectly(Q,P.byteArray,0,0,void 0,!0)}))})).catch((P=>{b.d.Error("Failed to load EXR texture: ",P)}))}}async function LP(P){const Q=new DataView(P),O={value:0},F=s(Q,O);try{const P=await RP(F,Q,O,gP.Float);return XP(P,F,Q,O),P.byteArray?{width:F.dataWindow.xMax-F.dataWindow.xMin+1,height:F.dataWindow.yMax-F.dataWindow.yMin+1,data:new Float32Array(P.byteArray)}:(b.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(g){b.d.Error("Failed to load EXR data: ",g)}return{width:0,height:0,data:null}}}}]);