"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12750:(R,q,L)=>{L.r(q),L.d(q,{_HDRTextureLoader:()=>C});var B=L(11081);class N{static ConvertPanoramaToCubemap(R,q,L,B){let N=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!R)throw"ConvertPanoramaToCubemap: input cannot be null";if(R.length!=q*L*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(B,this.FACE_FRONT,R,q,L,N),back:this.CreateCubemapTexture(B,this.FACE_BACK,R,q,L,N),left:this.CreateCubemapTexture(B,this.FACE_LEFT,R,q,L,N),right:this.CreateCubemapTexture(B,this.FACE_RIGHT,R,q,L,N),up:this.CreateCubemapTexture(B,this.FACE_UP,R,q,L,N),down:this.CreateCubemapTexture(B,this.FACE_DOWN,R,q,L,N),size:B,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(R,q,L,B,N){let h=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const Z=new ArrayBuffer(R*R*4*3),z=new Float32Array(Z),Y=h?Math.max(1,Math.round(B/4/R)):1,F=1/Y,C=F*F,e=q[1].Bc(q[0]).scale(F/R),y=q[3].Bc(q[2]).scale(F/R),U=1/R;let n=0;for(let r=0;r<R;r++)for(let h=0;h<Y;h++){let h=q[0],Z=q[2];for(let q=0;q<R;q++)for(let F=0;F<Y;F++){const Y=Z.Bc(h).scale(n).add(h);Y.normalize();const F=this.CalcProjectionSpherical(Y,L,B,N);z[r*R*3+3*q+0]+=F.r*C,z[r*R*3+3*q+1]+=F.g*C,z[r*R*3+3*q+2]+=F.b*C,h=h.add(e),Z=Z.add(y)}n+=U*F}return z}static CalcProjectionSpherical(R,q,L,B){let N=Math.atan2(R.z,R.x);const h=Math.acos(R.y);for(;N<-Math.PI;)N+=2*Math.PI;for(;N>Math.PI;)N-=2*Math.PI;let Z=N/Math.PI;const z=h/Math.PI;Z=.5*Z+.5;let Y=Math.round(Z*L);Y<0?Y=0:Y>=L&&(Y=L-1);let F=Math.round(z*B);F<0?F=0:F>=B&&(F=B-1);const C=B-F-1;return{r:q[C*L*3+3*Y+0],g:q[C*L*3+3*Y+1],b:q[C*L*3+3*Y+2]}}}function h(R,q,L,B,N,h){N>0?(N=function(R,q){return q>1023?R*Math.pow(2,1023)*Math.pow(2,q-1023):q<-1074?R*Math.pow(2,-1074)*Math.pow(2,q+1074):R*Math.pow(2,q)}(1,N-136),R[h+0]=q*N,R[h+1]=L*N,R[h+2]=B*N):(R[h+0]=0,R[h+1]=0,R[h+2]=0)}function Z(R,q){let L="",B="";for(let N=q;N<R.length-q&&(B=String.fromCharCode(R[N]),"\n"!=B);N++)L+=B;return L}function z(R){let q=0,L=0,B=Z(R,0);if("#"!=B[0]||"?"!=B[1])throw"Bad HDR Format.";let N=!1,h=!1,z=0;do{z+=B.length+1,B=Z(R,z),"FORMAT=32-bit_rle_rgbe"==B?h=!0:0==B.length&&(N=!0)}while(!N);if(!h)throw"HDR Bad header format, unsupported FORMAT";z+=B.length+1,B=Z(R,z);const Y=/^-Y (.*) \+X (.*)$/g.exec(B);if(!Y||Y.length<3)throw"HDR Bad header format, no size";if(L=parseInt(Y[2]),q=parseInt(Y[1]),L<8||L>32767)throw"HDR Bad header format, unsupported size";return z+=B.length+1,{height:q,width:L,dataPosition:z}}function Y(R,q){return function(R,q){let L=q.height;const B=q.width;let N,Z,z,Y,C,e=q.dataPosition,y=0,U=0,n=0;const r=new ArrayBuffer(4*B),p=new Uint8Array(r),c=new ArrayBuffer(q.width*q.height*4*3),d=new Float32Array(c);for(;L>0;){if(N=R[e++],Z=R[e++],z=R[e++],Y=R[e++],2!=N||2!=Z||128&z||q.width<8||q.width>32767)return F(R,q);if((z<<8|Y)!=B)throw"HDR Bad header format, wrong scan line width";for(y=0,n=0;n<4;n++)for(U=(n+1)*B;y<U;)if(N=R[e++],Z=R[e++],N>128){if(C=N-128,0==C||C>U-y)throw"HDR Bad Format, bad scanline data (run)";for(;C-- >0;)p[y++]=Z}else{if(C=N,0==C||C>U-y)throw"HDR Bad Format, bad scanline data (non-run)";if(p[y++]=Z,--C>0)for(let q=0;q<C;q++)p[y++]=R[e++]}for(n=0;n<B;n++)N=p[n],Z=p[n+B],z=p[n+2*B],Y=p[n+3*B],h(d,N,Z,z,Y,(q.height-L)*B*3+3*n);L--}return d}(R,q)}function F(R,q){let L=q.height;const B=q.width;let N,Z,z,Y,F,C=q.dataPosition;const e=new ArrayBuffer(q.width*q.height*4*3),y=new Float32Array(e);for(;L>0;){for(F=0;F<q.width;F++)N=R[C++],Z=R[C++],z=R[C++],Y=R[C++],h(y,N,Z,z,Y,(q.height-L)*B*3+3*F);L--}return y}N.FACE_LEFT=[new B.m(-1,-1,-1),new B.m(1,-1,-1),new B.m(-1,1,-1),new B.m(1,1,-1)],N.FACE_RIGHT=[new B.m(1,-1,1),new B.m(-1,-1,1),new B.m(1,1,1),new B.m(-1,1,1)],N.FACE_FRONT=[new B.m(1,-1,-1),new B.m(1,-1,1),new B.m(1,1,-1),new B.m(1,1,1)],N.FACE_BACK=[new B.m(-1,-1,1),new B.m(-1,-1,-1),new B.m(-1,1,1),new B.m(-1,1,-1)],N.FACE_DOWN=[new B.m(1,1,-1),new B.m(1,1,1),new B.m(-1,1,-1),new B.m(-1,1,1)],N.FACE_UP=[new B.m(-1,-1,-1),new B.m(-1,-1,1),new B.m(1,-1,-1),new B.m(1,-1,1)];class C{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(R,q,L){const B=new Uint8Array(R.buffer,R.byteOffset,R.byteLength),N=z(B),h=Y(B,N),Z=N.width*N.height,F=new Float32Array(4*Z);for(let z=0;z<Z;z+=1)F[4*z]=h[3*z],F[4*z+1]=h[3*z+1],F[4*z+2]=h[3*z+2],F[4*z+3]=1;L(N.width,N.height,q.generateMipMaps,!1,(()=>{const R=q.getEngine();q.type=1,q.format=5,q._gammaSpace=!1,R._uploadDataToTextureDirectly(q,F)}))}}}}]);