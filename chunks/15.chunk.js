"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{2581:(n,k,T)=>{T.r(k),T.d(k,{ReadExrDataAsync:()=>Pn,_ExrTextureLoader:()=>Sn});var c=T(556),K=T(747);const Q=4,G=4,w=1,E=2,I=8,S=65536,P=S>>3,W=14,J=65537,H=1<<W,s=H-1,b=59,C=63,z=2+C-b;var r,q;!function(n){n[n.NO_COMPRESSION=0]="NO_COMPRESSION",n[n.RLE_COMPRESSION=1]="RLE_COMPRESSION",n[n.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",n[n.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",n[n.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",n[n.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(r||(r={})),function(n){n[n.INCREASING_Y=0]="INCREASING_Y",n[n.DECREASING_Y=1]="DECREASING_Y"}(q||(q={}));const O=function(){const n=new ArrayBuffer(4),k=new Float32Array(n),T=new Uint32Array(n),c=new Uint32Array(512),K=new Uint32Array(512);for(let E=0;E<256;++E){const n=E-127;n<-27?(c[E]=0,c[256|E]=32768,K[E]=24,K[256|E]=24):n<-14?(c[E]=1024>>-n-14,c[256|E]=1024>>-n-14|32768,K[E]=-n-1,K[256|E]=-n-1):n<=15?(c[E]=n+15<<10,c[256|E]=n+15<<10|32768,K[E]=13,K[256|E]=13):n<128?(c[E]=31744,c[256|E]=64512,K[E]=24,K[256|E]=24):(c[E]=31744,c[256|E]=64512,K[E]=13,K[256|E]=13)}const Q=new Uint32Array(2048),G=new Uint32Array(64),w=new Uint32Array(64);for(let E=1;E<1024;++E){let n=E<<13,k=0;for(;0===(8388608&n);)n<<=1,k-=8388608;n&=-8388609,k+=947912704,Q[E]=n|k}for(let E=1024;E<2048;++E)Q[E]=939524096+(E-1024<<13);for(let E=1;E<31;++E)G[E]=E<<23;G[31]=1199570944,G[32]=2147483648;for(let E=33;E<63;++E)G[E]=2147483648+(E-32<<23);G[63]=3347054592;for(let E=1;E<64;++E)32!==E&&(w[E]=1024);return{floatView:k,uint32View:T,baseTable:c,shiftTable:K,mantissaTable:Q,exponentTable:G,offsetTable:w}}();function u(n,k){const T=new Uint8Array(n);let c=0;for(;0!=T[k.value+c];)c+=1;const K=(new TextDecoder).decode(T.slice(k.value,k.value+c));return k.value=k.value+c+1,K}function f(n,k){const T=n.getInt32(k.value,!0);return k.value+=Q,T}function A(n,k){const T=n.getUint32(k.value,!0);return k.value+=Q,T}function v(n,k){const T=n.getUint8(k.value);return k.value+=w,T}function F(n,k){const T=n.getUint16(k.value,!0);return k.value+=E,T}function m(n,k){const T=n[k.value];return k.value+=w,T}function x(n,k){let T;return T="getBigInt64"in DataView.prototype?Number(n.getBigInt64(k.value,!0)):n.getUint32(k.value+4,!0)+Number(n.getUint32(k.value,!0)<<32),k.value+=I,T}function g(n,k){const T=n.getFloat32(k.value,!0);return k.value+=G,T}function U(n,k){return function(n){const k=(31744&n)>>10,T=1023&n;return(n>>15?-1:1)*(k?31===k?T?NaN:1/0:Math.pow(2,k-15)*(1+T/1024):T/1024*6103515625e-14)}(F(n,k))}function V(n,k){return function(n){if(Math.abs(n)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");n=(0,K.b)(n,-65504,65504),O.floatView[0]=n;const k=O.uint32View[0],T=k>>23&511;return O.baseTable[T]+((8388607&k)>>O.shiftTable[T])}(g(n,k))}function Y(n,k,T,c){switch(T){case"string":case"stringvector":case"iccProfile":return function(n,k,T){const c=(new TextDecoder).decode(new Uint8Array(n).slice(k.value,k.value+T));return k.value=k.value+T,c}(n.buffer,k,c);case"chlist":return function(n,k,T){const c=k.value,K=[];for(;k.value<c+T-1;){const T=u(n.buffer,k),c=f(n,k),Q=v(n,k);k.value+=3;const G=f(n,k),w=f(n,k);K.push({name:T,pixelType:c,pLinear:Q,xSampling:G,ySampling:w})}return k.value+=1,K}(n,k,c);case"chromaticities":return function(n,k){return{redX:g(n,k),redY:g(n,k),greenX:g(n,k),greenY:g(n,k),blueX:g(n,k),blueY:g(n,k),whiteX:g(n,k),whiteY:g(n,k)}}(n,k);case"compression":return function(n,k){return v(n,k)}(n,k);case"box2i":return function(n,k){return{xMin:f(n,k),yMin:f(n,k),xMax:f(n,k),yMax:f(n,k)}}(n,k);case"lineOrder":return function(n,k){const T=v(n,k);return q[T]}(n,k);case"float":return g(n,k);case"v2f":return function(n,k){return[g(n,k),g(n,k)]}(n,k);case"v3f":return function(n,k){return[g(n,k),g(n,k),g(n,k)]}(n,k);case"int":return f(n,k);case"rational":return function(n,k){return[f(n,k),A(n,k)]}(n,k);case"timecode":return function(n,k){return[A(n,k),A(n,k)]}(n,k);case"preview":return k.value+=c,"skipped";default:return void(k.value+=c)}}function Z(n){for(let k=1;k<n.length;k++){const T=n[k-1]+n[k]-128;n[k]=T}}function e(n,k){let T=0,c=Math.floor((n.length+1)/2),K=0;const Q=n.length-1;for(;!(K>Q)&&(k[K++]=n[T++],!(K>Q));)k[K++]=n[c++]}const d=20000630;function l(n,k){if(n.getUint32(0,!0)!=d)throw new Error("Incorrect OpenEXR format");const T=n.getUint8(4),K=n.getUint8(5),Q={singleTile:!!(2&K),longName:!!(4&K),deepFormat:!!(8&K),multiPart:!!(16&K)};k.value=8;const G={};let w=!0;for(;w;){const T=u(n.buffer,k);if(T){const K=u(n.buffer,k),Q=Y(n,k,K,A(n,k));void 0===Q?c.d.Warn(`Unknown header attribute type ${K}'.`):G[T]=Q}else w=!1}if(0!=(-5&K))throw new Error("Unsupported file format");return{version:T,spec:Q,...G}}const i=32768,B=65535;function t(n,k,T,c,K){for(;T<n;)k=k<<8|m(c,K),T+=8;return{l:k>>(T-=n)&(1<<n)-1,c:k,lc:T}}function M(n,k,T,c){return{c:n=n<<8|m(T,c),lc:k+=8}}function o(n,k,T,c,K,Q,G,w,E){if(n==k){if(c<8){const n=M(T,c,K,Q);T=n.c,c=n.lc}let n=T>>(c-=8);if(n=new Uint8Array([n])[0],w.value+n>E)return null;const k=G[w.value-1];for(;n-- >0;)G[w.value++]=k}else{if(!(w.value<E))return null;G[w.value++]=n}return{c:T,lc:c}}const D=new Array(59);function R(n,k,T,c,K,Q){const G=k;let w=0,E=0;for(;c<=K;c++){if(G.value-k.value>T)return;let I=t(6,w,E,n,G);const S=I.l;if(w=I.c,E=I.lc,Q[c]=S,S==C){if(G.value-k.value>T)throw new Error("Error in HufUnpackEncTable");I=t(8,w,E,n,G);let S=I.l+z;if(w=I.c,E=I.lc,c+S>K+1)throw new Error("Error in HufUnpackEncTable");for(;S--;)Q[c++]=0;c--}else if(S>=b){let n=S-b+2;if(c+n>K+1)throw new Error("Error in HufUnpackEncTable");for(;n--;)Q[c++]=0;c--}}!function(n){for(let T=0;T<=58;++T)D[T]=0;for(let T=0;T<J;++T)D[n[T]]+=1;let k=0;for(let T=58;T>0;--T){const n=k+D[T]>>1;D[T]=k,k=n}for(let T=0;T<J;++T){const k=n[T];k>0&&(n[T]=k|D[k]++<<6)}}(Q)}function L(n){return 63&n}function h(n){return n>>6}function j(n,k,T,c,K,Q){const G=T.value,w=A(k,T),E=A(k,T);T.value+=4;const I=A(k,T);if(T.value+=4,w<0||w>=J||E<0||E>=J)throw new Error("Wrong HUF_ENCSIZE");const S=new Array(J),P=new Array(H);!function(n){for(let k=0;k<H;k++)n[k]={},n[k].len=0,n[k].lit=0,n[k].p=null}(P);if(R(n,T,c-(T.value-G),w,E,S),I>8*(c-(T.value-G)))throw new Error("Wrong hufUncompress");!function(n,k,T,c){for(;k<=T;k++){const T=h(n[k]),K=L(n[k]);if(T>>K)throw new Error("Invalid table entry");if(K>W){const n=c[T>>K-W];if(n.len)throw new Error("Invalid table entry");if(n.lit++,n.p){const k=n.p;n.p=new Array(n.lit);for(let T=0;T<n.lit-1;++T)n.p[T]=k[T]}else n.p=new Array(1);n.p[n.lit-1]=k}else if(K){let n=0;for(let Q=1<<W-K;Q>0;Q--){const Q=c[(T<<W-K)+n];if(Q.len||Q.p)throw new Error("Invalid table entry");Q.len=K,Q.lit=k,n++}}}}(S,w,E,P),function(n,k,T,c,K,Q,G,w,E){let I=0,S=0;const P=G,J=Math.trunc(c.value+(K+7)/8);for(;c.value<J;){let K=M(I,S,T,c);for(I=K.c,S=K.lc;S>=W;){const G=k[I>>S-W&s];if(G.len){S-=G.len;const n=o(G.lit,Q,I,S,T,c,w,E,P);n&&(I=n.c,S=n.lc)}else{if(!G.p)throw new Error("hufDecode issues");let k;for(k=0;k<G.lit;k++){const W=L(n[G.p[k]]);for(;S<W&&c.value<J;)K=M(I,S,T,c),I=K.c,S=K.lc;if(S>=W&&h(n[G.p[k]])==(I>>S-W&(1<<W)-1)){S-=W;const n=o(G.p[k],Q,I,S,T,c,w,E,P);n&&(I=n.c,S=n.lc);break}}if(k==G.lit)throw new Error("HufDecode issues")}}}const H=8-K&7;for(I>>=H,S-=H;S>0;){const n=k[I<<W-S&s];if(!n.len)throw new Error("HufDecode issues");{S-=n.len;const k=o(n.lit,Q,I,S,T,c,w,E,P);k&&(I=k.c,S=k.lc)}}}(S,P,n,T,I,E,Q,K,{value:0})}function p(n){return 65535&n}function a(n){const k=p(n);return k>32767?k-65536:k}function X(n,k){const T=a(n),c=a(k),K=T+(1&c)+(c>>1);return{a:K,b:K-c}}function y(n,k){const T=p(n),c=p(k),K=T-(c>>1)&B;return{a:c+K-i&B,b:K}}function N(n,k,T,c,K,Q,G){const w=G<16384,E=T>K?K:T;let I,S,P=1;for(;P<=E;)P<<=1;for(P>>=1,I=P,P>>=1;P>=1;){S=0;const G=S+Q*(K-I),E=Q*P,W=Q*I,J=c*P,H=c*I;let s,b,C,z;for(;S<=G;S+=W){let K=S;const Q=S+c*(T-I);for(;K<=Q;K+=H){const T=K+J,c=K+E,Q=c+J;if(w){let G=X(n[K+k],n[c+k]);s=G.a,C=G.b,G=X(n[T+k],n[Q+k]),b=G.a,z=G.b,G=X(s,b),n[K+k]=G.a,n[T+k]=G.b,G=X(C,z),n[c+k]=G.a,n[Q+k]=G.b}else{let G=y(n[K+k],n[c+k]);s=G.a,C=G.b,G=y(n[T+k],n[Q+k]),b=G.a,z=G.b,G=y(s,b),n[K+k]=G.a,n[T+k]=G.b,G=y(C,z),n[c+k]=G.a,n[Q+k]=G.b}}if(T&P){const T=K+E;let c;c=w?X(n[K+k],n[T+k]):y(n[K+k],n[T+k]),s=c.a,n[T+k]=c.b,n[K+k]=s}}if(K&P){let K=S;const Q=S+c*(T-I);for(;K<=Q;K+=H){const T=K+J;let c;c=w?X(n[K+k],n[T+k]):y(n[K+k],n[T+k]),s=c.a,n[T+k]=c.b,n[K+k]=s}}I=P,P>>=1}return S}function nn(n){return new DataView(n.array.buffer,n.offset.value,n.size)}function kn(n){const k=n.viewer.buffer.slice(n.offset.value,n.offset.value+n.size),T=new Uint8Array(function(n){let k=n.byteLength;const T=[];let c=0;const K=new DataView(n);for(;k>0;){const n=K.getInt8(c++);if(n<0){const Q=-n;k-=Q+1;for(let n=0;n<Q;n++)T.push(K.getUint8(c++))}else{const Q=n;k-=2;const G=K.getUint8(c++);for(let n=0;n<Q+1;n++)T.push(G)}}return T}(k)),c=new Uint8Array(T.length);return Z(T),e(T,c),new DataView(c.buffer)}function Tn(n){const k=n.array.slice(n.offset.value,n.offset.value+n.size),T=fflate.unzlibSync(k),c=new Uint8Array(T.length);return Z(T),e(T,c),new DataView(c.buffer)}function cn(n){const k=n.array.slice(n.offset.value,n.offset.value+n.size),T=fflate.unzlibSync(k),c=n.lines*n.channels*n.width,K=1==n.type?new Uint16Array(c):new Uint32Array(c);let Q=0,G=0;const w=new Array(4);for(let E=0;E<n.lines;E++)for(let k=0;k<n.channels;k++){let k=0;switch(n.type){case 1:w[0]=Q,w[1]=w[0]+n.width,Q=w[1]+n.width;for(let c=0;c<n.width;++c){k+=T[w[0]++]<<8|T[w[1]++],K[G]=k,G++}break;case 2:w[0]=Q,w[1]=w[0]+n.width,w[2]=w[1]+n.width,Q=w[2]+n.width;for(let c=0;c<n.width;++c){k+=T[w[0]++]<<24|T[w[1]++]<<16|T[w[2]++]<<8,K[G]=k,G++}}}return new DataView(K.buffer)}function Kn(n){const k=n.viewer,T={value:n.offset.value},c=new Uint16Array(n.width*n.scanlineBlockSize*(n.channels*n.type)),K=new Uint8Array(P);let Q=0;const G=new Array(n.channels);for(let E=0;E<n.channels;E++)G[E]={},G[E].start=Q,G[E].end=G[E].start,G[E].nx=n.width,G[E].ny=n.lines,G[E].size=n.type,Q+=G[E].nx*G[E].ny*G[E].size;const w=F(k,T),I=F(k,T);if(I>=P)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(w<=I)for(let E=0;E<I-w+1;E++)K[E+w]=v(k,T);const W=new Uint16Array(S),J=function(n,k){let T=0;for(let K=0;K<S;++K)(0==K||n[K>>3]&1<<(7&K))&&(k[T++]=K);const c=T-1;for(;T<S;)k[T++]=0;return c}(K,W),H=A(k,T);j(n.array,k,T,H,c,Q);for(let E=0;E<n.channels;++E){const n=G[E];for(let k=0;k<G[E].size;++k)N(c,n.start+k,n.nx,n.size,n.ny,n.nx*n.size,J)}!function(n,k,T){for(let c=0;c<T;++c)k[c]=n[k[c]]}(W,c,Q);let s=0;const b=new Uint8Array(c.buffer.byteLength);for(let S=0;S<n.lines;S++)for(let k=0;k<n.channels;k++){const n=G[k],T=n.nx*n.size,K=new Uint8Array(c.buffer,n.end*E,T*E);b.set(K,s),s+=T*E,n.end+=T}return new DataView(b.buffer)}var Qn,Gn=T(542);!function(n){n[n.Float=0]="Float",n[n.HalfFloat=1]="HalfFloat"}(Qn||(Qn={}));class wn{}async function En(n,k,T,c){const K={size:0,viewer:k,array:new Uint8Array(k.buffer),offset:T,width:n.dataWindow.xMax-n.dataWindow.xMin+1,height:n.dataWindow.yMax-n.dataWindow.yMin+1,channels:n.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(n.compression){case r.NO_COMPRESSION:K.lines=1,K.uncompress=nn;break;case r.RLE_COMPRESSION:K.lines=1,K.uncompress=kn;break;case r.ZIPS_COMPRESSION:K.lines=1,K.uncompress=Tn,await Gn.e.LoadScriptAsync(wn.FFLATEUrl);break;case r.ZIP_COMPRESSION:K.lines=16,K.uncompress=Tn,await Gn.e.LoadScriptAsync(wn.FFLATEUrl);break;case r.PIZ_COMPRESSION:K.lines=32,K.uncompress=Kn;break;case r.PXR24_COMPRESSION:K.lines=16,K.uncompress=cn,await Gn.e.LoadScriptAsync(wn.FFLATEUrl);break;default:throw new Error(r[n.compression]+" is unsupported")}K.scanlineBlockSize=K.lines;const Q={};for(const G of n.channels)switch(G.name){case"R":case"G":case"B":case"A":case"Y":Q[G.name]=!0,K.type=G.pixelType}let w=!1;if(Q.R&&Q.G&&Q.B&&Q.A)K.outputChannels=4,K.decodeChannels={R:0,G:1,B:2,A:3};else if(Q.R&&Q.G&&Q.B)w=!0,K.outputChannels=4,K.decodeChannels={R:0,G:1,B:2,A:3};else if(Q.R&&Q.G)K.outputChannels=2,K.decodeChannels={R:0,G:1};else if(Q.R)K.outputChannels=1,K.decodeChannels={R:0};else{if(!Q.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");K.outputChannels=1,K.decodeChannels={Y:0}}if(1===K.type)switch(c){case Qn.Float:K.getter=U,K.inputSize=E;break;case Qn.HalfFloat:K.getter=F,K.inputSize=E}else{if(2!==K.type)throw new Error("Unsupported pixelType "+K.type+" for "+n.compression);switch(c){case Qn.Float:K.getter=g,K.inputSize=G;break;case Qn.HalfFloat:K.getter=V,K.inputSize=G}}K.blockCount=K.height/K.scanlineBlockSize;for(let G=0;G<K.blockCount;G++)x(k,T);const I=K.width*K.height*K.outputChannels;switch(c){case Qn.Float:K.byteArray=new Float32Array(I),K.textureType=1,w&&K.byteArray.fill(1,0,I);break;case Qn.HalfFloat:K.byteArray=new Uint16Array(I),K.textureType=2,w&&K.byteArray.fill(15360,0,I);break;default:throw new Error("Unsupported type: "+c)}let S=0;for(const G of n.channels)void 0!==K.decodeChannels[G.name]&&(K.channelLineOffsets[G.name]=S*K.width),S+=2*G.pixelType;return K.bytesPerLine=K.width*S,K.outLineWidth=K.width*K.outputChannels,"INCREASING_Y"===n.lineOrder?K.scanOrder=n=>n:K.scanOrder=n=>K.height-1-n,4==K.outputChannels?(K.format=5,K.linearSpace=!0):(K.format=6,K.linearSpace=!1),K}function In(n,k,T,c){const K={value:0};for(let Q=0;Q<n.height/n.scanlineBlockSize;Q++){const G=f(T,c)-k.dataWindow.yMin;n.size=A(T,c),n.lines=G+n.scanlineBlockSize>n.height?n.height-G:n.scanlineBlockSize;const w=n.size<n.lines*n.bytesPerLine&&n.uncompress?n.uncompress(n):nn(n);c.value+=n.size;for(let T=0;T<n.scanlineBlockSize;T++){const c=Q*n.scanlineBlockSize,G=T+n.scanOrder(c);if(G>=n.height)continue;const E=T*n.bytesPerLine,I=(n.height-1-G)*n.outLineWidth;for(let T=0;T<n.channels;T++){const c=k.channels[T].name,Q=n.channelLineOffsets[c],G=n.decodeChannels[c];if(void 0!==G){K.value=E+Q;for(let k=0;k<n.width;k++){const T=I+k*n.outputChannels+G;n.byteArray&&(n.byteArray[T]=n.getter(w,K))}}}}}}wn.DefaultOutputType=Qn.HalfFloat,wn.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Sn{constructor(){this.supportCascades=!1}loadCubeData(n,k,T,c,K){throw".exr not supported in Cube."}loadData(n,k,T){const K=new DataView(n.buffer),Q={value:0},G=l(K,Q);En(G,K,Q,wn.DefaultOutputType).then((n=>{In(n,G,K,Q);const c=G.dataWindow.xMax-G.dataWindow.xMin+1,w=G.dataWindow.yMax-G.dataWindow.yMin+1;T(c,w,k.generateMipMaps,!1,(()=>{const T=k.getEngine();k.format=G.format,k.type=n.textureType,k.invertY=!1,k._gammaSpace=!G.linearSpace,n.byteArray&&T._uploadDataToTextureDirectly(k,n.byteArray,0,0,void 0,!0)}))})).catch((n=>{c.d.Error("Failed to load EXR texture: ",n)}))}}async function Pn(n){const k=new DataView(n),T={value:0},K=l(k,T);try{const n=await En(K,k,T,Qn.Float);return In(n,K,k,T),n.byteArray?{width:K.dataWindow.xMax-K.dataWindow.xMin+1,height:K.dataWindow.yMax-K.dataWindow.yMin+1,data:new Float32Array(n.byteArray)}:(c.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(Q){c.d.Error("Failed to load EXR data: ",Q)}return{width:0,height:0,data:null}}}}]);