"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{13102:(H,c,y)=>{y.r(c),y.d(c,{_HDRTextureLoader:()=>i});var Z=y(11092);class F{static ConvertPanoramaToCubemap(H,c,y,Z){let F=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!H)throw"ConvertPanoramaToCubemap: input cannot be null";if(H.length!=c*y*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(Z,this.FACE_FRONT,H,c,y,F),back:this.CreateCubemapTexture(Z,this.FACE_BACK,H,c,y,F),left:this.CreateCubemapTexture(Z,this.FACE_LEFT,H,c,y,F),right:this.CreateCubemapTexture(Z,this.FACE_RIGHT,H,c,y,F),up:this.CreateCubemapTexture(Z,this.FACE_UP,H,c,y,F),down:this.CreateCubemapTexture(Z,this.FACE_DOWN,H,c,y,F),size:Z,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(H,c,y,Z,F){let P=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const S=new ArrayBuffer(H*H*4*3),n=new Float32Array(S),O=P?Math.max(1,Math.round(Z/4/H)):1,a=1/O,i=a*a,C=c[1].Rc(c[0]).scale(a/H),g=c[3].Rc(c[2]).scale(a/H),v=1/H;let m=0;for(let z=0;z<H;z++)for(let P=0;P<O;P++){let P=c[0],S=c[2];for(let c=0;c<H;c++)for(let a=0;a<O;a++){const O=S.Rc(P).scale(m).add(P);O.normalize();const a=this.CalcProjectionSpherical(O,y,Z,F);n[z*H*3+3*c+0]+=a.r*i,n[z*H*3+3*c+1]+=a.g*i,n[z*H*3+3*c+2]+=a.b*i,P=P.add(C),S=S.add(g)}m+=v*a}return n}static CalcProjectionSpherical(H,c,y,Z){let F=Math.atan2(H.z,H.x);const P=Math.acos(H.y);for(;F<-Math.PI;)F+=2*Math.PI;for(;F>Math.PI;)F-=2*Math.PI;let S=F/Math.PI;const n=P/Math.PI;S=.5*S+.5;let O=Math.round(S*y);O<0?O=0:O>=y&&(O=y-1);let a=Math.round(n*Z);a<0?a=0:a>=Z&&(a=Z-1);const i=Z-a-1;return{r:c[i*y*3+3*O+0],g:c[i*y*3+3*O+1],b:c[i*y*3+3*O+2]}}}function P(H,c,y,Z,F,P){F>0?(F=function(H,c){return c>1023?H*Math.pow(2,1023)*Math.pow(2,c-1023):c<-1074?H*Math.pow(2,-1074)*Math.pow(2,c+1074):H*Math.pow(2,c)}(1,F-136),H[P+0]=c*F,H[P+1]=y*F,H[P+2]=Z*F):(H[P+0]=0,H[P+1]=0,H[P+2]=0)}function S(H,c){let y="",Z="";for(let F=c;F<H.length-c&&(Z=String.fromCharCode(H[F]),"\n"!=Z);F++)y+=Z;return y}function n(H){let c=0,y=0,Z=S(H,0);if("#"!=Z[0]||"?"!=Z[1])throw"Bad HDR Format.";let F=!1,P=!1,n=0;do{n+=Z.length+1,Z=S(H,n),"FORMAT=32-bit_rle_rgbe"==Z?P=!0:0==Z.length&&(F=!0)}while(!F);if(!P)throw"HDR Bad header format, unsupported FORMAT";n+=Z.length+1,Z=S(H,n);const O=/^-Y (.*) \+X (.*)$/g.exec(Z);if(!O||O.length<3)throw"HDR Bad header format, no size";if(y=parseInt(O[2]),c=parseInt(O[1]),y<8||y>32767)throw"HDR Bad header format, unsupported size";return n+=Z.length+1,{height:c,width:y,dataPosition:n}}function O(H,c){return function(H,c){let y=c.height;const Z=c.width;let F,S,n,O,i,C=c.dataPosition,g=0,v=0,m=0;const z=new ArrayBuffer(4*Z),V=new Uint8Array(z),h=new ArrayBuffer(c.width*c.height*4*3),Q=new Float32Array(h);for(;y>0;){if(F=H[C++],S=H[C++],n=H[C++],O=H[C++],2!=F||2!=S||128&n||c.width<8||c.width>32767)return a(H,c);if((n<<8|O)!=Z)throw"HDR Bad header format, wrong scan line width";for(g=0,m=0;m<4;m++)for(v=(m+1)*Z;g<v;)if(F=H[C++],S=H[C++],F>128){if(i=F-128,0==i||i>v-g)throw"HDR Bad Format, bad scanline data (run)";for(;i-- >0;)V[g++]=S}else{if(i=F,0==i||i>v-g)throw"HDR Bad Format, bad scanline data (non-run)";if(V[g++]=S,--i>0)for(let c=0;c<i;c++)V[g++]=H[C++]}for(m=0;m<Z;m++)F=V[m],S=V[m+Z],n=V[m+2*Z],O=V[m+3*Z],P(Q,F,S,n,O,(c.height-y)*Z*3+3*m);y--}return Q}(H,c)}function a(H,c){let y=c.height;const Z=c.width;let F,S,n,O,a,i=c.dataPosition;const C=new ArrayBuffer(c.width*c.height*4*3),g=new Float32Array(C);for(;y>0;){for(a=0;a<c.width;a++)F=H[i++],S=H[i++],n=H[i++],O=H[i++],P(g,F,S,n,O,(c.height-y)*Z*3+3*a);y--}return g}F.FACE_LEFT=[new Z.n(-1,-1,-1),new Z.n(1,-1,-1),new Z.n(-1,1,-1),new Z.n(1,1,-1)],F.FACE_RIGHT=[new Z.n(1,-1,1),new Z.n(-1,-1,1),new Z.n(1,1,1),new Z.n(-1,1,1)],F.FACE_FRONT=[new Z.n(1,-1,-1),new Z.n(1,-1,1),new Z.n(1,1,-1),new Z.n(1,1,1)],F.FACE_BACK=[new Z.n(-1,-1,1),new Z.n(-1,-1,-1),new Z.n(-1,1,1),new Z.n(-1,1,-1)],F.FACE_DOWN=[new Z.n(1,1,-1),new Z.n(1,1,1),new Z.n(-1,1,-1),new Z.n(-1,1,1)],F.FACE_UP=[new Z.n(-1,-1,-1),new Z.n(-1,-1,1),new Z.n(1,-1,-1),new Z.n(1,-1,1)];class i{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(H,c,y){const Z=new Uint8Array(H.buffer,H.byteOffset,H.byteLength),F=n(Z),P=O(Z,F),S=F.width*F.height,a=new Float32Array(4*S);for(let n=0;n<S;n+=1)a[4*n]=P[3*n],a[4*n+1]=P[3*n+1],a[4*n+2]=P[3*n+2],a[4*n+3]=1;y(F.width,F.height,c.generateMipMaps,!1,(()=>{const H=c.getEngine();c.type=1,c.format=5,c._gammaSpace=!1,H._uploadDataToTextureDirectly(c,a)}))}}}}]);