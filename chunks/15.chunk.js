"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12617:(z,a,K)=>{K.r(a),K.d(a,{_HDRTextureLoader:()=>r});var v=K(10941);class T{static ConvertPanoramaToCubemap(z,a,K,v){let T=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!z)throw"ConvertPanoramaToCubemap: input cannot be null";if(z.length!=a*K*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(v,this.FACE_FRONT,z,a,K,T),back:this.CreateCubemapTexture(v,this.FACE_BACK,z,a,K,T),left:this.CreateCubemapTexture(v,this.FACE_LEFT,z,a,K,T),right:this.CreateCubemapTexture(v,this.FACE_RIGHT,z,a,K,T),up:this.CreateCubemapTexture(v,this.FACE_UP,z,a,K,T),down:this.CreateCubemapTexture(v,this.FACE_DOWN,z,a,K,T),size:v,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(z,a,K,v,T){let m=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const p=new ArrayBuffer(z*z*4*3),j=new Float32Array(p),s=m?Math.max(1,Math.round(v/4/z)):1,M=1/s,r=M*M,W=a[1].sc(a[0]).scale(M/z),F=a[3].sc(a[2]).scale(M/z),G=1/z;let l=0;for(let V=0;V<z;V++)for(let m=0;m<s;m++){let m=a[0],p=a[2];for(let a=0;a<z;a++)for(let M=0;M<s;M++){const s=p.sc(m).scale(l).add(m);s.normalize();const M=this.CalcProjectionSpherical(s,K,v,T);j[V*z*3+3*a+0]+=M.r*r,j[V*z*3+3*a+1]+=M.g*r,j[V*z*3+3*a+2]+=M.b*r,m=m.add(W),p=p.add(F)}l+=G*M}return j}static CalcProjectionSpherical(z,a,K,v){let T=Math.atan2(z.z,z.x);const m=Math.acos(z.y);for(;T<-Math.PI;)T+=2*Math.PI;for(;T>Math.PI;)T-=2*Math.PI;let p=T/Math.PI;const j=m/Math.PI;p=.5*p+.5;let s=Math.round(p*K);s<0?s=0:s>=K&&(s=K-1);let M=Math.round(j*v);M<0?M=0:M>=v&&(M=v-1);const r=v-M-1;return{r:a[r*K*3+3*s+0],g:a[r*K*3+3*s+1],b:a[r*K*3+3*s+2]}}}function m(z,a,K,v,T,m){T>0?(T=function(z,a){return a>1023?z*Math.pow(2,1023)*Math.pow(2,a-1023):a<-1074?z*Math.pow(2,-1074)*Math.pow(2,a+1074):z*Math.pow(2,a)}(1,T-136),z[m+0]=a*T,z[m+1]=K*T,z[m+2]=v*T):(z[m+0]=0,z[m+1]=0,z[m+2]=0)}function p(z,a){let K="",v="";for(let T=a;T<z.length-a&&(v=String.fromCharCode(z[T]),"\n"!=v);T++)K+=v;return K}function j(z){let a=0,K=0,v=p(z,0);if("#"!=v[0]||"?"!=v[1])throw"Bad HDR Format.";let T=!1,m=!1,j=0;do{j+=v.length+1,v=p(z,j),"FORMAT=32-bit_rle_rgbe"==v?m=!0:0==v.length&&(T=!0)}while(!T);if(!m)throw"HDR Bad header format, unsupported FORMAT";j+=v.length+1,v=p(z,j);const s=/^-Y (.*) \+X (.*)$/g.exec(v);if(!s||s.length<3)throw"HDR Bad header format, no size";if(K=parseInt(s[2]),a=parseInt(s[1]),K<8||K>32767)throw"HDR Bad header format, unsupported size";return j+=v.length+1,{height:a,width:K,dataPosition:j}}function s(z,a){return function(z,a){let K=a.height;const v=a.width;let T,p,j,s,r,W=a.dataPosition,F=0,G=0,l=0;const V=new ArrayBuffer(4*v),c=new Uint8Array(V),C=new ArrayBuffer(a.width*a.height*4*3),w=new Float32Array(C);for(;K>0;){if(T=z[W++],p=z[W++],j=z[W++],s=z[W++],2!=T||2!=p||128&j||a.width<8||a.width>32767)return M(z,a);if((j<<8|s)!=v)throw"HDR Bad header format, wrong scan line width";for(F=0,l=0;l<4;l++)for(G=(l+1)*v;F<G;)if(T=z[W++],p=z[W++],T>128){if(r=T-128,0==r||r>G-F)throw"HDR Bad Format, bad scanline data (run)";for(;r-- >0;)c[F++]=p}else{if(r=T,0==r||r>G-F)throw"HDR Bad Format, bad scanline data (non-run)";if(c[F++]=p,--r>0)for(let a=0;a<r;a++)c[F++]=z[W++]}for(l=0;l<v;l++)T=c[l],p=c[l+v],j=c[l+2*v],s=c[l+3*v],m(w,T,p,j,s,(a.height-K)*v*3+3*l);K--}return w}(z,a)}function M(z,a){let K=a.height;const v=a.width;let T,p,j,s,M,r=a.dataPosition;const W=new ArrayBuffer(a.width*a.height*4*3),F=new Float32Array(W);for(;K>0;){for(M=0;M<a.width;M++)T=z[r++],p=z[r++],j=z[r++],s=z[r++],m(F,T,p,j,s,(a.height-K)*v*3+3*M);K--}return F}T.FACE_LEFT=[new v.o(-1,-1,-1),new v.o(1,-1,-1),new v.o(-1,1,-1),new v.o(1,1,-1)],T.FACE_RIGHT=[new v.o(1,-1,1),new v.o(-1,-1,1),new v.o(1,1,1),new v.o(-1,1,1)],T.FACE_FRONT=[new v.o(1,-1,-1),new v.o(1,-1,1),new v.o(1,1,-1),new v.o(1,1,1)],T.FACE_BACK=[new v.o(-1,-1,1),new v.o(-1,-1,-1),new v.o(-1,1,1),new v.o(-1,1,-1)],T.FACE_DOWN=[new v.o(1,1,-1),new v.o(1,1,1),new v.o(-1,1,-1),new v.o(-1,1,1)],T.FACE_UP=[new v.o(-1,-1,-1),new v.o(-1,-1,1),new v.o(1,-1,-1),new v.o(1,-1,1)];class r{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(z,a,K){const v=new Uint8Array(z.buffer,z.byteOffset,z.byteLength),T=j(v),m=s(v,T),p=T.width*T.height,M=new Float32Array(4*p);for(let j=0;j<p;j+=1)M[4*j]=m[3*j],M[4*j+1]=m[3*j+1],M[4*j+2]=m[3*j+2],M[4*j+3]=1;K(T.width,T.height,a.generateMipMaps,!1,(()=>{const z=a.getEngine();a.type=1,a.format=5,a._gammaSpace=!1,z._uploadDataToTextureDirectly(a,M)}))}}}}]);