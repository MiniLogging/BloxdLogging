"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{13683:(Z,x,F)=>{F.r(x),F.d(x,{_IESTextureLoader:()=>j});var u=F(11194);function G(Z){return Z.split(" ").filter((Z=>""!==Z)).map((Z=>parseFloat(Z)))}function f(Z,x,F){for(;F.length!==x;){const x=G(Z.lines[Z.index++]);F.push(...x)}}function Y(Z,x,F){let G=0,f=0,Y=0,j=0,d=0,t=0;for(let u=0;u<Z.numberOfHorizontalAngles-1;u++)if(F<Z.horizontalAngles[u+1]||u===Z.numberOfHorizontalAngles-2){f=u,Y=Z.horizontalAngles[u],j=Z.horizontalAngles[u+1];break}for(let u=0;u<Z.numberOfVerticalAngles-1;u++)if(x<Z.verticalAngles[u+1]||u===Z.numberOfVerticalAngles-2){G=u,d=Z.verticalAngles[u],t=Z.verticalAngles[u+1];break}const o=j-Y,c=t-d;if(0===c)return 0;const s=0===o?0:(F-Y)/o,J=(x-d)/c,p=0===o?f:f+1,U=(0,u.Lerp)(Z.candelaValues[f][G],Z.candelaValues[p][G],s),k=(0,u.Lerp)(Z.candelaValues[f][G+1],Z.candelaValues[p][G+1],s);return(0,u.Lerp)(U,k,J)}class j{constructor(){this.supportCascades=!1}loadCubeData(){throw".ies not supported in Cube."}loadData(Z,x,F){const u=function(Z){const x={lines:new TextDecoder("utf-8").decode(Z).split("\n"),index:0},F={version:x.lines[0],candelaValues:[],horizontalAngles:[],verticalAngles:[],numberOfHorizontalAngles:0,numberOfVerticalAngles:0};for(x.index=1;x.lines.length>0&&!x.lines[x.index].includes("TILT=");)x.index++;x.lines[x.index].includes("INCLUDE"),x.index++;const u=G(x.lines[x.index++]);F.numberOfLights=u[0],F.lumensPerLamp=u[1],F.candelaMultiplier=u[2],F.numberOfVerticalAngles=u[3],F.numberOfHorizontalAngles=u[4],F.photometricType=u[5],F.unitsType=u[6],F.width=u[7],F.length=u[8],F.height=u[9];const j=G(x.lines[x.index++]);F.ballastFactor=j[0],F.fileGenerationType=j[1],F.inputWatts=j[2];for(let G=0;G<F.numberOfHorizontalAngles;G++)F.candelaValues[G]=[];f(x,F.numberOfVerticalAngles,F.verticalAngles),f(x,F.numberOfHorizontalAngles,F.horizontalAngles);for(let G=0;G<F.numberOfHorizontalAngles;G++)f(x,F.numberOfVerticalAngles,F.candelaValues[G]);let d=-1;for(let G=0;G<F.numberOfHorizontalAngles;G++)for(let Z=0;Z<F.numberOfVerticalAngles;Z++)F.candelaValues[G][Z]*=F.candelaValues[G][Z]*F.candelaMultiplier*F.ballastFactor*F.fileGenerationType,d=Math.max(d,F.candelaValues[G][Z]);if(d>0)for(let G=0;G<F.numberOfHorizontalAngles;G++)for(let Z=0;Z<F.numberOfVerticalAngles;Z++)F.candelaValues[G][Z]/=d;const t=180,o=360,c=new Float32Array(64800),s=F.horizontalAngles[0],J=F.horizontalAngles[F.numberOfHorizontalAngles-1];for(let G=0;G<64800;G++){let Z=G%o;const x=Math.floor(G/o);J-s!==0&&(Z<s||Z>=J)&&(Z%=2*J,Z>J&&(Z=2*J-Z)),c[x+Z*t]=Y(F,x,Z)}return{width:180,height:1,data:c}}(new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength));F(u.width,u.height,!1,!1,(()=>{const Z=x.getEngine();x.type=1,x.format=6,x._gammaSpace=!1,Z._uploadDataToTextureDirectly(x,u.data)}))}}},11194:(Z,x,F)=>{function u(Z){return parseInt(Z.toString().replace(/\W/g,""))}function G(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Z-x)<=F}function f(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Z<x-u||Z>F+u}function Y(Z,x){return Z===x?Z:Math.random()*(x-Z)+Z}function j(Z,x,F){return Z+(x-Z)*F}function d(Z,x,F){let u=k(x-Z,360);return u>180&&(u-=360),Z+u*s(F)}function t(Z,x,F){let u=0;return u=Z!=x?s((F-Z)/(x-Z)):0,u}function o(Z,x,F,u,G){const f=G*G,Y=G*f;return Z*(2*Y-3*f+1)+F*(-2*Y+3*f)+x*(Y-2*f+G)+u*(Y-f)}function c(Z,x,F,u,G){const f=G*G;return 6*(f-G)*Z+(3*f-4*G+1)*x+6*(-f+G)*F+(3*f-2*G)*u}function s(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(F,Math.max(x,Z))}function J(Z){return Z-=2*Math.PI*Math.floor((Z+Math.PI)/(2*Math.PI))}function p(Z){const x=Z.toString(16);return Z<=15?("0"+x).toUpperCase():x.toUpperCase()}function U(Z){if(Math.log2)return Math.floor(Math.log2(Z));if(Z<0)return NaN;if(0===Z)return-1/0;let x=0;if(Z<1){for(;Z<1;)x++,Z*=2;x=-x}else if(Z>1)for(;Z>1;)x++,Z=Math.floor(Z/2);return x}function k(Z,x){return Z-Math.floor(Z/x)*x}function M(Z,x,F){return(Z-x)/(F-x)}function m(Z,x,F){return Z*(F-x)+x}function C(Z,x){let F=k(x-Z,360);return F>180&&(F-=360),F}function L(Z,x){const F=k(Z,2*x);return x-Math.abs(F-x)}function H(Z,x,F){let u=s(F);return u=-2*u*u*u+3*u*u,x*u+Z*(1-u)}function S(Z,x,F){let u=0;return u=Math.abs(x-Z)<=F?x:Z+Math.sign(x-Z)*F,u}function K(Z,x,F){const u=C(Z,x);let G=0;return G=-F<u&&u<F?x:S(Z,x=Z+u,F),G}function y(Z,x,F){return(Z-x)/(F-x)}function q(Z,x,F){return(F-x)*Z+x}function R(Z,x){const F=Z%x;return 0===F?x:R(x,F)}F.r(x),F.d(x,{Clamp:()=>s,DeltaAngle:()=>C,Denormalize:()=>m,ExtractAsInt:()=>u,Hermite:()=>o,Hermite1stDerivative:()=>c,HighestCommonFactor:()=>R,ILog2:()=>U,InverseLerp:()=>t,Lerp:()=>j,LerpAngle:()=>d,MoveTowards:()=>S,MoveTowardsAngle:()=>K,Normalize:()=>M,NormalizeRadians:()=>J,OutsideRange:()=>f,PercentToRange:()=>q,PingPong:()=>L,RandomRange:()=>Y,RangeToPercent:()=>y,Repeat:()=>k,SmoothStep:()=>H,ToHex:()=>p,WithinEpsilon:()=>G})}}]);