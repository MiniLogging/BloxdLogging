"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[15],{14033:(F,P,f)=>{f.r(P),f.d(P,{_IESTextureLoader:()=>A});var c=f(11664);function N(F){return F.split(" ").filter((F=>""!==F)).map((F=>parseFloat(F)))}function q(F,P,f){for(;f.length!==P;){const P=N(F.lines[F.index++]);f.push(...P)}}function H(F,P,f){let N=0,q=0,H=0,A=0,o=0,j=0;for(let c=0;c<F.numberOfHorizontalAngles-1;c++)if(f<F.horizontalAngles[c+1]||c===F.numberOfHorizontalAngles-2){q=c,H=F.horizontalAngles[c],A=F.horizontalAngles[c+1];break}for(let c=0;c<F.numberOfVerticalAngles-1;c++)if(P<F.verticalAngles[c+1]||c===F.numberOfVerticalAngles-2){N=c,o=F.verticalAngles[c],j=F.verticalAngles[c+1];break}const i=A-H,u=j-o;if(0===u)return 0;const T=0===i?0:(f-H)/i,Y=(P-o)/u,t=0===i?q:q+1,C=(0,c.Lerp)(F.candelaValues[q][N],F.candelaValues[t][N],T),L=(0,c.Lerp)(F.candelaValues[q][N+1],F.candelaValues[t][N+1],T);return(0,c.Lerp)(C,L,Y)}class A{constructor(){this.supportCascades=!1}loadCubeData(){throw".ies not supported in Cube."}loadData(F,P,f){const c=function(F){const P={lines:new TextDecoder("utf-8").decode(F).split("\n"),index:0},f={version:P.lines[0],candelaValues:[],horizontalAngles:[],verticalAngles:[],numberOfHorizontalAngles:0,numberOfVerticalAngles:0};for(P.index=1;P.lines.length>0&&!P.lines[P.index].includes("TILT=");)P.index++;P.lines[P.index].includes("INCLUDE"),P.index++;const c=N(P.lines[P.index++]);f.numberOfLights=c[0],f.lumensPerLamp=c[1],f.candelaMultiplier=c[2],f.numberOfVerticalAngles=c[3],f.numberOfHorizontalAngles=c[4],f.photometricType=c[5],f.unitsType=c[6],f.width=c[7],f.length=c[8],f.height=c[9];const A=N(P.lines[P.index++]);f.ballastFactor=A[0],f.fileGenerationType=A[1],f.inputWatts=A[2];for(let N=0;N<f.numberOfHorizontalAngles;N++)f.candelaValues[N]=[];q(P,f.numberOfVerticalAngles,f.verticalAngles),q(P,f.numberOfHorizontalAngles,f.horizontalAngles);for(let N=0;N<f.numberOfHorizontalAngles;N++)q(P,f.numberOfVerticalAngles,f.candelaValues[N]);let o=-1;for(let N=0;N<f.numberOfHorizontalAngles;N++)for(let F=0;F<f.numberOfVerticalAngles;F++)f.candelaValues[N][F]*=f.candelaValues[N][F]*f.candelaMultiplier*f.ballastFactor*f.fileGenerationType,o=Math.max(o,f.candelaValues[N][F]);if(o>0)for(let N=0;N<f.numberOfHorizontalAngles;N++)for(let F=0;F<f.numberOfVerticalAngles;F++)f.candelaValues[N][F]/=o;const j=180,i=360,u=new Float32Array(64800),T=f.horizontalAngles[0],Y=f.horizontalAngles[f.numberOfHorizontalAngles-1];for(let N=0;N<64800;N++){let F=N%i;const P=Math.floor(N/i);Y-T!==0&&(F<T||F>=Y)&&(F%=2*Y,F>Y&&(F=2*Y-F)),u[P+F*j]=H(f,P,F)}return{width:180,height:1,data:u}}(new Uint8Array(F.buffer,F.byteOffset,F.byteLength));f(c.width,c.height,!1,!1,(()=>{const F=P.getEngine();P.type=1,P.format=6,P._gammaSpace=!1,F._uploadDataToTextureDirectly(P,c.data)}))}}},11664:(F,P,f)=>{function c(F){return parseInt(F.toString().replace(/\W/g,""))}function N(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(F-P)<=f}function q(F,P,f){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return F<P-c||F>f+c}function H(F,P){return F===P?F:Math.random()*(P-F)+F}function A(F,P,f){return F+(P-F)*f}function o(F,P,f){let c=L(P-F,360);return c>180&&(c-=360),F+c*T(f)}function j(F,P,f){let c=0;return c=F!=P?T((f-F)/(P-F)):0,c}function i(F,P,f,c,N){const q=N*N,H=N*q;return F*(2*H-3*q+1)+f*(-2*H+3*q)+P*(H-2*q+N)+c*(H-q)}function u(F,P,f,c,N){const q=N*N;return 6*(q-N)*F+(3*q-4*N+1)*P+6*(-q+N)*f+(3*q-2*N)*c}function T(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(f,Math.max(P,F))}function Y(F){return F-=2*Math.PI*Math.floor((F+Math.PI)/(2*Math.PI))}function t(F){const P=F.toString(16);return F<=15?("0"+P).toUpperCase():P.toUpperCase()}function C(F){if(Math.log2)return Math.floor(Math.log2(F));if(F<0)return NaN;if(0===F)return-1/0;let P=0;if(F<1){for(;F<1;)P++,F*=2;P=-P}else if(F>1)for(;F>1;)P++,F=Math.floor(F/2);return P}function L(F,P){return F-Math.floor(F/P)*P}function J(F,P,f){return(F-P)/(f-P)}function B(F,P,f){return F*(f-P)+P}function z(F,P){let f=L(P-F,360);return f>180&&(f-=360),f}function Z(F,P){const f=L(F,2*P);return P-Math.abs(f-P)}function R(F,P,f){let c=T(f);return c=-2*c*c*c+3*c*c,P*c+F*(1-c)}function y(F,P,f){let c=0;return c=Math.abs(P-F)<=f?P:F+Math.sign(P-F)*f,c}function O(F,P,f){const c=z(F,P);let N=0;return N=-f<c&&c<f?P:y(F,P=F+c,f),N}function d(F,P,f){return(F-P)/(f-P)}function M(F,P,f){return(f-P)*F+P}function V(F,P){const f=F%P;return 0===f?P:V(P,f)}f.r(P),f.d(P,{Clamp:()=>T,DeltaAngle:()=>z,Denormalize:()=>B,ExtractAsInt:()=>c,Hermite:()=>i,Hermite1stDerivative:()=>u,HighestCommonFactor:()=>V,ILog2:()=>C,InverseLerp:()=>j,Lerp:()=>A,LerpAngle:()=>o,MoveTowards:()=>y,MoveTowardsAngle:()=>O,Normalize:()=>J,NormalizeRadians:()=>Y,OutsideRange:()=>q,PercentToRange:()=>M,PingPong:()=>Z,RandomRange:()=>H,RangeToPercent:()=>d,Repeat:()=>L,SmoothStep:()=>R,ToHex:()=>t,WithinEpsilon:()=>N})}}]);