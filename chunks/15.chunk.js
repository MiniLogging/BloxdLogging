"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{13234:(V,p,W)=>{W.r(p),W.d(p,{_HDRTextureLoader:()=>i});var N=W(11218);class d{static ConvertPanoramaToCubemap(V,p,W,N){let d=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!V)throw"ConvertPanoramaToCubemap: input cannot be null";if(V.length!=p*W*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(N,this.FACE_FRONT,V,p,W,d),back:this.CreateCubemapTexture(N,this.FACE_BACK,V,p,W,d),left:this.CreateCubemapTexture(N,this.FACE_LEFT,V,p,W,d),right:this.CreateCubemapTexture(N,this.FACE_RIGHT,V,p,W,d),up:this.CreateCubemapTexture(N,this.FACE_UP,V,p,W,d),down:this.CreateCubemapTexture(N,this.FACE_DOWN,V,p,W,d),size:N,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(V,p,W,N,d){let E=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const z=new ArrayBuffer(V*V*4*3),S=new Float32Array(z),Q=E?Math.max(1,Math.round(N/4/V)):1,J=1/Q,i=J*J,l=p[1].ed(p[0]).scale(J/V),j=p[3].ed(p[2]).scale(J/V),k=1/V;let u=0;for(let f=0;f<V;f++)for(let E=0;E<Q;E++){let E=p[0],z=p[2];for(let p=0;p<V;p++)for(let J=0;J<Q;J++){const Q=z.ed(E).scale(u).add(E);Q.normalize();const J=this.CalcProjectionSpherical(Q,W,N,d);S[f*V*3+3*p+0]+=J.r*i,S[f*V*3+3*p+1]+=J.g*i,S[f*V*3+3*p+2]+=J.b*i,E=E.add(l),z=z.add(j)}u+=k*J}return S}static CalcProjectionSpherical(V,p,W,N){let d=Math.atan2(V.z,V.x);const E=Math.acos(V.y);for(;d<-Math.PI;)d+=2*Math.PI;for(;d>Math.PI;)d-=2*Math.PI;let z=d/Math.PI;const S=E/Math.PI;z=.5*z+.5;let Q=Math.round(z*W);Q<0?Q=0:Q>=W&&(Q=W-1);let J=Math.round(S*N);J<0?J=0:J>=N&&(J=N-1);const i=N-J-1;return{r:p[i*W*3+3*Q+0],g:p[i*W*3+3*Q+1],b:p[i*W*3+3*Q+2]}}}function E(V,p,W,N,d,E){d>0?(d=function(V,p){return p>1023?V*Math.pow(2,1023)*Math.pow(2,p-1023):p<-1074?V*Math.pow(2,-1074)*Math.pow(2,p+1074):V*Math.pow(2,p)}(1,d-136),V[E+0]=p*d,V[E+1]=W*d,V[E+2]=N*d):(V[E+0]=0,V[E+1]=0,V[E+2]=0)}function z(V,p){let W="",N="";for(let d=p;d<V.length-p&&(N=String.fromCharCode(V[d]),"\n"!=N);d++)W+=N;return W}function S(V){let p=0,W=0,N=z(V,0);if("#"!=N[0]||"?"!=N[1])throw"Bad HDR Format.";let d=!1,E=!1,S=0;do{S+=N.length+1,N=z(V,S),"FORMAT=32-bit_rle_rgbe"==N?E=!0:0==N.length&&(d=!0)}while(!d);if(!E)throw"HDR Bad header format, unsupported FORMAT";S+=N.length+1,N=z(V,S);const Q=/^-Y (.*) \+X (.*)$/g.exec(N);if(!Q||Q.length<3)throw"HDR Bad header format, no size";if(W=parseInt(Q[2]),p=parseInt(Q[1]),W<8||W>32767)throw"HDR Bad header format, unsupported size";return S+=N.length+1,{height:p,width:W,dataPosition:S}}function Q(V,p){return function(V,p){let W=p.height;const N=p.width;let d,z,S,Q,i,l=p.dataPosition,j=0,k=0,u=0;const f=new ArrayBuffer(4*N),O=new Uint8Array(f),U=new ArrayBuffer(p.width*p.height*4*3),F=new Float32Array(U);for(;W>0;){if(d=V[l++],z=V[l++],S=V[l++],Q=V[l++],2!=d||2!=z||128&S||p.width<8||p.width>32767)return J(V,p);if((S<<8|Q)!=N)throw"HDR Bad header format, wrong scan line width";for(j=0,u=0;u<4;u++)for(k=(u+1)*N;j<k;)if(d=V[l++],z=V[l++],d>128){if(i=d-128,0==i||i>k-j)throw"HDR Bad Format, bad scanline data (run)";for(;i-- >0;)O[j++]=z}else{if(i=d,0==i||i>k-j)throw"HDR Bad Format, bad scanline data (non-run)";if(O[j++]=z,--i>0)for(let p=0;p<i;p++)O[j++]=V[l++]}for(u=0;u<N;u++)d=O[u],z=O[u+N],S=O[u+2*N],Q=O[u+3*N],E(F,d,z,S,Q,(p.height-W)*N*3+3*u);W--}return F}(V,p)}function J(V,p){let W=p.height;const N=p.width;let d,z,S,Q,J,i=p.dataPosition;const l=new ArrayBuffer(p.width*p.height*4*3),j=new Float32Array(l);for(;W>0;){for(J=0;J<p.width;J++)d=V[i++],z=V[i++],S=V[i++],Q=V[i++],E(j,d,z,S,Q,(p.height-W)*N*3+3*J);W--}return j}d.FACE_LEFT=[new N.n(-1,-1,-1),new N.n(1,-1,-1),new N.n(-1,1,-1),new N.n(1,1,-1)],d.FACE_RIGHT=[new N.n(1,-1,1),new N.n(-1,-1,1),new N.n(1,1,1),new N.n(-1,1,1)],d.FACE_FRONT=[new N.n(1,-1,-1),new N.n(1,-1,1),new N.n(1,1,-1),new N.n(1,1,1)],d.FACE_BACK=[new N.n(-1,-1,1),new N.n(-1,-1,-1),new N.n(-1,1,1),new N.n(-1,1,-1)],d.FACE_DOWN=[new N.n(1,1,-1),new N.n(1,1,1),new N.n(-1,1,-1),new N.n(-1,1,1)],d.FACE_UP=[new N.n(-1,-1,-1),new N.n(-1,-1,1),new N.n(1,-1,-1),new N.n(1,-1,1)];class i{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(V,p,W){const N=new Uint8Array(V.buffer,V.byteOffset,V.byteLength),d=S(N),E=Q(N,d),z=d.width*d.height,J=new Float32Array(4*z);for(let S=0;S<z;S+=1)J[4*S]=E[3*S],J[4*S+1]=E[3*S+1],J[4*S+2]=E[3*S+2],J[4*S+3]=1;W(d.width,d.height,p.generateMipMaps,!1,(()=>{const V=p.getEngine();p.type=1,p.format=5,p._gammaSpace=!1,V._uploadDataToTextureDirectly(p,J)}))}}}}]);