"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12778:(Z,J,E)=>{E.r(J),E.d(J,{_HDRTextureLoader:()=>A});var O=E(11198);class i{static ConvertPanoramaToCubemap(Z,J,E,O){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Z)throw"ConvertPanoramaToCubemap: input cannot be null";if(Z.length!=J*E*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(O,this.FACE_FRONT,Z,J,E,i),back:this.CreateCubemapTexture(O,this.FACE_BACK,Z,J,E,i),left:this.CreateCubemapTexture(O,this.FACE_LEFT,Z,J,E,i),right:this.CreateCubemapTexture(O,this.FACE_RIGHT,Z,J,E,i),up:this.CreateCubemapTexture(O,this.FACE_UP,Z,J,E,i),down:this.CreateCubemapTexture(O,this.FACE_DOWN,Z,J,E,i),size:O,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(Z,J,E,O,i){let Y=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const C=new ArrayBuffer(Z*Z*4*3),d=new Float32Array(C),z=Y?Math.max(1,Math.round(O/4/Z)):1,g=1/z,A=g*g,R=J[1].bc(J[0]).scale(g/Z),h=J[3].bc(J[2]).scale(g/Z),L=1/Z;let v=0;for(let X=0;X<Z;X++)for(let Y=0;Y<z;Y++){let Y=J[0],C=J[2];for(let J=0;J<Z;J++)for(let g=0;g<z;g++){const z=C.bc(Y).scale(v).add(Y);z.normalize();const g=this.CalcProjectionSpherical(z,E,O,i);d[X*Z*3+3*J+0]+=g.r*A,d[X*Z*3+3*J+1]+=g.g*A,d[X*Z*3+3*J+2]+=g.b*A,Y=Y.add(R),C=C.add(h)}v+=L*g}return d}static CalcProjectionSpherical(Z,J,E,O){let i=Math.atan2(Z.z,Z.x);const Y=Math.acos(Z.y);for(;i<-Math.PI;)i+=2*Math.PI;for(;i>Math.PI;)i-=2*Math.PI;let C=i/Math.PI;const d=Y/Math.PI;C=.5*C+.5;let z=Math.round(C*E);z<0?z=0:z>=E&&(z=E-1);let g=Math.round(d*O);g<0?g=0:g>=O&&(g=O-1);const A=O-g-1;return{r:J[A*E*3+3*z+0],g:J[A*E*3+3*z+1],b:J[A*E*3+3*z+2]}}}function Y(Z,J,E,O,i,Y){i>0?(i=function(Z,J){return J>1023?Z*Math.pow(2,1023)*Math.pow(2,J-1023):J<-1074?Z*Math.pow(2,-1074)*Math.pow(2,J+1074):Z*Math.pow(2,J)}(1,i-136),Z[Y+0]=J*i,Z[Y+1]=E*i,Z[Y+2]=O*i):(Z[Y+0]=0,Z[Y+1]=0,Z[Y+2]=0)}function C(Z,J){let E="",O="";for(let i=J;i<Z.length-J&&(O=String.fromCharCode(Z[i]),"\n"!=O);i++)E+=O;return E}function d(Z){let J=0,E=0,O=C(Z,0);if("#"!=O[0]||"?"!=O[1])throw"Bad HDR Format.";let i=!1,Y=!1,d=0;do{d+=O.length+1,O=C(Z,d),"FORMAT=32-bit_rle_rgbe"==O?Y=!0:0==O.length&&(i=!0)}while(!i);if(!Y)throw"HDR Bad header format, unsupported FORMAT";d+=O.length+1,O=C(Z,d);const z=/^-Y (.*) \+X (.*)$/g.exec(O);if(!z||z.length<3)throw"HDR Bad header format, no size";if(E=parseInt(z[2]),J=parseInt(z[1]),E<8||E>32767)throw"HDR Bad header format, unsupported size";return d+=O.length+1,{height:J,width:E,dataPosition:d}}function z(Z,J){return function(Z,J){let E=J.height;const O=J.width;let i,C,d,z,A,R=J.dataPosition,h=0,L=0,v=0;const X=new ArrayBuffer(4*O),l=new Uint8Array(X),K=new ArrayBuffer(J.width*J.height*4*3),T=new Float32Array(K);for(;E>0;){if(i=Z[R++],C=Z[R++],d=Z[R++],z=Z[R++],2!=i||2!=C||128&d||J.width<8||J.width>32767)return g(Z,J);if((d<<8|z)!=O)throw"HDR Bad header format, wrong scan line width";for(h=0,v=0;v<4;v++)for(L=(v+1)*O;h<L;)if(i=Z[R++],C=Z[R++],i>128){if(A=i-128,0==A||A>L-h)throw"HDR Bad Format, bad scanline data (run)";for(;A-- >0;)l[h++]=C}else{if(A=i,0==A||A>L-h)throw"HDR Bad Format, bad scanline data (non-run)";if(l[h++]=C,--A>0)for(let J=0;J<A;J++)l[h++]=Z[R++]}for(v=0;v<O;v++)i=l[v],C=l[v+O],d=l[v+2*O],z=l[v+3*O],Y(T,i,C,d,z,(J.height-E)*O*3+3*v);E--}return T}(Z,J)}function g(Z,J){let E=J.height;const O=J.width;let i,C,d,z,g,A=J.dataPosition;const R=new ArrayBuffer(J.width*J.height*4*3),h=new Float32Array(R);for(;E>0;){for(g=0;g<J.width;g++)i=Z[A++],C=Z[A++],d=Z[A++],z=Z[A++],Y(h,i,C,d,z,(J.height-E)*O*3+3*g);E--}return h}i.FACE_LEFT=[new O.o(-1,-1,-1),new O.o(1,-1,-1),new O.o(-1,1,-1),new O.o(1,1,-1)],i.FACE_RIGHT=[new O.o(1,-1,1),new O.o(-1,-1,1),new O.o(1,1,1),new O.o(-1,1,1)],i.FACE_FRONT=[new O.o(1,-1,-1),new O.o(1,-1,1),new O.o(1,1,-1),new O.o(1,1,1)],i.FACE_BACK=[new O.o(-1,-1,1),new O.o(-1,-1,-1),new O.o(-1,1,1),new O.o(-1,1,-1)],i.FACE_DOWN=[new O.o(1,1,-1),new O.o(1,1,1),new O.o(-1,1,-1),new O.o(-1,1,1)],i.FACE_UP=[new O.o(-1,-1,-1),new O.o(-1,-1,1),new O.o(1,-1,-1),new O.o(1,-1,1)];class A{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(Z,J,E){const O=new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength),i=d(O),Y=z(O,i),C=i.width*i.height,g=new Float32Array(4*C);for(let d=0;d<C;d+=1)g[4*d]=Y[3*d],g[4*d+1]=Y[3*d+1],g[4*d+2]=Y[3*d+2],g[4*d+3]=1;E(i.width,i.height,J.generateMipMaps,!1,(()=>{const Z=J.getEngine();J.type=1,J.format=5,J._gammaSpace=!1,Z._uploadDataToTextureDirectly(J,g)}))}}}}]);