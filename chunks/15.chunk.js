"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{13043:(v,y,n)=>{n.r(y),n.d(y,{_HDRTextureLoader:()=>Z});var B=n(11081);class J{static ConvertPanoramaToCubemap(v,y,n,B){let J=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!v)throw"ConvertPanoramaToCubemap: input cannot be null";if(v.length!=y*n*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(B,this.FACE_FRONT,v,y,n,J),back:this.CreateCubemapTexture(B,this.FACE_BACK,v,y,n,J),left:this.CreateCubemapTexture(B,this.FACE_LEFT,v,y,n,J),right:this.CreateCubemapTexture(B,this.FACE_RIGHT,v,y,n,J),up:this.CreateCubemapTexture(B,this.FACE_UP,v,y,n,J),down:this.CreateCubemapTexture(B,this.FACE_DOWN,v,y,n,J),size:B,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(v,y,n,B,J){let P=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const b=new ArrayBuffer(v*v*4*3),Y=new Float32Array(b),l=P?Math.max(1,Math.round(B/4/v)):1,a=1/l,Z=a*a,x=y[1].od(y[0]).scale(a/v),f=y[3].od(y[2]).scale(a/v),N=1/v;let i=0;for(let g=0;g<v;g++)for(let P=0;P<l;P++){let P=y[0],b=y[2];for(let y=0;y<v;y++)for(let a=0;a<l;a++){const l=b.od(P).scale(i).add(P);l.normalize();const a=this.CalcProjectionSpherical(l,n,B,J);Y[g*v*3+3*y+0]+=a.r*Z,Y[g*v*3+3*y+1]+=a.g*Z,Y[g*v*3+3*y+2]+=a.b*Z,P=P.add(x),b=b.add(f)}i+=N*a}return Y}static CalcProjectionSpherical(v,y,n,B){let J=Math.atan2(v.z,v.x);const P=Math.acos(v.y);for(;J<-Math.PI;)J+=2*Math.PI;for(;J>Math.PI;)J-=2*Math.PI;let b=J/Math.PI;const Y=P/Math.PI;b=.5*b+.5;let l=Math.round(b*n);l<0?l=0:l>=n&&(l=n-1);let a=Math.round(Y*B);a<0?a=0:a>=B&&(a=B-1);const Z=B-a-1;return{r:y[Z*n*3+3*l+0],g:y[Z*n*3+3*l+1],b:y[Z*n*3+3*l+2]}}}function P(v,y,n,B,J,P){J>0?(J=function(v,y){return y>1023?v*Math.pow(2,1023)*Math.pow(2,y-1023):y<-1074?v*Math.pow(2,-1074)*Math.pow(2,y+1074):v*Math.pow(2,y)}(1,J-136),v[P+0]=y*J,v[P+1]=n*J,v[P+2]=B*J):(v[P+0]=0,v[P+1]=0,v[P+2]=0)}function b(v,y){let n="",B="";for(let J=y;J<v.length-y&&(B=String.fromCharCode(v[J]),"\n"!=B);J++)n+=B;return n}function Y(v){let y=0,n=0,B=b(v,0);if("#"!=B[0]||"?"!=B[1])throw"Bad HDR Format.";let J=!1,P=!1,Y=0;do{Y+=B.length+1,B=b(v,Y),"FORMAT=32-bit_rle_rgbe"==B?P=!0:0==B.length&&(J=!0)}while(!J);if(!P)throw"HDR Bad header format, unsupported FORMAT";Y+=B.length+1,B=b(v,Y);const l=/^-Y (.*) \+X (.*)$/g.exec(B);if(!l||l.length<3)throw"HDR Bad header format, no size";if(n=parseInt(l[2]),y=parseInt(l[1]),n<8||n>32767)throw"HDR Bad header format, unsupported size";return Y+=B.length+1,{height:y,width:n,dataPosition:Y}}function l(v,y){return function(v,y){let n=y.height;const B=y.width;let J,b,Y,l,Z,x=y.dataPosition,f=0,N=0,i=0;const g=new ArrayBuffer(4*B),c=new Uint8Array(g),h=new ArrayBuffer(y.width*y.height*4*3),E=new Float32Array(h);for(;n>0;){if(J=v[x++],b=v[x++],Y=v[x++],l=v[x++],2!=J||2!=b||128&Y||y.width<8||y.width>32767)return a(v,y);if((Y<<8|l)!=B)throw"HDR Bad header format, wrong scan line width";for(f=0,i=0;i<4;i++)for(N=(i+1)*B;f<N;)if(J=v[x++],b=v[x++],J>128){if(Z=J-128,0==Z||Z>N-f)throw"HDR Bad Format, bad scanline data (run)";for(;Z-- >0;)c[f++]=b}else{if(Z=J,0==Z||Z>N-f)throw"HDR Bad Format, bad scanline data (non-run)";if(c[f++]=b,--Z>0)for(let y=0;y<Z;y++)c[f++]=v[x++]}for(i=0;i<B;i++)J=c[i],b=c[i+B],Y=c[i+2*B],l=c[i+3*B],P(E,J,b,Y,l,(y.height-n)*B*3+3*i);n--}return E}(v,y)}function a(v,y){let n=y.height;const B=y.width;let J,b,Y,l,a,Z=y.dataPosition;const x=new ArrayBuffer(y.width*y.height*4*3),f=new Float32Array(x);for(;n>0;){for(a=0;a<y.width;a++)J=v[Z++],b=v[Z++],Y=v[Z++],l=v[Z++],P(f,J,b,Y,l,(y.height-n)*B*3+3*a);n--}return f}J.FACE_LEFT=[new B.n(-1,-1,-1),new B.n(1,-1,-1),new B.n(-1,1,-1),new B.n(1,1,-1)],J.FACE_RIGHT=[new B.n(1,-1,1),new B.n(-1,-1,1),new B.n(1,1,1),new B.n(-1,1,1)],J.FACE_FRONT=[new B.n(1,-1,-1),new B.n(1,-1,1),new B.n(1,1,-1),new B.n(1,1,1)],J.FACE_BACK=[new B.n(-1,-1,1),new B.n(-1,-1,-1),new B.n(-1,1,1),new B.n(-1,1,-1)],J.FACE_DOWN=[new B.n(1,1,-1),new B.n(1,1,1),new B.n(-1,1,-1),new B.n(-1,1,1)],J.FACE_UP=[new B.n(-1,-1,-1),new B.n(-1,-1,1),new B.n(1,-1,-1),new B.n(1,-1,1)];class Z{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(v,y,n){const B=new Uint8Array(v.buffer,v.byteOffset,v.byteLength),J=Y(B),P=l(B,J),b=J.width*J.height,a=new Float32Array(4*b);for(let Y=0;Y<b;Y+=1)a[4*Y]=P[3*Y],a[4*Y+1]=P[3*Y+1],a[4*Y+2]=P[3*Y+2],a[4*Y+3]=1;n(J.width,J.height,y.generateMipMaps,!1,(()=>{const v=y.getEngine();y.type=1,y.format=5,y._gammaSpace=!1,v._uploadDataToTextureDirectly(y,a)}))}}}}]);