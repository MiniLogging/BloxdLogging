"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{13642:(P,f,Y)=>{Y.r(f),Y.d(f,{_IESTextureLoader:()=>o});var C=Y(11198);function q(P){return P.split(" ").filter((P=>""!==P)).map((P=>parseFloat(P)))}function m(P,f,Y){for(;Y.length!==f;){const f=q(P.lines[P.index++]);Y.push(...f)}}function L(P,f,Y){let q=0,m=0,L=0,o=0,w=0,d=0;for(let C=0;C<P.numberOfHorizontalAngles-1;C++)if(Y<P.horizontalAngles[C+1]||C===P.numberOfHorizontalAngles-2){m=C,L=P.horizontalAngles[C],o=P.horizontalAngles[C+1];break}for(let C=0;C<P.numberOfVerticalAngles-1;C++)if(f<P.verticalAngles[C+1]||C===P.numberOfVerticalAngles-2){q=C,w=P.verticalAngles[C],d=P.verticalAngles[C+1];break}const R=o-L,y=d-w;if(0===y)return 0;const r=0===R?0:(Y-L)/R,i=(f-w)/y,u=0===R?m:m+1,g=(0,C.Lerp)(P.candelaValues[m][q],P.candelaValues[u][q],r),S=(0,C.Lerp)(P.candelaValues[m][q+1],P.candelaValues[u][q+1],r);return(0,C.Lerp)(g,S,i)}class o{constructor(){this.supportCascades=!1}loadCubeData(){throw".ies not supported in Cube."}loadData(P,f,Y){const C=function(P){const f={lines:new TextDecoder("utf-8").decode(P).split("\n"),index:0},Y={version:f.lines[0],candelaValues:[],horizontalAngles:[],verticalAngles:[],numberOfHorizontalAngles:0,numberOfVerticalAngles:0};for(f.index=1;f.lines.length>0&&!f.lines[f.index].includes("TILT=");)f.index++;f.lines[f.index].includes("INCLUDE"),f.index++;const C=q(f.lines[f.index++]);Y.numberOfLights=C[0],Y.lumensPerLamp=C[1],Y.candelaMultiplier=C[2],Y.numberOfVerticalAngles=C[3],Y.numberOfHorizontalAngles=C[4],Y.photometricType=C[5],Y.unitsType=C[6],Y.width=C[7],Y.length=C[8],Y.height=C[9];const o=q(f.lines[f.index++]);Y.ballastFactor=o[0],Y.fileGenerationType=o[1],Y.inputWatts=o[2];for(let q=0;q<Y.numberOfHorizontalAngles;q++)Y.candelaValues[q]=[];m(f,Y.numberOfVerticalAngles,Y.verticalAngles),m(f,Y.numberOfHorizontalAngles,Y.horizontalAngles);for(let q=0;q<Y.numberOfHorizontalAngles;q++)m(f,Y.numberOfVerticalAngles,Y.candelaValues[q]);let w=-1;for(let q=0;q<Y.numberOfHorizontalAngles;q++)for(let P=0;P<Y.numberOfVerticalAngles;P++)Y.candelaValues[q][P]*=Y.candelaValues[q][P]*Y.candelaMultiplier*Y.ballastFactor*Y.fileGenerationType,w=Math.max(w,Y.candelaValues[q][P]);if(w>0)for(let q=0;q<Y.numberOfHorizontalAngles;q++)for(let P=0;P<Y.numberOfVerticalAngles;P++)Y.candelaValues[q][P]/=w;const d=180,R=360,y=new Float32Array(64800),r=Y.horizontalAngles[0],i=Y.horizontalAngles[Y.numberOfHorizontalAngles-1];for(let q=0;q<64800;q++){let P=q%R;const f=Math.floor(q/R);i-r!==0&&(P<r||P>=i)&&(P%=2*i,P>i&&(P=2*i-P)),y[f+P*d]=L(Y,f,P)}return{width:180,height:1,data:y}}(new Uint8Array(P.buffer,P.byteOffset,P.byteLength));Y(C.width,C.height,!1,!1,(()=>{const P=f.getEngine();f.type=1,f.format=6,f._gammaSpace=!1,P._uploadDataToTextureDirectly(f,C.data)}))}}},11198:(P,f,Y)=>{function C(P){return parseInt(P.toString().replace(/\W/g,""))}function q(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(P-f)<=Y}function m(P,f,Y){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return P<f-C||P>Y+C}function L(P,f){return P===f?P:Math.random()*(f-P)+P}function o(P,f,Y){return P+(f-P)*Y}function w(P,f,Y){let C=S(f-P,360);return C>180&&(C-=360),P+C*r(Y)}function d(P,f,Y){let C=0;return C=P!=f?r((Y-P)/(f-P)):0,C}function R(P,f,Y,C,q){const m=q*q,L=q*m;return P*(2*L-3*m+1)+Y*(-2*L+3*m)+f*(L-2*m+q)+C*(L-m)}function y(P,f,Y,C,q){const m=q*q;return 6*(m-q)*P+(3*m-4*q+1)*f+6*(-m+q)*Y+(3*m-2*q)*C}function r(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(Y,Math.max(f,P))}function i(P){return P-=2*Math.PI*Math.floor((P+Math.PI)/(2*Math.PI))}function u(P){const f=P.toString(16);return P<=15?("0"+f).toUpperCase():f.toUpperCase()}function g(P){if(Math.log2)return Math.floor(Math.log2(P));if(P<0)return NaN;if(0===P)return-1/0;let f=0;if(P<1){for(;P<1;)f++,P*=2;f=-f}else if(P>1)for(;P>1;)f++,P=Math.floor(P/2);return f}function S(P,f){return P-Math.floor(P/f)*f}function K(P,f,Y){return(P-f)/(Y-f)}function M(P,f,Y){return P*(Y-f)+f}function V(P,f){let Y=S(f-P,360);return Y>180&&(Y-=360),Y}function O(P,f){const Y=S(P,2*f);return f-Math.abs(Y-f)}function n(P,f,Y){let C=r(Y);return C=-2*C*C*C+3*C*C,f*C+P*(1-C)}function l(P,f,Y){let C=0;return C=Math.abs(f-P)<=Y?f:P+Math.sign(f-P)*Y,C}function v(P,f,Y){const C=V(P,f);let q=0;return q=-Y<C&&C<Y?f:l(P,f=P+C,Y),q}function c(P,f,Y){return(P-f)/(Y-f)}function T(P,f,Y){return(Y-f)*P+f}function U(P,f){const Y=P%f;return 0===Y?f:U(f,Y)}Y.r(f),Y.d(f,{Clamp:()=>r,DeltaAngle:()=>V,Denormalize:()=>M,ExtractAsInt:()=>C,Hermite:()=>R,Hermite1stDerivative:()=>y,HighestCommonFactor:()=>U,ILog2:()=>g,InverseLerp:()=>d,Lerp:()=>o,LerpAngle:()=>w,MoveTowards:()=>l,MoveTowardsAngle:()=>v,Normalize:()=>K,NormalizeRadians:()=>i,OutsideRange:()=>m,PercentToRange:()=>T,PingPong:()=>O,RandomRange:()=>L,RangeToPercent:()=>c,Repeat:()=>S,SmoothStep:()=>n,ToHex:()=>u,WithinEpsilon:()=>q})}}]);