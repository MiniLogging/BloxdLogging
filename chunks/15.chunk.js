"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12918:(O,f,y)=>{y.r(f),y.d(f,{_HDRTextureLoader:()=>t});var S=y(11324);class H{static ConvertPanoramaToCubemap(O,f,y,S){let H=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!O)throw"ConvertPanoramaToCubemap: input cannot be null";if(O.length!=f*y*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(S,this.FACE_FRONT,O,f,y,H),back:this.CreateCubemapTexture(S,this.FACE_BACK,O,f,y,H),left:this.CreateCubemapTexture(S,this.FACE_LEFT,O,f,y,H),right:this.CreateCubemapTexture(S,this.FACE_RIGHT,O,f,y,H),up:this.CreateCubemapTexture(S,this.FACE_UP,O,f,y,H),down:this.CreateCubemapTexture(S,this.FACE_DOWN,O,f,y,H),size:S,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(O,f,y,S,H){let b=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const h=new ArrayBuffer(O*O*4*3),v=new Float32Array(h),N=b?Math.max(1,Math.round(S/4/O)):1,m=1/N,t=m*m,q=f[1].xc(f[0]).scale(m/O),F=f[3].xc(f[2]).scale(m/O),I=1/O;let A=0;for(let J=0;J<O;J++)for(let b=0;b<N;b++){let b=f[0],h=f[2];for(let f=0;f<O;f++)for(let m=0;m<N;m++){const N=h.xc(b).scale(A).add(b);N.normalize();const m=this.CalcProjectionSpherical(N,y,S,H);v[J*O*3+3*f+0]+=m.r*t,v[J*O*3+3*f+1]+=m.g*t,v[J*O*3+3*f+2]+=m.b*t,b=b.add(q),h=h.add(F)}A+=I*m}return v}static CalcProjectionSpherical(O,f,y,S){let H=Math.atan2(O.z,O.x);const b=Math.acos(O.y);for(;H<-Math.PI;)H+=2*Math.PI;for(;H>Math.PI;)H-=2*Math.PI;let h=H/Math.PI;const v=b/Math.PI;h=.5*h+.5;let N=Math.round(h*y);N<0?N=0:N>=y&&(N=y-1);let m=Math.round(v*S);m<0?m=0:m>=S&&(m=S-1);const t=S-m-1;return{r:f[t*y*3+3*N+0],g:f[t*y*3+3*N+1],b:f[t*y*3+3*N+2]}}}function b(O,f,y,S,H,b){H>0?(H=function(O,f){return f>1023?O*Math.pow(2,1023)*Math.pow(2,f-1023):f<-1074?O*Math.pow(2,-1074)*Math.pow(2,f+1074):O*Math.pow(2,f)}(1,H-136),O[b+0]=f*H,O[b+1]=y*H,O[b+2]=S*H):(O[b+0]=0,O[b+1]=0,O[b+2]=0)}function h(O,f){let y="",S="";for(let H=f;H<O.length-f&&(S=String.fromCharCode(O[H]),"\n"!=S);H++)y+=S;return y}function v(O){let f=0,y=0,S=h(O,0);if("#"!=S[0]||"?"!=S[1])throw"Bad HDR Format.";let H=!1,b=!1,v=0;do{v+=S.length+1,S=h(O,v),"FORMAT=32-bit_rle_rgbe"==S?b=!0:0==S.length&&(H=!0)}while(!H);if(!b)throw"HDR Bad header format, unsupported FORMAT";v+=S.length+1,S=h(O,v);const N=/^-Y (.*) \+X (.*)$/g.exec(S);if(!N||N.length<3)throw"HDR Bad header format, no size";if(y=parseInt(N[2]),f=parseInt(N[1]),y<8||y>32767)throw"HDR Bad header format, unsupported size";return v+=S.length+1,{height:f,width:y,dataPosition:v}}function N(O,f){return function(O,f){let y=f.height;const S=f.width;let H,h,v,N,t,q=f.dataPosition,F=0,I=0,A=0;const J=new ArrayBuffer(4*S),X=new Uint8Array(J),w=new ArrayBuffer(f.width*f.height*4*3),B=new Float32Array(w);for(;y>0;){if(H=O[q++],h=O[q++],v=O[q++],N=O[q++],2!=H||2!=h||128&v||f.width<8||f.width>32767)return m(O,f);if((v<<8|N)!=S)throw"HDR Bad header format, wrong scan line width";for(F=0,A=0;A<4;A++)for(I=(A+1)*S;F<I;)if(H=O[q++],h=O[q++],H>128){if(t=H-128,0==t||t>I-F)throw"HDR Bad Format, bad scanline data (run)";for(;t-- >0;)X[F++]=h}else{if(t=H,0==t||t>I-F)throw"HDR Bad Format, bad scanline data (non-run)";if(X[F++]=h,--t>0)for(let f=0;f<t;f++)X[F++]=O[q++]}for(A=0;A<S;A++)H=X[A],h=X[A+S],v=X[A+2*S],N=X[A+3*S],b(B,H,h,v,N,(f.height-y)*S*3+3*A);y--}return B}(O,f)}function m(O,f){let y=f.height;const S=f.width;let H,h,v,N,m,t=f.dataPosition;const q=new ArrayBuffer(f.width*f.height*4*3),F=new Float32Array(q);for(;y>0;){for(m=0;m<f.width;m++)H=O[t++],h=O[t++],v=O[t++],N=O[t++],b(F,H,h,v,N,(f.height-y)*S*3+3*m);y--}return F}H.FACE_LEFT=[new S.m(-1,-1,-1),new S.m(1,-1,-1),new S.m(-1,1,-1),new S.m(1,1,-1)],H.FACE_RIGHT=[new S.m(1,-1,1),new S.m(-1,-1,1),new S.m(1,1,1),new S.m(-1,1,1)],H.FACE_FRONT=[new S.m(1,-1,-1),new S.m(1,-1,1),new S.m(1,1,-1),new S.m(1,1,1)],H.FACE_BACK=[new S.m(-1,-1,1),new S.m(-1,-1,-1),new S.m(-1,1,1),new S.m(-1,1,-1)],H.FACE_DOWN=[new S.m(1,1,-1),new S.m(1,1,1),new S.m(-1,1,-1),new S.m(-1,1,1)],H.FACE_UP=[new S.m(-1,-1,-1),new S.m(-1,-1,1),new S.m(1,-1,-1),new S.m(1,-1,1)];class t{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(O,f,y){const S=new Uint8Array(O.buffer,O.byteOffset,O.byteLength),H=v(S),b=N(S,H),h=H.width*H.height,m=new Float32Array(4*h);for(let v=0;v<h;v+=1)m[4*v]=b[3*v],m[4*v+1]=b[3*v+1],m[4*v+2]=b[3*v+2],m[4*v+3]=1;y(H.width,H.height,f.generateMipMaps,!1,(()=>{const O=f.getEngine();f.type=1,f.format=5,f._gammaSpace=!1,O._uploadDataToTextureDirectly(f,m)}))}}}}]);