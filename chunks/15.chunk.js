"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12574:(u,G,s)=>{s.r(G),s.d(G,{_HDRTextureLoader:()=>g});var T=s(10904);class z{static ConvertPanoramaToCubemap(u,G,s,T){let z=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!u)throw"ConvertPanoramaToCubemap: input cannot be null";if(u.length!=G*s*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(T,this.FACE_FRONT,u,G,s,z),back:this.CreateCubemapTexture(T,this.FACE_BACK,u,G,s,z),left:this.CreateCubemapTexture(T,this.FACE_LEFT,u,G,s,z),right:this.CreateCubemapTexture(T,this.FACE_RIGHT,u,G,s,z),up:this.CreateCubemapTexture(T,this.FACE_UP,u,G,s,z),down:this.CreateCubemapTexture(T,this.FACE_DOWN,u,G,s,z),size:T,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(u,G,s,T,z){let O=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const m=new ArrayBuffer(u*u*4*3),f=new Float32Array(m),C=O?Math.max(1,Math.round(T/4/u)):1,x=1/C,g=x*x,b=G[1].Nc(G[0]).scale(x/u),Q=G[3].Nc(G[2]).scale(x/u),Y=1/u;let n=0;for(let V=0;V<u;V++)for(let O=0;O<C;O++){let O=G[0],m=G[2];for(let G=0;G<u;G++)for(let x=0;x<C;x++){const C=m.Nc(O).scale(n).add(O);C.normalize();const x=this.CalcProjectionSpherical(C,s,T,z);f[V*u*3+3*G+0]+=x.r*g,f[V*u*3+3*G+1]+=x.g*g,f[V*u*3+3*G+2]+=x.b*g,O=O.add(b),m=m.add(Q)}n+=Y*x}return f}static CalcProjectionSpherical(u,G,s,T){let z=Math.atan2(u.z,u.x);const O=Math.acos(u.y);for(;z<-Math.PI;)z+=2*Math.PI;for(;z>Math.PI;)z-=2*Math.PI;let m=z/Math.PI;const f=O/Math.PI;m=.5*m+.5;let C=Math.round(m*s);C<0?C=0:C>=s&&(C=s-1);let x=Math.round(f*T);x<0?x=0:x>=T&&(x=T-1);const g=T-x-1;return{r:G[g*s*3+3*C+0],g:G[g*s*3+3*C+1],b:G[g*s*3+3*C+2]}}}function O(u,G,s,T,z,O){z>0?(z=function(u,G){return G>1023?u*Math.pow(2,1023)*Math.pow(2,G-1023):G<-1074?u*Math.pow(2,-1074)*Math.pow(2,G+1074):u*Math.pow(2,G)}(1,z-136),u[O+0]=G*z,u[O+1]=s*z,u[O+2]=T*z):(u[O+0]=0,u[O+1]=0,u[O+2]=0)}function m(u,G){let s="",T="";for(let z=G;z<u.length-G&&(T=String.fromCharCode(u[z]),"\n"!=T);z++)s+=T;return s}function f(u){let G=0,s=0,T=m(u,0);if("#"!=T[0]||"?"!=T[1])throw"Bad HDR Format.";let z=!1,O=!1,f=0;do{f+=T.length+1,T=m(u,f),"FORMAT=32-bit_rle_rgbe"==T?O=!0:0==T.length&&(z=!0)}while(!z);if(!O)throw"HDR Bad header format, unsupported FORMAT";f+=T.length+1,T=m(u,f);const C=/^-Y (.*) \+X (.*)$/g.exec(T);if(!C||C.length<3)throw"HDR Bad header format, no size";if(s=parseInt(C[2]),G=parseInt(C[1]),s<8||s>32767)throw"HDR Bad header format, unsupported size";return f+=T.length+1,{height:G,width:s,dataPosition:f}}function C(u,G){return function(u,G){let s=G.height;const T=G.width;let z,m,f,C,g,b=G.dataPosition,Q=0,Y=0,n=0;const V=new ArrayBuffer(4*T),F=new Uint8Array(V),r=new ArrayBuffer(G.width*G.height*4*3),c=new Float32Array(r);for(;s>0;){if(z=u[b++],m=u[b++],f=u[b++],C=u[b++],2!=z||2!=m||128&f||G.width<8||G.width>32767)return x(u,G);if((f<<8|C)!=T)throw"HDR Bad header format, wrong scan line width";for(Q=0,n=0;n<4;n++)for(Y=(n+1)*T;Q<Y;)if(z=u[b++],m=u[b++],z>128){if(g=z-128,0==g||g>Y-Q)throw"HDR Bad Format, bad scanline data (run)";for(;g-- >0;)F[Q++]=m}else{if(g=z,0==g||g>Y-Q)throw"HDR Bad Format, bad scanline data (non-run)";if(F[Q++]=m,--g>0)for(let G=0;G<g;G++)F[Q++]=u[b++]}for(n=0;n<T;n++)z=F[n],m=F[n+T],f=F[n+2*T],C=F[n+3*T],O(c,z,m,f,C,(G.height-s)*T*3+3*n);s--}return c}(u,G)}function x(u,G){let s=G.height;const T=G.width;let z,m,f,C,x,g=G.dataPosition;const b=new ArrayBuffer(G.width*G.height*4*3),Q=new Float32Array(b);for(;s>0;){for(x=0;x<G.width;x++)z=u[g++],m=u[g++],f=u[g++],C=u[g++],O(Q,z,m,f,C,(G.height-s)*T*3+3*x);s--}return Q}z.FACE_LEFT=[new T.q(-1,-1,-1),new T.q(1,-1,-1),new T.q(-1,1,-1),new T.q(1,1,-1)],z.FACE_RIGHT=[new T.q(1,-1,1),new T.q(-1,-1,1),new T.q(1,1,1),new T.q(-1,1,1)],z.FACE_FRONT=[new T.q(1,-1,-1),new T.q(1,-1,1),new T.q(1,1,-1),new T.q(1,1,1)],z.FACE_BACK=[new T.q(-1,-1,1),new T.q(-1,-1,-1),new T.q(-1,1,1),new T.q(-1,1,-1)],z.FACE_DOWN=[new T.q(1,1,-1),new T.q(1,1,1),new T.q(-1,1,-1),new T.q(-1,1,1)],z.FACE_UP=[new T.q(-1,-1,-1),new T.q(-1,-1,1),new T.q(1,-1,-1),new T.q(1,-1,1)];class g{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(u,G,s){const T=new Uint8Array(u.buffer,u.byteOffset,u.byteLength),z=f(T),O=C(T,z),m=z.width*z.height,x=new Float32Array(4*m);for(let f=0;f<m;f+=1)x[4*f]=O[3*f],x[4*f+1]=O[3*f+1],x[4*f+2]=O[3*f+2],x[4*f+3]=1;s(z.width,z.height,G.generateMipMaps,!1,(()=>{const u=G.getEngine();G.type=1,G.format=5,G._gammaSpace=!1,u._uploadDataToTextureDirectly(G,x)}))}}}}]);