"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12871:(V,O,Z)=>{Z.r(O),Z.d(O,{_HDRTextureLoader:()=>i});var d=Z(11251);class p{static ConvertPanoramaToCubemap(V,O,Z,d){let p=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!V)throw"ConvertPanoramaToCubemap: input cannot be null";if(V.length!=O*Z*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(d,this.FACE_FRONT,V,O,Z,p),back:this.CreateCubemapTexture(d,this.FACE_BACK,V,O,Z,p),left:this.CreateCubemapTexture(d,this.FACE_LEFT,V,O,Z,p),right:this.CreateCubemapTexture(d,this.FACE_RIGHT,V,O,Z,p),up:this.CreateCubemapTexture(d,this.FACE_UP,V,O,Z,p),down:this.CreateCubemapTexture(d,this.FACE_DOWN,V,O,Z,p),size:d,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(V,O,Z,d,p){let r=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const Y=new ArrayBuffer(V*V*4*3),m=new Float32Array(Y),a=r?Math.max(1,Math.round(d/4/V)):1,R=1/a,i=R*R,M=O[1].fc(O[0]).scale(R/V),c=O[3].fc(O[2]).scale(R/V),W=1/V;let F=0;for(let Q=0;Q<V;Q++)for(let r=0;r<a;r++){let r=O[0],Y=O[2];for(let O=0;O<V;O++)for(let R=0;R<a;R++){const a=Y.fc(r).scale(F).add(r);a.normalize();const R=this.CalcProjectionSpherical(a,Z,d,p);m[Q*V*3+3*O+0]+=R.r*i,m[Q*V*3+3*O+1]+=R.g*i,m[Q*V*3+3*O+2]+=R.b*i,r=r.add(M),Y=Y.add(c)}F+=W*R}return m}static CalcProjectionSpherical(V,O,Z,d){let p=Math.atan2(V.z,V.x);const r=Math.acos(V.y);for(;p<-Math.PI;)p+=2*Math.PI;for(;p>Math.PI;)p-=2*Math.PI;let Y=p/Math.PI;const m=r/Math.PI;Y=.5*Y+.5;let a=Math.round(Y*Z);a<0?a=0:a>=Z&&(a=Z-1);let R=Math.round(m*d);R<0?R=0:R>=d&&(R=d-1);const i=d-R-1;return{r:O[i*Z*3+3*a+0],g:O[i*Z*3+3*a+1],b:O[i*Z*3+3*a+2]}}}function r(V,O,Z,d,p,r){p>0?(p=function(V,O){return O>1023?V*Math.pow(2,1023)*Math.pow(2,O-1023):O<-1074?V*Math.pow(2,-1074)*Math.pow(2,O+1074):V*Math.pow(2,O)}(1,p-136),V[r+0]=O*p,V[r+1]=Z*p,V[r+2]=d*p):(V[r+0]=0,V[r+1]=0,V[r+2]=0)}function Y(V,O){let Z="",d="";for(let p=O;p<V.length-O&&(d=String.fromCharCode(V[p]),"\n"!=d);p++)Z+=d;return Z}function m(V){let O=0,Z=0,d=Y(V,0);if("#"!=d[0]||"?"!=d[1])throw"Bad HDR Format.";let p=!1,r=!1,m=0;do{m+=d.length+1,d=Y(V,m),"FORMAT=32-bit_rle_rgbe"==d?r=!0:0==d.length&&(p=!0)}while(!p);if(!r)throw"HDR Bad header format, unsupported FORMAT";m+=d.length+1,d=Y(V,m);const a=/^-Y (.*) \+X (.*)$/g.exec(d);if(!a||a.length<3)throw"HDR Bad header format, no size";if(Z=parseInt(a[2]),O=parseInt(a[1]),Z<8||Z>32767)throw"HDR Bad header format, unsupported size";return m+=d.length+1,{height:O,width:Z,dataPosition:m}}function a(V,O){return function(V,O){let Z=O.height;const d=O.width;let p,Y,m,a,i,M=O.dataPosition,c=0,W=0,F=0;const Q=new ArrayBuffer(4*d),b=new Uint8Array(Q),U=new ArrayBuffer(O.width*O.height*4*3),H=new Float32Array(U);for(;Z>0;){if(p=V[M++],Y=V[M++],m=V[M++],a=V[M++],2!=p||2!=Y||128&m||O.width<8||O.width>32767)return R(V,O);if((m<<8|a)!=d)throw"HDR Bad header format, wrong scan line width";for(c=0,F=0;F<4;F++)for(W=(F+1)*d;c<W;)if(p=V[M++],Y=V[M++],p>128){if(i=p-128,0==i||i>W-c)throw"HDR Bad Format, bad scanline data (run)";for(;i-- >0;)b[c++]=Y}else{if(i=p,0==i||i>W-c)throw"HDR Bad Format, bad scanline data (non-run)";if(b[c++]=Y,--i>0)for(let O=0;O<i;O++)b[c++]=V[M++]}for(F=0;F<d;F++)p=b[F],Y=b[F+d],m=b[F+2*d],a=b[F+3*d],r(H,p,Y,m,a,(O.height-Z)*d*3+3*F);Z--}return H}(V,O)}function R(V,O){let Z=O.height;const d=O.width;let p,Y,m,a,R,i=O.dataPosition;const M=new ArrayBuffer(O.width*O.height*4*3),c=new Float32Array(M);for(;Z>0;){for(R=0;R<O.width;R++)p=V[i++],Y=V[i++],m=V[i++],a=V[i++],r(c,p,Y,m,a,(O.height-Z)*d*3+3*R);Z--}return c}p.FACE_LEFT=[new d.m(-1,-1,-1),new d.m(1,-1,-1),new d.m(-1,1,-1),new d.m(1,1,-1)],p.FACE_RIGHT=[new d.m(1,-1,1),new d.m(-1,-1,1),new d.m(1,1,1),new d.m(-1,1,1)],p.FACE_FRONT=[new d.m(1,-1,-1),new d.m(1,-1,1),new d.m(1,1,-1),new d.m(1,1,1)],p.FACE_BACK=[new d.m(-1,-1,1),new d.m(-1,-1,-1),new d.m(-1,1,1),new d.m(-1,1,-1)],p.FACE_DOWN=[new d.m(1,1,-1),new d.m(1,1,1),new d.m(-1,1,-1),new d.m(-1,1,1)],p.FACE_UP=[new d.m(-1,-1,-1),new d.m(-1,-1,1),new d.m(1,-1,-1),new d.m(1,-1,1)];class i{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(V,O,Z){const d=new Uint8Array(V.buffer,V.byteOffset,V.byteLength),p=m(d),r=a(d,p),Y=p.width*p.height,R=new Float32Array(4*Y);for(let m=0;m<Y;m+=1)R[4*m]=r[3*m],R[4*m+1]=r[3*m+1],R[4*m+2]=r[3*m+2],R[4*m+3]=1;Z(p.width,p.height,O.generateMipMaps,!1,(()=>{const V=O.getEngine();O.type=1,O.format=5,O._gammaSpace=!1,V._uploadDataToTextureDirectly(O,R)}))}}}}]);