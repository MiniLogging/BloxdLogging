"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{13024:(H,p,V)=>{V.r(p),V.d(p,{_HDRTextureLoader:()=>P});var c=V(11108);class C{static ConvertPanoramaToCubemap(H,p,V,c){let C=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!H)throw"ConvertPanoramaToCubemap: input cannot be null";if(H.length!=p*V*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(c,this.FACE_FRONT,H,p,V,C),back:this.CreateCubemapTexture(c,this.FACE_BACK,H,p,V,C),left:this.CreateCubemapTexture(c,this.FACE_LEFT,H,p,V,C),right:this.CreateCubemapTexture(c,this.FACE_RIGHT,H,p,V,C),up:this.CreateCubemapTexture(c,this.FACE_UP,H,p,V,C),down:this.CreateCubemapTexture(c,this.FACE_DOWN,H,p,V,C),size:c,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(H,p,V,c,C){let E=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const z=new ArrayBuffer(H*H*4*3),w=new Float32Array(z),t=E?Math.max(1,Math.round(c/4/H)):1,Q=1/t,P=Q*Q,U=p[1].gd(p[0]).scale(Q/H),J=p[3].gd(p[2]).scale(Q/H),l=1/H;let N=0;for(let Z=0;Z<H;Z++)for(let E=0;E<t;E++){let E=p[0],z=p[2];for(let p=0;p<H;p++)for(let Q=0;Q<t;Q++){const t=z.gd(E).scale(N).add(E);t.normalize();const Q=this.CalcProjectionSpherical(t,V,c,C);w[Z*H*3+3*p+0]+=Q.r*P,w[Z*H*3+3*p+1]+=Q.g*P,w[Z*H*3+3*p+2]+=Q.b*P,E=E.add(U),z=z.add(J)}N+=l*Q}return w}static CalcProjectionSpherical(H,p,V,c){let C=Math.atan2(H.z,H.x);const E=Math.acos(H.y);for(;C<-Math.PI;)C+=2*Math.PI;for(;C>Math.PI;)C-=2*Math.PI;let z=C/Math.PI;const w=E/Math.PI;z=.5*z+.5;let t=Math.round(z*V);t<0?t=0:t>=V&&(t=V-1);let Q=Math.round(w*c);Q<0?Q=0:Q>=c&&(Q=c-1);const P=c-Q-1;return{r:p[P*V*3+3*t+0],g:p[P*V*3+3*t+1],b:p[P*V*3+3*t+2]}}}function E(H,p,V,c,C,E){C>0?(C=function(H,p){return p>1023?H*Math.pow(2,1023)*Math.pow(2,p-1023):p<-1074?H*Math.pow(2,-1074)*Math.pow(2,p+1074):H*Math.pow(2,p)}(1,C-136),H[E+0]=p*C,H[E+1]=V*C,H[E+2]=c*C):(H[E+0]=0,H[E+1]=0,H[E+2]=0)}function z(H,p){let V="",c="";for(let C=p;C<H.length-p&&(c=String.fromCharCode(H[C]),"\n"!=c);C++)V+=c;return V}function w(H){let p=0,V=0,c=z(H,0);if("#"!=c[0]||"?"!=c[1])throw"Bad HDR Format.";let C=!1,E=!1,w=0;do{w+=c.length+1,c=z(H,w),"FORMAT=32-bit_rle_rgbe"==c?E=!0:0==c.length&&(C=!0)}while(!C);if(!E)throw"HDR Bad header format, unsupported FORMAT";w+=c.length+1,c=z(H,w);const t=/^-Y (.*) \+X (.*)$/g.exec(c);if(!t||t.length<3)throw"HDR Bad header format, no size";if(V=parseInt(t[2]),p=parseInt(t[1]),V<8||V>32767)throw"HDR Bad header format, unsupported size";return w+=c.length+1,{height:p,width:V,dataPosition:w}}function t(H,p){return function(H,p){let V=p.height;const c=p.width;let C,z,w,t,P,U=p.dataPosition,J=0,l=0,N=0;const Z=new ArrayBuffer(4*c),Y=new Uint8Array(Z),y=new ArrayBuffer(p.width*p.height*4*3),M=new Float32Array(y);for(;V>0;){if(C=H[U++],z=H[U++],w=H[U++],t=H[U++],2!=C||2!=z||128&w||p.width<8||p.width>32767)return Q(H,p);if((w<<8|t)!=c)throw"HDR Bad header format, wrong scan line width";for(J=0,N=0;N<4;N++)for(l=(N+1)*c;J<l;)if(C=H[U++],z=H[U++],C>128){if(P=C-128,0==P||P>l-J)throw"HDR Bad Format, bad scanline data (run)";for(;P-- >0;)Y[J++]=z}else{if(P=C,0==P||P>l-J)throw"HDR Bad Format, bad scanline data (non-run)";if(Y[J++]=z,--P>0)for(let p=0;p<P;p++)Y[J++]=H[U++]}for(N=0;N<c;N++)C=Y[N],z=Y[N+c],w=Y[N+2*c],t=Y[N+3*c],E(M,C,z,w,t,(p.height-V)*c*3+3*N);V--}return M}(H,p)}function Q(H,p){let V=p.height;const c=p.width;let C,z,w,t,Q,P=p.dataPosition;const U=new ArrayBuffer(p.width*p.height*4*3),J=new Float32Array(U);for(;V>0;){for(Q=0;Q<p.width;Q++)C=H[P++],z=H[P++],w=H[P++],t=H[P++],E(J,C,z,w,t,(p.height-V)*c*3+3*Q);V--}return J}C.FACE_LEFT=[new c.p(-1,-1,-1),new c.p(1,-1,-1),new c.p(-1,1,-1),new c.p(1,1,-1)],C.FACE_RIGHT=[new c.p(1,-1,1),new c.p(-1,-1,1),new c.p(1,1,1),new c.p(-1,1,1)],C.FACE_FRONT=[new c.p(1,-1,-1),new c.p(1,-1,1),new c.p(1,1,-1),new c.p(1,1,1)],C.FACE_BACK=[new c.p(-1,-1,1),new c.p(-1,-1,-1),new c.p(-1,1,1),new c.p(-1,1,-1)],C.FACE_DOWN=[new c.p(1,1,-1),new c.p(1,1,1),new c.p(-1,1,-1),new c.p(-1,1,1)],C.FACE_UP=[new c.p(-1,-1,-1),new c.p(-1,-1,1),new c.p(1,-1,-1),new c.p(1,-1,1)];class P{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(H,p,V){const c=new Uint8Array(H.buffer,H.byteOffset,H.byteLength),C=w(c),E=t(c,C),z=C.width*C.height,Q=new Float32Array(4*z);for(let w=0;w<z;w+=1)Q[4*w]=E[3*w],Q[4*w+1]=E[3*w+1],Q[4*w+2]=E[3*w+2],Q[4*w+3]=1;V(C.width,C.height,p.generateMipMaps,!1,(()=>{const H=p.getEngine();p.type=1,p.format=5,p._gammaSpace=!1,H._uploadDataToTextureDirectly(p,Q)}))}}}}]);