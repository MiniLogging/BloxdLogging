"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12832:(N,q,R)=>{R.r(q),R.d(q,{_HDRTextureLoader:()=>E});var z=R(11181);class v{static ConvertPanoramaToCubemap(N,q,R,z){let v=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!N)throw"ConvertPanoramaToCubemap: input cannot be null";if(N.length!=q*R*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(z,this.FACE_FRONT,N,q,R,v),back:this.CreateCubemapTexture(z,this.FACE_BACK,N,q,R,v),left:this.CreateCubemapTexture(z,this.FACE_LEFT,N,q,R,v),right:this.CreateCubemapTexture(z,this.FACE_RIGHT,N,q,R,v),up:this.CreateCubemapTexture(z,this.FACE_UP,N,q,R,v),down:this.CreateCubemapTexture(z,this.FACE_DOWN,N,q,R,v),size:z,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(N,q,R,z,v){let B=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const F=new ArrayBuffer(N*N*4*3),S=new Float32Array(F),A=B?Math.max(1,Math.round(z/4/N)):1,y=1/A,E=y*y,t=q[1].gd(q[0]).scale(y/N),x=q[3].gd(q[2]).scale(y/N),e=1/N;let b=0;for(let f=0;f<N;f++)for(let B=0;B<A;B++){let B=q[0],F=q[2];for(let q=0;q<N;q++)for(let y=0;y<A;y++){const A=F.gd(B).scale(b).add(B);A.normalize();const y=this.CalcProjectionSpherical(A,R,z,v);S[f*N*3+3*q+0]+=y.r*E,S[f*N*3+3*q+1]+=y.g*E,S[f*N*3+3*q+2]+=y.b*E,B=B.add(t),F=F.add(x)}b+=e*y}return S}static CalcProjectionSpherical(N,q,R,z){let v=Math.atan2(N.z,N.x);const B=Math.acos(N.y);for(;v<-Math.PI;)v+=2*Math.PI;for(;v>Math.PI;)v-=2*Math.PI;let F=v/Math.PI;const S=B/Math.PI;F=.5*F+.5;let A=Math.round(F*R);A<0?A=0:A>=R&&(A=R-1);let y=Math.round(S*z);y<0?y=0:y>=z&&(y=z-1);const E=z-y-1;return{r:q[E*R*3+3*A+0],g:q[E*R*3+3*A+1],b:q[E*R*3+3*A+2]}}}function B(N,q,R,z,v,B){v>0?(v=function(N,q){return q>1023?N*Math.pow(2,1023)*Math.pow(2,q-1023):q<-1074?N*Math.pow(2,-1074)*Math.pow(2,q+1074):N*Math.pow(2,q)}(1,v-136),N[B+0]=q*v,N[B+1]=R*v,N[B+2]=z*v):(N[B+0]=0,N[B+1]=0,N[B+2]=0)}function F(N,q){let R="",z="";for(let v=q;v<N.length-q&&(z=String.fromCharCode(N[v]),"\n"!=z);v++)R+=z;return R}function S(N){let q=0,R=0,z=F(N,0);if("#"!=z[0]||"?"!=z[1])throw"Bad HDR Format.";let v=!1,B=!1,S=0;do{S+=z.length+1,z=F(N,S),"FORMAT=32-bit_rle_rgbe"==z?B=!0:0==z.length&&(v=!0)}while(!v);if(!B)throw"HDR Bad header format, unsupported FORMAT";S+=z.length+1,z=F(N,S);const A=/^-Y (.*) \+X (.*)$/g.exec(z);if(!A||A.length<3)throw"HDR Bad header format, no size";if(R=parseInt(A[2]),q=parseInt(A[1]),R<8||R>32767)throw"HDR Bad header format, unsupported size";return S+=z.length+1,{height:q,width:R,dataPosition:S}}function A(N,q){return function(N,q){let R=q.height;const z=q.width;let v,F,S,A,E,t=q.dataPosition,x=0,e=0,b=0;const f=new ArrayBuffer(4*z),D=new Uint8Array(f),V=new ArrayBuffer(q.width*q.height*4*3),H=new Float32Array(V);for(;R>0;){if(v=N[t++],F=N[t++],S=N[t++],A=N[t++],2!=v||2!=F||128&S||q.width<8||q.width>32767)return y(N,q);if((S<<8|A)!=z)throw"HDR Bad header format, wrong scan line width";for(x=0,b=0;b<4;b++)for(e=(b+1)*z;x<e;)if(v=N[t++],F=N[t++],v>128){if(E=v-128,0==E||E>e-x)throw"HDR Bad Format, bad scanline data (run)";for(;E-- >0;)D[x++]=F}else{if(E=v,0==E||E>e-x)throw"HDR Bad Format, bad scanline data (non-run)";if(D[x++]=F,--E>0)for(let q=0;q<E;q++)D[x++]=N[t++]}for(b=0;b<z;b++)v=D[b],F=D[b+z],S=D[b+2*z],A=D[b+3*z],B(H,v,F,S,A,(q.height-R)*z*3+3*b);R--}return H}(N,q)}function y(N,q){let R=q.height;const z=q.width;let v,F,S,A,y,E=q.dataPosition;const t=new ArrayBuffer(q.width*q.height*4*3),x=new Float32Array(t);for(;R>0;){for(y=0;y<q.width;y++)v=N[E++],F=N[E++],S=N[E++],A=N[E++],B(x,v,F,S,A,(q.height-R)*z*3+3*y);R--}return x}v.FACE_LEFT=[new z.m(-1,-1,-1),new z.m(1,-1,-1),new z.m(-1,1,-1),new z.m(1,1,-1)],v.FACE_RIGHT=[new z.m(1,-1,1),new z.m(-1,-1,1),new z.m(1,1,1),new z.m(-1,1,1)],v.FACE_FRONT=[new z.m(1,-1,-1),new z.m(1,-1,1),new z.m(1,1,-1),new z.m(1,1,1)],v.FACE_BACK=[new z.m(-1,-1,1),new z.m(-1,-1,-1),new z.m(-1,1,1),new z.m(-1,1,-1)],v.FACE_DOWN=[new z.m(1,1,-1),new z.m(1,1,1),new z.m(-1,1,-1),new z.m(-1,1,1)],v.FACE_UP=[new z.m(-1,-1,-1),new z.m(-1,-1,1),new z.m(1,-1,-1),new z.m(1,-1,1)];class E{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(N,q,R){const z=new Uint8Array(N.buffer,N.byteOffset,N.byteLength),v=S(z),B=A(z,v),F=v.width*v.height,y=new Float32Array(4*F);for(let S=0;S<F;S+=1)y[4*S]=B[3*S],y[4*S+1]=B[3*S+1],y[4*S+2]=B[3*S+2],y[4*S+3]=1;R(v.width,v.height,q.generateMipMaps,!1,(()=>{const N=q.getEngine();q.type=1,q.format=5,q._gammaSpace=!1,N._uploadDataToTextureDirectly(q,y)}))}}}}]);