"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12773:(d,t,A)=>{A.r(t),A.d(t,{_HDRTextureLoader:()=>D});var w=A(11076);class N{static ConvertPanoramaToCubemap(d,t,A,w){let N=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!d)throw"ConvertPanoramaToCubemap: input cannot be null";if(d.length!=t*A*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(w,this.FACE_FRONT,d,t,A,N),back:this.CreateCubemapTexture(w,this.FACE_BACK,d,t,A,N),left:this.CreateCubemapTexture(w,this.FACE_LEFT,d,t,A,N),right:this.CreateCubemapTexture(w,this.FACE_RIGHT,d,t,A,N),up:this.CreateCubemapTexture(w,this.FACE_UP,d,t,A,N),down:this.CreateCubemapTexture(w,this.FACE_DOWN,d,t,A,N),size:w,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(d,t,A,w,N){let p=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const B=new ArrayBuffer(d*d*4*3),X=new Float32Array(B),W=p?Math.max(1,Math.round(w/4/d)):1,a=1/W,D=a*a,i=t[1].Uc(t[0]).scale(a/d),k=t[3].Uc(t[2]).scale(a/d),b=1/d;let Q=0;for(let P=0;P<d;P++)for(let p=0;p<W;p++){let p=t[0],B=t[2];for(let t=0;t<d;t++)for(let a=0;a<W;a++){const W=B.Uc(p).scale(Q).add(p);W.normalize();const a=this.CalcProjectionSpherical(W,A,w,N);X[P*d*3+3*t+0]+=a.r*D,X[P*d*3+3*t+1]+=a.g*D,X[P*d*3+3*t+2]+=a.b*D,p=p.add(i),B=B.add(k)}Q+=b*a}return X}static CalcProjectionSpherical(d,t,A,w){let N=Math.atan2(d.z,d.x);const p=Math.acos(d.y);for(;N<-Math.PI;)N+=2*Math.PI;for(;N>Math.PI;)N-=2*Math.PI;let B=N/Math.PI;const X=p/Math.PI;B=.5*B+.5;let W=Math.round(B*A);W<0?W=0:W>=A&&(W=A-1);let a=Math.round(X*w);a<0?a=0:a>=w&&(a=w-1);const D=w-a-1;return{r:t[D*A*3+3*W+0],g:t[D*A*3+3*W+1],b:t[D*A*3+3*W+2]}}}function p(d,t,A,w,N,p){N>0?(N=function(d,t){return t>1023?d*Math.pow(2,1023)*Math.pow(2,t-1023):t<-1074?d*Math.pow(2,-1074)*Math.pow(2,t+1074):d*Math.pow(2,t)}(1,N-136),d[p+0]=t*N,d[p+1]=A*N,d[p+2]=w*N):(d[p+0]=0,d[p+1]=0,d[p+2]=0)}function B(d,t){let A="",w="";for(let N=t;N<d.length-t&&(w=String.fromCharCode(d[N]),"\n"!=w);N++)A+=w;return A}function X(d){let t=0,A=0,w=B(d,0);if("#"!=w[0]||"?"!=w[1])throw"Bad HDR Format.";let N=!1,p=!1,X=0;do{X+=w.length+1,w=B(d,X),"FORMAT=32-bit_rle_rgbe"==w?p=!0:0==w.length&&(N=!0)}while(!N);if(!p)throw"HDR Bad header format, unsupported FORMAT";X+=w.length+1,w=B(d,X);const W=/^-Y (.*) \+X (.*)$/g.exec(w);if(!W||W.length<3)throw"HDR Bad header format, no size";if(A=parseInt(W[2]),t=parseInt(W[1]),A<8||A>32767)throw"HDR Bad header format, unsupported size";return X+=w.length+1,{height:t,width:A,dataPosition:X}}function W(d,t){return function(d,t){let A=t.height;const w=t.width;let N,B,X,W,D,i=t.dataPosition,k=0,b=0,Q=0;const P=new ArrayBuffer(4*w),J=new Uint8Array(P),U=new ArrayBuffer(t.width*t.height*4*3),T=new Float32Array(U);for(;A>0;){if(N=d[i++],B=d[i++],X=d[i++],W=d[i++],2!=N||2!=B||128&X||t.width<8||t.width>32767)return a(d,t);if((X<<8|W)!=w)throw"HDR Bad header format, wrong scan line width";for(k=0,Q=0;Q<4;Q++)for(b=(Q+1)*w;k<b;)if(N=d[i++],B=d[i++],N>128){if(D=N-128,0==D||D>b-k)throw"HDR Bad Format, bad scanline data (run)";for(;D-- >0;)J[k++]=B}else{if(D=N,0==D||D>b-k)throw"HDR Bad Format, bad scanline data (non-run)";if(J[k++]=B,--D>0)for(let t=0;t<D;t++)J[k++]=d[i++]}for(Q=0;Q<w;Q++)N=J[Q],B=J[Q+w],X=J[Q+2*w],W=J[Q+3*w],p(T,N,B,X,W,(t.height-A)*w*3+3*Q);A--}return T}(d,t)}function a(d,t){let A=t.height;const w=t.width;let N,B,X,W,a,D=t.dataPosition;const i=new ArrayBuffer(t.width*t.height*4*3),k=new Float32Array(i);for(;A>0;){for(a=0;a<t.width;a++)N=d[D++],B=d[D++],X=d[D++],W=d[D++],p(k,N,B,X,W,(t.height-A)*w*3+3*a);A--}return k}N.FACE_LEFT=[new w.l(-1,-1,-1),new w.l(1,-1,-1),new w.l(-1,1,-1),new w.l(1,1,-1)],N.FACE_RIGHT=[new w.l(1,-1,1),new w.l(-1,-1,1),new w.l(1,1,1),new w.l(-1,1,1)],N.FACE_FRONT=[new w.l(1,-1,-1),new w.l(1,-1,1),new w.l(1,1,-1),new w.l(1,1,1)],N.FACE_BACK=[new w.l(-1,-1,1),new w.l(-1,-1,-1),new w.l(-1,1,1),new w.l(-1,1,-1)],N.FACE_DOWN=[new w.l(1,1,-1),new w.l(1,1,1),new w.l(-1,1,-1),new w.l(-1,1,1)],N.FACE_UP=[new w.l(-1,-1,-1),new w.l(-1,-1,1),new w.l(1,-1,-1),new w.l(1,-1,1)];class D{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(d,t,A){const w=new Uint8Array(d.buffer,d.byteOffset,d.byteLength),N=X(w),p=W(w,N),B=N.width*N.height,a=new Float32Array(4*B);for(let X=0;X<B;X+=1)a[4*X]=p[3*X],a[4*X+1]=p[3*X+1],a[4*X+2]=p[3*X+2],a[4*X+3]=1;A(N.width,N.height,t.generateMipMaps,!1,(()=>{const d=t.getEngine();t.type=1,t.format=5,t._gammaSpace=!1,d._uploadDataToTextureDirectly(t,a)}))}}}}]);