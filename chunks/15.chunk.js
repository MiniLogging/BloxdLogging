"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{2531:(J,T,b)=>{b.r(T),b.d(T,{ReadExrDataAsync:()=>aJ,_ExrTextureLoader:()=>AJ});var q=b(519),t=b(717);const j=4,B=4,Y=1,C=2,F=8,A=65536,a=A>>3,P=14,v=65537,G=1<<P,x=G-1,I=59,u=63,U=2+u-I;var K,E;!function(J){J[J.NO_COMPRESSION=0]="NO_COMPRESSION",J[J.RLE_COMPRESSION=1]="RLE_COMPRESSION",J[J.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",J[J.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",J[J.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",J[J.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(K||(K={})),function(J){J[J.INCREASING_Y=0]="INCREASING_Y",J[J.DECREASING_Y=1]="DECREASING_Y"}(E||(E={}));const l=function(){const J=new ArrayBuffer(4),T=new Float32Array(J),b=new Uint32Array(J),q=new Uint32Array(512),t=new Uint32Array(512);for(let C=0;C<256;++C){const J=C-127;J<-27?(q[C]=0,q[256|C]=32768,t[C]=24,t[256|C]=24):J<-14?(q[C]=1024>>-J-14,q[256|C]=1024>>-J-14|32768,t[C]=-J-1,t[256|C]=-J-1):J<=15?(q[C]=J+15<<10,q[256|C]=J+15<<10|32768,t[C]=13,t[256|C]=13):J<128?(q[C]=31744,q[256|C]=64512,t[C]=24,t[256|C]=24):(q[C]=31744,q[256|C]=64512,t[C]=13,t[256|C]=13)}const j=new Uint32Array(2048),B=new Uint32Array(64),Y=new Uint32Array(64);for(let C=1;C<1024;++C){let J=C<<13,T=0;for(;0===(8388608&J);)J<<=1,T-=8388608;J&=-8388609,T+=947912704,j[C]=J|T}for(let C=1024;C<2048;++C)j[C]=939524096+(C-1024<<13);for(let C=1;C<31;++C)B[C]=C<<23;B[31]=1199570944,B[32]=2147483648;for(let C=33;C<63;++C)B[C]=2147483648+(C-32<<23);B[63]=3347054592;for(let C=1;C<64;++C)32!==C&&(Y[C]=1024);return{floatView:T,uint32View:b,baseTable:q,shiftTable:t,mantissaTable:j,exponentTable:B,offsetTable:Y}}();function W(J,T){const b=new Uint8Array(J);let q=0;for(;0!=b[T.value+q];)q+=1;const t=(new TextDecoder).decode(b.slice(T.value,T.value+q));return T.value=T.value+q+1,t}function p(J,T){const b=J.getInt32(T.value,!0);return T.value+=j,b}function o(J,T){const b=J.getUint32(T.value,!0);return T.value+=j,b}function S(J,T){const b=J.getUint8(T.value);return T.value+=Y,b}function H(J,T){const b=J.getUint16(T.value,!0);return T.value+=C,b}function s(J,T){const b=J[T.value];return T.value+=Y,b}function g(J,T){let b;return b="getBigInt64"in DataView.prototype?Number(J.getBigInt64(T.value,!0)):J.getUint32(T.value+4,!0)+Number(J.getUint32(T.value,!0)<<32),T.value+=F,b}function d(J,T){const b=J.getFloat32(T.value,!0);return T.value+=B,b}function w(J,T){return function(J){const T=(31744&J)>>10,b=1023&J;return(J>>15?-1:1)*(T?31===T?b?NaN:1/0:Math.pow(2,T-15)*(1+b/1024):b/1024*6103515625e-14)}(H(J,T))}function Z(J,T){return function(J){if(Math.abs(J)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");J=(0,t.b)(J,-65504,65504),l.floatView[0]=J;const T=l.uint32View[0],b=T>>23&511;return l.baseTable[b]+((8388607&T)>>l.shiftTable[b])}(d(J,T))}function e(J,T,b,q){switch(b){case"string":case"stringvector":case"iccProfile":return function(J,T,b){const q=(new TextDecoder).decode(new Uint8Array(J).slice(T.value,T.value+b));return T.value=T.value+b,q}(J.buffer,T,q);case"chlist":return function(J,T,b){const q=T.value,t=[];for(;T.value<q+b-1;){const b=W(J.buffer,T),q=p(J,T),j=S(J,T);T.value+=3;const B=p(J,T),Y=p(J,T);t.push({name:b,pixelType:q,pLinear:j,xSampling:B,ySampling:Y})}return T.value+=1,t}(J,T,q);case"chromaticities":return function(J,T){return{redX:d(J,T),redY:d(J,T),greenX:d(J,T),greenY:d(J,T),blueX:d(J,T),blueY:d(J,T),whiteX:d(J,T),whiteY:d(J,T)}}(J,T);case"compression":return function(J,T){return S(J,T)}(J,T);case"box2i":return function(J,T){return{xMin:p(J,T),yMin:p(J,T),xMax:p(J,T),yMax:p(J,T)}}(J,T);case"lineOrder":return function(J,T){const b=S(J,T);return E[b]}(J,T);case"float":return d(J,T);case"v2f":return function(J,T){return[d(J,T),d(J,T)]}(J,T);case"v3f":return function(J,T){return[d(J,T),d(J,T),d(J,T)]}(J,T);case"int":return p(J,T);case"rational":return function(J,T){return[p(J,T),o(J,T)]}(J,T);case"timecode":return function(J,T){return[o(J,T),o(J,T)]}(J,T);case"preview":return T.value+=q,"skipped";default:return void(T.value+=q)}}function c(J){for(let T=1;T<J.length;T++){const b=J[T-1]+J[T]-128;J[T]=b}}function V(J,T){let b=0,q=Math.floor((J.length+1)/2),t=0;const j=J.length-1;for(;!(t>j)&&(T[t++]=J[b++],!(t>j));)T[t++]=J[q++]}const Q=20000630;function h(J,T){if(J.getUint32(0,!0)!=Q)throw new Error("Incorrect OpenEXR format");const b=J.getUint8(4),t=J.getUint8(5),j={singleTile:!!(2&t),longName:!!(4&t),deepFormat:!!(8&t),multiPart:!!(16&t)};T.value=8;const B={};let Y=!0;for(;Y;){const b=W(J.buffer,T);if(b){const t=W(J.buffer,T),j=e(J,T,t,o(J,T));void 0===j?q.d.Warn(`Unknown header attribute type ${t}'.`):B[b]=j}else Y=!1}if(0!=(-5&t))throw new Error("Unsupported file format");return{version:b,spec:j,...B}}const i=32768,m=65535;function O(J,T,b,q,t){for(;b<J;)T=T<<8|s(q,t),b+=8;return{l:T>>(b-=J)&(1<<J)-1,c:T,lc:b}}function X(J,T,b,q){return{c:J=J<<8|s(b,q),lc:T+=8}}function L(J,T,b,q,t,j,B,Y,C){if(J==T){if(q<8){const J=X(b,q,t,j);b=J.c,q=J.lc}let J=b>>(q-=8);if(J=new Uint8Array([J])[0],Y.value+J>C)return null;const T=B[Y.value-1];for(;J-- >0;)B[Y.value++]=T}else{if(!(Y.value<C))return null;B[Y.value++]=J}return{c:b,lc:q}}const r=new Array(59);function N(J,T,b,q,t,j){const B=T;let Y=0,C=0;for(;q<=t;q++){if(B.value-T.value>b)return;let F=O(6,Y,C,J,B);const A=F.l;if(Y=F.c,C=F.lc,j[q]=A,A==u){if(B.value-T.value>b)throw new Error("Error in HufUnpackEncTable");F=O(8,Y,C,J,B);let A=F.l+U;if(Y=F.c,C=F.lc,q+A>t+1)throw new Error("Error in HufUnpackEncTable");for(;A--;)j[q++]=0;q--}else if(A>=I){let J=A-I+2;if(q+J>t+1)throw new Error("Error in HufUnpackEncTable");for(;J--;)j[q++]=0;q--}}!function(J){for(let b=0;b<=58;++b)r[b]=0;for(let b=0;b<v;++b)r[J[b]]+=1;let T=0;for(let b=58;b>0;--b){const J=T+r[b]>>1;r[b]=T,T=J}for(let b=0;b<v;++b){const T=J[b];T>0&&(J[b]=T|r[T]++<<6)}}(j)}function R(J){return 63&J}function n(J){return J>>6}function D(J,T,b,q,t,j){const B=b.value,Y=o(T,b),C=o(T,b);b.value+=4;const F=o(T,b);if(b.value+=4,Y<0||Y>=v||C<0||C>=v)throw new Error("Wrong HUF_ENCSIZE");const A=new Array(v),a=new Array(G);!function(J){for(let T=0;T<G;T++)J[T]={},J[T].len=0,J[T].lit=0,J[T].p=null}(a);if(N(J,b,q-(b.value-B),Y,C,A),F>8*(q-(b.value-B)))throw new Error("Wrong hufUncompress");!function(J,T,b,q){for(;T<=b;T++){const b=n(J[T]),t=R(J[T]);if(b>>t)throw new Error("Invalid table entry");if(t>P){const J=q[b>>t-P];if(J.len)throw new Error("Invalid table entry");if(J.lit++,J.p){const T=J.p;J.p=new Array(J.lit);for(let b=0;b<J.lit-1;++b)J.p[b]=T[b]}else J.p=new Array(1);J.p[J.lit-1]=T}else if(t){let J=0;for(let j=1<<P-t;j>0;j--){const j=q[(b<<P-t)+J];if(j.len||j.p)throw new Error("Invalid table entry");j.len=t,j.lit=T,J++}}}}(A,Y,C,a),function(J,T,b,q,t,j,B,Y,C){let F=0,A=0;const a=B,v=Math.trunc(q.value+(t+7)/8);for(;q.value<v;){let t=X(F,A,b,q);for(F=t.c,A=t.lc;A>=P;){const B=T[F>>A-P&x];if(B.len){A-=B.len;const J=L(B.lit,j,F,A,b,q,Y,C,a);J&&(F=J.c,A=J.lc)}else{if(!B.p)throw new Error("hufDecode issues");let T;for(T=0;T<B.lit;T++){const P=R(J[B.p[T]]);for(;A<P&&q.value<v;)t=X(F,A,b,q),F=t.c,A=t.lc;if(A>=P&&n(J[B.p[T]])==(F>>A-P&(1<<P)-1)){A-=P;const J=L(B.p[T],j,F,A,b,q,Y,C,a);J&&(F=J.c,A=J.lc);break}}if(T==B.lit)throw new Error("HufDecode issues")}}}const G=8-t&7;for(F>>=G,A-=G;A>0;){const J=T[F<<P-A&x];if(!J.len)throw new Error("HufDecode issues");{A-=J.len;const T=L(J.lit,j,F,A,b,q,Y,C,a);T&&(F=T.c,A=T.lc)}}}(A,a,J,b,F,C,j,t,{value:0})}function f(J){return 65535&J}function z(J){const T=f(J);return T>32767?T-65536:T}function M(J,T){const b=z(J),q=z(T),t=b+(1&q)+(q>>1);return{a:t,b:t-q}}function y(J,T){const b=f(J),q=f(T),t=b-(q>>1)&m;return{a:q+t-i&m,b:t}}function k(J,T,b,q,t,j,B){const Y=B<16384,C=b>t?t:b;let F,A,a=1;for(;a<=C;)a<<=1;for(a>>=1,F=a,a>>=1;a>=1;){A=0;const B=A+j*(t-F),C=j*a,P=j*F,v=q*a,G=q*F;let x,I,u,U;for(;A<=B;A+=P){let t=A;const j=A+q*(b-F);for(;t<=j;t+=G){const b=t+v,q=t+C,j=q+v;if(Y){let B=M(J[t+T],J[q+T]);x=B.a,u=B.b,B=M(J[b+T],J[j+T]),I=B.a,U=B.b,B=M(x,I),J[t+T]=B.a,J[b+T]=B.b,B=M(u,U),J[q+T]=B.a,J[j+T]=B.b}else{let B=y(J[t+T],J[q+T]);x=B.a,u=B.b,B=y(J[b+T],J[j+T]),I=B.a,U=B.b,B=y(x,I),J[t+T]=B.a,J[b+T]=B.b,B=y(u,U),J[q+T]=B.a,J[j+T]=B.b}}if(b&a){const b=t+C;let q;q=Y?M(J[t+T],J[b+T]):y(J[t+T],J[b+T]),x=q.a,J[b+T]=q.b,J[t+T]=x}}if(t&a){let t=A;const j=A+q*(b-F);for(;t<=j;t+=G){const b=t+v;let q;q=Y?M(J[t+T],J[b+T]):y(J[t+T],J[b+T]),x=q.a,J[b+T]=q.b,J[t+T]=x}}F=a,a>>=1}return A}function JJ(J){return new DataView(J.array.buffer,J.offset.value,J.size)}function TJ(J){const T=J.viewer.buffer.slice(J.offset.value,J.offset.value+J.size),b=new Uint8Array(function(J){let T=J.byteLength;const b=[];let q=0;const t=new DataView(J);for(;T>0;){const J=t.getInt8(q++);if(J<0){const j=-J;T-=j+1;for(let J=0;J<j;J++)b.push(t.getUint8(q++))}else{const j=J;T-=2;const B=t.getUint8(q++);for(let J=0;J<j+1;J++)b.push(B)}}return b}(T)),q=new Uint8Array(b.length);return c(b),V(b,q),new DataView(q.buffer)}function bJ(J){const T=J.array.slice(J.offset.value,J.offset.value+J.size),b=fflate.unzlibSync(T),q=new Uint8Array(b.length);return c(b),V(b,q),new DataView(q.buffer)}function qJ(J){const T=J.array.slice(J.offset.value,J.offset.value+J.size),b=fflate.unzlibSync(T),q=J.lines*J.channels*J.width,t=1==J.type?new Uint16Array(q):new Uint32Array(q);let j=0,B=0;const Y=new Array(4);for(let C=0;C<J.lines;C++)for(let T=0;T<J.channels;T++){let T=0;switch(J.type){case 1:Y[0]=j,Y[1]=Y[0]+J.width,j=Y[1]+J.width;for(let q=0;q<J.width;++q){T+=b[Y[0]++]<<8|b[Y[1]++],t[B]=T,B++}break;case 2:Y[0]=j,Y[1]=Y[0]+J.width,Y[2]=Y[1]+J.width,j=Y[2]+J.width;for(let q=0;q<J.width;++q){T+=b[Y[0]++]<<24|b[Y[1]++]<<16|b[Y[2]++]<<8,t[B]=T,B++}}}return new DataView(t.buffer)}function tJ(J){const T=J.viewer,b={value:J.offset.value},q=new Uint16Array(J.width*J.scanlineBlockSize*(J.channels*J.type)),t=new Uint8Array(a);let j=0;const B=new Array(J.channels);for(let C=0;C<J.channels;C++)B[C]={},B[C].start=j,B[C].end=B[C].start,B[C].nx=J.width,B[C].ny=J.lines,B[C].size=J.type,j+=B[C].nx*B[C].ny*B[C].size;const Y=H(T,b),F=H(T,b);if(F>=a)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(Y<=F)for(let C=0;C<F-Y+1;C++)t[C+Y]=S(T,b);const P=new Uint16Array(A),v=function(J,T){let b=0;for(let t=0;t<A;++t)(0==t||J[t>>3]&1<<(7&t))&&(T[b++]=t);const q=b-1;for(;b<A;)T[b++]=0;return q}(t,P),G=o(T,b);D(J.array,T,b,G,q,j);for(let C=0;C<J.channels;++C){const J=B[C];for(let T=0;T<B[C].size;++T)k(q,J.start+T,J.nx,J.size,J.ny,J.nx*J.size,v)}!function(J,T,b){for(let q=0;q<b;++q)T[q]=J[T[q]]}(P,q,j);let x=0;const I=new Uint8Array(q.buffer.byteLength);for(let A=0;A<J.lines;A++)for(let T=0;T<J.channels;T++){const J=B[T],b=J.nx*J.size,t=new Uint8Array(q.buffer,J.end*C,b*C);I.set(t,x),x+=b*C,J.end+=b}return new DataView(I.buffer)}var jJ,BJ=b(505);!function(J){J[J.Float=0]="Float",J[J.HalfFloat=1]="HalfFloat"}(jJ||(jJ={}));class YJ{}async function CJ(J,T,b,q){const t={size:0,viewer:T,array:new Uint8Array(T.buffer),offset:b,width:J.dataWindow.xMax-J.dataWindow.xMin+1,height:J.dataWindow.yMax-J.dataWindow.yMin+1,channels:J.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(J.compression){case K.NO_COMPRESSION:t.lines=1,t.uncompress=JJ;break;case K.RLE_COMPRESSION:t.lines=1,t.uncompress=TJ;break;case K.ZIPS_COMPRESSION:t.lines=1,t.uncompress=bJ,await BJ.e.LoadScriptAsync(YJ.FFLATEUrl);break;case K.ZIP_COMPRESSION:t.lines=16,t.uncompress=bJ,await BJ.e.LoadScriptAsync(YJ.FFLATEUrl);break;case K.PIZ_COMPRESSION:t.lines=32,t.uncompress=tJ;break;case K.PXR24_COMPRESSION:t.lines=16,t.uncompress=qJ,await BJ.e.LoadScriptAsync(YJ.FFLATEUrl);break;default:throw new Error(K[J.compression]+" is unsupported")}t.scanlineBlockSize=t.lines;const j={};for(const B of J.channels)switch(B.name){case"R":case"G":case"B":case"A":case"Y":j[B.name]=!0,t.type=B.pixelType}let Y=!1;if(j.R&&j.G&&j.B&&j.A)t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(j.R&&j.G&&j.B)Y=!0,t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(j.R&&j.G)t.outputChannels=2,t.decodeChannels={R:0,G:1};else if(j.R)t.outputChannels=1,t.decodeChannels={R:0};else{if(!j.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");t.outputChannels=1,t.decodeChannels={Y:0}}if(1===t.type)switch(q){case jJ.Float:t.getter=w,t.inputSize=C;break;case jJ.HalfFloat:t.getter=H,t.inputSize=C}else{if(2!==t.type)throw new Error("Unsupported pixelType "+t.type+" for "+J.compression);switch(q){case jJ.Float:t.getter=d,t.inputSize=B;break;case jJ.HalfFloat:t.getter=Z,t.inputSize=B}}t.blockCount=t.height/t.scanlineBlockSize;for(let B=0;B<t.blockCount;B++)g(T,b);const F=t.width*t.height*t.outputChannels;switch(q){case jJ.Float:t.byteArray=new Float32Array(F),t.textureType=1,Y&&t.byteArray.fill(1,0,F);break;case jJ.HalfFloat:t.byteArray=new Uint16Array(F),t.textureType=2,Y&&t.byteArray.fill(15360,0,F);break;default:throw new Error("Unsupported type: "+q)}let A=0;for(const B of J.channels)void 0!==t.decodeChannels[B.name]&&(t.channelLineOffsets[B.name]=A*t.width),A+=2*B.pixelType;return t.bytesPerLine=t.width*A,t.outLineWidth=t.width*t.outputChannels,"INCREASING_Y"===J.lineOrder?t.scanOrder=J=>J:t.scanOrder=J=>t.height-1-J,4==t.outputChannels?(t.format=5,t.linearSpace=!0):(t.format=6,t.linearSpace=!1),t}function FJ(J,T,b,q){const t={value:0};for(let j=0;j<J.height/J.scanlineBlockSize;j++){const B=p(b,q)-T.dataWindow.yMin;J.size=o(b,q),J.lines=B+J.scanlineBlockSize>J.height?J.height-B:J.scanlineBlockSize;const Y=J.size<J.lines*J.bytesPerLine&&J.uncompress?J.uncompress(J):JJ(J);q.value+=J.size;for(let b=0;b<J.scanlineBlockSize;b++){const q=j*J.scanlineBlockSize,B=b+J.scanOrder(q);if(B>=J.height)continue;const C=b*J.bytesPerLine,F=(J.height-1-B)*J.outLineWidth;for(let b=0;b<J.channels;b++){const q=T.channels[b].name,j=J.channelLineOffsets[q],B=J.decodeChannels[q];if(void 0!==B){t.value=C+j;for(let T=0;T<J.width;T++){const b=F+T*J.outputChannels+B;J.byteArray&&(J.byteArray[b]=J.getter(Y,t))}}}}}}YJ.DefaultOutputType=jJ.HalfFloat,YJ.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class AJ{constructor(){this.supportCascades=!1}loadCubeData(J,T,b,q,t){throw".exr not supported in Cube."}loadData(J,T,b){const t=new DataView(J.buffer),j={value:0},B=h(t,j);CJ(B,t,j,YJ.DefaultOutputType).then((J=>{FJ(J,B,t,j);const q=B.dataWindow.xMax-B.dataWindow.xMin+1,Y=B.dataWindow.yMax-B.dataWindow.yMin+1;b(q,Y,T.generateMipMaps,!1,(()=>{const b=T.getEngine();T.format=B.format,T.type=J.textureType,T.invertY=!1,T._gammaSpace=!B.linearSpace,J.byteArray&&b._uploadDataToTextureDirectly(T,J.byteArray,0,0,void 0,!0)}))})).catch((J=>{q.d.Error("Failed to load EXR texture: ",J)}))}}async function aJ(J){const T=new DataView(J),b={value:0},t=h(T,b);try{const J=await CJ(t,T,b,jJ.Float);return FJ(J,t,T,b),J.byteArray?{width:t.dataWindow.xMax-t.dataWindow.xMin+1,height:t.dataWindow.yMax-t.dataWindow.yMin+1,data:new Float32Array(J.byteArray)}:(q.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(j){q.d.Error("Failed to load EXR data: ",j)}return{width:0,height:0,data:null}}}}]);