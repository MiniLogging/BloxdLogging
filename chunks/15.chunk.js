"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{13036:(y,g,f)=>{f.r(g),f.d(g,{_HDRTextureLoader:()=>c});var p=f(11054);class S{static ConvertPanoramaToCubemap(y,g,f,p){let S=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!y)throw"ConvertPanoramaToCubemap: input cannot be null";if(y.length!=g*f*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(p,this.FACE_FRONT,y,g,f,S),back:this.CreateCubemapTexture(p,this.FACE_BACK,y,g,f,S),left:this.CreateCubemapTexture(p,this.FACE_LEFT,y,g,f,S),right:this.CreateCubemapTexture(p,this.FACE_RIGHT,y,g,f,S),up:this.CreateCubemapTexture(p,this.FACE_UP,y,g,f,S),down:this.CreateCubemapTexture(p,this.FACE_DOWN,y,g,f,S),size:p,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(y,g,f,p,S){let k=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=new ArrayBuffer(y*y*4*3),H=new Float32Array(i),U=k?Math.max(1,Math.round(p/4/y)):1,l=1/U,c=l*l,Z=g[1].ed(g[0]).scale(l/y),C=g[3].ed(g[2]).scale(l/y),q=1/y;let W=0;for(let j=0;j<y;j++)for(let k=0;k<U;k++){let k=g[0],i=g[2];for(let g=0;g<y;g++)for(let l=0;l<U;l++){const U=i.ed(k).scale(W).add(k);U.normalize();const l=this.CalcProjectionSpherical(U,f,p,S);H[j*y*3+3*g+0]+=l.r*c,H[j*y*3+3*g+1]+=l.g*c,H[j*y*3+3*g+2]+=l.b*c,k=k.add(Z),i=i.add(C)}W+=q*l}return H}static CalcProjectionSpherical(y,g,f,p){let S=Math.atan2(y.z,y.x);const k=Math.acos(y.y);for(;S<-Math.PI;)S+=2*Math.PI;for(;S>Math.PI;)S-=2*Math.PI;let i=S/Math.PI;const H=k/Math.PI;i=.5*i+.5;let U=Math.round(i*f);U<0?U=0:U>=f&&(U=f-1);let l=Math.round(H*p);l<0?l=0:l>=p&&(l=p-1);const c=p-l-1;return{r:g[c*f*3+3*U+0],g:g[c*f*3+3*U+1],b:g[c*f*3+3*U+2]}}}function k(y,g,f,p,S,k){S>0?(S=function(y,g){return g>1023?y*Math.pow(2,1023)*Math.pow(2,g-1023):g<-1074?y*Math.pow(2,-1074)*Math.pow(2,g+1074):y*Math.pow(2,g)}(1,S-136),y[k+0]=g*S,y[k+1]=f*S,y[k+2]=p*S):(y[k+0]=0,y[k+1]=0,y[k+2]=0)}function i(y,g){let f="",p="";for(let S=g;S<y.length-g&&(p=String.fromCharCode(y[S]),"\n"!=p);S++)f+=p;return f}function H(y){let g=0,f=0,p=i(y,0);if("#"!=p[0]||"?"!=p[1])throw"Bad HDR Format.";let S=!1,k=!1,H=0;do{H+=p.length+1,p=i(y,H),"FORMAT=32-bit_rle_rgbe"==p?k=!0:0==p.length&&(S=!0)}while(!S);if(!k)throw"HDR Bad header format, unsupported FORMAT";H+=p.length+1,p=i(y,H);const U=/^-Y (.*) \+X (.*)$/g.exec(p);if(!U||U.length<3)throw"HDR Bad header format, no size";if(f=parseInt(U[2]),g=parseInt(U[1]),f<8||f>32767)throw"HDR Bad header format, unsupported size";return H+=p.length+1,{height:g,width:f,dataPosition:H}}function U(y,g){return function(y,g){let f=g.height;const p=g.width;let S,i,H,U,c,Z=g.dataPosition,C=0,q=0,W=0;const j=new ArrayBuffer(4*p),P=new Uint8Array(j),B=new ArrayBuffer(g.width*g.height*4*3),R=new Float32Array(B);for(;f>0;){if(S=y[Z++],i=y[Z++],H=y[Z++],U=y[Z++],2!=S||2!=i||128&H||g.width<8||g.width>32767)return l(y,g);if((H<<8|U)!=p)throw"HDR Bad header format, wrong scan line width";for(C=0,W=0;W<4;W++)for(q=(W+1)*p;C<q;)if(S=y[Z++],i=y[Z++],S>128){if(c=S-128,0==c||c>q-C)throw"HDR Bad Format, bad scanline data (run)";for(;c-- >0;)P[C++]=i}else{if(c=S,0==c||c>q-C)throw"HDR Bad Format, bad scanline data (non-run)";if(P[C++]=i,--c>0)for(let g=0;g<c;g++)P[C++]=y[Z++]}for(W=0;W<p;W++)S=P[W],i=P[W+p],H=P[W+2*p],U=P[W+3*p],k(R,S,i,H,U,(g.height-f)*p*3+3*W);f--}return R}(y,g)}function l(y,g){let f=g.height;const p=g.width;let S,i,H,U,l,c=g.dataPosition;const Z=new ArrayBuffer(g.width*g.height*4*3),C=new Float32Array(Z);for(;f>0;){for(l=0;l<g.width;l++)S=y[c++],i=y[c++],H=y[c++],U=y[c++],k(C,S,i,H,U,(g.height-f)*p*3+3*l);f--}return C}S.FACE_LEFT=[new p.m(-1,-1,-1),new p.m(1,-1,-1),new p.m(-1,1,-1),new p.m(1,1,-1)],S.FACE_RIGHT=[new p.m(1,-1,1),new p.m(-1,-1,1),new p.m(1,1,1),new p.m(-1,1,1)],S.FACE_FRONT=[new p.m(1,-1,-1),new p.m(1,-1,1),new p.m(1,1,-1),new p.m(1,1,1)],S.FACE_BACK=[new p.m(-1,-1,1),new p.m(-1,-1,-1),new p.m(-1,1,1),new p.m(-1,1,-1)],S.FACE_DOWN=[new p.m(1,1,-1),new p.m(1,1,1),new p.m(-1,1,-1),new p.m(-1,1,1)],S.FACE_UP=[new p.m(-1,-1,-1),new p.m(-1,-1,1),new p.m(1,-1,-1),new p.m(1,-1,1)];class c{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(y,g,f){const p=new Uint8Array(y.buffer,y.byteOffset,y.byteLength),S=H(p),k=U(p,S),i=S.width*S.height,l=new Float32Array(4*i);for(let H=0;H<i;H+=1)l[4*H]=k[3*H],l[4*H+1]=k[3*H+1],l[4*H+2]=k[3*H+2],l[4*H+3]=1;f(S.width,S.height,g.generateMipMaps,!1,(()=>{const y=g.getEngine();g.type=1,g.format=5,g._gammaSpace=!1,y._uploadDataToTextureDirectly(g,l)}))}}}}]);