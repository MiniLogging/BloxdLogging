"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12706:(A,e,E)=>{E.r(e),E.d(e,{_HDRTextureLoader:()=>w});var Q=E(11030);class x{static ConvertPanoramaToCubemap(A,e,E,Q){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!A)throw"ConvertPanoramaToCubemap: input cannot be null";if(A.length!=e*E*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(Q,this.FACE_FRONT,A,e,E,x),back:this.CreateCubemapTexture(Q,this.FACE_BACK,A,e,E,x),left:this.CreateCubemapTexture(Q,this.FACE_LEFT,A,e,E,x),right:this.CreateCubemapTexture(Q,this.FACE_RIGHT,A,e,E,x),up:this.CreateCubemapTexture(Q,this.FACE_UP,A,e,E,x),down:this.CreateCubemapTexture(Q,this.FACE_DOWN,A,e,E,x),size:Q,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(A,e,E,Q,x){let t=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const H=new ArrayBuffer(A*A*4*3),h=new Float32Array(H),Y=t?Math.max(1,Math.round(Q/4/A)):1,F=1/Y,w=F*F,r=e[1].Dd(e[0]).scale(F/A),S=e[3].Dd(e[2]).scale(F/A),v=1/A;let c=0;for(let D=0;D<A;D++)for(let t=0;t<Y;t++){let t=e[0],H=e[2];for(let e=0;e<A;e++)for(let F=0;F<Y;F++){const Y=H.Dd(t).scale(c).add(t);Y.normalize();const F=this.CalcProjectionSpherical(Y,E,Q,x);h[D*A*3+3*e+0]+=F.r*w,h[D*A*3+3*e+1]+=F.g*w,h[D*A*3+3*e+2]+=F.b*w,t=t.add(r),H=H.add(S)}c+=v*F}return h}static CalcProjectionSpherical(A,e,E,Q){let x=Math.atan2(A.z,A.x);const t=Math.acos(A.y);for(;x<-Math.PI;)x+=2*Math.PI;for(;x>Math.PI;)x-=2*Math.PI;let H=x/Math.PI;const h=t/Math.PI;H=.5*H+.5;let Y=Math.round(H*E);Y<0?Y=0:Y>=E&&(Y=E-1);let F=Math.round(h*Q);F<0?F=0:F>=Q&&(F=Q-1);const w=Q-F-1;return{r:e[w*E*3+3*Y+0],g:e[w*E*3+3*Y+1],b:e[w*E*3+3*Y+2]}}}function t(A,e,E,Q,x,t){x>0?(x=function(A,e){return e>1023?A*Math.pow(2,1023)*Math.pow(2,e-1023):e<-1074?A*Math.pow(2,-1074)*Math.pow(2,e+1074):A*Math.pow(2,e)}(1,x-136),A[t+0]=e*x,A[t+1]=E*x,A[t+2]=Q*x):(A[t+0]=0,A[t+1]=0,A[t+2]=0)}function H(A,e){let E="",Q="";for(let x=e;x<A.length-e&&(Q=String.fromCharCode(A[x]),"\n"!=Q);x++)E+=Q;return E}function h(A){let e=0,E=0,Q=H(A,0);if("#"!=Q[0]||"?"!=Q[1])throw"Bad HDR Format.";let x=!1,t=!1,h=0;do{h+=Q.length+1,Q=H(A,h),"FORMAT=32-bit_rle_rgbe"==Q?t=!0:0==Q.length&&(x=!0)}while(!x);if(!t)throw"HDR Bad header format, unsupported FORMAT";h+=Q.length+1,Q=H(A,h);const Y=/^-Y (.*) \+X (.*)$/g.exec(Q);if(!Y||Y.length<3)throw"HDR Bad header format, no size";if(E=parseInt(Y[2]),e=parseInt(Y[1]),E<8||E>32767)throw"HDR Bad header format, unsupported size";return h+=Q.length+1,{height:e,width:E,dataPosition:h}}function Y(A,e){return function(A,e){let E=e.height;const Q=e.width;let x,H,h,Y,w,r=e.dataPosition,S=0,v=0,c=0;const D=new ArrayBuffer(4*Q),a=new Uint8Array(D),z=new ArrayBuffer(e.width*e.height*4*3),I=new Float32Array(z);for(;E>0;){if(x=A[r++],H=A[r++],h=A[r++],Y=A[r++],2!=x||2!=H||128&h||e.width<8||e.width>32767)return F(A,e);if((h<<8|Y)!=Q)throw"HDR Bad header format, wrong scan line width";for(S=0,c=0;c<4;c++)for(v=(c+1)*Q;S<v;)if(x=A[r++],H=A[r++],x>128){if(w=x-128,0==w||w>v-S)throw"HDR Bad Format, bad scanline data (run)";for(;w-- >0;)a[S++]=H}else{if(w=x,0==w||w>v-S)throw"HDR Bad Format, bad scanline data (non-run)";if(a[S++]=H,--w>0)for(let e=0;e<w;e++)a[S++]=A[r++]}for(c=0;c<Q;c++)x=a[c],H=a[c+Q],h=a[c+2*Q],Y=a[c+3*Q],t(I,x,H,h,Y,(e.height-E)*Q*3+3*c);E--}return I}(A,e)}function F(A,e){let E=e.height;const Q=e.width;let x,H,h,Y,F,w=e.dataPosition;const r=new ArrayBuffer(e.width*e.height*4*3),S=new Float32Array(r);for(;E>0;){for(F=0;F<e.width;F++)x=A[w++],H=A[w++],h=A[w++],Y=A[w++],t(S,x,H,h,Y,(e.height-E)*Q*3+3*F);E--}return S}x.FACE_LEFT=[new Q.n(-1,-1,-1),new Q.n(1,-1,-1),new Q.n(-1,1,-1),new Q.n(1,1,-1)],x.FACE_RIGHT=[new Q.n(1,-1,1),new Q.n(-1,-1,1),new Q.n(1,1,1),new Q.n(-1,1,1)],x.FACE_FRONT=[new Q.n(1,-1,-1),new Q.n(1,-1,1),new Q.n(1,1,-1),new Q.n(1,1,1)],x.FACE_BACK=[new Q.n(-1,-1,1),new Q.n(-1,-1,-1),new Q.n(-1,1,1),new Q.n(-1,1,-1)],x.FACE_DOWN=[new Q.n(1,1,-1),new Q.n(1,1,1),new Q.n(-1,1,-1),new Q.n(-1,1,1)],x.FACE_UP=[new Q.n(-1,-1,-1),new Q.n(-1,-1,1),new Q.n(1,-1,-1),new Q.n(1,-1,1)];class w{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(A,e,E){const Q=new Uint8Array(A.buffer,A.byteOffset,A.byteLength),x=h(Q),t=Y(Q,x),H=x.width*x.height,F=new Float32Array(4*H);for(let h=0;h<H;h+=1)F[4*h]=t[3*h],F[4*h+1]=t[3*h+1],F[4*h+2]=t[3*h+2],F[4*h+3]=1;E(x.width,x.height,e.generateMipMaps,!1,(()=>{const A=e.getEngine();e.type=1,e.format=5,e._gammaSpace=!1,A._uploadDataToTextureDirectly(e,F)}))}}}}]);