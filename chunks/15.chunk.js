"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[15],{12634:(K,b,e)=>{e.r(b),e.d(b,{_HDRTextureLoader:()=>A});var z=e(10967);class k{static ConvertPanoramaToCubemap(K,b,e,z){let k=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!K)throw"ConvertPanoramaToCubemap: input cannot be null";if(K.length!=b*e*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(z,this.FACE_FRONT,K,b,e,k),back:this.CreateCubemapTexture(z,this.FACE_BACK,K,b,e,k),left:this.CreateCubemapTexture(z,this.FACE_LEFT,K,b,e,k),right:this.CreateCubemapTexture(z,this.FACE_RIGHT,K,b,e,k),up:this.CreateCubemapTexture(z,this.FACE_UP,K,b,e,k),down:this.CreateCubemapTexture(z,this.FACE_DOWN,K,b,e,k),size:z,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(K,b,e,z,k){let j=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const T=new ArrayBuffer(K*K*4*3),F=new Float32Array(T),l=j?Math.max(1,Math.round(z/4/K)):1,Y=1/l,A=Y*Y,X=b[1].Qc(b[0]).scale(Y/K),t=b[3].Qc(b[2]).scale(Y/K),U=1/K;let B=0;for(let u=0;u<K;u++)for(let j=0;j<l;j++){let j=b[0],T=b[2];for(let b=0;b<K;b++)for(let Y=0;Y<l;Y++){const l=T.Qc(j).scale(B).add(j);l.normalize();const Y=this.CalcProjectionSpherical(l,e,z,k);F[u*K*3+3*b+0]+=Y.r*A,F[u*K*3+3*b+1]+=Y.g*A,F[u*K*3+3*b+2]+=Y.b*A,j=j.add(X),T=T.add(t)}B+=U*Y}return F}static CalcProjectionSpherical(K,b,e,z){let k=Math.atan2(K.z,K.x);const j=Math.acos(K.y);for(;k<-Math.PI;)k+=2*Math.PI;for(;k>Math.PI;)k-=2*Math.PI;let T=k/Math.PI;const F=j/Math.PI;T=.5*T+.5;let l=Math.round(T*e);l<0?l=0:l>=e&&(l=e-1);let Y=Math.round(F*z);Y<0?Y=0:Y>=z&&(Y=z-1);const A=z-Y-1;return{r:b[A*e*3+3*l+0],g:b[A*e*3+3*l+1],b:b[A*e*3+3*l+2]}}}function j(K,b,e,z,k,j){k>0?(k=function(K,b){return b>1023?K*Math.pow(2,1023)*Math.pow(2,b-1023):b<-1074?K*Math.pow(2,-1074)*Math.pow(2,b+1074):K*Math.pow(2,b)}(1,k-136),K[j+0]=b*k,K[j+1]=e*k,K[j+2]=z*k):(K[j+0]=0,K[j+1]=0,K[j+2]=0)}function T(K,b){let e="",z="";for(let k=b;k<K.length-b&&(z=String.fromCharCode(K[k]),"\n"!=z);k++)e+=z;return e}function F(K){let b=0,e=0,z=T(K,0);if("#"!=z[0]||"?"!=z[1])throw"Bad HDR Format.";let k=!1,j=!1,F=0;do{F+=z.length+1,z=T(K,F),"FORMAT=32-bit_rle_rgbe"==z?j=!0:0==z.length&&(k=!0)}while(!k);if(!j)throw"HDR Bad header format, unsupported FORMAT";F+=z.length+1,z=T(K,F);const l=/^-Y (.*) \+X (.*)$/g.exec(z);if(!l||l.length<3)throw"HDR Bad header format, no size";if(e=parseInt(l[2]),b=parseInt(l[1]),e<8||e>32767)throw"HDR Bad header format, unsupported size";return F+=z.length+1,{height:b,width:e,dataPosition:F}}function l(K,b){return function(K,b){let e=b.height;const z=b.width;let k,T,F,l,A,X=b.dataPosition,t=0,U=0,B=0;const u=new ArrayBuffer(4*z),m=new Uint8Array(u),D=new ArrayBuffer(b.width*b.height*4*3),I=new Float32Array(D);for(;e>0;){if(k=K[X++],T=K[X++],F=K[X++],l=K[X++],2!=k||2!=T||128&F||b.width<8||b.width>32767)return Y(K,b);if((F<<8|l)!=z)throw"HDR Bad header format, wrong scan line width";for(t=0,B=0;B<4;B++)for(U=(B+1)*z;t<U;)if(k=K[X++],T=K[X++],k>128){if(A=k-128,0==A||A>U-t)throw"HDR Bad Format, bad scanline data (run)";for(;A-- >0;)m[t++]=T}else{if(A=k,0==A||A>U-t)throw"HDR Bad Format, bad scanline data (non-run)";if(m[t++]=T,--A>0)for(let b=0;b<A;b++)m[t++]=K[X++]}for(B=0;B<z;B++)k=m[B],T=m[B+z],F=m[B+2*z],l=m[B+3*z],j(I,k,T,F,l,(b.height-e)*z*3+3*B);e--}return I}(K,b)}function Y(K,b){let e=b.height;const z=b.width;let k,T,F,l,Y,A=b.dataPosition;const X=new ArrayBuffer(b.width*b.height*4*3),t=new Float32Array(X);for(;e>0;){for(Y=0;Y<b.width;Y++)k=K[A++],T=K[A++],F=K[A++],l=K[A++],j(t,k,T,F,l,(b.height-e)*z*3+3*Y);e--}return t}k.FACE_LEFT=[new z.k(-1,-1,-1),new z.k(1,-1,-1),new z.k(-1,1,-1),new z.k(1,1,-1)],k.FACE_RIGHT=[new z.k(1,-1,1),new z.k(-1,-1,1),new z.k(1,1,1),new z.k(-1,1,1)],k.FACE_FRONT=[new z.k(1,-1,-1),new z.k(1,-1,1),new z.k(1,1,-1),new z.k(1,1,1)],k.FACE_BACK=[new z.k(-1,-1,1),new z.k(-1,-1,-1),new z.k(-1,1,1),new z.k(-1,1,-1)],k.FACE_DOWN=[new z.k(1,1,-1),new z.k(1,1,1),new z.k(-1,1,-1),new z.k(-1,1,1)],k.FACE_UP=[new z.k(-1,-1,-1),new z.k(-1,-1,1),new z.k(1,-1,-1),new z.k(1,-1,1)];class A{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(K,b,e){const z=new Uint8Array(K.buffer,K.byteOffset,K.byteLength),k=F(z),j=l(z,k),T=k.width*k.height,Y=new Float32Array(4*T);for(let F=0;F<T;F+=1)Y[4*F]=j[3*F],Y[4*F+1]=j[3*F+1],Y[4*F+2]=j[3*F+2],Y[4*F+3]=1;e(k.width,k.height,b.generateMipMaps,!1,(()=>{const K=b.getEngine();b.type=1,b.format=5,b._gammaSpace=!1,K._uploadDataToTextureDirectly(b,Y)}))}}}}]);