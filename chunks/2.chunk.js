"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[2],{2264:(a,x,Q)=>{Q.r(x),Q.d(x,{_DDSTextureLoader:()=>D});var s=Q(2272),h=Q(2296);class D{constructor(){this.supportCascades=!0}loadCubeData(a,x,Q,D){const N=x.getEngine();let C,R=!1,U=1e3;if(Array.isArray(a))for(let s=0;s<a.length;s++){const Q=a[s];C=h.c.GetDDSInfo(Q),x.width=C.width,x.height=C.height,R=(C.isRGB||C.isLuminance||C.mipmapCount>1)&&x.generateMipMaps,N._unpackFlipY(C.isCompressed),h.c.UploadDDSLevels(N,x,Q,C,R,6,-1,s),C.isFourCC||1!==C.mipmapCount?U=C.mipmapCount-1:N.generateMipMapsForCubemap(x)}else{const D=a;C=h.c.GetDDSInfo(D),x.width=C.width,x.height=C.height,Q&&(C.sphericalPolynomial=new s.f),R=(C.isRGB||C.isLuminance||C.mipmapCount>1)&&x.generateMipMaps,N._unpackFlipY(C.isCompressed),h.c.UploadDDSLevels(N,x,D,C,R,6),C.isFourCC||1!==C.mipmapCount?U=C.mipmapCount-1:N.generateMipMapsForCubemap(x,!1)}N._setCubeMapTextureParams(x,R,U),x.isReady=!0,x.onLoadedObservable.notifyObservers(x),x.onLoadedObservable.clear(),D&&D({isDDS:!0,width:x.width,info:C,data:a,texture:x})}loadData(a,x,Q){const s=h.c.GetDDSInfo(a),D=(s.isRGB||s.isLuminance||s.mipmapCount>1)&&x.generateMipMaps&&Math.max(s.width,s.height)>>s.mipmapCount-1===1;Q(s.width,s.height,D,s.isFourCC,(()=>{h.c.UploadDDSLevels(x.getEngine(),x,a,s,D,1)}))}}}}]);