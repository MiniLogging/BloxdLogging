"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[2],{2319:(k,M,F)=>{F.r(M),F.d(M,{_DDSTextureLoader:()=>g});var l=F(2323),t=F(2351);class g{constructor(){this.supportCascades=!0}loadCubeData(k,M,F,g){const B=M.getEngine();let G,A=!1,N=1e3;if(Array.isArray(k))for(let l=0;l<k.length;l++){const F=k[l];G=t.b.GetDDSInfo(F),M.width=G.width,M.height=G.height,A=(G.isRGB||G.isLuminance||G.mipmapCount>1)&&M.generateMipMaps,B._unpackFlipY(G.isCompressed),t.b.UploadDDSLevels(B,M,F,G,A,6,-1,l),G.isFourCC||1!==G.mipmapCount?N=G.mipmapCount-1:B.generateMipMapsForCubemap(M)}else{const g=k;G=t.b.GetDDSInfo(g),M.width=G.width,M.height=G.height,F&&(G.sphericalPolynomial=new l.f),A=(G.isRGB||G.isLuminance||G.mipmapCount>1)&&M.generateMipMaps,B._unpackFlipY(G.isCompressed),t.b.UploadDDSLevels(B,M,g,G,A,6),G.isFourCC||1!==G.mipmapCount?N=G.mipmapCount-1:B.generateMipMapsForCubemap(M,!1)}B._setCubeMapTextureParams(M,A,N),M.isReady=!0,M.onLoadedObservable.notifyObservers(M),M.onLoadedObservable.clear(),g&&g({isDDS:!0,width:M.width,info:G,data:k,texture:M})}loadData(k,M,F){const l=t.b.GetDDSInfo(k),g=(l.isRGB||l.isLuminance||l.mipmapCount>1)&&M.generateMipMaps&&Math.max(l.width,l.height)>>l.mipmapCount-1===1;F(l.width,l.height,g,l.isFourCC,(()=>{t.b.UploadDDSLevels(M.getEngine(),M,k,l,g,1)}))}}}}]);