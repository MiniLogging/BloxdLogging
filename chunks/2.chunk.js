"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[2],{1993:(j,H,s)=>{s.r(H),s.d(H,{_DDSTextureLoader:()=>e});var i=s(1997),B=s(2014);class e{constructor(){this.supportCascades=!0}loadCubeData(j,H,s,e){const k=H.getEngine();let V,C=!1,L=1e3;if(Array.isArray(j))for(let i=0;i<j.length;i++){const s=j[i];V=B.d.GetDDSInfo(s),H.width=V.width,H.height=V.height,C=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&H.generateMipMaps,k._unpackFlipY(V.isCompressed),B.d.UploadDDSLevels(k,H,s,V,C,6,-1,i),V.isFourCC||1!==V.mipmapCount?L=V.mipmapCount-1:k.generateMipMapsForCubemap(H)}else{const e=j;V=B.d.GetDDSInfo(e),H.width=V.width,H.height=V.height,s&&(V.sphericalPolynomial=new i.f),C=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&H.generateMipMaps,k._unpackFlipY(V.isCompressed),B.d.UploadDDSLevels(k,H,e,V,C,6),V.isFourCC||1!==V.mipmapCount?L=V.mipmapCount-1:k.generateMipMapsForCubemap(H,!1)}k._setCubeMapTextureParams(H,C,L),H.isReady=!0,H.onLoadedObservable.notifyObservers(H),H.onLoadedObservable.clear(),e&&e({isDDS:!0,width:H.width,info:V,data:j,texture:H})}loadData(j,H,s){const i=B.d.GetDDSInfo(j),e=(i.isRGB||i.isLuminance||i.mipmapCount>1)&&H.generateMipMaps&&Math.max(i.width,i.height)>>i.mipmapCount-1===1;s(i.width,i.height,e,i.isFourCC,(()=>{B.d.UploadDDSLevels(H.getEngine(),H,j,i,e,1)}))}}}}]);