"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[2],{2289:(f,z,w)=>{w.r(z),w.d(z,{_DDSTextureLoader:()=>E});var S=w(2292),C=w(2310);class E{constructor(){this.supportCascades=!0}loadCubeData(f,z,w,E){const F=z.getEngine();let J,x=!1,u=1e3;if(Array.isArray(f))for(let S=0;S<f.length;S++){const w=f[S];J=C.e.GetDDSInfo(w),z.width=J.width,z.height=J.height,x=(J.isRGB||J.isLuminance||J.mipmapCount>1)&&z.generateMipMaps,F._unpackFlipY(J.isCompressed),C.e.UploadDDSLevels(F,z,w,J,x,6,-1,S),J.isFourCC||1!==J.mipmapCount?u=J.mipmapCount-1:F.generateMipMapsForCubemap(z)}else{const E=f;J=C.e.GetDDSInfo(E),z.width=J.width,z.height=J.height,w&&(J.sphericalPolynomial=new S.e),x=(J.isRGB||J.isLuminance||J.mipmapCount>1)&&z.generateMipMaps,F._unpackFlipY(J.isCompressed),C.e.UploadDDSLevels(F,z,E,J,x,6),J.isFourCC||1!==J.mipmapCount?u=J.mipmapCount-1:F.generateMipMapsForCubemap(z,!1)}F._setCubeMapTextureParams(z,x,u),z.isReady=!0,z.onLoadedObservable.notifyObservers(z),z.onLoadedObservable.clear(),E&&E({isDDS:!0,width:z.width,info:J,data:f,texture:z})}loadData(f,z,w){const S=C.e.GetDDSInfo(f),E=(S.isRGB||S.isLuminance||S.mipmapCount>1)&&z.generateMipMaps&&Math.max(S.width,S.height)>>S.mipmapCount-1===1;w(S.width,S.height,E,S.isFourCC,(()=>{C.e.UploadDDSLevels(z.getEngine(),z,f,S,E,1)}))}}}}]);