"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[2],{2253:(K,Y,l)=>{l.r(Y),l.d(Y,{_DDSTextureLoader:()=>d});var v=l(2259),U=l(2277);class d{constructor(){this.supportCascades=!0}loadCubeData(K,Y,l,d){const A=Y.getEngine();let c,t=!1,Z=1e3;if(Array.isArray(K))for(let v=0;v<K.length;v++){const l=K[v];c=U.c.GetDDSInfo(l),Y.width=c.width,Y.height=c.height,t=(c.isRGB||c.isLuminance||c.mipmapCount>1)&&Y.generateMipMaps,A._unpackFlipY(c.isCompressed),U.c.UploadDDSLevels(A,Y,l,c,t,6,-1,v),c.isFourCC||1!==c.mipmapCount?Z=c.mipmapCount-1:A.generateMipMapsForCubemap(Y)}else{const d=K;c=U.c.GetDDSInfo(d),Y.width=c.width,Y.height=c.height,l&&(c.sphericalPolynomial=new v.f),t=(c.isRGB||c.isLuminance||c.mipmapCount>1)&&Y.generateMipMaps,A._unpackFlipY(c.isCompressed),U.c.UploadDDSLevels(A,Y,d,c,t,6),c.isFourCC||1!==c.mipmapCount?Z=c.mipmapCount-1:A.generateMipMapsForCubemap(Y,!1)}A._setCubeMapTextureParams(Y,t,Z),Y.isReady=!0,Y.onLoadedObservable.notifyObservers(Y),Y.onLoadedObservable.clear(),d&&d({isDDS:!0,width:Y.width,info:c,data:K,texture:Y})}loadData(K,Y,l){const v=U.c.GetDDSInfo(K),d=(v.isRGB||v.isLuminance||v.mipmapCount>1)&&Y.generateMipMaps&&Math.max(v.width,v.height)>>v.mipmapCount-1===1;l(v.width,v.height,d,v.isFourCC,(()=>{U.c.UploadDDSLevels(Y.getEngine(),Y,K,v,d,1)}))}}}}]);