"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[2],{2262:(R,x,H)=>{H.r(x),H.d(x,{_IESTextureLoader:()=>D});var k=H(681);function c(R){return R.split(" ").filter((R=>""!==R)).map((R=>parseFloat(R)))}function t(R,x,H){for(;H.length!==x;){const x=c(R.lines[R.index++]);H.push(...x)}}function A(R,x,H){let c=0,t=0,A=0,D=0,U=0,J=0;for(let k=0;k<R.numberOfHorizontalAngles-1;k++)if(H<R.horizontalAngles[k+1]||k===R.numberOfHorizontalAngles-2){t=k,A=R.horizontalAngles[k],D=R.horizontalAngles[k+1];break}for(let k=0;k<R.numberOfVerticalAngles-1;k++)if(x<R.verticalAngles[k+1]||k===R.numberOfVerticalAngles-2){c=k,U=R.verticalAngles[k],J=R.verticalAngles[k+1];break}const V=D-A,n=J-U;if(0===n)return 0;const g=0===V?0:(H-A)/V,I=(x-U)/n,i=0===V?t:t+1,q=(0,k.Lerp)(R.candelaValues[t][c],R.candelaValues[i][c],g),S=(0,k.Lerp)(R.candelaValues[t][c+1],R.candelaValues[i][c+1],g);return(0,k.Lerp)(q,S,I)}class D{constructor(){this.supportCascades=!1}loadCubeData(){throw".ies not supported in Cube."}loadData(R,x,H){const k=function(R){const x={lines:new TextDecoder("utf-8").decode(R).split("\n"),index:0},H={version:x.lines[0],candelaValues:[],horizontalAngles:[],verticalAngles:[],numberOfHorizontalAngles:0,numberOfVerticalAngles:0};for(x.index=1;x.lines.length>0&&!x.lines[x.index].includes("TILT=");)x.index++;x.lines[x.index].includes("INCLUDE"),x.index++;const k=c(x.lines[x.index++]);H.numberOfLights=k[0],H.lumensPerLamp=k[1],H.candelaMultiplier=k[2],H.numberOfVerticalAngles=k[3],H.numberOfHorizontalAngles=k[4],H.photometricType=k[5],H.unitsType=k[6],H.width=k[7],H.length=k[8],H.height=k[9];const D=c(x.lines[x.index++]);H.ballastFactor=D[0],H.fileGenerationType=D[1],H.inputWatts=D[2];for(let c=0;c<H.numberOfHorizontalAngles;c++)H.candelaValues[c]=[];t(x,H.numberOfVerticalAngles,H.verticalAngles),t(x,H.numberOfHorizontalAngles,H.horizontalAngles);for(let c=0;c<H.numberOfHorizontalAngles;c++)t(x,H.numberOfVerticalAngles,H.candelaValues[c]);let U=-1;for(let c=0;c<H.numberOfHorizontalAngles;c++)for(let R=0;R<H.numberOfVerticalAngles;R++)H.candelaValues[c][R]*=H.candelaValues[c][R]*H.candelaMultiplier*H.ballastFactor*H.fileGenerationType,U=Math.max(U,H.candelaValues[c][R]);if(U>0)for(let c=0;c<H.numberOfHorizontalAngles;c++)for(let R=0;R<H.numberOfVerticalAngles;R++)H.candelaValues[c][R]/=U;const J=180,V=360,n=new Float32Array(64800),g=H.horizontalAngles[0],I=H.horizontalAngles[H.numberOfHorizontalAngles-1];for(let c=0;c<64800;c++){let R=c%V;const x=Math.floor(c/V);I-g!==0&&(R<g||R>=I)&&(R%=2*I,R>I&&(R=2*I-R)),n[x+R*J]=A(H,x,R)}return{width:180,height:1,data:n}}(new Uint8Array(R.buffer,R.byteOffset,R.byteLength));H(k.width,k.height,!1,!1,(()=>{const R=x.getEngine();x.type=1,x.format=6,x._gammaSpace=!1,R._uploadDataToTextureDirectly(x,k.data)}))}}}}]);