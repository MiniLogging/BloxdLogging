"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[2],{2035:(Y,d,t)=>{t.r(d),t.d(d,{_DDSTextureLoader:()=>U});var x=t(2043),C=t(2057);class U{constructor(){this.supportCascades=!0}loadCubeData(Y,d,t,U){const y=d.getEngine();let B,W=!1,o=1e3;if(Array.isArray(Y))for(let x=0;x<Y.length;x++){const t=Y[x];B=C.d.GetDDSInfo(t),d.width=B.width,d.height=B.height,W=(B.isRGB||B.isLuminance||B.mipmapCount>1)&&d.generateMipMaps,y._unpackFlipY(B.isCompressed),C.d.UploadDDSLevels(y,d,t,B,W,6,-1,x),B.isFourCC||1!==B.mipmapCount?o=B.mipmapCount-1:y.generateMipMapsForCubemap(d)}else{const U=Y;B=C.d.GetDDSInfo(U),d.width=B.width,d.height=B.height,t&&(B.sphericalPolynomial=new x.i),W=(B.isRGB||B.isLuminance||B.mipmapCount>1)&&d.generateMipMaps,y._unpackFlipY(B.isCompressed),C.d.UploadDDSLevels(y,d,U,B,W,6),B.isFourCC||1!==B.mipmapCount?o=B.mipmapCount-1:y.generateMipMapsForCubemap(d,!1)}y._setCubeMapTextureParams(d,W,o),d.isReady=!0,d.onLoadedObservable.notifyObservers(d),d.onLoadedObservable.clear(),U&&U({isDDS:!0,width:d.width,info:B,data:Y,texture:d})}loadData(Y,d,t){const x=C.d.GetDDSInfo(Y),U=(x.isRGB||x.isLuminance||x.mipmapCount>1)&&d.generateMipMaps&&Math.max(x.width,x.height)>>x.mipmapCount-1===1;t(x.width,x.height,U,x.isFourCC,(()=>{C.d.UploadDDSLevels(d.getEngine(),d,Y,x,U,1)}))}}}}]);