"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[87],{14091:(z,u,Y)=>{Y.r(u),Y.d(u,{FlowGraphWaitAllBlock:()=>T});var H=Y(12580),E=Y(10918),J=Y(12531),l=Y(12523);class T extends H.e{constructor(z){super(z),this.config=z,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",J.g,new l.b(this.config.inputSignalCount||0));for(let u=0;u<this.config.inputSignalCount;u++)this.inFlows.push(this._registerSignalInput(`in_${u}`));this._unregisterSignalInput("in")}_getCurrentActivationState(z){const u=this._cachedActivationState;if(u.length=0,z._hasExecutionVariable(this,"activationState")){const Y=z._getExecutionVariable(this,"activationState",[]);for(let z=0;z<Y.length;z++)u.push(Y[z])}else for(let Y=0;Y<this.config.inputSignalCount;Y++)u.push(!1);return u}_execute(z,u){const Y=this._getCurrentActivationState(z);if(u===this.reset)for(let H=0;H<this.config.inputSignalCount;H++)Y[H]=!1;else{const z=this.inFlows.indexOf(u);z>=0&&(Y[z]=!0)}if(this.remainingInputs.setValue(new l.b(Y.filter((z=>!z)).length),z),z._setExecutionVariable(this,"activationState",Y.slice()),Y.includes(!1))u!==this.reset&&this.out._activateSignal(z);else{this.completed._activateSignal(z);for(let z=0;z<this.config.inputSignalCount;z++)Y[z]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(z){super.serialize(z),z.config.inputFlows=this.config.inputSignalCount}}(0,E.d)("FlowGraphWaitAllBlock",T)}}]);