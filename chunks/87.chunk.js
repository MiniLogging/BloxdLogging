"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[87],{14196:(h,d,m)=>{m.r(d),m.d(d,{FlowGraphWaitAllBlock:()=>a});var j=m(12710),A=m(11080),b=m(12671),w=m(12668);class a extends j.d{constructor(h){super(h),this.config=h,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",b.i,new w.b(this.config.inputSignalCount||0));for(let d=0;d<this.config.inputSignalCount;d++)this.inFlows.push(this._registerSignalInput(`in_${d}`));this._unregisterSignalInput("in")}_getCurrentActivationState(h){const d=this._cachedActivationState;if(d.length=0,h._hasExecutionVariable(this,"activationState")){const m=h._getExecutionVariable(this,"activationState",[]);for(let h=0;h<m.length;h++)d.push(m[h])}else for(let m=0;m<this.config.inputSignalCount;m++)d.push(!1);return d}_execute(h,d){const m=this._getCurrentActivationState(h);if(d===this.reset)for(let j=0;j<this.config.inputSignalCount;j++)m[j]=!1;else{const h=this.inFlows.indexOf(d);h>=0&&(m[h]=!0)}if(this.remainingInputs.setValue(new w.b(m.filter((h=>!h)).length),h),h._setExecutionVariable(this,"activationState",m.slice()),m.includes(!1))d!==this.reset&&this.out._activateSignal(h);else{this.completed._activateSignal(h);for(let h=0;h<this.config.inputSignalCount;h++)m[h]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(h){super.serialize(h),h.config.inputFlows=this.config.inputSignalCount}}(0,A.i)("FlowGraphWaitAllBlock",a)}}]);