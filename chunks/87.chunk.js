"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[87],{14622:(G,V,W)=>{W.r(V),W.d(V,{FlowGraphWaitAllBlock:()=>z});var J=W(13115),R=W(11159),d=W(13071),k=W(13067);class z extends J.e{constructor(G){super(G),this.config=G,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",d.h,new k.e(this.config.inputSignalCount||0));for(let V=0;V<this.config.inputSignalCount;V++)this.inFlows.push(this._registerSignalInput(`in_${V}`));this._unregisterSignalInput("in")}_getCurrentActivationState(G){const V=this._cachedActivationState;if(V.length=0,G._hasExecutionVariable(this,"activationState")){const W=G._getExecutionVariable(this,"activationState",[]);for(let G=0;G<W.length;G++)V.push(W[G])}else for(let W=0;W<this.config.inputSignalCount;W++)V.push(!1);return V}_execute(G,V){const W=this._getCurrentActivationState(G);if(V===this.reset)for(let J=0;J<this.config.inputSignalCount;J++)W[J]=!1;else{const G=this.inFlows.indexOf(V);G>=0&&(W[G]=!0)}if(this.remainingInputs.setValue(new k.e(W.filter((G=>!G)).length),G),G._setExecutionVariable(this,"activationState",W.slice()),W.includes(!1))V!==this.reset&&this.out._activateSignal(G);else{this.completed._activateSignal(G);for(let G=0;G<this.config.inputSignalCount;G++)W[G]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(G){super.serialize(G),G.config.inputFlows=this.config.inputSignalCount}}(0,R.d)("FlowGraphWaitAllBlock",z)}}]);