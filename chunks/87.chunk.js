"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[87],{14182:(q,c,U)=>{U.r(c),U.d(c,{FlowGraphWaitAllBlock:()=>X});var J=U(12699),Q=U(10850),s=U(12648),g=U(12642);class X extends J.e{constructor(q){super(q),this.config=q,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",s.i,new g.b(this.config.inputSignalCount||0));for(let c=0;c<this.config.inputSignalCount;c++)this.inFlows.push(this._registerSignalInput(`in_${c}`));this._unregisterSignalInput("in")}_getCurrentActivationState(q){const c=this._cachedActivationState;if(c.length=0,q._hasExecutionVariable(this,"activationState")){const U=q._getExecutionVariable(this,"activationState",[]);for(let q=0;q<U.length;q++)c.push(U[q])}else for(let U=0;U<this.config.inputSignalCount;U++)c.push(!1);return c}_execute(q,c){const U=this._getCurrentActivationState(q);if(c===this.reset)for(let J=0;J<this.config.inputSignalCount;J++)U[J]=!1;else{const q=this.inFlows.indexOf(c);q>=0&&(U[q]=!0)}if(this.remainingInputs.setValue(new g.b(U.filter((q=>!q)).length),q),q._setExecutionVariable(this,"activationState",U.slice()),U.includes(!1))c!==this.reset&&this.out._activateSignal(q);else{this.completed._activateSignal(q);for(let q=0;q<this.config.inputSignalCount;q++)U[q]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(q){super.serialize(q),q.config.inputFlows=this.config.inputSignalCount}}(0,Q.f)("FlowGraphWaitAllBlock",X)}}]);