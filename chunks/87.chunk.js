"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[87],{14343:(s,Z,o)=>{o.r(Z),o.d(Z,{FlowGraphWaitAllBlock:()=>O});var t=o(12831),j=o(10916),S=o(12775),a=o(12771);class O extends t.b{constructor(s){super(s),this.config=s,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",S.j,new a.b(this.config.inputSignalCount||0));for(let Z=0;Z<this.config.inputSignalCount;Z++)this.inFlows.push(this._registerSignalInput(`in_${Z}`));this._unregisterSignalInput("in")}_getCurrentActivationState(s){const Z=this._cachedActivationState;if(Z.length=0,s._hasExecutionVariable(this,"activationState")){const o=s._getExecutionVariable(this,"activationState",[]);for(let s=0;s<o.length;s++)Z.push(o[s])}else for(let o=0;o<this.config.inputSignalCount;o++)Z.push(!1);return Z}_execute(s,Z){const o=this._getCurrentActivationState(s);if(Z===this.reset)for(let t=0;t<this.config.inputSignalCount;t++)o[t]=!1;else{const s=this.inFlows.indexOf(Z);s>=0&&(o[s]=!0)}if(this.remainingInputs.setValue(new a.b(o.filter((s=>!s)).length),s),s._setExecutionVariable(this,"activationState",o.slice()),o.includes(!1))Z!==this.reset&&this.out._activateSignal(s);else{this.completed._activateSignal(s);for(let s=0;s<this.config.inputSignalCount;s++)o[s]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(s){super.serialize(s),s.config.inputFlows=this.config.inputSignalCount}}(0,j.f)("FlowGraphWaitAllBlock",O)}}]);