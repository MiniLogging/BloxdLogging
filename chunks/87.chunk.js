"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[87],{14455:(Z,c,L)=>{L.r(c),L.d(c,{FlowGraphWaitAllBlock:()=>V});var k=L(12875),N=L(11012),R=L(12825),G=L(12817);class V extends k.e{constructor(Z){super(Z),this.config=Z,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",R.i,new G.b(this.config.inputSignalCount||0));for(let c=0;c<this.config.inputSignalCount;c++)this.inFlows.push(this._registerSignalInput(`in_${c}`));this._unregisterSignalInput("in")}_getCurrentActivationState(Z){const c=this._cachedActivationState;if(c.length=0,Z._hasExecutionVariable(this,"activationState")){const L=Z._getExecutionVariable(this,"activationState",[]);for(let Z=0;Z<L.length;Z++)c.push(L[Z])}else for(let L=0;L<this.config.inputSignalCount;L++)c.push(!1);return c}_execute(Z,c){const L=this._getCurrentActivationState(Z);if(c===this.reset)for(let k=0;k<this.config.inputSignalCount;k++)L[k]=!1;else{const Z=this.inFlows.indexOf(c);Z>=0&&(L[Z]=!0)}if(this.remainingInputs.setValue(new G.b(L.filter((Z=>!Z)).length),Z),Z._setExecutionVariable(this,"activationState",L.slice()),L.includes(!1))c!==this.reset&&this.out._activateSignal(Z);else{this.completed._activateSignal(Z);for(let Z=0;Z<this.config.inputSignalCount;Z++)L[Z]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(Z){super.serialize(Z),Z.config.inputFlows=this.config.inputSignalCount}}(0,N.g)("FlowGraphWaitAllBlock",V)}}]);