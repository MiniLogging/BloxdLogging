"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[87],{14503:(V,I,m)=>{m.r(I),m.d(I,{FlowGraphWaitAllBlock:()=>k});var C=m(12934),l=m(11048),s=m(12899),F=m(12896);class k extends C.d{constructor(V){super(V),this.config=V,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",s.h,new F.b(this.config.inputSignalCount||0));for(let I=0;I<this.config.inputSignalCount;I++)this.inFlows.push(this._registerSignalInput(`in_${I}`));this._unregisterSignalInput("in")}_getCurrentActivationState(V){const I=this._cachedActivationState;if(I.length=0,V._hasExecutionVariable(this,"activationState")){const m=V._getExecutionVariable(this,"activationState",[]);for(let V=0;V<m.length;V++)I.push(m[V])}else for(let m=0;m<this.config.inputSignalCount;m++)I.push(!1);return I}_execute(V,I){const m=this._getCurrentActivationState(V);if(I===this.reset)for(let C=0;C<this.config.inputSignalCount;C++)m[C]=!1;else{const V=this.inFlows.indexOf(I);V>=0&&(m[V]=!0)}if(this.remainingInputs.setValue(new F.b(m.filter((V=>!V)).length),V),V._setExecutionVariable(this,"activationState",m.slice()),m.includes(!1))I!==this.reset&&this.out._activateSignal(V);else{this.completed._activateSignal(V);for(let V=0;V<this.config.inputSignalCount;V++)m[V]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(V){super.serialize(V),V.config.inputFlows=this.config.inputSignalCount}}(0,l.h)("FlowGraphWaitAllBlock",k)}}]);