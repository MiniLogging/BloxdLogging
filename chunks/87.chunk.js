"use strict";(self["6xhfpmwgjr5"]=self["6xhfpmwgjr5"]||[]).push([[87],{16443:(P,a,R)=>{R.r(a),R.d(a,{ReadExrDataAsync:()=>lP,_ExrTextureLoader:()=>hP});var S=R(14057),A=R(14184);const Z=4,p=4,j=1,U=2,Q=8,h=65536,l=h>>3,V=14,f=65537,O=1<<V,q=O-1,y=59,t=63,W=2+t-y;var k,x;!function(P){P[P.NO_COMPRESSION=0]="NO_COMPRESSION",P[P.RLE_COMPRESSION=1]="RLE_COMPRESSION",P[P.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",P[P.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",P[P.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",P[P.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(k||(k={})),function(P){P[P.INCREASING_Y=0]="INCREASING_Y",P[P.DECREASING_Y=1]="DECREASING_Y"}(x||(x={}));const s=function(){const P=new ArrayBuffer(4),a=new Float32Array(P),R=new Uint32Array(P),S=new Uint32Array(512),A=new Uint32Array(512);for(let U=0;U<256;++U){const P=U-127;P<-27?(S[U]=0,S[256|U]=32768,A[U]=24,A[256|U]=24):P<-14?(S[U]=1024>>-P-14,S[256|U]=1024>>-P-14|32768,A[U]=-P-1,A[256|U]=-P-1):P<=15?(S[U]=P+15<<10,S[256|U]=P+15<<10|32768,A[U]=13,A[256|U]=13):P<128?(S[U]=31744,S[256|U]=64512,A[U]=24,A[256|U]=24):(S[U]=31744,S[256|U]=64512,A[U]=13,A[256|U]=13)}const Z=new Uint32Array(2048),p=new Uint32Array(64),j=new Uint32Array(64);for(let U=1;U<1024;++U){let P=U<<13,a=0;for(;0===(8388608&P);)P<<=1,a-=8388608;P&=-8388609,a+=947912704,Z[U]=P|a}for(let U=1024;U<2048;++U)Z[U]=939524096+(U-1024<<13);for(let U=1;U<31;++U)p[U]=U<<23;p[31]=1199570944,p[32]=2147483648;for(let U=33;U<63;++U)p[U]=2147483648+(U-32<<23);p[63]=3347054592;for(let U=1;U<64;++U)32!==U&&(j[U]=1024);return{floatView:a,uint32View:R,baseTable:S,shiftTable:A,mantissaTable:Z,exponentTable:p,offsetTable:j}}();function d(P,a){const R=new Uint8Array(P);let S=0;for(;0!=R[a.value+S];)S+=1;const A=(new TextDecoder).decode(R.slice(a.value,a.value+S));return a.value=a.value+S+1,A}function G(P,a){const R=P.getInt32(a.value,!0);return a.value+=Z,R}function H(P,a){const R=P.getUint32(a.value,!0);return a.value+=Z,R}function mP(P,a){const R=P.getUint8(a.value);return a.value+=j,R}function N(P,a){const R=P.getUint16(a.value,!0);return a.value+=U,R}function D(P,a){const R=P[a.value];return a.value+=j,R}function L(P,a){let R;return R="getBigInt64"in DataView.prototype?Number(P.getBigInt64(a.value,!0)):P.getUint32(a.value+4,!0)+Number(P.getUint32(a.value,!0)<<32),a.value+=Q,R}function c(P,a){const R=P.getFloat32(a.value,!0);return a.value+=p,R}function u(P,a){return function(P){const a=(31744&P)>>10,R=1023&P;return(P>>15?-1:1)*(a?31===a?R?NaN:1/0:Math.pow(2,a-15)*(1+R/1024):R/1024*6103515625e-14)}(N(P,a))}function Y(P,a){return function(P){if(Math.abs(P)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");P=(0,A.e)(P,-65504,65504),s.floatView[0]=P;const a=s.uint32View[0],R=a>>23&511;return s.baseTable[R]+((8388607&a)>>s.shiftTable[R])}(c(P,a))}function J(P,a,R,S){switch(R){case"string":case"stringvector":case"iccProfile":return function(P,a,R){const S=(new TextDecoder).decode(new Uint8Array(P).slice(a.value,a.value+R));return a.value=a.value+R,S}(P.buffer,a,S);case"chlist":return function(P,a,R){const S=a.value,A=[];for(;a.value<S+R-1;){const R=d(P.buffer,a),S=G(P,a),Z=mP(P,a);a.value+=3;const p=G(P,a),j=G(P,a);A.push({name:R,pixelType:S,pLinear:Z,xSampling:p,ySampling:j})}return a.value+=1,A}(P,a,S);case"chromaticities":return function(P,a){return{redX:c(P,a),redY:c(P,a),greenX:c(P,a),greenY:c(P,a),blueX:c(P,a),blueY:c(P,a),whiteX:c(P,a),whiteY:c(P,a)}}(P,a);case"compression":return function(P,a){return mP(P,a)}(P,a);case"box2i":return function(P,a){return{xMin:G(P,a),yMin:G(P,a),xMax:G(P,a),yMax:G(P,a)}}(P,a);case"lineOrder":return function(P,a){const R=mP(P,a);return x[R]}(P,a);case"float":return c(P,a);case"v2f":return function(P,a){return[c(P,a),c(P,a)]}(P,a);case"v3f":return function(P,a){return[c(P,a),c(P,a),c(P,a)]}(P,a);case"int":return G(P,a);case"rational":return function(P,a){return[G(P,a),H(P,a)]}(P,a);case"timecode":return function(P,a){return[H(P,a),H(P,a)]}(P,a);case"preview":return a.value+=S,"skipped";default:return void(a.value+=S)}}function n(P){for(let a=1;a<P.length;a++){const R=P[a-1]+P[a]-128;P[a]=R}}function b(P,a){let R=0,S=Math.floor((P.length+1)/2),A=0;const Z=P.length-1;for(;!(A>Z)&&(a[A++]=P[R++],!(A>Z));)a[A++]=P[S++]}const B=20000630;function o(P,a){if(P.getUint32(0,!0)!=B)throw new Error("Incorrect OpenEXR format");const R=P.getUint8(4),A=P.getUint8(5),Z={singleTile:!!(2&A),longName:!!(4&A),deepFormat:!!(8&A),multiPart:!!(16&A)};a.value=8;const p={};let j=!0;for(;j;){const R=d(P.buffer,a);if(R){const A=d(P.buffer,a),Z=J(P,a,A,H(P,a));void 0===Z?S.d.Warn(`Unknown header attribute type ${A}'.`):p[R]=Z}else j=!1}if(0!=(-5&A))throw new Error("Unsupported file format");return{version:R,spec:Z,...p}}const r=32768,v=65535;function M(P,a,R,S,A){for(;R<P;)a=a<<8|D(S,A),R+=8;return{l:a>>(R-=P)&(1<<P)-1,c:a,lc:R}}function E(P,a,R,S){return{c:P=P<<8|D(R,S),lc:a+=8}}function e(P,a,R,S,A,Z,p,j,U){if(P==a){if(S<8){const P=E(R,S,A,Z);R=P.c,S=P.lc}let P=R>>(S-=8);if(P=new Uint8Array([P])[0],j.value+P>U)return null;const a=p[j.value-1];for(;P-- >0;)p[j.value++]=a}else{if(!(j.value<U))return null;p[j.value++]=P}return{c:R,lc:S}}const w=new Array(59);function T(P,a,R,S,A,Z){const p=a;let j=0,U=0;for(;S<=A;S++){if(p.value-a.value>R)return;let Q=M(6,j,U,P,p);const h=Q.l;if(j=Q.c,U=Q.lc,Z[S]=h,h==t){if(p.value-a.value>R)throw new Error("Error in HufUnpackEncTable");Q=M(8,j,U,P,p);let h=Q.l+W;if(j=Q.c,U=Q.lc,S+h>A+1)throw new Error("Error in HufUnpackEncTable");for(;h--;)Z[S++]=0;S--}else if(h>=y){let P=h-y+2;if(S+P>A+1)throw new Error("Error in HufUnpackEncTable");for(;P--;)Z[S++]=0;S--}}!function(P){for(let R=0;R<=58;++R)w[R]=0;for(let R=0;R<f;++R)w[P[R]]+=1;let a=0;for(let R=58;R>0;--R){const P=a+w[R]>>1;w[R]=a,a=P}for(let R=0;R<f;++R){const a=P[R];a>0&&(P[R]=a|w[a]++<<6)}}(Z)}function I(P){return 63&P}function i(P){return P>>6}function X(P,a,R,S,A,Z){const p=R.value,j=H(a,R),U=H(a,R);R.value+=4;const Q=H(a,R);if(R.value+=4,j<0||j>=f||U<0||U>=f)throw new Error("Wrong HUF_ENCSIZE");const h=new Array(f),l=new Array(O);!function(P){for(let a=0;a<O;a++)P[a]={},P[a].len=0,P[a].lit=0,P[a].p=null}(l);if(T(P,R,S-(R.value-p),j,U,h),Q>8*(S-(R.value-p)))throw new Error("Wrong hufUncompress");!function(P,a,R,S){for(;a<=R;a++){const R=i(P[a]),A=I(P[a]);if(R>>A)throw new Error("Invalid table entry");if(A>V){const P=S[R>>A-V];if(P.len)throw new Error("Invalid table entry");if(P.lit++,P.p){const a=P.p;P.p=new Array(P.lit);for(let R=0;R<P.lit-1;++R)P.p[R]=a[R]}else P.p=new Array(1);P.p[P.lit-1]=a}else if(A){let P=0;for(let Z=1<<V-A;Z>0;Z--){const Z=S[(R<<V-A)+P];if(Z.len||Z.p)throw new Error("Invalid table entry");Z.len=A,Z.lit=a,P++}}}}(h,j,U,l),function(P,a,R,S,A,Z,p,j,U){let Q=0,h=0;const l=p,f=Math.trunc(S.value+(A+7)/8);for(;S.value<f;){let A=E(Q,h,R,S);for(Q=A.c,h=A.lc;h>=V;){const p=a[Q>>h-V&q];if(p.len){h-=p.len;const P=e(p.lit,Z,Q,h,R,S,j,U,l);P&&(Q=P.c,h=P.lc)}else{if(!p.p)throw new Error("hufDecode issues");let a;for(a=0;a<p.lit;a++){const V=I(P[p.p[a]]);for(;h<V&&S.value<f;)A=E(Q,h,R,S),Q=A.c,h=A.lc;if(h>=V&&i(P[p.p[a]])==(Q>>h-V&(1<<V)-1)){h-=V;const P=e(p.p[a],Z,Q,h,R,S,j,U,l);P&&(Q=P.c,h=P.lc);break}}if(a==p.lit)throw new Error("HufDecode issues")}}}const O=8-A&7;for(Q>>=O,h-=O;h>0;){const P=a[Q<<V-h&q];if(!P.len)throw new Error("HufDecode issues");{h-=P.len;const a=e(P.lit,Z,Q,h,R,S,j,U,l);a&&(Q=a.c,h=a.lc)}}}(h,l,P,R,Q,U,Z,A,{value:0})}function C(P){return 65535&P}function z(P){const a=C(P);return a>32767?a-65536:a}function K(P,a){const R=z(P),S=z(a),A=R+(1&S)+(S>>1);return{a:A,b:A-S}}function F(P,a){const R=C(P),S=C(a),A=R-(S>>1)&v;return{a:S+A-r&v,b:A}}function g(P,a,R,S,A,Z,p){const j=p<16384,U=R>A?A:R;let Q,h,l=1;for(;l<=U;)l<<=1;for(l>>=1,Q=l,l>>=1;l>=1;){h=0;const p=h+Z*(A-Q),U=Z*l,V=Z*Q,f=S*l,O=S*Q;let q,y,t,W;for(;h<=p;h+=V){let A=h;const Z=h+S*(R-Q);for(;A<=Z;A+=O){const R=A+f,S=A+U,Z=S+f;if(j){let p=K(P[A+a],P[S+a]);q=p.a,t=p.b,p=K(P[R+a],P[Z+a]),y=p.a,W=p.b,p=K(q,y),P[A+a]=p.a,P[R+a]=p.b,p=K(t,W),P[S+a]=p.a,P[Z+a]=p.b}else{let p=F(P[A+a],P[S+a]);q=p.a,t=p.b,p=F(P[R+a],P[Z+a]),y=p.a,W=p.b,p=F(q,y),P[A+a]=p.a,P[R+a]=p.b,p=F(t,W),P[S+a]=p.a,P[Z+a]=p.b}}if(R&l){const R=A+U;let S;S=j?K(P[A+a],P[R+a]):F(P[A+a],P[R+a]),q=S.a,P[R+a]=S.b,P[A+a]=q}}if(A&l){let A=h;const Z=h+S*(R-Q);for(;A<=Z;A+=O){const R=A+f;let S;S=j?K(P[A+a],P[R+a]):F(P[A+a],P[R+a]),q=S.a,P[R+a]=S.b,P[A+a]=q}}Q=l,l>>=1}return h}function PP(P){return new DataView(P.array.buffer,P.offset.value,P.size)}function aP(P){const a=P.viewer.buffer.slice(P.offset.value,P.offset.value+P.size),R=new Uint8Array(function(P){let a=P.byteLength;const R=[];let S=0;const A=new DataView(P);for(;a>0;){const P=A.getInt8(S++);if(P<0){const Z=-P;a-=Z+1;for(let P=0;P<Z;P++)R.push(A.getUint8(S++))}else{const Z=P;a-=2;const p=A.getUint8(S++);for(let P=0;P<Z+1;P++)R.push(p)}}return R}(a)),S=new Uint8Array(R.length);return n(R),b(R,S),new DataView(S.buffer)}function RP(P){const a=P.array.slice(P.offset.value,P.offset.value+P.size),R=fflate.unzlibSync(a),S=new Uint8Array(R.length);return n(R),b(R,S),new DataView(S.buffer)}function SP(P){const a=P.array.slice(P.offset.value,P.offset.value+P.size),R=fflate.unzlibSync(a),S=P.lines*P.channels*P.width,A=1==P.type?new Uint16Array(S):new Uint32Array(S);let Z=0,p=0;const j=new Array(4);for(let U=0;U<P.lines;U++)for(let a=0;a<P.channels;a++){let a=0;switch(P.type){case 1:j[0]=Z,j[1]=j[0]+P.width,Z=j[1]+P.width;for(let S=0;S<P.width;++S){a+=R[j[0]++]<<8|R[j[1]++],A[p]=a,p++}break;case 2:j[0]=Z,j[1]=j[0]+P.width,j[2]=j[1]+P.width,Z=j[2]+P.width;for(let S=0;S<P.width;++S){a+=R[j[0]++]<<24|R[j[1]++]<<16|R[j[2]++]<<8,A[p]=a,p++}}}return new DataView(A.buffer)}function AP(P){const a=P.viewer,R={value:P.offset.value},S=new Uint16Array(P.width*P.scanlineBlockSize*(P.channels*P.type)),A=new Uint8Array(l);let Z=0;const p=new Array(P.channels);for(let U=0;U<P.channels;U++)p[U]={},p[U].start=Z,p[U].end=p[U].start,p[U].nx=P.width,p[U].ny=P.lines,p[U].size=P.type,Z+=p[U].nx*p[U].ny*p[U].size;const j=N(a,R),Q=N(a,R);if(Q>=l)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(j<=Q)for(let U=0;U<Q-j+1;U++)A[U+j]=mP(a,R);const V=new Uint16Array(h),f=function(P,a){let R=0;for(let A=0;A<h;++A)(0==A||P[A>>3]&1<<(7&A))&&(a[R++]=A);const S=R-1;for(;R<h;)a[R++]=0;return S}(A,V),O=H(a,R);X(P.array,a,R,O,S,Z);for(let U=0;U<P.channels;++U){const P=p[U];for(let a=0;a<p[U].size;++a)g(S,P.start+a,P.nx,P.size,P.ny,P.nx*P.size,f)}!function(P,a,R){for(let S=0;S<R;++S)a[S]=P[a[S]]}(V,S,Z);let q=0;const y=new Uint8Array(S.buffer.byteLength);for(let h=0;h<P.lines;h++)for(let a=0;a<P.channels;a++){const P=p[a],R=P.nx*P.size,A=new Uint8Array(S.buffer,P.end*U,R*U);y.set(A,q),q+=R*U,P.end+=R}return new DataView(y.buffer)}var ZP,pP=R(14310);!function(P){P[P.Float=0]="Float",P[P.HalfFloat=1]="HalfFloat"}(ZP||(ZP={}));class jP{}async function UP(P,a,R,S){const A={size:0,viewer:a,array:new Uint8Array(a.buffer),offset:R,width:P.dataWindow.xMax-P.dataWindow.xMin+1,height:P.dataWindow.yMax-P.dataWindow.yMin+1,channels:P.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(P.compression){case k.NO_COMPRESSION:A.lines=1,A.uncompress=PP;break;case k.RLE_COMPRESSION:A.lines=1,A.uncompress=aP;break;case k.ZIPS_COMPRESSION:A.lines=1,A.uncompress=RP,await pP.h.LoadScriptAsync(jP.FFLATEUrl);break;case k.ZIP_COMPRESSION:A.lines=16,A.uncompress=RP,await pP.h.LoadScriptAsync(jP.FFLATEUrl);break;case k.PIZ_COMPRESSION:A.lines=32,A.uncompress=AP;break;case k.PXR24_COMPRESSION:A.lines=16,A.uncompress=SP,await pP.h.LoadScriptAsync(jP.FFLATEUrl);break;default:throw new Error(k[P.compression]+" is unsupported")}A.scanlineBlockSize=A.lines;const Z={};for(const p of P.channels)switch(p.name){case"R":case"G":case"B":case"A":case"Y":Z[p.name]=!0,A.type=p.pixelType}let j=!1;if(Z.R&&Z.G&&Z.B&&Z.A)A.outputChannels=4,A.decodeChannels={R:0,G:1,B:2,A:3};else if(Z.R&&Z.G&&Z.B)j=!0,A.outputChannels=4,A.decodeChannels={R:0,G:1,B:2,A:3};else if(Z.R&&Z.G)A.outputChannels=2,A.decodeChannels={R:0,G:1};else if(Z.R)A.outputChannels=1,A.decodeChannels={R:0};else{if(!Z.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");A.outputChannels=1,A.decodeChannels={Y:0}}if(1===A.type)switch(S){case ZP.Float:A.getter=u,A.inputSize=U;break;case ZP.HalfFloat:A.getter=N,A.inputSize=U}else{if(2!==A.type)throw new Error("Unsupported pixelType "+A.type+" for "+P.compression);switch(S){case ZP.Float:A.getter=c,A.inputSize=p;break;case ZP.HalfFloat:A.getter=Y,A.inputSize=p}}A.blockCount=A.height/A.scanlineBlockSize;for(let p=0;p<A.blockCount;p++)L(a,R);const Q=A.width*A.height*A.outputChannels;switch(S){case ZP.Float:A.byteArray=new Float32Array(Q),A.textureType=1,j&&A.byteArray.fill(1,0,Q);break;case ZP.HalfFloat:A.byteArray=new Uint16Array(Q),A.textureType=2,j&&A.byteArray.fill(15360,0,Q);break;default:throw new Error("Unsupported type: "+S)}let h=0;for(const p of P.channels)void 0!==A.decodeChannels[p.name]&&(A.channelLineOffsets[p.name]=h*A.width),h+=2*p.pixelType;return A.bytesPerLine=A.width*h,A.outLineWidth=A.width*A.outputChannels,"INCREASING_Y"===P.lineOrder?A.scanOrder=P=>P:A.scanOrder=P=>A.height-1-P,4==A.outputChannels?(A.format=5,A.linearSpace=!0):(A.format=6,A.linearSpace=!1),A}function QP(P,a,R,S){const A={value:0};for(let Z=0;Z<P.height/P.scanlineBlockSize;Z++){const p=G(R,S)-a.dataWindow.yMin;P.size=H(R,S),P.lines=p+P.scanlineBlockSize>P.height?P.height-p:P.scanlineBlockSize;const j=P.size<P.lines*P.bytesPerLine&&P.uncompress?P.uncompress(P):PP(P);S.value+=P.size;for(let R=0;R<P.scanlineBlockSize;R++){const S=Z*P.scanlineBlockSize,p=R+P.scanOrder(S);if(p>=P.height)continue;const U=R*P.bytesPerLine,Q=(P.height-1-p)*P.outLineWidth;for(let R=0;R<P.channels;R++){const S=a.channels[R].name,Z=P.channelLineOffsets[S],p=P.decodeChannels[S];if(void 0!==p){A.value=U+Z;for(let a=0;a<P.width;a++){const R=Q+a*P.outputChannels+p;P.byteArray&&(P.byteArray[R]=P.getter(j,A))}}}}}}jP.DefaultOutputType=ZP.HalfFloat,jP.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class hP{constructor(){this.supportCascades=!1}loadCubeData(P,a,R,S,A){throw".exr not supported in Cube."}loadData(P,a,R){const A=new DataView(P.buffer),Z={value:0},p=o(A,Z);UP(p,A,Z,jP.DefaultOutputType).then((P=>{QP(P,p,A,Z);const S=p.dataWindow.xMax-p.dataWindow.xMin+1,j=p.dataWindow.yMax-p.dataWindow.yMin+1;R(S,j,a.generateMipMaps,!1,(()=>{const R=a.getEngine();a.format=p.format,a.type=P.textureType,a.invertY=!1,a._gammaSpace=!p.linearSpace,P.byteArray&&R._uploadDataToTextureDirectly(a,P.byteArray,0,0,void 0,!0)}))})).catch((P=>{S.d.Error("Failed to load EXR texture: ",P)}))}}async function lP(P){const a=new DataView(P),R={value:0},A=o(a,R);try{const P=await UP(A,a,R,ZP.Float);return QP(P,A,a,R),P.byteArray?{width:A.dataWindow.xMax-A.dataWindow.xMin+1,height:A.dataWindow.yMax-A.dataWindow.yMin+1,data:new Float32Array(P.byteArray)}:(S.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(Z){S.d.Error("Failed to load EXR data: ",Z)}return{width:0,height:0,data:null}}}}]);