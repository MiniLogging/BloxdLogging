"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[87],{14260:(q,f,j)=>{j.r(f),j.d(f,{FlowGraphWaitAllBlock:()=>Q});var d=j(12752),g=j(10965),h=j(12709),L=j(12704);class Q extends d.c{constructor(q){super(q),this.config=q,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",h.e,new L.c(this.config.inputSignalCount||0));for(let f=0;f<this.config.inputSignalCount;f++)this.inFlows.push(this._registerSignalInput(`in_${f}`));this._unregisterSignalInput("in")}_getCurrentActivationState(q){const f=this._cachedActivationState;if(f.length=0,q._hasExecutionVariable(this,"activationState")){const j=q._getExecutionVariable(this,"activationState",[]);for(let q=0;q<j.length;q++)f.push(j[q])}else for(let j=0;j<this.config.inputSignalCount;j++)f.push(!1);return f}_execute(q,f){const j=this._getCurrentActivationState(q);if(f===this.reset)for(let d=0;d<this.config.inputSignalCount;d++)j[d]=!1;else{const q=this.inFlows.indexOf(f);q>=0&&(j[q]=!0)}if(this.remainingInputs.setValue(new L.c(j.filter((q=>!q)).length),q),q._setExecutionVariable(this,"activationState",j.slice()),j.includes(!1))f!==this.reset&&this.out._activateSignal(q);else{this.completed._activateSignal(q);for(let q=0;q<this.config.inputSignalCount;q++)j[q]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(q){super.serialize(q),q.config.inputFlows=this.config.inputSignalCount}}(0,g.f)("FlowGraphWaitAllBlock",Q)}}]);