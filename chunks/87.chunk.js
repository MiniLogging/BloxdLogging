"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[87],{14303:(x,O,Q)=>{Q.r(O),Q.d(O,{FlowGraphWaitAllBlock:()=>o});var X=Q(12744),Z=Q(10866),n=Q(12707),V=Q(12703);class o extends X.d{constructor(x){super(x),this.config=x,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",n.i,new V.b(this.config.inputSignalCount||0));for(let O=0;O<this.config.inputSignalCount;O++)this.inFlows.push(this._registerSignalInput(`in_${O}`));this._unregisterSignalInput("in")}_getCurrentActivationState(x){const O=this._cachedActivationState;if(O.length=0,x._hasExecutionVariable(this,"activationState")){const Q=x._getExecutionVariable(this,"activationState",[]);for(let x=0;x<Q.length;x++)O.push(Q[x])}else for(let Q=0;Q<this.config.inputSignalCount;Q++)O.push(!1);return O}_execute(x,O){const Q=this._getCurrentActivationState(x);if(O===this.reset)for(let X=0;X<this.config.inputSignalCount;X++)Q[X]=!1;else{const x=this.inFlows.indexOf(O);x>=0&&(Q[x]=!0)}if(this.remainingInputs.setValue(new V.b(Q.filter((x=>!x)).length),x),x._setExecutionVariable(this,"activationState",Q.slice()),Q.includes(!1))O!==this.reset&&this.out._activateSignal(x);else{this.completed._activateSignal(x);for(let x=0;x<this.config.inputSignalCount;x++)Q[x]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(x){super.serialize(x),x.config.inputFlows=this.config.inputSignalCount}}(0,Z.d)("FlowGraphWaitAllBlock",o)}}]);