"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[48],{13072:(j,H,s)=>{s.r(H),s.d(H,{AnimationGroup:()=>h,TargetedAnimation:()=>J});var i=s(12003),B=s(502),e=s(545),k=s(656),V=s(11997),C=s(693);class L{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(j,H,s,B){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=H,this._target=j,this._scene=s,this._host=B,this._activeTargets=[],H._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===i.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=C.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const j={frame:0,value:this._minValue};this._keys.splice(0,0,j)}if(this._target instanceof Array){let j=0;for(const H of this._target)this._preparePath(H,j),this._getOriginalValues(j),j++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const e=H.getEvents();e&&e.length>0&&e.forEach((j=>{this._events.push(j._clone())})),this._enableBlending=j&&j.animationPropertiesOverride?j.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(j){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const s=this._animation.targetPropertyPath;if(s.length>1){let i=j;for(let j=0;j<s.length-1;j++){const H=s[j];if(i=i[H],void 0===i)throw new Error(`Invalid property (${H}) in property path (${s.join(".")})`)}this._targetPath=s[s.length-1],this._activeTargets[H]=i}else this._targetPath=s[0],this._activeTargets[H]=j;if(void 0===this._activeTargets[H][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${s.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let j=0;for(const H of this._target)void 0!==this._originalValue[j]&&this._setValue(H,this._activeTargets[j],this._originalValue[j],-1,j),j++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let j=0;j<this._events.length;j++)this._events[j].isDone=!1}isStopped(){return this._stopped}dispose(){const j=this._animation.runtimeAnimations.indexOf(this);j>-1&&this._animation.runtimeAnimations.splice(j,1)}setValue(j,H){if(this._targetIsArray)for(let s=0;s<this._target.length;s++){const i=this._target[s];this._setValue(i,this._activeTargets[s],j,H,s)}else this._setValue(this._target,this._directTarget,j,H,0)}_getOriginalValues(){let j,H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const s=this._activeTargets[H];j=s.getLocalMatrix&&"_matrix"===this._targetPath?s.getLocalMatrix():s[this._targetPath],j&&j.clone?this._originalValue[H]=j.clone():this._originalValue[H]=j}_registerTargetForLateAnimationBinding(j,H){const s=j.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(s),s._lateAnimationHolders||(s._lateAnimationHolders={}),s._lateAnimationHolders[j.targetPath]||(s._lateAnimationHolders[j.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:H}),j.isAdditive?(s._lateAnimationHolders[j.targetPath].additiveAnimations.push(j),s._lateAnimationHolders[j.targetPath].totalAdditiveWeight+=j.weight):(s._lateAnimationHolders[j.targetPath].animations.push(j),s._lateAnimationHolders[j.targetPath].totalWeight+=j.weight)}_setValue(j,H,s,B,e){if(this._currentActiveTarget=H,this._weight=B,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const j=H[this._targetPath];j.clone?this._originalBlendValue=j.clone():this._originalBlendValue=j}this._originalBlendValue.m?i.c.AllowMatrixDecomposeForInterpolation?this._currentValue?C.d.DecomposeLerpToRef(this._originalBlendValue,s,this._blendingFactor,this._currentValue):this._currentValue=C.d.DecomposeLerp(this._originalBlendValue,s,this._blendingFactor):this._currentValue?C.d.LerpToRef(this._originalBlendValue,s,this._blendingFactor,this._currentValue):this._currentValue=C.d.Lerp(this._originalBlendValue,s,this._blendingFactor):this._currentValue=i.c._UniversalLerp(this._originalBlendValue,s,this._blendingFactor);const B=j&&j.animationPropertiesOverride?j.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=B}else this._currentValue?this._currentValue.p?this._currentValue.p(s):this._currentValue=s:null!==s&&void 0!==s&&s.clone?this._currentValue=s.clone():this._currentValue=s;-1!==B?this._registerTargetForLateAnimationBinding(this,this._originalValue[e]):this._animationState.loopMode===i.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[e],H[this._targetPath]):H[this._targetPath]=this._originalValue[e]+this._currentValue:H[this._targetPath]=this._currentValue,j.Zj&&j.Zj(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(j){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const s=this._animation.getKeys();j<s[0].frame?j=s[0].frame:j>s[s.length-1].frame&&(j=s[s.length-1].frame);const i=this._events;if(i.length)for(let e=0;e<i.length;e++)i[e].onlyOnce||(i[e].isDone=i[e].frame<j);this._currentFrame=j;const B=this._animation._interpolate(j,this._animationState);this.setValue(B,H)}_prepareForSpeedRatioChange(j){const H=this._previousElapsedTime*(this._animation.framePerSecond*j)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-H}animate(j,H,s,B,e){let k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const V=this._animation,C=V.targetPropertyPath;if(!C||C.length<1)return this._stopped=!0,!1;let L=!0;(H<this._minFrame||H>this._maxFrame)&&(H=this._minFrame),(s<this._minFrame||s>this._maxFrame)&&(s=this._maxFrame);const U=s-H;let x,p=j*(V.framePerSecond*e)/1e3+this._absoluteFrameOffset,a=0,E=!1;const r=B&&this._animationState.loopMode===i.c.ANIMATIONLOOPMODE_YOYO;if(r){const j=(p-H)/U,s=Math.sin(j*Math.PI);p=Math.abs(s)*U+H;const i=s>=0?1:-1;this._yoyoDirection!==i&&(E=!0),this._yoyoDirection=i}if(this._previousElapsedTime=j,this._previousAbsoluteFrame=p,!B&&s>=H&&(p>=U&&e>0||p<=0&&e<0))L=!1,a=V._getKeyValue(this._maxValue);else if(!B&&H>=s&&(p<=U&&e<0||p>=0&&e>0))L=!1,a=V._getKeyValue(this._minValue);else if(this._animationState.loopMode!==i.c.ANIMATIONLOOPMODE_CYCLE){const j=s.toString()+H.toString();if(!this._offsetsCache[j]){this._animationState.repeatCount=0,this._animationState.loopMode=i.c.ANIMATIONLOOPMODE_CYCLE;const B=V._interpolate(H,this._animationState),e=V._interpolate(s,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),V.dataType){case i.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[j]=e-B;break;case i.c.ANIMATIONTYPE_QUATERNION:case i.c.ANIMATIONTYPE_VECTOR3:case i.c.ANIMATIONTYPE_VECTOR2:case i.c.ANIMATIONTYPE_SIZE:case i.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[j]=e.de(B)}this._highLimitsCache[j]=e}a=this._highLimitsCache[j],x=this._offsetsCache[j]}if(void 0===x)switch(V.dataType){case i.c.ANIMATIONTYPE_FLOAT:x=0;break;case i.c.ANIMATIONTYPE_QUATERNION:x=i.j;break;case i.c.ANIMATIONTYPE_VECTOR3:x=i.q;break;case i.c.ANIMATIONTYPE_VECTOR2:x=i.o;break;case i.c.ANIMATIONTYPE_SIZE:x=i.m;break;case i.c.ANIMATIONTYPE_COLOR3:x=i.d;break;case i.c.ANIMATIONTYPE_COLOR4:x=i.g}let q;if(this._host&&this._host.syncRoot){const j=this._host.syncRoot;q=H+U*((j.masterFrame-j.fromFrame)/(j.toFrame-j.fromFrame))}else q=p>0&&H>s||p<0&&H<s?L&&0!==U?s+p%U:H:L&&0!==U?H+p%U:s;const J=this._events;if(!r&&(e>0&&this.currentFrame>q||e<0&&this.currentFrame<q)||r&&E){this._onLoop();for(let j=0;j<J.length;j++)J[j].onlyOnce||(J[j].isDone=!1);this._animationState.key=e>0?0:V.getKeys().length-1}this._currentFrame=q,this._animationState.repeatCount=0===U?0:p/U|0,this._animationState.highLimitValue=a,this._animationState.offsetValue=x;const h=V._interpolate(q,this._animationState);if(this.setValue(h,k),J.length)for(let i=0;i<J.length;i++)if(U>=0&&q>=J[i].frame&&J[i].frame>=H||U<0&&q<=J[i].frame&&J[i].frame<=H){const j=J[i];j.isDone||(j.onlyOnce&&(J.splice(i,1),i--),j.isDone=!0,j.action(q))}return L||(this._stopped=!0),L}}var U=s(526);class x{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(j){this._weight=-1!==j?Math.min(Math.max(j,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(j){for(let H=0;H<this._runtimeAnimations.length;H++){this._runtimeAnimations[H]._prepareForSpeedRatioChange(j)}this._speedRatio=j,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(j,H){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,e=arguments.length>4&&void 0!==arguments[4]&&arguments[4],k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,V=arguments.length>6?arguments[6]:void 0,C=arguments.length>7?arguments[7]:void 0,L=arguments.length>8?arguments[8]:void 0,U=arguments.length>9&&void 0!==arguments[9]&&arguments[9],x=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=H,this.fromFrame=s,this.toFrame=i,this.loopAnimation=e,this.onAnimationEnd=V,this.onAnimationLoop=L,this.isAdditive=U,this.playOrder=x,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Uj=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new B.d,this.onAnimationLoopObservable=new B.d,this._scene=j,C&&this.appendAnimations(H,C),this._speedRatio=k,j._activeAnimatables.push(this)}syncWith(j){if(this._syncRoot=j,j){const j=this._scene._activeAnimatables.indexOf(this);j>-1&&(this._scene._activeAnimatables.splice(j,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(j,H){for(let s=0;s<H.length;s++){const i=H[s],B=new L(j,i,this._scene,this);B._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(B)}}getAnimationByTargetProperty(j){const H=this._runtimeAnimations;for(let s=0;s<H.length;s++)if(H[s].animation.targetProperty===j)return H[s].animation;return null}getRuntimeAnimationByTargetProperty(j){const H=this._runtimeAnimations;for(let s=0;s<H.length;s++)if(H[s].animation.targetProperty===j)return H[s];return null}reset(){const j=this._runtimeAnimations;for(let H=0;H<j.length;H++)j[H].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(j){const H=this._runtimeAnimations;for(let s=0;s<H.length;s++)H[s].animation.enableBlending=!0,H[s].animation.blendingSpeed=j}disableBlending(){const j=this._runtimeAnimations;for(let H=0;H<j.length;H++)j[H].animation.enableBlending=!1}goToFrame(j){const H=this._runtimeAnimations;if(H[0]){const s=H[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??H[0].currentFrame;const i=0===this.speedRatio?0:(j-this._frameToSyncFromJump)/s*1e3/this.speedRatio;this._manualJumpDelay=-i}for(let s=0;s<H.length;s++)H[s].goToFrame(j,this._weight);this._goToFrame=j}get paused(){return this.Uj}pause(){this.Uj||(this.Uj=!0)}restart(){this.Uj=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(j,H){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(j||H){const B=this._scene._activeAnimatables.indexOf(this);if(B>-1){const e=this._runtimeAnimations;for(let s=e.length-1;s>=0;s--){const i=e[s];j&&i.animation.name!=j||(H&&!H(i.target)||(i.dispose(),e.splice(s,1)))}0==e.length&&(s||this._scene._activeAnimatables.splice(B,1),i||this._raiseOnAnimationEnd())}}else{const j=this._scene._activeAnimatables.indexOf(this);if(j>-1){s||this._scene._activeAnimatables.splice(j,1);const H=this._runtimeAnimations;for(let j=0;j<H.length;j++)H[j].dispose();this._runtimeAnimations.length=0,i||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((j=>{this.onAnimationEndObservable.add((()=>{j(this)}),void 0,void 0,this,!0)}))}_animate(j){if(this.Uj)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=j),!0;if(null===this._localDelayOffset?(this._localDelayOffset=j,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=j-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let H=!1;const s=this._runtimeAnimations;let i;for(i=0;i<s.length;i++){const B=s[i].animate(j-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);H=H||B}if(this.animationStarted=H,!H){if(this.disposeOnEnd)for(i=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(i,1),i=0;i<s.length;i++)s[i].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return H}}function p(j){if(0===j.totalWeight&&0===j.totalAdditiveWeight)return j.originalValue;let H=1;const s=C.i.bk[0],i=C.i.bk[1],B=C.i.Quaternion[0];let e=0;const k=j.animations[0],V=j.originalValue;let L=1,U=!1;if(j.totalWeight<1)L=1-j.totalWeight,V.decompose(i,B,s);else{if(e=1,H=j.totalWeight,L=k.weight/H,1==L){if(!j.totalAdditiveWeight)return k.currentValue;U=!0}k.currentValue.decompose(i,B,s)}if(!U){i.scaleInPlace(L),s.scaleInPlace(L),B.scaleInPlace(L);for(let k=e;k<j.animations.length;k++){const e=j.animations[k];if(0===e.weight)continue;L=e.weight/H;const V=C.i.bk[2],U=C.i.bk[3],x=C.i.Quaternion[1];e.currentValue.decompose(U,x,V),U.scaleAndAddToRef(L,i),x.scaleAndAddToRef(C.h.Dot(B,x)>0?L:-L,B),V.scaleAndAddToRef(L,s)}B.normalize()}for(let p=0;p<j.additiveAnimations.length;p++){const H=j.additiveAnimations[p];if(0===H.weight)continue;const e=C.i.bk[2],k=C.i.bk[3],V=C.i.Quaternion[1];H.currentValue.decompose(k,V,e),k.multiplyToRef(i,k),C.p.LerpToRef(i,k,H.weight,i),B.multiplyToRef(V,V),C.h.SlerpToRef(B,V,H.weight,B),e.scaleAndAddToRef(H.weight,s)}const x=k?k._animationState.workValue:C.i.Matrix[0].clone();return C.d.ComposeToRef(i,B,s,x),x}function a(j,H){if(0===j.totalWeight&&0===j.totalAdditiveWeight)return H;const s=j.animations[0],i=j.originalValue;let B=H;if(0===j.totalWeight&&j.totalAdditiveWeight>0)B.p(i);else if(1===j.animations.length){if(C.h.SlerpToRef(i,s.currentValue,Math.min(1,j.totalWeight),B),0===j.totalAdditiveWeight)return B}else if(j.animations.length>1){let s,e,k=1;if(j.totalWeight<1){const H=1-j.totalWeight;s=[],e=[],s.push(i),e.push(H)}else{if(2===j.animations.length&&(C.h.SlerpToRef(j.animations[0].currentValue,j.animations[1].currentValue,j.animations[1].weight/j.totalWeight,H),0===j.totalAdditiveWeight))return H;s=[],e=[],k=j.totalWeight}for(let H=0;H<j.animations.length;H++){const i=j.animations[H];s.push(i.currentValue),e.push(i.weight/k)}let V=0;for(let j=0;j<s.length;)j?(V+=e[j],C.h.SlerpToRef(B,s[j],e[j]/V,B),j++):(C.h.SlerpToRef(s[j],s[j+1],e[j+1]/(e[j]+e[j+1]),H),B=H,V=e[j]+e[j+1],j+=2)}for(let e=0;e<j.additiveAnimations.length;e++){const H=j.additiveAnimations[e];0!==H.weight&&(B.multiplyToRef(H.currentValue,C.i.Quaternion[0]),C.h.SlerpToRef(B,C.i.Quaternion[0],H.weight,B))}return B}var E,r,q=s(2097);E=q.b,(r=V.e)&&(r.prototype.copyAnimationRange=function(j,H,s){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3],e=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new i.c(this.name,"_matrix",j.animations[0].framePerSecond,i.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const k=j.animations[0].getRange(H);if(!k)return!1;const V=k.from,C=k.to,L=j.animations[0].getKeys(),U=j.length,x=j.getParent(),p=this.getParent(),a=B&&x&&U&&this.length&&U!==this.length,E=a&&p&&x?p.length/x.length:1,r=B&&!p&&e&&(1!==e.x||1!==e.y||1!==e.z),q=this.animations[0].getKeys();let J,h,o;for(let i=0,R=L.length;i<R;i++)J=L[i],J.frame>=V&&J.frame<=C&&(B?(o=J.value.clone(),a?(h=o.getTranslation(),o.setTranslation(h.scaleInPlace(E))):r&&e?(h=o.getTranslation(),o.setTranslation(h.multiplyInPlace(e))):o=J.value):o=J.value,q.push({frame:J.frame+s,value:o}));return this.animations[0].createRange(H,V+s,C+s),!0}),E&&(E.prototype._animate=function(j){if(!this.animationsEnabled)return;const H=U.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=H}this.deltaTime=void 0!==j?j:this.useConstantAnimationDeltaTime?16:(H-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=H;const s=this._activeAnimatables;if(0===s.length)return;this._animationTime+=this.deltaTime;const B=this._animationTime;for(let i=0;i<s.length;i++){const j=s[i];!j._animate(B)&&j.disposeOnEnd&&i--}!function(j){if(j._registeredForLateAnimationBindings.length){for(let H=0;H<j._registeredForLateAnimationBindings.length;H++){const s=j._registeredForLateAnimationBindings.data[H];for(const j in s._lateAnimationHolders){const H=s._lateAnimationHolders[j],B=H.animations[0],e=H.originalValue;if(void 0===e||null===e)continue;const k=i.c.AllowMatrixDecomposeForInterpolation&&e.m;let V=s[j];if(k)V=p(H);else if(void 0!==e.w)V=a(H,V||C.h.Identity());else{let j=0,s=1;const k=B&&B._animationState.loopMode===i.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(H.totalWeight<1)V=k?e.clone?e.clone():e:B&&e.scale?e.scale(1-H.totalWeight):B?e*(1-H.totalWeight):e.clone?e.clone():e;else if(B){s=H.totalWeight;const i=B.weight/s;V=1!==i?B.currentValue.scale?B.currentValue.scale(i):B.currentValue*i:B.currentValue,k&&(V.addToRef?V.addToRef(e,V):V+=e),j=1}for(let i=j;i<H.animations.length;i++){const j=H.animations[i],B=j.weight/s;B&&(j.currentValue.scaleAndAddToRef?j.currentValue.scaleAndAddToRef(B,V):V+=j.currentValue*B)}for(let i=0;i<H.additiveAnimations.length;i++){const j=H.additiveAnimations[i],s=j.weight;s&&(j.currentValue.scaleAndAddToRef?j.currentValue.scaleAndAddToRef(s,V):V+=j.currentValue*s)}}s[j]=V}s._lateAnimationHolders={}}j._registeredForLateAnimationBindings.reset()}}(this)},E.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((j,H)=>j.playOrder-H.playOrder))},E.prototype.beginWeightedAnimation=function(j,H,s){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,B=arguments.length>4?arguments[4]:void 0,e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,V=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,L=arguments.length>9?arguments[9]:void 0,U=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const x=this.beginAnimation(j,H,s,B,e,k,V,!1,C,L,U);return x.weight=i,x},E.prototype.beginAnimation=function(j,H,s,i){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,e=arguments.length>5?arguments[5]:void 0,k=arguments.length>6?arguments[6]:void 0,V=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],C=arguments.length>8?arguments[8]:void 0,L=arguments.length>9?arguments[9]:void 0,U=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(B<0){const j=H;H=s,s=j,B=-B}H>s&&(B=-B),V&&this.stopAnimation(j,void 0,C),k||(k=new x(this,j,H,s,i,B,e,void 0,L,U));const p=!C||C(j);if(j.animations&&p&&k.appendAnimations(j,j.animations),j.getAnimatables){const U=j.getAnimatables();for(let j=0;j<U.length;j++)this.beginAnimation(U[j],H,s,i,B,e,k,V,C,L)}return k.reset(),k},E.prototype.beginHierarchyAnimation=function(j,H,s,i,B){let e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,V=arguments.length>7?arguments[7]:void 0,C=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],L=arguments.length>9?arguments[9]:void 0,U=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const x=j.getDescendants(H),p=[];p.push(this.beginAnimation(j,s,i,B,e,k,V,C,L,void 0,U));for(const a of x)p.push(this.beginAnimation(a,s,i,B,e,k,V,C,L,void 0,U));return p},E.prototype.beginDirectAnimation=function(j,H,s,i,B){let e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(e<0){const j=s;s=i,i=j,e=-e}return s>i&&(e=-e),new x(this,j,s,i,B,e,arguments.length>6?arguments[6]:void 0,H,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},E.prototype.beginDirectHierarchyAnimation=function(j,H,s,i,B,e,k,V,C){let L=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const U=j.getDescendants(H),x=[];x.push(this.beginDirectAnimation(j,s,i,B,e,k,V,C,L));for(const p of U)x.push(this.beginDirectAnimation(p,s,i,B,e,k,V,C,L));return x},E.prototype.getAnimatableByTarget=function(j){for(let H=0;H<this._activeAnimatables.length;H++)if(this._activeAnimatables[H].target===j)return this._activeAnimatables[H];return null},E.prototype.getAllAnimatablesByTarget=function(j){const H=[];for(let s=0;s<this._activeAnimatables.length;s++)this._activeAnimatables[s].target===j&&H.push(this._activeAnimatables[s]);return H},E.prototype.stopAnimation=function(j,H,s){const i=this.getAllAnimatablesByTarget(j);for(const B of i)B.stop(H,s)},E.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let j=0;j<this._activeAnimatables.length;j++)this._activeAnimatables[j].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const j of this.animationGroups)j.stop()});class J{getClassName(){return"TargetedAnimation"}serialize(){const j={};return j.animation=this.animation.serialize(),j.targetId=this.target.id,j}}class h{get mask(){return this._mask}set mask(j){this._mask!==j&&(this._mask=j,this.syncWithMask(!0))}syncWithMask(){let j=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||j){this._numActiveAnimatables=0;for(let j=0;j<this._animatables.length;++j){const H=this._animatables[j];!this.mask||this.mask.disabled||this.mask.retainsTarget(H.target.name)?(this._numActiveAnimatables++,H.paused&&H.restart()):H.paused||H.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let j=0;j<this._animatables.length;++j){const H=this._animatables[j];this.mask.retainsTarget(H.target.name)||(H.stop(),this._animatables.splice(j,1),--j)}for(let j=0;j<this._targetedAnimations.length;j++){const H=this._targetedAnimations[j];this.mask.retainsTarget(H.target.name)||(this._targetedAnimations.splice(j,1),--j)}}}get from(){return this._from}set from(j){if(this._from!==j){this._from=j;for(let j=0;j<this._animatables.length;j++){this._animatables[j].fromFrame=this._from}}}get to(){return this._to}set to(j){if(this._to!==j){this._to=j;for(let j=0;j<this._animatables.length;j++){this._animatables[j].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(j){if(this._speedRatio!==j){this._speedRatio=j;for(let j=0;j<this._animatables.length;j++){this._animatables[j].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(j){if(this._loopAnimation!==j){this._loopAnimation=j;for(let j=0;j<this._animatables.length;j++){this._animatables[j].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(j){if(this._isAdditive!==j){this._isAdditive=j;for(let j=0;j<this._animatables.length;j++){this._animatables[j].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(j){this._weight!==j&&(this._weight=j,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(j){if(this._playOrder!==j&&(this._playOrder=j,this._animatables.length>0)){for(let j=0;j<this._animatables.length;j++)this._animatables[j].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(j){if(this._enableBlending!==j&&(this._enableBlending=j,null!==j))for(let H=0;H<this._targetedAnimations.length;++H)this._targetedAnimations[H].animation.enableBlending=j}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(j){if(this._blendingSpeed!==j&&(this._blendingSpeed=j,null!==j))for(let H=0;H<this._targetedAnimations.length;++H)this._targetedAnimations[H].animation.blendingSpeed=j}getLength(j,H){j=j??this._from;return((H=H??this._to)-j)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(j){let H=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],s=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=arguments.length>3?arguments[3]:void 0;if(0===j.length)return null;i=i??j[0].weight;let B=Number.MAX_VALUE,e=-Number.MAX_VALUE;if(s)for(const V of j)V.from<B&&(B=V.from),V.to>e&&(e=V.to);const k=new h(j[0].name+"_merged",j[0]._scene,i);for(const V of j){s&&V.normalize(B,e);for(const j of V.targetedAnimations)k.addTargetedAnimation(j.animation,j.target);H&&V.dispose()}return k}constructor(j){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=j,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new B.d,this.onAnimationLoopObservable=new B.d,this.onAnimationGroupLoopObservable=new B.d,this.onAnimationGroupEndObservable=new B.d,this.onAnimationGroupPauseObservable=new B.d,this.onAnimationGroupPlayObservable=new B.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=H||e.c.LastCreatedScene,this._weight=s,this._playOrder=i,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(j,H){const s=new J;s.animation=j,s.target=H;const i=j.getKeys();return this._from>i[0].frame&&(this._from=i[0].frame),this._to<i[i.length-1].frame&&(this._to=i[i.length-1].frame),null!==this._enableBlending&&(j.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(j.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(s),this._shouldStart=!0,s}removeTargetedAnimation(j){for(let H=this._targetedAnimations.length-1;H>-1;H--){this._targetedAnimations[H].animation===j&&this._targetedAnimations.splice(H,1)}}normalize(){let j=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==j&&(j=this._from),null==H&&(H=this._to);for(let s=0;s<this._targetedAnimations.length;s++){const i=this._targetedAnimations[s].animation.getKeys(),B=i[0],e=i[i.length-1];if(B.frame>j){const H={frame:j,value:B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation};i.splice(0,0,H)}if(e.frame<H){const j={frame:H,value:e.value,inTangent:e.inTangent,outTangent:e.outTangent,interpolation:e.interpolation};i.push(j)}}return this._from=j,this._to=H,this}_processLoop(j,H,s){j.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(H),this._animationLoopFlags[s]||(this._animationLoopFlags[s]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let j=arguments.length>0&&void 0!==arguments[0]&&arguments[0],H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,s=arguments.length>2?arguments[2]:void 0,i=arguments.length>3?arguments[3]:void 0,B=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=j,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let e=0;e<this._targetedAnimations.length;e++){const k=this._targetedAnimations[e],V=this._scene.beginDirectAnimation(k.target,[k.animation],void 0!==s?s:this._from,void 0!==i?i:this._to,j,H,void 0,void 0,void 0!==B?B:this._isAdditive);V.weight=this._weight,V.playOrder=this._playOrder,V.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(k),this._checkAnimationGroupEnded(V)},this._processLoop(V,k,e),this._animatables.push(V)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=H,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let j=0;j<this._animatables.length;j++){this._animatables[j].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(j){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==j&&(this.loopAnimation=j),this.restart()):(this.stop(),this.start(j,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let j=0;j<this._animatables.length;j++){this._animatables[j].reset()}return this}restart(){if(!this._isStarted)return this;for(let j=0;j<this._animatables.length;j++){this._animatables[j].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let j=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const H=this._animatables.slice();for(let i=0;i<H.length;i++)H[i].stop(void 0,void 0,!0,j);let s=0;for(let i=0;i<this._scene._activeAnimatables.length;i++){const H=this._scene._activeAnimatables[i];H._runtimeAnimations.length>0?this._scene._activeAnimatables[s++]=H:j&&this._checkAnimationGroupEnded(H,j)}return this._scene._activeAnimatables.length=s,this._isStarted=!1,this}setWeightForAllAnimatables(j){for(let H=0;H<this._animatables.length;H++){this._animatables[H].weight=j}return this}syncAllAnimationsWith(j){for(let H=0;H<this._animatables.length;H++){this._animatables[H].syncWith(j)}return this}goToFrame(j){if(!this._isStarted)return this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].goToFrame(j)}return this}getCurrentFrame(){var j;return(null===(j=this.animatables[0])||void 0===j?void 0:j.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const j=this._scene.animationGroups.indexOf(this);if(j>-1&&this._scene.animationGroups.splice(j,1),this._parentContainer){const j=this._parentContainer.animationGroups.indexOf(this);j>-1&&this._parentContainer.animationGroups.splice(j,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(j){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const s=this._animatables.indexOf(j);s>-1&&this._animatables.splice(s,1),0===this._animatables.length&&(this._isStarted=!1,H||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(j,H){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=new h(j||this.name,this._scene,this._weight,this._playOrder);i._from=this.from,i._to=this.to,i._speedRatio=this.speedRatio,i._loopAnimation=this.loopAnimation,i._isAdditive=this.isAdditive,i._enableBlending=this.enableBlending,i._blendingSpeed=this.blendingSpeed,i.metadata=this.metadata,i.mask=this.mask;for(const B of this._targetedAnimations)i.addTargetedAnimation(s?B.animation.clone():B.animation,H?H(B.target):B.target);return i}serialize(){const j={};j.name=this.name,j.from=this.from,j.to=this.to,j.speedRatio=this.speedRatio,j.loopAnimation=this.loopAnimation,j.isAdditive=this.isAdditive,j.weight=this.weight,j.playOrder=this.playOrder,j.enableBlending=this.enableBlending,j.blendingSpeed=this.blendingSpeed,j.targetedAnimations=[];for(let H=0;H<this.targetedAnimations.length;H++){const s=this.targetedAnimations[H];j.targetedAnimations[H]=s.serialize()}return k.c&&k.c.HasTags(this)&&(j.tags=k.c.GetTags(this)),this.metadata&&(j.metadata=this.metadata),j}static Parse(j,H){const s=new h(j.name,H,j.weight,j.playOrder);for(let B=0;B<j.targetedAnimations.length;B++){const e=j.targetedAnimations[B],k=i.c.Parse(e.animation),V=e.targetId;if("influence"===e.animation.property){const j=H.getMorphTargetById(V);j&&s.addTargetedAnimation(k,j)}else{const j=H.getNodeById(V);null!=j&&s.addTargetedAnimation(k,j)}}return k.c&&k.c.AddTagsTo(s,j.tags),null!==j.from&&null!==j.to&&s.normalize(j.from,j.to),void 0!==j.speedRatio&&(s._speedRatio=j.speedRatio),void 0!==j.loopAnimation&&(s._loopAnimation=j.loopAnimation),void 0!==j.isAdditive&&(s._isAdditive=j.isAdditive),void 0!==j.weight&&(s._weight=j.weight),void 0!==j.playOrder&&(s._playOrder=j.playOrder),void 0!==j.enableBlending&&(s._enableBlending=j.enableBlending),void 0!==j.blendingSpeed&&(s._blendingSpeed=j.blendingSpeed),void 0!==j.metadata&&(s.metadata=j.metadata),s}static MakeAnimationAdditive(j,H,s){let B;B="object"===typeof H?H:{referenceFrame:H,range:s,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let e=j;B.cloneOriginalAnimationGroup&&(e=j.clone(B.clonedAnimationGroupName||e.name));const k=e.targetedAnimations;for(let V=0;V<k.length;V++){const j=k[V];j.animation=i.c.MakeAnimationAdditive(j.animation,B)}if(e.isAdditive=!0,B.clipKeys){let j=Number.MAX_VALUE,H=-Number.MAX_VALUE;const s=e.targetedAnimations;for(let i=0;i<s.length;i++){const B=s[i].animation.getKeys();j>B[0].frame&&(j=B[0].frame),H<B[B.length-1].frame&&(H=B[B.length-1].frame)}e._from=j,e._to=H}return e}static ClipKeys(j,H,s,i,B){const e=j.clone(i||j.name);return h.ClipKeysInPlace(e,H,s,B)}static ClipKeysInPlace(j,H,s,i){return h.ClipInPlace(j,H,s,i,!1)}static ClipFrames(j,H,s,i,B){const e=j.clone(i||j.name);return h.ClipFramesInPlace(e,H,s,B)}static ClipFramesInPlace(j,H,s,i){return h.ClipInPlace(j,H,s,i,!0)}static ClipInPlace(j,H,s,i){let B=arguments.length>4&&void 0!==arguments[4]&&arguments[4],e=Number.MAX_VALUE,k=-Number.MAX_VALUE;const V=j.targetedAnimations;for(let C=0;C<V.length;C++){const j=V[C],L=i?j.animation:j.animation.clone();B&&(L.createKeyForFrame(H),L.createKeyForFrame(s));const U=L.getKeys(),x=[];let p=Number.MAX_VALUE;for(let i=0;i<U.length;i++){const j=U[i];if(!B&&i>=H&&i<=s||B&&j.frame>=H&&j.frame<=s){const H={frame:j.frame,value:j.value.clone?j.value.clone():j.value,inTangent:j.inTangent,outTangent:j.outTangent,interpolation:j.interpolation,lockedTangent:j.lockedTangent};p===Number.MAX_VALUE&&(p=H.frame),H.frame-=p,x.push(H)}}0!==x.length?(e>x[0].frame&&(e=x[0].frame),k<x[x.length-1].frame&&(k=x[x.length-1].frame),L.setKeys(x,!0),j.animation=L):(V.splice(C,1),C--)}return j._from=e,j._to=k,j}getClassName(){return"AnimationGroup"}toString(j){let H="Name: "+this.name;return H+=", type: "+this.getClassName(),j&&(H+=", from: "+this._from,H+=", to: "+this._to,H+=", isStarted: "+this._isStarted,H+=", speedRatio: "+this._speedRatio,H+=", targetedAnimations length: "+this._targetedAnimations.length,H+=", animatables length: "+this._animatables),H}}}}]);