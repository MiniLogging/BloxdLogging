"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[48],{13357:(Y,d,t)=>{t.r(d),t.d(d,{AnimationGroup:()=>T,TargetedAnimation:()=>g});var x=t(12307),C=t(513),U=t(561),y=t(659),B=t(12298),W=t(686);class o{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(Y,d,t,C){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=d,this._target=Y,this._scene=t,this._host=C,this._activeTargets=[],d._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===x.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=W.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const Y={frame:0,value:this._minValue};this._keys.splice(0,0,Y)}if(this._target instanceof Array){let Y=0;for(const d of this._target)this._preparePath(d,Y),this._getOriginalValues(Y),Y++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const U=d.getEvents();U&&U.length>0&&U.forEach((Y=>{this._events.push(Y._clone())})),this._enableBlending=Y&&Y.animationPropertiesOverride?Y.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const t=this._animation.targetPropertyPath;if(t.length>1){let x=Y;for(let Y=0;Y<t.length-1;Y++){const d=t[Y];if(x=x[d],void 0===x)throw new Error(`Invalid property (${d}) in property path (${t.join(".")})`)}this._targetPath=t[t.length-1],this._activeTargets[d]=x}else this._targetPath=t[0],this._activeTargets[d]=Y;if(void 0===this._activeTargets[d][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${t.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let Y=0;for(const d of this._target)void 0!==this._originalValue[Y]&&this._setValue(d,this._activeTargets[Y],this._originalValue[Y],-1,Y),Y++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let Y=0;Y<this._events.length;Y++)this._events[Y].isDone=!1}isStopped(){return this._stopped}dispose(){const Y=this._animation.runtimeAnimations.indexOf(this);Y>-1&&this._animation.runtimeAnimations.splice(Y,1)}setValue(Y,d){if(this._targetIsArray)for(let t=0;t<this._target.length;t++){const x=this._target[t];this._setValue(x,this._activeTargets[t],Y,d,t)}else this._setValue(this._target,this._directTarget,Y,d,0)}_getOriginalValues(){let Y,d=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=this._activeTargets[d];Y=t.getLocalMatrix&&"_matrix"===this._targetPath?t.getLocalMatrix():t[this._targetPath],Y&&Y.clone?this._originalValue[d]=Y.clone():this._originalValue[d]=Y}_registerTargetForLateAnimationBinding(Y,d){const t=Y.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(t),t._lateAnimationHolders||(t._lateAnimationHolders={}),t._lateAnimationHolders[Y.targetPath]||(t._lateAnimationHolders[Y.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:d}),Y.isAdditive?(t._lateAnimationHolders[Y.targetPath].additiveAnimations.push(Y),t._lateAnimationHolders[Y.targetPath].totalAdditiveWeight+=Y.weight):(t._lateAnimationHolders[Y.targetPath].animations.push(Y),t._lateAnimationHolders[Y.targetPath].totalWeight+=Y.weight)}_setValue(Y,d,t,C,U){if(this._currentActiveTarget=d,this._weight=C,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const Y=d[this._targetPath];Y.clone?this._originalBlendValue=Y.clone():this._originalBlendValue=Y}this._originalBlendValue.m?x.b.AllowMatrixDecomposeForInterpolation?this._currentValue?W.b.DecomposeLerpToRef(this._originalBlendValue,t,this._blendingFactor,this._currentValue):this._currentValue=W.b.DecomposeLerp(this._originalBlendValue,t,this._blendingFactor):this._currentValue?W.b.LerpToRef(this._originalBlendValue,t,this._blendingFactor,this._currentValue):this._currentValue=W.b.Lerp(this._originalBlendValue,t,this._blendingFactor):this._currentValue=x.b._UniversalLerp(this._originalBlendValue,t,this._blendingFactor);const C=Y&&Y.animationPropertiesOverride?Y.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=C}else this._currentValue?this._currentValue.p?this._currentValue.p(t):this._currentValue=t:null!==t&&void 0!==t&&t.clone?this._currentValue=t.clone():this._currentValue=t;-1!==C?this._registerTargetForLateAnimationBinding(this,this._originalValue[U]):this._animationState.loopMode===x.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[U],d[this._targetPath]):d[this._targetPath]=this._originalValue[U]+this._currentValue:d[this._targetPath]=this._currentValue,Y.ck&&Y.ck(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const t=this._animation.getKeys();Y<t[0].frame?Y=t[0].frame:Y>t[t.length-1].frame&&(Y=t[t.length-1].frame);const x=this._events;if(x.length)for(let U=0;U<x.length;U++)x[U].onlyOnce||(x[U].isDone=x[U].frame<Y);this._currentFrame=Y;const C=this._animation._interpolate(Y,this._animationState);this.setValue(C,d)}_prepareForSpeedRatioChange(Y){const d=this._previousElapsedTime*(this._animation.framePerSecond*Y)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-d}animate(Y,d,t,C,U){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const B=this._animation,W=B.targetPropertyPath;if(!W||W.length<1)return this._stopped=!0,!1;let o=!0;(d<this._minFrame||d>this._maxFrame)&&(d=this._minFrame),(t<this._minFrame||t>this._maxFrame)&&(t=this._maxFrame);const f=t-d;let F,D=Y*(B.framePerSecond*U)/1e3+this._absoluteFrameOffset,b=0,m=!1;const M=C&&this._animationState.loopMode===x.b.ANIMATIONLOOPMODE_YOYO;if(M){const Y=(D-d)/f,t=Math.sin(Y*Math.PI);D=Math.abs(t)*f+d;const x=t>=0?1:-1;this._yoyoDirection!==x&&(m=!0),this._yoyoDirection=x}if(this._previousElapsedTime=Y,this._previousAbsoluteFrame=D,!C&&t>=d&&(D>=f&&U>0||D<=0&&U<0))o=!1,b=B._getKeyValue(this._maxValue);else if(!C&&d>=t&&(D<=f&&U<0||D>=0&&U>0))o=!1,b=B._getKeyValue(this._minValue);else if(this._animationState.loopMode!==x.b.ANIMATIONLOOPMODE_CYCLE){const Y=t.toString()+d.toString();if(!this._offsetsCache[Y]){this._animationState.repeatCount=0,this._animationState.loopMode=x.b.ANIMATIONLOOPMODE_CYCLE;const C=B._interpolate(d,this._animationState),U=B._interpolate(t,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),B.dataType){case x.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[Y]=U-C;break;case x.b.ANIMATIONTYPE_QUATERNION:case x.b.ANIMATIONTYPE_VECTOR3:case x.b.ANIMATIONTYPE_VECTOR2:case x.b.ANIMATIONTYPE_SIZE:case x.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[Y]=U.ae(C)}this._highLimitsCache[Y]=U}b=this._highLimitsCache[Y],F=this._offsetsCache[Y]}if(void 0===F)switch(B.dataType){case x.b.ANIMATIONTYPE_FLOAT:F=0;break;case x.b.ANIMATIONTYPE_QUATERNION:F=x.i;break;case x.b.ANIMATIONTYPE_VECTOR3:F=x.s;break;case x.b.ANIMATIONTYPE_VECTOR2:F=x.o;break;case x.b.ANIMATIONTYPE_SIZE:F=x.k;break;case x.b.ANIMATIONTYPE_COLOR3:F=x.c;break;case x.b.ANIMATIONTYPE_COLOR4:F=x.e}let J;if(this._host&&this._host.syncRoot){const Y=this._host.syncRoot;J=d+f*((Y.masterFrame-Y.fromFrame)/(Y.toFrame-Y.fromFrame))}else J=D>0&&d>t||D<0&&d<t?o&&0!==f?t+D%f:d:o&&0!==f?d+D%f:t;const g=this._events;if(!M&&(U>0&&this.currentFrame>J||U<0&&this.currentFrame<J)||M&&m){this._onLoop();for(let Y=0;Y<g.length;Y++)g[Y].onlyOnce||(g[Y].isDone=!1);this._animationState.key=U>0?0:B.getKeys().length-1}this._currentFrame=J,this._animationState.repeatCount=0===f?0:D/f|0,this._animationState.highLimitValue=b,this._animationState.offsetValue=F;const T=B._interpolate(J,this._animationState);if(this.setValue(T,y),g.length)for(let x=0;x<g.length;x++)if(f>=0&&J>=g[x].frame&&g[x].frame>=d||f<0&&J<=g[x].frame&&g[x].frame<=d){const Y=g[x];Y.isDone||(Y.onlyOnce&&(g.splice(x,1),x--),Y.isDone=!0,Y.action(J))}return o||(this._stopped=!0),o}}var f=t(545);class F{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(Y){this._weight=-1!==Y?Math.min(Math.max(Y,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(Y){for(let d=0;d<this._runtimeAnimations.length;d++){this._runtimeAnimations[d]._prepareForSpeedRatioChange(Y)}this._speedRatio=Y,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(Y,d){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,U=arguments.length>4&&void 0!==arguments[4]&&arguments[4],y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,B=arguments.length>6?arguments[6]:void 0,W=arguments.length>7?arguments[7]:void 0,o=arguments.length>8?arguments[8]:void 0,f=arguments.length>9&&void 0!==arguments[9]&&arguments[9],F=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=d,this.fromFrame=t,this.toFrame=x,this.loopAnimation=U,this.onAnimationEnd=B,this.onAnimationLoop=o,this.isAdditive=f,this.playOrder=F,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Zj=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new C.b,this.onAnimationLoopObservable=new C.b,this._scene=Y,W&&this.appendAnimations(d,W),this._speedRatio=y,Y._activeAnimatables.push(this)}syncWith(Y){if(this._syncRoot=Y,Y){const Y=this._scene._activeAnimatables.indexOf(this);Y>-1&&(this._scene._activeAnimatables.splice(Y,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(Y,d){for(let t=0;t<d.length;t++){const x=d[t],C=new o(Y,x,this._scene,this);C._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(C)}}getAnimationByTargetProperty(Y){const d=this._runtimeAnimations;for(let t=0;t<d.length;t++)if(d[t].animation.targetProperty===Y)return d[t].animation;return null}getRuntimeAnimationByTargetProperty(Y){const d=this._runtimeAnimations;for(let t=0;t<d.length;t++)if(d[t].animation.targetProperty===Y)return d[t];return null}reset(){const Y=this._runtimeAnimations;for(let d=0;d<Y.length;d++)Y[d].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(Y){const d=this._runtimeAnimations;for(let t=0;t<d.length;t++)d[t].animation.enableBlending=!0,d[t].animation.blendingSpeed=Y}disableBlending(){const Y=this._runtimeAnimations;for(let d=0;d<Y.length;d++)Y[d].animation.enableBlending=!1}goToFrame(Y){const d=this._runtimeAnimations;if(d[0]){const t=d[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??d[0].currentFrame;const x=0===this.speedRatio?0:(Y-this._frameToSyncFromJump)/t*1e3/this.speedRatio;this._manualJumpDelay=-x}for(let t=0;t<d.length;t++)d[t].goToFrame(Y,this._weight);this._goToFrame=Y}get paused(){return this.Zj}pause(){this.Zj||(this.Zj=!0)}restart(){this.Zj=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(Y,d){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Y||d){const C=this._scene._activeAnimatables.indexOf(this);if(C>-1){const U=this._runtimeAnimations;for(let t=U.length-1;t>=0;t--){const x=U[t];Y&&x.animation.name!=Y||(d&&!d(x.target)||(x.dispose(),U.splice(t,1)))}0==U.length&&(t||this._scene._activeAnimatables.splice(C,1),x||this._raiseOnAnimationEnd())}}else{const Y=this._scene._activeAnimatables.indexOf(this);if(Y>-1){t||this._scene._activeAnimatables.splice(Y,1);const d=this._runtimeAnimations;for(let Y=0;Y<d.length;Y++)d[Y].dispose();this._runtimeAnimations.length=0,x||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((Y=>{this.onAnimationEndObservable.add((()=>{Y(this)}),void 0,void 0,this,!0)}))}_animate(Y){if(this.Zj)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=Y),!0;if(null===this._localDelayOffset?(this._localDelayOffset=Y,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=Y-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let d=!1;const t=this._runtimeAnimations;let x;for(x=0;x<t.length;x++){const C=t[x].animate(Y-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);d=d||C}if(this.animationStarted=d,!d){if(this.disposeOnEnd)for(x=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(x,1),x=0;x<t.length;x++)t[x].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return d}}function D(Y){if(0===Y.totalWeight&&0===Y.totalAdditiveWeight)return Y.originalValue;let d=1;const t=W.g.gk[0],x=W.g.gk[1],C=W.g.Quaternion[0];let U=0;const y=Y.animations[0],B=Y.originalValue;let o=1,f=!1;if(Y.totalWeight<1)o=1-Y.totalWeight,B.decompose(x,C,t);else{if(U=1,d=Y.totalWeight,o=y.weight/d,1==o){if(!Y.totalAdditiveWeight)return y.currentValue;f=!0}y.currentValue.decompose(x,C,t)}if(!f){x.scaleInPlace(o),t.scaleInPlace(o),C.scaleInPlace(o);for(let y=U;y<Y.animations.length;y++){const U=Y.animations[y];if(0===U.weight)continue;o=U.weight/d;const B=W.g.gk[2],f=W.g.gk[3],F=W.g.Quaternion[1];U.currentValue.decompose(f,F,B),f.scaleAndAddToRef(o,x),F.scaleAndAddToRef(W.d.Dot(C,F)>0?o:-o,C),B.scaleAndAddToRef(o,t)}C.normalize()}for(let D=0;D<Y.additiveAnimations.length;D++){const d=Y.additiveAnimations[D];if(0===d.weight)continue;const U=W.g.gk[2],y=W.g.gk[3],B=W.g.Quaternion[1];d.currentValue.decompose(y,B,U),y.multiplyToRef(x,y),W.k.LerpToRef(x,y,d.weight,x),C.multiplyToRef(B,B),W.d.SlerpToRef(C,B,d.weight,C),U.scaleAndAddToRef(d.weight,t)}const F=y?y._animationState.workValue:W.g.Matrix[0].clone();return W.b.ComposeToRef(x,C,t,F),F}function b(Y,d){if(0===Y.totalWeight&&0===Y.totalAdditiveWeight)return d;const t=Y.animations[0],x=Y.originalValue;let C=d;if(0===Y.totalWeight&&Y.totalAdditiveWeight>0)C.p(x);else if(1===Y.animations.length){if(W.d.SlerpToRef(x,t.currentValue,Math.min(1,Y.totalWeight),C),0===Y.totalAdditiveWeight)return C}else if(Y.animations.length>1){let t,U,y=1;if(Y.totalWeight<1){const d=1-Y.totalWeight;t=[],U=[],t.push(x),U.push(d)}else{if(2===Y.animations.length&&(W.d.SlerpToRef(Y.animations[0].currentValue,Y.animations[1].currentValue,Y.animations[1].weight/Y.totalWeight,d),0===Y.totalAdditiveWeight))return d;t=[],U=[],y=Y.totalWeight}for(let d=0;d<Y.animations.length;d++){const x=Y.animations[d];t.push(x.currentValue),U.push(x.weight/y)}let B=0;for(let Y=0;Y<t.length;)Y?(B+=U[Y],W.d.SlerpToRef(C,t[Y],U[Y]/B,C),Y++):(W.d.SlerpToRef(t[Y],t[Y+1],U[Y+1]/(U[Y]+U[Y+1]),d),C=d,B=U[Y]+U[Y+1],Y+=2)}for(let U=0;U<Y.additiveAnimations.length;U++){const d=Y.additiveAnimations[U];0!==d.weight&&(C.multiplyToRef(d.currentValue,W.g.Quaternion[0]),W.d.SlerpToRef(C,W.g.Quaternion[0],d.weight,C))}return C}var m,M,J=t(2148);m=J.b,(M=B.c)&&(M.prototype.copyAnimationRange=function(Y,d,t){let C=arguments.length>3&&void 0!==arguments[3]&&arguments[3],U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new x.b(this.name,"_matrix",Y.animations[0].framePerSecond,x.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const y=Y.animations[0].getRange(d);if(!y)return!1;const B=y.from,W=y.to,o=Y.animations[0].getKeys(),f=Y.length,F=Y.getParent(),D=this.getParent(),b=C&&F&&f&&this.length&&f!==this.length,m=b&&D&&F?D.length/F.length:1,M=C&&!D&&U&&(1!==U.x||1!==U.y||1!==U.z),J=this.animations[0].getKeys();let g,T,s;for(let x=0,l=o.length;x<l;x++)g=o[x],g.frame>=B&&g.frame<=W&&(C?(s=g.value.clone(),b?(T=s.getTranslation(),s.setTranslation(T.scaleInPlace(m))):M&&U?(T=s.getTranslation(),s.setTranslation(T.multiplyInPlace(U))):s=g.value):s=g.value,J.push({frame:g.frame+t,value:s}));return this.animations[0].createRange(d,B+t,W+t),!0}),m&&(m.prototype._animate=function(Y){if(!this.animationsEnabled)return;const d=f.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=d}this.deltaTime=void 0!==Y?Y:this.useConstantAnimationDeltaTime?16:(d-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=d;const t=this._activeAnimatables;if(0===t.length)return;this._animationTime+=this.deltaTime;const C=this._animationTime;for(let x=0;x<t.length;x++){const Y=t[x];!Y._animate(C)&&Y.disposeOnEnd&&x--}!function(Y){if(Y._registeredForLateAnimationBindings.length){for(let d=0;d<Y._registeredForLateAnimationBindings.length;d++){const t=Y._registeredForLateAnimationBindings.data[d];for(const Y in t._lateAnimationHolders){const d=t._lateAnimationHolders[Y],C=d.animations[0],U=d.originalValue;if(void 0===U||null===U)continue;const y=x.b.AllowMatrixDecomposeForInterpolation&&U.m;let B=t[Y];if(y)B=D(d);else if(void 0!==U.w)B=b(d,B||W.d.Identity());else{let Y=0,t=1;const y=C&&C._animationState.loopMode===x.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(d.totalWeight<1)B=y?U.clone?U.clone():U:C&&U.scale?U.scale(1-d.totalWeight):C?U*(1-d.totalWeight):U.clone?U.clone():U;else if(C){t=d.totalWeight;const x=C.weight/t;B=1!==x?C.currentValue.scale?C.currentValue.scale(x):C.currentValue*x:C.currentValue,y&&(B.addToRef?B.addToRef(U,B):B+=U),Y=1}for(let x=Y;x<d.animations.length;x++){const Y=d.animations[x],C=Y.weight/t;C&&(Y.currentValue.scaleAndAddToRef?Y.currentValue.scaleAndAddToRef(C,B):B+=Y.currentValue*C)}for(let x=0;x<d.additiveAnimations.length;x++){const Y=d.additiveAnimations[x],t=Y.weight;t&&(Y.currentValue.scaleAndAddToRef?Y.currentValue.scaleAndAddToRef(t,B):B+=Y.currentValue*t)}}t[Y]=B}t._lateAnimationHolders={}}Y._registeredForLateAnimationBindings.reset()}}(this)},m.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((Y,d)=>Y.playOrder-d.playOrder))},m.prototype.beginWeightedAnimation=function(Y,d,t){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,C=arguments.length>4?arguments[4]:void 0,U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,y=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0,W=arguments.length>8?arguments[8]:void 0,o=arguments.length>9?arguments[9]:void 0,f=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const F=this.beginAnimation(Y,d,t,C,U,y,B,!1,W,o,f);return F.weight=x,F},m.prototype.beginAnimation=function(Y,d,t,x){let C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,U=arguments.length>5?arguments[5]:void 0,y=arguments.length>6?arguments[6]:void 0,B=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],W=arguments.length>8?arguments[8]:void 0,o=arguments.length>9?arguments[9]:void 0,f=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(C<0){const Y=d;d=t,t=Y,C=-C}d>t&&(C=-C),B&&this.stopAnimation(Y,void 0,W),y||(y=new F(this,Y,d,t,x,C,U,void 0,o,f));const D=!W||W(Y);if(Y.animations&&D&&y.appendAnimations(Y,Y.animations),Y.getAnimatables){const f=Y.getAnimatables();for(let Y=0;Y<f.length;Y++)this.beginAnimation(f[Y],d,t,x,C,U,y,B,W,o)}return y.reset(),y},m.prototype.beginHierarchyAnimation=function(Y,d,t,x,C){let U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,y=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0,W=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],o=arguments.length>9?arguments[9]:void 0,f=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const F=Y.getDescendants(d),D=[];D.push(this.beginAnimation(Y,t,x,C,U,y,B,W,o,void 0,f));for(const b of F)D.push(this.beginAnimation(b,t,x,C,U,y,B,W,o,void 0,f));return D},m.prototype.beginDirectAnimation=function(Y,d,t,x,C){let U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(U<0){const Y=t;t=x,x=Y,U=-U}return t>x&&(U=-U),new F(this,Y,t,x,C,U,arguments.length>6?arguments[6]:void 0,d,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},m.prototype.beginDirectHierarchyAnimation=function(Y,d,t,x,C,U,y,B,W){let o=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const f=Y.getDescendants(d),F=[];F.push(this.beginDirectAnimation(Y,t,x,C,U,y,B,W,o));for(const D of f)F.push(this.beginDirectAnimation(D,t,x,C,U,y,B,W,o));return F},m.prototype.getAnimatableByTarget=function(Y){for(let d=0;d<this._activeAnimatables.length;d++)if(this._activeAnimatables[d].target===Y)return this._activeAnimatables[d];return null},m.prototype.getAllAnimatablesByTarget=function(Y){const d=[];for(let t=0;t<this._activeAnimatables.length;t++)this._activeAnimatables[t].target===Y&&d.push(this._activeAnimatables[t]);return d},m.prototype.stopAnimation=function(Y,d,t){const x=this.getAllAnimatablesByTarget(Y);for(const C of x)C.stop(d,t)},m.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let Y=0;Y<this._activeAnimatables.length;Y++)this._activeAnimatables[Y].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const Y of this.animationGroups)Y.stop()});class g{getClassName(){return"TargetedAnimation"}serialize(){const Y={};return Y.animation=this.animation.serialize(),Y.targetId=this.target.id,Y}}class T{get mask(){return this._mask}set mask(Y){this._mask!==Y&&(this._mask=Y,this.syncWithMask(!0))}syncWithMask(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||Y){this._numActiveAnimatables=0;for(let Y=0;Y<this._animatables.length;++Y){const d=this._animatables[Y];!this.mask||this.mask.disabled||this.mask.retainsTarget(d.target.name)?(this._numActiveAnimatables++,d.paused&&d.restart()):d.paused||d.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let Y=0;Y<this._animatables.length;++Y){const d=this._animatables[Y];this.mask.retainsTarget(d.target.name)||(d.stop(),this._animatables.splice(Y,1),--Y)}for(let Y=0;Y<this._targetedAnimations.length;Y++){const d=this._targetedAnimations[Y];this.mask.retainsTarget(d.target.name)||(this._targetedAnimations.splice(Y,1),--Y)}}}get from(){return this._from}set from(Y){if(this._from!==Y){this._from=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].fromFrame=this._from}}}get to(){return this._to}set to(Y){if(this._to!==Y){this._to=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(Y){if(this._speedRatio!==Y){this._speedRatio=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(Y){if(this._loopAnimation!==Y){this._loopAnimation=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(Y){if(this._isAdditive!==Y){this._isAdditive=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(Y){this._weight!==Y&&(this._weight=Y,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(Y){if(this._playOrder!==Y&&(this._playOrder=Y,this._animatables.length>0)){for(let Y=0;Y<this._animatables.length;Y++)this._animatables[Y].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(Y){if(this._enableBlending!==Y&&(this._enableBlending=Y,null!==Y))for(let d=0;d<this._targetedAnimations.length;++d)this._targetedAnimations[d].animation.enableBlending=Y}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(Y){if(this._blendingSpeed!==Y&&(this._blendingSpeed=Y,null!==Y))for(let d=0;d<this._targetedAnimations.length;++d)this._targetedAnimations[d].animation.blendingSpeed=Y}getLength(Y,d){Y=Y??this._from;return((d=d??this._to)-Y)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(Y){let d=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=arguments.length>3?arguments[3]:void 0;if(0===Y.length)return null;x=x??Y[0].weight;let C=Number.MAX_VALUE,U=-Number.MAX_VALUE;if(t)for(const B of Y)B.from<C&&(C=B.from),B.to>U&&(U=B.to);const y=new T(Y[0].name+"_merged",Y[0]._scene,x);for(const B of Y){t&&B.normalize(C,U);for(const Y of B.targetedAnimations)y.addTargetedAnimation(Y.animation,Y.target);d&&B.dispose()}return y}constructor(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=Y,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new C.b,this.onAnimationLoopObservable=new C.b,this.onAnimationGroupLoopObservable=new C.b,this.onAnimationGroupEndObservable=new C.b,this.onAnimationGroupPauseObservable=new C.b,this.onAnimationGroupPlayObservable=new C.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=d||U.d.LastCreatedScene,this._weight=t,this._playOrder=x,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(Y,d){const t=new g;t.animation=Y,t.target=d;const x=Y.getKeys();return this._from>x[0].frame&&(this._from=x[0].frame),this._to<x[x.length-1].frame&&(this._to=x[x.length-1].frame),null!==this._enableBlending&&(Y.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(Y.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(t),this._shouldStart=!0,t}removeTargetedAnimation(Y){for(let d=this._targetedAnimations.length-1;d>-1;d--){this._targetedAnimations[d].animation===Y&&this._targetedAnimations.splice(d,1)}}normalize(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==Y&&(Y=this._from),null==d&&(d=this._to);for(let t=0;t<this._targetedAnimations.length;t++){const x=this._targetedAnimations[t].animation.getKeys(),C=x[0],U=x[x.length-1];if(C.frame>Y){const d={frame:Y,value:C.value,inTangent:C.inTangent,outTangent:C.outTangent,interpolation:C.interpolation};x.splice(0,0,d)}if(U.frame<d){const Y={frame:d,value:U.value,inTangent:U.inTangent,outTangent:U.outTangent,interpolation:U.interpolation};x.push(Y)}}return this._from=Y,this._to=d,this}_processLoop(Y,d,t){Y.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(d),this._animationLoopFlags[t]||(this._animationLoopFlags[t]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0],d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,t=arguments.length>2?arguments[2]:void 0,x=arguments.length>3?arguments[3]:void 0,C=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=Y,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let U=0;U<this._targetedAnimations.length;U++){const y=this._targetedAnimations[U],B=this._scene.beginDirectAnimation(y.target,[y.animation],void 0!==t?t:this._from,void 0!==x?x:this._to,Y,d,void 0,void 0,void 0!==C?C:this._isAdditive);B.weight=this._weight,B.playOrder=this._playOrder,B.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(y),this._checkAnimationGroupEnded(B)},this._processLoop(B,y,U),this._animatables.push(B)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=d,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(Y){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==Y&&(this.loopAnimation=Y),this.restart()):(this.stop(),this.start(Y,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].reset()}return this}restart(){if(!this._isStarted)return this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const d=this._animatables.slice();for(let x=0;x<d.length;x++)d[x].stop(void 0,void 0,!0,Y);let t=0;for(let x=0;x<this._scene._activeAnimatables.length;x++){const d=this._scene._activeAnimatables[x];d._runtimeAnimations.length>0?this._scene._activeAnimatables[t++]=d:Y&&this._checkAnimationGroupEnded(d,Y)}return this._scene._activeAnimatables.length=t,this._isStarted=!1,this}setWeightForAllAnimatables(Y){for(let d=0;d<this._animatables.length;d++){this._animatables[d].weight=Y}return this}syncAllAnimationsWith(Y){for(let d=0;d<this._animatables.length;d++){this._animatables[d].syncWith(Y)}return this}goToFrame(Y){if(!this._isStarted)return this;for(let d=0;d<this._animatables.length;d++){this._animatables[d].goToFrame(Y)}return this}getCurrentFrame(){var Y;return(null===(Y=this.animatables[0])||void 0===Y?void 0:Y.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const Y=this._scene.animationGroups.indexOf(this);if(Y>-1&&this._scene.animationGroups.splice(Y,1),this._parentContainer){const Y=this._parentContainer.animationGroups.indexOf(this);Y>-1&&this._parentContainer.animationGroups.splice(Y,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(Y){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const t=this._animatables.indexOf(Y);t>-1&&this._animatables.splice(t,1),0===this._animatables.length&&(this._isStarted=!1,d||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(Y,d){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const x=new T(Y||this.name,this._scene,this._weight,this._playOrder);x._from=this.from,x._to=this.to,x._speedRatio=this.speedRatio,x._loopAnimation=this.loopAnimation,x._isAdditive=this.isAdditive,x._enableBlending=this.enableBlending,x._blendingSpeed=this.blendingSpeed,x.metadata=this.metadata,x.mask=this.mask;for(const C of this._targetedAnimations)x.addTargetedAnimation(t?C.animation.clone():C.animation,d?d(C.target):C.target);return x}serialize(){const Y={};Y.name=this.name,Y.from=this.from,Y.to=this.to,Y.speedRatio=this.speedRatio,Y.loopAnimation=this.loopAnimation,Y.isAdditive=this.isAdditive,Y.weight=this.weight,Y.playOrder=this.playOrder,Y.enableBlending=this.enableBlending,Y.blendingSpeed=this.blendingSpeed,Y.targetedAnimations=[];for(let d=0;d<this.targetedAnimations.length;d++){const t=this.targetedAnimations[d];Y.targetedAnimations[d]=t.serialize()}return y.d&&y.d.HasTags(this)&&(Y.tags=y.d.GetTags(this)),this.metadata&&(Y.metadata=this.metadata),Y}static Parse(Y,d){const t=new T(Y.name,d,Y.weight,Y.playOrder);for(let C=0;C<Y.targetedAnimations.length;C++){const U=Y.targetedAnimations[C],y=x.b.Parse(U.animation),B=U.targetId;if("influence"===U.animation.property){const Y=d.getMorphTargetById(B);Y&&t.addTargetedAnimation(y,Y)}else{const Y=d.getNodeById(B);null!=Y&&t.addTargetedAnimation(y,Y)}}return y.d&&y.d.AddTagsTo(t,Y.tags),null!==Y.from&&null!==Y.to&&t.normalize(Y.from,Y.to),void 0!==Y.speedRatio&&(t._speedRatio=Y.speedRatio),void 0!==Y.loopAnimation&&(t._loopAnimation=Y.loopAnimation),void 0!==Y.isAdditive&&(t._isAdditive=Y.isAdditive),void 0!==Y.weight&&(t._weight=Y.weight),void 0!==Y.playOrder&&(t._playOrder=Y.playOrder),void 0!==Y.enableBlending&&(t._enableBlending=Y.enableBlending),void 0!==Y.blendingSpeed&&(t._blendingSpeed=Y.blendingSpeed),void 0!==Y.metadata&&(t.metadata=Y.metadata),t}static MakeAnimationAdditive(Y,d,t){let C;C="object"===typeof d?d:{referenceFrame:d,range:t,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let U=Y;C.cloneOriginalAnimationGroup&&(U=Y.clone(C.clonedAnimationGroupName||U.name));const y=U.targetedAnimations;for(let B=0;B<y.length;B++){const Y=y[B];Y.animation=x.b.MakeAnimationAdditive(Y.animation,C)}if(U.isAdditive=!0,C.clipKeys){let Y=Number.MAX_VALUE,d=-Number.MAX_VALUE;const t=U.targetedAnimations;for(let x=0;x<t.length;x++){const C=t[x].animation.getKeys();Y>C[0].frame&&(Y=C[0].frame),d<C[C.length-1].frame&&(d=C[C.length-1].frame)}U._from=Y,U._to=d}return U}static ClipKeys(Y,d,t,x,C){const U=Y.clone(x||Y.name);return T.ClipKeysInPlace(U,d,t,C)}static ClipKeysInPlace(Y,d,t,x){return T.ClipInPlace(Y,d,t,x,!1)}static ClipFrames(Y,d,t,x,C){const U=Y.clone(x||Y.name);return T.ClipFramesInPlace(U,d,t,C)}static ClipFramesInPlace(Y,d,t,x){return T.ClipInPlace(Y,d,t,x,!0)}static ClipInPlace(Y,d,t,x){let C=arguments.length>4&&void 0!==arguments[4]&&arguments[4],U=Number.MAX_VALUE,y=-Number.MAX_VALUE;const B=Y.targetedAnimations;for(let W=0;W<B.length;W++){const Y=B[W],o=x?Y.animation:Y.animation.clone();C&&(o.createKeyForFrame(d),o.createKeyForFrame(t));const f=o.getKeys(),F=[];let D=Number.MAX_VALUE;for(let x=0;x<f.length;x++){const Y=f[x];if(!C&&x>=d&&x<=t||C&&Y.frame>=d&&Y.frame<=t){const d={frame:Y.frame,value:Y.value.clone?Y.value.clone():Y.value,inTangent:Y.inTangent,outTangent:Y.outTangent,interpolation:Y.interpolation,lockedTangent:Y.lockedTangent};D===Number.MAX_VALUE&&(D=d.frame),d.frame-=D,F.push(d)}}0!==F.length?(U>F[0].frame&&(U=F[0].frame),y<F[F.length-1].frame&&(y=F[F.length-1].frame),o.setKeys(F,!0),Y.animation=o):(B.splice(W,1),W--)}return Y._from=U,Y._to=y,Y}getClassName(){return"AnimationGroup"}toString(Y){let d="Name: "+this.name;return d+=", type: "+this.getClassName(),Y&&(d+=", from: "+this._from,d+=", to: "+this._to,d+=", isStarted: "+this._isStarted,d+=", speedRatio: "+this._speedRatio,d+=", targetedAnimations length: "+this._targetedAnimations.length,d+=", animatables length: "+this._animatables),d}}}}]);