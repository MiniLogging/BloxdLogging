"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[48],{13435:(K,Y,l)=>{l.r(Y),l.d(Y,{AnimationGroup:()=>n,TargetedAnimation:()=>J});var v=l(12456),U=l(469),d=l(526),A=l(635),c=l(12451),t=l(675);class Z{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(K,Y,l,U){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=Y,this._target=K,this._scene=l,this._host=U,this._activeTargets=[],Y._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===v.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=t.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const K={frame:0,value:this._minValue};this._keys.splice(0,0,K)}if(this._target instanceof Array){let K=0;for(const Y of this._target)this._preparePath(Y,K),this._getOriginalValues(K),K++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const d=Y.getEvents();d&&d.length>0&&d.forEach((K=>{this._events.push(K._clone())})),this._enableBlending=K&&K.animationPropertiesOverride?K.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(K){let Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const l=this._animation.targetPropertyPath;if(l.length>1){let v=K;for(let K=0;K<l.length-1;K++){const Y=l[K];if(v=v[Y],void 0===v)throw new Error(`Invalid property (${Y}) in property path (${l.join(".")})`)}this._targetPath=l[l.length-1],this._activeTargets[Y]=v}else this._targetPath=l[0],this._activeTargets[Y]=K;if(void 0===this._activeTargets[Y][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${l.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let K=0;for(const Y of this._target)void 0!==this._originalValue[K]&&this._setValue(Y,this._activeTargets[K],this._originalValue[K],-1,K),K++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let K=0;K<this._events.length;K++)this._events[K].isDone=!1}isStopped(){return this._stopped}dispose(){const K=this._animation.runtimeAnimations.indexOf(this);K>-1&&this._animation.runtimeAnimations.splice(K,1)}setValue(K,Y){if(this._targetIsArray)for(let l=0;l<this._target.length;l++){const v=this._target[l];this._setValue(v,this._activeTargets[l],K,Y,l)}else this._setValue(this._target,this._directTarget,K,Y,0)}_getOriginalValues(){let K,Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const l=this._activeTargets[Y];K=l.getLocalMatrix&&"_matrix"===this._targetPath?l.getLocalMatrix():l[this._targetPath],K&&K.clone?this._originalValue[Y]=K.clone():this._originalValue[Y]=K}_registerTargetForLateAnimationBinding(K,Y){const l=K.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(l),l._lateAnimationHolders||(l._lateAnimationHolders={}),l._lateAnimationHolders[K.targetPath]||(l._lateAnimationHolders[K.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:Y}),K.isAdditive?(l._lateAnimationHolders[K.targetPath].additiveAnimations.push(K),l._lateAnimationHolders[K.targetPath].totalAdditiveWeight+=K.weight):(l._lateAnimationHolders[K.targetPath].animations.push(K),l._lateAnimationHolders[K.targetPath].totalWeight+=K.weight)}_setValue(K,Y,l,U,d){if(this._currentActiveTarget=Y,this._weight=U,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const K=Y[this._targetPath];K.clone?this._originalBlendValue=K.clone():this._originalBlendValue=K}this._originalBlendValue.m?v.b.AllowMatrixDecomposeForInterpolation?this._currentValue?t.d.DecomposeLerpToRef(this._originalBlendValue,l,this._blendingFactor,this._currentValue):this._currentValue=t.d.DecomposeLerp(this._originalBlendValue,l,this._blendingFactor):this._currentValue?t.d.LerpToRef(this._originalBlendValue,l,this._blendingFactor,this._currentValue):this._currentValue=t.d.Lerp(this._originalBlendValue,l,this._blendingFactor):this._currentValue=v.b._UniversalLerp(this._originalBlendValue,l,this._blendingFactor);const U=K&&K.animationPropertiesOverride?K.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=U}else this._currentValue?this._currentValue.p?this._currentValue.p(l):this._currentValue=l:null!==l&&void 0!==l&&l.clone?this._currentValue=l.clone():this._currentValue=l;-1!==U?this._registerTargetForLateAnimationBinding(this,this._originalValue[d]):this._animationState.loopMode===v.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[d],Y[this._targetPath]):Y[this._targetPath]=this._originalValue[d]+this._currentValue:Y[this._targetPath]=this._currentValue,K.Mi&&K.Mi(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(K){let Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const l=this._animation.getKeys();K<l[0].frame?K=l[0].frame:K>l[l.length-1].frame&&(K=l[l.length-1].frame);const v=this._events;if(v.length)for(let d=0;d<v.length;d++)v[d].onlyOnce||(v[d].isDone=v[d].frame<K);this._currentFrame=K;const U=this._animation._interpolate(K,this._animationState);this.setValue(U,Y)}_prepareForSpeedRatioChange(K){const Y=this._previousElapsedTime*(this._animation.framePerSecond*K)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-Y}animate(K,Y,l,U,d){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const c=this._animation,t=c.targetPropertyPath;if(!t||t.length<1)return this._stopped=!0,!1;let Z=!0;(Y<this._minFrame||Y>this._maxFrame)&&(Y=this._minFrame),(l<this._minFrame||l>this._maxFrame)&&(l=this._maxFrame);const m=l-Y;let V,M=K*(c.framePerSecond*d)/1e3+this._absoluteFrameOffset,u=0,o=!1;const W=U&&this._animationState.loopMode===v.b.ANIMATIONLOOPMODE_YOYO;if(W){const K=(M-Y)/m,l=Math.sin(K*Math.PI);M=Math.abs(l)*m+Y;const v=l>=0?1:-1;this._yoyoDirection!==v&&(o=!0),this._yoyoDirection=v}if(this._previousElapsedTime=K,this._previousAbsoluteFrame=M,!U&&l>=Y&&(M>=m&&d>0||M<=0&&d<0))Z=!1,u=c._getKeyValue(this._maxValue);else if(!U&&Y>=l&&(M<=m&&d<0||M>=0&&d>0))Z=!1,u=c._getKeyValue(this._minValue);else if(this._animationState.loopMode!==v.b.ANIMATIONLOOPMODE_CYCLE){const K=l.toString()+Y.toString();if(!this._offsetsCache[K]){this._animationState.repeatCount=0,this._animationState.loopMode=v.b.ANIMATIONLOOPMODE_CYCLE;const U=c._interpolate(Y,this._animationState),d=c._interpolate(l,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),c.dataType){case v.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[K]=d-U;break;case v.b.ANIMATIONTYPE_QUATERNION:case v.b.ANIMATIONTYPE_VECTOR3:case v.b.ANIMATIONTYPE_VECTOR2:case v.b.ANIMATIONTYPE_SIZE:case v.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[K]=d.Lg(U)}this._highLimitsCache[K]=d}u=this._highLimitsCache[K],V=this._offsetsCache[K]}if(void 0===V)switch(c.dataType){case v.b.ANIMATIONTYPE_FLOAT:V=0;break;case v.b.ANIMATIONTYPE_QUATERNION:V=v.i;break;case v.b.ANIMATIONTYPE_VECTOR3:V=v.s;break;case v.b.ANIMATIONTYPE_VECTOR2:V=v.p;break;case v.b.ANIMATIONTYPE_SIZE:V=v.m;break;case v.b.ANIMATIONTYPE_COLOR3:V=v.d;break;case v.b.ANIMATIONTYPE_COLOR4:V=v.e}let g;if(this._host&&this._host.syncRoot){const K=this._host.syncRoot;g=Y+m*((K.masterFrame-K.fromFrame)/(K.toFrame-K.fromFrame))}else g=M>0&&Y>l||M<0&&Y<l?Z&&0!==m?l+M%m:Y:Z&&0!==m?Y+M%m:l;const J=this._events;if(!W&&(d>0&&this.currentFrame>g||d<0&&this.currentFrame<g)||W&&o){this._onLoop();for(let K=0;K<J.length;K++)J[K].onlyOnce||(J[K].isDone=!1);this._animationState.key=d>0?0:c.getKeys().length-1}this._currentFrame=g,this._animationState.repeatCount=0===m?0:M/m|0,this._animationState.highLimitValue=u,this._animationState.offsetValue=V;const n=c._interpolate(g,this._animationState);if(this.setValue(n,A),J.length)for(let v=0;v<J.length;v++)if(m>=0&&g>=J[v].frame&&J[v].frame>=Y||m<0&&g<=J[v].frame&&J[v].frame<=Y){const K=J[v];K.isDone||(K.onlyOnce&&(J.splice(v,1),v--),K.isDone=!0,K.action(g))}return Z||(this._stopped=!0),Z}}var m=l(508);class V{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(K){this._weight=-1!==K?Math.min(Math.max(K,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(K){for(let Y=0;Y<this._runtimeAnimations.length;Y++){this._runtimeAnimations[Y]._prepareForSpeedRatioChange(K)}this._speedRatio=K,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(K,Y){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,d=arguments.length>4&&void 0!==arguments[4]&&arguments[4],A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,c=arguments.length>6?arguments[6]:void 0,t=arguments.length>7?arguments[7]:void 0,Z=arguments.length>8?arguments[8]:void 0,m=arguments.length>9&&void 0!==arguments[9]&&arguments[9],V=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=Y,this.fromFrame=l,this.toFrame=v,this.loopAnimation=d,this.onAnimationEnd=c,this.onAnimationLoop=Z,this.isAdditive=m,this.playOrder=V,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Kk=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new U.b,this.onAnimationLoopObservable=new U.b,this._scene=K,t&&this.appendAnimations(Y,t),this._speedRatio=A,K._activeAnimatables.push(this)}syncWith(K){if(this._syncRoot=K,K){const K=this._scene._activeAnimatables.indexOf(this);K>-1&&(this._scene._activeAnimatables.splice(K,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(K,Y){for(let l=0;l<Y.length;l++){const v=Y[l],U=new Z(K,v,this._scene,this);U._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(U)}}getAnimationByTargetProperty(K){const Y=this._runtimeAnimations;for(let l=0;l<Y.length;l++)if(Y[l].animation.targetProperty===K)return Y[l].animation;return null}getRuntimeAnimationByTargetProperty(K){const Y=this._runtimeAnimations;for(let l=0;l<Y.length;l++)if(Y[l].animation.targetProperty===K)return Y[l];return null}reset(){const K=this._runtimeAnimations;for(let Y=0;Y<K.length;Y++)K[Y].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(K){const Y=this._runtimeAnimations;for(let l=0;l<Y.length;l++)Y[l].animation.enableBlending=!0,Y[l].animation.blendingSpeed=K}disableBlending(){const K=this._runtimeAnimations;for(let Y=0;Y<K.length;Y++)K[Y].animation.enableBlending=!1}goToFrame(K){const Y=this._runtimeAnimations;if(Y[0]){const l=Y[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??Y[0].currentFrame;const v=0===this.speedRatio?0:(K-this._frameToSyncFromJump)/l*1e3/this.speedRatio;this._manualJumpDelay=-v}for(let l=0;l<Y.length;l++)Y[l].goToFrame(K,this._weight);this._goToFrame=K}get paused(){return this.Kk}pause(){this.Kk||(this.Kk=!0)}restart(){this.Kk=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(K,Y){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],v=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(K||Y){const U=this._scene._activeAnimatables.indexOf(this);if(U>-1){const d=this._runtimeAnimations;for(let l=d.length-1;l>=0;l--){const v=d[l];K&&v.animation.name!=K||(Y&&!Y(v.target)||(v.dispose(),d.splice(l,1)))}0==d.length&&(l||this._scene._activeAnimatables.splice(U,1),v||this._raiseOnAnimationEnd())}}else{const K=this._scene._activeAnimatables.indexOf(this);if(K>-1){l||this._scene._activeAnimatables.splice(K,1);const Y=this._runtimeAnimations;for(let K=0;K<Y.length;K++)Y[K].dispose();this._runtimeAnimations.length=0,v||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((K=>{this.onAnimationEndObservable.add((()=>{K(this)}),void 0,void 0,this,!0)}))}_animate(K){if(this.Kk)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=K),!0;if(null===this._localDelayOffset?(this._localDelayOffset=K,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=K-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let Y=!1;const l=this._runtimeAnimations;let v;for(v=0;v<l.length;v++){const U=l[v].animate(K-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);Y=Y||U}if(this.animationStarted=Y,!Y){if(this.disposeOnEnd)for(v=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(v,1),v=0;v<l.length;v++)l[v].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return Y}}function M(K){if(0===K.totalWeight&&0===K.totalAdditiveWeight)return K.originalValue;let Y=1;const l=t.j.Qi[0],v=t.j.Qi[1],U=t.j.Quaternion[0];let d=0;const A=K.animations[0],c=K.originalValue;let Z=1,m=!1;if(K.totalWeight<1)Z=1-K.totalWeight,c.decompose(v,U,l);else{if(d=1,Y=K.totalWeight,Z=A.weight/Y,1==Z){if(!K.totalAdditiveWeight)return A.currentValue;m=!0}A.currentValue.decompose(v,U,l)}if(!m){v.scaleInPlace(Z),l.scaleInPlace(Z),U.scaleInPlace(Z);for(let A=d;A<K.animations.length;A++){const d=K.animations[A];if(0===d.weight)continue;Z=d.weight/Y;const c=t.j.Qi[2],m=t.j.Qi[3],V=t.j.Quaternion[1];d.currentValue.decompose(m,V,c),m.scaleAndAddToRef(Z,v),V.scaleAndAddToRef(t.h.Dot(U,V)>0?Z:-Z,U),c.scaleAndAddToRef(Z,l)}U.normalize()}for(let M=0;M<K.additiveAnimations.length;M++){const Y=K.additiveAnimations[M];if(0===Y.weight)continue;const d=t.j.Qi[2],A=t.j.Qi[3],c=t.j.Quaternion[1];Y.currentValue.decompose(A,c,d),A.multiplyToRef(v,A),t.o.LerpToRef(v,A,Y.weight,v),U.multiplyToRef(c,c),t.h.SlerpToRef(U,c,Y.weight,U),d.scaleAndAddToRef(Y.weight,l)}const V=A?A._animationState.workValue:t.j.Matrix[0].clone();return t.d.ComposeToRef(v,U,l,V),V}function u(K,Y){if(0===K.totalWeight&&0===K.totalAdditiveWeight)return Y;const l=K.animations[0],v=K.originalValue;let U=Y;if(0===K.totalWeight&&K.totalAdditiveWeight>0)U.p(v);else if(1===K.animations.length){if(t.h.SlerpToRef(v,l.currentValue,Math.min(1,K.totalWeight),U),0===K.totalAdditiveWeight)return U}else if(K.animations.length>1){let l,d,A=1;if(K.totalWeight<1){const Y=1-K.totalWeight;l=[],d=[],l.push(v),d.push(Y)}else{if(2===K.animations.length&&(t.h.SlerpToRef(K.animations[0].currentValue,K.animations[1].currentValue,K.animations[1].weight/K.totalWeight,Y),0===K.totalAdditiveWeight))return Y;l=[],d=[],A=K.totalWeight}for(let Y=0;Y<K.animations.length;Y++){const v=K.animations[Y];l.push(v.currentValue),d.push(v.weight/A)}let c=0;for(let K=0;K<l.length;)K?(c+=d[K],t.h.SlerpToRef(U,l[K],d[K]/c,U),K++):(t.h.SlerpToRef(l[K],l[K+1],d[K+1]/(d[K]+d[K+1]),Y),U=Y,c=d[K]+d[K+1],K+=2)}for(let d=0;d<K.additiveAnimations.length;d++){const Y=K.additiveAnimations[d];0!==Y.weight&&(U.multiplyToRef(Y.currentValue,t.j.Quaternion[0]),t.h.SlerpToRef(U,t.j.Quaternion[0],Y.weight,U))}return U}var o,W,g=l(2366);o=g.b,(W=c.e)&&(W.prototype.copyAnimationRange=function(K,Y,l){let U=arguments.length>3&&void 0!==arguments[3]&&arguments[3],d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new v.b(this.name,"_matrix",K.animations[0].framePerSecond,v.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const A=K.animations[0].getRange(Y);if(!A)return!1;const c=A.from,t=A.to,Z=K.animations[0].getKeys(),m=K.length,V=K.getParent(),M=this.getParent(),u=U&&V&&m&&this.length&&m!==this.length,o=u&&M&&V?M.length/V.length:1,W=U&&!M&&d&&(1!==d.x||1!==d.y||1!==d.z),g=this.animations[0].getKeys();let J,n,R;for(let v=0,H=Z.length;v<H;v++)J=Z[v],J.frame>=c&&J.frame<=t&&(U?(R=J.value.clone(),u?(n=R.getTranslation(),R.setTranslation(n.scaleInPlace(o))):W&&d?(n=R.getTranslation(),R.setTranslation(n.multiplyInPlace(d))):R=J.value):R=J.value,g.push({frame:J.frame+l,value:R}));return this.animations[0].createRange(Y,c+l,t+l),!0}),o&&(o.prototype._animate=function(K){if(!this.animationsEnabled)return;const Y=m.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=Y}this.deltaTime=void 0!==K?K:this.useConstantAnimationDeltaTime?16:(Y-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=Y;const l=this._activeAnimatables;if(0===l.length)return;this._animationTime+=this.deltaTime;const U=this._animationTime;for(let v=0;v<l.length;v++){const K=l[v];!K._animate(U)&&K.disposeOnEnd&&v--}!function(K){if(K._registeredForLateAnimationBindings.length){for(let Y=0;Y<K._registeredForLateAnimationBindings.length;Y++){const l=K._registeredForLateAnimationBindings.data[Y];for(const K in l._lateAnimationHolders){const Y=l._lateAnimationHolders[K],U=Y.animations[0],d=Y.originalValue;if(void 0===d||null===d)continue;const A=v.b.AllowMatrixDecomposeForInterpolation&&d.m;let c=l[K];if(A)c=M(Y);else if(void 0!==d.w)c=u(Y,c||t.h.Identity());else{let K=0,l=1;const A=U&&U._animationState.loopMode===v.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(Y.totalWeight<1)c=A?d.clone?d.clone():d:U&&d.scale?d.scale(1-Y.totalWeight):U?d*(1-Y.totalWeight):d.clone?d.clone():d;else if(U){l=Y.totalWeight;const v=U.weight/l;c=1!==v?U.currentValue.scale?U.currentValue.scale(v):U.currentValue*v:U.currentValue,A&&(c.addToRef?c.addToRef(d,c):c+=d),K=1}for(let v=K;v<Y.animations.length;v++){const K=Y.animations[v],U=K.weight/l;U&&(K.currentValue.scaleAndAddToRef?K.currentValue.scaleAndAddToRef(U,c):c+=K.currentValue*U)}for(let v=0;v<Y.additiveAnimations.length;v++){const K=Y.additiveAnimations[v],l=K.weight;l&&(K.currentValue.scaleAndAddToRef?K.currentValue.scaleAndAddToRef(l,c):c+=K.currentValue*l)}}l[K]=c}l._lateAnimationHolders={}}K._registeredForLateAnimationBindings.reset()}}(this)},o.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((K,Y)=>K.playOrder-Y.playOrder))},o.prototype.beginWeightedAnimation=function(K,Y,l){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,U=arguments.length>4?arguments[4]:void 0,d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,c=arguments.length>7?arguments[7]:void 0,t=arguments.length>8?arguments[8]:void 0,Z=arguments.length>9?arguments[9]:void 0,m=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const V=this.beginAnimation(K,Y,l,U,d,A,c,!1,t,Z,m);return V.weight=v,V},o.prototype.beginAnimation=function(K,Y,l,v){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,d=arguments.length>5?arguments[5]:void 0,A=arguments.length>6?arguments[6]:void 0,c=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],t=arguments.length>8?arguments[8]:void 0,Z=arguments.length>9?arguments[9]:void 0,m=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(U<0){const K=Y;Y=l,l=K,U=-U}Y>l&&(U=-U),c&&this.stopAnimation(K,void 0,t),A||(A=new V(this,K,Y,l,v,U,d,void 0,Z,m));const M=!t||t(K);if(K.animations&&M&&A.appendAnimations(K,K.animations),K.getAnimatables){const m=K.getAnimatables();for(let K=0;K<m.length;K++)this.beginAnimation(m[K],Y,l,v,U,d,A,c,t,Z)}return A.reset(),A},o.prototype.beginHierarchyAnimation=function(K,Y,l,v,U){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,c=arguments.length>7?arguments[7]:void 0,t=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],Z=arguments.length>9?arguments[9]:void 0,m=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const V=K.getDescendants(Y),M=[];M.push(this.beginAnimation(K,l,v,U,d,A,c,t,Z,void 0,m));for(const u of V)M.push(this.beginAnimation(u,l,v,U,d,A,c,t,Z,void 0,m));return M},o.prototype.beginDirectAnimation=function(K,Y,l,v,U){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(d<0){const K=l;l=v,v=K,d=-d}return l>v&&(d=-d),new V(this,K,l,v,U,d,arguments.length>6?arguments[6]:void 0,Y,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},o.prototype.beginDirectHierarchyAnimation=function(K,Y,l,v,U,d,A,c,t){let Z=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const m=K.getDescendants(Y),V=[];V.push(this.beginDirectAnimation(K,l,v,U,d,A,c,t,Z));for(const M of m)V.push(this.beginDirectAnimation(M,l,v,U,d,A,c,t,Z));return V},o.prototype.getAnimatableByTarget=function(K){for(let Y=0;Y<this._activeAnimatables.length;Y++)if(this._activeAnimatables[Y].target===K)return this._activeAnimatables[Y];return null},o.prototype.getAllAnimatablesByTarget=function(K){const Y=[];for(let l=0;l<this._activeAnimatables.length;l++)this._activeAnimatables[l].target===K&&Y.push(this._activeAnimatables[l]);return Y},o.prototype.stopAnimation=function(K,Y,l){const v=this.getAllAnimatablesByTarget(K);for(const U of v)U.stop(Y,l)},o.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let K=0;K<this._activeAnimatables.length;K++)this._activeAnimatables[K].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const K of this.animationGroups)K.stop()});class J{getClassName(){return"TargetedAnimation"}serialize(){const K={};return K.animation=this.animation.serialize(),K.targetId=this.target.id,K}}class n{get mask(){return this._mask}set mask(K){this._mask!==K&&(this._mask=K,this.syncWithMask(!0))}syncWithMask(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||K){this._numActiveAnimatables=0;for(let K=0;K<this._animatables.length;++K){const Y=this._animatables[K];!this.mask||this.mask.disabled||this.mask.retainsTarget(Y.target.name)?(this._numActiveAnimatables++,Y.paused&&Y.restart()):Y.paused||Y.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let K=0;K<this._animatables.length;++K){const Y=this._animatables[K];this.mask.retainsTarget(Y.target.name)||(Y.stop(),this._animatables.splice(K,1),--K)}for(let K=0;K<this._targetedAnimations.length;K++){const Y=this._targetedAnimations[K];this.mask.retainsTarget(Y.target.name)||(this._targetedAnimations.splice(K,1),--K)}}}get from(){return this._from}set from(K){if(this._from!==K){this._from=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].fromFrame=this._from}}}get to(){return this._to}set to(K){if(this._to!==K){this._to=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(K){if(this._speedRatio!==K){this._speedRatio=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(K){if(this._loopAnimation!==K){this._loopAnimation=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(K){if(this._isAdditive!==K){this._isAdditive=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(K){this._weight!==K&&(this._weight=K,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(K){if(this._playOrder!==K&&(this._playOrder=K,this._animatables.length>0)){for(let K=0;K<this._animatables.length;K++)this._animatables[K].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(K){if(this._enableBlending!==K&&(this._enableBlending=K,null!==K))for(let Y=0;Y<this._targetedAnimations.length;++Y)this._targetedAnimations[Y].animation.enableBlending=K}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(K){if(this._blendingSpeed!==K&&(this._blendingSpeed=K,null!==K))for(let Y=0;Y<this._targetedAnimations.length;++Y)this._targetedAnimations[Y].animation.blendingSpeed=K}getLength(K,Y){K=K??this._from;return((Y=Y??this._to)-K)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(K){let Y=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],v=arguments.length>3?arguments[3]:void 0;if(0===K.length)return null;v=v??K[0].weight;let U=Number.MAX_VALUE,d=-Number.MAX_VALUE;if(l)for(const c of K)c.from<U&&(U=c.from),c.to>d&&(d=c.to);const A=new n(K[0].name+"_merged",K[0]._scene,v);for(const c of K){l&&c.normalize(U,d);for(const K of c.targetedAnimations)A.addTargetedAnimation(K.animation,K.target);Y&&c.dispose()}return A}constructor(K){let Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=K,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new U.b,this.onAnimationLoopObservable=new U.b,this.onAnimationGroupLoopObservable=new U.b,this.onAnimationGroupEndObservable=new U.b,this.onAnimationGroupPauseObservable=new U.b,this.onAnimationGroupPlayObservable=new U.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=Y||d.e.LastCreatedScene,this._weight=l,this._playOrder=v,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(K,Y){const l=new J;l.animation=K,l.target=Y;const v=K.getKeys();return this._from>v[0].frame&&(this._from=v[0].frame),this._to<v[v.length-1].frame&&(this._to=v[v.length-1].frame),null!==this._enableBlending&&(K.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(K.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(l),this._shouldStart=!0,l}removeTargetedAnimation(K){for(let Y=this._targetedAnimations.length-1;Y>-1;Y--){this._targetedAnimations[Y].animation===K&&this._targetedAnimations.splice(Y,1)}}normalize(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==K&&(K=this._from),null==Y&&(Y=this._to);for(let l=0;l<this._targetedAnimations.length;l++){const v=this._targetedAnimations[l].animation.getKeys(),U=v[0],d=v[v.length-1];if(U.frame>K){const Y={frame:K,value:U.value,inTangent:U.inTangent,outTangent:U.outTangent,interpolation:U.interpolation};v.splice(0,0,Y)}if(d.frame<Y){const K={frame:Y,value:d.value,inTangent:d.inTangent,outTangent:d.outTangent,interpolation:d.interpolation};v.push(K)}}return this._from=K,this._to=Y,this}_processLoop(K,Y,l){K.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(Y),this._animationLoopFlags[l]||(this._animationLoopFlags[l]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0],Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,l=arguments.length>2?arguments[2]:void 0,v=arguments.length>3?arguments[3]:void 0,U=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=K,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let d=0;d<this._targetedAnimations.length;d++){const A=this._targetedAnimations[d],c=this._scene.beginDirectAnimation(A.target,[A.animation],void 0!==l?l:this._from,void 0!==v?v:this._to,K,Y,void 0,void 0,void 0!==U?U:this._isAdditive);c.weight=this._weight,c.playOrder=this._playOrder,c.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(A),this._checkAnimationGroupEnded(c)},this._processLoop(c,A,d),this._animatables.push(c)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=Y,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let K=0;K<this._animatables.length;K++){this._animatables[K].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(K){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==K&&(this.loopAnimation=K),this.restart()):(this.stop(),this.start(K,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let K=0;K<this._animatables.length;K++){this._animatables[K].reset()}return this}restart(){if(!this._isStarted)return this;for(let K=0;K<this._animatables.length;K++){this._animatables[K].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const Y=this._animatables.slice();for(let v=0;v<Y.length;v++)Y[v].stop(void 0,void 0,!0,K);let l=0;for(let v=0;v<this._scene._activeAnimatables.length;v++){const Y=this._scene._activeAnimatables[v];Y._runtimeAnimations.length>0?this._scene._activeAnimatables[l++]=Y:K&&this._checkAnimationGroupEnded(Y,K)}return this._scene._activeAnimatables.length=l,this._isStarted=!1,this}setWeightForAllAnimatables(K){for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].weight=K}return this}syncAllAnimationsWith(K){for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].syncWith(K)}return this}goToFrame(K){if(!this._isStarted)return this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].goToFrame(K)}return this}getCurrentFrame(){var K;return(null===(K=this.animatables[0])||void 0===K?void 0:K.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const K=this._scene.animationGroups.indexOf(this);if(K>-1&&this._scene.animationGroups.splice(K,1),this._parentContainer){const K=this._parentContainer.animationGroups.indexOf(this);K>-1&&this._parentContainer.animationGroups.splice(K,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(K){let Y=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const l=this._animatables.indexOf(K);l>-1&&this._animatables.splice(l,1),0===this._animatables.length&&(this._isStarted=!1,Y||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(K,Y){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const v=new n(K||this.name,this._scene,this._weight,this._playOrder);v._from=this.from,v._to=this.to,v._speedRatio=this.speedRatio,v._loopAnimation=this.loopAnimation,v._isAdditive=this.isAdditive,v._enableBlending=this.enableBlending,v._blendingSpeed=this.blendingSpeed,v.metadata=this.metadata,v.mask=this.mask;for(const U of this._targetedAnimations)v.addTargetedAnimation(l?U.animation.clone():U.animation,Y?Y(U.target):U.target);return v}serialize(){const K={};K.name=this.name,K.from=this.from,K.to=this.to,K.speedRatio=this.speedRatio,K.loopAnimation=this.loopAnimation,K.isAdditive=this.isAdditive,K.weight=this.weight,K.playOrder=this.playOrder,K.enableBlending=this.enableBlending,K.blendingSpeed=this.blendingSpeed,K.targetedAnimations=[];for(let Y=0;Y<this.targetedAnimations.length;Y++){const l=this.targetedAnimations[Y];K.targetedAnimations[Y]=l.serialize()}return A.c&&A.c.HasTags(this)&&(K.tags=A.c.GetTags(this)),this.metadata&&(K.metadata=this.metadata),K}static Parse(K,Y){const l=new n(K.name,Y,K.weight,K.playOrder);for(let U=0;U<K.targetedAnimations.length;U++){const d=K.targetedAnimations[U],A=v.b.Parse(d.animation),c=d.targetId;if("influence"===d.animation.property){const K=Y.getMorphTargetById(c);K&&l.addTargetedAnimation(A,K)}else{const K=Y.getNodeById(c);null!=K&&l.addTargetedAnimation(A,K)}}return A.c&&A.c.AddTagsTo(l,K.tags),null!==K.from&&null!==K.to&&l.normalize(K.from,K.to),void 0!==K.speedRatio&&(l._speedRatio=K.speedRatio),void 0!==K.loopAnimation&&(l._loopAnimation=K.loopAnimation),void 0!==K.isAdditive&&(l._isAdditive=K.isAdditive),void 0!==K.weight&&(l._weight=K.weight),void 0!==K.playOrder&&(l._playOrder=K.playOrder),void 0!==K.enableBlending&&(l._enableBlending=K.enableBlending),void 0!==K.blendingSpeed&&(l._blendingSpeed=K.blendingSpeed),void 0!==K.metadata&&(l.metadata=K.metadata),l}static MakeAnimationAdditive(K,Y,l){let U;U="object"===typeof Y?Y:{referenceFrame:Y,range:l,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let d=K;U.cloneOriginalAnimationGroup&&(d=K.clone(U.clonedAnimationGroupName||d.name));const A=d.targetedAnimations;for(let c=0;c<A.length;c++){const K=A[c];K.animation=v.b.MakeAnimationAdditive(K.animation,U)}if(d.isAdditive=!0,U.clipKeys){let K=Number.MAX_VALUE,Y=-Number.MAX_VALUE;const l=d.targetedAnimations;for(let v=0;v<l.length;v++){const U=l[v].animation.getKeys();K>U[0].frame&&(K=U[0].frame),Y<U[U.length-1].frame&&(Y=U[U.length-1].frame)}d._from=K,d._to=Y}return d}static ClipKeys(K,Y,l,v,U){const d=K.clone(v||K.name);return n.ClipKeysInPlace(d,Y,l,U)}static ClipKeysInPlace(K,Y,l,v){return n.ClipInPlace(K,Y,l,v,!1)}static ClipFrames(K,Y,l,v,U){const d=K.clone(v||K.name);return n.ClipFramesInPlace(d,Y,l,U)}static ClipFramesInPlace(K,Y,l,v){return n.ClipInPlace(K,Y,l,v,!0)}static ClipInPlace(K,Y,l,v){let U=arguments.length>4&&void 0!==arguments[4]&&arguments[4],d=Number.MAX_VALUE,A=-Number.MAX_VALUE;const c=K.targetedAnimations;for(let t=0;t<c.length;t++){const K=c[t],Z=v?K.animation:K.animation.clone();U&&(Z.createKeyForFrame(Y),Z.createKeyForFrame(l));const m=Z.getKeys(),V=[];let M=Number.MAX_VALUE;for(let v=0;v<m.length;v++){const K=m[v];if(!U&&v>=Y&&v<=l||U&&K.frame>=Y&&K.frame<=l){const Y={frame:K.frame,value:K.value.clone?K.value.clone():K.value,inTangent:K.inTangent,outTangent:K.outTangent,interpolation:K.interpolation,lockedTangent:K.lockedTangent};M===Number.MAX_VALUE&&(M=Y.frame),Y.frame-=M,V.push(Y)}}0!==V.length?(d>V[0].frame&&(d=V[0].frame),A<V[V.length-1].frame&&(A=V[V.length-1].frame),Z.setKeys(V,!0),K.animation=Z):(c.splice(t,1),t--)}return K._from=d,K._to=A,K}getClassName(){return"AnimationGroup"}toString(K){let Y="Name: "+this.name;return Y+=", type: "+this.getClassName(),K&&(Y+=", from: "+this._from,Y+=", to: "+this._to,Y+=", isStarted: "+this._isStarted,Y+=", speedRatio: "+this._speedRatio,Y+=", targetedAnimations length: "+this._targetedAnimations.length,Y+=", animatables length: "+this._animatables),Y}}}}]);