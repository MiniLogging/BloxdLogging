"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[92],{14202:(P,Q,O)=>{O.r(Q),O.d(Q,{EasingFunctionType:()=>b,FlowGraphEasingBlock:()=>R});var b,F=O(13123),g=O(12885),m=O(12871),q=O(696);!function(P){P[P.CircleEase=0]="CircleEase",P[P.BackEase=1]="BackEase",P[P.BounceEase=2]="BounceEase",P[P.CubicEase=3]="CubicEase",P[P.ElasticEase=4]="ElasticEase",P[P.ExponentialEase=5]="ExponentialEase",P[P.PowerEase=6]="PowerEase",P[P.QuadraticEase=7]="QuadraticEase",P[P.QuarticEase=8]="QuarticEase",P[P.QuinticEase=9]="QuinticEase",P[P.SineEase=10]="SineEase",P[P.BezierCurveEase=11]="BezierCurveEase"}(b||(b={}));class R extends g.c{constructor(P){super(P),this.config=P,this._easingFunctions={},this.type=this.registerDataInput("type",m.d,11),this.mode=this.registerDataInput("mode",m.o,0),this.parameters=this.registerDataInput("parameters",m.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",m.d)}_updateOutputs(P){const Q=this.type.getValue(P),O=this.mode.getValue(P),b=this.parameters.getValue(P);if(void 0===Q||void 0===O)return;const g=`${Q}-${O}-${b.join("-")}`;if(!this._easingFunctions[g]){const P=function(P){for(var Q=arguments.length,O=new Array(Q>1?Q-1:0),b=1;b<Q;b++)O[b-1]=arguments[b];switch(P){case 11:return new F.f(...O);case 0:return new F.l;case 1:return new F.b(...O);case 2:return new F.h(...O);case 3:return new F.p;case 4:return new F.s(...O);case 5:return new F.w(...O);default:throw new Error("Easing type not yet implemented")}}(Q,...b);P.setEasingMode(O),this._easingFunctions[g]=P}this.easingFunction.setValue(this._easingFunctions[g],P)}getClassName(){return"FlowGraphEasingBlock"}}(0,q.f)("FlowGraphEasingBlock",R)}}]);