"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[92],{14037:(J,T,b)=>{b.r(T),b.d(T,{EasingFunctionType:()=>q,FlowGraphEasingBlock:()=>C});var q,t=b(12855),j=b(12627),B=b(12603),Y=b(639);!function(J){J[J.CircleEase=0]="CircleEase",J[J.BackEase=1]="BackEase",J[J.BounceEase=2]="BounceEase",J[J.CubicEase=3]="CubicEase",J[J.ElasticEase=4]="ElasticEase",J[J.ExponentialEase=5]="ExponentialEase",J[J.PowerEase=6]="PowerEase",J[J.QuadraticEase=7]="QuadraticEase",J[J.QuarticEase=8]="QuarticEase",J[J.QuinticEase=9]="QuinticEase",J[J.SineEase=10]="SineEase",J[J.BezierCurveEase=11]="BezierCurveEase"}(q||(q={}));class C extends j.b{constructor(J){super(J),this.config=J,this._easingFunctions={},this.type=this.registerDataInput("type",B.c,11),this.mode=this.registerDataInput("mode",B.r,0),this.parameters=this.registerDataInput("parameters",B.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",B.c)}_updateOutputs(J){const T=this.type.getValue(J),b=this.mode.getValue(J),q=this.parameters.getValue(J);if(void 0===T||void 0===b)return;const j=`${T}-${b}-${q.join("-")}`;if(!this._easingFunctions[j]){const J=function(J){for(var T=arguments.length,b=new Array(T>1?T-1:0),q=1;q<T;q++)b[q-1]=arguments[q];switch(J){case 11:return new t.f(...b);case 0:return new t.j;case 1:return new t.b(...b);case 2:return new t.g(...b);case 3:return new t.l;case 4:return new t.p(...b);case 5:return new t.r(...b);default:throw new Error("Easing type not yet implemented")}}(T,...q);J.setEasingMode(b),this._easingFunctions[j]=J}this.easingFunction.setValue(this._easingFunctions[j],J)}getClassName(){return"FlowGraphEasingBlock"}}(0,Y.g)("FlowGraphEasingBlock",C)}}]);