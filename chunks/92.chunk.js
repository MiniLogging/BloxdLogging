"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[92],{13925:(W,F,c)=>{c.r(F),c.d(F,{EasingFunctionType:()=>T,FlowGraphEasingBlock:()=>u});var T,Y=c(12777),Z=c(12543),w=c(12517),A=c(642);!function(W){W[W.CircleEase=0]="CircleEase",W[W.BackEase=1]="BackEase",W[W.BounceEase=2]="BounceEase",W[W.CubicEase=3]="CubicEase",W[W.ElasticEase=4]="ElasticEase",W[W.ExponentialEase=5]="ExponentialEase",W[W.PowerEase=6]="PowerEase",W[W.QuadraticEase=7]="QuadraticEase",W[W.QuarticEase=8]="QuarticEase",W[W.QuinticEase=9]="QuinticEase",W[W.SineEase=10]="SineEase",W[W.BezierCurveEase=11]="BezierCurveEase"}(T||(T={}));class u extends Z.d{constructor(W){super(W),this.config=W,this._easingFunctions={},this.type=this.registerDataInput("type",w.c,11),this.mode=this.registerDataInput("mode",w.n,0),this.parameters=this.registerDataInput("parameters",w.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",w.c)}_updateOutputs(W){const F=this.type.getValue(W),c=this.mode.getValue(W),T=this.parameters.getValue(W);if(void 0===F||void 0===c)return;const Z=`${F}-${c}-${T.join("-")}`;if(!this._easingFunctions[Z]){const W=function(W){for(var F=arguments.length,c=new Array(F>1?F-1:0),T=1;T<F;T++)c[T-1]=arguments[T];switch(W){case 11:return new Y.h(...c);case 0:return new Y.p;case 1:return new Y.d(...c);case 2:return new Y.l(...c);case 3:return new Y.s;case 4:return new Y.z(...c);case 5:return new Y.B(...c);default:throw new Error("Easing type not yet implemented")}}(F,...T);W.setEasingMode(c),this._easingFunctions[Z]=W}this.easingFunction.setValue(this._easingFunctions[Z],W)}getClassName(){return"FlowGraphEasingBlock"}}(0,A.h)("FlowGraphEasingBlock",u)}}]);