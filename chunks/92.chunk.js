"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[92],{14321:(u,F,z)=>{z.r(F),z.d(F,{EasingFunctionType:()=>p,FlowGraphEasingBlock:()=>G});var p,b=z(13201),R=z(12980),c=z(12952),I=z(668);!function(u){u[u.CircleEase=0]="CircleEase",u[u.BackEase=1]="BackEase",u[u.BounceEase=2]="BounceEase",u[u.CubicEase=3]="CubicEase",u[u.ElasticEase=4]="ElasticEase",u[u.ExponentialEase=5]="ExponentialEase",u[u.PowerEase=6]="PowerEase",u[u.QuadraticEase=7]="QuadraticEase",u[u.QuarticEase=8]="QuarticEase",u[u.QuinticEase=9]="QuinticEase",u[u.SineEase=10]="SineEase",u[u.BezierCurveEase=11]="BezierCurveEase"}(p||(p={}));class G extends R.d{constructor(u){super(u),this.config=u,this._easingFunctions={},this.type=this.registerDataInput("type",c.e,11),this.mode=this.registerDataInput("mode",c.t,0),this.parameters=this.registerDataInput("parameters",c.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",c.e)}_updateOutputs(u){const F=this.type.getValue(u),z=this.mode.getValue(u),p=this.parameters.getValue(u);if(void 0===F||void 0===z)return;const R=`${F}-${z}-${p.join("-")}`;if(!this._easingFunctions[R]){const u=function(u){for(var F=arguments.length,z=new Array(F>1?F-1:0),p=1;p<F;p++)z[p-1]=arguments[p];switch(u){case 11:return new b.g(...z);case 0:return new b.j;case 1:return new b.e(...z);case 2:return new b.i(...z);case 3:return new b.l;case 4:return new b.o(...z);case 5:return new b.p(...z);default:throw new Error("Easing type not yet implemented")}}(F,...p);u.setEasingMode(z),this._easingFunctions[R]=u}this.easingFunction.setValue(this._easingFunctions[R],u)}getClassName(){return"FlowGraphEasingBlock"}}(0,I.h)("FlowGraphEasingBlock",G)}}]);