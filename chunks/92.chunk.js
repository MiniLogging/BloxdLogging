"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[92],{14209:(n,k,T)=>{T.r(k),T.d(k,{EasingFunctionType:()=>c,FlowGraphEasingBlock:()=>E});var c,K=T(13084),Q=T(12845),G=T(12831),w=T(675);!function(n){n[n.CircleEase=0]="CircleEase",n[n.BackEase=1]="BackEase",n[n.BounceEase=2]="BounceEase",n[n.CubicEase=3]="CubicEase",n[n.ElasticEase=4]="ElasticEase",n[n.ExponentialEase=5]="ExponentialEase",n[n.PowerEase=6]="PowerEase",n[n.QuadraticEase=7]="QuadraticEase",n[n.QuarticEase=8]="QuarticEase",n[n.QuinticEase=9]="QuinticEase",n[n.SineEase=10]="SineEase",n[n.BezierCurveEase=11]="BezierCurveEase"}(c||(c={}));class E extends Q.b{constructor(n){super(n),this.config=n,this._easingFunctions={},this.type=this.registerDataInput("type",G.e,11),this.mode=this.registerDataInput("mode",G.w,0),this.parameters=this.registerDataInput("parameters",G.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",G.e)}_updateOutputs(n){const k=this.type.getValue(n),T=this.mode.getValue(n),c=this.parameters.getValue(n);if(void 0===k||void 0===T)return;const Q=`${k}-${T}-${c.join("-")}`;if(!this._easingFunctions[Q]){const n=function(n){for(var k=arguments.length,T=new Array(k>1?k-1:0),c=1;c<k;c++)T[c-1]=arguments[c];switch(n){case 11:return new K.e(...T);case 0:return new K.i;case 1:return new K.c(...T);case 2:return new K.f(...T);case 3:return new K.k;case 4:return new K.m(...T);case 5:return new K.q(...T);default:throw new Error("Easing type not yet implemented")}}(k,...c);n.setEasingMode(T),this._easingFunctions[Q]=n}this.easingFunction.setValue(this._easingFunctions[Q],n)}getClassName(){return"FlowGraphEasingBlock"}}(0,w.f)("FlowGraphEasingBlock",E)}}]);