"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[92],{13986:(A,X,s)=>{s.r(X),s.d(X,{EasingFunctionType:()=>N,FlowGraphEasingBlock:()=>r});var N,f=s(12940),E=s(12701),g=s(12677),K=s(616);!function(A){A[A.CircleEase=0]="CircleEase",A[A.BackEase=1]="BackEase",A[A.BounceEase=2]="BounceEase",A[A.CubicEase=3]="CubicEase",A[A.ElasticEase=4]="ElasticEase",A[A.ExponentialEase=5]="ExponentialEase",A[A.PowerEase=6]="PowerEase",A[A.QuadraticEase=7]="QuadraticEase",A[A.QuarticEase=8]="QuarticEase",A[A.QuinticEase=9]="QuinticEase",A[A.SineEase=10]="SineEase",A[A.BezierCurveEase=11]="BezierCurveEase"}(N||(N={}));class r extends E.e{constructor(A){super(A),this.config=A,this._easingFunctions={},this.type=this.registerDataInput("type",g.b,11),this.mode=this.registerDataInput("mode",g.n,0),this.parameters=this.registerDataInput("parameters",g.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",g.b)}_updateOutputs(A){const X=this.type.getValue(A),s=this.mode.getValue(A),N=this.parameters.getValue(A);if(void 0===X||void 0===s)return;const E=`${X}-${s}-${N.join("-")}`;if(!this._easingFunctions[E]){const A=function(A){for(var X=arguments.length,s=new Array(X>1?X-1:0),N=1;N<X;N++)s[N-1]=arguments[N];switch(A){case 11:return new f.e(...s);case 0:return new f.j;case 1:return new f.b(...s);case 2:return new f.f(...s);case 3:return new f.k;case 4:return new f.p(...s);case 5:return new f.q(...s);default:throw new Error("Easing type not yet implemented")}}(X,...N);A.setEasingMode(s),this._easingFunctions[E]=A}this.easingFunction.setValue(this._easingFunctions[E],A)}getClassName(){return"FlowGraphEasingBlock"}}(0,K.f)("FlowGraphEasingBlock",r)}}]);