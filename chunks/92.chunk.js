"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[92],{14163:(U,M,b)=>{b.r(M),b.d(M,{EasingFunctionType:()=>a,FlowGraphEasingBlock:()=>O});var a,A=b(13035),H=b(12795),W=b(12775),y=b(609);!function(U){U[U.CircleEase=0]="CircleEase",U[U.BackEase=1]="BackEase",U[U.BounceEase=2]="BounceEase",U[U.CubicEase=3]="CubicEase",U[U.ElasticEase=4]="ElasticEase",U[U.ExponentialEase=5]="ExponentialEase",U[U.PowerEase=6]="PowerEase",U[U.QuadraticEase=7]="QuadraticEase",U[U.QuarticEase=8]="QuarticEase",U[U.QuinticEase=9]="QuinticEase",U[U.SineEase=10]="SineEase",U[U.BezierCurveEase=11]="BezierCurveEase"}(a||(a={}));class O extends H.c{constructor(U){super(U),this.config=U,this._easingFunctions={},this.type=this.registerDataInput("type",W.c,11),this.mode=this.registerDataInput("mode",W.t,0),this.parameters=this.registerDataInput("parameters",W.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",W.c)}_updateOutputs(U){const M=this.type.getValue(U),b=this.mode.getValue(U),a=this.parameters.getValue(U);if(void 0===M||void 0===b)return;const H=`${M}-${b}-${a.join("-")}`;if(!this._easingFunctions[H]){const U=function(U){for(var M=arguments.length,b=new Array(M>1?M-1:0),a=1;a<M;a++)b[a-1]=arguments[a];switch(U){case 11:return new A.e(...b);case 0:return new A.h;case 1:return new A.b(...b);case 2:return new A.g(...b);case 3:return new A.i;case 4:return new A.p(...b);case 5:return new A.t(...b);default:throw new Error("Easing type not yet implemented")}}(M,...a);U.setEasingMode(b),this._easingFunctions[H]=U}this.easingFunction.setValue(this._easingFunctions[H],U)}getClassName(){return"FlowGraphEasingBlock"}}(0,y.i)("FlowGraphEasingBlock",O)}}]);