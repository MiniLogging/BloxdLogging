"use strict";(self.mo7o6813fhb=self.mo7o6813fhb||[]).push([[78],{15319:(t,U,y)=>{y.r(U),y.d(U,{AnimationGroup:()=>l,TargetedAnimation:()=>D});var I=y(12956),r=y(12204),Y=y(12250),mt=y(12434),X=y(13774),P=y(12386);class G{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(t,U,y,r){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=U,this._target=t,this._scene=y,this._host=r,this._activeTargets=[],U._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===I.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=P.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const t={frame:0,value:this._minValue};this._keys.splice(0,0,t)}if(this._target instanceof Array){let t=0;for(const U of this._target)this._preparePath(U,t),this._getOriginalValues(t),t++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const Y=U.getEvents();if(Y&&Y.length>0)for(const I of Y)this._events.push(I._clone());this._enableBlending=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const y=this._animation.targetPropertyPath;if(y.length>1){let I=t;for(let t=0;t<y.length-1;t++){const U=y[t];if(I=I[U],void 0===I)throw new Error(`Invalid property (${U}) in property path (${y.join(".")})`)}this._targetPath=y[y.length-1],this._activeTargets[U]=I}else this._targetPath=y[0],this._activeTargets[U]=t;if(void 0===this._activeTargets[U][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${y.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let t=0;for(const U of this._target)void 0!==this._originalValue[t]&&this._setValue(U,this._activeTargets[t],this._originalValue[t],-1,t),t++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let t=0;t<this._events.length;t++)this._events[t].isDone=!1}isStopped(){return this._stopped}dispose(){const t=this._animation.runtimeAnimations.indexOf(this);t>-1&&this._animation.runtimeAnimations.splice(t,1)}setValue(t,U){if(this._targetIsArray)for(let y=0;y<this._target.length;y++){const I=this._target[y];this._setValue(I,this._activeTargets[y],t,U,y)}else this._setValue(this._target,this._directTarget,t,U,0)}_getOriginalValues(){let t,U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const y=this._activeTargets[U];t=y.getLocalMatrix&&"_matrix"===this._targetPath?y.getLocalMatrix():y[this._targetPath],t&&t.clone?this._originalValue[U]=t.clone():this._originalValue[U]=t}_registerTargetForLateAnimationBinding(t,U){const y=t.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(y),y._lateAnimationHolders||(y._lateAnimationHolders={}),y._lateAnimationHolders[t.targetPath]||(y._lateAnimationHolders[t.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:U}),t.isAdditive?(y._lateAnimationHolders[t.targetPath].additiveAnimations.push(t),y._lateAnimationHolders[t.targetPath].totalAdditiveWeight+=t.weight):(y._lateAnimationHolders[t.targetPath].animations.push(t),y._lateAnimationHolders[t.targetPath].totalWeight+=t.weight)}_setValue(t,U,y,r,Y){if(this._currentActiveTarget=U,this._weight=r,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const t=U[this._targetPath];t.clone?this._originalBlendValue=t.clone():this._originalBlendValue=t}this._originalBlendValue.m?I.e.AllowMatrixDecomposeForInterpolation?this._currentValue?P.Matrix.DecomposeLerpToRef(this._originalBlendValue,y,this._blendingFactor,this._currentValue):this._currentValue=P.Matrix.DecomposeLerp(this._originalBlendValue,y,this._blendingFactor):this._currentValue?P.Matrix.LerpToRef(this._originalBlendValue,y,this._blendingFactor,this._currentValue):this._currentValue=P.Matrix.Lerp(this._originalBlendValue,y,this._blendingFactor):this._currentValue=I.e._UniversalLerp(this._originalBlendValue,y,this._blendingFactor);const r=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=r}else this._currentValue?this._currentValue.Y?this._currentValue.Y(y):this._currentValue=y:null!==y&&void 0!==y&&y.clone?this._currentValue=y.clone():this._currentValue=y;-1!==r?this._registerTargetForLateAnimationBinding(this,this._originalValue[Y]):this._animationState.loopMode===I.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[Y],U[this._targetPath]):U[this._targetPath]=this._originalValue[Y]+this._currentValue:U[this._targetPath]=this._currentValue,t.TG&&t.TG(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const y=this._animation.getKeys();t<y[0].frame?t=y[0].frame:t>y[y.length-1].frame&&(t=y[y.length-1].frame);const I=this._events;if(I.length)for(let Y=0;Y<I.length;Y++)I[Y].onlyOnce||(I[Y].isDone=I[Y].frame<t);this._currentFrame=t;const r=this._animation._interpolate(t,this._animationState);this.setValue(r,U)}_prepareForSpeedRatioChange(t){const U=this._previousElapsedTime*(this._animation.framePerSecond*t)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-U}animate(t,U,y,r,Y){let mt=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const X=this._animation,P=X.targetPropertyPath;if(!P||P.length<1)return this._stopped=!0,!1;let G,M=!0;const L=this._events;let h=0;if(this._coreRuntimeAnimation)h=y-U,G=this._coreRuntimeAnimation.currentFrame,this._currentFrame=G,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let mt;(U<this._minFrame||U>this._maxFrame)&&(U=this._minFrame),(y<this._minFrame||y>this._maxFrame)&&(y=this._maxFrame),h=y-U;let P=t*(X.framePerSecond*Y)/1e3+this._absoluteFrameOffset,Q=0,F=!1;const E=r&&this._animationState.loopMode===I.e.ANIMATIONLOOPMODE_YOYO;if(E){const t=(P-U)/h,y=Math.sin(t*Math.PI);P=Math.abs(y)*h+U;const I=y>=0?1:-1;this._yoyoDirection!==I&&(F=!0),this._yoyoDirection=I}if(this._previousElapsedTime=t,this._previousAbsoluteFrame=P,!r&&y>=U&&(P>=h&&Y>0||P<=0&&Y<0))M=!1,Q=X._getKeyValue(this._maxValue);else if(!r&&U>=y&&(P<=h&&Y<0||P>=0&&Y>0))M=!1,Q=X._getKeyValue(this._minValue);else if(this._animationState.loopMode!==I.e.ANIMATIONLOOPMODE_CYCLE){const t=y.toString()+U.toString();if(!this._offsetsCache[t]){this._animationState.repeatCount=0,this._animationState.loopMode=I.e.ANIMATIONLOOPMODE_CYCLE;const r=X._interpolate(U,this._animationState),Y=X._interpolate(y,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),X.dataType){case I.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[t]=Y-r;break;case I.e.ANIMATIONTYPE_QUATERNION:case I.e.ANIMATIONTYPE_VECTOR3:case I.e.ANIMATIONTYPE_VECTOR2:case I.e.ANIMATIONTYPE_SIZE:case I.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[t]=Y.lU(r)}this._highLimitsCache[t]=Y}Q=this._highLimitsCache[t],mt=this._offsetsCache[t]}if(void 0===mt)switch(X.dataType){case I.e.ANIMATIONTYPE_FLOAT:mt=0;break;case I.e.ANIMATIONTYPE_QUATERNION:mt=I.n;break;case I.e.ANIMATIONTYPE_VECTOR3:mt=I.r;break;case I.e.ANIMATIONTYPE_VECTOR2:mt=I.q;break;case I.e.ANIMATIONTYPE_SIZE:mt=I.o;break;case I.e.ANIMATIONTYPE_COLOR3:mt=I.f;break;case I.e.ANIMATIONTYPE_COLOR4:mt=I.j}if(this._host&&this._host.syncRoot){const t=this._host.syncRoot;G=U+h*((t.masterFrame-t.fromFrame)/(t.toFrame-t.fromFrame))}else G=P>0&&U>y||P<0&&U<y?M&&0!==h?y+P%h:U:M&&0!==h?U+P%h:y;if(!E&&(Y>0&&this.currentFrame>G||Y<0&&this.currentFrame<G)||E&&F){this._onLoop();for(let t=0;t<L.length;t++)L[t].onlyOnce||(L[t].isDone=!1);this._animationState.key=Y>0?0:X.getKeys().length-1}this._currentFrame=G,this._animationState.repeatCount=0===h?0:P/h|0,this._animationState.highLimitValue=Q,this._animationState.offsetValue=mt}const Q=X._interpolate(G,this._animationState);if(this.setValue(Q,mt),L.length)for(let I=0;I<L.length;I++)if(h>=0&&G>=L[I].frame&&L[I].frame>=U||h<0&&G<=L[I].frame&&L[I].frame<=U){const t=L[I];t.isDone||(t.onlyOnce&&(L.splice(I,1),I--),t.isDone=!0,t.action(G))}return M||(this._stopped=!0),M}}var M=y(12234);class L{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(t){this._weight=-1!==t?Math.min(Math.max(t,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(t){for(let U=0;U<this._runtimeAnimations.length;U++){this._runtimeAnimations[U]._prepareForSpeedRatioChange(t)}this._speedRatio=t,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(t,U){let y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,Y=arguments.length>4&&void 0!==arguments[4]&&arguments[4],mt=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,X=arguments.length>6?arguments[6]:void 0,P=arguments.length>7?arguments[7]:void 0,G=arguments.length>8?arguments[8]:void 0,M=arguments.length>9&&void 0!==arguments[9]&&arguments[9],L=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=U,this.fromFrame=y,this.toFrame=I,this.loopAnimation=Y,this.onAnimationEnd=X,this.onAnimationLoop=G,this.isAdditive=M,this.playOrder=L,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.XX=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new r.b,this.onAnimationLoopObservable=new r.b,this._scene=t,P&&this.appendAnimations(U,P),this._speedRatio=mt,t._activeAnimatables.push(this)}syncWith(t){if(this._syncRoot=t,t){const t=this._scene._activeAnimatables.indexOf(this);t>-1&&(this._scene._activeAnimatables.splice(t,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(t,U){for(let y=0;y<U.length;y++){const I=U[y],r=new G(t,I,this._scene,this);r._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(r)}}getAnimationByTargetProperty(t){const U=this._runtimeAnimations;for(let y=0;y<U.length;y++)if(U[y].animation.targetProperty===t)return U[y].animation;return null}getRuntimeAnimationByTargetProperty(t){const U=this._runtimeAnimations;for(let y=0;y<U.length;y++)if(U[y].animation.targetProperty===t)return U[y];return null}reset(){const t=this._runtimeAnimations;for(let U=0;U<t.length;U++)t[U].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(t){const U=this._runtimeAnimations;for(let y=0;y<U.length;y++)U[y].animation.enableBlending=!0,U[y].animation.blendingSpeed=t}disableBlending(){const t=this._runtimeAnimations;for(let U=0;U<t.length;U++)t[U].animation.enableBlending=!1}goToFrame(t){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const y=this._runtimeAnimations;if(y[0]){const U=y[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??y[0].currentFrame;const I=0===this.speedRatio?0:(t-this._frameToSyncFromJump)/U*1e3/this.speedRatio;this._manualJumpDelay=-I}for(let I=0;I<y.length;I++)y[I].goToFrame(t,U?this._weight:-1);this._goToFrame=t}get paused(){return this.XX}pause(){this.XX||(this.XX=!0)}restart(){this.XX=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(t,U){let y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],I=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t||U){const r=this._scene._activeAnimatables.indexOf(this);if(r>-1){const Y=this._runtimeAnimations;for(let y=Y.length-1;y>=0;y--){const I=Y[y];t&&I.animation.name!=t||(U&&!U(I.target)||(I.dispose(),Y.splice(y,1)))}0==Y.length&&(y||this._scene._activeAnimatables.splice(r,1),I||this._raiseOnAnimationEnd())}}else{const t=this._scene._activeAnimatables.indexOf(this);if(t>-1){y||this._scene._activeAnimatables.splice(t,1);const U=this._runtimeAnimations;for(let t=0;t<U.length;t++)U[t].dispose();this._runtimeAnimations.length=0,I||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((t=>{this.onAnimationEndObservable.add((()=>{t(this)}),void 0,void 0,this,!0)}))}_animate(t){if(this.XX)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=t),!0;if(null===this._localDelayOffset?(this._localDelayOffset=t,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=t-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let U=!1;const y=this._runtimeAnimations;let I;for(I=0;I<y.length;I++){const r=y[I].animate(t-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);U=U||r}if(this.animationStarted=U,!U){if(this.disposeOnEnd)for(I=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(I,1),I=0;I<y.length;I++)y[I].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return U}}function h(t){if(0===t.totalWeight&&0===t.totalAdditiveWeight)return t.originalValue;let U=1;const y=P.TmpVectors.DU[0],I=P.TmpVectors.DU[1],r=P.TmpVectors.Quaternion[0];let Y=0;const mt=t.animations[0],X=t.originalValue;let G=1,M=!1;if(t.totalWeight<1)G=1-t.totalWeight,X.decompose(I,r,y);else{if(Y=1,U=t.totalWeight,G=mt.weight/U,1==G){if(!t.totalAdditiveWeight)return mt.currentValue;M=!0}mt.currentValue.decompose(I,r,y)}if(!M){I.scaleInPlace(G),y.scaleInPlace(G),r.scaleInPlace(G);for(let mt=Y;mt<t.animations.length;mt++){const Y=t.animations[mt];if(0===Y.weight)continue;G=Y.weight/U;const X=P.TmpVectors.DU[2],M=P.TmpVectors.DU[3],L=P.TmpVectors.Quaternion[1];Y.currentValue.decompose(M,L,X),M.scaleAndAddToRef(G,I),L.scaleAndAddToRef(P.Quaternion.Dot(r,L)>0?G:-G,r),X.scaleAndAddToRef(G,y)}r.normalize()}for(let h=0;h<t.additiveAnimations.length;h++){const U=t.additiveAnimations[h];if(0===U.weight)continue;const Y=P.TmpVectors.DU[2],mt=P.TmpVectors.DU[3],X=P.TmpVectors.Quaternion[1];U.currentValue.decompose(mt,X,Y),mt.multiplyToRef(I,mt),P.DU.LerpToRef(I,mt,U.weight,I),r.multiplyToRef(X,X),P.Quaternion.SlerpToRef(r,X,U.weight,r),Y.scaleAndAddToRef(U.weight,y)}const L=mt?mt._animationState.workValue:P.TmpVectors.Matrix[0].clone();return P.Matrix.ComposeToRef(I,r,y,L),L}function Q(t,U){if(0===t.totalWeight&&0===t.totalAdditiveWeight)return U;const y=t.animations[0],I=t.originalValue;let r=U;if(0===t.totalWeight&&t.totalAdditiveWeight>0)r.Y(I);else if(1===t.animations.length){if(P.Quaternion.SlerpToRef(I,y.currentValue,Math.min(1,t.totalWeight),r),0===t.totalAdditiveWeight)return r}else if(t.animations.length>1){let y,Y,mt=1;if(t.totalWeight<1){const U=1-t.totalWeight;y=[],Y=[],y.push(I),Y.push(U)}else{if(2===t.animations.length&&(P.Quaternion.SlerpToRef(t.animations[0].currentValue,t.animations[1].currentValue,t.animations[1].weight/t.totalWeight,U),0===t.totalAdditiveWeight))return U;y=[],Y=[],mt=t.totalWeight}for(let U=0;U<t.animations.length;U++){const I=t.animations[U];y.push(I.currentValue),Y.push(I.weight/mt)}let X=0;for(let t=0;t<y.length;)t?(X+=Y[t],P.Quaternion.SlerpToRef(r,y[t],Y[t]/X,r),t++):(P.Quaternion.SlerpToRef(y[t],y[t+1],Y[t+1]/(Y[t]+Y[t+1]),U),r=U,X=Y[t]+Y[t+1],t+=2)}for(let Y=0;Y<t.additiveAnimations.length;Y++){const U=t.additiveAnimations[Y];0!==U.weight&&(r.multiplyToRef(U.currentValue,P.TmpVectors.Quaternion[0]),P.Quaternion.SlerpToRef(r,P.TmpVectors.Quaternion[0],U.weight,r))}return r}var F,E,w=y(12653);F=w.e,(E=X.e)&&(E.prototype.copyAnimationRange=function(t,U,y){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],Y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new I.e(this.name,"_matrix",t.animations[0].framePerSecond,I.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const mt=t.animations[0].getRange(U);if(!mt)return!1;const X=mt.from,P=mt.to,G=t.animations[0].getKeys(),M=t.length,L=t.getParent(),h=this.getParent(),Q=r&&L&&M&&this.length&&M!==this.length,F=Q&&h&&L?h.length/L.length:1,E=r&&!h&&Y&&(1!==Y.x||1!==Y.y||1!==Y.z),w=this.animations[0].getKeys();let D,l,g;for(let I=0,B=G.length;I<B;I++)D=G[I],D.frame>=X&&D.frame<=P&&(r?(g=D.value.clone(),Q?(l=g.getTranslation(),g.setTranslation(l.scaleInPlace(F))):E&&Y?(l=g.getTranslation(),g.setTranslation(l.multiplyInPlace(Y))):g=D.value):g=D.value,w.push({frame:D.frame+y,value:g}));return this.animations[0].createRange(U,X+y,P+y),!0}),F&&(F.prototype._animate=function(t){if(!this.animationsEnabled)return;const U=M.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=U}this.deltaTime=void 0!==t?t:this.useConstantAnimationDeltaTime?16:(U-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=U;const y=this._activeAnimatables;if(0===y.length)return;this._animationTime+=this.deltaTime;const r=this._animationTime;for(let I=0;I<y.length;I++){const t=y[I];!t._animate(r)&&t.disposeOnEnd&&I--}!function(t){if(t._registeredForLateAnimationBindings.length){for(let U=0;U<t._registeredForLateAnimationBindings.length;U++){const y=t._registeredForLateAnimationBindings.data[U];for(const t in y._lateAnimationHolders){const U=y._lateAnimationHolders[t],r=U.animations[0],Y=U.originalValue;if(void 0===Y||null===Y)continue;const mt=I.e.AllowMatrixDecomposeForInterpolation&&Y.m;let X=y[t];if(mt)X=h(U);else if(void 0!==Y.w)X=Q(U,X||P.Quaternion.Identity());else{let t=0,y=1;const mt=r&&r._animationState.loopMode===I.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(U.totalWeight<1)X=mt?Y.clone?Y.clone():Y:r&&Y.scale?Y.scale(1-U.totalWeight):r?Y*(1-U.totalWeight):Y.clone?Y.clone():Y;else if(r){y=U.totalWeight;const I=r.weight/y;X=1!==I?r.currentValue.scale?r.currentValue.scale(I):r.currentValue*I:r.currentValue,mt&&(X.addToRef?X.addToRef(Y,X):X+=Y),t=1}for(let I=t;I<U.animations.length;I++){const t=U.animations[I],r=t.weight/y;r&&(t.currentValue.scaleAndAddToRef?t.currentValue.scaleAndAddToRef(r,X):X+=t.currentValue*r)}for(let I=0;I<U.additiveAnimations.length;I++){const t=U.additiveAnimations[I],y=t.weight;y&&(t.currentValue.scaleAndAddToRef?t.currentValue.scaleAndAddToRef(y,X):X+=t.currentValue*y)}}y[t]=X}y._lateAnimationHolders={}}t._registeredForLateAnimationBindings.reset()}}(this)},F.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((t,U)=>t.playOrder-U.playOrder))},F.prototype.beginWeightedAnimation=function(t,U,y){let I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4?arguments[4]:void 0,Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,mt=arguments.length>6?arguments[6]:void 0,X=arguments.length>7?arguments[7]:void 0,P=arguments.length>8?arguments[8]:void 0,G=arguments.length>9?arguments[9]:void 0,M=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const L=this.beginAnimation(t,U,y,r,Y,mt,X,!1,P,G,M);return L.weight=I,L},F.prototype.beginAnimation=function(t,U,y,I){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,Y=arguments.length>5?arguments[5]:void 0,mt=arguments.length>6?arguments[6]:void 0,X=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],P=arguments.length>8?arguments[8]:void 0,G=arguments.length>9?arguments[9]:void 0,M=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(r<0){const t=U;U=y,y=t,r=-r}U>y&&(r=-r),X&&this.stopAnimation(t,void 0,P),mt||(mt=new L(this,t,U,y,I,r,Y,void 0,G,M));const h=!P||P(t);if(t.animations&&h&&mt.appendAnimations(t,t.animations),t.getAnimatables){const M=t.getAnimatables();for(let t=0;t<M.length;t++)this.beginAnimation(M[t],U,y,I,r,Y,mt,X,P,G)}return mt.reset(),mt},F.prototype.beginHierarchyAnimation=function(t,U,y,I,r){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,mt=arguments.length>6?arguments[6]:void 0,X=arguments.length>7?arguments[7]:void 0,P=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],G=arguments.length>9?arguments[9]:void 0,M=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const L=t.getDescendants(U),h=[];h.push(this.beginAnimation(t,y,I,r,Y,mt,X,P,G,void 0,M));for(const Q of L)h.push(this.beginAnimation(Q,y,I,r,Y,mt,X,P,G,void 0,M));return h},F.prototype.beginDirectAnimation=function(t,U,y,I,r){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(Y<0){const t=y;y=I,I=t,Y=-Y}return y>I&&(Y=-Y),new L(this,t,y,I,r,Y,arguments.length>6?arguments[6]:void 0,U,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},F.prototype.beginDirectHierarchyAnimation=function(t,U,y,I,r,Y,mt,X,P){let G=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const M=t.getDescendants(U),L=[];L.push(this.beginDirectAnimation(t,y,I,r,Y,mt,X,P,G));for(const h of M)L.push(this.beginDirectAnimation(h,y,I,r,Y,mt,X,P,G));return L},F.prototype.getAnimatableByTarget=function(t){for(let U=0;U<this._activeAnimatables.length;U++)if(this._activeAnimatables[U].target===t)return this._activeAnimatables[U];return null},F.prototype.getAllAnimatablesByTarget=function(t){const U=[];for(let y=0;y<this._activeAnimatables.length;y++)this._activeAnimatables[y].target===t&&U.push(this._activeAnimatables[y]);return U},F.prototype.stopAnimation=function(t,U,y){const I=this.getAllAnimatablesByTarget(t);for(const r of I)r.stop(U,y)},F.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let t=0;t<this._activeAnimatables.length;t++)this._activeAnimatables[t].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const t of this.animationGroups)t.stop()});class D{getClassName(){return"TargetedAnimation"}serialize(){const t={};return t.animation=this.animation.serialize(),t.targetId=this.target.id,t}}class l{get mask(){return this._mask}set mask(t){this._mask!==t&&(this._mask=t,this.syncWithMask(!0))}syncWithMask(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||t){this._numActiveAnimatables=0;for(let t=0;t<this._animatables.length;++t){const U=this._animatables[t];!this.mask||this.mask.disabled||this.mask.retainsTarget(U.target.name)?(this._numActiveAnimatables++,U.paused&&U.restart()):U.paused||U.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let t=0;t<this._animatables.length;++t){const U=this._animatables[t];this.mask.retainsTarget(U.target.name)||(U.stop(),this._animatables.splice(t,1),--t)}for(let t=0;t<this._targetedAnimations.length;t++){const U=this._targetedAnimations[t];this.mask.retainsTarget(U.target.name)||(this._targetedAnimations.splice(t,1),--t)}}}get from(){return this._from}set from(t){if(this._from!==t){this._from=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].fromFrame=this._from}}}get to(){return this._to}set to(t){if(this._to!==t){this._to=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(t){if(this._speedRatio!==t){this._speedRatio=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(t){if(this._loopAnimation!==t){this._loopAnimation=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(t){if(this._isAdditive!==t){this._isAdditive=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(t){this._weight!==t&&(this._weight=t,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(t){if(this._playOrder!==t&&(this._playOrder=t,this._animatables.length>0)){for(let t=0;t<this._animatables.length;t++)this._animatables[t].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(t){if(this._enableBlending!==t&&(this._enableBlending=t,null!==t))for(let U=0;U<this._targetedAnimations.length;++U)this._targetedAnimations[U].animation.enableBlending=t}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(t){if(this._blendingSpeed!==t&&(this._blendingSpeed=t,null!==t))for(let U=0;U<this._targetedAnimations.length;++U)this._targetedAnimations[U].animation.blendingSpeed=t}getLength(t,U){t=t??this._from;return((U=U??this._to)-t)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(t){let U=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],I=arguments.length>3?arguments[3]:void 0;if(0===t.length)return null;I=I??t[0].weight;let r=Number.MAX_VALUE,Y=-Number.MAX_VALUE;if(y)for(const X of t)X.from<r&&(r=X.from),X.to>Y&&(Y=X.to);const mt=new l(t[0].name+"_merged",t[0]._scene,I);for(const X of t){y&&X.normalize(r,Y);for(const t of X.targetedAnimations)mt.addTargetedAnimation(t.animation,t.target);U&&X.dispose()}return mt}constructor(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=t,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new r.b,this.onAnimationLoopObservable=new r.b,this.onAnimationGroupLoopObservable=new r.b,this.onAnimationGroupEndObservable=new r.b,this.onAnimationGroupPauseObservable=new r.b,this.onAnimationGroupPlayObservable=new r.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=U||Y.d.LastCreatedScene,this._weight=y,this._playOrder=I,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(t,U){const y=new D;y.animation=t,y.target=U;const I=t.getKeys();return this._from>I[0].frame&&(this._from=I[0].frame),this._to<I[I.length-1].frame&&(this._to=I[I.length-1].frame),null!==this._enableBlending&&(t.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(t.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(y),this._shouldStart=!0,y}removeTargetedAnimation(t){for(let U=this._targetedAnimations.length-1;U>-1;U--){this._targetedAnimations[U].animation===t&&this._targetedAnimations.splice(U,1)}}normalize(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==t&&(t=this._from),null==U&&(U=this._to);for(let y=0;y<this._targetedAnimations.length;y++){const I=this._targetedAnimations[y].animation.getKeys(),r=I[0],Y=I[I.length-1];if(r.frame>t){const U={frame:t,value:r.value,inTangent:r.inTangent,outTangent:r.outTangent,interpolation:r.interpolation};I.splice(0,0,U)}if(Y.frame<U){const t={frame:U,value:Y.value,inTangent:Y.inTangent,outTangent:Y.outTangent,interpolation:Y.interpolation};I.push(t)}}return this._from=t,this._to=U,this}_processLoop(t,U,y){t.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(U),this._animationLoopFlags[y]||(this._animationLoopFlags[y]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,y=arguments.length>2?arguments[2]:void 0,I=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=t,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let Y=0;Y<this._targetedAnimations.length;Y++){const mt=this._targetedAnimations[Y],X=this._scene.beginDirectAnimation(mt.target,[mt.animation],void 0!==y?y:this._from,void 0!==I?I:this._to,t,U,void 0,void 0,void 0!==r?r:this._isAdditive);X.weight=this._weight,X.playOrder=this._playOrder,X.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(mt),this._checkAnimationGroupEnded(X)},this._processLoop(X,mt,Y),this._animatables.push(X)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=U,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let t=0;t<this._animatables.length;t++){this._animatables[t].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(t){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==t&&(this.loopAnimation=t),this.restart()):(this.stop(),this.start(t,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].reset()}return this}restart(){if(!this._isStarted)return this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const U=this._animatables.slice();for(let I=0;I<U.length;I++)U[I].stop(void 0,void 0,!0,t);let y=0;for(let I=0;I<this._scene._activeAnimatables.length;I++){const U=this._scene._activeAnimatables[I];U._runtimeAnimations.length>0?this._scene._activeAnimatables[y++]=U:t&&this._checkAnimationGroupEnded(U,t)}return this._scene._activeAnimatables.length=y,this._isStarted=!1,this}setWeightForAllAnimatables(t){for(let U=0;U<this._animatables.length;U++){this._animatables[U].weight=t}return this}syncAllAnimationsWith(t){for(let U=0;U<this._animatables.length;U++){this._animatables[U].syncWith(t)}return this}goToFrame(t){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let y=0;y<this._animatables.length;y++){this._animatables[y].goToFrame(t,U)}return this}getCurrentFrame(){var t;return(null===(t=this.animatables[0])||void 0===t?void 0:t.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const t=this._scene.animationGroups.indexOf(this);if(t>-1&&this._scene.animationGroups.splice(t,1),this._parentContainer){const t=this._parentContainer.animationGroups.indexOf(this);t>-1&&this._parentContainer.animationGroups.splice(t,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(t){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const y=this._animatables.indexOf(t);y>-1&&this._animatables.splice(y,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,U||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(t,U){let y=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const I=new l(t||this.name,this._scene,this._weight,this._playOrder);I._from=this.from,I._to=this.to,I._speedRatio=this.speedRatio,I._loopAnimation=this.loopAnimation,I._isAdditive=this.isAdditive,I._enableBlending=this.enableBlending,I._blendingSpeed=this.blendingSpeed,I.metadata=this.metadata,I.mask=this.mask;for(const r of this._targetedAnimations)I.addTargetedAnimation(y?r.animation.clone():r.animation,U?U(r.target):r.target);return I}serialize(){const t={};t.name=this.name,t.from=this.from,t.to=this.to,t.speedRatio=this.speedRatio,t.loopAnimation=this.loopAnimation,t.isAdditive=this.isAdditive,t.weight=this.weight,t.playOrder=this.playOrder,t.enableBlending=this.enableBlending,t.blendingSpeed=this.blendingSpeed,t.targetedAnimations=[];for(let U=0;U<this.targetedAnimations.length;U++){const y=this.targetedAnimations[U];t.targetedAnimations[U]=y.serialize()}return mt.d&&mt.d.HasTags(this)&&(t.tags=mt.d.GetTags(this)),this.metadata&&(t.metadata=this.metadata),t}static Parse(t,U){const y=new l(t.name,U,t.weight,t.playOrder);for(let r=0;r<t.targetedAnimations.length;r++){const Y=t.targetedAnimations[r],mt=I.e.Parse(Y.animation),X=Y.targetId;if("influence"===Y.animation.property){const t=U.getMorphTargetById(X);t&&y.addTargetedAnimation(mt,t)}else{const t=U.getNodeById(X);null!=t&&y.addTargetedAnimation(mt,t)}}return mt.d&&mt.d.AddTagsTo(y,t.tags),null!==t.from&&null!==t.to&&y.normalize(t.from,t.to),void 0!==t.speedRatio&&(y._speedRatio=t.speedRatio),void 0!==t.loopAnimation&&(y._loopAnimation=t.loopAnimation),void 0!==t.isAdditive&&(y._isAdditive=t.isAdditive),void 0!==t.weight&&(y._weight=t.weight),void 0!==t.playOrder&&(y._playOrder=t.playOrder),void 0!==t.enableBlending&&(y._enableBlending=t.enableBlending),void 0!==t.blendingSpeed&&(y._blendingSpeed=t.blendingSpeed),void 0!==t.metadata&&(y.metadata=t.metadata),y}static MakeAnimationAdditive(t,U,y){let r;r="object"===typeof U?U:{referenceFrame:U,range:y,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let Y=t;r.cloneOriginalAnimationGroup&&(Y=t.clone(r.clonedAnimationGroupName||Y.name));const mt=Y.targetedAnimations;for(let X=0;X<mt.length;X++){const t=mt[X];t.animation=I.e.MakeAnimationAdditive(t.animation,r)}if(Y.isAdditive=!0,r.clipKeys){let t=Number.MAX_VALUE,U=-Number.MAX_VALUE;const y=Y.targetedAnimations;for(let I=0;I<y.length;I++){const r=y[I].animation.getKeys();t>r[0].frame&&(t=r[0].frame),U<r[r.length-1].frame&&(U=r[r.length-1].frame)}Y._from=t,Y._to=U}return Y}static ClipKeys(t,U,y,I,r){const Y=t.clone(I||t.name);return l.ClipKeysInPlace(Y,U,y,r)}static ClipKeysInPlace(t,U,y,I){return l.ClipInPlace(t,U,y,I,!1)}static ClipFrames(t,U,y,I,r){const Y=t.clone(I||t.name);return l.ClipFramesInPlace(Y,U,y,r)}static ClipFramesInPlace(t,U,y,I){return l.ClipInPlace(t,U,y,I,!0)}static ClipInPlace(t,U,y,I){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Y=Number.MAX_VALUE,mt=-Number.MAX_VALUE;const X=t.targetedAnimations;for(let P=0;P<X.length;P++){const t=X[P],G=I?t.animation:t.animation.clone();r&&(G.createKeyForFrame(U),G.createKeyForFrame(y));const M=G.getKeys(),L=[];let h=Number.MAX_VALUE;for(let I=0;I<M.length;I++){const t=M[I];if(!r&&I>=U&&I<=y||r&&t.frame>=U&&t.frame<=y){const U={frame:t.frame,value:t.value.clone?t.value.clone():t.value,inTangent:t.inTangent,outTangent:t.outTangent,interpolation:t.interpolation,lockedTangent:t.lockedTangent};h===Number.MAX_VALUE&&(h=U.frame),U.frame-=h,L.push(U)}}0!==L.length?(Y>L[0].frame&&(Y=L[0].frame),mt<L[L.length-1].frame&&(mt=L[L.length-1].frame),G.setKeys(L,!0),t.animation=G):(X.splice(P,1),P--)}return t._from=Y,t._to=mt,t}getClassName(){return"AnimationGroup"}toString(t){let U="Name: "+this.name;return U+=", type: "+this.getClassName(),t&&(U+=", from: "+this._from,U+=", to: "+this._to,U+=", isStarted: "+this._isStarted,U+=", speedRatio: "+this._speedRatio,U+=", targetedAnimations length: "+this._targetedAnimations.length,U+=", animatables length: "+this._animatables),U}}}}]);