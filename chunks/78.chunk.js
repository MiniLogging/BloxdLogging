"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[78],{14557:(m,S,h)=>{h.r(S),h.d(S,{AnimationGroup:()=>L,TargetedAnimation:()=>n});var l=h(11838),M=h(11161),O=h(11196),u=h(11381),b=h(12981),q=h(11347);class Y{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(m,S,h,M){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=S,this._target=m,this._scene=h,this._host=M,this._activeTargets=[],S._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===l.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=q.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const m={frame:0,value:this._minValue};this._keys.splice(0,0,m)}if(this._target instanceof Array){let m=0;for(const S of this._target)this._preparePath(S,m),this._getOriginalValues(m),m++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const O=S.getEvents();if(O&&O.length>0)for(const l of O)this._events.push(l._clone());this._enableBlending=m&&m.animationPropertiesOverride?m.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=this._animation.targetPropertyPath;if(h.length>1){let l=m;for(let m=0;m<h.length-1;m++){const S=h[m];if(l=l[S],void 0===l)throw new Error(`Invalid property (${S}) in property path (${h.join(".")})`)}this._targetPath=h[h.length-1],this._activeTargets[S]=l}else this._targetPath=h[0],this._activeTargets[S]=m;if(void 0===this._activeTargets[S][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${h.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let m=0;for(const S of this._target)void 0!==this._originalValue[m]&&this._setValue(S,this._activeTargets[m],this._originalValue[m],-1,m),m++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let m=0;m<this._events.length;m++)this._events[m].isDone=!1}isStopped(){return this._stopped}dispose(){const m=this._animation.runtimeAnimations.indexOf(this);m>-1&&this._animation.runtimeAnimations.splice(m,1)}setValue(m,S){if(this._targetIsArray)for(let h=0;h<this._target.length;h++){const l=this._target[h];this._setValue(l,this._activeTargets[h],m,S,h)}else this._setValue(this._target,this._directTarget,m,S,0)}_getOriginalValues(){let m,S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const h=this._activeTargets[S];m=h.getLocalMatrix&&"_matrix"===this._targetPath?h.getLocalMatrix():h[this._targetPath],m&&m.clone?this._originalValue[S]=m.clone():this._originalValue[S]=m}_registerTargetForLateAnimationBinding(m,S){const h=m.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(h),h._lateAnimationHolders||(h._lateAnimationHolders={}),h._lateAnimationHolders[m.targetPath]||(h._lateAnimationHolders[m.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:S}),m.isAdditive?(h._lateAnimationHolders[m.targetPath].additiveAnimations.push(m),h._lateAnimationHolders[m.targetPath].totalAdditiveWeight+=m.weight):(h._lateAnimationHolders[m.targetPath].animations.push(m),h._lateAnimationHolders[m.targetPath].totalWeight+=m.weight)}_setValue(m,S,h,M,O){if(this._currentActiveTarget=S,this._weight=M,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const m=S[this._targetPath];m.clone?this._originalBlendValue=m.clone():this._originalBlendValue=m}this._originalBlendValue.m?l.e.AllowMatrixDecomposeForInterpolation?this._currentValue?q.Matrix.DecomposeLerpToRef(this._originalBlendValue,h,this._blendingFactor,this._currentValue):this._currentValue=q.Matrix.DecomposeLerp(this._originalBlendValue,h,this._blendingFactor):this._currentValue?q.Matrix.LerpToRef(this._originalBlendValue,h,this._blendingFactor,this._currentValue):this._currentValue=q.Matrix.Lerp(this._originalBlendValue,h,this._blendingFactor):this._currentValue=l.e._UniversalLerp(this._originalBlendValue,h,this._blendingFactor);const M=m&&m.animationPropertiesOverride?m.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=M}else this._currentValue?this._currentValue.l?this._currentValue.l(h):this._currentValue=h:null!==h&&void 0!==h&&h.clone?this._currentValue=h.clone():this._currentValue=h;-1!==M?this._registerTargetForLateAnimationBinding(this,this._originalValue[O]):this._animationState.loopMode===l.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[O],S[this._targetPath]):S[this._targetPath]=this._originalValue[O]+this._currentValue:S[this._targetPath]=this._currentValue,m.ZV&&m.ZV(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const h=this._animation.getKeys();m<h[0].frame?m=h[0].frame:m>h[h.length-1].frame&&(m=h[h.length-1].frame);const l=this._events;if(l.length)for(let O=0;O<l.length;O++)l[O].onlyOnce||(l[O].isDone=l[O].frame<m);this._currentFrame=m;const M=this._animation._interpolate(m,this._animationState);this.setValue(M,S)}_prepareForSpeedRatioChange(m){const S=this._previousElapsedTime*(this._animation.framePerSecond*m)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-S}animate(m,S,h,M,O){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const b=this._animation,q=b.targetPropertyPath;if(!q||q.length<1)return this._stopped=!0,!1;let Y,V=!0;const I=this._events;let Z=0;if(this._coreRuntimeAnimation)Z=h-S,Y=this._coreRuntimeAnimation.currentFrame,this._currentFrame=Y,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let u;(S<this._minFrame||S>this._maxFrame)&&(S=this._minFrame),(h<this._minFrame||h>this._maxFrame)&&(h=this._maxFrame),Z=h-S;let q=m*(b.framePerSecond*O)/1e3+this._absoluteFrameOffset,C=0,B=!1;const D=M&&this._animationState.loopMode===l.e.ANIMATIONLOOPMODE_YOYO;if(D){const m=(q-S)/Z,h=Math.sin(m*Math.PI);q=Math.abs(h)*Z+S;const l=h>=0?1:-1;this._yoyoDirection!==l&&(B=!0),this._yoyoDirection=l}if(this._previousElapsedTime=m,this._previousAbsoluteFrame=q,!M&&h>=S&&(q>=Z&&O>0||q<=0&&O<0))V=!1,C=b._getKeyValue(this._maxValue);else if(!M&&S>=h&&(q<=Z&&O<0||q>=0&&O>0))V=!1,C=b._getKeyValue(this._minValue);else if(this._animationState.loopMode!==l.e.ANIMATIONLOOPMODE_CYCLE){const m=h.toString()+S.toString();if(!this._offsetsCache[m]){this._animationState.repeatCount=0,this._animationState.loopMode=l.e.ANIMATIONLOOPMODE_CYCLE;const M=b._interpolate(S,this._animationState),O=b._interpolate(h,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),b.dataType){case l.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[m]=O-M;break;case l.e.ANIMATIONTYPE_QUATERNION:case l.e.ANIMATIONTYPE_VECTOR3:case l.e.ANIMATIONTYPE_VECTOR2:case l.e.ANIMATIONTYPE_SIZE:case l.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[m]=O.LS(M)}this._highLimitsCache[m]=O}C=this._highLimitsCache[m],u=this._offsetsCache[m]}if(void 0===u)switch(b.dataType){case l.e.ANIMATIONTYPE_FLOAT:u=0;break;case l.e.ANIMATIONTYPE_QUATERNION:u=l.m;break;case l.e.ANIMATIONTYPE_VECTOR3:u=l.u;break;case l.e.ANIMATIONTYPE_VECTOR2:u=l.q;break;case l.e.ANIMATIONTYPE_SIZE:u=l.p;break;case l.e.ANIMATIONTYPE_COLOR3:u=l.g;break;case l.e.ANIMATIONTYPE_COLOR4:u=l.j}if(this._host&&this._host.syncRoot){const m=this._host.syncRoot;Y=S+Z*((m.masterFrame-m.fromFrame)/(m.toFrame-m.fromFrame))}else Y=q>0&&S>h||q<0&&S<h?V&&0!==Z?h+q%Z:S:V&&0!==Z?S+q%Z:h;if(!D&&(O>0&&this.currentFrame>Y||O<0&&this.currentFrame<Y)||D&&B){this._onLoop();for(let m=0;m<I.length;m++)I[m].onlyOnce||(I[m].isDone=!1);this._animationState.key=O>0?0:b.getKeys().length-1}this._currentFrame=Y,this._animationState.repeatCount=0===Z?0:q/Z|0,this._animationState.highLimitValue=C,this._animationState.offsetValue=u}const C=b._interpolate(Y,this._animationState);if(this.setValue(C,u),I.length)for(let l=0;l<I.length;l++)if(Z>=0&&Y>=I[l].frame&&I[l].frame>=S||Z<0&&Y<=I[l].frame&&I[l].frame<=S){const m=I[l];m.isDone||(m.onlyOnce&&(I.splice(l,1),l--),m.isDone=!0,m.action(Y))}return V||(this._stopped=!0),V}}var V=h(11183);class I{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(m){this._weight=-1!==m?Math.min(Math.max(m,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(m){for(let S=0;S<this._runtimeAnimations.length;S++){this._runtimeAnimations[S]._prepareForSpeedRatioChange(m)}this._speedRatio=m,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(m,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,O=arguments.length>4&&void 0!==arguments[4]&&arguments[4],u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,b=arguments.length>6?arguments[6]:void 0,q=arguments.length>7?arguments[7]:void 0,Y=arguments.length>8?arguments[8]:void 0,V=arguments.length>9&&void 0!==arguments[9]&&arguments[9],I=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=S,this.fromFrame=h,this.toFrame=l,this.loopAnimation=O,this.onAnimationEnd=b,this.onAnimationLoop=Y,this.isAdditive=V,this.playOrder=I,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Gb=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new M.e,this.onAnimationLoopObservable=new M.e,this._scene=m,q&&this.appendAnimations(S,q),this._speedRatio=u,m._activeAnimatables.push(this)}syncWith(m){if(this._syncRoot=m,m){const m=this._scene._activeAnimatables.indexOf(this);m>-1&&(this._scene._activeAnimatables.splice(m,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(m,S){for(let h=0;h<S.length;h++){const l=S[h],M=new Y(m,l,this._scene,this);M._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(M)}}getAnimationByTargetProperty(m){const S=this._runtimeAnimations;for(let h=0;h<S.length;h++)if(S[h].animation.targetProperty===m)return S[h].animation;return null}getRuntimeAnimationByTargetProperty(m){const S=this._runtimeAnimations;for(let h=0;h<S.length;h++)if(S[h].animation.targetProperty===m)return S[h];return null}reset(){const m=this._runtimeAnimations;for(let S=0;S<m.length;S++)m[S].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(m){const S=this._runtimeAnimations;for(let h=0;h<S.length;h++)S[h].animation.enableBlending=!0,S[h].animation.blendingSpeed=m}disableBlending(){const m=this._runtimeAnimations;for(let S=0;S<m.length;S++)m[S].animation.enableBlending=!1}goToFrame(m){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const h=this._runtimeAnimations;if(h[0]){const S=h[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??h[0].currentFrame;const l=0===this.speedRatio?0:(m-this._frameToSyncFromJump)/S*1e3/this.speedRatio;this._manualJumpDelay=-l}for(let l=0;l<h.length;l++)h[l].goToFrame(m,S?this._weight:-1);this._goToFrame=m}get paused(){return this.Gb}pause(){this.Gb||(this.Gb=!0)}restart(){this.Gb=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(m,S){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],l=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(m||S){const M=this._scene._activeAnimatables.indexOf(this);if(M>-1){const O=this._runtimeAnimations;for(let h=O.length-1;h>=0;h--){const l=O[h];m&&l.animation.name!=m||(S&&!S(l.target)||(l.dispose(),O.splice(h,1)))}0==O.length&&(h||this._scene._activeAnimatables.splice(M,1),l||this._raiseOnAnimationEnd())}}else{const m=this._scene._activeAnimatables.indexOf(this);if(m>-1){h||this._scene._activeAnimatables.splice(m,1);const S=this._runtimeAnimations;for(let m=0;m<S.length;m++)S[m].dispose();this._runtimeAnimations.length=0,l||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((m=>{this.onAnimationEndObservable.add((()=>{m(this)}),void 0,void 0,this,!0)}))}_animate(m){if(this.Gb)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=m),!0;if(null===this._localDelayOffset?(this._localDelayOffset=m,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=m-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let S=!1;const h=this._runtimeAnimations;let l;for(l=0;l<h.length;l++){const M=h[l].animate(m-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);S=S||M}if(this.animationStarted=S,!S){if(this.disposeOnEnd)for(l=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(l,1),l=0;l<h.length;l++)h[l].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return S}}function Z(m){if(0===m.totalWeight&&0===m.totalAdditiveWeight)return m.originalValue;let S=1;const h=q.TmpVectors.nS[0],l=q.TmpVectors.nS[1],M=q.TmpVectors.Quaternion[0];let O=0;const u=m.animations[0],b=m.originalValue;let Y=1,V=!1;if(m.totalWeight<1)Y=1-m.totalWeight,b.decompose(l,M,h);else{if(O=1,S=m.totalWeight,Y=u.weight/S,1==Y){if(!m.totalAdditiveWeight)return u.currentValue;V=!0}u.currentValue.decompose(l,M,h)}if(!V){l.scaleInPlace(Y),h.scaleInPlace(Y),M.scaleInPlace(Y);for(let u=O;u<m.animations.length;u++){const O=m.animations[u];if(0===O.weight)continue;Y=O.weight/S;const b=q.TmpVectors.nS[2],V=q.TmpVectors.nS[3],I=q.TmpVectors.Quaternion[1];O.currentValue.decompose(V,I,b),V.scaleAndAddToRef(Y,l),I.scaleAndAddToRef(q.Quaternion.Dot(M,I)>0?Y:-Y,M),b.scaleAndAddToRef(Y,h)}M.normalize()}for(let Z=0;Z<m.additiveAnimations.length;Z++){const S=m.additiveAnimations[Z];if(0===S.weight)continue;const O=q.TmpVectors.nS[2],u=q.TmpVectors.nS[3],b=q.TmpVectors.Quaternion[1];S.currentValue.decompose(u,b,O),u.multiplyToRef(l,u),q.nS.LerpToRef(l,u,S.weight,l),M.multiplyToRef(b,b),q.Quaternion.SlerpToRef(M,b,S.weight,M),O.scaleAndAddToRef(S.weight,h)}const I=u?u._animationState.workValue:q.TmpVectors.Matrix[0].clone();return q.Matrix.ComposeToRef(l,M,h,I),I}function C(m,S){if(0===m.totalWeight&&0===m.totalAdditiveWeight)return S;const h=m.animations[0],l=m.originalValue;let M=S;if(0===m.totalWeight&&m.totalAdditiveWeight>0)M.l(l);else if(1===m.animations.length){if(q.Quaternion.SlerpToRef(l,h.currentValue,Math.min(1,m.totalWeight),M),0===m.totalAdditiveWeight)return M}else if(m.animations.length>1){let h,O,u=1;if(m.totalWeight<1){const S=1-m.totalWeight;h=[],O=[],h.push(l),O.push(S)}else{if(2===m.animations.length&&(q.Quaternion.SlerpToRef(m.animations[0].currentValue,m.animations[1].currentValue,m.animations[1].weight/m.totalWeight,S),0===m.totalAdditiveWeight))return S;h=[],O=[],u=m.totalWeight}for(let S=0;S<m.animations.length;S++){const l=m.animations[S];h.push(l.currentValue),O.push(l.weight/u)}let b=0;for(let m=0;m<h.length;)m?(b+=O[m],q.Quaternion.SlerpToRef(M,h[m],O[m]/b,M),m++):(q.Quaternion.SlerpToRef(h[m],h[m+1],O[m+1]/(O[m]+O[m+1]),S),M=S,b=O[m]+O[m+1],m+=2)}for(let O=0;O<m.additiveAnimations.length;O++){const S=m.additiveAnimations[O];0!==S.weight&&(M.multiplyToRef(S.currentValue,q.TmpVectors.Quaternion[0]),q.Quaternion.SlerpToRef(M,q.TmpVectors.Quaternion[0],S.weight,M))}return M}var B,D,E=h(11567);B=E.c,(D=b.d)&&(D.prototype.copyAnimationRange=function(m,S,h){let M=arguments.length>3&&void 0!==arguments[3]&&arguments[3],O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new l.e(this.name,"_matrix",m.animations[0].framePerSecond,l.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const u=m.animations[0].getRange(S);if(!u)return!1;const b=u.from,q=u.to,Y=m.animations[0].getKeys(),V=m.length,I=m.getParent(),Z=this.getParent(),C=M&&I&&V&&this.length&&V!==this.length,B=C&&Z&&I?Z.length/I.length:1,D=M&&!Z&&O&&(1!==O.x||1!==O.y||1!==O.z),E=this.animations[0].getKeys();let n,L,U;for(let l=0,H=Y.length;l<H;l++)n=Y[l],n.frame>=b&&n.frame<=q&&(M?(U=n.value.clone(),C?(L=U.getTranslation(),U.setTranslation(L.scaleInPlace(B))):D&&O?(L=U.getTranslation(),U.setTranslation(L.multiplyInPlace(O))):U=n.value):U=n.value,E.push({frame:n.frame+h,value:U}));return this.animations[0].createRange(S,b+h,q+h),!0}),B&&(B.prototype._animate=function(m){if(!this.animationsEnabled)return;const S=V.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=S}this.deltaTime=void 0!==m?m:this.useConstantAnimationDeltaTime?16:(S-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=S;const h=this._activeAnimatables;if(0===h.length)return;this._animationTime+=this.deltaTime;const M=this._animationTime;for(let l=0;l<h.length;l++){const m=h[l];!m._animate(M)&&m.disposeOnEnd&&l--}!function(m){if(m._registeredForLateAnimationBindings.length){for(let S=0;S<m._registeredForLateAnimationBindings.length;S++){const h=m._registeredForLateAnimationBindings.data[S];for(const m in h._lateAnimationHolders){const S=h._lateAnimationHolders[m],M=S.animations[0],O=S.originalValue;if(void 0===O||null===O)continue;const u=l.e.AllowMatrixDecomposeForInterpolation&&O.m;let b=h[m];if(u)b=Z(S);else if(void 0!==O.w)b=C(S,b||q.Quaternion.Identity());else{let m=0,h=1;const u=M&&M._animationState.loopMode===l.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(S.totalWeight<1)b=u?O.clone?O.clone():O:M&&O.scale?O.scale(1-S.totalWeight):M?O*(1-S.totalWeight):O.clone?O.clone():O;else if(M){h=S.totalWeight;const l=M.weight/h;b=1!==l?M.currentValue.scale?M.currentValue.scale(l):M.currentValue*l:M.currentValue,u&&(b.addToRef?b.addToRef(O,b):b+=O),m=1}for(let l=m;l<S.animations.length;l++){const m=S.animations[l],M=m.weight/h;M&&(m.currentValue.scaleAndAddToRef?m.currentValue.scaleAndAddToRef(M,b):b+=m.currentValue*M)}for(let l=0;l<S.additiveAnimations.length;l++){const m=S.additiveAnimations[l],h=m.weight;h&&(m.currentValue.scaleAndAddToRef?m.currentValue.scaleAndAddToRef(h,b):b+=m.currentValue*h)}}h[m]=b}h._lateAnimationHolders={}}m._registeredForLateAnimationBindings.reset()}}(this)},B.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((m,S)=>m.playOrder-S.playOrder))},B.prototype.beginWeightedAnimation=function(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,M=arguments.length>4?arguments[4]:void 0,O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,b=arguments.length>7?arguments[7]:void 0,q=arguments.length>8?arguments[8]:void 0,Y=arguments.length>9?arguments[9]:void 0,V=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const I=this.beginAnimation(m,S,h,M,O,u,b,!1,q,Y,V);return I.weight=l,I},B.prototype.beginAnimation=function(m,S,h,l){let M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,O=arguments.length>5?arguments[5]:void 0,u=arguments.length>6?arguments[6]:void 0,b=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],q=arguments.length>8?arguments[8]:void 0,Y=arguments.length>9?arguments[9]:void 0,V=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(M<0){const m=S;S=h,h=m,M=-M}S>h&&(M=-M),b&&this.stopAnimation(m,void 0,q),u||(u=new I(this,m,S,h,l,M,O,void 0,Y,V));const Z=!q||q(m);if(m.animations&&Z&&u.appendAnimations(m,m.animations),m.getAnimatables){const V=m.getAnimatables();for(let m=0;m<V.length;m++)this.beginAnimation(V[m],S,h,l,M,O,u,b,q,Y)}return u.reset(),u},B.prototype.beginHierarchyAnimation=function(m,S,h,l,M){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,b=arguments.length>7?arguments[7]:void 0,q=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],Y=arguments.length>9?arguments[9]:void 0,V=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const I=m.getDescendants(S),Z=[];Z.push(this.beginAnimation(m,h,l,M,O,u,b,q,Y,void 0,V));for(const C of I)Z.push(this.beginAnimation(C,h,l,M,O,u,b,q,Y,void 0,V));return Z},B.prototype.beginDirectAnimation=function(m,S,h,l,M){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(O<0){const m=h;h=l,l=m,O=-O}return h>l&&(O=-O),new I(this,m,h,l,M,O,arguments.length>6?arguments[6]:void 0,S,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},B.prototype.beginDirectHierarchyAnimation=function(m,S,h,l,M,O,u,b,q){let Y=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const V=m.getDescendants(S),I=[];I.push(this.beginDirectAnimation(m,h,l,M,O,u,b,q,Y));for(const Z of V)I.push(this.beginDirectAnimation(Z,h,l,M,O,u,b,q,Y));return I},B.prototype.getAnimatableByTarget=function(m){for(let S=0;S<this._activeAnimatables.length;S++)if(this._activeAnimatables[S].target===m)return this._activeAnimatables[S];return null},B.prototype.getAllAnimatablesByTarget=function(m){const S=[];for(let h=0;h<this._activeAnimatables.length;h++)this._activeAnimatables[h].target===m&&S.push(this._activeAnimatables[h]);return S},B.prototype.stopAnimation=function(m,S,h){const l=this.getAllAnimatablesByTarget(m);for(const M of l)M.stop(S,h)},B.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let m=0;m<this._activeAnimatables.length;m++)this._activeAnimatables[m].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const m of this.animationGroups)m.stop()});class n{getClassName(){return"TargetedAnimation"}serialize(){const m={};return m.animation=this.animation.serialize(),m.targetId=this.target.id,m}}class L{get mask(){return this._mask}set mask(m){this._mask!==m&&(this._mask=m,this.syncWithMask(!0))}syncWithMask(){let m=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||m){this._numActiveAnimatables=0;for(let m=0;m<this._animatables.length;++m){const S=this._animatables[m];!this.mask||this.mask.disabled||this.mask.retainsTarget(S.target.name)?(this._numActiveAnimatables++,S.paused&&S.restart()):S.paused||S.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let m=0;m<this._animatables.length;++m){const S=this._animatables[m];this.mask.retainsTarget(S.target.name)||(S.stop(),this._animatables.splice(m,1),--m)}for(let m=0;m<this._targetedAnimations.length;m++){const S=this._targetedAnimations[m];this.mask.retainsTarget(S.target.name)||(this._targetedAnimations.splice(m,1),--m)}}}get from(){return this._from}set from(m){if(this._from!==m){this._from=m;for(let m=0;m<this._animatables.length;m++){this._animatables[m].fromFrame=this._from}}}get to(){return this._to}set to(m){if(this._to!==m){this._to=m;for(let m=0;m<this._animatables.length;m++){this._animatables[m].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(m){if(this._speedRatio!==m){this._speedRatio=m;for(let m=0;m<this._animatables.length;m++){this._animatables[m].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(m){if(this._loopAnimation!==m){this._loopAnimation=m;for(let m=0;m<this._animatables.length;m++){this._animatables[m].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(m){if(this._isAdditive!==m){this._isAdditive=m;for(let m=0;m<this._animatables.length;m++){this._animatables[m].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(m){this._weight!==m&&(this._weight=m,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(m){if(this._playOrder!==m&&(this._playOrder=m,this._animatables.length>0)){for(let m=0;m<this._animatables.length;m++)this._animatables[m].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(m){if(this._enableBlending!==m&&(this._enableBlending=m,null!==m))for(let S=0;S<this._targetedAnimations.length;++S)this._targetedAnimations[S].animation.enableBlending=m}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(m){if(this._blendingSpeed!==m&&(this._blendingSpeed=m,null!==m))for(let S=0;S<this._targetedAnimations.length;++S)this._targetedAnimations[S].animation.blendingSpeed=m}getLength(m,S){m=m??this._from;return((S=S??this._to)-m)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(m){let S=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],l=arguments.length>3?arguments[3]:void 0;if(0===m.length)return null;l=l??m[0].weight;let M=Number.MAX_VALUE,O=-Number.MAX_VALUE;if(h)for(const b of m)b.from<M&&(M=b.from),b.to>O&&(O=b.to);const u=new L(m[0].name+"_merged",m[0]._scene,l);for(const b of m){h&&b.normalize(M,O);for(const m of b.targetedAnimations)u.addTargetedAnimation(m.animation,m.target);S&&b.dispose()}return u}constructor(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=m,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new M.e,this.onAnimationLoopObservable=new M.e,this.onAnimationGroupLoopObservable=new M.e,this.onAnimationGroupEndObservable=new M.e,this.onAnimationGroupPauseObservable=new M.e,this.onAnimationGroupPlayObservable=new M.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=S||O.d.LastCreatedScene,this._weight=h,this._playOrder=l,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(m,S){const h=new n;h.animation=m,h.target=S;const l=m.getKeys();return this._from>l[0].frame&&(this._from=l[0].frame),this._to<l[l.length-1].frame&&(this._to=l[l.length-1].frame),null!==this._enableBlending&&(m.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(m.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(h),this._shouldStart=!0,h}removeTargetedAnimation(m){for(let S=this._targetedAnimations.length-1;S>-1;S--){this._targetedAnimations[S].animation===m&&this._targetedAnimations.splice(S,1)}}normalize(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==m&&(m=this._from),null==S&&(S=this._to);for(let h=0;h<this._targetedAnimations.length;h++){const l=this._targetedAnimations[h].animation.getKeys(),M=l[0],O=l[l.length-1];if(M.frame>m){const S={frame:m,value:M.value,inTangent:M.inTangent,outTangent:M.outTangent,interpolation:M.interpolation};l.splice(0,0,S)}if(O.frame<S){const m={frame:S,value:O.value,inTangent:O.inTangent,outTangent:O.outTangent,interpolation:O.interpolation};l.push(m)}}return this._from=m,this._to=S,this}_processLoop(m,S,h){m.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(S),this._animationLoopFlags[h]||(this._animationLoopFlags[h]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let m=arguments.length>0&&void 0!==arguments[0]&&arguments[0],S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0,l=arguments.length>3?arguments[3]:void 0,M=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=m,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let O=0;O<this._targetedAnimations.length;O++){const u=this._targetedAnimations[O],b=this._scene.beginDirectAnimation(u.target,[u.animation],void 0!==h?h:this._from,void 0!==l?l:this._to,m,S,void 0,void 0,void 0!==M?M:this._isAdditive);b.weight=this._weight,b.playOrder=this._playOrder,b.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(u),this._checkAnimationGroupEnded(b)},this._processLoop(b,u,O),this._animatables.push(b)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=S,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let m=0;m<this._animatables.length;m++){this._animatables[m].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(m){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==m&&(this.loopAnimation=m),this.restart()):(this.stop(),this.start(m,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let m=0;m<this._animatables.length;m++){this._animatables[m].reset()}return this}restart(){if(!this._isStarted)return this;for(let m=0;m<this._animatables.length;m++){this._animatables[m].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let m=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const S=this._animatables.slice();for(let l=0;l<S.length;l++)S[l].stop(void 0,void 0,!0,m);let h=0;for(let l=0;l<this._scene._activeAnimatables.length;l++){const S=this._scene._activeAnimatables[l];S._runtimeAnimations.length>0?this._scene._activeAnimatables[h++]=S:m&&this._checkAnimationGroupEnded(S,m)}return this._scene._activeAnimatables.length=h,this._isStarted=!1,this}setWeightForAllAnimatables(m){for(let S=0;S<this._animatables.length;S++){this._animatables[S].weight=m}return this}syncAllAnimationsWith(m){for(let S=0;S<this._animatables.length;S++){this._animatables[S].syncWith(m)}return this}goToFrame(m){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let h=0;h<this._animatables.length;h++){this._animatables[h].goToFrame(m,S)}return this}getCurrentFrame(){var m;return(null===(m=this.animatables[0])||void 0===m?void 0:m.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const m=this._scene.animationGroups.indexOf(this);if(m>-1&&this._scene.animationGroups.splice(m,1),this._parentContainer){const m=this._parentContainer.animationGroups.indexOf(this);m>-1&&this._parentContainer.animationGroups.splice(m,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(m){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const h=this._animatables.indexOf(m);h>-1&&this._animatables.splice(h,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,S||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(m,S){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const l=new L(m||this.name,this._scene,this._weight,this._playOrder);l._from=this.from,l._to=this.to,l._speedRatio=this.speedRatio,l._loopAnimation=this.loopAnimation,l._isAdditive=this.isAdditive,l._enableBlending=this.enableBlending,l._blendingSpeed=this.blendingSpeed,l.metadata=this.metadata,l.mask=this.mask;for(const M of this._targetedAnimations)l.addTargetedAnimation(h?M.animation.clone():M.animation,S?S(M.target):M.target);return l}serialize(){const m={};m.name=this.name,m.from=this.from,m.to=this.to,m.speedRatio=this.speedRatio,m.loopAnimation=this.loopAnimation,m.isAdditive=this.isAdditive,m.weight=this.weight,m.playOrder=this.playOrder,m.enableBlending=this.enableBlending,m.blendingSpeed=this.blendingSpeed,m.targetedAnimations=[];for(let S=0;S<this.targetedAnimations.length;S++){const h=this.targetedAnimations[S];m.targetedAnimations[S]=h.serialize()}return u.b&&u.b.HasTags(this)&&(m.tags=u.b.GetTags(this)),this.metadata&&(m.metadata=this.metadata),m}static Parse(m,S){const h=new L(m.name,S,m.weight,m.playOrder);for(let M=0;M<m.targetedAnimations.length;M++){const O=m.targetedAnimations[M],u=l.e.Parse(O.animation),b=O.targetId;if("influence"===O.animation.property){const m=S.getMorphTargetById(b);m&&h.addTargetedAnimation(u,m)}else{const m=S.getNodeById(b);null!=m&&h.addTargetedAnimation(u,m)}}return u.b&&u.b.AddTagsTo(h,m.tags),null!==m.from&&null!==m.to&&h.normalize(m.from,m.to),void 0!==m.speedRatio&&(h._speedRatio=m.speedRatio),void 0!==m.loopAnimation&&(h._loopAnimation=m.loopAnimation),void 0!==m.isAdditive&&(h._isAdditive=m.isAdditive),void 0!==m.weight&&(h._weight=m.weight),void 0!==m.playOrder&&(h._playOrder=m.playOrder),void 0!==m.enableBlending&&(h._enableBlending=m.enableBlending),void 0!==m.blendingSpeed&&(h._blendingSpeed=m.blendingSpeed),void 0!==m.metadata&&(h.metadata=m.metadata),h}static MakeAnimationAdditive(m,S,h){let M;M="object"===typeof S?S:{referenceFrame:S,range:h,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let O=m;M.cloneOriginalAnimationGroup&&(O=m.clone(M.clonedAnimationGroupName||O.name));const u=O.targetedAnimations;for(let b=0;b<u.length;b++){const m=u[b];m.animation=l.e.MakeAnimationAdditive(m.animation,M)}if(O.isAdditive=!0,M.clipKeys){let m=Number.MAX_VALUE,S=-Number.MAX_VALUE;const h=O.targetedAnimations;for(let l=0;l<h.length;l++){const M=h[l].animation.getKeys();m>M[0].frame&&(m=M[0].frame),S<M[M.length-1].frame&&(S=M[M.length-1].frame)}O._from=m,O._to=S}return O}static ClipKeys(m,S,h,l,M){const O=m.clone(l||m.name);return L.ClipKeysInPlace(O,S,h,M)}static ClipKeysInPlace(m,S,h,l){return L.ClipInPlace(m,S,h,l,!1)}static ClipFrames(m,S,h,l,M){const O=m.clone(l||m.name);return L.ClipFramesInPlace(O,S,h,M)}static ClipFramesInPlace(m,S,h,l){return L.ClipInPlace(m,S,h,l,!0)}static ClipInPlace(m,S,h,l){let M=arguments.length>4&&void 0!==arguments[4]&&arguments[4],O=Number.MAX_VALUE,u=-Number.MAX_VALUE;const b=m.targetedAnimations;for(let q=0;q<b.length;q++){const m=b[q],Y=l?m.animation:m.animation.clone();M&&(Y.createKeyForFrame(S),Y.createKeyForFrame(h));const V=Y.getKeys(),I=[];let Z=Number.MAX_VALUE;for(let l=0;l<V.length;l++){const m=V[l];if(!M&&l>=S&&l<=h||M&&m.frame>=S&&m.frame<=h){const S={frame:m.frame,value:m.value.clone?m.value.clone():m.value,inTangent:m.inTangent,outTangent:m.outTangent,interpolation:m.interpolation,lockedTangent:m.lockedTangent};Z===Number.MAX_VALUE&&(Z=S.frame),S.frame-=Z,I.push(S)}}0!==I.length?(O>I[0].frame&&(O=I[0].frame),u<I[I.length-1].frame&&(u=I[I.length-1].frame),Y.setKeys(I,!0),m.animation=Y):(b.splice(q,1),q--)}return m._from=O,m._to=u,m}getClassName(){return"AnimationGroup"}toString(m){let S="Name: "+this.name;return S+=", type: "+this.getClassName(),m&&(S+=", from: "+this._from,S+=", to: "+this._to,S+=", isStarted: "+this._isStarted,S+=", speedRatio: "+this._speedRatio,S+=", targetedAnimations length: "+this._targetedAnimations.length,S+=", animatables length: "+this._animatables),S}}}}]);