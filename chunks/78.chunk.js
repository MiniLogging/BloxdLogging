"use strict";(self.v2pspxy442l=self.v2pspxy442l||[]).push([[78],{15594:(l,a,N)=>{N.r(a),N.d(a,{AnimationGroup:()=>C,TargetedAnimation:()=>Y});var U=N(12950),c=N(12260),K=N(12296),Z=N(12473),w=N(14063),S=N(12447);class T{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(l,a,N,c){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=a,this._target=l,this._scene=N,this._host=c,this._activeTargets=[],a._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===U.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=S.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const l={frame:0,value:this._minValue};this._keys.splice(0,0,l)}if(this._target instanceof Array){let l=0;for(const a of this._target)this._preparePath(a,l),this._getOriginalValues(l),l++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const K=a.getEvents();if(K&&K.length>0)for(const U of K)this._events.push(U._clone());this._enableBlending=l&&l.animationPropertiesOverride?l.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const N=this._animation.targetPropertyPath;if(N.length>1){let U=l;for(let l=0;l<N.length-1;l++){const a=N[l];if(U=U[a],void 0===U)throw new Error(`Invalid property (${a}) in property path (${N.join(".")})`)}this._targetPath=N[N.length-1],this._activeTargets[a]=U}else this._targetPath=N[0],this._activeTargets[a]=l;if(void 0===this._activeTargets[a][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${N.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let l=0;for(const a of this._target)void 0!==this._originalValue[l]&&this._setValue(a,this._activeTargets[l],this._originalValue[l],-1,l),l++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let l=0;l<this._events.length;l++)this._events[l].isDone=!1}isStopped(){return this._stopped}dispose(){const l=this._animation.runtimeAnimations.indexOf(this);l>-1&&this._animation.runtimeAnimations.splice(l,1)}setValue(l,a){if(this._targetIsArray)for(let N=0;N<this._target.length;N++){const U=this._target[N];this._setValue(U,this._activeTargets[N],l,a,N)}else this._setValue(this._target,this._directTarget,l,a,0)}_getOriginalValues(){let l,a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const N=this._activeTargets[a];l=N.getLocalMatrix&&"_matrix"===this._targetPath?N.getLocalMatrix():N[this._targetPath],l&&l.clone?this._originalValue[a]=l.clone():this._originalValue[a]=l}_registerTargetForLateAnimationBinding(l,a){const N=l.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(N),N._lateAnimationHolders||(N._lateAnimationHolders={}),N._lateAnimationHolders[l.targetPath]||(N._lateAnimationHolders[l.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:a}),l.isAdditive?(N._lateAnimationHolders[l.targetPath].additiveAnimations.push(l),N._lateAnimationHolders[l.targetPath].totalAdditiveWeight+=l.weight):(N._lateAnimationHolders[l.targetPath].animations.push(l),N._lateAnimationHolders[l.targetPath].totalWeight+=l.weight)}_setValue(l,a,N,c,K){if(this._currentActiveTarget=a,this._weight=c,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const l=a[this._targetPath];l.clone?this._originalBlendValue=l.clone():this._originalBlendValue=l}this._originalBlendValue.m?U.d.AllowMatrixDecomposeForInterpolation?this._currentValue?S.Matrix.DecomposeLerpToRef(this._originalBlendValue,N,this._blendingFactor,this._currentValue):this._currentValue=S.Matrix.DecomposeLerp(this._originalBlendValue,N,this._blendingFactor):this._currentValue?S.Matrix.LerpToRef(this._originalBlendValue,N,this._blendingFactor,this._currentValue):this._currentValue=S.Matrix.Lerp(this._originalBlendValue,N,this._blendingFactor):this._currentValue=U.d._UniversalLerp(this._originalBlendValue,N,this._blendingFactor);const c=l&&l.animationPropertiesOverride?l.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=c}else this._currentValue?this._currentValue.K?this._currentValue.K(N):this._currentValue=N:null!==N&&void 0!==N&&N.clone?this._currentValue=N.clone():this._currentValue=N;-1!==c?this._registerTargetForLateAnimationBinding(this,this._originalValue[K]):this._animationState.loopMode===U.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[K],a[this._targetPath]):a[this._targetPath]=this._originalValue[K]+this._currentValue:a[this._targetPath]=this._currentValue,l.DT&&l.DT(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const N=this._animation.getKeys();l<N[0].frame?l=N[0].frame:l>N[N.length-1].frame&&(l=N[N.length-1].frame);const U=this._events;if(U.length)for(let K=0;K<U.length;K++)U[K].onlyOnce||(U[K].isDone=U[K].frame<l);this._currentFrame=l;const c=this._animation._interpolate(l,this._animationState);this.setValue(c,a)}_prepareForSpeedRatioChange(l){const a=this._previousElapsedTime*(this._animation.framePerSecond*l)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-a}animate(l,a,N,c,K){let Z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const w=this._animation,S=w.targetPropertyPath;if(!S||S.length<1)return this._stopped=!0,!1;let T,J=!0;const n=this._events;let y=0;if(this._coreRuntimeAnimation)y=N-a,T=this._coreRuntimeAnimation.currentFrame,this._currentFrame=T,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let Z;(a<this._minFrame||a>this._maxFrame)&&(a=this._minFrame),(N<this._minFrame||N>this._maxFrame)&&(N=this._maxFrame),y=N-a;let S=l*(w.framePerSecond*K)/1e3+this._absoluteFrameOffset,H=0,u=!1;const W=c&&this._animationState.loopMode===U.d.ANIMATIONLOOPMODE_YOYO;if(W){const l=(S-a)/y,N=Math.sin(l*Math.PI);S=Math.abs(N)*y+a;const U=N>=0?1:-1;this._yoyoDirection!==U&&(u=!0),this._yoyoDirection=U}if(this._previousElapsedTime=l,this._previousAbsoluteFrame=S,!c&&N>=a&&(S>=y&&K>0||S<=0&&K<0))J=!1,H=w._getKeyValue(this._maxValue);else if(!c&&a>=N&&(S<=y&&K<0||S>=0&&K>0))J=!1,H=w._getKeyValue(this._minValue);else if(this._animationState.loopMode!==U.d.ANIMATIONLOOPMODE_CYCLE){const l=N.toString()+a.toString();if(!this._offsetsCache[l]){this._animationState.repeatCount=0,this._animationState.loopMode=U.d.ANIMATIONLOOPMODE_CYCLE;const c=w._interpolate(a,this._animationState),K=w._interpolate(N,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),w.dataType){case U.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[l]=K-c;break;case U.d.ANIMATIONTYPE_QUATERNION:case U.d.ANIMATIONTYPE_VECTOR3:case U.d.ANIMATIONTYPE_VECTOR2:case U.d.ANIMATIONTYPE_SIZE:case U.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[l]=K.Wa(c)}this._highLimitsCache[l]=K}H=this._highLimitsCache[l],Z=this._offsetsCache[l]}if(void 0===Z)switch(w.dataType){case U.d.ANIMATIONTYPE_FLOAT:Z=0;break;case U.d.ANIMATIONTYPE_QUATERNION:Z=U.m;break;case U.d.ANIMATIONTYPE_VECTOR3:Z=U.w;break;case U.d.ANIMATIONTYPE_VECTOR2:Z=U.s;break;case U.d.ANIMATIONTYPE_SIZE:Z=U.o;break;case U.d.ANIMATIONTYPE_COLOR3:Z=U.h;break;case U.d.ANIMATIONTYPE_COLOR4:Z=U.i}if(this._host&&this._host.syncRoot){const l=this._host.syncRoot;T=a+y*((l.masterFrame-l.fromFrame)/(l.toFrame-l.fromFrame))}else T=S>0&&a>N||S<0&&a<N?J&&0!==y?N+S%y:a:J&&0!==y?a+S%y:N;if(!W&&(K>0&&this.currentFrame>T||K<0&&this.currentFrame<T)||W&&u){this._onLoop();for(let l=0;l<n.length;l++)n[l].onlyOnce||(n[l].isDone=!1);this._animationState.key=K>0?0:w.getKeys().length-1}this._currentFrame=T,this._animationState.repeatCount=0===y?0:S/y|0,this._animationState.highLimitValue=H,this._animationState.offsetValue=Z}const H=w._interpolate(T,this._animationState);if(this.setValue(H,Z),n.length)for(let U=0;U<n.length;U++)if(y>=0&&T>=n[U].frame&&n[U].frame>=a||y<0&&T<=n[U].frame&&n[U].frame<=a){const l=n[U];l.isDone||(l.onlyOnce&&(n.splice(U,1),U--),l.isDone=!0,l.action(T))}return J||(this._stopped=!0),J}}var J=N(12283);class n{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(l){this._weight=-1!==l?Math.min(Math.max(l,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(l){for(let a=0;a<this._runtimeAnimations.length;a++){this._runtimeAnimations[a]._prepareForSpeedRatioChange(l)}this._speedRatio=l,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(l,a){let N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,K=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,w=arguments.length>6?arguments[6]:void 0,S=arguments.length>7?arguments[7]:void 0,T=arguments.length>8?arguments[8]:void 0,J=arguments.length>9&&void 0!==arguments[9]&&arguments[9],n=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=a,this.fromFrame=N,this.toFrame=U,this.loopAnimation=K,this.onAnimationEnd=w,this.onAnimationLoop=T,this.isAdditive=J,this.playOrder=n,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.fw=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new c.e,this.onAnimationLoopObservable=new c.e,this._scene=l,S&&this.appendAnimations(a,S),this._speedRatio=Z,l._activeAnimatables.push(this)}syncWith(l){if(this._syncRoot=l,l){const l=this._scene._activeAnimatables.indexOf(this);l>-1&&(this._scene._activeAnimatables.splice(l,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(l,a){for(let N=0;N<a.length;N++){const U=a[N],c=new T(l,U,this._scene,this);c._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(c)}}getAnimationByTargetProperty(l){const a=this._runtimeAnimations;for(let N=0;N<a.length;N++)if(a[N].animation.targetProperty===l)return a[N].animation;return null}getRuntimeAnimationByTargetProperty(l){const a=this._runtimeAnimations;for(let N=0;N<a.length;N++)if(a[N].animation.targetProperty===l)return a[N];return null}reset(){const l=this._runtimeAnimations;for(let a=0;a<l.length;a++)l[a].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(l){const a=this._runtimeAnimations;for(let N=0;N<a.length;N++)a[N].animation.enableBlending=!0,a[N].animation.blendingSpeed=l}disableBlending(){const l=this._runtimeAnimations;for(let a=0;a<l.length;a++)l[a].animation.enableBlending=!1}goToFrame(l){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const N=this._runtimeAnimations;if(N[0]){const a=N[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??N[0].currentFrame;const U=0===this.speedRatio?0:(l-this._frameToSyncFromJump)/a*1e3/this.speedRatio;this._manualJumpDelay=-U}for(let U=0;U<N.length;U++)N[U].goToFrame(l,a?this._weight:-1);this._goToFrame=l}get paused(){return this.fw}pause(){this.fw||(this.fw=!0)}restart(){this.fw=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(l,a){let N=arguments.length>2&&void 0!==arguments[2]&&arguments[2],U=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(l||a){const c=this._scene._activeAnimatables.indexOf(this);if(c>-1){const K=this._runtimeAnimations;for(let N=K.length-1;N>=0;N--){const U=K[N];l&&U.animation.name!=l||(a&&!a(U.target)||(U.dispose(),K.splice(N,1)))}0==K.length&&(N||this._scene._activeAnimatables.splice(c,1),U||this._raiseOnAnimationEnd())}}else{const l=this._scene._activeAnimatables.indexOf(this);if(l>-1){N||this._scene._activeAnimatables.splice(l,1);const a=this._runtimeAnimations;for(let l=0;l<a.length;l++)a[l].dispose();this._runtimeAnimations.length=0,U||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((l=>{this.onAnimationEndObservable.add((()=>{l(this)}),void 0,void 0,this,!0)}))}_animate(l){if(this.fw)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=l),!0;if(null===this._localDelayOffset?(this._localDelayOffset=l,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=l-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let a=!1;const N=this._runtimeAnimations;let U;for(U=0;U<N.length;U++){const c=N[U].animate(l-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);a=a||c}if(this.animationStarted=a,!a){if(this.disposeOnEnd)for(U=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(U,1),U=0;U<N.length;U++)N[U].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return a}}function y(l){if(0===l.totalWeight&&0===l.totalAdditiveWeight)return l.originalValue;let a=1;const N=S.TmpVectors.ua[0],U=S.TmpVectors.ua[1],c=S.TmpVectors.Quaternion[0];let K=0;const Z=l.animations[0],w=l.originalValue;let T=1,J=!1;if(l.totalWeight<1)T=1-l.totalWeight,w.decompose(U,c,N);else{if(K=1,a=l.totalWeight,T=Z.weight/a,1==T){if(!l.totalAdditiveWeight)return Z.currentValue;J=!0}Z.currentValue.decompose(U,c,N)}if(!J){U.scaleInPlace(T),N.scaleInPlace(T),c.scaleInPlace(T);for(let Z=K;Z<l.animations.length;Z++){const K=l.animations[Z];if(0===K.weight)continue;T=K.weight/a;const w=S.TmpVectors.ua[2],J=S.TmpVectors.ua[3],n=S.TmpVectors.Quaternion[1];K.currentValue.decompose(J,n,w),J.scaleAndAddToRef(T,U),n.scaleAndAddToRef(S.Quaternion.Dot(c,n)>0?T:-T,c),w.scaleAndAddToRef(T,N)}c.normalize()}for(let y=0;y<l.additiveAnimations.length;y++){const a=l.additiveAnimations[y];if(0===a.weight)continue;const K=S.TmpVectors.ua[2],Z=S.TmpVectors.ua[3],w=S.TmpVectors.Quaternion[1];a.currentValue.decompose(Z,w,K),Z.multiplyToRef(U,Z),S.ua.LerpToRef(U,Z,a.weight,U),c.multiplyToRef(w,w),S.Quaternion.SlerpToRef(c,w,a.weight,c),K.scaleAndAddToRef(a.weight,N)}const n=Z?Z._animationState.workValue:S.TmpVectors.Matrix[0].clone();return S.Matrix.ComposeToRef(U,c,N,n),n}function H(l,a){if(0===l.totalWeight&&0===l.totalAdditiveWeight)return a;const N=l.animations[0],U=l.originalValue;let c=a;if(0===l.totalWeight&&l.totalAdditiveWeight>0)c.K(U);else if(1===l.animations.length){if(S.Quaternion.SlerpToRef(U,N.currentValue,Math.min(1,l.totalWeight),c),0===l.totalAdditiveWeight)return c}else if(l.animations.length>1){let N,K,Z=1;if(l.totalWeight<1){const a=1-l.totalWeight;N=[],K=[],N.push(U),K.push(a)}else{if(2===l.animations.length&&(S.Quaternion.SlerpToRef(l.animations[0].currentValue,l.animations[1].currentValue,l.animations[1].weight/l.totalWeight,a),0===l.totalAdditiveWeight))return a;N=[],K=[],Z=l.totalWeight}for(let a=0;a<l.animations.length;a++){const U=l.animations[a];N.push(U.currentValue),K.push(U.weight/Z)}let w=0;for(let l=0;l<N.length;)l?(w+=K[l],S.Quaternion.SlerpToRef(c,N[l],K[l]/w,c),l++):(S.Quaternion.SlerpToRef(N[l],N[l+1],K[l+1]/(K[l]+K[l+1]),a),c=a,w=K[l]+K[l+1],l+=2)}for(let K=0;K<l.additiveAnimations.length;K++){const a=l.additiveAnimations[K];0!==a.weight&&(c.multiplyToRef(a.currentValue,S.TmpVectors.Quaternion[0]),S.Quaternion.SlerpToRef(c,S.TmpVectors.Quaternion[0],a.weight,c))}return c}var u,W,B=N(12678);u=B.d,(W=w.c)&&(W.prototype.copyAnimationRange=function(l,a,N){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3],K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new U.d(this.name,"_matrix",l.animations[0].framePerSecond,U.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Z=l.animations[0].getRange(a);if(!Z)return!1;const w=Z.from,S=Z.to,T=l.animations[0].getKeys(),J=l.length,n=l.getParent(),y=this.getParent(),H=c&&n&&J&&this.length&&J!==this.length,u=H&&y&&n?y.length/n.length:1,W=c&&!y&&K&&(1!==K.x||1!==K.y||1!==K.z),B=this.animations[0].getKeys();let Y,C,M;for(let U=0,A=T.length;U<A;U++)Y=T[U],Y.frame>=w&&Y.frame<=S&&(c?(M=Y.value.clone(),H?(C=M.getTranslation(),M.setTranslation(C.scaleInPlace(u))):W&&K?(C=M.getTranslation(),M.setTranslation(C.multiplyInPlace(K))):M=Y.value):M=Y.value,B.push({frame:Y.frame+N,value:M}));return this.animations[0].createRange(a,w+N,S+N),!0}),u&&(u.prototype._animate=function(l){if(!this.animationsEnabled)return;const a=J.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=a}this.deltaTime=void 0!==l?l:this.useConstantAnimationDeltaTime?16:(a-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=a;const N=this._activeAnimatables;if(0===N.length)return;this._animationTime+=this.deltaTime;const c=this._animationTime;for(let U=0;U<N.length;U++){const l=N[U];!l._animate(c)&&l.disposeOnEnd&&U--}!function(l){if(l._registeredForLateAnimationBindings.length){for(let a=0;a<l._registeredForLateAnimationBindings.length;a++){const N=l._registeredForLateAnimationBindings.data[a];for(const l in N._lateAnimationHolders){const a=N._lateAnimationHolders[l],c=a.animations[0],K=a.originalValue;if(void 0===K||null===K)continue;const Z=U.d.AllowMatrixDecomposeForInterpolation&&K.m;let w=N[l];if(Z)w=y(a);else if(void 0!==K.w)w=H(a,w||S.Quaternion.Identity());else{let l=0,N=1;const Z=c&&c._animationState.loopMode===U.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(a.totalWeight<1)w=Z?K.clone?K.clone():K:c&&K.scale?K.scale(1-a.totalWeight):c?K*(1-a.totalWeight):K.clone?K.clone():K;else if(c){N=a.totalWeight;const U=c.weight/N;w=1!==U?c.currentValue.scale?c.currentValue.scale(U):c.currentValue*U:c.currentValue,Z&&(w.addToRef?w.addToRef(K,w):w+=K),l=1}for(let U=l;U<a.animations.length;U++){const l=a.animations[U],c=l.weight/N;c&&(l.currentValue.scaleAndAddToRef?l.currentValue.scaleAndAddToRef(c,w):w+=l.currentValue*c)}for(let U=0;U<a.additiveAnimations.length;U++){const l=a.additiveAnimations[U],N=l.weight;N&&(l.currentValue.scaleAndAddToRef?l.currentValue.scaleAndAddToRef(N,w):w+=l.currentValue*N)}}N[l]=w}N._lateAnimationHolders={}}l._registeredForLateAnimationBindings.reset()}}(this)},u.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((l,a)=>l.playOrder-a.playOrder))},u.prototype.beginWeightedAnimation=function(l,a,N){let U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,c=arguments.length>4?arguments[4]:void 0,K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Z=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,S=arguments.length>8?arguments[8]:void 0,T=arguments.length>9?arguments[9]:void 0,J=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const n=this.beginAnimation(l,a,N,c,K,Z,w,!1,S,T,J);return n.weight=U,n},u.prototype.beginAnimation=function(l,a,N,U){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,K=arguments.length>5?arguments[5]:void 0,Z=arguments.length>6?arguments[6]:void 0,w=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],S=arguments.length>8?arguments[8]:void 0,T=arguments.length>9?arguments[9]:void 0,J=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(c<0){const l=a;a=N,N=l,c=-c}a>N&&(c=-c),w&&this.stopAnimation(l,void 0,S),Z||(Z=new n(this,l,a,N,U,c,K,void 0,T,J));const y=!S||S(l);if(l.animations&&y&&Z.appendAnimations(l,l.animations),l.getAnimatables){const J=l.getAnimatables();for(let l=0;l<J.length;l++)this.beginAnimation(J[l],a,N,U,c,K,Z,w,S,T)}return Z.reset(),Z},u.prototype.beginHierarchyAnimation=function(l,a,N,U,c){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Z=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,S=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],T=arguments.length>9?arguments[9]:void 0,J=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const n=l.getDescendants(a),y=[];y.push(this.beginAnimation(l,N,U,c,K,Z,w,S,T,void 0,J));for(const H of n)y.push(this.beginAnimation(H,N,U,c,K,Z,w,S,T,void 0,J));return y},u.prototype.beginDirectAnimation=function(l,a,N,U,c){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(K<0){const l=N;N=U,U=l,K=-K}return N>U&&(K=-K),new n(this,l,N,U,c,K,arguments.length>6?arguments[6]:void 0,a,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},u.prototype.beginDirectHierarchyAnimation=function(l,a,N,U,c,K,Z,w,S){let T=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const J=l.getDescendants(a),n=[];n.push(this.beginDirectAnimation(l,N,U,c,K,Z,w,S,T));for(const y of J)n.push(this.beginDirectAnimation(y,N,U,c,K,Z,w,S,T));return n},u.prototype.getAnimatableByTarget=function(l){for(let a=0;a<this._activeAnimatables.length;a++)if(this._activeAnimatables[a].target===l)return this._activeAnimatables[a];return null},u.prototype.getAllAnimatablesByTarget=function(l){const a=[];for(let N=0;N<this._activeAnimatables.length;N++)this._activeAnimatables[N].target===l&&a.push(this._activeAnimatables[N]);return a},u.prototype.stopAnimation=function(l,a,N){const U=this.getAllAnimatablesByTarget(l);for(const c of U)c.stop(a,N)},u.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let l=0;l<this._activeAnimatables.length;l++)this._activeAnimatables[l].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const l of this.animationGroups)l.stop()});class Y{getClassName(){return"TargetedAnimation"}serialize(){const l={};return l.animation=this.animation.serialize(),l.targetId=this.target.id,l}}class C{get mask(){return this._mask}set mask(l){this._mask!==l&&(this._mask=l,this.syncWithMask(!0))}syncWithMask(){let l=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||l){this._numActiveAnimatables=0;for(let l=0;l<this._animatables.length;++l){const a=this._animatables[l];!this.mask||this.mask.disabled||this.mask.retainsTarget(a.target.name)?(this._numActiveAnimatables++,a.paused&&a.restart()):a.paused||a.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let l=0;l<this._animatables.length;++l){const a=this._animatables[l];this.mask.retainsTarget(a.target.name)||(a.stop(),this._animatables.splice(l,1),--l)}for(let l=0;l<this._targetedAnimations.length;l++){const a=this._targetedAnimations[l];this.mask.retainsTarget(a.target.name)||(this._targetedAnimations.splice(l,1),--l)}}}get from(){return this._from}set from(l){if(this._from!==l){this._from=l;for(let l=0;l<this._animatables.length;l++){this._animatables[l].fromFrame=this._from}}}get to(){return this._to}set to(l){if(this._to!==l){this._to=l;for(let l=0;l<this._animatables.length;l++){this._animatables[l].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(l){if(this._speedRatio!==l){this._speedRatio=l;for(let l=0;l<this._animatables.length;l++){this._animatables[l].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(l){if(this._loopAnimation!==l){this._loopAnimation=l;for(let l=0;l<this._animatables.length;l++){this._animatables[l].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(l){if(this._isAdditive!==l){this._isAdditive=l;for(let l=0;l<this._animatables.length;l++){this._animatables[l].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(l){this._weight!==l&&(this._weight=l,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(l){if(this._playOrder!==l&&(this._playOrder=l,this._animatables.length>0)){for(let l=0;l<this._animatables.length;l++)this._animatables[l].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(l){if(this._enableBlending!==l&&(this._enableBlending=l,null!==l))for(let a=0;a<this._targetedAnimations.length;++a)this._targetedAnimations[a].animation.enableBlending=l}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(l){if(this._blendingSpeed!==l&&(this._blendingSpeed=l,null!==l))for(let a=0;a<this._targetedAnimations.length;++a)this._targetedAnimations[a].animation.blendingSpeed=l}getLength(l,a){l=l??this._from;return((a=a??this._to)-l)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(l){let a=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],N=arguments.length>2&&void 0!==arguments[2]&&arguments[2],U=arguments.length>3?arguments[3]:void 0;if(0===l.length)return null;U=U??l[0].weight;let c=Number.MAX_VALUE,K=-Number.MAX_VALUE;if(N)for(const w of l)w.from<c&&(c=w.from),w.to>K&&(K=w.to);const Z=new C(l[0].name+"_merged",l[0]._scene,U);for(const w of l){N&&w.normalize(c,K);for(const l of w.targetedAnimations)Z.addTargetedAnimation(l.animation,l.target);a&&w.dispose()}return Z}constructor(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=l,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new c.e,this.onAnimationLoopObservable=new c.e,this.onAnimationGroupLoopObservable=new c.e,this.onAnimationGroupEndObservable=new c.e,this.onAnimationGroupPauseObservable=new c.e,this.onAnimationGroupPlayObservable=new c.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=a||K.e.LastCreatedScene,this._weight=N,this._playOrder=U,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(l,a){const N=new Y;N.animation=l,N.target=a;const U=l.getKeys();return this._from>U[0].frame&&(this._from=U[0].frame),this._to<U[U.length-1].frame&&(this._to=U[U.length-1].frame),null!==this._enableBlending&&(l.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(l.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(N),this._shouldStart=!0,N}removeTargetedAnimation(l){for(let a=this._targetedAnimations.length-1;a>-1;a--){this._targetedAnimations[a].animation===l&&this._targetedAnimations.splice(a,1)}}normalize(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==l&&(l=this._from),null==a&&(a=this._to);for(let N=0;N<this._targetedAnimations.length;N++){const U=this._targetedAnimations[N].animation.getKeys(),c=U[0],K=U[U.length-1];if(c.frame>l){const a={frame:l,value:c.value,inTangent:c.inTangent,outTangent:c.outTangent,interpolation:c.interpolation};U.splice(0,0,a)}if(K.frame<a){const l={frame:a,value:K.value,inTangent:K.inTangent,outTangent:K.outTangent,interpolation:K.interpolation};U.push(l)}}return this._from=l,this._to=a,this}_processLoop(l,a,N){l.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(a),this._animationLoopFlags[N]||(this._animationLoopFlags[N]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let l=arguments.length>0&&void 0!==arguments[0]&&arguments[0],a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,N=arguments.length>2?arguments[2]:void 0,U=arguments.length>3?arguments[3]:void 0,c=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=l,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let K=0;K<this._targetedAnimations.length;K++){const Z=this._targetedAnimations[K],w=this._scene.beginDirectAnimation(Z.target,[Z.animation],void 0!==N?N:this._from,void 0!==U?U:this._to,l,a,void 0,void 0,void 0!==c?c:this._isAdditive);w.weight=this._weight,w.playOrder=this._playOrder,w.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Z),this._checkAnimationGroupEnded(w)},this._processLoop(w,Z,K),this._animatables.push(w)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=a,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let l=0;l<this._animatables.length;l++){this._animatables[l].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(l){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==l&&(this.loopAnimation=l),this.restart()):(this.stop(),this.start(l,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let l=0;l<this._animatables.length;l++){this._animatables[l].reset()}return this}restart(){if(!this._isStarted)return this;for(let l=0;l<this._animatables.length;l++){this._animatables[l].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let l=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const a=this._animatables.slice();for(let U=0;U<a.length;U++)a[U].stop(void 0,void 0,!0,l);let N=0;for(let U=0;U<this._scene._activeAnimatables.length;U++){const a=this._scene._activeAnimatables[U];a._runtimeAnimations.length>0?this._scene._activeAnimatables[N++]=a:l&&this._checkAnimationGroupEnded(a,l)}return this._scene._activeAnimatables.length=N,this._isStarted=!1,this}setWeightForAllAnimatables(l){for(let a=0;a<this._animatables.length;a++){this._animatables[a].weight=l}return this}syncAllAnimationsWith(l){for(let a=0;a<this._animatables.length;a++){this._animatables[a].syncWith(l)}return this}goToFrame(l){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let N=0;N<this._animatables.length;N++){this._animatables[N].goToFrame(l,a)}return this}getCurrentFrame(){var l;return(null===(l=this.animatables[0])||void 0===l?void 0:l.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const l=this._scene.animationGroups.indexOf(this);if(l>-1&&this._scene.animationGroups.splice(l,1),this._parentContainer){const l=this._parentContainer.animationGroups.indexOf(this);l>-1&&this._parentContainer.animationGroups.splice(l,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(l){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const N=this._animatables.indexOf(l);N>-1&&this._animatables.splice(N,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,a||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(l,a){let N=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const U=new C(l||this.name,this._scene,this._weight,this._playOrder);U._from=this.from,U._to=this.to,U._speedRatio=this.speedRatio,U._loopAnimation=this.loopAnimation,U._isAdditive=this.isAdditive,U._enableBlending=this.enableBlending,U._blendingSpeed=this.blendingSpeed,U.metadata=this.metadata,U.mask=this.mask;for(const c of this._targetedAnimations)U.addTargetedAnimation(N?c.animation.clone():c.animation,a?a(c.target):c.target);return U}serialize(){const l={};l.name=this.name,l.from=this.from,l.to=this.to,l.speedRatio=this.speedRatio,l.loopAnimation=this.loopAnimation,l.isAdditive=this.isAdditive,l.weight=this.weight,l.playOrder=this.playOrder,l.enableBlending=this.enableBlending,l.blendingSpeed=this.blendingSpeed,l.targetedAnimations=[];for(let a=0;a<this.targetedAnimations.length;a++){const N=this.targetedAnimations[a];l.targetedAnimations[a]=N.serialize()}return Z.d&&Z.d.HasTags(this)&&(l.tags=Z.d.GetTags(this)),this.metadata&&(l.metadata=this.metadata),l}static Parse(l,a){const N=new C(l.name,a,l.weight,l.playOrder);for(let c=0;c<l.targetedAnimations.length;c++){const K=l.targetedAnimations[c],Z=U.d.Parse(K.animation),w=K.targetId;if("influence"===K.animation.property){const l=a.getMorphTargetById(w);l&&N.addTargetedAnimation(Z,l)}else{const l=a.getNodeById(w);null!=l&&N.addTargetedAnimation(Z,l)}}return Z.d&&Z.d.AddTagsTo(N,l.tags),null!==l.from&&null!==l.to&&N.normalize(l.from,l.to),void 0!==l.speedRatio&&(N._speedRatio=l.speedRatio),void 0!==l.loopAnimation&&(N._loopAnimation=l.loopAnimation),void 0!==l.isAdditive&&(N._isAdditive=l.isAdditive),void 0!==l.weight&&(N._weight=l.weight),void 0!==l.playOrder&&(N._playOrder=l.playOrder),void 0!==l.enableBlending&&(N._enableBlending=l.enableBlending),void 0!==l.blendingSpeed&&(N._blendingSpeed=l.blendingSpeed),void 0!==l.metadata&&(N.metadata=l.metadata),N}static MakeAnimationAdditive(l,a,N){let c;c="object"===typeof a?a:{referenceFrame:a,range:N,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let K=l;c.cloneOriginalAnimationGroup&&(K=l.clone(c.clonedAnimationGroupName||K.name));const Z=K.targetedAnimations;for(let w=0;w<Z.length;w++){const l=Z[w];l.animation=U.d.MakeAnimationAdditive(l.animation,c)}if(K.isAdditive=!0,c.clipKeys){let l=Number.MAX_VALUE,a=-Number.MAX_VALUE;const N=K.targetedAnimations;for(let U=0;U<N.length;U++){const c=N[U].animation.getKeys();l>c[0].frame&&(l=c[0].frame),a<c[c.length-1].frame&&(a=c[c.length-1].frame)}K._from=l,K._to=a}return K}static ClipKeys(l,a,N,U,c){const K=l.clone(U||l.name);return C.ClipKeysInPlace(K,a,N,c)}static ClipKeysInPlace(l,a,N,U){return C.ClipInPlace(l,a,N,U,!1)}static ClipFrames(l,a,N,U,c){const K=l.clone(U||l.name);return C.ClipFramesInPlace(K,a,N,c)}static ClipFramesInPlace(l,a,N,U){return C.ClipInPlace(l,a,N,U,!0)}static ClipInPlace(l,a,N,U){let c=arguments.length>4&&void 0!==arguments[4]&&arguments[4],K=Number.MAX_VALUE,Z=-Number.MAX_VALUE;const w=l.targetedAnimations;for(let S=0;S<w.length;S++){const l=w[S],T=U?l.animation:l.animation.clone();c&&(T.createKeyForFrame(a),T.createKeyForFrame(N));const J=T.getKeys(),n=[];let y=Number.MAX_VALUE;for(let U=0;U<J.length;U++){const l=J[U];if(!c&&U>=a&&U<=N||c&&l.frame>=a&&l.frame<=N){const a={frame:l.frame,value:l.value.clone?l.value.clone():l.value,inTangent:l.inTangent,outTangent:l.outTangent,interpolation:l.interpolation,lockedTangent:l.lockedTangent};y===Number.MAX_VALUE&&(y=a.frame),a.frame-=y,n.push(a)}}0!==n.length?(K>n[0].frame&&(K=n[0].frame),Z<n[n.length-1].frame&&(Z=n[n.length-1].frame),T.setKeys(n,!0),l.animation=T):(w.splice(S,1),S--)}return l._from=K,l._to=Z,l}getClassName(){return"AnimationGroup"}toString(l){let a="Name: "+this.name;return a+=", type: "+this.getClassName(),l&&(a+=", from: "+this._from,a+=", to: "+this._to,a+=", isStarted: "+this._isStarted,a+=", speedRatio: "+this._speedRatio,a+=", targetedAnimations length: "+this._targetedAnimations.length,a+=", animatables length: "+this._animatables),a}}}}]);