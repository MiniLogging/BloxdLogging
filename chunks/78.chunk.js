"use strict";(self.zy41qorie9=self.zy41qorie9||[]).push([[78],{15296:(Z,l,C)=>{C.r(l),C.d(l,{AnimationGroup:()=>S,TargetedAnimation:()=>P});var B=C(12942),x=C(12251),b=C(12295),K=C(12486),f=C(13765),W=C(12442);class J{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(Z,l,C,x){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=l,this._target=Z,this._scene=C,this._host=x,this._activeTargets=[],l._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===B.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=W.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const Z={frame:0,value:this._minValue};this._keys.splice(0,0,Z)}if(this._target instanceof Array){let Z=0;for(const l of this._target)this._preparePath(l,Z),this._getOriginalValues(Z),Z++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const b=l.getEvents();if(b&&b.length>0)for(const B of b)this._events.push(B._clone());this._enableBlending=Z&&Z.animationPropertiesOverride?Z.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this._animation.targetPropertyPath;if(C.length>1){let B=Z;for(let Z=0;Z<C.length-1;Z++){const l=C[Z];if(B=B[l],void 0===B)throw new Error(`Invalid property (${l}) in property path (${C.join(".")})`)}this._targetPath=C[C.length-1],this._activeTargets[l]=B}else this._targetPath=C[0],this._activeTargets[l]=Z;if(void 0===this._activeTargets[l][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${C.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let Z=0;for(const l of this._target)void 0!==this._originalValue[Z]&&this._setValue(l,this._activeTargets[Z],this._originalValue[Z],-1,Z),Z++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let Z=0;Z<this._events.length;Z++)this._events[Z].isDone=!1}isStopped(){return this._stopped}dispose(){const Z=this._animation.runtimeAnimations.indexOf(this);Z>-1&&this._animation.runtimeAnimations.splice(Z,1)}setValue(Z,l){if(this._targetIsArray)for(let C=0;C<this._target.length;C++){const B=this._target[C];this._setValue(B,this._activeTargets[C],Z,l,C)}else this._setValue(this._target,this._directTarget,Z,l,0)}_getOriginalValues(){let Z,l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const C=this._activeTargets[l];Z=C.getLocalMatrix&&"_matrix"===this._targetPath?C.getLocalMatrix():C[this._targetPath],Z&&Z.clone?this._originalValue[l]=Z.clone():this._originalValue[l]=Z}_registerTargetForLateAnimationBinding(Z,l){const C=Z.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(C),C._lateAnimationHolders||(C._lateAnimationHolders={}),C._lateAnimationHolders[Z.targetPath]||(C._lateAnimationHolders[Z.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:l}),Z.isAdditive?(C._lateAnimationHolders[Z.targetPath].additiveAnimations.push(Z),C._lateAnimationHolders[Z.targetPath].totalAdditiveWeight+=Z.weight):(C._lateAnimationHolders[Z.targetPath].animations.push(Z),C._lateAnimationHolders[Z.targetPath].totalWeight+=Z.weight)}_setValue(Z,l,C,x,b){if(this._currentActiveTarget=l,this._weight=x,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const Z=l[this._targetPath];Z.clone?this._originalBlendValue=Z.clone():this._originalBlendValue=Z}this._originalBlendValue.m?B.b.AllowMatrixDecomposeForInterpolation?this._currentValue?W.Matrix.DecomposeLerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=W.Matrix.DecomposeLerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue?W.Matrix.LerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=W.Matrix.Lerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue=B.b._UniversalLerp(this._originalBlendValue,C,this._blendingFactor);const x=Z&&Z.animationPropertiesOverride?Z.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=x}else this._currentValue?this._currentValue.B?this._currentValue.B(C):this._currentValue=C:null!==C&&void 0!==C&&C.clone?this._currentValue=C.clone():this._currentValue=C;-1!==x?this._registerTargetForLateAnimationBinding(this,this._originalValue[b]):this._animationState.loopMode===B.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[b],l[this._targetPath]):l[this._targetPath]=this._originalValue[b]+this._currentValue:l[this._targetPath]=this._currentValue,Z.mE&&Z.mE(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const C=this._animation.getKeys();Z<C[0].frame?Z=C[0].frame:Z>C[C.length-1].frame&&(Z=C[C.length-1].frame);const B=this._events;if(B.length)for(let b=0;b<B.length;b++)B[b].onlyOnce||(B[b].isDone=B[b].frame<Z);this._currentFrame=Z;const x=this._animation._interpolate(Z,this._animationState);this.setValue(x,l)}_prepareForSpeedRatioChange(Z){const l=this._previousElapsedTime*(this._animation.framePerSecond*Z)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-l}animate(Z,l,C,x,b){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const f=this._animation,W=f.targetPropertyPath;if(!W||W.length<1)return this._stopped=!0,!1;let J,d=!0;const E=this._events;let G=0;if(this._coreRuntimeAnimation)G=C-l,J=this._coreRuntimeAnimation.currentFrame,this._currentFrame=J,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let K;(l<this._minFrame||l>this._maxFrame)&&(l=this._minFrame),(C<this._minFrame||C>this._maxFrame)&&(C=this._maxFrame),G=C-l;let W=Z*(f.framePerSecond*b)/1e3+this._absoluteFrameOffset,a=0,q=!1;const z=x&&this._animationState.loopMode===B.b.ANIMATIONLOOPMODE_YOYO;if(z){const Z=(W-l)/G,C=Math.sin(Z*Math.PI);W=Math.abs(C)*G+l;const B=C>=0?1:-1;this._yoyoDirection!==B&&(q=!0),this._yoyoDirection=B}if(this._previousElapsedTime=Z,this._previousAbsoluteFrame=W,!x&&C>=l&&(W>=G&&b>0||W<=0&&b<0))d=!1,a=f._getKeyValue(this._maxValue);else if(!x&&l>=C&&(W<=G&&b<0||W>=0&&b>0))d=!1,a=f._getKeyValue(this._minValue);else if(this._animationState.loopMode!==B.b.ANIMATIONLOOPMODE_CYCLE){const Z=C.toString()+l.toString();if(!this._offsetsCache[Z]){this._animationState.repeatCount=0,this._animationState.loopMode=B.b.ANIMATIONLOOPMODE_CYCLE;const x=f._interpolate(l,this._animationState),b=f._interpolate(C,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),f.dataType){case B.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[Z]=b-x;break;case B.b.ANIMATIONTYPE_QUATERNION:case B.b.ANIMATIONTYPE_VECTOR3:case B.b.ANIMATIONTYPE_VECTOR2:case B.b.ANIMATIONTYPE_SIZE:case B.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[Z]=b.zl(x)}this._highLimitsCache[Z]=b}a=this._highLimitsCache[Z],K=this._offsetsCache[Z]}if(void 0===K)switch(f.dataType){case B.b.ANIMATIONTYPE_FLOAT:K=0;break;case B.b.ANIMATIONTYPE_QUATERNION:K=B.g;break;case B.b.ANIMATIONTYPE_VECTOR3:K=B.n;break;case B.b.ANIMATIONTYPE_VECTOR2:K=B.k;break;case B.b.ANIMATIONTYPE_SIZE:K=B.i;break;case B.b.ANIMATIONTYPE_COLOR3:K=B.c;break;case B.b.ANIMATIONTYPE_COLOR4:K=B.d}if(this._host&&this._host.syncRoot){const Z=this._host.syncRoot;J=l+G*((Z.masterFrame-Z.fromFrame)/(Z.toFrame-Z.fromFrame))}else J=W>0&&l>C||W<0&&l<C?d&&0!==G?C+W%G:l:d&&0!==G?l+W%G:C;if(!z&&(b>0&&this.currentFrame>J||b<0&&this.currentFrame<J)||z&&q){this._onLoop();for(let Z=0;Z<E.length;Z++)E[Z].onlyOnce||(E[Z].isDone=!1);this._animationState.key=b>0?0:f.getKeys().length-1}this._currentFrame=J,this._animationState.repeatCount=0===G?0:W/G|0,this._animationState.highLimitValue=a,this._animationState.offsetValue=K}const a=f._interpolate(J,this._animationState);if(this.setValue(a,K),E.length)for(let B=0;B<E.length;B++)if(G>=0&&J>=E[B].frame&&E[B].frame>=l||G<0&&J<=E[B].frame&&E[B].frame<=l){const Z=E[B];Z.isDone||(Z.onlyOnce&&(E.splice(B,1),B--),Z.isDone=!0,Z.action(J))}return d||(this._stopped=!0),d}}var d=C(12275);class E{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(Z){this._weight=-1!==Z?Math.min(Math.max(Z,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(Z){for(let l=0;l<this._runtimeAnimations.length;l++){this._runtimeAnimations[l]._prepareForSpeedRatioChange(Z)}this._speedRatio=Z,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(Z,l){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,b=arguments.length>4&&void 0!==arguments[4]&&arguments[4],K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,W=arguments.length>7?arguments[7]:void 0,J=arguments.length>8?arguments[8]:void 0,d=arguments.length>9&&void 0!==arguments[9]&&arguments[9],E=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=l,this.fromFrame=C,this.toFrame=B,this.loopAnimation=b,this.onAnimationEnd=f,this.onAnimationLoop=J,this.isAdditive=d,this.playOrder=E,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.PW=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new x.b,this.onAnimationLoopObservable=new x.b,this._scene=Z,W&&this.appendAnimations(l,W),this._speedRatio=K,Z._activeAnimatables.push(this)}syncWith(Z){if(this._syncRoot=Z,Z){const Z=this._scene._activeAnimatables.indexOf(this);Z>-1&&(this._scene._activeAnimatables.splice(Z,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(Z,l){for(let C=0;C<l.length;C++){const B=l[C],x=new J(Z,B,this._scene,this);x._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(x)}}getAnimationByTargetProperty(Z){const l=this._runtimeAnimations;for(let C=0;C<l.length;C++)if(l[C].animation.targetProperty===Z)return l[C].animation;return null}getRuntimeAnimationByTargetProperty(Z){const l=this._runtimeAnimations;for(let C=0;C<l.length;C++)if(l[C].animation.targetProperty===Z)return l[C];return null}reset(){const Z=this._runtimeAnimations;for(let l=0;l<Z.length;l++)Z[l].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(Z){const l=this._runtimeAnimations;for(let C=0;C<l.length;C++)l[C].animation.enableBlending=!0,l[C].animation.blendingSpeed=Z}disableBlending(){const Z=this._runtimeAnimations;for(let l=0;l<Z.length;l++)Z[l].animation.enableBlending=!1}goToFrame(Z){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const C=this._runtimeAnimations;if(C[0]){const l=C[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??C[0].currentFrame;const B=0===this.speedRatio?0:(Z-this._frameToSyncFromJump)/l*1e3/this.speedRatio;this._manualJumpDelay=-B}for(let B=0;B<C.length;B++)C[B].goToFrame(Z,l?this._weight:-1);this._goToFrame=Z}get paused(){return this.PW}pause(){this.PW||(this.PW=!0)}restart(){this.PW=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(Z,l){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Z||l){const x=this._scene._activeAnimatables.indexOf(this);if(x>-1){const b=this._runtimeAnimations;for(let C=b.length-1;C>=0;C--){const B=b[C];Z&&B.animation.name!=Z||(l&&!l(B.target)||(B.dispose(),b.splice(C,1)))}0==b.length&&(C||this._scene._activeAnimatables.splice(x,1),B||this._raiseOnAnimationEnd())}}else{const Z=this._scene._activeAnimatables.indexOf(this);if(Z>-1){C||this._scene._activeAnimatables.splice(Z,1);const l=this._runtimeAnimations;for(let Z=0;Z<l.length;Z++)l[Z].dispose();this._runtimeAnimations.length=0,B||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((Z=>{this.onAnimationEndObservable.add((()=>{Z(this)}),void 0,void 0,this,!0)}))}_animate(Z){if(this.PW)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=Z),!0;if(null===this._localDelayOffset?(this._localDelayOffset=Z,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=Z-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let l=!1;const C=this._runtimeAnimations;let B;for(B=0;B<C.length;B++){const x=C[B].animate(Z-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);l=l||x}if(this.animationStarted=l,!l){if(this.disposeOnEnd)for(B=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(B,1),B=0;B<C.length;B++)C[B].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return l}}function G(Z){if(0===Z.totalWeight&&0===Z.totalAdditiveWeight)return Z.originalValue;let l=1;const C=W.TmpVectors.ql[0],B=W.TmpVectors.ql[1],x=W.TmpVectors.Quaternion[0];let b=0;const K=Z.animations[0],f=Z.originalValue;let J=1,d=!1;if(Z.totalWeight<1)J=1-Z.totalWeight,f.decompose(B,x,C);else{if(b=1,l=Z.totalWeight,J=K.weight/l,1==J){if(!Z.totalAdditiveWeight)return K.currentValue;d=!0}K.currentValue.decompose(B,x,C)}if(!d){B.scaleInPlace(J),C.scaleInPlace(J),x.scaleInPlace(J);for(let K=b;K<Z.animations.length;K++){const b=Z.animations[K];if(0===b.weight)continue;J=b.weight/l;const f=W.TmpVectors.ql[2],d=W.TmpVectors.ql[3],E=W.TmpVectors.Quaternion[1];b.currentValue.decompose(d,E,f),d.scaleAndAddToRef(J,B),E.scaleAndAddToRef(W.Quaternion.Dot(x,E)>0?J:-J,x),f.scaleAndAddToRef(J,C)}x.normalize()}for(let G=0;G<Z.additiveAnimations.length;G++){const l=Z.additiveAnimations[G];if(0===l.weight)continue;const b=W.TmpVectors.ql[2],K=W.TmpVectors.ql[3],f=W.TmpVectors.Quaternion[1];l.currentValue.decompose(K,f,b),K.multiplyToRef(B,K),W.ql.LerpToRef(B,K,l.weight,B),x.multiplyToRef(f,f),W.Quaternion.SlerpToRef(x,f,l.weight,x),b.scaleAndAddToRef(l.weight,C)}const E=K?K._animationState.workValue:W.TmpVectors.Matrix[0].clone();return W.Matrix.ComposeToRef(B,x,C,E),E}function a(Z,l){if(0===Z.totalWeight&&0===Z.totalAdditiveWeight)return l;const C=Z.animations[0],B=Z.originalValue;let x=l;if(0===Z.totalWeight&&Z.totalAdditiveWeight>0)x.B(B);else if(1===Z.animations.length){if(W.Quaternion.SlerpToRef(B,C.currentValue,Math.min(1,Z.totalWeight),x),0===Z.totalAdditiveWeight)return x}else if(Z.animations.length>1){let C,b,K=1;if(Z.totalWeight<1){const l=1-Z.totalWeight;C=[],b=[],C.push(B),b.push(l)}else{if(2===Z.animations.length&&(W.Quaternion.SlerpToRef(Z.animations[0].currentValue,Z.animations[1].currentValue,Z.animations[1].weight/Z.totalWeight,l),0===Z.totalAdditiveWeight))return l;C=[],b=[],K=Z.totalWeight}for(let l=0;l<Z.animations.length;l++){const B=Z.animations[l];C.push(B.currentValue),b.push(B.weight/K)}let f=0;for(let Z=0;Z<C.length;)Z?(f+=b[Z],W.Quaternion.SlerpToRef(x,C[Z],b[Z]/f,x),Z++):(W.Quaternion.SlerpToRef(C[Z],C[Z+1],b[Z+1]/(b[Z]+b[Z+1]),l),x=l,f=b[Z]+b[Z+1],Z+=2)}for(let b=0;b<Z.additiveAnimations.length;b++){const l=Z.additiveAnimations[b];0!==l.weight&&(x.multiplyToRef(l.currentValue,W.TmpVectors.Quaternion[0]),W.Quaternion.SlerpToRef(x,W.TmpVectors.Quaternion[0],l.weight,x))}return x}var q,z,Y=C(12704);q=Y.e,(z=f.e)&&(z.prototype.copyAnimationRange=function(Z,l,C){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3],b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new B.b(this.name,"_matrix",Z.animations[0].framePerSecond,B.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const K=Z.animations[0].getRange(l);if(!K)return!1;const f=K.from,W=K.to,J=Z.animations[0].getKeys(),d=Z.length,E=Z.getParent(),G=this.getParent(),a=x&&E&&d&&this.length&&d!==this.length,q=a&&G&&E?G.length/E.length:1,z=x&&!G&&b&&(1!==b.x||1!==b.y||1!==b.z),Y=this.animations[0].getKeys();let P,S,i;for(let B=0,s=J.length;B<s;B++)P=J[B],P.frame>=f&&P.frame<=W&&(x?(i=P.value.clone(),a?(S=i.getTranslation(),i.setTranslation(S.scaleInPlace(q))):z&&b?(S=i.getTranslation(),i.setTranslation(S.multiplyInPlace(b))):i=P.value):i=P.value,Y.push({frame:P.frame+C,value:i}));return this.animations[0].createRange(l,f+C,W+C),!0}),q&&(q.prototype._animate=function(Z){if(!this.animationsEnabled)return;const l=d.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=l}this.deltaTime=void 0!==Z?Z:this.useConstantAnimationDeltaTime?16:(l-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=l;const C=this._activeAnimatables;if(0===C.length)return;this._animationTime+=this.deltaTime;const x=this._animationTime;for(let B=0;B<C.length;B++){const Z=C[B];!Z._animate(x)&&Z.disposeOnEnd&&B--}!function(Z){if(Z._registeredForLateAnimationBindings.length){for(let l=0;l<Z._registeredForLateAnimationBindings.length;l++){const C=Z._registeredForLateAnimationBindings.data[l];for(const Z in C._lateAnimationHolders){const l=C._lateAnimationHolders[Z],x=l.animations[0],b=l.originalValue;if(void 0===b||null===b)continue;const K=B.b.AllowMatrixDecomposeForInterpolation&&b.m;let f=C[Z];if(K)f=G(l);else if(void 0!==b.w)f=a(l,f||W.Quaternion.Identity());else{let Z=0,C=1;const K=x&&x._animationState.loopMode===B.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(l.totalWeight<1)f=K?b.clone?b.clone():b:x&&b.scale?b.scale(1-l.totalWeight):x?b*(1-l.totalWeight):b.clone?b.clone():b;else if(x){C=l.totalWeight;const B=x.weight/C;f=1!==B?x.currentValue.scale?x.currentValue.scale(B):x.currentValue*B:x.currentValue,K&&(f.addToRef?f.addToRef(b,f):f+=b),Z=1}for(let B=Z;B<l.animations.length;B++){const Z=l.animations[B],x=Z.weight/C;x&&(Z.currentValue.scaleAndAddToRef?Z.currentValue.scaleAndAddToRef(x,f):f+=Z.currentValue*x)}for(let B=0;B<l.additiveAnimations.length;B++){const Z=l.additiveAnimations[B],C=Z.weight;C&&(Z.currentValue.scaleAndAddToRef?Z.currentValue.scaleAndAddToRef(C,f):f+=Z.currentValue*C)}}C[Z]=f}C._lateAnimationHolders={}}Z._registeredForLateAnimationBindings.reset()}}(this)},q.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((Z,l)=>Z.playOrder-l.playOrder))},q.prototype.beginWeightedAnimation=function(Z,l,C){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,x=arguments.length>4?arguments[4]:void 0,b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,K=arguments.length>6?arguments[6]:void 0,f=arguments.length>7?arguments[7]:void 0,W=arguments.length>8?arguments[8]:void 0,J=arguments.length>9?arguments[9]:void 0,d=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const E=this.beginAnimation(Z,l,C,x,b,K,f,!1,W,J,d);return E.weight=B,E},q.prototype.beginAnimation=function(Z,l,C,B){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,b=arguments.length>5?arguments[5]:void 0,K=arguments.length>6?arguments[6]:void 0,f=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],W=arguments.length>8?arguments[8]:void 0,J=arguments.length>9?arguments[9]:void 0,d=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(x<0){const Z=l;l=C,C=Z,x=-x}l>C&&(x=-x),f&&this.stopAnimation(Z,void 0,W),K||(K=new E(this,Z,l,C,B,x,b,void 0,J,d));const G=!W||W(Z);if(Z.animations&&G&&K.appendAnimations(Z,Z.animations),Z.getAnimatables){const d=Z.getAnimatables();for(let Z=0;Z<d.length;Z++)this.beginAnimation(d[Z],l,C,B,x,b,K,f,W,J)}return K.reset(),K},q.prototype.beginHierarchyAnimation=function(Z,l,C,B,x){let b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,K=arguments.length>6?arguments[6]:void 0,f=arguments.length>7?arguments[7]:void 0,W=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],J=arguments.length>9?arguments[9]:void 0,d=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const E=Z.getDescendants(l),G=[];G.push(this.beginAnimation(Z,C,B,x,b,K,f,W,J,void 0,d));for(const a of E)G.push(this.beginAnimation(a,C,B,x,b,K,f,W,J,void 0,d));return G},q.prototype.beginDirectAnimation=function(Z,l,C,B,x){let b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(b<0){const Z=C;C=B,B=Z,b=-b}return C>B&&(b=-b),new E(this,Z,C,B,x,b,arguments.length>6?arguments[6]:void 0,l,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},q.prototype.beginDirectHierarchyAnimation=function(Z,l,C,B,x,b,K,f,W){let J=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const d=Z.getDescendants(l),E=[];E.push(this.beginDirectAnimation(Z,C,B,x,b,K,f,W,J));for(const G of d)E.push(this.beginDirectAnimation(G,C,B,x,b,K,f,W,J));return E},q.prototype.getAnimatableByTarget=function(Z){for(let l=0;l<this._activeAnimatables.length;l++)if(this._activeAnimatables[l].target===Z)return this._activeAnimatables[l];return null},q.prototype.getAllAnimatablesByTarget=function(Z){const l=[];for(let C=0;C<this._activeAnimatables.length;C++)this._activeAnimatables[C].target===Z&&l.push(this._activeAnimatables[C]);return l},q.prototype.stopAnimation=function(Z,l,C){const B=this.getAllAnimatablesByTarget(Z);for(const x of B)x.stop(l,C)},q.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let Z=0;Z<this._activeAnimatables.length;Z++)this._activeAnimatables[Z].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const Z of this.animationGroups)Z.stop()});class P{getClassName(){return"TargetedAnimation"}serialize(){const Z={};return Z.animation=this.animation.serialize(),Z.targetId=this.target.id,Z}}class S{get mask(){return this._mask}set mask(Z){this._mask!==Z&&(this._mask=Z,this.syncWithMask(!0))}syncWithMask(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||Z){this._numActiveAnimatables=0;for(let Z=0;Z<this._animatables.length;++Z){const l=this._animatables[Z];!this.mask||this.mask.disabled||this.mask.retainsTarget(l.target.name)?(this._numActiveAnimatables++,l.paused&&l.restart()):l.paused||l.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let Z=0;Z<this._animatables.length;++Z){const l=this._animatables[Z];this.mask.retainsTarget(l.target.name)||(l.stop(),this._animatables.splice(Z,1),--Z)}for(let Z=0;Z<this._targetedAnimations.length;Z++){const l=this._targetedAnimations[Z];this.mask.retainsTarget(l.target.name)||(this._targetedAnimations.splice(Z,1),--Z)}}}get from(){return this._from}set from(Z){if(this._from!==Z){this._from=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].fromFrame=this._from}}}get to(){return this._to}set to(Z){if(this._to!==Z){this._to=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(Z){if(this._speedRatio!==Z){this._speedRatio=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(Z){if(this._loopAnimation!==Z){this._loopAnimation=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(Z){if(this._isAdditive!==Z){this._isAdditive=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(Z){this._weight!==Z&&(this._weight=Z,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(Z){if(this._playOrder!==Z&&(this._playOrder=Z,this._animatables.length>0)){for(let Z=0;Z<this._animatables.length;Z++)this._animatables[Z].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(Z){if(this._enableBlending!==Z&&(this._enableBlending=Z,null!==Z))for(let l=0;l<this._targetedAnimations.length;++l)this._targetedAnimations[l].animation.enableBlending=Z}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(Z){if(this._blendingSpeed!==Z&&(this._blendingSpeed=Z,null!==Z))for(let l=0;l<this._targetedAnimations.length;++l)this._targetedAnimations[l].animation.blendingSpeed=Z}getLength(Z,l){Z=Z??this._from;return((l=l??this._to)-Z)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(Z){let l=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=arguments.length>3?arguments[3]:void 0;if(0===Z.length)return null;B=B??Z[0].weight;let x=Number.MAX_VALUE,b=-Number.MAX_VALUE;if(C)for(const f of Z)f.from<x&&(x=f.from),f.to>b&&(b=f.to);const K=new S(Z[0].name+"_merged",Z[0]._scene,B);for(const f of Z){C&&f.normalize(x,b);for(const Z of f.targetedAnimations)K.addTargetedAnimation(Z.animation,Z.target);l&&f.dispose()}return K}constructor(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=Z,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new x.b,this.onAnimationLoopObservable=new x.b,this.onAnimationGroupLoopObservable=new x.b,this.onAnimationGroupEndObservable=new x.b,this.onAnimationGroupPauseObservable=new x.b,this.onAnimationGroupPlayObservable=new x.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=l||b.b.LastCreatedScene,this._weight=C,this._playOrder=B,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(Z,l){const C=new P;C.animation=Z,C.target=l;const B=Z.getKeys();return this._from>B[0].frame&&(this._from=B[0].frame),this._to<B[B.length-1].frame&&(this._to=B[B.length-1].frame),null!==this._enableBlending&&(Z.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(Z.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(C),this._shouldStart=!0,C}removeTargetedAnimation(Z){for(let l=this._targetedAnimations.length-1;l>-1;l--){this._targetedAnimations[l].animation===Z&&this._targetedAnimations.splice(l,1)}}normalize(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==Z&&(Z=this._from),null==l&&(l=this._to);for(let C=0;C<this._targetedAnimations.length;C++){const B=this._targetedAnimations[C].animation.getKeys(),x=B[0],b=B[B.length-1];if(x.frame>Z){const l={frame:Z,value:x.value,inTangent:x.inTangent,outTangent:x.outTangent,interpolation:x.interpolation};B.splice(0,0,l)}if(b.frame<l){const Z={frame:l,value:b.value,inTangent:b.inTangent,outTangent:b.outTangent,interpolation:b.interpolation};B.push(Z)}}return this._from=Z,this._to=l,this}_processLoop(Z,l,C){Z.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(l),this._animationLoopFlags[C]||(this._animationLoopFlags[C]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0],l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0,B=arguments.length>3?arguments[3]:void 0,x=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=Z,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let b=0;b<this._targetedAnimations.length;b++){const K=this._targetedAnimations[b],f=this._scene.beginDirectAnimation(K.target,[K.animation],void 0!==C?C:this._from,void 0!==B?B:this._to,Z,l,void 0,void 0,void 0!==x?x:this._isAdditive);f.weight=this._weight,f.playOrder=this._playOrder,f.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(K),this._checkAnimationGroupEnded(f)},this._processLoop(f,K,b),this._animatables.push(f)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=l,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(Z){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==Z&&(this.loopAnimation=Z),this.restart()):(this.stop(),this.start(Z,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].reset()}return this}restart(){if(!this._isStarted)return this;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const l=this._animatables.slice();for(let B=0;B<l.length;B++)l[B].stop(void 0,void 0,!0,Z);let C=0;for(let B=0;B<this._scene._activeAnimatables.length;B++){const l=this._scene._activeAnimatables[B];l._runtimeAnimations.length>0?this._scene._activeAnimatables[C++]=l:Z&&this._checkAnimationGroupEnded(l,Z)}return this._scene._activeAnimatables.length=C,this._isStarted=!1,this}setWeightForAllAnimatables(Z){for(let l=0;l<this._animatables.length;l++){this._animatables[l].weight=Z}return this}syncAllAnimationsWith(Z){for(let l=0;l<this._animatables.length;l++){this._animatables[l].syncWith(Z)}return this}goToFrame(Z){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let C=0;C<this._animatables.length;C++){this._animatables[C].goToFrame(Z,l)}return this}getCurrentFrame(){var Z;return(null===(Z=this.animatables[0])||void 0===Z?void 0:Z.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const Z=this._scene.animationGroups.indexOf(this);if(Z>-1&&this._scene.animationGroups.splice(Z,1),this._parentContainer){const Z=this._parentContainer.animationGroups.indexOf(this);Z>-1&&this._parentContainer.animationGroups.splice(Z,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(Z){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const C=this._animatables.indexOf(Z);C>-1&&this._animatables.splice(C,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,l||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(Z,l){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=new S(Z||this.name,this._scene,this._weight,this._playOrder);B._from=this.from,B._to=this.to,B._speedRatio=this.speedRatio,B._loopAnimation=this.loopAnimation,B._isAdditive=this.isAdditive,B._enableBlending=this.enableBlending,B._blendingSpeed=this.blendingSpeed,B.metadata=this.metadata,B.mask=this.mask;for(const x of this._targetedAnimations)B.addTargetedAnimation(C?x.animation.clone():x.animation,l?l(x.target):x.target);return B}serialize(){const Z={};Z.name=this.name,Z.from=this.from,Z.to=this.to,Z.speedRatio=this.speedRatio,Z.loopAnimation=this.loopAnimation,Z.isAdditive=this.isAdditive,Z.weight=this.weight,Z.playOrder=this.playOrder,Z.enableBlending=this.enableBlending,Z.blendingSpeed=this.blendingSpeed,Z.targetedAnimations=[];for(let l=0;l<this.targetedAnimations.length;l++){const C=this.targetedAnimations[l];Z.targetedAnimations[l]=C.serialize()}return K.e&&K.e.HasTags(this)&&(Z.tags=K.e.GetTags(this)),this.metadata&&(Z.metadata=this.metadata),Z}static Parse(Z,l){const C=new S(Z.name,l,Z.weight,Z.playOrder);for(let x=0;x<Z.targetedAnimations.length;x++){const b=Z.targetedAnimations[x],K=B.b.Parse(b.animation),f=b.targetId;if("influence"===b.animation.property){const Z=l.getMorphTargetById(f);Z&&C.addTargetedAnimation(K,Z)}else{const Z=l.getNodeById(f);null!=Z&&C.addTargetedAnimation(K,Z)}}return K.e&&K.e.AddTagsTo(C,Z.tags),null!==Z.from&&null!==Z.to&&C.normalize(Z.from,Z.to),void 0!==Z.speedRatio&&(C._speedRatio=Z.speedRatio),void 0!==Z.loopAnimation&&(C._loopAnimation=Z.loopAnimation),void 0!==Z.isAdditive&&(C._isAdditive=Z.isAdditive),void 0!==Z.weight&&(C._weight=Z.weight),void 0!==Z.playOrder&&(C._playOrder=Z.playOrder),void 0!==Z.enableBlending&&(C._enableBlending=Z.enableBlending),void 0!==Z.blendingSpeed&&(C._blendingSpeed=Z.blendingSpeed),void 0!==Z.metadata&&(C.metadata=Z.metadata),C}static MakeAnimationAdditive(Z,l,C){let x;x="object"===typeof l?l:{referenceFrame:l,range:C,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let b=Z;x.cloneOriginalAnimationGroup&&(b=Z.clone(x.clonedAnimationGroupName||b.name));const K=b.targetedAnimations;for(let f=0;f<K.length;f++){const Z=K[f];Z.animation=B.b.MakeAnimationAdditive(Z.animation,x)}if(b.isAdditive=!0,x.clipKeys){let Z=Number.MAX_VALUE,l=-Number.MAX_VALUE;const C=b.targetedAnimations;for(let B=0;B<C.length;B++){const x=C[B].animation.getKeys();Z>x[0].frame&&(Z=x[0].frame),l<x[x.length-1].frame&&(l=x[x.length-1].frame)}b._from=Z,b._to=l}return b}static ClipKeys(Z,l,C,B,x){const b=Z.clone(B||Z.name);return S.ClipKeysInPlace(b,l,C,x)}static ClipKeysInPlace(Z,l,C,B){return S.ClipInPlace(Z,l,C,B,!1)}static ClipFrames(Z,l,C,B,x){const b=Z.clone(B||Z.name);return S.ClipFramesInPlace(b,l,C,x)}static ClipFramesInPlace(Z,l,C,B){return S.ClipInPlace(Z,l,C,B,!0)}static ClipInPlace(Z,l,C,B){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4],b=Number.MAX_VALUE,K=-Number.MAX_VALUE;const f=Z.targetedAnimations;for(let W=0;W<f.length;W++){const Z=f[W],J=B?Z.animation:Z.animation.clone();x&&(J.createKeyForFrame(l),J.createKeyForFrame(C));const d=J.getKeys(),E=[];let G=Number.MAX_VALUE;for(let B=0;B<d.length;B++){const Z=d[B];if(!x&&B>=l&&B<=C||x&&Z.frame>=l&&Z.frame<=C){const l={frame:Z.frame,value:Z.value.clone?Z.value.clone():Z.value,inTangent:Z.inTangent,outTangent:Z.outTangent,interpolation:Z.interpolation,lockedTangent:Z.lockedTangent};G===Number.MAX_VALUE&&(G=l.frame),l.frame-=G,E.push(l)}}0!==E.length?(b>E[0].frame&&(b=E[0].frame),K<E[E.length-1].frame&&(K=E[E.length-1].frame),J.setKeys(E,!0),Z.animation=J):(f.splice(W,1),W--)}return Z._from=b,Z._to=K,Z}getClassName(){return"AnimationGroup"}toString(Z){let l="Name: "+this.name;return l+=", type: "+this.getClassName(),Z&&(l+=", from: "+this._from,l+=", to: "+this._to,l+=", isStarted: "+this._isStarted,l+=", speedRatio: "+this._speedRatio,l+=", targetedAnimations length: "+this._targetedAnimations.length,l+=", animatables length: "+this._animatables),l}}}}]);