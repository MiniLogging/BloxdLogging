"use strict";(self.nyfa010khv=self.nyfa010khv||[]).push([[78],{15273:(L,r,p)=>{p.r(r),p.d(r,{AnimationGroup:()=>O,TargetedAnimation:()=>P});var J=p(12642),i=p(11964),n=p(12009),j=p(12167),z=p(13777),G=p(12136);class C{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(L,r,p,i){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=r,this._target=L,this._scene=p,this._host=i,this._activeTargets=[],r._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===J.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=G.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const L={frame:0,value:this._minValue};this._keys.splice(0,0,L)}if(this._target instanceof Array){let L=0;for(const r of this._target)this._preparePath(r,L),this._getOriginalValues(L),L++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const n=r.getEvents();if(n&&n.length>0)for(const J of n)this._events.push(J._clone());this._enableBlending=L&&L.animationPropertiesOverride?L.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const p=this._animation.targetPropertyPath;if(p.length>1){let J=L;for(let L=0;L<p.length-1;L++){const r=p[L];if(J=J[r],void 0===J)throw new Error(`Invalid property (${r}) in property path (${p.join(".")})`)}this._targetPath=p[p.length-1],this._activeTargets[r]=J}else this._targetPath=p[0],this._activeTargets[r]=L;if(void 0===this._activeTargets[r][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${p.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let L=0;for(const r of this._target)void 0!==this._originalValue[L]&&this._setValue(r,this._activeTargets[L],this._originalValue[L],-1,L),L++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let L=0;L<this._events.length;L++)this._events[L].isDone=!1}isStopped(){return this._stopped}dispose(){const L=this._animation.runtimeAnimations.indexOf(this);L>-1&&this._animation.runtimeAnimations.splice(L,1)}setValue(L,r){if(this._targetIsArray)for(let p=0;p<this._target.length;p++){const J=this._target[p];this._setValue(J,this._activeTargets[p],L,r,p)}else this._setValue(this._target,this._directTarget,L,r,0)}_getOriginalValues(){let L,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const p=this._activeTargets[r];L=p.getLocalMatrix&&"_matrix"===this._targetPath?p.getLocalMatrix():p[this._targetPath],L&&L.clone?this._originalValue[r]=L.clone():this._originalValue[r]=L}_registerTargetForLateAnimationBinding(L,r){const p=L.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(p),p._lateAnimationHolders||(p._lateAnimationHolders={}),p._lateAnimationHolders[L.targetPath]||(p._lateAnimationHolders[L.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:r}),L.isAdditive?(p._lateAnimationHolders[L.targetPath].additiveAnimations.push(L),p._lateAnimationHolders[L.targetPath].totalAdditiveWeight+=L.weight):(p._lateAnimationHolders[L.targetPath].animations.push(L),p._lateAnimationHolders[L.targetPath].totalWeight+=L.weight)}_setValue(L,r,p,i,n){if(this._currentActiveTarget=r,this._weight=i,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const L=r[this._targetPath];L.clone?this._originalBlendValue=L.clone():this._originalBlendValue=L}this._originalBlendValue.m?J.c.AllowMatrixDecomposeForInterpolation?this._currentValue?G.Matrix.DecomposeLerpToRef(this._originalBlendValue,p,this._blendingFactor,this._currentValue):this._currentValue=G.Matrix.DecomposeLerp(this._originalBlendValue,p,this._blendingFactor):this._currentValue?G.Matrix.LerpToRef(this._originalBlendValue,p,this._blendingFactor,this._currentValue):this._currentValue=G.Matrix.Lerp(this._originalBlendValue,p,this._blendingFactor):this._currentValue=J.c._UniversalLerp(this._originalBlendValue,p,this._blendingFactor);const i=L&&L.animationPropertiesOverride?L.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=i}else this._currentValue?this._currentValue.G?this._currentValue.G(p):this._currentValue=p:null!==p&&void 0!==p&&p.clone?this._currentValue=p.clone():this._currentValue=p;-1!==i?this._registerTargetForLateAnimationBinding(this,this._originalValue[n]):this._animationState.loopMode===J.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[n],r[this._targetPath]):r[this._targetPath]=this._originalValue[n]+this._currentValue:r[this._targetPath]=this._currentValue,L.HC&&L.HC(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const p=this._animation.getKeys();L<p[0].frame?L=p[0].frame:L>p[p.length-1].frame&&(L=p[p.length-1].frame);const J=this._events;if(J.length)for(let n=0;n<J.length;n++)J[n].onlyOnce||(J[n].isDone=J[n].frame<L);this._currentFrame=L;const i=this._animation._interpolate(L,this._animationState);this.setValue(i,r)}_prepareForSpeedRatioChange(L){const r=this._previousElapsedTime*(this._animation.framePerSecond*L)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-r}animate(L,r,p,i,n){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const z=this._animation,G=z.targetPropertyPath;if(!G||G.length<1)return this._stopped=!0,!1;let C,t=!0;const E=this._events;let x=0;if(this._coreRuntimeAnimation)x=p-r,C=this._coreRuntimeAnimation.currentFrame,this._currentFrame=C,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let j;(r<this._minFrame||r>this._maxFrame)&&(r=this._minFrame),(p<this._minFrame||p>this._maxFrame)&&(p=this._maxFrame),x=p-r;let G=L*(z.framePerSecond*n)/1e3+this._absoluteFrameOffset,w=0,g=!1;const b=i&&this._animationState.loopMode===J.c.ANIMATIONLOOPMODE_YOYO;if(b){const L=(G-r)/x,p=Math.sin(L*Math.PI);G=Math.abs(p)*x+r;const J=p>=0?1:-1;this._yoyoDirection!==J&&(g=!0),this._yoyoDirection=J}if(this._previousElapsedTime=L,this._previousAbsoluteFrame=G,!i&&p>=r&&(G>=x&&n>0||G<=0&&n<0))t=!1,w=z._getKeyValue(this._maxValue);else if(!i&&r>=p&&(G<=x&&n<0||G>=0&&n>0))t=!1,w=z._getKeyValue(this._minValue);else if(this._animationState.loopMode!==J.c.ANIMATIONLOOPMODE_CYCLE){const L=p.toString()+r.toString();if(!this._offsetsCache[L]){this._animationState.repeatCount=0,this._animationState.loopMode=J.c.ANIMATIONLOOPMODE_CYCLE;const i=z._interpolate(r,this._animationState),n=z._interpolate(p,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),z.dataType){case J.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[L]=n-i;break;case J.c.ANIMATIONTYPE_QUATERNION:case J.c.ANIMATIONTYPE_VECTOR3:case J.c.ANIMATIONTYPE_VECTOR2:case J.c.ANIMATIONTYPE_SIZE:case J.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[L]=n.Pr(i)}this._highLimitsCache[L]=n}w=this._highLimitsCache[L],j=this._offsetsCache[L]}if(void 0===j)switch(z.dataType){case J.c.ANIMATIONTYPE_FLOAT:j=0;break;case J.c.ANIMATIONTYPE_QUATERNION:j=J.j;break;case J.c.ANIMATIONTYPE_VECTOR3:j=J.u;break;case J.c.ANIMATIONTYPE_VECTOR2:j=J.q;break;case J.c.ANIMATIONTYPE_SIZE:j=J.m;break;case J.c.ANIMATIONTYPE_COLOR3:j=J.d;break;case J.c.ANIMATIONTYPE_COLOR4:j=J.g}if(this._host&&this._host.syncRoot){const L=this._host.syncRoot;C=r+x*((L.masterFrame-L.fromFrame)/(L.toFrame-L.fromFrame))}else C=G>0&&r>p||G<0&&r<p?t&&0!==x?p+G%x:r:t&&0!==x?r+G%x:p;if(!b&&(n>0&&this.currentFrame>C||n<0&&this.currentFrame<C)||b&&g){this._onLoop();for(let L=0;L<E.length;L++)E[L].onlyOnce||(E[L].isDone=!1);this._animationState.key=n>0?0:z.getKeys().length-1}this._currentFrame=C,this._animationState.repeatCount=0===x?0:G/x|0,this._animationState.highLimitValue=w,this._animationState.offsetValue=j}const w=z._interpolate(C,this._animationState);if(this.setValue(w,j),E.length)for(let J=0;J<E.length;J++)if(x>=0&&C>=E[J].frame&&E[J].frame>=r||x<0&&C<=E[J].frame&&E[J].frame<=r){const L=E[J];L.isDone||(L.onlyOnce&&(E.splice(J,1),J--),L.isDone=!0,L.action(C))}return t||(this._stopped=!0),t}}var t=p(11988);class E{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(L){this._weight=-1!==L?Math.min(Math.max(L,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(L){for(let r=0;r<this._runtimeAnimations.length;r++){this._runtimeAnimations[r]._prepareForSpeedRatioChange(L)}this._speedRatio=L,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(L,r){let p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,n=arguments.length>4&&void 0!==arguments[4]&&arguments[4],j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,z=arguments.length>6?arguments[6]:void 0,G=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,t=arguments.length>9&&void 0!==arguments[9]&&arguments[9],E=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=r,this.fromFrame=p,this.toFrame=J,this.loopAnimation=n,this.onAnimationEnd=z,this.onAnimationLoop=C,this.isAdditive=t,this.playOrder=E,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.xz=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new i.c,this.onAnimationLoopObservable=new i.c,this._scene=L,G&&this.appendAnimations(r,G),this._speedRatio=j,L._activeAnimatables.push(this)}syncWith(L){if(this._syncRoot=L,L){const L=this._scene._activeAnimatables.indexOf(this);L>-1&&(this._scene._activeAnimatables.splice(L,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(L,r){for(let p=0;p<r.length;p++){const J=r[p],i=new C(L,J,this._scene,this);i._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(i)}}getAnimationByTargetProperty(L){const r=this._runtimeAnimations;for(let p=0;p<r.length;p++)if(r[p].animation.targetProperty===L)return r[p].animation;return null}getRuntimeAnimationByTargetProperty(L){const r=this._runtimeAnimations;for(let p=0;p<r.length;p++)if(r[p].animation.targetProperty===L)return r[p];return null}reset(){const L=this._runtimeAnimations;for(let r=0;r<L.length;r++)L[r].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(L){const r=this._runtimeAnimations;for(let p=0;p<r.length;p++)r[p].animation.enableBlending=!0,r[p].animation.blendingSpeed=L}disableBlending(){const L=this._runtimeAnimations;for(let r=0;r<L.length;r++)L[r].animation.enableBlending=!1}goToFrame(L){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const p=this._runtimeAnimations;if(p[0]){const r=p[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??p[0].currentFrame;const J=0===this.speedRatio?0:(L-this._frameToSyncFromJump)/r*1e3/this.speedRatio;this._manualJumpDelay=-J}for(let J=0;J<p.length;J++)p[J].goToFrame(L,r?this._weight:-1);this._goToFrame=L}get paused(){return this.xz}pause(){this.xz||(this.xz=!0)}restart(){this.xz=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(L,r){let p=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(L||r){const i=this._scene._activeAnimatables.indexOf(this);if(i>-1){const n=this._runtimeAnimations;for(let p=n.length-1;p>=0;p--){const J=n[p];L&&J.animation.name!=L||(r&&!r(J.target)||(J.dispose(),n.splice(p,1)))}0==n.length&&(p||this._scene._activeAnimatables.splice(i,1),J||this._raiseOnAnimationEnd())}}else{const L=this._scene._activeAnimatables.indexOf(this);if(L>-1){p||this._scene._activeAnimatables.splice(L,1);const r=this._runtimeAnimations;for(let L=0;L<r.length;L++)r[L].dispose();this._runtimeAnimations.length=0,J||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((L=>{this.onAnimationEndObservable.add((()=>{L(this)}),void 0,void 0,this,!0)}))}_animate(L){if(this.xz)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=L),!0;if(null===this._localDelayOffset?(this._localDelayOffset=L,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=L-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let r=!1;const p=this._runtimeAnimations;let J;for(J=0;J<p.length;J++){const i=p[J].animate(L-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);r=r||i}if(this.animationStarted=r,!r){if(this.disposeOnEnd)for(J=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(J,1),J=0;J<p.length;J++)p[J].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return r}}function x(L){if(0===L.totalWeight&&0===L.totalAdditiveWeight)return L.originalValue;let r=1;const p=G.TmpVectors.cr[0],J=G.TmpVectors.cr[1],i=G.TmpVectors.Quaternion[0];let n=0;const j=L.animations[0],z=L.originalValue;let C=1,t=!1;if(L.totalWeight<1)C=1-L.totalWeight,z.decompose(J,i,p);else{if(n=1,r=L.totalWeight,C=j.weight/r,1==C){if(!L.totalAdditiveWeight)return j.currentValue;t=!0}j.currentValue.decompose(J,i,p)}if(!t){J.scaleInPlace(C),p.scaleInPlace(C),i.scaleInPlace(C);for(let j=n;j<L.animations.length;j++){const n=L.animations[j];if(0===n.weight)continue;C=n.weight/r;const z=G.TmpVectors.cr[2],t=G.TmpVectors.cr[3],E=G.TmpVectors.Quaternion[1];n.currentValue.decompose(t,E,z),t.scaleAndAddToRef(C,J),E.scaleAndAddToRef(G.Quaternion.Dot(i,E)>0?C:-C,i),z.scaleAndAddToRef(C,p)}i.normalize()}for(let x=0;x<L.additiveAnimations.length;x++){const r=L.additiveAnimations[x];if(0===r.weight)continue;const n=G.TmpVectors.cr[2],j=G.TmpVectors.cr[3],z=G.TmpVectors.Quaternion[1];r.currentValue.decompose(j,z,n),j.multiplyToRef(J,j),G.cr.LerpToRef(J,j,r.weight,J),i.multiplyToRef(z,z),G.Quaternion.SlerpToRef(i,z,r.weight,i),n.scaleAndAddToRef(r.weight,p)}const E=j?j._animationState.workValue:G.TmpVectors.Matrix[0].clone();return G.Matrix.ComposeToRef(J,i,p,E),E}function w(L,r){if(0===L.totalWeight&&0===L.totalAdditiveWeight)return r;const p=L.animations[0],J=L.originalValue;let i=r;if(0===L.totalWeight&&L.totalAdditiveWeight>0)i.G(J);else if(1===L.animations.length){if(G.Quaternion.SlerpToRef(J,p.currentValue,Math.min(1,L.totalWeight),i),0===L.totalAdditiveWeight)return i}else if(L.animations.length>1){let p,n,j=1;if(L.totalWeight<1){const r=1-L.totalWeight;p=[],n=[],p.push(J),n.push(r)}else{if(2===L.animations.length&&(G.Quaternion.SlerpToRef(L.animations[0].currentValue,L.animations[1].currentValue,L.animations[1].weight/L.totalWeight,r),0===L.totalAdditiveWeight))return r;p=[],n=[],j=L.totalWeight}for(let r=0;r<L.animations.length;r++){const J=L.animations[r];p.push(J.currentValue),n.push(J.weight/j)}let z=0;for(let L=0;L<p.length;)L?(z+=n[L],G.Quaternion.SlerpToRef(i,p[L],n[L]/z,i),L++):(G.Quaternion.SlerpToRef(p[L],p[L+1],n[L+1]/(n[L]+n[L+1]),r),i=r,z=n[L]+n[L+1],L+=2)}for(let n=0;n<L.additiveAnimations.length;n++){const r=L.additiveAnimations[n];0!==r.weight&&(i.multiplyToRef(r.currentValue,G.TmpVectors.Quaternion[0]),G.Quaternion.SlerpToRef(i,G.TmpVectors.Quaternion[0],r.weight,i))}return i}var g,b,c=p(12355);g=c.b,(b=z.e)&&(b.prototype.copyAnimationRange=function(L,r,p){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3],n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new J.c(this.name,"_matrix",L.animations[0].framePerSecond,J.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const j=L.animations[0].getRange(r);if(!j)return!1;const z=j.from,G=j.to,C=L.animations[0].getKeys(),t=L.length,E=L.getParent(),x=this.getParent(),w=i&&E&&t&&this.length&&t!==this.length,g=w&&x&&E?x.length/E.length:1,b=i&&!x&&n&&(1!==n.x||1!==n.y||1!==n.z),c=this.animations[0].getKeys();let P,O,h;for(let J=0,U=C.length;J<U;J++)P=C[J],P.frame>=z&&P.frame<=G&&(i?(h=P.value.clone(),w?(O=h.getTranslation(),h.setTranslation(O.scaleInPlace(g))):b&&n?(O=h.getTranslation(),h.setTranslation(O.multiplyInPlace(n))):h=P.value):h=P.value,c.push({frame:P.frame+p,value:h}));return this.animations[0].createRange(r,z+p,G+p),!0}),g&&(g.prototype._animate=function(L){if(!this.animationsEnabled)return;const r=t.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=r}this.deltaTime=void 0!==L?L:this.useConstantAnimationDeltaTime?16:(r-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=r;const p=this._activeAnimatables;if(0===p.length)return;this._animationTime+=this.deltaTime;const i=this._animationTime;for(let J=0;J<p.length;J++){const L=p[J];!L._animate(i)&&L.disposeOnEnd&&J--}!function(L){if(L._registeredForLateAnimationBindings.length){for(let r=0;r<L._registeredForLateAnimationBindings.length;r++){const p=L._registeredForLateAnimationBindings.data[r];for(const L in p._lateAnimationHolders){const r=p._lateAnimationHolders[L],i=r.animations[0],n=r.originalValue;if(void 0===n||null===n)continue;const j=J.c.AllowMatrixDecomposeForInterpolation&&n.m;let z=p[L];if(j)z=x(r);else if(void 0!==n.w)z=w(r,z||G.Quaternion.Identity());else{let L=0,p=1;const j=i&&i._animationState.loopMode===J.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(r.totalWeight<1)z=j?n.clone?n.clone():n:i&&n.scale?n.scale(1-r.totalWeight):i?n*(1-r.totalWeight):n.clone?n.clone():n;else if(i){p=r.totalWeight;const J=i.weight/p;z=1!==J?i.currentValue.scale?i.currentValue.scale(J):i.currentValue*J:i.currentValue,j&&(z.addToRef?z.addToRef(n,z):z+=n),L=1}for(let J=L;J<r.animations.length;J++){const L=r.animations[J],i=L.weight/p;i&&(L.currentValue.scaleAndAddToRef?L.currentValue.scaleAndAddToRef(i,z):z+=L.currentValue*i)}for(let J=0;J<r.additiveAnimations.length;J++){const L=r.additiveAnimations[J],p=L.weight;p&&(L.currentValue.scaleAndAddToRef?L.currentValue.scaleAndAddToRef(p,z):z+=L.currentValue*p)}}p[L]=z}p._lateAnimationHolders={}}L._registeredForLateAnimationBindings.reset()}}(this)},g.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((L,r)=>L.playOrder-r.playOrder))},g.prototype.beginWeightedAnimation=function(L,r,p){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,i=arguments.length>4?arguments[4]:void 0,n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,j=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,G=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,t=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const E=this.beginAnimation(L,r,p,i,n,j,z,!1,G,C,t);return E.weight=J,E},g.prototype.beginAnimation=function(L,r,p,J){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,n=arguments.length>5?arguments[5]:void 0,j=arguments.length>6?arguments[6]:void 0,z=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],G=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,t=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(i<0){const L=r;r=p,p=L,i=-i}r>p&&(i=-i),z&&this.stopAnimation(L,void 0,G),j||(j=new E(this,L,r,p,J,i,n,void 0,C,t));const x=!G||G(L);if(L.animations&&x&&j.appendAnimations(L,L.animations),L.getAnimatables){const t=L.getAnimatables();for(let L=0;L<t.length;L++)this.beginAnimation(t[L],r,p,J,i,n,j,z,G,C)}return j.reset(),j},g.prototype.beginHierarchyAnimation=function(L,r,p,J,i){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,j=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,G=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],C=arguments.length>9?arguments[9]:void 0,t=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const E=L.getDescendants(r),x=[];x.push(this.beginAnimation(L,p,J,i,n,j,z,G,C,void 0,t));for(const w of E)x.push(this.beginAnimation(w,p,J,i,n,j,z,G,C,void 0,t));return x},g.prototype.beginDirectAnimation=function(L,r,p,J,i){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(n<0){const L=p;p=J,J=L,n=-n}return p>J&&(n=-n),new E(this,L,p,J,i,n,arguments.length>6?arguments[6]:void 0,r,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},g.prototype.beginDirectHierarchyAnimation=function(L,r,p,J,i,n,j,z,G){let C=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const t=L.getDescendants(r),E=[];E.push(this.beginDirectAnimation(L,p,J,i,n,j,z,G,C));for(const x of t)E.push(this.beginDirectAnimation(x,p,J,i,n,j,z,G,C));return E},g.prototype.getAnimatableByTarget=function(L){for(let r=0;r<this._activeAnimatables.length;r++)if(this._activeAnimatables[r].target===L)return this._activeAnimatables[r];return null},g.prototype.getAllAnimatablesByTarget=function(L){const r=[];for(let p=0;p<this._activeAnimatables.length;p++)this._activeAnimatables[p].target===L&&r.push(this._activeAnimatables[p]);return r},g.prototype.stopAnimation=function(L,r,p){const J=this.getAllAnimatablesByTarget(L);for(const i of J)i.stop(r,p)},g.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let L=0;L<this._activeAnimatables.length;L++)this._activeAnimatables[L].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const L of this.animationGroups)L.stop()});class P{getClassName(){return"TargetedAnimation"}serialize(){const L={};return L.animation=this.animation.serialize(),L.targetId=this.target.id,L}}class O{get mask(){return this._mask}set mask(L){this._mask!==L&&(this._mask=L,this.syncWithMask(!0))}syncWithMask(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||L){this._numActiveAnimatables=0;for(let L=0;L<this._animatables.length;++L){const r=this._animatables[L];!this.mask||this.mask.disabled||this.mask.retainsTarget(r.target.name)?(this._numActiveAnimatables++,r.paused&&r.restart()):r.paused||r.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let L=0;L<this._animatables.length;++L){const r=this._animatables[L];this.mask.retainsTarget(r.target.name)||(r.stop(),this._animatables.splice(L,1),--L)}for(let L=0;L<this._targetedAnimations.length;L++){const r=this._targetedAnimations[L];this.mask.retainsTarget(r.target.name)||(this._targetedAnimations.splice(L,1),--L)}}}get from(){return this._from}set from(L){if(this._from!==L){this._from=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].fromFrame=this._from}}}get to(){return this._to}set to(L){if(this._to!==L){this._to=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(L){if(this._speedRatio!==L){this._speedRatio=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(L){if(this._loopAnimation!==L){this._loopAnimation=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(L){if(this._isAdditive!==L){this._isAdditive=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(L){this._weight!==L&&(this._weight=L,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(L){if(this._playOrder!==L&&(this._playOrder=L,this._animatables.length>0)){for(let L=0;L<this._animatables.length;L++)this._animatables[L].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(L){if(this._enableBlending!==L&&(this._enableBlending=L,null!==L))for(let r=0;r<this._targetedAnimations.length;++r)this._targetedAnimations[r].animation.enableBlending=L}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(L){if(this._blendingSpeed!==L&&(this._blendingSpeed=L,null!==L))for(let r=0;r<this._targetedAnimations.length;++r)this._targetedAnimations[r].animation.blendingSpeed=L}getLength(L,r){L=L??this._from;return((r=r??this._to)-L)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(L){let r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],p=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=arguments.length>3?arguments[3]:void 0;if(0===L.length)return null;J=J??L[0].weight;let i=Number.MAX_VALUE,n=-Number.MAX_VALUE;if(p)for(const z of L)z.from<i&&(i=z.from),z.to>n&&(n=z.to);const j=new O(L[0].name+"_merged",L[0]._scene,J);for(const z of L){p&&z.normalize(i,n);for(const L of z.targetedAnimations)j.addTargetedAnimation(L.animation,L.target);r&&z.dispose()}return j}constructor(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=L,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new i.c,this.onAnimationLoopObservable=new i.c,this.onAnimationGroupLoopObservable=new i.c,this.onAnimationGroupEndObservable=new i.c,this.onAnimationGroupPauseObservable=new i.c,this.onAnimationGroupPlayObservable=new i.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=r||n.c.LastCreatedScene,this._weight=p,this._playOrder=J,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(L,r){const p=new P;p.animation=L,p.target=r;const J=L.getKeys();return this._from>J[0].frame&&(this._from=J[0].frame),this._to<J[J.length-1].frame&&(this._to=J[J.length-1].frame),null!==this._enableBlending&&(L.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(L.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(p),this._shouldStart=!0,p}removeTargetedAnimation(L){for(let r=this._targetedAnimations.length-1;r>-1;r--){this._targetedAnimations[r].animation===L&&this._targetedAnimations.splice(r,1)}}normalize(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==L&&(L=this._from),null==r&&(r=this._to);for(let p=0;p<this._targetedAnimations.length;p++){const J=this._targetedAnimations[p].animation.getKeys(),i=J[0],n=J[J.length-1];if(i.frame>L){const r={frame:L,value:i.value,inTangent:i.inTangent,outTangent:i.outTangent,interpolation:i.interpolation};J.splice(0,0,r)}if(n.frame<r){const L={frame:r,value:n.value,inTangent:n.inTangent,outTangent:n.outTangent,interpolation:n.interpolation};J.push(L)}}return this._from=L,this._to=r,this}_processLoop(L,r,p){L.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(r),this._animationLoopFlags[p]||(this._animationLoopFlags[p]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,p=arguments.length>2?arguments[2]:void 0,J=arguments.length>3?arguments[3]:void 0,i=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=L,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let n=0;n<this._targetedAnimations.length;n++){const j=this._targetedAnimations[n],z=this._scene.beginDirectAnimation(j.target,[j.animation],void 0!==p?p:this._from,void 0!==J?J:this._to,L,r,void 0,void 0,void 0!==i?i:this._isAdditive);z.weight=this._weight,z.playOrder=this._playOrder,z.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(j),this._checkAnimationGroupEnded(z)},this._processLoop(z,j,n),this._animatables.push(z)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=r,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let L=0;L<this._animatables.length;L++){this._animatables[L].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(L){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==L&&(this.loopAnimation=L),this.restart()):(this.stop(),this.start(L,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let L=0;L<this._animatables.length;L++){this._animatables[L].reset()}return this}restart(){if(!this._isStarted)return this;for(let L=0;L<this._animatables.length;L++){this._animatables[L].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const r=this._animatables.slice();for(let J=0;J<r.length;J++)r[J].stop(void 0,void 0,!0,L);let p=0;for(let J=0;J<this._scene._activeAnimatables.length;J++){const r=this._scene._activeAnimatables[J];r._runtimeAnimations.length>0?this._scene._activeAnimatables[p++]=r:L&&this._checkAnimationGroupEnded(r,L)}return this._scene._activeAnimatables.length=p,this._isStarted=!1,this}setWeightForAllAnimatables(L){for(let r=0;r<this._animatables.length;r++){this._animatables[r].weight=L}return this}syncAllAnimationsWith(L){for(let r=0;r<this._animatables.length;r++){this._animatables[r].syncWith(L)}return this}goToFrame(L){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let p=0;p<this._animatables.length;p++){this._animatables[p].goToFrame(L,r)}return this}getCurrentFrame(){var L;return(null===(L=this.animatables[0])||void 0===L?void 0:L.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const L=this._scene.animationGroups.indexOf(this);if(L>-1&&this._scene.animationGroups.splice(L,1),this._parentContainer){const L=this._parentContainer.animationGroups.indexOf(this);L>-1&&this._parentContainer.animationGroups.splice(L,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(L){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const p=this._animatables.indexOf(L);p>-1&&this._animatables.splice(p,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,r||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(L,r){let p=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const J=new O(L||this.name,this._scene,this._weight,this._playOrder);J._from=this.from,J._to=this.to,J._speedRatio=this.speedRatio,J._loopAnimation=this.loopAnimation,J._isAdditive=this.isAdditive,J._enableBlending=this.enableBlending,J._blendingSpeed=this.blendingSpeed,J.metadata=this.metadata,J.mask=this.mask;for(const i of this._targetedAnimations)J.addTargetedAnimation(p?i.animation.clone():i.animation,r?r(i.target):i.target);return J}serialize(){const L={};L.name=this.name,L.from=this.from,L.to=this.to,L.speedRatio=this.speedRatio,L.loopAnimation=this.loopAnimation,L.isAdditive=this.isAdditive,L.weight=this.weight,L.playOrder=this.playOrder,L.enableBlending=this.enableBlending,L.blendingSpeed=this.blendingSpeed,L.targetedAnimations=[];for(let r=0;r<this.targetedAnimations.length;r++){const p=this.targetedAnimations[r];L.targetedAnimations[r]=p.serialize()}return j.b&&j.b.HasTags(this)&&(L.tags=j.b.GetTags(this)),this.metadata&&(L.metadata=this.metadata),L}static Parse(L,r){const p=new O(L.name,r,L.weight,L.playOrder);for(let i=0;i<L.targetedAnimations.length;i++){const n=L.targetedAnimations[i],j=J.c.Parse(n.animation),z=n.targetId;if("influence"===n.animation.property){const L=r.getMorphTargetById(z);L&&p.addTargetedAnimation(j,L)}else{const L=r.getNodeById(z);null!=L&&p.addTargetedAnimation(j,L)}}return j.b&&j.b.AddTagsTo(p,L.tags),null!==L.from&&null!==L.to&&p.normalize(L.from,L.to),void 0!==L.speedRatio&&(p._speedRatio=L.speedRatio),void 0!==L.loopAnimation&&(p._loopAnimation=L.loopAnimation),void 0!==L.isAdditive&&(p._isAdditive=L.isAdditive),void 0!==L.weight&&(p._weight=L.weight),void 0!==L.playOrder&&(p._playOrder=L.playOrder),void 0!==L.enableBlending&&(p._enableBlending=L.enableBlending),void 0!==L.blendingSpeed&&(p._blendingSpeed=L.blendingSpeed),void 0!==L.metadata&&(p.metadata=L.metadata),p}static MakeAnimationAdditive(L,r,p){let i;i="object"===typeof r?r:{referenceFrame:r,range:p,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let n=L;i.cloneOriginalAnimationGroup&&(n=L.clone(i.clonedAnimationGroupName||n.name));const j=n.targetedAnimations;for(let z=0;z<j.length;z++){const L=j[z];L.animation=J.c.MakeAnimationAdditive(L.animation,i)}if(n.isAdditive=!0,i.clipKeys){let L=Number.MAX_VALUE,r=-Number.MAX_VALUE;const p=n.targetedAnimations;for(let J=0;J<p.length;J++){const i=p[J].animation.getKeys();L>i[0].frame&&(L=i[0].frame),r<i[i.length-1].frame&&(r=i[i.length-1].frame)}n._from=L,n._to=r}return n}static ClipKeys(L,r,p,J,i){const n=L.clone(J||L.name);return O.ClipKeysInPlace(n,r,p,i)}static ClipKeysInPlace(L,r,p,J){return O.ClipInPlace(L,r,p,J,!1)}static ClipFrames(L,r,p,J,i){const n=L.clone(J||L.name);return O.ClipFramesInPlace(n,r,p,i)}static ClipFramesInPlace(L,r,p,J){return O.ClipInPlace(L,r,p,J,!0)}static ClipInPlace(L,r,p,J){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4],n=Number.MAX_VALUE,j=-Number.MAX_VALUE;const z=L.targetedAnimations;for(let G=0;G<z.length;G++){const L=z[G],C=J?L.animation:L.animation.clone();i&&(C.createKeyForFrame(r),C.createKeyForFrame(p));const t=C.getKeys(),E=[];let x=Number.MAX_VALUE;for(let J=0;J<t.length;J++){const L=t[J];if(!i&&J>=r&&J<=p||i&&L.frame>=r&&L.frame<=p){const r={frame:L.frame,value:L.value.clone?L.value.clone():L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation,lockedTangent:L.lockedTangent};x===Number.MAX_VALUE&&(x=r.frame),r.frame-=x,E.push(r)}}0!==E.length?(n>E[0].frame&&(n=E[0].frame),j<E[E.length-1].frame&&(j=E[E.length-1].frame),C.setKeys(E,!0),L.animation=C):(z.splice(G,1),G--)}return L._from=n,L._to=j,L}getClassName(){return"AnimationGroup"}toString(L){let r="Name: "+this.name;return r+=", type: "+this.getClassName(),L&&(r+=", from: "+this._from,r+=", to: "+this._to,r+=", isStarted: "+this._isStarted,r+=", speedRatio: "+this._speedRatio,r+=", targetedAnimations length: "+this._targetedAnimations.length,r+=", animatables length: "+this._animatables),r}}}}]);