"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[78],{14940:(C,U,K)=>{K.r(U),K.d(U,{AnimationGroup:()=>f,TargetedAnimation:()=>V});var m=K(12357),O=K(11663),X=K(11703),A=K(11872),e=K(13443),t=K(11827);class z{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(C,U,K,O){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=U,this._target=C,this._scene=K,this._host=O,this._activeTargets=[],U._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===m.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=t.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const C={frame:0,value:this._minValue};this._keys.splice(0,0,C)}if(this._target instanceof Array){let C=0;for(const U of this._target)this._preparePath(U,C),this._getOriginalValues(C),C++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const X=U.getEvents();if(X&&X.length>0)for(const m of X)this._events.push(m._clone());this._enableBlending=C&&C.animationPropertiesOverride?C.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const K=this._animation.targetPropertyPath;if(K.length>1){let m=C;for(let C=0;C<K.length-1;C++){const U=K[C];if(m=m[U],void 0===m)throw new Error(`Invalid property (${U}) in property path (${K.join(".")})`)}this._targetPath=K[K.length-1],this._activeTargets[U]=m}else this._targetPath=K[0],this._activeTargets[U]=C;if(void 0===this._activeTargets[U][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${K.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let C=0;for(const U of this._target)void 0!==this._originalValue[C]&&this._setValue(U,this._activeTargets[C],this._originalValue[C],-1,C),C++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let C=0;C<this._events.length;C++)this._events[C].isDone=!1}isStopped(){return this._stopped}dispose(){const C=this._animation.runtimeAnimations.indexOf(this);C>-1&&this._animation.runtimeAnimations.splice(C,1)}setValue(C,U){if(this._targetIsArray)for(let K=0;K<this._target.length;K++){const m=this._target[K];this._setValue(m,this._activeTargets[K],C,U,K)}else this._setValue(this._target,this._directTarget,C,U,0)}_getOriginalValues(){let C,U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const K=this._activeTargets[U];C=K.getLocalMatrix&&"_matrix"===this._targetPath?K.getLocalMatrix():K[this._targetPath],C&&C.clone?this._originalValue[U]=C.clone():this._originalValue[U]=C}_registerTargetForLateAnimationBinding(C,U){const K=C.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(K),K._lateAnimationHolders||(K._lateAnimationHolders={}),K._lateAnimationHolders[C.targetPath]||(K._lateAnimationHolders[C.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:U}),C.isAdditive?(K._lateAnimationHolders[C.targetPath].additiveAnimations.push(C),K._lateAnimationHolders[C.targetPath].totalAdditiveWeight+=C.weight):(K._lateAnimationHolders[C.targetPath].animations.push(C),K._lateAnimationHolders[C.targetPath].totalWeight+=C.weight)}_setValue(C,U,K,O,X){if(this._currentActiveTarget=U,this._weight=O,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const C=U[this._targetPath];C.clone?this._originalBlendValue=C.clone():this._originalBlendValue=C}this._originalBlendValue.m?m.c.AllowMatrixDecomposeForInterpolation?this._currentValue?t.Matrix.DecomposeLerpToRef(this._originalBlendValue,K,this._blendingFactor,this._currentValue):this._currentValue=t.Matrix.DecomposeLerp(this._originalBlendValue,K,this._blendingFactor):this._currentValue?t.Matrix.LerpToRef(this._originalBlendValue,K,this._blendingFactor,this._currentValue):this._currentValue=t.Matrix.Lerp(this._originalBlendValue,K,this._blendingFactor):this._currentValue=m.c._UniversalLerp(this._originalBlendValue,K,this._blendingFactor);const O=C&&C.animationPropertiesOverride?C.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=O}else this._currentValue?this._currentValue.m?this._currentValue.m(K):this._currentValue=K:null!==K&&void 0!==K&&K.clone?this._currentValue=K.clone():this._currentValue=K;-1!==O?this._registerTargetForLateAnimationBinding(this,this._originalValue[X]):this._animationState.loopMode===m.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[X],U[this._targetPath]):U[this._targetPath]=this._originalValue[X]+this._currentValue:U[this._targetPath]=this._currentValue,C.Iz&&C.Iz(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const K=this._animation.getKeys();C<K[0].frame?C=K[0].frame:C>K[K.length-1].frame&&(C=K[K.length-1].frame);const m=this._events;if(m.length)for(let X=0;X<m.length;X++)m[X].onlyOnce||(m[X].isDone=m[X].frame<C);this._currentFrame=C;const O=this._animation._interpolate(C,this._animationState);this.setValue(O,U)}_prepareForSpeedRatioChange(C){const U=this._previousElapsedTime*(this._animation.framePerSecond*C)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-U}animate(C,U,K,O,X){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const e=this._animation,t=e.targetPropertyPath;if(!t||t.length<1)return this._stopped=!0,!1;let z,j=!0;const p=this._events;let E=0;if(this._coreRuntimeAnimation)E=K-U,z=this._coreRuntimeAnimation.currentFrame,this._currentFrame=z,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let A;(U<this._minFrame||U>this._maxFrame)&&(U=this._minFrame),(K<this._minFrame||K>this._maxFrame)&&(K=this._maxFrame),E=K-U;let t=C*(e.framePerSecond*X)/1e3+this._absoluteFrameOffset,u=0,b=!1;const v=O&&this._animationState.loopMode===m.c.ANIMATIONLOOPMODE_YOYO;if(v){const C=(t-U)/E,K=Math.sin(C*Math.PI);t=Math.abs(K)*E+U;const m=K>=0?1:-1;this._yoyoDirection!==m&&(b=!0),this._yoyoDirection=m}if(this._previousElapsedTime=C,this._previousAbsoluteFrame=t,!O&&K>=U&&(t>=E&&X>0||t<=0&&X<0))j=!1,u=e._getKeyValue(this._maxValue);else if(!O&&U>=K&&(t<=E&&X<0||t>=0&&X>0))j=!1,u=e._getKeyValue(this._minValue);else if(this._animationState.loopMode!==m.c.ANIMATIONLOOPMODE_CYCLE){const C=K.toString()+U.toString();if(!this._offsetsCache[C]){this._animationState.repeatCount=0,this._animationState.loopMode=m.c.ANIMATIONLOOPMODE_CYCLE;const O=e._interpolate(U,this._animationState),X=e._interpolate(K,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),e.dataType){case m.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[C]=X-O;break;case m.c.ANIMATIONTYPE_QUATERNION:case m.c.ANIMATIONTYPE_VECTOR3:case m.c.ANIMATIONTYPE_VECTOR2:case m.c.ANIMATIONTYPE_SIZE:case m.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[C]=X.vU(O)}this._highLimitsCache[C]=X}u=this._highLimitsCache[C],A=this._offsetsCache[C]}if(void 0===A)switch(e.dataType){case m.c.ANIMATIONTYPE_FLOAT:A=0;break;case m.c.ANIMATIONTYPE_QUATERNION:A=m.i;break;case m.c.ANIMATIONTYPE_VECTOR3:A=m.s;break;case m.c.ANIMATIONTYPE_VECTOR2:A=m.p;break;case m.c.ANIMATIONTYPE_SIZE:A=m.m;break;case m.c.ANIMATIONTYPE_COLOR3:A=m.d;break;case m.c.ANIMATIONTYPE_COLOR4:A=m.g}if(this._host&&this._host.syncRoot){const C=this._host.syncRoot;z=U+E*((C.masterFrame-C.fromFrame)/(C.toFrame-C.fromFrame))}else z=t>0&&U>K||t<0&&U<K?j&&0!==E?K+t%E:U:j&&0!==E?U+t%E:K;if(!v&&(X>0&&this.currentFrame>z||X<0&&this.currentFrame<z)||v&&b){this._onLoop();for(let C=0;C<p.length;C++)p[C].onlyOnce||(p[C].isDone=!1);this._animationState.key=X>0?0:e.getKeys().length-1}this._currentFrame=z,this._animationState.repeatCount=0===E?0:t/E|0,this._animationState.highLimitValue=u,this._animationState.offsetValue=A}const u=e._interpolate(z,this._animationState);if(this.setValue(u,A),p.length)for(let m=0;m<p.length;m++)if(E>=0&&z>=p[m].frame&&p[m].frame>=U||E<0&&z<=p[m].frame&&p[m].frame<=U){const C=p[m];C.isDone||(C.onlyOnce&&(p.splice(m,1),m--),C.isDone=!0,C.action(z))}return j||(this._stopped=!0),j}}var j=K(11688);class p{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(C){this._weight=-1!==C?Math.min(Math.max(C,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(C){for(let U=0;U<this._runtimeAnimations.length;U++){this._runtimeAnimations[U]._prepareForSpeedRatioChange(C)}this._speedRatio=C,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(C,U){let K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,X=arguments.length>4&&void 0!==arguments[4]&&arguments[4],A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,e=arguments.length>6?arguments[6]:void 0,t=arguments.length>7?arguments[7]:void 0,z=arguments.length>8?arguments[8]:void 0,j=arguments.length>9&&void 0!==arguments[9]&&arguments[9],p=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=U,this.fromFrame=K,this.toFrame=m,this.loopAnimation=X,this.onAnimationEnd=e,this.onAnimationLoop=z,this.isAdditive=j,this.playOrder=p,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.gA=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new O.b,this.onAnimationLoopObservable=new O.b,this._scene=C,t&&this.appendAnimations(U,t),this._speedRatio=A,C._activeAnimatables.push(this)}syncWith(C){if(this._syncRoot=C,C){const C=this._scene._activeAnimatables.indexOf(this);C>-1&&(this._scene._activeAnimatables.splice(C,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(C,U){for(let K=0;K<U.length;K++){const m=U[K],O=new z(C,m,this._scene,this);O._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(O)}}getAnimationByTargetProperty(C){const U=this._runtimeAnimations;for(let K=0;K<U.length;K++)if(U[K].animation.targetProperty===C)return U[K].animation;return null}getRuntimeAnimationByTargetProperty(C){const U=this._runtimeAnimations;for(let K=0;K<U.length;K++)if(U[K].animation.targetProperty===C)return U[K];return null}reset(){const C=this._runtimeAnimations;for(let U=0;U<C.length;U++)C[U].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(C){const U=this._runtimeAnimations;for(let K=0;K<U.length;K++)U[K].animation.enableBlending=!0,U[K].animation.blendingSpeed=C}disableBlending(){const C=this._runtimeAnimations;for(let U=0;U<C.length;U++)C[U].animation.enableBlending=!1}goToFrame(C){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const K=this._runtimeAnimations;if(K[0]){const U=K[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??K[0].currentFrame;const m=0===this.speedRatio?0:(C-this._frameToSyncFromJump)/U*1e3/this.speedRatio;this._manualJumpDelay=-m}for(let m=0;m<K.length;m++)K[m].goToFrame(C,U?this._weight:-1);this._goToFrame=C}get paused(){return this.gA}pause(){this.gA||(this.gA=!0)}restart(){this.gA=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(C,U){let K=arguments.length>2&&void 0!==arguments[2]&&arguments[2],m=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(C||U){const O=this._scene._activeAnimatables.indexOf(this);if(O>-1){const X=this._runtimeAnimations;for(let K=X.length-1;K>=0;K--){const m=X[K];C&&m.animation.name!=C||(U&&!U(m.target)||(m.dispose(),X.splice(K,1)))}0==X.length&&(K||this._scene._activeAnimatables.splice(O,1),m||this._raiseOnAnimationEnd())}}else{const C=this._scene._activeAnimatables.indexOf(this);if(C>-1){K||this._scene._activeAnimatables.splice(C,1);const U=this._runtimeAnimations;for(let C=0;C<U.length;C++)U[C].dispose();this._runtimeAnimations.length=0,m||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((C=>{this.onAnimationEndObservable.add((()=>{C(this)}),void 0,void 0,this,!0)}))}_animate(C){if(this.gA)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=C),!0;if(null===this._localDelayOffset?(this._localDelayOffset=C,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=C-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let U=!1;const K=this._runtimeAnimations;let m;for(m=0;m<K.length;m++){const O=K[m].animate(C-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);U=U||O}if(this.animationStarted=U,!U){if(this.disposeOnEnd)for(m=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(m,1),m=0;m<K.length;m++)K[m].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return U}}function E(C){if(0===C.totalWeight&&0===C.totalAdditiveWeight)return C.originalValue;let U=1;const K=t.TmpVectors.bU[0],m=t.TmpVectors.bU[1],O=t.TmpVectors.Quaternion[0];let X=0;const A=C.animations[0],e=C.originalValue;let z=1,j=!1;if(C.totalWeight<1)z=1-C.totalWeight,e.decompose(m,O,K);else{if(X=1,U=C.totalWeight,z=A.weight/U,1==z){if(!C.totalAdditiveWeight)return A.currentValue;j=!0}A.currentValue.decompose(m,O,K)}if(!j){m.scaleInPlace(z),K.scaleInPlace(z),O.scaleInPlace(z);for(let A=X;A<C.animations.length;A++){const X=C.animations[A];if(0===X.weight)continue;z=X.weight/U;const e=t.TmpVectors.bU[2],j=t.TmpVectors.bU[3],p=t.TmpVectors.Quaternion[1];X.currentValue.decompose(j,p,e),j.scaleAndAddToRef(z,m),p.scaleAndAddToRef(t.Quaternion.Dot(O,p)>0?z:-z,O),e.scaleAndAddToRef(z,K)}O.normalize()}for(let E=0;E<C.additiveAnimations.length;E++){const U=C.additiveAnimations[E];if(0===U.weight)continue;const X=t.TmpVectors.bU[2],A=t.TmpVectors.bU[3],e=t.TmpVectors.Quaternion[1];U.currentValue.decompose(A,e,X),A.multiplyToRef(m,A),t.bU.LerpToRef(m,A,U.weight,m),O.multiplyToRef(e,e),t.Quaternion.SlerpToRef(O,e,U.weight,O),X.scaleAndAddToRef(U.weight,K)}const p=A?A._animationState.workValue:t.TmpVectors.Matrix[0].clone();return t.Matrix.ComposeToRef(m,O,K,p),p}function u(C,U){if(0===C.totalWeight&&0===C.totalAdditiveWeight)return U;const K=C.animations[0],m=C.originalValue;let O=U;if(0===C.totalWeight&&C.totalAdditiveWeight>0)O.m(m);else if(1===C.animations.length){if(t.Quaternion.SlerpToRef(m,K.currentValue,Math.min(1,C.totalWeight),O),0===C.totalAdditiveWeight)return O}else if(C.animations.length>1){let K,X,A=1;if(C.totalWeight<1){const U=1-C.totalWeight;K=[],X=[],K.push(m),X.push(U)}else{if(2===C.animations.length&&(t.Quaternion.SlerpToRef(C.animations[0].currentValue,C.animations[1].currentValue,C.animations[1].weight/C.totalWeight,U),0===C.totalAdditiveWeight))return U;K=[],X=[],A=C.totalWeight}for(let U=0;U<C.animations.length;U++){const m=C.animations[U];K.push(m.currentValue),X.push(m.weight/A)}let e=0;for(let C=0;C<K.length;)C?(e+=X[C],t.Quaternion.SlerpToRef(O,K[C],X[C]/e,O),C++):(t.Quaternion.SlerpToRef(K[C],K[C+1],X[C+1]/(X[C]+X[C+1]),U),O=U,e=X[C]+X[C+1],C+=2)}for(let X=0;X<C.additiveAnimations.length;X++){const U=C.additiveAnimations[X];0!==U.weight&&(O.multiplyToRef(U.currentValue,t.TmpVectors.Quaternion[0]),t.Quaternion.SlerpToRef(O,t.TmpVectors.Quaternion[0],U.weight,O))}return O}var b,v,Q=K(12078);b=Q.b,(v=e.c)&&(v.prototype.copyAnimationRange=function(C,U,K){let O=arguments.length>3&&void 0!==arguments[3]&&arguments[3],X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new m.c(this.name,"_matrix",C.animations[0].framePerSecond,m.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const A=C.animations[0].getRange(U);if(!A)return!1;const e=A.from,t=A.to,z=C.animations[0].getKeys(),j=C.length,p=C.getParent(),E=this.getParent(),u=O&&p&&j&&this.length&&j!==this.length,b=u&&E&&p?E.length/p.length:1,v=O&&!E&&X&&(1!==X.x||1!==X.y||1!==X.z),Q=this.animations[0].getKeys();let V,f,F;for(let m=0,Z=z.length;m<Z;m++)V=z[m],V.frame>=e&&V.frame<=t&&(O?(F=V.value.clone(),u?(f=F.getTranslation(),F.setTranslation(f.scaleInPlace(b))):v&&X?(f=F.getTranslation(),F.setTranslation(f.multiplyInPlace(X))):F=V.value):F=V.value,Q.push({frame:V.frame+K,value:F}));return this.animations[0].createRange(U,e+K,t+K),!0}),b&&(b.prototype._animate=function(C){if(!this.animationsEnabled)return;const U=j.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=U}this.deltaTime=void 0!==C?C:this.useConstantAnimationDeltaTime?16:(U-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=U;const K=this._activeAnimatables;if(0===K.length)return;this._animationTime+=this.deltaTime;const O=this._animationTime;for(let m=0;m<K.length;m++){const C=K[m];!C._animate(O)&&C.disposeOnEnd&&m--}!function(C){if(C._registeredForLateAnimationBindings.length){for(let U=0;U<C._registeredForLateAnimationBindings.length;U++){const K=C._registeredForLateAnimationBindings.data[U];for(const C in K._lateAnimationHolders){const U=K._lateAnimationHolders[C],O=U.animations[0],X=U.originalValue;if(void 0===X||null===X)continue;const A=m.c.AllowMatrixDecomposeForInterpolation&&X.m;let e=K[C];if(A)e=E(U);else if(void 0!==X.w)e=u(U,e||t.Quaternion.Identity());else{let C=0,K=1;const A=O&&O._animationState.loopMode===m.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(U.totalWeight<1)e=A?X.clone?X.clone():X:O&&X.scale?X.scale(1-U.totalWeight):O?X*(1-U.totalWeight):X.clone?X.clone():X;else if(O){K=U.totalWeight;const m=O.weight/K;e=1!==m?O.currentValue.scale?O.currentValue.scale(m):O.currentValue*m:O.currentValue,A&&(e.addToRef?e.addToRef(X,e):e+=X),C=1}for(let m=C;m<U.animations.length;m++){const C=U.animations[m],O=C.weight/K;O&&(C.currentValue.scaleAndAddToRef?C.currentValue.scaleAndAddToRef(O,e):e+=C.currentValue*O)}for(let m=0;m<U.additiveAnimations.length;m++){const C=U.additiveAnimations[m],K=C.weight;K&&(C.currentValue.scaleAndAddToRef?C.currentValue.scaleAndAddToRef(K,e):e+=C.currentValue*K)}}K[C]=e}K._lateAnimationHolders={}}C._registeredForLateAnimationBindings.reset()}}(this)},b.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((C,U)=>C.playOrder-U.playOrder))},b.prototype.beginWeightedAnimation=function(C,U,K){let m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,O=arguments.length>4?arguments[4]:void 0,X=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,e=arguments.length>7?arguments[7]:void 0,t=arguments.length>8?arguments[8]:void 0,z=arguments.length>9?arguments[9]:void 0,j=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const p=this.beginAnimation(C,U,K,O,X,A,e,!1,t,z,j);return p.weight=m,p},b.prototype.beginAnimation=function(C,U,K,m){let O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,X=arguments.length>5?arguments[5]:void 0,A=arguments.length>6?arguments[6]:void 0,e=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],t=arguments.length>8?arguments[8]:void 0,z=arguments.length>9?arguments[9]:void 0,j=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(O<0){const C=U;U=K,K=C,O=-O}U>K&&(O=-O),e&&this.stopAnimation(C,void 0,t),A||(A=new p(this,C,U,K,m,O,X,void 0,z,j));const E=!t||t(C);if(C.animations&&E&&A.appendAnimations(C,C.animations),C.getAnimatables){const j=C.getAnimatables();for(let C=0;C<j.length;C++)this.beginAnimation(j[C],U,K,m,O,X,A,e,t,z)}return A.reset(),A},b.prototype.beginHierarchyAnimation=function(C,U,K,m,O){let X=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,e=arguments.length>7?arguments[7]:void 0,t=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],z=arguments.length>9?arguments[9]:void 0,j=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const p=C.getDescendants(U),E=[];E.push(this.beginAnimation(C,K,m,O,X,A,e,t,z,void 0,j));for(const u of p)E.push(this.beginAnimation(u,K,m,O,X,A,e,t,z,void 0,j));return E},b.prototype.beginDirectAnimation=function(C,U,K,m,O){let X=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(X<0){const C=K;K=m,m=C,X=-X}return K>m&&(X=-X),new p(this,C,K,m,O,X,arguments.length>6?arguments[6]:void 0,U,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},b.prototype.beginDirectHierarchyAnimation=function(C,U,K,m,O,X,A,e,t){let z=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const j=C.getDescendants(U),p=[];p.push(this.beginDirectAnimation(C,K,m,O,X,A,e,t,z));for(const E of j)p.push(this.beginDirectAnimation(E,K,m,O,X,A,e,t,z));return p},b.prototype.getAnimatableByTarget=function(C){for(let U=0;U<this._activeAnimatables.length;U++)if(this._activeAnimatables[U].target===C)return this._activeAnimatables[U];return null},b.prototype.getAllAnimatablesByTarget=function(C){const U=[];for(let K=0;K<this._activeAnimatables.length;K++)this._activeAnimatables[K].target===C&&U.push(this._activeAnimatables[K]);return U},b.prototype.stopAnimation=function(C,U,K){const m=this.getAllAnimatablesByTarget(C);for(const O of m)O.stop(U,K)},b.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let C=0;C<this._activeAnimatables.length;C++)this._activeAnimatables[C].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const C of this.animationGroups)C.stop()});class V{getClassName(){return"TargetedAnimation"}serialize(){const C={};return C.animation=this.animation.serialize(),C.targetId=this.target.id,C}}class f{get mask(){return this._mask}set mask(C){this._mask!==C&&(this._mask=C,this.syncWithMask(!0))}syncWithMask(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||C){this._numActiveAnimatables=0;for(let C=0;C<this._animatables.length;++C){const U=this._animatables[C];!this.mask||this.mask.disabled||this.mask.retainsTarget(U.target.name)?(this._numActiveAnimatables++,U.paused&&U.restart()):U.paused||U.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let C=0;C<this._animatables.length;++C){const U=this._animatables[C];this.mask.retainsTarget(U.target.name)||(U.stop(),this._animatables.splice(C,1),--C)}for(let C=0;C<this._targetedAnimations.length;C++){const U=this._targetedAnimations[C];this.mask.retainsTarget(U.target.name)||(this._targetedAnimations.splice(C,1),--C)}}}get from(){return this._from}set from(C){if(this._from!==C){this._from=C;for(let C=0;C<this._animatables.length;C++){this._animatables[C].fromFrame=this._from}}}get to(){return this._to}set to(C){if(this._to!==C){this._to=C;for(let C=0;C<this._animatables.length;C++){this._animatables[C].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(C){if(this._speedRatio!==C){this._speedRatio=C;for(let C=0;C<this._animatables.length;C++){this._animatables[C].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(C){if(this._loopAnimation!==C){this._loopAnimation=C;for(let C=0;C<this._animatables.length;C++){this._animatables[C].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(C){if(this._isAdditive!==C){this._isAdditive=C;for(let C=0;C<this._animatables.length;C++){this._animatables[C].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(C){this._weight!==C&&(this._weight=C,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(C){if(this._playOrder!==C&&(this._playOrder=C,this._animatables.length>0)){for(let C=0;C<this._animatables.length;C++)this._animatables[C].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(C){if(this._enableBlending!==C&&(this._enableBlending=C,null!==C))for(let U=0;U<this._targetedAnimations.length;++U)this._targetedAnimations[U].animation.enableBlending=C}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(C){if(this._blendingSpeed!==C&&(this._blendingSpeed=C,null!==C))for(let U=0;U<this._targetedAnimations.length;++U)this._targetedAnimations[U].animation.blendingSpeed=C}getLength(C,U){C=C??this._from;return((U=U??this._to)-C)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(C){let U=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],K=arguments.length>2&&void 0!==arguments[2]&&arguments[2],m=arguments.length>3?arguments[3]:void 0;if(0===C.length)return null;m=m??C[0].weight;let O=Number.MAX_VALUE,X=-Number.MAX_VALUE;if(K)for(const e of C)e.from<O&&(O=e.from),e.to>X&&(X=e.to);const A=new f(C[0].name+"_merged",C[0]._scene,m);for(const e of C){K&&e.normalize(O,X);for(const C of e.targetedAnimations)A.addTargetedAnimation(C.animation,C.target);U&&e.dispose()}return A}constructor(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=C,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new O.b,this.onAnimationLoopObservable=new O.b,this.onAnimationGroupLoopObservable=new O.b,this.onAnimationGroupEndObservable=new O.b,this.onAnimationGroupPauseObservable=new O.b,this.onAnimationGroupPlayObservable=new O.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=U||X.c.LastCreatedScene,this._weight=K,this._playOrder=m,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(C,U){const K=new V;K.animation=C,K.target=U;const m=C.getKeys();return this._from>m[0].frame&&(this._from=m[0].frame),this._to<m[m.length-1].frame&&(this._to=m[m.length-1].frame),null!==this._enableBlending&&(C.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(C.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(K),this._shouldStart=!0,K}removeTargetedAnimation(C){for(let U=this._targetedAnimations.length-1;U>-1;U--){this._targetedAnimations[U].animation===C&&this._targetedAnimations.splice(U,1)}}normalize(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==C&&(C=this._from),null==U&&(U=this._to);for(let K=0;K<this._targetedAnimations.length;K++){const m=this._targetedAnimations[K].animation.getKeys(),O=m[0],X=m[m.length-1];if(O.frame>C){const U={frame:C,value:O.value,inTangent:O.inTangent,outTangent:O.outTangent,interpolation:O.interpolation};m.splice(0,0,U)}if(X.frame<U){const C={frame:U,value:X.value,inTangent:X.inTangent,outTangent:X.outTangent,interpolation:X.interpolation};m.push(C)}}return this._from=C,this._to=U,this}_processLoop(C,U,K){C.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(U),this._animationLoopFlags[K]||(this._animationLoopFlags[K]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0],U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,K=arguments.length>2?arguments[2]:void 0,m=arguments.length>3?arguments[3]:void 0,O=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=C,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let X=0;X<this._targetedAnimations.length;X++){const A=this._targetedAnimations[X],e=this._scene.beginDirectAnimation(A.target,[A.animation],void 0!==K?K:this._from,void 0!==m?m:this._to,C,U,void 0,void 0,void 0!==O?O:this._isAdditive);e.weight=this._weight,e.playOrder=this._playOrder,e.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(A),this._checkAnimationGroupEnded(e)},this._processLoop(e,A,X),this._animatables.push(e)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=U,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let C=0;C<this._animatables.length;C++){this._animatables[C].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(C){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==C&&(this.loopAnimation=C),this.restart()):(this.stop(),this.start(C,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let C=0;C<this._animatables.length;C++){this._animatables[C].reset()}return this}restart(){if(!this._isStarted)return this;for(let C=0;C<this._animatables.length;C++){this._animatables[C].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const U=this._animatables.slice();for(let m=0;m<U.length;m++)U[m].stop(void 0,void 0,!0,C);let K=0;for(let m=0;m<this._scene._activeAnimatables.length;m++){const U=this._scene._activeAnimatables[m];U._runtimeAnimations.length>0?this._scene._activeAnimatables[K++]=U:C&&this._checkAnimationGroupEnded(U,C)}return this._scene._activeAnimatables.length=K,this._isStarted=!1,this}setWeightForAllAnimatables(C){for(let U=0;U<this._animatables.length;U++){this._animatables[U].weight=C}return this}syncAllAnimationsWith(C){for(let U=0;U<this._animatables.length;U++){this._animatables[U].syncWith(C)}return this}goToFrame(C){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let K=0;K<this._animatables.length;K++){this._animatables[K].goToFrame(C,U)}return this}getCurrentFrame(){var C;return(null===(C=this.animatables[0])||void 0===C?void 0:C.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const C=this._scene.animationGroups.indexOf(this);if(C>-1&&this._scene.animationGroups.splice(C,1),this._parentContainer){const C=this._parentContainer.animationGroups.indexOf(this);C>-1&&this._parentContainer.animationGroups.splice(C,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(C){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const K=this._animatables.indexOf(C);K>-1&&this._animatables.splice(K,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,U||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(C,U){let K=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const m=new f(C||this.name,this._scene,this._weight,this._playOrder);m._from=this.from,m._to=this.to,m._speedRatio=this.speedRatio,m._loopAnimation=this.loopAnimation,m._isAdditive=this.isAdditive,m._enableBlending=this.enableBlending,m._blendingSpeed=this.blendingSpeed,m.metadata=this.metadata,m.mask=this.mask;for(const O of this._targetedAnimations)m.addTargetedAnimation(K?O.animation.clone():O.animation,U?U(O.target):O.target);return m}serialize(){const C={};C.name=this.name,C.from=this.from,C.to=this.to,C.speedRatio=this.speedRatio,C.loopAnimation=this.loopAnimation,C.isAdditive=this.isAdditive,C.weight=this.weight,C.playOrder=this.playOrder,C.enableBlending=this.enableBlending,C.blendingSpeed=this.blendingSpeed,C.targetedAnimations=[];for(let U=0;U<this.targetedAnimations.length;U++){const K=this.targetedAnimations[U];C.targetedAnimations[U]=K.serialize()}return A.d&&A.d.HasTags(this)&&(C.tags=A.d.GetTags(this)),this.metadata&&(C.metadata=this.metadata),C}static Parse(C,U){const K=new f(C.name,U,C.weight,C.playOrder);for(let O=0;O<C.targetedAnimations.length;O++){const X=C.targetedAnimations[O],A=m.c.Parse(X.animation),e=X.targetId;if("influence"===X.animation.property){const C=U.getMorphTargetById(e);C&&K.addTargetedAnimation(A,C)}else{const C=U.getNodeById(e);null!=C&&K.addTargetedAnimation(A,C)}}return A.d&&A.d.AddTagsTo(K,C.tags),null!==C.from&&null!==C.to&&K.normalize(C.from,C.to),void 0!==C.speedRatio&&(K._speedRatio=C.speedRatio),void 0!==C.loopAnimation&&(K._loopAnimation=C.loopAnimation),void 0!==C.isAdditive&&(K._isAdditive=C.isAdditive),void 0!==C.weight&&(K._weight=C.weight),void 0!==C.playOrder&&(K._playOrder=C.playOrder),void 0!==C.enableBlending&&(K._enableBlending=C.enableBlending),void 0!==C.blendingSpeed&&(K._blendingSpeed=C.blendingSpeed),void 0!==C.metadata&&(K.metadata=C.metadata),K}static MakeAnimationAdditive(C,U,K){let O;O="object"===typeof U?U:{referenceFrame:U,range:K,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let X=C;O.cloneOriginalAnimationGroup&&(X=C.clone(O.clonedAnimationGroupName||X.name));const A=X.targetedAnimations;for(let e=0;e<A.length;e++){const C=A[e];C.animation=m.c.MakeAnimationAdditive(C.animation,O)}if(X.isAdditive=!0,O.clipKeys){let C=Number.MAX_VALUE,U=-Number.MAX_VALUE;const K=X.targetedAnimations;for(let m=0;m<K.length;m++){const O=K[m].animation.getKeys();C>O[0].frame&&(C=O[0].frame),U<O[O.length-1].frame&&(U=O[O.length-1].frame)}X._from=C,X._to=U}return X}static ClipKeys(C,U,K,m,O){const X=C.clone(m||C.name);return f.ClipKeysInPlace(X,U,K,O)}static ClipKeysInPlace(C,U,K,m){return f.ClipInPlace(C,U,K,m,!1)}static ClipFrames(C,U,K,m,O){const X=C.clone(m||C.name);return f.ClipFramesInPlace(X,U,K,O)}static ClipFramesInPlace(C,U,K,m){return f.ClipInPlace(C,U,K,m,!0)}static ClipInPlace(C,U,K,m){let O=arguments.length>4&&void 0!==arguments[4]&&arguments[4],X=Number.MAX_VALUE,A=-Number.MAX_VALUE;const e=C.targetedAnimations;for(let t=0;t<e.length;t++){const C=e[t],z=m?C.animation:C.animation.clone();O&&(z.createKeyForFrame(U),z.createKeyForFrame(K));const j=z.getKeys(),p=[];let E=Number.MAX_VALUE;for(let m=0;m<j.length;m++){const C=j[m];if(!O&&m>=U&&m<=K||O&&C.frame>=U&&C.frame<=K){const U={frame:C.frame,value:C.value.clone?C.value.clone():C.value,inTangent:C.inTangent,outTangent:C.outTangent,interpolation:C.interpolation,lockedTangent:C.lockedTangent};E===Number.MAX_VALUE&&(E=U.frame),U.frame-=E,p.push(U)}}0!==p.length?(X>p[0].frame&&(X=p[0].frame),A<p[p.length-1].frame&&(A=p[p.length-1].frame),z.setKeys(p,!0),C.animation=z):(e.splice(t,1),t--)}return C._from=X,C._to=A,C}getClassName(){return"AnimationGroup"}toString(C){let U="Name: "+this.name;return U+=", type: "+this.getClassName(),C&&(U+=", from: "+this._from,U+=", to: "+this._to,U+=", isStarted: "+this._isStarted,U+=", speedRatio: "+this._speedRatio,U+=", targetedAnimations length: "+this._targetedAnimations.length,U+=", animatables length: "+this._animatables),U}}}}]);