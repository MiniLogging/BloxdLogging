"use strict";(self.fkqm0epoq5=self.fkqm0epoq5||[]).push([[78],{14806:(D,l,G)=>{G.r(l),G.d(l,{AnimationGroup:()=>h,TargetedAnimation:()=>H});var V=G(12247),N=G(11532),M=G(11571),b=G(11746),X=G(13350),t=G(11710);class R{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(D,l,G,N){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=l,this._target=D,this._scene=G,this._host=N,this._activeTargets=[],l._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===V.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=t.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const D={frame:0,value:this._minValue};this._keys.splice(0,0,D)}if(this._target instanceof Array){let D=0;for(const l of this._target)this._preparePath(l,D),this._getOriginalValues(D),D++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const M=l.getEvents();if(M&&M.length>0)for(const V of M)this._events.push(V._clone());this._enableBlending=D&&D.animationPropertiesOverride?D.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const G=this._animation.targetPropertyPath;if(G.length>1){let V=D;for(let D=0;D<G.length-1;D++){const l=G[D];if(V=V[l],void 0===V)throw new Error(`Invalid property (${l}) in property path (${G.join(".")})`)}this._targetPath=G[G.length-1],this._activeTargets[l]=V}else this._targetPath=G[0],this._activeTargets[l]=D;if(void 0===this._activeTargets[l][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${G.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let D=0;for(const l of this._target)void 0!==this._originalValue[D]&&this._setValue(l,this._activeTargets[D],this._originalValue[D],-1,D),D++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let D=0;D<this._events.length;D++)this._events[D].isDone=!1}isStopped(){return this._stopped}dispose(){const D=this._animation.runtimeAnimations.indexOf(this);D>-1&&this._animation.runtimeAnimations.splice(D,1)}setValue(D,l){if(this._targetIsArray)for(let G=0;G<this._target.length;G++){const V=this._target[G];this._setValue(V,this._activeTargets[G],D,l,G)}else this._setValue(this._target,this._directTarget,D,l,0)}_getOriginalValues(){let D,l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const G=this._activeTargets[l];D=G.getLocalMatrix&&"_matrix"===this._targetPath?G.getLocalMatrix():G[this._targetPath],D&&D.clone?this._originalValue[l]=D.clone():this._originalValue[l]=D}_registerTargetForLateAnimationBinding(D,l){const G=D.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(G),G._lateAnimationHolders||(G._lateAnimationHolders={}),G._lateAnimationHolders[D.targetPath]||(G._lateAnimationHolders[D.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:l}),D.isAdditive?(G._lateAnimationHolders[D.targetPath].additiveAnimations.push(D),G._lateAnimationHolders[D.targetPath].totalAdditiveWeight+=D.weight):(G._lateAnimationHolders[D.targetPath].animations.push(D),G._lateAnimationHolders[D.targetPath].totalWeight+=D.weight)}_setValue(D,l,G,N,M){if(this._currentActiveTarget=l,this._weight=N,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const D=l[this._targetPath];D.clone?this._originalBlendValue=D.clone():this._originalBlendValue=D}this._originalBlendValue.m?V.b.AllowMatrixDecomposeForInterpolation?this._currentValue?t.Matrix.DecomposeLerpToRef(this._originalBlendValue,G,this._blendingFactor,this._currentValue):this._currentValue=t.Matrix.DecomposeLerp(this._originalBlendValue,G,this._blendingFactor):this._currentValue?t.Matrix.LerpToRef(this._originalBlendValue,G,this._blendingFactor,this._currentValue):this._currentValue=t.Matrix.Lerp(this._originalBlendValue,G,this._blendingFactor):this._currentValue=V.b._UniversalLerp(this._originalBlendValue,G,this._blendingFactor);const N=D&&D.animationPropertiesOverride?D.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=N}else this._currentValue?this._currentValue.V?this._currentValue.V(G):this._currentValue=G:null!==G&&void 0!==G&&G.clone?this._currentValue=G.clone():this._currentValue=G;-1!==N?this._registerTargetForLateAnimationBinding(this,this._originalValue[M]):this._animationState.loopMode===V.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[M],l[this._targetPath]):l[this._targetPath]=this._originalValue[M]+this._currentValue:l[this._targetPath]=this._currentValue,D.QR&&D.QR(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const G=this._animation.getKeys();D<G[0].frame?D=G[0].frame:D>G[G.length-1].frame&&(D=G[G.length-1].frame);const V=this._events;if(V.length)for(let M=0;M<V.length;M++)V[M].onlyOnce||(V[M].isDone=V[M].frame<D);this._currentFrame=D;const N=this._animation._interpolate(D,this._animationState);this.setValue(N,l)}_prepareForSpeedRatioChange(D){const l=this._previousElapsedTime*(this._animation.framePerSecond*D)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-l}animate(D,l,G,N,M){let b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const X=this._animation,t=X.targetPropertyPath;if(!t||t.length<1)return this._stopped=!0,!1;let R,n=!0;const g=this._events;let j=0;if(this._coreRuntimeAnimation)j=G-l,R=this._coreRuntimeAnimation.currentFrame,this._currentFrame=R,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let b;(l<this._minFrame||l>this._maxFrame)&&(l=this._minFrame),(G<this._minFrame||G>this._maxFrame)&&(G=this._maxFrame),j=G-l;let t=D*(X.framePerSecond*M)/1e3+this._absoluteFrameOffset,e=0,K=!1;const F=N&&this._animationState.loopMode===V.b.ANIMATIONLOOPMODE_YOYO;if(F){const D=(t-l)/j,G=Math.sin(D*Math.PI);t=Math.abs(G)*j+l;const V=G>=0?1:-1;this._yoyoDirection!==V&&(K=!0),this._yoyoDirection=V}if(this._previousElapsedTime=D,this._previousAbsoluteFrame=t,!N&&G>=l&&(t>=j&&M>0||t<=0&&M<0))n=!1,e=X._getKeyValue(this._maxValue);else if(!N&&l>=G&&(t<=j&&M<0||t>=0&&M>0))n=!1,e=X._getKeyValue(this._minValue);else if(this._animationState.loopMode!==V.b.ANIMATIONLOOPMODE_CYCLE){const D=G.toString()+l.toString();if(!this._offsetsCache[D]){this._animationState.repeatCount=0,this._animationState.loopMode=V.b.ANIMATIONLOOPMODE_CYCLE;const N=X._interpolate(l,this._animationState),M=X._interpolate(G,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),X.dataType){case V.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[D]=M-N;break;case V.b.ANIMATIONTYPE_QUATERNION:case V.b.ANIMATIONTYPE_VECTOR3:case V.b.ANIMATIONTYPE_VECTOR2:case V.b.ANIMATIONTYPE_SIZE:case V.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[D]=M.Fl(N)}this._highLimitsCache[D]=M}e=this._highLimitsCache[D],b=this._offsetsCache[D]}if(void 0===b)switch(X.dataType){case V.b.ANIMATIONTYPE_FLOAT:b=0;break;case V.b.ANIMATIONTYPE_QUATERNION:b=V.l;break;case V.b.ANIMATIONTYPE_VECTOR3:b=V.t;break;case V.b.ANIMATIONTYPE_VECTOR2:b=V.r;break;case V.b.ANIMATIONTYPE_SIZE:b=V.o;break;case V.b.ANIMATIONTYPE_COLOR3:b=V.d;break;case V.b.ANIMATIONTYPE_COLOR4:b=V.h}if(this._host&&this._host.syncRoot){const D=this._host.syncRoot;R=l+j*((D.masterFrame-D.fromFrame)/(D.toFrame-D.fromFrame))}else R=t>0&&l>G||t<0&&l<G?n&&0!==j?G+t%j:l:n&&0!==j?l+t%j:G;if(!F&&(M>0&&this.currentFrame>R||M<0&&this.currentFrame<R)||F&&K){this._onLoop();for(let D=0;D<g.length;D++)g[D].onlyOnce||(g[D].isDone=!1);this._animationState.key=M>0?0:X.getKeys().length-1}this._currentFrame=R,this._animationState.repeatCount=0===j?0:t/j|0,this._animationState.highLimitValue=e,this._animationState.offsetValue=b}const e=X._interpolate(R,this._animationState);if(this.setValue(e,b),g.length)for(let V=0;V<g.length;V++)if(j>=0&&R>=g[V].frame&&g[V].frame>=l||j<0&&R<=g[V].frame&&g[V].frame<=l){const D=g[V];D.isDone||(D.onlyOnce&&(g.splice(V,1),V--),D.isDone=!0,D.action(R))}return n||(this._stopped=!0),n}}var n=G(11554);class g{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(D){this._weight=-1!==D?Math.min(Math.max(D,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(D){for(let l=0;l<this._runtimeAnimations.length;l++){this._runtimeAnimations[l]._prepareForSpeedRatioChange(D)}this._speedRatio=D,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(D,l){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,M=arguments.length>4&&void 0!==arguments[4]&&arguments[4],b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,X=arguments.length>6?arguments[6]:void 0,t=arguments.length>7?arguments[7]:void 0,R=arguments.length>8?arguments[8]:void 0,n=arguments.length>9&&void 0!==arguments[9]&&arguments[9],g=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=l,this.fromFrame=G,this.toFrame=V,this.loopAnimation=M,this.onAnimationEnd=X,this.onAnimationLoop=R,this.isAdditive=n,this.playOrder=g,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.cX=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new N.e,this.onAnimationLoopObservable=new N.e,this._scene=D,t&&this.appendAnimations(l,t),this._speedRatio=b,D._activeAnimatables.push(this)}syncWith(D){if(this._syncRoot=D,D){const D=this._scene._activeAnimatables.indexOf(this);D>-1&&(this._scene._activeAnimatables.splice(D,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(D,l){for(let G=0;G<l.length;G++){const V=l[G],N=new R(D,V,this._scene,this);N._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(N)}}getAnimationByTargetProperty(D){const l=this._runtimeAnimations;for(let G=0;G<l.length;G++)if(l[G].animation.targetProperty===D)return l[G].animation;return null}getRuntimeAnimationByTargetProperty(D){const l=this._runtimeAnimations;for(let G=0;G<l.length;G++)if(l[G].animation.targetProperty===D)return l[G];return null}reset(){const D=this._runtimeAnimations;for(let l=0;l<D.length;l++)D[l].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(D){const l=this._runtimeAnimations;for(let G=0;G<l.length;G++)l[G].animation.enableBlending=!0,l[G].animation.blendingSpeed=D}disableBlending(){const D=this._runtimeAnimations;for(let l=0;l<D.length;l++)D[l].animation.enableBlending=!1}goToFrame(D){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const G=this._runtimeAnimations;if(G[0]){const l=G[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??G[0].currentFrame;const V=0===this.speedRatio?0:(D-this._frameToSyncFromJump)/l*1e3/this.speedRatio;this._manualJumpDelay=-V}for(let V=0;V<G.length;V++)G[V].goToFrame(D,l?this._weight:-1);this._goToFrame=D}get paused(){return this.cX}pause(){this.cX||(this.cX=!0)}restart(){this.cX=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(D,l){let G=arguments.length>2&&void 0!==arguments[2]&&arguments[2],V=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(D||l){const N=this._scene._activeAnimatables.indexOf(this);if(N>-1){const M=this._runtimeAnimations;for(let G=M.length-1;G>=0;G--){const V=M[G];D&&V.animation.name!=D||(l&&!l(V.target)||(V.dispose(),M.splice(G,1)))}0==M.length&&(G||this._scene._activeAnimatables.splice(N,1),V||this._raiseOnAnimationEnd())}}else{const D=this._scene._activeAnimatables.indexOf(this);if(D>-1){G||this._scene._activeAnimatables.splice(D,1);const l=this._runtimeAnimations;for(let D=0;D<l.length;D++)l[D].dispose();this._runtimeAnimations.length=0,V||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((D=>{this.onAnimationEndObservable.add((()=>{D(this)}),void 0,void 0,this,!0)}))}_animate(D){if(this.cX)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=D),!0;if(null===this._localDelayOffset?(this._localDelayOffset=D,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=D-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let l=!1;const G=this._runtimeAnimations;let V;for(V=0;V<G.length;V++){const N=G[V].animate(D-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);l=l||N}if(this.animationStarted=l,!l){if(this.disposeOnEnd)for(V=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(V,1),V=0;V<G.length;V++)G[V].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return l}}function j(D){if(0===D.totalWeight&&0===D.totalAdditiveWeight)return D.originalValue;let l=1;const G=t.TmpVectors.Kl[0],V=t.TmpVectors.Kl[1],N=t.TmpVectors.Quaternion[0];let M=0;const b=D.animations[0],X=D.originalValue;let R=1,n=!1;if(D.totalWeight<1)R=1-D.totalWeight,X.decompose(V,N,G);else{if(M=1,l=D.totalWeight,R=b.weight/l,1==R){if(!D.totalAdditiveWeight)return b.currentValue;n=!0}b.currentValue.decompose(V,N,G)}if(!n){V.scaleInPlace(R),G.scaleInPlace(R),N.scaleInPlace(R);for(let b=M;b<D.animations.length;b++){const M=D.animations[b];if(0===M.weight)continue;R=M.weight/l;const X=t.TmpVectors.Kl[2],n=t.TmpVectors.Kl[3],g=t.TmpVectors.Quaternion[1];M.currentValue.decompose(n,g,X),n.scaleAndAddToRef(R,V),g.scaleAndAddToRef(t.Quaternion.Dot(N,g)>0?R:-R,N),X.scaleAndAddToRef(R,G)}N.normalize()}for(let j=0;j<D.additiveAnimations.length;j++){const l=D.additiveAnimations[j];if(0===l.weight)continue;const M=t.TmpVectors.Kl[2],b=t.TmpVectors.Kl[3],X=t.TmpVectors.Quaternion[1];l.currentValue.decompose(b,X,M),b.multiplyToRef(V,b),t.Kl.LerpToRef(V,b,l.weight,V),N.multiplyToRef(X,X),t.Quaternion.SlerpToRef(N,X,l.weight,N),M.scaleAndAddToRef(l.weight,G)}const g=b?b._animationState.workValue:t.TmpVectors.Matrix[0].clone();return t.Matrix.ComposeToRef(V,N,G,g),g}function e(D,l){if(0===D.totalWeight&&0===D.totalAdditiveWeight)return l;const G=D.animations[0],V=D.originalValue;let N=l;if(0===D.totalWeight&&D.totalAdditiveWeight>0)N.V(V);else if(1===D.animations.length){if(t.Quaternion.SlerpToRef(V,G.currentValue,Math.min(1,D.totalWeight),N),0===D.totalAdditiveWeight)return N}else if(D.animations.length>1){let G,M,b=1;if(D.totalWeight<1){const l=1-D.totalWeight;G=[],M=[],G.push(V),M.push(l)}else{if(2===D.animations.length&&(t.Quaternion.SlerpToRef(D.animations[0].currentValue,D.animations[1].currentValue,D.animations[1].weight/D.totalWeight,l),0===D.totalAdditiveWeight))return l;G=[],M=[],b=D.totalWeight}for(let l=0;l<D.animations.length;l++){const V=D.animations[l];G.push(V.currentValue),M.push(V.weight/b)}let X=0;for(let D=0;D<G.length;)D?(X+=M[D],t.Quaternion.SlerpToRef(N,G[D],M[D]/X,N),D++):(t.Quaternion.SlerpToRef(G[D],G[D+1],M[D+1]/(M[D]+M[D+1]),l),N=l,X=M[D]+M[D+1],D+=2)}for(let M=0;M<D.additiveAnimations.length;M++){const l=D.additiveAnimations[M];0!==l.weight&&(N.multiplyToRef(l.currentValue,t.TmpVectors.Quaternion[0]),t.Quaternion.SlerpToRef(N,t.TmpVectors.Quaternion[0],l.weight,N))}return N}var K,F,d=G(11963);K=d.b,(F=X.e)&&(F.prototype.copyAnimationRange=function(D,l,G){let N=arguments.length>3&&void 0!==arguments[3]&&arguments[3],M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new V.b(this.name,"_matrix",D.animations[0].framePerSecond,V.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const b=D.animations[0].getRange(l);if(!b)return!1;const X=b.from,t=b.to,R=D.animations[0].getKeys(),n=D.length,g=D.getParent(),j=this.getParent(),e=N&&g&&n&&this.length&&n!==this.length,K=e&&j&&g?j.length/g.length:1,F=N&&!j&&M&&(1!==M.x||1!==M.y||1!==M.z),d=this.animations[0].getKeys();let H,h,x;for(let V=0,r=R.length;V<r;V++)H=R[V],H.frame>=X&&H.frame<=t&&(N?(x=H.value.clone(),e?(h=x.getTranslation(),x.setTranslation(h.scaleInPlace(K))):F&&M?(h=x.getTranslation(),x.setTranslation(h.multiplyInPlace(M))):x=H.value):x=H.value,d.push({frame:H.frame+G,value:x}));return this.animations[0].createRange(l,X+G,t+G),!0}),K&&(K.prototype._animate=function(D){if(!this.animationsEnabled)return;const l=n.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=l}this.deltaTime=void 0!==D?D:this.useConstantAnimationDeltaTime?16:(l-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=l;const G=this._activeAnimatables;if(0===G.length)return;this._animationTime+=this.deltaTime;const N=this._animationTime;for(let V=0;V<G.length;V++){const D=G[V];!D._animate(N)&&D.disposeOnEnd&&V--}!function(D){if(D._registeredForLateAnimationBindings.length){for(let l=0;l<D._registeredForLateAnimationBindings.length;l++){const G=D._registeredForLateAnimationBindings.data[l];for(const D in G._lateAnimationHolders){const l=G._lateAnimationHolders[D],N=l.animations[0],M=l.originalValue;if(void 0===M||null===M)continue;const b=V.b.AllowMatrixDecomposeForInterpolation&&M.m;let X=G[D];if(b)X=j(l);else if(void 0!==M.w)X=e(l,X||t.Quaternion.Identity());else{let D=0,G=1;const b=N&&N._animationState.loopMode===V.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(l.totalWeight<1)X=b?M.clone?M.clone():M:N&&M.scale?M.scale(1-l.totalWeight):N?M*(1-l.totalWeight):M.clone?M.clone():M;else if(N){G=l.totalWeight;const V=N.weight/G;X=1!==V?N.currentValue.scale?N.currentValue.scale(V):N.currentValue*V:N.currentValue,b&&(X.addToRef?X.addToRef(M,X):X+=M),D=1}for(let V=D;V<l.animations.length;V++){const D=l.animations[V],N=D.weight/G;N&&(D.currentValue.scaleAndAddToRef?D.currentValue.scaleAndAddToRef(N,X):X+=D.currentValue*N)}for(let V=0;V<l.additiveAnimations.length;V++){const D=l.additiveAnimations[V],G=D.weight;G&&(D.currentValue.scaleAndAddToRef?D.currentValue.scaleAndAddToRef(G,X):X+=D.currentValue*G)}}G[D]=X}G._lateAnimationHolders={}}D._registeredForLateAnimationBindings.reset()}}(this)},K.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((D,l)=>D.playOrder-l.playOrder))},K.prototype.beginWeightedAnimation=function(D,l,G){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,N=arguments.length>4?arguments[4]:void 0,M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,b=arguments.length>6?arguments[6]:void 0,X=arguments.length>7?arguments[7]:void 0,t=arguments.length>8?arguments[8]:void 0,R=arguments.length>9?arguments[9]:void 0,n=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const g=this.beginAnimation(D,l,G,N,M,b,X,!1,t,R,n);return g.weight=V,g},K.prototype.beginAnimation=function(D,l,G,V){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,M=arguments.length>5?arguments[5]:void 0,b=arguments.length>6?arguments[6]:void 0,X=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],t=arguments.length>8?arguments[8]:void 0,R=arguments.length>9?arguments[9]:void 0,n=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(N<0){const D=l;l=G,G=D,N=-N}l>G&&(N=-N),X&&this.stopAnimation(D,void 0,t),b||(b=new g(this,D,l,G,V,N,M,void 0,R,n));const j=!t||t(D);if(D.animations&&j&&b.appendAnimations(D,D.animations),D.getAnimatables){const n=D.getAnimatables();for(let D=0;D<n.length;D++)this.beginAnimation(n[D],l,G,V,N,M,b,X,t,R)}return b.reset(),b},K.prototype.beginHierarchyAnimation=function(D,l,G,V,N){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,b=arguments.length>6?arguments[6]:void 0,X=arguments.length>7?arguments[7]:void 0,t=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],R=arguments.length>9?arguments[9]:void 0,n=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const g=D.getDescendants(l),j=[];j.push(this.beginAnimation(D,G,V,N,M,b,X,t,R,void 0,n));for(const e of g)j.push(this.beginAnimation(e,G,V,N,M,b,X,t,R,void 0,n));return j},K.prototype.beginDirectAnimation=function(D,l,G,V,N){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(M<0){const D=G;G=V,V=D,M=-M}return G>V&&(M=-M),new g(this,D,G,V,N,M,arguments.length>6?arguments[6]:void 0,l,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},K.prototype.beginDirectHierarchyAnimation=function(D,l,G,V,N,M,b,X,t){let R=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const n=D.getDescendants(l),g=[];g.push(this.beginDirectAnimation(D,G,V,N,M,b,X,t,R));for(const j of n)g.push(this.beginDirectAnimation(j,G,V,N,M,b,X,t,R));return g},K.prototype.getAnimatableByTarget=function(D){for(let l=0;l<this._activeAnimatables.length;l++)if(this._activeAnimatables[l].target===D)return this._activeAnimatables[l];return null},K.prototype.getAllAnimatablesByTarget=function(D){const l=[];for(let G=0;G<this._activeAnimatables.length;G++)this._activeAnimatables[G].target===D&&l.push(this._activeAnimatables[G]);return l},K.prototype.stopAnimation=function(D,l,G){const V=this.getAllAnimatablesByTarget(D);for(const N of V)N.stop(l,G)},K.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let D=0;D<this._activeAnimatables.length;D++)this._activeAnimatables[D].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const D of this.animationGroups)D.stop()});class H{getClassName(){return"TargetedAnimation"}serialize(){const D={};return D.animation=this.animation.serialize(),D.targetId=this.target.id,D}}class h{get mask(){return this._mask}set mask(D){this._mask!==D&&(this._mask=D,this.syncWithMask(!0))}syncWithMask(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||D){this._numActiveAnimatables=0;for(let D=0;D<this._animatables.length;++D){const l=this._animatables[D];!this.mask||this.mask.disabled||this.mask.retainsTarget(l.target.name)?(this._numActiveAnimatables++,l.paused&&l.restart()):l.paused||l.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let D=0;D<this._animatables.length;++D){const l=this._animatables[D];this.mask.retainsTarget(l.target.name)||(l.stop(),this._animatables.splice(D,1),--D)}for(let D=0;D<this._targetedAnimations.length;D++){const l=this._targetedAnimations[D];this.mask.retainsTarget(l.target.name)||(this._targetedAnimations.splice(D,1),--D)}}}get from(){return this._from}set from(D){if(this._from!==D){this._from=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].fromFrame=this._from}}}get to(){return this._to}set to(D){if(this._to!==D){this._to=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(D){if(this._speedRatio!==D){this._speedRatio=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(D){if(this._loopAnimation!==D){this._loopAnimation=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(D){if(this._isAdditive!==D){this._isAdditive=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(D){this._weight!==D&&(this._weight=D,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(D){if(this._playOrder!==D&&(this._playOrder=D,this._animatables.length>0)){for(let D=0;D<this._animatables.length;D++)this._animatables[D].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(D){if(this._enableBlending!==D&&(this._enableBlending=D,null!==D))for(let l=0;l<this._targetedAnimations.length;++l)this._targetedAnimations[l].animation.enableBlending=D}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(D){if(this._blendingSpeed!==D&&(this._blendingSpeed=D,null!==D))for(let l=0;l<this._targetedAnimations.length;++l)this._targetedAnimations[l].animation.blendingSpeed=D}getLength(D,l){D=D??this._from;return((l=l??this._to)-D)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(D){let l=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],G=arguments.length>2&&void 0!==arguments[2]&&arguments[2],V=arguments.length>3?arguments[3]:void 0;if(0===D.length)return null;V=V??D[0].weight;let N=Number.MAX_VALUE,M=-Number.MAX_VALUE;if(G)for(const X of D)X.from<N&&(N=X.from),X.to>M&&(M=X.to);const b=new h(D[0].name+"_merged",D[0]._scene,V);for(const X of D){G&&X.normalize(N,M);for(const D of X.targetedAnimations)b.addTargetedAnimation(D.animation,D.target);l&&X.dispose()}return b}constructor(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=D,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new N.e,this.onAnimationLoopObservable=new N.e,this.onAnimationGroupLoopObservable=new N.e,this.onAnimationGroupEndObservable=new N.e,this.onAnimationGroupPauseObservable=new N.e,this.onAnimationGroupPlayObservable=new N.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=l||M.d.LastCreatedScene,this._weight=G,this._playOrder=V,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(D,l){const G=new H;G.animation=D,G.target=l;const V=D.getKeys();return this._from>V[0].frame&&(this._from=V[0].frame),this._to<V[V.length-1].frame&&(this._to=V[V.length-1].frame),null!==this._enableBlending&&(D.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(D.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(G),this._shouldStart=!0,G}removeTargetedAnimation(D){for(let l=this._targetedAnimations.length-1;l>-1;l--){this._targetedAnimations[l].animation===D&&this._targetedAnimations.splice(l,1)}}normalize(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==D&&(D=this._from),null==l&&(l=this._to);for(let G=0;G<this._targetedAnimations.length;G++){const V=this._targetedAnimations[G].animation.getKeys(),N=V[0],M=V[V.length-1];if(N.frame>D){const l={frame:D,value:N.value,inTangent:N.inTangent,outTangent:N.outTangent,interpolation:N.interpolation};V.splice(0,0,l)}if(M.frame<l){const D={frame:l,value:M.value,inTangent:M.inTangent,outTangent:M.outTangent,interpolation:M.interpolation};V.push(D)}}return this._from=D,this._to=l,this}_processLoop(D,l,G){D.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(l),this._animationLoopFlags[G]||(this._animationLoopFlags[G]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0],l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,G=arguments.length>2?arguments[2]:void 0,V=arguments.length>3?arguments[3]:void 0,N=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=D,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let M=0;M<this._targetedAnimations.length;M++){const b=this._targetedAnimations[M],X=this._scene.beginDirectAnimation(b.target,[b.animation],void 0!==G?G:this._from,void 0!==V?V:this._to,D,l,void 0,void 0,void 0!==N?N:this._isAdditive);X.weight=this._weight,X.playOrder=this._playOrder,X.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(b),this._checkAnimationGroupEnded(X)},this._processLoop(X,b,M),this._animatables.push(X)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=l,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let D=0;D<this._animatables.length;D++){this._animatables[D].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(D){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==D&&(this.loopAnimation=D),this.restart()):(this.stop(),this.start(D,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let D=0;D<this._animatables.length;D++){this._animatables[D].reset()}return this}restart(){if(!this._isStarted)return this;for(let D=0;D<this._animatables.length;D++){this._animatables[D].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const l=this._animatables.slice();for(let V=0;V<l.length;V++)l[V].stop(void 0,void 0,!0,D);let G=0;for(let V=0;V<this._scene._activeAnimatables.length;V++){const l=this._scene._activeAnimatables[V];l._runtimeAnimations.length>0?this._scene._activeAnimatables[G++]=l:D&&this._checkAnimationGroupEnded(l,D)}return this._scene._activeAnimatables.length=G,this._isStarted=!1,this}setWeightForAllAnimatables(D){for(let l=0;l<this._animatables.length;l++){this._animatables[l].weight=D}return this}syncAllAnimationsWith(D){for(let l=0;l<this._animatables.length;l++){this._animatables[l].syncWith(D)}return this}goToFrame(D){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let G=0;G<this._animatables.length;G++){this._animatables[G].goToFrame(D,l)}return this}getCurrentFrame(){var D;return(null===(D=this.animatables[0])||void 0===D?void 0:D.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const D=this._scene.animationGroups.indexOf(this);if(D>-1&&this._scene.animationGroups.splice(D,1),this._parentContainer){const D=this._parentContainer.animationGroups.indexOf(this);D>-1&&this._parentContainer.animationGroups.splice(D,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(D){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const G=this._animatables.indexOf(D);G>-1&&this._animatables.splice(G,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,l||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(D,l){let G=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const V=new h(D||this.name,this._scene,this._weight,this._playOrder);V._from=this.from,V._to=this.to,V._speedRatio=this.speedRatio,V._loopAnimation=this.loopAnimation,V._isAdditive=this.isAdditive,V._enableBlending=this.enableBlending,V._blendingSpeed=this.blendingSpeed,V.metadata=this.metadata,V.mask=this.mask;for(const N of this._targetedAnimations)V.addTargetedAnimation(G?N.animation.clone():N.animation,l?l(N.target):N.target);return V}serialize(){const D={};D.name=this.name,D.from=this.from,D.to=this.to,D.speedRatio=this.speedRatio,D.loopAnimation=this.loopAnimation,D.isAdditive=this.isAdditive,D.weight=this.weight,D.playOrder=this.playOrder,D.enableBlending=this.enableBlending,D.blendingSpeed=this.blendingSpeed,D.targetedAnimations=[];for(let l=0;l<this.targetedAnimations.length;l++){const G=this.targetedAnimations[l];D.targetedAnimations[l]=G.serialize()}return b.e&&b.e.HasTags(this)&&(D.tags=b.e.GetTags(this)),this.metadata&&(D.metadata=this.metadata),D}static Parse(D,l){const G=new h(D.name,l,D.weight,D.playOrder);for(let N=0;N<D.targetedAnimations.length;N++){const M=D.targetedAnimations[N],b=V.b.Parse(M.animation),X=M.targetId;if("influence"===M.animation.property){const D=l.getMorphTargetById(X);D&&G.addTargetedAnimation(b,D)}else{const D=l.getNodeById(X);null!=D&&G.addTargetedAnimation(b,D)}}return b.e&&b.e.AddTagsTo(G,D.tags),null!==D.from&&null!==D.to&&G.normalize(D.from,D.to),void 0!==D.speedRatio&&(G._speedRatio=D.speedRatio),void 0!==D.loopAnimation&&(G._loopAnimation=D.loopAnimation),void 0!==D.isAdditive&&(G._isAdditive=D.isAdditive),void 0!==D.weight&&(G._weight=D.weight),void 0!==D.playOrder&&(G._playOrder=D.playOrder),void 0!==D.enableBlending&&(G._enableBlending=D.enableBlending),void 0!==D.blendingSpeed&&(G._blendingSpeed=D.blendingSpeed),void 0!==D.metadata&&(G.metadata=D.metadata),G}static MakeAnimationAdditive(D,l,G){let N;N="object"===typeof l?l:{referenceFrame:l,range:G,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let M=D;N.cloneOriginalAnimationGroup&&(M=D.clone(N.clonedAnimationGroupName||M.name));const b=M.targetedAnimations;for(let X=0;X<b.length;X++){const D=b[X];D.animation=V.b.MakeAnimationAdditive(D.animation,N)}if(M.isAdditive=!0,N.clipKeys){let D=Number.MAX_VALUE,l=-Number.MAX_VALUE;const G=M.targetedAnimations;for(let V=0;V<G.length;V++){const N=G[V].animation.getKeys();D>N[0].frame&&(D=N[0].frame),l<N[N.length-1].frame&&(l=N[N.length-1].frame)}M._from=D,M._to=l}return M}static ClipKeys(D,l,G,V,N){const M=D.clone(V||D.name);return h.ClipKeysInPlace(M,l,G,N)}static ClipKeysInPlace(D,l,G,V){return h.ClipInPlace(D,l,G,V,!1)}static ClipFrames(D,l,G,V,N){const M=D.clone(V||D.name);return h.ClipFramesInPlace(M,l,G,N)}static ClipFramesInPlace(D,l,G,V){return h.ClipInPlace(D,l,G,V,!0)}static ClipInPlace(D,l,G,V){let N=arguments.length>4&&void 0!==arguments[4]&&arguments[4],M=Number.MAX_VALUE,b=-Number.MAX_VALUE;const X=D.targetedAnimations;for(let t=0;t<X.length;t++){const D=X[t],R=V?D.animation:D.animation.clone();N&&(R.createKeyForFrame(l),R.createKeyForFrame(G));const n=R.getKeys(),g=[];let j=Number.MAX_VALUE;for(let V=0;V<n.length;V++){const D=n[V];if(!N&&V>=l&&V<=G||N&&D.frame>=l&&D.frame<=G){const l={frame:D.frame,value:D.value.clone?D.value.clone():D.value,inTangent:D.inTangent,outTangent:D.outTangent,interpolation:D.interpolation,lockedTangent:D.lockedTangent};j===Number.MAX_VALUE&&(j=l.frame),l.frame-=j,g.push(l)}}0!==g.length?(M>g[0].frame&&(M=g[0].frame),b<g[g.length-1].frame&&(b=g[g.length-1].frame),R.setKeys(g,!0),D.animation=R):(X.splice(t,1),t--)}return D._from=M,D._to=b,D}getClassName(){return"AnimationGroup"}toString(D){let l="Name: "+this.name;return l+=", type: "+this.getClassName(),D&&(l+=", from: "+this._from,l+=", to: "+this._to,l+=", isStarted: "+this._isStarted,l+=", speedRatio: "+this._speedRatio,l+=", targetedAnimations length: "+this._targetedAnimations.length,l+=", animatables length: "+this._animatables),l}}}}]);