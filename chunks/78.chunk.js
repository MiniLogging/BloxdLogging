"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[78],{14226:(P,e,n)=>{n.r(e),n.d(e,{AnimationGroup:()=>J,TargetedAnimation:()=>w});var H=n(11641),S=n(10976),p=n(11017),k=n(11175),m=n(12737),t=n(11133);class C{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(P,e,n,S){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=e,this._target=P,this._scene=n,this._host=S,this._activeTargets=[],e._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===H.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=t.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const P={frame:0,value:this._minValue};this._keys.splice(0,0,P)}if(this._target instanceof Array){let P=0;for(const e of this._target)this._preparePath(e,P),this._getOriginalValues(P),P++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const p=e.getEvents();if(p&&p.length>0)for(const H of p)this._events.push(H._clone());this._enableBlending=P&&P.animationPropertiesOverride?P.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this._animation.targetPropertyPath;if(n.length>1){let H=P;for(let P=0;P<n.length-1;P++){const e=n[P];if(H=H[e],void 0===H)throw new Error(`Invalid property (${e}) in property path (${n.join(".")})`)}this._targetPath=n[n.length-1],this._activeTargets[e]=H}else this._targetPath=n[0],this._activeTargets[e]=P;if(void 0===this._activeTargets[e][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${n.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let P=0;for(const e of this._target)void 0!==this._originalValue[P]&&this._setValue(e,this._activeTargets[P],this._originalValue[P],-1,P),P++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let P=0;P<this._events.length;P++)this._events[P].isDone=!1}isStopped(){return this._stopped}dispose(){const P=this._animation.runtimeAnimations.indexOf(this);P>-1&&this._animation.runtimeAnimations.splice(P,1)}setValue(P,e){if(this._targetIsArray)for(let n=0;n<this._target.length;n++){const H=this._target[n];this._setValue(H,this._activeTargets[n],P,e,n)}else this._setValue(this._target,this._directTarget,P,e,0)}_getOriginalValues(){let P,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=this._activeTargets[e];P=n.getLocalMatrix&&"_matrix"===this._targetPath?n.getLocalMatrix():n[this._targetPath],P&&P.clone?this._originalValue[e]=P.clone():this._originalValue[e]=P}_registerTargetForLateAnimationBinding(P,e){const n=P.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(n),n._lateAnimationHolders||(n._lateAnimationHolders={}),n._lateAnimationHolders[P.targetPath]||(n._lateAnimationHolders[P.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:e}),P.isAdditive?(n._lateAnimationHolders[P.targetPath].additiveAnimations.push(P),n._lateAnimationHolders[P.targetPath].totalAdditiveWeight+=P.weight):(n._lateAnimationHolders[P.targetPath].animations.push(P),n._lateAnimationHolders[P.targetPath].totalWeight+=P.weight)}_setValue(P,e,n,S,p){if(this._currentActiveTarget=e,this._weight=S,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const P=e[this._targetPath];P.clone?this._originalBlendValue=P.clone():this._originalBlendValue=P}this._originalBlendValue.m?H.e.AllowMatrixDecomposeForInterpolation?this._currentValue?t.Matrix.DecomposeLerpToRef(this._originalBlendValue,n,this._blendingFactor,this._currentValue):this._currentValue=t.Matrix.DecomposeLerp(this._originalBlendValue,n,this._blendingFactor):this._currentValue?t.Matrix.LerpToRef(this._originalBlendValue,n,this._blendingFactor,this._currentValue):this._currentValue=t.Matrix.Lerp(this._originalBlendValue,n,this._blendingFactor):this._currentValue=H.e._UniversalLerp(this._originalBlendValue,n,this._blendingFactor);const S=P&&P.animationPropertiesOverride?P.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=S}else this._currentValue?this._currentValue.p?this._currentValue.p(n):this._currentValue=n:null!==n&&void 0!==n&&n.clone?this._currentValue=n.clone():this._currentValue=n;-1!==S?this._registerTargetForLateAnimationBinding(this,this._originalValue[p]):this._animationState.loopMode===H.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[p],e[this._targetPath]):e[this._targetPath]=this._originalValue[p]+this._currentValue:e[this._targetPath]=this._currentValue,P.vC&&P.vC(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=this._animation.getKeys();P<n[0].frame?P=n[0].frame:P>n[n.length-1].frame&&(P=n[n.length-1].frame);const H=this._events;if(H.length)for(let p=0;p<H.length;p++)H[p].onlyOnce||(H[p].isDone=H[p].frame<P);this._currentFrame=P;const S=this._animation._interpolate(P,this._animationState);this.setValue(S,e)}_prepareForSpeedRatioChange(P){const e=this._previousElapsedTime*(this._animation.framePerSecond*P)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-e}animate(P,e,n,S,p){let k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const m=this._animation,t=m.targetPropertyPath;if(!t||t.length<1)return this._stopped=!0,!1;let C,R=!0;const q=this._events;let A=0;if(this._coreRuntimeAnimation)A=n-e,C=this._coreRuntimeAnimation.currentFrame,this._currentFrame=C,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let k;(e<this._minFrame||e>this._maxFrame)&&(e=this._minFrame),(n<this._minFrame||n>this._maxFrame)&&(n=this._maxFrame),A=n-e;let t=P*(m.framePerSecond*p)/1e3+this._absoluteFrameOffset,F=0,Y=!1;const j=S&&this._animationState.loopMode===H.e.ANIMATIONLOOPMODE_YOYO;if(j){const P=(t-e)/A,n=Math.sin(P*Math.PI);t=Math.abs(n)*A+e;const H=n>=0?1:-1;this._yoyoDirection!==H&&(Y=!0),this._yoyoDirection=H}if(this._previousElapsedTime=P,this._previousAbsoluteFrame=t,!S&&n>=e&&(t>=A&&p>0||t<=0&&p<0))R=!1,F=m._getKeyValue(this._maxValue);else if(!S&&e>=n&&(t<=A&&p<0||t>=0&&p>0))R=!1,F=m._getKeyValue(this._minValue);else if(this._animationState.loopMode!==H.e.ANIMATIONLOOPMODE_CYCLE){const P=n.toString()+e.toString();if(!this._offsetsCache[P]){this._animationState.repeatCount=0,this._animationState.loopMode=H.e.ANIMATIONLOOPMODE_CYCLE;const S=m._interpolate(e,this._animationState),p=m._interpolate(n,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),m.dataType){case H.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[P]=p-S;break;case H.e.ANIMATIONTYPE_QUATERNION:case H.e.ANIMATIONTYPE_VECTOR3:case H.e.ANIMATIONTYPE_VECTOR2:case H.e.ANIMATIONTYPE_SIZE:case H.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[P]=p.be(S)}this._highLimitsCache[P]=p}F=this._highLimitsCache[P],k=this._offsetsCache[P]}if(void 0===k)switch(m.dataType){case H.e.ANIMATIONTYPE_FLOAT:k=0;break;case H.e.ANIMATIONTYPE_QUATERNION:k=H.l;break;case H.e.ANIMATIONTYPE_VECTOR3:k=H.s;break;case H.e.ANIMATIONTYPE_VECTOR2:k=H.q;break;case H.e.ANIMATIONTYPE_SIZE:k=H.o;break;case H.e.ANIMATIONTYPE_COLOR3:k=H.i;break;case H.e.ANIMATIONTYPE_COLOR4:k=H.k}if(this._host&&this._host.syncRoot){const P=this._host.syncRoot;C=e+A*((P.masterFrame-P.fromFrame)/(P.toFrame-P.fromFrame))}else C=t>0&&e>n||t<0&&e<n?R&&0!==A?n+t%A:e:R&&0!==A?e+t%A:n;if(!j&&(p>0&&this.currentFrame>C||p<0&&this.currentFrame<C)||j&&Y){this._onLoop();for(let P=0;P<q.length;P++)q[P].onlyOnce||(q[P].isDone=!1);this._animationState.key=p>0?0:m.getKeys().length-1}this._currentFrame=C,this._animationState.repeatCount=0===A?0:t/A|0,this._animationState.highLimitValue=F,this._animationState.offsetValue=k}const F=m._interpolate(C,this._animationState);if(this.setValue(F,k),q.length)for(let H=0;H<q.length;H++)if(A>=0&&C>=q[H].frame&&q[H].frame>=e||A<0&&C<=q[H].frame&&q[H].frame<=e){const P=q[H];P.isDone||(P.onlyOnce&&(q.splice(H,1),H--),P.isDone=!0,P.action(C))}return R||(this._stopped=!0),R}}var R=n(11002);class q{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(P){this._weight=-1!==P?Math.min(Math.max(P,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(P){for(let e=0;e<this._runtimeAnimations.length;e++){this._runtimeAnimations[e]._prepareForSpeedRatioChange(P)}this._speedRatio=P,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(P,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,p=arguments.length>4&&void 0!==arguments[4]&&arguments[4],k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,m=arguments.length>6?arguments[6]:void 0,t=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,R=arguments.length>9&&void 0!==arguments[9]&&arguments[9],q=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=e,this.fromFrame=n,this.toFrame=H,this.loopAnimation=p,this.onAnimationEnd=m,this.onAnimationLoop=C,this.isAdditive=R,this.playOrder=q,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Am=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new S.b,this.onAnimationLoopObservable=new S.b,this._scene=P,t&&this.appendAnimations(e,t),this._speedRatio=k,P._activeAnimatables.push(this)}syncWith(P){if(this._syncRoot=P,P){const P=this._scene._activeAnimatables.indexOf(this);P>-1&&(this._scene._activeAnimatables.splice(P,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(P,e){for(let n=0;n<e.length;n++){const H=e[n],S=new C(P,H,this._scene,this);S._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(S)}}getAnimationByTargetProperty(P){const e=this._runtimeAnimations;for(let n=0;n<e.length;n++)if(e[n].animation.targetProperty===P)return e[n].animation;return null}getRuntimeAnimationByTargetProperty(P){const e=this._runtimeAnimations;for(let n=0;n<e.length;n++)if(e[n].animation.targetProperty===P)return e[n];return null}reset(){const P=this._runtimeAnimations;for(let e=0;e<P.length;e++)P[e].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(P){const e=this._runtimeAnimations;for(let n=0;n<e.length;n++)e[n].animation.enableBlending=!0,e[n].animation.blendingSpeed=P}disableBlending(){const P=this._runtimeAnimations;for(let e=0;e<P.length;e++)P[e].animation.enableBlending=!1}goToFrame(P){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=this._runtimeAnimations;if(n[0]){const e=n[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??n[0].currentFrame;const H=0===this.speedRatio?0:(P-this._frameToSyncFromJump)/e*1e3/this.speedRatio;this._manualJumpDelay=-H}for(let H=0;H<n.length;H++)n[H].goToFrame(P,e?this._weight:-1);this._goToFrame=P}get paused(){return this.Am}pause(){this.Am||(this.Am=!0)}restart(){this.Am=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(P,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(P||e){const S=this._scene._activeAnimatables.indexOf(this);if(S>-1){const p=this._runtimeAnimations;for(let n=p.length-1;n>=0;n--){const H=p[n];P&&H.animation.name!=P||(e&&!e(H.target)||(H.dispose(),p.splice(n,1)))}0==p.length&&(n||this._scene._activeAnimatables.splice(S,1),H||this._raiseOnAnimationEnd())}}else{const P=this._scene._activeAnimatables.indexOf(this);if(P>-1){n||this._scene._activeAnimatables.splice(P,1);const e=this._runtimeAnimations;for(let P=0;P<e.length;P++)e[P].dispose();this._runtimeAnimations.length=0,H||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((P=>{this.onAnimationEndObservable.add((()=>{P(this)}),void 0,void 0,this,!0)}))}_animate(P){if(this.Am)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=P),!0;if(null===this._localDelayOffset?(this._localDelayOffset=P,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=P-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let e=!1;const n=this._runtimeAnimations;let H;for(H=0;H<n.length;H++){const S=n[H].animate(P-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);e=e||S}if(this.animationStarted=e,!e){if(this.disposeOnEnd)for(H=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(H,1),H=0;H<n.length;H++)n[H].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return e}}function A(P){if(0===P.totalWeight&&0===P.totalAdditiveWeight)return P.originalValue;let e=1;const n=t.TmpVectors.Ie[0],H=t.TmpVectors.Ie[1],S=t.TmpVectors.Quaternion[0];let p=0;const k=P.animations[0],m=P.originalValue;let C=1,R=!1;if(P.totalWeight<1)C=1-P.totalWeight,m.decompose(H,S,n);else{if(p=1,e=P.totalWeight,C=k.weight/e,1==C){if(!P.totalAdditiveWeight)return k.currentValue;R=!0}k.currentValue.decompose(H,S,n)}if(!R){H.scaleInPlace(C),n.scaleInPlace(C),S.scaleInPlace(C);for(let k=p;k<P.animations.length;k++){const p=P.animations[k];if(0===p.weight)continue;C=p.weight/e;const m=t.TmpVectors.Ie[2],R=t.TmpVectors.Ie[3],q=t.TmpVectors.Quaternion[1];p.currentValue.decompose(R,q,m),R.scaleAndAddToRef(C,H),q.scaleAndAddToRef(t.Quaternion.Dot(S,q)>0?C:-C,S),m.scaleAndAddToRef(C,n)}S.normalize()}for(let A=0;A<P.additiveAnimations.length;A++){const e=P.additiveAnimations[A];if(0===e.weight)continue;const p=t.TmpVectors.Ie[2],k=t.TmpVectors.Ie[3],m=t.TmpVectors.Quaternion[1];e.currentValue.decompose(k,m,p),k.multiplyToRef(H,k),t.Ie.LerpToRef(H,k,e.weight,H),S.multiplyToRef(m,m),t.Quaternion.SlerpToRef(S,m,e.weight,S),p.scaleAndAddToRef(e.weight,n)}const q=k?k._animationState.workValue:t.TmpVectors.Matrix[0].clone();return t.Matrix.ComposeToRef(H,S,n,q),q}function F(P,e){if(0===P.totalWeight&&0===P.totalAdditiveWeight)return e;const n=P.animations[0],H=P.originalValue;let S=e;if(0===P.totalWeight&&P.totalAdditiveWeight>0)S.p(H);else if(1===P.animations.length){if(t.Quaternion.SlerpToRef(H,n.currentValue,Math.min(1,P.totalWeight),S),0===P.totalAdditiveWeight)return S}else if(P.animations.length>1){let n,p,k=1;if(P.totalWeight<1){const e=1-P.totalWeight;n=[],p=[],n.push(H),p.push(e)}else{if(2===P.animations.length&&(t.Quaternion.SlerpToRef(P.animations[0].currentValue,P.animations[1].currentValue,P.animations[1].weight/P.totalWeight,e),0===P.totalAdditiveWeight))return e;n=[],p=[],k=P.totalWeight}for(let e=0;e<P.animations.length;e++){const H=P.animations[e];n.push(H.currentValue),p.push(H.weight/k)}let m=0;for(let P=0;P<n.length;)P?(m+=p[P],t.Quaternion.SlerpToRef(S,n[P],p[P]/m,S),P++):(t.Quaternion.SlerpToRef(n[P],n[P+1],p[P+1]/(p[P]+p[P+1]),e),S=e,m=p[P]+p[P+1],P+=2)}for(let p=0;p<P.additiveAnimations.length;p++){const e=P.additiveAnimations[p];0!==e.weight&&(S.multiplyToRef(e.currentValue,t.TmpVectors.Quaternion[0]),t.Quaternion.SlerpToRef(S,t.TmpVectors.Quaternion[0],e.weight,S))}return S}var Y,j,z=n(11379);Y=z.d,(j=m.d)&&(j.prototype.copyAnimationRange=function(P,e,n){let S=arguments.length>3&&void 0!==arguments[3]&&arguments[3],p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new H.e(this.name,"_matrix",P.animations[0].framePerSecond,H.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const k=P.animations[0].getRange(e);if(!k)return!1;const m=k.from,t=k.to,C=P.animations[0].getKeys(),R=P.length,q=P.getParent(),A=this.getParent(),F=S&&q&&R&&this.length&&R!==this.length,Y=F&&A&&q?A.length/q.length:1,j=S&&!A&&p&&(1!==p.x||1!==p.y||1!==p.z),z=this.animations[0].getKeys();let w,J,I;for(let H=0,O=C.length;H<O;H++)w=C[H],w.frame>=m&&w.frame<=t&&(S?(I=w.value.clone(),F?(J=I.getTranslation(),I.setTranslation(J.scaleInPlace(Y))):j&&p?(J=I.getTranslation(),I.setTranslation(J.multiplyInPlace(p))):I=w.value):I=w.value,z.push({frame:w.frame+n,value:I}));return this.animations[0].createRange(e,m+n,t+n),!0}),Y&&(Y.prototype._animate=function(P){if(!this.animationsEnabled)return;const e=R.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=e}this.deltaTime=void 0!==P?P:this.useConstantAnimationDeltaTime?16:(e-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=e;const n=this._activeAnimatables;if(0===n.length)return;this._animationTime+=this.deltaTime;const S=this._animationTime;for(let H=0;H<n.length;H++){const P=n[H];!P._animate(S)&&P.disposeOnEnd&&H--}!function(P){if(P._registeredForLateAnimationBindings.length){for(let e=0;e<P._registeredForLateAnimationBindings.length;e++){const n=P._registeredForLateAnimationBindings.data[e];for(const P in n._lateAnimationHolders){const e=n._lateAnimationHolders[P],S=e.animations[0],p=e.originalValue;if(void 0===p||null===p)continue;const k=H.e.AllowMatrixDecomposeForInterpolation&&p.m;let m=n[P];if(k)m=A(e);else if(void 0!==p.w)m=F(e,m||t.Quaternion.Identity());else{let P=0,n=1;const k=S&&S._animationState.loopMode===H.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(e.totalWeight<1)m=k?p.clone?p.clone():p:S&&p.scale?p.scale(1-e.totalWeight):S?p*(1-e.totalWeight):p.clone?p.clone():p;else if(S){n=e.totalWeight;const H=S.weight/n;m=1!==H?S.currentValue.scale?S.currentValue.scale(H):S.currentValue*H:S.currentValue,k&&(m.addToRef?m.addToRef(p,m):m+=p),P=1}for(let H=P;H<e.animations.length;H++){const P=e.animations[H],S=P.weight/n;S&&(P.currentValue.scaleAndAddToRef?P.currentValue.scaleAndAddToRef(S,m):m+=P.currentValue*S)}for(let H=0;H<e.additiveAnimations.length;H++){const P=e.additiveAnimations[H],n=P.weight;n&&(P.currentValue.scaleAndAddToRef?P.currentValue.scaleAndAddToRef(n,m):m+=P.currentValue*n)}}n[P]=m}n._lateAnimationHolders={}}P._registeredForLateAnimationBindings.reset()}}(this)},Y.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((P,e)=>P.playOrder-e.playOrder))},Y.prototype.beginWeightedAnimation=function(P,e,n){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,S=arguments.length>4?arguments[4]:void 0,p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,m=arguments.length>7?arguments[7]:void 0,t=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,R=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const q=this.beginAnimation(P,e,n,S,p,k,m,!1,t,C,R);return q.weight=H,q},Y.prototype.beginAnimation=function(P,e,n,H){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,p=arguments.length>5?arguments[5]:void 0,k=arguments.length>6?arguments[6]:void 0,m=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],t=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,R=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(S<0){const P=e;e=n,n=P,S=-S}e>n&&(S=-S),m&&this.stopAnimation(P,void 0,t),k||(k=new q(this,P,e,n,H,S,p,void 0,C,R));const A=!t||t(P);if(P.animations&&A&&k.appendAnimations(P,P.animations),P.getAnimatables){const R=P.getAnimatables();for(let P=0;P<R.length;P++)this.beginAnimation(R[P],e,n,H,S,p,k,m,t,C)}return k.reset(),k},Y.prototype.beginHierarchyAnimation=function(P,e,n,H,S){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,m=arguments.length>7?arguments[7]:void 0,t=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],C=arguments.length>9?arguments[9]:void 0,R=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const q=P.getDescendants(e),A=[];A.push(this.beginAnimation(P,n,H,S,p,k,m,t,C,void 0,R));for(const F of q)A.push(this.beginAnimation(F,n,H,S,p,k,m,t,C,void 0,R));return A},Y.prototype.beginDirectAnimation=function(P,e,n,H,S){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(p<0){const P=n;n=H,H=P,p=-p}return n>H&&(p=-p),new q(this,P,n,H,S,p,arguments.length>6?arguments[6]:void 0,e,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},Y.prototype.beginDirectHierarchyAnimation=function(P,e,n,H,S,p,k,m,t){let C=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const R=P.getDescendants(e),q=[];q.push(this.beginDirectAnimation(P,n,H,S,p,k,m,t,C));for(const A of R)q.push(this.beginDirectAnimation(A,n,H,S,p,k,m,t,C));return q},Y.prototype.getAnimatableByTarget=function(P){for(let e=0;e<this._activeAnimatables.length;e++)if(this._activeAnimatables[e].target===P)return this._activeAnimatables[e];return null},Y.prototype.getAllAnimatablesByTarget=function(P){const e=[];for(let n=0;n<this._activeAnimatables.length;n++)this._activeAnimatables[n].target===P&&e.push(this._activeAnimatables[n]);return e},Y.prototype.stopAnimation=function(P,e,n){const H=this.getAllAnimatablesByTarget(P);for(const S of H)S.stop(e,n)},Y.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let P=0;P<this._activeAnimatables.length;P++)this._activeAnimatables[P].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const P of this.animationGroups)P.stop()});class w{getClassName(){return"TargetedAnimation"}serialize(){const P={};return P.animation=this.animation.serialize(),P.targetId=this.target.id,P}}class J{get mask(){return this._mask}set mask(P){this._mask!==P&&(this._mask=P,this.syncWithMask(!0))}syncWithMask(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||P){this._numActiveAnimatables=0;for(let P=0;P<this._animatables.length;++P){const e=this._animatables[P];!this.mask||this.mask.disabled||this.mask.retainsTarget(e.target.name)?(this._numActiveAnimatables++,e.paused&&e.restart()):e.paused||e.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let P=0;P<this._animatables.length;++P){const e=this._animatables[P];this.mask.retainsTarget(e.target.name)||(e.stop(),this._animatables.splice(P,1),--P)}for(let P=0;P<this._targetedAnimations.length;P++){const e=this._targetedAnimations[P];this.mask.retainsTarget(e.target.name)||(this._targetedAnimations.splice(P,1),--P)}}}get from(){return this._from}set from(P){if(this._from!==P){this._from=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].fromFrame=this._from}}}get to(){return this._to}set to(P){if(this._to!==P){this._to=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(P){if(this._speedRatio!==P){this._speedRatio=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(P){if(this._loopAnimation!==P){this._loopAnimation=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(P){if(this._isAdditive!==P){this._isAdditive=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(P){this._weight!==P&&(this._weight=P,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(P){if(this._playOrder!==P&&(this._playOrder=P,this._animatables.length>0)){for(let P=0;P<this._animatables.length;P++)this._animatables[P].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(P){if(this._enableBlending!==P&&(this._enableBlending=P,null!==P))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.enableBlending=P}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(P){if(this._blendingSpeed!==P&&(this._blendingSpeed=P,null!==P))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.blendingSpeed=P}getLength(P,e){P=P??this._from;return((e=e??this._to)-P)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(P){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=arguments.length>3?arguments[3]:void 0;if(0===P.length)return null;H=H??P[0].weight;let S=Number.MAX_VALUE,p=-Number.MAX_VALUE;if(n)for(const m of P)m.from<S&&(S=m.from),m.to>p&&(p=m.to);const k=new J(P[0].name+"_merged",P[0]._scene,H);for(const m of P){n&&m.normalize(S,p);for(const P of m.targetedAnimations)k.addTargetedAnimation(P.animation,P.target);e&&m.dispose()}return k}constructor(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=P,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new S.b,this.onAnimationLoopObservable=new S.b,this.onAnimationGroupLoopObservable=new S.b,this.onAnimationGroupEndObservable=new S.b,this.onAnimationGroupPauseObservable=new S.b,this.onAnimationGroupPlayObservable=new S.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=e||p.d.LastCreatedScene,this._weight=n,this._playOrder=H,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(P,e){const n=new w;n.animation=P,n.target=e;const H=P.getKeys();return this._from>H[0].frame&&(this._from=H[0].frame),this._to<H[H.length-1].frame&&(this._to=H[H.length-1].frame),null!==this._enableBlending&&(P.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(P.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(n),this._shouldStart=!0,n}removeTargetedAnimation(P){for(let e=this._targetedAnimations.length-1;e>-1;e--){this._targetedAnimations[e].animation===P&&this._targetedAnimations.splice(e,1)}}normalize(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==P&&(P=this._from),null==e&&(e=this._to);for(let n=0;n<this._targetedAnimations.length;n++){const H=this._targetedAnimations[n].animation.getKeys(),S=H[0],p=H[H.length-1];if(S.frame>P){const e={frame:P,value:S.value,inTangent:S.inTangent,outTangent:S.outTangent,interpolation:S.interpolation};H.splice(0,0,e)}if(p.frame<e){const P={frame:e,value:p.value,inTangent:p.inTangent,outTangent:p.outTangent,interpolation:p.interpolation};H.push(P)}}return this._from=P,this._to=e,this}_processLoop(P,e,n){P.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(e),this._animationLoopFlags[n]||(this._animationLoopFlags[n]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,H=arguments.length>3?arguments[3]:void 0,S=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=P,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let p=0;p<this._targetedAnimations.length;p++){const k=this._targetedAnimations[p],m=this._scene.beginDirectAnimation(k.target,[k.animation],void 0!==n?n:this._from,void 0!==H?H:this._to,P,e,void 0,void 0,void 0!==S?S:this._isAdditive);m.weight=this._weight,m.playOrder=this._playOrder,m.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(k),this._checkAnimationGroupEnded(m)},this._processLoop(m,k,p),this._animatables.push(m)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=e,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let P=0;P<this._animatables.length;P++){this._animatables[P].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(P){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==P&&(this.loopAnimation=P),this.restart()):(this.stop(),this.start(P,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let P=0;P<this._animatables.length;P++){this._animatables[P].reset()}return this}restart(){if(!this._isStarted)return this;for(let P=0;P<this._animatables.length;P++){this._animatables[P].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const e=this._animatables.slice();for(let H=0;H<e.length;H++)e[H].stop(void 0,void 0,!0,P);let n=0;for(let H=0;H<this._scene._activeAnimatables.length;H++){const e=this._scene._activeAnimatables[H];e._runtimeAnimations.length>0?this._scene._activeAnimatables[n++]=e:P&&this._checkAnimationGroupEnded(e,P)}return this._scene._activeAnimatables.length=n,this._isStarted=!1,this}setWeightForAllAnimatables(P){for(let e=0;e<this._animatables.length;e++){this._animatables[e].weight=P}return this}syncAllAnimationsWith(P){for(let e=0;e<this._animatables.length;e++){this._animatables[e].syncWith(P)}return this}goToFrame(P){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let n=0;n<this._animatables.length;n++){this._animatables[n].goToFrame(P,e)}return this}getCurrentFrame(){var P;return(null===(P=this.animatables[0])||void 0===P?void 0:P.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const P=this._scene.animationGroups.indexOf(this);if(P>-1&&this._scene.animationGroups.splice(P,1),this._parentContainer){const P=this._parentContainer.animationGroups.indexOf(this);P>-1&&this._parentContainer.animationGroups.splice(P,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(P){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=this._animatables.indexOf(P);n>-1&&this._animatables.splice(n,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,e||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(P,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const H=new J(P||this.name,this._scene,this._weight,this._playOrder);H._from=this.from,H._to=this.to,H._speedRatio=this.speedRatio,H._loopAnimation=this.loopAnimation,H._isAdditive=this.isAdditive,H._enableBlending=this.enableBlending,H._blendingSpeed=this.blendingSpeed,H.metadata=this.metadata,H.mask=this.mask;for(const S of this._targetedAnimations)H.addTargetedAnimation(n?S.animation.clone():S.animation,e?e(S.target):S.target);return H}serialize(){const P={};P.name=this.name,P.from=this.from,P.to=this.to,P.speedRatio=this.speedRatio,P.loopAnimation=this.loopAnimation,P.isAdditive=this.isAdditive,P.weight=this.weight,P.playOrder=this.playOrder,P.enableBlending=this.enableBlending,P.blendingSpeed=this.blendingSpeed,P.targetedAnimations=[];for(let e=0;e<this.targetedAnimations.length;e++){const n=this.targetedAnimations[e];P.targetedAnimations[e]=n.serialize()}return k.c&&k.c.HasTags(this)&&(P.tags=k.c.GetTags(this)),this.metadata&&(P.metadata=this.metadata),P}static Parse(P,e){const n=new J(P.name,e,P.weight,P.playOrder);for(let S=0;S<P.targetedAnimations.length;S++){const p=P.targetedAnimations[S],k=H.e.Parse(p.animation),m=p.targetId;if("influence"===p.animation.property){const P=e.getMorphTargetById(m);P&&n.addTargetedAnimation(k,P)}else{const P=e.getNodeById(m);null!=P&&n.addTargetedAnimation(k,P)}}return k.c&&k.c.AddTagsTo(n,P.tags),null!==P.from&&null!==P.to&&n.normalize(P.from,P.to),void 0!==P.speedRatio&&(n._speedRatio=P.speedRatio),void 0!==P.loopAnimation&&(n._loopAnimation=P.loopAnimation),void 0!==P.isAdditive&&(n._isAdditive=P.isAdditive),void 0!==P.weight&&(n._weight=P.weight),void 0!==P.playOrder&&(n._playOrder=P.playOrder),void 0!==P.enableBlending&&(n._enableBlending=P.enableBlending),void 0!==P.blendingSpeed&&(n._blendingSpeed=P.blendingSpeed),void 0!==P.metadata&&(n.metadata=P.metadata),n}static MakeAnimationAdditive(P,e,n){let S;S="object"===typeof e?e:{referenceFrame:e,range:n,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let p=P;S.cloneOriginalAnimationGroup&&(p=P.clone(S.clonedAnimationGroupName||p.name));const k=p.targetedAnimations;for(let m=0;m<k.length;m++){const P=k[m];P.animation=H.e.MakeAnimationAdditive(P.animation,S)}if(p.isAdditive=!0,S.clipKeys){let P=Number.MAX_VALUE,e=-Number.MAX_VALUE;const n=p.targetedAnimations;for(let H=0;H<n.length;H++){const S=n[H].animation.getKeys();P>S[0].frame&&(P=S[0].frame),e<S[S.length-1].frame&&(e=S[S.length-1].frame)}p._from=P,p._to=e}return p}static ClipKeys(P,e,n,H,S){const p=P.clone(H||P.name);return J.ClipKeysInPlace(p,e,n,S)}static ClipKeysInPlace(P,e,n,H){return J.ClipInPlace(P,e,n,H,!1)}static ClipFrames(P,e,n,H,S){const p=P.clone(H||P.name);return J.ClipFramesInPlace(p,e,n,S)}static ClipFramesInPlace(P,e,n,H){return J.ClipInPlace(P,e,n,H,!0)}static ClipInPlace(P,e,n,H){let S=arguments.length>4&&void 0!==arguments[4]&&arguments[4],p=Number.MAX_VALUE,k=-Number.MAX_VALUE;const m=P.targetedAnimations;for(let t=0;t<m.length;t++){const P=m[t],C=H?P.animation:P.animation.clone();S&&(C.createKeyForFrame(e),C.createKeyForFrame(n));const R=C.getKeys(),q=[];let A=Number.MAX_VALUE;for(let H=0;H<R.length;H++){const P=R[H];if(!S&&H>=e&&H<=n||S&&P.frame>=e&&P.frame<=n){const e={frame:P.frame,value:P.value.clone?P.value.clone():P.value,inTangent:P.inTangent,outTangent:P.outTangent,interpolation:P.interpolation,lockedTangent:P.lockedTangent};A===Number.MAX_VALUE&&(A=e.frame),e.frame-=A,q.push(e)}}0!==q.length?(p>q[0].frame&&(p=q[0].frame),k<q[q.length-1].frame&&(k=q[q.length-1].frame),C.setKeys(q,!0),P.animation=C):(m.splice(t,1),t--)}return P._from=p,P._to=k,P}getClassName(){return"AnimationGroup"}toString(P){let e="Name: "+this.name;return e+=", type: "+this.getClassName(),P&&(e+=", from: "+this._from,e+=", to: "+this._to,e+=", isStarted: "+this._isStarted,e+=", speedRatio: "+this._speedRatio,e+=", targetedAnimations length: "+this._targetedAnimations.length,e+=", animatables length: "+this._animatables),e}}}}]);