"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[78],{15629:(u,R,I)=>{I.r(R),I.d(R,{AnimationGroup:()=>f,TargetedAnimation:()=>z});var B=I(12982),U=I(12303),K=I(12346),C=I(12514),D=I(14080),s=I(12481);class t{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(u,R,I,U){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=R,this._target=u,this._scene=I,this._host=U,this._activeTargets=[],R._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===B.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=s.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const u={frame:0,value:this._minValue};this._keys.splice(0,0,u)}if(this._target instanceof Array){let u=0;for(const R of this._target)this._preparePath(R,u),this._getOriginalValues(u),u++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const K=R.getEvents();if(K&&K.length>0)for(const B of K)this._events.push(B._clone());this._enableBlending=u&&u.animationPropertiesOverride?u.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const I=this._animation.targetPropertyPath;if(I.length>1){let B=u;for(let u=0;u<I.length-1;u++){const R=I[u];if(B=B[R],void 0===B)throw new Error(`Invalid property (${R}) in property path (${I.join(".")})`)}this._targetPath=I[I.length-1],this._activeTargets[R]=B}else this._targetPath=I[0],this._activeTargets[R]=u;if(void 0===this._activeTargets[R][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${I.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let u=0;for(const R of this._target)void 0!==this._originalValue[u]&&this._setValue(R,this._activeTargets[u],this._originalValue[u],-1,u),u++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let u=0;u<this._events.length;u++)this._events[u].isDone=!1}isStopped(){return this._stopped}dispose(){const u=this._animation.runtimeAnimations.indexOf(this);u>-1&&this._animation.runtimeAnimations.splice(u,1)}setValue(u,R){if(this._targetIsArray)for(let I=0;I<this._target.length;I++){const B=this._target[I];this._setValue(B,this._activeTargets[I],u,R,I)}else this._setValue(this._target,this._directTarget,u,R,0)}_getOriginalValues(){let u,R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const I=this._activeTargets[R];u=I.getLocalMatrix&&"_matrix"===this._targetPath?I.getLocalMatrix():I[this._targetPath],u&&u.clone?this._originalValue[R]=u.clone():this._originalValue[R]=u}_registerTargetForLateAnimationBinding(u,R){const I=u.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(I),I._lateAnimationHolders||(I._lateAnimationHolders={}),I._lateAnimationHolders[u.targetPath]||(I._lateAnimationHolders[u.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:R}),u.isAdditive?(I._lateAnimationHolders[u.targetPath].additiveAnimations.push(u),I._lateAnimationHolders[u.targetPath].totalAdditiveWeight+=u.weight):(I._lateAnimationHolders[u.targetPath].animations.push(u),I._lateAnimationHolders[u.targetPath].totalWeight+=u.weight)}_setValue(u,R,I,U,K){if(this._currentActiveTarget=R,this._weight=U,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const u=R[this._targetPath];u.clone?this._originalBlendValue=u.clone():this._originalBlendValue=u}this._originalBlendValue.m?B.d.AllowMatrixDecomposeForInterpolation?this._currentValue?s.Matrix.DecomposeLerpToRef(this._originalBlendValue,I,this._blendingFactor,this._currentValue):this._currentValue=s.Matrix.DecomposeLerp(this._originalBlendValue,I,this._blendingFactor):this._currentValue?s.Matrix.LerpToRef(this._originalBlendValue,I,this._blendingFactor,this._currentValue):this._currentValue=s.Matrix.Lerp(this._originalBlendValue,I,this._blendingFactor):this._currentValue=B.d._UniversalLerp(this._originalBlendValue,I,this._blendingFactor);const U=u&&u.animationPropertiesOverride?u.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=U}else this._currentValue?this._currentValue.B?this._currentValue.B(I):this._currentValue=I:null!==I&&void 0!==I&&I.clone?this._currentValue=I.clone():this._currentValue=I;-1!==U?this._registerTargetForLateAnimationBinding(this,this._originalValue[K]):this._animationState.loopMode===B.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[K],R[this._targetPath]):R[this._targetPath]=this._originalValue[K]+this._currentValue:R[this._targetPath]=this._currentValue,u.Ot&&u.Ot(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const I=this._animation.getKeys();u<I[0].frame?u=I[0].frame:u>I[I.length-1].frame&&(u=I[I.length-1].frame);const B=this._events;if(B.length)for(let K=0;K<B.length;K++)B[K].onlyOnce||(B[K].isDone=B[K].frame<u);this._currentFrame=u;const U=this._animation._interpolate(u,this._animationState);this.setValue(U,R)}_prepareForSpeedRatioChange(u){const R=this._previousElapsedTime*(this._animation.framePerSecond*u)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-R}animate(u,R,I,U,K){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const D=this._animation,s=D.targetPropertyPath;if(!s||s.length<1)return this._stopped=!0,!1;let t,G=!0;const S=this._events;let b=0;if(this._coreRuntimeAnimation)b=I-R,t=this._coreRuntimeAnimation.currentFrame,this._currentFrame=t,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let C;(R<this._minFrame||R>this._maxFrame)&&(R=this._minFrame),(I<this._minFrame||I>this._maxFrame)&&(I=this._maxFrame),b=I-R;let s=u*(D.framePerSecond*K)/1e3+this._absoluteFrameOffset,r=0,P=!1;const X=U&&this._animationState.loopMode===B.d.ANIMATIONLOOPMODE_YOYO;if(X){const u=(s-R)/b,I=Math.sin(u*Math.PI);s=Math.abs(I)*b+R;const B=I>=0?1:-1;this._yoyoDirection!==B&&(P=!0),this._yoyoDirection=B}if(this._previousElapsedTime=u,this._previousAbsoluteFrame=s,!U&&I>=R&&(s>=b&&K>0||s<=0&&K<0))G=!1,r=D._getKeyValue(this._maxValue);else if(!U&&R>=I&&(s<=b&&K<0||s>=0&&K>0))G=!1,r=D._getKeyValue(this._minValue);else if(this._animationState.loopMode!==B.d.ANIMATIONLOOPMODE_CYCLE){const u=I.toString()+R.toString();if(!this._offsetsCache[u]){this._animationState.repeatCount=0,this._animationState.loopMode=B.d.ANIMATIONLOOPMODE_CYCLE;const U=D._interpolate(R,this._animationState),K=D._interpolate(I,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),D.dataType){case B.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[u]=K-U;break;case B.d.ANIMATIONTYPE_QUATERNION:case B.d.ANIMATIONTYPE_VECTOR3:case B.d.ANIMATIONTYPE_VECTOR2:case B.d.ANIMATIONTYPE_SIZE:case B.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[u]=K.XR(U)}this._highLimitsCache[u]=K}r=this._highLimitsCache[u],C=this._offsetsCache[u]}if(void 0===C)switch(D.dataType){case B.d.ANIMATIONTYPE_FLOAT:C=0;break;case B.d.ANIMATIONTYPE_QUATERNION:C=B.m;break;case B.d.ANIMATIONTYPE_VECTOR3:C=B.u;break;case B.d.ANIMATIONTYPE_VECTOR2:C=B.t;break;case B.d.ANIMATIONTYPE_SIZE:C=B.q;break;case B.d.ANIMATIONTYPE_COLOR3:C=B.h;break;case B.d.ANIMATIONTYPE_COLOR4:C=B.j}if(this._host&&this._host.syncRoot){const u=this._host.syncRoot;t=R+b*((u.masterFrame-u.fromFrame)/(u.toFrame-u.fromFrame))}else t=s>0&&R>I||s<0&&R<I?G&&0!==b?I+s%b:R:G&&0!==b?R+s%b:I;if(!X&&(K>0&&this.currentFrame>t||K<0&&this.currentFrame<t)||X&&P){this._onLoop();for(let u=0;u<S.length;u++)S[u].onlyOnce||(S[u].isDone=!1);this._animationState.key=K>0?0:D.getKeys().length-1}this._currentFrame=t,this._animationState.repeatCount=0===b?0:s/b|0,this._animationState.highLimitValue=r,this._animationState.offsetValue=C}const r=D._interpolate(t,this._animationState);if(this.setValue(r,C),S.length)for(let B=0;B<S.length;B++)if(b>=0&&t>=S[B].frame&&S[B].frame>=R||b<0&&t<=S[B].frame&&S[B].frame<=R){const u=S[B];u.isDone||(u.onlyOnce&&(S.splice(B,1),B--),u.isDone=!0,u.action(t))}return G||(this._stopped=!0),G}}var G=I(12329);class S{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(u){this._weight=-1!==u?Math.min(Math.max(u,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(u){for(let R=0;R<this._runtimeAnimations.length;R++){this._runtimeAnimations[R]._prepareForSpeedRatioChange(u)}this._speedRatio=u,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(u,R){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,K=arguments.length>4&&void 0!==arguments[4]&&arguments[4],C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,D=arguments.length>6?arguments[6]:void 0,s=arguments.length>7?arguments[7]:void 0,t=arguments.length>8?arguments[8]:void 0,G=arguments.length>9&&void 0!==arguments[9]&&arguments[9],S=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=R,this.fromFrame=I,this.toFrame=B,this.loopAnimation=K,this.onAnimationEnd=D,this.onAnimationLoop=t,this.isAdditive=G,this.playOrder=S,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.OC=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new U.c,this.onAnimationLoopObservable=new U.c,this._scene=u,s&&this.appendAnimations(R,s),this._speedRatio=C,u._activeAnimatables.push(this)}syncWith(u){if(this._syncRoot=u,u){const u=this._scene._activeAnimatables.indexOf(this);u>-1&&(this._scene._activeAnimatables.splice(u,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(u,R){for(let I=0;I<R.length;I++){const B=R[I],U=new t(u,B,this._scene,this);U._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(U)}}getAnimationByTargetProperty(u){const R=this._runtimeAnimations;for(let I=0;I<R.length;I++)if(R[I].animation.targetProperty===u)return R[I].animation;return null}getRuntimeAnimationByTargetProperty(u){const R=this._runtimeAnimations;for(let I=0;I<R.length;I++)if(R[I].animation.targetProperty===u)return R[I];return null}reset(){const u=this._runtimeAnimations;for(let R=0;R<u.length;R++)u[R].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(u){const R=this._runtimeAnimations;for(let I=0;I<R.length;I++)R[I].animation.enableBlending=!0,R[I].animation.blendingSpeed=u}disableBlending(){const u=this._runtimeAnimations;for(let R=0;R<u.length;R++)u[R].animation.enableBlending=!1}goToFrame(u){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const I=this._runtimeAnimations;if(I[0]){const R=I[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??I[0].currentFrame;const B=0===this.speedRatio?0:(u-this._frameToSyncFromJump)/R*1e3/this.speedRatio;this._manualJumpDelay=-B}for(let B=0;B<I.length;B++)I[B].goToFrame(u,R?this._weight:-1);this._goToFrame=u}get paused(){return this.OC}pause(){this.OC||(this.OC=!0)}restart(){this.OC=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(u,R){let I=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(u||R){const U=this._scene._activeAnimatables.indexOf(this);if(U>-1){const K=this._runtimeAnimations;for(let I=K.length-1;I>=0;I--){const B=K[I];u&&B.animation.name!=u||(R&&!R(B.target)||(B.dispose(),K.splice(I,1)))}0==K.length&&(I||this._scene._activeAnimatables.splice(U,1),B||this._raiseOnAnimationEnd())}}else{const u=this._scene._activeAnimatables.indexOf(this);if(u>-1){I||this._scene._activeAnimatables.splice(u,1);const R=this._runtimeAnimations;for(let u=0;u<R.length;u++)R[u].dispose();this._runtimeAnimations.length=0,B||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((u=>{this.onAnimationEndObservable.add((()=>{u(this)}),void 0,void 0,this,!0)}))}_animate(u){if(this.OC)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=u),!0;if(null===this._localDelayOffset?(this._localDelayOffset=u,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=u-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let R=!1;const I=this._runtimeAnimations;let B;for(B=0;B<I.length;B++){const U=I[B].animate(u-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);R=R||U}if(this.animationStarted=R,!R){if(this.disposeOnEnd)for(B=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(B,1),B=0;B<I.length;B++)I[B].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return R}}function b(u){if(0===u.totalWeight&&0===u.totalAdditiveWeight)return u.originalValue;let R=1;const I=s.TmpVectors.PR[0],B=s.TmpVectors.PR[1],U=s.TmpVectors.Quaternion[0];let K=0;const C=u.animations[0],D=u.originalValue;let t=1,G=!1;if(u.totalWeight<1)t=1-u.totalWeight,D.decompose(B,U,I);else{if(K=1,R=u.totalWeight,t=C.weight/R,1==t){if(!u.totalAdditiveWeight)return C.currentValue;G=!0}C.currentValue.decompose(B,U,I)}if(!G){B.scaleInPlace(t),I.scaleInPlace(t),U.scaleInPlace(t);for(let C=K;C<u.animations.length;C++){const K=u.animations[C];if(0===K.weight)continue;t=K.weight/R;const D=s.TmpVectors.PR[2],G=s.TmpVectors.PR[3],S=s.TmpVectors.Quaternion[1];K.currentValue.decompose(G,S,D),G.scaleAndAddToRef(t,B),S.scaleAndAddToRef(s.Quaternion.Dot(U,S)>0?t:-t,U),D.scaleAndAddToRef(t,I)}U.normalize()}for(let b=0;b<u.additiveAnimations.length;b++){const R=u.additiveAnimations[b];if(0===R.weight)continue;const K=s.TmpVectors.PR[2],C=s.TmpVectors.PR[3],D=s.TmpVectors.Quaternion[1];R.currentValue.decompose(C,D,K),C.multiplyToRef(B,C),s.PR.LerpToRef(B,C,R.weight,B),U.multiplyToRef(D,D),s.Quaternion.SlerpToRef(U,D,R.weight,U),K.scaleAndAddToRef(R.weight,I)}const S=C?C._animationState.workValue:s.TmpVectors.Matrix[0].clone();return s.Matrix.ComposeToRef(B,U,I,S),S}function r(u,R){if(0===u.totalWeight&&0===u.totalAdditiveWeight)return R;const I=u.animations[0],B=u.originalValue;let U=R;if(0===u.totalWeight&&u.totalAdditiveWeight>0)U.B(B);else if(1===u.animations.length){if(s.Quaternion.SlerpToRef(B,I.currentValue,Math.min(1,u.totalWeight),U),0===u.totalAdditiveWeight)return U}else if(u.animations.length>1){let I,K,C=1;if(u.totalWeight<1){const R=1-u.totalWeight;I=[],K=[],I.push(B),K.push(R)}else{if(2===u.animations.length&&(s.Quaternion.SlerpToRef(u.animations[0].currentValue,u.animations[1].currentValue,u.animations[1].weight/u.totalWeight,R),0===u.totalAdditiveWeight))return R;I=[],K=[],C=u.totalWeight}for(let R=0;R<u.animations.length;R++){const B=u.animations[R];I.push(B.currentValue),K.push(B.weight/C)}let D=0;for(let u=0;u<I.length;)u?(D+=K[u],s.Quaternion.SlerpToRef(U,I[u],K[u]/D,U),u++):(s.Quaternion.SlerpToRef(I[u],I[u+1],K[u+1]/(K[u]+K[u+1]),R),U=R,D=K[u]+K[u+1],u+=2)}for(let K=0;K<u.additiveAnimations.length;K++){const R=u.additiveAnimations[K];0!==R.weight&&(U.multiplyToRef(R.currentValue,s.TmpVectors.Quaternion[0]),s.Quaternion.SlerpToRef(U,s.TmpVectors.Quaternion[0],R.weight,U))}return U}var P,X,E=I(12703);P=E.c,(X=D.b)&&(X.prototype.copyAnimationRange=function(u,R,I){let U=arguments.length>3&&void 0!==arguments[3]&&arguments[3],K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new B.d(this.name,"_matrix",u.animations[0].framePerSecond,B.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const C=u.animations[0].getRange(R);if(!C)return!1;const D=C.from,s=C.to,t=u.animations[0].getKeys(),G=u.length,S=u.getParent(),b=this.getParent(),r=U&&S&&G&&this.length&&G!==this.length,P=r&&b&&S?b.length/S.length:1,X=U&&!b&&K&&(1!==K.x||1!==K.y||1!==K.z),E=this.animations[0].getKeys();let z,f,T;for(let B=0,Q=t.length;B<Q;B++)z=t[B],z.frame>=D&&z.frame<=s&&(U?(T=z.value.clone(),r?(f=T.getTranslation(),T.setTranslation(f.scaleInPlace(P))):X&&K?(f=T.getTranslation(),T.setTranslation(f.multiplyInPlace(K))):T=z.value):T=z.value,E.push({frame:z.frame+I,value:T}));return this.animations[0].createRange(R,D+I,s+I),!0}),P&&(P.prototype._animate=function(u){if(!this.animationsEnabled)return;const R=G.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=R}this.deltaTime=void 0!==u?u:this.useConstantAnimationDeltaTime?16:(R-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=R;const I=this._activeAnimatables;if(0===I.length)return;this._animationTime+=this.deltaTime;const U=this._animationTime;for(let B=0;B<I.length;B++){const u=I[B];!u._animate(U)&&u.disposeOnEnd&&B--}!function(u){if(u._registeredForLateAnimationBindings.length){for(let R=0;R<u._registeredForLateAnimationBindings.length;R++){const I=u._registeredForLateAnimationBindings.data[R];for(const u in I._lateAnimationHolders){const R=I._lateAnimationHolders[u],U=R.animations[0],K=R.originalValue;if(void 0===K||null===K)continue;const C=B.d.AllowMatrixDecomposeForInterpolation&&K.m;let D=I[u];if(C)D=b(R);else if(void 0!==K.w)D=r(R,D||s.Quaternion.Identity());else{let u=0,I=1;const C=U&&U._animationState.loopMode===B.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(R.totalWeight<1)D=C?K.clone?K.clone():K:U&&K.scale?K.scale(1-R.totalWeight):U?K*(1-R.totalWeight):K.clone?K.clone():K;else if(U){I=R.totalWeight;const B=U.weight/I;D=1!==B?U.currentValue.scale?U.currentValue.scale(B):U.currentValue*B:U.currentValue,C&&(D.addToRef?D.addToRef(K,D):D+=K),u=1}for(let B=u;B<R.animations.length;B++){const u=R.animations[B],U=u.weight/I;U&&(u.currentValue.scaleAndAddToRef?u.currentValue.scaleAndAddToRef(U,D):D+=u.currentValue*U)}for(let B=0;B<R.additiveAnimations.length;B++){const u=R.additiveAnimations[B],I=u.weight;I&&(u.currentValue.scaleAndAddToRef?u.currentValue.scaleAndAddToRef(I,D):D+=u.currentValue*I)}}I[u]=D}I._lateAnimationHolders={}}u._registeredForLateAnimationBindings.reset()}}(this)},P.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((u,R)=>u.playOrder-R.playOrder))},P.prototype.beginWeightedAnimation=function(u,R,I){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,U=arguments.length>4?arguments[4]:void 0,K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,C=arguments.length>6?arguments[6]:void 0,D=arguments.length>7?arguments[7]:void 0,s=arguments.length>8?arguments[8]:void 0,t=arguments.length>9?arguments[9]:void 0,G=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const S=this.beginAnimation(u,R,I,U,K,C,D,!1,s,t,G);return S.weight=B,S},P.prototype.beginAnimation=function(u,R,I,B){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,K=arguments.length>5?arguments[5]:void 0,C=arguments.length>6?arguments[6]:void 0,D=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],s=arguments.length>8?arguments[8]:void 0,t=arguments.length>9?arguments[9]:void 0,G=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(U<0){const u=R;R=I,I=u,U=-U}R>I&&(U=-U),D&&this.stopAnimation(u,void 0,s),C||(C=new S(this,u,R,I,B,U,K,void 0,t,G));const b=!s||s(u);if(u.animations&&b&&C.appendAnimations(u,u.animations),u.getAnimatables){const G=u.getAnimatables();for(let u=0;u<G.length;u++)this.beginAnimation(G[u],R,I,B,U,K,C,D,s,t)}return C.reset(),C},P.prototype.beginHierarchyAnimation=function(u,R,I,B,U){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,C=arguments.length>6?arguments[6]:void 0,D=arguments.length>7?arguments[7]:void 0,s=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],t=arguments.length>9?arguments[9]:void 0,G=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const S=u.getDescendants(R),b=[];b.push(this.beginAnimation(u,I,B,U,K,C,D,s,t,void 0,G));for(const r of S)b.push(this.beginAnimation(r,I,B,U,K,C,D,s,t,void 0,G));return b},P.prototype.beginDirectAnimation=function(u,R,I,B,U){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(K<0){const u=I;I=B,B=u,K=-K}return I>B&&(K=-K),new S(this,u,I,B,U,K,arguments.length>6?arguments[6]:void 0,R,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},P.prototype.beginDirectHierarchyAnimation=function(u,R,I,B,U,K,C,D,s){let t=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const G=u.getDescendants(R),S=[];S.push(this.beginDirectAnimation(u,I,B,U,K,C,D,s,t));for(const b of G)S.push(this.beginDirectAnimation(b,I,B,U,K,C,D,s,t));return S},P.prototype.getAnimatableByTarget=function(u){for(let R=0;R<this._activeAnimatables.length;R++)if(this._activeAnimatables[R].target===u)return this._activeAnimatables[R];return null},P.prototype.getAllAnimatablesByTarget=function(u){const R=[];for(let I=0;I<this._activeAnimatables.length;I++)this._activeAnimatables[I].target===u&&R.push(this._activeAnimatables[I]);return R},P.prototype.stopAnimation=function(u,R,I){const B=this.getAllAnimatablesByTarget(u);for(const U of B)U.stop(R,I)},P.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let u=0;u<this._activeAnimatables.length;u++)this._activeAnimatables[u].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const u of this.animationGroups)u.stop()});class z{getClassName(){return"TargetedAnimation"}serialize(){const u={};return u.animation=this.animation.serialize(),u.targetId=this.target.id,u}}class f{get mask(){return this._mask}set mask(u){this._mask!==u&&(this._mask=u,this.syncWithMask(!0))}syncWithMask(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||u){this._numActiveAnimatables=0;for(let u=0;u<this._animatables.length;++u){const R=this._animatables[u];!this.mask||this.mask.disabled||this.mask.retainsTarget(R.target.name)?(this._numActiveAnimatables++,R.paused&&R.restart()):R.paused||R.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let u=0;u<this._animatables.length;++u){const R=this._animatables[u];this.mask.retainsTarget(R.target.name)||(R.stop(),this._animatables.splice(u,1),--u)}for(let u=0;u<this._targetedAnimations.length;u++){const R=this._targetedAnimations[u];this.mask.retainsTarget(R.target.name)||(this._targetedAnimations.splice(u,1),--u)}}}get from(){return this._from}set from(u){if(this._from!==u){this._from=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].fromFrame=this._from}}}get to(){return this._to}set to(u){if(this._to!==u){this._to=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(u){if(this._speedRatio!==u){this._speedRatio=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(u){if(this._loopAnimation!==u){this._loopAnimation=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(u){if(this._isAdditive!==u){this._isAdditive=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(u){this._weight!==u&&(this._weight=u,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(u){if(this._playOrder!==u&&(this._playOrder=u,this._animatables.length>0)){for(let u=0;u<this._animatables.length;u++)this._animatables[u].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(u){if(this._enableBlending!==u&&(this._enableBlending=u,null!==u))for(let R=0;R<this._targetedAnimations.length;++R)this._targetedAnimations[R].animation.enableBlending=u}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(u){if(this._blendingSpeed!==u&&(this._blendingSpeed=u,null!==u))for(let R=0;R<this._targetedAnimations.length;++R)this._targetedAnimations[R].animation.blendingSpeed=u}getLength(u,R){u=u??this._from;return((R=R??this._to)-u)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(u){let R=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],I=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=arguments.length>3?arguments[3]:void 0;if(0===u.length)return null;B=B??u[0].weight;let U=Number.MAX_VALUE,K=-Number.MAX_VALUE;if(I)for(const D of u)D.from<U&&(U=D.from),D.to>K&&(K=D.to);const C=new f(u[0].name+"_merged",u[0]._scene,B);for(const D of u){I&&D.normalize(U,K);for(const u of D.targetedAnimations)C.addTargetedAnimation(u.animation,u.target);R&&D.dispose()}return C}constructor(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=u,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new U.c,this.onAnimationLoopObservable=new U.c,this.onAnimationGroupLoopObservable=new U.c,this.onAnimationGroupEndObservable=new U.c,this.onAnimationGroupPauseObservable=new U.c,this.onAnimationGroupPlayObservable=new U.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=R||K.e.LastCreatedScene,this._weight=I,this._playOrder=B,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(u,R){const I=new z;I.animation=u,I.target=R;const B=u.getKeys();return this._from>B[0].frame&&(this._from=B[0].frame),this._to<B[B.length-1].frame&&(this._to=B[B.length-1].frame),null!==this._enableBlending&&(u.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(u.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(I),this._shouldStart=!0,I}removeTargetedAnimation(u){for(let R=this._targetedAnimations.length-1;R>-1;R--){this._targetedAnimations[R].animation===u&&this._targetedAnimations.splice(R,1)}}normalize(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==u&&(u=this._from),null==R&&(R=this._to);for(let I=0;I<this._targetedAnimations.length;I++){const B=this._targetedAnimations[I].animation.getKeys(),U=B[0],K=B[B.length-1];if(U.frame>u){const R={frame:u,value:U.value,inTangent:U.inTangent,outTangent:U.outTangent,interpolation:U.interpolation};B.splice(0,0,R)}if(K.frame<R){const u={frame:R,value:K.value,inTangent:K.inTangent,outTangent:K.outTangent,interpolation:K.interpolation};B.push(u)}}return this._from=u,this._to=R,this}_processLoop(u,R,I){u.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(R),this._animationLoopFlags[I]||(this._animationLoopFlags[I]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0],R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,I=arguments.length>2?arguments[2]:void 0,B=arguments.length>3?arguments[3]:void 0,U=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=u,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let K=0;K<this._targetedAnimations.length;K++){const C=this._targetedAnimations[K],D=this._scene.beginDirectAnimation(C.target,[C.animation],void 0!==I?I:this._from,void 0!==B?B:this._to,u,R,void 0,void 0,void 0!==U?U:this._isAdditive);D.weight=this._weight,D.playOrder=this._playOrder,D.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(C),this._checkAnimationGroupEnded(D)},this._processLoop(D,C,K),this._animatables.push(D)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=R,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let u=0;u<this._animatables.length;u++){this._animatables[u].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(u){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==u&&(this.loopAnimation=u),this.restart()):(this.stop(),this.start(u,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let u=0;u<this._animatables.length;u++){this._animatables[u].reset()}return this}restart(){if(!this._isStarted)return this;for(let u=0;u<this._animatables.length;u++){this._animatables[u].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const R=this._animatables.slice();for(let B=0;B<R.length;B++)R[B].stop(void 0,void 0,!0,u);let I=0;for(let B=0;B<this._scene._activeAnimatables.length;B++){const R=this._scene._activeAnimatables[B];R._runtimeAnimations.length>0?this._scene._activeAnimatables[I++]=R:u&&this._checkAnimationGroupEnded(R,u)}return this._scene._activeAnimatables.length=I,this._isStarted=!1,this}setWeightForAllAnimatables(u){for(let R=0;R<this._animatables.length;R++){this._animatables[R].weight=u}return this}syncAllAnimationsWith(u){for(let R=0;R<this._animatables.length;R++){this._animatables[R].syncWith(u)}return this}goToFrame(u){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let I=0;I<this._animatables.length;I++){this._animatables[I].goToFrame(u,R)}return this}getCurrentFrame(){var u;return(null===(u=this.animatables[0])||void 0===u?void 0:u.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const u=this._scene.animationGroups.indexOf(this);if(u>-1&&this._scene.animationGroups.splice(u,1),this._parentContainer){const u=this._parentContainer.animationGroups.indexOf(this);u>-1&&this._parentContainer.animationGroups.splice(u,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(u){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const I=this._animatables.indexOf(u);I>-1&&this._animatables.splice(I,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,R||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(u,R){let I=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=new f(u||this.name,this._scene,this._weight,this._playOrder);B._from=this.from,B._to=this.to,B._speedRatio=this.speedRatio,B._loopAnimation=this.loopAnimation,B._isAdditive=this.isAdditive,B._enableBlending=this.enableBlending,B._blendingSpeed=this.blendingSpeed,B.metadata=this.metadata,B.mask=this.mask;for(const U of this._targetedAnimations)B.addTargetedAnimation(I?U.animation.clone():U.animation,R?R(U.target):U.target);return B}serialize(){const u={};u.name=this.name,u.from=this.from,u.to=this.to,u.speedRatio=this.speedRatio,u.loopAnimation=this.loopAnimation,u.isAdditive=this.isAdditive,u.weight=this.weight,u.playOrder=this.playOrder,u.enableBlending=this.enableBlending,u.blendingSpeed=this.blendingSpeed,u.targetedAnimations=[];for(let R=0;R<this.targetedAnimations.length;R++){const I=this.targetedAnimations[R];u.targetedAnimations[R]=I.serialize()}return C.e&&C.e.HasTags(this)&&(u.tags=C.e.GetTags(this)),this.metadata&&(u.metadata=this.metadata),u}static Parse(u,R){const I=new f(u.name,R,u.weight,u.playOrder);for(let U=0;U<u.targetedAnimations.length;U++){const K=u.targetedAnimations[U],C=B.d.Parse(K.animation),D=K.targetId;if("influence"===K.animation.property){const u=R.getMorphTargetById(D);u&&I.addTargetedAnimation(C,u)}else{const u=R.getNodeById(D);null!=u&&I.addTargetedAnimation(C,u)}}return C.e&&C.e.AddTagsTo(I,u.tags),null!==u.from&&null!==u.to&&I.normalize(u.from,u.to),void 0!==u.speedRatio&&(I._speedRatio=u.speedRatio),void 0!==u.loopAnimation&&(I._loopAnimation=u.loopAnimation),void 0!==u.isAdditive&&(I._isAdditive=u.isAdditive),void 0!==u.weight&&(I._weight=u.weight),void 0!==u.playOrder&&(I._playOrder=u.playOrder),void 0!==u.enableBlending&&(I._enableBlending=u.enableBlending),void 0!==u.blendingSpeed&&(I._blendingSpeed=u.blendingSpeed),void 0!==u.metadata&&(I.metadata=u.metadata),I}static MakeAnimationAdditive(u,R,I){let U;U="object"===typeof R?R:{referenceFrame:R,range:I,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let K=u;U.cloneOriginalAnimationGroup&&(K=u.clone(U.clonedAnimationGroupName||K.name));const C=K.targetedAnimations;for(let D=0;D<C.length;D++){const u=C[D];u.animation=B.d.MakeAnimationAdditive(u.animation,U)}if(K.isAdditive=!0,U.clipKeys){let u=Number.MAX_VALUE,R=-Number.MAX_VALUE;const I=K.targetedAnimations;for(let B=0;B<I.length;B++){const U=I[B].animation.getKeys();u>U[0].frame&&(u=U[0].frame),R<U[U.length-1].frame&&(R=U[U.length-1].frame)}K._from=u,K._to=R}return K}static ClipKeys(u,R,I,B,U){const K=u.clone(B||u.name);return f.ClipKeysInPlace(K,R,I,U)}static ClipKeysInPlace(u,R,I,B){return f.ClipInPlace(u,R,I,B,!1)}static ClipFrames(u,R,I,B,U){const K=u.clone(B||u.name);return f.ClipFramesInPlace(K,R,I,U)}static ClipFramesInPlace(u,R,I,B){return f.ClipInPlace(u,R,I,B,!0)}static ClipInPlace(u,R,I,B){let U=arguments.length>4&&void 0!==arguments[4]&&arguments[4],K=Number.MAX_VALUE,C=-Number.MAX_VALUE;const D=u.targetedAnimations;for(let s=0;s<D.length;s++){const u=D[s],t=B?u.animation:u.animation.clone();U&&(t.createKeyForFrame(R),t.createKeyForFrame(I));const G=t.getKeys(),S=[];let b=Number.MAX_VALUE;for(let B=0;B<G.length;B++){const u=G[B];if(!U&&B>=R&&B<=I||U&&u.frame>=R&&u.frame<=I){const R={frame:u.frame,value:u.value.clone?u.value.clone():u.value,inTangent:u.inTangent,outTangent:u.outTangent,interpolation:u.interpolation,lockedTangent:u.lockedTangent};b===Number.MAX_VALUE&&(b=R.frame),R.frame-=b,S.push(R)}}0!==S.length?(K>S[0].frame&&(K=S[0].frame),C<S[S.length-1].frame&&(C=S[S.length-1].frame),t.setKeys(S,!0),u.animation=t):(D.splice(s,1),s--)}return u._from=K,u._to=C,u}getClassName(){return"AnimationGroup"}toString(u){let R="Name: "+this.name;return R+=", type: "+this.getClassName(),u&&(R+=", from: "+this._from,R+=", to: "+this._to,R+=", isStarted: "+this._isStarted,R+=", speedRatio: "+this._speedRatio,R+=", targetedAnimations length: "+this._targetedAnimations.length,R+=", animatables length: "+this._animatables),R}}}}]);