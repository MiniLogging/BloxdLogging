"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[78],{14509:(B,E,v)=>{v.r(E),v.d(E,{AnimationGroup:()=>g,TargetedAnimation:()=>m});var z=v(11908),o=v(11202),q=v(11242),c=v(11414),S=v(13020),x=v(11380);class D{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(B,E,v,o){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=E,this._target=B,this._scene=v,this._host=o,this._activeTargets=[],E._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===z.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=x.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const B={frame:0,value:this._minValue};this._keys.splice(0,0,B)}if(this._target instanceof Array){let B=0;for(const E of this._target)this._preparePath(E,B),this._getOriginalValues(B),B++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const q=E.getEvents();if(q&&q.length>0)for(const z of q)this._events.push(z._clone());this._enableBlending=B&&B.animationPropertiesOverride?B.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const v=this._animation.targetPropertyPath;if(v.length>1){let z=B;for(let B=0;B<v.length-1;B++){const E=v[B];if(z=z[E],void 0===z)throw new Error(`Invalid property (${E}) in property path (${v.join(".")})`)}this._targetPath=v[v.length-1],this._activeTargets[E]=z}else this._targetPath=v[0],this._activeTargets[E]=B;if(void 0===this._activeTargets[E][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${v.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let B=0;for(const E of this._target)void 0!==this._originalValue[B]&&this._setValue(E,this._activeTargets[B],this._originalValue[B],-1,B),B++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let B=0;B<this._events.length;B++)this._events[B].isDone=!1}isStopped(){return this._stopped}dispose(){const B=this._animation.runtimeAnimations.indexOf(this);B>-1&&this._animation.runtimeAnimations.splice(B,1)}setValue(B,E){if(this._targetIsArray)for(let v=0;v<this._target.length;v++){const z=this._target[v];this._setValue(z,this._activeTargets[v],B,E,v)}else this._setValue(this._target,this._directTarget,B,E,0)}_getOriginalValues(){let B,E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const v=this._activeTargets[E];B=v.getLocalMatrix&&"_matrix"===this._targetPath?v.getLocalMatrix():v[this._targetPath],B&&B.clone?this._originalValue[E]=B.clone():this._originalValue[E]=B}_registerTargetForLateAnimationBinding(B,E){const v=B.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(v),v._lateAnimationHolders||(v._lateAnimationHolders={}),v._lateAnimationHolders[B.targetPath]||(v._lateAnimationHolders[B.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:E}),B.isAdditive?(v._lateAnimationHolders[B.targetPath].additiveAnimations.push(B),v._lateAnimationHolders[B.targetPath].totalAdditiveWeight+=B.weight):(v._lateAnimationHolders[B.targetPath].animations.push(B),v._lateAnimationHolders[B.targetPath].totalWeight+=B.weight)}_setValue(B,E,v,o,q){if(this._currentActiveTarget=E,this._weight=o,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const B=E[this._targetPath];B.clone?this._originalBlendValue=B.clone():this._originalBlendValue=B}this._originalBlendValue.m?z.c.AllowMatrixDecomposeForInterpolation?this._currentValue?x.Matrix.DecomposeLerpToRef(this._originalBlendValue,v,this._blendingFactor,this._currentValue):this._currentValue=x.Matrix.DecomposeLerp(this._originalBlendValue,v,this._blendingFactor):this._currentValue?x.Matrix.LerpToRef(this._originalBlendValue,v,this._blendingFactor,this._currentValue):this._currentValue=x.Matrix.Lerp(this._originalBlendValue,v,this._blendingFactor):this._currentValue=z.c._UniversalLerp(this._originalBlendValue,v,this._blendingFactor);const o=B&&B.animationPropertiesOverride?B.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=o}else this._currentValue?this._currentValue.S?this._currentValue.S(v):this._currentValue=v:null!==v&&void 0!==v&&v.clone?this._currentValue=v.clone():this._currentValue=v;-1!==o?this._registerTargetForLateAnimationBinding(this,this._originalValue[q]):this._animationState.loopMode===z.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[q],E[this._targetPath]):E[this._targetPath]=this._originalValue[q]+this._currentValue:E[this._targetPath]=this._currentValue,B.mh&&B.mh(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const v=this._animation.getKeys();B<v[0].frame?B=v[0].frame:B>v[v.length-1].frame&&(B=v[v.length-1].frame);const z=this._events;if(z.length)for(let q=0;q<z.length;q++)z[q].onlyOnce||(z[q].isDone=z[q].frame<B);this._currentFrame=B;const o=this._animation._interpolate(B,this._animationState);this.setValue(o,E)}_prepareForSpeedRatioChange(B){const E=this._previousElapsedTime*(this._animation.framePerSecond*B)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-E}animate(B,E,v,o,q){let c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const S=this._animation,x=S.targetPropertyPath;if(!x||x.length<1)return this._stopped=!0,!1;let D,h=!0;const y=this._events;let Q=0;if(this._coreRuntimeAnimation)Q=v-E,D=this._coreRuntimeAnimation.currentFrame,this._currentFrame=D,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let c;(E<this._minFrame||E>this._maxFrame)&&(E=this._minFrame),(v<this._minFrame||v>this._maxFrame)&&(v=this._maxFrame),Q=v-E;let x=B*(S.framePerSecond*q)/1e3+this._absoluteFrameOffset,P=0,G=!1;const Y=o&&this._animationState.loopMode===z.c.ANIMATIONLOOPMODE_YOYO;if(Y){const B=(x-E)/Q,v=Math.sin(B*Math.PI);x=Math.abs(v)*Q+E;const z=v>=0?1:-1;this._yoyoDirection!==z&&(G=!0),this._yoyoDirection=z}if(this._previousElapsedTime=B,this._previousAbsoluteFrame=x,!o&&v>=E&&(x>=Q&&q>0||x<=0&&q<0))h=!1,P=S._getKeyValue(this._maxValue);else if(!o&&E>=v&&(x<=Q&&q<0||x>=0&&q>0))h=!1,P=S._getKeyValue(this._minValue);else if(this._animationState.loopMode!==z.c.ANIMATIONLOOPMODE_CYCLE){const B=v.toString()+E.toString();if(!this._offsetsCache[B]){this._animationState.repeatCount=0,this._animationState.loopMode=z.c.ANIMATIONLOOPMODE_CYCLE;const o=S._interpolate(E,this._animationState),q=S._interpolate(v,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),S.dataType){case z.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[B]=q-o;break;case z.c.ANIMATIONTYPE_QUATERNION:case z.c.ANIMATIONTYPE_VECTOR3:case z.c.ANIMATIONTYPE_VECTOR2:case z.c.ANIMATIONTYPE_SIZE:case z.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[B]=q.YE(o)}this._highLimitsCache[B]=q}P=this._highLimitsCache[B],c=this._offsetsCache[B]}if(void 0===c)switch(S.dataType){case z.c.ANIMATIONTYPE_FLOAT:c=0;break;case z.c.ANIMATIONTYPE_QUATERNION:c=z.l;break;case z.c.ANIMATIONTYPE_VECTOR3:c=z.s;break;case z.c.ANIMATIONTYPE_VECTOR2:c=z.p;break;case z.c.ANIMATIONTYPE_SIZE:c=z.o;break;case z.c.ANIMATIONTYPE_COLOR3:c=z.d;break;case z.c.ANIMATIONTYPE_COLOR4:c=z.h}if(this._host&&this._host.syncRoot){const B=this._host.syncRoot;D=E+Q*((B.masterFrame-B.fromFrame)/(B.toFrame-B.fromFrame))}else D=x>0&&E>v||x<0&&E<v?h&&0!==Q?v+x%Q:E:h&&0!==Q?E+x%Q:v;if(!Y&&(q>0&&this.currentFrame>D||q<0&&this.currentFrame<D)||Y&&G){this._onLoop();for(let B=0;B<y.length;B++)y[B].onlyOnce||(y[B].isDone=!1);this._animationState.key=q>0?0:S.getKeys().length-1}this._currentFrame=D,this._animationState.repeatCount=0===Q?0:x/Q|0,this._animationState.highLimitValue=P,this._animationState.offsetValue=c}const P=S._interpolate(D,this._animationState);if(this.setValue(P,c),y.length)for(let z=0;z<y.length;z++)if(Q>=0&&D>=y[z].frame&&y[z].frame>=E||Q<0&&D<=y[z].frame&&y[z].frame<=E){const B=y[z];B.isDone||(B.onlyOnce&&(y.splice(z,1),z--),B.isDone=!0,B.action(D))}return h||(this._stopped=!0),h}}var h=v(11230);class y{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(B){this._weight=-1!==B?Math.min(Math.max(B,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(B){for(let E=0;E<this._runtimeAnimations.length;E++){this._runtimeAnimations[E]._prepareForSpeedRatioChange(B)}this._speedRatio=B,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(B,E){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,S=arguments.length>6?arguments[6]:void 0,x=arguments.length>7?arguments[7]:void 0,D=arguments.length>8?arguments[8]:void 0,h=arguments.length>9&&void 0!==arguments[9]&&arguments[9],y=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=E,this.fromFrame=v,this.toFrame=z,this.loopAnimation=q,this.onAnimationEnd=S,this.onAnimationLoop=D,this.isAdditive=h,this.playOrder=y,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.FS=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new o.e,this.onAnimationLoopObservable=new o.e,this._scene=B,x&&this.appendAnimations(E,x),this._speedRatio=c,B._activeAnimatables.push(this)}syncWith(B){if(this._syncRoot=B,B){const B=this._scene._activeAnimatables.indexOf(this);B>-1&&(this._scene._activeAnimatables.splice(B,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(B,E){for(let v=0;v<E.length;v++){const z=E[v],o=new D(B,z,this._scene,this);o._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(o)}}getAnimationByTargetProperty(B){const E=this._runtimeAnimations;for(let v=0;v<E.length;v++)if(E[v].animation.targetProperty===B)return E[v].animation;return null}getRuntimeAnimationByTargetProperty(B){const E=this._runtimeAnimations;for(let v=0;v<E.length;v++)if(E[v].animation.targetProperty===B)return E[v];return null}reset(){const B=this._runtimeAnimations;for(let E=0;E<B.length;E++)B[E].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(B){const E=this._runtimeAnimations;for(let v=0;v<E.length;v++)E[v].animation.enableBlending=!0,E[v].animation.blendingSpeed=B}disableBlending(){const B=this._runtimeAnimations;for(let E=0;E<B.length;E++)B[E].animation.enableBlending=!1}goToFrame(B){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const v=this._runtimeAnimations;if(v[0]){const E=v[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??v[0].currentFrame;const z=0===this.speedRatio?0:(B-this._frameToSyncFromJump)/E*1e3/this.speedRatio;this._manualJumpDelay=-z}for(let z=0;z<v.length;z++)v[z].goToFrame(B,E?this._weight:-1);this._goToFrame=B}get paused(){return this.FS}pause(){this.FS||(this.FS=!0)}restart(){this.FS=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(B,E){let v=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(B||E){const o=this._scene._activeAnimatables.indexOf(this);if(o>-1){const q=this._runtimeAnimations;for(let v=q.length-1;v>=0;v--){const z=q[v];B&&z.animation.name!=B||(E&&!E(z.target)||(z.dispose(),q.splice(v,1)))}0==q.length&&(v||this._scene._activeAnimatables.splice(o,1),z||this._raiseOnAnimationEnd())}}else{const B=this._scene._activeAnimatables.indexOf(this);if(B>-1){v||this._scene._activeAnimatables.splice(B,1);const E=this._runtimeAnimations;for(let B=0;B<E.length;B++)E[B].dispose();this._runtimeAnimations.length=0,z||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((B=>{this.onAnimationEndObservable.add((()=>{B(this)}),void 0,void 0,this,!0)}))}_animate(B){if(this.FS)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=B),!0;if(null===this._localDelayOffset?(this._localDelayOffset=B,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=B-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let E=!1;const v=this._runtimeAnimations;let z;for(z=0;z<v.length;z++){const o=v[z].animate(B-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);E=E||o}if(this.animationStarted=E,!E){if(this.disposeOnEnd)for(z=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(z,1),z=0;z<v.length;z++)v[z].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return E}}function Q(B){if(0===B.totalWeight&&0===B.totalAdditiveWeight)return B.originalValue;let E=1;const v=x.TmpVectors.GE[0],z=x.TmpVectors.GE[1],o=x.TmpVectors.Quaternion[0];let q=0;const c=B.animations[0],S=B.originalValue;let D=1,h=!1;if(B.totalWeight<1)D=1-B.totalWeight,S.decompose(z,o,v);else{if(q=1,E=B.totalWeight,D=c.weight/E,1==D){if(!B.totalAdditiveWeight)return c.currentValue;h=!0}c.currentValue.decompose(z,o,v)}if(!h){z.scaleInPlace(D),v.scaleInPlace(D),o.scaleInPlace(D);for(let c=q;c<B.animations.length;c++){const q=B.animations[c];if(0===q.weight)continue;D=q.weight/E;const S=x.TmpVectors.GE[2],h=x.TmpVectors.GE[3],y=x.TmpVectors.Quaternion[1];q.currentValue.decompose(h,y,S),h.scaleAndAddToRef(D,z),y.scaleAndAddToRef(x.Quaternion.Dot(o,y)>0?D:-D,o),S.scaleAndAddToRef(D,v)}o.normalize()}for(let Q=0;Q<B.additiveAnimations.length;Q++){const E=B.additiveAnimations[Q];if(0===E.weight)continue;const q=x.TmpVectors.GE[2],c=x.TmpVectors.GE[3],S=x.TmpVectors.Quaternion[1];E.currentValue.decompose(c,S,q),c.multiplyToRef(z,c),x.GE.LerpToRef(z,c,E.weight,z),o.multiplyToRef(S,S),x.Quaternion.SlerpToRef(o,S,E.weight,o),q.scaleAndAddToRef(E.weight,v)}const y=c?c._animationState.workValue:x.TmpVectors.Matrix[0].clone();return x.Matrix.ComposeToRef(z,o,v,y),y}function P(B,E){if(0===B.totalWeight&&0===B.totalAdditiveWeight)return E;const v=B.animations[0],z=B.originalValue;let o=E;if(0===B.totalWeight&&B.totalAdditiveWeight>0)o.S(z);else if(1===B.animations.length){if(x.Quaternion.SlerpToRef(z,v.currentValue,Math.min(1,B.totalWeight),o),0===B.totalAdditiveWeight)return o}else if(B.animations.length>1){let v,q,c=1;if(B.totalWeight<1){const E=1-B.totalWeight;v=[],q=[],v.push(z),q.push(E)}else{if(2===B.animations.length&&(x.Quaternion.SlerpToRef(B.animations[0].currentValue,B.animations[1].currentValue,B.animations[1].weight/B.totalWeight,E),0===B.totalAdditiveWeight))return E;v=[],q=[],c=B.totalWeight}for(let E=0;E<B.animations.length;E++){const z=B.animations[E];v.push(z.currentValue),q.push(z.weight/c)}let S=0;for(let B=0;B<v.length;)B?(S+=q[B],x.Quaternion.SlerpToRef(o,v[B],q[B]/S,o),B++):(x.Quaternion.SlerpToRef(v[B],v[B+1],q[B+1]/(q[B]+q[B+1]),E),o=E,S=q[B]+q[B+1],B+=2)}for(let q=0;q<B.additiveAnimations.length;q++){const E=B.additiveAnimations[q];0!==E.weight&&(o.multiplyToRef(E.currentValue,x.TmpVectors.Quaternion[0]),x.Quaternion.SlerpToRef(o,x.TmpVectors.Quaternion[0],E.weight,o))}return o}var G,Y,a=v(11601);G=a.c,(Y=S.b)&&(Y.prototype.copyAnimationRange=function(B,E,v){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3],q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new z.c(this.name,"_matrix",B.animations[0].framePerSecond,z.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const c=B.animations[0].getRange(E);if(!c)return!1;const S=c.from,x=c.to,D=B.animations[0].getKeys(),h=B.length,y=B.getParent(),Q=this.getParent(),P=o&&y&&h&&this.length&&h!==this.length,G=P&&Q&&y?Q.length/y.length:1,Y=o&&!Q&&q&&(1!==q.x||1!==q.y||1!==q.z),a=this.animations[0].getKeys();let m,g,V;for(let z=0,T=D.length;z<T;z++)m=D[z],m.frame>=S&&m.frame<=x&&(o?(V=m.value.clone(),P?(g=V.getTranslation(),V.setTranslation(g.scaleInPlace(G))):Y&&q?(g=V.getTranslation(),V.setTranslation(g.multiplyInPlace(q))):V=m.value):V=m.value,a.push({frame:m.frame+v,value:V}));return this.animations[0].createRange(E,S+v,x+v),!0}),G&&(G.prototype._animate=function(B){if(!this.animationsEnabled)return;const E=h.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=E}this.deltaTime=void 0!==B?B:this.useConstantAnimationDeltaTime?16:(E-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=E;const v=this._activeAnimatables;if(0===v.length)return;this._animationTime+=this.deltaTime;const o=this._animationTime;for(let z=0;z<v.length;z++){const B=v[z];!B._animate(o)&&B.disposeOnEnd&&z--}!function(B){if(B._registeredForLateAnimationBindings.length){for(let E=0;E<B._registeredForLateAnimationBindings.length;E++){const v=B._registeredForLateAnimationBindings.data[E];for(const B in v._lateAnimationHolders){const E=v._lateAnimationHolders[B],o=E.animations[0],q=E.originalValue;if(void 0===q||null===q)continue;const c=z.c.AllowMatrixDecomposeForInterpolation&&q.m;let S=v[B];if(c)S=Q(E);else if(void 0!==q.w)S=P(E,S||x.Quaternion.Identity());else{let B=0,v=1;const c=o&&o._animationState.loopMode===z.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(E.totalWeight<1)S=c?q.clone?q.clone():q:o&&q.scale?q.scale(1-E.totalWeight):o?q*(1-E.totalWeight):q.clone?q.clone():q;else if(o){v=E.totalWeight;const z=o.weight/v;S=1!==z?o.currentValue.scale?o.currentValue.scale(z):o.currentValue*z:o.currentValue,c&&(S.addToRef?S.addToRef(q,S):S+=q),B=1}for(let z=B;z<E.animations.length;z++){const B=E.animations[z],o=B.weight/v;o&&(B.currentValue.scaleAndAddToRef?B.currentValue.scaleAndAddToRef(o,S):S+=B.currentValue*o)}for(let z=0;z<E.additiveAnimations.length;z++){const B=E.additiveAnimations[z],v=B.weight;v&&(B.currentValue.scaleAndAddToRef?B.currentValue.scaleAndAddToRef(v,S):S+=B.currentValue*v)}}v[B]=S}v._lateAnimationHolders={}}B._registeredForLateAnimationBindings.reset()}}(this)},G.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((B,E)=>B.playOrder-E.playOrder))},G.prototype.beginWeightedAnimation=function(B,E,v){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,o=arguments.length>4?arguments[4]:void 0,q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,c=arguments.length>6?arguments[6]:void 0,S=arguments.length>7?arguments[7]:void 0,x=arguments.length>8?arguments[8]:void 0,D=arguments.length>9?arguments[9]:void 0,h=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const y=this.beginAnimation(B,E,v,o,q,c,S,!1,x,D,h);return y.weight=z,y},G.prototype.beginAnimation=function(B,E,v,z){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,q=arguments.length>5?arguments[5]:void 0,c=arguments.length>6?arguments[6]:void 0,S=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],x=arguments.length>8?arguments[8]:void 0,D=arguments.length>9?arguments[9]:void 0,h=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(o<0){const B=E;E=v,v=B,o=-o}E>v&&(o=-o),S&&this.stopAnimation(B,void 0,x),c||(c=new y(this,B,E,v,z,o,q,void 0,D,h));const Q=!x||x(B);if(B.animations&&Q&&c.appendAnimations(B,B.animations),B.getAnimatables){const h=B.getAnimatables();for(let B=0;B<h.length;B++)this.beginAnimation(h[B],E,v,z,o,q,c,S,x,D)}return c.reset(),c},G.prototype.beginHierarchyAnimation=function(B,E,v,z,o){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,c=arguments.length>6?arguments[6]:void 0,S=arguments.length>7?arguments[7]:void 0,x=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],D=arguments.length>9?arguments[9]:void 0,h=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const y=B.getDescendants(E),Q=[];Q.push(this.beginAnimation(B,v,z,o,q,c,S,x,D,void 0,h));for(const P of y)Q.push(this.beginAnimation(P,v,z,o,q,c,S,x,D,void 0,h));return Q},G.prototype.beginDirectAnimation=function(B,E,v,z,o){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(q<0){const B=v;v=z,z=B,q=-q}return v>z&&(q=-q),new y(this,B,v,z,o,q,arguments.length>6?arguments[6]:void 0,E,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},G.prototype.beginDirectHierarchyAnimation=function(B,E,v,z,o,q,c,S,x){let D=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const h=B.getDescendants(E),y=[];y.push(this.beginDirectAnimation(B,v,z,o,q,c,S,x,D));for(const Q of h)y.push(this.beginDirectAnimation(Q,v,z,o,q,c,S,x,D));return y},G.prototype.getAnimatableByTarget=function(B){for(let E=0;E<this._activeAnimatables.length;E++)if(this._activeAnimatables[E].target===B)return this._activeAnimatables[E];return null},G.prototype.getAllAnimatablesByTarget=function(B){const E=[];for(let v=0;v<this._activeAnimatables.length;v++)this._activeAnimatables[v].target===B&&E.push(this._activeAnimatables[v]);return E},G.prototype.stopAnimation=function(B,E,v){const z=this.getAllAnimatablesByTarget(B);for(const o of z)o.stop(E,v)},G.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let B=0;B<this._activeAnimatables.length;B++)this._activeAnimatables[B].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const B of this.animationGroups)B.stop()});class m{getClassName(){return"TargetedAnimation"}serialize(){const B={};return B.animation=this.animation.serialize(),B.targetId=this.target.id,B}}class g{get mask(){return this._mask}set mask(B){this._mask!==B&&(this._mask=B,this.syncWithMask(!0))}syncWithMask(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||B){this._numActiveAnimatables=0;for(let B=0;B<this._animatables.length;++B){const E=this._animatables[B];!this.mask||this.mask.disabled||this.mask.retainsTarget(E.target.name)?(this._numActiveAnimatables++,E.paused&&E.restart()):E.paused||E.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let B=0;B<this._animatables.length;++B){const E=this._animatables[B];this.mask.retainsTarget(E.target.name)||(E.stop(),this._animatables.splice(B,1),--B)}for(let B=0;B<this._targetedAnimations.length;B++){const E=this._targetedAnimations[B];this.mask.retainsTarget(E.target.name)||(this._targetedAnimations.splice(B,1),--B)}}}get from(){return this._from}set from(B){if(this._from!==B){this._from=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].fromFrame=this._from}}}get to(){return this._to}set to(B){if(this._to!==B){this._to=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(B){if(this._speedRatio!==B){this._speedRatio=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(B){if(this._loopAnimation!==B){this._loopAnimation=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(B){if(this._isAdditive!==B){this._isAdditive=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(B){this._weight!==B&&(this._weight=B,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(B){if(this._playOrder!==B&&(this._playOrder=B,this._animatables.length>0)){for(let B=0;B<this._animatables.length;B++)this._animatables[B].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(B){if(this._enableBlending!==B&&(this._enableBlending=B,null!==B))for(let E=0;E<this._targetedAnimations.length;++E)this._targetedAnimations[E].animation.enableBlending=B}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(B){if(this._blendingSpeed!==B&&(this._blendingSpeed=B,null!==B))for(let E=0;E<this._targetedAnimations.length;++E)this._targetedAnimations[E].animation.blendingSpeed=B}getLength(B,E){B=B??this._from;return((E=E??this._to)-B)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(B){let E=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],v=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=arguments.length>3?arguments[3]:void 0;if(0===B.length)return null;z=z??B[0].weight;let o=Number.MAX_VALUE,q=-Number.MAX_VALUE;if(v)for(const S of B)S.from<o&&(o=S.from),S.to>q&&(q=S.to);const c=new g(B[0].name+"_merged",B[0]._scene,z);for(const S of B){v&&S.normalize(o,q);for(const B of S.targetedAnimations)c.addTargetedAnimation(B.animation,B.target);E&&S.dispose()}return c}constructor(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=B,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new o.e,this.onAnimationLoopObservable=new o.e,this.onAnimationGroupLoopObservable=new o.e,this.onAnimationGroupEndObservable=new o.e,this.onAnimationGroupPauseObservable=new o.e,this.onAnimationGroupPlayObservable=new o.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=E||q.b.LastCreatedScene,this._weight=v,this._playOrder=z,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(B,E){const v=new m;v.animation=B,v.target=E;const z=B.getKeys();return this._from>z[0].frame&&(this._from=z[0].frame),this._to<z[z.length-1].frame&&(this._to=z[z.length-1].frame),null!==this._enableBlending&&(B.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(B.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(v),this._shouldStart=!0,v}removeTargetedAnimation(B){for(let E=this._targetedAnimations.length-1;E>-1;E--){this._targetedAnimations[E].animation===B&&this._targetedAnimations.splice(E,1)}}normalize(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==B&&(B=this._from),null==E&&(E=this._to);for(let v=0;v<this._targetedAnimations.length;v++){const z=this._targetedAnimations[v].animation.getKeys(),o=z[0],q=z[z.length-1];if(o.frame>B){const E={frame:B,value:o.value,inTangent:o.inTangent,outTangent:o.outTangent,interpolation:o.interpolation};z.splice(0,0,E)}if(q.frame<E){const B={frame:E,value:q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation};z.push(B)}}return this._from=B,this._to=E,this}_processLoop(B,E,v){B.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(E),this._animationLoopFlags[v]||(this._animationLoopFlags[v]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0],E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,v=arguments.length>2?arguments[2]:void 0,z=arguments.length>3?arguments[3]:void 0,o=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=B,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let q=0;q<this._targetedAnimations.length;q++){const c=this._targetedAnimations[q],S=this._scene.beginDirectAnimation(c.target,[c.animation],void 0!==v?v:this._from,void 0!==z?z:this._to,B,E,void 0,void 0,void 0!==o?o:this._isAdditive);S.weight=this._weight,S.playOrder=this._playOrder,S.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(c),this._checkAnimationGroupEnded(S)},this._processLoop(S,c,q),this._animatables.push(S)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=E,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let B=0;B<this._animatables.length;B++){this._animatables[B].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(B){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==B&&(this.loopAnimation=B),this.restart()):(this.stop(),this.start(B,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let B=0;B<this._animatables.length;B++){this._animatables[B].reset()}return this}restart(){if(!this._isStarted)return this;for(let B=0;B<this._animatables.length;B++){this._animatables[B].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const E=this._animatables.slice();for(let z=0;z<E.length;z++)E[z].stop(void 0,void 0,!0,B);let v=0;for(let z=0;z<this._scene._activeAnimatables.length;z++){const E=this._scene._activeAnimatables[z];E._runtimeAnimations.length>0?this._scene._activeAnimatables[v++]=E:B&&this._checkAnimationGroupEnded(E,B)}return this._scene._activeAnimatables.length=v,this._isStarted=!1,this}setWeightForAllAnimatables(B){for(let E=0;E<this._animatables.length;E++){this._animatables[E].weight=B}return this}syncAllAnimationsWith(B){for(let E=0;E<this._animatables.length;E++){this._animatables[E].syncWith(B)}return this}goToFrame(B){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let v=0;v<this._animatables.length;v++){this._animatables[v].goToFrame(B,E)}return this}getCurrentFrame(){var B;return(null===(B=this.animatables[0])||void 0===B?void 0:B.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const B=this._scene.animationGroups.indexOf(this);if(B>-1&&this._scene.animationGroups.splice(B,1),this._parentContainer){const B=this._parentContainer.animationGroups.indexOf(this);B>-1&&this._parentContainer.animationGroups.splice(B,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(B){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const v=this._animatables.indexOf(B);v>-1&&this._animatables.splice(v,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,E||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(B,E){let v=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const z=new g(B||this.name,this._scene,this._weight,this._playOrder);z._from=this.from,z._to=this.to,z._speedRatio=this.speedRatio,z._loopAnimation=this.loopAnimation,z._isAdditive=this.isAdditive,z._enableBlending=this.enableBlending,z._blendingSpeed=this.blendingSpeed,z.metadata=this.metadata,z.mask=this.mask;for(const o of this._targetedAnimations)z.addTargetedAnimation(v?o.animation.clone():o.animation,E?E(o.target):o.target);return z}serialize(){const B={};B.name=this.name,B.from=this.from,B.to=this.to,B.speedRatio=this.speedRatio,B.loopAnimation=this.loopAnimation,B.isAdditive=this.isAdditive,B.weight=this.weight,B.playOrder=this.playOrder,B.enableBlending=this.enableBlending,B.blendingSpeed=this.blendingSpeed,B.targetedAnimations=[];for(let E=0;E<this.targetedAnimations.length;E++){const v=this.targetedAnimations[E];B.targetedAnimations[E]=v.serialize()}return c.c&&c.c.HasTags(this)&&(B.tags=c.c.GetTags(this)),this.metadata&&(B.metadata=this.metadata),B}static Parse(B,E){const v=new g(B.name,E,B.weight,B.playOrder);for(let o=0;o<B.targetedAnimations.length;o++){const q=B.targetedAnimations[o],c=z.c.Parse(q.animation),S=q.targetId;if("influence"===q.animation.property){const B=E.getMorphTargetById(S);B&&v.addTargetedAnimation(c,B)}else{const B=E.getNodeById(S);null!=B&&v.addTargetedAnimation(c,B)}}return c.c&&c.c.AddTagsTo(v,B.tags),null!==B.from&&null!==B.to&&v.normalize(B.from,B.to),void 0!==B.speedRatio&&(v._speedRatio=B.speedRatio),void 0!==B.loopAnimation&&(v._loopAnimation=B.loopAnimation),void 0!==B.isAdditive&&(v._isAdditive=B.isAdditive),void 0!==B.weight&&(v._weight=B.weight),void 0!==B.playOrder&&(v._playOrder=B.playOrder),void 0!==B.enableBlending&&(v._enableBlending=B.enableBlending),void 0!==B.blendingSpeed&&(v._blendingSpeed=B.blendingSpeed),void 0!==B.metadata&&(v.metadata=B.metadata),v}static MakeAnimationAdditive(B,E,v){let o;o="object"===typeof E?E:{referenceFrame:E,range:v,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let q=B;o.cloneOriginalAnimationGroup&&(q=B.clone(o.clonedAnimationGroupName||q.name));const c=q.targetedAnimations;for(let S=0;S<c.length;S++){const B=c[S];B.animation=z.c.MakeAnimationAdditive(B.animation,o)}if(q.isAdditive=!0,o.clipKeys){let B=Number.MAX_VALUE,E=-Number.MAX_VALUE;const v=q.targetedAnimations;for(let z=0;z<v.length;z++){const o=v[z].animation.getKeys();B>o[0].frame&&(B=o[0].frame),E<o[o.length-1].frame&&(E=o[o.length-1].frame)}q._from=B,q._to=E}return q}static ClipKeys(B,E,v,z,o){const q=B.clone(z||B.name);return g.ClipKeysInPlace(q,E,v,o)}static ClipKeysInPlace(B,E,v,z){return g.ClipInPlace(B,E,v,z,!1)}static ClipFrames(B,E,v,z,o){const q=B.clone(z||B.name);return g.ClipFramesInPlace(q,E,v,o)}static ClipFramesInPlace(B,E,v,z){return g.ClipInPlace(B,E,v,z,!0)}static ClipInPlace(B,E,v,z){let o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],q=Number.MAX_VALUE,c=-Number.MAX_VALUE;const S=B.targetedAnimations;for(let x=0;x<S.length;x++){const B=S[x],D=z?B.animation:B.animation.clone();o&&(D.createKeyForFrame(E),D.createKeyForFrame(v));const h=D.getKeys(),y=[];let Q=Number.MAX_VALUE;for(let z=0;z<h.length;z++){const B=h[z];if(!o&&z>=E&&z<=v||o&&B.frame>=E&&B.frame<=v){const E={frame:B.frame,value:B.value.clone?B.value.clone():B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation,lockedTangent:B.lockedTangent};Q===Number.MAX_VALUE&&(Q=E.frame),E.frame-=Q,y.push(E)}}0!==y.length?(q>y[0].frame&&(q=y[0].frame),c<y[y.length-1].frame&&(c=y[y.length-1].frame),D.setKeys(y,!0),B.animation=D):(S.splice(x,1),x--)}return B._from=q,B._to=c,B}getClassName(){return"AnimationGroup"}toString(B){let E="Name: "+this.name;return E+=", type: "+this.getClassName(),B&&(E+=", from: "+this._from,E+=", to: "+this._to,E+=", isStarted: "+this._isStarted,E+=", speedRatio: "+this._speedRatio,E+=", targetedAnimations length: "+this._targetedAnimations.length,E+=", animatables length: "+this._animatables),E}}}}]);