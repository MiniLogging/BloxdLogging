"use strict";(self.ksd6jhs1yr=self.ksd6jhs1yr||[]).push([[78],{15563:(C,c,d)=>{d.r(c),d.d(c,{AnimationGroup:()=>t,TargetedAnimation:()=>B});var b=d(12924),X=d(12221),P=d(12255),V=d(12433),R=d(14056),p=d(12403);class j{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(C,c,d,X){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=c,this._target=C,this._scene=d,this._host=X,this._activeTargets=[],c._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===b.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=p.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const C={frame:0,value:this._minValue};this._keys.splice(0,0,C)}if(this._target instanceof Array){let C=0;for(const c of this._target)this._preparePath(c,C),this._getOriginalValues(C),C++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const P=c.getEvents();if(P&&P.length>0)for(const b of P)this._events.push(b._clone());this._enableBlending=C&&C.animationPropertiesOverride?C.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(C){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const d=this._animation.targetPropertyPath;if(d.length>1){let b=C;for(let C=0;C<d.length-1;C++){const c=d[C];if(b=b[c],void 0===b)throw new Error(`Invalid property (${c}) in property path (${d.join(".")})`)}this._targetPath=d[d.length-1],this._activeTargets[c]=b}else this._targetPath=d[0],this._activeTargets[c]=C;if(void 0===this._activeTargets[c][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${d.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let C=0;for(const c of this._target)void 0!==this._originalValue[C]&&this._setValue(c,this._activeTargets[C],this._originalValue[C],-1,C),C++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let C=0;C<this._events.length;C++)this._events[C].isDone=!1}isStopped(){return this._stopped}dispose(){const C=this._animation.runtimeAnimations.indexOf(this);C>-1&&this._animation.runtimeAnimations.splice(C,1)}setValue(C,c){if(this._targetIsArray)for(let d=0;d<this._target.length;d++){const b=this._target[d];this._setValue(b,this._activeTargets[d],C,c,d)}else this._setValue(this._target,this._directTarget,C,c,0)}_getOriginalValues(){let C,c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const d=this._activeTargets[c];C=d.getLocalMatrix&&"_matrix"===this._targetPath?d.getLocalMatrix():d[this._targetPath],C&&C.clone?this._originalValue[c]=C.clone():this._originalValue[c]=C}_registerTargetForLateAnimationBinding(C,c){const d=C.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(d),d._lateAnimationHolders||(d._lateAnimationHolders={}),d._lateAnimationHolders[C.targetPath]||(d._lateAnimationHolders[C.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:c}),C.isAdditive?(d._lateAnimationHolders[C.targetPath].additiveAnimations.push(C),d._lateAnimationHolders[C.targetPath].totalAdditiveWeight+=C.weight):(d._lateAnimationHolders[C.targetPath].animations.push(C),d._lateAnimationHolders[C.targetPath].totalWeight+=C.weight)}_setValue(C,c,d,X,P){if(this._currentActiveTarget=c,this._weight=X,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const C=c[this._targetPath];C.clone?this._originalBlendValue=C.clone():this._originalBlendValue=C}this._originalBlendValue.m?b.b.AllowMatrixDecomposeForInterpolation?this._currentValue?p.Matrix.DecomposeLerpToRef(this._originalBlendValue,d,this._blendingFactor,this._currentValue):this._currentValue=p.Matrix.DecomposeLerp(this._originalBlendValue,d,this._blendingFactor):this._currentValue?p.Matrix.LerpToRef(this._originalBlendValue,d,this._blendingFactor,this._currentValue):this._currentValue=p.Matrix.Lerp(this._originalBlendValue,d,this._blendingFactor):this._currentValue=b.b._UniversalLerp(this._originalBlendValue,d,this._blendingFactor);const X=C&&C.animationPropertiesOverride?C.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=X}else this._currentValue?this._currentValue.V?this._currentValue.V(d):this._currentValue=d:null!==d&&void 0!==d&&d.clone?this._currentValue=d.clone():this._currentValue=d;-1!==X?this._registerTargetForLateAnimationBinding(this,this._originalValue[P]):this._animationState.loopMode===b.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[P],c[this._targetPath]):c[this._targetPath]=this._originalValue[P]+this._currentValue:c[this._targetPath]=this._currentValue,C.Wk&&C.Wk(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(C){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const d=this._animation.getKeys();C<d[0].frame?C=d[0].frame:C>d[d.length-1].frame&&(C=d[d.length-1].frame);const b=this._events;if(b.length)for(let P=0;P<b.length;P++)b[P].onlyOnce||(b[P].isDone=b[P].frame<C);this._currentFrame=C;const X=this._animation._interpolate(C,this._animationState);this.setValue(X,c)}_prepareForSpeedRatioChange(C){const c=this._previousElapsedTime*(this._animation.framePerSecond*C)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-c}animate(C,c,d,X,P){let V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const R=this._animation,p=R.targetPropertyPath;if(!p||p.length<1)return this._stopped=!0,!1;let j,g=!0;const k=this._events;let Z=0;if(this._coreRuntimeAnimation)Z=d-c,j=this._coreRuntimeAnimation.currentFrame,this._currentFrame=j,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let V;(c<this._minFrame||c>this._maxFrame)&&(c=this._minFrame),(d<this._minFrame||d>this._maxFrame)&&(d=this._maxFrame),Z=d-c;let p=C*(R.framePerSecond*P)/1e3+this._absoluteFrameOffset,U=0,A=!1;const u=X&&this._animationState.loopMode===b.b.ANIMATIONLOOPMODE_YOYO;if(u){const C=(p-c)/Z,d=Math.sin(C*Math.PI);p=Math.abs(d)*Z+c;const b=d>=0?1:-1;this._yoyoDirection!==b&&(A=!0),this._yoyoDirection=b}if(this._previousElapsedTime=C,this._previousAbsoluteFrame=p,!X&&d>=c&&(p>=Z&&P>0||p<=0&&P<0))g=!1,U=R._getKeyValue(this._maxValue);else if(!X&&c>=d&&(p<=Z&&P<0||p>=0&&P>0))g=!1,U=R._getKeyValue(this._minValue);else if(this._animationState.loopMode!==b.b.ANIMATIONLOOPMODE_CYCLE){const C=d.toString()+c.toString();if(!this._offsetsCache[C]){this._animationState.repeatCount=0,this._animationState.loopMode=b.b.ANIMATIONLOOPMODE_CYCLE;const X=R._interpolate(c,this._animationState),P=R._interpolate(d,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),R.dataType){case b.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[C]=P-X;break;case b.b.ANIMATIONTYPE_QUATERNION:case b.b.ANIMATIONTYPE_VECTOR3:case b.b.ANIMATIONTYPE_VECTOR2:case b.b.ANIMATIONTYPE_SIZE:case b.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[C]=P.Xd(X)}this._highLimitsCache[C]=P}U=this._highLimitsCache[C],V=this._offsetsCache[C]}if(void 0===V)switch(R.dataType){case b.b.ANIMATIONTYPE_FLOAT:V=0;break;case b.b.ANIMATIONTYPE_QUATERNION:V=b.j;break;case b.b.ANIMATIONTYPE_VECTOR3:V=b.p;break;case b.b.ANIMATIONTYPE_VECTOR2:V=b.o;break;case b.b.ANIMATIONTYPE_SIZE:V=b.n;break;case b.b.ANIMATIONTYPE_COLOR3:V=b.e;break;case b.b.ANIMATIONTYPE_COLOR4:V=b.i}if(this._host&&this._host.syncRoot){const C=this._host.syncRoot;j=c+Z*((C.masterFrame-C.fromFrame)/(C.toFrame-C.fromFrame))}else j=p>0&&c>d||p<0&&c<d?g&&0!==Z?d+p%Z:c:g&&0!==Z?c+p%Z:d;if(!u&&(P>0&&this.currentFrame>j||P<0&&this.currentFrame<j)||u&&A){this._onLoop();for(let C=0;C<k.length;C++)k[C].onlyOnce||(k[C].isDone=!1);this._animationState.key=P>0?0:R.getKeys().length-1}this._currentFrame=j,this._animationState.repeatCount=0===Z?0:p/Z|0,this._animationState.highLimitValue=U,this._animationState.offsetValue=V}const U=R._interpolate(j,this._animationState);if(this.setValue(U,V),k.length)for(let b=0;b<k.length;b++)if(Z>=0&&j>=k[b].frame&&k[b].frame>=c||Z<0&&j<=k[b].frame&&k[b].frame<=c){const C=k[b];C.isDone||(C.onlyOnce&&(k.splice(b,1),b--),C.isDone=!0,C.action(j))}return g||(this._stopped=!0),g}}var g=d(12241);class k{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(C){this._weight=-1!==C?Math.min(Math.max(C,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(C){for(let c=0;c<this._runtimeAnimations.length;c++){this._runtimeAnimations[c]._prepareForSpeedRatioChange(C)}this._speedRatio=C,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(C,c){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,P=arguments.length>4&&void 0!==arguments[4]&&arguments[4],V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,R=arguments.length>6?arguments[6]:void 0,p=arguments.length>7?arguments[7]:void 0,j=arguments.length>8?arguments[8]:void 0,g=arguments.length>9&&void 0!==arguments[9]&&arguments[9],k=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=c,this.fromFrame=d,this.toFrame=b,this.loopAnimation=P,this.onAnimationEnd=R,this.onAnimationLoop=j,this.isAdditive=g,this.playOrder=k,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.lp=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new X.b,this.onAnimationLoopObservable=new X.b,this._scene=C,p&&this.appendAnimations(c,p),this._speedRatio=V,C._activeAnimatables.push(this)}syncWith(C){if(this._syncRoot=C,C){const C=this._scene._activeAnimatables.indexOf(this);C>-1&&(this._scene._activeAnimatables.splice(C,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(C,c){for(let d=0;d<c.length;d++){const b=c[d],X=new j(C,b,this._scene,this);X._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(X)}}getAnimationByTargetProperty(C){const c=this._runtimeAnimations;for(let d=0;d<c.length;d++)if(c[d].animation.targetProperty===C)return c[d].animation;return null}getRuntimeAnimationByTargetProperty(C){const c=this._runtimeAnimations;for(let d=0;d<c.length;d++)if(c[d].animation.targetProperty===C)return c[d];return null}reset(){const C=this._runtimeAnimations;for(let c=0;c<C.length;c++)C[c].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(C){const c=this._runtimeAnimations;for(let d=0;d<c.length;d++)c[d].animation.enableBlending=!0,c[d].animation.blendingSpeed=C}disableBlending(){const C=this._runtimeAnimations;for(let c=0;c<C.length;c++)C[c].animation.enableBlending=!1}goToFrame(C){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const d=this._runtimeAnimations;if(d[0]){const c=d[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??d[0].currentFrame;const b=0===this.speedRatio?0:(C-this._frameToSyncFromJump)/c*1e3/this.speedRatio;this._manualJumpDelay=-b}for(let b=0;b<d.length;b++)d[b].goToFrame(C,c?this._weight:-1);this._goToFrame=C}get paused(){return this.lp}pause(){this.lp||(this.lp=!0)}restart(){this.lp=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(C,c){let d=arguments.length>2&&void 0!==arguments[2]&&arguments[2],b=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(C||c){const X=this._scene._activeAnimatables.indexOf(this);if(X>-1){const P=this._runtimeAnimations;for(let d=P.length-1;d>=0;d--){const b=P[d];C&&b.animation.name!=C||(c&&!c(b.target)||(b.dispose(),P.splice(d,1)))}0==P.length&&(d||this._scene._activeAnimatables.splice(X,1),b||this._raiseOnAnimationEnd())}}else{const C=this._scene._activeAnimatables.indexOf(this);if(C>-1){d||this._scene._activeAnimatables.splice(C,1);const c=this._runtimeAnimations;for(let C=0;C<c.length;C++)c[C].dispose();this._runtimeAnimations.length=0,b||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((C=>{this.onAnimationEndObservable.add((()=>{C(this)}),void 0,void 0,this,!0)}))}_animate(C){if(this.lp)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=C),!0;if(null===this._localDelayOffset?(this._localDelayOffset=C,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=C-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let c=!1;const d=this._runtimeAnimations;let b;for(b=0;b<d.length;b++){const X=d[b].animate(C-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);c=c||X}if(this.animationStarted=c,!c){if(this.disposeOnEnd)for(b=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(b,1),b=0;b<d.length;b++)d[b].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return c}}function Z(C){if(0===C.totalWeight&&0===C.totalAdditiveWeight)return C.originalValue;let c=1;const d=p.TmpVectors.dd[0],b=p.TmpVectors.dd[1],X=p.TmpVectors.Quaternion[0];let P=0;const V=C.animations[0],R=C.originalValue;let j=1,g=!1;if(C.totalWeight<1)j=1-C.totalWeight,R.decompose(b,X,d);else{if(P=1,c=C.totalWeight,j=V.weight/c,1==j){if(!C.totalAdditiveWeight)return V.currentValue;g=!0}V.currentValue.decompose(b,X,d)}if(!g){b.scaleInPlace(j),d.scaleInPlace(j),X.scaleInPlace(j);for(let V=P;V<C.animations.length;V++){const P=C.animations[V];if(0===P.weight)continue;j=P.weight/c;const R=p.TmpVectors.dd[2],g=p.TmpVectors.dd[3],k=p.TmpVectors.Quaternion[1];P.currentValue.decompose(g,k,R),g.scaleAndAddToRef(j,b),k.scaleAndAddToRef(p.Quaternion.Dot(X,k)>0?j:-j,X),R.scaleAndAddToRef(j,d)}X.normalize()}for(let Z=0;Z<C.additiveAnimations.length;Z++){const c=C.additiveAnimations[Z];if(0===c.weight)continue;const P=p.TmpVectors.dd[2],V=p.TmpVectors.dd[3],R=p.TmpVectors.Quaternion[1];c.currentValue.decompose(V,R,P),V.multiplyToRef(b,V),p.dd.LerpToRef(b,V,c.weight,b),X.multiplyToRef(R,R),p.Quaternion.SlerpToRef(X,R,c.weight,X),P.scaleAndAddToRef(c.weight,d)}const k=V?V._animationState.workValue:p.TmpVectors.Matrix[0].clone();return p.Matrix.ComposeToRef(b,X,d,k),k}function U(C,c){if(0===C.totalWeight&&0===C.totalAdditiveWeight)return c;const d=C.animations[0],b=C.originalValue;let X=c;if(0===C.totalWeight&&C.totalAdditiveWeight>0)X.V(b);else if(1===C.animations.length){if(p.Quaternion.SlerpToRef(b,d.currentValue,Math.min(1,C.totalWeight),X),0===C.totalAdditiveWeight)return X}else if(C.animations.length>1){let d,P,V=1;if(C.totalWeight<1){const c=1-C.totalWeight;d=[],P=[],d.push(b),P.push(c)}else{if(2===C.animations.length&&(p.Quaternion.SlerpToRef(C.animations[0].currentValue,C.animations[1].currentValue,C.animations[1].weight/C.totalWeight,c),0===C.totalAdditiveWeight))return c;d=[],P=[],V=C.totalWeight}for(let c=0;c<C.animations.length;c++){const b=C.animations[c];d.push(b.currentValue),P.push(b.weight/V)}let R=0;for(let C=0;C<d.length;)C?(R+=P[C],p.Quaternion.SlerpToRef(X,d[C],P[C]/R,X),C++):(p.Quaternion.SlerpToRef(d[C],d[C+1],P[C+1]/(P[C]+P[C+1]),c),X=c,R=P[C]+P[C+1],C+=2)}for(let P=0;P<C.additiveAnimations.length;P++){const c=C.additiveAnimations[P];0!==c.weight&&(X.multiplyToRef(c.currentValue,p.TmpVectors.Quaternion[0]),p.Quaternion.SlerpToRef(X,p.TmpVectors.Quaternion[0],c.weight,X))}return X}var A,u,q=d(12637);A=q.e,(u=R.c)&&(u.prototype.copyAnimationRange=function(C,c,d){let X=arguments.length>3&&void 0!==arguments[3]&&arguments[3],P=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new b.b(this.name,"_matrix",C.animations[0].framePerSecond,b.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const V=C.animations[0].getRange(c);if(!V)return!1;const R=V.from,p=V.to,j=C.animations[0].getKeys(),g=C.length,k=C.getParent(),Z=this.getParent(),U=X&&k&&g&&this.length&&g!==this.length,A=U&&Z&&k?Z.length/k.length:1,u=X&&!Z&&P&&(1!==P.x||1!==P.y||1!==P.z),q=this.animations[0].getKeys();let B,t,e;for(let b=0,n=j.length;b<n;b++)B=j[b],B.frame>=R&&B.frame<=p&&(X?(e=B.value.clone(),U?(t=e.getTranslation(),e.setTranslation(t.scaleInPlace(A))):u&&P?(t=e.getTranslation(),e.setTranslation(t.multiplyInPlace(P))):e=B.value):e=B.value,q.push({frame:B.frame+d,value:e}));return this.animations[0].createRange(c,R+d,p+d),!0}),A&&(A.prototype._animate=function(C){if(!this.animationsEnabled)return;const c=g.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=c}this.deltaTime=void 0!==C?C:this.useConstantAnimationDeltaTime?16:(c-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=c;const d=this._activeAnimatables;if(0===d.length)return;this._animationTime+=this.deltaTime;const X=this._animationTime;for(let b=0;b<d.length;b++){const C=d[b];!C._animate(X)&&C.disposeOnEnd&&b--}!function(C){if(C._registeredForLateAnimationBindings.length){for(let c=0;c<C._registeredForLateAnimationBindings.length;c++){const d=C._registeredForLateAnimationBindings.data[c];for(const C in d._lateAnimationHolders){const c=d._lateAnimationHolders[C],X=c.animations[0],P=c.originalValue;if(void 0===P||null===P)continue;const V=b.b.AllowMatrixDecomposeForInterpolation&&P.m;let R=d[C];if(V)R=Z(c);else if(void 0!==P.w)R=U(c,R||p.Quaternion.Identity());else{let C=0,d=1;const V=X&&X._animationState.loopMode===b.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(c.totalWeight<1)R=V?P.clone?P.clone():P:X&&P.scale?P.scale(1-c.totalWeight):X?P*(1-c.totalWeight):P.clone?P.clone():P;else if(X){d=c.totalWeight;const b=X.weight/d;R=1!==b?X.currentValue.scale?X.currentValue.scale(b):X.currentValue*b:X.currentValue,V&&(R.addToRef?R.addToRef(P,R):R+=P),C=1}for(let b=C;b<c.animations.length;b++){const C=c.animations[b],X=C.weight/d;X&&(C.currentValue.scaleAndAddToRef?C.currentValue.scaleAndAddToRef(X,R):R+=C.currentValue*X)}for(let b=0;b<c.additiveAnimations.length;b++){const C=c.additiveAnimations[b],d=C.weight;d&&(C.currentValue.scaleAndAddToRef?C.currentValue.scaleAndAddToRef(d,R):R+=C.currentValue*d)}}d[C]=R}d._lateAnimationHolders={}}C._registeredForLateAnimationBindings.reset()}}(this)},A.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((C,c)=>C.playOrder-c.playOrder))},A.prototype.beginWeightedAnimation=function(C,c,d){let b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,X=arguments.length>4?arguments[4]:void 0,P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,V=arguments.length>6?arguments[6]:void 0,R=arguments.length>7?arguments[7]:void 0,p=arguments.length>8?arguments[8]:void 0,j=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const k=this.beginAnimation(C,c,d,X,P,V,R,!1,p,j,g);return k.weight=b,k},A.prototype.beginAnimation=function(C,c,d,b){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,P=arguments.length>5?arguments[5]:void 0,V=arguments.length>6?arguments[6]:void 0,R=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],p=arguments.length>8?arguments[8]:void 0,j=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(X<0){const C=c;c=d,d=C,X=-X}c>d&&(X=-X),R&&this.stopAnimation(C,void 0,p),V||(V=new k(this,C,c,d,b,X,P,void 0,j,g));const Z=!p||p(C);if(C.animations&&Z&&V.appendAnimations(C,C.animations),C.getAnimatables){const g=C.getAnimatables();for(let C=0;C<g.length;C++)this.beginAnimation(g[C],c,d,b,X,P,V,R,p,j)}return V.reset(),V},A.prototype.beginHierarchyAnimation=function(C,c,d,b,X){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,V=arguments.length>6?arguments[6]:void 0,R=arguments.length>7?arguments[7]:void 0,p=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],j=arguments.length>9?arguments[9]:void 0,g=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const k=C.getDescendants(c),Z=[];Z.push(this.beginAnimation(C,d,b,X,P,V,R,p,j,void 0,g));for(const U of k)Z.push(this.beginAnimation(U,d,b,X,P,V,R,p,j,void 0,g));return Z},A.prototype.beginDirectAnimation=function(C,c,d,b,X){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(P<0){const C=d;d=b,b=C,P=-P}return d>b&&(P=-P),new k(this,C,d,b,X,P,arguments.length>6?arguments[6]:void 0,c,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},A.prototype.beginDirectHierarchyAnimation=function(C,c,d,b,X,P,V,R,p){let j=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const g=C.getDescendants(c),k=[];k.push(this.beginDirectAnimation(C,d,b,X,P,V,R,p,j));for(const Z of g)k.push(this.beginDirectAnimation(Z,d,b,X,P,V,R,p,j));return k},A.prototype.getAnimatableByTarget=function(C){for(let c=0;c<this._activeAnimatables.length;c++)if(this._activeAnimatables[c].target===C)return this._activeAnimatables[c];return null},A.prototype.getAllAnimatablesByTarget=function(C){const c=[];for(let d=0;d<this._activeAnimatables.length;d++)this._activeAnimatables[d].target===C&&c.push(this._activeAnimatables[d]);return c},A.prototype.stopAnimation=function(C,c,d){const b=this.getAllAnimatablesByTarget(C);for(const X of b)X.stop(c,d)},A.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let C=0;C<this._activeAnimatables.length;C++)this._activeAnimatables[C].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const C of this.animationGroups)C.stop()});class B{getClassName(){return"TargetedAnimation"}serialize(){const C={};return C.animation=this.animation.serialize(),C.targetId=this.target.id,C}}class t{get mask(){return this._mask}set mask(C){this._mask!==C&&(this._mask=C,this.syncWithMask(!0))}syncWithMask(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||C){this._numActiveAnimatables=0;for(let C=0;C<this._animatables.length;++C){const c=this._animatables[C];!this.mask||this.mask.disabled||this.mask.retainsTarget(c.target.name)?(this._numActiveAnimatables++,c.paused&&c.restart()):c.paused||c.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let C=0;C<this._animatables.length;++C){const c=this._animatables[C];this.mask.retainsTarget(c.target.name)||(c.stop(),this._animatables.splice(C,1),--C)}for(let C=0;C<this._targetedAnimations.length;C++){const c=this._targetedAnimations[C];this.mask.retainsTarget(c.target.name)||(this._targetedAnimations.splice(C,1),--C)}}}get from(){return this._from}set from(C){if(this._from!==C){this._from=C;for(let C=0;C<this._animatables.length;C++){this._animatables[C].fromFrame=this._from}}}get to(){return this._to}set to(C){if(this._to!==C){this._to=C;for(let C=0;C<this._animatables.length;C++){this._animatables[C].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(C){if(this._speedRatio!==C){this._speedRatio=C;for(let C=0;C<this._animatables.length;C++){this._animatables[C].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(C){if(this._loopAnimation!==C){this._loopAnimation=C;for(let C=0;C<this._animatables.length;C++){this._animatables[C].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(C){if(this._isAdditive!==C){this._isAdditive=C;for(let C=0;C<this._animatables.length;C++){this._animatables[C].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(C){this._weight!==C&&(this._weight=C,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(C){if(this._playOrder!==C&&(this._playOrder=C,this._animatables.length>0)){for(let C=0;C<this._animatables.length;C++)this._animatables[C].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(C){if(this._enableBlending!==C&&(this._enableBlending=C,null!==C))for(let c=0;c<this._targetedAnimations.length;++c)this._targetedAnimations[c].animation.enableBlending=C}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(C){if(this._blendingSpeed!==C&&(this._blendingSpeed=C,null!==C))for(let c=0;c<this._targetedAnimations.length;++c)this._targetedAnimations[c].animation.blendingSpeed=C}getLength(C,c){C=C??this._from;return((c=c??this._to)-C)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(C){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],d=arguments.length>2&&void 0!==arguments[2]&&arguments[2],b=arguments.length>3?arguments[3]:void 0;if(0===C.length)return null;b=b??C[0].weight;let X=Number.MAX_VALUE,P=-Number.MAX_VALUE;if(d)for(const R of C)R.from<X&&(X=R.from),R.to>P&&(P=R.to);const V=new t(C[0].name+"_merged",C[0]._scene,b);for(const R of C){d&&R.normalize(X,P);for(const C of R.targetedAnimations)V.addTargetedAnimation(C.animation,C.target);c&&R.dispose()}return V}constructor(C){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=C,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new X.b,this.onAnimationLoopObservable=new X.b,this.onAnimationGroupLoopObservable=new X.b,this.onAnimationGroupEndObservable=new X.b,this.onAnimationGroupPauseObservable=new X.b,this.onAnimationGroupPlayObservable=new X.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=c||P.c.LastCreatedScene,this._weight=d,this._playOrder=b,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(C,c){const d=new B;d.animation=C,d.target=c;const b=C.getKeys();return this._from>b[0].frame&&(this._from=b[0].frame),this._to<b[b.length-1].frame&&(this._to=b[b.length-1].frame),null!==this._enableBlending&&(C.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(C.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(d),this._shouldStart=!0,d}removeTargetedAnimation(C){for(let c=this._targetedAnimations.length-1;c>-1;c--){this._targetedAnimations[c].animation===C&&this._targetedAnimations.splice(c,1)}}normalize(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==C&&(C=this._from),null==c&&(c=this._to);for(let d=0;d<this._targetedAnimations.length;d++){const b=this._targetedAnimations[d].animation.getKeys(),X=b[0],P=b[b.length-1];if(X.frame>C){const c={frame:C,value:X.value,inTangent:X.inTangent,outTangent:X.outTangent,interpolation:X.interpolation};b.splice(0,0,c)}if(P.frame<c){const C={frame:c,value:P.value,inTangent:P.inTangent,outTangent:P.outTangent,interpolation:P.interpolation};b.push(C)}}return this._from=C,this._to=c,this}_processLoop(C,c,d){C.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(c),this._animationLoopFlags[d]||(this._animationLoopFlags[d]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0],c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,d=arguments.length>2?arguments[2]:void 0,b=arguments.length>3?arguments[3]:void 0,X=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=C,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let P=0;P<this._targetedAnimations.length;P++){const V=this._targetedAnimations[P],R=this._scene.beginDirectAnimation(V.target,[V.animation],void 0!==d?d:this._from,void 0!==b?b:this._to,C,c,void 0,void 0,void 0!==X?X:this._isAdditive);R.weight=this._weight,R.playOrder=this._playOrder,R.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(V),this._checkAnimationGroupEnded(R)},this._processLoop(R,V,P),this._animatables.push(R)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=c,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let C=0;C<this._animatables.length;C++){this._animatables[C].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(C){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==C&&(this.loopAnimation=C),this.restart()):(this.stop(),this.start(C,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let C=0;C<this._animatables.length;C++){this._animatables[C].reset()}return this}restart(){if(!this._isStarted)return this;for(let C=0;C<this._animatables.length;C++){this._animatables[C].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const c=this._animatables.slice();for(let b=0;b<c.length;b++)c[b].stop(void 0,void 0,!0,C);let d=0;for(let b=0;b<this._scene._activeAnimatables.length;b++){const c=this._scene._activeAnimatables[b];c._runtimeAnimations.length>0?this._scene._activeAnimatables[d++]=c:C&&this._checkAnimationGroupEnded(c,C)}return this._scene._activeAnimatables.length=d,this._isStarted=!1,this}setWeightForAllAnimatables(C){for(let c=0;c<this._animatables.length;c++){this._animatables[c].weight=C}return this}syncAllAnimationsWith(C){for(let c=0;c<this._animatables.length;c++){this._animatables[c].syncWith(C)}return this}goToFrame(C){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let d=0;d<this._animatables.length;d++){this._animatables[d].goToFrame(C,c)}return this}getCurrentFrame(){var C;return(null===(C=this.animatables[0])||void 0===C?void 0:C.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const C=this._scene.animationGroups.indexOf(this);if(C>-1&&this._scene.animationGroups.splice(C,1),this._parentContainer){const C=this._parentContainer.animationGroups.indexOf(this);C>-1&&this._parentContainer.animationGroups.splice(C,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(C){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const d=this._animatables.indexOf(C);d>-1&&this._animatables.splice(d,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,c||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(C,c){let d=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const b=new t(C||this.name,this._scene,this._weight,this._playOrder);b._from=this.from,b._to=this.to,b._speedRatio=this.speedRatio,b._loopAnimation=this.loopAnimation,b._isAdditive=this.isAdditive,b._enableBlending=this.enableBlending,b._blendingSpeed=this.blendingSpeed,b.metadata=this.metadata,b.mask=this.mask;for(const X of this._targetedAnimations)b.addTargetedAnimation(d?X.animation.clone():X.animation,c?c(X.target):X.target);return b}serialize(){const C={};C.name=this.name,C.from=this.from,C.to=this.to,C.speedRatio=this.speedRatio,C.loopAnimation=this.loopAnimation,C.isAdditive=this.isAdditive,C.weight=this.weight,C.playOrder=this.playOrder,C.enableBlending=this.enableBlending,C.blendingSpeed=this.blendingSpeed,C.targetedAnimations=[];for(let c=0;c<this.targetedAnimations.length;c++){const d=this.targetedAnimations[c];C.targetedAnimations[c]=d.serialize()}return V.b&&V.b.HasTags(this)&&(C.tags=V.b.GetTags(this)),this.metadata&&(C.metadata=this.metadata),C}static Parse(C,c){const d=new t(C.name,c,C.weight,C.playOrder);for(let X=0;X<C.targetedAnimations.length;X++){const P=C.targetedAnimations[X],V=b.b.Parse(P.animation),R=P.targetId;if("influence"===P.animation.property){const C=c.getMorphTargetById(R);C&&d.addTargetedAnimation(V,C)}else{const C=c.getNodeById(R);null!=C&&d.addTargetedAnimation(V,C)}}return V.b&&V.b.AddTagsTo(d,C.tags),null!==C.from&&null!==C.to&&d.normalize(C.from,C.to),void 0!==C.speedRatio&&(d._speedRatio=C.speedRatio),void 0!==C.loopAnimation&&(d._loopAnimation=C.loopAnimation),void 0!==C.isAdditive&&(d._isAdditive=C.isAdditive),void 0!==C.weight&&(d._weight=C.weight),void 0!==C.playOrder&&(d._playOrder=C.playOrder),void 0!==C.enableBlending&&(d._enableBlending=C.enableBlending),void 0!==C.blendingSpeed&&(d._blendingSpeed=C.blendingSpeed),void 0!==C.metadata&&(d.metadata=C.metadata),d}static MakeAnimationAdditive(C,c,d){let X;X="object"===typeof c?c:{referenceFrame:c,range:d,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let P=C;X.cloneOriginalAnimationGroup&&(P=C.clone(X.clonedAnimationGroupName||P.name));const V=P.targetedAnimations;for(let R=0;R<V.length;R++){const C=V[R];C.animation=b.b.MakeAnimationAdditive(C.animation,X)}if(P.isAdditive=!0,X.clipKeys){let C=Number.MAX_VALUE,c=-Number.MAX_VALUE;const d=P.targetedAnimations;for(let b=0;b<d.length;b++){const X=d[b].animation.getKeys();C>X[0].frame&&(C=X[0].frame),c<X[X.length-1].frame&&(c=X[X.length-1].frame)}P._from=C,P._to=c}return P}static ClipKeys(C,c,d,b,X){const P=C.clone(b||C.name);return t.ClipKeysInPlace(P,c,d,X)}static ClipKeysInPlace(C,c,d,b){return t.ClipInPlace(C,c,d,b,!1)}static ClipFrames(C,c,d,b,X){const P=C.clone(b||C.name);return t.ClipFramesInPlace(P,c,d,X)}static ClipFramesInPlace(C,c,d,b){return t.ClipInPlace(C,c,d,b,!0)}static ClipInPlace(C,c,d,b){let X=arguments.length>4&&void 0!==arguments[4]&&arguments[4],P=Number.MAX_VALUE,V=-Number.MAX_VALUE;const R=C.targetedAnimations;for(let p=0;p<R.length;p++){const C=R[p],j=b?C.animation:C.animation.clone();X&&(j.createKeyForFrame(c),j.createKeyForFrame(d));const g=j.getKeys(),k=[];let Z=Number.MAX_VALUE;for(let b=0;b<g.length;b++){const C=g[b];if(!X&&b>=c&&b<=d||X&&C.frame>=c&&C.frame<=d){const c={frame:C.frame,value:C.value.clone?C.value.clone():C.value,inTangent:C.inTangent,outTangent:C.outTangent,interpolation:C.interpolation,lockedTangent:C.lockedTangent};Z===Number.MAX_VALUE&&(Z=c.frame),c.frame-=Z,k.push(c)}}0!==k.length?(P>k[0].frame&&(P=k[0].frame),V<k[k.length-1].frame&&(V=k[k.length-1].frame),j.setKeys(k,!0),C.animation=j):(R.splice(p,1),p--)}return C._from=P,C._to=V,C}getClassName(){return"AnimationGroup"}toString(C){let c="Name: "+this.name;return c+=", type: "+this.getClassName(),C&&(c+=", from: "+this._from,c+=", to: "+this._to,c+=", isStarted: "+this._isStarted,c+=", speedRatio: "+this._speedRatio,c+=", targetedAnimations length: "+this._targetedAnimations.length,c+=", animatables length: "+this._animatables),c}}}}]);