"use strict";(self["9d4d30r2sf"]=self["9d4d30r2sf"]||[]).push([[78],{15670:(o,v,V)=>{V.r(v),V.d(v,{AnimationGroup:()=>j,TargetedAnimation:()=>R});var g=V(13035),E=V(12297),I=V(12339),Q=V(12538),U=V(14170),n=V(12488);class O{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(o,v,V,E){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=v,this._target=o,this._scene=V,this._host=E,this._activeTargets=[],v._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===g.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=n.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const o={frame:0,value:this._minValue};this._keys.splice(0,0,o)}if(this._target instanceof Array){let o=0;for(const v of this._target)this._preparePath(v,o),this._getOriginalValues(o),o++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const I=v.getEvents();if(I&&I.length>0)for(const g of I)this._events.push(g._clone());this._enableBlending=o&&o.animationPropertiesOverride?o.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const V=this._animation.targetPropertyPath;if(V.length>1){let g=o;for(let o=0;o<V.length-1;o++){const v=V[o];if(g=g[v],void 0===g)throw new Error(`Invalid property (${v}) in property path (${V.join(".")})`)}this._targetPath=V[V.length-1],this._activeTargets[v]=g}else this._targetPath=V[0],this._activeTargets[v]=o;if(void 0===this._activeTargets[v][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${V.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let o=0;for(const v of this._target)void 0!==this._originalValue[o]&&this._setValue(v,this._activeTargets[o],this._originalValue[o],-1,o),o++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let o=0;o<this._events.length;o++)this._events[o].isDone=!1}isStopped(){return this._stopped}dispose(){const o=this._animation.runtimeAnimations.indexOf(this);o>-1&&this._animation.runtimeAnimations.splice(o,1)}setValue(o,v){if(this._targetIsArray)for(let V=0;V<this._target.length;V++){const g=this._target[V];this._setValue(g,this._activeTargets[V],o,v,V)}else this._setValue(this._target,this._directTarget,o,v,0)}_getOriginalValues(){let o,v=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const V=this._activeTargets[v];o=V.getLocalMatrix&&"_matrix"===this._targetPath?V.getLocalMatrix():V[this._targetPath],o&&o.clone?this._originalValue[v]=o.clone():this._originalValue[v]=o}_registerTargetForLateAnimationBinding(o,v){const V=o.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(V),V._lateAnimationHolders||(V._lateAnimationHolders={}),V._lateAnimationHolders[o.targetPath]||(V._lateAnimationHolders[o.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:v}),o.isAdditive?(V._lateAnimationHolders[o.targetPath].additiveAnimations.push(o),V._lateAnimationHolders[o.targetPath].totalAdditiveWeight+=o.weight):(V._lateAnimationHolders[o.targetPath].animations.push(o),V._lateAnimationHolders[o.targetPath].totalWeight+=o.weight)}_setValue(o,v,V,E,I){if(this._currentActiveTarget=v,this._weight=E,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const o=v[this._targetPath];o.clone?this._originalBlendValue=o.clone():this._originalBlendValue=o}this._originalBlendValue.m?g.b.AllowMatrixDecomposeForInterpolation?this._currentValue?n.Matrix.DecomposeLerpToRef(this._originalBlendValue,V,this._blendingFactor,this._currentValue):this._currentValue=n.Matrix.DecomposeLerp(this._originalBlendValue,V,this._blendingFactor):this._currentValue?n.Matrix.LerpToRef(this._originalBlendValue,V,this._blendingFactor,this._currentValue):this._currentValue=n.Matrix.Lerp(this._originalBlendValue,V,this._blendingFactor):this._currentValue=g.b._UniversalLerp(this._originalBlendValue,V,this._blendingFactor);const E=o&&o.animationPropertiesOverride?o.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=E}else this._currentValue?this._currentValue.U?this._currentValue.U(V):this._currentValue=V:null!==V&&void 0!==V&&V.clone?this._currentValue=V.clone():this._currentValue=V;-1!==E?this._registerTargetForLateAnimationBinding(this,this._originalValue[I]):this._animationState.loopMode===g.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[I],v[this._targetPath]):v[this._targetPath]=this._originalValue[I]+this._currentValue:v[this._targetPath]=this._currentValue,o.eO&&o.eO(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const V=this._animation.getKeys();o<V[0].frame?o=V[0].frame:o>V[V.length-1].frame&&(o=V[V.length-1].frame);const g=this._events;if(g.length)for(let I=0;I<g.length;I++)g[I].onlyOnce||(g[I].isDone=g[I].frame<o);this._currentFrame=o;const E=this._animation._interpolate(o,this._animationState);this.setValue(E,v)}_prepareForSpeedRatioChange(o){const v=this._previousElapsedTime*(this._animation.framePerSecond*o)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-v}animate(o,v,V,E,I){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const U=this._animation,n=U.targetPropertyPath;if(!n||n.length<1)return this._stopped=!0,!1;let O,h=!0;const x=this._events;let f=0;if(this._coreRuntimeAnimation)f=V-v,O=this._coreRuntimeAnimation.currentFrame,this._currentFrame=O,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let Q;(v<this._minFrame||v>this._maxFrame)&&(v=this._minFrame),(V<this._minFrame||V>this._maxFrame)&&(V=this._maxFrame),f=V-v;let n=o*(U.framePerSecond*I)/1e3+this._absoluteFrameOffset,l=0,S=!1;const T=E&&this._animationState.loopMode===g.b.ANIMATIONLOOPMODE_YOYO;if(T){const o=(n-v)/f,V=Math.sin(o*Math.PI);n=Math.abs(V)*f+v;const g=V>=0?1:-1;this._yoyoDirection!==g&&(S=!0),this._yoyoDirection=g}if(this._previousElapsedTime=o,this._previousAbsoluteFrame=n,!E&&V>=v&&(n>=f&&I>0||n<=0&&I<0))h=!1,l=U._getKeyValue(this._maxValue);else if(!E&&v>=V&&(n<=f&&I<0||n>=0&&I>0))h=!1,l=U._getKeyValue(this._minValue);else if(this._animationState.loopMode!==g.b.ANIMATIONLOOPMODE_CYCLE){const o=V.toString()+v.toString();if(!this._offsetsCache[o]){this._animationState.repeatCount=0,this._animationState.loopMode=g.b.ANIMATIONLOOPMODE_CYCLE;const E=U._interpolate(v,this._animationState),I=U._interpolate(V,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),U.dataType){case g.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[o]=I-E;break;case g.b.ANIMATIONTYPE_QUATERNION:case g.b.ANIMATIONTYPE_VECTOR3:case g.b.ANIMATIONTYPE_VECTOR2:case g.b.ANIMATIONTYPE_SIZE:case g.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[o]=I.Rv(E)}this._highLimitsCache[o]=I}l=this._highLimitsCache[o],Q=this._offsetsCache[o]}if(void 0===Q)switch(U.dataType){case g.b.ANIMATIONTYPE_FLOAT:Q=0;break;case g.b.ANIMATIONTYPE_QUATERNION:Q=g.f;break;case g.b.ANIMATIONTYPE_VECTOR3:Q=g.m;break;case g.b.ANIMATIONTYPE_VECTOR2:Q=g.k;break;case g.b.ANIMATIONTYPE_SIZE:Q=g.g;break;case g.b.ANIMATIONTYPE_COLOR3:Q=g.c;break;case g.b.ANIMATIONTYPE_COLOR4:Q=g.d}if(this._host&&this._host.syncRoot){const o=this._host.syncRoot;O=v+f*((o.masterFrame-o.fromFrame)/(o.toFrame-o.fromFrame))}else O=n>0&&v>V||n<0&&v<V?h&&0!==f?V+n%f:v:h&&0!==f?v+n%f:V;if(!T&&(I>0&&this.currentFrame>O||I<0&&this.currentFrame<O)||T&&S){this._onLoop();for(let o=0;o<x.length;o++)x[o].onlyOnce||(x[o].isDone=!1);this._animationState.key=I>0?0:U.getKeys().length-1}this._currentFrame=O,this._animationState.repeatCount=0===f?0:n/f|0,this._animationState.highLimitValue=l,this._animationState.offsetValue=Q}const l=U._interpolate(O,this._animationState);if(this.setValue(l,Q),x.length)for(let g=0;g<x.length;g++)if(f>=0&&O>=x[g].frame&&x[g].frame>=v||f<0&&O<=x[g].frame&&x[g].frame<=v){const o=x[g];o.isDone||(o.onlyOnce&&(x.splice(g,1),g--),o.isDone=!0,o.action(O))}return h||(this._stopped=!0),h}}var h=V(12321);class x{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(o){this._weight=-1!==o?Math.min(Math.max(o,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(o){for(let v=0;v<this._runtimeAnimations.length;v++){this._runtimeAnimations[v]._prepareForSpeedRatioChange(o)}this._speedRatio=o,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(o,v){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,I=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,U=arguments.length>6?arguments[6]:void 0,n=arguments.length>7?arguments[7]:void 0,O=arguments.length>8?arguments[8]:void 0,h=arguments.length>9&&void 0!==arguments[9]&&arguments[9],x=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=v,this.fromFrame=V,this.toFrame=g,this.loopAnimation=I,this.onAnimationEnd=U,this.onAnimationLoop=O,this.isAdditive=h,this.playOrder=x,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.fU=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new E.e,this.onAnimationLoopObservable=new E.e,this._scene=o,n&&this.appendAnimations(v,n),this._speedRatio=Q,o._activeAnimatables.push(this)}syncWith(o){if(this._syncRoot=o,o){const o=this._scene._activeAnimatables.indexOf(this);o>-1&&(this._scene._activeAnimatables.splice(o,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(o,v){for(let V=0;V<v.length;V++){const g=v[V],E=new O(o,g,this._scene,this);E._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(E)}}getAnimationByTargetProperty(o){const v=this._runtimeAnimations;for(let V=0;V<v.length;V++)if(v[V].animation.targetProperty===o)return v[V].animation;return null}getRuntimeAnimationByTargetProperty(o){const v=this._runtimeAnimations;for(let V=0;V<v.length;V++)if(v[V].animation.targetProperty===o)return v[V];return null}reset(){const o=this._runtimeAnimations;for(let v=0;v<o.length;v++)o[v].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(o){const v=this._runtimeAnimations;for(let V=0;V<v.length;V++)v[V].animation.enableBlending=!0,v[V].animation.blendingSpeed=o}disableBlending(){const o=this._runtimeAnimations;for(let v=0;v<o.length;v++)o[v].animation.enableBlending=!1}goToFrame(o){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const V=this._runtimeAnimations;if(V[0]){const v=V[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??V[0].currentFrame;const g=0===this.speedRatio?0:(o-this._frameToSyncFromJump)/v*1e3/this.speedRatio;this._manualJumpDelay=-g}for(let g=0;g<V.length;g++)V[g].goToFrame(o,v?this._weight:-1);this._goToFrame=o}get paused(){return this.fU}pause(){this.fU||(this.fU=!0)}restart(){this.fU=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(o,v){let V=arguments.length>2&&void 0!==arguments[2]&&arguments[2],g=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(o||v){const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){const I=this._runtimeAnimations;for(let V=I.length-1;V>=0;V--){const g=I[V];o&&g.animation.name!=o||(v&&!v(g.target)||(g.dispose(),I.splice(V,1)))}0==I.length&&(V||this._scene._activeAnimatables.splice(E,1),g||this._raiseOnAnimationEnd())}}else{const o=this._scene._activeAnimatables.indexOf(this);if(o>-1){V||this._scene._activeAnimatables.splice(o,1);const v=this._runtimeAnimations;for(let o=0;o<v.length;o++)v[o].dispose();this._runtimeAnimations.length=0,g||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((o=>{this.onAnimationEndObservable.add((()=>{o(this)}),void 0,void 0,this,!0)}))}_animate(o){if(this.fU)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=o),!0;if(null===this._localDelayOffset?(this._localDelayOffset=o,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=o-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let v=!1;const V=this._runtimeAnimations;let g;for(g=0;g<V.length;g++){const E=V[g].animate(o-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);v=v||E}if(this.animationStarted=v,!v){if(this.disposeOnEnd)for(g=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(g,1),g=0;g<V.length;g++)V[g].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return v}}function f(o){if(0===o.totalWeight&&0===o.totalAdditiveWeight)return o.originalValue;let v=1;const V=n.TmpVectors.cv[0],g=n.TmpVectors.cv[1],E=n.TmpVectors.Quaternion[0];let I=0;const Q=o.animations[0],U=o.originalValue;let O=1,h=!1;if(o.totalWeight<1)O=1-o.totalWeight,U.decompose(g,E,V);else{if(I=1,v=o.totalWeight,O=Q.weight/v,1==O){if(!o.totalAdditiveWeight)return Q.currentValue;h=!0}Q.currentValue.decompose(g,E,V)}if(!h){g.scaleInPlace(O),V.scaleInPlace(O),E.scaleInPlace(O);for(let Q=I;Q<o.animations.length;Q++){const I=o.animations[Q];if(0===I.weight)continue;O=I.weight/v;const U=n.TmpVectors.cv[2],h=n.TmpVectors.cv[3],x=n.TmpVectors.Quaternion[1];I.currentValue.decompose(h,x,U),h.scaleAndAddToRef(O,g),x.scaleAndAddToRef(n.Quaternion.Dot(E,x)>0?O:-O,E),U.scaleAndAddToRef(O,V)}E.normalize()}for(let f=0;f<o.additiveAnimations.length;f++){const v=o.additiveAnimations[f];if(0===v.weight)continue;const I=n.TmpVectors.cv[2],Q=n.TmpVectors.cv[3],U=n.TmpVectors.Quaternion[1];v.currentValue.decompose(Q,U,I),Q.multiplyToRef(g,Q),n.cv.LerpToRef(g,Q,v.weight,g),E.multiplyToRef(U,U),n.Quaternion.SlerpToRef(E,U,v.weight,E),I.scaleAndAddToRef(v.weight,V)}const x=Q?Q._animationState.workValue:n.TmpVectors.Matrix[0].clone();return n.Matrix.ComposeToRef(g,E,V,x),x}function l(o,v){if(0===o.totalWeight&&0===o.totalAdditiveWeight)return v;const V=o.animations[0],g=o.originalValue;let E=v;if(0===o.totalWeight&&o.totalAdditiveWeight>0)E.U(g);else if(1===o.animations.length){if(n.Quaternion.SlerpToRef(g,V.currentValue,Math.min(1,o.totalWeight),E),0===o.totalAdditiveWeight)return E}else if(o.animations.length>1){let V,I,Q=1;if(o.totalWeight<1){const v=1-o.totalWeight;V=[],I=[],V.push(g),I.push(v)}else{if(2===o.animations.length&&(n.Quaternion.SlerpToRef(o.animations[0].currentValue,o.animations[1].currentValue,o.animations[1].weight/o.totalWeight,v),0===o.totalAdditiveWeight))return v;V=[],I=[],Q=o.totalWeight}for(let v=0;v<o.animations.length;v++){const g=o.animations[v];V.push(g.currentValue),I.push(g.weight/Q)}let U=0;for(let o=0;o<V.length;)o?(U+=I[o],n.Quaternion.SlerpToRef(E,V[o],I[o]/U,E),o++):(n.Quaternion.SlerpToRef(V[o],V[o+1],I[o+1]/(I[o]+I[o+1]),v),E=v,U=I[o]+I[o+1],o+=2)}for(let I=0;I<o.additiveAnimations.length;I++){const v=o.additiveAnimations[I];0!==v.weight&&(E.multiplyToRef(v.currentValue,n.TmpVectors.Quaternion[0]),n.Quaternion.SlerpToRef(E,n.TmpVectors.Quaternion[0],v.weight,E))}return E}var S,T,c=V(12747);S=c.b,(T=U.e)&&(T.prototype.copyAnimationRange=function(o,v,V){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new g.b(this.name,"_matrix",o.animations[0].framePerSecond,g.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Q=o.animations[0].getRange(v);if(!Q)return!1;const U=Q.from,n=Q.to,O=o.animations[0].getKeys(),h=o.length,x=o.getParent(),f=this.getParent(),l=E&&x&&h&&this.length&&h!==this.length,S=l&&f&&x?f.length/x.length:1,T=E&&!f&&I&&(1!==I.x||1!==I.y||1!==I.z),c=this.animations[0].getKeys();let R,j,t;for(let g=0,s=O.length;g<s;g++)R=O[g],R.frame>=U&&R.frame<=n&&(E?(t=R.value.clone(),l?(j=t.getTranslation(),t.setTranslation(j.scaleInPlace(S))):T&&I?(j=t.getTranslation(),t.setTranslation(j.multiplyInPlace(I))):t=R.value):t=R.value,c.push({frame:R.frame+V,value:t}));return this.animations[0].createRange(v,U+V,n+V),!0}),S&&(S.prototype._animate=function(o){if(!this.animationsEnabled)return;const v=h.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=v}this.deltaTime=void 0!==o?o:this.useConstantAnimationDeltaTime?16:(v-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=v;const V=this._activeAnimatables;if(0===V.length)return;this._animationTime+=this.deltaTime;const E=this._animationTime;for(let g=0;g<V.length;g++){const o=V[g];!o._animate(E)&&o.disposeOnEnd&&g--}!function(o){if(o._registeredForLateAnimationBindings.length){for(let v=0;v<o._registeredForLateAnimationBindings.length;v++){const V=o._registeredForLateAnimationBindings.data[v];for(const o in V._lateAnimationHolders){const v=V._lateAnimationHolders[o],E=v.animations[0],I=v.originalValue;if(void 0===I||null===I)continue;const Q=g.b.AllowMatrixDecomposeForInterpolation&&I.m;let U=V[o];if(Q)U=f(v);else if(void 0!==I.w)U=l(v,U||n.Quaternion.Identity());else{let o=0,V=1;const Q=E&&E._animationState.loopMode===g.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(v.totalWeight<1)U=Q?I.clone?I.clone():I:E&&I.scale?I.scale(1-v.totalWeight):E?I*(1-v.totalWeight):I.clone?I.clone():I;else if(E){V=v.totalWeight;const g=E.weight/V;U=1!==g?E.currentValue.scale?E.currentValue.scale(g):E.currentValue*g:E.currentValue,Q&&(U.addToRef?U.addToRef(I,U):U+=I),o=1}for(let g=o;g<v.animations.length;g++){const o=v.animations[g],E=o.weight/V;E&&(o.currentValue.scaleAndAddToRef?o.currentValue.scaleAndAddToRef(E,U):U+=o.currentValue*E)}for(let g=0;g<v.additiveAnimations.length;g++){const o=v.additiveAnimations[g],V=o.weight;V&&(o.currentValue.scaleAndAddToRef?o.currentValue.scaleAndAddToRef(V,U):U+=o.currentValue*V)}}V[o]=U}V._lateAnimationHolders={}}o._registeredForLateAnimationBindings.reset()}}(this)},S.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((o,v)=>o.playOrder-v.playOrder))},S.prototype.beginWeightedAnimation=function(o,v,V){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,E=arguments.length>4?arguments[4]:void 0,I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Q=arguments.length>6?arguments[6]:void 0,U=arguments.length>7?arguments[7]:void 0,n=arguments.length>8?arguments[8]:void 0,O=arguments.length>9?arguments[9]:void 0,h=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const x=this.beginAnimation(o,v,V,E,I,Q,U,!1,n,O,h);return x.weight=g,x},S.prototype.beginAnimation=function(o,v,V,g){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,I=arguments.length>5?arguments[5]:void 0,Q=arguments.length>6?arguments[6]:void 0,U=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],n=arguments.length>8?arguments[8]:void 0,O=arguments.length>9?arguments[9]:void 0,h=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(E<0){const o=v;v=V,V=o,E=-E}v>V&&(E=-E),U&&this.stopAnimation(o,void 0,n),Q||(Q=new x(this,o,v,V,g,E,I,void 0,O,h));const f=!n||n(o);if(o.animations&&f&&Q.appendAnimations(o,o.animations),o.getAnimatables){const h=o.getAnimatables();for(let o=0;o<h.length;o++)this.beginAnimation(h[o],v,V,g,E,I,Q,U,n,O)}return Q.reset(),Q},S.prototype.beginHierarchyAnimation=function(o,v,V,g,E){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Q=arguments.length>6?arguments[6]:void 0,U=arguments.length>7?arguments[7]:void 0,n=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],O=arguments.length>9?arguments[9]:void 0,h=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const x=o.getDescendants(v),f=[];f.push(this.beginAnimation(o,V,g,E,I,Q,U,n,O,void 0,h));for(const l of x)f.push(this.beginAnimation(l,V,g,E,I,Q,U,n,O,void 0,h));return f},S.prototype.beginDirectAnimation=function(o,v,V,g,E){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(I<0){const o=V;V=g,g=o,I=-I}return V>g&&(I=-I),new x(this,o,V,g,E,I,arguments.length>6?arguments[6]:void 0,v,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},S.prototype.beginDirectHierarchyAnimation=function(o,v,V,g,E,I,Q,U,n){let O=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const h=o.getDescendants(v),x=[];x.push(this.beginDirectAnimation(o,V,g,E,I,Q,U,n,O));for(const f of h)x.push(this.beginDirectAnimation(f,V,g,E,I,Q,U,n,O));return x},S.prototype.getAnimatableByTarget=function(o){for(let v=0;v<this._activeAnimatables.length;v++)if(this._activeAnimatables[v].target===o)return this._activeAnimatables[v];return null},S.prototype.getAllAnimatablesByTarget=function(o){const v=[];for(let V=0;V<this._activeAnimatables.length;V++)this._activeAnimatables[V].target===o&&v.push(this._activeAnimatables[V]);return v},S.prototype.stopAnimation=function(o,v,V){const g=this.getAllAnimatablesByTarget(o);for(const E of g)E.stop(v,V)},S.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let o=0;o<this._activeAnimatables.length;o++)this._activeAnimatables[o].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const o of this.animationGroups)o.stop()});class R{getClassName(){return"TargetedAnimation"}serialize(){const o={};return o.animation=this.animation.serialize(),o.targetId=this.target.id,o}}class j{get mask(){return this._mask}set mask(o){this._mask!==o&&(this._mask=o,this.syncWithMask(!0))}syncWithMask(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||o){this._numActiveAnimatables=0;for(let o=0;o<this._animatables.length;++o){const v=this._animatables[o];!this.mask||this.mask.disabled||this.mask.retainsTarget(v.target.name)?(this._numActiveAnimatables++,v.paused&&v.restart()):v.paused||v.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let o=0;o<this._animatables.length;++o){const v=this._animatables[o];this.mask.retainsTarget(v.target.name)||(v.stop(),this._animatables.splice(o,1),--o)}for(let o=0;o<this._targetedAnimations.length;o++){const v=this._targetedAnimations[o];this.mask.retainsTarget(v.target.name)||(this._targetedAnimations.splice(o,1),--o)}}}get from(){return this._from}set from(o){if(this._from!==o){this._from=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].fromFrame=this._from}}}get to(){return this._to}set to(o){if(this._to!==o){this._to=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(o){if(this._speedRatio!==o){this._speedRatio=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(o){if(this._loopAnimation!==o){this._loopAnimation=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(o){if(this._isAdditive!==o){this._isAdditive=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(o){this._weight!==o&&(this._weight=o,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(o){if(this._playOrder!==o&&(this._playOrder=o,this._animatables.length>0)){for(let o=0;o<this._animatables.length;o++)this._animatables[o].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(o){if(this._enableBlending!==o&&(this._enableBlending=o,null!==o))for(let v=0;v<this._targetedAnimations.length;++v)this._targetedAnimations[v].animation.enableBlending=o}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(o){if(this._blendingSpeed!==o&&(this._blendingSpeed=o,null!==o))for(let v=0;v<this._targetedAnimations.length;++v)this._targetedAnimations[v].animation.blendingSpeed=o}getLength(o,v){o=o??this._from;return((v=v??this._to)-o)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(o){let v=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2],g=arguments.length>3?arguments[3]:void 0;if(0===o.length)return null;g=g??o[0].weight;let E=Number.MAX_VALUE,I=-Number.MAX_VALUE;if(V)for(const U of o)U.from<E&&(E=U.from),U.to>I&&(I=U.to);const Q=new j(o[0].name+"_merged",o[0]._scene,g);for(const U of o){V&&U.normalize(E,I);for(const o of U.targetedAnimations)Q.addTargetedAnimation(o.animation,o.target);v&&U.dispose()}return Q}constructor(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=o,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new E.e,this.onAnimationLoopObservable=new E.e,this.onAnimationGroupLoopObservable=new E.e,this.onAnimationGroupEndObservable=new E.e,this.onAnimationGroupPauseObservable=new E.e,this.onAnimationGroupPlayObservable=new E.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=v||I.d.LastCreatedScene,this._weight=V,this._playOrder=g,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(o,v){const V=new R;V.animation=o,V.target=v;const g=o.getKeys();return this._from>g[0].frame&&(this._from=g[0].frame),this._to<g[g.length-1].frame&&(this._to=g[g.length-1].frame),null!==this._enableBlending&&(o.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(o.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(V),this._shouldStart=!0,V}removeTargetedAnimation(o){for(let v=this._targetedAnimations.length-1;v>-1;v--){this._targetedAnimations[v].animation===o&&this._targetedAnimations.splice(v,1)}}normalize(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==o&&(o=this._from),null==v&&(v=this._to);for(let V=0;V<this._targetedAnimations.length;V++){const g=this._targetedAnimations[V].animation.getKeys(),E=g[0],I=g[g.length-1];if(E.frame>o){const v={frame:o,value:E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation};g.splice(0,0,v)}if(I.frame<v){const o={frame:v,value:I.value,inTangent:I.inTangent,outTangent:I.outTangent,interpolation:I.interpolation};g.push(o)}}return this._from=o,this._to=v,this}_processLoop(o,v,V){o.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(v),this._animationLoopFlags[V]||(this._animationLoopFlags[V]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0],v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0,g=arguments.length>3?arguments[3]:void 0,E=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=o,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let I=0;I<this._targetedAnimations.length;I++){const Q=this._targetedAnimations[I],U=this._scene.beginDirectAnimation(Q.target,[Q.animation],void 0!==V?V:this._from,void 0!==g?g:this._to,o,v,void 0,void 0,void 0!==E?E:this._isAdditive);U.weight=this._weight,U.playOrder=this._playOrder,U.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Q),this._checkAnimationGroupEnded(U)},this._processLoop(U,Q,I),this._animatables.push(U)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=v,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let o=0;o<this._animatables.length;o++){this._animatables[o].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(o){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==o&&(this.loopAnimation=o),this.restart()):(this.stop(),this.start(o,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let o=0;o<this._animatables.length;o++){this._animatables[o].reset()}return this}restart(){if(!this._isStarted)return this;for(let o=0;o<this._animatables.length;o++){this._animatables[o].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const v=this._animatables.slice();for(let g=0;g<v.length;g++)v[g].stop(void 0,void 0,!0,o);let V=0;for(let g=0;g<this._scene._activeAnimatables.length;g++){const v=this._scene._activeAnimatables[g];v._runtimeAnimations.length>0?this._scene._activeAnimatables[V++]=v:o&&this._checkAnimationGroupEnded(v,o)}return this._scene._activeAnimatables.length=V,this._isStarted=!1,this}setWeightForAllAnimatables(o){for(let v=0;v<this._animatables.length;v++){this._animatables[v].weight=o}return this}syncAllAnimationsWith(o){for(let v=0;v<this._animatables.length;v++){this._animatables[v].syncWith(o)}return this}goToFrame(o){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let V=0;V<this._animatables.length;V++){this._animatables[V].goToFrame(o,v)}return this}getCurrentFrame(){var o;return(null===(o=this.animatables[0])||void 0===o?void 0:o.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const o=this._scene.animationGroups.indexOf(this);if(o>-1&&this._scene.animationGroups.splice(o,1),this._parentContainer){const o=this._parentContainer.animationGroups.indexOf(this);o>-1&&this._parentContainer.animationGroups.splice(o,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(o){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const V=this._animatables.indexOf(o);V>-1&&this._animatables.splice(V,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,v||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(o,v){let V=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const g=new j(o||this.name,this._scene,this._weight,this._playOrder);g._from=this.from,g._to=this.to,g._speedRatio=this.speedRatio,g._loopAnimation=this.loopAnimation,g._isAdditive=this.isAdditive,g._enableBlending=this.enableBlending,g._blendingSpeed=this.blendingSpeed,g.metadata=this.metadata,g.mask=this.mask;for(const E of this._targetedAnimations)g.addTargetedAnimation(V?E.animation.clone():E.animation,v?v(E.target):E.target);return g}serialize(){const o={};o.name=this.name,o.from=this.from,o.to=this.to,o.speedRatio=this.speedRatio,o.loopAnimation=this.loopAnimation,o.isAdditive=this.isAdditive,o.weight=this.weight,o.playOrder=this.playOrder,o.enableBlending=this.enableBlending,o.blendingSpeed=this.blendingSpeed,o.targetedAnimations=[];for(let v=0;v<this.targetedAnimations.length;v++){const V=this.targetedAnimations[v];o.targetedAnimations[v]=V.serialize()}return Q.e&&Q.e.HasTags(this)&&(o.tags=Q.e.GetTags(this)),this.metadata&&(o.metadata=this.metadata),o}static Parse(o,v){const V=new j(o.name,v,o.weight,o.playOrder);for(let E=0;E<o.targetedAnimations.length;E++){const I=o.targetedAnimations[E],Q=g.b.Parse(I.animation),U=I.targetId;if("influence"===I.animation.property){const o=v.getMorphTargetById(U);o&&V.addTargetedAnimation(Q,o)}else{const o=v.getNodeById(U);null!=o&&V.addTargetedAnimation(Q,o)}}return Q.e&&Q.e.AddTagsTo(V,o.tags),null!==o.from&&null!==o.to&&V.normalize(o.from,o.to),void 0!==o.speedRatio&&(V._speedRatio=o.speedRatio),void 0!==o.loopAnimation&&(V._loopAnimation=o.loopAnimation),void 0!==o.isAdditive&&(V._isAdditive=o.isAdditive),void 0!==o.weight&&(V._weight=o.weight),void 0!==o.playOrder&&(V._playOrder=o.playOrder),void 0!==o.enableBlending&&(V._enableBlending=o.enableBlending),void 0!==o.blendingSpeed&&(V._blendingSpeed=o.blendingSpeed),void 0!==o.metadata&&(V.metadata=o.metadata),V}static MakeAnimationAdditive(o,v,V){let E;E="object"===typeof v?v:{referenceFrame:v,range:V,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let I=o;E.cloneOriginalAnimationGroup&&(I=o.clone(E.clonedAnimationGroupName||I.name));const Q=I.targetedAnimations;for(let U=0;U<Q.length;U++){const o=Q[U];o.animation=g.b.MakeAnimationAdditive(o.animation,E)}if(I.isAdditive=!0,E.clipKeys){let o=Number.MAX_VALUE,v=-Number.MAX_VALUE;const V=I.targetedAnimations;for(let g=0;g<V.length;g++){const E=V[g].animation.getKeys();o>E[0].frame&&(o=E[0].frame),v<E[E.length-1].frame&&(v=E[E.length-1].frame)}I._from=o,I._to=v}return I}static ClipKeys(o,v,V,g,E){const I=o.clone(g||o.name);return j.ClipKeysInPlace(I,v,V,E)}static ClipKeysInPlace(o,v,V,g){return j.ClipInPlace(o,v,V,g,!1)}static ClipFrames(o,v,V,g,E){const I=o.clone(g||o.name);return j.ClipFramesInPlace(I,v,V,E)}static ClipFramesInPlace(o,v,V,g){return j.ClipInPlace(o,v,V,g,!0)}static ClipInPlace(o,v,V,g){let E=arguments.length>4&&void 0!==arguments[4]&&arguments[4],I=Number.MAX_VALUE,Q=-Number.MAX_VALUE;const U=o.targetedAnimations;for(let n=0;n<U.length;n++){const o=U[n],O=g?o.animation:o.animation.clone();E&&(O.createKeyForFrame(v),O.createKeyForFrame(V));const h=O.getKeys(),x=[];let f=Number.MAX_VALUE;for(let g=0;g<h.length;g++){const o=h[g];if(!E&&g>=v&&g<=V||E&&o.frame>=v&&o.frame<=V){const v={frame:o.frame,value:o.value.clone?o.value.clone():o.value,inTangent:o.inTangent,outTangent:o.outTangent,interpolation:o.interpolation,lockedTangent:o.lockedTangent};f===Number.MAX_VALUE&&(f=v.frame),v.frame-=f,x.push(v)}}0!==x.length?(I>x[0].frame&&(I=x[0].frame),Q<x[x.length-1].frame&&(Q=x[x.length-1].frame),O.setKeys(x,!0),o.animation=O):(U.splice(n,1),n--)}return o._from=I,o._to=Q,o}getClassName(){return"AnimationGroup"}toString(o){let v="Name: "+this.name;return v+=", type: "+this.getClassName(),o&&(v+=", from: "+this._from,v+=", to: "+this._to,v+=", isStarted: "+this._isStarted,v+=", speedRatio: "+this._speedRatio,v+=", targetedAnimations length: "+this._targetedAnimations.length,v+=", animatables length: "+this._animatables),v}}}}]);