"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[78],{15547:(M,Z,P)=>{P.r(Z),P.d(Z,{AnimationGroup:()=>u,TargetedAnimation:()=>L});var x=P(12890),c=P(12184),w=P(12225),v=P(12398),G=P(13995),mM=P(12373);class K{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(M,Z,P,c){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=Z,this._target=M,this._scene=P,this._host=c,this._activeTargets=[],Z._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===x.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=mM.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const M={frame:0,value:this._minValue};this._keys.splice(0,0,M)}if(this._target instanceof Array){let M=0;for(const Z of this._target)this._preparePath(Z,M),this._getOriginalValues(M),M++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const w=Z.getEvents();if(w&&w.length>0)for(const x of w)this._events.push(x._clone());this._enableBlending=M&&M.animationPropertiesOverride?M.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=this._animation.targetPropertyPath;if(P.length>1){let x=M;for(let M=0;M<P.length-1;M++){const Z=P[M];if(x=x[Z],void 0===x)throw new Error(`Invalid property (${Z}) in property path (${P.join(".")})`)}this._targetPath=P[P.length-1],this._activeTargets[Z]=x}else this._targetPath=P[0],this._activeTargets[Z]=M;if(void 0===this._activeTargets[Z][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${P.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let M=0;for(const Z of this._target)void 0!==this._originalValue[M]&&this._setValue(Z,this._activeTargets[M],this._originalValue[M],-1,M),M++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let M=0;M<this._events.length;M++)this._events[M].isDone=!1}isStopped(){return this._stopped}dispose(){const M=this._animation.runtimeAnimations.indexOf(this);M>-1&&this._animation.runtimeAnimations.splice(M,1)}setValue(M,Z){if(this._targetIsArray)for(let P=0;P<this._target.length;P++){const x=this._target[P];this._setValue(x,this._activeTargets[P],M,Z,P)}else this._setValue(this._target,this._directTarget,M,Z,0)}_getOriginalValues(){let M,Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const P=this._activeTargets[Z];M=P.getLocalMatrix&&"_matrix"===this._targetPath?P.getLocalMatrix():P[this._targetPath],M&&M.clone?this._originalValue[Z]=M.clone():this._originalValue[Z]=M}_registerTargetForLateAnimationBinding(M,Z){const P=M.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(P),P._lateAnimationHolders||(P._lateAnimationHolders={}),P._lateAnimationHolders[M.targetPath]||(P._lateAnimationHolders[M.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:Z}),M.isAdditive?(P._lateAnimationHolders[M.targetPath].additiveAnimations.push(M),P._lateAnimationHolders[M.targetPath].totalAdditiveWeight+=M.weight):(P._lateAnimationHolders[M.targetPath].animations.push(M),P._lateAnimationHolders[M.targetPath].totalWeight+=M.weight)}_setValue(M,Z,P,c,w){if(this._currentActiveTarget=Z,this._weight=c,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const M=Z[this._targetPath];M.clone?this._originalBlendValue=M.clone():this._originalBlendValue=M}this._originalBlendValue.m?x.d.AllowMatrixDecomposeForInterpolation?this._currentValue?mM.Matrix.DecomposeLerpToRef(this._originalBlendValue,P,this._blendingFactor,this._currentValue):this._currentValue=mM.Matrix.DecomposeLerp(this._originalBlendValue,P,this._blendingFactor):this._currentValue?mM.Matrix.LerpToRef(this._originalBlendValue,P,this._blendingFactor,this._currentValue):this._currentValue=mM.Matrix.Lerp(this._originalBlendValue,P,this._blendingFactor):this._currentValue=x.d._UniversalLerp(this._originalBlendValue,P,this._blendingFactor);const c=M&&M.animationPropertiesOverride?M.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=c}else this._currentValue?this._currentValue.v?this._currentValue.v(P):this._currentValue=P:null!==P&&void 0!==P&&P.clone?this._currentValue=P.clone():this._currentValue=P;-1!==c?this._registerTargetForLateAnimationBinding(this,this._originalValue[w]):this._animationState.loopMode===x.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[w],Z[this._targetPath]):Z[this._targetPath]=this._originalValue[w]+this._currentValue:Z[this._targetPath]=this._currentValue,M.Ad&&M.Ad(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const P=this._animation.getKeys();M<P[0].frame?M=P[0].frame:M>P[P.length-1].frame&&(M=P[P.length-1].frame);const x=this._events;if(x.length)for(let w=0;w<x.length;w++)x[w].onlyOnce||(x[w].isDone=x[w].frame<M);this._currentFrame=M;const c=this._animation._interpolate(M,this._animationState);this.setValue(c,Z)}_prepareForSpeedRatioChange(M){const Z=this._previousElapsedTime*(this._animation.framePerSecond*M)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-Z}animate(M,Z,P,c,w){let v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const G=this._animation,mM=G.targetPropertyPath;if(!mM||mM.length<1)return this._stopped=!0,!1;let K,d=!0;const O=this._events;let H=0;if(this._coreRuntimeAnimation)H=P-Z,K=this._coreRuntimeAnimation.currentFrame,this._currentFrame=K,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let v;(Z<this._minFrame||Z>this._maxFrame)&&(Z=this._minFrame),(P<this._minFrame||P>this._maxFrame)&&(P=this._maxFrame),H=P-Z;let mM=M*(G.framePerSecond*w)/1e3+this._absoluteFrameOffset,j=0,B=!1;const U=c&&this._animationState.loopMode===x.d.ANIMATIONLOOPMODE_YOYO;if(U){const M=(mM-Z)/H,P=Math.sin(M*Math.PI);mM=Math.abs(P)*H+Z;const x=P>=0?1:-1;this._yoyoDirection!==x&&(B=!0),this._yoyoDirection=x}if(this._previousElapsedTime=M,this._previousAbsoluteFrame=mM,!c&&P>=Z&&(mM>=H&&w>0||mM<=0&&w<0))d=!1,j=G._getKeyValue(this._maxValue);else if(!c&&Z>=P&&(mM<=H&&w<0||mM>=0&&w>0))d=!1,j=G._getKeyValue(this._minValue);else if(this._animationState.loopMode!==x.d.ANIMATIONLOOPMODE_CYCLE){const M=P.toString()+Z.toString();if(!this._offsetsCache[M]){this._animationState.repeatCount=0,this._animationState.loopMode=x.d.ANIMATIONLOOPMODE_CYCLE;const c=G._interpolate(Z,this._animationState),w=G._interpolate(P,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),G.dataType){case x.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[M]=w-c;break;case x.d.ANIMATIONTYPE_QUATERNION:case x.d.ANIMATIONTYPE_VECTOR3:case x.d.ANIMATIONTYPE_VECTOR2:case x.d.ANIMATIONTYPE_SIZE:case x.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[M]=w.UZ(c)}this._highLimitsCache[M]=w}j=this._highLimitsCache[M],v=this._offsetsCache[M]}if(void 0===v)switch(G.dataType){case x.d.ANIMATIONTYPE_FLOAT:v=0;break;case x.d.ANIMATIONTYPE_QUATERNION:v=x.n;break;case x.d.ANIMATIONTYPE_VECTOR3:v=x.w;break;case x.d.ANIMATIONTYPE_VECTOR2:v=x.s;break;case x.d.ANIMATIONTYPE_SIZE:v=x.q;break;case x.d.ANIMATIONTYPE_COLOR3:v=x.g;break;case x.d.ANIMATIONTYPE_COLOR4:v=x.j}if(this._host&&this._host.syncRoot){const M=this._host.syncRoot;K=Z+H*((M.masterFrame-M.fromFrame)/(M.toFrame-M.fromFrame))}else K=mM>0&&Z>P||mM<0&&Z<P?d&&0!==H?P+mM%H:Z:d&&0!==H?Z+mM%H:P;if(!U&&(w>0&&this.currentFrame>K||w<0&&this.currentFrame<K)||U&&B){this._onLoop();for(let M=0;M<O.length;M++)O[M].onlyOnce||(O[M].isDone=!1);this._animationState.key=w>0?0:G.getKeys().length-1}this._currentFrame=K,this._animationState.repeatCount=0===H?0:mM/H|0,this._animationState.highLimitValue=j,this._animationState.offsetValue=v}const j=G._interpolate(K,this._animationState);if(this.setValue(j,v),O.length)for(let x=0;x<O.length;x++)if(H>=0&&K>=O[x].frame&&O[x].frame>=Z||H<0&&K<=O[x].frame&&O[x].frame<=Z){const M=O[x];M.isDone||(M.onlyOnce&&(O.splice(x,1),x--),M.isDone=!0,M.action(K))}return d||(this._stopped=!0),d}}var d=P(12209);class O{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(M){this._weight=-1!==M?Math.min(Math.max(M,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(M){for(let Z=0;Z<this._runtimeAnimations.length;Z++){this._runtimeAnimations[Z]._prepareForSpeedRatioChange(M)}this._speedRatio=M,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,w=arguments.length>4&&void 0!==arguments[4]&&arguments[4],v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,G=arguments.length>6?arguments[6]:void 0,mM=arguments.length>7?arguments[7]:void 0,K=arguments.length>8?arguments[8]:void 0,d=arguments.length>9&&void 0!==arguments[9]&&arguments[9],O=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=Z,this.fromFrame=P,this.toFrame=x,this.loopAnimation=w,this.onAnimationEnd=G,this.onAnimationLoop=K,this.isAdditive=d,this.playOrder=O,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Zm=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new c.b,this.onAnimationLoopObservable=new c.b,this._scene=M,mM&&this.appendAnimations(Z,mM),this._speedRatio=v,M._activeAnimatables.push(this)}syncWith(M){if(this._syncRoot=M,M){const M=this._scene._activeAnimatables.indexOf(this);M>-1&&(this._scene._activeAnimatables.splice(M,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(M,Z){for(let P=0;P<Z.length;P++){const x=Z[P],c=new K(M,x,this._scene,this);c._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(c)}}getAnimationByTargetProperty(M){const Z=this._runtimeAnimations;for(let P=0;P<Z.length;P++)if(Z[P].animation.targetProperty===M)return Z[P].animation;return null}getRuntimeAnimationByTargetProperty(M){const Z=this._runtimeAnimations;for(let P=0;P<Z.length;P++)if(Z[P].animation.targetProperty===M)return Z[P];return null}reset(){const M=this._runtimeAnimations;for(let Z=0;Z<M.length;Z++)M[Z].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(M){const Z=this._runtimeAnimations;for(let P=0;P<Z.length;P++)Z[P].animation.enableBlending=!0,Z[P].animation.blendingSpeed=M}disableBlending(){const M=this._runtimeAnimations;for(let Z=0;Z<M.length;Z++)M[Z].animation.enableBlending=!1}goToFrame(M){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const P=this._runtimeAnimations;if(P[0]){const Z=P[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??P[0].currentFrame;const x=0===this.speedRatio?0:(M-this._frameToSyncFromJump)/Z*1e3/this.speedRatio;this._manualJumpDelay=-x}for(let x=0;x<P.length;x++)P[x].goToFrame(M,Z?this._weight:-1);this._goToFrame=M}get paused(){return this.Zm}pause(){this.Zm||(this.Zm=!0)}restart(){this.Zm=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(M,Z){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(M||Z){const c=this._scene._activeAnimatables.indexOf(this);if(c>-1){const w=this._runtimeAnimations;for(let P=w.length-1;P>=0;P--){const x=w[P];M&&x.animation.name!=M||(Z&&!Z(x.target)||(x.dispose(),w.splice(P,1)))}0==w.length&&(P||this._scene._activeAnimatables.splice(c,1),x||this._raiseOnAnimationEnd())}}else{const M=this._scene._activeAnimatables.indexOf(this);if(M>-1){P||this._scene._activeAnimatables.splice(M,1);const Z=this._runtimeAnimations;for(let M=0;M<Z.length;M++)Z[M].dispose();this._runtimeAnimations.length=0,x||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((M=>{this.onAnimationEndObservable.add((()=>{M(this)}),void 0,void 0,this,!0)}))}_animate(M){if(this.Zm)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=M),!0;if(null===this._localDelayOffset?(this._localDelayOffset=M,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=M-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let Z=!1;const P=this._runtimeAnimations;let x;for(x=0;x<P.length;x++){const c=P[x].animate(M-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);Z=Z||c}if(this.animationStarted=Z,!Z){if(this.disposeOnEnd)for(x=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(x,1),x=0;x<P.length;x++)P[x].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return Z}}function H(M){if(0===M.totalWeight&&0===M.totalAdditiveWeight)return M.originalValue;let Z=1;const P=mM.TmpVectors.BZ[0],x=mM.TmpVectors.BZ[1],c=mM.TmpVectors.Quaternion[0];let w=0;const v=M.animations[0],G=M.originalValue;let K=1,d=!1;if(M.totalWeight<1)K=1-M.totalWeight,G.decompose(x,c,P);else{if(w=1,Z=M.totalWeight,K=v.weight/Z,1==K){if(!M.totalAdditiveWeight)return v.currentValue;d=!0}v.currentValue.decompose(x,c,P)}if(!d){x.scaleInPlace(K),P.scaleInPlace(K),c.scaleInPlace(K);for(let v=w;v<M.animations.length;v++){const w=M.animations[v];if(0===w.weight)continue;K=w.weight/Z;const G=mM.TmpVectors.BZ[2],d=mM.TmpVectors.BZ[3],O=mM.TmpVectors.Quaternion[1];w.currentValue.decompose(d,O,G),d.scaleAndAddToRef(K,x),O.scaleAndAddToRef(mM.Quaternion.Dot(c,O)>0?K:-K,c),G.scaleAndAddToRef(K,P)}c.normalize()}for(let H=0;H<M.additiveAnimations.length;H++){const Z=M.additiveAnimations[H];if(0===Z.weight)continue;const w=mM.TmpVectors.BZ[2],v=mM.TmpVectors.BZ[3],G=mM.TmpVectors.Quaternion[1];Z.currentValue.decompose(v,G,w),v.multiplyToRef(x,v),mM.BZ.LerpToRef(x,v,Z.weight,x),c.multiplyToRef(G,G),mM.Quaternion.SlerpToRef(c,G,Z.weight,c),w.scaleAndAddToRef(Z.weight,P)}const O=v?v._animationState.workValue:mM.TmpVectors.Matrix[0].clone();return mM.Matrix.ComposeToRef(x,c,P,O),O}function j(M,Z){if(0===M.totalWeight&&0===M.totalAdditiveWeight)return Z;const P=M.animations[0],x=M.originalValue;let c=Z;if(0===M.totalWeight&&M.totalAdditiveWeight>0)c.v(x);else if(1===M.animations.length){if(mM.Quaternion.SlerpToRef(x,P.currentValue,Math.min(1,M.totalWeight),c),0===M.totalAdditiveWeight)return c}else if(M.animations.length>1){let P,w,v=1;if(M.totalWeight<1){const Z=1-M.totalWeight;P=[],w=[],P.push(x),w.push(Z)}else{if(2===M.animations.length&&(mM.Quaternion.SlerpToRef(M.animations[0].currentValue,M.animations[1].currentValue,M.animations[1].weight/M.totalWeight,Z),0===M.totalAdditiveWeight))return Z;P=[],w=[],v=M.totalWeight}for(let Z=0;Z<M.animations.length;Z++){const x=M.animations[Z];P.push(x.currentValue),w.push(x.weight/v)}let G=0;for(let M=0;M<P.length;)M?(G+=w[M],mM.Quaternion.SlerpToRef(c,P[M],w[M]/G,c),M++):(mM.Quaternion.SlerpToRef(P[M],P[M+1],w[M+1]/(w[M]+w[M+1]),Z),c=Z,G=w[M]+w[M+1],M+=2)}for(let w=0;w<M.additiveAnimations.length;w++){const Z=M.additiveAnimations[w];0!==Z.weight&&(c.multiplyToRef(Z.currentValue,mM.TmpVectors.Quaternion[0]),mM.Quaternion.SlerpToRef(c,mM.TmpVectors.Quaternion[0],Z.weight,c))}return c}var B,U,n=P(12596);B=n.e,(U=G.e)&&(U.prototype.copyAnimationRange=function(M,Z,P){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3],w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new x.d(this.name,"_matrix",M.animations[0].framePerSecond,x.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const v=M.animations[0].getRange(Z);if(!v)return!1;const G=v.from,mM=v.to,K=M.animations[0].getKeys(),d=M.length,O=M.getParent(),H=this.getParent(),j=c&&O&&d&&this.length&&d!==this.length,B=j&&H&&O?H.length/O.length:1,U=c&&!H&&w&&(1!==w.x||1!==w.y||1!==w.z),n=this.animations[0].getKeys();let L,u,N;for(let x=0,J=K.length;x<J;x++)L=K[x],L.frame>=G&&L.frame<=mM&&(c?(N=L.value.clone(),j?(u=N.getTranslation(),N.setTranslation(u.scaleInPlace(B))):U&&w?(u=N.getTranslation(),N.setTranslation(u.multiplyInPlace(w))):N=L.value):N=L.value,n.push({frame:L.frame+P,value:N}));return this.animations[0].createRange(Z,G+P,mM+P),!0}),B&&(B.prototype._animate=function(M){if(!this.animationsEnabled)return;const Z=d.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=Z}this.deltaTime=void 0!==M?M:this.useConstantAnimationDeltaTime?16:(Z-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=Z;const P=this._activeAnimatables;if(0===P.length)return;this._animationTime+=this.deltaTime;const c=this._animationTime;for(let x=0;x<P.length;x++){const M=P[x];!M._animate(c)&&M.disposeOnEnd&&x--}!function(M){if(M._registeredForLateAnimationBindings.length){for(let Z=0;Z<M._registeredForLateAnimationBindings.length;Z++){const P=M._registeredForLateAnimationBindings.data[Z];for(const M in P._lateAnimationHolders){const Z=P._lateAnimationHolders[M],c=Z.animations[0],w=Z.originalValue;if(void 0===w||null===w)continue;const v=x.d.AllowMatrixDecomposeForInterpolation&&w.m;let G=P[M];if(v)G=H(Z);else if(void 0!==w.w)G=j(Z,G||mM.Quaternion.Identity());else{let M=0,P=1;const v=c&&c._animationState.loopMode===x.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(Z.totalWeight<1)G=v?w.clone?w.clone():w:c&&w.scale?w.scale(1-Z.totalWeight):c?w*(1-Z.totalWeight):w.clone?w.clone():w;else if(c){P=Z.totalWeight;const x=c.weight/P;G=1!==x?c.currentValue.scale?c.currentValue.scale(x):c.currentValue*x:c.currentValue,v&&(G.addToRef?G.addToRef(w,G):G+=w),M=1}for(let x=M;x<Z.animations.length;x++){const M=Z.animations[x],c=M.weight/P;c&&(M.currentValue.scaleAndAddToRef?M.currentValue.scaleAndAddToRef(c,G):G+=M.currentValue*c)}for(let x=0;x<Z.additiveAnimations.length;x++){const M=Z.additiveAnimations[x],P=M.weight;P&&(M.currentValue.scaleAndAddToRef?M.currentValue.scaleAndAddToRef(P,G):G+=M.currentValue*P)}}P[M]=G}P._lateAnimationHolders={}}M._registeredForLateAnimationBindings.reset()}}(this)},B.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((M,Z)=>M.playOrder-Z.playOrder))},B.prototype.beginWeightedAnimation=function(M,Z,P){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,c=arguments.length>4?arguments[4]:void 0,w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,v=arguments.length>6?arguments[6]:void 0,G=arguments.length>7?arguments[7]:void 0,mM=arguments.length>8?arguments[8]:void 0,K=arguments.length>9?arguments[9]:void 0,d=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const O=this.beginAnimation(M,Z,P,c,w,v,G,!1,mM,K,d);return O.weight=x,O},B.prototype.beginAnimation=function(M,Z,P,x){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,w=arguments.length>5?arguments[5]:void 0,v=arguments.length>6?arguments[6]:void 0,G=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],mM=arguments.length>8?arguments[8]:void 0,K=arguments.length>9?arguments[9]:void 0,d=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(c<0){const M=Z;Z=P,P=M,c=-c}Z>P&&(c=-c),G&&this.stopAnimation(M,void 0,mM),v||(v=new O(this,M,Z,P,x,c,w,void 0,K,d));const H=!mM||mM(M);if(M.animations&&H&&v.appendAnimations(M,M.animations),M.getAnimatables){const d=M.getAnimatables();for(let M=0;M<d.length;M++)this.beginAnimation(d[M],Z,P,x,c,w,v,G,mM,K)}return v.reset(),v},B.prototype.beginHierarchyAnimation=function(M,Z,P,x,c){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,v=arguments.length>6?arguments[6]:void 0,G=arguments.length>7?arguments[7]:void 0,mM=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],K=arguments.length>9?arguments[9]:void 0,d=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const O=M.getDescendants(Z),H=[];H.push(this.beginAnimation(M,P,x,c,w,v,G,mM,K,void 0,d));for(const j of O)H.push(this.beginAnimation(j,P,x,c,w,v,G,mM,K,void 0,d));return H},B.prototype.beginDirectAnimation=function(M,Z,P,x,c){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(w<0){const M=P;P=x,x=M,w=-w}return P>x&&(w=-w),new O(this,M,P,x,c,w,arguments.length>6?arguments[6]:void 0,Z,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},B.prototype.beginDirectHierarchyAnimation=function(M,Z,P,x,c,w,v,G,mM){let K=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const d=M.getDescendants(Z),O=[];O.push(this.beginDirectAnimation(M,P,x,c,w,v,G,mM,K));for(const H of d)O.push(this.beginDirectAnimation(H,P,x,c,w,v,G,mM,K));return O},B.prototype.getAnimatableByTarget=function(M){for(let Z=0;Z<this._activeAnimatables.length;Z++)if(this._activeAnimatables[Z].target===M)return this._activeAnimatables[Z];return null},B.prototype.getAllAnimatablesByTarget=function(M){const Z=[];for(let P=0;P<this._activeAnimatables.length;P++)this._activeAnimatables[P].target===M&&Z.push(this._activeAnimatables[P]);return Z},B.prototype.stopAnimation=function(M,Z,P){const x=this.getAllAnimatablesByTarget(M);for(const c of x)c.stop(Z,P)},B.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let M=0;M<this._activeAnimatables.length;M++)this._activeAnimatables[M].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const M of this.animationGroups)M.stop()});class L{getClassName(){return"TargetedAnimation"}serialize(){const M={};return M.animation=this.animation.serialize(),M.targetId=this.target.id,M}}class u{get mask(){return this._mask}set mask(M){this._mask!==M&&(this._mask=M,this.syncWithMask(!0))}syncWithMask(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||M){this._numActiveAnimatables=0;for(let M=0;M<this._animatables.length;++M){const Z=this._animatables[M];!this.mask||this.mask.disabled||this.mask.retainsTarget(Z.target.name)?(this._numActiveAnimatables++,Z.paused&&Z.restart()):Z.paused||Z.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let M=0;M<this._animatables.length;++M){const Z=this._animatables[M];this.mask.retainsTarget(Z.target.name)||(Z.stop(),this._animatables.splice(M,1),--M)}for(let M=0;M<this._targetedAnimations.length;M++){const Z=this._targetedAnimations[M];this.mask.retainsTarget(Z.target.name)||(this._targetedAnimations.splice(M,1),--M)}}}get from(){return this._from}set from(M){if(this._from!==M){this._from=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].fromFrame=this._from}}}get to(){return this._to}set to(M){if(this._to!==M){this._to=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(M){if(this._speedRatio!==M){this._speedRatio=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(M){if(this._loopAnimation!==M){this._loopAnimation=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(M){if(this._isAdditive!==M){this._isAdditive=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(M){this._weight!==M&&(this._weight=M,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(M){if(this._playOrder!==M&&(this._playOrder=M,this._animatables.length>0)){for(let M=0;M<this._animatables.length;M++)this._animatables[M].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(M){if(this._enableBlending!==M&&(this._enableBlending=M,null!==M))for(let Z=0;Z<this._targetedAnimations.length;++Z)this._targetedAnimations[Z].animation.enableBlending=M}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(M){if(this._blendingSpeed!==M&&(this._blendingSpeed=M,null!==M))for(let Z=0;Z<this._targetedAnimations.length;++Z)this._targetedAnimations[Z].animation.blendingSpeed=M}getLength(M,Z){M=M??this._from;return((Z=Z??this._to)-M)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(M){let Z=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=arguments.length>3?arguments[3]:void 0;if(0===M.length)return null;x=x??M[0].weight;let c=Number.MAX_VALUE,w=-Number.MAX_VALUE;if(P)for(const G of M)G.from<c&&(c=G.from),G.to>w&&(w=G.to);const v=new u(M[0].name+"_merged",M[0]._scene,x);for(const G of M){P&&G.normalize(c,w);for(const M of G.targetedAnimations)v.addTargetedAnimation(M.animation,M.target);Z&&G.dispose()}return v}constructor(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=M,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new c.b,this.onAnimationLoopObservable=new c.b,this.onAnimationGroupLoopObservable=new c.b,this.onAnimationGroupEndObservable=new c.b,this.onAnimationGroupPauseObservable=new c.b,this.onAnimationGroupPlayObservable=new c.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=Z||w.b.LastCreatedScene,this._weight=P,this._playOrder=x,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(M,Z){const P=new L;P.animation=M,P.target=Z;const x=M.getKeys();return this._from>x[0].frame&&(this._from=x[0].frame),this._to<x[x.length-1].frame&&(this._to=x[x.length-1].frame),null!==this._enableBlending&&(M.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(M.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(P),this._shouldStart=!0,P}removeTargetedAnimation(M){for(let Z=this._targetedAnimations.length-1;Z>-1;Z--){this._targetedAnimations[Z].animation===M&&this._targetedAnimations.splice(Z,1)}}normalize(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==M&&(M=this._from),null==Z&&(Z=this._to);for(let P=0;P<this._targetedAnimations.length;P++){const x=this._targetedAnimations[P].animation.getKeys(),c=x[0],w=x[x.length-1];if(c.frame>M){const Z={frame:M,value:c.value,inTangent:c.inTangent,outTangent:c.outTangent,interpolation:c.interpolation};x.splice(0,0,Z)}if(w.frame<Z){const M={frame:Z,value:w.value,inTangent:w.inTangent,outTangent:w.outTangent,interpolation:w.interpolation};x.push(M)}}return this._from=M,this._to=Z,this}_processLoop(M,Z,P){M.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(Z),this._animationLoopFlags[P]||(this._animationLoopFlags[P]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0],Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0,x=arguments.length>3?arguments[3]:void 0,c=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=M,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let w=0;w<this._targetedAnimations.length;w++){const v=this._targetedAnimations[w],G=this._scene.beginDirectAnimation(v.target,[v.animation],void 0!==P?P:this._from,void 0!==x?x:this._to,M,Z,void 0,void 0,void 0!==c?c:this._isAdditive);G.weight=this._weight,G.playOrder=this._playOrder,G.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(v),this._checkAnimationGroupEnded(G)},this._processLoop(G,v,w),this._animatables.push(G)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=Z,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let M=0;M<this._animatables.length;M++){this._animatables[M].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(M){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==M&&(this.loopAnimation=M),this.restart()):(this.stop(),this.start(M,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let M=0;M<this._animatables.length;M++){this._animatables[M].reset()}return this}restart(){if(!this._isStarted)return this;for(let M=0;M<this._animatables.length;M++){this._animatables[M].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const Z=this._animatables.slice();for(let x=0;x<Z.length;x++)Z[x].stop(void 0,void 0,!0,M);let P=0;for(let x=0;x<this._scene._activeAnimatables.length;x++){const Z=this._scene._activeAnimatables[x];Z._runtimeAnimations.length>0?this._scene._activeAnimatables[P++]=Z:M&&this._checkAnimationGroupEnded(Z,M)}return this._scene._activeAnimatables.length=P,this._isStarted=!1,this}setWeightForAllAnimatables(M){for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].weight=M}return this}syncAllAnimationsWith(M){for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].syncWith(M)}return this}goToFrame(M){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let P=0;P<this._animatables.length;P++){this._animatables[P].goToFrame(M,Z)}return this}getCurrentFrame(){var M;return(null===(M=this.animatables[0])||void 0===M?void 0:M.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const M=this._scene.animationGroups.indexOf(this);if(M>-1&&this._scene.animationGroups.splice(M,1),this._parentContainer){const M=this._parentContainer.animationGroups.indexOf(this);M>-1&&this._parentContainer.animationGroups.splice(M,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(M){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const P=this._animatables.indexOf(M);P>-1&&this._animatables.splice(P,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,Z||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(M,Z){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const x=new u(M||this.name,this._scene,this._weight,this._playOrder);x._from=this.from,x._to=this.to,x._speedRatio=this.speedRatio,x._loopAnimation=this.loopAnimation,x._isAdditive=this.isAdditive,x._enableBlending=this.enableBlending,x._blendingSpeed=this.blendingSpeed,x.metadata=this.metadata,x.mask=this.mask;for(const c of this._targetedAnimations)x.addTargetedAnimation(P?c.animation.clone():c.animation,Z?Z(c.target):c.target);return x}serialize(){const M={};M.name=this.name,M.from=this.from,M.to=this.to,M.speedRatio=this.speedRatio,M.loopAnimation=this.loopAnimation,M.isAdditive=this.isAdditive,M.weight=this.weight,M.playOrder=this.playOrder,M.enableBlending=this.enableBlending,M.blendingSpeed=this.blendingSpeed,M.targetedAnimations=[];for(let Z=0;Z<this.targetedAnimations.length;Z++){const P=this.targetedAnimations[Z];M.targetedAnimations[Z]=P.serialize()}return v.e&&v.e.HasTags(this)&&(M.tags=v.e.GetTags(this)),this.metadata&&(M.metadata=this.metadata),M}static Parse(M,Z){const P=new u(M.name,Z,M.weight,M.playOrder);for(let c=0;c<M.targetedAnimations.length;c++){const w=M.targetedAnimations[c],v=x.d.Parse(w.animation),G=w.targetId;if("influence"===w.animation.property){const M=Z.getMorphTargetById(G);M&&P.addTargetedAnimation(v,M)}else{const M=Z.getNodeById(G);null!=M&&P.addTargetedAnimation(v,M)}}return v.e&&v.e.AddTagsTo(P,M.tags),null!==M.from&&null!==M.to&&P.normalize(M.from,M.to),void 0!==M.speedRatio&&(P._speedRatio=M.speedRatio),void 0!==M.loopAnimation&&(P._loopAnimation=M.loopAnimation),void 0!==M.isAdditive&&(P._isAdditive=M.isAdditive),void 0!==M.weight&&(P._weight=M.weight),void 0!==M.playOrder&&(P._playOrder=M.playOrder),void 0!==M.enableBlending&&(P._enableBlending=M.enableBlending),void 0!==M.blendingSpeed&&(P._blendingSpeed=M.blendingSpeed),void 0!==M.metadata&&(P.metadata=M.metadata),P}static MakeAnimationAdditive(M,Z,P){let c;c="object"===typeof Z?Z:{referenceFrame:Z,range:P,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let w=M;c.cloneOriginalAnimationGroup&&(w=M.clone(c.clonedAnimationGroupName||w.name));const v=w.targetedAnimations;for(let G=0;G<v.length;G++){const M=v[G];M.animation=x.d.MakeAnimationAdditive(M.animation,c)}if(w.isAdditive=!0,c.clipKeys){let M=Number.MAX_VALUE,Z=-Number.MAX_VALUE;const P=w.targetedAnimations;for(let x=0;x<P.length;x++){const c=P[x].animation.getKeys();M>c[0].frame&&(M=c[0].frame),Z<c[c.length-1].frame&&(Z=c[c.length-1].frame)}w._from=M,w._to=Z}return w}static ClipKeys(M,Z,P,x,c){const w=M.clone(x||M.name);return u.ClipKeysInPlace(w,Z,P,c)}static ClipKeysInPlace(M,Z,P,x){return u.ClipInPlace(M,Z,P,x,!1)}static ClipFrames(M,Z,P,x,c){const w=M.clone(x||M.name);return u.ClipFramesInPlace(w,Z,P,c)}static ClipFramesInPlace(M,Z,P,x){return u.ClipInPlace(M,Z,P,x,!0)}static ClipInPlace(M,Z,P,x){let c=arguments.length>4&&void 0!==arguments[4]&&arguments[4],w=Number.MAX_VALUE,v=-Number.MAX_VALUE;const G=M.targetedAnimations;for(let mM=0;mM<G.length;mM++){const M=G[mM],K=x?M.animation:M.animation.clone();c&&(K.createKeyForFrame(Z),K.createKeyForFrame(P));const d=K.getKeys(),O=[];let H=Number.MAX_VALUE;for(let x=0;x<d.length;x++){const M=d[x];if(!c&&x>=Z&&x<=P||c&&M.frame>=Z&&M.frame<=P){const Z={frame:M.frame,value:M.value.clone?M.value.clone():M.value,inTangent:M.inTangent,outTangent:M.outTangent,interpolation:M.interpolation,lockedTangent:M.lockedTangent};H===Number.MAX_VALUE&&(H=Z.frame),Z.frame-=H,O.push(Z)}}0!==O.length?(w>O[0].frame&&(w=O[0].frame),v<O[O.length-1].frame&&(v=O[O.length-1].frame),K.setKeys(O,!0),M.animation=K):(G.splice(mM,1),mM--)}return M._from=w,M._to=v,M}getClassName(){return"AnimationGroup"}toString(M){let Z="Name: "+this.name;return Z+=", type: "+this.getClassName(),M&&(Z+=", from: "+this._from,Z+=", to: "+this._to,Z+=", isStarted: "+this._isStarted,Z+=", speedRatio: "+this._speedRatio,Z+=", targetedAnimations length: "+this._targetedAnimations.length,Z+=", animatables length: "+this._animatables),Z}}}}]);