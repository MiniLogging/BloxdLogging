"use strict";(self.hmihoa2fs98=self.hmihoa2fs98||[]).push([[78],{14826:(b,d,P)=>{P.r(d),P.d(d,{AnimationGroup:()=>n,TargetedAnimation:()=>B});var G=P(12201),W=P(11487),i=P(11535),q=P(11722),C=P(13292),J=P(11681);class L{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(b,d,P,W){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=d,this._target=b,this._scene=P,this._host=W,this._activeTargets=[],d._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===G.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=J.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const b={frame:0,value:this._minValue};this._keys.splice(0,0,b)}if(this._target instanceof Array){let b=0;for(const d of this._target)this._preparePath(d,b),this._getOriginalValues(b),b++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const i=d.getEvents();if(i&&i.length>0)for(const G of i)this._events.push(G._clone());this._enableBlending=b&&b.animationPropertiesOverride?b.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=this._animation.targetPropertyPath;if(P.length>1){let G=b;for(let b=0;b<P.length-1;b++){const d=P[b];if(G=G[d],void 0===G)throw new Error(`Invalid property (${d}) in property path (${P.join(".")})`)}this._targetPath=P[P.length-1],this._activeTargets[d]=G}else this._targetPath=P[0],this._activeTargets[d]=b;if(void 0===this._activeTargets[d][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${P.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let b=0;for(const d of this._target)void 0!==this._originalValue[b]&&this._setValue(d,this._activeTargets[b],this._originalValue[b],-1,b),b++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let b=0;b<this._events.length;b++)this._events[b].isDone=!1}isStopped(){return this._stopped}dispose(){const b=this._animation.runtimeAnimations.indexOf(this);b>-1&&this._animation.runtimeAnimations.splice(b,1)}setValue(b,d){if(this._targetIsArray)for(let P=0;P<this._target.length;P++){const G=this._target[P];this._setValue(G,this._activeTargets[P],b,d,P)}else this._setValue(this._target,this._directTarget,b,d,0)}_getOriginalValues(){let b,d=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const P=this._activeTargets[d];b=P.getLocalMatrix&&"_matrix"===this._targetPath?P.getLocalMatrix():P[this._targetPath],b&&b.clone?this._originalValue[d]=b.clone():this._originalValue[d]=b}_registerTargetForLateAnimationBinding(b,d){const P=b.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(P),P._lateAnimationHolders||(P._lateAnimationHolders={}),P._lateAnimationHolders[b.targetPath]||(P._lateAnimationHolders[b.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:d}),b.isAdditive?(P._lateAnimationHolders[b.targetPath].additiveAnimations.push(b),P._lateAnimationHolders[b.targetPath].totalAdditiveWeight+=b.weight):(P._lateAnimationHolders[b.targetPath].animations.push(b),P._lateAnimationHolders[b.targetPath].totalWeight+=b.weight)}_setValue(b,d,P,W,i){if(this._currentActiveTarget=d,this._weight=W,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const b=d[this._targetPath];b.clone?this._originalBlendValue=b.clone():this._originalBlendValue=b}this._originalBlendValue.m?G.b.AllowMatrixDecomposeForInterpolation?this._currentValue?J.Matrix.DecomposeLerpToRef(this._originalBlendValue,P,this._blendingFactor,this._currentValue):this._currentValue=J.Matrix.DecomposeLerp(this._originalBlendValue,P,this._blendingFactor):this._currentValue?J.Matrix.LerpToRef(this._originalBlendValue,P,this._blendingFactor,this._currentValue):this._currentValue=J.Matrix.Lerp(this._originalBlendValue,P,this._blendingFactor):this._currentValue=G.b._UniversalLerp(this._originalBlendValue,P,this._blendingFactor);const W=b&&b.animationPropertiesOverride?b.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=W}else this._currentValue?this._currentValue.q?this._currentValue.q(P):this._currentValue=P:null!==P&&void 0!==P&&P.clone?this._currentValue=P.clone():this._currentValue=P;-1!==W?this._registerTargetForLateAnimationBinding(this,this._originalValue[i]):this._animationState.loopMode===G.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[i],d[this._targetPath]):d[this._targetPath]=this._originalValue[i]+this._currentValue:d[this._targetPath]=this._currentValue,b.aL&&b.aL(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const P=this._animation.getKeys();b<P[0].frame?b=P[0].frame:b>P[P.length-1].frame&&(b=P[P.length-1].frame);const G=this._events;if(G.length)for(let i=0;i<G.length;i++)G[i].onlyOnce||(G[i].isDone=G[i].frame<b);this._currentFrame=b;const W=this._animation._interpolate(b,this._animationState);this.setValue(W,d)}_prepareForSpeedRatioChange(b){const d=this._previousElapsedTime*(this._animation.framePerSecond*b)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-d}animate(b,d,P,W,i){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const C=this._animation,J=C.targetPropertyPath;if(!J||J.length<1)return this._stopped=!0,!1;let L,x=!0;const Y=this._events;let s=0;if(this._coreRuntimeAnimation)s=P-d,L=this._coreRuntimeAnimation.currentFrame,this._currentFrame=L,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let q;(d<this._minFrame||d>this._maxFrame)&&(d=this._minFrame),(P<this._minFrame||P>this._maxFrame)&&(P=this._maxFrame),s=P-d;let J=b*(C.framePerSecond*i)/1e3+this._absoluteFrameOffset,E=0,w=!1;const t=W&&this._animationState.loopMode===G.b.ANIMATIONLOOPMODE_YOYO;if(t){const b=(J-d)/s,P=Math.sin(b*Math.PI);J=Math.abs(P)*s+d;const G=P>=0?1:-1;this._yoyoDirection!==G&&(w=!0),this._yoyoDirection=G}if(this._previousElapsedTime=b,this._previousAbsoluteFrame=J,!W&&P>=d&&(J>=s&&i>0||J<=0&&i<0))x=!1,E=C._getKeyValue(this._maxValue);else if(!W&&d>=P&&(J<=s&&i<0||J>=0&&i>0))x=!1,E=C._getKeyValue(this._minValue);else if(this._animationState.loopMode!==G.b.ANIMATIONLOOPMODE_CYCLE){const b=P.toString()+d.toString();if(!this._offsetsCache[b]){this._animationState.repeatCount=0,this._animationState.loopMode=G.b.ANIMATIONLOOPMODE_CYCLE;const W=C._interpolate(d,this._animationState),i=C._interpolate(P,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),C.dataType){case G.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[b]=i-W;break;case G.b.ANIMATIONTYPE_QUATERNION:case G.b.ANIMATIONTYPE_VECTOR3:case G.b.ANIMATIONTYPE_VECTOR2:case G.b.ANIMATIONTYPE_SIZE:case G.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[b]=i.Rd(W)}this._highLimitsCache[b]=i}E=this._highLimitsCache[b],q=this._offsetsCache[b]}if(void 0===q)switch(C.dataType){case G.b.ANIMATIONTYPE_FLOAT:q=0;break;case G.b.ANIMATIONTYPE_QUATERNION:q=G.k;break;case G.b.ANIMATIONTYPE_VECTOR3:q=G.u;break;case G.b.ANIMATIONTYPE_VECTOR2:q=G.q;break;case G.b.ANIMATIONTYPE_SIZE:q=G.n;break;case G.b.ANIMATIONTYPE_COLOR3:q=G.f;break;case G.b.ANIMATIONTYPE_COLOR4:q=G.j}if(this._host&&this._host.syncRoot){const b=this._host.syncRoot;L=d+s*((b.masterFrame-b.fromFrame)/(b.toFrame-b.fromFrame))}else L=J>0&&d>P||J<0&&d<P?x&&0!==s?P+J%s:d:x&&0!==s?d+J%s:P;if(!t&&(i>0&&this.currentFrame>L||i<0&&this.currentFrame<L)||t&&w){this._onLoop();for(let b=0;b<Y.length;b++)Y[b].onlyOnce||(Y[b].isDone=!1);this._animationState.key=i>0?0:C.getKeys().length-1}this._currentFrame=L,this._animationState.repeatCount=0===s?0:J/s|0,this._animationState.highLimitValue=E,this._animationState.offsetValue=q}const E=C._interpolate(L,this._animationState);if(this.setValue(E,q),Y.length)for(let G=0;G<Y.length;G++)if(s>=0&&L>=Y[G].frame&&Y[G].frame>=d||s<0&&L<=Y[G].frame&&Y[G].frame<=d){const b=Y[G];b.isDone||(b.onlyOnce&&(Y.splice(G,1),G--),b.isDone=!0,b.action(L))}return x||(this._stopped=!0),x}}var x=P(11517);class Y{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(b){this._weight=-1!==b?Math.min(Math.max(b,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(b){for(let d=0;d<this._runtimeAnimations.length;d++){this._runtimeAnimations[d]._prepareForSpeedRatioChange(b)}this._speedRatio=b,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(b,d){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,i=arguments.length>4&&void 0!==arguments[4]&&arguments[4],q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,C=arguments.length>6?arguments[6]:void 0,J=arguments.length>7?arguments[7]:void 0,L=arguments.length>8?arguments[8]:void 0,x=arguments.length>9&&void 0!==arguments[9]&&arguments[9],Y=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=d,this.fromFrame=P,this.toFrame=G,this.loopAnimation=i,this.onAnimationEnd=C,this.onAnimationLoop=L,this.isAdditive=x,this.playOrder=Y,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.nC=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new W.d,this.onAnimationLoopObservable=new W.d,this._scene=b,J&&this.appendAnimations(d,J),this._speedRatio=q,b._activeAnimatables.push(this)}syncWith(b){if(this._syncRoot=b,b){const b=this._scene._activeAnimatables.indexOf(this);b>-1&&(this._scene._activeAnimatables.splice(b,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(b,d){for(let P=0;P<d.length;P++){const G=d[P],W=new L(b,G,this._scene,this);W._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(W)}}getAnimationByTargetProperty(b){const d=this._runtimeAnimations;for(let P=0;P<d.length;P++)if(d[P].animation.targetProperty===b)return d[P].animation;return null}getRuntimeAnimationByTargetProperty(b){const d=this._runtimeAnimations;for(let P=0;P<d.length;P++)if(d[P].animation.targetProperty===b)return d[P];return null}reset(){const b=this._runtimeAnimations;for(let d=0;d<b.length;d++)b[d].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(b){const d=this._runtimeAnimations;for(let P=0;P<d.length;P++)d[P].animation.enableBlending=!0,d[P].animation.blendingSpeed=b}disableBlending(){const b=this._runtimeAnimations;for(let d=0;d<b.length;d++)b[d].animation.enableBlending=!1}goToFrame(b){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const P=this._runtimeAnimations;if(P[0]){const d=P[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??P[0].currentFrame;const G=0===this.speedRatio?0:(b-this._frameToSyncFromJump)/d*1e3/this.speedRatio;this._manualJumpDelay=-G}for(let G=0;G<P.length;G++)P[G].goToFrame(b,d?this._weight:-1);this._goToFrame=b}get paused(){return this.nC}pause(){this.nC||(this.nC=!0)}restart(){this.nC=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(b,d){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],G=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(b||d){const W=this._scene._activeAnimatables.indexOf(this);if(W>-1){const i=this._runtimeAnimations;for(let P=i.length-1;P>=0;P--){const G=i[P];b&&G.animation.name!=b||(d&&!d(G.target)||(G.dispose(),i.splice(P,1)))}0==i.length&&(P||this._scene._activeAnimatables.splice(W,1),G||this._raiseOnAnimationEnd())}}else{const b=this._scene._activeAnimatables.indexOf(this);if(b>-1){P||this._scene._activeAnimatables.splice(b,1);const d=this._runtimeAnimations;for(let b=0;b<d.length;b++)d[b].dispose();this._runtimeAnimations.length=0,G||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((b=>{this.onAnimationEndObservable.add((()=>{b(this)}),void 0,void 0,this,!0)}))}_animate(b){if(this.nC)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=b),!0;if(null===this._localDelayOffset?(this._localDelayOffset=b,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=b-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let d=!1;const P=this._runtimeAnimations;let G;for(G=0;G<P.length;G++){const W=P[G].animate(b-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);d=d||W}if(this.animationStarted=d,!d){if(this.disposeOnEnd)for(G=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(G,1),G=0;G<P.length;G++)P[G].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return d}}function s(b){if(0===b.totalWeight&&0===b.totalAdditiveWeight)return b.originalValue;let d=1;const P=J.TmpVectors.ed[0],G=J.TmpVectors.ed[1],W=J.TmpVectors.Quaternion[0];let i=0;const q=b.animations[0],C=b.originalValue;let L=1,x=!1;if(b.totalWeight<1)L=1-b.totalWeight,C.decompose(G,W,P);else{if(i=1,d=b.totalWeight,L=q.weight/d,1==L){if(!b.totalAdditiveWeight)return q.currentValue;x=!0}q.currentValue.decompose(G,W,P)}if(!x){G.scaleInPlace(L),P.scaleInPlace(L),W.scaleInPlace(L);for(let q=i;q<b.animations.length;q++){const i=b.animations[q];if(0===i.weight)continue;L=i.weight/d;const C=J.TmpVectors.ed[2],x=J.TmpVectors.ed[3],Y=J.TmpVectors.Quaternion[1];i.currentValue.decompose(x,Y,C),x.scaleAndAddToRef(L,G),Y.scaleAndAddToRef(J.Quaternion.Dot(W,Y)>0?L:-L,W),C.scaleAndAddToRef(L,P)}W.normalize()}for(let s=0;s<b.additiveAnimations.length;s++){const d=b.additiveAnimations[s];if(0===d.weight)continue;const i=J.TmpVectors.ed[2],q=J.TmpVectors.ed[3],C=J.TmpVectors.Quaternion[1];d.currentValue.decompose(q,C,i),q.multiplyToRef(G,q),J.ed.LerpToRef(G,q,d.weight,G),W.multiplyToRef(C,C),J.Quaternion.SlerpToRef(W,C,d.weight,W),i.scaleAndAddToRef(d.weight,P)}const Y=q?q._animationState.workValue:J.TmpVectors.Matrix[0].clone();return J.Matrix.ComposeToRef(G,W,P,Y),Y}function E(b,d){if(0===b.totalWeight&&0===b.totalAdditiveWeight)return d;const P=b.animations[0],G=b.originalValue;let W=d;if(0===b.totalWeight&&b.totalAdditiveWeight>0)W.q(G);else if(1===b.animations.length){if(J.Quaternion.SlerpToRef(G,P.currentValue,Math.min(1,b.totalWeight),W),0===b.totalAdditiveWeight)return W}else if(b.animations.length>1){let P,i,q=1;if(b.totalWeight<1){const d=1-b.totalWeight;P=[],i=[],P.push(G),i.push(d)}else{if(2===b.animations.length&&(J.Quaternion.SlerpToRef(b.animations[0].currentValue,b.animations[1].currentValue,b.animations[1].weight/b.totalWeight,d),0===b.totalAdditiveWeight))return d;P=[],i=[],q=b.totalWeight}for(let d=0;d<b.animations.length;d++){const G=b.animations[d];P.push(G.currentValue),i.push(G.weight/q)}let C=0;for(let b=0;b<P.length;)b?(C+=i[b],J.Quaternion.SlerpToRef(W,P[b],i[b]/C,W),b++):(J.Quaternion.SlerpToRef(P[b],P[b+1],i[b+1]/(i[b]+i[b+1]),d),W=d,C=i[b]+i[b+1],b+=2)}for(let i=0;i<b.additiveAnimations.length;i++){const d=b.additiveAnimations[i];0!==d.weight&&(W.multiplyToRef(d.currentValue,J.TmpVectors.Quaternion[0]),J.Quaternion.SlerpToRef(W,J.TmpVectors.Quaternion[0],d.weight,W))}return W}var w,t,r=P(11909);w=r.e,(t=C.e)&&(t.prototype.copyAnimationRange=function(b,d,P){let W=arguments.length>3&&void 0!==arguments[3]&&arguments[3],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new G.b(this.name,"_matrix",b.animations[0].framePerSecond,G.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const q=b.animations[0].getRange(d);if(!q)return!1;const C=q.from,J=q.to,L=b.animations[0].getKeys(),x=b.length,Y=b.getParent(),s=this.getParent(),E=W&&Y&&x&&this.length&&x!==this.length,w=E&&s&&Y?s.length/Y.length:1,t=W&&!s&&i&&(1!==i.x||1!==i.y||1!==i.z),r=this.animations[0].getKeys();let B,n,Z;for(let G=0,o=L.length;G<o;G++)B=L[G],B.frame>=C&&B.frame<=J&&(W?(Z=B.value.clone(),E?(n=Z.getTranslation(),Z.setTranslation(n.scaleInPlace(w))):t&&i?(n=Z.getTranslation(),Z.setTranslation(n.multiplyInPlace(i))):Z=B.value):Z=B.value,r.push({frame:B.frame+P,value:Z}));return this.animations[0].createRange(d,C+P,J+P),!0}),w&&(w.prototype._animate=function(b){if(!this.animationsEnabled)return;const d=x.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=d}this.deltaTime=void 0!==b?b:this.useConstantAnimationDeltaTime?16:(d-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=d;const P=this._activeAnimatables;if(0===P.length)return;this._animationTime+=this.deltaTime;const W=this._animationTime;for(let G=0;G<P.length;G++){const b=P[G];!b._animate(W)&&b.disposeOnEnd&&G--}!function(b){if(b._registeredForLateAnimationBindings.length){for(let d=0;d<b._registeredForLateAnimationBindings.length;d++){const P=b._registeredForLateAnimationBindings.data[d];for(const b in P._lateAnimationHolders){const d=P._lateAnimationHolders[b],W=d.animations[0],i=d.originalValue;if(void 0===i||null===i)continue;const q=G.b.AllowMatrixDecomposeForInterpolation&&i.m;let C=P[b];if(q)C=s(d);else if(void 0!==i.w)C=E(d,C||J.Quaternion.Identity());else{let b=0,P=1;const q=W&&W._animationState.loopMode===G.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(d.totalWeight<1)C=q?i.clone?i.clone():i:W&&i.scale?i.scale(1-d.totalWeight):W?i*(1-d.totalWeight):i.clone?i.clone():i;else if(W){P=d.totalWeight;const G=W.weight/P;C=1!==G?W.currentValue.scale?W.currentValue.scale(G):W.currentValue*G:W.currentValue,q&&(C.addToRef?C.addToRef(i,C):C+=i),b=1}for(let G=b;G<d.animations.length;G++){const b=d.animations[G],W=b.weight/P;W&&(b.currentValue.scaleAndAddToRef?b.currentValue.scaleAndAddToRef(W,C):C+=b.currentValue*W)}for(let G=0;G<d.additiveAnimations.length;G++){const b=d.additiveAnimations[G],P=b.weight;P&&(b.currentValue.scaleAndAddToRef?b.currentValue.scaleAndAddToRef(P,C):C+=b.currentValue*P)}}P[b]=C}P._lateAnimationHolders={}}b._registeredForLateAnimationBindings.reset()}}(this)},w.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((b,d)=>b.playOrder-d.playOrder))},w.prototype.beginWeightedAnimation=function(b,d,P){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,W=arguments.length>4?arguments[4]:void 0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,q=arguments.length>6?arguments[6]:void 0,C=arguments.length>7?arguments[7]:void 0,J=arguments.length>8?arguments[8]:void 0,L=arguments.length>9?arguments[9]:void 0,x=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const Y=this.beginAnimation(b,d,P,W,i,q,C,!1,J,L,x);return Y.weight=G,Y},w.prototype.beginAnimation=function(b,d,P,G){let W=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,i=arguments.length>5?arguments[5]:void 0,q=arguments.length>6?arguments[6]:void 0,C=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],J=arguments.length>8?arguments[8]:void 0,L=arguments.length>9?arguments[9]:void 0,x=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(W<0){const b=d;d=P,P=b,W=-W}d>P&&(W=-W),C&&this.stopAnimation(b,void 0,J),q||(q=new Y(this,b,d,P,G,W,i,void 0,L,x));const s=!J||J(b);if(b.animations&&s&&q.appendAnimations(b,b.animations),b.getAnimatables){const x=b.getAnimatables();for(let b=0;b<x.length;b++)this.beginAnimation(x[b],d,P,G,W,i,q,C,J,L)}return q.reset(),q},w.prototype.beginHierarchyAnimation=function(b,d,P,G,W){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,q=arguments.length>6?arguments[6]:void 0,C=arguments.length>7?arguments[7]:void 0,J=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],L=arguments.length>9?arguments[9]:void 0,x=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const Y=b.getDescendants(d),s=[];s.push(this.beginAnimation(b,P,G,W,i,q,C,J,L,void 0,x));for(const E of Y)s.push(this.beginAnimation(E,P,G,W,i,q,C,J,L,void 0,x));return s},w.prototype.beginDirectAnimation=function(b,d,P,G,W){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(i<0){const b=P;P=G,G=b,i=-i}return P>G&&(i=-i),new Y(this,b,P,G,W,i,arguments.length>6?arguments[6]:void 0,d,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},w.prototype.beginDirectHierarchyAnimation=function(b,d,P,G,W,i,q,C,J){let L=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const x=b.getDescendants(d),Y=[];Y.push(this.beginDirectAnimation(b,P,G,W,i,q,C,J,L));for(const s of x)Y.push(this.beginDirectAnimation(s,P,G,W,i,q,C,J,L));return Y},w.prototype.getAnimatableByTarget=function(b){for(let d=0;d<this._activeAnimatables.length;d++)if(this._activeAnimatables[d].target===b)return this._activeAnimatables[d];return null},w.prototype.getAllAnimatablesByTarget=function(b){const d=[];for(let P=0;P<this._activeAnimatables.length;P++)this._activeAnimatables[P].target===b&&d.push(this._activeAnimatables[P]);return d},w.prototype.stopAnimation=function(b,d,P){const G=this.getAllAnimatablesByTarget(b);for(const W of G)W.stop(d,P)},w.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let b=0;b<this._activeAnimatables.length;b++)this._activeAnimatables[b].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const b of this.animationGroups)b.stop()});class B{getClassName(){return"TargetedAnimation"}serialize(){const b={};return b.animation=this.animation.serialize(),b.targetId=this.target.id,b}}class n{get mask(){return this._mask}set mask(b){this._mask!==b&&(this._mask=b,this.syncWithMask(!0))}syncWithMask(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||b){this._numActiveAnimatables=0;for(let b=0;b<this._animatables.length;++b){const d=this._animatables[b];!this.mask||this.mask.disabled||this.mask.retainsTarget(d.target.name)?(this._numActiveAnimatables++,d.paused&&d.restart()):d.paused||d.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let b=0;b<this._animatables.length;++b){const d=this._animatables[b];this.mask.retainsTarget(d.target.name)||(d.stop(),this._animatables.splice(b,1),--b)}for(let b=0;b<this._targetedAnimations.length;b++){const d=this._targetedAnimations[b];this.mask.retainsTarget(d.target.name)||(this._targetedAnimations.splice(b,1),--b)}}}get from(){return this._from}set from(b){if(this._from!==b){this._from=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].fromFrame=this._from}}}get to(){return this._to}set to(b){if(this._to!==b){this._to=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(b){if(this._speedRatio!==b){this._speedRatio=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(b){if(this._loopAnimation!==b){this._loopAnimation=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(b){if(this._isAdditive!==b){this._isAdditive=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(b){this._weight!==b&&(this._weight=b,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(b){if(this._playOrder!==b&&(this._playOrder=b,this._animatables.length>0)){for(let b=0;b<this._animatables.length;b++)this._animatables[b].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(b){if(this._enableBlending!==b&&(this._enableBlending=b,null!==b))for(let d=0;d<this._targetedAnimations.length;++d)this._targetedAnimations[d].animation.enableBlending=b}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(b){if(this._blendingSpeed!==b&&(this._blendingSpeed=b,null!==b))for(let d=0;d<this._targetedAnimations.length;++d)this._targetedAnimations[d].animation.blendingSpeed=b}getLength(b,d){b=b??this._from;return((d=d??this._to)-b)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(b){let d=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],G=arguments.length>3?arguments[3]:void 0;if(0===b.length)return null;G=G??b[0].weight;let W=Number.MAX_VALUE,i=-Number.MAX_VALUE;if(P)for(const C of b)C.from<W&&(W=C.from),C.to>i&&(i=C.to);const q=new n(b[0].name+"_merged",b[0]._scene,G);for(const C of b){P&&C.normalize(W,i);for(const b of C.targetedAnimations)q.addTargetedAnimation(b.animation,b.target);d&&C.dispose()}return q}constructor(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=b,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new W.d,this.onAnimationLoopObservable=new W.d,this.onAnimationGroupLoopObservable=new W.d,this.onAnimationGroupEndObservable=new W.d,this.onAnimationGroupPauseObservable=new W.d,this.onAnimationGroupPlayObservable=new W.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=d||i.e.LastCreatedScene,this._weight=P,this._playOrder=G,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(b,d){const P=new B;P.animation=b,P.target=d;const G=b.getKeys();return this._from>G[0].frame&&(this._from=G[0].frame),this._to<G[G.length-1].frame&&(this._to=G[G.length-1].frame),null!==this._enableBlending&&(b.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(b.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(P),this._shouldStart=!0,P}removeTargetedAnimation(b){for(let d=this._targetedAnimations.length-1;d>-1;d--){this._targetedAnimations[d].animation===b&&this._targetedAnimations.splice(d,1)}}normalize(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==b&&(b=this._from),null==d&&(d=this._to);for(let P=0;P<this._targetedAnimations.length;P++){const G=this._targetedAnimations[P].animation.getKeys(),W=G[0],i=G[G.length-1];if(W.frame>b){const d={frame:b,value:W.value,inTangent:W.inTangent,outTangent:W.outTangent,interpolation:W.interpolation};G.splice(0,0,d)}if(i.frame<d){const b={frame:d,value:i.value,inTangent:i.inTangent,outTangent:i.outTangent,interpolation:i.interpolation};G.push(b)}}return this._from=b,this._to=d,this}_processLoop(b,d,P){b.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(d),this._animationLoopFlags[P]||(this._animationLoopFlags[P]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0],d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0,G=arguments.length>3?arguments[3]:void 0,W=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=b,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let i=0;i<this._targetedAnimations.length;i++){const q=this._targetedAnimations[i],C=this._scene.beginDirectAnimation(q.target,[q.animation],void 0!==P?P:this._from,void 0!==G?G:this._to,b,d,void 0,void 0,void 0!==W?W:this._isAdditive);C.weight=this._weight,C.playOrder=this._playOrder,C.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(q),this._checkAnimationGroupEnded(C)},this._processLoop(C,q,i),this._animatables.push(C)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=d,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let b=0;b<this._animatables.length;b++){this._animatables[b].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(b){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==b&&(this.loopAnimation=b),this.restart()):(this.stop(),this.start(b,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].reset()}return this}restart(){if(!this._isStarted)return this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const d=this._animatables.slice();for(let G=0;G<d.length;G++)d[G].stop(void 0,void 0,!0,b);let P=0;for(let G=0;G<this._scene._activeAnimatables.length;G++){const d=this._scene._activeAnimatables[G];d._runtimeAnimations.length>0?this._scene._activeAnimatables[P++]=d:b&&this._checkAnimationGroupEnded(d,b)}return this._scene._activeAnimatables.length=P,this._isStarted=!1,this}setWeightForAllAnimatables(b){for(let d=0;d<this._animatables.length;d++){this._animatables[d].weight=b}return this}syncAllAnimationsWith(b){for(let d=0;d<this._animatables.length;d++){this._animatables[d].syncWith(b)}return this}goToFrame(b){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let P=0;P<this._animatables.length;P++){this._animatables[P].goToFrame(b,d)}return this}getCurrentFrame(){var b;return(null===(b=this.animatables[0])||void 0===b?void 0:b.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const b=this._scene.animationGroups.indexOf(this);if(b>-1&&this._scene.animationGroups.splice(b,1),this._parentContainer){const b=this._parentContainer.animationGroups.indexOf(this);b>-1&&this._parentContainer.animationGroups.splice(b,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(b){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const P=this._animatables.indexOf(b);P>-1&&this._animatables.splice(P,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,d||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(b,d){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const G=new n(b||this.name,this._scene,this._weight,this._playOrder);G._from=this.from,G._to=this.to,G._speedRatio=this.speedRatio,G._loopAnimation=this.loopAnimation,G._isAdditive=this.isAdditive,G._enableBlending=this.enableBlending,G._blendingSpeed=this.blendingSpeed,G.metadata=this.metadata,G.mask=this.mask;for(const W of this._targetedAnimations)G.addTargetedAnimation(P?W.animation.clone():W.animation,d?d(W.target):W.target);return G}serialize(){const b={};b.name=this.name,b.from=this.from,b.to=this.to,b.speedRatio=this.speedRatio,b.loopAnimation=this.loopAnimation,b.isAdditive=this.isAdditive,b.weight=this.weight,b.playOrder=this.playOrder,b.enableBlending=this.enableBlending,b.blendingSpeed=this.blendingSpeed,b.targetedAnimations=[];for(let d=0;d<this.targetedAnimations.length;d++){const P=this.targetedAnimations[d];b.targetedAnimations[d]=P.serialize()}return q.c&&q.c.HasTags(this)&&(b.tags=q.c.GetTags(this)),this.metadata&&(b.metadata=this.metadata),b}static Parse(b,d){const P=new n(b.name,d,b.weight,b.playOrder);for(let W=0;W<b.targetedAnimations.length;W++){const i=b.targetedAnimations[W],q=G.b.Parse(i.animation),C=i.targetId;if("influence"===i.animation.property){const b=d.getMorphTargetById(C);b&&P.addTargetedAnimation(q,b)}else{const b=d.getNodeById(C);null!=b&&P.addTargetedAnimation(q,b)}}return q.c&&q.c.AddTagsTo(P,b.tags),null!==b.from&&null!==b.to&&P.normalize(b.from,b.to),void 0!==b.speedRatio&&(P._speedRatio=b.speedRatio),void 0!==b.loopAnimation&&(P._loopAnimation=b.loopAnimation),void 0!==b.isAdditive&&(P._isAdditive=b.isAdditive),void 0!==b.weight&&(P._weight=b.weight),void 0!==b.playOrder&&(P._playOrder=b.playOrder),void 0!==b.enableBlending&&(P._enableBlending=b.enableBlending),void 0!==b.blendingSpeed&&(P._blendingSpeed=b.blendingSpeed),void 0!==b.metadata&&(P.metadata=b.metadata),P}static MakeAnimationAdditive(b,d,P){let W;W="object"===typeof d?d:{referenceFrame:d,range:P,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let i=b;W.cloneOriginalAnimationGroup&&(i=b.clone(W.clonedAnimationGroupName||i.name));const q=i.targetedAnimations;for(let C=0;C<q.length;C++){const b=q[C];b.animation=G.b.MakeAnimationAdditive(b.animation,W)}if(i.isAdditive=!0,W.clipKeys){let b=Number.MAX_VALUE,d=-Number.MAX_VALUE;const P=i.targetedAnimations;for(let G=0;G<P.length;G++){const W=P[G].animation.getKeys();b>W[0].frame&&(b=W[0].frame),d<W[W.length-1].frame&&(d=W[W.length-1].frame)}i._from=b,i._to=d}return i}static ClipKeys(b,d,P,G,W){const i=b.clone(G||b.name);return n.ClipKeysInPlace(i,d,P,W)}static ClipKeysInPlace(b,d,P,G){return n.ClipInPlace(b,d,P,G,!1)}static ClipFrames(b,d,P,G,W){const i=b.clone(G||b.name);return n.ClipFramesInPlace(i,d,P,W)}static ClipFramesInPlace(b,d,P,G){return n.ClipInPlace(b,d,P,G,!0)}static ClipInPlace(b,d,P,G){let W=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=Number.MAX_VALUE,q=-Number.MAX_VALUE;const C=b.targetedAnimations;for(let J=0;J<C.length;J++){const b=C[J],L=G?b.animation:b.animation.clone();W&&(L.createKeyForFrame(d),L.createKeyForFrame(P));const x=L.getKeys(),Y=[];let s=Number.MAX_VALUE;for(let G=0;G<x.length;G++){const b=x[G];if(!W&&G>=d&&G<=P||W&&b.frame>=d&&b.frame<=P){const d={frame:b.frame,value:b.value.clone?b.value.clone():b.value,inTangent:b.inTangent,outTangent:b.outTangent,interpolation:b.interpolation,lockedTangent:b.lockedTangent};s===Number.MAX_VALUE&&(s=d.frame),d.frame-=s,Y.push(d)}}0!==Y.length?(i>Y[0].frame&&(i=Y[0].frame),q<Y[Y.length-1].frame&&(q=Y[Y.length-1].frame),L.setKeys(Y,!0),b.animation=L):(C.splice(J,1),J--)}return b._from=i,b._to=q,b}getClassName(){return"AnimationGroup"}toString(b){let d="Name: "+this.name;return d+=", type: "+this.getClassName(),b&&(d+=", from: "+this._from,d+=", to: "+this._to,d+=", isStarted: "+this._isStarted,d+=", speedRatio: "+this._speedRatio,d+=", targetedAnimations length: "+this._targetedAnimations.length,d+=", animatables length: "+this._animatables),d}}}}]);