"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[78],{14406:(o,H,n)=>{n.r(H),n.d(H,{AnimationGroup:()=>N,TargetedAnimation:()=>J});var E=n(11717),k=n(11026),g=n(11060),O=n(11229),Y=n(12851),y=n(11189);class S{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(o,H,n,k){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=H,this._target=o,this._scene=n,this._host=k,this._activeTargets=[],H._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===E.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=y.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const o={frame:0,value:this._minValue};this._keys.splice(0,0,o)}if(this._target instanceof Array){let o=0;for(const H of this._target)this._preparePath(H,o),this._getOriginalValues(o),o++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const g=H.getEvents();if(g&&g.length>0)for(const E of g)this._events.push(E._clone());this._enableBlending=o&&o.animationPropertiesOverride?o.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this._animation.targetPropertyPath;if(n.length>1){let E=o;for(let o=0;o<n.length-1;o++){const H=n[o];if(E=E[H],void 0===E)throw new Error(`Invalid property (${H}) in property path (${n.join(".")})`)}this._targetPath=n[n.length-1],this._activeTargets[H]=E}else this._targetPath=n[0],this._activeTargets[H]=o;if(void 0===this._activeTargets[H][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${n.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let o=0;for(const H of this._target)void 0!==this._originalValue[o]&&this._setValue(H,this._activeTargets[o],this._originalValue[o],-1,o),o++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let o=0;o<this._events.length;o++)this._events[o].isDone=!1}isStopped(){return this._stopped}dispose(){const o=this._animation.runtimeAnimations.indexOf(this);o>-1&&this._animation.runtimeAnimations.splice(o,1)}setValue(o,H){if(this._targetIsArray)for(let n=0;n<this._target.length;n++){const E=this._target[n];this._setValue(E,this._activeTargets[n],o,H,n)}else this._setValue(this._target,this._directTarget,o,H,0)}_getOriginalValues(){let o,H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=this._activeTargets[H];o=n.getLocalMatrix&&"_matrix"===this._targetPath?n.getLocalMatrix():n[this._targetPath],o&&o.clone?this._originalValue[H]=o.clone():this._originalValue[H]=o}_registerTargetForLateAnimationBinding(o,H){const n=o.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(n),n._lateAnimationHolders||(n._lateAnimationHolders={}),n._lateAnimationHolders[o.targetPath]||(n._lateAnimationHolders[o.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:H}),o.isAdditive?(n._lateAnimationHolders[o.targetPath].additiveAnimations.push(o),n._lateAnimationHolders[o.targetPath].totalAdditiveWeight+=o.weight):(n._lateAnimationHolders[o.targetPath].animations.push(o),n._lateAnimationHolders[o.targetPath].totalWeight+=o.weight)}_setValue(o,H,n,k,g){if(this._currentActiveTarget=H,this._weight=k,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const o=H[this._targetPath];o.clone?this._originalBlendValue=o.clone():this._originalBlendValue=o}this._originalBlendValue.m?E.b.AllowMatrixDecomposeForInterpolation?this._currentValue?y.Matrix.DecomposeLerpToRef(this._originalBlendValue,n,this._blendingFactor,this._currentValue):this._currentValue=y.Matrix.DecomposeLerp(this._originalBlendValue,n,this._blendingFactor):this._currentValue?y.Matrix.LerpToRef(this._originalBlendValue,n,this._blendingFactor,this._currentValue):this._currentValue=y.Matrix.Lerp(this._originalBlendValue,n,this._blendingFactor):this._currentValue=E.b._UniversalLerp(this._originalBlendValue,n,this._blendingFactor);const k=o&&o.animationPropertiesOverride?o.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=k}else this._currentValue?this._currentValue.S?this._currentValue.S(n):this._currentValue=n:null!==n&&void 0!==n&&n.clone?this._currentValue=n.clone():this._currentValue=n;-1!==k?this._registerTargetForLateAnimationBinding(this,this._originalValue[g]):this._animationState.loopMode===E.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[g],H[this._targetPath]):H[this._targetPath]=this._originalValue[g]+this._currentValue:H[this._targetPath]=this._currentValue,o.KS&&o.KS(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=this._animation.getKeys();o<n[0].frame?o=n[0].frame:o>n[n.length-1].frame&&(o=n[n.length-1].frame);const E=this._events;if(E.length)for(let g=0;g<E.length;g++)E[g].onlyOnce||(E[g].isDone=E[g].frame<o);this._currentFrame=o;const k=this._animation._interpolate(o,this._animationState);this.setValue(k,H)}_prepareForSpeedRatioChange(o){const H=this._previousElapsedTime*(this._animation.framePerSecond*o)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-H}animate(o,H,n,k,g){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const Y=this._animation,y=Y.targetPropertyPath;if(!y||y.length<1)return this._stopped=!0,!1;let S,G=!0;const c=this._events;let A=0;if(this._coreRuntimeAnimation)A=n-H,S=this._coreRuntimeAnimation.currentFrame,this._currentFrame=S,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let O;(H<this._minFrame||H>this._maxFrame)&&(H=this._minFrame),(n<this._minFrame||n>this._maxFrame)&&(n=this._maxFrame),A=n-H;let y=o*(Y.framePerSecond*g)/1e3+this._absoluteFrameOffset,l=0,x=!1;const z=k&&this._animationState.loopMode===E.b.ANIMATIONLOOPMODE_YOYO;if(z){const o=(y-H)/A,n=Math.sin(o*Math.PI);y=Math.abs(n)*A+H;const E=n>=0?1:-1;this._yoyoDirection!==E&&(x=!0),this._yoyoDirection=E}if(this._previousElapsedTime=o,this._previousAbsoluteFrame=y,!k&&n>=H&&(y>=A&&g>0||y<=0&&g<0))G=!1,l=Y._getKeyValue(this._maxValue);else if(!k&&H>=n&&(y<=A&&g<0||y>=0&&g>0))G=!1,l=Y._getKeyValue(this._minValue);else if(this._animationState.loopMode!==E.b.ANIMATIONLOOPMODE_CYCLE){const o=n.toString()+H.toString();if(!this._offsetsCache[o]){this._animationState.repeatCount=0,this._animationState.loopMode=E.b.ANIMATIONLOOPMODE_CYCLE;const k=Y._interpolate(H,this._animationState),g=Y._interpolate(n,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),Y.dataType){case E.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[o]=g-k;break;case E.b.ANIMATIONTYPE_QUATERNION:case E.b.ANIMATIONTYPE_VECTOR3:case E.b.ANIMATIONTYPE_VECTOR2:case E.b.ANIMATIONTYPE_SIZE:case E.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[o]=g.zH(k)}this._highLimitsCache[o]=g}l=this._highLimitsCache[o],O=this._offsetsCache[o]}if(void 0===O)switch(Y.dataType){case E.b.ANIMATIONTYPE_FLOAT:O=0;break;case E.b.ANIMATIONTYPE_QUATERNION:O=E.h;break;case E.b.ANIMATIONTYPE_VECTOR3:O=E.p;break;case E.b.ANIMATIONTYPE_VECTOR2:O=E.l;break;case E.b.ANIMATIONTYPE_SIZE:O=E.i;break;case E.b.ANIMATIONTYPE_COLOR3:O=E.c;break;case E.b.ANIMATIONTYPE_COLOR4:O=E.d}if(this._host&&this._host.syncRoot){const o=this._host.syncRoot;S=H+A*((o.masterFrame-o.fromFrame)/(o.toFrame-o.fromFrame))}else S=y>0&&H>n||y<0&&H<n?G&&0!==A?n+y%A:H:G&&0!==A?H+y%A:n;if(!z&&(g>0&&this.currentFrame>S||g<0&&this.currentFrame<S)||z&&x){this._onLoop();for(let o=0;o<c.length;o++)c[o].onlyOnce||(c[o].isDone=!1);this._animationState.key=g>0?0:Y.getKeys().length-1}this._currentFrame=S,this._animationState.repeatCount=0===A?0:y/A|0,this._animationState.highLimitValue=l,this._animationState.offsetValue=O}const l=Y._interpolate(S,this._animationState);if(this.setValue(l,O),c.length)for(let E=0;E<c.length;E++)if(A>=0&&S>=c[E].frame&&c[E].frame>=H||A<0&&S<=c[E].frame&&c[E].frame<=H){const o=c[E];o.isDone||(o.onlyOnce&&(c.splice(E,1),E--),o.isDone=!0,o.action(S))}return G||(this._stopped=!0),G}}var G=n(11042);class c{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(o){this._weight=-1!==o?Math.min(Math.max(o,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(o){for(let H=0;H<this._runtimeAnimations.length;H++){this._runtimeAnimations[H]._prepareForSpeedRatioChange(o)}this._speedRatio=o,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(o,H){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,g=arguments.length>4&&void 0!==arguments[4]&&arguments[4],O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,y=arguments.length>7?arguments[7]:void 0,S=arguments.length>8?arguments[8]:void 0,G=arguments.length>9&&void 0!==arguments[9]&&arguments[9],c=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=H,this.fromFrame=n,this.toFrame=E,this.loopAnimation=g,this.onAnimationEnd=Y,this.onAnimationLoop=S,this.isAdditive=G,this.playOrder=c,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.yY=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new k.d,this.onAnimationLoopObservable=new k.d,this._scene=o,y&&this.appendAnimations(H,y),this._speedRatio=O,o._activeAnimatables.push(this)}syncWith(o){if(this._syncRoot=o,o){const o=this._scene._activeAnimatables.indexOf(this);o>-1&&(this._scene._activeAnimatables.splice(o,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(o,H){for(let n=0;n<H.length;n++){const E=H[n],k=new S(o,E,this._scene,this);k._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(k)}}getAnimationByTargetProperty(o){const H=this._runtimeAnimations;for(let n=0;n<H.length;n++)if(H[n].animation.targetProperty===o)return H[n].animation;return null}getRuntimeAnimationByTargetProperty(o){const H=this._runtimeAnimations;for(let n=0;n<H.length;n++)if(H[n].animation.targetProperty===o)return H[n];return null}reset(){const o=this._runtimeAnimations;for(let H=0;H<o.length;H++)o[H].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(o){const H=this._runtimeAnimations;for(let n=0;n<H.length;n++)H[n].animation.enableBlending=!0,H[n].animation.blendingSpeed=o}disableBlending(){const o=this._runtimeAnimations;for(let H=0;H<o.length;H++)o[H].animation.enableBlending=!1}goToFrame(o){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=this._runtimeAnimations;if(n[0]){const H=n[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??n[0].currentFrame;const E=0===this.speedRatio?0:(o-this._frameToSyncFromJump)/H*1e3/this.speedRatio;this._manualJumpDelay=-E}for(let E=0;E<n.length;E++)n[E].goToFrame(o,H?this._weight:-1);this._goToFrame=o}get paused(){return this.yY}pause(){this.yY||(this.yY=!0)}restart(){this.yY=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(o,H){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(o||H){const k=this._scene._activeAnimatables.indexOf(this);if(k>-1){const g=this._runtimeAnimations;for(let n=g.length-1;n>=0;n--){const E=g[n];o&&E.animation.name!=o||(H&&!H(E.target)||(E.dispose(),g.splice(n,1)))}0==g.length&&(n||this._scene._activeAnimatables.splice(k,1),E||this._raiseOnAnimationEnd())}}else{const o=this._scene._activeAnimatables.indexOf(this);if(o>-1){n||this._scene._activeAnimatables.splice(o,1);const H=this._runtimeAnimations;for(let o=0;o<H.length;o++)H[o].dispose();this._runtimeAnimations.length=0,E||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((o=>{this.onAnimationEndObservable.add((()=>{o(this)}),void 0,void 0,this,!0)}))}_animate(o){if(this.yY)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=o),!0;if(null===this._localDelayOffset?(this._localDelayOffset=o,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=o-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let H=!1;const n=this._runtimeAnimations;let E;for(E=0;E<n.length;E++){const k=n[E].animate(o-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);H=H||k}if(this.animationStarted=H,!H){if(this.disposeOnEnd)for(E=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(E,1),E=0;E<n.length;E++)n[E].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return H}}function A(o){if(0===o.totalWeight&&0===o.totalAdditiveWeight)return o.originalValue;let H=1;const n=y.TmpVectors.xH[0],E=y.TmpVectors.xH[1],k=y.TmpVectors.Quaternion[0];let g=0;const O=o.animations[0],Y=o.originalValue;let S=1,G=!1;if(o.totalWeight<1)S=1-o.totalWeight,Y.decompose(E,k,n);else{if(g=1,H=o.totalWeight,S=O.weight/H,1==S){if(!o.totalAdditiveWeight)return O.currentValue;G=!0}O.currentValue.decompose(E,k,n)}if(!G){E.scaleInPlace(S),n.scaleInPlace(S),k.scaleInPlace(S);for(let O=g;O<o.animations.length;O++){const g=o.animations[O];if(0===g.weight)continue;S=g.weight/H;const Y=y.TmpVectors.xH[2],G=y.TmpVectors.xH[3],c=y.TmpVectors.Quaternion[1];g.currentValue.decompose(G,c,Y),G.scaleAndAddToRef(S,E),c.scaleAndAddToRef(y.Quaternion.Dot(k,c)>0?S:-S,k),Y.scaleAndAddToRef(S,n)}k.normalize()}for(let A=0;A<o.additiveAnimations.length;A++){const H=o.additiveAnimations[A];if(0===H.weight)continue;const g=y.TmpVectors.xH[2],O=y.TmpVectors.xH[3],Y=y.TmpVectors.Quaternion[1];H.currentValue.decompose(O,Y,g),O.multiplyToRef(E,O),y.xH.LerpToRef(E,O,H.weight,E),k.multiplyToRef(Y,Y),y.Quaternion.SlerpToRef(k,Y,H.weight,k),g.scaleAndAddToRef(H.weight,n)}const c=O?O._animationState.workValue:y.TmpVectors.Matrix[0].clone();return y.Matrix.ComposeToRef(E,k,n,c),c}function l(o,H){if(0===o.totalWeight&&0===o.totalAdditiveWeight)return H;const n=o.animations[0],E=o.originalValue;let k=H;if(0===o.totalWeight&&o.totalAdditiveWeight>0)k.S(E);else if(1===o.animations.length){if(y.Quaternion.SlerpToRef(E,n.currentValue,Math.min(1,o.totalWeight),k),0===o.totalAdditiveWeight)return k}else if(o.animations.length>1){let n,g,O=1;if(o.totalWeight<1){const H=1-o.totalWeight;n=[],g=[],n.push(E),g.push(H)}else{if(2===o.animations.length&&(y.Quaternion.SlerpToRef(o.animations[0].currentValue,o.animations[1].currentValue,o.animations[1].weight/o.totalWeight,H),0===o.totalAdditiveWeight))return H;n=[],g=[],O=o.totalWeight}for(let H=0;H<o.animations.length;H++){const E=o.animations[H];n.push(E.currentValue),g.push(E.weight/O)}let Y=0;for(let o=0;o<n.length;)o?(Y+=g[o],y.Quaternion.SlerpToRef(k,n[o],g[o]/Y,k),o++):(y.Quaternion.SlerpToRef(n[o],n[o+1],g[o+1]/(g[o]+g[o+1]),H),k=H,Y=g[o]+g[o+1],o+=2)}for(let g=0;g<o.additiveAnimations.length;g++){const H=o.additiveAnimations[g];0!==H.weight&&(k.multiplyToRef(H.currentValue,y.TmpVectors.Quaternion[0]),y.Quaternion.SlerpToRef(k,y.TmpVectors.Quaternion[0],H.weight,k))}return k}var x,z,V=n(11435);x=V.c,(z=Y.b)&&(z.prototype.copyAnimationRange=function(o,H,n){let k=arguments.length>3&&void 0!==arguments[3]&&arguments[3],g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new E.b(this.name,"_matrix",o.animations[0].framePerSecond,E.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const O=o.animations[0].getRange(H);if(!O)return!1;const Y=O.from,y=O.to,S=o.animations[0].getKeys(),G=o.length,c=o.getParent(),A=this.getParent(),l=k&&c&&G&&this.length&&G!==this.length,x=l&&A&&c?A.length/c.length:1,z=k&&!A&&g&&(1!==g.x||1!==g.y||1!==g.z),V=this.animations[0].getKeys();let J,N,h;for(let E=0,Q=S.length;E<Q;E++)J=S[E],J.frame>=Y&&J.frame<=y&&(k?(h=J.value.clone(),l?(N=h.getTranslation(),h.setTranslation(N.scaleInPlace(x))):z&&g?(N=h.getTranslation(),h.setTranslation(N.multiplyInPlace(g))):h=J.value):h=J.value,V.push({frame:J.frame+n,value:h}));return this.animations[0].createRange(H,Y+n,y+n),!0}),x&&(x.prototype._animate=function(o){if(!this.animationsEnabled)return;const H=G.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=H}this.deltaTime=void 0!==o?o:this.useConstantAnimationDeltaTime?16:(H-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=H;const n=this._activeAnimatables;if(0===n.length)return;this._animationTime+=this.deltaTime;const k=this._animationTime;for(let E=0;E<n.length;E++){const o=n[E];!o._animate(k)&&o.disposeOnEnd&&E--}!function(o){if(o._registeredForLateAnimationBindings.length){for(let H=0;H<o._registeredForLateAnimationBindings.length;H++){const n=o._registeredForLateAnimationBindings.data[H];for(const o in n._lateAnimationHolders){const H=n._lateAnimationHolders[o],k=H.animations[0],g=H.originalValue;if(void 0===g||null===g)continue;const O=E.b.AllowMatrixDecomposeForInterpolation&&g.m;let Y=n[o];if(O)Y=A(H);else if(void 0!==g.w)Y=l(H,Y||y.Quaternion.Identity());else{let o=0,n=1;const O=k&&k._animationState.loopMode===E.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(H.totalWeight<1)Y=O?g.clone?g.clone():g:k&&g.scale?g.scale(1-H.totalWeight):k?g*(1-H.totalWeight):g.clone?g.clone():g;else if(k){n=H.totalWeight;const E=k.weight/n;Y=1!==E?k.currentValue.scale?k.currentValue.scale(E):k.currentValue*E:k.currentValue,O&&(Y.addToRef?Y.addToRef(g,Y):Y+=g),o=1}for(let E=o;E<H.animations.length;E++){const o=H.animations[E],k=o.weight/n;k&&(o.currentValue.scaleAndAddToRef?o.currentValue.scaleAndAddToRef(k,Y):Y+=o.currentValue*k)}for(let E=0;E<H.additiveAnimations.length;E++){const o=H.additiveAnimations[E],n=o.weight;n&&(o.currentValue.scaleAndAddToRef?o.currentValue.scaleAndAddToRef(n,Y):Y+=o.currentValue*n)}}n[o]=Y}n._lateAnimationHolders={}}o._registeredForLateAnimationBindings.reset()}}(this)},x.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((o,H)=>o.playOrder-H.playOrder))},x.prototype.beginWeightedAnimation=function(o,H,n){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,k=arguments.length>4?arguments[4]:void 0,g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,O=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7?arguments[7]:void 0,y=arguments.length>8?arguments[8]:void 0,S=arguments.length>9?arguments[9]:void 0,G=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const c=this.beginAnimation(o,H,n,k,g,O,Y,!1,y,S,G);return c.weight=E,c},x.prototype.beginAnimation=function(o,H,n,E){let k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,g=arguments.length>5?arguments[5]:void 0,O=arguments.length>6?arguments[6]:void 0,Y=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],y=arguments.length>8?arguments[8]:void 0,S=arguments.length>9?arguments[9]:void 0,G=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(k<0){const o=H;H=n,n=o,k=-k}H>n&&(k=-k),Y&&this.stopAnimation(o,void 0,y),O||(O=new c(this,o,H,n,E,k,g,void 0,S,G));const A=!y||y(o);if(o.animations&&A&&O.appendAnimations(o,o.animations),o.getAnimatables){const G=o.getAnimatables();for(let o=0;o<G.length;o++)this.beginAnimation(G[o],H,n,E,k,g,O,Y,y,S)}return O.reset(),O},x.prototype.beginHierarchyAnimation=function(o,H,n,E,k){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,O=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7?arguments[7]:void 0,y=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],S=arguments.length>9?arguments[9]:void 0,G=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const c=o.getDescendants(H),A=[];A.push(this.beginAnimation(o,n,E,k,g,O,Y,y,S,void 0,G));for(const l of c)A.push(this.beginAnimation(l,n,E,k,g,O,Y,y,S,void 0,G));return A},x.prototype.beginDirectAnimation=function(o,H,n,E,k){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(g<0){const o=n;n=E,E=o,g=-g}return n>E&&(g=-g),new c(this,o,n,E,k,g,arguments.length>6?arguments[6]:void 0,H,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},x.prototype.beginDirectHierarchyAnimation=function(o,H,n,E,k,g,O,Y,y){let S=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const G=o.getDescendants(H),c=[];c.push(this.beginDirectAnimation(o,n,E,k,g,O,Y,y,S));for(const A of G)c.push(this.beginDirectAnimation(A,n,E,k,g,O,Y,y,S));return c},x.prototype.getAnimatableByTarget=function(o){for(let H=0;H<this._activeAnimatables.length;H++)if(this._activeAnimatables[H].target===o)return this._activeAnimatables[H];return null},x.prototype.getAllAnimatablesByTarget=function(o){const H=[];for(let n=0;n<this._activeAnimatables.length;n++)this._activeAnimatables[n].target===o&&H.push(this._activeAnimatables[n]);return H},x.prototype.stopAnimation=function(o,H,n){const E=this.getAllAnimatablesByTarget(o);for(const k of E)k.stop(H,n)},x.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let o=0;o<this._activeAnimatables.length;o++)this._activeAnimatables[o].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const o of this.animationGroups)o.stop()});class J{getClassName(){return"TargetedAnimation"}serialize(){const o={};return o.animation=this.animation.serialize(),o.targetId=this.target.id,o}}class N{get mask(){return this._mask}set mask(o){this._mask!==o&&(this._mask=o,this.syncWithMask(!0))}syncWithMask(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||o){this._numActiveAnimatables=0;for(let o=0;o<this._animatables.length;++o){const H=this._animatables[o];!this.mask||this.mask.disabled||this.mask.retainsTarget(H.target.name)?(this._numActiveAnimatables++,H.paused&&H.restart()):H.paused||H.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let o=0;o<this._animatables.length;++o){const H=this._animatables[o];this.mask.retainsTarget(H.target.name)||(H.stop(),this._animatables.splice(o,1),--o)}for(let o=0;o<this._targetedAnimations.length;o++){const H=this._targetedAnimations[o];this.mask.retainsTarget(H.target.name)||(this._targetedAnimations.splice(o,1),--o)}}}get from(){return this._from}set from(o){if(this._from!==o){this._from=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].fromFrame=this._from}}}get to(){return this._to}set to(o){if(this._to!==o){this._to=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(o){if(this._speedRatio!==o){this._speedRatio=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(o){if(this._loopAnimation!==o){this._loopAnimation=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(o){if(this._isAdditive!==o){this._isAdditive=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(o){this._weight!==o&&(this._weight=o,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(o){if(this._playOrder!==o&&(this._playOrder=o,this._animatables.length>0)){for(let o=0;o<this._animatables.length;o++)this._animatables[o].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(o){if(this._enableBlending!==o&&(this._enableBlending=o,null!==o))for(let H=0;H<this._targetedAnimations.length;++H)this._targetedAnimations[H].animation.enableBlending=o}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(o){if(this._blendingSpeed!==o&&(this._blendingSpeed=o,null!==o))for(let H=0;H<this._targetedAnimations.length;++H)this._targetedAnimations[H].animation.blendingSpeed=o}getLength(o,H){o=o??this._from;return((H=H??this._to)-o)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(o){let H=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],E=arguments.length>3?arguments[3]:void 0;if(0===o.length)return null;E=E??o[0].weight;let k=Number.MAX_VALUE,g=-Number.MAX_VALUE;if(n)for(const Y of o)Y.from<k&&(k=Y.from),Y.to>g&&(g=Y.to);const O=new N(o[0].name+"_merged",o[0]._scene,E);for(const Y of o){n&&Y.normalize(k,g);for(const o of Y.targetedAnimations)O.addTargetedAnimation(o.animation,o.target);H&&Y.dispose()}return O}constructor(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=o,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new k.d,this.onAnimationLoopObservable=new k.d,this.onAnimationGroupLoopObservable=new k.d,this.onAnimationGroupEndObservable=new k.d,this.onAnimationGroupPauseObservable=new k.d,this.onAnimationGroupPlayObservable=new k.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=H||g.e.LastCreatedScene,this._weight=n,this._playOrder=E,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(o,H){const n=new J;n.animation=o,n.target=H;const E=o.getKeys();return this._from>E[0].frame&&(this._from=E[0].frame),this._to<E[E.length-1].frame&&(this._to=E[E.length-1].frame),null!==this._enableBlending&&(o.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(o.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(n),this._shouldStart=!0,n}removeTargetedAnimation(o){for(let H=this._targetedAnimations.length-1;H>-1;H--){this._targetedAnimations[H].animation===o&&this._targetedAnimations.splice(H,1)}}normalize(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==o&&(o=this._from),null==H&&(H=this._to);for(let n=0;n<this._targetedAnimations.length;n++){const E=this._targetedAnimations[n].animation.getKeys(),k=E[0],g=E[E.length-1];if(k.frame>o){const H={frame:o,value:k.value,inTangent:k.inTangent,outTangent:k.outTangent,interpolation:k.interpolation};E.splice(0,0,H)}if(g.frame<H){const o={frame:H,value:g.value,inTangent:g.inTangent,outTangent:g.outTangent,interpolation:g.interpolation};E.push(o)}}return this._from=o,this._to=H,this}_processLoop(o,H,n){o.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(H),this._animationLoopFlags[n]||(this._animationLoopFlags[n]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0],H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,E=arguments.length>3?arguments[3]:void 0,k=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=o,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let g=0;g<this._targetedAnimations.length;g++){const O=this._targetedAnimations[g],Y=this._scene.beginDirectAnimation(O.target,[O.animation],void 0!==n?n:this._from,void 0!==E?E:this._to,o,H,void 0,void 0,void 0!==k?k:this._isAdditive);Y.weight=this._weight,Y.playOrder=this._playOrder,Y.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(O),this._checkAnimationGroupEnded(Y)},this._processLoop(Y,O,g),this._animatables.push(Y)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=H,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let o=0;o<this._animatables.length;o++){this._animatables[o].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(o){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==o&&(this.loopAnimation=o),this.restart()):(this.stop(),this.start(o,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let o=0;o<this._animatables.length;o++){this._animatables[o].reset()}return this}restart(){if(!this._isStarted)return this;for(let o=0;o<this._animatables.length;o++){this._animatables[o].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const H=this._animatables.slice();for(let E=0;E<H.length;E++)H[E].stop(void 0,void 0,!0,o);let n=0;for(let E=0;E<this._scene._activeAnimatables.length;E++){const H=this._scene._activeAnimatables[E];H._runtimeAnimations.length>0?this._scene._activeAnimatables[n++]=H:o&&this._checkAnimationGroupEnded(H,o)}return this._scene._activeAnimatables.length=n,this._isStarted=!1,this}setWeightForAllAnimatables(o){for(let H=0;H<this._animatables.length;H++){this._animatables[H].weight=o}return this}syncAllAnimationsWith(o){for(let H=0;H<this._animatables.length;H++){this._animatables[H].syncWith(o)}return this}goToFrame(o){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let n=0;n<this._animatables.length;n++){this._animatables[n].goToFrame(o,H)}return this}getCurrentFrame(){var o;return(null===(o=this.animatables[0])||void 0===o?void 0:o.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const o=this._scene.animationGroups.indexOf(this);if(o>-1&&this._scene.animationGroups.splice(o,1),this._parentContainer){const o=this._parentContainer.animationGroups.indexOf(this);o>-1&&this._parentContainer.animationGroups.splice(o,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(o){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=this._animatables.indexOf(o);n>-1&&this._animatables.splice(n,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,H||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(o,H){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=new N(o||this.name,this._scene,this._weight,this._playOrder);E._from=this.from,E._to=this.to,E._speedRatio=this.speedRatio,E._loopAnimation=this.loopAnimation,E._isAdditive=this.isAdditive,E._enableBlending=this.enableBlending,E._blendingSpeed=this.blendingSpeed,E.metadata=this.metadata,E.mask=this.mask;for(const k of this._targetedAnimations)E.addTargetedAnimation(n?k.animation.clone():k.animation,H?H(k.target):k.target);return E}serialize(){const o={};o.name=this.name,o.from=this.from,o.to=this.to,o.speedRatio=this.speedRatio,o.loopAnimation=this.loopAnimation,o.isAdditive=this.isAdditive,o.weight=this.weight,o.playOrder=this.playOrder,o.enableBlending=this.enableBlending,o.blendingSpeed=this.blendingSpeed,o.targetedAnimations=[];for(let H=0;H<this.targetedAnimations.length;H++){const n=this.targetedAnimations[H];o.targetedAnimations[H]=n.serialize()}return O.e&&O.e.HasTags(this)&&(o.tags=O.e.GetTags(this)),this.metadata&&(o.metadata=this.metadata),o}static Parse(o,H){const n=new N(o.name,H,o.weight,o.playOrder);for(let k=0;k<o.targetedAnimations.length;k++){const g=o.targetedAnimations[k],O=E.b.Parse(g.animation),Y=g.targetId;if("influence"===g.animation.property){const o=H.getMorphTargetById(Y);o&&n.addTargetedAnimation(O,o)}else{const o=H.getNodeById(Y);null!=o&&n.addTargetedAnimation(O,o)}}return O.e&&O.e.AddTagsTo(n,o.tags),null!==o.from&&null!==o.to&&n.normalize(o.from,o.to),void 0!==o.speedRatio&&(n._speedRatio=o.speedRatio),void 0!==o.loopAnimation&&(n._loopAnimation=o.loopAnimation),void 0!==o.isAdditive&&(n._isAdditive=o.isAdditive),void 0!==o.weight&&(n._weight=o.weight),void 0!==o.playOrder&&(n._playOrder=o.playOrder),void 0!==o.enableBlending&&(n._enableBlending=o.enableBlending),void 0!==o.blendingSpeed&&(n._blendingSpeed=o.blendingSpeed),void 0!==o.metadata&&(n.metadata=o.metadata),n}static MakeAnimationAdditive(o,H,n){let k;k="object"===typeof H?H:{referenceFrame:H,range:n,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let g=o;k.cloneOriginalAnimationGroup&&(g=o.clone(k.clonedAnimationGroupName||g.name));const O=g.targetedAnimations;for(let Y=0;Y<O.length;Y++){const o=O[Y];o.animation=E.b.MakeAnimationAdditive(o.animation,k)}if(g.isAdditive=!0,k.clipKeys){let o=Number.MAX_VALUE,H=-Number.MAX_VALUE;const n=g.targetedAnimations;for(let E=0;E<n.length;E++){const k=n[E].animation.getKeys();o>k[0].frame&&(o=k[0].frame),H<k[k.length-1].frame&&(H=k[k.length-1].frame)}g._from=o,g._to=H}return g}static ClipKeys(o,H,n,E,k){const g=o.clone(E||o.name);return N.ClipKeysInPlace(g,H,n,k)}static ClipKeysInPlace(o,H,n,E){return N.ClipInPlace(o,H,n,E,!1)}static ClipFrames(o,H,n,E,k){const g=o.clone(E||o.name);return N.ClipFramesInPlace(g,H,n,k)}static ClipFramesInPlace(o,H,n,E){return N.ClipInPlace(o,H,n,E,!0)}static ClipInPlace(o,H,n,E){let k=arguments.length>4&&void 0!==arguments[4]&&arguments[4],g=Number.MAX_VALUE,O=-Number.MAX_VALUE;const Y=o.targetedAnimations;for(let y=0;y<Y.length;y++){const o=Y[y],S=E?o.animation:o.animation.clone();k&&(S.createKeyForFrame(H),S.createKeyForFrame(n));const G=S.getKeys(),c=[];let A=Number.MAX_VALUE;for(let E=0;E<G.length;E++){const o=G[E];if(!k&&E>=H&&E<=n||k&&o.frame>=H&&o.frame<=n){const H={frame:o.frame,value:o.value.clone?o.value.clone():o.value,inTangent:o.inTangent,outTangent:o.outTangent,interpolation:o.interpolation,lockedTangent:o.lockedTangent};A===Number.MAX_VALUE&&(A=H.frame),H.frame-=A,c.push(H)}}0!==c.length?(g>c[0].frame&&(g=c[0].frame),O<c[c.length-1].frame&&(O=c[c.length-1].frame),S.setKeys(c,!0),o.animation=S):(Y.splice(y,1),y--)}return o._from=g,o._to=O,o}getClassName(){return"AnimationGroup"}toString(o){let H="Name: "+this.name;return H+=", type: "+this.getClassName(),o&&(H+=", from: "+this._from,H+=", to: "+this._to,H+=", isStarted: "+this._isStarted,H+=", speedRatio: "+this._speedRatio,H+=", targetedAnimations length: "+this._targetedAnimations.length,H+=", animatables length: "+this._animatables),H}}}}]);