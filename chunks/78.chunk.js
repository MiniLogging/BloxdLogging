"use strict";(self.vfdo5lmva5i=self.vfdo5lmva5i||[]).push([[78],{14986:(w,o,H)=>{H.r(o),H.d(o,{AnimationGroup:()=>V,TargetedAnimation:()=>s});var h=H(12247),E=H(11540),e=H(11571),D=H(11753),t=H(13371),X=H(11720);class L{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(w,o,H,E){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=o,this._target=w,this._scene=H,this._host=E,this._activeTargets=[],o._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===h.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=X.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const w={frame:0,value:this._minValue};this._keys.splice(0,0,w)}if(this._target instanceof Array){let w=0;for(const o of this._target)this._preparePath(o,w),this._getOriginalValues(w),w++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const e=o.getEvents();if(e&&e.length>0)for(const h of e)this._events.push(h._clone());this._enableBlending=w&&w.animationPropertiesOverride?w.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=this._animation.targetPropertyPath;if(H.length>1){let h=w;for(let w=0;w<H.length-1;w++){const o=H[w];if(h=h[o],void 0===h)throw new Error(`Invalid property (${o}) in property path (${H.join(".")})`)}this._targetPath=H[H.length-1],this._activeTargets[o]=h}else this._targetPath=H[0],this._activeTargets[o]=w;if(void 0===this._activeTargets[o][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${H.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let w=0;for(const o of this._target)void 0!==this._originalValue[w]&&this._setValue(o,this._activeTargets[w],this._originalValue[w],-1,w),w++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let w=0;w<this._events.length;w++)this._events[w].isDone=!1}isStopped(){return this._stopped}dispose(){const w=this._animation.runtimeAnimations.indexOf(this);w>-1&&this._animation.runtimeAnimations.splice(w,1)}setValue(w,o){if(this._targetIsArray)for(let H=0;H<this._target.length;H++){const h=this._target[H];this._setValue(h,this._activeTargets[H],w,o,H)}else this._setValue(this._target,this._directTarget,w,o,0)}_getOriginalValues(){let w,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const H=this._activeTargets[o];w=H.getLocalMatrix&&"_matrix"===this._targetPath?H.getLocalMatrix():H[this._targetPath],w&&w.clone?this._originalValue[o]=w.clone():this._originalValue[o]=w}_registerTargetForLateAnimationBinding(w,o){const H=w.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(H),H._lateAnimationHolders||(H._lateAnimationHolders={}),H._lateAnimationHolders[w.targetPath]||(H._lateAnimationHolders[w.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:o}),w.isAdditive?(H._lateAnimationHolders[w.targetPath].additiveAnimations.push(w),H._lateAnimationHolders[w.targetPath].totalAdditiveWeight+=w.weight):(H._lateAnimationHolders[w.targetPath].animations.push(w),H._lateAnimationHolders[w.targetPath].totalWeight+=w.weight)}_setValue(w,o,H,E,e){if(this._currentActiveTarget=o,this._weight=E,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const w=o[this._targetPath];w.clone?this._originalBlendValue=w.clone():this._originalBlendValue=w}this._originalBlendValue.m?h.b.AllowMatrixDecomposeForInterpolation?this._currentValue?X.Matrix.DecomposeLerpToRef(this._originalBlendValue,H,this._blendingFactor,this._currentValue):this._currentValue=X.Matrix.DecomposeLerp(this._originalBlendValue,H,this._blendingFactor):this._currentValue?X.Matrix.LerpToRef(this._originalBlendValue,H,this._blendingFactor,this._currentValue):this._currentValue=X.Matrix.Lerp(this._originalBlendValue,H,this._blendingFactor):this._currentValue=h.b._UniversalLerp(this._originalBlendValue,H,this._blendingFactor);const E=w&&w.animationPropertiesOverride?w.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=E}else this._currentValue?this._currentValue.t?this._currentValue.t(H):this._currentValue=H:null!==H&&void 0!==H&&H.clone?this._currentValue=H.clone():this._currentValue=H;-1!==E?this._registerTargetForLateAnimationBinding(this,this._originalValue[e]):this._animationState.loopMode===h.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[e],o[this._targetPath]):o[this._targetPath]=this._originalValue[e]+this._currentValue:o[this._targetPath]=this._currentValue,w.dL&&w.dL(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const H=this._animation.getKeys();w<H[0].frame?w=H[0].frame:w>H[H.length-1].frame&&(w=H[H.length-1].frame);const h=this._events;if(h.length)for(let e=0;e<h.length;e++)h[e].onlyOnce||(h[e].isDone=h[e].frame<w);this._currentFrame=w;const E=this._animation._interpolate(w,this._animationState);this.setValue(E,o)}_prepareForSpeedRatioChange(w){const o=this._previousElapsedTime*(this._animation.framePerSecond*w)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-o}animate(w,o,H,E,e){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const t=this._animation,X=t.targetPropertyPath;if(!X||X.length<1)return this._stopped=!0,!1;let L,A=!0;const y=this._events;let z=0;if(this._coreRuntimeAnimation)z=H-o,L=this._coreRuntimeAnimation.currentFrame,this._currentFrame=L,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let D;(o<this._minFrame||o>this._maxFrame)&&(o=this._minFrame),(H<this._minFrame||H>this._maxFrame)&&(H=this._maxFrame),z=H-o;let X=w*(t.framePerSecond*e)/1e3+this._absoluteFrameOffset,C=0,Q=!1;const M=E&&this._animationState.loopMode===h.b.ANIMATIONLOOPMODE_YOYO;if(M){const w=(X-o)/z,H=Math.sin(w*Math.PI);X=Math.abs(H)*z+o;const h=H>=0?1:-1;this._yoyoDirection!==h&&(Q=!0),this._yoyoDirection=h}if(this._previousElapsedTime=w,this._previousAbsoluteFrame=X,!E&&H>=o&&(X>=z&&e>0||X<=0&&e<0))A=!1,C=t._getKeyValue(this._maxValue);else if(!E&&o>=H&&(X<=z&&e<0||X>=0&&e>0))A=!1,C=t._getKeyValue(this._minValue);else if(this._animationState.loopMode!==h.b.ANIMATIONLOOPMODE_CYCLE){const w=H.toString()+o.toString();if(!this._offsetsCache[w]){this._animationState.repeatCount=0,this._animationState.loopMode=h.b.ANIMATIONLOOPMODE_CYCLE;const E=t._interpolate(o,this._animationState),e=t._interpolate(H,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),t.dataType){case h.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[w]=e-E;break;case h.b.ANIMATIONTYPE_QUATERNION:case h.b.ANIMATIONTYPE_VECTOR3:case h.b.ANIMATIONTYPE_VECTOR2:case h.b.ANIMATIONTYPE_SIZE:case h.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[w]=e.so(E)}this._highLimitsCache[w]=e}C=this._highLimitsCache[w],D=this._offsetsCache[w]}if(void 0===D)switch(t.dataType){case h.b.ANIMATIONTYPE_FLOAT:D=0;break;case h.b.ANIMATIONTYPE_QUATERNION:D=h.f;break;case h.b.ANIMATIONTYPE_VECTOR3:D=h.r;break;case h.b.ANIMATIONTYPE_VECTOR2:D=h.n;break;case h.b.ANIMATIONTYPE_SIZE:D=h.j;break;case h.b.ANIMATIONTYPE_COLOR3:D=h.c;break;case h.b.ANIMATIONTYPE_COLOR4:D=h.d}if(this._host&&this._host.syncRoot){const w=this._host.syncRoot;L=o+z*((w.masterFrame-w.fromFrame)/(w.toFrame-w.fromFrame))}else L=X>0&&o>H||X<0&&o<H?A&&0!==z?H+X%z:o:A&&0!==z?o+X%z:H;if(!M&&(e>0&&this.currentFrame>L||e<0&&this.currentFrame<L)||M&&Q){this._onLoop();for(let w=0;w<y.length;w++)y[w].onlyOnce||(y[w].isDone=!1);this._animationState.key=e>0?0:t.getKeys().length-1}this._currentFrame=L,this._animationState.repeatCount=0===z?0:X/z|0,this._animationState.highLimitValue=C,this._animationState.offsetValue=D}const C=t._interpolate(L,this._animationState);if(this.setValue(C,D),y.length)for(let h=0;h<y.length;h++)if(z>=0&&L>=y[h].frame&&y[h].frame>=o||z<0&&L<=y[h].frame&&y[h].frame<=o){const w=y[h];w.isDone||(w.onlyOnce&&(y.splice(h,1),h--),w.isDone=!0,w.action(L))}return A||(this._stopped=!0),A}}var A=H(11560);class y{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(w){this._weight=-1!==w?Math.min(Math.max(w,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(w){for(let o=0;o<this._runtimeAnimations.length;o++){this._runtimeAnimations[o]._prepareForSpeedRatioChange(w)}this._speedRatio=w,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(w,o){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,e=arguments.length>4&&void 0!==arguments[4]&&arguments[4],D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,t=arguments.length>6?arguments[6]:void 0,X=arguments.length>7?arguments[7]:void 0,L=arguments.length>8?arguments[8]:void 0,A=arguments.length>9&&void 0!==arguments[9]&&arguments[9],y=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=o,this.fromFrame=H,this.toFrame=h,this.loopAnimation=e,this.onAnimationEnd=t,this.onAnimationLoop=L,this.isAdditive=A,this.playOrder=y,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.St=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new E.b,this.onAnimationLoopObservable=new E.b,this._scene=w,X&&this.appendAnimations(o,X),this._speedRatio=D,w._activeAnimatables.push(this)}syncWith(w){if(this._syncRoot=w,w){const w=this._scene._activeAnimatables.indexOf(this);w>-1&&(this._scene._activeAnimatables.splice(w,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(w,o){for(let H=0;H<o.length;H++){const h=o[H],E=new L(w,h,this._scene,this);E._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(E)}}getAnimationByTargetProperty(w){const o=this._runtimeAnimations;for(let H=0;H<o.length;H++)if(o[H].animation.targetProperty===w)return o[H].animation;return null}getRuntimeAnimationByTargetProperty(w){const o=this._runtimeAnimations;for(let H=0;H<o.length;H++)if(o[H].animation.targetProperty===w)return o[H];return null}reset(){const w=this._runtimeAnimations;for(let o=0;o<w.length;o++)w[o].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(w){const o=this._runtimeAnimations;for(let H=0;H<o.length;H++)o[H].animation.enableBlending=!0,o[H].animation.blendingSpeed=w}disableBlending(){const w=this._runtimeAnimations;for(let o=0;o<w.length;o++)w[o].animation.enableBlending=!1}goToFrame(w){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const H=this._runtimeAnimations;if(H[0]){const o=H[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??H[0].currentFrame;const h=0===this.speedRatio?0:(w-this._frameToSyncFromJump)/o*1e3/this.speedRatio;this._manualJumpDelay=-h}for(let h=0;h<H.length;h++)H[h].goToFrame(w,o?this._weight:-1);this._goToFrame=w}get paused(){return this.St}pause(){this.St||(this.St=!0)}restart(){this.St=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(w,o){let H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],h=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(w||o){const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){const e=this._runtimeAnimations;for(let H=e.length-1;H>=0;H--){const h=e[H];w&&h.animation.name!=w||(o&&!o(h.target)||(h.dispose(),e.splice(H,1)))}0==e.length&&(H||this._scene._activeAnimatables.splice(E,1),h||this._raiseOnAnimationEnd())}}else{const w=this._scene._activeAnimatables.indexOf(this);if(w>-1){H||this._scene._activeAnimatables.splice(w,1);const o=this._runtimeAnimations;for(let w=0;w<o.length;w++)o[w].dispose();this._runtimeAnimations.length=0,h||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((w=>{this.onAnimationEndObservable.add((()=>{w(this)}),void 0,void 0,this,!0)}))}_animate(w){if(this.St)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=w),!0;if(null===this._localDelayOffset?(this._localDelayOffset=w,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=w-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let o=!1;const H=this._runtimeAnimations;let h;for(h=0;h<H.length;h++){const E=H[h].animate(w-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);o=o||E}if(this.animationStarted=o,!o){if(this.disposeOnEnd)for(h=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(h,1),h=0;h<H.length;h++)H[h].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return o}}function z(w){if(0===w.totalWeight&&0===w.totalAdditiveWeight)return w.originalValue;let o=1;const H=X.TmpVectors.io[0],h=X.TmpVectors.io[1],E=X.TmpVectors.Quaternion[0];let e=0;const D=w.animations[0],t=w.originalValue;let L=1,A=!1;if(w.totalWeight<1)L=1-w.totalWeight,t.decompose(h,E,H);else{if(e=1,o=w.totalWeight,L=D.weight/o,1==L){if(!w.totalAdditiveWeight)return D.currentValue;A=!0}D.currentValue.decompose(h,E,H)}if(!A){h.scaleInPlace(L),H.scaleInPlace(L),E.scaleInPlace(L);for(let D=e;D<w.animations.length;D++){const e=w.animations[D];if(0===e.weight)continue;L=e.weight/o;const t=X.TmpVectors.io[2],A=X.TmpVectors.io[3],y=X.TmpVectors.Quaternion[1];e.currentValue.decompose(A,y,t),A.scaleAndAddToRef(L,h),y.scaleAndAddToRef(X.Quaternion.Dot(E,y)>0?L:-L,E),t.scaleAndAddToRef(L,H)}E.normalize()}for(let z=0;z<w.additiveAnimations.length;z++){const o=w.additiveAnimations[z];if(0===o.weight)continue;const e=X.TmpVectors.io[2],D=X.TmpVectors.io[3],t=X.TmpVectors.Quaternion[1];o.currentValue.decompose(D,t,e),D.multiplyToRef(h,D),X.io.LerpToRef(h,D,o.weight,h),E.multiplyToRef(t,t),X.Quaternion.SlerpToRef(E,t,o.weight,E),e.scaleAndAddToRef(o.weight,H)}const y=D?D._animationState.workValue:X.TmpVectors.Matrix[0].clone();return X.Matrix.ComposeToRef(h,E,H,y),y}function C(w,o){if(0===w.totalWeight&&0===w.totalAdditiveWeight)return o;const H=w.animations[0],h=w.originalValue;let E=o;if(0===w.totalWeight&&w.totalAdditiveWeight>0)E.t(h);else if(1===w.animations.length){if(X.Quaternion.SlerpToRef(h,H.currentValue,Math.min(1,w.totalWeight),E),0===w.totalAdditiveWeight)return E}else if(w.animations.length>1){let H,e,D=1;if(w.totalWeight<1){const o=1-w.totalWeight;H=[],e=[],H.push(h),e.push(o)}else{if(2===w.animations.length&&(X.Quaternion.SlerpToRef(w.animations[0].currentValue,w.animations[1].currentValue,w.animations[1].weight/w.totalWeight,o),0===w.totalAdditiveWeight))return o;H=[],e=[],D=w.totalWeight}for(let o=0;o<w.animations.length;o++){const h=w.animations[o];H.push(h.currentValue),e.push(h.weight/D)}let t=0;for(let w=0;w<H.length;)w?(t+=e[w],X.Quaternion.SlerpToRef(E,H[w],e[w]/t,E),w++):(X.Quaternion.SlerpToRef(H[w],H[w+1],e[w+1]/(e[w]+e[w+1]),o),E=o,t=e[w]+e[w+1],w+=2)}for(let e=0;e<w.additiveAnimations.length;e++){const o=w.additiveAnimations[e];0!==o.weight&&(E.multiplyToRef(o.currentValue,X.TmpVectors.Quaternion[0]),X.Quaternion.SlerpToRef(E,X.TmpVectors.Quaternion[0],o.weight,E))}return E}var Q,M,i=H(11957);Q=i.e,(M=t.c)&&(M.prototype.copyAnimationRange=function(w,o,H){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],e=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new h.b(this.name,"_matrix",w.animations[0].framePerSecond,h.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const D=w.animations[0].getRange(o);if(!D)return!1;const t=D.from,X=D.to,L=w.animations[0].getKeys(),A=w.length,y=w.getParent(),z=this.getParent(),C=E&&y&&A&&this.length&&A!==this.length,Q=C&&z&&y?z.length/y.length:1,M=E&&!z&&e&&(1!==e.x||1!==e.y||1!==e.z),i=this.animations[0].getKeys();let s,V,r;for(let h=0,k=L.length;h<k;h++)s=L[h],s.frame>=t&&s.frame<=X&&(E?(r=s.value.clone(),C?(V=r.getTranslation(),r.setTranslation(V.scaleInPlace(Q))):M&&e?(V=r.getTranslation(),r.setTranslation(V.multiplyInPlace(e))):r=s.value):r=s.value,i.push({frame:s.frame+H,value:r}));return this.animations[0].createRange(o,t+H,X+H),!0}),Q&&(Q.prototype._animate=function(w){if(!this.animationsEnabled)return;const o=A.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=o}this.deltaTime=void 0!==w?w:this.useConstantAnimationDeltaTime?16:(o-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=o;const H=this._activeAnimatables;if(0===H.length)return;this._animationTime+=this.deltaTime;const E=this._animationTime;for(let h=0;h<H.length;h++){const w=H[h];!w._animate(E)&&w.disposeOnEnd&&h--}!function(w){if(w._registeredForLateAnimationBindings.length){for(let o=0;o<w._registeredForLateAnimationBindings.length;o++){const H=w._registeredForLateAnimationBindings.data[o];for(const w in H._lateAnimationHolders){const o=H._lateAnimationHolders[w],E=o.animations[0],e=o.originalValue;if(void 0===e||null===e)continue;const D=h.b.AllowMatrixDecomposeForInterpolation&&e.m;let t=H[w];if(D)t=z(o);else if(void 0!==e.w)t=C(o,t||X.Quaternion.Identity());else{let w=0,H=1;const D=E&&E._animationState.loopMode===h.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(o.totalWeight<1)t=D?e.clone?e.clone():e:E&&e.scale?e.scale(1-o.totalWeight):E?e*(1-o.totalWeight):e.clone?e.clone():e;else if(E){H=o.totalWeight;const h=E.weight/H;t=1!==h?E.currentValue.scale?E.currentValue.scale(h):E.currentValue*h:E.currentValue,D&&(t.addToRef?t.addToRef(e,t):t+=e),w=1}for(let h=w;h<o.animations.length;h++){const w=o.animations[h],E=w.weight/H;E&&(w.currentValue.scaleAndAddToRef?w.currentValue.scaleAndAddToRef(E,t):t+=w.currentValue*E)}for(let h=0;h<o.additiveAnimations.length;h++){const w=o.additiveAnimations[h],H=w.weight;H&&(w.currentValue.scaleAndAddToRef?w.currentValue.scaleAndAddToRef(H,t):t+=w.currentValue*H)}}H[w]=t}H._lateAnimationHolders={}}w._registeredForLateAnimationBindings.reset()}}(this)},Q.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((w,o)=>w.playOrder-o.playOrder))},Q.prototype.beginWeightedAnimation=function(w,o,H){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,E=arguments.length>4?arguments[4]:void 0,e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,D=arguments.length>6?arguments[6]:void 0,t=arguments.length>7?arguments[7]:void 0,X=arguments.length>8?arguments[8]:void 0,L=arguments.length>9?arguments[9]:void 0,A=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const y=this.beginAnimation(w,o,H,E,e,D,t,!1,X,L,A);return y.weight=h,y},Q.prototype.beginAnimation=function(w,o,H,h){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,e=arguments.length>5?arguments[5]:void 0,D=arguments.length>6?arguments[6]:void 0,t=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],X=arguments.length>8?arguments[8]:void 0,L=arguments.length>9?arguments[9]:void 0,A=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(E<0){const w=o;o=H,H=w,E=-E}o>H&&(E=-E),t&&this.stopAnimation(w,void 0,X),D||(D=new y(this,w,o,H,h,E,e,void 0,L,A));const z=!X||X(w);if(w.animations&&z&&D.appendAnimations(w,w.animations),w.getAnimatables){const A=w.getAnimatables();for(let w=0;w<A.length;w++)this.beginAnimation(A[w],o,H,h,E,e,D,t,X,L)}return D.reset(),D},Q.prototype.beginHierarchyAnimation=function(w,o,H,h,E){let e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,D=arguments.length>6?arguments[6]:void 0,t=arguments.length>7?arguments[7]:void 0,X=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],L=arguments.length>9?arguments[9]:void 0,A=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const y=w.getDescendants(o),z=[];z.push(this.beginAnimation(w,H,h,E,e,D,t,X,L,void 0,A));for(const C of y)z.push(this.beginAnimation(C,H,h,E,e,D,t,X,L,void 0,A));return z},Q.prototype.beginDirectAnimation=function(w,o,H,h,E){let e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(e<0){const w=H;H=h,h=w,e=-e}return H>h&&(e=-e),new y(this,w,H,h,E,e,arguments.length>6?arguments[6]:void 0,o,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},Q.prototype.beginDirectHierarchyAnimation=function(w,o,H,h,E,e,D,t,X){let L=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const A=w.getDescendants(o),y=[];y.push(this.beginDirectAnimation(w,H,h,E,e,D,t,X,L));for(const z of A)y.push(this.beginDirectAnimation(z,H,h,E,e,D,t,X,L));return y},Q.prototype.getAnimatableByTarget=function(w){for(let o=0;o<this._activeAnimatables.length;o++)if(this._activeAnimatables[o].target===w)return this._activeAnimatables[o];return null},Q.prototype.getAllAnimatablesByTarget=function(w){const o=[];for(let H=0;H<this._activeAnimatables.length;H++)this._activeAnimatables[H].target===w&&o.push(this._activeAnimatables[H]);return o},Q.prototype.stopAnimation=function(w,o,H){const h=this.getAllAnimatablesByTarget(w);for(const E of h)E.stop(o,H)},Q.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let w=0;w<this._activeAnimatables.length;w++)this._activeAnimatables[w].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const w of this.animationGroups)w.stop()});class s{getClassName(){return"TargetedAnimation"}serialize(){const w={};return w.animation=this.animation.serialize(),w.targetId=this.target.id,w}}class V{get mask(){return this._mask}set mask(w){this._mask!==w&&(this._mask=w,this.syncWithMask(!0))}syncWithMask(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||w){this._numActiveAnimatables=0;for(let w=0;w<this._animatables.length;++w){const o=this._animatables[w];!this.mask||this.mask.disabled||this.mask.retainsTarget(o.target.name)?(this._numActiveAnimatables++,o.paused&&o.restart()):o.paused||o.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let w=0;w<this._animatables.length;++w){const o=this._animatables[w];this.mask.retainsTarget(o.target.name)||(o.stop(),this._animatables.splice(w,1),--w)}for(let w=0;w<this._targetedAnimations.length;w++){const o=this._targetedAnimations[w];this.mask.retainsTarget(o.target.name)||(this._targetedAnimations.splice(w,1),--w)}}}get from(){return this._from}set from(w){if(this._from!==w){this._from=w;for(let w=0;w<this._animatables.length;w++){this._animatables[w].fromFrame=this._from}}}get to(){return this._to}set to(w){if(this._to!==w){this._to=w;for(let w=0;w<this._animatables.length;w++){this._animatables[w].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(w){if(this._speedRatio!==w){this._speedRatio=w;for(let w=0;w<this._animatables.length;w++){this._animatables[w].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(w){if(this._loopAnimation!==w){this._loopAnimation=w;for(let w=0;w<this._animatables.length;w++){this._animatables[w].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(w){if(this._isAdditive!==w){this._isAdditive=w;for(let w=0;w<this._animatables.length;w++){this._animatables[w].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(w){this._weight!==w&&(this._weight=w,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(w){if(this._playOrder!==w&&(this._playOrder=w,this._animatables.length>0)){for(let w=0;w<this._animatables.length;w++)this._animatables[w].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(w){if(this._enableBlending!==w&&(this._enableBlending=w,null!==w))for(let o=0;o<this._targetedAnimations.length;++o)this._targetedAnimations[o].animation.enableBlending=w}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(w){if(this._blendingSpeed!==w&&(this._blendingSpeed=w,null!==w))for(let o=0;o<this._targetedAnimations.length;++o)this._targetedAnimations[o].animation.blendingSpeed=w}getLength(w,o){w=w??this._from;return((o=o??this._to)-w)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(w){let o=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],h=arguments.length>3?arguments[3]:void 0;if(0===w.length)return null;h=h??w[0].weight;let E=Number.MAX_VALUE,e=-Number.MAX_VALUE;if(H)for(const t of w)t.from<E&&(E=t.from),t.to>e&&(e=t.to);const D=new V(w[0].name+"_merged",w[0]._scene,h);for(const t of w){H&&t.normalize(E,e);for(const w of t.targetedAnimations)D.addTargetedAnimation(w.animation,w.target);o&&t.dispose()}return D}constructor(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=w,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new E.b,this.onAnimationLoopObservable=new E.b,this.onAnimationGroupLoopObservable=new E.b,this.onAnimationGroupEndObservable=new E.b,this.onAnimationGroupPauseObservable=new E.b,this.onAnimationGroupPlayObservable=new E.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=o||e.e.LastCreatedScene,this._weight=H,this._playOrder=h,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(w,o){const H=new s;H.animation=w,H.target=o;const h=w.getKeys();return this._from>h[0].frame&&(this._from=h[0].frame),this._to<h[h.length-1].frame&&(this._to=h[h.length-1].frame),null!==this._enableBlending&&(w.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(w.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(H),this._shouldStart=!0,H}removeTargetedAnimation(w){for(let o=this._targetedAnimations.length-1;o>-1;o--){this._targetedAnimations[o].animation===w&&this._targetedAnimations.splice(o,1)}}normalize(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==w&&(w=this._from),null==o&&(o=this._to);for(let H=0;H<this._targetedAnimations.length;H++){const h=this._targetedAnimations[H].animation.getKeys(),E=h[0],e=h[h.length-1];if(E.frame>w){const o={frame:w,value:E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation};h.splice(0,0,o)}if(e.frame<o){const w={frame:o,value:e.value,inTangent:e.inTangent,outTangent:e.outTangent,interpolation:e.interpolation};h.push(w)}}return this._from=w,this._to=o,this}_processLoop(w,o,H){w.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(o),this._animationLoopFlags[H]||(this._animationLoopFlags[H]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0],o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0,h=arguments.length>3?arguments[3]:void 0,E=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=w,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let e=0;e<this._targetedAnimations.length;e++){const D=this._targetedAnimations[e],t=this._scene.beginDirectAnimation(D.target,[D.animation],void 0!==H?H:this._from,void 0!==h?h:this._to,w,o,void 0,void 0,void 0!==E?E:this._isAdditive);t.weight=this._weight,t.playOrder=this._playOrder,t.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(D),this._checkAnimationGroupEnded(t)},this._processLoop(t,D,e),this._animatables.push(t)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=o,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let w=0;w<this._animatables.length;w++){this._animatables[w].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(w){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==w&&(this.loopAnimation=w),this.restart()):(this.stop(),this.start(w,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let w=0;w<this._animatables.length;w++){this._animatables[w].reset()}return this}restart(){if(!this._isStarted)return this;for(let w=0;w<this._animatables.length;w++){this._animatables[w].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const o=this._animatables.slice();for(let h=0;h<o.length;h++)o[h].stop(void 0,void 0,!0,w);let H=0;for(let h=0;h<this._scene._activeAnimatables.length;h++){const o=this._scene._activeAnimatables[h];o._runtimeAnimations.length>0?this._scene._activeAnimatables[H++]=o:w&&this._checkAnimationGroupEnded(o,w)}return this._scene._activeAnimatables.length=H,this._isStarted=!1,this}setWeightForAllAnimatables(w){for(let o=0;o<this._animatables.length;o++){this._animatables[o].weight=w}return this}syncAllAnimationsWith(w){for(let o=0;o<this._animatables.length;o++){this._animatables[o].syncWith(w)}return this}goToFrame(w){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].goToFrame(w,o)}return this}getCurrentFrame(){var w;return(null===(w=this.animatables[0])||void 0===w?void 0:w.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const w=this._scene.animationGroups.indexOf(this);if(w>-1&&this._scene.animationGroups.splice(w,1),this._parentContainer){const w=this._parentContainer.animationGroups.indexOf(this);w>-1&&this._parentContainer.animationGroups.splice(w,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(w){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const H=this._animatables.indexOf(w);H>-1&&this._animatables.splice(H,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,o||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(w,o){let H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const h=new V(w||this.name,this._scene,this._weight,this._playOrder);h._from=this.from,h._to=this.to,h._speedRatio=this.speedRatio,h._loopAnimation=this.loopAnimation,h._isAdditive=this.isAdditive,h._enableBlending=this.enableBlending,h._blendingSpeed=this.blendingSpeed,h.metadata=this.metadata,h.mask=this.mask;for(const E of this._targetedAnimations)h.addTargetedAnimation(H?E.animation.clone():E.animation,o?o(E.target):E.target);return h}serialize(){const w={};w.name=this.name,w.from=this.from,w.to=this.to,w.speedRatio=this.speedRatio,w.loopAnimation=this.loopAnimation,w.isAdditive=this.isAdditive,w.weight=this.weight,w.playOrder=this.playOrder,w.enableBlending=this.enableBlending,w.blendingSpeed=this.blendingSpeed,w.targetedAnimations=[];for(let o=0;o<this.targetedAnimations.length;o++){const H=this.targetedAnimations[o];w.targetedAnimations[o]=H.serialize()}return D.c&&D.c.HasTags(this)&&(w.tags=D.c.GetTags(this)),this.metadata&&(w.metadata=this.metadata),w}static Parse(w,o){const H=new V(w.name,o,w.weight,w.playOrder);for(let E=0;E<w.targetedAnimations.length;E++){const e=w.targetedAnimations[E],D=h.b.Parse(e.animation),t=e.targetId;if("influence"===e.animation.property){const w=o.getMorphTargetById(t);w&&H.addTargetedAnimation(D,w)}else{const w=o.getNodeById(t);null!=w&&H.addTargetedAnimation(D,w)}}return D.c&&D.c.AddTagsTo(H,w.tags),null!==w.from&&null!==w.to&&H.normalize(w.from,w.to),void 0!==w.speedRatio&&(H._speedRatio=w.speedRatio),void 0!==w.loopAnimation&&(H._loopAnimation=w.loopAnimation),void 0!==w.isAdditive&&(H._isAdditive=w.isAdditive),void 0!==w.weight&&(H._weight=w.weight),void 0!==w.playOrder&&(H._playOrder=w.playOrder),void 0!==w.enableBlending&&(H._enableBlending=w.enableBlending),void 0!==w.blendingSpeed&&(H._blendingSpeed=w.blendingSpeed),void 0!==w.metadata&&(H.metadata=w.metadata),H}static MakeAnimationAdditive(w,o,H){let E;E="object"===typeof o?o:{referenceFrame:o,range:H,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let e=w;E.cloneOriginalAnimationGroup&&(e=w.clone(E.clonedAnimationGroupName||e.name));const D=e.targetedAnimations;for(let t=0;t<D.length;t++){const w=D[t];w.animation=h.b.MakeAnimationAdditive(w.animation,E)}if(e.isAdditive=!0,E.clipKeys){let w=Number.MAX_VALUE,o=-Number.MAX_VALUE;const H=e.targetedAnimations;for(let h=0;h<H.length;h++){const E=H[h].animation.getKeys();w>E[0].frame&&(w=E[0].frame),o<E[E.length-1].frame&&(o=E[E.length-1].frame)}e._from=w,e._to=o}return e}static ClipKeys(w,o,H,h,E){const e=w.clone(h||w.name);return V.ClipKeysInPlace(e,o,H,E)}static ClipKeysInPlace(w,o,H,h){return V.ClipInPlace(w,o,H,h,!1)}static ClipFrames(w,o,H,h,E){const e=w.clone(h||w.name);return V.ClipFramesInPlace(e,o,H,E)}static ClipFramesInPlace(w,o,H,h){return V.ClipInPlace(w,o,H,h,!0)}static ClipInPlace(w,o,H,h){let E=arguments.length>4&&void 0!==arguments[4]&&arguments[4],e=Number.MAX_VALUE,D=-Number.MAX_VALUE;const t=w.targetedAnimations;for(let X=0;X<t.length;X++){const w=t[X],L=h?w.animation:w.animation.clone();E&&(L.createKeyForFrame(o),L.createKeyForFrame(H));const A=L.getKeys(),y=[];let z=Number.MAX_VALUE;for(let h=0;h<A.length;h++){const w=A[h];if(!E&&h>=o&&h<=H||E&&w.frame>=o&&w.frame<=H){const o={frame:w.frame,value:w.value.clone?w.value.clone():w.value,inTangent:w.inTangent,outTangent:w.outTangent,interpolation:w.interpolation,lockedTangent:w.lockedTangent};z===Number.MAX_VALUE&&(z=o.frame),o.frame-=z,y.push(o)}}0!==y.length?(e>y[0].frame&&(e=y[0].frame),D<y[y.length-1].frame&&(D=y[y.length-1].frame),L.setKeys(y,!0),w.animation=L):(t.splice(X,1),X--)}return w._from=e,w._to=D,w}getClassName(){return"AnimationGroup"}toString(w){let o="Name: "+this.name;return o+=", type: "+this.getClassName(),w&&(o+=", from: "+this._from,o+=", to: "+this._to,o+=", isStarted: "+this._isStarted,o+=", speedRatio: "+this._speedRatio,o+=", targetedAnimations length: "+this._targetedAnimations.length,o+=", animatables length: "+this._animatables),o}}}}]);