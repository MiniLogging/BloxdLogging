"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[78],{15458:(y,S,I)=>{I.r(S),I.d(S,{AnimationGroup:()=>s,TargetedAnimation:()=>j});var V=I(12838),i=I(12133),A=I(12185),B=I(12355),d=I(13967),F=I(12321);class J{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(y,S,I,i){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=S,this._target=y,this._scene=I,this._host=i,this._activeTargets=[],S._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===V.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=F.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const y={frame:0,value:this._minValue};this._keys.splice(0,0,y)}if(this._target instanceof Array){let y=0;for(const S of this._target)this._preparePath(S,y),this._getOriginalValues(y),y++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const A=S.getEvents();if(A&&A.length>0)for(const V of A)this._events.push(V._clone());this._enableBlending=y&&y.animationPropertiesOverride?y.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const I=this._animation.targetPropertyPath;if(I.length>1){let V=y;for(let y=0;y<I.length-1;y++){const S=I[y];if(V=V[S],void 0===V)throw new Error(`Invalid property (${S}) in property path (${I.join(".")})`)}this._targetPath=I[I.length-1],this._activeTargets[S]=V}else this._targetPath=I[0],this._activeTargets[S]=y;if(void 0===this._activeTargets[S][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${I.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let y=0;for(const S of this._target)void 0!==this._originalValue[y]&&this._setValue(S,this._activeTargets[y],this._originalValue[y],-1,y),y++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let y=0;y<this._events.length;y++)this._events[y].isDone=!1}isStopped(){return this._stopped}dispose(){const y=this._animation.runtimeAnimations.indexOf(this);y>-1&&this._animation.runtimeAnimations.splice(y,1)}setValue(y,S){if(this._targetIsArray)for(let I=0;I<this._target.length;I++){const V=this._target[I];this._setValue(V,this._activeTargets[I],y,S,I)}else this._setValue(this._target,this._directTarget,y,S,0)}_getOriginalValues(){let y,S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const I=this._activeTargets[S];y=I.getLocalMatrix&&"_matrix"===this._targetPath?I.getLocalMatrix():I[this._targetPath],y&&y.clone?this._originalValue[S]=y.clone():this._originalValue[S]=y}_registerTargetForLateAnimationBinding(y,S){const I=y.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(I),I._lateAnimationHolders||(I._lateAnimationHolders={}),I._lateAnimationHolders[y.targetPath]||(I._lateAnimationHolders[y.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:S}),y.isAdditive?(I._lateAnimationHolders[y.targetPath].additiveAnimations.push(y),I._lateAnimationHolders[y.targetPath].totalAdditiveWeight+=y.weight):(I._lateAnimationHolders[y.targetPath].animations.push(y),I._lateAnimationHolders[y.targetPath].totalWeight+=y.weight)}_setValue(y,S,I,i,A){if(this._currentActiveTarget=S,this._weight=i,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const y=S[this._targetPath];y.clone?this._originalBlendValue=y.clone():this._originalBlendValue=y}this._originalBlendValue.m?V.b.AllowMatrixDecomposeForInterpolation?this._currentValue?F.Matrix.DecomposeLerpToRef(this._originalBlendValue,I,this._blendingFactor,this._currentValue):this._currentValue=F.Matrix.DecomposeLerp(this._originalBlendValue,I,this._blendingFactor):this._currentValue?F.Matrix.LerpToRef(this._originalBlendValue,I,this._blendingFactor,this._currentValue):this._currentValue=F.Matrix.Lerp(this._originalBlendValue,I,this._blendingFactor):this._currentValue=V.b._UniversalLerp(this._originalBlendValue,I,this._blendingFactor);const i=y&&y.animationPropertiesOverride?y.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=i}else this._currentValue?this._currentValue.A?this._currentValue.A(I):this._currentValue=I:null!==I&&void 0!==I&&I.clone?this._currentValue=I.clone():this._currentValue=I;-1!==i?this._registerTargetForLateAnimationBinding(this,this._originalValue[A]):this._animationState.loopMode===V.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[A],S[this._targetPath]):S[this._targetPath]=this._originalValue[A]+this._currentValue:S[this._targetPath]=this._currentValue,y.Su&&y.Su(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const I=this._animation.getKeys();y<I[0].frame?y=I[0].frame:y>I[I.length-1].frame&&(y=I[I.length-1].frame);const V=this._events;if(V.length)for(let A=0;A<V.length;A++)V[A].onlyOnce||(V[A].isDone=V[A].frame<y);this._currentFrame=y;const i=this._animation._interpolate(y,this._animationState);this.setValue(i,S)}_prepareForSpeedRatioChange(y){const S=this._previousElapsedTime*(this._animation.framePerSecond*y)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-S}animate(y,S,I,i,A){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const d=this._animation,F=d.targetPropertyPath;if(!F||F.length<1)return this._stopped=!0,!1;let J,u=!0;const K=this._events;let G=0;if(this._coreRuntimeAnimation)G=I-S,J=this._coreRuntimeAnimation.currentFrame,this._currentFrame=J,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let B;(S<this._minFrame||S>this._maxFrame)&&(S=this._minFrame),(I<this._minFrame||I>this._maxFrame)&&(I=this._maxFrame),G=I-S;let F=y*(d.framePerSecond*A)/1e3+this._absoluteFrameOffset,p=0,L=!1;const T=i&&this._animationState.loopMode===V.b.ANIMATIONLOOPMODE_YOYO;if(T){const y=(F-S)/G,I=Math.sin(y*Math.PI);F=Math.abs(I)*G+S;const V=I>=0?1:-1;this._yoyoDirection!==V&&(L=!0),this._yoyoDirection=V}if(this._previousElapsedTime=y,this._previousAbsoluteFrame=F,!i&&I>=S&&(F>=G&&A>0||F<=0&&A<0))u=!1,p=d._getKeyValue(this._maxValue);else if(!i&&S>=I&&(F<=G&&A<0||F>=0&&A>0))u=!1,p=d._getKeyValue(this._minValue);else if(this._animationState.loopMode!==V.b.ANIMATIONLOOPMODE_CYCLE){const y=I.toString()+S.toString();if(!this._offsetsCache[y]){this._animationState.repeatCount=0,this._animationState.loopMode=V.b.ANIMATIONLOOPMODE_CYCLE;const i=d._interpolate(S,this._animationState),A=d._interpolate(I,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),d.dataType){case V.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[y]=A-i;break;case V.b.ANIMATIONTYPE_QUATERNION:case V.b.ANIMATIONTYPE_VECTOR3:case V.b.ANIMATIONTYPE_VECTOR2:case V.b.ANIMATIONTYPE_SIZE:case V.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[y]=A.fS(i)}this._highLimitsCache[y]=A}p=this._highLimitsCache[y],B=this._offsetsCache[y]}if(void 0===B)switch(d.dataType){case V.b.ANIMATIONTYPE_FLOAT:B=0;break;case V.b.ANIMATIONTYPE_QUATERNION:B=V.m;break;case V.b.ANIMATIONTYPE_VECTOR3:B=V.w;break;case V.b.ANIMATIONTYPE_VECTOR2:B=V.s;break;case V.b.ANIMATIONTYPE_SIZE:B=V.q;break;case V.b.ANIMATIONTYPE_COLOR3:B=V.e;break;case V.b.ANIMATIONTYPE_COLOR4:B=V.i}if(this._host&&this._host.syncRoot){const y=this._host.syncRoot;J=S+G*((y.masterFrame-y.fromFrame)/(y.toFrame-y.fromFrame))}else J=F>0&&S>I||F<0&&S<I?u&&0!==G?I+F%G:S:u&&0!==G?S+F%G:I;if(!T&&(A>0&&this.currentFrame>J||A<0&&this.currentFrame<J)||T&&L){this._onLoop();for(let y=0;y<K.length;y++)K[y].onlyOnce||(K[y].isDone=!1);this._animationState.key=A>0?0:d.getKeys().length-1}this._currentFrame=J,this._animationState.repeatCount=0===G?0:F/G|0,this._animationState.highLimitValue=p,this._animationState.offsetValue=B}const p=d._interpolate(J,this._animationState);if(this.setValue(p,B),K.length)for(let V=0;V<K.length;V++)if(G>=0&&J>=K[V].frame&&K[V].frame>=S||G<0&&J<=K[V].frame&&K[V].frame<=S){const y=K[V];y.isDone||(y.onlyOnce&&(K.splice(V,1),V--),y.isDone=!0,y.action(J))}return u||(this._stopped=!0),u}}var u=I(12167);class K{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(y){this._weight=-1!==y?Math.min(Math.max(y,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(y){for(let S=0;S<this._runtimeAnimations.length;S++){this._runtimeAnimations[S]._prepareForSpeedRatioChange(y)}this._speedRatio=y,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(y,S){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,A=arguments.length>4&&void 0!==arguments[4]&&arguments[4],B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,d=arguments.length>6?arguments[6]:void 0,F=arguments.length>7?arguments[7]:void 0,J=arguments.length>8?arguments[8]:void 0,u=arguments.length>9&&void 0!==arguments[9]&&arguments[9],K=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=S,this.fromFrame=I,this.toFrame=V,this.loopAnimation=A,this.onAnimationEnd=d,this.onAnimationLoop=J,this.isAdditive=u,this.playOrder=K,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.rd=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new i.b,this.onAnimationLoopObservable=new i.b,this._scene=y,F&&this.appendAnimations(S,F),this._speedRatio=B,y._activeAnimatables.push(this)}syncWith(y){if(this._syncRoot=y,y){const y=this._scene._activeAnimatables.indexOf(this);y>-1&&(this._scene._activeAnimatables.splice(y,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(y,S){for(let I=0;I<S.length;I++){const V=S[I],i=new J(y,V,this._scene,this);i._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(i)}}getAnimationByTargetProperty(y){const S=this._runtimeAnimations;for(let I=0;I<S.length;I++)if(S[I].animation.targetProperty===y)return S[I].animation;return null}getRuntimeAnimationByTargetProperty(y){const S=this._runtimeAnimations;for(let I=0;I<S.length;I++)if(S[I].animation.targetProperty===y)return S[I];return null}reset(){const y=this._runtimeAnimations;for(let S=0;S<y.length;S++)y[S].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(y){const S=this._runtimeAnimations;for(let I=0;I<S.length;I++)S[I].animation.enableBlending=!0,S[I].animation.blendingSpeed=y}disableBlending(){const y=this._runtimeAnimations;for(let S=0;S<y.length;S++)y[S].animation.enableBlending=!1}goToFrame(y){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const I=this._runtimeAnimations;if(I[0]){const S=I[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??I[0].currentFrame;const V=0===this.speedRatio?0:(y-this._frameToSyncFromJump)/S*1e3/this.speedRatio;this._manualJumpDelay=-V}for(let V=0;V<I.length;V++)I[V].goToFrame(y,S?this._weight:-1);this._goToFrame=y}get paused(){return this.rd}pause(){this.rd||(this.rd=!0)}restart(){this.rd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(y,S){let I=arguments.length>2&&void 0!==arguments[2]&&arguments[2],V=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(y||S){const i=this._scene._activeAnimatables.indexOf(this);if(i>-1){const A=this._runtimeAnimations;for(let I=A.length-1;I>=0;I--){const V=A[I];y&&V.animation.name!=y||(S&&!S(V.target)||(V.dispose(),A.splice(I,1)))}0==A.length&&(I||this._scene._activeAnimatables.splice(i,1),V||this._raiseOnAnimationEnd())}}else{const y=this._scene._activeAnimatables.indexOf(this);if(y>-1){I||this._scene._activeAnimatables.splice(y,1);const S=this._runtimeAnimations;for(let y=0;y<S.length;y++)S[y].dispose();this._runtimeAnimations.length=0,V||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((y=>{this.onAnimationEndObservable.add((()=>{y(this)}),void 0,void 0,this,!0)}))}_animate(y){if(this.rd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=y),!0;if(null===this._localDelayOffset?(this._localDelayOffset=y,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=y-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let S=!1;const I=this._runtimeAnimations;let V;for(V=0;V<I.length;V++){const i=I[V].animate(y-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);S=S||i}if(this.animationStarted=S,!S){if(this.disposeOnEnd)for(V=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(V,1),V=0;V<I.length;V++)I[V].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return S}}function G(y){if(0===y.totalWeight&&0===y.totalAdditiveWeight)return y.originalValue;let S=1;const I=F.TmpVectors.OS[0],V=F.TmpVectors.OS[1],i=F.TmpVectors.Quaternion[0];let A=0;const B=y.animations[0],d=y.originalValue;let J=1,u=!1;if(y.totalWeight<1)J=1-y.totalWeight,d.decompose(V,i,I);else{if(A=1,S=y.totalWeight,J=B.weight/S,1==J){if(!y.totalAdditiveWeight)return B.currentValue;u=!0}B.currentValue.decompose(V,i,I)}if(!u){V.scaleInPlace(J),I.scaleInPlace(J),i.scaleInPlace(J);for(let B=A;B<y.animations.length;B++){const A=y.animations[B];if(0===A.weight)continue;J=A.weight/S;const d=F.TmpVectors.OS[2],u=F.TmpVectors.OS[3],K=F.TmpVectors.Quaternion[1];A.currentValue.decompose(u,K,d),u.scaleAndAddToRef(J,V),K.scaleAndAddToRef(F.Quaternion.Dot(i,K)>0?J:-J,i),d.scaleAndAddToRef(J,I)}i.normalize()}for(let G=0;G<y.additiveAnimations.length;G++){const S=y.additiveAnimations[G];if(0===S.weight)continue;const A=F.TmpVectors.OS[2],B=F.TmpVectors.OS[3],d=F.TmpVectors.Quaternion[1];S.currentValue.decompose(B,d,A),B.multiplyToRef(V,B),F.OS.LerpToRef(V,B,S.weight,V),i.multiplyToRef(d,d),F.Quaternion.SlerpToRef(i,d,S.weight,i),A.scaleAndAddToRef(S.weight,I)}const K=B?B._animationState.workValue:F.TmpVectors.Matrix[0].clone();return F.Matrix.ComposeToRef(V,i,I,K),K}function p(y,S){if(0===y.totalWeight&&0===y.totalAdditiveWeight)return S;const I=y.animations[0],V=y.originalValue;let i=S;if(0===y.totalWeight&&y.totalAdditiveWeight>0)i.A(V);else if(1===y.animations.length){if(F.Quaternion.SlerpToRef(V,I.currentValue,Math.min(1,y.totalWeight),i),0===y.totalAdditiveWeight)return i}else if(y.animations.length>1){let I,A,B=1;if(y.totalWeight<1){const S=1-y.totalWeight;I=[],A=[],I.push(V),A.push(S)}else{if(2===y.animations.length&&(F.Quaternion.SlerpToRef(y.animations[0].currentValue,y.animations[1].currentValue,y.animations[1].weight/y.totalWeight,S),0===y.totalAdditiveWeight))return S;I=[],A=[],B=y.totalWeight}for(let S=0;S<y.animations.length;S++){const V=y.animations[S];I.push(V.currentValue),A.push(V.weight/B)}let d=0;for(let y=0;y<I.length;)y?(d+=A[y],F.Quaternion.SlerpToRef(i,I[y],A[y]/d,i),y++):(F.Quaternion.SlerpToRef(I[y],I[y+1],A[y+1]/(A[y]+A[y+1]),S),i=S,d=A[y]+A[y+1],y+=2)}for(let A=0;A<y.additiveAnimations.length;A++){const S=y.additiveAnimations[A];0!==S.weight&&(i.multiplyToRef(S.currentValue,F.TmpVectors.Quaternion[0]),F.Quaternion.SlerpToRef(i,F.TmpVectors.Quaternion[0],S.weight,i))}return i}var L,T,l=I(12556);L=l.e,(T=d.c)&&(T.prototype.copyAnimationRange=function(y,S,I){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3],A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new V.b(this.name,"_matrix",y.animations[0].framePerSecond,V.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const B=y.animations[0].getRange(S);if(!B)return!1;const d=B.from,F=B.to,J=y.animations[0].getKeys(),u=y.length,K=y.getParent(),G=this.getParent(),p=i&&K&&u&&this.length&&u!==this.length,L=p&&G&&K?G.length/K.length:1,T=i&&!G&&A&&(1!==A.x||1!==A.y||1!==A.z),l=this.animations[0].getKeys();let j,s,O;for(let V=0,f=J.length;V<f;V++)j=J[V],j.frame>=d&&j.frame<=F&&(i?(O=j.value.clone(),p?(s=O.getTranslation(),O.setTranslation(s.scaleInPlace(L))):T&&A?(s=O.getTranslation(),O.setTranslation(s.multiplyInPlace(A))):O=j.value):O=j.value,l.push({frame:j.frame+I,value:O}));return this.animations[0].createRange(S,d+I,F+I),!0}),L&&(L.prototype._animate=function(y){if(!this.animationsEnabled)return;const S=u.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=S}this.deltaTime=void 0!==y?y:this.useConstantAnimationDeltaTime?16:(S-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=S;const I=this._activeAnimatables;if(0===I.length)return;this._animationTime+=this.deltaTime;const i=this._animationTime;for(let V=0;V<I.length;V++){const y=I[V];!y._animate(i)&&y.disposeOnEnd&&V--}!function(y){if(y._registeredForLateAnimationBindings.length){for(let S=0;S<y._registeredForLateAnimationBindings.length;S++){const I=y._registeredForLateAnimationBindings.data[S];for(const y in I._lateAnimationHolders){const S=I._lateAnimationHolders[y],i=S.animations[0],A=S.originalValue;if(void 0===A||null===A)continue;const B=V.b.AllowMatrixDecomposeForInterpolation&&A.m;let d=I[y];if(B)d=G(S);else if(void 0!==A.w)d=p(S,d||F.Quaternion.Identity());else{let y=0,I=1;const B=i&&i._animationState.loopMode===V.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(S.totalWeight<1)d=B?A.clone?A.clone():A:i&&A.scale?A.scale(1-S.totalWeight):i?A*(1-S.totalWeight):A.clone?A.clone():A;else if(i){I=S.totalWeight;const V=i.weight/I;d=1!==V?i.currentValue.scale?i.currentValue.scale(V):i.currentValue*V:i.currentValue,B&&(d.addToRef?d.addToRef(A,d):d+=A),y=1}for(let V=y;V<S.animations.length;V++){const y=S.animations[V],i=y.weight/I;i&&(y.currentValue.scaleAndAddToRef?y.currentValue.scaleAndAddToRef(i,d):d+=y.currentValue*i)}for(let V=0;V<S.additiveAnimations.length;V++){const y=S.additiveAnimations[V],I=y.weight;I&&(y.currentValue.scaleAndAddToRef?y.currentValue.scaleAndAddToRef(I,d):d+=y.currentValue*I)}}I[y]=d}I._lateAnimationHolders={}}y._registeredForLateAnimationBindings.reset()}}(this)},L.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((y,S)=>y.playOrder-S.playOrder))},L.prototype.beginWeightedAnimation=function(y,S,I){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,i=arguments.length>4?arguments[4]:void 0,A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,B=arguments.length>6?arguments[6]:void 0,d=arguments.length>7?arguments[7]:void 0,F=arguments.length>8?arguments[8]:void 0,J=arguments.length>9?arguments[9]:void 0,u=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const K=this.beginAnimation(y,S,I,i,A,B,d,!1,F,J,u);return K.weight=V,K},L.prototype.beginAnimation=function(y,S,I,V){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,A=arguments.length>5?arguments[5]:void 0,B=arguments.length>6?arguments[6]:void 0,d=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],F=arguments.length>8?arguments[8]:void 0,J=arguments.length>9?arguments[9]:void 0,u=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(i<0){const y=S;S=I,I=y,i=-i}S>I&&(i=-i),d&&this.stopAnimation(y,void 0,F),B||(B=new K(this,y,S,I,V,i,A,void 0,J,u));const G=!F||F(y);if(y.animations&&G&&B.appendAnimations(y,y.animations),y.getAnimatables){const u=y.getAnimatables();for(let y=0;y<u.length;y++)this.beginAnimation(u[y],S,I,V,i,A,B,d,F,J)}return B.reset(),B},L.prototype.beginHierarchyAnimation=function(y,S,I,V,i){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,B=arguments.length>6?arguments[6]:void 0,d=arguments.length>7?arguments[7]:void 0,F=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],J=arguments.length>9?arguments[9]:void 0,u=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const K=y.getDescendants(S),G=[];G.push(this.beginAnimation(y,I,V,i,A,B,d,F,J,void 0,u));for(const p of K)G.push(this.beginAnimation(p,I,V,i,A,B,d,F,J,void 0,u));return G},L.prototype.beginDirectAnimation=function(y,S,I,V,i){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(A<0){const y=I;I=V,V=y,A=-A}return I>V&&(A=-A),new K(this,y,I,V,i,A,arguments.length>6?arguments[6]:void 0,S,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},L.prototype.beginDirectHierarchyAnimation=function(y,S,I,V,i,A,B,d,F){let J=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const u=y.getDescendants(S),K=[];K.push(this.beginDirectAnimation(y,I,V,i,A,B,d,F,J));for(const G of u)K.push(this.beginDirectAnimation(G,I,V,i,A,B,d,F,J));return K},L.prototype.getAnimatableByTarget=function(y){for(let S=0;S<this._activeAnimatables.length;S++)if(this._activeAnimatables[S].target===y)return this._activeAnimatables[S];return null},L.prototype.getAllAnimatablesByTarget=function(y){const S=[];for(let I=0;I<this._activeAnimatables.length;I++)this._activeAnimatables[I].target===y&&S.push(this._activeAnimatables[I]);return S},L.prototype.stopAnimation=function(y,S,I){const V=this.getAllAnimatablesByTarget(y);for(const i of V)i.stop(S,I)},L.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let y=0;y<this._activeAnimatables.length;y++)this._activeAnimatables[y].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const y of this.animationGroups)y.stop()});class j{getClassName(){return"TargetedAnimation"}serialize(){const y={};return y.animation=this.animation.serialize(),y.targetId=this.target.id,y}}class s{get mask(){return this._mask}set mask(y){this._mask!==y&&(this._mask=y,this.syncWithMask(!0))}syncWithMask(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||y){this._numActiveAnimatables=0;for(let y=0;y<this._animatables.length;++y){const S=this._animatables[y];!this.mask||this.mask.disabled||this.mask.retainsTarget(S.target.name)?(this._numActiveAnimatables++,S.paused&&S.restart()):S.paused||S.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let y=0;y<this._animatables.length;++y){const S=this._animatables[y];this.mask.retainsTarget(S.target.name)||(S.stop(),this._animatables.splice(y,1),--y)}for(let y=0;y<this._targetedAnimations.length;y++){const S=this._targetedAnimations[y];this.mask.retainsTarget(S.target.name)||(this._targetedAnimations.splice(y,1),--y)}}}get from(){return this._from}set from(y){if(this._from!==y){this._from=y;for(let y=0;y<this._animatables.length;y++){this._animatables[y].fromFrame=this._from}}}get to(){return this._to}set to(y){if(this._to!==y){this._to=y;for(let y=0;y<this._animatables.length;y++){this._animatables[y].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(y){if(this._speedRatio!==y){this._speedRatio=y;for(let y=0;y<this._animatables.length;y++){this._animatables[y].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(y){if(this._loopAnimation!==y){this._loopAnimation=y;for(let y=0;y<this._animatables.length;y++){this._animatables[y].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(y){if(this._isAdditive!==y){this._isAdditive=y;for(let y=0;y<this._animatables.length;y++){this._animatables[y].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(y){this._weight!==y&&(this._weight=y,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(y){if(this._playOrder!==y&&(this._playOrder=y,this._animatables.length>0)){for(let y=0;y<this._animatables.length;y++)this._animatables[y].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(y){if(this._enableBlending!==y&&(this._enableBlending=y,null!==y))for(let S=0;S<this._targetedAnimations.length;++S)this._targetedAnimations[S].animation.enableBlending=y}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(y){if(this._blendingSpeed!==y&&(this._blendingSpeed=y,null!==y))for(let S=0;S<this._targetedAnimations.length;++S)this._targetedAnimations[S].animation.blendingSpeed=y}getLength(y,S){y=y??this._from;return((S=S??this._to)-y)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(y){let S=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],I=arguments.length>2&&void 0!==arguments[2]&&arguments[2],V=arguments.length>3?arguments[3]:void 0;if(0===y.length)return null;V=V??y[0].weight;let i=Number.MAX_VALUE,A=-Number.MAX_VALUE;if(I)for(const d of y)d.from<i&&(i=d.from),d.to>A&&(A=d.to);const B=new s(y[0].name+"_merged",y[0]._scene,V);for(const d of y){I&&d.normalize(i,A);for(const y of d.targetedAnimations)B.addTargetedAnimation(y.animation,y.target);S&&d.dispose()}return B}constructor(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=y,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new i.b,this.onAnimationLoopObservable=new i.b,this.onAnimationGroupLoopObservable=new i.b,this.onAnimationGroupEndObservable=new i.b,this.onAnimationGroupPauseObservable=new i.b,this.onAnimationGroupPlayObservable=new i.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=S||A.e.LastCreatedScene,this._weight=I,this._playOrder=V,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(y,S){const I=new j;I.animation=y,I.target=S;const V=y.getKeys();return this._from>V[0].frame&&(this._from=V[0].frame),this._to<V[V.length-1].frame&&(this._to=V[V.length-1].frame),null!==this._enableBlending&&(y.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(y.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(I),this._shouldStart=!0,I}removeTargetedAnimation(y){for(let S=this._targetedAnimations.length-1;S>-1;S--){this._targetedAnimations[S].animation===y&&this._targetedAnimations.splice(S,1)}}normalize(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==y&&(y=this._from),null==S&&(S=this._to);for(let I=0;I<this._targetedAnimations.length;I++){const V=this._targetedAnimations[I].animation.getKeys(),i=V[0],A=V[V.length-1];if(i.frame>y){const S={frame:y,value:i.value,inTangent:i.inTangent,outTangent:i.outTangent,interpolation:i.interpolation};V.splice(0,0,S)}if(A.frame<S){const y={frame:S,value:A.value,inTangent:A.inTangent,outTangent:A.outTangent,interpolation:A.interpolation};V.push(y)}}return this._from=y,this._to=S,this}_processLoop(y,S,I){y.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(S),this._animationLoopFlags[I]||(this._animationLoopFlags[I]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0],S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,I=arguments.length>2?arguments[2]:void 0,V=arguments.length>3?arguments[3]:void 0,i=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=y,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let A=0;A<this._targetedAnimations.length;A++){const B=this._targetedAnimations[A],d=this._scene.beginDirectAnimation(B.target,[B.animation],void 0!==I?I:this._from,void 0!==V?V:this._to,y,S,void 0,void 0,void 0!==i?i:this._isAdditive);d.weight=this._weight,d.playOrder=this._playOrder,d.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(B),this._checkAnimationGroupEnded(d)},this._processLoop(d,B,A),this._animatables.push(d)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=S,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let y=0;y<this._animatables.length;y++){this._animatables[y].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(y){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==y&&(this.loopAnimation=y),this.restart()):(this.stop(),this.start(y,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let y=0;y<this._animatables.length;y++){this._animatables[y].reset()}return this}restart(){if(!this._isStarted)return this;for(let y=0;y<this._animatables.length;y++){this._animatables[y].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const S=this._animatables.slice();for(let V=0;V<S.length;V++)S[V].stop(void 0,void 0,!0,y);let I=0;for(let V=0;V<this._scene._activeAnimatables.length;V++){const S=this._scene._activeAnimatables[V];S._runtimeAnimations.length>0?this._scene._activeAnimatables[I++]=S:y&&this._checkAnimationGroupEnded(S,y)}return this._scene._activeAnimatables.length=I,this._isStarted=!1,this}setWeightForAllAnimatables(y){for(let S=0;S<this._animatables.length;S++){this._animatables[S].weight=y}return this}syncAllAnimationsWith(y){for(let S=0;S<this._animatables.length;S++){this._animatables[S].syncWith(y)}return this}goToFrame(y){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let I=0;I<this._animatables.length;I++){this._animatables[I].goToFrame(y,S)}return this}getCurrentFrame(){var y;return(null===(y=this.animatables[0])||void 0===y?void 0:y.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const y=this._scene.animationGroups.indexOf(this);if(y>-1&&this._scene.animationGroups.splice(y,1),this._parentContainer){const y=this._parentContainer.animationGroups.indexOf(this);y>-1&&this._parentContainer.animationGroups.splice(y,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(y){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const I=this._animatables.indexOf(y);I>-1&&this._animatables.splice(I,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,S||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(y,S){let I=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const V=new s(y||this.name,this._scene,this._weight,this._playOrder);V._from=this.from,V._to=this.to,V._speedRatio=this.speedRatio,V._loopAnimation=this.loopAnimation,V._isAdditive=this.isAdditive,V._enableBlending=this.enableBlending,V._blendingSpeed=this.blendingSpeed,V.metadata=this.metadata,V.mask=this.mask;for(const i of this._targetedAnimations)V.addTargetedAnimation(I?i.animation.clone():i.animation,S?S(i.target):i.target);return V}serialize(){const y={};y.name=this.name,y.from=this.from,y.to=this.to,y.speedRatio=this.speedRatio,y.loopAnimation=this.loopAnimation,y.isAdditive=this.isAdditive,y.weight=this.weight,y.playOrder=this.playOrder,y.enableBlending=this.enableBlending,y.blendingSpeed=this.blendingSpeed,y.targetedAnimations=[];for(let S=0;S<this.targetedAnimations.length;S++){const I=this.targetedAnimations[S];y.targetedAnimations[S]=I.serialize()}return B.d&&B.d.HasTags(this)&&(y.tags=B.d.GetTags(this)),this.metadata&&(y.metadata=this.metadata),y}static Parse(y,S){const I=new s(y.name,S,y.weight,y.playOrder);for(let i=0;i<y.targetedAnimations.length;i++){const A=y.targetedAnimations[i],B=V.b.Parse(A.animation),d=A.targetId;if("influence"===A.animation.property){const y=S.getMorphTargetById(d);y&&I.addTargetedAnimation(B,y)}else{const y=S.getNodeById(d);null!=y&&I.addTargetedAnimation(B,y)}}return B.d&&B.d.AddTagsTo(I,y.tags),null!==y.from&&null!==y.to&&I.normalize(y.from,y.to),void 0!==y.speedRatio&&(I._speedRatio=y.speedRatio),void 0!==y.loopAnimation&&(I._loopAnimation=y.loopAnimation),void 0!==y.isAdditive&&(I._isAdditive=y.isAdditive),void 0!==y.weight&&(I._weight=y.weight),void 0!==y.playOrder&&(I._playOrder=y.playOrder),void 0!==y.enableBlending&&(I._enableBlending=y.enableBlending),void 0!==y.blendingSpeed&&(I._blendingSpeed=y.blendingSpeed),void 0!==y.metadata&&(I.metadata=y.metadata),I}static MakeAnimationAdditive(y,S,I){let i;i="object"===typeof S?S:{referenceFrame:S,range:I,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let A=y;i.cloneOriginalAnimationGroup&&(A=y.clone(i.clonedAnimationGroupName||A.name));const B=A.targetedAnimations;for(let d=0;d<B.length;d++){const y=B[d];y.animation=V.b.MakeAnimationAdditive(y.animation,i)}if(A.isAdditive=!0,i.clipKeys){let y=Number.MAX_VALUE,S=-Number.MAX_VALUE;const I=A.targetedAnimations;for(let V=0;V<I.length;V++){const i=I[V].animation.getKeys();y>i[0].frame&&(y=i[0].frame),S<i[i.length-1].frame&&(S=i[i.length-1].frame)}A._from=y,A._to=S}return A}static ClipKeys(y,S,I,V,i){const A=y.clone(V||y.name);return s.ClipKeysInPlace(A,S,I,i)}static ClipKeysInPlace(y,S,I,V){return s.ClipInPlace(y,S,I,V,!1)}static ClipFrames(y,S,I,V,i){const A=y.clone(V||y.name);return s.ClipFramesInPlace(A,S,I,i)}static ClipFramesInPlace(y,S,I,V){return s.ClipInPlace(y,S,I,V,!0)}static ClipInPlace(y,S,I,V){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4],A=Number.MAX_VALUE,B=-Number.MAX_VALUE;const d=y.targetedAnimations;for(let F=0;F<d.length;F++){const y=d[F],J=V?y.animation:y.animation.clone();i&&(J.createKeyForFrame(S),J.createKeyForFrame(I));const u=J.getKeys(),K=[];let G=Number.MAX_VALUE;for(let V=0;V<u.length;V++){const y=u[V];if(!i&&V>=S&&V<=I||i&&y.frame>=S&&y.frame<=I){const S={frame:y.frame,value:y.value.clone?y.value.clone():y.value,inTangent:y.inTangent,outTangent:y.outTangent,interpolation:y.interpolation,lockedTangent:y.lockedTangent};G===Number.MAX_VALUE&&(G=S.frame),S.frame-=G,K.push(S)}}0!==K.length?(A>K[0].frame&&(A=K[0].frame),B<K[K.length-1].frame&&(B=K[K.length-1].frame),J.setKeys(K,!0),y.animation=J):(d.splice(F,1),F--)}return y._from=A,y._to=B,y}getClassName(){return"AnimationGroup"}toString(y){let S="Name: "+this.name;return S+=", type: "+this.getClassName(),y&&(S+=", from: "+this._from,S+=", to: "+this._to,S+=", isStarted: "+this._isStarted,S+=", speedRatio: "+this._speedRatio,S+=", targetedAnimations length: "+this._targetedAnimations.length,S+=", animatables length: "+this._animatables),S}}}}]);