"use strict";(self["2fwzcez286e"]=self["2fwzcez286e"]||[]).push([[78],{16178:(B,u,F)=>{F.r(u),F.d(u,{AnimationGroup:()=>X,TargetedAnimation:()=>W});var Z=F(13488),V=F(12807),p=F(12855),G=F(13016),R=F(14625),e=F(12979);class s{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(B,u,F,V){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=u,this._target=B,this._scene=F,this._host=V,this._activeTargets=[],u._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===Z.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=e.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const B={frame:0,value:this._minValue};this._keys.splice(0,0,B)}if(this._target instanceof Array){let B=0;for(const u of this._target)this._preparePath(u,B),this._getOriginalValues(B),B++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const p=u.getEvents();if(p&&p.length>0)for(const Z of p)this._events.push(Z._clone());this._enableBlending=B&&B.animationPropertiesOverride?B.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const F=this._animation.targetPropertyPath;if(F.length>1){let Z=B;for(let B=0;B<F.length-1;B++){const u=F[B];if(Z=Z[u],void 0===Z)throw new Error(`Invalid property (${u}) in property path (${F.join(".")})`)}this._targetPath=F[F.length-1],this._activeTargets[u]=Z}else this._targetPath=F[0],this._activeTargets[u]=B;if(void 0===this._activeTargets[u][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${F.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let B=0;for(const u of this._target)void 0!==this._originalValue[B]&&this._setValue(u,this._activeTargets[B],this._originalValue[B],-1,B),B++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let B=0;B<this._events.length;B++)this._events[B].isDone=!1}isStopped(){return this._stopped}dispose(){const B=this._animation.runtimeAnimations.indexOf(this);B>-1&&this._animation.runtimeAnimations.splice(B,1)}setValue(B,u){if(this._targetIsArray)for(let F=0;F<this._target.length;F++){const Z=this._target[F];this._setValue(Z,this._activeTargets[F],B,u,F)}else this._setValue(this._target,this._directTarget,B,u,0)}_getOriginalValues(){let B,u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const F=this._activeTargets[u];B=F.getLocalMatrix&&"_matrix"===this._targetPath?F.getLocalMatrix():F[this._targetPath],B&&B.clone?this._originalValue[u]=B.clone():this._originalValue[u]=B}_registerTargetForLateAnimationBinding(B,u){const F=B.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(F),F._lateAnimationHolders||(F._lateAnimationHolders={}),F._lateAnimationHolders[B.targetPath]||(F._lateAnimationHolders[B.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:u}),B.isAdditive?(F._lateAnimationHolders[B.targetPath].additiveAnimations.push(B),F._lateAnimationHolders[B.targetPath].totalAdditiveWeight+=B.weight):(F._lateAnimationHolders[B.targetPath].animations.push(B),F._lateAnimationHolders[B.targetPath].totalWeight+=B.weight)}_setValue(B,u,F,V,p){if(this._currentActiveTarget=u,this._weight=V,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const B=u[this._targetPath];B.clone?this._originalBlendValue=B.clone():this._originalBlendValue=B}this._originalBlendValue.m?Z.e.AllowMatrixDecomposeForInterpolation?this._currentValue?e.Matrix.DecomposeLerpToRef(this._originalBlendValue,F,this._blendingFactor,this._currentValue):this._currentValue=e.Matrix.DecomposeLerp(this._originalBlendValue,F,this._blendingFactor):this._currentValue?e.Matrix.LerpToRef(this._originalBlendValue,F,this._blendingFactor,this._currentValue):this._currentValue=e.Matrix.Lerp(this._originalBlendValue,F,this._blendingFactor):this._currentValue=Z.e._UniversalLerp(this._originalBlendValue,F,this._blendingFactor);const V=B&&B.animationPropertiesOverride?B.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=V}else this._currentValue?this._currentValue.Z?this._currentValue.Z(F):this._currentValue=F:null!==F&&void 0!==F&&F.clone?this._currentValue=F.clone():this._currentValue=F;-1!==V?this._registerTargetForLateAnimationBinding(this,this._originalValue[p]):this._animationState.loopMode===Z.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[p],u[this._targetPath]):u[this._targetPath]=this._originalValue[p]+this._currentValue:u[this._targetPath]=this._currentValue,B.vY&&B.vY(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const F=this._animation.getKeys();B<F[0].frame?B=F[0].frame:B>F[F.length-1].frame&&(B=F[F.length-1].frame);const Z=this._events;if(Z.length)for(let p=0;p<Z.length;p++)Z[p].onlyOnce||(Z[p].isDone=Z[p].frame<B);this._currentFrame=B;const V=this._animation._interpolate(B,this._animationState);this.setValue(V,u)}_prepareForSpeedRatioChange(B){const u=this._previousElapsedTime*(this._animation.framePerSecond*B)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-u}animate(B,u,F,V,p){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const R=this._animation,e=R.targetPropertyPath;if(!e||e.length<1)return this._stopped=!0,!1;let s,Y=!0;const Q=this._events;let t=0;if(this._coreRuntimeAnimation)t=F-u,s=this._coreRuntimeAnimation.currentFrame,this._currentFrame=s,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let G;(u<this._minFrame||u>this._maxFrame)&&(u=this._minFrame),(F<this._minFrame||F>this._maxFrame)&&(F=this._maxFrame),t=F-u;let e=B*(R.framePerSecond*p)/1e3+this._absoluteFrameOffset,v=0,D=!1;const L=V&&this._animationState.loopMode===Z.e.ANIMATIONLOOPMODE_YOYO;if(L){const B=(e-u)/t,F=Math.sin(B*Math.PI);e=Math.abs(F)*t+u;const Z=F>=0?1:-1;this._yoyoDirection!==Z&&(D=!0),this._yoyoDirection=Z}if(this._previousElapsedTime=B,this._previousAbsoluteFrame=e,!V&&F>=u&&(e>=t&&p>0||e<=0&&p<0))Y=!1,v=R._getKeyValue(this._maxValue);else if(!V&&u>=F&&(e<=t&&p<0||e>=0&&p>0))Y=!1,v=R._getKeyValue(this._minValue);else if(this._animationState.loopMode!==Z.e.ANIMATIONLOOPMODE_CYCLE){const B=F.toString()+u.toString();if(!this._offsetsCache[B]){this._animationState.repeatCount=0,this._animationState.loopMode=Z.e.ANIMATIONLOOPMODE_CYCLE;const V=R._interpolate(u,this._animationState),p=R._interpolate(F,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),R.dataType){case Z.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[B]=p-V;break;case Z.e.ANIMATIONTYPE_QUATERNION:case Z.e.ANIMATIONTYPE_VECTOR3:case Z.e.ANIMATIONTYPE_VECTOR2:case Z.e.ANIMATIONTYPE_SIZE:case Z.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[B]=p.Lu(V)}this._highLimitsCache[B]=p}v=this._highLimitsCache[B],G=this._offsetsCache[B]}if(void 0===G)switch(R.dataType){case Z.e.ANIMATIONTYPE_FLOAT:G=0;break;case Z.e.ANIMATIONTYPE_QUATERNION:G=Z.o;break;case Z.e.ANIMATIONTYPE_VECTOR3:G=Z.v;break;case Z.e.ANIMATIONTYPE_VECTOR2:G=Z.u;break;case Z.e.ANIMATIONTYPE_SIZE:G=Z.r;break;case Z.e.ANIMATIONTYPE_COLOR3:G=Z.h;break;case Z.e.ANIMATIONTYPE_COLOR4:G=Z.l}if(this._host&&this._host.syncRoot){const B=this._host.syncRoot;s=u+t*((B.masterFrame-B.fromFrame)/(B.toFrame-B.fromFrame))}else s=e>0&&u>F||e<0&&u<F?Y&&0!==t?F+e%t:u:Y&&0!==t?u+e%t:F;if(!L&&(p>0&&this.currentFrame>s||p<0&&this.currentFrame<s)||L&&D){this._onLoop();for(let B=0;B<Q.length;B++)Q[B].onlyOnce||(Q[B].isDone=!1);this._animationState.key=p>0?0:R.getKeys().length-1}this._currentFrame=s,this._animationState.repeatCount=0===t?0:e/t|0,this._animationState.highLimitValue=v,this._animationState.offsetValue=G}const v=R._interpolate(s,this._animationState);if(this.setValue(v,G),Q.length)for(let Z=0;Z<Q.length;Z++)if(t>=0&&s>=Q[Z].frame&&Q[Z].frame>=u||t<0&&s<=Q[Z].frame&&Q[Z].frame<=u){const B=Q[Z];B.isDone||(B.onlyOnce&&(Q.splice(Z,1),Z--),B.isDone=!0,B.action(s))}return Y||(this._stopped=!0),Y}}var Y=F(12834);class Q{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(B){this._weight=-1!==B?Math.min(Math.max(B,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(B){for(let u=0;u<this._runtimeAnimations.length;u++){this._runtimeAnimations[u]._prepareForSpeedRatioChange(B)}this._speedRatio=B,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(B,u){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,p=arguments.length>4&&void 0!==arguments[4]&&arguments[4],G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,R=arguments.length>6?arguments[6]:void 0,e=arguments.length>7?arguments[7]:void 0,s=arguments.length>8?arguments[8]:void 0,Y=arguments.length>9&&void 0!==arguments[9]&&arguments[9],Q=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=u,this.fromFrame=F,this.toFrame=Z,this.loopAnimation=p,this.onAnimationEnd=R,this.onAnimationLoop=s,this.isAdditive=Y,this.playOrder=Q,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.SG=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new V.b,this.onAnimationLoopObservable=new V.b,this._scene=B,e&&this.appendAnimations(u,e),this._speedRatio=G,B._activeAnimatables.push(this)}syncWith(B){if(this._syncRoot=B,B){const B=this._scene._activeAnimatables.indexOf(this);B>-1&&(this._scene._activeAnimatables.splice(B,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(B,u){for(let F=0;F<u.length;F++){const Z=u[F],V=new s(B,Z,this._scene,this);V._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(V)}}getAnimationByTargetProperty(B){const u=this._runtimeAnimations;for(let F=0;F<u.length;F++)if(u[F].animation.targetProperty===B)return u[F].animation;return null}getRuntimeAnimationByTargetProperty(B){const u=this._runtimeAnimations;for(let F=0;F<u.length;F++)if(u[F].animation.targetProperty===B)return u[F];return null}reset(){const B=this._runtimeAnimations;for(let u=0;u<B.length;u++)B[u].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(B){const u=this._runtimeAnimations;for(let F=0;F<u.length;F++)u[F].animation.enableBlending=!0,u[F].animation.blendingSpeed=B}disableBlending(){const B=this._runtimeAnimations;for(let u=0;u<B.length;u++)B[u].animation.enableBlending=!1}goToFrame(B){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const F=this._runtimeAnimations;if(F[0]){const u=F[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??F[0].currentFrame;const Z=0===this.speedRatio?0:(B-this._frameToSyncFromJump)/u*1e3/this.speedRatio;this._manualJumpDelay=-Z}for(let Z=0;Z<F.length;Z++)F[Z].goToFrame(B,u?this._weight:-1);this._goToFrame=B}get paused(){return this.SG}pause(){this.SG||(this.SG=!0)}restart(){this.SG=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(B,u){let F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(B||u){const V=this._scene._activeAnimatables.indexOf(this);if(V>-1){const p=this._runtimeAnimations;for(let F=p.length-1;F>=0;F--){const Z=p[F];B&&Z.animation.name!=B||(u&&!u(Z.target)||(Z.dispose(),p.splice(F,1)))}0==p.length&&(F||this._scene._activeAnimatables.splice(V,1),Z||this._raiseOnAnimationEnd())}}else{const B=this._scene._activeAnimatables.indexOf(this);if(B>-1){F||this._scene._activeAnimatables.splice(B,1);const u=this._runtimeAnimations;for(let B=0;B<u.length;B++)u[B].dispose();this._runtimeAnimations.length=0,Z||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((B=>{this.onAnimationEndObservable.add((()=>{B(this)}),void 0,void 0,this,!0)}))}_animate(B){if(this.SG)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=B),!0;if(null===this._localDelayOffset?(this._localDelayOffset=B,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=B-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let u=!1;const F=this._runtimeAnimations;let Z;for(Z=0;Z<F.length;Z++){const V=F[Z].animate(B-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);u=u||V}if(this.animationStarted=u,!u){if(this.disposeOnEnd)for(Z=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(Z,1),Z=0;Z<F.length;Z++)F[Z].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return u}}function t(B){if(0===B.totalWeight&&0===B.totalAdditiveWeight)return B.originalValue;let u=1;const F=e.TmpVectors.Du[0],Z=e.TmpVectors.Du[1],V=e.TmpVectors.Quaternion[0];let p=0;const G=B.animations[0],R=B.originalValue;let s=1,Y=!1;if(B.totalWeight<1)s=1-B.totalWeight,R.decompose(Z,V,F);else{if(p=1,u=B.totalWeight,s=G.weight/u,1==s){if(!B.totalAdditiveWeight)return G.currentValue;Y=!0}G.currentValue.decompose(Z,V,F)}if(!Y){Z.scaleInPlace(s),F.scaleInPlace(s),V.scaleInPlace(s);for(let G=p;G<B.animations.length;G++){const p=B.animations[G];if(0===p.weight)continue;s=p.weight/u;const R=e.TmpVectors.Du[2],Y=e.TmpVectors.Du[3],Q=e.TmpVectors.Quaternion[1];p.currentValue.decompose(Y,Q,R),Y.scaleAndAddToRef(s,Z),Q.scaleAndAddToRef(e.Quaternion.Dot(V,Q)>0?s:-s,V),R.scaleAndAddToRef(s,F)}V.normalize()}for(let t=0;t<B.additiveAnimations.length;t++){const u=B.additiveAnimations[t];if(0===u.weight)continue;const p=e.TmpVectors.Du[2],G=e.TmpVectors.Du[3],R=e.TmpVectors.Quaternion[1];u.currentValue.decompose(G,R,p),G.multiplyToRef(Z,G),e.Du.LerpToRef(Z,G,u.weight,Z),V.multiplyToRef(R,R),e.Quaternion.SlerpToRef(V,R,u.weight,V),p.scaleAndAddToRef(u.weight,F)}const Q=G?G._animationState.workValue:e.TmpVectors.Matrix[0].clone();return e.Matrix.ComposeToRef(Z,V,F,Q),Q}function v(B,u){if(0===B.totalWeight&&0===B.totalAdditiveWeight)return u;const F=B.animations[0],Z=B.originalValue;let V=u;if(0===B.totalWeight&&B.totalAdditiveWeight>0)V.Z(Z);else if(1===B.animations.length){if(e.Quaternion.SlerpToRef(Z,F.currentValue,Math.min(1,B.totalWeight),V),0===B.totalAdditiveWeight)return V}else if(B.animations.length>1){let F,p,G=1;if(B.totalWeight<1){const u=1-B.totalWeight;F=[],p=[],F.push(Z),p.push(u)}else{if(2===B.animations.length&&(e.Quaternion.SlerpToRef(B.animations[0].currentValue,B.animations[1].currentValue,B.animations[1].weight/B.totalWeight,u),0===B.totalAdditiveWeight))return u;F=[],p=[],G=B.totalWeight}for(let u=0;u<B.animations.length;u++){const Z=B.animations[u];F.push(Z.currentValue),p.push(Z.weight/G)}let R=0;for(let B=0;B<F.length;)B?(R+=p[B],e.Quaternion.SlerpToRef(V,F[B],p[B]/R,V),B++):(e.Quaternion.SlerpToRef(F[B],F[B+1],p[B+1]/(p[B]+p[B+1]),u),V=u,R=p[B]+p[B+1],B+=2)}for(let p=0;p<B.additiveAnimations.length;p++){const u=B.additiveAnimations[p];0!==u.weight&&(V.multiplyToRef(u.currentValue,e.TmpVectors.Quaternion[0]),e.Quaternion.SlerpToRef(V,e.TmpVectors.Quaternion[0],u.weight,V))}return V}var D,L,q=F(13221);D=q.e,(L=R.c)&&(L.prototype.copyAnimationRange=function(B,u,F){let V=arguments.length>3&&void 0!==arguments[3]&&arguments[3],p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new Z.e(this.name,"_matrix",B.animations[0].framePerSecond,Z.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const G=B.animations[0].getRange(u);if(!G)return!1;const R=G.from,e=G.to,s=B.animations[0].getKeys(),Y=B.length,Q=B.getParent(),t=this.getParent(),v=V&&Q&&Y&&this.length&&Y!==this.length,D=v&&t&&Q?t.length/Q.length:1,L=V&&!t&&p&&(1!==p.x||1!==p.y||1!==p.z),q=this.animations[0].getKeys();let W,X,f;for(let Z=0,C=s.length;Z<C;Z++)W=s[Z],W.frame>=R&&W.frame<=e&&(V?(f=W.value.clone(),v?(X=f.getTranslation(),f.setTranslation(X.scaleInPlace(D))):L&&p?(X=f.getTranslation(),f.setTranslation(X.multiplyInPlace(p))):f=W.value):f=W.value,q.push({frame:W.frame+F,value:f}));return this.animations[0].createRange(u,R+F,e+F),!0}),D&&(D.prototype._animate=function(B){if(!this.animationsEnabled)return;const u=Y.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=u}this.deltaTime=void 0!==B?B:this.useConstantAnimationDeltaTime?16:(u-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=u;const F=this._activeAnimatables;if(0===F.length)return;this._animationTime+=this.deltaTime;const V=this._animationTime;for(let Z=0;Z<F.length;Z++){const B=F[Z];!B._animate(V)&&B.disposeOnEnd&&Z--}!function(B){if(B._registeredForLateAnimationBindings.length){for(let u=0;u<B._registeredForLateAnimationBindings.length;u++){const F=B._registeredForLateAnimationBindings.data[u];for(const B in F._lateAnimationHolders){const u=F._lateAnimationHolders[B],V=u.animations[0],p=u.originalValue;if(void 0===p||null===p)continue;const G=Z.e.AllowMatrixDecomposeForInterpolation&&p.m;let R=F[B];if(G)R=t(u);else if(void 0!==p.w)R=v(u,R||e.Quaternion.Identity());else{let B=0,F=1;const G=V&&V._animationState.loopMode===Z.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(u.totalWeight<1)R=G?p.clone?p.clone():p:V&&p.scale?p.scale(1-u.totalWeight):V?p*(1-u.totalWeight):p.clone?p.clone():p;else if(V){F=u.totalWeight;const Z=V.weight/F;R=1!==Z?V.currentValue.scale?V.currentValue.scale(Z):V.currentValue*Z:V.currentValue,G&&(R.addToRef?R.addToRef(p,R):R+=p),B=1}for(let Z=B;Z<u.animations.length;Z++){const B=u.animations[Z],V=B.weight/F;V&&(B.currentValue.scaleAndAddToRef?B.currentValue.scaleAndAddToRef(V,R):R+=B.currentValue*V)}for(let Z=0;Z<u.additiveAnimations.length;Z++){const B=u.additiveAnimations[Z],F=B.weight;F&&(B.currentValue.scaleAndAddToRef?B.currentValue.scaleAndAddToRef(F,R):R+=B.currentValue*F)}}F[B]=R}F._lateAnimationHolders={}}B._registeredForLateAnimationBindings.reset()}}(this)},D.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((B,u)=>B.playOrder-u.playOrder))},D.prototype.beginWeightedAnimation=function(B,u,F){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,V=arguments.length>4?arguments[4]:void 0,p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,G=arguments.length>6?arguments[6]:void 0,R=arguments.length>7?arguments[7]:void 0,e=arguments.length>8?arguments[8]:void 0,s=arguments.length>9?arguments[9]:void 0,Y=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const Q=this.beginAnimation(B,u,F,V,p,G,R,!1,e,s,Y);return Q.weight=Z,Q},D.prototype.beginAnimation=function(B,u,F,Z){let V=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,p=arguments.length>5?arguments[5]:void 0,G=arguments.length>6?arguments[6]:void 0,R=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],e=arguments.length>8?arguments[8]:void 0,s=arguments.length>9?arguments[9]:void 0,Y=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(V<0){const B=u;u=F,F=B,V=-V}u>F&&(V=-V),R&&this.stopAnimation(B,void 0,e),G||(G=new Q(this,B,u,F,Z,V,p,void 0,s,Y));const t=!e||e(B);if(B.animations&&t&&G.appendAnimations(B,B.animations),B.getAnimatables){const Y=B.getAnimatables();for(let B=0;B<Y.length;B++)this.beginAnimation(Y[B],u,F,Z,V,p,G,R,e,s)}return G.reset(),G},D.prototype.beginHierarchyAnimation=function(B,u,F,Z,V){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,G=arguments.length>6?arguments[6]:void 0,R=arguments.length>7?arguments[7]:void 0,e=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],s=arguments.length>9?arguments[9]:void 0,Y=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const Q=B.getDescendants(u),t=[];t.push(this.beginAnimation(B,F,Z,V,p,G,R,e,s,void 0,Y));for(const v of Q)t.push(this.beginAnimation(v,F,Z,V,p,G,R,e,s,void 0,Y));return t},D.prototype.beginDirectAnimation=function(B,u,F,Z,V){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(p<0){const B=F;F=Z,Z=B,p=-p}return F>Z&&(p=-p),new Q(this,B,F,Z,V,p,arguments.length>6?arguments[6]:void 0,u,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},D.prototype.beginDirectHierarchyAnimation=function(B,u,F,Z,V,p,G,R,e){let s=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const Y=B.getDescendants(u),Q=[];Q.push(this.beginDirectAnimation(B,F,Z,V,p,G,R,e,s));for(const t of Y)Q.push(this.beginDirectAnimation(t,F,Z,V,p,G,R,e,s));return Q},D.prototype.getAnimatableByTarget=function(B){for(let u=0;u<this._activeAnimatables.length;u++)if(this._activeAnimatables[u].target===B)return this._activeAnimatables[u];return null},D.prototype.getAllAnimatablesByTarget=function(B){const u=[];for(let F=0;F<this._activeAnimatables.length;F++)this._activeAnimatables[F].target===B&&u.push(this._activeAnimatables[F]);return u},D.prototype.stopAnimation=function(B,u,F){const Z=this.getAllAnimatablesByTarget(B);for(const V of Z)V.stop(u,F)},D.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let B=0;B<this._activeAnimatables.length;B++)this._activeAnimatables[B].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const B of this.animationGroups)B.stop()});class W{getClassName(){return"TargetedAnimation"}serialize(){const B={};return B.animation=this.animation.serialize(),B.targetId=this.target.id,B}}class X{get mask(){return this._mask}set mask(B){this._mask!==B&&(this._mask=B,this.syncWithMask(!0))}syncWithMask(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||B){this._numActiveAnimatables=0;for(let B=0;B<this._animatables.length;++B){const u=this._animatables[B];!this.mask||this.mask.disabled||this.mask.retainsTarget(u.target.name)?(this._numActiveAnimatables++,u.paused&&u.restart()):u.paused||u.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let B=0;B<this._animatables.length;++B){const u=this._animatables[B];this.mask.retainsTarget(u.target.name)||(u.stop(),this._animatables.splice(B,1),--B)}for(let B=0;B<this._targetedAnimations.length;B++){const u=this._targetedAnimations[B];this.mask.retainsTarget(u.target.name)||(this._targetedAnimations.splice(B,1),--B)}}}get from(){return this._from}set from(B){if(this._from!==B){this._from=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].fromFrame=this._from}}}get to(){return this._to}set to(B){if(this._to!==B){this._to=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(B){if(this._speedRatio!==B){this._speedRatio=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(B){if(this._loopAnimation!==B){this._loopAnimation=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(B){if(this._isAdditive!==B){this._isAdditive=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(B){this._weight!==B&&(this._weight=B,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(B){if(this._playOrder!==B&&(this._playOrder=B,this._animatables.length>0)){for(let B=0;B<this._animatables.length;B++)this._animatables[B].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(B){if(this._enableBlending!==B&&(this._enableBlending=B,null!==B))for(let u=0;u<this._targetedAnimations.length;++u)this._targetedAnimations[u].animation.enableBlending=B}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(B){if(this._blendingSpeed!==B&&(this._blendingSpeed=B,null!==B))for(let u=0;u<this._targetedAnimations.length;++u)this._targetedAnimations[u].animation.blendingSpeed=B}getLength(B,u){B=B??this._from;return((u=u??this._to)-B)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(B){let u=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Z=arguments.length>3?arguments[3]:void 0;if(0===B.length)return null;Z=Z??B[0].weight;let V=Number.MAX_VALUE,p=-Number.MAX_VALUE;if(F)for(const R of B)R.from<V&&(V=R.from),R.to>p&&(p=R.to);const G=new X(B[0].name+"_merged",B[0]._scene,Z);for(const R of B){F&&R.normalize(V,p);for(const B of R.targetedAnimations)G.addTargetedAnimation(B.animation,B.target);u&&R.dispose()}return G}constructor(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=B,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new V.b,this.onAnimationLoopObservable=new V.b,this.onAnimationGroupLoopObservable=new V.b,this.onAnimationGroupEndObservable=new V.b,this.onAnimationGroupPauseObservable=new V.b,this.onAnimationGroupPlayObservable=new V.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=u||p.b.LastCreatedScene,this._weight=F,this._playOrder=Z,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(B,u){const F=new W;F.animation=B,F.target=u;const Z=B.getKeys();return this._from>Z[0].frame&&(this._from=Z[0].frame),this._to<Z[Z.length-1].frame&&(this._to=Z[Z.length-1].frame),null!==this._enableBlending&&(B.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(B.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(F),this._shouldStart=!0,F}removeTargetedAnimation(B){for(let u=this._targetedAnimations.length-1;u>-1;u--){this._targetedAnimations[u].animation===B&&this._targetedAnimations.splice(u,1)}}normalize(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==B&&(B=this._from),null==u&&(u=this._to);for(let F=0;F<this._targetedAnimations.length;F++){const Z=this._targetedAnimations[F].animation.getKeys(),V=Z[0],p=Z[Z.length-1];if(V.frame>B){const u={frame:B,value:V.value,inTangent:V.inTangent,outTangent:V.outTangent,interpolation:V.interpolation};Z.splice(0,0,u)}if(p.frame<u){const B={frame:u,value:p.value,inTangent:p.inTangent,outTangent:p.outTangent,interpolation:p.interpolation};Z.push(B)}}return this._from=B,this._to=u,this}_processLoop(B,u,F){B.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(u),this._animationLoopFlags[F]||(this._animationLoopFlags[F]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0],u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0,Z=arguments.length>3?arguments[3]:void 0,V=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=B,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let p=0;p<this._targetedAnimations.length;p++){const G=this._targetedAnimations[p],R=this._scene.beginDirectAnimation(G.target,[G.animation],void 0!==F?F:this._from,void 0!==Z?Z:this._to,B,u,void 0,void 0,void 0!==V?V:this._isAdditive);R.weight=this._weight,R.playOrder=this._playOrder,R.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(G),this._checkAnimationGroupEnded(R)},this._processLoop(R,G,p),this._animatables.push(R)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=u,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let B=0;B<this._animatables.length;B++){this._animatables[B].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(B){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==B&&(this.loopAnimation=B),this.restart()):(this.stop(),this.start(B,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let B=0;B<this._animatables.length;B++){this._animatables[B].reset()}return this}restart(){if(!this._isStarted)return this;for(let B=0;B<this._animatables.length;B++){this._animatables[B].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const u=this._animatables.slice();for(let Z=0;Z<u.length;Z++)u[Z].stop(void 0,void 0,!0,B);let F=0;for(let Z=0;Z<this._scene._activeAnimatables.length;Z++){const u=this._scene._activeAnimatables[Z];u._runtimeAnimations.length>0?this._scene._activeAnimatables[F++]=u:B&&this._checkAnimationGroupEnded(u,B)}return this._scene._activeAnimatables.length=F,this._isStarted=!1,this}setWeightForAllAnimatables(B){for(let u=0;u<this._animatables.length;u++){this._animatables[u].weight=B}return this}syncAllAnimationsWith(B){for(let u=0;u<this._animatables.length;u++){this._animatables[u].syncWith(B)}return this}goToFrame(B){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let F=0;F<this._animatables.length;F++){this._animatables[F].goToFrame(B,u)}return this}getCurrentFrame(){var B;return(null===(B=this.animatables[0])||void 0===B?void 0:B.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const B=this._scene.animationGroups.indexOf(this);if(B>-1&&this._scene.animationGroups.splice(B,1),this._parentContainer){const B=this._parentContainer.animationGroups.indexOf(this);B>-1&&this._parentContainer.animationGroups.splice(B,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(B){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const F=this._animatables.indexOf(B);F>-1&&this._animatables.splice(F,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,u||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(B,u){let F=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Z=new X(B||this.name,this._scene,this._weight,this._playOrder);Z._from=this.from,Z._to=this.to,Z._speedRatio=this.speedRatio,Z._loopAnimation=this.loopAnimation,Z._isAdditive=this.isAdditive,Z._enableBlending=this.enableBlending,Z._blendingSpeed=this.blendingSpeed,Z.metadata=this.metadata,Z.mask=this.mask;for(const V of this._targetedAnimations)Z.addTargetedAnimation(F?V.animation.clone():V.animation,u?u(V.target):V.target);return Z}serialize(){const B={};B.name=this.name,B.from=this.from,B.to=this.to,B.speedRatio=this.speedRatio,B.loopAnimation=this.loopAnimation,B.isAdditive=this.isAdditive,B.weight=this.weight,B.playOrder=this.playOrder,B.enableBlending=this.enableBlending,B.blendingSpeed=this.blendingSpeed,B.targetedAnimations=[];for(let u=0;u<this.targetedAnimations.length;u++){const F=this.targetedAnimations[u];B.targetedAnimations[u]=F.serialize()}return G.c&&G.c.HasTags(this)&&(B.tags=G.c.GetTags(this)),this.metadata&&(B.metadata=this.metadata),B}static Parse(B,u){const F=new X(B.name,u,B.weight,B.playOrder);for(let V=0;V<B.targetedAnimations.length;V++){const p=B.targetedAnimations[V],G=Z.e.Parse(p.animation),R=p.targetId;if("influence"===p.animation.property){const B=u.getMorphTargetById(R);B&&F.addTargetedAnimation(G,B)}else{const B=u.getNodeById(R);null!=B&&F.addTargetedAnimation(G,B)}}return G.c&&G.c.AddTagsTo(F,B.tags),null!==B.from&&null!==B.to&&F.normalize(B.from,B.to),void 0!==B.speedRatio&&(F._speedRatio=B.speedRatio),void 0!==B.loopAnimation&&(F._loopAnimation=B.loopAnimation),void 0!==B.isAdditive&&(F._isAdditive=B.isAdditive),void 0!==B.weight&&(F._weight=B.weight),void 0!==B.playOrder&&(F._playOrder=B.playOrder),void 0!==B.enableBlending&&(F._enableBlending=B.enableBlending),void 0!==B.blendingSpeed&&(F._blendingSpeed=B.blendingSpeed),void 0!==B.metadata&&(F.metadata=B.metadata),F}static MakeAnimationAdditive(B,u,F){let V;V="object"===typeof u?u:{referenceFrame:u,range:F,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let p=B;V.cloneOriginalAnimationGroup&&(p=B.clone(V.clonedAnimationGroupName||p.name));const G=p.targetedAnimations;for(let R=0;R<G.length;R++){const B=G[R];B.animation=Z.e.MakeAnimationAdditive(B.animation,V)}if(p.isAdditive=!0,V.clipKeys){let B=Number.MAX_VALUE,u=-Number.MAX_VALUE;const F=p.targetedAnimations;for(let Z=0;Z<F.length;Z++){const V=F[Z].animation.getKeys();B>V[0].frame&&(B=V[0].frame),u<V[V.length-1].frame&&(u=V[V.length-1].frame)}p._from=B,p._to=u}return p}static ClipKeys(B,u,F,Z,V){const p=B.clone(Z||B.name);return X.ClipKeysInPlace(p,u,F,V)}static ClipKeysInPlace(B,u,F,Z){return X.ClipInPlace(B,u,F,Z,!1)}static ClipFrames(B,u,F,Z,V){const p=B.clone(Z||B.name);return X.ClipFramesInPlace(p,u,F,V)}static ClipFramesInPlace(B,u,F,Z){return X.ClipInPlace(B,u,F,Z,!0)}static ClipInPlace(B,u,F,Z){let V=arguments.length>4&&void 0!==arguments[4]&&arguments[4],p=Number.MAX_VALUE,G=-Number.MAX_VALUE;const R=B.targetedAnimations;for(let e=0;e<R.length;e++){const B=R[e],s=Z?B.animation:B.animation.clone();V&&(s.createKeyForFrame(u),s.createKeyForFrame(F));const Y=s.getKeys(),Q=[];let t=Number.MAX_VALUE;for(let Z=0;Z<Y.length;Z++){const B=Y[Z];if(!V&&Z>=u&&Z<=F||V&&B.frame>=u&&B.frame<=F){const u={frame:B.frame,value:B.value.clone?B.value.clone():B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation,lockedTangent:B.lockedTangent};t===Number.MAX_VALUE&&(t=u.frame),u.frame-=t,Q.push(u)}}0!==Q.length?(p>Q[0].frame&&(p=Q[0].frame),G<Q[Q.length-1].frame&&(G=Q[Q.length-1].frame),s.setKeys(Q,!0),B.animation=s):(R.splice(e,1),e--)}return B._from=p,B._to=G,B}getClassName(){return"AnimationGroup"}toString(B){let u="Name: "+this.name;return u+=", type: "+this.getClassName(),B&&(u+=", from: "+this._from,u+=", to: "+this._to,u+=", isStarted: "+this._isStarted,u+=", speedRatio: "+this._speedRatio,u+=", targetedAnimations length: "+this._targetedAnimations.length,u+=", animatables length: "+this._animatables),u}}}}]);