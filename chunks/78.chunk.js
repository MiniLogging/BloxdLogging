"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[78],{14265:(g,w,q)=>{q.r(w),q.d(w,{AnimationGroup:()=>x,TargetedAnimation:()=>J});var R=q(11659),o=q(10998),r=q(11034),S=q(11226),i=q(12757),T=q(11180);class z{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(g,w,q,o){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=w,this._target=g,this._scene=q,this._host=o,this._activeTargets=[],w._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===R.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=T.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const g={frame:0,value:this._minValue};this._keys.splice(0,0,g)}if(this._target instanceof Array){let g=0;for(const w of this._target)this._preparePath(w,g),this._getOriginalValues(g),g++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const r=w.getEvents();if(r&&r.length>0)for(const R of r)this._events.push(R._clone());this._enableBlending=g&&g.animationPropertiesOverride?g.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const q=this._animation.targetPropertyPath;if(q.length>1){let R=g;for(let g=0;g<q.length-1;g++){const w=q[g];if(R=R[w],void 0===R)throw new Error(`Invalid property (${w}) in property path (${q.join(".")})`)}this._targetPath=q[q.length-1],this._activeTargets[w]=R}else this._targetPath=q[0],this._activeTargets[w]=g;if(void 0===this._activeTargets[w][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${q.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let g=0;for(const w of this._target)void 0!==this._originalValue[g]&&this._setValue(w,this._activeTargets[g],this._originalValue[g],-1,g),g++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let g=0;g<this._events.length;g++)this._events[g].isDone=!1}isStopped(){return this._stopped}dispose(){const g=this._animation.runtimeAnimations.indexOf(this);g>-1&&this._animation.runtimeAnimations.splice(g,1)}setValue(g,w){if(this._targetIsArray)for(let q=0;q<this._target.length;q++){const R=this._target[q];this._setValue(R,this._activeTargets[q],g,w,q)}else this._setValue(this._target,this._directTarget,g,w,0)}_getOriginalValues(){let g,w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const q=this._activeTargets[w];g=q.getLocalMatrix&&"_matrix"===this._targetPath?q.getLocalMatrix():q[this._targetPath],g&&g.clone?this._originalValue[w]=g.clone():this._originalValue[w]=g}_registerTargetForLateAnimationBinding(g,w){const q=g.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(q),q._lateAnimationHolders||(q._lateAnimationHolders={}),q._lateAnimationHolders[g.targetPath]||(q._lateAnimationHolders[g.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:w}),g.isAdditive?(q._lateAnimationHolders[g.targetPath].additiveAnimations.push(g),q._lateAnimationHolders[g.targetPath].totalAdditiveWeight+=g.weight):(q._lateAnimationHolders[g.targetPath].animations.push(g),q._lateAnimationHolders[g.targetPath].totalWeight+=g.weight)}_setValue(g,w,q,o,r){if(this._currentActiveTarget=w,this._weight=o,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const g=w[this._targetPath];g.clone?this._originalBlendValue=g.clone():this._originalBlendValue=g}this._originalBlendValue.m?R.c.AllowMatrixDecomposeForInterpolation?this._currentValue?T.Matrix.DecomposeLerpToRef(this._originalBlendValue,q,this._blendingFactor,this._currentValue):this._currentValue=T.Matrix.DecomposeLerp(this._originalBlendValue,q,this._blendingFactor):this._currentValue?T.Matrix.LerpToRef(this._originalBlendValue,q,this._blendingFactor,this._currentValue):this._currentValue=T.Matrix.Lerp(this._originalBlendValue,q,this._blendingFactor):this._currentValue=R.c._UniversalLerp(this._originalBlendValue,q,this._blendingFactor);const o=g&&g.animationPropertiesOverride?g.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=o}else this._currentValue?this._currentValue.T?this._currentValue.T(q):this._currentValue=q:null!==q&&void 0!==q&&q.clone?this._currentValue=q.clone():this._currentValue=q;-1!==o?this._registerTargetForLateAnimationBinding(this,this._originalValue[r]):this._animationState.loopMode===R.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[r],w[this._targetPath]):w[this._targetPath]=this._originalValue[r]+this._currentValue:w[this._targetPath]=this._currentValue,g.jz&&g.jz(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const q=this._animation.getKeys();g<q[0].frame?g=q[0].frame:g>q[q.length-1].frame&&(g=q[q.length-1].frame);const R=this._events;if(R.length)for(let r=0;r<R.length;r++)R[r].onlyOnce||(R[r].isDone=R[r].frame<g);this._currentFrame=g;const o=this._animation._interpolate(g,this._animationState);this.setValue(o,w)}_prepareForSpeedRatioChange(g){const w=this._previousElapsedTime*(this._animation.framePerSecond*g)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-w}animate(g,w,q,o,r){let S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const i=this._animation,T=i.targetPropertyPath;if(!T||T.length<1)return this._stopped=!0,!1;let z,t=!0;const m=this._events;let e=0;if(this._coreRuntimeAnimation)e=q-w,z=this._coreRuntimeAnimation.currentFrame,this._currentFrame=z,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let S;(w<this._minFrame||w>this._maxFrame)&&(w=this._minFrame),(q<this._minFrame||q>this._maxFrame)&&(q=this._maxFrame),e=q-w;let T=g*(i.framePerSecond*r)/1e3+this._absoluteFrameOffset,y=0,L=!1;const A=o&&this._animationState.loopMode===R.c.ANIMATIONLOOPMODE_YOYO;if(A){const g=(T-w)/e,q=Math.sin(g*Math.PI);T=Math.abs(q)*e+w;const R=q>=0?1:-1;this._yoyoDirection!==R&&(L=!0),this._yoyoDirection=R}if(this._previousElapsedTime=g,this._previousAbsoluteFrame=T,!o&&q>=w&&(T>=e&&r>0||T<=0&&r<0))t=!1,y=i._getKeyValue(this._maxValue);else if(!o&&w>=q&&(T<=e&&r<0||T>=0&&r>0))t=!1,y=i._getKeyValue(this._minValue);else if(this._animationState.loopMode!==R.c.ANIMATIONLOOPMODE_CYCLE){const g=q.toString()+w.toString();if(!this._offsetsCache[g]){this._animationState.repeatCount=0,this._animationState.loopMode=R.c.ANIMATIONLOOPMODE_CYCLE;const o=i._interpolate(w,this._animationState),r=i._interpolate(q,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),i.dataType){case R.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[g]=r-o;break;case R.c.ANIMATIONTYPE_QUATERNION:case R.c.ANIMATIONTYPE_VECTOR3:case R.c.ANIMATIONTYPE_VECTOR2:case R.c.ANIMATIONTYPE_SIZE:case R.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[g]=r.yw(o)}this._highLimitsCache[g]=r}y=this._highLimitsCache[g],S=this._offsetsCache[g]}if(void 0===S)switch(i.dataType){case R.c.ANIMATIONTYPE_FLOAT:S=0;break;case R.c.ANIMATIONTYPE_QUATERNION:S=R.m;break;case R.c.ANIMATIONTYPE_VECTOR3:S=R.t;break;case R.c.ANIMATIONTYPE_VECTOR2:S=R.r;break;case R.c.ANIMATIONTYPE_SIZE:S=R.o;break;case R.c.ANIMATIONTYPE_COLOR3:S=R.g;break;case R.c.ANIMATIONTYPE_COLOR4:S=R.j}if(this._host&&this._host.syncRoot){const g=this._host.syncRoot;z=w+e*((g.masterFrame-g.fromFrame)/(g.toFrame-g.fromFrame))}else z=T>0&&w>q||T<0&&w<q?t&&0!==e?q+T%e:w:t&&0!==e?w+T%e:q;if(!A&&(r>0&&this.currentFrame>z||r<0&&this.currentFrame<z)||A&&L){this._onLoop();for(let g=0;g<m.length;g++)m[g].onlyOnce||(m[g].isDone=!1);this._animationState.key=r>0?0:i.getKeys().length-1}this._currentFrame=z,this._animationState.repeatCount=0===e?0:T/e|0,this._animationState.highLimitValue=y,this._animationState.offsetValue=S}const y=i._interpolate(z,this._animationState);if(this.setValue(y,S),m.length)for(let R=0;R<m.length;R++)if(e>=0&&z>=m[R].frame&&m[R].frame>=w||e<0&&z<=m[R].frame&&m[R].frame<=w){const g=m[R];g.isDone||(g.onlyOnce&&(m.splice(R,1),R--),g.isDone=!0,g.action(z))}return t||(this._stopped=!0),t}}var t=q(11023);class m{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(g){this._weight=-1!==g?Math.min(Math.max(g,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(g){for(let w=0;w<this._runtimeAnimations.length;w++){this._runtimeAnimations[w]._prepareForSpeedRatioChange(g)}this._speedRatio=g,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(g,w){let q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0,T=arguments.length>7?arguments[7]:void 0,z=arguments.length>8?arguments[8]:void 0,t=arguments.length>9&&void 0!==arguments[9]&&arguments[9],m=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=w,this.fromFrame=q,this.toFrame=R,this.loopAnimation=r,this.onAnimationEnd=i,this.onAnimationLoop=z,this.isAdditive=t,this.playOrder=m,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.KS=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new o.b,this.onAnimationLoopObservable=new o.b,this._scene=g,T&&this.appendAnimations(w,T),this._speedRatio=S,g._activeAnimatables.push(this)}syncWith(g){if(this._syncRoot=g,g){const g=this._scene._activeAnimatables.indexOf(this);g>-1&&(this._scene._activeAnimatables.splice(g,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(g,w){for(let q=0;q<w.length;q++){const R=w[q],o=new z(g,R,this._scene,this);o._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(o)}}getAnimationByTargetProperty(g){const w=this._runtimeAnimations;for(let q=0;q<w.length;q++)if(w[q].animation.targetProperty===g)return w[q].animation;return null}getRuntimeAnimationByTargetProperty(g){const w=this._runtimeAnimations;for(let q=0;q<w.length;q++)if(w[q].animation.targetProperty===g)return w[q];return null}reset(){const g=this._runtimeAnimations;for(let w=0;w<g.length;w++)g[w].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(g){const w=this._runtimeAnimations;for(let q=0;q<w.length;q++)w[q].animation.enableBlending=!0,w[q].animation.blendingSpeed=g}disableBlending(){const g=this._runtimeAnimations;for(let w=0;w<g.length;w++)g[w].animation.enableBlending=!1}goToFrame(g){let w=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const q=this._runtimeAnimations;if(q[0]){const w=q[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??q[0].currentFrame;const R=0===this.speedRatio?0:(g-this._frameToSyncFromJump)/w*1e3/this.speedRatio;this._manualJumpDelay=-R}for(let R=0;R<q.length;R++)q[R].goToFrame(g,w?this._weight:-1);this._goToFrame=g}get paused(){return this.KS}pause(){this.KS||(this.KS=!0)}restart(){this.KS=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(g,w){let q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],R=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(g||w){const o=this._scene._activeAnimatables.indexOf(this);if(o>-1){const r=this._runtimeAnimations;for(let q=r.length-1;q>=0;q--){const R=r[q];g&&R.animation.name!=g||(w&&!w(R.target)||(R.dispose(),r.splice(q,1)))}0==r.length&&(q||this._scene._activeAnimatables.splice(o,1),R||this._raiseOnAnimationEnd())}}else{const g=this._scene._activeAnimatables.indexOf(this);if(g>-1){q||this._scene._activeAnimatables.splice(g,1);const w=this._runtimeAnimations;for(let g=0;g<w.length;g++)w[g].dispose();this._runtimeAnimations.length=0,R||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((g=>{this.onAnimationEndObservable.add((()=>{g(this)}),void 0,void 0,this,!0)}))}_animate(g){if(this.KS)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=g),!0;if(null===this._localDelayOffset?(this._localDelayOffset=g,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=g-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let w=!1;const q=this._runtimeAnimations;let R;for(R=0;R<q.length;R++){const o=q[R].animate(g-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);w=w||o}if(this.animationStarted=w,!w){if(this.disposeOnEnd)for(R=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(R,1),R=0;R<q.length;R++)q[R].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return w}}function e(g){if(0===g.totalWeight&&0===g.totalAdditiveWeight)return g.originalValue;let w=1;const q=T.TmpVectors.ew[0],R=T.TmpVectors.ew[1],o=T.TmpVectors.Quaternion[0];let r=0;const S=g.animations[0],i=g.originalValue;let z=1,t=!1;if(g.totalWeight<1)z=1-g.totalWeight,i.decompose(R,o,q);else{if(r=1,w=g.totalWeight,z=S.weight/w,1==z){if(!g.totalAdditiveWeight)return S.currentValue;t=!0}S.currentValue.decompose(R,o,q)}if(!t){R.scaleInPlace(z),q.scaleInPlace(z),o.scaleInPlace(z);for(let S=r;S<g.animations.length;S++){const r=g.animations[S];if(0===r.weight)continue;z=r.weight/w;const i=T.TmpVectors.ew[2],t=T.TmpVectors.ew[3],m=T.TmpVectors.Quaternion[1];r.currentValue.decompose(t,m,i),t.scaleAndAddToRef(z,R),m.scaleAndAddToRef(T.Quaternion.Dot(o,m)>0?z:-z,o),i.scaleAndAddToRef(z,q)}o.normalize()}for(let e=0;e<g.additiveAnimations.length;e++){const w=g.additiveAnimations[e];if(0===w.weight)continue;const r=T.TmpVectors.ew[2],S=T.TmpVectors.ew[3],i=T.TmpVectors.Quaternion[1];w.currentValue.decompose(S,i,r),S.multiplyToRef(R,S),T.ew.LerpToRef(R,S,w.weight,R),o.multiplyToRef(i,i),T.Quaternion.SlerpToRef(o,i,w.weight,o),r.scaleAndAddToRef(w.weight,q)}const m=S?S._animationState.workValue:T.TmpVectors.Matrix[0].clone();return T.Matrix.ComposeToRef(R,o,q,m),m}function y(g,w){if(0===g.totalWeight&&0===g.totalAdditiveWeight)return w;const q=g.animations[0],R=g.originalValue;let o=w;if(0===g.totalWeight&&g.totalAdditiveWeight>0)o.T(R);else if(1===g.animations.length){if(T.Quaternion.SlerpToRef(R,q.currentValue,Math.min(1,g.totalWeight),o),0===g.totalAdditiveWeight)return o}else if(g.animations.length>1){let q,r,S=1;if(g.totalWeight<1){const w=1-g.totalWeight;q=[],r=[],q.push(R),r.push(w)}else{if(2===g.animations.length&&(T.Quaternion.SlerpToRef(g.animations[0].currentValue,g.animations[1].currentValue,g.animations[1].weight/g.totalWeight,w),0===g.totalAdditiveWeight))return w;q=[],r=[],S=g.totalWeight}for(let w=0;w<g.animations.length;w++){const R=g.animations[w];q.push(R.currentValue),r.push(R.weight/S)}let i=0;for(let g=0;g<q.length;)g?(i+=r[g],T.Quaternion.SlerpToRef(o,q[g],r[g]/i,o),g++):(T.Quaternion.SlerpToRef(q[g],q[g+1],r[g+1]/(r[g]+r[g+1]),w),o=w,i=r[g]+r[g+1],g+=2)}for(let r=0;r<g.additiveAnimations.length;r++){const w=g.additiveAnimations[r];0!==w.weight&&(o.multiplyToRef(w.currentValue,T.TmpVectors.Quaternion[0]),T.Quaternion.SlerpToRef(o,T.TmpVectors.Quaternion[0],w.weight,o))}return o}var L,A,l=q(11395);L=l.c,(A=i.e)&&(A.prototype.copyAnimationRange=function(g,w,q){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new R.c(this.name,"_matrix",g.animations[0].framePerSecond,R.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const S=g.animations[0].getRange(w);if(!S)return!1;const i=S.from,T=S.to,z=g.animations[0].getKeys(),t=g.length,m=g.getParent(),e=this.getParent(),y=o&&m&&t&&this.length&&t!==this.length,L=y&&e&&m?e.length/m.length:1,A=o&&!e&&r&&(1!==r.x||1!==r.y||1!==r.z),l=this.animations[0].getKeys();let J,x,G;for(let R=0,d=z.length;R<d;R++)J=z[R],J.frame>=i&&J.frame<=T&&(o?(G=J.value.clone(),y?(x=G.getTranslation(),G.setTranslation(x.scaleInPlace(L))):A&&r?(x=G.getTranslation(),G.setTranslation(x.multiplyInPlace(r))):G=J.value):G=J.value,l.push({frame:J.frame+q,value:G}));return this.animations[0].createRange(w,i+q,T+q),!0}),L&&(L.prototype._animate=function(g){if(!this.animationsEnabled)return;const w=t.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=w}this.deltaTime=void 0!==g?g:this.useConstantAnimationDeltaTime?16:(w-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=w;const q=this._activeAnimatables;if(0===q.length)return;this._animationTime+=this.deltaTime;const o=this._animationTime;for(let R=0;R<q.length;R++){const g=q[R];!g._animate(o)&&g.disposeOnEnd&&R--}!function(g){if(g._registeredForLateAnimationBindings.length){for(let w=0;w<g._registeredForLateAnimationBindings.length;w++){const q=g._registeredForLateAnimationBindings.data[w];for(const g in q._lateAnimationHolders){const w=q._lateAnimationHolders[g],o=w.animations[0],r=w.originalValue;if(void 0===r||null===r)continue;const S=R.c.AllowMatrixDecomposeForInterpolation&&r.m;let i=q[g];if(S)i=e(w);else if(void 0!==r.w)i=y(w,i||T.Quaternion.Identity());else{let g=0,q=1;const S=o&&o._animationState.loopMode===R.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(w.totalWeight<1)i=S?r.clone?r.clone():r:o&&r.scale?r.scale(1-w.totalWeight):o?r*(1-w.totalWeight):r.clone?r.clone():r;else if(o){q=w.totalWeight;const R=o.weight/q;i=1!==R?o.currentValue.scale?o.currentValue.scale(R):o.currentValue*R:o.currentValue,S&&(i.addToRef?i.addToRef(r,i):i+=r),g=1}for(let R=g;R<w.animations.length;R++){const g=w.animations[R],o=g.weight/q;o&&(g.currentValue.scaleAndAddToRef?g.currentValue.scaleAndAddToRef(o,i):i+=g.currentValue*o)}for(let R=0;R<w.additiveAnimations.length;R++){const g=w.additiveAnimations[R],q=g.weight;q&&(g.currentValue.scaleAndAddToRef?g.currentValue.scaleAndAddToRef(q,i):i+=g.currentValue*q)}}q[g]=i}q._lateAnimationHolders={}}g._registeredForLateAnimationBindings.reset()}}(this)},L.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((g,w)=>g.playOrder-w.playOrder))},L.prototype.beginWeightedAnimation=function(g,w,q){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,o=arguments.length>4?arguments[4]:void 0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,S=arguments.length>6?arguments[6]:void 0,i=arguments.length>7?arguments[7]:void 0,T=arguments.length>8?arguments[8]:void 0,z=arguments.length>9?arguments[9]:void 0,t=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const m=this.beginAnimation(g,w,q,o,r,S,i,!1,T,z,t);return m.weight=R,m},L.prototype.beginAnimation=function(g,w,q,R){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,r=arguments.length>5?arguments[5]:void 0,S=arguments.length>6?arguments[6]:void 0,i=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],T=arguments.length>8?arguments[8]:void 0,z=arguments.length>9?arguments[9]:void 0,t=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(o<0){const g=w;w=q,q=g,o=-o}w>q&&(o=-o),i&&this.stopAnimation(g,void 0,T),S||(S=new m(this,g,w,q,R,o,r,void 0,z,t));const e=!T||T(g);if(g.animations&&e&&S.appendAnimations(g,g.animations),g.getAnimatables){const t=g.getAnimatables();for(let g=0;g<t.length;g++)this.beginAnimation(t[g],w,q,R,o,r,S,i,T,z)}return S.reset(),S},L.prototype.beginHierarchyAnimation=function(g,w,q,R,o){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,S=arguments.length>6?arguments[6]:void 0,i=arguments.length>7?arguments[7]:void 0,T=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],z=arguments.length>9?arguments[9]:void 0,t=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const m=g.getDescendants(w),e=[];e.push(this.beginAnimation(g,q,R,o,r,S,i,T,z,void 0,t));for(const y of m)e.push(this.beginAnimation(y,q,R,o,r,S,i,T,z,void 0,t));return e},L.prototype.beginDirectAnimation=function(g,w,q,R,o){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(r<0){const g=q;q=R,R=g,r=-r}return q>R&&(r=-r),new m(this,g,q,R,o,r,arguments.length>6?arguments[6]:void 0,w,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},L.prototype.beginDirectHierarchyAnimation=function(g,w,q,R,o,r,S,i,T){let z=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const t=g.getDescendants(w),m=[];m.push(this.beginDirectAnimation(g,q,R,o,r,S,i,T,z));for(const e of t)m.push(this.beginDirectAnimation(e,q,R,o,r,S,i,T,z));return m},L.prototype.getAnimatableByTarget=function(g){for(let w=0;w<this._activeAnimatables.length;w++)if(this._activeAnimatables[w].target===g)return this._activeAnimatables[w];return null},L.prototype.getAllAnimatablesByTarget=function(g){const w=[];for(let q=0;q<this._activeAnimatables.length;q++)this._activeAnimatables[q].target===g&&w.push(this._activeAnimatables[q]);return w},L.prototype.stopAnimation=function(g,w,q){const R=this.getAllAnimatablesByTarget(g);for(const o of R)o.stop(w,q)},L.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let g=0;g<this._activeAnimatables.length;g++)this._activeAnimatables[g].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const g of this.animationGroups)g.stop()});class J{getClassName(){return"TargetedAnimation"}serialize(){const g={};return g.animation=this.animation.serialize(),g.targetId=this.target.id,g}}class x{get mask(){return this._mask}set mask(g){this._mask!==g&&(this._mask=g,this.syncWithMask(!0))}syncWithMask(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||g){this._numActiveAnimatables=0;for(let g=0;g<this._animatables.length;++g){const w=this._animatables[g];!this.mask||this.mask.disabled||this.mask.retainsTarget(w.target.name)?(this._numActiveAnimatables++,w.paused&&w.restart()):w.paused||w.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let g=0;g<this._animatables.length;++g){const w=this._animatables[g];this.mask.retainsTarget(w.target.name)||(w.stop(),this._animatables.splice(g,1),--g)}for(let g=0;g<this._targetedAnimations.length;g++){const w=this._targetedAnimations[g];this.mask.retainsTarget(w.target.name)||(this._targetedAnimations.splice(g,1),--g)}}}get from(){return this._from}set from(g){if(this._from!==g){this._from=g;for(let g=0;g<this._animatables.length;g++){this._animatables[g].fromFrame=this._from}}}get to(){return this._to}set to(g){if(this._to!==g){this._to=g;for(let g=0;g<this._animatables.length;g++){this._animatables[g].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(g){if(this._speedRatio!==g){this._speedRatio=g;for(let g=0;g<this._animatables.length;g++){this._animatables[g].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(g){if(this._loopAnimation!==g){this._loopAnimation=g;for(let g=0;g<this._animatables.length;g++){this._animatables[g].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(g){if(this._isAdditive!==g){this._isAdditive=g;for(let g=0;g<this._animatables.length;g++){this._animatables[g].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(g){this._weight!==g&&(this._weight=g,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(g){if(this._playOrder!==g&&(this._playOrder=g,this._animatables.length>0)){for(let g=0;g<this._animatables.length;g++)this._animatables[g].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(g){if(this._enableBlending!==g&&(this._enableBlending=g,null!==g))for(let w=0;w<this._targetedAnimations.length;++w)this._targetedAnimations[w].animation.enableBlending=g}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(g){if(this._blendingSpeed!==g&&(this._blendingSpeed=g,null!==g))for(let w=0;w<this._targetedAnimations.length;++w)this._targetedAnimations[w].animation.blendingSpeed=g}getLength(g,w){g=g??this._from;return((w=w??this._to)-g)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(g){let w=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],R=arguments.length>3?arguments[3]:void 0;if(0===g.length)return null;R=R??g[0].weight;let o=Number.MAX_VALUE,r=-Number.MAX_VALUE;if(q)for(const i of g)i.from<o&&(o=i.from),i.to>r&&(r=i.to);const S=new x(g[0].name+"_merged",g[0]._scene,R);for(const i of g){q&&i.normalize(o,r);for(const g of i.targetedAnimations)S.addTargetedAnimation(g.animation,g.target);w&&i.dispose()}return S}constructor(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=g,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new o.b,this.onAnimationLoopObservable=new o.b,this.onAnimationGroupLoopObservable=new o.b,this.onAnimationGroupEndObservable=new o.b,this.onAnimationGroupPauseObservable=new o.b,this.onAnimationGroupPlayObservable=new o.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=w||r.c.LastCreatedScene,this._weight=q,this._playOrder=R,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(g,w){const q=new J;q.animation=g,q.target=w;const R=g.getKeys();return this._from>R[0].frame&&(this._from=R[0].frame),this._to<R[R.length-1].frame&&(this._to=R[R.length-1].frame),null!==this._enableBlending&&(g.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(g.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(q),this._shouldStart=!0,q}removeTargetedAnimation(g){for(let w=this._targetedAnimations.length-1;w>-1;w--){this._targetedAnimations[w].animation===g&&this._targetedAnimations.splice(w,1)}}normalize(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==g&&(g=this._from),null==w&&(w=this._to);for(let q=0;q<this._targetedAnimations.length;q++){const R=this._targetedAnimations[q].animation.getKeys(),o=R[0],r=R[R.length-1];if(o.frame>g){const w={frame:g,value:o.value,inTangent:o.inTangent,outTangent:o.outTangent,interpolation:o.interpolation};R.splice(0,0,w)}if(r.frame<w){const g={frame:w,value:r.value,inTangent:r.inTangent,outTangent:r.outTangent,interpolation:r.interpolation};R.push(g)}}return this._from=g,this._to=w,this}_processLoop(g,w,q){g.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(w),this._animationLoopFlags[q]||(this._animationLoopFlags[q]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0],w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,q=arguments.length>2?arguments[2]:void 0,R=arguments.length>3?arguments[3]:void 0,o=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=g,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let r=0;r<this._targetedAnimations.length;r++){const S=this._targetedAnimations[r],i=this._scene.beginDirectAnimation(S.target,[S.animation],void 0!==q?q:this._from,void 0!==R?R:this._to,g,w,void 0,void 0,void 0!==o?o:this._isAdditive);i.weight=this._weight,i.playOrder=this._playOrder,i.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(S),this._checkAnimationGroupEnded(i)},this._processLoop(i,S,r),this._animatables.push(i)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=w,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let g=0;g<this._animatables.length;g++){this._animatables[g].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(g){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==g&&(this.loopAnimation=g),this.restart()):(this.stop(),this.start(g,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let g=0;g<this._animatables.length;g++){this._animatables[g].reset()}return this}restart(){if(!this._isStarted)return this;for(let g=0;g<this._animatables.length;g++){this._animatables[g].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const w=this._animatables.slice();for(let R=0;R<w.length;R++)w[R].stop(void 0,void 0,!0,g);let q=0;for(let R=0;R<this._scene._activeAnimatables.length;R++){const w=this._scene._activeAnimatables[R];w._runtimeAnimations.length>0?this._scene._activeAnimatables[q++]=w:g&&this._checkAnimationGroupEnded(w,g)}return this._scene._activeAnimatables.length=q,this._isStarted=!1,this}setWeightForAllAnimatables(g){for(let w=0;w<this._animatables.length;w++){this._animatables[w].weight=g}return this}syncAllAnimationsWith(g){for(let w=0;w<this._animatables.length;w++){this._animatables[w].syncWith(g)}return this}goToFrame(g){let w=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].goToFrame(g,w)}return this}getCurrentFrame(){var g;return(null===(g=this.animatables[0])||void 0===g?void 0:g.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const g=this._scene.animationGroups.indexOf(this);if(g>-1&&this._scene.animationGroups.splice(g,1),this._parentContainer){const g=this._parentContainer.animationGroups.indexOf(this);g>-1&&this._parentContainer.animationGroups.splice(g,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(g){let w=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const q=this._animatables.indexOf(g);q>-1&&this._animatables.splice(q,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,w||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(g,w){let q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const R=new x(g||this.name,this._scene,this._weight,this._playOrder);R._from=this.from,R._to=this.to,R._speedRatio=this.speedRatio,R._loopAnimation=this.loopAnimation,R._isAdditive=this.isAdditive,R._enableBlending=this.enableBlending,R._blendingSpeed=this.blendingSpeed,R.metadata=this.metadata,R.mask=this.mask;for(const o of this._targetedAnimations)R.addTargetedAnimation(q?o.animation.clone():o.animation,w?w(o.target):o.target);return R}serialize(){const g={};g.name=this.name,g.from=this.from,g.to=this.to,g.speedRatio=this.speedRatio,g.loopAnimation=this.loopAnimation,g.isAdditive=this.isAdditive,g.weight=this.weight,g.playOrder=this.playOrder,g.enableBlending=this.enableBlending,g.blendingSpeed=this.blendingSpeed,g.targetedAnimations=[];for(let w=0;w<this.targetedAnimations.length;w++){const q=this.targetedAnimations[w];g.targetedAnimations[w]=q.serialize()}return S.e&&S.e.HasTags(this)&&(g.tags=S.e.GetTags(this)),this.metadata&&(g.metadata=this.metadata),g}static Parse(g,w){const q=new x(g.name,w,g.weight,g.playOrder);for(let o=0;o<g.targetedAnimations.length;o++){const r=g.targetedAnimations[o],S=R.c.Parse(r.animation),i=r.targetId;if("influence"===r.animation.property){const g=w.getMorphTargetById(i);g&&q.addTargetedAnimation(S,g)}else{const g=w.getNodeById(i);null!=g&&q.addTargetedAnimation(S,g)}}return S.e&&S.e.AddTagsTo(q,g.tags),null!==g.from&&null!==g.to&&q.normalize(g.from,g.to),void 0!==g.speedRatio&&(q._speedRatio=g.speedRatio),void 0!==g.loopAnimation&&(q._loopAnimation=g.loopAnimation),void 0!==g.isAdditive&&(q._isAdditive=g.isAdditive),void 0!==g.weight&&(q._weight=g.weight),void 0!==g.playOrder&&(q._playOrder=g.playOrder),void 0!==g.enableBlending&&(q._enableBlending=g.enableBlending),void 0!==g.blendingSpeed&&(q._blendingSpeed=g.blendingSpeed),void 0!==g.metadata&&(q.metadata=g.metadata),q}static MakeAnimationAdditive(g,w,q){let o;o="object"===typeof w?w:{referenceFrame:w,range:q,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let r=g;o.cloneOriginalAnimationGroup&&(r=g.clone(o.clonedAnimationGroupName||r.name));const S=r.targetedAnimations;for(let i=0;i<S.length;i++){const g=S[i];g.animation=R.c.MakeAnimationAdditive(g.animation,o)}if(r.isAdditive=!0,o.clipKeys){let g=Number.MAX_VALUE,w=-Number.MAX_VALUE;const q=r.targetedAnimations;for(let R=0;R<q.length;R++){const o=q[R].animation.getKeys();g>o[0].frame&&(g=o[0].frame),w<o[o.length-1].frame&&(w=o[o.length-1].frame)}r._from=g,r._to=w}return r}static ClipKeys(g,w,q,R,o){const r=g.clone(R||g.name);return x.ClipKeysInPlace(r,w,q,o)}static ClipKeysInPlace(g,w,q,R){return x.ClipInPlace(g,w,q,R,!1)}static ClipFrames(g,w,q,R,o){const r=g.clone(R||g.name);return x.ClipFramesInPlace(r,w,q,o)}static ClipFramesInPlace(g,w,q,R){return x.ClipInPlace(g,w,q,R,!0)}static ClipInPlace(g,w,q,R){let o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=Number.MAX_VALUE,S=-Number.MAX_VALUE;const i=g.targetedAnimations;for(let T=0;T<i.length;T++){const g=i[T],z=R?g.animation:g.animation.clone();o&&(z.createKeyForFrame(w),z.createKeyForFrame(q));const t=z.getKeys(),m=[];let e=Number.MAX_VALUE;for(let R=0;R<t.length;R++){const g=t[R];if(!o&&R>=w&&R<=q||o&&g.frame>=w&&g.frame<=q){const w={frame:g.frame,value:g.value.clone?g.value.clone():g.value,inTangent:g.inTangent,outTangent:g.outTangent,interpolation:g.interpolation,lockedTangent:g.lockedTangent};e===Number.MAX_VALUE&&(e=w.frame),w.frame-=e,m.push(w)}}0!==m.length?(r>m[0].frame&&(r=m[0].frame),S<m[m.length-1].frame&&(S=m[m.length-1].frame),z.setKeys(m,!0),g.animation=z):(i.splice(T,1),T--)}return g._from=r,g._to=S,g}getClassName(){return"AnimationGroup"}toString(g){let w="Name: "+this.name;return w+=", type: "+this.getClassName(),g&&(w+=", from: "+this._from,w+=", to: "+this._to,w+=", isStarted: "+this._isStarted,w+=", speedRatio: "+this._speedRatio,w+=", targetedAnimations length: "+this._targetedAnimations.length,w+=", animatables length: "+this._animatables),w}}}}]);