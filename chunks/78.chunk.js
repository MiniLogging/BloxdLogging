"use strict";(self.uw9p3pwwsje=self.uw9p3pwwsje||[]).push([[78],{15837:(D,h,o)=>{o.r(h),o.d(h,{AnimationGroup:()=>q,TargetedAnimation:()=>U});var H=o(13377),g=o(12648),j=o(12683),M=o(12864),R=o(14292),t=o(12831);class S{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(D,h,o,g){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=h,this._target=D,this._scene=o,this._host=g,this._activeTargets=[],h._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===H.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=t.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const D={frame:0,value:this._minValue};this._keys.splice(0,0,D)}if(this._target instanceof Array){let D=0;for(const h of this._target)this._preparePath(h,D),this._getOriginalValues(D),D++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const j=h.getEvents();if(j&&j.length>0)for(const H of j)this._events.push(H._clone());this._enableBlending=D&&D.animationPropertiesOverride?D.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=this._animation.targetPropertyPath;if(o.length>1){let H=D;for(let D=0;D<o.length-1;D++){const h=o[D];if(H=H[h],void 0===H)throw new Error(`Invalid property (${h}) in property path (${o.join(".")})`)}this._targetPath=o[o.length-1],this._activeTargets[h]=H}else this._targetPath=o[0],this._activeTargets[h]=D;if(void 0===this._activeTargets[h][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${o.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let D=0;for(const h of this._target)void 0!==this._originalValue[D]&&this._setValue(h,this._activeTargets[D],this._originalValue[D],-1,D),D++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let D=0;D<this._events.length;D++)this._events[D].isDone=!1}isStopped(){return this._stopped}dispose(){const D=this._animation.runtimeAnimations.indexOf(this);D>-1&&this._animation.runtimeAnimations.splice(D,1)}setValue(D,h){if(this._targetIsArray)for(let o=0;o<this._target.length;o++){const H=this._target[o];this._setValue(H,this._activeTargets[o],D,h,o)}else this._setValue(this._target,this._directTarget,D,h,0)}_getOriginalValues(){let D,h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const o=this._activeTargets[h];D=o.getLocalMatrix&&"_matrix"===this._targetPath?o.getLocalMatrix():o[this._targetPath],D&&D.clone?this._originalValue[h]=D.clone():this._originalValue[h]=D}_registerTargetForLateAnimationBinding(D,h){const o=D.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(o),o._lateAnimationHolders||(o._lateAnimationHolders={}),o._lateAnimationHolders[D.targetPath]||(o._lateAnimationHolders[D.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:h}),D.isAdditive?(o._lateAnimationHolders[D.targetPath].additiveAnimations.push(D),o._lateAnimationHolders[D.targetPath].totalAdditiveWeight+=D.weight):(o._lateAnimationHolders[D.targetPath].animations.push(D),o._lateAnimationHolders[D.targetPath].totalWeight+=D.weight)}_setValue(D,h,o,g,j){if(this._currentActiveTarget=h,this._weight=g,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const D=h[this._targetPath];D.clone?this._originalBlendValue=D.clone():this._originalBlendValue=D}this._originalBlendValue.m?H.e.AllowMatrixDecomposeForInterpolation?this._currentValue?t.Matrix.DecomposeLerpToRef(this._originalBlendValue,o,this._blendingFactor,this._currentValue):this._currentValue=t.Matrix.DecomposeLerp(this._originalBlendValue,o,this._blendingFactor):this._currentValue?t.Matrix.LerpToRef(this._originalBlendValue,o,this._blendingFactor,this._currentValue):this._currentValue=t.Matrix.Lerp(this._originalBlendValue,o,this._blendingFactor):this._currentValue=H.e._UniversalLerp(this._originalBlendValue,o,this._blendingFactor);const g=D&&D.animationPropertiesOverride?D.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=g}else this._currentValue?this._currentValue.M?this._currentValue.M(o):this._currentValue=o:null!==o&&void 0!==o&&o.clone?this._currentValue=o.clone():this._currentValue=o;-1!==g?this._registerTargetForLateAnimationBinding(this,this._originalValue[j]):this._animationState.loopMode===H.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[j],h[this._targetPath]):h[this._targetPath]=this._originalValue[j]+this._currentValue:h[this._targetPath]=this._currentValue,D.mK&&D.mK(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const o=this._animation.getKeys();D<o[0].frame?D=o[0].frame:D>o[o.length-1].frame&&(D=o[o.length-1].frame);const H=this._events;if(H.length)for(let j=0;j<H.length;j++)H[j].onlyOnce||(H[j].isDone=H[j].frame<D);this._currentFrame=D;const g=this._animation._interpolate(D,this._animationState);this.setValue(g,h)}_prepareForSpeedRatioChange(D){const h=this._previousElapsedTime*(this._animation.framePerSecond*D)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-h}animate(D,h,o,g,j){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const R=this._animation,t=R.targetPropertyPath;if(!t||t.length<1)return this._stopped=!0,!1;let S,k=!0;const K=this._events;let Q=0;if(this._coreRuntimeAnimation)Q=o-h,S=this._coreRuntimeAnimation.currentFrame,this._currentFrame=S,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let M;(h<this._minFrame||h>this._maxFrame)&&(h=this._minFrame),(o<this._minFrame||o>this._maxFrame)&&(o=this._maxFrame),Q=o-h;let t=D*(R.framePerSecond*j)/1e3+this._absoluteFrameOffset,v=0,r=!1;const B=g&&this._animationState.loopMode===H.e.ANIMATIONLOOPMODE_YOYO;if(B){const D=(t-h)/Q,o=Math.sin(D*Math.PI);t=Math.abs(o)*Q+h;const H=o>=0?1:-1;this._yoyoDirection!==H&&(r=!0),this._yoyoDirection=H}if(this._previousElapsedTime=D,this._previousAbsoluteFrame=t,!g&&o>=h&&(t>=Q&&j>0||t<=0&&j<0))k=!1,v=R._getKeyValue(this._maxValue);else if(!g&&h>=o&&(t<=Q&&j<0||t>=0&&j>0))k=!1,v=R._getKeyValue(this._minValue);else if(this._animationState.loopMode!==H.e.ANIMATIONLOOPMODE_CYCLE){const D=o.toString()+h.toString();if(!this._offsetsCache[D]){this._animationState.repeatCount=0,this._animationState.loopMode=H.e.ANIMATIONLOOPMODE_CYCLE;const g=R._interpolate(h,this._animationState),j=R._interpolate(o,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),R.dataType){case H.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[D]=j-g;break;case H.e.ANIMATIONTYPE_QUATERNION:case H.e.ANIMATIONTYPE_VECTOR3:case H.e.ANIMATIONTYPE_VECTOR2:case H.e.ANIMATIONTYPE_SIZE:case H.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[D]=j.Nh(g)}this._highLimitsCache[D]=j}v=this._highLimitsCache[D],M=this._offsetsCache[D]}if(void 0===M)switch(R.dataType){case H.e.ANIMATIONTYPE_FLOAT:M=0;break;case H.e.ANIMATIONTYPE_QUATERNION:M=H.k;break;case H.e.ANIMATIONTYPE_VECTOR3:M=H.r;break;case H.e.ANIMATIONTYPE_VECTOR2:M=H.n;break;case H.e.ANIMATIONTYPE_SIZE:M=H.m;break;case H.e.ANIMATIONTYPE_COLOR3:M=H.g;break;case H.e.ANIMATIONTYPE_COLOR4:M=H.i}if(this._host&&this._host.syncRoot){const D=this._host.syncRoot;S=h+Q*((D.masterFrame-D.fromFrame)/(D.toFrame-D.fromFrame))}else S=t>0&&h>o||t<0&&h<o?k&&0!==Q?o+t%Q:h:k&&0!==Q?h+t%Q:o;if(!B&&(j>0&&this.currentFrame>S||j<0&&this.currentFrame<S)||B&&r){this._onLoop();for(let D=0;D<K.length;D++)K[D].onlyOnce||(K[D].isDone=!1);this._animationState.key=j>0?0:R.getKeys().length-1}this._currentFrame=S,this._animationState.repeatCount=0===Q?0:t/Q|0,this._animationState.highLimitValue=v,this._animationState.offsetValue=M}const v=R._interpolate(S,this._animationState);if(this.setValue(v,M),K.length)for(let H=0;H<K.length;H++)if(Q>=0&&S>=K[H].frame&&K[H].frame>=h||Q<0&&S<=K[H].frame&&K[H].frame<=h){const D=K[H];D.isDone||(D.onlyOnce&&(K.splice(H,1),H--),D.isDone=!0,D.action(S))}return k||(this._stopped=!0),k}}var k=o(12667);class K{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(D){this._weight=-1!==D?Math.min(Math.max(D,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(D){for(let h=0;h<this._runtimeAnimations.length;h++){this._runtimeAnimations[h]._prepareForSpeedRatioChange(D)}this._speedRatio=D,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(D,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,j=arguments.length>4&&void 0!==arguments[4]&&arguments[4],M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,R=arguments.length>6?arguments[6]:void 0,t=arguments.length>7?arguments[7]:void 0,S=arguments.length>8?arguments[8]:void 0,k=arguments.length>9&&void 0!==arguments[9]&&arguments[9],K=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=h,this.fromFrame=o,this.toFrame=H,this.loopAnimation=j,this.onAnimationEnd=R,this.onAnimationLoop=S,this.isAdditive=k,this.playOrder=K,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.bt=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new g.c,this.onAnimationLoopObservable=new g.c,this._scene=D,t&&this.appendAnimations(h,t),this._speedRatio=M,D._activeAnimatables.push(this)}syncWith(D){if(this._syncRoot=D,D){const D=this._scene._activeAnimatables.indexOf(this);D>-1&&(this._scene._activeAnimatables.splice(D,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(D,h){for(let o=0;o<h.length;o++){const H=h[o],g=new S(D,H,this._scene,this);g._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(g)}}getAnimationByTargetProperty(D){const h=this._runtimeAnimations;for(let o=0;o<h.length;o++)if(h[o].animation.targetProperty===D)return h[o].animation;return null}getRuntimeAnimationByTargetProperty(D){const h=this._runtimeAnimations;for(let o=0;o<h.length;o++)if(h[o].animation.targetProperty===D)return h[o];return null}reset(){const D=this._runtimeAnimations;for(let h=0;h<D.length;h++)D[h].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(D){const h=this._runtimeAnimations;for(let o=0;o<h.length;o++)h[o].animation.enableBlending=!0,h[o].animation.blendingSpeed=D}disableBlending(){const D=this._runtimeAnimations;for(let h=0;h<D.length;h++)D[h].animation.enableBlending=!1}goToFrame(D){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const o=this._runtimeAnimations;if(o[0]){const h=o[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??o[0].currentFrame;const H=0===this.speedRatio?0:(D-this._frameToSyncFromJump)/h*1e3/this.speedRatio;this._manualJumpDelay=-H}for(let H=0;H<o.length;H++)o[H].goToFrame(D,h?this._weight:-1);this._goToFrame=D}get paused(){return this.bt}pause(){this.bt||(this.bt=!0)}restart(){this.bt=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(D,h){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(D||h){const g=this._scene._activeAnimatables.indexOf(this);if(g>-1){const j=this._runtimeAnimations;for(let o=j.length-1;o>=0;o--){const H=j[o];D&&H.animation.name!=D||(h&&!h(H.target)||(H.dispose(),j.splice(o,1)))}0==j.length&&(o||this._scene._activeAnimatables.splice(g,1),H||this._raiseOnAnimationEnd())}}else{const D=this._scene._activeAnimatables.indexOf(this);if(D>-1){o||this._scene._activeAnimatables.splice(D,1);const h=this._runtimeAnimations;for(let D=0;D<h.length;D++)h[D].dispose();this._runtimeAnimations.length=0,H||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((D=>{this.onAnimationEndObservable.add((()=>{D(this)}),void 0,void 0,this,!0)}))}_animate(D){if(this.bt)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=D),!0;if(null===this._localDelayOffset?(this._localDelayOffset=D,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=D-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let h=!1;const o=this._runtimeAnimations;let H;for(H=0;H<o.length;H++){const g=o[H].animate(D-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);h=h||g}if(this.animationStarted=h,!h){if(this.disposeOnEnd)for(H=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(H,1),H=0;H<o.length;H++)o[H].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return h}}function Q(D){if(0===D.totalWeight&&0===D.totalAdditiveWeight)return D.originalValue;let h=1;const o=t.TmpVectors.Gh[0],H=t.TmpVectors.Gh[1],g=t.TmpVectors.Quaternion[0];let j=0;const M=D.animations[0],R=D.originalValue;let S=1,k=!1;if(D.totalWeight<1)S=1-D.totalWeight,R.decompose(H,g,o);else{if(j=1,h=D.totalWeight,S=M.weight/h,1==S){if(!D.totalAdditiveWeight)return M.currentValue;k=!0}M.currentValue.decompose(H,g,o)}if(!k){H.scaleInPlace(S),o.scaleInPlace(S),g.scaleInPlace(S);for(let M=j;M<D.animations.length;M++){const j=D.animations[M];if(0===j.weight)continue;S=j.weight/h;const R=t.TmpVectors.Gh[2],k=t.TmpVectors.Gh[3],K=t.TmpVectors.Quaternion[1];j.currentValue.decompose(k,K,R),k.scaleAndAddToRef(S,H),K.scaleAndAddToRef(t.Quaternion.Dot(g,K)>0?S:-S,g),R.scaleAndAddToRef(S,o)}g.normalize()}for(let Q=0;Q<D.additiveAnimations.length;Q++){const h=D.additiveAnimations[Q];if(0===h.weight)continue;const j=t.TmpVectors.Gh[2],M=t.TmpVectors.Gh[3],R=t.TmpVectors.Quaternion[1];h.currentValue.decompose(M,R,j),M.multiplyToRef(H,M),t.Gh.LerpToRef(H,M,h.weight,H),g.multiplyToRef(R,R),t.Quaternion.SlerpToRef(g,R,h.weight,g),j.scaleAndAddToRef(h.weight,o)}const K=M?M._animationState.workValue:t.TmpVectors.Matrix[0].clone();return t.Matrix.ComposeToRef(H,g,o,K),K}function v(D,h){if(0===D.totalWeight&&0===D.totalAdditiveWeight)return h;const o=D.animations[0],H=D.originalValue;let g=h;if(0===D.totalWeight&&D.totalAdditiveWeight>0)g.M(H);else if(1===D.animations.length){if(t.Quaternion.SlerpToRef(H,o.currentValue,Math.min(1,D.totalWeight),g),0===D.totalAdditiveWeight)return g}else if(D.animations.length>1){let o,j,M=1;if(D.totalWeight<1){const h=1-D.totalWeight;o=[],j=[],o.push(H),j.push(h)}else{if(2===D.animations.length&&(t.Quaternion.SlerpToRef(D.animations[0].currentValue,D.animations[1].currentValue,D.animations[1].weight/D.totalWeight,h),0===D.totalAdditiveWeight))return h;o=[],j=[],M=D.totalWeight}for(let h=0;h<D.animations.length;h++){const H=D.animations[h];o.push(H.currentValue),j.push(H.weight/M)}let R=0;for(let D=0;D<o.length;)D?(R+=j[D],t.Quaternion.SlerpToRef(g,o[D],j[D]/R,g),D++):(t.Quaternion.SlerpToRef(o[D],o[D+1],j[D+1]/(j[D]+j[D+1]),h),g=h,R=j[D]+j[D+1],D+=2)}for(let j=0;j<D.additiveAnimations.length;j++){const h=D.additiveAnimations[j];0!==h.weight&&(g.multiplyToRef(h.currentValue,t.TmpVectors.Quaternion[0]),t.Quaternion.SlerpToRef(g,t.TmpVectors.Quaternion[0],h.weight,g))}return g}var r,B,s=o(13065);r=s.b,(B=R.d)&&(B.prototype.copyAnimationRange=function(D,h,o){let g=arguments.length>3&&void 0!==arguments[3]&&arguments[3],j=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new H.e(this.name,"_matrix",D.animations[0].framePerSecond,H.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const M=D.animations[0].getRange(h);if(!M)return!1;const R=M.from,t=M.to,S=D.animations[0].getKeys(),k=D.length,K=D.getParent(),Q=this.getParent(),v=g&&K&&k&&this.length&&k!==this.length,r=v&&Q&&K?Q.length/K.length:1,B=g&&!Q&&j&&(1!==j.x||1!==j.y||1!==j.z),s=this.animations[0].getKeys();let U,q,c;for(let H=0,y=S.length;H<y;H++)U=S[H],U.frame>=R&&U.frame<=t&&(g?(c=U.value.clone(),v?(q=c.getTranslation(),c.setTranslation(q.scaleInPlace(r))):B&&j?(q=c.getTranslation(),c.setTranslation(q.multiplyInPlace(j))):c=U.value):c=U.value,s.push({frame:U.frame+o,value:c}));return this.animations[0].createRange(h,R+o,t+o),!0}),r&&(r.prototype._animate=function(D){if(!this.animationsEnabled)return;const h=k.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=h}this.deltaTime=void 0!==D?D:this.useConstantAnimationDeltaTime?16:(h-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=h;const o=this._activeAnimatables;if(0===o.length)return;this._animationTime+=this.deltaTime;const g=this._animationTime;for(let H=0;H<o.length;H++){const D=o[H];!D._animate(g)&&D.disposeOnEnd&&H--}!function(D){if(D._registeredForLateAnimationBindings.length){for(let h=0;h<D._registeredForLateAnimationBindings.length;h++){const o=D._registeredForLateAnimationBindings.data[h];for(const D in o._lateAnimationHolders){const h=o._lateAnimationHolders[D],g=h.animations[0],j=h.originalValue;if(void 0===j||null===j)continue;const M=H.e.AllowMatrixDecomposeForInterpolation&&j.m;let R=o[D];if(M)R=Q(h);else if(void 0!==j.w)R=v(h,R||t.Quaternion.Identity());else{let D=0,o=1;const M=g&&g._animationState.loopMode===H.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(h.totalWeight<1)R=M?j.clone?j.clone():j:g&&j.scale?j.scale(1-h.totalWeight):g?j*(1-h.totalWeight):j.clone?j.clone():j;else if(g){o=h.totalWeight;const H=g.weight/o;R=1!==H?g.currentValue.scale?g.currentValue.scale(H):g.currentValue*H:g.currentValue,M&&(R.addToRef?R.addToRef(j,R):R+=j),D=1}for(let H=D;H<h.animations.length;H++){const D=h.animations[H],g=D.weight/o;g&&(D.currentValue.scaleAndAddToRef?D.currentValue.scaleAndAddToRef(g,R):R+=D.currentValue*g)}for(let H=0;H<h.additiveAnimations.length;H++){const D=h.additiveAnimations[H],o=D.weight;o&&(D.currentValue.scaleAndAddToRef?D.currentValue.scaleAndAddToRef(o,R):R+=D.currentValue*o)}}o[D]=R}o._lateAnimationHolders={}}D._registeredForLateAnimationBindings.reset()}}(this)},r.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((D,h)=>D.playOrder-h.playOrder))},r.prototype.beginWeightedAnimation=function(D,h,o){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,g=arguments.length>4?arguments[4]:void 0,j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,M=arguments.length>6?arguments[6]:void 0,R=arguments.length>7?arguments[7]:void 0,t=arguments.length>8?arguments[8]:void 0,S=arguments.length>9?arguments[9]:void 0,k=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const K=this.beginAnimation(D,h,o,g,j,M,R,!1,t,S,k);return K.weight=H,K},r.prototype.beginAnimation=function(D,h,o,H){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,j=arguments.length>5?arguments[5]:void 0,M=arguments.length>6?arguments[6]:void 0,R=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],t=arguments.length>8?arguments[8]:void 0,S=arguments.length>9?arguments[9]:void 0,k=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(g<0){const D=h;h=o,o=D,g=-g}h>o&&(g=-g),R&&this.stopAnimation(D,void 0,t),M||(M=new K(this,D,h,o,H,g,j,void 0,S,k));const Q=!t||t(D);if(D.animations&&Q&&M.appendAnimations(D,D.animations),D.getAnimatables){const k=D.getAnimatables();for(let D=0;D<k.length;D++)this.beginAnimation(k[D],h,o,H,g,j,M,R,t,S)}return M.reset(),M},r.prototype.beginHierarchyAnimation=function(D,h,o,H,g){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,M=arguments.length>6?arguments[6]:void 0,R=arguments.length>7?arguments[7]:void 0,t=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],S=arguments.length>9?arguments[9]:void 0,k=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const K=D.getDescendants(h),Q=[];Q.push(this.beginAnimation(D,o,H,g,j,M,R,t,S,void 0,k));for(const v of K)Q.push(this.beginAnimation(v,o,H,g,j,M,R,t,S,void 0,k));return Q},r.prototype.beginDirectAnimation=function(D,h,o,H,g){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(j<0){const D=o;o=H,H=D,j=-j}return o>H&&(j=-j),new K(this,D,o,H,g,j,arguments.length>6?arguments[6]:void 0,h,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},r.prototype.beginDirectHierarchyAnimation=function(D,h,o,H,g,j,M,R,t){let S=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const k=D.getDescendants(h),K=[];K.push(this.beginDirectAnimation(D,o,H,g,j,M,R,t,S));for(const Q of k)K.push(this.beginDirectAnimation(Q,o,H,g,j,M,R,t,S));return K},r.prototype.getAnimatableByTarget=function(D){for(let h=0;h<this._activeAnimatables.length;h++)if(this._activeAnimatables[h].target===D)return this._activeAnimatables[h];return null},r.prototype.getAllAnimatablesByTarget=function(D){const h=[];for(let o=0;o<this._activeAnimatables.length;o++)this._activeAnimatables[o].target===D&&h.push(this._activeAnimatables[o]);return h},r.prototype.stopAnimation=function(D,h,o){const H=this.getAllAnimatablesByTarget(D);for(const g of H)g.stop(h,o)},r.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let D=0;D<this._activeAnimatables.length;D++)this._activeAnimatables[D].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const D of this.animationGroups)D.stop()});class U{getClassName(){return"TargetedAnimation"}serialize(){const D={};return D.animation=this.animation.serialize(),D.targetId=this.target.id,D}}class q{get mask(){return this._mask}set mask(D){this._mask!==D&&(this._mask=D,this.syncWithMask(!0))}syncWithMask(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||D){this._numActiveAnimatables=0;for(let D=0;D<this._animatables.length;++D){const h=this._animatables[D];!this.mask||this.mask.disabled||this.mask.retainsTarget(h.target.name)?(this._numActiveAnimatables++,h.paused&&h.restart()):h.paused||h.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let D=0;D<this._animatables.length;++D){const h=this._animatables[D];this.mask.retainsTarget(h.target.name)||(h.stop(),this._animatables.splice(D,1),--D)}for(let D=0;D<this._targetedAnimations.length;D++){const h=this._targetedAnimations[D];this.mask.retainsTarget(h.target.name)||(this._targetedAnimations.splice(D,1),--D)}}}get from(){return this._from}set from(D){if(this._from!==D){this._from=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].fromFrame=this._from}}}get to(){return this._to}set to(D){if(this._to!==D){this._to=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(D){if(this._speedRatio!==D){this._speedRatio=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(D){if(this._loopAnimation!==D){this._loopAnimation=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(D){if(this._isAdditive!==D){this._isAdditive=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(D){this._weight!==D&&(this._weight=D,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(D){if(this._playOrder!==D&&(this._playOrder=D,this._animatables.length>0)){for(let D=0;D<this._animatables.length;D++)this._animatables[D].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(D){if(this._enableBlending!==D&&(this._enableBlending=D,null!==D))for(let h=0;h<this._targetedAnimations.length;++h)this._targetedAnimations[h].animation.enableBlending=D}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(D){if(this._blendingSpeed!==D&&(this._blendingSpeed=D,null!==D))for(let h=0;h<this._targetedAnimations.length;++h)this._targetedAnimations[h].animation.blendingSpeed=D}getLength(D,h){D=D??this._from;return((h=h??this._to)-D)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(D){let h=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=arguments.length>3?arguments[3]:void 0;if(0===D.length)return null;H=H??D[0].weight;let g=Number.MAX_VALUE,j=-Number.MAX_VALUE;if(o)for(const R of D)R.from<g&&(g=R.from),R.to>j&&(j=R.to);const M=new q(D[0].name+"_merged",D[0]._scene,H);for(const R of D){o&&R.normalize(g,j);for(const D of R.targetedAnimations)M.addTargetedAnimation(D.animation,D.target);h&&R.dispose()}return M}constructor(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=D,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new g.c,this.onAnimationLoopObservable=new g.c,this.onAnimationGroupLoopObservable=new g.c,this.onAnimationGroupEndObservable=new g.c,this.onAnimationGroupPauseObservable=new g.c,this.onAnimationGroupPlayObservable=new g.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=h||j.d.LastCreatedScene,this._weight=o,this._playOrder=H,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(D,h){const o=new U;o.animation=D,o.target=h;const H=D.getKeys();return this._from>H[0].frame&&(this._from=H[0].frame),this._to<H[H.length-1].frame&&(this._to=H[H.length-1].frame),null!==this._enableBlending&&(D.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(D.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(o),this._shouldStart=!0,o}removeTargetedAnimation(D){for(let h=this._targetedAnimations.length-1;h>-1;h--){this._targetedAnimations[h].animation===D&&this._targetedAnimations.splice(h,1)}}normalize(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==D&&(D=this._from),null==h&&(h=this._to);for(let o=0;o<this._targetedAnimations.length;o++){const H=this._targetedAnimations[o].animation.getKeys(),g=H[0],j=H[H.length-1];if(g.frame>D){const h={frame:D,value:g.value,inTangent:g.inTangent,outTangent:g.outTangent,interpolation:g.interpolation};H.splice(0,0,h)}if(j.frame<h){const D={frame:h,value:j.value,inTangent:j.inTangent,outTangent:j.outTangent,interpolation:j.interpolation};H.push(D)}}return this._from=D,this._to=h,this}_processLoop(D,h,o){D.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(h),this._animationLoopFlags[o]||(this._animationLoopFlags[o]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0],h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments.length>2?arguments[2]:void 0,H=arguments.length>3?arguments[3]:void 0,g=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=D,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let j=0;j<this._targetedAnimations.length;j++){const M=this._targetedAnimations[j],R=this._scene.beginDirectAnimation(M.target,[M.animation],void 0!==o?o:this._from,void 0!==H?H:this._to,D,h,void 0,void 0,void 0!==g?g:this._isAdditive);R.weight=this._weight,R.playOrder=this._playOrder,R.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(M),this._checkAnimationGroupEnded(R)},this._processLoop(R,M,j),this._animatables.push(R)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=h,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let D=0;D<this._animatables.length;D++){this._animatables[D].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(D){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==D&&(this.loopAnimation=D),this.restart()):(this.stop(),this.start(D,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let D=0;D<this._animatables.length;D++){this._animatables[D].reset()}return this}restart(){if(!this._isStarted)return this;for(let D=0;D<this._animatables.length;D++){this._animatables[D].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const h=this._animatables.slice();for(let H=0;H<h.length;H++)h[H].stop(void 0,void 0,!0,D);let o=0;for(let H=0;H<this._scene._activeAnimatables.length;H++){const h=this._scene._activeAnimatables[H];h._runtimeAnimations.length>0?this._scene._activeAnimatables[o++]=h:D&&this._checkAnimationGroupEnded(h,D)}return this._scene._activeAnimatables.length=o,this._isStarted=!1,this}setWeightForAllAnimatables(D){for(let h=0;h<this._animatables.length;h++){this._animatables[h].weight=D}return this}syncAllAnimationsWith(D){for(let h=0;h<this._animatables.length;h++){this._animatables[h].syncWith(D)}return this}goToFrame(D){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let o=0;o<this._animatables.length;o++){this._animatables[o].goToFrame(D,h)}return this}getCurrentFrame(){var D;return(null===(D=this.animatables[0])||void 0===D?void 0:D.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const D=this._scene.animationGroups.indexOf(this);if(D>-1&&this._scene.animationGroups.splice(D,1),this._parentContainer){const D=this._parentContainer.animationGroups.indexOf(this);D>-1&&this._parentContainer.animationGroups.splice(D,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(D){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const o=this._animatables.indexOf(D);o>-1&&this._animatables.splice(o,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,h||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(D,h){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const H=new q(D||this.name,this._scene,this._weight,this._playOrder);H._from=this.from,H._to=this.to,H._speedRatio=this.speedRatio,H._loopAnimation=this.loopAnimation,H._isAdditive=this.isAdditive,H._enableBlending=this.enableBlending,H._blendingSpeed=this.blendingSpeed,H.metadata=this.metadata,H.mask=this.mask;for(const g of this._targetedAnimations)H.addTargetedAnimation(o?g.animation.clone():g.animation,h?h(g.target):g.target);return H}serialize(){const D={};D.name=this.name,D.from=this.from,D.to=this.to,D.speedRatio=this.speedRatio,D.loopAnimation=this.loopAnimation,D.isAdditive=this.isAdditive,D.weight=this.weight,D.playOrder=this.playOrder,D.enableBlending=this.enableBlending,D.blendingSpeed=this.blendingSpeed,D.targetedAnimations=[];for(let h=0;h<this.targetedAnimations.length;h++){const o=this.targetedAnimations[h];D.targetedAnimations[h]=o.serialize()}return M.b&&M.b.HasTags(this)&&(D.tags=M.b.GetTags(this)),this.metadata&&(D.metadata=this.metadata),D}static Parse(D,h){const o=new q(D.name,h,D.weight,D.playOrder);for(let g=0;g<D.targetedAnimations.length;g++){const j=D.targetedAnimations[g],M=H.e.Parse(j.animation),R=j.targetId;if("influence"===j.animation.property){const D=h.getMorphTargetById(R);D&&o.addTargetedAnimation(M,D)}else{const D=h.getNodeById(R);null!=D&&o.addTargetedAnimation(M,D)}}return M.b&&M.b.AddTagsTo(o,D.tags),null!==D.from&&null!==D.to&&o.normalize(D.from,D.to),void 0!==D.speedRatio&&(o._speedRatio=D.speedRatio),void 0!==D.loopAnimation&&(o._loopAnimation=D.loopAnimation),void 0!==D.isAdditive&&(o._isAdditive=D.isAdditive),void 0!==D.weight&&(o._weight=D.weight),void 0!==D.playOrder&&(o._playOrder=D.playOrder),void 0!==D.enableBlending&&(o._enableBlending=D.enableBlending),void 0!==D.blendingSpeed&&(o._blendingSpeed=D.blendingSpeed),void 0!==D.metadata&&(o.metadata=D.metadata),o}static MakeAnimationAdditive(D,h,o){let g;g="object"===typeof h?h:{referenceFrame:h,range:o,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let j=D;g.cloneOriginalAnimationGroup&&(j=D.clone(g.clonedAnimationGroupName||j.name));const M=j.targetedAnimations;for(let R=0;R<M.length;R++){const D=M[R];D.animation=H.e.MakeAnimationAdditive(D.animation,g)}if(j.isAdditive=!0,g.clipKeys){let D=Number.MAX_VALUE,h=-Number.MAX_VALUE;const o=j.targetedAnimations;for(let H=0;H<o.length;H++){const g=o[H].animation.getKeys();D>g[0].frame&&(D=g[0].frame),h<g[g.length-1].frame&&(h=g[g.length-1].frame)}j._from=D,j._to=h}return j}static ClipKeys(D,h,o,H,g){const j=D.clone(H||D.name);return q.ClipKeysInPlace(j,h,o,g)}static ClipKeysInPlace(D,h,o,H){return q.ClipInPlace(D,h,o,H,!1)}static ClipFrames(D,h,o,H,g){const j=D.clone(H||D.name);return q.ClipFramesInPlace(j,h,o,g)}static ClipFramesInPlace(D,h,o,H){return q.ClipInPlace(D,h,o,H,!0)}static ClipInPlace(D,h,o,H){let g=arguments.length>4&&void 0!==arguments[4]&&arguments[4],j=Number.MAX_VALUE,M=-Number.MAX_VALUE;const R=D.targetedAnimations;for(let t=0;t<R.length;t++){const D=R[t],S=H?D.animation:D.animation.clone();g&&(S.createKeyForFrame(h),S.createKeyForFrame(o));const k=S.getKeys(),K=[];let Q=Number.MAX_VALUE;for(let H=0;H<k.length;H++){const D=k[H];if(!g&&H>=h&&H<=o||g&&D.frame>=h&&D.frame<=o){const h={frame:D.frame,value:D.value.clone?D.value.clone():D.value,inTangent:D.inTangent,outTangent:D.outTangent,interpolation:D.interpolation,lockedTangent:D.lockedTangent};Q===Number.MAX_VALUE&&(Q=h.frame),h.frame-=Q,K.push(h)}}0!==K.length?(j>K[0].frame&&(j=K[0].frame),M<K[K.length-1].frame&&(M=K[K.length-1].frame),S.setKeys(K,!0),D.animation=S):(R.splice(t,1),t--)}return D._from=j,D._to=M,D}getClassName(){return"AnimationGroup"}toString(D){let h="Name: "+this.name;return h+=", type: "+this.getClassName(),D&&(h+=", from: "+this._from,h+=", to: "+this._to,h+=", isStarted: "+this._isStarted,h+=", speedRatio: "+this._speedRatio,h+=", targetedAnimations length: "+this._targetedAnimations.length,h+=", animatables length: "+this._animatables),h}}}}]);