"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[78],{14412:(Z,x,F)=>{F.r(x),F.d(x,{AnimationGroup:()=>m,TargetedAnimation:()=>M});var u=F(11745),G=F(11e3),f=F(11037),Y=F(11221),j=F(12863),d=F(11179);class t{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(Z,x,F,G){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=x,this._target=Z,this._scene=F,this._host=G,this._activeTargets=[],x._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===u.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=d.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const Z={frame:0,value:this._minValue};this._keys.splice(0,0,Z)}if(this._target instanceof Array){let Z=0;for(const x of this._target)this._preparePath(x,Z),this._getOriginalValues(Z),Z++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const f=x.getEvents();if(f&&f.length>0)for(const u of f)this._events.push(u._clone());this._enableBlending=Z&&Z.animationPropertiesOverride?Z.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const F=this._animation.targetPropertyPath;if(F.length>1){let u=Z;for(let Z=0;Z<F.length-1;Z++){const x=F[Z];if(u=u[x],void 0===u)throw new Error(`Invalid property (${x}) in property path (${F.join(".")})`)}this._targetPath=F[F.length-1],this._activeTargets[x]=u}else this._targetPath=F[0],this._activeTargets[x]=Z;if(void 0===this._activeTargets[x][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${F.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let Z=0;for(const x of this._target)void 0!==this._originalValue[Z]&&this._setValue(x,this._activeTargets[Z],this._originalValue[Z],-1,Z),Z++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let Z=0;Z<this._events.length;Z++)this._events[Z].isDone=!1}isStopped(){return this._stopped}dispose(){const Z=this._animation.runtimeAnimations.indexOf(this);Z>-1&&this._animation.runtimeAnimations.splice(Z,1)}setValue(Z,x){if(this._targetIsArray)for(let F=0;F<this._target.length;F++){const u=this._target[F];this._setValue(u,this._activeTargets[F],Z,x,F)}else this._setValue(this._target,this._directTarget,Z,x,0)}_getOriginalValues(){let Z,x=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const F=this._activeTargets[x];Z=F.getLocalMatrix&&"_matrix"===this._targetPath?F.getLocalMatrix():F[this._targetPath],Z&&Z.clone?this._originalValue[x]=Z.clone():this._originalValue[x]=Z}_registerTargetForLateAnimationBinding(Z,x){const F=Z.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(F),F._lateAnimationHolders||(F._lateAnimationHolders={}),F._lateAnimationHolders[Z.targetPath]||(F._lateAnimationHolders[Z.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:x}),Z.isAdditive?(F._lateAnimationHolders[Z.targetPath].additiveAnimations.push(Z),F._lateAnimationHolders[Z.targetPath].totalAdditiveWeight+=Z.weight):(F._lateAnimationHolders[Z.targetPath].animations.push(Z),F._lateAnimationHolders[Z.targetPath].totalWeight+=Z.weight)}_setValue(Z,x,F,G,f){if(this._currentActiveTarget=x,this._weight=G,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const Z=x[this._targetPath];Z.clone?this._originalBlendValue=Z.clone():this._originalBlendValue=Z}this._originalBlendValue.m?u.d.AllowMatrixDecomposeForInterpolation?this._currentValue?d.Matrix.DecomposeLerpToRef(this._originalBlendValue,F,this._blendingFactor,this._currentValue):this._currentValue=d.Matrix.DecomposeLerp(this._originalBlendValue,F,this._blendingFactor):this._currentValue?d.Matrix.LerpToRef(this._originalBlendValue,F,this._blendingFactor,this._currentValue):this._currentValue=d.Matrix.Lerp(this._originalBlendValue,F,this._blendingFactor):this._currentValue=u.d._UniversalLerp(this._originalBlendValue,F,this._blendingFactor);const G=Z&&Z.animationPropertiesOverride?Z.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=G}else this._currentValue?this._currentValue.G?this._currentValue.G(F):this._currentValue=F:null!==F&&void 0!==F&&F.clone?this._currentValue=F.clone():this._currentValue=F;-1!==G?this._registerTargetForLateAnimationBinding(this,this._originalValue[f]):this._animationState.loopMode===u.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[f],x[this._targetPath]):x[this._targetPath]=this._originalValue[f]+this._currentValue:x[this._targetPath]=this._currentValue,Z.It&&Z.It(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const F=this._animation.getKeys();Z<F[0].frame?Z=F[0].frame:Z>F[F.length-1].frame&&(Z=F[F.length-1].frame);const u=this._events;if(u.length)for(let f=0;f<u.length;f++)u[f].onlyOnce||(u[f].isDone=u[f].frame<Z);this._currentFrame=Z;const G=this._animation._interpolate(Z,this._animationState);this.setValue(G,x)}_prepareForSpeedRatioChange(Z){const x=this._previousElapsedTime*(this._animation.framePerSecond*Z)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-x}animate(Z,x,F,G,f){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const j=this._animation,d=j.targetPropertyPath;if(!d||d.length<1)return this._stopped=!0,!1;let t,o=!0;const c=this._events;let s=0;if(this._coreRuntimeAnimation)s=F-x,t=this._coreRuntimeAnimation.currentFrame,this._currentFrame=t,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let Y;(x<this._minFrame||x>this._maxFrame)&&(x=this._minFrame),(F<this._minFrame||F>this._maxFrame)&&(F=this._maxFrame),s=F-x;let d=Z*(j.framePerSecond*f)/1e3+this._absoluteFrameOffset,J=0,p=!1;const U=G&&this._animationState.loopMode===u.d.ANIMATIONLOOPMODE_YOYO;if(U){const Z=(d-x)/s,F=Math.sin(Z*Math.PI);d=Math.abs(F)*s+x;const u=F>=0?1:-1;this._yoyoDirection!==u&&(p=!0),this._yoyoDirection=u}if(this._previousElapsedTime=Z,this._previousAbsoluteFrame=d,!G&&F>=x&&(d>=s&&f>0||d<=0&&f<0))o=!1,J=j._getKeyValue(this._maxValue);else if(!G&&x>=F&&(d<=s&&f<0||d>=0&&f>0))o=!1,J=j._getKeyValue(this._minValue);else if(this._animationState.loopMode!==u.d.ANIMATIONLOOPMODE_CYCLE){const Z=F.toString()+x.toString();if(!this._offsetsCache[Z]){this._animationState.repeatCount=0,this._animationState.loopMode=u.d.ANIMATIONLOOPMODE_CYCLE;const G=j._interpolate(x,this._animationState),f=j._interpolate(F,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),j.dataType){case u.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[Z]=f-G;break;case u.d.ANIMATIONTYPE_QUATERNION:case u.d.ANIMATIONTYPE_VECTOR3:case u.d.ANIMATIONTYPE_VECTOR2:case u.d.ANIMATIONTYPE_SIZE:case u.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[Z]=f.Mx(G)}this._highLimitsCache[Z]=f}J=this._highLimitsCache[Z],Y=this._offsetsCache[Z]}if(void 0===Y)switch(j.dataType){case u.d.ANIMATIONTYPE_FLOAT:Y=0;break;case u.d.ANIMATIONTYPE_QUATERNION:Y=u.m;break;case u.d.ANIMATIONTYPE_VECTOR3:Y=u.t;break;case u.d.ANIMATIONTYPE_VECTOR2:Y=u.r;break;case u.d.ANIMATIONTYPE_SIZE:Y=u.p;break;case u.d.ANIMATIONTYPE_COLOR3:Y=u.g;break;case u.d.ANIMATIONTYPE_COLOR4:Y=u.k}if(this._host&&this._host.syncRoot){const Z=this._host.syncRoot;t=x+s*((Z.masterFrame-Z.fromFrame)/(Z.toFrame-Z.fromFrame))}else t=d>0&&x>F||d<0&&x<F?o&&0!==s?F+d%s:x:o&&0!==s?x+d%s:F;if(!U&&(f>0&&this.currentFrame>t||f<0&&this.currentFrame<t)||U&&p){this._onLoop();for(let Z=0;Z<c.length;Z++)c[Z].onlyOnce||(c[Z].isDone=!1);this._animationState.key=f>0?0:j.getKeys().length-1}this._currentFrame=t,this._animationState.repeatCount=0===s?0:d/s|0,this._animationState.highLimitValue=J,this._animationState.offsetValue=Y}const J=j._interpolate(t,this._animationState);if(this.setValue(J,Y),c.length)for(let u=0;u<c.length;u++)if(s>=0&&t>=c[u].frame&&c[u].frame>=x||s<0&&t<=c[u].frame&&c[u].frame<=x){const Z=c[u];Z.isDone||(Z.onlyOnce&&(c.splice(u,1),u--),Z.isDone=!0,Z.action(t))}return o||(this._stopped=!0),o}}var o=F(11022);class c{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(Z){this._weight=-1!==Z?Math.min(Math.max(Z,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(Z){for(let x=0;x<this._runtimeAnimations.length;x++){this._runtimeAnimations[x]._prepareForSpeedRatioChange(Z)}this._speedRatio=Z,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,f=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,j=arguments.length>6?arguments[6]:void 0,d=arguments.length>7?arguments[7]:void 0,t=arguments.length>8?arguments[8]:void 0,o=arguments.length>9&&void 0!==arguments[9]&&arguments[9],c=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=x,this.fromFrame=F,this.toFrame=u,this.loopAnimation=f,this.onAnimationEnd=j,this.onAnimationLoop=t,this.isAdditive=o,this.playOrder=c,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.dj=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new G.b,this.onAnimationLoopObservable=new G.b,this._scene=Z,d&&this.appendAnimations(x,d),this._speedRatio=Y,Z._activeAnimatables.push(this)}syncWith(Z){if(this._syncRoot=Z,Z){const Z=this._scene._activeAnimatables.indexOf(this);Z>-1&&(this._scene._activeAnimatables.splice(Z,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(Z,x){for(let F=0;F<x.length;F++){const u=x[F],G=new t(Z,u,this._scene,this);G._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(G)}}getAnimationByTargetProperty(Z){const x=this._runtimeAnimations;for(let F=0;F<x.length;F++)if(x[F].animation.targetProperty===Z)return x[F].animation;return null}getRuntimeAnimationByTargetProperty(Z){const x=this._runtimeAnimations;for(let F=0;F<x.length;F++)if(x[F].animation.targetProperty===Z)return x[F];return null}reset(){const Z=this._runtimeAnimations;for(let x=0;x<Z.length;x++)Z[x].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(Z){const x=this._runtimeAnimations;for(let F=0;F<x.length;F++)x[F].animation.enableBlending=!0,x[F].animation.blendingSpeed=Z}disableBlending(){const Z=this._runtimeAnimations;for(let x=0;x<Z.length;x++)Z[x].animation.enableBlending=!1}goToFrame(Z){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const F=this._runtimeAnimations;if(F[0]){const x=F[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??F[0].currentFrame;const u=0===this.speedRatio?0:(Z-this._frameToSyncFromJump)/x*1e3/this.speedRatio;this._manualJumpDelay=-u}for(let u=0;u<F.length;u++)F[u].goToFrame(Z,x?this._weight:-1);this._goToFrame=Z}get paused(){return this.dj}pause(){this.dj||(this.dj=!0)}restart(){this.dj=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(Z,x){let F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],u=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Z||x){const G=this._scene._activeAnimatables.indexOf(this);if(G>-1){const f=this._runtimeAnimations;for(let F=f.length-1;F>=0;F--){const u=f[F];Z&&u.animation.name!=Z||(x&&!x(u.target)||(u.dispose(),f.splice(F,1)))}0==f.length&&(F||this._scene._activeAnimatables.splice(G,1),u||this._raiseOnAnimationEnd())}}else{const Z=this._scene._activeAnimatables.indexOf(this);if(Z>-1){F||this._scene._activeAnimatables.splice(Z,1);const x=this._runtimeAnimations;for(let Z=0;Z<x.length;Z++)x[Z].dispose();this._runtimeAnimations.length=0,u||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((Z=>{this.onAnimationEndObservable.add((()=>{Z(this)}),void 0,void 0,this,!0)}))}_animate(Z){if(this.dj)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=Z),!0;if(null===this._localDelayOffset?(this._localDelayOffset=Z,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=Z-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let x=!1;const F=this._runtimeAnimations;let u;for(u=0;u<F.length;u++){const G=F[u].animate(Z-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);x=x||G}if(this.animationStarted=x,!x){if(this.disposeOnEnd)for(u=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(u,1),u=0;u<F.length;u++)F[u].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return x}}function s(Z){if(0===Z.totalWeight&&0===Z.totalAdditiveWeight)return Z.originalValue;let x=1;const F=d.TmpVectors.kx[0],u=d.TmpVectors.kx[1],G=d.TmpVectors.Quaternion[0];let f=0;const Y=Z.animations[0],j=Z.originalValue;let t=1,o=!1;if(Z.totalWeight<1)t=1-Z.totalWeight,j.decompose(u,G,F);else{if(f=1,x=Z.totalWeight,t=Y.weight/x,1==t){if(!Z.totalAdditiveWeight)return Y.currentValue;o=!0}Y.currentValue.decompose(u,G,F)}if(!o){u.scaleInPlace(t),F.scaleInPlace(t),G.scaleInPlace(t);for(let Y=f;Y<Z.animations.length;Y++){const f=Z.animations[Y];if(0===f.weight)continue;t=f.weight/x;const j=d.TmpVectors.kx[2],o=d.TmpVectors.kx[3],c=d.TmpVectors.Quaternion[1];f.currentValue.decompose(o,c,j),o.scaleAndAddToRef(t,u),c.scaleAndAddToRef(d.Quaternion.Dot(G,c)>0?t:-t,G),j.scaleAndAddToRef(t,F)}G.normalize()}for(let s=0;s<Z.additiveAnimations.length;s++){const x=Z.additiveAnimations[s];if(0===x.weight)continue;const f=d.TmpVectors.kx[2],Y=d.TmpVectors.kx[3],j=d.TmpVectors.Quaternion[1];x.currentValue.decompose(Y,j,f),Y.multiplyToRef(u,Y),d.kx.LerpToRef(u,Y,x.weight,u),G.multiplyToRef(j,j),d.Quaternion.SlerpToRef(G,j,x.weight,G),f.scaleAndAddToRef(x.weight,F)}const c=Y?Y._animationState.workValue:d.TmpVectors.Matrix[0].clone();return d.Matrix.ComposeToRef(u,G,F,c),c}function J(Z,x){if(0===Z.totalWeight&&0===Z.totalAdditiveWeight)return x;const F=Z.animations[0],u=Z.originalValue;let G=x;if(0===Z.totalWeight&&Z.totalAdditiveWeight>0)G.G(u);else if(1===Z.animations.length){if(d.Quaternion.SlerpToRef(u,F.currentValue,Math.min(1,Z.totalWeight),G),0===Z.totalAdditiveWeight)return G}else if(Z.animations.length>1){let F,f,Y=1;if(Z.totalWeight<1){const x=1-Z.totalWeight;F=[],f=[],F.push(u),f.push(x)}else{if(2===Z.animations.length&&(d.Quaternion.SlerpToRef(Z.animations[0].currentValue,Z.animations[1].currentValue,Z.animations[1].weight/Z.totalWeight,x),0===Z.totalAdditiveWeight))return x;F=[],f=[],Y=Z.totalWeight}for(let x=0;x<Z.animations.length;x++){const u=Z.animations[x];F.push(u.currentValue),f.push(u.weight/Y)}let j=0;for(let Z=0;Z<F.length;)Z?(j+=f[Z],d.Quaternion.SlerpToRef(G,F[Z],f[Z]/j,G),Z++):(d.Quaternion.SlerpToRef(F[Z],F[Z+1],f[Z+1]/(f[Z]+f[Z+1]),x),G=x,j=f[Z]+f[Z+1],Z+=2)}for(let f=0;f<Z.additiveAnimations.length;f++){const x=Z.additiveAnimations[f];0!==x.weight&&(G.multiplyToRef(x.currentValue,d.TmpVectors.Quaternion[0]),d.Quaternion.SlerpToRef(G,d.TmpVectors.Quaternion[0],x.weight,G))}return G}var p,U,k=F(11447);p=k.d,(U=j.b)&&(U.prototype.copyAnimationRange=function(Z,x,F){let G=arguments.length>3&&void 0!==arguments[3]&&arguments[3],f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new u.d(this.name,"_matrix",Z.animations[0].framePerSecond,u.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Y=Z.animations[0].getRange(x);if(!Y)return!1;const j=Y.from,d=Y.to,t=Z.animations[0].getKeys(),o=Z.length,c=Z.getParent(),s=this.getParent(),J=G&&c&&o&&this.length&&o!==this.length,p=J&&s&&c?s.length/c.length:1,U=G&&!s&&f&&(1!==f.x||1!==f.y||1!==f.z),k=this.animations[0].getKeys();let M,m,C;for(let u=0,L=t.length;u<L;u++)M=t[u],M.frame>=j&&M.frame<=d&&(G?(C=M.value.clone(),J?(m=C.getTranslation(),C.setTranslation(m.scaleInPlace(p))):U&&f?(m=C.getTranslation(),C.setTranslation(m.multiplyInPlace(f))):C=M.value):C=M.value,k.push({frame:M.frame+F,value:C}));return this.animations[0].createRange(x,j+F,d+F),!0}),p&&(p.prototype._animate=function(Z){if(!this.animationsEnabled)return;const x=o.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=x}this.deltaTime=void 0!==Z?Z:this.useConstantAnimationDeltaTime?16:(x-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=x;const F=this._activeAnimatables;if(0===F.length)return;this._animationTime+=this.deltaTime;const G=this._animationTime;for(let u=0;u<F.length;u++){const Z=F[u];!Z._animate(G)&&Z.disposeOnEnd&&u--}!function(Z){if(Z._registeredForLateAnimationBindings.length){for(let x=0;x<Z._registeredForLateAnimationBindings.length;x++){const F=Z._registeredForLateAnimationBindings.data[x];for(const Z in F._lateAnimationHolders){const x=F._lateAnimationHolders[Z],G=x.animations[0],f=x.originalValue;if(void 0===f||null===f)continue;const Y=u.d.AllowMatrixDecomposeForInterpolation&&f.m;let j=F[Z];if(Y)j=s(x);else if(void 0!==f.w)j=J(x,j||d.Quaternion.Identity());else{let Z=0,F=1;const Y=G&&G._animationState.loopMode===u.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(x.totalWeight<1)j=Y?f.clone?f.clone():f:G&&f.scale?f.scale(1-x.totalWeight):G?f*(1-x.totalWeight):f.clone?f.clone():f;else if(G){F=x.totalWeight;const u=G.weight/F;j=1!==u?G.currentValue.scale?G.currentValue.scale(u):G.currentValue*u:G.currentValue,Y&&(j.addToRef?j.addToRef(f,j):j+=f),Z=1}for(let u=Z;u<x.animations.length;u++){const Z=x.animations[u],G=Z.weight/F;G&&(Z.currentValue.scaleAndAddToRef?Z.currentValue.scaleAndAddToRef(G,j):j+=Z.currentValue*G)}for(let u=0;u<x.additiveAnimations.length;u++){const Z=x.additiveAnimations[u],F=Z.weight;F&&(Z.currentValue.scaleAndAddToRef?Z.currentValue.scaleAndAddToRef(F,j):j+=Z.currentValue*F)}}F[Z]=j}F._lateAnimationHolders={}}Z._registeredForLateAnimationBindings.reset()}}(this)},p.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((Z,x)=>Z.playOrder-x.playOrder))},p.prototype.beginWeightedAnimation=function(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,G=arguments.length>4?arguments[4]:void 0,f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,j=arguments.length>7?arguments[7]:void 0,d=arguments.length>8?arguments[8]:void 0,t=arguments.length>9?arguments[9]:void 0,o=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const c=this.beginAnimation(Z,x,F,G,f,Y,j,!1,d,t,o);return c.weight=u,c},p.prototype.beginAnimation=function(Z,x,F,u){let G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,f=arguments.length>5?arguments[5]:void 0,Y=arguments.length>6?arguments[6]:void 0,j=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],d=arguments.length>8?arguments[8]:void 0,t=arguments.length>9?arguments[9]:void 0,o=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(G<0){const Z=x;x=F,F=Z,G=-G}x>F&&(G=-G),j&&this.stopAnimation(Z,void 0,d),Y||(Y=new c(this,Z,x,F,u,G,f,void 0,t,o));const s=!d||d(Z);if(Z.animations&&s&&Y.appendAnimations(Z,Z.animations),Z.getAnimatables){const o=Z.getAnimatables();for(let Z=0;Z<o.length;Z++)this.beginAnimation(o[Z],x,F,u,G,f,Y,j,d,t)}return Y.reset(),Y},p.prototype.beginHierarchyAnimation=function(Z,x,F,u,G){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,j=arguments.length>7?arguments[7]:void 0,d=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],t=arguments.length>9?arguments[9]:void 0,o=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const c=Z.getDescendants(x),s=[];s.push(this.beginAnimation(Z,F,u,G,f,Y,j,d,t,void 0,o));for(const J of c)s.push(this.beginAnimation(J,F,u,G,f,Y,j,d,t,void 0,o));return s},p.prototype.beginDirectAnimation=function(Z,x,F,u,G){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(f<0){const Z=F;F=u,u=Z,f=-f}return F>u&&(f=-f),new c(this,Z,F,u,G,f,arguments.length>6?arguments[6]:void 0,x,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},p.prototype.beginDirectHierarchyAnimation=function(Z,x,F,u,G,f,Y,j,d){let t=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const o=Z.getDescendants(x),c=[];c.push(this.beginDirectAnimation(Z,F,u,G,f,Y,j,d,t));for(const s of o)c.push(this.beginDirectAnimation(s,F,u,G,f,Y,j,d,t));return c},p.prototype.getAnimatableByTarget=function(Z){for(let x=0;x<this._activeAnimatables.length;x++)if(this._activeAnimatables[x].target===Z)return this._activeAnimatables[x];return null},p.prototype.getAllAnimatablesByTarget=function(Z){const x=[];for(let F=0;F<this._activeAnimatables.length;F++)this._activeAnimatables[F].target===Z&&x.push(this._activeAnimatables[F]);return x},p.prototype.stopAnimation=function(Z,x,F){const u=this.getAllAnimatablesByTarget(Z);for(const G of u)G.stop(x,F)},p.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let Z=0;Z<this._activeAnimatables.length;Z++)this._activeAnimatables[Z].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const Z of this.animationGroups)Z.stop()});class M{getClassName(){return"TargetedAnimation"}serialize(){const Z={};return Z.animation=this.animation.serialize(),Z.targetId=this.target.id,Z}}class m{get mask(){return this._mask}set mask(Z){this._mask!==Z&&(this._mask=Z,this.syncWithMask(!0))}syncWithMask(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||Z){this._numActiveAnimatables=0;for(let Z=0;Z<this._animatables.length;++Z){const x=this._animatables[Z];!this.mask||this.mask.disabled||this.mask.retainsTarget(x.target.name)?(this._numActiveAnimatables++,x.paused&&x.restart()):x.paused||x.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let Z=0;Z<this._animatables.length;++Z){const x=this._animatables[Z];this.mask.retainsTarget(x.target.name)||(x.stop(),this._animatables.splice(Z,1),--Z)}for(let Z=0;Z<this._targetedAnimations.length;Z++){const x=this._targetedAnimations[Z];this.mask.retainsTarget(x.target.name)||(this._targetedAnimations.splice(Z,1),--Z)}}}get from(){return this._from}set from(Z){if(this._from!==Z){this._from=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].fromFrame=this._from}}}get to(){return this._to}set to(Z){if(this._to!==Z){this._to=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(Z){if(this._speedRatio!==Z){this._speedRatio=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(Z){if(this._loopAnimation!==Z){this._loopAnimation=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(Z){if(this._isAdditive!==Z){this._isAdditive=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(Z){this._weight!==Z&&(this._weight=Z,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(Z){if(this._playOrder!==Z&&(this._playOrder=Z,this._animatables.length>0)){for(let Z=0;Z<this._animatables.length;Z++)this._animatables[Z].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(Z){if(this._enableBlending!==Z&&(this._enableBlending=Z,null!==Z))for(let x=0;x<this._targetedAnimations.length;++x)this._targetedAnimations[x].animation.enableBlending=Z}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(Z){if(this._blendingSpeed!==Z&&(this._blendingSpeed=Z,null!==Z))for(let x=0;x<this._targetedAnimations.length;++x)this._targetedAnimations[x].animation.blendingSpeed=Z}getLength(Z,x){Z=Z??this._from;return((x=x??this._to)-Z)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(Z){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],u=arguments.length>3?arguments[3]:void 0;if(0===Z.length)return null;u=u??Z[0].weight;let G=Number.MAX_VALUE,f=-Number.MAX_VALUE;if(F)for(const j of Z)j.from<G&&(G=j.from),j.to>f&&(f=j.to);const Y=new m(Z[0].name+"_merged",Z[0]._scene,u);for(const j of Z){F&&j.normalize(G,f);for(const Z of j.targetedAnimations)Y.addTargetedAnimation(Z.animation,Z.target);x&&j.dispose()}return Y}constructor(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=Z,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new G.b,this.onAnimationLoopObservable=new G.b,this.onAnimationGroupLoopObservable=new G.b,this.onAnimationGroupEndObservable=new G.b,this.onAnimationGroupPauseObservable=new G.b,this.onAnimationGroupPlayObservable=new G.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=x||f.c.LastCreatedScene,this._weight=F,this._playOrder=u,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(Z,x){const F=new M;F.animation=Z,F.target=x;const u=Z.getKeys();return this._from>u[0].frame&&(this._from=u[0].frame),this._to<u[u.length-1].frame&&(this._to=u[u.length-1].frame),null!==this._enableBlending&&(Z.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(Z.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(F),this._shouldStart=!0,F}removeTargetedAnimation(Z){for(let x=this._targetedAnimations.length-1;x>-1;x--){this._targetedAnimations[x].animation===Z&&this._targetedAnimations.splice(x,1)}}normalize(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==Z&&(Z=this._from),null==x&&(x=this._to);for(let F=0;F<this._targetedAnimations.length;F++){const u=this._targetedAnimations[F].animation.getKeys(),G=u[0],f=u[u.length-1];if(G.frame>Z){const x={frame:Z,value:G.value,inTangent:G.inTangent,outTangent:G.outTangent,interpolation:G.interpolation};u.splice(0,0,x)}if(f.frame<x){const Z={frame:x,value:f.value,inTangent:f.inTangent,outTangent:f.outTangent,interpolation:f.interpolation};u.push(Z)}}return this._from=Z,this._to=x,this}_processLoop(Z,x,F){Z.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(x),this._animationLoopFlags[F]||(this._animationLoopFlags[F]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0],x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0,u=arguments.length>3?arguments[3]:void 0,G=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=Z,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let f=0;f<this._targetedAnimations.length;f++){const Y=this._targetedAnimations[f],j=this._scene.beginDirectAnimation(Y.target,[Y.animation],void 0!==F?F:this._from,void 0!==u?u:this._to,Z,x,void 0,void 0,void 0!==G?G:this._isAdditive);j.weight=this._weight,j.playOrder=this._playOrder,j.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Y),this._checkAnimationGroupEnded(j)},this._processLoop(j,Y,f),this._animatables.push(j)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=x,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(Z){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==Z&&(this.loopAnimation=Z),this.restart()):(this.stop(),this.start(Z,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].reset()}return this}restart(){if(!this._isStarted)return this;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const x=this._animatables.slice();for(let u=0;u<x.length;u++)x[u].stop(void 0,void 0,!0,Z);let F=0;for(let u=0;u<this._scene._activeAnimatables.length;u++){const x=this._scene._activeAnimatables[u];x._runtimeAnimations.length>0?this._scene._activeAnimatables[F++]=x:Z&&this._checkAnimationGroupEnded(x,Z)}return this._scene._activeAnimatables.length=F,this._isStarted=!1,this}setWeightForAllAnimatables(Z){for(let x=0;x<this._animatables.length;x++){this._animatables[x].weight=Z}return this}syncAllAnimationsWith(Z){for(let x=0;x<this._animatables.length;x++){this._animatables[x].syncWith(Z)}return this}goToFrame(Z){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let F=0;F<this._animatables.length;F++){this._animatables[F].goToFrame(Z,x)}return this}getCurrentFrame(){var Z;return(null===(Z=this.animatables[0])||void 0===Z?void 0:Z.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const Z=this._scene.animationGroups.indexOf(this);if(Z>-1&&this._scene.animationGroups.splice(Z,1),this._parentContainer){const Z=this._parentContainer.animationGroups.indexOf(this);Z>-1&&this._parentContainer.animationGroups.splice(Z,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(Z){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const F=this._animatables.indexOf(Z);F>-1&&this._animatables.splice(F,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,x||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(Z,x){let F=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const u=new m(Z||this.name,this._scene,this._weight,this._playOrder);u._from=this.from,u._to=this.to,u._speedRatio=this.speedRatio,u._loopAnimation=this.loopAnimation,u._isAdditive=this.isAdditive,u._enableBlending=this.enableBlending,u._blendingSpeed=this.blendingSpeed,u.metadata=this.metadata,u.mask=this.mask;for(const G of this._targetedAnimations)u.addTargetedAnimation(F?G.animation.clone():G.animation,x?x(G.target):G.target);return u}serialize(){const Z={};Z.name=this.name,Z.from=this.from,Z.to=this.to,Z.speedRatio=this.speedRatio,Z.loopAnimation=this.loopAnimation,Z.isAdditive=this.isAdditive,Z.weight=this.weight,Z.playOrder=this.playOrder,Z.enableBlending=this.enableBlending,Z.blendingSpeed=this.blendingSpeed,Z.targetedAnimations=[];for(let x=0;x<this.targetedAnimations.length;x++){const F=this.targetedAnimations[x];Z.targetedAnimations[x]=F.serialize()}return Y.e&&Y.e.HasTags(this)&&(Z.tags=Y.e.GetTags(this)),this.metadata&&(Z.metadata=this.metadata),Z}static Parse(Z,x){const F=new m(Z.name,x,Z.weight,Z.playOrder);for(let G=0;G<Z.targetedAnimations.length;G++){const f=Z.targetedAnimations[G],Y=u.d.Parse(f.animation),j=f.targetId;if("influence"===f.animation.property){const Z=x.getMorphTargetById(j);Z&&F.addTargetedAnimation(Y,Z)}else{const Z=x.getNodeById(j);null!=Z&&F.addTargetedAnimation(Y,Z)}}return Y.e&&Y.e.AddTagsTo(F,Z.tags),null!==Z.from&&null!==Z.to&&F.normalize(Z.from,Z.to),void 0!==Z.speedRatio&&(F._speedRatio=Z.speedRatio),void 0!==Z.loopAnimation&&(F._loopAnimation=Z.loopAnimation),void 0!==Z.isAdditive&&(F._isAdditive=Z.isAdditive),void 0!==Z.weight&&(F._weight=Z.weight),void 0!==Z.playOrder&&(F._playOrder=Z.playOrder),void 0!==Z.enableBlending&&(F._enableBlending=Z.enableBlending),void 0!==Z.blendingSpeed&&(F._blendingSpeed=Z.blendingSpeed),void 0!==Z.metadata&&(F.metadata=Z.metadata),F}static MakeAnimationAdditive(Z,x,F){let G;G="object"===typeof x?x:{referenceFrame:x,range:F,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let f=Z;G.cloneOriginalAnimationGroup&&(f=Z.clone(G.clonedAnimationGroupName||f.name));const Y=f.targetedAnimations;for(let j=0;j<Y.length;j++){const Z=Y[j];Z.animation=u.d.MakeAnimationAdditive(Z.animation,G)}if(f.isAdditive=!0,G.clipKeys){let Z=Number.MAX_VALUE,x=-Number.MAX_VALUE;const F=f.targetedAnimations;for(let u=0;u<F.length;u++){const G=F[u].animation.getKeys();Z>G[0].frame&&(Z=G[0].frame),x<G[G.length-1].frame&&(x=G[G.length-1].frame)}f._from=Z,f._to=x}return f}static ClipKeys(Z,x,F,u,G){const f=Z.clone(u||Z.name);return m.ClipKeysInPlace(f,x,F,G)}static ClipKeysInPlace(Z,x,F,u){return m.ClipInPlace(Z,x,F,u,!1)}static ClipFrames(Z,x,F,u,G){const f=Z.clone(u||Z.name);return m.ClipFramesInPlace(f,x,F,G)}static ClipFramesInPlace(Z,x,F,u){return m.ClipInPlace(Z,x,F,u,!0)}static ClipInPlace(Z,x,F,u){let G=arguments.length>4&&void 0!==arguments[4]&&arguments[4],f=Number.MAX_VALUE,Y=-Number.MAX_VALUE;const j=Z.targetedAnimations;for(let d=0;d<j.length;d++){const Z=j[d],t=u?Z.animation:Z.animation.clone();G&&(t.createKeyForFrame(x),t.createKeyForFrame(F));const o=t.getKeys(),c=[];let s=Number.MAX_VALUE;for(let u=0;u<o.length;u++){const Z=o[u];if(!G&&u>=x&&u<=F||G&&Z.frame>=x&&Z.frame<=F){const x={frame:Z.frame,value:Z.value.clone?Z.value.clone():Z.value,inTangent:Z.inTangent,outTangent:Z.outTangent,interpolation:Z.interpolation,lockedTangent:Z.lockedTangent};s===Number.MAX_VALUE&&(s=x.frame),x.frame-=s,c.push(x)}}0!==c.length?(f>c[0].frame&&(f=c[0].frame),Y<c[c.length-1].frame&&(Y=c[c.length-1].frame),t.setKeys(c,!0),Z.animation=t):(j.splice(d,1),d--)}return Z._from=f,Z._to=Y,Z}getClassName(){return"AnimationGroup"}toString(Z){let x="Name: "+this.name;return x+=", type: "+this.getClassName(),Z&&(x+=", from: "+this._from,x+=", to: "+this._to,x+=", isStarted: "+this._isStarted,x+=", speedRatio: "+this._speedRatio,x+=", targetedAnimations length: "+this._targetedAnimations.length,x+=", animatables length: "+this._animatables),x}}}}]);