"use strict";(self.h6ljd275xwr=self.h6ljd275xwr||[]).push([[78],{14546:(n,y,H)=>{H.r(y),H.d(y,{AnimationGroup:()=>l,TargetedAnimation:()=>Q});var o=H(11885),G=H(11099),h=H(11149),k=H(11328),i=H(13034),B=H(11288);class V{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(n,y,H,G){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=y,this._target=n,this._scene=H,this._host=G,this._activeTargets=[],y._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===o.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=B.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const n={frame:0,value:this._minValue};this._keys.splice(0,0,n)}if(this._target instanceof Array){let n=0;for(const y of this._target)this._preparePath(y,n),this._getOriginalValues(n),n++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const h=y.getEvents();if(h&&h.length>0)for(const o of h)this._events.push(o._clone());this._enableBlending=n&&n.animationPropertiesOverride?n.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=this._animation.targetPropertyPath;if(H.length>1){let o=n;for(let n=0;n<H.length-1;n++){const y=H[n];if(o=o[y],void 0===o)throw new Error(`Invalid property (${y}) in property path (${H.join(".")})`)}this._targetPath=H[H.length-1],this._activeTargets[y]=o}else this._targetPath=H[0],this._activeTargets[y]=n;if(void 0===this._activeTargets[y][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${H.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let n=0;for(const y of this._target)void 0!==this._originalValue[n]&&this._setValue(y,this._activeTargets[n],this._originalValue[n],-1,n),n++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let n=0;n<this._events.length;n++)this._events[n].isDone=!1}isStopped(){return this._stopped}dispose(){const n=this._animation.runtimeAnimations.indexOf(this);n>-1&&this._animation.runtimeAnimations.splice(n,1)}setValue(n,y){if(this._targetIsArray)for(let H=0;H<this._target.length;H++){const o=this._target[H];this._setValue(o,this._activeTargets[H],n,y,H)}else this._setValue(this._target,this._directTarget,n,y,0)}_getOriginalValues(){let n,y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const H=this._activeTargets[y];n=H.getLocalMatrix&&"_matrix"===this._targetPath?H.getLocalMatrix():H[this._targetPath],n&&n.clone?this._originalValue[y]=n.clone():this._originalValue[y]=n}_registerTargetForLateAnimationBinding(n,y){const H=n.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(H),H._lateAnimationHolders||(H._lateAnimationHolders={}),H._lateAnimationHolders[n.targetPath]||(H._lateAnimationHolders[n.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:y}),n.isAdditive?(H._lateAnimationHolders[n.targetPath].additiveAnimations.push(n),H._lateAnimationHolders[n.targetPath].totalAdditiveWeight+=n.weight):(H._lateAnimationHolders[n.targetPath].animations.push(n),H._lateAnimationHolders[n.targetPath].totalWeight+=n.weight)}_setValue(n,y,H,G,h){if(this._currentActiveTarget=y,this._weight=G,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const n=y[this._targetPath];n.clone?this._originalBlendValue=n.clone():this._originalBlendValue=n}this._originalBlendValue.m?o.e.AllowMatrixDecomposeForInterpolation?this._currentValue?B.Matrix.DecomposeLerpToRef(this._originalBlendValue,H,this._blendingFactor,this._currentValue):this._currentValue=B.Matrix.DecomposeLerp(this._originalBlendValue,H,this._blendingFactor):this._currentValue?B.Matrix.LerpToRef(this._originalBlendValue,H,this._blendingFactor,this._currentValue):this._currentValue=B.Matrix.Lerp(this._originalBlendValue,H,this._blendingFactor):this._currentValue=o.e._UniversalLerp(this._originalBlendValue,H,this._blendingFactor);const G=n&&n.animationPropertiesOverride?n.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=G}else this._currentValue?this._currentValue.B?this._currentValue.B(H):this._currentValue=H:null!==H&&void 0!==H&&H.clone?this._currentValue=H.clone():this._currentValue=H;-1!==G?this._registerTargetForLateAnimationBinding(this,this._originalValue[h]):this._animationState.loopMode===o.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[h],y[this._targetPath]):y[this._targetPath]=this._originalValue[h]+this._currentValue:y[this._targetPath]=this._currentValue,n.ZV&&n.ZV(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const H=this._animation.getKeys();n<H[0].frame?n=H[0].frame:n>H[H.length-1].frame&&(n=H[H.length-1].frame);const o=this._events;if(o.length)for(let h=0;h<o.length;h++)o[h].onlyOnce||(o[h].isDone=o[h].frame<n);this._currentFrame=n;const G=this._animation._interpolate(n,this._animationState);this.setValue(G,y)}_prepareForSpeedRatioChange(n){const y=this._previousElapsedTime*(this._animation.framePerSecond*n)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-y}animate(n,y,H,G,h){let k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const i=this._animation,B=i.targetPropertyPath;if(!B||B.length<1)return this._stopped=!0,!1;let V,q=!0;const b=this._events;let A=0;if(this._coreRuntimeAnimation)A=H-y,V=this._coreRuntimeAnimation.currentFrame,this._currentFrame=V,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let k;(y<this._minFrame||y>this._maxFrame)&&(y=this._minFrame),(H<this._minFrame||H>this._maxFrame)&&(H=this._maxFrame),A=H-y;let B=n*(i.framePerSecond*h)/1e3+this._absoluteFrameOffset,U=0,T=!1;const W=G&&this._animationState.loopMode===o.e.ANIMATIONLOOPMODE_YOYO;if(W){const n=(B-y)/A,H=Math.sin(n*Math.PI);B=Math.abs(H)*A+y;const o=H>=0?1:-1;this._yoyoDirection!==o&&(T=!0),this._yoyoDirection=o}if(this._previousElapsedTime=n,this._previousAbsoluteFrame=B,!G&&H>=y&&(B>=A&&h>0||B<=0&&h<0))q=!1,U=i._getKeyValue(this._maxValue);else if(!G&&y>=H&&(B<=A&&h<0||B>=0&&h>0))q=!1,U=i._getKeyValue(this._minValue);else if(this._animationState.loopMode!==o.e.ANIMATIONLOOPMODE_CYCLE){const n=H.toString()+y.toString();if(!this._offsetsCache[n]){this._animationState.repeatCount=0,this._animationState.loopMode=o.e.ANIMATIONLOOPMODE_CYCLE;const G=i._interpolate(y,this._animationState),h=i._interpolate(H,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),i.dataType){case o.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[n]=h-G;break;case o.e.ANIMATIONTYPE_QUATERNION:case o.e.ANIMATIONTYPE_VECTOR3:case o.e.ANIMATIONTYPE_VECTOR2:case o.e.ANIMATIONTYPE_SIZE:case o.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[n]=h.Qy(G)}this._highLimitsCache[n]=h}U=this._highLimitsCache[n],k=this._offsetsCache[n]}if(void 0===k)switch(i.dataType){case o.e.ANIMATIONTYPE_FLOAT:k=0;break;case o.e.ANIMATIONTYPE_QUATERNION:k=o.n;break;case o.e.ANIMATIONTYPE_VECTOR3:k=o.u;break;case o.e.ANIMATIONTYPE_VECTOR2:k=o.q;break;case o.e.ANIMATIONTYPE_SIZE:k=o.p;break;case o.e.ANIMATIONTYPE_COLOR3:k=o.f;break;case o.e.ANIMATIONTYPE_COLOR4:k=o.j}if(this._host&&this._host.syncRoot){const n=this._host.syncRoot;V=y+A*((n.masterFrame-n.fromFrame)/(n.toFrame-n.fromFrame))}else V=B>0&&y>H||B<0&&y<H?q&&0!==A?H+B%A:y:q&&0!==A?y+B%A:H;if(!W&&(h>0&&this.currentFrame>V||h<0&&this.currentFrame<V)||W&&T){this._onLoop();for(let n=0;n<b.length;n++)b[n].onlyOnce||(b[n].isDone=!1);this._animationState.key=h>0?0:i.getKeys().length-1}this._currentFrame=V,this._animationState.repeatCount=0===A?0:B/A|0,this._animationState.highLimitValue=U,this._animationState.offsetValue=k}const U=i._interpolate(V,this._animationState);if(this.setValue(U,k),b.length)for(let o=0;o<b.length;o++)if(A>=0&&V>=b[o].frame&&b[o].frame>=y||A<0&&V<=b[o].frame&&b[o].frame<=y){const n=b[o];n.isDone||(n.onlyOnce&&(b.splice(o,1),o--),n.isDone=!0,n.action(V))}return q||(this._stopped=!0),q}}var q=H(11125);class b{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(n){this._weight=-1!==n?Math.min(Math.max(n,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(n){for(let y=0;y<this._runtimeAnimations.length;y++){this._runtimeAnimations[y]._prepareForSpeedRatioChange(n)}this._speedRatio=n,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(n,y){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,h=arguments.length>4&&void 0!==arguments[4]&&arguments[4],k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0,V=arguments.length>8?arguments[8]:void 0,q=arguments.length>9&&void 0!==arguments[9]&&arguments[9],b=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=y,this.fromFrame=H,this.toFrame=o,this.loopAnimation=h,this.onAnimationEnd=i,this.onAnimationLoop=V,this.isAdditive=q,this.playOrder=b,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Vi=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new G.c,this.onAnimationLoopObservable=new G.c,this._scene=n,B&&this.appendAnimations(y,B),this._speedRatio=k,n._activeAnimatables.push(this)}syncWith(n){if(this._syncRoot=n,n){const n=this._scene._activeAnimatables.indexOf(this);n>-1&&(this._scene._activeAnimatables.splice(n,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(n,y){for(let H=0;H<y.length;H++){const o=y[H],G=new V(n,o,this._scene,this);G._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(G)}}getAnimationByTargetProperty(n){const y=this._runtimeAnimations;for(let H=0;H<y.length;H++)if(y[H].animation.targetProperty===n)return y[H].animation;return null}getRuntimeAnimationByTargetProperty(n){const y=this._runtimeAnimations;for(let H=0;H<y.length;H++)if(y[H].animation.targetProperty===n)return y[H];return null}reset(){const n=this._runtimeAnimations;for(let y=0;y<n.length;y++)n[y].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(n){const y=this._runtimeAnimations;for(let H=0;H<y.length;H++)y[H].animation.enableBlending=!0,y[H].animation.blendingSpeed=n}disableBlending(){const n=this._runtimeAnimations;for(let y=0;y<n.length;y++)n[y].animation.enableBlending=!1}goToFrame(n){let y=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const H=this._runtimeAnimations;if(H[0]){const y=H[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??H[0].currentFrame;const o=0===this.speedRatio?0:(n-this._frameToSyncFromJump)/y*1e3/this.speedRatio;this._manualJumpDelay=-o}for(let o=0;o<H.length;o++)H[o].goToFrame(n,y?this._weight:-1);this._goToFrame=n}get paused(){return this.Vi}pause(){this.Vi||(this.Vi=!0)}restart(){this.Vi=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(n,y){let H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(n||y){const G=this._scene._activeAnimatables.indexOf(this);if(G>-1){const h=this._runtimeAnimations;for(let H=h.length-1;H>=0;H--){const o=h[H];n&&o.animation.name!=n||(y&&!y(o.target)||(o.dispose(),h.splice(H,1)))}0==h.length&&(H||this._scene._activeAnimatables.splice(G,1),o||this._raiseOnAnimationEnd())}}else{const n=this._scene._activeAnimatables.indexOf(this);if(n>-1){H||this._scene._activeAnimatables.splice(n,1);const y=this._runtimeAnimations;for(let n=0;n<y.length;n++)y[n].dispose();this._runtimeAnimations.length=0,o||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((n=>{this.onAnimationEndObservable.add((()=>{n(this)}),void 0,void 0,this,!0)}))}_animate(n){if(this.Vi)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=n),!0;if(null===this._localDelayOffset?(this._localDelayOffset=n,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=n-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let y=!1;const H=this._runtimeAnimations;let o;for(o=0;o<H.length;o++){const G=H[o].animate(n-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);y=y||G}if(this.animationStarted=y,!y){if(this.disposeOnEnd)for(o=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(o,1),o=0;o<H.length;o++)H[o].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return y}}function A(n){if(0===n.totalWeight&&0===n.totalAdditiveWeight)return n.originalValue;let y=1;const H=B.TmpVectors.zy[0],o=B.TmpVectors.zy[1],G=B.TmpVectors.Quaternion[0];let h=0;const k=n.animations[0],i=n.originalValue;let V=1,q=!1;if(n.totalWeight<1)V=1-n.totalWeight,i.decompose(o,G,H);else{if(h=1,y=n.totalWeight,V=k.weight/y,1==V){if(!n.totalAdditiveWeight)return k.currentValue;q=!0}k.currentValue.decompose(o,G,H)}if(!q){o.scaleInPlace(V),H.scaleInPlace(V),G.scaleInPlace(V);for(let k=h;k<n.animations.length;k++){const h=n.animations[k];if(0===h.weight)continue;V=h.weight/y;const i=B.TmpVectors.zy[2],q=B.TmpVectors.zy[3],b=B.TmpVectors.Quaternion[1];h.currentValue.decompose(q,b,i),q.scaleAndAddToRef(V,o),b.scaleAndAddToRef(B.Quaternion.Dot(G,b)>0?V:-V,G),i.scaleAndAddToRef(V,H)}G.normalize()}for(let A=0;A<n.additiveAnimations.length;A++){const y=n.additiveAnimations[A];if(0===y.weight)continue;const h=B.TmpVectors.zy[2],k=B.TmpVectors.zy[3],i=B.TmpVectors.Quaternion[1];y.currentValue.decompose(k,i,h),k.multiplyToRef(o,k),B.zy.LerpToRef(o,k,y.weight,o),G.multiplyToRef(i,i),B.Quaternion.SlerpToRef(G,i,y.weight,G),h.scaleAndAddToRef(y.weight,H)}const b=k?k._animationState.workValue:B.TmpVectors.Matrix[0].clone();return B.Matrix.ComposeToRef(o,G,H,b),b}function U(n,y){if(0===n.totalWeight&&0===n.totalAdditiveWeight)return y;const H=n.animations[0],o=n.originalValue;let G=y;if(0===n.totalWeight&&n.totalAdditiveWeight>0)G.B(o);else if(1===n.animations.length){if(B.Quaternion.SlerpToRef(o,H.currentValue,Math.min(1,n.totalWeight),G),0===n.totalAdditiveWeight)return G}else if(n.animations.length>1){let H,h,k=1;if(n.totalWeight<1){const y=1-n.totalWeight;H=[],h=[],H.push(o),h.push(y)}else{if(2===n.animations.length&&(B.Quaternion.SlerpToRef(n.animations[0].currentValue,n.animations[1].currentValue,n.animations[1].weight/n.totalWeight,y),0===n.totalAdditiveWeight))return y;H=[],h=[],k=n.totalWeight}for(let y=0;y<n.animations.length;y++){const o=n.animations[y];H.push(o.currentValue),h.push(o.weight/k)}let i=0;for(let n=0;n<H.length;)n?(i+=h[n],B.Quaternion.SlerpToRef(G,H[n],h[n]/i,G),n++):(B.Quaternion.SlerpToRef(H[n],H[n+1],h[n+1]/(h[n]+h[n+1]),y),G=y,i=h[n]+h[n+1],n+=2)}for(let h=0;h<n.additiveAnimations.length;h++){const y=n.additiveAnimations[h];0!==y.weight&&(G.multiplyToRef(y.currentValue,B.TmpVectors.Quaternion[0]),B.Quaternion.SlerpToRef(G,B.TmpVectors.Quaternion[0],y.weight,G))}return G}var T,W,z=H(11554);T=z.e,(W=i.d)&&(W.prototype.copyAnimationRange=function(n,y,H){let G=arguments.length>3&&void 0!==arguments[3]&&arguments[3],h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new o.e(this.name,"_matrix",n.animations[0].framePerSecond,o.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const k=n.animations[0].getRange(y);if(!k)return!1;const i=k.from,B=k.to,V=n.animations[0].getKeys(),q=n.length,b=n.getParent(),A=this.getParent(),U=G&&b&&q&&this.length&&q!==this.length,T=U&&A&&b?A.length/b.length:1,W=G&&!A&&h&&(1!==h.x||1!==h.y||1!==h.z),z=this.animations[0].getKeys();let Q,l,v;for(let o=0,F=V.length;o<F;o++)Q=V[o],Q.frame>=i&&Q.frame<=B&&(G?(v=Q.value.clone(),U?(l=v.getTranslation(),v.setTranslation(l.scaleInPlace(T))):W&&h?(l=v.getTranslation(),v.setTranslation(l.multiplyInPlace(h))):v=Q.value):v=Q.value,z.push({frame:Q.frame+H,value:v}));return this.animations[0].createRange(y,i+H,B+H),!0}),T&&(T.prototype._animate=function(n){if(!this.animationsEnabled)return;const y=q.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=y}this.deltaTime=void 0!==n?n:this.useConstantAnimationDeltaTime?16:(y-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=y;const H=this._activeAnimatables;if(0===H.length)return;this._animationTime+=this.deltaTime;const G=this._animationTime;for(let o=0;o<H.length;o++){const n=H[o];!n._animate(G)&&n.disposeOnEnd&&o--}!function(n){if(n._registeredForLateAnimationBindings.length){for(let y=0;y<n._registeredForLateAnimationBindings.length;y++){const H=n._registeredForLateAnimationBindings.data[y];for(const n in H._lateAnimationHolders){const y=H._lateAnimationHolders[n],G=y.animations[0],h=y.originalValue;if(void 0===h||null===h)continue;const k=o.e.AllowMatrixDecomposeForInterpolation&&h.m;let i=H[n];if(k)i=A(y);else if(void 0!==h.w)i=U(y,i||B.Quaternion.Identity());else{let n=0,H=1;const k=G&&G._animationState.loopMode===o.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(y.totalWeight<1)i=k?h.clone?h.clone():h:G&&h.scale?h.scale(1-y.totalWeight):G?h*(1-y.totalWeight):h.clone?h.clone():h;else if(G){H=y.totalWeight;const o=G.weight/H;i=1!==o?G.currentValue.scale?G.currentValue.scale(o):G.currentValue*o:G.currentValue,k&&(i.addToRef?i.addToRef(h,i):i+=h),n=1}for(let o=n;o<y.animations.length;o++){const n=y.animations[o],G=n.weight/H;G&&(n.currentValue.scaleAndAddToRef?n.currentValue.scaleAndAddToRef(G,i):i+=n.currentValue*G)}for(let o=0;o<y.additiveAnimations.length;o++){const n=y.additiveAnimations[o],H=n.weight;H&&(n.currentValue.scaleAndAddToRef?n.currentValue.scaleAndAddToRef(H,i):i+=n.currentValue*H)}}H[n]=i}H._lateAnimationHolders={}}n._registeredForLateAnimationBindings.reset()}}(this)},T.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((n,y)=>n.playOrder-y.playOrder))},T.prototype.beginWeightedAnimation=function(n,y,H){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,G=arguments.length>4?arguments[4]:void 0,h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,i=arguments.length>7?arguments[7]:void 0,B=arguments.length>8?arguments[8]:void 0,V=arguments.length>9?arguments[9]:void 0,q=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const b=this.beginAnimation(n,y,H,G,h,k,i,!1,B,V,q);return b.weight=o,b},T.prototype.beginAnimation=function(n,y,H,o){let G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,h=arguments.length>5?arguments[5]:void 0,k=arguments.length>6?arguments[6]:void 0,i=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],B=arguments.length>8?arguments[8]:void 0,V=arguments.length>9?arguments[9]:void 0,q=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(G<0){const n=y;y=H,H=n,G=-G}y>H&&(G=-G),i&&this.stopAnimation(n,void 0,B),k||(k=new b(this,n,y,H,o,G,h,void 0,V,q));const A=!B||B(n);if(n.animations&&A&&k.appendAnimations(n,n.animations),n.getAnimatables){const q=n.getAnimatables();for(let n=0;n<q.length;n++)this.beginAnimation(q[n],y,H,o,G,h,k,i,B,V)}return k.reset(),k},T.prototype.beginHierarchyAnimation=function(n,y,H,o,G){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,i=arguments.length>7?arguments[7]:void 0,B=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],V=arguments.length>9?arguments[9]:void 0,q=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const b=n.getDescendants(y),A=[];A.push(this.beginAnimation(n,H,o,G,h,k,i,B,V,void 0,q));for(const U of b)A.push(this.beginAnimation(U,H,o,G,h,k,i,B,V,void 0,q));return A},T.prototype.beginDirectAnimation=function(n,y,H,o,G){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(h<0){const n=H;H=o,o=n,h=-h}return H>o&&(h=-h),new b(this,n,H,o,G,h,arguments.length>6?arguments[6]:void 0,y,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},T.prototype.beginDirectHierarchyAnimation=function(n,y,H,o,G,h,k,i,B){let V=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const q=n.getDescendants(y),b=[];b.push(this.beginDirectAnimation(n,H,o,G,h,k,i,B,V));for(const A of q)b.push(this.beginDirectAnimation(A,H,o,G,h,k,i,B,V));return b},T.prototype.getAnimatableByTarget=function(n){for(let y=0;y<this._activeAnimatables.length;y++)if(this._activeAnimatables[y].target===n)return this._activeAnimatables[y];return null},T.prototype.getAllAnimatablesByTarget=function(n){const y=[];for(let H=0;H<this._activeAnimatables.length;H++)this._activeAnimatables[H].target===n&&y.push(this._activeAnimatables[H]);return y},T.prototype.stopAnimation=function(n,y,H){const o=this.getAllAnimatablesByTarget(n);for(const G of o)G.stop(y,H)},T.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let n=0;n<this._activeAnimatables.length;n++)this._activeAnimatables[n].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const n of this.animationGroups)n.stop()});class Q{getClassName(){return"TargetedAnimation"}serialize(){const n={};return n.animation=this.animation.serialize(),n.targetId=this.target.id,n}}class l{get mask(){return this._mask}set mask(n){this._mask!==n&&(this._mask=n,this.syncWithMask(!0))}syncWithMask(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||n){this._numActiveAnimatables=0;for(let n=0;n<this._animatables.length;++n){const y=this._animatables[n];!this.mask||this.mask.disabled||this.mask.retainsTarget(y.target.name)?(this._numActiveAnimatables++,y.paused&&y.restart()):y.paused||y.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let n=0;n<this._animatables.length;++n){const y=this._animatables[n];this.mask.retainsTarget(y.target.name)||(y.stop(),this._animatables.splice(n,1),--n)}for(let n=0;n<this._targetedAnimations.length;n++){const y=this._targetedAnimations[n];this.mask.retainsTarget(y.target.name)||(this._targetedAnimations.splice(n,1),--n)}}}get from(){return this._from}set from(n){if(this._from!==n){this._from=n;for(let n=0;n<this._animatables.length;n++){this._animatables[n].fromFrame=this._from}}}get to(){return this._to}set to(n){if(this._to!==n){this._to=n;for(let n=0;n<this._animatables.length;n++){this._animatables[n].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(n){if(this._speedRatio!==n){this._speedRatio=n;for(let n=0;n<this._animatables.length;n++){this._animatables[n].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(n){if(this._loopAnimation!==n){this._loopAnimation=n;for(let n=0;n<this._animatables.length;n++){this._animatables[n].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(n){if(this._isAdditive!==n){this._isAdditive=n;for(let n=0;n<this._animatables.length;n++){this._animatables[n].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(n){this._weight!==n&&(this._weight=n,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(n){if(this._playOrder!==n&&(this._playOrder=n,this._animatables.length>0)){for(let n=0;n<this._animatables.length;n++)this._animatables[n].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(n){if(this._enableBlending!==n&&(this._enableBlending=n,null!==n))for(let y=0;y<this._targetedAnimations.length;++y)this._targetedAnimations[y].animation.enableBlending=n}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(n){if(this._blendingSpeed!==n&&(this._blendingSpeed=n,null!==n))for(let y=0;y<this._targetedAnimations.length;++y)this._targetedAnimations[y].animation.blendingSpeed=n}getLength(n,y){n=n??this._from;return((y=y??this._to)-n)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(n){let y=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3?arguments[3]:void 0;if(0===n.length)return null;o=o??n[0].weight;let G=Number.MAX_VALUE,h=-Number.MAX_VALUE;if(H)for(const i of n)i.from<G&&(G=i.from),i.to>h&&(h=i.to);const k=new l(n[0].name+"_merged",n[0]._scene,o);for(const i of n){H&&i.normalize(G,h);for(const n of i.targetedAnimations)k.addTargetedAnimation(n.animation,n.target);y&&i.dispose()}return k}constructor(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=n,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new G.c,this.onAnimationLoopObservable=new G.c,this.onAnimationGroupLoopObservable=new G.c,this.onAnimationGroupEndObservable=new G.c,this.onAnimationGroupPauseObservable=new G.c,this.onAnimationGroupPlayObservable=new G.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=y||h.c.LastCreatedScene,this._weight=H,this._playOrder=o,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(n,y){const H=new Q;H.animation=n,H.target=y;const o=n.getKeys();return this._from>o[0].frame&&(this._from=o[0].frame),this._to<o[o.length-1].frame&&(this._to=o[o.length-1].frame),null!==this._enableBlending&&(n.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(n.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(H),this._shouldStart=!0,H}removeTargetedAnimation(n){for(let y=this._targetedAnimations.length-1;y>-1;y--){this._targetedAnimations[y].animation===n&&this._targetedAnimations.splice(y,1)}}normalize(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==n&&(n=this._from),null==y&&(y=this._to);for(let H=0;H<this._targetedAnimations.length;H++){const o=this._targetedAnimations[H].animation.getKeys(),G=o[0],h=o[o.length-1];if(G.frame>n){const y={frame:n,value:G.value,inTangent:G.inTangent,outTangent:G.outTangent,interpolation:G.interpolation};o.splice(0,0,y)}if(h.frame<y){const n={frame:y,value:h.value,inTangent:h.inTangent,outTangent:h.outTangent,interpolation:h.interpolation};o.push(n)}}return this._from=n,this._to=y,this}_processLoop(n,y,H){n.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(y),this._animationLoopFlags[H]||(this._animationLoopFlags[H]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0],y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0,o=arguments.length>3?arguments[3]:void 0,G=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=n,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let h=0;h<this._targetedAnimations.length;h++){const k=this._targetedAnimations[h],i=this._scene.beginDirectAnimation(k.target,[k.animation],void 0!==H?H:this._from,void 0!==o?o:this._to,n,y,void 0,void 0,void 0!==G?G:this._isAdditive);i.weight=this._weight,i.playOrder=this._playOrder,i.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(k),this._checkAnimationGroupEnded(i)},this._processLoop(i,k,h),this._animatables.push(i)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=y,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let n=0;n<this._animatables.length;n++){this._animatables[n].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(n){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==n&&(this.loopAnimation=n),this.restart()):(this.stop(),this.start(n,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let n=0;n<this._animatables.length;n++){this._animatables[n].reset()}return this}restart(){if(!this._isStarted)return this;for(let n=0;n<this._animatables.length;n++){this._animatables[n].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const y=this._animatables.slice();for(let o=0;o<y.length;o++)y[o].stop(void 0,void 0,!0,n);let H=0;for(let o=0;o<this._scene._activeAnimatables.length;o++){const y=this._scene._activeAnimatables[o];y._runtimeAnimations.length>0?this._scene._activeAnimatables[H++]=y:n&&this._checkAnimationGroupEnded(y,n)}return this._scene._activeAnimatables.length=H,this._isStarted=!1,this}setWeightForAllAnimatables(n){for(let y=0;y<this._animatables.length;y++){this._animatables[y].weight=n}return this}syncAllAnimationsWith(n){for(let y=0;y<this._animatables.length;y++){this._animatables[y].syncWith(n)}return this}goToFrame(n){let y=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].goToFrame(n,y)}return this}getCurrentFrame(){var n;return(null===(n=this.animatables[0])||void 0===n?void 0:n.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const n=this._scene.animationGroups.indexOf(this);if(n>-1&&this._scene.animationGroups.splice(n,1),this._parentContainer){const n=this._parentContainer.animationGroups.indexOf(this);n>-1&&this._parentContainer.animationGroups.splice(n,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(n){let y=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const H=this._animatables.indexOf(n);H>-1&&this._animatables.splice(H,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,y||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(n,y){let H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=new l(n||this.name,this._scene,this._weight,this._playOrder);o._from=this.from,o._to=this.to,o._speedRatio=this.speedRatio,o._loopAnimation=this.loopAnimation,o._isAdditive=this.isAdditive,o._enableBlending=this.enableBlending,o._blendingSpeed=this.blendingSpeed,o.metadata=this.metadata,o.mask=this.mask;for(const G of this._targetedAnimations)o.addTargetedAnimation(H?G.animation.clone():G.animation,y?y(G.target):G.target);return o}serialize(){const n={};n.name=this.name,n.from=this.from,n.to=this.to,n.speedRatio=this.speedRatio,n.loopAnimation=this.loopAnimation,n.isAdditive=this.isAdditive,n.weight=this.weight,n.playOrder=this.playOrder,n.enableBlending=this.enableBlending,n.blendingSpeed=this.blendingSpeed,n.targetedAnimations=[];for(let y=0;y<this.targetedAnimations.length;y++){const H=this.targetedAnimations[y];n.targetedAnimations[y]=H.serialize()}return k.d&&k.d.HasTags(this)&&(n.tags=k.d.GetTags(this)),this.metadata&&(n.metadata=this.metadata),n}static Parse(n,y){const H=new l(n.name,y,n.weight,n.playOrder);for(let G=0;G<n.targetedAnimations.length;G++){const h=n.targetedAnimations[G],k=o.e.Parse(h.animation),i=h.targetId;if("influence"===h.animation.property){const n=y.getMorphTargetById(i);n&&H.addTargetedAnimation(k,n)}else{const n=y.getNodeById(i);null!=n&&H.addTargetedAnimation(k,n)}}return k.d&&k.d.AddTagsTo(H,n.tags),null!==n.from&&null!==n.to&&H.normalize(n.from,n.to),void 0!==n.speedRatio&&(H._speedRatio=n.speedRatio),void 0!==n.loopAnimation&&(H._loopAnimation=n.loopAnimation),void 0!==n.isAdditive&&(H._isAdditive=n.isAdditive),void 0!==n.weight&&(H._weight=n.weight),void 0!==n.playOrder&&(H._playOrder=n.playOrder),void 0!==n.enableBlending&&(H._enableBlending=n.enableBlending),void 0!==n.blendingSpeed&&(H._blendingSpeed=n.blendingSpeed),void 0!==n.metadata&&(H.metadata=n.metadata),H}static MakeAnimationAdditive(n,y,H){let G;G="object"===typeof y?y:{referenceFrame:y,range:H,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let h=n;G.cloneOriginalAnimationGroup&&(h=n.clone(G.clonedAnimationGroupName||h.name));const k=h.targetedAnimations;for(let i=0;i<k.length;i++){const n=k[i];n.animation=o.e.MakeAnimationAdditive(n.animation,G)}if(h.isAdditive=!0,G.clipKeys){let n=Number.MAX_VALUE,y=-Number.MAX_VALUE;const H=h.targetedAnimations;for(let o=0;o<H.length;o++){const G=H[o].animation.getKeys();n>G[0].frame&&(n=G[0].frame),y<G[G.length-1].frame&&(y=G[G.length-1].frame)}h._from=n,h._to=y}return h}static ClipKeys(n,y,H,o,G){const h=n.clone(o||n.name);return l.ClipKeysInPlace(h,y,H,G)}static ClipKeysInPlace(n,y,H,o){return l.ClipInPlace(n,y,H,o,!1)}static ClipFrames(n,y,H,o,G){const h=n.clone(o||n.name);return l.ClipFramesInPlace(h,y,H,G)}static ClipFramesInPlace(n,y,H,o){return l.ClipInPlace(n,y,H,o,!0)}static ClipInPlace(n,y,H,o){let G=arguments.length>4&&void 0!==arguments[4]&&arguments[4],h=Number.MAX_VALUE,k=-Number.MAX_VALUE;const i=n.targetedAnimations;for(let B=0;B<i.length;B++){const n=i[B],V=o?n.animation:n.animation.clone();G&&(V.createKeyForFrame(y),V.createKeyForFrame(H));const q=V.getKeys(),b=[];let A=Number.MAX_VALUE;for(let o=0;o<q.length;o++){const n=q[o];if(!G&&o>=y&&o<=H||G&&n.frame>=y&&n.frame<=H){const y={frame:n.frame,value:n.value.clone?n.value.clone():n.value,inTangent:n.inTangent,outTangent:n.outTangent,interpolation:n.interpolation,lockedTangent:n.lockedTangent};A===Number.MAX_VALUE&&(A=y.frame),y.frame-=A,b.push(y)}}0!==b.length?(h>b[0].frame&&(h=b[0].frame),k<b[b.length-1].frame&&(k=b[b.length-1].frame),V.setKeys(b,!0),n.animation=V):(i.splice(B,1),B--)}return n._from=h,n._to=k,n}getClassName(){return"AnimationGroup"}toString(n){let y="Name: "+this.name;return y+=", type: "+this.getClassName(),n&&(y+=", from: "+this._from,y+=", to: "+this._to,y+=", isStarted: "+this._isStarted,y+=", speedRatio: "+this._speedRatio,y+=", targetedAnimations length: "+this._targetedAnimations.length,y+=", animatables length: "+this._animatables),y}}}}]);