"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[78],{15827:(K,A,T)=>{T.r(A),T.d(A,{AnimationGroup:()=>N,TargetedAnimation:()=>d});var G=T(13226),B=T(12534),L=T(12565),f=T(12736),O=T(14152),C=T(12700);class Q{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(K,A,T,B){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=A,this._target=K,this._scene=T,this._host=B,this._activeTargets=[],A._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===G.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=C.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const K={frame:0,value:this._minValue};this._keys.splice(0,0,K)}if(this._target instanceof Array){let K=0;for(const A of this._target)this._preparePath(A,K),this._getOriginalValues(K),K++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const L=A.getEvents();if(L&&L.length>0)for(const G of L)this._events.push(G._clone());this._enableBlending=K&&K.animationPropertiesOverride?K.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const T=this._animation.targetPropertyPath;if(T.length>1){let G=K;for(let K=0;K<T.length-1;K++){const A=T[K];if(G=G[A],void 0===G)throw new Error(`Invalid property (${A}) in property path (${T.join(".")})`)}this._targetPath=T[T.length-1],this._activeTargets[A]=G}else this._targetPath=T[0],this._activeTargets[A]=K;if(void 0===this._activeTargets[A][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${T.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let K=0;for(const A of this._target)void 0!==this._originalValue[K]&&this._setValue(A,this._activeTargets[K],this._originalValue[K],-1,K),K++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let K=0;K<this._events.length;K++)this._events[K].isDone=!1}isStopped(){return this._stopped}dispose(){const K=this._animation.runtimeAnimations.indexOf(this);K>-1&&this._animation.runtimeAnimations.splice(K,1)}setValue(K,A){if(this._targetIsArray)for(let T=0;T<this._target.length;T++){const G=this._target[T];this._setValue(G,this._activeTargets[T],K,A,T)}else this._setValue(this._target,this._directTarget,K,A,0)}_getOriginalValues(){let K,A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const T=this._activeTargets[A];K=T.getLocalMatrix&&"_matrix"===this._targetPath?T.getLocalMatrix():T[this._targetPath],K&&K.clone?this._originalValue[A]=K.clone():this._originalValue[A]=K}_registerTargetForLateAnimationBinding(K,A){const T=K.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(T),T._lateAnimationHolders||(T._lateAnimationHolders={}),T._lateAnimationHolders[K.targetPath]||(T._lateAnimationHolders[K.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:A}),K.isAdditive?(T._lateAnimationHolders[K.targetPath].additiveAnimations.push(K),T._lateAnimationHolders[K.targetPath].totalAdditiveWeight+=K.weight):(T._lateAnimationHolders[K.targetPath].animations.push(K),T._lateAnimationHolders[K.targetPath].totalWeight+=K.weight)}_setValue(K,A,T,B,L){if(this._currentActiveTarget=A,this._weight=B,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const K=A[this._targetPath];K.clone?this._originalBlendValue=K.clone():this._originalBlendValue=K}this._originalBlendValue.m?G.b.AllowMatrixDecomposeForInterpolation?this._currentValue?C.Matrix.DecomposeLerpToRef(this._originalBlendValue,T,this._blendingFactor,this._currentValue):this._currentValue=C.Matrix.DecomposeLerp(this._originalBlendValue,T,this._blendingFactor):this._currentValue?C.Matrix.LerpToRef(this._originalBlendValue,T,this._blendingFactor,this._currentValue):this._currentValue=C.Matrix.Lerp(this._originalBlendValue,T,this._blendingFactor):this._currentValue=G.b._UniversalLerp(this._originalBlendValue,T,this._blendingFactor);const B=K&&K.animationPropertiesOverride?K.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=B}else this._currentValue?this._currentValue.G?this._currentValue.G(T):this._currentValue=T:null!==T&&void 0!==T&&T.clone?this._currentValue=T.clone():this._currentValue=T;-1!==B?this._registerTargetForLateAnimationBinding(this,this._originalValue[L]):this._animationState.loopMode===G.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[L],A[this._targetPath]):A[this._targetPath]=this._originalValue[L]+this._currentValue:A[this._targetPath]=this._currentValue,K.fY&&K.fY(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const T=this._animation.getKeys();K<T[0].frame?K=T[0].frame:K>T[T.length-1].frame&&(K=T[T.length-1].frame);const G=this._events;if(G.length)for(let L=0;L<G.length;L++)G[L].onlyOnce||(G[L].isDone=G[L].frame<K);this._currentFrame=K;const B=this._animation._interpolate(K,this._animationState);this.setValue(B,A)}_prepareForSpeedRatioChange(K){const A=this._previousElapsedTime*(this._animation.framePerSecond*K)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-A}animate(K,A,T,B,L){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const O=this._animation,C=O.targetPropertyPath;if(!C||C.length<1)return this._stopped=!0,!1;let Q,Y=!0;const Z=this._events;let x=0;if(this._coreRuntimeAnimation)x=T-A,Q=this._coreRuntimeAnimation.currentFrame,this._currentFrame=Q,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let f;(A<this._minFrame||A>this._maxFrame)&&(A=this._minFrame),(T<this._minFrame||T>this._maxFrame)&&(T=this._maxFrame),x=T-A;let C=K*(O.framePerSecond*L)/1e3+this._absoluteFrameOffset,J=0,b=!1;const P=B&&this._animationState.loopMode===G.b.ANIMATIONLOOPMODE_YOYO;if(P){const K=(C-A)/x,T=Math.sin(K*Math.PI);C=Math.abs(T)*x+A;const G=T>=0?1:-1;this._yoyoDirection!==G&&(b=!0),this._yoyoDirection=G}if(this._previousElapsedTime=K,this._previousAbsoluteFrame=C,!B&&T>=A&&(C>=x&&L>0||C<=0&&L<0))Y=!1,J=O._getKeyValue(this._maxValue);else if(!B&&A>=T&&(C<=x&&L<0||C>=0&&L>0))Y=!1,J=O._getKeyValue(this._minValue);else if(this._animationState.loopMode!==G.b.ANIMATIONLOOPMODE_CYCLE){const K=T.toString()+A.toString();if(!this._offsetsCache[K]){this._animationState.repeatCount=0,this._animationState.loopMode=G.b.ANIMATIONLOOPMODE_CYCLE;const B=O._interpolate(A,this._animationState),L=O._interpolate(T,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),O.dataType){case G.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[K]=L-B;break;case G.b.ANIMATIONTYPE_QUATERNION:case G.b.ANIMATIONTYPE_VECTOR3:case G.b.ANIMATIONTYPE_VECTOR2:case G.b.ANIMATIONTYPE_SIZE:case G.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[K]=L.FA(B)}this._highLimitsCache[K]=L}J=this._highLimitsCache[K],f=this._offsetsCache[K]}if(void 0===f)switch(O.dataType){case G.b.ANIMATIONTYPE_FLOAT:f=0;break;case G.b.ANIMATIONTYPE_QUATERNION:f=G.k;break;case G.b.ANIMATIONTYPE_VECTOR3:f=G.t;break;case G.b.ANIMATIONTYPE_VECTOR2:f=G.p;break;case G.b.ANIMATIONTYPE_SIZE:f=G.n;break;case G.b.ANIMATIONTYPE_COLOR3:f=G.d;break;case G.b.ANIMATIONTYPE_COLOR4:f=G.g}if(this._host&&this._host.syncRoot){const K=this._host.syncRoot;Q=A+x*((K.masterFrame-K.fromFrame)/(K.toFrame-K.fromFrame))}else Q=C>0&&A>T||C<0&&A<T?Y&&0!==x?T+C%x:A:Y&&0!==x?A+C%x:T;if(!P&&(L>0&&this.currentFrame>Q||L<0&&this.currentFrame<Q)||P&&b){this._onLoop();for(let K=0;K<Z.length;K++)Z[K].onlyOnce||(Z[K].isDone=!1);this._animationState.key=L>0?0:O.getKeys().length-1}this._currentFrame=Q,this._animationState.repeatCount=0===x?0:C/x|0,this._animationState.highLimitValue=J,this._animationState.offsetValue=f}const J=O._interpolate(Q,this._animationState);if(this.setValue(J,f),Z.length)for(let G=0;G<Z.length;G++)if(x>=0&&Q>=Z[G].frame&&Z[G].frame>=A||x<0&&Q<=Z[G].frame&&Z[G].frame<=A){const K=Z[G];K.isDone||(K.onlyOnce&&(Z.splice(G,1),G--),K.isDone=!0,K.action(Q))}return Y||(this._stopped=!0),Y}}var Y=T(12553);class Z{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(K){this._weight=-1!==K?Math.min(Math.max(K,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(K){for(let A=0;A<this._runtimeAnimations.length;A++){this._runtimeAnimations[A]._prepareForSpeedRatioChange(K)}this._speedRatio=K,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(K,A){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,L=arguments.length>4&&void 0!==arguments[4]&&arguments[4],f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,O=arguments.length>6?arguments[6]:void 0,C=arguments.length>7?arguments[7]:void 0,Q=arguments.length>8?arguments[8]:void 0,Y=arguments.length>9&&void 0!==arguments[9]&&arguments[9],Z=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=A,this.fromFrame=T,this.toFrame=G,this.loopAnimation=L,this.onAnimationEnd=O,this.onAnimationLoop=Q,this.isAdditive=Y,this.playOrder=Z,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.hO=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new B.e,this.onAnimationLoopObservable=new B.e,this._scene=K,C&&this.appendAnimations(A,C),this._speedRatio=f,K._activeAnimatables.push(this)}syncWith(K){if(this._syncRoot=K,K){const K=this._scene._activeAnimatables.indexOf(this);K>-1&&(this._scene._activeAnimatables.splice(K,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(K,A){for(let T=0;T<A.length;T++){const G=A[T],B=new Q(K,G,this._scene,this);B._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(B)}}getAnimationByTargetProperty(K){const A=this._runtimeAnimations;for(let T=0;T<A.length;T++)if(A[T].animation.targetProperty===K)return A[T].animation;return null}getRuntimeAnimationByTargetProperty(K){const A=this._runtimeAnimations;for(let T=0;T<A.length;T++)if(A[T].animation.targetProperty===K)return A[T];return null}reset(){const K=this._runtimeAnimations;for(let A=0;A<K.length;A++)K[A].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(K){const A=this._runtimeAnimations;for(let T=0;T<A.length;T++)A[T].animation.enableBlending=!0,A[T].animation.blendingSpeed=K}disableBlending(){const K=this._runtimeAnimations;for(let A=0;A<K.length;A++)K[A].animation.enableBlending=!1}goToFrame(K){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const T=this._runtimeAnimations;if(T[0]){const A=T[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??T[0].currentFrame;const G=0===this.speedRatio?0:(K-this._frameToSyncFromJump)/A*1e3/this.speedRatio;this._manualJumpDelay=-G}for(let G=0;G<T.length;G++)T[G].goToFrame(K,A?this._weight:-1);this._goToFrame=K}get paused(){return this.hO}pause(){this.hO||(this.hO=!0)}restart(){this.hO=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(K,A){let T=arguments.length>2&&void 0!==arguments[2]&&arguments[2],G=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(K||A){const B=this._scene._activeAnimatables.indexOf(this);if(B>-1){const L=this._runtimeAnimations;for(let T=L.length-1;T>=0;T--){const G=L[T];K&&G.animation.name!=K||(A&&!A(G.target)||(G.dispose(),L.splice(T,1)))}0==L.length&&(T||this._scene._activeAnimatables.splice(B,1),G||this._raiseOnAnimationEnd())}}else{const K=this._scene._activeAnimatables.indexOf(this);if(K>-1){T||this._scene._activeAnimatables.splice(K,1);const A=this._runtimeAnimations;for(let K=0;K<A.length;K++)A[K].dispose();this._runtimeAnimations.length=0,G||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((K=>{this.onAnimationEndObservable.add((()=>{K(this)}),void 0,void 0,this,!0)}))}_animate(K){if(this.hO)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=K),!0;if(null===this._localDelayOffset?(this._localDelayOffset=K,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=K-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let A=!1;const T=this._runtimeAnimations;let G;for(G=0;G<T.length;G++){const B=T[G].animate(K-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);A=A||B}if(this.animationStarted=A,!A){if(this.disposeOnEnd)for(G=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(G,1),G=0;G<T.length;G++)T[G].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return A}}function x(K){if(0===K.totalWeight&&0===K.totalAdditiveWeight)return K.originalValue;let A=1;const T=C.TmpVectors.PA[0],G=C.TmpVectors.PA[1],B=C.TmpVectors.Quaternion[0];let L=0;const f=K.animations[0],O=K.originalValue;let Q=1,Y=!1;if(K.totalWeight<1)Q=1-K.totalWeight,O.decompose(G,B,T);else{if(L=1,A=K.totalWeight,Q=f.weight/A,1==Q){if(!K.totalAdditiveWeight)return f.currentValue;Y=!0}f.currentValue.decompose(G,B,T)}if(!Y){G.scaleInPlace(Q),T.scaleInPlace(Q),B.scaleInPlace(Q);for(let f=L;f<K.animations.length;f++){const L=K.animations[f];if(0===L.weight)continue;Q=L.weight/A;const O=C.TmpVectors.PA[2],Y=C.TmpVectors.PA[3],Z=C.TmpVectors.Quaternion[1];L.currentValue.decompose(Y,Z,O),Y.scaleAndAddToRef(Q,G),Z.scaleAndAddToRef(C.Quaternion.Dot(B,Z)>0?Q:-Q,B),O.scaleAndAddToRef(Q,T)}B.normalize()}for(let x=0;x<K.additiveAnimations.length;x++){const A=K.additiveAnimations[x];if(0===A.weight)continue;const L=C.TmpVectors.PA[2],f=C.TmpVectors.PA[3],O=C.TmpVectors.Quaternion[1];A.currentValue.decompose(f,O,L),f.multiplyToRef(G,f),C.PA.LerpToRef(G,f,A.weight,G),B.multiplyToRef(O,O),C.Quaternion.SlerpToRef(B,O,A.weight,B),L.scaleAndAddToRef(A.weight,T)}const Z=f?f._animationState.workValue:C.TmpVectors.Matrix[0].clone();return C.Matrix.ComposeToRef(G,B,T,Z),Z}function J(K,A){if(0===K.totalWeight&&0===K.totalAdditiveWeight)return A;const T=K.animations[0],G=K.originalValue;let B=A;if(0===K.totalWeight&&K.totalAdditiveWeight>0)B.G(G);else if(1===K.animations.length){if(C.Quaternion.SlerpToRef(G,T.currentValue,Math.min(1,K.totalWeight),B),0===K.totalAdditiveWeight)return B}else if(K.animations.length>1){let T,L,f=1;if(K.totalWeight<1){const A=1-K.totalWeight;T=[],L=[],T.push(G),L.push(A)}else{if(2===K.animations.length&&(C.Quaternion.SlerpToRef(K.animations[0].currentValue,K.animations[1].currentValue,K.animations[1].weight/K.totalWeight,A),0===K.totalAdditiveWeight))return A;T=[],L=[],f=K.totalWeight}for(let A=0;A<K.animations.length;A++){const G=K.animations[A];T.push(G.currentValue),L.push(G.weight/f)}let O=0;for(let K=0;K<T.length;)K?(O+=L[K],C.Quaternion.SlerpToRef(B,T[K],L[K]/O,B),K++):(C.Quaternion.SlerpToRef(T[K],T[K+1],L[K+1]/(L[K]+L[K+1]),A),B=A,O=L[K]+L[K+1],K+=2)}for(let L=0;L<K.additiveAnimations.length;L++){const A=K.additiveAnimations[L];0!==A.weight&&(B.multiplyToRef(A.currentValue,C.TmpVectors.Quaternion[0]),C.Quaternion.SlerpToRef(B,C.TmpVectors.Quaternion[0],A.weight,B))}return B}var b,P,F=T(12931);b=F.c,(P=O.b)&&(P.prototype.copyAnimationRange=function(K,A,T){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3],L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new G.b(this.name,"_matrix",K.animations[0].framePerSecond,G.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const f=K.animations[0].getRange(A);if(!f)return!1;const O=f.from,C=f.to,Q=K.animations[0].getKeys(),Y=K.length,Z=K.getParent(),x=this.getParent(),J=B&&Z&&Y&&this.length&&Y!==this.length,b=J&&x&&Z?x.length/Z.length:1,P=B&&!x&&L&&(1!==L.x||1!==L.y||1!==L.z),F=this.animations[0].getKeys();let d,N,D;for(let G=0,mK=Q.length;G<mK;G++)d=Q[G],d.frame>=O&&d.frame<=C&&(B?(D=d.value.clone(),J?(N=D.getTranslation(),D.setTranslation(N.scaleInPlace(b))):P&&L?(N=D.getTranslation(),D.setTranslation(N.multiplyInPlace(L))):D=d.value):D=d.value,F.push({frame:d.frame+T,value:D}));return this.animations[0].createRange(A,O+T,C+T),!0}),b&&(b.prototype._animate=function(K){if(!this.animationsEnabled)return;const A=Y.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=A}this.deltaTime=void 0!==K?K:this.useConstantAnimationDeltaTime?16:(A-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=A;const T=this._activeAnimatables;if(0===T.length)return;this._animationTime+=this.deltaTime;const B=this._animationTime;for(let G=0;G<T.length;G++){const K=T[G];!K._animate(B)&&K.disposeOnEnd&&G--}!function(K){if(K._registeredForLateAnimationBindings.length){for(let A=0;A<K._registeredForLateAnimationBindings.length;A++){const T=K._registeredForLateAnimationBindings.data[A];for(const K in T._lateAnimationHolders){const A=T._lateAnimationHolders[K],B=A.animations[0],L=A.originalValue;if(void 0===L||null===L)continue;const f=G.b.AllowMatrixDecomposeForInterpolation&&L.m;let O=T[K];if(f)O=x(A);else if(void 0!==L.w)O=J(A,O||C.Quaternion.Identity());else{let K=0,T=1;const f=B&&B._animationState.loopMode===G.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(A.totalWeight<1)O=f?L.clone?L.clone():L:B&&L.scale?L.scale(1-A.totalWeight):B?L*(1-A.totalWeight):L.clone?L.clone():L;else if(B){T=A.totalWeight;const G=B.weight/T;O=1!==G?B.currentValue.scale?B.currentValue.scale(G):B.currentValue*G:B.currentValue,f&&(O.addToRef?O.addToRef(L,O):O+=L),K=1}for(let G=K;G<A.animations.length;G++){const K=A.animations[G],B=K.weight/T;B&&(K.currentValue.scaleAndAddToRef?K.currentValue.scaleAndAddToRef(B,O):O+=K.currentValue*B)}for(let G=0;G<A.additiveAnimations.length;G++){const K=A.additiveAnimations[G],T=K.weight;T&&(K.currentValue.scaleAndAddToRef?K.currentValue.scaleAndAddToRef(T,O):O+=K.currentValue*T)}}T[K]=O}T._lateAnimationHolders={}}K._registeredForLateAnimationBindings.reset()}}(this)},b.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((K,A)=>K.playOrder-A.playOrder))},b.prototype.beginWeightedAnimation=function(K,A,T){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,B=arguments.length>4?arguments[4]:void 0,L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,Q=arguments.length>9?arguments[9]:void 0,Y=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const Z=this.beginAnimation(K,A,T,B,L,f,O,!1,C,Q,Y);return Z.weight=G,Z},b.prototype.beginAnimation=function(K,A,T,G){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,L=arguments.length>5?arguments[5]:void 0,f=arguments.length>6?arguments[6]:void 0,O=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],C=arguments.length>8?arguments[8]:void 0,Q=arguments.length>9?arguments[9]:void 0,Y=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(B<0){const K=A;A=T,T=K,B=-B}A>T&&(B=-B),O&&this.stopAnimation(K,void 0,C),f||(f=new Z(this,K,A,T,G,B,L,void 0,Q,Y));const x=!C||C(K);if(K.animations&&x&&f.appendAnimations(K,K.animations),K.getAnimatables){const Y=K.getAnimatables();for(let K=0;K<Y.length;K++)this.beginAnimation(Y[K],A,T,G,B,L,f,O,C,Q)}return f.reset(),f},b.prototype.beginHierarchyAnimation=function(K,A,T,G,B){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,C=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],Q=arguments.length>9?arguments[9]:void 0,Y=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const Z=K.getDescendants(A),x=[];x.push(this.beginAnimation(K,T,G,B,L,f,O,C,Q,void 0,Y));for(const J of Z)x.push(this.beginAnimation(J,T,G,B,L,f,O,C,Q,void 0,Y));return x},b.prototype.beginDirectAnimation=function(K,A,T,G,B){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(L<0){const K=T;T=G,G=K,L=-L}return T>G&&(L=-L),new Z(this,K,T,G,B,L,arguments.length>6?arguments[6]:void 0,A,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},b.prototype.beginDirectHierarchyAnimation=function(K,A,T,G,B,L,f,O,C){let Q=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const Y=K.getDescendants(A),Z=[];Z.push(this.beginDirectAnimation(K,T,G,B,L,f,O,C,Q));for(const x of Y)Z.push(this.beginDirectAnimation(x,T,G,B,L,f,O,C,Q));return Z},b.prototype.getAnimatableByTarget=function(K){for(let A=0;A<this._activeAnimatables.length;A++)if(this._activeAnimatables[A].target===K)return this._activeAnimatables[A];return null},b.prototype.getAllAnimatablesByTarget=function(K){const A=[];for(let T=0;T<this._activeAnimatables.length;T++)this._activeAnimatables[T].target===K&&A.push(this._activeAnimatables[T]);return A},b.prototype.stopAnimation=function(K,A,T){const G=this.getAllAnimatablesByTarget(K);for(const B of G)B.stop(A,T)},b.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let K=0;K<this._activeAnimatables.length;K++)this._activeAnimatables[K].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const K of this.animationGroups)K.stop()});class d{getClassName(){return"TargetedAnimation"}serialize(){const K={};return K.animation=this.animation.serialize(),K.targetId=this.target.id,K}}class N{get mask(){return this._mask}set mask(K){this._mask!==K&&(this._mask=K,this.syncWithMask(!0))}syncWithMask(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||K){this._numActiveAnimatables=0;for(let K=0;K<this._animatables.length;++K){const A=this._animatables[K];!this.mask||this.mask.disabled||this.mask.retainsTarget(A.target.name)?(this._numActiveAnimatables++,A.paused&&A.restart()):A.paused||A.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let K=0;K<this._animatables.length;++K){const A=this._animatables[K];this.mask.retainsTarget(A.target.name)||(A.stop(),this._animatables.splice(K,1),--K)}for(let K=0;K<this._targetedAnimations.length;K++){const A=this._targetedAnimations[K];this.mask.retainsTarget(A.target.name)||(this._targetedAnimations.splice(K,1),--K)}}}get from(){return this._from}set from(K){if(this._from!==K){this._from=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].fromFrame=this._from}}}get to(){return this._to}set to(K){if(this._to!==K){this._to=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(K){if(this._speedRatio!==K){this._speedRatio=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(K){if(this._loopAnimation!==K){this._loopAnimation=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(K){if(this._isAdditive!==K){this._isAdditive=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(K){this._weight!==K&&(this._weight=K,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(K){if(this._playOrder!==K&&(this._playOrder=K,this._animatables.length>0)){for(let K=0;K<this._animatables.length;K++)this._animatables[K].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(K){if(this._enableBlending!==K&&(this._enableBlending=K,null!==K))for(let A=0;A<this._targetedAnimations.length;++A)this._targetedAnimations[A].animation.enableBlending=K}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(K){if(this._blendingSpeed!==K&&(this._blendingSpeed=K,null!==K))for(let A=0;A<this._targetedAnimations.length;++A)this._targetedAnimations[A].animation.blendingSpeed=K}getLength(K,A){K=K??this._from;return((A=A??this._to)-K)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(K){let A=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],T=arguments.length>2&&void 0!==arguments[2]&&arguments[2],G=arguments.length>3?arguments[3]:void 0;if(0===K.length)return null;G=G??K[0].weight;let B=Number.MAX_VALUE,L=-Number.MAX_VALUE;if(T)for(const O of K)O.from<B&&(B=O.from),O.to>L&&(L=O.to);const f=new N(K[0].name+"_merged",K[0]._scene,G);for(const O of K){T&&O.normalize(B,L);for(const K of O.targetedAnimations)f.addTargetedAnimation(K.animation,K.target);A&&O.dispose()}return f}constructor(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=K,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new B.e,this.onAnimationLoopObservable=new B.e,this.onAnimationGroupLoopObservable=new B.e,this.onAnimationGroupEndObservable=new B.e,this.onAnimationGroupPauseObservable=new B.e,this.onAnimationGroupPlayObservable=new B.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=A||L.b.LastCreatedScene,this._weight=T,this._playOrder=G,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(K,A){const T=new d;T.animation=K,T.target=A;const G=K.getKeys();return this._from>G[0].frame&&(this._from=G[0].frame),this._to<G[G.length-1].frame&&(this._to=G[G.length-1].frame),null!==this._enableBlending&&(K.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(K.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(T),this._shouldStart=!0,T}removeTargetedAnimation(K){for(let A=this._targetedAnimations.length-1;A>-1;A--){this._targetedAnimations[A].animation===K&&this._targetedAnimations.splice(A,1)}}normalize(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==K&&(K=this._from),null==A&&(A=this._to);for(let T=0;T<this._targetedAnimations.length;T++){const G=this._targetedAnimations[T].animation.getKeys(),B=G[0],L=G[G.length-1];if(B.frame>K){const A={frame:K,value:B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation};G.splice(0,0,A)}if(L.frame<A){const K={frame:A,value:L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation};G.push(K)}}return this._from=K,this._to=A,this}_processLoop(K,A,T){K.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(A),this._animationLoopFlags[T]||(this._animationLoopFlags[T]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0],A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0,G=arguments.length>3?arguments[3]:void 0,B=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=K,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let L=0;L<this._targetedAnimations.length;L++){const f=this._targetedAnimations[L],O=this._scene.beginDirectAnimation(f.target,[f.animation],void 0!==T?T:this._from,void 0!==G?G:this._to,K,A,void 0,void 0,void 0!==B?B:this._isAdditive);O.weight=this._weight,O.playOrder=this._playOrder,O.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(f),this._checkAnimationGroupEnded(O)},this._processLoop(O,f,L),this._animatables.push(O)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=A,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let K=0;K<this._animatables.length;K++){this._animatables[K].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(K){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==K&&(this.loopAnimation=K),this.restart()):(this.stop(),this.start(K,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let K=0;K<this._animatables.length;K++){this._animatables[K].reset()}return this}restart(){if(!this._isStarted)return this;for(let K=0;K<this._animatables.length;K++){this._animatables[K].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const A=this._animatables.slice();for(let G=0;G<A.length;G++)A[G].stop(void 0,void 0,!0,K);let T=0;for(let G=0;G<this._scene._activeAnimatables.length;G++){const A=this._scene._activeAnimatables[G];A._runtimeAnimations.length>0?this._scene._activeAnimatables[T++]=A:K&&this._checkAnimationGroupEnded(A,K)}return this._scene._activeAnimatables.length=T,this._isStarted=!1,this}setWeightForAllAnimatables(K){for(let A=0;A<this._animatables.length;A++){this._animatables[A].weight=K}return this}syncAllAnimationsWith(K){for(let A=0;A<this._animatables.length;A++){this._animatables[A].syncWith(K)}return this}goToFrame(K){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let T=0;T<this._animatables.length;T++){this._animatables[T].goToFrame(K,A)}return this}getCurrentFrame(){var K;return(null===(K=this.animatables[0])||void 0===K?void 0:K.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const K=this._scene.animationGroups.indexOf(this);if(K>-1&&this._scene.animationGroups.splice(K,1),this._parentContainer){const K=this._parentContainer.animationGroups.indexOf(this);K>-1&&this._parentContainer.animationGroups.splice(K,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(K){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const T=this._animatables.indexOf(K);T>-1&&this._animatables.splice(T,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,A||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(K,A){let T=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const G=new N(K||this.name,this._scene,this._weight,this._playOrder);G._from=this.from,G._to=this.to,G._speedRatio=this.speedRatio,G._loopAnimation=this.loopAnimation,G._isAdditive=this.isAdditive,G._enableBlending=this.enableBlending,G._blendingSpeed=this.blendingSpeed,G.metadata=this.metadata,G.mask=this.mask;for(const B of this._targetedAnimations)G.addTargetedAnimation(T?B.animation.clone():B.animation,A?A(B.target):B.target);return G}serialize(){const K={};K.name=this.name,K.from=this.from,K.to=this.to,K.speedRatio=this.speedRatio,K.loopAnimation=this.loopAnimation,K.isAdditive=this.isAdditive,K.weight=this.weight,K.playOrder=this.playOrder,K.enableBlending=this.enableBlending,K.blendingSpeed=this.blendingSpeed,K.targetedAnimations=[];for(let A=0;A<this.targetedAnimations.length;A++){const T=this.targetedAnimations[A];K.targetedAnimations[A]=T.serialize()}return f.c&&f.c.HasTags(this)&&(K.tags=f.c.GetTags(this)),this.metadata&&(K.metadata=this.metadata),K}static Parse(K,A){const T=new N(K.name,A,K.weight,K.playOrder);for(let B=0;B<K.targetedAnimations.length;B++){const L=K.targetedAnimations[B],f=G.b.Parse(L.animation),O=L.targetId;if("influence"===L.animation.property){const K=A.getMorphTargetById(O);K&&T.addTargetedAnimation(f,K)}else{const K=A.getNodeById(O);null!=K&&T.addTargetedAnimation(f,K)}}return f.c&&f.c.AddTagsTo(T,K.tags),null!==K.from&&null!==K.to&&T.normalize(K.from,K.to),void 0!==K.speedRatio&&(T._speedRatio=K.speedRatio),void 0!==K.loopAnimation&&(T._loopAnimation=K.loopAnimation),void 0!==K.isAdditive&&(T._isAdditive=K.isAdditive),void 0!==K.weight&&(T._weight=K.weight),void 0!==K.playOrder&&(T._playOrder=K.playOrder),void 0!==K.enableBlending&&(T._enableBlending=K.enableBlending),void 0!==K.blendingSpeed&&(T._blendingSpeed=K.blendingSpeed),void 0!==K.metadata&&(T.metadata=K.metadata),T}static MakeAnimationAdditive(K,A,T){let B;B="object"===typeof A?A:{referenceFrame:A,range:T,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let L=K;B.cloneOriginalAnimationGroup&&(L=K.clone(B.clonedAnimationGroupName||L.name));const f=L.targetedAnimations;for(let O=0;O<f.length;O++){const K=f[O];K.animation=G.b.MakeAnimationAdditive(K.animation,B)}if(L.isAdditive=!0,B.clipKeys){let K=Number.MAX_VALUE,A=-Number.MAX_VALUE;const T=L.targetedAnimations;for(let G=0;G<T.length;G++){const B=T[G].animation.getKeys();K>B[0].frame&&(K=B[0].frame),A<B[B.length-1].frame&&(A=B[B.length-1].frame)}L._from=K,L._to=A}return L}static ClipKeys(K,A,T,G,B){const L=K.clone(G||K.name);return N.ClipKeysInPlace(L,A,T,B)}static ClipKeysInPlace(K,A,T,G){return N.ClipInPlace(K,A,T,G,!1)}static ClipFrames(K,A,T,G,B){const L=K.clone(G||K.name);return N.ClipFramesInPlace(L,A,T,B)}static ClipFramesInPlace(K,A,T,G){return N.ClipInPlace(K,A,T,G,!0)}static ClipInPlace(K,A,T,G){let B=arguments.length>4&&void 0!==arguments[4]&&arguments[4],L=Number.MAX_VALUE,f=-Number.MAX_VALUE;const O=K.targetedAnimations;for(let C=0;C<O.length;C++){const K=O[C],Q=G?K.animation:K.animation.clone();B&&(Q.createKeyForFrame(A),Q.createKeyForFrame(T));const Y=Q.getKeys(),Z=[];let x=Number.MAX_VALUE;for(let G=0;G<Y.length;G++){const K=Y[G];if(!B&&G>=A&&G<=T||B&&K.frame>=A&&K.frame<=T){const A={frame:K.frame,value:K.value.clone?K.value.clone():K.value,inTangent:K.inTangent,outTangent:K.outTangent,interpolation:K.interpolation,lockedTangent:K.lockedTangent};x===Number.MAX_VALUE&&(x=A.frame),A.frame-=x,Z.push(A)}}0!==Z.length?(L>Z[0].frame&&(L=Z[0].frame),f<Z[Z.length-1].frame&&(f=Z[Z.length-1].frame),Q.setKeys(Z,!0),K.animation=Q):(O.splice(C,1),C--)}return K._from=L,K._to=f,K}getClassName(){return"AnimationGroup"}toString(K){let A="Name: "+this.name;return A+=", type: "+this.getClassName(),K&&(A+=", from: "+this._from,A+=", to: "+this._to,A+=", isStarted: "+this._isStarted,A+=", speedRatio: "+this._speedRatio,A+=", targetedAnimations length: "+this._targetedAnimations.length,A+=", animatables length: "+this._animatables),A}}}}]);