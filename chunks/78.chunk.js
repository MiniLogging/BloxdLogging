"use strict";(self.ra6kpa9z1sg=self.ra6kpa9z1sg||[]).push([[78],{15948:(p,b,M)=>{M.r(b),M.d(b,{AnimationGroup:()=>Y,TargetedAnimation:()=>f});var h=M(13311),Q=M(12617),mp=M(12652),y=M(12815),P=M(14233),w=M(12777);class t{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(p,b,M,Q){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=b,this._target=p,this._scene=M,this._host=Q,this._activeTargets=[],b._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===h.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=w.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const p={frame:0,value:this._minValue};this._keys.splice(0,0,p)}if(this._target instanceof Array){let p=0;for(const b of this._target)this._preparePath(b,p),this._getOriginalValues(p),p++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const mp=b.getEvents();if(mp&&mp.length>0)for(const h of mp)this._events.push(h._clone());this._enableBlending=p&&p.animationPropertiesOverride?p.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const M=this._animation.targetPropertyPath;if(M.length>1){let h=p;for(let p=0;p<M.length-1;p++){const b=M[p];if(h=h[b],void 0===h)throw new Error(`Invalid property (${b}) in property path (${M.join(".")})`)}this._targetPath=M[M.length-1],this._activeTargets[b]=h}else this._targetPath=M[0],this._activeTargets[b]=p;if(void 0===this._activeTargets[b][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${M.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let p=0;for(const b of this._target)void 0!==this._originalValue[p]&&this._setValue(b,this._activeTargets[p],this._originalValue[p],-1,p),p++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let p=0;p<this._events.length;p++)this._events[p].isDone=!1}isStopped(){return this._stopped}dispose(){const p=this._animation.runtimeAnimations.indexOf(this);p>-1&&this._animation.runtimeAnimations.splice(p,1)}setValue(p,b){if(this._targetIsArray)for(let M=0;M<this._target.length;M++){const h=this._target[M];this._setValue(h,this._activeTargets[M],p,b,M)}else this._setValue(this._target,this._directTarget,p,b,0)}_getOriginalValues(){let p,b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const M=this._activeTargets[b];p=M.getLocalMatrix&&"_matrix"===this._targetPath?M.getLocalMatrix():M[this._targetPath],p&&p.clone?this._originalValue[b]=p.clone():this._originalValue[b]=p}_registerTargetForLateAnimationBinding(p,b){const M=p.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(M),M._lateAnimationHolders||(M._lateAnimationHolders={}),M._lateAnimationHolders[p.targetPath]||(M._lateAnimationHolders[p.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:b}),p.isAdditive?(M._lateAnimationHolders[p.targetPath].additiveAnimations.push(p),M._lateAnimationHolders[p.targetPath].totalAdditiveWeight+=p.weight):(M._lateAnimationHolders[p.targetPath].animations.push(p),M._lateAnimationHolders[p.targetPath].totalWeight+=p.weight)}_setValue(p,b,M,Q,mp){if(this._currentActiveTarget=b,this._weight=Q,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const p=b[this._targetPath];p.clone?this._originalBlendValue=p.clone():this._originalBlendValue=p}this._originalBlendValue.m?h.d.AllowMatrixDecomposeForInterpolation?this._currentValue?w.Matrix.DecomposeLerpToRef(this._originalBlendValue,M,this._blendingFactor,this._currentValue):this._currentValue=w.Matrix.DecomposeLerp(this._originalBlendValue,M,this._blendingFactor):this._currentValue?w.Matrix.LerpToRef(this._originalBlendValue,M,this._blendingFactor,this._currentValue):this._currentValue=w.Matrix.Lerp(this._originalBlendValue,M,this._blendingFactor):this._currentValue=h.d._UniversalLerp(this._originalBlendValue,M,this._blendingFactor);const Q=p&&p.animationPropertiesOverride?p.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=Q}else this._currentValue?this._currentValue.mp?this._currentValue.mp(M):this._currentValue=M:null!==M&&void 0!==M&&M.clone?this._currentValue=M.clone():this._currentValue=M;-1!==Q?this._registerTargetForLateAnimationBinding(this,this._originalValue[mp]):this._animationState.loopMode===h.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[mp],b[this._targetPath]):b[this._targetPath]=this._originalValue[mp]+this._currentValue:b[this._targetPath]=this._currentValue,p.yx&&p.yx(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const M=this._animation.getKeys();p<M[0].frame?p=M[0].frame:p>M[M.length-1].frame&&(p=M[M.length-1].frame);const h=this._events;if(h.length)for(let mp=0;mp<h.length;mp++)h[mp].onlyOnce||(h[mp].isDone=h[mp].frame<p);this._currentFrame=p;const Q=this._animation._interpolate(p,this._animationState);this.setValue(Q,b)}_prepareForSpeedRatioChange(p){const b=this._previousElapsedTime*(this._animation.framePerSecond*p)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-b}animate(p,b,M,Q,mp){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const P=this._animation,w=P.targetPropertyPath;if(!w||w.length<1)return this._stopped=!0,!1;let t,z=!0;const x=this._events;let S=0;if(this._coreRuntimeAnimation)S=M-b,t=this._coreRuntimeAnimation.currentFrame,this._currentFrame=t,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let y;(b<this._minFrame||b>this._maxFrame)&&(b=this._minFrame),(M<this._minFrame||M>this._maxFrame)&&(M=this._maxFrame),S=M-b;let w=p*(P.framePerSecond*mp)/1e3+this._absoluteFrameOffset,X=0,c=!1;const J=Q&&this._animationState.loopMode===h.d.ANIMATIONLOOPMODE_YOYO;if(J){const p=(w-b)/S,M=Math.sin(p*Math.PI);w=Math.abs(M)*S+b;const h=M>=0?1:-1;this._yoyoDirection!==h&&(c=!0),this._yoyoDirection=h}if(this._previousElapsedTime=p,this._previousAbsoluteFrame=w,!Q&&M>=b&&(w>=S&&mp>0||w<=0&&mp<0))z=!1,X=P._getKeyValue(this._maxValue);else if(!Q&&b>=M&&(w<=S&&mp<0||w>=0&&mp>0))z=!1,X=P._getKeyValue(this._minValue);else if(this._animationState.loopMode!==h.d.ANIMATIONLOOPMODE_CYCLE){const p=M.toString()+b.toString();if(!this._offsetsCache[p]){this._animationState.repeatCount=0,this._animationState.loopMode=h.d.ANIMATIONLOOPMODE_CYCLE;const Q=P._interpolate(b,this._animationState),mp=P._interpolate(M,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),P.dataType){case h.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[p]=mp-Q;break;case h.d.ANIMATIONTYPE_QUATERNION:case h.d.ANIMATIONTYPE_VECTOR3:case h.d.ANIMATIONTYPE_VECTOR2:case h.d.ANIMATIONTYPE_SIZE:case h.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[p]=mp.mh(Q)}this._highLimitsCache[p]=mp}X=this._highLimitsCache[p],y=this._offsetsCache[p]}if(void 0===y)switch(P.dataType){case h.d.ANIMATIONTYPE_FLOAT:y=0;break;case h.d.ANIMATIONTYPE_QUATERNION:y=h.j;break;case h.d.ANIMATIONTYPE_VECTOR3:y=h.p;break;case h.d.ANIMATIONTYPE_VECTOR2:y=h.o;break;case h.d.ANIMATIONTYPE_SIZE:y=h.l;break;case h.d.ANIMATIONTYPE_COLOR3:y=h.e;break;case h.d.ANIMATIONTYPE_COLOR4:y=h.i}if(this._host&&this._host.syncRoot){const p=this._host.syncRoot;t=b+S*((p.masterFrame-p.fromFrame)/(p.toFrame-p.fromFrame))}else t=w>0&&b>M||w<0&&b<M?z&&0!==S?M+w%S:b:z&&0!==S?b+w%S:M;if(!J&&(mp>0&&this.currentFrame>t||mp<0&&this.currentFrame<t)||J&&c){this._onLoop();for(let p=0;p<x.length;p++)x[p].onlyOnce||(x[p].isDone=!1);this._animationState.key=mp>0?0:P.getKeys().length-1}this._currentFrame=t,this._animationState.repeatCount=0===S?0:w/S|0,this._animationState.highLimitValue=X,this._animationState.offsetValue=y}const X=P._interpolate(t,this._animationState);if(this.setValue(X,y),x.length)for(let h=0;h<x.length;h++)if(S>=0&&t>=x[h].frame&&x[h].frame>=b||S<0&&t<=x[h].frame&&x[h].frame<=b){const p=x[h];p.isDone||(p.onlyOnce&&(x.splice(h,1),h--),p.isDone=!0,p.action(t))}return z||(this._stopped=!0),z}}var z=M(12630);class x{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(p){this._weight=-1!==p?Math.min(Math.max(p,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(p){for(let b=0;b<this._runtimeAnimations.length;b++){this._runtimeAnimations[b]._prepareForSpeedRatioChange(p)}this._speedRatio=p,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(p,b){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,mp=arguments.length>4&&void 0!==arguments[4]&&arguments[4],y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,P=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,t=arguments.length>8?arguments[8]:void 0,z=arguments.length>9&&void 0!==arguments[9]&&arguments[9],x=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=b,this.fromFrame=M,this.toFrame=h,this.loopAnimation=mp,this.onAnimationEnd=P,this.onAnimationLoop=t,this.isAdditive=z,this.playOrder=x,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Nw=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new Q.d,this.onAnimationLoopObservable=new Q.d,this._scene=p,w&&this.appendAnimations(b,w),this._speedRatio=y,p._activeAnimatables.push(this)}syncWith(p){if(this._syncRoot=p,p){const p=this._scene._activeAnimatables.indexOf(this);p>-1&&(this._scene._activeAnimatables.splice(p,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(p,b){for(let M=0;M<b.length;M++){const h=b[M],Q=new t(p,h,this._scene,this);Q._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(Q)}}getAnimationByTargetProperty(p){const b=this._runtimeAnimations;for(let M=0;M<b.length;M++)if(b[M].animation.targetProperty===p)return b[M].animation;return null}getRuntimeAnimationByTargetProperty(p){const b=this._runtimeAnimations;for(let M=0;M<b.length;M++)if(b[M].animation.targetProperty===p)return b[M];return null}reset(){const p=this._runtimeAnimations;for(let b=0;b<p.length;b++)p[b].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(p){const b=this._runtimeAnimations;for(let M=0;M<b.length;M++)b[M].animation.enableBlending=!0,b[M].animation.blendingSpeed=p}disableBlending(){const p=this._runtimeAnimations;for(let b=0;b<p.length;b++)p[b].animation.enableBlending=!1}goToFrame(p){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const M=this._runtimeAnimations;if(M[0]){const b=M[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??M[0].currentFrame;const h=0===this.speedRatio?0:(p-this._frameToSyncFromJump)/b*1e3/this.speedRatio;this._manualJumpDelay=-h}for(let h=0;h<M.length;h++)M[h].goToFrame(p,b?this._weight:-1);this._goToFrame=p}get paused(){return this.Nw}pause(){this.Nw||(this.Nw=!0)}restart(){this.Nw=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(p,b){let M=arguments.length>2&&void 0!==arguments[2]&&arguments[2],h=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(p||b){const Q=this._scene._activeAnimatables.indexOf(this);if(Q>-1){const mp=this._runtimeAnimations;for(let M=mp.length-1;M>=0;M--){const h=mp[M];p&&h.animation.name!=p||(b&&!b(h.target)||(h.dispose(),mp.splice(M,1)))}0==mp.length&&(M||this._scene._activeAnimatables.splice(Q,1),h||this._raiseOnAnimationEnd())}}else{const p=this._scene._activeAnimatables.indexOf(this);if(p>-1){M||this._scene._activeAnimatables.splice(p,1);const b=this._runtimeAnimations;for(let p=0;p<b.length;p++)b[p].dispose();this._runtimeAnimations.length=0,h||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((p=>{this.onAnimationEndObservable.add((()=>{p(this)}),void 0,void 0,this,!0)}))}_animate(p){if(this.Nw)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=p),!0;if(null===this._localDelayOffset?(this._localDelayOffset=p,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=p-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let b=!1;const M=this._runtimeAnimations;let h;for(h=0;h<M.length;h++){const Q=M[h].animate(p-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);b=b||Q}if(this.animationStarted=b,!b){if(this.disposeOnEnd)for(h=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(h,1),h=0;h<M.length;h++)M[h].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return b}}function S(p){if(0===p.totalWeight&&0===p.totalAdditiveWeight)return p.originalValue;let b=1;const M=w.TmpVectors.QM[0],h=w.TmpVectors.QM[1],Q=w.TmpVectors.Quaternion[0];let mp=0;const y=p.animations[0],P=p.originalValue;let t=1,z=!1;if(p.totalWeight<1)t=1-p.totalWeight,P.decompose(h,Q,M);else{if(mp=1,b=p.totalWeight,t=y.weight/b,1==t){if(!p.totalAdditiveWeight)return y.currentValue;z=!0}y.currentValue.decompose(h,Q,M)}if(!z){h.scaleInPlace(t),M.scaleInPlace(t),Q.scaleInPlace(t);for(let y=mp;y<p.animations.length;y++){const mp=p.animations[y];if(0===mp.weight)continue;t=mp.weight/b;const P=w.TmpVectors.QM[2],z=w.TmpVectors.QM[3],x=w.TmpVectors.Quaternion[1];mp.currentValue.decompose(z,x,P),z.scaleAndAddToRef(t,h),x.scaleAndAddToRef(w.Quaternion.Dot(Q,x)>0?t:-t,Q),P.scaleAndAddToRef(t,M)}Q.normalize()}for(let S=0;S<p.additiveAnimations.length;S++){const b=p.additiveAnimations[S];if(0===b.weight)continue;const mp=w.TmpVectors.QM[2],y=w.TmpVectors.QM[3],P=w.TmpVectors.Quaternion[1];b.currentValue.decompose(y,P,mp),y.multiplyToRef(h,y),w.QM.LerpToRef(h,y,b.weight,h),Q.multiplyToRef(P,P),w.Quaternion.SlerpToRef(Q,P,b.weight,Q),mp.scaleAndAddToRef(b.weight,M)}const x=y?y._animationState.workValue:w.TmpVectors.Matrix[0].clone();return w.Matrix.ComposeToRef(h,Q,M,x),x}function X(p,b){if(0===p.totalWeight&&0===p.totalAdditiveWeight)return b;const M=p.animations[0],h=p.originalValue;let Q=b;if(0===p.totalWeight&&p.totalAdditiveWeight>0)Q.mp(h);else if(1===p.animations.length){if(w.Quaternion.SlerpToRef(h,M.currentValue,Math.min(1,p.totalWeight),Q),0===p.totalAdditiveWeight)return Q}else if(p.animations.length>1){let M,mp,y=1;if(p.totalWeight<1){const b=1-p.totalWeight;M=[],mp=[],M.push(h),mp.push(b)}else{if(2===p.animations.length&&(w.Quaternion.SlerpToRef(p.animations[0].currentValue,p.animations[1].currentValue,p.animations[1].weight/p.totalWeight,b),0===p.totalAdditiveWeight))return b;M=[],mp=[],y=p.totalWeight}for(let b=0;b<p.animations.length;b++){const h=p.animations[b];M.push(h.currentValue),mp.push(h.weight/y)}let P=0;for(let p=0;p<M.length;)p?(P+=mp[p],w.Quaternion.SlerpToRef(Q,M[p],mp[p]/P,Q),p++):(w.Quaternion.SlerpToRef(M[p],M[p+1],mp[p+1]/(mp[p]+mp[p+1]),b),Q=b,P=mp[p]+mp[p+1],p+=2)}for(let mp=0;mp<p.additiveAnimations.length;mp++){const b=p.additiveAnimations[mp];0!==b.weight&&(Q.multiplyToRef(b.currentValue,w.TmpVectors.Quaternion[0]),w.Quaternion.SlerpToRef(Q,w.TmpVectors.Quaternion[0],b.weight,Q))}return Q}var c,J,g=M(13013);c=g.b,(J=P.e)&&(J.prototype.copyAnimationRange=function(p,b,M){let Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],mp=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new h.d(this.name,"_matrix",p.animations[0].framePerSecond,h.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const y=p.animations[0].getRange(b);if(!y)return!1;const P=y.from,w=y.to,t=p.animations[0].getKeys(),z=p.length,x=p.getParent(),S=this.getParent(),X=Q&&x&&z&&this.length&&z!==this.length,c=X&&S&&x?S.length/x.length:1,J=Q&&!S&&mp&&(1!==mp.x||1!==mp.y||1!==mp.z),g=this.animations[0].getKeys();let f,Y,a;for(let h=0,o=t.length;h<o;h++)f=t[h],f.frame>=P&&f.frame<=w&&(Q?(a=f.value.clone(),X?(Y=a.getTranslation(),a.setTranslation(Y.scaleInPlace(c))):J&&mp?(Y=a.getTranslation(),a.setTranslation(Y.multiplyInPlace(mp))):a=f.value):a=f.value,g.push({frame:f.frame+M,value:a}));return this.animations[0].createRange(b,P+M,w+M),!0}),c&&(c.prototype._animate=function(p){if(!this.animationsEnabled)return;const b=z.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=b}this.deltaTime=void 0!==p?p:this.useConstantAnimationDeltaTime?16:(b-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=b;const M=this._activeAnimatables;if(0===M.length)return;this._animationTime+=this.deltaTime;const Q=this._animationTime;for(let h=0;h<M.length;h++){const p=M[h];!p._animate(Q)&&p.disposeOnEnd&&h--}!function(p){if(p._registeredForLateAnimationBindings.length){for(let b=0;b<p._registeredForLateAnimationBindings.length;b++){const M=p._registeredForLateAnimationBindings.data[b];for(const p in M._lateAnimationHolders){const b=M._lateAnimationHolders[p],Q=b.animations[0],mp=b.originalValue;if(void 0===mp||null===mp)continue;const y=h.d.AllowMatrixDecomposeForInterpolation&&mp.m;let P=M[p];if(y)P=S(b);else if(void 0!==mp.w)P=X(b,P||w.Quaternion.Identity());else{let p=0,M=1;const y=Q&&Q._animationState.loopMode===h.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(b.totalWeight<1)P=y?mp.clone?mp.clone():mp:Q&&mp.scale?mp.scale(1-b.totalWeight):Q?mp*(1-b.totalWeight):mp.clone?mp.clone():mp;else if(Q){M=b.totalWeight;const h=Q.weight/M;P=1!==h?Q.currentValue.scale?Q.currentValue.scale(h):Q.currentValue*h:Q.currentValue,y&&(P.addToRef?P.addToRef(mp,P):P+=mp),p=1}for(let h=p;h<b.animations.length;h++){const p=b.animations[h],Q=p.weight/M;Q&&(p.currentValue.scaleAndAddToRef?p.currentValue.scaleAndAddToRef(Q,P):P+=p.currentValue*Q)}for(let h=0;h<b.additiveAnimations.length;h++){const p=b.additiveAnimations[h],M=p.weight;M&&(p.currentValue.scaleAndAddToRef?p.currentValue.scaleAndAddToRef(M,P):P+=p.currentValue*M)}}M[p]=P}M._lateAnimationHolders={}}p._registeredForLateAnimationBindings.reset()}}(this)},c.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((p,b)=>p.playOrder-b.playOrder))},c.prototype.beginWeightedAnimation=function(p,b,M){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,Q=arguments.length>4?arguments[4]:void 0,mp=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,y=arguments.length>6?arguments[6]:void 0,P=arguments.length>7?arguments[7]:void 0,w=arguments.length>8?arguments[8]:void 0,t=arguments.length>9?arguments[9]:void 0,z=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const x=this.beginAnimation(p,b,M,Q,mp,y,P,!1,w,t,z);return x.weight=h,x},c.prototype.beginAnimation=function(p,b,M,h){let Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,mp=arguments.length>5?arguments[5]:void 0,y=arguments.length>6?arguments[6]:void 0,P=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],w=arguments.length>8?arguments[8]:void 0,t=arguments.length>9?arguments[9]:void 0,z=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(Q<0){const p=b;b=M,M=p,Q=-Q}b>M&&(Q=-Q),P&&this.stopAnimation(p,void 0,w),y||(y=new x(this,p,b,M,h,Q,mp,void 0,t,z));const S=!w||w(p);if(p.animations&&S&&y.appendAnimations(p,p.animations),p.getAnimatables){const z=p.getAnimatables();for(let p=0;p<z.length;p++)this.beginAnimation(z[p],b,M,h,Q,mp,y,P,w,t)}return y.reset(),y},c.prototype.beginHierarchyAnimation=function(p,b,M,h,Q){let mp=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,y=arguments.length>6?arguments[6]:void 0,P=arguments.length>7?arguments[7]:void 0,w=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],t=arguments.length>9?arguments[9]:void 0,z=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const x=p.getDescendants(b),S=[];S.push(this.beginAnimation(p,M,h,Q,mp,y,P,w,t,void 0,z));for(const X of x)S.push(this.beginAnimation(X,M,h,Q,mp,y,P,w,t,void 0,z));return S},c.prototype.beginDirectAnimation=function(p,b,M,h,Q){let mp=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(mp<0){const p=M;M=h,h=p,mp=-mp}return M>h&&(mp=-mp),new x(this,p,M,h,Q,mp,arguments.length>6?arguments[6]:void 0,b,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},c.prototype.beginDirectHierarchyAnimation=function(p,b,M,h,Q,mp,y,P,w){let t=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const z=p.getDescendants(b),x=[];x.push(this.beginDirectAnimation(p,M,h,Q,mp,y,P,w,t));for(const S of z)x.push(this.beginDirectAnimation(S,M,h,Q,mp,y,P,w,t));return x},c.prototype.getAnimatableByTarget=function(p){for(let b=0;b<this._activeAnimatables.length;b++)if(this._activeAnimatables[b].target===p)return this._activeAnimatables[b];return null},c.prototype.getAllAnimatablesByTarget=function(p){const b=[];for(let M=0;M<this._activeAnimatables.length;M++)this._activeAnimatables[M].target===p&&b.push(this._activeAnimatables[M]);return b},c.prototype.stopAnimation=function(p,b,M){const h=this.getAllAnimatablesByTarget(p);for(const Q of h)Q.stop(b,M)},c.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let p=0;p<this._activeAnimatables.length;p++)this._activeAnimatables[p].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const p of this.animationGroups)p.stop()});class f{getClassName(){return"TargetedAnimation"}serialize(){const p={};return p.animation=this.animation.serialize(),p.targetId=this.target.id,p}}class Y{get mask(){return this._mask}set mask(p){this._mask!==p&&(this._mask=p,this.syncWithMask(!0))}syncWithMask(){let p=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||p){this._numActiveAnimatables=0;for(let p=0;p<this._animatables.length;++p){const b=this._animatables[p];!this.mask||this.mask.disabled||this.mask.retainsTarget(b.target.name)?(this._numActiveAnimatables++,b.paused&&b.restart()):b.paused||b.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let p=0;p<this._animatables.length;++p){const b=this._animatables[p];this.mask.retainsTarget(b.target.name)||(b.stop(),this._animatables.splice(p,1),--p)}for(let p=0;p<this._targetedAnimations.length;p++){const b=this._targetedAnimations[p];this.mask.retainsTarget(b.target.name)||(this._targetedAnimations.splice(p,1),--p)}}}get from(){return this._from}set from(p){if(this._from!==p){this._from=p;for(let p=0;p<this._animatables.length;p++){this._animatables[p].fromFrame=this._from}}}get to(){return this._to}set to(p){if(this._to!==p){this._to=p;for(let p=0;p<this._animatables.length;p++){this._animatables[p].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(p){if(this._speedRatio!==p){this._speedRatio=p;for(let p=0;p<this._animatables.length;p++){this._animatables[p].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(p){if(this._loopAnimation!==p){this._loopAnimation=p;for(let p=0;p<this._animatables.length;p++){this._animatables[p].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(p){if(this._isAdditive!==p){this._isAdditive=p;for(let p=0;p<this._animatables.length;p++){this._animatables[p].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(p){this._weight!==p&&(this._weight=p,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(p){if(this._playOrder!==p&&(this._playOrder=p,this._animatables.length>0)){for(let p=0;p<this._animatables.length;p++)this._animatables[p].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(p){if(this._enableBlending!==p&&(this._enableBlending=p,null!==p))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.enableBlending=p}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(p){if(this._blendingSpeed!==p&&(this._blendingSpeed=p,null!==p))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.blendingSpeed=p}getLength(p,b){p=p??this._from;return((b=b??this._to)-p)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(p){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],M=arguments.length>2&&void 0!==arguments[2]&&arguments[2],h=arguments.length>3?arguments[3]:void 0;if(0===p.length)return null;h=h??p[0].weight;let Q=Number.MAX_VALUE,mp=-Number.MAX_VALUE;if(M)for(const P of p)P.from<Q&&(Q=P.from),P.to>mp&&(mp=P.to);const y=new Y(p[0].name+"_merged",p[0]._scene,h);for(const P of p){M&&P.normalize(Q,mp);for(const p of P.targetedAnimations)y.addTargetedAnimation(p.animation,p.target);b&&P.dispose()}return y}constructor(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=p,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new Q.d,this.onAnimationLoopObservable=new Q.d,this.onAnimationGroupLoopObservable=new Q.d,this.onAnimationGroupEndObservable=new Q.d,this.onAnimationGroupPauseObservable=new Q.d,this.onAnimationGroupPlayObservable=new Q.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=b||mp.c.LastCreatedScene,this._weight=M,this._playOrder=h,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(p,b){const M=new f;M.animation=p,M.target=b;const h=p.getKeys();return this._from>h[0].frame&&(this._from=h[0].frame),this._to<h[h.length-1].frame&&(this._to=h[h.length-1].frame),null!==this._enableBlending&&(p.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(p.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(M),this._shouldStart=!0,M}removeTargetedAnimation(p){for(let b=this._targetedAnimations.length-1;b>-1;b--){this._targetedAnimations[b].animation===p&&this._targetedAnimations.splice(b,1)}}normalize(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==p&&(p=this._from),null==b&&(b=this._to);for(let M=0;M<this._targetedAnimations.length;M++){const h=this._targetedAnimations[M].animation.getKeys(),Q=h[0],mp=h[h.length-1];if(Q.frame>p){const b={frame:p,value:Q.value,inTangent:Q.inTangent,outTangent:Q.outTangent,interpolation:Q.interpolation};h.splice(0,0,b)}if(mp.frame<b){const p={frame:b,value:mp.value,inTangent:mp.inTangent,outTangent:mp.outTangent,interpolation:mp.interpolation};h.push(p)}}return this._from=p,this._to=b,this}_processLoop(p,b,M){p.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(b),this._animationLoopFlags[M]||(this._animationLoopFlags[M]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let p=arguments.length>0&&void 0!==arguments[0]&&arguments[0],b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,M=arguments.length>2?arguments[2]:void 0,h=arguments.length>3?arguments[3]:void 0,Q=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=p,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let mp=0;mp<this._targetedAnimations.length;mp++){const y=this._targetedAnimations[mp],P=this._scene.beginDirectAnimation(y.target,[y.animation],void 0!==M?M:this._from,void 0!==h?h:this._to,p,b,void 0,void 0,void 0!==Q?Q:this._isAdditive);P.weight=this._weight,P.playOrder=this._playOrder,P.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(y),this._checkAnimationGroupEnded(P)},this._processLoop(P,y,mp),this._animatables.push(P)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=b,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let p=0;p<this._animatables.length;p++){this._animatables[p].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(p){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==p&&(this.loopAnimation=p),this.restart()):(this.stop(),this.start(p,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let p=0;p<this._animatables.length;p++){this._animatables[p].reset()}return this}restart(){if(!this._isStarted)return this;for(let p=0;p<this._animatables.length;p++){this._animatables[p].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let p=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const b=this._animatables.slice();for(let h=0;h<b.length;h++)b[h].stop(void 0,void 0,!0,p);let M=0;for(let h=0;h<this._scene._activeAnimatables.length;h++){const b=this._scene._activeAnimatables[h];b._runtimeAnimations.length>0?this._scene._activeAnimatables[M++]=b:p&&this._checkAnimationGroupEnded(b,p)}return this._scene._activeAnimatables.length=M,this._isStarted=!1,this}setWeightForAllAnimatables(p){for(let b=0;b<this._animatables.length;b++){this._animatables[b].weight=p}return this}syncAllAnimationsWith(p){for(let b=0;b<this._animatables.length;b++){this._animatables[b].syncWith(p)}return this}goToFrame(p){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let M=0;M<this._animatables.length;M++){this._animatables[M].goToFrame(p,b)}return this}getCurrentFrame(){var p;return(null===(p=this.animatables[0])||void 0===p?void 0:p.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const p=this._scene.animationGroups.indexOf(this);if(p>-1&&this._scene.animationGroups.splice(p,1),this._parentContainer){const p=this._parentContainer.animationGroups.indexOf(this);p>-1&&this._parentContainer.animationGroups.splice(p,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(p){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const M=this._animatables.indexOf(p);M>-1&&this._animatables.splice(M,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,b||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(p,b){let M=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const h=new Y(p||this.name,this._scene,this._weight,this._playOrder);h._from=this.from,h._to=this.to,h._speedRatio=this.speedRatio,h._loopAnimation=this.loopAnimation,h._isAdditive=this.isAdditive,h._enableBlending=this.enableBlending,h._blendingSpeed=this.blendingSpeed,h.metadata=this.metadata,h.mask=this.mask;for(const Q of this._targetedAnimations)h.addTargetedAnimation(M?Q.animation.clone():Q.animation,b?b(Q.target):Q.target);return h}serialize(){const p={};p.name=this.name,p.from=this.from,p.to=this.to,p.speedRatio=this.speedRatio,p.loopAnimation=this.loopAnimation,p.isAdditive=this.isAdditive,p.weight=this.weight,p.playOrder=this.playOrder,p.enableBlending=this.enableBlending,p.blendingSpeed=this.blendingSpeed,p.targetedAnimations=[];for(let b=0;b<this.targetedAnimations.length;b++){const M=this.targetedAnimations[b];p.targetedAnimations[b]=M.serialize()}return y.b&&y.b.HasTags(this)&&(p.tags=y.b.GetTags(this)),this.metadata&&(p.metadata=this.metadata),p}static Parse(p,b){const M=new Y(p.name,b,p.weight,p.playOrder);for(let Q=0;Q<p.targetedAnimations.length;Q++){const mp=p.targetedAnimations[Q],y=h.d.Parse(mp.animation),P=mp.targetId;if("influence"===mp.animation.property){const p=b.getMorphTargetById(P);p&&M.addTargetedAnimation(y,p)}else{const p=b.getNodeById(P);null!=p&&M.addTargetedAnimation(y,p)}}return y.b&&y.b.AddTagsTo(M,p.tags),null!==p.from&&null!==p.to&&M.normalize(p.from,p.to),void 0!==p.speedRatio&&(M._speedRatio=p.speedRatio),void 0!==p.loopAnimation&&(M._loopAnimation=p.loopAnimation),void 0!==p.isAdditive&&(M._isAdditive=p.isAdditive),void 0!==p.weight&&(M._weight=p.weight),void 0!==p.playOrder&&(M._playOrder=p.playOrder),void 0!==p.enableBlending&&(M._enableBlending=p.enableBlending),void 0!==p.blendingSpeed&&(M._blendingSpeed=p.blendingSpeed),void 0!==p.metadata&&(M.metadata=p.metadata),M}static MakeAnimationAdditive(p,b,M){let Q;Q="object"===typeof b?b:{referenceFrame:b,range:M,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let mp=p;Q.cloneOriginalAnimationGroup&&(mp=p.clone(Q.clonedAnimationGroupName||mp.name));const y=mp.targetedAnimations;for(let P=0;P<y.length;P++){const p=y[P];p.animation=h.d.MakeAnimationAdditive(p.animation,Q)}if(mp.isAdditive=!0,Q.clipKeys){let p=Number.MAX_VALUE,b=-Number.MAX_VALUE;const M=mp.targetedAnimations;for(let h=0;h<M.length;h++){const Q=M[h].animation.getKeys();p>Q[0].frame&&(p=Q[0].frame),b<Q[Q.length-1].frame&&(b=Q[Q.length-1].frame)}mp._from=p,mp._to=b}return mp}static ClipKeys(p,b,M,h,Q){const mp=p.clone(h||p.name);return Y.ClipKeysInPlace(mp,b,M,Q)}static ClipKeysInPlace(p,b,M,h){return Y.ClipInPlace(p,b,M,h,!1)}static ClipFrames(p,b,M,h,Q){const mp=p.clone(h||p.name);return Y.ClipFramesInPlace(mp,b,M,Q)}static ClipFramesInPlace(p,b,M,h){return Y.ClipInPlace(p,b,M,h,!0)}static ClipInPlace(p,b,M,h){let Q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],mp=Number.MAX_VALUE,y=-Number.MAX_VALUE;const P=p.targetedAnimations;for(let w=0;w<P.length;w++){const p=P[w],t=h?p.animation:p.animation.clone();Q&&(t.createKeyForFrame(b),t.createKeyForFrame(M));const z=t.getKeys(),x=[];let S=Number.MAX_VALUE;for(let h=0;h<z.length;h++){const p=z[h];if(!Q&&h>=b&&h<=M||Q&&p.frame>=b&&p.frame<=M){const b={frame:p.frame,value:p.value.clone?p.value.clone():p.value,inTangent:p.inTangent,outTangent:p.outTangent,interpolation:p.interpolation,lockedTangent:p.lockedTangent};S===Number.MAX_VALUE&&(S=b.frame),b.frame-=S,x.push(b)}}0!==x.length?(mp>x[0].frame&&(mp=x[0].frame),y<x[x.length-1].frame&&(y=x[x.length-1].frame),t.setKeys(x,!0),p.animation=t):(P.splice(w,1),w--)}return p._from=mp,p._to=y,p}getClassName(){return"AnimationGroup"}toString(p){let b="Name: "+this.name;return b+=", type: "+this.getClassName(),p&&(b+=", from: "+this._from,b+=", to: "+this._to,b+=", isStarted: "+this._isStarted,b+=", speedRatio: "+this._speedRatio,b+=", targetedAnimations length: "+this._targetedAnimations.length,b+=", animatables length: "+this._animatables),b}}}}]);