"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[78],{14332:(B,I,C)=>{C.r(I),C.d(I,{AnimationGroup:()=>U,TargetedAnimation:()=>o});var M=C(11708),x=C(11022),y=C(11056),f=C(11232),L=C(12808),e=C(11194);class g{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(B,I,C,x){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=I,this._target=B,this._scene=C,this._host=x,this._activeTargets=[],I._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===M.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=e.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const B={frame:0,value:this._minValue};this._keys.splice(0,0,B)}if(this._target instanceof Array){let B=0;for(const I of this._target)this._preparePath(I,B),this._getOriginalValues(B),B++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const y=I.getEvents();if(y&&y.length>0)for(const M of y)this._events.push(M._clone());this._enableBlending=B&&B.animationPropertiesOverride?B.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this._animation.targetPropertyPath;if(C.length>1){let M=B;for(let B=0;B<C.length-1;B++){const I=C[B];if(M=M[I],void 0===M)throw new Error(`Invalid property (${I}) in property path (${C.join(".")})`)}this._targetPath=C[C.length-1],this._activeTargets[I]=M}else this._targetPath=C[0],this._activeTargets[I]=B;if(void 0===this._activeTargets[I][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${C.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let B=0;for(const I of this._target)void 0!==this._originalValue[B]&&this._setValue(I,this._activeTargets[B],this._originalValue[B],-1,B),B++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let B=0;B<this._events.length;B++)this._events[B].isDone=!1}isStopped(){return this._stopped}dispose(){const B=this._animation.runtimeAnimations.indexOf(this);B>-1&&this._animation.runtimeAnimations.splice(B,1)}setValue(B,I){if(this._targetIsArray)for(let C=0;C<this._target.length;C++){const M=this._target[C];this._setValue(M,this._activeTargets[C],B,I,C)}else this._setValue(this._target,this._directTarget,B,I,0)}_getOriginalValues(){let B,I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const C=this._activeTargets[I];B=C.getLocalMatrix&&"_matrix"===this._targetPath?C.getLocalMatrix():C[this._targetPath],B&&B.clone?this._originalValue[I]=B.clone():this._originalValue[I]=B}_registerTargetForLateAnimationBinding(B,I){const C=B.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(C),C._lateAnimationHolders||(C._lateAnimationHolders={}),C._lateAnimationHolders[B.targetPath]||(C._lateAnimationHolders[B.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:I}),B.isAdditive?(C._lateAnimationHolders[B.targetPath].additiveAnimations.push(B),C._lateAnimationHolders[B.targetPath].totalAdditiveWeight+=B.weight):(C._lateAnimationHolders[B.targetPath].animations.push(B),C._lateAnimationHolders[B.targetPath].totalWeight+=B.weight)}_setValue(B,I,C,x,y){if(this._currentActiveTarget=I,this._weight=x,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const B=I[this._targetPath];B.clone?this._originalBlendValue=B.clone():this._originalBlendValue=B}this._originalBlendValue.m?M.c.AllowMatrixDecomposeForInterpolation?this._currentValue?e.Matrix.DecomposeLerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=e.Matrix.DecomposeLerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue?e.Matrix.LerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=e.Matrix.Lerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue=M.c._UniversalLerp(this._originalBlendValue,C,this._blendingFactor);const x=B&&B.animationPropertiesOverride?B.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=x}else this._currentValue?this._currentValue.M?this._currentValue.M(C):this._currentValue=C:null!==C&&void 0!==C&&C.clone?this._currentValue=C.clone():this._currentValue=C;-1!==x?this._registerTargetForLateAnimationBinding(this,this._originalValue[y]):this._animationState.loopMode===M.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[y],I[this._targetPath]):I[this._targetPath]=this._originalValue[y]+this._currentValue:I[this._targetPath]=this._currentValue,B.RN&&B.RN(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const C=this._animation.getKeys();B<C[0].frame?B=C[0].frame:B>C[C.length-1].frame&&(B=C[C.length-1].frame);const M=this._events;if(M.length)for(let y=0;y<M.length;y++)M[y].onlyOnce||(M[y].isDone=M[y].frame<B);this._currentFrame=B;const x=this._animation._interpolate(B,this._animationState);this.setValue(x,I)}_prepareForSpeedRatioChange(B){const I=this._previousElapsedTime*(this._animation.framePerSecond*B)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-I}animate(B,I,C,x,y){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const L=this._animation,e=L.targetPropertyPath;if(!e||e.length<1)return this._stopped=!0,!1;let g,N=!0;const R=this._events;let H=0;if(this._coreRuntimeAnimation)H=C-I,g=this._coreRuntimeAnimation.currentFrame,this._currentFrame=g,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let f;(I<this._minFrame||I>this._maxFrame)&&(I=this._minFrame),(C<this._minFrame||C>this._maxFrame)&&(C=this._maxFrame),H=C-I;let e=B*(L.framePerSecond*y)/1e3+this._absoluteFrameOffset,F=0,k=!1;const q=x&&this._animationState.loopMode===M.c.ANIMATIONLOOPMODE_YOYO;if(q){const B=(e-I)/H,C=Math.sin(B*Math.PI);e=Math.abs(C)*H+I;const M=C>=0?1:-1;this._yoyoDirection!==M&&(k=!0),this._yoyoDirection=M}if(this._previousElapsedTime=B,this._previousAbsoluteFrame=e,!x&&C>=I&&(e>=H&&y>0||e<=0&&y<0))N=!1,F=L._getKeyValue(this._maxValue);else if(!x&&I>=C&&(e<=H&&y<0||e>=0&&y>0))N=!1,F=L._getKeyValue(this._minValue);else if(this._animationState.loopMode!==M.c.ANIMATIONLOOPMODE_CYCLE){const B=C.toString()+I.toString();if(!this._offsetsCache[B]){this._animationState.repeatCount=0,this._animationState.loopMode=M.c.ANIMATIONLOOPMODE_CYCLE;const x=L._interpolate(I,this._animationState),y=L._interpolate(C,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),L.dataType){case M.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[B]=y-x;break;case M.c.ANIMATIONTYPE_QUATERNION:case M.c.ANIMATIONTYPE_VECTOR3:case M.c.ANIMATIONTYPE_VECTOR2:case M.c.ANIMATIONTYPE_SIZE:case M.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[B]=y.FI(x)}this._highLimitsCache[B]=y}F=this._highLimitsCache[B],f=this._offsetsCache[B]}if(void 0===f)switch(L.dataType){case M.c.ANIMATIONTYPE_FLOAT:f=0;break;case M.c.ANIMATIONTYPE_QUATERNION:f=M.j;break;case M.c.ANIMATIONTYPE_VECTOR3:f=M.r;break;case M.c.ANIMATIONTYPE_VECTOR2:f=M.n;break;case M.c.ANIMATIONTYPE_SIZE:f=M.k;break;case M.c.ANIMATIONTYPE_COLOR3:f=M.e;break;case M.c.ANIMATIONTYPE_COLOR4:f=M.h}if(this._host&&this._host.syncRoot){const B=this._host.syncRoot;g=I+H*((B.masterFrame-B.fromFrame)/(B.toFrame-B.fromFrame))}else g=e>0&&I>C||e<0&&I<C?N&&0!==H?C+e%H:I:N&&0!==H?I+e%H:C;if(!q&&(y>0&&this.currentFrame>g||y<0&&this.currentFrame<g)||q&&k){this._onLoop();for(let B=0;B<R.length;B++)R[B].onlyOnce||(R[B].isDone=!1);this._animationState.key=y>0?0:L.getKeys().length-1}this._currentFrame=g,this._animationState.repeatCount=0===H?0:e/H|0,this._animationState.highLimitValue=F,this._animationState.offsetValue=f}const F=L._interpolate(g,this._animationState);if(this.setValue(F,f),R.length)for(let M=0;M<R.length;M++)if(H>=0&&g>=R[M].frame&&R[M].frame>=I||H<0&&g<=R[M].frame&&R[M].frame<=I){const B=R[M];B.isDone||(B.onlyOnce&&(R.splice(M,1),M--),B.isDone=!0,B.action(g))}return N||(this._stopped=!0),N}}var N=C(11034);class R{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(B){this._weight=-1!==B?Math.min(Math.max(B,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(B){for(let I=0;I<this._runtimeAnimations.length;I++){this._runtimeAnimations[I]._prepareForSpeedRatioChange(B)}this._speedRatio=B,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,y=arguments.length>4&&void 0!==arguments[4]&&arguments[4],f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,L=arguments.length>6?arguments[6]:void 0,e=arguments.length>7?arguments[7]:void 0,g=arguments.length>8?arguments[8]:void 0,N=arguments.length>9&&void 0!==arguments[9]&&arguments[9],R=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=I,this.fromFrame=C,this.toFrame=M,this.loopAnimation=y,this.onAnimationEnd=L,this.onAnimationLoop=g,this.isAdditive=N,this.playOrder=R,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.VL=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new x.e,this.onAnimationLoopObservable=new x.e,this._scene=B,e&&this.appendAnimations(I,e),this._speedRatio=f,B._activeAnimatables.push(this)}syncWith(B){if(this._syncRoot=B,B){const B=this._scene._activeAnimatables.indexOf(this);B>-1&&(this._scene._activeAnimatables.splice(B,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(B,I){for(let C=0;C<I.length;C++){const M=I[C],x=new g(B,M,this._scene,this);x._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(x)}}getAnimationByTargetProperty(B){const I=this._runtimeAnimations;for(let C=0;C<I.length;C++)if(I[C].animation.targetProperty===B)return I[C].animation;return null}getRuntimeAnimationByTargetProperty(B){const I=this._runtimeAnimations;for(let C=0;C<I.length;C++)if(I[C].animation.targetProperty===B)return I[C];return null}reset(){const B=this._runtimeAnimations;for(let I=0;I<B.length;I++)B[I].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(B){const I=this._runtimeAnimations;for(let C=0;C<I.length;C++)I[C].animation.enableBlending=!0,I[C].animation.blendingSpeed=B}disableBlending(){const B=this._runtimeAnimations;for(let I=0;I<B.length;I++)B[I].animation.enableBlending=!1}goToFrame(B){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const C=this._runtimeAnimations;if(C[0]){const I=C[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??C[0].currentFrame;const M=0===this.speedRatio?0:(B-this._frameToSyncFromJump)/I*1e3/this.speedRatio;this._manualJumpDelay=-M}for(let M=0;M<C.length;M++)C[M].goToFrame(B,I?this._weight:-1);this._goToFrame=B}get paused(){return this.VL}pause(){this.VL||(this.VL=!0)}restart(){this.VL=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(B,I){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],M=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(B||I){const x=this._scene._activeAnimatables.indexOf(this);if(x>-1){const y=this._runtimeAnimations;for(let C=y.length-1;C>=0;C--){const M=y[C];B&&M.animation.name!=B||(I&&!I(M.target)||(M.dispose(),y.splice(C,1)))}0==y.length&&(C||this._scene._activeAnimatables.splice(x,1),M||this._raiseOnAnimationEnd())}}else{const B=this._scene._activeAnimatables.indexOf(this);if(B>-1){C||this._scene._activeAnimatables.splice(B,1);const I=this._runtimeAnimations;for(let B=0;B<I.length;B++)I[B].dispose();this._runtimeAnimations.length=0,M||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((B=>{this.onAnimationEndObservable.add((()=>{B(this)}),void 0,void 0,this,!0)}))}_animate(B){if(this.VL)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=B),!0;if(null===this._localDelayOffset?(this._localDelayOffset=B,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=B-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let I=!1;const C=this._runtimeAnimations;let M;for(M=0;M<C.length;M++){const x=C[M].animate(B-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);I=I||x}if(this.animationStarted=I,!I){if(this.disposeOnEnd)for(M=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(M,1),M=0;M<C.length;M++)C[M].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return I}}function H(B){if(0===B.totalWeight&&0===B.totalAdditiveWeight)return B.originalValue;let I=1;const C=e.TmpVectors.HI[0],M=e.TmpVectors.HI[1],x=e.TmpVectors.Quaternion[0];let y=0;const f=B.animations[0],L=B.originalValue;let g=1,N=!1;if(B.totalWeight<1)g=1-B.totalWeight,L.decompose(M,x,C);else{if(y=1,I=B.totalWeight,g=f.weight/I,1==g){if(!B.totalAdditiveWeight)return f.currentValue;N=!0}f.currentValue.decompose(M,x,C)}if(!N){M.scaleInPlace(g),C.scaleInPlace(g),x.scaleInPlace(g);for(let f=y;f<B.animations.length;f++){const y=B.animations[f];if(0===y.weight)continue;g=y.weight/I;const L=e.TmpVectors.HI[2],N=e.TmpVectors.HI[3],R=e.TmpVectors.Quaternion[1];y.currentValue.decompose(N,R,L),N.scaleAndAddToRef(g,M),R.scaleAndAddToRef(e.Quaternion.Dot(x,R)>0?g:-g,x),L.scaleAndAddToRef(g,C)}x.normalize()}for(let H=0;H<B.additiveAnimations.length;H++){const I=B.additiveAnimations[H];if(0===I.weight)continue;const y=e.TmpVectors.HI[2],f=e.TmpVectors.HI[3],L=e.TmpVectors.Quaternion[1];I.currentValue.decompose(f,L,y),f.multiplyToRef(M,f),e.HI.LerpToRef(M,f,I.weight,M),x.multiplyToRef(L,L),e.Quaternion.SlerpToRef(x,L,I.weight,x),y.scaleAndAddToRef(I.weight,C)}const R=f?f._animationState.workValue:e.TmpVectors.Matrix[0].clone();return e.Matrix.ComposeToRef(M,x,C,R),R}function F(B,I){if(0===B.totalWeight&&0===B.totalAdditiveWeight)return I;const C=B.animations[0],M=B.originalValue;let x=I;if(0===B.totalWeight&&B.totalAdditiveWeight>0)x.M(M);else if(1===B.animations.length){if(e.Quaternion.SlerpToRef(M,C.currentValue,Math.min(1,B.totalWeight),x),0===B.totalAdditiveWeight)return x}else if(B.animations.length>1){let C,y,f=1;if(B.totalWeight<1){const I=1-B.totalWeight;C=[],y=[],C.push(M),y.push(I)}else{if(2===B.animations.length&&(e.Quaternion.SlerpToRef(B.animations[0].currentValue,B.animations[1].currentValue,B.animations[1].weight/B.totalWeight,I),0===B.totalAdditiveWeight))return I;C=[],y=[],f=B.totalWeight}for(let I=0;I<B.animations.length;I++){const M=B.animations[I];C.push(M.currentValue),y.push(M.weight/f)}let L=0;for(let B=0;B<C.length;)B?(L+=y[B],e.Quaternion.SlerpToRef(x,C[B],y[B]/L,x),B++):(e.Quaternion.SlerpToRef(C[B],C[B+1],y[B+1]/(y[B]+y[B+1]),I),x=I,L=y[B]+y[B+1],B+=2)}for(let y=0;y<B.additiveAnimations.length;y++){const I=B.additiveAnimations[y];0!==I.weight&&(x.multiplyToRef(I.currentValue,e.TmpVectors.Quaternion[0]),e.Quaternion.SlerpToRef(x,e.TmpVectors.Quaternion[0],I.weight,x))}return x}var k,q,S=C(11440);k=S.b,(q=L.e)&&(q.prototype.copyAnimationRange=function(B,I,C){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3],y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new M.c(this.name,"_matrix",B.animations[0].framePerSecond,M.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const f=B.animations[0].getRange(I);if(!f)return!1;const L=f.from,e=f.to,g=B.animations[0].getKeys(),N=B.length,R=B.getParent(),H=this.getParent(),F=x&&R&&N&&this.length&&N!==this.length,k=F&&H&&R?H.length/R.length:1,q=x&&!H&&y&&(1!==y.x||1!==y.y||1!==y.z),S=this.animations[0].getKeys();let o,U,G;for(let M=0,V=g.length;M<V;M++)o=g[M],o.frame>=L&&o.frame<=e&&(x?(G=o.value.clone(),F?(U=G.getTranslation(),G.setTranslation(U.scaleInPlace(k))):q&&y?(U=G.getTranslation(),G.setTranslation(U.multiplyInPlace(y))):G=o.value):G=o.value,S.push({frame:o.frame+C,value:G}));return this.animations[0].createRange(I,L+C,e+C),!0}),k&&(k.prototype._animate=function(B){if(!this.animationsEnabled)return;const I=N.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=I}this.deltaTime=void 0!==B?B:this.useConstantAnimationDeltaTime?16:(I-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=I;const C=this._activeAnimatables;if(0===C.length)return;this._animationTime+=this.deltaTime;const x=this._animationTime;for(let M=0;M<C.length;M++){const B=C[M];!B._animate(x)&&B.disposeOnEnd&&M--}!function(B){if(B._registeredForLateAnimationBindings.length){for(let I=0;I<B._registeredForLateAnimationBindings.length;I++){const C=B._registeredForLateAnimationBindings.data[I];for(const B in C._lateAnimationHolders){const I=C._lateAnimationHolders[B],x=I.animations[0],y=I.originalValue;if(void 0===y||null===y)continue;const f=M.c.AllowMatrixDecomposeForInterpolation&&y.m;let L=C[B];if(f)L=H(I);else if(void 0!==y.w)L=F(I,L||e.Quaternion.Identity());else{let B=0,C=1;const f=x&&x._animationState.loopMode===M.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(I.totalWeight<1)L=f?y.clone?y.clone():y:x&&y.scale?y.scale(1-I.totalWeight):x?y*(1-I.totalWeight):y.clone?y.clone():y;else if(x){C=I.totalWeight;const M=x.weight/C;L=1!==M?x.currentValue.scale?x.currentValue.scale(M):x.currentValue*M:x.currentValue,f&&(L.addToRef?L.addToRef(y,L):L+=y),B=1}for(let M=B;M<I.animations.length;M++){const B=I.animations[M],x=B.weight/C;x&&(B.currentValue.scaleAndAddToRef?B.currentValue.scaleAndAddToRef(x,L):L+=B.currentValue*x)}for(let M=0;M<I.additiveAnimations.length;M++){const B=I.additiveAnimations[M],C=B.weight;C&&(B.currentValue.scaleAndAddToRef?B.currentValue.scaleAndAddToRef(C,L):L+=B.currentValue*C)}}C[B]=L}C._lateAnimationHolders={}}B._registeredForLateAnimationBindings.reset()}}(this)},k.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((B,I)=>B.playOrder-I.playOrder))},k.prototype.beginWeightedAnimation=function(B,I,C){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,x=arguments.length>4?arguments[4]:void 0,y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,L=arguments.length>7?arguments[7]:void 0,e=arguments.length>8?arguments[8]:void 0,g=arguments.length>9?arguments[9]:void 0,N=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const R=this.beginAnimation(B,I,C,x,y,f,L,!1,e,g,N);return R.weight=M,R},k.prototype.beginAnimation=function(B,I,C,M){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,y=arguments.length>5?arguments[5]:void 0,f=arguments.length>6?arguments[6]:void 0,L=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],e=arguments.length>8?arguments[8]:void 0,g=arguments.length>9?arguments[9]:void 0,N=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(x<0){const B=I;I=C,C=B,x=-x}I>C&&(x=-x),L&&this.stopAnimation(B,void 0,e),f||(f=new R(this,B,I,C,M,x,y,void 0,g,N));const H=!e||e(B);if(B.animations&&H&&f.appendAnimations(B,B.animations),B.getAnimatables){const N=B.getAnimatables();for(let B=0;B<N.length;B++)this.beginAnimation(N[B],I,C,M,x,y,f,L,e,g)}return f.reset(),f},k.prototype.beginHierarchyAnimation=function(B,I,C,M,x){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,L=arguments.length>7?arguments[7]:void 0,e=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],g=arguments.length>9?arguments[9]:void 0,N=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const R=B.getDescendants(I),H=[];H.push(this.beginAnimation(B,C,M,x,y,f,L,e,g,void 0,N));for(const F of R)H.push(this.beginAnimation(F,C,M,x,y,f,L,e,g,void 0,N));return H},k.prototype.beginDirectAnimation=function(B,I,C,M,x){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(y<0){const B=C;C=M,M=B,y=-y}return C>M&&(y=-y),new R(this,B,C,M,x,y,arguments.length>6?arguments[6]:void 0,I,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},k.prototype.beginDirectHierarchyAnimation=function(B,I,C,M,x,y,f,L,e){let g=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const N=B.getDescendants(I),R=[];R.push(this.beginDirectAnimation(B,C,M,x,y,f,L,e,g));for(const H of N)R.push(this.beginDirectAnimation(H,C,M,x,y,f,L,e,g));return R},k.prototype.getAnimatableByTarget=function(B){for(let I=0;I<this._activeAnimatables.length;I++)if(this._activeAnimatables[I].target===B)return this._activeAnimatables[I];return null},k.prototype.getAllAnimatablesByTarget=function(B){const I=[];for(let C=0;C<this._activeAnimatables.length;C++)this._activeAnimatables[C].target===B&&I.push(this._activeAnimatables[C]);return I},k.prototype.stopAnimation=function(B,I,C){const M=this.getAllAnimatablesByTarget(B);for(const x of M)x.stop(I,C)},k.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let B=0;B<this._activeAnimatables.length;B++)this._activeAnimatables[B].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const B of this.animationGroups)B.stop()});class o{getClassName(){return"TargetedAnimation"}serialize(){const B={};return B.animation=this.animation.serialize(),B.targetId=this.target.id,B}}class U{get mask(){return this._mask}set mask(B){this._mask!==B&&(this._mask=B,this.syncWithMask(!0))}syncWithMask(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||B){this._numActiveAnimatables=0;for(let B=0;B<this._animatables.length;++B){const I=this._animatables[B];!this.mask||this.mask.disabled||this.mask.retainsTarget(I.target.name)?(this._numActiveAnimatables++,I.paused&&I.restart()):I.paused||I.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let B=0;B<this._animatables.length;++B){const I=this._animatables[B];this.mask.retainsTarget(I.target.name)||(I.stop(),this._animatables.splice(B,1),--B)}for(let B=0;B<this._targetedAnimations.length;B++){const I=this._targetedAnimations[B];this.mask.retainsTarget(I.target.name)||(this._targetedAnimations.splice(B,1),--B)}}}get from(){return this._from}set from(B){if(this._from!==B){this._from=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].fromFrame=this._from}}}get to(){return this._to}set to(B){if(this._to!==B){this._to=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(B){if(this._speedRatio!==B){this._speedRatio=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(B){if(this._loopAnimation!==B){this._loopAnimation=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(B){if(this._isAdditive!==B){this._isAdditive=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(B){this._weight!==B&&(this._weight=B,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(B){if(this._playOrder!==B&&(this._playOrder=B,this._animatables.length>0)){for(let B=0;B<this._animatables.length;B++)this._animatables[B].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(B){if(this._enableBlending!==B&&(this._enableBlending=B,null!==B))for(let I=0;I<this._targetedAnimations.length;++I)this._targetedAnimations[I].animation.enableBlending=B}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(B){if(this._blendingSpeed!==B&&(this._blendingSpeed=B,null!==B))for(let I=0;I<this._targetedAnimations.length;++I)this._targetedAnimations[I].animation.blendingSpeed=B}getLength(B,I){B=B??this._from;return((I=I??this._to)-B)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(B){let I=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],M=arguments.length>3?arguments[3]:void 0;if(0===B.length)return null;M=M??B[0].weight;let x=Number.MAX_VALUE,y=-Number.MAX_VALUE;if(C)for(const L of B)L.from<x&&(x=L.from),L.to>y&&(y=L.to);const f=new U(B[0].name+"_merged",B[0]._scene,M);for(const L of B){C&&L.normalize(x,y);for(const B of L.targetedAnimations)f.addTargetedAnimation(B.animation,B.target);I&&L.dispose()}return f}constructor(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=B,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new x.e,this.onAnimationLoopObservable=new x.e,this.onAnimationGroupLoopObservable=new x.e,this.onAnimationGroupEndObservable=new x.e,this.onAnimationGroupPauseObservable=new x.e,this.onAnimationGroupPlayObservable=new x.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=I||y.c.LastCreatedScene,this._weight=C,this._playOrder=M,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(B,I){const C=new o;C.animation=B,C.target=I;const M=B.getKeys();return this._from>M[0].frame&&(this._from=M[0].frame),this._to<M[M.length-1].frame&&(this._to=M[M.length-1].frame),null!==this._enableBlending&&(B.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(B.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(C),this._shouldStart=!0,C}removeTargetedAnimation(B){for(let I=this._targetedAnimations.length-1;I>-1;I--){this._targetedAnimations[I].animation===B&&this._targetedAnimations.splice(I,1)}}normalize(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==B&&(B=this._from),null==I&&(I=this._to);for(let C=0;C<this._targetedAnimations.length;C++){const M=this._targetedAnimations[C].animation.getKeys(),x=M[0],y=M[M.length-1];if(x.frame>B){const I={frame:B,value:x.value,inTangent:x.inTangent,outTangent:x.outTangent,interpolation:x.interpolation};M.splice(0,0,I)}if(y.frame<I){const B={frame:I,value:y.value,inTangent:y.inTangent,outTangent:y.outTangent,interpolation:y.interpolation};M.push(B)}}return this._from=B,this._to=I,this}_processLoop(B,I,C){B.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(I),this._animationLoopFlags[C]||(this._animationLoopFlags[C]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0],I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0,M=arguments.length>3?arguments[3]:void 0,x=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=B,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let y=0;y<this._targetedAnimations.length;y++){const f=this._targetedAnimations[y],L=this._scene.beginDirectAnimation(f.target,[f.animation],void 0!==C?C:this._from,void 0!==M?M:this._to,B,I,void 0,void 0,void 0!==x?x:this._isAdditive);L.weight=this._weight,L.playOrder=this._playOrder,L.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(f),this._checkAnimationGroupEnded(L)},this._processLoop(L,f,y),this._animatables.push(L)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=I,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let B=0;B<this._animatables.length;B++){this._animatables[B].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(B){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==B&&(this.loopAnimation=B),this.restart()):(this.stop(),this.start(B,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let B=0;B<this._animatables.length;B++){this._animatables[B].reset()}return this}restart(){if(!this._isStarted)return this;for(let B=0;B<this._animatables.length;B++){this._animatables[B].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const I=this._animatables.slice();for(let M=0;M<I.length;M++)I[M].stop(void 0,void 0,!0,B);let C=0;for(let M=0;M<this._scene._activeAnimatables.length;M++){const I=this._scene._activeAnimatables[M];I._runtimeAnimations.length>0?this._scene._activeAnimatables[C++]=I:B&&this._checkAnimationGroupEnded(I,B)}return this._scene._activeAnimatables.length=C,this._isStarted=!1,this}setWeightForAllAnimatables(B){for(let I=0;I<this._animatables.length;I++){this._animatables[I].weight=B}return this}syncAllAnimationsWith(B){for(let I=0;I<this._animatables.length;I++){this._animatables[I].syncWith(B)}return this}goToFrame(B){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let C=0;C<this._animatables.length;C++){this._animatables[C].goToFrame(B,I)}return this}getCurrentFrame(){var B;return(null===(B=this.animatables[0])||void 0===B?void 0:B.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const B=this._scene.animationGroups.indexOf(this);if(B>-1&&this._scene.animationGroups.splice(B,1),this._parentContainer){const B=this._parentContainer.animationGroups.indexOf(this);B>-1&&this._parentContainer.animationGroups.splice(B,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(B){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const C=this._animatables.indexOf(B);C>-1&&this._animatables.splice(C,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,I||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(B,I){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const M=new U(B||this.name,this._scene,this._weight,this._playOrder);M._from=this.from,M._to=this.to,M._speedRatio=this.speedRatio,M._loopAnimation=this.loopAnimation,M._isAdditive=this.isAdditive,M._enableBlending=this.enableBlending,M._blendingSpeed=this.blendingSpeed,M.metadata=this.metadata,M.mask=this.mask;for(const x of this._targetedAnimations)M.addTargetedAnimation(C?x.animation.clone():x.animation,I?I(x.target):x.target);return M}serialize(){const B={};B.name=this.name,B.from=this.from,B.to=this.to,B.speedRatio=this.speedRatio,B.loopAnimation=this.loopAnimation,B.isAdditive=this.isAdditive,B.weight=this.weight,B.playOrder=this.playOrder,B.enableBlending=this.enableBlending,B.blendingSpeed=this.blendingSpeed,B.targetedAnimations=[];for(let I=0;I<this.targetedAnimations.length;I++){const C=this.targetedAnimations[I];B.targetedAnimations[I]=C.serialize()}return f.e&&f.e.HasTags(this)&&(B.tags=f.e.GetTags(this)),this.metadata&&(B.metadata=this.metadata),B}static Parse(B,I){const C=new U(B.name,I,B.weight,B.playOrder);for(let x=0;x<B.targetedAnimations.length;x++){const y=B.targetedAnimations[x],f=M.c.Parse(y.animation),L=y.targetId;if("influence"===y.animation.property){const B=I.getMorphTargetById(L);B&&C.addTargetedAnimation(f,B)}else{const B=I.getNodeById(L);null!=B&&C.addTargetedAnimation(f,B)}}return f.e&&f.e.AddTagsTo(C,B.tags),null!==B.from&&null!==B.to&&C.normalize(B.from,B.to),void 0!==B.speedRatio&&(C._speedRatio=B.speedRatio),void 0!==B.loopAnimation&&(C._loopAnimation=B.loopAnimation),void 0!==B.isAdditive&&(C._isAdditive=B.isAdditive),void 0!==B.weight&&(C._weight=B.weight),void 0!==B.playOrder&&(C._playOrder=B.playOrder),void 0!==B.enableBlending&&(C._enableBlending=B.enableBlending),void 0!==B.blendingSpeed&&(C._blendingSpeed=B.blendingSpeed),void 0!==B.metadata&&(C.metadata=B.metadata),C}static MakeAnimationAdditive(B,I,C){let x;x="object"===typeof I?I:{referenceFrame:I,range:C,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let y=B;x.cloneOriginalAnimationGroup&&(y=B.clone(x.clonedAnimationGroupName||y.name));const f=y.targetedAnimations;for(let L=0;L<f.length;L++){const B=f[L];B.animation=M.c.MakeAnimationAdditive(B.animation,x)}if(y.isAdditive=!0,x.clipKeys){let B=Number.MAX_VALUE,I=-Number.MAX_VALUE;const C=y.targetedAnimations;for(let M=0;M<C.length;M++){const x=C[M].animation.getKeys();B>x[0].frame&&(B=x[0].frame),I<x[x.length-1].frame&&(I=x[x.length-1].frame)}y._from=B,y._to=I}return y}static ClipKeys(B,I,C,M,x){const y=B.clone(M||B.name);return U.ClipKeysInPlace(y,I,C,x)}static ClipKeysInPlace(B,I,C,M){return U.ClipInPlace(B,I,C,M,!1)}static ClipFrames(B,I,C,M,x){const y=B.clone(M||B.name);return U.ClipFramesInPlace(y,I,C,x)}static ClipFramesInPlace(B,I,C,M){return U.ClipInPlace(B,I,C,M,!0)}static ClipInPlace(B,I,C,M){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4],y=Number.MAX_VALUE,f=-Number.MAX_VALUE;const L=B.targetedAnimations;for(let e=0;e<L.length;e++){const B=L[e],g=M?B.animation:B.animation.clone();x&&(g.createKeyForFrame(I),g.createKeyForFrame(C));const N=g.getKeys(),R=[];let H=Number.MAX_VALUE;for(let M=0;M<N.length;M++){const B=N[M];if(!x&&M>=I&&M<=C||x&&B.frame>=I&&B.frame<=C){const I={frame:B.frame,value:B.value.clone?B.value.clone():B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation,lockedTangent:B.lockedTangent};H===Number.MAX_VALUE&&(H=I.frame),I.frame-=H,R.push(I)}}0!==R.length?(y>R[0].frame&&(y=R[0].frame),f<R[R.length-1].frame&&(f=R[R.length-1].frame),g.setKeys(R,!0),B.animation=g):(L.splice(e,1),e--)}return B._from=y,B._to=f,B}getClassName(){return"AnimationGroup"}toString(B){let I="Name: "+this.name;return I+=", type: "+this.getClassName(),B&&(I+=", from: "+this._from,I+=", to: "+this._to,I+=", isStarted: "+this._isStarted,I+=", speedRatio: "+this._speedRatio,I+=", targetedAnimations length: "+this._targetedAnimations.length,I+=", animatables length: "+this._animatables),I}}}}]);