"use strict";(self.b15p7b72fr8=self.b15p7b72fr8||[]).push([[78],{15796:(s,k,h)=>{h.r(k),h.d(k,{AnimationGroup:()=>R,TargetedAnimation:()=>P});var A=h(13128),g=h(12408),ms=h(12445),i=h(12631),K=h(14228),H=h(12590);class O{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(s,k,h,g){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=k,this._target=s,this._scene=h,this._host=g,this._activeTargets=[],k._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===A.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=H.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const s={frame:0,value:this._minValue};this._keys.splice(0,0,s)}if(this._target instanceof Array){let s=0;for(const k of this._target)this._preparePath(k,s),this._getOriginalValues(s),s++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const ms=k.getEvents();if(ms&&ms.length>0)for(const A of ms)this._events.push(A._clone());this._enableBlending=s&&s.animationPropertiesOverride?s.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=this._animation.targetPropertyPath;if(h.length>1){let A=s;for(let s=0;s<h.length-1;s++){const k=h[s];if(A=A[k],void 0===A)throw new Error(`Invalid property (${k}) in property path (${h.join(".")})`)}this._targetPath=h[h.length-1],this._activeTargets[k]=A}else this._targetPath=h[0],this._activeTargets[k]=s;if(void 0===this._activeTargets[k][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${h.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let s=0;for(const k of this._target)void 0!==this._originalValue[s]&&this._setValue(k,this._activeTargets[s],this._originalValue[s],-1,s),s++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let s=0;s<this._events.length;s++)this._events[s].isDone=!1}isStopped(){return this._stopped}dispose(){const s=this._animation.runtimeAnimations.indexOf(this);s>-1&&this._animation.runtimeAnimations.splice(s,1)}setValue(s,k){if(this._targetIsArray)for(let h=0;h<this._target.length;h++){const A=this._target[h];this._setValue(A,this._activeTargets[h],s,k,h)}else this._setValue(this._target,this._directTarget,s,k,0)}_getOriginalValues(){let s,k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const h=this._activeTargets[k];s=h.getLocalMatrix&&"_matrix"===this._targetPath?h.getLocalMatrix():h[this._targetPath],s&&s.clone?this._originalValue[k]=s.clone():this._originalValue[k]=s}_registerTargetForLateAnimationBinding(s,k){const h=s.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(h),h._lateAnimationHolders||(h._lateAnimationHolders={}),h._lateAnimationHolders[s.targetPath]||(h._lateAnimationHolders[s.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:k}),s.isAdditive?(h._lateAnimationHolders[s.targetPath].additiveAnimations.push(s),h._lateAnimationHolders[s.targetPath].totalAdditiveWeight+=s.weight):(h._lateAnimationHolders[s.targetPath].animations.push(s),h._lateAnimationHolders[s.targetPath].totalWeight+=s.weight)}_setValue(s,k,h,g,ms){if(this._currentActiveTarget=k,this._weight=g,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const s=k[this._targetPath];s.clone?this._originalBlendValue=s.clone():this._originalBlendValue=s}this._originalBlendValue.m?A.c.AllowMatrixDecomposeForInterpolation?this._currentValue?H.Matrix.DecomposeLerpToRef(this._originalBlendValue,h,this._blendingFactor,this._currentValue):this._currentValue=H.Matrix.DecomposeLerp(this._originalBlendValue,h,this._blendingFactor):this._currentValue?H.Matrix.LerpToRef(this._originalBlendValue,h,this._blendingFactor,this._currentValue):this._currentValue=H.Matrix.Lerp(this._originalBlendValue,h,this._blendingFactor):this._currentValue=A.c._UniversalLerp(this._originalBlendValue,h,this._blendingFactor);const g=s&&s.animationPropertiesOverride?s.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=g}else this._currentValue?this._currentValue.H?this._currentValue.H(h):this._currentValue=h:null!==h&&void 0!==h&&h.clone?this._currentValue=h.clone():this._currentValue=h;-1!==g?this._registerTargetForLateAnimationBinding(this,this._originalValue[ms]):this._animationState.loopMode===A.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[ms],k[this._targetPath]):k[this._targetPath]=this._originalValue[ms]+this._currentValue:k[this._targetPath]=this._currentValue,s.mS&&s.mS(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const h=this._animation.getKeys();s<h[0].frame?s=h[0].frame:s>h[h.length-1].frame&&(s=h[h.length-1].frame);const A=this._events;if(A.length)for(let ms=0;ms<A.length;ms++)A[ms].onlyOnce||(A[ms].isDone=A[ms].frame<s);this._currentFrame=s;const g=this._animation._interpolate(s,this._animationState);this.setValue(g,k)}_prepareForSpeedRatioChange(s){const k=this._previousElapsedTime*(this._animation.framePerSecond*s)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-k}animate(s,k,h,g,ms){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const K=this._animation,H=K.targetPropertyPath;if(!H||H.length<1)return this._stopped=!0,!1;let O,c=!0;const S=this._events;let a=0;if(this._coreRuntimeAnimation)a=h-k,O=this._coreRuntimeAnimation.currentFrame,this._currentFrame=O,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let i;(k<this._minFrame||k>this._maxFrame)&&(k=this._minFrame),(h<this._minFrame||h>this._maxFrame)&&(h=this._maxFrame),a=h-k;let H=s*(K.framePerSecond*ms)/1e3+this._absoluteFrameOffset,r=0,d=!1;const E=g&&this._animationState.loopMode===A.c.ANIMATIONLOOPMODE_YOYO;if(E){const s=(H-k)/a,h=Math.sin(s*Math.PI);H=Math.abs(h)*a+k;const A=h>=0?1:-1;this._yoyoDirection!==A&&(d=!0),this._yoyoDirection=A}if(this._previousElapsedTime=s,this._previousAbsoluteFrame=H,!g&&h>=k&&(H>=a&&ms>0||H<=0&&ms<0))c=!1,r=K._getKeyValue(this._maxValue);else if(!g&&k>=h&&(H<=a&&ms<0||H>=0&&ms>0))c=!1,r=K._getKeyValue(this._minValue);else if(this._animationState.loopMode!==A.c.ANIMATIONLOOPMODE_CYCLE){const s=h.toString()+k.toString();if(!this._offsetsCache[s]){this._animationState.repeatCount=0,this._animationState.loopMode=A.c.ANIMATIONLOOPMODE_CYCLE;const g=K._interpolate(k,this._animationState),ms=K._interpolate(h,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),K.dataType){case A.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[s]=ms-g;break;case A.c.ANIMATIONTYPE_QUATERNION:case A.c.ANIMATIONTYPE_VECTOR3:case A.c.ANIMATIONTYPE_VECTOR2:case A.c.ANIMATIONTYPE_SIZE:case A.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[s]=ms.Rk(g)}this._highLimitsCache[s]=ms}r=this._highLimitsCache[s],i=this._offsetsCache[s]}if(void 0===i)switch(K.dataType){case A.c.ANIMATIONTYPE_FLOAT:i=0;break;case A.c.ANIMATIONTYPE_QUATERNION:i=A.n;break;case A.c.ANIMATIONTYPE_VECTOR3:i=A.w;break;case A.c.ANIMATIONTYPE_VECTOR2:i=A.s;break;case A.c.ANIMATIONTYPE_SIZE:i=A.p;break;case A.c.ANIMATIONTYPE_COLOR3:i=A.g;break;case A.c.ANIMATIONTYPE_COLOR4:i=A.k}if(this._host&&this._host.syncRoot){const s=this._host.syncRoot;O=k+a*((s.masterFrame-s.fromFrame)/(s.toFrame-s.fromFrame))}else O=H>0&&k>h||H<0&&k<h?c&&0!==a?h+H%a:k:c&&0!==a?k+H%a:h;if(!E&&(ms>0&&this.currentFrame>O||ms<0&&this.currentFrame<O)||E&&d){this._onLoop();for(let s=0;s<S.length;s++)S[s].onlyOnce||(S[s].isDone=!1);this._animationState.key=ms>0?0:K.getKeys().length-1}this._currentFrame=O,this._animationState.repeatCount=0===a?0:H/a|0,this._animationState.highLimitValue=r,this._animationState.offsetValue=i}const r=K._interpolate(O,this._animationState);if(this.setValue(r,i),S.length)for(let A=0;A<S.length;A++)if(a>=0&&O>=S[A].frame&&S[A].frame>=k||a<0&&O<=S[A].frame&&S[A].frame<=k){const s=S[A];s.isDone||(s.onlyOnce&&(S.splice(A,1),A--),s.isDone=!0,s.action(O))}return c||(this._stopped=!0),c}}var c=h(12435);class S{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(s){this._weight=-1!==s?Math.min(Math.max(s,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(s){for(let k=0;k<this._runtimeAnimations.length;k++){this._runtimeAnimations[k]._prepareForSpeedRatioChange(s)}this._speedRatio=s,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(s,k){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,ms=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,K=arguments.length>6?arguments[6]:void 0,H=arguments.length>7?arguments[7]:void 0,O=arguments.length>8?arguments[8]:void 0,c=arguments.length>9&&void 0!==arguments[9]&&arguments[9],S=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=k,this.fromFrame=h,this.toFrame=A,this.loopAnimation=ms,this.onAnimationEnd=K,this.onAnimationLoop=O,this.isAdditive=c,this.playOrder=S,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.VK=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new g.c,this.onAnimationLoopObservable=new g.c,this._scene=s,H&&this.appendAnimations(k,H),this._speedRatio=i,s._activeAnimatables.push(this)}syncWith(s){if(this._syncRoot=s,s){const s=this._scene._activeAnimatables.indexOf(this);s>-1&&(this._scene._activeAnimatables.splice(s,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(s,k){for(let h=0;h<k.length;h++){const A=k[h],g=new O(s,A,this._scene,this);g._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(g)}}getAnimationByTargetProperty(s){const k=this._runtimeAnimations;for(let h=0;h<k.length;h++)if(k[h].animation.targetProperty===s)return k[h].animation;return null}getRuntimeAnimationByTargetProperty(s){const k=this._runtimeAnimations;for(let h=0;h<k.length;h++)if(k[h].animation.targetProperty===s)return k[h];return null}reset(){const s=this._runtimeAnimations;for(let k=0;k<s.length;k++)s[k].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(s){const k=this._runtimeAnimations;for(let h=0;h<k.length;h++)k[h].animation.enableBlending=!0,k[h].animation.blendingSpeed=s}disableBlending(){const s=this._runtimeAnimations;for(let k=0;k<s.length;k++)s[k].animation.enableBlending=!1}goToFrame(s){let k=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const h=this._runtimeAnimations;if(h[0]){const k=h[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??h[0].currentFrame;const A=0===this.speedRatio?0:(s-this._frameToSyncFromJump)/k*1e3/this.speedRatio;this._manualJumpDelay=-A}for(let A=0;A<h.length;A++)h[A].goToFrame(s,k?this._weight:-1);this._goToFrame=s}get paused(){return this.VK}pause(){this.VK||(this.VK=!0)}restart(){this.VK=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(s,k){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],A=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(s||k){const g=this._scene._activeAnimatables.indexOf(this);if(g>-1){const ms=this._runtimeAnimations;for(let h=ms.length-1;h>=0;h--){const A=ms[h];s&&A.animation.name!=s||(k&&!k(A.target)||(A.dispose(),ms.splice(h,1)))}0==ms.length&&(h||this._scene._activeAnimatables.splice(g,1),A||this._raiseOnAnimationEnd())}}else{const s=this._scene._activeAnimatables.indexOf(this);if(s>-1){h||this._scene._activeAnimatables.splice(s,1);const k=this._runtimeAnimations;for(let s=0;s<k.length;s++)k[s].dispose();this._runtimeAnimations.length=0,A||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((s=>{this.onAnimationEndObservable.add((()=>{s(this)}),void 0,void 0,this,!0)}))}_animate(s){if(this.VK)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=s),!0;if(null===this._localDelayOffset?(this._localDelayOffset=s,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=s-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let k=!1;const h=this._runtimeAnimations;let A;for(A=0;A<h.length;A++){const g=h[A].animate(s-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);k=k||g}if(this.animationStarted=k,!k){if(this.disposeOnEnd)for(A=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(A,1),A=0;A<h.length;A++)h[A].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return k}}function a(s){if(0===s.totalWeight&&0===s.totalAdditiveWeight)return s.originalValue;let k=1;const h=H.TmpVectors.Pk[0],A=H.TmpVectors.Pk[1],g=H.TmpVectors.Quaternion[0];let ms=0;const i=s.animations[0],K=s.originalValue;let O=1,c=!1;if(s.totalWeight<1)O=1-s.totalWeight,K.decompose(A,g,h);else{if(ms=1,k=s.totalWeight,O=i.weight/k,1==O){if(!s.totalAdditiveWeight)return i.currentValue;c=!0}i.currentValue.decompose(A,g,h)}if(!c){A.scaleInPlace(O),h.scaleInPlace(O),g.scaleInPlace(O);for(let i=ms;i<s.animations.length;i++){const ms=s.animations[i];if(0===ms.weight)continue;O=ms.weight/k;const K=H.TmpVectors.Pk[2],c=H.TmpVectors.Pk[3],S=H.TmpVectors.Quaternion[1];ms.currentValue.decompose(c,S,K),c.scaleAndAddToRef(O,A),S.scaleAndAddToRef(H.Quaternion.Dot(g,S)>0?O:-O,g),K.scaleAndAddToRef(O,h)}g.normalize()}for(let a=0;a<s.additiveAnimations.length;a++){const k=s.additiveAnimations[a];if(0===k.weight)continue;const ms=H.TmpVectors.Pk[2],i=H.TmpVectors.Pk[3],K=H.TmpVectors.Quaternion[1];k.currentValue.decompose(i,K,ms),i.multiplyToRef(A,i),H.Pk.LerpToRef(A,i,k.weight,A),g.multiplyToRef(K,K),H.Quaternion.SlerpToRef(g,K,k.weight,g),ms.scaleAndAddToRef(k.weight,h)}const S=i?i._animationState.workValue:H.TmpVectors.Matrix[0].clone();return H.Matrix.ComposeToRef(A,g,h,S),S}function r(s,k){if(0===s.totalWeight&&0===s.totalAdditiveWeight)return k;const h=s.animations[0],A=s.originalValue;let g=k;if(0===s.totalWeight&&s.totalAdditiveWeight>0)g.H(A);else if(1===s.animations.length){if(H.Quaternion.SlerpToRef(A,h.currentValue,Math.min(1,s.totalWeight),g),0===s.totalAdditiveWeight)return g}else if(s.animations.length>1){let h,ms,i=1;if(s.totalWeight<1){const k=1-s.totalWeight;h=[],ms=[],h.push(A),ms.push(k)}else{if(2===s.animations.length&&(H.Quaternion.SlerpToRef(s.animations[0].currentValue,s.animations[1].currentValue,s.animations[1].weight/s.totalWeight,k),0===s.totalAdditiveWeight))return k;h=[],ms=[],i=s.totalWeight}for(let k=0;k<s.animations.length;k++){const A=s.animations[k];h.push(A.currentValue),ms.push(A.weight/i)}let K=0;for(let s=0;s<h.length;)s?(K+=ms[s],H.Quaternion.SlerpToRef(g,h[s],ms[s]/K,g),s++):(H.Quaternion.SlerpToRef(h[s],h[s+1],ms[s+1]/(ms[s]+ms[s+1]),k),g=k,K=ms[s]+ms[s+1],s+=2)}for(let ms=0;ms<s.additiveAnimations.length;ms++){const k=s.additiveAnimations[ms];0!==k.weight&&(g.multiplyToRef(k.currentValue,H.TmpVectors.Quaternion[0]),H.Quaternion.SlerpToRef(g,H.TmpVectors.Quaternion[0],k.weight,g))}return g}var d,E,j=h(12836);d=j.d,(E=K.e)&&(E.prototype.copyAnimationRange=function(s,k,h){let g=arguments.length>3&&void 0!==arguments[3]&&arguments[3],ms=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new A.c(this.name,"_matrix",s.animations[0].framePerSecond,A.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const i=s.animations[0].getRange(k);if(!i)return!1;const K=i.from,H=i.to,O=s.animations[0].getKeys(),c=s.length,S=s.getParent(),a=this.getParent(),r=g&&S&&c&&this.length&&c!==this.length,d=r&&a&&S?a.length/S.length:1,E=g&&!a&&ms&&(1!==ms.x||1!==ms.y||1!==ms.z),j=this.animations[0].getKeys();let P,R,D;for(let A=0,w=O.length;A<w;A++)P=O[A],P.frame>=K&&P.frame<=H&&(g?(D=P.value.clone(),r?(R=D.getTranslation(),D.setTranslation(R.scaleInPlace(d))):E&&ms?(R=D.getTranslation(),D.setTranslation(R.multiplyInPlace(ms))):D=P.value):D=P.value,j.push({frame:P.frame+h,value:D}));return this.animations[0].createRange(k,K+h,H+h),!0}),d&&(d.prototype._animate=function(s){if(!this.animationsEnabled)return;const k=c.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=k}this.deltaTime=void 0!==s?s:this.useConstantAnimationDeltaTime?16:(k-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=k;const h=this._activeAnimatables;if(0===h.length)return;this._animationTime+=this.deltaTime;const g=this._animationTime;for(let A=0;A<h.length;A++){const s=h[A];!s._animate(g)&&s.disposeOnEnd&&A--}!function(s){if(s._registeredForLateAnimationBindings.length){for(let k=0;k<s._registeredForLateAnimationBindings.length;k++){const h=s._registeredForLateAnimationBindings.data[k];for(const s in h._lateAnimationHolders){const k=h._lateAnimationHolders[s],g=k.animations[0],ms=k.originalValue;if(void 0===ms||null===ms)continue;const i=A.c.AllowMatrixDecomposeForInterpolation&&ms.m;let K=h[s];if(i)K=a(k);else if(void 0!==ms.w)K=r(k,K||H.Quaternion.Identity());else{let s=0,h=1;const i=g&&g._animationState.loopMode===A.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(k.totalWeight<1)K=i?ms.clone?ms.clone():ms:g&&ms.scale?ms.scale(1-k.totalWeight):g?ms*(1-k.totalWeight):ms.clone?ms.clone():ms;else if(g){h=k.totalWeight;const A=g.weight/h;K=1!==A?g.currentValue.scale?g.currentValue.scale(A):g.currentValue*A:g.currentValue,i&&(K.addToRef?K.addToRef(ms,K):K+=ms),s=1}for(let A=s;A<k.animations.length;A++){const s=k.animations[A],g=s.weight/h;g&&(s.currentValue.scaleAndAddToRef?s.currentValue.scaleAndAddToRef(g,K):K+=s.currentValue*g)}for(let A=0;A<k.additiveAnimations.length;A++){const s=k.additiveAnimations[A],h=s.weight;h&&(s.currentValue.scaleAndAddToRef?s.currentValue.scaleAndAddToRef(h,K):K+=s.currentValue*h)}}h[s]=K}h._lateAnimationHolders={}}s._registeredForLateAnimationBindings.reset()}}(this)},d.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((s,k)=>s.playOrder-k.playOrder))},d.prototype.beginWeightedAnimation=function(s,k,h){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,g=arguments.length>4?arguments[4]:void 0,ms=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0,K=arguments.length>7?arguments[7]:void 0,H=arguments.length>8?arguments[8]:void 0,O=arguments.length>9?arguments[9]:void 0,c=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const S=this.beginAnimation(s,k,h,g,ms,i,K,!1,H,O,c);return S.weight=A,S},d.prototype.beginAnimation=function(s,k,h,A){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,ms=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,K=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],H=arguments.length>8?arguments[8]:void 0,O=arguments.length>9?arguments[9]:void 0,c=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(g<0){const s=k;k=h,h=s,g=-g}k>h&&(g=-g),K&&this.stopAnimation(s,void 0,H),i||(i=new S(this,s,k,h,A,g,ms,void 0,O,c));const a=!H||H(s);if(s.animations&&a&&i.appendAnimations(s,s.animations),s.getAnimatables){const c=s.getAnimatables();for(let s=0;s<c.length;s++)this.beginAnimation(c[s],k,h,A,g,ms,i,K,H,O)}return i.reset(),i},d.prototype.beginHierarchyAnimation=function(s,k,h,A,g){let ms=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0,K=arguments.length>7?arguments[7]:void 0,H=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],O=arguments.length>9?arguments[9]:void 0,c=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const S=s.getDescendants(k),a=[];a.push(this.beginAnimation(s,h,A,g,ms,i,K,H,O,void 0,c));for(const r of S)a.push(this.beginAnimation(r,h,A,g,ms,i,K,H,O,void 0,c));return a},d.prototype.beginDirectAnimation=function(s,k,h,A,g){let ms=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(ms<0){const s=h;h=A,A=s,ms=-ms}return h>A&&(ms=-ms),new S(this,s,h,A,g,ms,arguments.length>6?arguments[6]:void 0,k,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},d.prototype.beginDirectHierarchyAnimation=function(s,k,h,A,g,ms,i,K,H){let O=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const c=s.getDescendants(k),S=[];S.push(this.beginDirectAnimation(s,h,A,g,ms,i,K,H,O));for(const a of c)S.push(this.beginDirectAnimation(a,h,A,g,ms,i,K,H,O));return S},d.prototype.getAnimatableByTarget=function(s){for(let k=0;k<this._activeAnimatables.length;k++)if(this._activeAnimatables[k].target===s)return this._activeAnimatables[k];return null},d.prototype.getAllAnimatablesByTarget=function(s){const k=[];for(let h=0;h<this._activeAnimatables.length;h++)this._activeAnimatables[h].target===s&&k.push(this._activeAnimatables[h]);return k},d.prototype.stopAnimation=function(s,k,h){const A=this.getAllAnimatablesByTarget(s);for(const g of A)g.stop(k,h)},d.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let s=0;s<this._activeAnimatables.length;s++)this._activeAnimatables[s].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const s of this.animationGroups)s.stop()});class P{getClassName(){return"TargetedAnimation"}serialize(){const s={};return s.animation=this.animation.serialize(),s.targetId=this.target.id,s}}class R{get mask(){return this._mask}set mask(s){this._mask!==s&&(this._mask=s,this.syncWithMask(!0))}syncWithMask(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||s){this._numActiveAnimatables=0;for(let s=0;s<this._animatables.length;++s){const k=this._animatables[s];!this.mask||this.mask.disabled||this.mask.retainsTarget(k.target.name)?(this._numActiveAnimatables++,k.paused&&k.restart()):k.paused||k.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let s=0;s<this._animatables.length;++s){const k=this._animatables[s];this.mask.retainsTarget(k.target.name)||(k.stop(),this._animatables.splice(s,1),--s)}for(let s=0;s<this._targetedAnimations.length;s++){const k=this._targetedAnimations[s];this.mask.retainsTarget(k.target.name)||(this._targetedAnimations.splice(s,1),--s)}}}get from(){return this._from}set from(s){if(this._from!==s){this._from=s;for(let s=0;s<this._animatables.length;s++){this._animatables[s].fromFrame=this._from}}}get to(){return this._to}set to(s){if(this._to!==s){this._to=s;for(let s=0;s<this._animatables.length;s++){this._animatables[s].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(s){if(this._speedRatio!==s){this._speedRatio=s;for(let s=0;s<this._animatables.length;s++){this._animatables[s].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(s){if(this._loopAnimation!==s){this._loopAnimation=s;for(let s=0;s<this._animatables.length;s++){this._animatables[s].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(s){if(this._isAdditive!==s){this._isAdditive=s;for(let s=0;s<this._animatables.length;s++){this._animatables[s].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(s){this._weight!==s&&(this._weight=s,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(s){if(this._playOrder!==s&&(this._playOrder=s,this._animatables.length>0)){for(let s=0;s<this._animatables.length;s++)this._animatables[s].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(s){if(this._enableBlending!==s&&(this._enableBlending=s,null!==s))for(let k=0;k<this._targetedAnimations.length;++k)this._targetedAnimations[k].animation.enableBlending=s}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(s){if(this._blendingSpeed!==s&&(this._blendingSpeed=s,null!==s))for(let k=0;k<this._targetedAnimations.length;++k)this._targetedAnimations[k].animation.blendingSpeed=s}getLength(s,k){s=s??this._from;return((k=k??this._to)-s)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(s){let k=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],A=arguments.length>3?arguments[3]:void 0;if(0===s.length)return null;A=A??s[0].weight;let g=Number.MAX_VALUE,ms=-Number.MAX_VALUE;if(h)for(const K of s)K.from<g&&(g=K.from),K.to>ms&&(ms=K.to);const i=new R(s[0].name+"_merged",s[0]._scene,A);for(const K of s){h&&K.normalize(g,ms);for(const s of K.targetedAnimations)i.addTargetedAnimation(s.animation,s.target);k&&K.dispose()}return i}constructor(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=s,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new g.c,this.onAnimationLoopObservable=new g.c,this.onAnimationGroupLoopObservable=new g.c,this.onAnimationGroupEndObservable=new g.c,this.onAnimationGroupPauseObservable=new g.c,this.onAnimationGroupPlayObservable=new g.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=k||ms.b.LastCreatedScene,this._weight=h,this._playOrder=A,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(s,k){const h=new P;h.animation=s,h.target=k;const A=s.getKeys();return this._from>A[0].frame&&(this._from=A[0].frame),this._to<A[A.length-1].frame&&(this._to=A[A.length-1].frame),null!==this._enableBlending&&(s.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(s.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(h),this._shouldStart=!0,h}removeTargetedAnimation(s){for(let k=this._targetedAnimations.length-1;k>-1;k--){this._targetedAnimations[k].animation===s&&this._targetedAnimations.splice(k,1)}}normalize(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==s&&(s=this._from),null==k&&(k=this._to);for(let h=0;h<this._targetedAnimations.length;h++){const A=this._targetedAnimations[h].animation.getKeys(),g=A[0],ms=A[A.length-1];if(g.frame>s){const k={frame:s,value:g.value,inTangent:g.inTangent,outTangent:g.outTangent,interpolation:g.interpolation};A.splice(0,0,k)}if(ms.frame<k){const s={frame:k,value:ms.value,inTangent:ms.inTangent,outTangent:ms.outTangent,interpolation:ms.interpolation};A.push(s)}}return this._from=s,this._to=k,this}_processLoop(s,k,h){s.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(k),this._animationLoopFlags[h]||(this._animationLoopFlags[h]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0],k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0,A=arguments.length>3?arguments[3]:void 0,g=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=s,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let ms=0;ms<this._targetedAnimations.length;ms++){const i=this._targetedAnimations[ms],K=this._scene.beginDirectAnimation(i.target,[i.animation],void 0!==h?h:this._from,void 0!==A?A:this._to,s,k,void 0,void 0,void 0!==g?g:this._isAdditive);K.weight=this._weight,K.playOrder=this._playOrder,K.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(i),this._checkAnimationGroupEnded(K)},this._processLoop(K,i,ms),this._animatables.push(K)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=k,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let s=0;s<this._animatables.length;s++){this._animatables[s].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(s){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==s&&(this.loopAnimation=s),this.restart()):(this.stop(),this.start(s,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let s=0;s<this._animatables.length;s++){this._animatables[s].reset()}return this}restart(){if(!this._isStarted)return this;for(let s=0;s<this._animatables.length;s++){this._animatables[s].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const k=this._animatables.slice();for(let A=0;A<k.length;A++)k[A].stop(void 0,void 0,!0,s);let h=0;for(let A=0;A<this._scene._activeAnimatables.length;A++){const k=this._scene._activeAnimatables[A];k._runtimeAnimations.length>0?this._scene._activeAnimatables[h++]=k:s&&this._checkAnimationGroupEnded(k,s)}return this._scene._activeAnimatables.length=h,this._isStarted=!1,this}setWeightForAllAnimatables(s){for(let k=0;k<this._animatables.length;k++){this._animatables[k].weight=s}return this}syncAllAnimationsWith(s){for(let k=0;k<this._animatables.length;k++){this._animatables[k].syncWith(s)}return this}goToFrame(s){let k=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let h=0;h<this._animatables.length;h++){this._animatables[h].goToFrame(s,k)}return this}getCurrentFrame(){var s;return(null===(s=this.animatables[0])||void 0===s?void 0:s.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const s=this._scene.animationGroups.indexOf(this);if(s>-1&&this._scene.animationGroups.splice(s,1),this._parentContainer){const s=this._parentContainer.animationGroups.indexOf(this);s>-1&&this._parentContainer.animationGroups.splice(s,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(s){let k=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const h=this._animatables.indexOf(s);h>-1&&this._animatables.splice(h,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,k||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(s,k){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const A=new R(s||this.name,this._scene,this._weight,this._playOrder);A._from=this.from,A._to=this.to,A._speedRatio=this.speedRatio,A._loopAnimation=this.loopAnimation,A._isAdditive=this.isAdditive,A._enableBlending=this.enableBlending,A._blendingSpeed=this.blendingSpeed,A.metadata=this.metadata,A.mask=this.mask;for(const g of this._targetedAnimations)A.addTargetedAnimation(h?g.animation.clone():g.animation,k?k(g.target):g.target);return A}serialize(){const s={};s.name=this.name,s.from=this.from,s.to=this.to,s.speedRatio=this.speedRatio,s.loopAnimation=this.loopAnimation,s.isAdditive=this.isAdditive,s.weight=this.weight,s.playOrder=this.playOrder,s.enableBlending=this.enableBlending,s.blendingSpeed=this.blendingSpeed,s.targetedAnimations=[];for(let k=0;k<this.targetedAnimations.length;k++){const h=this.targetedAnimations[k];s.targetedAnimations[k]=h.serialize()}return i.e&&i.e.HasTags(this)&&(s.tags=i.e.GetTags(this)),this.metadata&&(s.metadata=this.metadata),s}static Parse(s,k){const h=new R(s.name,k,s.weight,s.playOrder);for(let g=0;g<s.targetedAnimations.length;g++){const ms=s.targetedAnimations[g],i=A.c.Parse(ms.animation),K=ms.targetId;if("influence"===ms.animation.property){const s=k.getMorphTargetById(K);s&&h.addTargetedAnimation(i,s)}else{const s=k.getNodeById(K);null!=s&&h.addTargetedAnimation(i,s)}}return i.e&&i.e.AddTagsTo(h,s.tags),null!==s.from&&null!==s.to&&h.normalize(s.from,s.to),void 0!==s.speedRatio&&(h._speedRatio=s.speedRatio),void 0!==s.loopAnimation&&(h._loopAnimation=s.loopAnimation),void 0!==s.isAdditive&&(h._isAdditive=s.isAdditive),void 0!==s.weight&&(h._weight=s.weight),void 0!==s.playOrder&&(h._playOrder=s.playOrder),void 0!==s.enableBlending&&(h._enableBlending=s.enableBlending),void 0!==s.blendingSpeed&&(h._blendingSpeed=s.blendingSpeed),void 0!==s.metadata&&(h.metadata=s.metadata),h}static MakeAnimationAdditive(s,k,h){let g;g="object"===typeof k?k:{referenceFrame:k,range:h,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let ms=s;g.cloneOriginalAnimationGroup&&(ms=s.clone(g.clonedAnimationGroupName||ms.name));const i=ms.targetedAnimations;for(let K=0;K<i.length;K++){const s=i[K];s.animation=A.c.MakeAnimationAdditive(s.animation,g)}if(ms.isAdditive=!0,g.clipKeys){let s=Number.MAX_VALUE,k=-Number.MAX_VALUE;const h=ms.targetedAnimations;for(let A=0;A<h.length;A++){const g=h[A].animation.getKeys();s>g[0].frame&&(s=g[0].frame),k<g[g.length-1].frame&&(k=g[g.length-1].frame)}ms._from=s,ms._to=k}return ms}static ClipKeys(s,k,h,A,g){const ms=s.clone(A||s.name);return R.ClipKeysInPlace(ms,k,h,g)}static ClipKeysInPlace(s,k,h,A){return R.ClipInPlace(s,k,h,A,!1)}static ClipFrames(s,k,h,A,g){const ms=s.clone(A||s.name);return R.ClipFramesInPlace(ms,k,h,g)}static ClipFramesInPlace(s,k,h,A){return R.ClipInPlace(s,k,h,A,!0)}static ClipInPlace(s,k,h,A){let g=arguments.length>4&&void 0!==arguments[4]&&arguments[4],ms=Number.MAX_VALUE,i=-Number.MAX_VALUE;const K=s.targetedAnimations;for(let H=0;H<K.length;H++){const s=K[H],O=A?s.animation:s.animation.clone();g&&(O.createKeyForFrame(k),O.createKeyForFrame(h));const c=O.getKeys(),S=[];let a=Number.MAX_VALUE;for(let A=0;A<c.length;A++){const s=c[A];if(!g&&A>=k&&A<=h||g&&s.frame>=k&&s.frame<=h){const k={frame:s.frame,value:s.value.clone?s.value.clone():s.value,inTangent:s.inTangent,outTangent:s.outTangent,interpolation:s.interpolation,lockedTangent:s.lockedTangent};a===Number.MAX_VALUE&&(a=k.frame),k.frame-=a,S.push(k)}}0!==S.length?(ms>S[0].frame&&(ms=S[0].frame),i<S[S.length-1].frame&&(i=S[S.length-1].frame),O.setKeys(S,!0),s.animation=O):(K.splice(H,1),H--)}return s._from=ms,s._to=i,s}getClassName(){return"AnimationGroup"}toString(s){let k="Name: "+this.name;return k+=", type: "+this.getClassName(),s&&(k+=", from: "+this._from,k+=", to: "+this._to,k+=", isStarted: "+this._isStarted,k+=", speedRatio: "+this._speedRatio,k+=", targetedAnimations length: "+this._targetedAnimations.length,k+=", animatables length: "+this._animatables),k}}}}]);