"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[78],{15540:(V,h,mV)=>{mV.r(h),mV.d(h,{AnimationGroup:()=>c,TargetedAnimation:()=>M});var t=mV(12918),L=mV(12258),N=mV(12300),A=mV(12450),k=mV(14044),C=mV(12422);class K{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(V,h,mV,L){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=h,this._target=V,this._scene=mV,this._host=L,this._activeTargets=[],h._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===t.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=C.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const V={frame:0,value:this._minValue};this._keys.splice(0,0,V)}if(this._target instanceof Array){let V=0;for(const h of this._target)this._preparePath(h,V),this._getOriginalValues(V),V++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const N=h.getEvents();if(N&&N.length>0)for(const t of N)this._events.push(t._clone());this._enableBlending=V&&V.animationPropertiesOverride?V.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const mV=this._animation.targetPropertyPath;if(mV.length>1){let t=V;for(let V=0;V<mV.length-1;V++){const h=mV[V];if(t=t[h],void 0===t)throw new Error(`Invalid property (${h}) in property path (${mV.join(".")})`)}this._targetPath=mV[mV.length-1],this._activeTargets[h]=t}else this._targetPath=mV[0],this._activeTargets[h]=V;if(void 0===this._activeTargets[h][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${mV.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let V=0;for(const h of this._target)void 0!==this._originalValue[V]&&this._setValue(h,this._activeTargets[V],this._originalValue[V],-1,V),V++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let V=0;V<this._events.length;V++)this._events[V].isDone=!1}isStopped(){return this._stopped}dispose(){const V=this._animation.runtimeAnimations.indexOf(this);V>-1&&this._animation.runtimeAnimations.splice(V,1)}setValue(V,h){if(this._targetIsArray)for(let mV=0;mV<this._target.length;mV++){const t=this._target[mV];this._setValue(t,this._activeTargets[mV],V,h,mV)}else this._setValue(this._target,this._directTarget,V,h,0)}_getOriginalValues(){let V,h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const mV=this._activeTargets[h];V=mV.getLocalMatrix&&"_matrix"===this._targetPath?mV.getLocalMatrix():mV[this._targetPath],V&&V.clone?this._originalValue[h]=V.clone():this._originalValue[h]=V}_registerTargetForLateAnimationBinding(V,h){const mV=V.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(mV),mV._lateAnimationHolders||(mV._lateAnimationHolders={}),mV._lateAnimationHolders[V.targetPath]||(mV._lateAnimationHolders[V.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:h}),V.isAdditive?(mV._lateAnimationHolders[V.targetPath].additiveAnimations.push(V),mV._lateAnimationHolders[V.targetPath].totalAdditiveWeight+=V.weight):(mV._lateAnimationHolders[V.targetPath].animations.push(V),mV._lateAnimationHolders[V.targetPath].totalWeight+=V.weight)}_setValue(V,h,mV,L,N){if(this._currentActiveTarget=h,this._weight=L,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const V=h[this._targetPath];V.clone?this._originalBlendValue=V.clone():this._originalBlendValue=V}this._originalBlendValue.m?t.d.AllowMatrixDecomposeForInterpolation?this._currentValue?C.Matrix.DecomposeLerpToRef(this._originalBlendValue,mV,this._blendingFactor,this._currentValue):this._currentValue=C.Matrix.DecomposeLerp(this._originalBlendValue,mV,this._blendingFactor):this._currentValue?C.Matrix.LerpToRef(this._originalBlendValue,mV,this._blendingFactor,this._currentValue):this._currentValue=C.Matrix.Lerp(this._originalBlendValue,mV,this._blendingFactor):this._currentValue=t.d._UniversalLerp(this._originalBlendValue,mV,this._blendingFactor);const L=V&&V.animationPropertiesOverride?V.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=L}else this._currentValue?this._currentValue.t?this._currentValue.t(mV):this._currentValue=mV:null!==mV&&void 0!==mV&&mV.clone?this._currentValue=mV.clone():this._currentValue=mV;-1!==L?this._registerTargetForLateAnimationBinding(this,this._originalValue[N]):this._animationState.loopMode===t.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[N],h[this._targetPath]):h[this._targetPath]=this._originalValue[N]+this._currentValue:h[this._targetPath]=this._currentValue,V.UK&&V.UK(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const mV=this._animation.getKeys();V<mV[0].frame?V=mV[0].frame:V>mV[mV.length-1].frame&&(V=mV[mV.length-1].frame);const t=this._events;if(t.length)for(let N=0;N<t.length;N++)t[N].onlyOnce||(t[N].isDone=t[N].frame<V);this._currentFrame=V;const L=this._animation._interpolate(V,this._animationState);this.setValue(L,h)}_prepareForSpeedRatioChange(V){const h=this._previousElapsedTime*(this._animation.framePerSecond*V)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-h}animate(V,h,mV,L,N){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const k=this._animation,C=k.targetPropertyPath;if(!C||C.length<1)return this._stopped=!0,!1;let K,o=!0;const n=this._events;let q=0;if(this._coreRuntimeAnimation)q=mV-h,K=this._coreRuntimeAnimation.currentFrame,this._currentFrame=K,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let A;(h<this._minFrame||h>this._maxFrame)&&(h=this._minFrame),(mV<this._minFrame||mV>this._maxFrame)&&(mV=this._maxFrame),q=mV-h;let C=V*(k.framePerSecond*N)/1e3+this._absoluteFrameOffset,x=0,R=!1;const d=L&&this._animationState.loopMode===t.d.ANIMATIONLOOPMODE_YOYO;if(d){const V=(C-h)/q,mV=Math.sin(V*Math.PI);C=Math.abs(mV)*q+h;const t=mV>=0?1:-1;this._yoyoDirection!==t&&(R=!0),this._yoyoDirection=t}if(this._previousElapsedTime=V,this._previousAbsoluteFrame=C,!L&&mV>=h&&(C>=q&&N>0||C<=0&&N<0))o=!1,x=k._getKeyValue(this._maxValue);else if(!L&&h>=mV&&(C<=q&&N<0||C>=0&&N>0))o=!1,x=k._getKeyValue(this._minValue);else if(this._animationState.loopMode!==t.d.ANIMATIONLOOPMODE_CYCLE){const V=mV.toString()+h.toString();if(!this._offsetsCache[V]){this._animationState.repeatCount=0,this._animationState.loopMode=t.d.ANIMATIONLOOPMODE_CYCLE;const L=k._interpolate(h,this._animationState),N=k._interpolate(mV,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),k.dataType){case t.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[V]=N-L;break;case t.d.ANIMATIONTYPE_QUATERNION:case t.d.ANIMATIONTYPE_VECTOR3:case t.d.ANIMATIONTYPE_VECTOR2:case t.d.ANIMATIONTYPE_SIZE:case t.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[V]=N.Mh(L)}this._highLimitsCache[V]=N}x=this._highLimitsCache[V],A=this._offsetsCache[V]}if(void 0===A)switch(k.dataType){case t.d.ANIMATIONTYPE_FLOAT:A=0;break;case t.d.ANIMATIONTYPE_QUATERNION:A=t.j;break;case t.d.ANIMATIONTYPE_VECTOR3:A=t.q;break;case t.d.ANIMATIONTYPE_VECTOR2:A=t.n;break;case t.d.ANIMATIONTYPE_SIZE:A=t.m;break;case t.d.ANIMATIONTYPE_COLOR3:A=t.e;break;case t.d.ANIMATIONTYPE_COLOR4:A=t.f}if(this._host&&this._host.syncRoot){const V=this._host.syncRoot;K=h+q*((V.masterFrame-V.fromFrame)/(V.toFrame-V.fromFrame))}else K=C>0&&h>mV||C<0&&h<mV?o&&0!==q?mV+C%q:h:o&&0!==q?h+C%q:mV;if(!d&&(N>0&&this.currentFrame>K||N<0&&this.currentFrame<K)||d&&R){this._onLoop();for(let V=0;V<n.length;V++)n[V].onlyOnce||(n[V].isDone=!1);this._animationState.key=N>0?0:k.getKeys().length-1}this._currentFrame=K,this._animationState.repeatCount=0===q?0:C/q|0,this._animationState.highLimitValue=x,this._animationState.offsetValue=A}const x=k._interpolate(K,this._animationState);if(this.setValue(x,A),n.length)for(let t=0;t<n.length;t++)if(q>=0&&K>=n[t].frame&&n[t].frame>=h||q<0&&K<=n[t].frame&&n[t].frame<=h){const V=n[t];V.isDone||(V.onlyOnce&&(n.splice(t,1),t--),V.isDone=!0,V.action(K))}return o||(this._stopped=!0),o}}var o=mV(12280);class n{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(V){this._weight=-1!==V?Math.min(Math.max(V,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(V){for(let h=0;h<this._runtimeAnimations.length;h++){this._runtimeAnimations[h]._prepareForSpeedRatioChange(V)}this._speedRatio=V,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(V,h){let mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,N=arguments.length>4&&void 0!==arguments[4]&&arguments[4],A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,C=arguments.length>7?arguments[7]:void 0,K=arguments.length>8?arguments[8]:void 0,o=arguments.length>9&&void 0!==arguments[9]&&arguments[9],n=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=h,this.fromFrame=mV,this.toFrame=t,this.loopAnimation=N,this.onAnimationEnd=k,this.onAnimationLoop=K,this.isAdditive=o,this.playOrder=n,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Lk=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new L.d,this.onAnimationLoopObservable=new L.d,this._scene=V,C&&this.appendAnimations(h,C),this._speedRatio=A,V._activeAnimatables.push(this)}syncWith(V){if(this._syncRoot=V,V){const V=this._scene._activeAnimatables.indexOf(this);V>-1&&(this._scene._activeAnimatables.splice(V,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(V,h){for(let mV=0;mV<h.length;mV++){const t=h[mV],L=new K(V,t,this._scene,this);L._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(L)}}getAnimationByTargetProperty(V){const h=this._runtimeAnimations;for(let mV=0;mV<h.length;mV++)if(h[mV].animation.targetProperty===V)return h[mV].animation;return null}getRuntimeAnimationByTargetProperty(V){const h=this._runtimeAnimations;for(let mV=0;mV<h.length;mV++)if(h[mV].animation.targetProperty===V)return h[mV];return null}reset(){const V=this._runtimeAnimations;for(let h=0;h<V.length;h++)V[h].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(V){const h=this._runtimeAnimations;for(let mV=0;mV<h.length;mV++)h[mV].animation.enableBlending=!0,h[mV].animation.blendingSpeed=V}disableBlending(){const V=this._runtimeAnimations;for(let h=0;h<V.length;h++)V[h].animation.enableBlending=!1}goToFrame(V){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const mV=this._runtimeAnimations;if(mV[0]){const h=mV[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??mV[0].currentFrame;const t=0===this.speedRatio?0:(V-this._frameToSyncFromJump)/h*1e3/this.speedRatio;this._manualJumpDelay=-t}for(let t=0;t<mV.length;t++)mV[t].goToFrame(V,h?this._weight:-1);this._goToFrame=V}get paused(){return this.Lk}pause(){this.Lk||(this.Lk=!0)}restart(){this.Lk=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(V,h){let mV=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(V||h){const L=this._scene._activeAnimatables.indexOf(this);if(L>-1){const N=this._runtimeAnimations;for(let mV=N.length-1;mV>=0;mV--){const t=N[mV];V&&t.animation.name!=V||(h&&!h(t.target)||(t.dispose(),N.splice(mV,1)))}0==N.length&&(mV||this._scene._activeAnimatables.splice(L,1),t||this._raiseOnAnimationEnd())}}else{const V=this._scene._activeAnimatables.indexOf(this);if(V>-1){mV||this._scene._activeAnimatables.splice(V,1);const h=this._runtimeAnimations;for(let V=0;V<h.length;V++)h[V].dispose();this._runtimeAnimations.length=0,t||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((V=>{this.onAnimationEndObservable.add((()=>{V(this)}),void 0,void 0,this,!0)}))}_animate(V){if(this.Lk)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=V),!0;if(null===this._localDelayOffset?(this._localDelayOffset=V,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=V-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let h=!1;const mV=this._runtimeAnimations;let t;for(t=0;t<mV.length;t++){const L=mV[t].animate(V-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);h=h||L}if(this.animationStarted=h,!h){if(this.disposeOnEnd)for(t=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(t,1),t=0;t<mV.length;t++)mV[t].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return h}}function q(V){if(0===V.totalWeight&&0===V.totalAdditiveWeight)return V.originalValue;let h=1;const mV=C.TmpVectors.sh[0],t=C.TmpVectors.sh[1],L=C.TmpVectors.Quaternion[0];let N=0;const A=V.animations[0],k=V.originalValue;let K=1,o=!1;if(V.totalWeight<1)K=1-V.totalWeight,k.decompose(t,L,mV);else{if(N=1,h=V.totalWeight,K=A.weight/h,1==K){if(!V.totalAdditiveWeight)return A.currentValue;o=!0}A.currentValue.decompose(t,L,mV)}if(!o){t.scaleInPlace(K),mV.scaleInPlace(K),L.scaleInPlace(K);for(let A=N;A<V.animations.length;A++){const N=V.animations[A];if(0===N.weight)continue;K=N.weight/h;const k=C.TmpVectors.sh[2],o=C.TmpVectors.sh[3],n=C.TmpVectors.Quaternion[1];N.currentValue.decompose(o,n,k),o.scaleAndAddToRef(K,t),n.scaleAndAddToRef(C.Quaternion.Dot(L,n)>0?K:-K,L),k.scaleAndAddToRef(K,mV)}L.normalize()}for(let q=0;q<V.additiveAnimations.length;q++){const h=V.additiveAnimations[q];if(0===h.weight)continue;const N=C.TmpVectors.sh[2],A=C.TmpVectors.sh[3],k=C.TmpVectors.Quaternion[1];h.currentValue.decompose(A,k,N),A.multiplyToRef(t,A),C.sh.LerpToRef(t,A,h.weight,t),L.multiplyToRef(k,k),C.Quaternion.SlerpToRef(L,k,h.weight,L),N.scaleAndAddToRef(h.weight,mV)}const n=A?A._animationState.workValue:C.TmpVectors.Matrix[0].clone();return C.Matrix.ComposeToRef(t,L,mV,n),n}function x(V,h){if(0===V.totalWeight&&0===V.totalAdditiveWeight)return h;const mV=V.animations[0],t=V.originalValue;let L=h;if(0===V.totalWeight&&V.totalAdditiveWeight>0)L.t(t);else if(1===V.animations.length){if(C.Quaternion.SlerpToRef(t,mV.currentValue,Math.min(1,V.totalWeight),L),0===V.totalAdditiveWeight)return L}else if(V.animations.length>1){let mV,N,A=1;if(V.totalWeight<1){const h=1-V.totalWeight;mV=[],N=[],mV.push(t),N.push(h)}else{if(2===V.animations.length&&(C.Quaternion.SlerpToRef(V.animations[0].currentValue,V.animations[1].currentValue,V.animations[1].weight/V.totalWeight,h),0===V.totalAdditiveWeight))return h;mV=[],N=[],A=V.totalWeight}for(let h=0;h<V.animations.length;h++){const t=V.animations[h];mV.push(t.currentValue),N.push(t.weight/A)}let k=0;for(let V=0;V<mV.length;)V?(k+=N[V],C.Quaternion.SlerpToRef(L,mV[V],N[V]/k,L),V++):(C.Quaternion.SlerpToRef(mV[V],mV[V+1],N[V+1]/(N[V]+N[V+1]),h),L=h,k=N[V]+N[V+1],V+=2)}for(let N=0;N<V.additiveAnimations.length;N++){const h=V.additiveAnimations[N];0!==h.weight&&(L.multiplyToRef(h.currentValue,C.TmpVectors.Quaternion[0]),C.Quaternion.SlerpToRef(L,C.TmpVectors.Quaternion[0],h.weight,L))}return L}var R,d,s=mV(12648);R=s.d,(d=k.d)&&(d.prototype.copyAnimationRange=function(V,h,mV){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3],N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new t.d(this.name,"_matrix",V.animations[0].framePerSecond,t.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const A=V.animations[0].getRange(h);if(!A)return!1;const k=A.from,C=A.to,K=V.animations[0].getKeys(),o=V.length,n=V.getParent(),q=this.getParent(),x=L&&n&&o&&this.length&&o!==this.length,R=x&&q&&n?q.length/n.length:1,d=L&&!q&&N&&(1!==N.x||1!==N.y||1!==N.z),s=this.animations[0].getKeys();let M,c,z;for(let t=0,Q=K.length;t<Q;t++)M=K[t],M.frame>=k&&M.frame<=C&&(L?(z=M.value.clone(),x?(c=z.getTranslation(),z.setTranslation(c.scaleInPlace(R))):d&&N?(c=z.getTranslation(),z.setTranslation(c.multiplyInPlace(N))):z=M.value):z=M.value,s.push({frame:M.frame+mV,value:z}));return this.animations[0].createRange(h,k+mV,C+mV),!0}),R&&(R.prototype._animate=function(V){if(!this.animationsEnabled)return;const h=o.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=h}this.deltaTime=void 0!==V?V:this.useConstantAnimationDeltaTime?16:(h-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=h;const mV=this._activeAnimatables;if(0===mV.length)return;this._animationTime+=this.deltaTime;const L=this._animationTime;for(let t=0;t<mV.length;t++){const V=mV[t];!V._animate(L)&&V.disposeOnEnd&&t--}!function(V){if(V._registeredForLateAnimationBindings.length){for(let h=0;h<V._registeredForLateAnimationBindings.length;h++){const mV=V._registeredForLateAnimationBindings.data[h];for(const V in mV._lateAnimationHolders){const h=mV._lateAnimationHolders[V],L=h.animations[0],N=h.originalValue;if(void 0===N||null===N)continue;const A=t.d.AllowMatrixDecomposeForInterpolation&&N.m;let k=mV[V];if(A)k=q(h);else if(void 0!==N.w)k=x(h,k||C.Quaternion.Identity());else{let V=0,mV=1;const A=L&&L._animationState.loopMode===t.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(h.totalWeight<1)k=A?N.clone?N.clone():N:L&&N.scale?N.scale(1-h.totalWeight):L?N*(1-h.totalWeight):N.clone?N.clone():N;else if(L){mV=h.totalWeight;const t=L.weight/mV;k=1!==t?L.currentValue.scale?L.currentValue.scale(t):L.currentValue*t:L.currentValue,A&&(k.addToRef?k.addToRef(N,k):k+=N),V=1}for(let t=V;t<h.animations.length;t++){const V=h.animations[t],L=V.weight/mV;L&&(V.currentValue.scaleAndAddToRef?V.currentValue.scaleAndAddToRef(L,k):k+=V.currentValue*L)}for(let t=0;t<h.additiveAnimations.length;t++){const V=h.additiveAnimations[t],mV=V.weight;mV&&(V.currentValue.scaleAndAddToRef?V.currentValue.scaleAndAddToRef(mV,k):k+=V.currentValue*mV)}}mV[V]=k}mV._lateAnimationHolders={}}V._registeredForLateAnimationBindings.reset()}}(this)},R.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((V,h)=>V.playOrder-h.playOrder))},R.prototype.beginWeightedAnimation=function(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,L=arguments.length>4?arguments[4]:void 0,N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,k=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,K=arguments.length>9?arguments[9]:void 0,o=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const n=this.beginAnimation(V,h,mV,L,N,A,k,!1,C,K,o);return n.weight=t,n},R.prototype.beginAnimation=function(V,h,mV,t){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,N=arguments.length>5?arguments[5]:void 0,A=arguments.length>6?arguments[6]:void 0,k=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],C=arguments.length>8?arguments[8]:void 0,K=arguments.length>9?arguments[9]:void 0,o=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(L<0){const V=h;h=mV,mV=V,L=-L}h>mV&&(L=-L),k&&this.stopAnimation(V,void 0,C),A||(A=new n(this,V,h,mV,t,L,N,void 0,K,o));const q=!C||C(V);if(V.animations&&q&&A.appendAnimations(V,V.animations),V.getAnimatables){const o=V.getAnimatables();for(let V=0;V<o.length;V++)this.beginAnimation(o[V],h,mV,t,L,N,A,k,C,K)}return A.reset(),A},R.prototype.beginHierarchyAnimation=function(V,h,mV,t,L){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,k=arguments.length>7?arguments[7]:void 0,C=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],K=arguments.length>9?arguments[9]:void 0,o=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const n=V.getDescendants(h),q=[];q.push(this.beginAnimation(V,mV,t,L,N,A,k,C,K,void 0,o));for(const x of n)q.push(this.beginAnimation(x,mV,t,L,N,A,k,C,K,void 0,o));return q},R.prototype.beginDirectAnimation=function(V,h,mV,t,L){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(N<0){const V=mV;mV=t,t=V,N=-N}return mV>t&&(N=-N),new n(this,V,mV,t,L,N,arguments.length>6?arguments[6]:void 0,h,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},R.prototype.beginDirectHierarchyAnimation=function(V,h,mV,t,L,N,A,k,C){let K=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const o=V.getDescendants(h),n=[];n.push(this.beginDirectAnimation(V,mV,t,L,N,A,k,C,K));for(const q of o)n.push(this.beginDirectAnimation(q,mV,t,L,N,A,k,C,K));return n},R.prototype.getAnimatableByTarget=function(V){for(let h=0;h<this._activeAnimatables.length;h++)if(this._activeAnimatables[h].target===V)return this._activeAnimatables[h];return null},R.prototype.getAllAnimatablesByTarget=function(V){const h=[];for(let mV=0;mV<this._activeAnimatables.length;mV++)this._activeAnimatables[mV].target===V&&h.push(this._activeAnimatables[mV]);return h},R.prototype.stopAnimation=function(V,h,mV){const t=this.getAllAnimatablesByTarget(V);for(const L of t)L.stop(h,mV)},R.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let V=0;V<this._activeAnimatables.length;V++)this._activeAnimatables[V].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const V of this.animationGroups)V.stop()});class M{getClassName(){return"TargetedAnimation"}serialize(){const V={};return V.animation=this.animation.serialize(),V.targetId=this.target.id,V}}class c{get mask(){return this._mask}set mask(V){this._mask!==V&&(this._mask=V,this.syncWithMask(!0))}syncWithMask(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||V){this._numActiveAnimatables=0;for(let V=0;V<this._animatables.length;++V){const h=this._animatables[V];!this.mask||this.mask.disabled||this.mask.retainsTarget(h.target.name)?(this._numActiveAnimatables++,h.paused&&h.restart()):h.paused||h.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let V=0;V<this._animatables.length;++V){const h=this._animatables[V];this.mask.retainsTarget(h.target.name)||(h.stop(),this._animatables.splice(V,1),--V)}for(let V=0;V<this._targetedAnimations.length;V++){const h=this._targetedAnimations[V];this.mask.retainsTarget(h.target.name)||(this._targetedAnimations.splice(V,1),--V)}}}get from(){return this._from}set from(V){if(this._from!==V){this._from=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].fromFrame=this._from}}}get to(){return this._to}set to(V){if(this._to!==V){this._to=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(V){if(this._speedRatio!==V){this._speedRatio=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(V){if(this._loopAnimation!==V){this._loopAnimation=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(V){if(this._isAdditive!==V){this._isAdditive=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(V){this._weight!==V&&(this._weight=V,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(V){if(this._playOrder!==V&&(this._playOrder=V,this._animatables.length>0)){for(let V=0;V<this._animatables.length;V++)this._animatables[V].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(V){if(this._enableBlending!==V&&(this._enableBlending=V,null!==V))for(let h=0;h<this._targetedAnimations.length;++h)this._targetedAnimations[h].animation.enableBlending=V}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(V){if(this._blendingSpeed!==V&&(this._blendingSpeed=V,null!==V))for(let h=0;h<this._targetedAnimations.length;++h)this._targetedAnimations[h].animation.blendingSpeed=V}getLength(V,h){V=V??this._from;return((h=h??this._to)-V)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(V){let h=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],mV=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=arguments.length>3?arguments[3]:void 0;if(0===V.length)return null;t=t??V[0].weight;let L=Number.MAX_VALUE,N=-Number.MAX_VALUE;if(mV)for(const k of V)k.from<L&&(L=k.from),k.to>N&&(N=k.to);const A=new c(V[0].name+"_merged",V[0]._scene,t);for(const k of V){mV&&k.normalize(L,N);for(const V of k.targetedAnimations)A.addTargetedAnimation(V.animation,V.target);h&&k.dispose()}return A}constructor(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=V,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new L.d,this.onAnimationLoopObservable=new L.d,this.onAnimationGroupLoopObservable=new L.d,this.onAnimationGroupEndObservable=new L.d,this.onAnimationGroupPauseObservable=new L.d,this.onAnimationGroupPlayObservable=new L.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=h||N.b.LastCreatedScene,this._weight=mV,this._playOrder=t,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(V,h){const mV=new M;mV.animation=V,mV.target=h;const t=V.getKeys();return this._from>t[0].frame&&(this._from=t[0].frame),this._to<t[t.length-1].frame&&(this._to=t[t.length-1].frame),null!==this._enableBlending&&(V.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(V.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(mV),this._shouldStart=!0,mV}removeTargetedAnimation(V){for(let h=this._targetedAnimations.length-1;h>-1;h--){this._targetedAnimations[h].animation===V&&this._targetedAnimations.splice(h,1)}}normalize(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==V&&(V=this._from),null==h&&(h=this._to);for(let mV=0;mV<this._targetedAnimations.length;mV++){const t=this._targetedAnimations[mV].animation.getKeys(),L=t[0],N=t[t.length-1];if(L.frame>V){const h={frame:V,value:L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation};t.splice(0,0,h)}if(N.frame<h){const V={frame:h,value:N.value,inTangent:N.inTangent,outTangent:N.outTangent,interpolation:N.interpolation};t.push(V)}}return this._from=V,this._to=h,this}_processLoop(V,h,mV){V.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(h),this._animationLoopFlags[mV]||(this._animationLoopFlags[mV]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0],h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,mV=arguments.length>2?arguments[2]:void 0,t=arguments.length>3?arguments[3]:void 0,L=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=V,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let N=0;N<this._targetedAnimations.length;N++){const A=this._targetedAnimations[N],k=this._scene.beginDirectAnimation(A.target,[A.animation],void 0!==mV?mV:this._from,void 0!==t?t:this._to,V,h,void 0,void 0,void 0!==L?L:this._isAdditive);k.weight=this._weight,k.playOrder=this._playOrder,k.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(A),this._checkAnimationGroupEnded(k)},this._processLoop(k,A,N),this._animatables.push(k)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=h,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let V=0;V<this._animatables.length;V++){this._animatables[V].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(V){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==V&&(this.loopAnimation=V),this.restart()):(this.stop(),this.start(V,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let V=0;V<this._animatables.length;V++){this._animatables[V].reset()}return this}restart(){if(!this._isStarted)return this;for(let V=0;V<this._animatables.length;V++){this._animatables[V].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const h=this._animatables.slice();for(let t=0;t<h.length;t++)h[t].stop(void 0,void 0,!0,V);let mV=0;for(let t=0;t<this._scene._activeAnimatables.length;t++){const h=this._scene._activeAnimatables[t];h._runtimeAnimations.length>0?this._scene._activeAnimatables[mV++]=h:V&&this._checkAnimationGroupEnded(h,V)}return this._scene._activeAnimatables.length=mV,this._isStarted=!1,this}setWeightForAllAnimatables(V){for(let h=0;h<this._animatables.length;h++){this._animatables[h].weight=V}return this}syncAllAnimationsWith(V){for(let h=0;h<this._animatables.length;h++){this._animatables[h].syncWith(V)}return this}goToFrame(V){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let mV=0;mV<this._animatables.length;mV++){this._animatables[mV].goToFrame(V,h)}return this}getCurrentFrame(){var V;return(null===(V=this.animatables[0])||void 0===V?void 0:V.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const V=this._scene.animationGroups.indexOf(this);if(V>-1&&this._scene.animationGroups.splice(V,1),this._parentContainer){const V=this._parentContainer.animationGroups.indexOf(this);V>-1&&this._parentContainer.animationGroups.splice(V,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(V){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const mV=this._animatables.indexOf(V);mV>-1&&this._animatables.splice(mV,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,h||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(V,h){let mV=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=new c(V||this.name,this._scene,this._weight,this._playOrder);t._from=this.from,t._to=this.to,t._speedRatio=this.speedRatio,t._loopAnimation=this.loopAnimation,t._isAdditive=this.isAdditive,t._enableBlending=this.enableBlending,t._blendingSpeed=this.blendingSpeed,t.metadata=this.metadata,t.mask=this.mask;for(const L of this._targetedAnimations)t.addTargetedAnimation(mV?L.animation.clone():L.animation,h?h(L.target):L.target);return t}serialize(){const V={};V.name=this.name,V.from=this.from,V.to=this.to,V.speedRatio=this.speedRatio,V.loopAnimation=this.loopAnimation,V.isAdditive=this.isAdditive,V.weight=this.weight,V.playOrder=this.playOrder,V.enableBlending=this.enableBlending,V.blendingSpeed=this.blendingSpeed,V.targetedAnimations=[];for(let h=0;h<this.targetedAnimations.length;h++){const mV=this.targetedAnimations[h];V.targetedAnimations[h]=mV.serialize()}return A.e&&A.e.HasTags(this)&&(V.tags=A.e.GetTags(this)),this.metadata&&(V.metadata=this.metadata),V}static Parse(V,h){const mV=new c(V.name,h,V.weight,V.playOrder);for(let L=0;L<V.targetedAnimations.length;L++){const N=V.targetedAnimations[L],A=t.d.Parse(N.animation),k=N.targetId;if("influence"===N.animation.property){const V=h.getMorphTargetById(k);V&&mV.addTargetedAnimation(A,V)}else{const V=h.getNodeById(k);null!=V&&mV.addTargetedAnimation(A,V)}}return A.e&&A.e.AddTagsTo(mV,V.tags),null!==V.from&&null!==V.to&&mV.normalize(V.from,V.to),void 0!==V.speedRatio&&(mV._speedRatio=V.speedRatio),void 0!==V.loopAnimation&&(mV._loopAnimation=V.loopAnimation),void 0!==V.isAdditive&&(mV._isAdditive=V.isAdditive),void 0!==V.weight&&(mV._weight=V.weight),void 0!==V.playOrder&&(mV._playOrder=V.playOrder),void 0!==V.enableBlending&&(mV._enableBlending=V.enableBlending),void 0!==V.blendingSpeed&&(mV._blendingSpeed=V.blendingSpeed),void 0!==V.metadata&&(mV.metadata=V.metadata),mV}static MakeAnimationAdditive(V,h,mV){let L;L="object"===typeof h?h:{referenceFrame:h,range:mV,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let N=V;L.cloneOriginalAnimationGroup&&(N=V.clone(L.clonedAnimationGroupName||N.name));const A=N.targetedAnimations;for(let k=0;k<A.length;k++){const V=A[k];V.animation=t.d.MakeAnimationAdditive(V.animation,L)}if(N.isAdditive=!0,L.clipKeys){let V=Number.MAX_VALUE,h=-Number.MAX_VALUE;const mV=N.targetedAnimations;for(let t=0;t<mV.length;t++){const L=mV[t].animation.getKeys();V>L[0].frame&&(V=L[0].frame),h<L[L.length-1].frame&&(h=L[L.length-1].frame)}N._from=V,N._to=h}return N}static ClipKeys(V,h,mV,t,L){const N=V.clone(t||V.name);return c.ClipKeysInPlace(N,h,mV,L)}static ClipKeysInPlace(V,h,mV,t){return c.ClipInPlace(V,h,mV,t,!1)}static ClipFrames(V,h,mV,t,L){const N=V.clone(t||V.name);return c.ClipFramesInPlace(N,h,mV,L)}static ClipFramesInPlace(V,h,mV,t){return c.ClipInPlace(V,h,mV,t,!0)}static ClipInPlace(V,h,mV,t){let L=arguments.length>4&&void 0!==arguments[4]&&arguments[4],N=Number.MAX_VALUE,A=-Number.MAX_VALUE;const k=V.targetedAnimations;for(let C=0;C<k.length;C++){const V=k[C],K=t?V.animation:V.animation.clone();L&&(K.createKeyForFrame(h),K.createKeyForFrame(mV));const o=K.getKeys(),n=[];let q=Number.MAX_VALUE;for(let t=0;t<o.length;t++){const V=o[t];if(!L&&t>=h&&t<=mV||L&&V.frame>=h&&V.frame<=mV){const h={frame:V.frame,value:V.value.clone?V.value.clone():V.value,inTangent:V.inTangent,outTangent:V.outTangent,interpolation:V.interpolation,lockedTangent:V.lockedTangent};q===Number.MAX_VALUE&&(q=h.frame),h.frame-=q,n.push(h)}}0!==n.length?(N>n[0].frame&&(N=n[0].frame),A<n[n.length-1].frame&&(A=n[n.length-1].frame),K.setKeys(n,!0),V.animation=K):(k.splice(C,1),C--)}return V._from=N,V._to=A,V}getClassName(){return"AnimationGroup"}toString(V){let h="Name: "+this.name;return h+=", type: "+this.getClassName(),V&&(h+=", from: "+this._from,h+=", to: "+this._to,h+=", isStarted: "+this._isStarted,h+=", speedRatio: "+this._speedRatio,h+=", targetedAnimations length: "+this._targetedAnimations.length,h+=", animatables length: "+this._animatables),h}}}}]);