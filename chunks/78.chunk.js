"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[78],{14354:(k,h,o)=>{o.r(h),o.d(h,{AnimationGroup:()=>M,TargetedAnimation:()=>f});var x=o(11783),I=o(11082),q=o(11120),Y=o(11277),J=o(12867),G=o(11239);class l{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(k,h,o,I){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=h,this._target=k,this._scene=o,this._host=I,this._activeTargets=[],h._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===x.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=G.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const k={frame:0,value:this._minValue};this._keys.splice(0,0,k)}if(this._target instanceof Array){let k=0;for(const h of this._target)this._preparePath(h,k),this._getOriginalValues(k),k++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const q=h.getEvents();if(q&&q.length>0)for(const x of q)this._events.push(x._clone());this._enableBlending=k&&k.animationPropertiesOverride?k.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=this._animation.targetPropertyPath;if(o.length>1){let x=k;for(let k=0;k<o.length-1;k++){const h=o[k];if(x=x[h],void 0===x)throw new Error(`Invalid property (${h}) in property path (${o.join(".")})`)}this._targetPath=o[o.length-1],this._activeTargets[h]=x}else this._targetPath=o[0],this._activeTargets[h]=k;if(void 0===this._activeTargets[h][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${o.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let k=0;for(const h of this._target)void 0!==this._originalValue[k]&&this._setValue(h,this._activeTargets[k],this._originalValue[k],-1,k),k++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let k=0;k<this._events.length;k++)this._events[k].isDone=!1}isStopped(){return this._stopped}dispose(){const k=this._animation.runtimeAnimations.indexOf(this);k>-1&&this._animation.runtimeAnimations.splice(k,1)}setValue(k,h){if(this._targetIsArray)for(let o=0;o<this._target.length;o++){const x=this._target[o];this._setValue(x,this._activeTargets[o],k,h,o)}else this._setValue(this._target,this._directTarget,k,h,0)}_getOriginalValues(){let k,h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const o=this._activeTargets[h];k=o.getLocalMatrix&&"_matrix"===this._targetPath?o.getLocalMatrix():o[this._targetPath],k&&k.clone?this._originalValue[h]=k.clone():this._originalValue[h]=k}_registerTargetForLateAnimationBinding(k,h){const o=k.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(o),o._lateAnimationHolders||(o._lateAnimationHolders={}),o._lateAnimationHolders[k.targetPath]||(o._lateAnimationHolders[k.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:h}),k.isAdditive?(o._lateAnimationHolders[k.targetPath].additiveAnimations.push(k),o._lateAnimationHolders[k.targetPath].totalAdditiveWeight+=k.weight):(o._lateAnimationHolders[k.targetPath].animations.push(k),o._lateAnimationHolders[k.targetPath].totalWeight+=k.weight)}_setValue(k,h,o,I,q){if(this._currentActiveTarget=h,this._weight=I,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const k=h[this._targetPath];k.clone?this._originalBlendValue=k.clone():this._originalBlendValue=k}this._originalBlendValue.m?x.c.AllowMatrixDecomposeForInterpolation?this._currentValue?G.Matrix.DecomposeLerpToRef(this._originalBlendValue,o,this._blendingFactor,this._currentValue):this._currentValue=G.Matrix.DecomposeLerp(this._originalBlendValue,o,this._blendingFactor):this._currentValue?G.Matrix.LerpToRef(this._originalBlendValue,o,this._blendingFactor,this._currentValue):this._currentValue=G.Matrix.Lerp(this._originalBlendValue,o,this._blendingFactor):this._currentValue=x.c._UniversalLerp(this._originalBlendValue,o,this._blendingFactor);const I=k&&k.animationPropertiesOverride?k.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=I}else this._currentValue?this._currentValue.Y?this._currentValue.Y(o):this._currentValue=o:null!==o&&void 0!==o&&o.clone?this._currentValue=o.clone():this._currentValue=o;-1!==I?this._registerTargetForLateAnimationBinding(this,this._originalValue[q]):this._animationState.loopMode===x.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[q],h[this._targetPath]):h[this._targetPath]=this._originalValue[q]+this._currentValue:h[this._targetPath]=this._currentValue,k.Pl&&k.Pl(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const o=this._animation.getKeys();k<o[0].frame?k=o[0].frame:k>o[o.length-1].frame&&(k=o[o.length-1].frame);const x=this._events;if(x.length)for(let q=0;q<x.length;q++)x[q].onlyOnce||(x[q].isDone=x[q].frame<k);this._currentFrame=k;const I=this._animation._interpolate(k,this._animationState);this.setValue(I,h)}_prepareForSpeedRatioChange(k){const h=this._previousElapsedTime*(this._animation.framePerSecond*k)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-h}animate(k,h,o,I,q){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const J=this._animation,G=J.targetPropertyPath;if(!G||G.length<1)return this._stopped=!0,!1;let l,A=!0;const K=this._events;let a=0;if(this._coreRuntimeAnimation)a=o-h,l=this._coreRuntimeAnimation.currentFrame,this._currentFrame=l,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let Y;(h<this._minFrame||h>this._maxFrame)&&(h=this._minFrame),(o<this._minFrame||o>this._maxFrame)&&(o=this._maxFrame),a=o-h;let G=k*(J.framePerSecond*q)/1e3+this._absoluteFrameOffset,N=0,X=!1;const c=I&&this._animationState.loopMode===x.c.ANIMATIONLOOPMODE_YOYO;if(c){const k=(G-h)/a,o=Math.sin(k*Math.PI);G=Math.abs(o)*a+h;const x=o>=0?1:-1;this._yoyoDirection!==x&&(X=!0),this._yoyoDirection=x}if(this._previousElapsedTime=k,this._previousAbsoluteFrame=G,!I&&o>=h&&(G>=a&&q>0||G<=0&&q<0))A=!1,N=J._getKeyValue(this._maxValue);else if(!I&&h>=o&&(G<=a&&q<0||G>=0&&q>0))A=!1,N=J._getKeyValue(this._minValue);else if(this._animationState.loopMode!==x.c.ANIMATIONLOOPMODE_CYCLE){const k=o.toString()+h.toString();if(!this._offsetsCache[k]){this._animationState.repeatCount=0,this._animationState.loopMode=x.c.ANIMATIONLOOPMODE_CYCLE;const I=J._interpolate(h,this._animationState),q=J._interpolate(o,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),J.dataType){case x.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[k]=q-I;break;case x.c.ANIMATIONTYPE_QUATERNION:case x.c.ANIMATIONTYPE_VECTOR3:case x.c.ANIMATIONTYPE_VECTOR2:case x.c.ANIMATIONTYPE_SIZE:case x.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[k]=q.ih(I)}this._highLimitsCache[k]=q}N=this._highLimitsCache[k],Y=this._offsetsCache[k]}if(void 0===Y)switch(J.dataType){case x.c.ANIMATIONTYPE_FLOAT:Y=0;break;case x.c.ANIMATIONTYPE_QUATERNION:Y=x.m;break;case x.c.ANIMATIONTYPE_VECTOR3:Y=x.v;break;case x.c.ANIMATIONTYPE_VECTOR2:Y=x.r;break;case x.c.ANIMATIONTYPE_SIZE:Y=x.o;break;case x.c.ANIMATIONTYPE_COLOR3:Y=x.g;break;case x.c.ANIMATIONTYPE_COLOR4:Y=x.j}if(this._host&&this._host.syncRoot){const k=this._host.syncRoot;l=h+a*((k.masterFrame-k.fromFrame)/(k.toFrame-k.fromFrame))}else l=G>0&&h>o||G<0&&h<o?A&&0!==a?o+G%a:h:A&&0!==a?h+G%a:o;if(!c&&(q>0&&this.currentFrame>l||q<0&&this.currentFrame<l)||c&&X){this._onLoop();for(let k=0;k<K.length;k++)K[k].onlyOnce||(K[k].isDone=!1);this._animationState.key=q>0?0:J.getKeys().length-1}this._currentFrame=l,this._animationState.repeatCount=0===a?0:G/a|0,this._animationState.highLimitValue=N,this._animationState.offsetValue=Y}const N=J._interpolate(l,this._animationState);if(this.setValue(N,Y),K.length)for(let x=0;x<K.length;x++)if(a>=0&&l>=K[x].frame&&K[x].frame>=h||a<0&&l<=K[x].frame&&K[x].frame<=h){const k=K[x];k.isDone||(k.onlyOnce&&(K.splice(x,1),x--),k.isDone=!0,k.action(l))}return A||(this._stopped=!0),A}}var A=o(11106);class K{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(k){this._weight=-1!==k?Math.min(Math.max(k,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(k){for(let h=0;h<this._runtimeAnimations.length;h++){this._runtimeAnimations[h]._prepareForSpeedRatioChange(k)}this._speedRatio=k,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(k,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,J=arguments.length>6?arguments[6]:void 0,G=arguments.length>7?arguments[7]:void 0,l=arguments.length>8?arguments[8]:void 0,A=arguments.length>9&&void 0!==arguments[9]&&arguments[9],K=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=h,this.fromFrame=o,this.toFrame=x,this.loopAnimation=q,this.onAnimationEnd=J,this.onAnimationLoop=l,this.isAdditive=A,this.playOrder=K,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.WJ=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new I.d,this.onAnimationLoopObservable=new I.d,this._scene=k,G&&this.appendAnimations(h,G),this._speedRatio=Y,k._activeAnimatables.push(this)}syncWith(k){if(this._syncRoot=k,k){const k=this._scene._activeAnimatables.indexOf(this);k>-1&&(this._scene._activeAnimatables.splice(k,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(k,h){for(let o=0;o<h.length;o++){const x=h[o],I=new l(k,x,this._scene,this);I._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(I)}}getAnimationByTargetProperty(k){const h=this._runtimeAnimations;for(let o=0;o<h.length;o++)if(h[o].animation.targetProperty===k)return h[o].animation;return null}getRuntimeAnimationByTargetProperty(k){const h=this._runtimeAnimations;for(let o=0;o<h.length;o++)if(h[o].animation.targetProperty===k)return h[o];return null}reset(){const k=this._runtimeAnimations;for(let h=0;h<k.length;h++)k[h].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(k){const h=this._runtimeAnimations;for(let o=0;o<h.length;o++)h[o].animation.enableBlending=!0,h[o].animation.blendingSpeed=k}disableBlending(){const k=this._runtimeAnimations;for(let h=0;h<k.length;h++)k[h].animation.enableBlending=!1}goToFrame(k){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const o=this._runtimeAnimations;if(o[0]){const h=o[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??o[0].currentFrame;const x=0===this.speedRatio?0:(k-this._frameToSyncFromJump)/h*1e3/this.speedRatio;this._manualJumpDelay=-x}for(let x=0;x<o.length;x++)o[x].goToFrame(k,h?this._weight:-1);this._goToFrame=k}get paused(){return this.WJ}pause(){this.WJ||(this.WJ=!0)}restart(){this.WJ=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(k,h){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(k||h){const I=this._scene._activeAnimatables.indexOf(this);if(I>-1){const q=this._runtimeAnimations;for(let o=q.length-1;o>=0;o--){const x=q[o];k&&x.animation.name!=k||(h&&!h(x.target)||(x.dispose(),q.splice(o,1)))}0==q.length&&(o||this._scene._activeAnimatables.splice(I,1),x||this._raiseOnAnimationEnd())}}else{const k=this._scene._activeAnimatables.indexOf(this);if(k>-1){o||this._scene._activeAnimatables.splice(k,1);const h=this._runtimeAnimations;for(let k=0;k<h.length;k++)h[k].dispose();this._runtimeAnimations.length=0,x||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((k=>{this.onAnimationEndObservable.add((()=>{k(this)}),void 0,void 0,this,!0)}))}_animate(k){if(this.WJ)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=k),!0;if(null===this._localDelayOffset?(this._localDelayOffset=k,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=k-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let h=!1;const o=this._runtimeAnimations;let x;for(x=0;x<o.length;x++){const I=o[x].animate(k-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);h=h||I}if(this.animationStarted=h,!h){if(this.disposeOnEnd)for(x=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(x,1),x=0;x<o.length;x++)o[x].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return h}}function a(k){if(0===k.totalWeight&&0===k.totalAdditiveWeight)return k.originalValue;let h=1;const o=G.TmpVectors.Vh[0],x=G.TmpVectors.Vh[1],I=G.TmpVectors.Quaternion[0];let q=0;const Y=k.animations[0],J=k.originalValue;let l=1,A=!1;if(k.totalWeight<1)l=1-k.totalWeight,J.decompose(x,I,o);else{if(q=1,h=k.totalWeight,l=Y.weight/h,1==l){if(!k.totalAdditiveWeight)return Y.currentValue;A=!0}Y.currentValue.decompose(x,I,o)}if(!A){x.scaleInPlace(l),o.scaleInPlace(l),I.scaleInPlace(l);for(let Y=q;Y<k.animations.length;Y++){const q=k.animations[Y];if(0===q.weight)continue;l=q.weight/h;const J=G.TmpVectors.Vh[2],A=G.TmpVectors.Vh[3],K=G.TmpVectors.Quaternion[1];q.currentValue.decompose(A,K,J),A.scaleAndAddToRef(l,x),K.scaleAndAddToRef(G.Quaternion.Dot(I,K)>0?l:-l,I),J.scaleAndAddToRef(l,o)}I.normalize()}for(let a=0;a<k.additiveAnimations.length;a++){const h=k.additiveAnimations[a];if(0===h.weight)continue;const q=G.TmpVectors.Vh[2],Y=G.TmpVectors.Vh[3],J=G.TmpVectors.Quaternion[1];h.currentValue.decompose(Y,J,q),Y.multiplyToRef(x,Y),G.Vh.LerpToRef(x,Y,h.weight,x),I.multiplyToRef(J,J),G.Quaternion.SlerpToRef(I,J,h.weight,I),q.scaleAndAddToRef(h.weight,o)}const K=Y?Y._animationState.workValue:G.TmpVectors.Matrix[0].clone();return G.Matrix.ComposeToRef(x,I,o,K),K}function N(k,h){if(0===k.totalWeight&&0===k.totalAdditiveWeight)return h;const o=k.animations[0],x=k.originalValue;let I=h;if(0===k.totalWeight&&k.totalAdditiveWeight>0)I.Y(x);else if(1===k.animations.length){if(G.Quaternion.SlerpToRef(x,o.currentValue,Math.min(1,k.totalWeight),I),0===k.totalAdditiveWeight)return I}else if(k.animations.length>1){let o,q,Y=1;if(k.totalWeight<1){const h=1-k.totalWeight;o=[],q=[],o.push(x),q.push(h)}else{if(2===k.animations.length&&(G.Quaternion.SlerpToRef(k.animations[0].currentValue,k.animations[1].currentValue,k.animations[1].weight/k.totalWeight,h),0===k.totalAdditiveWeight))return h;o=[],q=[],Y=k.totalWeight}for(let h=0;h<k.animations.length;h++){const x=k.animations[h];o.push(x.currentValue),q.push(x.weight/Y)}let J=0;for(let k=0;k<o.length;)k?(J+=q[k],G.Quaternion.SlerpToRef(I,o[k],q[k]/J,I),k++):(G.Quaternion.SlerpToRef(o[k],o[k+1],q[k+1]/(q[k]+q[k+1]),h),I=h,J=q[k]+q[k+1],k+=2)}for(let q=0;q<k.additiveAnimations.length;q++){const h=k.additiveAnimations[q];0!==h.weight&&(I.multiplyToRef(h.currentValue,G.TmpVectors.Quaternion[0]),G.Quaternion.SlerpToRef(I,G.TmpVectors.Quaternion[0],h.weight,I))}return I}var X,c,W=o(11472);X=W.e,(c=J.d)&&(c.prototype.copyAnimationRange=function(k,h,o){let I=arguments.length>3&&void 0!==arguments[3]&&arguments[3],q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new x.c(this.name,"_matrix",k.animations[0].framePerSecond,x.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Y=k.animations[0].getRange(h);if(!Y)return!1;const J=Y.from,G=Y.to,l=k.animations[0].getKeys(),A=k.length,K=k.getParent(),a=this.getParent(),N=I&&K&&A&&this.length&&A!==this.length,X=N&&a&&K?a.length/K.length:1,c=I&&!a&&q&&(1!==q.x||1!==q.y||1!==q.z),W=this.animations[0].getKeys();let f,M,T;for(let x=0,j=l.length;x<j;x++)f=l[x],f.frame>=J&&f.frame<=G&&(I?(T=f.value.clone(),N?(M=T.getTranslation(),T.setTranslation(M.scaleInPlace(X))):c&&q?(M=T.getTranslation(),T.setTranslation(M.multiplyInPlace(q))):T=f.value):T=f.value,W.push({frame:f.frame+o,value:T}));return this.animations[0].createRange(h,J+o,G+o),!0}),X&&(X.prototype._animate=function(k){if(!this.animationsEnabled)return;const h=A.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=h}this.deltaTime=void 0!==k?k:this.useConstantAnimationDeltaTime?16:(h-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=h;const o=this._activeAnimatables;if(0===o.length)return;this._animationTime+=this.deltaTime;const I=this._animationTime;for(let x=0;x<o.length;x++){const k=o[x];!k._animate(I)&&k.disposeOnEnd&&x--}!function(k){if(k._registeredForLateAnimationBindings.length){for(let h=0;h<k._registeredForLateAnimationBindings.length;h++){const o=k._registeredForLateAnimationBindings.data[h];for(const k in o._lateAnimationHolders){const h=o._lateAnimationHolders[k],I=h.animations[0],q=h.originalValue;if(void 0===q||null===q)continue;const Y=x.c.AllowMatrixDecomposeForInterpolation&&q.m;let J=o[k];if(Y)J=a(h);else if(void 0!==q.w)J=N(h,J||G.Quaternion.Identity());else{let k=0,o=1;const Y=I&&I._animationState.loopMode===x.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(h.totalWeight<1)J=Y?q.clone?q.clone():q:I&&q.scale?q.scale(1-h.totalWeight):I?q*(1-h.totalWeight):q.clone?q.clone():q;else if(I){o=h.totalWeight;const x=I.weight/o;J=1!==x?I.currentValue.scale?I.currentValue.scale(x):I.currentValue*x:I.currentValue,Y&&(J.addToRef?J.addToRef(q,J):J+=q),k=1}for(let x=k;x<h.animations.length;x++){const k=h.animations[x],I=k.weight/o;I&&(k.currentValue.scaleAndAddToRef?k.currentValue.scaleAndAddToRef(I,J):J+=k.currentValue*I)}for(let x=0;x<h.additiveAnimations.length;x++){const k=h.additiveAnimations[x],o=k.weight;o&&(k.currentValue.scaleAndAddToRef?k.currentValue.scaleAndAddToRef(o,J):J+=k.currentValue*o)}}o[k]=J}o._lateAnimationHolders={}}k._registeredForLateAnimationBindings.reset()}}(this)},X.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((k,h)=>k.playOrder-h.playOrder))},X.prototype.beginWeightedAnimation=function(k,h,o){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,I=arguments.length>4?arguments[4]:void 0,q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7?arguments[7]:void 0,G=arguments.length>8?arguments[8]:void 0,l=arguments.length>9?arguments[9]:void 0,A=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const K=this.beginAnimation(k,h,o,I,q,Y,J,!1,G,l,A);return K.weight=x,K},X.prototype.beginAnimation=function(k,h,o,x){let I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,q=arguments.length>5?arguments[5]:void 0,Y=arguments.length>6?arguments[6]:void 0,J=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],G=arguments.length>8?arguments[8]:void 0,l=arguments.length>9?arguments[9]:void 0,A=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(I<0){const k=h;h=o,o=k,I=-I}h>o&&(I=-I),J&&this.stopAnimation(k,void 0,G),Y||(Y=new K(this,k,h,o,x,I,q,void 0,l,A));const a=!G||G(k);if(k.animations&&a&&Y.appendAnimations(k,k.animations),k.getAnimatables){const A=k.getAnimatables();for(let k=0;k<A.length;k++)this.beginAnimation(A[k],h,o,x,I,q,Y,J,G,l)}return Y.reset(),Y},X.prototype.beginHierarchyAnimation=function(k,h,o,x,I){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7?arguments[7]:void 0,G=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],l=arguments.length>9?arguments[9]:void 0,A=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const K=k.getDescendants(h),a=[];a.push(this.beginAnimation(k,o,x,I,q,Y,J,G,l,void 0,A));for(const N of K)a.push(this.beginAnimation(N,o,x,I,q,Y,J,G,l,void 0,A));return a},X.prototype.beginDirectAnimation=function(k,h,o,x,I){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(q<0){const k=o;o=x,x=k,q=-q}return o>x&&(q=-q),new K(this,k,o,x,I,q,arguments.length>6?arguments[6]:void 0,h,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},X.prototype.beginDirectHierarchyAnimation=function(k,h,o,x,I,q,Y,J,G){let l=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const A=k.getDescendants(h),K=[];K.push(this.beginDirectAnimation(k,o,x,I,q,Y,J,G,l));for(const a of A)K.push(this.beginDirectAnimation(a,o,x,I,q,Y,J,G,l));return K},X.prototype.getAnimatableByTarget=function(k){for(let h=0;h<this._activeAnimatables.length;h++)if(this._activeAnimatables[h].target===k)return this._activeAnimatables[h];return null},X.prototype.getAllAnimatablesByTarget=function(k){const h=[];for(let o=0;o<this._activeAnimatables.length;o++)this._activeAnimatables[o].target===k&&h.push(this._activeAnimatables[o]);return h},X.prototype.stopAnimation=function(k,h,o){const x=this.getAllAnimatablesByTarget(k);for(const I of x)I.stop(h,o)},X.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let k=0;k<this._activeAnimatables.length;k++)this._activeAnimatables[k].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const k of this.animationGroups)k.stop()});class f{getClassName(){return"TargetedAnimation"}serialize(){const k={};return k.animation=this.animation.serialize(),k.targetId=this.target.id,k}}class M{get mask(){return this._mask}set mask(k){this._mask!==k&&(this._mask=k,this.syncWithMask(!0))}syncWithMask(){let k=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||k){this._numActiveAnimatables=0;for(let k=0;k<this._animatables.length;++k){const h=this._animatables[k];!this.mask||this.mask.disabled||this.mask.retainsTarget(h.target.name)?(this._numActiveAnimatables++,h.paused&&h.restart()):h.paused||h.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let k=0;k<this._animatables.length;++k){const h=this._animatables[k];this.mask.retainsTarget(h.target.name)||(h.stop(),this._animatables.splice(k,1),--k)}for(let k=0;k<this._targetedAnimations.length;k++){const h=this._targetedAnimations[k];this.mask.retainsTarget(h.target.name)||(this._targetedAnimations.splice(k,1),--k)}}}get from(){return this._from}set from(k){if(this._from!==k){this._from=k;for(let k=0;k<this._animatables.length;k++){this._animatables[k].fromFrame=this._from}}}get to(){return this._to}set to(k){if(this._to!==k){this._to=k;for(let k=0;k<this._animatables.length;k++){this._animatables[k].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(k){if(this._speedRatio!==k){this._speedRatio=k;for(let k=0;k<this._animatables.length;k++){this._animatables[k].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(k){if(this._loopAnimation!==k){this._loopAnimation=k;for(let k=0;k<this._animatables.length;k++){this._animatables[k].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(k){if(this._isAdditive!==k){this._isAdditive=k;for(let k=0;k<this._animatables.length;k++){this._animatables[k].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(k){this._weight!==k&&(this._weight=k,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(k){if(this._playOrder!==k&&(this._playOrder=k,this._animatables.length>0)){for(let k=0;k<this._animatables.length;k++)this._animatables[k].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(k){if(this._enableBlending!==k&&(this._enableBlending=k,null!==k))for(let h=0;h<this._targetedAnimations.length;++h)this._targetedAnimations[h].animation.enableBlending=k}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(k){if(this._blendingSpeed!==k&&(this._blendingSpeed=k,null!==k))for(let h=0;h<this._targetedAnimations.length;++h)this._targetedAnimations[h].animation.blendingSpeed=k}getLength(k,h){k=k??this._from;return((h=h??this._to)-k)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(k){let h=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=arguments.length>3?arguments[3]:void 0;if(0===k.length)return null;x=x??k[0].weight;let I=Number.MAX_VALUE,q=-Number.MAX_VALUE;if(o)for(const J of k)J.from<I&&(I=J.from),J.to>q&&(q=J.to);const Y=new M(k[0].name+"_merged",k[0]._scene,x);for(const J of k){o&&J.normalize(I,q);for(const k of J.targetedAnimations)Y.addTargetedAnimation(k.animation,k.target);h&&J.dispose()}return Y}constructor(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=k,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new I.d,this.onAnimationLoopObservable=new I.d,this.onAnimationGroupLoopObservable=new I.d,this.onAnimationGroupEndObservable=new I.d,this.onAnimationGroupPauseObservable=new I.d,this.onAnimationGroupPlayObservable=new I.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=h||q.b.LastCreatedScene,this._weight=o,this._playOrder=x,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(k,h){const o=new f;o.animation=k,o.target=h;const x=k.getKeys();return this._from>x[0].frame&&(this._from=x[0].frame),this._to<x[x.length-1].frame&&(this._to=x[x.length-1].frame),null!==this._enableBlending&&(k.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(k.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(o),this._shouldStart=!0,o}removeTargetedAnimation(k){for(let h=this._targetedAnimations.length-1;h>-1;h--){this._targetedAnimations[h].animation===k&&this._targetedAnimations.splice(h,1)}}normalize(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==k&&(k=this._from),null==h&&(h=this._to);for(let o=0;o<this._targetedAnimations.length;o++){const x=this._targetedAnimations[o].animation.getKeys(),I=x[0],q=x[x.length-1];if(I.frame>k){const h={frame:k,value:I.value,inTangent:I.inTangent,outTangent:I.outTangent,interpolation:I.interpolation};x.splice(0,0,h)}if(q.frame<h){const k={frame:h,value:q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation};x.push(k)}}return this._from=k,this._to=h,this}_processLoop(k,h,o){k.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(h),this._animationLoopFlags[o]||(this._animationLoopFlags[o]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let k=arguments.length>0&&void 0!==arguments[0]&&arguments[0],h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments.length>2?arguments[2]:void 0,x=arguments.length>3?arguments[3]:void 0,I=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=k,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let q=0;q<this._targetedAnimations.length;q++){const Y=this._targetedAnimations[q],J=this._scene.beginDirectAnimation(Y.target,[Y.animation],void 0!==o?o:this._from,void 0!==x?x:this._to,k,h,void 0,void 0,void 0!==I?I:this._isAdditive);J.weight=this._weight,J.playOrder=this._playOrder,J.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Y),this._checkAnimationGroupEnded(J)},this._processLoop(J,Y,q),this._animatables.push(J)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=h,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let k=0;k<this._animatables.length;k++){this._animatables[k].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(k){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==k&&(this.loopAnimation=k),this.restart()):(this.stop(),this.start(k,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let k=0;k<this._animatables.length;k++){this._animatables[k].reset()}return this}restart(){if(!this._isStarted)return this;for(let k=0;k<this._animatables.length;k++){this._animatables[k].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let k=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const h=this._animatables.slice();for(let x=0;x<h.length;x++)h[x].stop(void 0,void 0,!0,k);let o=0;for(let x=0;x<this._scene._activeAnimatables.length;x++){const h=this._scene._activeAnimatables[x];h._runtimeAnimations.length>0?this._scene._activeAnimatables[o++]=h:k&&this._checkAnimationGroupEnded(h,k)}return this._scene._activeAnimatables.length=o,this._isStarted=!1,this}setWeightForAllAnimatables(k){for(let h=0;h<this._animatables.length;h++){this._animatables[h].weight=k}return this}syncAllAnimationsWith(k){for(let h=0;h<this._animatables.length;h++){this._animatables[h].syncWith(k)}return this}goToFrame(k){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let o=0;o<this._animatables.length;o++){this._animatables[o].goToFrame(k,h)}return this}getCurrentFrame(){var k;return(null===(k=this.animatables[0])||void 0===k?void 0:k.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const k=this._scene.animationGroups.indexOf(this);if(k>-1&&this._scene.animationGroups.splice(k,1),this._parentContainer){const k=this._parentContainer.animationGroups.indexOf(this);k>-1&&this._parentContainer.animationGroups.splice(k,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(k){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const o=this._animatables.indexOf(k);o>-1&&this._animatables.splice(o,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,h||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(k,h){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const x=new M(k||this.name,this._scene,this._weight,this._playOrder);x._from=this.from,x._to=this.to,x._speedRatio=this.speedRatio,x._loopAnimation=this.loopAnimation,x._isAdditive=this.isAdditive,x._enableBlending=this.enableBlending,x._blendingSpeed=this.blendingSpeed,x.metadata=this.metadata,x.mask=this.mask;for(const I of this._targetedAnimations)x.addTargetedAnimation(o?I.animation.clone():I.animation,h?h(I.target):I.target);return x}serialize(){const k={};k.name=this.name,k.from=this.from,k.to=this.to,k.speedRatio=this.speedRatio,k.loopAnimation=this.loopAnimation,k.isAdditive=this.isAdditive,k.weight=this.weight,k.playOrder=this.playOrder,k.enableBlending=this.enableBlending,k.blendingSpeed=this.blendingSpeed,k.targetedAnimations=[];for(let h=0;h<this.targetedAnimations.length;h++){const o=this.targetedAnimations[h];k.targetedAnimations[h]=o.serialize()}return Y.d&&Y.d.HasTags(this)&&(k.tags=Y.d.GetTags(this)),this.metadata&&(k.metadata=this.metadata),k}static Parse(k,h){const o=new M(k.name,h,k.weight,k.playOrder);for(let I=0;I<k.targetedAnimations.length;I++){const q=k.targetedAnimations[I],Y=x.c.Parse(q.animation),J=q.targetId;if("influence"===q.animation.property){const k=h.getMorphTargetById(J);k&&o.addTargetedAnimation(Y,k)}else{const k=h.getNodeById(J);null!=k&&o.addTargetedAnimation(Y,k)}}return Y.d&&Y.d.AddTagsTo(o,k.tags),null!==k.from&&null!==k.to&&o.normalize(k.from,k.to),void 0!==k.speedRatio&&(o._speedRatio=k.speedRatio),void 0!==k.loopAnimation&&(o._loopAnimation=k.loopAnimation),void 0!==k.isAdditive&&(o._isAdditive=k.isAdditive),void 0!==k.weight&&(o._weight=k.weight),void 0!==k.playOrder&&(o._playOrder=k.playOrder),void 0!==k.enableBlending&&(o._enableBlending=k.enableBlending),void 0!==k.blendingSpeed&&(o._blendingSpeed=k.blendingSpeed),void 0!==k.metadata&&(o.metadata=k.metadata),o}static MakeAnimationAdditive(k,h,o){let I;I="object"===typeof h?h:{referenceFrame:h,range:o,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let q=k;I.cloneOriginalAnimationGroup&&(q=k.clone(I.clonedAnimationGroupName||q.name));const Y=q.targetedAnimations;for(let J=0;J<Y.length;J++){const k=Y[J];k.animation=x.c.MakeAnimationAdditive(k.animation,I)}if(q.isAdditive=!0,I.clipKeys){let k=Number.MAX_VALUE,h=-Number.MAX_VALUE;const o=q.targetedAnimations;for(let x=0;x<o.length;x++){const I=o[x].animation.getKeys();k>I[0].frame&&(k=I[0].frame),h<I[I.length-1].frame&&(h=I[I.length-1].frame)}q._from=k,q._to=h}return q}static ClipKeys(k,h,o,x,I){const q=k.clone(x||k.name);return M.ClipKeysInPlace(q,h,o,I)}static ClipKeysInPlace(k,h,o,x){return M.ClipInPlace(k,h,o,x,!1)}static ClipFrames(k,h,o,x,I){const q=k.clone(x||k.name);return M.ClipFramesInPlace(q,h,o,I)}static ClipFramesInPlace(k,h,o,x){return M.ClipInPlace(k,h,o,x,!0)}static ClipInPlace(k,h,o,x){let I=arguments.length>4&&void 0!==arguments[4]&&arguments[4],q=Number.MAX_VALUE,Y=-Number.MAX_VALUE;const J=k.targetedAnimations;for(let G=0;G<J.length;G++){const k=J[G],l=x?k.animation:k.animation.clone();I&&(l.createKeyForFrame(h),l.createKeyForFrame(o));const A=l.getKeys(),K=[];let a=Number.MAX_VALUE;for(let x=0;x<A.length;x++){const k=A[x];if(!I&&x>=h&&x<=o||I&&k.frame>=h&&k.frame<=o){const h={frame:k.frame,value:k.value.clone?k.value.clone():k.value,inTangent:k.inTangent,outTangent:k.outTangent,interpolation:k.interpolation,lockedTangent:k.lockedTangent};a===Number.MAX_VALUE&&(a=h.frame),h.frame-=a,K.push(h)}}0!==K.length?(q>K[0].frame&&(q=K[0].frame),Y<K[K.length-1].frame&&(Y=K[K.length-1].frame),l.setKeys(K,!0),k.animation=l):(J.splice(G,1),G--)}return k._from=q,k._to=Y,k}getClassName(){return"AnimationGroup"}toString(k){let h="Name: "+this.name;return h+=", type: "+this.getClassName(),k&&(h+=", from: "+this._from,h+=", to: "+this._to,h+=", isStarted: "+this._isStarted,h+=", speedRatio: "+this._speedRatio,h+=", targetedAnimations length: "+this._targetedAnimations.length,h+=", animatables length: "+this._animatables),h}}}}]);