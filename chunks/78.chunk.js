"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[78],{14771:(U,X,b)=>{b.r(X),b.d(X,{AnimationGroup:()=>O,TargetedAnimation:()=>I});var F=b(12142),E=b(11392),w=b(11442),Q=b(11630),z=b(13199),q=b(11593);class p{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(U,X,b,E){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=X,this._target=U,this._scene=b,this._host=E,this._activeTargets=[],X._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===F.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=q.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const U={frame:0,value:this._minValue};this._keys.splice(0,0,U)}if(this._target instanceof Array){let U=0;for(const X of this._target)this._preparePath(X,U),this._getOriginalValues(U),U++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const w=X.getEvents();if(w&&w.length>0)for(const F of w)this._events.push(F._clone());this._enableBlending=U&&U.animationPropertiesOverride?U.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=this._animation.targetPropertyPath;if(b.length>1){let F=U;for(let U=0;U<b.length-1;U++){const X=b[U];if(F=F[X],void 0===F)throw new Error(`Invalid property (${X}) in property path (${b.join(".")})`)}this._targetPath=b[b.length-1],this._activeTargets[X]=F}else this._targetPath=b[0],this._activeTargets[X]=U;if(void 0===this._activeTargets[X][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${b.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let U=0;for(const X of this._target)void 0!==this._originalValue[U]&&this._setValue(X,this._activeTargets[U],this._originalValue[U],-1,U),U++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let U=0;U<this._events.length;U++)this._events[U].isDone=!1}isStopped(){return this._stopped}dispose(){const U=this._animation.runtimeAnimations.indexOf(this);U>-1&&this._animation.runtimeAnimations.splice(U,1)}setValue(U,X){if(this._targetIsArray)for(let b=0;b<this._target.length;b++){const F=this._target[b];this._setValue(F,this._activeTargets[b],U,X,b)}else this._setValue(this._target,this._directTarget,U,X,0)}_getOriginalValues(){let U,X=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=this._activeTargets[X];U=b.getLocalMatrix&&"_matrix"===this._targetPath?b.getLocalMatrix():b[this._targetPath],U&&U.clone?this._originalValue[X]=U.clone():this._originalValue[X]=U}_registerTargetForLateAnimationBinding(U,X){const b=U.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(b),b._lateAnimationHolders||(b._lateAnimationHolders={}),b._lateAnimationHolders[U.targetPath]||(b._lateAnimationHolders[U.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:X}),U.isAdditive?(b._lateAnimationHolders[U.targetPath].additiveAnimations.push(U),b._lateAnimationHolders[U.targetPath].totalAdditiveWeight+=U.weight):(b._lateAnimationHolders[U.targetPath].animations.push(U),b._lateAnimationHolders[U.targetPath].totalWeight+=U.weight)}_setValue(U,X,b,E,w){if(this._currentActiveTarget=X,this._weight=E,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const U=X[this._targetPath];U.clone?this._originalBlendValue=U.clone():this._originalBlendValue=U}this._originalBlendValue.m?F.e.AllowMatrixDecomposeForInterpolation?this._currentValue?q.Matrix.DecomposeLerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=q.Matrix.DecomposeLerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue?q.Matrix.LerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=q.Matrix.Lerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue=F.e._UniversalLerp(this._originalBlendValue,b,this._blendingFactor);const E=U&&U.animationPropertiesOverride?U.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=E}else this._currentValue?this._currentValue.q?this._currentValue.q(b):this._currentValue=b:null!==b&&void 0!==b&&b.clone?this._currentValue=b.clone():this._currentValue=b;-1!==E?this._registerTargetForLateAnimationBinding(this,this._originalValue[w]):this._animationState.loopMode===F.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[w],X[this._targetPath]):X[this._targetPath]=this._originalValue[w]+this._currentValue:X[this._targetPath]=this._currentValue,U.Cp&&U.Cp(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const b=this._animation.getKeys();U<b[0].frame?U=b[0].frame:U>b[b.length-1].frame&&(U=b[b.length-1].frame);const F=this._events;if(F.length)for(let w=0;w<F.length;w++)F[w].onlyOnce||(F[w].isDone=F[w].frame<U);this._currentFrame=U;const E=this._animation._interpolate(U,this._animationState);this.setValue(E,X)}_prepareForSpeedRatioChange(U){const X=this._previousElapsedTime*(this._animation.framePerSecond*U)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-X}animate(U,X,b,E,w){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const z=this._animation,q=z.targetPropertyPath;if(!q||q.length<1)return this._stopped=!0,!1;let p,S=!0;const R=this._events;let n=0;if(this._coreRuntimeAnimation)n=b-X,p=this._coreRuntimeAnimation.currentFrame,this._currentFrame=p,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let Q;(X<this._minFrame||X>this._maxFrame)&&(X=this._minFrame),(b<this._minFrame||b>this._maxFrame)&&(b=this._maxFrame),n=b-X;let q=U*(z.framePerSecond*w)/1e3+this._absoluteFrameOffset,a=0,J=!1;const m=E&&this._animationState.loopMode===F.e.ANIMATIONLOOPMODE_YOYO;if(m){const U=(q-X)/n,b=Math.sin(U*Math.PI);q=Math.abs(b)*n+X;const F=b>=0?1:-1;this._yoyoDirection!==F&&(J=!0),this._yoyoDirection=F}if(this._previousElapsedTime=U,this._previousAbsoluteFrame=q,!E&&b>=X&&(q>=n&&w>0||q<=0&&w<0))S=!1,a=z._getKeyValue(this._maxValue);else if(!E&&X>=b&&(q<=n&&w<0||q>=0&&w>0))S=!1,a=z._getKeyValue(this._minValue);else if(this._animationState.loopMode!==F.e.ANIMATIONLOOPMODE_CYCLE){const U=b.toString()+X.toString();if(!this._offsetsCache[U]){this._animationState.repeatCount=0,this._animationState.loopMode=F.e.ANIMATIONLOOPMODE_CYCLE;const E=z._interpolate(X,this._animationState),w=z._interpolate(b,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),z.dataType){case F.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[U]=w-E;break;case F.e.ANIMATIONTYPE_QUATERNION:case F.e.ANIMATIONTYPE_VECTOR3:case F.e.ANIMATIONTYPE_VECTOR2:case F.e.ANIMATIONTYPE_SIZE:case F.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[U]=w.mX(E)}this._highLimitsCache[U]=w}a=this._highLimitsCache[U],Q=this._offsetsCache[U]}if(void 0===Q)switch(z.dataType){case F.e.ANIMATIONTYPE_FLOAT:Q=0;break;case F.e.ANIMATIONTYPE_QUATERNION:Q=F.n;break;case F.e.ANIMATIONTYPE_VECTOR3:Q=F.u;break;case F.e.ANIMATIONTYPE_VECTOR2:Q=F.t;break;case F.e.ANIMATIONTYPE_SIZE:Q=F.r;break;case F.e.ANIMATIONTYPE_COLOR3:Q=F.h;break;case F.e.ANIMATIONTYPE_COLOR4:Q=F.j}if(this._host&&this._host.syncRoot){const U=this._host.syncRoot;p=X+n*((U.masterFrame-U.fromFrame)/(U.toFrame-U.fromFrame))}else p=q>0&&X>b||q<0&&X<b?S&&0!==n?b+q%n:X:S&&0!==n?X+q%n:b;if(!m&&(w>0&&this.currentFrame>p||w<0&&this.currentFrame<p)||m&&J){this._onLoop();for(let U=0;U<R.length;U++)R[U].onlyOnce||(R[U].isDone=!1);this._animationState.key=w>0?0:z.getKeys().length-1}this._currentFrame=p,this._animationState.repeatCount=0===n?0:q/n|0,this._animationState.highLimitValue=a,this._animationState.offsetValue=Q}const a=z._interpolate(p,this._animationState);if(this.setValue(a,Q),R.length)for(let F=0;F<R.length;F++)if(n>=0&&p>=R[F].frame&&R[F].frame>=X||n<0&&p<=R[F].frame&&R[F].frame<=X){const U=R[F];U.isDone||(U.onlyOnce&&(R.splice(F,1),F--),U.isDone=!0,U.action(p))}return S||(this._stopped=!0),S}}var S=b(11421);class R{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(U){this._weight=-1!==U?Math.min(Math.max(U,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(U){for(let X=0;X<this._runtimeAnimations.length;X++){this._runtimeAnimations[X]._prepareForSpeedRatioChange(U)}this._speedRatio=U,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(U,X){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,w=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,z=arguments.length>6?arguments[6]:void 0,q=arguments.length>7?arguments[7]:void 0,p=arguments.length>8?arguments[8]:void 0,S=arguments.length>9&&void 0!==arguments[9]&&arguments[9],R=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=X,this.fromFrame=b,this.toFrame=F,this.loopAnimation=w,this.onAnimationEnd=z,this.onAnimationLoop=p,this.isAdditive=S,this.playOrder=R,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Wz=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new E.e,this.onAnimationLoopObservable=new E.e,this._scene=U,q&&this.appendAnimations(X,q),this._speedRatio=Q,U._activeAnimatables.push(this)}syncWith(U){if(this._syncRoot=U,U){const U=this._scene._activeAnimatables.indexOf(this);U>-1&&(this._scene._activeAnimatables.splice(U,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(U,X){for(let b=0;b<X.length;b++){const F=X[b],E=new p(U,F,this._scene,this);E._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(E)}}getAnimationByTargetProperty(U){const X=this._runtimeAnimations;for(let b=0;b<X.length;b++)if(X[b].animation.targetProperty===U)return X[b].animation;return null}getRuntimeAnimationByTargetProperty(U){const X=this._runtimeAnimations;for(let b=0;b<X.length;b++)if(X[b].animation.targetProperty===U)return X[b];return null}reset(){const U=this._runtimeAnimations;for(let X=0;X<U.length;X++)U[X].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(U){const X=this._runtimeAnimations;for(let b=0;b<X.length;b++)X[b].animation.enableBlending=!0,X[b].animation.blendingSpeed=U}disableBlending(){const U=this._runtimeAnimations;for(let X=0;X<U.length;X++)U[X].animation.enableBlending=!1}goToFrame(U){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._runtimeAnimations;if(b[0]){const X=b[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??b[0].currentFrame;const F=0===this.speedRatio?0:(U-this._frameToSyncFromJump)/X*1e3/this.speedRatio;this._manualJumpDelay=-F}for(let F=0;F<b.length;F++)b[F].goToFrame(U,X?this._weight:-1);this._goToFrame=U}get paused(){return this.Wz}pause(){this.Wz||(this.Wz=!0)}restart(){this.Wz=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(U,X){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],F=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(U||X){const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){const w=this._runtimeAnimations;for(let b=w.length-1;b>=0;b--){const F=w[b];U&&F.animation.name!=U||(X&&!X(F.target)||(F.dispose(),w.splice(b,1)))}0==w.length&&(b||this._scene._activeAnimatables.splice(E,1),F||this._raiseOnAnimationEnd())}}else{const U=this._scene._activeAnimatables.indexOf(this);if(U>-1){b||this._scene._activeAnimatables.splice(U,1);const X=this._runtimeAnimations;for(let U=0;U<X.length;U++)X[U].dispose();this._runtimeAnimations.length=0,F||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((U=>{this.onAnimationEndObservable.add((()=>{U(this)}),void 0,void 0,this,!0)}))}_animate(U){if(this.Wz)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=U),!0;if(null===this._localDelayOffset?(this._localDelayOffset=U,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=U-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let X=!1;const b=this._runtimeAnimations;let F;for(F=0;F<b.length;F++){const E=b[F].animate(U-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);X=X||E}if(this.animationStarted=X,!X){if(this.disposeOnEnd)for(F=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(F,1),F=0;F<b.length;F++)b[F].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return X}}function n(U){if(0===U.totalWeight&&0===U.totalAdditiveWeight)return U.originalValue;let X=1;const b=q.TmpVectors.JX[0],F=q.TmpVectors.JX[1],E=q.TmpVectors.Quaternion[0];let w=0;const Q=U.animations[0],z=U.originalValue;let p=1,S=!1;if(U.totalWeight<1)p=1-U.totalWeight,z.decompose(F,E,b);else{if(w=1,X=U.totalWeight,p=Q.weight/X,1==p){if(!U.totalAdditiveWeight)return Q.currentValue;S=!0}Q.currentValue.decompose(F,E,b)}if(!S){F.scaleInPlace(p),b.scaleInPlace(p),E.scaleInPlace(p);for(let Q=w;Q<U.animations.length;Q++){const w=U.animations[Q];if(0===w.weight)continue;p=w.weight/X;const z=q.TmpVectors.JX[2],S=q.TmpVectors.JX[3],R=q.TmpVectors.Quaternion[1];w.currentValue.decompose(S,R,z),S.scaleAndAddToRef(p,F),R.scaleAndAddToRef(q.Quaternion.Dot(E,R)>0?p:-p,E),z.scaleAndAddToRef(p,b)}E.normalize()}for(let n=0;n<U.additiveAnimations.length;n++){const X=U.additiveAnimations[n];if(0===X.weight)continue;const w=q.TmpVectors.JX[2],Q=q.TmpVectors.JX[3],z=q.TmpVectors.Quaternion[1];X.currentValue.decompose(Q,z,w),Q.multiplyToRef(F,Q),q.JX.LerpToRef(F,Q,X.weight,F),E.multiplyToRef(z,z),q.Quaternion.SlerpToRef(E,z,X.weight,E),w.scaleAndAddToRef(X.weight,b)}const R=Q?Q._animationState.workValue:q.TmpVectors.Matrix[0].clone();return q.Matrix.ComposeToRef(F,E,b,R),R}function a(U,X){if(0===U.totalWeight&&0===U.totalAdditiveWeight)return X;const b=U.animations[0],F=U.originalValue;let E=X;if(0===U.totalWeight&&U.totalAdditiveWeight>0)E.q(F);else if(1===U.animations.length){if(q.Quaternion.SlerpToRef(F,b.currentValue,Math.min(1,U.totalWeight),E),0===U.totalAdditiveWeight)return E}else if(U.animations.length>1){let b,w,Q=1;if(U.totalWeight<1){const X=1-U.totalWeight;b=[],w=[],b.push(F),w.push(X)}else{if(2===U.animations.length&&(q.Quaternion.SlerpToRef(U.animations[0].currentValue,U.animations[1].currentValue,U.animations[1].weight/U.totalWeight,X),0===U.totalAdditiveWeight))return X;b=[],w=[],Q=U.totalWeight}for(let X=0;X<U.animations.length;X++){const F=U.animations[X];b.push(F.currentValue),w.push(F.weight/Q)}let z=0;for(let U=0;U<b.length;)U?(z+=w[U],q.Quaternion.SlerpToRef(E,b[U],w[U]/z,E),U++):(q.Quaternion.SlerpToRef(b[U],b[U+1],w[U+1]/(w[U]+w[U+1]),X),E=X,z=w[U]+w[U+1],U+=2)}for(let w=0;w<U.additiveAnimations.length;w++){const X=U.additiveAnimations[w];0!==X.weight&&(E.multiplyToRef(X.currentValue,q.TmpVectors.Quaternion[0]),q.Quaternion.SlerpToRef(E,q.TmpVectors.Quaternion[0],X.weight,E))}return E}var J,m,x=b(11833);J=x.c,(m=z.e)&&(m.prototype.copyAnimationRange=function(U,X,b){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new F.e(this.name,"_matrix",U.animations[0].framePerSecond,F.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Q=U.animations[0].getRange(X);if(!Q)return!1;const z=Q.from,q=Q.to,p=U.animations[0].getKeys(),S=U.length,R=U.getParent(),n=this.getParent(),a=E&&R&&S&&this.length&&S!==this.length,J=a&&n&&R?n.length/R.length:1,m=E&&!n&&w&&(1!==w.x||1!==w.y||1!==w.z),x=this.animations[0].getKeys();let I,O,N;for(let F=0,u=p.length;F<u;F++)I=p[F],I.frame>=z&&I.frame<=q&&(E?(N=I.value.clone(),a?(O=N.getTranslation(),N.setTranslation(O.scaleInPlace(J))):m&&w?(O=N.getTranslation(),N.setTranslation(O.multiplyInPlace(w))):N=I.value):N=I.value,x.push({frame:I.frame+b,value:N}));return this.animations[0].createRange(X,z+b,q+b),!0}),J&&(J.prototype._animate=function(U){if(!this.animationsEnabled)return;const X=S.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=X}this.deltaTime=void 0!==U?U:this.useConstantAnimationDeltaTime?16:(X-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=X;const b=this._activeAnimatables;if(0===b.length)return;this._animationTime+=this.deltaTime;const E=this._animationTime;for(let F=0;F<b.length;F++){const U=b[F];!U._animate(E)&&U.disposeOnEnd&&F--}!function(U){if(U._registeredForLateAnimationBindings.length){for(let X=0;X<U._registeredForLateAnimationBindings.length;X++){const b=U._registeredForLateAnimationBindings.data[X];for(const U in b._lateAnimationHolders){const X=b._lateAnimationHolders[U],E=X.animations[0],w=X.originalValue;if(void 0===w||null===w)continue;const Q=F.e.AllowMatrixDecomposeForInterpolation&&w.m;let z=b[U];if(Q)z=n(X);else if(void 0!==w.w)z=a(X,z||q.Quaternion.Identity());else{let U=0,b=1;const Q=E&&E._animationState.loopMode===F.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(X.totalWeight<1)z=Q?w.clone?w.clone():w:E&&w.scale?w.scale(1-X.totalWeight):E?w*(1-X.totalWeight):w.clone?w.clone():w;else if(E){b=X.totalWeight;const F=E.weight/b;z=1!==F?E.currentValue.scale?E.currentValue.scale(F):E.currentValue*F:E.currentValue,Q&&(z.addToRef?z.addToRef(w,z):z+=w),U=1}for(let F=U;F<X.animations.length;F++){const U=X.animations[F],E=U.weight/b;E&&(U.currentValue.scaleAndAddToRef?U.currentValue.scaleAndAddToRef(E,z):z+=U.currentValue*E)}for(let F=0;F<X.additiveAnimations.length;F++){const U=X.additiveAnimations[F],b=U.weight;b&&(U.currentValue.scaleAndAddToRef?U.currentValue.scaleAndAddToRef(b,z):z+=U.currentValue*b)}}b[U]=z}b._lateAnimationHolders={}}U._registeredForLateAnimationBindings.reset()}}(this)},J.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((U,X)=>U.playOrder-X.playOrder))},J.prototype.beginWeightedAnimation=function(U,X,b){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,E=arguments.length>4?arguments[4]:void 0,w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Q=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,q=arguments.length>8?arguments[8]:void 0,p=arguments.length>9?arguments[9]:void 0,S=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const R=this.beginAnimation(U,X,b,E,w,Q,z,!1,q,p,S);return R.weight=F,R},J.prototype.beginAnimation=function(U,X,b,F){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,w=arguments.length>5?arguments[5]:void 0,Q=arguments.length>6?arguments[6]:void 0,z=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],q=arguments.length>8?arguments[8]:void 0,p=arguments.length>9?arguments[9]:void 0,S=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(E<0){const U=X;X=b,b=U,E=-E}X>b&&(E=-E),z&&this.stopAnimation(U,void 0,q),Q||(Q=new R(this,U,X,b,F,E,w,void 0,p,S));const n=!q||q(U);if(U.animations&&n&&Q.appendAnimations(U,U.animations),U.getAnimatables){const S=U.getAnimatables();for(let U=0;U<S.length;U++)this.beginAnimation(S[U],X,b,F,E,w,Q,z,q,p)}return Q.reset(),Q},J.prototype.beginHierarchyAnimation=function(U,X,b,F,E){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Q=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,q=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],p=arguments.length>9?arguments[9]:void 0,S=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const R=U.getDescendants(X),n=[];n.push(this.beginAnimation(U,b,F,E,w,Q,z,q,p,void 0,S));for(const a of R)n.push(this.beginAnimation(a,b,F,E,w,Q,z,q,p,void 0,S));return n},J.prototype.beginDirectAnimation=function(U,X,b,F,E){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(w<0){const U=b;b=F,F=U,w=-w}return b>F&&(w=-w),new R(this,U,b,F,E,w,arguments.length>6?arguments[6]:void 0,X,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},J.prototype.beginDirectHierarchyAnimation=function(U,X,b,F,E,w,Q,z,q){let p=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const S=U.getDescendants(X),R=[];R.push(this.beginDirectAnimation(U,b,F,E,w,Q,z,q,p));for(const n of S)R.push(this.beginDirectAnimation(n,b,F,E,w,Q,z,q,p));return R},J.prototype.getAnimatableByTarget=function(U){for(let X=0;X<this._activeAnimatables.length;X++)if(this._activeAnimatables[X].target===U)return this._activeAnimatables[X];return null},J.prototype.getAllAnimatablesByTarget=function(U){const X=[];for(let b=0;b<this._activeAnimatables.length;b++)this._activeAnimatables[b].target===U&&X.push(this._activeAnimatables[b]);return X},J.prototype.stopAnimation=function(U,X,b){const F=this.getAllAnimatablesByTarget(U);for(const E of F)E.stop(X,b)},J.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let U=0;U<this._activeAnimatables.length;U++)this._activeAnimatables[U].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const U of this.animationGroups)U.stop()});class I{getClassName(){return"TargetedAnimation"}serialize(){const U={};return U.animation=this.animation.serialize(),U.targetId=this.target.id,U}}class O{get mask(){return this._mask}set mask(U){this._mask!==U&&(this._mask=U,this.syncWithMask(!0))}syncWithMask(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||U){this._numActiveAnimatables=0;for(let U=0;U<this._animatables.length;++U){const X=this._animatables[U];!this.mask||this.mask.disabled||this.mask.retainsTarget(X.target.name)?(this._numActiveAnimatables++,X.paused&&X.restart()):X.paused||X.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let U=0;U<this._animatables.length;++U){const X=this._animatables[U];this.mask.retainsTarget(X.target.name)||(X.stop(),this._animatables.splice(U,1),--U)}for(let U=0;U<this._targetedAnimations.length;U++){const X=this._targetedAnimations[U];this.mask.retainsTarget(X.target.name)||(this._targetedAnimations.splice(U,1),--U)}}}get from(){return this._from}set from(U){if(this._from!==U){this._from=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].fromFrame=this._from}}}get to(){return this._to}set to(U){if(this._to!==U){this._to=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(U){if(this._speedRatio!==U){this._speedRatio=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(U){if(this._loopAnimation!==U){this._loopAnimation=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(U){if(this._isAdditive!==U){this._isAdditive=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(U){this._weight!==U&&(this._weight=U,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(U){if(this._playOrder!==U&&(this._playOrder=U,this._animatables.length>0)){for(let U=0;U<this._animatables.length;U++)this._animatables[U].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(U){if(this._enableBlending!==U&&(this._enableBlending=U,null!==U))for(let X=0;X<this._targetedAnimations.length;++X)this._targetedAnimations[X].animation.enableBlending=U}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(U){if(this._blendingSpeed!==U&&(this._blendingSpeed=U,null!==U))for(let X=0;X<this._targetedAnimations.length;++X)this._targetedAnimations[X].animation.blendingSpeed=U}getLength(U,X){U=U??this._from;return((X=X??this._to)-U)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(U){let X=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],F=arguments.length>3?arguments[3]:void 0;if(0===U.length)return null;F=F??U[0].weight;let E=Number.MAX_VALUE,w=-Number.MAX_VALUE;if(b)for(const z of U)z.from<E&&(E=z.from),z.to>w&&(w=z.to);const Q=new O(U[0].name+"_merged",U[0]._scene,F);for(const z of U){b&&z.normalize(E,w);for(const U of z.targetedAnimations)Q.addTargetedAnimation(U.animation,U.target);X&&z.dispose()}return Q}constructor(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=U,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new E.e,this.onAnimationLoopObservable=new E.e,this.onAnimationGroupLoopObservable=new E.e,this.onAnimationGroupEndObservable=new E.e,this.onAnimationGroupPauseObservable=new E.e,this.onAnimationGroupPlayObservable=new E.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=X||w.c.LastCreatedScene,this._weight=b,this._playOrder=F,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(U,X){const b=new I;b.animation=U,b.target=X;const F=U.getKeys();return this._from>F[0].frame&&(this._from=F[0].frame),this._to<F[F.length-1].frame&&(this._to=F[F.length-1].frame),null!==this._enableBlending&&(U.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(U.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(b),this._shouldStart=!0,b}removeTargetedAnimation(U){for(let X=this._targetedAnimations.length-1;X>-1;X--){this._targetedAnimations[X].animation===U&&this._targetedAnimations.splice(X,1)}}normalize(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==U&&(U=this._from),null==X&&(X=this._to);for(let b=0;b<this._targetedAnimations.length;b++){const F=this._targetedAnimations[b].animation.getKeys(),E=F[0],w=F[F.length-1];if(E.frame>U){const X={frame:U,value:E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation};F.splice(0,0,X)}if(w.frame<X){const U={frame:X,value:w.value,inTangent:w.inTangent,outTangent:w.outTangent,interpolation:w.interpolation};F.push(U)}}return this._from=U,this._to=X,this}_processLoop(U,X,b){U.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(X),this._animationLoopFlags[b]||(this._animationLoopFlags[b]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0],X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0,F=arguments.length>3?arguments[3]:void 0,E=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=U,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let w=0;w<this._targetedAnimations.length;w++){const Q=this._targetedAnimations[w],z=this._scene.beginDirectAnimation(Q.target,[Q.animation],void 0!==b?b:this._from,void 0!==F?F:this._to,U,X,void 0,void 0,void 0!==E?E:this._isAdditive);z.weight=this._weight,z.playOrder=this._playOrder,z.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Q),this._checkAnimationGroupEnded(z)},this._processLoop(z,Q,w),this._animatables.push(z)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=X,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let U=0;U<this._animatables.length;U++){this._animatables[U].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(U){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==U&&(this.loopAnimation=U),this.restart()):(this.stop(),this.start(U,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let U=0;U<this._animatables.length;U++){this._animatables[U].reset()}return this}restart(){if(!this._isStarted)return this;for(let U=0;U<this._animatables.length;U++){this._animatables[U].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const X=this._animatables.slice();for(let F=0;F<X.length;F++)X[F].stop(void 0,void 0,!0,U);let b=0;for(let F=0;F<this._scene._activeAnimatables.length;F++){const X=this._scene._activeAnimatables[F];X._runtimeAnimations.length>0?this._scene._activeAnimatables[b++]=X:U&&this._checkAnimationGroupEnded(X,U)}return this._scene._activeAnimatables.length=b,this._isStarted=!1,this}setWeightForAllAnimatables(U){for(let X=0;X<this._animatables.length;X++){this._animatables[X].weight=U}return this}syncAllAnimationsWith(U){for(let X=0;X<this._animatables.length;X++){this._animatables[X].syncWith(U)}return this}goToFrame(U){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].goToFrame(U,X)}return this}getCurrentFrame(){var U;return(null===(U=this.animatables[0])||void 0===U?void 0:U.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const U=this._scene.animationGroups.indexOf(this);if(U>-1&&this._scene.animationGroups.splice(U,1),this._parentContainer){const U=this._parentContainer.animationGroups.indexOf(this);U>-1&&this._parentContainer.animationGroups.splice(U,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(U){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._animatables.indexOf(U);b>-1&&this._animatables.splice(b,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,X||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(U,X){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const F=new O(U||this.name,this._scene,this._weight,this._playOrder);F._from=this.from,F._to=this.to,F._speedRatio=this.speedRatio,F._loopAnimation=this.loopAnimation,F._isAdditive=this.isAdditive,F._enableBlending=this.enableBlending,F._blendingSpeed=this.blendingSpeed,F.metadata=this.metadata,F.mask=this.mask;for(const E of this._targetedAnimations)F.addTargetedAnimation(b?E.animation.clone():E.animation,X?X(E.target):E.target);return F}serialize(){const U={};U.name=this.name,U.from=this.from,U.to=this.to,U.speedRatio=this.speedRatio,U.loopAnimation=this.loopAnimation,U.isAdditive=this.isAdditive,U.weight=this.weight,U.playOrder=this.playOrder,U.enableBlending=this.enableBlending,U.blendingSpeed=this.blendingSpeed,U.targetedAnimations=[];for(let X=0;X<this.targetedAnimations.length;X++){const b=this.targetedAnimations[X];U.targetedAnimations[X]=b.serialize()}return Q.d&&Q.d.HasTags(this)&&(U.tags=Q.d.GetTags(this)),this.metadata&&(U.metadata=this.metadata),U}static Parse(U,X){const b=new O(U.name,X,U.weight,U.playOrder);for(let E=0;E<U.targetedAnimations.length;E++){const w=U.targetedAnimations[E],Q=F.e.Parse(w.animation),z=w.targetId;if("influence"===w.animation.property){const U=X.getMorphTargetById(z);U&&b.addTargetedAnimation(Q,U)}else{const U=X.getNodeById(z);null!=U&&b.addTargetedAnimation(Q,U)}}return Q.d&&Q.d.AddTagsTo(b,U.tags),null!==U.from&&null!==U.to&&b.normalize(U.from,U.to),void 0!==U.speedRatio&&(b._speedRatio=U.speedRatio),void 0!==U.loopAnimation&&(b._loopAnimation=U.loopAnimation),void 0!==U.isAdditive&&(b._isAdditive=U.isAdditive),void 0!==U.weight&&(b._weight=U.weight),void 0!==U.playOrder&&(b._playOrder=U.playOrder),void 0!==U.enableBlending&&(b._enableBlending=U.enableBlending),void 0!==U.blendingSpeed&&(b._blendingSpeed=U.blendingSpeed),void 0!==U.metadata&&(b.metadata=U.metadata),b}static MakeAnimationAdditive(U,X,b){let E;E="object"===typeof X?X:{referenceFrame:X,range:b,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let w=U;E.cloneOriginalAnimationGroup&&(w=U.clone(E.clonedAnimationGroupName||w.name));const Q=w.targetedAnimations;for(let z=0;z<Q.length;z++){const U=Q[z];U.animation=F.e.MakeAnimationAdditive(U.animation,E)}if(w.isAdditive=!0,E.clipKeys){let U=Number.MAX_VALUE,X=-Number.MAX_VALUE;const b=w.targetedAnimations;for(let F=0;F<b.length;F++){const E=b[F].animation.getKeys();U>E[0].frame&&(U=E[0].frame),X<E[E.length-1].frame&&(X=E[E.length-1].frame)}w._from=U,w._to=X}return w}static ClipKeys(U,X,b,F,E){const w=U.clone(F||U.name);return O.ClipKeysInPlace(w,X,b,E)}static ClipKeysInPlace(U,X,b,F){return O.ClipInPlace(U,X,b,F,!1)}static ClipFrames(U,X,b,F,E){const w=U.clone(F||U.name);return O.ClipFramesInPlace(w,X,b,E)}static ClipFramesInPlace(U,X,b,F){return O.ClipInPlace(U,X,b,F,!0)}static ClipInPlace(U,X,b,F){let E=arguments.length>4&&void 0!==arguments[4]&&arguments[4],w=Number.MAX_VALUE,Q=-Number.MAX_VALUE;const z=U.targetedAnimations;for(let q=0;q<z.length;q++){const U=z[q],p=F?U.animation:U.animation.clone();E&&(p.createKeyForFrame(X),p.createKeyForFrame(b));const S=p.getKeys(),R=[];let n=Number.MAX_VALUE;for(let F=0;F<S.length;F++){const U=S[F];if(!E&&F>=X&&F<=b||E&&U.frame>=X&&U.frame<=b){const X={frame:U.frame,value:U.value.clone?U.value.clone():U.value,inTangent:U.inTangent,outTangent:U.outTangent,interpolation:U.interpolation,lockedTangent:U.lockedTangent};n===Number.MAX_VALUE&&(n=X.frame),X.frame-=n,R.push(X)}}0!==R.length?(w>R[0].frame&&(w=R[0].frame),Q<R[R.length-1].frame&&(Q=R[R.length-1].frame),p.setKeys(R,!0),U.animation=p):(z.splice(q,1),q--)}return U._from=w,U._to=Q,U}getClassName(){return"AnimationGroup"}toString(U){let X="Name: "+this.name;return X+=", type: "+this.getClassName(),U&&(X+=", from: "+this._from,X+=", to: "+this._to,X+=", isStarted: "+this._isStarted,X+=", speedRatio: "+this._speedRatio,X+=", targetedAnimations length: "+this._targetedAnimations.length,X+=", animatables length: "+this._animatables),X}}}}]);