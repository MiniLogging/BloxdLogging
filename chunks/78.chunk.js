"use strict";(self["3nlrbof8msu"]=self["3nlrbof8msu"]||[]).push([[78],{15903:(t,b,Z)=>{Z.r(b),Z.d(b,{AnimationGroup:()=>l,TargetedAnimation:()=>u});var J=Z(13261),S=Z(12551),P=Z(12585),v=Z(12768),h=Z(14319),C=Z(12735);class Y{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(t,b,Z,S){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=b,this._target=t,this._scene=Z,this._host=S,this._activeTargets=[],b._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===J.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=C.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const t={frame:0,value:this._minValue};this._keys.splice(0,0,t)}if(this._target instanceof Array){let t=0;for(const b of this._target)this._preparePath(b,t),this._getOriginalValues(t),t++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const P=b.getEvents();if(P&&P.length>0)for(const J of P)this._events.push(J._clone());this._enableBlending=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Z=this._animation.targetPropertyPath;if(Z.length>1){let J=t;for(let t=0;t<Z.length-1;t++){const b=Z[t];if(J=J[b],void 0===J)throw new Error(`Invalid property (${b}) in property path (${Z.join(".")})`)}this._targetPath=Z[Z.length-1],this._activeTargets[b]=J}else this._targetPath=Z[0],this._activeTargets[b]=t;if(void 0===this._activeTargets[b][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${Z.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let t=0;for(const b of this._target)void 0!==this._originalValue[t]&&this._setValue(b,this._activeTargets[t],this._originalValue[t],-1,t),t++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let t=0;t<this._events.length;t++)this._events[t].isDone=!1}isStopped(){return this._stopped}dispose(){const t=this._animation.runtimeAnimations.indexOf(this);t>-1&&this._animation.runtimeAnimations.splice(t,1)}setValue(t,b){if(this._targetIsArray)for(let Z=0;Z<this._target.length;Z++){const J=this._target[Z];this._setValue(J,this._activeTargets[Z],t,b,Z)}else this._setValue(this._target,this._directTarget,t,b,0)}_getOriginalValues(){let t,b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Z=this._activeTargets[b];t=Z.getLocalMatrix&&"_matrix"===this._targetPath?Z.getLocalMatrix():Z[this._targetPath],t&&t.clone?this._originalValue[b]=t.clone():this._originalValue[b]=t}_registerTargetForLateAnimationBinding(t,b){const Z=t.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(Z),Z._lateAnimationHolders||(Z._lateAnimationHolders={}),Z._lateAnimationHolders[t.targetPath]||(Z._lateAnimationHolders[t.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:b}),t.isAdditive?(Z._lateAnimationHolders[t.targetPath].additiveAnimations.push(t),Z._lateAnimationHolders[t.targetPath].totalAdditiveWeight+=t.weight):(Z._lateAnimationHolders[t.targetPath].animations.push(t),Z._lateAnimationHolders[t.targetPath].totalWeight+=t.weight)}_setValue(t,b,Z,S,P){if(this._currentActiveTarget=b,this._weight=S,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const t=b[this._targetPath];t.clone?this._originalBlendValue=t.clone():this._originalBlendValue=t}this._originalBlendValue.m?J.d.AllowMatrixDecomposeForInterpolation?this._currentValue?C.Matrix.DecomposeLerpToRef(this._originalBlendValue,Z,this._blendingFactor,this._currentValue):this._currentValue=C.Matrix.DecomposeLerp(this._originalBlendValue,Z,this._blendingFactor):this._currentValue?C.Matrix.LerpToRef(this._originalBlendValue,Z,this._blendingFactor,this._currentValue):this._currentValue=C.Matrix.Lerp(this._originalBlendValue,Z,this._blendingFactor):this._currentValue=J.d._UniversalLerp(this._originalBlendValue,Z,this._blendingFactor);const S=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=S}else this._currentValue?this._currentValue.S?this._currentValue.S(Z):this._currentValue=Z:null!==Z&&void 0!==Z&&Z.clone?this._currentValue=Z.clone():this._currentValue=Z;-1!==S?this._registerTargetForLateAnimationBinding(this,this._originalValue[P]):this._animationState.loopMode===J.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[P],b[this._targetPath]):b[this._targetPath]=this._originalValue[P]+this._currentValue:b[this._targetPath]=this._currentValue,t.og&&t.og(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const Z=this._animation.getKeys();t<Z[0].frame?t=Z[0].frame:t>Z[Z.length-1].frame&&(t=Z[Z.length-1].frame);const J=this._events;if(J.length)for(let P=0;P<J.length;P++)J[P].onlyOnce||(J[P].isDone=J[P].frame<t);this._currentFrame=t;const S=this._animation._interpolate(t,this._animationState);this.setValue(S,b)}_prepareForSpeedRatioChange(t){const b=this._previousElapsedTime*(this._animation.framePerSecond*t)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-b}animate(t,b,Z,S,P){let v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const h=this._animation,C=h.targetPropertyPath;if(!C||C.length<1)return this._stopped=!0,!1;let Y,g=!0;const I=this._events;let r=0;if(this._coreRuntimeAnimation)r=Z-b,Y=this._coreRuntimeAnimation.currentFrame,this._currentFrame=Y,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let v;(b<this._minFrame||b>this._maxFrame)&&(b=this._minFrame),(Z<this._minFrame||Z>this._maxFrame)&&(Z=this._maxFrame),r=Z-b;let C=t*(h.framePerSecond*P)/1e3+this._absoluteFrameOffset,M=0,T=!1;const a=S&&this._animationState.loopMode===J.d.ANIMATIONLOOPMODE_YOYO;if(a){const t=(C-b)/r,Z=Math.sin(t*Math.PI);C=Math.abs(Z)*r+b;const J=Z>=0?1:-1;this._yoyoDirection!==J&&(T=!0),this._yoyoDirection=J}if(this._previousElapsedTime=t,this._previousAbsoluteFrame=C,!S&&Z>=b&&(C>=r&&P>0||C<=0&&P<0))g=!1,M=h._getKeyValue(this._maxValue);else if(!S&&b>=Z&&(C<=r&&P<0||C>=0&&P>0))g=!1,M=h._getKeyValue(this._minValue);else if(this._animationState.loopMode!==J.d.ANIMATIONLOOPMODE_CYCLE){const t=Z.toString()+b.toString();if(!this._offsetsCache[t]){this._animationState.repeatCount=0,this._animationState.loopMode=J.d.ANIMATIONLOOPMODE_CYCLE;const S=h._interpolate(b,this._animationState),P=h._interpolate(Z,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),h.dataType){case J.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[t]=P-S;break;case J.d.ANIMATIONTYPE_QUATERNION:case J.d.ANIMATIONTYPE_VECTOR3:case J.d.ANIMATIONTYPE_VECTOR2:case J.d.ANIMATIONTYPE_SIZE:case J.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[t]=P.SZ(S)}this._highLimitsCache[t]=P}M=this._highLimitsCache[t],v=this._offsetsCache[t]}if(void 0===v)switch(h.dataType){case J.d.ANIMATIONTYPE_FLOAT:v=0;break;case J.d.ANIMATIONTYPE_QUATERNION:v=J.l;break;case J.d.ANIMATIONTYPE_VECTOR3:v=J.t;break;case J.d.ANIMATIONTYPE_VECTOR2:v=J.q;break;case J.d.ANIMATIONTYPE_SIZE:v=J.o;break;case J.d.ANIMATIONTYPE_COLOR3:v=J.g;break;case J.d.ANIMATIONTYPE_COLOR4:v=J.j}if(this._host&&this._host.syncRoot){const t=this._host.syncRoot;Y=b+r*((t.masterFrame-t.fromFrame)/(t.toFrame-t.fromFrame))}else Y=C>0&&b>Z||C<0&&b<Z?g&&0!==r?Z+C%r:b:g&&0!==r?b+C%r:Z;if(!a&&(P>0&&this.currentFrame>Y||P<0&&this.currentFrame<Y)||a&&T){this._onLoop();for(let t=0;t<I.length;t++)I[t].onlyOnce||(I[t].isDone=!1);this._animationState.key=P>0?0:h.getKeys().length-1}this._currentFrame=Y,this._animationState.repeatCount=0===r?0:C/r|0,this._animationState.highLimitValue=M,this._animationState.offsetValue=v}const M=h._interpolate(Y,this._animationState);if(this.setValue(M,v),I.length)for(let J=0;J<I.length;J++)if(r>=0&&Y>=I[J].frame&&I[J].frame>=b||r<0&&Y<=I[J].frame&&I[J].frame<=b){const t=I[J];t.isDone||(t.onlyOnce&&(I.splice(J,1),J--),t.isDone=!0,t.action(Y))}return g||(this._stopped=!0),g}}var g=Z(12570);class I{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(t){this._weight=-1!==t?Math.min(Math.max(t,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(t){for(let b=0;b<this._runtimeAnimations.length;b++){this._runtimeAnimations[b]._prepareForSpeedRatioChange(t)}this._speedRatio=t,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(t,b){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,P=arguments.length>4&&void 0!==arguments[4]&&arguments[4],v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,h=arguments.length>6?arguments[6]:void 0,C=arguments.length>7?arguments[7]:void 0,Y=arguments.length>8?arguments[8]:void 0,g=arguments.length>9&&void 0!==arguments[9]&&arguments[9],I=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=b,this.fromFrame=Z,this.toFrame=J,this.loopAnimation=P,this.onAnimationEnd=h,this.onAnimationLoop=Y,this.isAdditive=g,this.playOrder=I,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.ZC=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new S.d,this.onAnimationLoopObservable=new S.d,this._scene=t,C&&this.appendAnimations(b,C),this._speedRatio=v,t._activeAnimatables.push(this)}syncWith(t){if(this._syncRoot=t,t){const t=this._scene._activeAnimatables.indexOf(this);t>-1&&(this._scene._activeAnimatables.splice(t,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(t,b){for(let Z=0;Z<b.length;Z++){const J=b[Z],S=new Y(t,J,this._scene,this);S._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(S)}}getAnimationByTargetProperty(t){const b=this._runtimeAnimations;for(let Z=0;Z<b.length;Z++)if(b[Z].animation.targetProperty===t)return b[Z].animation;return null}getRuntimeAnimationByTargetProperty(t){const b=this._runtimeAnimations;for(let Z=0;Z<b.length;Z++)if(b[Z].animation.targetProperty===t)return b[Z];return null}reset(){const t=this._runtimeAnimations;for(let b=0;b<t.length;b++)t[b].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(t){const b=this._runtimeAnimations;for(let Z=0;Z<b.length;Z++)b[Z].animation.enableBlending=!0,b[Z].animation.blendingSpeed=t}disableBlending(){const t=this._runtimeAnimations;for(let b=0;b<t.length;b++)t[b].animation.enableBlending=!1}goToFrame(t){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Z=this._runtimeAnimations;if(Z[0]){const b=Z[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??Z[0].currentFrame;const J=0===this.speedRatio?0:(t-this._frameToSyncFromJump)/b*1e3/this.speedRatio;this._manualJumpDelay=-J}for(let J=0;J<Z.length;J++)Z[J].goToFrame(t,b?this._weight:-1);this._goToFrame=t}get paused(){return this.ZC}pause(){this.ZC||(this.ZC=!0)}restart(){this.ZC=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(t,b){let Z=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t||b){const S=this._scene._activeAnimatables.indexOf(this);if(S>-1){const P=this._runtimeAnimations;for(let Z=P.length-1;Z>=0;Z--){const J=P[Z];t&&J.animation.name!=t||(b&&!b(J.target)||(J.dispose(),P.splice(Z,1)))}0==P.length&&(Z||this._scene._activeAnimatables.splice(S,1),J||this._raiseOnAnimationEnd())}}else{const t=this._scene._activeAnimatables.indexOf(this);if(t>-1){Z||this._scene._activeAnimatables.splice(t,1);const b=this._runtimeAnimations;for(let t=0;t<b.length;t++)b[t].dispose();this._runtimeAnimations.length=0,J||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((t=>{this.onAnimationEndObservable.add((()=>{t(this)}),void 0,void 0,this,!0)}))}_animate(t){if(this.ZC)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=t),!0;if(null===this._localDelayOffset?(this._localDelayOffset=t,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=t-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let b=!1;const Z=this._runtimeAnimations;let J;for(J=0;J<Z.length;J++){const S=Z[J].animate(t-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);b=b||S}if(this.animationStarted=b,!b){if(this.disposeOnEnd)for(J=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(J,1),J=0;J<Z.length;J++)Z[J].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return b}}function r(t){if(0===t.totalWeight&&0===t.totalAdditiveWeight)return t.originalValue;let b=1;const Z=C.TmpVectors.JZ[0],J=C.TmpVectors.JZ[1],S=C.TmpVectors.Quaternion[0];let P=0;const v=t.animations[0],h=t.originalValue;let Y=1,g=!1;if(t.totalWeight<1)Y=1-t.totalWeight,h.decompose(J,S,Z);else{if(P=1,b=t.totalWeight,Y=v.weight/b,1==Y){if(!t.totalAdditiveWeight)return v.currentValue;g=!0}v.currentValue.decompose(J,S,Z)}if(!g){J.scaleInPlace(Y),Z.scaleInPlace(Y),S.scaleInPlace(Y);for(let v=P;v<t.animations.length;v++){const P=t.animations[v];if(0===P.weight)continue;Y=P.weight/b;const h=C.TmpVectors.JZ[2],g=C.TmpVectors.JZ[3],I=C.TmpVectors.Quaternion[1];P.currentValue.decompose(g,I,h),g.scaleAndAddToRef(Y,J),I.scaleAndAddToRef(C.Quaternion.Dot(S,I)>0?Y:-Y,S),h.scaleAndAddToRef(Y,Z)}S.normalize()}for(let r=0;r<t.additiveAnimations.length;r++){const b=t.additiveAnimations[r];if(0===b.weight)continue;const P=C.TmpVectors.JZ[2],v=C.TmpVectors.JZ[3],h=C.TmpVectors.Quaternion[1];b.currentValue.decompose(v,h,P),v.multiplyToRef(J,v),C.JZ.LerpToRef(J,v,b.weight,J),S.multiplyToRef(h,h),C.Quaternion.SlerpToRef(S,h,b.weight,S),P.scaleAndAddToRef(b.weight,Z)}const I=v?v._animationState.workValue:C.TmpVectors.Matrix[0].clone();return C.Matrix.ComposeToRef(J,S,Z,I),I}function M(t,b){if(0===t.totalWeight&&0===t.totalAdditiveWeight)return b;const Z=t.animations[0],J=t.originalValue;let S=b;if(0===t.totalWeight&&t.totalAdditiveWeight>0)S.S(J);else if(1===t.animations.length){if(C.Quaternion.SlerpToRef(J,Z.currentValue,Math.min(1,t.totalWeight),S),0===t.totalAdditiveWeight)return S}else if(t.animations.length>1){let Z,P,v=1;if(t.totalWeight<1){const b=1-t.totalWeight;Z=[],P=[],Z.push(J),P.push(b)}else{if(2===t.animations.length&&(C.Quaternion.SlerpToRef(t.animations[0].currentValue,t.animations[1].currentValue,t.animations[1].weight/t.totalWeight,b),0===t.totalAdditiveWeight))return b;Z=[],P=[],v=t.totalWeight}for(let b=0;b<t.animations.length;b++){const J=t.animations[b];Z.push(J.currentValue),P.push(J.weight/v)}let h=0;for(let t=0;t<Z.length;)t?(h+=P[t],C.Quaternion.SlerpToRef(S,Z[t],P[t]/h,S),t++):(C.Quaternion.SlerpToRef(Z[t],Z[t+1],P[t+1]/(P[t]+P[t+1]),b),S=b,h=P[t]+P[t+1],t+=2)}for(let P=0;P<t.additiveAnimations.length;P++){const b=t.additiveAnimations[P];0!==b.weight&&(S.multiplyToRef(b.currentValue,C.TmpVectors.Quaternion[0]),C.Quaternion.SlerpToRef(S,C.TmpVectors.Quaternion[0],b.weight,S))}return S}var T,a,k=Z(12975);T=k.d,(a=h.c)&&(a.prototype.copyAnimationRange=function(t,b,Z){let S=arguments.length>3&&void 0!==arguments[3]&&arguments[3],P=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new J.d(this.name,"_matrix",t.animations[0].framePerSecond,J.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const v=t.animations[0].getRange(b);if(!v)return!1;const h=v.from,C=v.to,Y=t.animations[0].getKeys(),g=t.length,I=t.getParent(),r=this.getParent(),M=S&&I&&g&&this.length&&g!==this.length,T=M&&r&&I?r.length/I.length:1,a=S&&!r&&P&&(1!==P.x||1!==P.y||1!==P.z),k=this.animations[0].getKeys();let u,l,U;for(let J=0,E=Y.length;J<E;J++)u=Y[J],u.frame>=h&&u.frame<=C&&(S?(U=u.value.clone(),M?(l=U.getTranslation(),U.setTranslation(l.scaleInPlace(T))):a&&P?(l=U.getTranslation(),U.setTranslation(l.multiplyInPlace(P))):U=u.value):U=u.value,k.push({frame:u.frame+Z,value:U}));return this.animations[0].createRange(b,h+Z,C+Z),!0}),T&&(T.prototype._animate=function(t){if(!this.animationsEnabled)return;const b=g.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=b}this.deltaTime=void 0!==t?t:this.useConstantAnimationDeltaTime?16:(b-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=b;const Z=this._activeAnimatables;if(0===Z.length)return;this._animationTime+=this.deltaTime;const S=this._animationTime;for(let J=0;J<Z.length;J++){const t=Z[J];!t._animate(S)&&t.disposeOnEnd&&J--}!function(t){if(t._registeredForLateAnimationBindings.length){for(let b=0;b<t._registeredForLateAnimationBindings.length;b++){const Z=t._registeredForLateAnimationBindings.data[b];for(const t in Z._lateAnimationHolders){const b=Z._lateAnimationHolders[t],S=b.animations[0],P=b.originalValue;if(void 0===P||null===P)continue;const v=J.d.AllowMatrixDecomposeForInterpolation&&P.m;let h=Z[t];if(v)h=r(b);else if(void 0!==P.w)h=M(b,h||C.Quaternion.Identity());else{let t=0,Z=1;const v=S&&S._animationState.loopMode===J.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(b.totalWeight<1)h=v?P.clone?P.clone():P:S&&P.scale?P.scale(1-b.totalWeight):S?P*(1-b.totalWeight):P.clone?P.clone():P;else if(S){Z=b.totalWeight;const J=S.weight/Z;h=1!==J?S.currentValue.scale?S.currentValue.scale(J):S.currentValue*J:S.currentValue,v&&(h.addToRef?h.addToRef(P,h):h+=P),t=1}for(let J=t;J<b.animations.length;J++){const t=b.animations[J],S=t.weight/Z;S&&(t.currentValue.scaleAndAddToRef?t.currentValue.scaleAndAddToRef(S,h):h+=t.currentValue*S)}for(let J=0;J<b.additiveAnimations.length;J++){const t=b.additiveAnimations[J],Z=t.weight;Z&&(t.currentValue.scaleAndAddToRef?t.currentValue.scaleAndAddToRef(Z,h):h+=t.currentValue*Z)}}Z[t]=h}Z._lateAnimationHolders={}}t._registeredForLateAnimationBindings.reset()}}(this)},T.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((t,b)=>t.playOrder-b.playOrder))},T.prototype.beginWeightedAnimation=function(t,b,Z){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,S=arguments.length>4?arguments[4]:void 0,P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,v=arguments.length>6?arguments[6]:void 0,h=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,Y=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const I=this.beginAnimation(t,b,Z,S,P,v,h,!1,C,Y,g);return I.weight=J,I},T.prototype.beginAnimation=function(t,b,Z,J){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,P=arguments.length>5?arguments[5]:void 0,v=arguments.length>6?arguments[6]:void 0,h=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],C=arguments.length>8?arguments[8]:void 0,Y=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(S<0){const t=b;b=Z,Z=t,S=-S}b>Z&&(S=-S),h&&this.stopAnimation(t,void 0,C),v||(v=new I(this,t,b,Z,J,S,P,void 0,Y,g));const r=!C||C(t);if(t.animations&&r&&v.appendAnimations(t,t.animations),t.getAnimatables){const g=t.getAnimatables();for(let t=0;t<g.length;t++)this.beginAnimation(g[t],b,Z,J,S,P,v,h,C,Y)}return v.reset(),v},T.prototype.beginHierarchyAnimation=function(t,b,Z,J,S){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,v=arguments.length>6?arguments[6]:void 0,h=arguments.length>7?arguments[7]:void 0,C=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],Y=arguments.length>9?arguments[9]:void 0,g=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const I=t.getDescendants(b),r=[];r.push(this.beginAnimation(t,Z,J,S,P,v,h,C,Y,void 0,g));for(const M of I)r.push(this.beginAnimation(M,Z,J,S,P,v,h,C,Y,void 0,g));return r},T.prototype.beginDirectAnimation=function(t,b,Z,J,S){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(P<0){const t=Z;Z=J,J=t,P=-P}return Z>J&&(P=-P),new I(this,t,Z,J,S,P,arguments.length>6?arguments[6]:void 0,b,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},T.prototype.beginDirectHierarchyAnimation=function(t,b,Z,J,S,P,v,h,C){let Y=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const g=t.getDescendants(b),I=[];I.push(this.beginDirectAnimation(t,Z,J,S,P,v,h,C,Y));for(const r of g)I.push(this.beginDirectAnimation(r,Z,J,S,P,v,h,C,Y));return I},T.prototype.getAnimatableByTarget=function(t){for(let b=0;b<this._activeAnimatables.length;b++)if(this._activeAnimatables[b].target===t)return this._activeAnimatables[b];return null},T.prototype.getAllAnimatablesByTarget=function(t){const b=[];for(let Z=0;Z<this._activeAnimatables.length;Z++)this._activeAnimatables[Z].target===t&&b.push(this._activeAnimatables[Z]);return b},T.prototype.stopAnimation=function(t,b,Z){const J=this.getAllAnimatablesByTarget(t);for(const S of J)S.stop(b,Z)},T.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let t=0;t<this._activeAnimatables.length;t++)this._activeAnimatables[t].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const t of this.animationGroups)t.stop()});class u{getClassName(){return"TargetedAnimation"}serialize(){const t={};return t.animation=this.animation.serialize(),t.targetId=this.target.id,t}}class l{get mask(){return this._mask}set mask(t){this._mask!==t&&(this._mask=t,this.syncWithMask(!0))}syncWithMask(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||t){this._numActiveAnimatables=0;for(let t=0;t<this._animatables.length;++t){const b=this._animatables[t];!this.mask||this.mask.disabled||this.mask.retainsTarget(b.target.name)?(this._numActiveAnimatables++,b.paused&&b.restart()):b.paused||b.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let t=0;t<this._animatables.length;++t){const b=this._animatables[t];this.mask.retainsTarget(b.target.name)||(b.stop(),this._animatables.splice(t,1),--t)}for(let t=0;t<this._targetedAnimations.length;t++){const b=this._targetedAnimations[t];this.mask.retainsTarget(b.target.name)||(this._targetedAnimations.splice(t,1),--t)}}}get from(){return this._from}set from(t){if(this._from!==t){this._from=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].fromFrame=this._from}}}get to(){return this._to}set to(t){if(this._to!==t){this._to=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(t){if(this._speedRatio!==t){this._speedRatio=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(t){if(this._loopAnimation!==t){this._loopAnimation=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(t){if(this._isAdditive!==t){this._isAdditive=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(t){this._weight!==t&&(this._weight=t,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(t){if(this._playOrder!==t&&(this._playOrder=t,this._animatables.length>0)){for(let t=0;t<this._animatables.length;t++)this._animatables[t].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(t){if(this._enableBlending!==t&&(this._enableBlending=t,null!==t))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.enableBlending=t}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(t){if(this._blendingSpeed!==t&&(this._blendingSpeed=t,null!==t))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.blendingSpeed=t}getLength(t,b){t=t??this._from;return((b=b??this._to)-t)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(t){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Z=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=arguments.length>3?arguments[3]:void 0;if(0===t.length)return null;J=J??t[0].weight;let S=Number.MAX_VALUE,P=-Number.MAX_VALUE;if(Z)for(const h of t)h.from<S&&(S=h.from),h.to>P&&(P=h.to);const v=new l(t[0].name+"_merged",t[0]._scene,J);for(const h of t){Z&&h.normalize(S,P);for(const t of h.targetedAnimations)v.addTargetedAnimation(t.animation,t.target);b&&h.dispose()}return v}constructor(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=t,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new S.d,this.onAnimationLoopObservable=new S.d,this.onAnimationGroupLoopObservable=new S.d,this.onAnimationGroupEndObservable=new S.d,this.onAnimationGroupPauseObservable=new S.d,this.onAnimationGroupPlayObservable=new S.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=b||P.e.LastCreatedScene,this._weight=Z,this._playOrder=J,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(t,b){const Z=new u;Z.animation=t,Z.target=b;const J=t.getKeys();return this._from>J[0].frame&&(this._from=J[0].frame),this._to<J[J.length-1].frame&&(this._to=J[J.length-1].frame),null!==this._enableBlending&&(t.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(t.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(Z),this._shouldStart=!0,Z}removeTargetedAnimation(t){for(let b=this._targetedAnimations.length-1;b>-1;b--){this._targetedAnimations[b].animation===t&&this._targetedAnimations.splice(b,1)}}normalize(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==t&&(t=this._from),null==b&&(b=this._to);for(let Z=0;Z<this._targetedAnimations.length;Z++){const J=this._targetedAnimations[Z].animation.getKeys(),S=J[0],P=J[J.length-1];if(S.frame>t){const b={frame:t,value:S.value,inTangent:S.inTangent,outTangent:S.outTangent,interpolation:S.interpolation};J.splice(0,0,b)}if(P.frame<b){const t={frame:b,value:P.value,inTangent:P.inTangent,outTangent:P.outTangent,interpolation:P.interpolation};J.push(t)}}return this._from=t,this._to=b,this}_processLoop(t,b,Z){t.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(b),this._animationLoopFlags[Z]||(this._animationLoopFlags[Z]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Z=arguments.length>2?arguments[2]:void 0,J=arguments.length>3?arguments[3]:void 0,S=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=t,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let P=0;P<this._targetedAnimations.length;P++){const v=this._targetedAnimations[P],h=this._scene.beginDirectAnimation(v.target,[v.animation],void 0!==Z?Z:this._from,void 0!==J?J:this._to,t,b,void 0,void 0,void 0!==S?S:this._isAdditive);h.weight=this._weight,h.playOrder=this._playOrder,h.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(v),this._checkAnimationGroupEnded(h)},this._processLoop(h,v,P),this._animatables.push(h)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=b,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let t=0;t<this._animatables.length;t++){this._animatables[t].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(t){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==t&&(this.loopAnimation=t),this.restart()):(this.stop(),this.start(t,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].reset()}return this}restart(){if(!this._isStarted)return this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const b=this._animatables.slice();for(let J=0;J<b.length;J++)b[J].stop(void 0,void 0,!0,t);let Z=0;for(let J=0;J<this._scene._activeAnimatables.length;J++){const b=this._scene._activeAnimatables[J];b._runtimeAnimations.length>0?this._scene._activeAnimatables[Z++]=b:t&&this._checkAnimationGroupEnded(b,t)}return this._scene._activeAnimatables.length=Z,this._isStarted=!1,this}setWeightForAllAnimatables(t){for(let b=0;b<this._animatables.length;b++){this._animatables[b].weight=t}return this}syncAllAnimationsWith(t){for(let b=0;b<this._animatables.length;b++){this._animatables[b].syncWith(t)}return this}goToFrame(t){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].goToFrame(t,b)}return this}getCurrentFrame(){var t;return(null===(t=this.animatables[0])||void 0===t?void 0:t.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const t=this._scene.animationGroups.indexOf(this);if(t>-1&&this._scene.animationGroups.splice(t,1),this._parentContainer){const t=this._parentContainer.animationGroups.indexOf(this);t>-1&&this._parentContainer.animationGroups.splice(t,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(t){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Z=this._animatables.indexOf(t);Z>-1&&this._animatables.splice(Z,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,b||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(t,b){let Z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const J=new l(t||this.name,this._scene,this._weight,this._playOrder);J._from=this.from,J._to=this.to,J._speedRatio=this.speedRatio,J._loopAnimation=this.loopAnimation,J._isAdditive=this.isAdditive,J._enableBlending=this.enableBlending,J._blendingSpeed=this.blendingSpeed,J.metadata=this.metadata,J.mask=this.mask;for(const S of this._targetedAnimations)J.addTargetedAnimation(Z?S.animation.clone():S.animation,b?b(S.target):S.target);return J}serialize(){const t={};t.name=this.name,t.from=this.from,t.to=this.to,t.speedRatio=this.speedRatio,t.loopAnimation=this.loopAnimation,t.isAdditive=this.isAdditive,t.weight=this.weight,t.playOrder=this.playOrder,t.enableBlending=this.enableBlending,t.blendingSpeed=this.blendingSpeed,t.targetedAnimations=[];for(let b=0;b<this.targetedAnimations.length;b++){const Z=this.targetedAnimations[b];t.targetedAnimations[b]=Z.serialize()}return v.b&&v.b.HasTags(this)&&(t.tags=v.b.GetTags(this)),this.metadata&&(t.metadata=this.metadata),t}static Parse(t,b){const Z=new l(t.name,b,t.weight,t.playOrder);for(let S=0;S<t.targetedAnimations.length;S++){const P=t.targetedAnimations[S],v=J.d.Parse(P.animation),h=P.targetId;if("influence"===P.animation.property){const t=b.getMorphTargetById(h);t&&Z.addTargetedAnimation(v,t)}else{const t=b.getNodeById(h);null!=t&&Z.addTargetedAnimation(v,t)}}return v.b&&v.b.AddTagsTo(Z,t.tags),null!==t.from&&null!==t.to&&Z.normalize(t.from,t.to),void 0!==t.speedRatio&&(Z._speedRatio=t.speedRatio),void 0!==t.loopAnimation&&(Z._loopAnimation=t.loopAnimation),void 0!==t.isAdditive&&(Z._isAdditive=t.isAdditive),void 0!==t.weight&&(Z._weight=t.weight),void 0!==t.playOrder&&(Z._playOrder=t.playOrder),void 0!==t.enableBlending&&(Z._enableBlending=t.enableBlending),void 0!==t.blendingSpeed&&(Z._blendingSpeed=t.blendingSpeed),void 0!==t.metadata&&(Z.metadata=t.metadata),Z}static MakeAnimationAdditive(t,b,Z){let S;S="object"===typeof b?b:{referenceFrame:b,range:Z,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let P=t;S.cloneOriginalAnimationGroup&&(P=t.clone(S.clonedAnimationGroupName||P.name));const v=P.targetedAnimations;for(let h=0;h<v.length;h++){const t=v[h];t.animation=J.d.MakeAnimationAdditive(t.animation,S)}if(P.isAdditive=!0,S.clipKeys){let t=Number.MAX_VALUE,b=-Number.MAX_VALUE;const Z=P.targetedAnimations;for(let J=0;J<Z.length;J++){const S=Z[J].animation.getKeys();t>S[0].frame&&(t=S[0].frame),b<S[S.length-1].frame&&(b=S[S.length-1].frame)}P._from=t,P._to=b}return P}static ClipKeys(t,b,Z,J,S){const P=t.clone(J||t.name);return l.ClipKeysInPlace(P,b,Z,S)}static ClipKeysInPlace(t,b,Z,J){return l.ClipInPlace(t,b,Z,J,!1)}static ClipFrames(t,b,Z,J,S){const P=t.clone(J||t.name);return l.ClipFramesInPlace(P,b,Z,S)}static ClipFramesInPlace(t,b,Z,J){return l.ClipInPlace(t,b,Z,J,!0)}static ClipInPlace(t,b,Z,J){let S=arguments.length>4&&void 0!==arguments[4]&&arguments[4],P=Number.MAX_VALUE,v=-Number.MAX_VALUE;const h=t.targetedAnimations;for(let C=0;C<h.length;C++){const t=h[C],Y=J?t.animation:t.animation.clone();S&&(Y.createKeyForFrame(b),Y.createKeyForFrame(Z));const g=Y.getKeys(),I=[];let r=Number.MAX_VALUE;for(let J=0;J<g.length;J++){const t=g[J];if(!S&&J>=b&&J<=Z||S&&t.frame>=b&&t.frame<=Z){const b={frame:t.frame,value:t.value.clone?t.value.clone():t.value,inTangent:t.inTangent,outTangent:t.outTangent,interpolation:t.interpolation,lockedTangent:t.lockedTangent};r===Number.MAX_VALUE&&(r=b.frame),b.frame-=r,I.push(b)}}0!==I.length?(P>I[0].frame&&(P=I[0].frame),v<I[I.length-1].frame&&(v=I[I.length-1].frame),Y.setKeys(I,!0),t.animation=Y):(h.splice(C,1),C--)}return t._from=P,t._to=v,t}getClassName(){return"AnimationGroup"}toString(t){let b="Name: "+this.name;return b+=", type: "+this.getClassName(),t&&(b+=", from: "+this._from,b+=", to: "+this._to,b+=", isStarted: "+this._isStarted,b+=", speedRatio: "+this._speedRatio,b+=", targetedAnimations length: "+this._targetedAnimations.length,b+=", animatables length: "+this._animatables),b}}}}]);