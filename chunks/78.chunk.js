"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[78],{14411:(F,b,Q)=>{Q.r(b),Q.d(b,{AnimationGroup:()=>L,TargetedAnimation:()=>X});var C=Q(11812),z=Q(11133),t=Q(11161),g=Q(11352),W=Q(12876),Z=Q(11309);class q{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(F,b,Q,z){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=b,this._target=F,this._scene=Q,this._host=z,this._activeTargets=[],b._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===C.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=Z.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const F={frame:0,value:this._minValue};this._keys.splice(0,0,F)}if(this._target instanceof Array){let F=0;for(const b of this._target)this._preparePath(b,F),this._getOriginalValues(F),F++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const t=b.getEvents();if(t&&t.length>0)for(const C of t)this._events.push(C._clone());this._enableBlending=F&&F.animationPropertiesOverride?F.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Q=this._animation.targetPropertyPath;if(Q.length>1){let C=F;for(let F=0;F<Q.length-1;F++){const b=Q[F];if(C=C[b],void 0===C)throw new Error(`Invalid property (${b}) in property path (${Q.join(".")})`)}this._targetPath=Q[Q.length-1],this._activeTargets[b]=C}else this._targetPath=Q[0],this._activeTargets[b]=F;if(void 0===this._activeTargets[b][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${Q.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let F=0;for(const b of this._target)void 0!==this._originalValue[F]&&this._setValue(b,this._activeTargets[F],this._originalValue[F],-1,F),F++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let F=0;F<this._events.length;F++)this._events[F].isDone=!1}isStopped(){return this._stopped}dispose(){const F=this._animation.runtimeAnimations.indexOf(this);F>-1&&this._animation.runtimeAnimations.splice(F,1)}setValue(F,b){if(this._targetIsArray)for(let Q=0;Q<this._target.length;Q++){const C=this._target[Q];this._setValue(C,this._activeTargets[Q],F,b,Q)}else this._setValue(this._target,this._directTarget,F,b,0)}_getOriginalValues(){let F,b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Q=this._activeTargets[b];F=Q.getLocalMatrix&&"_matrix"===this._targetPath?Q.getLocalMatrix():Q[this._targetPath],F&&F.clone?this._originalValue[b]=F.clone():this._originalValue[b]=F}_registerTargetForLateAnimationBinding(F,b){const Q=F.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(Q),Q._lateAnimationHolders||(Q._lateAnimationHolders={}),Q._lateAnimationHolders[F.targetPath]||(Q._lateAnimationHolders[F.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:b}),F.isAdditive?(Q._lateAnimationHolders[F.targetPath].additiveAnimations.push(F),Q._lateAnimationHolders[F.targetPath].totalAdditiveWeight+=F.weight):(Q._lateAnimationHolders[F.targetPath].animations.push(F),Q._lateAnimationHolders[F.targetPath].totalWeight+=F.weight)}_setValue(F,b,Q,z,t){if(this._currentActiveTarget=b,this._weight=z,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const F=b[this._targetPath];F.clone?this._originalBlendValue=F.clone():this._originalBlendValue=F}this._originalBlendValue.m?C.b.AllowMatrixDecomposeForInterpolation?this._currentValue?Z.Matrix.DecomposeLerpToRef(this._originalBlendValue,Q,this._blendingFactor,this._currentValue):this._currentValue=Z.Matrix.DecomposeLerp(this._originalBlendValue,Q,this._blendingFactor):this._currentValue?Z.Matrix.LerpToRef(this._originalBlendValue,Q,this._blendingFactor,this._currentValue):this._currentValue=Z.Matrix.Lerp(this._originalBlendValue,Q,this._blendingFactor):this._currentValue=C.b._UniversalLerp(this._originalBlendValue,Q,this._blendingFactor);const z=F&&F.animationPropertiesOverride?F.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=z}else this._currentValue?this._currentValue.W?this._currentValue.W(Q):this._currentValue=Q:null!==Q&&void 0!==Q&&Q.clone?this._currentValue=Q.clone():this._currentValue=Q;-1!==z?this._registerTargetForLateAnimationBinding(this,this._originalValue[t]):this._animationState.loopMode===C.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[t],b[this._targetPath]):b[this._targetPath]=this._originalValue[t]+this._currentValue:b[this._targetPath]=this._currentValue,F.EG&&F.EG(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const Q=this._animation.getKeys();F<Q[0].frame?F=Q[0].frame:F>Q[Q.length-1].frame&&(F=Q[Q.length-1].frame);const C=this._events;if(C.length)for(let t=0;t<C.length;t++)C[t].onlyOnce||(C[t].isDone=C[t].frame<F);this._currentFrame=F;const z=this._animation._interpolate(F,this._animationState);this.setValue(z,b)}_prepareForSpeedRatioChange(F){const b=this._previousElapsedTime*(this._animation.framePerSecond*F)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-b}animate(F,b,Q,z,t){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const W=this._animation,Z=W.targetPropertyPath;if(!Z||Z.length<1)return this._stopped=!0,!1;let q,G=!0;const K=this._events;let e=0;if(this._coreRuntimeAnimation)e=Q-b,q=this._coreRuntimeAnimation.currentFrame,this._currentFrame=q,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let g;(b<this._minFrame||b>this._maxFrame)&&(b=this._minFrame),(Q<this._minFrame||Q>this._maxFrame)&&(Q=this._maxFrame),e=Q-b;let Z=F*(W.framePerSecond*t)/1e3+this._absoluteFrameOffset,N=0,y=!1;const E=z&&this._animationState.loopMode===C.b.ANIMATIONLOOPMODE_YOYO;if(E){const F=(Z-b)/e,Q=Math.sin(F*Math.PI);Z=Math.abs(Q)*e+b;const C=Q>=0?1:-1;this._yoyoDirection!==C&&(y=!0),this._yoyoDirection=C}if(this._previousElapsedTime=F,this._previousAbsoluteFrame=Z,!z&&Q>=b&&(Z>=e&&t>0||Z<=0&&t<0))G=!1,N=W._getKeyValue(this._maxValue);else if(!z&&b>=Q&&(Z<=e&&t<0||Z>=0&&t>0))G=!1,N=W._getKeyValue(this._minValue);else if(this._animationState.loopMode!==C.b.ANIMATIONLOOPMODE_CYCLE){const F=Q.toString()+b.toString();if(!this._offsetsCache[F]){this._animationState.repeatCount=0,this._animationState.loopMode=C.b.ANIMATIONLOOPMODE_CYCLE;const z=W._interpolate(b,this._animationState),t=W._interpolate(Q,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),W.dataType){case C.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[F]=t-z;break;case C.b.ANIMATIONTYPE_QUATERNION:case C.b.ANIMATIONTYPE_VECTOR3:case C.b.ANIMATIONTYPE_VECTOR2:case C.b.ANIMATIONTYPE_SIZE:case C.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[F]=t.WQ(z)}this._highLimitsCache[F]=t}N=this._highLimitsCache[F],g=this._offsetsCache[F]}if(void 0===g)switch(W.dataType){case C.b.ANIMATIONTYPE_FLOAT:g=0;break;case C.b.ANIMATIONTYPE_QUATERNION:g=C.f;break;case C.b.ANIMATIONTYPE_VECTOR3:g=C.q;break;case C.b.ANIMATIONTYPE_VECTOR2:g=C.m;break;case C.b.ANIMATIONTYPE_SIZE:g=C.j;break;case C.b.ANIMATIONTYPE_COLOR3:g=C.c;break;case C.b.ANIMATIONTYPE_COLOR4:g=C.e}if(this._host&&this._host.syncRoot){const F=this._host.syncRoot;q=b+e*((F.masterFrame-F.fromFrame)/(F.toFrame-F.fromFrame))}else q=Z>0&&b>Q||Z<0&&b<Q?G&&0!==e?Q+Z%e:b:G&&0!==e?b+Z%e:Q;if(!E&&(t>0&&this.currentFrame>q||t<0&&this.currentFrame<q)||E&&y){this._onLoop();for(let F=0;F<K.length;F++)K[F].onlyOnce||(K[F].isDone=!1);this._animationState.key=t>0?0:W.getKeys().length-1}this._currentFrame=q,this._animationState.repeatCount=0===e?0:Z/e|0,this._animationState.highLimitValue=N,this._animationState.offsetValue=g}const N=W._interpolate(q,this._animationState);if(this.setValue(N,g),K.length)for(let C=0;C<K.length;C++)if(e>=0&&q>=K[C].frame&&K[C].frame>=b||e<0&&q<=K[C].frame&&K[C].frame<=b){const F=K[C];F.isDone||(F.onlyOnce&&(K.splice(C,1),C--),F.isDone=!0,F.action(q))}return G||(this._stopped=!0),G}}var G=Q(11153);class K{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(F){this._weight=-1!==F?Math.min(Math.max(F,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(F){for(let b=0;b<this._runtimeAnimations.length;b++){this._runtimeAnimations[b]._prepareForSpeedRatioChange(F)}this._speedRatio=F,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(F,b){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,t=arguments.length>4&&void 0!==arguments[4]&&arguments[4],g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,W=arguments.length>6?arguments[6]:void 0,Z=arguments.length>7?arguments[7]:void 0,q=arguments.length>8?arguments[8]:void 0,G=arguments.length>9&&void 0!==arguments[9]&&arguments[9],K=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=b,this.fromFrame=Q,this.toFrame=C,this.loopAnimation=t,this.onAnimationEnd=W,this.onAnimationLoop=q,this.isAdditive=G,this.playOrder=K,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.qZ=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new z.c,this.onAnimationLoopObservable=new z.c,this._scene=F,Z&&this.appendAnimations(b,Z),this._speedRatio=g,F._activeAnimatables.push(this)}syncWith(F){if(this._syncRoot=F,F){const F=this._scene._activeAnimatables.indexOf(this);F>-1&&(this._scene._activeAnimatables.splice(F,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(F,b){for(let Q=0;Q<b.length;Q++){const C=b[Q],z=new q(F,C,this._scene,this);z._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(z)}}getAnimationByTargetProperty(F){const b=this._runtimeAnimations;for(let Q=0;Q<b.length;Q++)if(b[Q].animation.targetProperty===F)return b[Q].animation;return null}getRuntimeAnimationByTargetProperty(F){const b=this._runtimeAnimations;for(let Q=0;Q<b.length;Q++)if(b[Q].animation.targetProperty===F)return b[Q];return null}reset(){const F=this._runtimeAnimations;for(let b=0;b<F.length;b++)F[b].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(F){const b=this._runtimeAnimations;for(let Q=0;Q<b.length;Q++)b[Q].animation.enableBlending=!0,b[Q].animation.blendingSpeed=F}disableBlending(){const F=this._runtimeAnimations;for(let b=0;b<F.length;b++)F[b].animation.enableBlending=!1}goToFrame(F){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Q=this._runtimeAnimations;if(Q[0]){const b=Q[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??Q[0].currentFrame;const C=0===this.speedRatio?0:(F-this._frameToSyncFromJump)/b*1e3/this.speedRatio;this._manualJumpDelay=-C}for(let C=0;C<Q.length;C++)Q[C].goToFrame(F,b?this._weight:-1);this._goToFrame=F}get paused(){return this.qZ}pause(){this.qZ||(this.qZ=!0)}restart(){this.qZ=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(F,b){let Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(F||b){const z=this._scene._activeAnimatables.indexOf(this);if(z>-1){const t=this._runtimeAnimations;for(let Q=t.length-1;Q>=0;Q--){const C=t[Q];F&&C.animation.name!=F||(b&&!b(C.target)||(C.dispose(),t.splice(Q,1)))}0==t.length&&(Q||this._scene._activeAnimatables.splice(z,1),C||this._raiseOnAnimationEnd())}}else{const F=this._scene._activeAnimatables.indexOf(this);if(F>-1){Q||this._scene._activeAnimatables.splice(F,1);const b=this._runtimeAnimations;for(let F=0;F<b.length;F++)b[F].dispose();this._runtimeAnimations.length=0,C||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((F=>{this.onAnimationEndObservable.add((()=>{F(this)}),void 0,void 0,this,!0)}))}_animate(F){if(this.qZ)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=F),!0;if(null===this._localDelayOffset?(this._localDelayOffset=F,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=F-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let b=!1;const Q=this._runtimeAnimations;let C;for(C=0;C<Q.length;C++){const z=Q[C].animate(F-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);b=b||z}if(this.animationStarted=b,!b){if(this.disposeOnEnd)for(C=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(C,1),C=0;C<Q.length;C++)Q[C].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return b}}function e(F){if(0===F.totalWeight&&0===F.totalAdditiveWeight)return F.originalValue;let b=1;const Q=Z.TmpVectors.gQ[0],C=Z.TmpVectors.gQ[1],z=Z.TmpVectors.Quaternion[0];let t=0;const g=F.animations[0],W=F.originalValue;let q=1,G=!1;if(F.totalWeight<1)q=1-F.totalWeight,W.decompose(C,z,Q);else{if(t=1,b=F.totalWeight,q=g.weight/b,1==q){if(!F.totalAdditiveWeight)return g.currentValue;G=!0}g.currentValue.decompose(C,z,Q)}if(!G){C.scaleInPlace(q),Q.scaleInPlace(q),z.scaleInPlace(q);for(let g=t;g<F.animations.length;g++){const t=F.animations[g];if(0===t.weight)continue;q=t.weight/b;const W=Z.TmpVectors.gQ[2],G=Z.TmpVectors.gQ[3],K=Z.TmpVectors.Quaternion[1];t.currentValue.decompose(G,K,W),G.scaleAndAddToRef(q,C),K.scaleAndAddToRef(Z.Quaternion.Dot(z,K)>0?q:-q,z),W.scaleAndAddToRef(q,Q)}z.normalize()}for(let e=0;e<F.additiveAnimations.length;e++){const b=F.additiveAnimations[e];if(0===b.weight)continue;const t=Z.TmpVectors.gQ[2],g=Z.TmpVectors.gQ[3],W=Z.TmpVectors.Quaternion[1];b.currentValue.decompose(g,W,t),g.multiplyToRef(C,g),Z.gQ.LerpToRef(C,g,b.weight,C),z.multiplyToRef(W,W),Z.Quaternion.SlerpToRef(z,W,b.weight,z),t.scaleAndAddToRef(b.weight,Q)}const K=g?g._animationState.workValue:Z.TmpVectors.Matrix[0].clone();return Z.Matrix.ComposeToRef(C,z,Q,K),K}function N(F,b){if(0===F.totalWeight&&0===F.totalAdditiveWeight)return b;const Q=F.animations[0],C=F.originalValue;let z=b;if(0===F.totalWeight&&F.totalAdditiveWeight>0)z.W(C);else if(1===F.animations.length){if(Z.Quaternion.SlerpToRef(C,Q.currentValue,Math.min(1,F.totalWeight),z),0===F.totalAdditiveWeight)return z}else if(F.animations.length>1){let Q,t,g=1;if(F.totalWeight<1){const b=1-F.totalWeight;Q=[],t=[],Q.push(C),t.push(b)}else{if(2===F.animations.length&&(Z.Quaternion.SlerpToRef(F.animations[0].currentValue,F.animations[1].currentValue,F.animations[1].weight/F.totalWeight,b),0===F.totalAdditiveWeight))return b;Q=[],t=[],g=F.totalWeight}for(let b=0;b<F.animations.length;b++){const C=F.animations[b];Q.push(C.currentValue),t.push(C.weight/g)}let W=0;for(let F=0;F<Q.length;)F?(W+=t[F],Z.Quaternion.SlerpToRef(z,Q[F],t[F]/W,z),F++):(Z.Quaternion.SlerpToRef(Q[F],Q[F+1],t[F+1]/(t[F]+t[F+1]),b),z=b,W=t[F]+t[F+1],F+=2)}for(let t=0;t<F.additiveAnimations.length;t++){const b=F.additiveAnimations[t];0!==b.weight&&(z.multiplyToRef(b.currentValue,Z.TmpVectors.Quaternion[0]),Z.Quaternion.SlerpToRef(z,Z.TmpVectors.Quaternion[0],b.weight,z))}return z}var y,E,c=Q(11537);y=c.c,(E=W.b)&&(E.prototype.copyAnimationRange=function(F,b,Q){let z=arguments.length>3&&void 0!==arguments[3]&&arguments[3],t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new C.b(this.name,"_matrix",F.animations[0].framePerSecond,C.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const g=F.animations[0].getRange(b);if(!g)return!1;const W=g.from,Z=g.to,q=F.animations[0].getKeys(),G=F.length,K=F.getParent(),e=this.getParent(),N=z&&K&&G&&this.length&&G!==this.length,y=N&&e&&K?e.length/K.length:1,E=z&&!e&&t&&(1!==t.x||1!==t.y||1!==t.z),c=this.animations[0].getKeys();let X,L,i;for(let C=0,f=q.length;C<f;C++)X=q[C],X.frame>=W&&X.frame<=Z&&(z?(i=X.value.clone(),N?(L=i.getTranslation(),i.setTranslation(L.scaleInPlace(y))):E&&t?(L=i.getTranslation(),i.setTranslation(L.multiplyInPlace(t))):i=X.value):i=X.value,c.push({frame:X.frame+Q,value:i}));return this.animations[0].createRange(b,W+Q,Z+Q),!0}),y&&(y.prototype._animate=function(F){if(!this.animationsEnabled)return;const b=G.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=b}this.deltaTime=void 0!==F?F:this.useConstantAnimationDeltaTime?16:(b-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=b;const Q=this._activeAnimatables;if(0===Q.length)return;this._animationTime+=this.deltaTime;const z=this._animationTime;for(let C=0;C<Q.length;C++){const F=Q[C];!F._animate(z)&&F.disposeOnEnd&&C--}!function(F){if(F._registeredForLateAnimationBindings.length){for(let b=0;b<F._registeredForLateAnimationBindings.length;b++){const Q=F._registeredForLateAnimationBindings.data[b];for(const F in Q._lateAnimationHolders){const b=Q._lateAnimationHolders[F],z=b.animations[0],t=b.originalValue;if(void 0===t||null===t)continue;const g=C.b.AllowMatrixDecomposeForInterpolation&&t.m;let W=Q[F];if(g)W=e(b);else if(void 0!==t.w)W=N(b,W||Z.Quaternion.Identity());else{let F=0,Q=1;const g=z&&z._animationState.loopMode===C.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(b.totalWeight<1)W=g?t.clone?t.clone():t:z&&t.scale?t.scale(1-b.totalWeight):z?t*(1-b.totalWeight):t.clone?t.clone():t;else if(z){Q=b.totalWeight;const C=z.weight/Q;W=1!==C?z.currentValue.scale?z.currentValue.scale(C):z.currentValue*C:z.currentValue,g&&(W.addToRef?W.addToRef(t,W):W+=t),F=1}for(let C=F;C<b.animations.length;C++){const F=b.animations[C],z=F.weight/Q;z&&(F.currentValue.scaleAndAddToRef?F.currentValue.scaleAndAddToRef(z,W):W+=F.currentValue*z)}for(let C=0;C<b.additiveAnimations.length;C++){const F=b.additiveAnimations[C],Q=F.weight;Q&&(F.currentValue.scaleAndAddToRef?F.currentValue.scaleAndAddToRef(Q,W):W+=F.currentValue*Q)}}Q[F]=W}Q._lateAnimationHolders={}}F._registeredForLateAnimationBindings.reset()}}(this)},y.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((F,b)=>F.playOrder-b.playOrder))},y.prototype.beginWeightedAnimation=function(F,b,Q){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,z=arguments.length>4?arguments[4]:void 0,t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,W=arguments.length>7?arguments[7]:void 0,Z=arguments.length>8?arguments[8]:void 0,q=arguments.length>9?arguments[9]:void 0,G=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const K=this.beginAnimation(F,b,Q,z,t,g,W,!1,Z,q,G);return K.weight=C,K},y.prototype.beginAnimation=function(F,b,Q,C){let z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,t=arguments.length>5?arguments[5]:void 0,g=arguments.length>6?arguments[6]:void 0,W=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],Z=arguments.length>8?arguments[8]:void 0,q=arguments.length>9?arguments[9]:void 0,G=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(z<0){const F=b;b=Q,Q=F,z=-z}b>Q&&(z=-z),W&&this.stopAnimation(F,void 0,Z),g||(g=new K(this,F,b,Q,C,z,t,void 0,q,G));const e=!Z||Z(F);if(F.animations&&e&&g.appendAnimations(F,F.animations),F.getAnimatables){const G=F.getAnimatables();for(let F=0;F<G.length;F++)this.beginAnimation(G[F],b,Q,C,z,t,g,W,Z,q)}return g.reset(),g},y.prototype.beginHierarchyAnimation=function(F,b,Q,C,z){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,W=arguments.length>7?arguments[7]:void 0,Z=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],q=arguments.length>9?arguments[9]:void 0,G=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const K=F.getDescendants(b),e=[];e.push(this.beginAnimation(F,Q,C,z,t,g,W,Z,q,void 0,G));for(const N of K)e.push(this.beginAnimation(N,Q,C,z,t,g,W,Z,q,void 0,G));return e},y.prototype.beginDirectAnimation=function(F,b,Q,C,z){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(t<0){const F=Q;Q=C,C=F,t=-t}return Q>C&&(t=-t),new K(this,F,Q,C,z,t,arguments.length>6?arguments[6]:void 0,b,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},y.prototype.beginDirectHierarchyAnimation=function(F,b,Q,C,z,t,g,W,Z){let q=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const G=F.getDescendants(b),K=[];K.push(this.beginDirectAnimation(F,Q,C,z,t,g,W,Z,q));for(const e of G)K.push(this.beginDirectAnimation(e,Q,C,z,t,g,W,Z,q));return K},y.prototype.getAnimatableByTarget=function(F){for(let b=0;b<this._activeAnimatables.length;b++)if(this._activeAnimatables[b].target===F)return this._activeAnimatables[b];return null},y.prototype.getAllAnimatablesByTarget=function(F){const b=[];for(let Q=0;Q<this._activeAnimatables.length;Q++)this._activeAnimatables[Q].target===F&&b.push(this._activeAnimatables[Q]);return b},y.prototype.stopAnimation=function(F,b,Q){const C=this.getAllAnimatablesByTarget(F);for(const z of C)z.stop(b,Q)},y.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let F=0;F<this._activeAnimatables.length;F++)this._activeAnimatables[F].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const F of this.animationGroups)F.stop()});class X{getClassName(){return"TargetedAnimation"}serialize(){const F={};return F.animation=this.animation.serialize(),F.targetId=this.target.id,F}}class L{get mask(){return this._mask}set mask(F){this._mask!==F&&(this._mask=F,this.syncWithMask(!0))}syncWithMask(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||F){this._numActiveAnimatables=0;for(let F=0;F<this._animatables.length;++F){const b=this._animatables[F];!this.mask||this.mask.disabled||this.mask.retainsTarget(b.target.name)?(this._numActiveAnimatables++,b.paused&&b.restart()):b.paused||b.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let F=0;F<this._animatables.length;++F){const b=this._animatables[F];this.mask.retainsTarget(b.target.name)||(b.stop(),this._animatables.splice(F,1),--F)}for(let F=0;F<this._targetedAnimations.length;F++){const b=this._targetedAnimations[F];this.mask.retainsTarget(b.target.name)||(this._targetedAnimations.splice(F,1),--F)}}}get from(){return this._from}set from(F){if(this._from!==F){this._from=F;for(let F=0;F<this._animatables.length;F++){this._animatables[F].fromFrame=this._from}}}get to(){return this._to}set to(F){if(this._to!==F){this._to=F;for(let F=0;F<this._animatables.length;F++){this._animatables[F].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(F){if(this._speedRatio!==F){this._speedRatio=F;for(let F=0;F<this._animatables.length;F++){this._animatables[F].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(F){if(this._loopAnimation!==F){this._loopAnimation=F;for(let F=0;F<this._animatables.length;F++){this._animatables[F].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(F){if(this._isAdditive!==F){this._isAdditive=F;for(let F=0;F<this._animatables.length;F++){this._animatables[F].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(F){this._weight!==F&&(this._weight=F,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(F){if(this._playOrder!==F&&(this._playOrder=F,this._animatables.length>0)){for(let F=0;F<this._animatables.length;F++)this._animatables[F].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(F){if(this._enableBlending!==F&&(this._enableBlending=F,null!==F))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.enableBlending=F}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(F){if(this._blendingSpeed!==F&&(this._blendingSpeed=F,null!==F))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.blendingSpeed=F}getLength(F,b){F=F??this._from;return((b=b??this._to)-F)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(F){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=arguments.length>3?arguments[3]:void 0;if(0===F.length)return null;C=C??F[0].weight;let z=Number.MAX_VALUE,t=-Number.MAX_VALUE;if(Q)for(const W of F)W.from<z&&(z=W.from),W.to>t&&(t=W.to);const g=new L(F[0].name+"_merged",F[0]._scene,C);for(const W of F){Q&&W.normalize(z,t);for(const F of W.targetedAnimations)g.addTargetedAnimation(F.animation,F.target);b&&W.dispose()}return g}constructor(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=F,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new z.c,this.onAnimationLoopObservable=new z.c,this.onAnimationGroupLoopObservable=new z.c,this.onAnimationGroupEndObservable=new z.c,this.onAnimationGroupPauseObservable=new z.c,this.onAnimationGroupPlayObservable=new z.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=b||t.d.LastCreatedScene,this._weight=Q,this._playOrder=C,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(F,b){const Q=new X;Q.animation=F,Q.target=b;const C=F.getKeys();return this._from>C[0].frame&&(this._from=C[0].frame),this._to<C[C.length-1].frame&&(this._to=C[C.length-1].frame),null!==this._enableBlending&&(F.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(F.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(Q),this._shouldStart=!0,Q}removeTargetedAnimation(F){for(let b=this._targetedAnimations.length-1;b>-1;b--){this._targetedAnimations[b].animation===F&&this._targetedAnimations.splice(b,1)}}normalize(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==F&&(F=this._from),null==b&&(b=this._to);for(let Q=0;Q<this._targetedAnimations.length;Q++){const C=this._targetedAnimations[Q].animation.getKeys(),z=C[0],t=C[C.length-1];if(z.frame>F){const b={frame:F,value:z.value,inTangent:z.inTangent,outTangent:z.outTangent,interpolation:z.interpolation};C.splice(0,0,b)}if(t.frame<b){const F={frame:b,value:t.value,inTangent:t.inTangent,outTangent:t.outTangent,interpolation:t.interpolation};C.push(F)}}return this._from=F,this._to=b,this}_processLoop(F,b,Q){F.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(b),this._animationLoopFlags[Q]||(this._animationLoopFlags[Q]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0],b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Q=arguments.length>2?arguments[2]:void 0,C=arguments.length>3?arguments[3]:void 0,z=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=F,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let t=0;t<this._targetedAnimations.length;t++){const g=this._targetedAnimations[t],W=this._scene.beginDirectAnimation(g.target,[g.animation],void 0!==Q?Q:this._from,void 0!==C?C:this._to,F,b,void 0,void 0,void 0!==z?z:this._isAdditive);W.weight=this._weight,W.playOrder=this._playOrder,W.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(g),this._checkAnimationGroupEnded(W)},this._processLoop(W,g,t),this._animatables.push(W)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=b,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let F=0;F<this._animatables.length;F++){this._animatables[F].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(F){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==F&&(this.loopAnimation=F),this.restart()):(this.stop(),this.start(F,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let F=0;F<this._animatables.length;F++){this._animatables[F].reset()}return this}restart(){if(!this._isStarted)return this;for(let F=0;F<this._animatables.length;F++){this._animatables[F].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const b=this._animatables.slice();for(let C=0;C<b.length;C++)b[C].stop(void 0,void 0,!0,F);let Q=0;for(let C=0;C<this._scene._activeAnimatables.length;C++){const b=this._scene._activeAnimatables[C];b._runtimeAnimations.length>0?this._scene._activeAnimatables[Q++]=b:F&&this._checkAnimationGroupEnded(b,F)}return this._scene._activeAnimatables.length=Q,this._isStarted=!1,this}setWeightForAllAnimatables(F){for(let b=0;b<this._animatables.length;b++){this._animatables[b].weight=F}return this}syncAllAnimationsWith(F){for(let b=0;b<this._animatables.length;b++){this._animatables[b].syncWith(F)}return this}goToFrame(F){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].goToFrame(F,b)}return this}getCurrentFrame(){var F;return(null===(F=this.animatables[0])||void 0===F?void 0:F.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const F=this._scene.animationGroups.indexOf(this);if(F>-1&&this._scene.animationGroups.splice(F,1),this._parentContainer){const F=this._parentContainer.animationGroups.indexOf(this);F>-1&&this._parentContainer.animationGroups.splice(F,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(F){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Q=this._animatables.indexOf(F);Q>-1&&this._animatables.splice(Q,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,b||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(F,b){let Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const C=new L(F||this.name,this._scene,this._weight,this._playOrder);C._from=this.from,C._to=this.to,C._speedRatio=this.speedRatio,C._loopAnimation=this.loopAnimation,C._isAdditive=this.isAdditive,C._enableBlending=this.enableBlending,C._blendingSpeed=this.blendingSpeed,C.metadata=this.metadata,C.mask=this.mask;for(const z of this._targetedAnimations)C.addTargetedAnimation(Q?z.animation.clone():z.animation,b?b(z.target):z.target);return C}serialize(){const F={};F.name=this.name,F.from=this.from,F.to=this.to,F.speedRatio=this.speedRatio,F.loopAnimation=this.loopAnimation,F.isAdditive=this.isAdditive,F.weight=this.weight,F.playOrder=this.playOrder,F.enableBlending=this.enableBlending,F.blendingSpeed=this.blendingSpeed,F.targetedAnimations=[];for(let b=0;b<this.targetedAnimations.length;b++){const Q=this.targetedAnimations[b];F.targetedAnimations[b]=Q.serialize()}return g.e&&g.e.HasTags(this)&&(F.tags=g.e.GetTags(this)),this.metadata&&(F.metadata=this.metadata),F}static Parse(F,b){const Q=new L(F.name,b,F.weight,F.playOrder);for(let z=0;z<F.targetedAnimations.length;z++){const t=F.targetedAnimations[z],g=C.b.Parse(t.animation),W=t.targetId;if("influence"===t.animation.property){const F=b.getMorphTargetById(W);F&&Q.addTargetedAnimation(g,F)}else{const F=b.getNodeById(W);null!=F&&Q.addTargetedAnimation(g,F)}}return g.e&&g.e.AddTagsTo(Q,F.tags),null!==F.from&&null!==F.to&&Q.normalize(F.from,F.to),void 0!==F.speedRatio&&(Q._speedRatio=F.speedRatio),void 0!==F.loopAnimation&&(Q._loopAnimation=F.loopAnimation),void 0!==F.isAdditive&&(Q._isAdditive=F.isAdditive),void 0!==F.weight&&(Q._weight=F.weight),void 0!==F.playOrder&&(Q._playOrder=F.playOrder),void 0!==F.enableBlending&&(Q._enableBlending=F.enableBlending),void 0!==F.blendingSpeed&&(Q._blendingSpeed=F.blendingSpeed),void 0!==F.metadata&&(Q.metadata=F.metadata),Q}static MakeAnimationAdditive(F,b,Q){let z;z="object"===typeof b?b:{referenceFrame:b,range:Q,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let t=F;z.cloneOriginalAnimationGroup&&(t=F.clone(z.clonedAnimationGroupName||t.name));const g=t.targetedAnimations;for(let W=0;W<g.length;W++){const F=g[W];F.animation=C.b.MakeAnimationAdditive(F.animation,z)}if(t.isAdditive=!0,z.clipKeys){let F=Number.MAX_VALUE,b=-Number.MAX_VALUE;const Q=t.targetedAnimations;for(let C=0;C<Q.length;C++){const z=Q[C].animation.getKeys();F>z[0].frame&&(F=z[0].frame),b<z[z.length-1].frame&&(b=z[z.length-1].frame)}t._from=F,t._to=b}return t}static ClipKeys(F,b,Q,C,z){const t=F.clone(C||F.name);return L.ClipKeysInPlace(t,b,Q,z)}static ClipKeysInPlace(F,b,Q,C){return L.ClipInPlace(F,b,Q,C,!1)}static ClipFrames(F,b,Q,C,z){const t=F.clone(C||F.name);return L.ClipFramesInPlace(t,b,Q,z)}static ClipFramesInPlace(F,b,Q,C){return L.ClipInPlace(F,b,Q,C,!0)}static ClipInPlace(F,b,Q,C){let z=arguments.length>4&&void 0!==arguments[4]&&arguments[4],t=Number.MAX_VALUE,g=-Number.MAX_VALUE;const W=F.targetedAnimations;for(let Z=0;Z<W.length;Z++){const F=W[Z],q=C?F.animation:F.animation.clone();z&&(q.createKeyForFrame(b),q.createKeyForFrame(Q));const G=q.getKeys(),K=[];let e=Number.MAX_VALUE;for(let C=0;C<G.length;C++){const F=G[C];if(!z&&C>=b&&C<=Q||z&&F.frame>=b&&F.frame<=Q){const b={frame:F.frame,value:F.value.clone?F.value.clone():F.value,inTangent:F.inTangent,outTangent:F.outTangent,interpolation:F.interpolation,lockedTangent:F.lockedTangent};e===Number.MAX_VALUE&&(e=b.frame),b.frame-=e,K.push(b)}}0!==K.length?(t>K[0].frame&&(t=K[0].frame),g<K[K.length-1].frame&&(g=K[K.length-1].frame),q.setKeys(K,!0),F.animation=q):(W.splice(Z,1),Z--)}return F._from=t,F._to=g,F}getClassName(){return"AnimationGroup"}toString(F){let b="Name: "+this.name;return b+=", type: "+this.getClassName(),F&&(b+=", from: "+this._from,b+=", to: "+this._to,b+=", isStarted: "+this._isStarted,b+=", speedRatio: "+this._speedRatio,b+=", targetedAnimations length: "+this._targetedAnimations.length,b+=", animatables length: "+this._animatables),b}}}}]);