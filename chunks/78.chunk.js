"use strict";(self.wy695la1oic=self.wy695la1oic||[]).push([[78],{14571:(S,v,D)=>{D.r(v),D.d(v,{AnimationGroup:()=>q,TargetedAnimation:()=>K});var z=D(11884),e=D(11179),N=D(11222),m=D(11422),B=D(13036),g=D(11371);class E{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(S,v,D,e){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=v,this._target=S,this._scene=D,this._host=e,this._activeTargets=[],v._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===z.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=g.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const S={frame:0,value:this._minValue};this._keys.splice(0,0,S)}if(this._target instanceof Array){let S=0;for(const v of this._target)this._preparePath(v,S),this._getOriginalValues(S),S++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const N=v.getEvents();if(N&&N.length>0)for(const z of N)this._events.push(z._clone());this._enableBlending=S&&S.animationPropertiesOverride?S.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const D=this._animation.targetPropertyPath;if(D.length>1){let z=S;for(let S=0;S<D.length-1;S++){const v=D[S];if(z=z[v],void 0===z)throw new Error(`Invalid property (${v}) in property path (${D.join(".")})`)}this._targetPath=D[D.length-1],this._activeTargets[v]=z}else this._targetPath=D[0],this._activeTargets[v]=S;if(void 0===this._activeTargets[v][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${D.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let S=0;for(const v of this._target)void 0!==this._originalValue[S]&&this._setValue(v,this._activeTargets[S],this._originalValue[S],-1,S),S++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let S=0;S<this._events.length;S++)this._events[S].isDone=!1}isStopped(){return this._stopped}dispose(){const S=this._animation.runtimeAnimations.indexOf(this);S>-1&&this._animation.runtimeAnimations.splice(S,1)}setValue(S,v){if(this._targetIsArray)for(let D=0;D<this._target.length;D++){const z=this._target[D];this._setValue(z,this._activeTargets[D],S,v,D)}else this._setValue(this._target,this._directTarget,S,v,0)}_getOriginalValues(){let S,v=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const D=this._activeTargets[v];S=D.getLocalMatrix&&"_matrix"===this._targetPath?D.getLocalMatrix():D[this._targetPath],S&&S.clone?this._originalValue[v]=S.clone():this._originalValue[v]=S}_registerTargetForLateAnimationBinding(S,v){const D=S.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(D),D._lateAnimationHolders||(D._lateAnimationHolders={}),D._lateAnimationHolders[S.targetPath]||(D._lateAnimationHolders[S.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:v}),S.isAdditive?(D._lateAnimationHolders[S.targetPath].additiveAnimations.push(S),D._lateAnimationHolders[S.targetPath].totalAdditiveWeight+=S.weight):(D._lateAnimationHolders[S.targetPath].animations.push(S),D._lateAnimationHolders[S.targetPath].totalWeight+=S.weight)}_setValue(S,v,D,e,N){if(this._currentActiveTarget=v,this._weight=e,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const S=v[this._targetPath];S.clone?this._originalBlendValue=S.clone():this._originalBlendValue=S}this._originalBlendValue.m?z.b.AllowMatrixDecomposeForInterpolation?this._currentValue?g.Matrix.DecomposeLerpToRef(this._originalBlendValue,D,this._blendingFactor,this._currentValue):this._currentValue=g.Matrix.DecomposeLerp(this._originalBlendValue,D,this._blendingFactor):this._currentValue?g.Matrix.LerpToRef(this._originalBlendValue,D,this._blendingFactor,this._currentValue):this._currentValue=g.Matrix.Lerp(this._originalBlendValue,D,this._blendingFactor):this._currentValue=z.b._UniversalLerp(this._originalBlendValue,D,this._blendingFactor);const e=S&&S.animationPropertiesOverride?S.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=e}else this._currentValue?this._currentValue.N?this._currentValue.N(D):this._currentValue=D:null!==D&&void 0!==D&&D.clone?this._currentValue=D.clone():this._currentValue=D;-1!==e?this._registerTargetForLateAnimationBinding(this,this._originalValue[N]):this._animationState.loopMode===z.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[N],v[this._targetPath]):v[this._targetPath]=this._originalValue[N]+this._currentValue:v[this._targetPath]=this._currentValue,S.PE&&S.PE(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const D=this._animation.getKeys();S<D[0].frame?S=D[0].frame:S>D[D.length-1].frame&&(S=D[D.length-1].frame);const z=this._events;if(z.length)for(let N=0;N<z.length;N++)z[N].onlyOnce||(z[N].isDone=z[N].frame<S);this._currentFrame=S;const e=this._animation._interpolate(S,this._animationState);this.setValue(e,v)}_prepareForSpeedRatioChange(S){const v=this._previousElapsedTime*(this._animation.framePerSecond*S)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-v}animate(S,v,D,e,N){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const B=this._animation,g=B.targetPropertyPath;if(!g||g.length<1)return this._stopped=!0,!1;let E,h=!0;const A=this._events;let w=0;if(this._coreRuntimeAnimation)w=D-v,E=this._coreRuntimeAnimation.currentFrame,this._currentFrame=E,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let m;(v<this._minFrame||v>this._maxFrame)&&(v=this._minFrame),(D<this._minFrame||D>this._maxFrame)&&(D=this._maxFrame),w=D-v;let g=S*(B.framePerSecond*N)/1e3+this._absoluteFrameOffset,n=0,R=!1;const O=e&&this._animationState.loopMode===z.b.ANIMATIONLOOPMODE_YOYO;if(O){const S=(g-v)/w,D=Math.sin(S*Math.PI);g=Math.abs(D)*w+v;const z=D>=0?1:-1;this._yoyoDirection!==z&&(R=!0),this._yoyoDirection=z}if(this._previousElapsedTime=S,this._previousAbsoluteFrame=g,!e&&D>=v&&(g>=w&&N>0||g<=0&&N<0))h=!1,n=B._getKeyValue(this._maxValue);else if(!e&&v>=D&&(g<=w&&N<0||g>=0&&N>0))h=!1,n=B._getKeyValue(this._minValue);else if(this._animationState.loopMode!==z.b.ANIMATIONLOOPMODE_CYCLE){const S=D.toString()+v.toString();if(!this._offsetsCache[S]){this._animationState.repeatCount=0,this._animationState.loopMode=z.b.ANIMATIONLOOPMODE_CYCLE;const e=B._interpolate(v,this._animationState),N=B._interpolate(D,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),B.dataType){case z.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[S]=N-e;break;case z.b.ANIMATIONTYPE_QUATERNION:case z.b.ANIMATIONTYPE_VECTOR3:case z.b.ANIMATIONTYPE_VECTOR2:case z.b.ANIMATIONTYPE_SIZE:case z.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[S]=N.Ov(e)}this._highLimitsCache[S]=N}n=this._highLimitsCache[S],m=this._offsetsCache[S]}if(void 0===m)switch(B.dataType){case z.b.ANIMATIONTYPE_FLOAT:m=0;break;case z.b.ANIMATIONTYPE_QUATERNION:m=z.l;break;case z.b.ANIMATIONTYPE_VECTOR3:m=z.t;break;case z.b.ANIMATIONTYPE_VECTOR2:m=z.q;break;case z.b.ANIMATIONTYPE_SIZE:m=z.o;break;case z.b.ANIMATIONTYPE_COLOR3:m=z.f;break;case z.b.ANIMATIONTYPE_COLOR4:m=z.h}if(this._host&&this._host.syncRoot){const S=this._host.syncRoot;E=v+w*((S.masterFrame-S.fromFrame)/(S.toFrame-S.fromFrame))}else E=g>0&&v>D||g<0&&v<D?h&&0!==w?D+g%w:v:h&&0!==w?v+g%w:D;if(!O&&(N>0&&this.currentFrame>E||N<0&&this.currentFrame<E)||O&&R){this._onLoop();for(let S=0;S<A.length;S++)A[S].onlyOnce||(A[S].isDone=!1);this._animationState.key=N>0?0:B.getKeys().length-1}this._currentFrame=E,this._animationState.repeatCount=0===w?0:g/w|0,this._animationState.highLimitValue=n,this._animationState.offsetValue=m}const n=B._interpolate(E,this._animationState);if(this.setValue(n,m),A.length)for(let z=0;z<A.length;z++)if(w>=0&&E>=A[z].frame&&A[z].frame>=v||w<0&&E<=A[z].frame&&A[z].frame<=v){const S=A[z];S.isDone||(S.onlyOnce&&(A.splice(z,1),z--),S.isDone=!0,S.action(E))}return h||(this._stopped=!0),h}}var h=D(11199);class A{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(S){this._weight=-1!==S?Math.min(Math.max(S,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(S){for(let v=0;v<this._runtimeAnimations.length;v++){this._runtimeAnimations[v]._prepareForSpeedRatioChange(S)}this._speedRatio=S,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(S,v){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,N=arguments.length>4&&void 0!==arguments[4]&&arguments[4],m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,B=arguments.length>6?arguments[6]:void 0,g=arguments.length>7?arguments[7]:void 0,E=arguments.length>8?arguments[8]:void 0,h=arguments.length>9&&void 0!==arguments[9]&&arguments[9],A=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=v,this.fromFrame=D,this.toFrame=z,this.loopAnimation=N,this.onAnimationEnd=B,this.onAnimationLoop=E,this.isAdditive=h,this.playOrder=A,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.IB=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new e.d,this.onAnimationLoopObservable=new e.d,this._scene=S,g&&this.appendAnimations(v,g),this._speedRatio=m,S._activeAnimatables.push(this)}syncWith(S){if(this._syncRoot=S,S){const S=this._scene._activeAnimatables.indexOf(this);S>-1&&(this._scene._activeAnimatables.splice(S,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(S,v){for(let D=0;D<v.length;D++){const z=v[D],e=new E(S,z,this._scene,this);e._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(e)}}getAnimationByTargetProperty(S){const v=this._runtimeAnimations;for(let D=0;D<v.length;D++)if(v[D].animation.targetProperty===S)return v[D].animation;return null}getRuntimeAnimationByTargetProperty(S){const v=this._runtimeAnimations;for(let D=0;D<v.length;D++)if(v[D].animation.targetProperty===S)return v[D];return null}reset(){const S=this._runtimeAnimations;for(let v=0;v<S.length;v++)S[v].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(S){const v=this._runtimeAnimations;for(let D=0;D<v.length;D++)v[D].animation.enableBlending=!0,v[D].animation.blendingSpeed=S}disableBlending(){const S=this._runtimeAnimations;for(let v=0;v<S.length;v++)S[v].animation.enableBlending=!1}goToFrame(S){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const D=this._runtimeAnimations;if(D[0]){const v=D[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??D[0].currentFrame;const z=0===this.speedRatio?0:(S-this._frameToSyncFromJump)/v*1e3/this.speedRatio;this._manualJumpDelay=-z}for(let z=0;z<D.length;z++)D[z].goToFrame(S,v?this._weight:-1);this._goToFrame=S}get paused(){return this.IB}pause(){this.IB||(this.IB=!0)}restart(){this.IB=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(S,v){let D=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(S||v){const e=this._scene._activeAnimatables.indexOf(this);if(e>-1){const N=this._runtimeAnimations;for(let D=N.length-1;D>=0;D--){const z=N[D];S&&z.animation.name!=S||(v&&!v(z.target)||(z.dispose(),N.splice(D,1)))}0==N.length&&(D||this._scene._activeAnimatables.splice(e,1),z||this._raiseOnAnimationEnd())}}else{const S=this._scene._activeAnimatables.indexOf(this);if(S>-1){D||this._scene._activeAnimatables.splice(S,1);const v=this._runtimeAnimations;for(let S=0;S<v.length;S++)v[S].dispose();this._runtimeAnimations.length=0,z||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((S=>{this.onAnimationEndObservable.add((()=>{S(this)}),void 0,void 0,this,!0)}))}_animate(S){if(this.IB)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=S),!0;if(null===this._localDelayOffset?(this._localDelayOffset=S,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=S-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let v=!1;const D=this._runtimeAnimations;let z;for(z=0;z<D.length;z++){const e=D[z].animate(S-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);v=v||e}if(this.animationStarted=v,!v){if(this.disposeOnEnd)for(z=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(z,1),z=0;z<D.length;z++)D[z].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return v}}function w(S){if(0===S.totalWeight&&0===S.totalAdditiveWeight)return S.originalValue;let v=1;const D=g.TmpVectors.Rv[0],z=g.TmpVectors.Rv[1],e=g.TmpVectors.Quaternion[0];let N=0;const m=S.animations[0],B=S.originalValue;let E=1,h=!1;if(S.totalWeight<1)E=1-S.totalWeight,B.decompose(z,e,D);else{if(N=1,v=S.totalWeight,E=m.weight/v,1==E){if(!S.totalAdditiveWeight)return m.currentValue;h=!0}m.currentValue.decompose(z,e,D)}if(!h){z.scaleInPlace(E),D.scaleInPlace(E),e.scaleInPlace(E);for(let m=N;m<S.animations.length;m++){const N=S.animations[m];if(0===N.weight)continue;E=N.weight/v;const B=g.TmpVectors.Rv[2],h=g.TmpVectors.Rv[3],A=g.TmpVectors.Quaternion[1];N.currentValue.decompose(h,A,B),h.scaleAndAddToRef(E,z),A.scaleAndAddToRef(g.Quaternion.Dot(e,A)>0?E:-E,e),B.scaleAndAddToRef(E,D)}e.normalize()}for(let w=0;w<S.additiveAnimations.length;w++){const v=S.additiveAnimations[w];if(0===v.weight)continue;const N=g.TmpVectors.Rv[2],m=g.TmpVectors.Rv[3],B=g.TmpVectors.Quaternion[1];v.currentValue.decompose(m,B,N),m.multiplyToRef(z,m),g.Rv.LerpToRef(z,m,v.weight,z),e.multiplyToRef(B,B),g.Quaternion.SlerpToRef(e,B,v.weight,e),N.scaleAndAddToRef(v.weight,D)}const A=m?m._animationState.workValue:g.TmpVectors.Matrix[0].clone();return g.Matrix.ComposeToRef(z,e,D,A),A}function n(S,v){if(0===S.totalWeight&&0===S.totalAdditiveWeight)return v;const D=S.animations[0],z=S.originalValue;let e=v;if(0===S.totalWeight&&S.totalAdditiveWeight>0)e.N(z);else if(1===S.animations.length){if(g.Quaternion.SlerpToRef(z,D.currentValue,Math.min(1,S.totalWeight),e),0===S.totalAdditiveWeight)return e}else if(S.animations.length>1){let D,N,m=1;if(S.totalWeight<1){const v=1-S.totalWeight;D=[],N=[],D.push(z),N.push(v)}else{if(2===S.animations.length&&(g.Quaternion.SlerpToRef(S.animations[0].currentValue,S.animations[1].currentValue,S.animations[1].weight/S.totalWeight,v),0===S.totalAdditiveWeight))return v;D=[],N=[],m=S.totalWeight}for(let v=0;v<S.animations.length;v++){const z=S.animations[v];D.push(z.currentValue),N.push(z.weight/m)}let B=0;for(let S=0;S<D.length;)S?(B+=N[S],g.Quaternion.SlerpToRef(e,D[S],N[S]/B,e),S++):(g.Quaternion.SlerpToRef(D[S],D[S+1],N[S+1]/(N[S]+N[S+1]),v),e=v,B=N[S]+N[S+1],S+=2)}for(let N=0;N<S.additiveAnimations.length;N++){const v=S.additiveAnimations[N];0!==v.weight&&(e.multiplyToRef(v.currentValue,g.TmpVectors.Quaternion[0]),g.Quaternion.SlerpToRef(e,g.TmpVectors.Quaternion[0],v.weight,e))}return e}var R,O,I=D(11619);R=I.d,(O=B.d)&&(O.prototype.copyAnimationRange=function(S,v,D){let e=arguments.length>3&&void 0!==arguments[3]&&arguments[3],N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new z.b(this.name,"_matrix",S.animations[0].framePerSecond,z.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const m=S.animations[0].getRange(v);if(!m)return!1;const B=m.from,g=m.to,E=S.animations[0].getKeys(),h=S.length,A=S.getParent(),w=this.getParent(),n=e&&A&&h&&this.length&&h!==this.length,R=n&&w&&A?w.length/A.length:1,O=e&&!w&&N&&(1!==N.x||1!==N.y||1!==N.z),I=this.animations[0].getKeys();let K,q,u;for(let z=0,s=E.length;z<s;z++)K=E[z],K.frame>=B&&K.frame<=g&&(e?(u=K.value.clone(),n?(q=u.getTranslation(),u.setTranslation(q.scaleInPlace(R))):O&&N?(q=u.getTranslation(),u.setTranslation(q.multiplyInPlace(N))):u=K.value):u=K.value,I.push({frame:K.frame+D,value:u}));return this.animations[0].createRange(v,B+D,g+D),!0}),R&&(R.prototype._animate=function(S){if(!this.animationsEnabled)return;const v=h.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=v}this.deltaTime=void 0!==S?S:this.useConstantAnimationDeltaTime?16:(v-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=v;const D=this._activeAnimatables;if(0===D.length)return;this._animationTime+=this.deltaTime;const e=this._animationTime;for(let z=0;z<D.length;z++){const S=D[z];!S._animate(e)&&S.disposeOnEnd&&z--}!function(S){if(S._registeredForLateAnimationBindings.length){for(let v=0;v<S._registeredForLateAnimationBindings.length;v++){const D=S._registeredForLateAnimationBindings.data[v];for(const S in D._lateAnimationHolders){const v=D._lateAnimationHolders[S],e=v.animations[0],N=v.originalValue;if(void 0===N||null===N)continue;const m=z.b.AllowMatrixDecomposeForInterpolation&&N.m;let B=D[S];if(m)B=w(v);else if(void 0!==N.w)B=n(v,B||g.Quaternion.Identity());else{let S=0,D=1;const m=e&&e._animationState.loopMode===z.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(v.totalWeight<1)B=m?N.clone?N.clone():N:e&&N.scale?N.scale(1-v.totalWeight):e?N*(1-v.totalWeight):N.clone?N.clone():N;else if(e){D=v.totalWeight;const z=e.weight/D;B=1!==z?e.currentValue.scale?e.currentValue.scale(z):e.currentValue*z:e.currentValue,m&&(B.addToRef?B.addToRef(N,B):B+=N),S=1}for(let z=S;z<v.animations.length;z++){const S=v.animations[z],e=S.weight/D;e&&(S.currentValue.scaleAndAddToRef?S.currentValue.scaleAndAddToRef(e,B):B+=S.currentValue*e)}for(let z=0;z<v.additiveAnimations.length;z++){const S=v.additiveAnimations[z],D=S.weight;D&&(S.currentValue.scaleAndAddToRef?S.currentValue.scaleAndAddToRef(D,B):B+=S.currentValue*D)}}D[S]=B}D._lateAnimationHolders={}}S._registeredForLateAnimationBindings.reset()}}(this)},R.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((S,v)=>S.playOrder-v.playOrder))},R.prototype.beginWeightedAnimation=function(S,v,D){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,e=arguments.length>4?arguments[4]:void 0,N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,m=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0,g=arguments.length>8?arguments[8]:void 0,E=arguments.length>9?arguments[9]:void 0,h=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const A=this.beginAnimation(S,v,D,e,N,m,B,!1,g,E,h);return A.weight=z,A},R.prototype.beginAnimation=function(S,v,D,z){let e=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,N=arguments.length>5?arguments[5]:void 0,m=arguments.length>6?arguments[6]:void 0,B=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],g=arguments.length>8?arguments[8]:void 0,E=arguments.length>9?arguments[9]:void 0,h=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(e<0){const S=v;v=D,D=S,e=-e}v>D&&(e=-e),B&&this.stopAnimation(S,void 0,g),m||(m=new A(this,S,v,D,z,e,N,void 0,E,h));const w=!g||g(S);if(S.animations&&w&&m.appendAnimations(S,S.animations),S.getAnimatables){const h=S.getAnimatables();for(let S=0;S<h.length;S++)this.beginAnimation(h[S],v,D,z,e,N,m,B,g,E)}return m.reset(),m},R.prototype.beginHierarchyAnimation=function(S,v,D,z,e){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,m=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0,g=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],E=arguments.length>9?arguments[9]:void 0,h=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const A=S.getDescendants(v),w=[];w.push(this.beginAnimation(S,D,z,e,N,m,B,g,E,void 0,h));for(const n of A)w.push(this.beginAnimation(n,D,z,e,N,m,B,g,E,void 0,h));return w},R.prototype.beginDirectAnimation=function(S,v,D,z,e){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(N<0){const S=D;D=z,z=S,N=-N}return D>z&&(N=-N),new A(this,S,D,z,e,N,arguments.length>6?arguments[6]:void 0,v,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},R.prototype.beginDirectHierarchyAnimation=function(S,v,D,z,e,N,m,B,g){let E=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const h=S.getDescendants(v),A=[];A.push(this.beginDirectAnimation(S,D,z,e,N,m,B,g,E));for(const w of h)A.push(this.beginDirectAnimation(w,D,z,e,N,m,B,g,E));return A},R.prototype.getAnimatableByTarget=function(S){for(let v=0;v<this._activeAnimatables.length;v++)if(this._activeAnimatables[v].target===S)return this._activeAnimatables[v];return null},R.prototype.getAllAnimatablesByTarget=function(S){const v=[];for(let D=0;D<this._activeAnimatables.length;D++)this._activeAnimatables[D].target===S&&v.push(this._activeAnimatables[D]);return v},R.prototype.stopAnimation=function(S,v,D){const z=this.getAllAnimatablesByTarget(S);for(const e of z)e.stop(v,D)},R.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let S=0;S<this._activeAnimatables.length;S++)this._activeAnimatables[S].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const S of this.animationGroups)S.stop()});class K{getClassName(){return"TargetedAnimation"}serialize(){const S={};return S.animation=this.animation.serialize(),S.targetId=this.target.id,S}}class q{get mask(){return this._mask}set mask(S){this._mask!==S&&(this._mask=S,this.syncWithMask(!0))}syncWithMask(){let S=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||S){this._numActiveAnimatables=0;for(let S=0;S<this._animatables.length;++S){const v=this._animatables[S];!this.mask||this.mask.disabled||this.mask.retainsTarget(v.target.name)?(this._numActiveAnimatables++,v.paused&&v.restart()):v.paused||v.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let S=0;S<this._animatables.length;++S){const v=this._animatables[S];this.mask.retainsTarget(v.target.name)||(v.stop(),this._animatables.splice(S,1),--S)}for(let S=0;S<this._targetedAnimations.length;S++){const v=this._targetedAnimations[S];this.mask.retainsTarget(v.target.name)||(this._targetedAnimations.splice(S,1),--S)}}}get from(){return this._from}set from(S){if(this._from!==S){this._from=S;for(let S=0;S<this._animatables.length;S++){this._animatables[S].fromFrame=this._from}}}get to(){return this._to}set to(S){if(this._to!==S){this._to=S;for(let S=0;S<this._animatables.length;S++){this._animatables[S].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(S){if(this._speedRatio!==S){this._speedRatio=S;for(let S=0;S<this._animatables.length;S++){this._animatables[S].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(S){if(this._loopAnimation!==S){this._loopAnimation=S;for(let S=0;S<this._animatables.length;S++){this._animatables[S].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(S){if(this._isAdditive!==S){this._isAdditive=S;for(let S=0;S<this._animatables.length;S++){this._animatables[S].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(S){this._weight!==S&&(this._weight=S,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(S){if(this._playOrder!==S&&(this._playOrder=S,this._animatables.length>0)){for(let S=0;S<this._animatables.length;S++)this._animatables[S].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(S){if(this._enableBlending!==S&&(this._enableBlending=S,null!==S))for(let v=0;v<this._targetedAnimations.length;++v)this._targetedAnimations[v].animation.enableBlending=S}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(S){if(this._blendingSpeed!==S&&(this._blendingSpeed=S,null!==S))for(let v=0;v<this._targetedAnimations.length;++v)this._targetedAnimations[v].animation.blendingSpeed=S}getLength(S,v){S=S??this._from;return((v=v??this._to)-S)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(S){let v=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],D=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=arguments.length>3?arguments[3]:void 0;if(0===S.length)return null;z=z??S[0].weight;let e=Number.MAX_VALUE,N=-Number.MAX_VALUE;if(D)for(const B of S)B.from<e&&(e=B.from),B.to>N&&(N=B.to);const m=new q(S[0].name+"_merged",S[0]._scene,z);for(const B of S){D&&B.normalize(e,N);for(const S of B.targetedAnimations)m.addTargetedAnimation(S.animation,S.target);v&&B.dispose()}return m}constructor(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=S,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new e.d,this.onAnimationLoopObservable=new e.d,this.onAnimationGroupLoopObservable=new e.d,this.onAnimationGroupEndObservable=new e.d,this.onAnimationGroupPauseObservable=new e.d,this.onAnimationGroupPlayObservable=new e.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=v||N.c.LastCreatedScene,this._weight=D,this._playOrder=z,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(S,v){const D=new K;D.animation=S,D.target=v;const z=S.getKeys();return this._from>z[0].frame&&(this._from=z[0].frame),this._to<z[z.length-1].frame&&(this._to=z[z.length-1].frame),null!==this._enableBlending&&(S.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(S.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(D),this._shouldStart=!0,D}removeTargetedAnimation(S){for(let v=this._targetedAnimations.length-1;v>-1;v--){this._targetedAnimations[v].animation===S&&this._targetedAnimations.splice(v,1)}}normalize(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==S&&(S=this._from),null==v&&(v=this._to);for(let D=0;D<this._targetedAnimations.length;D++){const z=this._targetedAnimations[D].animation.getKeys(),e=z[0],N=z[z.length-1];if(e.frame>S){const v={frame:S,value:e.value,inTangent:e.inTangent,outTangent:e.outTangent,interpolation:e.interpolation};z.splice(0,0,v)}if(N.frame<v){const S={frame:v,value:N.value,inTangent:N.inTangent,outTangent:N.outTangent,interpolation:N.interpolation};z.push(S)}}return this._from=S,this._to=v,this}_processLoop(S,v,D){S.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(v),this._animationLoopFlags[D]||(this._animationLoopFlags[D]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let S=arguments.length>0&&void 0!==arguments[0]&&arguments[0],v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,D=arguments.length>2?arguments[2]:void 0,z=arguments.length>3?arguments[3]:void 0,e=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=S,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let N=0;N<this._targetedAnimations.length;N++){const m=this._targetedAnimations[N],B=this._scene.beginDirectAnimation(m.target,[m.animation],void 0!==D?D:this._from,void 0!==z?z:this._to,S,v,void 0,void 0,void 0!==e?e:this._isAdditive);B.weight=this._weight,B.playOrder=this._playOrder,B.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(m),this._checkAnimationGroupEnded(B)},this._processLoop(B,m,N),this._animatables.push(B)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=v,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let S=0;S<this._animatables.length;S++){this._animatables[S].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(S){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==S&&(this.loopAnimation=S),this.restart()):(this.stop(),this.start(S,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let S=0;S<this._animatables.length;S++){this._animatables[S].reset()}return this}restart(){if(!this._isStarted)return this;for(let S=0;S<this._animatables.length;S++){this._animatables[S].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let S=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const v=this._animatables.slice();for(let z=0;z<v.length;z++)v[z].stop(void 0,void 0,!0,S);let D=0;for(let z=0;z<this._scene._activeAnimatables.length;z++){const v=this._scene._activeAnimatables[z];v._runtimeAnimations.length>0?this._scene._activeAnimatables[D++]=v:S&&this._checkAnimationGroupEnded(v,S)}return this._scene._activeAnimatables.length=D,this._isStarted=!1,this}setWeightForAllAnimatables(S){for(let v=0;v<this._animatables.length;v++){this._animatables[v].weight=S}return this}syncAllAnimationsWith(S){for(let v=0;v<this._animatables.length;v++){this._animatables[v].syncWith(S)}return this}goToFrame(S){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let D=0;D<this._animatables.length;D++){this._animatables[D].goToFrame(S,v)}return this}getCurrentFrame(){var S;return(null===(S=this.animatables[0])||void 0===S?void 0:S.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const S=this._scene.animationGroups.indexOf(this);if(S>-1&&this._scene.animationGroups.splice(S,1),this._parentContainer){const S=this._parentContainer.animationGroups.indexOf(this);S>-1&&this._parentContainer.animationGroups.splice(S,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(S){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const D=this._animatables.indexOf(S);D>-1&&this._animatables.splice(D,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,v||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(S,v){let D=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const z=new q(S||this.name,this._scene,this._weight,this._playOrder);z._from=this.from,z._to=this.to,z._speedRatio=this.speedRatio,z._loopAnimation=this.loopAnimation,z._isAdditive=this.isAdditive,z._enableBlending=this.enableBlending,z._blendingSpeed=this.blendingSpeed,z.metadata=this.metadata,z.mask=this.mask;for(const e of this._targetedAnimations)z.addTargetedAnimation(D?e.animation.clone():e.animation,v?v(e.target):e.target);return z}serialize(){const S={};S.name=this.name,S.from=this.from,S.to=this.to,S.speedRatio=this.speedRatio,S.loopAnimation=this.loopAnimation,S.isAdditive=this.isAdditive,S.weight=this.weight,S.playOrder=this.playOrder,S.enableBlending=this.enableBlending,S.blendingSpeed=this.blendingSpeed,S.targetedAnimations=[];for(let v=0;v<this.targetedAnimations.length;v++){const D=this.targetedAnimations[v];S.targetedAnimations[v]=D.serialize()}return m.c&&m.c.HasTags(this)&&(S.tags=m.c.GetTags(this)),this.metadata&&(S.metadata=this.metadata),S}static Parse(S,v){const D=new q(S.name,v,S.weight,S.playOrder);for(let e=0;e<S.targetedAnimations.length;e++){const N=S.targetedAnimations[e],m=z.b.Parse(N.animation),B=N.targetId;if("influence"===N.animation.property){const S=v.getMorphTargetById(B);S&&D.addTargetedAnimation(m,S)}else{const S=v.getNodeById(B);null!=S&&D.addTargetedAnimation(m,S)}}return m.c&&m.c.AddTagsTo(D,S.tags),null!==S.from&&null!==S.to&&D.normalize(S.from,S.to),void 0!==S.speedRatio&&(D._speedRatio=S.speedRatio),void 0!==S.loopAnimation&&(D._loopAnimation=S.loopAnimation),void 0!==S.isAdditive&&(D._isAdditive=S.isAdditive),void 0!==S.weight&&(D._weight=S.weight),void 0!==S.playOrder&&(D._playOrder=S.playOrder),void 0!==S.enableBlending&&(D._enableBlending=S.enableBlending),void 0!==S.blendingSpeed&&(D._blendingSpeed=S.blendingSpeed),void 0!==S.metadata&&(D.metadata=S.metadata),D}static MakeAnimationAdditive(S,v,D){let e;e="object"===typeof v?v:{referenceFrame:v,range:D,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let N=S;e.cloneOriginalAnimationGroup&&(N=S.clone(e.clonedAnimationGroupName||N.name));const m=N.targetedAnimations;for(let B=0;B<m.length;B++){const S=m[B];S.animation=z.b.MakeAnimationAdditive(S.animation,e)}if(N.isAdditive=!0,e.clipKeys){let S=Number.MAX_VALUE,v=-Number.MAX_VALUE;const D=N.targetedAnimations;for(let z=0;z<D.length;z++){const e=D[z].animation.getKeys();S>e[0].frame&&(S=e[0].frame),v<e[e.length-1].frame&&(v=e[e.length-1].frame)}N._from=S,N._to=v}return N}static ClipKeys(S,v,D,z,e){const N=S.clone(z||S.name);return q.ClipKeysInPlace(N,v,D,e)}static ClipKeysInPlace(S,v,D,z){return q.ClipInPlace(S,v,D,z,!1)}static ClipFrames(S,v,D,z,e){const N=S.clone(z||S.name);return q.ClipFramesInPlace(N,v,D,e)}static ClipFramesInPlace(S,v,D,z){return q.ClipInPlace(S,v,D,z,!0)}static ClipInPlace(S,v,D,z){let e=arguments.length>4&&void 0!==arguments[4]&&arguments[4],N=Number.MAX_VALUE,m=-Number.MAX_VALUE;const B=S.targetedAnimations;for(let g=0;g<B.length;g++){const S=B[g],E=z?S.animation:S.animation.clone();e&&(E.createKeyForFrame(v),E.createKeyForFrame(D));const h=E.getKeys(),A=[];let w=Number.MAX_VALUE;for(let z=0;z<h.length;z++){const S=h[z];if(!e&&z>=v&&z<=D||e&&S.frame>=v&&S.frame<=D){const v={frame:S.frame,value:S.value.clone?S.value.clone():S.value,inTangent:S.inTangent,outTangent:S.outTangent,interpolation:S.interpolation,lockedTangent:S.lockedTangent};w===Number.MAX_VALUE&&(w=v.frame),v.frame-=w,A.push(v)}}0!==A.length?(N>A[0].frame&&(N=A[0].frame),m<A[A.length-1].frame&&(m=A[A.length-1].frame),E.setKeys(A,!0),S.animation=E):(B.splice(g,1),g--)}return S._from=N,S._to=m,S}getClassName(){return"AnimationGroup"}toString(S){let v="Name: "+this.name;return v+=", type: "+this.getClassName(),S&&(v+=", from: "+this._from,v+=", to: "+this._to,v+=", isStarted: "+this._isStarted,v+=", speedRatio: "+this._speedRatio,v+=", targetedAnimations length: "+this._targetedAnimations.length,v+=", animatables length: "+this._animatables),v}}}}]);