"use strict";(self["5dou0t7wntc"]=self["5dou0t7wntc"]||[]).push([[78],{14899:(K,O,F)=>{F.r(O),F.d(O,{AnimationGroup:()=>N,TargetedAnimation:()=>k});var f=F(12266),r=F(11523),l=F(11559),q=F(11762),J=F(13361),c=F(11713);class E{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(K,O,F,r){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=O,this._target=K,this._scene=F,this._host=r,this._activeTargets=[],O._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===f.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=c.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const K={frame:0,value:this._minValue};this._keys.splice(0,0,K)}if(this._target instanceof Array){let K=0;for(const O of this._target)this._preparePath(O,K),this._getOriginalValues(K),K++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const l=O.getEvents();if(l&&l.length>0)for(const f of l)this._events.push(f._clone());this._enableBlending=K&&K.animationPropertiesOverride?K.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const F=this._animation.targetPropertyPath;if(F.length>1){let f=K;for(let K=0;K<F.length-1;K++){const O=F[K];if(f=f[O],void 0===f)throw new Error(`Invalid property (${O}) in property path (${F.join(".")})`)}this._targetPath=F[F.length-1],this._activeTargets[O]=f}else this._targetPath=F[0],this._activeTargets[O]=K;if(void 0===this._activeTargets[O][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${F.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let K=0;for(const O of this._target)void 0!==this._originalValue[K]&&this._setValue(O,this._activeTargets[K],this._originalValue[K],-1,K),K++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let K=0;K<this._events.length;K++)this._events[K].isDone=!1}isStopped(){return this._stopped}dispose(){const K=this._animation.runtimeAnimations.indexOf(this);K>-1&&this._animation.runtimeAnimations.splice(K,1)}setValue(K,O){if(this._targetIsArray)for(let F=0;F<this._target.length;F++){const f=this._target[F];this._setValue(f,this._activeTargets[F],K,O,F)}else this._setValue(this._target,this._directTarget,K,O,0)}_getOriginalValues(){let K,O=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const F=this._activeTargets[O];K=F.getLocalMatrix&&"_matrix"===this._targetPath?F.getLocalMatrix():F[this._targetPath],K&&K.clone?this._originalValue[O]=K.clone():this._originalValue[O]=K}_registerTargetForLateAnimationBinding(K,O){const F=K.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(F),F._lateAnimationHolders||(F._lateAnimationHolders={}),F._lateAnimationHolders[K.targetPath]||(F._lateAnimationHolders[K.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:O}),K.isAdditive?(F._lateAnimationHolders[K.targetPath].additiveAnimations.push(K),F._lateAnimationHolders[K.targetPath].totalAdditiveWeight+=K.weight):(F._lateAnimationHolders[K.targetPath].animations.push(K),F._lateAnimationHolders[K.targetPath].totalWeight+=K.weight)}_setValue(K,O,F,r,l){if(this._currentActiveTarget=O,this._weight=r,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const K=O[this._targetPath];K.clone?this._originalBlendValue=K.clone():this._originalBlendValue=K}this._originalBlendValue.m?f.d.AllowMatrixDecomposeForInterpolation?this._currentValue?c.Matrix.DecomposeLerpToRef(this._originalBlendValue,F,this._blendingFactor,this._currentValue):this._currentValue=c.Matrix.DecomposeLerp(this._originalBlendValue,F,this._blendingFactor):this._currentValue?c.Matrix.LerpToRef(this._originalBlendValue,F,this._blendingFactor,this._currentValue):this._currentValue=c.Matrix.Lerp(this._originalBlendValue,F,this._blendingFactor):this._currentValue=f.d._UniversalLerp(this._originalBlendValue,F,this._blendingFactor);const r=K&&K.animationPropertiesOverride?K.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=r}else this._currentValue?this._currentValue.l?this._currentValue.l(F):this._currentValue=F:null!==F&&void 0!==F&&F.clone?this._currentValue=F.clone():this._currentValue=F;-1!==r?this._registerTargetForLateAnimationBinding(this,this._originalValue[l]):this._animationState.loopMode===f.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[l],O[this._targetPath]):O[this._targetPath]=this._originalValue[l]+this._currentValue:O[this._targetPath]=this._currentValue,K.NM&&K.NM(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const F=this._animation.getKeys();K<F[0].frame?K=F[0].frame:K>F[F.length-1].frame&&(K=F[F.length-1].frame);const f=this._events;if(f.length)for(let l=0;l<f.length;l++)f[l].onlyOnce||(f[l].isDone=f[l].frame<K);this._currentFrame=K;const r=this._animation._interpolate(K,this._animationState);this.setValue(r,O)}_prepareForSpeedRatioChange(K){const O=this._previousElapsedTime*(this._animation.framePerSecond*K)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-O}animate(K,O,F,r,l){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const J=this._animation,c=J.targetPropertyPath;if(!c||c.length<1)return this._stopped=!0,!1;let E,M=!0;const t=this._events;let j=0;if(this._coreRuntimeAnimation)j=F-O,E=this._coreRuntimeAnimation.currentFrame,this._currentFrame=E,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let q;(O<this._minFrame||O>this._maxFrame)&&(O=this._minFrame),(F<this._minFrame||F>this._maxFrame)&&(F=this._maxFrame),j=F-O;let c=K*(J.framePerSecond*l)/1e3+this._absoluteFrameOffset,X=0,u=!1;const T=r&&this._animationState.loopMode===f.d.ANIMATIONLOOPMODE_YOYO;if(T){const K=(c-O)/j,F=Math.sin(K*Math.PI);c=Math.abs(F)*j+O;const f=F>=0?1:-1;this._yoyoDirection!==f&&(u=!0),this._yoyoDirection=f}if(this._previousElapsedTime=K,this._previousAbsoluteFrame=c,!r&&F>=O&&(c>=j&&l>0||c<=0&&l<0))M=!1,X=J._getKeyValue(this._maxValue);else if(!r&&O>=F&&(c<=j&&l<0||c>=0&&l>0))M=!1,X=J._getKeyValue(this._minValue);else if(this._animationState.loopMode!==f.d.ANIMATIONLOOPMODE_CYCLE){const K=F.toString()+O.toString();if(!this._offsetsCache[K]){this._animationState.repeatCount=0,this._animationState.loopMode=f.d.ANIMATIONLOOPMODE_CYCLE;const r=J._interpolate(O,this._animationState),l=J._interpolate(F,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),J.dataType){case f.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[K]=l-r;break;case f.d.ANIMATIONTYPE_QUATERNION:case f.d.ANIMATIONTYPE_VECTOR3:case f.d.ANIMATIONTYPE_VECTOR2:case f.d.ANIMATIONTYPE_SIZE:case f.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[K]=l.oO(r)}this._highLimitsCache[K]=l}X=this._highLimitsCache[K],q=this._offsetsCache[K]}if(void 0===q)switch(J.dataType){case f.d.ANIMATIONTYPE_FLOAT:q=0;break;case f.d.ANIMATIONTYPE_QUATERNION:q=f.m;break;case f.d.ANIMATIONTYPE_VECTOR3:q=f.w;break;case f.d.ANIMATIONTYPE_VECTOR2:q=f.s;break;case f.d.ANIMATIONTYPE_SIZE:q=f.q;break;case f.d.ANIMATIONTYPE_COLOR3:q=f.g;break;case f.d.ANIMATIONTYPE_COLOR4:q=f.k}if(this._host&&this._host.syncRoot){const K=this._host.syncRoot;E=O+j*((K.masterFrame-K.fromFrame)/(K.toFrame-K.fromFrame))}else E=c>0&&O>F||c<0&&O<F?M&&0!==j?F+c%j:O:M&&0!==j?O+c%j:F;if(!T&&(l>0&&this.currentFrame>E||l<0&&this.currentFrame<E)||T&&u){this._onLoop();for(let K=0;K<t.length;K++)t[K].onlyOnce||(t[K].isDone=!1);this._animationState.key=l>0?0:J.getKeys().length-1}this._currentFrame=E,this._animationState.repeatCount=0===j?0:c/j|0,this._animationState.highLimitValue=X,this._animationState.offsetValue=q}const X=J._interpolate(E,this._animationState);if(this.setValue(X,q),t.length)for(let f=0;f<t.length;f++)if(j>=0&&E>=t[f].frame&&t[f].frame>=O||j<0&&E<=t[f].frame&&t[f].frame<=O){const K=t[f];K.isDone||(K.onlyOnce&&(t.splice(f,1),f--),K.isDone=!0,K.action(E))}return M||(this._stopped=!0),M}}var M=F(11541);class t{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(K){this._weight=-1!==K?Math.min(Math.max(K,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(K){for(let O=0;O<this._runtimeAnimations.length;O++){this._runtimeAnimations[O]._prepareForSpeedRatioChange(K)}this._speedRatio=K,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(K,O){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,l=arguments.length>4&&void 0!==arguments[4]&&arguments[4],q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,J=arguments.length>6?arguments[6]:void 0,c=arguments.length>7?arguments[7]:void 0,E=arguments.length>8?arguments[8]:void 0,M=arguments.length>9&&void 0!==arguments[9]&&arguments[9],t=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=O,this.fromFrame=F,this.toFrame=f,this.loopAnimation=l,this.onAnimationEnd=J,this.onAnimationLoop=E,this.isAdditive=M,this.playOrder=t,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.tJ=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new r.c,this.onAnimationLoopObservable=new r.c,this._scene=K,c&&this.appendAnimations(O,c),this._speedRatio=q,K._activeAnimatables.push(this)}syncWith(K){if(this._syncRoot=K,K){const K=this._scene._activeAnimatables.indexOf(this);K>-1&&(this._scene._activeAnimatables.splice(K,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(K,O){for(let F=0;F<O.length;F++){const f=O[F],r=new E(K,f,this._scene,this);r._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(r)}}getAnimationByTargetProperty(K){const O=this._runtimeAnimations;for(let F=0;F<O.length;F++)if(O[F].animation.targetProperty===K)return O[F].animation;return null}getRuntimeAnimationByTargetProperty(K){const O=this._runtimeAnimations;for(let F=0;F<O.length;F++)if(O[F].animation.targetProperty===K)return O[F];return null}reset(){const K=this._runtimeAnimations;for(let O=0;O<K.length;O++)K[O].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(K){const O=this._runtimeAnimations;for(let F=0;F<O.length;F++)O[F].animation.enableBlending=!0,O[F].animation.blendingSpeed=K}disableBlending(){const K=this._runtimeAnimations;for(let O=0;O<K.length;O++)K[O].animation.enableBlending=!1}goToFrame(K){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const F=this._runtimeAnimations;if(F[0]){const O=F[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??F[0].currentFrame;const f=0===this.speedRatio?0:(K-this._frameToSyncFromJump)/O*1e3/this.speedRatio;this._manualJumpDelay=-f}for(let f=0;f<F.length;f++)F[f].goToFrame(K,O?this._weight:-1);this._goToFrame=K}get paused(){return this.tJ}pause(){this.tJ||(this.tJ=!0)}restart(){this.tJ=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(K,O){let F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],f=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(K||O){const r=this._scene._activeAnimatables.indexOf(this);if(r>-1){const l=this._runtimeAnimations;for(let F=l.length-1;F>=0;F--){const f=l[F];K&&f.animation.name!=K||(O&&!O(f.target)||(f.dispose(),l.splice(F,1)))}0==l.length&&(F||this._scene._activeAnimatables.splice(r,1),f||this._raiseOnAnimationEnd())}}else{const K=this._scene._activeAnimatables.indexOf(this);if(K>-1){F||this._scene._activeAnimatables.splice(K,1);const O=this._runtimeAnimations;for(let K=0;K<O.length;K++)O[K].dispose();this._runtimeAnimations.length=0,f||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((K=>{this.onAnimationEndObservable.add((()=>{K(this)}),void 0,void 0,this,!0)}))}_animate(K){if(this.tJ)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=K),!0;if(null===this._localDelayOffset?(this._localDelayOffset=K,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=K-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let O=!1;const F=this._runtimeAnimations;let f;for(f=0;f<F.length;f++){const r=F[f].animate(K-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);O=O||r}if(this.animationStarted=O,!O){if(this.disposeOnEnd)for(f=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(f,1),f=0;f<F.length;f++)F[f].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return O}}function j(K){if(0===K.totalWeight&&0===K.totalAdditiveWeight)return K.originalValue;let O=1;const F=c.TmpVectors.TO[0],f=c.TmpVectors.TO[1],r=c.TmpVectors.Quaternion[0];let l=0;const q=K.animations[0],J=K.originalValue;let E=1,M=!1;if(K.totalWeight<1)E=1-K.totalWeight,J.decompose(f,r,F);else{if(l=1,O=K.totalWeight,E=q.weight/O,1==E){if(!K.totalAdditiveWeight)return q.currentValue;M=!0}q.currentValue.decompose(f,r,F)}if(!M){f.scaleInPlace(E),F.scaleInPlace(E),r.scaleInPlace(E);for(let q=l;q<K.animations.length;q++){const l=K.animations[q];if(0===l.weight)continue;E=l.weight/O;const J=c.TmpVectors.TO[2],M=c.TmpVectors.TO[3],t=c.TmpVectors.Quaternion[1];l.currentValue.decompose(M,t,J),M.scaleAndAddToRef(E,f),t.scaleAndAddToRef(c.Quaternion.Dot(r,t)>0?E:-E,r),J.scaleAndAddToRef(E,F)}r.normalize()}for(let j=0;j<K.additiveAnimations.length;j++){const O=K.additiveAnimations[j];if(0===O.weight)continue;const l=c.TmpVectors.TO[2],q=c.TmpVectors.TO[3],J=c.TmpVectors.Quaternion[1];O.currentValue.decompose(q,J,l),q.multiplyToRef(f,q),c.TO.LerpToRef(f,q,O.weight,f),r.multiplyToRef(J,J),c.Quaternion.SlerpToRef(r,J,O.weight,r),l.scaleAndAddToRef(O.weight,F)}const t=q?q._animationState.workValue:c.TmpVectors.Matrix[0].clone();return c.Matrix.ComposeToRef(f,r,F,t),t}function X(K,O){if(0===K.totalWeight&&0===K.totalAdditiveWeight)return O;const F=K.animations[0],f=K.originalValue;let r=O;if(0===K.totalWeight&&K.totalAdditiveWeight>0)r.l(f);else if(1===K.animations.length){if(c.Quaternion.SlerpToRef(f,F.currentValue,Math.min(1,K.totalWeight),r),0===K.totalAdditiveWeight)return r}else if(K.animations.length>1){let F,l,q=1;if(K.totalWeight<1){const O=1-K.totalWeight;F=[],l=[],F.push(f),l.push(O)}else{if(2===K.animations.length&&(c.Quaternion.SlerpToRef(K.animations[0].currentValue,K.animations[1].currentValue,K.animations[1].weight/K.totalWeight,O),0===K.totalAdditiveWeight))return O;F=[],l=[],q=K.totalWeight}for(let O=0;O<K.animations.length;O++){const f=K.animations[O];F.push(f.currentValue),l.push(f.weight/q)}let J=0;for(let K=0;K<F.length;)K?(J+=l[K],c.Quaternion.SlerpToRef(r,F[K],l[K]/J,r),K++):(c.Quaternion.SlerpToRef(F[K],F[K+1],l[K+1]/(l[K]+l[K+1]),O),r=O,J=l[K]+l[K+1],K+=2)}for(let l=0;l<K.additiveAnimations.length;l++){const O=K.additiveAnimations[l];0!==O.weight&&(r.multiplyToRef(O.currentValue,c.TmpVectors.Quaternion[0]),c.Quaternion.SlerpToRef(r,c.TmpVectors.Quaternion[0],O.weight,r))}return r}var u,T,o=F(11964);u=o.d,(T=J.d)&&(T.prototype.copyAnimationRange=function(K,O,F){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new f.d(this.name,"_matrix",K.animations[0].framePerSecond,f.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const q=K.animations[0].getRange(O);if(!q)return!1;const J=q.from,c=q.to,E=K.animations[0].getKeys(),M=K.length,t=K.getParent(),j=this.getParent(),X=r&&t&&M&&this.length&&M!==this.length,u=X&&j&&t?j.length/t.length:1,T=r&&!j&&l&&(1!==l.x||1!==l.y||1!==l.z),o=this.animations[0].getKeys();let k,N,Z;for(let f=0,L=E.length;f<L;f++)k=E[f],k.frame>=J&&k.frame<=c&&(r?(Z=k.value.clone(),X?(N=Z.getTranslation(),Z.setTranslation(N.scaleInPlace(u))):T&&l?(N=Z.getTranslation(),Z.setTranslation(N.multiplyInPlace(l))):Z=k.value):Z=k.value,o.push({frame:k.frame+F,value:Z}));return this.animations[0].createRange(O,J+F,c+F),!0}),u&&(u.prototype._animate=function(K){if(!this.animationsEnabled)return;const O=M.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=O}this.deltaTime=void 0!==K?K:this.useConstantAnimationDeltaTime?16:(O-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=O;const F=this._activeAnimatables;if(0===F.length)return;this._animationTime+=this.deltaTime;const r=this._animationTime;for(let f=0;f<F.length;f++){const K=F[f];!K._animate(r)&&K.disposeOnEnd&&f--}!function(K){if(K._registeredForLateAnimationBindings.length){for(let O=0;O<K._registeredForLateAnimationBindings.length;O++){const F=K._registeredForLateAnimationBindings.data[O];for(const K in F._lateAnimationHolders){const O=F._lateAnimationHolders[K],r=O.animations[0],l=O.originalValue;if(void 0===l||null===l)continue;const q=f.d.AllowMatrixDecomposeForInterpolation&&l.m;let J=F[K];if(q)J=j(O);else if(void 0!==l.w)J=X(O,J||c.Quaternion.Identity());else{let K=0,F=1;const q=r&&r._animationState.loopMode===f.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(O.totalWeight<1)J=q?l.clone?l.clone():l:r&&l.scale?l.scale(1-O.totalWeight):r?l*(1-O.totalWeight):l.clone?l.clone():l;else if(r){F=O.totalWeight;const f=r.weight/F;J=1!==f?r.currentValue.scale?r.currentValue.scale(f):r.currentValue*f:r.currentValue,q&&(J.addToRef?J.addToRef(l,J):J+=l),K=1}for(let f=K;f<O.animations.length;f++){const K=O.animations[f],r=K.weight/F;r&&(K.currentValue.scaleAndAddToRef?K.currentValue.scaleAndAddToRef(r,J):J+=K.currentValue*r)}for(let f=0;f<O.additiveAnimations.length;f++){const K=O.additiveAnimations[f],F=K.weight;F&&(K.currentValue.scaleAndAddToRef?K.currentValue.scaleAndAddToRef(F,J):J+=K.currentValue*F)}}F[K]=J}F._lateAnimationHolders={}}K._registeredForLateAnimationBindings.reset()}}(this)},u.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((K,O)=>K.playOrder-O.playOrder))},u.prototype.beginWeightedAnimation=function(K,O,F){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4?arguments[4]:void 0,l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,q=arguments.length>6?arguments[6]:void 0,J=arguments.length>7?arguments[7]:void 0,c=arguments.length>8?arguments[8]:void 0,E=arguments.length>9?arguments[9]:void 0,M=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const t=this.beginAnimation(K,O,F,r,l,q,J,!1,c,E,M);return t.weight=f,t},u.prototype.beginAnimation=function(K,O,F,f){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,l=arguments.length>5?arguments[5]:void 0,q=arguments.length>6?arguments[6]:void 0,J=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],c=arguments.length>8?arguments[8]:void 0,E=arguments.length>9?arguments[9]:void 0,M=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(r<0){const K=O;O=F,F=K,r=-r}O>F&&(r=-r),J&&this.stopAnimation(K,void 0,c),q||(q=new t(this,K,O,F,f,r,l,void 0,E,M));const j=!c||c(K);if(K.animations&&j&&q.appendAnimations(K,K.animations),K.getAnimatables){const M=K.getAnimatables();for(let K=0;K<M.length;K++)this.beginAnimation(M[K],O,F,f,r,l,q,J,c,E)}return q.reset(),q},u.prototype.beginHierarchyAnimation=function(K,O,F,f,r){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,q=arguments.length>6?arguments[6]:void 0,J=arguments.length>7?arguments[7]:void 0,c=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],E=arguments.length>9?arguments[9]:void 0,M=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const t=K.getDescendants(O),j=[];j.push(this.beginAnimation(K,F,f,r,l,q,J,c,E,void 0,M));for(const X of t)j.push(this.beginAnimation(X,F,f,r,l,q,J,c,E,void 0,M));return j},u.prototype.beginDirectAnimation=function(K,O,F,f,r){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(l<0){const K=F;F=f,f=K,l=-l}return F>f&&(l=-l),new t(this,K,F,f,r,l,arguments.length>6?arguments[6]:void 0,O,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},u.prototype.beginDirectHierarchyAnimation=function(K,O,F,f,r,l,q,J,c){let E=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const M=K.getDescendants(O),t=[];t.push(this.beginDirectAnimation(K,F,f,r,l,q,J,c,E));for(const j of M)t.push(this.beginDirectAnimation(j,F,f,r,l,q,J,c,E));return t},u.prototype.getAnimatableByTarget=function(K){for(let O=0;O<this._activeAnimatables.length;O++)if(this._activeAnimatables[O].target===K)return this._activeAnimatables[O];return null},u.prototype.getAllAnimatablesByTarget=function(K){const O=[];for(let F=0;F<this._activeAnimatables.length;F++)this._activeAnimatables[F].target===K&&O.push(this._activeAnimatables[F]);return O},u.prototype.stopAnimation=function(K,O,F){const f=this.getAllAnimatablesByTarget(K);for(const r of f)r.stop(O,F)},u.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let K=0;K<this._activeAnimatables.length;K++)this._activeAnimatables[K].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const K of this.animationGroups)K.stop()});class k{getClassName(){return"TargetedAnimation"}serialize(){const K={};return K.animation=this.animation.serialize(),K.targetId=this.target.id,K}}class N{get mask(){return this._mask}set mask(K){this._mask!==K&&(this._mask=K,this.syncWithMask(!0))}syncWithMask(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||K){this._numActiveAnimatables=0;for(let K=0;K<this._animatables.length;++K){const O=this._animatables[K];!this.mask||this.mask.disabled||this.mask.retainsTarget(O.target.name)?(this._numActiveAnimatables++,O.paused&&O.restart()):O.paused||O.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let K=0;K<this._animatables.length;++K){const O=this._animatables[K];this.mask.retainsTarget(O.target.name)||(O.stop(),this._animatables.splice(K,1),--K)}for(let K=0;K<this._targetedAnimations.length;K++){const O=this._targetedAnimations[K];this.mask.retainsTarget(O.target.name)||(this._targetedAnimations.splice(K,1),--K)}}}get from(){return this._from}set from(K){if(this._from!==K){this._from=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].fromFrame=this._from}}}get to(){return this._to}set to(K){if(this._to!==K){this._to=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(K){if(this._speedRatio!==K){this._speedRatio=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(K){if(this._loopAnimation!==K){this._loopAnimation=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(K){if(this._isAdditive!==K){this._isAdditive=K;for(let K=0;K<this._animatables.length;K++){this._animatables[K].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(K){this._weight!==K&&(this._weight=K,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(K){if(this._playOrder!==K&&(this._playOrder=K,this._animatables.length>0)){for(let K=0;K<this._animatables.length;K++)this._animatables[K].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(K){if(this._enableBlending!==K&&(this._enableBlending=K,null!==K))for(let O=0;O<this._targetedAnimations.length;++O)this._targetedAnimations[O].animation.enableBlending=K}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(K){if(this._blendingSpeed!==K&&(this._blendingSpeed=K,null!==K))for(let O=0;O<this._targetedAnimations.length;++O)this._targetedAnimations[O].animation.blendingSpeed=K}getLength(K,O){K=K??this._from;return((O=O??this._to)-K)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(K){let O=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],f=arguments.length>3?arguments[3]:void 0;if(0===K.length)return null;f=f??K[0].weight;let r=Number.MAX_VALUE,l=-Number.MAX_VALUE;if(F)for(const J of K)J.from<r&&(r=J.from),J.to>l&&(l=J.to);const q=new N(K[0].name+"_merged",K[0]._scene,f);for(const J of K){F&&J.normalize(r,l);for(const K of J.targetedAnimations)q.addTargetedAnimation(K.animation,K.target);O&&J.dispose()}return q}constructor(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=K,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new r.c,this.onAnimationLoopObservable=new r.c,this.onAnimationGroupLoopObservable=new r.c,this.onAnimationGroupEndObservable=new r.c,this.onAnimationGroupPauseObservable=new r.c,this.onAnimationGroupPlayObservable=new r.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=O||l.e.LastCreatedScene,this._weight=F,this._playOrder=f,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(K,O){const F=new k;F.animation=K,F.target=O;const f=K.getKeys();return this._from>f[0].frame&&(this._from=f[0].frame),this._to<f[f.length-1].frame&&(this._to=f[f.length-1].frame),null!==this._enableBlending&&(K.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(K.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(F),this._shouldStart=!0,F}removeTargetedAnimation(K){for(let O=this._targetedAnimations.length-1;O>-1;O--){this._targetedAnimations[O].animation===K&&this._targetedAnimations.splice(O,1)}}normalize(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==K&&(K=this._from),null==O&&(O=this._to);for(let F=0;F<this._targetedAnimations.length;F++){const f=this._targetedAnimations[F].animation.getKeys(),r=f[0],l=f[f.length-1];if(r.frame>K){const O={frame:K,value:r.value,inTangent:r.inTangent,outTangent:r.outTangent,interpolation:r.interpolation};f.splice(0,0,O)}if(l.frame<O){const K={frame:O,value:l.value,inTangent:l.inTangent,outTangent:l.outTangent,interpolation:l.interpolation};f.push(K)}}return this._from=K,this._to=O,this}_processLoop(K,O,F){K.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(O),this._animationLoopFlags[F]||(this._animationLoopFlags[F]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0],O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0,f=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=K,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let l=0;l<this._targetedAnimations.length;l++){const q=this._targetedAnimations[l],J=this._scene.beginDirectAnimation(q.target,[q.animation],void 0!==F?F:this._from,void 0!==f?f:this._to,K,O,void 0,void 0,void 0!==r?r:this._isAdditive);J.weight=this._weight,J.playOrder=this._playOrder,J.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(q),this._checkAnimationGroupEnded(J)},this._processLoop(J,q,l),this._animatables.push(J)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=O,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let K=0;K<this._animatables.length;K++){this._animatables[K].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(K){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==K&&(this.loopAnimation=K),this.restart()):(this.stop(),this.start(K,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let K=0;K<this._animatables.length;K++){this._animatables[K].reset()}return this}restart(){if(!this._isStarted)return this;for(let K=0;K<this._animatables.length;K++){this._animatables[K].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const O=this._animatables.slice();for(let f=0;f<O.length;f++)O[f].stop(void 0,void 0,!0,K);let F=0;for(let f=0;f<this._scene._activeAnimatables.length;f++){const O=this._scene._activeAnimatables[f];O._runtimeAnimations.length>0?this._scene._activeAnimatables[F++]=O:K&&this._checkAnimationGroupEnded(O,K)}return this._scene._activeAnimatables.length=F,this._isStarted=!1,this}setWeightForAllAnimatables(K){for(let O=0;O<this._animatables.length;O++){this._animatables[O].weight=K}return this}syncAllAnimationsWith(K){for(let O=0;O<this._animatables.length;O++){this._animatables[O].syncWith(K)}return this}goToFrame(K){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let F=0;F<this._animatables.length;F++){this._animatables[F].goToFrame(K,O)}return this}getCurrentFrame(){var K;return(null===(K=this.animatables[0])||void 0===K?void 0:K.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const K=this._scene.animationGroups.indexOf(this);if(K>-1&&this._scene.animationGroups.splice(K,1),this._parentContainer){const K=this._parentContainer.animationGroups.indexOf(this);K>-1&&this._parentContainer.animationGroups.splice(K,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(K){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const F=this._animatables.indexOf(K);F>-1&&this._animatables.splice(F,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,O||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(K,O){let F=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const f=new N(K||this.name,this._scene,this._weight,this._playOrder);f._from=this.from,f._to=this.to,f._speedRatio=this.speedRatio,f._loopAnimation=this.loopAnimation,f._isAdditive=this.isAdditive,f._enableBlending=this.enableBlending,f._blendingSpeed=this.blendingSpeed,f.metadata=this.metadata,f.mask=this.mask;for(const r of this._targetedAnimations)f.addTargetedAnimation(F?r.animation.clone():r.animation,O?O(r.target):r.target);return f}serialize(){const K={};K.name=this.name,K.from=this.from,K.to=this.to,K.speedRatio=this.speedRatio,K.loopAnimation=this.loopAnimation,K.isAdditive=this.isAdditive,K.weight=this.weight,K.playOrder=this.playOrder,K.enableBlending=this.enableBlending,K.blendingSpeed=this.blendingSpeed,K.targetedAnimations=[];for(let O=0;O<this.targetedAnimations.length;O++){const F=this.targetedAnimations[O];K.targetedAnimations[O]=F.serialize()}return q.d&&q.d.HasTags(this)&&(K.tags=q.d.GetTags(this)),this.metadata&&(K.metadata=this.metadata),K}static Parse(K,O){const F=new N(K.name,O,K.weight,K.playOrder);for(let r=0;r<K.targetedAnimations.length;r++){const l=K.targetedAnimations[r],q=f.d.Parse(l.animation),J=l.targetId;if("influence"===l.animation.property){const K=O.getMorphTargetById(J);K&&F.addTargetedAnimation(q,K)}else{const K=O.getNodeById(J);null!=K&&F.addTargetedAnimation(q,K)}}return q.d&&q.d.AddTagsTo(F,K.tags),null!==K.from&&null!==K.to&&F.normalize(K.from,K.to),void 0!==K.speedRatio&&(F._speedRatio=K.speedRatio),void 0!==K.loopAnimation&&(F._loopAnimation=K.loopAnimation),void 0!==K.isAdditive&&(F._isAdditive=K.isAdditive),void 0!==K.weight&&(F._weight=K.weight),void 0!==K.playOrder&&(F._playOrder=K.playOrder),void 0!==K.enableBlending&&(F._enableBlending=K.enableBlending),void 0!==K.blendingSpeed&&(F._blendingSpeed=K.blendingSpeed),void 0!==K.metadata&&(F.metadata=K.metadata),F}static MakeAnimationAdditive(K,O,F){let r;r="object"===typeof O?O:{referenceFrame:O,range:F,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let l=K;r.cloneOriginalAnimationGroup&&(l=K.clone(r.clonedAnimationGroupName||l.name));const q=l.targetedAnimations;for(let J=0;J<q.length;J++){const K=q[J];K.animation=f.d.MakeAnimationAdditive(K.animation,r)}if(l.isAdditive=!0,r.clipKeys){let K=Number.MAX_VALUE,O=-Number.MAX_VALUE;const F=l.targetedAnimations;for(let f=0;f<F.length;f++){const r=F[f].animation.getKeys();K>r[0].frame&&(K=r[0].frame),O<r[r.length-1].frame&&(O=r[r.length-1].frame)}l._from=K,l._to=O}return l}static ClipKeys(K,O,F,f,r){const l=K.clone(f||K.name);return N.ClipKeysInPlace(l,O,F,r)}static ClipKeysInPlace(K,O,F,f){return N.ClipInPlace(K,O,F,f,!1)}static ClipFrames(K,O,F,f,r){const l=K.clone(f||K.name);return N.ClipFramesInPlace(l,O,F,r)}static ClipFramesInPlace(K,O,F,f){return N.ClipInPlace(K,O,F,f,!0)}static ClipInPlace(K,O,F,f){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],l=Number.MAX_VALUE,q=-Number.MAX_VALUE;const J=K.targetedAnimations;for(let c=0;c<J.length;c++){const K=J[c],E=f?K.animation:K.animation.clone();r&&(E.createKeyForFrame(O),E.createKeyForFrame(F));const M=E.getKeys(),t=[];let j=Number.MAX_VALUE;for(let f=0;f<M.length;f++){const K=M[f];if(!r&&f>=O&&f<=F||r&&K.frame>=O&&K.frame<=F){const O={frame:K.frame,value:K.value.clone?K.value.clone():K.value,inTangent:K.inTangent,outTangent:K.outTangent,interpolation:K.interpolation,lockedTangent:K.lockedTangent};j===Number.MAX_VALUE&&(j=O.frame),O.frame-=j,t.push(O)}}0!==t.length?(l>t[0].frame&&(l=t[0].frame),q<t[t.length-1].frame&&(q=t[t.length-1].frame),E.setKeys(t,!0),K.animation=E):(J.splice(c,1),c--)}return K._from=l,K._to=q,K}getClassName(){return"AnimationGroup"}toString(K){let O="Name: "+this.name;return O+=", type: "+this.getClassName(),K&&(O+=", from: "+this._from,O+=", to: "+this._to,O+=", isStarted: "+this._isStarted,O+=", speedRatio: "+this._speedRatio,O+=", targetedAnimations length: "+this._targetedAnimations.length,O+=", animatables length: "+this._animatables),O}}}}]);