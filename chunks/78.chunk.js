"use strict";(self["269hv5nclphh"]=self["269hv5nclphh"]||[]).push([[78],{15548:(E,H,d)=>{d.r(H),d.d(H,{AnimationGroup:()=>D,TargetedAnimation:()=>L});var n=d(12910),Z=d(12230),I=d(12268),g=d(12432),l=d(14027),r=d(12384);class t{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(E,H,d,Z){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=H,this._target=E,this._scene=d,this._host=Z,this._activeTargets=[],H._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===n.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=r.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const E={frame:0,value:this._minValue};this._keys.splice(0,0,E)}if(this._target instanceof Array){let E=0;for(const H of this._target)this._preparePath(H,E),this._getOriginalValues(E),E++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const I=H.getEvents();if(I&&I.length>0)for(const n of I)this._events.push(n._clone());this._enableBlending=E&&E.animationPropertiesOverride?E.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const d=this._animation.targetPropertyPath;if(d.length>1){let n=E;for(let E=0;E<d.length-1;E++){const H=d[E];if(n=n[H],void 0===n)throw new Error(`Invalid property (${H}) in property path (${d.join(".")})`)}this._targetPath=d[d.length-1],this._activeTargets[H]=n}else this._targetPath=d[0],this._activeTargets[H]=E;if(void 0===this._activeTargets[H][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${d.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let E=0;for(const H of this._target)void 0!==this._originalValue[E]&&this._setValue(H,this._activeTargets[E],this._originalValue[E],-1,E),E++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let E=0;E<this._events.length;E++)this._events[E].isDone=!1}isStopped(){return this._stopped}dispose(){const E=this._animation.runtimeAnimations.indexOf(this);E>-1&&this._animation.runtimeAnimations.splice(E,1)}setValue(E,H){if(this._targetIsArray)for(let d=0;d<this._target.length;d++){const n=this._target[d];this._setValue(n,this._activeTargets[d],E,H,d)}else this._setValue(this._target,this._directTarget,E,H,0)}_getOriginalValues(){let E,H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const d=this._activeTargets[H];E=d.getLocalMatrix&&"_matrix"===this._targetPath?d.getLocalMatrix():d[this._targetPath],E&&E.clone?this._originalValue[H]=E.clone():this._originalValue[H]=E}_registerTargetForLateAnimationBinding(E,H){const d=E.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(d),d._lateAnimationHolders||(d._lateAnimationHolders={}),d._lateAnimationHolders[E.targetPath]||(d._lateAnimationHolders[E.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:H}),E.isAdditive?(d._lateAnimationHolders[E.targetPath].additiveAnimations.push(E),d._lateAnimationHolders[E.targetPath].totalAdditiveWeight+=E.weight):(d._lateAnimationHolders[E.targetPath].animations.push(E),d._lateAnimationHolders[E.targetPath].totalWeight+=E.weight)}_setValue(E,H,d,Z,I){if(this._currentActiveTarget=H,this._weight=Z,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const E=H[this._targetPath];E.clone?this._originalBlendValue=E.clone():this._originalBlendValue=E}this._originalBlendValue.m?n.b.AllowMatrixDecomposeForInterpolation?this._currentValue?r.Matrix.DecomposeLerpToRef(this._originalBlendValue,d,this._blendingFactor,this._currentValue):this._currentValue=r.Matrix.DecomposeLerp(this._originalBlendValue,d,this._blendingFactor):this._currentValue?r.Matrix.LerpToRef(this._originalBlendValue,d,this._blendingFactor,this._currentValue):this._currentValue=r.Matrix.Lerp(this._originalBlendValue,d,this._blendingFactor):this._currentValue=n.b._UniversalLerp(this._originalBlendValue,d,this._blendingFactor);const Z=E&&E.animationPropertiesOverride?E.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=Z}else this._currentValue?this._currentValue.l?this._currentValue.l(d):this._currentValue=d:null!==d&&void 0!==d&&d.clone?this._currentValue=d.clone():this._currentValue=d;-1!==Z?this._registerTargetForLateAnimationBinding(this,this._originalValue[I]):this._animationState.loopMode===n.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[I],H[this._targetPath]):H[this._targetPath]=this._originalValue[I]+this._currentValue:H[this._targetPath]=this._currentValue,E.HS&&E.HS(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const d=this._animation.getKeys();E<d[0].frame?E=d[0].frame:E>d[d.length-1].frame&&(E=d[d.length-1].frame);const n=this._events;if(n.length)for(let I=0;I<n.length;I++)n[I].onlyOnce||(n[I].isDone=n[I].frame<E);this._currentFrame=E;const Z=this._animation._interpolate(E,this._animationState);this.setValue(Z,H)}_prepareForSpeedRatioChange(E){const H=this._previousElapsedTime*(this._animation.framePerSecond*E)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-H}animate(E,H,d,Z,I){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const l=this._animation,r=l.targetPropertyPath;if(!r||r.length<1)return this._stopped=!0,!1;let t,S=!0;const M=this._events;let V=0;if(this._coreRuntimeAnimation)V=d-H,t=this._coreRuntimeAnimation.currentFrame,this._currentFrame=t,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let g;(H<this._minFrame||H>this._maxFrame)&&(H=this._minFrame),(d<this._minFrame||d>this._maxFrame)&&(d=this._maxFrame),V=d-H;let r=E*(l.framePerSecond*I)/1e3+this._absoluteFrameOffset,C=0,w=!1;const R=Z&&this._animationState.loopMode===n.b.ANIMATIONLOOPMODE_YOYO;if(R){const E=(r-H)/V,d=Math.sin(E*Math.PI);r=Math.abs(d)*V+H;const n=d>=0?1:-1;this._yoyoDirection!==n&&(w=!0),this._yoyoDirection=n}if(this._previousElapsedTime=E,this._previousAbsoluteFrame=r,!Z&&d>=H&&(r>=V&&I>0||r<=0&&I<0))S=!1,C=l._getKeyValue(this._maxValue);else if(!Z&&H>=d&&(r<=V&&I<0||r>=0&&I>0))S=!1,C=l._getKeyValue(this._minValue);else if(this._animationState.loopMode!==n.b.ANIMATIONLOOPMODE_CYCLE){const E=d.toString()+H.toString();if(!this._offsetsCache[E]){this._animationState.repeatCount=0,this._animationState.loopMode=n.b.ANIMATIONLOOPMODE_CYCLE;const Z=l._interpolate(H,this._animationState),I=l._interpolate(d,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),l.dataType){case n.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[E]=I-Z;break;case n.b.ANIMATIONTYPE_QUATERNION:case n.b.ANIMATIONTYPE_VECTOR3:case n.b.ANIMATIONTYPE_VECTOR2:case n.b.ANIMATIONTYPE_SIZE:case n.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[E]=I.RH(Z)}this._highLimitsCache[E]=I}C=this._highLimitsCache[E],g=this._offsetsCache[E]}if(void 0===g)switch(l.dataType){case n.b.ANIMATIONTYPE_FLOAT:g=0;break;case n.b.ANIMATIONTYPE_QUATERNION:g=n.k;break;case n.b.ANIMATIONTYPE_VECTOR3:g=n.o;break;case n.b.ANIMATIONTYPE_VECTOR2:g=n.n;break;case n.b.ANIMATIONTYPE_SIZE:g=n.m;break;case n.b.ANIMATIONTYPE_COLOR3:g=n.e;break;case n.b.ANIMATIONTYPE_COLOR4:g=n.g}if(this._host&&this._host.syncRoot){const E=this._host.syncRoot;t=H+V*((E.masterFrame-E.fromFrame)/(E.toFrame-E.fromFrame))}else t=r>0&&H>d||r<0&&H<d?S&&0!==V?d+r%V:H:S&&0!==V?H+r%V:d;if(!R&&(I>0&&this.currentFrame>t||I<0&&this.currentFrame<t)||R&&w){this._onLoop();for(let E=0;E<M.length;E++)M[E].onlyOnce||(M[E].isDone=!1);this._animationState.key=I>0?0:l.getKeys().length-1}this._currentFrame=t,this._animationState.repeatCount=0===V?0:r/V|0,this._animationState.highLimitValue=C,this._animationState.offsetValue=g}const C=l._interpolate(t,this._animationState);if(this.setValue(C,g),M.length)for(let n=0;n<M.length;n++)if(V>=0&&t>=M[n].frame&&M[n].frame>=H||V<0&&t<=M[n].frame&&M[n].frame<=H){const E=M[n];E.isDone||(E.onlyOnce&&(M.splice(n,1),n--),E.isDone=!0,E.action(t))}return S||(this._stopped=!0),S}}var S=d(12247);class M{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(E){this._weight=-1!==E?Math.min(Math.max(E,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(E){for(let H=0;H<this._runtimeAnimations.length;H++){this._runtimeAnimations[H]._prepareForSpeedRatioChange(E)}this._speedRatio=E,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(E,H){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,I=arguments.length>4&&void 0!==arguments[4]&&arguments[4],g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,l=arguments.length>6?arguments[6]:void 0,r=arguments.length>7?arguments[7]:void 0,t=arguments.length>8?arguments[8]:void 0,S=arguments.length>9&&void 0!==arguments[9]&&arguments[9],M=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=H,this.fromFrame=d,this.toFrame=n,this.loopAnimation=I,this.onAnimationEnd=l,this.onAnimationLoop=t,this.isAdditive=S,this.playOrder=M,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Ol=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new Z.e,this.onAnimationLoopObservable=new Z.e,this._scene=E,r&&this.appendAnimations(H,r),this._speedRatio=g,E._activeAnimatables.push(this)}syncWith(E){if(this._syncRoot=E,E){const E=this._scene._activeAnimatables.indexOf(this);E>-1&&(this._scene._activeAnimatables.splice(E,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(E,H){for(let d=0;d<H.length;d++){const n=H[d],Z=new t(E,n,this._scene,this);Z._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(Z)}}getAnimationByTargetProperty(E){const H=this._runtimeAnimations;for(let d=0;d<H.length;d++)if(H[d].animation.targetProperty===E)return H[d].animation;return null}getRuntimeAnimationByTargetProperty(E){const H=this._runtimeAnimations;for(let d=0;d<H.length;d++)if(H[d].animation.targetProperty===E)return H[d];return null}reset(){const E=this._runtimeAnimations;for(let H=0;H<E.length;H++)E[H].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(E){const H=this._runtimeAnimations;for(let d=0;d<H.length;d++)H[d].animation.enableBlending=!0,H[d].animation.blendingSpeed=E}disableBlending(){const E=this._runtimeAnimations;for(let H=0;H<E.length;H++)E[H].animation.enableBlending=!1}goToFrame(E){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const d=this._runtimeAnimations;if(d[0]){const H=d[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??d[0].currentFrame;const n=0===this.speedRatio?0:(E-this._frameToSyncFromJump)/H*1e3/this.speedRatio;this._manualJumpDelay=-n}for(let n=0;n<d.length;n++)d[n].goToFrame(E,H?this._weight:-1);this._goToFrame=E}get paused(){return this.Ol}pause(){this.Ol||(this.Ol=!0)}restart(){this.Ol=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(E,H){let d=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(E||H){const Z=this._scene._activeAnimatables.indexOf(this);if(Z>-1){const I=this._runtimeAnimations;for(let d=I.length-1;d>=0;d--){const n=I[d];E&&n.animation.name!=E||(H&&!H(n.target)||(n.dispose(),I.splice(d,1)))}0==I.length&&(d||this._scene._activeAnimatables.splice(Z,1),n||this._raiseOnAnimationEnd())}}else{const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){d||this._scene._activeAnimatables.splice(E,1);const H=this._runtimeAnimations;for(let E=0;E<H.length;E++)H[E].dispose();this._runtimeAnimations.length=0,n||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((E=>{this.onAnimationEndObservable.add((()=>{E(this)}),void 0,void 0,this,!0)}))}_animate(E){if(this.Ol)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=E),!0;if(null===this._localDelayOffset?(this._localDelayOffset=E,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=E-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let H=!1;const d=this._runtimeAnimations;let n;for(n=0;n<d.length;n++){const Z=d[n].animate(E-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);H=H||Z}if(this.animationStarted=H,!H){if(this.disposeOnEnd)for(n=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(n,1),n=0;n<d.length;n++)d[n].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return H}}function V(E){if(0===E.totalWeight&&0===E.totalAdditiveWeight)return E.originalValue;let H=1;const d=r.TmpVectors.wH[0],n=r.TmpVectors.wH[1],Z=r.TmpVectors.Quaternion[0];let I=0;const g=E.animations[0],l=E.originalValue;let t=1,S=!1;if(E.totalWeight<1)t=1-E.totalWeight,l.decompose(n,Z,d);else{if(I=1,H=E.totalWeight,t=g.weight/H,1==t){if(!E.totalAdditiveWeight)return g.currentValue;S=!0}g.currentValue.decompose(n,Z,d)}if(!S){n.scaleInPlace(t),d.scaleInPlace(t),Z.scaleInPlace(t);for(let g=I;g<E.animations.length;g++){const I=E.animations[g];if(0===I.weight)continue;t=I.weight/H;const l=r.TmpVectors.wH[2],S=r.TmpVectors.wH[3],M=r.TmpVectors.Quaternion[1];I.currentValue.decompose(S,M,l),S.scaleAndAddToRef(t,n),M.scaleAndAddToRef(r.Quaternion.Dot(Z,M)>0?t:-t,Z),l.scaleAndAddToRef(t,d)}Z.normalize()}for(let V=0;V<E.additiveAnimations.length;V++){const H=E.additiveAnimations[V];if(0===H.weight)continue;const I=r.TmpVectors.wH[2],g=r.TmpVectors.wH[3],l=r.TmpVectors.Quaternion[1];H.currentValue.decompose(g,l,I),g.multiplyToRef(n,g),r.wH.LerpToRef(n,g,H.weight,n),Z.multiplyToRef(l,l),r.Quaternion.SlerpToRef(Z,l,H.weight,Z),I.scaleAndAddToRef(H.weight,d)}const M=g?g._animationState.workValue:r.TmpVectors.Matrix[0].clone();return r.Matrix.ComposeToRef(n,Z,d,M),M}function C(E,H){if(0===E.totalWeight&&0===E.totalAdditiveWeight)return H;const d=E.animations[0],n=E.originalValue;let Z=H;if(0===E.totalWeight&&E.totalAdditiveWeight>0)Z.l(n);else if(1===E.animations.length){if(r.Quaternion.SlerpToRef(n,d.currentValue,Math.min(1,E.totalWeight),Z),0===E.totalAdditiveWeight)return Z}else if(E.animations.length>1){let d,I,g=1;if(E.totalWeight<1){const H=1-E.totalWeight;d=[],I=[],d.push(n),I.push(H)}else{if(2===E.animations.length&&(r.Quaternion.SlerpToRef(E.animations[0].currentValue,E.animations[1].currentValue,E.animations[1].weight/E.totalWeight,H),0===E.totalAdditiveWeight))return H;d=[],I=[],g=E.totalWeight}for(let H=0;H<E.animations.length;H++){const n=E.animations[H];d.push(n.currentValue),I.push(n.weight/g)}let l=0;for(let E=0;E<d.length;)E?(l+=I[E],r.Quaternion.SlerpToRef(Z,d[E],I[E]/l,Z),E++):(r.Quaternion.SlerpToRef(d[E],d[E+1],I[E+1]/(I[E]+I[E+1]),H),Z=H,l=I[E]+I[E+1],E+=2)}for(let I=0;I<E.additiveAnimations.length;I++){const H=E.additiveAnimations[I];0!==H.weight&&(Z.multiplyToRef(H.currentValue,r.TmpVectors.Quaternion[0]),r.Quaternion.SlerpToRef(Z,r.TmpVectors.Quaternion[0],H.weight,Z))}return Z}var w,R,Q=d(12634);w=Q.c,(R=l.e)&&(R.prototype.copyAnimationRange=function(E,H,d){let Z=arguments.length>3&&void 0!==arguments[3]&&arguments[3],I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new n.b(this.name,"_matrix",E.animations[0].framePerSecond,n.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const g=E.animations[0].getRange(H);if(!g)return!1;const l=g.from,r=g.to,t=E.animations[0].getKeys(),S=E.length,M=E.getParent(),V=this.getParent(),C=Z&&M&&S&&this.length&&S!==this.length,w=C&&V&&M?V.length/M.length:1,R=Z&&!V&&I&&(1!==I.x||1!==I.y||1!==I.z),Q=this.animations[0].getKeys();let L,D,e;for(let n=0,s=t.length;n<s;n++)L=t[n],L.frame>=l&&L.frame<=r&&(Z?(e=L.value.clone(),C?(D=e.getTranslation(),e.setTranslation(D.scaleInPlace(w))):R&&I?(D=e.getTranslation(),e.setTranslation(D.multiplyInPlace(I))):e=L.value):e=L.value,Q.push({frame:L.frame+d,value:e}));return this.animations[0].createRange(H,l+d,r+d),!0}),w&&(w.prototype._animate=function(E){if(!this.animationsEnabled)return;const H=S.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=H}this.deltaTime=void 0!==E?E:this.useConstantAnimationDeltaTime?16:(H-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=H;const d=this._activeAnimatables;if(0===d.length)return;this._animationTime+=this.deltaTime;const Z=this._animationTime;for(let n=0;n<d.length;n++){const E=d[n];!E._animate(Z)&&E.disposeOnEnd&&n--}!function(E){if(E._registeredForLateAnimationBindings.length){for(let H=0;H<E._registeredForLateAnimationBindings.length;H++){const d=E._registeredForLateAnimationBindings.data[H];for(const E in d._lateAnimationHolders){const H=d._lateAnimationHolders[E],Z=H.animations[0],I=H.originalValue;if(void 0===I||null===I)continue;const g=n.b.AllowMatrixDecomposeForInterpolation&&I.m;let l=d[E];if(g)l=V(H);else if(void 0!==I.w)l=C(H,l||r.Quaternion.Identity());else{let E=0,d=1;const g=Z&&Z._animationState.loopMode===n.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(H.totalWeight<1)l=g?I.clone?I.clone():I:Z&&I.scale?I.scale(1-H.totalWeight):Z?I*(1-H.totalWeight):I.clone?I.clone():I;else if(Z){d=H.totalWeight;const n=Z.weight/d;l=1!==n?Z.currentValue.scale?Z.currentValue.scale(n):Z.currentValue*n:Z.currentValue,g&&(l.addToRef?l.addToRef(I,l):l+=I),E=1}for(let n=E;n<H.animations.length;n++){const E=H.animations[n],Z=E.weight/d;Z&&(E.currentValue.scaleAndAddToRef?E.currentValue.scaleAndAddToRef(Z,l):l+=E.currentValue*Z)}for(let n=0;n<H.additiveAnimations.length;n++){const E=H.additiveAnimations[n],d=E.weight;d&&(E.currentValue.scaleAndAddToRef?E.currentValue.scaleAndAddToRef(d,l):l+=E.currentValue*d)}}d[E]=l}d._lateAnimationHolders={}}E._registeredForLateAnimationBindings.reset()}}(this)},w.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((E,H)=>E.playOrder-H.playOrder))},w.prototype.beginWeightedAnimation=function(E,H,d){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,Z=arguments.length>4?arguments[4]:void 0,I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,l=arguments.length>7?arguments[7]:void 0,r=arguments.length>8?arguments[8]:void 0,t=arguments.length>9?arguments[9]:void 0,S=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const M=this.beginAnimation(E,H,d,Z,I,g,l,!1,r,t,S);return M.weight=n,M},w.prototype.beginAnimation=function(E,H,d,n){let Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,I=arguments.length>5?arguments[5]:void 0,g=arguments.length>6?arguments[6]:void 0,l=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],r=arguments.length>8?arguments[8]:void 0,t=arguments.length>9?arguments[9]:void 0,S=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(Z<0){const E=H;H=d,d=E,Z=-Z}H>d&&(Z=-Z),l&&this.stopAnimation(E,void 0,r),g||(g=new M(this,E,H,d,n,Z,I,void 0,t,S));const V=!r||r(E);if(E.animations&&V&&g.appendAnimations(E,E.animations),E.getAnimatables){const S=E.getAnimatables();for(let E=0;E<S.length;E++)this.beginAnimation(S[E],H,d,n,Z,I,g,l,r,t)}return g.reset(),g},w.prototype.beginHierarchyAnimation=function(E,H,d,n,Z){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,l=arguments.length>7?arguments[7]:void 0,r=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],t=arguments.length>9?arguments[9]:void 0,S=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const M=E.getDescendants(H),V=[];V.push(this.beginAnimation(E,d,n,Z,I,g,l,r,t,void 0,S));for(const C of M)V.push(this.beginAnimation(C,d,n,Z,I,g,l,r,t,void 0,S));return V},w.prototype.beginDirectAnimation=function(E,H,d,n,Z){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(I<0){const E=d;d=n,n=E,I=-I}return d>n&&(I=-I),new M(this,E,d,n,Z,I,arguments.length>6?arguments[6]:void 0,H,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},w.prototype.beginDirectHierarchyAnimation=function(E,H,d,n,Z,I,g,l,r){let t=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const S=E.getDescendants(H),M=[];M.push(this.beginDirectAnimation(E,d,n,Z,I,g,l,r,t));for(const V of S)M.push(this.beginDirectAnimation(V,d,n,Z,I,g,l,r,t));return M},w.prototype.getAnimatableByTarget=function(E){for(let H=0;H<this._activeAnimatables.length;H++)if(this._activeAnimatables[H].target===E)return this._activeAnimatables[H];return null},w.prototype.getAllAnimatablesByTarget=function(E){const H=[];for(let d=0;d<this._activeAnimatables.length;d++)this._activeAnimatables[d].target===E&&H.push(this._activeAnimatables[d]);return H},w.prototype.stopAnimation=function(E,H,d){const n=this.getAllAnimatablesByTarget(E);for(const Z of n)Z.stop(H,d)},w.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let E=0;E<this._activeAnimatables.length;E++)this._activeAnimatables[E].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const E of this.animationGroups)E.stop()});class L{getClassName(){return"TargetedAnimation"}serialize(){const E={};return E.animation=this.animation.serialize(),E.targetId=this.target.id,E}}class D{get mask(){return this._mask}set mask(E){this._mask!==E&&(this._mask=E,this.syncWithMask(!0))}syncWithMask(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||E){this._numActiveAnimatables=0;for(let E=0;E<this._animatables.length;++E){const H=this._animatables[E];!this.mask||this.mask.disabled||this.mask.retainsTarget(H.target.name)?(this._numActiveAnimatables++,H.paused&&H.restart()):H.paused||H.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let E=0;E<this._animatables.length;++E){const H=this._animatables[E];this.mask.retainsTarget(H.target.name)||(H.stop(),this._animatables.splice(E,1),--E)}for(let E=0;E<this._targetedAnimations.length;E++){const H=this._targetedAnimations[E];this.mask.retainsTarget(H.target.name)||(this._targetedAnimations.splice(E,1),--E)}}}get from(){return this._from}set from(E){if(this._from!==E){this._from=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].fromFrame=this._from}}}get to(){return this._to}set to(E){if(this._to!==E){this._to=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(E){if(this._speedRatio!==E){this._speedRatio=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(E){if(this._loopAnimation!==E){this._loopAnimation=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(E){if(this._isAdditive!==E){this._isAdditive=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(E){this._weight!==E&&(this._weight=E,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(E){if(this._playOrder!==E&&(this._playOrder=E,this._animatables.length>0)){for(let E=0;E<this._animatables.length;E++)this._animatables[E].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(E){if(this._enableBlending!==E&&(this._enableBlending=E,null!==E))for(let H=0;H<this._targetedAnimations.length;++H)this._targetedAnimations[H].animation.enableBlending=E}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(E){if(this._blendingSpeed!==E&&(this._blendingSpeed=E,null!==E))for(let H=0;H<this._targetedAnimations.length;++H)this._targetedAnimations[H].animation.blendingSpeed=E}getLength(E,H){E=E??this._from;return((H=H??this._to)-E)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(E){let H=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],d=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3?arguments[3]:void 0;if(0===E.length)return null;n=n??E[0].weight;let Z=Number.MAX_VALUE,I=-Number.MAX_VALUE;if(d)for(const l of E)l.from<Z&&(Z=l.from),l.to>I&&(I=l.to);const g=new D(E[0].name+"_merged",E[0]._scene,n);for(const l of E){d&&l.normalize(Z,I);for(const E of l.targetedAnimations)g.addTargetedAnimation(E.animation,E.target);H&&l.dispose()}return g}constructor(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=E,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new Z.e,this.onAnimationLoopObservable=new Z.e,this.onAnimationGroupLoopObservable=new Z.e,this.onAnimationGroupEndObservable=new Z.e,this.onAnimationGroupPauseObservable=new Z.e,this.onAnimationGroupPlayObservable=new Z.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=H||I.b.LastCreatedScene,this._weight=d,this._playOrder=n,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(E,H){const d=new L;d.animation=E,d.target=H;const n=E.getKeys();return this._from>n[0].frame&&(this._from=n[0].frame),this._to<n[n.length-1].frame&&(this._to=n[n.length-1].frame),null!==this._enableBlending&&(E.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(E.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(d),this._shouldStart=!0,d}removeTargetedAnimation(E){for(let H=this._targetedAnimations.length-1;H>-1;H--){this._targetedAnimations[H].animation===E&&this._targetedAnimations.splice(H,1)}}normalize(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==E&&(E=this._from),null==H&&(H=this._to);for(let d=0;d<this._targetedAnimations.length;d++){const n=this._targetedAnimations[d].animation.getKeys(),Z=n[0],I=n[n.length-1];if(Z.frame>E){const H={frame:E,value:Z.value,inTangent:Z.inTangent,outTangent:Z.outTangent,interpolation:Z.interpolation};n.splice(0,0,H)}if(I.frame<H){const E={frame:H,value:I.value,inTangent:I.inTangent,outTangent:I.outTangent,interpolation:I.interpolation};n.push(E)}}return this._from=E,this._to=H,this}_processLoop(E,H,d){E.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(H),this._animationLoopFlags[d]||(this._animationLoopFlags[d]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0],H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,d=arguments.length>2?arguments[2]:void 0,n=arguments.length>3?arguments[3]:void 0,Z=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=E,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let I=0;I<this._targetedAnimations.length;I++){const g=this._targetedAnimations[I],l=this._scene.beginDirectAnimation(g.target,[g.animation],void 0!==d?d:this._from,void 0!==n?n:this._to,E,H,void 0,void 0,void 0!==Z?Z:this._isAdditive);l.weight=this._weight,l.playOrder=this._playOrder,l.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(g),this._checkAnimationGroupEnded(l)},this._processLoop(l,g,I),this._animatables.push(l)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=H,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let E=0;E<this._animatables.length;E++){this._animatables[E].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(E){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==E&&(this.loopAnimation=E),this.restart()):(this.stop(),this.start(E,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].reset()}return this}restart(){if(!this._isStarted)return this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const H=this._animatables.slice();for(let n=0;n<H.length;n++)H[n].stop(void 0,void 0,!0,E);let d=0;for(let n=0;n<this._scene._activeAnimatables.length;n++){const H=this._scene._activeAnimatables[n];H._runtimeAnimations.length>0?this._scene._activeAnimatables[d++]=H:E&&this._checkAnimationGroupEnded(H,E)}return this._scene._activeAnimatables.length=d,this._isStarted=!1,this}setWeightForAllAnimatables(E){for(let H=0;H<this._animatables.length;H++){this._animatables[H].weight=E}return this}syncAllAnimationsWith(E){for(let H=0;H<this._animatables.length;H++){this._animatables[H].syncWith(E)}return this}goToFrame(E){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let d=0;d<this._animatables.length;d++){this._animatables[d].goToFrame(E,H)}return this}getCurrentFrame(){var E;return(null===(E=this.animatables[0])||void 0===E?void 0:E.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const E=this._scene.animationGroups.indexOf(this);if(E>-1&&this._scene.animationGroups.splice(E,1),this._parentContainer){const E=this._parentContainer.animationGroups.indexOf(this);E>-1&&this._parentContainer.animationGroups.splice(E,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(E){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const d=this._animatables.indexOf(E);d>-1&&this._animatables.splice(d,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,H||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(E,H){let d=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=new D(E||this.name,this._scene,this._weight,this._playOrder);n._from=this.from,n._to=this.to,n._speedRatio=this.speedRatio,n._loopAnimation=this.loopAnimation,n._isAdditive=this.isAdditive,n._enableBlending=this.enableBlending,n._blendingSpeed=this.blendingSpeed,n.metadata=this.metadata,n.mask=this.mask;for(const Z of this._targetedAnimations)n.addTargetedAnimation(d?Z.animation.clone():Z.animation,H?H(Z.target):Z.target);return n}serialize(){const E={};E.name=this.name,E.from=this.from,E.to=this.to,E.speedRatio=this.speedRatio,E.loopAnimation=this.loopAnimation,E.isAdditive=this.isAdditive,E.weight=this.weight,E.playOrder=this.playOrder,E.enableBlending=this.enableBlending,E.blendingSpeed=this.blendingSpeed,E.targetedAnimations=[];for(let H=0;H<this.targetedAnimations.length;H++){const d=this.targetedAnimations[H];E.targetedAnimations[H]=d.serialize()}return g.e&&g.e.HasTags(this)&&(E.tags=g.e.GetTags(this)),this.metadata&&(E.metadata=this.metadata),E}static Parse(E,H){const d=new D(E.name,H,E.weight,E.playOrder);for(let Z=0;Z<E.targetedAnimations.length;Z++){const I=E.targetedAnimations[Z],g=n.b.Parse(I.animation),l=I.targetId;if("influence"===I.animation.property){const E=H.getMorphTargetById(l);E&&d.addTargetedAnimation(g,E)}else{const E=H.getNodeById(l);null!=E&&d.addTargetedAnimation(g,E)}}return g.e&&g.e.AddTagsTo(d,E.tags),null!==E.from&&null!==E.to&&d.normalize(E.from,E.to),void 0!==E.speedRatio&&(d._speedRatio=E.speedRatio),void 0!==E.loopAnimation&&(d._loopAnimation=E.loopAnimation),void 0!==E.isAdditive&&(d._isAdditive=E.isAdditive),void 0!==E.weight&&(d._weight=E.weight),void 0!==E.playOrder&&(d._playOrder=E.playOrder),void 0!==E.enableBlending&&(d._enableBlending=E.enableBlending),void 0!==E.blendingSpeed&&(d._blendingSpeed=E.blendingSpeed),void 0!==E.metadata&&(d.metadata=E.metadata),d}static MakeAnimationAdditive(E,H,d){let Z;Z="object"===typeof H?H:{referenceFrame:H,range:d,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let I=E;Z.cloneOriginalAnimationGroup&&(I=E.clone(Z.clonedAnimationGroupName||I.name));const g=I.targetedAnimations;for(let l=0;l<g.length;l++){const E=g[l];E.animation=n.b.MakeAnimationAdditive(E.animation,Z)}if(I.isAdditive=!0,Z.clipKeys){let E=Number.MAX_VALUE,H=-Number.MAX_VALUE;const d=I.targetedAnimations;for(let n=0;n<d.length;n++){const Z=d[n].animation.getKeys();E>Z[0].frame&&(E=Z[0].frame),H<Z[Z.length-1].frame&&(H=Z[Z.length-1].frame)}I._from=E,I._to=H}return I}static ClipKeys(E,H,d,n,Z){const I=E.clone(n||E.name);return D.ClipKeysInPlace(I,H,d,Z)}static ClipKeysInPlace(E,H,d,n){return D.ClipInPlace(E,H,d,n,!1)}static ClipFrames(E,H,d,n,Z){const I=E.clone(n||E.name);return D.ClipFramesInPlace(I,H,d,Z)}static ClipFramesInPlace(E,H,d,n){return D.ClipInPlace(E,H,d,n,!0)}static ClipInPlace(E,H,d,n){let Z=arguments.length>4&&void 0!==arguments[4]&&arguments[4],I=Number.MAX_VALUE,g=-Number.MAX_VALUE;const l=E.targetedAnimations;for(let r=0;r<l.length;r++){const E=l[r],t=n?E.animation:E.animation.clone();Z&&(t.createKeyForFrame(H),t.createKeyForFrame(d));const S=t.getKeys(),M=[];let V=Number.MAX_VALUE;for(let n=0;n<S.length;n++){const E=S[n];if(!Z&&n>=H&&n<=d||Z&&E.frame>=H&&E.frame<=d){const H={frame:E.frame,value:E.value.clone?E.value.clone():E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation,lockedTangent:E.lockedTangent};V===Number.MAX_VALUE&&(V=H.frame),H.frame-=V,M.push(H)}}0!==M.length?(I>M[0].frame&&(I=M[0].frame),g<M[M.length-1].frame&&(g=M[M.length-1].frame),t.setKeys(M,!0),E.animation=t):(l.splice(r,1),r--)}return E._from=I,E._to=g,E}getClassName(){return"AnimationGroup"}toString(E){let H="Name: "+this.name;return H+=", type: "+this.getClassName(),E&&(H+=", from: "+this._from,H+=", to: "+this._to,H+=", isStarted: "+this._isStarted,H+=", speedRatio: "+this._speedRatio,H+=", targetedAnimations length: "+this._targetedAnimations.length,H+=", animatables length: "+this._animatables),H}}}}]);