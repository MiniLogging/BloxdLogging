"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[78],{16150:(Y,c,h)=>{h.r(c),h.d(c,{AnimationGroup:()=>D,TargetedAnimation:()=>d});var C=h(13395),E=h(12690),N=h(12722),Q=h(12914),b=h(14382),H=h(12869);class w{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(Y,c,h,E){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=c,this._target=Y,this._scene=h,this._host=E,this._activeTargets=[],c._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===C.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=H.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const Y={frame:0,value:this._minValue};this._keys.splice(0,0,Y)}if(this._target instanceof Array){let Y=0;for(const c of this._target)this._preparePath(c,Y),this._getOriginalValues(Y),Y++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const N=c.getEvents();if(N&&N.length>0)for(const C of N)this._events.push(C._clone());this._enableBlending=Y&&Y.animationPropertiesOverride?Y.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=this._animation.targetPropertyPath;if(h.length>1){let C=Y;for(let Y=0;Y<h.length-1;Y++){const c=h[Y];if(C=C[c],void 0===C)throw new Error(`Invalid property (${c}) in property path (${h.join(".")})`)}this._targetPath=h[h.length-1],this._activeTargets[c]=C}else this._targetPath=h[0],this._activeTargets[c]=Y;if(void 0===this._activeTargets[c][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${h.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let Y=0;for(const c of this._target)void 0!==this._originalValue[Y]&&this._setValue(c,this._activeTargets[Y],this._originalValue[Y],-1,Y),Y++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let Y=0;Y<this._events.length;Y++)this._events[Y].isDone=!1}isStopped(){return this._stopped}dispose(){const Y=this._animation.runtimeAnimations.indexOf(this);Y>-1&&this._animation.runtimeAnimations.splice(Y,1)}setValue(Y,c){if(this._targetIsArray)for(let h=0;h<this._target.length;h++){const C=this._target[h];this._setValue(C,this._activeTargets[h],Y,c,h)}else this._setValue(this._target,this._directTarget,Y,c,0)}_getOriginalValues(){let Y,c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const h=this._activeTargets[c];Y=h.getLocalMatrix&&"_matrix"===this._targetPath?h.getLocalMatrix():h[this._targetPath],Y&&Y.clone?this._originalValue[c]=Y.clone():this._originalValue[c]=Y}_registerTargetForLateAnimationBinding(Y,c){const h=Y.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(h),h._lateAnimationHolders||(h._lateAnimationHolders={}),h._lateAnimationHolders[Y.targetPath]||(h._lateAnimationHolders[Y.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:c}),Y.isAdditive?(h._lateAnimationHolders[Y.targetPath].additiveAnimations.push(Y),h._lateAnimationHolders[Y.targetPath].totalAdditiveWeight+=Y.weight):(h._lateAnimationHolders[Y.targetPath].animations.push(Y),h._lateAnimationHolders[Y.targetPath].totalWeight+=Y.weight)}_setValue(Y,c,h,E,N){if(this._currentActiveTarget=c,this._weight=E,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const Y=c[this._targetPath];Y.clone?this._originalBlendValue=Y.clone():this._originalBlendValue=Y}this._originalBlendValue.m?C.d.AllowMatrixDecomposeForInterpolation?this._currentValue?H.Matrix.DecomposeLerpToRef(this._originalBlendValue,h,this._blendingFactor,this._currentValue):this._currentValue=H.Matrix.DecomposeLerp(this._originalBlendValue,h,this._blendingFactor):this._currentValue?H.Matrix.LerpToRef(this._originalBlendValue,h,this._blendingFactor,this._currentValue):this._currentValue=H.Matrix.Lerp(this._originalBlendValue,h,this._blendingFactor):this._currentValue=C.d._UniversalLerp(this._originalBlendValue,h,this._blendingFactor);const E=Y&&Y.animationPropertiesOverride?Y.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=E}else this._currentValue?this._currentValue.N?this._currentValue.N(h):this._currentValue=h:null!==h&&void 0!==h&&h.clone?this._currentValue=h.clone():this._currentValue=h;-1!==E?this._registerTargetForLateAnimationBinding(this,this._originalValue[N]):this._animationState.loopMode===C.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[N],c[this._targetPath]):c[this._targetPath]=this._originalValue[N]+this._currentValue:c[this._targetPath]=this._currentValue,Y.xq&&Y.xq(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const h=this._animation.getKeys();Y<h[0].frame?Y=h[0].frame:Y>h[h.length-1].frame&&(Y=h[h.length-1].frame);const C=this._events;if(C.length)for(let N=0;N<C.length;N++)C[N].onlyOnce||(C[N].isDone=C[N].frame<Y);this._currentFrame=Y;const E=this._animation._interpolate(Y,this._animationState);this.setValue(E,c)}_prepareForSpeedRatioChange(Y){const c=this._previousElapsedTime*(this._animation.framePerSecond*Y)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-c}animate(Y,c,h,E,N){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const b=this._animation,H=b.targetPropertyPath;if(!H||H.length<1)return this._stopped=!0,!1;let w,W=!0;const q=this._events;let k=0;if(this._coreRuntimeAnimation)k=h-c,w=this._coreRuntimeAnimation.currentFrame,this._currentFrame=w,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let Q;(c<this._minFrame||c>this._maxFrame)&&(c=this._minFrame),(h<this._minFrame||h>this._maxFrame)&&(h=this._maxFrame),k=h-c;let H=Y*(b.framePerSecond*N)/1e3+this._absoluteFrameOffset,M=0,p=!1;const P=E&&this._animationState.loopMode===C.d.ANIMATIONLOOPMODE_YOYO;if(P){const Y=(H-c)/k,h=Math.sin(Y*Math.PI);H=Math.abs(h)*k+c;const C=h>=0?1:-1;this._yoyoDirection!==C&&(p=!0),this._yoyoDirection=C}if(this._previousElapsedTime=Y,this._previousAbsoluteFrame=H,!E&&h>=c&&(H>=k&&N>0||H<=0&&N<0))W=!1,M=b._getKeyValue(this._maxValue);else if(!E&&c>=h&&(H<=k&&N<0||H>=0&&N>0))W=!1,M=b._getKeyValue(this._minValue);else if(this._animationState.loopMode!==C.d.ANIMATIONLOOPMODE_CYCLE){const Y=h.toString()+c.toString();if(!this._offsetsCache[Y]){this._animationState.repeatCount=0,this._animationState.loopMode=C.d.ANIMATIONLOOPMODE_CYCLE;const E=b._interpolate(c,this._animationState),N=b._interpolate(h,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),b.dataType){case C.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[Y]=N-E;break;case C.d.ANIMATIONTYPE_QUATERNION:case C.d.ANIMATIONTYPE_VECTOR3:case C.d.ANIMATIONTYPE_VECTOR2:case C.d.ANIMATIONTYPE_SIZE:case C.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[Y]=N.Hh(E)}this._highLimitsCache[Y]=N}M=this._highLimitsCache[Y],Q=this._offsetsCache[Y]}if(void 0===Q)switch(b.dataType){case C.d.ANIMATIONTYPE_FLOAT:Q=0;break;case C.d.ANIMATIONTYPE_QUATERNION:Q=C.j;break;case C.d.ANIMATIONTYPE_VECTOR3:Q=C.t;break;case C.d.ANIMATIONTYPE_VECTOR2:Q=C.q;break;case C.d.ANIMATIONTYPE_SIZE:Q=C.n;break;case C.d.ANIMATIONTYPE_COLOR3:Q=C.e;break;case C.d.ANIMATIONTYPE_COLOR4:Q=C.i}if(this._host&&this._host.syncRoot){const Y=this._host.syncRoot;w=c+k*((Y.masterFrame-Y.fromFrame)/(Y.toFrame-Y.fromFrame))}else w=H>0&&c>h||H<0&&c<h?W&&0!==k?h+H%k:c:W&&0!==k?c+H%k:h;if(!P&&(N>0&&this.currentFrame>w||N<0&&this.currentFrame<w)||P&&p){this._onLoop();for(let Y=0;Y<q.length;Y++)q[Y].onlyOnce||(q[Y].isDone=!1);this._animationState.key=N>0?0:b.getKeys().length-1}this._currentFrame=w,this._animationState.repeatCount=0===k?0:H/k|0,this._animationState.highLimitValue=M,this._animationState.offsetValue=Q}const M=b._interpolate(w,this._animationState);if(this.setValue(M,Q),q.length)for(let C=0;C<q.length;C++)if(k>=0&&w>=q[C].frame&&q[C].frame>=c||k<0&&w<=q[C].frame&&q[C].frame<=c){const Y=q[C];Y.isDone||(Y.onlyOnce&&(q.splice(C,1),C--),Y.isDone=!0,Y.action(w))}return W||(this._stopped=!0),W}}var W=h(12709);class q{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(Y){this._weight=-1!==Y?Math.min(Math.max(Y,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(Y){for(let c=0;c<this._runtimeAnimations.length;c++){this._runtimeAnimations[c]._prepareForSpeedRatioChange(Y)}this._speedRatio=Y,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,N=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,b=arguments.length>6?arguments[6]:void 0,H=arguments.length>7?arguments[7]:void 0,w=arguments.length>8?arguments[8]:void 0,W=arguments.length>9&&void 0!==arguments[9]&&arguments[9],q=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=c,this.fromFrame=h,this.toFrame=C,this.loopAnimation=N,this.onAnimationEnd=b,this.onAnimationLoop=w,this.isAdditive=W,this.playOrder=q,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Dw=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new E.c,this.onAnimationLoopObservable=new E.c,this._scene=Y,H&&this.appendAnimations(c,H),this._speedRatio=Q,Y._activeAnimatables.push(this)}syncWith(Y){if(this._syncRoot=Y,Y){const Y=this._scene._activeAnimatables.indexOf(this);Y>-1&&(this._scene._activeAnimatables.splice(Y,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(Y,c){for(let h=0;h<c.length;h++){const C=c[h],E=new w(Y,C,this._scene,this);E._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(E)}}getAnimationByTargetProperty(Y){const c=this._runtimeAnimations;for(let h=0;h<c.length;h++)if(c[h].animation.targetProperty===Y)return c[h].animation;return null}getRuntimeAnimationByTargetProperty(Y){const c=this._runtimeAnimations;for(let h=0;h<c.length;h++)if(c[h].animation.targetProperty===Y)return c[h];return null}reset(){const Y=this._runtimeAnimations;for(let c=0;c<Y.length;c++)Y[c].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(Y){const c=this._runtimeAnimations;for(let h=0;h<c.length;h++)c[h].animation.enableBlending=!0,c[h].animation.blendingSpeed=Y}disableBlending(){const Y=this._runtimeAnimations;for(let c=0;c<Y.length;c++)Y[c].animation.enableBlending=!1}goToFrame(Y){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const h=this._runtimeAnimations;if(h[0]){const c=h[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??h[0].currentFrame;const C=0===this.speedRatio?0:(Y-this._frameToSyncFromJump)/c*1e3/this.speedRatio;this._manualJumpDelay=-C}for(let C=0;C<h.length;C++)h[C].goToFrame(Y,c?this._weight:-1);this._goToFrame=Y}get paused(){return this.Dw}pause(){this.Dw||(this.Dw=!0)}restart(){this.Dw=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(Y,c){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Y||c){const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){const N=this._runtimeAnimations;for(let h=N.length-1;h>=0;h--){const C=N[h];Y&&C.animation.name!=Y||(c&&!c(C.target)||(C.dispose(),N.splice(h,1)))}0==N.length&&(h||this._scene._activeAnimatables.splice(E,1),C||this._raiseOnAnimationEnd())}}else{const Y=this._scene._activeAnimatables.indexOf(this);if(Y>-1){h||this._scene._activeAnimatables.splice(Y,1);const c=this._runtimeAnimations;for(let Y=0;Y<c.length;Y++)c[Y].dispose();this._runtimeAnimations.length=0,C||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((Y=>{this.onAnimationEndObservable.add((()=>{Y(this)}),void 0,void 0,this,!0)}))}_animate(Y){if(this.Dw)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=Y),!0;if(null===this._localDelayOffset?(this._localDelayOffset=Y,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=Y-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let c=!1;const h=this._runtimeAnimations;let C;for(C=0;C<h.length;C++){const E=h[C].animate(Y-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);c=c||E}if(this.animationStarted=c,!c){if(this.disposeOnEnd)for(C=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(C,1),C=0;C<h.length;C++)h[C].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return c}}function k(Y){if(0===Y.totalWeight&&0===Y.totalAdditiveWeight)return Y.originalValue;let c=1;const h=H.TmpVectors.bh[0],C=H.TmpVectors.bh[1],E=H.TmpVectors.Quaternion[0];let N=0;const Q=Y.animations[0],b=Y.originalValue;let w=1,W=!1;if(Y.totalWeight<1)w=1-Y.totalWeight,b.decompose(C,E,h);else{if(N=1,c=Y.totalWeight,w=Q.weight/c,1==w){if(!Y.totalAdditiveWeight)return Q.currentValue;W=!0}Q.currentValue.decompose(C,E,h)}if(!W){C.scaleInPlace(w),h.scaleInPlace(w),E.scaleInPlace(w);for(let Q=N;Q<Y.animations.length;Q++){const N=Y.animations[Q];if(0===N.weight)continue;w=N.weight/c;const b=H.TmpVectors.bh[2],W=H.TmpVectors.bh[3],q=H.TmpVectors.Quaternion[1];N.currentValue.decompose(W,q,b),W.scaleAndAddToRef(w,C),q.scaleAndAddToRef(H.Quaternion.Dot(E,q)>0?w:-w,E),b.scaleAndAddToRef(w,h)}E.normalize()}for(let k=0;k<Y.additiveAnimations.length;k++){const c=Y.additiveAnimations[k];if(0===c.weight)continue;const N=H.TmpVectors.bh[2],Q=H.TmpVectors.bh[3],b=H.TmpVectors.Quaternion[1];c.currentValue.decompose(Q,b,N),Q.multiplyToRef(C,Q),H.bh.LerpToRef(C,Q,c.weight,C),E.multiplyToRef(b,b),H.Quaternion.SlerpToRef(E,b,c.weight,E),N.scaleAndAddToRef(c.weight,h)}const q=Q?Q._animationState.workValue:H.TmpVectors.Matrix[0].clone();return H.Matrix.ComposeToRef(C,E,h,q),q}function M(Y,c){if(0===Y.totalWeight&&0===Y.totalAdditiveWeight)return c;const h=Y.animations[0],C=Y.originalValue;let E=c;if(0===Y.totalWeight&&Y.totalAdditiveWeight>0)E.N(C);else if(1===Y.animations.length){if(H.Quaternion.SlerpToRef(C,h.currentValue,Math.min(1,Y.totalWeight),E),0===Y.totalAdditiveWeight)return E}else if(Y.animations.length>1){let h,N,Q=1;if(Y.totalWeight<1){const c=1-Y.totalWeight;h=[],N=[],h.push(C),N.push(c)}else{if(2===Y.animations.length&&(H.Quaternion.SlerpToRef(Y.animations[0].currentValue,Y.animations[1].currentValue,Y.animations[1].weight/Y.totalWeight,c),0===Y.totalAdditiveWeight))return c;h=[],N=[],Q=Y.totalWeight}for(let c=0;c<Y.animations.length;c++){const C=Y.animations[c];h.push(C.currentValue),N.push(C.weight/Q)}let b=0;for(let Y=0;Y<h.length;)Y?(b+=N[Y],H.Quaternion.SlerpToRef(E,h[Y],N[Y]/b,E),Y++):(H.Quaternion.SlerpToRef(h[Y],h[Y+1],N[Y+1]/(N[Y]+N[Y+1]),c),E=c,b=N[Y]+N[Y+1],Y+=2)}for(let N=0;N<Y.additiveAnimations.length;N++){const c=Y.additiveAnimations[N];0!==c.weight&&(E.multiplyToRef(c.currentValue,H.TmpVectors.Quaternion[0]),H.Quaternion.SlerpToRef(E,H.TmpVectors.Quaternion[0],c.weight,E))}return E}var p,P,y=h(13110);p=y.e,(P=b.d)&&(P.prototype.copyAnimationRange=function(Y,c,h){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new C.d(this.name,"_matrix",Y.animations[0].framePerSecond,C.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Q=Y.animations[0].getRange(c);if(!Q)return!1;const b=Q.from,H=Q.to,w=Y.animations[0].getKeys(),W=Y.length,q=Y.getParent(),k=this.getParent(),M=E&&q&&W&&this.length&&W!==this.length,p=M&&k&&q?k.length/q.length:1,P=E&&!k&&N&&(1!==N.x||1!==N.y||1!==N.z),y=this.animations[0].getKeys();let d,D,T;for(let C=0,e=w.length;C<e;C++)d=w[C],d.frame>=b&&d.frame<=H&&(E?(T=d.value.clone(),M?(D=T.getTranslation(),T.setTranslation(D.scaleInPlace(p))):P&&N?(D=T.getTranslation(),T.setTranslation(D.multiplyInPlace(N))):T=d.value):T=d.value,y.push({frame:d.frame+h,value:T}));return this.animations[0].createRange(c,b+h,H+h),!0}),p&&(p.prototype._animate=function(Y){if(!this.animationsEnabled)return;const c=W.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=c}this.deltaTime=void 0!==Y?Y:this.useConstantAnimationDeltaTime?16:(c-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=c;const h=this._activeAnimatables;if(0===h.length)return;this._animationTime+=this.deltaTime;const E=this._animationTime;for(let C=0;C<h.length;C++){const Y=h[C];!Y._animate(E)&&Y.disposeOnEnd&&C--}!function(Y){if(Y._registeredForLateAnimationBindings.length){for(let c=0;c<Y._registeredForLateAnimationBindings.length;c++){const h=Y._registeredForLateAnimationBindings.data[c];for(const Y in h._lateAnimationHolders){const c=h._lateAnimationHolders[Y],E=c.animations[0],N=c.originalValue;if(void 0===N||null===N)continue;const Q=C.d.AllowMatrixDecomposeForInterpolation&&N.m;let b=h[Y];if(Q)b=k(c);else if(void 0!==N.w)b=M(c,b||H.Quaternion.Identity());else{let Y=0,h=1;const Q=E&&E._animationState.loopMode===C.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(c.totalWeight<1)b=Q?N.clone?N.clone():N:E&&N.scale?N.scale(1-c.totalWeight):E?N*(1-c.totalWeight):N.clone?N.clone():N;else if(E){h=c.totalWeight;const C=E.weight/h;b=1!==C?E.currentValue.scale?E.currentValue.scale(C):E.currentValue*C:E.currentValue,Q&&(b.addToRef?b.addToRef(N,b):b+=N),Y=1}for(let C=Y;C<c.animations.length;C++){const Y=c.animations[C],E=Y.weight/h;E&&(Y.currentValue.scaleAndAddToRef?Y.currentValue.scaleAndAddToRef(E,b):b+=Y.currentValue*E)}for(let C=0;C<c.additiveAnimations.length;C++){const Y=c.additiveAnimations[C],h=Y.weight;h&&(Y.currentValue.scaleAndAddToRef?Y.currentValue.scaleAndAddToRef(h,b):b+=Y.currentValue*h)}}h[Y]=b}h._lateAnimationHolders={}}Y._registeredForLateAnimationBindings.reset()}}(this)},p.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((Y,c)=>Y.playOrder-c.playOrder))},p.prototype.beginWeightedAnimation=function(Y,c,h){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,E=arguments.length>4?arguments[4]:void 0,N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Q=arguments.length>6?arguments[6]:void 0,b=arguments.length>7?arguments[7]:void 0,H=arguments.length>8?arguments[8]:void 0,w=arguments.length>9?arguments[9]:void 0,W=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const q=this.beginAnimation(Y,c,h,E,N,Q,b,!1,H,w,W);return q.weight=C,q},p.prototype.beginAnimation=function(Y,c,h,C){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,N=arguments.length>5?arguments[5]:void 0,Q=arguments.length>6?arguments[6]:void 0,b=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],H=arguments.length>8?arguments[8]:void 0,w=arguments.length>9?arguments[9]:void 0,W=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(E<0){const Y=c;c=h,h=Y,E=-E}c>h&&(E=-E),b&&this.stopAnimation(Y,void 0,H),Q||(Q=new q(this,Y,c,h,C,E,N,void 0,w,W));const k=!H||H(Y);if(Y.animations&&k&&Q.appendAnimations(Y,Y.animations),Y.getAnimatables){const W=Y.getAnimatables();for(let Y=0;Y<W.length;Y++)this.beginAnimation(W[Y],c,h,C,E,N,Q,b,H,w)}return Q.reset(),Q},p.prototype.beginHierarchyAnimation=function(Y,c,h,C,E){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Q=arguments.length>6?arguments[6]:void 0,b=arguments.length>7?arguments[7]:void 0,H=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],w=arguments.length>9?arguments[9]:void 0,W=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const q=Y.getDescendants(c),k=[];k.push(this.beginAnimation(Y,h,C,E,N,Q,b,H,w,void 0,W));for(const M of q)k.push(this.beginAnimation(M,h,C,E,N,Q,b,H,w,void 0,W));return k},p.prototype.beginDirectAnimation=function(Y,c,h,C,E){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(N<0){const Y=h;h=C,C=Y,N=-N}return h>C&&(N=-N),new q(this,Y,h,C,E,N,arguments.length>6?arguments[6]:void 0,c,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},p.prototype.beginDirectHierarchyAnimation=function(Y,c,h,C,E,N,Q,b,H){let w=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const W=Y.getDescendants(c),q=[];q.push(this.beginDirectAnimation(Y,h,C,E,N,Q,b,H,w));for(const k of W)q.push(this.beginDirectAnimation(k,h,C,E,N,Q,b,H,w));return q},p.prototype.getAnimatableByTarget=function(Y){for(let c=0;c<this._activeAnimatables.length;c++)if(this._activeAnimatables[c].target===Y)return this._activeAnimatables[c];return null},p.prototype.getAllAnimatablesByTarget=function(Y){const c=[];for(let h=0;h<this._activeAnimatables.length;h++)this._activeAnimatables[h].target===Y&&c.push(this._activeAnimatables[h]);return c},p.prototype.stopAnimation=function(Y,c,h){const C=this.getAllAnimatablesByTarget(Y);for(const E of C)E.stop(c,h)},p.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let Y=0;Y<this._activeAnimatables.length;Y++)this._activeAnimatables[Y].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const Y of this.animationGroups)Y.stop()});class d{getClassName(){return"TargetedAnimation"}serialize(){const Y={};return Y.animation=this.animation.serialize(),Y.targetId=this.target.id,Y}}class D{get mask(){return this._mask}set mask(Y){this._mask!==Y&&(this._mask=Y,this.syncWithMask(!0))}syncWithMask(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||Y){this._numActiveAnimatables=0;for(let Y=0;Y<this._animatables.length;++Y){const c=this._animatables[Y];!this.mask||this.mask.disabled||this.mask.retainsTarget(c.target.name)?(this._numActiveAnimatables++,c.paused&&c.restart()):c.paused||c.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let Y=0;Y<this._animatables.length;++Y){const c=this._animatables[Y];this.mask.retainsTarget(c.target.name)||(c.stop(),this._animatables.splice(Y,1),--Y)}for(let Y=0;Y<this._targetedAnimations.length;Y++){const c=this._targetedAnimations[Y];this.mask.retainsTarget(c.target.name)||(this._targetedAnimations.splice(Y,1),--Y)}}}get from(){return this._from}set from(Y){if(this._from!==Y){this._from=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].fromFrame=this._from}}}get to(){return this._to}set to(Y){if(this._to!==Y){this._to=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(Y){if(this._speedRatio!==Y){this._speedRatio=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(Y){if(this._loopAnimation!==Y){this._loopAnimation=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(Y){if(this._isAdditive!==Y){this._isAdditive=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(Y){this._weight!==Y&&(this._weight=Y,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(Y){if(this._playOrder!==Y&&(this._playOrder=Y,this._animatables.length>0)){for(let Y=0;Y<this._animatables.length;Y++)this._animatables[Y].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(Y){if(this._enableBlending!==Y&&(this._enableBlending=Y,null!==Y))for(let c=0;c<this._targetedAnimations.length;++c)this._targetedAnimations[c].animation.enableBlending=Y}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(Y){if(this._blendingSpeed!==Y&&(this._blendingSpeed=Y,null!==Y))for(let c=0;c<this._targetedAnimations.length;++c)this._targetedAnimations[c].animation.blendingSpeed=Y}getLength(Y,c){Y=Y??this._from;return((c=c??this._to)-Y)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(Y){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=arguments.length>3?arguments[3]:void 0;if(0===Y.length)return null;C=C??Y[0].weight;let E=Number.MAX_VALUE,N=-Number.MAX_VALUE;if(h)for(const b of Y)b.from<E&&(E=b.from),b.to>N&&(N=b.to);const Q=new D(Y[0].name+"_merged",Y[0]._scene,C);for(const b of Y){h&&b.normalize(E,N);for(const Y of b.targetedAnimations)Q.addTargetedAnimation(Y.animation,Y.target);c&&b.dispose()}return Q}constructor(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=Y,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new E.c,this.onAnimationLoopObservable=new E.c,this.onAnimationGroupLoopObservable=new E.c,this.onAnimationGroupEndObservable=new E.c,this.onAnimationGroupPauseObservable=new E.c,this.onAnimationGroupPlayObservable=new E.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=c||N.d.LastCreatedScene,this._weight=h,this._playOrder=C,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(Y,c){const h=new d;h.animation=Y,h.target=c;const C=Y.getKeys();return this._from>C[0].frame&&(this._from=C[0].frame),this._to<C[C.length-1].frame&&(this._to=C[C.length-1].frame),null!==this._enableBlending&&(Y.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(Y.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(h),this._shouldStart=!0,h}removeTargetedAnimation(Y){for(let c=this._targetedAnimations.length-1;c>-1;c--){this._targetedAnimations[c].animation===Y&&this._targetedAnimations.splice(c,1)}}normalize(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==Y&&(Y=this._from),null==c&&(c=this._to);for(let h=0;h<this._targetedAnimations.length;h++){const C=this._targetedAnimations[h].animation.getKeys(),E=C[0],N=C[C.length-1];if(E.frame>Y){const c={frame:Y,value:E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation};C.splice(0,0,c)}if(N.frame<c){const Y={frame:c,value:N.value,inTangent:N.inTangent,outTangent:N.outTangent,interpolation:N.interpolation};C.push(Y)}}return this._from=Y,this._to=c,this}_processLoop(Y,c,h){Y.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(c),this._animationLoopFlags[h]||(this._animationLoopFlags[h]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0],c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0,C=arguments.length>3?arguments[3]:void 0,E=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=Y,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let N=0;N<this._targetedAnimations.length;N++){const Q=this._targetedAnimations[N],b=this._scene.beginDirectAnimation(Q.target,[Q.animation],void 0!==h?h:this._from,void 0!==C?C:this._to,Y,c,void 0,void 0,void 0!==E?E:this._isAdditive);b.weight=this._weight,b.playOrder=this._playOrder,b.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Q),this._checkAnimationGroupEnded(b)},this._processLoop(b,Q,N),this._animatables.push(b)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=c,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(Y){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==Y&&(this.loopAnimation=Y),this.restart()):(this.stop(),this.start(Y,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].reset()}return this}restart(){if(!this._isStarted)return this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const c=this._animatables.slice();for(let C=0;C<c.length;C++)c[C].stop(void 0,void 0,!0,Y);let h=0;for(let C=0;C<this._scene._activeAnimatables.length;C++){const c=this._scene._activeAnimatables[C];c._runtimeAnimations.length>0?this._scene._activeAnimatables[h++]=c:Y&&this._checkAnimationGroupEnded(c,Y)}return this._scene._activeAnimatables.length=h,this._isStarted=!1,this}setWeightForAllAnimatables(Y){for(let c=0;c<this._animatables.length;c++){this._animatables[c].weight=Y}return this}syncAllAnimationsWith(Y){for(let c=0;c<this._animatables.length;c++){this._animatables[c].syncWith(Y)}return this}goToFrame(Y){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let h=0;h<this._animatables.length;h++){this._animatables[h].goToFrame(Y,c)}return this}getCurrentFrame(){var Y;return(null===(Y=this.animatables[0])||void 0===Y?void 0:Y.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const Y=this._scene.animationGroups.indexOf(this);if(Y>-1&&this._scene.animationGroups.splice(Y,1),this._parentContainer){const Y=this._parentContainer.animationGroups.indexOf(this);Y>-1&&this._parentContainer.animationGroups.splice(Y,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(Y){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const h=this._animatables.indexOf(Y);h>-1&&this._animatables.splice(h,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,c||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(Y,c){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const C=new D(Y||this.name,this._scene,this._weight,this._playOrder);C._from=this.from,C._to=this.to,C._speedRatio=this.speedRatio,C._loopAnimation=this.loopAnimation,C._isAdditive=this.isAdditive,C._enableBlending=this.enableBlending,C._blendingSpeed=this.blendingSpeed,C.metadata=this.metadata,C.mask=this.mask;for(const E of this._targetedAnimations)C.addTargetedAnimation(h?E.animation.clone():E.animation,c?c(E.target):E.target);return C}serialize(){const Y={};Y.name=this.name,Y.from=this.from,Y.to=this.to,Y.speedRatio=this.speedRatio,Y.loopAnimation=this.loopAnimation,Y.isAdditive=this.isAdditive,Y.weight=this.weight,Y.playOrder=this.playOrder,Y.enableBlending=this.enableBlending,Y.blendingSpeed=this.blendingSpeed,Y.targetedAnimations=[];for(let c=0;c<this.targetedAnimations.length;c++){const h=this.targetedAnimations[c];Y.targetedAnimations[c]=h.serialize()}return Q.d&&Q.d.HasTags(this)&&(Y.tags=Q.d.GetTags(this)),this.metadata&&(Y.metadata=this.metadata),Y}static Parse(Y,c){const h=new D(Y.name,c,Y.weight,Y.playOrder);for(let E=0;E<Y.targetedAnimations.length;E++){const N=Y.targetedAnimations[E],Q=C.d.Parse(N.animation),b=N.targetId;if("influence"===N.animation.property){const Y=c.getMorphTargetById(b);Y&&h.addTargetedAnimation(Q,Y)}else{const Y=c.getNodeById(b);null!=Y&&h.addTargetedAnimation(Q,Y)}}return Q.d&&Q.d.AddTagsTo(h,Y.tags),null!==Y.from&&null!==Y.to&&h.normalize(Y.from,Y.to),void 0!==Y.speedRatio&&(h._speedRatio=Y.speedRatio),void 0!==Y.loopAnimation&&(h._loopAnimation=Y.loopAnimation),void 0!==Y.isAdditive&&(h._isAdditive=Y.isAdditive),void 0!==Y.weight&&(h._weight=Y.weight),void 0!==Y.playOrder&&(h._playOrder=Y.playOrder),void 0!==Y.enableBlending&&(h._enableBlending=Y.enableBlending),void 0!==Y.blendingSpeed&&(h._blendingSpeed=Y.blendingSpeed),void 0!==Y.metadata&&(h.metadata=Y.metadata),h}static MakeAnimationAdditive(Y,c,h){let E;E="object"===typeof c?c:{referenceFrame:c,range:h,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let N=Y;E.cloneOriginalAnimationGroup&&(N=Y.clone(E.clonedAnimationGroupName||N.name));const Q=N.targetedAnimations;for(let b=0;b<Q.length;b++){const Y=Q[b];Y.animation=C.d.MakeAnimationAdditive(Y.animation,E)}if(N.isAdditive=!0,E.clipKeys){let Y=Number.MAX_VALUE,c=-Number.MAX_VALUE;const h=N.targetedAnimations;for(let C=0;C<h.length;C++){const E=h[C].animation.getKeys();Y>E[0].frame&&(Y=E[0].frame),c<E[E.length-1].frame&&(c=E[E.length-1].frame)}N._from=Y,N._to=c}return N}static ClipKeys(Y,c,h,C,E){const N=Y.clone(C||Y.name);return D.ClipKeysInPlace(N,c,h,E)}static ClipKeysInPlace(Y,c,h,C){return D.ClipInPlace(Y,c,h,C,!1)}static ClipFrames(Y,c,h,C,E){const N=Y.clone(C||Y.name);return D.ClipFramesInPlace(N,c,h,E)}static ClipFramesInPlace(Y,c,h,C){return D.ClipInPlace(Y,c,h,C,!0)}static ClipInPlace(Y,c,h,C){let E=arguments.length>4&&void 0!==arguments[4]&&arguments[4],N=Number.MAX_VALUE,Q=-Number.MAX_VALUE;const b=Y.targetedAnimations;for(let H=0;H<b.length;H++){const Y=b[H],w=C?Y.animation:Y.animation.clone();E&&(w.createKeyForFrame(c),w.createKeyForFrame(h));const W=w.getKeys(),q=[];let k=Number.MAX_VALUE;for(let C=0;C<W.length;C++){const Y=W[C];if(!E&&C>=c&&C<=h||E&&Y.frame>=c&&Y.frame<=h){const c={frame:Y.frame,value:Y.value.clone?Y.value.clone():Y.value,inTangent:Y.inTangent,outTangent:Y.outTangent,interpolation:Y.interpolation,lockedTangent:Y.lockedTangent};k===Number.MAX_VALUE&&(k=c.frame),c.frame-=k,q.push(c)}}0!==q.length?(N>q[0].frame&&(N=q[0].frame),Q<q[q.length-1].frame&&(Q=q[q.length-1].frame),w.setKeys(q,!0),Y.animation=w):(b.splice(H,1),H--)}return Y._from=N,Y._to=Q,Y}getClassName(){return"AnimationGroup"}toString(Y){let c="Name: "+this.name;return c+=", type: "+this.getClassName(),Y&&(c+=", from: "+this._from,c+=", to: "+this._to,c+=", isStarted: "+this._isStarted,c+=", speedRatio: "+this._speedRatio,c+=", targetedAnimations length: "+this._targetedAnimations.length,c+=", animatables length: "+this._animatables),c}}}}]);