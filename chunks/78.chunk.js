"use strict";(self.u4k1rqylno=self.u4k1rqylno||[]).push([[78],{14837:(e,E,H)=>{H.r(E),H.d(E,{AnimationGroup:()=>X,TargetedAnimation:()=>S});var N=H(12235),u=H(11541),z=H(11579),P=H(11780),M=H(13334),D=H(11738);class A{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(e,E,H,u){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=E,this._target=e,this._scene=H,this._host=u,this._activeTargets=[],E._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===N.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=D.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const e={frame:0,value:this._minValue};this._keys.splice(0,0,e)}if(this._target instanceof Array){let e=0;for(const E of this._target)this._preparePath(E,e),this._getOriginalValues(e),e++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const z=E.getEvents();if(z&&z.length>0)for(const N of z)this._events.push(N._clone());this._enableBlending=e&&e.animationPropertiesOverride?e.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=this._animation.targetPropertyPath;if(H.length>1){let N=e;for(let e=0;e<H.length-1;e++){const E=H[e];if(N=N[E],void 0===N)throw new Error(`Invalid property (${E}) in property path (${H.join(".")})`)}this._targetPath=H[H.length-1],this._activeTargets[E]=N}else this._targetPath=H[0],this._activeTargets[E]=e;if(void 0===this._activeTargets[E][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${H.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let e=0;for(const E of this._target)void 0!==this._originalValue[e]&&this._setValue(E,this._activeTargets[e],this._originalValue[e],-1,e),e++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let e=0;e<this._events.length;e++)this._events[e].isDone=!1}isStopped(){return this._stopped}dispose(){const e=this._animation.runtimeAnimations.indexOf(this);e>-1&&this._animation.runtimeAnimations.splice(e,1)}setValue(e,E){if(this._targetIsArray)for(let H=0;H<this._target.length;H++){const N=this._target[H];this._setValue(N,this._activeTargets[H],e,E,H)}else this._setValue(this._target,this._directTarget,e,E,0)}_getOriginalValues(){let e,E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const H=this._activeTargets[E];e=H.getLocalMatrix&&"_matrix"===this._targetPath?H.getLocalMatrix():H[this._targetPath],e&&e.clone?this._originalValue[E]=e.clone():this._originalValue[E]=e}_registerTargetForLateAnimationBinding(e,E){const H=e.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(H),H._lateAnimationHolders||(H._lateAnimationHolders={}),H._lateAnimationHolders[e.targetPath]||(H._lateAnimationHolders[e.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:E}),e.isAdditive?(H._lateAnimationHolders[e.targetPath].additiveAnimations.push(e),H._lateAnimationHolders[e.targetPath].totalAdditiveWeight+=e.weight):(H._lateAnimationHolders[e.targetPath].animations.push(e),H._lateAnimationHolders[e.targetPath].totalWeight+=e.weight)}_setValue(e,E,H,u,z){if(this._currentActiveTarget=E,this._weight=u,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const e=E[this._targetPath];e.clone?this._originalBlendValue=e.clone():this._originalBlendValue=e}this._originalBlendValue.m?N.b.AllowMatrixDecomposeForInterpolation?this._currentValue?D.Matrix.DecomposeLerpToRef(this._originalBlendValue,H,this._blendingFactor,this._currentValue):this._currentValue=D.Matrix.DecomposeLerp(this._originalBlendValue,H,this._blendingFactor):this._currentValue?D.Matrix.LerpToRef(this._originalBlendValue,H,this._blendingFactor,this._currentValue):this._currentValue=D.Matrix.Lerp(this._originalBlendValue,H,this._blendingFactor):this._currentValue=N.b._UniversalLerp(this._originalBlendValue,H,this._blendingFactor);const u=e&&e.animationPropertiesOverride?e.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=u}else this._currentValue?this._currentValue.P?this._currentValue.P(H):this._currentValue=H:null!==H&&void 0!==H&&H.clone?this._currentValue=H.clone():this._currentValue=H;-1!==u?this._registerTargetForLateAnimationBinding(this,this._originalValue[z]):this._animationState.loopMode===N.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[z],E[this._targetPath]):E[this._targetPath]=this._originalValue[z]+this._currentValue:E[this._targetPath]=this._currentValue,e.vA&&e.vA(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const H=this._animation.getKeys();e<H[0].frame?e=H[0].frame:e>H[H.length-1].frame&&(e=H[H.length-1].frame);const N=this._events;if(N.length)for(let z=0;z<N.length;z++)N[z].onlyOnce||(N[z].isDone=N[z].frame<e);this._currentFrame=e;const u=this._animation._interpolate(e,this._animationState);this.setValue(u,E)}_prepareForSpeedRatioChange(e){const E=this._previousElapsedTime*(this._animation.framePerSecond*e)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-E}animate(e,E,H,u,z){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const M=this._animation,D=M.targetPropertyPath;if(!D||D.length<1)return this._stopped=!0,!1;let A,C=!0;const i=this._events;let V=0;if(this._coreRuntimeAnimation)V=H-E,A=this._coreRuntimeAnimation.currentFrame,this._currentFrame=A,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let P;(E<this._minFrame||E>this._maxFrame)&&(E=this._minFrame),(H<this._minFrame||H>this._maxFrame)&&(H=this._maxFrame),V=H-E;let D=e*(M.framePerSecond*z)/1e3+this._absoluteFrameOffset,U=0,j=!1;const F=u&&this._animationState.loopMode===N.b.ANIMATIONLOOPMODE_YOYO;if(F){const e=(D-E)/V,H=Math.sin(e*Math.PI);D=Math.abs(H)*V+E;const N=H>=0?1:-1;this._yoyoDirection!==N&&(j=!0),this._yoyoDirection=N}if(this._previousElapsedTime=e,this._previousAbsoluteFrame=D,!u&&H>=E&&(D>=V&&z>0||D<=0&&z<0))C=!1,U=M._getKeyValue(this._maxValue);else if(!u&&E>=H&&(D<=V&&z<0||D>=0&&z>0))C=!1,U=M._getKeyValue(this._minValue);else if(this._animationState.loopMode!==N.b.ANIMATIONLOOPMODE_CYCLE){const e=H.toString()+E.toString();if(!this._offsetsCache[e]){this._animationState.repeatCount=0,this._animationState.loopMode=N.b.ANIMATIONLOOPMODE_CYCLE;const u=M._interpolate(E,this._animationState),z=M._interpolate(H,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),M.dataType){case N.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[e]=z-u;break;case N.b.ANIMATIONTYPE_QUATERNION:case N.b.ANIMATIONTYPE_VECTOR3:case N.b.ANIMATIONTYPE_VECTOR2:case N.b.ANIMATIONTYPE_SIZE:case N.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[e]=z.FE(u)}this._highLimitsCache[e]=z}U=this._highLimitsCache[e],P=this._offsetsCache[e]}if(void 0===P)switch(M.dataType){case N.b.ANIMATIONTYPE_FLOAT:P=0;break;case N.b.ANIMATIONTYPE_QUATERNION:P=N.j;break;case N.b.ANIMATIONTYPE_VECTOR3:P=N.q;break;case N.b.ANIMATIONTYPE_VECTOR2:P=N.o;break;case N.b.ANIMATIONTYPE_SIZE:P=N.n;break;case N.b.ANIMATIONTYPE_COLOR3:P=N.f;break;case N.b.ANIMATIONTYPE_COLOR4:P=N.g}if(this._host&&this._host.syncRoot){const e=this._host.syncRoot;A=E+V*((e.masterFrame-e.fromFrame)/(e.toFrame-e.fromFrame))}else A=D>0&&E>H||D<0&&E<H?C&&0!==V?H+D%V:E:C&&0!==V?E+D%V:H;if(!F&&(z>0&&this.currentFrame>A||z<0&&this.currentFrame<A)||F&&j){this._onLoop();for(let e=0;e<i.length;e++)i[e].onlyOnce||(i[e].isDone=!1);this._animationState.key=z>0?0:M.getKeys().length-1}this._currentFrame=A,this._animationState.repeatCount=0===V?0:D/V|0,this._animationState.highLimitValue=U,this._animationState.offsetValue=P}const U=M._interpolate(A,this._animationState);if(this.setValue(U,P),i.length)for(let N=0;N<i.length;N++)if(V>=0&&A>=i[N].frame&&i[N].frame>=E||V<0&&A<=i[N].frame&&i[N].frame<=E){const e=i[N];e.isDone||(e.onlyOnce&&(i.splice(N,1),N--),e.isDone=!0,e.action(A))}return C||(this._stopped=!0),C}}var C=H(11559);class i{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(e){this._weight=-1!==e?Math.min(Math.max(e,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(e){for(let E=0;E<this._runtimeAnimations.length;E++){this._runtimeAnimations[E]._prepareForSpeedRatioChange(e)}this._speedRatio=e,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(e,E){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,z=arguments.length>4&&void 0!==arguments[4]&&arguments[4],P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,M=arguments.length>6?arguments[6]:void 0,D=arguments.length>7?arguments[7]:void 0,A=arguments.length>8?arguments[8]:void 0,C=arguments.length>9&&void 0!==arguments[9]&&arguments[9],i=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=E,this.fromFrame=H,this.toFrame=N,this.loopAnimation=z,this.onAnimationEnd=M,this.onAnimationLoop=A,this.isAdditive=C,this.playOrder=i,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.ZP=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new u.d,this.onAnimationLoopObservable=new u.d,this._scene=e,D&&this.appendAnimations(E,D),this._speedRatio=P,e._activeAnimatables.push(this)}syncWith(e){if(this._syncRoot=e,e){const e=this._scene._activeAnimatables.indexOf(this);e>-1&&(this._scene._activeAnimatables.splice(e,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(e,E){for(let H=0;H<E.length;H++){const N=E[H],u=new A(e,N,this._scene,this);u._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(u)}}getAnimationByTargetProperty(e){const E=this._runtimeAnimations;for(let H=0;H<E.length;H++)if(E[H].animation.targetProperty===e)return E[H].animation;return null}getRuntimeAnimationByTargetProperty(e){const E=this._runtimeAnimations;for(let H=0;H<E.length;H++)if(E[H].animation.targetProperty===e)return E[H];return null}reset(){const e=this._runtimeAnimations;for(let E=0;E<e.length;E++)e[E].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(e){const E=this._runtimeAnimations;for(let H=0;H<E.length;H++)E[H].animation.enableBlending=!0,E[H].animation.blendingSpeed=e}disableBlending(){const e=this._runtimeAnimations;for(let E=0;E<e.length;E++)e[E].animation.enableBlending=!1}goToFrame(e){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const H=this._runtimeAnimations;if(H[0]){const E=H[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??H[0].currentFrame;const N=0===this.speedRatio?0:(e-this._frameToSyncFromJump)/E*1e3/this.speedRatio;this._manualJumpDelay=-N}for(let N=0;N<H.length;N++)H[N].goToFrame(e,E?this._weight:-1);this._goToFrame=e}get paused(){return this.ZP}pause(){this.ZP||(this.ZP=!0)}restart(){this.ZP=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(e,E){let H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],N=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e||E){const u=this._scene._activeAnimatables.indexOf(this);if(u>-1){const z=this._runtimeAnimations;for(let H=z.length-1;H>=0;H--){const N=z[H];e&&N.animation.name!=e||(E&&!E(N.target)||(N.dispose(),z.splice(H,1)))}0==z.length&&(H||this._scene._activeAnimatables.splice(u,1),N||this._raiseOnAnimationEnd())}}else{const e=this._scene._activeAnimatables.indexOf(this);if(e>-1){H||this._scene._activeAnimatables.splice(e,1);const E=this._runtimeAnimations;for(let e=0;e<E.length;e++)E[e].dispose();this._runtimeAnimations.length=0,N||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((e=>{this.onAnimationEndObservable.add((()=>{e(this)}),void 0,void 0,this,!0)}))}_animate(e){if(this.ZP)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=e),!0;if(null===this._localDelayOffset?(this._localDelayOffset=e,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=e-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let E=!1;const H=this._runtimeAnimations;let N;for(N=0;N<H.length;N++){const u=H[N].animate(e-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);E=E||u}if(this.animationStarted=E,!E){if(this.disposeOnEnd)for(N=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(N,1),N=0;N<H.length;N++)H[N].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return E}}function V(e){if(0===e.totalWeight&&0===e.totalAdditiveWeight)return e.originalValue;let E=1;const H=D.TmpVectors.jE[0],N=D.TmpVectors.jE[1],u=D.TmpVectors.Quaternion[0];let z=0;const P=e.animations[0],M=e.originalValue;let A=1,C=!1;if(e.totalWeight<1)A=1-e.totalWeight,M.decompose(N,u,H);else{if(z=1,E=e.totalWeight,A=P.weight/E,1==A){if(!e.totalAdditiveWeight)return P.currentValue;C=!0}P.currentValue.decompose(N,u,H)}if(!C){N.scaleInPlace(A),H.scaleInPlace(A),u.scaleInPlace(A);for(let P=z;P<e.animations.length;P++){const z=e.animations[P];if(0===z.weight)continue;A=z.weight/E;const M=D.TmpVectors.jE[2],C=D.TmpVectors.jE[3],i=D.TmpVectors.Quaternion[1];z.currentValue.decompose(C,i,M),C.scaleAndAddToRef(A,N),i.scaleAndAddToRef(D.Quaternion.Dot(u,i)>0?A:-A,u),M.scaleAndAddToRef(A,H)}u.normalize()}for(let V=0;V<e.additiveAnimations.length;V++){const E=e.additiveAnimations[V];if(0===E.weight)continue;const z=D.TmpVectors.jE[2],P=D.TmpVectors.jE[3],M=D.TmpVectors.Quaternion[1];E.currentValue.decompose(P,M,z),P.multiplyToRef(N,P),D.jE.LerpToRef(N,P,E.weight,N),u.multiplyToRef(M,M),D.Quaternion.SlerpToRef(u,M,E.weight,u),z.scaleAndAddToRef(E.weight,H)}const i=P?P._animationState.workValue:D.TmpVectors.Matrix[0].clone();return D.Matrix.ComposeToRef(N,u,H,i),i}function U(e,E){if(0===e.totalWeight&&0===e.totalAdditiveWeight)return E;const H=e.animations[0],N=e.originalValue;let u=E;if(0===e.totalWeight&&e.totalAdditiveWeight>0)u.P(N);else if(1===e.animations.length){if(D.Quaternion.SlerpToRef(N,H.currentValue,Math.min(1,e.totalWeight),u),0===e.totalAdditiveWeight)return u}else if(e.animations.length>1){let H,z,P=1;if(e.totalWeight<1){const E=1-e.totalWeight;H=[],z=[],H.push(N),z.push(E)}else{if(2===e.animations.length&&(D.Quaternion.SlerpToRef(e.animations[0].currentValue,e.animations[1].currentValue,e.animations[1].weight/e.totalWeight,E),0===e.totalAdditiveWeight))return E;H=[],z=[],P=e.totalWeight}for(let E=0;E<e.animations.length;E++){const N=e.animations[E];H.push(N.currentValue),z.push(N.weight/P)}let M=0;for(let e=0;e<H.length;)e?(M+=z[e],D.Quaternion.SlerpToRef(u,H[e],z[e]/M,u),e++):(D.Quaternion.SlerpToRef(H[e],H[e+1],z[e+1]/(z[e]+z[e+1]),E),u=E,M=z[e]+z[e+1],e+=2)}for(let z=0;z<e.additiveAnimations.length;z++){const E=e.additiveAnimations[z];0!==E.weight&&(u.multiplyToRef(E.currentValue,D.TmpVectors.Quaternion[0]),D.Quaternion.SlerpToRef(u,D.TmpVectors.Quaternion[0],E.weight,u))}return u}var j,F,h=H(11967);j=h.c,(F=M.b)&&(F.prototype.copyAnimationRange=function(e,E,H){let u=arguments.length>3&&void 0!==arguments[3]&&arguments[3],z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new N.b(this.name,"_matrix",e.animations[0].framePerSecond,N.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const P=e.animations[0].getRange(E);if(!P)return!1;const M=P.from,D=P.to,A=e.animations[0].getKeys(),C=e.length,i=e.getParent(),V=this.getParent(),U=u&&i&&C&&this.length&&C!==this.length,j=U&&V&&i?V.length/i.length:1,F=u&&!V&&z&&(1!==z.x||1!==z.y||1!==z.z),h=this.animations[0].getKeys();let S,X,a;for(let N=0,W=A.length;N<W;N++)S=A[N],S.frame>=M&&S.frame<=D&&(u?(a=S.value.clone(),U?(X=a.getTranslation(),a.setTranslation(X.scaleInPlace(j))):F&&z?(X=a.getTranslation(),a.setTranslation(X.multiplyInPlace(z))):a=S.value):a=S.value,h.push({frame:S.frame+H,value:a}));return this.animations[0].createRange(E,M+H,D+H),!0}),j&&(j.prototype._animate=function(e){if(!this.animationsEnabled)return;const E=C.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=E}this.deltaTime=void 0!==e?e:this.useConstantAnimationDeltaTime?16:(E-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=E;const H=this._activeAnimatables;if(0===H.length)return;this._animationTime+=this.deltaTime;const u=this._animationTime;for(let N=0;N<H.length;N++){const e=H[N];!e._animate(u)&&e.disposeOnEnd&&N--}!function(e){if(e._registeredForLateAnimationBindings.length){for(let E=0;E<e._registeredForLateAnimationBindings.length;E++){const H=e._registeredForLateAnimationBindings.data[E];for(const e in H._lateAnimationHolders){const E=H._lateAnimationHolders[e],u=E.animations[0],z=E.originalValue;if(void 0===z||null===z)continue;const P=N.b.AllowMatrixDecomposeForInterpolation&&z.m;let M=H[e];if(P)M=V(E);else if(void 0!==z.w)M=U(E,M||D.Quaternion.Identity());else{let e=0,H=1;const P=u&&u._animationState.loopMode===N.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(E.totalWeight<1)M=P?z.clone?z.clone():z:u&&z.scale?z.scale(1-E.totalWeight):u?z*(1-E.totalWeight):z.clone?z.clone():z;else if(u){H=E.totalWeight;const N=u.weight/H;M=1!==N?u.currentValue.scale?u.currentValue.scale(N):u.currentValue*N:u.currentValue,P&&(M.addToRef?M.addToRef(z,M):M+=z),e=1}for(let N=e;N<E.animations.length;N++){const e=E.animations[N],u=e.weight/H;u&&(e.currentValue.scaleAndAddToRef?e.currentValue.scaleAndAddToRef(u,M):M+=e.currentValue*u)}for(let N=0;N<E.additiveAnimations.length;N++){const e=E.additiveAnimations[N],H=e.weight;H&&(e.currentValue.scaleAndAddToRef?e.currentValue.scaleAndAddToRef(H,M):M+=e.currentValue*H)}}H[e]=M}H._lateAnimationHolders={}}e._registeredForLateAnimationBindings.reset()}}(this)},j.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((e,E)=>e.playOrder-E.playOrder))},j.prototype.beginWeightedAnimation=function(e,E,H){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,u=arguments.length>4?arguments[4]:void 0,z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,P=arguments.length>6?arguments[6]:void 0,M=arguments.length>7?arguments[7]:void 0,D=arguments.length>8?arguments[8]:void 0,A=arguments.length>9?arguments[9]:void 0,C=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const i=this.beginAnimation(e,E,H,u,z,P,M,!1,D,A,C);return i.weight=N,i},j.prototype.beginAnimation=function(e,E,H,N){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,z=arguments.length>5?arguments[5]:void 0,P=arguments.length>6?arguments[6]:void 0,M=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],D=arguments.length>8?arguments[8]:void 0,A=arguments.length>9?arguments[9]:void 0,C=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(u<0){const e=E;E=H,H=e,u=-u}E>H&&(u=-u),M&&this.stopAnimation(e,void 0,D),P||(P=new i(this,e,E,H,N,u,z,void 0,A,C));const V=!D||D(e);if(e.animations&&V&&P.appendAnimations(e,e.animations),e.getAnimatables){const C=e.getAnimatables();for(let e=0;e<C.length;e++)this.beginAnimation(C[e],E,H,N,u,z,P,M,D,A)}return P.reset(),P},j.prototype.beginHierarchyAnimation=function(e,E,H,N,u){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,P=arguments.length>6?arguments[6]:void 0,M=arguments.length>7?arguments[7]:void 0,D=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],A=arguments.length>9?arguments[9]:void 0,C=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const i=e.getDescendants(E),V=[];V.push(this.beginAnimation(e,H,N,u,z,P,M,D,A,void 0,C));for(const U of i)V.push(this.beginAnimation(U,H,N,u,z,P,M,D,A,void 0,C));return V},j.prototype.beginDirectAnimation=function(e,E,H,N,u){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(z<0){const e=H;H=N,N=e,z=-z}return H>N&&(z=-z),new i(this,e,H,N,u,z,arguments.length>6?arguments[6]:void 0,E,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},j.prototype.beginDirectHierarchyAnimation=function(e,E,H,N,u,z,P,M,D){let A=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const C=e.getDescendants(E),i=[];i.push(this.beginDirectAnimation(e,H,N,u,z,P,M,D,A));for(const V of C)i.push(this.beginDirectAnimation(V,H,N,u,z,P,M,D,A));return i},j.prototype.getAnimatableByTarget=function(e){for(let E=0;E<this._activeAnimatables.length;E++)if(this._activeAnimatables[E].target===e)return this._activeAnimatables[E];return null},j.prototype.getAllAnimatablesByTarget=function(e){const E=[];for(let H=0;H<this._activeAnimatables.length;H++)this._activeAnimatables[H].target===e&&E.push(this._activeAnimatables[H]);return E},j.prototype.stopAnimation=function(e,E,H){const N=this.getAllAnimatablesByTarget(e);for(const u of N)u.stop(E,H)},j.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let e=0;e<this._activeAnimatables.length;e++)this._activeAnimatables[e].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const e of this.animationGroups)e.stop()});class S{getClassName(){return"TargetedAnimation"}serialize(){const e={};return e.animation=this.animation.serialize(),e.targetId=this.target.id,e}}class X{get mask(){return this._mask}set mask(e){this._mask!==e&&(this._mask=e,this.syncWithMask(!0))}syncWithMask(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||e){this._numActiveAnimatables=0;for(let e=0;e<this._animatables.length;++e){const E=this._animatables[e];!this.mask||this.mask.disabled||this.mask.retainsTarget(E.target.name)?(this._numActiveAnimatables++,E.paused&&E.restart()):E.paused||E.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let e=0;e<this._animatables.length;++e){const E=this._animatables[e];this.mask.retainsTarget(E.target.name)||(E.stop(),this._animatables.splice(e,1),--e)}for(let e=0;e<this._targetedAnimations.length;e++){const E=this._targetedAnimations[e];this.mask.retainsTarget(E.target.name)||(this._targetedAnimations.splice(e,1),--e)}}}get from(){return this._from}set from(e){if(this._from!==e){this._from=e;for(let e=0;e<this._animatables.length;e++){this._animatables[e].fromFrame=this._from}}}get to(){return this._to}set to(e){if(this._to!==e){this._to=e;for(let e=0;e<this._animatables.length;e++){this._animatables[e].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(e){if(this._speedRatio!==e){this._speedRatio=e;for(let e=0;e<this._animatables.length;e++){this._animatables[e].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(e){if(this._loopAnimation!==e){this._loopAnimation=e;for(let e=0;e<this._animatables.length;e++){this._animatables[e].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(e){if(this._isAdditive!==e){this._isAdditive=e;for(let e=0;e<this._animatables.length;e++){this._animatables[e].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(e){this._weight!==e&&(this._weight=e,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(e){if(this._playOrder!==e&&(this._playOrder=e,this._animatables.length>0)){for(let e=0;e<this._animatables.length;e++)this._animatables[e].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(e){if(this._enableBlending!==e&&(this._enableBlending=e,null!==e))for(let E=0;E<this._targetedAnimations.length;++E)this._targetedAnimations[E].animation.enableBlending=e}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(e){if(this._blendingSpeed!==e&&(this._blendingSpeed=e,null!==e))for(let E=0;E<this._targetedAnimations.length;++E)this._targetedAnimations[E].animation.blendingSpeed=e}getLength(e,E){e=e??this._from;return((E=E??this._to)-e)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(e){let E=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],N=arguments.length>3?arguments[3]:void 0;if(0===e.length)return null;N=N??e[0].weight;let u=Number.MAX_VALUE,z=-Number.MAX_VALUE;if(H)for(const M of e)M.from<u&&(u=M.from),M.to>z&&(z=M.to);const P=new X(e[0].name+"_merged",e[0]._scene,N);for(const M of e){H&&M.normalize(u,z);for(const e of M.targetedAnimations)P.addTargetedAnimation(e.animation,e.target);E&&M.dispose()}return P}constructor(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=e,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new u.d,this.onAnimationLoopObservable=new u.d,this.onAnimationGroupLoopObservable=new u.d,this.onAnimationGroupEndObservable=new u.d,this.onAnimationGroupPauseObservable=new u.d,this.onAnimationGroupPlayObservable=new u.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=E||z.d.LastCreatedScene,this._weight=H,this._playOrder=N,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(e,E){const H=new S;H.animation=e,H.target=E;const N=e.getKeys();return this._from>N[0].frame&&(this._from=N[0].frame),this._to<N[N.length-1].frame&&(this._to=N[N.length-1].frame),null!==this._enableBlending&&(e.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(e.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(H),this._shouldStart=!0,H}removeTargetedAnimation(e){for(let E=this._targetedAnimations.length-1;E>-1;E--){this._targetedAnimations[E].animation===e&&this._targetedAnimations.splice(E,1)}}normalize(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==e&&(e=this._from),null==E&&(E=this._to);for(let H=0;H<this._targetedAnimations.length;H++){const N=this._targetedAnimations[H].animation.getKeys(),u=N[0],z=N[N.length-1];if(u.frame>e){const E={frame:e,value:u.value,inTangent:u.inTangent,outTangent:u.outTangent,interpolation:u.interpolation};N.splice(0,0,E)}if(z.frame<E){const e={frame:E,value:z.value,inTangent:z.inTangent,outTangent:z.outTangent,interpolation:z.interpolation};N.push(e)}}return this._from=e,this._to=E,this}_processLoop(e,E,H){e.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(E),this._animationLoopFlags[H]||(this._animationLoopFlags[H]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0,N=arguments.length>3?arguments[3]:void 0,u=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=e,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let z=0;z<this._targetedAnimations.length;z++){const P=this._targetedAnimations[z],M=this._scene.beginDirectAnimation(P.target,[P.animation],void 0!==H?H:this._from,void 0!==N?N:this._to,e,E,void 0,void 0,void 0!==u?u:this._isAdditive);M.weight=this._weight,M.playOrder=this._playOrder,M.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(P),this._checkAnimationGroupEnded(M)},this._processLoop(M,P,z),this._animatables.push(M)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=E,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let e=0;e<this._animatables.length;e++){this._animatables[e].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(e){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==e&&(this.loopAnimation=e),this.restart()):(this.stop(),this.start(e,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let e=0;e<this._animatables.length;e++){this._animatables[e].reset()}return this}restart(){if(!this._isStarted)return this;for(let e=0;e<this._animatables.length;e++){this._animatables[e].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const E=this._animatables.slice();for(let N=0;N<E.length;N++)E[N].stop(void 0,void 0,!0,e);let H=0;for(let N=0;N<this._scene._activeAnimatables.length;N++){const E=this._scene._activeAnimatables[N];E._runtimeAnimations.length>0?this._scene._activeAnimatables[H++]=E:e&&this._checkAnimationGroupEnded(E,e)}return this._scene._activeAnimatables.length=H,this._isStarted=!1,this}setWeightForAllAnimatables(e){for(let E=0;E<this._animatables.length;E++){this._animatables[E].weight=e}return this}syncAllAnimationsWith(e){for(let E=0;E<this._animatables.length;E++){this._animatables[E].syncWith(e)}return this}goToFrame(e){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].goToFrame(e,E)}return this}getCurrentFrame(){var e;return(null===(e=this.animatables[0])||void 0===e?void 0:e.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const e=this._scene.animationGroups.indexOf(this);if(e>-1&&this._scene.animationGroups.splice(e,1),this._parentContainer){const e=this._parentContainer.animationGroups.indexOf(this);e>-1&&this._parentContainer.animationGroups.splice(e,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(e){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const H=this._animatables.indexOf(e);H>-1&&this._animatables.splice(H,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,E||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(e,E){let H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const N=new X(e||this.name,this._scene,this._weight,this._playOrder);N._from=this.from,N._to=this.to,N._speedRatio=this.speedRatio,N._loopAnimation=this.loopAnimation,N._isAdditive=this.isAdditive,N._enableBlending=this.enableBlending,N._blendingSpeed=this.blendingSpeed,N.metadata=this.metadata,N.mask=this.mask;for(const u of this._targetedAnimations)N.addTargetedAnimation(H?u.animation.clone():u.animation,E?E(u.target):u.target);return N}serialize(){const e={};e.name=this.name,e.from=this.from,e.to=this.to,e.speedRatio=this.speedRatio,e.loopAnimation=this.loopAnimation,e.isAdditive=this.isAdditive,e.weight=this.weight,e.playOrder=this.playOrder,e.enableBlending=this.enableBlending,e.blendingSpeed=this.blendingSpeed,e.targetedAnimations=[];for(let E=0;E<this.targetedAnimations.length;E++){const H=this.targetedAnimations[E];e.targetedAnimations[E]=H.serialize()}return P.c&&P.c.HasTags(this)&&(e.tags=P.c.GetTags(this)),this.metadata&&(e.metadata=this.metadata),e}static Parse(e,E){const H=new X(e.name,E,e.weight,e.playOrder);for(let u=0;u<e.targetedAnimations.length;u++){const z=e.targetedAnimations[u],P=N.b.Parse(z.animation),M=z.targetId;if("influence"===z.animation.property){const e=E.getMorphTargetById(M);e&&H.addTargetedAnimation(P,e)}else{const e=E.getNodeById(M);null!=e&&H.addTargetedAnimation(P,e)}}return P.c&&P.c.AddTagsTo(H,e.tags),null!==e.from&&null!==e.to&&H.normalize(e.from,e.to),void 0!==e.speedRatio&&(H._speedRatio=e.speedRatio),void 0!==e.loopAnimation&&(H._loopAnimation=e.loopAnimation),void 0!==e.isAdditive&&(H._isAdditive=e.isAdditive),void 0!==e.weight&&(H._weight=e.weight),void 0!==e.playOrder&&(H._playOrder=e.playOrder),void 0!==e.enableBlending&&(H._enableBlending=e.enableBlending),void 0!==e.blendingSpeed&&(H._blendingSpeed=e.blendingSpeed),void 0!==e.metadata&&(H.metadata=e.metadata),H}static MakeAnimationAdditive(e,E,H){let u;u="object"===typeof E?E:{referenceFrame:E,range:H,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let z=e;u.cloneOriginalAnimationGroup&&(z=e.clone(u.clonedAnimationGroupName||z.name));const P=z.targetedAnimations;for(let M=0;M<P.length;M++){const e=P[M];e.animation=N.b.MakeAnimationAdditive(e.animation,u)}if(z.isAdditive=!0,u.clipKeys){let e=Number.MAX_VALUE,E=-Number.MAX_VALUE;const H=z.targetedAnimations;for(let N=0;N<H.length;N++){const u=H[N].animation.getKeys();e>u[0].frame&&(e=u[0].frame),E<u[u.length-1].frame&&(E=u[u.length-1].frame)}z._from=e,z._to=E}return z}static ClipKeys(e,E,H,N,u){const z=e.clone(N||e.name);return X.ClipKeysInPlace(z,E,H,u)}static ClipKeysInPlace(e,E,H,N){return X.ClipInPlace(e,E,H,N,!1)}static ClipFrames(e,E,H,N,u){const z=e.clone(N||e.name);return X.ClipFramesInPlace(z,E,H,u)}static ClipFramesInPlace(e,E,H,N){return X.ClipInPlace(e,E,H,N,!0)}static ClipInPlace(e,E,H,N){let u=arguments.length>4&&void 0!==arguments[4]&&arguments[4],z=Number.MAX_VALUE,P=-Number.MAX_VALUE;const M=e.targetedAnimations;for(let D=0;D<M.length;D++){const e=M[D],A=N?e.animation:e.animation.clone();u&&(A.createKeyForFrame(E),A.createKeyForFrame(H));const C=A.getKeys(),i=[];let V=Number.MAX_VALUE;for(let N=0;N<C.length;N++){const e=C[N];if(!u&&N>=E&&N<=H||u&&e.frame>=E&&e.frame<=H){const E={frame:e.frame,value:e.value.clone?e.value.clone():e.value,inTangent:e.inTangent,outTangent:e.outTangent,interpolation:e.interpolation,lockedTangent:e.lockedTangent};V===Number.MAX_VALUE&&(V=E.frame),E.frame-=V,i.push(E)}}0!==i.length?(z>i[0].frame&&(z=i[0].frame),P<i[i.length-1].frame&&(P=i[i.length-1].frame),A.setKeys(i,!0),e.animation=A):(M.splice(D,1),D--)}return e._from=z,e._to=P,e}getClassName(){return"AnimationGroup"}toString(e){let E="Name: "+this.name;return E+=", type: "+this.getClassName(),e&&(E+=", from: "+this._from,E+=", to: "+this._to,E+=", isStarted: "+this._isStarted,E+=", speedRatio: "+this._speedRatio,E+=", targetedAnimations length: "+this._targetedAnimations.length,E+=", animatables length: "+this._animatables),E}}}}]);