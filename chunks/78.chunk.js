"use strict";(self["9jl1vn4ei5r"]=self["9jl1vn4ei5r"]||[]).push([[78],{14916:(M,p,b)=>{b.r(p),b.d(p,{AnimationGroup:()=>D,TargetedAnimation:()=>K});var Q=b(12342),q=b(11624),B=b(11664),k=b(11829),u=b(13385),T=b(11796);class O{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(M,p,b,q){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=p,this._target=M,this._scene=b,this._host=q,this._activeTargets=[],p._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===Q.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=T.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const M={frame:0,value:this._minValue};this._keys.splice(0,0,M)}if(this._target instanceof Array){let M=0;for(const p of this._target)this._preparePath(p,M),this._getOriginalValues(M),M++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const B=p.getEvents();if(B&&B.length>0)for(const Q of B)this._events.push(Q._clone());this._enableBlending=M&&M.animationPropertiesOverride?M.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=this._animation.targetPropertyPath;if(b.length>1){let Q=M;for(let M=0;M<b.length-1;M++){const p=b[M];if(Q=Q[p],void 0===Q)throw new Error(`Invalid property (${p}) in property path (${b.join(".")})`)}this._targetPath=b[b.length-1],this._activeTargets[p]=Q}else this._targetPath=b[0],this._activeTargets[p]=M;if(void 0===this._activeTargets[p][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${b.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let M=0;for(const p of this._target)void 0!==this._originalValue[M]&&this._setValue(p,this._activeTargets[M],this._originalValue[M],-1,M),M++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let M=0;M<this._events.length;M++)this._events[M].isDone=!1}isStopped(){return this._stopped}dispose(){const M=this._animation.runtimeAnimations.indexOf(this);M>-1&&this._animation.runtimeAnimations.splice(M,1)}setValue(M,p){if(this._targetIsArray)for(let b=0;b<this._target.length;b++){const Q=this._target[b];this._setValue(Q,this._activeTargets[b],M,p,b)}else this._setValue(this._target,this._directTarget,M,p,0)}_getOriginalValues(){let M,p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=this._activeTargets[p];M=b.getLocalMatrix&&"_matrix"===this._targetPath?b.getLocalMatrix():b[this._targetPath],M&&M.clone?this._originalValue[p]=M.clone():this._originalValue[p]=M}_registerTargetForLateAnimationBinding(M,p){const b=M.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(b),b._lateAnimationHolders||(b._lateAnimationHolders={}),b._lateAnimationHolders[M.targetPath]||(b._lateAnimationHolders[M.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:p}),M.isAdditive?(b._lateAnimationHolders[M.targetPath].additiveAnimations.push(M),b._lateAnimationHolders[M.targetPath].totalAdditiveWeight+=M.weight):(b._lateAnimationHolders[M.targetPath].animations.push(M),b._lateAnimationHolders[M.targetPath].totalWeight+=M.weight)}_setValue(M,p,b,q,B){if(this._currentActiveTarget=p,this._weight=q,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const M=p[this._targetPath];M.clone?this._originalBlendValue=M.clone():this._originalBlendValue=M}this._originalBlendValue.m?Q.c.AllowMatrixDecomposeForInterpolation?this._currentValue?T.Matrix.DecomposeLerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=T.Matrix.DecomposeLerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue?T.Matrix.LerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=T.Matrix.Lerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue=Q.c._UniversalLerp(this._originalBlendValue,b,this._blendingFactor);const q=M&&M.animationPropertiesOverride?M.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=q}else this._currentValue?this._currentValue.B?this._currentValue.B(b):this._currentValue=b:null!==b&&void 0!==b&&b.clone?this._currentValue=b.clone():this._currentValue=b;-1!==q?this._registerTargetForLateAnimationBinding(this,this._originalValue[B]):this._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[B],p[this._targetPath]):p[this._targetPath]=this._originalValue[B]+this._currentValue:p[this._targetPath]=this._currentValue,M.XO&&M.XO(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const b=this._animation.getKeys();M<b[0].frame?M=b[0].frame:M>b[b.length-1].frame&&(M=b[b.length-1].frame);const Q=this._events;if(Q.length)for(let B=0;B<Q.length;B++)Q[B].onlyOnce||(Q[B].isDone=Q[B].frame<M);this._currentFrame=M;const q=this._animation._interpolate(M,this._animationState);this.setValue(q,p)}_prepareForSpeedRatioChange(M){const p=this._previousElapsedTime*(this._animation.framePerSecond*M)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-p}animate(M,p,b,q,B){let k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const u=this._animation,T=u.targetPropertyPath;if(!T||T.length<1)return this._stopped=!0,!1;let O,H=!0;const F=this._events;let o=0;if(this._coreRuntimeAnimation)o=b-p,O=this._coreRuntimeAnimation.currentFrame,this._currentFrame=O,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let k;(p<this._minFrame||p>this._maxFrame)&&(p=this._minFrame),(b<this._minFrame||b>this._maxFrame)&&(b=this._maxFrame),o=b-p;let T=M*(u.framePerSecond*B)/1e3+this._absoluteFrameOffset,W=0,i=!1;const A=q&&this._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_YOYO;if(A){const M=(T-p)/o,b=Math.sin(M*Math.PI);T=Math.abs(b)*o+p;const Q=b>=0?1:-1;this._yoyoDirection!==Q&&(i=!0),this._yoyoDirection=Q}if(this._previousElapsedTime=M,this._previousAbsoluteFrame=T,!q&&b>=p&&(T>=o&&B>0||T<=0&&B<0))H=!1,W=u._getKeyValue(this._maxValue);else if(!q&&p>=b&&(T<=o&&B<0||T>=0&&B>0))H=!1,W=u._getKeyValue(this._minValue);else if(this._animationState.loopMode!==Q.c.ANIMATIONLOOPMODE_CYCLE){const M=b.toString()+p.toString();if(!this._offsetsCache[M]){this._animationState.repeatCount=0,this._animationState.loopMode=Q.c.ANIMATIONLOOPMODE_CYCLE;const q=u._interpolate(p,this._animationState),B=u._interpolate(b,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),u.dataType){case Q.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[M]=B-q;break;case Q.c.ANIMATIONTYPE_QUATERNION:case Q.c.ANIMATIONTYPE_VECTOR3:case Q.c.ANIMATIONTYPE_VECTOR2:case Q.c.ANIMATIONTYPE_SIZE:case Q.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[M]=B.jp(q)}this._highLimitsCache[M]=B}W=this._highLimitsCache[M],k=this._offsetsCache[M]}if(void 0===k)switch(u.dataType){case Q.c.ANIMATIONTYPE_FLOAT:k=0;break;case Q.c.ANIMATIONTYPE_QUATERNION:k=Q.k;break;case Q.c.ANIMATIONTYPE_VECTOR3:k=Q.q;break;case Q.c.ANIMATIONTYPE_VECTOR2:k=Q.p;break;case Q.c.ANIMATIONTYPE_SIZE:k=Q.o;break;case Q.c.ANIMATIONTYPE_COLOR3:k=Q.e;break;case Q.c.ANIMATIONTYPE_COLOR4:k=Q.h}if(this._host&&this._host.syncRoot){const M=this._host.syncRoot;O=p+o*((M.masterFrame-M.fromFrame)/(M.toFrame-M.fromFrame))}else O=T>0&&p>b||T<0&&p<b?H&&0!==o?b+T%o:p:H&&0!==o?p+T%o:b;if(!A&&(B>0&&this.currentFrame>O||B<0&&this.currentFrame<O)||A&&i){this._onLoop();for(let M=0;M<F.length;M++)F[M].onlyOnce||(F[M].isDone=!1);this._animationState.key=B>0?0:u.getKeys().length-1}this._currentFrame=O,this._animationState.repeatCount=0===o?0:T/o|0,this._animationState.highLimitValue=W,this._animationState.offsetValue=k}const W=u._interpolate(O,this._animationState);if(this.setValue(W,k),F.length)for(let Q=0;Q<F.length;Q++)if(o>=0&&O>=F[Q].frame&&F[Q].frame>=p||o<0&&O<=F[Q].frame&&F[Q].frame<=p){const M=F[Q];M.isDone||(M.onlyOnce&&(F.splice(Q,1),Q--),M.isDone=!0,M.action(O))}return H||(this._stopped=!0),H}}var H=b(11647);class F{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(M){this._weight=-1!==M?Math.min(Math.max(M,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(M){for(let p=0;p<this._runtimeAnimations.length;p++){this._runtimeAnimations[p]._prepareForSpeedRatioChange(M)}this._speedRatio=M,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(M,p){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,B=arguments.length>4&&void 0!==arguments[4]&&arguments[4],k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,T=arguments.length>7?arguments[7]:void 0,O=arguments.length>8?arguments[8]:void 0,H=arguments.length>9&&void 0!==arguments[9]&&arguments[9],F=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=p,this.fromFrame=b,this.toFrame=Q,this.loopAnimation=B,this.onAnimationEnd=u,this.onAnimationLoop=O,this.isAdditive=H,this.playOrder=F,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.hu=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new q.b,this.onAnimationLoopObservable=new q.b,this._scene=M,T&&this.appendAnimations(p,T),this._speedRatio=k,M._activeAnimatables.push(this)}syncWith(M){if(this._syncRoot=M,M){const M=this._scene._activeAnimatables.indexOf(this);M>-1&&(this._scene._activeAnimatables.splice(M,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(M,p){for(let b=0;b<p.length;b++){const Q=p[b],q=new O(M,Q,this._scene,this);q._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(q)}}getAnimationByTargetProperty(M){const p=this._runtimeAnimations;for(let b=0;b<p.length;b++)if(p[b].animation.targetProperty===M)return p[b].animation;return null}getRuntimeAnimationByTargetProperty(M){const p=this._runtimeAnimations;for(let b=0;b<p.length;b++)if(p[b].animation.targetProperty===M)return p[b];return null}reset(){const M=this._runtimeAnimations;for(let p=0;p<M.length;p++)M[p].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(M){const p=this._runtimeAnimations;for(let b=0;b<p.length;b++)p[b].animation.enableBlending=!0,p[b].animation.blendingSpeed=M}disableBlending(){const M=this._runtimeAnimations;for(let p=0;p<M.length;p++)M[p].animation.enableBlending=!1}goToFrame(M){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._runtimeAnimations;if(b[0]){const p=b[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??b[0].currentFrame;const Q=0===this.speedRatio?0:(M-this._frameToSyncFromJump)/p*1e3/this.speedRatio;this._manualJumpDelay=-Q}for(let Q=0;Q<b.length;Q++)b[Q].goToFrame(M,p?this._weight:-1);this._goToFrame=M}get paused(){return this.hu}pause(){this.hu||(this.hu=!0)}restart(){this.hu=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(M,p){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(M||p){const q=this._scene._activeAnimatables.indexOf(this);if(q>-1){const B=this._runtimeAnimations;for(let b=B.length-1;b>=0;b--){const Q=B[b];M&&Q.animation.name!=M||(p&&!p(Q.target)||(Q.dispose(),B.splice(b,1)))}0==B.length&&(b||this._scene._activeAnimatables.splice(q,1),Q||this._raiseOnAnimationEnd())}}else{const M=this._scene._activeAnimatables.indexOf(this);if(M>-1){b||this._scene._activeAnimatables.splice(M,1);const p=this._runtimeAnimations;for(let M=0;M<p.length;M++)p[M].dispose();this._runtimeAnimations.length=0,Q||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((M=>{this.onAnimationEndObservable.add((()=>{M(this)}),void 0,void 0,this,!0)}))}_animate(M){if(this.hu)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=M),!0;if(null===this._localDelayOffset?(this._localDelayOffset=M,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=M-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let p=!1;const b=this._runtimeAnimations;let Q;for(Q=0;Q<b.length;Q++){const q=b[Q].animate(M-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);p=p||q}if(this.animationStarted=p,!p){if(this.disposeOnEnd)for(Q=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(Q,1),Q=0;Q<b.length;Q++)b[Q].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return p}}function o(M){if(0===M.totalWeight&&0===M.totalAdditiveWeight)return M.originalValue;let p=1;const b=T.TmpVectors.Ap[0],Q=T.TmpVectors.Ap[1],q=T.TmpVectors.Quaternion[0];let B=0;const k=M.animations[0],u=M.originalValue;let O=1,H=!1;if(M.totalWeight<1)O=1-M.totalWeight,u.decompose(Q,q,b);else{if(B=1,p=M.totalWeight,O=k.weight/p,1==O){if(!M.totalAdditiveWeight)return k.currentValue;H=!0}k.currentValue.decompose(Q,q,b)}if(!H){Q.scaleInPlace(O),b.scaleInPlace(O),q.scaleInPlace(O);for(let k=B;k<M.animations.length;k++){const B=M.animations[k];if(0===B.weight)continue;O=B.weight/p;const u=T.TmpVectors.Ap[2],H=T.TmpVectors.Ap[3],F=T.TmpVectors.Quaternion[1];B.currentValue.decompose(H,F,u),H.scaleAndAddToRef(O,Q),F.scaleAndAddToRef(T.Quaternion.Dot(q,F)>0?O:-O,q),u.scaleAndAddToRef(O,b)}q.normalize()}for(let o=0;o<M.additiveAnimations.length;o++){const p=M.additiveAnimations[o];if(0===p.weight)continue;const B=T.TmpVectors.Ap[2],k=T.TmpVectors.Ap[3],u=T.TmpVectors.Quaternion[1];p.currentValue.decompose(k,u,B),k.multiplyToRef(Q,k),T.Ap.LerpToRef(Q,k,p.weight,Q),q.multiplyToRef(u,u),T.Quaternion.SlerpToRef(q,u,p.weight,q),B.scaleAndAddToRef(p.weight,b)}const F=k?k._animationState.workValue:T.TmpVectors.Matrix[0].clone();return T.Matrix.ComposeToRef(Q,q,b,F),F}function W(M,p){if(0===M.totalWeight&&0===M.totalAdditiveWeight)return p;const b=M.animations[0],Q=M.originalValue;let q=p;if(0===M.totalWeight&&M.totalAdditiveWeight>0)q.B(Q);else if(1===M.animations.length){if(T.Quaternion.SlerpToRef(Q,b.currentValue,Math.min(1,M.totalWeight),q),0===M.totalAdditiveWeight)return q}else if(M.animations.length>1){let b,B,k=1;if(M.totalWeight<1){const p=1-M.totalWeight;b=[],B=[],b.push(Q),B.push(p)}else{if(2===M.animations.length&&(T.Quaternion.SlerpToRef(M.animations[0].currentValue,M.animations[1].currentValue,M.animations[1].weight/M.totalWeight,p),0===M.totalAdditiveWeight))return p;b=[],B=[],k=M.totalWeight}for(let p=0;p<M.animations.length;p++){const Q=M.animations[p];b.push(Q.currentValue),B.push(Q.weight/k)}let u=0;for(let M=0;M<b.length;)M?(u+=B[M],T.Quaternion.SlerpToRef(q,b[M],B[M]/u,q),M++):(T.Quaternion.SlerpToRef(b[M],b[M+1],B[M+1]/(B[M]+B[M+1]),p),q=p,u=B[M]+B[M+1],M+=2)}for(let B=0;B<M.additiveAnimations.length;B++){const p=M.additiveAnimations[B];0!==p.weight&&(q.multiplyToRef(p.currentValue,T.TmpVectors.Quaternion[0]),T.Quaternion.SlerpToRef(q,T.TmpVectors.Quaternion[0],p.weight,q))}return q}var i,A,j=b(12033);i=j.e,(A=u.d)&&(A.prototype.copyAnimationRange=function(M,p,b){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new Q.c(this.name,"_matrix",M.animations[0].framePerSecond,Q.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const k=M.animations[0].getRange(p);if(!k)return!1;const u=k.from,T=k.to,O=M.animations[0].getKeys(),H=M.length,F=M.getParent(),o=this.getParent(),W=q&&F&&H&&this.length&&H!==this.length,i=W&&o&&F?o.length/F.length:1,A=q&&!o&&B&&(1!==B.x||1!==B.y||1!==B.z),j=this.animations[0].getKeys();let K,D,a;for(let Q=0,s=O.length;Q<s;Q++)K=O[Q],K.frame>=u&&K.frame<=T&&(q?(a=K.value.clone(),W?(D=a.getTranslation(),a.setTranslation(D.scaleInPlace(i))):A&&B?(D=a.getTranslation(),a.setTranslation(D.multiplyInPlace(B))):a=K.value):a=K.value,j.push({frame:K.frame+b,value:a}));return this.animations[0].createRange(p,u+b,T+b),!0}),i&&(i.prototype._animate=function(M){if(!this.animationsEnabled)return;const p=H.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=p}this.deltaTime=void 0!==M?M:this.useConstantAnimationDeltaTime?16:(p-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=p;const b=this._activeAnimatables;if(0===b.length)return;this._animationTime+=this.deltaTime;const q=this._animationTime;for(let Q=0;Q<b.length;Q++){const M=b[Q];!M._animate(q)&&M.disposeOnEnd&&Q--}!function(M){if(M._registeredForLateAnimationBindings.length){for(let p=0;p<M._registeredForLateAnimationBindings.length;p++){const b=M._registeredForLateAnimationBindings.data[p];for(const M in b._lateAnimationHolders){const p=b._lateAnimationHolders[M],q=p.animations[0],B=p.originalValue;if(void 0===B||null===B)continue;const k=Q.c.AllowMatrixDecomposeForInterpolation&&B.m;let u=b[M];if(k)u=o(p);else if(void 0!==B.w)u=W(p,u||T.Quaternion.Identity());else{let M=0,b=1;const k=q&&q._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(p.totalWeight<1)u=k?B.clone?B.clone():B:q&&B.scale?B.scale(1-p.totalWeight):q?B*(1-p.totalWeight):B.clone?B.clone():B;else if(q){b=p.totalWeight;const Q=q.weight/b;u=1!==Q?q.currentValue.scale?q.currentValue.scale(Q):q.currentValue*Q:q.currentValue,k&&(u.addToRef?u.addToRef(B,u):u+=B),M=1}for(let Q=M;Q<p.animations.length;Q++){const M=p.animations[Q],q=M.weight/b;q&&(M.currentValue.scaleAndAddToRef?M.currentValue.scaleAndAddToRef(q,u):u+=M.currentValue*q)}for(let Q=0;Q<p.additiveAnimations.length;Q++){const M=p.additiveAnimations[Q],b=M.weight;b&&(M.currentValue.scaleAndAddToRef?M.currentValue.scaleAndAddToRef(b,u):u+=M.currentValue*b)}}b[M]=u}b._lateAnimationHolders={}}M._registeredForLateAnimationBindings.reset()}}(this)},i.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((M,p)=>M.playOrder-p.playOrder))},i.prototype.beginWeightedAnimation=function(M,p,b){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,q=arguments.length>4?arguments[4]:void 0,B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,u=arguments.length>7?arguments[7]:void 0,T=arguments.length>8?arguments[8]:void 0,O=arguments.length>9?arguments[9]:void 0,H=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const F=this.beginAnimation(M,p,b,q,B,k,u,!1,T,O,H);return F.weight=Q,F},i.prototype.beginAnimation=function(M,p,b,Q){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,B=arguments.length>5?arguments[5]:void 0,k=arguments.length>6?arguments[6]:void 0,u=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],T=arguments.length>8?arguments[8]:void 0,O=arguments.length>9?arguments[9]:void 0,H=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(q<0){const M=p;p=b,b=M,q=-q}p>b&&(q=-q),u&&this.stopAnimation(M,void 0,T),k||(k=new F(this,M,p,b,Q,q,B,void 0,O,H));const o=!T||T(M);if(M.animations&&o&&k.appendAnimations(M,M.animations),M.getAnimatables){const H=M.getAnimatables();for(let M=0;M<H.length;M++)this.beginAnimation(H[M],p,b,Q,q,B,k,u,T,O)}return k.reset(),k},i.prototype.beginHierarchyAnimation=function(M,p,b,Q,q){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,u=arguments.length>7?arguments[7]:void 0,T=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],O=arguments.length>9?arguments[9]:void 0,H=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const F=M.getDescendants(p),o=[];o.push(this.beginAnimation(M,b,Q,q,B,k,u,T,O,void 0,H));for(const W of F)o.push(this.beginAnimation(W,b,Q,q,B,k,u,T,O,void 0,H));return o},i.prototype.beginDirectAnimation=function(M,p,b,Q,q){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(B<0){const M=b;b=Q,Q=M,B=-B}return b>Q&&(B=-B),new F(this,M,b,Q,q,B,arguments.length>6?arguments[6]:void 0,p,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},i.prototype.beginDirectHierarchyAnimation=function(M,p,b,Q,q,B,k,u,T){let O=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const H=M.getDescendants(p),F=[];F.push(this.beginDirectAnimation(M,b,Q,q,B,k,u,T,O));for(const o of H)F.push(this.beginDirectAnimation(o,b,Q,q,B,k,u,T,O));return F},i.prototype.getAnimatableByTarget=function(M){for(let p=0;p<this._activeAnimatables.length;p++)if(this._activeAnimatables[p].target===M)return this._activeAnimatables[p];return null},i.prototype.getAllAnimatablesByTarget=function(M){const p=[];for(let b=0;b<this._activeAnimatables.length;b++)this._activeAnimatables[b].target===M&&p.push(this._activeAnimatables[b]);return p},i.prototype.stopAnimation=function(M,p,b){const Q=this.getAllAnimatablesByTarget(M);for(const q of Q)q.stop(p,b)},i.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let M=0;M<this._activeAnimatables.length;M++)this._activeAnimatables[M].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const M of this.animationGroups)M.stop()});class K{getClassName(){return"TargetedAnimation"}serialize(){const M={};return M.animation=this.animation.serialize(),M.targetId=this.target.id,M}}class D{get mask(){return this._mask}set mask(M){this._mask!==M&&(this._mask=M,this.syncWithMask(!0))}syncWithMask(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||M){this._numActiveAnimatables=0;for(let M=0;M<this._animatables.length;++M){const p=this._animatables[M];!this.mask||this.mask.disabled||this.mask.retainsTarget(p.target.name)?(this._numActiveAnimatables++,p.paused&&p.restart()):p.paused||p.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let M=0;M<this._animatables.length;++M){const p=this._animatables[M];this.mask.retainsTarget(p.target.name)||(p.stop(),this._animatables.splice(M,1),--M)}for(let M=0;M<this._targetedAnimations.length;M++){const p=this._targetedAnimations[M];this.mask.retainsTarget(p.target.name)||(this._targetedAnimations.splice(M,1),--M)}}}get from(){return this._from}set from(M){if(this._from!==M){this._from=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].fromFrame=this._from}}}get to(){return this._to}set to(M){if(this._to!==M){this._to=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(M){if(this._speedRatio!==M){this._speedRatio=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(M){if(this._loopAnimation!==M){this._loopAnimation=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(M){if(this._isAdditive!==M){this._isAdditive=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(M){this._weight!==M&&(this._weight=M,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(M){if(this._playOrder!==M&&(this._playOrder=M,this._animatables.length>0)){for(let M=0;M<this._animatables.length;M++)this._animatables[M].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(M){if(this._enableBlending!==M&&(this._enableBlending=M,null!==M))for(let p=0;p<this._targetedAnimations.length;++p)this._targetedAnimations[p].animation.enableBlending=M}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(M){if(this._blendingSpeed!==M&&(this._blendingSpeed=M,null!==M))for(let p=0;p<this._targetedAnimations.length;++p)this._targetedAnimations[p].animation.blendingSpeed=M}getLength(M,p){M=M??this._from;return((p=p??this._to)-M)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(M){let p=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=arguments.length>3?arguments[3]:void 0;if(0===M.length)return null;Q=Q??M[0].weight;let q=Number.MAX_VALUE,B=-Number.MAX_VALUE;if(b)for(const u of M)u.from<q&&(q=u.from),u.to>B&&(B=u.to);const k=new D(M[0].name+"_merged",M[0]._scene,Q);for(const u of M){b&&u.normalize(q,B);for(const M of u.targetedAnimations)k.addTargetedAnimation(M.animation,M.target);p&&u.dispose()}return k}constructor(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=M,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new q.b,this.onAnimationLoopObservable=new q.b,this.onAnimationGroupLoopObservable=new q.b,this.onAnimationGroupEndObservable=new q.b,this.onAnimationGroupPauseObservable=new q.b,this.onAnimationGroupPlayObservable=new q.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=p||B.c.LastCreatedScene,this._weight=b,this._playOrder=Q,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(M,p){const b=new K;b.animation=M,b.target=p;const Q=M.getKeys();return this._from>Q[0].frame&&(this._from=Q[0].frame),this._to<Q[Q.length-1].frame&&(this._to=Q[Q.length-1].frame),null!==this._enableBlending&&(M.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(M.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(b),this._shouldStart=!0,b}removeTargetedAnimation(M){for(let p=this._targetedAnimations.length-1;p>-1;p--){this._targetedAnimations[p].animation===M&&this._targetedAnimations.splice(p,1)}}normalize(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==M&&(M=this._from),null==p&&(p=this._to);for(let b=0;b<this._targetedAnimations.length;b++){const Q=this._targetedAnimations[b].animation.getKeys(),q=Q[0],B=Q[Q.length-1];if(q.frame>M){const p={frame:M,value:q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation};Q.splice(0,0,p)}if(B.frame<p){const M={frame:p,value:B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation};Q.push(M)}}return this._from=M,this._to=p,this}_processLoop(M,p,b){M.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(p),this._animationLoopFlags[b]||(this._animationLoopFlags[b]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0],p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0,Q=arguments.length>3?arguments[3]:void 0,q=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=M,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let B=0;B<this._targetedAnimations.length;B++){const k=this._targetedAnimations[B],u=this._scene.beginDirectAnimation(k.target,[k.animation],void 0!==b?b:this._from,void 0!==Q?Q:this._to,M,p,void 0,void 0,void 0!==q?q:this._isAdditive);u.weight=this._weight,u.playOrder=this._playOrder,u.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(k),this._checkAnimationGroupEnded(u)},this._processLoop(u,k,B),this._animatables.push(u)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=p,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let M=0;M<this._animatables.length;M++){this._animatables[M].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(M){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==M&&(this.loopAnimation=M),this.restart()):(this.stop(),this.start(M,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let M=0;M<this._animatables.length;M++){this._animatables[M].reset()}return this}restart(){if(!this._isStarted)return this;for(let M=0;M<this._animatables.length;M++){this._animatables[M].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const p=this._animatables.slice();for(let Q=0;Q<p.length;Q++)p[Q].stop(void 0,void 0,!0,M);let b=0;for(let Q=0;Q<this._scene._activeAnimatables.length;Q++){const p=this._scene._activeAnimatables[Q];p._runtimeAnimations.length>0?this._scene._activeAnimatables[b++]=p:M&&this._checkAnimationGroupEnded(p,M)}return this._scene._activeAnimatables.length=b,this._isStarted=!1,this}setWeightForAllAnimatables(M){for(let p=0;p<this._animatables.length;p++){this._animatables[p].weight=M}return this}syncAllAnimationsWith(M){for(let p=0;p<this._animatables.length;p++){this._animatables[p].syncWith(M)}return this}goToFrame(M){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].goToFrame(M,p)}return this}getCurrentFrame(){var M;return(null===(M=this.animatables[0])||void 0===M?void 0:M.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const M=this._scene.animationGroups.indexOf(this);if(M>-1&&this._scene.animationGroups.splice(M,1),this._parentContainer){const M=this._parentContainer.animationGroups.indexOf(this);M>-1&&this._parentContainer.animationGroups.splice(M,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(M){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._animatables.indexOf(M);b>-1&&this._animatables.splice(b,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,p||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(M,p){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=new D(M||this.name,this._scene,this._weight,this._playOrder);Q._from=this.from,Q._to=this.to,Q._speedRatio=this.speedRatio,Q._loopAnimation=this.loopAnimation,Q._isAdditive=this.isAdditive,Q._enableBlending=this.enableBlending,Q._blendingSpeed=this.blendingSpeed,Q.metadata=this.metadata,Q.mask=this.mask;for(const q of this._targetedAnimations)Q.addTargetedAnimation(b?q.animation.clone():q.animation,p?p(q.target):q.target);return Q}serialize(){const M={};M.name=this.name,M.from=this.from,M.to=this.to,M.speedRatio=this.speedRatio,M.loopAnimation=this.loopAnimation,M.isAdditive=this.isAdditive,M.weight=this.weight,M.playOrder=this.playOrder,M.enableBlending=this.enableBlending,M.blendingSpeed=this.blendingSpeed,M.targetedAnimations=[];for(let p=0;p<this.targetedAnimations.length;p++){const b=this.targetedAnimations[p];M.targetedAnimations[p]=b.serialize()}return k.c&&k.c.HasTags(this)&&(M.tags=k.c.GetTags(this)),this.metadata&&(M.metadata=this.metadata),M}static Parse(M,p){const b=new D(M.name,p,M.weight,M.playOrder);for(let q=0;q<M.targetedAnimations.length;q++){const B=M.targetedAnimations[q],k=Q.c.Parse(B.animation),u=B.targetId;if("influence"===B.animation.property){const M=p.getMorphTargetById(u);M&&b.addTargetedAnimation(k,M)}else{const M=p.getNodeById(u);null!=M&&b.addTargetedAnimation(k,M)}}return k.c&&k.c.AddTagsTo(b,M.tags),null!==M.from&&null!==M.to&&b.normalize(M.from,M.to),void 0!==M.speedRatio&&(b._speedRatio=M.speedRatio),void 0!==M.loopAnimation&&(b._loopAnimation=M.loopAnimation),void 0!==M.isAdditive&&(b._isAdditive=M.isAdditive),void 0!==M.weight&&(b._weight=M.weight),void 0!==M.playOrder&&(b._playOrder=M.playOrder),void 0!==M.enableBlending&&(b._enableBlending=M.enableBlending),void 0!==M.blendingSpeed&&(b._blendingSpeed=M.blendingSpeed),void 0!==M.metadata&&(b.metadata=M.metadata),b}static MakeAnimationAdditive(M,p,b){let q;q="object"===typeof p?p:{referenceFrame:p,range:b,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let B=M;q.cloneOriginalAnimationGroup&&(B=M.clone(q.clonedAnimationGroupName||B.name));const k=B.targetedAnimations;for(let u=0;u<k.length;u++){const M=k[u];M.animation=Q.c.MakeAnimationAdditive(M.animation,q)}if(B.isAdditive=!0,q.clipKeys){let M=Number.MAX_VALUE,p=-Number.MAX_VALUE;const b=B.targetedAnimations;for(let Q=0;Q<b.length;Q++){const q=b[Q].animation.getKeys();M>q[0].frame&&(M=q[0].frame),p<q[q.length-1].frame&&(p=q[q.length-1].frame)}B._from=M,B._to=p}return B}static ClipKeys(M,p,b,Q,q){const B=M.clone(Q||M.name);return D.ClipKeysInPlace(B,p,b,q)}static ClipKeysInPlace(M,p,b,Q){return D.ClipInPlace(M,p,b,Q,!1)}static ClipFrames(M,p,b,Q,q){const B=M.clone(Q||M.name);return D.ClipFramesInPlace(B,p,b,q)}static ClipFramesInPlace(M,p,b,Q){return D.ClipInPlace(M,p,b,Q,!0)}static ClipInPlace(M,p,b,Q){let q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],B=Number.MAX_VALUE,k=-Number.MAX_VALUE;const u=M.targetedAnimations;for(let T=0;T<u.length;T++){const M=u[T],O=Q?M.animation:M.animation.clone();q&&(O.createKeyForFrame(p),O.createKeyForFrame(b));const H=O.getKeys(),F=[];let o=Number.MAX_VALUE;for(let Q=0;Q<H.length;Q++){const M=H[Q];if(!q&&Q>=p&&Q<=b||q&&M.frame>=p&&M.frame<=b){const p={frame:M.frame,value:M.value.clone?M.value.clone():M.value,inTangent:M.inTangent,outTangent:M.outTangent,interpolation:M.interpolation,lockedTangent:M.lockedTangent};o===Number.MAX_VALUE&&(o=p.frame),p.frame-=o,F.push(p)}}0!==F.length?(B>F[0].frame&&(B=F[0].frame),k<F[F.length-1].frame&&(k=F[F.length-1].frame),O.setKeys(F,!0),M.animation=O):(u.splice(T,1),T--)}return M._from=B,M._to=k,M}getClassName(){return"AnimationGroup"}toString(M){let p="Name: "+this.name;return p+=", type: "+this.getClassName(),M&&(p+=", from: "+this._from,p+=", to: "+this._to,p+=", isStarted: "+this._isStarted,p+=", speedRatio: "+this._speedRatio,p+=", targetedAnimations length: "+this._targetedAnimations.length,p+=", animatables length: "+this._animatables),p}}}}]);