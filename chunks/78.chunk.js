"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[78],{15533:(E,U,g)=>{g.r(U),g.d(U,{AnimationGroup:()=>V,TargetedAnimation:()=>h});var N=g(12853),L=g(12174),D=g(12205),S=g(12370),u=g(13972),s=g(12334);class C{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(E,U,g,L){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=U,this._target=E,this._scene=g,this._host=L,this._activeTargets=[],U._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===N.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=s.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const E={frame:0,value:this._minValue};this._keys.splice(0,0,E)}if(this._target instanceof Array){let E=0;for(const U of this._target)this._preparePath(U,E),this._getOriginalValues(E),E++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const D=U.getEvents();if(D&&D.length>0)for(const N of D)this._events.push(N._clone());this._enableBlending=E&&E.animationPropertiesOverride?E.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const g=this._animation.targetPropertyPath;if(g.length>1){let N=E;for(let E=0;E<g.length-1;E++){const U=g[E];if(N=N[U],void 0===N)throw new Error(`Invalid property (${U}) in property path (${g.join(".")})`)}this._targetPath=g[g.length-1],this._activeTargets[U]=N}else this._targetPath=g[0],this._activeTargets[U]=E;if(void 0===this._activeTargets[U][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${g.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let E=0;for(const U of this._target)void 0!==this._originalValue[E]&&this._setValue(U,this._activeTargets[E],this._originalValue[E],-1,E),E++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let E=0;E<this._events.length;E++)this._events[E].isDone=!1}isStopped(){return this._stopped}dispose(){const E=this._animation.runtimeAnimations.indexOf(this);E>-1&&this._animation.runtimeAnimations.splice(E,1)}setValue(E,U){if(this._targetIsArray)for(let g=0;g<this._target.length;g++){const N=this._target[g];this._setValue(N,this._activeTargets[g],E,U,g)}else this._setValue(this._target,this._directTarget,E,U,0)}_getOriginalValues(){let E,U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const g=this._activeTargets[U];E=g.getLocalMatrix&&"_matrix"===this._targetPath?g.getLocalMatrix():g[this._targetPath],E&&E.clone?this._originalValue[U]=E.clone():this._originalValue[U]=E}_registerTargetForLateAnimationBinding(E,U){const g=E.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(g),g._lateAnimationHolders||(g._lateAnimationHolders={}),g._lateAnimationHolders[E.targetPath]||(g._lateAnimationHolders[E.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:U}),E.isAdditive?(g._lateAnimationHolders[E.targetPath].additiveAnimations.push(E),g._lateAnimationHolders[E.targetPath].totalAdditiveWeight+=E.weight):(g._lateAnimationHolders[E.targetPath].animations.push(E),g._lateAnimationHolders[E.targetPath].totalWeight+=E.weight)}_setValue(E,U,g,L,D){if(this._currentActiveTarget=U,this._weight=L,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const E=U[this._targetPath];E.clone?this._originalBlendValue=E.clone():this._originalBlendValue=E}this._originalBlendValue.m?N.c.AllowMatrixDecomposeForInterpolation?this._currentValue?s.Matrix.DecomposeLerpToRef(this._originalBlendValue,g,this._blendingFactor,this._currentValue):this._currentValue=s.Matrix.DecomposeLerp(this._originalBlendValue,g,this._blendingFactor):this._currentValue?s.Matrix.LerpToRef(this._originalBlendValue,g,this._blendingFactor,this._currentValue):this._currentValue=s.Matrix.Lerp(this._originalBlendValue,g,this._blendingFactor):this._currentValue=N.c._UniversalLerp(this._originalBlendValue,g,this._blendingFactor);const L=E&&E.animationPropertiesOverride?E.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=L}else this._currentValue?this._currentValue.D?this._currentValue.D(g):this._currentValue=g:null!==g&&void 0!==g&&g.clone?this._currentValue=g.clone():this._currentValue=g;-1!==L?this._registerTargetForLateAnimationBinding(this,this._originalValue[D]):this._animationState.loopMode===N.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[D],U[this._targetPath]):U[this._targetPath]=this._originalValue[D]+this._currentValue:U[this._targetPath]=this._currentValue,E.qC&&E.qC(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const g=this._animation.getKeys();E<g[0].frame?E=g[0].frame:E>g[g.length-1].frame&&(E=g[g.length-1].frame);const N=this._events;if(N.length)for(let D=0;D<N.length;D++)N[D].onlyOnce||(N[D].isDone=N[D].frame<E);this._currentFrame=E;const L=this._animation._interpolate(E,this._animationState);this.setValue(L,U)}_prepareForSpeedRatioChange(E){const U=this._previousElapsedTime*(this._animation.framePerSecond*E)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-U}animate(E,U,g,L,D){let S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const u=this._animation,s=u.targetPropertyPath;if(!s||s.length<1)return this._stopped=!0,!1;let C,B=!0;const P=this._events;let F=0;if(this._coreRuntimeAnimation)F=g-U,C=this._coreRuntimeAnimation.currentFrame,this._currentFrame=C,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let S;(U<this._minFrame||U>this._maxFrame)&&(U=this._minFrame),(g<this._minFrame||g>this._maxFrame)&&(g=this._maxFrame),F=g-U;let s=E*(u.framePerSecond*D)/1e3+this._absoluteFrameOffset,f=0,d=!1;const I=L&&this._animationState.loopMode===N.c.ANIMATIONLOOPMODE_YOYO;if(I){const E=(s-U)/F,g=Math.sin(E*Math.PI);s=Math.abs(g)*F+U;const N=g>=0?1:-1;this._yoyoDirection!==N&&(d=!0),this._yoyoDirection=N}if(this._previousElapsedTime=E,this._previousAbsoluteFrame=s,!L&&g>=U&&(s>=F&&D>0||s<=0&&D<0))B=!1,f=u._getKeyValue(this._maxValue);else if(!L&&U>=g&&(s<=F&&D<0||s>=0&&D>0))B=!1,f=u._getKeyValue(this._minValue);else if(this._animationState.loopMode!==N.c.ANIMATIONLOOPMODE_CYCLE){const E=g.toString()+U.toString();if(!this._offsetsCache[E]){this._animationState.repeatCount=0,this._animationState.loopMode=N.c.ANIMATIONLOOPMODE_CYCLE;const L=u._interpolate(U,this._animationState),D=u._interpolate(g,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),u.dataType){case N.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[E]=D-L;break;case N.c.ANIMATIONTYPE_QUATERNION:case N.c.ANIMATIONTYPE_VECTOR3:case N.c.ANIMATIONTYPE_VECTOR2:case N.c.ANIMATIONTYPE_SIZE:case N.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[E]=D.IU(L)}this._highLimitsCache[E]=D}f=this._highLimitsCache[E],S=this._offsetsCache[E]}if(void 0===S)switch(u.dataType){case N.c.ANIMATIONTYPE_FLOAT:S=0;break;case N.c.ANIMATIONTYPE_QUATERNION:S=N.h;break;case N.c.ANIMATIONTYPE_VECTOR3:S=N.q;break;case N.c.ANIMATIONTYPE_VECTOR2:S=N.o;break;case N.c.ANIMATIONTYPE_SIZE:S=N.l;break;case N.c.ANIMATIONTYPE_COLOR3:S=N.d;break;case N.c.ANIMATIONTYPE_COLOR4:S=N.g}if(this._host&&this._host.syncRoot){const E=this._host.syncRoot;C=U+F*((E.masterFrame-E.fromFrame)/(E.toFrame-E.fromFrame))}else C=s>0&&U>g||s<0&&U<g?B&&0!==F?g+s%F:U:B&&0!==F?U+s%F:g;if(!I&&(D>0&&this.currentFrame>C||D<0&&this.currentFrame<C)||I&&d){this._onLoop();for(let E=0;E<P.length;E++)P[E].onlyOnce||(P[E].isDone=!1);this._animationState.key=D>0?0:u.getKeys().length-1}this._currentFrame=C,this._animationState.repeatCount=0===F?0:s/F|0,this._animationState.highLimitValue=f,this._animationState.offsetValue=S}const f=u._interpolate(C,this._animationState);if(this.setValue(f,S),P.length)for(let N=0;N<P.length;N++)if(F>=0&&C>=P[N].frame&&P[N].frame>=U||F<0&&C<=P[N].frame&&P[N].frame<=U){const E=P[N];E.isDone||(E.onlyOnce&&(P.splice(N,1),N--),E.isDone=!0,E.action(C))}return B||(this._stopped=!0),B}}var B=g(12197);class P{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(E){this._weight=-1!==E?Math.min(Math.max(E,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(E){for(let U=0;U<this._runtimeAnimations.length;U++){this._runtimeAnimations[U]._prepareForSpeedRatioChange(E)}this._speedRatio=E,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(E,U){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,D=arguments.length>4&&void 0!==arguments[4]&&arguments[4],S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,s=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,B=arguments.length>9&&void 0!==arguments[9]&&arguments[9],P=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=U,this.fromFrame=g,this.toFrame=N,this.loopAnimation=D,this.onAnimationEnd=u,this.onAnimationLoop=C,this.isAdditive=B,this.playOrder=P,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Cu=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new L.b,this.onAnimationLoopObservable=new L.b,this._scene=E,s&&this.appendAnimations(U,s),this._speedRatio=S,E._activeAnimatables.push(this)}syncWith(E){if(this._syncRoot=E,E){const E=this._scene._activeAnimatables.indexOf(this);E>-1&&(this._scene._activeAnimatables.splice(E,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(E,U){for(let g=0;g<U.length;g++){const N=U[g],L=new C(E,N,this._scene,this);L._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(L)}}getAnimationByTargetProperty(E){const U=this._runtimeAnimations;for(let g=0;g<U.length;g++)if(U[g].animation.targetProperty===E)return U[g].animation;return null}getRuntimeAnimationByTargetProperty(E){const U=this._runtimeAnimations;for(let g=0;g<U.length;g++)if(U[g].animation.targetProperty===E)return U[g];return null}reset(){const E=this._runtimeAnimations;for(let U=0;U<E.length;U++)E[U].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(E){const U=this._runtimeAnimations;for(let g=0;g<U.length;g++)U[g].animation.enableBlending=!0,U[g].animation.blendingSpeed=E}disableBlending(){const E=this._runtimeAnimations;for(let U=0;U<E.length;U++)E[U].animation.enableBlending=!1}goToFrame(E){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const g=this._runtimeAnimations;if(g[0]){const U=g[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??g[0].currentFrame;const N=0===this.speedRatio?0:(E-this._frameToSyncFromJump)/U*1e3/this.speedRatio;this._manualJumpDelay=-N}for(let N=0;N<g.length;N++)g[N].goToFrame(E,U?this._weight:-1);this._goToFrame=E}get paused(){return this.Cu}pause(){this.Cu||(this.Cu=!0)}restart(){this.Cu=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(E,U){let g=arguments.length>2&&void 0!==arguments[2]&&arguments[2],N=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(E||U){const L=this._scene._activeAnimatables.indexOf(this);if(L>-1){const D=this._runtimeAnimations;for(let g=D.length-1;g>=0;g--){const N=D[g];E&&N.animation.name!=E||(U&&!U(N.target)||(N.dispose(),D.splice(g,1)))}0==D.length&&(g||this._scene._activeAnimatables.splice(L,1),N||this._raiseOnAnimationEnd())}}else{const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){g||this._scene._activeAnimatables.splice(E,1);const U=this._runtimeAnimations;for(let E=0;E<U.length;E++)U[E].dispose();this._runtimeAnimations.length=0,N||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((E=>{this.onAnimationEndObservable.add((()=>{E(this)}),void 0,void 0,this,!0)}))}_animate(E){if(this.Cu)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=E),!0;if(null===this._localDelayOffset?(this._localDelayOffset=E,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=E-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let U=!1;const g=this._runtimeAnimations;let N;for(N=0;N<g.length;N++){const L=g[N].animate(E-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);U=U||L}if(this.animationStarted=U,!U){if(this.disposeOnEnd)for(N=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(N,1),N=0;N<g.length;N++)g[N].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return U}}function F(E){if(0===E.totalWeight&&0===E.totalAdditiveWeight)return E.originalValue;let U=1;const g=s.TmpVectors.dU[0],N=s.TmpVectors.dU[1],L=s.TmpVectors.Quaternion[0];let D=0;const S=E.animations[0],u=E.originalValue;let C=1,B=!1;if(E.totalWeight<1)C=1-E.totalWeight,u.decompose(N,L,g);else{if(D=1,U=E.totalWeight,C=S.weight/U,1==C){if(!E.totalAdditiveWeight)return S.currentValue;B=!0}S.currentValue.decompose(N,L,g)}if(!B){N.scaleInPlace(C),g.scaleInPlace(C),L.scaleInPlace(C);for(let S=D;S<E.animations.length;S++){const D=E.animations[S];if(0===D.weight)continue;C=D.weight/U;const u=s.TmpVectors.dU[2],B=s.TmpVectors.dU[3],P=s.TmpVectors.Quaternion[1];D.currentValue.decompose(B,P,u),B.scaleAndAddToRef(C,N),P.scaleAndAddToRef(s.Quaternion.Dot(L,P)>0?C:-C,L),u.scaleAndAddToRef(C,g)}L.normalize()}for(let F=0;F<E.additiveAnimations.length;F++){const U=E.additiveAnimations[F];if(0===U.weight)continue;const D=s.TmpVectors.dU[2],S=s.TmpVectors.dU[3],u=s.TmpVectors.Quaternion[1];U.currentValue.decompose(S,u,D),S.multiplyToRef(N,S),s.dU.LerpToRef(N,S,U.weight,N),L.multiplyToRef(u,u),s.Quaternion.SlerpToRef(L,u,U.weight,L),D.scaleAndAddToRef(U.weight,g)}const P=S?S._animationState.workValue:s.TmpVectors.Matrix[0].clone();return s.Matrix.ComposeToRef(N,L,g,P),P}function f(E,U){if(0===E.totalWeight&&0===E.totalAdditiveWeight)return U;const g=E.animations[0],N=E.originalValue;let L=U;if(0===E.totalWeight&&E.totalAdditiveWeight>0)L.D(N);else if(1===E.animations.length){if(s.Quaternion.SlerpToRef(N,g.currentValue,Math.min(1,E.totalWeight),L),0===E.totalAdditiveWeight)return L}else if(E.animations.length>1){let g,D,S=1;if(E.totalWeight<1){const U=1-E.totalWeight;g=[],D=[],g.push(N),D.push(U)}else{if(2===E.animations.length&&(s.Quaternion.SlerpToRef(E.animations[0].currentValue,E.animations[1].currentValue,E.animations[1].weight/E.totalWeight,U),0===E.totalAdditiveWeight))return U;g=[],D=[],S=E.totalWeight}for(let U=0;U<E.animations.length;U++){const N=E.animations[U];g.push(N.currentValue),D.push(N.weight/S)}let u=0;for(let E=0;E<g.length;)E?(u+=D[E],s.Quaternion.SlerpToRef(L,g[E],D[E]/u,L),E++):(s.Quaternion.SlerpToRef(g[E],g[E+1],D[E+1]/(D[E]+D[E+1]),U),L=U,u=D[E]+D[E+1],E+=2)}for(let D=0;D<E.additiveAnimations.length;D++){const U=E.additiveAnimations[D];0!==U.weight&&(L.multiplyToRef(U.currentValue,s.TmpVectors.Quaternion[0]),s.Quaternion.SlerpToRef(L,s.TmpVectors.Quaternion[0],U.weight,L))}return L}var d,I,y=g(12573);d=y.c,(I=u.b)&&(I.prototype.copyAnimationRange=function(E,U,g){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3],D=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new N.c(this.name,"_matrix",E.animations[0].framePerSecond,N.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const S=E.animations[0].getRange(U);if(!S)return!1;const u=S.from,s=S.to,C=E.animations[0].getKeys(),B=E.length,P=E.getParent(),F=this.getParent(),f=L&&P&&B&&this.length&&B!==this.length,d=f&&F&&P?F.length/P.length:1,I=L&&!F&&D&&(1!==D.x||1!==D.y||1!==D.z),y=this.animations[0].getKeys();let h,V,e;for(let N=0,x=C.length;N<x;N++)h=C[N],h.frame>=u&&h.frame<=s&&(L?(e=h.value.clone(),f?(V=e.getTranslation(),e.setTranslation(V.scaleInPlace(d))):I&&D?(V=e.getTranslation(),e.setTranslation(V.multiplyInPlace(D))):e=h.value):e=h.value,y.push({frame:h.frame+g,value:e}));return this.animations[0].createRange(U,u+g,s+g),!0}),d&&(d.prototype._animate=function(E){if(!this.animationsEnabled)return;const U=B.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=U}this.deltaTime=void 0!==E?E:this.useConstantAnimationDeltaTime?16:(U-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=U;const g=this._activeAnimatables;if(0===g.length)return;this._animationTime+=this.deltaTime;const L=this._animationTime;for(let N=0;N<g.length;N++){const E=g[N];!E._animate(L)&&E.disposeOnEnd&&N--}!function(E){if(E._registeredForLateAnimationBindings.length){for(let U=0;U<E._registeredForLateAnimationBindings.length;U++){const g=E._registeredForLateAnimationBindings.data[U];for(const E in g._lateAnimationHolders){const U=g._lateAnimationHolders[E],L=U.animations[0],D=U.originalValue;if(void 0===D||null===D)continue;const S=N.c.AllowMatrixDecomposeForInterpolation&&D.m;let u=g[E];if(S)u=F(U);else if(void 0!==D.w)u=f(U,u||s.Quaternion.Identity());else{let E=0,g=1;const S=L&&L._animationState.loopMode===N.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(U.totalWeight<1)u=S?D.clone?D.clone():D:L&&D.scale?D.scale(1-U.totalWeight):L?D*(1-U.totalWeight):D.clone?D.clone():D;else if(L){g=U.totalWeight;const N=L.weight/g;u=1!==N?L.currentValue.scale?L.currentValue.scale(N):L.currentValue*N:L.currentValue,S&&(u.addToRef?u.addToRef(D,u):u+=D),E=1}for(let N=E;N<U.animations.length;N++){const E=U.animations[N],L=E.weight/g;L&&(E.currentValue.scaleAndAddToRef?E.currentValue.scaleAndAddToRef(L,u):u+=E.currentValue*L)}for(let N=0;N<U.additiveAnimations.length;N++){const E=U.additiveAnimations[N],g=E.weight;g&&(E.currentValue.scaleAndAddToRef?E.currentValue.scaleAndAddToRef(g,u):u+=E.currentValue*g)}}g[E]=u}g._lateAnimationHolders={}}E._registeredForLateAnimationBindings.reset()}}(this)},d.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((E,U)=>E.playOrder-U.playOrder))},d.prototype.beginWeightedAnimation=function(E,U,g){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,L=arguments.length>4?arguments[4]:void 0,D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,S=arguments.length>6?arguments[6]:void 0,u=arguments.length>7?arguments[7]:void 0,s=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,B=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const P=this.beginAnimation(E,U,g,L,D,S,u,!1,s,C,B);return P.weight=N,P},d.prototype.beginAnimation=function(E,U,g,N){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,D=arguments.length>5?arguments[5]:void 0,S=arguments.length>6?arguments[6]:void 0,u=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],s=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,B=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(L<0){const E=U;U=g,g=E,L=-L}U>g&&(L=-L),u&&this.stopAnimation(E,void 0,s),S||(S=new P(this,E,U,g,N,L,D,void 0,C,B));const F=!s||s(E);if(E.animations&&F&&S.appendAnimations(E,E.animations),E.getAnimatables){const B=E.getAnimatables();for(let E=0;E<B.length;E++)this.beginAnimation(B[E],U,g,N,L,D,S,u,s,C)}return S.reset(),S},d.prototype.beginHierarchyAnimation=function(E,U,g,N,L){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,S=arguments.length>6?arguments[6]:void 0,u=arguments.length>7?arguments[7]:void 0,s=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],C=arguments.length>9?arguments[9]:void 0,B=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const P=E.getDescendants(U),F=[];F.push(this.beginAnimation(E,g,N,L,D,S,u,s,C,void 0,B));for(const f of P)F.push(this.beginAnimation(f,g,N,L,D,S,u,s,C,void 0,B));return F},d.prototype.beginDirectAnimation=function(E,U,g,N,L){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(D<0){const E=g;g=N,N=E,D=-D}return g>N&&(D=-D),new P(this,E,g,N,L,D,arguments.length>6?arguments[6]:void 0,U,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},d.prototype.beginDirectHierarchyAnimation=function(E,U,g,N,L,D,S,u,s){let C=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const B=E.getDescendants(U),P=[];P.push(this.beginDirectAnimation(E,g,N,L,D,S,u,s,C));for(const F of B)P.push(this.beginDirectAnimation(F,g,N,L,D,S,u,s,C));return P},d.prototype.getAnimatableByTarget=function(E){for(let U=0;U<this._activeAnimatables.length;U++)if(this._activeAnimatables[U].target===E)return this._activeAnimatables[U];return null},d.prototype.getAllAnimatablesByTarget=function(E){const U=[];for(let g=0;g<this._activeAnimatables.length;g++)this._activeAnimatables[g].target===E&&U.push(this._activeAnimatables[g]);return U},d.prototype.stopAnimation=function(E,U,g){const N=this.getAllAnimatablesByTarget(E);for(const L of N)L.stop(U,g)},d.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let E=0;E<this._activeAnimatables.length;E++)this._activeAnimatables[E].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const E of this.animationGroups)E.stop()});class h{getClassName(){return"TargetedAnimation"}serialize(){const E={};return E.animation=this.animation.serialize(),E.targetId=this.target.id,E}}class V{get mask(){return this._mask}set mask(E){this._mask!==E&&(this._mask=E,this.syncWithMask(!0))}syncWithMask(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||E){this._numActiveAnimatables=0;for(let E=0;E<this._animatables.length;++E){const U=this._animatables[E];!this.mask||this.mask.disabled||this.mask.retainsTarget(U.target.name)?(this._numActiveAnimatables++,U.paused&&U.restart()):U.paused||U.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let E=0;E<this._animatables.length;++E){const U=this._animatables[E];this.mask.retainsTarget(U.target.name)||(U.stop(),this._animatables.splice(E,1),--E)}for(let E=0;E<this._targetedAnimations.length;E++){const U=this._targetedAnimations[E];this.mask.retainsTarget(U.target.name)||(this._targetedAnimations.splice(E,1),--E)}}}get from(){return this._from}set from(E){if(this._from!==E){this._from=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].fromFrame=this._from}}}get to(){return this._to}set to(E){if(this._to!==E){this._to=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(E){if(this._speedRatio!==E){this._speedRatio=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(E){if(this._loopAnimation!==E){this._loopAnimation=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(E){if(this._isAdditive!==E){this._isAdditive=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(E){this._weight!==E&&(this._weight=E,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(E){if(this._playOrder!==E&&(this._playOrder=E,this._animatables.length>0)){for(let E=0;E<this._animatables.length;E++)this._animatables[E].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(E){if(this._enableBlending!==E&&(this._enableBlending=E,null!==E))for(let U=0;U<this._targetedAnimations.length;++U)this._targetedAnimations[U].animation.enableBlending=E}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(E){if(this._blendingSpeed!==E&&(this._blendingSpeed=E,null!==E))for(let U=0;U<this._targetedAnimations.length;++U)this._targetedAnimations[U].animation.blendingSpeed=E}getLength(E,U){E=E??this._from;return((U=U??this._to)-E)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(E){let U=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],g=arguments.length>2&&void 0!==arguments[2]&&arguments[2],N=arguments.length>3?arguments[3]:void 0;if(0===E.length)return null;N=N??E[0].weight;let L=Number.MAX_VALUE,D=-Number.MAX_VALUE;if(g)for(const u of E)u.from<L&&(L=u.from),u.to>D&&(D=u.to);const S=new V(E[0].name+"_merged",E[0]._scene,N);for(const u of E){g&&u.normalize(L,D);for(const E of u.targetedAnimations)S.addTargetedAnimation(E.animation,E.target);U&&u.dispose()}return S}constructor(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=E,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new L.b,this.onAnimationLoopObservable=new L.b,this.onAnimationGroupLoopObservable=new L.b,this.onAnimationGroupEndObservable=new L.b,this.onAnimationGroupPauseObservable=new L.b,this.onAnimationGroupPlayObservable=new L.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=U||D.b.LastCreatedScene,this._weight=g,this._playOrder=N,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(E,U){const g=new h;g.animation=E,g.target=U;const N=E.getKeys();return this._from>N[0].frame&&(this._from=N[0].frame),this._to<N[N.length-1].frame&&(this._to=N[N.length-1].frame),null!==this._enableBlending&&(E.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(E.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(g),this._shouldStart=!0,g}removeTargetedAnimation(E){for(let U=this._targetedAnimations.length-1;U>-1;U--){this._targetedAnimations[U].animation===E&&this._targetedAnimations.splice(U,1)}}normalize(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==E&&(E=this._from),null==U&&(U=this._to);for(let g=0;g<this._targetedAnimations.length;g++){const N=this._targetedAnimations[g].animation.getKeys(),L=N[0],D=N[N.length-1];if(L.frame>E){const U={frame:E,value:L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation};N.splice(0,0,U)}if(D.frame<U){const E={frame:U,value:D.value,inTangent:D.inTangent,outTangent:D.outTangent,interpolation:D.interpolation};N.push(E)}}return this._from=E,this._to=U,this}_processLoop(E,U,g){E.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(U),this._animationLoopFlags[g]||(this._animationLoopFlags[g]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0],U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,g=arguments.length>2?arguments[2]:void 0,N=arguments.length>3?arguments[3]:void 0,L=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=E,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let D=0;D<this._targetedAnimations.length;D++){const S=this._targetedAnimations[D],u=this._scene.beginDirectAnimation(S.target,[S.animation],void 0!==g?g:this._from,void 0!==N?N:this._to,E,U,void 0,void 0,void 0!==L?L:this._isAdditive);u.weight=this._weight,u.playOrder=this._playOrder,u.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(S),this._checkAnimationGroupEnded(u)},this._processLoop(u,S,D),this._animatables.push(u)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=U,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let E=0;E<this._animatables.length;E++){this._animatables[E].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(E){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==E&&(this.loopAnimation=E),this.restart()):(this.stop(),this.start(E,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].reset()}return this}restart(){if(!this._isStarted)return this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const U=this._animatables.slice();for(let N=0;N<U.length;N++)U[N].stop(void 0,void 0,!0,E);let g=0;for(let N=0;N<this._scene._activeAnimatables.length;N++){const U=this._scene._activeAnimatables[N];U._runtimeAnimations.length>0?this._scene._activeAnimatables[g++]=U:E&&this._checkAnimationGroupEnded(U,E)}return this._scene._activeAnimatables.length=g,this._isStarted=!1,this}setWeightForAllAnimatables(E){for(let U=0;U<this._animatables.length;U++){this._animatables[U].weight=E}return this}syncAllAnimationsWith(E){for(let U=0;U<this._animatables.length;U++){this._animatables[U].syncWith(E)}return this}goToFrame(E){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let g=0;g<this._animatables.length;g++){this._animatables[g].goToFrame(E,U)}return this}getCurrentFrame(){var E;return(null===(E=this.animatables[0])||void 0===E?void 0:E.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const E=this._scene.animationGroups.indexOf(this);if(E>-1&&this._scene.animationGroups.splice(E,1),this._parentContainer){const E=this._parentContainer.animationGroups.indexOf(this);E>-1&&this._parentContainer.animationGroups.splice(E,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(E){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const g=this._animatables.indexOf(E);g>-1&&this._animatables.splice(g,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,U||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(E,U){let g=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const N=new V(E||this.name,this._scene,this._weight,this._playOrder);N._from=this.from,N._to=this.to,N._speedRatio=this.speedRatio,N._loopAnimation=this.loopAnimation,N._isAdditive=this.isAdditive,N._enableBlending=this.enableBlending,N._blendingSpeed=this.blendingSpeed,N.metadata=this.metadata,N.mask=this.mask;for(const L of this._targetedAnimations)N.addTargetedAnimation(g?L.animation.clone():L.animation,U?U(L.target):L.target);return N}serialize(){const E={};E.name=this.name,E.from=this.from,E.to=this.to,E.speedRatio=this.speedRatio,E.loopAnimation=this.loopAnimation,E.isAdditive=this.isAdditive,E.weight=this.weight,E.playOrder=this.playOrder,E.enableBlending=this.enableBlending,E.blendingSpeed=this.blendingSpeed,E.targetedAnimations=[];for(let U=0;U<this.targetedAnimations.length;U++){const g=this.targetedAnimations[U];E.targetedAnimations[U]=g.serialize()}return S.c&&S.c.HasTags(this)&&(E.tags=S.c.GetTags(this)),this.metadata&&(E.metadata=this.metadata),E}static Parse(E,U){const g=new V(E.name,U,E.weight,E.playOrder);for(let L=0;L<E.targetedAnimations.length;L++){const D=E.targetedAnimations[L],S=N.c.Parse(D.animation),u=D.targetId;if("influence"===D.animation.property){const E=U.getMorphTargetById(u);E&&g.addTargetedAnimation(S,E)}else{const E=U.getNodeById(u);null!=E&&g.addTargetedAnimation(S,E)}}return S.c&&S.c.AddTagsTo(g,E.tags),null!==E.from&&null!==E.to&&g.normalize(E.from,E.to),void 0!==E.speedRatio&&(g._speedRatio=E.speedRatio),void 0!==E.loopAnimation&&(g._loopAnimation=E.loopAnimation),void 0!==E.isAdditive&&(g._isAdditive=E.isAdditive),void 0!==E.weight&&(g._weight=E.weight),void 0!==E.playOrder&&(g._playOrder=E.playOrder),void 0!==E.enableBlending&&(g._enableBlending=E.enableBlending),void 0!==E.blendingSpeed&&(g._blendingSpeed=E.blendingSpeed),void 0!==E.metadata&&(g.metadata=E.metadata),g}static MakeAnimationAdditive(E,U,g){let L;L="object"===typeof U?U:{referenceFrame:U,range:g,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let D=E;L.cloneOriginalAnimationGroup&&(D=E.clone(L.clonedAnimationGroupName||D.name));const S=D.targetedAnimations;for(let u=0;u<S.length;u++){const E=S[u];E.animation=N.c.MakeAnimationAdditive(E.animation,L)}if(D.isAdditive=!0,L.clipKeys){let E=Number.MAX_VALUE,U=-Number.MAX_VALUE;const g=D.targetedAnimations;for(let N=0;N<g.length;N++){const L=g[N].animation.getKeys();E>L[0].frame&&(E=L[0].frame),U<L[L.length-1].frame&&(U=L[L.length-1].frame)}D._from=E,D._to=U}return D}static ClipKeys(E,U,g,N,L){const D=E.clone(N||E.name);return V.ClipKeysInPlace(D,U,g,L)}static ClipKeysInPlace(E,U,g,N){return V.ClipInPlace(E,U,g,N,!1)}static ClipFrames(E,U,g,N,L){const D=E.clone(N||E.name);return V.ClipFramesInPlace(D,U,g,L)}static ClipFramesInPlace(E,U,g,N){return V.ClipInPlace(E,U,g,N,!0)}static ClipInPlace(E,U,g,N){let L=arguments.length>4&&void 0!==arguments[4]&&arguments[4],D=Number.MAX_VALUE,S=-Number.MAX_VALUE;const u=E.targetedAnimations;for(let s=0;s<u.length;s++){const E=u[s],C=N?E.animation:E.animation.clone();L&&(C.createKeyForFrame(U),C.createKeyForFrame(g));const B=C.getKeys(),P=[];let F=Number.MAX_VALUE;for(let N=0;N<B.length;N++){const E=B[N];if(!L&&N>=U&&N<=g||L&&E.frame>=U&&E.frame<=g){const U={frame:E.frame,value:E.value.clone?E.value.clone():E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation,lockedTangent:E.lockedTangent};F===Number.MAX_VALUE&&(F=U.frame),U.frame-=F,P.push(U)}}0!==P.length?(D>P[0].frame&&(D=P[0].frame),S<P[P.length-1].frame&&(S=P[P.length-1].frame),C.setKeys(P,!0),E.animation=C):(u.splice(s,1),s--)}return E._from=D,E._to=S,E}getClassName(){return"AnimationGroup"}toString(E){let U="Name: "+this.name;return U+=", type: "+this.getClassName(),E&&(U+=", from: "+this._from,U+=", to: "+this._to,U+=", isStarted: "+this._isStarted,U+=", speedRatio: "+this._speedRatio,U+=", targetedAnimations length: "+this._targetedAnimations.length,U+=", animatables length: "+this._animatables),U}}}}]);