"use strict";(self.hwpa2z1pqte=self.hwpa2z1pqte||[]).push([[78],{16103:(h,R,l)=>{l.r(R),l.d(R,{AnimationGroup:()=>f,TargetedAnimation:()=>t});var j=l(13399),a=l(12696),D=l(12749),U=l(12944),F=l(14521),w=l(12900);class mh{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(h,R,l,a){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=R,this._target=h,this._scene=l,this._host=a,this._activeTargets=[],R._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===j.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=w.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const h={frame:0,value:this._minValue};this._keys.splice(0,0,h)}if(this._target instanceof Array){let h=0;for(const R of this._target)this._preparePath(R,h),this._getOriginalValues(h),h++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const D=R.getEvents();if(D&&D.length>0)for(const j of D)this._events.push(j._clone());this._enableBlending=h&&h.animationPropertiesOverride?h.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const l=this._animation.targetPropertyPath;if(l.length>1){let j=h;for(let h=0;h<l.length-1;h++){const R=l[h];if(j=j[R],void 0===j)throw new Error(`Invalid property (${R}) in property path (${l.join(".")})`)}this._targetPath=l[l.length-1],this._activeTargets[R]=j}else this._targetPath=l[0],this._activeTargets[R]=h;if(void 0===this._activeTargets[R][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${l.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let h=0;for(const R of this._target)void 0!==this._originalValue[h]&&this._setValue(R,this._activeTargets[h],this._originalValue[h],-1,h),h++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let h=0;h<this._events.length;h++)this._events[h].isDone=!1}isStopped(){return this._stopped}dispose(){const h=this._animation.runtimeAnimations.indexOf(this);h>-1&&this._animation.runtimeAnimations.splice(h,1)}setValue(h,R){if(this._targetIsArray)for(let l=0;l<this._target.length;l++){const j=this._target[l];this._setValue(j,this._activeTargets[l],h,R,l)}else this._setValue(this._target,this._directTarget,h,R,0)}_getOriginalValues(){let h,R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const l=this._activeTargets[R];h=l.getLocalMatrix&&"_matrix"===this._targetPath?l.getLocalMatrix():l[this._targetPath],h&&h.clone?this._originalValue[R]=h.clone():this._originalValue[R]=h}_registerTargetForLateAnimationBinding(h,R){const l=h.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(l),l._lateAnimationHolders||(l._lateAnimationHolders={}),l._lateAnimationHolders[h.targetPath]||(l._lateAnimationHolders[h.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:R}),h.isAdditive?(l._lateAnimationHolders[h.targetPath].additiveAnimations.push(h),l._lateAnimationHolders[h.targetPath].totalAdditiveWeight+=h.weight):(l._lateAnimationHolders[h.targetPath].animations.push(h),l._lateAnimationHolders[h.targetPath].totalWeight+=h.weight)}_setValue(h,R,l,a,D){if(this._currentActiveTarget=R,this._weight=a,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const h=R[this._targetPath];h.clone?this._originalBlendValue=h.clone():this._originalBlendValue=h}this._originalBlendValue.m?j.b.AllowMatrixDecomposeForInterpolation?this._currentValue?w.Matrix.DecomposeLerpToRef(this._originalBlendValue,l,this._blendingFactor,this._currentValue):this._currentValue=w.Matrix.DecomposeLerp(this._originalBlendValue,l,this._blendingFactor):this._currentValue?w.Matrix.LerpToRef(this._originalBlendValue,l,this._blendingFactor,this._currentValue):this._currentValue=w.Matrix.Lerp(this._originalBlendValue,l,this._blendingFactor):this._currentValue=j.b._UniversalLerp(this._originalBlendValue,l,this._blendingFactor);const a=h&&h.animationPropertiesOverride?h.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=a}else this._currentValue?this._currentValue.D?this._currentValue.D(l):this._currentValue=l:null!==l&&void 0!==l&&l.clone?this._currentValue=l.clone():this._currentValue=l;-1!==a?this._registerTargetForLateAnimationBinding(this,this._originalValue[D]):this._animationState.loopMode===j.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[D],R[this._targetPath]):R[this._targetPath]=this._originalValue[D]+this._currentValue:R[this._targetPath]=this._currentValue,h.Vm&&h.Vm(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const l=this._animation.getKeys();h<l[0].frame?h=l[0].frame:h>l[l.length-1].frame&&(h=l[l.length-1].frame);const j=this._events;if(j.length)for(let D=0;D<j.length;D++)j[D].onlyOnce||(j[D].isDone=j[D].frame<h);this._currentFrame=h;const a=this._animation._interpolate(h,this._animationState);this.setValue(a,R)}_prepareForSpeedRatioChange(h){const R=this._previousElapsedTime*(this._animation.framePerSecond*h)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-R}animate(h,R,l,a,D){let U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const F=this._animation,w=F.targetPropertyPath;if(!w||w.length<1)return this._stopped=!0,!1;let mh,u=!0;const c=this._events;let J=0;if(this._coreRuntimeAnimation)J=l-R,mh=this._coreRuntimeAnimation.currentFrame,this._currentFrame=mh,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let U;(R<this._minFrame||R>this._maxFrame)&&(R=this._minFrame),(l<this._minFrame||l>this._maxFrame)&&(l=this._maxFrame),J=l-R;let w=h*(F.framePerSecond*D)/1e3+this._absoluteFrameOffset,q=0,Q=!1;const Y=a&&this._animationState.loopMode===j.b.ANIMATIONLOOPMODE_YOYO;if(Y){const h=(w-R)/J,l=Math.sin(h*Math.PI);w=Math.abs(l)*J+R;const j=l>=0?1:-1;this._yoyoDirection!==j&&(Q=!0),this._yoyoDirection=j}if(this._previousElapsedTime=h,this._previousAbsoluteFrame=w,!a&&l>=R&&(w>=J&&D>0||w<=0&&D<0))u=!1,q=F._getKeyValue(this._maxValue);else if(!a&&R>=l&&(w<=J&&D<0||w>=0&&D>0))u=!1,q=F._getKeyValue(this._minValue);else if(this._animationState.loopMode!==j.b.ANIMATIONLOOPMODE_CYCLE){const h=l.toString()+R.toString();if(!this._offsetsCache[h]){this._animationState.repeatCount=0,this._animationState.loopMode=j.b.ANIMATIONLOOPMODE_CYCLE;const a=F._interpolate(R,this._animationState),D=F._interpolate(l,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),F.dataType){case j.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[h]=D-a;break;case j.b.ANIMATIONTYPE_QUATERNION:case j.b.ANIMATIONTYPE_VECTOR3:case j.b.ANIMATIONTYPE_VECTOR2:case j.b.ANIMATIONTYPE_SIZE:case j.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[h]=D.fR(a)}this._highLimitsCache[h]=D}q=this._highLimitsCache[h],U=this._offsetsCache[h]}if(void 0===U)switch(F.dataType){case j.b.ANIMATIONTYPE_FLOAT:U=0;break;case j.b.ANIMATIONTYPE_QUATERNION:U=j.g;break;case j.b.ANIMATIONTYPE_VECTOR3:U=j.n;break;case j.b.ANIMATIONTYPE_VECTOR2:U=j.m;break;case j.b.ANIMATIONTYPE_SIZE:U=j.j;break;case j.b.ANIMATIONTYPE_COLOR3:U=j.d;break;case j.b.ANIMATIONTYPE_COLOR4:U=j.e}if(this._host&&this._host.syncRoot){const h=this._host.syncRoot;mh=R+J*((h.masterFrame-h.fromFrame)/(h.toFrame-h.fromFrame))}else mh=w>0&&R>l||w<0&&R<l?u&&0!==J?l+w%J:R:u&&0!==J?R+w%J:l;if(!Y&&(D>0&&this.currentFrame>mh||D<0&&this.currentFrame<mh)||Y&&Q){this._onLoop();for(let h=0;h<c.length;h++)c[h].onlyOnce||(c[h].isDone=!1);this._animationState.key=D>0?0:F.getKeys().length-1}this._currentFrame=mh,this._animationState.repeatCount=0===J?0:w/J|0,this._animationState.highLimitValue=q,this._animationState.offsetValue=U}const q=F._interpolate(mh,this._animationState);if(this.setValue(q,U),c.length)for(let j=0;j<c.length;j++)if(J>=0&&mh>=c[j].frame&&c[j].frame>=R||J<0&&mh<=c[j].frame&&c[j].frame<=R){const h=c[j];h.isDone||(h.onlyOnce&&(c.splice(j,1),j--),h.isDone=!0,h.action(mh))}return u||(this._stopped=!0),u}}var u=l(12724);class c{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(h){this._weight=-1!==h?Math.min(Math.max(h,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(h){for(let R=0;R<this._runtimeAnimations.length;R++){this._runtimeAnimations[R]._prepareForSpeedRatioChange(h)}this._speedRatio=h,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(h,R){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,D=arguments.length>4&&void 0!==arguments[4]&&arguments[4],U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,F=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,mh=arguments.length>8?arguments[8]:void 0,u=arguments.length>9&&void 0!==arguments[9]&&arguments[9],c=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=R,this.fromFrame=l,this.toFrame=j,this.loopAnimation=D,this.onAnimationEnd=F,this.onAnimationLoop=mh,this.isAdditive=u,this.playOrder=c,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.BU=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new a.d,this.onAnimationLoopObservable=new a.d,this._scene=h,w&&this.appendAnimations(R,w),this._speedRatio=U,h._activeAnimatables.push(this)}syncWith(h){if(this._syncRoot=h,h){const h=this._scene._activeAnimatables.indexOf(this);h>-1&&(this._scene._activeAnimatables.splice(h,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(h,R){for(let l=0;l<R.length;l++){const j=R[l],a=new mh(h,j,this._scene,this);a._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(a)}}getAnimationByTargetProperty(h){const R=this._runtimeAnimations;for(let l=0;l<R.length;l++)if(R[l].animation.targetProperty===h)return R[l].animation;return null}getRuntimeAnimationByTargetProperty(h){const R=this._runtimeAnimations;for(let l=0;l<R.length;l++)if(R[l].animation.targetProperty===h)return R[l];return null}reset(){const h=this._runtimeAnimations;for(let R=0;R<h.length;R++)h[R].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(h){const R=this._runtimeAnimations;for(let l=0;l<R.length;l++)R[l].animation.enableBlending=!0,R[l].animation.blendingSpeed=h}disableBlending(){const h=this._runtimeAnimations;for(let R=0;R<h.length;R++)h[R].animation.enableBlending=!1}goToFrame(h){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const l=this._runtimeAnimations;if(l[0]){const R=l[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??l[0].currentFrame;const j=0===this.speedRatio?0:(h-this._frameToSyncFromJump)/R*1e3/this.speedRatio;this._manualJumpDelay=-j}for(let j=0;j<l.length;j++)l[j].goToFrame(h,R?this._weight:-1);this._goToFrame=h}get paused(){return this.BU}pause(){this.BU||(this.BU=!0)}restart(){this.BU=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(h,R){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],j=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(h||R){const a=this._scene._activeAnimatables.indexOf(this);if(a>-1){const D=this._runtimeAnimations;for(let l=D.length-1;l>=0;l--){const j=D[l];h&&j.animation.name!=h||(R&&!R(j.target)||(j.dispose(),D.splice(l,1)))}0==D.length&&(l||this._scene._activeAnimatables.splice(a,1),j||this._raiseOnAnimationEnd())}}else{const h=this._scene._activeAnimatables.indexOf(this);if(h>-1){l||this._scene._activeAnimatables.splice(h,1);const R=this._runtimeAnimations;for(let h=0;h<R.length;h++)R[h].dispose();this._runtimeAnimations.length=0,j||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((h=>{this.onAnimationEndObservable.add((()=>{h(this)}),void 0,void 0,this,!0)}))}_animate(h){if(this.BU)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=h),!0;if(null===this._localDelayOffset?(this._localDelayOffset=h,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=h-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let R=!1;const l=this._runtimeAnimations;let j;for(j=0;j<l.length;j++){const a=l[j].animate(h-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);R=R||a}if(this.animationStarted=R,!R){if(this.disposeOnEnd)for(j=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(j,1),j=0;j<l.length;j++)l[j].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return R}}function J(h){if(0===h.totalWeight&&0===h.totalAdditiveWeight)return h.originalValue;let R=1;const l=w.TmpVectors.tR[0],j=w.TmpVectors.tR[1],a=w.TmpVectors.Quaternion[0];let D=0;const U=h.animations[0],F=h.originalValue;let mh=1,u=!1;if(h.totalWeight<1)mh=1-h.totalWeight,F.decompose(j,a,l);else{if(D=1,R=h.totalWeight,mh=U.weight/R,1==mh){if(!h.totalAdditiveWeight)return U.currentValue;u=!0}U.currentValue.decompose(j,a,l)}if(!u){j.scaleInPlace(mh),l.scaleInPlace(mh),a.scaleInPlace(mh);for(let U=D;U<h.animations.length;U++){const D=h.animations[U];if(0===D.weight)continue;mh=D.weight/R;const F=w.TmpVectors.tR[2],u=w.TmpVectors.tR[3],c=w.TmpVectors.Quaternion[1];D.currentValue.decompose(u,c,F),u.scaleAndAddToRef(mh,j),c.scaleAndAddToRef(w.Quaternion.Dot(a,c)>0?mh:-mh,a),F.scaleAndAddToRef(mh,l)}a.normalize()}for(let J=0;J<h.additiveAnimations.length;J++){const R=h.additiveAnimations[J];if(0===R.weight)continue;const D=w.TmpVectors.tR[2],U=w.TmpVectors.tR[3],F=w.TmpVectors.Quaternion[1];R.currentValue.decompose(U,F,D),U.multiplyToRef(j,U),w.tR.LerpToRef(j,U,R.weight,j),a.multiplyToRef(F,F),w.Quaternion.SlerpToRef(a,F,R.weight,a),D.scaleAndAddToRef(R.weight,l)}const c=U?U._animationState.workValue:w.TmpVectors.Matrix[0].clone();return w.Matrix.ComposeToRef(j,a,l,c),c}function q(h,R){if(0===h.totalWeight&&0===h.totalAdditiveWeight)return R;const l=h.animations[0],j=h.originalValue;let a=R;if(0===h.totalWeight&&h.totalAdditiveWeight>0)a.D(j);else if(1===h.animations.length){if(w.Quaternion.SlerpToRef(j,l.currentValue,Math.min(1,h.totalWeight),a),0===h.totalAdditiveWeight)return a}else if(h.animations.length>1){let l,D,U=1;if(h.totalWeight<1){const R=1-h.totalWeight;l=[],D=[],l.push(j),D.push(R)}else{if(2===h.animations.length&&(w.Quaternion.SlerpToRef(h.animations[0].currentValue,h.animations[1].currentValue,h.animations[1].weight/h.totalWeight,R),0===h.totalAdditiveWeight))return R;l=[],D=[],U=h.totalWeight}for(let R=0;R<h.animations.length;R++){const j=h.animations[R];l.push(j.currentValue),D.push(j.weight/U)}let F=0;for(let h=0;h<l.length;)h?(F+=D[h],w.Quaternion.SlerpToRef(a,l[h],D[h]/F,a),h++):(w.Quaternion.SlerpToRef(l[h],l[h+1],D[h+1]/(D[h]+D[h+1]),R),a=R,F=D[h]+D[h+1],h+=2)}for(let D=0;D<h.additiveAnimations.length;D++){const R=h.additiveAnimations[D];0!==R.weight&&(a.multiplyToRef(R.currentValue,w.TmpVectors.Quaternion[0]),w.Quaternion.SlerpToRef(a,w.TmpVectors.Quaternion[0],R.weight,a))}return a}var Q,Y,s=l(13126);Q=s.e,(Y=F.d)&&(Y.prototype.copyAnimationRange=function(h,R,l){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],D=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new j.b(this.name,"_matrix",h.animations[0].framePerSecond,j.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const U=h.animations[0].getRange(R);if(!U)return!1;const F=U.from,w=U.to,mh=h.animations[0].getKeys(),u=h.length,c=h.getParent(),J=this.getParent(),q=a&&c&&u&&this.length&&u!==this.length,Q=q&&J&&c?J.length/c.length:1,Y=a&&!J&&D&&(1!==D.x||1!==D.y||1!==D.z),s=this.animations[0].getKeys();let t,f,T;for(let j=0,E=mh.length;j<E;j++)t=mh[j],t.frame>=F&&t.frame<=w&&(a?(T=t.value.clone(),q?(f=T.getTranslation(),T.setTranslation(f.scaleInPlace(Q))):Y&&D?(f=T.getTranslation(),T.setTranslation(f.multiplyInPlace(D))):T=t.value):T=t.value,s.push({frame:t.frame+l,value:T}));return this.animations[0].createRange(R,F+l,w+l),!0}),Q&&(Q.prototype._animate=function(h){if(!this.animationsEnabled)return;const R=u.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=R}this.deltaTime=void 0!==h?h:this.useConstantAnimationDeltaTime?16:(R-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=R;const l=this._activeAnimatables;if(0===l.length)return;this._animationTime+=this.deltaTime;const a=this._animationTime;for(let j=0;j<l.length;j++){const h=l[j];!h._animate(a)&&h.disposeOnEnd&&j--}!function(h){if(h._registeredForLateAnimationBindings.length){for(let R=0;R<h._registeredForLateAnimationBindings.length;R++){const l=h._registeredForLateAnimationBindings.data[R];for(const h in l._lateAnimationHolders){const R=l._lateAnimationHolders[h],a=R.animations[0],D=R.originalValue;if(void 0===D||null===D)continue;const U=j.b.AllowMatrixDecomposeForInterpolation&&D.m;let F=l[h];if(U)F=J(R);else if(void 0!==D.w)F=q(R,F||w.Quaternion.Identity());else{let h=0,l=1;const U=a&&a._animationState.loopMode===j.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(R.totalWeight<1)F=U?D.clone?D.clone():D:a&&D.scale?D.scale(1-R.totalWeight):a?D*(1-R.totalWeight):D.clone?D.clone():D;else if(a){l=R.totalWeight;const j=a.weight/l;F=1!==j?a.currentValue.scale?a.currentValue.scale(j):a.currentValue*j:a.currentValue,U&&(F.addToRef?F.addToRef(D,F):F+=D),h=1}for(let j=h;j<R.animations.length;j++){const h=R.animations[j],a=h.weight/l;a&&(h.currentValue.scaleAndAddToRef?h.currentValue.scaleAndAddToRef(a,F):F+=h.currentValue*a)}for(let j=0;j<R.additiveAnimations.length;j++){const h=R.additiveAnimations[j],l=h.weight;l&&(h.currentValue.scaleAndAddToRef?h.currentValue.scaleAndAddToRef(l,F):F+=h.currentValue*l)}}l[h]=F}l._lateAnimationHolders={}}h._registeredForLateAnimationBindings.reset()}}(this)},Q.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((h,R)=>h.playOrder-R.playOrder))},Q.prototype.beginWeightedAnimation=function(h,R,l){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4?arguments[4]:void 0,D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,U=arguments.length>6?arguments[6]:void 0,F=arguments.length>7?arguments[7]:void 0,w=arguments.length>8?arguments[8]:void 0,mh=arguments.length>9?arguments[9]:void 0,u=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const c=this.beginAnimation(h,R,l,a,D,U,F,!1,w,mh,u);return c.weight=j,c},Q.prototype.beginAnimation=function(h,R,l,j){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,D=arguments.length>5?arguments[5]:void 0,U=arguments.length>6?arguments[6]:void 0,F=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],w=arguments.length>8?arguments[8]:void 0,mh=arguments.length>9?arguments[9]:void 0,u=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(a<0){const h=R;R=l,l=h,a=-a}R>l&&(a=-a),F&&this.stopAnimation(h,void 0,w),U||(U=new c(this,h,R,l,j,a,D,void 0,mh,u));const J=!w||w(h);if(h.animations&&J&&U.appendAnimations(h,h.animations),h.getAnimatables){const u=h.getAnimatables();for(let h=0;h<u.length;h++)this.beginAnimation(u[h],R,l,j,a,D,U,F,w,mh)}return U.reset(),U},Q.prototype.beginHierarchyAnimation=function(h,R,l,j,a){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,U=arguments.length>6?arguments[6]:void 0,F=arguments.length>7?arguments[7]:void 0,w=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],mh=arguments.length>9?arguments[9]:void 0,u=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const c=h.getDescendants(R),J=[];J.push(this.beginAnimation(h,l,j,a,D,U,F,w,mh,void 0,u));for(const q of c)J.push(this.beginAnimation(q,l,j,a,D,U,F,w,mh,void 0,u));return J},Q.prototype.beginDirectAnimation=function(h,R,l,j,a){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(D<0){const h=l;l=j,j=h,D=-D}return l>j&&(D=-D),new c(this,h,l,j,a,D,arguments.length>6?arguments[6]:void 0,R,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},Q.prototype.beginDirectHierarchyAnimation=function(h,R,l,j,a,D,U,F,w){let mh=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const u=h.getDescendants(R),c=[];c.push(this.beginDirectAnimation(h,l,j,a,D,U,F,w,mh));for(const J of u)c.push(this.beginDirectAnimation(J,l,j,a,D,U,F,w,mh));return c},Q.prototype.getAnimatableByTarget=function(h){for(let R=0;R<this._activeAnimatables.length;R++)if(this._activeAnimatables[R].target===h)return this._activeAnimatables[R];return null},Q.prototype.getAllAnimatablesByTarget=function(h){const R=[];for(let l=0;l<this._activeAnimatables.length;l++)this._activeAnimatables[l].target===h&&R.push(this._activeAnimatables[l]);return R},Q.prototype.stopAnimation=function(h,R,l){const j=this.getAllAnimatablesByTarget(h);for(const a of j)a.stop(R,l)},Q.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let h=0;h<this._activeAnimatables.length;h++)this._activeAnimatables[h].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const h of this.animationGroups)h.stop()});class t{getClassName(){return"TargetedAnimation"}serialize(){const h={};return h.animation=this.animation.serialize(),h.targetId=this.target.id,h}}class f{get mask(){return this._mask}set mask(h){this._mask!==h&&(this._mask=h,this.syncWithMask(!0))}syncWithMask(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||h){this._numActiveAnimatables=0;for(let h=0;h<this._animatables.length;++h){const R=this._animatables[h];!this.mask||this.mask.disabled||this.mask.retainsTarget(R.target.name)?(this._numActiveAnimatables++,R.paused&&R.restart()):R.paused||R.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let h=0;h<this._animatables.length;++h){const R=this._animatables[h];this.mask.retainsTarget(R.target.name)||(R.stop(),this._animatables.splice(h,1),--h)}for(let h=0;h<this._targetedAnimations.length;h++){const R=this._targetedAnimations[h];this.mask.retainsTarget(R.target.name)||(this._targetedAnimations.splice(h,1),--h)}}}get from(){return this._from}set from(h){if(this._from!==h){this._from=h;for(let h=0;h<this._animatables.length;h++){this._animatables[h].fromFrame=this._from}}}get to(){return this._to}set to(h){if(this._to!==h){this._to=h;for(let h=0;h<this._animatables.length;h++){this._animatables[h].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(h){if(this._speedRatio!==h){this._speedRatio=h;for(let h=0;h<this._animatables.length;h++){this._animatables[h].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(h){if(this._loopAnimation!==h){this._loopAnimation=h;for(let h=0;h<this._animatables.length;h++){this._animatables[h].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(h){if(this._isAdditive!==h){this._isAdditive=h;for(let h=0;h<this._animatables.length;h++){this._animatables[h].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(h){this._weight!==h&&(this._weight=h,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(h){if(this._playOrder!==h&&(this._playOrder=h,this._animatables.length>0)){for(let h=0;h<this._animatables.length;h++)this._animatables[h].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(h){if(this._enableBlending!==h&&(this._enableBlending=h,null!==h))for(let R=0;R<this._targetedAnimations.length;++R)this._targetedAnimations[R].animation.enableBlending=h}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(h){if(this._blendingSpeed!==h&&(this._blendingSpeed=h,null!==h))for(let R=0;R<this._targetedAnimations.length;++R)this._targetedAnimations[R].animation.blendingSpeed=h}getLength(h,R){h=h??this._from;return((R=R??this._to)-h)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(h){let R=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],j=arguments.length>3?arguments[3]:void 0;if(0===h.length)return null;j=j??h[0].weight;let a=Number.MAX_VALUE,D=-Number.MAX_VALUE;if(l)for(const F of h)F.from<a&&(a=F.from),F.to>D&&(D=F.to);const U=new f(h[0].name+"_merged",h[0]._scene,j);for(const F of h){l&&F.normalize(a,D);for(const h of F.targetedAnimations)U.addTargetedAnimation(h.animation,h.target);R&&F.dispose()}return U}constructor(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=h,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new a.d,this.onAnimationLoopObservable=new a.d,this.onAnimationGroupLoopObservable=new a.d,this.onAnimationGroupEndObservable=new a.d,this.onAnimationGroupPauseObservable=new a.d,this.onAnimationGroupPlayObservable=new a.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=R||D.b.LastCreatedScene,this._weight=l,this._playOrder=j,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(h,R){const l=new t;l.animation=h,l.target=R;const j=h.getKeys();return this._from>j[0].frame&&(this._from=j[0].frame),this._to<j[j.length-1].frame&&(this._to=j[j.length-1].frame),null!==this._enableBlending&&(h.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(h.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(l),this._shouldStart=!0,l}removeTargetedAnimation(h){for(let R=this._targetedAnimations.length-1;R>-1;R--){this._targetedAnimations[R].animation===h&&this._targetedAnimations.splice(R,1)}}normalize(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==h&&(h=this._from),null==R&&(R=this._to);for(let l=0;l<this._targetedAnimations.length;l++){const j=this._targetedAnimations[l].animation.getKeys(),a=j[0],D=j[j.length-1];if(a.frame>h){const R={frame:h,value:a.value,inTangent:a.inTangent,outTangent:a.outTangent,interpolation:a.interpolation};j.splice(0,0,R)}if(D.frame<R){const h={frame:R,value:D.value,inTangent:D.inTangent,outTangent:D.outTangent,interpolation:D.interpolation};j.push(h)}}return this._from=h,this._to=R,this}_processLoop(h,R,l){h.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(R),this._animationLoopFlags[l]||(this._animationLoopFlags[l]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0],R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,l=arguments.length>2?arguments[2]:void 0,j=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=h,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let D=0;D<this._targetedAnimations.length;D++){const U=this._targetedAnimations[D],F=this._scene.beginDirectAnimation(U.target,[U.animation],void 0!==l?l:this._from,void 0!==j?j:this._to,h,R,void 0,void 0,void 0!==a?a:this._isAdditive);F.weight=this._weight,F.playOrder=this._playOrder,F.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(U),this._checkAnimationGroupEnded(F)},this._processLoop(F,U,D),this._animatables.push(F)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=R,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let h=0;h<this._animatables.length;h++){this._animatables[h].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(h){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==h&&(this.loopAnimation=h),this.restart()):(this.stop(),this.start(h,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let h=0;h<this._animatables.length;h++){this._animatables[h].reset()}return this}restart(){if(!this._isStarted)return this;for(let h=0;h<this._animatables.length;h++){this._animatables[h].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const R=this._animatables.slice();for(let j=0;j<R.length;j++)R[j].stop(void 0,void 0,!0,h);let l=0;for(let j=0;j<this._scene._activeAnimatables.length;j++){const R=this._scene._activeAnimatables[j];R._runtimeAnimations.length>0?this._scene._activeAnimatables[l++]=R:h&&this._checkAnimationGroupEnded(R,h)}return this._scene._activeAnimatables.length=l,this._isStarted=!1,this}setWeightForAllAnimatables(h){for(let R=0;R<this._animatables.length;R++){this._animatables[R].weight=h}return this}syncAllAnimationsWith(h){for(let R=0;R<this._animatables.length;R++){this._animatables[R].syncWith(h)}return this}goToFrame(h){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let l=0;l<this._animatables.length;l++){this._animatables[l].goToFrame(h,R)}return this}getCurrentFrame(){var h;return(null===(h=this.animatables[0])||void 0===h?void 0:h.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const h=this._scene.animationGroups.indexOf(this);if(h>-1&&this._scene.animationGroups.splice(h,1),this._parentContainer){const h=this._parentContainer.animationGroups.indexOf(this);h>-1&&this._parentContainer.animationGroups.splice(h,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(h){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const l=this._animatables.indexOf(h);l>-1&&this._animatables.splice(l,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,R||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(h,R){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const j=new f(h||this.name,this._scene,this._weight,this._playOrder);j._from=this.from,j._to=this.to,j._speedRatio=this.speedRatio,j._loopAnimation=this.loopAnimation,j._isAdditive=this.isAdditive,j._enableBlending=this.enableBlending,j._blendingSpeed=this.blendingSpeed,j.metadata=this.metadata,j.mask=this.mask;for(const a of this._targetedAnimations)j.addTargetedAnimation(l?a.animation.clone():a.animation,R?R(a.target):a.target);return j}serialize(){const h={};h.name=this.name,h.from=this.from,h.to=this.to,h.speedRatio=this.speedRatio,h.loopAnimation=this.loopAnimation,h.isAdditive=this.isAdditive,h.weight=this.weight,h.playOrder=this.playOrder,h.enableBlending=this.enableBlending,h.blendingSpeed=this.blendingSpeed,h.targetedAnimations=[];for(let R=0;R<this.targetedAnimations.length;R++){const l=this.targetedAnimations[R];h.targetedAnimations[R]=l.serialize()}return U.e&&U.e.HasTags(this)&&(h.tags=U.e.GetTags(this)),this.metadata&&(h.metadata=this.metadata),h}static Parse(h,R){const l=new f(h.name,R,h.weight,h.playOrder);for(let a=0;a<h.targetedAnimations.length;a++){const D=h.targetedAnimations[a],U=j.b.Parse(D.animation),F=D.targetId;if("influence"===D.animation.property){const h=R.getMorphTargetById(F);h&&l.addTargetedAnimation(U,h)}else{const h=R.getNodeById(F);null!=h&&l.addTargetedAnimation(U,h)}}return U.e&&U.e.AddTagsTo(l,h.tags),null!==h.from&&null!==h.to&&l.normalize(h.from,h.to),void 0!==h.speedRatio&&(l._speedRatio=h.speedRatio),void 0!==h.loopAnimation&&(l._loopAnimation=h.loopAnimation),void 0!==h.isAdditive&&(l._isAdditive=h.isAdditive),void 0!==h.weight&&(l._weight=h.weight),void 0!==h.playOrder&&(l._playOrder=h.playOrder),void 0!==h.enableBlending&&(l._enableBlending=h.enableBlending),void 0!==h.blendingSpeed&&(l._blendingSpeed=h.blendingSpeed),void 0!==h.metadata&&(l.metadata=h.metadata),l}static MakeAnimationAdditive(h,R,l){let a;a="object"===typeof R?R:{referenceFrame:R,range:l,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let D=h;a.cloneOriginalAnimationGroup&&(D=h.clone(a.clonedAnimationGroupName||D.name));const U=D.targetedAnimations;for(let F=0;F<U.length;F++){const h=U[F];h.animation=j.b.MakeAnimationAdditive(h.animation,a)}if(D.isAdditive=!0,a.clipKeys){let h=Number.MAX_VALUE,R=-Number.MAX_VALUE;const l=D.targetedAnimations;for(let j=0;j<l.length;j++){const a=l[j].animation.getKeys();h>a[0].frame&&(h=a[0].frame),R<a[a.length-1].frame&&(R=a[a.length-1].frame)}D._from=h,D._to=R}return D}static ClipKeys(h,R,l,j,a){const D=h.clone(j||h.name);return f.ClipKeysInPlace(D,R,l,a)}static ClipKeysInPlace(h,R,l,j){return f.ClipInPlace(h,R,l,j,!1)}static ClipFrames(h,R,l,j,a){const D=h.clone(j||h.name);return f.ClipFramesInPlace(D,R,l,a)}static ClipFramesInPlace(h,R,l,j){return f.ClipInPlace(h,R,l,j,!0)}static ClipInPlace(h,R,l,j){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],D=Number.MAX_VALUE,U=-Number.MAX_VALUE;const F=h.targetedAnimations;for(let w=0;w<F.length;w++){const h=F[w],mh=j?h.animation:h.animation.clone();a&&(mh.createKeyForFrame(R),mh.createKeyForFrame(l));const u=mh.getKeys(),c=[];let J=Number.MAX_VALUE;for(let j=0;j<u.length;j++){const h=u[j];if(!a&&j>=R&&j<=l||a&&h.frame>=R&&h.frame<=l){const R={frame:h.frame,value:h.value.clone?h.value.clone():h.value,inTangent:h.inTangent,outTangent:h.outTangent,interpolation:h.interpolation,lockedTangent:h.lockedTangent};J===Number.MAX_VALUE&&(J=R.frame),R.frame-=J,c.push(R)}}0!==c.length?(D>c[0].frame&&(D=c[0].frame),U<c[c.length-1].frame&&(U=c[c.length-1].frame),mh.setKeys(c,!0),h.animation=mh):(F.splice(w,1),w--)}return h._from=D,h._to=U,h}getClassName(){return"AnimationGroup"}toString(h){let R="Name: "+this.name;return R+=", type: "+this.getClassName(),h&&(R+=", from: "+this._from,R+=", to: "+this._to,R+=", isStarted: "+this._isStarted,R+=", speedRatio: "+this._speedRatio,R+=", targetedAnimations length: "+this._targetedAnimations.length,R+=", animatables length: "+this._animatables),R}}}}]);