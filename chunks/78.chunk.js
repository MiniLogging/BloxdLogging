"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[78],{14443:(H,O,S)=>{S.r(O),S.d(O,{AnimationGroup:()=>T,TargetedAnimation:()=>y});var t=S(11831),q=S(11140),p=S(11180),G=S(11346),U=S(12954),V=S(11301);class w{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(H,O,S,q){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=O,this._target=H,this._scene=S,this._host=q,this._activeTargets=[],O._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===t.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=V.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const H={frame:0,value:this._minValue};this._keys.splice(0,0,H)}if(this._target instanceof Array){let H=0;for(const O of this._target)this._preparePath(O,H),this._getOriginalValues(H),H++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const p=O.getEvents();if(p&&p.length>0)for(const t of p)this._events.push(t._clone());this._enableBlending=H&&H.animationPropertiesOverride?H.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const S=this._animation.targetPropertyPath;if(S.length>1){let t=H;for(let H=0;H<S.length-1;H++){const O=S[H];if(t=t[O],void 0===t)throw new Error(`Invalid property (${O}) in property path (${S.join(".")})`)}this._targetPath=S[S.length-1],this._activeTargets[O]=t}else this._targetPath=S[0],this._activeTargets[O]=H;if(void 0===this._activeTargets[O][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${S.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let H=0;for(const O of this._target)void 0!==this._originalValue[H]&&this._setValue(O,this._activeTargets[H],this._originalValue[H],-1,H),H++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let H=0;H<this._events.length;H++)this._events[H].isDone=!1}isStopped(){return this._stopped}dispose(){const H=this._animation.runtimeAnimations.indexOf(this);H>-1&&this._animation.runtimeAnimations.splice(H,1)}setValue(H,O){if(this._targetIsArray)for(let S=0;S<this._target.length;S++){const t=this._target[S];this._setValue(t,this._activeTargets[S],H,O,S)}else this._setValue(this._target,this._directTarget,H,O,0)}_getOriginalValues(){let H,O=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const S=this._activeTargets[O];H=S.getLocalMatrix&&"_matrix"===this._targetPath?S.getLocalMatrix():S[this._targetPath],H&&H.clone?this._originalValue[O]=H.clone():this._originalValue[O]=H}_registerTargetForLateAnimationBinding(H,O){const S=H.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(S),S._lateAnimationHolders||(S._lateAnimationHolders={}),S._lateAnimationHolders[H.targetPath]||(S._lateAnimationHolders[H.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:O}),H.isAdditive?(S._lateAnimationHolders[H.targetPath].additiveAnimations.push(H),S._lateAnimationHolders[H.targetPath].totalAdditiveWeight+=H.weight):(S._lateAnimationHolders[H.targetPath].animations.push(H),S._lateAnimationHolders[H.targetPath].totalWeight+=H.weight)}_setValue(H,O,S,q,p){if(this._currentActiveTarget=O,this._weight=q,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const H=O[this._targetPath];H.clone?this._originalBlendValue=H.clone():this._originalBlendValue=H}this._originalBlendValue.m?t.d.AllowMatrixDecomposeForInterpolation?this._currentValue?V.Matrix.DecomposeLerpToRef(this._originalBlendValue,S,this._blendingFactor,this._currentValue):this._currentValue=V.Matrix.DecomposeLerp(this._originalBlendValue,S,this._blendingFactor):this._currentValue?V.Matrix.LerpToRef(this._originalBlendValue,S,this._blendingFactor,this._currentValue):this._currentValue=V.Matrix.Lerp(this._originalBlendValue,S,this._blendingFactor):this._currentValue=t.d._UniversalLerp(this._originalBlendValue,S,this._blendingFactor);const q=H&&H.animationPropertiesOverride?H.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=q}else this._currentValue?this._currentValue.t?this._currentValue.t(S):this._currentValue=S:null!==S&&void 0!==S&&S.clone?this._currentValue=S.clone():this._currentValue=S;-1!==q?this._registerTargetForLateAnimationBinding(this,this._originalValue[p]):this._animationState.loopMode===t.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[p],O[this._targetPath]):O[this._targetPath]=this._originalValue[p]+this._currentValue:O[this._targetPath]=this._currentValue,H.kw&&H.kw(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const S=this._animation.getKeys();H<S[0].frame?H=S[0].frame:H>S[S.length-1].frame&&(H=S[S.length-1].frame);const t=this._events;if(t.length)for(let p=0;p<t.length;p++)t[p].onlyOnce||(t[p].isDone=t[p].frame<H);this._currentFrame=H;const q=this._animation._interpolate(H,this._animationState);this.setValue(q,O)}_prepareForSpeedRatioChange(H){const O=this._previousElapsedTime*(this._animation.framePerSecond*H)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-O}animate(H,O,S,q,p){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const U=this._animation,V=U.targetPropertyPath;if(!V||V.length<1)return this._stopped=!0,!1;let w,o=!0;const h=this._events;let a=0;if(this._coreRuntimeAnimation)a=S-O,w=this._coreRuntimeAnimation.currentFrame,this._currentFrame=w,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let G;(O<this._minFrame||O>this._maxFrame)&&(O=this._minFrame),(S<this._minFrame||S>this._maxFrame)&&(S=this._maxFrame),a=S-O;let V=H*(U.framePerSecond*p)/1e3+this._absoluteFrameOffset,j=0,e=!1;const X=q&&this._animationState.loopMode===t.d.ANIMATIONLOOPMODE_YOYO;if(X){const H=(V-O)/a,S=Math.sin(H*Math.PI);V=Math.abs(S)*a+O;const t=S>=0?1:-1;this._yoyoDirection!==t&&(e=!0),this._yoyoDirection=t}if(this._previousElapsedTime=H,this._previousAbsoluteFrame=V,!q&&S>=O&&(V>=a&&p>0||V<=0&&p<0))o=!1,j=U._getKeyValue(this._maxValue);else if(!q&&O>=S&&(V<=a&&p<0||V>=0&&p>0))o=!1,j=U._getKeyValue(this._minValue);else if(this._animationState.loopMode!==t.d.ANIMATIONLOOPMODE_CYCLE){const H=S.toString()+O.toString();if(!this._offsetsCache[H]){this._animationState.repeatCount=0,this._animationState.loopMode=t.d.ANIMATIONLOOPMODE_CYCLE;const q=U._interpolate(O,this._animationState),p=U._interpolate(S,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),U.dataType){case t.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[H]=p-q;break;case t.d.ANIMATIONTYPE_QUATERNION:case t.d.ANIMATIONTYPE_VECTOR3:case t.d.ANIMATIONTYPE_VECTOR2:case t.d.ANIMATIONTYPE_SIZE:case t.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[H]=p.XO(q)}this._highLimitsCache[H]=p}j=this._highLimitsCache[H],G=this._offsetsCache[H]}if(void 0===G)switch(U.dataType){case t.d.ANIMATIONTYPE_FLOAT:G=0;break;case t.d.ANIMATIONTYPE_QUATERNION:G=t.n;break;case t.d.ANIMATIONTYPE_VECTOR3:G=t.s;break;case t.d.ANIMATIONTYPE_VECTOR2:G=t.r;break;case t.d.ANIMATIONTYPE_SIZE:G=t.o;break;case t.d.ANIMATIONTYPE_COLOR3:G=t.f;break;case t.d.ANIMATIONTYPE_COLOR4:G=t.j}if(this._host&&this._host.syncRoot){const H=this._host.syncRoot;w=O+a*((H.masterFrame-H.fromFrame)/(H.toFrame-H.fromFrame))}else w=V>0&&O>S||V<0&&O<S?o&&0!==a?S+V%a:O:o&&0!==a?O+V%a:S;if(!X&&(p>0&&this.currentFrame>w||p<0&&this.currentFrame<w)||X&&e){this._onLoop();for(let H=0;H<h.length;H++)h[H].onlyOnce||(h[H].isDone=!1);this._animationState.key=p>0?0:U.getKeys().length-1}this._currentFrame=w,this._animationState.repeatCount=0===a?0:V/a|0,this._animationState.highLimitValue=j,this._animationState.offsetValue=G}const j=U._interpolate(w,this._animationState);if(this.setValue(j,G),h.length)for(let t=0;t<h.length;t++)if(a>=0&&w>=h[t].frame&&h[t].frame>=O||a<0&&w<=h[t].frame&&h[t].frame<=O){const H=h[t];H.isDone||(H.onlyOnce&&(h.splice(t,1),t--),H.isDone=!0,H.action(w))}return o||(this._stopped=!0),o}}var o=S(11162);class h{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(H){this._weight=-1!==H?Math.min(Math.max(H,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(H){for(let O=0;O<this._runtimeAnimations.length;O++){this._runtimeAnimations[O]._prepareForSpeedRatioChange(H)}this._speedRatio=H,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(H,O){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,p=arguments.length>4&&void 0!==arguments[4]&&arguments[4],G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,U=arguments.length>6?arguments[6]:void 0,V=arguments.length>7?arguments[7]:void 0,w=arguments.length>8?arguments[8]:void 0,o=arguments.length>9&&void 0!==arguments[9]&&arguments[9],h=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=O,this.fromFrame=S,this.toFrame=t,this.loopAnimation=p,this.onAnimationEnd=U,this.onAnimationLoop=w,this.isAdditive=o,this.playOrder=h,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.CG=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new q.b,this.onAnimationLoopObservable=new q.b,this._scene=H,V&&this.appendAnimations(O,V),this._speedRatio=G,H._activeAnimatables.push(this)}syncWith(H){if(this._syncRoot=H,H){const H=this._scene._activeAnimatables.indexOf(this);H>-1&&(this._scene._activeAnimatables.splice(H,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(H,O){for(let S=0;S<O.length;S++){const t=O[S],q=new w(H,t,this._scene,this);q._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(q)}}getAnimationByTargetProperty(H){const O=this._runtimeAnimations;for(let S=0;S<O.length;S++)if(O[S].animation.targetProperty===H)return O[S].animation;return null}getRuntimeAnimationByTargetProperty(H){const O=this._runtimeAnimations;for(let S=0;S<O.length;S++)if(O[S].animation.targetProperty===H)return O[S];return null}reset(){const H=this._runtimeAnimations;for(let O=0;O<H.length;O++)H[O].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(H){const O=this._runtimeAnimations;for(let S=0;S<O.length;S++)O[S].animation.enableBlending=!0,O[S].animation.blendingSpeed=H}disableBlending(){const H=this._runtimeAnimations;for(let O=0;O<H.length;O++)H[O].animation.enableBlending=!1}goToFrame(H){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const S=this._runtimeAnimations;if(S[0]){const O=S[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??S[0].currentFrame;const t=0===this.speedRatio?0:(H-this._frameToSyncFromJump)/O*1e3/this.speedRatio;this._manualJumpDelay=-t}for(let t=0;t<S.length;t++)S[t].goToFrame(H,O?this._weight:-1);this._goToFrame=H}get paused(){return this.CG}pause(){this.CG||(this.CG=!0)}restart(){this.CG=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(H,O){let S=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(H||O){const q=this._scene._activeAnimatables.indexOf(this);if(q>-1){const p=this._runtimeAnimations;for(let S=p.length-1;S>=0;S--){const t=p[S];H&&t.animation.name!=H||(O&&!O(t.target)||(t.dispose(),p.splice(S,1)))}0==p.length&&(S||this._scene._activeAnimatables.splice(q,1),t||this._raiseOnAnimationEnd())}}else{const H=this._scene._activeAnimatables.indexOf(this);if(H>-1){S||this._scene._activeAnimatables.splice(H,1);const O=this._runtimeAnimations;for(let H=0;H<O.length;H++)O[H].dispose();this._runtimeAnimations.length=0,t||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((H=>{this.onAnimationEndObservable.add((()=>{H(this)}),void 0,void 0,this,!0)}))}_animate(H){if(this.CG)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=H),!0;if(null===this._localDelayOffset?(this._localDelayOffset=H,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=H-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let O=!1;const S=this._runtimeAnimations;let t;for(t=0;t<S.length;t++){const q=S[t].animate(H-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);O=O||q}if(this.animationStarted=O,!O){if(this.disposeOnEnd)for(t=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(t,1),t=0;t<S.length;t++)S[t].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return O}}function a(H){if(0===H.totalWeight&&0===H.totalAdditiveWeight)return H.originalValue;let O=1;const S=V.TmpVectors.eO[0],t=V.TmpVectors.eO[1],q=V.TmpVectors.Quaternion[0];let p=0;const G=H.animations[0],U=H.originalValue;let w=1,o=!1;if(H.totalWeight<1)w=1-H.totalWeight,U.decompose(t,q,S);else{if(p=1,O=H.totalWeight,w=G.weight/O,1==w){if(!H.totalAdditiveWeight)return G.currentValue;o=!0}G.currentValue.decompose(t,q,S)}if(!o){t.scaleInPlace(w),S.scaleInPlace(w),q.scaleInPlace(w);for(let G=p;G<H.animations.length;G++){const p=H.animations[G];if(0===p.weight)continue;w=p.weight/O;const U=V.TmpVectors.eO[2],o=V.TmpVectors.eO[3],h=V.TmpVectors.Quaternion[1];p.currentValue.decompose(o,h,U),o.scaleAndAddToRef(w,t),h.scaleAndAddToRef(V.Quaternion.Dot(q,h)>0?w:-w,q),U.scaleAndAddToRef(w,S)}q.normalize()}for(let a=0;a<H.additiveAnimations.length;a++){const O=H.additiveAnimations[a];if(0===O.weight)continue;const p=V.TmpVectors.eO[2],G=V.TmpVectors.eO[3],U=V.TmpVectors.Quaternion[1];O.currentValue.decompose(G,U,p),G.multiplyToRef(t,G),V.eO.LerpToRef(t,G,O.weight,t),q.multiplyToRef(U,U),V.Quaternion.SlerpToRef(q,U,O.weight,q),p.scaleAndAddToRef(O.weight,S)}const h=G?G._animationState.workValue:V.TmpVectors.Matrix[0].clone();return V.Matrix.ComposeToRef(t,q,S,h),h}function j(H,O){if(0===H.totalWeight&&0===H.totalAdditiveWeight)return O;const S=H.animations[0],t=H.originalValue;let q=O;if(0===H.totalWeight&&H.totalAdditiveWeight>0)q.t(t);else if(1===H.animations.length){if(V.Quaternion.SlerpToRef(t,S.currentValue,Math.min(1,H.totalWeight),q),0===H.totalAdditiveWeight)return q}else if(H.animations.length>1){let S,p,G=1;if(H.totalWeight<1){const O=1-H.totalWeight;S=[],p=[],S.push(t),p.push(O)}else{if(2===H.animations.length&&(V.Quaternion.SlerpToRef(H.animations[0].currentValue,H.animations[1].currentValue,H.animations[1].weight/H.totalWeight,O),0===H.totalAdditiveWeight))return O;S=[],p=[],G=H.totalWeight}for(let O=0;O<H.animations.length;O++){const t=H.animations[O];S.push(t.currentValue),p.push(t.weight/G)}let U=0;for(let H=0;H<S.length;)H?(U+=p[H],V.Quaternion.SlerpToRef(q,S[H],p[H]/U,q),H++):(V.Quaternion.SlerpToRef(S[H],S[H+1],p[H+1]/(p[H]+p[H+1]),O),q=O,U=p[H]+p[H+1],H+=2)}for(let p=0;p<H.additiveAnimations.length;p++){const O=H.additiveAnimations[p];0!==O.weight&&(q.multiplyToRef(O.currentValue,V.TmpVectors.Quaternion[0]),V.Quaternion.SlerpToRef(q,V.TmpVectors.Quaternion[0],O.weight,q))}return q}var e,X,E=S(11541);e=E.e,(X=U.c)&&(X.prototype.copyAnimationRange=function(H,O,S){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new t.d(this.name,"_matrix",H.animations[0].framePerSecond,t.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const G=H.animations[0].getRange(O);if(!G)return!1;const U=G.from,V=G.to,w=H.animations[0].getKeys(),o=H.length,h=H.getParent(),a=this.getParent(),j=q&&h&&o&&this.length&&o!==this.length,e=j&&a&&h?a.length/h.length:1,X=q&&!a&&p&&(1!==p.x||1!==p.y||1!==p.z),E=this.animations[0].getKeys();let y,T,K;for(let t=0,b=w.length;t<b;t++)y=w[t],y.frame>=U&&y.frame<=V&&(q?(K=y.value.clone(),j?(T=K.getTranslation(),K.setTranslation(T.scaleInPlace(e))):X&&p?(T=K.getTranslation(),K.setTranslation(T.multiplyInPlace(p))):K=y.value):K=y.value,E.push({frame:y.frame+S,value:K}));return this.animations[0].createRange(O,U+S,V+S),!0}),e&&(e.prototype._animate=function(H){if(!this.animationsEnabled)return;const O=o.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=O}this.deltaTime=void 0!==H?H:this.useConstantAnimationDeltaTime?16:(O-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=O;const S=this._activeAnimatables;if(0===S.length)return;this._animationTime+=this.deltaTime;const q=this._animationTime;for(let t=0;t<S.length;t++){const H=S[t];!H._animate(q)&&H.disposeOnEnd&&t--}!function(H){if(H._registeredForLateAnimationBindings.length){for(let O=0;O<H._registeredForLateAnimationBindings.length;O++){const S=H._registeredForLateAnimationBindings.data[O];for(const H in S._lateAnimationHolders){const O=S._lateAnimationHolders[H],q=O.animations[0],p=O.originalValue;if(void 0===p||null===p)continue;const G=t.d.AllowMatrixDecomposeForInterpolation&&p.m;let U=S[H];if(G)U=a(O);else if(void 0!==p.w)U=j(O,U||V.Quaternion.Identity());else{let H=0,S=1;const G=q&&q._animationState.loopMode===t.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(O.totalWeight<1)U=G?p.clone?p.clone():p:q&&p.scale?p.scale(1-O.totalWeight):q?p*(1-O.totalWeight):p.clone?p.clone():p;else if(q){S=O.totalWeight;const t=q.weight/S;U=1!==t?q.currentValue.scale?q.currentValue.scale(t):q.currentValue*t:q.currentValue,G&&(U.addToRef?U.addToRef(p,U):U+=p),H=1}for(let t=H;t<O.animations.length;t++){const H=O.animations[t],q=H.weight/S;q&&(H.currentValue.scaleAndAddToRef?H.currentValue.scaleAndAddToRef(q,U):U+=H.currentValue*q)}for(let t=0;t<O.additiveAnimations.length;t++){const H=O.additiveAnimations[t],S=H.weight;S&&(H.currentValue.scaleAndAddToRef?H.currentValue.scaleAndAddToRef(S,U):U+=H.currentValue*S)}}S[H]=U}S._lateAnimationHolders={}}H._registeredForLateAnimationBindings.reset()}}(this)},e.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((H,O)=>H.playOrder-O.playOrder))},e.prototype.beginWeightedAnimation=function(H,O,S){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,q=arguments.length>4?arguments[4]:void 0,p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,G=arguments.length>6?arguments[6]:void 0,U=arguments.length>7?arguments[7]:void 0,V=arguments.length>8?arguments[8]:void 0,w=arguments.length>9?arguments[9]:void 0,o=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const h=this.beginAnimation(H,O,S,q,p,G,U,!1,V,w,o);return h.weight=t,h},e.prototype.beginAnimation=function(H,O,S,t){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,p=arguments.length>5?arguments[5]:void 0,G=arguments.length>6?arguments[6]:void 0,U=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],V=arguments.length>8?arguments[8]:void 0,w=arguments.length>9?arguments[9]:void 0,o=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(q<0){const H=O;O=S,S=H,q=-q}O>S&&(q=-q),U&&this.stopAnimation(H,void 0,V),G||(G=new h(this,H,O,S,t,q,p,void 0,w,o));const a=!V||V(H);if(H.animations&&a&&G.appendAnimations(H,H.animations),H.getAnimatables){const o=H.getAnimatables();for(let H=0;H<o.length;H++)this.beginAnimation(o[H],O,S,t,q,p,G,U,V,w)}return G.reset(),G},e.prototype.beginHierarchyAnimation=function(H,O,S,t,q){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,G=arguments.length>6?arguments[6]:void 0,U=arguments.length>7?arguments[7]:void 0,V=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],w=arguments.length>9?arguments[9]:void 0,o=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const h=H.getDescendants(O),a=[];a.push(this.beginAnimation(H,S,t,q,p,G,U,V,w,void 0,o));for(const j of h)a.push(this.beginAnimation(j,S,t,q,p,G,U,V,w,void 0,o));return a},e.prototype.beginDirectAnimation=function(H,O,S,t,q){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(p<0){const H=S;S=t,t=H,p=-p}return S>t&&(p=-p),new h(this,H,S,t,q,p,arguments.length>6?arguments[6]:void 0,O,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},e.prototype.beginDirectHierarchyAnimation=function(H,O,S,t,q,p,G,U,V){let w=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const o=H.getDescendants(O),h=[];h.push(this.beginDirectAnimation(H,S,t,q,p,G,U,V,w));for(const a of o)h.push(this.beginDirectAnimation(a,S,t,q,p,G,U,V,w));return h},e.prototype.getAnimatableByTarget=function(H){for(let O=0;O<this._activeAnimatables.length;O++)if(this._activeAnimatables[O].target===H)return this._activeAnimatables[O];return null},e.prototype.getAllAnimatablesByTarget=function(H){const O=[];for(let S=0;S<this._activeAnimatables.length;S++)this._activeAnimatables[S].target===H&&O.push(this._activeAnimatables[S]);return O},e.prototype.stopAnimation=function(H,O,S){const t=this.getAllAnimatablesByTarget(H);for(const q of t)q.stop(O,S)},e.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let H=0;H<this._activeAnimatables.length;H++)this._activeAnimatables[H].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const H of this.animationGroups)H.stop()});class y{getClassName(){return"TargetedAnimation"}serialize(){const H={};return H.animation=this.animation.serialize(),H.targetId=this.target.id,H}}class T{get mask(){return this._mask}set mask(H){this._mask!==H&&(this._mask=H,this.syncWithMask(!0))}syncWithMask(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||H){this._numActiveAnimatables=0;for(let H=0;H<this._animatables.length;++H){const O=this._animatables[H];!this.mask||this.mask.disabled||this.mask.retainsTarget(O.target.name)?(this._numActiveAnimatables++,O.paused&&O.restart()):O.paused||O.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let H=0;H<this._animatables.length;++H){const O=this._animatables[H];this.mask.retainsTarget(O.target.name)||(O.stop(),this._animatables.splice(H,1),--H)}for(let H=0;H<this._targetedAnimations.length;H++){const O=this._targetedAnimations[H];this.mask.retainsTarget(O.target.name)||(this._targetedAnimations.splice(H,1),--H)}}}get from(){return this._from}set from(H){if(this._from!==H){this._from=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].fromFrame=this._from}}}get to(){return this._to}set to(H){if(this._to!==H){this._to=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(H){if(this._speedRatio!==H){this._speedRatio=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(H){if(this._loopAnimation!==H){this._loopAnimation=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(H){if(this._isAdditive!==H){this._isAdditive=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(H){this._weight!==H&&(this._weight=H,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(H){if(this._playOrder!==H&&(this._playOrder=H,this._animatables.length>0)){for(let H=0;H<this._animatables.length;H++)this._animatables[H].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(H){if(this._enableBlending!==H&&(this._enableBlending=H,null!==H))for(let O=0;O<this._targetedAnimations.length;++O)this._targetedAnimations[O].animation.enableBlending=H}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(H){if(this._blendingSpeed!==H&&(this._blendingSpeed=H,null!==H))for(let O=0;O<this._targetedAnimations.length;++O)this._targetedAnimations[O].animation.blendingSpeed=H}getLength(H,O){H=H??this._from;return((O=O??this._to)-H)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(H){let O=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],S=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=arguments.length>3?arguments[3]:void 0;if(0===H.length)return null;t=t??H[0].weight;let q=Number.MAX_VALUE,p=-Number.MAX_VALUE;if(S)for(const U of H)U.from<q&&(q=U.from),U.to>p&&(p=U.to);const G=new T(H[0].name+"_merged",H[0]._scene,t);for(const U of H){S&&U.normalize(q,p);for(const H of U.targetedAnimations)G.addTargetedAnimation(H.animation,H.target);O&&U.dispose()}return G}constructor(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=H,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new q.b,this.onAnimationLoopObservable=new q.b,this.onAnimationGroupLoopObservable=new q.b,this.onAnimationGroupEndObservable=new q.b,this.onAnimationGroupPauseObservable=new q.b,this.onAnimationGroupPlayObservable=new q.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=O||p.c.LastCreatedScene,this._weight=S,this._playOrder=t,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(H,O){const S=new y;S.animation=H,S.target=O;const t=H.getKeys();return this._from>t[0].frame&&(this._from=t[0].frame),this._to<t[t.length-1].frame&&(this._to=t[t.length-1].frame),null!==this._enableBlending&&(H.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(H.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(S),this._shouldStart=!0,S}removeTargetedAnimation(H){for(let O=this._targetedAnimations.length-1;O>-1;O--){this._targetedAnimations[O].animation===H&&this._targetedAnimations.splice(O,1)}}normalize(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==H&&(H=this._from),null==O&&(O=this._to);for(let S=0;S<this._targetedAnimations.length;S++){const t=this._targetedAnimations[S].animation.getKeys(),q=t[0],p=t[t.length-1];if(q.frame>H){const O={frame:H,value:q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation};t.splice(0,0,O)}if(p.frame<O){const H={frame:O,value:p.value,inTangent:p.inTangent,outTangent:p.outTangent,interpolation:p.interpolation};t.push(H)}}return this._from=H,this._to=O,this}_processLoop(H,O,S){H.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(O),this._animationLoopFlags[S]||(this._animationLoopFlags[S]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0],O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,S=arguments.length>2?arguments[2]:void 0,t=arguments.length>3?arguments[3]:void 0,q=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=H,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let p=0;p<this._targetedAnimations.length;p++){const G=this._targetedAnimations[p],U=this._scene.beginDirectAnimation(G.target,[G.animation],void 0!==S?S:this._from,void 0!==t?t:this._to,H,O,void 0,void 0,void 0!==q?q:this._isAdditive);U.weight=this._weight,U.playOrder=this._playOrder,U.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(G),this._checkAnimationGroupEnded(U)},this._processLoop(U,G,p),this._animatables.push(U)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=O,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let H=0;H<this._animatables.length;H++){this._animatables[H].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(H){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==H&&(this.loopAnimation=H),this.restart()):(this.stop(),this.start(H,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].reset()}return this}restart(){if(!this._isStarted)return this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const O=this._animatables.slice();for(let t=0;t<O.length;t++)O[t].stop(void 0,void 0,!0,H);let S=0;for(let t=0;t<this._scene._activeAnimatables.length;t++){const O=this._scene._activeAnimatables[t];O._runtimeAnimations.length>0?this._scene._activeAnimatables[S++]=O:H&&this._checkAnimationGroupEnded(O,H)}return this._scene._activeAnimatables.length=S,this._isStarted=!1,this}setWeightForAllAnimatables(H){for(let O=0;O<this._animatables.length;O++){this._animatables[O].weight=H}return this}syncAllAnimationsWith(H){for(let O=0;O<this._animatables.length;O++){this._animatables[O].syncWith(H)}return this}goToFrame(H){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let S=0;S<this._animatables.length;S++){this._animatables[S].goToFrame(H,O)}return this}getCurrentFrame(){var H;return(null===(H=this.animatables[0])||void 0===H?void 0:H.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const H=this._scene.animationGroups.indexOf(this);if(H>-1&&this._scene.animationGroups.splice(H,1),this._parentContainer){const H=this._parentContainer.animationGroups.indexOf(this);H>-1&&this._parentContainer.animationGroups.splice(H,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(H){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const S=this._animatables.indexOf(H);S>-1&&this._animatables.splice(S,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,O||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(H,O){let S=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=new T(H||this.name,this._scene,this._weight,this._playOrder);t._from=this.from,t._to=this.to,t._speedRatio=this.speedRatio,t._loopAnimation=this.loopAnimation,t._isAdditive=this.isAdditive,t._enableBlending=this.enableBlending,t._blendingSpeed=this.blendingSpeed,t.metadata=this.metadata,t.mask=this.mask;for(const q of this._targetedAnimations)t.addTargetedAnimation(S?q.animation.clone():q.animation,O?O(q.target):q.target);return t}serialize(){const H={};H.name=this.name,H.from=this.from,H.to=this.to,H.speedRatio=this.speedRatio,H.loopAnimation=this.loopAnimation,H.isAdditive=this.isAdditive,H.weight=this.weight,H.playOrder=this.playOrder,H.enableBlending=this.enableBlending,H.blendingSpeed=this.blendingSpeed,H.targetedAnimations=[];for(let O=0;O<this.targetedAnimations.length;O++){const S=this.targetedAnimations[O];H.targetedAnimations[O]=S.serialize()}return G.e&&G.e.HasTags(this)&&(H.tags=G.e.GetTags(this)),this.metadata&&(H.metadata=this.metadata),H}static Parse(H,O){const S=new T(H.name,O,H.weight,H.playOrder);for(let q=0;q<H.targetedAnimations.length;q++){const p=H.targetedAnimations[q],G=t.d.Parse(p.animation),U=p.targetId;if("influence"===p.animation.property){const H=O.getMorphTargetById(U);H&&S.addTargetedAnimation(G,H)}else{const H=O.getNodeById(U);null!=H&&S.addTargetedAnimation(G,H)}}return G.e&&G.e.AddTagsTo(S,H.tags),null!==H.from&&null!==H.to&&S.normalize(H.from,H.to),void 0!==H.speedRatio&&(S._speedRatio=H.speedRatio),void 0!==H.loopAnimation&&(S._loopAnimation=H.loopAnimation),void 0!==H.isAdditive&&(S._isAdditive=H.isAdditive),void 0!==H.weight&&(S._weight=H.weight),void 0!==H.playOrder&&(S._playOrder=H.playOrder),void 0!==H.enableBlending&&(S._enableBlending=H.enableBlending),void 0!==H.blendingSpeed&&(S._blendingSpeed=H.blendingSpeed),void 0!==H.metadata&&(S.metadata=H.metadata),S}static MakeAnimationAdditive(H,O,S){let q;q="object"===typeof O?O:{referenceFrame:O,range:S,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let p=H;q.cloneOriginalAnimationGroup&&(p=H.clone(q.clonedAnimationGroupName||p.name));const G=p.targetedAnimations;for(let U=0;U<G.length;U++){const H=G[U];H.animation=t.d.MakeAnimationAdditive(H.animation,q)}if(p.isAdditive=!0,q.clipKeys){let H=Number.MAX_VALUE,O=-Number.MAX_VALUE;const S=p.targetedAnimations;for(let t=0;t<S.length;t++){const q=S[t].animation.getKeys();H>q[0].frame&&(H=q[0].frame),O<q[q.length-1].frame&&(O=q[q.length-1].frame)}p._from=H,p._to=O}return p}static ClipKeys(H,O,S,t,q){const p=H.clone(t||H.name);return T.ClipKeysInPlace(p,O,S,q)}static ClipKeysInPlace(H,O,S,t){return T.ClipInPlace(H,O,S,t,!1)}static ClipFrames(H,O,S,t,q){const p=H.clone(t||H.name);return T.ClipFramesInPlace(p,O,S,q)}static ClipFramesInPlace(H,O,S,t){return T.ClipInPlace(H,O,S,t,!0)}static ClipInPlace(H,O,S,t){let q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],p=Number.MAX_VALUE,G=-Number.MAX_VALUE;const U=H.targetedAnimations;for(let V=0;V<U.length;V++){const H=U[V],w=t?H.animation:H.animation.clone();q&&(w.createKeyForFrame(O),w.createKeyForFrame(S));const o=w.getKeys(),h=[];let a=Number.MAX_VALUE;for(let t=0;t<o.length;t++){const H=o[t];if(!q&&t>=O&&t<=S||q&&H.frame>=O&&H.frame<=S){const O={frame:H.frame,value:H.value.clone?H.value.clone():H.value,inTangent:H.inTangent,outTangent:H.outTangent,interpolation:H.interpolation,lockedTangent:H.lockedTangent};a===Number.MAX_VALUE&&(a=O.frame),O.frame-=a,h.push(O)}}0!==h.length?(p>h[0].frame&&(p=h[0].frame),G<h[h.length-1].frame&&(G=h[h.length-1].frame),w.setKeys(h,!0),H.animation=w):(U.splice(V,1),V--)}return H._from=p,H._to=G,H}getClassName(){return"AnimationGroup"}toString(H){let O="Name: "+this.name;return O+=", type: "+this.getClassName(),H&&(O+=", from: "+this._from,O+=", to: "+this._to,O+=", isStarted: "+this._isStarted,O+=", speedRatio: "+this._speedRatio,O+=", targetedAnimations length: "+this._targetedAnimations.length,O+=", animatables length: "+this._animatables),O}}}}]);