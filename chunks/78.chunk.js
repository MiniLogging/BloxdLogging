"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[78],{14348:(P,f,Y)=>{Y.r(f),Y.d(f,{AnimationGroup:()=>M,TargetedAnimation:()=>K});var C=Y(11727),q=Y(11018),m=Y(11052),L=Y(11222),o=Y(12840),w=Y(11179);class d{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(P,f,Y,q){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=f,this._target=P,this._scene=Y,this._host=q,this._activeTargets=[],f._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===C.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=w.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const P={frame:0,value:this._minValue};this._keys.splice(0,0,P)}if(this._target instanceof Array){let P=0;for(const f of this._target)this._preparePath(f,P),this._getOriginalValues(P),P++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const m=f.getEvents();if(m&&m.length>0)for(const C of m)this._events.push(C._clone());this._enableBlending=P&&P.animationPropertiesOverride?P.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Y=this._animation.targetPropertyPath;if(Y.length>1){let C=P;for(let P=0;P<Y.length-1;P++){const f=Y[P];if(C=C[f],void 0===C)throw new Error(`Invalid property (${f}) in property path (${Y.join(".")})`)}this._targetPath=Y[Y.length-1],this._activeTargets[f]=C}else this._targetPath=Y[0],this._activeTargets[f]=P;if(void 0===this._activeTargets[f][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${Y.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let P=0;for(const f of this._target)void 0!==this._originalValue[P]&&this._setValue(f,this._activeTargets[P],this._originalValue[P],-1,P),P++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let P=0;P<this._events.length;P++)this._events[P].isDone=!1}isStopped(){return this._stopped}dispose(){const P=this._animation.runtimeAnimations.indexOf(this);P>-1&&this._animation.runtimeAnimations.splice(P,1)}setValue(P,f){if(this._targetIsArray)for(let Y=0;Y<this._target.length;Y++){const C=this._target[Y];this._setValue(C,this._activeTargets[Y],P,f,Y)}else this._setValue(this._target,this._directTarget,P,f,0)}_getOriginalValues(){let P,f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Y=this._activeTargets[f];P=Y.getLocalMatrix&&"_matrix"===this._targetPath?Y.getLocalMatrix():Y[this._targetPath],P&&P.clone?this._originalValue[f]=P.clone():this._originalValue[f]=P}_registerTargetForLateAnimationBinding(P,f){const Y=P.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(Y),Y._lateAnimationHolders||(Y._lateAnimationHolders={}),Y._lateAnimationHolders[P.targetPath]||(Y._lateAnimationHolders[P.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:f}),P.isAdditive?(Y._lateAnimationHolders[P.targetPath].additiveAnimations.push(P),Y._lateAnimationHolders[P.targetPath].totalAdditiveWeight+=P.weight):(Y._lateAnimationHolders[P.targetPath].animations.push(P),Y._lateAnimationHolders[P.targetPath].totalWeight+=P.weight)}_setValue(P,f,Y,q,m){if(this._currentActiveTarget=f,this._weight=q,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const P=f[this._targetPath];P.clone?this._originalBlendValue=P.clone():this._originalBlendValue=P}this._originalBlendValue.m?C.b.AllowMatrixDecomposeForInterpolation?this._currentValue?w.Matrix.DecomposeLerpToRef(this._originalBlendValue,Y,this._blendingFactor,this._currentValue):this._currentValue=w.Matrix.DecomposeLerp(this._originalBlendValue,Y,this._blendingFactor):this._currentValue?w.Matrix.LerpToRef(this._originalBlendValue,Y,this._blendingFactor,this._currentValue):this._currentValue=w.Matrix.Lerp(this._originalBlendValue,Y,this._blendingFactor):this._currentValue=C.b._UniversalLerp(this._originalBlendValue,Y,this._blendingFactor);const q=P&&P.animationPropertiesOverride?P.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=q}else this._currentValue?this._currentValue.q?this._currentValue.q(Y):this._currentValue=Y:null!==Y&&void 0!==Y&&Y.clone?this._currentValue=Y.clone():this._currentValue=Y;-1!==q?this._registerTargetForLateAnimationBinding(this,this._originalValue[m]):this._animationState.loopMode===C.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[m],f[this._targetPath]):f[this._targetPath]=this._originalValue[m]+this._currentValue:f[this._targetPath]=this._currentValue,P.Ed&&P.Ed(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const Y=this._animation.getKeys();P<Y[0].frame?P=Y[0].frame:P>Y[Y.length-1].frame&&(P=Y[Y.length-1].frame);const C=this._events;if(C.length)for(let m=0;m<C.length;m++)C[m].onlyOnce||(C[m].isDone=C[m].frame<P);this._currentFrame=P;const q=this._animation._interpolate(P,this._animationState);this.setValue(q,f)}_prepareForSpeedRatioChange(P){const f=this._previousElapsedTime*(this._animation.framePerSecond*P)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-f}animate(P,f,Y,q,m){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const o=this._animation,w=o.targetPropertyPath;if(!w||w.length<1)return this._stopped=!0,!1;let d,R=!0;const y=this._events;let r=0;if(this._coreRuntimeAnimation)r=Y-f,d=this._coreRuntimeAnimation.currentFrame,this._currentFrame=d,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let L;(f<this._minFrame||f>this._maxFrame)&&(f=this._minFrame),(Y<this._minFrame||Y>this._maxFrame)&&(Y=this._maxFrame),r=Y-f;let w=P*(o.framePerSecond*m)/1e3+this._absoluteFrameOffset,i=0,u=!1;const g=q&&this._animationState.loopMode===C.b.ANIMATIONLOOPMODE_YOYO;if(g){const P=(w-f)/r,Y=Math.sin(P*Math.PI);w=Math.abs(Y)*r+f;const C=Y>=0?1:-1;this._yoyoDirection!==C&&(u=!0),this._yoyoDirection=C}if(this._previousElapsedTime=P,this._previousAbsoluteFrame=w,!q&&Y>=f&&(w>=r&&m>0||w<=0&&m<0))R=!1,i=o._getKeyValue(this._maxValue);else if(!q&&f>=Y&&(w<=r&&m<0||w>=0&&m>0))R=!1,i=o._getKeyValue(this._minValue);else if(this._animationState.loopMode!==C.b.ANIMATIONLOOPMODE_CYCLE){const P=Y.toString()+f.toString();if(!this._offsetsCache[P]){this._animationState.repeatCount=0,this._animationState.loopMode=C.b.ANIMATIONLOOPMODE_CYCLE;const q=o._interpolate(f,this._animationState),m=o._interpolate(Y,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),o.dataType){case C.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[P]=m-q;break;case C.b.ANIMATIONTYPE_QUATERNION:case C.b.ANIMATIONTYPE_VECTOR3:case C.b.ANIMATIONTYPE_VECTOR2:case C.b.ANIMATIONTYPE_SIZE:case C.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[P]=m.nf(q)}this._highLimitsCache[P]=m}i=this._highLimitsCache[P],L=this._offsetsCache[P]}if(void 0===L)switch(o.dataType){case C.b.ANIMATIONTYPE_FLOAT:L=0;break;case C.b.ANIMATIONTYPE_QUATERNION:L=C.j;break;case C.b.ANIMATIONTYPE_VECTOR3:L=C.q;break;case C.b.ANIMATIONTYPE_VECTOR2:L=C.o;break;case C.b.ANIMATIONTYPE_SIZE:L=C.m;break;case C.b.ANIMATIONTYPE_COLOR3:L=C.e;break;case C.b.ANIMATIONTYPE_COLOR4:L=C.g}if(this._host&&this._host.syncRoot){const P=this._host.syncRoot;d=f+r*((P.masterFrame-P.fromFrame)/(P.toFrame-P.fromFrame))}else d=w>0&&f>Y||w<0&&f<Y?R&&0!==r?Y+w%r:f:R&&0!==r?f+w%r:Y;if(!g&&(m>0&&this.currentFrame>d||m<0&&this.currentFrame<d)||g&&u){this._onLoop();for(let P=0;P<y.length;P++)y[P].onlyOnce||(y[P].isDone=!1);this._animationState.key=m>0?0:o.getKeys().length-1}this._currentFrame=d,this._animationState.repeatCount=0===r?0:w/r|0,this._animationState.highLimitValue=i,this._animationState.offsetValue=L}const i=o._interpolate(d,this._animationState);if(this.setValue(i,L),y.length)for(let C=0;C<y.length;C++)if(r>=0&&d>=y[C].frame&&y[C].frame>=f||r<0&&d<=y[C].frame&&y[C].frame<=f){const P=y[C];P.isDone||(P.onlyOnce&&(y.splice(C,1),C--),P.isDone=!0,P.action(d))}return R||(this._stopped=!0),R}}var R=Y(11035);class y{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(P){this._weight=-1!==P?Math.min(Math.max(P,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(P){for(let f=0;f<this._runtimeAnimations.length;f++){this._runtimeAnimations[f]._prepareForSpeedRatioChange(P)}this._speedRatio=P,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,m=arguments.length>4&&void 0!==arguments[4]&&arguments[4],L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,d=arguments.length>8?arguments[8]:void 0,R=arguments.length>9&&void 0!==arguments[9]&&arguments[9],y=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=f,this.fromFrame=Y,this.toFrame=C,this.loopAnimation=m,this.onAnimationEnd=o,this.onAnimationLoop=d,this.isAdditive=R,this.playOrder=y,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Lo=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new q.e,this.onAnimationLoopObservable=new q.e,this._scene=P,w&&this.appendAnimations(f,w),this._speedRatio=L,P._activeAnimatables.push(this)}syncWith(P){if(this._syncRoot=P,P){const P=this._scene._activeAnimatables.indexOf(this);P>-1&&(this._scene._activeAnimatables.splice(P,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(P,f){for(let Y=0;Y<f.length;Y++){const C=f[Y],q=new d(P,C,this._scene,this);q._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(q)}}getAnimationByTargetProperty(P){const f=this._runtimeAnimations;for(let Y=0;Y<f.length;Y++)if(f[Y].animation.targetProperty===P)return f[Y].animation;return null}getRuntimeAnimationByTargetProperty(P){const f=this._runtimeAnimations;for(let Y=0;Y<f.length;Y++)if(f[Y].animation.targetProperty===P)return f[Y];return null}reset(){const P=this._runtimeAnimations;for(let f=0;f<P.length;f++)P[f].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(P){const f=this._runtimeAnimations;for(let Y=0;Y<f.length;Y++)f[Y].animation.enableBlending=!0,f[Y].animation.blendingSpeed=P}disableBlending(){const P=this._runtimeAnimations;for(let f=0;f<P.length;f++)P[f].animation.enableBlending=!1}goToFrame(P){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Y=this._runtimeAnimations;if(Y[0]){const f=Y[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??Y[0].currentFrame;const C=0===this.speedRatio?0:(P-this._frameToSyncFromJump)/f*1e3/this.speedRatio;this._manualJumpDelay=-C}for(let C=0;C<Y.length;C++)Y[C].goToFrame(P,f?this._weight:-1);this._goToFrame=P}get paused(){return this.Lo}pause(){this.Lo||(this.Lo=!0)}restart(){this.Lo=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(P,f){let Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(P||f){const q=this._scene._activeAnimatables.indexOf(this);if(q>-1){const m=this._runtimeAnimations;for(let Y=m.length-1;Y>=0;Y--){const C=m[Y];P&&C.animation.name!=P||(f&&!f(C.target)||(C.dispose(),m.splice(Y,1)))}0==m.length&&(Y||this._scene._activeAnimatables.splice(q,1),C||this._raiseOnAnimationEnd())}}else{const P=this._scene._activeAnimatables.indexOf(this);if(P>-1){Y||this._scene._activeAnimatables.splice(P,1);const f=this._runtimeAnimations;for(let P=0;P<f.length;P++)f[P].dispose();this._runtimeAnimations.length=0,C||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((P=>{this.onAnimationEndObservable.add((()=>{P(this)}),void 0,void 0,this,!0)}))}_animate(P){if(this.Lo)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=P),!0;if(null===this._localDelayOffset?(this._localDelayOffset=P,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=P-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let f=!1;const Y=this._runtimeAnimations;let C;for(C=0;C<Y.length;C++){const q=Y[C].animate(P-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);f=f||q}if(this.animationStarted=f,!f){if(this.disposeOnEnd)for(C=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(C,1),C=0;C<Y.length;C++)Y[C].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return f}}function r(P){if(0===P.totalWeight&&0===P.totalAdditiveWeight)return P.originalValue;let f=1;const Y=w.TmpVectors.Of[0],C=w.TmpVectors.Of[1],q=w.TmpVectors.Quaternion[0];let m=0;const L=P.animations[0],o=P.originalValue;let d=1,R=!1;if(P.totalWeight<1)d=1-P.totalWeight,o.decompose(C,q,Y);else{if(m=1,f=P.totalWeight,d=L.weight/f,1==d){if(!P.totalAdditiveWeight)return L.currentValue;R=!0}L.currentValue.decompose(C,q,Y)}if(!R){C.scaleInPlace(d),Y.scaleInPlace(d),q.scaleInPlace(d);for(let L=m;L<P.animations.length;L++){const m=P.animations[L];if(0===m.weight)continue;d=m.weight/f;const o=w.TmpVectors.Of[2],R=w.TmpVectors.Of[3],y=w.TmpVectors.Quaternion[1];m.currentValue.decompose(R,y,o),R.scaleAndAddToRef(d,C),y.scaleAndAddToRef(w.Quaternion.Dot(q,y)>0?d:-d,q),o.scaleAndAddToRef(d,Y)}q.normalize()}for(let r=0;r<P.additiveAnimations.length;r++){const f=P.additiveAnimations[r];if(0===f.weight)continue;const m=w.TmpVectors.Of[2],L=w.TmpVectors.Of[3],o=w.TmpVectors.Quaternion[1];f.currentValue.decompose(L,o,m),L.multiplyToRef(C,L),w.Of.LerpToRef(C,L,f.weight,C),q.multiplyToRef(o,o),w.Quaternion.SlerpToRef(q,o,f.weight,q),m.scaleAndAddToRef(f.weight,Y)}const y=L?L._animationState.workValue:w.TmpVectors.Matrix[0].clone();return w.Matrix.ComposeToRef(C,q,Y,y),y}function i(P,f){if(0===P.totalWeight&&0===P.totalAdditiveWeight)return f;const Y=P.animations[0],C=P.originalValue;let q=f;if(0===P.totalWeight&&P.totalAdditiveWeight>0)q.q(C);else if(1===P.animations.length){if(w.Quaternion.SlerpToRef(C,Y.currentValue,Math.min(1,P.totalWeight),q),0===P.totalAdditiveWeight)return q}else if(P.animations.length>1){let Y,m,L=1;if(P.totalWeight<1){const f=1-P.totalWeight;Y=[],m=[],Y.push(C),m.push(f)}else{if(2===P.animations.length&&(w.Quaternion.SlerpToRef(P.animations[0].currentValue,P.animations[1].currentValue,P.animations[1].weight/P.totalWeight,f),0===P.totalAdditiveWeight))return f;Y=[],m=[],L=P.totalWeight}for(let f=0;f<P.animations.length;f++){const C=P.animations[f];Y.push(C.currentValue),m.push(C.weight/L)}let o=0;for(let P=0;P<Y.length;)P?(o+=m[P],w.Quaternion.SlerpToRef(q,Y[P],m[P]/o,q),P++):(w.Quaternion.SlerpToRef(Y[P],Y[P+1],m[P+1]/(m[P]+m[P+1]),f),q=f,o=m[P]+m[P+1],P+=2)}for(let m=0;m<P.additiveAnimations.length;m++){const f=P.additiveAnimations[m];0!==f.weight&&(q.multiplyToRef(f.currentValue,w.TmpVectors.Quaternion[0]),w.Quaternion.SlerpToRef(q,w.TmpVectors.Quaternion[0],f.weight,q))}return q}var u,g,S=Y(11429);u=S.e,(g=o.d)&&(g.prototype.copyAnimationRange=function(P,f,Y){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],m=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new C.b(this.name,"_matrix",P.animations[0].framePerSecond,C.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const L=P.animations[0].getRange(f);if(!L)return!1;const o=L.from,w=L.to,d=P.animations[0].getKeys(),R=P.length,y=P.getParent(),r=this.getParent(),i=q&&y&&R&&this.length&&R!==this.length,u=i&&r&&y?r.length/y.length:1,g=q&&!r&&m&&(1!==m.x||1!==m.y||1!==m.z),S=this.animations[0].getKeys();let K,M,V;for(let C=0,O=d.length;C<O;C++)K=d[C],K.frame>=o&&K.frame<=w&&(q?(V=K.value.clone(),i?(M=V.getTranslation(),V.setTranslation(M.scaleInPlace(u))):g&&m?(M=V.getTranslation(),V.setTranslation(M.multiplyInPlace(m))):V=K.value):V=K.value,S.push({frame:K.frame+Y,value:V}));return this.animations[0].createRange(f,o+Y,w+Y),!0}),u&&(u.prototype._animate=function(P){if(!this.animationsEnabled)return;const f=R.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=f}this.deltaTime=void 0!==P?P:this.useConstantAnimationDeltaTime?16:(f-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=f;const Y=this._activeAnimatables;if(0===Y.length)return;this._animationTime+=this.deltaTime;const q=this._animationTime;for(let C=0;C<Y.length;C++){const P=Y[C];!P._animate(q)&&P.disposeOnEnd&&C--}!function(P){if(P._registeredForLateAnimationBindings.length){for(let f=0;f<P._registeredForLateAnimationBindings.length;f++){const Y=P._registeredForLateAnimationBindings.data[f];for(const P in Y._lateAnimationHolders){const f=Y._lateAnimationHolders[P],q=f.animations[0],m=f.originalValue;if(void 0===m||null===m)continue;const L=C.b.AllowMatrixDecomposeForInterpolation&&m.m;let o=Y[P];if(L)o=r(f);else if(void 0!==m.w)o=i(f,o||w.Quaternion.Identity());else{let P=0,Y=1;const L=q&&q._animationState.loopMode===C.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(f.totalWeight<1)o=L?m.clone?m.clone():m:q&&m.scale?m.scale(1-f.totalWeight):q?m*(1-f.totalWeight):m.clone?m.clone():m;else if(q){Y=f.totalWeight;const C=q.weight/Y;o=1!==C?q.currentValue.scale?q.currentValue.scale(C):q.currentValue*C:q.currentValue,L&&(o.addToRef?o.addToRef(m,o):o+=m),P=1}for(let C=P;C<f.animations.length;C++){const P=f.animations[C],q=P.weight/Y;q&&(P.currentValue.scaleAndAddToRef?P.currentValue.scaleAndAddToRef(q,o):o+=P.currentValue*q)}for(let C=0;C<f.additiveAnimations.length;C++){const P=f.additiveAnimations[C],Y=P.weight;Y&&(P.currentValue.scaleAndAddToRef?P.currentValue.scaleAndAddToRef(Y,o):o+=P.currentValue*Y)}}Y[P]=o}Y._lateAnimationHolders={}}P._registeredForLateAnimationBindings.reset()}}(this)},u.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((P,f)=>P.playOrder-f.playOrder))},u.prototype.beginWeightedAnimation=function(P,f,Y){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,q=arguments.length>4?arguments[4]:void 0,m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,L=arguments.length>6?arguments[6]:void 0,o=arguments.length>7?arguments[7]:void 0,w=arguments.length>8?arguments[8]:void 0,d=arguments.length>9?arguments[9]:void 0,R=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const y=this.beginAnimation(P,f,Y,q,m,L,o,!1,w,d,R);return y.weight=C,y},u.prototype.beginAnimation=function(P,f,Y,C){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,m=arguments.length>5?arguments[5]:void 0,L=arguments.length>6?arguments[6]:void 0,o=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],w=arguments.length>8?arguments[8]:void 0,d=arguments.length>9?arguments[9]:void 0,R=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(q<0){const P=f;f=Y,Y=P,q=-q}f>Y&&(q=-q),o&&this.stopAnimation(P,void 0,w),L||(L=new y(this,P,f,Y,C,q,m,void 0,d,R));const r=!w||w(P);if(P.animations&&r&&L.appendAnimations(P,P.animations),P.getAnimatables){const R=P.getAnimatables();for(let P=0;P<R.length;P++)this.beginAnimation(R[P],f,Y,C,q,m,L,o,w,d)}return L.reset(),L},u.prototype.beginHierarchyAnimation=function(P,f,Y,C,q){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,L=arguments.length>6?arguments[6]:void 0,o=arguments.length>7?arguments[7]:void 0,w=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],d=arguments.length>9?arguments[9]:void 0,R=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const y=P.getDescendants(f),r=[];r.push(this.beginAnimation(P,Y,C,q,m,L,o,w,d,void 0,R));for(const i of y)r.push(this.beginAnimation(i,Y,C,q,m,L,o,w,d,void 0,R));return r},u.prototype.beginDirectAnimation=function(P,f,Y,C,q){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(m<0){const P=Y;Y=C,C=P,m=-m}return Y>C&&(m=-m),new y(this,P,Y,C,q,m,arguments.length>6?arguments[6]:void 0,f,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},u.prototype.beginDirectHierarchyAnimation=function(P,f,Y,C,q,m,L,o,w){let d=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const R=P.getDescendants(f),y=[];y.push(this.beginDirectAnimation(P,Y,C,q,m,L,o,w,d));for(const r of R)y.push(this.beginDirectAnimation(r,Y,C,q,m,L,o,w,d));return y},u.prototype.getAnimatableByTarget=function(P){for(let f=0;f<this._activeAnimatables.length;f++)if(this._activeAnimatables[f].target===P)return this._activeAnimatables[f];return null},u.prototype.getAllAnimatablesByTarget=function(P){const f=[];for(let Y=0;Y<this._activeAnimatables.length;Y++)this._activeAnimatables[Y].target===P&&f.push(this._activeAnimatables[Y]);return f},u.prototype.stopAnimation=function(P,f,Y){const C=this.getAllAnimatablesByTarget(P);for(const q of C)q.stop(f,Y)},u.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let P=0;P<this._activeAnimatables.length;P++)this._activeAnimatables[P].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const P of this.animationGroups)P.stop()});class K{getClassName(){return"TargetedAnimation"}serialize(){const P={};return P.animation=this.animation.serialize(),P.targetId=this.target.id,P}}class M{get mask(){return this._mask}set mask(P){this._mask!==P&&(this._mask=P,this.syncWithMask(!0))}syncWithMask(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||P){this._numActiveAnimatables=0;for(let P=0;P<this._animatables.length;++P){const f=this._animatables[P];!this.mask||this.mask.disabled||this.mask.retainsTarget(f.target.name)?(this._numActiveAnimatables++,f.paused&&f.restart()):f.paused||f.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let P=0;P<this._animatables.length;++P){const f=this._animatables[P];this.mask.retainsTarget(f.target.name)||(f.stop(),this._animatables.splice(P,1),--P)}for(let P=0;P<this._targetedAnimations.length;P++){const f=this._targetedAnimations[P];this.mask.retainsTarget(f.target.name)||(this._targetedAnimations.splice(P,1),--P)}}}get from(){return this._from}set from(P){if(this._from!==P){this._from=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].fromFrame=this._from}}}get to(){return this._to}set to(P){if(this._to!==P){this._to=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(P){if(this._speedRatio!==P){this._speedRatio=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(P){if(this._loopAnimation!==P){this._loopAnimation=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(P){if(this._isAdditive!==P){this._isAdditive=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(P){this._weight!==P&&(this._weight=P,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(P){if(this._playOrder!==P&&(this._playOrder=P,this._animatables.length>0)){for(let P=0;P<this._animatables.length;P++)this._animatables[P].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(P){if(this._enableBlending!==P&&(this._enableBlending=P,null!==P))for(let f=0;f<this._targetedAnimations.length;++f)this._targetedAnimations[f].animation.enableBlending=P}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(P){if(this._blendingSpeed!==P&&(this._blendingSpeed=P,null!==P))for(let f=0;f<this._targetedAnimations.length;++f)this._targetedAnimations[f].animation.blendingSpeed=P}getLength(P,f){P=P??this._from;return((f=f??this._to)-P)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(P){let f=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=arguments.length>3?arguments[3]:void 0;if(0===P.length)return null;C=C??P[0].weight;let q=Number.MAX_VALUE,m=-Number.MAX_VALUE;if(Y)for(const o of P)o.from<q&&(q=o.from),o.to>m&&(m=o.to);const L=new M(P[0].name+"_merged",P[0]._scene,C);for(const o of P){Y&&o.normalize(q,m);for(const P of o.targetedAnimations)L.addTargetedAnimation(P.animation,P.target);f&&o.dispose()}return L}constructor(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=P,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new q.e,this.onAnimationLoopObservable=new q.e,this.onAnimationGroupLoopObservable=new q.e,this.onAnimationGroupEndObservable=new q.e,this.onAnimationGroupPauseObservable=new q.e,this.onAnimationGroupPlayObservable=new q.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=f||m.e.LastCreatedScene,this._weight=Y,this._playOrder=C,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(P,f){const Y=new K;Y.animation=P,Y.target=f;const C=P.getKeys();return this._from>C[0].frame&&(this._from=C[0].frame),this._to<C[C.length-1].frame&&(this._to=C[C.length-1].frame),null!==this._enableBlending&&(P.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(P.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(Y),this._shouldStart=!0,Y}removeTargetedAnimation(P){for(let f=this._targetedAnimations.length-1;f>-1;f--){this._targetedAnimations[f].animation===P&&this._targetedAnimations.splice(f,1)}}normalize(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==P&&(P=this._from),null==f&&(f=this._to);for(let Y=0;Y<this._targetedAnimations.length;Y++){const C=this._targetedAnimations[Y].animation.getKeys(),q=C[0],m=C[C.length-1];if(q.frame>P){const f={frame:P,value:q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation};C.splice(0,0,f)}if(m.frame<f){const P={frame:f,value:m.value,inTangent:m.inTangent,outTangent:m.outTangent,interpolation:m.interpolation};C.push(P)}}return this._from=P,this._to=f,this}_processLoop(P,f,Y){P.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(f),this._animationLoopFlags[Y]||(this._animationLoopFlags[Y]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0],f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Y=arguments.length>2?arguments[2]:void 0,C=arguments.length>3?arguments[3]:void 0,q=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=P,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let m=0;m<this._targetedAnimations.length;m++){const L=this._targetedAnimations[m],o=this._scene.beginDirectAnimation(L.target,[L.animation],void 0!==Y?Y:this._from,void 0!==C?C:this._to,P,f,void 0,void 0,void 0!==q?q:this._isAdditive);o.weight=this._weight,o.playOrder=this._playOrder,o.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(L),this._checkAnimationGroupEnded(o)},this._processLoop(o,L,m),this._animatables.push(o)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=f,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let P=0;P<this._animatables.length;P++){this._animatables[P].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(P){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==P&&(this.loopAnimation=P),this.restart()):(this.stop(),this.start(P,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let P=0;P<this._animatables.length;P++){this._animatables[P].reset()}return this}restart(){if(!this._isStarted)return this;for(let P=0;P<this._animatables.length;P++){this._animatables[P].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const f=this._animatables.slice();for(let C=0;C<f.length;C++)f[C].stop(void 0,void 0,!0,P);let Y=0;for(let C=0;C<this._scene._activeAnimatables.length;C++){const f=this._scene._activeAnimatables[C];f._runtimeAnimations.length>0?this._scene._activeAnimatables[Y++]=f:P&&this._checkAnimationGroupEnded(f,P)}return this._scene._activeAnimatables.length=Y,this._isStarted=!1,this}setWeightForAllAnimatables(P){for(let f=0;f<this._animatables.length;f++){this._animatables[f].weight=P}return this}syncAllAnimationsWith(P){for(let f=0;f<this._animatables.length;f++){this._animatables[f].syncWith(P)}return this}goToFrame(P){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].goToFrame(P,f)}return this}getCurrentFrame(){var P;return(null===(P=this.animatables[0])||void 0===P?void 0:P.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const P=this._scene.animationGroups.indexOf(this);if(P>-1&&this._scene.animationGroups.splice(P,1),this._parentContainer){const P=this._parentContainer.animationGroups.indexOf(this);P>-1&&this._parentContainer.animationGroups.splice(P,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(P){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Y=this._animatables.indexOf(P);Y>-1&&this._animatables.splice(Y,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,f||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(P,f){let Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const C=new M(P||this.name,this._scene,this._weight,this._playOrder);C._from=this.from,C._to=this.to,C._speedRatio=this.speedRatio,C._loopAnimation=this.loopAnimation,C._isAdditive=this.isAdditive,C._enableBlending=this.enableBlending,C._blendingSpeed=this.blendingSpeed,C.metadata=this.metadata,C.mask=this.mask;for(const q of this._targetedAnimations)C.addTargetedAnimation(Y?q.animation.clone():q.animation,f?f(q.target):q.target);return C}serialize(){const P={};P.name=this.name,P.from=this.from,P.to=this.to,P.speedRatio=this.speedRatio,P.loopAnimation=this.loopAnimation,P.isAdditive=this.isAdditive,P.weight=this.weight,P.playOrder=this.playOrder,P.enableBlending=this.enableBlending,P.blendingSpeed=this.blendingSpeed,P.targetedAnimations=[];for(let f=0;f<this.targetedAnimations.length;f++){const Y=this.targetedAnimations[f];P.targetedAnimations[f]=Y.serialize()}return L.c&&L.c.HasTags(this)&&(P.tags=L.c.GetTags(this)),this.metadata&&(P.metadata=this.metadata),P}static Parse(P,f){const Y=new M(P.name,f,P.weight,P.playOrder);for(let q=0;q<P.targetedAnimations.length;q++){const m=P.targetedAnimations[q],L=C.b.Parse(m.animation),o=m.targetId;if("influence"===m.animation.property){const P=f.getMorphTargetById(o);P&&Y.addTargetedAnimation(L,P)}else{const P=f.getNodeById(o);null!=P&&Y.addTargetedAnimation(L,P)}}return L.c&&L.c.AddTagsTo(Y,P.tags),null!==P.from&&null!==P.to&&Y.normalize(P.from,P.to),void 0!==P.speedRatio&&(Y._speedRatio=P.speedRatio),void 0!==P.loopAnimation&&(Y._loopAnimation=P.loopAnimation),void 0!==P.isAdditive&&(Y._isAdditive=P.isAdditive),void 0!==P.weight&&(Y._weight=P.weight),void 0!==P.playOrder&&(Y._playOrder=P.playOrder),void 0!==P.enableBlending&&(Y._enableBlending=P.enableBlending),void 0!==P.blendingSpeed&&(Y._blendingSpeed=P.blendingSpeed),void 0!==P.metadata&&(Y.metadata=P.metadata),Y}static MakeAnimationAdditive(P,f,Y){let q;q="object"===typeof f?f:{referenceFrame:f,range:Y,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let m=P;q.cloneOriginalAnimationGroup&&(m=P.clone(q.clonedAnimationGroupName||m.name));const L=m.targetedAnimations;for(let o=0;o<L.length;o++){const P=L[o];P.animation=C.b.MakeAnimationAdditive(P.animation,q)}if(m.isAdditive=!0,q.clipKeys){let P=Number.MAX_VALUE,f=-Number.MAX_VALUE;const Y=m.targetedAnimations;for(let C=0;C<Y.length;C++){const q=Y[C].animation.getKeys();P>q[0].frame&&(P=q[0].frame),f<q[q.length-1].frame&&(f=q[q.length-1].frame)}m._from=P,m._to=f}return m}static ClipKeys(P,f,Y,C,q){const m=P.clone(C||P.name);return M.ClipKeysInPlace(m,f,Y,q)}static ClipKeysInPlace(P,f,Y,C){return M.ClipInPlace(P,f,Y,C,!1)}static ClipFrames(P,f,Y,C,q){const m=P.clone(C||P.name);return M.ClipFramesInPlace(m,f,Y,q)}static ClipFramesInPlace(P,f,Y,C){return M.ClipInPlace(P,f,Y,C,!0)}static ClipInPlace(P,f,Y,C){let q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],m=Number.MAX_VALUE,L=-Number.MAX_VALUE;const o=P.targetedAnimations;for(let w=0;w<o.length;w++){const P=o[w],d=C?P.animation:P.animation.clone();q&&(d.createKeyForFrame(f),d.createKeyForFrame(Y));const R=d.getKeys(),y=[];let r=Number.MAX_VALUE;for(let C=0;C<R.length;C++){const P=R[C];if(!q&&C>=f&&C<=Y||q&&P.frame>=f&&P.frame<=Y){const f={frame:P.frame,value:P.value.clone?P.value.clone():P.value,inTangent:P.inTangent,outTangent:P.outTangent,interpolation:P.interpolation,lockedTangent:P.lockedTangent};r===Number.MAX_VALUE&&(r=f.frame),f.frame-=r,y.push(f)}}0!==y.length?(m>y[0].frame&&(m=y[0].frame),L<y[y.length-1].frame&&(L=y[y.length-1].frame),d.setKeys(y,!0),P.animation=d):(o.splice(w,1),w--)}return P._from=m,P._to=L,P}getClassName(){return"AnimationGroup"}toString(P){let f="Name: "+this.name;return f+=", type: "+this.getClassName(),P&&(f+=", from: "+this._from,f+=", to: "+this._to,f+=", isStarted: "+this._isStarted,f+=", speedRatio: "+this._speedRatio,f+=", targetedAnimations length: "+this._targetedAnimations.length,f+=", animatables length: "+this._animatables),f}}}}]);