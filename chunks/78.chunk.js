"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[78],{16029:(I,x,L)=>{L.r(x),L.d(x,{AnimationGroup:()=>U,TargetedAnimation:()=>s});var F=L(13490),X=L(12797),G=L(12840),Y=L(13014),p=L(14420),B=L(12983);class l{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(I,x,L,X){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=x,this._target=I,this._scene=L,this._host=X,this._activeTargets=[],x._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===F.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=B.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const I={frame:0,value:this._minValue};this._keys.splice(0,0,I)}if(this._target instanceof Array){let I=0;for(const x of this._target)this._preparePath(x,I),this._getOriginalValues(I),I++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const G=x.getEvents();if(G&&G.length>0)for(const F of G)this._events.push(F._clone());this._enableBlending=I&&I.animationPropertiesOverride?I.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const L=this._animation.targetPropertyPath;if(L.length>1){let F=I;for(let I=0;I<L.length-1;I++){const x=L[I];if(F=F[x],void 0===F)throw new Error(`Invalid property (${x}) in property path (${L.join(".")})`)}this._targetPath=L[L.length-1],this._activeTargets[x]=F}else this._targetPath=L[0],this._activeTargets[x]=I;if(void 0===this._activeTargets[x][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${L.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let I=0;for(const x of this._target)void 0!==this._originalValue[I]&&this._setValue(x,this._activeTargets[I],this._originalValue[I],-1,I),I++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let I=0;I<this._events.length;I++)this._events[I].isDone=!1}isStopped(){return this._stopped}dispose(){const I=this._animation.runtimeAnimations.indexOf(this);I>-1&&this._animation.runtimeAnimations.splice(I,1)}setValue(I,x){if(this._targetIsArray)for(let L=0;L<this._target.length;L++){const F=this._target[L];this._setValue(F,this._activeTargets[L],I,x,L)}else this._setValue(this._target,this._directTarget,I,x,0)}_getOriginalValues(){let I,x=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const L=this._activeTargets[x];I=L.getLocalMatrix&&"_matrix"===this._targetPath?L.getLocalMatrix():L[this._targetPath],I&&I.clone?this._originalValue[x]=I.clone():this._originalValue[x]=I}_registerTargetForLateAnimationBinding(I,x){const L=I.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(L),L._lateAnimationHolders||(L._lateAnimationHolders={}),L._lateAnimationHolders[I.targetPath]||(L._lateAnimationHolders[I.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:x}),I.isAdditive?(L._lateAnimationHolders[I.targetPath].additiveAnimations.push(I),L._lateAnimationHolders[I.targetPath].totalAdditiveWeight+=I.weight):(L._lateAnimationHolders[I.targetPath].animations.push(I),L._lateAnimationHolders[I.targetPath].totalWeight+=I.weight)}_setValue(I,x,L,X,G){if(this._currentActiveTarget=x,this._weight=X,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const I=x[this._targetPath];I.clone?this._originalBlendValue=I.clone():this._originalBlendValue=I}this._originalBlendValue.m?F.d.AllowMatrixDecomposeForInterpolation?this._currentValue?B.Matrix.DecomposeLerpToRef(this._originalBlendValue,L,this._blendingFactor,this._currentValue):this._currentValue=B.Matrix.DecomposeLerp(this._originalBlendValue,L,this._blendingFactor):this._currentValue?B.Matrix.LerpToRef(this._originalBlendValue,L,this._blendingFactor,this._currentValue):this._currentValue=B.Matrix.Lerp(this._originalBlendValue,L,this._blendingFactor):this._currentValue=F.d._UniversalLerp(this._originalBlendValue,L,this._blendingFactor);const X=I&&I.animationPropertiesOverride?I.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=X}else this._currentValue?this._currentValue.X?this._currentValue.X(L):this._currentValue=L:null!==L&&void 0!==L&&L.clone?this._currentValue=L.clone():this._currentValue=L;-1!==X?this._registerTargetForLateAnimationBinding(this,this._originalValue[G]):this._animationState.loopMode===F.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[G],x[this._targetPath]):x[this._targetPath]=this._originalValue[G]+this._currentValue:x[this._targetPath]=this._currentValue,I.nW&&I.nW(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const L=this._animation.getKeys();I<L[0].frame?I=L[0].frame:I>L[L.length-1].frame&&(I=L[L.length-1].frame);const F=this._events;if(F.length)for(let G=0;G<F.length;G++)F[G].onlyOnce||(F[G].isDone=F[G].frame<I);this._currentFrame=I;const X=this._animation._interpolate(I,this._animationState);this.setValue(X,x)}_prepareForSpeedRatioChange(I){const x=this._previousElapsedTime*(this._animation.framePerSecond*I)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-x}animate(I,x,L,X,G){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const p=this._animation,B=p.targetPropertyPath;if(!B||B.length<1)return this._stopped=!0,!1;let l,W=!0;const Q=this._events;let e=0;if(this._coreRuntimeAnimation)e=L-x,l=this._coreRuntimeAnimation.currentFrame,this._currentFrame=l,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let Y;(x<this._minFrame||x>this._maxFrame)&&(x=this._minFrame),(L<this._minFrame||L>this._maxFrame)&&(L=this._maxFrame),e=L-x;let B=I*(p.framePerSecond*G)/1e3+this._absoluteFrameOffset,g=0,v=!1;const z=X&&this._animationState.loopMode===F.d.ANIMATIONLOOPMODE_YOYO;if(z){const I=(B-x)/e,L=Math.sin(I*Math.PI);B=Math.abs(L)*e+x;const F=L>=0?1:-1;this._yoyoDirection!==F&&(v=!0),this._yoyoDirection=F}if(this._previousElapsedTime=I,this._previousAbsoluteFrame=B,!X&&L>=x&&(B>=e&&G>0||B<=0&&G<0))W=!1,g=p._getKeyValue(this._maxValue);else if(!X&&x>=L&&(B<=e&&G<0||B>=0&&G>0))W=!1,g=p._getKeyValue(this._minValue);else if(this._animationState.loopMode!==F.d.ANIMATIONLOOPMODE_CYCLE){const I=L.toString()+x.toString();if(!this._offsetsCache[I]){this._animationState.repeatCount=0,this._animationState.loopMode=F.d.ANIMATIONLOOPMODE_CYCLE;const X=p._interpolate(x,this._animationState),G=p._interpolate(L,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),p.dataType){case F.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[I]=G-X;break;case F.d.ANIMATIONTYPE_QUATERNION:case F.d.ANIMATIONTYPE_VECTOR3:case F.d.ANIMATIONTYPE_VECTOR2:case F.d.ANIMATIONTYPE_SIZE:case F.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[I]=G.Ux(X)}this._highLimitsCache[I]=G}g=this._highLimitsCache[I],Y=this._offsetsCache[I]}if(void 0===Y)switch(p.dataType){case F.d.ANIMATIONTYPE_FLOAT:Y=0;break;case F.d.ANIMATIONTYPE_QUATERNION:Y=F.m;break;case F.d.ANIMATIONTYPE_VECTOR3:Y=F.q;break;case F.d.ANIMATIONTYPE_VECTOR2:Y=F.o;break;case F.d.ANIMATIONTYPE_SIZE:Y=F.n;break;case F.d.ANIMATIONTYPE_COLOR3:Y=F.e;break;case F.d.ANIMATIONTYPE_COLOR4:Y=F.i}if(this._host&&this._host.syncRoot){const I=this._host.syncRoot;l=x+e*((I.masterFrame-I.fromFrame)/(I.toFrame-I.fromFrame))}else l=B>0&&x>L||B<0&&x<L?W&&0!==e?L+B%e:x:W&&0!==e?x+B%e:L;if(!z&&(G>0&&this.currentFrame>l||G<0&&this.currentFrame<l)||z&&v){this._onLoop();for(let I=0;I<Q.length;I++)Q[I].onlyOnce||(Q[I].isDone=!1);this._animationState.key=G>0?0:p.getKeys().length-1}this._currentFrame=l,this._animationState.repeatCount=0===e?0:B/e|0,this._animationState.highLimitValue=g,this._animationState.offsetValue=Y}const g=p._interpolate(l,this._animationState);if(this.setValue(g,Y),Q.length)for(let F=0;F<Q.length;F++)if(e>=0&&l>=Q[F].frame&&Q[F].frame>=x||e<0&&l<=Q[F].frame&&Q[F].frame<=x){const I=Q[F];I.isDone||(I.onlyOnce&&(Q.splice(F,1),F--),I.isDone=!0,I.action(l))}return W||(this._stopped=!0),W}}var W=L(12823);class Q{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(I){this._weight=-1!==I?Math.min(Math.max(I,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(I){for(let x=0;x<this._runtimeAnimations.length;x++){this._runtimeAnimations[x]._prepareForSpeedRatioChange(I)}this._speedRatio=I,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,G=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,p=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0,l=arguments.length>8?arguments[8]:void 0,W=arguments.length>9&&void 0!==arguments[9]&&arguments[9],Q=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=x,this.fromFrame=L,this.toFrame=F,this.loopAnimation=G,this.onAnimationEnd=p,this.onAnimationLoop=l,this.isAdditive=W,this.playOrder=Q,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.kp=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new X.c,this.onAnimationLoopObservable=new X.c,this._scene=I,B&&this.appendAnimations(x,B),this._speedRatio=Y,I._activeAnimatables.push(this)}syncWith(I){if(this._syncRoot=I,I){const I=this._scene._activeAnimatables.indexOf(this);I>-1&&(this._scene._activeAnimatables.splice(I,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(I,x){for(let L=0;L<x.length;L++){const F=x[L],X=new l(I,F,this._scene,this);X._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(X)}}getAnimationByTargetProperty(I){const x=this._runtimeAnimations;for(let L=0;L<x.length;L++)if(x[L].animation.targetProperty===I)return x[L].animation;return null}getRuntimeAnimationByTargetProperty(I){const x=this._runtimeAnimations;for(let L=0;L<x.length;L++)if(x[L].animation.targetProperty===I)return x[L];return null}reset(){const I=this._runtimeAnimations;for(let x=0;x<I.length;x++)I[x].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(I){const x=this._runtimeAnimations;for(let L=0;L<x.length;L++)x[L].animation.enableBlending=!0,x[L].animation.blendingSpeed=I}disableBlending(){const I=this._runtimeAnimations;for(let x=0;x<I.length;x++)I[x].animation.enableBlending=!1}goToFrame(I){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const L=this._runtimeAnimations;if(L[0]){const x=L[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??L[0].currentFrame;const F=0===this.speedRatio?0:(I-this._frameToSyncFromJump)/x*1e3/this.speedRatio;this._manualJumpDelay=-F}for(let F=0;F<L.length;F++)L[F].goToFrame(I,x?this._weight:-1);this._goToFrame=I}get paused(){return this.kp}pause(){this.kp||(this.kp=!0)}restart(){this.kp=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(I,x){let L=arguments.length>2&&void 0!==arguments[2]&&arguments[2],F=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(I||x){const X=this._scene._activeAnimatables.indexOf(this);if(X>-1){const G=this._runtimeAnimations;for(let L=G.length-1;L>=0;L--){const F=G[L];I&&F.animation.name!=I||(x&&!x(F.target)||(F.dispose(),G.splice(L,1)))}0==G.length&&(L||this._scene._activeAnimatables.splice(X,1),F||this._raiseOnAnimationEnd())}}else{const I=this._scene._activeAnimatables.indexOf(this);if(I>-1){L||this._scene._activeAnimatables.splice(I,1);const x=this._runtimeAnimations;for(let I=0;I<x.length;I++)x[I].dispose();this._runtimeAnimations.length=0,F||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((I=>{this.onAnimationEndObservable.add((()=>{I(this)}),void 0,void 0,this,!0)}))}_animate(I){if(this.kp)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=I),!0;if(null===this._localDelayOffset?(this._localDelayOffset=I,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=I-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let x=!1;const L=this._runtimeAnimations;let F;for(F=0;F<L.length;F++){const X=L[F].animate(I-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);x=x||X}if(this.animationStarted=x,!x){if(this.disposeOnEnd)for(F=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(F,1),F=0;F<L.length;F++)L[F].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return x}}function e(I){if(0===I.totalWeight&&0===I.totalAdditiveWeight)return I.originalValue;let x=1;const L=B.TmpVectors.sx[0],F=B.TmpVectors.sx[1],X=B.TmpVectors.Quaternion[0];let G=0;const Y=I.animations[0],p=I.originalValue;let l=1,W=!1;if(I.totalWeight<1)l=1-I.totalWeight,p.decompose(F,X,L);else{if(G=1,x=I.totalWeight,l=Y.weight/x,1==l){if(!I.totalAdditiveWeight)return Y.currentValue;W=!0}Y.currentValue.decompose(F,X,L)}if(!W){F.scaleInPlace(l),L.scaleInPlace(l),X.scaleInPlace(l);for(let Y=G;Y<I.animations.length;Y++){const G=I.animations[Y];if(0===G.weight)continue;l=G.weight/x;const p=B.TmpVectors.sx[2],W=B.TmpVectors.sx[3],Q=B.TmpVectors.Quaternion[1];G.currentValue.decompose(W,Q,p),W.scaleAndAddToRef(l,F),Q.scaleAndAddToRef(B.Quaternion.Dot(X,Q)>0?l:-l,X),p.scaleAndAddToRef(l,L)}X.normalize()}for(let e=0;e<I.additiveAnimations.length;e++){const x=I.additiveAnimations[e];if(0===x.weight)continue;const G=B.TmpVectors.sx[2],Y=B.TmpVectors.sx[3],p=B.TmpVectors.Quaternion[1];x.currentValue.decompose(Y,p,G),Y.multiplyToRef(F,Y),B.sx.LerpToRef(F,Y,x.weight,F),X.multiplyToRef(p,p),B.Quaternion.SlerpToRef(X,p,x.weight,X),G.scaleAndAddToRef(x.weight,L)}const Q=Y?Y._animationState.workValue:B.TmpVectors.Matrix[0].clone();return B.Matrix.ComposeToRef(F,X,L,Q),Q}function g(I,x){if(0===I.totalWeight&&0===I.totalAdditiveWeight)return x;const L=I.animations[0],F=I.originalValue;let X=x;if(0===I.totalWeight&&I.totalAdditiveWeight>0)X.X(F);else if(1===I.animations.length){if(B.Quaternion.SlerpToRef(F,L.currentValue,Math.min(1,I.totalWeight),X),0===I.totalAdditiveWeight)return X}else if(I.animations.length>1){let L,G,Y=1;if(I.totalWeight<1){const x=1-I.totalWeight;L=[],G=[],L.push(F),G.push(x)}else{if(2===I.animations.length&&(B.Quaternion.SlerpToRef(I.animations[0].currentValue,I.animations[1].currentValue,I.animations[1].weight/I.totalWeight,x),0===I.totalAdditiveWeight))return x;L=[],G=[],Y=I.totalWeight}for(let x=0;x<I.animations.length;x++){const F=I.animations[x];L.push(F.currentValue),G.push(F.weight/Y)}let p=0;for(let I=0;I<L.length;)I?(p+=G[I],B.Quaternion.SlerpToRef(X,L[I],G[I]/p,X),I++):(B.Quaternion.SlerpToRef(L[I],L[I+1],G[I+1]/(G[I]+G[I+1]),x),X=x,p=G[I]+G[I+1],I+=2)}for(let G=0;G<I.additiveAnimations.length;G++){const x=I.additiveAnimations[G];0!==x.weight&&(X.multiplyToRef(x.currentValue,B.TmpVectors.Quaternion[0]),B.Quaternion.SlerpToRef(X,B.TmpVectors.Quaternion[0],x.weight,X))}return X}var v,z,H=L(13218);v=H.b,(z=p.b)&&(z.prototype.copyAnimationRange=function(I,x,L){let X=arguments.length>3&&void 0!==arguments[3]&&arguments[3],G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new F.d(this.name,"_matrix",I.animations[0].framePerSecond,F.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Y=I.animations[0].getRange(x);if(!Y)return!1;const p=Y.from,B=Y.to,l=I.animations[0].getKeys(),W=I.length,Q=I.getParent(),e=this.getParent(),g=X&&Q&&W&&this.length&&W!==this.length,v=g&&e&&Q?e.length/Q.length:1,z=X&&!e&&G&&(1!==G.x||1!==G.y||1!==G.z),H=this.animations[0].getKeys();let s,U,q;for(let F=0,y=l.length;F<y;F++)s=l[F],s.frame>=p&&s.frame<=B&&(X?(q=s.value.clone(),g?(U=q.getTranslation(),q.setTranslation(U.scaleInPlace(v))):z&&G?(U=q.getTranslation(),q.setTranslation(U.multiplyInPlace(G))):q=s.value):q=s.value,H.push({frame:s.frame+L,value:q}));return this.animations[0].createRange(x,p+L,B+L),!0}),v&&(v.prototype._animate=function(I){if(!this.animationsEnabled)return;const x=W.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=x}this.deltaTime=void 0!==I?I:this.useConstantAnimationDeltaTime?16:(x-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=x;const L=this._activeAnimatables;if(0===L.length)return;this._animationTime+=this.deltaTime;const X=this._animationTime;for(let F=0;F<L.length;F++){const I=L[F];!I._animate(X)&&I.disposeOnEnd&&F--}!function(I){if(I._registeredForLateAnimationBindings.length){for(let x=0;x<I._registeredForLateAnimationBindings.length;x++){const L=I._registeredForLateAnimationBindings.data[x];for(const I in L._lateAnimationHolders){const x=L._lateAnimationHolders[I],X=x.animations[0],G=x.originalValue;if(void 0===G||null===G)continue;const Y=F.d.AllowMatrixDecomposeForInterpolation&&G.m;let p=L[I];if(Y)p=e(x);else if(void 0!==G.w)p=g(x,p||B.Quaternion.Identity());else{let I=0,L=1;const Y=X&&X._animationState.loopMode===F.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(x.totalWeight<1)p=Y?G.clone?G.clone():G:X&&G.scale?G.scale(1-x.totalWeight):X?G*(1-x.totalWeight):G.clone?G.clone():G;else if(X){L=x.totalWeight;const F=X.weight/L;p=1!==F?X.currentValue.scale?X.currentValue.scale(F):X.currentValue*F:X.currentValue,Y&&(p.addToRef?p.addToRef(G,p):p+=G),I=1}for(let F=I;F<x.animations.length;F++){const I=x.animations[F],X=I.weight/L;X&&(I.currentValue.scaleAndAddToRef?I.currentValue.scaleAndAddToRef(X,p):p+=I.currentValue*X)}for(let F=0;F<x.additiveAnimations.length;F++){const I=x.additiveAnimations[F],L=I.weight;L&&(I.currentValue.scaleAndAddToRef?I.currentValue.scaleAndAddToRef(L,p):p+=I.currentValue*L)}}L[I]=p}L._lateAnimationHolders={}}I._registeredForLateAnimationBindings.reset()}}(this)},v.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((I,x)=>I.playOrder-x.playOrder))},v.prototype.beginWeightedAnimation=function(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,X=arguments.length>4?arguments[4]:void 0,G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,p=arguments.length>7?arguments[7]:void 0,B=arguments.length>8?arguments[8]:void 0,l=arguments.length>9?arguments[9]:void 0,W=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const Q=this.beginAnimation(I,x,L,X,G,Y,p,!1,B,l,W);return Q.weight=F,Q},v.prototype.beginAnimation=function(I,x,L,F){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,G=arguments.length>5?arguments[5]:void 0,Y=arguments.length>6?arguments[6]:void 0,p=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],B=arguments.length>8?arguments[8]:void 0,l=arguments.length>9?arguments[9]:void 0,W=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(X<0){const I=x;x=L,L=I,X=-X}x>L&&(X=-X),p&&this.stopAnimation(I,void 0,B),Y||(Y=new Q(this,I,x,L,F,X,G,void 0,l,W));const e=!B||B(I);if(I.animations&&e&&Y.appendAnimations(I,I.animations),I.getAnimatables){const W=I.getAnimatables();for(let I=0;I<W.length;I++)this.beginAnimation(W[I],x,L,F,X,G,Y,p,B,l)}return Y.reset(),Y},v.prototype.beginHierarchyAnimation=function(I,x,L,F,X){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,p=arguments.length>7?arguments[7]:void 0,B=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],l=arguments.length>9?arguments[9]:void 0,W=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const Q=I.getDescendants(x),e=[];e.push(this.beginAnimation(I,L,F,X,G,Y,p,B,l,void 0,W));for(const g of Q)e.push(this.beginAnimation(g,L,F,X,G,Y,p,B,l,void 0,W));return e},v.prototype.beginDirectAnimation=function(I,x,L,F,X){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(G<0){const I=L;L=F,F=I,G=-G}return L>F&&(G=-G),new Q(this,I,L,F,X,G,arguments.length>6?arguments[6]:void 0,x,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},v.prototype.beginDirectHierarchyAnimation=function(I,x,L,F,X,G,Y,p,B){let l=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const W=I.getDescendants(x),Q=[];Q.push(this.beginDirectAnimation(I,L,F,X,G,Y,p,B,l));for(const e of W)Q.push(this.beginDirectAnimation(e,L,F,X,G,Y,p,B,l));return Q},v.prototype.getAnimatableByTarget=function(I){for(let x=0;x<this._activeAnimatables.length;x++)if(this._activeAnimatables[x].target===I)return this._activeAnimatables[x];return null},v.prototype.getAllAnimatablesByTarget=function(I){const x=[];for(let L=0;L<this._activeAnimatables.length;L++)this._activeAnimatables[L].target===I&&x.push(this._activeAnimatables[L]);return x},v.prototype.stopAnimation=function(I,x,L){const F=this.getAllAnimatablesByTarget(I);for(const X of F)X.stop(x,L)},v.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let I=0;I<this._activeAnimatables.length;I++)this._activeAnimatables[I].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const I of this.animationGroups)I.stop()});class s{getClassName(){return"TargetedAnimation"}serialize(){const I={};return I.animation=this.animation.serialize(),I.targetId=this.target.id,I}}class U{get mask(){return this._mask}set mask(I){this._mask!==I&&(this._mask=I,this.syncWithMask(!0))}syncWithMask(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||I){this._numActiveAnimatables=0;for(let I=0;I<this._animatables.length;++I){const x=this._animatables[I];!this.mask||this.mask.disabled||this.mask.retainsTarget(x.target.name)?(this._numActiveAnimatables++,x.paused&&x.restart()):x.paused||x.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let I=0;I<this._animatables.length;++I){const x=this._animatables[I];this.mask.retainsTarget(x.target.name)||(x.stop(),this._animatables.splice(I,1),--I)}for(let I=0;I<this._targetedAnimations.length;I++){const x=this._targetedAnimations[I];this.mask.retainsTarget(x.target.name)||(this._targetedAnimations.splice(I,1),--I)}}}get from(){return this._from}set from(I){if(this._from!==I){this._from=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].fromFrame=this._from}}}get to(){return this._to}set to(I){if(this._to!==I){this._to=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(I){if(this._speedRatio!==I){this._speedRatio=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(I){if(this._loopAnimation!==I){this._loopAnimation=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(I){if(this._isAdditive!==I){this._isAdditive=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(I){this._weight!==I&&(this._weight=I,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(I){if(this._playOrder!==I&&(this._playOrder=I,this._animatables.length>0)){for(let I=0;I<this._animatables.length;I++)this._animatables[I].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(I){if(this._enableBlending!==I&&(this._enableBlending=I,null!==I))for(let x=0;x<this._targetedAnimations.length;++x)this._targetedAnimations[x].animation.enableBlending=I}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(I){if(this._blendingSpeed!==I&&(this._blendingSpeed=I,null!==I))for(let x=0;x<this._targetedAnimations.length;++x)this._targetedAnimations[x].animation.blendingSpeed=I}getLength(I,x){I=I??this._from;return((x=x??this._to)-I)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(I){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],L=arguments.length>2&&void 0!==arguments[2]&&arguments[2],F=arguments.length>3?arguments[3]:void 0;if(0===I.length)return null;F=F??I[0].weight;let X=Number.MAX_VALUE,G=-Number.MAX_VALUE;if(L)for(const p of I)p.from<X&&(X=p.from),p.to>G&&(G=p.to);const Y=new U(I[0].name+"_merged",I[0]._scene,F);for(const p of I){L&&p.normalize(X,G);for(const I of p.targetedAnimations)Y.addTargetedAnimation(I.animation,I.target);x&&p.dispose()}return Y}constructor(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=I,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new X.c,this.onAnimationLoopObservable=new X.c,this.onAnimationGroupLoopObservable=new X.c,this.onAnimationGroupEndObservable=new X.c,this.onAnimationGroupPauseObservable=new X.c,this.onAnimationGroupPlayObservable=new X.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=x||G.e.LastCreatedScene,this._weight=L,this._playOrder=F,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(I,x){const L=new s;L.animation=I,L.target=x;const F=I.getKeys();return this._from>F[0].frame&&(this._from=F[0].frame),this._to<F[F.length-1].frame&&(this._to=F[F.length-1].frame),null!==this._enableBlending&&(I.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(I.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(L),this._shouldStart=!0,L}removeTargetedAnimation(I){for(let x=this._targetedAnimations.length-1;x>-1;x--){this._targetedAnimations[x].animation===I&&this._targetedAnimations.splice(x,1)}}normalize(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==I&&(I=this._from),null==x&&(x=this._to);for(let L=0;L<this._targetedAnimations.length;L++){const F=this._targetedAnimations[L].animation.getKeys(),X=F[0],G=F[F.length-1];if(X.frame>I){const x={frame:I,value:X.value,inTangent:X.inTangent,outTangent:X.outTangent,interpolation:X.interpolation};F.splice(0,0,x)}if(G.frame<x){const I={frame:x,value:G.value,inTangent:G.inTangent,outTangent:G.outTangent,interpolation:G.interpolation};F.push(I)}}return this._from=I,this._to=x,this}_processLoop(I,x,L){I.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(x),this._animationLoopFlags[L]||(this._animationLoopFlags[L]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0],x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,L=arguments.length>2?arguments[2]:void 0,F=arguments.length>3?arguments[3]:void 0,X=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=I,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let G=0;G<this._targetedAnimations.length;G++){const Y=this._targetedAnimations[G],p=this._scene.beginDirectAnimation(Y.target,[Y.animation],void 0!==L?L:this._from,void 0!==F?F:this._to,I,x,void 0,void 0,void 0!==X?X:this._isAdditive);p.weight=this._weight,p.playOrder=this._playOrder,p.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Y),this._checkAnimationGroupEnded(p)},this._processLoop(p,Y,G),this._animatables.push(p)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=x,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let I=0;I<this._animatables.length;I++){this._animatables[I].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(I){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==I&&(this.loopAnimation=I),this.restart()):(this.stop(),this.start(I,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let I=0;I<this._animatables.length;I++){this._animatables[I].reset()}return this}restart(){if(!this._isStarted)return this;for(let I=0;I<this._animatables.length;I++){this._animatables[I].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const x=this._animatables.slice();for(let F=0;F<x.length;F++)x[F].stop(void 0,void 0,!0,I);let L=0;for(let F=0;F<this._scene._activeAnimatables.length;F++){const x=this._scene._activeAnimatables[F];x._runtimeAnimations.length>0?this._scene._activeAnimatables[L++]=x:I&&this._checkAnimationGroupEnded(x,I)}return this._scene._activeAnimatables.length=L,this._isStarted=!1,this}setWeightForAllAnimatables(I){for(let x=0;x<this._animatables.length;x++){this._animatables[x].weight=I}return this}syncAllAnimationsWith(I){for(let x=0;x<this._animatables.length;x++){this._animatables[x].syncWith(I)}return this}goToFrame(I){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let L=0;L<this._animatables.length;L++){this._animatables[L].goToFrame(I,x)}return this}getCurrentFrame(){var I;return(null===(I=this.animatables[0])||void 0===I?void 0:I.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const I=this._scene.animationGroups.indexOf(this);if(I>-1&&this._scene.animationGroups.splice(I,1),this._parentContainer){const I=this._parentContainer.animationGroups.indexOf(this);I>-1&&this._parentContainer.animationGroups.splice(I,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(I){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const L=this._animatables.indexOf(I);L>-1&&this._animatables.splice(L,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,x||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(I,x){let L=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const F=new U(I||this.name,this._scene,this._weight,this._playOrder);F._from=this.from,F._to=this.to,F._speedRatio=this.speedRatio,F._loopAnimation=this.loopAnimation,F._isAdditive=this.isAdditive,F._enableBlending=this.enableBlending,F._blendingSpeed=this.blendingSpeed,F.metadata=this.metadata,F.mask=this.mask;for(const X of this._targetedAnimations)F.addTargetedAnimation(L?X.animation.clone():X.animation,x?x(X.target):X.target);return F}serialize(){const I={};I.name=this.name,I.from=this.from,I.to=this.to,I.speedRatio=this.speedRatio,I.loopAnimation=this.loopAnimation,I.isAdditive=this.isAdditive,I.weight=this.weight,I.playOrder=this.playOrder,I.enableBlending=this.enableBlending,I.blendingSpeed=this.blendingSpeed,I.targetedAnimations=[];for(let x=0;x<this.targetedAnimations.length;x++){const L=this.targetedAnimations[x];I.targetedAnimations[x]=L.serialize()}return Y.d&&Y.d.HasTags(this)&&(I.tags=Y.d.GetTags(this)),this.metadata&&(I.metadata=this.metadata),I}static Parse(I,x){const L=new U(I.name,x,I.weight,I.playOrder);for(let X=0;X<I.targetedAnimations.length;X++){const G=I.targetedAnimations[X],Y=F.d.Parse(G.animation),p=G.targetId;if("influence"===G.animation.property){const I=x.getMorphTargetById(p);I&&L.addTargetedAnimation(Y,I)}else{const I=x.getNodeById(p);null!=I&&L.addTargetedAnimation(Y,I)}}return Y.d&&Y.d.AddTagsTo(L,I.tags),null!==I.from&&null!==I.to&&L.normalize(I.from,I.to),void 0!==I.speedRatio&&(L._speedRatio=I.speedRatio),void 0!==I.loopAnimation&&(L._loopAnimation=I.loopAnimation),void 0!==I.isAdditive&&(L._isAdditive=I.isAdditive),void 0!==I.weight&&(L._weight=I.weight),void 0!==I.playOrder&&(L._playOrder=I.playOrder),void 0!==I.enableBlending&&(L._enableBlending=I.enableBlending),void 0!==I.blendingSpeed&&(L._blendingSpeed=I.blendingSpeed),void 0!==I.metadata&&(L.metadata=I.metadata),L}static MakeAnimationAdditive(I,x,L){let X;X="object"===typeof x?x:{referenceFrame:x,range:L,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let G=I;X.cloneOriginalAnimationGroup&&(G=I.clone(X.clonedAnimationGroupName||G.name));const Y=G.targetedAnimations;for(let p=0;p<Y.length;p++){const I=Y[p];I.animation=F.d.MakeAnimationAdditive(I.animation,X)}if(G.isAdditive=!0,X.clipKeys){let I=Number.MAX_VALUE,x=-Number.MAX_VALUE;const L=G.targetedAnimations;for(let F=0;F<L.length;F++){const X=L[F].animation.getKeys();I>X[0].frame&&(I=X[0].frame),x<X[X.length-1].frame&&(x=X[X.length-1].frame)}G._from=I,G._to=x}return G}static ClipKeys(I,x,L,F,X){const G=I.clone(F||I.name);return U.ClipKeysInPlace(G,x,L,X)}static ClipKeysInPlace(I,x,L,F){return U.ClipInPlace(I,x,L,F,!1)}static ClipFrames(I,x,L,F,X){const G=I.clone(F||I.name);return U.ClipFramesInPlace(G,x,L,X)}static ClipFramesInPlace(I,x,L,F){return U.ClipInPlace(I,x,L,F,!0)}static ClipInPlace(I,x,L,F){let X=arguments.length>4&&void 0!==arguments[4]&&arguments[4],G=Number.MAX_VALUE,Y=-Number.MAX_VALUE;const p=I.targetedAnimations;for(let B=0;B<p.length;B++){const I=p[B],l=F?I.animation:I.animation.clone();X&&(l.createKeyForFrame(x),l.createKeyForFrame(L));const W=l.getKeys(),Q=[];let e=Number.MAX_VALUE;for(let F=0;F<W.length;F++){const I=W[F];if(!X&&F>=x&&F<=L||X&&I.frame>=x&&I.frame<=L){const x={frame:I.frame,value:I.value.clone?I.value.clone():I.value,inTangent:I.inTangent,outTangent:I.outTangent,interpolation:I.interpolation,lockedTangent:I.lockedTangent};e===Number.MAX_VALUE&&(e=x.frame),x.frame-=e,Q.push(x)}}0!==Q.length?(G>Q[0].frame&&(G=Q[0].frame),Y<Q[Q.length-1].frame&&(Y=Q[Q.length-1].frame),l.setKeys(Q,!0),I.animation=l):(p.splice(B,1),B--)}return I._from=G,I._to=Y,I}getClassName(){return"AnimationGroup"}toString(I){let x="Name: "+this.name;return x+=", type: "+this.getClassName(),I&&(x+=", from: "+this._from,x+=", to: "+this._to,x+=", isStarted: "+this._isStarted,x+=", speedRatio: "+this._speedRatio,x+=", targetedAnimations length: "+this._targetedAnimations.length,x+=", animatables length: "+this._animatables),x}}}}]);