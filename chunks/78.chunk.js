"use strict";(self.fjf2z1c8il8=self.fjf2z1c8il8||[]).push([[78],{15696:(g,i,a)=>{a.r(i),a.d(i,{AnimationGroup:()=>R,TargetedAnimation:()=>p});var n=a(12994),L=a(12286),d=a(12316),b=a(12492),k=a(14115),e=a(12452);class N{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(g,i,a,L){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=i,this._target=g,this._scene=a,this._host=L,this._activeTargets=[],i._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===n.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=e.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const g={frame:0,value:this._minValue};this._keys.splice(0,0,g)}if(this._target instanceof Array){let g=0;for(const i of this._target)this._preparePath(i,g),this._getOriginalValues(g),g++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const d=i.getEvents();if(d&&d.length>0)for(const n of d)this._events.push(n._clone());this._enableBlending=g&&g.animationPropertiesOverride?g.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const a=this._animation.targetPropertyPath;if(a.length>1){let n=g;for(let g=0;g<a.length-1;g++){const i=a[g];if(n=n[i],void 0===n)throw new Error(`Invalid property (${i}) in property path (${a.join(".")})`)}this._targetPath=a[a.length-1],this._activeTargets[i]=n}else this._targetPath=a[0],this._activeTargets[i]=g;if(void 0===this._activeTargets[i][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${a.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let g=0;for(const i of this._target)void 0!==this._originalValue[g]&&this._setValue(i,this._activeTargets[g],this._originalValue[g],-1,g),g++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let g=0;g<this._events.length;g++)this._events[g].isDone=!1}isStopped(){return this._stopped}dispose(){const g=this._animation.runtimeAnimations.indexOf(this);g>-1&&this._animation.runtimeAnimations.splice(g,1)}setValue(g,i){if(this._targetIsArray)for(let a=0;a<this._target.length;a++){const n=this._target[a];this._setValue(n,this._activeTargets[a],g,i,a)}else this._setValue(this._target,this._directTarget,g,i,0)}_getOriginalValues(){let g,i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const a=this._activeTargets[i];g=a.getLocalMatrix&&"_matrix"===this._targetPath?a.getLocalMatrix():a[this._targetPath],g&&g.clone?this._originalValue[i]=g.clone():this._originalValue[i]=g}_registerTargetForLateAnimationBinding(g,i){const a=g.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(a),a._lateAnimationHolders||(a._lateAnimationHolders={}),a._lateAnimationHolders[g.targetPath]||(a._lateAnimationHolders[g.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:i}),g.isAdditive?(a._lateAnimationHolders[g.targetPath].additiveAnimations.push(g),a._lateAnimationHolders[g.targetPath].totalAdditiveWeight+=g.weight):(a._lateAnimationHolders[g.targetPath].animations.push(g),a._lateAnimationHolders[g.targetPath].totalWeight+=g.weight)}_setValue(g,i,a,L,d){if(this._currentActiveTarget=i,this._weight=L,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const g=i[this._targetPath];g.clone?this._originalBlendValue=g.clone():this._originalBlendValue=g}this._originalBlendValue.m?n.b.AllowMatrixDecomposeForInterpolation?this._currentValue?e.Matrix.DecomposeLerpToRef(this._originalBlendValue,a,this._blendingFactor,this._currentValue):this._currentValue=e.Matrix.DecomposeLerp(this._originalBlendValue,a,this._blendingFactor):this._currentValue?e.Matrix.LerpToRef(this._originalBlendValue,a,this._blendingFactor,this._currentValue):this._currentValue=e.Matrix.Lerp(this._originalBlendValue,a,this._blendingFactor):this._currentValue=n.b._UniversalLerp(this._originalBlendValue,a,this._blendingFactor);const L=g&&g.animationPropertiesOverride?g.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=L}else this._currentValue?this._currentValue.I?this._currentValue.I(a):this._currentValue=a:null!==a&&void 0!==a&&a.clone?this._currentValue=a.clone():this._currentValue=a;-1!==L?this._registerTargetForLateAnimationBinding(this,this._originalValue[d]):this._animationState.loopMode===n.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[d],i[this._targetPath]):i[this._targetPath]=this._originalValue[d]+this._currentValue:i[this._targetPath]=this._currentValue,g.rF&&g.rF(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const a=this._animation.getKeys();g<a[0].frame?g=a[0].frame:g>a[a.length-1].frame&&(g=a[a.length-1].frame);const n=this._events;if(n.length)for(let d=0;d<n.length;d++)n[d].onlyOnce||(n[d].isDone=n[d].frame<g);this._currentFrame=g;const L=this._animation._interpolate(g,this._animationState);this.setValue(L,i)}_prepareForSpeedRatioChange(g){const i=this._previousElapsedTime*(this._animation.framePerSecond*g)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-i}animate(g,i,a,L,d){let b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const k=this._animation,e=k.targetPropertyPath;if(!e||e.length<1)return this._stopped=!0,!1;let N,F=!0;const I=this._events;let j=0;if(this._coreRuntimeAnimation)j=a-i,N=this._coreRuntimeAnimation.currentFrame,this._currentFrame=N,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let b;(i<this._minFrame||i>this._maxFrame)&&(i=this._minFrame),(a<this._minFrame||a>this._maxFrame)&&(a=this._maxFrame),j=a-i;let e=g*(k.framePerSecond*d)/1e3+this._absoluteFrameOffset,y=0,B=!1;const c=L&&this._animationState.loopMode===n.b.ANIMATIONLOOPMODE_YOYO;if(c){const g=(e-i)/j,a=Math.sin(g*Math.PI);e=Math.abs(a)*j+i;const n=a>=0?1:-1;this._yoyoDirection!==n&&(B=!0),this._yoyoDirection=n}if(this._previousElapsedTime=g,this._previousAbsoluteFrame=e,!L&&a>=i&&(e>=j&&d>0||e<=0&&d<0))F=!1,y=k._getKeyValue(this._maxValue);else if(!L&&i>=a&&(e<=j&&d<0||e>=0&&d>0))F=!1,y=k._getKeyValue(this._minValue);else if(this._animationState.loopMode!==n.b.ANIMATIONLOOPMODE_CYCLE){const g=a.toString()+i.toString();if(!this._offsetsCache[g]){this._animationState.repeatCount=0,this._animationState.loopMode=n.b.ANIMATIONLOOPMODE_CYCLE;const L=k._interpolate(i,this._animationState),d=k._interpolate(a,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),k.dataType){case n.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[g]=d-L;break;case n.b.ANIMATIONTYPE_QUATERNION:case n.b.ANIMATIONTYPE_VECTOR3:case n.b.ANIMATIONTYPE_VECTOR2:case n.b.ANIMATIONTYPE_SIZE:case n.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[g]=d.ci(L)}this._highLimitsCache[g]=d}y=this._highLimitsCache[g],b=this._offsetsCache[g]}if(void 0===b)switch(k.dataType){case n.b.ANIMATIONTYPE_FLOAT:b=0;break;case n.b.ANIMATIONTYPE_QUATERNION:b=n.j;break;case n.b.ANIMATIONTYPE_VECTOR3:b=n.q;break;case n.b.ANIMATIONTYPE_VECTOR2:b=n.o;break;case n.b.ANIMATIONTYPE_SIZE:b=n.k;break;case n.b.ANIMATIONTYPE_COLOR3:b=n.f;break;case n.b.ANIMATIONTYPE_COLOR4:b=n.g}if(this._host&&this._host.syncRoot){const g=this._host.syncRoot;N=i+j*((g.masterFrame-g.fromFrame)/(g.toFrame-g.fromFrame))}else N=e>0&&i>a||e<0&&i<a?F&&0!==j?a+e%j:i:F&&0!==j?i+e%j:a;if(!c&&(d>0&&this.currentFrame>N||d<0&&this.currentFrame<N)||c&&B){this._onLoop();for(let g=0;g<I.length;g++)I[g].onlyOnce||(I[g].isDone=!1);this._animationState.key=d>0?0:k.getKeys().length-1}this._currentFrame=N,this._animationState.repeatCount=0===j?0:e/j|0,this._animationState.highLimitValue=y,this._animationState.offsetValue=b}const y=k._interpolate(N,this._animationState);if(this.setValue(y,b),I.length)for(let n=0;n<I.length;n++)if(j>=0&&N>=I[n].frame&&I[n].frame>=i||j<0&&N<=I[n].frame&&I[n].frame<=i){const g=I[n];g.isDone||(g.onlyOnce&&(I.splice(n,1),n--),g.isDone=!0,g.action(N))}return F||(this._stopped=!0),F}}var F=a(12301);class I{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(g){this._weight=-1!==g?Math.min(Math.max(g,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(g){for(let i=0;i<this._runtimeAnimations.length;i++){this._runtimeAnimations[i]._prepareForSpeedRatioChange(g)}this._speedRatio=g,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(g,i){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,d=arguments.length>4&&void 0!==arguments[4]&&arguments[4],b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,e=arguments.length>7?arguments[7]:void 0,N=arguments.length>8?arguments[8]:void 0,F=arguments.length>9&&void 0!==arguments[9]&&arguments[9],I=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=i,this.fromFrame=a,this.toFrame=n,this.loopAnimation=d,this.onAnimationEnd=k,this.onAnimationLoop=N,this.isAdditive=F,this.playOrder=I,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Ye=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new L.b,this.onAnimationLoopObservable=new L.b,this._scene=g,e&&this.appendAnimations(i,e),this._speedRatio=b,g._activeAnimatables.push(this)}syncWith(g){if(this._syncRoot=g,g){const g=this._scene._activeAnimatables.indexOf(this);g>-1&&(this._scene._activeAnimatables.splice(g,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(g,i){for(let a=0;a<i.length;a++){const n=i[a],L=new N(g,n,this._scene,this);L._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(L)}}getAnimationByTargetProperty(g){const i=this._runtimeAnimations;for(let a=0;a<i.length;a++)if(i[a].animation.targetProperty===g)return i[a].animation;return null}getRuntimeAnimationByTargetProperty(g){const i=this._runtimeAnimations;for(let a=0;a<i.length;a++)if(i[a].animation.targetProperty===g)return i[a];return null}reset(){const g=this._runtimeAnimations;for(let i=0;i<g.length;i++)g[i].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(g){const i=this._runtimeAnimations;for(let a=0;a<i.length;a++)i[a].animation.enableBlending=!0,i[a].animation.blendingSpeed=g}disableBlending(){const g=this._runtimeAnimations;for(let i=0;i<g.length;i++)g[i].animation.enableBlending=!1}goToFrame(g){let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const a=this._runtimeAnimations;if(a[0]){const i=a[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??a[0].currentFrame;const n=0===this.speedRatio?0:(g-this._frameToSyncFromJump)/i*1e3/this.speedRatio;this._manualJumpDelay=-n}for(let n=0;n<a.length;n++)a[n].goToFrame(g,i?this._weight:-1);this._goToFrame=g}get paused(){return this.Ye}pause(){this.Ye||(this.Ye=!0)}restart(){this.Ye=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(g,i){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(g||i){const L=this._scene._activeAnimatables.indexOf(this);if(L>-1){const d=this._runtimeAnimations;for(let a=d.length-1;a>=0;a--){const n=d[a];g&&n.animation.name!=g||(i&&!i(n.target)||(n.dispose(),d.splice(a,1)))}0==d.length&&(a||this._scene._activeAnimatables.splice(L,1),n||this._raiseOnAnimationEnd())}}else{const g=this._scene._activeAnimatables.indexOf(this);if(g>-1){a||this._scene._activeAnimatables.splice(g,1);const i=this._runtimeAnimations;for(let g=0;g<i.length;g++)i[g].dispose();this._runtimeAnimations.length=0,n||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((g=>{this.onAnimationEndObservable.add((()=>{g(this)}),void 0,void 0,this,!0)}))}_animate(g){if(this.Ye)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=g),!0;if(null===this._localDelayOffset?(this._localDelayOffset=g,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=g-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let i=!1;const a=this._runtimeAnimations;let n;for(n=0;n<a.length;n++){const L=a[n].animate(g-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);i=i||L}if(this.animationStarted=i,!i){if(this.disposeOnEnd)for(n=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(n,1),n=0;n<a.length;n++)a[n].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return i}}function j(g){if(0===g.totalWeight&&0===g.totalAdditiveWeight)return g.originalValue;let i=1;const a=e.TmpVectors.Bi[0],n=e.TmpVectors.Bi[1],L=e.TmpVectors.Quaternion[0];let d=0;const b=g.animations[0],k=g.originalValue;let N=1,F=!1;if(g.totalWeight<1)N=1-g.totalWeight,k.decompose(n,L,a);else{if(d=1,i=g.totalWeight,N=b.weight/i,1==N){if(!g.totalAdditiveWeight)return b.currentValue;F=!0}b.currentValue.decompose(n,L,a)}if(!F){n.scaleInPlace(N),a.scaleInPlace(N),L.scaleInPlace(N);for(let b=d;b<g.animations.length;b++){const d=g.animations[b];if(0===d.weight)continue;N=d.weight/i;const k=e.TmpVectors.Bi[2],F=e.TmpVectors.Bi[3],I=e.TmpVectors.Quaternion[1];d.currentValue.decompose(F,I,k),F.scaleAndAddToRef(N,n),I.scaleAndAddToRef(e.Quaternion.Dot(L,I)>0?N:-N,L),k.scaleAndAddToRef(N,a)}L.normalize()}for(let j=0;j<g.additiveAnimations.length;j++){const i=g.additiveAnimations[j];if(0===i.weight)continue;const d=e.TmpVectors.Bi[2],b=e.TmpVectors.Bi[3],k=e.TmpVectors.Quaternion[1];i.currentValue.decompose(b,k,d),b.multiplyToRef(n,b),e.Bi.LerpToRef(n,b,i.weight,n),L.multiplyToRef(k,k),e.Quaternion.SlerpToRef(L,k,i.weight,L),d.scaleAndAddToRef(i.weight,a)}const I=b?b._animationState.workValue:e.TmpVectors.Matrix[0].clone();return e.Matrix.ComposeToRef(n,L,a,I),I}function y(g,i){if(0===g.totalWeight&&0===g.totalAdditiveWeight)return i;const a=g.animations[0],n=g.originalValue;let L=i;if(0===g.totalWeight&&g.totalAdditiveWeight>0)L.I(n);else if(1===g.animations.length){if(e.Quaternion.SlerpToRef(n,a.currentValue,Math.min(1,g.totalWeight),L),0===g.totalAdditiveWeight)return L}else if(g.animations.length>1){let a,d,b=1;if(g.totalWeight<1){const i=1-g.totalWeight;a=[],d=[],a.push(n),d.push(i)}else{if(2===g.animations.length&&(e.Quaternion.SlerpToRef(g.animations[0].currentValue,g.animations[1].currentValue,g.animations[1].weight/g.totalWeight,i),0===g.totalAdditiveWeight))return i;a=[],d=[],b=g.totalWeight}for(let i=0;i<g.animations.length;i++){const n=g.animations[i];a.push(n.currentValue),d.push(n.weight/b)}let k=0;for(let g=0;g<a.length;)g?(k+=d[g],e.Quaternion.SlerpToRef(L,a[g],d[g]/k,L),g++):(e.Quaternion.SlerpToRef(a[g],a[g+1],d[g+1]/(d[g]+d[g+1]),i),L=i,k=d[g]+d[g+1],g+=2)}for(let d=0;d<g.additiveAnimations.length;d++){const i=g.additiveAnimations[d];0!==i.weight&&(L.multiplyToRef(i.currentValue,e.TmpVectors.Quaternion[0]),e.Quaternion.SlerpToRef(L,e.TmpVectors.Quaternion[0],i.weight,L))}return L}var B,c,D=a(12692);B=D.e,(c=k.d)&&(c.prototype.copyAnimationRange=function(g,i,a){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3],d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new n.b(this.name,"_matrix",g.animations[0].framePerSecond,n.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const b=g.animations[0].getRange(i);if(!b)return!1;const k=b.from,e=b.to,N=g.animations[0].getKeys(),F=g.length,I=g.getParent(),j=this.getParent(),y=L&&I&&F&&this.length&&F!==this.length,B=y&&j&&I?j.length/I.length:1,c=L&&!j&&d&&(1!==d.x||1!==d.y||1!==d.z),D=this.animations[0].getKeys();let p,R,x;for(let n=0,E=N.length;n<E;n++)p=N[n],p.frame>=k&&p.frame<=e&&(L?(x=p.value.clone(),y?(R=x.getTranslation(),x.setTranslation(R.scaleInPlace(B))):c&&d?(R=x.getTranslation(),x.setTranslation(R.multiplyInPlace(d))):x=p.value):x=p.value,D.push({frame:p.frame+a,value:x}));return this.animations[0].createRange(i,k+a,e+a),!0}),B&&(B.prototype._animate=function(g){if(!this.animationsEnabled)return;const i=F.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=i}this.deltaTime=void 0!==g?g:this.useConstantAnimationDeltaTime?16:(i-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=i;const a=this._activeAnimatables;if(0===a.length)return;this._animationTime+=this.deltaTime;const L=this._animationTime;for(let n=0;n<a.length;n++){const g=a[n];!g._animate(L)&&g.disposeOnEnd&&n--}!function(g){if(g._registeredForLateAnimationBindings.length){for(let i=0;i<g._registeredForLateAnimationBindings.length;i++){const a=g._registeredForLateAnimationBindings.data[i];for(const g in a._lateAnimationHolders){const i=a._lateAnimationHolders[g],L=i.animations[0],d=i.originalValue;if(void 0===d||null===d)continue;const b=n.b.AllowMatrixDecomposeForInterpolation&&d.m;let k=a[g];if(b)k=j(i);else if(void 0!==d.w)k=y(i,k||e.Quaternion.Identity());else{let g=0,a=1;const b=L&&L._animationState.loopMode===n.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(i.totalWeight<1)k=b?d.clone?d.clone():d:L&&d.scale?d.scale(1-i.totalWeight):L?d*(1-i.totalWeight):d.clone?d.clone():d;else if(L){a=i.totalWeight;const n=L.weight/a;k=1!==n?L.currentValue.scale?L.currentValue.scale(n):L.currentValue*n:L.currentValue,b&&(k.addToRef?k.addToRef(d,k):k+=d),g=1}for(let n=g;n<i.animations.length;n++){const g=i.animations[n],L=g.weight/a;L&&(g.currentValue.scaleAndAddToRef?g.currentValue.scaleAndAddToRef(L,k):k+=g.currentValue*L)}for(let n=0;n<i.additiveAnimations.length;n++){const g=i.additiveAnimations[n],a=g.weight;a&&(g.currentValue.scaleAndAddToRef?g.currentValue.scaleAndAddToRef(a,k):k+=g.currentValue*a)}}a[g]=k}a._lateAnimationHolders={}}g._registeredForLateAnimationBindings.reset()}}(this)},B.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((g,i)=>g.playOrder-i.playOrder))},B.prototype.beginWeightedAnimation=function(g,i,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,L=arguments.length>4?arguments[4]:void 0,d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,b=arguments.length>6?arguments[6]:void 0,k=arguments.length>7?arguments[7]:void 0,e=arguments.length>8?arguments[8]:void 0,N=arguments.length>9?arguments[9]:void 0,F=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const I=this.beginAnimation(g,i,a,L,d,b,k,!1,e,N,F);return I.weight=n,I},B.prototype.beginAnimation=function(g,i,a,n){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,d=arguments.length>5?arguments[5]:void 0,b=arguments.length>6?arguments[6]:void 0,k=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],e=arguments.length>8?arguments[8]:void 0,N=arguments.length>9?arguments[9]:void 0,F=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(L<0){const g=i;i=a,a=g,L=-L}i>a&&(L=-L),k&&this.stopAnimation(g,void 0,e),b||(b=new I(this,g,i,a,n,L,d,void 0,N,F));const j=!e||e(g);if(g.animations&&j&&b.appendAnimations(g,g.animations),g.getAnimatables){const F=g.getAnimatables();for(let g=0;g<F.length;g++)this.beginAnimation(F[g],i,a,n,L,d,b,k,e,N)}return b.reset(),b},B.prototype.beginHierarchyAnimation=function(g,i,a,n,L){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,b=arguments.length>6?arguments[6]:void 0,k=arguments.length>7?arguments[7]:void 0,e=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],N=arguments.length>9?arguments[9]:void 0,F=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const I=g.getDescendants(i),j=[];j.push(this.beginAnimation(g,a,n,L,d,b,k,e,N,void 0,F));for(const y of I)j.push(this.beginAnimation(y,a,n,L,d,b,k,e,N,void 0,F));return j},B.prototype.beginDirectAnimation=function(g,i,a,n,L){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(d<0){const g=a;a=n,n=g,d=-d}return a>n&&(d=-d),new I(this,g,a,n,L,d,arguments.length>6?arguments[6]:void 0,i,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},B.prototype.beginDirectHierarchyAnimation=function(g,i,a,n,L,d,b,k,e){let N=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const F=g.getDescendants(i),I=[];I.push(this.beginDirectAnimation(g,a,n,L,d,b,k,e,N));for(const j of F)I.push(this.beginDirectAnimation(j,a,n,L,d,b,k,e,N));return I},B.prototype.getAnimatableByTarget=function(g){for(let i=0;i<this._activeAnimatables.length;i++)if(this._activeAnimatables[i].target===g)return this._activeAnimatables[i];return null},B.prototype.getAllAnimatablesByTarget=function(g){const i=[];for(let a=0;a<this._activeAnimatables.length;a++)this._activeAnimatables[a].target===g&&i.push(this._activeAnimatables[a]);return i},B.prototype.stopAnimation=function(g,i,a){const n=this.getAllAnimatablesByTarget(g);for(const L of n)L.stop(i,a)},B.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let g=0;g<this._activeAnimatables.length;g++)this._activeAnimatables[g].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const g of this.animationGroups)g.stop()});class p{getClassName(){return"TargetedAnimation"}serialize(){const g={};return g.animation=this.animation.serialize(),g.targetId=this.target.id,g}}class R{get mask(){return this._mask}set mask(g){this._mask!==g&&(this._mask=g,this.syncWithMask(!0))}syncWithMask(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||g){this._numActiveAnimatables=0;for(let g=0;g<this._animatables.length;++g){const i=this._animatables[g];!this.mask||this.mask.disabled||this.mask.retainsTarget(i.target.name)?(this._numActiveAnimatables++,i.paused&&i.restart()):i.paused||i.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let g=0;g<this._animatables.length;++g){const i=this._animatables[g];this.mask.retainsTarget(i.target.name)||(i.stop(),this._animatables.splice(g,1),--g)}for(let g=0;g<this._targetedAnimations.length;g++){const i=this._targetedAnimations[g];this.mask.retainsTarget(i.target.name)||(this._targetedAnimations.splice(g,1),--g)}}}get from(){return this._from}set from(g){if(this._from!==g){this._from=g;for(let g=0;g<this._animatables.length;g++){this._animatables[g].fromFrame=this._from}}}get to(){return this._to}set to(g){if(this._to!==g){this._to=g;for(let g=0;g<this._animatables.length;g++){this._animatables[g].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(g){if(this._speedRatio!==g){this._speedRatio=g;for(let g=0;g<this._animatables.length;g++){this._animatables[g].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(g){if(this._loopAnimation!==g){this._loopAnimation=g;for(let g=0;g<this._animatables.length;g++){this._animatables[g].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(g){if(this._isAdditive!==g){this._isAdditive=g;for(let g=0;g<this._animatables.length;g++){this._animatables[g].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(g){this._weight!==g&&(this._weight=g,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(g){if(this._playOrder!==g&&(this._playOrder=g,this._animatables.length>0)){for(let g=0;g<this._animatables.length;g++)this._animatables[g].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(g){if(this._enableBlending!==g&&(this._enableBlending=g,null!==g))for(let i=0;i<this._targetedAnimations.length;++i)this._targetedAnimations[i].animation.enableBlending=g}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(g){if(this._blendingSpeed!==g&&(this._blendingSpeed=g,null!==g))for(let i=0;i<this._targetedAnimations.length;++i)this._targetedAnimations[i].animation.blendingSpeed=g}getLength(g,i){g=g??this._from;return((i=i??this._to)-g)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(g){let i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3?arguments[3]:void 0;if(0===g.length)return null;n=n??g[0].weight;let L=Number.MAX_VALUE,d=-Number.MAX_VALUE;if(a)for(const k of g)k.from<L&&(L=k.from),k.to>d&&(d=k.to);const b=new R(g[0].name+"_merged",g[0]._scene,n);for(const k of g){a&&k.normalize(L,d);for(const g of k.targetedAnimations)b.addTargetedAnimation(g.animation,g.target);i&&k.dispose()}return b}constructor(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=g,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new L.b,this.onAnimationLoopObservable=new L.b,this.onAnimationGroupLoopObservable=new L.b,this.onAnimationGroupEndObservable=new L.b,this.onAnimationGroupPauseObservable=new L.b,this.onAnimationGroupPlayObservable=new L.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=i||d.c.LastCreatedScene,this._weight=a,this._playOrder=n,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(g,i){const a=new p;a.animation=g,a.target=i;const n=g.getKeys();return this._from>n[0].frame&&(this._from=n[0].frame),this._to<n[n.length-1].frame&&(this._to=n[n.length-1].frame),null!==this._enableBlending&&(g.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(g.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(a),this._shouldStart=!0,a}removeTargetedAnimation(g){for(let i=this._targetedAnimations.length-1;i>-1;i--){this._targetedAnimations[i].animation===g&&this._targetedAnimations.splice(i,1)}}normalize(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==g&&(g=this._from),null==i&&(i=this._to);for(let a=0;a<this._targetedAnimations.length;a++){const n=this._targetedAnimations[a].animation.getKeys(),L=n[0],d=n[n.length-1];if(L.frame>g){const i={frame:g,value:L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation};n.splice(0,0,i)}if(d.frame<i){const g={frame:i,value:d.value,inTangent:d.inTangent,outTangent:d.outTangent,interpolation:d.interpolation};n.push(g)}}return this._from=g,this._to=i,this}_processLoop(g,i,a){g.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(i),this._animationLoopFlags[a]||(this._animationLoopFlags[a]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2?arguments[2]:void 0,n=arguments.length>3?arguments[3]:void 0,L=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=g,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let d=0;d<this._targetedAnimations.length;d++){const b=this._targetedAnimations[d],k=this._scene.beginDirectAnimation(b.target,[b.animation],void 0!==a?a:this._from,void 0!==n?n:this._to,g,i,void 0,void 0,void 0!==L?L:this._isAdditive);k.weight=this._weight,k.playOrder=this._playOrder,k.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(b),this._checkAnimationGroupEnded(k)},this._processLoop(k,b,d),this._animatables.push(k)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=i,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let g=0;g<this._animatables.length;g++){this._animatables[g].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(g){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==g&&(this.loopAnimation=g),this.restart()):(this.stop(),this.start(g,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let g=0;g<this._animatables.length;g++){this._animatables[g].reset()}return this}restart(){if(!this._isStarted)return this;for(let g=0;g<this._animatables.length;g++){this._animatables[g].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const i=this._animatables.slice();for(let n=0;n<i.length;n++)i[n].stop(void 0,void 0,!0,g);let a=0;for(let n=0;n<this._scene._activeAnimatables.length;n++){const i=this._scene._activeAnimatables[n];i._runtimeAnimations.length>0?this._scene._activeAnimatables[a++]=i:g&&this._checkAnimationGroupEnded(i,g)}return this._scene._activeAnimatables.length=a,this._isStarted=!1,this}setWeightForAllAnimatables(g){for(let i=0;i<this._animatables.length;i++){this._animatables[i].weight=g}return this}syncAllAnimationsWith(g){for(let i=0;i<this._animatables.length;i++){this._animatables[i].syncWith(g)}return this}goToFrame(g){let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let a=0;a<this._animatables.length;a++){this._animatables[a].goToFrame(g,i)}return this}getCurrentFrame(){var g;return(null===(g=this.animatables[0])||void 0===g?void 0:g.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const g=this._scene.animationGroups.indexOf(this);if(g>-1&&this._scene.animationGroups.splice(g,1),this._parentContainer){const g=this._parentContainer.animationGroups.indexOf(this);g>-1&&this._parentContainer.animationGroups.splice(g,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(g){let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const a=this._animatables.indexOf(g);a>-1&&this._animatables.splice(a,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,i||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(g,i){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=new R(g||this.name,this._scene,this._weight,this._playOrder);n._from=this.from,n._to=this.to,n._speedRatio=this.speedRatio,n._loopAnimation=this.loopAnimation,n._isAdditive=this.isAdditive,n._enableBlending=this.enableBlending,n._blendingSpeed=this.blendingSpeed,n.metadata=this.metadata,n.mask=this.mask;for(const L of this._targetedAnimations)n.addTargetedAnimation(a?L.animation.clone():L.animation,i?i(L.target):L.target);return n}serialize(){const g={};g.name=this.name,g.from=this.from,g.to=this.to,g.speedRatio=this.speedRatio,g.loopAnimation=this.loopAnimation,g.isAdditive=this.isAdditive,g.weight=this.weight,g.playOrder=this.playOrder,g.enableBlending=this.enableBlending,g.blendingSpeed=this.blendingSpeed,g.targetedAnimations=[];for(let i=0;i<this.targetedAnimations.length;i++){const a=this.targetedAnimations[i];g.targetedAnimations[i]=a.serialize()}return b.c&&b.c.HasTags(this)&&(g.tags=b.c.GetTags(this)),this.metadata&&(g.metadata=this.metadata),g}static Parse(g,i){const a=new R(g.name,i,g.weight,g.playOrder);for(let L=0;L<g.targetedAnimations.length;L++){const d=g.targetedAnimations[L],b=n.b.Parse(d.animation),k=d.targetId;if("influence"===d.animation.property){const g=i.getMorphTargetById(k);g&&a.addTargetedAnimation(b,g)}else{const g=i.getNodeById(k);null!=g&&a.addTargetedAnimation(b,g)}}return b.c&&b.c.AddTagsTo(a,g.tags),null!==g.from&&null!==g.to&&a.normalize(g.from,g.to),void 0!==g.speedRatio&&(a._speedRatio=g.speedRatio),void 0!==g.loopAnimation&&(a._loopAnimation=g.loopAnimation),void 0!==g.isAdditive&&(a._isAdditive=g.isAdditive),void 0!==g.weight&&(a._weight=g.weight),void 0!==g.playOrder&&(a._playOrder=g.playOrder),void 0!==g.enableBlending&&(a._enableBlending=g.enableBlending),void 0!==g.blendingSpeed&&(a._blendingSpeed=g.blendingSpeed),void 0!==g.metadata&&(a.metadata=g.metadata),a}static MakeAnimationAdditive(g,i,a){let L;L="object"===typeof i?i:{referenceFrame:i,range:a,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let d=g;L.cloneOriginalAnimationGroup&&(d=g.clone(L.clonedAnimationGroupName||d.name));const b=d.targetedAnimations;for(let k=0;k<b.length;k++){const g=b[k];g.animation=n.b.MakeAnimationAdditive(g.animation,L)}if(d.isAdditive=!0,L.clipKeys){let g=Number.MAX_VALUE,i=-Number.MAX_VALUE;const a=d.targetedAnimations;for(let n=0;n<a.length;n++){const L=a[n].animation.getKeys();g>L[0].frame&&(g=L[0].frame),i<L[L.length-1].frame&&(i=L[L.length-1].frame)}d._from=g,d._to=i}return d}static ClipKeys(g,i,a,n,L){const d=g.clone(n||g.name);return R.ClipKeysInPlace(d,i,a,L)}static ClipKeysInPlace(g,i,a,n){return R.ClipInPlace(g,i,a,n,!1)}static ClipFrames(g,i,a,n,L){const d=g.clone(n||g.name);return R.ClipFramesInPlace(d,i,a,L)}static ClipFramesInPlace(g,i,a,n){return R.ClipInPlace(g,i,a,n,!0)}static ClipInPlace(g,i,a,n){let L=arguments.length>4&&void 0!==arguments[4]&&arguments[4],d=Number.MAX_VALUE,b=-Number.MAX_VALUE;const k=g.targetedAnimations;for(let e=0;e<k.length;e++){const g=k[e],N=n?g.animation:g.animation.clone();L&&(N.createKeyForFrame(i),N.createKeyForFrame(a));const F=N.getKeys(),I=[];let j=Number.MAX_VALUE;for(let n=0;n<F.length;n++){const g=F[n];if(!L&&n>=i&&n<=a||L&&g.frame>=i&&g.frame<=a){const i={frame:g.frame,value:g.value.clone?g.value.clone():g.value,inTangent:g.inTangent,outTangent:g.outTangent,interpolation:g.interpolation,lockedTangent:g.lockedTangent};j===Number.MAX_VALUE&&(j=i.frame),i.frame-=j,I.push(i)}}0!==I.length?(d>I[0].frame&&(d=I[0].frame),b<I[I.length-1].frame&&(b=I[I.length-1].frame),N.setKeys(I,!0),g.animation=N):(k.splice(e,1),e--)}return g._from=d,g._to=b,g}getClassName(){return"AnimationGroup"}toString(g){let i="Name: "+this.name;return i+=", type: "+this.getClassName(),g&&(i+=", from: "+this._from,i+=", to: "+this._to,i+=", isStarted: "+this._isStarted,i+=", speedRatio: "+this._speedRatio,i+=", targetedAnimations length: "+this._targetedAnimations.length,i+=", animatables length: "+this._animatables),i}}}}]);