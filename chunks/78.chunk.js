"use strict";(self["7c63p8lin4r"]=self["7c63p8lin4r"]||[]).push([[78],{15654:(z,u,U)=>{U.r(u),U.d(u,{AnimationGroup:()=>M,TargetedAnimation:()=>r});var J=U(13406),v=U(12756),f=U(12797),g=U(12960),w=U(14123),P=U(12914);class R{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(z,u,U,v){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=u,this._target=z,this._scene=U,this._host=v,this._activeTargets=[],u._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===J.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=P.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const z={frame:0,value:this._minValue};this._keys.splice(0,0,z)}if(this._target instanceof Array){let z=0;for(const u of this._target)this._preparePath(u,z),this._getOriginalValues(z),z++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const f=u.getEvents();if(f&&f.length>0)for(const J of f)this._events.push(J._clone());this._enableBlending=z&&z.animationPropertiesOverride?z.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const U=this._animation.targetPropertyPath;if(U.length>1){let J=z;for(let z=0;z<U.length-1;z++){const u=U[z];if(J=J[u],void 0===J)throw new Error("Invalid property (".concat(u,") in property path (").concat(U.join("."),")"))}this._targetPath=U[U.length-1],this._activeTargets[u]=J}else this._targetPath=U[0],this._activeTargets[u]=z;if(void 0===this._activeTargets[u][this._targetPath])throw new Error("Invalid property (".concat(this._targetPath,") in property path (").concat(U.join("."),")"))}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let z=0;for(const u of this._target)void 0!==this._originalValue[z]&&this._setValue(u,this._activeTargets[z],this._originalValue[z],-1,z),z++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let z=0;z<this._events.length;z++)this._events[z].isDone=!1}isStopped(){return this._stopped}dispose(){const z=this._animation.runtimeAnimations.indexOf(this);z>-1&&this._animation.runtimeAnimations.splice(z,1)}setValue(z,u){if(this._targetIsArray)for(let U=0;U<this._target.length;U++){const J=this._target[U];this._setValue(J,this._activeTargets[U],z,u,U)}else this._setValue(this._target,this._directTarget,z,u,0)}_getOriginalValues(){let z,u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const U=this._activeTargets[u];z=U.getLocalMatrix&&"_matrix"===this._targetPath?U.getLocalMatrix():U[this._targetPath],z&&z.clone?this._originalValue[u]=z.clone():this._originalValue[u]=z}_registerTargetForLateAnimationBinding(z,u){const U=z.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(U),U._lateAnimationHolders||(U._lateAnimationHolders={}),U._lateAnimationHolders[z.targetPath]||(U._lateAnimationHolders[z.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:u}),z.isAdditive?(U._lateAnimationHolders[z.targetPath].additiveAnimations.push(z),U._lateAnimationHolders[z.targetPath].totalAdditiveWeight+=z.weight):(U._lateAnimationHolders[z.targetPath].animations.push(z),U._lateAnimationHolders[z.targetPath].totalWeight+=z.weight)}_setValue(z,u,U,v,f){if(this._currentActiveTarget=u,this._weight=v,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const z=u[this._targetPath];z.clone?this._originalBlendValue=z.clone():this._originalBlendValue=z}this._originalBlendValue.m?J.b.AllowMatrixDecomposeForInterpolation?this._currentValue?P.Matrix.DecomposeLerpToRef(this._originalBlendValue,U,this._blendingFactor,this._currentValue):this._currentValue=P.Matrix.DecomposeLerp(this._originalBlendValue,U,this._blendingFactor):this._currentValue?P.Matrix.LerpToRef(this._originalBlendValue,U,this._blendingFactor,this._currentValue):this._currentValue=P.Matrix.Lerp(this._originalBlendValue,U,this._blendingFactor):this._currentValue=J.b._UniversalLerp(this._originalBlendValue,U,this._blendingFactor);const v=z&&z.animationPropertiesOverride?z.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=v}else this._currentValue?this._currentValue.v?this._currentValue.v(U):this._currentValue=U:null!==U&&void 0!==U&&U.clone?this._currentValue=U.clone():this._currentValue=U;-1!==v?this._registerTargetForLateAnimationBinding(this,this._originalValue[f]):this._animationState.loopMode===J.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[f],u[this._targetPath]):u[this._targetPath]=this._originalValue[f]+this._currentValue:u[this._targetPath]=this._currentValue,z.LS&&z.LS(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const U=this._animation.getKeys();z<U[0].frame?z=U[0].frame:z>U[U.length-1].frame&&(z=U[U.length-1].frame);const J=this._events;if(J.length)for(let f=0;f<J.length;f++)J[f].onlyOnce||(J[f].isDone=J[f].frame<z);this._currentFrame=z;const v=this._animation._interpolate(z,this._animationState);this.setValue(v,u)}_prepareForSpeedRatioChange(z){const u=this._previousElapsedTime*(this._animation.framePerSecond*z)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-u}animate(z,u,U,v,f){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const w=this._animation,P=w.targetPropertyPath;if(!P||P.length<1)return this._stopped=!0,!1;let R,S=!0;const d=this._events;let mz=0;if(this._coreRuntimeAnimation)mz=U-u,R=this._coreRuntimeAnimation.currentFrame,this._currentFrame=R,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let g;(u<this._minFrame||u>this._maxFrame)&&(u=this._minFrame),(U<this._minFrame||U>this._maxFrame)&&(U=this._maxFrame),mz=U-u;let P=z*(w.framePerSecond*f)/1e3+this._absoluteFrameOffset,Z=0,A=!1;const E=v&&this._animationState.loopMode===J.b.ANIMATIONLOOPMODE_YOYO;if(E){const z=(P-u)/mz,U=Math.sin(z*Math.PI);P=Math.abs(U)*mz+u;const J=U>=0?1:-1;this._yoyoDirection!==J&&(A=!0),this._yoyoDirection=J}if(this._previousElapsedTime=z,this._previousAbsoluteFrame=P,!v&&U>=u&&(P>=mz&&f>0||P<=0&&f<0))S=!1,Z=w._getKeyValue(this._maxValue);else if(!v&&u>=U&&(P<=mz&&f<0||P>=0&&f>0))S=!1,Z=w._getKeyValue(this._minValue);else if(this._animationState.loopMode!==J.b.ANIMATIONLOOPMODE_CYCLE){const z=U.toString()+u.toString();if(!this._offsetsCache[z]){this._animationState.repeatCount=0,this._animationState.loopMode=J.b.ANIMATIONLOOPMODE_CYCLE;const v=w._interpolate(u,this._animationState),f=w._interpolate(U,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),w.dataType){case J.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[z]=f-v;break;case J.b.ANIMATIONTYPE_QUATERNION:case J.b.ANIMATIONTYPE_VECTOR3:case J.b.ANIMATIONTYPE_VECTOR2:case J.b.ANIMATIONTYPE_SIZE:case J.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[z]=f.Cu(v)}this._highLimitsCache[z]=f}Z=this._highLimitsCache[z],g=this._offsetsCache[z]}if(void 0===g)switch(w.dataType){case J.b.ANIMATIONTYPE_FLOAT:g=0;break;case J.b.ANIMATIONTYPE_QUATERNION:g=J.k;break;case J.b.ANIMATIONTYPE_VECTOR3:g=J.q;break;case J.b.ANIMATIONTYPE_VECTOR2:g=J.o;break;case J.b.ANIMATIONTYPE_SIZE:g=J.n;break;case J.b.ANIMATIONTYPE_COLOR3:g=J.f;break;case J.b.ANIMATIONTYPE_COLOR4:g=J.i}if(this._host&&this._host.syncRoot){const z=this._host.syncRoot;R=u+mz*((z.masterFrame-z.fromFrame)/(z.toFrame-z.fromFrame))}else R=P>0&&u>U||P<0&&u<U?S&&0!==mz?U+P%mz:u:S&&0!==mz?u+P%mz:U;if(!E&&(f>0&&this.currentFrame>R||f<0&&this.currentFrame<R)||E&&A){this._onLoop();for(let z=0;z<d.length;z++)d[z].onlyOnce||(d[z].isDone=!1);this._animationState.key=f>0?0:w.getKeys().length-1}this._currentFrame=R,this._animationState.repeatCount=0===mz?0:P/mz|0,this._animationState.highLimitValue=Z,this._animationState.offsetValue=g}const Z=w._interpolate(R,this._animationState);if(this.setValue(Z,g),d.length)for(let J=0;J<d.length;J++)if(mz>=0&&R>=d[J].frame&&d[J].frame>=u||mz<0&&R<=d[J].frame&&d[J].frame<=u){const z=d[J];z.isDone||(z.onlyOnce&&(d.splice(J,1),J--),z.isDone=!0,z.action(R))}return S||(this._stopped=!0),S}}var S=U(12777);class d{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(z){this._weight=-1!==z?Math.min(Math.max(z,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(z){for(let u=0;u<this._runtimeAnimations.length;u++){this._runtimeAnimations[u]._prepareForSpeedRatioChange(z)}this._speedRatio=z,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(z,u){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,f=arguments.length>4&&void 0!==arguments[4]&&arguments[4],g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,w=arguments.length>6?arguments[6]:void 0,P=arguments.length>7?arguments[7]:void 0,R=arguments.length>8?arguments[8]:void 0,S=arguments.length>9&&void 0!==arguments[9]&&arguments[9],d=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=u,this.fromFrame=U,this.toFrame=J,this.loopAnimation=f,this.onAnimationEnd=w,this.onAnimationLoop=R,this.isAdditive=S,this.playOrder=d,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.mR=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new v.e,this.onAnimationLoopObservable=new v.e,this._scene=z,P&&this.appendAnimations(u,P),this._speedRatio=g,z._activeAnimatables.push(this)}syncWith(z){if(this._syncRoot=z,z){const z=this._scene._activeAnimatables.indexOf(this);z>-1&&(this._scene._activeAnimatables.splice(z,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(z,u){for(let U=0;U<u.length;U++){const J=u[U],v=new R(z,J,this._scene,this);v._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(v)}}getAnimationByTargetProperty(z){const u=this._runtimeAnimations;for(let U=0;U<u.length;U++)if(u[U].animation.targetProperty===z)return u[U].animation;return null}getRuntimeAnimationByTargetProperty(z){const u=this._runtimeAnimations;for(let U=0;U<u.length;U++)if(u[U].animation.targetProperty===z)return u[U];return null}reset(){const z=this._runtimeAnimations;for(let u=0;u<z.length;u++)z[u].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(z){const u=this._runtimeAnimations;for(let U=0;U<u.length;U++)u[U].animation.enableBlending=!0,u[U].animation.blendingSpeed=z}disableBlending(){const z=this._runtimeAnimations;for(let u=0;u<z.length;u++)z[u].animation.enableBlending=!1}goToFrame(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const U=this._runtimeAnimations;if(U[0]){var J;const u=U[0].animation.framePerSecond;this._frameToSyncFromJump=null!==(J=this._frameToSyncFromJump)&&void 0!==J?J:U[0].currentFrame;const v=0===this.speedRatio?0:(z-this._frameToSyncFromJump)/u*1e3/this.speedRatio;this._manualJumpDelay=-v}for(let v=0;v<U.length;v++)U[v].goToFrame(z,u?this._weight:-1);this._goToFrame=z}get paused(){return this.mR}pause(){this.mR||(this.mR=!0)}restart(){this.mR=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(z,u){let U=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(z||u){const v=this._scene._activeAnimatables.indexOf(this);if(v>-1){const f=this._runtimeAnimations;for(let U=f.length-1;U>=0;U--){const J=f[U];z&&J.animation.name!=z||(u&&!u(J.target)||(J.dispose(),f.splice(U,1)))}0==f.length&&(U||this._scene._activeAnimatables.splice(v,1),J||this._raiseOnAnimationEnd())}}else{const z=this._scene._activeAnimatables.indexOf(this);if(z>-1){U||this._scene._activeAnimatables.splice(z,1);const u=this._runtimeAnimations;for(let z=0;z<u.length;z++)u[z].dispose();this._runtimeAnimations.length=0,J||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((z=>{this.onAnimationEndObservable.add((()=>{z(this)}),void 0,void 0,this,!0)}))}_animate(z){if(this.mR)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=z),!0;if(null===this._localDelayOffset?(this._localDelayOffset=z,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=z-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let u=!1;const U=this._runtimeAnimations;let J;for(J=0;J<U.length;J++){const v=U[J].animate(z-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);u=u||v}if(this.animationStarted=u,!u){if(this.disposeOnEnd)for(J=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(J,1),J=0;J<U.length;J++)U[J].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return u}}function mz(z){if(0===z.totalWeight&&0===z.totalAdditiveWeight)return z.originalValue;let u=1;const U=P.TmpVectors.Eu[0],J=P.TmpVectors.Eu[1],v=P.TmpVectors.Quaternion[0];let f=0;const g=z.animations[0],w=z.originalValue;let R=1,S=!1;if(z.totalWeight<1)R=1-z.totalWeight,w.decompose(J,v,U);else{if(f=1,u=z.totalWeight,R=g.weight/u,1==R){if(!z.totalAdditiveWeight)return g.currentValue;S=!0}g.currentValue.decompose(J,v,U)}if(!S){J.scaleInPlace(R),U.scaleInPlace(R),v.scaleInPlace(R);for(let g=f;g<z.animations.length;g++){const f=z.animations[g];if(0===f.weight)continue;R=f.weight/u;const w=P.TmpVectors.Eu[2],S=P.TmpVectors.Eu[3],d=P.TmpVectors.Quaternion[1];f.currentValue.decompose(S,d,w),S.scaleAndAddToRef(R,J),d.scaleAndAddToRef(P.Quaternion.Dot(v,d)>0?R:-R,v),w.scaleAndAddToRef(R,U)}v.normalize()}for(let mz=0;mz<z.additiveAnimations.length;mz++){const u=z.additiveAnimations[mz];if(0===u.weight)continue;const f=P.TmpVectors.Eu[2],g=P.TmpVectors.Eu[3],w=P.TmpVectors.Quaternion[1];u.currentValue.decompose(g,w,f),g.multiplyToRef(J,g),P.Eu.LerpToRef(J,g,u.weight,J),v.multiplyToRef(w,w),P.Quaternion.SlerpToRef(v,w,u.weight,v),f.scaleAndAddToRef(u.weight,U)}const d=g?g._animationState.workValue:P.TmpVectors.Matrix[0].clone();return P.Matrix.ComposeToRef(J,v,U,d),d}function Z(z,u){if(0===z.totalWeight&&0===z.totalAdditiveWeight)return u;const U=z.animations[0],J=z.originalValue;let v=u;if(0===z.totalWeight&&z.totalAdditiveWeight>0)v.v(J);else if(1===z.animations.length){if(P.Quaternion.SlerpToRef(J,U.currentValue,Math.min(1,z.totalWeight),v),0===z.totalAdditiveWeight)return v}else if(z.animations.length>1){let U,f,g=1;if(z.totalWeight<1){const u=1-z.totalWeight;U=[],f=[],U.push(J),f.push(u)}else{if(2===z.animations.length&&(P.Quaternion.SlerpToRef(z.animations[0].currentValue,z.animations[1].currentValue,z.animations[1].weight/z.totalWeight,u),0===z.totalAdditiveWeight))return u;U=[],f=[],g=z.totalWeight}for(let u=0;u<z.animations.length;u++){const J=z.animations[u];U.push(J.currentValue),f.push(J.weight/g)}let w=0;for(let z=0;z<U.length;)z?(w+=f[z],P.Quaternion.SlerpToRef(v,U[z],f[z]/w,v),z++):(P.Quaternion.SlerpToRef(U[z],U[z+1],f[z+1]/(f[z]+f[z+1]),u),v=u,w=f[z]+f[z+1],z+=2)}for(let f=0;f<z.additiveAnimations.length;f++){const u=z.additiveAnimations[f];0!==u.weight&&(v.multiplyToRef(u.currentValue,P.TmpVectors.Quaternion[0]),P.Quaternion.SlerpToRef(v,P.TmpVectors.Quaternion[0],u.weight,v))}return v}var A,E,C=U(13161);A=C.d,(E=w.b)&&(E.prototype.copyAnimationRange=function(z,u,U){let v=arguments.length>3&&void 0!==arguments[3]&&arguments[3],f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new J.b(this.name,"_matrix",z.animations[0].framePerSecond,J.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const g=z.animations[0].getRange(u);if(!g)return!1;const w=g.from,P=g.to,R=z.animations[0].getKeys(),S=z.length,d=z.getParent(),mz=this.getParent(),Z=v&&d&&S&&this.length&&S!==this.length,A=Z&&mz&&d?mz.length/d.length:1,E=v&&!mz&&f&&(1!==f.x||1!==f.y||1!==f.z),C=this.animations[0].getKeys();let r,M,T;for(let J=0,X=R.length;J<X;J++)r=R[J],r.frame>=w&&r.frame<=P&&(v?(T=r.value.clone(),Z?(M=T.getTranslation(),T.setTranslation(M.scaleInPlace(A))):E&&f?(M=T.getTranslation(),T.setTranslation(M.multiplyInPlace(f))):T=r.value):T=r.value,C.push({frame:r.frame+U,value:T}));return this.animations[0].createRange(u,w+U,P+U),!0}),A&&(A.prototype._animate=function(z){if(!this.animationsEnabled)return;const u=S.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=u}this.deltaTime=void 0!==z?z:this.useConstantAnimationDeltaTime?16:(u-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=u;const U=this._activeAnimatables;if(0===U.length)return;this._animationTime+=this.deltaTime;const v=this._animationTime;for(let J=0;J<U.length;J++){const z=U[J];!z._animate(v)&&z.disposeOnEnd&&J--}!function(z){if(z._registeredForLateAnimationBindings.length){for(let u=0;u<z._registeredForLateAnimationBindings.length;u++){const U=z._registeredForLateAnimationBindings.data[u];for(const z in U._lateAnimationHolders){const u=U._lateAnimationHolders[z],v=u.animations[0],f=u.originalValue;if(void 0===f||null===f)continue;const g=J.b.AllowMatrixDecomposeForInterpolation&&f.m;let w=U[z];if(g)w=mz(u);else if(void 0!==f.w)w=Z(u,w||P.Quaternion.Identity());else{let z=0,U=1;const g=v&&v._animationState.loopMode===J.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(u.totalWeight<1)w=g?f.clone?f.clone():f:v&&f.scale?f.scale(1-u.totalWeight):v?f*(1-u.totalWeight):f.clone?f.clone():f;else if(v){U=u.totalWeight;const J=v.weight/U;w=1!==J?v.currentValue.scale?v.currentValue.scale(J):v.currentValue*J:v.currentValue,g&&(w.addToRef?w.addToRef(f,w):w+=f),z=1}for(let J=z;J<u.animations.length;J++){const z=u.animations[J],v=z.weight/U;v&&(z.currentValue.scaleAndAddToRef?z.currentValue.scaleAndAddToRef(v,w):w+=z.currentValue*v)}for(let J=0;J<u.additiveAnimations.length;J++){const z=u.additiveAnimations[J],U=z.weight;U&&(z.currentValue.scaleAndAddToRef?z.currentValue.scaleAndAddToRef(U,w):w+=z.currentValue*U)}}U[z]=w}U._lateAnimationHolders={}}z._registeredForLateAnimationBindings.reset()}}(this)},A.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((z,u)=>z.playOrder-u.playOrder))},A.prototype.beginWeightedAnimation=function(z,u,U){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4?arguments[4]:void 0,f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,P=arguments.length>8?arguments[8]:void 0,R=arguments.length>9?arguments[9]:void 0,S=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const d=this.beginAnimation(z,u,U,v,f,g,w,!1,P,R,S);return d.weight=J,d},A.prototype.beginAnimation=function(z,u,U,J){let v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,f=arguments.length>5?arguments[5]:void 0,g=arguments.length>6?arguments[6]:void 0,w=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],P=arguments.length>8?arguments[8]:void 0,R=arguments.length>9?arguments[9]:void 0,S=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(v<0){const z=u;u=U,U=z,v=-v}u>U&&(v=-v),w&&this.stopAnimation(z,void 0,P),g||(g=new d(this,z,u,U,J,v,f,void 0,R,S));const mz=!P||P(z);if(z.animations&&mz&&g.appendAnimations(z,z.animations),z.getAnimatables){const S=z.getAnimatables();for(let z=0;z<S.length;z++)this.beginAnimation(S[z],u,U,J,v,f,g,w,P,R)}return g.reset(),g},A.prototype.beginHierarchyAnimation=function(z,u,U,J,v){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,P=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],R=arguments.length>9?arguments[9]:void 0,S=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const d=z.getDescendants(u),mz=[];mz.push(this.beginAnimation(z,U,J,v,f,g,w,P,R,void 0,S));for(const Z of d)mz.push(this.beginAnimation(Z,U,J,v,f,g,w,P,R,void 0,S));return mz},A.prototype.beginDirectAnimation=function(z,u,U,J,v){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(f<0){const z=U;U=J,J=z,f=-f}return U>J&&(f=-f),new d(this,z,U,J,v,f,arguments.length>6?arguments[6]:void 0,u,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},A.prototype.beginDirectHierarchyAnimation=function(z,u,U,J,v,f,g,w,P){let R=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const S=z.getDescendants(u),d=[];d.push(this.beginDirectAnimation(z,U,J,v,f,g,w,P,R));for(const mz of S)d.push(this.beginDirectAnimation(mz,U,J,v,f,g,w,P,R));return d},A.prototype.getAnimatableByTarget=function(z){for(let u=0;u<this._activeAnimatables.length;u++)if(this._activeAnimatables[u].target===z)return this._activeAnimatables[u];return null},A.prototype.getAllAnimatablesByTarget=function(z){const u=[];for(let U=0;U<this._activeAnimatables.length;U++)this._activeAnimatables[U].target===z&&u.push(this._activeAnimatables[U]);return u},A.prototype.stopAnimation=function(z,u,U){const J=this.getAllAnimatablesByTarget(z);for(const v of J)v.stop(u,U)},A.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let z=0;z<this._activeAnimatables.length;z++)this._activeAnimatables[z].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const z of this.animationGroups)z.stop()});class r{getClassName(){return"TargetedAnimation"}serialize(){const z={};return z.animation=this.animation.serialize(),z.targetId=this.target.id,z}}class M{get mask(){return this._mask}set mask(z){this._mask!==z&&(this._mask=z,this.syncWithMask(!0))}syncWithMask(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||z){this._numActiveAnimatables=0;for(let z=0;z<this._animatables.length;++z){const u=this._animatables[z];!this.mask||this.mask.disabled||this.mask.retainsTarget(u.target.name)?(this._numActiveAnimatables++,u.paused&&u.restart()):u.paused||u.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let z=0;z<this._animatables.length;++z){const u=this._animatables[z];this.mask.retainsTarget(u.target.name)||(u.stop(),this._animatables.splice(z,1),--z)}for(let z=0;z<this._targetedAnimations.length;z++){const u=this._targetedAnimations[z];this.mask.retainsTarget(u.target.name)||(this._targetedAnimations.splice(z,1),--z)}}}get from(){return this._from}set from(z){if(this._from!==z){this._from=z;for(let z=0;z<this._animatables.length;z++){this._animatables[z].fromFrame=this._from}}}get to(){return this._to}set to(z){if(this._to!==z){this._to=z;for(let z=0;z<this._animatables.length;z++){this._animatables[z].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(z){if(this._speedRatio!==z){this._speedRatio=z;for(let z=0;z<this._animatables.length;z++){this._animatables[z].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(z){if(this._loopAnimation!==z){this._loopAnimation=z;for(let z=0;z<this._animatables.length;z++){this._animatables[z].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(z){if(this._isAdditive!==z){this._isAdditive=z;for(let z=0;z<this._animatables.length;z++){this._animatables[z].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(z){this._weight!==z&&(this._weight=z,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(z){if(this._playOrder!==z&&(this._playOrder=z,this._animatables.length>0)){for(let z=0;z<this._animatables.length;z++)this._animatables[z].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(z){if(this._enableBlending!==z&&(this._enableBlending=z,null!==z))for(let u=0;u<this._targetedAnimations.length;++u)this._targetedAnimations[u].animation.enableBlending=z}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(z){if(this._blendingSpeed!==z&&(this._blendingSpeed=z,null!==z))for(let u=0;u<this._targetedAnimations.length;++u)this._targetedAnimations[u].animation.blendingSpeed=z}getLength(z,u){var U,J;z=null!==(U=z)&&void 0!==U?U:this._from;return((u=null!==(J=u)&&void 0!==J?J:this._to)-z)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(z){var u;let U=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],J=arguments.length>2&&void 0!==arguments[2]&&arguments[2],v=arguments.length>3?arguments[3]:void 0;if(0===z.length)return null;v=null!==(u=v)&&void 0!==u?u:z[0].weight;let f=Number.MAX_VALUE,g=-Number.MAX_VALUE;if(J)for(const P of z)P.from<f&&(f=P.from),P.to>g&&(g=P.to);const w=new M(z[0].name+"_merged",z[0]._scene,v);for(const P of z){J&&P.normalize(f,g);for(const z of P.targetedAnimations)w.addTargetedAnimation(z.animation,z.target);U&&P.dispose()}return w}constructor(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=z,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new v.e,this.onAnimationLoopObservable=new v.e,this.onAnimationGroupLoopObservable=new v.e,this.onAnimationGroupEndObservable=new v.e,this.onAnimationGroupPauseObservable=new v.e,this.onAnimationGroupPlayObservable=new v.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=u||f.e.LastCreatedScene,this._weight=U,this._playOrder=J,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(z,u){const U=new r;U.animation=z,U.target=u;const J=z.getKeys();return this._from>J[0].frame&&(this._from=J[0].frame),this._to<J[J.length-1].frame&&(this._to=J[J.length-1].frame),null!==this._enableBlending&&(z.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(z.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(U),this._shouldStart=!0,U}removeTargetedAnimation(z){for(let u=this._targetedAnimations.length-1;u>-1;u--){this._targetedAnimations[u].animation===z&&this._targetedAnimations.splice(u,1)}}normalize(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==z&&(z=this._from),null==u&&(u=this._to);for(let U=0;U<this._targetedAnimations.length;U++){const J=this._targetedAnimations[U].animation.getKeys(),v=J[0],f=J[J.length-1];if(v.frame>z){const u={frame:z,value:v.value,inTangent:v.inTangent,outTangent:v.outTangent,interpolation:v.interpolation};J.splice(0,0,u)}if(f.frame<u){const z={frame:u,value:f.value,inTangent:f.inTangent,outTangent:f.outTangent,interpolation:f.interpolation};J.push(z)}}return this._from=z,this._to=u,this}_processLoop(z,u,U){z.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(u),this._animationLoopFlags[U]||(this._animationLoopFlags[U]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0],u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,U=arguments.length>2?arguments[2]:void 0,J=arguments.length>3?arguments[3]:void 0,v=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=z,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let f=0;f<this._targetedAnimations.length;f++){const g=this._targetedAnimations[f],w=this._scene.beginDirectAnimation(g.target,[g.animation],void 0!==U?U:this._from,void 0!==J?J:this._to,z,u,void 0,void 0,void 0!==v?v:this._isAdditive);w.weight=this._weight,w.playOrder=this._playOrder,w.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(g),this._checkAnimationGroupEnded(w)},this._processLoop(w,g,f),this._animatables.push(w)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=u,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let z=0;z<this._animatables.length;z++){this._animatables[z].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(z){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==z&&(this.loopAnimation=z),this.restart()):(this.stop(),this.start(z,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let z=0;z<this._animatables.length;z++){this._animatables[z].reset()}return this}restart(){if(!this._isStarted)return this;for(let z=0;z<this._animatables.length;z++){this._animatables[z].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const u=this._animatables.slice();for(let J=0;J<u.length;J++)u[J].stop(void 0,void 0,!0,z);let U=0;for(let J=0;J<this._scene._activeAnimatables.length;J++){const u=this._scene._activeAnimatables[J];u._runtimeAnimations.length>0?this._scene._activeAnimatables[U++]=u:z&&this._checkAnimationGroupEnded(u,z)}return this._scene._activeAnimatables.length=U,this._isStarted=!1,this}setWeightForAllAnimatables(z){for(let u=0;u<this._animatables.length;u++){this._animatables[u].weight=z}return this}syncAllAnimationsWith(z){for(let u=0;u<this._animatables.length;u++){this._animatables[u].syncWith(z)}return this}goToFrame(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let U=0;U<this._animatables.length;U++){this._animatables[U].goToFrame(z,u)}return this}getCurrentFrame(){var z;return(null===(z=this.animatables[0])||void 0===z?void 0:z.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const z=this._scene.animationGroups.indexOf(this);if(z>-1&&this._scene.animationGroups.splice(z,1),this._parentContainer){const z=this._parentContainer.animationGroups.indexOf(this);z>-1&&this._parentContainer.animationGroups.splice(z,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const U=this._animatables.indexOf(z);U>-1&&this._animatables.splice(U,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,u||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(z,u){let U=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const J=new M(z||this.name,this._scene,this._weight,this._playOrder);J._from=this.from,J._to=this.to,J._speedRatio=this.speedRatio,J._loopAnimation=this.loopAnimation,J._isAdditive=this.isAdditive,J._enableBlending=this.enableBlending,J._blendingSpeed=this.blendingSpeed,J.metadata=this.metadata,J.mask=this.mask;for(const v of this._targetedAnimations)J.addTargetedAnimation(U?v.animation.clone():v.animation,u?u(v.target):v.target);return J}serialize(){const z={};z.name=this.name,z.from=this.from,z.to=this.to,z.speedRatio=this.speedRatio,z.loopAnimation=this.loopAnimation,z.isAdditive=this.isAdditive,z.weight=this.weight,z.playOrder=this.playOrder,z.enableBlending=this.enableBlending,z.blendingSpeed=this.blendingSpeed,z.targetedAnimations=[];for(let u=0;u<this.targetedAnimations.length;u++){const U=this.targetedAnimations[u];z.targetedAnimations[u]=U.serialize()}return g.b&&g.b.HasTags(this)&&(z.tags=g.b.GetTags(this)),this.metadata&&(z.metadata=this.metadata),z}static Parse(z,u){const U=new M(z.name,u,z.weight,z.playOrder);for(let v=0;v<z.targetedAnimations.length;v++){const f=z.targetedAnimations[v],g=J.b.Parse(f.animation),w=f.targetId;if("influence"===f.animation.property){const z=u.getMorphTargetById(w);z&&U.addTargetedAnimation(g,z)}else{const z=u.getNodeById(w);null!=z&&U.addTargetedAnimation(g,z)}}return g.b&&g.b.AddTagsTo(U,z.tags),null!==z.from&&null!==z.to&&U.normalize(z.from,z.to),void 0!==z.speedRatio&&(U._speedRatio=z.speedRatio),void 0!==z.loopAnimation&&(U._loopAnimation=z.loopAnimation),void 0!==z.isAdditive&&(U._isAdditive=z.isAdditive),void 0!==z.weight&&(U._weight=z.weight),void 0!==z.playOrder&&(U._playOrder=z.playOrder),void 0!==z.enableBlending&&(U._enableBlending=z.enableBlending),void 0!==z.blendingSpeed&&(U._blendingSpeed=z.blendingSpeed),void 0!==z.metadata&&(U.metadata=z.metadata),U}static MakeAnimationAdditive(z,u,U){let v;v="object"===typeof u?u:{referenceFrame:u,range:U,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let f=z;v.cloneOriginalAnimationGroup&&(f=z.clone(v.clonedAnimationGroupName||f.name));const g=f.targetedAnimations;for(let w=0;w<g.length;w++){const z=g[w];z.animation=J.b.MakeAnimationAdditive(z.animation,v)}if(f.isAdditive=!0,v.clipKeys){let z=Number.MAX_VALUE,u=-Number.MAX_VALUE;const U=f.targetedAnimations;for(let J=0;J<U.length;J++){const v=U[J].animation.getKeys();z>v[0].frame&&(z=v[0].frame),u<v[v.length-1].frame&&(u=v[v.length-1].frame)}f._from=z,f._to=u}return f}static ClipKeys(z,u,U,J,v){const f=z.clone(J||z.name);return M.ClipKeysInPlace(f,u,U,v)}static ClipKeysInPlace(z,u,U,J){return M.ClipInPlace(z,u,U,J,!1)}static ClipFrames(z,u,U,J,v){const f=z.clone(J||z.name);return M.ClipFramesInPlace(f,u,U,v)}static ClipFramesInPlace(z,u,U,J){return M.ClipInPlace(z,u,U,J,!0)}static ClipInPlace(z,u,U,J){let v=arguments.length>4&&void 0!==arguments[4]&&arguments[4],f=Number.MAX_VALUE,g=-Number.MAX_VALUE;const w=z.targetedAnimations;for(let P=0;P<w.length;P++){const z=w[P],R=J?z.animation:z.animation.clone();v&&(R.createKeyForFrame(u),R.createKeyForFrame(U));const S=R.getKeys(),d=[];let mz=Number.MAX_VALUE;for(let J=0;J<S.length;J++){const z=S[J];if(!v&&J>=u&&J<=U||v&&z.frame>=u&&z.frame<=U){const u={frame:z.frame,value:z.value.clone?z.value.clone():z.value,inTangent:z.inTangent,outTangent:z.outTangent,interpolation:z.interpolation,lockedTangent:z.lockedTangent};mz===Number.MAX_VALUE&&(mz=u.frame),u.frame-=mz,d.push(u)}}0!==d.length?(f>d[0].frame&&(f=d[0].frame),g<d[d.length-1].frame&&(g=d[d.length-1].frame),R.setKeys(d,!0),z.animation=R):(w.splice(P,1),P--)}return z._from=f,z._to=g,z}getClassName(){return"AnimationGroup"}toString(z){let u="Name: "+this.name;return u+=", type: "+this.getClassName(),z&&(u+=", from: "+this._from,u+=", to: "+this._to,u+=", isStarted: "+this._isStarted,u+=", speedRatio: "+this._speedRatio,u+=", targetedAnimations length: "+this._targetedAnimations.length,u+=", animatables length: "+this._animatables),u}}}}]);