"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[78],{14316:(R,J,B)=>{B.r(J),B.d(J,{AnimationGroup:()=>S,TargetedAnimation:()=>u});var Q=B(11718),h=B(11032),y=B(11065),N=B(11221),r=B(12819),q=B(11186);class e{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(R,J,B,h){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=J,this._target=R,this._scene=B,this._host=h,this._activeTargets=[],J._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===Q.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=q.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const R={frame:0,value:this._minValue};this._keys.splice(0,0,R)}if(this._target instanceof Array){let R=0;for(const J of this._target)this._preparePath(J,R),this._getOriginalValues(R),R++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const y=J.getEvents();if(y&&y.length>0)for(const Q of y)this._events.push(Q._clone());this._enableBlending=R&&R.animationPropertiesOverride?R.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const B=this._animation.targetPropertyPath;if(B.length>1){let Q=R;for(let R=0;R<B.length-1;R++){const J=B[R];if(Q=Q[J],void 0===Q)throw new Error(`Invalid property (${J}) in property path (${B.join(".")})`)}this._targetPath=B[B.length-1],this._activeTargets[J]=Q}else this._targetPath=B[0],this._activeTargets[J]=R;if(void 0===this._activeTargets[J][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${B.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let R=0;for(const J of this._target)void 0!==this._originalValue[R]&&this._setValue(J,this._activeTargets[R],this._originalValue[R],-1,R),R++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let R=0;R<this._events.length;R++)this._events[R].isDone=!1}isStopped(){return this._stopped}dispose(){const R=this._animation.runtimeAnimations.indexOf(this);R>-1&&this._animation.runtimeAnimations.splice(R,1)}setValue(R,J){if(this._targetIsArray)for(let B=0;B<this._target.length;B++){const Q=this._target[B];this._setValue(Q,this._activeTargets[B],R,J,B)}else this._setValue(this._target,this._directTarget,R,J,0)}_getOriginalValues(){let R,J=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const B=this._activeTargets[J];R=B.getLocalMatrix&&"_matrix"===this._targetPath?B.getLocalMatrix():B[this._targetPath],R&&R.clone?this._originalValue[J]=R.clone():this._originalValue[J]=R}_registerTargetForLateAnimationBinding(R,J){const B=R.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(B),B._lateAnimationHolders||(B._lateAnimationHolders={}),B._lateAnimationHolders[R.targetPath]||(B._lateAnimationHolders[R.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:J}),R.isAdditive?(B._lateAnimationHolders[R.targetPath].additiveAnimations.push(R),B._lateAnimationHolders[R.targetPath].totalAdditiveWeight+=R.weight):(B._lateAnimationHolders[R.targetPath].animations.push(R),B._lateAnimationHolders[R.targetPath].totalWeight+=R.weight)}_setValue(R,J,B,h,y){if(this._currentActiveTarget=J,this._weight=h,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const R=J[this._targetPath];R.clone?this._originalBlendValue=R.clone():this._originalBlendValue=R}this._originalBlendValue.m?Q.c.AllowMatrixDecomposeForInterpolation?this._currentValue?q.Matrix.DecomposeLerpToRef(this._originalBlendValue,B,this._blendingFactor,this._currentValue):this._currentValue=q.Matrix.DecomposeLerp(this._originalBlendValue,B,this._blendingFactor):this._currentValue?q.Matrix.LerpToRef(this._originalBlendValue,B,this._blendingFactor,this._currentValue):this._currentValue=q.Matrix.Lerp(this._originalBlendValue,B,this._blendingFactor):this._currentValue=Q.c._UniversalLerp(this._originalBlendValue,B,this._blendingFactor);const h=R&&R.animationPropertiesOverride?R.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=h}else this._currentValue?this._currentValue.h?this._currentValue.h(B):this._currentValue=B:null!==B&&void 0!==B&&B.clone?this._currentValue=B.clone():this._currentValue=B;-1!==h?this._registerTargetForLateAnimationBinding(this,this._originalValue[y]):this._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[y],J[this._targetPath]):J[this._targetPath]=this._originalValue[y]+this._currentValue:J[this._targetPath]=this._currentValue,R.ND&&R.ND(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const B=this._animation.getKeys();R<B[0].frame?R=B[0].frame:R>B[B.length-1].frame&&(R=B[B.length-1].frame);const Q=this._events;if(Q.length)for(let y=0;y<Q.length;y++)Q[y].onlyOnce||(Q[y].isDone=Q[y].frame<R);this._currentFrame=R;const h=this._animation._interpolate(R,this._animationState);this.setValue(h,J)}_prepareForSpeedRatioChange(R){const J=this._previousElapsedTime*(this._animation.framePerSecond*R)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-J}animate(R,J,B,h,y){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const r=this._animation,q=r.targetPropertyPath;if(!q||q.length<1)return this._stopped=!0,!1;let e,D=!0;const l=this._events;let E=0;if(this._coreRuntimeAnimation)E=B-J,e=this._coreRuntimeAnimation.currentFrame,this._currentFrame=e,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let N;(J<this._minFrame||J>this._maxFrame)&&(J=this._minFrame),(B<this._minFrame||B>this._maxFrame)&&(B=this._maxFrame),E=B-J;let q=R*(r.framePerSecond*y)/1e3+this._absoluteFrameOffset,O=0,n=!1;const P=h&&this._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_YOYO;if(P){const R=(q-J)/E,B=Math.sin(R*Math.PI);q=Math.abs(B)*E+J;const Q=B>=0?1:-1;this._yoyoDirection!==Q&&(n=!0),this._yoyoDirection=Q}if(this._previousElapsedTime=R,this._previousAbsoluteFrame=q,!h&&B>=J&&(q>=E&&y>0||q<=0&&y<0))D=!1,O=r._getKeyValue(this._maxValue);else if(!h&&J>=B&&(q<=E&&y<0||q>=0&&y>0))D=!1,O=r._getKeyValue(this._minValue);else if(this._animationState.loopMode!==Q.c.ANIMATIONLOOPMODE_CYCLE){const R=B.toString()+J.toString();if(!this._offsetsCache[R]){this._animationState.repeatCount=0,this._animationState.loopMode=Q.c.ANIMATIONLOOPMODE_CYCLE;const h=r._interpolate(J,this._animationState),y=r._interpolate(B,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),r.dataType){case Q.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[R]=y-h;break;case Q.c.ANIMATIONTYPE_QUATERNION:case Q.c.ANIMATIONTYPE_VECTOR3:case Q.c.ANIMATIONTYPE_VECTOR2:case Q.c.ANIMATIONTYPE_SIZE:case Q.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[R]=y.PJ(h)}this._highLimitsCache[R]=y}O=this._highLimitsCache[R],N=this._offsetsCache[R]}if(void 0===N)switch(r.dataType){case Q.c.ANIMATIONTYPE_FLOAT:N=0;break;case Q.c.ANIMATIONTYPE_QUATERNION:N=Q.k;break;case Q.c.ANIMATIONTYPE_VECTOR3:N=Q.r;break;case Q.c.ANIMATIONTYPE_VECTOR2:N=Q.o;break;case Q.c.ANIMATIONTYPE_SIZE:N=Q.n;break;case Q.c.ANIMATIONTYPE_COLOR3:N=Q.e;break;case Q.c.ANIMATIONTYPE_COLOR4:N=Q.g}if(this._host&&this._host.syncRoot){const R=this._host.syncRoot;e=J+E*((R.masterFrame-R.fromFrame)/(R.toFrame-R.fromFrame))}else e=q>0&&J>B||q<0&&J<B?D&&0!==E?B+q%E:J:D&&0!==E?J+q%E:B;if(!P&&(y>0&&this.currentFrame>e||y<0&&this.currentFrame<e)||P&&n){this._onLoop();for(let R=0;R<l.length;R++)l[R].onlyOnce||(l[R].isDone=!1);this._animationState.key=y>0?0:r.getKeys().length-1}this._currentFrame=e,this._animationState.repeatCount=0===E?0:q/E|0,this._animationState.highLimitValue=O,this._animationState.offsetValue=N}const O=r._interpolate(e,this._animationState);if(this.setValue(O,N),l.length)for(let Q=0;Q<l.length;Q++)if(E>=0&&e>=l[Q].frame&&l[Q].frame>=J||E<0&&e<=l[Q].frame&&l[Q].frame<=J){const R=l[Q];R.isDone||(R.onlyOnce&&(l.splice(Q,1),Q--),R.isDone=!0,R.action(e))}return D||(this._stopped=!0),D}}var D=B(11047);class l{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(R){this._weight=-1!==R?Math.min(Math.max(R,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(R){for(let J=0;J<this._runtimeAnimations.length;J++){this._runtimeAnimations[J]._prepareForSpeedRatioChange(R)}this._speedRatio=R,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(R,J){let B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,y=arguments.length>4&&void 0!==arguments[4]&&arguments[4],N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,r=arguments.length>6?arguments[6]:void 0,q=arguments.length>7?arguments[7]:void 0,e=arguments.length>8?arguments[8]:void 0,D=arguments.length>9&&void 0!==arguments[9]&&arguments[9],l=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=J,this.fromFrame=B,this.toFrame=Q,this.loopAnimation=y,this.onAnimationEnd=r,this.onAnimationLoop=e,this.isAdditive=D,this.playOrder=l,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.lr=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new h.e,this.onAnimationLoopObservable=new h.e,this._scene=R,q&&this.appendAnimations(J,q),this._speedRatio=N,R._activeAnimatables.push(this)}syncWith(R){if(this._syncRoot=R,R){const R=this._scene._activeAnimatables.indexOf(this);R>-1&&(this._scene._activeAnimatables.splice(R,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(R,J){for(let B=0;B<J.length;B++){const Q=J[B],h=new e(R,Q,this._scene,this);h._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(h)}}getAnimationByTargetProperty(R){const J=this._runtimeAnimations;for(let B=0;B<J.length;B++)if(J[B].animation.targetProperty===R)return J[B].animation;return null}getRuntimeAnimationByTargetProperty(R){const J=this._runtimeAnimations;for(let B=0;B<J.length;B++)if(J[B].animation.targetProperty===R)return J[B];return null}reset(){const R=this._runtimeAnimations;for(let J=0;J<R.length;J++)R[J].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(R){const J=this._runtimeAnimations;for(let B=0;B<J.length;B++)J[B].animation.enableBlending=!0,J[B].animation.blendingSpeed=R}disableBlending(){const R=this._runtimeAnimations;for(let J=0;J<R.length;J++)R[J].animation.enableBlending=!1}goToFrame(R){let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const B=this._runtimeAnimations;if(B[0]){const J=B[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??B[0].currentFrame;const Q=0===this.speedRatio?0:(R-this._frameToSyncFromJump)/J*1e3/this.speedRatio;this._manualJumpDelay=-Q}for(let Q=0;Q<B.length;Q++)B[Q].goToFrame(R,J?this._weight:-1);this._goToFrame=R}get paused(){return this.lr}pause(){this.lr||(this.lr=!0)}restart(){this.lr=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(R,J){let B=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(R||J){const h=this._scene._activeAnimatables.indexOf(this);if(h>-1){const y=this._runtimeAnimations;for(let B=y.length-1;B>=0;B--){const Q=y[B];R&&Q.animation.name!=R||(J&&!J(Q.target)||(Q.dispose(),y.splice(B,1)))}0==y.length&&(B||this._scene._activeAnimatables.splice(h,1),Q||this._raiseOnAnimationEnd())}}else{const R=this._scene._activeAnimatables.indexOf(this);if(R>-1){B||this._scene._activeAnimatables.splice(R,1);const J=this._runtimeAnimations;for(let R=0;R<J.length;R++)J[R].dispose();this._runtimeAnimations.length=0,Q||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((R=>{this.onAnimationEndObservable.add((()=>{R(this)}),void 0,void 0,this,!0)}))}_animate(R){if(this.lr)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=R),!0;if(null===this._localDelayOffset?(this._localDelayOffset=R,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=R-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let J=!1;const B=this._runtimeAnimations;let Q;for(Q=0;Q<B.length;Q++){const h=B[Q].animate(R-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);J=J||h}if(this.animationStarted=J,!J){if(this.disposeOnEnd)for(Q=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(Q,1),Q=0;Q<B.length;Q++)B[Q].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return J}}function E(R){if(0===R.totalWeight&&0===R.totalAdditiveWeight)return R.originalValue;let J=1;const B=q.TmpVectors.nJ[0],Q=q.TmpVectors.nJ[1],h=q.TmpVectors.Quaternion[0];let y=0;const N=R.animations[0],r=R.originalValue;let e=1,D=!1;if(R.totalWeight<1)e=1-R.totalWeight,r.decompose(Q,h,B);else{if(y=1,J=R.totalWeight,e=N.weight/J,1==e){if(!R.totalAdditiveWeight)return N.currentValue;D=!0}N.currentValue.decompose(Q,h,B)}if(!D){Q.scaleInPlace(e),B.scaleInPlace(e),h.scaleInPlace(e);for(let N=y;N<R.animations.length;N++){const y=R.animations[N];if(0===y.weight)continue;e=y.weight/J;const r=q.TmpVectors.nJ[2],D=q.TmpVectors.nJ[3],l=q.TmpVectors.Quaternion[1];y.currentValue.decompose(D,l,r),D.scaleAndAddToRef(e,Q),l.scaleAndAddToRef(q.Quaternion.Dot(h,l)>0?e:-e,h),r.scaleAndAddToRef(e,B)}h.normalize()}for(let E=0;E<R.additiveAnimations.length;E++){const J=R.additiveAnimations[E];if(0===J.weight)continue;const y=q.TmpVectors.nJ[2],N=q.TmpVectors.nJ[3],r=q.TmpVectors.Quaternion[1];J.currentValue.decompose(N,r,y),N.multiplyToRef(Q,N),q.nJ.LerpToRef(Q,N,J.weight,Q),h.multiplyToRef(r,r),q.Quaternion.SlerpToRef(h,r,J.weight,h),y.scaleAndAddToRef(J.weight,B)}const l=N?N._animationState.workValue:q.TmpVectors.Matrix[0].clone();return q.Matrix.ComposeToRef(Q,h,B,l),l}function O(R,J){if(0===R.totalWeight&&0===R.totalAdditiveWeight)return J;const B=R.animations[0],Q=R.originalValue;let h=J;if(0===R.totalWeight&&R.totalAdditiveWeight>0)h.h(Q);else if(1===R.animations.length){if(q.Quaternion.SlerpToRef(Q,B.currentValue,Math.min(1,R.totalWeight),h),0===R.totalAdditiveWeight)return h}else if(R.animations.length>1){let B,y,N=1;if(R.totalWeight<1){const J=1-R.totalWeight;B=[],y=[],B.push(Q),y.push(J)}else{if(2===R.animations.length&&(q.Quaternion.SlerpToRef(R.animations[0].currentValue,R.animations[1].currentValue,R.animations[1].weight/R.totalWeight,J),0===R.totalAdditiveWeight))return J;B=[],y=[],N=R.totalWeight}for(let J=0;J<R.animations.length;J++){const Q=R.animations[J];B.push(Q.currentValue),y.push(Q.weight/N)}let r=0;for(let R=0;R<B.length;)R?(r+=y[R],q.Quaternion.SlerpToRef(h,B[R],y[R]/r,h),R++):(q.Quaternion.SlerpToRef(B[R],B[R+1],y[R+1]/(y[R]+y[R+1]),J),h=J,r=y[R]+y[R+1],R+=2)}for(let y=0;y<R.additiveAnimations.length;y++){const J=R.additiveAnimations[y];0!==J.weight&&(h.multiplyToRef(J.currentValue,q.TmpVectors.Quaternion[0]),q.Quaternion.SlerpToRef(h,q.TmpVectors.Quaternion[0],J.weight,h))}return h}var n,P,A=B(11419);n=A.d,(P=r.b)&&(P.prototype.copyAnimationRange=function(R,J,B){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3],y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new Q.c(this.name,"_matrix",R.animations[0].framePerSecond,Q.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const N=R.animations[0].getRange(J);if(!N)return!1;const r=N.from,q=N.to,e=R.animations[0].getKeys(),D=R.length,l=R.getParent(),E=this.getParent(),O=h&&l&&D&&this.length&&D!==this.length,n=O&&E&&l?E.length/l.length:1,P=h&&!E&&y&&(1!==y.x||1!==y.y||1!==y.z),A=this.animations[0].getKeys();let u,S,f;for(let Q=0,a=e.length;Q<a;Q++)u=e[Q],u.frame>=r&&u.frame<=q&&(h?(f=u.value.clone(),O?(S=f.getTranslation(),f.setTranslation(S.scaleInPlace(n))):P&&y?(S=f.getTranslation(),f.setTranslation(S.multiplyInPlace(y))):f=u.value):f=u.value,A.push({frame:u.frame+B,value:f}));return this.animations[0].createRange(J,r+B,q+B),!0}),n&&(n.prototype._animate=function(R){if(!this.animationsEnabled)return;const J=D.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=J}this.deltaTime=void 0!==R?R:this.useConstantAnimationDeltaTime?16:(J-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=J;const B=this._activeAnimatables;if(0===B.length)return;this._animationTime+=this.deltaTime;const h=this._animationTime;for(let Q=0;Q<B.length;Q++){const R=B[Q];!R._animate(h)&&R.disposeOnEnd&&Q--}!function(R){if(R._registeredForLateAnimationBindings.length){for(let J=0;J<R._registeredForLateAnimationBindings.length;J++){const B=R._registeredForLateAnimationBindings.data[J];for(const R in B._lateAnimationHolders){const J=B._lateAnimationHolders[R],h=J.animations[0],y=J.originalValue;if(void 0===y||null===y)continue;const N=Q.c.AllowMatrixDecomposeForInterpolation&&y.m;let r=B[R];if(N)r=E(J);else if(void 0!==y.w)r=O(J,r||q.Quaternion.Identity());else{let R=0,B=1;const N=h&&h._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(J.totalWeight<1)r=N?y.clone?y.clone():y:h&&y.scale?y.scale(1-J.totalWeight):h?y*(1-J.totalWeight):y.clone?y.clone():y;else if(h){B=J.totalWeight;const Q=h.weight/B;r=1!==Q?h.currentValue.scale?h.currentValue.scale(Q):h.currentValue*Q:h.currentValue,N&&(r.addToRef?r.addToRef(y,r):r+=y),R=1}for(let Q=R;Q<J.animations.length;Q++){const R=J.animations[Q],h=R.weight/B;h&&(R.currentValue.scaleAndAddToRef?R.currentValue.scaleAndAddToRef(h,r):r+=R.currentValue*h)}for(let Q=0;Q<J.additiveAnimations.length;Q++){const R=J.additiveAnimations[Q],B=R.weight;B&&(R.currentValue.scaleAndAddToRef?R.currentValue.scaleAndAddToRef(B,r):r+=R.currentValue*B)}}B[R]=r}B._lateAnimationHolders={}}R._registeredForLateAnimationBindings.reset()}}(this)},n.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((R,J)=>R.playOrder-J.playOrder))},n.prototype.beginWeightedAnimation=function(R,J,B){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,h=arguments.length>4?arguments[4]:void 0,y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,N=arguments.length>6?arguments[6]:void 0,r=arguments.length>7?arguments[7]:void 0,q=arguments.length>8?arguments[8]:void 0,e=arguments.length>9?arguments[9]:void 0,D=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const l=this.beginAnimation(R,J,B,h,y,N,r,!1,q,e,D);return l.weight=Q,l},n.prototype.beginAnimation=function(R,J,B,Q){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,y=arguments.length>5?arguments[5]:void 0,N=arguments.length>6?arguments[6]:void 0,r=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],q=arguments.length>8?arguments[8]:void 0,e=arguments.length>9?arguments[9]:void 0,D=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(h<0){const R=J;J=B,B=R,h=-h}J>B&&(h=-h),r&&this.stopAnimation(R,void 0,q),N||(N=new l(this,R,J,B,Q,h,y,void 0,e,D));const E=!q||q(R);if(R.animations&&E&&N.appendAnimations(R,R.animations),R.getAnimatables){const D=R.getAnimatables();for(let R=0;R<D.length;R++)this.beginAnimation(D[R],J,B,Q,h,y,N,r,q,e)}return N.reset(),N},n.prototype.beginHierarchyAnimation=function(R,J,B,Q,h){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,N=arguments.length>6?arguments[6]:void 0,r=arguments.length>7?arguments[7]:void 0,q=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],e=arguments.length>9?arguments[9]:void 0,D=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const l=R.getDescendants(J),E=[];E.push(this.beginAnimation(R,B,Q,h,y,N,r,q,e,void 0,D));for(const O of l)E.push(this.beginAnimation(O,B,Q,h,y,N,r,q,e,void 0,D));return E},n.prototype.beginDirectAnimation=function(R,J,B,Q,h){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(y<0){const R=B;B=Q,Q=R,y=-y}return B>Q&&(y=-y),new l(this,R,B,Q,h,y,arguments.length>6?arguments[6]:void 0,J,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},n.prototype.beginDirectHierarchyAnimation=function(R,J,B,Q,h,y,N,r,q){let e=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const D=R.getDescendants(J),l=[];l.push(this.beginDirectAnimation(R,B,Q,h,y,N,r,q,e));for(const E of D)l.push(this.beginDirectAnimation(E,B,Q,h,y,N,r,q,e));return l},n.prototype.getAnimatableByTarget=function(R){for(let J=0;J<this._activeAnimatables.length;J++)if(this._activeAnimatables[J].target===R)return this._activeAnimatables[J];return null},n.prototype.getAllAnimatablesByTarget=function(R){const J=[];for(let B=0;B<this._activeAnimatables.length;B++)this._activeAnimatables[B].target===R&&J.push(this._activeAnimatables[B]);return J},n.prototype.stopAnimation=function(R,J,B){const Q=this.getAllAnimatablesByTarget(R);for(const h of Q)h.stop(J,B)},n.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let R=0;R<this._activeAnimatables.length;R++)this._activeAnimatables[R].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const R of this.animationGroups)R.stop()});class u{getClassName(){return"TargetedAnimation"}serialize(){const R={};return R.animation=this.animation.serialize(),R.targetId=this.target.id,R}}class S{get mask(){return this._mask}set mask(R){this._mask!==R&&(this._mask=R,this.syncWithMask(!0))}syncWithMask(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||R){this._numActiveAnimatables=0;for(let R=0;R<this._animatables.length;++R){const J=this._animatables[R];!this.mask||this.mask.disabled||this.mask.retainsTarget(J.target.name)?(this._numActiveAnimatables++,J.paused&&J.restart()):J.paused||J.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let R=0;R<this._animatables.length;++R){const J=this._animatables[R];this.mask.retainsTarget(J.target.name)||(J.stop(),this._animatables.splice(R,1),--R)}for(let R=0;R<this._targetedAnimations.length;R++){const J=this._targetedAnimations[R];this.mask.retainsTarget(J.target.name)||(this._targetedAnimations.splice(R,1),--R)}}}get from(){return this._from}set from(R){if(this._from!==R){this._from=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].fromFrame=this._from}}}get to(){return this._to}set to(R){if(this._to!==R){this._to=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(R){if(this._speedRatio!==R){this._speedRatio=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(R){if(this._loopAnimation!==R){this._loopAnimation=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(R){if(this._isAdditive!==R){this._isAdditive=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(R){this._weight!==R&&(this._weight=R,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(R){if(this._playOrder!==R&&(this._playOrder=R,this._animatables.length>0)){for(let R=0;R<this._animatables.length;R++)this._animatables[R].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(R){if(this._enableBlending!==R&&(this._enableBlending=R,null!==R))for(let J=0;J<this._targetedAnimations.length;++J)this._targetedAnimations[J].animation.enableBlending=R}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(R){if(this._blendingSpeed!==R&&(this._blendingSpeed=R,null!==R))for(let J=0;J<this._targetedAnimations.length;++J)this._targetedAnimations[J].animation.blendingSpeed=R}getLength(R,J){R=R??this._from;return((J=J??this._to)-R)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(R){let J=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],B=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=arguments.length>3?arguments[3]:void 0;if(0===R.length)return null;Q=Q??R[0].weight;let h=Number.MAX_VALUE,y=-Number.MAX_VALUE;if(B)for(const r of R)r.from<h&&(h=r.from),r.to>y&&(y=r.to);const N=new S(R[0].name+"_merged",R[0]._scene,Q);for(const r of R){B&&r.normalize(h,y);for(const R of r.targetedAnimations)N.addTargetedAnimation(R.animation,R.target);J&&r.dispose()}return N}constructor(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=R,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new h.e,this.onAnimationLoopObservable=new h.e,this.onAnimationGroupLoopObservable=new h.e,this.onAnimationGroupEndObservable=new h.e,this.onAnimationGroupPauseObservable=new h.e,this.onAnimationGroupPlayObservable=new h.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=J||y.e.LastCreatedScene,this._weight=B,this._playOrder=Q,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(R,J){const B=new u;B.animation=R,B.target=J;const Q=R.getKeys();return this._from>Q[0].frame&&(this._from=Q[0].frame),this._to<Q[Q.length-1].frame&&(this._to=Q[Q.length-1].frame),null!==this._enableBlending&&(R.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(R.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(B),this._shouldStart=!0,B}removeTargetedAnimation(R){for(let J=this._targetedAnimations.length-1;J>-1;J--){this._targetedAnimations[J].animation===R&&this._targetedAnimations.splice(J,1)}}normalize(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==R&&(R=this._from),null==J&&(J=this._to);for(let B=0;B<this._targetedAnimations.length;B++){const Q=this._targetedAnimations[B].animation.getKeys(),h=Q[0],y=Q[Q.length-1];if(h.frame>R){const J={frame:R,value:h.value,inTangent:h.inTangent,outTangent:h.outTangent,interpolation:h.interpolation};Q.splice(0,0,J)}if(y.frame<J){const R={frame:J,value:y.value,inTangent:y.inTangent,outTangent:y.outTangent,interpolation:y.interpolation};Q.push(R)}}return this._from=R,this._to=J,this}_processLoop(R,J,B){R.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(J),this._animationLoopFlags[B]||(this._animationLoopFlags[B]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0],J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,B=arguments.length>2?arguments[2]:void 0,Q=arguments.length>3?arguments[3]:void 0,h=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=R,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let y=0;y<this._targetedAnimations.length;y++){const N=this._targetedAnimations[y],r=this._scene.beginDirectAnimation(N.target,[N.animation],void 0!==B?B:this._from,void 0!==Q?Q:this._to,R,J,void 0,void 0,void 0!==h?h:this._isAdditive);r.weight=this._weight,r.playOrder=this._playOrder,r.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(N),this._checkAnimationGroupEnded(r)},this._processLoop(r,N,y),this._animatables.push(r)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=J,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let R=0;R<this._animatables.length;R++){this._animatables[R].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(R){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==R&&(this.loopAnimation=R),this.restart()):(this.stop(),this.start(R,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let R=0;R<this._animatables.length;R++){this._animatables[R].reset()}return this}restart(){if(!this._isStarted)return this;for(let R=0;R<this._animatables.length;R++){this._animatables[R].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const J=this._animatables.slice();for(let Q=0;Q<J.length;Q++)J[Q].stop(void 0,void 0,!0,R);let B=0;for(let Q=0;Q<this._scene._activeAnimatables.length;Q++){const J=this._scene._activeAnimatables[Q];J._runtimeAnimations.length>0?this._scene._activeAnimatables[B++]=J:R&&this._checkAnimationGroupEnded(J,R)}return this._scene._activeAnimatables.length=B,this._isStarted=!1,this}setWeightForAllAnimatables(R){for(let J=0;J<this._animatables.length;J++){this._animatables[J].weight=R}return this}syncAllAnimationsWith(R){for(let J=0;J<this._animatables.length;J++){this._animatables[J].syncWith(R)}return this}goToFrame(R){let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let B=0;B<this._animatables.length;B++){this._animatables[B].goToFrame(R,J)}return this}getCurrentFrame(){var R;return(null===(R=this.animatables[0])||void 0===R?void 0:R.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const R=this._scene.animationGroups.indexOf(this);if(R>-1&&this._scene.animationGroups.splice(R,1),this._parentContainer){const R=this._parentContainer.animationGroups.indexOf(this);R>-1&&this._parentContainer.animationGroups.splice(R,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(R){let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const B=this._animatables.indexOf(R);B>-1&&this._animatables.splice(B,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,J||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(R,J){let B=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=new S(R||this.name,this._scene,this._weight,this._playOrder);Q._from=this.from,Q._to=this.to,Q._speedRatio=this.speedRatio,Q._loopAnimation=this.loopAnimation,Q._isAdditive=this.isAdditive,Q._enableBlending=this.enableBlending,Q._blendingSpeed=this.blendingSpeed,Q.metadata=this.metadata,Q.mask=this.mask;for(const h of this._targetedAnimations)Q.addTargetedAnimation(B?h.animation.clone():h.animation,J?J(h.target):h.target);return Q}serialize(){const R={};R.name=this.name,R.from=this.from,R.to=this.to,R.speedRatio=this.speedRatio,R.loopAnimation=this.loopAnimation,R.isAdditive=this.isAdditive,R.weight=this.weight,R.playOrder=this.playOrder,R.enableBlending=this.enableBlending,R.blendingSpeed=this.blendingSpeed,R.targetedAnimations=[];for(let J=0;J<this.targetedAnimations.length;J++){const B=this.targetedAnimations[J];R.targetedAnimations[J]=B.serialize()}return N.d&&N.d.HasTags(this)&&(R.tags=N.d.GetTags(this)),this.metadata&&(R.metadata=this.metadata),R}static Parse(R,J){const B=new S(R.name,J,R.weight,R.playOrder);for(let h=0;h<R.targetedAnimations.length;h++){const y=R.targetedAnimations[h],N=Q.c.Parse(y.animation),r=y.targetId;if("influence"===y.animation.property){const R=J.getMorphTargetById(r);R&&B.addTargetedAnimation(N,R)}else{const R=J.getNodeById(r);null!=R&&B.addTargetedAnimation(N,R)}}return N.d&&N.d.AddTagsTo(B,R.tags),null!==R.from&&null!==R.to&&B.normalize(R.from,R.to),void 0!==R.speedRatio&&(B._speedRatio=R.speedRatio),void 0!==R.loopAnimation&&(B._loopAnimation=R.loopAnimation),void 0!==R.isAdditive&&(B._isAdditive=R.isAdditive),void 0!==R.weight&&(B._weight=R.weight),void 0!==R.playOrder&&(B._playOrder=R.playOrder),void 0!==R.enableBlending&&(B._enableBlending=R.enableBlending),void 0!==R.blendingSpeed&&(B._blendingSpeed=R.blendingSpeed),void 0!==R.metadata&&(B.metadata=R.metadata),B}static MakeAnimationAdditive(R,J,B){let h;h="object"===typeof J?J:{referenceFrame:J,range:B,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let y=R;h.cloneOriginalAnimationGroup&&(y=R.clone(h.clonedAnimationGroupName||y.name));const N=y.targetedAnimations;for(let r=0;r<N.length;r++){const R=N[r];R.animation=Q.c.MakeAnimationAdditive(R.animation,h)}if(y.isAdditive=!0,h.clipKeys){let R=Number.MAX_VALUE,J=-Number.MAX_VALUE;const B=y.targetedAnimations;for(let Q=0;Q<B.length;Q++){const h=B[Q].animation.getKeys();R>h[0].frame&&(R=h[0].frame),J<h[h.length-1].frame&&(J=h[h.length-1].frame)}y._from=R,y._to=J}return y}static ClipKeys(R,J,B,Q,h){const y=R.clone(Q||R.name);return S.ClipKeysInPlace(y,J,B,h)}static ClipKeysInPlace(R,J,B,Q){return S.ClipInPlace(R,J,B,Q,!1)}static ClipFrames(R,J,B,Q,h){const y=R.clone(Q||R.name);return S.ClipFramesInPlace(y,J,B,h)}static ClipFramesInPlace(R,J,B,Q){return S.ClipInPlace(R,J,B,Q,!0)}static ClipInPlace(R,J,B,Q){let h=arguments.length>4&&void 0!==arguments[4]&&arguments[4],y=Number.MAX_VALUE,N=-Number.MAX_VALUE;const r=R.targetedAnimations;for(let q=0;q<r.length;q++){const R=r[q],e=Q?R.animation:R.animation.clone();h&&(e.createKeyForFrame(J),e.createKeyForFrame(B));const D=e.getKeys(),l=[];let E=Number.MAX_VALUE;for(let Q=0;Q<D.length;Q++){const R=D[Q];if(!h&&Q>=J&&Q<=B||h&&R.frame>=J&&R.frame<=B){const J={frame:R.frame,value:R.value.clone?R.value.clone():R.value,inTangent:R.inTangent,outTangent:R.outTangent,interpolation:R.interpolation,lockedTangent:R.lockedTangent};E===Number.MAX_VALUE&&(E=J.frame),J.frame-=E,l.push(J)}}0!==l.length?(y>l[0].frame&&(y=l[0].frame),N<l[l.length-1].frame&&(N=l[l.length-1].frame),e.setKeys(l,!0),R.animation=e):(r.splice(q,1),q--)}return R._from=y,R._to=N,R}getClassName(){return"AnimationGroup"}toString(R){let J="Name: "+this.name;return J+=", type: "+this.getClassName(),R&&(J+=", from: "+this._from,J+=", to: "+this._to,J+=", isStarted: "+this._isStarted,J+=", speedRatio: "+this._speedRatio,J+=", targetedAnimations length: "+this._targetedAnimations.length,J+=", animatables length: "+this._animatables),J}}}}]);