"use strict";(self.kdlk57exiqh=self.kdlk57exiqh||[]).push([[78],{15311:(i,x,e)=>{e.r(x),e.d(x,{AnimationGroup:()=>Q,TargetedAnimation:()=>T});var j=e(12753),E=e(12065),a=e(12108),Y=e(12283),J=e(13800),u=e(12250);class b{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(i,x,e,E){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=x,this._target=i,this._scene=e,this._host=E,this._activeTargets=[],x._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===j.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=u.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const i={frame:0,value:this._minValue};this._keys.splice(0,0,i)}if(this._target instanceof Array){let i=0;for(const x of this._target)this._preparePath(x,i),this._getOriginalValues(i),i++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const a=x.getEvents();if(a&&a.length>0)for(const j of a)this._events.push(j._clone());this._enableBlending=i&&i.animationPropertiesOverride?i.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const e=this._animation.targetPropertyPath;if(e.length>1){let j=i;for(let i=0;i<e.length-1;i++){const x=e[i];if(j=j[x],void 0===j)throw new Error(`Invalid property (${x}) in property path (${e.join(".")})`)}this._targetPath=e[e.length-1],this._activeTargets[x]=j}else this._targetPath=e[0],this._activeTargets[x]=i;if(void 0===this._activeTargets[x][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${e.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let i=0;for(const x of this._target)void 0!==this._originalValue[i]&&this._setValue(x,this._activeTargets[i],this._originalValue[i],-1,i),i++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let i=0;i<this._events.length;i++)this._events[i].isDone=!1}isStopped(){return this._stopped}dispose(){const i=this._animation.runtimeAnimations.indexOf(this);i>-1&&this._animation.runtimeAnimations.splice(i,1)}setValue(i,x){if(this._targetIsArray)for(let e=0;e<this._target.length;e++){const j=this._target[e];this._setValue(j,this._activeTargets[e],i,x,e)}else this._setValue(this._target,this._directTarget,i,x,0)}_getOriginalValues(){let i,x=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const e=this._activeTargets[x];i=e.getLocalMatrix&&"_matrix"===this._targetPath?e.getLocalMatrix():e[this._targetPath],i&&i.clone?this._originalValue[x]=i.clone():this._originalValue[x]=i}_registerTargetForLateAnimationBinding(i,x){const e=i.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(e),e._lateAnimationHolders||(e._lateAnimationHolders={}),e._lateAnimationHolders[i.targetPath]||(e._lateAnimationHolders[i.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:x}),i.isAdditive?(e._lateAnimationHolders[i.targetPath].additiveAnimations.push(i),e._lateAnimationHolders[i.targetPath].totalAdditiveWeight+=i.weight):(e._lateAnimationHolders[i.targetPath].animations.push(i),e._lateAnimationHolders[i.targetPath].totalWeight+=i.weight)}_setValue(i,x,e,E,a){if(this._currentActiveTarget=x,this._weight=E,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const i=x[this._targetPath];i.clone?this._originalBlendValue=i.clone():this._originalBlendValue=i}this._originalBlendValue.m?j.c.AllowMatrixDecomposeForInterpolation?this._currentValue?u.Matrix.DecomposeLerpToRef(this._originalBlendValue,e,this._blendingFactor,this._currentValue):this._currentValue=u.Matrix.DecomposeLerp(this._originalBlendValue,e,this._blendingFactor):this._currentValue?u.Matrix.LerpToRef(this._originalBlendValue,e,this._blendingFactor,this._currentValue):this._currentValue=u.Matrix.Lerp(this._originalBlendValue,e,this._blendingFactor):this._currentValue=j.c._UniversalLerp(this._originalBlendValue,e,this._blendingFactor);const E=i&&i.animationPropertiesOverride?i.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=E}else this._currentValue?this._currentValue.A?this._currentValue.A(e):this._currentValue=e:null!==e&&void 0!==e&&e.clone?this._currentValue=e.clone():this._currentValue=e;-1!==E?this._registerTargetForLateAnimationBinding(this,this._originalValue[a]):this._animationState.loopMode===j.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[a],x[this._targetPath]):x[this._targetPath]=this._originalValue[a]+this._currentValue:x[this._targetPath]=this._currentValue,i.rg&&i.rg(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const e=this._animation.getKeys();i<e[0].frame?i=e[0].frame:i>e[e.length-1].frame&&(i=e[e.length-1].frame);const j=this._events;if(j.length)for(let a=0;a<j.length;a++)j[a].onlyOnce||(j[a].isDone=j[a].frame<i);this._currentFrame=i;const E=this._animation._interpolate(i,this._animationState);this.setValue(E,x)}_prepareForSpeedRatioChange(i){const x=this._previousElapsedTime*(this._animation.framePerSecond*i)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-x}animate(i,x,e,E,a){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const J=this._animation,u=J.targetPropertyPath;if(!u||u.length<1)return this._stopped=!0,!1;let b,g=!0;const A=this._events;let K=0;if(this._coreRuntimeAnimation)K=e-x,b=this._coreRuntimeAnimation.currentFrame,this._currentFrame=b,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let Y;(x<this._minFrame||x>this._maxFrame)&&(x=this._minFrame),(e<this._minFrame||e>this._maxFrame)&&(e=this._maxFrame),K=e-x;let u=i*(J.framePerSecond*a)/1e3+this._absoluteFrameOffset,L=0,o=!1;const M=E&&this._animationState.loopMode===j.c.ANIMATIONLOOPMODE_YOYO;if(M){const i=(u-x)/K,e=Math.sin(i*Math.PI);u=Math.abs(e)*K+x;const j=e>=0?1:-1;this._yoyoDirection!==j&&(o=!0),this._yoyoDirection=j}if(this._previousElapsedTime=i,this._previousAbsoluteFrame=u,!E&&e>=x&&(u>=K&&a>0||u<=0&&a<0))g=!1,L=J._getKeyValue(this._maxValue);else if(!E&&x>=e&&(u<=K&&a<0||u>=0&&a>0))g=!1,L=J._getKeyValue(this._minValue);else if(this._animationState.loopMode!==j.c.ANIMATIONLOOPMODE_CYCLE){const i=e.toString()+x.toString();if(!this._offsetsCache[i]){this._animationState.repeatCount=0,this._animationState.loopMode=j.c.ANIMATIONLOOPMODE_CYCLE;const E=J._interpolate(x,this._animationState),a=J._interpolate(e,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),J.dataType){case j.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[i]=a-E;break;case j.c.ANIMATIONTYPE_QUATERNION:case j.c.ANIMATIONTYPE_VECTOR3:case j.c.ANIMATIONTYPE_VECTOR2:case j.c.ANIMATIONTYPE_SIZE:case j.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[i]=a.Cx(E)}this._highLimitsCache[i]=a}L=this._highLimitsCache[i],Y=this._offsetsCache[i]}if(void 0===Y)switch(J.dataType){case j.c.ANIMATIONTYPE_FLOAT:Y=0;break;case j.c.ANIMATIONTYPE_QUATERNION:Y=j.h;break;case j.c.ANIMATIONTYPE_VECTOR3:Y=j.n;break;case j.c.ANIMATIONTYPE_VECTOR2:Y=j.m;break;case j.c.ANIMATIONTYPE_SIZE:Y=j.l;break;case j.c.ANIMATIONTYPE_COLOR3:Y=j.e;break;case j.c.ANIMATIONTYPE_COLOR4:Y=j.g}if(this._host&&this._host.syncRoot){const i=this._host.syncRoot;b=x+K*((i.masterFrame-i.fromFrame)/(i.toFrame-i.fromFrame))}else b=u>0&&x>e||u<0&&x<e?g&&0!==K?e+u%K:x:g&&0!==K?x+u%K:e;if(!M&&(a>0&&this.currentFrame>b||a<0&&this.currentFrame<b)||M&&o){this._onLoop();for(let i=0;i<A.length;i++)A[i].onlyOnce||(A[i].isDone=!1);this._animationState.key=a>0?0:J.getKeys().length-1}this._currentFrame=b,this._animationState.repeatCount=0===K?0:u/K|0,this._animationState.highLimitValue=L,this._animationState.offsetValue=Y}const L=J._interpolate(b,this._animationState);if(this.setValue(L,Y),A.length)for(let j=0;j<A.length;j++)if(K>=0&&b>=A[j].frame&&A[j].frame>=x||K<0&&b<=A[j].frame&&A[j].frame<=x){const i=A[j];i.isDone||(i.onlyOnce&&(A.splice(j,1),j--),i.isDone=!0,i.action(b))}return g||(this._stopped=!0),g}}var g=e(12089);class A{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(i){this._weight=-1!==i?Math.min(Math.max(i,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(i){for(let x=0;x<this._runtimeAnimations.length;x++){this._runtimeAnimations[x]._prepareForSpeedRatioChange(i)}this._speedRatio=i,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(i,x){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,J=arguments.length>6?arguments[6]:void 0,u=arguments.length>7?arguments[7]:void 0,b=arguments.length>8?arguments[8]:void 0,g=arguments.length>9&&void 0!==arguments[9]&&arguments[9],A=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=x,this.fromFrame=e,this.toFrame=j,this.loopAnimation=a,this.onAnimationEnd=J,this.onAnimationLoop=b,this.isAdditive=g,this.playOrder=A,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.VJ=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new E.b,this.onAnimationLoopObservable=new E.b,this._scene=i,u&&this.appendAnimations(x,u),this._speedRatio=Y,i._activeAnimatables.push(this)}syncWith(i){if(this._syncRoot=i,i){const i=this._scene._activeAnimatables.indexOf(this);i>-1&&(this._scene._activeAnimatables.splice(i,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(i,x){for(let e=0;e<x.length;e++){const j=x[e],E=new b(i,j,this._scene,this);E._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(E)}}getAnimationByTargetProperty(i){const x=this._runtimeAnimations;for(let e=0;e<x.length;e++)if(x[e].animation.targetProperty===i)return x[e].animation;return null}getRuntimeAnimationByTargetProperty(i){const x=this._runtimeAnimations;for(let e=0;e<x.length;e++)if(x[e].animation.targetProperty===i)return x[e];return null}reset(){const i=this._runtimeAnimations;for(let x=0;x<i.length;x++)i[x].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(i){const x=this._runtimeAnimations;for(let e=0;e<x.length;e++)x[e].animation.enableBlending=!0,x[e].animation.blendingSpeed=i}disableBlending(){const i=this._runtimeAnimations;for(let x=0;x<i.length;x++)i[x].animation.enableBlending=!1}goToFrame(i){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const e=this._runtimeAnimations;if(e[0]){const x=e[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??e[0].currentFrame;const j=0===this.speedRatio?0:(i-this._frameToSyncFromJump)/x*1e3/this.speedRatio;this._manualJumpDelay=-j}for(let j=0;j<e.length;j++)e[j].goToFrame(i,x?this._weight:-1);this._goToFrame=i}get paused(){return this.VJ}pause(){this.VJ||(this.VJ=!0)}restart(){this.VJ=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(i,x){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2],j=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(i||x){const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){const a=this._runtimeAnimations;for(let e=a.length-1;e>=0;e--){const j=a[e];i&&j.animation.name!=i||(x&&!x(j.target)||(j.dispose(),a.splice(e,1)))}0==a.length&&(e||this._scene._activeAnimatables.splice(E,1),j||this._raiseOnAnimationEnd())}}else{const i=this._scene._activeAnimatables.indexOf(this);if(i>-1){e||this._scene._activeAnimatables.splice(i,1);const x=this._runtimeAnimations;for(let i=0;i<x.length;i++)x[i].dispose();this._runtimeAnimations.length=0,j||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((i=>{this.onAnimationEndObservable.add((()=>{i(this)}),void 0,void 0,this,!0)}))}_animate(i){if(this.VJ)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=i),!0;if(null===this._localDelayOffset?(this._localDelayOffset=i,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=i-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let x=!1;const e=this._runtimeAnimations;let j;for(j=0;j<e.length;j++){const E=e[j].animate(i-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);x=x||E}if(this.animationStarted=x,!x){if(this.disposeOnEnd)for(j=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(j,1),j=0;j<e.length;j++)e[j].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return x}}function K(i){if(0===i.totalWeight&&0===i.totalAdditiveWeight)return i.originalValue;let x=1;const e=u.TmpVectors.KJ[0],j=u.TmpVectors.KJ[1],E=u.TmpVectors.Quaternion[0];let a=0;const Y=i.animations[0],J=i.originalValue;let b=1,g=!1;if(i.totalWeight<1)b=1-i.totalWeight,J.decompose(j,E,e);else{if(a=1,x=i.totalWeight,b=Y.weight/x,1==b){if(!i.totalAdditiveWeight)return Y.currentValue;g=!0}Y.currentValue.decompose(j,E,e)}if(!g){j.scaleInPlace(b),e.scaleInPlace(b),E.scaleInPlace(b);for(let Y=a;Y<i.animations.length;Y++){const a=i.animations[Y];if(0===a.weight)continue;b=a.weight/x;const J=u.TmpVectors.KJ[2],g=u.TmpVectors.KJ[3],A=u.TmpVectors.Quaternion[1];a.currentValue.decompose(g,A,J),g.scaleAndAddToRef(b,j),A.scaleAndAddToRef(u.Quaternion.Dot(E,A)>0?b:-b,E),J.scaleAndAddToRef(b,e)}E.normalize()}for(let K=0;K<i.additiveAnimations.length;K++){const x=i.additiveAnimations[K];if(0===x.weight)continue;const a=u.TmpVectors.KJ[2],Y=u.TmpVectors.KJ[3],J=u.TmpVectors.Quaternion[1];x.currentValue.decompose(Y,J,a),Y.multiplyToRef(j,Y),u.KJ.LerpToRef(j,Y,x.weight,j),E.multiplyToRef(J,J),u.Quaternion.SlerpToRef(E,J,x.weight,E),a.scaleAndAddToRef(x.weight,e)}const A=Y?Y._animationState.workValue:u.TmpVectors.Matrix[0].clone();return u.Matrix.ComposeToRef(j,E,e,A),A}function L(i,x){if(0===i.totalWeight&&0===i.totalAdditiveWeight)return x;const e=i.animations[0],j=i.originalValue;let E=x;if(0===i.totalWeight&&i.totalAdditiveWeight>0)E.A(j);else if(1===i.animations.length){if(u.Quaternion.SlerpToRef(j,e.currentValue,Math.min(1,i.totalWeight),E),0===i.totalAdditiveWeight)return E}else if(i.animations.length>1){let e,a,Y=1;if(i.totalWeight<1){const x=1-i.totalWeight;e=[],a=[],e.push(j),a.push(x)}else{if(2===i.animations.length&&(u.Quaternion.SlerpToRef(i.animations[0].currentValue,i.animations[1].currentValue,i.animations[1].weight/i.totalWeight,x),0===i.totalAdditiveWeight))return x;e=[],a=[],Y=i.totalWeight}for(let x=0;x<i.animations.length;x++){const j=i.animations[x];e.push(j.currentValue),a.push(j.weight/Y)}let J=0;for(let i=0;i<e.length;)i?(J+=a[i],u.Quaternion.SlerpToRef(E,e[i],a[i]/J,E),i++):(u.Quaternion.SlerpToRef(e[i],e[i+1],a[i+1]/(a[i]+a[i+1]),x),E=x,J=a[i]+a[i+1],i+=2)}for(let a=0;a<i.additiveAnimations.length;a++){const x=i.additiveAnimations[a];0!==x.weight&&(E.multiplyToRef(x.currentValue,u.TmpVectors.Quaternion[0]),u.Quaternion.SlerpToRef(E,u.TmpVectors.Quaternion[0],x.weight,E))}return E}var o,M,z=e(12452);o=z.d,(M=J.c)&&(M.prototype.copyAnimationRange=function(i,x,e){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new j.c(this.name,"_matrix",i.animations[0].framePerSecond,j.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Y=i.animations[0].getRange(x);if(!Y)return!1;const J=Y.from,u=Y.to,b=i.animations[0].getKeys(),g=i.length,A=i.getParent(),K=this.getParent(),L=E&&A&&g&&this.length&&g!==this.length,o=L&&K&&A?K.length/A.length:1,M=E&&!K&&a&&(1!==a.x||1!==a.y||1!==a.z),z=this.animations[0].getKeys();let T,Q,t;for(let j=0,V=b.length;j<V;j++)T=b[j],T.frame>=J&&T.frame<=u&&(E?(t=T.value.clone(),L?(Q=t.getTranslation(),t.setTranslation(Q.scaleInPlace(o))):M&&a?(Q=t.getTranslation(),t.setTranslation(Q.multiplyInPlace(a))):t=T.value):t=T.value,z.push({frame:T.frame+e,value:t}));return this.animations[0].createRange(x,J+e,u+e),!0}),o&&(o.prototype._animate=function(i){if(!this.animationsEnabled)return;const x=g.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=x}this.deltaTime=void 0!==i?i:this.useConstantAnimationDeltaTime?16:(x-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=x;const e=this._activeAnimatables;if(0===e.length)return;this._animationTime+=this.deltaTime;const E=this._animationTime;for(let j=0;j<e.length;j++){const i=e[j];!i._animate(E)&&i.disposeOnEnd&&j--}!function(i){if(i._registeredForLateAnimationBindings.length){for(let x=0;x<i._registeredForLateAnimationBindings.length;x++){const e=i._registeredForLateAnimationBindings.data[x];for(const i in e._lateAnimationHolders){const x=e._lateAnimationHolders[i],E=x.animations[0],a=x.originalValue;if(void 0===a||null===a)continue;const Y=j.c.AllowMatrixDecomposeForInterpolation&&a.m;let J=e[i];if(Y)J=K(x);else if(void 0!==a.w)J=L(x,J||u.Quaternion.Identity());else{let i=0,e=1;const Y=E&&E._animationState.loopMode===j.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(x.totalWeight<1)J=Y?a.clone?a.clone():a:E&&a.scale?a.scale(1-x.totalWeight):E?a*(1-x.totalWeight):a.clone?a.clone():a;else if(E){e=x.totalWeight;const j=E.weight/e;J=1!==j?E.currentValue.scale?E.currentValue.scale(j):E.currentValue*j:E.currentValue,Y&&(J.addToRef?J.addToRef(a,J):J+=a),i=1}for(let j=i;j<x.animations.length;j++){const i=x.animations[j],E=i.weight/e;E&&(i.currentValue.scaleAndAddToRef?i.currentValue.scaleAndAddToRef(E,J):J+=i.currentValue*E)}for(let j=0;j<x.additiveAnimations.length;j++){const i=x.additiveAnimations[j],e=i.weight;e&&(i.currentValue.scaleAndAddToRef?i.currentValue.scaleAndAddToRef(e,J):J+=i.currentValue*e)}}e[i]=J}e._lateAnimationHolders={}}i._registeredForLateAnimationBindings.reset()}}(this)},o.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((i,x)=>i.playOrder-x.playOrder))},o.prototype.beginWeightedAnimation=function(i,x,e){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,E=arguments.length>4?arguments[4]:void 0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7?arguments[7]:void 0,u=arguments.length>8?arguments[8]:void 0,b=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const A=this.beginAnimation(i,x,e,E,a,Y,J,!1,u,b,g);return A.weight=j,A},o.prototype.beginAnimation=function(i,x,e,j){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,a=arguments.length>5?arguments[5]:void 0,Y=arguments.length>6?arguments[6]:void 0,J=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],u=arguments.length>8?arguments[8]:void 0,b=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(E<0){const i=x;x=e,e=i,E=-E}x>e&&(E=-E),J&&this.stopAnimation(i,void 0,u),Y||(Y=new A(this,i,x,e,j,E,a,void 0,b,g));const K=!u||u(i);if(i.animations&&K&&Y.appendAnimations(i,i.animations),i.getAnimatables){const g=i.getAnimatables();for(let i=0;i<g.length;i++)this.beginAnimation(g[i],x,e,j,E,a,Y,J,u,b)}return Y.reset(),Y},o.prototype.beginHierarchyAnimation=function(i,x,e,j,E){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,J=arguments.length>7?arguments[7]:void 0,u=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],b=arguments.length>9?arguments[9]:void 0,g=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const A=i.getDescendants(x),K=[];K.push(this.beginAnimation(i,e,j,E,a,Y,J,u,b,void 0,g));for(const L of A)K.push(this.beginAnimation(L,e,j,E,a,Y,J,u,b,void 0,g));return K},o.prototype.beginDirectAnimation=function(i,x,e,j,E){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(a<0){const i=e;e=j,j=i,a=-a}return e>j&&(a=-a),new A(this,i,e,j,E,a,arguments.length>6?arguments[6]:void 0,x,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},o.prototype.beginDirectHierarchyAnimation=function(i,x,e,j,E,a,Y,J,u){let b=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const g=i.getDescendants(x),A=[];A.push(this.beginDirectAnimation(i,e,j,E,a,Y,J,u,b));for(const K of g)A.push(this.beginDirectAnimation(K,e,j,E,a,Y,J,u,b));return A},o.prototype.getAnimatableByTarget=function(i){for(let x=0;x<this._activeAnimatables.length;x++)if(this._activeAnimatables[x].target===i)return this._activeAnimatables[x];return null},o.prototype.getAllAnimatablesByTarget=function(i){const x=[];for(let e=0;e<this._activeAnimatables.length;e++)this._activeAnimatables[e].target===i&&x.push(this._activeAnimatables[e]);return x},o.prototype.stopAnimation=function(i,x,e){const j=this.getAllAnimatablesByTarget(i);for(const E of j)E.stop(x,e)},o.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let i=0;i<this._activeAnimatables.length;i++)this._activeAnimatables[i].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const i of this.animationGroups)i.stop()});class T{getClassName(){return"TargetedAnimation"}serialize(){const i={};return i.animation=this.animation.serialize(),i.targetId=this.target.id,i}}class Q{get mask(){return this._mask}set mask(i){this._mask!==i&&(this._mask=i,this.syncWithMask(!0))}syncWithMask(){let i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||i){this._numActiveAnimatables=0;for(let i=0;i<this._animatables.length;++i){const x=this._animatables[i];!this.mask||this.mask.disabled||this.mask.retainsTarget(x.target.name)?(this._numActiveAnimatables++,x.paused&&x.restart()):x.paused||x.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let i=0;i<this._animatables.length;++i){const x=this._animatables[i];this.mask.retainsTarget(x.target.name)||(x.stop(),this._animatables.splice(i,1),--i)}for(let i=0;i<this._targetedAnimations.length;i++){const x=this._targetedAnimations[i];this.mask.retainsTarget(x.target.name)||(this._targetedAnimations.splice(i,1),--i)}}}get from(){return this._from}set from(i){if(this._from!==i){this._from=i;for(let i=0;i<this._animatables.length;i++){this._animatables[i].fromFrame=this._from}}}get to(){return this._to}set to(i){if(this._to!==i){this._to=i;for(let i=0;i<this._animatables.length;i++){this._animatables[i].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(i){if(this._speedRatio!==i){this._speedRatio=i;for(let i=0;i<this._animatables.length;i++){this._animatables[i].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(i){if(this._loopAnimation!==i){this._loopAnimation=i;for(let i=0;i<this._animatables.length;i++){this._animatables[i].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(i){if(this._isAdditive!==i){this._isAdditive=i;for(let i=0;i<this._animatables.length;i++){this._animatables[i].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(i){this._weight!==i&&(this._weight=i,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(i){if(this._playOrder!==i&&(this._playOrder=i,this._animatables.length>0)){for(let i=0;i<this._animatables.length;i++)this._animatables[i].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(i){if(this._enableBlending!==i&&(this._enableBlending=i,null!==i))for(let x=0;x<this._targetedAnimations.length;++x)this._targetedAnimations[x].animation.enableBlending=i}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(i){if(this._blendingSpeed!==i&&(this._blendingSpeed=i,null!==i))for(let x=0;x<this._targetedAnimations.length;++x)this._targetedAnimations[x].animation.blendingSpeed=i}getLength(i,x){i=i??this._from;return((x=x??this._to)-i)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(i){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],e=arguments.length>2&&void 0!==arguments[2]&&arguments[2],j=arguments.length>3?arguments[3]:void 0;if(0===i.length)return null;j=j??i[0].weight;let E=Number.MAX_VALUE,a=-Number.MAX_VALUE;if(e)for(const J of i)J.from<E&&(E=J.from),J.to>a&&(a=J.to);const Y=new Q(i[0].name+"_merged",i[0]._scene,j);for(const J of i){e&&J.normalize(E,a);for(const i of J.targetedAnimations)Y.addTargetedAnimation(i.animation,i.target);x&&J.dispose()}return Y}constructor(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=i,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new E.b,this.onAnimationLoopObservable=new E.b,this.onAnimationGroupLoopObservable=new E.b,this.onAnimationGroupEndObservable=new E.b,this.onAnimationGroupPauseObservable=new E.b,this.onAnimationGroupPlayObservable=new E.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=x||a.e.LastCreatedScene,this._weight=e,this._playOrder=j,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(i,x){const e=new T;e.animation=i,e.target=x;const j=i.getKeys();return this._from>j[0].frame&&(this._from=j[0].frame),this._to<j[j.length-1].frame&&(this._to=j[j.length-1].frame),null!==this._enableBlending&&(i.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(i.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(e),this._shouldStart=!0,e}removeTargetedAnimation(i){for(let x=this._targetedAnimations.length-1;x>-1;x--){this._targetedAnimations[x].animation===i&&this._targetedAnimations.splice(x,1)}}normalize(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==i&&(i=this._from),null==x&&(x=this._to);for(let e=0;e<this._targetedAnimations.length;e++){const j=this._targetedAnimations[e].animation.getKeys(),E=j[0],a=j[j.length-1];if(E.frame>i){const x={frame:i,value:E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation};j.splice(0,0,x)}if(a.frame<x){const i={frame:x,value:a.value,inTangent:a.inTangent,outTangent:a.outTangent,interpolation:a.interpolation};j.push(i)}}return this._from=i,this._to=x,this}_processLoop(i,x,e){i.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(x),this._animationLoopFlags[e]||(this._animationLoopFlags[e]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let i=arguments.length>0&&void 0!==arguments[0]&&arguments[0],x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,e=arguments.length>2?arguments[2]:void 0,j=arguments.length>3?arguments[3]:void 0,E=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=i,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let a=0;a<this._targetedAnimations.length;a++){const Y=this._targetedAnimations[a],J=this._scene.beginDirectAnimation(Y.target,[Y.animation],void 0!==e?e:this._from,void 0!==j?j:this._to,i,x,void 0,void 0,void 0!==E?E:this._isAdditive);J.weight=this._weight,J.playOrder=this._playOrder,J.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Y),this._checkAnimationGroupEnded(J)},this._processLoop(J,Y,a),this._animatables.push(J)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=x,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let i=0;i<this._animatables.length;i++){this._animatables[i].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(i){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==i&&(this.loopAnimation=i),this.restart()):(this.stop(),this.start(i,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let i=0;i<this._animatables.length;i++){this._animatables[i].reset()}return this}restart(){if(!this._isStarted)return this;for(let i=0;i<this._animatables.length;i++){this._animatables[i].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const x=this._animatables.slice();for(let j=0;j<x.length;j++)x[j].stop(void 0,void 0,!0,i);let e=0;for(let j=0;j<this._scene._activeAnimatables.length;j++){const x=this._scene._activeAnimatables[j];x._runtimeAnimations.length>0?this._scene._activeAnimatables[e++]=x:i&&this._checkAnimationGroupEnded(x,i)}return this._scene._activeAnimatables.length=e,this._isStarted=!1,this}setWeightForAllAnimatables(i){for(let x=0;x<this._animatables.length;x++){this._animatables[x].weight=i}return this}syncAllAnimationsWith(i){for(let x=0;x<this._animatables.length;x++){this._animatables[x].syncWith(i)}return this}goToFrame(i){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let e=0;e<this._animatables.length;e++){this._animatables[e].goToFrame(i,x)}return this}getCurrentFrame(){var i;return(null===(i=this.animatables[0])||void 0===i?void 0:i.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const i=this._scene.animationGroups.indexOf(this);if(i>-1&&this._scene.animationGroups.splice(i,1),this._parentContainer){const i=this._parentContainer.animationGroups.indexOf(this);i>-1&&this._parentContainer.animationGroups.splice(i,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(i){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const e=this._animatables.indexOf(i);e>-1&&this._animatables.splice(e,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,x||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(i,x){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const j=new Q(i||this.name,this._scene,this._weight,this._playOrder);j._from=this.from,j._to=this.to,j._speedRatio=this.speedRatio,j._loopAnimation=this.loopAnimation,j._isAdditive=this.isAdditive,j._enableBlending=this.enableBlending,j._blendingSpeed=this.blendingSpeed,j.metadata=this.metadata,j.mask=this.mask;for(const E of this._targetedAnimations)j.addTargetedAnimation(e?E.animation.clone():E.animation,x?x(E.target):E.target);return j}serialize(){const i={};i.name=this.name,i.from=this.from,i.to=this.to,i.speedRatio=this.speedRatio,i.loopAnimation=this.loopAnimation,i.isAdditive=this.isAdditive,i.weight=this.weight,i.playOrder=this.playOrder,i.enableBlending=this.enableBlending,i.blendingSpeed=this.blendingSpeed,i.targetedAnimations=[];for(let x=0;x<this.targetedAnimations.length;x++){const e=this.targetedAnimations[x];i.targetedAnimations[x]=e.serialize()}return Y.c&&Y.c.HasTags(this)&&(i.tags=Y.c.GetTags(this)),this.metadata&&(i.metadata=this.metadata),i}static Parse(i,x){const e=new Q(i.name,x,i.weight,i.playOrder);for(let E=0;E<i.targetedAnimations.length;E++){const a=i.targetedAnimations[E],Y=j.c.Parse(a.animation),J=a.targetId;if("influence"===a.animation.property){const i=x.getMorphTargetById(J);i&&e.addTargetedAnimation(Y,i)}else{const i=x.getNodeById(J);null!=i&&e.addTargetedAnimation(Y,i)}}return Y.c&&Y.c.AddTagsTo(e,i.tags),null!==i.from&&null!==i.to&&e.normalize(i.from,i.to),void 0!==i.speedRatio&&(e._speedRatio=i.speedRatio),void 0!==i.loopAnimation&&(e._loopAnimation=i.loopAnimation),void 0!==i.isAdditive&&(e._isAdditive=i.isAdditive),void 0!==i.weight&&(e._weight=i.weight),void 0!==i.playOrder&&(e._playOrder=i.playOrder),void 0!==i.enableBlending&&(e._enableBlending=i.enableBlending),void 0!==i.blendingSpeed&&(e._blendingSpeed=i.blendingSpeed),void 0!==i.metadata&&(e.metadata=i.metadata),e}static MakeAnimationAdditive(i,x,e){let E;E="object"===typeof x?x:{referenceFrame:x,range:e,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let a=i;E.cloneOriginalAnimationGroup&&(a=i.clone(E.clonedAnimationGroupName||a.name));const Y=a.targetedAnimations;for(let J=0;J<Y.length;J++){const i=Y[J];i.animation=j.c.MakeAnimationAdditive(i.animation,E)}if(a.isAdditive=!0,E.clipKeys){let i=Number.MAX_VALUE,x=-Number.MAX_VALUE;const e=a.targetedAnimations;for(let j=0;j<e.length;j++){const E=e[j].animation.getKeys();i>E[0].frame&&(i=E[0].frame),x<E[E.length-1].frame&&(x=E[E.length-1].frame)}a._from=i,a._to=x}return a}static ClipKeys(i,x,e,j,E){const a=i.clone(j||i.name);return Q.ClipKeysInPlace(a,x,e,E)}static ClipKeysInPlace(i,x,e,j){return Q.ClipInPlace(i,x,e,j,!1)}static ClipFrames(i,x,e,j,E){const a=i.clone(j||i.name);return Q.ClipFramesInPlace(a,x,e,E)}static ClipFramesInPlace(i,x,e,j){return Q.ClipInPlace(i,x,e,j,!0)}static ClipInPlace(i,x,e,j){let E=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=Number.MAX_VALUE,Y=-Number.MAX_VALUE;const J=i.targetedAnimations;for(let u=0;u<J.length;u++){const i=J[u],b=j?i.animation:i.animation.clone();E&&(b.createKeyForFrame(x),b.createKeyForFrame(e));const g=b.getKeys(),A=[];let K=Number.MAX_VALUE;for(let j=0;j<g.length;j++){const i=g[j];if(!E&&j>=x&&j<=e||E&&i.frame>=x&&i.frame<=e){const x={frame:i.frame,value:i.value.clone?i.value.clone():i.value,inTangent:i.inTangent,outTangent:i.outTangent,interpolation:i.interpolation,lockedTangent:i.lockedTangent};K===Number.MAX_VALUE&&(K=x.frame),x.frame-=K,A.push(x)}}0!==A.length?(a>A[0].frame&&(a=A[0].frame),Y<A[A.length-1].frame&&(Y=A[A.length-1].frame),b.setKeys(A,!0),i.animation=b):(J.splice(u,1),u--)}return i._from=a,i._to=Y,i}getClassName(){return"AnimationGroup"}toString(i){let x="Name: "+this.name;return x+=", type: "+this.getClassName(),i&&(x+=", from: "+this._from,x+=", to: "+this._to,x+=", isStarted: "+this._isStarted,x+=", speedRatio: "+this._speedRatio,x+=", targetedAnimations length: "+this._targetedAnimations.length,x+=", animatables length: "+this._animatables),x}}}}]);