"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[78],{16046:(Y,b,C)=>{C.r(b),C.d(b,{AnimationGroup:()=>Q,TargetedAnimation:()=>w});var R=C(13351),q=C(12652),A=C(12702),E=C(12872),B=C(14341),g=C(12831);class r{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(Y,b,C,q){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=b,this._target=Y,this._scene=C,this._host=q,this._activeTargets=[],b._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===R.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=g.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const Y={frame:0,value:this._minValue};this._keys.splice(0,0,Y)}if(this._target instanceof Array){let Y=0;for(const b of this._target)this._preparePath(b,Y),this._getOriginalValues(Y),Y++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const A=b.getEvents();if(A&&A.length>0)for(const R of A)this._events.push(R._clone());this._enableBlending=Y&&Y.animationPropertiesOverride?Y.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this._animation.targetPropertyPath;if(C.length>1){let R=Y;for(let Y=0;Y<C.length-1;Y++){const b=C[Y];if(R=R[b],void 0===R)throw new Error(`Invalid property (${b}) in property path (${C.join(".")})`)}this._targetPath=C[C.length-1],this._activeTargets[b]=R}else this._targetPath=C[0],this._activeTargets[b]=Y;if(void 0===this._activeTargets[b][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${C.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let Y=0;for(const b of this._target)void 0!==this._originalValue[Y]&&this._setValue(b,this._activeTargets[Y],this._originalValue[Y],-1,Y),Y++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let Y=0;Y<this._events.length;Y++)this._events[Y].isDone=!1}isStopped(){return this._stopped}dispose(){const Y=this._animation.runtimeAnimations.indexOf(this);Y>-1&&this._animation.runtimeAnimations.splice(Y,1)}setValue(Y,b){if(this._targetIsArray)for(let C=0;C<this._target.length;C++){const R=this._target[C];this._setValue(R,this._activeTargets[C],Y,b,C)}else this._setValue(this._target,this._directTarget,Y,b,0)}_getOriginalValues(){let Y,b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const C=this._activeTargets[b];Y=C.getLocalMatrix&&"_matrix"===this._targetPath?C.getLocalMatrix():C[this._targetPath],Y&&Y.clone?this._originalValue[b]=Y.clone():this._originalValue[b]=Y}_registerTargetForLateAnimationBinding(Y,b){const C=Y.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(C),C._lateAnimationHolders||(C._lateAnimationHolders={}),C._lateAnimationHolders[Y.targetPath]||(C._lateAnimationHolders[Y.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:b}),Y.isAdditive?(C._lateAnimationHolders[Y.targetPath].additiveAnimations.push(Y),C._lateAnimationHolders[Y.targetPath].totalAdditiveWeight+=Y.weight):(C._lateAnimationHolders[Y.targetPath].animations.push(Y),C._lateAnimationHolders[Y.targetPath].totalWeight+=Y.weight)}_setValue(Y,b,C,q,A){if(this._currentActiveTarget=b,this._weight=q,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const Y=b[this._targetPath];Y.clone?this._originalBlendValue=Y.clone():this._originalBlendValue=Y}this._originalBlendValue.m?R.e.AllowMatrixDecomposeForInterpolation?this._currentValue?g.Matrix.DecomposeLerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=g.Matrix.DecomposeLerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue?g.Matrix.LerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=g.Matrix.Lerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue=R.e._UniversalLerp(this._originalBlendValue,C,this._blendingFactor);const q=Y&&Y.animationPropertiesOverride?Y.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=q}else this._currentValue?this._currentValue.q?this._currentValue.q(C):this._currentValue=C:null!==C&&void 0!==C&&C.clone?this._currentValue=C.clone():this._currentValue=C;-1!==q?this._registerTargetForLateAnimationBinding(this,this._originalValue[A]):this._animationState.loopMode===R.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[A],b[this._targetPath]):b[this._targetPath]=this._originalValue[A]+this._currentValue:b[this._targetPath]=this._currentValue,Y.JO&&Y.JO(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const C=this._animation.getKeys();Y<C[0].frame?Y=C[0].frame:Y>C[C.length-1].frame&&(Y=C[C.length-1].frame);const R=this._events;if(R.length)for(let A=0;A<R.length;A++)R[A].onlyOnce||(R[A].isDone=R[A].frame<Y);this._currentFrame=Y;const q=this._animation._interpolate(Y,this._animationState);this.setValue(q,b)}_prepareForSpeedRatioChange(Y){const b=this._previousElapsedTime*(this._animation.framePerSecond*Y)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-b}animate(Y,b,C,q,A){let E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const B=this._animation,g=B.targetPropertyPath;if(!g||g.length<1)return this._stopped=!0,!1;let r,O=!0;const F=this._events;let y=0;if(this._coreRuntimeAnimation)y=C-b,r=this._coreRuntimeAnimation.currentFrame,this._currentFrame=r,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let E;(b<this._minFrame||b>this._maxFrame)&&(b=this._minFrame),(C<this._minFrame||C>this._maxFrame)&&(C=this._maxFrame),y=C-b;let g=Y*(B.framePerSecond*A)/1e3+this._absoluteFrameOffset,S=0,n=!1;const t=q&&this._animationState.loopMode===R.e.ANIMATIONLOOPMODE_YOYO;if(t){const Y=(g-b)/y,C=Math.sin(Y*Math.PI);g=Math.abs(C)*y+b;const R=C>=0?1:-1;this._yoyoDirection!==R&&(n=!0),this._yoyoDirection=R}if(this._previousElapsedTime=Y,this._previousAbsoluteFrame=g,!q&&C>=b&&(g>=y&&A>0||g<=0&&A<0))O=!1,S=B._getKeyValue(this._maxValue);else if(!q&&b>=C&&(g<=y&&A<0||g>=0&&A>0))O=!1,S=B._getKeyValue(this._minValue);else if(this._animationState.loopMode!==R.e.ANIMATIONLOOPMODE_CYCLE){const Y=C.toString()+b.toString();if(!this._offsetsCache[Y]){this._animationState.repeatCount=0,this._animationState.loopMode=R.e.ANIMATIONLOOPMODE_CYCLE;const q=B._interpolate(b,this._animationState),A=B._interpolate(C,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),B.dataType){case R.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[Y]=A-q;break;case R.e.ANIMATIONTYPE_QUATERNION:case R.e.ANIMATIONTYPE_VECTOR3:case R.e.ANIMATIONTYPE_VECTOR2:case R.e.ANIMATIONTYPE_SIZE:case R.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[Y]=A.EC(q)}this._highLimitsCache[Y]=A}S=this._highLimitsCache[Y],E=this._offsetsCache[Y]}if(void 0===E)switch(B.dataType){case R.e.ANIMATIONTYPE_FLOAT:E=0;break;case R.e.ANIMATIONTYPE_QUATERNION:E=R.i;break;case R.e.ANIMATIONTYPE_VECTOR3:E=R.q;break;case R.e.ANIMATIONTYPE_VECTOR2:E=R.m;break;case R.e.ANIMATIONTYPE_SIZE:E=R.j;break;case R.e.ANIMATIONTYPE_COLOR3:E=R.g;break;case R.e.ANIMATIONTYPE_COLOR4:E=R.h}if(this._host&&this._host.syncRoot){const Y=this._host.syncRoot;r=b+y*((Y.masterFrame-Y.fromFrame)/(Y.toFrame-Y.fromFrame))}else r=g>0&&b>C||g<0&&b<C?O&&0!==y?C+g%y:b:O&&0!==y?b+g%y:C;if(!t&&(A>0&&this.currentFrame>r||A<0&&this.currentFrame<r)||t&&n){this._onLoop();for(let Y=0;Y<F.length;Y++)F[Y].onlyOnce||(F[Y].isDone=!1);this._animationState.key=A>0?0:B.getKeys().length-1}this._currentFrame=r,this._animationState.repeatCount=0===y?0:g/y|0,this._animationState.highLimitValue=S,this._animationState.offsetValue=E}const S=B._interpolate(r,this._animationState);if(this.setValue(S,E),F.length)for(let R=0;R<F.length;R++)if(y>=0&&r>=F[R].frame&&F[R].frame>=b||y<0&&r<=F[R].frame&&F[R].frame<=b){const Y=F[R];Y.isDone||(Y.onlyOnce&&(F.splice(R,1),R--),Y.isDone=!0,Y.action(r))}return O||(this._stopped=!0),O}}var O=C(12681);class F{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(Y){this._weight=-1!==Y?Math.min(Math.max(Y,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(Y){for(let b=0;b<this._runtimeAnimations.length;b++){this._runtimeAnimations[b]._prepareForSpeedRatioChange(Y)}this._speedRatio=Y,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(Y,b){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,A=arguments.length>4&&void 0!==arguments[4]&&arguments[4],E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,B=arguments.length>6?arguments[6]:void 0,g=arguments.length>7?arguments[7]:void 0,r=arguments.length>8?arguments[8]:void 0,O=arguments.length>9&&void 0!==arguments[9]&&arguments[9],F=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=b,this.fromFrame=C,this.toFrame=R,this.loopAnimation=A,this.onAnimationEnd=B,this.onAnimationLoop=r,this.isAdditive=O,this.playOrder=F,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.qg=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new q.d,this.onAnimationLoopObservable=new q.d,this._scene=Y,g&&this.appendAnimations(b,g),this._speedRatio=E,Y._activeAnimatables.push(this)}syncWith(Y){if(this._syncRoot=Y,Y){const Y=this._scene._activeAnimatables.indexOf(this);Y>-1&&(this._scene._activeAnimatables.splice(Y,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(Y,b){for(let C=0;C<b.length;C++){const R=b[C],q=new r(Y,R,this._scene,this);q._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(q)}}getAnimationByTargetProperty(Y){const b=this._runtimeAnimations;for(let C=0;C<b.length;C++)if(b[C].animation.targetProperty===Y)return b[C].animation;return null}getRuntimeAnimationByTargetProperty(Y){const b=this._runtimeAnimations;for(let C=0;C<b.length;C++)if(b[C].animation.targetProperty===Y)return b[C];return null}reset(){const Y=this._runtimeAnimations;for(let b=0;b<Y.length;b++)Y[b].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(Y){const b=this._runtimeAnimations;for(let C=0;C<b.length;C++)b[C].animation.enableBlending=!0,b[C].animation.blendingSpeed=Y}disableBlending(){const Y=this._runtimeAnimations;for(let b=0;b<Y.length;b++)Y[b].animation.enableBlending=!1}goToFrame(Y){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const C=this._runtimeAnimations;if(C[0]){const b=C[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??C[0].currentFrame;const R=0===this.speedRatio?0:(Y-this._frameToSyncFromJump)/b*1e3/this.speedRatio;this._manualJumpDelay=-R}for(let R=0;R<C.length;R++)C[R].goToFrame(Y,b?this._weight:-1);this._goToFrame=Y}get paused(){return this.qg}pause(){this.qg||(this.qg=!0)}restart(){this.qg=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(Y,b){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],R=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Y||b){const q=this._scene._activeAnimatables.indexOf(this);if(q>-1){const A=this._runtimeAnimations;for(let C=A.length-1;C>=0;C--){const R=A[C];Y&&R.animation.name!=Y||(b&&!b(R.target)||(R.dispose(),A.splice(C,1)))}0==A.length&&(C||this._scene._activeAnimatables.splice(q,1),R||this._raiseOnAnimationEnd())}}else{const Y=this._scene._activeAnimatables.indexOf(this);if(Y>-1){C||this._scene._activeAnimatables.splice(Y,1);const b=this._runtimeAnimations;for(let Y=0;Y<b.length;Y++)b[Y].dispose();this._runtimeAnimations.length=0,R||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((Y=>{this.onAnimationEndObservable.add((()=>{Y(this)}),void 0,void 0,this,!0)}))}_animate(Y){if(this.qg)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=Y),!0;if(null===this._localDelayOffset?(this._localDelayOffset=Y,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=Y-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let b=!1;const C=this._runtimeAnimations;let R;for(R=0;R<C.length;R++){const q=C[R].animate(Y-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);b=b||q}if(this.animationStarted=b,!b){if(this.disposeOnEnd)for(R=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(R,1),R=0;R<C.length;R++)C[R].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return b}}function y(Y){if(0===Y.totalWeight&&0===Y.totalAdditiveWeight)return Y.originalValue;let b=1;const C=g.TmpVectors.AC[0],R=g.TmpVectors.AC[1],q=g.TmpVectors.Quaternion[0];let A=0;const E=Y.animations[0],B=Y.originalValue;let r=1,O=!1;if(Y.totalWeight<1)r=1-Y.totalWeight,B.decompose(R,q,C);else{if(A=1,b=Y.totalWeight,r=E.weight/b,1==r){if(!Y.totalAdditiveWeight)return E.currentValue;O=!0}E.currentValue.decompose(R,q,C)}if(!O){R.scaleInPlace(r),C.scaleInPlace(r),q.scaleInPlace(r);for(let E=A;E<Y.animations.length;E++){const A=Y.animations[E];if(0===A.weight)continue;r=A.weight/b;const B=g.TmpVectors.AC[2],O=g.TmpVectors.AC[3],F=g.TmpVectors.Quaternion[1];A.currentValue.decompose(O,F,B),O.scaleAndAddToRef(r,R),F.scaleAndAddToRef(g.Quaternion.Dot(q,F)>0?r:-r,q),B.scaleAndAddToRef(r,C)}q.normalize()}for(let y=0;y<Y.additiveAnimations.length;y++){const b=Y.additiveAnimations[y];if(0===b.weight)continue;const A=g.TmpVectors.AC[2],E=g.TmpVectors.AC[3],B=g.TmpVectors.Quaternion[1];b.currentValue.decompose(E,B,A),E.multiplyToRef(R,E),g.AC.LerpToRef(R,E,b.weight,R),q.multiplyToRef(B,B),g.Quaternion.SlerpToRef(q,B,b.weight,q),A.scaleAndAddToRef(b.weight,C)}const F=E?E._animationState.workValue:g.TmpVectors.Matrix[0].clone();return g.Matrix.ComposeToRef(R,q,C,F),F}function S(Y,b){if(0===Y.totalWeight&&0===Y.totalAdditiveWeight)return b;const C=Y.animations[0],R=Y.originalValue;let q=b;if(0===Y.totalWeight&&Y.totalAdditiveWeight>0)q.q(R);else if(1===Y.animations.length){if(g.Quaternion.SlerpToRef(R,C.currentValue,Math.min(1,Y.totalWeight),q),0===Y.totalAdditiveWeight)return q}else if(Y.animations.length>1){let C,A,E=1;if(Y.totalWeight<1){const b=1-Y.totalWeight;C=[],A=[],C.push(R),A.push(b)}else{if(2===Y.animations.length&&(g.Quaternion.SlerpToRef(Y.animations[0].currentValue,Y.animations[1].currentValue,Y.animations[1].weight/Y.totalWeight,b),0===Y.totalAdditiveWeight))return b;C=[],A=[],E=Y.totalWeight}for(let b=0;b<Y.animations.length;b++){const R=Y.animations[b];C.push(R.currentValue),A.push(R.weight/E)}let B=0;for(let Y=0;Y<C.length;)Y?(B+=A[Y],g.Quaternion.SlerpToRef(q,C[Y],A[Y]/B,q),Y++):(g.Quaternion.SlerpToRef(C[Y],C[Y+1],A[Y+1]/(A[Y]+A[Y+1]),b),q=b,B=A[Y]+A[Y+1],Y+=2)}for(let A=0;A<Y.additiveAnimations.length;A++){const b=Y.additiveAnimations[A];0!==b.weight&&(q.multiplyToRef(b.currentValue,g.TmpVectors.Quaternion[0]),g.Quaternion.SlerpToRef(q,g.TmpVectors.Quaternion[0],b.weight,q))}return q}var n,t,I=C(13077);n=I.b,(t=B.d)&&(t.prototype.copyAnimationRange=function(Y,b,C){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new R.e(this.name,"_matrix",Y.animations[0].framePerSecond,R.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const E=Y.animations[0].getRange(b);if(!E)return!1;const B=E.from,g=E.to,r=Y.animations[0].getKeys(),O=Y.length,F=Y.getParent(),y=this.getParent(),S=q&&F&&O&&this.length&&O!==this.length,n=S&&y&&F?y.length/F.length:1,t=q&&!y&&A&&(1!==A.x||1!==A.y||1!==A.z),I=this.animations[0].getKeys();let w,Q,N;for(let R=0,p=r.length;R<p;R++)w=r[R],w.frame>=B&&w.frame<=g&&(q?(N=w.value.clone(),S?(Q=N.getTranslation(),N.setTranslation(Q.scaleInPlace(n))):t&&A?(Q=N.getTranslation(),N.setTranslation(Q.multiplyInPlace(A))):N=w.value):N=w.value,I.push({frame:w.frame+C,value:N}));return this.animations[0].createRange(b,B+C,g+C),!0}),n&&(n.prototype._animate=function(Y){if(!this.animationsEnabled)return;const b=O.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=b}this.deltaTime=void 0!==Y?Y:this.useConstantAnimationDeltaTime?16:(b-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=b;const C=this._activeAnimatables;if(0===C.length)return;this._animationTime+=this.deltaTime;const q=this._animationTime;for(let R=0;R<C.length;R++){const Y=C[R];!Y._animate(q)&&Y.disposeOnEnd&&R--}!function(Y){if(Y._registeredForLateAnimationBindings.length){for(let b=0;b<Y._registeredForLateAnimationBindings.length;b++){const C=Y._registeredForLateAnimationBindings.data[b];for(const Y in C._lateAnimationHolders){const b=C._lateAnimationHolders[Y],q=b.animations[0],A=b.originalValue;if(void 0===A||null===A)continue;const E=R.e.AllowMatrixDecomposeForInterpolation&&A.m;let B=C[Y];if(E)B=y(b);else if(void 0!==A.w)B=S(b,B||g.Quaternion.Identity());else{let Y=0,C=1;const E=q&&q._animationState.loopMode===R.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(b.totalWeight<1)B=E?A.clone?A.clone():A:q&&A.scale?A.scale(1-b.totalWeight):q?A*(1-b.totalWeight):A.clone?A.clone():A;else if(q){C=b.totalWeight;const R=q.weight/C;B=1!==R?q.currentValue.scale?q.currentValue.scale(R):q.currentValue*R:q.currentValue,E&&(B.addToRef?B.addToRef(A,B):B+=A),Y=1}for(let R=Y;R<b.animations.length;R++){const Y=b.animations[R],q=Y.weight/C;q&&(Y.currentValue.scaleAndAddToRef?Y.currentValue.scaleAndAddToRef(q,B):B+=Y.currentValue*q)}for(let R=0;R<b.additiveAnimations.length;R++){const Y=b.additiveAnimations[R],C=Y.weight;C&&(Y.currentValue.scaleAndAddToRef?Y.currentValue.scaleAndAddToRef(C,B):B+=Y.currentValue*C)}}C[Y]=B}C._lateAnimationHolders={}}Y._registeredForLateAnimationBindings.reset()}}(this)},n.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((Y,b)=>Y.playOrder-b.playOrder))},n.prototype.beginWeightedAnimation=function(Y,b,C){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,q=arguments.length>4?arguments[4]:void 0,A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,E=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0,g=arguments.length>8?arguments[8]:void 0,r=arguments.length>9?arguments[9]:void 0,O=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const F=this.beginAnimation(Y,b,C,q,A,E,B,!1,g,r,O);return F.weight=R,F},n.prototype.beginAnimation=function(Y,b,C,R){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,A=arguments.length>5?arguments[5]:void 0,E=arguments.length>6?arguments[6]:void 0,B=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],g=arguments.length>8?arguments[8]:void 0,r=arguments.length>9?arguments[9]:void 0,O=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(q<0){const Y=b;b=C,C=Y,q=-q}b>C&&(q=-q),B&&this.stopAnimation(Y,void 0,g),E||(E=new F(this,Y,b,C,R,q,A,void 0,r,O));const y=!g||g(Y);if(Y.animations&&y&&E.appendAnimations(Y,Y.animations),Y.getAnimatables){const O=Y.getAnimatables();for(let Y=0;Y<O.length;Y++)this.beginAnimation(O[Y],b,C,R,q,A,E,B,g,r)}return E.reset(),E},n.prototype.beginHierarchyAnimation=function(Y,b,C,R,q){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,E=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0,g=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],r=arguments.length>9?arguments[9]:void 0,O=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const F=Y.getDescendants(b),y=[];y.push(this.beginAnimation(Y,C,R,q,A,E,B,g,r,void 0,O));for(const S of F)y.push(this.beginAnimation(S,C,R,q,A,E,B,g,r,void 0,O));return y},n.prototype.beginDirectAnimation=function(Y,b,C,R,q){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(A<0){const Y=C;C=R,R=Y,A=-A}return C>R&&(A=-A),new F(this,Y,C,R,q,A,arguments.length>6?arguments[6]:void 0,b,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},n.prototype.beginDirectHierarchyAnimation=function(Y,b,C,R,q,A,E,B,g){let r=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const O=Y.getDescendants(b),F=[];F.push(this.beginDirectAnimation(Y,C,R,q,A,E,B,g,r));for(const y of O)F.push(this.beginDirectAnimation(y,C,R,q,A,E,B,g,r));return F},n.prototype.getAnimatableByTarget=function(Y){for(let b=0;b<this._activeAnimatables.length;b++)if(this._activeAnimatables[b].target===Y)return this._activeAnimatables[b];return null},n.prototype.getAllAnimatablesByTarget=function(Y){const b=[];for(let C=0;C<this._activeAnimatables.length;C++)this._activeAnimatables[C].target===Y&&b.push(this._activeAnimatables[C]);return b},n.prototype.stopAnimation=function(Y,b,C){const R=this.getAllAnimatablesByTarget(Y);for(const q of R)q.stop(b,C)},n.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let Y=0;Y<this._activeAnimatables.length;Y++)this._activeAnimatables[Y].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const Y of this.animationGroups)Y.stop()});class w{getClassName(){return"TargetedAnimation"}serialize(){const Y={};return Y.animation=this.animation.serialize(),Y.targetId=this.target.id,Y}}class Q{get mask(){return this._mask}set mask(Y){this._mask!==Y&&(this._mask=Y,this.syncWithMask(!0))}syncWithMask(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||Y){this._numActiveAnimatables=0;for(let Y=0;Y<this._animatables.length;++Y){const b=this._animatables[Y];!this.mask||this.mask.disabled||this.mask.retainsTarget(b.target.name)?(this._numActiveAnimatables++,b.paused&&b.restart()):b.paused||b.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let Y=0;Y<this._animatables.length;++Y){const b=this._animatables[Y];this.mask.retainsTarget(b.target.name)||(b.stop(),this._animatables.splice(Y,1),--Y)}for(let Y=0;Y<this._targetedAnimations.length;Y++){const b=this._targetedAnimations[Y];this.mask.retainsTarget(b.target.name)||(this._targetedAnimations.splice(Y,1),--Y)}}}get from(){return this._from}set from(Y){if(this._from!==Y){this._from=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].fromFrame=this._from}}}get to(){return this._to}set to(Y){if(this._to!==Y){this._to=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(Y){if(this._speedRatio!==Y){this._speedRatio=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(Y){if(this._loopAnimation!==Y){this._loopAnimation=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(Y){if(this._isAdditive!==Y){this._isAdditive=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(Y){this._weight!==Y&&(this._weight=Y,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(Y){if(this._playOrder!==Y&&(this._playOrder=Y,this._animatables.length>0)){for(let Y=0;Y<this._animatables.length;Y++)this._animatables[Y].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(Y){if(this._enableBlending!==Y&&(this._enableBlending=Y,null!==Y))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.enableBlending=Y}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(Y){if(this._blendingSpeed!==Y&&(this._blendingSpeed=Y,null!==Y))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.blendingSpeed=Y}getLength(Y,b){Y=Y??this._from;return((b=b??this._to)-Y)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(Y){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],R=arguments.length>3?arguments[3]:void 0;if(0===Y.length)return null;R=R??Y[0].weight;let q=Number.MAX_VALUE,A=-Number.MAX_VALUE;if(C)for(const B of Y)B.from<q&&(q=B.from),B.to>A&&(A=B.to);const E=new Q(Y[0].name+"_merged",Y[0]._scene,R);for(const B of Y){C&&B.normalize(q,A);for(const Y of B.targetedAnimations)E.addTargetedAnimation(Y.animation,Y.target);b&&B.dispose()}return E}constructor(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=Y,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new q.d,this.onAnimationLoopObservable=new q.d,this.onAnimationGroupLoopObservable=new q.d,this.onAnimationGroupEndObservable=new q.d,this.onAnimationGroupPauseObservable=new q.d,this.onAnimationGroupPlayObservable=new q.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=b||A.d.LastCreatedScene,this._weight=C,this._playOrder=R,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(Y,b){const C=new w;C.animation=Y,C.target=b;const R=Y.getKeys();return this._from>R[0].frame&&(this._from=R[0].frame),this._to<R[R.length-1].frame&&(this._to=R[R.length-1].frame),null!==this._enableBlending&&(Y.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(Y.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(C),this._shouldStart=!0,C}removeTargetedAnimation(Y){for(let b=this._targetedAnimations.length-1;b>-1;b--){this._targetedAnimations[b].animation===Y&&this._targetedAnimations.splice(b,1)}}normalize(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==Y&&(Y=this._from),null==b&&(b=this._to);for(let C=0;C<this._targetedAnimations.length;C++){const R=this._targetedAnimations[C].animation.getKeys(),q=R[0],A=R[R.length-1];if(q.frame>Y){const b={frame:Y,value:q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation};R.splice(0,0,b)}if(A.frame<b){const Y={frame:b,value:A.value,inTangent:A.inTangent,outTangent:A.outTangent,interpolation:A.interpolation};R.push(Y)}}return this._from=Y,this._to=b,this}_processLoop(Y,b,C){Y.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(b),this._animationLoopFlags[C]||(this._animationLoopFlags[C]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0],b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0,R=arguments.length>3?arguments[3]:void 0,q=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=Y,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let A=0;A<this._targetedAnimations.length;A++){const E=this._targetedAnimations[A],B=this._scene.beginDirectAnimation(E.target,[E.animation],void 0!==C?C:this._from,void 0!==R?R:this._to,Y,b,void 0,void 0,void 0!==q?q:this._isAdditive);B.weight=this._weight,B.playOrder=this._playOrder,B.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(E),this._checkAnimationGroupEnded(B)},this._processLoop(B,E,A),this._animatables.push(B)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=b,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(Y){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==Y&&(this.loopAnimation=Y),this.restart()):(this.stop(),this.start(Y,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].reset()}return this}restart(){if(!this._isStarted)return this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const b=this._animatables.slice();for(let R=0;R<b.length;R++)b[R].stop(void 0,void 0,!0,Y);let C=0;for(let R=0;R<this._scene._activeAnimatables.length;R++){const b=this._scene._activeAnimatables[R];b._runtimeAnimations.length>0?this._scene._activeAnimatables[C++]=b:Y&&this._checkAnimationGroupEnded(b,Y)}return this._scene._activeAnimatables.length=C,this._isStarted=!1,this}setWeightForAllAnimatables(Y){for(let b=0;b<this._animatables.length;b++){this._animatables[b].weight=Y}return this}syncAllAnimationsWith(Y){for(let b=0;b<this._animatables.length;b++){this._animatables[b].syncWith(Y)}return this}goToFrame(Y){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let C=0;C<this._animatables.length;C++){this._animatables[C].goToFrame(Y,b)}return this}getCurrentFrame(){var Y;return(null===(Y=this.animatables[0])||void 0===Y?void 0:Y.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const Y=this._scene.animationGroups.indexOf(this);if(Y>-1&&this._scene.animationGroups.splice(Y,1),this._parentContainer){const Y=this._parentContainer.animationGroups.indexOf(this);Y>-1&&this._parentContainer.animationGroups.splice(Y,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(Y){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const C=this._animatables.indexOf(Y);C>-1&&this._animatables.splice(C,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,b||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(Y,b){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const R=new Q(Y||this.name,this._scene,this._weight,this._playOrder);R._from=this.from,R._to=this.to,R._speedRatio=this.speedRatio,R._loopAnimation=this.loopAnimation,R._isAdditive=this.isAdditive,R._enableBlending=this.enableBlending,R._blendingSpeed=this.blendingSpeed,R.metadata=this.metadata,R.mask=this.mask;for(const q of this._targetedAnimations)R.addTargetedAnimation(C?q.animation.clone():q.animation,b?b(q.target):q.target);return R}serialize(){const Y={};Y.name=this.name,Y.from=this.from,Y.to=this.to,Y.speedRatio=this.speedRatio,Y.loopAnimation=this.loopAnimation,Y.isAdditive=this.isAdditive,Y.weight=this.weight,Y.playOrder=this.playOrder,Y.enableBlending=this.enableBlending,Y.blendingSpeed=this.blendingSpeed,Y.targetedAnimations=[];for(let b=0;b<this.targetedAnimations.length;b++){const C=this.targetedAnimations[b];Y.targetedAnimations[b]=C.serialize()}return E.d&&E.d.HasTags(this)&&(Y.tags=E.d.GetTags(this)),this.metadata&&(Y.metadata=this.metadata),Y}static Parse(Y,b){const C=new Q(Y.name,b,Y.weight,Y.playOrder);for(let q=0;q<Y.targetedAnimations.length;q++){const A=Y.targetedAnimations[q],E=R.e.Parse(A.animation),B=A.targetId;if("influence"===A.animation.property){const Y=b.getMorphTargetById(B);Y&&C.addTargetedAnimation(E,Y)}else{const Y=b.getNodeById(B);null!=Y&&C.addTargetedAnimation(E,Y)}}return E.d&&E.d.AddTagsTo(C,Y.tags),null!==Y.from&&null!==Y.to&&C.normalize(Y.from,Y.to),void 0!==Y.speedRatio&&(C._speedRatio=Y.speedRatio),void 0!==Y.loopAnimation&&(C._loopAnimation=Y.loopAnimation),void 0!==Y.isAdditive&&(C._isAdditive=Y.isAdditive),void 0!==Y.weight&&(C._weight=Y.weight),void 0!==Y.playOrder&&(C._playOrder=Y.playOrder),void 0!==Y.enableBlending&&(C._enableBlending=Y.enableBlending),void 0!==Y.blendingSpeed&&(C._blendingSpeed=Y.blendingSpeed),void 0!==Y.metadata&&(C.metadata=Y.metadata),C}static MakeAnimationAdditive(Y,b,C){let q;q="object"===typeof b?b:{referenceFrame:b,range:C,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let A=Y;q.cloneOriginalAnimationGroup&&(A=Y.clone(q.clonedAnimationGroupName||A.name));const E=A.targetedAnimations;for(let B=0;B<E.length;B++){const Y=E[B];Y.animation=R.e.MakeAnimationAdditive(Y.animation,q)}if(A.isAdditive=!0,q.clipKeys){let Y=Number.MAX_VALUE,b=-Number.MAX_VALUE;const C=A.targetedAnimations;for(let R=0;R<C.length;R++){const q=C[R].animation.getKeys();Y>q[0].frame&&(Y=q[0].frame),b<q[q.length-1].frame&&(b=q[q.length-1].frame)}A._from=Y,A._to=b}return A}static ClipKeys(Y,b,C,R,q){const A=Y.clone(R||Y.name);return Q.ClipKeysInPlace(A,b,C,q)}static ClipKeysInPlace(Y,b,C,R){return Q.ClipInPlace(Y,b,C,R,!1)}static ClipFrames(Y,b,C,R,q){const A=Y.clone(R||Y.name);return Q.ClipFramesInPlace(A,b,C,q)}static ClipFramesInPlace(Y,b,C,R){return Q.ClipInPlace(Y,b,C,R,!0)}static ClipInPlace(Y,b,C,R){let q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],A=Number.MAX_VALUE,E=-Number.MAX_VALUE;const B=Y.targetedAnimations;for(let g=0;g<B.length;g++){const Y=B[g],r=R?Y.animation:Y.animation.clone();q&&(r.createKeyForFrame(b),r.createKeyForFrame(C));const O=r.getKeys(),F=[];let y=Number.MAX_VALUE;for(let R=0;R<O.length;R++){const Y=O[R];if(!q&&R>=b&&R<=C||q&&Y.frame>=b&&Y.frame<=C){const b={frame:Y.frame,value:Y.value.clone?Y.value.clone():Y.value,inTangent:Y.inTangent,outTangent:Y.outTangent,interpolation:Y.interpolation,lockedTangent:Y.lockedTangent};y===Number.MAX_VALUE&&(y=b.frame),b.frame-=y,F.push(b)}}0!==F.length?(A>F[0].frame&&(A=F[0].frame),E<F[F.length-1].frame&&(E=F[F.length-1].frame),r.setKeys(F,!0),Y.animation=r):(B.splice(g,1),g--)}return Y._from=A,Y._to=E,Y}getClassName(){return"AnimationGroup"}toString(Y){let b="Name: "+this.name;return b+=", type: "+this.getClassName(),Y&&(b+=", from: "+this._from,b+=", to: "+this._to,b+=", isStarted: "+this._isStarted,b+=", speedRatio: "+this._speedRatio,b+=", targetedAnimations length: "+this._targetedAnimations.length,b+=", animatables length: "+this._animatables),b}}}}]);