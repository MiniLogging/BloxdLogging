"use strict";(self.h66iwo8dvgq=self.h66iwo8dvgq||[]).push([[78],{15121:(b,X,P)=>{P.r(X),P.d(X,{AnimationGroup:()=>W,TargetedAnimation:()=>B});var Q=P(12386),S=P(11694),d=P(11732),N=P(11870),a=P(13555),u=P(11834);class w{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(b,X,P,S){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=X,this._target=b,this._scene=P,this._host=S,this._activeTargets=[],X._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===Q.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=u.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const b={frame:0,value:this._minValue};this._keys.splice(0,0,b)}if(this._target instanceof Array){let b=0;for(const X of this._target)this._preparePath(X,b),this._getOriginalValues(b),b++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const d=X.getEvents();if(d&&d.length>0)for(const Q of d)this._events.push(Q._clone());this._enableBlending=b&&b.animationPropertiesOverride?b.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=this._animation.targetPropertyPath;if(P.length>1){let Q=b;for(let b=0;b<P.length-1;b++){const X=P[b];if(Q=Q[X],void 0===Q)throw new Error(`Invalid property (${X}) in property path (${P.join(".")})`)}this._targetPath=P[P.length-1],this._activeTargets[X]=Q}else this._targetPath=P[0],this._activeTargets[X]=b;if(void 0===this._activeTargets[X][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${P.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let b=0;for(const X of this._target)void 0!==this._originalValue[b]&&this._setValue(X,this._activeTargets[b],this._originalValue[b],-1,b),b++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let b=0;b<this._events.length;b++)this._events[b].isDone=!1}isStopped(){return this._stopped}dispose(){const b=this._animation.runtimeAnimations.indexOf(this);b>-1&&this._animation.runtimeAnimations.splice(b,1)}setValue(b,X){if(this._targetIsArray)for(let P=0;P<this._target.length;P++){const Q=this._target[P];this._setValue(Q,this._activeTargets[P],b,X,P)}else this._setValue(this._target,this._directTarget,b,X,0)}_getOriginalValues(){let b,X=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const P=this._activeTargets[X];b=P.getLocalMatrix&&"_matrix"===this._targetPath?P.getLocalMatrix():P[this._targetPath],b&&b.clone?this._originalValue[X]=b.clone():this._originalValue[X]=b}_registerTargetForLateAnimationBinding(b,X){const P=b.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(P),P._lateAnimationHolders||(P._lateAnimationHolders={}),P._lateAnimationHolders[b.targetPath]||(P._lateAnimationHolders[b.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:X}),b.isAdditive?(P._lateAnimationHolders[b.targetPath].additiveAnimations.push(b),P._lateAnimationHolders[b.targetPath].totalAdditiveWeight+=b.weight):(P._lateAnimationHolders[b.targetPath].animations.push(b),P._lateAnimationHolders[b.targetPath].totalWeight+=b.weight)}_setValue(b,X,P,S,d){if(this._currentActiveTarget=X,this._weight=S,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const b=X[this._targetPath];b.clone?this._originalBlendValue=b.clone():this._originalBlendValue=b}this._originalBlendValue.m?Q.c.AllowMatrixDecomposeForInterpolation?this._currentValue?u.Matrix.DecomposeLerpToRef(this._originalBlendValue,P,this._blendingFactor,this._currentValue):this._currentValue=u.Matrix.DecomposeLerp(this._originalBlendValue,P,this._blendingFactor):this._currentValue?u.Matrix.LerpToRef(this._originalBlendValue,P,this._blendingFactor,this._currentValue):this._currentValue=u.Matrix.Lerp(this._originalBlendValue,P,this._blendingFactor):this._currentValue=Q.c._UniversalLerp(this._originalBlendValue,P,this._blendingFactor);const S=b&&b.animationPropertiesOverride?b.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=S}else this._currentValue?this._currentValue.N?this._currentValue.N(P):this._currentValue=P:null!==P&&void 0!==P&&P.clone?this._currentValue=P.clone():this._currentValue=P;-1!==S?this._registerTargetForLateAnimationBinding(this,this._originalValue[d]):this._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[d],X[this._targetPath]):X[this._targetPath]=this._originalValue[d]+this._currentValue:X[this._targetPath]=this._currentValue,b.pw&&b.pw(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const P=this._animation.getKeys();b<P[0].frame?b=P[0].frame:b>P[P.length-1].frame&&(b=P[P.length-1].frame);const Q=this._events;if(Q.length)for(let d=0;d<Q.length;d++)Q[d].onlyOnce||(Q[d].isDone=Q[d].frame<b);this._currentFrame=b;const S=this._animation._interpolate(b,this._animationState);this.setValue(S,X)}_prepareForSpeedRatioChange(b){const X=this._previousElapsedTime*(this._animation.framePerSecond*b)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-X}animate(b,X,P,S,d){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const a=this._animation,u=a.targetPropertyPath;if(!u||u.length<1)return this._stopped=!0,!1;let w,f=!0;const O=this._events;let e=0;if(this._coreRuntimeAnimation)e=P-X,w=this._coreRuntimeAnimation.currentFrame,this._currentFrame=w,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let N;(X<this._minFrame||X>this._maxFrame)&&(X=this._minFrame),(P<this._minFrame||P>this._maxFrame)&&(P=this._maxFrame),e=P-X;let u=b*(a.framePerSecond*d)/1e3+this._absoluteFrameOffset,Y=0,D=!1;const E=S&&this._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_YOYO;if(E){const b=(u-X)/e,P=Math.sin(b*Math.PI);u=Math.abs(P)*e+X;const Q=P>=0?1:-1;this._yoyoDirection!==Q&&(D=!0),this._yoyoDirection=Q}if(this._previousElapsedTime=b,this._previousAbsoluteFrame=u,!S&&P>=X&&(u>=e&&d>0||u<=0&&d<0))f=!1,Y=a._getKeyValue(this._maxValue);else if(!S&&X>=P&&(u<=e&&d<0||u>=0&&d>0))f=!1,Y=a._getKeyValue(this._minValue);else if(this._animationState.loopMode!==Q.c.ANIMATIONLOOPMODE_CYCLE){const b=P.toString()+X.toString();if(!this._offsetsCache[b]){this._animationState.repeatCount=0,this._animationState.loopMode=Q.c.ANIMATIONLOOPMODE_CYCLE;const S=a._interpolate(X,this._animationState),d=a._interpolate(P,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),a.dataType){case Q.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[b]=d-S;break;case Q.c.ANIMATIONTYPE_QUATERNION:case Q.c.ANIMATIONTYPE_VECTOR3:case Q.c.ANIMATIONTYPE_VECTOR2:case Q.c.ANIMATIONTYPE_SIZE:case Q.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[b]=d.BX(S)}this._highLimitsCache[b]=d}Y=this._highLimitsCache[b],N=this._offsetsCache[b]}if(void 0===N)switch(a.dataType){case Q.c.ANIMATIONTYPE_FLOAT:N=0;break;case Q.c.ANIMATIONTYPE_QUATERNION:N=Q.h;break;case Q.c.ANIMATIONTYPE_VECTOR3:N=Q.r;break;case Q.c.ANIMATIONTYPE_VECTOR2:N=Q.n;break;case Q.c.ANIMATIONTYPE_SIZE:N=Q.k;break;case Q.c.ANIMATIONTYPE_COLOR3:N=Q.e;break;case Q.c.ANIMATIONTYPE_COLOR4:N=Q.f}if(this._host&&this._host.syncRoot){const b=this._host.syncRoot;w=X+e*((b.masterFrame-b.fromFrame)/(b.toFrame-b.fromFrame))}else w=u>0&&X>P||u<0&&X<P?f&&0!==e?P+u%e:X:f&&0!==e?X+u%e:P;if(!E&&(d>0&&this.currentFrame>w||d<0&&this.currentFrame<w)||E&&D){this._onLoop();for(let b=0;b<O.length;b++)O[b].onlyOnce||(O[b].isDone=!1);this._animationState.key=d>0?0:a.getKeys().length-1}this._currentFrame=w,this._animationState.repeatCount=0===e?0:u/e|0,this._animationState.highLimitValue=Y,this._animationState.offsetValue=N}const Y=a._interpolate(w,this._animationState);if(this.setValue(Y,N),O.length)for(let Q=0;Q<O.length;Q++)if(e>=0&&w>=O[Q].frame&&O[Q].frame>=X||e<0&&w<=O[Q].frame&&O[Q].frame<=X){const b=O[Q];b.isDone||(b.onlyOnce&&(O.splice(Q,1),Q--),b.isDone=!0,b.action(w))}return f||(this._stopped=!0),f}}var f=P(11713);class O{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(b){this._weight=-1!==b?Math.min(Math.max(b,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(b){for(let X=0;X<this._runtimeAnimations.length;X++){this._runtimeAnimations[X]._prepareForSpeedRatioChange(b)}this._speedRatio=b,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(b,X){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,d=arguments.length>4&&void 0!==arguments[4]&&arguments[4],N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,a=arguments.length>6?arguments[6]:void 0,u=arguments.length>7?arguments[7]:void 0,w=arguments.length>8?arguments[8]:void 0,f=arguments.length>9&&void 0!==arguments[9]&&arguments[9],O=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=X,this.fromFrame=P,this.toFrame=Q,this.loopAnimation=d,this.onAnimationEnd=a,this.onAnimationLoop=w,this.isAdditive=f,this.playOrder=O,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Ya=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new S.d,this.onAnimationLoopObservable=new S.d,this._scene=b,u&&this.appendAnimations(X,u),this._speedRatio=N,b._activeAnimatables.push(this)}syncWith(b){if(this._syncRoot=b,b){const b=this._scene._activeAnimatables.indexOf(this);b>-1&&(this._scene._activeAnimatables.splice(b,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(b,X){for(let P=0;P<X.length;P++){const Q=X[P],S=new w(b,Q,this._scene,this);S._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(S)}}getAnimationByTargetProperty(b){const X=this._runtimeAnimations;for(let P=0;P<X.length;P++)if(X[P].animation.targetProperty===b)return X[P].animation;return null}getRuntimeAnimationByTargetProperty(b){const X=this._runtimeAnimations;for(let P=0;P<X.length;P++)if(X[P].animation.targetProperty===b)return X[P];return null}reset(){const b=this._runtimeAnimations;for(let X=0;X<b.length;X++)b[X].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(b){const X=this._runtimeAnimations;for(let P=0;P<X.length;P++)X[P].animation.enableBlending=!0,X[P].animation.blendingSpeed=b}disableBlending(){const b=this._runtimeAnimations;for(let X=0;X<b.length;X++)b[X].animation.enableBlending=!1}goToFrame(b){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const P=this._runtimeAnimations;if(P[0]){const X=P[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??P[0].currentFrame;const Q=0===this.speedRatio?0:(b-this._frameToSyncFromJump)/X*1e3/this.speedRatio;this._manualJumpDelay=-Q}for(let Q=0;Q<P.length;Q++)P[Q].goToFrame(b,X?this._weight:-1);this._goToFrame=b}get paused(){return this.Ya}pause(){this.Ya||(this.Ya=!0)}restart(){this.Ya=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(b,X){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(b||X){const S=this._scene._activeAnimatables.indexOf(this);if(S>-1){const d=this._runtimeAnimations;for(let P=d.length-1;P>=0;P--){const Q=d[P];b&&Q.animation.name!=b||(X&&!X(Q.target)||(Q.dispose(),d.splice(P,1)))}0==d.length&&(P||this._scene._activeAnimatables.splice(S,1),Q||this._raiseOnAnimationEnd())}}else{const b=this._scene._activeAnimatables.indexOf(this);if(b>-1){P||this._scene._activeAnimatables.splice(b,1);const X=this._runtimeAnimations;for(let b=0;b<X.length;b++)X[b].dispose();this._runtimeAnimations.length=0,Q||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((b=>{this.onAnimationEndObservable.add((()=>{b(this)}),void 0,void 0,this,!0)}))}_animate(b){if(this.Ya)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=b),!0;if(null===this._localDelayOffset?(this._localDelayOffset=b,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=b-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let X=!1;const P=this._runtimeAnimations;let Q;for(Q=0;Q<P.length;Q++){const S=P[Q].animate(b-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);X=X||S}if(this.animationStarted=X,!X){if(this.disposeOnEnd)for(Q=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(Q,1),Q=0;Q<P.length;Q++)P[Q].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return X}}function e(b){if(0===b.totalWeight&&0===b.totalAdditiveWeight)return b.originalValue;let X=1;const P=u.TmpVectors.tX[0],Q=u.TmpVectors.tX[1],S=u.TmpVectors.Quaternion[0];let d=0;const N=b.animations[0],a=b.originalValue;let w=1,f=!1;if(b.totalWeight<1)w=1-b.totalWeight,a.decompose(Q,S,P);else{if(d=1,X=b.totalWeight,w=N.weight/X,1==w){if(!b.totalAdditiveWeight)return N.currentValue;f=!0}N.currentValue.decompose(Q,S,P)}if(!f){Q.scaleInPlace(w),P.scaleInPlace(w),S.scaleInPlace(w);for(let N=d;N<b.animations.length;N++){const d=b.animations[N];if(0===d.weight)continue;w=d.weight/X;const a=u.TmpVectors.tX[2],f=u.TmpVectors.tX[3],O=u.TmpVectors.Quaternion[1];d.currentValue.decompose(f,O,a),f.scaleAndAddToRef(w,Q),O.scaleAndAddToRef(u.Quaternion.Dot(S,O)>0?w:-w,S),a.scaleAndAddToRef(w,P)}S.normalize()}for(let e=0;e<b.additiveAnimations.length;e++){const X=b.additiveAnimations[e];if(0===X.weight)continue;const d=u.TmpVectors.tX[2],N=u.TmpVectors.tX[3],a=u.TmpVectors.Quaternion[1];X.currentValue.decompose(N,a,d),N.multiplyToRef(Q,N),u.tX.LerpToRef(Q,N,X.weight,Q),S.multiplyToRef(a,a),u.Quaternion.SlerpToRef(S,a,X.weight,S),d.scaleAndAddToRef(X.weight,P)}const O=N?N._animationState.workValue:u.TmpVectors.Matrix[0].clone();return u.Matrix.ComposeToRef(Q,S,P,O),O}function Y(b,X){if(0===b.totalWeight&&0===b.totalAdditiveWeight)return X;const P=b.animations[0],Q=b.originalValue;let S=X;if(0===b.totalWeight&&b.totalAdditiveWeight>0)S.N(Q);else if(1===b.animations.length){if(u.Quaternion.SlerpToRef(Q,P.currentValue,Math.min(1,b.totalWeight),S),0===b.totalAdditiveWeight)return S}else if(b.animations.length>1){let P,d,N=1;if(b.totalWeight<1){const X=1-b.totalWeight;P=[],d=[],P.push(Q),d.push(X)}else{if(2===b.animations.length&&(u.Quaternion.SlerpToRef(b.animations[0].currentValue,b.animations[1].currentValue,b.animations[1].weight/b.totalWeight,X),0===b.totalAdditiveWeight))return X;P=[],d=[],N=b.totalWeight}for(let X=0;X<b.animations.length;X++){const Q=b.animations[X];P.push(Q.currentValue),d.push(Q.weight/N)}let a=0;for(let b=0;b<P.length;)b?(a+=d[b],u.Quaternion.SlerpToRef(S,P[b],d[b]/a,S),b++):(u.Quaternion.SlerpToRef(P[b],P[b+1],d[b+1]/(d[b]+d[b+1]),X),S=X,a=d[b]+d[b+1],b+=2)}for(let d=0;d<b.additiveAnimations.length;d++){const X=b.additiveAnimations[d];0!==X.weight&&(S.multiplyToRef(X.currentValue,u.TmpVectors.Quaternion[0]),u.Quaternion.SlerpToRef(S,u.TmpVectors.Quaternion[0],X.weight,S))}return S}var D,E,t=P(12093);D=t.e,(E=a.d)&&(E.prototype.copyAnimationRange=function(b,X,P){let S=arguments.length>3&&void 0!==arguments[3]&&arguments[3],d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new Q.c(this.name,"_matrix",b.animations[0].framePerSecond,Q.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const N=b.animations[0].getRange(X);if(!N)return!1;const a=N.from,u=N.to,w=b.animations[0].getKeys(),f=b.length,O=b.getParent(),e=this.getParent(),Y=S&&O&&f&&this.length&&f!==this.length,D=Y&&e&&O?e.length/O.length:1,E=S&&!e&&d&&(1!==d.x||1!==d.y||1!==d.z),t=this.animations[0].getKeys();let B,W,n;for(let Q=0,y=w.length;Q<y;Q++)B=w[Q],B.frame>=a&&B.frame<=u&&(S?(n=B.value.clone(),Y?(W=n.getTranslation(),n.setTranslation(W.scaleInPlace(D))):E&&d?(W=n.getTranslation(),n.setTranslation(W.multiplyInPlace(d))):n=B.value):n=B.value,t.push({frame:B.frame+P,value:n}));return this.animations[0].createRange(X,a+P,u+P),!0}),D&&(D.prototype._animate=function(b){if(!this.animationsEnabled)return;const X=f.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=X}this.deltaTime=void 0!==b?b:this.useConstantAnimationDeltaTime?16:(X-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=X;const P=this._activeAnimatables;if(0===P.length)return;this._animationTime+=this.deltaTime;const S=this._animationTime;for(let Q=0;Q<P.length;Q++){const b=P[Q];!b._animate(S)&&b.disposeOnEnd&&Q--}!function(b){if(b._registeredForLateAnimationBindings.length){for(let X=0;X<b._registeredForLateAnimationBindings.length;X++){const P=b._registeredForLateAnimationBindings.data[X];for(const b in P._lateAnimationHolders){const X=P._lateAnimationHolders[b],S=X.animations[0],d=X.originalValue;if(void 0===d||null===d)continue;const N=Q.c.AllowMatrixDecomposeForInterpolation&&d.m;let a=P[b];if(N)a=e(X);else if(void 0!==d.w)a=Y(X,a||u.Quaternion.Identity());else{let b=0,P=1;const N=S&&S._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(X.totalWeight<1)a=N?d.clone?d.clone():d:S&&d.scale?d.scale(1-X.totalWeight):S?d*(1-X.totalWeight):d.clone?d.clone():d;else if(S){P=X.totalWeight;const Q=S.weight/P;a=1!==Q?S.currentValue.scale?S.currentValue.scale(Q):S.currentValue*Q:S.currentValue,N&&(a.addToRef?a.addToRef(d,a):a+=d),b=1}for(let Q=b;Q<X.animations.length;Q++){const b=X.animations[Q],S=b.weight/P;S&&(b.currentValue.scaleAndAddToRef?b.currentValue.scaleAndAddToRef(S,a):a+=b.currentValue*S)}for(let Q=0;Q<X.additiveAnimations.length;Q++){const b=X.additiveAnimations[Q],P=b.weight;P&&(b.currentValue.scaleAndAddToRef?b.currentValue.scaleAndAddToRef(P,a):a+=b.currentValue*P)}}P[b]=a}P._lateAnimationHolders={}}b._registeredForLateAnimationBindings.reset()}}(this)},D.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((b,X)=>b.playOrder-X.playOrder))},D.prototype.beginWeightedAnimation=function(b,X,P){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,S=arguments.length>4?arguments[4]:void 0,d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,N=arguments.length>6?arguments[6]:void 0,a=arguments.length>7?arguments[7]:void 0,u=arguments.length>8?arguments[8]:void 0,w=arguments.length>9?arguments[9]:void 0,f=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const O=this.beginAnimation(b,X,P,S,d,N,a,!1,u,w,f);return O.weight=Q,O},D.prototype.beginAnimation=function(b,X,P,Q){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,d=arguments.length>5?arguments[5]:void 0,N=arguments.length>6?arguments[6]:void 0,a=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],u=arguments.length>8?arguments[8]:void 0,w=arguments.length>9?arguments[9]:void 0,f=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(S<0){const b=X;X=P,P=b,S=-S}X>P&&(S=-S),a&&this.stopAnimation(b,void 0,u),N||(N=new O(this,b,X,P,Q,S,d,void 0,w,f));const e=!u||u(b);if(b.animations&&e&&N.appendAnimations(b,b.animations),b.getAnimatables){const f=b.getAnimatables();for(let b=0;b<f.length;b++)this.beginAnimation(f[b],X,P,Q,S,d,N,a,u,w)}return N.reset(),N},D.prototype.beginHierarchyAnimation=function(b,X,P,Q,S){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,N=arguments.length>6?arguments[6]:void 0,a=arguments.length>7?arguments[7]:void 0,u=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],w=arguments.length>9?arguments[9]:void 0,f=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const O=b.getDescendants(X),e=[];e.push(this.beginAnimation(b,P,Q,S,d,N,a,u,w,void 0,f));for(const Y of O)e.push(this.beginAnimation(Y,P,Q,S,d,N,a,u,w,void 0,f));return e},D.prototype.beginDirectAnimation=function(b,X,P,Q,S){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(d<0){const b=P;P=Q,Q=b,d=-d}return P>Q&&(d=-d),new O(this,b,P,Q,S,d,arguments.length>6?arguments[6]:void 0,X,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},D.prototype.beginDirectHierarchyAnimation=function(b,X,P,Q,S,d,N,a,u){let w=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const f=b.getDescendants(X),O=[];O.push(this.beginDirectAnimation(b,P,Q,S,d,N,a,u,w));for(const e of f)O.push(this.beginDirectAnimation(e,P,Q,S,d,N,a,u,w));return O},D.prototype.getAnimatableByTarget=function(b){for(let X=0;X<this._activeAnimatables.length;X++)if(this._activeAnimatables[X].target===b)return this._activeAnimatables[X];return null},D.prototype.getAllAnimatablesByTarget=function(b){const X=[];for(let P=0;P<this._activeAnimatables.length;P++)this._activeAnimatables[P].target===b&&X.push(this._activeAnimatables[P]);return X},D.prototype.stopAnimation=function(b,X,P){const Q=this.getAllAnimatablesByTarget(b);for(const S of Q)S.stop(X,P)},D.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let b=0;b<this._activeAnimatables.length;b++)this._activeAnimatables[b].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const b of this.animationGroups)b.stop()});class B{getClassName(){return"TargetedAnimation"}serialize(){const b={};return b.animation=this.animation.serialize(),b.targetId=this.target.id,b}}class W{get mask(){return this._mask}set mask(b){this._mask!==b&&(this._mask=b,this.syncWithMask(!0))}syncWithMask(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||b){this._numActiveAnimatables=0;for(let b=0;b<this._animatables.length;++b){const X=this._animatables[b];!this.mask||this.mask.disabled||this.mask.retainsTarget(X.target.name)?(this._numActiveAnimatables++,X.paused&&X.restart()):X.paused||X.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let b=0;b<this._animatables.length;++b){const X=this._animatables[b];this.mask.retainsTarget(X.target.name)||(X.stop(),this._animatables.splice(b,1),--b)}for(let b=0;b<this._targetedAnimations.length;b++){const X=this._targetedAnimations[b];this.mask.retainsTarget(X.target.name)||(this._targetedAnimations.splice(b,1),--b)}}}get from(){return this._from}set from(b){if(this._from!==b){this._from=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].fromFrame=this._from}}}get to(){return this._to}set to(b){if(this._to!==b){this._to=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(b){if(this._speedRatio!==b){this._speedRatio=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(b){if(this._loopAnimation!==b){this._loopAnimation=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(b){if(this._isAdditive!==b){this._isAdditive=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(b){this._weight!==b&&(this._weight=b,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(b){if(this._playOrder!==b&&(this._playOrder=b,this._animatables.length>0)){for(let b=0;b<this._animatables.length;b++)this._animatables[b].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(b){if(this._enableBlending!==b&&(this._enableBlending=b,null!==b))for(let X=0;X<this._targetedAnimations.length;++X)this._targetedAnimations[X].animation.enableBlending=b}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(b){if(this._blendingSpeed!==b&&(this._blendingSpeed=b,null!==b))for(let X=0;X<this._targetedAnimations.length;++X)this._targetedAnimations[X].animation.blendingSpeed=b}getLength(b,X){b=b??this._from;return((X=X??this._to)-b)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(b){let X=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=arguments.length>3?arguments[3]:void 0;if(0===b.length)return null;Q=Q??b[0].weight;let S=Number.MAX_VALUE,d=-Number.MAX_VALUE;if(P)for(const a of b)a.from<S&&(S=a.from),a.to>d&&(d=a.to);const N=new W(b[0].name+"_merged",b[0]._scene,Q);for(const a of b){P&&a.normalize(S,d);for(const b of a.targetedAnimations)N.addTargetedAnimation(b.animation,b.target);X&&a.dispose()}return N}constructor(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=b,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new S.d,this.onAnimationLoopObservable=new S.d,this.onAnimationGroupLoopObservable=new S.d,this.onAnimationGroupEndObservable=new S.d,this.onAnimationGroupPauseObservable=new S.d,this.onAnimationGroupPlayObservable=new S.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=X||d.e.LastCreatedScene,this._weight=P,this._playOrder=Q,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(b,X){const P=new B;P.animation=b,P.target=X;const Q=b.getKeys();return this._from>Q[0].frame&&(this._from=Q[0].frame),this._to<Q[Q.length-1].frame&&(this._to=Q[Q.length-1].frame),null!==this._enableBlending&&(b.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(b.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(P),this._shouldStart=!0,P}removeTargetedAnimation(b){for(let X=this._targetedAnimations.length-1;X>-1;X--){this._targetedAnimations[X].animation===b&&this._targetedAnimations.splice(X,1)}}normalize(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==b&&(b=this._from),null==X&&(X=this._to);for(let P=0;P<this._targetedAnimations.length;P++){const Q=this._targetedAnimations[P].animation.getKeys(),S=Q[0],d=Q[Q.length-1];if(S.frame>b){const X={frame:b,value:S.value,inTangent:S.inTangent,outTangent:S.outTangent,interpolation:S.interpolation};Q.splice(0,0,X)}if(d.frame<X){const b={frame:X,value:d.value,inTangent:d.inTangent,outTangent:d.outTangent,interpolation:d.interpolation};Q.push(b)}}return this._from=b,this._to=X,this}_processLoop(b,X,P){b.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(X),this._animationLoopFlags[P]||(this._animationLoopFlags[P]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0],X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0,Q=arguments.length>3?arguments[3]:void 0,S=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=b,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let d=0;d<this._targetedAnimations.length;d++){const N=this._targetedAnimations[d],a=this._scene.beginDirectAnimation(N.target,[N.animation],void 0!==P?P:this._from,void 0!==Q?Q:this._to,b,X,void 0,void 0,void 0!==S?S:this._isAdditive);a.weight=this._weight,a.playOrder=this._playOrder,a.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(N),this._checkAnimationGroupEnded(a)},this._processLoop(a,N,d),this._animatables.push(a)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=X,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let b=0;b<this._animatables.length;b++){this._animatables[b].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(b){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==b&&(this.loopAnimation=b),this.restart()):(this.stop(),this.start(b,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].reset()}return this}restart(){if(!this._isStarted)return this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const X=this._animatables.slice();for(let Q=0;Q<X.length;Q++)X[Q].stop(void 0,void 0,!0,b);let P=0;for(let Q=0;Q<this._scene._activeAnimatables.length;Q++){const X=this._scene._activeAnimatables[Q];X._runtimeAnimations.length>0?this._scene._activeAnimatables[P++]=X:b&&this._checkAnimationGroupEnded(X,b)}return this._scene._activeAnimatables.length=P,this._isStarted=!1,this}setWeightForAllAnimatables(b){for(let X=0;X<this._animatables.length;X++){this._animatables[X].weight=b}return this}syncAllAnimationsWith(b){for(let X=0;X<this._animatables.length;X++){this._animatables[X].syncWith(b)}return this}goToFrame(b){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let P=0;P<this._animatables.length;P++){this._animatables[P].goToFrame(b,X)}return this}getCurrentFrame(){var b;return(null===(b=this.animatables[0])||void 0===b?void 0:b.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const b=this._scene.animationGroups.indexOf(this);if(b>-1&&this._scene.animationGroups.splice(b,1),this._parentContainer){const b=this._parentContainer.animationGroups.indexOf(this);b>-1&&this._parentContainer.animationGroups.splice(b,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(b){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const P=this._animatables.indexOf(b);P>-1&&this._animatables.splice(P,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,X||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(b,X){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=new W(b||this.name,this._scene,this._weight,this._playOrder);Q._from=this.from,Q._to=this.to,Q._speedRatio=this.speedRatio,Q._loopAnimation=this.loopAnimation,Q._isAdditive=this.isAdditive,Q._enableBlending=this.enableBlending,Q._blendingSpeed=this.blendingSpeed,Q.metadata=this.metadata,Q.mask=this.mask;for(const S of this._targetedAnimations)Q.addTargetedAnimation(P?S.animation.clone():S.animation,X?X(S.target):S.target);return Q}serialize(){const b={};b.name=this.name,b.from=this.from,b.to=this.to,b.speedRatio=this.speedRatio,b.loopAnimation=this.loopAnimation,b.isAdditive=this.isAdditive,b.weight=this.weight,b.playOrder=this.playOrder,b.enableBlending=this.enableBlending,b.blendingSpeed=this.blendingSpeed,b.targetedAnimations=[];for(let X=0;X<this.targetedAnimations.length;X++){const P=this.targetedAnimations[X];b.targetedAnimations[X]=P.serialize()}return N.d&&N.d.HasTags(this)&&(b.tags=N.d.GetTags(this)),this.metadata&&(b.metadata=this.metadata),b}static Parse(b,X){const P=new W(b.name,X,b.weight,b.playOrder);for(let S=0;S<b.targetedAnimations.length;S++){const d=b.targetedAnimations[S],N=Q.c.Parse(d.animation),a=d.targetId;if("influence"===d.animation.property){const b=X.getMorphTargetById(a);b&&P.addTargetedAnimation(N,b)}else{const b=X.getNodeById(a);null!=b&&P.addTargetedAnimation(N,b)}}return N.d&&N.d.AddTagsTo(P,b.tags),null!==b.from&&null!==b.to&&P.normalize(b.from,b.to),void 0!==b.speedRatio&&(P._speedRatio=b.speedRatio),void 0!==b.loopAnimation&&(P._loopAnimation=b.loopAnimation),void 0!==b.isAdditive&&(P._isAdditive=b.isAdditive),void 0!==b.weight&&(P._weight=b.weight),void 0!==b.playOrder&&(P._playOrder=b.playOrder),void 0!==b.enableBlending&&(P._enableBlending=b.enableBlending),void 0!==b.blendingSpeed&&(P._blendingSpeed=b.blendingSpeed),void 0!==b.metadata&&(P.metadata=b.metadata),P}static MakeAnimationAdditive(b,X,P){let S;S="object"===typeof X?X:{referenceFrame:X,range:P,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let d=b;S.cloneOriginalAnimationGroup&&(d=b.clone(S.clonedAnimationGroupName||d.name));const N=d.targetedAnimations;for(let a=0;a<N.length;a++){const b=N[a];b.animation=Q.c.MakeAnimationAdditive(b.animation,S)}if(d.isAdditive=!0,S.clipKeys){let b=Number.MAX_VALUE,X=-Number.MAX_VALUE;const P=d.targetedAnimations;for(let Q=0;Q<P.length;Q++){const S=P[Q].animation.getKeys();b>S[0].frame&&(b=S[0].frame),X<S[S.length-1].frame&&(X=S[S.length-1].frame)}d._from=b,d._to=X}return d}static ClipKeys(b,X,P,Q,S){const d=b.clone(Q||b.name);return W.ClipKeysInPlace(d,X,P,S)}static ClipKeysInPlace(b,X,P,Q){return W.ClipInPlace(b,X,P,Q,!1)}static ClipFrames(b,X,P,Q,S){const d=b.clone(Q||b.name);return W.ClipFramesInPlace(d,X,P,S)}static ClipFramesInPlace(b,X,P,Q){return W.ClipInPlace(b,X,P,Q,!0)}static ClipInPlace(b,X,P,Q){let S=arguments.length>4&&void 0!==arguments[4]&&arguments[4],d=Number.MAX_VALUE,N=-Number.MAX_VALUE;const a=b.targetedAnimations;for(let u=0;u<a.length;u++){const b=a[u],w=Q?b.animation:b.animation.clone();S&&(w.createKeyForFrame(X),w.createKeyForFrame(P));const f=w.getKeys(),O=[];let e=Number.MAX_VALUE;for(let Q=0;Q<f.length;Q++){const b=f[Q];if(!S&&Q>=X&&Q<=P||S&&b.frame>=X&&b.frame<=P){const X={frame:b.frame,value:b.value.clone?b.value.clone():b.value,inTangent:b.inTangent,outTangent:b.outTangent,interpolation:b.interpolation,lockedTangent:b.lockedTangent};e===Number.MAX_VALUE&&(e=X.frame),X.frame-=e,O.push(X)}}0!==O.length?(d>O[0].frame&&(d=O[0].frame),N<O[O.length-1].frame&&(N=O[O.length-1].frame),w.setKeys(O,!0),b.animation=w):(a.splice(u,1),u--)}return b._from=d,b._to=N,b}getClassName(){return"AnimationGroup"}toString(b){let X="Name: "+this.name;return X+=", type: "+this.getClassName(),b&&(X+=", from: "+this._from,X+=", to: "+this._to,X+=", isStarted: "+this._isStarted,X+=", speedRatio: "+this._speedRatio,X+=", targetedAnimations length: "+this._targetedAnimations.length,X+=", animatables length: "+this._animatables),X}}}}]);