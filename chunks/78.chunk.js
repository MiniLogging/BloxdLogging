"use strict";(self["1kjc9ee3uyt"]=self["1kjc9ee3uyt"]||[]).push([[78],{14703:(w,E,G)=>{G.r(E),G.d(E,{AnimationGroup:()=>J,TargetedAnimation:()=>Z});var P=G(12181),h=G(11504),B=G(11543),y=G(11712),x=G(13219),U=G(11679);class l{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(w,E,G,h){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=E,this._target=w,this._scene=G,this._host=h,this._activeTargets=[],E._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===P.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=U.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const w={frame:0,value:this._minValue};this._keys.splice(0,0,w)}if(this._target instanceof Array){let w=0;for(const E of this._target)this._preparePath(E,w),this._getOriginalValues(w),w++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const B=E.getEvents();if(B&&B.length>0)for(const P of B)this._events.push(P._clone());this._enableBlending=w&&w.animationPropertiesOverride?w.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const G=this._animation.targetPropertyPath;if(G.length>1){let P=w;for(let w=0;w<G.length-1;w++){const E=G[w];if(P=P[E],void 0===P)throw new Error(`Invalid property (${E}) in property path (${G.join(".")})`)}this._targetPath=G[G.length-1],this._activeTargets[E]=P}else this._targetPath=G[0],this._activeTargets[E]=w;if(void 0===this._activeTargets[E][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${G.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let w=0;for(const E of this._target)void 0!==this._originalValue[w]&&this._setValue(E,this._activeTargets[w],this._originalValue[w],-1,w),w++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let w=0;w<this._events.length;w++)this._events[w].isDone=!1}isStopped(){return this._stopped}dispose(){const w=this._animation.runtimeAnimations.indexOf(this);w>-1&&this._animation.runtimeAnimations.splice(w,1)}setValue(w,E){if(this._targetIsArray)for(let G=0;G<this._target.length;G++){const P=this._target[G];this._setValue(P,this._activeTargets[G],w,E,G)}else this._setValue(this._target,this._directTarget,w,E,0)}_getOriginalValues(){let w,E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const G=this._activeTargets[E];w=G.getLocalMatrix&&"_matrix"===this._targetPath?G.getLocalMatrix():G[this._targetPath],w&&w.clone?this._originalValue[E]=w.clone():this._originalValue[E]=w}_registerTargetForLateAnimationBinding(w,E){const G=w.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(G),G._lateAnimationHolders||(G._lateAnimationHolders={}),G._lateAnimationHolders[w.targetPath]||(G._lateAnimationHolders[w.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:E}),w.isAdditive?(G._lateAnimationHolders[w.targetPath].additiveAnimations.push(w),G._lateAnimationHolders[w.targetPath].totalAdditiveWeight+=w.weight):(G._lateAnimationHolders[w.targetPath].animations.push(w),G._lateAnimationHolders[w.targetPath].totalWeight+=w.weight)}_setValue(w,E,G,h,B){if(this._currentActiveTarget=E,this._weight=h,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const w=E[this._targetPath];w.clone?this._originalBlendValue=w.clone():this._originalBlendValue=w}this._originalBlendValue.m?P.e.AllowMatrixDecomposeForInterpolation?this._currentValue?U.Matrix.DecomposeLerpToRef(this._originalBlendValue,G,this._blendingFactor,this._currentValue):this._currentValue=U.Matrix.DecomposeLerp(this._originalBlendValue,G,this._blendingFactor):this._currentValue?U.Matrix.LerpToRef(this._originalBlendValue,G,this._blendingFactor,this._currentValue):this._currentValue=U.Matrix.Lerp(this._originalBlendValue,G,this._blendingFactor):this._currentValue=P.e._UniversalLerp(this._originalBlendValue,G,this._blendingFactor);const h=w&&w.animationPropertiesOverride?w.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=h}else this._currentValue?this._currentValue.B?this._currentValue.B(G):this._currentValue=G:null!==G&&void 0!==G&&G.clone?this._currentValue=G.clone():this._currentValue=G;-1!==h?this._registerTargetForLateAnimationBinding(this,this._originalValue[B]):this._animationState.loopMode===P.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[B],E[this._targetPath]):E[this._targetPath]=this._originalValue[B]+this._currentValue:E[this._targetPath]=this._currentValue,w.Sl&&w.Sl(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const G=this._animation.getKeys();w<G[0].frame?w=G[0].frame:w>G[G.length-1].frame&&(w=G[G.length-1].frame);const P=this._events;if(P.length)for(let B=0;B<P.length;B++)P[B].onlyOnce||(P[B].isDone=P[B].frame<w);this._currentFrame=w;const h=this._animation._interpolate(w,this._animationState);this.setValue(h,E)}_prepareForSpeedRatioChange(w){const E=this._previousElapsedTime*(this._animation.framePerSecond*w)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-E}animate(w,E,G,h,B){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const x=this._animation,U=x.targetPropertyPath;if(!U||U.length<1)return this._stopped=!0,!1;let l,i=!0;const O=this._events;let u=0;if(this._coreRuntimeAnimation)u=G-E,l=this._coreRuntimeAnimation.currentFrame,this._currentFrame=l,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let y;(E<this._minFrame||E>this._maxFrame)&&(E=this._minFrame),(G<this._minFrame||G>this._maxFrame)&&(G=this._maxFrame),u=G-E;let U=w*(x.framePerSecond*B)/1e3+this._absoluteFrameOffset,V=0,a=!1;const Q=h&&this._animationState.loopMode===P.e.ANIMATIONLOOPMODE_YOYO;if(Q){const w=(U-E)/u,G=Math.sin(w*Math.PI);U=Math.abs(G)*u+E;const P=G>=0?1:-1;this._yoyoDirection!==P&&(a=!0),this._yoyoDirection=P}if(this._previousElapsedTime=w,this._previousAbsoluteFrame=U,!h&&G>=E&&(U>=u&&B>0||U<=0&&B<0))i=!1,V=x._getKeyValue(this._maxValue);else if(!h&&E>=G&&(U<=u&&B<0||U>=0&&B>0))i=!1,V=x._getKeyValue(this._minValue);else if(this._animationState.loopMode!==P.e.ANIMATIONLOOPMODE_CYCLE){const w=G.toString()+E.toString();if(!this._offsetsCache[w]){this._animationState.repeatCount=0,this._animationState.loopMode=P.e.ANIMATIONLOOPMODE_CYCLE;const h=x._interpolate(E,this._animationState),B=x._interpolate(G,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),x.dataType){case P.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[w]=B-h;break;case P.e.ANIMATIONTYPE_QUATERNION:case P.e.ANIMATIONTYPE_VECTOR3:case P.e.ANIMATIONTYPE_VECTOR2:case P.e.ANIMATIONTYPE_SIZE:case P.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[w]=B.cE(h)}this._highLimitsCache[w]=B}V=this._highLimitsCache[w],y=this._offsetsCache[w]}if(void 0===y)switch(x.dataType){case P.e.ANIMATIONTYPE_FLOAT:y=0;break;case P.e.ANIMATIONTYPE_QUATERNION:y=P.n;break;case P.e.ANIMATIONTYPE_VECTOR3:y=P.t;break;case P.e.ANIMATIONTYPE_VECTOR2:y=P.q;break;case P.e.ANIMATIONTYPE_SIZE:y=P.p;break;case P.e.ANIMATIONTYPE_COLOR3:y=P.g;break;case P.e.ANIMATIONTYPE_COLOR4:y=P.k}if(this._host&&this._host.syncRoot){const w=this._host.syncRoot;l=E+u*((w.masterFrame-w.fromFrame)/(w.toFrame-w.fromFrame))}else l=U>0&&E>G||U<0&&E<G?i&&0!==u?G+U%u:E:i&&0!==u?E+U%u:G;if(!Q&&(B>0&&this.currentFrame>l||B<0&&this.currentFrame<l)||Q&&a){this._onLoop();for(let w=0;w<O.length;w++)O[w].onlyOnce||(O[w].isDone=!1);this._animationState.key=B>0?0:x.getKeys().length-1}this._currentFrame=l,this._animationState.repeatCount=0===u?0:U/u|0,this._animationState.highLimitValue=V,this._animationState.offsetValue=y}const V=x._interpolate(l,this._animationState);if(this.setValue(V,y),O.length)for(let P=0;P<O.length;P++)if(u>=0&&l>=O[P].frame&&O[P].frame>=E||u<0&&l<=O[P].frame&&O[P].frame<=E){const w=O[P];w.isDone||(w.onlyOnce&&(O.splice(P,1),P--),w.isDone=!0,w.action(l))}return i||(this._stopped=!0),i}}var i=G(11528);class O{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(w){this._weight=-1!==w?Math.min(Math.max(w,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(w){for(let E=0;E<this._runtimeAnimations.length;E++){this._runtimeAnimations[E]._prepareForSpeedRatioChange(w)}this._speedRatio=w,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(w,E){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,B=arguments.length>4&&void 0!==arguments[4]&&arguments[4],y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,x=arguments.length>6?arguments[6]:void 0,U=arguments.length>7?arguments[7]:void 0,l=arguments.length>8?arguments[8]:void 0,i=arguments.length>9&&void 0!==arguments[9]&&arguments[9],O=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=E,this.fromFrame=G,this.toFrame=P,this.loopAnimation=B,this.onAnimationEnd=x,this.onAnimationLoop=l,this.isAdditive=i,this.playOrder=O,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Vx=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new h.d,this.onAnimationLoopObservable=new h.d,this._scene=w,U&&this.appendAnimations(E,U),this._speedRatio=y,w._activeAnimatables.push(this)}syncWith(w){if(this._syncRoot=w,w){const w=this._scene._activeAnimatables.indexOf(this);w>-1&&(this._scene._activeAnimatables.splice(w,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(w,E){for(let G=0;G<E.length;G++){const P=E[G],h=new l(w,P,this._scene,this);h._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(h)}}getAnimationByTargetProperty(w){const E=this._runtimeAnimations;for(let G=0;G<E.length;G++)if(E[G].animation.targetProperty===w)return E[G].animation;return null}getRuntimeAnimationByTargetProperty(w){const E=this._runtimeAnimations;for(let G=0;G<E.length;G++)if(E[G].animation.targetProperty===w)return E[G];return null}reset(){const w=this._runtimeAnimations;for(let E=0;E<w.length;E++)w[E].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(w){const E=this._runtimeAnimations;for(let G=0;G<E.length;G++)E[G].animation.enableBlending=!0,E[G].animation.blendingSpeed=w}disableBlending(){const w=this._runtimeAnimations;for(let E=0;E<w.length;E++)w[E].animation.enableBlending=!1}goToFrame(w){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const G=this._runtimeAnimations;if(G[0]){const E=G[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??G[0].currentFrame;const P=0===this.speedRatio?0:(w-this._frameToSyncFromJump)/E*1e3/this.speedRatio;this._manualJumpDelay=-P}for(let P=0;P<G.length;P++)G[P].goToFrame(w,E?this._weight:-1);this._goToFrame=w}get paused(){return this.Vx}pause(){this.Vx||(this.Vx=!0)}restart(){this.Vx=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(w,E){let G=arguments.length>2&&void 0!==arguments[2]&&arguments[2],P=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(w||E){const h=this._scene._activeAnimatables.indexOf(this);if(h>-1){const B=this._runtimeAnimations;for(let G=B.length-1;G>=0;G--){const P=B[G];w&&P.animation.name!=w||(E&&!E(P.target)||(P.dispose(),B.splice(G,1)))}0==B.length&&(G||this._scene._activeAnimatables.splice(h,1),P||this._raiseOnAnimationEnd())}}else{const w=this._scene._activeAnimatables.indexOf(this);if(w>-1){G||this._scene._activeAnimatables.splice(w,1);const E=this._runtimeAnimations;for(let w=0;w<E.length;w++)E[w].dispose();this._runtimeAnimations.length=0,P||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((w=>{this.onAnimationEndObservable.add((()=>{w(this)}),void 0,void 0,this,!0)}))}_animate(w){if(this.Vx)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=w),!0;if(null===this._localDelayOffset?(this._localDelayOffset=w,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=w-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let E=!1;const G=this._runtimeAnimations;let P;for(P=0;P<G.length;P++){const h=G[P].animate(w-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);E=E||h}if(this.animationStarted=E,!E){if(this.disposeOnEnd)for(P=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(P,1),P=0;P<G.length;P++)G[P].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return E}}function u(w){if(0===w.totalWeight&&0===w.totalAdditiveWeight)return w.originalValue;let E=1;const G=U.TmpVectors.QE[0],P=U.TmpVectors.QE[1],h=U.TmpVectors.Quaternion[0];let B=0;const y=w.animations[0],x=w.originalValue;let l=1,i=!1;if(w.totalWeight<1)l=1-w.totalWeight,x.decompose(P,h,G);else{if(B=1,E=w.totalWeight,l=y.weight/E,1==l){if(!w.totalAdditiveWeight)return y.currentValue;i=!0}y.currentValue.decompose(P,h,G)}if(!i){P.scaleInPlace(l),G.scaleInPlace(l),h.scaleInPlace(l);for(let y=B;y<w.animations.length;y++){const B=w.animations[y];if(0===B.weight)continue;l=B.weight/E;const x=U.TmpVectors.QE[2],i=U.TmpVectors.QE[3],O=U.TmpVectors.Quaternion[1];B.currentValue.decompose(i,O,x),i.scaleAndAddToRef(l,P),O.scaleAndAddToRef(U.Quaternion.Dot(h,O)>0?l:-l,h),x.scaleAndAddToRef(l,G)}h.normalize()}for(let u=0;u<w.additiveAnimations.length;u++){const E=w.additiveAnimations[u];if(0===E.weight)continue;const B=U.TmpVectors.QE[2],y=U.TmpVectors.QE[3],x=U.TmpVectors.Quaternion[1];E.currentValue.decompose(y,x,B),y.multiplyToRef(P,y),U.QE.LerpToRef(P,y,E.weight,P),h.multiplyToRef(x,x),U.Quaternion.SlerpToRef(h,x,E.weight,h),B.scaleAndAddToRef(E.weight,G)}const O=y?y._animationState.workValue:U.TmpVectors.Matrix[0].clone();return U.Matrix.ComposeToRef(P,h,G,O),O}function V(w,E){if(0===w.totalWeight&&0===w.totalAdditiveWeight)return E;const G=w.animations[0],P=w.originalValue;let h=E;if(0===w.totalWeight&&w.totalAdditiveWeight>0)h.B(P);else if(1===w.animations.length){if(U.Quaternion.SlerpToRef(P,G.currentValue,Math.min(1,w.totalWeight),h),0===w.totalAdditiveWeight)return h}else if(w.animations.length>1){let G,B,y=1;if(w.totalWeight<1){const E=1-w.totalWeight;G=[],B=[],G.push(P),B.push(E)}else{if(2===w.animations.length&&(U.Quaternion.SlerpToRef(w.animations[0].currentValue,w.animations[1].currentValue,w.animations[1].weight/w.totalWeight,E),0===w.totalAdditiveWeight))return E;G=[],B=[],y=w.totalWeight}for(let E=0;E<w.animations.length;E++){const P=w.animations[E];G.push(P.currentValue),B.push(P.weight/y)}let x=0;for(let w=0;w<G.length;)w?(x+=B[w],U.Quaternion.SlerpToRef(h,G[w],B[w]/x,h),w++):(U.Quaternion.SlerpToRef(G[w],G[w+1],B[w+1]/(B[w]+B[w+1]),E),h=E,x=B[w]+B[w+1],w+=2)}for(let B=0;B<w.additiveAnimations.length;B++){const E=w.additiveAnimations[B];0!==E.weight&&(h.multiplyToRef(E.currentValue,U.TmpVectors.Quaternion[0]),U.Quaternion.SlerpToRef(h,U.TmpVectors.Quaternion[0],E.weight,h))}return h}var a,Q,c=G(11908);a=c.d,(Q=x.b)&&(Q.prototype.copyAnimationRange=function(w,E,G){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3],B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new P.e(this.name,"_matrix",w.animations[0].framePerSecond,P.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const y=w.animations[0].getRange(E);if(!y)return!1;const x=y.from,U=y.to,l=w.animations[0].getKeys(),i=w.length,O=w.getParent(),u=this.getParent(),V=h&&O&&i&&this.length&&i!==this.length,a=V&&u&&O?u.length/O.length:1,Q=h&&!u&&B&&(1!==B.x||1!==B.y||1!==B.z),c=this.animations[0].getKeys();let Z,J,d;for(let P=0,K=l.length;P<K;P++)Z=l[P],Z.frame>=x&&Z.frame<=U&&(h?(d=Z.value.clone(),V?(J=d.getTranslation(),d.setTranslation(J.scaleInPlace(a))):Q&&B?(J=d.getTranslation(),d.setTranslation(J.multiplyInPlace(B))):d=Z.value):d=Z.value,c.push({frame:Z.frame+G,value:d}));return this.animations[0].createRange(E,x+G,U+G),!0}),a&&(a.prototype._animate=function(w){if(!this.animationsEnabled)return;const E=i.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=E}this.deltaTime=void 0!==w?w:this.useConstantAnimationDeltaTime?16:(E-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=E;const G=this._activeAnimatables;if(0===G.length)return;this._animationTime+=this.deltaTime;const h=this._animationTime;for(let P=0;P<G.length;P++){const w=G[P];!w._animate(h)&&w.disposeOnEnd&&P--}!function(w){if(w._registeredForLateAnimationBindings.length){for(let E=0;E<w._registeredForLateAnimationBindings.length;E++){const G=w._registeredForLateAnimationBindings.data[E];for(const w in G._lateAnimationHolders){const E=G._lateAnimationHolders[w],h=E.animations[0],B=E.originalValue;if(void 0===B||null===B)continue;const y=P.e.AllowMatrixDecomposeForInterpolation&&B.m;let x=G[w];if(y)x=u(E);else if(void 0!==B.w)x=V(E,x||U.Quaternion.Identity());else{let w=0,G=1;const y=h&&h._animationState.loopMode===P.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(E.totalWeight<1)x=y?B.clone?B.clone():B:h&&B.scale?B.scale(1-E.totalWeight):h?B*(1-E.totalWeight):B.clone?B.clone():B;else if(h){G=E.totalWeight;const P=h.weight/G;x=1!==P?h.currentValue.scale?h.currentValue.scale(P):h.currentValue*P:h.currentValue,y&&(x.addToRef?x.addToRef(B,x):x+=B),w=1}for(let P=w;P<E.animations.length;P++){const w=E.animations[P],h=w.weight/G;h&&(w.currentValue.scaleAndAddToRef?w.currentValue.scaleAndAddToRef(h,x):x+=w.currentValue*h)}for(let P=0;P<E.additiveAnimations.length;P++){const w=E.additiveAnimations[P],G=w.weight;G&&(w.currentValue.scaleAndAddToRef?w.currentValue.scaleAndAddToRef(G,x):x+=w.currentValue*G)}}G[w]=x}G._lateAnimationHolders={}}w._registeredForLateAnimationBindings.reset()}}(this)},a.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((w,E)=>w.playOrder-E.playOrder))},a.prototype.beginWeightedAnimation=function(w,E,G){let P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,h=arguments.length>4?arguments[4]:void 0,B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,y=arguments.length>6?arguments[6]:void 0,x=arguments.length>7?arguments[7]:void 0,U=arguments.length>8?arguments[8]:void 0,l=arguments.length>9?arguments[9]:void 0,i=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const O=this.beginAnimation(w,E,G,h,B,y,x,!1,U,l,i);return O.weight=P,O},a.prototype.beginAnimation=function(w,E,G,P){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,B=arguments.length>5?arguments[5]:void 0,y=arguments.length>6?arguments[6]:void 0,x=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],U=arguments.length>8?arguments[8]:void 0,l=arguments.length>9?arguments[9]:void 0,i=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(h<0){const w=E;E=G,G=w,h=-h}E>G&&(h=-h),x&&this.stopAnimation(w,void 0,U),y||(y=new O(this,w,E,G,P,h,B,void 0,l,i));const u=!U||U(w);if(w.animations&&u&&y.appendAnimations(w,w.animations),w.getAnimatables){const i=w.getAnimatables();for(let w=0;w<i.length;w++)this.beginAnimation(i[w],E,G,P,h,B,y,x,U,l)}return y.reset(),y},a.prototype.beginHierarchyAnimation=function(w,E,G,P,h){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,y=arguments.length>6?arguments[6]:void 0,x=arguments.length>7?arguments[7]:void 0,U=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],l=arguments.length>9?arguments[9]:void 0,i=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const O=w.getDescendants(E),u=[];u.push(this.beginAnimation(w,G,P,h,B,y,x,U,l,void 0,i));for(const V of O)u.push(this.beginAnimation(V,G,P,h,B,y,x,U,l,void 0,i));return u},a.prototype.beginDirectAnimation=function(w,E,G,P,h){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(B<0){const w=G;G=P,P=w,B=-B}return G>P&&(B=-B),new O(this,w,G,P,h,B,arguments.length>6?arguments[6]:void 0,E,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},a.prototype.beginDirectHierarchyAnimation=function(w,E,G,P,h,B,y,x,U){let l=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const i=w.getDescendants(E),O=[];O.push(this.beginDirectAnimation(w,G,P,h,B,y,x,U,l));for(const u of i)O.push(this.beginDirectAnimation(u,G,P,h,B,y,x,U,l));return O},a.prototype.getAnimatableByTarget=function(w){for(let E=0;E<this._activeAnimatables.length;E++)if(this._activeAnimatables[E].target===w)return this._activeAnimatables[E];return null},a.prototype.getAllAnimatablesByTarget=function(w){const E=[];for(let G=0;G<this._activeAnimatables.length;G++)this._activeAnimatables[G].target===w&&E.push(this._activeAnimatables[G]);return E},a.prototype.stopAnimation=function(w,E,G){const P=this.getAllAnimatablesByTarget(w);for(const h of P)h.stop(E,G)},a.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let w=0;w<this._activeAnimatables.length;w++)this._activeAnimatables[w].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const w of this.animationGroups)w.stop()});class Z{getClassName(){return"TargetedAnimation"}serialize(){const w={};return w.animation=this.animation.serialize(),w.targetId=this.target.id,w}}class J{get mask(){return this._mask}set mask(w){this._mask!==w&&(this._mask=w,this.syncWithMask(!0))}syncWithMask(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||w){this._numActiveAnimatables=0;for(let w=0;w<this._animatables.length;++w){const E=this._animatables[w];!this.mask||this.mask.disabled||this.mask.retainsTarget(E.target.name)?(this._numActiveAnimatables++,E.paused&&E.restart()):E.paused||E.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let w=0;w<this._animatables.length;++w){const E=this._animatables[w];this.mask.retainsTarget(E.target.name)||(E.stop(),this._animatables.splice(w,1),--w)}for(let w=0;w<this._targetedAnimations.length;w++){const E=this._targetedAnimations[w];this.mask.retainsTarget(E.target.name)||(this._targetedAnimations.splice(w,1),--w)}}}get from(){return this._from}set from(w){if(this._from!==w){this._from=w;for(let w=0;w<this._animatables.length;w++){this._animatables[w].fromFrame=this._from}}}get to(){return this._to}set to(w){if(this._to!==w){this._to=w;for(let w=0;w<this._animatables.length;w++){this._animatables[w].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(w){if(this._speedRatio!==w){this._speedRatio=w;for(let w=0;w<this._animatables.length;w++){this._animatables[w].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(w){if(this._loopAnimation!==w){this._loopAnimation=w;for(let w=0;w<this._animatables.length;w++){this._animatables[w].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(w){if(this._isAdditive!==w){this._isAdditive=w;for(let w=0;w<this._animatables.length;w++){this._animatables[w].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(w){this._weight!==w&&(this._weight=w,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(w){if(this._playOrder!==w&&(this._playOrder=w,this._animatables.length>0)){for(let w=0;w<this._animatables.length;w++)this._animatables[w].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(w){if(this._enableBlending!==w&&(this._enableBlending=w,null!==w))for(let E=0;E<this._targetedAnimations.length;++E)this._targetedAnimations[E].animation.enableBlending=w}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(w){if(this._blendingSpeed!==w&&(this._blendingSpeed=w,null!==w))for(let E=0;E<this._targetedAnimations.length;++E)this._targetedAnimations[E].animation.blendingSpeed=w}getLength(w,E){w=w??this._from;return((E=E??this._to)-w)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(w){let E=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],G=arguments.length>2&&void 0!==arguments[2]&&arguments[2],P=arguments.length>3?arguments[3]:void 0;if(0===w.length)return null;P=P??w[0].weight;let h=Number.MAX_VALUE,B=-Number.MAX_VALUE;if(G)for(const x of w)x.from<h&&(h=x.from),x.to>B&&(B=x.to);const y=new J(w[0].name+"_merged",w[0]._scene,P);for(const x of w){G&&x.normalize(h,B);for(const w of x.targetedAnimations)y.addTargetedAnimation(w.animation,w.target);E&&x.dispose()}return y}constructor(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=w,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new h.d,this.onAnimationLoopObservable=new h.d,this.onAnimationGroupLoopObservable=new h.d,this.onAnimationGroupEndObservable=new h.d,this.onAnimationGroupPauseObservable=new h.d,this.onAnimationGroupPlayObservable=new h.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=E||B.e.LastCreatedScene,this._weight=G,this._playOrder=P,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(w,E){const G=new Z;G.animation=w,G.target=E;const P=w.getKeys();return this._from>P[0].frame&&(this._from=P[0].frame),this._to<P[P.length-1].frame&&(this._to=P[P.length-1].frame),null!==this._enableBlending&&(w.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(w.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(G),this._shouldStart=!0,G}removeTargetedAnimation(w){for(let E=this._targetedAnimations.length-1;E>-1;E--){this._targetedAnimations[E].animation===w&&this._targetedAnimations.splice(E,1)}}normalize(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==w&&(w=this._from),null==E&&(E=this._to);for(let G=0;G<this._targetedAnimations.length;G++){const P=this._targetedAnimations[G].animation.getKeys(),h=P[0],B=P[P.length-1];if(h.frame>w){const E={frame:w,value:h.value,inTangent:h.inTangent,outTangent:h.outTangent,interpolation:h.interpolation};P.splice(0,0,E)}if(B.frame<E){const w={frame:E,value:B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation};P.push(w)}}return this._from=w,this._to=E,this}_processLoop(w,E,G){w.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(E),this._animationLoopFlags[G]||(this._animationLoopFlags[G]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0],E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,G=arguments.length>2?arguments[2]:void 0,P=arguments.length>3?arguments[3]:void 0,h=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=w,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let B=0;B<this._targetedAnimations.length;B++){const y=this._targetedAnimations[B],x=this._scene.beginDirectAnimation(y.target,[y.animation],void 0!==G?G:this._from,void 0!==P?P:this._to,w,E,void 0,void 0,void 0!==h?h:this._isAdditive);x.weight=this._weight,x.playOrder=this._playOrder,x.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(y),this._checkAnimationGroupEnded(x)},this._processLoop(x,y,B),this._animatables.push(x)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=E,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let w=0;w<this._animatables.length;w++){this._animatables[w].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(w){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==w&&(this.loopAnimation=w),this.restart()):(this.stop(),this.start(w,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let w=0;w<this._animatables.length;w++){this._animatables[w].reset()}return this}restart(){if(!this._isStarted)return this;for(let w=0;w<this._animatables.length;w++){this._animatables[w].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const E=this._animatables.slice();for(let P=0;P<E.length;P++)E[P].stop(void 0,void 0,!0,w);let G=0;for(let P=0;P<this._scene._activeAnimatables.length;P++){const E=this._scene._activeAnimatables[P];E._runtimeAnimations.length>0?this._scene._activeAnimatables[G++]=E:w&&this._checkAnimationGroupEnded(E,w)}return this._scene._activeAnimatables.length=G,this._isStarted=!1,this}setWeightForAllAnimatables(w){for(let E=0;E<this._animatables.length;E++){this._animatables[E].weight=w}return this}syncAllAnimationsWith(w){for(let E=0;E<this._animatables.length;E++){this._animatables[E].syncWith(w)}return this}goToFrame(w){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let G=0;G<this._animatables.length;G++){this._animatables[G].goToFrame(w,E)}return this}getCurrentFrame(){var w;return(null===(w=this.animatables[0])||void 0===w?void 0:w.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const w=this._scene.animationGroups.indexOf(this);if(w>-1&&this._scene.animationGroups.splice(w,1),this._parentContainer){const w=this._parentContainer.animationGroups.indexOf(this);w>-1&&this._parentContainer.animationGroups.splice(w,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(w){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const G=this._animatables.indexOf(w);G>-1&&this._animatables.splice(G,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,E||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(w,E){let G=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const P=new J(w||this.name,this._scene,this._weight,this._playOrder);P._from=this.from,P._to=this.to,P._speedRatio=this.speedRatio,P._loopAnimation=this.loopAnimation,P._isAdditive=this.isAdditive,P._enableBlending=this.enableBlending,P._blendingSpeed=this.blendingSpeed,P.metadata=this.metadata,P.mask=this.mask;for(const h of this._targetedAnimations)P.addTargetedAnimation(G?h.animation.clone():h.animation,E?E(h.target):h.target);return P}serialize(){const w={};w.name=this.name,w.from=this.from,w.to=this.to,w.speedRatio=this.speedRatio,w.loopAnimation=this.loopAnimation,w.isAdditive=this.isAdditive,w.weight=this.weight,w.playOrder=this.playOrder,w.enableBlending=this.enableBlending,w.blendingSpeed=this.blendingSpeed,w.targetedAnimations=[];for(let E=0;E<this.targetedAnimations.length;E++){const G=this.targetedAnimations[E];w.targetedAnimations[E]=G.serialize()}return y.e&&y.e.HasTags(this)&&(w.tags=y.e.GetTags(this)),this.metadata&&(w.metadata=this.metadata),w}static Parse(w,E){const G=new J(w.name,E,w.weight,w.playOrder);for(let h=0;h<w.targetedAnimations.length;h++){const B=w.targetedAnimations[h],y=P.e.Parse(B.animation),x=B.targetId;if("influence"===B.animation.property){const w=E.getMorphTargetById(x);w&&G.addTargetedAnimation(y,w)}else{const w=E.getNodeById(x);null!=w&&G.addTargetedAnimation(y,w)}}return y.e&&y.e.AddTagsTo(G,w.tags),null!==w.from&&null!==w.to&&G.normalize(w.from,w.to),void 0!==w.speedRatio&&(G._speedRatio=w.speedRatio),void 0!==w.loopAnimation&&(G._loopAnimation=w.loopAnimation),void 0!==w.isAdditive&&(G._isAdditive=w.isAdditive),void 0!==w.weight&&(G._weight=w.weight),void 0!==w.playOrder&&(G._playOrder=w.playOrder),void 0!==w.enableBlending&&(G._enableBlending=w.enableBlending),void 0!==w.blendingSpeed&&(G._blendingSpeed=w.blendingSpeed),void 0!==w.metadata&&(G.metadata=w.metadata),G}static MakeAnimationAdditive(w,E,G){let h;h="object"===typeof E?E:{referenceFrame:E,range:G,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let B=w;h.cloneOriginalAnimationGroup&&(B=w.clone(h.clonedAnimationGroupName||B.name));const y=B.targetedAnimations;for(let x=0;x<y.length;x++){const w=y[x];w.animation=P.e.MakeAnimationAdditive(w.animation,h)}if(B.isAdditive=!0,h.clipKeys){let w=Number.MAX_VALUE,E=-Number.MAX_VALUE;const G=B.targetedAnimations;for(let P=0;P<G.length;P++){const h=G[P].animation.getKeys();w>h[0].frame&&(w=h[0].frame),E<h[h.length-1].frame&&(E=h[h.length-1].frame)}B._from=w,B._to=E}return B}static ClipKeys(w,E,G,P,h){const B=w.clone(P||w.name);return J.ClipKeysInPlace(B,E,G,h)}static ClipKeysInPlace(w,E,G,P){return J.ClipInPlace(w,E,G,P,!1)}static ClipFrames(w,E,G,P,h){const B=w.clone(P||w.name);return J.ClipFramesInPlace(B,E,G,h)}static ClipFramesInPlace(w,E,G,P){return J.ClipInPlace(w,E,G,P,!0)}static ClipInPlace(w,E,G,P){let h=arguments.length>4&&void 0!==arguments[4]&&arguments[4],B=Number.MAX_VALUE,y=-Number.MAX_VALUE;const x=w.targetedAnimations;for(let U=0;U<x.length;U++){const w=x[U],l=P?w.animation:w.animation.clone();h&&(l.createKeyForFrame(E),l.createKeyForFrame(G));const i=l.getKeys(),O=[];let u=Number.MAX_VALUE;for(let P=0;P<i.length;P++){const w=i[P];if(!h&&P>=E&&P<=G||h&&w.frame>=E&&w.frame<=G){const E={frame:w.frame,value:w.value.clone?w.value.clone():w.value,inTangent:w.inTangent,outTangent:w.outTangent,interpolation:w.interpolation,lockedTangent:w.lockedTangent};u===Number.MAX_VALUE&&(u=E.frame),E.frame-=u,O.push(E)}}0!==O.length?(B>O[0].frame&&(B=O[0].frame),y<O[O.length-1].frame&&(y=O[O.length-1].frame),l.setKeys(O,!0),w.animation=l):(x.splice(U,1),U--)}return w._from=B,w._to=y,w}getClassName(){return"AnimationGroup"}toString(w){let E="Name: "+this.name;return E+=", type: "+this.getClassName(),w&&(E+=", from: "+this._from,E+=", to: "+this._to,E+=", isStarted: "+this._isStarted,E+=", speedRatio: "+this._speedRatio,E+=", targetedAnimations length: "+this._targetedAnimations.length,E+=", animatables length: "+this._animatables),E}}}}]);