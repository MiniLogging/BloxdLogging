"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[78],{14278:(q,S,b)=>{b.r(S),b.d(S,{AnimationGroup:()=>k,TargetedAnimation:()=>Q});var z=b(11634),C=b(10929),v=b(10975),U=b(11144),g=b(12757),r=b(11103);class I{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(q,S,b,C){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=S,this._target=q,this._scene=b,this._host=C,this._activeTargets=[],S._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===z.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=r.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const q={frame:0,value:this._minValue};this._keys.splice(0,0,q)}if(this._target instanceof Array){let q=0;for(const S of this._target)this._preparePath(S,q),this._getOriginalValues(q),q++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const v=S.getEvents();if(v&&v.length>0)for(const z of v)this._events.push(z._clone());this._enableBlending=q&&q.animationPropertiesOverride?q.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=this._animation.targetPropertyPath;if(b.length>1){let z=q;for(let q=0;q<b.length-1;q++){const S=b[q];if(z=z[S],void 0===z)throw new Error(`Invalid property (${S}) in property path (${b.join(".")})`)}this._targetPath=b[b.length-1],this._activeTargets[S]=z}else this._targetPath=b[0],this._activeTargets[S]=q;if(void 0===this._activeTargets[S][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${b.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let q=0;for(const S of this._target)void 0!==this._originalValue[q]&&this._setValue(S,this._activeTargets[q],this._originalValue[q],-1,q),q++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let q=0;q<this._events.length;q++)this._events[q].isDone=!1}isStopped(){return this._stopped}dispose(){const q=this._animation.runtimeAnimations.indexOf(this);q>-1&&this._animation.runtimeAnimations.splice(q,1)}setValue(q,S){if(this._targetIsArray)for(let b=0;b<this._target.length;b++){const z=this._target[b];this._setValue(z,this._activeTargets[b],q,S,b)}else this._setValue(this._target,this._directTarget,q,S,0)}_getOriginalValues(){let q,S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=this._activeTargets[S];q=b.getLocalMatrix&&"_matrix"===this._targetPath?b.getLocalMatrix():b[this._targetPath],q&&q.clone?this._originalValue[S]=q.clone():this._originalValue[S]=q}_registerTargetForLateAnimationBinding(q,S){const b=q.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(b),b._lateAnimationHolders||(b._lateAnimationHolders={}),b._lateAnimationHolders[q.targetPath]||(b._lateAnimationHolders[q.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:S}),q.isAdditive?(b._lateAnimationHolders[q.targetPath].additiveAnimations.push(q),b._lateAnimationHolders[q.targetPath].totalAdditiveWeight+=q.weight):(b._lateAnimationHolders[q.targetPath].animations.push(q),b._lateAnimationHolders[q.targetPath].totalWeight+=q.weight)}_setValue(q,S,b,C,v){if(this._currentActiveTarget=S,this._weight=C,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const q=S[this._targetPath];q.clone?this._originalBlendValue=q.clone():this._originalBlendValue=q}this._originalBlendValue.m?z.d.AllowMatrixDecomposeForInterpolation?this._currentValue?r.Matrix.DecomposeLerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=r.Matrix.DecomposeLerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue?r.Matrix.LerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=r.Matrix.Lerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue=z.d._UniversalLerp(this._originalBlendValue,b,this._blendingFactor);const C=q&&q.animationPropertiesOverride?q.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=C}else this._currentValue?this._currentValue.v?this._currentValue.v(b):this._currentValue=b:null!==b&&void 0!==b&&b.clone?this._currentValue=b.clone():this._currentValue=b;-1!==C?this._registerTargetForLateAnimationBinding(this,this._originalValue[v]):this._animationState.loopMode===z.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[v],S[this._targetPath]):S[this._targetPath]=this._originalValue[v]+this._currentValue:S[this._targetPath]=this._currentValue,q.gV&&q.gV(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const b=this._animation.getKeys();q<b[0].frame?q=b[0].frame:q>b[b.length-1].frame&&(q=b[b.length-1].frame);const z=this._events;if(z.length)for(let v=0;v<z.length;v++)z[v].onlyOnce||(z[v].isDone=z[v].frame<q);this._currentFrame=q;const C=this._animation._interpolate(q,this._animationState);this.setValue(C,S)}_prepareForSpeedRatioChange(q){const S=this._previousElapsedTime*(this._animation.framePerSecond*q)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-S}animate(q,S,b,C,v){let U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const g=this._animation,r=g.targetPropertyPath;if(!r||r.length<1)return this._stopped=!0,!1;let I,V=!0;const l=this._events;let y=0;if(this._coreRuntimeAnimation)y=b-S,I=this._coreRuntimeAnimation.currentFrame,this._currentFrame=I,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let U;(S<this._minFrame||S>this._maxFrame)&&(S=this._minFrame),(b<this._minFrame||b>this._maxFrame)&&(b=this._maxFrame),y=b-S;let r=q*(g.framePerSecond*v)/1e3+this._absoluteFrameOffset,R=0,G=!1;const Z=C&&this._animationState.loopMode===z.d.ANIMATIONLOOPMODE_YOYO;if(Z){const q=(r-S)/y,b=Math.sin(q*Math.PI);r=Math.abs(b)*y+S;const z=b>=0?1:-1;this._yoyoDirection!==z&&(G=!0),this._yoyoDirection=z}if(this._previousElapsedTime=q,this._previousAbsoluteFrame=r,!C&&b>=S&&(r>=y&&v>0||r<=0&&v<0))V=!1,R=g._getKeyValue(this._maxValue);else if(!C&&S>=b&&(r<=y&&v<0||r>=0&&v>0))V=!1,R=g._getKeyValue(this._minValue);else if(this._animationState.loopMode!==z.d.ANIMATIONLOOPMODE_CYCLE){const q=b.toString()+S.toString();if(!this._offsetsCache[q]){this._animationState.repeatCount=0,this._animationState.loopMode=z.d.ANIMATIONLOOPMODE_CYCLE;const C=g._interpolate(S,this._animationState),v=g._interpolate(b,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),g.dataType){case z.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[q]=v-C;break;case z.d.ANIMATIONTYPE_QUATERNION:case z.d.ANIMATIONTYPE_VECTOR3:case z.d.ANIMATIONTYPE_VECTOR2:case z.d.ANIMATIONTYPE_SIZE:case z.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[q]=v.RS(C)}this._highLimitsCache[q]=v}R=this._highLimitsCache[q],U=this._offsetsCache[q]}if(void 0===U)switch(g.dataType){case z.d.ANIMATIONTYPE_FLOAT:U=0;break;case z.d.ANIMATIONTYPE_QUATERNION:U=z.g;break;case z.d.ANIMATIONTYPE_VECTOR3:U=z.q;break;case z.d.ANIMATIONTYPE_VECTOR2:U=z.n;break;case z.d.ANIMATIONTYPE_SIZE:U=z.k;break;case z.d.ANIMATIONTYPE_COLOR3:U=z.e;break;case z.d.ANIMATIONTYPE_COLOR4:U=z.f}if(this._host&&this._host.syncRoot){const q=this._host.syncRoot;I=S+y*((q.masterFrame-q.fromFrame)/(q.toFrame-q.fromFrame))}else I=r>0&&S>b||r<0&&S<b?V&&0!==y?b+r%y:S:V&&0!==y?S+r%y:b;if(!Z&&(v>0&&this.currentFrame>I||v<0&&this.currentFrame<I)||Z&&G){this._onLoop();for(let q=0;q<l.length;q++)l[q].onlyOnce||(l[q].isDone=!1);this._animationState.key=v>0?0:g.getKeys().length-1}this._currentFrame=I,this._animationState.repeatCount=0===y?0:r/y|0,this._animationState.highLimitValue=R,this._animationState.offsetValue=U}const R=g._interpolate(I,this._animationState);if(this.setValue(R,U),l.length)for(let z=0;z<l.length;z++)if(y>=0&&I>=l[z].frame&&l[z].frame>=S||y<0&&I<=l[z].frame&&l[z].frame<=S){const q=l[z];q.isDone||(q.onlyOnce&&(l.splice(z,1),z--),q.isDone=!0,q.action(I))}return V||(this._stopped=!0),V}}var V=b(10957);class l{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(q){this._weight=-1!==q?Math.min(Math.max(q,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(q){for(let S=0;S<this._runtimeAnimations.length;S++){this._runtimeAnimations[S]._prepareForSpeedRatioChange(q)}this._speedRatio=q,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(q,S){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,v=arguments.length>4&&void 0!==arguments[4]&&arguments[4],U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,r=arguments.length>7?arguments[7]:void 0,I=arguments.length>8?arguments[8]:void 0,V=arguments.length>9&&void 0!==arguments[9]&&arguments[9],l=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=S,this.fromFrame=b,this.toFrame=z,this.loopAnimation=v,this.onAnimationEnd=g,this.onAnimationLoop=I,this.isAdditive=V,this.playOrder=l,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Ur=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new C.d,this.onAnimationLoopObservable=new C.d,this._scene=q,r&&this.appendAnimations(S,r),this._speedRatio=U,q._activeAnimatables.push(this)}syncWith(q){if(this._syncRoot=q,q){const q=this._scene._activeAnimatables.indexOf(this);q>-1&&(this._scene._activeAnimatables.splice(q,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(q,S){for(let b=0;b<S.length;b++){const z=S[b],C=new I(q,z,this._scene,this);C._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(C)}}getAnimationByTargetProperty(q){const S=this._runtimeAnimations;for(let b=0;b<S.length;b++)if(S[b].animation.targetProperty===q)return S[b].animation;return null}getRuntimeAnimationByTargetProperty(q){const S=this._runtimeAnimations;for(let b=0;b<S.length;b++)if(S[b].animation.targetProperty===q)return S[b];return null}reset(){const q=this._runtimeAnimations;for(let S=0;S<q.length;S++)q[S].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(q){const S=this._runtimeAnimations;for(let b=0;b<S.length;b++)S[b].animation.enableBlending=!0,S[b].animation.blendingSpeed=q}disableBlending(){const q=this._runtimeAnimations;for(let S=0;S<q.length;S++)q[S].animation.enableBlending=!1}goToFrame(q){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._runtimeAnimations;if(b[0]){const S=b[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??b[0].currentFrame;const z=0===this.speedRatio?0:(q-this._frameToSyncFromJump)/S*1e3/this.speedRatio;this._manualJumpDelay=-z}for(let z=0;z<b.length;z++)b[z].goToFrame(q,S?this._weight:-1);this._goToFrame=q}get paused(){return this.Ur}pause(){this.Ur||(this.Ur=!0)}restart(){this.Ur=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(q,S){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(q||S){const C=this._scene._activeAnimatables.indexOf(this);if(C>-1){const v=this._runtimeAnimations;for(let b=v.length-1;b>=0;b--){const z=v[b];q&&z.animation.name!=q||(S&&!S(z.target)||(z.dispose(),v.splice(b,1)))}0==v.length&&(b||this._scene._activeAnimatables.splice(C,1),z||this._raiseOnAnimationEnd())}}else{const q=this._scene._activeAnimatables.indexOf(this);if(q>-1){b||this._scene._activeAnimatables.splice(q,1);const S=this._runtimeAnimations;for(let q=0;q<S.length;q++)S[q].dispose();this._runtimeAnimations.length=0,z||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((q=>{this.onAnimationEndObservable.add((()=>{q(this)}),void 0,void 0,this,!0)}))}_animate(q){if(this.Ur)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=q),!0;if(null===this._localDelayOffset?(this._localDelayOffset=q,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=q-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let S=!1;const b=this._runtimeAnimations;let z;for(z=0;z<b.length;z++){const C=b[z].animate(q-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);S=S||C}if(this.animationStarted=S,!S){if(this.disposeOnEnd)for(z=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(z,1),z=0;z<b.length;z++)b[z].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return S}}function y(q){if(0===q.totalWeight&&0===q.totalAdditiveWeight)return q.originalValue;let S=1;const b=r.TmpVectors.yS[0],z=r.TmpVectors.yS[1],C=r.TmpVectors.Quaternion[0];let v=0;const U=q.animations[0],g=q.originalValue;let I=1,V=!1;if(q.totalWeight<1)I=1-q.totalWeight,g.decompose(z,C,b);else{if(v=1,S=q.totalWeight,I=U.weight/S,1==I){if(!q.totalAdditiveWeight)return U.currentValue;V=!0}U.currentValue.decompose(z,C,b)}if(!V){z.scaleInPlace(I),b.scaleInPlace(I),C.scaleInPlace(I);for(let U=v;U<q.animations.length;U++){const v=q.animations[U];if(0===v.weight)continue;I=v.weight/S;const g=r.TmpVectors.yS[2],V=r.TmpVectors.yS[3],l=r.TmpVectors.Quaternion[1];v.currentValue.decompose(V,l,g),V.scaleAndAddToRef(I,z),l.scaleAndAddToRef(r.Quaternion.Dot(C,l)>0?I:-I,C),g.scaleAndAddToRef(I,b)}C.normalize()}for(let y=0;y<q.additiveAnimations.length;y++){const S=q.additiveAnimations[y];if(0===S.weight)continue;const v=r.TmpVectors.yS[2],U=r.TmpVectors.yS[3],g=r.TmpVectors.Quaternion[1];S.currentValue.decompose(U,g,v),U.multiplyToRef(z,U),r.yS.LerpToRef(z,U,S.weight,z),C.multiplyToRef(g,g),r.Quaternion.SlerpToRef(C,g,S.weight,C),v.scaleAndAddToRef(S.weight,b)}const l=U?U._animationState.workValue:r.TmpVectors.Matrix[0].clone();return r.Matrix.ComposeToRef(z,C,b,l),l}function R(q,S){if(0===q.totalWeight&&0===q.totalAdditiveWeight)return S;const b=q.animations[0],z=q.originalValue;let C=S;if(0===q.totalWeight&&q.totalAdditiveWeight>0)C.v(z);else if(1===q.animations.length){if(r.Quaternion.SlerpToRef(z,b.currentValue,Math.min(1,q.totalWeight),C),0===q.totalAdditiveWeight)return C}else if(q.animations.length>1){let b,v,U=1;if(q.totalWeight<1){const S=1-q.totalWeight;b=[],v=[],b.push(z),v.push(S)}else{if(2===q.animations.length&&(r.Quaternion.SlerpToRef(q.animations[0].currentValue,q.animations[1].currentValue,q.animations[1].weight/q.totalWeight,S),0===q.totalAdditiveWeight))return S;b=[],v=[],U=q.totalWeight}for(let S=0;S<q.animations.length;S++){const z=q.animations[S];b.push(z.currentValue),v.push(z.weight/U)}let g=0;for(let q=0;q<b.length;)q?(g+=v[q],r.Quaternion.SlerpToRef(C,b[q],v[q]/g,C),q++):(r.Quaternion.SlerpToRef(b[q],b[q+1],v[q+1]/(v[q]+v[q+1]),S),C=S,g=v[q]+v[q+1],q+=2)}for(let v=0;v<q.additiveAnimations.length;v++){const S=q.additiveAnimations[v];0!==S.weight&&(C.multiplyToRef(S.currentValue,r.TmpVectors.Quaternion[0]),r.Quaternion.SlerpToRef(C,r.TmpVectors.Quaternion[0],S.weight,C))}return C}var G,Z,H=b(11339);G=H.c,(Z=g.b)&&(Z.prototype.copyAnimationRange=function(q,S,b){let C=arguments.length>3&&void 0!==arguments[3]&&arguments[3],v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new z.d(this.name,"_matrix",q.animations[0].framePerSecond,z.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const U=q.animations[0].getRange(S);if(!U)return!1;const g=U.from,r=U.to,I=q.animations[0].getKeys(),V=q.length,l=q.getParent(),y=this.getParent(),R=C&&l&&V&&this.length&&V!==this.length,G=R&&y&&l?y.length/l.length:1,Z=C&&!y&&v&&(1!==v.x||1!==v.y||1!==v.z),H=this.animations[0].getKeys();let Q,k,W;for(let z=0,N=I.length;z<N;z++)Q=I[z],Q.frame>=g&&Q.frame<=r&&(C?(W=Q.value.clone(),R?(k=W.getTranslation(),W.setTranslation(k.scaleInPlace(G))):Z&&v?(k=W.getTranslation(),W.setTranslation(k.multiplyInPlace(v))):W=Q.value):W=Q.value,H.push({frame:Q.frame+b,value:W}));return this.animations[0].createRange(S,g+b,r+b),!0}),G&&(G.prototype._animate=function(q){if(!this.animationsEnabled)return;const S=V.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=S}this.deltaTime=void 0!==q?q:this.useConstantAnimationDeltaTime?16:(S-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=S;const b=this._activeAnimatables;if(0===b.length)return;this._animationTime+=this.deltaTime;const C=this._animationTime;for(let z=0;z<b.length;z++){const q=b[z];!q._animate(C)&&q.disposeOnEnd&&z--}!function(q){if(q._registeredForLateAnimationBindings.length){for(let S=0;S<q._registeredForLateAnimationBindings.length;S++){const b=q._registeredForLateAnimationBindings.data[S];for(const q in b._lateAnimationHolders){const S=b._lateAnimationHolders[q],C=S.animations[0],v=S.originalValue;if(void 0===v||null===v)continue;const U=z.d.AllowMatrixDecomposeForInterpolation&&v.m;let g=b[q];if(U)g=y(S);else if(void 0!==v.w)g=R(S,g||r.Quaternion.Identity());else{let q=0,b=1;const U=C&&C._animationState.loopMode===z.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(S.totalWeight<1)g=U?v.clone?v.clone():v:C&&v.scale?v.scale(1-S.totalWeight):C?v*(1-S.totalWeight):v.clone?v.clone():v;else if(C){b=S.totalWeight;const z=C.weight/b;g=1!==z?C.currentValue.scale?C.currentValue.scale(z):C.currentValue*z:C.currentValue,U&&(g.addToRef?g.addToRef(v,g):g+=v),q=1}for(let z=q;z<S.animations.length;z++){const q=S.animations[z],C=q.weight/b;C&&(q.currentValue.scaleAndAddToRef?q.currentValue.scaleAndAddToRef(C,g):g+=q.currentValue*C)}for(let z=0;z<S.additiveAnimations.length;z++){const q=S.additiveAnimations[z],b=q.weight;b&&(q.currentValue.scaleAndAddToRef?q.currentValue.scaleAndAddToRef(b,g):g+=q.currentValue*b)}}b[q]=g}b._lateAnimationHolders={}}q._registeredForLateAnimationBindings.reset()}}(this)},G.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((q,S)=>q.playOrder-S.playOrder))},G.prototype.beginWeightedAnimation=function(q,S,b){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,C=arguments.length>4?arguments[4]:void 0,v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,U=arguments.length>6?arguments[6]:void 0,g=arguments.length>7?arguments[7]:void 0,r=arguments.length>8?arguments[8]:void 0,I=arguments.length>9?arguments[9]:void 0,V=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const l=this.beginAnimation(q,S,b,C,v,U,g,!1,r,I,V);return l.weight=z,l},G.prototype.beginAnimation=function(q,S,b,z){let C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,v=arguments.length>5?arguments[5]:void 0,U=arguments.length>6?arguments[6]:void 0,g=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],r=arguments.length>8?arguments[8]:void 0,I=arguments.length>9?arguments[9]:void 0,V=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(C<0){const q=S;S=b,b=q,C=-C}S>b&&(C=-C),g&&this.stopAnimation(q,void 0,r),U||(U=new l(this,q,S,b,z,C,v,void 0,I,V));const y=!r||r(q);if(q.animations&&y&&U.appendAnimations(q,q.animations),q.getAnimatables){const V=q.getAnimatables();for(let q=0;q<V.length;q++)this.beginAnimation(V[q],S,b,z,C,v,U,g,r,I)}return U.reset(),U},G.prototype.beginHierarchyAnimation=function(q,S,b,z,C){let v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,U=arguments.length>6?arguments[6]:void 0,g=arguments.length>7?arguments[7]:void 0,r=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],I=arguments.length>9?arguments[9]:void 0,V=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const l=q.getDescendants(S),y=[];y.push(this.beginAnimation(q,b,z,C,v,U,g,r,I,void 0,V));for(const R of l)y.push(this.beginAnimation(R,b,z,C,v,U,g,r,I,void 0,V));return y},G.prototype.beginDirectAnimation=function(q,S,b,z,C){let v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(v<0){const q=b;b=z,z=q,v=-v}return b>z&&(v=-v),new l(this,q,b,z,C,v,arguments.length>6?arguments[6]:void 0,S,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},G.prototype.beginDirectHierarchyAnimation=function(q,S,b,z,C,v,U,g,r){let I=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const V=q.getDescendants(S),l=[];l.push(this.beginDirectAnimation(q,b,z,C,v,U,g,r,I));for(const y of V)l.push(this.beginDirectAnimation(y,b,z,C,v,U,g,r,I));return l},G.prototype.getAnimatableByTarget=function(q){for(let S=0;S<this._activeAnimatables.length;S++)if(this._activeAnimatables[S].target===q)return this._activeAnimatables[S];return null},G.prototype.getAllAnimatablesByTarget=function(q){const S=[];for(let b=0;b<this._activeAnimatables.length;b++)this._activeAnimatables[b].target===q&&S.push(this._activeAnimatables[b]);return S},G.prototype.stopAnimation=function(q,S,b){const z=this.getAllAnimatablesByTarget(q);for(const C of z)C.stop(S,b)},G.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let q=0;q<this._activeAnimatables.length;q++)this._activeAnimatables[q].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const q of this.animationGroups)q.stop()});class Q{getClassName(){return"TargetedAnimation"}serialize(){const q={};return q.animation=this.animation.serialize(),q.targetId=this.target.id,q}}class k{get mask(){return this._mask}set mask(q){this._mask!==q&&(this._mask=q,this.syncWithMask(!0))}syncWithMask(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||q){this._numActiveAnimatables=0;for(let q=0;q<this._animatables.length;++q){const S=this._animatables[q];!this.mask||this.mask.disabled||this.mask.retainsTarget(S.target.name)?(this._numActiveAnimatables++,S.paused&&S.restart()):S.paused||S.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let q=0;q<this._animatables.length;++q){const S=this._animatables[q];this.mask.retainsTarget(S.target.name)||(S.stop(),this._animatables.splice(q,1),--q)}for(let q=0;q<this._targetedAnimations.length;q++){const S=this._targetedAnimations[q];this.mask.retainsTarget(S.target.name)||(this._targetedAnimations.splice(q,1),--q)}}}get from(){return this._from}set from(q){if(this._from!==q){this._from=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].fromFrame=this._from}}}get to(){return this._to}set to(q){if(this._to!==q){this._to=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(q){if(this._speedRatio!==q){this._speedRatio=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(q){if(this._loopAnimation!==q){this._loopAnimation=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(q){if(this._isAdditive!==q){this._isAdditive=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(q){this._weight!==q&&(this._weight=q,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(q){if(this._playOrder!==q&&(this._playOrder=q,this._animatables.length>0)){for(let q=0;q<this._animatables.length;q++)this._animatables[q].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(q){if(this._enableBlending!==q&&(this._enableBlending=q,null!==q))for(let S=0;S<this._targetedAnimations.length;++S)this._targetedAnimations[S].animation.enableBlending=q}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(q){if(this._blendingSpeed!==q&&(this._blendingSpeed=q,null!==q))for(let S=0;S<this._targetedAnimations.length;++S)this._targetedAnimations[S].animation.blendingSpeed=q}getLength(q,S){q=q??this._from;return((S=S??this._to)-q)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(q){let S=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=arguments.length>3?arguments[3]:void 0;if(0===q.length)return null;z=z??q[0].weight;let C=Number.MAX_VALUE,v=-Number.MAX_VALUE;if(b)for(const g of q)g.from<C&&(C=g.from),g.to>v&&(v=g.to);const U=new k(q[0].name+"_merged",q[0]._scene,z);for(const g of q){b&&g.normalize(C,v);for(const q of g.targetedAnimations)U.addTargetedAnimation(q.animation,q.target);S&&g.dispose()}return U}constructor(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=q,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new C.d,this.onAnimationLoopObservable=new C.d,this.onAnimationGroupLoopObservable=new C.d,this.onAnimationGroupEndObservable=new C.d,this.onAnimationGroupPauseObservable=new C.d,this.onAnimationGroupPlayObservable=new C.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=S||v.b.LastCreatedScene,this._weight=b,this._playOrder=z,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(q,S){const b=new Q;b.animation=q,b.target=S;const z=q.getKeys();return this._from>z[0].frame&&(this._from=z[0].frame),this._to<z[z.length-1].frame&&(this._to=z[z.length-1].frame),null!==this._enableBlending&&(q.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(q.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(b),this._shouldStart=!0,b}removeTargetedAnimation(q){for(let S=this._targetedAnimations.length-1;S>-1;S--){this._targetedAnimations[S].animation===q&&this._targetedAnimations.splice(S,1)}}normalize(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==q&&(q=this._from),null==S&&(S=this._to);for(let b=0;b<this._targetedAnimations.length;b++){const z=this._targetedAnimations[b].animation.getKeys(),C=z[0],v=z[z.length-1];if(C.frame>q){const S={frame:q,value:C.value,inTangent:C.inTangent,outTangent:C.outTangent,interpolation:C.interpolation};z.splice(0,0,S)}if(v.frame<S){const q={frame:S,value:v.value,inTangent:v.inTangent,outTangent:v.outTangent,interpolation:v.interpolation};z.push(q)}}return this._from=q,this._to=S,this}_processLoop(q,S,b){q.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(S),this._animationLoopFlags[b]||(this._animationLoopFlags[b]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0],S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0,z=arguments.length>3?arguments[3]:void 0,C=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=q,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let v=0;v<this._targetedAnimations.length;v++){const U=this._targetedAnimations[v],g=this._scene.beginDirectAnimation(U.target,[U.animation],void 0!==b?b:this._from,void 0!==z?z:this._to,q,S,void 0,void 0,void 0!==C?C:this._isAdditive);g.weight=this._weight,g.playOrder=this._playOrder,g.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(U),this._checkAnimationGroupEnded(g)},this._processLoop(g,U,v),this._animatables.push(g)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=S,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let q=0;q<this._animatables.length;q++){this._animatables[q].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(q){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==q&&(this.loopAnimation=q),this.restart()):(this.stop(),this.start(q,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].reset()}return this}restart(){if(!this._isStarted)return this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const S=this._animatables.slice();for(let z=0;z<S.length;z++)S[z].stop(void 0,void 0,!0,q);let b=0;for(let z=0;z<this._scene._activeAnimatables.length;z++){const S=this._scene._activeAnimatables[z];S._runtimeAnimations.length>0?this._scene._activeAnimatables[b++]=S:q&&this._checkAnimationGroupEnded(S,q)}return this._scene._activeAnimatables.length=b,this._isStarted=!1,this}setWeightForAllAnimatables(q){for(let S=0;S<this._animatables.length;S++){this._animatables[S].weight=q}return this}syncAllAnimationsWith(q){for(let S=0;S<this._animatables.length;S++){this._animatables[S].syncWith(q)}return this}goToFrame(q){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].goToFrame(q,S)}return this}getCurrentFrame(){var q;return(null===(q=this.animatables[0])||void 0===q?void 0:q.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const q=this._scene.animationGroups.indexOf(this);if(q>-1&&this._scene.animationGroups.splice(q,1),this._parentContainer){const q=this._parentContainer.animationGroups.indexOf(this);q>-1&&this._parentContainer.animationGroups.splice(q,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(q){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._animatables.indexOf(q);b>-1&&this._animatables.splice(b,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,S||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(q,S){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const z=new k(q||this.name,this._scene,this._weight,this._playOrder);z._from=this.from,z._to=this.to,z._speedRatio=this.speedRatio,z._loopAnimation=this.loopAnimation,z._isAdditive=this.isAdditive,z._enableBlending=this.enableBlending,z._blendingSpeed=this.blendingSpeed,z.metadata=this.metadata,z.mask=this.mask;for(const C of this._targetedAnimations)z.addTargetedAnimation(b?C.animation.clone():C.animation,S?S(C.target):C.target);return z}serialize(){const q={};q.name=this.name,q.from=this.from,q.to=this.to,q.speedRatio=this.speedRatio,q.loopAnimation=this.loopAnimation,q.isAdditive=this.isAdditive,q.weight=this.weight,q.playOrder=this.playOrder,q.enableBlending=this.enableBlending,q.blendingSpeed=this.blendingSpeed,q.targetedAnimations=[];for(let S=0;S<this.targetedAnimations.length;S++){const b=this.targetedAnimations[S];q.targetedAnimations[S]=b.serialize()}return U.b&&U.b.HasTags(this)&&(q.tags=U.b.GetTags(this)),this.metadata&&(q.metadata=this.metadata),q}static Parse(q,S){const b=new k(q.name,S,q.weight,q.playOrder);for(let C=0;C<q.targetedAnimations.length;C++){const v=q.targetedAnimations[C],U=z.d.Parse(v.animation),g=v.targetId;if("influence"===v.animation.property){const q=S.getMorphTargetById(g);q&&b.addTargetedAnimation(U,q)}else{const q=S.getNodeById(g);null!=q&&b.addTargetedAnimation(U,q)}}return U.b&&U.b.AddTagsTo(b,q.tags),null!==q.from&&null!==q.to&&b.normalize(q.from,q.to),void 0!==q.speedRatio&&(b._speedRatio=q.speedRatio),void 0!==q.loopAnimation&&(b._loopAnimation=q.loopAnimation),void 0!==q.isAdditive&&(b._isAdditive=q.isAdditive),void 0!==q.weight&&(b._weight=q.weight),void 0!==q.playOrder&&(b._playOrder=q.playOrder),void 0!==q.enableBlending&&(b._enableBlending=q.enableBlending),void 0!==q.blendingSpeed&&(b._blendingSpeed=q.blendingSpeed),void 0!==q.metadata&&(b.metadata=q.metadata),b}static MakeAnimationAdditive(q,S,b){let C;C="object"===typeof S?S:{referenceFrame:S,range:b,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let v=q;C.cloneOriginalAnimationGroup&&(v=q.clone(C.clonedAnimationGroupName||v.name));const U=v.targetedAnimations;for(let g=0;g<U.length;g++){const q=U[g];q.animation=z.d.MakeAnimationAdditive(q.animation,C)}if(v.isAdditive=!0,C.clipKeys){let q=Number.MAX_VALUE,S=-Number.MAX_VALUE;const b=v.targetedAnimations;for(let z=0;z<b.length;z++){const C=b[z].animation.getKeys();q>C[0].frame&&(q=C[0].frame),S<C[C.length-1].frame&&(S=C[C.length-1].frame)}v._from=q,v._to=S}return v}static ClipKeys(q,S,b,z,C){const v=q.clone(z||q.name);return k.ClipKeysInPlace(v,S,b,C)}static ClipKeysInPlace(q,S,b,z){return k.ClipInPlace(q,S,b,z,!1)}static ClipFrames(q,S,b,z,C){const v=q.clone(z||q.name);return k.ClipFramesInPlace(v,S,b,C)}static ClipFramesInPlace(q,S,b,z){return k.ClipInPlace(q,S,b,z,!0)}static ClipInPlace(q,S,b,z){let C=arguments.length>4&&void 0!==arguments[4]&&arguments[4],v=Number.MAX_VALUE,U=-Number.MAX_VALUE;const g=q.targetedAnimations;for(let r=0;r<g.length;r++){const q=g[r],I=z?q.animation:q.animation.clone();C&&(I.createKeyForFrame(S),I.createKeyForFrame(b));const V=I.getKeys(),l=[];let y=Number.MAX_VALUE;for(let z=0;z<V.length;z++){const q=V[z];if(!C&&z>=S&&z<=b||C&&q.frame>=S&&q.frame<=b){const S={frame:q.frame,value:q.value.clone?q.value.clone():q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation,lockedTangent:q.lockedTangent};y===Number.MAX_VALUE&&(y=S.frame),S.frame-=y,l.push(S)}}0!==l.length?(v>l[0].frame&&(v=l[0].frame),U<l[l.length-1].frame&&(U=l[l.length-1].frame),I.setKeys(l,!0),q.animation=I):(g.splice(r,1),r--)}return q._from=v,q._to=U,q}getClassName(){return"AnimationGroup"}toString(q){let S="Name: "+this.name;return S+=", type: "+this.getClassName(),q&&(S+=", from: "+this._from,S+=", to: "+this._to,S+=", isStarted: "+this._isStarted,S+=", speedRatio: "+this._speedRatio,S+=", targetedAnimations length: "+this._targetedAnimations.length,S+=", animatables length: "+this._animatables),S}}}}]);