"use strict";(self.vb3rpbgyozo=self.vb3rpbgyozo||[]).push([[78],{15931:(q,I,l)=>{l.r(I),l.d(I,{AnimationGroup:()=>B,TargetedAnimation:()=>U});var w=l(13247),t=l(12573),O=l(12612),c=l(12786),a=l(14371),F=l(12747);class s{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(q,I,l,t){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=I,this._target=q,this._scene=l,this._host=t,this._activeTargets=[],I._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===w.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=F.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const q={frame:0,value:this._minValue};this._keys.splice(0,0,q)}if(this._target instanceof Array){let q=0;for(const I of this._target)this._preparePath(I,q),this._getOriginalValues(q),q++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const O=I.getEvents();if(O&&O.length>0)for(const w of O)this._events.push(w._clone());this._enableBlending=q&&q.animationPropertiesOverride?q.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const l=this._animation.targetPropertyPath;if(l.length>1){let w=q;for(let q=0;q<l.length-1;q++){const I=l[q];if(w=w[I],void 0===w)throw new Error(`Invalid property (${I}) in property path (${l.join(".")})`)}this._targetPath=l[l.length-1],this._activeTargets[I]=w}else this._targetPath=l[0],this._activeTargets[I]=q;if(void 0===this._activeTargets[I][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${l.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let q=0;for(const I of this._target)void 0!==this._originalValue[q]&&this._setValue(I,this._activeTargets[q],this._originalValue[q],-1,q),q++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let q=0;q<this._events.length;q++)this._events[q].isDone=!1}isStopped(){return this._stopped}dispose(){const q=this._animation.runtimeAnimations.indexOf(this);q>-1&&this._animation.runtimeAnimations.splice(q,1)}setValue(q,I){if(this._targetIsArray)for(let l=0;l<this._target.length;l++){const w=this._target[l];this._setValue(w,this._activeTargets[l],q,I,l)}else this._setValue(this._target,this._directTarget,q,I,0)}_getOriginalValues(){let q,I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const l=this._activeTargets[I];q=l.getLocalMatrix&&"_matrix"===this._targetPath?l.getLocalMatrix():l[this._targetPath],q&&q.clone?this._originalValue[I]=q.clone():this._originalValue[I]=q}_registerTargetForLateAnimationBinding(q,I){const l=q.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(l),l._lateAnimationHolders||(l._lateAnimationHolders={}),l._lateAnimationHolders[q.targetPath]||(l._lateAnimationHolders[q.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:I}),q.isAdditive?(l._lateAnimationHolders[q.targetPath].additiveAnimations.push(q),l._lateAnimationHolders[q.targetPath].totalAdditiveWeight+=q.weight):(l._lateAnimationHolders[q.targetPath].animations.push(q),l._lateAnimationHolders[q.targetPath].totalWeight+=q.weight)}_setValue(q,I,l,t,O){if(this._currentActiveTarget=I,this._weight=t,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const q=I[this._targetPath];q.clone?this._originalBlendValue=q.clone():this._originalBlendValue=q}this._originalBlendValue.m?w.d.AllowMatrixDecomposeForInterpolation?this._currentValue?F.Matrix.DecomposeLerpToRef(this._originalBlendValue,l,this._blendingFactor,this._currentValue):this._currentValue=F.Matrix.DecomposeLerp(this._originalBlendValue,l,this._blendingFactor):this._currentValue?F.Matrix.LerpToRef(this._originalBlendValue,l,this._blendingFactor,this._currentValue):this._currentValue=F.Matrix.Lerp(this._originalBlendValue,l,this._blendingFactor):this._currentValue=w.d._UniversalLerp(this._originalBlendValue,l,this._blendingFactor);const t=q&&q.animationPropertiesOverride?q.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=t}else this._currentValue?this._currentValue.t?this._currentValue.t(l):this._currentValue=l:null!==l&&void 0!==l&&l.clone?this._currentValue=l.clone():this._currentValue=l;-1!==t?this._registerTargetForLateAnimationBinding(this,this._originalValue[O]):this._animationState.loopMode===w.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[O],I[this._targetPath]):I[this._targetPath]=this._originalValue[O]+this._currentValue:I[this._targetPath]=this._currentValue,q.TZ&&q.TZ(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const l=this._animation.getKeys();q<l[0].frame?q=l[0].frame:q>l[l.length-1].frame&&(q=l[l.length-1].frame);const w=this._events;if(w.length)for(let O=0;O<w.length;O++)w[O].onlyOnce||(w[O].isDone=w[O].frame<q);this._currentFrame=q;const t=this._animation._interpolate(q,this._animationState);this.setValue(t,I)}_prepareForSpeedRatioChange(q){const I=this._previousElapsedTime*(this._animation.framePerSecond*q)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-I}animate(q,I,l,t,O){let c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const a=this._animation,F=a.targetPropertyPath;if(!F||F.length<1)return this._stopped=!0,!1;let s,Z=!0;const r=this._events;let x=0;if(this._coreRuntimeAnimation)x=l-I,s=this._coreRuntimeAnimation.currentFrame,this._currentFrame=s,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let c;(I<this._minFrame||I>this._maxFrame)&&(I=this._minFrame),(l<this._minFrame||l>this._maxFrame)&&(l=this._maxFrame),x=l-I;let F=q*(a.framePerSecond*O)/1e3+this._absoluteFrameOffset,o=0,d=!1;const T=t&&this._animationState.loopMode===w.d.ANIMATIONLOOPMODE_YOYO;if(T){const q=(F-I)/x,l=Math.sin(q*Math.PI);F=Math.abs(l)*x+I;const w=l>=0?1:-1;this._yoyoDirection!==w&&(d=!0),this._yoyoDirection=w}if(this._previousElapsedTime=q,this._previousAbsoluteFrame=F,!t&&l>=I&&(F>=x&&O>0||F<=0&&O<0))Z=!1,o=a._getKeyValue(this._maxValue);else if(!t&&I>=l&&(F<=x&&O<0||F>=0&&O>0))Z=!1,o=a._getKeyValue(this._minValue);else if(this._animationState.loopMode!==w.d.ANIMATIONLOOPMODE_CYCLE){const q=l.toString()+I.toString();if(!this._offsetsCache[q]){this._animationState.repeatCount=0,this._animationState.loopMode=w.d.ANIMATIONLOOPMODE_CYCLE;const t=a._interpolate(I,this._animationState),O=a._interpolate(l,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),a.dataType){case w.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[q]=O-t;break;case w.d.ANIMATIONTYPE_QUATERNION:case w.d.ANIMATIONTYPE_VECTOR3:case w.d.ANIMATIONTYPE_VECTOR2:case w.d.ANIMATIONTYPE_SIZE:case w.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[q]=O.TI(t)}this._highLimitsCache[q]=O}o=this._highLimitsCache[q],c=this._offsetsCache[q]}if(void 0===c)switch(a.dataType){case w.d.ANIMATIONTYPE_FLOAT:c=0;break;case w.d.ANIMATIONTYPE_QUATERNION:c=w.k;break;case w.d.ANIMATIONTYPE_VECTOR3:c=w.r;break;case w.d.ANIMATIONTYPE_VECTOR2:c=w.n;break;case w.d.ANIMATIONTYPE_SIZE:c=w.m;break;case w.d.ANIMATIONTYPE_COLOR3:c=w.g;break;case w.d.ANIMATIONTYPE_COLOR4:c=w.i}if(this._host&&this._host.syncRoot){const q=this._host.syncRoot;s=I+x*((q.masterFrame-q.fromFrame)/(q.toFrame-q.fromFrame))}else s=F>0&&I>l||F<0&&I<l?Z&&0!==x?l+F%x:I:Z&&0!==x?I+F%x:l;if(!T&&(O>0&&this.currentFrame>s||O<0&&this.currentFrame<s)||T&&d){this._onLoop();for(let q=0;q<r.length;q++)r[q].onlyOnce||(r[q].isDone=!1);this._animationState.key=O>0?0:a.getKeys().length-1}this._currentFrame=s,this._animationState.repeatCount=0===x?0:F/x|0,this._animationState.highLimitValue=o,this._animationState.offsetValue=c}const o=a._interpolate(s,this._animationState);if(this.setValue(o,c),r.length)for(let w=0;w<r.length;w++)if(x>=0&&s>=r[w].frame&&r[w].frame>=I||x<0&&s<=r[w].frame&&r[w].frame<=I){const q=r[w];q.isDone||(q.onlyOnce&&(r.splice(w,1),w--),q.isDone=!0,q.action(s))}return Z||(this._stopped=!0),Z}}var Z=l(12601);class r{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(q){this._weight=-1!==q?Math.min(Math.max(q,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(q){for(let I=0;I<this._runtimeAnimations.length;I++){this._runtimeAnimations[I]._prepareForSpeedRatioChange(q)}this._speedRatio=q,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(q,I){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,O=arguments.length>4&&void 0!==arguments[4]&&arguments[4],c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,a=arguments.length>6?arguments[6]:void 0,F=arguments.length>7?arguments[7]:void 0,s=arguments.length>8?arguments[8]:void 0,Z=arguments.length>9&&void 0!==arguments[9]&&arguments[9],r=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=I,this.fromFrame=l,this.toFrame=w,this.loopAnimation=O,this.onAnimationEnd=a,this.onAnimationLoop=s,this.isAdditive=Z,this.playOrder=r,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.za=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new t.d,this.onAnimationLoopObservable=new t.d,this._scene=q,F&&this.appendAnimations(I,F),this._speedRatio=c,q._activeAnimatables.push(this)}syncWith(q){if(this._syncRoot=q,q){const q=this._scene._activeAnimatables.indexOf(this);q>-1&&(this._scene._activeAnimatables.splice(q,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(q,I){for(let l=0;l<I.length;l++){const w=I[l],t=new s(q,w,this._scene,this);t._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(t)}}getAnimationByTargetProperty(q){const I=this._runtimeAnimations;for(let l=0;l<I.length;l++)if(I[l].animation.targetProperty===q)return I[l].animation;return null}getRuntimeAnimationByTargetProperty(q){const I=this._runtimeAnimations;for(let l=0;l<I.length;l++)if(I[l].animation.targetProperty===q)return I[l];return null}reset(){const q=this._runtimeAnimations;for(let I=0;I<q.length;I++)q[I].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(q){const I=this._runtimeAnimations;for(let l=0;l<I.length;l++)I[l].animation.enableBlending=!0,I[l].animation.blendingSpeed=q}disableBlending(){const q=this._runtimeAnimations;for(let I=0;I<q.length;I++)q[I].animation.enableBlending=!1}goToFrame(q){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const l=this._runtimeAnimations;if(l[0]){const I=l[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??l[0].currentFrame;const w=0===this.speedRatio?0:(q-this._frameToSyncFromJump)/I*1e3/this.speedRatio;this._manualJumpDelay=-w}for(let w=0;w<l.length;w++)l[w].goToFrame(q,I?this._weight:-1);this._goToFrame=q}get paused(){return this.za}pause(){this.za||(this.za=!0)}restart(){this.za=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(q,I){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],w=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(q||I){const t=this._scene._activeAnimatables.indexOf(this);if(t>-1){const O=this._runtimeAnimations;for(let l=O.length-1;l>=0;l--){const w=O[l];q&&w.animation.name!=q||(I&&!I(w.target)||(w.dispose(),O.splice(l,1)))}0==O.length&&(l||this._scene._activeAnimatables.splice(t,1),w||this._raiseOnAnimationEnd())}}else{const q=this._scene._activeAnimatables.indexOf(this);if(q>-1){l||this._scene._activeAnimatables.splice(q,1);const I=this._runtimeAnimations;for(let q=0;q<I.length;q++)I[q].dispose();this._runtimeAnimations.length=0,w||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((q=>{this.onAnimationEndObservable.add((()=>{q(this)}),void 0,void 0,this,!0)}))}_animate(q){if(this.za)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=q),!0;if(null===this._localDelayOffset?(this._localDelayOffset=q,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=q-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let I=!1;const l=this._runtimeAnimations;let w;for(w=0;w<l.length;w++){const t=l[w].animate(q-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);I=I||t}if(this.animationStarted=I,!I){if(this.disposeOnEnd)for(w=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(w,1),w=0;w<l.length;w++)l[w].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return I}}function x(q){if(0===q.totalWeight&&0===q.totalAdditiveWeight)return q.originalValue;let I=1;const l=F.TmpVectors.dI[0],w=F.TmpVectors.dI[1],t=F.TmpVectors.Quaternion[0];let O=0;const c=q.animations[0],a=q.originalValue;let s=1,Z=!1;if(q.totalWeight<1)s=1-q.totalWeight,a.decompose(w,t,l);else{if(O=1,I=q.totalWeight,s=c.weight/I,1==s){if(!q.totalAdditiveWeight)return c.currentValue;Z=!0}c.currentValue.decompose(w,t,l)}if(!Z){w.scaleInPlace(s),l.scaleInPlace(s),t.scaleInPlace(s);for(let c=O;c<q.animations.length;c++){const O=q.animations[c];if(0===O.weight)continue;s=O.weight/I;const a=F.TmpVectors.dI[2],Z=F.TmpVectors.dI[3],r=F.TmpVectors.Quaternion[1];O.currentValue.decompose(Z,r,a),Z.scaleAndAddToRef(s,w),r.scaleAndAddToRef(F.Quaternion.Dot(t,r)>0?s:-s,t),a.scaleAndAddToRef(s,l)}t.normalize()}for(let x=0;x<q.additiveAnimations.length;x++){const I=q.additiveAnimations[x];if(0===I.weight)continue;const O=F.TmpVectors.dI[2],c=F.TmpVectors.dI[3],a=F.TmpVectors.Quaternion[1];I.currentValue.decompose(c,a,O),c.multiplyToRef(w,c),F.dI.LerpToRef(w,c,I.weight,w),t.multiplyToRef(a,a),F.Quaternion.SlerpToRef(t,a,I.weight,t),O.scaleAndAddToRef(I.weight,l)}const r=c?c._animationState.workValue:F.TmpVectors.Matrix[0].clone();return F.Matrix.ComposeToRef(w,t,l,r),r}function o(q,I){if(0===q.totalWeight&&0===q.totalAdditiveWeight)return I;const l=q.animations[0],w=q.originalValue;let t=I;if(0===q.totalWeight&&q.totalAdditiveWeight>0)t.t(w);else if(1===q.animations.length){if(F.Quaternion.SlerpToRef(w,l.currentValue,Math.min(1,q.totalWeight),t),0===q.totalAdditiveWeight)return t}else if(q.animations.length>1){let l,O,c=1;if(q.totalWeight<1){const I=1-q.totalWeight;l=[],O=[],l.push(w),O.push(I)}else{if(2===q.animations.length&&(F.Quaternion.SlerpToRef(q.animations[0].currentValue,q.animations[1].currentValue,q.animations[1].weight/q.totalWeight,I),0===q.totalAdditiveWeight))return I;l=[],O=[],c=q.totalWeight}for(let I=0;I<q.animations.length;I++){const w=q.animations[I];l.push(w.currentValue),O.push(w.weight/c)}let a=0;for(let q=0;q<l.length;)q?(a+=O[q],F.Quaternion.SlerpToRef(t,l[q],O[q]/a,t),q++):(F.Quaternion.SlerpToRef(l[q],l[q+1],O[q+1]/(O[q]+O[q+1]),I),t=I,a=O[q]+O[q+1],q+=2)}for(let O=0;O<q.additiveAnimations.length;O++){const I=q.additiveAnimations[O];0!==I.weight&&(t.multiplyToRef(I.currentValue,F.TmpVectors.Quaternion[0]),F.Quaternion.SlerpToRef(t,F.TmpVectors.Quaternion[0],I.weight,t))}return t}var d,T,V=l(12987);d=V.e,(T=a.e)&&(T.prototype.copyAnimationRange=function(q,I,l){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3],O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new w.d(this.name,"_matrix",q.animations[0].framePerSecond,w.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const c=q.animations[0].getRange(I);if(!c)return!1;const a=c.from,F=c.to,s=q.animations[0].getKeys(),Z=q.length,r=q.getParent(),x=this.getParent(),o=t&&r&&Z&&this.length&&Z!==this.length,d=o&&x&&r?x.length/r.length:1,T=t&&!x&&O&&(1!==O.x||1!==O.y||1!==O.z),V=this.animations[0].getKeys();let U,B,v;for(let w=0,k=s.length;w<k;w++)U=s[w],U.frame>=a&&U.frame<=F&&(t?(v=U.value.clone(),o?(B=v.getTranslation(),v.setTranslation(B.scaleInPlace(d))):T&&O?(B=v.getTranslation(),v.setTranslation(B.multiplyInPlace(O))):v=U.value):v=U.value,V.push({frame:U.frame+l,value:v}));return this.animations[0].createRange(I,a+l,F+l),!0}),d&&(d.prototype._animate=function(q){if(!this.animationsEnabled)return;const I=Z.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=I}this.deltaTime=void 0!==q?q:this.useConstantAnimationDeltaTime?16:(I-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=I;const l=this._activeAnimatables;if(0===l.length)return;this._animationTime+=this.deltaTime;const t=this._animationTime;for(let w=0;w<l.length;w++){const q=l[w];!q._animate(t)&&q.disposeOnEnd&&w--}!function(q){if(q._registeredForLateAnimationBindings.length){for(let I=0;I<q._registeredForLateAnimationBindings.length;I++){const l=q._registeredForLateAnimationBindings.data[I];for(const q in l._lateAnimationHolders){const I=l._lateAnimationHolders[q],t=I.animations[0],O=I.originalValue;if(void 0===O||null===O)continue;const c=w.d.AllowMatrixDecomposeForInterpolation&&O.m;let a=l[q];if(c)a=x(I);else if(void 0!==O.w)a=o(I,a||F.Quaternion.Identity());else{let q=0,l=1;const c=t&&t._animationState.loopMode===w.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(I.totalWeight<1)a=c?O.clone?O.clone():O:t&&O.scale?O.scale(1-I.totalWeight):t?O*(1-I.totalWeight):O.clone?O.clone():O;else if(t){l=I.totalWeight;const w=t.weight/l;a=1!==w?t.currentValue.scale?t.currentValue.scale(w):t.currentValue*w:t.currentValue,c&&(a.addToRef?a.addToRef(O,a):a+=O),q=1}for(let w=q;w<I.animations.length;w++){const q=I.animations[w],t=q.weight/l;t&&(q.currentValue.scaleAndAddToRef?q.currentValue.scaleAndAddToRef(t,a):a+=q.currentValue*t)}for(let w=0;w<I.additiveAnimations.length;w++){const q=I.additiveAnimations[w],l=q.weight;l&&(q.currentValue.scaleAndAddToRef?q.currentValue.scaleAndAddToRef(l,a):a+=q.currentValue*l)}}l[q]=a}l._lateAnimationHolders={}}q._registeredForLateAnimationBindings.reset()}}(this)},d.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((q,I)=>q.playOrder-I.playOrder))},d.prototype.beginWeightedAnimation=function(q,I,l){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,t=arguments.length>4?arguments[4]:void 0,O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,c=arguments.length>6?arguments[6]:void 0,a=arguments.length>7?arguments[7]:void 0,F=arguments.length>8?arguments[8]:void 0,s=arguments.length>9?arguments[9]:void 0,Z=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const r=this.beginAnimation(q,I,l,t,O,c,a,!1,F,s,Z);return r.weight=w,r},d.prototype.beginAnimation=function(q,I,l,w){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,O=arguments.length>5?arguments[5]:void 0,c=arguments.length>6?arguments[6]:void 0,a=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],F=arguments.length>8?arguments[8]:void 0,s=arguments.length>9?arguments[9]:void 0,Z=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(t<0){const q=I;I=l,l=q,t=-t}I>l&&(t=-t),a&&this.stopAnimation(q,void 0,F),c||(c=new r(this,q,I,l,w,t,O,void 0,s,Z));const x=!F||F(q);if(q.animations&&x&&c.appendAnimations(q,q.animations),q.getAnimatables){const Z=q.getAnimatables();for(let q=0;q<Z.length;q++)this.beginAnimation(Z[q],I,l,w,t,O,c,a,F,s)}return c.reset(),c},d.prototype.beginHierarchyAnimation=function(q,I,l,w,t){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,c=arguments.length>6?arguments[6]:void 0,a=arguments.length>7?arguments[7]:void 0,F=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],s=arguments.length>9?arguments[9]:void 0,Z=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const r=q.getDescendants(I),x=[];x.push(this.beginAnimation(q,l,w,t,O,c,a,F,s,void 0,Z));for(const o of r)x.push(this.beginAnimation(o,l,w,t,O,c,a,F,s,void 0,Z));return x},d.prototype.beginDirectAnimation=function(q,I,l,w,t){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(O<0){const q=l;l=w,w=q,O=-O}return l>w&&(O=-O),new r(this,q,l,w,t,O,arguments.length>6?arguments[6]:void 0,I,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},d.prototype.beginDirectHierarchyAnimation=function(q,I,l,w,t,O,c,a,F){let s=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const Z=q.getDescendants(I),r=[];r.push(this.beginDirectAnimation(q,l,w,t,O,c,a,F,s));for(const x of Z)r.push(this.beginDirectAnimation(x,l,w,t,O,c,a,F,s));return r},d.prototype.getAnimatableByTarget=function(q){for(let I=0;I<this._activeAnimatables.length;I++)if(this._activeAnimatables[I].target===q)return this._activeAnimatables[I];return null},d.prototype.getAllAnimatablesByTarget=function(q){const I=[];for(let l=0;l<this._activeAnimatables.length;l++)this._activeAnimatables[l].target===q&&I.push(this._activeAnimatables[l]);return I},d.prototype.stopAnimation=function(q,I,l){const w=this.getAllAnimatablesByTarget(q);for(const t of w)t.stop(I,l)},d.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let q=0;q<this._activeAnimatables.length;q++)this._activeAnimatables[q].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const q of this.animationGroups)q.stop()});class U{getClassName(){return"TargetedAnimation"}serialize(){const q={};return q.animation=this.animation.serialize(),q.targetId=this.target.id,q}}class B{get mask(){return this._mask}set mask(q){this._mask!==q&&(this._mask=q,this.syncWithMask(!0))}syncWithMask(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||q){this._numActiveAnimatables=0;for(let q=0;q<this._animatables.length;++q){const I=this._animatables[q];!this.mask||this.mask.disabled||this.mask.retainsTarget(I.target.name)?(this._numActiveAnimatables++,I.paused&&I.restart()):I.paused||I.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let q=0;q<this._animatables.length;++q){const I=this._animatables[q];this.mask.retainsTarget(I.target.name)||(I.stop(),this._animatables.splice(q,1),--q)}for(let q=0;q<this._targetedAnimations.length;q++){const I=this._targetedAnimations[q];this.mask.retainsTarget(I.target.name)||(this._targetedAnimations.splice(q,1),--q)}}}get from(){return this._from}set from(q){if(this._from!==q){this._from=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].fromFrame=this._from}}}get to(){return this._to}set to(q){if(this._to!==q){this._to=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(q){if(this._speedRatio!==q){this._speedRatio=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(q){if(this._loopAnimation!==q){this._loopAnimation=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(q){if(this._isAdditive!==q){this._isAdditive=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(q){this._weight!==q&&(this._weight=q,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(q){if(this._playOrder!==q&&(this._playOrder=q,this._animatables.length>0)){for(let q=0;q<this._animatables.length;q++)this._animatables[q].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(q){if(this._enableBlending!==q&&(this._enableBlending=q,null!==q))for(let I=0;I<this._targetedAnimations.length;++I)this._targetedAnimations[I].animation.enableBlending=q}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(q){if(this._blendingSpeed!==q&&(this._blendingSpeed=q,null!==q))for(let I=0;I<this._targetedAnimations.length;++I)this._targetedAnimations[I].animation.blendingSpeed=q}getLength(q,I){q=q??this._from;return((I=I??this._to)-q)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(q){let I=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],w=arguments.length>3?arguments[3]:void 0;if(0===q.length)return null;w=w??q[0].weight;let t=Number.MAX_VALUE,O=-Number.MAX_VALUE;if(l)for(const a of q)a.from<t&&(t=a.from),a.to>O&&(O=a.to);const c=new B(q[0].name+"_merged",q[0]._scene,w);for(const a of q){l&&a.normalize(t,O);for(const q of a.targetedAnimations)c.addTargetedAnimation(q.animation,q.target);I&&a.dispose()}return c}constructor(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=q,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new t.d,this.onAnimationLoopObservable=new t.d,this.onAnimationGroupLoopObservable=new t.d,this.onAnimationGroupEndObservable=new t.d,this.onAnimationGroupPauseObservable=new t.d,this.onAnimationGroupPlayObservable=new t.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=I||O.e.LastCreatedScene,this._weight=l,this._playOrder=w,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(q,I){const l=new U;l.animation=q,l.target=I;const w=q.getKeys();return this._from>w[0].frame&&(this._from=w[0].frame),this._to<w[w.length-1].frame&&(this._to=w[w.length-1].frame),null!==this._enableBlending&&(q.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(q.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(l),this._shouldStart=!0,l}removeTargetedAnimation(q){for(let I=this._targetedAnimations.length-1;I>-1;I--){this._targetedAnimations[I].animation===q&&this._targetedAnimations.splice(I,1)}}normalize(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==q&&(q=this._from),null==I&&(I=this._to);for(let l=0;l<this._targetedAnimations.length;l++){const w=this._targetedAnimations[l].animation.getKeys(),t=w[0],O=w[w.length-1];if(t.frame>q){const I={frame:q,value:t.value,inTangent:t.inTangent,outTangent:t.outTangent,interpolation:t.interpolation};w.splice(0,0,I)}if(O.frame<I){const q={frame:I,value:O.value,inTangent:O.inTangent,outTangent:O.outTangent,interpolation:O.interpolation};w.push(q)}}return this._from=q,this._to=I,this}_processLoop(q,I,l){q.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(I),this._animationLoopFlags[l]||(this._animationLoopFlags[l]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0],I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,l=arguments.length>2?arguments[2]:void 0,w=arguments.length>3?arguments[3]:void 0,t=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=q,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let O=0;O<this._targetedAnimations.length;O++){const c=this._targetedAnimations[O],a=this._scene.beginDirectAnimation(c.target,[c.animation],void 0!==l?l:this._from,void 0!==w?w:this._to,q,I,void 0,void 0,void 0!==t?t:this._isAdditive);a.weight=this._weight,a.playOrder=this._playOrder,a.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(c),this._checkAnimationGroupEnded(a)},this._processLoop(a,c,O),this._animatables.push(a)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=I,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let q=0;q<this._animatables.length;q++){this._animatables[q].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(q){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==q&&(this.loopAnimation=q),this.restart()):(this.stop(),this.start(q,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].reset()}return this}restart(){if(!this._isStarted)return this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const I=this._animatables.slice();for(let w=0;w<I.length;w++)I[w].stop(void 0,void 0,!0,q);let l=0;for(let w=0;w<this._scene._activeAnimatables.length;w++){const I=this._scene._activeAnimatables[w];I._runtimeAnimations.length>0?this._scene._activeAnimatables[l++]=I:q&&this._checkAnimationGroupEnded(I,q)}return this._scene._activeAnimatables.length=l,this._isStarted=!1,this}setWeightForAllAnimatables(q){for(let I=0;I<this._animatables.length;I++){this._animatables[I].weight=q}return this}syncAllAnimationsWith(q){for(let I=0;I<this._animatables.length;I++){this._animatables[I].syncWith(q)}return this}goToFrame(q){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let l=0;l<this._animatables.length;l++){this._animatables[l].goToFrame(q,I)}return this}getCurrentFrame(){var q;return(null===(q=this.animatables[0])||void 0===q?void 0:q.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const q=this._scene.animationGroups.indexOf(this);if(q>-1&&this._scene.animationGroups.splice(q,1),this._parentContainer){const q=this._parentContainer.animationGroups.indexOf(this);q>-1&&this._parentContainer.animationGroups.splice(q,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(q){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const l=this._animatables.indexOf(q);l>-1&&this._animatables.splice(l,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,I||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(q,I){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const w=new B(q||this.name,this._scene,this._weight,this._playOrder);w._from=this.from,w._to=this.to,w._speedRatio=this.speedRatio,w._loopAnimation=this.loopAnimation,w._isAdditive=this.isAdditive,w._enableBlending=this.enableBlending,w._blendingSpeed=this.blendingSpeed,w.metadata=this.metadata,w.mask=this.mask;for(const t of this._targetedAnimations)w.addTargetedAnimation(l?t.animation.clone():t.animation,I?I(t.target):t.target);return w}serialize(){const q={};q.name=this.name,q.from=this.from,q.to=this.to,q.speedRatio=this.speedRatio,q.loopAnimation=this.loopAnimation,q.isAdditive=this.isAdditive,q.weight=this.weight,q.playOrder=this.playOrder,q.enableBlending=this.enableBlending,q.blendingSpeed=this.blendingSpeed,q.targetedAnimations=[];for(let I=0;I<this.targetedAnimations.length;I++){const l=this.targetedAnimations[I];q.targetedAnimations[I]=l.serialize()}return c.e&&c.e.HasTags(this)&&(q.tags=c.e.GetTags(this)),this.metadata&&(q.metadata=this.metadata),q}static Parse(q,I){const l=new B(q.name,I,q.weight,q.playOrder);for(let t=0;t<q.targetedAnimations.length;t++){const O=q.targetedAnimations[t],c=w.d.Parse(O.animation),a=O.targetId;if("influence"===O.animation.property){const q=I.getMorphTargetById(a);q&&l.addTargetedAnimation(c,q)}else{const q=I.getNodeById(a);null!=q&&l.addTargetedAnimation(c,q)}}return c.e&&c.e.AddTagsTo(l,q.tags),null!==q.from&&null!==q.to&&l.normalize(q.from,q.to),void 0!==q.speedRatio&&(l._speedRatio=q.speedRatio),void 0!==q.loopAnimation&&(l._loopAnimation=q.loopAnimation),void 0!==q.isAdditive&&(l._isAdditive=q.isAdditive),void 0!==q.weight&&(l._weight=q.weight),void 0!==q.playOrder&&(l._playOrder=q.playOrder),void 0!==q.enableBlending&&(l._enableBlending=q.enableBlending),void 0!==q.blendingSpeed&&(l._blendingSpeed=q.blendingSpeed),void 0!==q.metadata&&(l.metadata=q.metadata),l}static MakeAnimationAdditive(q,I,l){let t;t="object"===typeof I?I:{referenceFrame:I,range:l,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let O=q;t.cloneOriginalAnimationGroup&&(O=q.clone(t.clonedAnimationGroupName||O.name));const c=O.targetedAnimations;for(let a=0;a<c.length;a++){const q=c[a];q.animation=w.d.MakeAnimationAdditive(q.animation,t)}if(O.isAdditive=!0,t.clipKeys){let q=Number.MAX_VALUE,I=-Number.MAX_VALUE;const l=O.targetedAnimations;for(let w=0;w<l.length;w++){const t=l[w].animation.getKeys();q>t[0].frame&&(q=t[0].frame),I<t[t.length-1].frame&&(I=t[t.length-1].frame)}O._from=q,O._to=I}return O}static ClipKeys(q,I,l,w,t){const O=q.clone(w||q.name);return B.ClipKeysInPlace(O,I,l,t)}static ClipKeysInPlace(q,I,l,w){return B.ClipInPlace(q,I,l,w,!1)}static ClipFrames(q,I,l,w,t){const O=q.clone(w||q.name);return B.ClipFramesInPlace(O,I,l,t)}static ClipFramesInPlace(q,I,l,w){return B.ClipInPlace(q,I,l,w,!0)}static ClipInPlace(q,I,l,w){let t=arguments.length>4&&void 0!==arguments[4]&&arguments[4],O=Number.MAX_VALUE,c=-Number.MAX_VALUE;const a=q.targetedAnimations;for(let F=0;F<a.length;F++){const q=a[F],s=w?q.animation:q.animation.clone();t&&(s.createKeyForFrame(I),s.createKeyForFrame(l));const Z=s.getKeys(),r=[];let x=Number.MAX_VALUE;for(let w=0;w<Z.length;w++){const q=Z[w];if(!t&&w>=I&&w<=l||t&&q.frame>=I&&q.frame<=l){const I={frame:q.frame,value:q.value.clone?q.value.clone():q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation,lockedTangent:q.lockedTangent};x===Number.MAX_VALUE&&(x=I.frame),I.frame-=x,r.push(I)}}0!==r.length?(O>r[0].frame&&(O=r[0].frame),c<r[r.length-1].frame&&(c=r[r.length-1].frame),s.setKeys(r,!0),q.animation=s):(a.splice(F,1),F--)}return q._from=O,q._to=c,q}getClassName(){return"AnimationGroup"}toString(q){let I="Name: "+this.name;return I+=", type: "+this.getClassName(),q&&(I+=", from: "+this._from,I+=", to: "+this._to,I+=", isStarted: "+this._isStarted,I+=", speedRatio: "+this._speedRatio,I+=", targetedAnimations length: "+this._targetedAnimations.length,I+=", animatables length: "+this._animatables),I}}}}]);