"use strict";(self.n52dyox90qa=self.n52dyox90qa||[]).push([[78],{14907:(E,t,z)=>{z.r(t),z.d(t,{AnimationGroup:()=>mE,TargetedAnimation:()=>L});var A=z(12342),X=z(11632),R=z(11667),u=z(11852),p=z(13397),C=z(11812);class Z{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(E,t,z,X){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=t,this._target=E,this._scene=z,this._host=X,this._activeTargets=[],t._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===A.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=C.Matrix.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const E={frame:0,value:this._minValue};this._keys.splice(0,0,E)}if(this._target instanceof Array){let E=0;for(const t of this._target)this._preparePath(t,E),this._getOriginalValues(E),E++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const R=t.getEvents();if(R&&R.length>0)for(const A of R)this._events.push(A._clone());this._enableBlending=E&&E.animationPropertiesOverride?E.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const z=this._animation.targetPropertyPath;if(z.length>1){let A=E;for(let E=0;E<z.length-1;E++){const t=z[E];if(A=A[t],void 0===A)throw new Error(`Invalid property (${t}) in property path (${z.join(".")})`)}this._targetPath=z[z.length-1],this._activeTargets[t]=A}else this._targetPath=z[0],this._activeTargets[t]=E;if(void 0===this._activeTargets[t][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${z.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let E=0;for(const t of this._target)void 0!==this._originalValue[E]&&this._setValue(t,this._activeTargets[E],this._originalValue[E],-1,E),E++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let E=0;E<this._events.length;E++)this._events[E].isDone=!1}isStopped(){return this._stopped}dispose(){const E=this._animation.runtimeAnimations.indexOf(this);E>-1&&this._animation.runtimeAnimations.splice(E,1)}setValue(E,t){if(this._targetIsArray)for(let z=0;z<this._target.length;z++){const A=this._target[z];this._setValue(A,this._activeTargets[z],E,t,z)}else this._setValue(this._target,this._directTarget,E,t,0)}_getOriginalValues(){let E,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const z=this._activeTargets[t];E=z.getLocalMatrix&&"_matrix"===this._targetPath?z.getLocalMatrix():z[this._targetPath],E&&E.clone?this._originalValue[t]=E.clone():this._originalValue[t]=E}_registerTargetForLateAnimationBinding(E,t){const z=E.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(z),z._lateAnimationHolders||(z._lateAnimationHolders={}),z._lateAnimationHolders[E.targetPath]||(z._lateAnimationHolders[E.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:t}),E.isAdditive?(z._lateAnimationHolders[E.targetPath].additiveAnimations.push(E),z._lateAnimationHolders[E.targetPath].totalAdditiveWeight+=E.weight):(z._lateAnimationHolders[E.targetPath].animations.push(E),z._lateAnimationHolders[E.targetPath].totalWeight+=E.weight)}_setValue(E,t,z,X,R){if(this._currentActiveTarget=t,this._weight=X,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const E=t[this._targetPath];E.clone?this._originalBlendValue=E.clone():this._originalBlendValue=E}this._originalBlendValue.m?A.c.AllowMatrixDecomposeForInterpolation?this._currentValue?C.Matrix.DecomposeLerpToRef(this._originalBlendValue,z,this._blendingFactor,this._currentValue):this._currentValue=C.Matrix.DecomposeLerp(this._originalBlendValue,z,this._blendingFactor):this._currentValue?C.Matrix.LerpToRef(this._originalBlendValue,z,this._blendingFactor,this._currentValue):this._currentValue=C.Matrix.Lerp(this._originalBlendValue,z,this._blendingFactor):this._currentValue=A.c._UniversalLerp(this._originalBlendValue,z,this._blendingFactor);const X=E&&E.animationPropertiesOverride?E.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=X}else this._currentValue?this._currentValue.R?this._currentValue.R(z):this._currentValue=z:null!==z&&void 0!==z&&z.clone?this._currentValue=z.clone():this._currentValue=z;-1!==X?this._registerTargetForLateAnimationBinding(this,this._originalValue[R]):this._animationState.loopMode===A.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[R],t[this._targetPath]):t[this._targetPath]=this._originalValue[R]+this._currentValue:t[this._targetPath]=this._currentValue,E.oZ&&E.oZ(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const z=this._animation.getKeys();E<z[0].frame?E=z[0].frame:E>z[z.length-1].frame&&(E=z[z.length-1].frame);const A=this._events;if(A.length)for(let R=0;R<A.length;R++)A[R].onlyOnce||(A[R].isDone=A[R].frame<E);this._currentFrame=E;const X=this._animation._interpolate(E,this._animationState);this.setValue(X,t)}_prepareForSpeedRatioChange(E){const t=this._previousElapsedTime*(this._animation.framePerSecond*E)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-t}animate(E,t,z,X,R){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const p=this._animation,C=p.targetPropertyPath;if(!C||C.length<1)return this._stopped=!0,!1;let Z,H=!0;const h=this._events;let d=0;if(this._coreRuntimeAnimation)d=z-t,Z=this._coreRuntimeAnimation.currentFrame,this._currentFrame=Z,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let u;(t<this._minFrame||t>this._maxFrame)&&(t=this._minFrame),(z<this._minFrame||z>this._maxFrame)&&(z=this._maxFrame),d=z-t;let C=E*(p.framePerSecond*R)/1e3+this._absoluteFrameOffset,y=0,O=!1;const c=X&&this._animationState.loopMode===A.c.ANIMATIONLOOPMODE_YOYO;if(c){const E=(C-t)/d,z=Math.sin(E*Math.PI);C=Math.abs(z)*d+t;const A=z>=0?1:-1;this._yoyoDirection!==A&&(O=!0),this._yoyoDirection=A}if(this._previousElapsedTime=E,this._previousAbsoluteFrame=C,!X&&z>=t&&(C>=d&&R>0||C<=0&&R<0))H=!1,y=p._getKeyValue(this._maxValue);else if(!X&&t>=z&&(C<=d&&R<0||C>=0&&R>0))H=!1,y=p._getKeyValue(this._minValue);else if(this._animationState.loopMode!==A.c.ANIMATIONLOOPMODE_CYCLE){const E=z.toString()+t.toString();if(!this._offsetsCache[E]){this._animationState.repeatCount=0,this._animationState.loopMode=A.c.ANIMATIONLOOPMODE_CYCLE;const X=p._interpolate(t,this._animationState),R=p._interpolate(z,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),p.dataType){case A.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[E]=R-X;break;case A.c.ANIMATIONTYPE_QUATERNION:case A.c.ANIMATIONTYPE_VECTOR3:case A.c.ANIMATIONTYPE_VECTOR2:case A.c.ANIMATIONTYPE_SIZE:case A.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[E]=R.Wt(X)}this._highLimitsCache[E]=R}y=this._highLimitsCache[E],u=this._offsetsCache[E]}if(void 0===u)switch(p.dataType){case A.c.ANIMATIONTYPE_FLOAT:u=0;break;case A.c.ANIMATIONTYPE_QUATERNION:u=A.j;break;case A.c.ANIMATIONTYPE_VECTOR3:u=A.r;break;case A.c.ANIMATIONTYPE_VECTOR2:u=A.q;break;case A.c.ANIMATIONTYPE_SIZE:u=A.n;break;case A.c.ANIMATIONTYPE_COLOR3:u=A.g;break;case A.c.ANIMATIONTYPE_COLOR4:u=A.h}if(this._host&&this._host.syncRoot){const E=this._host.syncRoot;Z=t+d*((E.masterFrame-E.fromFrame)/(E.toFrame-E.fromFrame))}else Z=C>0&&t>z||C<0&&t<z?H&&0!==d?z+C%d:t:H&&0!==d?t+C%d:z;if(!c&&(R>0&&this.currentFrame>Z||R<0&&this.currentFrame<Z)||c&&O){this._onLoop();for(let E=0;E<h.length;E++)h[E].onlyOnce||(h[E].isDone=!1);this._animationState.key=R>0?0:p.getKeys().length-1}this._currentFrame=Z,this._animationState.repeatCount=0===d?0:C/d|0,this._animationState.highLimitValue=y,this._animationState.offsetValue=u}const y=p._interpolate(Z,this._animationState);if(this.setValue(y,u),h.length)for(let A=0;A<h.length;A++)if(d>=0&&Z>=h[A].frame&&h[A].frame>=t||d<0&&Z<=h[A].frame&&h[A].frame<=t){const E=h[A];E.isDone||(E.onlyOnce&&(h.splice(A,1),A--),E.isDone=!0,E.action(Z))}return H||(this._stopped=!0),H}}var H=z(11649);class h{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(E){this._weight=-1!==E?Math.min(Math.max(E,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(E){for(let t=0;t<this._runtimeAnimations.length;t++){this._runtimeAnimations[t]._prepareForSpeedRatioChange(E)}this._speedRatio=E,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(E,t){let z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,R=arguments.length>4&&void 0!==arguments[4]&&arguments[4],u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,p=arguments.length>6?arguments[6]:void 0,C=arguments.length>7?arguments[7]:void 0,Z=arguments.length>8?arguments[8]:void 0,H=arguments.length>9&&void 0!==arguments[9]&&arguments[9],h=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=t,this.fromFrame=z,this.toFrame=A,this.loopAnimation=R,this.onAnimationEnd=p,this.onAnimationLoop=Z,this.isAdditive=H,this.playOrder=h,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Yu=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new X.b,this.onAnimationLoopObservable=new X.b,this._scene=E,C&&this.appendAnimations(t,C),this._speedRatio=u,E._activeAnimatables.push(this)}syncWith(E){if(this._syncRoot=E,E){const E=this._scene._activeAnimatables.indexOf(this);E>-1&&(this._scene._activeAnimatables.splice(E,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(E,t){for(let z=0;z<t.length;z++){const A=t[z],X=new Z(E,A,this._scene,this);X._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(X)}}getAnimationByTargetProperty(E){const t=this._runtimeAnimations;for(let z=0;z<t.length;z++)if(t[z].animation.targetProperty===E)return t[z].animation;return null}getRuntimeAnimationByTargetProperty(E){const t=this._runtimeAnimations;for(let z=0;z<t.length;z++)if(t[z].animation.targetProperty===E)return t[z];return null}reset(){const E=this._runtimeAnimations;for(let t=0;t<E.length;t++)E[t].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(E){const t=this._runtimeAnimations;for(let z=0;z<t.length;z++)t[z].animation.enableBlending=!0,t[z].animation.blendingSpeed=E}disableBlending(){const E=this._runtimeAnimations;for(let t=0;t<E.length;t++)E[t].animation.enableBlending=!1}goToFrame(E){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const z=this._runtimeAnimations;if(z[0]){const t=z[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??z[0].currentFrame;const A=0===this.speedRatio?0:(E-this._frameToSyncFromJump)/t*1e3/this.speedRatio;this._manualJumpDelay=-A}for(let A=0;A<z.length;A++)z[A].goToFrame(E,t?this._weight:-1);this._goToFrame=E}get paused(){return this.Yu}pause(){this.Yu||(this.Yu=!0)}restart(){this.Yu=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(E,t){let z=arguments.length>2&&void 0!==arguments[2]&&arguments[2],A=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(E||t){const X=this._scene._activeAnimatables.indexOf(this);if(X>-1){const R=this._runtimeAnimations;for(let z=R.length-1;z>=0;z--){const A=R[z];E&&A.animation.name!=E||(t&&!t(A.target)||(A.dispose(),R.splice(z,1)))}0==R.length&&(z||this._scene._activeAnimatables.splice(X,1),A||this._raiseOnAnimationEnd())}}else{const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){z||this._scene._activeAnimatables.splice(E,1);const t=this._runtimeAnimations;for(let E=0;E<t.length;E++)t[E].dispose();this._runtimeAnimations.length=0,A||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((E=>{this.onAnimationEndObservable.add((()=>{E(this)}),void 0,void 0,this,!0)}))}_animate(E){if(this.Yu)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=E),!0;if(null===this._localDelayOffset?(this._localDelayOffset=E,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=E-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let t=!1;const z=this._runtimeAnimations;let A;for(A=0;A<z.length;A++){const X=z[A].animate(E-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);t=t||X}if(this.animationStarted=t,!t){if(this.disposeOnEnd)for(A=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(A,1),A=0;A<z.length;A++)z[A].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return t}}function d(E){if(0===E.totalWeight&&0===E.totalAdditiveWeight)return E.originalValue;let t=1;const z=C.TmpVectors.Lt[0],A=C.TmpVectors.Lt[1],X=C.TmpVectors.Quaternion[0];let R=0;const u=E.animations[0],p=E.originalValue;let Z=1,H=!1;if(E.totalWeight<1)Z=1-E.totalWeight,p.decompose(A,X,z);else{if(R=1,t=E.totalWeight,Z=u.weight/t,1==Z){if(!E.totalAdditiveWeight)return u.currentValue;H=!0}u.currentValue.decompose(A,X,z)}if(!H){A.scaleInPlace(Z),z.scaleInPlace(Z),X.scaleInPlace(Z);for(let u=R;u<E.animations.length;u++){const R=E.animations[u];if(0===R.weight)continue;Z=R.weight/t;const p=C.TmpVectors.Lt[2],H=C.TmpVectors.Lt[3],h=C.TmpVectors.Quaternion[1];R.currentValue.decompose(H,h,p),H.scaleAndAddToRef(Z,A),h.scaleAndAddToRef(C.Quaternion.Dot(X,h)>0?Z:-Z,X),p.scaleAndAddToRef(Z,z)}X.normalize()}for(let d=0;d<E.additiveAnimations.length;d++){const t=E.additiveAnimations[d];if(0===t.weight)continue;const R=C.TmpVectors.Lt[2],u=C.TmpVectors.Lt[3],p=C.TmpVectors.Quaternion[1];t.currentValue.decompose(u,p,R),u.multiplyToRef(A,u),C.Lt.LerpToRef(A,u,t.weight,A),X.multiplyToRef(p,p),C.Quaternion.SlerpToRef(X,p,t.weight,X),R.scaleAndAddToRef(t.weight,z)}const h=u?u._animationState.workValue:C.TmpVectors.Matrix[0].clone();return C.Matrix.ComposeToRef(A,X,z,h),h}function y(E,t){if(0===E.totalWeight&&0===E.totalAdditiveWeight)return t;const z=E.animations[0],A=E.originalValue;let X=t;if(0===E.totalWeight&&E.totalAdditiveWeight>0)X.R(A);else if(1===E.animations.length){if(C.Quaternion.SlerpToRef(A,z.currentValue,Math.min(1,E.totalWeight),X),0===E.totalAdditiveWeight)return X}else if(E.animations.length>1){let z,R,u=1;if(E.totalWeight<1){const t=1-E.totalWeight;z=[],R=[],z.push(A),R.push(t)}else{if(2===E.animations.length&&(C.Quaternion.SlerpToRef(E.animations[0].currentValue,E.animations[1].currentValue,E.animations[1].weight/E.totalWeight,t),0===E.totalAdditiveWeight))return t;z=[],R=[],u=E.totalWeight}for(let t=0;t<E.animations.length;t++){const A=E.animations[t];z.push(A.currentValue),R.push(A.weight/u)}let p=0;for(let E=0;E<z.length;)E?(p+=R[E],C.Quaternion.SlerpToRef(X,z[E],R[E]/p,X),E++):(C.Quaternion.SlerpToRef(z[E],z[E+1],R[E+1]/(R[E]+R[E+1]),t),X=t,p=R[E]+R[E+1],E+=2)}for(let R=0;R<E.additiveAnimations.length;R++){const t=E.additiveAnimations[R];0!==t.weight&&(X.multiplyToRef(t.currentValue,C.TmpVectors.Quaternion[0]),C.Quaternion.SlerpToRef(X,C.TmpVectors.Quaternion[0],t.weight,X))}return X}var O,c,a=z(12051);O=a.c,(c=p.d)&&(c.prototype.copyAnimationRange=function(E,t,z){let X=arguments.length>3&&void 0!==arguments[3]&&arguments[3],R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new A.c(this.name,"_matrix",E.animations[0].framePerSecond,A.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const u=E.animations[0].getRange(t);if(!u)return!1;const p=u.from,C=u.to,Z=E.animations[0].getKeys(),H=E.length,h=E.getParent(),d=this.getParent(),y=X&&h&&H&&this.length&&H!==this.length,O=y&&d&&h?d.length/h.length:1,c=X&&!d&&R&&(1!==R.x||1!==R.y||1!==R.z),a=this.animations[0].getKeys();let L,mE,W;for(let A=0,I=Z.length;A<I;A++)L=Z[A],L.frame>=p&&L.frame<=C&&(X?(W=L.value.clone(),y?(mE=W.getTranslation(),W.setTranslation(mE.scaleInPlace(O))):c&&R?(mE=W.getTranslation(),W.setTranslation(mE.multiplyInPlace(R))):W=L.value):W=L.value,a.push({frame:L.frame+z,value:W}));return this.animations[0].createRange(t,p+z,C+z),!0}),O&&(O.prototype._animate=function(E){if(!this.animationsEnabled)return;const t=H.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=t}this.deltaTime=void 0!==E?E:this.useConstantAnimationDeltaTime?16:(t-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=t;const z=this._activeAnimatables;if(0===z.length)return;this._animationTime+=this.deltaTime;const X=this._animationTime;for(let A=0;A<z.length;A++){const E=z[A];!E._animate(X)&&E.disposeOnEnd&&A--}!function(E){if(E._registeredForLateAnimationBindings.length){for(let t=0;t<E._registeredForLateAnimationBindings.length;t++){const z=E._registeredForLateAnimationBindings.data[t];for(const E in z._lateAnimationHolders){const t=z._lateAnimationHolders[E],X=t.animations[0],R=t.originalValue;if(void 0===R||null===R)continue;const u=A.c.AllowMatrixDecomposeForInterpolation&&R.m;let p=z[E];if(u)p=d(t);else if(void 0!==R.w)p=y(t,p||C.Quaternion.Identity());else{let E=0,z=1;const u=X&&X._animationState.loopMode===A.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(t.totalWeight<1)p=u?R.clone?R.clone():R:X&&R.scale?R.scale(1-t.totalWeight):X?R*(1-t.totalWeight):R.clone?R.clone():R;else if(X){z=t.totalWeight;const A=X.weight/z;p=1!==A?X.currentValue.scale?X.currentValue.scale(A):X.currentValue*A:X.currentValue,u&&(p.addToRef?p.addToRef(R,p):p+=R),E=1}for(let A=E;A<t.animations.length;A++){const E=t.animations[A],X=E.weight/z;X&&(E.currentValue.scaleAndAddToRef?E.currentValue.scaleAndAddToRef(X,p):p+=E.currentValue*X)}for(let A=0;A<t.additiveAnimations.length;A++){const E=t.additiveAnimations[A],z=E.weight;z&&(E.currentValue.scaleAndAddToRef?E.currentValue.scaleAndAddToRef(z,p):p+=E.currentValue*z)}}z[E]=p}z._lateAnimationHolders={}}E._registeredForLateAnimationBindings.reset()}}(this)},O.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((E,t)=>E.playOrder-t.playOrder))},O.prototype.beginWeightedAnimation=function(E,t,z){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,X=arguments.length>4?arguments[4]:void 0,R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,p=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,Z=arguments.length>9?arguments[9]:void 0,H=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const h=this.beginAnimation(E,t,z,X,R,u,p,!1,C,Z,H);return h.weight=A,h},O.prototype.beginAnimation=function(E,t,z,A){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,R=arguments.length>5?arguments[5]:void 0,u=arguments.length>6?arguments[6]:void 0,p=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],C=arguments.length>8?arguments[8]:void 0,Z=arguments.length>9?arguments[9]:void 0,H=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(X<0){const E=t;t=z,z=E,X=-X}t>z&&(X=-X),p&&this.stopAnimation(E,void 0,C),u||(u=new h(this,E,t,z,A,X,R,void 0,Z,H));const d=!C||C(E);if(E.animations&&d&&u.appendAnimations(E,E.animations),E.getAnimatables){const H=E.getAnimatables();for(let E=0;E<H.length;E++)this.beginAnimation(H[E],t,z,A,X,R,u,p,C,Z)}return u.reset(),u},O.prototype.beginHierarchyAnimation=function(E,t,z,A,X){let R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,p=arguments.length>7?arguments[7]:void 0,C=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],Z=arguments.length>9?arguments[9]:void 0,H=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const h=E.getDescendants(t),d=[];d.push(this.beginAnimation(E,z,A,X,R,u,p,C,Z,void 0,H));for(const y of h)d.push(this.beginAnimation(y,z,A,X,R,u,p,C,Z,void 0,H));return d},O.prototype.beginDirectAnimation=function(E,t,z,A,X){let R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(R<0){const E=z;z=A,A=E,R=-R}return z>A&&(R=-R),new h(this,E,z,A,X,R,arguments.length>6?arguments[6]:void 0,t,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},O.prototype.beginDirectHierarchyAnimation=function(E,t,z,A,X,R,u,p,C){let Z=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const H=E.getDescendants(t),h=[];h.push(this.beginDirectAnimation(E,z,A,X,R,u,p,C,Z));for(const d of H)h.push(this.beginDirectAnimation(d,z,A,X,R,u,p,C,Z));return h},O.prototype.getAnimatableByTarget=function(E){for(let t=0;t<this._activeAnimatables.length;t++)if(this._activeAnimatables[t].target===E)return this._activeAnimatables[t];return null},O.prototype.getAllAnimatablesByTarget=function(E){const t=[];for(let z=0;z<this._activeAnimatables.length;z++)this._activeAnimatables[z].target===E&&t.push(this._activeAnimatables[z]);return t},O.prototype.stopAnimation=function(E,t,z){const A=this.getAllAnimatablesByTarget(E);for(const X of A)X.stop(t,z)},O.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let E=0;E<this._activeAnimatables.length;E++)this._activeAnimatables[E].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const E of this.animationGroups)E.stop()});class L{getClassName(){return"TargetedAnimation"}serialize(){const E={};return E.animation=this.animation.serialize(),E.targetId=this.target.id,E}}class mE{get mask(){return this._mask}set mask(E){this._mask!==E&&(this._mask=E,this.syncWithMask(!0))}syncWithMask(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||E){this._numActiveAnimatables=0;for(let E=0;E<this._animatables.length;++E){const t=this._animatables[E];!this.mask||this.mask.disabled||this.mask.retainsTarget(t.target.name)?(this._numActiveAnimatables++,t.paused&&t.restart()):t.paused||t.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let E=0;E<this._animatables.length;++E){const t=this._animatables[E];this.mask.retainsTarget(t.target.name)||(t.stop(),this._animatables.splice(E,1),--E)}for(let E=0;E<this._targetedAnimations.length;E++){const t=this._targetedAnimations[E];this.mask.retainsTarget(t.target.name)||(this._targetedAnimations.splice(E,1),--E)}}}get from(){return this._from}set from(E){if(this._from!==E){this._from=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].fromFrame=this._from}}}get to(){return this._to}set to(E){if(this._to!==E){this._to=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(E){if(this._speedRatio!==E){this._speedRatio=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(E){if(this._loopAnimation!==E){this._loopAnimation=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(E){if(this._isAdditive!==E){this._isAdditive=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(E){this._weight!==E&&(this._weight=E,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(E){if(this._playOrder!==E&&(this._playOrder=E,this._animatables.length>0)){for(let E=0;E<this._animatables.length;E++)this._animatables[E].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(E){if(this._enableBlending!==E&&(this._enableBlending=E,null!==E))for(let t=0;t<this._targetedAnimations.length;++t)this._targetedAnimations[t].animation.enableBlending=E}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(E){if(this._blendingSpeed!==E&&(this._blendingSpeed=E,null!==E))for(let t=0;t<this._targetedAnimations.length;++t)this._targetedAnimations[t].animation.blendingSpeed=E}getLength(E,t){E=E??this._from;return((t=t??this._to)-E)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(E){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2],A=arguments.length>3?arguments[3]:void 0;if(0===E.length)return null;A=A??E[0].weight;let X=Number.MAX_VALUE,R=-Number.MAX_VALUE;if(z)for(const p of E)p.from<X&&(X=p.from),p.to>R&&(R=p.to);const u=new mE(E[0].name+"_merged",E[0]._scene,A);for(const p of E){z&&p.normalize(X,R);for(const E of p.targetedAnimations)u.addTargetedAnimation(E.animation,E.target);t&&p.dispose()}return u}constructor(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=E,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new X.b,this.onAnimationLoopObservable=new X.b,this.onAnimationGroupLoopObservable=new X.b,this.onAnimationGroupEndObservable=new X.b,this.onAnimationGroupPauseObservable=new X.b,this.onAnimationGroupPlayObservable=new X.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=t||R.d.LastCreatedScene,this._weight=z,this._playOrder=A,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(E,t){const z=new L;z.animation=E,z.target=t;const A=E.getKeys();return this._from>A[0].frame&&(this._from=A[0].frame),this._to<A[A.length-1].frame&&(this._to=A[A.length-1].frame),null!==this._enableBlending&&(E.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(E.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(z),this._shouldStart=!0,z}removeTargetedAnimation(E){for(let t=this._targetedAnimations.length-1;t>-1;t--){this._targetedAnimations[t].animation===E&&this._targetedAnimations.splice(t,1)}}normalize(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==E&&(E=this._from),null==t&&(t=this._to);for(let z=0;z<this._targetedAnimations.length;z++){const A=this._targetedAnimations[z].animation.getKeys(),X=A[0],R=A[A.length-1];if(X.frame>E){const t={frame:E,value:X.value,inTangent:X.inTangent,outTangent:X.outTangent,interpolation:X.interpolation};A.splice(0,0,t)}if(R.frame<t){const E={frame:t,value:R.value,inTangent:R.inTangent,outTangent:R.outTangent,interpolation:R.interpolation};A.push(E)}}return this._from=E,this._to=t,this}_processLoop(E,t,z){E.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(t),this._animationLoopFlags[z]||(this._animationLoopFlags[z]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,z=arguments.length>2?arguments[2]:void 0,A=arguments.length>3?arguments[3]:void 0,X=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=E,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let R=0;R<this._targetedAnimations.length;R++){const u=this._targetedAnimations[R],p=this._scene.beginDirectAnimation(u.target,[u.animation],void 0!==z?z:this._from,void 0!==A?A:this._to,E,t,void 0,void 0,void 0!==X?X:this._isAdditive);p.weight=this._weight,p.playOrder=this._playOrder,p.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(u),this._checkAnimationGroupEnded(p)},this._processLoop(p,u,R),this._animatables.push(p)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=t,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let E=0;E<this._animatables.length;E++){this._animatables[E].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(E){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==E&&(this.loopAnimation=E),this.restart()):(this.stop(),this.start(E,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].reset()}return this}restart(){if(!this._isStarted)return this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const t=this._animatables.slice();for(let A=0;A<t.length;A++)t[A].stop(void 0,void 0,!0,E);let z=0;for(let A=0;A<this._scene._activeAnimatables.length;A++){const t=this._scene._activeAnimatables[A];t._runtimeAnimations.length>0?this._scene._activeAnimatables[z++]=t:E&&this._checkAnimationGroupEnded(t,E)}return this._scene._activeAnimatables.length=z,this._isStarted=!1,this}setWeightForAllAnimatables(E){for(let t=0;t<this._animatables.length;t++){this._animatables[t].weight=E}return this}syncAllAnimationsWith(E){for(let t=0;t<this._animatables.length;t++){this._animatables[t].syncWith(E)}return this}goToFrame(E){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let z=0;z<this._animatables.length;z++){this._animatables[z].goToFrame(E,t)}return this}getCurrentFrame(){var E;return(null===(E=this.animatables[0])||void 0===E?void 0:E.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const E=this._scene.animationGroups.indexOf(this);if(E>-1&&this._scene.animationGroups.splice(E,1),this._parentContainer){const E=this._parentContainer.animationGroups.indexOf(this);E>-1&&this._parentContainer.animationGroups.splice(E,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(E){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const z=this._animatables.indexOf(E);z>-1&&this._animatables.splice(z,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,t||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(E,t){let z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const A=new mE(E||this.name,this._scene,this._weight,this._playOrder);A._from=this.from,A._to=this.to,A._speedRatio=this.speedRatio,A._loopAnimation=this.loopAnimation,A._isAdditive=this.isAdditive,A._enableBlending=this.enableBlending,A._blendingSpeed=this.blendingSpeed,A.metadata=this.metadata,A.mask=this.mask;for(const X of this._targetedAnimations)A.addTargetedAnimation(z?X.animation.clone():X.animation,t?t(X.target):X.target);return A}serialize(){const E={};E.name=this.name,E.from=this.from,E.to=this.to,E.speedRatio=this.speedRatio,E.loopAnimation=this.loopAnimation,E.isAdditive=this.isAdditive,E.weight=this.weight,E.playOrder=this.playOrder,E.enableBlending=this.enableBlending,E.blendingSpeed=this.blendingSpeed,E.targetedAnimations=[];for(let t=0;t<this.targetedAnimations.length;t++){const z=this.targetedAnimations[t];E.targetedAnimations[t]=z.serialize()}return u.d&&u.d.HasTags(this)&&(E.tags=u.d.GetTags(this)),this.metadata&&(E.metadata=this.metadata),E}static Parse(E,t){const z=new mE(E.name,t,E.weight,E.playOrder);for(let X=0;X<E.targetedAnimations.length;X++){const R=E.targetedAnimations[X],u=A.c.Parse(R.animation),p=R.targetId;if("influence"===R.animation.property){const E=t.getMorphTargetById(p);E&&z.addTargetedAnimation(u,E)}else{const E=t.getNodeById(p);null!=E&&z.addTargetedAnimation(u,E)}}return u.d&&u.d.AddTagsTo(z,E.tags),null!==E.from&&null!==E.to&&z.normalize(E.from,E.to),void 0!==E.speedRatio&&(z._speedRatio=E.speedRatio),void 0!==E.loopAnimation&&(z._loopAnimation=E.loopAnimation),void 0!==E.isAdditive&&(z._isAdditive=E.isAdditive),void 0!==E.weight&&(z._weight=E.weight),void 0!==E.playOrder&&(z._playOrder=E.playOrder),void 0!==E.enableBlending&&(z._enableBlending=E.enableBlending),void 0!==E.blendingSpeed&&(z._blendingSpeed=E.blendingSpeed),void 0!==E.metadata&&(z.metadata=E.metadata),z}static MakeAnimationAdditive(E,t,z){let X;X="object"===typeof t?t:{referenceFrame:t,range:z,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let R=E;X.cloneOriginalAnimationGroup&&(R=E.clone(X.clonedAnimationGroupName||R.name));const u=R.targetedAnimations;for(let p=0;p<u.length;p++){const E=u[p];E.animation=A.c.MakeAnimationAdditive(E.animation,X)}if(R.isAdditive=!0,X.clipKeys){let E=Number.MAX_VALUE,t=-Number.MAX_VALUE;const z=R.targetedAnimations;for(let A=0;A<z.length;A++){const X=z[A].animation.getKeys();E>X[0].frame&&(E=X[0].frame),t<X[X.length-1].frame&&(t=X[X.length-1].frame)}R._from=E,R._to=t}return R}static ClipKeys(E,t,z,A,X){const R=E.clone(A||E.name);return mE.ClipKeysInPlace(R,t,z,X)}static ClipKeysInPlace(E,t,z,A){return mE.ClipInPlace(E,t,z,A,!1)}static ClipFrames(E,t,z,A,X){const R=E.clone(A||E.name);return mE.ClipFramesInPlace(R,t,z,X)}static ClipFramesInPlace(E,t,z,A){return mE.ClipInPlace(E,t,z,A,!0)}static ClipInPlace(E,t,z,A){let X=arguments.length>4&&void 0!==arguments[4]&&arguments[4],R=Number.MAX_VALUE,u=-Number.MAX_VALUE;const p=E.targetedAnimations;for(let C=0;C<p.length;C++){const E=p[C],Z=A?E.animation:E.animation.clone();X&&(Z.createKeyForFrame(t),Z.createKeyForFrame(z));const H=Z.getKeys(),h=[];let d=Number.MAX_VALUE;for(let A=0;A<H.length;A++){const E=H[A];if(!X&&A>=t&&A<=z||X&&E.frame>=t&&E.frame<=z){const t={frame:E.frame,value:E.value.clone?E.value.clone():E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation,lockedTangent:E.lockedTangent};d===Number.MAX_VALUE&&(d=t.frame),t.frame-=d,h.push(t)}}0!==h.length?(R>h[0].frame&&(R=h[0].frame),u<h[h.length-1].frame&&(u=h[h.length-1].frame),Z.setKeys(h,!0),E.animation=Z):(p.splice(C,1),C--)}return E._from=R,E._to=u,E}getClassName(){return"AnimationGroup"}toString(E){let t="Name: "+this.name;return t+=", type: "+this.getClassName(),E&&(t+=", from: "+this._from,t+=", to: "+this._to,t+=", isStarted: "+this._isStarted,t+=", speedRatio: "+this._speedRatio,t+=", targetedAnimations length: "+this._targetedAnimations.length,t+=", animatables length: "+this._animatables),t}}}}]);