"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[9],{11615:(Z,h,V)=>{V.d(h,{e:()=>l,f:()=>P,l:()=>C,h:()=>z,o:()=>m});class v{constructor(){this.children=[]}isValid(Z){return!0}process(Z,h,V){let v="";if(this.line){let V=this.line;const x=h.processor;if(x){var A,H,K,d,a,n;x.lineProcessor&&(V=x.lineProcessor(V,h.isFragment,h.processingContext));const v=(null===(A=h.processor)||void 0===A?void 0:A.attributeKeywordName)??"attribute",N=h.isFragment&&null!==(H=h.processor)&&void 0!==H&&H.varyingFragmentKeywordName?null===(K=h.processor)||void 0===K?void 0:K.varyingFragmentKeywordName:!h.isFragment&&null!==(d=h.processor)&&void 0!==d&&d.varyingVertexKeywordName?null===(a=h.processor)||void 0===a?void 0:a.varyingVertexKeywordName:"varying";if(!h.isFragment&&x.attributeProcessor&&this.line.startsWith(v))V=x.attributeProcessor(this.line,Z,h.processingContext);else if(x.varyingProcessor&&(null!==(n=x.varyingCheck)&&void 0!==n&&n.call(x,this.line,h.isFragment)||!x.varyingCheck&&this.line.startsWith(N)))V=x.varyingProcessor(this.line,h.isFragment,Z,h.processingContext);else if(x.uniformProcessor&&x.uniformRegexp&&x.uniformRegexp.test(this.line))h.lookForClosingBracketForUniformBuffer||(V=x.uniformProcessor(this.line,h.isFragment,Z,h.processingContext));else if(x.uniformBufferProcessor&&x.uniformBufferRegexp&&x.uniformBufferRegexp.test(this.line))h.lookForClosingBracketForUniformBuffer||(V=x.uniformBufferProcessor(this.line,h.isFragment,h.processingContext),h.lookForClosingBracketForUniformBuffer=!0);else if(x.textureProcessor&&x.textureRegexp&&x.textureRegexp.test(this.line))V=x.textureProcessor(this.line,h.isFragment,Z,h.processingContext);else if((x.uniformProcessor||x.uniformBufferProcessor)&&this.line.startsWith("uniform")&&!h.lookForClosingBracketForUniformBuffer){/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line)?x.uniformProcessor&&(V=x.uniformProcessor(this.line,h.isFragment,Z,h.processingContext)):x.uniformBufferProcessor&&(V=x.uniformBufferProcessor(this.line,h.isFragment,h.processingContext),h.lookForClosingBracketForUniformBuffer=!0)}h.lookForClosingBracketForUniformBuffer&&-1!==this.line.indexOf("}")&&(h.lookForClosingBracketForUniformBuffer=!1,x.endOfUniformBufferProcessor&&(V=x.endOfUniformBufferProcessor(this.line,h.isFragment,h.processingContext)))}v+=V+"\n"}for(const x of this.children)v+=x.process(Z,h,V);return this.additionalDefineKey&&(Z[this.additionalDefineKey]=this.additionalDefineValue||"true",V[this.additionalDefineKey]=Z[this.additionalDefineKey]),v}}class A{constructor(){this._lines=[]}get currentLine(){return this._lines[this.lineIndex]}get canRead(){return this.lineIndex<this._lines.length-1}set lines(Z){this._lines.length=0;for(const h of Z){if(!h||"\r"===h)continue;if("#"===h[0]){this._lines.push(h);continue}const Z=h.trim();if(!Z)continue;if(Z.startsWith("//")){this._lines.push(h);continue}const V=Z.indexOf(";");if(-1===V)this._lines.push(Z);else if(V===Z.length-1)Z.length>1&&this._lines.push(Z);else{const Z=h.split(";");for(let h=0;h<Z.length;h++){let V=Z[h];V&&(V=V.trim(),V&&this._lines.push(V+(h!==Z.length-1?";":"")))}}}}}class H extends v{process(Z,h,V){for(let v=0;v<this.children.length;v++){const A=this.children[v];if(A.isValid(Z))return A.process(Z,h,V)}return""}}class K extends v{isValid(Z){return this.testExpression.isTrue(Z)}}class d{isTrue(Z){return!0}static postfixToInfix(Z){const h=[];for(const V of Z)if(void 0===d._OperatorPriority[V])h.push(V);else{const Z=h[h.length-1],v=h[h.length-2];h.length-=2,h.push(`(${v}${V}${Z})`)}return h[h.length-1]}static infixToPostfix(Z){const h=d._InfixToPostfixCache.get(Z);if(h)return h.accessTime=Date.now(),h.result;if(!Z.includes("&&")&&!Z.includes("||")&&!Z.includes(")")&&!Z.includes("("))return[Z];const V=[];let v=-1;const A=()=>{x=x.trim(),""!==x&&(V.push(x),x="")},H=Z=>{v<d._Stack.length-1&&(d._Stack[++v]=Z)},K=()=>d._Stack[v],a=()=>-1===v?"!!INVALID EXPRESSION!!":d._Stack[v--];let n=0,x="";for(;n<Z.length;){const h=Z.charAt(n),N=n<Z.length-1?Z.substring(n,2+n):"";if("("===h)x="",H(h);else if(")"===h){for(A();-1!==v&&"("!==K();)V.push(a());a()}else if(d._OperatorPriority[N]>1){for(A();-1!==v&&d._OperatorPriority[K()]>=d._OperatorPriority[N];)V.push(a());H(N),n++}else x+=h;n++}for(A();-1!==v;)"("===K()?a():V.push(a());return d._InfixToPostfixCache.size>=d.InfixToPostfixCacheLimitSize&&d.ClearCache(),d._InfixToPostfixCache.set(Z,{result:V,accessTime:Date.now()}),V}static ClearCache(){const Z=Array.from(d._InfixToPostfixCache.entries()).sort(((Z,h)=>Z[1].accessTime-h[1].accessTime));for(let h=0;h<d.InfixToPostfixCacheCleanupSize;h++)d._InfixToPostfixCache.delete(Z[h][0])}}d.InfixToPostfixCacheLimitSize=5e4,d.InfixToPostfixCacheCleanupSize=25e3,d._InfixToPostfixCache=new Map,d._OperatorPriority={")":0,"(":1,"||":2,"&&":3},d._Stack=["","","","","","","","","","","","","","","","","","","",""];class a extends d{constructor(Z){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super(),this.define=Z,this.not=h}isTrue(Z){let h=void 0!==Z[this.define];return this.not&&(h=!h),h}}class n extends d{isTrue(Z){return this.leftOperand.isTrue(Z)||this.rightOperand.isTrue(Z)}}class x extends d{isTrue(Z){return this.leftOperand.isTrue(Z)&&this.rightOperand.isTrue(Z)}}class N extends d{constructor(Z,h,V){super(),this.define=Z,this.operand=h,this.testValue=V}toString(){return`${this.define} ${this.operand} ${this.testValue}`}isTrue(Z){let h=!1;const V=parseInt(void 0!=Z[this.define]?Z[this.define]:this.define),v=parseInt(void 0!=Z[this.testValue]?Z[this.testValue]:this.testValue);if(isNaN(V)||isNaN(v))return!1;switch(this.operand){case">":h=V>v;break;case"<":h=V<v;break;case"<=":h=V<=v;break;case">=":h=V>=v;break;case"==":h=V===v;break;case"!=":h=V!==v}return h}}var D=V(11594),k=V(11624);const u=/defined\s*?\((.+?)\)/g,F=/defined\s*?\[(.+?)\]/g,b=/#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,o=/__decl__/,q=/light\{X\}.(\w*)/g,X=/\{X\}/g,E=[],j=/(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;function P(Z){Z.processor&&Z.processor.initializeShaders&&Z.processor.initializeShaders(Z.processingContext)}function C(Z,h,V,v){var A;null!==(A=h.processor)&&void 0!==A&&A.preProcessShaderCode&&(Z=h.processor.preProcessShaderCode(Z,h.isFragment)),z(Z,h,(Z=>{h.processCodeAfterIncludes&&(Z=h.processCodeAfterIncludes(h.isFragment?"fragment":"vertex",Z,h.defines));const A=function(Z,h,V){let v=function(Z,h){var V;if(null!==(V=h.processor)&&void 0!==V&&V.noPrecision)return Z;const v=h.shouldUseHighPrecisionShader;-1===Z.indexOf("precision highp float")?Z=v?"precision highp float;\n"+Z:"precision mediump float;\n"+Z:v||(Z=Z.replace("precision highp float","precision mediump float"));return Z}(Z,h);if(!h.processor)return v;if(0===h.processor.shaderLanguage&&-1!==v.indexOf("#version 3")&&(v=v.replace("#version 300 es",""),!h.processor.parseGLES3))return v;const A=h.defines,H=W(h,V);h.processor.preProcessor&&(v=h.processor.preProcessor(v,A,H,h.isFragment,h.processingContext));const K={};v=y(v,H,h,K),h.processor.postProcessor&&(v=h.processor.postProcessor(v,A,h.isFragment,h.processingContext,V?{drawBuffersExtensionDisabled:!V.getCaps().drawBuffersExtension}:{},H,K));null!==V&&void 0!==V&&V._features.needShaderCodeInlining&&(v=V.inlineShaderCode(v));return v}(Z,h,v);V(A,Z)}))}function l(Z,h,V){return V.processor&&V.processor.finalizeShaders?V.processor.finalizeShaders(Z,h,V.processingContext):{vertexCode:Z,fragmentCode:h}}function B(Z){const h=/defined\((.+)\)/.exec(Z);if(h&&h.length)return new a(h[1].trim(),"!"===Z[0]);const V=["==","!=",">=","<=","<",">"];let v="",A=0;for(v of V)if(A=Z.indexOf(v),A>-1)break;if(-1===A)return new a(Z);const H=Z.substring(0,A).trim(),K=Z.substring(A+v.length).trim();return new N(H,v,K)}function S(Z,h){const V=new K,v=Z.substring(0,h);let A=Z.substring(h);return A=A.substring(0,(A.indexOf("//")+1||A.length+1)-1).trim(),V.testExpression="#ifdef"===v?new a(A):"#ifndef"===v?new a(A,!0):function(Z){Z=Z.replace(u,"defined[$1]");const h=d.infixToPostfix(Z),V=[];for(const A of h)if("||"!==A&&"&&"!==A)V.push(A);else if(V.length>=2){let Z=V[V.length-1],h=V[V.length-2];V.length-=2;const v="&&"==A?new x:new n;"string"===typeof Z&&(Z=Z.replace(F,"defined($1)")),"string"===typeof h&&(h=h.replace(F,"defined($1)")),v.leftOperand="string"===typeof h?B(h):h,v.rightOperand="string"===typeof Z?B(Z):Z,V.push(v)}let v=V[V.length-1];return"string"===typeof v&&(v=v.replace(F,"defined($1)")),"string"===typeof v?B(v):v}(A),V}function r(Z,h,V,A){let H=Z.currentLine;for(;L(Z,V,A);){H=Z.currentLine;const K=H.substring(0,5).toLowerCase();if("#else"===K){const V=new v;return h.children.push(V),void L(Z,V,A)}if("#elif"===K){const Z=S(H,5);h.children.push(Z),V=Z}}}function L(Z,h,V){for(;Z.canRead;){Z.lineIndex++;const A=Z.currentLine;if(A.indexOf("#")>=0){const v=j.exec(A);if(v&&v.length){switch(v[0]){case"#ifdef":{const v=new H;h.children.push(v);const K=S(A,6);v.children.push(K),r(Z,v,K,V);break}case"#else":case"#elif":return!0;case"#endif":return!1;case"#ifndef":{const v=new H;h.children.push(v);const K=S(A,7);v.children.push(K),r(Z,v,K,V);break}case"#if":{const v=new H,K=S(A,3);h.children.push(v),v.children.push(K),r(Z,v,K,V);break}}continue}}const K=new v;if(K.line=A,h.children.push(K),"#"===A[0]&&"d"===A[1]){const Z=A.replace(";","").split(" ");K.additionalDefineKey=Z[1],3===Z.length&&(K.additionalDefineValue=Z[2])}}return!1}function y(Z,h,V,H){const K=new v,d=new A;return d.lineIndex=-1,d.lines=Z.split("\n"),L(d,K,H),K.process(h,V,H)}function W(Z,h){var V;const v=Z.defines,A={};for(const H of v){const Z=H.replace("#define","").replace(";","").trim().split(" ");A[Z[0]]=Z.length>1?Z[1]:""}return 0===(null===(V=Z.processor)||void 0===V?void 0:V.shaderLanguage)&&(A.GL_ES="true"),A.__VERSION__=Z.version,A[Z.platformName]="true",(0,k.h)(A,null===h||void 0===h?void 0:h.isNDCHalfZRange,null===h||void 0===h?void 0:h.useReverseDepthBuffer,null===h||void 0===h?void 0:h.useExactSrgbConversions),A}function z(Z,h,V){let v;for(E.length=0;null!==(v=b.exec(Z));)E.push(v);let A=String(Z),H=[Z],K=!1;for(const d of E){let Z=d[1];if(-1!==Z.indexOf("__decl__")&&(Z=Z.replace(o,""),h.supportsUniformBuffers&&(Z=Z.replace("Vertex","Ubo").replace("Fragment","Ubo")),Z+="Declaration"),!h.includesShadersStore[Z]){const v=h.shadersRepository+"ShadersInclude/"+Z+".fx";return void m.loadFile(v,(v=>{h.includesShadersStore[Z]=v,z(H.join(""),h,V)}))}{let V=h.includesShadersStore[Z];if(d[2]){const Z=d[3].split(",");for(let h=0;h<Z.length;h+=2){const v=new RegExp(Z[h],"g"),A=Z[h+1];V=V.replace(v,A)}}if(d[4]){const Z=d[5];if(-1!==Z.indexOf("..")){const v=Z.split(".."),A=parseInt(v[0]);let H=parseInt(v[1]),K=V.slice(0);V="",isNaN(H)&&(H=h.indexParameters[v[1]]);for(let Z=A;Z<H;Z++)h.supportsUniformBuffers||(K=K.replace(q,((Z,h)=>h+"{X}"))),V+=K.replace(X,Z.toString())+"\n"}else h.supportsUniformBuffers||(V=V.replace(q,((Z,h)=>h+"{X}"))),V=V.replace(X,Z)}const v=[];for(const Z of H){const h=Z.split(d[0]);for(let Z=0;Z<h.length-1;Z++)v.push(h[Z]),v.push(V);v.push(h[h.length-1])}H=v,K=K||V.indexOf("#include<")>=0||V.indexOf("#include <")>=0}}E.length=0,A=H.join(""),K?z(A.toString(),h,V):V(A)}const m={loadFile:(Z,h,V,v,A,H)=>{throw(0,D.d)("FileTools")}}},11624:(Z,h,V)=>{V.d(h,{c:()=>A,f:()=>H,h:()=>d,k:()=>K,l:()=>a});var v=V(11594);V(11573);const A={};function H(Z,h){return(arguments.length>2&&void 0!==arguments[2]?arguments[2]:"")+(h?h+"\n":"")+Z}function K(Z,h,V,H,K,d,a){const n=a||A.loadFile;if(n){return n(Z,h,V,H,K,d)}throw(0,v.d)("FileTools")}function d(Z,h,V,v){if(Z)return h?Z.IS_NDC_HALF_ZRANGE="":delete Z.IS_NDC_HALF_ZRANGE,V?Z.USE_REVERSE_DEPTHBUFFER="":delete Z.USE_REVERSE_DEPTHBUFFER,void(v?Z.USE_EXACT_SRGB_CONVERSIONS="":delete Z.USE_EXACT_SRGB_CONVERSIONS);{let Z="";return h&&(Z+="#define IS_NDC_HALF_ZRANGE"),V&&(Z&&(Z+="\n"),Z+="#define USE_REVERSE_DEPTHBUFFER"),v&&(Z&&(Z+="\n"),Z+="#define USE_EXACT_SRGB_CONVERSIONS"),Z}}function a(Z,h){let V=arguments.length>2&&void 0!==arguments[2]&&arguments[2],v=arguments.length>3?arguments[3]:void 0;switch(Z){case 3:{const Z=(ArrayBuffer,new Int8Array(h));return v&&Z.set(new Int8Array(v)),Z}case 0:{const Z=(ArrayBuffer,new Uint8Array(h));return v&&Z.set(new Uint8Array(v)),Z}case 4:{const Z=h instanceof ArrayBuffer?new Int16Array(h):new Int16Array(V?h/2:h);return v&&Z.set(new Int16Array(v)),Z}case 5:case 8:case 9:case 10:case 2:{const Z=h instanceof ArrayBuffer?new Uint16Array(h):new Uint16Array(V?h/2:h);return v&&Z.set(new Uint16Array(v)),Z}case 6:{const Z=h instanceof ArrayBuffer?new Int32Array(h):new Int32Array(V?h/4:h);return v&&Z.set(new Int32Array(v)),Z}case 7:case 11:case 12:case 13:case 14:case 15:{const Z=h instanceof ArrayBuffer?new Uint32Array(h):new Uint32Array(V?h/4:h);return v&&Z.set(new Uint32Array(v)),Z}case 1:{const Z=h instanceof ArrayBuffer?new Float32Array(h):new Float32Array(V?h/4:h);return v&&Z.set(new Float32Array(v)),Z}}const A=(ArrayBuffer,new Uint8Array(h));return v&&A.set(new Uint8Array(v)),A}},11647:(Z,h,V)=>{V.d(h,{c:()=>v});class v{static GetShadersRepository(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?v.ShadersRepository:v.ShadersRepositoryWGSL}static GetShadersStore(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?v.ShadersStore:v.ShadersStoreWGSL}static GetIncludesShadersStore(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?v.IncludesShadersStore:v.IncludesShadersStoreWGSL}}v.ShadersRepository="src/Shaders/",v.ShadersStore={},v.IncludesShadersStore={},v.ShadersRepositoryWGSL="src/ShadersWGSL/",v.ShadersStoreWGSL={},v.IncludesShadersStoreWGSL={}},11655:(Z,h,V)=>{V.d(h,{d:()=>D,e:()=>X,h:()=>u,j:()=>k,m:()=>F,p:()=>q,t:()=>N,w:()=>n,x:()=>x,A:()=>a,D:()=>d});class v{constructor(){this._valueCache={},this.vertexCompilationError=null,this.fragmentCompilationError=null,this.programLinkError=null,this.programValidationError=null,this._isDisposed=!1}get isAsync(){return this.isParallelCompiled}get isReady(){return!!this.program&&(!this.isParallelCompiled||this.Ph._isRenderingStateCompiled(this))}_handlesSpectorRebuildCallback(Z){Z&&this.program&&Z(this.program)}setEngine(Z){this.Ph=Z}_fillEffectInformation(Z,h,V,v,A,H,K,d){const a=this.Ph;if(a.supportsUniformBuffers)for(const x in h)Z.bindUniformBlock(x,h[x]);let n;for(this.Ph.getUniforms(this,V).forEach(((Z,h)=>{v[V[h]]=Z})),this._uniforms=v,n=0;n<A.length;n++){null==Z.getUniform(A[n])&&(A.splice(n,1),n--)}A.forEach(((Z,h)=>{H[Z]=h}));for(const x of a.getAttributes(this,K))d.push(x)}dispose(){this._uniforms={},this._isDisposed=!0}_cacheMatrix(Z,h){const V=this._valueCache[Z],v=h.updateFlag;return(void 0===V||V!==v)&&(this._valueCache[Z]=v,!0)}_cacheFloat2(Z,h,V){let v=this._valueCache[Z];if(!v||2!==v.length)return v=[h,V],this._valueCache[Z]=v,!0;let A=!1;return v[0]!==h&&(v[0]=h,A=!0),v[1]!==V&&(v[1]=V,A=!0),A}_cacheFloat3(Z,h,V,v){let A=this._valueCache[Z];if(!A||3!==A.length)return A=[h,V,v],this._valueCache[Z]=A,!0;let H=!1;return A[0]!==h&&(A[0]=h,H=!0),A[1]!==V&&(A[1]=V,H=!0),A[2]!==v&&(A[2]=v,H=!0),H}_cacheFloat4(Z,h,V,v,A){let H=this._valueCache[Z];if(!H||4!==H.length)return H=[h,V,v,A],this._valueCache[Z]=H,!0;let K=!1;return H[0]!==h&&(H[0]=h,K=!0),H[1]!==V&&(H[1]=V,K=!0),H[2]!==v&&(H[2]=v,K=!0),H[3]!==A&&(H[3]=A,K=!0),K}setInt(Z,h){const V=this._valueCache[Z];void 0!==V&&V===h||this.Ph.setInt(this._uniforms[Z],h)&&(this._valueCache[Z]=h)}setInt2(Z,h,V){this._cacheFloat2(Z,h,V)&&(this.Ph.setInt2(this._uniforms[Z],h,V)||(this._valueCache[Z]=null))}setInt3(Z,h,V,v){this._cacheFloat3(Z,h,V,v)&&(this.Ph.setInt3(this._uniforms[Z],h,V,v)||(this._valueCache[Z]=null))}setInt4(Z,h,V,v,A){this._cacheFloat4(Z,h,V,v,A)&&(this.Ph.setInt4(this._uniforms[Z],h,V,v,A)||(this._valueCache[Z]=null))}setIntArray(Z,h){this._valueCache[Z]=null,this.Ph.setIntArray(this._uniforms[Z],h)}setIntArray2(Z,h){this._valueCache[Z]=null,this.Ph.setIntArray2(this._uniforms[Z],h)}setIntArray3(Z,h){this._valueCache[Z]=null,this.Ph.setIntArray3(this._uniforms[Z],h)}setIntArray4(Z,h){this._valueCache[Z]=null,this.Ph.setIntArray4(this._uniforms[Z],h)}setUInt(Z,h){const V=this._valueCache[Z];void 0!==V&&V===h||this.Ph.setUInt(this._uniforms[Z],h)&&(this._valueCache[Z]=h)}setUInt2(Z,h,V){this._cacheFloat2(Z,h,V)&&(this.Ph.setUInt2(this._uniforms[Z],h,V)||(this._valueCache[Z]=null))}setUInt3(Z,h,V,v){this._cacheFloat3(Z,h,V,v)&&(this.Ph.setUInt3(this._uniforms[Z],h,V,v)||(this._valueCache[Z]=null))}setUInt4(Z,h,V,v,A){this._cacheFloat4(Z,h,V,v,A)&&(this.Ph.setUInt4(this._uniforms[Z],h,V,v,A)||(this._valueCache[Z]=null))}setUIntArray(Z,h){this._valueCache[Z]=null,this.Ph.setUIntArray(this._uniforms[Z],h)}setUIntArray2(Z,h){this._valueCache[Z]=null,this.Ph.setUIntArray2(this._uniforms[Z],h)}setUIntArray3(Z,h){this._valueCache[Z]=null,this.Ph.setUIntArray3(this._uniforms[Z],h)}setUIntArray4(Z,h){this._valueCache[Z]=null,this.Ph.setUIntArray4(this._uniforms[Z],h)}setArray(Z,h){this._valueCache[Z]=null,this.Ph.setArray(this._uniforms[Z],h)}setArray2(Z,h){this._valueCache[Z]=null,this.Ph.setArray2(this._uniforms[Z],h)}setArray3(Z,h){this._valueCache[Z]=null,this.Ph.setArray3(this._uniforms[Z],h)}setArray4(Z,h){this._valueCache[Z]=null,this.Ph.setArray4(this._uniforms[Z],h)}setMatrices(Z,h){h&&(this._valueCache[Z]=null,this.Ph.setMatrices(this._uniforms[Z],h))}setMatrix(Z,h){this._cacheMatrix(Z,h)&&(this.Ph.setMatrices(this._uniforms[Z],h.mh())||(this._valueCache[Z]=null))}setMatrix3x3(Z,h){this._valueCache[Z]=null,this.Ph.setMatrix3x3(this._uniforms[Z],h)}setMatrix2x2(Z,h){this._valueCache[Z]=null,this.Ph.setMatrix2x2(this._uniforms[Z],h)}setFloat(Z,h){const V=this._valueCache[Z];void 0!==V&&V===h||this.Ph.setFloat(this._uniforms[Z],h)&&(this._valueCache[Z]=h)}setVector2(Z,h){this._cacheFloat2(Z,h.x,h.y)&&(this.Ph.setFloat2(this._uniforms[Z],h.x,h.y)||(this._valueCache[Z]=null))}setFloat2(Z,h,V){this._cacheFloat2(Z,h,V)&&(this.Ph.setFloat2(this._uniforms[Z],h,V)||(this._valueCache[Z]=null))}setVector3(Z,h){this._cacheFloat3(Z,h.x,h.y,h.z)&&(this.Ph.setFloat3(this._uniforms[Z],h.x,h.y,h.z)||(this._valueCache[Z]=null))}setFloat3(Z,h,V,v){this._cacheFloat3(Z,h,V,v)&&(this.Ph.setFloat3(this._uniforms[Z],h,V,v)||(this._valueCache[Z]=null))}setVector4(Z,h){this._cacheFloat4(Z,h.x,h.y,h.z,h.w)&&(this.Ph.setFloat4(this._uniforms[Z],h.x,h.y,h.z,h.w)||(this._valueCache[Z]=null))}setQuaternion(Z,h){this._cacheFloat4(Z,h.x,h.y,h.z,h.w)&&(this.Ph.setFloat4(this._uniforms[Z],h.x,h.y,h.z,h.w)||(this._valueCache[Z]=null))}setFloat4(Z,h,V,v,A){this._cacheFloat4(Z,h,V,v,A)&&(this.Ph.setFloat4(this._uniforms[Z],h,V,v,A)||(this._valueCache[Z]=null))}setColor3(Z,h){this._cacheFloat3(Z,h.r,h.g,h.b)&&(this.Ph.setFloat3(this._uniforms[Z],h.r,h.g,h.b)||(this._valueCache[Z]=null))}setColor4(Z,h,V){this._cacheFloat4(Z,h.r,h.g,h.b,V)&&(this.Ph.setFloat4(this._uniforms[Z],h.r,h.g,h.b,V)||(this._valueCache[Z]=null))}setDirectColor4(Z,h){this._cacheFloat4(Z,h.r,h.g,h.b,h.a)&&(this.Ph.setFloat4(this._uniforms[Z],h.r,h.g,h.b,h.a)||(this._valueCache[Z]=null))}_getVertexShaderCode(){return this.vertexShader?this.Ph._getShaderSource(this.vertexShader):null}_getFragmentShaderCode(){return this.fragmentShader?this.Ph._getShaderSource(this.fragmentShader):null}}var A=V(11624);const H=new WeakMap,K={_webGLVersion:2,cachedPipelines:{}};function d(Z){let h=H.get(Z);if(!h){if(!Z)return K;h={_webGLVersion:Z.TEXTURE_BINDING_3D?2:1,_context:Z,parallelShaderCompile:Z.getExtension("KHR_parallel_shader_compile")||void 0,cachedPipelines:{}},H.set(Z,h)}return h}function a(Z){H.delete(Z)}function n(Z,h,V,v,A,H){const K=d(v);H||(H=K._createShaderProgramInjection??D);return H(Z,o(h,"vertex",v,K._contextWasLost),o(V,"fragment",v,K._contextWasLost),v,A,K.validateShaderPrograms)}function x(Z,h,V,v,A){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,K=arguments.length>6?arguments[6]:void 0;const a=d(A);K||(K=a._createShaderProgramInjection??D);const n=a._webGLVersion>1?"#version 300 es\n#define WEBGL2 \n":"";return K(Z,b(h,"vertex",v,n,A,a._contextWasLost),b(V,"fragment",v,n,A,a._contextWasLost),A,H,a.validateShaderPrograms)}function N(Z,h){const V=new v,A=d(Z);return A.parallelShaderCompile&&!A.disableParallelShaderCompile&&(V.isParallelCompiled=!0),V.context=A._context,V}function D(Z,h,V,v){let A=arguments.length>5?arguments[5]:void 0;const H=v.createProgram();if(Z.program=H,!H)throw new Error("Unable to create program");return v.attachShader(H,h),v.attachShader(H,V),v.linkProgram(H),Z.context=v,Z.vertexShader=h,Z.fragmentShader=V,Z.isParallelCompiled||u(Z,v,A),H}function k(Z,h,V){const v=Z;if(v._isDisposed)return!1;const A=d(h);return!!(A&&A.parallelShaderCompile&&A.parallelShaderCompile.COMPLETION_STATUS_KHR&&v.program&&h.getProgramParameter(v.program,A.parallelShaderCompile.COMPLETION_STATUS_KHR))&&(u(v,h,V),!0)}function u(Z,h,V){const v=Z.context,A=Z.vertexShader,H=Z.fragmentShader,K=Z.program;if(!v.getProgramParameter(K,v.LINK_STATUS)){if(!h.getShaderParameter(A,h.COMPILE_STATUS)){const V=h.getShaderInfoLog(A);if(V)throw Z.vertexCompilationError=V,new Error("VERTEX SHADER "+V)}if(!h.getShaderParameter(H,h.COMPILE_STATUS)){const V=h.getShaderInfoLog(H);if(V)throw Z.fragmentCompilationError=V,new Error("FRAGMENT SHADER "+V)}const V=v.getProgramInfoLog(K);if(V)throw Z.programLinkError=V,new Error(V)}if(V){v.validateProgram(K);if(!v.getProgramParameter(K,v.VALIDATE_STATUS)){const h=v.getProgramInfoLog(K);if(h)throw Z.programValidationError=h,new Error(h)}}v.deleteShader(A),v.deleteShader(H),Z.vertexShader=void 0,Z.fragmentShader=void 0,Z.onCompiled&&(Z.onCompiled(),Z.onCompiled=void 0)}function F(Z,h,V,v,A,H,K,a,N){let D=arguments.length>10?arguments[10]:void 0,k=arguments.length>11?arguments[11]:void 0,u=arguments.length>12?arguments[12]:void 0;const F=d(Z.context);k||(k=F.createRawShaderProgramInjection??n),u||(u=F.createShaderProgramInjection??x);const b=Z;b.program=v?k(b,h,V,b.context,N):u(b,h,V,a,b.context,N),b.program.__SPECTOR_rebuildProgram=K,D()}function b(Z,h,V,v,H,K){return o((0,A.f)(Z,V,v),h,H,K)}function o(Z,h,V,v){const A=V.createShader("vertex"===h?V.VERTEX_SHADER:V.FRAGMENT_SHADER);if(!A){let Z=V.NO_ERROR,A=V.NO_ERROR;for(;(A=V.getError())!==V.NO_ERROR;)Z=A;throw new Error(`Something went wrong while creating a gl ${h} shader object. gl error=${Z}, gl isContextLost=${V.isContextLost()}, _contextWasLost=${v}`)}return V.shaderSource(A,Z),V.compileShader(A),A}function q(Z,h){h.useProgram(Z)}function X(Z,h){const V=Z;if(!V.isParallelCompiled)return void h(Z);const v=V.onCompiled;V.onCompiled=()=>{null===v||void 0===v||v(),h(Z)}}},11649:(Z,h,V)=>{V.d(h,{d:()=>N,f:()=>k,h:()=>n,i:()=>x});var v=V(11573),A=V(11655),H=V(11647),K=V(11580),d=V(11615),a=V(11624);function n(Z,h){return(0,A.D)(h).cachedPipelines[Z]}function x(Z){const h=Z._name,V=Z.context;if(h&&V){const Z=(0,A.D)(V),v=Z.cachedPipelines[h];null===v||void 0===v||v.dispose(),delete Z.cachedPipelines[h]}}function N(Z,h,V,A,H,K,a){let n,x;const N=(0,v.m)()?null===K||void 0===K?void 0:K.getHostDocument():null;n="string"===typeof h?h:h.vertexSource?"source:"+h.vertexSource:h.vertexElement?(null===N||void 0===N?void 0:N.getElementById(h.vertexElement))||h.vertexElement:h.vertex||h,x="string"===typeof h?h:h.fragmentSource?"source:"+h.fragmentSource:h.fragmentElement?(null===N||void 0===N?void 0:N.getElementById(h.fragmentElement))||h.fragmentElement:h.fragment||h;const k=[void 0,void 0],u=()=>{if(k[0]&&k[1]){Z.isFragment=!0;const[v,n]=k;(0,d.l)(n,Z,((K,n)=>{a&&(a._fragmentSourceCodeBeforeMigration=n),V&&(K=V("fragment",K));const x=(0,d.e)(v,K,Z);Z=null;const N=function(Z,h,V,v){if(V){return{vertexSourceCode:(1===v?"//":"")+"#define SHADER_NAME vertex:"+(V.vertexElement||V.vertex||V.spectorName||V)+"\n"+Z,fragmentSourceCode:(1===v?"//":"")+"#define SHADER_NAME fragment:"+(V.fragmentElement||V.fragment||V.spectorName||V)+"\n"+h}}return{vertexSourceCode:Z,fragmentSourceCode:h}}(x.vertexCode,x.fragmentCode,h,H);null===A||void 0===A||A(N.vertexSourceCode,N.fragmentSourceCode)}),K)}};D(n,"Vertex","",(h=>{(0,d.f)(Z),(0,d.l)(h,Z,((Z,v)=>{a&&(a._rawVertexSourceCode=h,a._vertexSourceCodeBeforeMigration=v),V&&(Z=V("vertex",Z)),k[0]=Z,u()}),K)}),H),D(x,"Fragment","Pixel",(Z=>{a&&(a._rawFragmentSourceCode=Z),k[1]=Z,u()}),H)}function D(Z,h,V,A,K,d){if("undefined"!==typeof HTMLElement&&Z instanceof HTMLElement){return void A((0,v.d)(Z))}if("source:"===Z.substring(0,7))return void A(Z.substring(7));if("base64:"===Z.substring(0,7)){return void A(window.atob(Z.substring(7)))}const n=H.c.GetShadersStore(K);if(n[Z+h+"Shader"])return void A(n[Z+h+"Shader"]);if(V&&n[Z+V+"Shader"])return void A(n[Z+V+"Shader"]);let x;if(x="."===Z[0]||"/"===Z[0]||Z.indexOf("http")>-1?Z:H.c.GetShadersRepository(K)+Z,!(d=d||a.k))throw new Error("loadFileInjection is not defined");d(x+"."+h.toLowerCase()+".fx",A)}const k=(Z,h,V,v)=>{try{const H=Z.context?(0,A.D)(Z.context):null;H&&(H.disableParallelShaderCompile=Z.disableParallelCompilation);const K=Z.existingPipelineContext||h(Z.shaderProcessingContext);return K._name=Z.name,Z.name&&H&&(H.cachedPipelines[Z.name]=K),V(K,Z.vertex,Z.fragment,!!Z.createAsRaw,"","",Z.rebuildRebind,Z.defines,Z.transformFeedbackVaryings,"",(()=>{v(K,(()=>{var h;null===(h=Z.onRenderingStateCompiled)||void 0===h||h.call(Z,K)}))})),K}catch(H){throw K.b.Error("Error compiling effect"),H}}},11644:(Z,h,V)=>{V.r(h),V.d(h,{Effect:()=>a});var v=V(11566),A=V(11580),H=V(11647),K=V(11649),d=V(11633);class a{static get ShadersRepository(){return H.c.ShadersRepository}static set ShadersRepository(Z){H.c.ShadersRepository=Z}get K(){return this._isDisposed}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new v.b),this._onBindObservable}get shaderLanguage(){return this._shaderLanguage}constructor(Z,h,V){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,H=arguments.length>4?arguments[4]:void 0,d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,x=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,N=arguments.length>8&&void 0!==arguments[8]?arguments[8]:null,D=arguments.length>9?arguments[9]:void 0,k=arguments.length>10&&void 0!==arguments[10]?arguments[10]:"",u=arguments.length>11&&void 0!==arguments[11]?arguments[11]:0,F=arguments.length>12?arguments[12]:void 0;this.defines="",this.onCompiled=null,this.onError=null,this.onBind=null,this.uniqueId=0,this.onCompileObservable=new v.b,this.onErrorObservable=new v.b,this._onBindObservable=null,this._isDisposed=!1,this._refCount=1,this._bonesComputationForcedToCPU=!1,this._uniformBuffersNames={},this._multiTarget=!1,this._samplers={},this._isReady=!1,this._compilationError="",this._allFallbacksProcessed=!1,this._uniforms={},this._key="",this._fallbacks=null,this._vertexSourceCodeOverride="",this._fragmentSourceCodeOverride="",this._transformFeedbackVaryings=null,this._disableParallelShaderCompilation=!1,this._pipelineContext=null,this._vertexSourceCode="",this._fragmentSourceCode="",this._vertexSourceCodeBeforeMigration="",this._fragmentSourceCodeBeforeMigration="",this._rawVertexSourceCode="",this._rawFragmentSourceCode="",this._processCodeAfterIncludes=void 0,this._processFinalCode=null,this.name=Z,this._key=k;const b=this._key.replace(/\r/g,"").replace(/\n/g,"|");let o;if(h.attributes){const Z=h;if(this._engine=V,this._attributesNames=Z.attributes,this._uniformsNames=Z.uniformsNames.concat(Z.samplers),this._samplerList=Z.samplers.slice(),this.defines=Z.defines,this.onError=Z.onError,this.onCompiled=Z.onCompiled,this._fallbacks=Z.fallbacks,this._indexParameters=Z.indexParameters,this._transformFeedbackVaryings=Z.transformFeedbackVaryings||null,this._multiTarget=!!Z.multiTarget,this._shaderLanguage=Z.shaderLanguage??0,this._disableParallelShaderCompilation=!!Z.disableParallelShaderCompilation,Z.uniformBuffersNames){this._uniformBuffersNamesList=Z.uniformBuffersNames.slice();for(let h=0;h<Z.uniformBuffersNames.length;h++)this._uniformBuffersNames[Z.uniformBuffersNames[h]]=h}this._processFinalCode=Z.processFinalCode??null,this._processCodeAfterIncludes=Z.processCodeAfterIncludes??void 0,F=Z.extraInitializationsAsync,o=Z.existingPipelineContext}else this._engine=H,this.defines=null==d?"":d,this._uniformsNames=V.concat(A),this._samplerList=A?A.slice():[],this._attributesNames=h,this._uniformBuffersNamesList=[],this._shaderLanguage=u,this.onError=N,this.onCompiled=x,this._indexParameters=D,this._fallbacks=n;"WEBGL2"===this._engine.shaderPlatformName&&(o=(0,K.h)(b,this._engine._gl)??o),this._attributeLocationByName={},this.uniqueId=a._UniqueIdSeed++,o?(this._pipelineContext=o,this._pipelineContext.setEngine(this._engine),this._onRenderingStateCompiled(this._pipelineContext),this._pipelineContext.program&&(this._pipelineContext.program.__SPECTOR_rebuildProgram=this._rebuildProgram.bind(this))):this._processShaderCodeAsync(null,!1,null,F),this._engine.onReleaseEffectsObservable.addOnce((()=>{this.K||this.dispose(!0)}))}async _processShaderCodeAsync(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,v=arguments.length>3?arguments[3]:void 0;v&&await v(),this._processingContext=V||this._engine._getShaderProcessingContext(this._shaderLanguage,!1);const A={defines:this.defines.split("\n"),indexParameters:this._indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:Z??this._engine._getShaderProcessor(this._shaderLanguage),supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:H.c.GetShadersRepository(this._shaderLanguage),includesShadersStore:H.c.GetIncludesShadersStore(this._shaderLanguage),version:(100*this._engine.version).toString(),platformName:this._engine.shaderPlatformName,processingContext:this._processingContext,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:this._processCodeAfterIncludes};(0,K.d)(A,this.name,this._processFinalCode,((Z,V)=>{this._vertexSourceCode=Z,this._fragmentSourceCode=V,this._prepareEffect(h)}),this._shaderLanguage,this._engine,this)}get key(){return this._key}isReady(){try{return this._isReadyInternal()}catch{return!1}}_isReadyInternal(){return!!this._engine.K||(!!this._isReady||!!this._pipelineContext&&this._pipelineContext.isReady)}getEngine(){return this._engine}getPipelineContext(){return this._pipelineContext}getAttributesNames(){return this._attributesNames}getAttributeLocation(Z){return this._attributes[Z]}getAttributeLocationByName(Z){return this._attributeLocationByName[Z]}getAttributesCount(){return this._attributes.length}getUniformIndex(Z){return this._uniformsNames.indexOf(Z)}getUniform(Z){return this._uniforms[Z]}getSamplers(){return this._samplerList}getUniformNames(){return this._uniformsNames}getUniformBuffersNames(){return this._uniformBuffersNamesList}getIndexParameters(){return this._indexParameters}getCompilationError(){return this._compilationError}allFallbacksProcessed(){return this._allFallbacksProcessed}async whenCompiledAsync(){return await new Promise((Z=>{this.executeWhenCompiled(Z)}))}executeWhenCompiled(Z){this.isReady()?Z(this):(this.onCompileObservable.add((h=>{Z(h)})),this._pipelineContext&&!this._pipelineContext.isAsync||this._checkIsReady(null))}_checkIsReady(Z){(0,d.h)((()=>this._isReadyInternal()||this._isDisposed),(()=>{}),(h=>{this._processCompilationErrors(h,Z)}),16,12e4,!0,` - Effect: ${"string"===typeof this.name?this.name:this.key}`)}get vertexSourceCode(){var Z;return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._vertexSourceCodeOverride:(null===(Z=this._pipelineContext)||void 0===Z?void 0:Z._getVertexShaderCode())??this._vertexSourceCode}get fragmentSourceCode(){var Z;return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._fragmentSourceCodeOverride:(null===(Z=this._pipelineContext)||void 0===Z?void 0:Z._getFragmentShaderCode())??this._fragmentSourceCode}get vertexSourceCodeBeforeMigration(){return this._vertexSourceCodeBeforeMigration}get fragmentSourceCodeBeforeMigration(){return this._fragmentSourceCodeBeforeMigration}get rawVertexSourceCode(){return this._rawVertexSourceCode}get rawFragmentSourceCode(){return this._rawFragmentSourceCode}getPipelineGenerationOptions(){return{platformName:this._engine.shaderPlatformName,shaderLanguage:this._shaderLanguage,shaderNameOrContent:this.name,key:this._key,defines:this.defines.split("\n"),addGlobalDefines:!1,extendedProcessingOptions:{indexParameters:this._indexParameters,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,supportsUniformBuffers:this._engine.supportsUniformBuffers},extendedCreatePipelineOptions:{transformFeedbackVaryings:this._transformFeedbackVaryings,createAsRaw:!(!this._vertexSourceCodeOverride||!this._fragmentSourceCodeOverride)}}}_rebuildProgram(Z,h,V,v){this._isReady=!1,this._vertexSourceCodeOverride=Z,this._fragmentSourceCodeOverride=h,this.onError=(Z,h)=>{v&&v(h)},this.onCompiled=()=>{var Z,h;const v=this.getEngine().scenes;if(v)for(let V=0;V<v.length;V++)v[V].markAllMaterialsAsDirty(127);null===(Z=(h=this._pipelineContext)._handlesSpectorRebuildCallback)||void 0===Z||Z.call(h,V)},this._fallbacks=null,this._prepareEffect()}_onRenderingStateCompiled(Z){if(this._pipelineContext=Z,this._pipelineContext.setEngine(this._engine),this._attributes=[],this._pipelineContext._fillEffectInformation(this,this._uniformBuffersNames,this._uniformsNames,this._uniforms,this._samplerList,this._samplers,this._attributesNames,this._attributes),this._attributesNames)for(let h=0;h<this._attributesNames.length;h++){const Z=this._attributesNames[h];this._attributeLocationByName[Z]=this._attributes[h]}this._engine.bindSamplers(this),this._compilationError="",this._isReady=!0,this.onCompiled&&this.onCompiled(this),this.onCompileObservable.notifyObservers(this),this.onCompileObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh(),a.AutomaticallyClearCodeCache&&this.clearCodeCache()}_prepareEffect(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=this._pipelineContext;this._isReady=!1;try{const V=!(!this._vertexSourceCodeOverride||!this._fragmentSourceCodeOverride),v=V?null:this.defines,A=V?this._vertexSourceCodeOverride:this._vertexSourceCode,H=V?this._fragmentSourceCodeOverride:this._fragmentSourceCode,d=this._engine;this._pipelineContext=(0,K.f)({existingPipelineContext:Z?h:null,vertex:A,fragment:H,context:"WEBGL2"===d.shaderPlatformName||"WEBGL1"===d.shaderPlatformName?d._gl:void 0,rebuildRebind:(Z,h,V,v)=>this._rebuildProgram(Z,h,V,v),defines:v,transformFeedbackVaryings:this._transformFeedbackVaryings,name:this._key.replace(/\r/g,"").replace(/\n/g,"|"),createAsRaw:V,disableParallelCompilation:this._disableParallelShaderCompilation,shaderProcessingContext:this._processingContext,onRenderingStateCompiled:V=>{h&&!Z&&this._engine._deletePipelineContext(h),V&&this._onRenderingStateCompiled(V)}},this._engine.createPipelineContext.bind(this._engine),this._engine._preparePipelineContextAsync.bind(this._engine),this._engine._executeWhenRenderingStateIsCompiled.bind(this._engine)),this._pipelineContext.isAsync&&this._checkIsReady(h)}catch(V){this._processCompilationErrors(V,h)}}_getShaderCodeAndErrorLine(Z,h,V){const v=V?/FRAGMENT SHADER ERROR: 0:(\d+?):/:/VERTEX SHADER ERROR: 0:(\d+?):/;let A=null;if(h&&Z){const H=h.match(v);if(H&&2===H.length){const h=parseInt(H[1]),v=Z.split("\n",-1);v.length>=h&&(A=`Offending line [${h}] in ${V?"fragment":"vertex"} code: ${v[h-1]}`)}}return[Z,A]}_processCompilationErrors(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;this._compilationError=Z.message;const V=this._attributesNames,v=this._fallbacks;if(A.b.Error("Unable to compile effect:"),A.b.Error(`Uniforms: ${this._uniformsNames.join(" ")}`),A.b.Error(`Attributes: ${V.join(" ")}`),A.b.Error("Defines:\n"+this.defines),a.LogShaderCodeOnCompilationError){var H,K;let Z=null,h=null,V=null;var d;if(null!==(H=this._pipelineContext)&&void 0!==H&&H._getVertexShaderCode()&&([V,Z]=this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(),this._compilationError,!1),V&&(A.b.Error("Vertex code:"),A.b.Error(V))),null!==(K=this._pipelineContext)&&void 0!==K&&K._getFragmentShaderCode())[V,h]=this._getShaderCodeAndErrorLine(null===(d=this._pipelineContext)||void 0===d?void 0:d._getFragmentShaderCode(),this._compilationError,!0),V&&(A.b.Error("Fragment code:"),A.b.Error(V));Z&&A.b.Error(Z),h&&A.b.Error(h)}A.b.Error("Error: "+this._compilationError);const n=()=>{this.onError&&this.onError(this,this._compilationError),this.onErrorObservable.notifyObservers(this),this._engine.onEffectErrorObservable.notifyObservers({effect:this,errors:this._compilationError})};h&&(this._pipelineContext=h,this._isReady=!0,n()),v?(this._pipelineContext=null,v.hasMoreFallbacks?(this._allFallbacksProcessed=!1,A.b.Error("Trying next fallback."),this.defines=v.reduce(this.defines,this),this._prepareEffect()):(this._allFallbacksProcessed=!0,n(),this.onErrorObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh())):(this._allFallbacksProcessed=!0,h||n())}get isSupported(){return""===this._compilationError}_bindTexture(Z,h){this._engine._bindTexture(this._samplers[Z],h,Z)}setTexture(Z,h){this._engine.setTexture(this._samplers[Z],this._uniforms[Z],h,Z)}setTextureArray(Z,h){const V=Z+"Ex";if(-1===this._samplerList.indexOf(V+"0")){const v=this._samplerList.indexOf(Z);for(let Z=1;Z<h.length;Z++){const h=V+(Z-1).toString();this._samplerList.splice(v+Z,0,h)}let A=0;for(const Z of this._samplerList)this._samplers[Z]=A,A+=1}this._engine.setTextureArray(this._samplers[Z],this._uniforms[Z],h,Z)}bindUniformBuffer(Z,h){const V=this._uniformBuffersNames[h];void 0===V||a._BaseCache[V]===Z&&this._engine._features.useUBOBindingCache||(a._BaseCache[V]=Z,this._engine.bindUniformBufferBase(Z,V,h))}bindUniformBlock(Z,h){this._engine.bindUniformBlock(this._pipelineContext,Z,h)}setInt(Z,h){return this._pipelineContext.setInt(Z,h),this}setInt2(Z,h,V){return this._pipelineContext.setInt2(Z,h,V),this}setInt3(Z,h,V,v){return this._pipelineContext.setInt3(Z,h,V,v),this}setInt4(Z,h,V,v,A){return this._pipelineContext.setInt4(Z,h,V,v,A),this}setIntArray(Z,h){return this._pipelineContext.setIntArray(Z,h),this}setIntArray2(Z,h){return this._pipelineContext.setIntArray2(Z,h),this}setIntArray3(Z,h){return this._pipelineContext.setIntArray3(Z,h),this}setIntArray4(Z,h){return this._pipelineContext.setIntArray4(Z,h),this}setUInt(Z,h){return this._pipelineContext.setUInt(Z,h),this}setUInt2(Z,h,V){return this._pipelineContext.setUInt2(Z,h,V),this}setUInt3(Z,h,V,v){return this._pipelineContext.setUInt3(Z,h,V,v),this}setUInt4(Z,h,V,v,A){return this._pipelineContext.setUInt4(Z,h,V,v,A),this}setUIntArray(Z,h){return this._pipelineContext.setUIntArray(Z,h),this}setUIntArray2(Z,h){return this._pipelineContext.setUIntArray2(Z,h),this}setUIntArray3(Z,h){return this._pipelineContext.setUIntArray3(Z,h),this}setUIntArray4(Z,h){return this._pipelineContext.setUIntArray4(Z,h),this}setFloatArray(Z,h){return this._pipelineContext.setArray(Z,h),this}setFloatArray2(Z,h){return this._pipelineContext.setArray2(Z,h),this}setFloatArray3(Z,h){return this._pipelineContext.setArray3(Z,h),this}setFloatArray4(Z,h){return this._pipelineContext.setArray4(Z,h),this}setArray(Z,h){return this._pipelineContext.setArray(Z,h),this}setArray2(Z,h){return this._pipelineContext.setArray2(Z,h),this}setArray3(Z,h){return this._pipelineContext.setArray3(Z,h),this}setArray4(Z,h){return this._pipelineContext.setArray4(Z,h),this}setMatrices(Z,h){return this._pipelineContext.setMatrices(Z,h),this}setMatrix(Z,h){return this._pipelineContext.setMatrix(Z,h),this}setMatrix3x3(Z,h){return this._pipelineContext.setMatrix3x3(Z,h),this}setMatrix2x2(Z,h){return this._pipelineContext.setMatrix2x2(Z,h),this}setFloat(Z,h){return this._pipelineContext.setFloat(Z,h),this}setBool(Z,h){return this._pipelineContext.setInt(Z,h?1:0),this}setVector2(Z,h){return this._pipelineContext.setVector2(Z,h),this}setFloat2(Z,h,V){return this._pipelineContext.setFloat2(Z,h,V),this}setVector3(Z,h){return this._pipelineContext.setVector3(Z,h),this}setFloat3(Z,h,V,v){return this._pipelineContext.setFloat3(Z,h,V,v),this}setVector4(Z,h){return this._pipelineContext.setVector4(Z,h),this}setQuaternion(Z,h){return this._pipelineContext.setQuaternion(Z,h),this}setFloat4(Z,h,V,v,A){return this._pipelineContext.setFloat4(Z,h,V,v,A),this}setColor3(Z,h){return this._pipelineContext.setColor3(Z,h),this}setColor4(Z,h,V){return this._pipelineContext.setColor4(Z,h,V),this}setDirectColor4(Z,h){return this._pipelineContext.setDirectColor4(Z,h),this}clearCodeCache(){this._vertexSourceCode="",this._fragmentSourceCode="",this._fragmentSourceCodeBeforeMigration="",this._vertexSourceCodeBeforeMigration=""}dispose(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])this._refCount=0;else{if(a.PersistentMode)return;this._refCount--}this._refCount>0||this._isDisposed||(this._pipelineContext&&(0,K.i)(this._pipelineContext),this._engine._releaseEffect(this),this.clearCodeCache(),this._isDisposed=!0)}static RegisterShader(Z,h,V){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;h&&(H.c.GetShadersStore(v)[`${Z}PixelShader`]=h),V&&(H.c.GetShadersStore(v)[`${Z}VertexShader`]=V)}static ResetCache(){a._BaseCache={}}}a.LogShaderCodeOnCompilationError=!0,a.PersistentMode=!1,a.AutomaticallyClearCodeCache=!1,a._UniqueIdSeed=0,a._BaseCache={},a.ShadersStore=H.c.ShadersStore,a.IncludesShadersStore=H.c.IncludesShadersStore},11594:(Z,h,V)=>{V.d(h,{d:()=>A});const v={};function A(Z){if(!(arguments.length>1&&void 0!==arguments[1]&&arguments[1])||!v[Z])return v[Z]=!0,`${Z} needs to be imported before as it contains a side-effect required by your code.`}},11573:(Z,h,V)=>{function v(){return"undefined"!==typeof window}function A(){return"undefined"!==typeof navigator}function H(){return"undefined"!==typeof document}function K(Z){let h="",V=Z.firstChild;for(;V;)3===V.nodeType&&(h+=V.textContent),V=V.nextSibling;return h}V.d(h,{d:()=>K,g:()=>H,j:()=>A,m:()=>v})},11580:(Z,h,V)=>{V.d(h,{b:()=>v});class v{static _CheckLimit(Z,h){let V=v._LogLimitOutputs[Z];return V?V.current++:(V={limit:h,current:1},v._LogLimitOutputs[Z]=V),V.current<=V.limit}static _GenerateLimitMessage(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const V=v._LogLimitOutputs[Z];if(!V||!v.MessageLimitReached)return;const A=this._Levels[h];V.current===V.limit&&v[A.name](v.MessageLimitReached.replace(/%LIMIT%/g,""+V.limit).replace(/%TYPE%/g,A.name??""))}static _AddLogEntry(Z){v._LogCache=Z+v._LogCache,v.OnNewCacheEntry&&v.OnNewCacheEntry(Z)}static _FormatMessage(Z){const h=Z=>Z<10?"0"+Z:""+Z,V=new Date;return"["+h(V.getHours())+":"+h(V.getMinutes())+":"+h(V.getSeconds())+"]: "+Z}static _LogDisabled(Z,h){}static _LogEnabled(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,h=arguments.length>1?arguments[1]:void 0,V=arguments.length>2?arguments[2]:void 0;const A=Array.isArray(h)?h[0]:h;if(void 0!==V&&!v._CheckLimit(A,V))return;const H=v._FormatMessage(A),K=this._Levels[Z],d=Array.isArray(h)?h.slice(1):[];K.logFunc&&K.logFunc("BJS - "+H,...d);const a=`<div style='color:${K.color}'>${H}</div><br>`;v._AddLogEntry(a),v._GenerateLimitMessage(A,Z)}static get LogCache(){return v._LogCache}static ClearLogCache(){v._LogCache="",v._LogLimitOutputs={},v.errorsCount=0}static set LogLevels(Z){v.Log=v._LogDisabled,v.Warn=v._LogDisabled,v.Error=v._LogDisabled;const h=[v.MessageLogLevel,v.WarningLogLevel,v.ErrorLogLevel];for(const V of h)if((Z&V)===V){const Z=this._Levels[V];v[Z.name]=v._LogEnabled.bind(v,V)}}}v.NoneLogLevel=0,v.MessageLogLevel=1,v.WarningLogLevel=2,v.ErrorLogLevel=4,v.AllLogLevel=7,v.MessageLimitReached="Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.",v._LogCache="",v._LogLimitOutputs={},v._Levels=[{},{color:"white",logFunc:console.log,name:"Log"},{color:"orange",logFunc:console.warn,name:"Warn"},{},{color:"red",logFunc:console.error,name:"Error"}],v.errorsCount=0,v.Log=v._LogEnabled.bind(v,v.MessageLogLevel),v.Warn=v._LogEnabled.bind(v,v.WarningLogLevel),v.Error=v._LogEnabled.bind(v,v.ErrorLogLevel)},11566:(Z,h,V)=>{V.d(h,{b:()=>K});const v="undefined"!==typeof WeakRef;class A{constructor(Z){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2?arguments[2]:void 0,v=arguments.length>3?arguments[3]:void 0;this.initialize(Z,h,V,v)}initialize(Z){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2?arguments[2]:void 0,v=arguments.length>3?arguments[3]:void 0;return this.mask=Z,this.skipNextObservers=h,this.target=V,this.currentTarget=v,this}}class H{constructor(Z,h){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this.callback=Z,this.mask=h,this.scope=V,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this._remove&&this._remove(Z)}}class K{static FromPromise(Z,h){const V=new K;return Z.then((Z=>{V.notifyObservers(Z)})).catch((Z=>{if(!h)throw Z;h.notifyObservers(Z)})),V}get observers(){return this._observers}constructor(Z){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.notifyIfTriggered=h,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new A(0),Z&&(this._onObserverAdded=Z)}add(Z){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],V=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Z)return null;const A=new H(Z,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null);A.unregisterOnNextCall=V,h?this._observers.unshift(A):this._observers.push(A),this._onObserverAdded&&this._onObserverAdded(A),this._hasNotified&&this.notifyIfTriggered&&void 0!==this._lastNotifiedValue&&this.notifyObserver(A,this._lastNotifiedValue);const K=v?new WeakRef(this):{deref:()=>this};return A._remove=function(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=K.deref();h&&(Z?h.remove(A):h._remove(A))},A}addOnce(Z){return this.add(Z,void 0,void 0,void 0,!0)}remove(Z){if(!Z)return!1;Z._remove=null;return-1!==this._observers.indexOf(Z)&&(this._deferUnregister(Z),!0)}removeCallback(Z,h){for(let V=0;V<this._observers.length;V++){const v=this._observers[V];if(!v._willBeUnregistered&&(v.callback===Z&&(!h||h===v.scope)))return this._deferUnregister(v),!0}return!1}_deferUnregister(Z){Z._willBeUnregistered||(this._numObserversMarkedAsDeleted++,Z.unregisterOnNextCall=!1,Z._willBeUnregistered=!0,setTimeout((()=>{this._remove(Z)}),0))}_remove(Z){let h=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!Z)return!1;const V=this._observers.indexOf(Z);return-1!==V&&(h&&this._numObserversMarkedAsDeleted--,this._observers.splice(V,1),!0)}makeObserverTopPriority(Z){this._remove(Z,!1),this._observers.unshift(Z)}makeObserverBottomPriority(Z){this._remove(Z,!1),this._observers.push(Z)}notifyObservers(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,V=arguments.length>2?arguments[2]:void 0,v=arguments.length>3?arguments[3]:void 0,A=arguments.length>4?arguments[4]:void 0;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=Z),!this._observers.length)return!0;const H=this._eventState;H.mask=h,H.target=V,H.currentTarget=v,H.skipNextObservers=!1,H.lastReturnValue=Z,H.userInfo=A;for(const K of this._observers)if(!K._willBeUnregistered&&(K.mask&h&&(K.unregisterOnNextCall&&this._deferUnregister(K),K.scope?H.lastReturnValue=K.callback.apply(K.scope,[Z,H]):H.lastReturnValue=K.callback(Z,H)),H.skipNextObservers))return!1;return!0}notifyObserver(Z,h){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=h),Z._willBeUnregistered)return;const v=this._eventState;v.mask=V,v.skipNextObservers=!1,Z.unregisterOnNextCall&&this._deferUnregister(Z),Z.callback(h,v)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const Z=this._observers.pop();Z&&(Z._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const Z=new K;return Z._observers=this._observers.slice(0),Z}hasSpecificMask(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;for(const h of this._observers)if(h.mask&Z||h.mask===Z)return!0;return!1}}},11633:(Z,h,V)=>{V.d(h,{e:()=>A,h:()=>K});let v=[];class A{static SetImmediate(Z){0===v.length&&setTimeout((()=>{const Z=v;v=[];for(const h of Z)h()}),1),v.push(Z)}}function H(Z,h,V){try{if(Z())return h(),!0}catch(v){return null===V||void 0===V||V(v),!0}return!1}const K=function(Z,h,V){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:16,A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:3e4,K=arguments.length>6?arguments[6]:void 0;if((!(arguments.length>5&&void 0!==arguments[5])||arguments[5])&&H(Z,h,V))return null;const d=setInterval((()=>{H(Z,h,V)?clearInterval(d):(A-=v,A<0&&(clearInterval(d),null===V||void 0===V||V(new Error("Operation timed out after maximum retries. "+(K||"")),!0)))}),v);return()=>clearInterval(d)}}}]);