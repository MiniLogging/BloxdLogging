"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[9],{11063:(Z,x,F)=>{F.d(x,{c:()=>y,g:()=>S,n:()=>K,k:()=>e,r:()=>b});class u{constructor(){this.children=[]}isValid(Z){return!0}process(Z,x,F){let u="";if(this.line){let F=this.line;const o=x.processor;if(o){var G,f,Y,j,d,t;o.lineProcessor&&(F=o.lineProcessor(F,x.isFragment,x.processingContext));const u=(null===(G=x.processor)||void 0===G?void 0:G.attributeKeywordName)??"attribute",c=x.isFragment&&null!==(f=x.processor)&&void 0!==f&&f.varyingFragmentKeywordName?null===(Y=x.processor)||void 0===Y?void 0:Y.varyingFragmentKeywordName:!x.isFragment&&null!==(j=x.processor)&&void 0!==j&&j.varyingVertexKeywordName?null===(d=x.processor)||void 0===d?void 0:d.varyingVertexKeywordName:"varying";if(!x.isFragment&&o.attributeProcessor&&this.line.startsWith(u))F=o.attributeProcessor(this.line,Z,x.processingContext);else if(o.varyingProcessor&&(null!==(t=o.varyingCheck)&&void 0!==t&&t.call(o,this.line,x.isFragment)||!o.varyingCheck&&this.line.startsWith(c)))F=o.varyingProcessor(this.line,x.isFragment,Z,x.processingContext);else if(o.uniformProcessor&&o.uniformRegexp&&o.uniformRegexp.test(this.line))x.lookForClosingBracketForUniformBuffer||(F=o.uniformProcessor(this.line,x.isFragment,Z,x.processingContext));else if(o.uniformBufferProcessor&&o.uniformBufferRegexp&&o.uniformBufferRegexp.test(this.line))x.lookForClosingBracketForUniformBuffer||(F=o.uniformBufferProcessor(this.line,x.isFragment,x.processingContext),x.lookForClosingBracketForUniformBuffer=!0);else if(o.textureProcessor&&o.textureRegexp&&o.textureRegexp.test(this.line))F=o.textureProcessor(this.line,x.isFragment,Z,x.processingContext);else if((o.uniformProcessor||o.uniformBufferProcessor)&&this.line.startsWith("uniform")&&!x.lookForClosingBracketForUniformBuffer){/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line)?o.uniformProcessor&&(F=o.uniformProcessor(this.line,x.isFragment,Z,x.processingContext)):o.uniformBufferProcessor&&(F=o.uniformBufferProcessor(this.line,x.isFragment,x.processingContext),x.lookForClosingBracketForUniformBuffer=!0)}x.lookForClosingBracketForUniformBuffer&&-1!==this.line.indexOf("}")&&(x.lookForClosingBracketForUniformBuffer=!1,o.endOfUniformBufferProcessor&&(F=o.endOfUniformBufferProcessor(this.line,x.isFragment,x.processingContext)))}u+=F+"\n"}for(const o of this.children)u+=o.process(Z,x,F);return this.additionalDefineKey&&(Z[this.additionalDefineKey]=this.additionalDefineValue||"true",F[this.additionalDefineKey]=Z[this.additionalDefineKey]),u}}class G{constructor(){this._lines=[]}get currentLine(){return this._lines[this.lineIndex]}get canRead(){return this.lineIndex<this._lines.length-1}set lines(Z){this._lines.length=0;for(const x of Z){if(!x||"\r"===x)continue;if("#"===x[0]){this._lines.push(x);continue}const Z=x.trim();if(!Z)continue;if(Z.startsWith("//")){this._lines.push(x);continue}const F=Z.indexOf(";");if(-1===F)this._lines.push(Z);else if(F===Z.length-1)Z.length>1&&this._lines.push(Z);else{const Z=x.split(";");for(let x=0;x<Z.length;x++){let F=Z[x];F&&(F=F.trim(),F&&this._lines.push(F+(x!==Z.length-1?";":"")))}}}}}class f extends u{process(Z,x,F){for(let u=0;u<this.children.length;u++){const G=this.children[u];if(G.isValid(Z))return G.process(Z,x,F)}return""}}class Y extends u{isValid(Z){return this.testExpression.isTrue(Z)}}class j{isTrue(Z){return!0}static postfixToInfix(Z){const x=[];for(const F of Z)if(void 0===j._OperatorPriority[F])x.push(F);else{const Z=x[x.length-1],u=x[x.length-2];x.length-=2,x.push(`(${u}${F}${Z})`)}return x[x.length-1]}static infixToPostfix(Z){const x=j._InfixToPostfixCache.get(Z);if(x)return x.accessTime=Date.now(),x.result;if(!Z.includes("&&")&&!Z.includes("||")&&!Z.includes(")")&&!Z.includes("("))return[Z];const F=[];let u=-1;const G=()=>{o=o.trim(),""!==o&&(F.push(o),o="")},f=Z=>{u<j._Stack.length-1&&(j._Stack[++u]=Z)},Y=()=>j._Stack[u],d=()=>-1===u?"!!INVALID EXPRESSION!!":j._Stack[u--];let t=0,o="";for(;t<Z.length;){const x=Z.charAt(t),c=t<Z.length-1?Z.substring(t,2+t):"";if("("===x)o="",f(x);else if(")"===x){for(G();-1!==u&&"("!==Y();)F.push(d());d()}else if(j._OperatorPriority[c]>1){for(G();-1!==u&&j._OperatorPriority[Y()]>=j._OperatorPriority[c];)F.push(d());f(c),t++}else o+=x;t++}for(G();-1!==u;)"("===Y()?d():F.push(d());return j._InfixToPostfixCache.size>=j.InfixToPostfixCacheLimitSize&&j.ClearCache(),j._InfixToPostfixCache.set(Z,{result:F,accessTime:Date.now()}),F}static ClearCache(){const Z=Array.from(j._InfixToPostfixCache.entries()).sort(((Z,x)=>Z[1].accessTime-x[1].accessTime));for(let x=0;x<j.InfixToPostfixCacheCleanupSize;x++)j._InfixToPostfixCache.delete(Z[x][0])}}j.InfixToPostfixCacheLimitSize=5e4,j.InfixToPostfixCacheCleanupSize=25e3,j._InfixToPostfixCache=new Map,j._OperatorPriority={")":0,"(":1,"||":2,"&&":3},j._Stack=["","","","","","","","","","","","","","","","","","","",""];class d extends j{constructor(Z){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super(),this.define=Z,this.not=x}isTrue(Z){let x=void 0!==Z[this.define];return this.not&&(x=!x),x}}class t extends j{isTrue(Z){return this.leftOperand.isTrue(Z)||this.rightOperand.isTrue(Z)}}class o extends j{isTrue(Z){return this.leftOperand.isTrue(Z)&&this.rightOperand.isTrue(Z)}}class c extends j{constructor(Z,x,F){super(),this.define=Z,this.operand=x,this.testValue=F}toString(){return`${this.define} ${this.operand} ${this.testValue}`}isTrue(Z){let x=!1;const F=parseInt(void 0!=Z[this.define]?Z[this.define]:this.define),u=parseInt(void 0!=Z[this.testValue]?Z[this.testValue]:this.testValue);if(isNaN(F)||isNaN(u))return!1;switch(this.operand){case">":x=F>u;break;case"<":x=F<u;break;case"<=":x=F<=u;break;case">=":x=F>=u;break;case"==":x=F===u;break;case"!=":x=F!==u}return x}}var s=F(11029),J=F(11067);const p=/defined\s*?\((.+?)\)/g,U=/defined\s*?\[(.+?)\]/g,k=/#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,M=/__decl__/,m=/light\{X\}.(\w*)/g,C=/\{X\}/g,L=[],H=/(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;function S(Z){Z.processor&&Z.processor.initializeShaders&&Z.processor.initializeShaders(Z.processingContext)}function K(Z,x,F,u){var G;null!==(G=x.processor)&&void 0!==G&&G.preProcessShaderCode&&(Z=x.processor.preProcessShaderCode(Z,x.isFragment)),e(Z,x,(Z=>{x.processCodeAfterIncludes&&(Z=x.processCodeAfterIncludes(x.isFragment?"fragment":"vertex",Z,x.defines));const G=function(Z,x,F){let u=function(Z,x){var F;if(null!==(F=x.processor)&&void 0!==F&&F.noPrecision)return Z;const u=x.shouldUseHighPrecisionShader;-1===Z.indexOf("precision highp float")?Z=u?"precision highp float;\n"+Z:"precision mediump float;\n"+Z:u||(Z=Z.replace("precision highp float","precision mediump float"));return Z}(Z,x);if(!x.processor)return u;if(0===x.processor.shaderLanguage&&-1!==u.indexOf("#version 3")&&(u=u.replace("#version 300 es",""),!x.processor.parseGLES3))return u;const G=x.defines,f=i(x,F);x.processor.preProcessor&&(u=x.processor.preProcessor(u,G,f,x.isFragment,x.processingContext));const Y={};u=l(u,f,x,Y),x.processor.postProcessor&&(u=x.processor.postProcessor(u,G,x.isFragment,x.processingContext,F?{drawBuffersExtensionDisabled:!F.getCaps().drawBuffersExtension}:{},f,Y));null!==F&&void 0!==F&&F._features.needShaderCodeInlining&&(u=F.inlineShaderCode(u));return u}(Z,x,u);F(G,Z)}))}function y(Z,x,F){return F.processor&&F.processor.finalizeShaders?F.processor.finalizeShaders(Z,x,F.processingContext):{vertexCode:Z,fragmentCode:x}}function q(Z){const x=/defined\((.+)\)/.exec(Z);if(x&&x.length)return new d(x[1].trim(),"!"===Z[0]);const F=["==","!=",">=","<=","<",">"];let u="",G=0;for(u of F)if(G=Z.indexOf(u),G>-1)break;if(-1===G)return new d(Z);const f=Z.substring(0,G).trim(),Y=Z.substring(G+u.length).trim();return new c(f,u,Y)}function R(Z,x){const F=new Y,u=Z.substring(0,x);let G=Z.substring(x);return G=G.substring(0,(G.indexOf("//")+1||G.length+1)-1).trim(),F.testExpression="#ifdef"===u?new d(G):"#ifndef"===u?new d(G,!0):function(Z){Z=Z.replace(p,"defined[$1]");const x=j.infixToPostfix(Z),F=[];for(const G of x)if("||"!==G&&"&&"!==G)F.push(G);else if(F.length>=2){let Z=F[F.length-1],x=F[F.length-2];F.length-=2;const u="&&"==G?new o:new t;"string"===typeof Z&&(Z=Z.replace(U,"defined($1)")),"string"===typeof x&&(x=x.replace(U,"defined($1)")),u.leftOperand="string"===typeof x?q(x):x,u.rightOperand="string"===typeof Z?q(Z):Z,F.push(u)}let u=F[F.length-1];return"string"===typeof u&&(u=u.replace(U,"defined($1)")),"string"===typeof u?q(u):u}(G),F}function B(Z,x,F,G){let f=Z.currentLine;for(;v(Z,F,G);){f=Z.currentLine;const Y=f.substring(0,5).toLowerCase();if("#else"===Y){const F=new u;return x.children.push(F),void v(Z,F,G)}if("#elif"===Y){const Z=R(f,5);x.children.push(Z),F=Z}}}function v(Z,x,F){for(;Z.canRead;){Z.lineIndex++;const G=Z.currentLine;if(G.indexOf("#")>=0){const u=H.exec(G);if(u&&u.length){switch(u[0]){case"#ifdef":{const u=new f;x.children.push(u);const Y=R(G,6);u.children.push(Y),B(Z,u,Y,F);break}case"#else":case"#elif":return!0;case"#endif":return!1;case"#ifndef":{const u=new f;x.children.push(u);const Y=R(G,7);u.children.push(Y),B(Z,u,Y,F);break}case"#if":{const u=new f,Y=R(G,3);x.children.push(u),u.children.push(Y),B(Z,u,Y,F);break}}continue}}const Y=new u;if(Y.line=G,x.children.push(Y),"#"===G[0]&&"d"===G[1]){const Z=G.replace(";","").split(" ");Y.additionalDefineKey=Z[1],3===Z.length&&(Y.additionalDefineValue=Z[2])}}return!1}function l(Z,x,F,f){const Y=new u,j=new G;return j.lineIndex=-1,j.lines=Z.split("\n"),v(j,Y,f),Y.process(x,F,f)}function i(Z,x){var F;const u=Z.defines,G={};for(const f of u){const Z=f.replace("#define","").replace(";","").trim().split(" ");G[Z[0]]=Z.length>1?Z[1]:""}return 0===(null===(F=Z.processor)||void 0===F?void 0:F.shaderLanguage)&&(G.GL_ES="true"),G.__VERSION__=Z.version,G[Z.platformName]="true",(0,J.h)(G,null===x||void 0===x?void 0:x.isNDCHalfZRange,null===x||void 0===x?void 0:x.useReverseDepthBuffer,null===x||void 0===x?void 0:x.useExactSrgbConversions),G}function e(Z,x,F){let u;for(L.length=0;null!==(u=k.exec(Z));)L.push(u);let G=String(Z),f=[Z],Y=!1;for(const j of L){let Z=j[1];if(-1!==Z.indexOf("__decl__")&&(Z=Z.replace(M,""),x.supportsUniformBuffers&&(Z=Z.replace("Vertex","Ubo").replace("Fragment","Ubo")),Z+="Declaration"),!x.includesShadersStore[Z]){const u=x.shadersRepository+"ShadersInclude/"+Z+".fx";return void b.loadFile(u,(u=>{x.includesShadersStore[Z]=u,e(f.join(""),x,F)}))}{let F=x.includesShadersStore[Z];if(j[2]){const Z=j[3].split(",");for(let x=0;x<Z.length;x+=2){const u=new RegExp(Z[x],"g"),G=Z[x+1];F=F.replace(u,G)}}if(j[4]){const Z=j[5];if(-1!==Z.indexOf("..")){const u=Z.split(".."),G=parseInt(u[0]);let f=parseInt(u[1]),Y=F.slice(0);F="",isNaN(f)&&(f=x.indexParameters[u[1]]);for(let Z=G;Z<f;Z++)x.supportsUniformBuffers||(Y=Y.replace(m,((Z,x)=>x+"{X}"))),F+=Y.replace(C,Z.toString())+"\n"}else x.supportsUniformBuffers||(F=F.replace(m,((Z,x)=>x+"{X}"))),F=F.replace(C,Z)}const u=[];for(const Z of f){const x=Z.split(j[0]);for(let Z=0;Z<x.length-1;Z++)u.push(x[Z]),u.push(F);u.push(x[x.length-1])}f=u,Y=Y||F.indexOf("#include<")>=0||F.indexOf("#include <")>=0}}L.length=0,G=f.join(""),Y?e(G.toString(),x,F):F(G)}const b={loadFile:(Z,x,F,u,G,f)=>{throw(0,s.e)("FileTools")}}},11067:(Z,x,F)=>{F.d(x,{c:()=>G,f:()=>f,h:()=>j,k:()=>Y,o:()=>d});var u=F(11029);F(11004);const G={};function f(Z,x){return(arguments.length>2&&void 0!==arguments[2]?arguments[2]:"")+(x?x+"\n":"")+Z}function Y(Z,x,F,f,Y,j,d){const t=d||G.loadFile;if(t){return t(Z,x,F,f,Y,j)}throw(0,u.e)("FileTools")}function j(Z,x,F,u){if(Z)return x?Z.IS_NDC_HALF_ZRANGE="":delete Z.IS_NDC_HALF_ZRANGE,F?Z.USE_REVERSE_DEPTHBUFFER="":delete Z.USE_REVERSE_DEPTHBUFFER,void(u?Z.USE_EXACT_SRGB_CONVERSIONS="":delete Z.USE_EXACT_SRGB_CONVERSIONS);{let Z="";return x&&(Z+="#define IS_NDC_HALF_ZRANGE"),F&&(Z&&(Z+="\n"),Z+="#define USE_REVERSE_DEPTHBUFFER"),u&&(Z&&(Z+="\n"),Z+="#define USE_EXACT_SRGB_CONVERSIONS"),Z}}function d(Z,x){let F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],u=arguments.length>3?arguments[3]:void 0;switch(Z){case 3:{const Z=(ArrayBuffer,new Int8Array(x));return u&&Z.set(new Int8Array(u)),Z}case 0:{const Z=(ArrayBuffer,new Uint8Array(x));return u&&Z.set(new Uint8Array(u)),Z}case 4:{const Z=x instanceof ArrayBuffer?new Int16Array(x):new Int16Array(F?x/2:x);return u&&Z.set(new Int16Array(u)),Z}case 5:case 8:case 9:case 10:case 2:{const Z=x instanceof ArrayBuffer?new Uint16Array(x):new Uint16Array(F?x/2:x);return u&&Z.set(new Uint16Array(u)),Z}case 6:{const Z=x instanceof ArrayBuffer?new Int32Array(x):new Int32Array(F?x/4:x);return u&&Z.set(new Int32Array(u)),Z}case 7:case 11:case 12:case 13:case 14:case 15:{const Z=x instanceof ArrayBuffer?new Uint32Array(x):new Uint32Array(F?x/4:x);return u&&Z.set(new Uint32Array(u)),Z}case 1:{const Z=x instanceof ArrayBuffer?new Float32Array(x):new Float32Array(F?x/4:x);return u&&Z.set(new Float32Array(u)),Z}}const G=(ArrayBuffer,new Uint8Array(x));return u&&G.set(new Uint8Array(u)),G}},11091:(Z,x,F)=>{F.d(x,{d:()=>u});class u{static GetShadersRepository(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?u.ShadersRepository:u.ShadersRepositoryWGSL}static GetShadersStore(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?u.ShadersStore:u.ShadersStoreWGSL}static GetIncludesShadersStore(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?u.IncludesShadersStore:u.IncludesShadersStoreWGSL}}u.ShadersRepository="src/Shaders/",u.ShadersStore={},u.IncludesShadersStore={},u.ShadersRepositoryWGSL="src/ShadersWGSL/",u.ShadersStoreWGSL={},u.IncludesShadersStoreWGSL={}},11103:(Z,x,F)=>{F.d(x,{b:()=>s,d:()=>C,e:()=>p,g:()=>J,j:()=>U,k:()=>m,l:()=>c,n:()=>t,q:()=>o,t:()=>d,v:()=>j});class u{constructor(){this._valueCache={},this.vertexCompilationError=null,this.fragmentCompilationError=null,this.programLinkError=null,this.programValidationError=null,this._isDisposed=!1}get isAsync(){return this.isParallelCompiled}get isReady(){return!!this.program&&(!this.isParallelCompiled||this.Ux._isRenderingStateCompiled(this))}_handlesSpectorRebuildCallback(Z){Z&&this.program&&Z(this.program)}setEngine(Z){this.Ux=Z}_fillEffectInformation(Z,x,F,u,G,f,Y,j){const d=this.Ux;if(d.supportsUniformBuffers)for(const o in x)Z.bindUniformBlock(o,x[o]);let t;for(this.Ux.getUniforms(this,F).forEach(((Z,x)=>{u[F[x]]=Z})),this._uniforms=u,t=0;t<G.length;t++){null==Z.getUniform(G[t])&&(G.splice(t,1),t--)}G.forEach(((Z,x)=>{f[Z]=x}));for(const o of d.getAttributes(this,Y))j.push(o)}dispose(){this._uniforms={},this._isDisposed=!0}_cacheMatrix(Z,x){const F=this._valueCache[Z],u=x.updateFlag;return(void 0===F||F!==u)&&(this._valueCache[Z]=u,!0)}_cacheFloat2(Z,x,F){let u=this._valueCache[Z];if(!u||2!==u.length)return u=[x,F],this._valueCache[Z]=u,!0;let G=!1;return u[0]!==x&&(u[0]=x,G=!0),u[1]!==F&&(u[1]=F,G=!0),G}_cacheFloat3(Z,x,F,u){let G=this._valueCache[Z];if(!G||3!==G.length)return G=[x,F,u],this._valueCache[Z]=G,!0;let f=!1;return G[0]!==x&&(G[0]=x,f=!0),G[1]!==F&&(G[1]=F,f=!0),G[2]!==u&&(G[2]=u,f=!0),f}_cacheFloat4(Z,x,F,u,G){let f=this._valueCache[Z];if(!f||4!==f.length)return f=[x,F,u,G],this._valueCache[Z]=f,!0;let Y=!1;return f[0]!==x&&(f[0]=x,Y=!0),f[1]!==F&&(f[1]=F,Y=!0),f[2]!==u&&(f[2]=u,Y=!0),f[3]!==G&&(f[3]=G,Y=!0),Y}setInt(Z,x){const F=this._valueCache[Z];void 0!==F&&F===x||this.Ux.setInt(this._uniforms[Z],x)&&(this._valueCache[Z]=x)}setInt2(Z,x,F){this._cacheFloat2(Z,x,F)&&(this.Ux.setInt2(this._uniforms[Z],x,F)||(this._valueCache[Z]=null))}setInt3(Z,x,F,u){this._cacheFloat3(Z,x,F,u)&&(this.Ux.setInt3(this._uniforms[Z],x,F,u)||(this._valueCache[Z]=null))}setInt4(Z,x,F,u,G){this._cacheFloat4(Z,x,F,u,G)&&(this.Ux.setInt4(this._uniforms[Z],x,F,u,G)||(this._valueCache[Z]=null))}setIntArray(Z,x){this._valueCache[Z]=null,this.Ux.setIntArray(this._uniforms[Z],x)}setIntArray2(Z,x){this._valueCache[Z]=null,this.Ux.setIntArray2(this._uniforms[Z],x)}setIntArray3(Z,x){this._valueCache[Z]=null,this.Ux.setIntArray3(this._uniforms[Z],x)}setIntArray4(Z,x){this._valueCache[Z]=null,this.Ux.setIntArray4(this._uniforms[Z],x)}setUInt(Z,x){const F=this._valueCache[Z];void 0!==F&&F===x||this.Ux.setUInt(this._uniforms[Z],x)&&(this._valueCache[Z]=x)}setUInt2(Z,x,F){this._cacheFloat2(Z,x,F)&&(this.Ux.setUInt2(this._uniforms[Z],x,F)||(this._valueCache[Z]=null))}setUInt3(Z,x,F,u){this._cacheFloat3(Z,x,F,u)&&(this.Ux.setUInt3(this._uniforms[Z],x,F,u)||(this._valueCache[Z]=null))}setUInt4(Z,x,F,u,G){this._cacheFloat4(Z,x,F,u,G)&&(this.Ux.setUInt4(this._uniforms[Z],x,F,u,G)||(this._valueCache[Z]=null))}setUIntArray(Z,x){this._valueCache[Z]=null,this.Ux.setUIntArray(this._uniforms[Z],x)}setUIntArray2(Z,x){this._valueCache[Z]=null,this.Ux.setUIntArray2(this._uniforms[Z],x)}setUIntArray3(Z,x){this._valueCache[Z]=null,this.Ux.setUIntArray3(this._uniforms[Z],x)}setUIntArray4(Z,x){this._valueCache[Z]=null,this.Ux.setUIntArray4(this._uniforms[Z],x)}setArray(Z,x){this._valueCache[Z]=null,this.Ux.setArray(this._uniforms[Z],x)}setArray2(Z,x){this._valueCache[Z]=null,this.Ux.setArray2(this._uniforms[Z],x)}setArray3(Z,x){this._valueCache[Z]=null,this.Ux.setArray3(this._uniforms[Z],x)}setArray4(Z,x){this._valueCache[Z]=null,this.Ux.setArray4(this._uniforms[Z],x)}setMatrices(Z,x){x&&(this._valueCache[Z]=null,this.Ux.setMatrices(this._uniforms[Z],x))}setMatrix(Z,x){this._cacheMatrix(Z,x)&&(this.Ux.setMatrices(this._uniforms[Z],x.Wf())||(this._valueCache[Z]=null))}setMatrix3x3(Z,x){this._valueCache[Z]=null,this.Ux.setMatrix3x3(this._uniforms[Z],x)}setMatrix2x2(Z,x){this._valueCache[Z]=null,this.Ux.setMatrix2x2(this._uniforms[Z],x)}setFloat(Z,x){const F=this._valueCache[Z];void 0!==F&&F===x||this.Ux.setFloat(this._uniforms[Z],x)&&(this._valueCache[Z]=x)}setVector2(Z,x){this._cacheFloat2(Z,x.x,x.y)&&(this.Ux.setFloat2(this._uniforms[Z],x.x,x.y)||(this._valueCache[Z]=null))}setFloat2(Z,x,F){this._cacheFloat2(Z,x,F)&&(this.Ux.setFloat2(this._uniforms[Z],x,F)||(this._valueCache[Z]=null))}setVector3(Z,x){this._cacheFloat3(Z,x.x,x.y,x.z)&&(this.Ux.setFloat3(this._uniforms[Z],x.x,x.y,x.z)||(this._valueCache[Z]=null))}setFloat3(Z,x,F,u){this._cacheFloat3(Z,x,F,u)&&(this.Ux.setFloat3(this._uniforms[Z],x,F,u)||(this._valueCache[Z]=null))}setVector4(Z,x){this._cacheFloat4(Z,x.x,x.y,x.z,x.w)&&(this.Ux.setFloat4(this._uniforms[Z],x.x,x.y,x.z,x.w)||(this._valueCache[Z]=null))}setQuaternion(Z,x){this._cacheFloat4(Z,x.x,x.y,x.z,x.w)&&(this.Ux.setFloat4(this._uniforms[Z],x.x,x.y,x.z,x.w)||(this._valueCache[Z]=null))}setFloat4(Z,x,F,u,G){this._cacheFloat4(Z,x,F,u,G)&&(this.Ux.setFloat4(this._uniforms[Z],x,F,u,G)||(this._valueCache[Z]=null))}setColor3(Z,x){this._cacheFloat3(Z,x.r,x.g,x.b)&&(this.Ux.setFloat3(this._uniforms[Z],x.r,x.g,x.b)||(this._valueCache[Z]=null))}setColor4(Z,x,F){this._cacheFloat4(Z,x.r,x.g,x.b,F)&&(this.Ux.setFloat4(this._uniforms[Z],x.r,x.g,x.b,F)||(this._valueCache[Z]=null))}setDirectColor4(Z,x){this._cacheFloat4(Z,x.r,x.g,x.b,x.a)&&(this.Ux.setFloat4(this._uniforms[Z],x.r,x.g,x.b,x.a)||(this._valueCache[Z]=null))}_getVertexShaderCode(){return this.vertexShader?this.Ux._getShaderSource(this.vertexShader):null}_getFragmentShaderCode(){return this.fragmentShader?this.Ux._getShaderSource(this.fragmentShader):null}}var G=F(11067);const f=new WeakMap,Y={_webGLVersion:2,cachedPipelines:{}};function j(Z){let x=f.get(Z);if(!x){if(!Z)return Y;x={_webGLVersion:Z.TEXTURE_BINDING_3D?2:1,_context:Z,parallelShaderCompile:Z.getExtension("KHR_parallel_shader_compile")||void 0,cachedPipelines:{}},f.set(Z,x)}return x}function d(Z){f.delete(Z)}function t(Z,x,F,u,G,f){const Y=j(u);f||(f=Y._createShaderProgramInjection??s);return f(Z,M(x,"vertex",u,Y._contextWasLost),M(F,"fragment",u,Y._contextWasLost),u,G,Y.validateShaderPrograms)}function o(Z,x,F,u,G){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,Y=arguments.length>6?arguments[6]:void 0;const d=j(G);Y||(Y=d._createShaderProgramInjection??s);const t=d._webGLVersion>1?"#version 300 es\n#define WEBGL2 \n":"";return Y(Z,k(x,"vertex",u,t,G,d._contextWasLost),k(F,"fragment",u,t,G,d._contextWasLost),G,f,d.validateShaderPrograms)}function c(Z,x){const F=new u,G=j(Z);return G.parallelShaderCompile&&!G.disableParallelShaderCompile&&(F.isParallelCompiled=!0),F.context=G._context,F}function s(Z,x,F,u){let G=arguments.length>5?arguments[5]:void 0;const f=u.createProgram();if(Z.program=f,!f)throw new Error("Unable to create program");return u.attachShader(f,x),u.attachShader(f,F),u.linkProgram(f),Z.context=u,Z.vertexShader=x,Z.fragmentShader=F,Z.isParallelCompiled||p(Z,u,G),f}function J(Z,x,F){const u=Z;if(u._isDisposed)return!1;const G=j(x);return!!(G&&G.parallelShaderCompile&&G.parallelShaderCompile.COMPLETION_STATUS_KHR&&u.program&&x.getProgramParameter(u.program,G.parallelShaderCompile.COMPLETION_STATUS_KHR))&&(p(u,x,F),!0)}function p(Z,x,F){const u=Z.context,G=Z.vertexShader,f=Z.fragmentShader,Y=Z.program;if(!u.getProgramParameter(Y,u.LINK_STATUS)){if(!x.getShaderParameter(G,x.COMPILE_STATUS)){const F=x.getShaderInfoLog(G);if(F)throw Z.vertexCompilationError=F,new Error("VERTEX SHADER "+F)}if(!x.getShaderParameter(f,x.COMPILE_STATUS)){const F=x.getShaderInfoLog(f);if(F)throw Z.fragmentCompilationError=F,new Error("FRAGMENT SHADER "+F)}const F=u.getProgramInfoLog(Y);if(F)throw Z.programLinkError=F,new Error(F)}if(F){u.validateProgram(Y);if(!u.getProgramParameter(Y,u.VALIDATE_STATUS)){const x=u.getProgramInfoLog(Y);if(x)throw Z.programValidationError=x,new Error(x)}}u.deleteShader(G),u.deleteShader(f),Z.vertexShader=void 0,Z.fragmentShader=void 0,Z.onCompiled&&(Z.onCompiled(),Z.onCompiled=void 0)}function U(Z,x,F,u,G,f,Y,d,c){let s=arguments.length>10?arguments[10]:void 0,J=arguments.length>11?arguments[11]:void 0,p=arguments.length>12?arguments[12]:void 0;const U=j(Z.context);J||(J=U.createRawShaderProgramInjection??t),p||(p=U.createShaderProgramInjection??o);const k=Z;k.program=u?J(k,x,F,k.context,c):p(k,x,F,d,k.context,c),k.program.__SPECTOR_rebuildProgram=Y,s()}function k(Z,x,F,u,f,Y){return M((0,G.f)(Z,F,u),x,f,Y)}function M(Z,x,F,u){const G=F.createShader("vertex"===x?F.VERTEX_SHADER:F.FRAGMENT_SHADER);if(!G){let Z=F.NO_ERROR,G=F.NO_ERROR;for(;(G=F.getError())!==F.NO_ERROR;)Z=G;throw new Error(`Something went wrong while creating a gl ${x} shader object. gl error=${Z}, gl isContextLost=${F.isContextLost()}, _contextWasLost=${u}`)}return F.shaderSource(G,Z),F.compileShader(G),G}function m(Z,x){x.useProgram(Z)}function C(Z,x){const F=Z;if(!F.isParallelCompiled)return void x(Z);const u=F.onCompiled;F.onCompiled=()=>{null===u||void 0===u||u(),x(Z)}}},11099:(Z,x,F)=>{F.d(x,{e:()=>c,i:()=>J,l:()=>t,p:()=>o});var u=F(11004),G=F(11103),f=F(11091),Y=F(11012),j=F(11063),d=F(11067);function t(Z,x){return(0,G.v)(x).cachedPipelines[Z]}function o(Z){const x=Z._name,F=Z.context;if(x&&F){const Z=(0,G.v)(F),u=Z.cachedPipelines[x];null===u||void 0===u||u.dispose(),delete Z.cachedPipelines[x]}}function c(Z,x,F,G,f,Y,d){let t,o;const c=(0,u.h)()?null===Y||void 0===Y?void 0:Y.getHostDocument():null;t="string"===typeof x?x:x.vertexSource?"source:"+x.vertexSource:x.vertexElement?(null===c||void 0===c?void 0:c.getElementById(x.vertexElement))||x.vertexElement:x.vertex||x,o="string"===typeof x?x:x.fragmentSource?"source:"+x.fragmentSource:x.fragmentElement?(null===c||void 0===c?void 0:c.getElementById(x.fragmentElement))||x.fragmentElement:x.fragment||x;const J=[void 0,void 0],p=()=>{if(J[0]&&J[1]){Z.isFragment=!0;const[u,t]=J;(0,j.n)(t,Z,((Y,t)=>{d&&(d._fragmentSourceCodeBeforeMigration=t),F&&(Y=F("fragment",Y));const o=(0,j.c)(u,Y,Z);Z=null;const c=function(Z,x,F,u){if(F){return{vertexSourceCode:(1===u?"//":"")+"#define SHADER_NAME vertex:"+(F.vertexElement||F.vertex||F.spectorName||F)+"\n"+Z,fragmentSourceCode:(1===u?"//":"")+"#define SHADER_NAME fragment:"+(F.fragmentElement||F.fragment||F.spectorName||F)+"\n"+x}}return{vertexSourceCode:Z,fragmentSourceCode:x}}(o.vertexCode,o.fragmentCode,x,f);null===G||void 0===G||G(c.vertexSourceCode,c.fragmentSourceCode)}),Y)}};s(t,"Vertex","",(x=>{(0,j.g)(Z),(0,j.n)(x,Z,((Z,u)=>{d&&(d._rawVertexSourceCode=x,d._vertexSourceCodeBeforeMigration=u),F&&(Z=F("vertex",Z)),J[0]=Z,p()}),Y)}),f),s(o,"Fragment","Pixel",(Z=>{d&&(d._rawFragmentSourceCode=Z),J[1]=Z,p()}),f)}function s(Z,x,F,G,Y,j){if("undefined"!==typeof HTMLElement&&Z instanceof HTMLElement){return void G((0,u.b)(Z))}if("source:"===Z.substring(0,7))return void G(Z.substring(7));if("base64:"===Z.substring(0,7)){return void G(window.atob(Z.substring(7)))}const t=f.d.GetShadersStore(Y);if(t[Z+x+"Shader"])return void G(t[Z+x+"Shader"]);if(F&&t[Z+F+"Shader"])return void G(t[Z+F+"Shader"]);let o;if(o="."===Z[0]||"/"===Z[0]||Z.indexOf("http")>-1?Z:f.d.GetShadersRepository(Y)+Z,!(j=j||d.k))throw new Error("loadFileInjection is not defined");j(o+"."+x.toLowerCase()+".fx",G)}const J=(Z,x,F,u)=>{try{const f=Z.context?(0,G.v)(Z.context):null;f&&(f.disableParallelShaderCompile=Z.disableParallelCompilation);const Y=Z.existingPipelineContext||x(Z.shaderProcessingContext);return Y._name=Z.name,Z.name&&f&&(f.cachedPipelines[Z.name]=Y),F(Y,Z.vertex,Z.fragment,!!Z.createAsRaw,"","",Z.rebuildRebind,Z.defines,Z.transformFeedbackVaryings,"",(()=>{u(Y,(()=>{var x;null===(x=Z.onRenderingStateCompiled)||void 0===x||x.call(Z,Y)}))})),Y}catch(f){throw Y.d.Error("Error compiling effect"),f}}},11088:(Z,x,F)=>{F.r(x),F.d(x,{Effect:()=>d});var u=F(11e3),G=F(11012),f=F(11091),Y=F(11099),j=F(11072);class d{static get ShadersRepository(){return f.d.ShadersRepository}static set ShadersRepository(Z){f.d.ShadersRepository=Z}get J(){return this._isDisposed}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new u.b),this._onBindObservable}get shaderLanguage(){return this._shaderLanguage}constructor(Z,x,F){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,f=arguments.length>4?arguments[4]:void 0,j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,t=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:null,s=arguments.length>9?arguments[9]:void 0,J=arguments.length>10&&void 0!==arguments[10]?arguments[10]:"",p=arguments.length>11&&void 0!==arguments[11]?arguments[11]:0,U=arguments.length>12?arguments[12]:void 0;this.defines="",this.onCompiled=null,this.onError=null,this.onBind=null,this.uniqueId=0,this.onCompileObservable=new u.b,this.onErrorObservable=new u.b,this._onBindObservable=null,this._isDisposed=!1,this._refCount=1,this._bonesComputationForcedToCPU=!1,this._uniformBuffersNames={},this._multiTarget=!1,this._samplers={},this._isReady=!1,this._compilationError="",this._allFallbacksProcessed=!1,this._uniforms={},this._key="",this._fallbacks=null,this._vertexSourceCodeOverride="",this._fragmentSourceCodeOverride="",this._transformFeedbackVaryings=null,this._disableParallelShaderCompilation=!1,this._pipelineContext=null,this._vertexSourceCode="",this._fragmentSourceCode="",this._vertexSourceCodeBeforeMigration="",this._fragmentSourceCodeBeforeMigration="",this._rawVertexSourceCode="",this._rawFragmentSourceCode="",this._processCodeAfterIncludes=void 0,this._processFinalCode=null,this.name=Z,this._key=J;const k=this._key.replace(/\r/g,"").replace(/\n/g,"|");let M;if(x.attributes){const Z=x;if(this._engine=F,this._attributesNames=Z.attributes,this._uniformsNames=Z.uniformsNames.concat(Z.samplers),this._samplerList=Z.samplers.slice(),this.defines=Z.defines,this.onError=Z.onError,this.onCompiled=Z.onCompiled,this._fallbacks=Z.fallbacks,this._indexParameters=Z.indexParameters,this._transformFeedbackVaryings=Z.transformFeedbackVaryings||null,this._multiTarget=!!Z.multiTarget,this._shaderLanguage=Z.shaderLanguage??0,this._disableParallelShaderCompilation=!!Z.disableParallelShaderCompilation,Z.uniformBuffersNames){this._uniformBuffersNamesList=Z.uniformBuffersNames.slice();for(let x=0;x<Z.uniformBuffersNames.length;x++)this._uniformBuffersNames[Z.uniformBuffersNames[x]]=x}this._processFinalCode=Z.processFinalCode??null,this._processCodeAfterIncludes=Z.processCodeAfterIncludes??void 0,U=Z.extraInitializationsAsync,M=Z.existingPipelineContext}else this._engine=f,this.defines=null==j?"":j,this._uniformsNames=F.concat(G),this._samplerList=G?G.slice():[],this._attributesNames=x,this._uniformBuffersNamesList=[],this._shaderLanguage=p,this.onError=c,this.onCompiled=o,this._indexParameters=s,this._fallbacks=t;"WEBGL2"===this._engine.shaderPlatformName&&(M=(0,Y.l)(k,this._engine._gl)??M),this._attributeLocationByName={},this.uniqueId=d._UniqueIdSeed++,M?(this._pipelineContext=M,this._pipelineContext.setEngine(this._engine),this._onRenderingStateCompiled(this._pipelineContext),this._pipelineContext.program&&(this._pipelineContext.program.__SPECTOR_rebuildProgram=this._rebuildProgram.bind(this))):this._processShaderCodeAsync(null,!1,null,U),this._engine.onReleaseEffectsObservable.addOnce((()=>{this.J||this.dispose(!0)}))}async _processShaderCodeAsync(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,u=arguments.length>3?arguments[3]:void 0;u&&await u(),this._processingContext=F||this._engine._getShaderProcessingContext(this._shaderLanguage,!1);const G={defines:this.defines.split("\n"),indexParameters:this._indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:Z??this._engine._getShaderProcessor(this._shaderLanguage),supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:f.d.GetShadersRepository(this._shaderLanguage),includesShadersStore:f.d.GetIncludesShadersStore(this._shaderLanguage),version:(100*this._engine.version).toString(),platformName:this._engine.shaderPlatformName,processingContext:this._processingContext,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:this._processCodeAfterIncludes};(0,Y.e)(G,this.name,this._processFinalCode,((Z,F)=>{this._vertexSourceCode=Z,this._fragmentSourceCode=F,this._prepareEffect(x)}),this._shaderLanguage,this._engine,this)}get key(){return this._key}isReady(){try{return this._isReadyInternal()}catch{return!1}}_isReadyInternal(){return!!this._engine.J||(!!this._isReady||!!this._pipelineContext&&this._pipelineContext.isReady)}getEngine(){return this._engine}getPipelineContext(){return this._pipelineContext}getAttributesNames(){return this._attributesNames}getAttributeLocation(Z){return this._attributes[Z]}getAttributeLocationByName(Z){return this._attributeLocationByName[Z]}getAttributesCount(){return this._attributes.length}getUniformIndex(Z){return this._uniformsNames.indexOf(Z)}getUniform(Z){return this._uniforms[Z]}getSamplers(){return this._samplerList}getUniformNames(){return this._uniformsNames}getUniformBuffersNames(){return this._uniformBuffersNamesList}getIndexParameters(){return this._indexParameters}getCompilationError(){return this._compilationError}allFallbacksProcessed(){return this._allFallbacksProcessed}async whenCompiledAsync(){return await new Promise((Z=>{this.executeWhenCompiled(Z)}))}executeWhenCompiled(Z){this.isReady()?Z(this):(this.onCompileObservable.add((x=>{Z(x)})),this._pipelineContext&&!this._pipelineContext.isAsync||this._checkIsReady(null))}_checkIsReady(Z){(0,j.h)((()=>this._isReadyInternal()||this._isDisposed),(()=>{}),(x=>{this._processCompilationErrors(x,Z)}),16,12e4,!0,` - Effect: ${"string"===typeof this.name?this.name:this.key}`)}get vertexSourceCode(){var Z;return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._vertexSourceCodeOverride:(null===(Z=this._pipelineContext)||void 0===Z?void 0:Z._getVertexShaderCode())??this._vertexSourceCode}get fragmentSourceCode(){var Z;return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._fragmentSourceCodeOverride:(null===(Z=this._pipelineContext)||void 0===Z?void 0:Z._getFragmentShaderCode())??this._fragmentSourceCode}get vertexSourceCodeBeforeMigration(){return this._vertexSourceCodeBeforeMigration}get fragmentSourceCodeBeforeMigration(){return this._fragmentSourceCodeBeforeMigration}get rawVertexSourceCode(){return this._rawVertexSourceCode}get rawFragmentSourceCode(){return this._rawFragmentSourceCode}getPipelineGenerationOptions(){return{platformName:this._engine.shaderPlatformName,shaderLanguage:this._shaderLanguage,shaderNameOrContent:this.name,key:this._key,defines:this.defines.split("\n"),addGlobalDefines:!1,extendedProcessingOptions:{indexParameters:this._indexParameters,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,supportsUniformBuffers:this._engine.supportsUniformBuffers},extendedCreatePipelineOptions:{transformFeedbackVaryings:this._transformFeedbackVaryings,createAsRaw:!(!this._vertexSourceCodeOverride||!this._fragmentSourceCodeOverride)}}}_rebuildProgram(Z,x,F,u){this._isReady=!1,this._vertexSourceCodeOverride=Z,this._fragmentSourceCodeOverride=x,this.onError=(Z,x)=>{u&&u(x)},this.onCompiled=()=>{var Z,x;const u=this.getEngine().scenes;if(u)for(let F=0;F<u.length;F++)u[F].markAllMaterialsAsDirty(127);null===(Z=(x=this._pipelineContext)._handlesSpectorRebuildCallback)||void 0===Z||Z.call(x,F)},this._fallbacks=null,this._prepareEffect()}_onRenderingStateCompiled(Z){if(this._pipelineContext=Z,this._pipelineContext.setEngine(this._engine),this._attributes=[],this._pipelineContext._fillEffectInformation(this,this._uniformBuffersNames,this._uniformsNames,this._uniforms,this._samplerList,this._samplers,this._attributesNames,this._attributes),this._attributesNames)for(let x=0;x<this._attributesNames.length;x++){const Z=this._attributesNames[x];this._attributeLocationByName[Z]=this._attributes[x]}this._engine.bindSamplers(this),this._compilationError="",this._isReady=!0,this.onCompiled&&this.onCompiled(this),this.onCompileObservable.notifyObservers(this),this.onCompileObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh(),d.AutomaticallyClearCodeCache&&this.clearCodeCache()}_prepareEffect(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=this._pipelineContext;this._isReady=!1;try{const F=!(!this._vertexSourceCodeOverride||!this._fragmentSourceCodeOverride),u=F?null:this.defines,G=F?this._vertexSourceCodeOverride:this._vertexSourceCode,f=F?this._fragmentSourceCodeOverride:this._fragmentSourceCode,j=this._engine;this._pipelineContext=(0,Y.i)({existingPipelineContext:Z?x:null,vertex:G,fragment:f,context:"WEBGL2"===j.shaderPlatformName||"WEBGL1"===j.shaderPlatformName?j._gl:void 0,rebuildRebind:(Z,x,F,u)=>this._rebuildProgram(Z,x,F,u),defines:u,transformFeedbackVaryings:this._transformFeedbackVaryings,name:this._key.replace(/\r/g,"").replace(/\n/g,"|"),createAsRaw:F,disableParallelCompilation:this._disableParallelShaderCompilation,shaderProcessingContext:this._processingContext,onRenderingStateCompiled:F=>{x&&!Z&&this._engine._deletePipelineContext(x),F&&this._onRenderingStateCompiled(F)}},this._engine.createPipelineContext.bind(this._engine),this._engine._preparePipelineContextAsync.bind(this._engine),this._engine._executeWhenRenderingStateIsCompiled.bind(this._engine)),this._pipelineContext.isAsync&&this._checkIsReady(x)}catch(F){this._processCompilationErrors(F,x)}}_getShaderCodeAndErrorLine(Z,x,F){const u=F?/FRAGMENT SHADER ERROR: 0:(\d+?):/:/VERTEX SHADER ERROR: 0:(\d+?):/;let G=null;if(x&&Z){const f=x.match(u);if(f&&2===f.length){const x=parseInt(f[1]),u=Z.split("\n",-1);u.length>=x&&(G=`Offending line [${x}] in ${F?"fragment":"vertex"} code: ${u[x-1]}`)}}return[Z,G]}_processCompilationErrors(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;this._compilationError=Z.message;const F=this._attributesNames,u=this._fallbacks;if(G.d.Error("Unable to compile effect:"),G.d.Error(`Uniforms: ${this._uniformsNames.join(" ")}`),G.d.Error(`Attributes: ${F.join(" ")}`),G.d.Error("Defines:\n"+this.defines),d.LogShaderCodeOnCompilationError){var f,Y;let Z=null,x=null,F=null;var j;if(null!==(f=this._pipelineContext)&&void 0!==f&&f._getVertexShaderCode()&&([F,Z]=this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(),this._compilationError,!1),F&&(G.d.Error("Vertex code:"),G.d.Error(F))),null!==(Y=this._pipelineContext)&&void 0!==Y&&Y._getFragmentShaderCode())[F,x]=this._getShaderCodeAndErrorLine(null===(j=this._pipelineContext)||void 0===j?void 0:j._getFragmentShaderCode(),this._compilationError,!0),F&&(G.d.Error("Fragment code:"),G.d.Error(F));Z&&G.d.Error(Z),x&&G.d.Error(x)}G.d.Error("Error: "+this._compilationError);const t=()=>{this.onError&&this.onError(this,this._compilationError),this.onErrorObservable.notifyObservers(this),this._engine.onEffectErrorObservable.notifyObservers({effect:this,errors:this._compilationError})};x&&(this._pipelineContext=x,this._isReady=!0,t()),u?(this._pipelineContext=null,u.hasMoreFallbacks?(this._allFallbacksProcessed=!1,G.d.Error("Trying next fallback."),this.defines=u.reduce(this.defines,this),this._prepareEffect()):(this._allFallbacksProcessed=!0,t(),this.onErrorObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh())):(this._allFallbacksProcessed=!0,x||t())}get isSupported(){return""===this._compilationError}_bindTexture(Z,x){this._engine._bindTexture(this._samplers[Z],x,Z)}setTexture(Z,x){this._engine.setTexture(this._samplers[Z],this._uniforms[Z],x,Z)}setTextureArray(Z,x){const F=Z+"Ex";if(-1===this._samplerList.indexOf(F+"0")){const u=this._samplerList.indexOf(Z);for(let Z=1;Z<x.length;Z++){const x=F+(Z-1).toString();this._samplerList.splice(u+Z,0,x)}let G=0;for(const Z of this._samplerList)this._samplers[Z]=G,G+=1}this._engine.setTextureArray(this._samplers[Z],this._uniforms[Z],x,Z)}bindUniformBuffer(Z,x){const F=this._uniformBuffersNames[x];void 0===F||d._BaseCache[F]===Z&&this._engine._features.useUBOBindingCache||(d._BaseCache[F]=Z,this._engine.bindUniformBufferBase(Z,F,x))}bindUniformBlock(Z,x){this._engine.bindUniformBlock(this._pipelineContext,Z,x)}setInt(Z,x){return this._pipelineContext.setInt(Z,x),this}setInt2(Z,x,F){return this._pipelineContext.setInt2(Z,x,F),this}setInt3(Z,x,F,u){return this._pipelineContext.setInt3(Z,x,F,u),this}setInt4(Z,x,F,u,G){return this._pipelineContext.setInt4(Z,x,F,u,G),this}setIntArray(Z,x){return this._pipelineContext.setIntArray(Z,x),this}setIntArray2(Z,x){return this._pipelineContext.setIntArray2(Z,x),this}setIntArray3(Z,x){return this._pipelineContext.setIntArray3(Z,x),this}setIntArray4(Z,x){return this._pipelineContext.setIntArray4(Z,x),this}setUInt(Z,x){return this._pipelineContext.setUInt(Z,x),this}setUInt2(Z,x,F){return this._pipelineContext.setUInt2(Z,x,F),this}setUInt3(Z,x,F,u){return this._pipelineContext.setUInt3(Z,x,F,u),this}setUInt4(Z,x,F,u,G){return this._pipelineContext.setUInt4(Z,x,F,u,G),this}setUIntArray(Z,x){return this._pipelineContext.setUIntArray(Z,x),this}setUIntArray2(Z,x){return this._pipelineContext.setUIntArray2(Z,x),this}setUIntArray3(Z,x){return this._pipelineContext.setUIntArray3(Z,x),this}setUIntArray4(Z,x){return this._pipelineContext.setUIntArray4(Z,x),this}setFloatArray(Z,x){return this._pipelineContext.setArray(Z,x),this}setFloatArray2(Z,x){return this._pipelineContext.setArray2(Z,x),this}setFloatArray3(Z,x){return this._pipelineContext.setArray3(Z,x),this}setFloatArray4(Z,x){return this._pipelineContext.setArray4(Z,x),this}setArray(Z,x){return this._pipelineContext.setArray(Z,x),this}setArray2(Z,x){return this._pipelineContext.setArray2(Z,x),this}setArray3(Z,x){return this._pipelineContext.setArray3(Z,x),this}setArray4(Z,x){return this._pipelineContext.setArray4(Z,x),this}setMatrices(Z,x){return this._pipelineContext.setMatrices(Z,x),this}setMatrix(Z,x){return this._pipelineContext.setMatrix(Z,x),this}setMatrix3x3(Z,x){return this._pipelineContext.setMatrix3x3(Z,x),this}setMatrix2x2(Z,x){return this._pipelineContext.setMatrix2x2(Z,x),this}setFloat(Z,x){return this._pipelineContext.setFloat(Z,x),this}setBool(Z,x){return this._pipelineContext.setInt(Z,x?1:0),this}setVector2(Z,x){return this._pipelineContext.setVector2(Z,x),this}setFloat2(Z,x,F){return this._pipelineContext.setFloat2(Z,x,F),this}setVector3(Z,x){return this._pipelineContext.setVector3(Z,x),this}setFloat3(Z,x,F,u){return this._pipelineContext.setFloat3(Z,x,F,u),this}setVector4(Z,x){return this._pipelineContext.setVector4(Z,x),this}setQuaternion(Z,x){return this._pipelineContext.setQuaternion(Z,x),this}setFloat4(Z,x,F,u,G){return this._pipelineContext.setFloat4(Z,x,F,u,G),this}setColor3(Z,x){return this._pipelineContext.setColor3(Z,x),this}setColor4(Z,x,F){return this._pipelineContext.setColor4(Z,x,F),this}setDirectColor4(Z,x){return this._pipelineContext.setDirectColor4(Z,x),this}clearCodeCache(){this._vertexSourceCode="",this._fragmentSourceCode="",this._fragmentSourceCodeBeforeMigration="",this._vertexSourceCodeBeforeMigration=""}dispose(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])this._refCount=0;else{if(d.PersistentMode)return;this._refCount--}this._refCount>0||this._isDisposed||(this._pipelineContext&&(0,Y.p)(this._pipelineContext),this._engine._releaseEffect(this),this.clearCodeCache(),this._isDisposed=!0)}static RegisterShader(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;x&&(f.d.GetShadersStore(u)[`${Z}PixelShader`]=x),F&&(f.d.GetShadersStore(u)[`${Z}VertexShader`]=F)}static ResetCache(){d._BaseCache={}}}d.LogShaderCodeOnCompilationError=!0,d.PersistentMode=!1,d.AutomaticallyClearCodeCache=!1,d._UniqueIdSeed=0,d._BaseCache={},d.ShadersStore=f.d.ShadersStore,d.IncludesShadersStore=f.d.IncludesShadersStore},11029:(Z,x,F)=>{F.d(x,{e:()=>G});const u={};function G(Z){if(!(arguments.length>1&&void 0!==arguments[1]&&arguments[1])||!u[Z])return u[Z]=!0,`${Z} needs to be imported before as it contains a side-effect required by your code.`}},11004:(Z,x,F)=>{function u(){return"undefined"!==typeof window}function G(){return"undefined"!==typeof navigator}function f(){return"undefined"!==typeof document}function Y(Z){let x="",F=Z.firstChild;for(;F;)3===F.nodeType&&(x+=F.textContent),F=F.nextSibling;return x}F.d(x,{b:()=>Y,e:()=>f,f:()=>G,h:()=>u})},11012:(Z,x,F)=>{F.d(x,{d:()=>u});class u{static _CheckLimit(Z,x){let F=u._LogLimitOutputs[Z];return F?F.current++:(F={limit:x,current:1},u._LogLimitOutputs[Z]=F),F.current<=F.limit}static _GenerateLimitMessage(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const F=u._LogLimitOutputs[Z];if(!F||!u.MessageLimitReached)return;const G=this._Levels[x];F.current===F.limit&&u[G.name](u.MessageLimitReached.replace(/%LIMIT%/g,""+F.limit).replace(/%TYPE%/g,G.name??""))}static _AddLogEntry(Z){u._LogCache=Z+u._LogCache,u.OnNewCacheEntry&&u.OnNewCacheEntry(Z)}static _FormatMessage(Z){const x=Z=>Z<10?"0"+Z:""+Z,F=new Date;return"["+x(F.getHours())+":"+x(F.getMinutes())+":"+x(F.getSeconds())+"]: "+Z}static _LogDisabled(Z,x){}static _LogEnabled(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,x=arguments.length>1?arguments[1]:void 0,F=arguments.length>2?arguments[2]:void 0;const G=Array.isArray(x)?x[0]:x;if(void 0!==F&&!u._CheckLimit(G,F))return;const f=u._FormatMessage(G),Y=this._Levels[Z],j=Array.isArray(x)?x.slice(1):[];Y.logFunc&&Y.logFunc("BJS - "+f,...j);const d=`<div style='color:${Y.color}'>${f}</div><br>`;u._AddLogEntry(d),u._GenerateLimitMessage(G,Z)}static get LogCache(){return u._LogCache}static ClearLogCache(){u._LogCache="",u._LogLimitOutputs={},u.errorsCount=0}static set LogLevels(Z){u.Log=u._LogDisabled,u.Warn=u._LogDisabled,u.Error=u._LogDisabled;const x=[u.MessageLogLevel,u.WarningLogLevel,u.ErrorLogLevel];for(const F of x)if((Z&F)===F){const Z=this._Levels[F];u[Z.name]=u._LogEnabled.bind(u,F)}}}u.NoneLogLevel=0,u.MessageLogLevel=1,u.WarningLogLevel=2,u.ErrorLogLevel=4,u.AllLogLevel=7,u.MessageLimitReached="Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.",u._LogCache="",u._LogLimitOutputs={},u._Levels=[{},{color:"white",logFunc:console.log,name:"Log"},{color:"orange",logFunc:console.warn,name:"Warn"},{},{color:"red",logFunc:console.error,name:"Error"}],u.errorsCount=0,u.Log=u._LogEnabled.bind(u,u.MessageLogLevel),u.Warn=u._LogEnabled.bind(u,u.WarningLogLevel),u.Error=u._LogEnabled.bind(u,u.ErrorLogLevel)},11e3:(Z,x,F)=>{F.d(x,{b:()=>Y});const u="undefined"!==typeof WeakRef;class G{constructor(Z){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],F=arguments.length>2?arguments[2]:void 0,u=arguments.length>3?arguments[3]:void 0;this.initialize(Z,x,F,u)}initialize(Z){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],F=arguments.length>2?arguments[2]:void 0,u=arguments.length>3?arguments[3]:void 0;return this.mask=Z,this.skipNextObservers=x,this.target=F,this.currentTarget=u,this}}class f{constructor(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this.callback=Z,this.mask=x,this.scope=F,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this._remove&&this._remove(Z)}}class Y{static FromPromise(Z,x){const F=new Y;return Z.then((Z=>{F.notifyObservers(Z)})).catch((Z=>{if(!x)throw Z;x.notifyObservers(Z)})),F}get observers(){return this._observers}constructor(Z){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.notifyIfTriggered=x,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new G(0),Z&&(this._onObserverAdded=Z)}add(Z){let x=arguments.length>2&&void 0!==arguments[2]&&arguments[2],F=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Z)return null;const G=new f(Z,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null);G.unregisterOnNextCall=F,x?this._observers.unshift(G):this._observers.push(G),this._onObserverAdded&&this._onObserverAdded(G),this._hasNotified&&this.notifyIfTriggered&&void 0!==this._lastNotifiedValue&&this.notifyObserver(G,this._lastNotifiedValue);const Y=u?new WeakRef(this):{deref:()=>this};return G._remove=function(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=Y.deref();x&&(Z?x.remove(G):x._remove(G))},G}addOnce(Z){return this.add(Z,void 0,void 0,void 0,!0)}remove(Z){if(!Z)return!1;Z._remove=null;return-1!==this._observers.indexOf(Z)&&(this._deferUnregister(Z),!0)}removeCallback(Z,x){for(let F=0;F<this._observers.length;F++){const u=this._observers[F];if(!u._willBeUnregistered&&(u.callback===Z&&(!x||x===u.scope)))return this._deferUnregister(u),!0}return!1}_deferUnregister(Z){Z._willBeUnregistered||(this._numObserversMarkedAsDeleted++,Z.unregisterOnNextCall=!1,Z._willBeUnregistered=!0,setTimeout((()=>{this._remove(Z)}),0))}_remove(Z){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!Z)return!1;const F=this._observers.indexOf(Z);return-1!==F&&(x&&this._numObserversMarkedAsDeleted--,this._observers.splice(F,1),!0)}makeObserverTopPriority(Z){this._remove(Z,!1),this._observers.unshift(Z)}makeObserverBottomPriority(Z){this._remove(Z,!1),this._observers.push(Z)}notifyObservers(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,F=arguments.length>2?arguments[2]:void 0,u=arguments.length>3?arguments[3]:void 0,G=arguments.length>4?arguments[4]:void 0;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=Z),!this._observers.length)return!0;const f=this._eventState;f.mask=x,f.target=F,f.currentTarget=u,f.skipNextObservers=!1,f.lastReturnValue=Z,f.userInfo=G;for(const Y of this._observers)if(!Y._willBeUnregistered&&(Y.mask&x&&(Y.unregisterOnNextCall&&this._deferUnregister(Y),Y.scope?f.lastReturnValue=Y.callback.apply(Y.scope,[Z,f]):f.lastReturnValue=Y.callback(Z,f)),f.skipNextObservers))return!1;return!0}notifyObserver(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=x),Z._willBeUnregistered)return;const u=this._eventState;u.mask=F,u.skipNextObservers=!1,Z.unregisterOnNextCall&&this._deferUnregister(Z),Z.callback(x,u)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const Z=this._observers.pop();Z&&(Z._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const Z=new Y;return Z._observers=this._observers.slice(0),Z}hasSpecificMask(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;for(const x of this._observers)if(x.mask&Z||x.mask===Z)return!0;return!1}}},11072:(Z,x,F)=>{F.d(x,{d:()=>G,h:()=>Y});let u=[];class G{static SetImmediate(Z){0===u.length&&setTimeout((()=>{const Z=u;u=[];for(const x of Z)x()}),1),u.push(Z)}}function f(Z,x,F){try{if(Z())return x(),!0}catch(u){return null===F||void 0===F||F(u),!0}return!1}const Y=function(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:16,G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:3e4,Y=arguments.length>6?arguments[6]:void 0;if((!(arguments.length>5&&void 0!==arguments[5])||arguments[5])&&f(Z,x,F))return null;const j=setInterval((()=>{f(Z,x,F)?clearInterval(j):(G-=u,G<0&&(clearInterval(j),null===F||void 0===F||F(new Error("Operation timed out after maximum retries. "+(Y||"")),!0)))}),u);return()=>clearInterval(j)}}}]);