"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[9],{11074:(B,I,C)=>{C.d(I,{e:()=>A,i:()=>t,n:()=>r,m:()=>O,r:()=>a});class M{constructor(){this.children=[]}isValid(B){return!0}process(B,I,C){let M="";if(this.line){let C=this.line;const N=I.processor;if(N){var x,y,f,L,e,g;N.lineProcessor&&(C=N.lineProcessor(C,I.isFragment,I.processingContext));const M=(null===(x=I.processor)||void 0===x?void 0:x.attributeKeywordName)??"attribute",R=I.isFragment&&null!==(y=I.processor)&&void 0!==y&&y.varyingFragmentKeywordName?null===(f=I.processor)||void 0===f?void 0:f.varyingFragmentKeywordName:!I.isFragment&&null!==(L=I.processor)&&void 0!==L&&L.varyingVertexKeywordName?null===(e=I.processor)||void 0===e?void 0:e.varyingVertexKeywordName:"varying";if(!I.isFragment&&N.attributeProcessor&&this.line.startsWith(M))C=N.attributeProcessor(this.line,B,I.processingContext);else if(N.varyingProcessor&&(null!==(g=N.varyingCheck)&&void 0!==g&&g.call(N,this.line,I.isFragment)||!N.varyingCheck&&this.line.startsWith(R)))C=N.varyingProcessor(this.line,I.isFragment,B,I.processingContext);else if(N.uniformProcessor&&N.uniformRegexp&&N.uniformRegexp.test(this.line))I.lookForClosingBracketForUniformBuffer||(C=N.uniformProcessor(this.line,I.isFragment,B,I.processingContext));else if(N.uniformBufferProcessor&&N.uniformBufferRegexp&&N.uniformBufferRegexp.test(this.line))I.lookForClosingBracketForUniformBuffer||(C=N.uniformBufferProcessor(this.line,I.isFragment,I.processingContext),I.lookForClosingBracketForUniformBuffer=!0);else if(N.textureProcessor&&N.textureRegexp&&N.textureRegexp.test(this.line))C=N.textureProcessor(this.line,I.isFragment,B,I.processingContext);else if((N.uniformProcessor||N.uniformBufferProcessor)&&this.line.startsWith("uniform")&&!I.lookForClosingBracketForUniformBuffer){/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line)?N.uniformProcessor&&(C=N.uniformProcessor(this.line,I.isFragment,B,I.processingContext)):N.uniformBufferProcessor&&(C=N.uniformBufferProcessor(this.line,I.isFragment,I.processingContext),I.lookForClosingBracketForUniformBuffer=!0)}I.lookForClosingBracketForUniformBuffer&&-1!==this.line.indexOf("}")&&(I.lookForClosingBracketForUniformBuffer=!1,N.endOfUniformBufferProcessor&&(C=N.endOfUniformBufferProcessor(this.line,I.isFragment,I.processingContext)))}M+=C+"\n"}for(const N of this.children)M+=N.process(B,I,C);return this.additionalDefineKey&&(B[this.additionalDefineKey]=this.additionalDefineValue||"true",C[this.additionalDefineKey]=B[this.additionalDefineKey]),M}}class x{constructor(){this._lines=[]}get currentLine(){return this._lines[this.lineIndex]}get canRead(){return this.lineIndex<this._lines.length-1}set lines(B){this._lines.length=0;for(const I of B){if(!I||"\r"===I)continue;if("#"===I[0]){this._lines.push(I);continue}const B=I.trim();if(!B)continue;if(B.startsWith("//")){this._lines.push(I);continue}const C=B.indexOf(";");if(-1===C)this._lines.push(B);else if(C===B.length-1)B.length>1&&this._lines.push(B);else{const B=I.split(";");for(let I=0;I<B.length;I++){let C=B[I];C&&(C=C.trim(),C&&this._lines.push(C+(I!==B.length-1?";":"")))}}}}}class y extends M{process(B,I,C){for(let M=0;M<this.children.length;M++){const x=this.children[M];if(x.isValid(B))return x.process(B,I,C)}return""}}class f extends M{isValid(B){return this.testExpression.isTrue(B)}}class L{isTrue(B){return!0}static postfixToInfix(B){const I=[];for(const C of B)if(void 0===L._OperatorPriority[C])I.push(C);else{const B=I[I.length-1],M=I[I.length-2];I.length-=2,I.push(`(${M}${C}${B})`)}return I[I.length-1]}static infixToPostfix(B){const I=L._InfixToPostfixCache.get(B);if(I)return I.accessTime=Date.now(),I.result;if(!B.includes("&&")&&!B.includes("||")&&!B.includes(")")&&!B.includes("("))return[B];const C=[];let M=-1;const x=()=>{N=N.trim(),""!==N&&(C.push(N),N="")},y=B=>{M<L._Stack.length-1&&(L._Stack[++M]=B)},f=()=>L._Stack[M],e=()=>-1===M?"!!INVALID EXPRESSION!!":L._Stack[M--];let g=0,N="";for(;g<B.length;){const I=B.charAt(g),R=g<B.length-1?B.substring(g,2+g):"";if("("===I)N="",y(I);else if(")"===I){for(x();-1!==M&&"("!==f();)C.push(e());e()}else if(L._OperatorPriority[R]>1){for(x();-1!==M&&L._OperatorPriority[f()]>=L._OperatorPriority[R];)C.push(e());y(R),g++}else N+=I;g++}for(x();-1!==M;)"("===f()?e():C.push(e());return L._InfixToPostfixCache.size>=L.InfixToPostfixCacheLimitSize&&L.ClearCache(),L._InfixToPostfixCache.set(B,{result:C,accessTime:Date.now()}),C}static ClearCache(){const B=Array.from(L._InfixToPostfixCache.entries()).sort(((B,I)=>B[1].accessTime-I[1].accessTime));for(let I=0;I<L.InfixToPostfixCacheCleanupSize;I++)L._InfixToPostfixCache.delete(B[I][0])}}L.InfixToPostfixCacheLimitSize=5e4,L.InfixToPostfixCacheCleanupSize=25e3,L._InfixToPostfixCache=new Map,L._OperatorPriority={")":0,"(":1,"||":2,"&&":3},L._Stack=["","","","","","","","","","","","","","","","","","","",""];class e extends L{constructor(B){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super(),this.define=B,this.not=I}isTrue(B){let I=void 0!==B[this.define];return this.not&&(I=!I),I}}class g extends L{isTrue(B){return this.leftOperand.isTrue(B)||this.rightOperand.isTrue(B)}}class N extends L{isTrue(B){return this.leftOperand.isTrue(B)&&this.rightOperand.isTrue(B)}}class R extends L{constructor(B,I,C){super(),this.define=B,this.operand=I,this.testValue=C}toString(){return`${this.define} ${this.operand} ${this.testValue}`}isTrue(B){let I=!1;const C=parseInt(void 0!=B[this.define]?B[this.define]:this.define),M=parseInt(void 0!=B[this.testValue]?B[this.testValue]:this.testValue);if(isNaN(C)||isNaN(M))return!1;switch(this.operand){case">":I=C>M;break;case"<":I=C<M;break;case"<=":I=C<=M;break;case">=":I=C>=M;break;case"==":I=C===M;break;case"!=":I=C!==M}return I}}var H=C(11042),F=C(11083);const k=/defined\s*?\((.+?)\)/g,q=/defined\s*?\[(.+?)\]/g,S=/#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,o=/__decl__/,U=/light\{X\}.(\w*)/g,G=/\{X\}/g,V=[],c=/(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;function t(B){B.processor&&B.processor.initializeShaders&&B.processor.initializeShaders(B.processingContext)}function r(B,I,C,M){var x;null!==(x=I.processor)&&void 0!==x&&x.preProcessShaderCode&&(B=I.processor.preProcessShaderCode(B,I.isFragment)),O(B,I,(B=>{I.processCodeAfterIncludes&&(B=I.processCodeAfterIncludes(I.isFragment?"fragment":"vertex",B,I.defines));const x=function(B,I,C){let M=function(B,I){var C;if(null!==(C=I.processor)&&void 0!==C&&C.noPrecision)return B;const M=I.shouldUseHighPrecisionShader;-1===B.indexOf("precision highp float")?B=M?"precision highp float;\n"+B:"precision mediump float;\n"+B:M||(B=B.replace("precision highp float","precision mediump float"));return B}(B,I);if(!I.processor)return M;if(0===I.processor.shaderLanguage&&-1!==M.indexOf("#version 3")&&(M=M.replace("#version 300 es",""),!I.processor.parseGLES3))return M;const x=I.defines,y=n(I,C);I.processor.preProcessor&&(M=I.processor.preProcessor(M,x,y,I.isFragment,I.processingContext));const f={};M=p(M,y,I,f),I.processor.postProcessor&&(M=I.processor.postProcessor(M,x,I.isFragment,I.processingContext,C?{drawBuffersExtensionDisabled:!C.getCaps().drawBuffersExtension}:{},y,f));null!==C&&void 0!==C&&C._features.needShaderCodeInlining&&(M=C.inlineShaderCode(M));return M}(B,I,M);C(x,B)}))}function A(B,I,C){return C.processor&&C.processor.finalizeShaders?C.processor.finalizeShaders(B,I,C.processingContext):{vertexCode:B,fragmentCode:I}}function D(B){const I=/defined\((.+)\)/.exec(B);if(I&&I.length)return new e(I[1].trim(),"!"===B[0]);const C=["==","!=",">=","<=","<",">"];let M="",x=0;for(M of C)if(x=B.indexOf(M),x>-1)break;if(-1===x)return new e(B);const y=B.substring(0,x).trim(),f=B.substring(x+M.length).trim();return new R(y,M,f)}function J(B,I){const C=new f,M=B.substring(0,I);let x=B.substring(I);return x=x.substring(0,(x.indexOf("//")+1||x.length+1)-1).trim(),C.testExpression="#ifdef"===M?new e(x):"#ifndef"===M?new e(x,!0):function(B){B=B.replace(k,"defined[$1]");const I=L.infixToPostfix(B),C=[];for(const x of I)if("||"!==x&&"&&"!==x)C.push(x);else if(C.length>=2){let B=C[C.length-1],I=C[C.length-2];C.length-=2;const M="&&"==x?new N:new g;"string"===typeof B&&(B=B.replace(q,"defined($1)")),"string"===typeof I&&(I=I.replace(q,"defined($1)")),M.leftOperand="string"===typeof I?D(I):I,M.rightOperand="string"===typeof B?D(B):B,C.push(M)}let M=C[C.length-1];return"string"===typeof M&&(M=M.replace(q,"defined($1)")),"string"===typeof M?D(M):M}(x),C}function i(B,I,C,x){let y=B.currentLine;for(;u(B,C,x);){y=B.currentLine;const f=y.substring(0,5).toLowerCase();if("#else"===f){const C=new M;return I.children.push(C),void u(B,C,x)}if("#elif"===f){const B=J(y,5);I.children.push(B),C=B}}}function u(B,I,C){for(;B.canRead;){B.lineIndex++;const x=B.currentLine;if(x.indexOf("#")>=0){const M=c.exec(x);if(M&&M.length){switch(M[0]){case"#ifdef":{const M=new y;I.children.push(M);const f=J(x,6);M.children.push(f),i(B,M,f,C);break}case"#else":case"#elif":return!0;case"#endif":return!1;case"#ifndef":{const M=new y;I.children.push(M);const f=J(x,7);M.children.push(f),i(B,M,f,C);break}case"#if":{const M=new y,f=J(x,3);I.children.push(M),M.children.push(f),i(B,M,f,C);break}}continue}}const f=new M;if(f.line=x,I.children.push(f),"#"===x[0]&&"d"===x[1]){const B=x.replace(";","").split(" ");f.additionalDefineKey=B[1],3===B.length&&(f.additionalDefineValue=B[2])}}return!1}function p(B,I,C,y){const f=new M,L=new x;return L.lineIndex=-1,L.lines=B.split("\n"),u(L,f,y),f.process(I,C,y)}function n(B,I){var C;const M=B.defines,x={};for(const y of M){const B=y.replace("#define","").replace(";","").trim().split(" ");x[B[0]]=B.length>1?B[1]:""}return 0===(null===(C=B.processor)||void 0===C?void 0:C.shaderLanguage)&&(x.GL_ES="true"),x.__VERSION__=B.version,x[B.platformName]="true",(0,F.l)(x,null===I||void 0===I?void 0:I.isNDCHalfZRange,null===I||void 0===I?void 0:I.useReverseDepthBuffer,null===I||void 0===I?void 0:I.useExactSrgbConversions),x}function O(B,I,C){let M;for(V.length=0;null!==(M=S.exec(B));)V.push(M);let x=String(B),y=[B],f=!1;for(const L of V){let B=L[1];if(-1!==B.indexOf("__decl__")&&(B=B.replace(o,""),I.supportsUniformBuffers&&(B=B.replace("Vertex","Ubo").replace("Fragment","Ubo")),B+="Declaration"),!I.includesShadersStore[B]){const M=I.shadersRepository+"ShadersInclude/"+B+".fx";return void a.loadFile(M,(M=>{I.includesShadersStore[B]=M,O(y.join(""),I,C)}))}{let C=I.includesShadersStore[B];if(L[2]){const B=L[3].split(",");for(let I=0;I<B.length;I+=2){const M=new RegExp(B[I],"g"),x=B[I+1];C=C.replace(M,x)}}if(L[4]){const B=L[5];if(-1!==B.indexOf("..")){const M=B.split(".."),x=parseInt(M[0]);let y=parseInt(M[1]),f=C.slice(0);C="",isNaN(y)&&(y=I.indexParameters[M[1]]);for(let B=x;B<y;B++)I.supportsUniformBuffers||(f=f.replace(U,((B,I)=>I+"{X}"))),C+=f.replace(G,B.toString())+"\n"}else I.supportsUniformBuffers||(C=C.replace(U,((B,I)=>I+"{X}"))),C=C.replace(G,B)}const M=[];for(const B of y){const I=B.split(L[0]);for(let B=0;B<I.length-1;B++)M.push(I[B]),M.push(C);M.push(I[I.length-1])}y=M,f=f||C.indexOf("#include<")>=0||C.indexOf("#include <")>=0}}V.length=0,x=y.join(""),f?O(x.toString(),I,C):C(x)}const a={loadFile:(B,I,C,M,x,y)=>{throw(0,H.c)("FileTools")}}},11083:(B,I,C)=>{C.d(I,{e:()=>x,h:()=>y,l:()=>L,m:()=>f,q:()=>e});var M=C(11042);C(11024);const x={};function y(B,I){return(arguments.length>2&&void 0!==arguments[2]?arguments[2]:"")+(I?I+"\n":"")+B}function f(B,I,C,y,f,L,e){const g=e||x.loadFile;if(g){return g(B,I,C,y,f,L)}throw(0,M.c)("FileTools")}function L(B,I,C,M){if(B)return I?B.IS_NDC_HALF_ZRANGE="":delete B.IS_NDC_HALF_ZRANGE,C?B.USE_REVERSE_DEPTHBUFFER="":delete B.USE_REVERSE_DEPTHBUFFER,void(M?B.USE_EXACT_SRGB_CONVERSIONS="":delete B.USE_EXACT_SRGB_CONVERSIONS);{let B="";return I&&(B+="#define IS_NDC_HALF_ZRANGE"),C&&(B&&(B+="\n"),B+="#define USE_REVERSE_DEPTHBUFFER"),M&&(B&&(B+="\n"),B+="#define USE_EXACT_SRGB_CONVERSIONS"),B}}function e(B,I){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],M=arguments.length>3?arguments[3]:void 0;switch(B){case 3:{const B=(ArrayBuffer,new Int8Array(I));return M&&B.set(new Int8Array(M)),B}case 0:{const B=(ArrayBuffer,new Uint8Array(I));return M&&B.set(new Uint8Array(M)),B}case 4:{const B=I instanceof ArrayBuffer?new Int16Array(I):new Int16Array(C?I/2:I);return M&&B.set(new Int16Array(M)),B}case 5:case 8:case 9:case 10:case 2:{const B=I instanceof ArrayBuffer?new Uint16Array(I):new Uint16Array(C?I/2:I);return M&&B.set(new Uint16Array(M)),B}case 6:{const B=I instanceof ArrayBuffer?new Int32Array(I):new Int32Array(C?I/4:I);return M&&B.set(new Int32Array(M)),B}case 7:case 11:case 12:case 13:case 14:case 15:{const B=I instanceof ArrayBuffer?new Uint32Array(I):new Uint32Array(C?I/4:I);return M&&B.set(new Uint32Array(M)),B}case 1:{const B=I instanceof ArrayBuffer?new Float32Array(I):new Float32Array(C?I/4:I);return M&&B.set(new Float32Array(M)),B}}const x=(ArrayBuffer,new Uint8Array(I));return M&&x.set(new Uint8Array(M)),x}},11110:(B,I,C)=>{C.d(I,{d:()=>M});class M{static GetShadersRepository(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?M.ShadersRepository:M.ShadersRepositoryWGSL}static GetShadersStore(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?M.ShadersStore:M.ShadersStoreWGSL}static GetIncludesShadersStore(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?M.IncludesShadersStore:M.IncludesShadersStoreWGSL}}M.ShadersRepository="src/Shaders/",M.ShadersStore={},M.IncludesShadersStore={},M.ShadersRepositoryWGSL="src/ShadersWGSL/",M.ShadersStoreWGSL={},M.IncludesShadersStoreWGSL={}},11117:(B,I,C)=>{C.d(I,{c:()=>H,g:()=>G,j:()=>k,l:()=>F,p:()=>q,r:()=>U,t:()=>R,x:()=>g,B:()=>N,E:()=>e,H:()=>L});class M{constructor(){this._valueCache={},this.vertexCompilationError=null,this.fragmentCompilationError=null,this.programLinkError=null,this.programValidationError=null,this._isDisposed=!1}get isAsync(){return this.isParallelCompiled}get isReady(){return!!this.program&&(!this.isParallelCompiled||this.RI._isRenderingStateCompiled(this))}_handlesSpectorRebuildCallback(B){B&&this.program&&B(this.program)}setEngine(B){this.RI=B}_fillEffectInformation(B,I,C,M,x,y,f,L){const e=this.RI;if(e.supportsUniformBuffers)for(const N in I)B.bindUniformBlock(N,I[N]);let g;for(this.RI.getUniforms(this,C).forEach(((B,I)=>{M[C[I]]=B})),this._uniforms=M,g=0;g<x.length;g++){null==B.getUniform(x[g])&&(x.splice(g,1),g--)}x.forEach(((B,I)=>{y[B]=I}));for(const N of e.getAttributes(this,f))L.push(N)}dispose(){this._uniforms={},this._isDisposed=!0}_cacheMatrix(B,I){const C=this._valueCache[B],M=I.updateFlag;return(void 0===C||C!==M)&&(this._valueCache[B]=M,!0)}_cacheFloat2(B,I,C){let M=this._valueCache[B];if(!M||2!==M.length)return M=[I,C],this._valueCache[B]=M,!0;let x=!1;return M[0]!==I&&(M[0]=I,x=!0),M[1]!==C&&(M[1]=C,x=!0),x}_cacheFloat3(B,I,C,M){let x=this._valueCache[B];if(!x||3!==x.length)return x=[I,C,M],this._valueCache[B]=x,!0;let y=!1;return x[0]!==I&&(x[0]=I,y=!0),x[1]!==C&&(x[1]=C,y=!0),x[2]!==M&&(x[2]=M,y=!0),y}_cacheFloat4(B,I,C,M,x){let y=this._valueCache[B];if(!y||4!==y.length)return y=[I,C,M,x],this._valueCache[B]=y,!0;let f=!1;return y[0]!==I&&(y[0]=I,f=!0),y[1]!==C&&(y[1]=C,f=!0),y[2]!==M&&(y[2]=M,f=!0),y[3]!==x&&(y[3]=x,f=!0),f}setInt(B,I){const C=this._valueCache[B];void 0!==C&&C===I||this.RI.setInt(this._uniforms[B],I)&&(this._valueCache[B]=I)}setInt2(B,I,C){this._cacheFloat2(B,I,C)&&(this.RI.setInt2(this._uniforms[B],I,C)||(this._valueCache[B]=null))}setInt3(B,I,C,M){this._cacheFloat3(B,I,C,M)&&(this.RI.setInt3(this._uniforms[B],I,C,M)||(this._valueCache[B]=null))}setInt4(B,I,C,M,x){this._cacheFloat4(B,I,C,M,x)&&(this.RI.setInt4(this._uniforms[B],I,C,M,x)||(this._valueCache[B]=null))}setIntArray(B,I){this._valueCache[B]=null,this.RI.setIntArray(this._uniforms[B],I)}setIntArray2(B,I){this._valueCache[B]=null,this.RI.setIntArray2(this._uniforms[B],I)}setIntArray3(B,I){this._valueCache[B]=null,this.RI.setIntArray3(this._uniforms[B],I)}setIntArray4(B,I){this._valueCache[B]=null,this.RI.setIntArray4(this._uniforms[B],I)}setUInt(B,I){const C=this._valueCache[B];void 0!==C&&C===I||this.RI.setUInt(this._uniforms[B],I)&&(this._valueCache[B]=I)}setUInt2(B,I,C){this._cacheFloat2(B,I,C)&&(this.RI.setUInt2(this._uniforms[B],I,C)||(this._valueCache[B]=null))}setUInt3(B,I,C,M){this._cacheFloat3(B,I,C,M)&&(this.RI.setUInt3(this._uniforms[B],I,C,M)||(this._valueCache[B]=null))}setUInt4(B,I,C,M,x){this._cacheFloat4(B,I,C,M,x)&&(this.RI.setUInt4(this._uniforms[B],I,C,M,x)||(this._valueCache[B]=null))}setUIntArray(B,I){this._valueCache[B]=null,this.RI.setUIntArray(this._uniforms[B],I)}setUIntArray2(B,I){this._valueCache[B]=null,this.RI.setUIntArray2(this._uniforms[B],I)}setUIntArray3(B,I){this._valueCache[B]=null,this.RI.setUIntArray3(this._uniforms[B],I)}setUIntArray4(B,I){this._valueCache[B]=null,this.RI.setUIntArray4(this._uniforms[B],I)}setArray(B,I){this._valueCache[B]=null,this.RI.setArray(this._uniforms[B],I)}setArray2(B,I){this._valueCache[B]=null,this.RI.setArray2(this._uniforms[B],I)}setArray3(B,I){this._valueCache[B]=null,this.RI.setArray3(this._uniforms[B],I)}setArray4(B,I){this._valueCache[B]=null,this.RI.setArray4(this._uniforms[B],I)}setMatrices(B,I){I&&(this._valueCache[B]=null,this.RI.setMatrices(this._uniforms[B],I))}setMatrix(B,I){this._cacheMatrix(B,I)&&(this.RI.setMatrices(this._uniforms[B],I.Df())||(this._valueCache[B]=null))}setMatrix3x3(B,I){this._valueCache[B]=null,this.RI.setMatrix3x3(this._uniforms[B],I)}setMatrix2x2(B,I){this._valueCache[B]=null,this.RI.setMatrix2x2(this._uniforms[B],I)}setFloat(B,I){const C=this._valueCache[B];void 0!==C&&C===I||this.RI.setFloat(this._uniforms[B],I)&&(this._valueCache[B]=I)}setVector2(B,I){this._cacheFloat2(B,I.x,I.y)&&(this.RI.setFloat2(this._uniforms[B],I.x,I.y)||(this._valueCache[B]=null))}setFloat2(B,I,C){this._cacheFloat2(B,I,C)&&(this.RI.setFloat2(this._uniforms[B],I,C)||(this._valueCache[B]=null))}setVector3(B,I){this._cacheFloat3(B,I.x,I.y,I.z)&&(this.RI.setFloat3(this._uniforms[B],I.x,I.y,I.z)||(this._valueCache[B]=null))}setFloat3(B,I,C,M){this._cacheFloat3(B,I,C,M)&&(this.RI.setFloat3(this._uniforms[B],I,C,M)||(this._valueCache[B]=null))}setVector4(B,I){this._cacheFloat4(B,I.x,I.y,I.z,I.w)&&(this.RI.setFloat4(this._uniforms[B],I.x,I.y,I.z,I.w)||(this._valueCache[B]=null))}setQuaternion(B,I){this._cacheFloat4(B,I.x,I.y,I.z,I.w)&&(this.RI.setFloat4(this._uniforms[B],I.x,I.y,I.z,I.w)||(this._valueCache[B]=null))}setFloat4(B,I,C,M,x){this._cacheFloat4(B,I,C,M,x)&&(this.RI.setFloat4(this._uniforms[B],I,C,M,x)||(this._valueCache[B]=null))}setColor3(B,I){this._cacheFloat3(B,I.r,I.g,I.b)&&(this.RI.setFloat3(this._uniforms[B],I.r,I.g,I.b)||(this._valueCache[B]=null))}setColor4(B,I,C){this._cacheFloat4(B,I.r,I.g,I.b,C)&&(this.RI.setFloat4(this._uniforms[B],I.r,I.g,I.b,C)||(this._valueCache[B]=null))}setDirectColor4(B,I){this._cacheFloat4(B,I.r,I.g,I.b,I.a)&&(this.RI.setFloat4(this._uniforms[B],I.r,I.g,I.b,I.a)||(this._valueCache[B]=null))}_getVertexShaderCode(){return this.vertexShader?this.RI._getShaderSource(this.vertexShader):null}_getFragmentShaderCode(){return this.fragmentShader?this.RI._getShaderSource(this.fragmentShader):null}}var x=C(11083);const y=new WeakMap,f={_webGLVersion:2,cachedPipelines:{}};function L(B){let I=y.get(B);if(!I){if(!B)return f;I={_webGLVersion:B.TEXTURE_BINDING_3D?2:1,_context:B,parallelShaderCompile:B.getExtension("KHR_parallel_shader_compile")||void 0,cachedPipelines:{}},y.set(B,I)}return I}function e(B){y.delete(B)}function g(B,I,C,M,x,y){const f=L(M);y||(y=f._createShaderProgramInjection??H);return y(B,o(I,"vertex",M,f._contextWasLost),o(C,"fragment",M,f._contextWasLost),M,x,f.validateShaderPrograms)}function N(B,I,C,M,x){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,f=arguments.length>6?arguments[6]:void 0;const e=L(x);f||(f=e._createShaderProgramInjection??H);const g=e._webGLVersion>1?"#version 300 es\n#define WEBGL2 \n":"";return f(B,S(I,"vertex",M,g,x,e._contextWasLost),S(C,"fragment",M,g,x,e._contextWasLost),x,y,e.validateShaderPrograms)}function R(B,I){const C=new M,x=L(B);return x.parallelShaderCompile&&!x.disableParallelShaderCompile&&(C.isParallelCompiled=!0),C.context=x._context,C}function H(B,I,C,M){let x=arguments.length>5?arguments[5]:void 0;const y=M.createProgram();if(B.program=y,!y)throw new Error("Unable to create program");return M.attachShader(y,I),M.attachShader(y,C),M.linkProgram(y),B.context=M,B.vertexShader=I,B.fragmentShader=C,B.isParallelCompiled||k(B,M,x),y}function F(B,I,C){const M=B;if(M._isDisposed)return!1;const x=L(I);return!!(x&&x.parallelShaderCompile&&x.parallelShaderCompile.COMPLETION_STATUS_KHR&&M.program&&I.getProgramParameter(M.program,x.parallelShaderCompile.COMPLETION_STATUS_KHR))&&(k(M,I,C),!0)}function k(B,I,C){const M=B.context,x=B.vertexShader,y=B.fragmentShader,f=B.program;if(!M.getProgramParameter(f,M.LINK_STATUS)){if(!I.getShaderParameter(x,I.COMPILE_STATUS)){const C=I.getShaderInfoLog(x);if(C)throw B.vertexCompilationError=C,new Error("VERTEX SHADER "+C)}if(!I.getShaderParameter(y,I.COMPILE_STATUS)){const C=I.getShaderInfoLog(y);if(C)throw B.fragmentCompilationError=C,new Error("FRAGMENT SHADER "+C)}const C=M.getProgramInfoLog(f);if(C)throw B.programLinkError=C,new Error(C)}if(C){M.validateProgram(f);if(!M.getProgramParameter(f,M.VALIDATE_STATUS)){const I=M.getProgramInfoLog(f);if(I)throw B.programValidationError=I,new Error(I)}}M.deleteShader(x),M.deleteShader(y),B.vertexShader=void 0,B.fragmentShader=void 0,B.onCompiled&&(B.onCompiled(),B.onCompiled=void 0)}function q(B,I,C,M,x,y,f,e,R){let H=arguments.length>10?arguments[10]:void 0,F=arguments.length>11?arguments[11]:void 0,k=arguments.length>12?arguments[12]:void 0;const q=L(B.context);F||(F=q.createRawShaderProgramInjection??g),k||(k=q.createShaderProgramInjection??N);const S=B;S.program=M?F(S,I,C,S.context,R):k(S,I,C,e,S.context,R),S.program.__SPECTOR_rebuildProgram=f,H()}function S(B,I,C,M,y,f){return o((0,x.h)(B,C,M),I,y,f)}function o(B,I,C,M){const x=C.createShader("vertex"===I?C.VERTEX_SHADER:C.FRAGMENT_SHADER);if(!x){let B=C.NO_ERROR,x=C.NO_ERROR;for(;(x=C.getError())!==C.NO_ERROR;)B=x;throw new Error(`Something went wrong while creating a gl ${I} shader object. gl error=${B}, gl isContextLost=${C.isContextLost()}, _contextWasLost=${M}`)}return C.shaderSource(x,B),C.compileShader(x),x}function U(B,I){I.useProgram(B)}function G(B,I){const C=B;if(!C.isParallelCompiled)return void I(B);const M=C.onCompiled;C.onCompiled=()=>{null===M||void 0===M||M(),I(B)}}},11113:(B,I,C)=>{C.d(I,{d:()=>R,f:()=>F,j:()=>g,k:()=>N});var M=C(11024),x=C(11117),y=C(11110),f=C(11027),L=C(11074),e=C(11083);function g(B,I){return(0,x.H)(I).cachedPipelines[B]}function N(B){const I=B._name,C=B.context;if(I&&C){const B=(0,x.H)(C),M=B.cachedPipelines[I];null===M||void 0===M||M.dispose(),delete B.cachedPipelines[I]}}function R(B,I,C,x,y,f,e){let g,N;const R=(0,M.k)()?null===f||void 0===f?void 0:f.getHostDocument():null;g="string"===typeof I?I:I.vertexSource?"source:"+I.vertexSource:I.vertexElement?(null===R||void 0===R?void 0:R.getElementById(I.vertexElement))||I.vertexElement:I.vertex||I,N="string"===typeof I?I:I.fragmentSource?"source:"+I.fragmentSource:I.fragmentElement?(null===R||void 0===R?void 0:R.getElementById(I.fragmentElement))||I.fragmentElement:I.fragment||I;const F=[void 0,void 0],k=()=>{if(F[0]&&F[1]){B.isFragment=!0;const[M,g]=F;(0,L.n)(g,B,((f,g)=>{e&&(e._fragmentSourceCodeBeforeMigration=g),C&&(f=C("fragment",f));const N=(0,L.e)(M,f,B);B=null;const R=function(B,I,C,M){if(C){return{vertexSourceCode:(1===M?"//":"")+"#define SHADER_NAME vertex:"+(C.vertexElement||C.vertex||C.spectorName||C)+"\n"+B,fragmentSourceCode:(1===M?"//":"")+"#define SHADER_NAME fragment:"+(C.fragmentElement||C.fragment||C.spectorName||C)+"\n"+I}}return{vertexSourceCode:B,fragmentSourceCode:I}}(N.vertexCode,N.fragmentCode,I,y);null===x||void 0===x||x(R.vertexSourceCode,R.fragmentSourceCode)}),f)}};H(g,"Vertex","",(I=>{(0,L.i)(B),(0,L.n)(I,B,((B,M)=>{e&&(e._rawVertexSourceCode=I,e._vertexSourceCodeBeforeMigration=M),C&&(B=C("vertex",B)),F[0]=B,k()}),f)}),y),H(N,"Fragment","Pixel",(B=>{e&&(e._rawFragmentSourceCode=B),F[1]=B,k()}),y)}function H(B,I,C,x,f,L){if("undefined"!==typeof HTMLElement&&B instanceof HTMLElement){return void x((0,M.d)(B))}if("source:"===B.substring(0,7))return void x(B.substring(7));if("base64:"===B.substring(0,7)){return void x(window.atob(B.substring(7)))}const g=y.d.GetShadersStore(f);if(g[B+I+"Shader"])return void x(g[B+I+"Shader"]);if(C&&g[B+C+"Shader"])return void x(g[B+C+"Shader"]);let N;if(N="."===B[0]||"/"===B[0]||B.indexOf("http")>-1?B:y.d.GetShadersRepository(f)+B,!(L=L||e.m))throw new Error("loadFileInjection is not defined");L(N+"."+I.toLowerCase()+".fx",x)}const F=(B,I,C,M)=>{try{const y=B.context?(0,x.H)(B.context):null;y&&(y.disableParallelShaderCompile=B.disableParallelCompilation);const f=B.existingPipelineContext||I(B.shaderProcessingContext);return f._name=B.name,B.name&&y&&(y.cachedPipelines[B.name]=f),C(f,B.vertex,B.fragment,!!B.createAsRaw,"","",B.rebuildRebind,B.defines,B.transformFeedbackVaryings,"",(()=>{M(f,(()=>{var I;null===(I=B.onRenderingStateCompiled)||void 0===I||I.call(B,f)}))})),f}catch(y){throw f.b.Error("Error compiling effect"),y}}},11101:(B,I,C)=>{C.r(I),C.d(I,{Effect:()=>e});var M=C(11022),x=C(11027),y=C(11110),f=C(11113),L=C(11091);class e{static get ShadersRepository(){return y.d.ShadersRepository}static set ShadersRepository(B){y.d.ShadersRepository=B}get R(){return this._isDisposed}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new M.e),this._onBindObservable}get shaderLanguage(){return this._shaderLanguage}constructor(B,I,C){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,y=arguments.length>4?arguments[4]:void 0,L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,g=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,N=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,R=arguments.length>8&&void 0!==arguments[8]?arguments[8]:null,H=arguments.length>9?arguments[9]:void 0,F=arguments.length>10&&void 0!==arguments[10]?arguments[10]:"",k=arguments.length>11&&void 0!==arguments[11]?arguments[11]:0,q=arguments.length>12?arguments[12]:void 0;this.defines="",this.onCompiled=null,this.onError=null,this.onBind=null,this.uniqueId=0,this.onCompileObservable=new M.e,this.onErrorObservable=new M.e,this._onBindObservable=null,this._isDisposed=!1,this._refCount=1,this._bonesComputationForcedToCPU=!1,this._uniformBuffersNames={},this._multiTarget=!1,this._samplers={},this._isReady=!1,this._compilationError="",this._allFallbacksProcessed=!1,this._uniforms={},this._key="",this._fallbacks=null,this._vertexSourceCodeOverride="",this._fragmentSourceCodeOverride="",this._transformFeedbackVaryings=null,this._disableParallelShaderCompilation=!1,this._pipelineContext=null,this._vertexSourceCode="",this._fragmentSourceCode="",this._vertexSourceCodeBeforeMigration="",this._fragmentSourceCodeBeforeMigration="",this._rawVertexSourceCode="",this._rawFragmentSourceCode="",this._processCodeAfterIncludes=void 0,this._processFinalCode=null,this.name=B,this._key=F;const S=this._key.replace(/\r/g,"").replace(/\n/g,"|");let o;if(I.attributes){const B=I;if(this._engine=C,this._attributesNames=B.attributes,this._uniformsNames=B.uniformsNames.concat(B.samplers),this._samplerList=B.samplers.slice(),this.defines=B.defines,this.onError=B.onError,this.onCompiled=B.onCompiled,this._fallbacks=B.fallbacks,this._indexParameters=B.indexParameters,this._transformFeedbackVaryings=B.transformFeedbackVaryings||null,this._multiTarget=!!B.multiTarget,this._shaderLanguage=B.shaderLanguage??0,this._disableParallelShaderCompilation=!!B.disableParallelShaderCompilation,B.uniformBuffersNames){this._uniformBuffersNamesList=B.uniformBuffersNames.slice();for(let I=0;I<B.uniformBuffersNames.length;I++)this._uniformBuffersNames[B.uniformBuffersNames[I]]=I}this._processFinalCode=B.processFinalCode??null,this._processCodeAfterIncludes=B.processCodeAfterIncludes??void 0,q=B.extraInitializationsAsync,o=B.existingPipelineContext}else this._engine=y,this.defines=null==L?"":L,this._uniformsNames=C.concat(x),this._samplerList=x?x.slice():[],this._attributesNames=I,this._uniformBuffersNamesList=[],this._shaderLanguage=k,this.onError=R,this.onCompiled=N,this._indexParameters=H,this._fallbacks=g;"WEBGL2"===this._engine.shaderPlatformName&&(o=(0,f.j)(S,this._engine._gl)??o),this._attributeLocationByName={},this.uniqueId=e._UniqueIdSeed++,o?(this._pipelineContext=o,this._pipelineContext.setEngine(this._engine),this._onRenderingStateCompiled(this._pipelineContext),this._pipelineContext.program&&(this._pipelineContext.program.__SPECTOR_rebuildProgram=this._rebuildProgram.bind(this))):this._processShaderCodeAsync(null,!1,null,q),this._engine.onReleaseEffectsObservable.addOnce((()=>{this.R||this.dispose(!0)}))}async _processShaderCodeAsync(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,M=arguments.length>3?arguments[3]:void 0;M&&await M(),this._processingContext=C||this._engine._getShaderProcessingContext(this._shaderLanguage,!1);const x={defines:this.defines.split("\n"),indexParameters:this._indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:B??this._engine._getShaderProcessor(this._shaderLanguage),supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:y.d.GetShadersRepository(this._shaderLanguage),includesShadersStore:y.d.GetIncludesShadersStore(this._shaderLanguage),version:(100*this._engine.version).toString(),platformName:this._engine.shaderPlatformName,processingContext:this._processingContext,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:this._processCodeAfterIncludes};(0,f.d)(x,this.name,this._processFinalCode,((B,C)=>{this._vertexSourceCode=B,this._fragmentSourceCode=C,this._prepareEffect(I)}),this._shaderLanguage,this._engine,this)}get key(){return this._key}isReady(){try{return this._isReadyInternal()}catch{return!1}}_isReadyInternal(){return!!this._engine.R||(!!this._isReady||!!this._pipelineContext&&this._pipelineContext.isReady)}getEngine(){return this._engine}getPipelineContext(){return this._pipelineContext}getAttributesNames(){return this._attributesNames}getAttributeLocation(B){return this._attributes[B]}getAttributeLocationByName(B){return this._attributeLocationByName[B]}getAttributesCount(){return this._attributes.length}getUniformIndex(B){return this._uniformsNames.indexOf(B)}getUniform(B){return this._uniforms[B]}getSamplers(){return this._samplerList}getUniformNames(){return this._uniformsNames}getUniformBuffersNames(){return this._uniformBuffersNamesList}getIndexParameters(){return this._indexParameters}getCompilationError(){return this._compilationError}allFallbacksProcessed(){return this._allFallbacksProcessed}async whenCompiledAsync(){return await new Promise((B=>{this.executeWhenCompiled(B)}))}executeWhenCompiled(B){this.isReady()?B(this):(this.onCompileObservable.add((I=>{B(I)})),this._pipelineContext&&!this._pipelineContext.isAsync||this._checkIsReady(null))}_checkIsReady(B){(0,L.f)((()=>this._isReadyInternal()||this._isDisposed),(()=>{}),(I=>{this._processCompilationErrors(I,B)}),16,12e4,!0,` - Effect: ${"string"===typeof this.name?this.name:this.key}`)}get vertexSourceCode(){var B;return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._vertexSourceCodeOverride:(null===(B=this._pipelineContext)||void 0===B?void 0:B._getVertexShaderCode())??this._vertexSourceCode}get fragmentSourceCode(){var B;return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._fragmentSourceCodeOverride:(null===(B=this._pipelineContext)||void 0===B?void 0:B._getFragmentShaderCode())??this._fragmentSourceCode}get vertexSourceCodeBeforeMigration(){return this._vertexSourceCodeBeforeMigration}get fragmentSourceCodeBeforeMigration(){return this._fragmentSourceCodeBeforeMigration}get rawVertexSourceCode(){return this._rawVertexSourceCode}get rawFragmentSourceCode(){return this._rawFragmentSourceCode}getPipelineGenerationOptions(){return{platformName:this._engine.shaderPlatformName,shaderLanguage:this._shaderLanguage,shaderNameOrContent:this.name,key:this._key,defines:this.defines.split("\n"),addGlobalDefines:!1,extendedProcessingOptions:{indexParameters:this._indexParameters,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,supportsUniformBuffers:this._engine.supportsUniformBuffers},extendedCreatePipelineOptions:{transformFeedbackVaryings:this._transformFeedbackVaryings,createAsRaw:!(!this._vertexSourceCodeOverride||!this._fragmentSourceCodeOverride)}}}_rebuildProgram(B,I,C,M){this._isReady=!1,this._vertexSourceCodeOverride=B,this._fragmentSourceCodeOverride=I,this.onError=(B,I)=>{M&&M(I)},this.onCompiled=()=>{var B,I;const M=this.getEngine().scenes;if(M)for(let C=0;C<M.length;C++)M[C].markAllMaterialsAsDirty(127);null===(B=(I=this._pipelineContext)._handlesSpectorRebuildCallback)||void 0===B||B.call(I,C)},this._fallbacks=null,this._prepareEffect()}_onRenderingStateCompiled(B){if(this._pipelineContext=B,this._pipelineContext.setEngine(this._engine),this._attributes=[],this._pipelineContext._fillEffectInformation(this,this._uniformBuffersNames,this._uniformsNames,this._uniforms,this._samplerList,this._samplers,this._attributesNames,this._attributes),this._attributesNames)for(let I=0;I<this._attributesNames.length;I++){const B=this._attributesNames[I];this._attributeLocationByName[B]=this._attributes[I]}this._engine.bindSamplers(this),this._compilationError="",this._isReady=!0,this.onCompiled&&this.onCompiled(this),this.onCompileObservable.notifyObservers(this),this.onCompileObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh(),e.AutomaticallyClearCodeCache&&this.clearCodeCache()}_prepareEffect(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=this._pipelineContext;this._isReady=!1;try{const C=!(!this._vertexSourceCodeOverride||!this._fragmentSourceCodeOverride),M=C?null:this.defines,x=C?this._vertexSourceCodeOverride:this._vertexSourceCode,y=C?this._fragmentSourceCodeOverride:this._fragmentSourceCode,L=this._engine;this._pipelineContext=(0,f.f)({existingPipelineContext:B?I:null,vertex:x,fragment:y,context:"WEBGL2"===L.shaderPlatformName||"WEBGL1"===L.shaderPlatformName?L._gl:void 0,rebuildRebind:(B,I,C,M)=>this._rebuildProgram(B,I,C,M),defines:M,transformFeedbackVaryings:this._transformFeedbackVaryings,name:this._key.replace(/\r/g,"").replace(/\n/g,"|"),createAsRaw:C,disableParallelCompilation:this._disableParallelShaderCompilation,shaderProcessingContext:this._processingContext,onRenderingStateCompiled:C=>{I&&!B&&this._engine._deletePipelineContext(I),C&&this._onRenderingStateCompiled(C)}},this._engine.createPipelineContext.bind(this._engine),this._engine._preparePipelineContextAsync.bind(this._engine),this._engine._executeWhenRenderingStateIsCompiled.bind(this._engine)),this._pipelineContext.isAsync&&this._checkIsReady(I)}catch(C){this._processCompilationErrors(C,I)}}_getShaderCodeAndErrorLine(B,I,C){const M=C?/FRAGMENT SHADER ERROR: 0:(\d+?):/:/VERTEX SHADER ERROR: 0:(\d+?):/;let x=null;if(I&&B){const y=I.match(M);if(y&&2===y.length){const I=parseInt(y[1]),M=B.split("\n",-1);M.length>=I&&(x=`Offending line [${I}] in ${C?"fragment":"vertex"} code: ${M[I-1]}`)}}return[B,x]}_processCompilationErrors(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;this._compilationError=B.message;const C=this._attributesNames,M=this._fallbacks;if(x.b.Error("Unable to compile effect:"),x.b.Error(`Uniforms: ${this._uniformsNames.join(" ")}`),x.b.Error(`Attributes: ${C.join(" ")}`),x.b.Error("Defines:\n"+this.defines),e.LogShaderCodeOnCompilationError){var y,f;let B=null,I=null,C=null;var L;if(null!==(y=this._pipelineContext)&&void 0!==y&&y._getVertexShaderCode()&&([C,B]=this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(),this._compilationError,!1),C&&(x.b.Error("Vertex code:"),x.b.Error(C))),null!==(f=this._pipelineContext)&&void 0!==f&&f._getFragmentShaderCode())[C,I]=this._getShaderCodeAndErrorLine(null===(L=this._pipelineContext)||void 0===L?void 0:L._getFragmentShaderCode(),this._compilationError,!0),C&&(x.b.Error("Fragment code:"),x.b.Error(C));B&&x.b.Error(B),I&&x.b.Error(I)}x.b.Error("Error: "+this._compilationError);const g=()=>{this.onError&&this.onError(this,this._compilationError),this.onErrorObservable.notifyObservers(this),this._engine.onEffectErrorObservable.notifyObservers({effect:this,errors:this._compilationError})};I&&(this._pipelineContext=I,this._isReady=!0,g()),M?(this._pipelineContext=null,M.hasMoreFallbacks?(this._allFallbacksProcessed=!1,x.b.Error("Trying next fallback."),this.defines=M.reduce(this.defines,this),this._prepareEffect()):(this._allFallbacksProcessed=!0,g(),this.onErrorObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh())):(this._allFallbacksProcessed=!0,I||g())}get isSupported(){return""===this._compilationError}_bindTexture(B,I){this._engine._bindTexture(this._samplers[B],I,B)}setTexture(B,I){this._engine.setTexture(this._samplers[B],this._uniforms[B],I,B)}setTextureArray(B,I){const C=B+"Ex";if(-1===this._samplerList.indexOf(C+"0")){const M=this._samplerList.indexOf(B);for(let B=1;B<I.length;B++){const I=C+(B-1).toString();this._samplerList.splice(M+B,0,I)}let x=0;for(const B of this._samplerList)this._samplers[B]=x,x+=1}this._engine.setTextureArray(this._samplers[B],this._uniforms[B],I,B)}bindUniformBuffer(B,I){const C=this._uniformBuffersNames[I];void 0===C||e._BaseCache[C]===B&&this._engine._features.useUBOBindingCache||(e._BaseCache[C]=B,this._engine.bindUniformBufferBase(B,C,I))}bindUniformBlock(B,I){this._engine.bindUniformBlock(this._pipelineContext,B,I)}setInt(B,I){return this._pipelineContext.setInt(B,I),this}setInt2(B,I,C){return this._pipelineContext.setInt2(B,I,C),this}setInt3(B,I,C,M){return this._pipelineContext.setInt3(B,I,C,M),this}setInt4(B,I,C,M,x){return this._pipelineContext.setInt4(B,I,C,M,x),this}setIntArray(B,I){return this._pipelineContext.setIntArray(B,I),this}setIntArray2(B,I){return this._pipelineContext.setIntArray2(B,I),this}setIntArray3(B,I){return this._pipelineContext.setIntArray3(B,I),this}setIntArray4(B,I){return this._pipelineContext.setIntArray4(B,I),this}setUInt(B,I){return this._pipelineContext.setUInt(B,I),this}setUInt2(B,I,C){return this._pipelineContext.setUInt2(B,I,C),this}setUInt3(B,I,C,M){return this._pipelineContext.setUInt3(B,I,C,M),this}setUInt4(B,I,C,M,x){return this._pipelineContext.setUInt4(B,I,C,M,x),this}setUIntArray(B,I){return this._pipelineContext.setUIntArray(B,I),this}setUIntArray2(B,I){return this._pipelineContext.setUIntArray2(B,I),this}setUIntArray3(B,I){return this._pipelineContext.setUIntArray3(B,I),this}setUIntArray4(B,I){return this._pipelineContext.setUIntArray4(B,I),this}setFloatArray(B,I){return this._pipelineContext.setArray(B,I),this}setFloatArray2(B,I){return this._pipelineContext.setArray2(B,I),this}setFloatArray3(B,I){return this._pipelineContext.setArray3(B,I),this}setFloatArray4(B,I){return this._pipelineContext.setArray4(B,I),this}setArray(B,I){return this._pipelineContext.setArray(B,I),this}setArray2(B,I){return this._pipelineContext.setArray2(B,I),this}setArray3(B,I){return this._pipelineContext.setArray3(B,I),this}setArray4(B,I){return this._pipelineContext.setArray4(B,I),this}setMatrices(B,I){return this._pipelineContext.setMatrices(B,I),this}setMatrix(B,I){return this._pipelineContext.setMatrix(B,I),this}setMatrix3x3(B,I){return this._pipelineContext.setMatrix3x3(B,I),this}setMatrix2x2(B,I){return this._pipelineContext.setMatrix2x2(B,I),this}setFloat(B,I){return this._pipelineContext.setFloat(B,I),this}setBool(B,I){return this._pipelineContext.setInt(B,I?1:0),this}setVector2(B,I){return this._pipelineContext.setVector2(B,I),this}setFloat2(B,I,C){return this._pipelineContext.setFloat2(B,I,C),this}setVector3(B,I){return this._pipelineContext.setVector3(B,I),this}setFloat3(B,I,C,M){return this._pipelineContext.setFloat3(B,I,C,M),this}setVector4(B,I){return this._pipelineContext.setVector4(B,I),this}setQuaternion(B,I){return this._pipelineContext.setQuaternion(B,I),this}setFloat4(B,I,C,M,x){return this._pipelineContext.setFloat4(B,I,C,M,x),this}setColor3(B,I){return this._pipelineContext.setColor3(B,I),this}setColor4(B,I,C){return this._pipelineContext.setColor4(B,I,C),this}setDirectColor4(B,I){return this._pipelineContext.setDirectColor4(B,I),this}clearCodeCache(){this._vertexSourceCode="",this._fragmentSourceCode="",this._fragmentSourceCodeBeforeMigration="",this._vertexSourceCodeBeforeMigration=""}dispose(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])this._refCount=0;else{if(e.PersistentMode)return;this._refCount--}this._refCount>0||this._isDisposed||(this._pipelineContext&&(0,f.k)(this._pipelineContext),this._engine._releaseEffect(this),this.clearCodeCache(),this._isDisposed=!0)}static RegisterShader(B,I,C){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;I&&(y.d.GetShadersStore(M)[`${B}PixelShader`]=I),C&&(y.d.GetShadersStore(M)[`${B}VertexShader`]=C)}static ResetCache(){e._BaseCache={}}}e.LogShaderCodeOnCompilationError=!0,e.PersistentMode=!1,e.AutomaticallyClearCodeCache=!1,e._UniqueIdSeed=0,e._BaseCache={},e.ShadersStore=y.d.ShadersStore,e.IncludesShadersStore=y.d.IncludesShadersStore},11042:(B,I,C)=>{C.d(I,{c:()=>x});const M={};function x(B){if(!(arguments.length>1&&void 0!==arguments[1]&&arguments[1])||!M[B])return M[B]=!0,`${B} needs to be imported before as it contains a side-effect required by your code.`}},11024:(B,I,C)=>{function M(){return"undefined"!==typeof window}function x(){return"undefined"!==typeof navigator}function y(){return"undefined"!==typeof document}function f(B){let I="",C=B.firstChild;for(;C;)3===C.nodeType&&(I+=C.textContent),C=C.nextSibling;return I}C.d(I,{d:()=>f,f:()=>y,h:()=>x,k:()=>M})},11027:(B,I,C)=>{C.d(I,{b:()=>M});class M{static _CheckLimit(B,I){let C=M._LogLimitOutputs[B];return C?C.current++:(C={limit:I,current:1},M._LogLimitOutputs[B]=C),C.current<=C.limit}static _GenerateLimitMessage(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const C=M._LogLimitOutputs[B];if(!C||!M.MessageLimitReached)return;const x=this._Levels[I];C.current===C.limit&&M[x.name](M.MessageLimitReached.replace(/%LIMIT%/g,""+C.limit).replace(/%TYPE%/g,x.name??""))}static _AddLogEntry(B){M._LogCache=B+M._LogCache,M.OnNewCacheEntry&&M.OnNewCacheEntry(B)}static _FormatMessage(B){const I=B=>B<10?"0"+B:""+B,C=new Date;return"["+I(C.getHours())+":"+I(C.getMinutes())+":"+I(C.getSeconds())+"]: "+B}static _LogDisabled(B,I){}static _LogEnabled(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,I=arguments.length>1?arguments[1]:void 0,C=arguments.length>2?arguments[2]:void 0;const x=Array.isArray(I)?I[0]:I;if(void 0!==C&&!M._CheckLimit(x,C))return;const y=M._FormatMessage(x),f=this._Levels[B],L=Array.isArray(I)?I.slice(1):[];f.logFunc&&f.logFunc("BJS - "+y,...L);const e=`<div style='color:${f.color}'>${y}</div><br>`;M._AddLogEntry(e),M._GenerateLimitMessage(x,B)}static get LogCache(){return M._LogCache}static ClearLogCache(){M._LogCache="",M._LogLimitOutputs={},M.errorsCount=0}static set LogLevels(B){M.Log=M._LogDisabled,M.Warn=M._LogDisabled,M.Error=M._LogDisabled;const I=[M.MessageLogLevel,M.WarningLogLevel,M.ErrorLogLevel];for(const C of I)if((B&C)===C){const B=this._Levels[C];M[B.name]=M._LogEnabled.bind(M,C)}}}M.NoneLogLevel=0,M.MessageLogLevel=1,M.WarningLogLevel=2,M.ErrorLogLevel=4,M.AllLogLevel=7,M.MessageLimitReached="Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.",M._LogCache="",M._LogLimitOutputs={},M._Levels=[{},{color:"white",logFunc:console.log,name:"Log"},{color:"orange",logFunc:console.warn,name:"Warn"},{},{color:"red",logFunc:console.error,name:"Error"}],M.errorsCount=0,M.Log=M._LogEnabled.bind(M,M.MessageLogLevel),M.Warn=M._LogEnabled.bind(M,M.WarningLogLevel),M.Error=M._LogEnabled.bind(M,M.ErrorLogLevel)},11022:(B,I,C)=>{C.d(I,{e:()=>f});const M="undefined"!==typeof WeakRef;class x{constructor(B){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2?arguments[2]:void 0,M=arguments.length>3?arguments[3]:void 0;this.initialize(B,I,C,M)}initialize(B){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2?arguments[2]:void 0,M=arguments.length>3?arguments[3]:void 0;return this.mask=B,this.skipNextObservers=I,this.target=C,this.currentTarget=M,this}}class y{constructor(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this.callback=B,this.mask=I,this.scope=C,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this._remove&&this._remove(B)}}class f{static FromPromise(B,I){const C=new f;return B.then((B=>{C.notifyObservers(B)})).catch((B=>{if(!I)throw B;I.notifyObservers(B)})),C}get observers(){return this._observers}constructor(B){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.notifyIfTriggered=I,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new x(0),B&&(this._onObserverAdded=B)}add(B){let I=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!B)return null;const x=new y(B,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null);x.unregisterOnNextCall=C,I?this._observers.unshift(x):this._observers.push(x),this._onObserverAdded&&this._onObserverAdded(x),this._hasNotified&&this.notifyIfTriggered&&void 0!==this._lastNotifiedValue&&this.notifyObserver(x,this._lastNotifiedValue);const f=M?new WeakRef(this):{deref:()=>this};return x._remove=function(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=f.deref();I&&(B?I.remove(x):I._remove(x))},x}addOnce(B){return this.add(B,void 0,void 0,void 0,!0)}remove(B){if(!B)return!1;B._remove=null;return-1!==this._observers.indexOf(B)&&(this._deferUnregister(B),!0)}removeCallback(B,I){for(let C=0;C<this._observers.length;C++){const M=this._observers[C];if(!M._willBeUnregistered&&(M.callback===B&&(!I||I===M.scope)))return this._deferUnregister(M),!0}return!1}_deferUnregister(B){B._willBeUnregistered||(this._numObserversMarkedAsDeleted++,B.unregisterOnNextCall=!1,B._willBeUnregistered=!0,setTimeout((()=>{this._remove(B)}),0))}_remove(B){let I=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!B)return!1;const C=this._observers.indexOf(B);return-1!==C&&(I&&this._numObserversMarkedAsDeleted--,this._observers.splice(C,1),!0)}makeObserverTopPriority(B){this._remove(B,!1),this._observers.unshift(B)}makeObserverBottomPriority(B){this._remove(B,!1),this._observers.push(B)}notifyObservers(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,C=arguments.length>2?arguments[2]:void 0,M=arguments.length>3?arguments[3]:void 0,x=arguments.length>4?arguments[4]:void 0;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=B),!this._observers.length)return!0;const y=this._eventState;y.mask=I,y.target=C,y.currentTarget=M,y.skipNextObservers=!1,y.lastReturnValue=B,y.userInfo=x;for(const f of this._observers)if(!f._willBeUnregistered&&(f.mask&I&&(f.unregisterOnNextCall&&this._deferUnregister(f),f.scope?y.lastReturnValue=f.callback.apply(f.scope,[B,y]):y.lastReturnValue=f.callback(B,y)),y.skipNextObservers))return!1;return!0}notifyObserver(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=I),B._willBeUnregistered)return;const M=this._eventState;M.mask=C,M.skipNextObservers=!1,B.unregisterOnNextCall&&this._deferUnregister(B),B.callback(I,M)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const B=this._observers.pop();B&&(B._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const B=new f;return B._observers=this._observers.slice(0),B}hasSpecificMask(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;for(const I of this._observers)if(I.mask&B||I.mask===B)return!0;return!1}}},11091:(B,I,C)=>{C.d(I,{e:()=>x,f:()=>f});let M=[];class x{static SetImmediate(B){0===M.length&&setTimeout((()=>{const B=M;M=[];for(const I of B)I()}),1),M.push(B)}}function y(B,I,C){try{if(B())return I(),!0}catch(M){return null===C||void 0===C||C(M),!0}return!1}const f=function(B,I,C){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:16,x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:3e4,f=arguments.length>6?arguments[6]:void 0;if((!(arguments.length>5&&void 0!==arguments[5])||arguments[5])&&y(B,I,C))return null;const L=setInterval((()=>{y(B,I,C)?clearInterval(L):(x-=M,x<0&&(clearInterval(L),null===C||void 0===C||C(new Error("Operation timed out after maximum retries. "+(f||"")),!0)))}),M);return()=>clearInterval(L)}}}]);