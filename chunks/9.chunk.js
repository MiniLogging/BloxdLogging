"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[9],{11469:(U,X,b)=>{b.d(X,{e:()=>j,h:()=>P,n:()=>f,j:()=>s,p:()=>h});class F{constructor(){this.children=[]}isValid(U){return!0}process(U,X,b){let F="";if(this.line){let b=this.line;const S=X.processor;if(S){var E,w,Q,z,q,p;S.lineProcessor&&(b=S.lineProcessor(b,X.isFragment,X.processingContext));const F=(null===(E=X.processor)||void 0===E?void 0:E.attributeKeywordName)??"attribute",R=X.isFragment&&null!==(w=X.processor)&&void 0!==w&&w.varyingFragmentKeywordName?null===(Q=X.processor)||void 0===Q?void 0:Q.varyingFragmentKeywordName:!X.isFragment&&null!==(z=X.processor)&&void 0!==z&&z.varyingVertexKeywordName?null===(q=X.processor)||void 0===q?void 0:q.varyingVertexKeywordName:"varying";if(!X.isFragment&&S.attributeProcessor&&this.line.startsWith(F))b=S.attributeProcessor(this.line,U,X.processingContext);else if(S.varyingProcessor&&(null!==(p=S.varyingCheck)&&void 0!==p&&p.call(S,this.line,X.isFragment)||!S.varyingCheck&&this.line.startsWith(R)))b=S.varyingProcessor(this.line,X.isFragment,U,X.processingContext);else if(S.uniformProcessor&&S.uniformRegexp&&S.uniformRegexp.test(this.line))X.lookForClosingBracketForUniformBuffer||(b=S.uniformProcessor(this.line,X.isFragment,U,X.processingContext));else if(S.uniformBufferProcessor&&S.uniformBufferRegexp&&S.uniformBufferRegexp.test(this.line))X.lookForClosingBracketForUniformBuffer||(b=S.uniformBufferProcessor(this.line,X.isFragment,X.processingContext),X.lookForClosingBracketForUniformBuffer=!0);else if(S.textureProcessor&&S.textureRegexp&&S.textureRegexp.test(this.line))b=S.textureProcessor(this.line,X.isFragment,U,X.processingContext);else if((S.uniformProcessor||S.uniformBufferProcessor)&&this.line.startsWith("uniform")&&!X.lookForClosingBracketForUniformBuffer){/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line)?S.uniformProcessor&&(b=S.uniformProcessor(this.line,X.isFragment,U,X.processingContext)):S.uniformBufferProcessor&&(b=S.uniformBufferProcessor(this.line,X.isFragment,X.processingContext),X.lookForClosingBracketForUniformBuffer=!0)}X.lookForClosingBracketForUniformBuffer&&-1!==this.line.indexOf("}")&&(X.lookForClosingBracketForUniformBuffer=!1,S.endOfUniformBufferProcessor&&(b=S.endOfUniformBufferProcessor(this.line,X.isFragment,X.processingContext)))}F+=b+"\n"}for(const S of this.children)F+=S.process(U,X,b);return this.additionalDefineKey&&(U[this.additionalDefineKey]=this.additionalDefineValue||"true",b[this.additionalDefineKey]=U[this.additionalDefineKey]),F}}class E{constructor(){this._lines=[]}get currentLine(){return this._lines[this.lineIndex]}get canRead(){return this.lineIndex<this._lines.length-1}set lines(U){this._lines.length=0;for(const X of U){if(!X||"\r"===X)continue;if("#"===X[0]){this._lines.push(X);continue}const U=X.trim();if(!U)continue;if(U.startsWith("//")){this._lines.push(X);continue}const b=U.indexOf(";");if(-1===b)this._lines.push(U);else if(b===U.length-1)U.length>1&&this._lines.push(U);else{const U=X.split(";");for(let X=0;X<U.length;X++){let b=U[X];b&&(b=b.trim(),b&&this._lines.push(b+(X!==U.length-1?";":"")))}}}}}class w extends F{process(U,X,b){for(let F=0;F<this.children.length;F++){const E=this.children[F];if(E.isValid(U))return E.process(U,X,b)}return""}}class Q extends F{isValid(U){return this.testExpression.isTrue(U)}}class z{isTrue(U){return!0}static postfixToInfix(U){const X=[];for(const b of U)if(void 0===z._OperatorPriority[b])X.push(b);else{const U=X[X.length-1],F=X[X.length-2];X.length-=2,X.push(`(${F}${b}${U})`)}return X[X.length-1]}static infixToPostfix(U){const X=z._InfixToPostfixCache.get(U);if(X)return X.accessTime=Date.now(),X.result;if(!U.includes("&&")&&!U.includes("||")&&!U.includes(")")&&!U.includes("("))return[U];const b=[];let F=-1;const E=()=>{S=S.trim(),""!==S&&(b.push(S),S="")},w=U=>{F<z._Stack.length-1&&(z._Stack[++F]=U)},Q=()=>z._Stack[F],q=()=>-1===F?"!!INVALID EXPRESSION!!":z._Stack[F--];let p=0,S="";for(;p<U.length;){const X=U.charAt(p),R=p<U.length-1?U.substring(p,2+p):"";if("("===X)S="",w(X);else if(")"===X){for(E();-1!==F&&"("!==Q();)b.push(q());q()}else if(z._OperatorPriority[R]>1){for(E();-1!==F&&z._OperatorPriority[Q()]>=z._OperatorPriority[R];)b.push(q());w(R),p++}else S+=X;p++}for(E();-1!==F;)"("===Q()?q():b.push(q());return z._InfixToPostfixCache.size>=z.InfixToPostfixCacheLimitSize&&z.ClearCache(),z._InfixToPostfixCache.set(U,{result:b,accessTime:Date.now()}),b}static ClearCache(){const U=Array.from(z._InfixToPostfixCache.entries()).sort(((U,X)=>U[1].accessTime-X[1].accessTime));for(let X=0;X<z.InfixToPostfixCacheCleanupSize;X++)z._InfixToPostfixCache.delete(U[X][0])}}z.InfixToPostfixCacheLimitSize=5e4,z.InfixToPostfixCacheCleanupSize=25e3,z._InfixToPostfixCache=new Map,z._OperatorPriority={")":0,"(":1,"||":2,"&&":3},z._Stack=["","","","","","","","","","","","","","","","","","","",""];class q extends z{constructor(U){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super(),this.define=U,this.not=X}isTrue(U){let X=void 0!==U[this.define];return this.not&&(X=!X),X}}class p extends z{isTrue(U){return this.leftOperand.isTrue(U)||this.rightOperand.isTrue(U)}}class S extends z{isTrue(U){return this.leftOperand.isTrue(U)&&this.rightOperand.isTrue(U)}}class R extends z{constructor(U,X,b){super(),this.define=U,this.operand=X,this.testValue=b}toString(){return`${this.define} ${this.operand} ${this.testValue}`}isTrue(U){let X=!1;const b=parseInt(void 0!=U[this.define]?U[this.define]:this.define),F=parseInt(void 0!=U[this.testValue]?U[this.testValue]:this.testValue);if(isNaN(b)||isNaN(F))return!1;switch(this.operand){case">":X=b>F;break;case"<":X=b<F;break;case"<=":X=b<=F;break;case">=":X=b>=F;break;case"==":X=b===F;break;case"!=":X=b!==F}return X}}var n=b(11428),a=b(11472);const J=/defined\s*?\((.+?)\)/g,m=/defined\s*?\[(.+?)\]/g,x=/#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,I=/__decl__/,O=/light\{X\}.(\w*)/g,N=/\{X\}/g,u=[],i=/(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;function P(U){U.processor&&U.processor.initializeShaders&&U.processor.initializeShaders(U.processingContext)}function f(U,X,b,F){var E;null!==(E=X.processor)&&void 0!==E&&E.preProcessShaderCode&&(U=X.processor.preProcessShaderCode(U,X.isFragment)),s(U,X,(U=>{X.processCodeAfterIncludes&&(U=X.processCodeAfterIncludes(X.isFragment?"fragment":"vertex",U,X.defines));const E=function(U,X,b){let F=function(U,X){var b;if(null!==(b=X.processor)&&void 0!==b&&b.noPrecision)return U;const F=X.shouldUseHighPrecisionShader;-1===U.indexOf("precision highp float")?U=F?"precision highp float;\n"+U:"precision mediump float;\n"+U:F||(U=U.replace("precision highp float","precision mediump float"));return U}(U,X);if(!X.processor)return F;if(0===X.processor.shaderLanguage&&-1!==F.indexOf("#version 3")&&(F=F.replace("#version 300 es",""),!X.processor.parseGLES3))return F;const E=X.defines,w=A(X,b);X.processor.preProcessor&&(F=X.processor.preProcessor(F,E,w,X.isFragment,X.processingContext));const Q={};F=v(F,w,X,Q),X.processor.postProcessor&&(F=X.processor.postProcessor(F,E,X.isFragment,X.processingContext,b?{drawBuffersExtensionDisabled:!b.getCaps().drawBuffersExtension}:{},w,Q));null!==b&&void 0!==b&&b._features.needShaderCodeInlining&&(F=b.inlineShaderCode(F));return F}(U,X,F);b(E,U)}))}function j(U,X,b){return b.processor&&b.processor.finalizeShaders?b.processor.finalizeShaders(U,X,b.processingContext):{vertexCode:U,fragmentCode:X}}function e(U){const X=/defined\((.+)\)/.exec(U);if(X&&X.length)return new q(X[1].trim(),"!"===U[0]);const b=["==","!=",">=","<=","<",">"];let F="",E=0;for(F of b)if(E=U.indexOf(F),E>-1)break;if(-1===E)return new q(U);const w=U.substring(0,E).trim(),Q=U.substring(E+F.length).trim();return new R(w,F,Q)}function l(U,X){const b=new Q,F=U.substring(0,X);let E=U.substring(X);return E=E.substring(0,(E.indexOf("//")+1||E.length+1)-1).trim(),b.testExpression="#ifdef"===F?new q(E):"#ifndef"===F?new q(E,!0):function(U){U=U.replace(J,"defined[$1]");const X=z.infixToPostfix(U),b=[];for(const E of X)if("||"!==E&&"&&"!==E)b.push(E);else if(b.length>=2){let U=b[b.length-1],X=b[b.length-2];b.length-=2;const F="&&"==E?new S:new p;"string"===typeof U&&(U=U.replace(m,"defined($1)")),"string"===typeof X&&(X=X.replace(m,"defined($1)")),F.leftOperand="string"===typeof X?e(X):X,F.rightOperand="string"===typeof U?e(U):U,b.push(F)}let F=b[b.length-1];return"string"===typeof F&&(F=F.replace(m,"defined($1)")),"string"===typeof F?e(F):F}(E),b}function d(U,X,b,E){let w=U.currentLine;for(;k(U,b,E);){w=U.currentLine;const Q=w.substring(0,5).toLowerCase();if("#else"===Q){const b=new F;return X.children.push(b),void k(U,b,E)}if("#elif"===Q){const U=l(w,5);X.children.push(U),b=U}}}function k(U,X,b){for(;U.canRead;){U.lineIndex++;const E=U.currentLine;if(E.indexOf("#")>=0){const F=i.exec(E);if(F&&F.length){switch(F[0]){case"#ifdef":{const F=new w;X.children.push(F);const Q=l(E,6);F.children.push(Q),d(U,F,Q,b);break}case"#else":case"#elif":return!0;case"#endif":return!1;case"#ifndef":{const F=new w;X.children.push(F);const Q=l(E,7);F.children.push(Q),d(U,F,Q,b);break}case"#if":{const F=new w,Q=l(E,3);X.children.push(F),F.children.push(Q),d(U,F,Q,b);break}}continue}}const Q=new F;if(Q.line=E,X.children.push(Q),"#"===E[0]&&"d"===E[1]){const U=E.replace(";","").split(" ");Q.additionalDefineKey=U[1],3===U.length&&(Q.additionalDefineValue=U[2])}}return!1}function v(U,X,b,w){const Q=new F,z=new E;return z.lineIndex=-1,z.lines=U.split("\n"),k(z,Q,w),Q.process(X,b,w)}function A(U,X){var b;const F=U.defines,E={};for(const w of F){const U=w.replace("#define","").replace(";","").trim().split(" ");E[U[0]]=U.length>1?U[1]:""}return 0===(null===(b=U.processor)||void 0===b?void 0:b.shaderLanguage)&&(E.GL_ES="true"),E.__VERSION__=U.version,E[U.platformName]="true",(0,a.i)(E,null===X||void 0===X?void 0:X.isNDCHalfZRange,null===X||void 0===X?void 0:X.useReverseDepthBuffer,null===X||void 0===X?void 0:X.useExactSrgbConversions),E}function s(U,X,b){let F;for(u.length=0;null!==(F=x.exec(U));)u.push(F);let E=String(U),w=[U],Q=!1;for(const z of u){let U=z[1];if(-1!==U.indexOf("__decl__")&&(U=U.replace(I,""),X.supportsUniformBuffers&&(U=U.replace("Vertex","Ubo").replace("Fragment","Ubo")),U+="Declaration"),!X.includesShadersStore[U]){const F=X.shadersRepository+"ShadersInclude/"+U+".fx";return void h.loadFile(F,(F=>{X.includesShadersStore[U]=F,s(w.join(""),X,b)}))}{let b=X.includesShadersStore[U];if(z[2]){const U=z[3].split(",");for(let X=0;X<U.length;X+=2){const F=new RegExp(U[X],"g"),E=U[X+1];b=b.replace(F,E)}}if(z[4]){const U=z[5];if(-1!==U.indexOf("..")){const F=U.split(".."),E=parseInt(F[0]);let w=parseInt(F[1]),Q=b.slice(0);b="",isNaN(w)&&(w=X.indexParameters[F[1]]);for(let U=E;U<w;U++)X.supportsUniformBuffers||(Q=Q.replace(O,((U,X)=>X+"{X}"))),b+=Q.replace(N,U.toString())+"\n"}else X.supportsUniformBuffers||(b=b.replace(O,((U,X)=>X+"{X}"))),b=b.replace(N,U)}const F=[];for(const U of w){const X=U.split(z[0]);for(let U=0;U<X.length-1;U++)F.push(X[U]),F.push(b);F.push(X[X.length-1])}w=F,Q=Q||b.indexOf("#include<")>=0||b.indexOf("#include <")>=0}}u.length=0,E=w.join(""),Q?s(E.toString(),X,b):b(E)}const h={loadFile:(U,X,b,F,E,w)=>{throw(0,n.b)("FileTools")}}},11472:(U,X,b)=>{b.d(X,{d:()=>E,e:()=>w,i:()=>z,k:()=>Q,n:()=>q});var F=b(11428);b(11401);const E={};function w(U,X){return(arguments.length>2&&void 0!==arguments[2]?arguments[2]:"")+(X?X+"\n":"")+U}function Q(U,X,b,w,Q,z,q){const p=q||E.loadFile;if(p){return p(U,X,b,w,Q,z)}throw(0,F.b)("FileTools")}function z(U,X,b,F){if(U)return X?U.IS_NDC_HALF_ZRANGE="":delete U.IS_NDC_HALF_ZRANGE,b?U.USE_REVERSE_DEPTHBUFFER="":delete U.USE_REVERSE_DEPTHBUFFER,void(F?U.USE_EXACT_SRGB_CONVERSIONS="":delete U.USE_EXACT_SRGB_CONVERSIONS);{let U="";return X&&(U+="#define IS_NDC_HALF_ZRANGE"),b&&(U&&(U+="\n"),U+="#define USE_REVERSE_DEPTHBUFFER"),F&&(U&&(U+="\n"),U+="#define USE_EXACT_SRGB_CONVERSIONS"),U}}function q(U,X){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],F=arguments.length>3?arguments[3]:void 0;switch(U){case 3:{const U=(ArrayBuffer,new Int8Array(X));return F&&U.set(new Int8Array(F)),U}case 0:{const U=(ArrayBuffer,new Uint8Array(X));return F&&U.set(new Uint8Array(F)),U}case 4:{const U=X instanceof ArrayBuffer?new Int16Array(X):new Int16Array(b?X/2:X);return F&&U.set(new Int16Array(F)),U}case 5:case 8:case 9:case 10:case 2:{const U=X instanceof ArrayBuffer?new Uint16Array(X):new Uint16Array(b?X/2:X);return F&&U.set(new Uint16Array(F)),U}case 6:{const U=X instanceof ArrayBuffer?new Int32Array(X):new Int32Array(b?X/4:X);return F&&U.set(new Int32Array(F)),U}case 7:case 11:case 12:case 13:case 14:case 15:{const U=X instanceof ArrayBuffer?new Uint32Array(X):new Uint32Array(b?X/4:X);return F&&U.set(new Uint32Array(F)),U}case 1:{const U=X instanceof ArrayBuffer?new Float32Array(X):new Float32Array(b?X/4:X);return F&&U.set(new Float32Array(F)),U}}const E=(ArrayBuffer,new Uint8Array(X));return F&&E.set(new Uint8Array(F)),E}},11499:(U,X,b)=>{b.d(X,{c:()=>F});class F{static GetShadersRepository(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?F.ShadersRepository:F.ShadersRepositoryWGSL}static GetShadersStore(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?F.ShadersStore:F.ShadersStoreWGSL}static GetIncludesShadersStore(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?F.IncludesShadersStore:F.IncludesShadersStoreWGSL}}F.ShadersRepository="src/Shaders/",F.ShadersStore={},F.IncludesShadersStore={},F.ShadersRepositoryWGSL="src/ShadersWGSL/",F.ShadersStoreWGSL={},F.IncludesShadersStoreWGSL={}},11516:(U,X,b)=>{b.d(X,{c:()=>n,e:()=>N,g:()=>J,j:()=>a,l:()=>m,m:()=>O,n:()=>R,r:()=>p,t:()=>S,w:()=>q,y:()=>z});class F{constructor(){this._valueCache={},this.vertexCompilationError=null,this.fragmentCompilationError=null,this.programLinkError=null,this.programValidationError=null,this._isDisposed=!1}get isAsync(){return this.isParallelCompiled}get isReady(){return!!this.program&&(!this.isParallelCompiled||this.aX._isRenderingStateCompiled(this))}_handlesSpectorRebuildCallback(U){U&&this.program&&U(this.program)}setEngine(U){this.aX=U}_fillEffectInformation(U,X,b,F,E,w,Q,z){const q=this.aX;if(q.supportsUniformBuffers)for(const S in X)U.bindUniformBlock(S,X[S]);let p;for(this.aX.getUniforms(this,b).forEach(((U,X)=>{F[b[X]]=U})),this._uniforms=F,p=0;p<E.length;p++){null==U.getUniform(E[p])&&(E.splice(p,1),p--)}E.forEach(((U,X)=>{w[U]=X}));for(const S of q.getAttributes(this,Q))z.push(S)}dispose(){this._uniforms={},this._isDisposed=!0}_cacheMatrix(U,X){const b=this._valueCache[U],F=X.updateFlag;return(void 0===b||b!==F)&&(this._valueCache[U]=F,!0)}_cacheFloat2(U,X,b){let F=this._valueCache[U];if(!F||2!==F.length)return F=[X,b],this._valueCache[U]=F,!0;let E=!1;return F[0]!==X&&(F[0]=X,E=!0),F[1]!==b&&(F[1]=b,E=!0),E}_cacheFloat3(U,X,b,F){let E=this._valueCache[U];if(!E||3!==E.length)return E=[X,b,F],this._valueCache[U]=E,!0;let w=!1;return E[0]!==X&&(E[0]=X,w=!0),E[1]!==b&&(E[1]=b,w=!0),E[2]!==F&&(E[2]=F,w=!0),w}_cacheFloat4(U,X,b,F,E){let w=this._valueCache[U];if(!w||4!==w.length)return w=[X,b,F,E],this._valueCache[U]=w,!0;let Q=!1;return w[0]!==X&&(w[0]=X,Q=!0),w[1]!==b&&(w[1]=b,Q=!0),w[2]!==F&&(w[2]=F,Q=!0),w[3]!==E&&(w[3]=E,Q=!0),Q}setInt(U,X){const b=this._valueCache[U];void 0!==b&&b===X||this.aX.setInt(this._uniforms[U],X)&&(this._valueCache[U]=X)}setInt2(U,X,b){this._cacheFloat2(U,X,b)&&(this.aX.setInt2(this._uniforms[U],X,b)||(this._valueCache[U]=null))}setInt3(U,X,b,F){this._cacheFloat3(U,X,b,F)&&(this.aX.setInt3(this._uniforms[U],X,b,F)||(this._valueCache[U]=null))}setInt4(U,X,b,F,E){this._cacheFloat4(U,X,b,F,E)&&(this.aX.setInt4(this._uniforms[U],X,b,F,E)||(this._valueCache[U]=null))}setIntArray(U,X){this._valueCache[U]=null,this.aX.setIntArray(this._uniforms[U],X)}setIntArray2(U,X){this._valueCache[U]=null,this.aX.setIntArray2(this._uniforms[U],X)}setIntArray3(U,X){this._valueCache[U]=null,this.aX.setIntArray3(this._uniforms[U],X)}setIntArray4(U,X){this._valueCache[U]=null,this.aX.setIntArray4(this._uniforms[U],X)}setUInt(U,X){const b=this._valueCache[U];void 0!==b&&b===X||this.aX.setUInt(this._uniforms[U],X)&&(this._valueCache[U]=X)}setUInt2(U,X,b){this._cacheFloat2(U,X,b)&&(this.aX.setUInt2(this._uniforms[U],X,b)||(this._valueCache[U]=null))}setUInt3(U,X,b,F){this._cacheFloat3(U,X,b,F)&&(this.aX.setUInt3(this._uniforms[U],X,b,F)||(this._valueCache[U]=null))}setUInt4(U,X,b,F,E){this._cacheFloat4(U,X,b,F,E)&&(this.aX.setUInt4(this._uniforms[U],X,b,F,E)||(this._valueCache[U]=null))}setUIntArray(U,X){this._valueCache[U]=null,this.aX.setUIntArray(this._uniforms[U],X)}setUIntArray2(U,X){this._valueCache[U]=null,this.aX.setUIntArray2(this._uniforms[U],X)}setUIntArray3(U,X){this._valueCache[U]=null,this.aX.setUIntArray3(this._uniforms[U],X)}setUIntArray4(U,X){this._valueCache[U]=null,this.aX.setUIntArray4(this._uniforms[U],X)}setArray(U,X){this._valueCache[U]=null,this.aX.setArray(this._uniforms[U],X)}setArray2(U,X){this._valueCache[U]=null,this.aX.setArray2(this._uniforms[U],X)}setArray3(U,X){this._valueCache[U]=null,this.aX.setArray3(this._uniforms[U],X)}setArray4(U,X){this._valueCache[U]=null,this.aX.setArray4(this._uniforms[U],X)}setMatrices(U,X){X&&(this._valueCache[U]=null,this.aX.setMatrices(this._uniforms[U],X))}setMatrix(U,X){this._cacheMatrix(U,X)&&(this.aX.setMatrices(this._uniforms[U],X.Jb())||(this._valueCache[U]=null))}setMatrix3x3(U,X){this._valueCache[U]=null,this.aX.setMatrix3x3(this._uniforms[U],X)}setMatrix2x2(U,X){this._valueCache[U]=null,this.aX.setMatrix2x2(this._uniforms[U],X)}setFloat(U,X){const b=this._valueCache[U];void 0!==b&&b===X||this.aX.setFloat(this._uniforms[U],X)&&(this._valueCache[U]=X)}setVector2(U,X){this._cacheFloat2(U,X.x,X.y)&&(this.aX.setFloat2(this._uniforms[U],X.x,X.y)||(this._valueCache[U]=null))}setFloat2(U,X,b){this._cacheFloat2(U,X,b)&&(this.aX.setFloat2(this._uniforms[U],X,b)||(this._valueCache[U]=null))}setVector3(U,X){this._cacheFloat3(U,X.x,X.y,X.z)&&(this.aX.setFloat3(this._uniforms[U],X.x,X.y,X.z)||(this._valueCache[U]=null))}setFloat3(U,X,b,F){this._cacheFloat3(U,X,b,F)&&(this.aX.setFloat3(this._uniforms[U],X,b,F)||(this._valueCache[U]=null))}setVector4(U,X){this._cacheFloat4(U,X.x,X.y,X.z,X.w)&&(this.aX.setFloat4(this._uniforms[U],X.x,X.y,X.z,X.w)||(this._valueCache[U]=null))}setQuaternion(U,X){this._cacheFloat4(U,X.x,X.y,X.z,X.w)&&(this.aX.setFloat4(this._uniforms[U],X.x,X.y,X.z,X.w)||(this._valueCache[U]=null))}setFloat4(U,X,b,F,E){this._cacheFloat4(U,X,b,F,E)&&(this.aX.setFloat4(this._uniforms[U],X,b,F,E)||(this._valueCache[U]=null))}setColor3(U,X){this._cacheFloat3(U,X.r,X.g,X.b)&&(this.aX.setFloat3(this._uniforms[U],X.r,X.g,X.b)||(this._valueCache[U]=null))}setColor4(U,X,b){this._cacheFloat4(U,X.r,X.g,X.b,b)&&(this.aX.setFloat4(this._uniforms[U],X.r,X.g,X.b,b)||(this._valueCache[U]=null))}setDirectColor4(U,X){this._cacheFloat4(U,X.r,X.g,X.b,X.a)&&(this.aX.setFloat4(this._uniforms[U],X.r,X.g,X.b,X.a)||(this._valueCache[U]=null))}_getVertexShaderCode(){return this.vertexShader?this.aX._getShaderSource(this.vertexShader):null}_getFragmentShaderCode(){return this.fragmentShader?this.aX._getShaderSource(this.fragmentShader):null}}var E=b(11472);const w=new WeakMap,Q={_webGLVersion:2,cachedPipelines:{}};function z(U){let X=w.get(U);if(!X){if(!U)return Q;X={_webGLVersion:U.TEXTURE_BINDING_3D?2:1,_context:U,parallelShaderCompile:U.getExtension("KHR_parallel_shader_compile")||void 0,cachedPipelines:{}},w.set(U,X)}return X}function q(U){w.delete(U)}function p(U,X,b,F,E,w){const Q=z(F);w||(w=Q._createShaderProgramInjection??n);return w(U,I(X,"vertex",F,Q._contextWasLost),I(b,"fragment",F,Q._contextWasLost),F,E,Q.validateShaderPrograms)}function S(U,X,b,F,E){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,Q=arguments.length>6?arguments[6]:void 0;const q=z(E);Q||(Q=q._createShaderProgramInjection??n);const p=q._webGLVersion>1?"#version 300 es\n#define WEBGL2 \n":"";return Q(U,x(X,"vertex",F,p,E,q._contextWasLost),x(b,"fragment",F,p,E,q._contextWasLost),E,w,q.validateShaderPrograms)}function R(U,X){const b=new F,E=z(U);return E.parallelShaderCompile&&!E.disableParallelShaderCompile&&(b.isParallelCompiled=!0),b.context=E._context,b}function n(U,X,b,F){let E=arguments.length>5?arguments[5]:void 0;const w=F.createProgram();if(U.program=w,!w)throw new Error("Unable to create program");return F.attachShader(w,X),F.attachShader(w,b),F.linkProgram(w),U.context=F,U.vertexShader=X,U.fragmentShader=b,U.isParallelCompiled||J(U,F,E),w}function a(U,X,b){const F=U;if(F._isDisposed)return!1;const E=z(X);return!!(E&&E.parallelShaderCompile&&E.parallelShaderCompile.COMPLETION_STATUS_KHR&&F.program&&X.getProgramParameter(F.program,E.parallelShaderCompile.COMPLETION_STATUS_KHR))&&(J(F,X,b),!0)}function J(U,X,b){const F=U.context,E=U.vertexShader,w=U.fragmentShader,Q=U.program;if(!F.getProgramParameter(Q,F.LINK_STATUS)){if(!X.getShaderParameter(E,X.COMPILE_STATUS)){const b=X.getShaderInfoLog(E);if(b)throw U.vertexCompilationError=b,new Error("VERTEX SHADER "+b)}if(!X.getShaderParameter(w,X.COMPILE_STATUS)){const b=X.getShaderInfoLog(w);if(b)throw U.fragmentCompilationError=b,new Error("FRAGMENT SHADER "+b)}const b=F.getProgramInfoLog(Q);if(b)throw U.programLinkError=b,new Error(b)}if(b){F.validateProgram(Q);if(!F.getProgramParameter(Q,F.VALIDATE_STATUS)){const X=F.getProgramInfoLog(Q);if(X)throw U.programValidationError=X,new Error(X)}}F.deleteShader(E),F.deleteShader(w),U.vertexShader=void 0,U.fragmentShader=void 0,U.onCompiled&&(U.onCompiled(),U.onCompiled=void 0)}function m(U,X,b,F,E,w,Q,q,R){let n=arguments.length>10?arguments[10]:void 0,a=arguments.length>11?arguments[11]:void 0,J=arguments.length>12?arguments[12]:void 0;const m=z(U.context);a||(a=m.createRawShaderProgramInjection??p),J||(J=m.createShaderProgramInjection??S);const x=U;x.program=F?a(x,X,b,x.context,R):J(x,X,b,q,x.context,R),x.program.__SPECTOR_rebuildProgram=Q,n()}function x(U,X,b,F,w,Q){return I((0,E.e)(U,b,F),X,w,Q)}function I(U,X,b,F){const E=b.createShader("vertex"===X?b.VERTEX_SHADER:b.FRAGMENT_SHADER);if(!E){let U=b.NO_ERROR,E=b.NO_ERROR;for(;(E=b.getError())!==b.NO_ERROR;)U=E;throw new Error(`Something went wrong while creating a gl ${X} shader object. gl error=${U}, gl isContextLost=${b.isContextLost()}, _contextWasLost=${F}`)}return b.shaderSource(E,U),b.compileShader(E),E}function O(U,X){X.useProgram(U)}function N(U,X){const b=U;if(!b.isParallelCompiled)return void X(U);const F=b.onCompiled;b.onCompiled=()=>{null===F||void 0===F||F(),X(U)}}},11507:(U,X,b)=>{b.d(X,{e:()=>R,g:()=>a,h:()=>p,k:()=>S});var F=b(11401),E=b(11516),w=b(11499),Q=b(11408),z=b(11469),q=b(11472);function p(U,X){return(0,E.y)(X).cachedPipelines[U]}function S(U){const X=U._name,b=U.context;if(X&&b){const U=(0,E.y)(b),F=U.cachedPipelines[X];null===F||void 0===F||F.dispose(),delete U.cachedPipelines[X]}}function R(U,X,b,E,w,Q,q){let p,S;const R=(0,F.m)()?null===Q||void 0===Q?void 0:Q.getHostDocument():null;p="string"===typeof X?X:X.vertexSource?"source:"+X.vertexSource:X.vertexElement?(null===R||void 0===R?void 0:R.getElementById(X.vertexElement))||X.vertexElement:X.vertex||X,S="string"===typeof X?X:X.fragmentSource?"source:"+X.fragmentSource:X.fragmentElement?(null===R||void 0===R?void 0:R.getElementById(X.fragmentElement))||X.fragmentElement:X.fragment||X;const a=[void 0,void 0],J=()=>{if(a[0]&&a[1]){U.isFragment=!0;const[F,p]=a;(0,z.n)(p,U,((Q,p)=>{q&&(q._fragmentSourceCodeBeforeMigration=p),b&&(Q=b("fragment",Q));const S=(0,z.e)(F,Q,U);U=null;const R=function(U,X,b,F){if(b){return{vertexSourceCode:(1===F?"//":"")+"#define SHADER_NAME vertex:"+(b.vertexElement||b.vertex||b.spectorName||b)+"\n"+U,fragmentSourceCode:(1===F?"//":"")+"#define SHADER_NAME fragment:"+(b.fragmentElement||b.fragment||b.spectorName||b)+"\n"+X}}return{vertexSourceCode:U,fragmentSourceCode:X}}(S.vertexCode,S.fragmentCode,X,w);null===E||void 0===E||E(R.vertexSourceCode,R.fragmentSourceCode)}),Q)}};n(p,"Vertex","",(X=>{(0,z.h)(U),(0,z.n)(X,U,((U,F)=>{q&&(q._rawVertexSourceCode=X,q._vertexSourceCodeBeforeMigration=F),b&&(U=b("vertex",U)),a[0]=U,J()}),Q)}),w),n(S,"Fragment","Pixel",(U=>{q&&(q._rawFragmentSourceCode=U),a[1]=U,J()}),w)}function n(U,X,b,E,Q,z){if("undefined"!==typeof HTMLElement&&U instanceof HTMLElement){return void E((0,F.c)(U))}if("source:"===U.substring(0,7))return void E(U.substring(7));if("base64:"===U.substring(0,7)){return void E(window.atob(U.substring(7)))}const p=w.c.GetShadersStore(Q);if(p[U+X+"Shader"])return void E(p[U+X+"Shader"]);if(b&&p[U+b+"Shader"])return void E(p[U+b+"Shader"]);let S;if(S="."===U[0]||"/"===U[0]||U.indexOf("http")>-1?U:w.c.GetShadersRepository(Q)+U,!(z=z||q.k))throw new Error("loadFileInjection is not defined");z(S+"."+X.toLowerCase()+".fx",E)}const a=(U,X,b,F)=>{try{const w=U.context?(0,E.y)(U.context):null;w&&(w.disableParallelShaderCompile=U.disableParallelCompilation);const Q=U.existingPipelineContext||X(U.shaderProcessingContext);return Q._name=U.name,U.name&&w&&(w.cachedPipelines[U.name]=Q),b(Q,U.vertex,U.fragment,!!U.createAsRaw,"","",U.rebuildRebind,U.defines,U.transformFeedbackVaryings,"",(()=>{F(Q,(()=>{var X;null===(X=U.onRenderingStateCompiled)||void 0===X||X.call(U,Q)}))})),Q}catch(w){throw Q.e.Error("Error compiling effect"),w}}},11490:(U,X,b)=>{b.r(X),b.d(X,{Effect:()=>q});var F=b(11392),E=b(11408),w=b(11499),Q=b(11507),z=b(11481);class q{static get ShadersRepository(){return w.c.ShadersRepository}static set ShadersRepository(U){w.c.ShadersRepository=U}get R(){return this._isDisposed}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new F.e),this._onBindObservable}get shaderLanguage(){return this._shaderLanguage}constructor(U,X,b){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,w=arguments.length>4?arguments[4]:void 0,z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,p=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,R=arguments.length>8&&void 0!==arguments[8]?arguments[8]:null,n=arguments.length>9?arguments[9]:void 0,a=arguments.length>10&&void 0!==arguments[10]?arguments[10]:"",J=arguments.length>11&&void 0!==arguments[11]?arguments[11]:0,m=arguments.length>12?arguments[12]:void 0;this.defines="",this.onCompiled=null,this.onError=null,this.onBind=null,this.uniqueId=0,this.onCompileObservable=new F.e,this.onErrorObservable=new F.e,this._onBindObservable=null,this._isDisposed=!1,this._refCount=1,this._bonesComputationForcedToCPU=!1,this._uniformBuffersNames={},this._multiTarget=!1,this._samplers={},this._isReady=!1,this._compilationError="",this._allFallbacksProcessed=!1,this._uniforms={},this._key="",this._fallbacks=null,this._vertexSourceCodeOverride="",this._fragmentSourceCodeOverride="",this._transformFeedbackVaryings=null,this._disableParallelShaderCompilation=!1,this._pipelineContext=null,this._vertexSourceCode="",this._fragmentSourceCode="",this._vertexSourceCodeBeforeMigration="",this._fragmentSourceCodeBeforeMigration="",this._rawVertexSourceCode="",this._rawFragmentSourceCode="",this._processCodeAfterIncludes=void 0,this._processFinalCode=null,this.name=U,this._key=a;const x=this._key.replace(/\r/g,"").replace(/\n/g,"|");let I;if(X.attributes){const U=X;if(this._engine=b,this._attributesNames=U.attributes,this._uniformsNames=U.uniformsNames.concat(U.samplers),this._samplerList=U.samplers.slice(),this.defines=U.defines,this.onError=U.onError,this.onCompiled=U.onCompiled,this._fallbacks=U.fallbacks,this._indexParameters=U.indexParameters,this._transformFeedbackVaryings=U.transformFeedbackVaryings||null,this._multiTarget=!!U.multiTarget,this._shaderLanguage=U.shaderLanguage??0,this._disableParallelShaderCompilation=!!U.disableParallelShaderCompilation,U.uniformBuffersNames){this._uniformBuffersNamesList=U.uniformBuffersNames.slice();for(let X=0;X<U.uniformBuffersNames.length;X++)this._uniformBuffersNames[U.uniformBuffersNames[X]]=X}this._processFinalCode=U.processFinalCode??null,this._processCodeAfterIncludes=U.processCodeAfterIncludes??void 0,m=U.extraInitializationsAsync,I=U.existingPipelineContext}else this._engine=w,this.defines=null==z?"":z,this._uniformsNames=b.concat(E),this._samplerList=E?E.slice():[],this._attributesNames=X,this._uniformBuffersNamesList=[],this._shaderLanguage=J,this.onError=R,this.onCompiled=S,this._indexParameters=n,this._fallbacks=p;"WEBGL2"===this._engine.shaderPlatformName&&(I=(0,Q.h)(x,this._engine._gl)??I),this._attributeLocationByName={},this.uniqueId=q._UniqueIdSeed++,I?(this._pipelineContext=I,this._pipelineContext.setEngine(this._engine),this._onRenderingStateCompiled(this._pipelineContext),this._pipelineContext.program&&(this._pipelineContext.program.__SPECTOR_rebuildProgram=this._rebuildProgram.bind(this))):this._processShaderCodeAsync(null,!1,null,m),this._engine.onReleaseEffectsObservable.addOnce((()=>{this.R||this.dispose(!0)}))}async _processShaderCodeAsync(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,X=arguments.length>1&&void 0!==arguments[1]&&arguments[1],b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,F=arguments.length>3?arguments[3]:void 0;F&&await F(),this._processingContext=b||this._engine._getShaderProcessingContext(this._shaderLanguage,!1);const E={defines:this.defines.split("\n"),indexParameters:this._indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:U??this._engine._getShaderProcessor(this._shaderLanguage),supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:w.c.GetShadersRepository(this._shaderLanguage),includesShadersStore:w.c.GetIncludesShadersStore(this._shaderLanguage),version:(100*this._engine.version).toString(),platformName:this._engine.shaderPlatformName,processingContext:this._processingContext,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:this._processCodeAfterIncludes};(0,Q.e)(E,this.name,this._processFinalCode,((U,b)=>{this._vertexSourceCode=U,this._fragmentSourceCode=b,this._prepareEffect(X)}),this._shaderLanguage,this._engine,this)}get key(){return this._key}isReady(){try{return this._isReadyInternal()}catch{return!1}}_isReadyInternal(){return!!this._engine.R||(!!this._isReady||!!this._pipelineContext&&this._pipelineContext.isReady)}getEngine(){return this._engine}getPipelineContext(){return this._pipelineContext}getAttributesNames(){return this._attributesNames}getAttributeLocation(U){return this._attributes[U]}getAttributeLocationByName(U){return this._attributeLocationByName[U]}getAttributesCount(){return this._attributes.length}getUniformIndex(U){return this._uniformsNames.indexOf(U)}getUniform(U){return this._uniforms[U]}getSamplers(){return this._samplerList}getUniformNames(){return this._uniformsNames}getUniformBuffersNames(){return this._uniformBuffersNamesList}getIndexParameters(){return this._indexParameters}getCompilationError(){return this._compilationError}allFallbacksProcessed(){return this._allFallbacksProcessed}async whenCompiledAsync(){return await new Promise((U=>{this.executeWhenCompiled(U)}))}executeWhenCompiled(U){this.isReady()?U(this):(this.onCompileObservable.add((X=>{U(X)})),this._pipelineContext&&!this._pipelineContext.isAsync||this._checkIsReady(null))}_checkIsReady(U){(0,z.g)((()=>this._isReadyInternal()||this._isDisposed),(()=>{}),(X=>{this._processCompilationErrors(X,U)}),16,12e4,!0,` - Effect: ${"string"===typeof this.name?this.name:this.key}`)}get vertexSourceCode(){var U;return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._vertexSourceCodeOverride:(null===(U=this._pipelineContext)||void 0===U?void 0:U._getVertexShaderCode())??this._vertexSourceCode}get fragmentSourceCode(){var U;return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._fragmentSourceCodeOverride:(null===(U=this._pipelineContext)||void 0===U?void 0:U._getFragmentShaderCode())??this._fragmentSourceCode}get vertexSourceCodeBeforeMigration(){return this._vertexSourceCodeBeforeMigration}get fragmentSourceCodeBeforeMigration(){return this._fragmentSourceCodeBeforeMigration}get rawVertexSourceCode(){return this._rawVertexSourceCode}get rawFragmentSourceCode(){return this._rawFragmentSourceCode}getPipelineGenerationOptions(){return{platformName:this._engine.shaderPlatformName,shaderLanguage:this._shaderLanguage,shaderNameOrContent:this.name,key:this._key,defines:this.defines.split("\n"),addGlobalDefines:!1,extendedProcessingOptions:{indexParameters:this._indexParameters,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,supportsUniformBuffers:this._engine.supportsUniformBuffers},extendedCreatePipelineOptions:{transformFeedbackVaryings:this._transformFeedbackVaryings,createAsRaw:!(!this._vertexSourceCodeOverride||!this._fragmentSourceCodeOverride)}}}_rebuildProgram(U,X,b,F){this._isReady=!1,this._vertexSourceCodeOverride=U,this._fragmentSourceCodeOverride=X,this.onError=(U,X)=>{F&&F(X)},this.onCompiled=()=>{var U,X;const F=this.getEngine().scenes;if(F)for(let b=0;b<F.length;b++)F[b].markAllMaterialsAsDirty(127);null===(U=(X=this._pipelineContext)._handlesSpectorRebuildCallback)||void 0===U||U.call(X,b)},this._fallbacks=null,this._prepareEffect()}_onRenderingStateCompiled(U){if(this._pipelineContext=U,this._pipelineContext.setEngine(this._engine),this._attributes=[],this._pipelineContext._fillEffectInformation(this,this._uniformBuffersNames,this._uniformsNames,this._uniforms,this._samplerList,this._samplers,this._attributesNames,this._attributes),this._attributesNames)for(let X=0;X<this._attributesNames.length;X++){const U=this._attributesNames[X];this._attributeLocationByName[U]=this._attributes[X]}this._engine.bindSamplers(this),this._compilationError="",this._isReady=!0,this.onCompiled&&this.onCompiled(this),this.onCompileObservable.notifyObservers(this),this.onCompileObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh(),q.AutomaticallyClearCodeCache&&this.clearCodeCache()}_prepareEffect(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=this._pipelineContext;this._isReady=!1;try{const b=!(!this._vertexSourceCodeOverride||!this._fragmentSourceCodeOverride),F=b?null:this.defines,E=b?this._vertexSourceCodeOverride:this._vertexSourceCode,w=b?this._fragmentSourceCodeOverride:this._fragmentSourceCode,z=this._engine;this._pipelineContext=(0,Q.g)({existingPipelineContext:U?X:null,vertex:E,fragment:w,context:"WEBGL2"===z.shaderPlatformName||"WEBGL1"===z.shaderPlatformName?z._gl:void 0,rebuildRebind:(U,X,b,F)=>this._rebuildProgram(U,X,b,F),defines:F,transformFeedbackVaryings:this._transformFeedbackVaryings,name:this._key.replace(/\r/g,"").replace(/\n/g,"|"),createAsRaw:b,disableParallelCompilation:this._disableParallelShaderCompilation,shaderProcessingContext:this._processingContext,onRenderingStateCompiled:b=>{X&&!U&&this._engine._deletePipelineContext(X),b&&this._onRenderingStateCompiled(b)}},this._engine.createPipelineContext.bind(this._engine),this._engine._preparePipelineContextAsync.bind(this._engine),this._engine._executeWhenRenderingStateIsCompiled.bind(this._engine)),this._pipelineContext.isAsync&&this._checkIsReady(X)}catch(b){this._processCompilationErrors(b,X)}}_getShaderCodeAndErrorLine(U,X,b){const F=b?/FRAGMENT SHADER ERROR: 0:(\d+?):/:/VERTEX SHADER ERROR: 0:(\d+?):/;let E=null;if(X&&U){const w=X.match(F);if(w&&2===w.length){const X=parseInt(w[1]),F=U.split("\n",-1);F.length>=X&&(E=`Offending line [${X}] in ${b?"fragment":"vertex"} code: ${F[X-1]}`)}}return[U,E]}_processCompilationErrors(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;this._compilationError=U.message;const b=this._attributesNames,F=this._fallbacks;if(E.e.Error("Unable to compile effect:"),E.e.Error(`Uniforms: ${this._uniformsNames.join(" ")}`),E.e.Error(`Attributes: ${b.join(" ")}`),E.e.Error("Defines:\n"+this.defines),q.LogShaderCodeOnCompilationError){var w,Q;let U=null,X=null,b=null;var z;if(null!==(w=this._pipelineContext)&&void 0!==w&&w._getVertexShaderCode()&&([b,U]=this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(),this._compilationError,!1),b&&(E.e.Error("Vertex code:"),E.e.Error(b))),null!==(Q=this._pipelineContext)&&void 0!==Q&&Q._getFragmentShaderCode())[b,X]=this._getShaderCodeAndErrorLine(null===(z=this._pipelineContext)||void 0===z?void 0:z._getFragmentShaderCode(),this._compilationError,!0),b&&(E.e.Error("Fragment code:"),E.e.Error(b));U&&E.e.Error(U),X&&E.e.Error(X)}E.e.Error("Error: "+this._compilationError);const p=()=>{this.onError&&this.onError(this,this._compilationError),this.onErrorObservable.notifyObservers(this),this._engine.onEffectErrorObservable.notifyObservers({effect:this,errors:this._compilationError})};X&&(this._pipelineContext=X,this._isReady=!0,p()),F?(this._pipelineContext=null,F.hasMoreFallbacks?(this._allFallbacksProcessed=!1,E.e.Error("Trying next fallback."),this.defines=F.reduce(this.defines,this),this._prepareEffect()):(this._allFallbacksProcessed=!0,p(),this.onErrorObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh())):(this._allFallbacksProcessed=!0,X||p())}get isSupported(){return""===this._compilationError}_bindTexture(U,X){this._engine._bindTexture(this._samplers[U],X,U)}setTexture(U,X){this._engine.setTexture(this._samplers[U],this._uniforms[U],X,U)}setTextureArray(U,X){const b=U+"Ex";if(-1===this._samplerList.indexOf(b+"0")){const F=this._samplerList.indexOf(U);for(let U=1;U<X.length;U++){const X=b+(U-1).toString();this._samplerList.splice(F+U,0,X)}let E=0;for(const U of this._samplerList)this._samplers[U]=E,E+=1}this._engine.setTextureArray(this._samplers[U],this._uniforms[U],X,U)}bindUniformBuffer(U,X){const b=this._uniformBuffersNames[X];void 0===b||q._BaseCache[b]===U&&this._engine._features.useUBOBindingCache||(q._BaseCache[b]=U,this._engine.bindUniformBufferBase(U,b,X))}bindUniformBlock(U,X){this._engine.bindUniformBlock(this._pipelineContext,U,X)}setInt(U,X){return this._pipelineContext.setInt(U,X),this}setInt2(U,X,b){return this._pipelineContext.setInt2(U,X,b),this}setInt3(U,X,b,F){return this._pipelineContext.setInt3(U,X,b,F),this}setInt4(U,X,b,F,E){return this._pipelineContext.setInt4(U,X,b,F,E),this}setIntArray(U,X){return this._pipelineContext.setIntArray(U,X),this}setIntArray2(U,X){return this._pipelineContext.setIntArray2(U,X),this}setIntArray3(U,X){return this._pipelineContext.setIntArray3(U,X),this}setIntArray4(U,X){return this._pipelineContext.setIntArray4(U,X),this}setUInt(U,X){return this._pipelineContext.setUInt(U,X),this}setUInt2(U,X,b){return this._pipelineContext.setUInt2(U,X,b),this}setUInt3(U,X,b,F){return this._pipelineContext.setUInt3(U,X,b,F),this}setUInt4(U,X,b,F,E){return this._pipelineContext.setUInt4(U,X,b,F,E),this}setUIntArray(U,X){return this._pipelineContext.setUIntArray(U,X),this}setUIntArray2(U,X){return this._pipelineContext.setUIntArray2(U,X),this}setUIntArray3(U,X){return this._pipelineContext.setUIntArray3(U,X),this}setUIntArray4(U,X){return this._pipelineContext.setUIntArray4(U,X),this}setFloatArray(U,X){return this._pipelineContext.setArray(U,X),this}setFloatArray2(U,X){return this._pipelineContext.setArray2(U,X),this}setFloatArray3(U,X){return this._pipelineContext.setArray3(U,X),this}setFloatArray4(U,X){return this._pipelineContext.setArray4(U,X),this}setArray(U,X){return this._pipelineContext.setArray(U,X),this}setArray2(U,X){return this._pipelineContext.setArray2(U,X),this}setArray3(U,X){return this._pipelineContext.setArray3(U,X),this}setArray4(U,X){return this._pipelineContext.setArray4(U,X),this}setMatrices(U,X){return this._pipelineContext.setMatrices(U,X),this}setMatrix(U,X){return this._pipelineContext.setMatrix(U,X),this}setMatrix3x3(U,X){return this._pipelineContext.setMatrix3x3(U,X),this}setMatrix2x2(U,X){return this._pipelineContext.setMatrix2x2(U,X),this}setFloat(U,X){return this._pipelineContext.setFloat(U,X),this}setBool(U,X){return this._pipelineContext.setInt(U,X?1:0),this}setVector2(U,X){return this._pipelineContext.setVector2(U,X),this}setFloat2(U,X,b){return this._pipelineContext.setFloat2(U,X,b),this}setVector3(U,X){return this._pipelineContext.setVector3(U,X),this}setFloat3(U,X,b,F){return this._pipelineContext.setFloat3(U,X,b,F),this}setVector4(U,X){return this._pipelineContext.setVector4(U,X),this}setQuaternion(U,X){return this._pipelineContext.setQuaternion(U,X),this}setFloat4(U,X,b,F,E){return this._pipelineContext.setFloat4(U,X,b,F,E),this}setColor3(U,X){return this._pipelineContext.setColor3(U,X),this}setColor4(U,X,b){return this._pipelineContext.setColor4(U,X,b),this}setDirectColor4(U,X){return this._pipelineContext.setDirectColor4(U,X),this}clearCodeCache(){this._vertexSourceCode="",this._fragmentSourceCode="",this._fragmentSourceCodeBeforeMigration="",this._vertexSourceCodeBeforeMigration=""}dispose(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])this._refCount=0;else{if(q.PersistentMode)return;this._refCount--}this._refCount>0||this._isDisposed||(this._pipelineContext&&(0,Q.k)(this._pipelineContext),this._engine._releaseEffect(this),this.clearCodeCache(),this._isDisposed=!0)}static RegisterShader(U,X,b){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;X&&(w.c.GetShadersStore(F)[`${U}PixelShader`]=X),b&&(w.c.GetShadersStore(F)[`${U}VertexShader`]=b)}static ResetCache(){q._BaseCache={}}}q.LogShaderCodeOnCompilationError=!0,q.PersistentMode=!1,q.AutomaticallyClearCodeCache=!1,q._UniqueIdSeed=0,q._BaseCache={},q.ShadersStore=w.c.ShadersStore,q.IncludesShadersStore=w.c.IncludesShadersStore},11428:(U,X,b)=>{b.d(X,{b:()=>E});const F={};function E(U){if(!(arguments.length>1&&void 0!==arguments[1]&&arguments[1])||!F[U])return F[U]=!0,`${U} needs to be imported before as it contains a side-effect required by your code.`}},11401:(U,X,b)=>{function F(){return"undefined"!==typeof window}function E(){return"undefined"!==typeof navigator}function w(){return"undefined"!==typeof document}function Q(U){let X="",b=U.firstChild;for(;b;)3===b.nodeType&&(X+=b.textContent),b=b.nextSibling;return X}b.d(X,{c:()=>Q,e:()=>w,i:()=>E,m:()=>F})},11408:(U,X,b)=>{b.d(X,{e:()=>F});class F{static _CheckLimit(U,X){let b=F._LogLimitOutputs[U];return b?b.current++:(b={limit:X,current:1},F._LogLimitOutputs[U]=b),b.current<=b.limit}static _GenerateLimitMessage(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const b=F._LogLimitOutputs[U];if(!b||!F.MessageLimitReached)return;const E=this._Levels[X];b.current===b.limit&&F[E.name](F.MessageLimitReached.replace(/%LIMIT%/g,""+b.limit).replace(/%TYPE%/g,E.name??""))}static _AddLogEntry(U){F._LogCache=U+F._LogCache,F.OnNewCacheEntry&&F.OnNewCacheEntry(U)}static _FormatMessage(U){const X=U=>U<10?"0"+U:""+U,b=new Date;return"["+X(b.getHours())+":"+X(b.getMinutes())+":"+X(b.getSeconds())+"]: "+U}static _LogDisabled(U,X){}static _LogEnabled(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,X=arguments.length>1?arguments[1]:void 0,b=arguments.length>2?arguments[2]:void 0;const E=Array.isArray(X)?X[0]:X;if(void 0!==b&&!F._CheckLimit(E,b))return;const w=F._FormatMessage(E),Q=this._Levels[U],z=Array.isArray(X)?X.slice(1):[];Q.logFunc&&Q.logFunc("BJS - "+w,...z);const q=`<div style='color:${Q.color}'>${w}</div><br>`;F._AddLogEntry(q),F._GenerateLimitMessage(E,U)}static get LogCache(){return F._LogCache}static ClearLogCache(){F._LogCache="",F._LogLimitOutputs={},F.errorsCount=0}static set LogLevels(U){F.Log=F._LogDisabled,F.Warn=F._LogDisabled,F.Error=F._LogDisabled;const X=[F.MessageLogLevel,F.WarningLogLevel,F.ErrorLogLevel];for(const b of X)if((U&b)===b){const U=this._Levels[b];F[U.name]=F._LogEnabled.bind(F,b)}}}F.NoneLogLevel=0,F.MessageLogLevel=1,F.WarningLogLevel=2,F.ErrorLogLevel=4,F.AllLogLevel=7,F.MessageLimitReached="Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.",F._LogCache="",F._LogLimitOutputs={},F._Levels=[{},{color:"white",logFunc:console.log,name:"Log"},{color:"orange",logFunc:console.warn,name:"Warn"},{},{color:"red",logFunc:console.error,name:"Error"}],F.errorsCount=0,F.Log=F._LogEnabled.bind(F,F.MessageLogLevel),F.Warn=F._LogEnabled.bind(F,F.WarningLogLevel),F.Error=F._LogEnabled.bind(F,F.ErrorLogLevel)},11392:(U,X,b)=>{b.d(X,{e:()=>Q});const F="undefined"!==typeof WeakRef;class E{constructor(U){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1],b=arguments.length>2?arguments[2]:void 0,F=arguments.length>3?arguments[3]:void 0;this.initialize(U,X,b,F)}initialize(U){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1],b=arguments.length>2?arguments[2]:void 0,F=arguments.length>3?arguments[3]:void 0;return this.mask=U,this.skipNextObservers=X,this.target=b,this.currentTarget=F,this}}class w{constructor(U,X){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this.callback=U,this.mask=X,this.scope=b,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this._remove&&this._remove(U)}}class Q{static FromPromise(U,X){const b=new Q;return U.then((U=>{b.notifyObservers(U)})).catch((U=>{if(!X)throw U;X.notifyObservers(U)})),b}get observers(){return this._observers}constructor(U){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.notifyIfTriggered=X,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new E(0),U&&(this._onObserverAdded=U)}add(U){let X=arguments.length>2&&void 0!==arguments[2]&&arguments[2],b=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!U)return null;const E=new w(U,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null);E.unregisterOnNextCall=b,X?this._observers.unshift(E):this._observers.push(E),this._onObserverAdded&&this._onObserverAdded(E),this._hasNotified&&this.notifyIfTriggered&&void 0!==this._lastNotifiedValue&&this.notifyObserver(E,this._lastNotifiedValue);const Q=F?new WeakRef(this):{deref:()=>this};return E._remove=function(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=Q.deref();X&&(U?X.remove(E):X._remove(E))},E}addOnce(U){return this.add(U,void 0,void 0,void 0,!0)}remove(U){if(!U)return!1;U._remove=null;return-1!==this._observers.indexOf(U)&&(this._deferUnregister(U),!0)}removeCallback(U,X){for(let b=0;b<this._observers.length;b++){const F=this._observers[b];if(!F._willBeUnregistered&&(F.callback===U&&(!X||X===F.scope)))return this._deferUnregister(F),!0}return!1}_deferUnregister(U){U._willBeUnregistered||(this._numObserversMarkedAsDeleted++,U.unregisterOnNextCall=!1,U._willBeUnregistered=!0,setTimeout((()=>{this._remove(U)}),0))}_remove(U){let X=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!U)return!1;const b=this._observers.indexOf(U);return-1!==b&&(X&&this._numObserversMarkedAsDeleted--,this._observers.splice(b,1),!0)}makeObserverTopPriority(U){this._remove(U,!1),this._observers.unshift(U)}makeObserverBottomPriority(U){this._remove(U,!1),this._observers.push(U)}notifyObservers(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,b=arguments.length>2?arguments[2]:void 0,F=arguments.length>3?arguments[3]:void 0,E=arguments.length>4?arguments[4]:void 0;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=U),!this._observers.length)return!0;const w=this._eventState;w.mask=X,w.target=b,w.currentTarget=F,w.skipNextObservers=!1,w.lastReturnValue=U,w.userInfo=E;for(const Q of this._observers)if(!Q._willBeUnregistered&&(Q.mask&X&&(Q.unregisterOnNextCall&&this._deferUnregister(Q),Q.scope?w.lastReturnValue=Q.callback.apply(Q.scope,[U,w]):w.lastReturnValue=Q.callback(U,w)),w.skipNextObservers))return!1;return!0}notifyObserver(U,X){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=X),U._willBeUnregistered)return;const F=this._eventState;F.mask=b,F.skipNextObservers=!1,U.unregisterOnNextCall&&this._deferUnregister(U),U.callback(X,F)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const U=this._observers.pop();U&&(U._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const U=new Q;return U._observers=this._observers.slice(0),U}hasSpecificMask(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;for(const X of this._observers)if(X.mask&U||X.mask===U)return!0;return!1}}},11481:(U,X,b)=>{b.d(X,{c:()=>E,g:()=>Q});let F=[];class E{static SetImmediate(U){0===F.length&&setTimeout((()=>{const U=F;F=[];for(const X of U)X()}),1),F.push(U)}}function w(U,X,b){try{if(U())return X(),!0}catch(F){return null===b||void 0===b||b(F),!0}return!1}const Q=function(U,X,b){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:16,E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:3e4,Q=arguments.length>6?arguments[6]:void 0;if((!(arguments.length>5&&void 0!==arguments[5])||arguments[5])&&w(U,X,b))return null;const z=setInterval((()=>{w(U,X,b)?clearInterval(z):(E-=F,E<0&&(clearInterval(z),null===b||void 0===b||b(new Error("Operation timed out after maximum retries. "+(Q||"")),!0)))}),F);return()=>clearInterval(z)}}}]);