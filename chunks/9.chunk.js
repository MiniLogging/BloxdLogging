"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[9],{12855:(I,x,L)=>{L.d(x,{e:()=>f,i:()=>Z,n:()=>t,k:()=>u,o:()=>A});class F{constructor(){this.children=[]}isValid(I){return!0}process(I,x,L){let F="";if(this.line){let L=this.line;const W=x.processor;if(W){var X,G,Y,p,B,l;W.lineProcessor&&(L=W.lineProcessor(L,x.isFragment,x.processingContext));const F=(null===(X=x.processor)||void 0===X?void 0:X.attributeKeywordName)??"attribute",Q=x.isFragment&&null!==(G=x.processor)&&void 0!==G&&G.varyingFragmentKeywordName?null===(Y=x.processor)||void 0===Y?void 0:Y.varyingFragmentKeywordName:!x.isFragment&&null!==(p=x.processor)&&void 0!==p&&p.varyingVertexKeywordName?null===(B=x.processor)||void 0===B?void 0:B.varyingVertexKeywordName:"varying";if(!x.isFragment&&W.attributeProcessor&&this.line.startsWith(F))L=W.attributeProcessor(this.line,I,x.processingContext);else if(W.varyingProcessor&&(null!==(l=W.varyingCheck)&&void 0!==l&&l.call(W,this.line,x.isFragment)||!W.varyingCheck&&this.line.startsWith(Q)))L=W.varyingProcessor(this.line,x.isFragment,I,x.processingContext);else if(W.uniformProcessor&&W.uniformRegexp&&W.uniformRegexp.test(this.line))x.lookForClosingBracketForUniformBuffer||(L=W.uniformProcessor(this.line,x.isFragment,I,x.processingContext));else if(W.uniformBufferProcessor&&W.uniformBufferRegexp&&W.uniformBufferRegexp.test(this.line))x.lookForClosingBracketForUniformBuffer||(L=W.uniformBufferProcessor(this.line,x.isFragment,x.processingContext),x.lookForClosingBracketForUniformBuffer=!0);else if(W.textureProcessor&&W.textureRegexp&&W.textureRegexp.test(this.line))L=W.textureProcessor(this.line,x.isFragment,I,x.processingContext);else if((W.uniformProcessor||W.uniformBufferProcessor)&&this.line.startsWith("uniform")&&!x.lookForClosingBracketForUniformBuffer){/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line)?W.uniformProcessor&&(L=W.uniformProcessor(this.line,x.isFragment,I,x.processingContext)):W.uniformBufferProcessor&&(L=W.uniformBufferProcessor(this.line,x.isFragment,x.processingContext),x.lookForClosingBracketForUniformBuffer=!0)}x.lookForClosingBracketForUniformBuffer&&-1!==this.line.indexOf("}")&&(x.lookForClosingBracketForUniformBuffer=!1,W.endOfUniformBufferProcessor&&(L=W.endOfUniformBufferProcessor(this.line,x.isFragment,x.processingContext)))}F+=L+"\n"}for(const W of this.children)F+=W.process(I,x,L);return this.additionalDefineKey&&(I[this.additionalDefineKey]=this.additionalDefineValue||"true",L[this.additionalDefineKey]=I[this.additionalDefineKey]),F}}class X{constructor(){this._lines=[]}get currentLine(){return this._lines[this.lineIndex]}get canRead(){return this.lineIndex<this._lines.length-1}set lines(I){this._lines.length=0;for(const x of I){if(!x||"\r"===x)continue;if("#"===x[0]){this._lines.push(x);continue}const I=x.trim();if(!I)continue;if(I.startsWith("//")){this._lines.push(x);continue}const L=I.indexOf(";");if(-1===L)this._lines.push(I);else if(L===I.length-1)I.length>1&&this._lines.push(I);else{const I=x.split(";");for(let x=0;x<I.length;x++){let L=I[x];L&&(L=L.trim(),L&&this._lines.push(L+(x!==I.length-1?";":"")))}}}}}class G extends F{process(I,x,L){for(let F=0;F<this.children.length;F++){const X=this.children[F];if(X.isValid(I))return X.process(I,x,L)}return""}}class Y extends F{isValid(I){return this.testExpression.isTrue(I)}}class p{isTrue(I){return!0}static postfixToInfix(I){const x=[];for(const L of I)if(void 0===p._OperatorPriority[L])x.push(L);else{const I=x[x.length-1],F=x[x.length-2];x.length-=2,x.push(`(${F}${L}${I})`)}return x[x.length-1]}static infixToPostfix(I){const x=p._InfixToPostfixCache.get(I);if(x)return x.accessTime=Date.now(),x.result;if(!I.includes("&&")&&!I.includes("||")&&!I.includes(")")&&!I.includes("("))return[I];const L=[];let F=-1;const X=()=>{W=W.trim(),""!==W&&(L.push(W),W="")},G=I=>{F<p._Stack.length-1&&(p._Stack[++F]=I)},Y=()=>p._Stack[F],B=()=>-1===F?"!!INVALID EXPRESSION!!":p._Stack[F--];let l=0,W="";for(;l<I.length;){const x=I.charAt(l),Q=l<I.length-1?I.substring(l,2+l):"";if("("===x)W="",G(x);else if(")"===x){for(X();-1!==F&&"("!==Y();)L.push(B());B()}else if(p._OperatorPriority[Q]>1){for(X();-1!==F&&p._OperatorPriority[Y()]>=p._OperatorPriority[Q];)L.push(B());G(Q),l++}else W+=x;l++}for(X();-1!==F;)"("===Y()?B():L.push(B());return p._InfixToPostfixCache.size>=p.InfixToPostfixCacheLimitSize&&p.ClearCache(),p._InfixToPostfixCache.set(I,{result:L,accessTime:Date.now()}),L}static ClearCache(){const I=Array.from(p._InfixToPostfixCache.entries()).sort(((I,x)=>I[1].accessTime-x[1].accessTime));for(let x=0;x<p.InfixToPostfixCacheCleanupSize;x++)p._InfixToPostfixCache.delete(I[x][0])}}p.InfixToPostfixCacheLimitSize=5e4,p.InfixToPostfixCacheCleanupSize=25e3,p._InfixToPostfixCache=new Map,p._OperatorPriority={")":0,"(":1,"||":2,"&&":3},p._Stack=["","","","","","","","","","","","","","","","","","","",""];class B extends p{constructor(I){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super(),this.define=I,this.not=x}isTrue(I){let x=void 0!==I[this.define];return this.not&&(x=!x),x}}class l extends p{isTrue(I){return this.leftOperand.isTrue(I)||this.rightOperand.isTrue(I)}}class W extends p{isTrue(I){return this.leftOperand.isTrue(I)&&this.rightOperand.isTrue(I)}}class Q extends p{constructor(I,x,L){super(),this.define=I,this.operand=x,this.testValue=L}toString(){return`${this.define} ${this.operand} ${this.testValue}`}isTrue(I){let x=!1;const L=parseInt(void 0!=I[this.define]?I[this.define]:this.define),F=parseInt(void 0!=I[this.testValue]?I[this.testValue]:this.testValue);if(isNaN(L)||isNaN(F))return!1;switch(this.operand){case">":x=L>F;break;case"<":x=L<F;break;case"<=":x=L<=F;break;case">=":x=L>=F;break;case"==":x=L===F;break;case"!=":x=L!==F}return x}}var e=L(12825),g=L(12858);const v=/defined\s*?\((.+?)\)/g,z=/defined\s*?\[(.+?)\]/g,H=/#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,s=/__decl__/,U=/light\{X\}.(\w*)/g,q=/\{X\}/g,y=[],T=/(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;function Z(I){I.processor&&I.processor.initializeShaders&&I.processor.initializeShaders(I.processingContext)}function t(I,x,L,F){var X;null!==(X=x.processor)&&void 0!==X&&X.preProcessShaderCode&&(I=x.processor.preProcessShaderCode(I,x.isFragment)),u(I,x,(I=>{x.processCodeAfterIncludes&&(I=x.processCodeAfterIncludes(x.isFragment?"fragment":"vertex",I,x.defines));const X=function(I,x,L){let F=function(I,x){var L;if(null!==(L=x.processor)&&void 0!==L&&L.noPrecision)return I;const F=x.shouldUseHighPrecisionShader;-1===I.indexOf("precision highp float")?I=F?"precision highp float;\n"+I:"precision mediump float;\n"+I:F||(I=I.replace("precision highp float","precision mediump float"));return I}(I,x);if(!x.processor)return F;if(0===x.processor.shaderLanguage&&-1!==F.indexOf("#version 3")&&(F=F.replace("#version 300 es",""),!x.processor.parseGLES3))return F;const X=x.defines,G=K(x,L);x.processor.preProcessor&&(F=x.processor.preProcessor(F,X,G,x.isFragment,x.processingContext));const Y={};F=M(F,G,x,Y),x.processor.postProcessor&&(F=x.processor.postProcessor(F,X,x.isFragment,x.processingContext,L?{drawBuffersExtensionDisabled:!L.getCaps().drawBuffersExtension}:{},G,Y));null!==L&&void 0!==L&&L._features.needShaderCodeInlining&&(F=L.inlineShaderCode(F));return F}(I,x,F);L(X,I)}))}function f(I,x,L){return L.processor&&L.processor.finalizeShaders?L.processor.finalizeShaders(I,x,L.processingContext):{vertexCode:I,fragmentCode:x}}function R(I){const x=/defined\((.+)\)/.exec(I);if(x&&x.length)return new B(x[1].trim(),"!"===I[0]);const L=["==","!=",">=","<=","<",">"];let F="",X=0;for(F of L)if(X=I.indexOf(F),X>-1)break;if(-1===X)return new B(I);const G=I.substring(0,X).trim(),Y=I.substring(X+F.length).trim();return new Q(G,F,Y)}function n(I,x){const L=new Y,F=I.substring(0,x);let X=I.substring(x);return X=X.substring(0,(X.indexOf("//")+1||X.length+1)-1).trim(),L.testExpression="#ifdef"===F?new B(X):"#ifndef"===F?new B(X,!0):function(I){I=I.replace(v,"defined[$1]");const x=p.infixToPostfix(I),L=[];for(const X of x)if("||"!==X&&"&&"!==X)L.push(X);else if(L.length>=2){let I=L[L.length-1],x=L[L.length-2];L.length-=2;const F="&&"==X?new W:new l;"string"===typeof I&&(I=I.replace(z,"defined($1)")),"string"===typeof x&&(x=x.replace(z,"defined($1)")),F.leftOperand="string"===typeof x?R(x):x,F.rightOperand="string"===typeof I?R(I):I,L.push(F)}let F=L[L.length-1];return"string"===typeof F&&(F=F.replace(z,"defined($1)")),"string"===typeof F?R(F):F}(X),L}function P(I,x,L,X){let G=I.currentLine;for(;d(I,L,X);){G=I.currentLine;const Y=G.substring(0,5).toLowerCase();if("#else"===Y){const L=new F;return x.children.push(L),void d(I,L,X)}if("#elif"===Y){const I=n(G,5);x.children.push(I),L=I}}}function d(I,x,L){for(;I.canRead;){I.lineIndex++;const X=I.currentLine;if(X.indexOf("#")>=0){const F=T.exec(X);if(F&&F.length){switch(F[0]){case"#ifdef":{const F=new G;x.children.push(F);const Y=n(X,6);F.children.push(Y),P(I,F,Y,L);break}case"#else":case"#elif":return!0;case"#endif":return!1;case"#ifndef":{const F=new G;x.children.push(F);const Y=n(X,7);F.children.push(Y),P(I,F,Y,L);break}case"#if":{const F=new G,Y=n(X,3);x.children.push(F),F.children.push(Y),P(I,F,Y,L);break}}continue}}const Y=new F;if(Y.line=X,x.children.push(Y),"#"===X[0]&&"d"===X[1]){const I=X.replace(";","").split(" ");Y.additionalDefineKey=I[1],3===I.length&&(Y.additionalDefineValue=I[2])}}return!1}function M(I,x,L,G){const Y=new F,p=new X;return p.lineIndex=-1,p.lines=I.split("\n"),d(p,Y,G),Y.process(x,L,G)}function K(I,x){var L;const F=I.defines,X={};for(const G of F){const I=G.replace("#define","").replace(";","").trim().split(" ");X[I[0]]=I.length>1?I[1]:""}return 0===(null===(L=I.processor)||void 0===L?void 0:L.shaderLanguage)&&(X.GL_ES="true"),X.__VERSION__=I.version,X[I.platformName]="true",(0,g.g)(X,null===x||void 0===x?void 0:x.isNDCHalfZRange,null===x||void 0===x?void 0:x.dp,null===x||void 0===x?void 0:x.useExactSrgbConversions),X}function u(I,x,L){let F;for(y.length=0;null!==(F=H.exec(I));)y.push(F);let X=String(I),G=[I],Y=!1;for(const p of y){let I=p[1];if(-1!==I.indexOf("__decl__")&&(I=I.replace(s,""),x.supportsUniformBuffers&&(I=I.replace("Vertex","Ubo").replace("Fragment","Ubo")),I+="Declaration"),!x.includesShadersStore[I]){const F=x.shadersRepository+"ShadersInclude/"+I+".fx";return void A.loadFile(F,(F=>{x.includesShadersStore[I]=F,u(G.join(""),x,L)}))}{let L=x.includesShadersStore[I];if(p[2]){const I=p[3].split(",");for(let x=0;x<I.length;x+=2){const F=new RegExp(I[x],"g"),X=I[x+1];L=L.replace(F,X)}}if(p[4]){const I=p[5];if(-1!==I.indexOf("..")){const F=I.split(".."),X=parseInt(F[0]);let G=parseInt(F[1]),Y=L.slice(0);L="",isNaN(G)&&(G=x.indexParameters[F[1]]);for(let I=X;I<G;I++)x.supportsUniformBuffers||(Y=Y.replace(U,((I,x)=>x+"{X}"))),L+=Y.replace(q,I.toString())+"\n"}else x.supportsUniformBuffers||(L=L.replace(U,((I,x)=>x+"{X}"))),L=L.replace(q,I)}const F=[];for(const I of G){const x=I.split(p[0]);for(let I=0;I<x.length-1;I++)F.push(x[I]),F.push(L);F.push(x[x.length-1])}G=F,Y=Y||L.indexOf("#include<")>=0||L.indexOf("#include <")>=0}}y.length=0,X=G.join(""),Y?u(X.toString(),x,L):L(X)}const A={loadFile:(I,x,L,F,X,G)=>{throw(0,e.e)("FileTools")}}},12858:(I,x,L)=>{L.d(x,{c:()=>X,f:()=>G,g:()=>p,i:()=>Y,m:()=>B});var F=L(12825);L(12805);const X={};function G(I,x){return(arguments.length>2&&void 0!==arguments[2]?arguments[2]:"")+(x?x+"\n":"")+I}function Y(I,x,L,G,Y,p,B){const l=B||X.loadFile;if(l){return l(I,x,L,G,Y,p)}throw(0,F.e)("FileTools")}function p(I,x,L,F){if(I)return x?I.IS_NDC_HALF_ZRANGE="":delete I.IS_NDC_HALF_ZRANGE,L?I.USE_REVERSE_DEPTHBUFFER="":delete I.USE_REVERSE_DEPTHBUFFER,void(F?I.USE_EXACT_SRGB_CONVERSIONS="":delete I.USE_EXACT_SRGB_CONVERSIONS);{let I="";return x&&(I+="#define IS_NDC_HALF_ZRANGE"),L&&(I&&(I+="\n"),I+="#define USE_REVERSE_DEPTHBUFFER"),F&&(I&&(I+="\n"),I+="#define USE_EXACT_SRGB_CONVERSIONS"),I}}function B(I,x){let L=arguments.length>2&&void 0!==arguments[2]&&arguments[2],F=arguments.length>3?arguments[3]:void 0;switch(I){case 3:{const I=(ArrayBuffer,new Int8Array(x));return F&&I.set(new Int8Array(F)),I}case 0:{const I=(ArrayBuffer,new Uint8Array(x));return F&&I.set(new Uint8Array(F)),I}case 4:{const I=x instanceof ArrayBuffer?new Int16Array(x):new Int16Array(L?x/2:x);return F&&I.set(new Int16Array(F)),I}case 5:case 8:case 9:case 10:case 2:{const I=x instanceof ArrayBuffer?new Uint16Array(x):new Uint16Array(L?x/2:x);return F&&I.set(new Uint16Array(F)),I}case 6:{const I=x instanceof ArrayBuffer?new Int32Array(x):new Int32Array(L?x/4:x);return F&&I.set(new Int32Array(F)),I}case 7:case 11:case 12:case 13:case 14:case 15:{const I=x instanceof ArrayBuffer?new Uint32Array(x):new Uint32Array(L?x/4:x);return F&&I.set(new Uint32Array(F)),I}case 1:{const I=x instanceof ArrayBuffer?new Float32Array(x):new Float32Array(L?x/4:x);return F&&I.set(new Float32Array(F)),I}}const X=(ArrayBuffer,new Uint8Array(x));return F&&X.set(new Uint8Array(F)),X}},12885:(I,x,L)=>{L.d(x,{d:()=>F});class F{static GetShadersRepository(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?F.ShadersRepository:F.ShadersRepositoryWGSL}static GetShadersStore(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?F.ShadersStore:F.ShadersStoreWGSL}static GetIncludesShadersStore(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?F.IncludesShadersStore:F.IncludesShadersStoreWGSL}}F.ShadersRepository="src/Shaders/",F.ShadersStore={},F.IncludesShadersStore={},F.ShadersRepositoryWGSL="src/ShadersWGSL/",F.ShadersStoreWGSL={},F.IncludesShadersStoreWGSL={}},12893:(I,x,L)=>{L.d(x,{b:()=>e,d:()=>q,e:()=>v,f:()=>g,h:()=>z,l:()=>U,o:()=>Q,s:()=>l,t:()=>W,v:()=>B,w:()=>p});class F{constructor(){this._valueCache={},this.vertexCompilationError=null,this.fragmentCompilationError=null,this.programLinkError=null,this.programValidationError=null,this._isDisposed=!1}get isAsync(){return this.isParallelCompiled}get isReady(){return!!this.program&&(!this.isParallelCompiled||this.Hx._isRenderingStateCompiled(this))}_handlesSpectorRebuildCallback(I){I&&this.program&&I(this.program)}setEngine(I){this.Hx=I}_fillEffectInformation(I,x,L,F,X,G,Y,p){const B=this.Hx;if(B.supportsUniformBuffers)for(const W in x)I.bindUniformBlock(W,x[W]);let l;for(this.Hx.getUniforms(this,L).forEach(((I,x)=>{F[L[x]]=I})),this._uniforms=F,l=0;l<X.length;l++){null==I.getUniform(X[l])&&(X.splice(l,1),l--)}X.forEach(((I,x)=>{G[I]=x}));for(const W of B.getAttributes(this,Y))p.push(W)}dispose(){this._uniforms={},this._isDisposed=!0}_cacheMatrix(I,x){const L=this._valueCache[I],F=x.updateFlag;return(void 0===L||L!==F)&&(this._valueCache[I]=F,!0)}_cacheFloat2(I,x,L){let F=this._valueCache[I];if(!F||2!==F.length)return F=[x,L],this._valueCache[I]=F,!0;let X=!1;return F[0]!==x&&(F[0]=x,X=!0),F[1]!==L&&(F[1]=L,X=!0),X}_cacheFloat3(I,x,L,F){let X=this._valueCache[I];if(!X||3!==X.length)return X=[x,L,F],this._valueCache[I]=X,!0;let G=!1;return X[0]!==x&&(X[0]=x,G=!0),X[1]!==L&&(X[1]=L,G=!0),X[2]!==F&&(X[2]=F,G=!0),G}_cacheFloat4(I,x,L,F,X){let G=this._valueCache[I];if(!G||4!==G.length)return G=[x,L,F,X],this._valueCache[I]=G,!0;let Y=!1;return G[0]!==x&&(G[0]=x,Y=!0),G[1]!==L&&(G[1]=L,Y=!0),G[2]!==F&&(G[2]=F,Y=!0),G[3]!==X&&(G[3]=X,Y=!0),Y}setInt(I,x){const L=this._valueCache[I];void 0!==L&&L===x||this.Hx.setInt(this._uniforms[I],x)&&(this._valueCache[I]=x)}setInt2(I,x,L){this._cacheFloat2(I,x,L)&&(this.Hx.setInt2(this._uniforms[I],x,L)||(this._valueCache[I]=null))}setInt3(I,x,L,F){this._cacheFloat3(I,x,L,F)&&(this.Hx.setInt3(this._uniforms[I],x,L,F)||(this._valueCache[I]=null))}setInt4(I,x,L,F,X){this._cacheFloat4(I,x,L,F,X)&&(this.Hx.setInt4(this._uniforms[I],x,L,F,X)||(this._valueCache[I]=null))}setIntArray(I,x){this._valueCache[I]=null,this.Hx.setIntArray(this._uniforms[I],x)}setIntArray2(I,x){this._valueCache[I]=null,this.Hx.setIntArray2(this._uniforms[I],x)}setIntArray3(I,x){this._valueCache[I]=null,this.Hx.setIntArray3(this._uniforms[I],x)}setIntArray4(I,x){this._valueCache[I]=null,this.Hx.setIntArray4(this._uniforms[I],x)}setUInt(I,x){const L=this._valueCache[I];void 0!==L&&L===x||this.Hx.setUInt(this._uniforms[I],x)&&(this._valueCache[I]=x)}setUInt2(I,x,L){this._cacheFloat2(I,x,L)&&(this.Hx.setUInt2(this._uniforms[I],x,L)||(this._valueCache[I]=null))}setUInt3(I,x,L,F){this._cacheFloat3(I,x,L,F)&&(this.Hx.setUInt3(this._uniforms[I],x,L,F)||(this._valueCache[I]=null))}setUInt4(I,x,L,F,X){this._cacheFloat4(I,x,L,F,X)&&(this.Hx.setUInt4(this._uniforms[I],x,L,F,X)||(this._valueCache[I]=null))}setUIntArray(I,x){this._valueCache[I]=null,this.Hx.setUIntArray(this._uniforms[I],x)}setUIntArray2(I,x){this._valueCache[I]=null,this.Hx.setUIntArray2(this._uniforms[I],x)}setUIntArray3(I,x){this._valueCache[I]=null,this.Hx.setUIntArray3(this._uniforms[I],x)}setUIntArray4(I,x){this._valueCache[I]=null,this.Hx.setUIntArray4(this._uniforms[I],x)}setArray(I,x){this._valueCache[I]=null,this.Hx.setArray(this._uniforms[I],x)}setArray2(I,x){this._valueCache[I]=null,this.Hx.setArray2(this._uniforms[I],x)}setArray3(I,x){this._valueCache[I]=null,this.Hx.setArray3(this._uniforms[I],x)}setArray4(I,x){this._valueCache[I]=null,this.Hx.setArray4(this._uniforms[I],x)}setMatrices(I,x){x&&(this._valueCache[I]=null,this.Hx.setMatrices(this._uniforms[I],x))}setMatrix(I,x){this._cacheMatrix(I,x)&&(this.Hx.setMatrices(this._uniforms[I],x.Cp())||(this._valueCache[I]=null))}setMatrix3x3(I,x){this._valueCache[I]=null,this.Hx.setMatrix3x3(this._uniforms[I],x)}setMatrix2x2(I,x){this._valueCache[I]=null,this.Hx.setMatrix2x2(this._uniforms[I],x)}setFloat(I,x){const L=this._valueCache[I];void 0!==L&&L===x||this.Hx.setFloat(this._uniforms[I],x)&&(this._valueCache[I]=x)}setVector2(I,x){this._cacheFloat2(I,x.x,x.y)&&(this.Hx.setFloat2(this._uniforms[I],x.x,x.y)||(this._valueCache[I]=null))}setFloat2(I,x,L){this._cacheFloat2(I,x,L)&&(this.Hx.setFloat2(this._uniforms[I],x,L)||(this._valueCache[I]=null))}setVector3(I,x){this._cacheFloat3(I,x.x,x.y,x.z)&&(this.Hx.setFloat3(this._uniforms[I],x.x,x.y,x.z)||(this._valueCache[I]=null))}setFloat3(I,x,L,F){this._cacheFloat3(I,x,L,F)&&(this.Hx.setFloat3(this._uniforms[I],x,L,F)||(this._valueCache[I]=null))}setVector4(I,x){this._cacheFloat4(I,x.x,x.y,x.z,x.w)&&(this.Hx.setFloat4(this._uniforms[I],x.x,x.y,x.z,x.w)||(this._valueCache[I]=null))}setQuaternion(I,x){this._cacheFloat4(I,x.x,x.y,x.z,x.w)&&(this.Hx.setFloat4(this._uniforms[I],x.x,x.y,x.z,x.w)||(this._valueCache[I]=null))}setFloat4(I,x,L,F,X){this._cacheFloat4(I,x,L,F,X)&&(this.Hx.setFloat4(this._uniforms[I],x,L,F,X)||(this._valueCache[I]=null))}setColor3(I,x){this._cacheFloat3(I,x.r,x.g,x.b)&&(this.Hx.setFloat3(this._uniforms[I],x.r,x.g,x.b)||(this._valueCache[I]=null))}setColor4(I,x,L){this._cacheFloat4(I,x.r,x.g,x.b,L)&&(this.Hx.setFloat4(this._uniforms[I],x.r,x.g,x.b,L)||(this._valueCache[I]=null))}setDirectColor4(I,x){this._cacheFloat4(I,x.r,x.g,x.b,x.a)&&(this.Hx.setFloat4(this._uniforms[I],x.r,x.g,x.b,x.a)||(this._valueCache[I]=null))}_getVertexShaderCode(){return this.vertexShader?this.Hx._getShaderSource(this.vertexShader):null}_getFragmentShaderCode(){return this.fragmentShader?this.Hx._getShaderSource(this.fragmentShader):null}}var X=L(12858);const G=new WeakMap,Y={_webGLVersion:2,cachedPipelines:{}};function p(I){let x=G.get(I);if(!x){if(!I)return Y;x={_webGLVersion:I.TEXTURE_BINDING_3D?2:1,_context:I,parallelShaderCompile:I.getExtension("KHR_parallel_shader_compile")||void 0,cachedPipelines:{}},G.set(I,x)}return x}function B(I){G.delete(I)}function l(I,x,L,F,X,G){const Y=p(F);G||(G=Y._createShaderProgramInjection??e);return G(I,s(x,"vertex",F,Y._contextWasLost),s(L,"fragment",F,Y._contextWasLost),F,X,Y.validateShaderPrograms)}function W(I,x,L,F,X){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,Y=arguments.length>6?arguments[6]:void 0;const B=p(X);Y||(Y=B._createShaderProgramInjection??e);const l=B._webGLVersion>1?"#version 300 es\n#define WEBGL2 \n":"";return Y(I,H(x,"vertex",F,l,X,B._contextWasLost),H(L,"fragment",F,l,X,B._contextWasLost),X,G,B.validateShaderPrograms)}function Q(I,x){const L=new F,X=p(I);return X.parallelShaderCompile&&!X.disableParallelShaderCompile&&(L.isParallelCompiled=!0),L.context=X._context,L}function e(I,x,L,F){let X=arguments.length>5?arguments[5]:void 0;const G=F.createProgram();if(I.program=G,!G)throw new Error("Unable to create program");return F.attachShader(G,x),F.attachShader(G,L),F.linkProgram(G),I.context=F,I.vertexShader=x,I.fragmentShader=L,I.isParallelCompiled||v(I,F,X),G}function g(I,x,L){const F=I;if(F._isDisposed)return!1;const X=p(x);return!!(X&&X.parallelShaderCompile&&X.parallelShaderCompile.COMPLETION_STATUS_KHR&&F.program&&x.getProgramParameter(F.program,X.parallelShaderCompile.COMPLETION_STATUS_KHR))&&(v(F,x,L),!0)}function v(I,x,L){const F=I.context,X=I.vertexShader,G=I.fragmentShader,Y=I.program;if(!F.getProgramParameter(Y,F.LINK_STATUS)){if(!x.getShaderParameter(X,x.COMPILE_STATUS)){const L=x.getShaderInfoLog(X);if(L)throw I.vertexCompilationError=L,new Error("VERTEX SHADER "+L)}if(!x.getShaderParameter(G,x.COMPILE_STATUS)){const L=x.getShaderInfoLog(G);if(L)throw I.fragmentCompilationError=L,new Error("FRAGMENT SHADER "+L)}const L=F.getProgramInfoLog(Y);if(L)throw I.programLinkError=L,new Error(L)}if(L){F.validateProgram(Y);if(!F.getProgramParameter(Y,F.VALIDATE_STATUS)){const x=F.getProgramInfoLog(Y);if(x)throw I.programValidationError=x,new Error(x)}}F.deleteShader(X),F.deleteShader(G),I.vertexShader=void 0,I.fragmentShader=void 0,I.onCompiled&&(I.onCompiled(),I.onCompiled=void 0)}function z(I,x,L,F,X,G,Y,B,Q){let e=arguments.length>10?arguments[10]:void 0,g=arguments.length>11?arguments[11]:void 0,v=arguments.length>12?arguments[12]:void 0;const z=p(I.context);g||(g=z.createRawShaderProgramInjection??l),v||(v=z.createShaderProgramInjection??W);const H=I;H.program=F?g(H,x,L,H.context,Q):v(H,x,L,B,H.context,Q),H.program.__SPECTOR_rebuildProgram=Y,e()}function H(I,x,L,F,G,Y){return s((0,X.f)(I,L,F),x,G,Y)}function s(I,x,L,F){const X=L.createShader("vertex"===x?L.VERTEX_SHADER:L.FRAGMENT_SHADER);if(!X){let I=L.NO_ERROR,X=L.NO_ERROR;for(;(X=L.getError())!==L.NO_ERROR;)I=X;throw new Error(`Something went wrong while creating a gl ${x} shader object. gl error=${I}, gl isContextLost=${L.isContextLost()}, _contextWasLost=${F}`)}return L.shaderSource(X,I),L.compileShader(X),X}function U(I,x){x.useProgram(I)}function q(I,x){const L=I;if(!L.isParallelCompiled)return void x(I);const F=L.onCompiled;L.onCompiled=()=>{null===F||void 0===F||F(),x(I)}}},12889:(I,x,L)=>{L.d(x,{e:()=>Q,h:()=>g,j:()=>l,k:()=>W});var F=L(12805),X=L(12893),G=L(12885),Y=L(12809),p=L(12855),B=L(12858);function l(I,x){return(0,X.w)(x).cachedPipelines[I]}function W(I){const x=I._name,L=I.context;if(x&&L){const I=(0,X.w)(L),F=I.cachedPipelines[x];null===F||void 0===F||F.dispose(),delete I.cachedPipelines[x]}}function Q(I,x,L,X,G,Y,B){let l,W;const Q=(0,F.l)()?null===Y||void 0===Y?void 0:Y.getHostDocument():null;l="string"===typeof x?x:x.vertexSource?"source:"+x.vertexSource:x.vertexElement?(null===Q||void 0===Q?void 0:Q.getElementById(x.vertexElement))||x.vertexElement:x.vertex||x,W="string"===typeof x?x:x.fragmentSource?"source:"+x.fragmentSource:x.fragmentElement?(null===Q||void 0===Q?void 0:Q.getElementById(x.fragmentElement))||x.fragmentElement:x.fragment||x;const g=[void 0,void 0],v=()=>{if(g[0]&&g[1]){I.isFragment=!0;const[F,l]=g;(0,p.n)(l,I,((Y,l)=>{B&&(B._fragmentSourceCodeBeforeMigration=l),L&&(Y=L("fragment",Y));const W=(0,p.e)(F,Y,I);I=null;const Q=function(I,x,L,F){if(L){return{vertexSourceCode:(1===F?"//":"")+"#define SHADER_NAME vertex:"+(L.vertexElement||L.vertex||L.spectorName||L)+"\n"+I,fragmentSourceCode:(1===F?"//":"")+"#define SHADER_NAME fragment:"+(L.fragmentElement||L.fragment||L.spectorName||L)+"\n"+x}}return{vertexSourceCode:I,fragmentSourceCode:x}}(W.vertexCode,W.fragmentCode,x,G);null===X||void 0===X||X(Q.vertexSourceCode,Q.fragmentSourceCode)}),Y)}};e(l,"Vertex","",(x=>{(0,p.i)(I),(0,p.n)(x,I,((I,F)=>{B&&(B._rawVertexSourceCode=x,B._vertexSourceCodeBeforeMigration=F),L&&(I=L("vertex",I)),g[0]=I,v()}),Y)}),G),e(W,"Fragment","Pixel",(I=>{B&&(B._rawFragmentSourceCode=I),g[1]=I,v()}),G)}function e(I,x,L,X,Y,p){if("undefined"!==typeof HTMLElement&&I instanceof HTMLElement){return void X((0,F.d)(I))}if("source:"===I.substring(0,7))return void X(I.substring(7));if("base64:"===I.substring(0,7)){return void X(window.atob(I.substring(7)))}const l=G.d.GetShadersStore(Y);if(l[I+x+"Shader"])return void X(l[I+x+"Shader"]);if(L&&l[I+L+"Shader"])return void X(l[I+L+"Shader"]);let W;if(W="."===I[0]||"/"===I[0]||I.indexOf("http")>-1?I:G.d.GetShadersRepository(Y)+I,!(p=p||B.i))throw new Error("loadFileInjection is not defined");p(W+"."+x.toLowerCase()+".fx",X)}const g=(I,x,L,F)=>{try{const G=I.context?(0,X.w)(I.context):null;G&&(G.disableParallelShaderCompile=I.disableParallelCompilation);const Y=I.existingPipelineContext||x(I.shaderProcessingContext);return Y._name=I.name,I.name&&G&&(G.cachedPipelines[I.name]=Y),L(Y,I.vertex,I.fragment,!!I.createAsRaw,"","",I.rebuildRebind,I.defines,I.transformFeedbackVaryings,"",(()=>{F(Y,(()=>{var x;null===(x=I.onRenderingStateCompiled)||void 0===x||x.call(I,Y)}))})),Y}catch(G){throw Y.c.Error("Error compiling effect"),G}}},12878:(I,x,L)=>{L.r(x),L.d(x,{Effect:()=>B});var F=L(12797),X=L(12809),G=L(12885),Y=L(12889),p=L(12865);class B{static get ShadersRepository(){return G.d.ShadersRepository}static set ShadersRepository(I){G.d.ShadersRepository=I}get p(){return this._isDisposed}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new F.c),this._onBindObservable}get shaderLanguage(){return this._shaderLanguage}constructor(I,x,L){let X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,G=arguments.length>4?arguments[4]:void 0,p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,W=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,Q=arguments.length>8&&void 0!==arguments[8]?arguments[8]:null,e=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]?arguments[10]:"",v=arguments.length>11&&void 0!==arguments[11]?arguments[11]:0,z=arguments.length>12?arguments[12]:void 0;this.defines="",this.onCompiled=null,this.onError=null,this.onBind=null,this.uniqueId=0,this.onCompileObservable=new F.c,this.onErrorObservable=new F.c,this._onBindObservable=null,this._isDisposed=!1,this._refCount=1,this._bonesComputationForcedToCPU=!1,this._uniformBuffersNames={},this._multiTarget=!1,this._samplers={},this._isReady=!1,this._compilationError="",this._allFallbacksProcessed=!1,this._uniforms={},this._key="",this._fallbacks=null,this._vertexSourceCodeOverride="",this._fragmentSourceCodeOverride="",this._transformFeedbackVaryings=null,this._disableParallelShaderCompilation=!1,this._pipelineContext=null,this._vertexSourceCode="",this._fragmentSourceCode="",this._vertexSourceCodeBeforeMigration="",this._fragmentSourceCodeBeforeMigration="",this._rawVertexSourceCode="",this._rawFragmentSourceCode="",this._processCodeAfterIncludes=void 0,this._processFinalCode=null,this.name=I,this._key=g;const H=this._key.replace(/\r/g,"").replace(/\n/g,"|");let s;if(x.attributes){const I=x;if(this._engine=L,this._attributesNames=I.attributes,this._uniformsNames=I.uniformsNames.concat(I.samplers),this._samplerList=I.samplers.slice(),this.defines=I.defines,this.onError=I.onError,this.onCompiled=I.onCompiled,this._fallbacks=I.fallbacks,this._indexParameters=I.indexParameters,this._transformFeedbackVaryings=I.transformFeedbackVaryings||null,this._multiTarget=!!I.multiTarget,this._shaderLanguage=I.shaderLanguage??0,this._disableParallelShaderCompilation=!!I.disableParallelShaderCompilation,I.uniformBuffersNames){this._uniformBuffersNamesList=I.uniformBuffersNames.slice();for(let x=0;x<I.uniformBuffersNames.length;x++)this._uniformBuffersNames[I.uniformBuffersNames[x]]=x}this._processFinalCode=I.processFinalCode??null,this._processCodeAfterIncludes=I.processCodeAfterIncludes??void 0,z=I.extraInitializationsAsync,s=I.existingPipelineContext}else this._engine=G,this.defines=null==p?"":p,this._uniformsNames=L.concat(X),this._samplerList=X?X.slice():[],this._attributesNames=x,this._uniformBuffersNamesList=[],this._shaderLanguage=v,this.onError=Q,this.onCompiled=W,this._indexParameters=e,this._fallbacks=l;"WEBGL2"===this._engine.shaderPlatformName&&(s=(0,Y.j)(H,this._engine._gl)??s),this._attributeLocationByName={},this.uniqueId=B._UniqueIdSeed++,s?(this._pipelineContext=s,this._pipelineContext.setEngine(this._engine),this._onRenderingStateCompiled(this._pipelineContext),this._pipelineContext.program&&(this._pipelineContext.program.__SPECTOR_rebuildProgram=this._rebuildProgram.bind(this))):this._processShaderCodeAsync(null,!1,null,z),this._engine.onReleaseEffectsObservable.addOnce((()=>{this.p||this.dispose(!0)}))}async _processShaderCodeAsync(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,F=arguments.length>3?arguments[3]:void 0;F&&await F(),this._processingContext=L||this._engine._getShaderProcessingContext(this._shaderLanguage,!1);const X={defines:this.defines.split("\n"),indexParameters:this._indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:I??this._engine._getShaderProcessor(this._shaderLanguage),supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:G.d.GetShadersRepository(this._shaderLanguage),includesShadersStore:G.d.GetIncludesShadersStore(this._shaderLanguage),version:(100*this._engine.version).toString(),platformName:this._engine.shaderPlatformName,processingContext:this._processingContext,isNDCHalfZRange:this._engine.isNDCHalfZRange,dp:this._engine.dp,processCodeAfterIncludes:this._processCodeAfterIncludes};(0,Y.e)(X,this.name,this._processFinalCode,((I,L)=>{this._vertexSourceCode=I,this._fragmentSourceCode=L,this._prepareEffect(x)}),this._shaderLanguage,this._engine,this)}get key(){return this._key}isReady(){try{return this._isReadyInternal()}catch{return!1}}_isReadyInternal(){return!!this._engine.p||(!!this._isReady||!!this._pipelineContext&&this._pipelineContext.isReady)}getEngine(){return this._engine}getPipelineContext(){return this._pipelineContext}getAttributesNames(){return this._attributesNames}getAttributeLocation(I){return this._attributes[I]}getAttributeLocationByName(I){return this._attributeLocationByName[I]}getAttributesCount(){return this._attributes.length}getUniformIndex(I){return this._uniformsNames.indexOf(I)}getUniform(I){return this._uniforms[I]}getSamplers(){return this._samplerList}getUniformNames(){return this._uniformsNames}getUniformBuffersNames(){return this._uniformBuffersNamesList}getIndexParameters(){return this._indexParameters}getCompilationError(){return this._compilationError}allFallbacksProcessed(){return this._allFallbacksProcessed}async whenCompiledAsync(){return await new Promise((I=>{this.executeWhenCompiled(I)}))}executeWhenCompiled(I){this.isReady()?I(this):(this.onCompileObservable.add((x=>{I(x)})),this._pipelineContext&&!this._pipelineContext.isAsync||this._checkIsReady(null))}_checkIsReady(I){(0,p.e)((()=>this._isReadyInternal()||this._isDisposed),(()=>{}),(x=>{this._processCompilationErrors(x,I)}),16,12e4,!0,` - Effect: ${"string"===typeof this.name?this.name:this.key}`)}get vertexSourceCode(){var I;return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._vertexSourceCodeOverride:(null===(I=this._pipelineContext)||void 0===I?void 0:I._getVertexShaderCode())??this._vertexSourceCode}get fragmentSourceCode(){var I;return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._fragmentSourceCodeOverride:(null===(I=this._pipelineContext)||void 0===I?void 0:I._getFragmentShaderCode())??this._fragmentSourceCode}get vertexSourceCodeBeforeMigration(){return this._vertexSourceCodeBeforeMigration}get fragmentSourceCodeBeforeMigration(){return this._fragmentSourceCodeBeforeMigration}get rawVertexSourceCode(){return this._rawVertexSourceCode}get rawFragmentSourceCode(){return this._rawFragmentSourceCode}getPipelineGenerationOptions(){return{platformName:this._engine.shaderPlatformName,shaderLanguage:this._shaderLanguage,shaderNameOrContent:this.name,key:this._key,defines:this.defines.split("\n"),addGlobalDefines:!1,extendedProcessingOptions:{indexParameters:this._indexParameters,isNDCHalfZRange:this._engine.isNDCHalfZRange,dp:this._engine.dp,supportsUniformBuffers:this._engine.supportsUniformBuffers},extendedCreatePipelineOptions:{transformFeedbackVaryings:this._transformFeedbackVaryings,createAsRaw:!(!this._vertexSourceCodeOverride||!this._fragmentSourceCodeOverride)}}}_rebuildProgram(I,x,L,F){this._isReady=!1,this._vertexSourceCodeOverride=I,this._fragmentSourceCodeOverride=x,this.onError=(I,x)=>{F&&F(x)},this.onCompiled=()=>{var I,x;const F=this.getEngine().scenes;if(F)for(let L=0;L<F.length;L++)F[L].markAllMaterialsAsDirty(127);null===(I=(x=this._pipelineContext)._handlesSpectorRebuildCallback)||void 0===I||I.call(x,L)},this._fallbacks=null,this._prepareEffect()}_onRenderingStateCompiled(I){if(this._pipelineContext=I,this._pipelineContext.setEngine(this._engine),this._attributes=[],this._pipelineContext._fillEffectInformation(this,this._uniformBuffersNames,this._uniformsNames,this._uniforms,this._samplerList,this._samplers,this._attributesNames,this._attributes),this._attributesNames)for(let x=0;x<this._attributesNames.length;x++){const I=this._attributesNames[x];this._attributeLocationByName[I]=this._attributes[x]}this._engine.bindSamplers(this),this._compilationError="",this._isReady=!0,this.onCompiled&&this.onCompiled(this),this.onCompileObservable.notifyObservers(this),this.onCompileObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh(),B.AutomaticallyClearCodeCache&&this.clearCodeCache()}_prepareEffect(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=this._pipelineContext;this._isReady=!1;try{const L=!(!this._vertexSourceCodeOverride||!this._fragmentSourceCodeOverride),F=L?null:this.defines,X=L?this._vertexSourceCodeOverride:this._vertexSourceCode,G=L?this._fragmentSourceCodeOverride:this._fragmentSourceCode,p=this._engine;this._pipelineContext=(0,Y.h)({existingPipelineContext:I?x:null,vertex:X,fragment:G,context:"WEBGL2"===p.shaderPlatformName||"WEBGL1"===p.shaderPlatformName?p._gl:void 0,rebuildRebind:(I,x,L,F)=>this._rebuildProgram(I,x,L,F),defines:F,transformFeedbackVaryings:this._transformFeedbackVaryings,name:this._key.replace(/\r/g,"").replace(/\n/g,"|"),createAsRaw:L,disableParallelCompilation:this._disableParallelShaderCompilation,shaderProcessingContext:this._processingContext,onRenderingStateCompiled:L=>{x&&!I&&this._engine._deletePipelineContext(x),L&&this._onRenderingStateCompiled(L)}},this._engine.createPipelineContext.bind(this._engine),this._engine._preparePipelineContextAsync.bind(this._engine),this._engine._executeWhenRenderingStateIsCompiled.bind(this._engine)),this._pipelineContext.isAsync&&this._checkIsReady(x)}catch(L){this._processCompilationErrors(L,x)}}_getShaderCodeAndErrorLine(I,x,L){const F=L?/FRAGMENT SHADER ERROR: 0:(\d+?):/:/VERTEX SHADER ERROR: 0:(\d+?):/;let X=null;if(x&&I){const G=x.match(F);if(G&&2===G.length){const x=parseInt(G[1]),F=I.split("\n",-1);F.length>=x&&(X=`Offending line [${x}] in ${L?"fragment":"vertex"} code: ${F[x-1]}`)}}return[I,X]}_processCompilationErrors(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;this._compilationError=I.message;const L=this._attributesNames,F=this._fallbacks;if(X.c.Error("Unable to compile effect:"),X.c.Error(`Uniforms: ${this._uniformsNames.join(" ")}`),X.c.Error(`Attributes: ${L.join(" ")}`),X.c.Error("Defines:\n"+this.defines),B.LogShaderCodeOnCompilationError){var G,Y;let I=null,x=null,L=null;var p;if(null!==(G=this._pipelineContext)&&void 0!==G&&G._getVertexShaderCode()&&([L,I]=this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(),this._compilationError,!1),L&&(X.c.Error("Vertex code:"),X.c.Error(L))),null!==(Y=this._pipelineContext)&&void 0!==Y&&Y._getFragmentShaderCode())[L,x]=this._getShaderCodeAndErrorLine(null===(p=this._pipelineContext)||void 0===p?void 0:p._getFragmentShaderCode(),this._compilationError,!0),L&&(X.c.Error("Fragment code:"),X.c.Error(L));I&&X.c.Error(I),x&&X.c.Error(x)}X.c.Error("Error: "+this._compilationError);const l=()=>{this.onError&&this.onError(this,this._compilationError),this.onErrorObservable.notifyObservers(this),this._engine.onEffectErrorObservable.notifyObservers({effect:this,errors:this._compilationError})};x&&(this._pipelineContext=x,this._isReady=!0,l()),F?(this._pipelineContext=null,F.hasMoreFallbacks?(this._allFallbacksProcessed=!1,X.c.Error("Trying next fallback."),this.defines=F.reduce(this.defines,this),this._prepareEffect()):(this._allFallbacksProcessed=!0,l(),this.onErrorObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh())):(this._allFallbacksProcessed=!0,x||l())}get isSupported(){return""===this._compilationError}_bindTexture(I,x){this._engine._bindTexture(this._samplers[I],x,I)}setTexture(I,x){this._engine.setTexture(this._samplers[I],this._uniforms[I],x,I)}setTextureArray(I,x){const L=I+"Ex";if(-1===this._samplerList.indexOf(L+"0")){const F=this._samplerList.indexOf(I);for(let I=1;I<x.length;I++){const x=L+(I-1).toString();this._samplerList.splice(F+I,0,x)}let X=0;for(const I of this._samplerList)this._samplers[I]=X,X+=1}this._engine.setTextureArray(this._samplers[I],this._uniforms[I],x,I)}bindUniformBuffer(I,x){const L=this._uniformBuffersNames[x];void 0===L||B._BaseCache[L]===I&&this._engine._features.useUBOBindingCache||(B._BaseCache[L]=I,this._engine.bindUniformBufferBase(I,L,x))}bindUniformBlock(I,x){this._engine.bindUniformBlock(this._pipelineContext,I,x)}setInt(I,x){return this._pipelineContext.setInt(I,x),this}setInt2(I,x,L){return this._pipelineContext.setInt2(I,x,L),this}setInt3(I,x,L,F){return this._pipelineContext.setInt3(I,x,L,F),this}setInt4(I,x,L,F,X){return this._pipelineContext.setInt4(I,x,L,F,X),this}setIntArray(I,x){return this._pipelineContext.setIntArray(I,x),this}setIntArray2(I,x){return this._pipelineContext.setIntArray2(I,x),this}setIntArray3(I,x){return this._pipelineContext.setIntArray3(I,x),this}setIntArray4(I,x){return this._pipelineContext.setIntArray4(I,x),this}setUInt(I,x){return this._pipelineContext.setUInt(I,x),this}setUInt2(I,x,L){return this._pipelineContext.setUInt2(I,x,L),this}setUInt3(I,x,L,F){return this._pipelineContext.setUInt3(I,x,L,F),this}setUInt4(I,x,L,F,X){return this._pipelineContext.setUInt4(I,x,L,F,X),this}setUIntArray(I,x){return this._pipelineContext.setUIntArray(I,x),this}setUIntArray2(I,x){return this._pipelineContext.setUIntArray2(I,x),this}setUIntArray3(I,x){return this._pipelineContext.setUIntArray3(I,x),this}setUIntArray4(I,x){return this._pipelineContext.setUIntArray4(I,x),this}setFloatArray(I,x){return this._pipelineContext.setArray(I,x),this}setFloatArray2(I,x){return this._pipelineContext.setArray2(I,x),this}setFloatArray3(I,x){return this._pipelineContext.setArray3(I,x),this}setFloatArray4(I,x){return this._pipelineContext.setArray4(I,x),this}setArray(I,x){return this._pipelineContext.setArray(I,x),this}setArray2(I,x){return this._pipelineContext.setArray2(I,x),this}setArray3(I,x){return this._pipelineContext.setArray3(I,x),this}setArray4(I,x){return this._pipelineContext.setArray4(I,x),this}setMatrices(I,x){return this._pipelineContext.setMatrices(I,x),this}setMatrix(I,x){return this._pipelineContext.setMatrix(I,x),this}setMatrix3x3(I,x){return this._pipelineContext.setMatrix3x3(I,x),this}setMatrix2x2(I,x){return this._pipelineContext.setMatrix2x2(I,x),this}setFloat(I,x){return this._pipelineContext.setFloat(I,x),this}setBool(I,x){return this._pipelineContext.setInt(I,x?1:0),this}setVector2(I,x){return this._pipelineContext.setVector2(I,x),this}setFloat2(I,x,L){return this._pipelineContext.setFloat2(I,x,L),this}setVector3(I,x){return this._pipelineContext.setVector3(I,x),this}setFloat3(I,x,L,F){return this._pipelineContext.setFloat3(I,x,L,F),this}setVector4(I,x){return this._pipelineContext.setVector4(I,x),this}setQuaternion(I,x){return this._pipelineContext.setQuaternion(I,x),this}setFloat4(I,x,L,F,X){return this._pipelineContext.setFloat4(I,x,L,F,X),this}setColor3(I,x){return this._pipelineContext.setColor3(I,x),this}setColor4(I,x,L){return this._pipelineContext.setColor4(I,x,L),this}setDirectColor4(I,x){return this._pipelineContext.setDirectColor4(I,x),this}clearCodeCache(){this._vertexSourceCode="",this._fragmentSourceCode="",this._fragmentSourceCodeBeforeMigration="",this._vertexSourceCodeBeforeMigration=""}dispose(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])this._refCount=0;else{if(B.PersistentMode)return;this._refCount--}this._refCount>0||this._isDisposed||(this._pipelineContext&&(0,Y.k)(this._pipelineContext),this._engine._releaseEffect(this),this.clearCodeCache(),this._isDisposed=!0)}static RegisterShader(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;x&&(G.d.GetShadersStore(F)[`${I}PixelShader`]=x),L&&(G.d.GetShadersStore(F)[`${I}VertexShader`]=L)}static ResetCache(){B._BaseCache={}}}B.LogShaderCodeOnCompilationError=!0,B.PersistentMode=!1,B.AutomaticallyClearCodeCache=!1,B._UniqueIdSeed=0,B._BaseCache={},B.ShadersStore=G.d.ShadersStore,B.IncludesShadersStore=G.d.IncludesShadersStore},12825:(I,x,L)=>{L.d(x,{e:()=>X});const F={};function X(I){if(!(arguments.length>1&&void 0!==arguments[1]&&arguments[1])||!F[I])return F[I]=!0,`${I} needs to be imported before as it contains a side-effect required by your code.`}},12805:(I,x,L)=>{function F(){return"undefined"!==typeof window}function X(){return"undefined"!==typeof navigator}function G(){return"undefined"!==typeof document}function Y(I){let x="",L=I.firstChild;for(;L;)3===L.nodeType&&(x+=L.textContent),L=L.nextSibling;return x}L.d(x,{d:()=>Y,h:()=>G,j:()=>X,l:()=>F})},12809:(I,x,L)=>{L.d(x,{c:()=>F});class F{static _CheckLimit(I,x){let L=F._LogLimitOutputs[I];return L?L.current++:(L={limit:x,current:1},F._LogLimitOutputs[I]=L),L.current<=L.limit}static _GenerateLimitMessage(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const L=F._LogLimitOutputs[I];if(!L||!F.MessageLimitReached)return;const X=this._Levels[x];L.current===L.limit&&F[X.name](F.MessageLimitReached.replace(/%LIMIT%/g,""+L.limit).replace(/%TYPE%/g,X.name??""))}static _AddLogEntry(I){F._LogCache=I+F._LogCache,F.OnNewCacheEntry&&F.OnNewCacheEntry(I)}static _FormatMessage(I){const x=I=>I<10?"0"+I:""+I,L=new Date;return"["+x(L.getHours())+":"+x(L.getMinutes())+":"+x(L.getSeconds())+"]: "+I}static _LogDisabled(I,x){}static _LogEnabled(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,x=arguments.length>1?arguments[1]:void 0,L=arguments.length>2?arguments[2]:void 0;const X=Array.isArray(x)?x[0]:x;if(void 0!==L&&!F._CheckLimit(X,L))return;const G=F._FormatMessage(X),Y=this._Levels[I],p=Array.isArray(x)?x.slice(1):[];Y.logFunc&&Y.logFunc("BJS - "+G,...p);const B=`<div style='color:${Y.color}'>${G}</div><br>`;F._AddLogEntry(B),F._GenerateLimitMessage(X,I)}static get LogCache(){return F._LogCache}static ClearLogCache(){F._LogCache="",F._LogLimitOutputs={},F.errorsCount=0}static set LogLevels(I){F.Log=F._LogDisabled,F.Warn=F._LogDisabled,F.Error=F._LogDisabled;const x=[F.MessageLogLevel,F.WarningLogLevel,F.ErrorLogLevel];for(const L of x)if((I&L)===L){const I=this._Levels[L];F[I.name]=F._LogEnabled.bind(F,L)}}}F.NoneLogLevel=0,F.MessageLogLevel=1,F.WarningLogLevel=2,F.ErrorLogLevel=4,F.AllLogLevel=7,F.MessageLimitReached="Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.",F._LogCache="",F._LogLimitOutputs={},F._Levels=[{},{color:"white",logFunc:console.log,name:"Log"},{color:"orange",logFunc:console.warn,name:"Warn"},{},{color:"red",logFunc:console.error,name:"Error"}],F.errorsCount=0,F.Log=F._LogEnabled.bind(F,F.MessageLogLevel),F.Warn=F._LogEnabled.bind(F,F.WarningLogLevel),F.Error=F._LogEnabled.bind(F,F.ErrorLogLevel)},12797:(I,x,L)=>{L.d(x,{c:()=>Y});const F="undefined"!==typeof WeakRef;class X{constructor(I){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],L=arguments.length>2?arguments[2]:void 0,F=arguments.length>3?arguments[3]:void 0;this.initialize(I,x,L,F)}initialize(I){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],L=arguments.length>2?arguments[2]:void 0,F=arguments.length>3?arguments[3]:void 0;return this.mask=I,this.skipNextObservers=x,this.target=L,this.currentTarget=F,this}}class G{constructor(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this.callback=I,this.mask=x,this.scope=L,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this._remove&&this._remove(I)}}class Y{static FromPromise(I,x){const L=new Y;return I.then((I=>{L.notifyObservers(I)})).catch((I=>{if(!x)throw I;x.notifyObservers(I)})),L}get observers(){return this._observers}constructor(I){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.notifyIfTriggered=x,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new X(0),I&&(this._onObserverAdded=I)}add(I){let x=arguments.length>2&&void 0!==arguments[2]&&arguments[2],L=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!I)return null;const X=new G(I,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null);X.unregisterOnNextCall=L,x?this._observers.unshift(X):this._observers.push(X),this._onObserverAdded&&this._onObserverAdded(X),this._hasNotified&&this.notifyIfTriggered&&void 0!==this._lastNotifiedValue&&this.notifyObserver(X,this._lastNotifiedValue);const Y=F?new WeakRef(this):{deref:()=>this};return X._remove=function(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=Y.deref();x&&(I?x.remove(X):x._remove(X))},X}addOnce(I){return this.add(I,void 0,void 0,void 0,!0)}remove(I){if(!I)return!1;I._remove=null;return-1!==this._observers.indexOf(I)&&(this._deferUnregister(I),!0)}removeCallback(I,x){for(let L=0;L<this._observers.length;L++){const F=this._observers[L];if(!F._willBeUnregistered&&(F.callback===I&&(!x||x===F.scope)))return this._deferUnregister(F),!0}return!1}_deferUnregister(I){I._willBeUnregistered||(this._numObserversMarkedAsDeleted++,I.unregisterOnNextCall=!1,I._willBeUnregistered=!0,setTimeout((()=>{this._remove(I)}),0))}_remove(I){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!I)return!1;const L=this._observers.indexOf(I);return-1!==L&&(x&&this._numObserversMarkedAsDeleted--,this._observers.splice(L,1),!0)}makeObserverTopPriority(I){this._remove(I,!1),this._observers.unshift(I)}makeObserverBottomPriority(I){this._remove(I,!1),this._observers.push(I)}notifyObservers(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,L=arguments.length>2?arguments[2]:void 0,F=arguments.length>3?arguments[3]:void 0,X=arguments.length>4?arguments[4]:void 0;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=I),!this._observers.length)return!0;const G=this._eventState;G.mask=x,G.target=L,G.currentTarget=F,G.skipNextObservers=!1,G.lastReturnValue=I,G.userInfo=X;for(const Y of this._observers)if(!Y._willBeUnregistered&&(Y.mask&x&&(Y.unregisterOnNextCall&&this._deferUnregister(Y),Y.scope?G.lastReturnValue=Y.callback.apply(Y.scope,[I,G]):G.lastReturnValue=Y.callback(I,G)),G.skipNextObservers))return!1;return!0}notifyObserver(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=x),I._willBeUnregistered)return;const F=this._eventState;F.mask=L,F.skipNextObservers=!1,I.unregisterOnNextCall&&this._deferUnregister(I),I.callback(x,F)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const I=this._observers.pop();I&&(I._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const I=new Y;return I._observers=this._observers.slice(0),I}hasSpecificMask(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;for(const x of this._observers)if(x.mask&I||x.mask===I)return!0;return!1}}},12865:(I,x,L)=>{L.d(x,{c:()=>X,e:()=>Y});let F=[];class X{static SetImmediate(I){0===F.length&&setTimeout((()=>{const I=F;F=[];for(const x of I)x()}),1),F.push(I)}}function G(I,x,L){try{if(I())return x(),!0}catch(F){return null===L||void 0===L||L(F),!0}return!1}const Y=function(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:16,X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:3e4,Y=arguments.length>6?arguments[6]:void 0;if((!(arguments.length>5&&void 0!==arguments[5])||arguments[5])&&G(I,x,L))return null;const p=setInterval((()=>{G(I,x,L)?clearInterval(p):(X-=F,X<0&&(clearInterval(p),null===L||void 0===L||L(new Error("Operation timed out after maximum retries. "+(Y||"")),!0)))}),F);return()=>clearInterval(p)}}}]);