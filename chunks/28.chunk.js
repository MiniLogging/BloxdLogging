"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[28,29],{14038:(M,Z,P)=>{var x=P(12291),c=P(12199),w=P(12230),v=P(12325),G=P(12260),mM=P(12304);G.e.prototype._partialLoadFile=function(M,Z,P,x){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(M,(M=>{P[Z]=M,P._internalCount++,6===P._internalCount&&x(P)}),void 0,void 0,!0,((M,Z)=>{c&&M&&c(M.status+" "+M.statusText,Z)}))},G.e.prototype._cascadeLoadFiles=function(M,Z,P){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const c=[];c._internalCount=0;for(let w=0;w<6;w++)this._partialLoadFile(P[w],w,c,Z,x)},G.e.prototype._cascadeLoadImgs=function(M,Z,P,x){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,w=arguments.length>5?arguments[5]:void 0;const v=[];v._internalCount=0;for(let G=0;G<6;G++)this._partialLoadImg(x[G],G,v,M,Z,P,c,w)},G.e.prototype._partialLoadImg=function(M,Z,P,x,c,G){let mM=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,K=arguments.length>7?arguments[7]:void 0;const d=(0,v.c)();(0,w.p)(M,(M=>{P[Z]=M,P._internalCount++,x&&x.removePendingData(d),6===P._internalCount&&G&&G(c,P)}),((M,Z)=>{x&&x.removePendingData(d),mM&&mM(M,Z)}),x?x.offlineProvider:null,K),x&&x.addPendingData(d)},G.e.prototype.createCubeTextureBase=function(M,Z,P,w){let v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,K=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,O=arguments.length>8&&void 0!==arguments[8]&&arguments[8],H=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,j=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,B=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,U=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,n=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,L=arguments.length>14&&void 0!==arguments[14]&&arguments[14],u=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const N=B||new x.d(this,7);N.isCube=!0,N.url=M,N.generateMipMaps=!w,N._lodGenerationScale=H,N._lodGenerationOffset=j,N._useSRGBBuffer=!!L&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!w),N!==B&&(N.label=M.substring(0,60)),this._doNotHandleContextLost||(N._extension=d,N._files=P,N._buffer=u);const J=M;this._transformTextureUrl&&!B&&(M=this._transformTextureUrl(M));const t=d??function(M){const Z=M.split("?")[0],P=Z.lastIndexOf(".");return P>-1?Z.substring(P).toLowerCase():""}(M),F=(0,mM.b)(t),D=(M,Z)=>{N.dispose(),G?G(M,Z):M&&c.d.Warn(M)},l=(x,G)=>{M===J?x&&D(x.status+" "+x.statusText,G):(c.d.Warn(`Failed to load ${M}, falling back to the ${J}`),this.createCubeTextureBase(J,Z,P,!!w,v,D,K,d,O,H,j,N,U,n,L,u))};if(F)F.then((x=>{const c=M=>{U&&U(N,M),x.loadCubeData(M,N,O,v,((M,Z)=>{D(M,Z)}))};u?c(u):P&&6===P.length?x.supportCascades?this._cascadeLoadFiles(Z,(M=>c(M.map((M=>new Uint8Array(M))))),P,D):D("Textures type does not support cascades."):this._loadFile(M,(M=>c(new Uint8Array(M))),void 0,void 0,!0,l)}));else{if(!P||0===P.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(Z,N,((M,Z)=>{n&&n(M,Z)}),P,D)}return this._internalTexturesCache.push(N),N}},14834:(M,Z,P)=>{P.r(Z),P.d(Z,{_DDSTextureLoader:()=>w});var x=P(12549),c=P(14839);class w{constructor(){this.supportCascades=!0}loadCubeData(M,Z,P,w){const v=Z.getEngine();let G,mM=!1,K=1e3;if(Array.isArray(M))for(let x=0;x<M.length;x++){const P=M[x];G=c.DDSTools.GetDDSInfo(P),Z.width=G.width,Z.height=G.height,mM=(G.isRGB||G.isLuminance||G.mipmapCount>1)&&Z.generateMipMaps,v._unpackFlipY(G.isCompressed),c.DDSTools.UploadDDSLevels(v,Z,P,G,mM,6,-1,x),G.isFourCC||1!==G.mipmapCount?K=G.mipmapCount-1:v.generateMipMapsForCubemap(Z)}else{const w=M;G=c.DDSTools.GetDDSInfo(w),Z.width=G.width,Z.height=G.height,P&&(G.sphericalPolynomial=new x.h),mM=(G.isRGB||G.isLuminance||G.mipmapCount>1)&&Z.generateMipMaps,v._unpackFlipY(G.isCompressed),c.DDSTools.UploadDDSLevels(v,Z,w,G,mM,6),G.isFourCC||1!==G.mipmapCount?K=G.mipmapCount-1:v.generateMipMapsForCubemap(Z,!1)}v._setCubeMapTextureParams(Z,mM,K),Z.isReady=!0,Z.onLoadedObservable.notifyObservers(Z),Z.onLoadedObservable.clear(),w&&w({isDDS:!0,width:Z.width,info:G,data:M,texture:Z})}loadData(M,Z,P){const x=c.DDSTools.GetDDSInfo(M),w=(x.isRGB||x.isLuminance||x.mipmapCount>1)&&Z.generateMipMaps&&Math.max(x.width,x.height)>>x.mipmapCount-1===1;P(x.width,x.height,w,x.isFourCC,(()=>{c.DDSTools.UploadDDSLevels(Z.getEngine(),Z,M,x,w,1)}))}}},12888:(M,Z,P)=>{P.d(Z,{e:()=>K});var x=P(12373),c=P(12387),w=P(12549),v=P(12377),G=P(12406);class mM{constructor(M,Z,P,x){this.name=M,this.worldAxisForNormal=Z,this.worldAxisForFileX=P,this.worldAxisForFileY=x}}class K{static ConvertCubeMapTextureToSphericalPolynomial(M){var Z;if(!M.isCube)return null;null===(Z=M.DM())||void 0===Z||Z.getEngine().flushFramebuffer();const P=M.getSize().width,x=M.readPixels(0,void 0,void 0,!1),c=M.readPixels(1,void 0,void 0,!1);let w,v;M.isRenderTarget?(w=M.readPixels(3,void 0,void 0,!1),v=M.readPixels(2,void 0,void 0,!1)):(w=M.readPixels(2,void 0,void 0,!1),v=M.readPixels(3,void 0,void 0,!1));const G=M.readPixels(4,void 0,void 0,!1),mM=M.readPixels(5,void 0,void 0,!1),K=M.gammaSpace;let d=0;return 1!=M.textureType&&2!=M.textureType||(d=1),new Promise((M=>{Promise.all([c,x,w,v,G,mM]).then((Z=>{let[x,c,w,v,G,mM]=Z;const O={size:P,right:c,left:x,up:w,down:v,front:G,back:mM,format:5,type:d,gammaSpace:K};M(this.ConvertCubeMapToSphericalPolynomial(O))}))}))}static _AreaElement(M,Z){return Math.atan2(M*Z,Math.sqrt(M*M+Z*Z+1))}static ConvertCubeMapToSphericalPolynomial(M){const Z=new w.d;let P=0;const x=2/M.size,mM=x,K=.5*x,d=K-1;for(let w=0;w<6;w++){const O=this._FileFaces[w],H=M[O.name];let j=d;const B=5===M.format?4:3;for(let w=0;w<M.size;w++){let U=d;for(let mM=0;mM<M.size;mM++){const d=O.worldAxisForFileX.scale(U).add(O.worldAxisForFileY.scale(j)).add(O.worldAxisForNormal);d.normalize();const n=this._AreaElement(U-K,j-K)-this._AreaElement(U-K,j+K)-this._AreaElement(U+K,j-K)+this._AreaElement(U+K,j+K);let L=H[w*M.size*B+mM*B+0],u=H[w*M.size*B+mM*B+1],N=H[w*M.size*B+mM*B+2];isNaN(L)&&(L=0),isNaN(u)&&(u=0),isNaN(N)&&(N=0),0===M.type&&(L/=255,u/=255,N/=255),M.gammaSpace&&(L=Math.pow((0,c.Clamp)(L),v.g),u=Math.pow((0,c.Clamp)(u),v.g),N=Math.pow((0,c.Clamp)(N),v.g));const J=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const M=Math.max(L,u,N);if(M>J){const Z=J/M;L*=Z,u*=Z,N*=Z}}else L=(0,c.Clamp)(L,0,J),u=(0,c.Clamp)(u,0,J),N=(0,c.Clamp)(N,0,J);const t=new G.uZ(L,u,N);Z.addLight(d,t,n),P+=n,U+=x}j+=mM}}const O=6*(4*Math.PI)/6/P;return Z.scaleInPlace(O),Z.convertIncidentRadianceToIrradiance(),Z.convertIrradianceToLambertianRadiance(),w.h.FromHarmonics(Z)}}K._FileFaces=[new mM("right",new x.BZ(1,0,0),new x.BZ(0,0,-1),new x.BZ(0,-1,0)),new mM("left",new x.BZ(-1,0,0),new x.BZ(0,0,1),new x.BZ(0,-1,0)),new mM("up",new x.BZ(0,1,0),new x.BZ(1,0,0),new x.BZ(0,0,1)),new mM("down",new x.BZ(0,-1,0),new x.BZ(1,0,0),new x.BZ(0,0,-1)),new mM("front",new x.BZ(0,0,1),new x.BZ(1,0,0),new x.BZ(0,-1,0)),new mM("back",new x.BZ(0,0,-1),new x.BZ(-1,0,0),new x.BZ(0,-1,0))],K.MAX_HDRI_VALUE=4096,K.PRESERVE_CLAMPED_COLORS=!1},14839:(M,Z,P)=>{P.d(Z,{DDSTools:()=>B});var x=P(12387),c=P(12199),w=P(12888),v=P(12581);P(14038);const G=131072,mM=131072;function K(M){return M.charCodeAt(0)+(M.charCodeAt(1)<<8)+(M.charCodeAt(2)<<16)+(M.charCodeAt(3)<<24)}const d=K("DXT1"),O=K("DXT3"),H=K("DXT5"),j=K("DX10");class B{static GetDDSInfo(M){const Z=new Int32Array(M.buffer,M.byteOffset,31),P=new Int32Array(M.buffer,M.byteOffset,35);let x=1;Z[2]&G&&(x=Math.max(1,Z[7]));const c=Z[21],w=c===j?P[32]:0;let v=0;switch(c){case 113:v=2;break;case 116:v=1;break;case j:if(10===w){v=2;break}if(2===w){v=1;break}}return{width:Z[4],height:Z[3],mipmapCount:x,isFourCC:4===(4&Z[20]),isRGB:64===(64&Z[20]),isLuminance:(Z[20]&mM)===mM,isCube:512===(512&Z[28]),isCompressed:c===d||c===O||c===H,dxgiFormat:w,textureType:v}}static _GetHalfFloatAsFloatRGBAArrayBuffer(M,Z,P,x,c,w){const G=new Float32Array(x),mM=new Uint16Array(c,P);let K=0;for(let d=0;d<Z;d++)for(let Z=0;Z<M;Z++){const P=4*(Z+d*M);G[K]=(0,v.f)(mM[P]),G[K+1]=(0,v.f)(mM[P+1]),G[K+2]=(0,v.f)(mM[P+2]),B.StoreLODInAlphaChannel?G[K+3]=w:G[K+3]=(0,v.f)(mM[P+3]),K+=4}return G}static _GetHalfFloatRGBAArrayBuffer(M,Z,P,x,c,w){if(B.StoreLODInAlphaChannel){const G=new Uint16Array(x),mM=new Uint16Array(c,P);let K=0;for(let P=0;P<Z;P++)for(let Z=0;Z<M;Z++){const x=4*(Z+P*M);G[K]=mM[x],G[K+1]=mM[x+1],G[K+2]=mM[x+2],G[K+3]=(0,v.p)(w),K+=4}return G}return new Uint16Array(c,P,x)}static _GetFloatRGBAArrayBuffer(M,Z,P,x,c,w){if(B.StoreLODInAlphaChannel){const v=new Float32Array(x),G=new Float32Array(c,P);let mM=0;for(let P=0;P<Z;P++)for(let Z=0;Z<M;Z++){const x=4*(Z+P*M);v[mM]=G[x],v[mM+1]=G[x+1],v[mM+2]=G[x+2],v[mM+3]=w,mM+=4}return v}return new Float32Array(c,P,x)}static _GetFloatAsHalfFloatRGBAArrayBuffer(M,Z,P,x,c,w){const G=new Uint16Array(x),mM=new Float32Array(c,P);let K=0;for(let d=0;d<Z;d++)for(let Z=0;Z<M;Z++)G[K]=(0,v.p)(mM[K]),G[K+1]=(0,v.p)(mM[K+1]),G[K+2]=(0,v.p)(mM[K+2]),B.StoreLODInAlphaChannel?G[K+3]=(0,v.p)(w):G[K+3]=(0,v.p)(mM[K+3]),K+=4;return G}static _GetFloatAsUIntRGBAArrayBuffer(M,Z,P,c,w,v){const G=new Uint8Array(c),mM=new Float32Array(w,P);let K=0;for(let d=0;d<Z;d++)for(let Z=0;Z<M;Z++){const P=4*(Z+d*M);G[K]=255*(0,x.Clamp)(mM[P]),G[K+1]=255*(0,x.Clamp)(mM[P+1]),G[K+2]=255*(0,x.Clamp)(mM[P+2]),B.StoreLODInAlphaChannel?G[K+3]=v:G[K+3]=255*(0,x.Clamp)(mM[P+3]),K+=4}return G}static _GetHalfFloatAsUIntRGBAArrayBuffer(M,Z,P,c,w,G){const mM=new Uint8Array(c),K=new Uint16Array(w,P);let d=0;for(let O=0;O<Z;O++)for(let Z=0;Z<M;Z++){const P=4*(Z+O*M);mM[d]=255*(0,x.Clamp)((0,v.f)(K[P])),mM[d+1]=255*(0,x.Clamp)((0,v.f)(K[P+1])),mM[d+2]=255*(0,x.Clamp)((0,v.f)(K[P+2])),B.StoreLODInAlphaChannel?mM[d+3]=G:mM[d+3]=255*(0,x.Clamp)((0,v.f)(K[P+3])),d+=4}return mM}static _GetRGBAArrayBuffer(M,Z,P,x,c,w,v,G,mM){const K=new Uint8Array(x),d=new Uint8Array(c,P);let O=0;for(let H=0;H<Z;H++)for(let Z=0;Z<M;Z++){const P=4*(Z+H*M);K[O]=d[P+w],K[O+1]=d[P+v],K[O+2]=d[P+G],K[O+3]=d[P+mM],O+=4}return K}static _ExtractLongWordOrder(M){return 0===M||255===M||-16777216===M?0:1+B._ExtractLongWordOrder(M>>8)}static _GetRGBArrayBuffer(M,Z,P,x,c,w,v,G){const mM=new Uint8Array(x),K=new Uint8Array(c,P);let d=0;for(let O=0;O<Z;O++)for(let Z=0;Z<M;Z++){const P=3*(Z+O*M);mM[d]=K[P+w],mM[d+1]=K[P+v],mM[d+2]=K[P+G],d+=3}return mM}static _GetLuminanceArrayBuffer(M,Z,P,x,c){const w=new Uint8Array(x),v=new Uint8Array(c,P);let G=0;for(let mM=0;mM<Z;mM++)for(let Z=0;Z<M;Z++){const P=Z+mM*M;w[G]=v[P],G++}return w}static UploadDDSLevels(M,Z,P,x,v,mM){let K=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,U=arguments.length>7?arguments[7]:void 0,n=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],L=null;x.sphericalPolynomial&&(L=[]);const u=!!M.getCaps().s3tc;Z.generateMipMaps=v;const N=new Int32Array(P.buffer,P.byteOffset,31);let J,t,F,D,l,h,Q,I=0,s=0,C=1;if(542327876!==N[0])return void c.d.Error("Invalid magic number in DDS header");if(!x.isFourCC&&!x.isRGB&&!x.isLuminance)return void c.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(x.isCompressed&&!u)return void c.d.Error("Compressed textures are not supported on this platform.");let R=N[22];D=N[1]+4;let W=!1;if(x.isFourCC)switch(J=N[21],J){case d:C=8,s=33777;break;case O:C=16,s=33778;break;case H:C=16,s=33779;break;case 113:W=!0,R=64;break;case 116:W=!0,R=128;break;case j:{D+=20;let M=!1;switch(x.dxgiFormat){case 10:W=!0,R=64,M=!0;break;case 2:W=!0,R=128,M=!0;break;case 88:x.isRGB=!0,x.isFourCC=!1,R=32,M=!0}if(M)break}default:return void c.d.Error(["Unsupported FourCC code:",(k=J,String.fromCharCode(255&k,k>>8&255,k>>16&255,k>>24&255))])}var k;const A=B._ExtractLongWordOrder(N[23]),o=B._ExtractLongWordOrder(N[24]),E=B._ExtractLongWordOrder(N[25]),r=B._ExtractLongWordOrder(N[26]);W&&(s=M._getRGBABufferInternalSizedFormat(x.textureType)),h=1,N[2]&G&&!1!==v&&(h=Math.max(1,N[7]));const q=U||0,e=M.getCaps();for(let c=q;c<mM;c++){for(t=N[4],F=N[3],Q=0;Q<h;++Q){if(-1===K||K===Q){const w=-1===K?Q:0;if(!x.isCompressed&&x.isFourCC){Z.format=5,I=t*F*4;let x=null;if(M._badOS||M._badDesktopOS||!e.textureHalfFloat&&!e.textureFloat)128===R?(x=B._GetFloatAsUIntRGBAArrayBuffer(t,F,P.byteOffset+D,I,P.buffer,w),L&&0==w&&L.push(B._GetFloatRGBAArrayBuffer(t,F,P.byteOffset+D,I,P.buffer,w))):64===R&&(x=B._GetHalfFloatAsUIntRGBAArrayBuffer(t,F,P.byteOffset+D,I,P.buffer,w),L&&0==w&&L.push(B._GetHalfFloatAsFloatRGBAArrayBuffer(t,F,P.byteOffset+D,I,P.buffer,w))),Z.type=0;else{const M=e.textureFloat&&(n&&e.textureFloatLinearFiltering||!n),c=e.textureHalfFloat&&(n&&e.textureHalfFloatLinearFiltering||!n),v=(128===R||64===R&&!c)&&M?1:(64===R||128===R&&!M)&&c?2:0;let G,mM=null;if(128===R)switch(v){case 1:G=B._GetFloatRGBAArrayBuffer,mM=null;break;case 2:G=B._GetFloatAsHalfFloatRGBAArrayBuffer,mM=B._GetFloatRGBAArrayBuffer;break;case 0:G=B._GetFloatAsUIntRGBAArrayBuffer,mM=B._GetFloatRGBAArrayBuffer}else switch(v){case 1:G=B._GetHalfFloatAsFloatRGBAArrayBuffer,mM=null;break;case 2:G=B._GetHalfFloatRGBAArrayBuffer,mM=B._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:G=B._GetHalfFloatAsUIntRGBAArrayBuffer,mM=B._GetHalfFloatAsFloatRGBAArrayBuffer}Z.type=v,x=G(t,F,P.byteOffset+D,I,P.buffer,w),L&&0==w&&L.push(mM?mM(t,F,P.byteOffset+D,I,P.buffer,w):x)}x&&M._uploadDataToTextureDirectly(Z,x,c,w)}else if(x.isRGB)Z.type=0,24===R?(Z.format=4,I=t*F*3,l=B._GetRGBArrayBuffer(t,F,P.byteOffset+D,I,P.buffer,A,o,E),M._uploadDataToTextureDirectly(Z,l,c,w)):(Z.format=5,I=t*F*4,l=B._GetRGBAArrayBuffer(t,F,P.byteOffset+D,I,P.buffer,A,o,E,r),M._uploadDataToTextureDirectly(Z,l,c,w));else if(x.isLuminance){const x=M._getUnpackAlignement(),v=t;I=Math.floor((t+x-1)/x)*x*(F-1)+v,l=B._GetLuminanceArrayBuffer(t,F,P.byteOffset+D,I,P.buffer),Z.format=1,Z.type=0,M._uploadDataToTextureDirectly(Z,l,c,w)}else I=Math.max(4,t)/4*Math.max(4,F)/4*C,l=new Uint8Array(P.buffer,P.byteOffset+D,I),Z.type=0,M._uploadCompressedDataToTextureDirectly(Z,s,t,F,l,c,w)}D+=R?t*F*(R/8):I,t*=.5,F*=.5,t=Math.max(1,t),F=Math.max(1,F)}if(void 0!==U)break}L&&L.length>0?x.sphericalPolynomial=w.e.ConvertCubeMapToSphericalPolynomial({size:N[4],right:L[0],left:L[1],up:L[2],down:L[3],front:L[4],back:L[5],format:5,type:1,gammaSpace:!1}):x.sphericalPolynomial=void 0}}B.StoreLODInAlphaChannel=!1}}]);