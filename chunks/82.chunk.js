"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[82],{14125:(n,k,T)=>{T.r(k),T.d(k,{FlowGraphWaitAllBlock:()=>w});var c=T(12875),K=T(675),Q=T(12831),G=T(12829);class w extends c.c{constructor(n){super(n),this.config=n,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",Q.j,new G.d(this.config.inputSignalCount||0));for(let k=0;k<this.config.inputSignalCount;k++)this.inFlows.push(this._registerSignalInput(`in_${k}`));this._unregisterSignalInput("in")}_getCurrentActivationState(n){const k=this._cachedActivationState;if(k.length=0,n._hasExecutionVariable(this,"activationState")){const T=n._getExecutionVariable(this,"activationState",[]);for(let n=0;n<T.length;n++)k.push(T[n])}else for(let T=0;T<this.config.inputSignalCount;T++)k.push(!1);return k}_execute(n,k){const T=this._getCurrentActivationState(n);if(k===this.reset)for(let c=0;c<this.config.inputSignalCount;c++)T[c]=!1;else{const n=this.inFlows.indexOf(k);n>=0&&(T[n]=!0)}if(this.remainingInputs.setValue(new G.d(T.filter((n=>!n)).length),n),n._setExecutionVariable(this,"activationState",T.slice()),T.includes(!1))k!==this.reset&&this.out._activateSignal(n);else{this.completed._activateSignal(n);for(let n=0;n<this.config.inputSignalCount;n++)T[n]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(n){super.serialize(n),n.config.inputFlows=this.config.inputSignalCount}}(0,K.f)("FlowGraphWaitAllBlock",w)}}]);