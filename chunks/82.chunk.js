"use strict";(self["6xhfpmwgjr5"]=self["6xhfpmwgjr5"]||[]).push([[82,83],{16418:(P,a,R)=>{R.r(a),R.d(a,{_ENVTextureLoader:()=>G});var S=R(14310),A=R(14173),Z=R(14184),p=R(14170),j=R(13984),U=R(14223),Q=(R(15127),R(15221)),h=R(14057);R(15218),R(16422),R(15267);const l="image/png",V=[134,22,135,150,246,214,150,54];function f(P){const a=new DataView(P.buffer,P.byteOffset,P.byteLength);let R=0;for(let p=0;p<V.length;p++)if(a.getUint8(R++)!==V[p])return h.d.Error("Not a babylon environment map"),null;let S="",A=0;for(;A=a.getUint8(R++);)S+=String.fromCharCode(A);let Z=JSON.parse(S);return Z=O(Z),Z.binaryDataPosition=R,Z.Zh&&(Z.Zh.lodGenerationScale=Z.Zh.lodGenerationScale||.8),Z}function O(P){if(P.version>2)throw new Error(`Unsupported babylon environment map version "${P.version}". Latest supported version is "2".`);return 2===P.version?P:P={...P,version:2,imageType:l}}function q(P,a){const R=(a=O(a)).Zh;let S=Math.log2(a.width);if(S=Math.round(S)+1,R.mipmaps.length!==6*S)throw new Error(`Unsupported specular mipmaps number "${R.mipmaps.length}"`);const A=new Array(S);for(let Z=0;Z<S;Z++){A[Z]=new Array(6);for(let S=0;S<6;S++){const p=R.mipmaps[6*Z+S];A[Z][S]=new Uint8Array(P.buffer,P.byteOffset+a.binaryDataPosition+p.position,p.length)}}return A}function y(P,a){var R;a=O(a);const S=new Array(6),A=null===(R=a.irradiance)||void 0===R?void 0:R.irradianceTexture;if(A){if(6!==A.faces.length)throw new Error(`Incorrect irradiance texture faces number "${A.faces.length}"`);for(let R=0;R<6;R++){const Z=A.faces[R];S[R]=new Uint8Array(P.buffer,P.byteOffset+a.binaryDataPosition+Z.position,Z.length)}}return S}function t(P,a,R){var S;const Z=(R=O(R)).Zh;if(!Z)return Promise.resolve([]);P._lodGenerationScale=Z.lodGenerationScale;const p=[],j=q(a,R);p.push(k(P,j,R.imageType));const U=null===(S=R.irradiance)||void 0===S?void 0:S.irradianceTexture;if(U){var Q,h;const S=y(a,R);let Z=null;null!==(Q=R.irradiance)&&void 0!==Q&&null!==(h=Q.irradianceTexture)&&void 0!==h&&h.dominantDirection&&(Z=A.p.ka(R.irradiance.irradianceTexture.dominantDirection)),p.push(x(P,S,U.size,R.imageType,Z))}return Promise.all(p)}async function W(P,a,R,S,A,Z,p,j,U,Q,h){return await new Promise(((l,V)=>{if(R){const R=a.createTexture(null,!0,!0,null,1,null,(P=>{V(P)}),P);null===S||void 0===S||S.onEffectCreatedObservable.addOnce((j=>{j.executeWhenCompiled((()=>{S.externalTextureSamplerBinding=!0,S.onApply=S=>{S._bindTexture("textureSampler",R),S.setFloat2("scale",1,a._features.needsInvertingBitmap&&P instanceof ImageBitmap?-1:1)},a.scenes.length&&(a.scenes[0].postProcessManager.directRender([S],Q,!0,Z,p),a.restoreDefaultFramebuffer(),R.dispose(),URL.revokeObjectURL(A),l())}))}))}else{if(a._uploadImageToTexture(h,P,Z,p),j){const R=U[p];R&&a._uploadImageToTexture(R._texture,P,Z,0)}l()}}))}async function k(P,a){let R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:l;const S=P.getEngine();P.format=5,P.type=0,P.generateMipMaps=!0,P._cachedAnisotropicFilteringLevel=null,S.updateTextureSamplingMode(3,P),await s(P,a,!0,R),P.isReady=!0}async function x(P,a,R){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:l,A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const Z=P.getEngine(),p=new j.e(Z,5),Q=new U.c(Z,p);P._irradianceTexture=Q,Q._dominantDirection=A,p.isCube=!0,p.format=5,p.type=0,p.generateMipMaps=!0,p._cachedAnisotropicFilteringLevel=null,p.generateMipMaps=!0,p.width=R,p.height=R,Z.updateTextureSamplingMode(3,p),await s(p,[a],!1,S),Z.generateMipMapsForCubemap(p),p.isReady=!0}async function s(P,a,A){let p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:l;if(!S.h.IsExponentOfTwo(P.width))throw new Error("Texture size must be a power of two");const h=(0,Z.f)(P.width)+1,V=P.getEngine();let f=!1,O=!1,q=null,y=null,t=null;const k=V.getCaps();k.textureLOD?V._features.supportRenderAndCopyToLodForFloatTextures?k.textureHalfFloatRender&&k.textureHalfFloatLinearFiltering?(f=!0,P.type=2):k.textureFloatRender&&k.textureFloatLinearFiltering&&(f=!0,P.type=1):f=!1:(f=!1,O=A);let x=0;if(f)V.isWebGPU?(x=1,await R.e(148).then(R.bind(R,17223))):await R.e(149).then(R.bind(R,17225)),q=new Q.b("rgbdDecode","rgbdDecode",null,null,1,null,3,V,!1,void 0,P.type,void 0,null,!1,void 0,x),P._isRGBD=!1,P.invertY=!1,y=V.createRenderTargetCubeTexture(P.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:P.type,format:5});else if(P._isRGBD=!0,P.invertY=!0,O){const a=3;t={};const R=P._lodGenerationScale,S=P._lodGenerationOffset;for(let A=0;A<a;A++){const Z=(h-1)*R+S,p=S+(Z-S)*(1-A/(a-1)),Q=Math.round(Math.min(Math.max(p,0),Z)),l=new j.e(V,2);l.isCube=!0,l.invertY=!0,l.generateMipMaps=!1,V.updateTextureSamplingMode(2,l);const f=new U.c(null);switch(f._isCube=!0,f._texture=l,t[Q]=f,A){case 0:P._lodTextureLow=f;break;case 1:P._lodTextureMid=f;break;case 2:P._lodTextureHigh=f}}}const s=[];for(let R=0;R<a.length;R++)for(let S=0;S<6;S++){const A=a[R][S],Z=new Blob([A],{type:p}),j=URL.createObjectURL(Z);let U;if(V._features.forceBitmapOverHTMLImageElement)U=V.createImageBitmap(Z,{premultiplyAlpha:"none"}).then((async a=>await W(a,V,f,q,j,S,R,O,t,y,P)));else{const a=new Image;a.src=j,U=new Promise(((A,Z)=>{a.onload=()=>{W(a,V,f,q,j,S,R,O,t,y,P).then((()=>A())).catch((P=>{Z(P)}))},a.onerror=P=>{Z(P)}}))}s.push(U)}if(await Promise.all(s),a.length<h){let R;const S=Math.pow(2,h-1-a.length),A=S*S*4;switch(P.type){case 0:R=new Uint8Array(A);break;case 2:R=new Uint16Array(A);break;case 1:R=new Float32Array(A)}for(let Z=a.length;Z<h;Z++)for(let a=0;a<6;a++){var d;V._uploadArrayBufferViewToTexture((null===(d=y)||void 0===d?void 0:d.texture)||P,R,a,Z)}}if(y){const a=P._irradianceTexture;P._irradianceTexture=null,V._releaseTexture(P),y._swapAndDie(P),P._irradianceTexture=a}q&&q.dispose(),O&&(P._lodTextureHigh&&P._lodTextureHigh._texture&&(P._lodTextureHigh._texture.isReady=!0),P._lodTextureMid&&P._lodTextureMid._texture&&(P._lodTextureMid._texture.isReady=!0),P._lodTextureLow&&P._lodTextureLow._texture&&(P._lodTextureLow._texture.isReady=!0))}function d(P,a){const R=(a=O(a)).irradiance;if(!R)return;const S=new p.h;A.p.FromArrayToRef(R.x,0,S.x),A.p.FromArrayToRef(R.y,0,S.y),A.p.FromArrayToRef(R.z,0,S.z),A.p.FromArrayToRef(R.xx,0,S.xx),A.p.FromArrayToRef(R.yy,0,S.yy),A.p.FromArrayToRef(R.zz,0,S.zz),A.p.FromArrayToRef(R.yz,0,S.yz),A.p.FromArrayToRef(R.zx,0,S.zx),A.p.FromArrayToRef(R.xy,0,S.xy),P._sphericalPolynomial=S}class G{constructor(){this.supportCascades=!1}loadCubeData(P,a,R,S,A){if(Array.isArray(P))return;const Z=f(P);if(Z){a.width=Z.width,a.height=Z.width;try{d(a,Z),t(a,P,Z).then((()=>{a.isReady=!0,a.onLoadedObservable.notifyObservers(a),a.onLoadedObservable.clear(),S&&S()}),(P=>{null===A||void 0===A||A("Can not upload environment levels",P)}))}catch(p){null===A||void 0===A||A("Can not upload environment file",p)}}else A&&A("Can not parse the environment file",null)}loadData(){throw".env not supported in 2d."}}},16422:(P,a,R)=>{R.r(a),R.d(a,{Dispose:()=>V,DumpData:()=>l,DumpDataAsync:()=>h,DumpFramebuffer:()=>Q,DumpTools:()=>f});var S=R(15224),A=R(14310),Z=R(14184),p=R(14009);let j,U=null;async function Q(P,a,R,S){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",Z=arguments.length>5?arguments[5]:void 0,p=arguments.length>6?arguments[6]:void 0;const j=await R.readPixels(0,0,P,a);l(P,a,new Uint8Array(j.buffer),S,A,Z,!0,void 0,p)}async function h(P,a,R){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"image/png",A=arguments.length>4?arguments[4]:void 0,Z=arguments.length>5&&void 0!==arguments[5]&&arguments[5],p=arguments.length>6&&void 0!==arguments[6]&&arguments[6],j=arguments.length>7?arguments[7]:void 0;return await new Promise((U=>{l(P,a,R,(P=>U(P)),S,A,Z,p,j)}))}function l(P,a,Q,h){let l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",f=arguments.length>5?arguments[5]:void 0,O=arguments.length>6&&void 0!==arguments[6]&&arguments[6],q=arguments.length>7&&void 0!==arguments[7]&&arguments[7],y=arguments.length>8?arguments[8]:void 0;(async function(){return U||(U=new Promise(((P,a)=>{let A,Z=null;const U={Sj:!0,depth:!1,gp:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};Promise.resolve().then(R.bind(R,14014)).then((Q=>{let{ThinEngine:h}=Q;const l=p.e.Instances.length;try{A=new OffscreenCanvas(100,100),Z=new h(A,!1,U)}catch(q){var f;l<p.e.Instances.length&&(null===(f=p.e.Instances.pop())||void 0===f||f.dispose()),A=document.createElement("canvas"),Z=new h(A,!1,U)}p.e.Instances.pop(),p.e.OnEnginesDisposedObservable.add((P=>{Z&&P!==Z&&!Z.U&&0===p.e.Instances.length&&V()})),Z.getCaps().parallelShaderCompile=void 0;const O=new S.b(Z);R.e(158).then(R.bind(R,17274)).then((R=>{let{passPixelShader:p}=R;if(!Z)return void a("Engine is not defined");const U=new S.d({fa:Z,name:p.name,fragmentShader:p.shader,samplerNames:["textureSampler"]});j={canvas:A,fa:Z,renderer:O,wrapper:U},P(j)}))})).catch(a)}))),await U})().then((R=>{if(R.fa.setSize(P,a,!0),Q instanceof Float32Array){const P=new Uint8Array(Q.length);let a=Q.length;for(;a--;){const R=Q[a];P[a]=Math.round(255*(0,Z.e)(R))}Q=P}const S=R.fa.createRawTexture(Q,P,a,5,!1,!O,1);R.renderer.setViewport(),R.renderer.applyEffectWrapper(R.wrapper),R.wrapper.effect._bindTexture("textureSampler",S),R.renderer.draw(),q?A.h.ToBlob(R.canvas,(P=>{const a=new FileReader;a.onload=P=>{const a=P.target.result;h&&h(a)},a.readAsArrayBuffer(P)}),l,y):A.h.EncodeScreenshotCanvasData(R.canvas,h,l,f,y),S.dispose()}))}function V(){var P;j?(j.wrapper.dispose(),j.renderer.dispose(),j.fa.dispose()):null===(P=U)||void 0===P||P.then((P=>{P.wrapper.dispose(),P.renderer.dispose(),P.fa.dispose()}));U=null,j=null}const f={DumpData:l,DumpDataAsync:h,DumpFramebuffer:Q,Dispose:V};A.h.DumpData=l,A.h.DumpDataAsync=h,A.h.DumpFramebuffer=Q}}]);