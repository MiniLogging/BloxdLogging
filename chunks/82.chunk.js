"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[82],{14107:(U,M,b)=>{b.r(M),b.d(M,{FlowGraphWaitAllBlock:()=>y});var a=b(12830),A=b(609),H=b(12775),W=b(12767);class y extends a.e{constructor(U){super(U),this.config=U,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",H.i,new W.e(this.config.inputSignalCount||0));for(let M=0;M<this.config.inputSignalCount;M++)this.inFlows.push(this._registerSignalInput(`in_${M}`));this._unregisterSignalInput("in")}_getCurrentActivationState(U){const M=this._cachedActivationState;if(M.length=0,U._hasExecutionVariable(this,"activationState")){const b=U._getExecutionVariable(this,"activationState",[]);for(let U=0;U<b.length;U++)M.push(b[U])}else for(let b=0;b<this.config.inputSignalCount;b++)M.push(!1);return M}_execute(U,M){const b=this._getCurrentActivationState(U);if(M===this.reset)for(let a=0;a<this.config.inputSignalCount;a++)b[a]=!1;else{const U=this.inFlows.indexOf(M);U>=0&&(b[U]=!0)}if(this.remainingInputs.setValue(new W.e(b.filter((U=>!U)).length),U),U._setExecutionVariable(this,"activationState",b.slice()),b.includes(!1))M!==this.reset&&this.out._activateSignal(U);else{this.completed._activateSignal(U);for(let U=0;U<this.config.inputSignalCount;U++)b[U]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(U){super.serialize(U),U.config.inputFlows=this.config.inputSignalCount}}(0,A.i)("FlowGraphWaitAllBlock",y)}}]);