"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[82],{13969:(J,T,b)=>{b.r(T),b.d(T,{FlowGraphWaitAllBlock:()=>Y});var q=b(12647),t=b(639),j=b(12603),B=b(12598);class Y extends q.c{constructor(J){super(J),this.config=J,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",j.i,new B.e(this.config.inputSignalCount||0));for(let T=0;T<this.config.inputSignalCount;T++)this.inFlows.push(this._registerSignalInput(`in_${T}`));this._unregisterSignalInput("in")}_getCurrentActivationState(J){const T=this._cachedActivationState;if(T.length=0,J._hasExecutionVariable(this,"activationState")){const b=J._getExecutionVariable(this,"activationState",[]);for(let J=0;J<b.length;J++)T.push(b[J])}else for(let b=0;b<this.config.inputSignalCount;b++)T.push(!1);return T}_execute(J,T){const b=this._getCurrentActivationState(J);if(T===this.reset)for(let q=0;q<this.config.inputSignalCount;q++)b[q]=!1;else{const J=this.inFlows.indexOf(T);J>=0&&(b[J]=!0)}if(this.remainingInputs.setValue(new B.e(b.filter((J=>!J)).length),J),J._setExecutionVariable(this,"activationState",b.slice()),b.includes(!1))T!==this.reset&&this.out._activateSignal(J);else{this.completed._activateSignal(J);for(let J=0;J<this.config.inputSignalCount;J++)b[J]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(J){super.serialize(J),J.config.inputFlows=this.config.inputSignalCount}}(0,t.g)("FlowGraphWaitAllBlock",Y)}}]);