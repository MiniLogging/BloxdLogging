"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[82],{13843:(W,F,c)=>{c.r(F),c.d(F,{FlowGraphWaitAllBlock:()=>A});var T=c(12566),Y=c(642),Z=c(12517),w=c(12512);class A extends T.c{constructor(W){super(W),this.config=W,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",Z.f,new w.c(this.config.inputSignalCount||0));for(let F=0;F<this.config.inputSignalCount;F++)this.inFlows.push(this._registerSignalInput(`in_${F}`));this._unregisterSignalInput("in")}_getCurrentActivationState(W){const F=this._cachedActivationState;if(F.length=0,W._hasExecutionVariable(this,"activationState")){const c=W._getExecutionVariable(this,"activationState",[]);for(let W=0;W<c.length;W++)F.push(c[W])}else for(let c=0;c<this.config.inputSignalCount;c++)F.push(!1);return F}_execute(W,F){const c=this._getCurrentActivationState(W);if(F===this.reset)for(let T=0;T<this.config.inputSignalCount;T++)c[T]=!1;else{const W=this.inFlows.indexOf(F);W>=0&&(c[W]=!0)}if(this.remainingInputs.setValue(new w.c(c.filter((W=>!W)).length),W),W._setExecutionVariable(this,"activationState",c.slice()),c.includes(!1))F!==this.reset&&this.out._activateSignal(W);else{this.completed._activateSignal(W);for(let W=0;W<this.config.inputSignalCount;W++)c[W]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(W){super.serialize(W),W.config.inputFlows=this.config.inputSignalCount}}(0,Y.h)("FlowGraphWaitAllBlock",A)}}]);