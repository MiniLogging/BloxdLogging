"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[82],{13919:(A,X,s)=>{s.r(X),s.d(X,{FlowGraphWaitAllBlock:()=>K});var N=s(12724),f=s(616),E=s(12677),g=s(12672);class K extends N.e{constructor(A){super(A),this.config=A,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",E.f,new g.e(this.config.inputSignalCount||0));for(let X=0;X<this.config.inputSignalCount;X++)this.inFlows.push(this._registerSignalInput(`in_${X}`));this._unregisterSignalInput("in")}_getCurrentActivationState(A){const X=this._cachedActivationState;if(X.length=0,A._hasExecutionVariable(this,"activationState")){const s=A._getExecutionVariable(this,"activationState",[]);for(let A=0;A<s.length;A++)X.push(s[A])}else for(let s=0;s<this.config.inputSignalCount;s++)X.push(!1);return X}_execute(A,X){const s=this._getCurrentActivationState(A);if(X===this.reset)for(let N=0;N<this.config.inputSignalCount;N++)s[N]=!1;else{const A=this.inFlows.indexOf(X);A>=0&&(s[A]=!0)}if(this.remainingInputs.setValue(new g.e(s.filter((A=>!A)).length),A),A._setExecutionVariable(this,"activationState",s.slice()),s.includes(!1))X!==this.reset&&this.out._activateSignal(A);else{this.completed._activateSignal(A);for(let A=0;A<this.config.inputSignalCount;A++)s[A]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(A){super.serialize(A),A.config.inputFlows=this.config.inputSignalCount}}(0,f.f)("FlowGraphWaitAllBlock",K)}}]);