"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[82],{14247:(u,F,z)=>{z.r(F),z.d(F,{FlowGraphWaitAllBlock:()=>I});var p=z(13003),b=z(668),R=z(12952),c=z(12944);class I extends p.e{constructor(u){super(u),this.config=u,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",R.l,new c.d(this.config.inputSignalCount||0));for(let F=0;F<this.config.inputSignalCount;F++)this.inFlows.push(this._registerSignalInput(`in_${F}`));this._unregisterSignalInput("in")}_getCurrentActivationState(u){const F=this._cachedActivationState;if(F.length=0,u._hasExecutionVariable(this,"activationState")){const z=u._getExecutionVariable(this,"activationState",[]);for(let u=0;u<z.length;u++)F.push(z[u])}else for(let z=0;z<this.config.inputSignalCount;z++)F.push(!1);return F}_execute(u,F){const z=this._getCurrentActivationState(u);if(F===this.reset)for(let p=0;p<this.config.inputSignalCount;p++)z[p]=!1;else{const u=this.inFlows.indexOf(F);u>=0&&(z[u]=!0)}if(this.remainingInputs.setValue(new c.d(z.filter((u=>!u)).length),u),u._setExecutionVariable(this,"activationState",z.slice()),z.includes(!1))F!==this.reset&&this.out._activateSignal(u);else{this.completed._activateSignal(u);for(let u=0;u<this.config.inputSignalCount;u++)z[u]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(u){super.serialize(u),u.config.inputFlows=this.config.inputSignalCount}}(0,b.h)("FlowGraphWaitAllBlock",I)}}]);