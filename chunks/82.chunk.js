"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[82],{14124:(P,Q,O)=>{O.r(Q),O.d(Q,{FlowGraphWaitAllBlock:()=>q});var b=O(12922),F=O(696),g=O(12871),m=O(12867);class q extends b.b{constructor(P){super(P),this.config=P,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",g.h,new m.c(this.config.inputSignalCount||0));for(let Q=0;Q<this.config.inputSignalCount;Q++)this.inFlows.push(this._registerSignalInput(`in_${Q}`));this._unregisterSignalInput("in")}_getCurrentActivationState(P){const Q=this._cachedActivationState;if(Q.length=0,P._hasExecutionVariable(this,"activationState")){const O=P._getExecutionVariable(this,"activationState",[]);for(let P=0;P<O.length;P++)Q.push(O[P])}else for(let O=0;O<this.config.inputSignalCount;O++)Q.push(!1);return Q}_execute(P,Q){const O=this._getCurrentActivationState(P);if(Q===this.reset)for(let b=0;b<this.config.inputSignalCount;b++)O[b]=!1;else{const P=this.inFlows.indexOf(Q);P>=0&&(O[P]=!0)}if(this.remainingInputs.setValue(new m.c(O.filter((P=>!P)).length),P),P._setExecutionVariable(this,"activationState",O.slice()),O.includes(!1))Q!==this.reset&&this.out._activateSignal(P);else{this.completed._activateSignal(P);for(let P=0;P<this.config.inputSignalCount;P++)O[P]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(P){super.serialize(P),P.config.inputFlows=this.config.inputSignalCount}}(0,F.f)("FlowGraphWaitAllBlock",q)}}]);