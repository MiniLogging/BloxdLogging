"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[33],{13469:(x,O,Q)=>{Q.r(O),Q.d(O,{_TGATextureLoader:()=>o});var X=Q(10905);function Z(x){let O=0;return{id_length:x[O++],colormap_type:x[O++],image_type:x[O++],colormap_index:x[O++]|x[O++]<<8,colormap_length:x[O++]|x[O++]<<8,colormap_size:x[O++],origin:[x[O++]|x[O++]<<8,x[O++]|x[O++]<<8],width:x[O++]|x[O++]<<8,height:x[O++]|x[O++]<<8,pixel_size:x[O++],flags:x[O++]}}function n(x,O){if(O.length<19)return void X.e.Error("Unable to load TGA file - Not enough data to contain header");let Q=18;const n=Z(O);if(n.id_length+Q>O.length)return void X.e.Error("Unable to load TGA file - Not enough data");Q+=n.id_length;let o,l=!1,C=!1,U=!1;switch(n.image_type){case 9:l=!0;case 1:C=!0;break;case 10:l=!0;case 2:break;case 11:l=!0;case 3:U=!0}const L=n.pixel_size>>3,h=n.width*n.height*L;let N,a,K,M,Y,g,v;if(C&&(N=O.subarray(Q,Q+=n.colormap_length*(n.colormap_size>>3))),l){let x,X,Z;o=new Uint8Array(h);let n=0;const V=new Uint8Array(L);for(;Q<h&&n<h;)if(x=O[Q++],X=1+(127&x),128&x){for(Z=0;Z<L;++Z)V[Z]=O[Q++];for(Z=0;Z<X;++Z)o.set(V,n+Z*L);n+=L*X}else{for(X*=L,Z=0;Z<X;++Z)o[n+Z]=O[Q++];n+=X}}else o=O.subarray(Q,Q+=C?n.width*n.height:h);switch((48&n.flags)>>4){default:case 2:a=0,M=1,v=n.width,K=0,Y=1,g=n.height;break;case 0:a=0,M=1,v=n.width,K=n.height-1,Y=-1,g=-1;break;case 3:a=n.width-1,M=-1,v=-1,K=0,Y=1,g=n.height;break;case 1:a=n.width-1,M=-1,v=-1,K=n.height-1,Y=-1,g=-1}const R="_getImageData"+(U?"Grey":"")+n.pixel_size+"bits",s=V[R](n,N,o,K,Y,g,a,M,v);x.getEngine()._uploadDataToTextureDirectly(x,s)}const V={GetTGAHeader:Z,UploadContent:n,_getImageData8bits:function(x,O,Q,X,Z,n,V,o,l){const C=Q,U=O,L=x.width,h=x.height;let N,a,K,M=0;const Y=new Uint8Array(L*h*4);for(K=X;K!==n;K+=Z)for(a=V;a!==l;a+=o,M++)N=C[M],Y[4*(a+L*K)+3]=255,Y[4*(a+L*K)+2]=U[3*N+0],Y[4*(a+L*K)+1]=U[3*N+1],Y[4*(a+L*K)+0]=U[3*N+2];return Y},_getImageData16bits:function(x,O,Q,X,Z,n,V,o,l){const C=Q,U=x.width,L=x.height;let h,N,a,K=0;const M=new Uint8Array(U*L*4);for(a=X;a!==n;a+=Z)for(N=V;N!==l;N+=o,K+=2){h=C[K+0]+(C[K+1]<<8);const x=255*((31744&h)>>10)/31|0,O=255*((992&h)>>5)/31|0,Q=255*(31&h)/31|0;M[4*(N+U*a)+0]=x,M[4*(N+U*a)+1]=O,M[4*(N+U*a)+2]=Q,M[4*(N+U*a)+3]=32768&h?0:255}return M},_getImageData24bits:function(x,O,Q,X,Z,n,V,o,l){const C=Q,U=x.width,L=x.height;let h,N,a=0;const K=new Uint8Array(U*L*4);for(N=X;N!==n;N+=Z)for(h=V;h!==l;h+=o,a+=3)K[4*(h+U*N)+3]=255,K[4*(h+U*N)+2]=C[a+0],K[4*(h+U*N)+1]=C[a+1],K[4*(h+U*N)+0]=C[a+2];return K},_getImageData32bits:function(x,O,Q,X,Z,n,V,o,l){const C=Q,U=x.width,L=x.height;let h,N,a=0;const K=new Uint8Array(U*L*4);for(N=X;N!==n;N+=Z)for(h=V;h!==l;h+=o,a+=4)K[4*(h+U*N)+2]=C[a+0],K[4*(h+U*N)+1]=C[a+1],K[4*(h+U*N)+0]=C[a+2],K[4*(h+U*N)+3]=C[a+3];return K},_getImageDataGrey8bits:function(x,O,Q,X,Z,n,V,o,l){const C=Q,U=x.width,L=x.height;let h,N,a,K=0;const M=new Uint8Array(U*L*4);for(a=X;a!==n;a+=Z)for(N=V;N!==l;N+=o,K++)h=C[K],M[4*(N+U*a)+0]=h,M[4*(N+U*a)+1]=h,M[4*(N+U*a)+2]=h,M[4*(N+U*a)+3]=255;return M},_getImageDataGrey16bits:function(x,O,Q,X,Z,n,V,o,l){const C=Q,U=x.width,L=x.height;let h,N,a=0;const K=new Uint8Array(U*L*4);for(N=X;N!==n;N+=Z)for(h=V;h!==l;h+=o,a+=2)K[4*(h+U*N)+0]=C[a+0],K[4*(h+U*N)+1]=C[a+0],K[4*(h+U*N)+2]=C[a+0],K[4*(h+U*N)+3]=C[a+1];return K}};class o{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(x,O,Q){const X=new Uint8Array(x.buffer,x.byteOffset,x.byteLength),V=Z(X);Q(V.width,V.height,O.generateMipMaps,!1,(()=>{n(O,X)}))}}}}]);