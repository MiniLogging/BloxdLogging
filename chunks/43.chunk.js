"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12814:(M,E,b)=>{b.r(E),b.d(E,{AnimationGroup:()=>C,TargetedAnimation:()=>c});var x=b(12117),k=b(962),a=b(1005),g=b(1126),n=b(12114),J=b(970);class u{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(M,E,b,k){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=E,this._target=M,this._scene=b,this._host=k,this._activeTargets=[],E._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===x.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=J.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const M={frame:0,value:this._minValue};this._keys.splice(0,0,M)}if(this._target instanceof Array){let M=0;for(const E of this._target)this._preparePath(E,M),this._getOriginalValues(M),M++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const a=E.getEvents();a&&a.length>0&&a.forEach((M=>{this._events.push(M._clone())})),this._enableBlending=M&&M.animationPropertiesOverride?M.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(M){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=this._animation.targetPropertyPath;if(b.length>1){let x=M;for(let M=0;M<b.length-1;M++){const E=b[M];if(x=x[E],void 0===x)throw new Error(`Invalid property (${E}) in property path (${b.join(".")})`)}this._targetPath=b[b.length-1],this._activeTargets[E]=x}else this._targetPath=b[0],this._activeTargets[E]=M;if(void 0===this._activeTargets[E][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${b.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let M=0;for(const E of this._target)void 0!==this._originalValue[M]&&this._setValue(E,this._activeTargets[M],this._originalValue[M],-1,M),M++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let M=0;M<this._events.length;M++)this._events[M].isDone=!1}isStopped(){return this._stopped}dispose(){const M=this._animation.runtimeAnimations.indexOf(this);M>-1&&this._animation.runtimeAnimations.splice(M,1)}setValue(M,E){if(this._targetIsArray)for(let b=0;b<this._target.length;b++){const x=this._target[b];this._setValue(x,this._activeTargets[b],M,E,b)}else this._setValue(this._target,this._directTarget,M,E,0)}_getOriginalValues(){let M,E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=this._activeTargets[E];M=b.getLocalMatrix&&"_matrix"===this._targetPath?b.getLocalMatrix():b[this._targetPath],M&&M.clone?this._originalValue[E]=M.clone():this._originalValue[E]=M}_registerTargetForLateAnimationBinding(M,E){const b=M.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(b),b._lateAnimationHolders||(b._lateAnimationHolders={}),b._lateAnimationHolders[M.targetPath]||(b._lateAnimationHolders[M.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:E}),M.isAdditive?(b._lateAnimationHolders[M.targetPath].additiveAnimations.push(M),b._lateAnimationHolders[M.targetPath].totalAdditiveWeight+=M.weight):(b._lateAnimationHolders[M.targetPath].animations.push(M),b._lateAnimationHolders[M.targetPath].totalWeight+=M.weight)}_setValue(M,E,b,k,a){if(this._currentActiveTarget=E,this._weight=k,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const M=E[this._targetPath];M.clone?this._originalBlendValue=M.clone():this._originalBlendValue=M}this._originalBlendValue.m?x.d.AllowMatrixDecomposeForInterpolation?this._currentValue?J.d.DecomposeLerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=J.d.DecomposeLerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue?J.d.LerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=J.d.Lerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue=x.d._UniversalLerp(this._originalBlendValue,b,this._blendingFactor);const k=M&&M.animationPropertiesOverride?M.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=k}else this._currentValue?this._currentValue.p?this._currentValue.p(b):this._currentValue=b:null!==b&&void 0!==b&&b.clone?this._currentValue=b.clone():this._currentValue=b;-1!==k?this._registerTargetForLateAnimationBinding(this,this._originalValue[a]):this._animationState.loopMode===x.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[a],E[this._targetPath]):E[this._targetPath]=this._originalValue[a]+this._currentValue:E[this._targetPath]=this._currentValue,M.ge&&M.ge(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(M){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const b=this._animation.getKeys();M<b[0].frame?M=b[0].frame:M>b[b.length-1].frame&&(M=b[b.length-1].frame);const x=this._events;if(x.length)for(let a=0;a<x.length;a++)x[a].onlyOnce||(x[a].isDone=x[a].frame<M);this._currentFrame=M;const k=this._animation._interpolate(M,this._animationState);this.setValue(k,E)}_prepareForSpeedRatioChange(M){const E=this._previousElapsedTime*(this._animation.framePerSecond*M)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-E}animate(M,E,b,k,a){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const n=this._animation,J=n.targetPropertyPath;if(!J||J.length<1)return this._stopped=!0,!1;let u=!0;(E<this._minFrame||E>this._maxFrame)&&(E=this._minFrame),(b<this._minFrame||b>this._maxFrame)&&(b=this._maxFrame);const T=b-E;let V,I=M*(n.framePerSecond*a)/1e3+this._absoluteFrameOffset,t=0,y=!1;const B=k&&this._animationState.loopMode===x.d.ANIMATIONLOOPMODE_YOYO;if(B){const M=(I-E)/T,b=Math.sin(M*Math.PI);I=Math.abs(b)*T+E;const x=b>=0?1:-1;this._yoyoDirection!==x&&(y=!0),this._yoyoDirection=x}if(this._previousElapsedTime=M,this._previousAbsoluteFrame=I,!k&&b>=E&&(I>=T&&a>0||I<=0&&a<0))u=!1,t=n._getKeyValue(this._maxValue);else if(!k&&E>=b&&(I<=T&&a<0||I>=0&&a>0))u=!1,t=n._getKeyValue(this._minValue);else if(this._animationState.loopMode!==x.d.ANIMATIONLOOPMODE_CYCLE){const M=b.toString()+E.toString();if(!this._offsetsCache[M]){this._animationState.repeatCount=0,this._animationState.loopMode=x.d.ANIMATIONLOOPMODE_CYCLE;const k=n._interpolate(E,this._animationState),a=n._interpolate(b,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),n.dataType){case x.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[M]=a-k;break;case x.d.ANIMATIONTYPE_QUATERNION:case x.d.ANIMATIONTYPE_VECTOR3:case x.d.ANIMATIONTYPE_VECTOR2:case x.d.ANIMATIONTYPE_SIZE:case x.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[M]=a.Qc(k)}this._highLimitsCache[M]=a}t=this._highLimitsCache[M],V=this._offsetsCache[M]}if(void 0===V)switch(n.dataType){case x.d.ANIMATIONTYPE_FLOAT:V=0;break;case x.d.ANIMATIONTYPE_QUATERNION:V=x.n;break;case x.d.ANIMATIONTYPE_VECTOR3:V=x.y;break;case x.d.ANIMATIONTYPE_VECTOR2:V=x.u;break;case x.d.ANIMATIONTYPE_SIZE:V=x.q;break;case x.d.ANIMATIONTYPE_COLOR3:V=x.h;break;case x.d.ANIMATIONTYPE_COLOR4:V=x.k}let r;if(this._host&&this._host.syncRoot){const M=this._host.syncRoot;r=E+T*((M.masterFrame-M.fromFrame)/(M.toFrame-M.fromFrame))}else r=I>0&&E>b||I<0&&E<b?u&&0!==T?b+I%T:E:u&&0!==T?E+I%T:b;const c=this._events;if(!B&&(a>0&&this.currentFrame>r||a<0&&this.currentFrame<r)||B&&y){this._onLoop();for(let M=0;M<c.length;M++)c[M].onlyOnce||(c[M].isDone=!1);this._animationState.key=a>0?0:n.getKeys().length-1}this._currentFrame=r,this._animationState.repeatCount=0===T?0:I/T|0,this._animationState.highLimitValue=t,this._animationState.offsetValue=V;const C=n._interpolate(r,this._animationState);if(this.setValue(C,g),c.length)for(let x=0;x<c.length;x++)if(T>=0&&r>=c[x].frame&&c[x].frame>=E||T<0&&r<=c[x].frame&&c[x].frame<=E){const M=c[x];M.isDone||(M.onlyOnce&&(c.splice(x,1),x--),M.isDone=!0,M.action(r))}return u||(this._stopped=!0),u}}var T=b(1099);class V{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(M){this._weight=-1!==M?Math.min(Math.max(M,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(M){for(let E=0;E<this._runtimeAnimations.length;E++){this._runtimeAnimations[E]._prepareForSpeedRatioChange(M)}this._speedRatio=M,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(M,E){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,n=arguments.length>6?arguments[6]:void 0,J=arguments.length>7?arguments[7]:void 0,u=arguments.length>8?arguments[8]:void 0,T=arguments.length>9&&void 0!==arguments[9]&&arguments[9],V=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=E,this.fromFrame=b,this.toFrame=x,this.loopAnimation=a,this.onAnimationEnd=n,this.onAnimationLoop=u,this.isAdditive=T,this.playOrder=V,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.yd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new k.b,this.onAnimationLoopObservable=new k.b,this._scene=M,J&&this.appendAnimations(E,J),this._speedRatio=g,M._activeAnimatables.push(this)}syncWith(M){if(this._syncRoot=M,M){const M=this._scene._activeAnimatables.indexOf(this);M>-1&&(this._scene._activeAnimatables.splice(M,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(M,E){for(let b=0;b<E.length;b++){const x=E[b],k=new u(M,x,this._scene,this);k._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(k)}}getAnimationByTargetProperty(M){const E=this._runtimeAnimations;for(let b=0;b<E.length;b++)if(E[b].animation.targetProperty===M)return E[b].animation;return null}getRuntimeAnimationByTargetProperty(M){const E=this._runtimeAnimations;for(let b=0;b<E.length;b++)if(E[b].animation.targetProperty===M)return E[b];return null}reset(){const M=this._runtimeAnimations;for(let E=0;E<M.length;E++)M[E].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(M){const E=this._runtimeAnimations;for(let b=0;b<E.length;b++)E[b].animation.enableBlending=!0,E[b].animation.blendingSpeed=M}disableBlending(){const M=this._runtimeAnimations;for(let E=0;E<M.length;E++)M[E].animation.enableBlending=!1}goToFrame(M){const E=this._runtimeAnimations;if(E[0]){const b=E[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??E[0].currentFrame;const x=0===this.speedRatio?0:(M-this._frameToSyncFromJump)/b*1e3/this.speedRatio;this._manualJumpDelay=-x}for(let b=0;b<E.length;b++)E[b].goToFrame(M,this._weight);this._goToFrame=M}get paused(){return this.yd}pause(){this.yd||(this.yd=!0)}restart(){this.yd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(M,E){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(M||E){const k=this._scene._activeAnimatables.indexOf(this);if(k>-1){const a=this._runtimeAnimations;for(let b=a.length-1;b>=0;b--){const x=a[b];M&&x.animation.name!=M||(E&&!E(x.target)||(x.dispose(),a.splice(b,1)))}0==a.length&&(b||this._scene._activeAnimatables.splice(k,1),x||this._raiseOnAnimationEnd())}}else{const M=this._scene._activeAnimatables.indexOf(this);if(M>-1){b||this._scene._activeAnimatables.splice(M,1);const E=this._runtimeAnimations;for(let M=0;M<E.length;M++)E[M].dispose();this._runtimeAnimations.length=0,x||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((M=>{this.onAnimationEndObservable.add((()=>{M(this)}),void 0,void 0,this,!0)}))}_animate(M){if(this.yd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=M),!0;if(null===this._localDelayOffset?(this._localDelayOffset=M,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=M-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let E=!1;const b=this._runtimeAnimations;let x;for(x=0;x<b.length;x++){const k=b[x].animate(M-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);E=E||k}if(this.animationStarted=E,!E){if(this.disposeOnEnd)for(x=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(x,1),x=0;x<b.length;x++)b[x].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return E}}function I(M){if(0===M.totalWeight&&0===M.totalAdditiveWeight)return M.originalValue;let E=1;const b=J.i.Fd[0],x=J.i.Fd[1],k=J.i.Quaternion[0];let a=0;const g=M.animations[0],n=M.originalValue;let u=1,T=!1;if(M.totalWeight<1)u=1-M.totalWeight,n.decompose(x,k,b);else{if(a=1,E=M.totalWeight,u=g.weight/E,1==u){if(!M.totalAdditiveWeight)return g.currentValue;T=!0}g.currentValue.decompose(x,k,b)}if(!T){x.scaleInPlace(u),b.scaleInPlace(u),k.scaleInPlace(u);for(let g=a;g<M.animations.length;g++){const a=M.animations[g];if(0===a.weight)continue;u=a.weight/E;const n=J.i.Fd[2],T=J.i.Fd[3],V=J.i.Quaternion[1];a.currentValue.decompose(T,V,n),T.scaleAndAddToRef(u,x),V.scaleAndAddToRef(J.e.Dot(k,V)>0?u:-u,k),n.scaleAndAddToRef(u,b)}k.normalize()}for(let I=0;I<M.additiveAnimations.length;I++){const E=M.additiveAnimations[I];if(0===E.weight)continue;const a=J.i.Fd[2],g=J.i.Fd[3],n=J.i.Quaternion[1];E.currentValue.decompose(g,n,a),g.multiplyToRef(x,g),J.m.LerpToRef(x,g,E.weight,x),k.multiplyToRef(n,n),J.e.SlerpToRef(k,n,E.weight,k),a.scaleAndAddToRef(E.weight,b)}const V=g?g._animationState.workValue:J.i.Matrix[0].clone();return J.d.ComposeToRef(x,k,b,V),V}function t(M,E){if(0===M.totalWeight&&0===M.totalAdditiveWeight)return E;const b=M.animations[0],x=M.originalValue;let k=E;if(0===M.totalWeight&&M.totalAdditiveWeight>0)k.p(x);else if(1===M.animations.length){if(J.e.SlerpToRef(x,b.currentValue,Math.min(1,M.totalWeight),k),0===M.totalAdditiveWeight)return k}else if(M.animations.length>1){let b,a,g=1;if(M.totalWeight<1){const E=1-M.totalWeight;b=[],a=[],b.push(x),a.push(E)}else{if(2===M.animations.length&&(J.e.SlerpToRef(M.animations[0].currentValue,M.animations[1].currentValue,M.animations[1].weight/M.totalWeight,E),0===M.totalAdditiveWeight))return E;b=[],a=[],g=M.totalWeight}for(let E=0;E<M.animations.length;E++){const x=M.animations[E];b.push(x.currentValue),a.push(x.weight/g)}let n=0;for(let M=0;M<b.length;)M?(n+=a[M],J.e.SlerpToRef(k,b[M],a[M]/n,k),M++):(J.e.SlerpToRef(b[M],b[M+1],a[M+1]/(a[M]+a[M+1]),E),k=E,n=a[M]+a[M+1],M+=2)}for(let a=0;a<M.additiveAnimations.length;a++){const E=M.additiveAnimations[a];0!==E.weight&&(k.multiplyToRef(E.currentValue,J.i.Quaternion[0]),J.e.SlerpToRef(k,J.i.Quaternion[0],E.weight,k))}return k}var y,B,r=b(1171);y=r.d,(B=n.b)&&(B.prototype.copyAnimationRange=function(M,E,b){let k=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new x.d(this.name,"_matrix",M.animations[0].framePerSecond,x.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const g=M.animations[0].getRange(E);if(!g)return!1;const n=g.from,J=g.to,u=M.animations[0].getKeys(),T=M.length,V=M.getParent(),I=this.getParent(),t=k&&V&&T&&this.length&&T!==this.length,y=t&&I&&V?I.length/V.length:1,B=k&&!I&&a&&(1!==a.x||1!==a.y||1!==a.z),r=this.animations[0].getKeys();let c,C,R;for(let x=0,w=u.length;x<w;x++)c=u[x],c.frame>=n&&c.frame<=J&&(k?(R=c.value.clone(),t?(C=R.getTranslation(),R.setTranslation(C.scaleInPlace(y))):B&&a?(C=R.getTranslation(),R.setTranslation(C.multiplyInPlace(a))):R=c.value):R=c.value,r.push({frame:c.frame+b,value:R}));return this.animations[0].createRange(E,n+b,J+b),!0}),y&&(y.prototype._animate=function(M){if(!this.animationsEnabled)return;const E=T.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=E}this.deltaTime=void 0!==M?M:this.useConstantAnimationDeltaTime?16:(E-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=E;const b=this._activeAnimatables;if(0===b.length)return;this._animationTime+=this.deltaTime;const k=this._animationTime;for(let x=0;x<b.length;x++){const M=b[x];!M._animate(k)&&M.disposeOnEnd&&x--}!function(M){if(M._registeredForLateAnimationBindings.length){for(let E=0;E<M._registeredForLateAnimationBindings.length;E++){const b=M._registeredForLateAnimationBindings.data[E];for(const M in b._lateAnimationHolders){const E=b._lateAnimationHolders[M],k=E.animations[0],a=E.originalValue;if(void 0===a||null===a)continue;const g=x.d.AllowMatrixDecomposeForInterpolation&&a.m;let n=b[M];if(g)n=I(E);else if(void 0!==a.w)n=t(E,n||J.e.Identity());else{let M=0,b=1;const g=k&&k._animationState.loopMode===x.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(E.totalWeight<1)n=g?a.clone?a.clone():a:k&&a.scale?a.scale(1-E.totalWeight):k?a*(1-E.totalWeight):a.clone?a.clone():a;else if(k){b=E.totalWeight;const x=k.weight/b;n=1!==x?k.currentValue.scale?k.currentValue.scale(x):k.currentValue*x:k.currentValue,g&&(n.addToRef?n.addToRef(a,n):n+=a),M=1}for(let x=M;x<E.animations.length;x++){const M=E.animations[x],k=M.weight/b;k&&(M.currentValue.scaleAndAddToRef?M.currentValue.scaleAndAddToRef(k,n):n+=M.currentValue*k)}for(let x=0;x<E.additiveAnimations.length;x++){const M=E.additiveAnimations[x],b=M.weight;b&&(M.currentValue.scaleAndAddToRef?M.currentValue.scaleAndAddToRef(b,n):n+=M.currentValue*b)}}b[M]=n}b._lateAnimationHolders={}}M._registeredForLateAnimationBindings.reset()}}(this)},y.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((M,E)=>M.playOrder-E.playOrder))},y.prototype.beginWeightedAnimation=function(M,E,b){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,k=arguments.length>4?arguments[4]:void 0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,n=arguments.length>7?arguments[7]:void 0,J=arguments.length>8?arguments[8]:void 0,u=arguments.length>9?arguments[9]:void 0,T=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const V=this.beginAnimation(M,E,b,k,a,g,n,!1,J,u,T);return V.weight=x,V},y.prototype.beginAnimation=function(M,E,b,x){let k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,a=arguments.length>5?arguments[5]:void 0,g=arguments.length>6?arguments[6]:void 0,n=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],J=arguments.length>8?arguments[8]:void 0,u=arguments.length>9?arguments[9]:void 0,T=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(k<0){const M=E;E=b,b=M,k=-k}E>b&&(k=-k),n&&this.stopAnimation(M,void 0,J),g||(g=new V(this,M,E,b,x,k,a,void 0,u,T));const I=!J||J(M);if(M.animations&&I&&g.appendAnimations(M,M.animations),M.getAnimatables){const T=M.getAnimatables();for(let M=0;M<T.length;M++)this.beginAnimation(T[M],E,b,x,k,a,g,n,J,u)}return g.reset(),g},y.prototype.beginHierarchyAnimation=function(M,E,b,x,k){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,n=arguments.length>7?arguments[7]:void 0,J=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],u=arguments.length>9?arguments[9]:void 0,T=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const V=M.getDescendants(E),I=[];I.push(this.beginAnimation(M,b,x,k,a,g,n,J,u,void 0,T));for(const t of V)I.push(this.beginAnimation(t,b,x,k,a,g,n,J,u,void 0,T));return I},y.prototype.beginDirectAnimation=function(M,E,b,x,k){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(a<0){const M=b;b=x,x=M,a=-a}return b>x&&(a=-a),new V(this,M,b,x,k,a,arguments.length>6?arguments[6]:void 0,E,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},y.prototype.beginDirectHierarchyAnimation=function(M,E,b,x,k,a,g,n,J){let u=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const T=M.getDescendants(E),V=[];V.push(this.beginDirectAnimation(M,b,x,k,a,g,n,J,u));for(const I of T)V.push(this.beginDirectAnimation(I,b,x,k,a,g,n,J,u));return V},y.prototype.getAnimatableByTarget=function(M){for(let E=0;E<this._activeAnimatables.length;E++)if(this._activeAnimatables[E].target===M)return this._activeAnimatables[E];return null},y.prototype.getAllAnimatablesByTarget=function(M){const E=[];for(let b=0;b<this._activeAnimatables.length;b++)this._activeAnimatables[b].target===M&&E.push(this._activeAnimatables[b]);return E},y.prototype.stopAnimation=function(M,E,b){const x=this.getAllAnimatablesByTarget(M);for(const k of x)k.stop(E,b)},y.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let M=0;M<this._activeAnimatables.length;M++)this._activeAnimatables[M].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const M of this.animationGroups)M.stop()});class c{getClassName(){return"TargetedAnimation"}serialize(){const M={};return M.animation=this.animation.serialize(),M.targetId=this.target.id,M}}class C{get mask(){return this._mask}set mask(M){this._mask!==M&&(this._mask=M,this.syncWithMask(!0))}syncWithMask(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||M){this._numActiveAnimatables=0;for(let M=0;M<this._animatables.length;++M){const E=this._animatables[M];!this.mask||this.mask.disabled||this.mask.retainsTarget(E.target.name)?(this._numActiveAnimatables++,E.paused&&E.restart()):E.paused||E.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let M=0;M<this._animatables.length;++M){const E=this._animatables[M];this.mask.retainsTarget(E.target.name)||(E.stop(),this._animatables.splice(M,1),--M)}for(let M=0;M<this._targetedAnimations.length;M++){const E=this._targetedAnimations[M];this.mask.retainsTarget(E.target.name)||(this._targetedAnimations.splice(M,1),--M)}}}get from(){return this._from}set from(M){if(this._from!==M){this._from=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].fromFrame=this._from}}}get to(){return this._to}set to(M){if(this._to!==M){this._to=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(M){if(this._speedRatio!==M){this._speedRatio=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(M){if(this._loopAnimation!==M){this._loopAnimation=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(M){if(this._isAdditive!==M){this._isAdditive=M;for(let M=0;M<this._animatables.length;M++){this._animatables[M].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(M){this._weight!==M&&(this._weight=M,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(M){if(this._playOrder!==M&&(this._playOrder=M,this._animatables.length>0)){for(let M=0;M<this._animatables.length;M++)this._animatables[M].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(M){if(this._enableBlending!==M&&(this._enableBlending=M,null!==M))for(let E=0;E<this._targetedAnimations.length;++E)this._targetedAnimations[E].animation.enableBlending=M}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(M){if(this._blendingSpeed!==M&&(this._blendingSpeed=M,null!==M))for(let E=0;E<this._targetedAnimations.length;++E)this._targetedAnimations[E].animation.blendingSpeed=M}getLength(M,E){M=M??this._from;return((E=E??this._to)-M)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(M){let E=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=arguments.length>3?arguments[3]:void 0;if(0===M.length)return null;x=x??M[0].weight;let k=Number.MAX_VALUE,a=-Number.MAX_VALUE;if(b)for(const n of M)n.from<k&&(k=n.from),n.to>a&&(a=n.to);const g=new C(M[0].name+"_merged",M[0]._scene,x);for(const n of M){b&&n.normalize(k,a);for(const M of n.targetedAnimations)g.addTargetedAnimation(M.animation,M.target);E&&n.dispose()}return g}constructor(M){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=M,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new k.b,this.onAnimationLoopObservable=new k.b,this.onAnimationGroupLoopObservable=new k.b,this.onAnimationGroupEndObservable=new k.b,this.onAnimationGroupPauseObservable=new k.b,this.onAnimationGroupPlayObservable=new k.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=E||a.b.LastCreatedScene,this._weight=b,this._playOrder=x,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(M,E){const b=new c;b.animation=M,b.target=E;const x=M.getKeys();return this._from>x[0].frame&&(this._from=x[0].frame),this._to<x[x.length-1].frame&&(this._to=x[x.length-1].frame),null!==this._enableBlending&&(M.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(M.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(b),this._shouldStart=!0,b}removeTargetedAnimation(M){for(let E=this._targetedAnimations.length-1;E>-1;E--){this._targetedAnimations[E].animation===M&&this._targetedAnimations.splice(E,1)}}normalize(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==M&&(M=this._from),null==E&&(E=this._to);for(let b=0;b<this._targetedAnimations.length;b++){const x=this._targetedAnimations[b].animation.getKeys(),k=x[0],a=x[x.length-1];if(k.frame>M){const E={frame:M,value:k.value,inTangent:k.inTangent,outTangent:k.outTangent,interpolation:k.interpolation};x.splice(0,0,E)}if(a.frame<E){const M={frame:E,value:a.value,inTangent:a.inTangent,outTangent:a.outTangent,interpolation:a.interpolation};x.push(M)}}return this._from=M,this._to=E,this}_processLoop(M,E,b){M.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(E),this._animationLoopFlags[b]||(this._animationLoopFlags[b]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0],E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0,x=arguments.length>3?arguments[3]:void 0,k=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=M,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let a=0;a<this._targetedAnimations.length;a++){const g=this._targetedAnimations[a],n=this._scene.beginDirectAnimation(g.target,[g.animation],void 0!==b?b:this._from,void 0!==x?x:this._to,M,E,void 0,void 0,void 0!==k?k:this._isAdditive);n.weight=this._weight,n.playOrder=this._playOrder,n.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(g),this._checkAnimationGroupEnded(n)},this._processLoop(n,g,a),this._animatables.push(n)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=E,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let M=0;M<this._animatables.length;M++){this._animatables[M].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(M){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==M&&(this.loopAnimation=M),this.restart()):(this.stop(),this.start(M,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let M=0;M<this._animatables.length;M++){this._animatables[M].reset()}return this}restart(){if(!this._isStarted)return this;for(let M=0;M<this._animatables.length;M++){this._animatables[M].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const E=this._animatables.slice();for(let x=0;x<E.length;x++)E[x].stop(void 0,void 0,!0,M);let b=0;for(let x=0;x<this._scene._activeAnimatables.length;x++){const E=this._scene._activeAnimatables[x];E._runtimeAnimations.length>0?this._scene._activeAnimatables[b++]=E:M&&this._checkAnimationGroupEnded(E,M)}return this._scene._activeAnimatables.length=b,this._isStarted=!1,this}setWeightForAllAnimatables(M){for(let E=0;E<this._animatables.length;E++){this._animatables[E].weight=M}return this}syncAllAnimationsWith(M){for(let E=0;E<this._animatables.length;E++){this._animatables[E].syncWith(M)}return this}goToFrame(M){if(!this._isStarted)return this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].goToFrame(M)}return this}getCurrentFrame(){var M;return(null===(M=this.animatables[0])||void 0===M?void 0:M.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const M=this._scene.animationGroups.indexOf(this);if(M>-1&&this._scene.animationGroups.splice(M,1),this._parentContainer){const M=this._parentContainer.animationGroups.indexOf(this);M>-1&&this._parentContainer.animationGroups.splice(M,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(M){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._animatables.indexOf(M);b>-1&&this._animatables.splice(b,1),0===this._animatables.length&&(this._isStarted=!1,E||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(M,E){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const x=new C(M||this.name,this._scene,this._weight,this._playOrder);x._from=this.from,x._to=this.to,x._speedRatio=this.speedRatio,x._loopAnimation=this.loopAnimation,x._isAdditive=this.isAdditive,x._enableBlending=this.enableBlending,x._blendingSpeed=this.blendingSpeed,x.metadata=this.metadata,x.mask=this.mask;for(const k of this._targetedAnimations)x.addTargetedAnimation(b?k.animation.clone():k.animation,E?E(k.target):k.target);return x}serialize(){const M={};M.name=this.name,M.from=this.from,M.to=this.to,M.speedRatio=this.speedRatio,M.loopAnimation=this.loopAnimation,M.isAdditive=this.isAdditive,M.weight=this.weight,M.playOrder=this.playOrder,M.enableBlending=this.enableBlending,M.blendingSpeed=this.blendingSpeed,M.targetedAnimations=[];for(let E=0;E<this.targetedAnimations.length;E++){const b=this.targetedAnimations[E];M.targetedAnimations[E]=b.serialize()}return g.b&&g.b.HasTags(this)&&(M.tags=g.b.GetTags(this)),this.metadata&&(M.metadata=this.metadata),M}static Parse(M,E){const b=new C(M.name,E,M.weight,M.playOrder);for(let k=0;k<M.targetedAnimations.length;k++){const a=M.targetedAnimations[k],g=x.d.Parse(a.animation),n=a.targetId;if("influence"===a.animation.property){const M=E.getMorphTargetById(n);M&&b.addTargetedAnimation(g,M)}else{const M=E.getNodeById(n);null!=M&&b.addTargetedAnimation(g,M)}}return g.b&&g.b.AddTagsTo(b,M.tags),null!==M.from&&null!==M.to&&b.normalize(M.from,M.to),void 0!==M.speedRatio&&(b._speedRatio=M.speedRatio),void 0!==M.loopAnimation&&(b._loopAnimation=M.loopAnimation),void 0!==M.isAdditive&&(b._isAdditive=M.isAdditive),void 0!==M.weight&&(b._weight=M.weight),void 0!==M.playOrder&&(b._playOrder=M.playOrder),void 0!==M.enableBlending&&(b._enableBlending=M.enableBlending),void 0!==M.blendingSpeed&&(b._blendingSpeed=M.blendingSpeed),void 0!==M.metadata&&(b.metadata=M.metadata),b}static MakeAnimationAdditive(M,E,b){let k;k="object"===typeof E?E:{referenceFrame:E,range:b,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let a=M;k.cloneOriginalAnimationGroup&&(a=M.clone(k.clonedAnimationGroupName||a.name));const g=a.targetedAnimations;for(let n=0;n<g.length;n++){const M=g[n];M.animation=x.d.MakeAnimationAdditive(M.animation,k)}if(a.isAdditive=!0,k.clipKeys){let M=Number.MAX_VALUE,E=-Number.MAX_VALUE;const b=a.targetedAnimations;for(let x=0;x<b.length;x++){const k=b[x].animation.getKeys();M>k[0].frame&&(M=k[0].frame),E<k[k.length-1].frame&&(E=k[k.length-1].frame)}a._from=M,a._to=E}return a}static ClipKeys(M,E,b,x,k){const a=M.clone(x||M.name);return C.ClipKeysInPlace(a,E,b,k)}static ClipKeysInPlace(M,E,b,x){return C.ClipInPlace(M,E,b,x,!1)}static ClipFrames(M,E,b,x,k){const a=M.clone(x||M.name);return C.ClipFramesInPlace(a,E,b,k)}static ClipFramesInPlace(M,E,b,x){return C.ClipInPlace(M,E,b,x,!0)}static ClipInPlace(M,E,b,x){let k=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=Number.MAX_VALUE,g=-Number.MAX_VALUE;const n=M.targetedAnimations;for(let J=0;J<n.length;J++){const M=n[J],u=x?M.animation:M.animation.clone();k&&(u.createKeyForFrame(E),u.createKeyForFrame(b));const T=u.getKeys(),V=[];let I=Number.MAX_VALUE;for(let x=0;x<T.length;x++){const M=T[x];if(!k&&x>=E&&x<=b||k&&M.frame>=E&&M.frame<=b){const E={frame:M.frame,value:M.value.clone?M.value.clone():M.value,inTangent:M.inTangent,outTangent:M.outTangent,interpolation:M.interpolation,lockedTangent:M.lockedTangent};I===Number.MAX_VALUE&&(I=E.frame),E.frame-=I,V.push(E)}}0!==V.length?(a>V[0].frame&&(a=V[0].frame),g<V[V.length-1].frame&&(g=V[V.length-1].frame),u.setKeys(V,!0),M.animation=u):(n.splice(J,1),J--)}return M._from=a,M._to=g,M}getClassName(){return"AnimationGroup"}toString(M){let E="Name: "+this.name;return E+=", type: "+this.getClassName(),M&&(E+=", from: "+this._from,E+=", to: "+this._to,E+=", isStarted: "+this._isStarted,E+=", speedRatio: "+this._speedRatio,E+=", targetedAnimations length: "+this._targetedAnimations.length,E+=", animatables length: "+this._animatables),E}}}}]);