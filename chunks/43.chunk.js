"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12197:(B,q,C)=>{C.r(q),C.d(q,{AnimationGroup:()=>s,TargetedAnimation:()=>U});var v=C(11579),m=C(940),O=C(978),S=C(1118),D=C(11575),R=C(946);class T{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(B,q,C,m){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=q,this._target=B,this._scene=C,this._host=m,this._activeTargets=[],q._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===v.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=R.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const B={frame:0,value:this._minValue};this._keys.splice(0,0,B)}if(this._target instanceof Array){let B=0;for(const q of this._target)this._preparePath(q,B),this._getOriginalValues(B),B++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const O=q.getEvents();O&&O.length>0&&O.forEach((B=>{this._events.push(B._clone())})),this._enableBlending=B&&B.animationPropertiesOverride?B.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(B){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this._animation.targetPropertyPath;if(C.length>1){let v=B;for(let B=0;B<C.length-1;B++){const q=C[B];if(v=v[q],void 0===v)throw new Error(`Invalid property (${q}) in property path (${C.join(".")})`)}this._targetPath=C[C.length-1],this._activeTargets[q]=v}else this._targetPath=C[0],this._activeTargets[q]=B;if(void 0===this._activeTargets[q][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${C.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let B=0;for(const q of this._target)void 0!==this._originalValue[B]&&this._setValue(q,this._activeTargets[B],this._originalValue[B],-1,B),B++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let B=0;B<this._events.length;B++)this._events[B].isDone=!1}isStopped(){return this._stopped}dispose(){const B=this._animation.runtimeAnimations.indexOf(this);B>-1&&this._animation.runtimeAnimations.splice(B,1)}setValue(B,q){if(this._targetIsArray)for(let C=0;C<this._target.length;C++){const v=this._target[C];this._setValue(v,this._activeTargets[C],B,q,C)}else this._setValue(this._target,this._directTarget,B,q,0)}_getOriginalValues(){let B,q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const C=this._activeTargets[q];B=C.getLocalMatrix&&"_matrix"===this._targetPath?C.getLocalMatrix():C[this._targetPath],B&&B.clone?this._originalValue[q]=B.clone():this._originalValue[q]=B}_registerTargetForLateAnimationBinding(B,q){const C=B.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(C),C._lateAnimationHolders||(C._lateAnimationHolders={}),C._lateAnimationHolders[B.targetPath]||(C._lateAnimationHolders[B.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:q}),B.isAdditive?(C._lateAnimationHolders[B.targetPath].additiveAnimations.push(B),C._lateAnimationHolders[B.targetPath].totalAdditiveWeight+=B.weight):(C._lateAnimationHolders[B.targetPath].animations.push(B),C._lateAnimationHolders[B.targetPath].totalWeight+=B.weight)}_setValue(B,q,C,m,O){if(this._currentActiveTarget=q,this._weight=m,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const B=q[this._targetPath];B.clone?this._originalBlendValue=B.clone():this._originalBlendValue=B}this._originalBlendValue.m?v.d.AllowMatrixDecomposeForInterpolation?this._currentValue?R.b.DecomposeLerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=R.b.DecomposeLerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue?R.b.LerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=R.b.Lerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue=v.d._UniversalLerp(this._originalBlendValue,C,this._blendingFactor);const m=B&&B.animationPropertiesOverride?B.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=m}else this._currentValue?this._currentValue.p?this._currentValue.p(C):this._currentValue=C:null!==C&&void 0!==C&&C.clone?this._currentValue=C.clone():this._currentValue=C;-1!==m?this._registerTargetForLateAnimationBinding(this,this._originalValue[O]):this._animationState.loopMode===v.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[O],q[this._targetPath]):q[this._targetPath]=this._originalValue[O]+this._currentValue:q[this._targetPath]=this._currentValue,B.oe&&B.oe(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(B){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const C=this._animation.getKeys();B<C[0].frame?B=C[0].frame:B>C[C.length-1].frame&&(B=C[C.length-1].frame);const v=this._events;if(v.length)for(let O=0;O<v.length;O++)v[O].onlyOnce||(v[O].isDone=v[O].frame<B);this._currentFrame=B;const m=this._animation._interpolate(B,this._animationState);this.setValue(m,q)}_prepareForSpeedRatioChange(B){const q=this._previousElapsedTime*(this._animation.framePerSecond*B)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-q}animate(B,q,C,m,O){let S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const D=this._animation,R=D.targetPropertyPath;if(!R||R.length<1)return this._stopped=!0,!1;let T=!0;(q<this._minFrame||q>this._maxFrame)&&(q=this._minFrame),(C<this._minFrame||C>this._maxFrame)&&(C=this._maxFrame);const l=C-q;let z,W=B*(D.framePerSecond*O)/1e3+this._absoluteFrameOffset,Z=0,G=!1;const y=m&&this._animationState.loopMode===v.d.ANIMATIONLOOPMODE_YOYO;if(y){const B=(W-q)/l,C=Math.sin(B*Math.PI);W=Math.abs(C)*l+q;const v=C>=0?1:-1;this._yoyoDirection!==v&&(G=!0),this._yoyoDirection=v}if(this._previousElapsedTime=B,this._previousAbsoluteFrame=W,!m&&C>=q&&(W>=l&&O>0||W<=0&&O<0))T=!1,Z=D._getKeyValue(this._maxValue);else if(!m&&q>=C&&(W<=l&&O<0||W>=0&&O>0))T=!1,Z=D._getKeyValue(this._minValue);else if(this._animationState.loopMode!==v.d.ANIMATIONLOOPMODE_CYCLE){const B=C.toString()+q.toString();if(!this._offsetsCache[B]){this._animationState.repeatCount=0,this._animationState.loopMode=v.d.ANIMATIONLOOPMODE_CYCLE;const m=D._interpolate(q,this._animationState),O=D._interpolate(C,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),D.dataType){case v.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[B]=O-m;break;case v.d.ANIMATIONTYPE_QUATERNION:case v.d.ANIMATIONTYPE_VECTOR3:case v.d.ANIMATIONTYPE_VECTOR2:case v.d.ANIMATIONTYPE_SIZE:case v.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[B]=O.Fc(m)}this._highLimitsCache[B]=O}Z=this._highLimitsCache[B],z=this._offsetsCache[B]}if(void 0===z)switch(D.dataType){case v.d.ANIMATIONTYPE_FLOAT:z=0;break;case v.d.ANIMATIONTYPE_QUATERNION:z=v.k;break;case v.d.ANIMATIONTYPE_VECTOR3:z=v.t;break;case v.d.ANIMATIONTYPE_VECTOR2:z=v.p;break;case v.d.ANIMATIONTYPE_SIZE:z=v.o;break;case v.d.ANIMATIONTYPE_COLOR3:z=v.g;break;case v.d.ANIMATIONTYPE_COLOR4:z=v.h}let e;if(this._host&&this._host.syncRoot){const B=this._host.syncRoot;e=q+l*((B.masterFrame-B.fromFrame)/(B.toFrame-B.fromFrame))}else e=W>0&&q>C||W<0&&q<C?T&&0!==l?C+W%l:q:T&&0!==l?q+W%l:C;const U=this._events;if(!y&&(O>0&&this.currentFrame>e||O<0&&this.currentFrame<e)||y&&G){this._onLoop();for(let B=0;B<U.length;B++)U[B].onlyOnce||(U[B].isDone=!1);this._animationState.key=O>0?0:D.getKeys().length-1}this._currentFrame=e,this._animationState.repeatCount=0===l?0:W/l|0,this._animationState.highLimitValue=Z,this._animationState.offsetValue=z;const s=D._interpolate(e,this._animationState);if(this.setValue(s,S),U.length)for(let v=0;v<U.length;v++)if(l>=0&&e>=U[v].frame&&U[v].frame>=q||l<0&&e<=U[v].frame&&U[v].frame<=q){const B=U[v];B.isDone||(B.onlyOnce&&(U.splice(v,1),v--),B.isDone=!0,B.action(e))}return T||(this._stopped=!0),T}}var l=C(1081);class z{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(B){this._weight=-1!==B?Math.min(Math.max(B,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(B){for(let q=0;q<this._runtimeAnimations.length;q++){this._runtimeAnimations[q]._prepareForSpeedRatioChange(B)}this._speedRatio=B,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(B,q){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,O=arguments.length>4&&void 0!==arguments[4]&&arguments[4],S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,D=arguments.length>6?arguments[6]:void 0,R=arguments.length>7?arguments[7]:void 0,T=arguments.length>8?arguments[8]:void 0,l=arguments.length>9&&void 0!==arguments[9]&&arguments[9],z=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=q,this.fromFrame=C,this.toFrame=v,this.loopAnimation=O,this.onAnimationEnd=D,this.onAnimationLoop=T,this.isAdditive=l,this.playOrder=z,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.mf=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new m.b,this.onAnimationLoopObservable=new m.b,this._scene=B,R&&this.appendAnimations(q,R),this._speedRatio=S,B._activeAnimatables.push(this)}syncWith(B){if(this._syncRoot=B,B){const B=this._scene._activeAnimatables.indexOf(this);B>-1&&(this._scene._activeAnimatables.splice(B,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(B,q){for(let C=0;C<q.length;C++){const v=q[C],m=new T(B,v,this._scene,this);m._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(m)}}getAnimationByTargetProperty(B){const q=this._runtimeAnimations;for(let C=0;C<q.length;C++)if(q[C].animation.targetProperty===B)return q[C].animation;return null}getRuntimeAnimationByTargetProperty(B){const q=this._runtimeAnimations;for(let C=0;C<q.length;C++)if(q[C].animation.targetProperty===B)return q[C];return null}reset(){const B=this._runtimeAnimations;for(let q=0;q<B.length;q++)B[q].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(B){const q=this._runtimeAnimations;for(let C=0;C<q.length;C++)q[C].animation.enableBlending=!0,q[C].animation.blendingSpeed=B}disableBlending(){const B=this._runtimeAnimations;for(let q=0;q<B.length;q++)B[q].animation.enableBlending=!1}goToFrame(B){const q=this._runtimeAnimations;if(q[0]){const C=q[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??q[0].currentFrame;const v=0===this.speedRatio?0:(B-this._frameToSyncFromJump)/C*1e3/this.speedRatio;this._manualJumpDelay=-v}for(let C=0;C<q.length;C++)q[C].goToFrame(B,this._weight);this._goToFrame=B}get paused(){return this.mf}pause(){this.mf||(this.mf=!0)}restart(){this.mf=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(B,q){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],v=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(B||q){const m=this._scene._activeAnimatables.indexOf(this);if(m>-1){const O=this._runtimeAnimations;for(let C=O.length-1;C>=0;C--){const v=O[C];B&&v.animation.name!=B||(q&&!q(v.target)||(v.dispose(),O.splice(C,1)))}0==O.length&&(C||this._scene._activeAnimatables.splice(m,1),v||this._raiseOnAnimationEnd())}}else{const B=this._scene._activeAnimatables.indexOf(this);if(B>-1){C||this._scene._activeAnimatables.splice(B,1);const q=this._runtimeAnimations;for(let B=0;B<q.length;B++)q[B].dispose();this._runtimeAnimations.length=0,v||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((B=>{this.onAnimationEndObservable.add((()=>{B(this)}),void 0,void 0,this,!0)}))}_animate(B){if(this.mf)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=B),!0;if(null===this._localDelayOffset?(this._localDelayOffset=B,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=B-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let q=!1;const C=this._runtimeAnimations;let v;for(v=0;v<C.length;v++){const m=C[v].animate(B-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);q=q||m}if(this.animationStarted=q,!q){if(this.disposeOnEnd)for(v=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(v,1),v=0;v<C.length;v++)C[v].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return q}}function W(B){if(0===B.totalWeight&&0===B.totalAdditiveWeight)return B.originalValue;let q=1;const C=R.d.qd[0],v=R.d.qd[1],m=R.d.Quaternion[0];let O=0;const S=B.animations[0],D=B.originalValue;let T=1,l=!1;if(B.totalWeight<1)T=1-B.totalWeight,D.decompose(v,m,C);else{if(O=1,q=B.totalWeight,T=S.weight/q,1==T){if(!B.totalAdditiveWeight)return S.currentValue;l=!0}S.currentValue.decompose(v,m,C)}if(!l){v.scaleInPlace(T),C.scaleInPlace(T),m.scaleInPlace(T);for(let S=O;S<B.animations.length;S++){const O=B.animations[S];if(0===O.weight)continue;T=O.weight/q;const D=R.d.qd[2],l=R.d.qd[3],z=R.d.Quaternion[1];O.currentValue.decompose(l,z,D),l.scaleAndAddToRef(T,v),z.scaleAndAddToRef(R.c.Dot(m,z)>0?T:-T,m),D.scaleAndAddToRef(T,C)}m.normalize()}for(let W=0;W<B.additiveAnimations.length;W++){const q=B.additiveAnimations[W];if(0===q.weight)continue;const O=R.d.qd[2],S=R.d.qd[3],D=R.d.Quaternion[1];q.currentValue.decompose(S,D,O),S.multiplyToRef(v,S),R.i.LerpToRef(v,S,q.weight,v),m.multiplyToRef(D,D),R.c.SlerpToRef(m,D,q.weight,m),O.scaleAndAddToRef(q.weight,C)}const z=S?S._animationState.workValue:R.d.Matrix[0].clone();return R.b.ComposeToRef(v,m,C,z),z}function Z(B,q){if(0===B.totalWeight&&0===B.totalAdditiveWeight)return q;const C=B.animations[0],v=B.originalValue;let m=q;if(0===B.totalWeight&&B.totalAdditiveWeight>0)m.p(v);else if(1===B.animations.length){if(R.c.SlerpToRef(v,C.currentValue,Math.min(1,B.totalWeight),m),0===B.totalAdditiveWeight)return m}else if(B.animations.length>1){let C,O,S=1;if(B.totalWeight<1){const q=1-B.totalWeight;C=[],O=[],C.push(v),O.push(q)}else{if(2===B.animations.length&&(R.c.SlerpToRef(B.animations[0].currentValue,B.animations[1].currentValue,B.animations[1].weight/B.totalWeight,q),0===B.totalAdditiveWeight))return q;C=[],O=[],S=B.totalWeight}for(let q=0;q<B.animations.length;q++){const v=B.animations[q];C.push(v.currentValue),O.push(v.weight/S)}let D=0;for(let B=0;B<C.length;)B?(D+=O[B],R.c.SlerpToRef(m,C[B],O[B]/D,m),B++):(R.c.SlerpToRef(C[B],C[B+1],O[B+1]/(O[B]+O[B+1]),q),m=q,D=O[B]+O[B+1],B+=2)}for(let O=0;O<B.additiveAnimations.length;O++){const q=B.additiveAnimations[O];0!==q.weight&&(m.multiplyToRef(q.currentValue,R.d.Quaternion[0]),R.c.SlerpToRef(m,R.d.Quaternion[0],q.weight,m))}return m}var G,y,e=C(1158);G=e.d,(y=D.b)&&(y.prototype.copyAnimationRange=function(B,q,C){let m=arguments.length>3&&void 0!==arguments[3]&&arguments[3],O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new v.d(this.name,"_matrix",B.animations[0].framePerSecond,v.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const S=B.animations[0].getRange(q);if(!S)return!1;const D=S.from,R=S.to,T=B.animations[0].getKeys(),l=B.length,z=B.getParent(),W=this.getParent(),Z=m&&z&&l&&this.length&&l!==this.length,G=Z&&W&&z?W.length/z.length:1,y=m&&!W&&O&&(1!==O.x||1!==O.y||1!==O.z),e=this.animations[0].getKeys();let U,s,A;for(let v=0,r=T.length;v<r;v++)U=T[v],U.frame>=D&&U.frame<=R&&(m?(A=U.value.clone(),Z?(s=A.getTranslation(),A.setTranslation(s.scaleInPlace(G))):y&&O?(s=A.getTranslation(),A.setTranslation(s.multiplyInPlace(O))):A=U.value):A=U.value,e.push({frame:U.frame+C,value:A}));return this.animations[0].createRange(q,D+C,R+C),!0}),G&&(G.prototype._animate=function(B){if(!this.animationsEnabled)return;const q=l.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=q}this.deltaTime=void 0!==B?B:this.useConstantAnimationDeltaTime?16:(q-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=q;const C=this._activeAnimatables;if(0===C.length)return;this._animationTime+=this.deltaTime;const m=this._animationTime;for(let v=0;v<C.length;v++){const B=C[v];!B._animate(m)&&B.disposeOnEnd&&v--}!function(B){if(B._registeredForLateAnimationBindings.length){for(let q=0;q<B._registeredForLateAnimationBindings.length;q++){const C=B._registeredForLateAnimationBindings.data[q];for(const B in C._lateAnimationHolders){const q=C._lateAnimationHolders[B],m=q.animations[0],O=q.originalValue;if(void 0===O||null===O)continue;const S=v.d.AllowMatrixDecomposeForInterpolation&&O.m;let D=C[B];if(S)D=W(q);else if(void 0!==O.w)D=Z(q,D||R.c.Identity());else{let B=0,C=1;const S=m&&m._animationState.loopMode===v.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(q.totalWeight<1)D=S?O.clone?O.clone():O:m&&O.scale?O.scale(1-q.totalWeight):m?O*(1-q.totalWeight):O.clone?O.clone():O;else if(m){C=q.totalWeight;const v=m.weight/C;D=1!==v?m.currentValue.scale?m.currentValue.scale(v):m.currentValue*v:m.currentValue,S&&(D.addToRef?D.addToRef(O,D):D+=O),B=1}for(let v=B;v<q.animations.length;v++){const B=q.animations[v],m=B.weight/C;m&&(B.currentValue.scaleAndAddToRef?B.currentValue.scaleAndAddToRef(m,D):D+=B.currentValue*m)}for(let v=0;v<q.additiveAnimations.length;v++){const B=q.additiveAnimations[v],C=B.weight;C&&(B.currentValue.scaleAndAddToRef?B.currentValue.scaleAndAddToRef(C,D):D+=B.currentValue*C)}}C[B]=D}C._lateAnimationHolders={}}B._registeredForLateAnimationBindings.reset()}}(this)},G.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((B,q)=>B.playOrder-q.playOrder))},G.prototype.beginWeightedAnimation=function(B,q,C){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,m=arguments.length>4?arguments[4]:void 0,O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,S=arguments.length>6?arguments[6]:void 0,D=arguments.length>7?arguments[7]:void 0,R=arguments.length>8?arguments[8]:void 0,T=arguments.length>9?arguments[9]:void 0,l=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const z=this.beginAnimation(B,q,C,m,O,S,D,!1,R,T,l);return z.weight=v,z},G.prototype.beginAnimation=function(B,q,C,v){let m=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,O=arguments.length>5?arguments[5]:void 0,S=arguments.length>6?arguments[6]:void 0,D=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],R=arguments.length>8?arguments[8]:void 0,T=arguments.length>9?arguments[9]:void 0,l=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(m<0){const B=q;q=C,C=B,m=-m}q>C&&(m=-m),D&&this.stopAnimation(B,void 0,R),S||(S=new z(this,B,q,C,v,m,O,void 0,T,l));const W=!R||R(B);if(B.animations&&W&&S.appendAnimations(B,B.animations),B.getAnimatables){const l=B.getAnimatables();for(let B=0;B<l.length;B++)this.beginAnimation(l[B],q,C,v,m,O,S,D,R,T)}return S.reset(),S},G.prototype.beginHierarchyAnimation=function(B,q,C,v,m){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,S=arguments.length>6?arguments[6]:void 0,D=arguments.length>7?arguments[7]:void 0,R=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],T=arguments.length>9?arguments[9]:void 0,l=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const z=B.getDescendants(q),W=[];W.push(this.beginAnimation(B,C,v,m,O,S,D,R,T,void 0,l));for(const Z of z)W.push(this.beginAnimation(Z,C,v,m,O,S,D,R,T,void 0,l));return W},G.prototype.beginDirectAnimation=function(B,q,C,v,m){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(O<0){const B=C;C=v,v=B,O=-O}return C>v&&(O=-O),new z(this,B,C,v,m,O,arguments.length>6?arguments[6]:void 0,q,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},G.prototype.beginDirectHierarchyAnimation=function(B,q,C,v,m,O,S,D,R){let T=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const l=B.getDescendants(q),z=[];z.push(this.beginDirectAnimation(B,C,v,m,O,S,D,R,T));for(const W of l)z.push(this.beginDirectAnimation(W,C,v,m,O,S,D,R,T));return z},G.prototype.getAnimatableByTarget=function(B){for(let q=0;q<this._activeAnimatables.length;q++)if(this._activeAnimatables[q].target===B)return this._activeAnimatables[q];return null},G.prototype.getAllAnimatablesByTarget=function(B){const q=[];for(let C=0;C<this._activeAnimatables.length;C++)this._activeAnimatables[C].target===B&&q.push(this._activeAnimatables[C]);return q},G.prototype.stopAnimation=function(B,q,C){const v=this.getAllAnimatablesByTarget(B);for(const m of v)m.stop(q,C)},G.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let B=0;B<this._activeAnimatables.length;B++)this._activeAnimatables[B].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const B of this.animationGroups)B.stop()});class U{getClassName(){return"TargetedAnimation"}serialize(){const B={};return B.animation=this.animation.serialize(),B.targetId=this.target.id,B}}class s{get mask(){return this._mask}set mask(B){this._mask!==B&&(this._mask=B,this.syncWithMask(!0))}syncWithMask(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||B){this._numActiveAnimatables=0;for(let B=0;B<this._animatables.length;++B){const q=this._animatables[B];!this.mask||this.mask.disabled||this.mask.retainsTarget(q.target.name)?(this._numActiveAnimatables++,q.paused&&q.restart()):q.paused||q.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let B=0;B<this._animatables.length;++B){const q=this._animatables[B];this.mask.retainsTarget(q.target.name)||(q.stop(),this._animatables.splice(B,1),--B)}for(let B=0;B<this._targetedAnimations.length;B++){const q=this._targetedAnimations[B];this.mask.retainsTarget(q.target.name)||(this._targetedAnimations.splice(B,1),--B)}}}get from(){return this._from}set from(B){if(this._from!==B){this._from=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].fromFrame=this._from}}}get to(){return this._to}set to(B){if(this._to!==B){this._to=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(B){if(this._speedRatio!==B){this._speedRatio=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(B){if(this._loopAnimation!==B){this._loopAnimation=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(B){if(this._isAdditive!==B){this._isAdditive=B;for(let B=0;B<this._animatables.length;B++){this._animatables[B].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(B){this._weight!==B&&(this._weight=B,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(B){if(this._playOrder!==B&&(this._playOrder=B,this._animatables.length>0)){for(let B=0;B<this._animatables.length;B++)this._animatables[B].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(B){if(this._enableBlending!==B&&(this._enableBlending=B,null!==B))for(let q=0;q<this._targetedAnimations.length;++q)this._targetedAnimations[q].animation.enableBlending=B}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(B){if(this._blendingSpeed!==B&&(this._blendingSpeed=B,null!==B))for(let q=0;q<this._targetedAnimations.length;++q)this._targetedAnimations[q].animation.blendingSpeed=B}getLength(B,q){B=B??this._from;return((q=q??this._to)-B)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(B){let q=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],v=arguments.length>3?arguments[3]:void 0;if(0===B.length)return null;v=v??B[0].weight;let m=Number.MAX_VALUE,O=-Number.MAX_VALUE;if(C)for(const D of B)D.from<m&&(m=D.from),D.to>O&&(O=D.to);const S=new s(B[0].name+"_merged",B[0]._scene,v);for(const D of B){C&&D.normalize(m,O);for(const B of D.targetedAnimations)S.addTargetedAnimation(B.animation,B.target);q&&D.dispose()}return S}constructor(B){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=B,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new m.b,this.onAnimationLoopObservable=new m.b,this.onAnimationGroupLoopObservable=new m.b,this.onAnimationGroupEndObservable=new m.b,this.onAnimationGroupPauseObservable=new m.b,this.onAnimationGroupPlayObservable=new m.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=q||O.e.LastCreatedScene,this._weight=C,this._playOrder=v,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(B,q){const C=new U;C.animation=B,C.target=q;const v=B.getKeys();return this._from>v[0].frame&&(this._from=v[0].frame),this._to<v[v.length-1].frame&&(this._to=v[v.length-1].frame),null!==this._enableBlending&&(B.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(B.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(C),this._shouldStart=!0,C}removeTargetedAnimation(B){for(let q=this._targetedAnimations.length-1;q>-1;q--){this._targetedAnimations[q].animation===B&&this._targetedAnimations.splice(q,1)}}normalize(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==B&&(B=this._from),null==q&&(q=this._to);for(let C=0;C<this._targetedAnimations.length;C++){const v=this._targetedAnimations[C].animation.getKeys(),m=v[0],O=v[v.length-1];if(m.frame>B){const q={frame:B,value:m.value,inTangent:m.inTangent,outTangent:m.outTangent,interpolation:m.interpolation};v.splice(0,0,q)}if(O.frame<q){const B={frame:q,value:O.value,inTangent:O.inTangent,outTangent:O.outTangent,interpolation:O.interpolation};v.push(B)}}return this._from=B,this._to=q,this}_processLoop(B,q,C){B.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(q),this._animationLoopFlags[C]||(this._animationLoopFlags[C]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0],q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0,v=arguments.length>3?arguments[3]:void 0,m=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=B,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let O=0;O<this._targetedAnimations.length;O++){const S=this._targetedAnimations[O],D=this._scene.beginDirectAnimation(S.target,[S.animation],void 0!==C?C:this._from,void 0!==v?v:this._to,B,q,void 0,void 0,void 0!==m?m:this._isAdditive);D.weight=this._weight,D.playOrder=this._playOrder,D.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(S),this._checkAnimationGroupEnded(D)},this._processLoop(D,S,O),this._animatables.push(D)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=q,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let B=0;B<this._animatables.length;B++){this._animatables[B].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(B){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==B&&(this.loopAnimation=B),this.restart()):(this.stop(),this.start(B,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let B=0;B<this._animatables.length;B++){this._animatables[B].reset()}return this}restart(){if(!this._isStarted)return this;for(let B=0;B<this._animatables.length;B++){this._animatables[B].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const q=this._animatables.slice();for(let v=0;v<q.length;v++)q[v].stop(void 0,void 0,!0,B);let C=0;for(let v=0;v<this._scene._activeAnimatables.length;v++){const q=this._scene._activeAnimatables[v];q._runtimeAnimations.length>0?this._scene._activeAnimatables[C++]=q:B&&this._checkAnimationGroupEnded(q,B)}return this._scene._activeAnimatables.length=C,this._isStarted=!1,this}setWeightForAllAnimatables(B){for(let q=0;q<this._animatables.length;q++){this._animatables[q].weight=B}return this}syncAllAnimationsWith(B){for(let q=0;q<this._animatables.length;q++){this._animatables[q].syncWith(B)}return this}goToFrame(B){if(!this._isStarted)return this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].goToFrame(B)}return this}getCurrentFrame(){var B;return(null===(B=this.animatables[0])||void 0===B?void 0:B.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const B=this._scene.animationGroups.indexOf(this);if(B>-1&&this._scene.animationGroups.splice(B,1),this._parentContainer){const B=this._parentContainer.animationGroups.indexOf(this);B>-1&&this._parentContainer.animationGroups.splice(B,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(B){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const C=this._animatables.indexOf(B);C>-1&&this._animatables.splice(C,1),0===this._animatables.length&&(this._isStarted=!1,q||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(B,q){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const v=new s(B||this.name,this._scene,this._weight,this._playOrder);v._from=this.from,v._to=this.to,v._speedRatio=this.speedRatio,v._loopAnimation=this.loopAnimation,v._isAdditive=this.isAdditive,v._enableBlending=this.enableBlending,v._blendingSpeed=this.blendingSpeed,v.metadata=this.metadata,v.mask=this.mask;for(const m of this._targetedAnimations)v.addTargetedAnimation(C?m.animation.clone():m.animation,q?q(m.target):m.target);return v}serialize(){const B={};B.name=this.name,B.from=this.from,B.to=this.to,B.speedRatio=this.speedRatio,B.loopAnimation=this.loopAnimation,B.isAdditive=this.isAdditive,B.weight=this.weight,B.playOrder=this.playOrder,B.enableBlending=this.enableBlending,B.blendingSpeed=this.blendingSpeed,B.targetedAnimations=[];for(let q=0;q<this.targetedAnimations.length;q++){const C=this.targetedAnimations[q];B.targetedAnimations[q]=C.serialize()}return S.e&&S.e.HasTags(this)&&(B.tags=S.e.GetTags(this)),this.metadata&&(B.metadata=this.metadata),B}static Parse(B,q){const C=new s(B.name,q,B.weight,B.playOrder);for(let m=0;m<B.targetedAnimations.length;m++){const O=B.targetedAnimations[m],S=v.d.Parse(O.animation),D=O.targetId;if("influence"===O.animation.property){const B=q.getMorphTargetById(D);B&&C.addTargetedAnimation(S,B)}else{const B=q.getNodeById(D);null!=B&&C.addTargetedAnimation(S,B)}}return S.e&&S.e.AddTagsTo(C,B.tags),null!==B.from&&null!==B.to&&C.normalize(B.from,B.to),void 0!==B.speedRatio&&(C._speedRatio=B.speedRatio),void 0!==B.loopAnimation&&(C._loopAnimation=B.loopAnimation),void 0!==B.isAdditive&&(C._isAdditive=B.isAdditive),void 0!==B.weight&&(C._weight=B.weight),void 0!==B.playOrder&&(C._playOrder=B.playOrder),void 0!==B.enableBlending&&(C._enableBlending=B.enableBlending),void 0!==B.blendingSpeed&&(C._blendingSpeed=B.blendingSpeed),void 0!==B.metadata&&(C.metadata=B.metadata),C}static MakeAnimationAdditive(B,q,C){let m;m="object"===typeof q?q:{referenceFrame:q,range:C,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let O=B;m.cloneOriginalAnimationGroup&&(O=B.clone(m.clonedAnimationGroupName||O.name));const S=O.targetedAnimations;for(let D=0;D<S.length;D++){const B=S[D];B.animation=v.d.MakeAnimationAdditive(B.animation,m)}if(O.isAdditive=!0,m.clipKeys){let B=Number.MAX_VALUE,q=-Number.MAX_VALUE;const C=O.targetedAnimations;for(let v=0;v<C.length;v++){const m=C[v].animation.getKeys();B>m[0].frame&&(B=m[0].frame),q<m[m.length-1].frame&&(q=m[m.length-1].frame)}O._from=B,O._to=q}return O}static ClipKeys(B,q,C,v,m){const O=B.clone(v||B.name);return s.ClipKeysInPlace(O,q,C,m)}static ClipKeysInPlace(B,q,C,v){return s.ClipInPlace(B,q,C,v,!1)}static ClipFrames(B,q,C,v,m){const O=B.clone(v||B.name);return s.ClipFramesInPlace(O,q,C,m)}static ClipFramesInPlace(B,q,C,v){return s.ClipInPlace(B,q,C,v,!0)}static ClipInPlace(B,q,C,v){let m=arguments.length>4&&void 0!==arguments[4]&&arguments[4],O=Number.MAX_VALUE,S=-Number.MAX_VALUE;const D=B.targetedAnimations;for(let R=0;R<D.length;R++){const B=D[R],T=v?B.animation:B.animation.clone();m&&(T.createKeyForFrame(q),T.createKeyForFrame(C));const l=T.getKeys(),z=[];let W=Number.MAX_VALUE;for(let v=0;v<l.length;v++){const B=l[v];if(!m&&v>=q&&v<=C||m&&B.frame>=q&&B.frame<=C){const q={frame:B.frame,value:B.value.clone?B.value.clone():B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation,lockedTangent:B.lockedTangent};W===Number.MAX_VALUE&&(W=q.frame),q.frame-=W,z.push(q)}}0!==z.length?(O>z[0].frame&&(O=z[0].frame),S<z[z.length-1].frame&&(S=z[z.length-1].frame),T.setKeys(z,!0),B.animation=T):(D.splice(R,1),R--)}return B._from=O,B._to=S,B}getClassName(){return"AnimationGroup"}toString(B){let q="Name: "+this.name;return q+=", type: "+this.getClassName(),B&&(q+=", from: "+this._from,q+=", to: "+this._to,q+=", isStarted: "+this._isStarted,q+=", speedRatio: "+this._speedRatio,q+=", targetedAnimations length: "+this._targetedAnimations.length,q+=", animatables length: "+this._animatables),q}}}}]);