"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{13050:(j,S,h)=>{h.r(S),h.d(S,{AnimationGroup:()=>o,TargetedAnimation:()=>v});var m=h(12412),I=h(964),d=h(1001),U=h(1124),f=h(12406),r=h(970);class a{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(j,S,h,I){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=S,this._target=j,this._scene=h,this._host=I,this._activeTargets=[],S._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===m.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=r.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const j={frame:0,value:this._minValue};this._keys.splice(0,0,j)}if(this._target instanceof Array){let j=0;for(const S of this._target)this._preparePath(S,j),this._getOriginalValues(j),j++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const d=S.getEvents();d&&d.length>0&&d.forEach((j=>{this._events.push(j._clone())})),this._enableBlending=j&&j.animationPropertiesOverride?j.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(j){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=this._animation.targetPropertyPath;if(h.length>1){let m=j;for(let j=0;j<h.length-1;j++){const S=h[j];if(m=m[S],void 0===m)throw new Error(`Invalid property (${S}) in property path (${h.join(".")})`)}this._targetPath=h[h.length-1],this._activeTargets[S]=m}else this._targetPath=h[0],this._activeTargets[S]=j;if(void 0===this._activeTargets[S][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${h.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let j=0;for(const S of this._target)void 0!==this._originalValue[j]&&this._setValue(S,this._activeTargets[j],this._originalValue[j],-1,j),j++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let j=0;j<this._events.length;j++)this._events[j].isDone=!1}isStopped(){return this._stopped}dispose(){const j=this._animation.runtimeAnimations.indexOf(this);j>-1&&this._animation.runtimeAnimations.splice(j,1)}setValue(j,S){if(this._targetIsArray)for(let h=0;h<this._target.length;h++){const m=this._target[h];this._setValue(m,this._activeTargets[h],j,S,h)}else this._setValue(this._target,this._directTarget,j,S,0)}_getOriginalValues(){let j,S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const h=this._activeTargets[S];j=h.getLocalMatrix&&"_matrix"===this._targetPath?h.getLocalMatrix():h[this._targetPath],j&&j.clone?this._originalValue[S]=j.clone():this._originalValue[S]=j}_registerTargetForLateAnimationBinding(j,S){const h=j.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(h),h._lateAnimationHolders||(h._lateAnimationHolders={}),h._lateAnimationHolders[j.targetPath]||(h._lateAnimationHolders[j.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:S}),j.isAdditive?(h._lateAnimationHolders[j.targetPath].additiveAnimations.push(j),h._lateAnimationHolders[j.targetPath].totalAdditiveWeight+=j.weight):(h._lateAnimationHolders[j.targetPath].animations.push(j),h._lateAnimationHolders[j.targetPath].totalWeight+=j.weight)}_setValue(j,S,h,I,d){if(this._currentActiveTarget=S,this._weight=I,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const j=S[this._targetPath];j.clone?this._originalBlendValue=j.clone():this._originalBlendValue=j}this._originalBlendValue.m?m.c.AllowMatrixDecomposeForInterpolation?this._currentValue?r.d.DecomposeLerpToRef(this._originalBlendValue,h,this._blendingFactor,this._currentValue):this._currentValue=r.d.DecomposeLerp(this._originalBlendValue,h,this._blendingFactor):this._currentValue?r.d.LerpToRef(this._originalBlendValue,h,this._blendingFactor,this._currentValue):this._currentValue=r.d.Lerp(this._originalBlendValue,h,this._blendingFactor):this._currentValue=m.c._UniversalLerp(this._originalBlendValue,h,this._blendingFactor);const I=j&&j.animationPropertiesOverride?j.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=I}else this._currentValue?this._currentValue.p?this._currentValue.p(h):this._currentValue=h:null!==h&&void 0!==h&&h.clone?this._currentValue=h.clone():this._currentValue=h;-1!==I?this._registerTargetForLateAnimationBinding(this,this._originalValue[d]):this._animationState.loopMode===m.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[d],S[this._targetPath]):S[this._targetPath]=this._originalValue[d]+this._currentValue:S[this._targetPath]=this._currentValue,j.je&&j.je(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(j){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const h=this._animation.getKeys();j<h[0].frame?j=h[0].frame:j>h[h.length-1].frame&&(j=h[h.length-1].frame);const m=this._events;if(m.length)for(let d=0;d<m.length;d++)m[d].onlyOnce||(m[d].isDone=m[d].frame<j);this._currentFrame=j;const I=this._animation._interpolate(j,this._animationState);this.setValue(I,S)}_prepareForSpeedRatioChange(j){const S=this._previousElapsedTime*(this._animation.framePerSecond*j)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-S}animate(j,S,h,I,d){let U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const f=this._animation,r=f.targetPropertyPath;if(!r||r.length<1)return this._stopped=!0,!1;let a=!0;(S<this._minFrame||S>this._maxFrame)&&(S=this._minFrame),(h<this._minFrame||h>this._maxFrame)&&(h=this._maxFrame);const M=h-S;let O,p=j*(f.framePerSecond*d)/1e3+this._absoluteFrameOffset,e=0,w=!1;const l=I&&this._animationState.loopMode===m.c.ANIMATIONLOOPMODE_YOYO;if(l){const j=(p-S)/M,h=Math.sin(j*Math.PI);p=Math.abs(h)*M+S;const m=h>=0?1:-1;this._yoyoDirection!==m&&(w=!0),this._yoyoDirection=m}if(this._previousElapsedTime=j,this._previousAbsoluteFrame=p,!I&&h>=S&&(p>=M&&d>0||p<=0&&d<0))a=!1,e=f._getKeyValue(this._maxValue);else if(!I&&S>=h&&(p<=M&&d<0||p>=0&&d>0))a=!1,e=f._getKeyValue(this._minValue);else if(this._animationState.loopMode!==m.c.ANIMATIONLOOPMODE_CYCLE){const j=h.toString()+S.toString();if(!this._offsetsCache[j]){this._animationState.repeatCount=0,this._animationState.loopMode=m.c.ANIMATIONLOOPMODE_CYCLE;const I=f._interpolate(S,this._animationState),d=f._interpolate(h,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),f.dataType){case m.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[j]=d-I;break;case m.c.ANIMATIONTYPE_QUATERNION:case m.c.ANIMATIONTYPE_VECTOR3:case m.c.ANIMATIONTYPE_VECTOR2:case m.c.ANIMATIONTYPE_SIZE:case m.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[j]=d.cc(I)}this._highLimitsCache[j]=d}e=this._highLimitsCache[j],O=this._offsetsCache[j]}if(void 0===O)switch(f.dataType){case m.c.ANIMATIONTYPE_FLOAT:O=0;break;case m.c.ANIMATIONTYPE_QUATERNION:O=m.n;break;case m.c.ANIMATIONTYPE_VECTOR3:O=m.t;break;case m.c.ANIMATIONTYPE_VECTOR2:O=m.s;break;case m.c.ANIMATIONTYPE_SIZE:O=m.r;break;case m.c.ANIMATIONTYPE_COLOR3:O=m.g;break;case m.c.ANIMATIONTYPE_COLOR4:O=m.k}let P;if(this._host&&this._host.syncRoot){const j=this._host.syncRoot;P=S+M*((j.masterFrame-j.fromFrame)/(j.toFrame-j.fromFrame))}else P=p>0&&S>h||p<0&&S<h?a&&0!==M?h+p%M:S:a&&0!==M?S+p%M:h;const v=this._events;if(!l&&(d>0&&this.currentFrame>P||d<0&&this.currentFrame<P)||l&&w){this._onLoop();for(let j=0;j<v.length;j++)v[j].onlyOnce||(v[j].isDone=!1);this._animationState.key=d>0?0:f.getKeys().length-1}this._currentFrame=P,this._animationState.repeatCount=0===M?0:p/M|0,this._animationState.highLimitValue=e,this._animationState.offsetValue=O;const o=f._interpolate(P,this._animationState);if(this.setValue(o,U),v.length)for(let m=0;m<v.length;m++)if(M>=0&&P>=v[m].frame&&v[m].frame>=S||M<0&&P<=v[m].frame&&v[m].frame<=S){const j=v[m];j.isDone||(j.onlyOnce&&(v.splice(m,1),m--),j.isDone=!0,j.action(P))}return a||(this._stopped=!0),a}}var M=h(1087);class O{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(j){this._weight=-1!==j?Math.min(Math.max(j,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(j){for(let S=0;S<this._runtimeAnimations.length;S++){this._runtimeAnimations[S]._prepareForSpeedRatioChange(j)}this._speedRatio=j,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(j,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,d=arguments.length>4&&void 0!==arguments[4]&&arguments[4],U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,r=arguments.length>7?arguments[7]:void 0,a=arguments.length>8?arguments[8]:void 0,M=arguments.length>9&&void 0!==arguments[9]&&arguments[9],O=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=S,this.fromFrame=h,this.toFrame=m,this.loopAnimation=d,this.onAnimationEnd=f,this.onAnimationLoop=a,this.isAdditive=M,this.playOrder=O,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.cf=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new I.b,this.onAnimationLoopObservable=new I.b,this._scene=j,r&&this.appendAnimations(S,r),this._speedRatio=U,j._activeAnimatables.push(this)}syncWith(j){if(this._syncRoot=j,j){const j=this._scene._activeAnimatables.indexOf(this);j>-1&&(this._scene._activeAnimatables.splice(j,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(j,S){for(let h=0;h<S.length;h++){const m=S[h],I=new a(j,m,this._scene,this);I._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(I)}}getAnimationByTargetProperty(j){const S=this._runtimeAnimations;for(let h=0;h<S.length;h++)if(S[h].animation.targetProperty===j)return S[h].animation;return null}getRuntimeAnimationByTargetProperty(j){const S=this._runtimeAnimations;for(let h=0;h<S.length;h++)if(S[h].animation.targetProperty===j)return S[h];return null}reset(){const j=this._runtimeAnimations;for(let S=0;S<j.length;S++)j[S].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(j){const S=this._runtimeAnimations;for(let h=0;h<S.length;h++)S[h].animation.enableBlending=!0,S[h].animation.blendingSpeed=j}disableBlending(){const j=this._runtimeAnimations;for(let S=0;S<j.length;S++)j[S].animation.enableBlending=!1}goToFrame(j){const S=this._runtimeAnimations;if(S[0]){const h=S[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??S[0].currentFrame;const m=0===this.speedRatio?0:(j-this._frameToSyncFromJump)/h*1e3/this.speedRatio;this._manualJumpDelay=-m}for(let h=0;h<S.length;h++)S[h].goToFrame(j,this._weight);this._goToFrame=j}get paused(){return this.cf}pause(){this.cf||(this.cf=!0)}restart(){this.cf=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(j,S){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],m=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(j||S){const I=this._scene._activeAnimatables.indexOf(this);if(I>-1){const d=this._runtimeAnimations;for(let h=d.length-1;h>=0;h--){const m=d[h];j&&m.animation.name!=j||(S&&!S(m.target)||(m.dispose(),d.splice(h,1)))}0==d.length&&(h||this._scene._activeAnimatables.splice(I,1),m||this._raiseOnAnimationEnd())}}else{const j=this._scene._activeAnimatables.indexOf(this);if(j>-1){h||this._scene._activeAnimatables.splice(j,1);const S=this._runtimeAnimations;for(let j=0;j<S.length;j++)S[j].dispose();this._runtimeAnimations.length=0,m||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((j=>{this.onAnimationEndObservable.add((()=>{j(this)}),void 0,void 0,this,!0)}))}_animate(j){if(this.cf)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=j),!0;if(null===this._localDelayOffset?(this._localDelayOffset=j,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=j-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let S=!1;const h=this._runtimeAnimations;let m;for(m=0;m<h.length;m++){const I=h[m].animate(j-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);S=S||I}if(this.animationStarted=S,!S){if(this.disposeOnEnd)for(m=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(m,1),m=0;m<h.length;m++)h[m].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return S}}function p(j){if(0===j.totalWeight&&0===j.totalAdditiveWeight)return j.originalValue;let S=1;const h=r.i.od[0],m=r.i.od[1],I=r.i.Quaternion[0];let d=0;const U=j.animations[0],f=j.originalValue;let a=1,M=!1;if(j.totalWeight<1)a=1-j.totalWeight,f.decompose(m,I,h);else{if(d=1,S=j.totalWeight,a=U.weight/S,1==a){if(!j.totalAdditiveWeight)return U.currentValue;M=!0}U.currentValue.decompose(m,I,h)}if(!M){m.scaleInPlace(a),h.scaleInPlace(a),I.scaleInPlace(a);for(let U=d;U<j.animations.length;U++){const d=j.animations[U];if(0===d.weight)continue;a=d.weight/S;const f=r.i.od[2],M=r.i.od[3],O=r.i.Quaternion[1];d.currentValue.decompose(M,O,f),M.scaleAndAddToRef(a,m),O.scaleAndAddToRef(r.g.Dot(I,O)>0?a:-a,I),f.scaleAndAddToRef(a,h)}I.normalize()}for(let p=0;p<j.additiveAnimations.length;p++){const S=j.additiveAnimations[p];if(0===S.weight)continue;const d=r.i.od[2],U=r.i.od[3],f=r.i.Quaternion[1];S.currentValue.decompose(U,f,d),U.multiplyToRef(m,U),r.m.LerpToRef(m,U,S.weight,m),I.multiplyToRef(f,f),r.g.SlerpToRef(I,f,S.weight,I),d.scaleAndAddToRef(S.weight,h)}const O=U?U._animationState.workValue:r.i.Matrix[0].clone();return r.d.ComposeToRef(m,I,h,O),O}function e(j,S){if(0===j.totalWeight&&0===j.totalAdditiveWeight)return S;const h=j.animations[0],m=j.originalValue;let I=S;if(0===j.totalWeight&&j.totalAdditiveWeight>0)I.p(m);else if(1===j.animations.length){if(r.g.SlerpToRef(m,h.currentValue,Math.min(1,j.totalWeight),I),0===j.totalAdditiveWeight)return I}else if(j.animations.length>1){let h,d,U=1;if(j.totalWeight<1){const S=1-j.totalWeight;h=[],d=[],h.push(m),d.push(S)}else{if(2===j.animations.length&&(r.g.SlerpToRef(j.animations[0].currentValue,j.animations[1].currentValue,j.animations[1].weight/j.totalWeight,S),0===j.totalAdditiveWeight))return S;h=[],d=[],U=j.totalWeight}for(let S=0;S<j.animations.length;S++){const m=j.animations[S];h.push(m.currentValue),d.push(m.weight/U)}let f=0;for(let j=0;j<h.length;)j?(f+=d[j],r.g.SlerpToRef(I,h[j],d[j]/f,I),j++):(r.g.SlerpToRef(h[j],h[j+1],d[j+1]/(d[j]+d[j+1]),S),I=S,f=d[j]+d[j+1],j+=2)}for(let d=0;d<j.additiveAnimations.length;d++){const S=j.additiveAnimations[d];0!==S.weight&&(I.multiplyToRef(S.currentValue,r.i.Quaternion[0]),r.g.SlerpToRef(I,r.i.Quaternion[0],S.weight,I))}return I}var w,l,P=h(1160);w=P.d,(l=f.d)&&(l.prototype.copyAnimationRange=function(j,S,h){let I=arguments.length>3&&void 0!==arguments[3]&&arguments[3],d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new m.c(this.name,"_matrix",j.animations[0].framePerSecond,m.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const U=j.animations[0].getRange(S);if(!U)return!1;const f=U.from,r=U.to,a=j.animations[0].getKeys(),M=j.length,O=j.getParent(),p=this.getParent(),e=I&&O&&M&&this.length&&M!==this.length,w=e&&p&&O?p.length/O.length:1,l=I&&!p&&d&&(1!==d.x||1!==d.y||1!==d.z),P=this.animations[0].getKeys();let v,o,R;for(let m=0,i=a.length;m<i;m++)v=a[m],v.frame>=f&&v.frame<=r&&(I?(R=v.value.clone(),e?(o=R.getTranslation(),R.setTranslation(o.scaleInPlace(w))):l&&d?(o=R.getTranslation(),R.setTranslation(o.multiplyInPlace(d))):R=v.value):R=v.value,P.push({frame:v.frame+h,value:R}));return this.animations[0].createRange(S,f+h,r+h),!0}),w&&(w.prototype._animate=function(j){if(!this.animationsEnabled)return;const S=M.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=S}this.deltaTime=void 0!==j?j:this.useConstantAnimationDeltaTime?16:(S-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=S;const h=this._activeAnimatables;if(0===h.length)return;this._animationTime+=this.deltaTime;const I=this._animationTime;for(let m=0;m<h.length;m++){const j=h[m];!j._animate(I)&&j.disposeOnEnd&&m--}!function(j){if(j._registeredForLateAnimationBindings.length){for(let S=0;S<j._registeredForLateAnimationBindings.length;S++){const h=j._registeredForLateAnimationBindings.data[S];for(const j in h._lateAnimationHolders){const S=h._lateAnimationHolders[j],I=S.animations[0],d=S.originalValue;if(void 0===d||null===d)continue;const U=m.c.AllowMatrixDecomposeForInterpolation&&d.m;let f=h[j];if(U)f=p(S);else if(void 0!==d.w)f=e(S,f||r.g.Identity());else{let j=0,h=1;const U=I&&I._animationState.loopMode===m.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(S.totalWeight<1)f=U?d.clone?d.clone():d:I&&d.scale?d.scale(1-S.totalWeight):I?d*(1-S.totalWeight):d.clone?d.clone():d;else if(I){h=S.totalWeight;const m=I.weight/h;f=1!==m?I.currentValue.scale?I.currentValue.scale(m):I.currentValue*m:I.currentValue,U&&(f.addToRef?f.addToRef(d,f):f+=d),j=1}for(let m=j;m<S.animations.length;m++){const j=S.animations[m],I=j.weight/h;I&&(j.currentValue.scaleAndAddToRef?j.currentValue.scaleAndAddToRef(I,f):f+=j.currentValue*I)}for(let m=0;m<S.additiveAnimations.length;m++){const j=S.additiveAnimations[m],h=j.weight;h&&(j.currentValue.scaleAndAddToRef?j.currentValue.scaleAndAddToRef(h,f):f+=j.currentValue*h)}}h[j]=f}h._lateAnimationHolders={}}j._registeredForLateAnimationBindings.reset()}}(this)},w.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((j,S)=>j.playOrder-S.playOrder))},w.prototype.beginWeightedAnimation=function(j,S,h){let m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,I=arguments.length>4?arguments[4]:void 0,d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,U=arguments.length>6?arguments[6]:void 0,f=arguments.length>7?arguments[7]:void 0,r=arguments.length>8?arguments[8]:void 0,a=arguments.length>9?arguments[9]:void 0,M=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const O=this.beginAnimation(j,S,h,I,d,U,f,!1,r,a,M);return O.weight=m,O},w.prototype.beginAnimation=function(j,S,h,m){let I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,d=arguments.length>5?arguments[5]:void 0,U=arguments.length>6?arguments[6]:void 0,f=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],r=arguments.length>8?arguments[8]:void 0,a=arguments.length>9?arguments[9]:void 0,M=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(I<0){const j=S;S=h,h=j,I=-I}S>h&&(I=-I),f&&this.stopAnimation(j,void 0,r),U||(U=new O(this,j,S,h,m,I,d,void 0,a,M));const p=!r||r(j);if(j.animations&&p&&U.appendAnimations(j,j.animations),j.getAnimatables){const M=j.getAnimatables();for(let j=0;j<M.length;j++)this.beginAnimation(M[j],S,h,m,I,d,U,f,r,a)}return U.reset(),U},w.prototype.beginHierarchyAnimation=function(j,S,h,m,I){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,U=arguments.length>6?arguments[6]:void 0,f=arguments.length>7?arguments[7]:void 0,r=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],a=arguments.length>9?arguments[9]:void 0,M=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const O=j.getDescendants(S),p=[];p.push(this.beginAnimation(j,h,m,I,d,U,f,r,a,void 0,M));for(const e of O)p.push(this.beginAnimation(e,h,m,I,d,U,f,r,a,void 0,M));return p},w.prototype.beginDirectAnimation=function(j,S,h,m,I){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(d<0){const j=h;h=m,m=j,d=-d}return h>m&&(d=-d),new O(this,j,h,m,I,d,arguments.length>6?arguments[6]:void 0,S,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},w.prototype.beginDirectHierarchyAnimation=function(j,S,h,m,I,d,U,f,r){let a=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const M=j.getDescendants(S),O=[];O.push(this.beginDirectAnimation(j,h,m,I,d,U,f,r,a));for(const p of M)O.push(this.beginDirectAnimation(p,h,m,I,d,U,f,r,a));return O},w.prototype.getAnimatableByTarget=function(j){for(let S=0;S<this._activeAnimatables.length;S++)if(this._activeAnimatables[S].target===j)return this._activeAnimatables[S];return null},w.prototype.getAllAnimatablesByTarget=function(j){const S=[];for(let h=0;h<this._activeAnimatables.length;h++)this._activeAnimatables[h].target===j&&S.push(this._activeAnimatables[h]);return S},w.prototype.stopAnimation=function(j,S,h){const m=this.getAllAnimatablesByTarget(j);for(const I of m)I.stop(S,h)},w.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let j=0;j<this._activeAnimatables.length;j++)this._activeAnimatables[j].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const j of this.animationGroups)j.stop()});class v{getClassName(){return"TargetedAnimation"}serialize(){const j={};return j.animation=this.animation.serialize(),j.targetId=this.target.id,j}}class o{get mask(){return this._mask}set mask(j){this._mask!==j&&(this._mask=j,this.syncWithMask(!0))}syncWithMask(){let j=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||j){this._numActiveAnimatables=0;for(let j=0;j<this._animatables.length;++j){const S=this._animatables[j];!this.mask||this.mask.disabled||this.mask.retainsTarget(S.target.name)?(this._numActiveAnimatables++,S.paused&&S.restart()):S.paused||S.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let j=0;j<this._animatables.length;++j){const S=this._animatables[j];this.mask.retainsTarget(S.target.name)||(S.stop(),this._animatables.splice(j,1),--j)}for(let j=0;j<this._targetedAnimations.length;j++){const S=this._targetedAnimations[j];this.mask.retainsTarget(S.target.name)||(this._targetedAnimations.splice(j,1),--j)}}}get from(){return this._from}set from(j){if(this._from!==j){this._from=j;for(let j=0;j<this._animatables.length;j++){this._animatables[j].fromFrame=this._from}}}get to(){return this._to}set to(j){if(this._to!==j){this._to=j;for(let j=0;j<this._animatables.length;j++){this._animatables[j].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(j){if(this._speedRatio!==j){this._speedRatio=j;for(let j=0;j<this._animatables.length;j++){this._animatables[j].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(j){if(this._loopAnimation!==j){this._loopAnimation=j;for(let j=0;j<this._animatables.length;j++){this._animatables[j].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(j){if(this._isAdditive!==j){this._isAdditive=j;for(let j=0;j<this._animatables.length;j++){this._animatables[j].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(j){this._weight!==j&&(this._weight=j,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(j){if(this._playOrder!==j&&(this._playOrder=j,this._animatables.length>0)){for(let j=0;j<this._animatables.length;j++)this._animatables[j].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(j){if(this._enableBlending!==j&&(this._enableBlending=j,null!==j))for(let S=0;S<this._targetedAnimations.length;++S)this._targetedAnimations[S].animation.enableBlending=j}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(j){if(this._blendingSpeed!==j&&(this._blendingSpeed=j,null!==j))for(let S=0;S<this._targetedAnimations.length;++S)this._targetedAnimations[S].animation.blendingSpeed=j}getLength(j,S){j=j??this._from;return((S=S??this._to)-j)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(j){let S=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],m=arguments.length>3?arguments[3]:void 0;if(0===j.length)return null;m=m??j[0].weight;let I=Number.MAX_VALUE,d=-Number.MAX_VALUE;if(h)for(const f of j)f.from<I&&(I=f.from),f.to>d&&(d=f.to);const U=new o(j[0].name+"_merged",j[0]._scene,m);for(const f of j){h&&f.normalize(I,d);for(const j of f.targetedAnimations)U.addTargetedAnimation(j.animation,j.target);S&&f.dispose()}return U}constructor(j){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=j,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new I.b,this.onAnimationLoopObservable=new I.b,this.onAnimationGroupLoopObservable=new I.b,this.onAnimationGroupEndObservable=new I.b,this.onAnimationGroupPauseObservable=new I.b,this.onAnimationGroupPlayObservable=new I.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=S||d.d.LastCreatedScene,this._weight=h,this._playOrder=m,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(j,S){const h=new v;h.animation=j,h.target=S;const m=j.getKeys();return this._from>m[0].frame&&(this._from=m[0].frame),this._to<m[m.length-1].frame&&(this._to=m[m.length-1].frame),null!==this._enableBlending&&(j.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(j.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(h),this._shouldStart=!0,h}removeTargetedAnimation(j){for(let S=this._targetedAnimations.length-1;S>-1;S--){this._targetedAnimations[S].animation===j&&this._targetedAnimations.splice(S,1)}}normalize(){let j=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==j&&(j=this._from),null==S&&(S=this._to);for(let h=0;h<this._targetedAnimations.length;h++){const m=this._targetedAnimations[h].animation.getKeys(),I=m[0],d=m[m.length-1];if(I.frame>j){const S={frame:j,value:I.value,inTangent:I.inTangent,outTangent:I.outTangent,interpolation:I.interpolation};m.splice(0,0,S)}if(d.frame<S){const j={frame:S,value:d.value,inTangent:d.inTangent,outTangent:d.outTangent,interpolation:d.interpolation};m.push(j)}}return this._from=j,this._to=S,this}_processLoop(j,S,h){j.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(S),this._animationLoopFlags[h]||(this._animationLoopFlags[h]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let j=arguments.length>0&&void 0!==arguments[0]&&arguments[0],S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0,m=arguments.length>3?arguments[3]:void 0,I=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=j,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let d=0;d<this._targetedAnimations.length;d++){const U=this._targetedAnimations[d],f=this._scene.beginDirectAnimation(U.target,[U.animation],void 0!==h?h:this._from,void 0!==m?m:this._to,j,S,void 0,void 0,void 0!==I?I:this._isAdditive);f.weight=this._weight,f.playOrder=this._playOrder,f.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(U),this._checkAnimationGroupEnded(f)},this._processLoop(f,U,d),this._animatables.push(f)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=S,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let j=0;j<this._animatables.length;j++){this._animatables[j].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(j){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==j&&(this.loopAnimation=j),this.restart()):(this.stop(),this.start(j,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let j=0;j<this._animatables.length;j++){this._animatables[j].reset()}return this}restart(){if(!this._isStarted)return this;for(let j=0;j<this._animatables.length;j++){this._animatables[j].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let j=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const S=this._animatables.slice();for(let m=0;m<S.length;m++)S[m].stop(void 0,void 0,!0,j);let h=0;for(let m=0;m<this._scene._activeAnimatables.length;m++){const S=this._scene._activeAnimatables[m];S._runtimeAnimations.length>0?this._scene._activeAnimatables[h++]=S:j&&this._checkAnimationGroupEnded(S,j)}return this._scene._activeAnimatables.length=h,this._isStarted=!1,this}setWeightForAllAnimatables(j){for(let S=0;S<this._animatables.length;S++){this._animatables[S].weight=j}return this}syncAllAnimationsWith(j){for(let S=0;S<this._animatables.length;S++){this._animatables[S].syncWith(j)}return this}goToFrame(j){if(!this._isStarted)return this;for(let S=0;S<this._animatables.length;S++){this._animatables[S].goToFrame(j)}return this}getCurrentFrame(){var j;return(null===(j=this.animatables[0])||void 0===j?void 0:j.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const j=this._scene.animationGroups.indexOf(this);if(j>-1&&this._scene.animationGroups.splice(j,1),this._parentContainer){const j=this._parentContainer.animationGroups.indexOf(this);j>-1&&this._parentContainer.animationGroups.splice(j,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(j){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const h=this._animatables.indexOf(j);h>-1&&this._animatables.splice(h,1),0===this._animatables.length&&(this._isStarted=!1,S||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(j,S){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const m=new o(j||this.name,this._scene,this._weight,this._playOrder);m._from=this.from,m._to=this.to,m._speedRatio=this.speedRatio,m._loopAnimation=this.loopAnimation,m._isAdditive=this.isAdditive,m._enableBlending=this.enableBlending,m._blendingSpeed=this.blendingSpeed,m.metadata=this.metadata,m.mask=this.mask;for(const I of this._targetedAnimations)m.addTargetedAnimation(h?I.animation.clone():I.animation,S?S(I.target):I.target);return m}serialize(){const j={};j.name=this.name,j.from=this.from,j.to=this.to,j.speedRatio=this.speedRatio,j.loopAnimation=this.loopAnimation,j.isAdditive=this.isAdditive,j.weight=this.weight,j.playOrder=this.playOrder,j.enableBlending=this.enableBlending,j.blendingSpeed=this.blendingSpeed,j.targetedAnimations=[];for(let S=0;S<this.targetedAnimations.length;S++){const h=this.targetedAnimations[S];j.targetedAnimations[S]=h.serialize()}return U.c&&U.c.HasTags(this)&&(j.tags=U.c.GetTags(this)),this.metadata&&(j.metadata=this.metadata),j}static Parse(j,S){const h=new o(j.name,S,j.weight,j.playOrder);for(let I=0;I<j.targetedAnimations.length;I++){const d=j.targetedAnimations[I],U=m.c.Parse(d.animation),f=d.targetId;if("influence"===d.animation.property){const j=S.getMorphTargetById(f);j&&h.addTargetedAnimation(U,j)}else{const j=S.getNodeById(f);null!=j&&h.addTargetedAnimation(U,j)}}return U.c&&U.c.AddTagsTo(h,j.tags),null!==j.from&&null!==j.to&&h.normalize(j.from,j.to),void 0!==j.speedRatio&&(h._speedRatio=j.speedRatio),void 0!==j.loopAnimation&&(h._loopAnimation=j.loopAnimation),void 0!==j.isAdditive&&(h._isAdditive=j.isAdditive),void 0!==j.weight&&(h._weight=j.weight),void 0!==j.playOrder&&(h._playOrder=j.playOrder),void 0!==j.enableBlending&&(h._enableBlending=j.enableBlending),void 0!==j.blendingSpeed&&(h._blendingSpeed=j.blendingSpeed),void 0!==j.metadata&&(h.metadata=j.metadata),h}static MakeAnimationAdditive(j,S,h){let I;I="object"===typeof S?S:{referenceFrame:S,range:h,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let d=j;I.cloneOriginalAnimationGroup&&(d=j.clone(I.clonedAnimationGroupName||d.name));const U=d.targetedAnimations;for(let f=0;f<U.length;f++){const j=U[f];j.animation=m.c.MakeAnimationAdditive(j.animation,I)}if(d.isAdditive=!0,I.clipKeys){let j=Number.MAX_VALUE,S=-Number.MAX_VALUE;const h=d.targetedAnimations;for(let m=0;m<h.length;m++){const I=h[m].animation.getKeys();j>I[0].frame&&(j=I[0].frame),S<I[I.length-1].frame&&(S=I[I.length-1].frame)}d._from=j,d._to=S}return d}static ClipKeys(j,S,h,m,I){const d=j.clone(m||j.name);return o.ClipKeysInPlace(d,S,h,I)}static ClipKeysInPlace(j,S,h,m){return o.ClipInPlace(j,S,h,m,!1)}static ClipFrames(j,S,h,m,I){const d=j.clone(m||j.name);return o.ClipFramesInPlace(d,S,h,I)}static ClipFramesInPlace(j,S,h,m){return o.ClipInPlace(j,S,h,m,!0)}static ClipInPlace(j,S,h,m){let I=arguments.length>4&&void 0!==arguments[4]&&arguments[4],d=Number.MAX_VALUE,U=-Number.MAX_VALUE;const f=j.targetedAnimations;for(let r=0;r<f.length;r++){const j=f[r],a=m?j.animation:j.animation.clone();I&&(a.createKeyForFrame(S),a.createKeyForFrame(h));const M=a.getKeys(),O=[];let p=Number.MAX_VALUE;for(let m=0;m<M.length;m++){const j=M[m];if(!I&&m>=S&&m<=h||I&&j.frame>=S&&j.frame<=h){const S={frame:j.frame,value:j.value.clone?j.value.clone():j.value,inTangent:j.inTangent,outTangent:j.outTangent,interpolation:j.interpolation,lockedTangent:j.lockedTangent};p===Number.MAX_VALUE&&(p=S.frame),S.frame-=p,O.push(S)}}0!==O.length?(d>O[0].frame&&(d=O[0].frame),U<O[O.length-1].frame&&(U=O[O.length-1].frame),a.setKeys(O,!0),j.animation=a):(f.splice(r,1),r--)}return j._from=d,j._to=U,j}getClassName(){return"AnimationGroup"}toString(j){let S="Name: "+this.name;return S+=", type: "+this.getClassName(),j&&(S+=", from: "+this._from,S+=", to: "+this._to,S+=", isStarted: "+this._isStarted,S+=", speedRatio: "+this._speedRatio,S+=", targetedAnimations length: "+this._targetedAnimations.length,S+=", animatables length: "+this._animatables),S}}}}]);