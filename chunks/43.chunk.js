"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{13283:(I,S,d)=>{d.r(S),d.d(S,{AnimationGroup:()=>t,TargetedAnimation:()=>G});var N=d(12626),O=d(1011),g=d(1035),T=d(1166),q=d(12621),a=d(1020);class f{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(I,S,d,O){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=S,this._target=I,this._scene=d,this._host=O,this._activeTargets=[],S._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===N.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=a.e.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const I={frame:0,value:this._minValue};this._keys.splice(0,0,I)}if(this._target instanceof Array){let I=0;for(const S of this._target)this._preparePath(S,I),this._getOriginalValues(I),I++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const g=S.getEvents();g&&g.length>0&&g.forEach((I=>{this._events.push(I._clone())})),this._enableBlending=I&&I.animationPropertiesOverride?I.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(I){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const d=this._animation.targetPropertyPath;if(d.length>1){let N=I;for(let I=0;I<d.length-1;I++){const S=d[I];if(N=N[S],void 0===N)throw new Error(`Invalid property (${S}) in property path (${d.join(".")})`)}this._targetPath=d[d.length-1],this._activeTargets[S]=N}else this._targetPath=d[0],this._activeTargets[S]=I;if(void 0===this._activeTargets[S][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${d.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let I=0;for(const S of this._target)void 0!==this._originalValue[I]&&this._setValue(S,this._activeTargets[I],this._originalValue[I],-1,I),I++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let I=0;I<this._events.length;I++)this._events[I].isDone=!1}isStopped(){return this._stopped}dispose(){const I=this._animation.runtimeAnimations.indexOf(this);I>-1&&this._animation.runtimeAnimations.splice(I,1)}setValue(I,S){if(this._targetIsArray)for(let d=0;d<this._target.length;d++){const N=this._target[d];this._setValue(N,this._activeTargets[d],I,S,d)}else this._setValue(this._target,this._directTarget,I,S,0)}_getOriginalValues(){let I,S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const d=this._activeTargets[S];I=d.getLocalMatrix&&"_matrix"===this._targetPath?d.getLocalMatrix():d[this._targetPath],I&&I.clone?this._originalValue[S]=I.clone():this._originalValue[S]=I}_registerTargetForLateAnimationBinding(I,S){const d=I.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(d),d._lateAnimationHolders||(d._lateAnimationHolders={}),d._lateAnimationHolders[I.targetPath]||(d._lateAnimationHolders[I.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:S}),I.isAdditive?(d._lateAnimationHolders[I.targetPath].additiveAnimations.push(I),d._lateAnimationHolders[I.targetPath].totalAdditiveWeight+=I.weight):(d._lateAnimationHolders[I.targetPath].animations.push(I),d._lateAnimationHolders[I.targetPath].totalWeight+=I.weight)}_setValue(I,S,d,O,g){if(this._currentActiveTarget=S,this._weight=O,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const I=S[this._targetPath];I.clone?this._originalBlendValue=I.clone():this._originalBlendValue=I}this._originalBlendValue.m?N.d.AllowMatrixDecomposeForInterpolation?this._currentValue?a.e.DecomposeLerpToRef(this._originalBlendValue,d,this._blendingFactor,this._currentValue):this._currentValue=a.e.DecomposeLerp(this._originalBlendValue,d,this._blendingFactor):this._currentValue?a.e.LerpToRef(this._originalBlendValue,d,this._blendingFactor,this._currentValue):this._currentValue=a.e.Lerp(this._originalBlendValue,d,this._blendingFactor):this._currentValue=N.d._UniversalLerp(this._originalBlendValue,d,this._blendingFactor);const O=I&&I.animationPropertiesOverride?I.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=O}else this._currentValue?this._currentValue.p?this._currentValue.p(d):this._currentValue=d:null!==d&&void 0!==d&&d.clone?this._currentValue=d.clone():this._currentValue=d;-1!==O?this._registerTargetForLateAnimationBinding(this,this._originalValue[g]):this._animationState.loopMode===N.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[g],S[this._targetPath]):S[this._targetPath]=this._originalValue[g]+this._currentValue:S[this._targetPath]=this._currentValue,I.De&&I.De(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(I){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const d=this._animation.getKeys();I<d[0].frame?I=d[0].frame:I>d[d.length-1].frame&&(I=d[d.length-1].frame);const N=this._events;if(N.length)for(let g=0;g<N.length;g++)N[g].onlyOnce||(N[g].isDone=N[g].frame<I);this._currentFrame=I;const O=this._animation._interpolate(I,this._animationState);this.setValue(O,S)}_prepareForSpeedRatioChange(I){const S=this._previousElapsedTime*(this._animation.framePerSecond*I)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-S}animate(I,S,d,O,g){let T=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const q=this._animation,a=q.targetPropertyPath;if(!a||a.length<1)return this._stopped=!0,!1;let f=!0;(S<this._minFrame||S>this._maxFrame)&&(S=this._minFrame),(d<this._minFrame||d>this._maxFrame)&&(d=this._maxFrame);const Y=d-S;let p,E=I*(q.framePerSecond*g)/1e3+this._absoluteFrameOffset,o=0,k=!1;const U=O&&this._animationState.loopMode===N.d.ANIMATIONLOOPMODE_YOYO;if(U){const I=(E-S)/Y,d=Math.sin(I*Math.PI);E=Math.abs(d)*Y+S;const N=d>=0?1:-1;this._yoyoDirection!==N&&(k=!0),this._yoyoDirection=N}if(this._previousElapsedTime=I,this._previousAbsoluteFrame=E,!O&&d>=S&&(E>=Y&&g>0||E<=0&&g<0))f=!1,o=q._getKeyValue(this._maxValue);else if(!O&&S>=d&&(E<=Y&&g<0||E>=0&&g>0))f=!1,o=q._getKeyValue(this._minValue);else if(this._animationState.loopMode!==N.d.ANIMATIONLOOPMODE_CYCLE){const I=d.toString()+S.toString();if(!this._offsetsCache[I]){this._animationState.repeatCount=0,this._animationState.loopMode=N.d.ANIMATIONLOOPMODE_CYCLE;const O=q._interpolate(S,this._animationState),g=q._interpolate(d,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),q.dataType){case N.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[I]=g-O;break;case N.d.ANIMATIONTYPE_QUATERNION:case N.d.ANIMATIONTYPE_VECTOR3:case N.d.ANIMATIONTYPE_VECTOR2:case N.d.ANIMATIONTYPE_SIZE:case N.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[I]=g.vc(O)}this._highLimitsCache[I]=g}o=this._highLimitsCache[I],p=this._offsetsCache[I]}if(void 0===p)switch(q.dataType){case N.d.ANIMATIONTYPE_FLOAT:p=0;break;case N.d.ANIMATIONTYPE_QUATERNION:p=N.i;break;case N.d.ANIMATIONTYPE_VECTOR3:p=N.r;break;case N.d.ANIMATIONTYPE_VECTOR2:p=N.o;break;case N.d.ANIMATIONTYPE_SIZE:p=N.m;break;case N.d.ANIMATIONTYPE_COLOR3:p=N.e;break;case N.d.ANIMATIONTYPE_COLOR4:p=N.f}let i;if(this._host&&this._host.syncRoot){const I=this._host.syncRoot;i=S+Y*((I.masterFrame-I.fromFrame)/(I.toFrame-I.fromFrame))}else i=E>0&&S>d||E<0&&S<d?f&&0!==Y?d+E%Y:S:f&&0!==Y?S+E%Y:d;const G=this._events;if(!U&&(g>0&&this.currentFrame>i||g<0&&this.currentFrame<i)||U&&k){this._onLoop();for(let I=0;I<G.length;I++)G[I].onlyOnce||(G[I].isDone=!1);this._animationState.key=g>0?0:q.getKeys().length-1}this._currentFrame=i,this._animationState.repeatCount=0===Y?0:E/Y|0,this._animationState.highLimitValue=o,this._animationState.offsetValue=p;const t=q._interpolate(i,this._animationState);if(this.setValue(t,T),G.length)for(let N=0;N<G.length;N++)if(Y>=0&&i>=G[N].frame&&G[N].frame>=S||Y<0&&i<=G[N].frame&&G[N].frame<=S){const I=G[N];I.isDone||(I.onlyOnce&&(G.splice(N,1),N--),I.isDone=!0,I.action(i))}return f||(this._stopped=!0),f}}var Y=d(1128);class p{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(I){this._weight=-1!==I?Math.min(Math.max(I,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(I){for(let S=0;S<this._runtimeAnimations.length;S++){this._runtimeAnimations[S]._prepareForSpeedRatioChange(I)}this._speedRatio=I,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(I,S){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,g=arguments.length>4&&void 0!==arguments[4]&&arguments[4],T=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,q=arguments.length>6?arguments[6]:void 0,a=arguments.length>7?arguments[7]:void 0,f=arguments.length>8?arguments[8]:void 0,Y=arguments.length>9&&void 0!==arguments[9]&&arguments[9],p=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=S,this.fromFrame=d,this.toFrame=N,this.loopAnimation=g,this.onAnimationEnd=q,this.onAnimationLoop=f,this.isAdditive=Y,this.playOrder=p,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Cf=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new O.c,this.onAnimationLoopObservable=new O.c,this._scene=I,a&&this.appendAnimations(S,a),this._speedRatio=T,I._activeAnimatables.push(this)}syncWith(I){if(this._syncRoot=I,I){const I=this._scene._activeAnimatables.indexOf(this);I>-1&&(this._scene._activeAnimatables.splice(I,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(I,S){for(let d=0;d<S.length;d++){const N=S[d],O=new f(I,N,this._scene,this);O._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(O)}}getAnimationByTargetProperty(I){const S=this._runtimeAnimations;for(let d=0;d<S.length;d++)if(S[d].animation.targetProperty===I)return S[d].animation;return null}getRuntimeAnimationByTargetProperty(I){const S=this._runtimeAnimations;for(let d=0;d<S.length;d++)if(S[d].animation.targetProperty===I)return S[d];return null}reset(){const I=this._runtimeAnimations;for(let S=0;S<I.length;S++)I[S].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(I){const S=this._runtimeAnimations;for(let d=0;d<S.length;d++)S[d].animation.enableBlending=!0,S[d].animation.blendingSpeed=I}disableBlending(){const I=this._runtimeAnimations;for(let S=0;S<I.length;S++)I[S].animation.enableBlending=!1}goToFrame(I){const S=this._runtimeAnimations;if(S[0]){const d=S[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??S[0].currentFrame;const N=0===this.speedRatio?0:(I-this._frameToSyncFromJump)/d*1e3/this.speedRatio;this._manualJumpDelay=-N}for(let d=0;d<S.length;d++)S[d].goToFrame(I,this._weight);this._goToFrame=I}get paused(){return this.Cf}pause(){this.Cf||(this.Cf=!0)}restart(){this.Cf=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(I,S){let d=arguments.length>2&&void 0!==arguments[2]&&arguments[2],N=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(I||S){const O=this._scene._activeAnimatables.indexOf(this);if(O>-1){const g=this._runtimeAnimations;for(let d=g.length-1;d>=0;d--){const N=g[d];I&&N.animation.name!=I||(S&&!S(N.target)||(N.dispose(),g.splice(d,1)))}0==g.length&&(d||this._scene._activeAnimatables.splice(O,1),N||this._raiseOnAnimationEnd())}}else{const I=this._scene._activeAnimatables.indexOf(this);if(I>-1){d||this._scene._activeAnimatables.splice(I,1);const S=this._runtimeAnimations;for(let I=0;I<S.length;I++)S[I].dispose();this._runtimeAnimations.length=0,N||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((I=>{this.onAnimationEndObservable.add((()=>{I(this)}),void 0,void 0,this,!0)}))}_animate(I){if(this.Cf)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=I),!0;if(null===this._localDelayOffset?(this._localDelayOffset=I,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=I-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let S=!1;const d=this._runtimeAnimations;let N;for(N=0;N<d.length;N++){const O=d[N].animate(I-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);S=S||O}if(this.animationStarted=S,!S){if(this.disposeOnEnd)for(N=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(N,1),N=0;N<d.length;N++)d[N].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return S}}function E(I){if(0===I.totalWeight&&0===I.totalAdditiveWeight)return I.originalValue;let S=1;const d=a.j.Cd[0],N=a.j.Cd[1],O=a.j.Quaternion[0];let g=0;const T=I.animations[0],q=I.originalValue;let f=1,Y=!1;if(I.totalWeight<1)f=1-I.totalWeight,q.decompose(N,O,d);else{if(g=1,S=I.totalWeight,f=T.weight/S,1==f){if(!I.totalAdditiveWeight)return T.currentValue;Y=!0}T.currentValue.decompose(N,O,d)}if(!Y){N.scaleInPlace(f),d.scaleInPlace(f),O.scaleInPlace(f);for(let T=g;T<I.animations.length;T++){const g=I.animations[T];if(0===g.weight)continue;f=g.weight/S;const q=a.j.Cd[2],Y=a.j.Cd[3],p=a.j.Quaternion[1];g.currentValue.decompose(Y,p,q),Y.scaleAndAddToRef(f,N),p.scaleAndAddToRef(a.g.Dot(O,p)>0?f:-f,O),q.scaleAndAddToRef(f,d)}O.normalize()}for(let E=0;E<I.additiveAnimations.length;E++){const S=I.additiveAnimations[E];if(0===S.weight)continue;const g=a.j.Cd[2],T=a.j.Cd[3],q=a.j.Quaternion[1];S.currentValue.decompose(T,q,g),T.multiplyToRef(N,T),a.p.LerpToRef(N,T,S.weight,N),O.multiplyToRef(q,q),a.g.SlerpToRef(O,q,S.weight,O),g.scaleAndAddToRef(S.weight,d)}const p=T?T._animationState.workValue:a.j.Matrix[0].clone();return a.e.ComposeToRef(N,O,d,p),p}function o(I,S){if(0===I.totalWeight&&0===I.totalAdditiveWeight)return S;const d=I.animations[0],N=I.originalValue;let O=S;if(0===I.totalWeight&&I.totalAdditiveWeight>0)O.p(N);else if(1===I.animations.length){if(a.g.SlerpToRef(N,d.currentValue,Math.min(1,I.totalWeight),O),0===I.totalAdditiveWeight)return O}else if(I.animations.length>1){let d,g,T=1;if(I.totalWeight<1){const S=1-I.totalWeight;d=[],g=[],d.push(N),g.push(S)}else{if(2===I.animations.length&&(a.g.SlerpToRef(I.animations[0].currentValue,I.animations[1].currentValue,I.animations[1].weight/I.totalWeight,S),0===I.totalAdditiveWeight))return S;d=[],g=[],T=I.totalWeight}for(let S=0;S<I.animations.length;S++){const N=I.animations[S];d.push(N.currentValue),g.push(N.weight/T)}let q=0;for(let I=0;I<d.length;)I?(q+=g[I],a.g.SlerpToRef(O,d[I],g[I]/q,O),I++):(a.g.SlerpToRef(d[I],d[I+1],g[I+1]/(g[I]+g[I+1]),S),O=S,q=g[I]+g[I+1],I+=2)}for(let g=0;g<I.additiveAnimations.length;g++){const S=I.additiveAnimations[g];0!==S.weight&&(O.multiplyToRef(S.currentValue,a.j.Quaternion[0]),a.g.SlerpToRef(O,a.j.Quaternion[0],S.weight,O))}return O}var k,U,i=d(1209);k=i.c,(U=q.c)&&(U.prototype.copyAnimationRange=function(I,S,d){let O=arguments.length>3&&void 0!==arguments[3]&&arguments[3],g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new N.d(this.name,"_matrix",I.animations[0].framePerSecond,N.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const T=I.animations[0].getRange(S);if(!T)return!1;const q=T.from,a=T.to,f=I.animations[0].getKeys(),Y=I.length,p=I.getParent(),E=this.getParent(),o=O&&p&&Y&&this.length&&Y!==this.length,k=o&&E&&p?E.length/p.length:1,U=O&&!E&&g&&(1!==g.x||1!==g.y||1!==g.z),i=this.animations[0].getKeys();let G,t,j;for(let N=0,C=f.length;N<C;N++)G=f[N],G.frame>=q&&G.frame<=a&&(O?(j=G.value.clone(),o?(t=j.getTranslation(),j.setTranslation(t.scaleInPlace(k))):U&&g?(t=j.getTranslation(),j.setTranslation(t.multiplyInPlace(g))):j=G.value):j=G.value,i.push({frame:G.frame+d,value:j}));return this.animations[0].createRange(S,q+d,a+d),!0}),k&&(k.prototype._animate=function(I){if(!this.animationsEnabled)return;const S=Y.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=S}this.deltaTime=void 0!==I?I:this.useConstantAnimationDeltaTime?16:(S-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=S;const d=this._activeAnimatables;if(0===d.length)return;this._animationTime+=this.deltaTime;const O=this._animationTime;for(let N=0;N<d.length;N++){const I=d[N];!I._animate(O)&&I.disposeOnEnd&&N--}!function(I){if(I._registeredForLateAnimationBindings.length){for(let S=0;S<I._registeredForLateAnimationBindings.length;S++){const d=I._registeredForLateAnimationBindings.data[S];for(const I in d._lateAnimationHolders){const S=d._lateAnimationHolders[I],O=S.animations[0],g=S.originalValue;if(void 0===g||null===g)continue;const T=N.d.AllowMatrixDecomposeForInterpolation&&g.m;let q=d[I];if(T)q=E(S);else if(void 0!==g.w)q=o(S,q||a.g.Identity());else{let I=0,d=1;const T=O&&O._animationState.loopMode===N.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(S.totalWeight<1)q=T?g.clone?g.clone():g:O&&g.scale?g.scale(1-S.totalWeight):O?g*(1-S.totalWeight):g.clone?g.clone():g;else if(O){d=S.totalWeight;const N=O.weight/d;q=1!==N?O.currentValue.scale?O.currentValue.scale(N):O.currentValue*N:O.currentValue,T&&(q.addToRef?q.addToRef(g,q):q+=g),I=1}for(let N=I;N<S.animations.length;N++){const I=S.animations[N],O=I.weight/d;O&&(I.currentValue.scaleAndAddToRef?I.currentValue.scaleAndAddToRef(O,q):q+=I.currentValue*O)}for(let N=0;N<S.additiveAnimations.length;N++){const I=S.additiveAnimations[N],d=I.weight;d&&(I.currentValue.scaleAndAddToRef?I.currentValue.scaleAndAddToRef(d,q):q+=I.currentValue*d)}}d[I]=q}d._lateAnimationHolders={}}I._registeredForLateAnimationBindings.reset()}}(this)},k.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((I,S)=>I.playOrder-S.playOrder))},k.prototype.beginWeightedAnimation=function(I,S,d){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,O=arguments.length>4?arguments[4]:void 0,g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,T=arguments.length>6?arguments[6]:void 0,q=arguments.length>7?arguments[7]:void 0,a=arguments.length>8?arguments[8]:void 0,f=arguments.length>9?arguments[9]:void 0,Y=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const p=this.beginAnimation(I,S,d,O,g,T,q,!1,a,f,Y);return p.weight=N,p},k.prototype.beginAnimation=function(I,S,d,N){let O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,g=arguments.length>5?arguments[5]:void 0,T=arguments.length>6?arguments[6]:void 0,q=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],a=arguments.length>8?arguments[8]:void 0,f=arguments.length>9?arguments[9]:void 0,Y=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(O<0){const I=S;S=d,d=I,O=-O}S>d&&(O=-O),q&&this.stopAnimation(I,void 0,a),T||(T=new p(this,I,S,d,N,O,g,void 0,f,Y));const E=!a||a(I);if(I.animations&&E&&T.appendAnimations(I,I.animations),I.getAnimatables){const Y=I.getAnimatables();for(let I=0;I<Y.length;I++)this.beginAnimation(Y[I],S,d,N,O,g,T,q,a,f)}return T.reset(),T},k.prototype.beginHierarchyAnimation=function(I,S,d,N,O){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,T=arguments.length>6?arguments[6]:void 0,q=arguments.length>7?arguments[7]:void 0,a=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],f=arguments.length>9?arguments[9]:void 0,Y=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const p=I.getDescendants(S),E=[];E.push(this.beginAnimation(I,d,N,O,g,T,q,a,f,void 0,Y));for(const o of p)E.push(this.beginAnimation(o,d,N,O,g,T,q,a,f,void 0,Y));return E},k.prototype.beginDirectAnimation=function(I,S,d,N,O){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(g<0){const I=d;d=N,N=I,g=-g}return d>N&&(g=-g),new p(this,I,d,N,O,g,arguments.length>6?arguments[6]:void 0,S,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},k.prototype.beginDirectHierarchyAnimation=function(I,S,d,N,O,g,T,q,a){let f=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const Y=I.getDescendants(S),p=[];p.push(this.beginDirectAnimation(I,d,N,O,g,T,q,a,f));for(const E of Y)p.push(this.beginDirectAnimation(E,d,N,O,g,T,q,a,f));return p},k.prototype.getAnimatableByTarget=function(I){for(let S=0;S<this._activeAnimatables.length;S++)if(this._activeAnimatables[S].target===I)return this._activeAnimatables[S];return null},k.prototype.getAllAnimatablesByTarget=function(I){const S=[];for(let d=0;d<this._activeAnimatables.length;d++)this._activeAnimatables[d].target===I&&S.push(this._activeAnimatables[d]);return S},k.prototype.stopAnimation=function(I,S,d){const N=this.getAllAnimatablesByTarget(I);for(const O of N)O.stop(S,d)},k.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let I=0;I<this._activeAnimatables.length;I++)this._activeAnimatables[I].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const I of this.animationGroups)I.stop()});class G{getClassName(){return"TargetedAnimation"}serialize(){const I={};return I.animation=this.animation.serialize(),I.targetId=this.target.id,I}}class t{get mask(){return this._mask}set mask(I){this._mask!==I&&(this._mask=I,this.syncWithMask(!0))}syncWithMask(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||I){this._numActiveAnimatables=0;for(let I=0;I<this._animatables.length;++I){const S=this._animatables[I];!this.mask||this.mask.disabled||this.mask.retainsTarget(S.target.name)?(this._numActiveAnimatables++,S.paused&&S.restart()):S.paused||S.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let I=0;I<this._animatables.length;++I){const S=this._animatables[I];this.mask.retainsTarget(S.target.name)||(S.stop(),this._animatables.splice(I,1),--I)}for(let I=0;I<this._targetedAnimations.length;I++){const S=this._targetedAnimations[I];this.mask.retainsTarget(S.target.name)||(this._targetedAnimations.splice(I,1),--I)}}}get from(){return this._from}set from(I){if(this._from!==I){this._from=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].fromFrame=this._from}}}get to(){return this._to}set to(I){if(this._to!==I){this._to=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(I){if(this._speedRatio!==I){this._speedRatio=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(I){if(this._loopAnimation!==I){this._loopAnimation=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(I){if(this._isAdditive!==I){this._isAdditive=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(I){this._weight!==I&&(this._weight=I,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(I){if(this._playOrder!==I&&(this._playOrder=I,this._animatables.length>0)){for(let I=0;I<this._animatables.length;I++)this._animatables[I].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(I){if(this._enableBlending!==I&&(this._enableBlending=I,null!==I))for(let S=0;S<this._targetedAnimations.length;++S)this._targetedAnimations[S].animation.enableBlending=I}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(I){if(this._blendingSpeed!==I&&(this._blendingSpeed=I,null!==I))for(let S=0;S<this._targetedAnimations.length;++S)this._targetedAnimations[S].animation.blendingSpeed=I}getLength(I,S){I=I??this._from;return((S=S??this._to)-I)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(I){let S=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],d=arguments.length>2&&void 0!==arguments[2]&&arguments[2],N=arguments.length>3?arguments[3]:void 0;if(0===I.length)return null;N=N??I[0].weight;let O=Number.MAX_VALUE,g=-Number.MAX_VALUE;if(d)for(const q of I)q.from<O&&(O=q.from),q.to>g&&(g=q.to);const T=new t(I[0].name+"_merged",I[0]._scene,N);for(const q of I){d&&q.normalize(O,g);for(const I of q.targetedAnimations)T.addTargetedAnimation(I.animation,I.target);S&&q.dispose()}return T}constructor(I){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=I,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new O.c,this.onAnimationLoopObservable=new O.c,this.onAnimationGroupLoopObservable=new O.c,this.onAnimationGroupEndObservable=new O.c,this.onAnimationGroupPauseObservable=new O.c,this.onAnimationGroupPlayObservable=new O.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=S||g.e.LastCreatedScene,this._weight=d,this._playOrder=N,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(I,S){const d=new G;d.animation=I,d.target=S;const N=I.getKeys();return this._from>N[0].frame&&(this._from=N[0].frame),this._to<N[N.length-1].frame&&(this._to=N[N.length-1].frame),null!==this._enableBlending&&(I.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(I.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(d),this._shouldStart=!0,d}removeTargetedAnimation(I){for(let S=this._targetedAnimations.length-1;S>-1;S--){this._targetedAnimations[S].animation===I&&this._targetedAnimations.splice(S,1)}}normalize(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==I&&(I=this._from),null==S&&(S=this._to);for(let d=0;d<this._targetedAnimations.length;d++){const N=this._targetedAnimations[d].animation.getKeys(),O=N[0],g=N[N.length-1];if(O.frame>I){const S={frame:I,value:O.value,inTangent:O.inTangent,outTangent:O.outTangent,interpolation:O.interpolation};N.splice(0,0,S)}if(g.frame<S){const I={frame:S,value:g.value,inTangent:g.inTangent,outTangent:g.outTangent,interpolation:g.interpolation};N.push(I)}}return this._from=I,this._to=S,this}_processLoop(I,S,d){I.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(S),this._animationLoopFlags[d]||(this._animationLoopFlags[d]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0],S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,d=arguments.length>2?arguments[2]:void 0,N=arguments.length>3?arguments[3]:void 0,O=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=I,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let g=0;g<this._targetedAnimations.length;g++){const T=this._targetedAnimations[g],q=this._scene.beginDirectAnimation(T.target,[T.animation],void 0!==d?d:this._from,void 0!==N?N:this._to,I,S,void 0,void 0,void 0!==O?O:this._isAdditive);q.weight=this._weight,q.playOrder=this._playOrder,q.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(T),this._checkAnimationGroupEnded(q)},this._processLoop(q,T,g),this._animatables.push(q)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=S,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let I=0;I<this._animatables.length;I++){this._animatables[I].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(I){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==I&&(this.loopAnimation=I),this.restart()):(this.stop(),this.start(I,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let I=0;I<this._animatables.length;I++){this._animatables[I].reset()}return this}restart(){if(!this._isStarted)return this;for(let I=0;I<this._animatables.length;I++){this._animatables[I].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const S=this._animatables.slice();for(let N=0;N<S.length;N++)S[N].stop(void 0,void 0,!0,I);let d=0;for(let N=0;N<this._scene._activeAnimatables.length;N++){const S=this._scene._activeAnimatables[N];S._runtimeAnimations.length>0?this._scene._activeAnimatables[d++]=S:I&&this._checkAnimationGroupEnded(S,I)}return this._scene._activeAnimatables.length=d,this._isStarted=!1,this}setWeightForAllAnimatables(I){for(let S=0;S<this._animatables.length;S++){this._animatables[S].weight=I}return this}syncAllAnimationsWith(I){for(let S=0;S<this._animatables.length;S++){this._animatables[S].syncWith(I)}return this}goToFrame(I){if(!this._isStarted)return this;for(let S=0;S<this._animatables.length;S++){this._animatables[S].goToFrame(I)}return this}getCurrentFrame(){var I;return(null===(I=this.animatables[0])||void 0===I?void 0:I.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const I=this._scene.animationGroups.indexOf(this);if(I>-1&&this._scene.animationGroups.splice(I,1),this._parentContainer){const I=this._parentContainer.animationGroups.indexOf(this);I>-1&&this._parentContainer.animationGroups.splice(I,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(I){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const d=this._animatables.indexOf(I);d>-1&&this._animatables.splice(d,1),0===this._animatables.length&&(this._isStarted=!1,S||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(I,S){let d=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const N=new t(I||this.name,this._scene,this._weight,this._playOrder);N._from=this.from,N._to=this.to,N._speedRatio=this.speedRatio,N._loopAnimation=this.loopAnimation,N._isAdditive=this.isAdditive,N._enableBlending=this.enableBlending,N._blendingSpeed=this.blendingSpeed,N.metadata=this.metadata,N.mask=this.mask;for(const O of this._targetedAnimations)N.addTargetedAnimation(d?O.animation.clone():O.animation,S?S(O.target):O.target);return N}serialize(){const I={};I.name=this.name,I.from=this.from,I.to=this.to,I.speedRatio=this.speedRatio,I.loopAnimation=this.loopAnimation,I.isAdditive=this.isAdditive,I.weight=this.weight,I.playOrder=this.playOrder,I.enableBlending=this.enableBlending,I.blendingSpeed=this.blendingSpeed,I.targetedAnimations=[];for(let S=0;S<this.targetedAnimations.length;S++){const d=this.targetedAnimations[S];I.targetedAnimations[S]=d.serialize()}return T.b&&T.b.HasTags(this)&&(I.tags=T.b.GetTags(this)),this.metadata&&(I.metadata=this.metadata),I}static Parse(I,S){const d=new t(I.name,S,I.weight,I.playOrder);for(let O=0;O<I.targetedAnimations.length;O++){const g=I.targetedAnimations[O],T=N.d.Parse(g.animation),q=g.targetId;if("influence"===g.animation.property){const I=S.getMorphTargetById(q);I&&d.addTargetedAnimation(T,I)}else{const I=S.getNodeById(q);null!=I&&d.addTargetedAnimation(T,I)}}return T.b&&T.b.AddTagsTo(d,I.tags),null!==I.from&&null!==I.to&&d.normalize(I.from,I.to),void 0!==I.speedRatio&&(d._speedRatio=I.speedRatio),void 0!==I.loopAnimation&&(d._loopAnimation=I.loopAnimation),void 0!==I.isAdditive&&(d._isAdditive=I.isAdditive),void 0!==I.weight&&(d._weight=I.weight),void 0!==I.playOrder&&(d._playOrder=I.playOrder),void 0!==I.enableBlending&&(d._enableBlending=I.enableBlending),void 0!==I.blendingSpeed&&(d._blendingSpeed=I.blendingSpeed),void 0!==I.metadata&&(d.metadata=I.metadata),d}static MakeAnimationAdditive(I,S,d){let O;O="object"===typeof S?S:{referenceFrame:S,range:d,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let g=I;O.cloneOriginalAnimationGroup&&(g=I.clone(O.clonedAnimationGroupName||g.name));const T=g.targetedAnimations;for(let q=0;q<T.length;q++){const I=T[q];I.animation=N.d.MakeAnimationAdditive(I.animation,O)}if(g.isAdditive=!0,O.clipKeys){let I=Number.MAX_VALUE,S=-Number.MAX_VALUE;const d=g.targetedAnimations;for(let N=0;N<d.length;N++){const O=d[N].animation.getKeys();I>O[0].frame&&(I=O[0].frame),S<O[O.length-1].frame&&(S=O[O.length-1].frame)}g._from=I,g._to=S}return g}static ClipKeys(I,S,d,N,O){const g=I.clone(N||I.name);return t.ClipKeysInPlace(g,S,d,O)}static ClipKeysInPlace(I,S,d,N){return t.ClipInPlace(I,S,d,N,!1)}static ClipFrames(I,S,d,N,O){const g=I.clone(N||I.name);return t.ClipFramesInPlace(g,S,d,O)}static ClipFramesInPlace(I,S,d,N){return t.ClipInPlace(I,S,d,N,!0)}static ClipInPlace(I,S,d,N){let O=arguments.length>4&&void 0!==arguments[4]&&arguments[4],g=Number.MAX_VALUE,T=-Number.MAX_VALUE;const q=I.targetedAnimations;for(let a=0;a<q.length;a++){const I=q[a],f=N?I.animation:I.animation.clone();O&&(f.createKeyForFrame(S),f.createKeyForFrame(d));const Y=f.getKeys(),p=[];let E=Number.MAX_VALUE;for(let N=0;N<Y.length;N++){const I=Y[N];if(!O&&N>=S&&N<=d||O&&I.frame>=S&&I.frame<=d){const S={frame:I.frame,value:I.value.clone?I.value.clone():I.value,inTangent:I.inTangent,outTangent:I.outTangent,interpolation:I.interpolation,lockedTangent:I.lockedTangent};E===Number.MAX_VALUE&&(E=S.frame),S.frame-=E,p.push(S)}}0!==p.length?(g>p[0].frame&&(g=p[0].frame),T<p[p.length-1].frame&&(T=p[p.length-1].frame),f.setKeys(p,!0),I.animation=f):(q.splice(a,1),a--)}return I._from=g,I._to=T,I}getClassName(){return"AnimationGroup"}toString(I){let S="Name: "+this.name;return S+=", type: "+this.getClassName(),I&&(S+=", from: "+this._from,S+=", to: "+this._to,S+=", isStarted: "+this._isStarted,S+=", speedRatio: "+this._speedRatio,S+=", targetedAnimations length: "+this._targetedAnimations.length,S+=", animatables length: "+this._animatables),S}}}}]);