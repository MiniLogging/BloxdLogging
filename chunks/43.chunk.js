"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12546:(f,Q,H)=>{H.r(Q),H.d(Q,{AnimationGroup:()=>e,TargetedAnimation:()=>n});var X=H(11903),i=H(994),S=H(1027),x=H(1156),K=H(11901),Z=H(1003);class B{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(f,Q,H,i){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=Q,this._target=f,this._scene=H,this._host=i,this._activeTargets=[],Q._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===X.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=Z.e.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const f={frame:0,value:this._minValue};this._keys.splice(0,0,f)}if(this._target instanceof Array){let f=0;for(const Q of this._target)this._preparePath(Q,f),this._getOriginalValues(f),f++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const S=Q.getEvents();S&&S.length>0&&S.forEach((f=>{this._events.push(f._clone())})),this._enableBlending=f&&f.animationPropertiesOverride?f.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(f){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=this._animation.targetPropertyPath;if(H.length>1){let X=f;for(let f=0;f<H.length-1;f++){const Q=H[f];if(X=X[Q],void 0===X)throw new Error(`Invalid property (${Q}) in property path (${H.join(".")})`)}this._targetPath=H[H.length-1],this._activeTargets[Q]=X}else this._targetPath=H[0],this._activeTargets[Q]=f;if(void 0===this._activeTargets[Q][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${H.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let f=0;for(const Q of this._target)void 0!==this._originalValue[f]&&this._setValue(Q,this._activeTargets[f],this._originalValue[f],-1,f),f++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let f=0;f<this._events.length;f++)this._events[f].isDone=!1}isStopped(){return this._stopped}dispose(){const f=this._animation.runtimeAnimations.indexOf(this);f>-1&&this._animation.runtimeAnimations.splice(f,1)}setValue(f,Q){if(this._targetIsArray)for(let H=0;H<this._target.length;H++){const X=this._target[H];this._setValue(X,this._activeTargets[H],f,Q,H)}else this._setValue(this._target,this._directTarget,f,Q,0)}_getOriginalValues(){let f,Q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const H=this._activeTargets[Q];f=H.getLocalMatrix&&"_matrix"===this._targetPath?H.getLocalMatrix():H[this._targetPath],f&&f.clone?this._originalValue[Q]=f.clone():this._originalValue[Q]=f}_registerTargetForLateAnimationBinding(f,Q){const H=f.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(H),H._lateAnimationHolders||(H._lateAnimationHolders={}),H._lateAnimationHolders[f.targetPath]||(H._lateAnimationHolders[f.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:Q}),f.isAdditive?(H._lateAnimationHolders[f.targetPath].additiveAnimations.push(f),H._lateAnimationHolders[f.targetPath].totalAdditiveWeight+=f.weight):(H._lateAnimationHolders[f.targetPath].animations.push(f),H._lateAnimationHolders[f.targetPath].totalWeight+=f.weight)}_setValue(f,Q,H,i,S){if(this._currentActiveTarget=Q,this._weight=i,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const f=Q[this._targetPath];f.clone?this._originalBlendValue=f.clone():this._originalBlendValue=f}this._originalBlendValue.m?X.d.AllowMatrixDecomposeForInterpolation?this._currentValue?Z.e.DecomposeLerpToRef(this._originalBlendValue,H,this._blendingFactor,this._currentValue):this._currentValue=Z.e.DecomposeLerp(this._originalBlendValue,H,this._blendingFactor):this._currentValue?Z.e.LerpToRef(this._originalBlendValue,H,this._blendingFactor,this._currentValue):this._currentValue=Z.e.Lerp(this._originalBlendValue,H,this._blendingFactor):this._currentValue=X.d._UniversalLerp(this._originalBlendValue,H,this._blendingFactor);const i=f&&f.animationPropertiesOverride?f.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=i}else this._currentValue?this._currentValue.p?this._currentValue.p(H):this._currentValue=H:null!==H&&void 0!==H&&H.clone?this._currentValue=H.clone():this._currentValue=H;-1!==i?this._registerTargetForLateAnimationBinding(this,this._originalValue[S]):this._animationState.loopMode===X.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[S],Q[this._targetPath]):Q[this._targetPath]=this._originalValue[S]+this._currentValue:Q[this._targetPath]=this._currentValue,f.ve&&f.ve(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(f){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const H=this._animation.getKeys();f<H[0].frame?f=H[0].frame:f>H[H.length-1].frame&&(f=H[H.length-1].frame);const X=this._events;if(X.length)for(let S=0;S<X.length;S++)X[S].onlyOnce||(X[S].isDone=X[S].frame<f);this._currentFrame=f;const i=this._animation._interpolate(f,this._animationState);this.setValue(i,Q)}_prepareForSpeedRatioChange(f){const Q=this._previousElapsedTime*(this._animation.framePerSecond*f)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-Q}animate(f,Q,H,i,S){let x=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const K=this._animation,Z=K.targetPropertyPath;if(!Z||Z.length<1)return this._stopped=!0,!1;let B=!0;(Q<this._minFrame||Q>this._maxFrame)&&(Q=this._minFrame),(H<this._minFrame||H>this._maxFrame)&&(H=this._maxFrame);const N=H-Q;let J,g=f*(K.framePerSecond*S)/1e3+this._absoluteFrameOffset,z=0,v=!1;const Y=i&&this._animationState.loopMode===X.d.ANIMATIONLOOPMODE_YOYO;if(Y){const f=(g-Q)/N,H=Math.sin(f*Math.PI);g=Math.abs(H)*N+Q;const X=H>=0?1:-1;this._yoyoDirection!==X&&(v=!0),this._yoyoDirection=X}if(this._previousElapsedTime=f,this._previousAbsoluteFrame=g,!i&&H>=Q&&(g>=N&&S>0||g<=0&&S<0))B=!1,z=K._getKeyValue(this._maxValue);else if(!i&&Q>=H&&(g<=N&&S<0||g>=0&&S>0))B=!1,z=K._getKeyValue(this._minValue);else if(this._animationState.loopMode!==X.d.ANIMATIONLOOPMODE_CYCLE){const f=H.toString()+Q.toString();if(!this._offsetsCache[f]){this._animationState.repeatCount=0,this._animationState.loopMode=X.d.ANIMATIONLOOPMODE_CYCLE;const i=K._interpolate(Q,this._animationState),S=K._interpolate(H,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),K.dataType){case X.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[f]=S-i;break;case X.d.ANIMATIONTYPE_QUATERNION:case X.d.ANIMATIONTYPE_VECTOR3:case X.d.ANIMATIONTYPE_VECTOR2:case X.d.ANIMATIONTYPE_SIZE:case X.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[f]=S.hd(i)}this._highLimitsCache[f]=S}z=this._highLimitsCache[f],J=this._offsetsCache[f]}if(void 0===J)switch(K.dataType){case X.d.ANIMATIONTYPE_FLOAT:J=0;break;case X.d.ANIMATIONTYPE_QUATERNION:J=X.l;break;case X.d.ANIMATIONTYPE_VECTOR3:J=X.r;break;case X.d.ANIMATIONTYPE_VECTOR2:J=X.p;break;case X.d.ANIMATIONTYPE_SIZE:J=X.m;break;case X.d.ANIMATIONTYPE_COLOR3:J=X.f;break;case X.d.ANIMATIONTYPE_COLOR4:J=X.h}let O;if(this._host&&this._host.syncRoot){const f=this._host.syncRoot;O=Q+N*((f.masterFrame-f.fromFrame)/(f.toFrame-f.fromFrame))}else O=g>0&&Q>H||g<0&&Q<H?B&&0!==N?H+g%N:Q:B&&0!==N?Q+g%N:H;const n=this._events;if(!Y&&(S>0&&this.currentFrame>O||S<0&&this.currentFrame<O)||Y&&v){this._onLoop();for(let f=0;f<n.length;f++)n[f].onlyOnce||(n[f].isDone=!1);this._animationState.key=S>0?0:K.getKeys().length-1}this._currentFrame=O,this._animationState.repeatCount=0===N?0:g/N|0,this._animationState.highLimitValue=z,this._animationState.offsetValue=J;const e=K._interpolate(O,this._animationState);if(this.setValue(e,x),n.length)for(let X=0;X<n.length;X++)if(N>=0&&O>=n[X].frame&&n[X].frame>=Q||N<0&&O<=n[X].frame&&n[X].frame<=Q){const f=n[X];f.isDone||(f.onlyOnce&&(n.splice(X,1),X--),f.isDone=!0,f.action(O))}return B||(this._stopped=!0),B}}var N=H(1126);class J{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(f){this._weight=-1!==f?Math.min(Math.max(f,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(f){for(let Q=0;Q<this._runtimeAnimations.length;Q++){this._runtimeAnimations[Q]._prepareForSpeedRatioChange(f)}this._speedRatio=f,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(f,Q){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,S=arguments.length>4&&void 0!==arguments[4]&&arguments[4],x=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,K=arguments.length>6?arguments[6]:void 0,Z=arguments.length>7?arguments[7]:void 0,B=arguments.length>8?arguments[8]:void 0,N=arguments.length>9&&void 0!==arguments[9]&&arguments[9],J=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=Q,this.fromFrame=H,this.toFrame=X,this.loopAnimation=S,this.onAnimationEnd=K,this.onAnimationLoop=B,this.isAdditive=N,this.playOrder=J,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Od=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new i.e,this.onAnimationLoopObservable=new i.e,this._scene=f,Z&&this.appendAnimations(Q,Z),this._speedRatio=x,f._activeAnimatables.push(this)}syncWith(f){if(this._syncRoot=f,f){const f=this._scene._activeAnimatables.indexOf(this);f>-1&&(this._scene._activeAnimatables.splice(f,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(f,Q){for(let H=0;H<Q.length;H++){const X=Q[H],i=new B(f,X,this._scene,this);i._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(i)}}getAnimationByTargetProperty(f){const Q=this._runtimeAnimations;for(let H=0;H<Q.length;H++)if(Q[H].animation.targetProperty===f)return Q[H].animation;return null}getRuntimeAnimationByTargetProperty(f){const Q=this._runtimeAnimations;for(let H=0;H<Q.length;H++)if(Q[H].animation.targetProperty===f)return Q[H];return null}reset(){const f=this._runtimeAnimations;for(let Q=0;Q<f.length;Q++)f[Q].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(f){const Q=this._runtimeAnimations;for(let H=0;H<Q.length;H++)Q[H].animation.enableBlending=!0,Q[H].animation.blendingSpeed=f}disableBlending(){const f=this._runtimeAnimations;for(let Q=0;Q<f.length;Q++)f[Q].animation.enableBlending=!1}goToFrame(f){const Q=this._runtimeAnimations;if(Q[0]){const H=Q[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??Q[0].currentFrame;const X=0===this.speedRatio?0:(f-this._frameToSyncFromJump)/H*1e3/this.speedRatio;this._manualJumpDelay=-X}for(let H=0;H<Q.length;H++)Q[H].goToFrame(f,this._weight);this._goToFrame=f}get paused(){return this.Od}pause(){this.Od||(this.Od=!0)}restart(){this.Od=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(f,Q){let H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],X=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(f||Q){const i=this._scene._activeAnimatables.indexOf(this);if(i>-1){const S=this._runtimeAnimations;for(let H=S.length-1;H>=0;H--){const X=S[H];f&&X.animation.name!=f||(Q&&!Q(X.target)||(X.dispose(),S.splice(H,1)))}0==S.length&&(H||this._scene._activeAnimatables.splice(i,1),X||this._raiseOnAnimationEnd())}}else{const f=this._scene._activeAnimatables.indexOf(this);if(f>-1){H||this._scene._activeAnimatables.splice(f,1);const Q=this._runtimeAnimations;for(let f=0;f<Q.length;f++)Q[f].dispose();this._runtimeAnimations.length=0,X||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((f=>{this.onAnimationEndObservable.add((()=>{f(this)}),void 0,void 0,this,!0)}))}_animate(f){if(this.Od)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=f),!0;if(null===this._localDelayOffset?(this._localDelayOffset=f,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=f-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let Q=!1;const H=this._runtimeAnimations;let X;for(X=0;X<H.length;X++){const i=H[X].animate(f-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);Q=Q||i}if(this.animationStarted=Q,!Q){if(this.disposeOnEnd)for(X=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(X,1),X=0;X<H.length;X++)H[X].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return Q}}function g(f){if(0===f.totalWeight&&0===f.totalAdditiveWeight)return f.originalValue;let Q=1;const H=Z.l.Wd[0],X=Z.l.Wd[1],i=Z.l.Quaternion[0];let S=0;const x=f.animations[0],K=f.originalValue;let B=1,N=!1;if(f.totalWeight<1)B=1-f.totalWeight,K.decompose(X,i,H);else{if(S=1,Q=f.totalWeight,B=x.weight/Q,1==B){if(!f.totalAdditiveWeight)return x.currentValue;N=!0}x.currentValue.decompose(X,i,H)}if(!N){X.scaleInPlace(B),H.scaleInPlace(B),i.scaleInPlace(B);for(let x=S;x<f.animations.length;x++){const S=f.animations[x];if(0===S.weight)continue;B=S.weight/Q;const K=Z.l.Wd[2],N=Z.l.Wd[3],J=Z.l.Quaternion[1];S.currentValue.decompose(N,J,K),N.scaleAndAddToRef(B,X),J.scaleAndAddToRef(Z.i.Dot(i,J)>0?B:-B,i),K.scaleAndAddToRef(B,H)}i.normalize()}for(let g=0;g<f.additiveAnimations.length;g++){const Q=f.additiveAnimations[g];if(0===Q.weight)continue;const S=Z.l.Wd[2],x=Z.l.Wd[3],K=Z.l.Quaternion[1];Q.currentValue.decompose(x,K,S),x.multiplyToRef(X,x),Z.p.LerpToRef(X,x,Q.weight,X),i.multiplyToRef(K,K),Z.i.SlerpToRef(i,K,Q.weight,i),S.scaleAndAddToRef(Q.weight,H)}const J=x?x._animationState.workValue:Z.l.Matrix[0].clone();return Z.e.ComposeToRef(X,i,H,J),J}function z(f,Q){if(0===f.totalWeight&&0===f.totalAdditiveWeight)return Q;const H=f.animations[0],X=f.originalValue;let i=Q;if(0===f.totalWeight&&f.totalAdditiveWeight>0)i.p(X);else if(1===f.animations.length){if(Z.i.SlerpToRef(X,H.currentValue,Math.min(1,f.totalWeight),i),0===f.totalAdditiveWeight)return i}else if(f.animations.length>1){let H,S,x=1;if(f.totalWeight<1){const Q=1-f.totalWeight;H=[],S=[],H.push(X),S.push(Q)}else{if(2===f.animations.length&&(Z.i.SlerpToRef(f.animations[0].currentValue,f.animations[1].currentValue,f.animations[1].weight/f.totalWeight,Q),0===f.totalAdditiveWeight))return Q;H=[],S=[],x=f.totalWeight}for(let Q=0;Q<f.animations.length;Q++){const X=f.animations[Q];H.push(X.currentValue),S.push(X.weight/x)}let K=0;for(let f=0;f<H.length;)f?(K+=S[f],Z.i.SlerpToRef(i,H[f],S[f]/K,i),f++):(Z.i.SlerpToRef(H[f],H[f+1],S[f+1]/(S[f]+S[f+1]),Q),i=Q,K=S[f]+S[f+1],f+=2)}for(let S=0;S<f.additiveAnimations.length;S++){const Q=f.additiveAnimations[S];0!==Q.weight&&(i.multiplyToRef(Q.currentValue,Z.l.Quaternion[0]),Z.i.SlerpToRef(i,Z.l.Quaternion[0],Q.weight,i))}return i}var v,Y,O=H(1196);v=O.e,(Y=K.e)&&(Y.prototype.copyAnimationRange=function(f,Q,H){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3],S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new X.d(this.name,"_matrix",f.animations[0].framePerSecond,X.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const x=f.animations[0].getRange(Q);if(!x)return!1;const K=x.from,Z=x.to,B=f.animations[0].getKeys(),N=f.length,J=f.getParent(),g=this.getParent(),z=i&&J&&N&&this.length&&N!==this.length,v=z&&g&&J?g.length/J.length:1,Y=i&&!g&&S&&(1!==S.x||1!==S.y||1!==S.z),O=this.animations[0].getKeys();let n,e,G;for(let X=0,I=B.length;X<I;X++)n=B[X],n.frame>=K&&n.frame<=Z&&(i?(G=n.value.clone(),z?(e=G.getTranslation(),G.setTranslation(e.scaleInPlace(v))):Y&&S?(e=G.getTranslation(),G.setTranslation(e.multiplyInPlace(S))):G=n.value):G=n.value,O.push({frame:n.frame+H,value:G}));return this.animations[0].createRange(Q,K+H,Z+H),!0}),v&&(v.prototype._animate=function(f){if(!this.animationsEnabled)return;const Q=N.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=Q}this.deltaTime=void 0!==f?f:this.useConstantAnimationDeltaTime?16:(Q-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=Q;const H=this._activeAnimatables;if(0===H.length)return;this._animationTime+=this.deltaTime;const i=this._animationTime;for(let X=0;X<H.length;X++){const f=H[X];!f._animate(i)&&f.disposeOnEnd&&X--}!function(f){if(f._registeredForLateAnimationBindings.length){for(let Q=0;Q<f._registeredForLateAnimationBindings.length;Q++){const H=f._registeredForLateAnimationBindings.data[Q];for(const f in H._lateAnimationHolders){const Q=H._lateAnimationHolders[f],i=Q.animations[0],S=Q.originalValue;if(void 0===S||null===S)continue;const x=X.d.AllowMatrixDecomposeForInterpolation&&S.m;let K=H[f];if(x)K=g(Q);else if(void 0!==S.w)K=z(Q,K||Z.i.Identity());else{let f=0,H=1;const x=i&&i._animationState.loopMode===X.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(Q.totalWeight<1)K=x?S.clone?S.clone():S:i&&S.scale?S.scale(1-Q.totalWeight):i?S*(1-Q.totalWeight):S.clone?S.clone():S;else if(i){H=Q.totalWeight;const X=i.weight/H;K=1!==X?i.currentValue.scale?i.currentValue.scale(X):i.currentValue*X:i.currentValue,x&&(K.addToRef?K.addToRef(S,K):K+=S),f=1}for(let X=f;X<Q.animations.length;X++){const f=Q.animations[X],i=f.weight/H;i&&(f.currentValue.scaleAndAddToRef?f.currentValue.scaleAndAddToRef(i,K):K+=f.currentValue*i)}for(let X=0;X<Q.additiveAnimations.length;X++){const f=Q.additiveAnimations[X],H=f.weight;H&&(f.currentValue.scaleAndAddToRef?f.currentValue.scaleAndAddToRef(H,K):K+=f.currentValue*H)}}H[f]=K}H._lateAnimationHolders={}}f._registeredForLateAnimationBindings.reset()}}(this)},v.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((f,Q)=>f.playOrder-Q.playOrder))},v.prototype.beginWeightedAnimation=function(f,Q,H){let X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,i=arguments.length>4?arguments[4]:void 0,S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,x=arguments.length>6?arguments[6]:void 0,K=arguments.length>7?arguments[7]:void 0,Z=arguments.length>8?arguments[8]:void 0,B=arguments.length>9?arguments[9]:void 0,N=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const J=this.beginAnimation(f,Q,H,i,S,x,K,!1,Z,B,N);return J.weight=X,J},v.prototype.beginAnimation=function(f,Q,H,X){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,S=arguments.length>5?arguments[5]:void 0,x=arguments.length>6?arguments[6]:void 0,K=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],Z=arguments.length>8?arguments[8]:void 0,B=arguments.length>9?arguments[9]:void 0,N=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(i<0){const f=Q;Q=H,H=f,i=-i}Q>H&&(i=-i),K&&this.stopAnimation(f,void 0,Z),x||(x=new J(this,f,Q,H,X,i,S,void 0,B,N));const g=!Z||Z(f);if(f.animations&&g&&x.appendAnimations(f,f.animations),f.getAnimatables){const N=f.getAnimatables();for(let f=0;f<N.length;f++)this.beginAnimation(N[f],Q,H,X,i,S,x,K,Z,B)}return x.reset(),x},v.prototype.beginHierarchyAnimation=function(f,Q,H,X,i){let S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,x=arguments.length>6?arguments[6]:void 0,K=arguments.length>7?arguments[7]:void 0,Z=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],B=arguments.length>9?arguments[9]:void 0,N=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const J=f.getDescendants(Q),g=[];g.push(this.beginAnimation(f,H,X,i,S,x,K,Z,B,void 0,N));for(const z of J)g.push(this.beginAnimation(z,H,X,i,S,x,K,Z,B,void 0,N));return g},v.prototype.beginDirectAnimation=function(f,Q,H,X,i){let S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(S<0){const f=H;H=X,X=f,S=-S}return H>X&&(S=-S),new J(this,f,H,X,i,S,arguments.length>6?arguments[6]:void 0,Q,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},v.prototype.beginDirectHierarchyAnimation=function(f,Q,H,X,i,S,x,K,Z){let B=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const N=f.getDescendants(Q),J=[];J.push(this.beginDirectAnimation(f,H,X,i,S,x,K,Z,B));for(const g of N)J.push(this.beginDirectAnimation(g,H,X,i,S,x,K,Z,B));return J},v.prototype.getAnimatableByTarget=function(f){for(let Q=0;Q<this._activeAnimatables.length;Q++)if(this._activeAnimatables[Q].target===f)return this._activeAnimatables[Q];return null},v.prototype.getAllAnimatablesByTarget=function(f){const Q=[];for(let H=0;H<this._activeAnimatables.length;H++)this._activeAnimatables[H].target===f&&Q.push(this._activeAnimatables[H]);return Q},v.prototype.stopAnimation=function(f,Q,H){const X=this.getAllAnimatablesByTarget(f);for(const i of X)i.stop(Q,H)},v.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let f=0;f<this._activeAnimatables.length;f++)this._activeAnimatables[f].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const f of this.animationGroups)f.stop()});class n{getClassName(){return"TargetedAnimation"}serialize(){const f={};return f.animation=this.animation.serialize(),f.targetId=this.target.id,f}}class e{get mask(){return this._mask}set mask(f){this._mask!==f&&(this._mask=f,this.syncWithMask(!0))}syncWithMask(){let f=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||f){this._numActiveAnimatables=0;for(let f=0;f<this._animatables.length;++f){const Q=this._animatables[f];!this.mask||this.mask.disabled||this.mask.retainsTarget(Q.target.name)?(this._numActiveAnimatables++,Q.paused&&Q.restart()):Q.paused||Q.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let f=0;f<this._animatables.length;++f){const Q=this._animatables[f];this.mask.retainsTarget(Q.target.name)||(Q.stop(),this._animatables.splice(f,1),--f)}for(let f=0;f<this._targetedAnimations.length;f++){const Q=this._targetedAnimations[f];this.mask.retainsTarget(Q.target.name)||(this._targetedAnimations.splice(f,1),--f)}}}get from(){return this._from}set from(f){if(this._from!==f){this._from=f;for(let f=0;f<this._animatables.length;f++){this._animatables[f].fromFrame=this._from}}}get to(){return this._to}set to(f){if(this._to!==f){this._to=f;for(let f=0;f<this._animatables.length;f++){this._animatables[f].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(f){if(this._speedRatio!==f){this._speedRatio=f;for(let f=0;f<this._animatables.length;f++){this._animatables[f].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(f){if(this._loopAnimation!==f){this._loopAnimation=f;for(let f=0;f<this._animatables.length;f++){this._animatables[f].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(f){if(this._isAdditive!==f){this._isAdditive=f;for(let f=0;f<this._animatables.length;f++){this._animatables[f].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(f){this._weight!==f&&(this._weight=f,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(f){if(this._playOrder!==f&&(this._playOrder=f,this._animatables.length>0)){for(let f=0;f<this._animatables.length;f++)this._animatables[f].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(f){if(this._enableBlending!==f&&(this._enableBlending=f,null!==f))for(let Q=0;Q<this._targetedAnimations.length;++Q)this._targetedAnimations[Q].animation.enableBlending=f}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(f){if(this._blendingSpeed!==f&&(this._blendingSpeed=f,null!==f))for(let Q=0;Q<this._targetedAnimations.length;++Q)this._targetedAnimations[Q].animation.blendingSpeed=f}getLength(f,Q){f=f??this._from;return((Q=Q??this._to)-f)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(f){let Q=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],X=arguments.length>3?arguments[3]:void 0;if(0===f.length)return null;X=X??f[0].weight;let i=Number.MAX_VALUE,S=-Number.MAX_VALUE;if(H)for(const K of f)K.from<i&&(i=K.from),K.to>S&&(S=K.to);const x=new e(f[0].name+"_merged",f[0]._scene,X);for(const K of f){H&&K.normalize(i,S);for(const f of K.targetedAnimations)x.addTargetedAnimation(f.animation,f.target);Q&&K.dispose()}return x}constructor(f){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=f,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new i.e,this.onAnimationLoopObservable=new i.e,this.onAnimationGroupLoopObservable=new i.e,this.onAnimationGroupEndObservable=new i.e,this.onAnimationGroupPauseObservable=new i.e,this.onAnimationGroupPlayObservable=new i.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=Q||S.e.LastCreatedScene,this._weight=H,this._playOrder=X,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(f,Q){const H=new n;H.animation=f,H.target=Q;const X=f.getKeys();return this._from>X[0].frame&&(this._from=X[0].frame),this._to<X[X.length-1].frame&&(this._to=X[X.length-1].frame),null!==this._enableBlending&&(f.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(f.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(H),this._shouldStart=!0,H}removeTargetedAnimation(f){for(let Q=this._targetedAnimations.length-1;Q>-1;Q--){this._targetedAnimations[Q].animation===f&&this._targetedAnimations.splice(Q,1)}}normalize(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==f&&(f=this._from),null==Q&&(Q=this._to);for(let H=0;H<this._targetedAnimations.length;H++){const X=this._targetedAnimations[H].animation.getKeys(),i=X[0],S=X[X.length-1];if(i.frame>f){const Q={frame:f,value:i.value,inTangent:i.inTangent,outTangent:i.outTangent,interpolation:i.interpolation};X.splice(0,0,Q)}if(S.frame<Q){const f={frame:Q,value:S.value,inTangent:S.inTangent,outTangent:S.outTangent,interpolation:S.interpolation};X.push(f)}}return this._from=f,this._to=Q,this}_processLoop(f,Q,H){f.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(Q),this._animationLoopFlags[H]||(this._animationLoopFlags[H]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let f=arguments.length>0&&void 0!==arguments[0]&&arguments[0],Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0,X=arguments.length>3?arguments[3]:void 0,i=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=f,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let S=0;S<this._targetedAnimations.length;S++){const x=this._targetedAnimations[S],K=this._scene.beginDirectAnimation(x.target,[x.animation],void 0!==H?H:this._from,void 0!==X?X:this._to,f,Q,void 0,void 0,void 0!==i?i:this._isAdditive);K.weight=this._weight,K.playOrder=this._playOrder,K.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(x),this._checkAnimationGroupEnded(K)},this._processLoop(K,x,S),this._animatables.push(K)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=Q,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let f=0;f<this._animatables.length;f++){this._animatables[f].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(f){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==f&&(this.loopAnimation=f),this.restart()):(this.stop(),this.start(f,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let f=0;f<this._animatables.length;f++){this._animatables[f].reset()}return this}restart(){if(!this._isStarted)return this;for(let f=0;f<this._animatables.length;f++){this._animatables[f].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let f=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const Q=this._animatables.slice();for(let X=0;X<Q.length;X++)Q[X].stop(void 0,void 0,!0,f);let H=0;for(let X=0;X<this._scene._activeAnimatables.length;X++){const Q=this._scene._activeAnimatables[X];Q._runtimeAnimations.length>0?this._scene._activeAnimatables[H++]=Q:f&&this._checkAnimationGroupEnded(Q,f)}return this._scene._activeAnimatables.length=H,this._isStarted=!1,this}setWeightForAllAnimatables(f){for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].weight=f}return this}syncAllAnimationsWith(f){for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].syncWith(f)}return this}goToFrame(f){if(!this._isStarted)return this;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].goToFrame(f)}return this}getCurrentFrame(){var f;return(null===(f=this.animatables[0])||void 0===f?void 0:f.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const f=this._scene.animationGroups.indexOf(this);if(f>-1&&this._scene.animationGroups.splice(f,1),this._parentContainer){const f=this._parentContainer.animationGroups.indexOf(this);f>-1&&this._parentContainer.animationGroups.splice(f,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(f){let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const H=this._animatables.indexOf(f);H>-1&&this._animatables.splice(H,1),0===this._animatables.length&&(this._isStarted=!1,Q||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(f,Q){let H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const X=new e(f||this.name,this._scene,this._weight,this._playOrder);X._from=this.from,X._to=this.to,X._speedRatio=this.speedRatio,X._loopAnimation=this.loopAnimation,X._isAdditive=this.isAdditive,X._enableBlending=this.enableBlending,X._blendingSpeed=this.blendingSpeed,X.metadata=this.metadata,X.mask=this.mask;for(const i of this._targetedAnimations)X.addTargetedAnimation(H?i.animation.clone():i.animation,Q?Q(i.target):i.target);return X}serialize(){const f={};f.name=this.name,f.from=this.from,f.to=this.to,f.speedRatio=this.speedRatio,f.loopAnimation=this.loopAnimation,f.isAdditive=this.isAdditive,f.weight=this.weight,f.playOrder=this.playOrder,f.enableBlending=this.enableBlending,f.blendingSpeed=this.blendingSpeed,f.targetedAnimations=[];for(let Q=0;Q<this.targetedAnimations.length;Q++){const H=this.targetedAnimations[Q];f.targetedAnimations[Q]=H.serialize()}return x.b&&x.b.HasTags(this)&&(f.tags=x.b.GetTags(this)),this.metadata&&(f.metadata=this.metadata),f}static Parse(f,Q){const H=new e(f.name,Q,f.weight,f.playOrder);for(let i=0;i<f.targetedAnimations.length;i++){const S=f.targetedAnimations[i],x=X.d.Parse(S.animation),K=S.targetId;if("influence"===S.animation.property){const f=Q.getMorphTargetById(K);f&&H.addTargetedAnimation(x,f)}else{const f=Q.getNodeById(K);null!=f&&H.addTargetedAnimation(x,f)}}return x.b&&x.b.AddTagsTo(H,f.tags),null!==f.from&&null!==f.to&&H.normalize(f.from,f.to),void 0!==f.speedRatio&&(H._speedRatio=f.speedRatio),void 0!==f.loopAnimation&&(H._loopAnimation=f.loopAnimation),void 0!==f.isAdditive&&(H._isAdditive=f.isAdditive),void 0!==f.weight&&(H._weight=f.weight),void 0!==f.playOrder&&(H._playOrder=f.playOrder),void 0!==f.enableBlending&&(H._enableBlending=f.enableBlending),void 0!==f.blendingSpeed&&(H._blendingSpeed=f.blendingSpeed),void 0!==f.metadata&&(H.metadata=f.metadata),H}static MakeAnimationAdditive(f,Q,H){let i;i="object"===typeof Q?Q:{referenceFrame:Q,range:H,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let S=f;i.cloneOriginalAnimationGroup&&(S=f.clone(i.clonedAnimationGroupName||S.name));const x=S.targetedAnimations;for(let K=0;K<x.length;K++){const f=x[K];f.animation=X.d.MakeAnimationAdditive(f.animation,i)}if(S.isAdditive=!0,i.clipKeys){let f=Number.MAX_VALUE,Q=-Number.MAX_VALUE;const H=S.targetedAnimations;for(let X=0;X<H.length;X++){const i=H[X].animation.getKeys();f>i[0].frame&&(f=i[0].frame),Q<i[i.length-1].frame&&(Q=i[i.length-1].frame)}S._from=f,S._to=Q}return S}static ClipKeys(f,Q,H,X,i){const S=f.clone(X||f.name);return e.ClipKeysInPlace(S,Q,H,i)}static ClipKeysInPlace(f,Q,H,X){return e.ClipInPlace(f,Q,H,X,!1)}static ClipFrames(f,Q,H,X,i){const S=f.clone(X||f.name);return e.ClipFramesInPlace(S,Q,H,i)}static ClipFramesInPlace(f,Q,H,X){return e.ClipInPlace(f,Q,H,X,!0)}static ClipInPlace(f,Q,H,X){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4],S=Number.MAX_VALUE,x=-Number.MAX_VALUE;const K=f.targetedAnimations;for(let Z=0;Z<K.length;Z++){const f=K[Z],B=X?f.animation:f.animation.clone();i&&(B.createKeyForFrame(Q),B.createKeyForFrame(H));const N=B.getKeys(),J=[];let g=Number.MAX_VALUE;for(let X=0;X<N.length;X++){const f=N[X];if(!i&&X>=Q&&X<=H||i&&f.frame>=Q&&f.frame<=H){const Q={frame:f.frame,value:f.value.clone?f.value.clone():f.value,inTangent:f.inTangent,outTangent:f.outTangent,interpolation:f.interpolation,lockedTangent:f.lockedTangent};g===Number.MAX_VALUE&&(g=Q.frame),Q.frame-=g,J.push(Q)}}0!==J.length?(S>J[0].frame&&(S=J[0].frame),x<J[J.length-1].frame&&(x=J[J.length-1].frame),B.setKeys(J,!0),f.animation=B):(K.splice(Z,1),Z--)}return f._from=S,f._to=x,f}getClassName(){return"AnimationGroup"}toString(f){let Q="Name: "+this.name;return Q+=", type: "+this.getClassName(),f&&(Q+=", from: "+this._from,Q+=", to: "+this._to,Q+=", isStarted: "+this._isStarted,Q+=", speedRatio: "+this._speedRatio,Q+=", targetedAnimations length: "+this._targetedAnimations.length,Q+=", animatables length: "+this._animatables),Q}}}}]);