"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12437:(I,k,i)=>{i.r(k),i.d(k,{AnimationGroup:()=>B,TargetedAnimation:()=>n});var d=i(11755),u=i(981),H=i(1018),Y=i(1148),x=i(11749),j=i(983);class l{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(I,k,i,u){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=k,this._target=I,this._scene=i,this._host=u,this._activeTargets=[],k._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===d.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=j.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const I={frame:0,value:this._minValue};this._keys.splice(0,0,I)}if(this._target instanceof Array){let I=0;for(const k of this._target)this._preparePath(k,I),this._getOriginalValues(I),I++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const H=k.getEvents();H&&H.length>0&&H.forEach((I=>{this._events.push(I._clone())})),this._enableBlending=I&&I.animationPropertiesOverride?I.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(I){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const i=this._animation.targetPropertyPath;if(i.length>1){let d=I;for(let I=0;I<i.length-1;I++){const k=i[I];if(d=d[k],void 0===d)throw new Error(`Invalid property (${k}) in property path (${i.join(".")})`)}this._targetPath=i[i.length-1],this._activeTargets[k]=d}else this._targetPath=i[0],this._activeTargets[k]=I;if(void 0===this._activeTargets[k][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${i.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let I=0;for(const k of this._target)void 0!==this._originalValue[I]&&this._setValue(k,this._activeTargets[I],this._originalValue[I],-1,I),I++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let I=0;I<this._events.length;I++)this._events[I].isDone=!1}isStopped(){return this._stopped}dispose(){const I=this._animation.runtimeAnimations.indexOf(this);I>-1&&this._animation.runtimeAnimations.splice(I,1)}setValue(I,k){if(this._targetIsArray)for(let i=0;i<this._target.length;i++){const d=this._target[i];this._setValue(d,this._activeTargets[i],I,k,i)}else this._setValue(this._target,this._directTarget,I,k,0)}_getOriginalValues(){let I,k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const i=this._activeTargets[k];I=i.getLocalMatrix&&"_matrix"===this._targetPath?i.getLocalMatrix():i[this._targetPath],I&&I.clone?this._originalValue[k]=I.clone():this._originalValue[k]=I}_registerTargetForLateAnimationBinding(I,k){const i=I.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(i),i._lateAnimationHolders||(i._lateAnimationHolders={}),i._lateAnimationHolders[I.targetPath]||(i._lateAnimationHolders[I.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:k}),I.isAdditive?(i._lateAnimationHolders[I.targetPath].additiveAnimations.push(I),i._lateAnimationHolders[I.targetPath].totalAdditiveWeight+=I.weight):(i._lateAnimationHolders[I.targetPath].animations.push(I),i._lateAnimationHolders[I.targetPath].totalWeight+=I.weight)}_setValue(I,k,i,u,H){if(this._currentActiveTarget=k,this._weight=u,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const I=k[this._targetPath];I.clone?this._originalBlendValue=I.clone():this._originalBlendValue=I}this._originalBlendValue.m?d.b.AllowMatrixDecomposeForInterpolation?this._currentValue?j.c.DecomposeLerpToRef(this._originalBlendValue,i,this._blendingFactor,this._currentValue):this._currentValue=j.c.DecomposeLerp(this._originalBlendValue,i,this._blendingFactor):this._currentValue?j.c.LerpToRef(this._originalBlendValue,i,this._blendingFactor,this._currentValue):this._currentValue=j.c.Lerp(this._originalBlendValue,i,this._blendingFactor):this._currentValue=d.b._UniversalLerp(this._originalBlendValue,i,this._blendingFactor);const u=I&&I.animationPropertiesOverride?I.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=u}else this._currentValue?this._currentValue.p?this._currentValue.p(i):this._currentValue=i:null!==i&&void 0!==i&&i.clone?this._currentValue=i.clone():this._currentValue=i;-1!==u?this._registerTargetForLateAnimationBinding(this,this._originalValue[H]):this._animationState.loopMode===d.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[H],k[this._targetPath]):k[this._targetPath]=this._originalValue[H]+this._currentValue:k[this._targetPath]=this._currentValue,I.de&&I.de(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(I){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const i=this._animation.getKeys();I<i[0].frame?I=i[0].frame:I>i[i.length-1].frame&&(I=i[i.length-1].frame);const d=this._events;if(d.length)for(let H=0;H<d.length;H++)d[H].onlyOnce||(d[H].isDone=d[H].frame<I);this._currentFrame=I;const u=this._animation._interpolate(I,this._animationState);this.setValue(u,k)}_prepareForSpeedRatioChange(I){const k=this._previousElapsedTime*(this._animation.framePerSecond*I)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-k}animate(I,k,i,u,H){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const x=this._animation,j=x.targetPropertyPath;if(!j||j.length<1)return this._stopped=!0,!1;let l=!0;(k<this._minFrame||k>this._maxFrame)&&(k=this._minFrame),(i<this._minFrame||i>this._maxFrame)&&(i=this._maxFrame);const g=i-k;let P,J=I*(x.framePerSecond*H)/1e3+this._absoluteFrameOffset,L=0,s=!1;const h=u&&this._animationState.loopMode===d.b.ANIMATIONLOOPMODE_YOYO;if(h){const I=(J-k)/g,i=Math.sin(I*Math.PI);J=Math.abs(i)*g+k;const d=i>=0?1:-1;this._yoyoDirection!==d&&(s=!0),this._yoyoDirection=d}if(this._previousElapsedTime=I,this._previousAbsoluteFrame=J,!u&&i>=k&&(J>=g&&H>0||J<=0&&H<0))l=!1,L=x._getKeyValue(this._maxValue);else if(!u&&k>=i&&(J<=g&&H<0||J>=0&&H>0))l=!1,L=x._getKeyValue(this._minValue);else if(this._animationState.loopMode!==d.b.ANIMATIONLOOPMODE_CYCLE){const I=i.toString()+k.toString();if(!this._offsetsCache[I]){this._animationState.repeatCount=0,this._animationState.loopMode=d.b.ANIMATIONLOOPMODE_CYCLE;const u=x._interpolate(k,this._animationState),H=x._interpolate(i,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),x.dataType){case d.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[I]=H-u;break;case d.b.ANIMATIONTYPE_QUATERNION:case d.b.ANIMATIONTYPE_VECTOR3:case d.b.ANIMATIONTYPE_VECTOR2:case d.b.ANIMATIONTYPE_SIZE:case d.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[I]=H.tc(u)}this._highLimitsCache[I]=H}L=this._highLimitsCache[I],P=this._offsetsCache[I]}if(void 0===P)switch(x.dataType){case d.b.ANIMATIONTYPE_FLOAT:P=0;break;case d.b.ANIMATIONTYPE_QUATERNION:P=d.l;break;case d.b.ANIMATIONTYPE_VECTOR3:P=d.u;break;case d.b.ANIMATIONTYPE_VECTOR2:P=d.s;break;case d.b.ANIMATIONTYPE_SIZE:P=d.p;break;case d.b.ANIMATIONTYPE_COLOR3:P=d.f;break;case d.b.ANIMATIONTYPE_COLOR4:P=d.h}let Z;if(this._host&&this._host.syncRoot){const I=this._host.syncRoot;Z=k+g*((I.masterFrame-I.fromFrame)/(I.toFrame-I.fromFrame))}else Z=J>0&&k>i||J<0&&k<i?l&&0!==g?i+J%g:k:l&&0!==g?k+J%g:i;const n=this._events;if(!h&&(H>0&&this.currentFrame>Z||H<0&&this.currentFrame<Z)||h&&s){this._onLoop();for(let I=0;I<n.length;I++)n[I].onlyOnce||(n[I].isDone=!1);this._animationState.key=H>0?0:x.getKeys().length-1}this._currentFrame=Z,this._animationState.repeatCount=0===g?0:J/g|0,this._animationState.highLimitValue=L,this._animationState.offsetValue=P;const B=x._interpolate(Z,this._animationState);if(this.setValue(B,Y),n.length)for(let d=0;d<n.length;d++)if(g>=0&&Z>=n[d].frame&&n[d].frame>=k||g<0&&Z<=n[d].frame&&n[d].frame<=k){const I=n[d];I.isDone||(I.onlyOnce&&(n.splice(d,1),d--),I.isDone=!0,I.action(Z))}return l||(this._stopped=!0),l}}var g=i(1116);class P{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(I){this._weight=-1!==I?Math.min(Math.max(I,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(I){for(let k=0;k<this._runtimeAnimations.length;k++){this._runtimeAnimations[k]._prepareForSpeedRatioChange(I)}this._speedRatio=I,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(I,k){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,H=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,x=arguments.length>6?arguments[6]:void 0,j=arguments.length>7?arguments[7]:void 0,l=arguments.length>8?arguments[8]:void 0,g=arguments.length>9&&void 0!==arguments[9]&&arguments[9],P=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=k,this.fromFrame=i,this.toFrame=d,this.loopAnimation=H,this.onAnimationEnd=x,this.onAnimationLoop=l,this.isAdditive=g,this.playOrder=P,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.if=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new u.e,this.onAnimationLoopObservable=new u.e,this._scene=I,j&&this.appendAnimations(k,j),this._speedRatio=Y,I._activeAnimatables.push(this)}syncWith(I){if(this._syncRoot=I,I){const I=this._scene._activeAnimatables.indexOf(this);I>-1&&(this._scene._activeAnimatables.splice(I,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(I,k){for(let i=0;i<k.length;i++){const d=k[i],u=new l(I,d,this._scene,this);u._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(u)}}getAnimationByTargetProperty(I){const k=this._runtimeAnimations;for(let i=0;i<k.length;i++)if(k[i].animation.targetProperty===I)return k[i].animation;return null}getRuntimeAnimationByTargetProperty(I){const k=this._runtimeAnimations;for(let i=0;i<k.length;i++)if(k[i].animation.targetProperty===I)return k[i];return null}reset(){const I=this._runtimeAnimations;for(let k=0;k<I.length;k++)I[k].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(I){const k=this._runtimeAnimations;for(let i=0;i<k.length;i++)k[i].animation.enableBlending=!0,k[i].animation.blendingSpeed=I}disableBlending(){const I=this._runtimeAnimations;for(let k=0;k<I.length;k++)I[k].animation.enableBlending=!1}goToFrame(I){const k=this._runtimeAnimations;if(k[0]){const i=k[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??k[0].currentFrame;const d=0===this.speedRatio?0:(I-this._frameToSyncFromJump)/i*1e3/this.speedRatio;this._manualJumpDelay=-d}for(let i=0;i<k.length;i++)k[i].goToFrame(I,this._weight);this._goToFrame=I}get paused(){return this.if}pause(){this.if||(this.if=!0)}restart(){this.if=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(I,k){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],d=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(I||k){const u=this._scene._activeAnimatables.indexOf(this);if(u>-1){const H=this._runtimeAnimations;for(let i=H.length-1;i>=0;i--){const d=H[i];I&&d.animation.name!=I||(k&&!k(d.target)||(d.dispose(),H.splice(i,1)))}0==H.length&&(i||this._scene._activeAnimatables.splice(u,1),d||this._raiseOnAnimationEnd())}}else{const I=this._scene._activeAnimatables.indexOf(this);if(I>-1){i||this._scene._activeAnimatables.splice(I,1);const k=this._runtimeAnimations;for(let I=0;I<k.length;I++)k[I].dispose();this._runtimeAnimations.length=0,d||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((I=>{this.onAnimationEndObservable.add((()=>{I(this)}),void 0,void 0,this,!0)}))}_animate(I){if(this.if)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=I),!0;if(null===this._localDelayOffset?(this._localDelayOffset=I,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=I-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let k=!1;const i=this._runtimeAnimations;let d;for(d=0;d<i.length;d++){const u=i[d].animate(I-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);k=k||u}if(this.animationStarted=k,!k){if(this.disposeOnEnd)for(d=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(d,1),d=0;d<i.length;d++)i[d].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return k}}function J(I){if(0===I.totalWeight&&0===I.totalAdditiveWeight)return I.originalValue;let k=1;const i=j.i.kd[0],d=j.i.kd[1],u=j.i.Quaternion[0];let H=0;const Y=I.animations[0],x=I.originalValue;let l=1,g=!1;if(I.totalWeight<1)l=1-I.totalWeight,x.decompose(d,u,i);else{if(H=1,k=I.totalWeight,l=Y.weight/k,1==l){if(!I.totalAdditiveWeight)return Y.currentValue;g=!0}Y.currentValue.decompose(d,u,i)}if(!g){d.scaleInPlace(l),i.scaleInPlace(l),u.scaleInPlace(l);for(let Y=H;Y<I.animations.length;Y++){const H=I.animations[Y];if(0===H.weight)continue;l=H.weight/k;const x=j.i.kd[2],g=j.i.kd[3],P=j.i.Quaternion[1];H.currentValue.decompose(g,P,x),g.scaleAndAddToRef(l,d),P.scaleAndAddToRef(j.g.Dot(u,P)>0?l:-l,u),x.scaleAndAddToRef(l,i)}u.normalize()}for(let J=0;J<I.additiveAnimations.length;J++){const k=I.additiveAnimations[J];if(0===k.weight)continue;const H=j.i.kd[2],Y=j.i.kd[3],x=j.i.Quaternion[1];k.currentValue.decompose(Y,x,H),Y.multiplyToRef(d,Y),j.m.LerpToRef(d,Y,k.weight,d),u.multiplyToRef(x,x),j.g.SlerpToRef(u,x,k.weight,u),H.scaleAndAddToRef(k.weight,i)}const P=Y?Y._animationState.workValue:j.i.Matrix[0].clone();return j.c.ComposeToRef(d,u,i,P),P}function L(I,k){if(0===I.totalWeight&&0===I.totalAdditiveWeight)return k;const i=I.animations[0],d=I.originalValue;let u=k;if(0===I.totalWeight&&I.totalAdditiveWeight>0)u.p(d);else if(1===I.animations.length){if(j.g.SlerpToRef(d,i.currentValue,Math.min(1,I.totalWeight),u),0===I.totalAdditiveWeight)return u}else if(I.animations.length>1){let i,H,Y=1;if(I.totalWeight<1){const k=1-I.totalWeight;i=[],H=[],i.push(d),H.push(k)}else{if(2===I.animations.length&&(j.g.SlerpToRef(I.animations[0].currentValue,I.animations[1].currentValue,I.animations[1].weight/I.totalWeight,k),0===I.totalAdditiveWeight))return k;i=[],H=[],Y=I.totalWeight}for(let k=0;k<I.animations.length;k++){const d=I.animations[k];i.push(d.currentValue),H.push(d.weight/Y)}let x=0;for(let I=0;I<i.length;)I?(x+=H[I],j.g.SlerpToRef(u,i[I],H[I]/x,u),I++):(j.g.SlerpToRef(i[I],i[I+1],H[I+1]/(H[I]+H[I+1]),k),u=k,x=H[I]+H[I+1],I+=2)}for(let H=0;H<I.additiveAnimations.length;H++){const k=I.additiveAnimations[H];0!==k.weight&&(u.multiplyToRef(k.currentValue,j.i.Quaternion[0]),j.g.SlerpToRef(u,j.i.Quaternion[0],k.weight,u))}return u}var s,h,Z=i(1175);s=Z.e,(h=x.c)&&(h.prototype.copyAnimationRange=function(I,k,i){let u=arguments.length>3&&void 0!==arguments[3]&&arguments[3],H=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new d.b(this.name,"_matrix",I.animations[0].framePerSecond,d.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Y=I.animations[0].getRange(k);if(!Y)return!1;const x=Y.from,j=Y.to,l=I.animations[0].getKeys(),g=I.length,P=I.getParent(),J=this.getParent(),L=u&&P&&g&&this.length&&g!==this.length,s=L&&J&&P?J.length/P.length:1,h=u&&!J&&H&&(1!==H.x||1!==H.y||1!==H.z),Z=this.animations[0].getKeys();let n,B,b;for(let d=0,o=l.length;d<o;d++)n=l[d],n.frame>=x&&n.frame<=j&&(u?(b=n.value.clone(),L?(B=b.getTranslation(),b.setTranslation(B.scaleInPlace(s))):h&&H?(B=b.getTranslation(),b.setTranslation(B.multiplyInPlace(H))):b=n.value):b=n.value,Z.push({frame:n.frame+i,value:b}));return this.animations[0].createRange(k,x+i,j+i),!0}),s&&(s.prototype._animate=function(I){if(!this.animationsEnabled)return;const k=g.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=k}this.deltaTime=void 0!==I?I:this.useConstantAnimationDeltaTime?16:(k-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=k;const i=this._activeAnimatables;if(0===i.length)return;this._animationTime+=this.deltaTime;const u=this._animationTime;for(let d=0;d<i.length;d++){const I=i[d];!I._animate(u)&&I.disposeOnEnd&&d--}!function(I){if(I._registeredForLateAnimationBindings.length){for(let k=0;k<I._registeredForLateAnimationBindings.length;k++){const i=I._registeredForLateAnimationBindings.data[k];for(const I in i._lateAnimationHolders){const k=i._lateAnimationHolders[I],u=k.animations[0],H=k.originalValue;if(void 0===H||null===H)continue;const Y=d.b.AllowMatrixDecomposeForInterpolation&&H.m;let x=i[I];if(Y)x=J(k);else if(void 0!==H.w)x=L(k,x||j.g.Identity());else{let I=0,i=1;const Y=u&&u._animationState.loopMode===d.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(k.totalWeight<1)x=Y?H.clone?H.clone():H:u&&H.scale?H.scale(1-k.totalWeight):u?H*(1-k.totalWeight):H.clone?H.clone():H;else if(u){i=k.totalWeight;const d=u.weight/i;x=1!==d?u.currentValue.scale?u.currentValue.scale(d):u.currentValue*d:u.currentValue,Y&&(x.addToRef?x.addToRef(H,x):x+=H),I=1}for(let d=I;d<k.animations.length;d++){const I=k.animations[d],u=I.weight/i;u&&(I.currentValue.scaleAndAddToRef?I.currentValue.scaleAndAddToRef(u,x):x+=I.currentValue*u)}for(let d=0;d<k.additiveAnimations.length;d++){const I=k.additiveAnimations[d],i=I.weight;i&&(I.currentValue.scaleAndAddToRef?I.currentValue.scaleAndAddToRef(i,x):x+=I.currentValue*i)}}i[I]=x}i._lateAnimationHolders={}}I._registeredForLateAnimationBindings.reset()}}(this)},s.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((I,k)=>I.playOrder-k.playOrder))},s.prototype.beginWeightedAnimation=function(I,k,i){let d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,u=arguments.length>4?arguments[4]:void 0,H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,x=arguments.length>7?arguments[7]:void 0,j=arguments.length>8?arguments[8]:void 0,l=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const P=this.beginAnimation(I,k,i,u,H,Y,x,!1,j,l,g);return P.weight=d,P},s.prototype.beginAnimation=function(I,k,i,d){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,H=arguments.length>5?arguments[5]:void 0,Y=arguments.length>6?arguments[6]:void 0,x=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],j=arguments.length>8?arguments[8]:void 0,l=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(u<0){const I=k;k=i,i=I,u=-u}k>i&&(u=-u),x&&this.stopAnimation(I,void 0,j),Y||(Y=new P(this,I,k,i,d,u,H,void 0,l,g));const J=!j||j(I);if(I.animations&&J&&Y.appendAnimations(I,I.animations),I.getAnimatables){const g=I.getAnimatables();for(let I=0;I<g.length;I++)this.beginAnimation(g[I],k,i,d,u,H,Y,x,j,l)}return Y.reset(),Y},s.prototype.beginHierarchyAnimation=function(I,k,i,d,u){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,x=arguments.length>7?arguments[7]:void 0,j=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],l=arguments.length>9?arguments[9]:void 0,g=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const P=I.getDescendants(k),J=[];J.push(this.beginAnimation(I,i,d,u,H,Y,x,j,l,void 0,g));for(const L of P)J.push(this.beginAnimation(L,i,d,u,H,Y,x,j,l,void 0,g));return J},s.prototype.beginDirectAnimation=function(I,k,i,d,u){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(H<0){const I=i;i=d,d=I,H=-H}return i>d&&(H=-H),new P(this,I,i,d,u,H,arguments.length>6?arguments[6]:void 0,k,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},s.prototype.beginDirectHierarchyAnimation=function(I,k,i,d,u,H,Y,x,j){let l=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const g=I.getDescendants(k),P=[];P.push(this.beginDirectAnimation(I,i,d,u,H,Y,x,j,l));for(const J of g)P.push(this.beginDirectAnimation(J,i,d,u,H,Y,x,j,l));return P},s.prototype.getAnimatableByTarget=function(I){for(let k=0;k<this._activeAnimatables.length;k++)if(this._activeAnimatables[k].target===I)return this._activeAnimatables[k];return null},s.prototype.getAllAnimatablesByTarget=function(I){const k=[];for(let i=0;i<this._activeAnimatables.length;i++)this._activeAnimatables[i].target===I&&k.push(this._activeAnimatables[i]);return k},s.prototype.stopAnimation=function(I,k,i){const d=this.getAllAnimatablesByTarget(I);for(const u of d)u.stop(k,i)},s.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let I=0;I<this._activeAnimatables.length;I++)this._activeAnimatables[I].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const I of this.animationGroups)I.stop()});class n{getClassName(){return"TargetedAnimation"}serialize(){const I={};return I.animation=this.animation.serialize(),I.targetId=this.target.id,I}}class B{get mask(){return this._mask}set mask(I){this._mask!==I&&(this._mask=I,this.syncWithMask(!0))}syncWithMask(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||I){this._numActiveAnimatables=0;for(let I=0;I<this._animatables.length;++I){const k=this._animatables[I];!this.mask||this.mask.disabled||this.mask.retainsTarget(k.target.name)?(this._numActiveAnimatables++,k.paused&&k.restart()):k.paused||k.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let I=0;I<this._animatables.length;++I){const k=this._animatables[I];this.mask.retainsTarget(k.target.name)||(k.stop(),this._animatables.splice(I,1),--I)}for(let I=0;I<this._targetedAnimations.length;I++){const k=this._targetedAnimations[I];this.mask.retainsTarget(k.target.name)||(this._targetedAnimations.splice(I,1),--I)}}}get from(){return this._from}set from(I){if(this._from!==I){this._from=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].fromFrame=this._from}}}get to(){return this._to}set to(I){if(this._to!==I){this._to=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(I){if(this._speedRatio!==I){this._speedRatio=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(I){if(this._loopAnimation!==I){this._loopAnimation=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(I){if(this._isAdditive!==I){this._isAdditive=I;for(let I=0;I<this._animatables.length;I++){this._animatables[I].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(I){this._weight!==I&&(this._weight=I,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(I){if(this._playOrder!==I&&(this._playOrder=I,this._animatables.length>0)){for(let I=0;I<this._animatables.length;I++)this._animatables[I].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(I){if(this._enableBlending!==I&&(this._enableBlending=I,null!==I))for(let k=0;k<this._targetedAnimations.length;++k)this._targetedAnimations[k].animation.enableBlending=I}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(I){if(this._blendingSpeed!==I&&(this._blendingSpeed=I,null!==I))for(let k=0;k<this._targetedAnimations.length;++k)this._targetedAnimations[k].animation.blendingSpeed=I}getLength(I,k){I=I??this._from;return((k=k??this._to)-I)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(I){let k=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],d=arguments.length>3?arguments[3]:void 0;if(0===I.length)return null;d=d??I[0].weight;let u=Number.MAX_VALUE,H=-Number.MAX_VALUE;if(i)for(const x of I)x.from<u&&(u=x.from),x.to>H&&(H=x.to);const Y=new B(I[0].name+"_merged",I[0]._scene,d);for(const x of I){i&&x.normalize(u,H);for(const I of x.targetedAnimations)Y.addTargetedAnimation(I.animation,I.target);k&&x.dispose()}return Y}constructor(I){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=I,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new u.e,this.onAnimationLoopObservable=new u.e,this.onAnimationGroupLoopObservable=new u.e,this.onAnimationGroupEndObservable=new u.e,this.onAnimationGroupPauseObservable=new u.e,this.onAnimationGroupPlayObservable=new u.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=k||H.e.LastCreatedScene,this._weight=i,this._playOrder=d,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(I,k){const i=new n;i.animation=I,i.target=k;const d=I.getKeys();return this._from>d[0].frame&&(this._from=d[0].frame),this._to<d[d.length-1].frame&&(this._to=d[d.length-1].frame),null!==this._enableBlending&&(I.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(I.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(i),this._shouldStart=!0,i}removeTargetedAnimation(I){for(let k=this._targetedAnimations.length-1;k>-1;k--){this._targetedAnimations[k].animation===I&&this._targetedAnimations.splice(k,1)}}normalize(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==I&&(I=this._from),null==k&&(k=this._to);for(let i=0;i<this._targetedAnimations.length;i++){const d=this._targetedAnimations[i].animation.getKeys(),u=d[0],H=d[d.length-1];if(u.frame>I){const k={frame:I,value:u.value,inTangent:u.inTangent,outTangent:u.outTangent,interpolation:u.interpolation};d.splice(0,0,k)}if(H.frame<k){const I={frame:k,value:H.value,inTangent:H.inTangent,outTangent:H.outTangent,interpolation:H.interpolation};d.push(I)}}return this._from=I,this._to=k,this}_processLoop(I,k,i){I.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(k),this._animationLoopFlags[i]||(this._animationLoopFlags[i]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0],k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0,d=arguments.length>3?arguments[3]:void 0,u=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=I,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let H=0;H<this._targetedAnimations.length;H++){const Y=this._targetedAnimations[H],x=this._scene.beginDirectAnimation(Y.target,[Y.animation],void 0!==i?i:this._from,void 0!==d?d:this._to,I,k,void 0,void 0,void 0!==u?u:this._isAdditive);x.weight=this._weight,x.playOrder=this._playOrder,x.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Y),this._checkAnimationGroupEnded(x)},this._processLoop(x,Y,H),this._animatables.push(x)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=k,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let I=0;I<this._animatables.length;I++){this._animatables[I].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(I){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==I&&(this.loopAnimation=I),this.restart()):(this.stop(),this.start(I,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let I=0;I<this._animatables.length;I++){this._animatables[I].reset()}return this}restart(){if(!this._isStarted)return this;for(let I=0;I<this._animatables.length;I++){this._animatables[I].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const k=this._animatables.slice();for(let d=0;d<k.length;d++)k[d].stop(void 0,void 0,!0,I);let i=0;for(let d=0;d<this._scene._activeAnimatables.length;d++){const k=this._scene._activeAnimatables[d];k._runtimeAnimations.length>0?this._scene._activeAnimatables[i++]=k:I&&this._checkAnimationGroupEnded(k,I)}return this._scene._activeAnimatables.length=i,this._isStarted=!1,this}setWeightForAllAnimatables(I){for(let k=0;k<this._animatables.length;k++){this._animatables[k].weight=I}return this}syncAllAnimationsWith(I){for(let k=0;k<this._animatables.length;k++){this._animatables[k].syncWith(I)}return this}goToFrame(I){if(!this._isStarted)return this;for(let k=0;k<this._animatables.length;k++){this._animatables[k].goToFrame(I)}return this}getCurrentFrame(){var I;return(null===(I=this.animatables[0])||void 0===I?void 0:I.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const I=this._scene.animationGroups.indexOf(this);if(I>-1&&this._scene.animationGroups.splice(I,1),this._parentContainer){const I=this._parentContainer.animationGroups.indexOf(this);I>-1&&this._parentContainer.animationGroups.splice(I,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(I){let k=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const i=this._animatables.indexOf(I);i>-1&&this._animatables.splice(i,1),0===this._animatables.length&&(this._isStarted=!1,k||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(I,k){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const d=new B(I||this.name,this._scene,this._weight,this._playOrder);d._from=this.from,d._to=this.to,d._speedRatio=this.speedRatio,d._loopAnimation=this.loopAnimation,d._isAdditive=this.isAdditive,d._enableBlending=this.enableBlending,d._blendingSpeed=this.blendingSpeed,d.metadata=this.metadata,d.mask=this.mask;for(const u of this._targetedAnimations)d.addTargetedAnimation(i?u.animation.clone():u.animation,k?k(u.target):u.target);return d}serialize(){const I={};I.name=this.name,I.from=this.from,I.to=this.to,I.speedRatio=this.speedRatio,I.loopAnimation=this.loopAnimation,I.isAdditive=this.isAdditive,I.weight=this.weight,I.playOrder=this.playOrder,I.enableBlending=this.enableBlending,I.blendingSpeed=this.blendingSpeed,I.targetedAnimations=[];for(let k=0;k<this.targetedAnimations.length;k++){const i=this.targetedAnimations[k];I.targetedAnimations[k]=i.serialize()}return Y.b&&Y.b.HasTags(this)&&(I.tags=Y.b.GetTags(this)),this.metadata&&(I.metadata=this.metadata),I}static Parse(I,k){const i=new B(I.name,k,I.weight,I.playOrder);for(let u=0;u<I.targetedAnimations.length;u++){const H=I.targetedAnimations[u],Y=d.b.Parse(H.animation),x=H.targetId;if("influence"===H.animation.property){const I=k.getMorphTargetById(x);I&&i.addTargetedAnimation(Y,I)}else{const I=k.getNodeById(x);null!=I&&i.addTargetedAnimation(Y,I)}}return Y.b&&Y.b.AddTagsTo(i,I.tags),null!==I.from&&null!==I.to&&i.normalize(I.from,I.to),void 0!==I.speedRatio&&(i._speedRatio=I.speedRatio),void 0!==I.loopAnimation&&(i._loopAnimation=I.loopAnimation),void 0!==I.isAdditive&&(i._isAdditive=I.isAdditive),void 0!==I.weight&&(i._weight=I.weight),void 0!==I.playOrder&&(i._playOrder=I.playOrder),void 0!==I.enableBlending&&(i._enableBlending=I.enableBlending),void 0!==I.blendingSpeed&&(i._blendingSpeed=I.blendingSpeed),void 0!==I.metadata&&(i.metadata=I.metadata),i}static MakeAnimationAdditive(I,k,i){let u;u="object"===typeof k?k:{referenceFrame:k,range:i,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let H=I;u.cloneOriginalAnimationGroup&&(H=I.clone(u.clonedAnimationGroupName||H.name));const Y=H.targetedAnimations;for(let x=0;x<Y.length;x++){const I=Y[x];I.animation=d.b.MakeAnimationAdditive(I.animation,u)}if(H.isAdditive=!0,u.clipKeys){let I=Number.MAX_VALUE,k=-Number.MAX_VALUE;const i=H.targetedAnimations;for(let d=0;d<i.length;d++){const u=i[d].animation.getKeys();I>u[0].frame&&(I=u[0].frame),k<u[u.length-1].frame&&(k=u[u.length-1].frame)}H._from=I,H._to=k}return H}static ClipKeys(I,k,i,d,u){const H=I.clone(d||I.name);return B.ClipKeysInPlace(H,k,i,u)}static ClipKeysInPlace(I,k,i,d){return B.ClipInPlace(I,k,i,d,!1)}static ClipFrames(I,k,i,d,u){const H=I.clone(d||I.name);return B.ClipFramesInPlace(H,k,i,u)}static ClipFramesInPlace(I,k,i,d){return B.ClipInPlace(I,k,i,d,!0)}static ClipInPlace(I,k,i,d){let u=arguments.length>4&&void 0!==arguments[4]&&arguments[4],H=Number.MAX_VALUE,Y=-Number.MAX_VALUE;const x=I.targetedAnimations;for(let j=0;j<x.length;j++){const I=x[j],l=d?I.animation:I.animation.clone();u&&(l.createKeyForFrame(k),l.createKeyForFrame(i));const g=l.getKeys(),P=[];let J=Number.MAX_VALUE;for(let d=0;d<g.length;d++){const I=g[d];if(!u&&d>=k&&d<=i||u&&I.frame>=k&&I.frame<=i){const k={frame:I.frame,value:I.value.clone?I.value.clone():I.value,inTangent:I.inTangent,outTangent:I.outTangent,interpolation:I.interpolation,lockedTangent:I.lockedTangent};J===Number.MAX_VALUE&&(J=k.frame),k.frame-=J,P.push(k)}}0!==P.length?(H>P[0].frame&&(H=P[0].frame),Y<P[P.length-1].frame&&(Y=P[P.length-1].frame),l.setKeys(P,!0),I.animation=l):(x.splice(j,1),j--)}return I._from=H,I._to=Y,I}getClassName(){return"AnimationGroup"}toString(I){let k="Name: "+this.name;return k+=", type: "+this.getClassName(),I&&(k+=", from: "+this._from,k+=", to: "+this._to,k+=", isStarted: "+this._isStarted,k+=", speedRatio: "+this._speedRatio,k+=", targetedAnimations length: "+this._targetedAnimations.length,k+=", animatables length: "+this._animatables),k}}}}]);