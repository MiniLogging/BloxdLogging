"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{13377:(D,j,W)=>{W.r(j),W.d(j,{AnimationGroup:()=>g,TargetedAnimation:()=>U});var Q=W(12682),C=W(961),k=W(991),M=W(1155),O=W(12673),E=W(966);class f{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(D,j,W,C){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=j,this._target=D,this._scene=W,this._host=C,this._activeTargets=[],j._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===Q.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=E.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const D={frame:0,value:this._minValue};this._keys.splice(0,0,D)}if(this._target instanceof Array){let D=0;for(const j of this._target)this._preparePath(j,D),this._getOriginalValues(D),D++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const k=j.getEvents();k&&k.length>0&&k.forEach((D=>{this._events.push(D._clone())})),this._enableBlending=D&&D.animationPropertiesOverride?D.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(D){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const W=this._animation.targetPropertyPath;if(W.length>1){let Q=D;for(let D=0;D<W.length-1;D++){const j=W[D];if(Q=Q[j],void 0===Q)throw new Error(`Invalid property (${j}) in property path (${W.join(".")})`)}this._targetPath=W[W.length-1],this._activeTargets[j]=Q}else this._targetPath=W[0],this._activeTargets[j]=D;if(void 0===this._activeTargets[j][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${W.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let D=0;for(const j of this._target)void 0!==this._originalValue[D]&&this._setValue(j,this._activeTargets[D],this._originalValue[D],-1,D),D++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let D=0;D<this._events.length;D++)this._events[D].isDone=!1}isStopped(){return this._stopped}dispose(){const D=this._animation.runtimeAnimations.indexOf(this);D>-1&&this._animation.runtimeAnimations.splice(D,1)}setValue(D,j){if(this._targetIsArray)for(let W=0;W<this._target.length;W++){const Q=this._target[W];this._setValue(Q,this._activeTargets[W],D,j,W)}else this._setValue(this._target,this._directTarget,D,j,0)}_getOriginalValues(){let D,j=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const W=this._activeTargets[j];D=W.getLocalMatrix&&"_matrix"===this._targetPath?W.getLocalMatrix():W[this._targetPath],D&&D.clone?this._originalValue[j]=D.clone():this._originalValue[j]=D}_registerTargetForLateAnimationBinding(D,j){const W=D.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(W),W._lateAnimationHolders||(W._lateAnimationHolders={}),W._lateAnimationHolders[D.targetPath]||(W._lateAnimationHolders[D.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:j}),D.isAdditive?(W._lateAnimationHolders[D.targetPath].additiveAnimations.push(D),W._lateAnimationHolders[D.targetPath].totalAdditiveWeight+=D.weight):(W._lateAnimationHolders[D.targetPath].animations.push(D),W._lateAnimationHolders[D.targetPath].totalWeight+=D.weight)}_setValue(D,j,W,C,k){if(this._currentActiveTarget=j,this._weight=C,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const D=j[this._targetPath];D.clone?this._originalBlendValue=D.clone():this._originalBlendValue=D}this._originalBlendValue.m?Q.c.AllowMatrixDecomposeForInterpolation?this._currentValue?E.b.DecomposeLerpToRef(this._originalBlendValue,W,this._blendingFactor,this._currentValue):this._currentValue=E.b.DecomposeLerp(this._originalBlendValue,W,this._blendingFactor):this._currentValue?E.b.LerpToRef(this._originalBlendValue,W,this._blendingFactor,this._currentValue):this._currentValue=E.b.Lerp(this._originalBlendValue,W,this._blendingFactor):this._currentValue=Q.c._UniversalLerp(this._originalBlendValue,W,this._blendingFactor);const C=D&&D.animationPropertiesOverride?D.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=C}else this._currentValue?this._currentValue.p?this._currentValue.p(W):this._currentValue=W:null!==W&&void 0!==W&&W.clone?this._currentValue=W.clone():this._currentValue=W;-1!==C?this._registerTargetForLateAnimationBinding(this,this._originalValue[k]):this._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[k],j[this._targetPath]):j[this._targetPath]=this._originalValue[k]+this._currentValue:j[this._targetPath]=this._currentValue,D.Le&&D.Le(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(D){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const W=this._animation.getKeys();D<W[0].frame?D=W[0].frame:D>W[W.length-1].frame&&(D=W[W.length-1].frame);const Q=this._events;if(Q.length)for(let k=0;k<Q.length;k++)Q[k].onlyOnce||(Q[k].isDone=Q[k].frame<D);this._currentFrame=D;const C=this._animation._interpolate(D,this._animationState);this.setValue(C,j)}_prepareForSpeedRatioChange(D){const j=this._previousElapsedTime*(this._animation.framePerSecond*D)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-j}animate(D,j,W,C,k){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const O=this._animation,E=O.targetPropertyPath;if(!E||E.length<1)return this._stopped=!0,!1;let f=!0;(j<this._minFrame||j>this._maxFrame)&&(j=this._minFrame),(W<this._minFrame||W>this._maxFrame)&&(W=this._maxFrame);const F=W-j;let Z,P=D*(O.framePerSecond*k)/1e3+this._absoluteFrameOffset,X=0,x=!1;const R=C&&this._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_YOYO;if(R){const D=(P-j)/F,W=Math.sin(D*Math.PI);P=Math.abs(W)*F+j;const Q=W>=0?1:-1;this._yoyoDirection!==Q&&(x=!0),this._yoyoDirection=Q}if(this._previousElapsedTime=D,this._previousAbsoluteFrame=P,!C&&W>=j&&(P>=F&&k>0||P<=0&&k<0))f=!1,X=O._getKeyValue(this._maxValue);else if(!C&&j>=W&&(P<=F&&k<0||P>=0&&k>0))f=!1,X=O._getKeyValue(this._minValue);else if(this._animationState.loopMode!==Q.c.ANIMATIONLOOPMODE_CYCLE){const D=W.toString()+j.toString();if(!this._offsetsCache[D]){this._animationState.repeatCount=0,this._animationState.loopMode=Q.c.ANIMATIONLOOPMODE_CYCLE;const C=O._interpolate(j,this._animationState),k=O._interpolate(W,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),O.dataType){case Q.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[D]=k-C;break;case Q.c.ANIMATIONTYPE_QUATERNION:case Q.c.ANIMATIONTYPE_VECTOR3:case Q.c.ANIMATIONTYPE_VECTOR2:case Q.c.ANIMATIONTYPE_SIZE:case Q.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[D]=k.Qc(C)}this._highLimitsCache[D]=k}X=this._highLimitsCache[D],Z=this._offsetsCache[D]}if(void 0===Z)switch(O.dataType){case Q.c.ANIMATIONTYPE_FLOAT:Z=0;break;case Q.c.ANIMATIONTYPE_QUATERNION:Z=Q.k;break;case Q.c.ANIMATIONTYPE_VECTOR3:Z=Q.s;break;case Q.c.ANIMATIONTYPE_VECTOR2:Z=Q.p;break;case Q.c.ANIMATIONTYPE_SIZE:Z=Q.l;break;case Q.c.ANIMATIONTYPE_COLOR3:Z=Q.f;break;case Q.c.ANIMATIONTYPE_COLOR4:Z=Q.i}let V;if(this._host&&this._host.syncRoot){const D=this._host.syncRoot;V=j+F*((D.masterFrame-D.fromFrame)/(D.toFrame-D.fromFrame))}else V=P>0&&j>W||P<0&&j<W?f&&0!==F?W+P%F:j:f&&0!==F?j+P%F:W;const U=this._events;if(!R&&(k>0&&this.currentFrame>V||k<0&&this.currentFrame<V)||R&&x){this._onLoop();for(let D=0;D<U.length;D++)U[D].onlyOnce||(U[D].isDone=!1);this._animationState.key=k>0?0:O.getKeys().length-1}this._currentFrame=V,this._animationState.repeatCount=0===F?0:P/F|0,this._animationState.highLimitValue=X,this._animationState.offsetValue=Z;const g=O._interpolate(V,this._animationState);if(this.setValue(g,M),U.length)for(let Q=0;Q<U.length;Q++)if(F>=0&&V>=U[Q].frame&&U[Q].frame>=j||F<0&&V<=U[Q].frame&&U[Q].frame<=j){const D=U[Q];D.isDone||(D.onlyOnce&&(U.splice(Q,1),Q--),D.isDone=!0,D.action(V))}return f||(this._stopped=!0),f}}var F=W(1122);class Z{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(D){this._weight=-1!==D?Math.min(Math.max(D,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(D){for(let j=0;j<this._runtimeAnimations.length;j++){this._runtimeAnimations[j]._prepareForSpeedRatioChange(D)}this._speedRatio=D,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(D,j){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,k=arguments.length>4&&void 0!==arguments[4]&&arguments[4],M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,O=arguments.length>6?arguments[6]:void 0,E=arguments.length>7?arguments[7]:void 0,f=arguments.length>8?arguments[8]:void 0,F=arguments.length>9&&void 0!==arguments[9]&&arguments[9],Z=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=j,this.fromFrame=W,this.toFrame=Q,this.loopAnimation=k,this.onAnimationEnd=O,this.onAnimationLoop=f,this.isAdditive=F,this.playOrder=Z,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Cf=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new C.d,this.onAnimationLoopObservable=new C.d,this._scene=D,E&&this.appendAnimations(j,E),this._speedRatio=M,D._activeAnimatables.push(this)}syncWith(D){if(this._syncRoot=D,D){const D=this._scene._activeAnimatables.indexOf(this);D>-1&&(this._scene._activeAnimatables.splice(D,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(D,j){for(let W=0;W<j.length;W++){const Q=j[W],C=new f(D,Q,this._scene,this);C._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(C)}}getAnimationByTargetProperty(D){const j=this._runtimeAnimations;for(let W=0;W<j.length;W++)if(j[W].animation.targetProperty===D)return j[W].animation;return null}getRuntimeAnimationByTargetProperty(D){const j=this._runtimeAnimations;for(let W=0;W<j.length;W++)if(j[W].animation.targetProperty===D)return j[W];return null}reset(){const D=this._runtimeAnimations;for(let j=0;j<D.length;j++)D[j].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(D){const j=this._runtimeAnimations;for(let W=0;W<j.length;W++)j[W].animation.enableBlending=!0,j[W].animation.blendingSpeed=D}disableBlending(){const D=this._runtimeAnimations;for(let j=0;j<D.length;j++)D[j].animation.enableBlending=!1}goToFrame(D){const j=this._runtimeAnimations;if(j[0]){const W=j[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??j[0].currentFrame;const Q=0===this.speedRatio?0:(D-this._frameToSyncFromJump)/W*1e3/this.speedRatio;this._manualJumpDelay=-Q}for(let W=0;W<j.length;W++)j[W].goToFrame(D,this._weight);this._goToFrame=D}get paused(){return this.Cf}pause(){this.Cf||(this.Cf=!0)}restart(){this.Cf=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(D,j){let W=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(D||j){const C=this._scene._activeAnimatables.indexOf(this);if(C>-1){const k=this._runtimeAnimations;for(let W=k.length-1;W>=0;W--){const Q=k[W];D&&Q.animation.name!=D||(j&&!j(Q.target)||(Q.dispose(),k.splice(W,1)))}0==k.length&&(W||this._scene._activeAnimatables.splice(C,1),Q||this._raiseOnAnimationEnd())}}else{const D=this._scene._activeAnimatables.indexOf(this);if(D>-1){W||this._scene._activeAnimatables.splice(D,1);const j=this._runtimeAnimations;for(let D=0;D<j.length;D++)j[D].dispose();this._runtimeAnimations.length=0,Q||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((D=>{this.onAnimationEndObservable.add((()=>{D(this)}),void 0,void 0,this,!0)}))}_animate(D){if(this.Cf)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=D),!0;if(null===this._localDelayOffset?(this._localDelayOffset=D,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=D-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let j=!1;const W=this._runtimeAnimations;let Q;for(Q=0;Q<W.length;Q++){const C=W[Q].animate(D-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);j=j||C}if(this.animationStarted=j,!j){if(this.disposeOnEnd)for(Q=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(Q,1),Q=0;Q<W.length;Q++)W[Q].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return j}}function P(D){if(0===D.totalWeight&&0===D.totalAdditiveWeight)return D.originalValue;let j=1;const W=E.e.Kd[0],Q=E.e.Kd[1],C=E.e.Quaternion[0];let k=0;const M=D.animations[0],O=D.originalValue;let f=1,F=!1;if(D.totalWeight<1)f=1-D.totalWeight,O.decompose(Q,C,W);else{if(k=1,j=D.totalWeight,f=M.weight/j,1==f){if(!D.totalAdditiveWeight)return M.currentValue;F=!0}M.currentValue.decompose(Q,C,W)}if(!F){Q.scaleInPlace(f),W.scaleInPlace(f),C.scaleInPlace(f);for(let M=k;M<D.animations.length;M++){const k=D.animations[M];if(0===k.weight)continue;f=k.weight/j;const O=E.e.Kd[2],F=E.e.Kd[3],Z=E.e.Quaternion[1];k.currentValue.decompose(F,Z,O),F.scaleAndAddToRef(f,Q),Z.scaleAndAddToRef(E.d.Dot(C,Z)>0?f:-f,C),O.scaleAndAddToRef(f,W)}C.normalize()}for(let P=0;P<D.additiveAnimations.length;P++){const j=D.additiveAnimations[P];if(0===j.weight)continue;const k=E.e.Kd[2],M=E.e.Kd[3],O=E.e.Quaternion[1];j.currentValue.decompose(M,O,k),M.multiplyToRef(Q,M),E.j.LerpToRef(Q,M,j.weight,Q),C.multiplyToRef(O,O),E.d.SlerpToRef(C,O,j.weight,C),k.scaleAndAddToRef(j.weight,W)}const Z=M?M._animationState.workValue:E.e.Matrix[0].clone();return E.b.ComposeToRef(Q,C,W,Z),Z}function X(D,j){if(0===D.totalWeight&&0===D.totalAdditiveWeight)return j;const W=D.animations[0],Q=D.originalValue;let C=j;if(0===D.totalWeight&&D.totalAdditiveWeight>0)C.p(Q);else if(1===D.animations.length){if(E.d.SlerpToRef(Q,W.currentValue,Math.min(1,D.totalWeight),C),0===D.totalAdditiveWeight)return C}else if(D.animations.length>1){let W,k,M=1;if(D.totalWeight<1){const j=1-D.totalWeight;W=[],k=[],W.push(Q),k.push(j)}else{if(2===D.animations.length&&(E.d.SlerpToRef(D.animations[0].currentValue,D.animations[1].currentValue,D.animations[1].weight/D.totalWeight,j),0===D.totalAdditiveWeight))return j;W=[],k=[],M=D.totalWeight}for(let j=0;j<D.animations.length;j++){const Q=D.animations[j];W.push(Q.currentValue),k.push(Q.weight/M)}let O=0;for(let D=0;D<W.length;)D?(O+=k[D],E.d.SlerpToRef(C,W[D],k[D]/O,C),D++):(E.d.SlerpToRef(W[D],W[D+1],k[D+1]/(k[D]+k[D+1]),j),C=j,O=k[D]+k[D+1],D+=2)}for(let k=0;k<D.additiveAnimations.length;k++){const j=D.additiveAnimations[k];0!==j.weight&&(C.multiplyToRef(j.currentValue,E.e.Quaternion[0]),E.d.SlerpToRef(C,E.e.Quaternion[0],j.weight,C))}return C}var x,R,V=W(1199);x=V.b,(R=O.e)&&(R.prototype.copyAnimationRange=function(D,j,W){let C=arguments.length>3&&void 0!==arguments[3]&&arguments[3],k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new Q.c(this.name,"_matrix",D.animations[0].framePerSecond,Q.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const M=D.animations[0].getRange(j);if(!M)return!1;const O=M.from,E=M.to,f=D.animations[0].getKeys(),F=D.length,Z=D.getParent(),P=this.getParent(),X=C&&Z&&F&&this.length&&F!==this.length,x=X&&P&&Z?P.length/Z.length:1,R=C&&!P&&k&&(1!==k.x||1!==k.y||1!==k.z),V=this.animations[0].getKeys();let U,g,N;for(let Q=0,G=f.length;Q<G;Q++)U=f[Q],U.frame>=O&&U.frame<=E&&(C?(N=U.value.clone(),X?(g=N.getTranslation(),N.setTranslation(g.scaleInPlace(x))):R&&k?(g=N.getTranslation(),N.setTranslation(g.multiplyInPlace(k))):N=U.value):N=U.value,V.push({frame:U.frame+W,value:N}));return this.animations[0].createRange(j,O+W,E+W),!0}),x&&(x.prototype._animate=function(D){if(!this.animationsEnabled)return;const j=F.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=j}this.deltaTime=void 0!==D?D:this.useConstantAnimationDeltaTime?16:(j-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=j;const W=this._activeAnimatables;if(0===W.length)return;this._animationTime+=this.deltaTime;const C=this._animationTime;for(let Q=0;Q<W.length;Q++){const D=W[Q];!D._animate(C)&&D.disposeOnEnd&&Q--}!function(D){if(D._registeredForLateAnimationBindings.length){for(let j=0;j<D._registeredForLateAnimationBindings.length;j++){const W=D._registeredForLateAnimationBindings.data[j];for(const D in W._lateAnimationHolders){const j=W._lateAnimationHolders[D],C=j.animations[0],k=j.originalValue;if(void 0===k||null===k)continue;const M=Q.c.AllowMatrixDecomposeForInterpolation&&k.m;let O=W[D];if(M)O=P(j);else if(void 0!==k.w)O=X(j,O||E.d.Identity());else{let D=0,W=1;const M=C&&C._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(j.totalWeight<1)O=M?k.clone?k.clone():k:C&&k.scale?k.scale(1-j.totalWeight):C?k*(1-j.totalWeight):k.clone?k.clone():k;else if(C){W=j.totalWeight;const Q=C.weight/W;O=1!==Q?C.currentValue.scale?C.currentValue.scale(Q):C.currentValue*Q:C.currentValue,M&&(O.addToRef?O.addToRef(k,O):O+=k),D=1}for(let Q=D;Q<j.animations.length;Q++){const D=j.animations[Q],C=D.weight/W;C&&(D.currentValue.scaleAndAddToRef?D.currentValue.scaleAndAddToRef(C,O):O+=D.currentValue*C)}for(let Q=0;Q<j.additiveAnimations.length;Q++){const D=j.additiveAnimations[Q],W=D.weight;W&&(D.currentValue.scaleAndAddToRef?D.currentValue.scaleAndAddToRef(W,O):O+=D.currentValue*W)}}W[D]=O}W._lateAnimationHolders={}}D._registeredForLateAnimationBindings.reset()}}(this)},x.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((D,j)=>D.playOrder-j.playOrder))},x.prototype.beginWeightedAnimation=function(D,j,W){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,C=arguments.length>4?arguments[4]:void 0,k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,M=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,E=arguments.length>8?arguments[8]:void 0,f=arguments.length>9?arguments[9]:void 0,F=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const Z=this.beginAnimation(D,j,W,C,k,M,O,!1,E,f,F);return Z.weight=Q,Z},x.prototype.beginAnimation=function(D,j,W,Q){let C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,k=arguments.length>5?arguments[5]:void 0,M=arguments.length>6?arguments[6]:void 0,O=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],E=arguments.length>8?arguments[8]:void 0,f=arguments.length>9?arguments[9]:void 0,F=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(C<0){const D=j;j=W,W=D,C=-C}j>W&&(C=-C),O&&this.stopAnimation(D,void 0,E),M||(M=new Z(this,D,j,W,Q,C,k,void 0,f,F));const P=!E||E(D);if(D.animations&&P&&M.appendAnimations(D,D.animations),D.getAnimatables){const F=D.getAnimatables();for(let D=0;D<F.length;D++)this.beginAnimation(F[D],j,W,Q,C,k,M,O,E,f)}return M.reset(),M},x.prototype.beginHierarchyAnimation=function(D,j,W,Q,C){let k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,M=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,E=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],f=arguments.length>9?arguments[9]:void 0,F=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const Z=D.getDescendants(j),P=[];P.push(this.beginAnimation(D,W,Q,C,k,M,O,E,f,void 0,F));for(const X of Z)P.push(this.beginAnimation(X,W,Q,C,k,M,O,E,f,void 0,F));return P},x.prototype.beginDirectAnimation=function(D,j,W,Q,C){let k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(k<0){const D=W;W=Q,Q=D,k=-k}return W>Q&&(k=-k),new Z(this,D,W,Q,C,k,arguments.length>6?arguments[6]:void 0,j,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},x.prototype.beginDirectHierarchyAnimation=function(D,j,W,Q,C,k,M,O,E){let f=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const F=D.getDescendants(j),Z=[];Z.push(this.beginDirectAnimation(D,W,Q,C,k,M,O,E,f));for(const P of F)Z.push(this.beginDirectAnimation(P,W,Q,C,k,M,O,E,f));return Z},x.prototype.getAnimatableByTarget=function(D){for(let j=0;j<this._activeAnimatables.length;j++)if(this._activeAnimatables[j].target===D)return this._activeAnimatables[j];return null},x.prototype.getAllAnimatablesByTarget=function(D){const j=[];for(let W=0;W<this._activeAnimatables.length;W++)this._activeAnimatables[W].target===D&&j.push(this._activeAnimatables[W]);return j},x.prototype.stopAnimation=function(D,j,W){const Q=this.getAllAnimatablesByTarget(D);for(const C of Q)C.stop(j,W)},x.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let D=0;D<this._activeAnimatables.length;D++)this._activeAnimatables[D].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const D of this.animationGroups)D.stop()});class U{getClassName(){return"TargetedAnimation"}serialize(){const D={};return D.animation=this.animation.serialize(),D.targetId=this.target.id,D}}class g{get mask(){return this._mask}set mask(D){this._mask!==D&&(this._mask=D,this.syncWithMask(!0))}syncWithMask(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||D){this._numActiveAnimatables=0;for(let D=0;D<this._animatables.length;++D){const j=this._animatables[D];!this.mask||this.mask.disabled||this.mask.retainsTarget(j.target.name)?(this._numActiveAnimatables++,j.paused&&j.restart()):j.paused||j.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let D=0;D<this._animatables.length;++D){const j=this._animatables[D];this.mask.retainsTarget(j.target.name)||(j.stop(),this._animatables.splice(D,1),--D)}for(let D=0;D<this._targetedAnimations.length;D++){const j=this._targetedAnimations[D];this.mask.retainsTarget(j.target.name)||(this._targetedAnimations.splice(D,1),--D)}}}get from(){return this._from}set from(D){if(this._from!==D){this._from=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].fromFrame=this._from}}}get to(){return this._to}set to(D){if(this._to!==D){this._to=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(D){if(this._speedRatio!==D){this._speedRatio=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(D){if(this._loopAnimation!==D){this._loopAnimation=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(D){if(this._isAdditive!==D){this._isAdditive=D;for(let D=0;D<this._animatables.length;D++){this._animatables[D].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(D){this._weight!==D&&(this._weight=D,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(D){if(this._playOrder!==D&&(this._playOrder=D,this._animatables.length>0)){for(let D=0;D<this._animatables.length;D++)this._animatables[D].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(D){if(this._enableBlending!==D&&(this._enableBlending=D,null!==D))for(let j=0;j<this._targetedAnimations.length;++j)this._targetedAnimations[j].animation.enableBlending=D}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(D){if(this._blendingSpeed!==D&&(this._blendingSpeed=D,null!==D))for(let j=0;j<this._targetedAnimations.length;++j)this._targetedAnimations[j].animation.blendingSpeed=D}getLength(D,j){D=D??this._from;return((j=j??this._to)-D)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(D){let j=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],W=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=arguments.length>3?arguments[3]:void 0;if(0===D.length)return null;Q=Q??D[0].weight;let C=Number.MAX_VALUE,k=-Number.MAX_VALUE;if(W)for(const O of D)O.from<C&&(C=O.from),O.to>k&&(k=O.to);const M=new g(D[0].name+"_merged",D[0]._scene,Q);for(const O of D){W&&O.normalize(C,k);for(const D of O.targetedAnimations)M.addTargetedAnimation(D.animation,D.target);j&&O.dispose()}return M}constructor(D){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=D,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new C.d,this.onAnimationLoopObservable=new C.d,this.onAnimationGroupLoopObservable=new C.d,this.onAnimationGroupEndObservable=new C.d,this.onAnimationGroupPauseObservable=new C.d,this.onAnimationGroupPlayObservable=new C.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=j||k.b.LastCreatedScene,this._weight=W,this._playOrder=Q,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(D,j){const W=new U;W.animation=D,W.target=j;const Q=D.getKeys();return this._from>Q[0].frame&&(this._from=Q[0].frame),this._to<Q[Q.length-1].frame&&(this._to=Q[Q.length-1].frame),null!==this._enableBlending&&(D.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(D.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(W),this._shouldStart=!0,W}removeTargetedAnimation(D){for(let j=this._targetedAnimations.length-1;j>-1;j--){this._targetedAnimations[j].animation===D&&this._targetedAnimations.splice(j,1)}}normalize(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==D&&(D=this._from),null==j&&(j=this._to);for(let W=0;W<this._targetedAnimations.length;W++){const Q=this._targetedAnimations[W].animation.getKeys(),C=Q[0],k=Q[Q.length-1];if(C.frame>D){const j={frame:D,value:C.value,inTangent:C.inTangent,outTangent:C.outTangent,interpolation:C.interpolation};Q.splice(0,0,j)}if(k.frame<j){const D={frame:j,value:k.value,inTangent:k.inTangent,outTangent:k.outTangent,interpolation:k.interpolation};Q.push(D)}}return this._from=D,this._to=j,this}_processLoop(D,j,W){D.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(j),this._animationLoopFlags[W]||(this._animationLoopFlags[W]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0],j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,W=arguments.length>2?arguments[2]:void 0,Q=arguments.length>3?arguments[3]:void 0,C=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=D,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let k=0;k<this._targetedAnimations.length;k++){const M=this._targetedAnimations[k],O=this._scene.beginDirectAnimation(M.target,[M.animation],void 0!==W?W:this._from,void 0!==Q?Q:this._to,D,j,void 0,void 0,void 0!==C?C:this._isAdditive);O.weight=this._weight,O.playOrder=this._playOrder,O.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(M),this._checkAnimationGroupEnded(O)},this._processLoop(O,M,k),this._animatables.push(O)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=j,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let D=0;D<this._animatables.length;D++){this._animatables[D].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(D){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==D&&(this.loopAnimation=D),this.restart()):(this.stop(),this.start(D,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let D=0;D<this._animatables.length;D++){this._animatables[D].reset()}return this}restart(){if(!this._isStarted)return this;for(let D=0;D<this._animatables.length;D++){this._animatables[D].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const j=this._animatables.slice();for(let Q=0;Q<j.length;Q++)j[Q].stop(void 0,void 0,!0,D);let W=0;for(let Q=0;Q<this._scene._activeAnimatables.length;Q++){const j=this._scene._activeAnimatables[Q];j._runtimeAnimations.length>0?this._scene._activeAnimatables[W++]=j:D&&this._checkAnimationGroupEnded(j,D)}return this._scene._activeAnimatables.length=W,this._isStarted=!1,this}setWeightForAllAnimatables(D){for(let j=0;j<this._animatables.length;j++){this._animatables[j].weight=D}return this}syncAllAnimationsWith(D){for(let j=0;j<this._animatables.length;j++){this._animatables[j].syncWith(D)}return this}goToFrame(D){if(!this._isStarted)return this;for(let j=0;j<this._animatables.length;j++){this._animatables[j].goToFrame(D)}return this}getCurrentFrame(){var D;return(null===(D=this.animatables[0])||void 0===D?void 0:D.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const D=this._scene.animationGroups.indexOf(this);if(D>-1&&this._scene.animationGroups.splice(D,1),this._parentContainer){const D=this._parentContainer.animationGroups.indexOf(this);D>-1&&this._parentContainer.animationGroups.splice(D,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(D){let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const W=this._animatables.indexOf(D);W>-1&&this._animatables.splice(W,1),0===this._animatables.length&&(this._isStarted=!1,j||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(D,j){let W=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=new g(D||this.name,this._scene,this._weight,this._playOrder);Q._from=this.from,Q._to=this.to,Q._speedRatio=this.speedRatio,Q._loopAnimation=this.loopAnimation,Q._isAdditive=this.isAdditive,Q._enableBlending=this.enableBlending,Q._blendingSpeed=this.blendingSpeed,Q.metadata=this.metadata,Q.mask=this.mask;for(const C of this._targetedAnimations)Q.addTargetedAnimation(W?C.animation.clone():C.animation,j?j(C.target):C.target);return Q}serialize(){const D={};D.name=this.name,D.from=this.from,D.to=this.to,D.speedRatio=this.speedRatio,D.loopAnimation=this.loopAnimation,D.isAdditive=this.isAdditive,D.weight=this.weight,D.playOrder=this.playOrder,D.enableBlending=this.enableBlending,D.blendingSpeed=this.blendingSpeed,D.targetedAnimations=[];for(let j=0;j<this.targetedAnimations.length;j++){const W=this.targetedAnimations[j];D.targetedAnimations[j]=W.serialize()}return M.e&&M.e.HasTags(this)&&(D.tags=M.e.GetTags(this)),this.metadata&&(D.metadata=this.metadata),D}static Parse(D,j){const W=new g(D.name,j,D.weight,D.playOrder);for(let C=0;C<D.targetedAnimations.length;C++){const k=D.targetedAnimations[C],M=Q.c.Parse(k.animation),O=k.targetId;if("influence"===k.animation.property){const D=j.getMorphTargetById(O);D&&W.addTargetedAnimation(M,D)}else{const D=j.getNodeById(O);null!=D&&W.addTargetedAnimation(M,D)}}return M.e&&M.e.AddTagsTo(W,D.tags),null!==D.from&&null!==D.to&&W.normalize(D.from,D.to),void 0!==D.speedRatio&&(W._speedRatio=D.speedRatio),void 0!==D.loopAnimation&&(W._loopAnimation=D.loopAnimation),void 0!==D.isAdditive&&(W._isAdditive=D.isAdditive),void 0!==D.weight&&(W._weight=D.weight),void 0!==D.playOrder&&(W._playOrder=D.playOrder),void 0!==D.enableBlending&&(W._enableBlending=D.enableBlending),void 0!==D.blendingSpeed&&(W._blendingSpeed=D.blendingSpeed),void 0!==D.metadata&&(W.metadata=D.metadata),W}static MakeAnimationAdditive(D,j,W){let C;C="object"===typeof j?j:{referenceFrame:j,range:W,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let k=D;C.cloneOriginalAnimationGroup&&(k=D.clone(C.clonedAnimationGroupName||k.name));const M=k.targetedAnimations;for(let O=0;O<M.length;O++){const D=M[O];D.animation=Q.c.MakeAnimationAdditive(D.animation,C)}if(k.isAdditive=!0,C.clipKeys){let D=Number.MAX_VALUE,j=-Number.MAX_VALUE;const W=k.targetedAnimations;for(let Q=0;Q<W.length;Q++){const C=W[Q].animation.getKeys();D>C[0].frame&&(D=C[0].frame),j<C[C.length-1].frame&&(j=C[C.length-1].frame)}k._from=D,k._to=j}return k}static ClipKeys(D,j,W,Q,C){const k=D.clone(Q||D.name);return g.ClipKeysInPlace(k,j,W,C)}static ClipKeysInPlace(D,j,W,Q){return g.ClipInPlace(D,j,W,Q,!1)}static ClipFrames(D,j,W,Q,C){const k=D.clone(Q||D.name);return g.ClipFramesInPlace(k,j,W,C)}static ClipFramesInPlace(D,j,W,Q){return g.ClipInPlace(D,j,W,Q,!0)}static ClipInPlace(D,j,W,Q){let C=arguments.length>4&&void 0!==arguments[4]&&arguments[4],k=Number.MAX_VALUE,M=-Number.MAX_VALUE;const O=D.targetedAnimations;for(let E=0;E<O.length;E++){const D=O[E],f=Q?D.animation:D.animation.clone();C&&(f.createKeyForFrame(j),f.createKeyForFrame(W));const F=f.getKeys(),Z=[];let P=Number.MAX_VALUE;for(let Q=0;Q<F.length;Q++){const D=F[Q];if(!C&&Q>=j&&Q<=W||C&&D.frame>=j&&D.frame<=W){const j={frame:D.frame,value:D.value.clone?D.value.clone():D.value,inTangent:D.inTangent,outTangent:D.outTangent,interpolation:D.interpolation,lockedTangent:D.lockedTangent};P===Number.MAX_VALUE&&(P=j.frame),j.frame-=P,Z.push(j)}}0!==Z.length?(k>Z[0].frame&&(k=Z[0].frame),M<Z[Z.length-1].frame&&(M=Z[Z.length-1].frame),f.setKeys(Z,!0),D.animation=f):(O.splice(E,1),E--)}return D._from=k,D._to=M,D}getClassName(){return"AnimationGroup"}toString(D){let j="Name: "+this.name;return j+=", type: "+this.getClassName(),D&&(j+=", from: "+this._from,j+=", to: "+this._to,j+=", isStarted: "+this._isStarted,j+=", speedRatio: "+this._speedRatio,j+=", targetedAnimations length: "+this._targetedAnimations.length,j+=", animatables length: "+this._animatables),j}}}}]);