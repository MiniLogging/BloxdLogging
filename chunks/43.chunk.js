"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12560:(b,G,i)=>{i.r(G),i.d(G,{AnimationGroup:()=>W,TargetedAnimation:()=>u});var g=i(11894),c=i(1006),V=i(1036),z=i(1174),E=i(11885),Z=i(1014);class Y{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(b,G,i,c){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=G,this._target=b,this._scene=i,this._host=c,this._activeTargets=[],G._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===g.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=Z.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const b={frame:0,value:this._minValue};this._keys.splice(0,0,b)}if(this._target instanceof Array){let b=0;for(const G of this._target)this._preparePath(G,b),this._getOriginalValues(b),b++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const V=G.getEvents();V&&V.length>0&&V.forEach((b=>{this._events.push(b._clone())})),this._enableBlending=b&&b.animationPropertiesOverride?b.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(b){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const i=this._animation.targetPropertyPath;if(i.length>1){let g=b;for(let b=0;b<i.length-1;b++){const G=i[b];if(g=g[G],void 0===g)throw new Error(`Invalid property (${G}) in property path (${i.join(".")})`)}this._targetPath=i[i.length-1],this._activeTargets[G]=g}else this._targetPath=i[0],this._activeTargets[G]=b;if(void 0===this._activeTargets[G][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${i.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let b=0;for(const G of this._target)void 0!==this._originalValue[b]&&this._setValue(G,this._activeTargets[b],this._originalValue[b],-1,b),b++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let b=0;b<this._events.length;b++)this._events[b].isDone=!1}isStopped(){return this._stopped}dispose(){const b=this._animation.runtimeAnimations.indexOf(this);b>-1&&this._animation.runtimeAnimations.splice(b,1)}setValue(b,G){if(this._targetIsArray)for(let i=0;i<this._target.length;i++){const g=this._target[i];this._setValue(g,this._activeTargets[i],b,G,i)}else this._setValue(this._target,this._directTarget,b,G,0)}_getOriginalValues(){let b,G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const i=this._activeTargets[G];b=i.getLocalMatrix&&"_matrix"===this._targetPath?i.getLocalMatrix():i[this._targetPath],b&&b.clone?this._originalValue[G]=b.clone():this._originalValue[G]=b}_registerTargetForLateAnimationBinding(b,G){const i=b.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(i),i._lateAnimationHolders||(i._lateAnimationHolders={}),i._lateAnimationHolders[b.targetPath]||(i._lateAnimationHolders[b.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:G}),b.isAdditive?(i._lateAnimationHolders[b.targetPath].additiveAnimations.push(b),i._lateAnimationHolders[b.targetPath].totalAdditiveWeight+=b.weight):(i._lateAnimationHolders[b.targetPath].animations.push(b),i._lateAnimationHolders[b.targetPath].totalWeight+=b.weight)}_setValue(b,G,i,c,V){if(this._currentActiveTarget=G,this._weight=c,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const b=G[this._targetPath];b.clone?this._originalBlendValue=b.clone():this._originalBlendValue=b}this._originalBlendValue.m?g.b.AllowMatrixDecomposeForInterpolation?this._currentValue?Z.b.DecomposeLerpToRef(this._originalBlendValue,i,this._blendingFactor,this._currentValue):this._currentValue=Z.b.DecomposeLerp(this._originalBlendValue,i,this._blendingFactor):this._currentValue?Z.b.LerpToRef(this._originalBlendValue,i,this._blendingFactor,this._currentValue):this._currentValue=Z.b.Lerp(this._originalBlendValue,i,this._blendingFactor):this._currentValue=g.b._UniversalLerp(this._originalBlendValue,i,this._blendingFactor);const c=b&&b.animationPropertiesOverride?b.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=c}else this._currentValue?this._currentValue.p?this._currentValue.p(i):this._currentValue=i:null!==i&&void 0!==i&&i.clone?this._currentValue=i.clone():this._currentValue=i;-1!==c?this._registerTargetForLateAnimationBinding(this,this._originalValue[V]):this._animationState.loopMode===g.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[V],G[this._targetPath]):G[this._targetPath]=this._originalValue[V]+this._currentValue:G[this._targetPath]=this._currentValue,b.te&&b.te(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(b){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const i=this._animation.getKeys();b<i[0].frame?b=i[0].frame:b>i[i.length-1].frame&&(b=i[i.length-1].frame);const g=this._events;if(g.length)for(let V=0;V<g.length;V++)g[V].onlyOnce||(g[V].isDone=g[V].frame<b);this._currentFrame=b;const c=this._animation._interpolate(b,this._animationState);this.setValue(c,G)}_prepareForSpeedRatioChange(b){const G=this._previousElapsedTime*(this._animation.framePerSecond*b)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-G}animate(b,G,i,c,V){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const E=this._animation,Z=E.targetPropertyPath;if(!Z||Z.length<1)return this._stopped=!0,!1;let Y=!0;(G<this._minFrame||G>this._maxFrame)&&(G=this._minFrame),(i<this._minFrame||i>this._maxFrame)&&(i=this._maxFrame);const J=i-G;let q,o=b*(E.framePerSecond*V)/1e3+this._absoluteFrameOffset,s=0,F=!1;const l=c&&this._animationState.loopMode===g.b.ANIMATIONLOOPMODE_YOYO;if(l){const b=(o-G)/J,i=Math.sin(b*Math.PI);o=Math.abs(i)*J+G;const g=i>=0?1:-1;this._yoyoDirection!==g&&(F=!0),this._yoyoDirection=g}if(this._previousElapsedTime=b,this._previousAbsoluteFrame=o,!c&&i>=G&&(o>=J&&V>0||o<=0&&V<0))Y=!1,s=E._getKeyValue(this._maxValue);else if(!c&&G>=i&&(o<=J&&V<0||o>=0&&V>0))Y=!1,s=E._getKeyValue(this._minValue);else if(this._animationState.loopMode!==g.b.ANIMATIONLOOPMODE_CYCLE){const b=i.toString()+G.toString();if(!this._offsetsCache[b]){this._animationState.repeatCount=0,this._animationState.loopMode=g.b.ANIMATIONLOOPMODE_CYCLE;const c=E._interpolate(G,this._animationState),V=E._interpolate(i,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),E.dataType){case g.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[b]=V-c;break;case g.b.ANIMATIONTYPE_QUATERNION:case g.b.ANIMATIONTYPE_VECTOR3:case g.b.ANIMATIONTYPE_VECTOR2:case g.b.ANIMATIONTYPE_SIZE:case g.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[b]=V.ad(c)}this._highLimitsCache[b]=V}s=this._highLimitsCache[b],q=this._offsetsCache[b]}if(void 0===q)switch(E.dataType){case g.b.ANIMATIONTYPE_FLOAT:q=0;break;case g.b.ANIMATIONTYPE_QUATERNION:q=g.h;break;case g.b.ANIMATIONTYPE_VECTOR3:q=g.r;break;case g.b.ANIMATIONTYPE_VECTOR2:q=g.p;break;case g.b.ANIMATIONTYPE_SIZE:q=g.l;break;case g.b.ANIMATIONTYPE_COLOR3:q=g.d;break;case g.b.ANIMATIONTYPE_COLOR4:q=g.e}let v;if(this._host&&this._host.syncRoot){const b=this._host.syncRoot;v=G+J*((b.masterFrame-b.fromFrame)/(b.toFrame-b.fromFrame))}else v=o>0&&G>i||o<0&&G<i?Y&&0!==J?i+o%J:G:Y&&0!==J?G+o%J:i;const u=this._events;if(!l&&(V>0&&this.currentFrame>v||V<0&&this.currentFrame<v)||l&&F){this._onLoop();for(let b=0;b<u.length;b++)u[b].onlyOnce||(u[b].isDone=!1);this._animationState.key=V>0?0:E.getKeys().length-1}this._currentFrame=v,this._animationState.repeatCount=0===J?0:o/J|0,this._animationState.highLimitValue=s,this._animationState.offsetValue=q;const W=E._interpolate(v,this._animationState);if(this.setValue(W,z),u.length)for(let g=0;g<u.length;g++)if(J>=0&&v>=u[g].frame&&u[g].frame>=G||J<0&&v<=u[g].frame&&u[g].frame<=G){const b=u[g];b.isDone||(b.onlyOnce&&(u.splice(g,1),g--),b.isDone=!0,b.action(v))}return Y||(this._stopped=!0),Y}}var J=i(1149);class q{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(b){this._weight=-1!==b?Math.min(Math.max(b,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(b){for(let G=0;G<this._runtimeAnimations.length;G++){this._runtimeAnimations[G]._prepareForSpeedRatioChange(b)}this._speedRatio=b,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(b,G){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,V=arguments.length>4&&void 0!==arguments[4]&&arguments[4],z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,E=arguments.length>6?arguments[6]:void 0,Z=arguments.length>7?arguments[7]:void 0,Y=arguments.length>8?arguments[8]:void 0,J=arguments.length>9&&void 0!==arguments[9]&&arguments[9],q=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=G,this.fromFrame=i,this.toFrame=g,this.loopAnimation=V,this.onAnimationEnd=E,this.onAnimationLoop=Y,this.isAdditive=J,this.playOrder=q,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Md=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new c.c,this.onAnimationLoopObservable=new c.c,this._scene=b,Z&&this.appendAnimations(G,Z),this._speedRatio=z,b._activeAnimatables.push(this)}syncWith(b){if(this._syncRoot=b,b){const b=this._scene._activeAnimatables.indexOf(this);b>-1&&(this._scene._activeAnimatables.splice(b,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(b,G){for(let i=0;i<G.length;i++){const g=G[i],c=new Y(b,g,this._scene,this);c._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(c)}}getAnimationByTargetProperty(b){const G=this._runtimeAnimations;for(let i=0;i<G.length;i++)if(G[i].animation.targetProperty===b)return G[i].animation;return null}getRuntimeAnimationByTargetProperty(b){const G=this._runtimeAnimations;for(let i=0;i<G.length;i++)if(G[i].animation.targetProperty===b)return G[i];return null}reset(){const b=this._runtimeAnimations;for(let G=0;G<b.length;G++)b[G].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(b){const G=this._runtimeAnimations;for(let i=0;i<G.length;i++)G[i].animation.enableBlending=!0,G[i].animation.blendingSpeed=b}disableBlending(){const b=this._runtimeAnimations;for(let G=0;G<b.length;G++)b[G].animation.enableBlending=!1}goToFrame(b){const G=this._runtimeAnimations;if(G[0]){const i=G[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??G[0].currentFrame;const g=0===this.speedRatio?0:(b-this._frameToSyncFromJump)/i*1e3/this.speedRatio;this._manualJumpDelay=-g}for(let i=0;i<G.length;i++)G[i].goToFrame(b,this._weight);this._goToFrame=b}get paused(){return this.Md}pause(){this.Md||(this.Md=!0)}restart(){this.Md=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(b,G){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],g=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(b||G){const c=this._scene._activeAnimatables.indexOf(this);if(c>-1){const V=this._runtimeAnimations;for(let i=V.length-1;i>=0;i--){const g=V[i];b&&g.animation.name!=b||(G&&!G(g.target)||(g.dispose(),V.splice(i,1)))}0==V.length&&(i||this._scene._activeAnimatables.splice(c,1),g||this._raiseOnAnimationEnd())}}else{const b=this._scene._activeAnimatables.indexOf(this);if(b>-1){i||this._scene._activeAnimatables.splice(b,1);const G=this._runtimeAnimations;for(let b=0;b<G.length;b++)G[b].dispose();this._runtimeAnimations.length=0,g||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((b=>{this.onAnimationEndObservable.add((()=>{b(this)}),void 0,void 0,this,!0)}))}_animate(b){if(this.Md)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=b),!0;if(null===this._localDelayOffset?(this._localDelayOffset=b,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=b-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let G=!1;const i=this._runtimeAnimations;let g;for(g=0;g<i.length;g++){const c=i[g].animate(b-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);G=G||c}if(this.animationStarted=G,!G){if(this.disposeOnEnd)for(g=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(g,1),g=0;g<i.length;g++)i[g].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return G}}function o(b){if(0===b.totalWeight&&0===b.totalAdditiveWeight)return b.originalValue;let G=1;const i=Z.g.Td[0],g=Z.g.Td[1],c=Z.g.Quaternion[0];let V=0;const z=b.animations[0],E=b.originalValue;let Y=1,J=!1;if(b.totalWeight<1)Y=1-b.totalWeight,E.decompose(g,c,i);else{if(V=1,G=b.totalWeight,Y=z.weight/G,1==Y){if(!b.totalAdditiveWeight)return z.currentValue;J=!0}z.currentValue.decompose(g,c,i)}if(!J){g.scaleInPlace(Y),i.scaleInPlace(Y),c.scaleInPlace(Y);for(let z=V;z<b.animations.length;z++){const V=b.animations[z];if(0===V.weight)continue;Y=V.weight/G;const E=Z.g.Td[2],J=Z.g.Td[3],q=Z.g.Quaternion[1];V.currentValue.decompose(J,q,E),J.scaleAndAddToRef(Y,g),q.scaleAndAddToRef(Z.d.Dot(c,q)>0?Y:-Y,c),E.scaleAndAddToRef(Y,i)}c.normalize()}for(let o=0;o<b.additiveAnimations.length;o++){const G=b.additiveAnimations[o];if(0===G.weight)continue;const V=Z.g.Td[2],z=Z.g.Td[3],E=Z.g.Quaternion[1];G.currentValue.decompose(z,E,V),z.multiplyToRef(g,z),Z.l.LerpToRef(g,z,G.weight,g),c.multiplyToRef(E,E),Z.d.SlerpToRef(c,E,G.weight,c),V.scaleAndAddToRef(G.weight,i)}const q=z?z._animationState.workValue:Z.g.Matrix[0].clone();return Z.b.ComposeToRef(g,c,i,q),q}function s(b,G){if(0===b.totalWeight&&0===b.totalAdditiveWeight)return G;const i=b.animations[0],g=b.originalValue;let c=G;if(0===b.totalWeight&&b.totalAdditiveWeight>0)c.p(g);else if(1===b.animations.length){if(Z.d.SlerpToRef(g,i.currentValue,Math.min(1,b.totalWeight),c),0===b.totalAdditiveWeight)return c}else if(b.animations.length>1){let i,V,z=1;if(b.totalWeight<1){const G=1-b.totalWeight;i=[],V=[],i.push(g),V.push(G)}else{if(2===b.animations.length&&(Z.d.SlerpToRef(b.animations[0].currentValue,b.animations[1].currentValue,b.animations[1].weight/b.totalWeight,G),0===b.totalAdditiveWeight))return G;i=[],V=[],z=b.totalWeight}for(let G=0;G<b.animations.length;G++){const g=b.animations[G];i.push(g.currentValue),V.push(g.weight/z)}let E=0;for(let b=0;b<i.length;)b?(E+=V[b],Z.d.SlerpToRef(c,i[b],V[b]/E,c),b++):(Z.d.SlerpToRef(i[b],i[b+1],V[b+1]/(V[b]+V[b+1]),G),c=G,E=V[b]+V[b+1],b+=2)}for(let V=0;V<b.additiveAnimations.length;V++){const G=b.additiveAnimations[V];0!==G.weight&&(c.multiplyToRef(G.currentValue,Z.g.Quaternion[0]),Z.d.SlerpToRef(c,Z.g.Quaternion[0],G.weight,c))}return c}var F,l,v=i(1219);F=v.d,(l=E.e)&&(l.prototype.copyAnimationRange=function(b,G,i){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3],V=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new g.b(this.name,"_matrix",b.animations[0].framePerSecond,g.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const z=b.animations[0].getRange(G);if(!z)return!1;const E=z.from,Z=z.to,Y=b.animations[0].getKeys(),J=b.length,q=b.getParent(),o=this.getParent(),s=c&&q&&J&&this.length&&J!==this.length,F=s&&o&&q?o.length/q.length:1,l=c&&!o&&V&&(1!==V.x||1!==V.y||1!==V.z),v=this.animations[0].getKeys();let u,W,x;for(let g=0,M=Y.length;g<M;g++)u=Y[g],u.frame>=E&&u.frame<=Z&&(c?(x=u.value.clone(),s?(W=x.getTranslation(),x.setTranslation(W.scaleInPlace(F))):l&&V?(W=x.getTranslation(),x.setTranslation(W.multiplyInPlace(V))):x=u.value):x=u.value,v.push({frame:u.frame+i,value:x}));return this.animations[0].createRange(G,E+i,Z+i),!0}),F&&(F.prototype._animate=function(b){if(!this.animationsEnabled)return;const G=J.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=G}this.deltaTime=void 0!==b?b:this.useConstantAnimationDeltaTime?16:(G-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=G;const i=this._activeAnimatables;if(0===i.length)return;this._animationTime+=this.deltaTime;const c=this._animationTime;for(let g=0;g<i.length;g++){const b=i[g];!b._animate(c)&&b.disposeOnEnd&&g--}!function(b){if(b._registeredForLateAnimationBindings.length){for(let G=0;G<b._registeredForLateAnimationBindings.length;G++){const i=b._registeredForLateAnimationBindings.data[G];for(const b in i._lateAnimationHolders){const G=i._lateAnimationHolders[b],c=G.animations[0],V=G.originalValue;if(void 0===V||null===V)continue;const z=g.b.AllowMatrixDecomposeForInterpolation&&V.m;let E=i[b];if(z)E=o(G);else if(void 0!==V.w)E=s(G,E||Z.d.Identity());else{let b=0,i=1;const z=c&&c._animationState.loopMode===g.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(G.totalWeight<1)E=z?V.clone?V.clone():V:c&&V.scale?V.scale(1-G.totalWeight):c?V*(1-G.totalWeight):V.clone?V.clone():V;else if(c){i=G.totalWeight;const g=c.weight/i;E=1!==g?c.currentValue.scale?c.currentValue.scale(g):c.currentValue*g:c.currentValue,z&&(E.addToRef?E.addToRef(V,E):E+=V),b=1}for(let g=b;g<G.animations.length;g++){const b=G.animations[g],c=b.weight/i;c&&(b.currentValue.scaleAndAddToRef?b.currentValue.scaleAndAddToRef(c,E):E+=b.currentValue*c)}for(let g=0;g<G.additiveAnimations.length;g++){const b=G.additiveAnimations[g],i=b.weight;i&&(b.currentValue.scaleAndAddToRef?b.currentValue.scaleAndAddToRef(i,E):E+=b.currentValue*i)}}i[b]=E}i._lateAnimationHolders={}}b._registeredForLateAnimationBindings.reset()}}(this)},F.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((b,G)=>b.playOrder-G.playOrder))},F.prototype.beginWeightedAnimation=function(b,G,i){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,c=arguments.length>4?arguments[4]:void 0,V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,z=arguments.length>6?arguments[6]:void 0,E=arguments.length>7?arguments[7]:void 0,Z=arguments.length>8?arguments[8]:void 0,Y=arguments.length>9?arguments[9]:void 0,J=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const q=this.beginAnimation(b,G,i,c,V,z,E,!1,Z,Y,J);return q.weight=g,q},F.prototype.beginAnimation=function(b,G,i,g){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,V=arguments.length>5?arguments[5]:void 0,z=arguments.length>6?arguments[6]:void 0,E=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],Z=arguments.length>8?arguments[8]:void 0,Y=arguments.length>9?arguments[9]:void 0,J=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(c<0){const b=G;G=i,i=b,c=-c}G>i&&(c=-c),E&&this.stopAnimation(b,void 0,Z),z||(z=new q(this,b,G,i,g,c,V,void 0,Y,J));const o=!Z||Z(b);if(b.animations&&o&&z.appendAnimations(b,b.animations),b.getAnimatables){const J=b.getAnimatables();for(let b=0;b<J.length;b++)this.beginAnimation(J[b],G,i,g,c,V,z,E,Z,Y)}return z.reset(),z},F.prototype.beginHierarchyAnimation=function(b,G,i,g,c){let V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,z=arguments.length>6?arguments[6]:void 0,E=arguments.length>7?arguments[7]:void 0,Z=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],Y=arguments.length>9?arguments[9]:void 0,J=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const q=b.getDescendants(G),o=[];o.push(this.beginAnimation(b,i,g,c,V,z,E,Z,Y,void 0,J));for(const s of q)o.push(this.beginAnimation(s,i,g,c,V,z,E,Z,Y,void 0,J));return o},F.prototype.beginDirectAnimation=function(b,G,i,g,c){let V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(V<0){const b=i;i=g,g=b,V=-V}return i>g&&(V=-V),new q(this,b,i,g,c,V,arguments.length>6?arguments[6]:void 0,G,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},F.prototype.beginDirectHierarchyAnimation=function(b,G,i,g,c,V,z,E,Z){let Y=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const J=b.getDescendants(G),q=[];q.push(this.beginDirectAnimation(b,i,g,c,V,z,E,Z,Y));for(const o of J)q.push(this.beginDirectAnimation(o,i,g,c,V,z,E,Z,Y));return q},F.prototype.getAnimatableByTarget=function(b){for(let G=0;G<this._activeAnimatables.length;G++)if(this._activeAnimatables[G].target===b)return this._activeAnimatables[G];return null},F.prototype.getAllAnimatablesByTarget=function(b){const G=[];for(let i=0;i<this._activeAnimatables.length;i++)this._activeAnimatables[i].target===b&&G.push(this._activeAnimatables[i]);return G},F.prototype.stopAnimation=function(b,G,i){const g=this.getAllAnimatablesByTarget(b);for(const c of g)c.stop(G,i)},F.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let b=0;b<this._activeAnimatables.length;b++)this._activeAnimatables[b].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const b of this.animationGroups)b.stop()});class u{getClassName(){return"TargetedAnimation"}serialize(){const b={};return b.animation=this.animation.serialize(),b.targetId=this.target.id,b}}class W{get mask(){return this._mask}set mask(b){this._mask!==b&&(this._mask=b,this.syncWithMask(!0))}syncWithMask(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||b){this._numActiveAnimatables=0;for(let b=0;b<this._animatables.length;++b){const G=this._animatables[b];!this.mask||this.mask.disabled||this.mask.retainsTarget(G.target.name)?(this._numActiveAnimatables++,G.paused&&G.restart()):G.paused||G.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let b=0;b<this._animatables.length;++b){const G=this._animatables[b];this.mask.retainsTarget(G.target.name)||(G.stop(),this._animatables.splice(b,1),--b)}for(let b=0;b<this._targetedAnimations.length;b++){const G=this._targetedAnimations[b];this.mask.retainsTarget(G.target.name)||(this._targetedAnimations.splice(b,1),--b)}}}get from(){return this._from}set from(b){if(this._from!==b){this._from=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].fromFrame=this._from}}}get to(){return this._to}set to(b){if(this._to!==b){this._to=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(b){if(this._speedRatio!==b){this._speedRatio=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(b){if(this._loopAnimation!==b){this._loopAnimation=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(b){if(this._isAdditive!==b){this._isAdditive=b;for(let b=0;b<this._animatables.length;b++){this._animatables[b].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(b){this._weight!==b&&(this._weight=b,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(b){if(this._playOrder!==b&&(this._playOrder=b,this._animatables.length>0)){for(let b=0;b<this._animatables.length;b++)this._animatables[b].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(b){if(this._enableBlending!==b&&(this._enableBlending=b,null!==b))for(let G=0;G<this._targetedAnimations.length;++G)this._targetedAnimations[G].animation.enableBlending=b}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(b){if(this._blendingSpeed!==b&&(this._blendingSpeed=b,null!==b))for(let G=0;G<this._targetedAnimations.length;++G)this._targetedAnimations[G].animation.blendingSpeed=b}getLength(b,G){b=b??this._from;return((G=G??this._to)-b)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(b){let G=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],g=arguments.length>3?arguments[3]:void 0;if(0===b.length)return null;g=g??b[0].weight;let c=Number.MAX_VALUE,V=-Number.MAX_VALUE;if(i)for(const E of b)E.from<c&&(c=E.from),E.to>V&&(V=E.to);const z=new W(b[0].name+"_merged",b[0]._scene,g);for(const E of b){i&&E.normalize(c,V);for(const b of E.targetedAnimations)z.addTargetedAnimation(b.animation,b.target);G&&E.dispose()}return z}constructor(b){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=b,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new c.c,this.onAnimationLoopObservable=new c.c,this.onAnimationGroupLoopObservable=new c.c,this.onAnimationGroupEndObservable=new c.c,this.onAnimationGroupPauseObservable=new c.c,this.onAnimationGroupPlayObservable=new c.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=G||V.c.LastCreatedScene,this._weight=i,this._playOrder=g,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(b,G){const i=new u;i.animation=b,i.target=G;const g=b.getKeys();return this._from>g[0].frame&&(this._from=g[0].frame),this._to<g[g.length-1].frame&&(this._to=g[g.length-1].frame),null!==this._enableBlending&&(b.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(b.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(i),this._shouldStart=!0,i}removeTargetedAnimation(b){for(let G=this._targetedAnimations.length-1;G>-1;G--){this._targetedAnimations[G].animation===b&&this._targetedAnimations.splice(G,1)}}normalize(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==b&&(b=this._from),null==G&&(G=this._to);for(let i=0;i<this._targetedAnimations.length;i++){const g=this._targetedAnimations[i].animation.getKeys(),c=g[0],V=g[g.length-1];if(c.frame>b){const G={frame:b,value:c.value,inTangent:c.inTangent,outTangent:c.outTangent,interpolation:c.interpolation};g.splice(0,0,G)}if(V.frame<G){const b={frame:G,value:V.value,inTangent:V.inTangent,outTangent:V.outTangent,interpolation:V.interpolation};g.push(b)}}return this._from=b,this._to=G,this}_processLoop(b,G,i){b.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(G),this._animationLoopFlags[i]||(this._animationLoopFlags[i]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0],G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0,g=arguments.length>3?arguments[3]:void 0,c=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=b,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let V=0;V<this._targetedAnimations.length;V++){const z=this._targetedAnimations[V],E=this._scene.beginDirectAnimation(z.target,[z.animation],void 0!==i?i:this._from,void 0!==g?g:this._to,b,G,void 0,void 0,void 0!==c?c:this._isAdditive);E.weight=this._weight,E.playOrder=this._playOrder,E.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(z),this._checkAnimationGroupEnded(E)},this._processLoop(E,z,V),this._animatables.push(E)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=G,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let b=0;b<this._animatables.length;b++){this._animatables[b].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(b){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==b&&(this.loopAnimation=b),this.restart()):(this.stop(),this.start(b,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].reset()}return this}restart(){if(!this._isStarted)return this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const G=this._animatables.slice();for(let g=0;g<G.length;g++)G[g].stop(void 0,void 0,!0,b);let i=0;for(let g=0;g<this._scene._activeAnimatables.length;g++){const G=this._scene._activeAnimatables[g];G._runtimeAnimations.length>0?this._scene._activeAnimatables[i++]=G:b&&this._checkAnimationGroupEnded(G,b)}return this._scene._activeAnimatables.length=i,this._isStarted=!1,this}setWeightForAllAnimatables(b){for(let G=0;G<this._animatables.length;G++){this._animatables[G].weight=b}return this}syncAllAnimationsWith(b){for(let G=0;G<this._animatables.length;G++){this._animatables[G].syncWith(b)}return this}goToFrame(b){if(!this._isStarted)return this;for(let G=0;G<this._animatables.length;G++){this._animatables[G].goToFrame(b)}return this}getCurrentFrame(){var b;return(null===(b=this.animatables[0])||void 0===b?void 0:b.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const b=this._scene.animationGroups.indexOf(this);if(b>-1&&this._scene.animationGroups.splice(b,1),this._parentContainer){const b=this._parentContainer.animationGroups.indexOf(this);b>-1&&this._parentContainer.animationGroups.splice(b,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(b){let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const i=this._animatables.indexOf(b);i>-1&&this._animatables.splice(i,1),0===this._animatables.length&&(this._isStarted=!1,G||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(b,G){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const g=new W(b||this.name,this._scene,this._weight,this._playOrder);g._from=this.from,g._to=this.to,g._speedRatio=this.speedRatio,g._loopAnimation=this.loopAnimation,g._isAdditive=this.isAdditive,g._enableBlending=this.enableBlending,g._blendingSpeed=this.blendingSpeed,g.metadata=this.metadata,g.mask=this.mask;for(const c of this._targetedAnimations)g.addTargetedAnimation(i?c.animation.clone():c.animation,G?G(c.target):c.target);return g}serialize(){const b={};b.name=this.name,b.from=this.from,b.to=this.to,b.speedRatio=this.speedRatio,b.loopAnimation=this.loopAnimation,b.isAdditive=this.isAdditive,b.weight=this.weight,b.playOrder=this.playOrder,b.enableBlending=this.enableBlending,b.blendingSpeed=this.blendingSpeed,b.targetedAnimations=[];for(let G=0;G<this.targetedAnimations.length;G++){const i=this.targetedAnimations[G];b.targetedAnimations[G]=i.serialize()}return z.b&&z.b.HasTags(this)&&(b.tags=z.b.GetTags(this)),this.metadata&&(b.metadata=this.metadata),b}static Parse(b,G){const i=new W(b.name,G,b.weight,b.playOrder);for(let c=0;c<b.targetedAnimations.length;c++){const V=b.targetedAnimations[c],z=g.b.Parse(V.animation),E=V.targetId;if("influence"===V.animation.property){const b=G.getMorphTargetById(E);b&&i.addTargetedAnimation(z,b)}else{const b=G.getNodeById(E);null!=b&&i.addTargetedAnimation(z,b)}}return z.b&&z.b.AddTagsTo(i,b.tags),null!==b.from&&null!==b.to&&i.normalize(b.from,b.to),void 0!==b.speedRatio&&(i._speedRatio=b.speedRatio),void 0!==b.loopAnimation&&(i._loopAnimation=b.loopAnimation),void 0!==b.isAdditive&&(i._isAdditive=b.isAdditive),void 0!==b.weight&&(i._weight=b.weight),void 0!==b.playOrder&&(i._playOrder=b.playOrder),void 0!==b.enableBlending&&(i._enableBlending=b.enableBlending),void 0!==b.blendingSpeed&&(i._blendingSpeed=b.blendingSpeed),void 0!==b.metadata&&(i.metadata=b.metadata),i}static MakeAnimationAdditive(b,G,i){let c;c="object"===typeof G?G:{referenceFrame:G,range:i,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let V=b;c.cloneOriginalAnimationGroup&&(V=b.clone(c.clonedAnimationGroupName||V.name));const z=V.targetedAnimations;for(let E=0;E<z.length;E++){const b=z[E];b.animation=g.b.MakeAnimationAdditive(b.animation,c)}if(V.isAdditive=!0,c.clipKeys){let b=Number.MAX_VALUE,G=-Number.MAX_VALUE;const i=V.targetedAnimations;for(let g=0;g<i.length;g++){const c=i[g].animation.getKeys();b>c[0].frame&&(b=c[0].frame),G<c[c.length-1].frame&&(G=c[c.length-1].frame)}V._from=b,V._to=G}return V}static ClipKeys(b,G,i,g,c){const V=b.clone(g||b.name);return W.ClipKeysInPlace(V,G,i,c)}static ClipKeysInPlace(b,G,i,g){return W.ClipInPlace(b,G,i,g,!1)}static ClipFrames(b,G,i,g,c){const V=b.clone(g||b.name);return W.ClipFramesInPlace(V,G,i,c)}static ClipFramesInPlace(b,G,i,g){return W.ClipInPlace(b,G,i,g,!0)}static ClipInPlace(b,G,i,g){let c=arguments.length>4&&void 0!==arguments[4]&&arguments[4],V=Number.MAX_VALUE,z=-Number.MAX_VALUE;const E=b.targetedAnimations;for(let Z=0;Z<E.length;Z++){const b=E[Z],Y=g?b.animation:b.animation.clone();c&&(Y.createKeyForFrame(G),Y.createKeyForFrame(i));const J=Y.getKeys(),q=[];let o=Number.MAX_VALUE;for(let g=0;g<J.length;g++){const b=J[g];if(!c&&g>=G&&g<=i||c&&b.frame>=G&&b.frame<=i){const G={frame:b.frame,value:b.value.clone?b.value.clone():b.value,inTangent:b.inTangent,outTangent:b.outTangent,interpolation:b.interpolation,lockedTangent:b.lockedTangent};o===Number.MAX_VALUE&&(o=G.frame),G.frame-=o,q.push(G)}}0!==q.length?(V>q[0].frame&&(V=q[0].frame),z<q[q.length-1].frame&&(z=q[q.length-1].frame),Y.setKeys(q,!0),b.animation=Y):(E.splice(Z,1),Z--)}return b._from=V,b._to=z,b}getClassName(){return"AnimationGroup"}toString(b){let G="Name: "+this.name;return G+=", type: "+this.getClassName(),b&&(G+=", from: "+this._from,G+=", to: "+this._to,G+=", isStarted: "+this._isStarted,G+=", speedRatio: "+this._speedRatio,G+=", targetedAnimations length: "+this._targetedAnimations.length,G+=", animatables length: "+this._animatables),G}}}}]);