"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12536:(q,X,Q)=>{Q.r(X),Q.d(X,{AnimationGroup:()=>i,TargetedAnimation:()=>e});var y=Q(11882),x=Q(998),u=Q(1028),H=Q(1175),b=Q(11877),D=Q(1002);class a{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(q,X,Q,x){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=X,this._target=q,this._scene=Q,this._host=x,this._activeTargets=[],X._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===y.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=D.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const q={frame:0,value:this._minValue};this._keys.splice(0,0,q)}if(this._target instanceof Array){let q=0;for(const X of this._target)this._preparePath(X,q),this._getOriginalValues(q),q++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const u=X.getEvents();u&&u.length>0&&u.forEach((q=>{this._events.push(q._clone())})),this._enableBlending=q&&q.animationPropertiesOverride?q.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(q){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Q=this._animation.targetPropertyPath;if(Q.length>1){let y=q;for(let q=0;q<Q.length-1;q++){const X=Q[q];if(y=y[X],void 0===y)throw new Error(`Invalid property (${X}) in property path (${Q.join(".")})`)}this._targetPath=Q[Q.length-1],this._activeTargets[X]=y}else this._targetPath=Q[0],this._activeTargets[X]=q;if(void 0===this._activeTargets[X][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${Q.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let q=0;for(const X of this._target)void 0!==this._originalValue[q]&&this._setValue(X,this._activeTargets[q],this._originalValue[q],-1,q),q++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let q=0;q<this._events.length;q++)this._events[q].isDone=!1}isStopped(){return this._stopped}dispose(){const q=this._animation.runtimeAnimations.indexOf(this);q>-1&&this._animation.runtimeAnimations.splice(q,1)}setValue(q,X){if(this._targetIsArray)for(let Q=0;Q<this._target.length;Q++){const y=this._target[Q];this._setValue(y,this._activeTargets[Q],q,X,Q)}else this._setValue(this._target,this._directTarget,q,X,0)}_getOriginalValues(){let q,X=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Q=this._activeTargets[X];q=Q.getLocalMatrix&&"_matrix"===this._targetPath?Q.getLocalMatrix():Q[this._targetPath],q&&q.clone?this._originalValue[X]=q.clone():this._originalValue[X]=q}_registerTargetForLateAnimationBinding(q,X){const Q=q.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(Q),Q._lateAnimationHolders||(Q._lateAnimationHolders={}),Q._lateAnimationHolders[q.targetPath]||(Q._lateAnimationHolders[q.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:X}),q.isAdditive?(Q._lateAnimationHolders[q.targetPath].additiveAnimations.push(q),Q._lateAnimationHolders[q.targetPath].totalAdditiveWeight+=q.weight):(Q._lateAnimationHolders[q.targetPath].animations.push(q),Q._lateAnimationHolders[q.targetPath].totalWeight+=q.weight)}_setValue(q,X,Q,x,u){if(this._currentActiveTarget=X,this._weight=x,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const q=X[this._targetPath];q.clone?this._originalBlendValue=q.clone():this._originalBlendValue=q}this._originalBlendValue.m?y.e.AllowMatrixDecomposeForInterpolation?this._currentValue?D.b.DecomposeLerpToRef(this._originalBlendValue,Q,this._blendingFactor,this._currentValue):this._currentValue=D.b.DecomposeLerp(this._originalBlendValue,Q,this._blendingFactor):this._currentValue?D.b.LerpToRef(this._originalBlendValue,Q,this._blendingFactor,this._currentValue):this._currentValue=D.b.Lerp(this._originalBlendValue,Q,this._blendingFactor):this._currentValue=y.e._UniversalLerp(this._originalBlendValue,Q,this._blendingFactor);const x=q&&q.animationPropertiesOverride?q.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=x}else this._currentValue?this._currentValue.p?this._currentValue.p(Q):this._currentValue=Q:null!==Q&&void 0!==Q&&Q.clone?this._currentValue=Q.clone():this._currentValue=Q;-1!==x?this._registerTargetForLateAnimationBinding(this,this._originalValue[u]):this._animationState.loopMode===y.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[u],X[this._targetPath]):X[this._targetPath]=this._originalValue[u]+this._currentValue:X[this._targetPath]=this._currentValue,q.te&&q.te(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(q){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const Q=this._animation.getKeys();q<Q[0].frame?q=Q[0].frame:q>Q[Q.length-1].frame&&(q=Q[Q.length-1].frame);const y=this._events;if(y.length)for(let u=0;u<y.length;u++)y[u].onlyOnce||(y[u].isDone=y[u].frame<q);this._currentFrame=q;const x=this._animation._interpolate(q,this._animationState);this.setValue(x,X)}_prepareForSpeedRatioChange(q){const X=this._previousElapsedTime*(this._animation.framePerSecond*q)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-X}animate(q,X,Q,x,u){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const b=this._animation,D=b.targetPropertyPath;if(!D||D.length<1)return this._stopped=!0,!1;let a=!0;(X<this._minFrame||X>this._maxFrame)&&(X=this._minFrame),(Q<this._minFrame||Q>this._maxFrame)&&(Q=this._maxFrame);const R=Q-X;let L,f=q*(b.framePerSecond*u)/1e3+this._absoluteFrameOffset,k=0,j=!1;const I=x&&this._animationState.loopMode===y.e.ANIMATIONLOOPMODE_YOYO;if(I){const q=(f-X)/R,Q=Math.sin(q*Math.PI);f=Math.abs(Q)*R+X;const y=Q>=0?1:-1;this._yoyoDirection!==y&&(j=!0),this._yoyoDirection=y}if(this._previousElapsedTime=q,this._previousAbsoluteFrame=f,!x&&Q>=X&&(f>=R&&u>0||f<=0&&u<0))a=!1,k=b._getKeyValue(this._maxValue);else if(!x&&X>=Q&&(f<=R&&u<0||f>=0&&u>0))a=!1,k=b._getKeyValue(this._minValue);else if(this._animationState.loopMode!==y.e.ANIMATIONLOOPMODE_CYCLE){const q=Q.toString()+X.toString();if(!this._offsetsCache[q]){this._animationState.repeatCount=0,this._animationState.loopMode=y.e.ANIMATIONLOOPMODE_CYCLE;const x=b._interpolate(X,this._animationState),u=b._interpolate(Q,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),b.dataType){case y.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[q]=u-x;break;case y.e.ANIMATIONTYPE_QUATERNION:case y.e.ANIMATIONTYPE_VECTOR3:case y.e.ANIMATIONTYPE_VECTOR2:case y.e.ANIMATIONTYPE_SIZE:case y.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[q]=u.Sc(x)}this._highLimitsCache[q]=u}k=this._highLimitsCache[q],L=this._offsetsCache[q]}if(void 0===L)switch(b.dataType){case y.e.ANIMATIONTYPE_FLOAT:L=0;break;case y.e.ANIMATIONTYPE_QUATERNION:L=y.i;break;case y.e.ANIMATIONTYPE_VECTOR3:L=y.r;break;case y.e.ANIMATIONTYPE_VECTOR2:L=y.n;break;case y.e.ANIMATIONTYPE_SIZE:L=y.k;break;case y.e.ANIMATIONTYPE_COLOR3:L=y.g;break;case y.e.ANIMATIONTYPE_COLOR4:L=y.h}let d;if(this._host&&this._host.syncRoot){const q=this._host.syncRoot;d=X+R*((q.masterFrame-q.fromFrame)/(q.toFrame-q.fromFrame))}else d=f>0&&X>Q||f<0&&X<Q?a&&0!==R?Q+f%R:X:a&&0!==R?X+f%R:Q;const e=this._events;if(!I&&(u>0&&this.currentFrame>d||u<0&&this.currentFrame<d)||I&&j){this._onLoop();for(let q=0;q<e.length;q++)e[q].onlyOnce||(e[q].isDone=!1);this._animationState.key=u>0?0:b.getKeys().length-1}this._currentFrame=d,this._animationState.repeatCount=0===R?0:f/R|0,this._animationState.highLimitValue=k,this._animationState.offsetValue=L;const i=b._interpolate(d,this._animationState);if(this.setValue(i,H),e.length)for(let y=0;y<e.length;y++)if(R>=0&&d>=e[y].frame&&e[y].frame>=X||R<0&&d<=e[y].frame&&e[y].frame<=X){const q=e[y];q.isDone||(q.onlyOnce&&(e.splice(y,1),y--),q.isDone=!0,q.action(d))}return a||(this._stopped=!0),a}}var R=Q(1141);class L{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(q){this._weight=-1!==q?Math.min(Math.max(q,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(q){for(let X=0;X<this._runtimeAnimations.length;X++){this._runtimeAnimations[X]._prepareForSpeedRatioChange(q)}this._speedRatio=q,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(q,X){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,u=arguments.length>4&&void 0!==arguments[4]&&arguments[4],H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,b=arguments.length>6?arguments[6]:void 0,D=arguments.length>7?arguments[7]:void 0,a=arguments.length>8?arguments[8]:void 0,R=arguments.length>9&&void 0!==arguments[9]&&arguments[9],L=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=X,this.fromFrame=Q,this.toFrame=y,this.loopAnimation=u,this.onAnimationEnd=b,this.onAnimationLoop=a,this.isAdditive=R,this.playOrder=L,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Gd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new x.c,this.onAnimationLoopObservable=new x.c,this._scene=q,D&&this.appendAnimations(X,D),this._speedRatio=H,q._activeAnimatables.push(this)}syncWith(q){if(this._syncRoot=q,q){const q=this._scene._activeAnimatables.indexOf(this);q>-1&&(this._scene._activeAnimatables.splice(q,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(q,X){for(let Q=0;Q<X.length;Q++){const y=X[Q],x=new a(q,y,this._scene,this);x._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(x)}}getAnimationByTargetProperty(q){const X=this._runtimeAnimations;for(let Q=0;Q<X.length;Q++)if(X[Q].animation.targetProperty===q)return X[Q].animation;return null}getRuntimeAnimationByTargetProperty(q){const X=this._runtimeAnimations;for(let Q=0;Q<X.length;Q++)if(X[Q].animation.targetProperty===q)return X[Q];return null}reset(){const q=this._runtimeAnimations;for(let X=0;X<q.length;X++)q[X].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(q){const X=this._runtimeAnimations;for(let Q=0;Q<X.length;Q++)X[Q].animation.enableBlending=!0,X[Q].animation.blendingSpeed=q}disableBlending(){const q=this._runtimeAnimations;for(let X=0;X<q.length;X++)q[X].animation.enableBlending=!1}goToFrame(q){const X=this._runtimeAnimations;if(X[0]){const Q=X[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??X[0].currentFrame;const y=0===this.speedRatio?0:(q-this._frameToSyncFromJump)/Q*1e3/this.speedRatio;this._manualJumpDelay=-y}for(let Q=0;Q<X.length;Q++)X[Q].goToFrame(q,this._weight);this._goToFrame=q}get paused(){return this.Gd}pause(){this.Gd||(this.Gd=!0)}restart(){this.Gd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(q,X){let Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],y=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(q||X){const x=this._scene._activeAnimatables.indexOf(this);if(x>-1){const u=this._runtimeAnimations;for(let Q=u.length-1;Q>=0;Q--){const y=u[Q];q&&y.animation.name!=q||(X&&!X(y.target)||(y.dispose(),u.splice(Q,1)))}0==u.length&&(Q||this._scene._activeAnimatables.splice(x,1),y||this._raiseOnAnimationEnd())}}else{const q=this._scene._activeAnimatables.indexOf(this);if(q>-1){Q||this._scene._activeAnimatables.splice(q,1);const X=this._runtimeAnimations;for(let q=0;q<X.length;q++)X[q].dispose();this._runtimeAnimations.length=0,y||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((q=>{this.onAnimationEndObservable.add((()=>{q(this)}),void 0,void 0,this,!0)}))}_animate(q){if(this.Gd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=q),!0;if(null===this._localDelayOffset?(this._localDelayOffset=q,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=q-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let X=!1;const Q=this._runtimeAnimations;let y;for(y=0;y<Q.length;y++){const x=Q[y].animate(q-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);X=X||x}if(this.animationStarted=X,!X){if(this.disposeOnEnd)for(y=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(y,1),y=0;y<Q.length;y++)Q[y].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return X}}function f(q){if(0===q.totalWeight&&0===q.totalAdditiveWeight)return q.originalValue;let X=1;const Q=D.h.Od[0],y=D.h.Od[1],x=D.h.Quaternion[0];let u=0;const H=q.animations[0],b=q.originalValue;let a=1,R=!1;if(q.totalWeight<1)a=1-q.totalWeight,b.decompose(y,x,Q);else{if(u=1,X=q.totalWeight,a=H.weight/X,1==a){if(!q.totalAdditiveWeight)return H.currentValue;R=!0}H.currentValue.decompose(y,x,Q)}if(!R){y.scaleInPlace(a),Q.scaleInPlace(a),x.scaleInPlace(a);for(let H=u;H<q.animations.length;H++){const u=q.animations[H];if(0===u.weight)continue;a=u.weight/X;const b=D.h.Od[2],R=D.h.Od[3],L=D.h.Quaternion[1];u.currentValue.decompose(R,L,b),R.scaleAndAddToRef(a,y),L.scaleAndAddToRef(D.d.Dot(x,L)>0?a:-a,x),b.scaleAndAddToRef(a,Q)}x.normalize()}for(let f=0;f<q.additiveAnimations.length;f++){const X=q.additiveAnimations[f];if(0===X.weight)continue;const u=D.h.Od[2],H=D.h.Od[3],b=D.h.Quaternion[1];X.currentValue.decompose(H,b,u),H.multiplyToRef(y,H),D.n.LerpToRef(y,H,X.weight,y),x.multiplyToRef(b,b),D.d.SlerpToRef(x,b,X.weight,x),u.scaleAndAddToRef(X.weight,Q)}const L=H?H._animationState.workValue:D.h.Matrix[0].clone();return D.b.ComposeToRef(y,x,Q,L),L}function k(q,X){if(0===q.totalWeight&&0===q.totalAdditiveWeight)return X;const Q=q.animations[0],y=q.originalValue;let x=X;if(0===q.totalWeight&&q.totalAdditiveWeight>0)x.p(y);else if(1===q.animations.length){if(D.d.SlerpToRef(y,Q.currentValue,Math.min(1,q.totalWeight),x),0===q.totalAdditiveWeight)return x}else if(q.animations.length>1){let Q,u,H=1;if(q.totalWeight<1){const X=1-q.totalWeight;Q=[],u=[],Q.push(y),u.push(X)}else{if(2===q.animations.length&&(D.d.SlerpToRef(q.animations[0].currentValue,q.animations[1].currentValue,q.animations[1].weight/q.totalWeight,X),0===q.totalAdditiveWeight))return X;Q=[],u=[],H=q.totalWeight}for(let X=0;X<q.animations.length;X++){const y=q.animations[X];Q.push(y.currentValue),u.push(y.weight/H)}let b=0;for(let q=0;q<Q.length;)q?(b+=u[q],D.d.SlerpToRef(x,Q[q],u[q]/b,x),q++):(D.d.SlerpToRef(Q[q],Q[q+1],u[q+1]/(u[q]+u[q+1]),X),x=X,b=u[q]+u[q+1],q+=2)}for(let u=0;u<q.additiveAnimations.length;u++){const X=q.additiveAnimations[u];0!==X.weight&&(x.multiplyToRef(X.currentValue,D.h.Quaternion[0]),D.d.SlerpToRef(x,D.h.Quaternion[0],X.weight,x))}return x}var j,I,d=Q(1206);j=d.d,(I=b.e)&&(I.prototype.copyAnimationRange=function(q,X,Q){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3],u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new y.e(this.name,"_matrix",q.animations[0].framePerSecond,y.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const H=q.animations[0].getRange(X);if(!H)return!1;const b=H.from,D=H.to,a=q.animations[0].getKeys(),R=q.length,L=q.getParent(),f=this.getParent(),k=x&&L&&R&&this.length&&R!==this.length,j=k&&f&&L?f.length/L.length:1,I=x&&!f&&u&&(1!==u.x||1!==u.y||1!==u.z),d=this.animations[0].getKeys();let e,i,A;for(let y=0,B=a.length;y<B;y++)e=a[y],e.frame>=b&&e.frame<=D&&(x?(A=e.value.clone(),k?(i=A.getTranslation(),A.setTranslation(i.scaleInPlace(j))):I&&u?(i=A.getTranslation(),A.setTranslation(i.multiplyInPlace(u))):A=e.value):A=e.value,d.push({frame:e.frame+Q,value:A}));return this.animations[0].createRange(X,b+Q,D+Q),!0}),j&&(j.prototype._animate=function(q){if(!this.animationsEnabled)return;const X=R.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=X}this.deltaTime=void 0!==q?q:this.useConstantAnimationDeltaTime?16:(X-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=X;const Q=this._activeAnimatables;if(0===Q.length)return;this._animationTime+=this.deltaTime;const x=this._animationTime;for(let y=0;y<Q.length;y++){const q=Q[y];!q._animate(x)&&q.disposeOnEnd&&y--}!function(q){if(q._registeredForLateAnimationBindings.length){for(let X=0;X<q._registeredForLateAnimationBindings.length;X++){const Q=q._registeredForLateAnimationBindings.data[X];for(const q in Q._lateAnimationHolders){const X=Q._lateAnimationHolders[q],x=X.animations[0],u=X.originalValue;if(void 0===u||null===u)continue;const H=y.e.AllowMatrixDecomposeForInterpolation&&u.m;let b=Q[q];if(H)b=f(X);else if(void 0!==u.w)b=k(X,b||D.d.Identity());else{let q=0,Q=1;const H=x&&x._animationState.loopMode===y.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(X.totalWeight<1)b=H?u.clone?u.clone():u:x&&u.scale?u.scale(1-X.totalWeight):x?u*(1-X.totalWeight):u.clone?u.clone():u;else if(x){Q=X.totalWeight;const y=x.weight/Q;b=1!==y?x.currentValue.scale?x.currentValue.scale(y):x.currentValue*y:x.currentValue,H&&(b.addToRef?b.addToRef(u,b):b+=u),q=1}for(let y=q;y<X.animations.length;y++){const q=X.animations[y],x=q.weight/Q;x&&(q.currentValue.scaleAndAddToRef?q.currentValue.scaleAndAddToRef(x,b):b+=q.currentValue*x)}for(let y=0;y<X.additiveAnimations.length;y++){const q=X.additiveAnimations[y],Q=q.weight;Q&&(q.currentValue.scaleAndAddToRef?q.currentValue.scaleAndAddToRef(Q,b):b+=q.currentValue*Q)}}Q[q]=b}Q._lateAnimationHolders={}}q._registeredForLateAnimationBindings.reset()}}(this)},j.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((q,X)=>q.playOrder-X.playOrder))},j.prototype.beginWeightedAnimation=function(q,X,Q){let y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,x=arguments.length>4?arguments[4]:void 0,u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,H=arguments.length>6?arguments[6]:void 0,b=arguments.length>7?arguments[7]:void 0,D=arguments.length>8?arguments[8]:void 0,a=arguments.length>9?arguments[9]:void 0,R=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const L=this.beginAnimation(q,X,Q,x,u,H,b,!1,D,a,R);return L.weight=y,L},j.prototype.beginAnimation=function(q,X,Q,y){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,u=arguments.length>5?arguments[5]:void 0,H=arguments.length>6?arguments[6]:void 0,b=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],D=arguments.length>8?arguments[8]:void 0,a=arguments.length>9?arguments[9]:void 0,R=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(x<0){const q=X;X=Q,Q=q,x=-x}X>Q&&(x=-x),b&&this.stopAnimation(q,void 0,D),H||(H=new L(this,q,X,Q,y,x,u,void 0,a,R));const f=!D||D(q);if(q.animations&&f&&H.appendAnimations(q,q.animations),q.getAnimatables){const R=q.getAnimatables();for(let q=0;q<R.length;q++)this.beginAnimation(R[q],X,Q,y,x,u,H,b,D,a)}return H.reset(),H},j.prototype.beginHierarchyAnimation=function(q,X,Q,y,x){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,H=arguments.length>6?arguments[6]:void 0,b=arguments.length>7?arguments[7]:void 0,D=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],a=arguments.length>9?arguments[9]:void 0,R=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const L=q.getDescendants(X),f=[];f.push(this.beginAnimation(q,Q,y,x,u,H,b,D,a,void 0,R));for(const k of L)f.push(this.beginAnimation(k,Q,y,x,u,H,b,D,a,void 0,R));return f},j.prototype.beginDirectAnimation=function(q,X,Q,y,x){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(u<0){const q=Q;Q=y,y=q,u=-u}return Q>y&&(u=-u),new L(this,q,Q,y,x,u,arguments.length>6?arguments[6]:void 0,X,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},j.prototype.beginDirectHierarchyAnimation=function(q,X,Q,y,x,u,H,b,D){let a=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const R=q.getDescendants(X),L=[];L.push(this.beginDirectAnimation(q,Q,y,x,u,H,b,D,a));for(const f of R)L.push(this.beginDirectAnimation(f,Q,y,x,u,H,b,D,a));return L},j.prototype.getAnimatableByTarget=function(q){for(let X=0;X<this._activeAnimatables.length;X++)if(this._activeAnimatables[X].target===q)return this._activeAnimatables[X];return null},j.prototype.getAllAnimatablesByTarget=function(q){const X=[];for(let Q=0;Q<this._activeAnimatables.length;Q++)this._activeAnimatables[Q].target===q&&X.push(this._activeAnimatables[Q]);return X},j.prototype.stopAnimation=function(q,X,Q){const y=this.getAllAnimatablesByTarget(q);for(const x of y)x.stop(X,Q)},j.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let q=0;q<this._activeAnimatables.length;q++)this._activeAnimatables[q].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const q of this.animationGroups)q.stop()});class e{getClassName(){return"TargetedAnimation"}serialize(){const q={};return q.animation=this.animation.serialize(),q.targetId=this.target.id,q}}class i{get mask(){return this._mask}set mask(q){this._mask!==q&&(this._mask=q,this.syncWithMask(!0))}syncWithMask(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||q){this._numActiveAnimatables=0;for(let q=0;q<this._animatables.length;++q){const X=this._animatables[q];!this.mask||this.mask.disabled||this.mask.retainsTarget(X.target.name)?(this._numActiveAnimatables++,X.paused&&X.restart()):X.paused||X.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let q=0;q<this._animatables.length;++q){const X=this._animatables[q];this.mask.retainsTarget(X.target.name)||(X.stop(),this._animatables.splice(q,1),--q)}for(let q=0;q<this._targetedAnimations.length;q++){const X=this._targetedAnimations[q];this.mask.retainsTarget(X.target.name)||(this._targetedAnimations.splice(q,1),--q)}}}get from(){return this._from}set from(q){if(this._from!==q){this._from=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].fromFrame=this._from}}}get to(){return this._to}set to(q){if(this._to!==q){this._to=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(q){if(this._speedRatio!==q){this._speedRatio=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(q){if(this._loopAnimation!==q){this._loopAnimation=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(q){if(this._isAdditive!==q){this._isAdditive=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(q){this._weight!==q&&(this._weight=q,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(q){if(this._playOrder!==q&&(this._playOrder=q,this._animatables.length>0)){for(let q=0;q<this._animatables.length;q++)this._animatables[q].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(q){if(this._enableBlending!==q&&(this._enableBlending=q,null!==q))for(let X=0;X<this._targetedAnimations.length;++X)this._targetedAnimations[X].animation.enableBlending=q}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(q){if(this._blendingSpeed!==q&&(this._blendingSpeed=q,null!==q))for(let X=0;X<this._targetedAnimations.length;++X)this._targetedAnimations[X].animation.blendingSpeed=q}getLength(q,X){q=q??this._from;return((X=X??this._to)-q)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(q){let X=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],y=arguments.length>3?arguments[3]:void 0;if(0===q.length)return null;y=y??q[0].weight;let x=Number.MAX_VALUE,u=-Number.MAX_VALUE;if(Q)for(const b of q)b.from<x&&(x=b.from),b.to>u&&(u=b.to);const H=new i(q[0].name+"_merged",q[0]._scene,y);for(const b of q){Q&&b.normalize(x,u);for(const q of b.targetedAnimations)H.addTargetedAnimation(q.animation,q.target);X&&b.dispose()}return H}constructor(q){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=q,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new x.c,this.onAnimationLoopObservable=new x.c,this.onAnimationGroupLoopObservable=new x.c,this.onAnimationGroupEndObservable=new x.c,this.onAnimationGroupPauseObservable=new x.c,this.onAnimationGroupPlayObservable=new x.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=X||u.c.LastCreatedScene,this._weight=Q,this._playOrder=y,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(q,X){const Q=new e;Q.animation=q,Q.target=X;const y=q.getKeys();return this._from>y[0].frame&&(this._from=y[0].frame),this._to<y[y.length-1].frame&&(this._to=y[y.length-1].frame),null!==this._enableBlending&&(q.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(q.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(Q),this._shouldStart=!0,Q}removeTargetedAnimation(q){for(let X=this._targetedAnimations.length-1;X>-1;X--){this._targetedAnimations[X].animation===q&&this._targetedAnimations.splice(X,1)}}normalize(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==q&&(q=this._from),null==X&&(X=this._to);for(let Q=0;Q<this._targetedAnimations.length;Q++){const y=this._targetedAnimations[Q].animation.getKeys(),x=y[0],u=y[y.length-1];if(x.frame>q){const X={frame:q,value:x.value,inTangent:x.inTangent,outTangent:x.outTangent,interpolation:x.interpolation};y.splice(0,0,X)}if(u.frame<X){const q={frame:X,value:u.value,inTangent:u.inTangent,outTangent:u.outTangent,interpolation:u.interpolation};y.push(q)}}return this._from=q,this._to=X,this}_processLoop(q,X,Q){q.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(X),this._animationLoopFlags[Q]||(this._animationLoopFlags[Q]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0],X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Q=arguments.length>2?arguments[2]:void 0,y=arguments.length>3?arguments[3]:void 0,x=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=q,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let u=0;u<this._targetedAnimations.length;u++){const H=this._targetedAnimations[u],b=this._scene.beginDirectAnimation(H.target,[H.animation],void 0!==Q?Q:this._from,void 0!==y?y:this._to,q,X,void 0,void 0,void 0!==x?x:this._isAdditive);b.weight=this._weight,b.playOrder=this._playOrder,b.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(H),this._checkAnimationGroupEnded(b)},this._processLoop(b,H,u),this._animatables.push(b)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=X,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let q=0;q<this._animatables.length;q++){this._animatables[q].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(q){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==q&&(this.loopAnimation=q),this.restart()):(this.stop(),this.start(q,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].reset()}return this}restart(){if(!this._isStarted)return this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const X=this._animatables.slice();for(let y=0;y<X.length;y++)X[y].stop(void 0,void 0,!0,q);let Q=0;for(let y=0;y<this._scene._activeAnimatables.length;y++){const X=this._scene._activeAnimatables[y];X._runtimeAnimations.length>0?this._scene._activeAnimatables[Q++]=X:q&&this._checkAnimationGroupEnded(X,q)}return this._scene._activeAnimatables.length=Q,this._isStarted=!1,this}setWeightForAllAnimatables(q){for(let X=0;X<this._animatables.length;X++){this._animatables[X].weight=q}return this}syncAllAnimationsWith(q){for(let X=0;X<this._animatables.length;X++){this._animatables[X].syncWith(q)}return this}goToFrame(q){if(!this._isStarted)return this;for(let X=0;X<this._animatables.length;X++){this._animatables[X].goToFrame(q)}return this}getCurrentFrame(){var q;return(null===(q=this.animatables[0])||void 0===q?void 0:q.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const q=this._scene.animationGroups.indexOf(this);if(q>-1&&this._scene.animationGroups.splice(q,1),this._parentContainer){const q=this._parentContainer.animationGroups.indexOf(this);q>-1&&this._parentContainer.animationGroups.splice(q,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(q){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Q=this._animatables.indexOf(q);Q>-1&&this._animatables.splice(Q,1),0===this._animatables.length&&(this._isStarted=!1,X||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(q,X){let Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const y=new i(q||this.name,this._scene,this._weight,this._playOrder);y._from=this.from,y._to=this.to,y._speedRatio=this.speedRatio,y._loopAnimation=this.loopAnimation,y._isAdditive=this.isAdditive,y._enableBlending=this.enableBlending,y._blendingSpeed=this.blendingSpeed,y.metadata=this.metadata,y.mask=this.mask;for(const x of this._targetedAnimations)y.addTargetedAnimation(Q?x.animation.clone():x.animation,X?X(x.target):x.target);return y}serialize(){const q={};q.name=this.name,q.from=this.from,q.to=this.to,q.speedRatio=this.speedRatio,q.loopAnimation=this.loopAnimation,q.isAdditive=this.isAdditive,q.weight=this.weight,q.playOrder=this.playOrder,q.enableBlending=this.enableBlending,q.blendingSpeed=this.blendingSpeed,q.targetedAnimations=[];for(let X=0;X<this.targetedAnimations.length;X++){const Q=this.targetedAnimations[X];q.targetedAnimations[X]=Q.serialize()}return H.d&&H.d.HasTags(this)&&(q.tags=H.d.GetTags(this)),this.metadata&&(q.metadata=this.metadata),q}static Parse(q,X){const Q=new i(q.name,X,q.weight,q.playOrder);for(let x=0;x<q.targetedAnimations.length;x++){const u=q.targetedAnimations[x],H=y.e.Parse(u.animation),b=u.targetId;if("influence"===u.animation.property){const q=X.getMorphTargetById(b);q&&Q.addTargetedAnimation(H,q)}else{const q=X.getNodeById(b);null!=q&&Q.addTargetedAnimation(H,q)}}return H.d&&H.d.AddTagsTo(Q,q.tags),null!==q.from&&null!==q.to&&Q.normalize(q.from,q.to),void 0!==q.speedRatio&&(Q._speedRatio=q.speedRatio),void 0!==q.loopAnimation&&(Q._loopAnimation=q.loopAnimation),void 0!==q.isAdditive&&(Q._isAdditive=q.isAdditive),void 0!==q.weight&&(Q._weight=q.weight),void 0!==q.playOrder&&(Q._playOrder=q.playOrder),void 0!==q.enableBlending&&(Q._enableBlending=q.enableBlending),void 0!==q.blendingSpeed&&(Q._blendingSpeed=q.blendingSpeed),void 0!==q.metadata&&(Q.metadata=q.metadata),Q}static MakeAnimationAdditive(q,X,Q){let x;x="object"===typeof X?X:{referenceFrame:X,range:Q,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let u=q;x.cloneOriginalAnimationGroup&&(u=q.clone(x.clonedAnimationGroupName||u.name));const H=u.targetedAnimations;for(let b=0;b<H.length;b++){const q=H[b];q.animation=y.e.MakeAnimationAdditive(q.animation,x)}if(u.isAdditive=!0,x.clipKeys){let q=Number.MAX_VALUE,X=-Number.MAX_VALUE;const Q=u.targetedAnimations;for(let y=0;y<Q.length;y++){const x=Q[y].animation.getKeys();q>x[0].frame&&(q=x[0].frame),X<x[x.length-1].frame&&(X=x[x.length-1].frame)}u._from=q,u._to=X}return u}static ClipKeys(q,X,Q,y,x){const u=q.clone(y||q.name);return i.ClipKeysInPlace(u,X,Q,x)}static ClipKeysInPlace(q,X,Q,y){return i.ClipInPlace(q,X,Q,y,!1)}static ClipFrames(q,X,Q,y,x){const u=q.clone(y||q.name);return i.ClipFramesInPlace(u,X,Q,x)}static ClipFramesInPlace(q,X,Q,y){return i.ClipInPlace(q,X,Q,y,!0)}static ClipInPlace(q,X,Q,y){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4],u=Number.MAX_VALUE,H=-Number.MAX_VALUE;const b=q.targetedAnimations;for(let D=0;D<b.length;D++){const q=b[D],a=y?q.animation:q.animation.clone();x&&(a.createKeyForFrame(X),a.createKeyForFrame(Q));const R=a.getKeys(),L=[];let f=Number.MAX_VALUE;for(let y=0;y<R.length;y++){const q=R[y];if(!x&&y>=X&&y<=Q||x&&q.frame>=X&&q.frame<=Q){const X={frame:q.frame,value:q.value.clone?q.value.clone():q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation,lockedTangent:q.lockedTangent};f===Number.MAX_VALUE&&(f=X.frame),X.frame-=f,L.push(X)}}0!==L.length?(u>L[0].frame&&(u=L[0].frame),H<L[L.length-1].frame&&(H=L[L.length-1].frame),a.setKeys(L,!0),q.animation=a):(b.splice(D,1),D--)}return q._from=u,q._to=H,q}getClassName(){return"AnimationGroup"}toString(q){let X="Name: "+this.name;return X+=", type: "+this.getClassName(),q&&(X+=", from: "+this._from,X+=", to: "+this._to,X+=", isStarted: "+this._isStarted,X+=", speedRatio: "+this._speedRatio,X+=", targetedAnimations length: "+this._targetedAnimations.length,X+=", animatables length: "+this._animatables),X}}}}]);