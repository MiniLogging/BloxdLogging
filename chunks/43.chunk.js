"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{13172:(T,z,X)=>{X.r(z),X.d(z,{AnimationGroup:()=>x,TargetedAnimation:()=>s});var b=X(12493),F=X(968),A=X(1007),u=X(1128),y=X(12491),E=X(976);class v{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(T,z,X,F){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=z,this._target=T,this._scene=X,this._host=F,this._activeTargets=[],z._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===b.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=E.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const T={frame:0,value:this._minValue};this._keys.splice(0,0,T)}if(this._target instanceof Array){let T=0;for(const z of this._target)this._preparePath(z,T),this._getOriginalValues(T),T++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const A=z.getEvents();A&&A.length>0&&A.forEach((T=>{this._events.push(T._clone())})),this._enableBlending=T&&T.animationPropertiesOverride?T.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(T){let z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const X=this._animation.targetPropertyPath;if(X.length>1){let b=T;for(let T=0;T<X.length-1;T++){const z=X[T];if(b=b[z],void 0===b)throw new Error(`Invalid property (${z}) in property path (${X.join(".")})`)}this._targetPath=X[X.length-1],this._activeTargets[z]=b}else this._targetPath=X[0],this._activeTargets[z]=T;if(void 0===this._activeTargets[z][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${X.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let T=0;for(const z of this._target)void 0!==this._originalValue[T]&&this._setValue(z,this._activeTargets[T],this._originalValue[T],-1,T),T++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let T=0;T<this._events.length;T++)this._events[T].isDone=!1}isStopped(){return this._stopped}dispose(){const T=this._animation.runtimeAnimations.indexOf(this);T>-1&&this._animation.runtimeAnimations.splice(T,1)}setValue(T,z){if(this._targetIsArray)for(let X=0;X<this._target.length;X++){const b=this._target[X];this._setValue(b,this._activeTargets[X],T,z,X)}else this._setValue(this._target,this._directTarget,T,z,0)}_getOriginalValues(){let T,z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const X=this._activeTargets[z];T=X.getLocalMatrix&&"_matrix"===this._targetPath?X.getLocalMatrix():X[this._targetPath],T&&T.clone?this._originalValue[z]=T.clone():this._originalValue[z]=T}_registerTargetForLateAnimationBinding(T,z){const X=T.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(X),X._lateAnimationHolders||(X._lateAnimationHolders={}),X._lateAnimationHolders[T.targetPath]||(X._lateAnimationHolders[T.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:z}),T.isAdditive?(X._lateAnimationHolders[T.targetPath].additiveAnimations.push(T),X._lateAnimationHolders[T.targetPath].totalAdditiveWeight+=T.weight):(X._lateAnimationHolders[T.targetPath].animations.push(T),X._lateAnimationHolders[T.targetPath].totalWeight+=T.weight)}_setValue(T,z,X,F,A){if(this._currentActiveTarget=z,this._weight=F,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const T=z[this._targetPath];T.clone?this._originalBlendValue=T.clone():this._originalBlendValue=T}this._originalBlendValue.m?b.e.AllowMatrixDecomposeForInterpolation?this._currentValue?E.d.DecomposeLerpToRef(this._originalBlendValue,X,this._blendingFactor,this._currentValue):this._currentValue=E.d.DecomposeLerp(this._originalBlendValue,X,this._blendingFactor):this._currentValue?E.d.LerpToRef(this._originalBlendValue,X,this._blendingFactor,this._currentValue):this._currentValue=E.d.Lerp(this._originalBlendValue,X,this._blendingFactor):this._currentValue=b.e._UniversalLerp(this._originalBlendValue,X,this._blendingFactor);const F=T&&T.animationPropertiesOverride?T.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=F}else this._currentValue?this._currentValue.p?this._currentValue.p(X):this._currentValue=X:null!==X&&void 0!==X&&X.clone?this._currentValue=X.clone():this._currentValue=X;-1!==F?this._registerTargetForLateAnimationBinding(this,this._originalValue[A]):this._animationState.loopMode===b.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[A],z[this._targetPath]):z[this._targetPath]=this._originalValue[A]+this._currentValue:z[this._targetPath]=this._currentValue,T.Fe&&T.Fe(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(T){let z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const X=this._animation.getKeys();T<X[0].frame?T=X[0].frame:T>X[X.length-1].frame&&(T=X[X.length-1].frame);const b=this._events;if(b.length)for(let A=0;A<b.length;A++)b[A].onlyOnce||(b[A].isDone=b[A].frame<T);this._currentFrame=T;const F=this._animation._interpolate(T,this._animationState);this.setValue(F,z)}_prepareForSpeedRatioChange(T){const z=this._previousElapsedTime*(this._animation.framePerSecond*T)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-z}animate(T,z,X,F,A){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const y=this._animation,E=y.targetPropertyPath;if(!E||E.length<1)return this._stopped=!0,!1;let v=!0;(z<this._minFrame||z>this._maxFrame)&&(z=this._minFrame),(X<this._minFrame||X>this._maxFrame)&&(X=this._maxFrame);const k=X-z;let L,D=T*(y.framePerSecond*A)/1e3+this._absoluteFrameOffset,c=0,p=!1;const H=F&&this._animationState.loopMode===b.e.ANIMATIONLOOPMODE_YOYO;if(H){const T=(D-z)/k,X=Math.sin(T*Math.PI);D=Math.abs(X)*k+z;const b=X>=0?1:-1;this._yoyoDirection!==b&&(p=!0),this._yoyoDirection=b}if(this._previousElapsedTime=T,this._previousAbsoluteFrame=D,!F&&X>=z&&(D>=k&&A>0||D<=0&&A<0))v=!1,c=y._getKeyValue(this._maxValue);else if(!F&&z>=X&&(D<=k&&A<0||D>=0&&A>0))v=!1,c=y._getKeyValue(this._minValue);else if(this._animationState.loopMode!==b.e.ANIMATIONLOOPMODE_CYCLE){const T=X.toString()+z.toString();if(!this._offsetsCache[T]){this._animationState.repeatCount=0,this._animationState.loopMode=b.e.ANIMATIONLOOPMODE_CYCLE;const F=y._interpolate(z,this._animationState),A=y._interpolate(X,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),y.dataType){case b.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[T]=A-F;break;case b.e.ANIMATIONTYPE_QUATERNION:case b.e.ANIMATIONTYPE_VECTOR3:case b.e.ANIMATIONTYPE_VECTOR2:case b.e.ANIMATIONTYPE_SIZE:case b.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[T]=A.Mc(F)}this._highLimitsCache[T]=A}c=this._highLimitsCache[T],L=this._offsetsCache[T]}if(void 0===L)switch(y.dataType){case b.e.ANIMATIONTYPE_FLOAT:L=0;break;case b.e.ANIMATIONTYPE_QUATERNION:L=b.j;break;case b.e.ANIMATIONTYPE_VECTOR3:L=b.o;break;case b.e.ANIMATIONTYPE_VECTOR2:L=b.n;break;case b.e.ANIMATIONTYPE_SIZE:L=b.l;break;case b.e.ANIMATIONTYPE_COLOR3:L=b.f;break;case b.e.ANIMATIONTYPE_COLOR4:L=b.g}let U;if(this._host&&this._host.syncRoot){const T=this._host.syncRoot;U=z+k*((T.masterFrame-T.fromFrame)/(T.toFrame-T.fromFrame))}else U=D>0&&z>X||D<0&&z<X?v&&0!==k?X+D%k:z:v&&0!==k?z+D%k:X;const s=this._events;if(!H&&(A>0&&this.currentFrame>U||A<0&&this.currentFrame<U)||H&&p){this._onLoop();for(let T=0;T<s.length;T++)s[T].onlyOnce||(s[T].isDone=!1);this._animationState.key=A>0?0:y.getKeys().length-1}this._currentFrame=U,this._animationState.repeatCount=0===k?0:D/k|0,this._animationState.highLimitValue=c,this._animationState.offsetValue=L;const x=y._interpolate(U,this._animationState);if(this.setValue(x,u),s.length)for(let b=0;b<s.length;b++)if(k>=0&&U>=s[b].frame&&s[b].frame>=z||k<0&&U<=s[b].frame&&s[b].frame<=z){const T=s[b];T.isDone||(T.onlyOnce&&(s.splice(b,1),b--),T.isDone=!0,T.action(U))}return v||(this._stopped=!0),v}}var k=X(1096);class L{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(T){this._weight=-1!==T?Math.min(Math.max(T,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(T){for(let z=0;z<this._runtimeAnimations.length;z++){this._runtimeAnimations[z]._prepareForSpeedRatioChange(T)}this._speedRatio=T,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(T,z){let X=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,A=arguments.length>4&&void 0!==arguments[4]&&arguments[4],u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,y=arguments.length>6?arguments[6]:void 0,E=arguments.length>7?arguments[7]:void 0,v=arguments.length>8?arguments[8]:void 0,k=arguments.length>9&&void 0!==arguments[9]&&arguments[9],L=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=z,this.fromFrame=X,this.toFrame=b,this.loopAnimation=A,this.onAnimationEnd=y,this.onAnimationLoop=v,this.isAdditive=k,this.playOrder=L,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.vf=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new F.d,this.onAnimationLoopObservable=new F.d,this._scene=T,E&&this.appendAnimations(z,E),this._speedRatio=u,T._activeAnimatables.push(this)}syncWith(T){if(this._syncRoot=T,T){const T=this._scene._activeAnimatables.indexOf(this);T>-1&&(this._scene._activeAnimatables.splice(T,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(T,z){for(let X=0;X<z.length;X++){const b=z[X],F=new v(T,b,this._scene,this);F._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(F)}}getAnimationByTargetProperty(T){const z=this._runtimeAnimations;for(let X=0;X<z.length;X++)if(z[X].animation.targetProperty===T)return z[X].animation;return null}getRuntimeAnimationByTargetProperty(T){const z=this._runtimeAnimations;for(let X=0;X<z.length;X++)if(z[X].animation.targetProperty===T)return z[X];return null}reset(){const T=this._runtimeAnimations;for(let z=0;z<T.length;z++)T[z].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(T){const z=this._runtimeAnimations;for(let X=0;X<z.length;X++)z[X].animation.enableBlending=!0,z[X].animation.blendingSpeed=T}disableBlending(){const T=this._runtimeAnimations;for(let z=0;z<T.length;z++)T[z].animation.enableBlending=!1}goToFrame(T){const z=this._runtimeAnimations;if(z[0]){const X=z[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??z[0].currentFrame;const b=0===this.speedRatio?0:(T-this._frameToSyncFromJump)/X*1e3/this.speedRatio;this._manualJumpDelay=-b}for(let X=0;X<z.length;X++)z[X].goToFrame(T,this._weight);this._goToFrame=T}get paused(){return this.vf}pause(){this.vf||(this.vf=!0)}restart(){this.vf=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(T,z){let X=arguments.length>2&&void 0!==arguments[2]&&arguments[2],b=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(T||z){const F=this._scene._activeAnimatables.indexOf(this);if(F>-1){const A=this._runtimeAnimations;for(let X=A.length-1;X>=0;X--){const b=A[X];T&&b.animation.name!=T||(z&&!z(b.target)||(b.dispose(),A.splice(X,1)))}0==A.length&&(X||this._scene._activeAnimatables.splice(F,1),b||this._raiseOnAnimationEnd())}}else{const T=this._scene._activeAnimatables.indexOf(this);if(T>-1){X||this._scene._activeAnimatables.splice(T,1);const z=this._runtimeAnimations;for(let T=0;T<z.length;T++)z[T].dispose();this._runtimeAnimations.length=0,b||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((T=>{this.onAnimationEndObservable.add((()=>{T(this)}),void 0,void 0,this,!0)}))}_animate(T){if(this.vf)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=T),!0;if(null===this._localDelayOffset?(this._localDelayOffset=T,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=T-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let z=!1;const X=this._runtimeAnimations;let b;for(b=0;b<X.length;b++){const F=X[b].animate(T-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);z=z||F}if(this.animationStarted=z,!z){if(this.disposeOnEnd)for(b=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(b,1),b=0;b<X.length;b++)X[b].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return z}}function D(T){if(0===T.totalWeight&&0===T.totalAdditiveWeight)return T.originalValue;let z=1;const X=E.f.Id[0],b=E.f.Id[1],F=E.f.Quaternion[0];let A=0;const u=T.animations[0],y=T.originalValue;let v=1,k=!1;if(T.totalWeight<1)v=1-T.totalWeight,y.decompose(b,F,X);else{if(A=1,z=T.totalWeight,v=u.weight/z,1==v){if(!T.totalAdditiveWeight)return u.currentValue;k=!0}u.currentValue.decompose(b,F,X)}if(!k){b.scaleInPlace(v),X.scaleInPlace(v),F.scaleInPlace(v);for(let u=A;u<T.animations.length;u++){const A=T.animations[u];if(0===A.weight)continue;v=A.weight/z;const y=E.f.Id[2],k=E.f.Id[3],L=E.f.Quaternion[1];A.currentValue.decompose(k,L,y),k.scaleAndAddToRef(v,b),L.scaleAndAddToRef(E.e.Dot(F,L)>0?v:-v,F),y.scaleAndAddToRef(v,X)}F.normalize()}for(let D=0;D<T.additiveAnimations.length;D++){const z=T.additiveAnimations[D];if(0===z.weight)continue;const A=E.f.Id[2],u=E.f.Id[3],y=E.f.Quaternion[1];z.currentValue.decompose(u,y,A),u.multiplyToRef(b,u),E.j.LerpToRef(b,u,z.weight,b),F.multiplyToRef(y,y),E.e.SlerpToRef(F,y,z.weight,F),A.scaleAndAddToRef(z.weight,X)}const L=u?u._animationState.workValue:E.f.Matrix[0].clone();return E.d.ComposeToRef(b,F,X,L),L}function c(T,z){if(0===T.totalWeight&&0===T.totalAdditiveWeight)return z;const X=T.animations[0],b=T.originalValue;let F=z;if(0===T.totalWeight&&T.totalAdditiveWeight>0)F.p(b);else if(1===T.animations.length){if(E.e.SlerpToRef(b,X.currentValue,Math.min(1,T.totalWeight),F),0===T.totalAdditiveWeight)return F}else if(T.animations.length>1){let X,A,u=1;if(T.totalWeight<1){const z=1-T.totalWeight;X=[],A=[],X.push(b),A.push(z)}else{if(2===T.animations.length&&(E.e.SlerpToRef(T.animations[0].currentValue,T.animations[1].currentValue,T.animations[1].weight/T.totalWeight,z),0===T.totalAdditiveWeight))return z;X=[],A=[],u=T.totalWeight}for(let z=0;z<T.animations.length;z++){const b=T.animations[z];X.push(b.currentValue),A.push(b.weight/u)}let y=0;for(let T=0;T<X.length;)T?(y+=A[T],E.e.SlerpToRef(F,X[T],A[T]/y,F),T++):(E.e.SlerpToRef(X[T],X[T+1],A[T+1]/(A[T]+A[T+1]),z),F=z,y=A[T]+A[T+1],T+=2)}for(let A=0;A<T.additiveAnimations.length;A++){const z=T.additiveAnimations[A];0!==z.weight&&(F.multiplyToRef(z.currentValue,E.f.Quaternion[0]),E.e.SlerpToRef(F,E.f.Quaternion[0],z.weight,F))}return F}var p,H,U=X(1159);p=U.e,(H=y.d)&&(H.prototype.copyAnimationRange=function(T,z,X){let F=arguments.length>3&&void 0!==arguments[3]&&arguments[3],A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new b.e(this.name,"_matrix",T.animations[0].framePerSecond,b.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const u=T.animations[0].getRange(z);if(!u)return!1;const y=u.from,E=u.to,v=T.animations[0].getKeys(),k=T.length,L=T.getParent(),D=this.getParent(),c=F&&L&&k&&this.length&&k!==this.length,p=c&&D&&L?D.length/L.length:1,H=F&&!D&&A&&(1!==A.x||1!==A.y||1!==A.z),U=this.animations[0].getKeys();let s,x,K;for(let b=0,d=v.length;b<d;b++)s=v[b],s.frame>=y&&s.frame<=E&&(F?(K=s.value.clone(),c?(x=K.getTranslation(),K.setTranslation(x.scaleInPlace(p))):H&&A?(x=K.getTranslation(),K.setTranslation(x.multiplyInPlace(A))):K=s.value):K=s.value,U.push({frame:s.frame+X,value:K}));return this.animations[0].createRange(z,y+X,E+X),!0}),p&&(p.prototype._animate=function(T){if(!this.animationsEnabled)return;const z=k.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=z}this.deltaTime=void 0!==T?T:this.useConstantAnimationDeltaTime?16:(z-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=z;const X=this._activeAnimatables;if(0===X.length)return;this._animationTime+=this.deltaTime;const F=this._animationTime;for(let b=0;b<X.length;b++){const T=X[b];!T._animate(F)&&T.disposeOnEnd&&b--}!function(T){if(T._registeredForLateAnimationBindings.length){for(let z=0;z<T._registeredForLateAnimationBindings.length;z++){const X=T._registeredForLateAnimationBindings.data[z];for(const T in X._lateAnimationHolders){const z=X._lateAnimationHolders[T],F=z.animations[0],A=z.originalValue;if(void 0===A||null===A)continue;const u=b.e.AllowMatrixDecomposeForInterpolation&&A.m;let y=X[T];if(u)y=D(z);else if(void 0!==A.w)y=c(z,y||E.e.Identity());else{let T=0,X=1;const u=F&&F._animationState.loopMode===b.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(z.totalWeight<1)y=u?A.clone?A.clone():A:F&&A.scale?A.scale(1-z.totalWeight):F?A*(1-z.totalWeight):A.clone?A.clone():A;else if(F){X=z.totalWeight;const b=F.weight/X;y=1!==b?F.currentValue.scale?F.currentValue.scale(b):F.currentValue*b:F.currentValue,u&&(y.addToRef?y.addToRef(A,y):y+=A),T=1}for(let b=T;b<z.animations.length;b++){const T=z.animations[b],F=T.weight/X;F&&(T.currentValue.scaleAndAddToRef?T.currentValue.scaleAndAddToRef(F,y):y+=T.currentValue*F)}for(let b=0;b<z.additiveAnimations.length;b++){const T=z.additiveAnimations[b],X=T.weight;X&&(T.currentValue.scaleAndAddToRef?T.currentValue.scaleAndAddToRef(X,y):y+=T.currentValue*X)}}X[T]=y}X._lateAnimationHolders={}}T._registeredForLateAnimationBindings.reset()}}(this)},p.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((T,z)=>T.playOrder-z.playOrder))},p.prototype.beginWeightedAnimation=function(T,z,X){let b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,F=arguments.length>4?arguments[4]:void 0,A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,y=arguments.length>7?arguments[7]:void 0,E=arguments.length>8?arguments[8]:void 0,v=arguments.length>9?arguments[9]:void 0,k=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const L=this.beginAnimation(T,z,X,F,A,u,y,!1,E,v,k);return L.weight=b,L},p.prototype.beginAnimation=function(T,z,X,b){let F=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,A=arguments.length>5?arguments[5]:void 0,u=arguments.length>6?arguments[6]:void 0,y=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],E=arguments.length>8?arguments[8]:void 0,v=arguments.length>9?arguments[9]:void 0,k=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(F<0){const T=z;z=X,X=T,F=-F}z>X&&(F=-F),y&&this.stopAnimation(T,void 0,E),u||(u=new L(this,T,z,X,b,F,A,void 0,v,k));const D=!E||E(T);if(T.animations&&D&&u.appendAnimations(T,T.animations),T.getAnimatables){const k=T.getAnimatables();for(let T=0;T<k.length;T++)this.beginAnimation(k[T],z,X,b,F,A,u,y,E,v)}return u.reset(),u},p.prototype.beginHierarchyAnimation=function(T,z,X,b,F){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,y=arguments.length>7?arguments[7]:void 0,E=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],v=arguments.length>9?arguments[9]:void 0,k=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const L=T.getDescendants(z),D=[];D.push(this.beginAnimation(T,X,b,F,A,u,y,E,v,void 0,k));for(const c of L)D.push(this.beginAnimation(c,X,b,F,A,u,y,E,v,void 0,k));return D},p.prototype.beginDirectAnimation=function(T,z,X,b,F){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(A<0){const T=X;X=b,b=T,A=-A}return X>b&&(A=-A),new L(this,T,X,b,F,A,arguments.length>6?arguments[6]:void 0,z,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},p.prototype.beginDirectHierarchyAnimation=function(T,z,X,b,F,A,u,y,E){let v=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const k=T.getDescendants(z),L=[];L.push(this.beginDirectAnimation(T,X,b,F,A,u,y,E,v));for(const D of k)L.push(this.beginDirectAnimation(D,X,b,F,A,u,y,E,v));return L},p.prototype.getAnimatableByTarget=function(T){for(let z=0;z<this._activeAnimatables.length;z++)if(this._activeAnimatables[z].target===T)return this._activeAnimatables[z];return null},p.prototype.getAllAnimatablesByTarget=function(T){const z=[];for(let X=0;X<this._activeAnimatables.length;X++)this._activeAnimatables[X].target===T&&z.push(this._activeAnimatables[X]);return z},p.prototype.stopAnimation=function(T,z,X){const b=this.getAllAnimatablesByTarget(T);for(const F of b)F.stop(z,X)},p.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let T=0;T<this._activeAnimatables.length;T++)this._activeAnimatables[T].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const T of this.animationGroups)T.stop()});class s{getClassName(){return"TargetedAnimation"}serialize(){const T={};return T.animation=this.animation.serialize(),T.targetId=this.target.id,T}}class x{get mask(){return this._mask}set mask(T){this._mask!==T&&(this._mask=T,this.syncWithMask(!0))}syncWithMask(){let T=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||T){this._numActiveAnimatables=0;for(let T=0;T<this._animatables.length;++T){const z=this._animatables[T];!this.mask||this.mask.disabled||this.mask.retainsTarget(z.target.name)?(this._numActiveAnimatables++,z.paused&&z.restart()):z.paused||z.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let T=0;T<this._animatables.length;++T){const z=this._animatables[T];this.mask.retainsTarget(z.target.name)||(z.stop(),this._animatables.splice(T,1),--T)}for(let T=0;T<this._targetedAnimations.length;T++){const z=this._targetedAnimations[T];this.mask.retainsTarget(z.target.name)||(this._targetedAnimations.splice(T,1),--T)}}}get from(){return this._from}set from(T){if(this._from!==T){this._from=T;for(let T=0;T<this._animatables.length;T++){this._animatables[T].fromFrame=this._from}}}get to(){return this._to}set to(T){if(this._to!==T){this._to=T;for(let T=0;T<this._animatables.length;T++){this._animatables[T].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(T){if(this._speedRatio!==T){this._speedRatio=T;for(let T=0;T<this._animatables.length;T++){this._animatables[T].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(T){if(this._loopAnimation!==T){this._loopAnimation=T;for(let T=0;T<this._animatables.length;T++){this._animatables[T].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(T){if(this._isAdditive!==T){this._isAdditive=T;for(let T=0;T<this._animatables.length;T++){this._animatables[T].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(T){this._weight!==T&&(this._weight=T,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(T){if(this._playOrder!==T&&(this._playOrder=T,this._animatables.length>0)){for(let T=0;T<this._animatables.length;T++)this._animatables[T].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(T){if(this._enableBlending!==T&&(this._enableBlending=T,null!==T))for(let z=0;z<this._targetedAnimations.length;++z)this._targetedAnimations[z].animation.enableBlending=T}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(T){if(this._blendingSpeed!==T&&(this._blendingSpeed=T,null!==T))for(let z=0;z<this._targetedAnimations.length;++z)this._targetedAnimations[z].animation.blendingSpeed=T}getLength(T,z){T=T??this._from;return((z=z??this._to)-T)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(T){let z=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],X=arguments.length>2&&void 0!==arguments[2]&&arguments[2],b=arguments.length>3?arguments[3]:void 0;if(0===T.length)return null;b=b??T[0].weight;let F=Number.MAX_VALUE,A=-Number.MAX_VALUE;if(X)for(const y of T)y.from<F&&(F=y.from),y.to>A&&(A=y.to);const u=new x(T[0].name+"_merged",T[0]._scene,b);for(const y of T){X&&y.normalize(F,A);for(const T of y.targetedAnimations)u.addTargetedAnimation(T.animation,T.target);z&&y.dispose()}return u}constructor(T){let z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,X=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=T,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new F.d,this.onAnimationLoopObservable=new F.d,this.onAnimationGroupLoopObservable=new F.d,this.onAnimationGroupEndObservable=new F.d,this.onAnimationGroupPauseObservable=new F.d,this.onAnimationGroupPlayObservable=new F.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=z||A.e.LastCreatedScene,this._weight=X,this._playOrder=b,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(T,z){const X=new s;X.animation=T,X.target=z;const b=T.getKeys();return this._from>b[0].frame&&(this._from=b[0].frame),this._to<b[b.length-1].frame&&(this._to=b[b.length-1].frame),null!==this._enableBlending&&(T.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(T.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(X),this._shouldStart=!0,X}removeTargetedAnimation(T){for(let z=this._targetedAnimations.length-1;z>-1;z--){this._targetedAnimations[z].animation===T&&this._targetedAnimations.splice(z,1)}}normalize(){let T=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==T&&(T=this._from),null==z&&(z=this._to);for(let X=0;X<this._targetedAnimations.length;X++){const b=this._targetedAnimations[X].animation.getKeys(),F=b[0],A=b[b.length-1];if(F.frame>T){const z={frame:T,value:F.value,inTangent:F.inTangent,outTangent:F.outTangent,interpolation:F.interpolation};b.splice(0,0,z)}if(A.frame<z){const T={frame:z,value:A.value,inTangent:A.inTangent,outTangent:A.outTangent,interpolation:A.interpolation};b.push(T)}}return this._from=T,this._to=z,this}_processLoop(T,z,X){T.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(z),this._animationLoopFlags[X]||(this._animationLoopFlags[X]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let T=arguments.length>0&&void 0!==arguments[0]&&arguments[0],z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,X=arguments.length>2?arguments[2]:void 0,b=arguments.length>3?arguments[3]:void 0,F=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=T,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let A=0;A<this._targetedAnimations.length;A++){const u=this._targetedAnimations[A],y=this._scene.beginDirectAnimation(u.target,[u.animation],void 0!==X?X:this._from,void 0!==b?b:this._to,T,z,void 0,void 0,void 0!==F?F:this._isAdditive);y.weight=this._weight,y.playOrder=this._playOrder,y.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(u),this._checkAnimationGroupEnded(y)},this._processLoop(y,u,A),this._animatables.push(y)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=z,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let T=0;T<this._animatables.length;T++){this._animatables[T].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(T){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==T&&(this.loopAnimation=T),this.restart()):(this.stop(),this.start(T,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let T=0;T<this._animatables.length;T++){this._animatables[T].reset()}return this}restart(){if(!this._isStarted)return this;for(let T=0;T<this._animatables.length;T++){this._animatables[T].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let T=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const z=this._animatables.slice();for(let b=0;b<z.length;b++)z[b].stop(void 0,void 0,!0,T);let X=0;for(let b=0;b<this._scene._activeAnimatables.length;b++){const z=this._scene._activeAnimatables[b];z._runtimeAnimations.length>0?this._scene._activeAnimatables[X++]=z:T&&this._checkAnimationGroupEnded(z,T)}return this._scene._activeAnimatables.length=X,this._isStarted=!1,this}setWeightForAllAnimatables(T){for(let z=0;z<this._animatables.length;z++){this._animatables[z].weight=T}return this}syncAllAnimationsWith(T){for(let z=0;z<this._animatables.length;z++){this._animatables[z].syncWith(T)}return this}goToFrame(T){if(!this._isStarted)return this;for(let z=0;z<this._animatables.length;z++){this._animatables[z].goToFrame(T)}return this}getCurrentFrame(){var T;return(null===(T=this.animatables[0])||void 0===T?void 0:T.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const T=this._scene.animationGroups.indexOf(this);if(T>-1&&this._scene.animationGroups.splice(T,1),this._parentContainer){const T=this._parentContainer.animationGroups.indexOf(this);T>-1&&this._parentContainer.animationGroups.splice(T,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(T){let z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const X=this._animatables.indexOf(T);X>-1&&this._animatables.splice(X,1),0===this._animatables.length&&(this._isStarted=!1,z||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(T,z){let X=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const b=new x(T||this.name,this._scene,this._weight,this._playOrder);b._from=this.from,b._to=this.to,b._speedRatio=this.speedRatio,b._loopAnimation=this.loopAnimation,b._isAdditive=this.isAdditive,b._enableBlending=this.enableBlending,b._blendingSpeed=this.blendingSpeed,b.metadata=this.metadata,b.mask=this.mask;for(const F of this._targetedAnimations)b.addTargetedAnimation(X?F.animation.clone():F.animation,z?z(F.target):F.target);return b}serialize(){const T={};T.name=this.name,T.from=this.from,T.to=this.to,T.speedRatio=this.speedRatio,T.loopAnimation=this.loopAnimation,T.isAdditive=this.isAdditive,T.weight=this.weight,T.playOrder=this.playOrder,T.enableBlending=this.enableBlending,T.blendingSpeed=this.blendingSpeed,T.targetedAnimations=[];for(let z=0;z<this.targetedAnimations.length;z++){const X=this.targetedAnimations[z];T.targetedAnimations[z]=X.serialize()}return u.e&&u.e.HasTags(this)&&(T.tags=u.e.GetTags(this)),this.metadata&&(T.metadata=this.metadata),T}static Parse(T,z){const X=new x(T.name,z,T.weight,T.playOrder);for(let F=0;F<T.targetedAnimations.length;F++){const A=T.targetedAnimations[F],u=b.e.Parse(A.animation),y=A.targetId;if("influence"===A.animation.property){const T=z.getMorphTargetById(y);T&&X.addTargetedAnimation(u,T)}else{const T=z.getNodeById(y);null!=T&&X.addTargetedAnimation(u,T)}}return u.e&&u.e.AddTagsTo(X,T.tags),null!==T.from&&null!==T.to&&X.normalize(T.from,T.to),void 0!==T.speedRatio&&(X._speedRatio=T.speedRatio),void 0!==T.loopAnimation&&(X._loopAnimation=T.loopAnimation),void 0!==T.isAdditive&&(X._isAdditive=T.isAdditive),void 0!==T.weight&&(X._weight=T.weight),void 0!==T.playOrder&&(X._playOrder=T.playOrder),void 0!==T.enableBlending&&(X._enableBlending=T.enableBlending),void 0!==T.blendingSpeed&&(X._blendingSpeed=T.blendingSpeed),void 0!==T.metadata&&(X.metadata=T.metadata),X}static MakeAnimationAdditive(T,z,X){let F;F="object"===typeof z?z:{referenceFrame:z,range:X,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let A=T;F.cloneOriginalAnimationGroup&&(A=T.clone(F.clonedAnimationGroupName||A.name));const u=A.targetedAnimations;for(let y=0;y<u.length;y++){const T=u[y];T.animation=b.e.MakeAnimationAdditive(T.animation,F)}if(A.isAdditive=!0,F.clipKeys){let T=Number.MAX_VALUE,z=-Number.MAX_VALUE;const X=A.targetedAnimations;for(let b=0;b<X.length;b++){const F=X[b].animation.getKeys();T>F[0].frame&&(T=F[0].frame),z<F[F.length-1].frame&&(z=F[F.length-1].frame)}A._from=T,A._to=z}return A}static ClipKeys(T,z,X,b,F){const A=T.clone(b||T.name);return x.ClipKeysInPlace(A,z,X,F)}static ClipKeysInPlace(T,z,X,b){return x.ClipInPlace(T,z,X,b,!1)}static ClipFrames(T,z,X,b,F){const A=T.clone(b||T.name);return x.ClipFramesInPlace(A,z,X,F)}static ClipFramesInPlace(T,z,X,b){return x.ClipInPlace(T,z,X,b,!0)}static ClipInPlace(T,z,X,b){let F=arguments.length>4&&void 0!==arguments[4]&&arguments[4],A=Number.MAX_VALUE,u=-Number.MAX_VALUE;const y=T.targetedAnimations;for(let E=0;E<y.length;E++){const T=y[E],v=b?T.animation:T.animation.clone();F&&(v.createKeyForFrame(z),v.createKeyForFrame(X));const k=v.getKeys(),L=[];let D=Number.MAX_VALUE;for(let b=0;b<k.length;b++){const T=k[b];if(!F&&b>=z&&b<=X||F&&T.frame>=z&&T.frame<=X){const z={frame:T.frame,value:T.value.clone?T.value.clone():T.value,inTangent:T.inTangent,outTangent:T.outTangent,interpolation:T.interpolation,lockedTangent:T.lockedTangent};D===Number.MAX_VALUE&&(D=z.frame),z.frame-=D,L.push(z)}}0!==L.length?(A>L[0].frame&&(A=L[0].frame),u<L[L.length-1].frame&&(u=L[L.length-1].frame),v.setKeys(L,!0),T.animation=v):(y.splice(E,1),E--)}return T._from=A,T._to=u,T}getClassName(){return"AnimationGroup"}toString(T){let z="Name: "+this.name;return z+=", type: "+this.getClassName(),T&&(z+=", from: "+this._from,z+=", to: "+this._to,z+=", isStarted: "+this._isStarted,z+=", speedRatio: "+this._speedRatio,z+=", targetedAnimations length: "+this._targetedAnimations.length,z+=", animatables length: "+this._animatables),z}}}}]);