"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{13436:(L,i,P)=>{P.r(i),P.d(i,{AnimationGroup:()=>j,TargetedAnimation:()=>H});var D=P(12783),V=P(990),M=P(1024),a=P(1170),w=P(12780),O=P(995);class U{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(L,i,P,V){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=i,this._target=L,this._scene=P,this._host=V,this._activeTargets=[],i._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===D.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=O.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const L={frame:0,value:this._minValue};this._keys.splice(0,0,L)}if(this._target instanceof Array){let L=0;for(const i of this._target)this._preparePath(i,L),this._getOriginalValues(L),L++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const M=i.getEvents();M&&M.length>0&&M.forEach((L=>{this._events.push(L._clone())})),this._enableBlending=L&&L.animationPropertiesOverride?L.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(L){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=this._animation.targetPropertyPath;if(P.length>1){let D=L;for(let L=0;L<P.length-1;L++){const i=P[L];if(D=D[i],void 0===D)throw new Error(`Invalid property (${i}) in property path (${P.join(".")})`)}this._targetPath=P[P.length-1],this._activeTargets[i]=D}else this._targetPath=P[0],this._activeTargets[i]=L;if(void 0===this._activeTargets[i][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${P.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let L=0;for(const i of this._target)void 0!==this._originalValue[L]&&this._setValue(i,this._activeTargets[L],this._originalValue[L],-1,L),L++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let L=0;L<this._events.length;L++)this._events[L].isDone=!1}isStopped(){return this._stopped}dispose(){const L=this._animation.runtimeAnimations.indexOf(this);L>-1&&this._animation.runtimeAnimations.splice(L,1)}setValue(L,i){if(this._targetIsArray)for(let P=0;P<this._target.length;P++){const D=this._target[P];this._setValue(D,this._activeTargets[P],L,i,P)}else this._setValue(this._target,this._directTarget,L,i,0)}_getOriginalValues(){let L,i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const P=this._activeTargets[i];L=P.getLocalMatrix&&"_matrix"===this._targetPath?P.getLocalMatrix():P[this._targetPath],L&&L.clone?this._originalValue[i]=L.clone():this._originalValue[i]=L}_registerTargetForLateAnimationBinding(L,i){const P=L.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(P),P._lateAnimationHolders||(P._lateAnimationHolders={}),P._lateAnimationHolders[L.targetPath]||(P._lateAnimationHolders[L.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:i}),L.isAdditive?(P._lateAnimationHolders[L.targetPath].additiveAnimations.push(L),P._lateAnimationHolders[L.targetPath].totalAdditiveWeight+=L.weight):(P._lateAnimationHolders[L.targetPath].animations.push(L),P._lateAnimationHolders[L.targetPath].totalWeight+=L.weight)}_setValue(L,i,P,V,M){if(this._currentActiveTarget=i,this._weight=V,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const L=i[this._targetPath];L.clone?this._originalBlendValue=L.clone():this._originalBlendValue=L}this._originalBlendValue.m?D.e.AllowMatrixDecomposeForInterpolation?this._currentValue?O.d.DecomposeLerpToRef(this._originalBlendValue,P,this._blendingFactor,this._currentValue):this._currentValue=O.d.DecomposeLerp(this._originalBlendValue,P,this._blendingFactor):this._currentValue?O.d.LerpToRef(this._originalBlendValue,P,this._blendingFactor,this._currentValue):this._currentValue=O.d.Lerp(this._originalBlendValue,P,this._blendingFactor):this._currentValue=D.e._UniversalLerp(this._originalBlendValue,P,this._blendingFactor);const V=L&&L.animationPropertiesOverride?L.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=V}else this._currentValue?this._currentValue.p?this._currentValue.p(P):this._currentValue=P:null!==P&&void 0!==P&&P.clone?this._currentValue=P.clone():this._currentValue=P;-1!==V?this._registerTargetForLateAnimationBinding(this,this._originalValue[M]):this._animationState.loopMode===D.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[M],i[this._targetPath]):i[this._targetPath]=this._originalValue[M]+this._currentValue:i[this._targetPath]=this._currentValue,L.He&&L.He(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(L){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const P=this._animation.getKeys();L<P[0].frame?L=P[0].frame:L>P[P.length-1].frame&&(L=P[P.length-1].frame);const D=this._events;if(D.length)for(let M=0;M<D.length;M++)D[M].onlyOnce||(D[M].isDone=D[M].frame<L);this._currentFrame=L;const V=this._animation._interpolate(L,this._animationState);this.setValue(V,i)}_prepareForSpeedRatioChange(L){const i=this._previousElapsedTime*(this._animation.framePerSecond*L)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-i}animate(L,i,P,V,M){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const w=this._animation,O=w.targetPropertyPath;if(!O||O.length<1)return this._stopped=!0,!1;let U=!0;(i<this._minFrame||i>this._maxFrame)&&(i=this._minFrame),(P<this._minFrame||P>this._maxFrame)&&(P=this._maxFrame);const C=P-i;let T,c=L*(w.framePerSecond*M)/1e3+this._absoluteFrameOffset,r=0,F=!1;const S=V&&this._animationState.loopMode===D.e.ANIMATIONLOOPMODE_YOYO;if(S){const L=(c-i)/C,P=Math.sin(L*Math.PI);c=Math.abs(P)*C+i;const D=P>=0?1:-1;this._yoyoDirection!==D&&(F=!0),this._yoyoDirection=D}if(this._previousElapsedTime=L,this._previousAbsoluteFrame=c,!V&&P>=i&&(c>=C&&M>0||c<=0&&M<0))U=!1,r=w._getKeyValue(this._maxValue);else if(!V&&i>=P&&(c<=C&&M<0||c>=0&&M>0))U=!1,r=w._getKeyValue(this._minValue);else if(this._animationState.loopMode!==D.e.ANIMATIONLOOPMODE_CYCLE){const L=P.toString()+i.toString();if(!this._offsetsCache[L]){this._animationState.repeatCount=0,this._animationState.loopMode=D.e.ANIMATIONLOOPMODE_CYCLE;const V=w._interpolate(i,this._animationState),M=w._interpolate(P,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),w.dataType){case D.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[L]=M-V;break;case D.e.ANIMATIONTYPE_QUATERNION:case D.e.ANIMATIONTYPE_VECTOR3:case D.e.ANIMATIONTYPE_VECTOR2:case D.e.ANIMATIONTYPE_SIZE:case D.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[L]=M.md(V)}this._highLimitsCache[L]=M}r=this._highLimitsCache[L],T=this._offsetsCache[L]}if(void 0===T)switch(w.dataType){case D.e.ANIMATIONTYPE_FLOAT:T=0;break;case D.e.ANIMATIONTYPE_QUATERNION:T=D.l;break;case D.e.ANIMATIONTYPE_VECTOR3:T=D.t;break;case D.e.ANIMATIONTYPE_VECTOR2:T=D.p;break;case D.e.ANIMATIONTYPE_SIZE:T=D.o;break;case D.e.ANIMATIONTYPE_COLOR3:T=D.f;break;case D.e.ANIMATIONTYPE_COLOR4:T=D.j}let q;if(this._host&&this._host.syncRoot){const L=this._host.syncRoot;q=i+C*((L.masterFrame-L.fromFrame)/(L.toFrame-L.fromFrame))}else q=c>0&&i>P||c<0&&i<P?U&&0!==C?P+c%C:i:U&&0!==C?i+c%C:P;const H=this._events;if(!S&&(M>0&&this.currentFrame>q||M<0&&this.currentFrame<q)||S&&F){this._onLoop();for(let L=0;L<H.length;L++)H[L].onlyOnce||(H[L].isDone=!1);this._animationState.key=M>0?0:w.getKeys().length-1}this._currentFrame=q,this._animationState.repeatCount=0===C?0:c/C|0,this._animationState.highLimitValue=r,this._animationState.offsetValue=T;const j=w._interpolate(q,this._animationState);if(this.setValue(j,a),H.length)for(let D=0;D<H.length;D++)if(C>=0&&q>=H[D].frame&&H[D].frame>=i||C<0&&q<=H[D].frame&&H[D].frame<=i){const L=H[D];L.isDone||(L.onlyOnce&&(H.splice(D,1),D--),L.isDone=!0,L.action(q))}return U||(this._stopped=!0),U}}var C=P(1142);class T{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(L){this._weight=-1!==L?Math.min(Math.max(L,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(L){for(let i=0;i<this._runtimeAnimations.length;i++){this._runtimeAnimations[i]._prepareForSpeedRatioChange(L)}this._speedRatio=L,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(L,i){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,D=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,M=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,w=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,U=arguments.length>8?arguments[8]:void 0,C=arguments.length>9&&void 0!==arguments[9]&&arguments[9],T=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=i,this.fromFrame=P,this.toFrame=D,this.loopAnimation=M,this.onAnimationEnd=w,this.onAnimationLoop=U,this.isAdditive=C,this.playOrder=T,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Zd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new V.b,this.onAnimationLoopObservable=new V.b,this._scene=L,O&&this.appendAnimations(i,O),this._speedRatio=a,L._activeAnimatables.push(this)}syncWith(L){if(this._syncRoot=L,L){const L=this._scene._activeAnimatables.indexOf(this);L>-1&&(this._scene._activeAnimatables.splice(L,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(L,i){for(let P=0;P<i.length;P++){const D=i[P],V=new U(L,D,this._scene,this);V._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(V)}}getAnimationByTargetProperty(L){const i=this._runtimeAnimations;for(let P=0;P<i.length;P++)if(i[P].animation.targetProperty===L)return i[P].animation;return null}getRuntimeAnimationByTargetProperty(L){const i=this._runtimeAnimations;for(let P=0;P<i.length;P++)if(i[P].animation.targetProperty===L)return i[P];return null}reset(){const L=this._runtimeAnimations;for(let i=0;i<L.length;i++)L[i].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(L){const i=this._runtimeAnimations;for(let P=0;P<i.length;P++)i[P].animation.enableBlending=!0,i[P].animation.blendingSpeed=L}disableBlending(){const L=this._runtimeAnimations;for(let i=0;i<L.length;i++)L[i].animation.enableBlending=!1}goToFrame(L){const i=this._runtimeAnimations;if(i[0]){const P=i[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??i[0].currentFrame;const D=0===this.speedRatio?0:(L-this._frameToSyncFromJump)/P*1e3/this.speedRatio;this._manualJumpDelay=-D}for(let P=0;P<i.length;P++)i[P].goToFrame(L,this._weight);this._goToFrame=L}get paused(){return this.Zd}pause(){this.Zd||(this.Zd=!0)}restart(){this.Zd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(L,i){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],D=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(L||i){const V=this._scene._activeAnimatables.indexOf(this);if(V>-1){const M=this._runtimeAnimations;for(let P=M.length-1;P>=0;P--){const D=M[P];L&&D.animation.name!=L||(i&&!i(D.target)||(D.dispose(),M.splice(P,1)))}0==M.length&&(P||this._scene._activeAnimatables.splice(V,1),D||this._raiseOnAnimationEnd())}}else{const L=this._scene._activeAnimatables.indexOf(this);if(L>-1){P||this._scene._activeAnimatables.splice(L,1);const i=this._runtimeAnimations;for(let L=0;L<i.length;L++)i[L].dispose();this._runtimeAnimations.length=0,D||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((L=>{this.onAnimationEndObservable.add((()=>{L(this)}),void 0,void 0,this,!0)}))}_animate(L){if(this.Zd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=L),!0;if(null===this._localDelayOffset?(this._localDelayOffset=L,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=L-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let i=!1;const P=this._runtimeAnimations;let D;for(D=0;D<P.length;D++){const V=P[D].animate(L-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);i=i||V}if(this.animationStarted=i,!i){if(this.disposeOnEnd)for(D=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(D,1),D=0;D<P.length;D++)P[D].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return i}}function c(L){if(0===L.totalWeight&&0===L.totalAdditiveWeight)return L.originalValue;let i=1;const P=O.j.ge[0],D=O.j.ge[1],V=O.j.Quaternion[0];let M=0;const a=L.animations[0],w=L.originalValue;let U=1,C=!1;if(L.totalWeight<1)U=1-L.totalWeight,w.decompose(D,V,P);else{if(M=1,i=L.totalWeight,U=a.weight/i,1==U){if(!L.totalAdditiveWeight)return a.currentValue;C=!0}a.currentValue.decompose(D,V,P)}if(!C){D.scaleInPlace(U),P.scaleInPlace(U),V.scaleInPlace(U);for(let a=M;a<L.animations.length;a++){const M=L.animations[a];if(0===M.weight)continue;U=M.weight/i;const w=O.j.ge[2],C=O.j.ge[3],T=O.j.Quaternion[1];M.currentValue.decompose(C,T,w),C.scaleAndAddToRef(U,D),T.scaleAndAddToRef(O.g.Dot(V,T)>0?U:-U,V),w.scaleAndAddToRef(U,P)}V.normalize()}for(let c=0;c<L.additiveAnimations.length;c++){const i=L.additiveAnimations[c];if(0===i.weight)continue;const M=O.j.ge[2],a=O.j.ge[3],w=O.j.Quaternion[1];i.currentValue.decompose(a,w,M),a.multiplyToRef(D,a),O.p.LerpToRef(D,a,i.weight,D),V.multiplyToRef(w,w),O.g.SlerpToRef(V,w,i.weight,V),M.scaleAndAddToRef(i.weight,P)}const T=a?a._animationState.workValue:O.j.Matrix[0].clone();return O.d.ComposeToRef(D,V,P,T),T}function r(L,i){if(0===L.totalWeight&&0===L.totalAdditiveWeight)return i;const P=L.animations[0],D=L.originalValue;let V=i;if(0===L.totalWeight&&L.totalAdditiveWeight>0)V.p(D);else if(1===L.animations.length){if(O.g.SlerpToRef(D,P.currentValue,Math.min(1,L.totalWeight),V),0===L.totalAdditiveWeight)return V}else if(L.animations.length>1){let P,M,a=1;if(L.totalWeight<1){const i=1-L.totalWeight;P=[],M=[],P.push(D),M.push(i)}else{if(2===L.animations.length&&(O.g.SlerpToRef(L.animations[0].currentValue,L.animations[1].currentValue,L.animations[1].weight/L.totalWeight,i),0===L.totalAdditiveWeight))return i;P=[],M=[],a=L.totalWeight}for(let i=0;i<L.animations.length;i++){const D=L.animations[i];P.push(D.currentValue),M.push(D.weight/a)}let w=0;for(let L=0;L<P.length;)L?(w+=M[L],O.g.SlerpToRef(V,P[L],M[L]/w,V),L++):(O.g.SlerpToRef(P[L],P[L+1],M[L+1]/(M[L]+M[L+1]),i),V=i,w=M[L]+M[L+1],L+=2)}for(let M=0;M<L.additiveAnimations.length;M++){const i=L.additiveAnimations[M];0!==i.weight&&(V.multiplyToRef(i.currentValue,O.j.Quaternion[0]),O.g.SlerpToRef(V,O.j.Quaternion[0],i.weight,V))}return V}var F,S,q=P(1213);F=q.e,(S=w.d)&&(S.prototype.copyAnimationRange=function(L,i,P){let V=arguments.length>3&&void 0!==arguments[3]&&arguments[3],M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new D.e(this.name,"_matrix",L.animations[0].framePerSecond,D.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const a=L.animations[0].getRange(i);if(!a)return!1;const w=a.from,O=a.to,U=L.animations[0].getKeys(),C=L.length,T=L.getParent(),c=this.getParent(),r=V&&T&&C&&this.length&&C!==this.length,F=r&&c&&T?c.length/T.length:1,S=V&&!c&&M&&(1!==M.x||1!==M.y||1!==M.z),q=this.animations[0].getKeys();let H,j,B;for(let D=0,u=U.length;D<u;D++)H=U[D],H.frame>=w&&H.frame<=O&&(V?(B=H.value.clone(),r?(j=B.getTranslation(),B.setTranslation(j.scaleInPlace(F))):S&&M?(j=B.getTranslation(),B.setTranslation(j.multiplyInPlace(M))):B=H.value):B=H.value,q.push({frame:H.frame+P,value:B}));return this.animations[0].createRange(i,w+P,O+P),!0}),F&&(F.prototype._animate=function(L){if(!this.animationsEnabled)return;const i=C.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=i}this.deltaTime=void 0!==L?L:this.useConstantAnimationDeltaTime?16:(i-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=i;const P=this._activeAnimatables;if(0===P.length)return;this._animationTime+=this.deltaTime;const V=this._animationTime;for(let D=0;D<P.length;D++){const L=P[D];!L._animate(V)&&L.disposeOnEnd&&D--}!function(L){if(L._registeredForLateAnimationBindings.length){for(let i=0;i<L._registeredForLateAnimationBindings.length;i++){const P=L._registeredForLateAnimationBindings.data[i];for(const L in P._lateAnimationHolders){const i=P._lateAnimationHolders[L],V=i.animations[0],M=i.originalValue;if(void 0===M||null===M)continue;const a=D.e.AllowMatrixDecomposeForInterpolation&&M.m;let w=P[L];if(a)w=c(i);else if(void 0!==M.w)w=r(i,w||O.g.Identity());else{let L=0,P=1;const a=V&&V._animationState.loopMode===D.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(i.totalWeight<1)w=a?M.clone?M.clone():M:V&&M.scale?M.scale(1-i.totalWeight):V?M*(1-i.totalWeight):M.clone?M.clone():M;else if(V){P=i.totalWeight;const D=V.weight/P;w=1!==D?V.currentValue.scale?V.currentValue.scale(D):V.currentValue*D:V.currentValue,a&&(w.addToRef?w.addToRef(M,w):w+=M),L=1}for(let D=L;D<i.animations.length;D++){const L=i.animations[D],V=L.weight/P;V&&(L.currentValue.scaleAndAddToRef?L.currentValue.scaleAndAddToRef(V,w):w+=L.currentValue*V)}for(let D=0;D<i.additiveAnimations.length;D++){const L=i.additiveAnimations[D],P=L.weight;P&&(L.currentValue.scaleAndAddToRef?L.currentValue.scaleAndAddToRef(P,w):w+=L.currentValue*P)}}P[L]=w}P._lateAnimationHolders={}}L._registeredForLateAnimationBindings.reset()}}(this)},F.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((L,i)=>L.playOrder-i.playOrder))},F.prototype.beginWeightedAnimation=function(L,i,P){let D=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,V=arguments.length>4?arguments[4]:void 0,M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,a=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,O=arguments.length>8?arguments[8]:void 0,U=arguments.length>9?arguments[9]:void 0,C=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const T=this.beginAnimation(L,i,P,V,M,a,w,!1,O,U,C);return T.weight=D,T},F.prototype.beginAnimation=function(L,i,P,D){let V=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,M=arguments.length>5?arguments[5]:void 0,a=arguments.length>6?arguments[6]:void 0,w=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],O=arguments.length>8?arguments[8]:void 0,U=arguments.length>9?arguments[9]:void 0,C=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(V<0){const L=i;i=P,P=L,V=-V}i>P&&(V=-V),w&&this.stopAnimation(L,void 0,O),a||(a=new T(this,L,i,P,D,V,M,void 0,U,C));const c=!O||O(L);if(L.animations&&c&&a.appendAnimations(L,L.animations),L.getAnimatables){const C=L.getAnimatables();for(let L=0;L<C.length;L++)this.beginAnimation(C[L],i,P,D,V,M,a,w,O,U)}return a.reset(),a},F.prototype.beginHierarchyAnimation=function(L,i,P,D,V){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,a=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,O=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],U=arguments.length>9?arguments[9]:void 0,C=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const T=L.getDescendants(i),c=[];c.push(this.beginAnimation(L,P,D,V,M,a,w,O,U,void 0,C));for(const r of T)c.push(this.beginAnimation(r,P,D,V,M,a,w,O,U,void 0,C));return c},F.prototype.beginDirectAnimation=function(L,i,P,D,V){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(M<0){const L=P;P=D,D=L,M=-M}return P>D&&(M=-M),new T(this,L,P,D,V,M,arguments.length>6?arguments[6]:void 0,i,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},F.prototype.beginDirectHierarchyAnimation=function(L,i,P,D,V,M,a,w,O){let U=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const C=L.getDescendants(i),T=[];T.push(this.beginDirectAnimation(L,P,D,V,M,a,w,O,U));for(const c of C)T.push(this.beginDirectAnimation(c,P,D,V,M,a,w,O,U));return T},F.prototype.getAnimatableByTarget=function(L){for(let i=0;i<this._activeAnimatables.length;i++)if(this._activeAnimatables[i].target===L)return this._activeAnimatables[i];return null},F.prototype.getAllAnimatablesByTarget=function(L){const i=[];for(let P=0;P<this._activeAnimatables.length;P++)this._activeAnimatables[P].target===L&&i.push(this._activeAnimatables[P]);return i},F.prototype.stopAnimation=function(L,i,P){const D=this.getAllAnimatablesByTarget(L);for(const V of D)V.stop(i,P)},F.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let L=0;L<this._activeAnimatables.length;L++)this._activeAnimatables[L].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const L of this.animationGroups)L.stop()});class H{getClassName(){return"TargetedAnimation"}serialize(){const L={};return L.animation=this.animation.serialize(),L.targetId=this.target.id,L}}class j{get mask(){return this._mask}set mask(L){this._mask!==L&&(this._mask=L,this.syncWithMask(!0))}syncWithMask(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||L){this._numActiveAnimatables=0;for(let L=0;L<this._animatables.length;++L){const i=this._animatables[L];!this.mask||this.mask.disabled||this.mask.retainsTarget(i.target.name)?(this._numActiveAnimatables++,i.paused&&i.restart()):i.paused||i.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let L=0;L<this._animatables.length;++L){const i=this._animatables[L];this.mask.retainsTarget(i.target.name)||(i.stop(),this._animatables.splice(L,1),--L)}for(let L=0;L<this._targetedAnimations.length;L++){const i=this._targetedAnimations[L];this.mask.retainsTarget(i.target.name)||(this._targetedAnimations.splice(L,1),--L)}}}get from(){return this._from}set from(L){if(this._from!==L){this._from=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].fromFrame=this._from}}}get to(){return this._to}set to(L){if(this._to!==L){this._to=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(L){if(this._speedRatio!==L){this._speedRatio=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(L){if(this._loopAnimation!==L){this._loopAnimation=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(L){if(this._isAdditive!==L){this._isAdditive=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(L){this._weight!==L&&(this._weight=L,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(L){if(this._playOrder!==L&&(this._playOrder=L,this._animatables.length>0)){for(let L=0;L<this._animatables.length;L++)this._animatables[L].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(L){if(this._enableBlending!==L&&(this._enableBlending=L,null!==L))for(let i=0;i<this._targetedAnimations.length;++i)this._targetedAnimations[i].animation.enableBlending=L}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(L){if(this._blendingSpeed!==L&&(this._blendingSpeed=L,null!==L))for(let i=0;i<this._targetedAnimations.length;++i)this._targetedAnimations[i].animation.blendingSpeed=L}getLength(L,i){L=L??this._from;return((i=i??this._to)-L)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(L){let i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],D=arguments.length>3?arguments[3]:void 0;if(0===L.length)return null;D=D??L[0].weight;let V=Number.MAX_VALUE,M=-Number.MAX_VALUE;if(P)for(const w of L)w.from<V&&(V=w.from),w.to>M&&(M=w.to);const a=new j(L[0].name+"_merged",L[0]._scene,D);for(const w of L){P&&w.normalize(V,M);for(const L of w.targetedAnimations)a.addTargetedAnimation(L.animation,L.target);i&&w.dispose()}return a}constructor(L){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,D=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=L,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new V.b,this.onAnimationLoopObservable=new V.b,this.onAnimationGroupLoopObservable=new V.b,this.onAnimationGroupEndObservable=new V.b,this.onAnimationGroupPauseObservable=new V.b,this.onAnimationGroupPlayObservable=new V.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=i||M.c.LastCreatedScene,this._weight=P,this._playOrder=D,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(L,i){const P=new H;P.animation=L,P.target=i;const D=L.getKeys();return this._from>D[0].frame&&(this._from=D[0].frame),this._to<D[D.length-1].frame&&(this._to=D[D.length-1].frame),null!==this._enableBlending&&(L.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(L.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(P),this._shouldStart=!0,P}removeTargetedAnimation(L){for(let i=this._targetedAnimations.length-1;i>-1;i--){this._targetedAnimations[i].animation===L&&this._targetedAnimations.splice(i,1)}}normalize(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==L&&(L=this._from),null==i&&(i=this._to);for(let P=0;P<this._targetedAnimations.length;P++){const D=this._targetedAnimations[P].animation.getKeys(),V=D[0],M=D[D.length-1];if(V.frame>L){const i={frame:L,value:V.value,inTangent:V.inTangent,outTangent:V.outTangent,interpolation:V.interpolation};D.splice(0,0,i)}if(M.frame<i){const L={frame:i,value:M.value,inTangent:M.inTangent,outTangent:M.outTangent,interpolation:M.interpolation};D.push(L)}}return this._from=L,this._to=i,this}_processLoop(L,i,P){L.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(i),this._animationLoopFlags[P]||(this._animationLoopFlags[P]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0,D=arguments.length>3?arguments[3]:void 0,V=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=L,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let M=0;M<this._targetedAnimations.length;M++){const a=this._targetedAnimations[M],w=this._scene.beginDirectAnimation(a.target,[a.animation],void 0!==P?P:this._from,void 0!==D?D:this._to,L,i,void 0,void 0,void 0!==V?V:this._isAdditive);w.weight=this._weight,w.playOrder=this._playOrder,w.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(a),this._checkAnimationGroupEnded(w)},this._processLoop(w,a,M),this._animatables.push(w)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=i,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let L=0;L<this._animatables.length;L++){this._animatables[L].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(L){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==L&&(this.loopAnimation=L),this.restart()):(this.stop(),this.start(L,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let L=0;L<this._animatables.length;L++){this._animatables[L].reset()}return this}restart(){if(!this._isStarted)return this;for(let L=0;L<this._animatables.length;L++){this._animatables[L].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const i=this._animatables.slice();for(let D=0;D<i.length;D++)i[D].stop(void 0,void 0,!0,L);let P=0;for(let D=0;D<this._scene._activeAnimatables.length;D++){const i=this._scene._activeAnimatables[D];i._runtimeAnimations.length>0?this._scene._activeAnimatables[P++]=i:L&&this._checkAnimationGroupEnded(i,L)}return this._scene._activeAnimatables.length=P,this._isStarted=!1,this}setWeightForAllAnimatables(L){for(let i=0;i<this._animatables.length;i++){this._animatables[i].weight=L}return this}syncAllAnimationsWith(L){for(let i=0;i<this._animatables.length;i++){this._animatables[i].syncWith(L)}return this}goToFrame(L){if(!this._isStarted)return this;for(let i=0;i<this._animatables.length;i++){this._animatables[i].goToFrame(L)}return this}getCurrentFrame(){var L;return(null===(L=this.animatables[0])||void 0===L?void 0:L.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const L=this._scene.animationGroups.indexOf(this);if(L>-1&&this._scene.animationGroups.splice(L,1),this._parentContainer){const L=this._parentContainer.animationGroups.indexOf(this);L>-1&&this._parentContainer.animationGroups.splice(L,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(L){let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const P=this._animatables.indexOf(L);P>-1&&this._animatables.splice(P,1),0===this._animatables.length&&(this._isStarted=!1,i||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(L,i){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const D=new j(L||this.name,this._scene,this._weight,this._playOrder);D._from=this.from,D._to=this.to,D._speedRatio=this.speedRatio,D._loopAnimation=this.loopAnimation,D._isAdditive=this.isAdditive,D._enableBlending=this.enableBlending,D._blendingSpeed=this.blendingSpeed,D.metadata=this.metadata,D.mask=this.mask;for(const V of this._targetedAnimations)D.addTargetedAnimation(P?V.animation.clone():V.animation,i?i(V.target):V.target);return D}serialize(){const L={};L.name=this.name,L.from=this.from,L.to=this.to,L.speedRatio=this.speedRatio,L.loopAnimation=this.loopAnimation,L.isAdditive=this.isAdditive,L.weight=this.weight,L.playOrder=this.playOrder,L.enableBlending=this.enableBlending,L.blendingSpeed=this.blendingSpeed,L.targetedAnimations=[];for(let i=0;i<this.targetedAnimations.length;i++){const P=this.targetedAnimations[i];L.targetedAnimations[i]=P.serialize()}return a.d&&a.d.HasTags(this)&&(L.tags=a.d.GetTags(this)),this.metadata&&(L.metadata=this.metadata),L}static Parse(L,i){const P=new j(L.name,i,L.weight,L.playOrder);for(let V=0;V<L.targetedAnimations.length;V++){const M=L.targetedAnimations[V],a=D.e.Parse(M.animation),w=M.targetId;if("influence"===M.animation.property){const L=i.getMorphTargetById(w);L&&P.addTargetedAnimation(a,L)}else{const L=i.getNodeById(w);null!=L&&P.addTargetedAnimation(a,L)}}return a.d&&a.d.AddTagsTo(P,L.tags),null!==L.from&&null!==L.to&&P.normalize(L.from,L.to),void 0!==L.speedRatio&&(P._speedRatio=L.speedRatio),void 0!==L.loopAnimation&&(P._loopAnimation=L.loopAnimation),void 0!==L.isAdditive&&(P._isAdditive=L.isAdditive),void 0!==L.weight&&(P._weight=L.weight),void 0!==L.playOrder&&(P._playOrder=L.playOrder),void 0!==L.enableBlending&&(P._enableBlending=L.enableBlending),void 0!==L.blendingSpeed&&(P._blendingSpeed=L.blendingSpeed),void 0!==L.metadata&&(P.metadata=L.metadata),P}static MakeAnimationAdditive(L,i,P){let V;V="object"===typeof i?i:{referenceFrame:i,range:P,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let M=L;V.cloneOriginalAnimationGroup&&(M=L.clone(V.clonedAnimationGroupName||M.name));const a=M.targetedAnimations;for(let w=0;w<a.length;w++){const L=a[w];L.animation=D.e.MakeAnimationAdditive(L.animation,V)}if(M.isAdditive=!0,V.clipKeys){let L=Number.MAX_VALUE,i=-Number.MAX_VALUE;const P=M.targetedAnimations;for(let D=0;D<P.length;D++){const V=P[D].animation.getKeys();L>V[0].frame&&(L=V[0].frame),i<V[V.length-1].frame&&(i=V[V.length-1].frame)}M._from=L,M._to=i}return M}static ClipKeys(L,i,P,D,V){const M=L.clone(D||L.name);return j.ClipKeysInPlace(M,i,P,V)}static ClipKeysInPlace(L,i,P,D){return j.ClipInPlace(L,i,P,D,!1)}static ClipFrames(L,i,P,D,V){const M=L.clone(D||L.name);return j.ClipFramesInPlace(M,i,P,V)}static ClipFramesInPlace(L,i,P,D){return j.ClipInPlace(L,i,P,D,!0)}static ClipInPlace(L,i,P,D){let V=arguments.length>4&&void 0!==arguments[4]&&arguments[4],M=Number.MAX_VALUE,a=-Number.MAX_VALUE;const w=L.targetedAnimations;for(let O=0;O<w.length;O++){const L=w[O],U=D?L.animation:L.animation.clone();V&&(U.createKeyForFrame(i),U.createKeyForFrame(P));const C=U.getKeys(),T=[];let c=Number.MAX_VALUE;for(let D=0;D<C.length;D++){const L=C[D];if(!V&&D>=i&&D<=P||V&&L.frame>=i&&L.frame<=P){const i={frame:L.frame,value:L.value.clone?L.value.clone():L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation,lockedTangent:L.lockedTangent};c===Number.MAX_VALUE&&(c=i.frame),i.frame-=c,T.push(i)}}0!==T.length?(M>T[0].frame&&(M=T[0].frame),a<T[T.length-1].frame&&(a=T[T.length-1].frame),U.setKeys(T,!0),L.animation=U):(w.splice(O,1),O--)}return L._from=M,L._to=a,L}getClassName(){return"AnimationGroup"}toString(L){let i="Name: "+this.name;return i+=", type: "+this.getClassName(),L&&(i+=", from: "+this._from,i+=", to: "+this._to,i+=", isStarted: "+this._isStarted,i+=", speedRatio: "+this._speedRatio,i+=", targetedAnimations length: "+this._targetedAnimations.length,i+=", animatables length: "+this._animatables),i}}}}]);