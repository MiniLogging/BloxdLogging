"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{13506:(x,Z,l)=>{l.r(Z),l.d(Z,{AnimationGroup:()=>X,TargetedAnimation:()=>v});var t=l(12882),L=l(1039),z=l(1070),A=l(1233),P=l(12879),C=l(1043);class j{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(x,Z,l,L){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=Z,this._target=x,this._scene=l,this._host=L,this._activeTargets=[],Z._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===t.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=C.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const x={frame:0,value:this._minValue};this._keys.splice(0,0,x)}if(this._target instanceof Array){let x=0;for(const Z of this._target)this._preparePath(Z,x),this._getOriginalValues(x),x++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const z=Z.getEvents();z&&z.length>0&&z.forEach((x=>{this._events.push(x._clone())})),this._enableBlending=x&&x.animationPropertiesOverride?x.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(x){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const l=this._animation.targetPropertyPath;if(l.length>1){let t=x;for(let x=0;x<l.length-1;x++){const Z=l[x];if(t=t[Z],void 0===t)throw new Error(`Invalid property (${Z}) in property path (${l.join(".")})`)}this._targetPath=l[l.length-1],this._activeTargets[Z]=t}else this._targetPath=l[0],this._activeTargets[Z]=x;if(void 0===this._activeTargets[Z][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${l.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let x=0;for(const Z of this._target)void 0!==this._originalValue[x]&&this._setValue(Z,this._activeTargets[x],this._originalValue[x],-1,x),x++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let x=0;x<this._events.length;x++)this._events[x].isDone=!1}isStopped(){return this._stopped}dispose(){const x=this._animation.runtimeAnimations.indexOf(this);x>-1&&this._animation.runtimeAnimations.splice(x,1)}setValue(x,Z){if(this._targetIsArray)for(let l=0;l<this._target.length;l++){const t=this._target[l];this._setValue(t,this._activeTargets[l],x,Z,l)}else this._setValue(this._target,this._directTarget,x,Z,0)}_getOriginalValues(){let x,Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const l=this._activeTargets[Z];x=l.getLocalMatrix&&"_matrix"===this._targetPath?l.getLocalMatrix():l[this._targetPath],x&&x.clone?this._originalValue[Z]=x.clone():this._originalValue[Z]=x}_registerTargetForLateAnimationBinding(x,Z){const l=x.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(l),l._lateAnimationHolders||(l._lateAnimationHolders={}),l._lateAnimationHolders[x.targetPath]||(l._lateAnimationHolders[x.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:Z}),x.isAdditive?(l._lateAnimationHolders[x.targetPath].additiveAnimations.push(x),l._lateAnimationHolders[x.targetPath].totalAdditiveWeight+=x.weight):(l._lateAnimationHolders[x.targetPath].animations.push(x),l._lateAnimationHolders[x.targetPath].totalWeight+=x.weight)}_setValue(x,Z,l,L,z){if(this._currentActiveTarget=Z,this._weight=L,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const x=Z[this._targetPath];x.clone?this._originalBlendValue=x.clone():this._originalBlendValue=x}this._originalBlendValue.m?t.c.AllowMatrixDecomposeForInterpolation?this._currentValue?C.d.DecomposeLerpToRef(this._originalBlendValue,l,this._blendingFactor,this._currentValue):this._currentValue=C.d.DecomposeLerp(this._originalBlendValue,l,this._blendingFactor):this._currentValue?C.d.LerpToRef(this._originalBlendValue,l,this._blendingFactor,this._currentValue):this._currentValue=C.d.Lerp(this._originalBlendValue,l,this._blendingFactor):this._currentValue=t.c._UniversalLerp(this._originalBlendValue,l,this._blendingFactor);const L=x&&x.animationPropertiesOverride?x.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=L}else this._currentValue?this._currentValue.p?this._currentValue.p(l):this._currentValue=l:null!==l&&void 0!==l&&l.clone?this._currentValue=l.clone():this._currentValue=l;-1!==L?this._registerTargetForLateAnimationBinding(this,this._originalValue[z]):this._animationState.loopMode===t.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[z],Z[this._targetPath]):Z[this._targetPath]=this._originalValue[z]+this._currentValue:Z[this._targetPath]=this._currentValue,x.Ee&&x.Ee(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(x){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const l=this._animation.getKeys();x<l[0].frame?x=l[0].frame:x>l[l.length-1].frame&&(x=l[l.length-1].frame);const t=this._events;if(t.length)for(let z=0;z<t.length;z++)t[z].onlyOnce||(t[z].isDone=t[z].frame<x);this._currentFrame=x;const L=this._animation._interpolate(x,this._animationState);this.setValue(L,Z)}_prepareForSpeedRatioChange(x){const Z=this._previousElapsedTime*(this._animation.framePerSecond*x)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-Z}animate(x,Z,l,L,z){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const P=this._animation,C=P.targetPropertyPath;if(!C||C.length<1)return this._stopped=!0,!1;let j=!0;(Z<this._minFrame||Z>this._maxFrame)&&(Z=this._minFrame),(l<this._minFrame||l>this._maxFrame)&&(l=this._maxFrame);const V=l-Z;let Q,c=x*(P.framePerSecond*z)/1e3+this._absoluteFrameOffset,a=0,I=!1;const u=L&&this._animationState.loopMode===t.c.ANIMATIONLOOPMODE_YOYO;if(u){const x=(c-Z)/V,l=Math.sin(x*Math.PI);c=Math.abs(l)*V+Z;const t=l>=0?1:-1;this._yoyoDirection!==t&&(I=!0),this._yoyoDirection=t}if(this._previousElapsedTime=x,this._previousAbsoluteFrame=c,!L&&l>=Z&&(c>=V&&z>0||c<=0&&z<0))j=!1,a=P._getKeyValue(this._maxValue);else if(!L&&Z>=l&&(c<=V&&z<0||c>=0&&z>0))j=!1,a=P._getKeyValue(this._minValue);else if(this._animationState.loopMode!==t.c.ANIMATIONLOOPMODE_CYCLE){const x=l.toString()+Z.toString();if(!this._offsetsCache[x]){this._animationState.repeatCount=0,this._animationState.loopMode=t.c.ANIMATIONLOOPMODE_CYCLE;const L=P._interpolate(Z,this._animationState),z=P._interpolate(l,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),P.dataType){case t.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[x]=z-L;break;case t.c.ANIMATIONTYPE_QUATERNION:case t.c.ANIMATIONTYPE_VECTOR3:case t.c.ANIMATIONTYPE_VECTOR2:case t.c.ANIMATIONTYPE_SIZE:case t.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[x]=z.qd(L)}this._highLimitsCache[x]=z}a=this._highLimitsCache[x],Q=this._offsetsCache[x]}if(void 0===Q)switch(P.dataType){case t.c.ANIMATIONTYPE_FLOAT:Q=0;break;case t.c.ANIMATIONTYPE_QUATERNION:Q=t.l;break;case t.c.ANIMATIONTYPE_VECTOR3:Q=t.q;break;case t.c.ANIMATIONTYPE_VECTOR2:Q=t.p;break;case t.c.ANIMATIONTYPE_SIZE:Q=t.n;break;case t.c.ANIMATIONTYPE_COLOR3:Q=t.g;break;case t.c.ANIMATIONTYPE_COLOR4:Q=t.i}let n;if(this._host&&this._host.syncRoot){const x=this._host.syncRoot;n=Z+V*((x.masterFrame-x.fromFrame)/(x.toFrame-x.fromFrame))}else n=c>0&&Z>l||c<0&&Z<l?j&&0!==V?l+c%V:Z:j&&0!==V?Z+c%V:l;const v=this._events;if(!u&&(z>0&&this.currentFrame>n||z<0&&this.currentFrame<n)||u&&I){this._onLoop();for(let x=0;x<v.length;x++)v[x].onlyOnce||(v[x].isDone=!1);this._animationState.key=z>0?0:P.getKeys().length-1}this._currentFrame=n,this._animationState.repeatCount=0===V?0:c/V|0,this._animationState.highLimitValue=a,this._animationState.offsetValue=Q;const X=P._interpolate(n,this._animationState);if(this.setValue(X,A),v.length)for(let t=0;t<v.length;t++)if(V>=0&&n>=v[t].frame&&v[t].frame>=Z||V<0&&n<=v[t].frame&&v[t].frame<=Z){const x=v[t];x.isDone||(x.onlyOnce&&(v.splice(t,1),t--),x.isDone=!0,x.action(n))}return j||(this._stopped=!0),j}}var V=l(1201);class Q{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(x){this._weight=-1!==x?Math.min(Math.max(x,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(x){for(let Z=0;Z<this._runtimeAnimations.length;Z++){this._runtimeAnimations[Z]._prepareForSpeedRatioChange(x)}this._speedRatio=x,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(x,Z){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,z=arguments.length>4&&void 0!==arguments[4]&&arguments[4],A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,P=arguments.length>6?arguments[6]:void 0,C=arguments.length>7?arguments[7]:void 0,j=arguments.length>8?arguments[8]:void 0,V=arguments.length>9&&void 0!==arguments[9]&&arguments[9],Q=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=Z,this.fromFrame=l,this.toFrame=t,this.loopAnimation=z,this.onAnimationEnd=P,this.onAnimationLoop=j,this.isAdditive=V,this.playOrder=Q,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Xd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new L.c,this.onAnimationLoopObservable=new L.c,this._scene=x,C&&this.appendAnimations(Z,C),this._speedRatio=A,x._activeAnimatables.push(this)}syncWith(x){if(this._syncRoot=x,x){const x=this._scene._activeAnimatables.indexOf(this);x>-1&&(this._scene._activeAnimatables.splice(x,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(x,Z){for(let l=0;l<Z.length;l++){const t=Z[l],L=new j(x,t,this._scene,this);L._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(L)}}getAnimationByTargetProperty(x){const Z=this._runtimeAnimations;for(let l=0;l<Z.length;l++)if(Z[l].animation.targetProperty===x)return Z[l].animation;return null}getRuntimeAnimationByTargetProperty(x){const Z=this._runtimeAnimations;for(let l=0;l<Z.length;l++)if(Z[l].animation.targetProperty===x)return Z[l];return null}reset(){const x=this._runtimeAnimations;for(let Z=0;Z<x.length;Z++)x[Z].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(x){const Z=this._runtimeAnimations;for(let l=0;l<Z.length;l++)Z[l].animation.enableBlending=!0,Z[l].animation.blendingSpeed=x}disableBlending(){const x=this._runtimeAnimations;for(let Z=0;Z<x.length;Z++)x[Z].animation.enableBlending=!1}goToFrame(x){const Z=this._runtimeAnimations;if(Z[0]){const l=Z[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??Z[0].currentFrame;const t=0===this.speedRatio?0:(x-this._frameToSyncFromJump)/l*1e3/this.speedRatio;this._manualJumpDelay=-t}for(let l=0;l<Z.length;l++)Z[l].goToFrame(x,this._weight);this._goToFrame=x}get paused(){return this.Xd}pause(){this.Xd||(this.Xd=!0)}restart(){this.Xd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(x,Z){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(x||Z){const L=this._scene._activeAnimatables.indexOf(this);if(L>-1){const z=this._runtimeAnimations;for(let l=z.length-1;l>=0;l--){const t=z[l];x&&t.animation.name!=x||(Z&&!Z(t.target)||(t.dispose(),z.splice(l,1)))}0==z.length&&(l||this._scene._activeAnimatables.splice(L,1),t||this._raiseOnAnimationEnd())}}else{const x=this._scene._activeAnimatables.indexOf(this);if(x>-1){l||this._scene._activeAnimatables.splice(x,1);const Z=this._runtimeAnimations;for(let x=0;x<Z.length;x++)Z[x].dispose();this._runtimeAnimations.length=0,t||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((x=>{this.onAnimationEndObservable.add((()=>{x(this)}),void 0,void 0,this,!0)}))}_animate(x){if(this.Xd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=x),!0;if(null===this._localDelayOffset?(this._localDelayOffset=x,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=x-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let Z=!1;const l=this._runtimeAnimations;let t;for(t=0;t<l.length;t++){const L=l[t].animate(x-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);Z=Z||L}if(this.animationStarted=Z,!Z){if(this.disposeOnEnd)for(t=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(t,1),t=0;t<l.length;t++)l[t].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return Z}}function c(x){if(0===x.totalWeight&&0===x.totalAdditiveWeight)return x.originalValue;let Z=1;const l=C.f.ce[0],t=C.f.ce[1],L=C.f.Quaternion[0];let z=0;const A=x.animations[0],P=x.originalValue;let j=1,V=!1;if(x.totalWeight<1)j=1-x.totalWeight,P.decompose(t,L,l);else{if(z=1,Z=x.totalWeight,j=A.weight/Z,1==j){if(!x.totalAdditiveWeight)return A.currentValue;V=!0}A.currentValue.decompose(t,L,l)}if(!V){t.scaleInPlace(j),l.scaleInPlace(j),L.scaleInPlace(j);for(let A=z;A<x.animations.length;A++){const z=x.animations[A];if(0===z.weight)continue;j=z.weight/Z;const P=C.f.ce[2],V=C.f.ce[3],Q=C.f.Quaternion[1];z.currentValue.decompose(V,Q,P),V.scaleAndAddToRef(j,t),Q.scaleAndAddToRef(C.e.Dot(L,Q)>0?j:-j,L),P.scaleAndAddToRef(j,l)}L.normalize()}for(let c=0;c<x.additiveAnimations.length;c++){const Z=x.additiveAnimations[c];if(0===Z.weight)continue;const z=C.f.ce[2],A=C.f.ce[3],P=C.f.Quaternion[1];Z.currentValue.decompose(A,P,z),A.multiplyToRef(t,A),C.k.LerpToRef(t,A,Z.weight,t),L.multiplyToRef(P,P),C.e.SlerpToRef(L,P,Z.weight,L),z.scaleAndAddToRef(Z.weight,l)}const Q=A?A._animationState.workValue:C.f.Matrix[0].clone();return C.d.ComposeToRef(t,L,l,Q),Q}function a(x,Z){if(0===x.totalWeight&&0===x.totalAdditiveWeight)return Z;const l=x.animations[0],t=x.originalValue;let L=Z;if(0===x.totalWeight&&x.totalAdditiveWeight>0)L.p(t);else if(1===x.animations.length){if(C.e.SlerpToRef(t,l.currentValue,Math.min(1,x.totalWeight),L),0===x.totalAdditiveWeight)return L}else if(x.animations.length>1){let l,z,A=1;if(x.totalWeight<1){const Z=1-x.totalWeight;l=[],z=[],l.push(t),z.push(Z)}else{if(2===x.animations.length&&(C.e.SlerpToRef(x.animations[0].currentValue,x.animations[1].currentValue,x.animations[1].weight/x.totalWeight,Z),0===x.totalAdditiveWeight))return Z;l=[],z=[],A=x.totalWeight}for(let Z=0;Z<x.animations.length;Z++){const t=x.animations[Z];l.push(t.currentValue),z.push(t.weight/A)}let P=0;for(let x=0;x<l.length;)x?(P+=z[x],C.e.SlerpToRef(L,l[x],z[x]/P,L),x++):(C.e.SlerpToRef(l[x],l[x+1],z[x+1]/(z[x]+z[x+1]),Z),L=Z,P=z[x]+z[x+1],x+=2)}for(let z=0;z<x.additiveAnimations.length;z++){const Z=x.additiveAnimations[z];0!==Z.weight&&(L.multiplyToRef(Z.currentValue,C.f.Quaternion[0]),C.e.SlerpToRef(L,C.f.Quaternion[0],Z.weight,L))}return L}var I,u,n=l(1267);I=n.e,(u=P.d)&&(u.prototype.copyAnimationRange=function(x,Z,l){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3],z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new t.c(this.name,"_matrix",x.animations[0].framePerSecond,t.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const A=x.animations[0].getRange(Z);if(!A)return!1;const P=A.from,C=A.to,j=x.animations[0].getKeys(),V=x.length,Q=x.getParent(),c=this.getParent(),a=L&&Q&&V&&this.length&&V!==this.length,I=a&&c&&Q?c.length/Q.length:1,u=L&&!c&&z&&(1!==z.x||1!==z.y||1!==z.z),n=this.animations[0].getKeys();let v,X,W;for(let t=0,f=j.length;t<f;t++)v=j[t],v.frame>=P&&v.frame<=C&&(L?(W=v.value.clone(),a?(X=W.getTranslation(),W.setTranslation(X.scaleInPlace(I))):u&&z?(X=W.getTranslation(),W.setTranslation(X.multiplyInPlace(z))):W=v.value):W=v.value,n.push({frame:v.frame+l,value:W}));return this.animations[0].createRange(Z,P+l,C+l),!0}),I&&(I.prototype._animate=function(x){if(!this.animationsEnabled)return;const Z=V.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=Z}this.deltaTime=void 0!==x?x:this.useConstantAnimationDeltaTime?16:(Z-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=Z;const l=this._activeAnimatables;if(0===l.length)return;this._animationTime+=this.deltaTime;const L=this._animationTime;for(let t=0;t<l.length;t++){const x=l[t];!x._animate(L)&&x.disposeOnEnd&&t--}!function(x){if(x._registeredForLateAnimationBindings.length){for(let Z=0;Z<x._registeredForLateAnimationBindings.length;Z++){const l=x._registeredForLateAnimationBindings.data[Z];for(const x in l._lateAnimationHolders){const Z=l._lateAnimationHolders[x],L=Z.animations[0],z=Z.originalValue;if(void 0===z||null===z)continue;const A=t.c.AllowMatrixDecomposeForInterpolation&&z.m;let P=l[x];if(A)P=c(Z);else if(void 0!==z.w)P=a(Z,P||C.e.Identity());else{let x=0,l=1;const A=L&&L._animationState.loopMode===t.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(Z.totalWeight<1)P=A?z.clone?z.clone():z:L&&z.scale?z.scale(1-Z.totalWeight):L?z*(1-Z.totalWeight):z.clone?z.clone():z;else if(L){l=Z.totalWeight;const t=L.weight/l;P=1!==t?L.currentValue.scale?L.currentValue.scale(t):L.currentValue*t:L.currentValue,A&&(P.addToRef?P.addToRef(z,P):P+=z),x=1}for(let t=x;t<Z.animations.length;t++){const x=Z.animations[t],L=x.weight/l;L&&(x.currentValue.scaleAndAddToRef?x.currentValue.scaleAndAddToRef(L,P):P+=x.currentValue*L)}for(let t=0;t<Z.additiveAnimations.length;t++){const x=Z.additiveAnimations[t],l=x.weight;l&&(x.currentValue.scaleAndAddToRef?x.currentValue.scaleAndAddToRef(l,P):P+=x.currentValue*l)}}l[x]=P}l._lateAnimationHolders={}}x._registeredForLateAnimationBindings.reset()}}(this)},I.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((x,Z)=>x.playOrder-Z.playOrder))},I.prototype.beginWeightedAnimation=function(x,Z,l){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,L=arguments.length>4?arguments[4]:void 0,z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,P=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,j=arguments.length>9?arguments[9]:void 0,V=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const Q=this.beginAnimation(x,Z,l,L,z,A,P,!1,C,j,V);return Q.weight=t,Q},I.prototype.beginAnimation=function(x,Z,l,t){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,z=arguments.length>5?arguments[5]:void 0,A=arguments.length>6?arguments[6]:void 0,P=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],C=arguments.length>8?arguments[8]:void 0,j=arguments.length>9?arguments[9]:void 0,V=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(L<0){const x=Z;Z=l,l=x,L=-L}Z>l&&(L=-L),P&&this.stopAnimation(x,void 0,C),A||(A=new Q(this,x,Z,l,t,L,z,void 0,j,V));const c=!C||C(x);if(x.animations&&c&&A.appendAnimations(x,x.animations),x.getAnimatables){const V=x.getAnimatables();for(let x=0;x<V.length;x++)this.beginAnimation(V[x],Z,l,t,L,z,A,P,C,j)}return A.reset(),A},I.prototype.beginHierarchyAnimation=function(x,Z,l,t,L){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,P=arguments.length>7?arguments[7]:void 0,C=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],j=arguments.length>9?arguments[9]:void 0,V=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const Q=x.getDescendants(Z),c=[];c.push(this.beginAnimation(x,l,t,L,z,A,P,C,j,void 0,V));for(const a of Q)c.push(this.beginAnimation(a,l,t,L,z,A,P,C,j,void 0,V));return c},I.prototype.beginDirectAnimation=function(x,Z,l,t,L){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(z<0){const x=l;l=t,t=x,z=-z}return l>t&&(z=-z),new Q(this,x,l,t,L,z,arguments.length>6?arguments[6]:void 0,Z,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},I.prototype.beginDirectHierarchyAnimation=function(x,Z,l,t,L,z,A,P,C){let j=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const V=x.getDescendants(Z),Q=[];Q.push(this.beginDirectAnimation(x,l,t,L,z,A,P,C,j));for(const c of V)Q.push(this.beginDirectAnimation(c,l,t,L,z,A,P,C,j));return Q},I.prototype.getAnimatableByTarget=function(x){for(let Z=0;Z<this._activeAnimatables.length;Z++)if(this._activeAnimatables[Z].target===x)return this._activeAnimatables[Z];return null},I.prototype.getAllAnimatablesByTarget=function(x){const Z=[];for(let l=0;l<this._activeAnimatables.length;l++)this._activeAnimatables[l].target===x&&Z.push(this._activeAnimatables[l]);return Z},I.prototype.stopAnimation=function(x,Z,l){const t=this.getAllAnimatablesByTarget(x);for(const L of t)L.stop(Z,l)},I.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let x=0;x<this._activeAnimatables.length;x++)this._activeAnimatables[x].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const x of this.animationGroups)x.stop()});class v{getClassName(){return"TargetedAnimation"}serialize(){const x={};return x.animation=this.animation.serialize(),x.targetId=this.target.id,x}}class X{get mask(){return this._mask}set mask(x){this._mask!==x&&(this._mask=x,this.syncWithMask(!0))}syncWithMask(){let x=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||x){this._numActiveAnimatables=0;for(let x=0;x<this._animatables.length;++x){const Z=this._animatables[x];!this.mask||this.mask.disabled||this.mask.retainsTarget(Z.target.name)?(this._numActiveAnimatables++,Z.paused&&Z.restart()):Z.paused||Z.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let x=0;x<this._animatables.length;++x){const Z=this._animatables[x];this.mask.retainsTarget(Z.target.name)||(Z.stop(),this._animatables.splice(x,1),--x)}for(let x=0;x<this._targetedAnimations.length;x++){const Z=this._targetedAnimations[x];this.mask.retainsTarget(Z.target.name)||(this._targetedAnimations.splice(x,1),--x)}}}get from(){return this._from}set from(x){if(this._from!==x){this._from=x;for(let x=0;x<this._animatables.length;x++){this._animatables[x].fromFrame=this._from}}}get to(){return this._to}set to(x){if(this._to!==x){this._to=x;for(let x=0;x<this._animatables.length;x++){this._animatables[x].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(x){if(this._speedRatio!==x){this._speedRatio=x;for(let x=0;x<this._animatables.length;x++){this._animatables[x].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(x){if(this._loopAnimation!==x){this._loopAnimation=x;for(let x=0;x<this._animatables.length;x++){this._animatables[x].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(x){if(this._isAdditive!==x){this._isAdditive=x;for(let x=0;x<this._animatables.length;x++){this._animatables[x].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(x){this._weight!==x&&(this._weight=x,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(x){if(this._playOrder!==x&&(this._playOrder=x,this._animatables.length>0)){for(let x=0;x<this._animatables.length;x++)this._animatables[x].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(x){if(this._enableBlending!==x&&(this._enableBlending=x,null!==x))for(let Z=0;Z<this._targetedAnimations.length;++Z)this._targetedAnimations[Z].animation.enableBlending=x}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(x){if(this._blendingSpeed!==x&&(this._blendingSpeed=x,null!==x))for(let Z=0;Z<this._targetedAnimations.length;++Z)this._targetedAnimations[Z].animation.blendingSpeed=x}getLength(x,Z){x=x??this._from;return((Z=Z??this._to)-x)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(x){let Z=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=arguments.length>3?arguments[3]:void 0;if(0===x.length)return null;t=t??x[0].weight;let L=Number.MAX_VALUE,z=-Number.MAX_VALUE;if(l)for(const P of x)P.from<L&&(L=P.from),P.to>z&&(z=P.to);const A=new X(x[0].name+"_merged",x[0]._scene,t);for(const P of x){l&&P.normalize(L,z);for(const x of P.targetedAnimations)A.addTargetedAnimation(x.animation,x.target);Z&&P.dispose()}return A}constructor(x){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=x,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new L.c,this.onAnimationLoopObservable=new L.c,this.onAnimationGroupLoopObservable=new L.c,this.onAnimationGroupEndObservable=new L.c,this.onAnimationGroupPauseObservable=new L.c,this.onAnimationGroupPlayObservable=new L.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=Z||z.d.LastCreatedScene,this._weight=l,this._playOrder=t,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(x,Z){const l=new v;l.animation=x,l.target=Z;const t=x.getKeys();return this._from>t[0].frame&&(this._from=t[0].frame),this._to<t[t.length-1].frame&&(this._to=t[t.length-1].frame),null!==this._enableBlending&&(x.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(x.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(l),this._shouldStart=!0,l}removeTargetedAnimation(x){for(let Z=this._targetedAnimations.length-1;Z>-1;Z--){this._targetedAnimations[Z].animation===x&&this._targetedAnimations.splice(Z,1)}}normalize(){let x=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==x&&(x=this._from),null==Z&&(Z=this._to);for(let l=0;l<this._targetedAnimations.length;l++){const t=this._targetedAnimations[l].animation.getKeys(),L=t[0],z=t[t.length-1];if(L.frame>x){const Z={frame:x,value:L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation};t.splice(0,0,Z)}if(z.frame<Z){const x={frame:Z,value:z.value,inTangent:z.inTangent,outTangent:z.outTangent,interpolation:z.interpolation};t.push(x)}}return this._from=x,this._to=Z,this}_processLoop(x,Z,l){x.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(Z),this._animationLoopFlags[l]||(this._animationLoopFlags[l]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let x=arguments.length>0&&void 0!==arguments[0]&&arguments[0],Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,l=arguments.length>2?arguments[2]:void 0,t=arguments.length>3?arguments[3]:void 0,L=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=x,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let z=0;z<this._targetedAnimations.length;z++){const A=this._targetedAnimations[z],P=this._scene.beginDirectAnimation(A.target,[A.animation],void 0!==l?l:this._from,void 0!==t?t:this._to,x,Z,void 0,void 0,void 0!==L?L:this._isAdditive);P.weight=this._weight,P.playOrder=this._playOrder,P.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(A),this._checkAnimationGroupEnded(P)},this._processLoop(P,A,z),this._animatables.push(P)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=Z,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let x=0;x<this._animatables.length;x++){this._animatables[x].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(x){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==x&&(this.loopAnimation=x),this.restart()):(this.stop(),this.start(x,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let x=0;x<this._animatables.length;x++){this._animatables[x].reset()}return this}restart(){if(!this._isStarted)return this;for(let x=0;x<this._animatables.length;x++){this._animatables[x].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let x=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const Z=this._animatables.slice();for(let t=0;t<Z.length;t++)Z[t].stop(void 0,void 0,!0,x);let l=0;for(let t=0;t<this._scene._activeAnimatables.length;t++){const Z=this._scene._activeAnimatables[t];Z._runtimeAnimations.length>0?this._scene._activeAnimatables[l++]=Z:x&&this._checkAnimationGroupEnded(Z,x)}return this._scene._activeAnimatables.length=l,this._isStarted=!1,this}setWeightForAllAnimatables(x){for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].weight=x}return this}syncAllAnimationsWith(x){for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].syncWith(x)}return this}goToFrame(x){if(!this._isStarted)return this;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].goToFrame(x)}return this}getCurrentFrame(){var x;return(null===(x=this.animatables[0])||void 0===x?void 0:x.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const x=this._scene.animationGroups.indexOf(this);if(x>-1&&this._scene.animationGroups.splice(x,1),this._parentContainer){const x=this._parentContainer.animationGroups.indexOf(this);x>-1&&this._parentContainer.animationGroups.splice(x,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(x){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const l=this._animatables.indexOf(x);l>-1&&this._animatables.splice(l,1),0===this._animatables.length&&(this._isStarted=!1,Z||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(x,Z){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=new X(x||this.name,this._scene,this._weight,this._playOrder);t._from=this.from,t._to=this.to,t._speedRatio=this.speedRatio,t._loopAnimation=this.loopAnimation,t._isAdditive=this.isAdditive,t._enableBlending=this.enableBlending,t._blendingSpeed=this.blendingSpeed,t.metadata=this.metadata,t.mask=this.mask;for(const L of this._targetedAnimations)t.addTargetedAnimation(l?L.animation.clone():L.animation,Z?Z(L.target):L.target);return t}serialize(){const x={};x.name=this.name,x.from=this.from,x.to=this.to,x.speedRatio=this.speedRatio,x.loopAnimation=this.loopAnimation,x.isAdditive=this.isAdditive,x.weight=this.weight,x.playOrder=this.playOrder,x.enableBlending=this.enableBlending,x.blendingSpeed=this.blendingSpeed,x.targetedAnimations=[];for(let Z=0;Z<this.targetedAnimations.length;Z++){const l=this.targetedAnimations[Z];x.targetedAnimations[Z]=l.serialize()}return A.b&&A.b.HasTags(this)&&(x.tags=A.b.GetTags(this)),this.metadata&&(x.metadata=this.metadata),x}static Parse(x,Z){const l=new X(x.name,Z,x.weight,x.playOrder);for(let L=0;L<x.targetedAnimations.length;L++){const z=x.targetedAnimations[L],A=t.c.Parse(z.animation),P=z.targetId;if("influence"===z.animation.property){const x=Z.getMorphTargetById(P);x&&l.addTargetedAnimation(A,x)}else{const x=Z.getNodeById(P);null!=x&&l.addTargetedAnimation(A,x)}}return A.b&&A.b.AddTagsTo(l,x.tags),null!==x.from&&null!==x.to&&l.normalize(x.from,x.to),void 0!==x.speedRatio&&(l._speedRatio=x.speedRatio),void 0!==x.loopAnimation&&(l._loopAnimation=x.loopAnimation),void 0!==x.isAdditive&&(l._isAdditive=x.isAdditive),void 0!==x.weight&&(l._weight=x.weight),void 0!==x.playOrder&&(l._playOrder=x.playOrder),void 0!==x.enableBlending&&(l._enableBlending=x.enableBlending),void 0!==x.blendingSpeed&&(l._blendingSpeed=x.blendingSpeed),void 0!==x.metadata&&(l.metadata=x.metadata),l}static MakeAnimationAdditive(x,Z,l){let L;L="object"===typeof Z?Z:{referenceFrame:Z,range:l,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let z=x;L.cloneOriginalAnimationGroup&&(z=x.clone(L.clonedAnimationGroupName||z.name));const A=z.targetedAnimations;for(let P=0;P<A.length;P++){const x=A[P];x.animation=t.c.MakeAnimationAdditive(x.animation,L)}if(z.isAdditive=!0,L.clipKeys){let x=Number.MAX_VALUE,Z=-Number.MAX_VALUE;const l=z.targetedAnimations;for(let t=0;t<l.length;t++){const L=l[t].animation.getKeys();x>L[0].frame&&(x=L[0].frame),Z<L[L.length-1].frame&&(Z=L[L.length-1].frame)}z._from=x,z._to=Z}return z}static ClipKeys(x,Z,l,t,L){const z=x.clone(t||x.name);return X.ClipKeysInPlace(z,Z,l,L)}static ClipKeysInPlace(x,Z,l,t){return X.ClipInPlace(x,Z,l,t,!1)}static ClipFrames(x,Z,l,t,L){const z=x.clone(t||x.name);return X.ClipFramesInPlace(z,Z,l,L)}static ClipFramesInPlace(x,Z,l,t){return X.ClipInPlace(x,Z,l,t,!0)}static ClipInPlace(x,Z,l,t){let L=arguments.length>4&&void 0!==arguments[4]&&arguments[4],z=Number.MAX_VALUE,A=-Number.MAX_VALUE;const P=x.targetedAnimations;for(let C=0;C<P.length;C++){const x=P[C],j=t?x.animation:x.animation.clone();L&&(j.createKeyForFrame(Z),j.createKeyForFrame(l));const V=j.getKeys(),Q=[];let c=Number.MAX_VALUE;for(let t=0;t<V.length;t++){const x=V[t];if(!L&&t>=Z&&t<=l||L&&x.frame>=Z&&x.frame<=l){const Z={frame:x.frame,value:x.value.clone?x.value.clone():x.value,inTangent:x.inTangent,outTangent:x.outTangent,interpolation:x.interpolation,lockedTangent:x.lockedTangent};c===Number.MAX_VALUE&&(c=Z.frame),Z.frame-=c,Q.push(Z)}}0!==Q.length?(z>Q[0].frame&&(z=Q[0].frame),A<Q[Q.length-1].frame&&(A=Q[Q.length-1].frame),j.setKeys(Q,!0),x.animation=j):(P.splice(C,1),C--)}return x._from=z,x._to=A,x}getClassName(){return"AnimationGroup"}toString(x){let Z="Name: "+this.name;return Z+=", type: "+this.getClassName(),x&&(Z+=", from: "+this._from,Z+=", to: "+this._to,Z+=", isStarted: "+this._isStarted,Z+=", speedRatio: "+this._speedRatio,Z+=", targetedAnimations length: "+this._targetedAnimations.length,Z+=", animatables length: "+this._animatables),Z}}}}]);