"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12459:(V,H,t)=>{t.r(H),t.d(H,{AnimationGroup:()=>e,TargetedAnimation:()=>Q});var I=t(11784),Z=t(936),h=t(958),f=t(1100),m=t(11776),K=t(943);class E{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(V,H,t,Z){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=H,this._target=V,this._scene=t,this._host=Z,this._activeTargets=[],H._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===I.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=K.e.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const V={frame:0,value:this._minValue};this._keys.splice(0,0,V)}if(this._target instanceof Array){let V=0;for(const H of this._target)this._preparePath(H,V),this._getOriginalValues(V),V++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const h=H.getEvents();h&&h.length>0&&h.forEach((V=>{this._events.push(V._clone())})),this._enableBlending=V&&V.animationPropertiesOverride?V.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(V){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const t=this._animation.targetPropertyPath;if(t.length>1){let I=V;for(let V=0;V<t.length-1;V++){const H=t[V];if(I=I[H],void 0===I)throw new Error(`Invalid property (${H}) in property path (${t.join(".")})`)}this._targetPath=t[t.length-1],this._activeTargets[H]=I}else this._targetPath=t[0],this._activeTargets[H]=V;if(void 0===this._activeTargets[H][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${t.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let V=0;for(const H of this._target)void 0!==this._originalValue[V]&&this._setValue(H,this._activeTargets[V],this._originalValue[V],-1,V),V++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let V=0;V<this._events.length;V++)this._events[V].isDone=!1}isStopped(){return this._stopped}dispose(){const V=this._animation.runtimeAnimations.indexOf(this);V>-1&&this._animation.runtimeAnimations.splice(V,1)}setValue(V,H){if(this._targetIsArray)for(let t=0;t<this._target.length;t++){const I=this._target[t];this._setValue(I,this._activeTargets[t],V,H,t)}else this._setValue(this._target,this._directTarget,V,H,0)}_getOriginalValues(){let V,H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=this._activeTargets[H];V=t.getLocalMatrix&&"_matrix"===this._targetPath?t.getLocalMatrix():t[this._targetPath],V&&V.clone?this._originalValue[H]=V.clone():this._originalValue[H]=V}_registerTargetForLateAnimationBinding(V,H){const t=V.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(t),t._lateAnimationHolders||(t._lateAnimationHolders={}),t._lateAnimationHolders[V.targetPath]||(t._lateAnimationHolders[V.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:H}),V.isAdditive?(t._lateAnimationHolders[V.targetPath].additiveAnimations.push(V),t._lateAnimationHolders[V.targetPath].totalAdditiveWeight+=V.weight):(t._lateAnimationHolders[V.targetPath].animations.push(V),t._lateAnimationHolders[V.targetPath].totalWeight+=V.weight)}_setValue(V,H,t,Z,h){if(this._currentActiveTarget=H,this._weight=Z,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const V=H[this._targetPath];V.clone?this._originalBlendValue=V.clone():this._originalBlendValue=V}this._originalBlendValue.m?I.d.AllowMatrixDecomposeForInterpolation?this._currentValue?K.e.DecomposeLerpToRef(this._originalBlendValue,t,this._blendingFactor,this._currentValue):this._currentValue=K.e.DecomposeLerp(this._originalBlendValue,t,this._blendingFactor):this._currentValue?K.e.LerpToRef(this._originalBlendValue,t,this._blendingFactor,this._currentValue):this._currentValue=K.e.Lerp(this._originalBlendValue,t,this._blendingFactor):this._currentValue=I.d._UniversalLerp(this._originalBlendValue,t,this._blendingFactor);const Z=V&&V.animationPropertiesOverride?V.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=Z}else this._currentValue?this._currentValue.p?this._currentValue.p(t):this._currentValue=t:null!==t&&void 0!==t&&t.clone?this._currentValue=t.clone():this._currentValue=t;-1!==Z?this._registerTargetForLateAnimationBinding(this,this._originalValue[h]):this._animationState.loopMode===I.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[h],H[this._targetPath]):H[this._targetPath]=this._originalValue[h]+this._currentValue:H[this._targetPath]=this._currentValue,V.ne&&V.ne(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(V){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const t=this._animation.getKeys();V<t[0].frame?V=t[0].frame:V>t[t.length-1].frame&&(V=t[t.length-1].frame);const I=this._events;if(I.length)for(let h=0;h<I.length;h++)I[h].onlyOnce||(I[h].isDone=I[h].frame<V);this._currentFrame=V;const Z=this._animation._interpolate(V,this._animationState);this.setValue(Z,H)}_prepareForSpeedRatioChange(V){const H=this._previousElapsedTime*(this._animation.framePerSecond*V)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-H}animate(V,H,t,Z,h){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const m=this._animation,K=m.targetPropertyPath;if(!K||K.length<1)return this._stopped=!0,!1;let E=!0;(H<this._minFrame||H>this._maxFrame)&&(H=this._minFrame),(t<this._minFrame||t>this._maxFrame)&&(t=this._maxFrame);const d=t-H;let a,J=V*(m.framePerSecond*h)/1e3+this._absoluteFrameOffset,O=0,C=!1;const S=Z&&this._animationState.loopMode===I.d.ANIMATIONLOOPMODE_YOYO;if(S){const V=(J-H)/d,t=Math.sin(V*Math.PI);J=Math.abs(t)*d+H;const I=t>=0?1:-1;this._yoyoDirection!==I&&(C=!0),this._yoyoDirection=I}if(this._previousElapsedTime=V,this._previousAbsoluteFrame=J,!Z&&t>=H&&(J>=d&&h>0||J<=0&&h<0))E=!1,O=m._getKeyValue(this._maxValue);else if(!Z&&H>=t&&(J<=d&&h<0||J>=0&&h>0))E=!1,O=m._getKeyValue(this._minValue);else if(this._animationState.loopMode!==I.d.ANIMATIONLOOPMODE_CYCLE){const V=t.toString()+H.toString();if(!this._offsetsCache[V]){this._animationState.repeatCount=0,this._animationState.loopMode=I.d.ANIMATIONLOOPMODE_CYCLE;const Z=m._interpolate(H,this._animationState),h=m._interpolate(t,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),m.dataType){case I.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[V]=h-Z;break;case I.d.ANIMATIONTYPE_QUATERNION:case I.d.ANIMATIONTYPE_VECTOR3:case I.d.ANIMATIONTYPE_VECTOR2:case I.d.ANIMATIONTYPE_SIZE:case I.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[V]=h.Ec(Z)}this._highLimitsCache[V]=h}O=this._highLimitsCache[V],a=this._offsetsCache[V]}if(void 0===a)switch(m.dataType){case I.d.ANIMATIONTYPE_FLOAT:a=0;break;case I.d.ANIMATIONTYPE_QUATERNION:a=I.m;break;case I.d.ANIMATIONTYPE_VECTOR3:a=I.v;break;case I.d.ANIMATIONTYPE_VECTOR2:a=I.u;break;case I.d.ANIMATIONTYPE_SIZE:a=I.q;break;case I.d.ANIMATIONTYPE_COLOR3:a=I.e;break;case I.d.ANIMATIONTYPE_COLOR4:a=I.i}let v;if(this._host&&this._host.syncRoot){const V=this._host.syncRoot;v=H+d*((V.masterFrame-V.fromFrame)/(V.toFrame-V.fromFrame))}else v=J>0&&H>t||J<0&&H<t?E&&0!==d?t+J%d:H:E&&0!==d?H+J%d:t;const Q=this._events;if(!S&&(h>0&&this.currentFrame>v||h<0&&this.currentFrame<v)||S&&C){this._onLoop();for(let V=0;V<Q.length;V++)Q[V].onlyOnce||(Q[V].isDone=!1);this._animationState.key=h>0?0:m.getKeys().length-1}this._currentFrame=v,this._animationState.repeatCount=0===d?0:J/d|0,this._animationState.highLimitValue=O,this._animationState.offsetValue=a;const e=m._interpolate(v,this._animationState);if(this.setValue(e,f),Q.length)for(let I=0;I<Q.length;I++)if(d>=0&&v>=Q[I].frame&&Q[I].frame>=H||d<0&&v<=Q[I].frame&&Q[I].frame<=H){const V=Q[I];V.isDone||(V.onlyOnce&&(Q.splice(I,1),I--),V.isDone=!0,V.action(v))}return E||(this._stopped=!0),E}}var d=t(1071);class a{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(V){this._weight=-1!==V?Math.min(Math.max(V,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(V){for(let H=0;H<this._runtimeAnimations.length;H++){this._runtimeAnimations[H]._prepareForSpeedRatioChange(V)}this._speedRatio=V,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(V,H){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,h=arguments.length>4&&void 0!==arguments[4]&&arguments[4],f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,m=arguments.length>6?arguments[6]:void 0,K=arguments.length>7?arguments[7]:void 0,E=arguments.length>8?arguments[8]:void 0,d=arguments.length>9&&void 0!==arguments[9]&&arguments[9],a=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=H,this.fromFrame=t,this.toFrame=I,this.loopAnimation=h,this.onAnimationEnd=m,this.onAnimationLoop=E,this.isAdditive=d,this.playOrder=a,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.gf=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new Z.c,this.onAnimationLoopObservable=new Z.c,this._scene=V,K&&this.appendAnimations(H,K),this._speedRatio=f,V._activeAnimatables.push(this)}syncWith(V){if(this._syncRoot=V,V){const V=this._scene._activeAnimatables.indexOf(this);V>-1&&(this._scene._activeAnimatables.splice(V,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(V,H){for(let t=0;t<H.length;t++){const I=H[t],Z=new E(V,I,this._scene,this);Z._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(Z)}}getAnimationByTargetProperty(V){const H=this._runtimeAnimations;for(let t=0;t<H.length;t++)if(H[t].animation.targetProperty===V)return H[t].animation;return null}getRuntimeAnimationByTargetProperty(V){const H=this._runtimeAnimations;for(let t=0;t<H.length;t++)if(H[t].animation.targetProperty===V)return H[t];return null}reset(){const V=this._runtimeAnimations;for(let H=0;H<V.length;H++)V[H].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(V){const H=this._runtimeAnimations;for(let t=0;t<H.length;t++)H[t].animation.enableBlending=!0,H[t].animation.blendingSpeed=V}disableBlending(){const V=this._runtimeAnimations;for(let H=0;H<V.length;H++)V[H].animation.enableBlending=!1}goToFrame(V){const H=this._runtimeAnimations;if(H[0]){const t=H[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??H[0].currentFrame;const I=0===this.speedRatio?0:(V-this._frameToSyncFromJump)/t*1e3/this.speedRatio;this._manualJumpDelay=-I}for(let t=0;t<H.length;t++)H[t].goToFrame(V,this._weight);this._goToFrame=V}get paused(){return this.gf}pause(){this.gf||(this.gf=!0)}restart(){this.gf=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(V,H){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],I=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(V||H){const Z=this._scene._activeAnimatables.indexOf(this);if(Z>-1){const h=this._runtimeAnimations;for(let t=h.length-1;t>=0;t--){const I=h[t];V&&I.animation.name!=V||(H&&!H(I.target)||(I.dispose(),h.splice(t,1)))}0==h.length&&(t||this._scene._activeAnimatables.splice(Z,1),I||this._raiseOnAnimationEnd())}}else{const V=this._scene._activeAnimatables.indexOf(this);if(V>-1){t||this._scene._activeAnimatables.splice(V,1);const H=this._runtimeAnimations;for(let V=0;V<H.length;V++)H[V].dispose();this._runtimeAnimations.length=0,I||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((V=>{this.onAnimationEndObservable.add((()=>{V(this)}),void 0,void 0,this,!0)}))}_animate(V){if(this.gf)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=V),!0;if(null===this._localDelayOffset?(this._localDelayOffset=V,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=V-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let H=!1;const t=this._runtimeAnimations;let I;for(I=0;I<t.length;I++){const Z=t[I].animate(V-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);H=H||Z}if(this.animationStarted=H,!H){if(this.disposeOnEnd)for(I=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(I,1),I=0;I<t.length;I++)t[I].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return H}}function J(V){if(0===V.totalWeight&&0===V.totalAdditiveWeight)return V.originalValue;let H=1;const t=K.j.rd[0],I=K.j.rd[1],Z=K.j.Quaternion[0];let h=0;const f=V.animations[0],m=V.originalValue;let E=1,d=!1;if(V.totalWeight<1)E=1-V.totalWeight,m.decompose(I,Z,t);else{if(h=1,H=V.totalWeight,E=f.weight/H,1==E){if(!V.totalAdditiveWeight)return f.currentValue;d=!0}f.currentValue.decompose(I,Z,t)}if(!d){I.scaleInPlace(E),t.scaleInPlace(E),Z.scaleInPlace(E);for(let f=h;f<V.animations.length;f++){const h=V.animations[f];if(0===h.weight)continue;E=h.weight/H;const m=K.j.rd[2],d=K.j.rd[3],a=K.j.Quaternion[1];h.currentValue.decompose(d,a,m),d.scaleAndAddToRef(E,I),a.scaleAndAddToRef(K.h.Dot(Z,a)>0?E:-E,Z),m.scaleAndAddToRef(E,t)}Z.normalize()}for(let J=0;J<V.additiveAnimations.length;J++){const H=V.additiveAnimations[J];if(0===H.weight)continue;const h=K.j.rd[2],f=K.j.rd[3],m=K.j.Quaternion[1];H.currentValue.decompose(f,m,h),f.multiplyToRef(I,f),K.o.LerpToRef(I,f,H.weight,I),Z.multiplyToRef(m,m),K.h.SlerpToRef(Z,m,H.weight,Z),h.scaleAndAddToRef(H.weight,t)}const a=f?f._animationState.workValue:K.j.Matrix[0].clone();return K.e.ComposeToRef(I,Z,t,a),a}function O(V,H){if(0===V.totalWeight&&0===V.totalAdditiveWeight)return H;const t=V.animations[0],I=V.originalValue;let Z=H;if(0===V.totalWeight&&V.totalAdditiveWeight>0)Z.p(I);else if(1===V.animations.length){if(K.h.SlerpToRef(I,t.currentValue,Math.min(1,V.totalWeight),Z),0===V.totalAdditiveWeight)return Z}else if(V.animations.length>1){let t,h,f=1;if(V.totalWeight<1){const H=1-V.totalWeight;t=[],h=[],t.push(I),h.push(H)}else{if(2===V.animations.length&&(K.h.SlerpToRef(V.animations[0].currentValue,V.animations[1].currentValue,V.animations[1].weight/V.totalWeight,H),0===V.totalAdditiveWeight))return H;t=[],h=[],f=V.totalWeight}for(let H=0;H<V.animations.length;H++){const I=V.animations[H];t.push(I.currentValue),h.push(I.weight/f)}let m=0;for(let V=0;V<t.length;)V?(m+=h[V],K.h.SlerpToRef(Z,t[V],h[V]/m,Z),V++):(K.h.SlerpToRef(t[V],t[V+1],h[V+1]/(h[V]+h[V+1]),H),Z=H,m=h[V]+h[V+1],V+=2)}for(let h=0;h<V.additiveAnimations.length;h++){const H=V.additiveAnimations[h];0!==H.weight&&(Z.multiplyToRef(H.currentValue,K.j.Quaternion[0]),K.h.SlerpToRef(Z,K.j.Quaternion[0],H.weight,Z))}return Z}var C,S,v=t(1139);C=v.b,(S=m.d)&&(S.prototype.copyAnimationRange=function(V,H,t){let Z=arguments.length>3&&void 0!==arguments[3]&&arguments[3],h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new I.d(this.name,"_matrix",V.animations[0].framePerSecond,I.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const f=V.animations[0].getRange(H);if(!f)return!1;const m=f.from,K=f.to,E=V.animations[0].getKeys(),d=V.length,a=V.getParent(),J=this.getParent(),O=Z&&a&&d&&this.length&&d!==this.length,C=O&&J&&a?J.length/a.length:1,S=Z&&!J&&h&&(1!==h.x||1!==h.y||1!==h.z),v=this.animations[0].getKeys();let Q,e,W;for(let I=0,c=E.length;I<c;I++)Q=E[I],Q.frame>=m&&Q.frame<=K&&(Z?(W=Q.value.clone(),O?(e=W.getTranslation(),W.setTranslation(e.scaleInPlace(C))):S&&h?(e=W.getTranslation(),W.setTranslation(e.multiplyInPlace(h))):W=Q.value):W=Q.value,v.push({frame:Q.frame+t,value:W}));return this.animations[0].createRange(H,m+t,K+t),!0}),C&&(C.prototype._animate=function(V){if(!this.animationsEnabled)return;const H=d.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=H}this.deltaTime=void 0!==V?V:this.useConstantAnimationDeltaTime?16:(H-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=H;const t=this._activeAnimatables;if(0===t.length)return;this._animationTime+=this.deltaTime;const Z=this._animationTime;for(let I=0;I<t.length;I++){const V=t[I];!V._animate(Z)&&V.disposeOnEnd&&I--}!function(V){if(V._registeredForLateAnimationBindings.length){for(let H=0;H<V._registeredForLateAnimationBindings.length;H++){const t=V._registeredForLateAnimationBindings.data[H];for(const V in t._lateAnimationHolders){const H=t._lateAnimationHolders[V],Z=H.animations[0],h=H.originalValue;if(void 0===h||null===h)continue;const f=I.d.AllowMatrixDecomposeForInterpolation&&h.m;let m=t[V];if(f)m=J(H);else if(void 0!==h.w)m=O(H,m||K.h.Identity());else{let V=0,t=1;const f=Z&&Z._animationState.loopMode===I.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(H.totalWeight<1)m=f?h.clone?h.clone():h:Z&&h.scale?h.scale(1-H.totalWeight):Z?h*(1-H.totalWeight):h.clone?h.clone():h;else if(Z){t=H.totalWeight;const I=Z.weight/t;m=1!==I?Z.currentValue.scale?Z.currentValue.scale(I):Z.currentValue*I:Z.currentValue,f&&(m.addToRef?m.addToRef(h,m):m+=h),V=1}for(let I=V;I<H.animations.length;I++){const V=H.animations[I],Z=V.weight/t;Z&&(V.currentValue.scaleAndAddToRef?V.currentValue.scaleAndAddToRef(Z,m):m+=V.currentValue*Z)}for(let I=0;I<H.additiveAnimations.length;I++){const V=H.additiveAnimations[I],t=V.weight;t&&(V.currentValue.scaleAndAddToRef?V.currentValue.scaleAndAddToRef(t,m):m+=V.currentValue*t)}}t[V]=m}t._lateAnimationHolders={}}V._registeredForLateAnimationBindings.reset()}}(this)},C.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((V,H)=>V.playOrder-H.playOrder))},C.prototype.beginWeightedAnimation=function(V,H,t){let I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,Z=arguments.length>4?arguments[4]:void 0,h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,m=arguments.length>7?arguments[7]:void 0,K=arguments.length>8?arguments[8]:void 0,E=arguments.length>9?arguments[9]:void 0,d=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const a=this.beginAnimation(V,H,t,Z,h,f,m,!1,K,E,d);return a.weight=I,a},C.prototype.beginAnimation=function(V,H,t,I){let Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,h=arguments.length>5?arguments[5]:void 0,f=arguments.length>6?arguments[6]:void 0,m=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],K=arguments.length>8?arguments[8]:void 0,E=arguments.length>9?arguments[9]:void 0,d=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(Z<0){const V=H;H=t,t=V,Z=-Z}H>t&&(Z=-Z),m&&this.stopAnimation(V,void 0,K),f||(f=new a(this,V,H,t,I,Z,h,void 0,E,d));const J=!K||K(V);if(V.animations&&J&&f.appendAnimations(V,V.animations),V.getAnimatables){const d=V.getAnimatables();for(let V=0;V<d.length;V++)this.beginAnimation(d[V],H,t,I,Z,h,f,m,K,E)}return f.reset(),f},C.prototype.beginHierarchyAnimation=function(V,H,t,I,Z){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,m=arguments.length>7?arguments[7]:void 0,K=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],E=arguments.length>9?arguments[9]:void 0,d=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const a=V.getDescendants(H),J=[];J.push(this.beginAnimation(V,t,I,Z,h,f,m,K,E,void 0,d));for(const O of a)J.push(this.beginAnimation(O,t,I,Z,h,f,m,K,E,void 0,d));return J},C.prototype.beginDirectAnimation=function(V,H,t,I,Z){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(h<0){const V=t;t=I,I=V,h=-h}return t>I&&(h=-h),new a(this,V,t,I,Z,h,arguments.length>6?arguments[6]:void 0,H,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},C.prototype.beginDirectHierarchyAnimation=function(V,H,t,I,Z,h,f,m,K){let E=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const d=V.getDescendants(H),a=[];a.push(this.beginDirectAnimation(V,t,I,Z,h,f,m,K,E));for(const J of d)a.push(this.beginDirectAnimation(J,t,I,Z,h,f,m,K,E));return a},C.prototype.getAnimatableByTarget=function(V){for(let H=0;H<this._activeAnimatables.length;H++)if(this._activeAnimatables[H].target===V)return this._activeAnimatables[H];return null},C.prototype.getAllAnimatablesByTarget=function(V){const H=[];for(let t=0;t<this._activeAnimatables.length;t++)this._activeAnimatables[t].target===V&&H.push(this._activeAnimatables[t]);return H},C.prototype.stopAnimation=function(V,H,t){const I=this.getAllAnimatablesByTarget(V);for(const Z of I)Z.stop(H,t)},C.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let V=0;V<this._activeAnimatables.length;V++)this._activeAnimatables[V].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const V of this.animationGroups)V.stop()});class Q{getClassName(){return"TargetedAnimation"}serialize(){const V={};return V.animation=this.animation.serialize(),V.targetId=this.target.id,V}}class e{get mask(){return this._mask}set mask(V){this._mask!==V&&(this._mask=V,this.syncWithMask(!0))}syncWithMask(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||V){this._numActiveAnimatables=0;for(let V=0;V<this._animatables.length;++V){const H=this._animatables[V];!this.mask||this.mask.disabled||this.mask.retainsTarget(H.target.name)?(this._numActiveAnimatables++,H.paused&&H.restart()):H.paused||H.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let V=0;V<this._animatables.length;++V){const H=this._animatables[V];this.mask.retainsTarget(H.target.name)||(H.stop(),this._animatables.splice(V,1),--V)}for(let V=0;V<this._targetedAnimations.length;V++){const H=this._targetedAnimations[V];this.mask.retainsTarget(H.target.name)||(this._targetedAnimations.splice(V,1),--V)}}}get from(){return this._from}set from(V){if(this._from!==V){this._from=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].fromFrame=this._from}}}get to(){return this._to}set to(V){if(this._to!==V){this._to=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(V){if(this._speedRatio!==V){this._speedRatio=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(V){if(this._loopAnimation!==V){this._loopAnimation=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(V){if(this._isAdditive!==V){this._isAdditive=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(V){this._weight!==V&&(this._weight=V,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(V){if(this._playOrder!==V&&(this._playOrder=V,this._animatables.length>0)){for(let V=0;V<this._animatables.length;V++)this._animatables[V].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(V){if(this._enableBlending!==V&&(this._enableBlending=V,null!==V))for(let H=0;H<this._targetedAnimations.length;++H)this._targetedAnimations[H].animation.enableBlending=V}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(V){if(this._blendingSpeed!==V&&(this._blendingSpeed=V,null!==V))for(let H=0;H<this._targetedAnimations.length;++H)this._targetedAnimations[H].animation.blendingSpeed=V}getLength(V,H){V=V??this._from;return((H=H??this._to)-V)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(V){let H=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],I=arguments.length>3?arguments[3]:void 0;if(0===V.length)return null;I=I??V[0].weight;let Z=Number.MAX_VALUE,h=-Number.MAX_VALUE;if(t)for(const m of V)m.from<Z&&(Z=m.from),m.to>h&&(h=m.to);const f=new e(V[0].name+"_merged",V[0]._scene,I);for(const m of V){t&&m.normalize(Z,h);for(const V of m.targetedAnimations)f.addTargetedAnimation(V.animation,V.target);H&&m.dispose()}return f}constructor(V){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=V,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new Z.c,this.onAnimationLoopObservable=new Z.c,this.onAnimationGroupLoopObservable=new Z.c,this.onAnimationGroupEndObservable=new Z.c,this.onAnimationGroupPauseObservable=new Z.c,this.onAnimationGroupPlayObservable=new Z.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=H||h.e.LastCreatedScene,this._weight=t,this._playOrder=I,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(V,H){const t=new Q;t.animation=V,t.target=H;const I=V.getKeys();return this._from>I[0].frame&&(this._from=I[0].frame),this._to<I[I.length-1].frame&&(this._to=I[I.length-1].frame),null!==this._enableBlending&&(V.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(V.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(t),this._shouldStart=!0,t}removeTargetedAnimation(V){for(let H=this._targetedAnimations.length-1;H>-1;H--){this._targetedAnimations[H].animation===V&&this._targetedAnimations.splice(H,1)}}normalize(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==V&&(V=this._from),null==H&&(H=this._to);for(let t=0;t<this._targetedAnimations.length;t++){const I=this._targetedAnimations[t].animation.getKeys(),Z=I[0],h=I[I.length-1];if(Z.frame>V){const H={frame:V,value:Z.value,inTangent:Z.inTangent,outTangent:Z.outTangent,interpolation:Z.interpolation};I.splice(0,0,H)}if(h.frame<H){const V={frame:H,value:h.value,inTangent:h.inTangent,outTangent:h.outTangent,interpolation:h.interpolation};I.push(V)}}return this._from=V,this._to=H,this}_processLoop(V,H,t){V.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(H),this._animationLoopFlags[t]||(this._animationLoopFlags[t]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0],H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,t=arguments.length>2?arguments[2]:void 0,I=arguments.length>3?arguments[3]:void 0,Z=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=V,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let h=0;h<this._targetedAnimations.length;h++){const f=this._targetedAnimations[h],m=this._scene.beginDirectAnimation(f.target,[f.animation],void 0!==t?t:this._from,void 0!==I?I:this._to,V,H,void 0,void 0,void 0!==Z?Z:this._isAdditive);m.weight=this._weight,m.playOrder=this._playOrder,m.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(f),this._checkAnimationGroupEnded(m)},this._processLoop(m,f,h),this._animatables.push(m)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=H,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let V=0;V<this._animatables.length;V++){this._animatables[V].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(V){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==V&&(this.loopAnimation=V),this.restart()):(this.stop(),this.start(V,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let V=0;V<this._animatables.length;V++){this._animatables[V].reset()}return this}restart(){if(!this._isStarted)return this;for(let V=0;V<this._animatables.length;V++){this._animatables[V].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const H=this._animatables.slice();for(let I=0;I<H.length;I++)H[I].stop(void 0,void 0,!0,V);let t=0;for(let I=0;I<this._scene._activeAnimatables.length;I++){const H=this._scene._activeAnimatables[I];H._runtimeAnimations.length>0?this._scene._activeAnimatables[t++]=H:V&&this._checkAnimationGroupEnded(H,V)}return this._scene._activeAnimatables.length=t,this._isStarted=!1,this}setWeightForAllAnimatables(V){for(let H=0;H<this._animatables.length;H++){this._animatables[H].weight=V}return this}syncAllAnimationsWith(V){for(let H=0;H<this._animatables.length;H++){this._animatables[H].syncWith(V)}return this}goToFrame(V){if(!this._isStarted)return this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].goToFrame(V)}return this}getCurrentFrame(){var V;return(null===(V=this.animatables[0])||void 0===V?void 0:V.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const V=this._scene.animationGroups.indexOf(this);if(V>-1&&this._scene.animationGroups.splice(V,1),this._parentContainer){const V=this._parentContainer.animationGroups.indexOf(this);V>-1&&this._parentContainer.animationGroups.splice(V,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(V){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const t=this._animatables.indexOf(V);t>-1&&this._animatables.splice(t,1),0===this._animatables.length&&(this._isStarted=!1,H||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(V,H){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const I=new e(V||this.name,this._scene,this._weight,this._playOrder);I._from=this.from,I._to=this.to,I._speedRatio=this.speedRatio,I._loopAnimation=this.loopAnimation,I._isAdditive=this.isAdditive,I._enableBlending=this.enableBlending,I._blendingSpeed=this.blendingSpeed,I.metadata=this.metadata,I.mask=this.mask;for(const Z of this._targetedAnimations)I.addTargetedAnimation(t?Z.animation.clone():Z.animation,H?H(Z.target):Z.target);return I}serialize(){const V={};V.name=this.name,V.from=this.from,V.to=this.to,V.speedRatio=this.speedRatio,V.loopAnimation=this.loopAnimation,V.isAdditive=this.isAdditive,V.weight=this.weight,V.playOrder=this.playOrder,V.enableBlending=this.enableBlending,V.blendingSpeed=this.blendingSpeed,V.targetedAnimations=[];for(let H=0;H<this.targetedAnimations.length;H++){const t=this.targetedAnimations[H];V.targetedAnimations[H]=t.serialize()}return f.d&&f.d.HasTags(this)&&(V.tags=f.d.GetTags(this)),this.metadata&&(V.metadata=this.metadata),V}static Parse(V,H){const t=new e(V.name,H,V.weight,V.playOrder);for(let Z=0;Z<V.targetedAnimations.length;Z++){const h=V.targetedAnimations[Z],f=I.d.Parse(h.animation),m=h.targetId;if("influence"===h.animation.property){const V=H.getMorphTargetById(m);V&&t.addTargetedAnimation(f,V)}else{const V=H.getNodeById(m);null!=V&&t.addTargetedAnimation(f,V)}}return f.d&&f.d.AddTagsTo(t,V.tags),null!==V.from&&null!==V.to&&t.normalize(V.from,V.to),void 0!==V.speedRatio&&(t._speedRatio=V.speedRatio),void 0!==V.loopAnimation&&(t._loopAnimation=V.loopAnimation),void 0!==V.isAdditive&&(t._isAdditive=V.isAdditive),void 0!==V.weight&&(t._weight=V.weight),void 0!==V.playOrder&&(t._playOrder=V.playOrder),void 0!==V.enableBlending&&(t._enableBlending=V.enableBlending),void 0!==V.blendingSpeed&&(t._blendingSpeed=V.blendingSpeed),void 0!==V.metadata&&(t.metadata=V.metadata),t}static MakeAnimationAdditive(V,H,t){let Z;Z="object"===typeof H?H:{referenceFrame:H,range:t,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let h=V;Z.cloneOriginalAnimationGroup&&(h=V.clone(Z.clonedAnimationGroupName||h.name));const f=h.targetedAnimations;for(let m=0;m<f.length;m++){const V=f[m];V.animation=I.d.MakeAnimationAdditive(V.animation,Z)}if(h.isAdditive=!0,Z.clipKeys){let V=Number.MAX_VALUE,H=-Number.MAX_VALUE;const t=h.targetedAnimations;for(let I=0;I<t.length;I++){const Z=t[I].animation.getKeys();V>Z[0].frame&&(V=Z[0].frame),H<Z[Z.length-1].frame&&(H=Z[Z.length-1].frame)}h._from=V,h._to=H}return h}static ClipKeys(V,H,t,I,Z){const h=V.clone(I||V.name);return e.ClipKeysInPlace(h,H,t,Z)}static ClipKeysInPlace(V,H,t,I){return e.ClipInPlace(V,H,t,I,!1)}static ClipFrames(V,H,t,I,Z){const h=V.clone(I||V.name);return e.ClipFramesInPlace(h,H,t,Z)}static ClipFramesInPlace(V,H,t,I){return e.ClipInPlace(V,H,t,I,!0)}static ClipInPlace(V,H,t,I){let Z=arguments.length>4&&void 0!==arguments[4]&&arguments[4],h=Number.MAX_VALUE,f=-Number.MAX_VALUE;const m=V.targetedAnimations;for(let K=0;K<m.length;K++){const V=m[K],E=I?V.animation:V.animation.clone();Z&&(E.createKeyForFrame(H),E.createKeyForFrame(t));const d=E.getKeys(),a=[];let J=Number.MAX_VALUE;for(let I=0;I<d.length;I++){const V=d[I];if(!Z&&I>=H&&I<=t||Z&&V.frame>=H&&V.frame<=t){const H={frame:V.frame,value:V.value.clone?V.value.clone():V.value,inTangent:V.inTangent,outTangent:V.outTangent,interpolation:V.interpolation,lockedTangent:V.lockedTangent};J===Number.MAX_VALUE&&(J=H.frame),H.frame-=J,a.push(H)}}0!==a.length?(h>a[0].frame&&(h=a[0].frame),f<a[a.length-1].frame&&(f=a[a.length-1].frame),E.setKeys(a,!0),V.animation=E):(m.splice(K,1),K--)}return V._from=h,V._to=f,V}getClassName(){return"AnimationGroup"}toString(V){let H="Name: "+this.name;return H+=", type: "+this.getClassName(),V&&(H+=", from: "+this._from,H+=", to: "+this._to,H+=", isStarted: "+this._isStarted,H+=", speedRatio: "+this._speedRatio,H+=", targetedAnimations length: "+this._targetedAnimations.length,H+=", animatables length: "+this._animatables),H}}}}]);