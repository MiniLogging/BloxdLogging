"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12853:(p,O,E)=>{E.r(O),E.d(O,{AnimationGroup:()=>t,TargetedAnimation:()=>H});var e=E(12213),x=E(990),F=E(1025),q=E(1129),a=E(12209),Y=E(995);class B{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(p,O,E,x){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=O,this._target=p,this._scene=E,this._host=x,this._activeTargets=[],O._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===e.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=Y.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const p={frame:0,value:this._minValue};this._keys.splice(0,0,p)}if(this._target instanceof Array){let p=0;for(const O of this._target)this._preparePath(O,p),this._getOriginalValues(p),p++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const F=O.getEvents();F&&F.length>0&&F.forEach((p=>{this._events.push(p._clone())})),this._enableBlending=p&&p.animationPropertiesOverride?p.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(p){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const E=this._animation.targetPropertyPath;if(E.length>1){let e=p;for(let p=0;p<E.length-1;p++){const O=E[p];if(e=e[O],void 0===e)throw new Error(`Invalid property (${O}) in property path (${E.join(".")})`)}this._targetPath=E[E.length-1],this._activeTargets[O]=e}else this._targetPath=E[0],this._activeTargets[O]=p;if(void 0===this._activeTargets[O][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${E.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let p=0;for(const O of this._target)void 0!==this._originalValue[p]&&this._setValue(O,this._activeTargets[p],this._originalValue[p],-1,p),p++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let p=0;p<this._events.length;p++)this._events[p].isDone=!1}isStopped(){return this._stopped}dispose(){const p=this._animation.runtimeAnimations.indexOf(this);p>-1&&this._animation.runtimeAnimations.splice(p,1)}setValue(p,O){if(this._targetIsArray)for(let E=0;E<this._target.length;E++){const e=this._target[E];this._setValue(e,this._activeTargets[E],p,O,E)}else this._setValue(this._target,this._directTarget,p,O,0)}_getOriginalValues(){let p,O=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const E=this._activeTargets[O];p=E.getLocalMatrix&&"_matrix"===this._targetPath?E.getLocalMatrix():E[this._targetPath],p&&p.clone?this._originalValue[O]=p.clone():this._originalValue[O]=p}_registerTargetForLateAnimationBinding(p,O){const E=p.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(E),E._lateAnimationHolders||(E._lateAnimationHolders={}),E._lateAnimationHolders[p.targetPath]||(E._lateAnimationHolders[p.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:O}),p.isAdditive?(E._lateAnimationHolders[p.targetPath].additiveAnimations.push(p),E._lateAnimationHolders[p.targetPath].totalAdditiveWeight+=p.weight):(E._lateAnimationHolders[p.targetPath].animations.push(p),E._lateAnimationHolders[p.targetPath].totalWeight+=p.weight)}_setValue(p,O,E,x,F){if(this._currentActiveTarget=O,this._weight=x,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const p=O[this._targetPath];p.clone?this._originalBlendValue=p.clone():this._originalBlendValue=p}this._originalBlendValue.m?e.e.AllowMatrixDecomposeForInterpolation?this._currentValue?Y.d.DecomposeLerpToRef(this._originalBlendValue,E,this._blendingFactor,this._currentValue):this._currentValue=Y.d.DecomposeLerp(this._originalBlendValue,E,this._blendingFactor):this._currentValue?Y.d.LerpToRef(this._originalBlendValue,E,this._blendingFactor,this._currentValue):this._currentValue=Y.d.Lerp(this._originalBlendValue,E,this._blendingFactor):this._currentValue=e.e._UniversalLerp(this._originalBlendValue,E,this._blendingFactor);const x=p&&p.animationPropertiesOverride?p.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=x}else this._currentValue?this._currentValue.p?this._currentValue.p(E):this._currentValue=E:null!==E&&void 0!==E&&E.clone?this._currentValue=E.clone():this._currentValue=E;-1!==x?this._registerTargetForLateAnimationBinding(this,this._originalValue[F]):this._animationState.loopMode===e.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[F],O[this._targetPath]):O[this._targetPath]=this._originalValue[F]+this._currentValue:O[this._targetPath]=this._currentValue,p.Me&&p.Me(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(p){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const E=this._animation.getKeys();p<E[0].frame?p=E[0].frame:p>E[E.length-1].frame&&(p=E[E.length-1].frame);const e=this._events;if(e.length)for(let F=0;F<e.length;F++)e[F].onlyOnce||(e[F].isDone=e[F].frame<p);this._currentFrame=p;const x=this._animation._interpolate(p,this._animationState);this.setValue(x,O)}_prepareForSpeedRatioChange(p){const O=this._previousElapsedTime*(this._animation.framePerSecond*p)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-O}animate(p,O,E,x,F){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const a=this._animation,Y=a.targetPropertyPath;if(!Y||Y.length<1)return this._stopped=!0,!1;let B=!0;(O<this._minFrame||O>this._maxFrame)&&(O=this._minFrame),(E<this._minFrame||E>this._maxFrame)&&(E=this._maxFrame);const s=E-O;let D,Z=p*(a.framePerSecond*F)/1e3+this._absoluteFrameOffset,m=0,h=!1;const T=x&&this._animationState.loopMode===e.e.ANIMATIONLOOPMODE_YOYO;if(T){const p=(Z-O)/s,E=Math.sin(p*Math.PI);Z=Math.abs(E)*s+O;const e=E>=0?1:-1;this._yoyoDirection!==e&&(h=!0),this._yoyoDirection=e}if(this._previousElapsedTime=p,this._previousAbsoluteFrame=Z,!x&&E>=O&&(Z>=s&&F>0||Z<=0&&F<0))B=!1,m=a._getKeyValue(this._maxValue);else if(!x&&O>=E&&(Z<=s&&F<0||Z>=0&&F>0))B=!1,m=a._getKeyValue(this._minValue);else if(this._animationState.loopMode!==e.e.ANIMATIONLOOPMODE_CYCLE){const p=E.toString()+O.toString();if(!this._offsetsCache[p]){this._animationState.repeatCount=0,this._animationState.loopMode=e.e.ANIMATIONLOOPMODE_CYCLE;const x=a._interpolate(O,this._animationState),F=a._interpolate(E,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),a.dataType){case e.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[p]=F-x;break;case e.e.ANIMATIONTYPE_QUATERNION:case e.e.ANIMATIONTYPE_VECTOR3:case e.e.ANIMATIONTYPE_VECTOR2:case e.e.ANIMATIONTYPE_SIZE:case e.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[p]=F.Qc(x)}this._highLimitsCache[p]=F}m=this._highLimitsCache[p],D=this._offsetsCache[p]}if(void 0===D)switch(a.dataType){case e.e.ANIMATIONTYPE_FLOAT:D=0;break;case e.e.ANIMATIONTYPE_QUATERNION:D=e.o;break;case e.e.ANIMATIONTYPE_VECTOR3:D=e.w;break;case e.e.ANIMATIONTYPE_VECTOR2:D=e.u;break;case e.e.ANIMATIONTYPE_SIZE:D=e.r;break;case e.e.ANIMATIONTYPE_COLOR3:D=e.i;break;case e.e.ANIMATIONTYPE_COLOR4:D=e.m}let A;if(this._host&&this._host.syncRoot){const p=this._host.syncRoot;A=O+s*((p.masterFrame-p.fromFrame)/(p.toFrame-p.fromFrame))}else A=Z>0&&O>E||Z<0&&O<E?B&&0!==s?E+Z%s:O:B&&0!==s?O+Z%s:E;const H=this._events;if(!T&&(F>0&&this.currentFrame>A||F<0&&this.currentFrame<A)||T&&h){this._onLoop();for(let p=0;p<H.length;p++)H[p].onlyOnce||(H[p].isDone=!1);this._animationState.key=F>0?0:a.getKeys().length-1}this._currentFrame=A,this._animationState.repeatCount=0===s?0:Z/s|0,this._animationState.highLimitValue=m,this._animationState.offsetValue=D;const t=a._interpolate(A,this._animationState);if(this.setValue(t,q),H.length)for(let e=0;e<H.length;e++)if(s>=0&&A>=H[e].frame&&H[e].frame>=O||s<0&&A<=H[e].frame&&H[e].frame<=O){const p=H[e];p.isDone||(p.onlyOnce&&(H.splice(e,1),e--),p.isDone=!0,p.action(A))}return B||(this._stopped=!0),B}}var s=E(1099);class D{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(p){this._weight=-1!==p?Math.min(Math.max(p,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(p){for(let O=0;O<this._runtimeAnimations.length;O++){this._runtimeAnimations[O]._prepareForSpeedRatioChange(p)}this._speedRatio=p,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(p,O){let E=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,F=arguments.length>4&&void 0!==arguments[4]&&arguments[4],q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,a=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7?arguments[7]:void 0,B=arguments.length>8?arguments[8]:void 0,s=arguments.length>9&&void 0!==arguments[9]&&arguments[9],D=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=O,this.fromFrame=E,this.toFrame=e,this.loopAnimation=F,this.onAnimationEnd=a,this.onAnimationLoop=B,this.isAdditive=s,this.playOrder=D,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Cf=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new x.b,this.onAnimationLoopObservable=new x.b,this._scene=p,Y&&this.appendAnimations(O,Y),this._speedRatio=q,p._activeAnimatables.push(this)}syncWith(p){if(this._syncRoot=p,p){const p=this._scene._activeAnimatables.indexOf(this);p>-1&&(this._scene._activeAnimatables.splice(p,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(p,O){for(let E=0;E<O.length;E++){const e=O[E],x=new B(p,e,this._scene,this);x._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(x)}}getAnimationByTargetProperty(p){const O=this._runtimeAnimations;for(let E=0;E<O.length;E++)if(O[E].animation.targetProperty===p)return O[E].animation;return null}getRuntimeAnimationByTargetProperty(p){const O=this._runtimeAnimations;for(let E=0;E<O.length;E++)if(O[E].animation.targetProperty===p)return O[E];return null}reset(){const p=this._runtimeAnimations;for(let O=0;O<p.length;O++)p[O].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(p){const O=this._runtimeAnimations;for(let E=0;E<O.length;E++)O[E].animation.enableBlending=!0,O[E].animation.blendingSpeed=p}disableBlending(){const p=this._runtimeAnimations;for(let O=0;O<p.length;O++)p[O].animation.enableBlending=!1}goToFrame(p){const O=this._runtimeAnimations;if(O[0]){const E=O[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??O[0].currentFrame;const e=0===this.speedRatio?0:(p-this._frameToSyncFromJump)/E*1e3/this.speedRatio;this._manualJumpDelay=-e}for(let E=0;E<O.length;E++)O[E].goToFrame(p,this._weight);this._goToFrame=p}get paused(){return this.Cf}pause(){this.Cf||(this.Cf=!0)}restart(){this.Cf=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(p,O){let E=arguments.length>2&&void 0!==arguments[2]&&arguments[2],e=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(p||O){const x=this._scene._activeAnimatables.indexOf(this);if(x>-1){const F=this._runtimeAnimations;for(let E=F.length-1;E>=0;E--){const e=F[E];p&&e.animation.name!=p||(O&&!O(e.target)||(e.dispose(),F.splice(E,1)))}0==F.length&&(E||this._scene._activeAnimatables.splice(x,1),e||this._raiseOnAnimationEnd())}}else{const p=this._scene._activeAnimatables.indexOf(this);if(p>-1){E||this._scene._activeAnimatables.splice(p,1);const O=this._runtimeAnimations;for(let p=0;p<O.length;p++)O[p].dispose();this._runtimeAnimations.length=0,e||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((p=>{this.onAnimationEndObservable.add((()=>{p(this)}),void 0,void 0,this,!0)}))}_animate(p){if(this.Cf)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=p),!0;if(null===this._localDelayOffset?(this._localDelayOffset=p,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=p-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let O=!1;const E=this._runtimeAnimations;let e;for(e=0;e<E.length;e++){const x=E[e].animate(p-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);O=O||x}if(this.animationStarted=O,!O){if(this.disposeOnEnd)for(e=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(e,1),e=0;e<E.length;e++)E[e].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return O}}function Z(p){if(0===p.totalWeight&&0===p.totalAdditiveWeight)return p.originalValue;let O=1;const E=Y.j.Ld[0],e=Y.j.Ld[1],x=Y.j.Quaternion[0];let F=0;const q=p.animations[0],a=p.originalValue;let B=1,s=!1;if(p.totalWeight<1)B=1-p.totalWeight,a.decompose(e,x,E);else{if(F=1,O=p.totalWeight,B=q.weight/O,1==B){if(!p.totalAdditiveWeight)return q.currentValue;s=!0}q.currentValue.decompose(e,x,E)}if(!s){e.scaleInPlace(B),E.scaleInPlace(B),x.scaleInPlace(B);for(let q=F;q<p.animations.length;q++){const F=p.animations[q];if(0===F.weight)continue;B=F.weight/O;const a=Y.j.Ld[2],s=Y.j.Ld[3],D=Y.j.Quaternion[1];F.currentValue.decompose(s,D,a),s.scaleAndAddToRef(B,e),D.scaleAndAddToRef(Y.h.Dot(x,D)>0?B:-B,x),a.scaleAndAddToRef(B,E)}x.normalize()}for(let Z=0;Z<p.additiveAnimations.length;Z++){const O=p.additiveAnimations[Z];if(0===O.weight)continue;const F=Y.j.Ld[2],q=Y.j.Ld[3],a=Y.j.Quaternion[1];O.currentValue.decompose(q,a,F),q.multiplyToRef(e,q),Y.n.LerpToRef(e,q,O.weight,e),x.multiplyToRef(a,a),Y.h.SlerpToRef(x,a,O.weight,x),F.scaleAndAddToRef(O.weight,E)}const D=q?q._animationState.workValue:Y.j.Matrix[0].clone();return Y.d.ComposeToRef(e,x,E,D),D}function m(p,O){if(0===p.totalWeight&&0===p.totalAdditiveWeight)return O;const E=p.animations[0],e=p.originalValue;let x=O;if(0===p.totalWeight&&p.totalAdditiveWeight>0)x.p(e);else if(1===p.animations.length){if(Y.h.SlerpToRef(e,E.currentValue,Math.min(1,p.totalWeight),x),0===p.totalAdditiveWeight)return x}else if(p.animations.length>1){let E,F,q=1;if(p.totalWeight<1){const O=1-p.totalWeight;E=[],F=[],E.push(e),F.push(O)}else{if(2===p.animations.length&&(Y.h.SlerpToRef(p.animations[0].currentValue,p.animations[1].currentValue,p.animations[1].weight/p.totalWeight,O),0===p.totalAdditiveWeight))return O;E=[],F=[],q=p.totalWeight}for(let O=0;O<p.animations.length;O++){const e=p.animations[O];E.push(e.currentValue),F.push(e.weight/q)}let a=0;for(let p=0;p<E.length;)p?(a+=F[p],Y.h.SlerpToRef(x,E[p],F[p]/a,x),p++):(Y.h.SlerpToRef(E[p],E[p+1],F[p+1]/(F[p]+F[p+1]),O),x=O,a=F[p]+F[p+1],p+=2)}for(let F=0;F<p.additiveAnimations.length;F++){const O=p.additiveAnimations[F];0!==O.weight&&(x.multiplyToRef(O.currentValue,Y.j.Quaternion[0]),Y.h.SlerpToRef(x,Y.j.Quaternion[0],O.weight,x))}return x}var h,T,A=E(1168);h=A.d,(T=a.e)&&(T.prototype.copyAnimationRange=function(p,O,E){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3],F=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new e.e(this.name,"_matrix",p.animations[0].framePerSecond,e.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const q=p.animations[0].getRange(O);if(!q)return!1;const a=q.from,Y=q.to,B=p.animations[0].getKeys(),s=p.length,D=p.getParent(),Z=this.getParent(),m=x&&D&&s&&this.length&&s!==this.length,h=m&&Z&&D?Z.length/D.length:1,T=x&&!Z&&F&&(1!==F.x||1!==F.y||1!==F.z),A=this.animations[0].getKeys();let H,t,r;for(let e=0,Q=B.length;e<Q;e++)H=B[e],H.frame>=a&&H.frame<=Y&&(x?(r=H.value.clone(),m?(t=r.getTranslation(),r.setTranslation(t.scaleInPlace(h))):T&&F?(t=r.getTranslation(),r.setTranslation(t.multiplyInPlace(F))):r=H.value):r=H.value,A.push({frame:H.frame+E,value:r}));return this.animations[0].createRange(O,a+E,Y+E),!0}),h&&(h.prototype._animate=function(p){if(!this.animationsEnabled)return;const O=s.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=O}this.deltaTime=void 0!==p?p:this.useConstantAnimationDeltaTime?16:(O-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=O;const E=this._activeAnimatables;if(0===E.length)return;this._animationTime+=this.deltaTime;const x=this._animationTime;for(let e=0;e<E.length;e++){const p=E[e];!p._animate(x)&&p.disposeOnEnd&&e--}!function(p){if(p._registeredForLateAnimationBindings.length){for(let O=0;O<p._registeredForLateAnimationBindings.length;O++){const E=p._registeredForLateAnimationBindings.data[O];for(const p in E._lateAnimationHolders){const O=E._lateAnimationHolders[p],x=O.animations[0],F=O.originalValue;if(void 0===F||null===F)continue;const q=e.e.AllowMatrixDecomposeForInterpolation&&F.m;let a=E[p];if(q)a=Z(O);else if(void 0!==F.w)a=m(O,a||Y.h.Identity());else{let p=0,E=1;const q=x&&x._animationState.loopMode===e.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(O.totalWeight<1)a=q?F.clone?F.clone():F:x&&F.scale?F.scale(1-O.totalWeight):x?F*(1-O.totalWeight):F.clone?F.clone():F;else if(x){E=O.totalWeight;const e=x.weight/E;a=1!==e?x.currentValue.scale?x.currentValue.scale(e):x.currentValue*e:x.currentValue,q&&(a.addToRef?a.addToRef(F,a):a+=F),p=1}for(let e=p;e<O.animations.length;e++){const p=O.animations[e],x=p.weight/E;x&&(p.currentValue.scaleAndAddToRef?p.currentValue.scaleAndAddToRef(x,a):a+=p.currentValue*x)}for(let e=0;e<O.additiveAnimations.length;e++){const p=O.additiveAnimations[e],E=p.weight;E&&(p.currentValue.scaleAndAddToRef?p.currentValue.scaleAndAddToRef(E,a):a+=p.currentValue*E)}}E[p]=a}E._lateAnimationHolders={}}p._registeredForLateAnimationBindings.reset()}}(this)},h.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((p,O)=>p.playOrder-O.playOrder))},h.prototype.beginWeightedAnimation=function(p,O,E){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,x=arguments.length>4?arguments[4]:void 0,F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,q=arguments.length>6?arguments[6]:void 0,a=arguments.length>7?arguments[7]:void 0,Y=arguments.length>8?arguments[8]:void 0,B=arguments.length>9?arguments[9]:void 0,s=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const D=this.beginAnimation(p,O,E,x,F,q,a,!1,Y,B,s);return D.weight=e,D},h.prototype.beginAnimation=function(p,O,E,e){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,F=arguments.length>5?arguments[5]:void 0,q=arguments.length>6?arguments[6]:void 0,a=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],Y=arguments.length>8?arguments[8]:void 0,B=arguments.length>9?arguments[9]:void 0,s=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(x<0){const p=O;O=E,E=p,x=-x}O>E&&(x=-x),a&&this.stopAnimation(p,void 0,Y),q||(q=new D(this,p,O,E,e,x,F,void 0,B,s));const Z=!Y||Y(p);if(p.animations&&Z&&q.appendAnimations(p,p.animations),p.getAnimatables){const s=p.getAnimatables();for(let p=0;p<s.length;p++)this.beginAnimation(s[p],O,E,e,x,F,q,a,Y,B)}return q.reset(),q},h.prototype.beginHierarchyAnimation=function(p,O,E,e,x){let F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,q=arguments.length>6?arguments[6]:void 0,a=arguments.length>7?arguments[7]:void 0,Y=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],B=arguments.length>9?arguments[9]:void 0,s=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const D=p.getDescendants(O),Z=[];Z.push(this.beginAnimation(p,E,e,x,F,q,a,Y,B,void 0,s));for(const m of D)Z.push(this.beginAnimation(m,E,e,x,F,q,a,Y,B,void 0,s));return Z},h.prototype.beginDirectAnimation=function(p,O,E,e,x){let F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(F<0){const p=E;E=e,e=p,F=-F}return E>e&&(F=-F),new D(this,p,E,e,x,F,arguments.length>6?arguments[6]:void 0,O,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},h.prototype.beginDirectHierarchyAnimation=function(p,O,E,e,x,F,q,a,Y){let B=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const s=p.getDescendants(O),D=[];D.push(this.beginDirectAnimation(p,E,e,x,F,q,a,Y,B));for(const Z of s)D.push(this.beginDirectAnimation(Z,E,e,x,F,q,a,Y,B));return D},h.prototype.getAnimatableByTarget=function(p){for(let O=0;O<this._activeAnimatables.length;O++)if(this._activeAnimatables[O].target===p)return this._activeAnimatables[O];return null},h.prototype.getAllAnimatablesByTarget=function(p){const O=[];for(let E=0;E<this._activeAnimatables.length;E++)this._activeAnimatables[E].target===p&&O.push(this._activeAnimatables[E]);return O},h.prototype.stopAnimation=function(p,O,E){const e=this.getAllAnimatablesByTarget(p);for(const x of e)x.stop(O,E)},h.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let p=0;p<this._activeAnimatables.length;p++)this._activeAnimatables[p].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const p of this.animationGroups)p.stop()});class H{getClassName(){return"TargetedAnimation"}serialize(){const p={};return p.animation=this.animation.serialize(),p.targetId=this.target.id,p}}class t{get mask(){return this._mask}set mask(p){this._mask!==p&&(this._mask=p,this.syncWithMask(!0))}syncWithMask(){let p=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||p){this._numActiveAnimatables=0;for(let p=0;p<this._animatables.length;++p){const O=this._animatables[p];!this.mask||this.mask.disabled||this.mask.retainsTarget(O.target.name)?(this._numActiveAnimatables++,O.paused&&O.restart()):O.paused||O.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let p=0;p<this._animatables.length;++p){const O=this._animatables[p];this.mask.retainsTarget(O.target.name)||(O.stop(),this._animatables.splice(p,1),--p)}for(let p=0;p<this._targetedAnimations.length;p++){const O=this._targetedAnimations[p];this.mask.retainsTarget(O.target.name)||(this._targetedAnimations.splice(p,1),--p)}}}get from(){return this._from}set from(p){if(this._from!==p){this._from=p;for(let p=0;p<this._animatables.length;p++){this._animatables[p].fromFrame=this._from}}}get to(){return this._to}set to(p){if(this._to!==p){this._to=p;for(let p=0;p<this._animatables.length;p++){this._animatables[p].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(p){if(this._speedRatio!==p){this._speedRatio=p;for(let p=0;p<this._animatables.length;p++){this._animatables[p].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(p){if(this._loopAnimation!==p){this._loopAnimation=p;for(let p=0;p<this._animatables.length;p++){this._animatables[p].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(p){if(this._isAdditive!==p){this._isAdditive=p;for(let p=0;p<this._animatables.length;p++){this._animatables[p].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(p){this._weight!==p&&(this._weight=p,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(p){if(this._playOrder!==p&&(this._playOrder=p,this._animatables.length>0)){for(let p=0;p<this._animatables.length;p++)this._animatables[p].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(p){if(this._enableBlending!==p&&(this._enableBlending=p,null!==p))for(let O=0;O<this._targetedAnimations.length;++O)this._targetedAnimations[O].animation.enableBlending=p}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(p){if(this._blendingSpeed!==p&&(this._blendingSpeed=p,null!==p))for(let O=0;O<this._targetedAnimations.length;++O)this._targetedAnimations[O].animation.blendingSpeed=p}getLength(p,O){p=p??this._from;return((O=O??this._to)-p)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(p){let O=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],E=arguments.length>2&&void 0!==arguments[2]&&arguments[2],e=arguments.length>3?arguments[3]:void 0;if(0===p.length)return null;e=e??p[0].weight;let x=Number.MAX_VALUE,F=-Number.MAX_VALUE;if(E)for(const a of p)a.from<x&&(x=a.from),a.to>F&&(F=a.to);const q=new t(p[0].name+"_merged",p[0]._scene,e);for(const a of p){E&&a.normalize(x,F);for(const p of a.targetedAnimations)q.addTargetedAnimation(p.animation,p.target);O&&a.dispose()}return q}constructor(p){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,E=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=p,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new x.b,this.onAnimationLoopObservable=new x.b,this.onAnimationGroupLoopObservable=new x.b,this.onAnimationGroupEndObservable=new x.b,this.onAnimationGroupPauseObservable=new x.b,this.onAnimationGroupPlayObservable=new x.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=O||F.c.LastCreatedScene,this._weight=E,this._playOrder=e,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(p,O){const E=new H;E.animation=p,E.target=O;const e=p.getKeys();return this._from>e[0].frame&&(this._from=e[0].frame),this._to<e[e.length-1].frame&&(this._to=e[e.length-1].frame),null!==this._enableBlending&&(p.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(p.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(E),this._shouldStart=!0,E}removeTargetedAnimation(p){for(let O=this._targetedAnimations.length-1;O>-1;O--){this._targetedAnimations[O].animation===p&&this._targetedAnimations.splice(O,1)}}normalize(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==p&&(p=this._from),null==O&&(O=this._to);for(let E=0;E<this._targetedAnimations.length;E++){const e=this._targetedAnimations[E].animation.getKeys(),x=e[0],F=e[e.length-1];if(x.frame>p){const O={frame:p,value:x.value,inTangent:x.inTangent,outTangent:x.outTangent,interpolation:x.interpolation};e.splice(0,0,O)}if(F.frame<O){const p={frame:O,value:F.value,inTangent:F.inTangent,outTangent:F.outTangent,interpolation:F.interpolation};e.push(p)}}return this._from=p,this._to=O,this}_processLoop(p,O,E){p.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(O),this._animationLoopFlags[E]||(this._animationLoopFlags[E]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let p=arguments.length>0&&void 0!==arguments[0]&&arguments[0],O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,E=arguments.length>2?arguments[2]:void 0,e=arguments.length>3?arguments[3]:void 0,x=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=p,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let F=0;F<this._targetedAnimations.length;F++){const q=this._targetedAnimations[F],a=this._scene.beginDirectAnimation(q.target,[q.animation],void 0!==E?E:this._from,void 0!==e?e:this._to,p,O,void 0,void 0,void 0!==x?x:this._isAdditive);a.weight=this._weight,a.playOrder=this._playOrder,a.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(q),this._checkAnimationGroupEnded(a)},this._processLoop(a,q,F),this._animatables.push(a)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=O,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let p=0;p<this._animatables.length;p++){this._animatables[p].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(p){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==p&&(this.loopAnimation=p),this.restart()):(this.stop(),this.start(p,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let p=0;p<this._animatables.length;p++){this._animatables[p].reset()}return this}restart(){if(!this._isStarted)return this;for(let p=0;p<this._animatables.length;p++){this._animatables[p].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let p=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const O=this._animatables.slice();for(let e=0;e<O.length;e++)O[e].stop(void 0,void 0,!0,p);let E=0;for(let e=0;e<this._scene._activeAnimatables.length;e++){const O=this._scene._activeAnimatables[e];O._runtimeAnimations.length>0?this._scene._activeAnimatables[E++]=O:p&&this._checkAnimationGroupEnded(O,p)}return this._scene._activeAnimatables.length=E,this._isStarted=!1,this}setWeightForAllAnimatables(p){for(let O=0;O<this._animatables.length;O++){this._animatables[O].weight=p}return this}syncAllAnimationsWith(p){for(let O=0;O<this._animatables.length;O++){this._animatables[O].syncWith(p)}return this}goToFrame(p){if(!this._isStarted)return this;for(let O=0;O<this._animatables.length;O++){this._animatables[O].goToFrame(p)}return this}getCurrentFrame(){var p;return(null===(p=this.animatables[0])||void 0===p?void 0:p.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const p=this._scene.animationGroups.indexOf(this);if(p>-1&&this._scene.animationGroups.splice(p,1),this._parentContainer){const p=this._parentContainer.animationGroups.indexOf(this);p>-1&&this._parentContainer.animationGroups.splice(p,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(p){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const E=this._animatables.indexOf(p);E>-1&&this._animatables.splice(E,1),0===this._animatables.length&&(this._isStarted=!1,O||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(p,O){let E=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const e=new t(p||this.name,this._scene,this._weight,this._playOrder);e._from=this.from,e._to=this.to,e._speedRatio=this.speedRatio,e._loopAnimation=this.loopAnimation,e._isAdditive=this.isAdditive,e._enableBlending=this.enableBlending,e._blendingSpeed=this.blendingSpeed,e.metadata=this.metadata,e.mask=this.mask;for(const x of this._targetedAnimations)e.addTargetedAnimation(E?x.animation.clone():x.animation,O?O(x.target):x.target);return e}serialize(){const p={};p.name=this.name,p.from=this.from,p.to=this.to,p.speedRatio=this.speedRatio,p.loopAnimation=this.loopAnimation,p.isAdditive=this.isAdditive,p.weight=this.weight,p.playOrder=this.playOrder,p.enableBlending=this.enableBlending,p.blendingSpeed=this.blendingSpeed,p.targetedAnimations=[];for(let O=0;O<this.targetedAnimations.length;O++){const E=this.targetedAnimations[O];p.targetedAnimations[O]=E.serialize()}return q.b&&q.b.HasTags(this)&&(p.tags=q.b.GetTags(this)),this.metadata&&(p.metadata=this.metadata),p}static Parse(p,O){const E=new t(p.name,O,p.weight,p.playOrder);for(let x=0;x<p.targetedAnimations.length;x++){const F=p.targetedAnimations[x],q=e.e.Parse(F.animation),a=F.targetId;if("influence"===F.animation.property){const p=O.getMorphTargetById(a);p&&E.addTargetedAnimation(q,p)}else{const p=O.getNodeById(a);null!=p&&E.addTargetedAnimation(q,p)}}return q.b&&q.b.AddTagsTo(E,p.tags),null!==p.from&&null!==p.to&&E.normalize(p.from,p.to),void 0!==p.speedRatio&&(E._speedRatio=p.speedRatio),void 0!==p.loopAnimation&&(E._loopAnimation=p.loopAnimation),void 0!==p.isAdditive&&(E._isAdditive=p.isAdditive),void 0!==p.weight&&(E._weight=p.weight),void 0!==p.playOrder&&(E._playOrder=p.playOrder),void 0!==p.enableBlending&&(E._enableBlending=p.enableBlending),void 0!==p.blendingSpeed&&(E._blendingSpeed=p.blendingSpeed),void 0!==p.metadata&&(E.metadata=p.metadata),E}static MakeAnimationAdditive(p,O,E){let x;x="object"===typeof O?O:{referenceFrame:O,range:E,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let F=p;x.cloneOriginalAnimationGroup&&(F=p.clone(x.clonedAnimationGroupName||F.name));const q=F.targetedAnimations;for(let a=0;a<q.length;a++){const p=q[a];p.animation=e.e.MakeAnimationAdditive(p.animation,x)}if(F.isAdditive=!0,x.clipKeys){let p=Number.MAX_VALUE,O=-Number.MAX_VALUE;const E=F.targetedAnimations;for(let e=0;e<E.length;e++){const x=E[e].animation.getKeys();p>x[0].frame&&(p=x[0].frame),O<x[x.length-1].frame&&(O=x[x.length-1].frame)}F._from=p,F._to=O}return F}static ClipKeys(p,O,E,e,x){const F=p.clone(e||p.name);return t.ClipKeysInPlace(F,O,E,x)}static ClipKeysInPlace(p,O,E,e){return t.ClipInPlace(p,O,E,e,!1)}static ClipFrames(p,O,E,e,x){const F=p.clone(e||p.name);return t.ClipFramesInPlace(F,O,E,x)}static ClipFramesInPlace(p,O,E,e){return t.ClipInPlace(p,O,E,e,!0)}static ClipInPlace(p,O,E,e){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4],F=Number.MAX_VALUE,q=-Number.MAX_VALUE;const a=p.targetedAnimations;for(let Y=0;Y<a.length;Y++){const p=a[Y],B=e?p.animation:p.animation.clone();x&&(B.createKeyForFrame(O),B.createKeyForFrame(E));const s=B.getKeys(),D=[];let Z=Number.MAX_VALUE;for(let e=0;e<s.length;e++){const p=s[e];if(!x&&e>=O&&e<=E||x&&p.frame>=O&&p.frame<=E){const O={frame:p.frame,value:p.value.clone?p.value.clone():p.value,inTangent:p.inTangent,outTangent:p.outTangent,interpolation:p.interpolation,lockedTangent:p.lockedTangent};Z===Number.MAX_VALUE&&(Z=O.frame),O.frame-=Z,D.push(O)}}0!==D.length?(F>D[0].frame&&(F=D[0].frame),q<D[D.length-1].frame&&(q=D[D.length-1].frame),B.setKeys(D,!0),p.animation=B):(a.splice(Y,1),Y--)}return p._from=F,p._to=q,p}getClassName(){return"AnimationGroup"}toString(p){let O="Name: "+this.name;return O+=", type: "+this.getClassName(),p&&(O+=", from: "+this._from,O+=", to: "+this._to,O+=", isStarted: "+this._isStarted,O+=", speedRatio: "+this._speedRatio,O+=", targetedAnimations length: "+this._targetedAnimations.length,O+=", animatables length: "+this._animatables),O}}}}]);