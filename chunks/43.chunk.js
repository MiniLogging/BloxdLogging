"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12639:(R,N,q)=>{q.r(N),q.d(N,{AnimationGroup:()=>e,TargetedAnimation:()=>C});var w=q(12006),u=q(959),M=q(997),v=q(1131),G=q(12003),J=q(966);class y{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(R,N,q,u){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=N,this._target=R,this._scene=q,this._host=u,this._activeTargets=[],N._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===w.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=J.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const R={frame:0,value:this._minValue};this._keys.splice(0,0,R)}if(this._target instanceof Array){let R=0;for(const N of this._target)this._preparePath(N,R),this._getOriginalValues(R),R++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const M=N.getEvents();M&&M.length>0&&M.forEach((R=>{this._events.push(R._clone())})),this._enableBlending=R&&R.animationPropertiesOverride?R.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(R){let N=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const q=this._animation.targetPropertyPath;if(q.length>1){let w=R;for(let R=0;R<q.length-1;R++){const N=q[R];if(w=w[N],void 0===w)throw new Error(`Invalid property (${N}) in property path (${q.join(".")})`)}this._targetPath=q[q.length-1],this._activeTargets[N]=w}else this._targetPath=q[0],this._activeTargets[N]=R;if(void 0===this._activeTargets[N][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${q.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let R=0;for(const N of this._target)void 0!==this._originalValue[R]&&this._setValue(N,this._activeTargets[R],this._originalValue[R],-1,R),R++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let R=0;R<this._events.length;R++)this._events[R].isDone=!1}isStopped(){return this._stopped}dispose(){const R=this._animation.runtimeAnimations.indexOf(this);R>-1&&this._animation.runtimeAnimations.splice(R,1)}setValue(R,N){if(this._targetIsArray)for(let q=0;q<this._target.length;q++){const w=this._target[q];this._setValue(w,this._activeTargets[q],R,N,q)}else this._setValue(this._target,this._directTarget,R,N,0)}_getOriginalValues(){let R,N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const q=this._activeTargets[N];R=q.getLocalMatrix&&"_matrix"===this._targetPath?q.getLocalMatrix():q[this._targetPath],R&&R.clone?this._originalValue[N]=R.clone():this._originalValue[N]=R}_registerTargetForLateAnimationBinding(R,N){const q=R.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(q),q._lateAnimationHolders||(q._lateAnimationHolders={}),q._lateAnimationHolders[R.targetPath]||(q._lateAnimationHolders[R.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:N}),R.isAdditive?(q._lateAnimationHolders[R.targetPath].additiveAnimations.push(R),q._lateAnimationHolders[R.targetPath].totalAdditiveWeight+=R.weight):(q._lateAnimationHolders[R.targetPath].animations.push(R),q._lateAnimationHolders[R.targetPath].totalWeight+=R.weight)}_setValue(R,N,q,u,M){if(this._currentActiveTarget=N,this._weight=u,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const R=N[this._targetPath];R.clone?this._originalBlendValue=R.clone():this._originalBlendValue=R}this._originalBlendValue.m?w.c.AllowMatrixDecomposeForInterpolation?this._currentValue?J.c.DecomposeLerpToRef(this._originalBlendValue,q,this._blendingFactor,this._currentValue):this._currentValue=J.c.DecomposeLerp(this._originalBlendValue,q,this._blendingFactor):this._currentValue?J.c.LerpToRef(this._originalBlendValue,q,this._blendingFactor,this._currentValue):this._currentValue=J.c.Lerp(this._originalBlendValue,q,this._blendingFactor):this._currentValue=w.c._UniversalLerp(this._originalBlendValue,q,this._blendingFactor);const u=R&&R.animationPropertiesOverride?R.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=u}else this._currentValue?this._currentValue.p?this._currentValue.p(q):this._currentValue=q:null!==q&&void 0!==q&&q.clone?this._currentValue=q.clone():this._currentValue=q;-1!==u?this._registerTargetForLateAnimationBinding(this,this._originalValue[M]):this._animationState.loopMode===w.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[M],N[this._targetPath]):N[this._targetPath]=this._originalValue[M]+this._currentValue:N[this._targetPath]=this._currentValue,R.pe&&R.pe(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(R){let N=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const q=this._animation.getKeys();R<q[0].frame?R=q[0].frame:R>q[q.length-1].frame&&(R=q[q.length-1].frame);const w=this._events;if(w.length)for(let M=0;M<w.length;M++)w[M].onlyOnce||(w[M].isDone=w[M].frame<R);this._currentFrame=R;const u=this._animation._interpolate(R,this._animationState);this.setValue(u,N)}_prepareForSpeedRatioChange(R){const N=this._previousElapsedTime*(this._animation.framePerSecond*R)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-N}animate(R,N,q,u,M){let v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const G=this._animation,J=G.targetPropertyPath;if(!J||J.length<1)return this._stopped=!0,!1;let y=!0;(N<this._minFrame||N>this._maxFrame)&&(N=this._minFrame),(q<this._minFrame||q>this._maxFrame)&&(q=this._maxFrame);const a=q-N;let j,F=R*(G.framePerSecond*M)/1e3+this._absoluteFrameOffset,S=0,H=!1;const W=u&&this._animationState.loopMode===w.c.ANIMATIONLOOPMODE_YOYO;if(W){const R=(F-N)/a,q=Math.sin(R*Math.PI);F=Math.abs(q)*a+N;const w=q>=0?1:-1;this._yoyoDirection!==w&&(H=!0),this._yoyoDirection=w}if(this._previousElapsedTime=R,this._previousAbsoluteFrame=F,!u&&q>=N&&(F>=a&&M>0||F<=0&&M<0))y=!1,S=G._getKeyValue(this._maxValue);else if(!u&&N>=q&&(F<=a&&M<0||F>=0&&M>0))y=!1,S=G._getKeyValue(this._minValue);else if(this._animationState.loopMode!==w.c.ANIMATIONLOOPMODE_CYCLE){const R=q.toString()+N.toString();if(!this._offsetsCache[R]){this._animationState.repeatCount=0,this._animationState.loopMode=w.c.ANIMATIONLOOPMODE_CYCLE;const u=G._interpolate(N,this._animationState),M=G._interpolate(q,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),G.dataType){case w.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[R]=M-u;break;case w.c.ANIMATIONTYPE_QUATERNION:case w.c.ANIMATIONTYPE_VECTOR3:case w.c.ANIMATIONTYPE_VECTOR2:case w.c.ANIMATIONTYPE_SIZE:case w.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[R]=M.Vc(u)}this._highLimitsCache[R]=M}S=this._highLimitsCache[R],j=this._offsetsCache[R]}if(void 0===j)switch(G.dataType){case w.c.ANIMATIONTYPE_FLOAT:j=0;break;case w.c.ANIMATIONTYPE_QUATERNION:j=w.h;break;case w.c.ANIMATIONTYPE_VECTOR3:j=w.l;break;case w.c.ANIMATIONTYPE_VECTOR2:j=w.j;break;case w.c.ANIMATIONTYPE_SIZE:j=w.i;break;case w.c.ANIMATIONTYPE_COLOR3:j=w.f;break;case w.c.ANIMATIONTYPE_COLOR4:j=w.g}let k;if(this._host&&this._host.syncRoot){const R=this._host.syncRoot;k=N+a*((R.masterFrame-R.fromFrame)/(R.toFrame-R.fromFrame))}else k=F>0&&N>q||F<0&&N<q?y&&0!==a?q+F%a:N:y&&0!==a?N+F%a:q;const C=this._events;if(!W&&(M>0&&this.currentFrame>k||M<0&&this.currentFrame<k)||W&&H){this._onLoop();for(let R=0;R<C.length;R++)C[R].onlyOnce||(C[R].isDone=!1);this._animationState.key=M>0?0:G.getKeys().length-1}this._currentFrame=k,this._animationState.repeatCount=0===a?0:F/a|0,this._animationState.highLimitValue=S,this._animationState.offsetValue=j;const e=G._interpolate(k,this._animationState);if(this.setValue(e,v),C.length)for(let w=0;w<C.length;w++)if(a>=0&&k>=C[w].frame&&C[w].frame>=N||a<0&&k<=C[w].frame&&C[w].frame<=N){const R=C[w];R.isDone||(R.onlyOnce&&(C.splice(w,1),w--),R.isDone=!0,R.action(k))}return y||(this._stopped=!0),y}}var a=q(1097);class j{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(R){this._weight=-1!==R?Math.min(Math.max(R,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(R){for(let N=0;N<this._runtimeAnimations.length;N++){this._runtimeAnimations[N]._prepareForSpeedRatioChange(R)}this._speedRatio=R,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(R,N){let q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,M=arguments.length>4&&void 0!==arguments[4]&&arguments[4],v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,G=arguments.length>6?arguments[6]:void 0,J=arguments.length>7?arguments[7]:void 0,y=arguments.length>8?arguments[8]:void 0,a=arguments.length>9&&void 0!==arguments[9]&&arguments[9],j=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=N,this.fromFrame=q,this.toFrame=w,this.loopAnimation=M,this.onAnimationEnd=G,this.onAnimationLoop=y,this.isAdditive=a,this.playOrder=j,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Gd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new u.c,this.onAnimationLoopObservable=new u.c,this._scene=R,J&&this.appendAnimations(N,J),this._speedRatio=v,R._activeAnimatables.push(this)}syncWith(R){if(this._syncRoot=R,R){const R=this._scene._activeAnimatables.indexOf(this);R>-1&&(this._scene._activeAnimatables.splice(R,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(R,N){for(let q=0;q<N.length;q++){const w=N[q],u=new y(R,w,this._scene,this);u._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(u)}}getAnimationByTargetProperty(R){const N=this._runtimeAnimations;for(let q=0;q<N.length;q++)if(N[q].animation.targetProperty===R)return N[q].animation;return null}getRuntimeAnimationByTargetProperty(R){const N=this._runtimeAnimations;for(let q=0;q<N.length;q++)if(N[q].animation.targetProperty===R)return N[q];return null}reset(){const R=this._runtimeAnimations;for(let N=0;N<R.length;N++)R[N].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(R){const N=this._runtimeAnimations;for(let q=0;q<N.length;q++)N[q].animation.enableBlending=!0,N[q].animation.blendingSpeed=R}disableBlending(){const R=this._runtimeAnimations;for(let N=0;N<R.length;N++)R[N].animation.enableBlending=!1}goToFrame(R){const N=this._runtimeAnimations;if(N[0]){const q=N[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??N[0].currentFrame;const w=0===this.speedRatio?0:(R-this._frameToSyncFromJump)/q*1e3/this.speedRatio;this._manualJumpDelay=-w}for(let q=0;q<N.length;q++)N[q].goToFrame(R,this._weight);this._goToFrame=R}get paused(){return this.Gd}pause(){this.Gd||(this.Gd=!0)}restart(){this.Gd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(R,N){let q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],w=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(R||N){const u=this._scene._activeAnimatables.indexOf(this);if(u>-1){const M=this._runtimeAnimations;for(let q=M.length-1;q>=0;q--){const w=M[q];R&&w.animation.name!=R||(N&&!N(w.target)||(w.dispose(),M.splice(q,1)))}0==M.length&&(q||this._scene._activeAnimatables.splice(u,1),w||this._raiseOnAnimationEnd())}}else{const R=this._scene._activeAnimatables.indexOf(this);if(R>-1){q||this._scene._activeAnimatables.splice(R,1);const N=this._runtimeAnimations;for(let R=0;R<N.length;R++)N[R].dispose();this._runtimeAnimations.length=0,w||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((R=>{this.onAnimationEndObservable.add((()=>{R(this)}),void 0,void 0,this,!0)}))}_animate(R){if(this.Gd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=R),!0;if(null===this._localDelayOffset?(this._localDelayOffset=R,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=R-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let N=!1;const q=this._runtimeAnimations;let w;for(w=0;w<q.length;w++){const u=q[w].animate(R-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);N=N||u}if(this.animationStarted=N,!N){if(this.disposeOnEnd)for(w=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(w,1),w=0;w<q.length;w++)q[w].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return N}}function F(R){if(0===R.totalWeight&&0===R.totalAdditiveWeight)return R.originalValue;let N=1;const q=J.f.Od[0],w=J.f.Od[1],u=J.f.Quaternion[0];let M=0;const v=R.animations[0],G=R.originalValue;let y=1,a=!1;if(R.totalWeight<1)y=1-R.totalWeight,G.decompose(w,u,q);else{if(M=1,N=R.totalWeight,y=v.weight/N,1==y){if(!R.totalAdditiveWeight)return v.currentValue;a=!0}v.currentValue.decompose(w,u,q)}if(!a){w.scaleInPlace(y),q.scaleInPlace(y),u.scaleInPlace(y);for(let v=M;v<R.animations.length;v++){const M=R.animations[v];if(0===M.weight)continue;y=M.weight/N;const G=J.f.Od[2],a=J.f.Od[3],j=J.f.Quaternion[1];M.currentValue.decompose(a,j,G),a.scaleAndAddToRef(y,w),j.scaleAndAddToRef(J.e.Dot(u,j)>0?y:-y,u),G.scaleAndAddToRef(y,q)}u.normalize()}for(let F=0;F<R.additiveAnimations.length;F++){const N=R.additiveAnimations[F];if(0===N.weight)continue;const M=J.f.Od[2],v=J.f.Od[3],G=J.f.Quaternion[1];N.currentValue.decompose(v,G,M),v.multiplyToRef(w,v),J.m.LerpToRef(w,v,N.weight,w),u.multiplyToRef(G,G),J.e.SlerpToRef(u,G,N.weight,u),M.scaleAndAddToRef(N.weight,q)}const j=v?v._animationState.workValue:J.f.Matrix[0].clone();return J.c.ComposeToRef(w,u,q,j),j}function S(R,N){if(0===R.totalWeight&&0===R.totalAdditiveWeight)return N;const q=R.animations[0],w=R.originalValue;let u=N;if(0===R.totalWeight&&R.totalAdditiveWeight>0)u.p(w);else if(1===R.animations.length){if(J.e.SlerpToRef(w,q.currentValue,Math.min(1,R.totalWeight),u),0===R.totalAdditiveWeight)return u}else if(R.animations.length>1){let q,M,v=1;if(R.totalWeight<1){const N=1-R.totalWeight;q=[],M=[],q.push(w),M.push(N)}else{if(2===R.animations.length&&(J.e.SlerpToRef(R.animations[0].currentValue,R.animations[1].currentValue,R.animations[1].weight/R.totalWeight,N),0===R.totalAdditiveWeight))return N;q=[],M=[],v=R.totalWeight}for(let N=0;N<R.animations.length;N++){const w=R.animations[N];q.push(w.currentValue),M.push(w.weight/v)}let G=0;for(let R=0;R<q.length;)R?(G+=M[R],J.e.SlerpToRef(u,q[R],M[R]/G,u),R++):(J.e.SlerpToRef(q[R],q[R+1],M[R+1]/(M[R]+M[R+1]),N),u=N,G=M[R]+M[R+1],R+=2)}for(let M=0;M<R.additiveAnimations.length;M++){const N=R.additiveAnimations[M];0!==N.weight&&(u.multiplyToRef(N.currentValue,J.f.Quaternion[0]),J.e.SlerpToRef(u,J.f.Quaternion[0],N.weight,u))}return u}var H,W,k=q(1174);H=k.e,(W=G.b)&&(W.prototype.copyAnimationRange=function(R,N,q){let u=arguments.length>3&&void 0!==arguments[3]&&arguments[3],M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new w.c(this.name,"_matrix",R.animations[0].framePerSecond,w.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const v=R.animations[0].getRange(N);if(!v)return!1;const G=v.from,J=v.to,y=R.animations[0].getKeys(),a=R.length,j=R.getParent(),F=this.getParent(),S=u&&j&&a&&this.length&&a!==this.length,H=S&&F&&j?F.length/j.length:1,W=u&&!F&&M&&(1!==M.x||1!==M.y||1!==M.z),k=this.animations[0].getKeys();let C,e,K;for(let w=0,r=y.length;w<r;w++)C=y[w],C.frame>=G&&C.frame<=J&&(u?(K=C.value.clone(),S?(e=K.getTranslation(),K.setTranslation(e.scaleInPlace(H))):W&&M?(e=K.getTranslation(),K.setTranslation(e.multiplyInPlace(M))):K=C.value):K=C.value,k.push({frame:C.frame+q,value:K}));return this.animations[0].createRange(N,G+q,J+q),!0}),H&&(H.prototype._animate=function(R){if(!this.animationsEnabled)return;const N=a.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=N}this.deltaTime=void 0!==R?R:this.useConstantAnimationDeltaTime?16:(N-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=N;const q=this._activeAnimatables;if(0===q.length)return;this._animationTime+=this.deltaTime;const u=this._animationTime;for(let w=0;w<q.length;w++){const R=q[w];!R._animate(u)&&R.disposeOnEnd&&w--}!function(R){if(R._registeredForLateAnimationBindings.length){for(let N=0;N<R._registeredForLateAnimationBindings.length;N++){const q=R._registeredForLateAnimationBindings.data[N];for(const R in q._lateAnimationHolders){const N=q._lateAnimationHolders[R],u=N.animations[0],M=N.originalValue;if(void 0===M||null===M)continue;const v=w.c.AllowMatrixDecomposeForInterpolation&&M.m;let G=q[R];if(v)G=F(N);else if(void 0!==M.w)G=S(N,G||J.e.Identity());else{let R=0,q=1;const v=u&&u._animationState.loopMode===w.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(N.totalWeight<1)G=v?M.clone?M.clone():M:u&&M.scale?M.scale(1-N.totalWeight):u?M*(1-N.totalWeight):M.clone?M.clone():M;else if(u){q=N.totalWeight;const w=u.weight/q;G=1!==w?u.currentValue.scale?u.currentValue.scale(w):u.currentValue*w:u.currentValue,v&&(G.addToRef?G.addToRef(M,G):G+=M),R=1}for(let w=R;w<N.animations.length;w++){const R=N.animations[w],u=R.weight/q;u&&(R.currentValue.scaleAndAddToRef?R.currentValue.scaleAndAddToRef(u,G):G+=R.currentValue*u)}for(let w=0;w<N.additiveAnimations.length;w++){const R=N.additiveAnimations[w],q=R.weight;q&&(R.currentValue.scaleAndAddToRef?R.currentValue.scaleAndAddToRef(q,G):G+=R.currentValue*q)}}q[R]=G}q._lateAnimationHolders={}}R._registeredForLateAnimationBindings.reset()}}(this)},H.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((R,N)=>R.playOrder-N.playOrder))},H.prototype.beginWeightedAnimation=function(R,N,q){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,u=arguments.length>4?arguments[4]:void 0,M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,v=arguments.length>6?arguments[6]:void 0,G=arguments.length>7?arguments[7]:void 0,J=arguments.length>8?arguments[8]:void 0,y=arguments.length>9?arguments[9]:void 0,a=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const j=this.beginAnimation(R,N,q,u,M,v,G,!1,J,y,a);return j.weight=w,j},H.prototype.beginAnimation=function(R,N,q,w){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,M=arguments.length>5?arguments[5]:void 0,v=arguments.length>6?arguments[6]:void 0,G=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],J=arguments.length>8?arguments[8]:void 0,y=arguments.length>9?arguments[9]:void 0,a=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(u<0){const R=N;N=q,q=R,u=-u}N>q&&(u=-u),G&&this.stopAnimation(R,void 0,J),v||(v=new j(this,R,N,q,w,u,M,void 0,y,a));const F=!J||J(R);if(R.animations&&F&&v.appendAnimations(R,R.animations),R.getAnimatables){const a=R.getAnimatables();for(let R=0;R<a.length;R++)this.beginAnimation(a[R],N,q,w,u,M,v,G,J,y)}return v.reset(),v},H.prototype.beginHierarchyAnimation=function(R,N,q,w,u){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,v=arguments.length>6?arguments[6]:void 0,G=arguments.length>7?arguments[7]:void 0,J=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],y=arguments.length>9?arguments[9]:void 0,a=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const j=R.getDescendants(N),F=[];F.push(this.beginAnimation(R,q,w,u,M,v,G,J,y,void 0,a));for(const S of j)F.push(this.beginAnimation(S,q,w,u,M,v,G,J,y,void 0,a));return F},H.prototype.beginDirectAnimation=function(R,N,q,w,u){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(M<0){const R=q;q=w,w=R,M=-M}return q>w&&(M=-M),new j(this,R,q,w,u,M,arguments.length>6?arguments[6]:void 0,N,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},H.prototype.beginDirectHierarchyAnimation=function(R,N,q,w,u,M,v,G,J){let y=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const a=R.getDescendants(N),j=[];j.push(this.beginDirectAnimation(R,q,w,u,M,v,G,J,y));for(const F of a)j.push(this.beginDirectAnimation(F,q,w,u,M,v,G,J,y));return j},H.prototype.getAnimatableByTarget=function(R){for(let N=0;N<this._activeAnimatables.length;N++)if(this._activeAnimatables[N].target===R)return this._activeAnimatables[N];return null},H.prototype.getAllAnimatablesByTarget=function(R){const N=[];for(let q=0;q<this._activeAnimatables.length;q++)this._activeAnimatables[q].target===R&&N.push(this._activeAnimatables[q]);return N},H.prototype.stopAnimation=function(R,N,q){const w=this.getAllAnimatablesByTarget(R);for(const u of w)u.stop(N,q)},H.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let R=0;R<this._activeAnimatables.length;R++)this._activeAnimatables[R].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const R of this.animationGroups)R.stop()});class C{getClassName(){return"TargetedAnimation"}serialize(){const R={};return R.animation=this.animation.serialize(),R.targetId=this.target.id,R}}class e{get mask(){return this._mask}set mask(R){this._mask!==R&&(this._mask=R,this.syncWithMask(!0))}syncWithMask(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||R){this._numActiveAnimatables=0;for(let R=0;R<this._animatables.length;++R){const N=this._animatables[R];!this.mask||this.mask.disabled||this.mask.retainsTarget(N.target.name)?(this._numActiveAnimatables++,N.paused&&N.restart()):N.paused||N.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let R=0;R<this._animatables.length;++R){const N=this._animatables[R];this.mask.retainsTarget(N.target.name)||(N.stop(),this._animatables.splice(R,1),--R)}for(let R=0;R<this._targetedAnimations.length;R++){const N=this._targetedAnimations[R];this.mask.retainsTarget(N.target.name)||(this._targetedAnimations.splice(R,1),--R)}}}get from(){return this._from}set from(R){if(this._from!==R){this._from=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].fromFrame=this._from}}}get to(){return this._to}set to(R){if(this._to!==R){this._to=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(R){if(this._speedRatio!==R){this._speedRatio=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(R){if(this._loopAnimation!==R){this._loopAnimation=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(R){if(this._isAdditive!==R){this._isAdditive=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(R){this._weight!==R&&(this._weight=R,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(R){if(this._playOrder!==R&&(this._playOrder=R,this._animatables.length>0)){for(let R=0;R<this._animatables.length;R++)this._animatables[R].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(R){if(this._enableBlending!==R&&(this._enableBlending=R,null!==R))for(let N=0;N<this._targetedAnimations.length;++N)this._targetedAnimations[N].animation.enableBlending=R}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(R){if(this._blendingSpeed!==R&&(this._blendingSpeed=R,null!==R))for(let N=0;N<this._targetedAnimations.length;++N)this._targetedAnimations[N].animation.blendingSpeed=R}getLength(R,N){R=R??this._from;return((N=N??this._to)-R)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(R){let N=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],w=arguments.length>3?arguments[3]:void 0;if(0===R.length)return null;w=w??R[0].weight;let u=Number.MAX_VALUE,M=-Number.MAX_VALUE;if(q)for(const G of R)G.from<u&&(u=G.from),G.to>M&&(M=G.to);const v=new e(R[0].name+"_merged",R[0]._scene,w);for(const G of R){q&&G.normalize(u,M);for(const R of G.targetedAnimations)v.addTargetedAnimation(R.animation,R.target);N&&G.dispose()}return v}constructor(R){let N=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=R,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new u.c,this.onAnimationLoopObservable=new u.c,this.onAnimationGroupLoopObservable=new u.c,this.onAnimationGroupEndObservable=new u.c,this.onAnimationGroupPauseObservable=new u.c,this.onAnimationGroupPlayObservable=new u.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=N||M.e.LastCreatedScene,this._weight=q,this._playOrder=w,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(R,N){const q=new C;q.animation=R,q.target=N;const w=R.getKeys();return this._from>w[0].frame&&(this._from=w[0].frame),this._to<w[w.length-1].frame&&(this._to=w[w.length-1].frame),null!==this._enableBlending&&(R.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(R.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(q),this._shouldStart=!0,q}removeTargetedAnimation(R){for(let N=this._targetedAnimations.length-1;N>-1;N--){this._targetedAnimations[N].animation===R&&this._targetedAnimations.splice(N,1)}}normalize(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,N=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==R&&(R=this._from),null==N&&(N=this._to);for(let q=0;q<this._targetedAnimations.length;q++){const w=this._targetedAnimations[q].animation.getKeys(),u=w[0],M=w[w.length-1];if(u.frame>R){const N={frame:R,value:u.value,inTangent:u.inTangent,outTangent:u.outTangent,interpolation:u.interpolation};w.splice(0,0,N)}if(M.frame<N){const R={frame:N,value:M.value,inTangent:M.inTangent,outTangent:M.outTangent,interpolation:M.interpolation};w.push(R)}}return this._from=R,this._to=N,this}_processLoop(R,N,q){R.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(N),this._animationLoopFlags[q]||(this._animationLoopFlags[q]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0],N=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,q=arguments.length>2?arguments[2]:void 0,w=arguments.length>3?arguments[3]:void 0,u=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=R,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let M=0;M<this._targetedAnimations.length;M++){const v=this._targetedAnimations[M],G=this._scene.beginDirectAnimation(v.target,[v.animation],void 0!==q?q:this._from,void 0!==w?w:this._to,R,N,void 0,void 0,void 0!==u?u:this._isAdditive);G.weight=this._weight,G.playOrder=this._playOrder,G.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(v),this._checkAnimationGroupEnded(G)},this._processLoop(G,v,M),this._animatables.push(G)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=N,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let R=0;R<this._animatables.length;R++){this._animatables[R].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(R){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==R&&(this.loopAnimation=R),this.restart()):(this.stop(),this.start(R,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let R=0;R<this._animatables.length;R++){this._animatables[R].reset()}return this}restart(){if(!this._isStarted)return this;for(let R=0;R<this._animatables.length;R++){this._animatables[R].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const N=this._animatables.slice();for(let w=0;w<N.length;w++)N[w].stop(void 0,void 0,!0,R);let q=0;for(let w=0;w<this._scene._activeAnimatables.length;w++){const N=this._scene._activeAnimatables[w];N._runtimeAnimations.length>0?this._scene._activeAnimatables[q++]=N:R&&this._checkAnimationGroupEnded(N,R)}return this._scene._activeAnimatables.length=q,this._isStarted=!1,this}setWeightForAllAnimatables(R){for(let N=0;N<this._animatables.length;N++){this._animatables[N].weight=R}return this}syncAllAnimationsWith(R){for(let N=0;N<this._animatables.length;N++){this._animatables[N].syncWith(R)}return this}goToFrame(R){if(!this._isStarted)return this;for(let N=0;N<this._animatables.length;N++){this._animatables[N].goToFrame(R)}return this}getCurrentFrame(){var R;return(null===(R=this.animatables[0])||void 0===R?void 0:R.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const R=this._scene.animationGroups.indexOf(this);if(R>-1&&this._scene.animationGroups.splice(R,1),this._parentContainer){const R=this._parentContainer.animationGroups.indexOf(this);R>-1&&this._parentContainer.animationGroups.splice(R,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(R){let N=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const q=this._animatables.indexOf(R);q>-1&&this._animatables.splice(q,1),0===this._animatables.length&&(this._isStarted=!1,N||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(R,N){let q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const w=new e(R||this.name,this._scene,this._weight,this._playOrder);w._from=this.from,w._to=this.to,w._speedRatio=this.speedRatio,w._loopAnimation=this.loopAnimation,w._isAdditive=this.isAdditive,w._enableBlending=this.enableBlending,w._blendingSpeed=this.blendingSpeed,w.metadata=this.metadata,w.mask=this.mask;for(const u of this._targetedAnimations)w.addTargetedAnimation(q?u.animation.clone():u.animation,N?N(u.target):u.target);return w}serialize(){const R={};R.name=this.name,R.from=this.from,R.to=this.to,R.speedRatio=this.speedRatio,R.loopAnimation=this.loopAnimation,R.isAdditive=this.isAdditive,R.weight=this.weight,R.playOrder=this.playOrder,R.enableBlending=this.enableBlending,R.blendingSpeed=this.blendingSpeed,R.targetedAnimations=[];for(let N=0;N<this.targetedAnimations.length;N++){const q=this.targetedAnimations[N];R.targetedAnimations[N]=q.serialize()}return v.d&&v.d.HasTags(this)&&(R.tags=v.d.GetTags(this)),this.metadata&&(R.metadata=this.metadata),R}static Parse(R,N){const q=new e(R.name,N,R.weight,R.playOrder);for(let u=0;u<R.targetedAnimations.length;u++){const M=R.targetedAnimations[u],v=w.c.Parse(M.animation),G=M.targetId;if("influence"===M.animation.property){const R=N.getMorphTargetById(G);R&&q.addTargetedAnimation(v,R)}else{const R=N.getNodeById(G);null!=R&&q.addTargetedAnimation(v,R)}}return v.d&&v.d.AddTagsTo(q,R.tags),null!==R.from&&null!==R.to&&q.normalize(R.from,R.to),void 0!==R.speedRatio&&(q._speedRatio=R.speedRatio),void 0!==R.loopAnimation&&(q._loopAnimation=R.loopAnimation),void 0!==R.isAdditive&&(q._isAdditive=R.isAdditive),void 0!==R.weight&&(q._weight=R.weight),void 0!==R.playOrder&&(q._playOrder=R.playOrder),void 0!==R.enableBlending&&(q._enableBlending=R.enableBlending),void 0!==R.blendingSpeed&&(q._blendingSpeed=R.blendingSpeed),void 0!==R.metadata&&(q.metadata=R.metadata),q}static MakeAnimationAdditive(R,N,q){let u;u="object"===typeof N?N:{referenceFrame:N,range:q,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let M=R;u.cloneOriginalAnimationGroup&&(M=R.clone(u.clonedAnimationGroupName||M.name));const v=M.targetedAnimations;for(let G=0;G<v.length;G++){const R=v[G];R.animation=w.c.MakeAnimationAdditive(R.animation,u)}if(M.isAdditive=!0,u.clipKeys){let R=Number.MAX_VALUE,N=-Number.MAX_VALUE;const q=M.targetedAnimations;for(let w=0;w<q.length;w++){const u=q[w].animation.getKeys();R>u[0].frame&&(R=u[0].frame),N<u[u.length-1].frame&&(N=u[u.length-1].frame)}M._from=R,M._to=N}return M}static ClipKeys(R,N,q,w,u){const M=R.clone(w||R.name);return e.ClipKeysInPlace(M,N,q,u)}static ClipKeysInPlace(R,N,q,w){return e.ClipInPlace(R,N,q,w,!1)}static ClipFrames(R,N,q,w,u){const M=R.clone(w||R.name);return e.ClipFramesInPlace(M,N,q,u)}static ClipFramesInPlace(R,N,q,w){return e.ClipInPlace(R,N,q,w,!0)}static ClipInPlace(R,N,q,w){let u=arguments.length>4&&void 0!==arguments[4]&&arguments[4],M=Number.MAX_VALUE,v=-Number.MAX_VALUE;const G=R.targetedAnimations;for(let J=0;J<G.length;J++){const R=G[J],y=w?R.animation:R.animation.clone();u&&(y.createKeyForFrame(N),y.createKeyForFrame(q));const a=y.getKeys(),j=[];let F=Number.MAX_VALUE;for(let w=0;w<a.length;w++){const R=a[w];if(!u&&w>=N&&w<=q||u&&R.frame>=N&&R.frame<=q){const N={frame:R.frame,value:R.value.clone?R.value.clone():R.value,inTangent:R.inTangent,outTangent:R.outTangent,interpolation:R.interpolation,lockedTangent:R.lockedTangent};F===Number.MAX_VALUE&&(F=N.frame),N.frame-=F,j.push(N)}}0!==j.length?(M>j[0].frame&&(M=j[0].frame),v<j[j.length-1].frame&&(v=j[j.length-1].frame),y.setKeys(j,!0),R.animation=y):(G.splice(J,1),J--)}return R._from=M,R._to=v,R}getClassName(){return"AnimationGroup"}toString(R){let N="Name: "+this.name;return N+=", type: "+this.getClassName(),R&&(N+=", from: "+this._from,N+=", to: "+this._to,N+=", isStarted: "+this._isStarted,N+=", speedRatio: "+this._speedRatio,N+=", targetedAnimations length: "+this._targetedAnimations.length,N+=", animatables length: "+this._animatables),N}}}}]);