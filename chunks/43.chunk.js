"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{13297:(o,i,p)=>{p.r(i),p.d(i,{AnimationGroup:()=>e,TargetedAnimation:()=>F});var b=p(12621),k=p(971),u=p(1003),j=p(1133),z=p(12619),g=p(977);class J{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(o,i,p,k){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=i,this._target=o,this._scene=p,this._host=k,this._activeTargets=[],i._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===b.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=g.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const o={frame:0,value:this._minValue};this._keys.splice(0,0,o)}if(this._target instanceof Array){let o=0;for(const i of this._target)this._preparePath(i,o),this._getOriginalValues(o),o++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const u=i.getEvents();u&&u.length>0&&u.forEach((o=>{this._events.push(o._clone())})),this._enableBlending=o&&o.animationPropertiesOverride?o.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(o){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const p=this._animation.targetPropertyPath;if(p.length>1){let b=o;for(let o=0;o<p.length-1;o++){const i=p[o];if(b=b[i],void 0===b)throw new Error(`Invalid property (${i}) in property path (${p.join(".")})`)}this._targetPath=p[p.length-1],this._activeTargets[i]=b}else this._targetPath=p[0],this._activeTargets[i]=o;if(void 0===this._activeTargets[i][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${p.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let o=0;for(const i of this._target)void 0!==this._originalValue[o]&&this._setValue(i,this._activeTargets[o],this._originalValue[o],-1,o),o++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let o=0;o<this._events.length;o++)this._events[o].isDone=!1}isStopped(){return this._stopped}dispose(){const o=this._animation.runtimeAnimations.indexOf(this);o>-1&&this._animation.runtimeAnimations.splice(o,1)}setValue(o,i){if(this._targetIsArray)for(let p=0;p<this._target.length;p++){const b=this._target[p];this._setValue(b,this._activeTargets[p],o,i,p)}else this._setValue(this._target,this._directTarget,o,i,0)}_getOriginalValues(){let o,i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const p=this._activeTargets[i];o=p.getLocalMatrix&&"_matrix"===this._targetPath?p.getLocalMatrix():p[this._targetPath],o&&o.clone?this._originalValue[i]=o.clone():this._originalValue[i]=o}_registerTargetForLateAnimationBinding(o,i){const p=o.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(p),p._lateAnimationHolders||(p._lateAnimationHolders={}),p._lateAnimationHolders[o.targetPath]||(p._lateAnimationHolders[o.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:i}),o.isAdditive?(p._lateAnimationHolders[o.targetPath].additiveAnimations.push(o),p._lateAnimationHolders[o.targetPath].totalAdditiveWeight+=o.weight):(p._lateAnimationHolders[o.targetPath].animations.push(o),p._lateAnimationHolders[o.targetPath].totalWeight+=o.weight)}_setValue(o,i,p,k,u){if(this._currentActiveTarget=i,this._weight=k,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const o=i[this._targetPath];o.clone?this._originalBlendValue=o.clone():this._originalBlendValue=o}this._originalBlendValue.m?b.b.AllowMatrixDecomposeForInterpolation?this._currentValue?g.c.DecomposeLerpToRef(this._originalBlendValue,p,this._blendingFactor,this._currentValue):this._currentValue=g.c.DecomposeLerp(this._originalBlendValue,p,this._blendingFactor):this._currentValue?g.c.LerpToRef(this._originalBlendValue,p,this._blendingFactor,this._currentValue):this._currentValue=g.c.Lerp(this._originalBlendValue,p,this._blendingFactor):this._currentValue=b.b._UniversalLerp(this._originalBlendValue,p,this._blendingFactor);const k=o&&o.animationPropertiesOverride?o.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=k}else this._currentValue?this._currentValue.p?this._currentValue.p(p):this._currentValue=p:null!==p&&void 0!==p&&p.clone?this._currentValue=p.clone():this._currentValue=p;-1!==k?this._registerTargetForLateAnimationBinding(this,this._originalValue[u]):this._animationState.loopMode===b.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[u],i[this._targetPath]):i[this._targetPath]=this._originalValue[u]+this._currentValue:i[this._targetPath]=this._currentValue,o.Ee&&o.Ee(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(o){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const p=this._animation.getKeys();o<p[0].frame?o=p[0].frame:o>p[p.length-1].frame&&(o=p[p.length-1].frame);const b=this._events;if(b.length)for(let u=0;u<b.length;u++)b[u].onlyOnce||(b[u].isDone=b[u].frame<o);this._currentFrame=o;const k=this._animation._interpolate(o,this._animationState);this.setValue(k,i)}_prepareForSpeedRatioChange(o){const i=this._previousElapsedTime*(this._animation.framePerSecond*o)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-i}animate(o,i,p,k,u){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const z=this._animation,g=z.targetPropertyPath;if(!g||g.length<1)return this._stopped=!0,!1;let J=!0;(i<this._minFrame||i>this._maxFrame)&&(i=this._minFrame),(p<this._minFrame||p>this._maxFrame)&&(p=this._maxFrame);const a=p-i;let G,O=o*(z.framePerSecond*u)/1e3+this._absoluteFrameOffset,C=0,l=!1;const R=k&&this._animationState.loopMode===b.b.ANIMATIONLOOPMODE_YOYO;if(R){const o=(O-i)/a,p=Math.sin(o*Math.PI);O=Math.abs(p)*a+i;const b=p>=0?1:-1;this._yoyoDirection!==b&&(l=!0),this._yoyoDirection=b}if(this._previousElapsedTime=o,this._previousAbsoluteFrame=O,!k&&p>=i&&(O>=a&&u>0||O<=0&&u<0))J=!1,C=z._getKeyValue(this._maxValue);else if(!k&&i>=p&&(O<=a&&u<0||O>=0&&u>0))J=!1,C=z._getKeyValue(this._minValue);else if(this._animationState.loopMode!==b.b.ANIMATIONLOOPMODE_CYCLE){const o=p.toString()+i.toString();if(!this._offsetsCache[o]){this._animationState.repeatCount=0,this._animationState.loopMode=b.b.ANIMATIONLOOPMODE_CYCLE;const k=z._interpolate(i,this._animationState),u=z._interpolate(p,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),z.dataType){case b.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[o]=u-k;break;case b.b.ANIMATIONTYPE_QUATERNION:case b.b.ANIMATIONTYPE_VECTOR3:case b.b.ANIMATIONTYPE_VECTOR2:case b.b.ANIMATIONTYPE_SIZE:case b.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[o]=u.Gc(k)}this._highLimitsCache[o]=u}C=this._highLimitsCache[o],G=this._offsetsCache[o]}if(void 0===G)switch(z.dataType){case b.b.ANIMATIONTYPE_FLOAT:G=0;break;case b.b.ANIMATIONTYPE_QUATERNION:G=b.k;break;case b.b.ANIMATIONTYPE_VECTOR3:G=b.u;break;case b.b.ANIMATIONTYPE_VECTOR2:G=b.q;break;case b.b.ANIMATIONTYPE_SIZE:G=b.m;break;case b.b.ANIMATIONTYPE_COLOR3:G=b.e;break;case b.b.ANIMATIONTYPE_COLOR4:G=b.g}let E;if(this._host&&this._host.syncRoot){const o=this._host.syncRoot;E=i+a*((o.masterFrame-o.fromFrame)/(o.toFrame-o.fromFrame))}else E=O>0&&i>p||O<0&&i<p?J&&0!==a?p+O%a:i:J&&0!==a?i+O%a:p;const F=this._events;if(!R&&(u>0&&this.currentFrame>E||u<0&&this.currentFrame<E)||R&&l){this._onLoop();for(let o=0;o<F.length;o++)F[o].onlyOnce||(F[o].isDone=!1);this._animationState.key=u>0?0:z.getKeys().length-1}this._currentFrame=E,this._animationState.repeatCount=0===a?0:O/a|0,this._animationState.highLimitValue=C,this._animationState.offsetValue=G;const e=z._interpolate(E,this._animationState);if(this.setValue(e,j),F.length)for(let b=0;b<F.length;b++)if(a>=0&&E>=F[b].frame&&F[b].frame>=i||a<0&&E<=F[b].frame&&F[b].frame<=i){const o=F[b];o.isDone||(o.onlyOnce&&(F.splice(b,1),b--),o.isDone=!0,o.action(E))}return J||(this._stopped=!0),J}}var a=p(1099);class G{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(o){this._weight=-1!==o?Math.min(Math.max(o,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(o){for(let i=0;i<this._runtimeAnimations.length;i++){this._runtimeAnimations[i]._prepareForSpeedRatioChange(o)}this._speedRatio=o,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(o,i){let p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,u=arguments.length>4&&void 0!==arguments[4]&&arguments[4],j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,z=arguments.length>6?arguments[6]:void 0,g=arguments.length>7?arguments[7]:void 0,J=arguments.length>8?arguments[8]:void 0,a=arguments.length>9&&void 0!==arguments[9]&&arguments[9],G=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=i,this.fromFrame=p,this.toFrame=b,this.loopAnimation=u,this.onAnimationEnd=z,this.onAnimationLoop=J,this.isAdditive=a,this.playOrder=G,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.yf=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new k.d,this.onAnimationLoopObservable=new k.d,this._scene=o,g&&this.appendAnimations(i,g),this._speedRatio=j,o._activeAnimatables.push(this)}syncWith(o){if(this._syncRoot=o,o){const o=this._scene._activeAnimatables.indexOf(this);o>-1&&(this._scene._activeAnimatables.splice(o,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(o,i){for(let p=0;p<i.length;p++){const b=i[p],k=new J(o,b,this._scene,this);k._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(k)}}getAnimationByTargetProperty(o){const i=this._runtimeAnimations;for(let p=0;p<i.length;p++)if(i[p].animation.targetProperty===o)return i[p].animation;return null}getRuntimeAnimationByTargetProperty(o){const i=this._runtimeAnimations;for(let p=0;p<i.length;p++)if(i[p].animation.targetProperty===o)return i[p];return null}reset(){const o=this._runtimeAnimations;for(let i=0;i<o.length;i++)o[i].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(o){const i=this._runtimeAnimations;for(let p=0;p<i.length;p++)i[p].animation.enableBlending=!0,i[p].animation.blendingSpeed=o}disableBlending(){const o=this._runtimeAnimations;for(let i=0;i<o.length;i++)o[i].animation.enableBlending=!1}goToFrame(o){const i=this._runtimeAnimations;if(i[0]){const p=i[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??i[0].currentFrame;const b=0===this.speedRatio?0:(o-this._frameToSyncFromJump)/p*1e3/this.speedRatio;this._manualJumpDelay=-b}for(let p=0;p<i.length;p++)i[p].goToFrame(o,this._weight);this._goToFrame=o}get paused(){return this.yf}pause(){this.yf||(this.yf=!0)}restart(){this.yf=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(o,i){let p=arguments.length>2&&void 0!==arguments[2]&&arguments[2],b=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(o||i){const k=this._scene._activeAnimatables.indexOf(this);if(k>-1){const u=this._runtimeAnimations;for(let p=u.length-1;p>=0;p--){const b=u[p];o&&b.animation.name!=o||(i&&!i(b.target)||(b.dispose(),u.splice(p,1)))}0==u.length&&(p||this._scene._activeAnimatables.splice(k,1),b||this._raiseOnAnimationEnd())}}else{const o=this._scene._activeAnimatables.indexOf(this);if(o>-1){p||this._scene._activeAnimatables.splice(o,1);const i=this._runtimeAnimations;for(let o=0;o<i.length;o++)i[o].dispose();this._runtimeAnimations.length=0,b||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((o=>{this.onAnimationEndObservable.add((()=>{o(this)}),void 0,void 0,this,!0)}))}_animate(o){if(this.yf)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=o),!0;if(null===this._localDelayOffset?(this._localDelayOffset=o,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=o-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let i=!1;const p=this._runtimeAnimations;let b;for(b=0;b<p.length;b++){const k=p[b].animate(o-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);i=i||k}if(this.animationStarted=i,!i){if(this.disposeOnEnd)for(b=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(b,1),b=0;b<p.length;b++)p[b].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return i}}function O(o){if(0===o.totalWeight&&0===o.totalAdditiveWeight)return o.originalValue;let i=1;const p=g.e.Hd[0],b=g.e.Hd[1],k=g.e.Quaternion[0];let u=0;const j=o.animations[0],z=o.originalValue;let J=1,a=!1;if(o.totalWeight<1)J=1-o.totalWeight,z.decompose(b,k,p);else{if(u=1,i=o.totalWeight,J=j.weight/i,1==J){if(!o.totalAdditiveWeight)return j.currentValue;a=!0}j.currentValue.decompose(b,k,p)}if(!a){b.scaleInPlace(J),p.scaleInPlace(J),k.scaleInPlace(J);for(let j=u;j<o.animations.length;j++){const u=o.animations[j];if(0===u.weight)continue;J=u.weight/i;const z=g.e.Hd[2],a=g.e.Hd[3],G=g.e.Quaternion[1];u.currentValue.decompose(a,G,z),a.scaleAndAddToRef(J,b),G.scaleAndAddToRef(g.d.Dot(k,G)>0?J:-J,k),z.scaleAndAddToRef(J,p)}k.normalize()}for(let O=0;O<o.additiveAnimations.length;O++){const i=o.additiveAnimations[O];if(0===i.weight)continue;const u=g.e.Hd[2],j=g.e.Hd[3],z=g.e.Quaternion[1];i.currentValue.decompose(j,z,u),j.multiplyToRef(b,j),g.i.LerpToRef(b,j,i.weight,b),k.multiplyToRef(z,z),g.d.SlerpToRef(k,z,i.weight,k),u.scaleAndAddToRef(i.weight,p)}const G=j?j._animationState.workValue:g.e.Matrix[0].clone();return g.c.ComposeToRef(b,k,p,G),G}function C(o,i){if(0===o.totalWeight&&0===o.totalAdditiveWeight)return i;const p=o.animations[0],b=o.originalValue;let k=i;if(0===o.totalWeight&&o.totalAdditiveWeight>0)k.p(b);else if(1===o.animations.length){if(g.d.SlerpToRef(b,p.currentValue,Math.min(1,o.totalWeight),k),0===o.totalAdditiveWeight)return k}else if(o.animations.length>1){let p,u,j=1;if(o.totalWeight<1){const i=1-o.totalWeight;p=[],u=[],p.push(b),u.push(i)}else{if(2===o.animations.length&&(g.d.SlerpToRef(o.animations[0].currentValue,o.animations[1].currentValue,o.animations[1].weight/o.totalWeight,i),0===o.totalAdditiveWeight))return i;p=[],u=[],j=o.totalWeight}for(let i=0;i<o.animations.length;i++){const b=o.animations[i];p.push(b.currentValue),u.push(b.weight/j)}let z=0;for(let o=0;o<p.length;)o?(z+=u[o],g.d.SlerpToRef(k,p[o],u[o]/z,k),o++):(g.d.SlerpToRef(p[o],p[o+1],u[o+1]/(u[o]+u[o+1]),i),k=i,z=u[o]+u[o+1],o+=2)}for(let u=0;u<o.additiveAnimations.length;u++){const i=o.additiveAnimations[u];0!==i.weight&&(k.multiplyToRef(i.currentValue,g.e.Quaternion[0]),g.d.SlerpToRef(k,g.e.Quaternion[0],i.weight,k))}return k}var l,R,E=p(1172);l=E.b,(R=z.b)&&(R.prototype.copyAnimationRange=function(o,i,p){let k=arguments.length>3&&void 0!==arguments[3]&&arguments[3],u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new b.b(this.name,"_matrix",o.animations[0].framePerSecond,b.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const j=o.animations[0].getRange(i);if(!j)return!1;const z=j.from,g=j.to,J=o.animations[0].getKeys(),a=o.length,G=o.getParent(),O=this.getParent(),C=k&&G&&a&&this.length&&a!==this.length,l=C&&O&&G?O.length/G.length:1,R=k&&!O&&u&&(1!==u.x||1!==u.y||1!==u.z),E=this.animations[0].getKeys();let F,e,W;for(let b=0,M=J.length;b<M;b++)F=J[b],F.frame>=z&&F.frame<=g&&(k?(W=F.value.clone(),C?(e=W.getTranslation(),W.setTranslation(e.scaleInPlace(l))):R&&u?(e=W.getTranslation(),W.setTranslation(e.multiplyInPlace(u))):W=F.value):W=F.value,E.push({frame:F.frame+p,value:W}));return this.animations[0].createRange(i,z+p,g+p),!0}),l&&(l.prototype._animate=function(o){if(!this.animationsEnabled)return;const i=a.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=i}this.deltaTime=void 0!==o?o:this.useConstantAnimationDeltaTime?16:(i-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=i;const p=this._activeAnimatables;if(0===p.length)return;this._animationTime+=this.deltaTime;const k=this._animationTime;for(let b=0;b<p.length;b++){const o=p[b];!o._animate(k)&&o.disposeOnEnd&&b--}!function(o){if(o._registeredForLateAnimationBindings.length){for(let i=0;i<o._registeredForLateAnimationBindings.length;i++){const p=o._registeredForLateAnimationBindings.data[i];for(const o in p._lateAnimationHolders){const i=p._lateAnimationHolders[o],k=i.animations[0],u=i.originalValue;if(void 0===u||null===u)continue;const j=b.b.AllowMatrixDecomposeForInterpolation&&u.m;let z=p[o];if(j)z=O(i);else if(void 0!==u.w)z=C(i,z||g.d.Identity());else{let o=0,p=1;const j=k&&k._animationState.loopMode===b.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(i.totalWeight<1)z=j?u.clone?u.clone():u:k&&u.scale?u.scale(1-i.totalWeight):k?u*(1-i.totalWeight):u.clone?u.clone():u;else if(k){p=i.totalWeight;const b=k.weight/p;z=1!==b?k.currentValue.scale?k.currentValue.scale(b):k.currentValue*b:k.currentValue,j&&(z.addToRef?z.addToRef(u,z):z+=u),o=1}for(let b=o;b<i.animations.length;b++){const o=i.animations[b],k=o.weight/p;k&&(o.currentValue.scaleAndAddToRef?o.currentValue.scaleAndAddToRef(k,z):z+=o.currentValue*k)}for(let b=0;b<i.additiveAnimations.length;b++){const o=i.additiveAnimations[b],p=o.weight;p&&(o.currentValue.scaleAndAddToRef?o.currentValue.scaleAndAddToRef(p,z):z+=o.currentValue*p)}}p[o]=z}p._lateAnimationHolders={}}o._registeredForLateAnimationBindings.reset()}}(this)},l.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((o,i)=>o.playOrder-i.playOrder))},l.prototype.beginWeightedAnimation=function(o,i,p){let b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,k=arguments.length>4?arguments[4]:void 0,u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,j=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,g=arguments.length>8?arguments[8]:void 0,J=arguments.length>9?arguments[9]:void 0,a=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const G=this.beginAnimation(o,i,p,k,u,j,z,!1,g,J,a);return G.weight=b,G},l.prototype.beginAnimation=function(o,i,p,b){let k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,u=arguments.length>5?arguments[5]:void 0,j=arguments.length>6?arguments[6]:void 0,z=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],g=arguments.length>8?arguments[8]:void 0,J=arguments.length>9?arguments[9]:void 0,a=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(k<0){const o=i;i=p,p=o,k=-k}i>p&&(k=-k),z&&this.stopAnimation(o,void 0,g),j||(j=new G(this,o,i,p,b,k,u,void 0,J,a));const O=!g||g(o);if(o.animations&&O&&j.appendAnimations(o,o.animations),o.getAnimatables){const a=o.getAnimatables();for(let o=0;o<a.length;o++)this.beginAnimation(a[o],i,p,b,k,u,j,z,g,J)}return j.reset(),j},l.prototype.beginHierarchyAnimation=function(o,i,p,b,k){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,j=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,g=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],J=arguments.length>9?arguments[9]:void 0,a=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const G=o.getDescendants(i),O=[];O.push(this.beginAnimation(o,p,b,k,u,j,z,g,J,void 0,a));for(const C of G)O.push(this.beginAnimation(C,p,b,k,u,j,z,g,J,void 0,a));return O},l.prototype.beginDirectAnimation=function(o,i,p,b,k){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(u<0){const o=p;p=b,b=o,u=-u}return p>b&&(u=-u),new G(this,o,p,b,k,u,arguments.length>6?arguments[6]:void 0,i,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},l.prototype.beginDirectHierarchyAnimation=function(o,i,p,b,k,u,j,z,g){let J=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const a=o.getDescendants(i),G=[];G.push(this.beginDirectAnimation(o,p,b,k,u,j,z,g,J));for(const O of a)G.push(this.beginDirectAnimation(O,p,b,k,u,j,z,g,J));return G},l.prototype.getAnimatableByTarget=function(o){for(let i=0;i<this._activeAnimatables.length;i++)if(this._activeAnimatables[i].target===o)return this._activeAnimatables[i];return null},l.prototype.getAllAnimatablesByTarget=function(o){const i=[];for(let p=0;p<this._activeAnimatables.length;p++)this._activeAnimatables[p].target===o&&i.push(this._activeAnimatables[p]);return i},l.prototype.stopAnimation=function(o,i,p){const b=this.getAllAnimatablesByTarget(o);for(const k of b)k.stop(i,p)},l.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let o=0;o<this._activeAnimatables.length;o++)this._activeAnimatables[o].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const o of this.animationGroups)o.stop()});class F{getClassName(){return"TargetedAnimation"}serialize(){const o={};return o.animation=this.animation.serialize(),o.targetId=this.target.id,o}}class e{get mask(){return this._mask}set mask(o){this._mask!==o&&(this._mask=o,this.syncWithMask(!0))}syncWithMask(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||o){this._numActiveAnimatables=0;for(let o=0;o<this._animatables.length;++o){const i=this._animatables[o];!this.mask||this.mask.disabled||this.mask.retainsTarget(i.target.name)?(this._numActiveAnimatables++,i.paused&&i.restart()):i.paused||i.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let o=0;o<this._animatables.length;++o){const i=this._animatables[o];this.mask.retainsTarget(i.target.name)||(i.stop(),this._animatables.splice(o,1),--o)}for(let o=0;o<this._targetedAnimations.length;o++){const i=this._targetedAnimations[o];this.mask.retainsTarget(i.target.name)||(this._targetedAnimations.splice(o,1),--o)}}}get from(){return this._from}set from(o){if(this._from!==o){this._from=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].fromFrame=this._from}}}get to(){return this._to}set to(o){if(this._to!==o){this._to=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(o){if(this._speedRatio!==o){this._speedRatio=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(o){if(this._loopAnimation!==o){this._loopAnimation=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(o){if(this._isAdditive!==o){this._isAdditive=o;for(let o=0;o<this._animatables.length;o++){this._animatables[o].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(o){this._weight!==o&&(this._weight=o,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(o){if(this._playOrder!==o&&(this._playOrder=o,this._animatables.length>0)){for(let o=0;o<this._animatables.length;o++)this._animatables[o].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(o){if(this._enableBlending!==o&&(this._enableBlending=o,null!==o))for(let i=0;i<this._targetedAnimations.length;++i)this._targetedAnimations[i].animation.enableBlending=o}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(o){if(this._blendingSpeed!==o&&(this._blendingSpeed=o,null!==o))for(let i=0;i<this._targetedAnimations.length;++i)this._targetedAnimations[i].animation.blendingSpeed=o}getLength(o,i){o=o??this._from;return((i=i??this._to)-o)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(o){let i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],p=arguments.length>2&&void 0!==arguments[2]&&arguments[2],b=arguments.length>3?arguments[3]:void 0;if(0===o.length)return null;b=b??o[0].weight;let k=Number.MAX_VALUE,u=-Number.MAX_VALUE;if(p)for(const z of o)z.from<k&&(k=z.from),z.to>u&&(u=z.to);const j=new e(o[0].name+"_merged",o[0]._scene,b);for(const z of o){p&&z.normalize(k,u);for(const o of z.targetedAnimations)j.addTargetedAnimation(o.animation,o.target);i&&z.dispose()}return j}constructor(o){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=o,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new k.d,this.onAnimationLoopObservable=new k.d,this.onAnimationGroupLoopObservable=new k.d,this.onAnimationGroupEndObservable=new k.d,this.onAnimationGroupPauseObservable=new k.d,this.onAnimationGroupPlayObservable=new k.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=i||u.e.LastCreatedScene,this._weight=p,this._playOrder=b,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(o,i){const p=new F;p.animation=o,p.target=i;const b=o.getKeys();return this._from>b[0].frame&&(this._from=b[0].frame),this._to<b[b.length-1].frame&&(this._to=b[b.length-1].frame),null!==this._enableBlending&&(o.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(o.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(p),this._shouldStart=!0,p}removeTargetedAnimation(o){for(let i=this._targetedAnimations.length-1;i>-1;i--){this._targetedAnimations[i].animation===o&&this._targetedAnimations.splice(i,1)}}normalize(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==o&&(o=this._from),null==i&&(i=this._to);for(let p=0;p<this._targetedAnimations.length;p++){const b=this._targetedAnimations[p].animation.getKeys(),k=b[0],u=b[b.length-1];if(k.frame>o){const i={frame:o,value:k.value,inTangent:k.inTangent,outTangent:k.outTangent,interpolation:k.interpolation};b.splice(0,0,i)}if(u.frame<i){const o={frame:i,value:u.value,inTangent:u.inTangent,outTangent:u.outTangent,interpolation:u.interpolation};b.push(o)}}return this._from=o,this._to=i,this}_processLoop(o,i,p){o.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(i),this._animationLoopFlags[p]||(this._animationLoopFlags[p]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,p=arguments.length>2?arguments[2]:void 0,b=arguments.length>3?arguments[3]:void 0,k=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=o,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let u=0;u<this._targetedAnimations.length;u++){const j=this._targetedAnimations[u],z=this._scene.beginDirectAnimation(j.target,[j.animation],void 0!==p?p:this._from,void 0!==b?b:this._to,o,i,void 0,void 0,void 0!==k?k:this._isAdditive);z.weight=this._weight,z.playOrder=this._playOrder,z.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(j),this._checkAnimationGroupEnded(z)},this._processLoop(z,j,u),this._animatables.push(z)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=i,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let o=0;o<this._animatables.length;o++){this._animatables[o].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(o){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==o&&(this.loopAnimation=o),this.restart()):(this.stop(),this.start(o,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let o=0;o<this._animatables.length;o++){this._animatables[o].reset()}return this}restart(){if(!this._isStarted)return this;for(let o=0;o<this._animatables.length;o++){this._animatables[o].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const i=this._animatables.slice();for(let b=0;b<i.length;b++)i[b].stop(void 0,void 0,!0,o);let p=0;for(let b=0;b<this._scene._activeAnimatables.length;b++){const i=this._scene._activeAnimatables[b];i._runtimeAnimations.length>0?this._scene._activeAnimatables[p++]=i:o&&this._checkAnimationGroupEnded(i,o)}return this._scene._activeAnimatables.length=p,this._isStarted=!1,this}setWeightForAllAnimatables(o){for(let i=0;i<this._animatables.length;i++){this._animatables[i].weight=o}return this}syncAllAnimationsWith(o){for(let i=0;i<this._animatables.length;i++){this._animatables[i].syncWith(o)}return this}goToFrame(o){if(!this._isStarted)return this;for(let i=0;i<this._animatables.length;i++){this._animatables[i].goToFrame(o)}return this}getCurrentFrame(){var o;return(null===(o=this.animatables[0])||void 0===o?void 0:o.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const o=this._scene.animationGroups.indexOf(this);if(o>-1&&this._scene.animationGroups.splice(o,1),this._parentContainer){const o=this._parentContainer.animationGroups.indexOf(this);o>-1&&this._parentContainer.animationGroups.splice(o,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(o){let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const p=this._animatables.indexOf(o);p>-1&&this._animatables.splice(p,1),0===this._animatables.length&&(this._isStarted=!1,i||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(o,i){let p=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const b=new e(o||this.name,this._scene,this._weight,this._playOrder);b._from=this.from,b._to=this.to,b._speedRatio=this.speedRatio,b._loopAnimation=this.loopAnimation,b._isAdditive=this.isAdditive,b._enableBlending=this.enableBlending,b._blendingSpeed=this.blendingSpeed,b.metadata=this.metadata,b.mask=this.mask;for(const k of this._targetedAnimations)b.addTargetedAnimation(p?k.animation.clone():k.animation,i?i(k.target):k.target);return b}serialize(){const o={};o.name=this.name,o.from=this.from,o.to=this.to,o.speedRatio=this.speedRatio,o.loopAnimation=this.loopAnimation,o.isAdditive=this.isAdditive,o.weight=this.weight,o.playOrder=this.playOrder,o.enableBlending=this.enableBlending,o.blendingSpeed=this.blendingSpeed,o.targetedAnimations=[];for(let i=0;i<this.targetedAnimations.length;i++){const p=this.targetedAnimations[i];o.targetedAnimations[i]=p.serialize()}return j.d&&j.d.HasTags(this)&&(o.tags=j.d.GetTags(this)),this.metadata&&(o.metadata=this.metadata),o}static Parse(o,i){const p=new e(o.name,i,o.weight,o.playOrder);for(let k=0;k<o.targetedAnimations.length;k++){const u=o.targetedAnimations[k],j=b.b.Parse(u.animation),z=u.targetId;if("influence"===u.animation.property){const o=i.getMorphTargetById(z);o&&p.addTargetedAnimation(j,o)}else{const o=i.getNodeById(z);null!=o&&p.addTargetedAnimation(j,o)}}return j.d&&j.d.AddTagsTo(p,o.tags),null!==o.from&&null!==o.to&&p.normalize(o.from,o.to),void 0!==o.speedRatio&&(p._speedRatio=o.speedRatio),void 0!==o.loopAnimation&&(p._loopAnimation=o.loopAnimation),void 0!==o.isAdditive&&(p._isAdditive=o.isAdditive),void 0!==o.weight&&(p._weight=o.weight),void 0!==o.playOrder&&(p._playOrder=o.playOrder),void 0!==o.enableBlending&&(p._enableBlending=o.enableBlending),void 0!==o.blendingSpeed&&(p._blendingSpeed=o.blendingSpeed),void 0!==o.metadata&&(p.metadata=o.metadata),p}static MakeAnimationAdditive(o,i,p){let k;k="object"===typeof i?i:{referenceFrame:i,range:p,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let u=o;k.cloneOriginalAnimationGroup&&(u=o.clone(k.clonedAnimationGroupName||u.name));const j=u.targetedAnimations;for(let z=0;z<j.length;z++){const o=j[z];o.animation=b.b.MakeAnimationAdditive(o.animation,k)}if(u.isAdditive=!0,k.clipKeys){let o=Number.MAX_VALUE,i=-Number.MAX_VALUE;const p=u.targetedAnimations;for(let b=0;b<p.length;b++){const k=p[b].animation.getKeys();o>k[0].frame&&(o=k[0].frame),i<k[k.length-1].frame&&(i=k[k.length-1].frame)}u._from=o,u._to=i}return u}static ClipKeys(o,i,p,b,k){const u=o.clone(b||o.name);return e.ClipKeysInPlace(u,i,p,k)}static ClipKeysInPlace(o,i,p,b){return e.ClipInPlace(o,i,p,b,!1)}static ClipFrames(o,i,p,b,k){const u=o.clone(b||o.name);return e.ClipFramesInPlace(u,i,p,k)}static ClipFramesInPlace(o,i,p,b){return e.ClipInPlace(o,i,p,b,!0)}static ClipInPlace(o,i,p,b){let k=arguments.length>4&&void 0!==arguments[4]&&arguments[4],u=Number.MAX_VALUE,j=-Number.MAX_VALUE;const z=o.targetedAnimations;for(let g=0;g<z.length;g++){const o=z[g],J=b?o.animation:o.animation.clone();k&&(J.createKeyForFrame(i),J.createKeyForFrame(p));const a=J.getKeys(),G=[];let O=Number.MAX_VALUE;for(let b=0;b<a.length;b++){const o=a[b];if(!k&&b>=i&&b<=p||k&&o.frame>=i&&o.frame<=p){const i={frame:o.frame,value:o.value.clone?o.value.clone():o.value,inTangent:o.inTangent,outTangent:o.outTangent,interpolation:o.interpolation,lockedTangent:o.lockedTangent};O===Number.MAX_VALUE&&(O=i.frame),i.frame-=O,G.push(i)}}0!==G.length?(u>G[0].frame&&(u=G[0].frame),j<G[G.length-1].frame&&(j=G[G.length-1].frame),J.setKeys(G,!0),o.animation=J):(z.splice(g,1),g--)}return o._from=u,o._to=j,o}getClassName(){return"AnimationGroup"}toString(o){let i="Name: "+this.name;return i+=", type: "+this.getClassName(),o&&(i+=", from: "+this._from,i+=", to: "+this._to,i+=", isStarted: "+this._isStarted,i+=", speedRatio: "+this._speedRatio,i+=", targetedAnimations length: "+this._targetedAnimations.length,i+=", animatables length: "+this._animatables),i}}}}]);