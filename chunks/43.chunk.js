"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{13239:(F,e,a)=>{a.r(e),a.d(e,{AnimationGroup:()=>u,TargetedAnimation:()=>b});var k=a(12590),h=a(1005),z=a(1034),x=a(1173),t=a(12585),H=a(1007);class p{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(F,e,a,h){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=e,this._target=F,this._scene=a,this._host=h,this._activeTargets=[],e._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===k.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=H.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const F={frame:0,value:this._minValue};this._keys.splice(0,0,F)}if(this._target instanceof Array){let F=0;for(const e of this._target)this._preparePath(e,F),this._getOriginalValues(F),F++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const z=e.getEvents();z&&z.length>0&&z.forEach((F=>{this._events.push(F._clone())})),this._enableBlending=F&&F.animationPropertiesOverride?F.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(F){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const a=this._animation.targetPropertyPath;if(a.length>1){let k=F;for(let F=0;F<a.length-1;F++){const e=a[F];if(k=k[e],void 0===k)throw new Error(`Invalid property (${e}) in property path (${a.join(".")})`)}this._targetPath=a[a.length-1],this._activeTargets[e]=k}else this._targetPath=a[0],this._activeTargets[e]=F;if(void 0===this._activeTargets[e][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${a.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let F=0;for(const e of this._target)void 0!==this._originalValue[F]&&this._setValue(e,this._activeTargets[F],this._originalValue[F],-1,F),F++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let F=0;F<this._events.length;F++)this._events[F].isDone=!1}isStopped(){return this._stopped}dispose(){const F=this._animation.runtimeAnimations.indexOf(this);F>-1&&this._animation.runtimeAnimations.splice(F,1)}setValue(F,e){if(this._targetIsArray)for(let a=0;a<this._target.length;a++){const k=this._target[a];this._setValue(k,this._activeTargets[a],F,e,a)}else this._setValue(this._target,this._directTarget,F,e,0)}_getOriginalValues(){let F,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const a=this._activeTargets[e];F=a.getLocalMatrix&&"_matrix"===this._targetPath?a.getLocalMatrix():a[this._targetPath],F&&F.clone?this._originalValue[e]=F.clone():this._originalValue[e]=F}_registerTargetForLateAnimationBinding(F,e){const a=F.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(a),a._lateAnimationHolders||(a._lateAnimationHolders={}),a._lateAnimationHolders[F.targetPath]||(a._lateAnimationHolders[F.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:e}),F.isAdditive?(a._lateAnimationHolders[F.targetPath].additiveAnimations.push(F),a._lateAnimationHolders[F.targetPath].totalAdditiveWeight+=F.weight):(a._lateAnimationHolders[F.targetPath].animations.push(F),a._lateAnimationHolders[F.targetPath].totalWeight+=F.weight)}_setValue(F,e,a,h,z){if(this._currentActiveTarget=e,this._weight=h,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const F=e[this._targetPath];F.clone?this._originalBlendValue=F.clone():this._originalBlendValue=F}this._originalBlendValue.m?k.d.AllowMatrixDecomposeForInterpolation?this._currentValue?H.b.DecomposeLerpToRef(this._originalBlendValue,a,this._blendingFactor,this._currentValue):this._currentValue=H.b.DecomposeLerp(this._originalBlendValue,a,this._blendingFactor):this._currentValue?H.b.LerpToRef(this._originalBlendValue,a,this._blendingFactor,this._currentValue):this._currentValue=H.b.Lerp(this._originalBlendValue,a,this._blendingFactor):this._currentValue=k.d._UniversalLerp(this._originalBlendValue,a,this._blendingFactor);const h=F&&F.animationPropertiesOverride?F.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=h}else this._currentValue?this._currentValue.p?this._currentValue.p(a):this._currentValue=a:null!==a&&void 0!==a&&a.clone?this._currentValue=a.clone():this._currentValue=a;-1!==h?this._registerTargetForLateAnimationBinding(this,this._originalValue[z]):this._animationState.loopMode===k.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[z],e[this._targetPath]):e[this._targetPath]=this._originalValue[z]+this._currentValue:e[this._targetPath]=this._currentValue,F.pe&&F.pe(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(F){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const a=this._animation.getKeys();F<a[0].frame?F=a[0].frame:F>a[a.length-1].frame&&(F=a[a.length-1].frame);const k=this._events;if(k.length)for(let z=0;z<k.length;z++)k[z].onlyOnce||(k[z].isDone=k[z].frame<F);this._currentFrame=F;const h=this._animation._interpolate(F,this._animationState);this.setValue(h,e)}_prepareForSpeedRatioChange(F){const e=this._previousElapsedTime*(this._animation.framePerSecond*F)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-e}animate(F,e,a,h,z){let x=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const t=this._animation,H=t.targetPropertyPath;if(!H||H.length<1)return this._stopped=!0,!1;let p=!0;(e<this._minFrame||e>this._maxFrame)&&(e=this._minFrame),(a<this._minFrame||a>this._maxFrame)&&(a=this._maxFrame);const y=a-e;let L,s=F*(t.framePerSecond*z)/1e3+this._absoluteFrameOffset,Z=0,A=!1;const w=h&&this._animationState.loopMode===k.d.ANIMATIONLOOPMODE_YOYO;if(w){const F=(s-e)/y,a=Math.sin(F*Math.PI);s=Math.abs(a)*y+e;const k=a>=0?1:-1;this._yoyoDirection!==k&&(A=!0),this._yoyoDirection=k}if(this._previousElapsedTime=F,this._previousAbsoluteFrame=s,!h&&a>=e&&(s>=y&&z>0||s<=0&&z<0))p=!1,Z=t._getKeyValue(this._maxValue);else if(!h&&e>=a&&(s<=y&&z<0||s>=0&&z>0))p=!1,Z=t._getKeyValue(this._minValue);else if(this._animationState.loopMode!==k.d.ANIMATIONLOOPMODE_CYCLE){const F=a.toString()+e.toString();if(!this._offsetsCache[F]){this._animationState.repeatCount=0,this._animationState.loopMode=k.d.ANIMATIONLOOPMODE_CYCLE;const h=t._interpolate(e,this._animationState),z=t._interpolate(a,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),t.dataType){case k.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[F]=z-h;break;case k.d.ANIMATIONTYPE_QUATERNION:case k.d.ANIMATIONTYPE_VECTOR3:case k.d.ANIMATIONTYPE_VECTOR2:case k.d.ANIMATIONTYPE_SIZE:case k.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[F]=z.qc(h)}this._highLimitsCache[F]=z}Z=this._highLimitsCache[F],L=this._offsetsCache[F]}if(void 0===L)switch(t.dataType){case k.d.ANIMATIONTYPE_FLOAT:L=0;break;case k.d.ANIMATIONTYPE_QUATERNION:L=k.i;break;case k.d.ANIMATIONTYPE_VECTOR3:L=k.s;break;case k.d.ANIMATIONTYPE_VECTOR2:L=k.p;break;case k.d.ANIMATIONTYPE_SIZE:L=k.m;break;case k.d.ANIMATIONTYPE_COLOR3:L=k.e;break;case k.d.ANIMATIONTYPE_COLOR4:L=k.f}let I;if(this._host&&this._host.syncRoot){const F=this._host.syncRoot;I=e+y*((F.masterFrame-F.fromFrame)/(F.toFrame-F.fromFrame))}else I=s>0&&e>a||s<0&&e<a?p&&0!==y?a+s%y:e:p&&0!==y?e+s%y:a;const b=this._events;if(!w&&(z>0&&this.currentFrame>I||z<0&&this.currentFrame<I)||w&&A){this._onLoop();for(let F=0;F<b.length;F++)b[F].onlyOnce||(b[F].isDone=!1);this._animationState.key=z>0?0:t.getKeys().length-1}this._currentFrame=I,this._animationState.repeatCount=0===y?0:s/y|0,this._animationState.highLimitValue=Z,this._animationState.offsetValue=L;const u=t._interpolate(I,this._animationState);if(this.setValue(u,x),b.length)for(let k=0;k<b.length;k++)if(y>=0&&I>=b[k].frame&&b[k].frame>=e||y<0&&I<=b[k].frame&&b[k].frame<=e){const F=b[k];F.isDone||(F.onlyOnce&&(b.splice(k,1),k--),F.isDone=!0,F.action(I))}return p||(this._stopped=!0),p}}var y=a(1137);class L{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(F){this._weight=-1!==F?Math.min(Math.max(F,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(F){for(let e=0;e<this._runtimeAnimations.length;e++){this._runtimeAnimations[e]._prepareForSpeedRatioChange(F)}this._speedRatio=F,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(F,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,z=arguments.length>4&&void 0!==arguments[4]&&arguments[4],x=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,t=arguments.length>6?arguments[6]:void 0,H=arguments.length>7?arguments[7]:void 0,p=arguments.length>8?arguments[8]:void 0,y=arguments.length>9&&void 0!==arguments[9]&&arguments[9],L=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=e,this.fromFrame=a,this.toFrame=k,this.loopAnimation=z,this.onAnimationEnd=t,this.onAnimationLoop=p,this.isAdditive=y,this.playOrder=L,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.gf=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new h.d,this.onAnimationLoopObservable=new h.d,this._scene=F,H&&this.appendAnimations(e,H),this._speedRatio=x,F._activeAnimatables.push(this)}syncWith(F){if(this._syncRoot=F,F){const F=this._scene._activeAnimatables.indexOf(this);F>-1&&(this._scene._activeAnimatables.splice(F,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(F,e){for(let a=0;a<e.length;a++){const k=e[a],h=new p(F,k,this._scene,this);h._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(h)}}getAnimationByTargetProperty(F){const e=this._runtimeAnimations;for(let a=0;a<e.length;a++)if(e[a].animation.targetProperty===F)return e[a].animation;return null}getRuntimeAnimationByTargetProperty(F){const e=this._runtimeAnimations;for(let a=0;a<e.length;a++)if(e[a].animation.targetProperty===F)return e[a];return null}reset(){const F=this._runtimeAnimations;for(let e=0;e<F.length;e++)F[e].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(F){const e=this._runtimeAnimations;for(let a=0;a<e.length;a++)e[a].animation.enableBlending=!0,e[a].animation.blendingSpeed=F}disableBlending(){const F=this._runtimeAnimations;for(let e=0;e<F.length;e++)F[e].animation.enableBlending=!1}goToFrame(F){const e=this._runtimeAnimations;if(e[0]){const a=e[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??e[0].currentFrame;const k=0===this.speedRatio?0:(F-this._frameToSyncFromJump)/a*1e3/this.speedRatio;this._manualJumpDelay=-k}for(let a=0;a<e.length;a++)e[a].goToFrame(F,this._weight);this._goToFrame=F}get paused(){return this.gf}pause(){this.gf||(this.gf=!0)}restart(){this.gf=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(F,e){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],k=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(F||e){const h=this._scene._activeAnimatables.indexOf(this);if(h>-1){const z=this._runtimeAnimations;for(let a=z.length-1;a>=0;a--){const k=z[a];F&&k.animation.name!=F||(e&&!e(k.target)||(k.dispose(),z.splice(a,1)))}0==z.length&&(a||this._scene._activeAnimatables.splice(h,1),k||this._raiseOnAnimationEnd())}}else{const F=this._scene._activeAnimatables.indexOf(this);if(F>-1){a||this._scene._activeAnimatables.splice(F,1);const e=this._runtimeAnimations;for(let F=0;F<e.length;F++)e[F].dispose();this._runtimeAnimations.length=0,k||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((F=>{this.onAnimationEndObservable.add((()=>{F(this)}),void 0,void 0,this,!0)}))}_animate(F){if(this.gf)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=F),!0;if(null===this._localDelayOffset?(this._localDelayOffset=F,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=F-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let e=!1;const a=this._runtimeAnimations;let k;for(k=0;k<a.length;k++){const h=a[k].animate(F-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);e=e||h}if(this.animationStarted=e,!e){if(this.disposeOnEnd)for(k=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(k,1),k=0;k<a.length;k++)a[k].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return e}}function s(F){if(0===F.totalWeight&&0===F.totalAdditiveWeight)return F.originalValue;let e=1;const a=H.h.yd[0],k=H.h.yd[1],h=H.h.Quaternion[0];let z=0;const x=F.animations[0],t=F.originalValue;let p=1,y=!1;if(F.totalWeight<1)p=1-F.totalWeight,t.decompose(k,h,a);else{if(z=1,e=F.totalWeight,p=x.weight/e,1==p){if(!F.totalAdditiveWeight)return x.currentValue;y=!0}x.currentValue.decompose(k,h,a)}if(!y){k.scaleInPlace(p),a.scaleInPlace(p),h.scaleInPlace(p);for(let x=z;x<F.animations.length;x++){const z=F.animations[x];if(0===z.weight)continue;p=z.weight/e;const t=H.h.yd[2],y=H.h.yd[3],L=H.h.Quaternion[1];z.currentValue.decompose(y,L,t),y.scaleAndAddToRef(p,k),L.scaleAndAddToRef(H.d.Dot(h,L)>0?p:-p,h),t.scaleAndAddToRef(p,a)}h.normalize()}for(let s=0;s<F.additiveAnimations.length;s++){const e=F.additiveAnimations[s];if(0===e.weight)continue;const z=H.h.yd[2],x=H.h.yd[3],t=H.h.Quaternion[1];e.currentValue.decompose(x,t,z),x.multiplyToRef(k,x),H.l.LerpToRef(k,x,e.weight,k),h.multiplyToRef(t,t),H.d.SlerpToRef(h,t,e.weight,h),z.scaleAndAddToRef(e.weight,a)}const L=x?x._animationState.workValue:H.h.Matrix[0].clone();return H.b.ComposeToRef(k,h,a,L),L}function Z(F,e){if(0===F.totalWeight&&0===F.totalAdditiveWeight)return e;const a=F.animations[0],k=F.originalValue;let h=e;if(0===F.totalWeight&&F.totalAdditiveWeight>0)h.p(k);else if(1===F.animations.length){if(H.d.SlerpToRef(k,a.currentValue,Math.min(1,F.totalWeight),h),0===F.totalAdditiveWeight)return h}else if(F.animations.length>1){let a,z,x=1;if(F.totalWeight<1){const e=1-F.totalWeight;a=[],z=[],a.push(k),z.push(e)}else{if(2===F.animations.length&&(H.d.SlerpToRef(F.animations[0].currentValue,F.animations[1].currentValue,F.animations[1].weight/F.totalWeight,e),0===F.totalAdditiveWeight))return e;a=[],z=[],x=F.totalWeight}for(let e=0;e<F.animations.length;e++){const k=F.animations[e];a.push(k.currentValue),z.push(k.weight/x)}let t=0;for(let F=0;F<a.length;)F?(t+=z[F],H.d.SlerpToRef(h,a[F],z[F]/t,h),F++):(H.d.SlerpToRef(a[F],a[F+1],z[F+1]/(z[F]+z[F+1]),e),h=e,t=z[F]+z[F+1],F+=2)}for(let z=0;z<F.additiveAnimations.length;z++){const e=F.additiveAnimations[z];0!==e.weight&&(h.multiplyToRef(e.currentValue,H.h.Quaternion[0]),H.d.SlerpToRef(h,H.h.Quaternion[0],e.weight,h))}return h}var A,w,I=a(1216);A=I.b,(w=t.e)&&(w.prototype.copyAnimationRange=function(F,e,a){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3],z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new k.d(this.name,"_matrix",F.animations[0].framePerSecond,k.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const x=F.animations[0].getRange(e);if(!x)return!1;const t=x.from,H=x.to,p=F.animations[0].getKeys(),y=F.length,L=F.getParent(),s=this.getParent(),Z=h&&L&&y&&this.length&&y!==this.length,A=Z&&s&&L?s.length/L.length:1,w=h&&!s&&z&&(1!==z.x||1!==z.y||1!==z.z),I=this.animations[0].getKeys();let b,u,r;for(let k=0,O=p.length;k<O;k++)b=p[k],b.frame>=t&&b.frame<=H&&(h?(r=b.value.clone(),Z?(u=r.getTranslation(),r.setTranslation(u.scaleInPlace(A))):w&&z?(u=r.getTranslation(),r.setTranslation(u.multiplyInPlace(z))):r=b.value):r=b.value,I.push({frame:b.frame+a,value:r}));return this.animations[0].createRange(e,t+a,H+a),!0}),A&&(A.prototype._animate=function(F){if(!this.animationsEnabled)return;const e=y.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=e}this.deltaTime=void 0!==F?F:this.useConstantAnimationDeltaTime?16:(e-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=e;const a=this._activeAnimatables;if(0===a.length)return;this._animationTime+=this.deltaTime;const h=this._animationTime;for(let k=0;k<a.length;k++){const F=a[k];!F._animate(h)&&F.disposeOnEnd&&k--}!function(F){if(F._registeredForLateAnimationBindings.length){for(let e=0;e<F._registeredForLateAnimationBindings.length;e++){const a=F._registeredForLateAnimationBindings.data[e];for(const F in a._lateAnimationHolders){const e=a._lateAnimationHolders[F],h=e.animations[0],z=e.originalValue;if(void 0===z||null===z)continue;const x=k.d.AllowMatrixDecomposeForInterpolation&&z.m;let t=a[F];if(x)t=s(e);else if(void 0!==z.w)t=Z(e,t||H.d.Identity());else{let F=0,a=1;const x=h&&h._animationState.loopMode===k.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(e.totalWeight<1)t=x?z.clone?z.clone():z:h&&z.scale?z.scale(1-e.totalWeight):h?z*(1-e.totalWeight):z.clone?z.clone():z;else if(h){a=e.totalWeight;const k=h.weight/a;t=1!==k?h.currentValue.scale?h.currentValue.scale(k):h.currentValue*k:h.currentValue,x&&(t.addToRef?t.addToRef(z,t):t+=z),F=1}for(let k=F;k<e.animations.length;k++){const F=e.animations[k],h=F.weight/a;h&&(F.currentValue.scaleAndAddToRef?F.currentValue.scaleAndAddToRef(h,t):t+=F.currentValue*h)}for(let k=0;k<e.additiveAnimations.length;k++){const F=e.additiveAnimations[k],a=F.weight;a&&(F.currentValue.scaleAndAddToRef?F.currentValue.scaleAndAddToRef(a,t):t+=F.currentValue*a)}}a[F]=t}a._lateAnimationHolders={}}F._registeredForLateAnimationBindings.reset()}}(this)},A.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((F,e)=>F.playOrder-e.playOrder))},A.prototype.beginWeightedAnimation=function(F,e,a){let k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,h=arguments.length>4?arguments[4]:void 0,z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,x=arguments.length>6?arguments[6]:void 0,t=arguments.length>7?arguments[7]:void 0,H=arguments.length>8?arguments[8]:void 0,p=arguments.length>9?arguments[9]:void 0,y=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const L=this.beginAnimation(F,e,a,h,z,x,t,!1,H,p,y);return L.weight=k,L},A.prototype.beginAnimation=function(F,e,a,k){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,z=arguments.length>5?arguments[5]:void 0,x=arguments.length>6?arguments[6]:void 0,t=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],H=arguments.length>8?arguments[8]:void 0,p=arguments.length>9?arguments[9]:void 0,y=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(h<0){const F=e;e=a,a=F,h=-h}e>a&&(h=-h),t&&this.stopAnimation(F,void 0,H),x||(x=new L(this,F,e,a,k,h,z,void 0,p,y));const s=!H||H(F);if(F.animations&&s&&x.appendAnimations(F,F.animations),F.getAnimatables){const y=F.getAnimatables();for(let F=0;F<y.length;F++)this.beginAnimation(y[F],e,a,k,h,z,x,t,H,p)}return x.reset(),x},A.prototype.beginHierarchyAnimation=function(F,e,a,k,h){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,x=arguments.length>6?arguments[6]:void 0,t=arguments.length>7?arguments[7]:void 0,H=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],p=arguments.length>9?arguments[9]:void 0,y=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const L=F.getDescendants(e),s=[];s.push(this.beginAnimation(F,a,k,h,z,x,t,H,p,void 0,y));for(const Z of L)s.push(this.beginAnimation(Z,a,k,h,z,x,t,H,p,void 0,y));return s},A.prototype.beginDirectAnimation=function(F,e,a,k,h){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(z<0){const F=a;a=k,k=F,z=-z}return a>k&&(z=-z),new L(this,F,a,k,h,z,arguments.length>6?arguments[6]:void 0,e,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},A.prototype.beginDirectHierarchyAnimation=function(F,e,a,k,h,z,x,t,H){let p=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const y=F.getDescendants(e),L=[];L.push(this.beginDirectAnimation(F,a,k,h,z,x,t,H,p));for(const s of y)L.push(this.beginDirectAnimation(s,a,k,h,z,x,t,H,p));return L},A.prototype.getAnimatableByTarget=function(F){for(let e=0;e<this._activeAnimatables.length;e++)if(this._activeAnimatables[e].target===F)return this._activeAnimatables[e];return null},A.prototype.getAllAnimatablesByTarget=function(F){const e=[];for(let a=0;a<this._activeAnimatables.length;a++)this._activeAnimatables[a].target===F&&e.push(this._activeAnimatables[a]);return e},A.prototype.stopAnimation=function(F,e,a){const k=this.getAllAnimatablesByTarget(F);for(const h of k)h.stop(e,a)},A.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let F=0;F<this._activeAnimatables.length;F++)this._activeAnimatables[F].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const F of this.animationGroups)F.stop()});class b{getClassName(){return"TargetedAnimation"}serialize(){const F={};return F.animation=this.animation.serialize(),F.targetId=this.target.id,F}}class u{get mask(){return this._mask}set mask(F){this._mask!==F&&(this._mask=F,this.syncWithMask(!0))}syncWithMask(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||F){this._numActiveAnimatables=0;for(let F=0;F<this._animatables.length;++F){const e=this._animatables[F];!this.mask||this.mask.disabled||this.mask.retainsTarget(e.target.name)?(this._numActiveAnimatables++,e.paused&&e.restart()):e.paused||e.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let F=0;F<this._animatables.length;++F){const e=this._animatables[F];this.mask.retainsTarget(e.target.name)||(e.stop(),this._animatables.splice(F,1),--F)}for(let F=0;F<this._targetedAnimations.length;F++){const e=this._targetedAnimations[F];this.mask.retainsTarget(e.target.name)||(this._targetedAnimations.splice(F,1),--F)}}}get from(){return this._from}set from(F){if(this._from!==F){this._from=F;for(let F=0;F<this._animatables.length;F++){this._animatables[F].fromFrame=this._from}}}get to(){return this._to}set to(F){if(this._to!==F){this._to=F;for(let F=0;F<this._animatables.length;F++){this._animatables[F].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(F){if(this._speedRatio!==F){this._speedRatio=F;for(let F=0;F<this._animatables.length;F++){this._animatables[F].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(F){if(this._loopAnimation!==F){this._loopAnimation=F;for(let F=0;F<this._animatables.length;F++){this._animatables[F].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(F){if(this._isAdditive!==F){this._isAdditive=F;for(let F=0;F<this._animatables.length;F++){this._animatables[F].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(F){this._weight!==F&&(this._weight=F,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(F){if(this._playOrder!==F&&(this._playOrder=F,this._animatables.length>0)){for(let F=0;F<this._animatables.length;F++)this._animatables[F].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(F){if(this._enableBlending!==F&&(this._enableBlending=F,null!==F))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.enableBlending=F}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(F){if(this._blendingSpeed!==F&&(this._blendingSpeed=F,null!==F))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.blendingSpeed=F}getLength(F,e){F=F??this._from;return((e=e??this._to)-F)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(F){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],k=arguments.length>3?arguments[3]:void 0;if(0===F.length)return null;k=k??F[0].weight;let h=Number.MAX_VALUE,z=-Number.MAX_VALUE;if(a)for(const t of F)t.from<h&&(h=t.from),t.to>z&&(z=t.to);const x=new u(F[0].name+"_merged",F[0]._scene,k);for(const t of F){a&&t.normalize(h,z);for(const F of t.targetedAnimations)x.addTargetedAnimation(F.animation,F.target);e&&t.dispose()}return x}constructor(F){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=F,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new h.d,this.onAnimationLoopObservable=new h.d,this.onAnimationGroupLoopObservable=new h.d,this.onAnimationGroupEndObservable=new h.d,this.onAnimationGroupPauseObservable=new h.d,this.onAnimationGroupPlayObservable=new h.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=e||z.b.LastCreatedScene,this._weight=a,this._playOrder=k,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(F,e){const a=new b;a.animation=F,a.target=e;const k=F.getKeys();return this._from>k[0].frame&&(this._from=k[0].frame),this._to<k[k.length-1].frame&&(this._to=k[k.length-1].frame),null!==this._enableBlending&&(F.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(F.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(a),this._shouldStart=!0,a}removeTargetedAnimation(F){for(let e=this._targetedAnimations.length-1;e>-1;e--){this._targetedAnimations[e].animation===F&&this._targetedAnimations.splice(e,1)}}normalize(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==F&&(F=this._from),null==e&&(e=this._to);for(let a=0;a<this._targetedAnimations.length;a++){const k=this._targetedAnimations[a].animation.getKeys(),h=k[0],z=k[k.length-1];if(h.frame>F){const e={frame:F,value:h.value,inTangent:h.inTangent,outTangent:h.outTangent,interpolation:h.interpolation};k.splice(0,0,e)}if(z.frame<e){const F={frame:e,value:z.value,inTangent:z.inTangent,outTangent:z.outTangent,interpolation:z.interpolation};k.push(F)}}return this._from=F,this._to=e,this}_processLoop(F,e,a){F.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(e),this._animationLoopFlags[a]||(this._animationLoopFlags[a]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2?arguments[2]:void 0,k=arguments.length>3?arguments[3]:void 0,h=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=F,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let z=0;z<this._targetedAnimations.length;z++){const x=this._targetedAnimations[z],t=this._scene.beginDirectAnimation(x.target,[x.animation],void 0!==a?a:this._from,void 0!==k?k:this._to,F,e,void 0,void 0,void 0!==h?h:this._isAdditive);t.weight=this._weight,t.playOrder=this._playOrder,t.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(x),this._checkAnimationGroupEnded(t)},this._processLoop(t,x,z),this._animatables.push(t)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=e,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let F=0;F<this._animatables.length;F++){this._animatables[F].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(F){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==F&&(this.loopAnimation=F),this.restart()):(this.stop(),this.start(F,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let F=0;F<this._animatables.length;F++){this._animatables[F].reset()}return this}restart(){if(!this._isStarted)return this;for(let F=0;F<this._animatables.length;F++){this._animatables[F].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const e=this._animatables.slice();for(let k=0;k<e.length;k++)e[k].stop(void 0,void 0,!0,F);let a=0;for(let k=0;k<this._scene._activeAnimatables.length;k++){const e=this._scene._activeAnimatables[k];e._runtimeAnimations.length>0?this._scene._activeAnimatables[a++]=e:F&&this._checkAnimationGroupEnded(e,F)}return this._scene._activeAnimatables.length=a,this._isStarted=!1,this}setWeightForAllAnimatables(F){for(let e=0;e<this._animatables.length;e++){this._animatables[e].weight=F}return this}syncAllAnimationsWith(F){for(let e=0;e<this._animatables.length;e++){this._animatables[e].syncWith(F)}return this}goToFrame(F){if(!this._isStarted)return this;for(let e=0;e<this._animatables.length;e++){this._animatables[e].goToFrame(F)}return this}getCurrentFrame(){var F;return(null===(F=this.animatables[0])||void 0===F?void 0:F.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const F=this._scene.animationGroups.indexOf(this);if(F>-1&&this._scene.animationGroups.splice(F,1),this._parentContainer){const F=this._parentContainer.animationGroups.indexOf(this);F>-1&&this._parentContainer.animationGroups.splice(F,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(F){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const a=this._animatables.indexOf(F);a>-1&&this._animatables.splice(a,1),0===this._animatables.length&&(this._isStarted=!1,e||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(F,e){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const k=new u(F||this.name,this._scene,this._weight,this._playOrder);k._from=this.from,k._to=this.to,k._speedRatio=this.speedRatio,k._loopAnimation=this.loopAnimation,k._isAdditive=this.isAdditive,k._enableBlending=this.enableBlending,k._blendingSpeed=this.blendingSpeed,k.metadata=this.metadata,k.mask=this.mask;for(const h of this._targetedAnimations)k.addTargetedAnimation(a?h.animation.clone():h.animation,e?e(h.target):h.target);return k}serialize(){const F={};F.name=this.name,F.from=this.from,F.to=this.to,F.speedRatio=this.speedRatio,F.loopAnimation=this.loopAnimation,F.isAdditive=this.isAdditive,F.weight=this.weight,F.playOrder=this.playOrder,F.enableBlending=this.enableBlending,F.blendingSpeed=this.blendingSpeed,F.targetedAnimations=[];for(let e=0;e<this.targetedAnimations.length;e++){const a=this.targetedAnimations[e];F.targetedAnimations[e]=a.serialize()}return x.d&&x.d.HasTags(this)&&(F.tags=x.d.GetTags(this)),this.metadata&&(F.metadata=this.metadata),F}static Parse(F,e){const a=new u(F.name,e,F.weight,F.playOrder);for(let h=0;h<F.targetedAnimations.length;h++){const z=F.targetedAnimations[h],x=k.d.Parse(z.animation),t=z.targetId;if("influence"===z.animation.property){const F=e.getMorphTargetById(t);F&&a.addTargetedAnimation(x,F)}else{const F=e.getNodeById(t);null!=F&&a.addTargetedAnimation(x,F)}}return x.d&&x.d.AddTagsTo(a,F.tags),null!==F.from&&null!==F.to&&a.normalize(F.from,F.to),void 0!==F.speedRatio&&(a._speedRatio=F.speedRatio),void 0!==F.loopAnimation&&(a._loopAnimation=F.loopAnimation),void 0!==F.isAdditive&&(a._isAdditive=F.isAdditive),void 0!==F.weight&&(a._weight=F.weight),void 0!==F.playOrder&&(a._playOrder=F.playOrder),void 0!==F.enableBlending&&(a._enableBlending=F.enableBlending),void 0!==F.blendingSpeed&&(a._blendingSpeed=F.blendingSpeed),void 0!==F.metadata&&(a.metadata=F.metadata),a}static MakeAnimationAdditive(F,e,a){let h;h="object"===typeof e?e:{referenceFrame:e,range:a,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let z=F;h.cloneOriginalAnimationGroup&&(z=F.clone(h.clonedAnimationGroupName||z.name));const x=z.targetedAnimations;for(let t=0;t<x.length;t++){const F=x[t];F.animation=k.d.MakeAnimationAdditive(F.animation,h)}if(z.isAdditive=!0,h.clipKeys){let F=Number.MAX_VALUE,e=-Number.MAX_VALUE;const a=z.targetedAnimations;for(let k=0;k<a.length;k++){const h=a[k].animation.getKeys();F>h[0].frame&&(F=h[0].frame),e<h[h.length-1].frame&&(e=h[h.length-1].frame)}z._from=F,z._to=e}return z}static ClipKeys(F,e,a,k,h){const z=F.clone(k||F.name);return u.ClipKeysInPlace(z,e,a,h)}static ClipKeysInPlace(F,e,a,k){return u.ClipInPlace(F,e,a,k,!1)}static ClipFrames(F,e,a,k,h){const z=F.clone(k||F.name);return u.ClipFramesInPlace(z,e,a,h)}static ClipFramesInPlace(F,e,a,k){return u.ClipInPlace(F,e,a,k,!0)}static ClipInPlace(F,e,a,k){let h=arguments.length>4&&void 0!==arguments[4]&&arguments[4],z=Number.MAX_VALUE,x=-Number.MAX_VALUE;const t=F.targetedAnimations;for(let H=0;H<t.length;H++){const F=t[H],p=k?F.animation:F.animation.clone();h&&(p.createKeyForFrame(e),p.createKeyForFrame(a));const y=p.getKeys(),L=[];let s=Number.MAX_VALUE;for(let k=0;k<y.length;k++){const F=y[k];if(!h&&k>=e&&k<=a||h&&F.frame>=e&&F.frame<=a){const e={frame:F.frame,value:F.value.clone?F.value.clone():F.value,inTangent:F.inTangent,outTangent:F.outTangent,interpolation:F.interpolation,lockedTangent:F.lockedTangent};s===Number.MAX_VALUE&&(s=e.frame),e.frame-=s,L.push(e)}}0!==L.length?(z>L[0].frame&&(z=L[0].frame),x<L[L.length-1].frame&&(x=L[L.length-1].frame),p.setKeys(L,!0),F.animation=p):(t.splice(H,1),H--)}return F._from=z,F._to=x,F}getClassName(){return"AnimationGroup"}toString(F){let e="Name: "+this.name;return e+=", type: "+this.getClassName(),F&&(e+=", from: "+this._from,e+=", to: "+this._to,e+=", isStarted: "+this._isStarted,e+=", speedRatio: "+this._speedRatio,e+=", targetedAnimations length: "+this._targetedAnimations.length,e+=", animatables length: "+this._animatables),e}}}}]);