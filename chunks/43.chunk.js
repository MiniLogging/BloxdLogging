"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{13204:(v,T,X)=>{X.r(T),X.d(T,{AnimationGroup:()=>b,TargetedAnimation:()=>k});var O=X(12532),u=X(1001),B=X(1034),m=X(1163),A=X(12530),x=X(1006);class f{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(v,T,X,u){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=T,this._target=v,this._scene=X,this._host=u,this._activeTargets=[],T._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===O.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=x.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const v={frame:0,value:this._minValue};this._keys.splice(0,0,v)}if(this._target instanceof Array){let v=0;for(const T of this._target)this._preparePath(T,v),this._getOriginalValues(v),v++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const B=T.getEvents();B&&B.length>0&&B.forEach((v=>{this._events.push(v._clone())})),this._enableBlending=v&&v.animationPropertiesOverride?v.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(v){let T=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const X=this._animation.targetPropertyPath;if(X.length>1){let O=v;for(let v=0;v<X.length-1;v++){const T=X[v];if(O=O[T],void 0===O)throw new Error(`Invalid property (${T}) in property path (${X.join(".")})`)}this._targetPath=X[X.length-1],this._activeTargets[T]=O}else this._targetPath=X[0],this._activeTargets[T]=v;if(void 0===this._activeTargets[T][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${X.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let v=0;for(const T of this._target)void 0!==this._originalValue[v]&&this._setValue(T,this._activeTargets[v],this._originalValue[v],-1,v),v++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let v=0;v<this._events.length;v++)this._events[v].isDone=!1}isStopped(){return this._stopped}dispose(){const v=this._animation.runtimeAnimations.indexOf(this);v>-1&&this._animation.runtimeAnimations.splice(v,1)}setValue(v,T){if(this._targetIsArray)for(let X=0;X<this._target.length;X++){const O=this._target[X];this._setValue(O,this._activeTargets[X],v,T,X)}else this._setValue(this._target,this._directTarget,v,T,0)}_getOriginalValues(){let v,T=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const X=this._activeTargets[T];v=X.getLocalMatrix&&"_matrix"===this._targetPath?X.getLocalMatrix():X[this._targetPath],v&&v.clone?this._originalValue[T]=v.clone():this._originalValue[T]=v}_registerTargetForLateAnimationBinding(v,T){const X=v.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(X),X._lateAnimationHolders||(X._lateAnimationHolders={}),X._lateAnimationHolders[v.targetPath]||(X._lateAnimationHolders[v.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:T}),v.isAdditive?(X._lateAnimationHolders[v.targetPath].additiveAnimations.push(v),X._lateAnimationHolders[v.targetPath].totalAdditiveWeight+=v.weight):(X._lateAnimationHolders[v.targetPath].animations.push(v),X._lateAnimationHolders[v.targetPath].totalWeight+=v.weight)}_setValue(v,T,X,u,B){if(this._currentActiveTarget=T,this._weight=u,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const v=T[this._targetPath];v.clone?this._originalBlendValue=v.clone():this._originalBlendValue=v}this._originalBlendValue.m?O.e.AllowMatrixDecomposeForInterpolation?this._currentValue?x.b.DecomposeLerpToRef(this._originalBlendValue,X,this._blendingFactor,this._currentValue):this._currentValue=x.b.DecomposeLerp(this._originalBlendValue,X,this._blendingFactor):this._currentValue?x.b.LerpToRef(this._originalBlendValue,X,this._blendingFactor,this._currentValue):this._currentValue=x.b.Lerp(this._originalBlendValue,X,this._blendingFactor):this._currentValue=O.e._UniversalLerp(this._originalBlendValue,X,this._blendingFactor);const u=v&&v.animationPropertiesOverride?v.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=u}else this._currentValue?this._currentValue.p?this._currentValue.p(X):this._currentValue=X:null!==X&&void 0!==X&&X.clone?this._currentValue=X.clone():this._currentValue=X;-1!==u?this._registerTargetForLateAnimationBinding(this,this._originalValue[B]):this._animationState.loopMode===O.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[B],T[this._targetPath]):T[this._targetPath]=this._originalValue[B]+this._currentValue:T[this._targetPath]=this._currentValue,v.Oe&&v.Oe(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(v){let T=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const X=this._animation.getKeys();v<X[0].frame?v=X[0].frame:v>X[X.length-1].frame&&(v=X[X.length-1].frame);const O=this._events;if(O.length)for(let B=0;B<O.length;B++)O[B].onlyOnce||(O[B].isDone=O[B].frame<v);this._currentFrame=v;const u=this._animation._interpolate(v,this._animationState);this.setValue(u,T)}_prepareForSpeedRatioChange(v){const T=this._previousElapsedTime*(this._animation.framePerSecond*v)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-T}animate(v,T,X,u,B){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const A=this._animation,x=A.targetPropertyPath;if(!x||x.length<1)return this._stopped=!0,!1;let f=!0;(T<this._minFrame||T>this._maxFrame)&&(T=this._minFrame),(X<this._minFrame||X>this._maxFrame)&&(X=this._maxFrame);const M=X-T;let H,n=v*(A.framePerSecond*B)/1e3+this._absoluteFrameOffset,V=0,D=!1;const s=u&&this._animationState.loopMode===O.e.ANIMATIONLOOPMODE_YOYO;if(s){const v=(n-T)/M,X=Math.sin(v*Math.PI);n=Math.abs(X)*M+T;const O=X>=0?1:-1;this._yoyoDirection!==O&&(D=!0),this._yoyoDirection=O}if(this._previousElapsedTime=v,this._previousAbsoluteFrame=n,!u&&X>=T&&(n>=M&&B>0||n<=0&&B<0))f=!1,V=A._getKeyValue(this._maxValue);else if(!u&&T>=X&&(n<=M&&B<0||n>=0&&B>0))f=!1,V=A._getKeyValue(this._minValue);else if(this._animationState.loopMode!==O.e.ANIMATIONLOOPMODE_CYCLE){const v=X.toString()+T.toString();if(!this._offsetsCache[v]){this._animationState.repeatCount=0,this._animationState.loopMode=O.e.ANIMATIONLOOPMODE_CYCLE;const u=A._interpolate(T,this._animationState),B=A._interpolate(X,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),A.dataType){case O.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[v]=B-u;break;case O.e.ANIMATIONTYPE_QUATERNION:case O.e.ANIMATIONTYPE_VECTOR3:case O.e.ANIMATIONTYPE_VECTOR2:case O.e.ANIMATIONTYPE_SIZE:case O.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[v]=B.Xc(u)}this._highLimitsCache[v]=B}V=this._highLimitsCache[v],H=this._offsetsCache[v]}if(void 0===H)switch(A.dataType){case O.e.ANIMATIONTYPE_FLOAT:H=0;break;case O.e.ANIMATIONTYPE_QUATERNION:H=O.o;break;case O.e.ANIMATIONTYPE_VECTOR3:H=O.v;break;case O.e.ANIMATIONTYPE_VECTOR2:H=O.t;break;case O.e.ANIMATIONTYPE_SIZE:H=O.q;break;case O.e.ANIMATIONTYPE_COLOR3:H=O.h;break;case O.e.ANIMATIONTYPE_COLOR4:H=O.l}let F;if(this._host&&this._host.syncRoot){const v=this._host.syncRoot;F=T+M*((v.masterFrame-v.fromFrame)/(v.toFrame-v.fromFrame))}else F=n>0&&T>X||n<0&&T<X?f&&0!==M?X+n%M:T:f&&0!==M?T+n%M:X;const k=this._events;if(!s&&(B>0&&this.currentFrame>F||B<0&&this.currentFrame<F)||s&&D){this._onLoop();for(let v=0;v<k.length;v++)k[v].onlyOnce||(k[v].isDone=!1);this._animationState.key=B>0?0:A.getKeys().length-1}this._currentFrame=F,this._animationState.repeatCount=0===M?0:n/M|0,this._animationState.highLimitValue=V,this._animationState.offsetValue=H;const b=A._interpolate(F,this._animationState);if(this.setValue(b,m),k.length)for(let O=0;O<k.length;O++)if(M>=0&&F>=k[O].frame&&k[O].frame>=T||M<0&&F<=k[O].frame&&k[O].frame<=T){const v=k[O];v.isDone||(v.onlyOnce&&(k.splice(O,1),O--),v.isDone=!0,v.action(F))}return f||(this._stopped=!0),f}}var M=X(1133);class H{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(v){this._weight=-1!==v?Math.min(Math.max(v,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(v){for(let T=0;T<this._runtimeAnimations.length;T++){this._runtimeAnimations[T]._prepareForSpeedRatioChange(v)}this._speedRatio=v,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(v,T){let X=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,B=arguments.length>4&&void 0!==arguments[4]&&arguments[4],m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,x=arguments.length>7?arguments[7]:void 0,f=arguments.length>8?arguments[8]:void 0,M=arguments.length>9&&void 0!==arguments[9]&&arguments[9],H=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=T,this.fromFrame=X,this.toFrame=O,this.loopAnimation=B,this.onAnimationEnd=A,this.onAnimationLoop=f,this.isAdditive=M,this.playOrder=H,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Mf=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new u.b,this.onAnimationLoopObservable=new u.b,this._scene=v,x&&this.appendAnimations(T,x),this._speedRatio=m,v._activeAnimatables.push(this)}syncWith(v){if(this._syncRoot=v,v){const v=this._scene._activeAnimatables.indexOf(this);v>-1&&(this._scene._activeAnimatables.splice(v,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(v,T){for(let X=0;X<T.length;X++){const O=T[X],u=new f(v,O,this._scene,this);u._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(u)}}getAnimationByTargetProperty(v){const T=this._runtimeAnimations;for(let X=0;X<T.length;X++)if(T[X].animation.targetProperty===v)return T[X].animation;return null}getRuntimeAnimationByTargetProperty(v){const T=this._runtimeAnimations;for(let X=0;X<T.length;X++)if(T[X].animation.targetProperty===v)return T[X];return null}reset(){const v=this._runtimeAnimations;for(let T=0;T<v.length;T++)v[T].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(v){const T=this._runtimeAnimations;for(let X=0;X<T.length;X++)T[X].animation.enableBlending=!0,T[X].animation.blendingSpeed=v}disableBlending(){const v=this._runtimeAnimations;for(let T=0;T<v.length;T++)v[T].animation.enableBlending=!1}goToFrame(v){const T=this._runtimeAnimations;if(T[0]){const X=T[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??T[0].currentFrame;const O=0===this.speedRatio?0:(v-this._frameToSyncFromJump)/X*1e3/this.speedRatio;this._manualJumpDelay=-O}for(let X=0;X<T.length;X++)T[X].goToFrame(v,this._weight);this._goToFrame=v}get paused(){return this.Mf}pause(){this.Mf||(this.Mf=!0)}restart(){this.Mf=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(v,T){let X=arguments.length>2&&void 0!==arguments[2]&&arguments[2],O=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(v||T){const u=this._scene._activeAnimatables.indexOf(this);if(u>-1){const B=this._runtimeAnimations;for(let X=B.length-1;X>=0;X--){const O=B[X];v&&O.animation.name!=v||(T&&!T(O.target)||(O.dispose(),B.splice(X,1)))}0==B.length&&(X||this._scene._activeAnimatables.splice(u,1),O||this._raiseOnAnimationEnd())}}else{const v=this._scene._activeAnimatables.indexOf(this);if(v>-1){X||this._scene._activeAnimatables.splice(v,1);const T=this._runtimeAnimations;for(let v=0;v<T.length;v++)T[v].dispose();this._runtimeAnimations.length=0,O||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((v=>{this.onAnimationEndObservable.add((()=>{v(this)}),void 0,void 0,this,!0)}))}_animate(v){if(this.Mf)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=v),!0;if(null===this._localDelayOffset?(this._localDelayOffset=v,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=v-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let T=!1;const X=this._runtimeAnimations;let O;for(O=0;O<X.length;O++){const u=X[O].animate(v-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);T=T||u}if(this.animationStarted=T,!T){if(this.disposeOnEnd)for(O=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(O,1),O=0;O<X.length;O++)X[O].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return T}}function n(v){if(0===v.totalWeight&&0===v.totalAdditiveWeight)return v.originalValue;let T=1;const X=x.g.Vd[0],O=x.g.Vd[1],u=x.g.Quaternion[0];let B=0;const m=v.animations[0],A=v.originalValue;let f=1,M=!1;if(v.totalWeight<1)f=1-v.totalWeight,A.decompose(O,u,X);else{if(B=1,T=v.totalWeight,f=m.weight/T,1==f){if(!v.totalAdditiveWeight)return m.currentValue;M=!0}m.currentValue.decompose(O,u,X)}if(!M){O.scaleInPlace(f),X.scaleInPlace(f),u.scaleInPlace(f);for(let m=B;m<v.animations.length;m++){const B=v.animations[m];if(0===B.weight)continue;f=B.weight/T;const A=x.g.Vd[2],M=x.g.Vd[3],H=x.g.Quaternion[1];B.currentValue.decompose(M,H,A),M.scaleAndAddToRef(f,O),H.scaleAndAddToRef(x.f.Dot(u,H)>0?f:-f,u),A.scaleAndAddToRef(f,X)}u.normalize()}for(let n=0;n<v.additiveAnimations.length;n++){const T=v.additiveAnimations[n];if(0===T.weight)continue;const B=x.g.Vd[2],m=x.g.Vd[3],A=x.g.Quaternion[1];T.currentValue.decompose(m,A,B),m.multiplyToRef(O,m),x.l.LerpToRef(O,m,T.weight,O),u.multiplyToRef(A,A),x.f.SlerpToRef(u,A,T.weight,u),B.scaleAndAddToRef(T.weight,X)}const H=m?m._animationState.workValue:x.g.Matrix[0].clone();return x.b.ComposeToRef(O,u,X,H),H}function V(v,T){if(0===v.totalWeight&&0===v.totalAdditiveWeight)return T;const X=v.animations[0],O=v.originalValue;let u=T;if(0===v.totalWeight&&v.totalAdditiveWeight>0)u.p(O);else if(1===v.animations.length){if(x.f.SlerpToRef(O,X.currentValue,Math.min(1,v.totalWeight),u),0===v.totalAdditiveWeight)return u}else if(v.animations.length>1){let X,B,m=1;if(v.totalWeight<1){const T=1-v.totalWeight;X=[],B=[],X.push(O),B.push(T)}else{if(2===v.animations.length&&(x.f.SlerpToRef(v.animations[0].currentValue,v.animations[1].currentValue,v.animations[1].weight/v.totalWeight,T),0===v.totalAdditiveWeight))return T;X=[],B=[],m=v.totalWeight}for(let T=0;T<v.animations.length;T++){const O=v.animations[T];X.push(O.currentValue),B.push(O.weight/m)}let A=0;for(let v=0;v<X.length;)v?(A+=B[v],x.f.SlerpToRef(u,X[v],B[v]/A,u),v++):(x.f.SlerpToRef(X[v],X[v+1],B[v+1]/(B[v]+B[v+1]),T),u=T,A=B[v]+B[v+1],v+=2)}for(let B=0;B<v.additiveAnimations.length;B++){const T=v.additiveAnimations[B];0!==T.weight&&(u.multiplyToRef(T.currentValue,x.g.Quaternion[0]),x.f.SlerpToRef(u,x.g.Quaternion[0],T.weight,u))}return u}var D,s,F=X(1209);D=F.e,(s=A.c)&&(s.prototype.copyAnimationRange=function(v,T,X){let u=arguments.length>3&&void 0!==arguments[3]&&arguments[3],B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new O.e(this.name,"_matrix",v.animations[0].framePerSecond,O.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const m=v.animations[0].getRange(T);if(!m)return!1;const A=m.from,x=m.to,f=v.animations[0].getKeys(),M=v.length,H=v.getParent(),n=this.getParent(),V=u&&H&&M&&this.length&&M!==this.length,D=V&&n&&H?n.length/H.length:1,s=u&&!n&&B&&(1!==B.x||1!==B.y||1!==B.z),F=this.animations[0].getKeys();let k,b,l;for(let O=0,Q=f.length;O<Q;O++)k=f[O],k.frame>=A&&k.frame<=x&&(u?(l=k.value.clone(),V?(b=l.getTranslation(),l.setTranslation(b.scaleInPlace(D))):s&&B?(b=l.getTranslation(),l.setTranslation(b.multiplyInPlace(B))):l=k.value):l=k.value,F.push({frame:k.frame+X,value:l}));return this.animations[0].createRange(T,A+X,x+X),!0}),D&&(D.prototype._animate=function(v){if(!this.animationsEnabled)return;const T=M.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=T}this.deltaTime=void 0!==v?v:this.useConstantAnimationDeltaTime?16:(T-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=T;const X=this._activeAnimatables;if(0===X.length)return;this._animationTime+=this.deltaTime;const u=this._animationTime;for(let O=0;O<X.length;O++){const v=X[O];!v._animate(u)&&v.disposeOnEnd&&O--}!function(v){if(v._registeredForLateAnimationBindings.length){for(let T=0;T<v._registeredForLateAnimationBindings.length;T++){const X=v._registeredForLateAnimationBindings.data[T];for(const v in X._lateAnimationHolders){const T=X._lateAnimationHolders[v],u=T.animations[0],B=T.originalValue;if(void 0===B||null===B)continue;const m=O.e.AllowMatrixDecomposeForInterpolation&&B.m;let A=X[v];if(m)A=n(T);else if(void 0!==B.w)A=V(T,A||x.f.Identity());else{let v=0,X=1;const m=u&&u._animationState.loopMode===O.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(T.totalWeight<1)A=m?B.clone?B.clone():B:u&&B.scale?B.scale(1-T.totalWeight):u?B*(1-T.totalWeight):B.clone?B.clone():B;else if(u){X=T.totalWeight;const O=u.weight/X;A=1!==O?u.currentValue.scale?u.currentValue.scale(O):u.currentValue*O:u.currentValue,m&&(A.addToRef?A.addToRef(B,A):A+=B),v=1}for(let O=v;O<T.animations.length;O++){const v=T.animations[O],u=v.weight/X;u&&(v.currentValue.scaleAndAddToRef?v.currentValue.scaleAndAddToRef(u,A):A+=v.currentValue*u)}for(let O=0;O<T.additiveAnimations.length;O++){const v=T.additiveAnimations[O],X=v.weight;X&&(v.currentValue.scaleAndAddToRef?v.currentValue.scaleAndAddToRef(X,A):A+=v.currentValue*X)}}X[v]=A}X._lateAnimationHolders={}}v._registeredForLateAnimationBindings.reset()}}(this)},D.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((v,T)=>v.playOrder-T.playOrder))},D.prototype.beginWeightedAnimation=function(v,T,X){let O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,u=arguments.length>4?arguments[4]:void 0,B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,m=arguments.length>6?arguments[6]:void 0,A=arguments.length>7?arguments[7]:void 0,x=arguments.length>8?arguments[8]:void 0,f=arguments.length>9?arguments[9]:void 0,M=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const H=this.beginAnimation(v,T,X,u,B,m,A,!1,x,f,M);return H.weight=O,H},D.prototype.beginAnimation=function(v,T,X,O){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,B=arguments.length>5?arguments[5]:void 0,m=arguments.length>6?arguments[6]:void 0,A=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],x=arguments.length>8?arguments[8]:void 0,f=arguments.length>9?arguments[9]:void 0,M=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(u<0){const v=T;T=X,X=v,u=-u}T>X&&(u=-u),A&&this.stopAnimation(v,void 0,x),m||(m=new H(this,v,T,X,O,u,B,void 0,f,M));const n=!x||x(v);if(v.animations&&n&&m.appendAnimations(v,v.animations),v.getAnimatables){const M=v.getAnimatables();for(let v=0;v<M.length;v++)this.beginAnimation(M[v],T,X,O,u,B,m,A,x,f)}return m.reset(),m},D.prototype.beginHierarchyAnimation=function(v,T,X,O,u){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,m=arguments.length>6?arguments[6]:void 0,A=arguments.length>7?arguments[7]:void 0,x=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],f=arguments.length>9?arguments[9]:void 0,M=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const H=v.getDescendants(T),n=[];n.push(this.beginAnimation(v,X,O,u,B,m,A,x,f,void 0,M));for(const V of H)n.push(this.beginAnimation(V,X,O,u,B,m,A,x,f,void 0,M));return n},D.prototype.beginDirectAnimation=function(v,T,X,O,u){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(B<0){const v=X;X=O,O=v,B=-B}return X>O&&(B=-B),new H(this,v,X,O,u,B,arguments.length>6?arguments[6]:void 0,T,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},D.prototype.beginDirectHierarchyAnimation=function(v,T,X,O,u,B,m,A,x){let f=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const M=v.getDescendants(T),H=[];H.push(this.beginDirectAnimation(v,X,O,u,B,m,A,x,f));for(const n of M)H.push(this.beginDirectAnimation(n,X,O,u,B,m,A,x,f));return H},D.prototype.getAnimatableByTarget=function(v){for(let T=0;T<this._activeAnimatables.length;T++)if(this._activeAnimatables[T].target===v)return this._activeAnimatables[T];return null},D.prototype.getAllAnimatablesByTarget=function(v){const T=[];for(let X=0;X<this._activeAnimatables.length;X++)this._activeAnimatables[X].target===v&&T.push(this._activeAnimatables[X]);return T},D.prototype.stopAnimation=function(v,T,X){const O=this.getAllAnimatablesByTarget(v);for(const u of O)u.stop(T,X)},D.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let v=0;v<this._activeAnimatables.length;v++)this._activeAnimatables[v].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const v of this.animationGroups)v.stop()});class k{getClassName(){return"TargetedAnimation"}serialize(){const v={};return v.animation=this.animation.serialize(),v.targetId=this.target.id,v}}class b{get mask(){return this._mask}set mask(v){this._mask!==v&&(this._mask=v,this.syncWithMask(!0))}syncWithMask(){let v=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||v){this._numActiveAnimatables=0;for(let v=0;v<this._animatables.length;++v){const T=this._animatables[v];!this.mask||this.mask.disabled||this.mask.retainsTarget(T.target.name)?(this._numActiveAnimatables++,T.paused&&T.restart()):T.paused||T.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let v=0;v<this._animatables.length;++v){const T=this._animatables[v];this.mask.retainsTarget(T.target.name)||(T.stop(),this._animatables.splice(v,1),--v)}for(let v=0;v<this._targetedAnimations.length;v++){const T=this._targetedAnimations[v];this.mask.retainsTarget(T.target.name)||(this._targetedAnimations.splice(v,1),--v)}}}get from(){return this._from}set from(v){if(this._from!==v){this._from=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].fromFrame=this._from}}}get to(){return this._to}set to(v){if(this._to!==v){this._to=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(v){if(this._speedRatio!==v){this._speedRatio=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(v){if(this._loopAnimation!==v){this._loopAnimation=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(v){if(this._isAdditive!==v){this._isAdditive=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(v){this._weight!==v&&(this._weight=v,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(v){if(this._playOrder!==v&&(this._playOrder=v,this._animatables.length>0)){for(let v=0;v<this._animatables.length;v++)this._animatables[v].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(v){if(this._enableBlending!==v&&(this._enableBlending=v,null!==v))for(let T=0;T<this._targetedAnimations.length;++T)this._targetedAnimations[T].animation.enableBlending=v}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(v){if(this._blendingSpeed!==v&&(this._blendingSpeed=v,null!==v))for(let T=0;T<this._targetedAnimations.length;++T)this._targetedAnimations[T].animation.blendingSpeed=v}getLength(v,T){v=v??this._from;return((T=T??this._to)-v)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(v){let T=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],X=arguments.length>2&&void 0!==arguments[2]&&arguments[2],O=arguments.length>3?arguments[3]:void 0;if(0===v.length)return null;O=O??v[0].weight;let u=Number.MAX_VALUE,B=-Number.MAX_VALUE;if(X)for(const A of v)A.from<u&&(u=A.from),A.to>B&&(B=A.to);const m=new b(v[0].name+"_merged",v[0]._scene,O);for(const A of v){X&&A.normalize(u,B);for(const v of A.targetedAnimations)m.addTargetedAnimation(v.animation,v.target);T&&A.dispose()}return m}constructor(v){let T=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,X=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=v,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new u.b,this.onAnimationLoopObservable=new u.b,this.onAnimationGroupLoopObservable=new u.b,this.onAnimationGroupEndObservable=new u.b,this.onAnimationGroupPauseObservable=new u.b,this.onAnimationGroupPlayObservable=new u.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=T||B.c.LastCreatedScene,this._weight=X,this._playOrder=O,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(v,T){const X=new k;X.animation=v,X.target=T;const O=v.getKeys();return this._from>O[0].frame&&(this._from=O[0].frame),this._to<O[O.length-1].frame&&(this._to=O[O.length-1].frame),null!==this._enableBlending&&(v.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(v.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(X),this._shouldStart=!0,X}removeTargetedAnimation(v){for(let T=this._targetedAnimations.length-1;T>-1;T--){this._targetedAnimations[T].animation===v&&this._targetedAnimations.splice(T,1)}}normalize(){let v=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,T=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==v&&(v=this._from),null==T&&(T=this._to);for(let X=0;X<this._targetedAnimations.length;X++){const O=this._targetedAnimations[X].animation.getKeys(),u=O[0],B=O[O.length-1];if(u.frame>v){const T={frame:v,value:u.value,inTangent:u.inTangent,outTangent:u.outTangent,interpolation:u.interpolation};O.splice(0,0,T)}if(B.frame<T){const v={frame:T,value:B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation};O.push(v)}}return this._from=v,this._to=T,this}_processLoop(v,T,X){v.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(T),this._animationLoopFlags[X]||(this._animationLoopFlags[X]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let v=arguments.length>0&&void 0!==arguments[0]&&arguments[0],T=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,X=arguments.length>2?arguments[2]:void 0,O=arguments.length>3?arguments[3]:void 0,u=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=v,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let B=0;B<this._targetedAnimations.length;B++){const m=this._targetedAnimations[B],A=this._scene.beginDirectAnimation(m.target,[m.animation],void 0!==X?X:this._from,void 0!==O?O:this._to,v,T,void 0,void 0,void 0!==u?u:this._isAdditive);A.weight=this._weight,A.playOrder=this._playOrder,A.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(m),this._checkAnimationGroupEnded(A)},this._processLoop(A,m,B),this._animatables.push(A)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=T,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let v=0;v<this._animatables.length;v++){this._animatables[v].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(v){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==v&&(this.loopAnimation=v),this.restart()):(this.stop(),this.start(v,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let v=0;v<this._animatables.length;v++){this._animatables[v].reset()}return this}restart(){if(!this._isStarted)return this;for(let v=0;v<this._animatables.length;v++){this._animatables[v].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let v=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const T=this._animatables.slice();for(let O=0;O<T.length;O++)T[O].stop(void 0,void 0,!0,v);let X=0;for(let O=0;O<this._scene._activeAnimatables.length;O++){const T=this._scene._activeAnimatables[O];T._runtimeAnimations.length>0?this._scene._activeAnimatables[X++]=T:v&&this._checkAnimationGroupEnded(T,v)}return this._scene._activeAnimatables.length=X,this._isStarted=!1,this}setWeightForAllAnimatables(v){for(let T=0;T<this._animatables.length;T++){this._animatables[T].weight=v}return this}syncAllAnimationsWith(v){for(let T=0;T<this._animatables.length;T++){this._animatables[T].syncWith(v)}return this}goToFrame(v){if(!this._isStarted)return this;for(let T=0;T<this._animatables.length;T++){this._animatables[T].goToFrame(v)}return this}getCurrentFrame(){var v;return(null===(v=this.animatables[0])||void 0===v?void 0:v.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const v=this._scene.animationGroups.indexOf(this);if(v>-1&&this._scene.animationGroups.splice(v,1),this._parentContainer){const v=this._parentContainer.animationGroups.indexOf(this);v>-1&&this._parentContainer.animationGroups.splice(v,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(v){let T=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const X=this._animatables.indexOf(v);X>-1&&this._animatables.splice(X,1),0===this._animatables.length&&(this._isStarted=!1,T||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(v,T){let X=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const O=new b(v||this.name,this._scene,this._weight,this._playOrder);O._from=this.from,O._to=this.to,O._speedRatio=this.speedRatio,O._loopAnimation=this.loopAnimation,O._isAdditive=this.isAdditive,O._enableBlending=this.enableBlending,O._blendingSpeed=this.blendingSpeed,O.metadata=this.metadata,O.mask=this.mask;for(const u of this._targetedAnimations)O.addTargetedAnimation(X?u.animation.clone():u.animation,T?T(u.target):u.target);return O}serialize(){const v={};v.name=this.name,v.from=this.from,v.to=this.to,v.speedRatio=this.speedRatio,v.loopAnimation=this.loopAnimation,v.isAdditive=this.isAdditive,v.weight=this.weight,v.playOrder=this.playOrder,v.enableBlending=this.enableBlending,v.blendingSpeed=this.blendingSpeed,v.targetedAnimations=[];for(let T=0;T<this.targetedAnimations.length;T++){const X=this.targetedAnimations[T];v.targetedAnimations[T]=X.serialize()}return m.d&&m.d.HasTags(this)&&(v.tags=m.d.GetTags(this)),this.metadata&&(v.metadata=this.metadata),v}static Parse(v,T){const X=new b(v.name,T,v.weight,v.playOrder);for(let u=0;u<v.targetedAnimations.length;u++){const B=v.targetedAnimations[u],m=O.e.Parse(B.animation),A=B.targetId;if("influence"===B.animation.property){const v=T.getMorphTargetById(A);v&&X.addTargetedAnimation(m,v)}else{const v=T.getNodeById(A);null!=v&&X.addTargetedAnimation(m,v)}}return m.d&&m.d.AddTagsTo(X,v.tags),null!==v.from&&null!==v.to&&X.normalize(v.from,v.to),void 0!==v.speedRatio&&(X._speedRatio=v.speedRatio),void 0!==v.loopAnimation&&(X._loopAnimation=v.loopAnimation),void 0!==v.isAdditive&&(X._isAdditive=v.isAdditive),void 0!==v.weight&&(X._weight=v.weight),void 0!==v.playOrder&&(X._playOrder=v.playOrder),void 0!==v.enableBlending&&(X._enableBlending=v.enableBlending),void 0!==v.blendingSpeed&&(X._blendingSpeed=v.blendingSpeed),void 0!==v.metadata&&(X.metadata=v.metadata),X}static MakeAnimationAdditive(v,T,X){let u;u="object"===typeof T?T:{referenceFrame:T,range:X,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let B=v;u.cloneOriginalAnimationGroup&&(B=v.clone(u.clonedAnimationGroupName||B.name));const m=B.targetedAnimations;for(let A=0;A<m.length;A++){const v=m[A];v.animation=O.e.MakeAnimationAdditive(v.animation,u)}if(B.isAdditive=!0,u.clipKeys){let v=Number.MAX_VALUE,T=-Number.MAX_VALUE;const X=B.targetedAnimations;for(let O=0;O<X.length;O++){const u=X[O].animation.getKeys();v>u[0].frame&&(v=u[0].frame),T<u[u.length-1].frame&&(T=u[u.length-1].frame)}B._from=v,B._to=T}return B}static ClipKeys(v,T,X,O,u){const B=v.clone(O||v.name);return b.ClipKeysInPlace(B,T,X,u)}static ClipKeysInPlace(v,T,X,O){return b.ClipInPlace(v,T,X,O,!1)}static ClipFrames(v,T,X,O,u){const B=v.clone(O||v.name);return b.ClipFramesInPlace(B,T,X,u)}static ClipFramesInPlace(v,T,X,O){return b.ClipInPlace(v,T,X,O,!0)}static ClipInPlace(v,T,X,O){let u=arguments.length>4&&void 0!==arguments[4]&&arguments[4],B=Number.MAX_VALUE,m=-Number.MAX_VALUE;const A=v.targetedAnimations;for(let x=0;x<A.length;x++){const v=A[x],f=O?v.animation:v.animation.clone();u&&(f.createKeyForFrame(T),f.createKeyForFrame(X));const M=f.getKeys(),H=[];let n=Number.MAX_VALUE;for(let O=0;O<M.length;O++){const v=M[O];if(!u&&O>=T&&O<=X||u&&v.frame>=T&&v.frame<=X){const T={frame:v.frame,value:v.value.clone?v.value.clone():v.value,inTangent:v.inTangent,outTangent:v.outTangent,interpolation:v.interpolation,lockedTangent:v.lockedTangent};n===Number.MAX_VALUE&&(n=T.frame),T.frame-=n,H.push(T)}}0!==H.length?(B>H[0].frame&&(B=H[0].frame),m<H[H.length-1].frame&&(m=H[H.length-1].frame),f.setKeys(H,!0),v.animation=f):(A.splice(x,1),x--)}return v._from=B,v._to=m,v}getClassName(){return"AnimationGroup"}toString(v){let T="Name: "+this.name;return T+=", type: "+this.getClassName(),v&&(T+=", from: "+this._from,T+=", to: "+this._to,T+=", isStarted: "+this._isStarted,T+=", speedRatio: "+this._speedRatio,T+=", targetedAnimations length: "+this._targetedAnimations.length,T+=", animatables length: "+this._animatables),T}}}}]);