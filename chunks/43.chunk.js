"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12381:(d,m,g)=>{g.r(m),g.d(m,{AnimationGroup:()=>R,TargetedAnimation:()=>O});var V=g(11772),u=g(1009),D=g(1037),j=g(1151),z=g(11763),s=g(1012);class U{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(d,m,g,u){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=m,this._target=d,this._scene=g,this._host=u,this._activeTargets=[],m._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===V.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=s.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const d={frame:0,value:this._minValue};this._keys.splice(0,0,d)}if(this._target instanceof Array){let d=0;for(const m of this._target)this._preparePath(m,d),this._getOriginalValues(d),d++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const D=m.getEvents();D&&D.length>0&&D.forEach((d=>{this._events.push(d._clone())})),this._enableBlending=d&&d.animationPropertiesOverride?d.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(d){let m=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const g=this._animation.targetPropertyPath;if(g.length>1){let V=d;for(let d=0;d<g.length-1;d++){const m=g[d];if(V=V[m],void 0===V)throw new Error(`Invalid property (${m}) in property path (${g.join(".")})`)}this._targetPath=g[g.length-1],this._activeTargets[m]=V}else this._targetPath=g[0],this._activeTargets[m]=d;if(void 0===this._activeTargets[m][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${g.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let d=0;for(const m of this._target)void 0!==this._originalValue[d]&&this._setValue(m,this._activeTargets[d],this._originalValue[d],-1,d),d++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let d=0;d<this._events.length;d++)this._events[d].isDone=!1}isStopped(){return this._stopped}dispose(){const d=this._animation.runtimeAnimations.indexOf(this);d>-1&&this._animation.runtimeAnimations.splice(d,1)}setValue(d,m){if(this._targetIsArray)for(let g=0;g<this._target.length;g++){const V=this._target[g];this._setValue(V,this._activeTargets[g],d,m,g)}else this._setValue(this._target,this._directTarget,d,m,0)}_getOriginalValues(){let d,m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const g=this._activeTargets[m];d=g.getLocalMatrix&&"_matrix"===this._targetPath?g.getLocalMatrix():g[this._targetPath],d&&d.clone?this._originalValue[m]=d.clone():this._originalValue[m]=d}_registerTargetForLateAnimationBinding(d,m){const g=d.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(g),g._lateAnimationHolders||(g._lateAnimationHolders={}),g._lateAnimationHolders[d.targetPath]||(g._lateAnimationHolders[d.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:m}),d.isAdditive?(g._lateAnimationHolders[d.targetPath].additiveAnimations.push(d),g._lateAnimationHolders[d.targetPath].totalAdditiveWeight+=d.weight):(g._lateAnimationHolders[d.targetPath].animations.push(d),g._lateAnimationHolders[d.targetPath].totalWeight+=d.weight)}_setValue(d,m,g,u,D){if(this._currentActiveTarget=m,this._weight=u,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const d=m[this._targetPath];d.clone?this._originalBlendValue=d.clone():this._originalBlendValue=d}this._originalBlendValue.m?V.e.AllowMatrixDecomposeForInterpolation?this._currentValue?s.d.DecomposeLerpToRef(this._originalBlendValue,g,this._blendingFactor,this._currentValue):this._currentValue=s.d.DecomposeLerp(this._originalBlendValue,g,this._blendingFactor):this._currentValue?s.d.LerpToRef(this._originalBlendValue,g,this._blendingFactor,this._currentValue):this._currentValue=s.d.Lerp(this._originalBlendValue,g,this._blendingFactor):this._currentValue=V.e._UniversalLerp(this._originalBlendValue,g,this._blendingFactor);const u=d&&d.animationPropertiesOverride?d.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=u}else this._currentValue?this._currentValue.p?this._currentValue.p(g):this._currentValue=g:null!==g&&void 0!==g&&g.clone?this._currentValue=g.clone():this._currentValue=g;-1!==u?this._registerTargetForLateAnimationBinding(this,this._originalValue[D]):this._animationState.loopMode===V.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[D],m[this._targetPath]):m[this._targetPath]=this._originalValue[D]+this._currentValue:m[this._targetPath]=this._currentValue,d.se&&d.se(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(d){let m=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const g=this._animation.getKeys();d<g[0].frame?d=g[0].frame:d>g[g.length-1].frame&&(d=g[g.length-1].frame);const V=this._events;if(V.length)for(let D=0;D<V.length;D++)V[D].onlyOnce||(V[D].isDone=V[D].frame<d);this._currentFrame=d;const u=this._animation._interpolate(d,this._animationState);this.setValue(u,m)}_prepareForSpeedRatioChange(d){const m=this._previousElapsedTime*(this._animation.framePerSecond*d)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-m}animate(d,m,g,u,D){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const z=this._animation,s=z.targetPropertyPath;if(!s||s.length<1)return this._stopped=!0,!1;let U=!0;(m<this._minFrame||m>this._maxFrame)&&(m=this._minFrame),(g<this._minFrame||g>this._maxFrame)&&(g=this._maxFrame);const X=g-m;let Y,Q=d*(z.framePerSecond*D)/1e3+this._absoluteFrameOffset,B=0,i=!1;const C=u&&this._animationState.loopMode===V.e.ANIMATIONLOOPMODE_YOYO;if(C){const d=(Q-m)/X,g=Math.sin(d*Math.PI);Q=Math.abs(g)*X+m;const V=g>=0?1:-1;this._yoyoDirection!==V&&(i=!0),this._yoyoDirection=V}if(this._previousElapsedTime=d,this._previousAbsoluteFrame=Q,!u&&g>=m&&(Q>=X&&D>0||Q<=0&&D<0))U=!1,B=z._getKeyValue(this._maxValue);else if(!u&&m>=g&&(Q<=X&&D<0||Q>=0&&D>0))U=!1,B=z._getKeyValue(this._minValue);else if(this._animationState.loopMode!==V.e.ANIMATIONLOOPMODE_CYCLE){const d=g.toString()+m.toString();if(!this._offsetsCache[d]){this._animationState.repeatCount=0,this._animationState.loopMode=V.e.ANIMATIONLOOPMODE_CYCLE;const u=z._interpolate(m,this._animationState),D=z._interpolate(g,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),z.dataType){case V.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[d]=D-u;break;case V.e.ANIMATIONTYPE_QUATERNION:case V.e.ANIMATIONTYPE_VECTOR3:case V.e.ANIMATIONTYPE_VECTOR2:case V.e.ANIMATIONTYPE_SIZE:case V.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[d]=D.Vc(u)}this._highLimitsCache[d]=D}B=this._highLimitsCache[d],Y=this._offsetsCache[d]}if(void 0===Y)switch(z.dataType){case V.e.ANIMATIONTYPE_FLOAT:Y=0;break;case V.e.ANIMATIONTYPE_QUATERNION:Y=V.n;break;case V.e.ANIMATIONTYPE_VECTOR3:Y=V.s;break;case V.e.ANIMATIONTYPE_VECTOR2:Y=V.r;break;case V.e.ANIMATIONTYPE_SIZE:Y=V.p;break;case V.e.ANIMATIONTYPE_COLOR3:Y=V.f;break;case V.e.ANIMATIONTYPE_COLOR4:Y=V.j}let L;if(this._host&&this._host.syncRoot){const d=this._host.syncRoot;L=m+X*((d.masterFrame-d.fromFrame)/(d.toFrame-d.fromFrame))}else L=Q>0&&m>g||Q<0&&m<g?U&&0!==X?g+Q%X:m:U&&0!==X?m+Q%X:g;const O=this._events;if(!C&&(D>0&&this.currentFrame>L||D<0&&this.currentFrame<L)||C&&i){this._onLoop();for(let d=0;d<O.length;d++)O[d].onlyOnce||(O[d].isDone=!1);this._animationState.key=D>0?0:z.getKeys().length-1}this._currentFrame=L,this._animationState.repeatCount=0===X?0:Q/X|0,this._animationState.highLimitValue=B,this._animationState.offsetValue=Y;const R=z._interpolate(L,this._animationState);if(this.setValue(R,j),O.length)for(let V=0;V<O.length;V++)if(X>=0&&L>=O[V].frame&&O[V].frame>=m||X<0&&L<=O[V].frame&&O[V].frame<=m){const d=O[V];d.isDone||(d.onlyOnce&&(O.splice(V,1),V--),d.isDone=!0,d.action(L))}return U||(this._stopped=!0),U}}var X=g(1132);class Y{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(d){this._weight=-1!==d?Math.min(Math.max(d,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(d){for(let m=0;m<this._runtimeAnimations.length;m++){this._runtimeAnimations[m]._prepareForSpeedRatioChange(d)}this._speedRatio=d,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(d,m){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,D=arguments.length>4&&void 0!==arguments[4]&&arguments[4],j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,z=arguments.length>6?arguments[6]:void 0,s=arguments.length>7?arguments[7]:void 0,U=arguments.length>8?arguments[8]:void 0,X=arguments.length>9&&void 0!==arguments[9]&&arguments[9],Y=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=m,this.fromFrame=g,this.toFrame=V,this.loopAnimation=D,this.onAnimationEnd=z,this.onAnimationLoop=U,this.isAdditive=X,this.playOrder=Y,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Id=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new u.d,this.onAnimationLoopObservable=new u.d,this._scene=d,s&&this.appendAnimations(m,s),this._speedRatio=j,d._activeAnimatables.push(this)}syncWith(d){if(this._syncRoot=d,d){const d=this._scene._activeAnimatables.indexOf(this);d>-1&&(this._scene._activeAnimatables.splice(d,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(d,m){for(let g=0;g<m.length;g++){const V=m[g],u=new U(d,V,this._scene,this);u._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(u)}}getAnimationByTargetProperty(d){const m=this._runtimeAnimations;for(let g=0;g<m.length;g++)if(m[g].animation.targetProperty===d)return m[g].animation;return null}getRuntimeAnimationByTargetProperty(d){const m=this._runtimeAnimations;for(let g=0;g<m.length;g++)if(m[g].animation.targetProperty===d)return m[g];return null}reset(){const d=this._runtimeAnimations;for(let m=0;m<d.length;m++)d[m].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(d){const m=this._runtimeAnimations;for(let g=0;g<m.length;g++)m[g].animation.enableBlending=!0,m[g].animation.blendingSpeed=d}disableBlending(){const d=this._runtimeAnimations;for(let m=0;m<d.length;m++)d[m].animation.enableBlending=!1}goToFrame(d){const m=this._runtimeAnimations;if(m[0]){const g=m[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??m[0].currentFrame;const V=0===this.speedRatio?0:(d-this._frameToSyncFromJump)/g*1e3/this.speedRatio;this._manualJumpDelay=-V}for(let g=0;g<m.length;g++)m[g].goToFrame(d,this._weight);this._goToFrame=d}get paused(){return this.Id}pause(){this.Id||(this.Id=!0)}restart(){this.Id=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(d,m){let g=arguments.length>2&&void 0!==arguments[2]&&arguments[2],V=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(d||m){const u=this._scene._activeAnimatables.indexOf(this);if(u>-1){const D=this._runtimeAnimations;for(let g=D.length-1;g>=0;g--){const V=D[g];d&&V.animation.name!=d||(m&&!m(V.target)||(V.dispose(),D.splice(g,1)))}0==D.length&&(g||this._scene._activeAnimatables.splice(u,1),V||this._raiseOnAnimationEnd())}}else{const d=this._scene._activeAnimatables.indexOf(this);if(d>-1){g||this._scene._activeAnimatables.splice(d,1);const m=this._runtimeAnimations;for(let d=0;d<m.length;d++)m[d].dispose();this._runtimeAnimations.length=0,V||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((d=>{this.onAnimationEndObservable.add((()=>{d(this)}),void 0,void 0,this,!0)}))}_animate(d){if(this.Id)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=d),!0;if(null===this._localDelayOffset?(this._localDelayOffset=d,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=d-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let m=!1;const g=this._runtimeAnimations;let V;for(V=0;V<g.length;V++){const u=g[V].animate(d-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);m=m||u}if(this.animationStarted=m,!m){if(this.disposeOnEnd)for(V=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(V,1),V=0;V<g.length;V++)g[V].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return m}}function Q(d){if(0===d.totalWeight&&0===d.totalAdditiveWeight)return d.originalValue;let m=1;const g=s.h.Pd[0],V=s.h.Pd[1],u=s.h.Quaternion[0];let D=0;const j=d.animations[0],z=d.originalValue;let U=1,X=!1;if(d.totalWeight<1)U=1-d.totalWeight,z.decompose(V,u,g);else{if(D=1,m=d.totalWeight,U=j.weight/m,1==U){if(!d.totalAdditiveWeight)return j.currentValue;X=!0}j.currentValue.decompose(V,u,g)}if(!X){V.scaleInPlace(U),g.scaleInPlace(U),u.scaleInPlace(U);for(let j=D;j<d.animations.length;j++){const D=d.animations[j];if(0===D.weight)continue;U=D.weight/m;const z=s.h.Pd[2],X=s.h.Pd[3],Y=s.h.Quaternion[1];D.currentValue.decompose(X,Y,z),X.scaleAndAddToRef(U,V),Y.scaleAndAddToRef(s.f.Dot(u,Y)>0?U:-U,u),z.scaleAndAddToRef(U,g)}u.normalize()}for(let Q=0;Q<d.additiveAnimations.length;Q++){const m=d.additiveAnimations[Q];if(0===m.weight)continue;const D=s.h.Pd[2],j=s.h.Pd[3],z=s.h.Quaternion[1];m.currentValue.decompose(j,z,D),j.multiplyToRef(V,j),s.m.LerpToRef(V,j,m.weight,V),u.multiplyToRef(z,z),s.f.SlerpToRef(u,z,m.weight,u),D.scaleAndAddToRef(m.weight,g)}const Y=j?j._animationState.workValue:s.h.Matrix[0].clone();return s.d.ComposeToRef(V,u,g,Y),Y}function B(d,m){if(0===d.totalWeight&&0===d.totalAdditiveWeight)return m;const g=d.animations[0],V=d.originalValue;let u=m;if(0===d.totalWeight&&d.totalAdditiveWeight>0)u.p(V);else if(1===d.animations.length){if(s.f.SlerpToRef(V,g.currentValue,Math.min(1,d.totalWeight),u),0===d.totalAdditiveWeight)return u}else if(d.animations.length>1){let g,D,j=1;if(d.totalWeight<1){const m=1-d.totalWeight;g=[],D=[],g.push(V),D.push(m)}else{if(2===d.animations.length&&(s.f.SlerpToRef(d.animations[0].currentValue,d.animations[1].currentValue,d.animations[1].weight/d.totalWeight,m),0===d.totalAdditiveWeight))return m;g=[],D=[],j=d.totalWeight}for(let m=0;m<d.animations.length;m++){const V=d.animations[m];g.push(V.currentValue),D.push(V.weight/j)}let z=0;for(let d=0;d<g.length;)d?(z+=D[d],s.f.SlerpToRef(u,g[d],D[d]/z,u),d++):(s.f.SlerpToRef(g[d],g[d+1],D[d+1]/(D[d]+D[d+1]),m),u=m,z=D[d]+D[d+1],d+=2)}for(let D=0;D<d.additiveAnimations.length;D++){const m=d.additiveAnimations[D];0!==m.weight&&(u.multiplyToRef(m.currentValue,s.h.Quaternion[0]),s.f.SlerpToRef(u,s.h.Quaternion[0],m.weight,u))}return u}var i,C,L=g(1188);i=L.e,(C=z.b)&&(C.prototype.copyAnimationRange=function(d,m,g){let u=arguments.length>3&&void 0!==arguments[3]&&arguments[3],D=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new V.e(this.name,"_matrix",d.animations[0].framePerSecond,V.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const j=d.animations[0].getRange(m);if(!j)return!1;const z=j.from,s=j.to,U=d.animations[0].getKeys(),X=d.length,Y=d.getParent(),Q=this.getParent(),B=u&&Y&&X&&this.length&&X!==this.length,i=B&&Q&&Y?Q.length/Y.length:1,C=u&&!Q&&D&&(1!==D.x||1!==D.y||1!==D.z),L=this.animations[0].getKeys();let O,R,J;for(let V=0,c=U.length;V<c;V++)O=U[V],O.frame>=z&&O.frame<=s&&(u?(J=O.value.clone(),B?(R=J.getTranslation(),J.setTranslation(R.scaleInPlace(i))):C&&D?(R=J.getTranslation(),J.setTranslation(R.multiplyInPlace(D))):J=O.value):J=O.value,L.push({frame:O.frame+g,value:J}));return this.animations[0].createRange(m,z+g,s+g),!0}),i&&(i.prototype._animate=function(d){if(!this.animationsEnabled)return;const m=X.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=m}this.deltaTime=void 0!==d?d:this.useConstantAnimationDeltaTime?16:(m-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=m;const g=this._activeAnimatables;if(0===g.length)return;this._animationTime+=this.deltaTime;const u=this._animationTime;for(let V=0;V<g.length;V++){const d=g[V];!d._animate(u)&&d.disposeOnEnd&&V--}!function(d){if(d._registeredForLateAnimationBindings.length){for(let m=0;m<d._registeredForLateAnimationBindings.length;m++){const g=d._registeredForLateAnimationBindings.data[m];for(const d in g._lateAnimationHolders){const m=g._lateAnimationHolders[d],u=m.animations[0],D=m.originalValue;if(void 0===D||null===D)continue;const j=V.e.AllowMatrixDecomposeForInterpolation&&D.m;let z=g[d];if(j)z=Q(m);else if(void 0!==D.w)z=B(m,z||s.f.Identity());else{let d=0,g=1;const j=u&&u._animationState.loopMode===V.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(m.totalWeight<1)z=j?D.clone?D.clone():D:u&&D.scale?D.scale(1-m.totalWeight):u?D*(1-m.totalWeight):D.clone?D.clone():D;else if(u){g=m.totalWeight;const V=u.weight/g;z=1!==V?u.currentValue.scale?u.currentValue.scale(V):u.currentValue*V:u.currentValue,j&&(z.addToRef?z.addToRef(D,z):z+=D),d=1}for(let V=d;V<m.animations.length;V++){const d=m.animations[V],u=d.weight/g;u&&(d.currentValue.scaleAndAddToRef?d.currentValue.scaleAndAddToRef(u,z):z+=d.currentValue*u)}for(let V=0;V<m.additiveAnimations.length;V++){const d=m.additiveAnimations[V],g=d.weight;g&&(d.currentValue.scaleAndAddToRef?d.currentValue.scaleAndAddToRef(g,z):z+=d.currentValue*g)}}g[d]=z}g._lateAnimationHolders={}}d._registeredForLateAnimationBindings.reset()}}(this)},i.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((d,m)=>d.playOrder-m.playOrder))},i.prototype.beginWeightedAnimation=function(d,m,g){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,u=arguments.length>4?arguments[4]:void 0,D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,j=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,s=arguments.length>8?arguments[8]:void 0,U=arguments.length>9?arguments[9]:void 0,X=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const Y=this.beginAnimation(d,m,g,u,D,j,z,!1,s,U,X);return Y.weight=V,Y},i.prototype.beginAnimation=function(d,m,g,V){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,D=arguments.length>5?arguments[5]:void 0,j=arguments.length>6?arguments[6]:void 0,z=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],s=arguments.length>8?arguments[8]:void 0,U=arguments.length>9?arguments[9]:void 0,X=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(u<0){const d=m;m=g,g=d,u=-u}m>g&&(u=-u),z&&this.stopAnimation(d,void 0,s),j||(j=new Y(this,d,m,g,V,u,D,void 0,U,X));const Q=!s||s(d);if(d.animations&&Q&&j.appendAnimations(d,d.animations),d.getAnimatables){const X=d.getAnimatables();for(let d=0;d<X.length;d++)this.beginAnimation(X[d],m,g,V,u,D,j,z,s,U)}return j.reset(),j},i.prototype.beginHierarchyAnimation=function(d,m,g,V,u){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,j=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,s=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],U=arguments.length>9?arguments[9]:void 0,X=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const Y=d.getDescendants(m),Q=[];Q.push(this.beginAnimation(d,g,V,u,D,j,z,s,U,void 0,X));for(const B of Y)Q.push(this.beginAnimation(B,g,V,u,D,j,z,s,U,void 0,X));return Q},i.prototype.beginDirectAnimation=function(d,m,g,V,u){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(D<0){const d=g;g=V,V=d,D=-D}return g>V&&(D=-D),new Y(this,d,g,V,u,D,arguments.length>6?arguments[6]:void 0,m,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},i.prototype.beginDirectHierarchyAnimation=function(d,m,g,V,u,D,j,z,s){let U=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const X=d.getDescendants(m),Y=[];Y.push(this.beginDirectAnimation(d,g,V,u,D,j,z,s,U));for(const Q of X)Y.push(this.beginDirectAnimation(Q,g,V,u,D,j,z,s,U));return Y},i.prototype.getAnimatableByTarget=function(d){for(let m=0;m<this._activeAnimatables.length;m++)if(this._activeAnimatables[m].target===d)return this._activeAnimatables[m];return null},i.prototype.getAllAnimatablesByTarget=function(d){const m=[];for(let g=0;g<this._activeAnimatables.length;g++)this._activeAnimatables[g].target===d&&m.push(this._activeAnimatables[g]);return m},i.prototype.stopAnimation=function(d,m,g){const V=this.getAllAnimatablesByTarget(d);for(const u of V)u.stop(m,g)},i.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let d=0;d<this._activeAnimatables.length;d++)this._activeAnimatables[d].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const d of this.animationGroups)d.stop()});class O{getClassName(){return"TargetedAnimation"}serialize(){const d={};return d.animation=this.animation.serialize(),d.targetId=this.target.id,d}}class R{get mask(){return this._mask}set mask(d){this._mask!==d&&(this._mask=d,this.syncWithMask(!0))}syncWithMask(){let d=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||d){this._numActiveAnimatables=0;for(let d=0;d<this._animatables.length;++d){const m=this._animatables[d];!this.mask||this.mask.disabled||this.mask.retainsTarget(m.target.name)?(this._numActiveAnimatables++,m.paused&&m.restart()):m.paused||m.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let d=0;d<this._animatables.length;++d){const m=this._animatables[d];this.mask.retainsTarget(m.target.name)||(m.stop(),this._animatables.splice(d,1),--d)}for(let d=0;d<this._targetedAnimations.length;d++){const m=this._targetedAnimations[d];this.mask.retainsTarget(m.target.name)||(this._targetedAnimations.splice(d,1),--d)}}}get from(){return this._from}set from(d){if(this._from!==d){this._from=d;for(let d=0;d<this._animatables.length;d++){this._animatables[d].fromFrame=this._from}}}get to(){return this._to}set to(d){if(this._to!==d){this._to=d;for(let d=0;d<this._animatables.length;d++){this._animatables[d].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(d){if(this._speedRatio!==d){this._speedRatio=d;for(let d=0;d<this._animatables.length;d++){this._animatables[d].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(d){if(this._loopAnimation!==d){this._loopAnimation=d;for(let d=0;d<this._animatables.length;d++){this._animatables[d].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(d){if(this._isAdditive!==d){this._isAdditive=d;for(let d=0;d<this._animatables.length;d++){this._animatables[d].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(d){this._weight!==d&&(this._weight=d,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(d){if(this._playOrder!==d&&(this._playOrder=d,this._animatables.length>0)){for(let d=0;d<this._animatables.length;d++)this._animatables[d].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(d){if(this._enableBlending!==d&&(this._enableBlending=d,null!==d))for(let m=0;m<this._targetedAnimations.length;++m)this._targetedAnimations[m].animation.enableBlending=d}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(d){if(this._blendingSpeed!==d&&(this._blendingSpeed=d,null!==d))for(let m=0;m<this._targetedAnimations.length;++m)this._targetedAnimations[m].animation.blendingSpeed=d}getLength(d,m){d=d??this._from;return((m=m??this._to)-d)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(d){let m=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],g=arguments.length>2&&void 0!==arguments[2]&&arguments[2],V=arguments.length>3?arguments[3]:void 0;if(0===d.length)return null;V=V??d[0].weight;let u=Number.MAX_VALUE,D=-Number.MAX_VALUE;if(g)for(const z of d)z.from<u&&(u=z.from),z.to>D&&(D=z.to);const j=new R(d[0].name+"_merged",d[0]._scene,V);for(const z of d){g&&z.normalize(u,D);for(const d of z.targetedAnimations)j.addTargetedAnimation(d.animation,d.target);m&&z.dispose()}return j}constructor(d){let m=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=d,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new u.d,this.onAnimationLoopObservable=new u.d,this.onAnimationGroupLoopObservable=new u.d,this.onAnimationGroupEndObservable=new u.d,this.onAnimationGroupPauseObservable=new u.d,this.onAnimationGroupPlayObservable=new u.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=m||D.b.LastCreatedScene,this._weight=g,this._playOrder=V,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(d,m){const g=new O;g.animation=d,g.target=m;const V=d.getKeys();return this._from>V[0].frame&&(this._from=V[0].frame),this._to<V[V.length-1].frame&&(this._to=V[V.length-1].frame),null!==this._enableBlending&&(d.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(d.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(g),this._shouldStart=!0,g}removeTargetedAnimation(d){for(let m=this._targetedAnimations.length-1;m>-1;m--){this._targetedAnimations[m].animation===d&&this._targetedAnimations.splice(m,1)}}normalize(){let d=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,m=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==d&&(d=this._from),null==m&&(m=this._to);for(let g=0;g<this._targetedAnimations.length;g++){const V=this._targetedAnimations[g].animation.getKeys(),u=V[0],D=V[V.length-1];if(u.frame>d){const m={frame:d,value:u.value,inTangent:u.inTangent,outTangent:u.outTangent,interpolation:u.interpolation};V.splice(0,0,m)}if(D.frame<m){const d={frame:m,value:D.value,inTangent:D.inTangent,outTangent:D.outTangent,interpolation:D.interpolation};V.push(d)}}return this._from=d,this._to=m,this}_processLoop(d,m,g){d.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(m),this._animationLoopFlags[g]||(this._animationLoopFlags[g]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let d=arguments.length>0&&void 0!==arguments[0]&&arguments[0],m=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,g=arguments.length>2?arguments[2]:void 0,V=arguments.length>3?arguments[3]:void 0,u=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=d,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let D=0;D<this._targetedAnimations.length;D++){const j=this._targetedAnimations[D],z=this._scene.beginDirectAnimation(j.target,[j.animation],void 0!==g?g:this._from,void 0!==V?V:this._to,d,m,void 0,void 0,void 0!==u?u:this._isAdditive);z.weight=this._weight,z.playOrder=this._playOrder,z.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(j),this._checkAnimationGroupEnded(z)},this._processLoop(z,j,D),this._animatables.push(z)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=m,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let d=0;d<this._animatables.length;d++){this._animatables[d].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(d){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==d&&(this.loopAnimation=d),this.restart()):(this.stop(),this.start(d,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let d=0;d<this._animatables.length;d++){this._animatables[d].reset()}return this}restart(){if(!this._isStarted)return this;for(let d=0;d<this._animatables.length;d++){this._animatables[d].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let d=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const m=this._animatables.slice();for(let V=0;V<m.length;V++)m[V].stop(void 0,void 0,!0,d);let g=0;for(let V=0;V<this._scene._activeAnimatables.length;V++){const m=this._scene._activeAnimatables[V];m._runtimeAnimations.length>0?this._scene._activeAnimatables[g++]=m:d&&this._checkAnimationGroupEnded(m,d)}return this._scene._activeAnimatables.length=g,this._isStarted=!1,this}setWeightForAllAnimatables(d){for(let m=0;m<this._animatables.length;m++){this._animatables[m].weight=d}return this}syncAllAnimationsWith(d){for(let m=0;m<this._animatables.length;m++){this._animatables[m].syncWith(d)}return this}goToFrame(d){if(!this._isStarted)return this;for(let m=0;m<this._animatables.length;m++){this._animatables[m].goToFrame(d)}return this}getCurrentFrame(){var d;return(null===(d=this.animatables[0])||void 0===d?void 0:d.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const d=this._scene.animationGroups.indexOf(this);if(d>-1&&this._scene.animationGroups.splice(d,1),this._parentContainer){const d=this._parentContainer.animationGroups.indexOf(this);d>-1&&this._parentContainer.animationGroups.splice(d,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(d){let m=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const g=this._animatables.indexOf(d);g>-1&&this._animatables.splice(g,1),0===this._animatables.length&&(this._isStarted=!1,m||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(d,m){let g=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const V=new R(d||this.name,this._scene,this._weight,this._playOrder);V._from=this.from,V._to=this.to,V._speedRatio=this.speedRatio,V._loopAnimation=this.loopAnimation,V._isAdditive=this.isAdditive,V._enableBlending=this.enableBlending,V._blendingSpeed=this.blendingSpeed,V.metadata=this.metadata,V.mask=this.mask;for(const u of this._targetedAnimations)V.addTargetedAnimation(g?u.animation.clone():u.animation,m?m(u.target):u.target);return V}serialize(){const d={};d.name=this.name,d.from=this.from,d.to=this.to,d.speedRatio=this.speedRatio,d.loopAnimation=this.loopAnimation,d.isAdditive=this.isAdditive,d.weight=this.weight,d.playOrder=this.playOrder,d.enableBlending=this.enableBlending,d.blendingSpeed=this.blendingSpeed,d.targetedAnimations=[];for(let m=0;m<this.targetedAnimations.length;m++){const g=this.targetedAnimations[m];d.targetedAnimations[m]=g.serialize()}return j.d&&j.d.HasTags(this)&&(d.tags=j.d.GetTags(this)),this.metadata&&(d.metadata=this.metadata),d}static Parse(d,m){const g=new R(d.name,m,d.weight,d.playOrder);for(let u=0;u<d.targetedAnimations.length;u++){const D=d.targetedAnimations[u],j=V.e.Parse(D.animation),z=D.targetId;if("influence"===D.animation.property){const d=m.getMorphTargetById(z);d&&g.addTargetedAnimation(j,d)}else{const d=m.getNodeById(z);null!=d&&g.addTargetedAnimation(j,d)}}return j.d&&j.d.AddTagsTo(g,d.tags),null!==d.from&&null!==d.to&&g.normalize(d.from,d.to),void 0!==d.speedRatio&&(g._speedRatio=d.speedRatio),void 0!==d.loopAnimation&&(g._loopAnimation=d.loopAnimation),void 0!==d.isAdditive&&(g._isAdditive=d.isAdditive),void 0!==d.weight&&(g._weight=d.weight),void 0!==d.playOrder&&(g._playOrder=d.playOrder),void 0!==d.enableBlending&&(g._enableBlending=d.enableBlending),void 0!==d.blendingSpeed&&(g._blendingSpeed=d.blendingSpeed),void 0!==d.metadata&&(g.metadata=d.metadata),g}static MakeAnimationAdditive(d,m,g){let u;u="object"===typeof m?m:{referenceFrame:m,range:g,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let D=d;u.cloneOriginalAnimationGroup&&(D=d.clone(u.clonedAnimationGroupName||D.name));const j=D.targetedAnimations;for(let z=0;z<j.length;z++){const d=j[z];d.animation=V.e.MakeAnimationAdditive(d.animation,u)}if(D.isAdditive=!0,u.clipKeys){let d=Number.MAX_VALUE,m=-Number.MAX_VALUE;const g=D.targetedAnimations;for(let V=0;V<g.length;V++){const u=g[V].animation.getKeys();d>u[0].frame&&(d=u[0].frame),m<u[u.length-1].frame&&(m=u[u.length-1].frame)}D._from=d,D._to=m}return D}static ClipKeys(d,m,g,V,u){const D=d.clone(V||d.name);return R.ClipKeysInPlace(D,m,g,u)}static ClipKeysInPlace(d,m,g,V){return R.ClipInPlace(d,m,g,V,!1)}static ClipFrames(d,m,g,V,u){const D=d.clone(V||d.name);return R.ClipFramesInPlace(D,m,g,u)}static ClipFramesInPlace(d,m,g,V){return R.ClipInPlace(d,m,g,V,!0)}static ClipInPlace(d,m,g,V){let u=arguments.length>4&&void 0!==arguments[4]&&arguments[4],D=Number.MAX_VALUE,j=-Number.MAX_VALUE;const z=d.targetedAnimations;for(let s=0;s<z.length;s++){const d=z[s],U=V?d.animation:d.animation.clone();u&&(U.createKeyForFrame(m),U.createKeyForFrame(g));const X=U.getKeys(),Y=[];let Q=Number.MAX_VALUE;for(let V=0;V<X.length;V++){const d=X[V];if(!u&&V>=m&&V<=g||u&&d.frame>=m&&d.frame<=g){const m={frame:d.frame,value:d.value.clone?d.value.clone():d.value,inTangent:d.inTangent,outTangent:d.outTangent,interpolation:d.interpolation,lockedTangent:d.lockedTangent};Q===Number.MAX_VALUE&&(Q=m.frame),m.frame-=Q,Y.push(m)}}0!==Y.length?(D>Y[0].frame&&(D=Y[0].frame),j<Y[Y.length-1].frame&&(j=Y[Y.length-1].frame),U.setKeys(Y,!0),d.animation=U):(z.splice(s,1),s--)}return d._from=D,d._to=j,d}getClassName(){return"AnimationGroup"}toString(d){let m="Name: "+this.name;return m+=", type: "+this.getClassName(),d&&(m+=", from: "+this._from,m+=", to: "+this._to,m+=", isStarted: "+this._isStarted,m+=", speedRatio: "+this._speedRatio,m+=", targetedAnimations length: "+this._targetedAnimations.length,m+=", animatables length: "+this._animatables),m}}}}]);