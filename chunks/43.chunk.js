"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12611:(L,J,o)=>{o.r(J),o.d(J,{AnimationGroup:()=>l,TargetedAnimation:()=>O});var g=o(11979),V=o(974),q=o(1008),I=o(1153),b=o(11971),D=o(982);class Z{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(L,J,o,V){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=J,this._target=L,this._scene=o,this._host=V,this._activeTargets=[],J._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===g.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=D.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const L={frame:0,value:this._minValue};this._keys.splice(0,0,L)}if(this._target instanceof Array){let L=0;for(const J of this._target)this._preparePath(J,L),this._getOriginalValues(L),L++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const q=J.getEvents();q&&q.length>0&&q.forEach((L=>{this._events.push(L._clone())})),this._enableBlending=L&&L.animationPropertiesOverride?L.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(L){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=this._animation.targetPropertyPath;if(o.length>1){let g=L;for(let L=0;L<o.length-1;L++){const J=o[L];if(g=g[J],void 0===g)throw new Error(`Invalid property (${J}) in property path (${o.join(".")})`)}this._targetPath=o[o.length-1],this._activeTargets[J]=g}else this._targetPath=o[0],this._activeTargets[J]=L;if(void 0===this._activeTargets[J][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${o.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let L=0;for(const J of this._target)void 0!==this._originalValue[L]&&this._setValue(J,this._activeTargets[L],this._originalValue[L],-1,L),L++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let L=0;L<this._events.length;L++)this._events[L].isDone=!1}isStopped(){return this._stopped}dispose(){const L=this._animation.runtimeAnimations.indexOf(this);L>-1&&this._animation.runtimeAnimations.splice(L,1)}setValue(L,J){if(this._targetIsArray)for(let o=0;o<this._target.length;o++){const g=this._target[o];this._setValue(g,this._activeTargets[o],L,J,o)}else this._setValue(this._target,this._directTarget,L,J,0)}_getOriginalValues(){let L,J=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const o=this._activeTargets[J];L=o.getLocalMatrix&&"_matrix"===this._targetPath?o.getLocalMatrix():o[this._targetPath],L&&L.clone?this._originalValue[J]=L.clone():this._originalValue[J]=L}_registerTargetForLateAnimationBinding(L,J){const o=L.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(o),o._lateAnimationHolders||(o._lateAnimationHolders={}),o._lateAnimationHolders[L.targetPath]||(o._lateAnimationHolders[L.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:J}),L.isAdditive?(o._lateAnimationHolders[L.targetPath].additiveAnimations.push(L),o._lateAnimationHolders[L.targetPath].totalAdditiveWeight+=L.weight):(o._lateAnimationHolders[L.targetPath].animations.push(L),o._lateAnimationHolders[L.targetPath].totalWeight+=L.weight)}_setValue(L,J,o,V,q){if(this._currentActiveTarget=J,this._weight=V,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const L=J[this._targetPath];L.clone?this._originalBlendValue=L.clone():this._originalBlendValue=L}this._originalBlendValue.m?g.e.AllowMatrixDecomposeForInterpolation?this._currentValue?D.c.DecomposeLerpToRef(this._originalBlendValue,o,this._blendingFactor,this._currentValue):this._currentValue=D.c.DecomposeLerp(this._originalBlendValue,o,this._blendingFactor):this._currentValue?D.c.LerpToRef(this._originalBlendValue,o,this._blendingFactor,this._currentValue):this._currentValue=D.c.Lerp(this._originalBlendValue,o,this._blendingFactor):this._currentValue=g.e._UniversalLerp(this._originalBlendValue,o,this._blendingFactor);const V=L&&L.animationPropertiesOverride?L.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=V}else this._currentValue?this._currentValue.p?this._currentValue.p(o):this._currentValue=o:null!==o&&void 0!==o&&o.clone?this._currentValue=o.clone():this._currentValue=o;-1!==V?this._registerTargetForLateAnimationBinding(this,this._originalValue[q]):this._animationState.loopMode===g.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[q],J[this._targetPath]):J[this._targetPath]=this._originalValue[q]+this._currentValue:J[this._targetPath]=this._currentValue,L.ve&&L.ve(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(L){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const o=this._animation.getKeys();L<o[0].frame?L=o[0].frame:L>o[o.length-1].frame&&(L=o[o.length-1].frame);const g=this._events;if(g.length)for(let q=0;q<g.length;q++)g[q].onlyOnce||(g[q].isDone=g[q].frame<L);this._currentFrame=L;const V=this._animation._interpolate(L,this._animationState);this.setValue(V,J)}_prepareForSpeedRatioChange(L){const J=this._previousElapsedTime*(this._animation.framePerSecond*L)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-J}animate(L,J,o,V,q){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const b=this._animation,D=b.targetPropertyPath;if(!D||D.length<1)return this._stopped=!0,!1;let Z=!0;(J<this._minFrame||J>this._maxFrame)&&(J=this._minFrame),(o<this._minFrame||o>this._maxFrame)&&(o=this._maxFrame);const C=o-J;let v,U=L*(b.framePerSecond*q)/1e3+this._absoluteFrameOffset,k=0,H=!1;const e=V&&this._animationState.loopMode===g.e.ANIMATIONLOOPMODE_YOYO;if(e){const L=(U-J)/C,o=Math.sin(L*Math.PI);U=Math.abs(o)*C+J;const g=o>=0?1:-1;this._yoyoDirection!==g&&(H=!0),this._yoyoDirection=g}if(this._previousElapsedTime=L,this._previousAbsoluteFrame=U,!V&&o>=J&&(U>=C&&q>0||U<=0&&q<0))Z=!1,k=b._getKeyValue(this._maxValue);else if(!V&&J>=o&&(U<=C&&q<0||U>=0&&q>0))Z=!1,k=b._getKeyValue(this._minValue);else if(this._animationState.loopMode!==g.e.ANIMATIONLOOPMODE_CYCLE){const L=o.toString()+J.toString();if(!this._offsetsCache[L]){this._animationState.repeatCount=0,this._animationState.loopMode=g.e.ANIMATIONLOOPMODE_CYCLE;const V=b._interpolate(J,this._animationState),q=b._interpolate(o,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),b.dataType){case g.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[L]=q-V;break;case g.e.ANIMATIONTYPE_QUATERNION:case g.e.ANIMATIONTYPE_VECTOR3:case g.e.ANIMATIONTYPE_VECTOR2:case g.e.ANIMATIONTYPE_SIZE:case g.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[L]=q.Uc(V)}this._highLimitsCache[L]=q}k=this._highLimitsCache[L],v=this._offsetsCache[L]}if(void 0===v)switch(b.dataType){case g.e.ANIMATIONTYPE_FLOAT:v=0;break;case g.e.ANIMATIONTYPE_QUATERNION:v=g.k;break;case g.e.ANIMATIONTYPE_VECTOR3:v=g.q;break;case g.e.ANIMATIONTYPE_VECTOR2:v=g.o;break;case g.e.ANIMATIONTYPE_SIZE:v=g.l;break;case g.e.ANIMATIONTYPE_COLOR3:v=g.f;break;case g.e.ANIMATIONTYPE_COLOR4:v=g.h}let T;if(this._host&&this._host.syncRoot){const L=this._host.syncRoot;T=J+C*((L.masterFrame-L.fromFrame)/(L.toFrame-L.fromFrame))}else T=U>0&&J>o||U<0&&J<o?Z&&0!==C?o+U%C:J:Z&&0!==C?J+U%C:o;const O=this._events;if(!e&&(q>0&&this.currentFrame>T||q<0&&this.currentFrame<T)||e&&H){this._onLoop();for(let L=0;L<O.length;L++)O[L].onlyOnce||(O[L].isDone=!1);this._animationState.key=q>0?0:b.getKeys().length-1}this._currentFrame=T,this._animationState.repeatCount=0===C?0:U/C|0,this._animationState.highLimitValue=k,this._animationState.offsetValue=v;const l=b._interpolate(T,this._animationState);if(this.setValue(l,I),O.length)for(let g=0;g<O.length;g++)if(C>=0&&T>=O[g].frame&&O[g].frame>=J||C<0&&T<=O[g].frame&&O[g].frame<=J){const L=O[g];L.isDone||(L.onlyOnce&&(O.splice(g,1),g--),L.isDone=!0,L.action(T))}return Z||(this._stopped=!0),Z}}var C=o(1114);class v{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(L){this._weight=-1!==L?Math.min(Math.max(L,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(L){for(let J=0;J<this._runtimeAnimations.length;J++){this._runtimeAnimations[J]._prepareForSpeedRatioChange(L)}this._speedRatio=L,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(L,J){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,b=arguments.length>6?arguments[6]:void 0,D=arguments.length>7?arguments[7]:void 0,Z=arguments.length>8?arguments[8]:void 0,C=arguments.length>9&&void 0!==arguments[9]&&arguments[9],v=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=J,this.fromFrame=o,this.toFrame=g,this.loopAnimation=q,this.onAnimationEnd=b,this.onAnimationLoop=Z,this.isAdditive=C,this.playOrder=v,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Hd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new V.c,this.onAnimationLoopObservable=new V.c,this._scene=L,D&&this.appendAnimations(J,D),this._speedRatio=I,L._activeAnimatables.push(this)}syncWith(L){if(this._syncRoot=L,L){const L=this._scene._activeAnimatables.indexOf(this);L>-1&&(this._scene._activeAnimatables.splice(L,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(L,J){for(let o=0;o<J.length;o++){const g=J[o],V=new Z(L,g,this._scene,this);V._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(V)}}getAnimationByTargetProperty(L){const J=this._runtimeAnimations;for(let o=0;o<J.length;o++)if(J[o].animation.targetProperty===L)return J[o].animation;return null}getRuntimeAnimationByTargetProperty(L){const J=this._runtimeAnimations;for(let o=0;o<J.length;o++)if(J[o].animation.targetProperty===L)return J[o];return null}reset(){const L=this._runtimeAnimations;for(let J=0;J<L.length;J++)L[J].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(L){const J=this._runtimeAnimations;for(let o=0;o<J.length;o++)J[o].animation.enableBlending=!0,J[o].animation.blendingSpeed=L}disableBlending(){const L=this._runtimeAnimations;for(let J=0;J<L.length;J++)L[J].animation.enableBlending=!1}goToFrame(L){const J=this._runtimeAnimations;if(J[0]){const o=J[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??J[0].currentFrame;const g=0===this.speedRatio?0:(L-this._frameToSyncFromJump)/o*1e3/this.speedRatio;this._manualJumpDelay=-g}for(let o=0;o<J.length;o++)J[o].goToFrame(L,this._weight);this._goToFrame=L}get paused(){return this.Hd}pause(){this.Hd||(this.Hd=!0)}restart(){this.Hd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(L,J){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],g=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(L||J){const V=this._scene._activeAnimatables.indexOf(this);if(V>-1){const q=this._runtimeAnimations;for(let o=q.length-1;o>=0;o--){const g=q[o];L&&g.animation.name!=L||(J&&!J(g.target)||(g.dispose(),q.splice(o,1)))}0==q.length&&(o||this._scene._activeAnimatables.splice(V,1),g||this._raiseOnAnimationEnd())}}else{const L=this._scene._activeAnimatables.indexOf(this);if(L>-1){o||this._scene._activeAnimatables.splice(L,1);const J=this._runtimeAnimations;for(let L=0;L<J.length;L++)J[L].dispose();this._runtimeAnimations.length=0,g||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((L=>{this.onAnimationEndObservable.add((()=>{L(this)}),void 0,void 0,this,!0)}))}_animate(L){if(this.Hd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=L),!0;if(null===this._localDelayOffset?(this._localDelayOffset=L,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=L-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let J=!1;const o=this._runtimeAnimations;let g;for(g=0;g<o.length;g++){const V=o[g].animate(L-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);J=J||V}if(this.animationStarted=J,!J){if(this.disposeOnEnd)for(g=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(g,1),g=0;g<o.length;g++)o[g].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return J}}function U(L){if(0===L.totalWeight&&0===L.totalAdditiveWeight)return L.originalValue;let J=1;const o=D.h.Pd[0],g=D.h.Pd[1],V=D.h.Quaternion[0];let q=0;const I=L.animations[0],b=L.originalValue;let Z=1,C=!1;if(L.totalWeight<1)Z=1-L.totalWeight,b.decompose(g,V,o);else{if(q=1,J=L.totalWeight,Z=I.weight/J,1==Z){if(!L.totalAdditiveWeight)return I.currentValue;C=!0}I.currentValue.decompose(g,V,o)}if(!C){g.scaleInPlace(Z),o.scaleInPlace(Z),V.scaleInPlace(Z);for(let I=q;I<L.animations.length;I++){const q=L.animations[I];if(0===q.weight)continue;Z=q.weight/J;const b=D.h.Pd[2],C=D.h.Pd[3],v=D.h.Quaternion[1];q.currentValue.decompose(C,v,b),C.scaleAndAddToRef(Z,g),v.scaleAndAddToRef(D.d.Dot(V,v)>0?Z:-Z,V),b.scaleAndAddToRef(Z,o)}V.normalize()}for(let U=0;U<L.additiveAnimations.length;U++){const J=L.additiveAnimations[U];if(0===J.weight)continue;const q=D.h.Pd[2],I=D.h.Pd[3],b=D.h.Quaternion[1];J.currentValue.decompose(I,b,q),I.multiplyToRef(g,I),D.o.LerpToRef(g,I,J.weight,g),V.multiplyToRef(b,b),D.d.SlerpToRef(V,b,J.weight,V),q.scaleAndAddToRef(J.weight,o)}const v=I?I._animationState.workValue:D.h.Matrix[0].clone();return D.c.ComposeToRef(g,V,o,v),v}function k(L,J){if(0===L.totalWeight&&0===L.totalAdditiveWeight)return J;const o=L.animations[0],g=L.originalValue;let V=J;if(0===L.totalWeight&&L.totalAdditiveWeight>0)V.p(g);else if(1===L.animations.length){if(D.d.SlerpToRef(g,o.currentValue,Math.min(1,L.totalWeight),V),0===L.totalAdditiveWeight)return V}else if(L.animations.length>1){let o,q,I=1;if(L.totalWeight<1){const J=1-L.totalWeight;o=[],q=[],o.push(g),q.push(J)}else{if(2===L.animations.length&&(D.d.SlerpToRef(L.animations[0].currentValue,L.animations[1].currentValue,L.animations[1].weight/L.totalWeight,J),0===L.totalAdditiveWeight))return J;o=[],q=[],I=L.totalWeight}for(let J=0;J<L.animations.length;J++){const g=L.animations[J];o.push(g.currentValue),q.push(g.weight/I)}let b=0;for(let L=0;L<o.length;)L?(b+=q[L],D.d.SlerpToRef(V,o[L],q[L]/b,V),L++):(D.d.SlerpToRef(o[L],o[L+1],q[L+1]/(q[L]+q[L+1]),J),V=J,b=q[L]+q[L+1],L+=2)}for(let q=0;q<L.additiveAnimations.length;q++){const J=L.additiveAnimations[q];0!==J.weight&&(V.multiplyToRef(J.currentValue,D.h.Quaternion[0]),D.d.SlerpToRef(V,D.h.Quaternion[0],J.weight,V))}return V}var H,e,T=o(1186);H=T.b,(e=b.e)&&(e.prototype.copyAnimationRange=function(L,J,o){let V=arguments.length>3&&void 0!==arguments[3]&&arguments[3],q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new g.e(this.name,"_matrix",L.animations[0].framePerSecond,g.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const I=L.animations[0].getRange(J);if(!I)return!1;const b=I.from,D=I.to,Z=L.animations[0].getKeys(),C=L.length,v=L.getParent(),U=this.getParent(),k=V&&v&&C&&this.length&&C!==this.length,H=k&&U&&v?U.length/v.length:1,e=V&&!U&&q&&(1!==q.x||1!==q.y||1!==q.z),T=this.animations[0].getKeys();let O,l,a;for(let g=0,S=Z.length;g<S;g++)O=Z[g],O.frame>=b&&O.frame<=D&&(V?(a=O.value.clone(),k?(l=a.getTranslation(),a.setTranslation(l.scaleInPlace(H))):e&&q?(l=a.getTranslation(),a.setTranslation(l.multiplyInPlace(q))):a=O.value):a=O.value,T.push({frame:O.frame+o,value:a}));return this.animations[0].createRange(J,b+o,D+o),!0}),H&&(H.prototype._animate=function(L){if(!this.animationsEnabled)return;const J=C.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=J}this.deltaTime=void 0!==L?L:this.useConstantAnimationDeltaTime?16:(J-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=J;const o=this._activeAnimatables;if(0===o.length)return;this._animationTime+=this.deltaTime;const V=this._animationTime;for(let g=0;g<o.length;g++){const L=o[g];!L._animate(V)&&L.disposeOnEnd&&g--}!function(L){if(L._registeredForLateAnimationBindings.length){for(let J=0;J<L._registeredForLateAnimationBindings.length;J++){const o=L._registeredForLateAnimationBindings.data[J];for(const L in o._lateAnimationHolders){const J=o._lateAnimationHolders[L],V=J.animations[0],q=J.originalValue;if(void 0===q||null===q)continue;const I=g.e.AllowMatrixDecomposeForInterpolation&&q.m;let b=o[L];if(I)b=U(J);else if(void 0!==q.w)b=k(J,b||D.d.Identity());else{let L=0,o=1;const I=V&&V._animationState.loopMode===g.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(J.totalWeight<1)b=I?q.clone?q.clone():q:V&&q.scale?q.scale(1-J.totalWeight):V?q*(1-J.totalWeight):q.clone?q.clone():q;else if(V){o=J.totalWeight;const g=V.weight/o;b=1!==g?V.currentValue.scale?V.currentValue.scale(g):V.currentValue*g:V.currentValue,I&&(b.addToRef?b.addToRef(q,b):b+=q),L=1}for(let g=L;g<J.animations.length;g++){const L=J.animations[g],V=L.weight/o;V&&(L.currentValue.scaleAndAddToRef?L.currentValue.scaleAndAddToRef(V,b):b+=L.currentValue*V)}for(let g=0;g<J.additiveAnimations.length;g++){const L=J.additiveAnimations[g],o=L.weight;o&&(L.currentValue.scaleAndAddToRef?L.currentValue.scaleAndAddToRef(o,b):b+=L.currentValue*o)}}o[L]=b}o._lateAnimationHolders={}}L._registeredForLateAnimationBindings.reset()}}(this)},H.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((L,J)=>L.playOrder-J.playOrder))},H.prototype.beginWeightedAnimation=function(L,J,o){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,V=arguments.length>4?arguments[4]:void 0,q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,I=arguments.length>6?arguments[6]:void 0,b=arguments.length>7?arguments[7]:void 0,D=arguments.length>8?arguments[8]:void 0,Z=arguments.length>9?arguments[9]:void 0,C=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const v=this.beginAnimation(L,J,o,V,q,I,b,!1,D,Z,C);return v.weight=g,v},H.prototype.beginAnimation=function(L,J,o,g){let V=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,q=arguments.length>5?arguments[5]:void 0,I=arguments.length>6?arguments[6]:void 0,b=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],D=arguments.length>8?arguments[8]:void 0,Z=arguments.length>9?arguments[9]:void 0,C=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(V<0){const L=J;J=o,o=L,V=-V}J>o&&(V=-V),b&&this.stopAnimation(L,void 0,D),I||(I=new v(this,L,J,o,g,V,q,void 0,Z,C));const U=!D||D(L);if(L.animations&&U&&I.appendAnimations(L,L.animations),L.getAnimatables){const C=L.getAnimatables();for(let L=0;L<C.length;L++)this.beginAnimation(C[L],J,o,g,V,q,I,b,D,Z)}return I.reset(),I},H.prototype.beginHierarchyAnimation=function(L,J,o,g,V){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,I=arguments.length>6?arguments[6]:void 0,b=arguments.length>7?arguments[7]:void 0,D=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],Z=arguments.length>9?arguments[9]:void 0,C=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const v=L.getDescendants(J),U=[];U.push(this.beginAnimation(L,o,g,V,q,I,b,D,Z,void 0,C));for(const k of v)U.push(this.beginAnimation(k,o,g,V,q,I,b,D,Z,void 0,C));return U},H.prototype.beginDirectAnimation=function(L,J,o,g,V){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(q<0){const L=o;o=g,g=L,q=-q}return o>g&&(q=-q),new v(this,L,o,g,V,q,arguments.length>6?arguments[6]:void 0,J,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},H.prototype.beginDirectHierarchyAnimation=function(L,J,o,g,V,q,I,b,D){let Z=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const C=L.getDescendants(J),v=[];v.push(this.beginDirectAnimation(L,o,g,V,q,I,b,D,Z));for(const U of C)v.push(this.beginDirectAnimation(U,o,g,V,q,I,b,D,Z));return v},H.prototype.getAnimatableByTarget=function(L){for(let J=0;J<this._activeAnimatables.length;J++)if(this._activeAnimatables[J].target===L)return this._activeAnimatables[J];return null},H.prototype.getAllAnimatablesByTarget=function(L){const J=[];for(let o=0;o<this._activeAnimatables.length;o++)this._activeAnimatables[o].target===L&&J.push(this._activeAnimatables[o]);return J},H.prototype.stopAnimation=function(L,J,o){const g=this.getAllAnimatablesByTarget(L);for(const V of g)V.stop(J,o)},H.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let L=0;L<this._activeAnimatables.length;L++)this._activeAnimatables[L].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const L of this.animationGroups)L.stop()});class O{getClassName(){return"TargetedAnimation"}serialize(){const L={};return L.animation=this.animation.serialize(),L.targetId=this.target.id,L}}class l{get mask(){return this._mask}set mask(L){this._mask!==L&&(this._mask=L,this.syncWithMask(!0))}syncWithMask(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||L){this._numActiveAnimatables=0;for(let L=0;L<this._animatables.length;++L){const J=this._animatables[L];!this.mask||this.mask.disabled||this.mask.retainsTarget(J.target.name)?(this._numActiveAnimatables++,J.paused&&J.restart()):J.paused||J.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let L=0;L<this._animatables.length;++L){const J=this._animatables[L];this.mask.retainsTarget(J.target.name)||(J.stop(),this._animatables.splice(L,1),--L)}for(let L=0;L<this._targetedAnimations.length;L++){const J=this._targetedAnimations[L];this.mask.retainsTarget(J.target.name)||(this._targetedAnimations.splice(L,1),--L)}}}get from(){return this._from}set from(L){if(this._from!==L){this._from=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].fromFrame=this._from}}}get to(){return this._to}set to(L){if(this._to!==L){this._to=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(L){if(this._speedRatio!==L){this._speedRatio=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(L){if(this._loopAnimation!==L){this._loopAnimation=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(L){if(this._isAdditive!==L){this._isAdditive=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(L){this._weight!==L&&(this._weight=L,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(L){if(this._playOrder!==L&&(this._playOrder=L,this._animatables.length>0)){for(let L=0;L<this._animatables.length;L++)this._animatables[L].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(L){if(this._enableBlending!==L&&(this._enableBlending=L,null!==L))for(let J=0;J<this._targetedAnimations.length;++J)this._targetedAnimations[J].animation.enableBlending=L}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(L){if(this._blendingSpeed!==L&&(this._blendingSpeed=L,null!==L))for(let J=0;J<this._targetedAnimations.length;++J)this._targetedAnimations[J].animation.blendingSpeed=L}getLength(L,J){L=L??this._from;return((J=J??this._to)-L)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(L){let J=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],g=arguments.length>3?arguments[3]:void 0;if(0===L.length)return null;g=g??L[0].weight;let V=Number.MAX_VALUE,q=-Number.MAX_VALUE;if(o)for(const b of L)b.from<V&&(V=b.from),b.to>q&&(q=b.to);const I=new l(L[0].name+"_merged",L[0]._scene,g);for(const b of L){o&&b.normalize(V,q);for(const L of b.targetedAnimations)I.addTargetedAnimation(L.animation,L.target);J&&b.dispose()}return I}constructor(L){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=L,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new V.c,this.onAnimationLoopObservable=new V.c,this.onAnimationGroupLoopObservable=new V.c,this.onAnimationGroupEndObservable=new V.c,this.onAnimationGroupPauseObservable=new V.c,this.onAnimationGroupPlayObservable=new V.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=J||q.d.LastCreatedScene,this._weight=o,this._playOrder=g,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(L,J){const o=new O;o.animation=L,o.target=J;const g=L.getKeys();return this._from>g[0].frame&&(this._from=g[0].frame),this._to<g[g.length-1].frame&&(this._to=g[g.length-1].frame),null!==this._enableBlending&&(L.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(L.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(o),this._shouldStart=!0,o}removeTargetedAnimation(L){for(let J=this._targetedAnimations.length-1;J>-1;J--){this._targetedAnimations[J].animation===L&&this._targetedAnimations.splice(J,1)}}normalize(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==L&&(L=this._from),null==J&&(J=this._to);for(let o=0;o<this._targetedAnimations.length;o++){const g=this._targetedAnimations[o].animation.getKeys(),V=g[0],q=g[g.length-1];if(V.frame>L){const J={frame:L,value:V.value,inTangent:V.inTangent,outTangent:V.outTangent,interpolation:V.interpolation};g.splice(0,0,J)}if(q.frame<J){const L={frame:J,value:q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation};g.push(L)}}return this._from=L,this._to=J,this}_processLoop(L,J,o){L.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(J),this._animationLoopFlags[o]||(this._animationLoopFlags[o]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0],J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments.length>2?arguments[2]:void 0,g=arguments.length>3?arguments[3]:void 0,V=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=L,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let q=0;q<this._targetedAnimations.length;q++){const I=this._targetedAnimations[q],b=this._scene.beginDirectAnimation(I.target,[I.animation],void 0!==o?o:this._from,void 0!==g?g:this._to,L,J,void 0,void 0,void 0!==V?V:this._isAdditive);b.weight=this._weight,b.playOrder=this._playOrder,b.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(I),this._checkAnimationGroupEnded(b)},this._processLoop(b,I,q),this._animatables.push(b)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=J,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let L=0;L<this._animatables.length;L++){this._animatables[L].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(L){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==L&&(this.loopAnimation=L),this.restart()):(this.stop(),this.start(L,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let L=0;L<this._animatables.length;L++){this._animatables[L].reset()}return this}restart(){if(!this._isStarted)return this;for(let L=0;L<this._animatables.length;L++){this._animatables[L].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const J=this._animatables.slice();for(let g=0;g<J.length;g++)J[g].stop(void 0,void 0,!0,L);let o=0;for(let g=0;g<this._scene._activeAnimatables.length;g++){const J=this._scene._activeAnimatables[g];J._runtimeAnimations.length>0?this._scene._activeAnimatables[o++]=J:L&&this._checkAnimationGroupEnded(J,L)}return this._scene._activeAnimatables.length=o,this._isStarted=!1,this}setWeightForAllAnimatables(L){for(let J=0;J<this._animatables.length;J++){this._animatables[J].weight=L}return this}syncAllAnimationsWith(L){for(let J=0;J<this._animatables.length;J++){this._animatables[J].syncWith(L)}return this}goToFrame(L){if(!this._isStarted)return this;for(let J=0;J<this._animatables.length;J++){this._animatables[J].goToFrame(L)}return this}getCurrentFrame(){var L;return(null===(L=this.animatables[0])||void 0===L?void 0:L.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const L=this._scene.animationGroups.indexOf(this);if(L>-1&&this._scene.animationGroups.splice(L,1),this._parentContainer){const L=this._parentContainer.animationGroups.indexOf(this);L>-1&&this._parentContainer.animationGroups.splice(L,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(L){let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const o=this._animatables.indexOf(L);o>-1&&this._animatables.splice(o,1),0===this._animatables.length&&(this._isStarted=!1,J||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(L,J){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const g=new l(L||this.name,this._scene,this._weight,this._playOrder);g._from=this.from,g._to=this.to,g._speedRatio=this.speedRatio,g._loopAnimation=this.loopAnimation,g._isAdditive=this.isAdditive,g._enableBlending=this.enableBlending,g._blendingSpeed=this.blendingSpeed,g.metadata=this.metadata,g.mask=this.mask;for(const V of this._targetedAnimations)g.addTargetedAnimation(o?V.animation.clone():V.animation,J?J(V.target):V.target);return g}serialize(){const L={};L.name=this.name,L.from=this.from,L.to=this.to,L.speedRatio=this.speedRatio,L.loopAnimation=this.loopAnimation,L.isAdditive=this.isAdditive,L.weight=this.weight,L.playOrder=this.playOrder,L.enableBlending=this.enableBlending,L.blendingSpeed=this.blendingSpeed,L.targetedAnimations=[];for(let J=0;J<this.targetedAnimations.length;J++){const o=this.targetedAnimations[J];L.targetedAnimations[J]=o.serialize()}return I.b&&I.b.HasTags(this)&&(L.tags=I.b.GetTags(this)),this.metadata&&(L.metadata=this.metadata),L}static Parse(L,J){const o=new l(L.name,J,L.weight,L.playOrder);for(let V=0;V<L.targetedAnimations.length;V++){const q=L.targetedAnimations[V],I=g.e.Parse(q.animation),b=q.targetId;if("influence"===q.animation.property){const L=J.getMorphTargetById(b);L&&o.addTargetedAnimation(I,L)}else{const L=J.getNodeById(b);null!=L&&o.addTargetedAnimation(I,L)}}return I.b&&I.b.AddTagsTo(o,L.tags),null!==L.from&&null!==L.to&&o.normalize(L.from,L.to),void 0!==L.speedRatio&&(o._speedRatio=L.speedRatio),void 0!==L.loopAnimation&&(o._loopAnimation=L.loopAnimation),void 0!==L.isAdditive&&(o._isAdditive=L.isAdditive),void 0!==L.weight&&(o._weight=L.weight),void 0!==L.playOrder&&(o._playOrder=L.playOrder),void 0!==L.enableBlending&&(o._enableBlending=L.enableBlending),void 0!==L.blendingSpeed&&(o._blendingSpeed=L.blendingSpeed),void 0!==L.metadata&&(o.metadata=L.metadata),o}static MakeAnimationAdditive(L,J,o){let V;V="object"===typeof J?J:{referenceFrame:J,range:o,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let q=L;V.cloneOriginalAnimationGroup&&(q=L.clone(V.clonedAnimationGroupName||q.name));const I=q.targetedAnimations;for(let b=0;b<I.length;b++){const L=I[b];L.animation=g.e.MakeAnimationAdditive(L.animation,V)}if(q.isAdditive=!0,V.clipKeys){let L=Number.MAX_VALUE,J=-Number.MAX_VALUE;const o=q.targetedAnimations;for(let g=0;g<o.length;g++){const V=o[g].animation.getKeys();L>V[0].frame&&(L=V[0].frame),J<V[V.length-1].frame&&(J=V[V.length-1].frame)}q._from=L,q._to=J}return q}static ClipKeys(L,J,o,g,V){const q=L.clone(g||L.name);return l.ClipKeysInPlace(q,J,o,V)}static ClipKeysInPlace(L,J,o,g){return l.ClipInPlace(L,J,o,g,!1)}static ClipFrames(L,J,o,g,V){const q=L.clone(g||L.name);return l.ClipFramesInPlace(q,J,o,V)}static ClipFramesInPlace(L,J,o,g){return l.ClipInPlace(L,J,o,g,!0)}static ClipInPlace(L,J,o,g){let V=arguments.length>4&&void 0!==arguments[4]&&arguments[4],q=Number.MAX_VALUE,I=-Number.MAX_VALUE;const b=L.targetedAnimations;for(let D=0;D<b.length;D++){const L=b[D],Z=g?L.animation:L.animation.clone();V&&(Z.createKeyForFrame(J),Z.createKeyForFrame(o));const C=Z.getKeys(),v=[];let U=Number.MAX_VALUE;for(let g=0;g<C.length;g++){const L=C[g];if(!V&&g>=J&&g<=o||V&&L.frame>=J&&L.frame<=o){const J={frame:L.frame,value:L.value.clone?L.value.clone():L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation,lockedTangent:L.lockedTangent};U===Number.MAX_VALUE&&(U=J.frame),J.frame-=U,v.push(J)}}0!==v.length?(q>v[0].frame&&(q=v[0].frame),I<v[v.length-1].frame&&(I=v[v.length-1].frame),Z.setKeys(v,!0),L.animation=Z):(b.splice(D,1),D--)}return L._from=q,L._to=I,L}getClassName(){return"AnimationGroup"}toString(L){let J="Name: "+this.name;return J+=", type: "+this.getClassName(),L&&(J+=", from: "+this._from,J+=", to: "+this._to,J+=", isStarted: "+this._isStarted,J+=", speedRatio: "+this._speedRatio,J+=", targetedAnimations length: "+this._targetedAnimations.length,J+=", animatables length: "+this._animatables),J}}}}]);