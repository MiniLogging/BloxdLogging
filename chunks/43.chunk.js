"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{12973:(t,b,Y)=>{Y.r(b),Y.d(b,{AnimationGroup:()=>J,TargetedAnimation:()=>B});var o=Y(12329),x=Y(1013),F=Y(1051),r=Y(1227),R=Y(12320),d=Y(1019);class E{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(t,b,Y,x){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=b,this._target=t,this._scene=Y,this._host=x,this._activeTargets=[],b._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===o.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=d.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const t={frame:0,value:this._minValue};this._keys.splice(0,0,t)}if(this._target instanceof Array){let t=0;for(const b of this._target)this._preparePath(b,t),this._getOriginalValues(t),t++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const F=b.getEvents();F&&F.length>0&&F.forEach((t=>{this._events.push(t._clone())})),this._enableBlending=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Y=this._animation.targetPropertyPath;if(Y.length>1){let o=t;for(let t=0;t<Y.length-1;t++){const b=Y[t];if(o=o[b],void 0===o)throw new Error(`Invalid property (${b}) in property path (${Y.join(".")})`)}this._targetPath=Y[Y.length-1],this._activeTargets[b]=o}else this._targetPath=Y[0],this._activeTargets[b]=t;if(void 0===this._activeTargets[b][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${Y.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let t=0;for(const b of this._target)void 0!==this._originalValue[t]&&this._setValue(b,this._activeTargets[t],this._originalValue[t],-1,t),t++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let t=0;t<this._events.length;t++)this._events[t].isDone=!1}isStopped(){return this._stopped}dispose(){const t=this._animation.runtimeAnimations.indexOf(this);t>-1&&this._animation.runtimeAnimations.splice(t,1)}setValue(t,b){if(this._targetIsArray)for(let Y=0;Y<this._target.length;Y++){const o=this._target[Y];this._setValue(o,this._activeTargets[Y],t,b,Y)}else this._setValue(this._target,this._directTarget,t,b,0)}_getOriginalValues(){let t,b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Y=this._activeTargets[b];t=Y.getLocalMatrix&&"_matrix"===this._targetPath?Y.getLocalMatrix():Y[this._targetPath],t&&t.clone?this._originalValue[b]=t.clone():this._originalValue[b]=t}_registerTargetForLateAnimationBinding(t,b){const Y=t.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(Y),Y._lateAnimationHolders||(Y._lateAnimationHolders={}),Y._lateAnimationHolders[t.targetPath]||(Y._lateAnimationHolders[t.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:b}),t.isAdditive?(Y._lateAnimationHolders[t.targetPath].additiveAnimations.push(t),Y._lateAnimationHolders[t.targetPath].totalAdditiveWeight+=t.weight):(Y._lateAnimationHolders[t.targetPath].animations.push(t),Y._lateAnimationHolders[t.targetPath].totalWeight+=t.weight)}_setValue(t,b,Y,x,F){if(this._currentActiveTarget=b,this._weight=x,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const t=b[this._targetPath];t.clone?this._originalBlendValue=t.clone():this._originalBlendValue=t}this._originalBlendValue.m?o.d.AllowMatrixDecomposeForInterpolation?this._currentValue?d.c.DecomposeLerpToRef(this._originalBlendValue,Y,this._blendingFactor,this._currentValue):this._currentValue=d.c.DecomposeLerp(this._originalBlendValue,Y,this._blendingFactor):this._currentValue?d.c.LerpToRef(this._originalBlendValue,Y,this._blendingFactor,this._currentValue):this._currentValue=d.c.Lerp(this._originalBlendValue,Y,this._blendingFactor):this._currentValue=o.d._UniversalLerp(this._originalBlendValue,Y,this._blendingFactor);const x=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=x}else this._currentValue?this._currentValue.p?this._currentValue.p(Y):this._currentValue=Y:null!==Y&&void 0!==Y&&Y.clone?this._currentValue=Y.clone():this._currentValue=Y;-1!==x?this._registerTargetForLateAnimationBinding(this,this._originalValue[F]):this._animationState.loopMode===o.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[F],b[this._targetPath]):b[this._targetPath]=this._originalValue[F]+this._currentValue:b[this._targetPath]=this._currentValue,t.Ae&&t.Ae(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const Y=this._animation.getKeys();t<Y[0].frame?t=Y[0].frame:t>Y[Y.length-1].frame&&(t=Y[Y.length-1].frame);const o=this._events;if(o.length)for(let F=0;F<o.length;F++)o[F].onlyOnce||(o[F].isDone=o[F].frame<t);this._currentFrame=t;const x=this._animation._interpolate(t,this._animationState);this.setValue(x,b)}_prepareForSpeedRatioChange(t){const b=this._previousElapsedTime*(this._animation.framePerSecond*t)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-b}animate(t,b,Y,x,F){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const R=this._animation,d=R.targetPropertyPath;if(!d||d.length<1)return this._stopped=!0,!1;let E=!0;(b<this._minFrame||b>this._maxFrame)&&(b=this._minFrame),(Y<this._minFrame||Y>this._maxFrame)&&(Y=this._maxFrame);const U=Y-b;let C,p=t*(R.framePerSecond*F)/1e3+this._absoluteFrameOffset,W=0,T=!1;const y=x&&this._animationState.loopMode===o.d.ANIMATIONLOOPMODE_YOYO;if(y){const t=(p-b)/U,Y=Math.sin(t*Math.PI);p=Math.abs(Y)*U+b;const o=Y>=0?1:-1;this._yoyoDirection!==o&&(T=!0),this._yoyoDirection=o}if(this._previousElapsedTime=t,this._previousAbsoluteFrame=p,!x&&Y>=b&&(p>=U&&F>0||p<=0&&F<0))E=!1,W=R._getKeyValue(this._maxValue);else if(!x&&b>=Y&&(p<=U&&F<0||p>=0&&F>0))E=!1,W=R._getKeyValue(this._minValue);else if(this._animationState.loopMode!==o.d.ANIMATIONLOOPMODE_CYCLE){const t=Y.toString()+b.toString();if(!this._offsetsCache[t]){this._animationState.repeatCount=0,this._animationState.loopMode=o.d.ANIMATIONLOOPMODE_CYCLE;const x=R._interpolate(b,this._animationState),F=R._interpolate(Y,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),R.dataType){case o.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[t]=F-x;break;case o.d.ANIMATIONTYPE_QUATERNION:case o.d.ANIMATIONTYPE_VECTOR3:case o.d.ANIMATIONTYPE_VECTOR2:case o.d.ANIMATIONTYPE_SIZE:case o.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[t]=F.fd(x)}this._highLimitsCache[t]=F}W=this._highLimitsCache[t],C=this._offsetsCache[t]}if(void 0===C)switch(R.dataType){case o.d.ANIMATIONTYPE_FLOAT:C=0;break;case o.d.ANIMATIONTYPE_QUATERNION:C=o.k;break;case o.d.ANIMATIONTYPE_VECTOR3:C=o.r;break;case o.d.ANIMATIONTYPE_VECTOR2:C=o.p;break;case o.d.ANIMATIONTYPE_SIZE:C=o.l;break;case o.d.ANIMATIONTYPE_COLOR3:C=o.g;break;case o.d.ANIMATIONTYPE_COLOR4:C=o.j}let v;if(this._host&&this._host.syncRoot){const t=this._host.syncRoot;v=b+U*((t.masterFrame-t.fromFrame)/(t.toFrame-t.fromFrame))}else v=p>0&&b>Y||p<0&&b<Y?E&&0!==U?Y+p%U:b:E&&0!==U?b+p%U:Y;const B=this._events;if(!y&&(F>0&&this.currentFrame>v||F<0&&this.currentFrame<v)||y&&T){this._onLoop();for(let t=0;t<B.length;t++)B[t].onlyOnce||(B[t].isDone=!1);this._animationState.key=F>0?0:R.getKeys().length-1}this._currentFrame=v,this._animationState.repeatCount=0===U?0:p/U|0,this._animationState.highLimitValue=W,this._animationState.offsetValue=C;const J=R._interpolate(v,this._animationState);if(this.setValue(J,r),B.length)for(let o=0;o<B.length;o++)if(U>=0&&v>=B[o].frame&&B[o].frame>=b||U<0&&v<=B[o].frame&&B[o].frame<=b){const t=B[o];t.isDone||(t.onlyOnce&&(B.splice(o,1),o--),t.isDone=!0,t.action(v))}return E||(this._stopped=!0),E}}var U=Y(1195);class C{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(t){this._weight=-1!==t?Math.min(Math.max(t,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(t){for(let b=0;b<this._runtimeAnimations.length;b++){this._runtimeAnimations[b]._prepareForSpeedRatioChange(t)}this._speedRatio=t,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(t,b){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,F=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,R=arguments.length>6?arguments[6]:void 0,d=arguments.length>7?arguments[7]:void 0,E=arguments.length>8?arguments[8]:void 0,U=arguments.length>9&&void 0!==arguments[9]&&arguments[9],C=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=b,this.fromFrame=Y,this.toFrame=o,this.loopAnimation=F,this.onAnimationEnd=R,this.onAnimationLoop=E,this.isAdditive=U,this.playOrder=C,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Vd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new x.e,this.onAnimationLoopObservable=new x.e,this._scene=t,d&&this.appendAnimations(b,d),this._speedRatio=r,t._activeAnimatables.push(this)}syncWith(t){if(this._syncRoot=t,t){const t=this._scene._activeAnimatables.indexOf(this);t>-1&&(this._scene._activeAnimatables.splice(t,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(t,b){for(let Y=0;Y<b.length;Y++){const o=b[Y],x=new E(t,o,this._scene,this);x._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(x)}}getAnimationByTargetProperty(t){const b=this._runtimeAnimations;for(let Y=0;Y<b.length;Y++)if(b[Y].animation.targetProperty===t)return b[Y].animation;return null}getRuntimeAnimationByTargetProperty(t){const b=this._runtimeAnimations;for(let Y=0;Y<b.length;Y++)if(b[Y].animation.targetProperty===t)return b[Y];return null}reset(){const t=this._runtimeAnimations;for(let b=0;b<t.length;b++)t[b].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(t){const b=this._runtimeAnimations;for(let Y=0;Y<b.length;Y++)b[Y].animation.enableBlending=!0,b[Y].animation.blendingSpeed=t}disableBlending(){const t=this._runtimeAnimations;for(let b=0;b<t.length;b++)t[b].animation.enableBlending=!1}goToFrame(t){const b=this._runtimeAnimations;if(b[0]){const Y=b[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??b[0].currentFrame;const o=0===this.speedRatio?0:(t-this._frameToSyncFromJump)/Y*1e3/this.speedRatio;this._manualJumpDelay=-o}for(let Y=0;Y<b.length;Y++)b[Y].goToFrame(t,this._weight);this._goToFrame=t}get paused(){return this.Vd}pause(){this.Vd||(this.Vd=!0)}restart(){this.Vd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(t,b){let Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t||b){const x=this._scene._activeAnimatables.indexOf(this);if(x>-1){const F=this._runtimeAnimations;for(let Y=F.length-1;Y>=0;Y--){const o=F[Y];t&&o.animation.name!=t||(b&&!b(o.target)||(o.dispose(),F.splice(Y,1)))}0==F.length&&(Y||this._scene._activeAnimatables.splice(x,1),o||this._raiseOnAnimationEnd())}}else{const t=this._scene._activeAnimatables.indexOf(this);if(t>-1){Y||this._scene._activeAnimatables.splice(t,1);const b=this._runtimeAnimations;for(let t=0;t<b.length;t++)b[t].dispose();this._runtimeAnimations.length=0,o||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((t=>{this.onAnimationEndObservable.add((()=>{t(this)}),void 0,void 0,this,!0)}))}_animate(t){if(this.Vd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=t),!0;if(null===this._localDelayOffset?(this._localDelayOffset=t,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=t-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let b=!1;const Y=this._runtimeAnimations;let o;for(o=0;o<Y.length;o++){const x=Y[o].animate(t-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);b=b||x}if(this.animationStarted=b,!b){if(this.disposeOnEnd)for(o=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(o,1),o=0;o<Y.length;o++)Y[o].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return b}}function p(t){if(0===t.totalWeight&&0===t.totalAdditiveWeight)return t.originalValue;let b=1;const Y=d.f.ae[0],o=d.f.ae[1],x=d.f.Quaternion[0];let F=0;const r=t.animations[0],R=t.originalValue;let E=1,U=!1;if(t.totalWeight<1)E=1-t.totalWeight,R.decompose(o,x,Y);else{if(F=1,b=t.totalWeight,E=r.weight/b,1==E){if(!t.totalAdditiveWeight)return r.currentValue;U=!0}r.currentValue.decompose(o,x,Y)}if(!U){o.scaleInPlace(E),Y.scaleInPlace(E),x.scaleInPlace(E);for(let r=F;r<t.animations.length;r++){const F=t.animations[r];if(0===F.weight)continue;E=F.weight/b;const R=d.f.ae[2],U=d.f.ae[3],C=d.f.Quaternion[1];F.currentValue.decompose(U,C,R),U.scaleAndAddToRef(E,o),C.scaleAndAddToRef(d.e.Dot(x,C)>0?E:-E,x),R.scaleAndAddToRef(E,Y)}x.normalize()}for(let p=0;p<t.additiveAnimations.length;p++){const b=t.additiveAnimations[p];if(0===b.weight)continue;const F=d.f.ae[2],r=d.f.ae[3],R=d.f.Quaternion[1];b.currentValue.decompose(r,R,F),r.multiplyToRef(o,r),d.l.LerpToRef(o,r,b.weight,o),x.multiplyToRef(R,R),d.e.SlerpToRef(x,R,b.weight,x),F.scaleAndAddToRef(b.weight,Y)}const C=r?r._animationState.workValue:d.f.Matrix[0].clone();return d.c.ComposeToRef(o,x,Y,C),C}function W(t,b){if(0===t.totalWeight&&0===t.totalAdditiveWeight)return b;const Y=t.animations[0],o=t.originalValue;let x=b;if(0===t.totalWeight&&t.totalAdditiveWeight>0)x.p(o);else if(1===t.animations.length){if(d.e.SlerpToRef(o,Y.currentValue,Math.min(1,t.totalWeight),x),0===t.totalAdditiveWeight)return x}else if(t.animations.length>1){let Y,F,r=1;if(t.totalWeight<1){const b=1-t.totalWeight;Y=[],F=[],Y.push(o),F.push(b)}else{if(2===t.animations.length&&(d.e.SlerpToRef(t.animations[0].currentValue,t.animations[1].currentValue,t.animations[1].weight/t.totalWeight,b),0===t.totalAdditiveWeight))return b;Y=[],F=[],r=t.totalWeight}for(let b=0;b<t.animations.length;b++){const o=t.animations[b];Y.push(o.currentValue),F.push(o.weight/r)}let R=0;for(let t=0;t<Y.length;)t?(R+=F[t],d.e.SlerpToRef(x,Y[t],F[t]/R,x),t++):(d.e.SlerpToRef(Y[t],Y[t+1],F[t+1]/(F[t]+F[t+1]),b),x=b,R=F[t]+F[t+1],t+=2)}for(let F=0;F<t.additiveAnimations.length;F++){const b=t.additiveAnimations[F];0!==b.weight&&(x.multiplyToRef(b.currentValue,d.f.Quaternion[0]),d.e.SlerpToRef(x,d.f.Quaternion[0],b.weight,x))}return x}var T,y,v=Y(1260);T=v.e,(y=R.d)&&(y.prototype.copyAnimationRange=function(t,b,Y){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3],F=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new o.d(this.name,"_matrix",t.animations[0].framePerSecond,o.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const r=t.animations[0].getRange(b);if(!r)return!1;const R=r.from,d=r.to,E=t.animations[0].getKeys(),U=t.length,C=t.getParent(),p=this.getParent(),W=x&&C&&U&&this.length&&U!==this.length,T=W&&p&&C?p.length/C.length:1,y=x&&!p&&F&&(1!==F.x||1!==F.y||1!==F.z),v=this.animations[0].getKeys();let B,J,m;for(let o=0,K=E.length;o<K;o++)B=E[o],B.frame>=R&&B.frame<=d&&(x?(m=B.value.clone(),W?(J=m.getTranslation(),m.setTranslation(J.scaleInPlace(T))):y&&F?(J=m.getTranslation(),m.setTranslation(J.multiplyInPlace(F))):m=B.value):m=B.value,v.push({frame:B.frame+Y,value:m}));return this.animations[0].createRange(b,R+Y,d+Y),!0}),T&&(T.prototype._animate=function(t){if(!this.animationsEnabled)return;const b=U.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=b}this.deltaTime=void 0!==t?t:this.useConstantAnimationDeltaTime?16:(b-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=b;const Y=this._activeAnimatables;if(0===Y.length)return;this._animationTime+=this.deltaTime;const x=this._animationTime;for(let o=0;o<Y.length;o++){const t=Y[o];!t._animate(x)&&t.disposeOnEnd&&o--}!function(t){if(t._registeredForLateAnimationBindings.length){for(let b=0;b<t._registeredForLateAnimationBindings.length;b++){const Y=t._registeredForLateAnimationBindings.data[b];for(const t in Y._lateAnimationHolders){const b=Y._lateAnimationHolders[t],x=b.animations[0],F=b.originalValue;if(void 0===F||null===F)continue;const r=o.d.AllowMatrixDecomposeForInterpolation&&F.m;let R=Y[t];if(r)R=p(b);else if(void 0!==F.w)R=W(b,R||d.e.Identity());else{let t=0,Y=1;const r=x&&x._animationState.loopMode===o.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(b.totalWeight<1)R=r?F.clone?F.clone():F:x&&F.scale?F.scale(1-b.totalWeight):x?F*(1-b.totalWeight):F.clone?F.clone():F;else if(x){Y=b.totalWeight;const o=x.weight/Y;R=1!==o?x.currentValue.scale?x.currentValue.scale(o):x.currentValue*o:x.currentValue,r&&(R.addToRef?R.addToRef(F,R):R+=F),t=1}for(let o=t;o<b.animations.length;o++){const t=b.animations[o],x=t.weight/Y;x&&(t.currentValue.scaleAndAddToRef?t.currentValue.scaleAndAddToRef(x,R):R+=t.currentValue*x)}for(let o=0;o<b.additiveAnimations.length;o++){const t=b.additiveAnimations[o],Y=t.weight;Y&&(t.currentValue.scaleAndAddToRef?t.currentValue.scaleAndAddToRef(Y,R):R+=t.currentValue*Y)}}Y[t]=R}Y._lateAnimationHolders={}}t._registeredForLateAnimationBindings.reset()}}(this)},T.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((t,b)=>t.playOrder-b.playOrder))},T.prototype.beginWeightedAnimation=function(t,b,Y){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,x=arguments.length>4?arguments[4]:void 0,F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,r=arguments.length>6?arguments[6]:void 0,R=arguments.length>7?arguments[7]:void 0,d=arguments.length>8?arguments[8]:void 0,E=arguments.length>9?arguments[9]:void 0,U=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const C=this.beginAnimation(t,b,Y,x,F,r,R,!1,d,E,U);return C.weight=o,C},T.prototype.beginAnimation=function(t,b,Y,o){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,F=arguments.length>5?arguments[5]:void 0,r=arguments.length>6?arguments[6]:void 0,R=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],d=arguments.length>8?arguments[8]:void 0,E=arguments.length>9?arguments[9]:void 0,U=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(x<0){const t=b;b=Y,Y=t,x=-x}b>Y&&(x=-x),R&&this.stopAnimation(t,void 0,d),r||(r=new C(this,t,b,Y,o,x,F,void 0,E,U));const p=!d||d(t);if(t.animations&&p&&r.appendAnimations(t,t.animations),t.getAnimatables){const U=t.getAnimatables();for(let t=0;t<U.length;t++)this.beginAnimation(U[t],b,Y,o,x,F,r,R,d,E)}return r.reset(),r},T.prototype.beginHierarchyAnimation=function(t,b,Y,o,x){let F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,r=arguments.length>6?arguments[6]:void 0,R=arguments.length>7?arguments[7]:void 0,d=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],E=arguments.length>9?arguments[9]:void 0,U=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const C=t.getDescendants(b),p=[];p.push(this.beginAnimation(t,Y,o,x,F,r,R,d,E,void 0,U));for(const W of C)p.push(this.beginAnimation(W,Y,o,x,F,r,R,d,E,void 0,U));return p},T.prototype.beginDirectAnimation=function(t,b,Y,o,x){let F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(F<0){const t=Y;Y=o,o=t,F=-F}return Y>o&&(F=-F),new C(this,t,Y,o,x,F,arguments.length>6?arguments[6]:void 0,b,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},T.prototype.beginDirectHierarchyAnimation=function(t,b,Y,o,x,F,r,R,d){let E=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const U=t.getDescendants(b),C=[];C.push(this.beginDirectAnimation(t,Y,o,x,F,r,R,d,E));for(const p of U)C.push(this.beginDirectAnimation(p,Y,o,x,F,r,R,d,E));return C},T.prototype.getAnimatableByTarget=function(t){for(let b=0;b<this._activeAnimatables.length;b++)if(this._activeAnimatables[b].target===t)return this._activeAnimatables[b];return null},T.prototype.getAllAnimatablesByTarget=function(t){const b=[];for(let Y=0;Y<this._activeAnimatables.length;Y++)this._activeAnimatables[Y].target===t&&b.push(this._activeAnimatables[Y]);return b},T.prototype.stopAnimation=function(t,b,Y){const o=this.getAllAnimatablesByTarget(t);for(const x of o)x.stop(b,Y)},T.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let t=0;t<this._activeAnimatables.length;t++)this._activeAnimatables[t].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const t of this.animationGroups)t.stop()});class B{getClassName(){return"TargetedAnimation"}serialize(){const t={};return t.animation=this.animation.serialize(),t.targetId=this.target.id,t}}class J{get mask(){return this._mask}set mask(t){this._mask!==t&&(this._mask=t,this.syncWithMask(!0))}syncWithMask(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||t){this._numActiveAnimatables=0;for(let t=0;t<this._animatables.length;++t){const b=this._animatables[t];!this.mask||this.mask.disabled||this.mask.retainsTarget(b.target.name)?(this._numActiveAnimatables++,b.paused&&b.restart()):b.paused||b.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let t=0;t<this._animatables.length;++t){const b=this._animatables[t];this.mask.retainsTarget(b.target.name)||(b.stop(),this._animatables.splice(t,1),--t)}for(let t=0;t<this._targetedAnimations.length;t++){const b=this._targetedAnimations[t];this.mask.retainsTarget(b.target.name)||(this._targetedAnimations.splice(t,1),--t)}}}get from(){return this._from}set from(t){if(this._from!==t){this._from=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].fromFrame=this._from}}}get to(){return this._to}set to(t){if(this._to!==t){this._to=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(t){if(this._speedRatio!==t){this._speedRatio=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(t){if(this._loopAnimation!==t){this._loopAnimation=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(t){if(this._isAdditive!==t){this._isAdditive=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(t){this._weight!==t&&(this._weight=t,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(t){if(this._playOrder!==t&&(this._playOrder=t,this._animatables.length>0)){for(let t=0;t<this._animatables.length;t++)this._animatables[t].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(t){if(this._enableBlending!==t&&(this._enableBlending=t,null!==t))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.enableBlending=t}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(t){if(this._blendingSpeed!==t&&(this._blendingSpeed=t,null!==t))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.blendingSpeed=t}getLength(t,b){t=t??this._from;return((b=b??this._to)-t)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(t){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3?arguments[3]:void 0;if(0===t.length)return null;o=o??t[0].weight;let x=Number.MAX_VALUE,F=-Number.MAX_VALUE;if(Y)for(const R of t)R.from<x&&(x=R.from),R.to>F&&(F=R.to);const r=new J(t[0].name+"_merged",t[0]._scene,o);for(const R of t){Y&&R.normalize(x,F);for(const t of R.targetedAnimations)r.addTargetedAnimation(t.animation,t.target);b&&R.dispose()}return r}constructor(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=t,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new x.e,this.onAnimationLoopObservable=new x.e,this.onAnimationGroupLoopObservable=new x.e,this.onAnimationGroupEndObservable=new x.e,this.onAnimationGroupPauseObservable=new x.e,this.onAnimationGroupPlayObservable=new x.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=b||F.d.LastCreatedScene,this._weight=Y,this._playOrder=o,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(t,b){const Y=new B;Y.animation=t,Y.target=b;const o=t.getKeys();return this._from>o[0].frame&&(this._from=o[0].frame),this._to<o[o.length-1].frame&&(this._to=o[o.length-1].frame),null!==this._enableBlending&&(t.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(t.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(Y),this._shouldStart=!0,Y}removeTargetedAnimation(t){for(let b=this._targetedAnimations.length-1;b>-1;b--){this._targetedAnimations[b].animation===t&&this._targetedAnimations.splice(b,1)}}normalize(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==t&&(t=this._from),null==b&&(b=this._to);for(let Y=0;Y<this._targetedAnimations.length;Y++){const o=this._targetedAnimations[Y].animation.getKeys(),x=o[0],F=o[o.length-1];if(x.frame>t){const b={frame:t,value:x.value,inTangent:x.inTangent,outTangent:x.outTangent,interpolation:x.interpolation};o.splice(0,0,b)}if(F.frame<b){const t={frame:b,value:F.value,inTangent:F.inTangent,outTangent:F.outTangent,interpolation:F.interpolation};o.push(t)}}return this._from=t,this._to=b,this}_processLoop(t,b,Y){t.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(b),this._animationLoopFlags[Y]||(this._animationLoopFlags[Y]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Y=arguments.length>2?arguments[2]:void 0,o=arguments.length>3?arguments[3]:void 0,x=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=t,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let F=0;F<this._targetedAnimations.length;F++){const r=this._targetedAnimations[F],R=this._scene.beginDirectAnimation(r.target,[r.animation],void 0!==Y?Y:this._from,void 0!==o?o:this._to,t,b,void 0,void 0,void 0!==x?x:this._isAdditive);R.weight=this._weight,R.playOrder=this._playOrder,R.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(r),this._checkAnimationGroupEnded(R)},this._processLoop(R,r,F),this._animatables.push(R)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=b,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let t=0;t<this._animatables.length;t++){this._animatables[t].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(t){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==t&&(this.loopAnimation=t),this.restart()):(this.stop(),this.start(t,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].reset()}return this}restart(){if(!this._isStarted)return this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const b=this._animatables.slice();for(let o=0;o<b.length;o++)b[o].stop(void 0,void 0,!0,t);let Y=0;for(let o=0;o<this._scene._activeAnimatables.length;o++){const b=this._scene._activeAnimatables[o];b._runtimeAnimations.length>0?this._scene._activeAnimatables[Y++]=b:t&&this._checkAnimationGroupEnded(b,t)}return this._scene._activeAnimatables.length=Y,this._isStarted=!1,this}setWeightForAllAnimatables(t){for(let b=0;b<this._animatables.length;b++){this._animatables[b].weight=t}return this}syncAllAnimationsWith(t){for(let b=0;b<this._animatables.length;b++){this._animatables[b].syncWith(t)}return this}goToFrame(t){if(!this._isStarted)return this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].goToFrame(t)}return this}getCurrentFrame(){var t;return(null===(t=this.animatables[0])||void 0===t?void 0:t.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const t=this._scene.animationGroups.indexOf(this);if(t>-1&&this._scene.animationGroups.splice(t,1),this._parentContainer){const t=this._parentContainer.animationGroups.indexOf(this);t>-1&&this._parentContainer.animationGroups.splice(t,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(t){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Y=this._animatables.indexOf(t);Y>-1&&this._animatables.splice(Y,1),0===this._animatables.length&&(this._isStarted=!1,b||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(t,b){let Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=new J(t||this.name,this._scene,this._weight,this._playOrder);o._from=this.from,o._to=this.to,o._speedRatio=this.speedRatio,o._loopAnimation=this.loopAnimation,o._isAdditive=this.isAdditive,o._enableBlending=this.enableBlending,o._blendingSpeed=this.blendingSpeed,o.metadata=this.metadata,o.mask=this.mask;for(const x of this._targetedAnimations)o.addTargetedAnimation(Y?x.animation.clone():x.animation,b?b(x.target):x.target);return o}serialize(){const t={};t.name=this.name,t.from=this.from,t.to=this.to,t.speedRatio=this.speedRatio,t.loopAnimation=this.loopAnimation,t.isAdditive=this.isAdditive,t.weight=this.weight,t.playOrder=this.playOrder,t.enableBlending=this.enableBlending,t.blendingSpeed=this.blendingSpeed,t.targetedAnimations=[];for(let b=0;b<this.targetedAnimations.length;b++){const Y=this.targetedAnimations[b];t.targetedAnimations[b]=Y.serialize()}return r.b&&r.b.HasTags(this)&&(t.tags=r.b.GetTags(this)),this.metadata&&(t.metadata=this.metadata),t}static Parse(t,b){const Y=new J(t.name,b,t.weight,t.playOrder);for(let x=0;x<t.targetedAnimations.length;x++){const F=t.targetedAnimations[x],r=o.d.Parse(F.animation),R=F.targetId;if("influence"===F.animation.property){const t=b.getMorphTargetById(R);t&&Y.addTargetedAnimation(r,t)}else{const t=b.getNodeById(R);null!=t&&Y.addTargetedAnimation(r,t)}}return r.b&&r.b.AddTagsTo(Y,t.tags),null!==t.from&&null!==t.to&&Y.normalize(t.from,t.to),void 0!==t.speedRatio&&(Y._speedRatio=t.speedRatio),void 0!==t.loopAnimation&&(Y._loopAnimation=t.loopAnimation),void 0!==t.isAdditive&&(Y._isAdditive=t.isAdditive),void 0!==t.weight&&(Y._weight=t.weight),void 0!==t.playOrder&&(Y._playOrder=t.playOrder),void 0!==t.enableBlending&&(Y._enableBlending=t.enableBlending),void 0!==t.blendingSpeed&&(Y._blendingSpeed=t.blendingSpeed),void 0!==t.metadata&&(Y.metadata=t.metadata),Y}static MakeAnimationAdditive(t,b,Y){let x;x="object"===typeof b?b:{referenceFrame:b,range:Y,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let F=t;x.cloneOriginalAnimationGroup&&(F=t.clone(x.clonedAnimationGroupName||F.name));const r=F.targetedAnimations;for(let R=0;R<r.length;R++){const t=r[R];t.animation=o.d.MakeAnimationAdditive(t.animation,x)}if(F.isAdditive=!0,x.clipKeys){let t=Number.MAX_VALUE,b=-Number.MAX_VALUE;const Y=F.targetedAnimations;for(let o=0;o<Y.length;o++){const x=Y[o].animation.getKeys();t>x[0].frame&&(t=x[0].frame),b<x[x.length-1].frame&&(b=x[x.length-1].frame)}F._from=t,F._to=b}return F}static ClipKeys(t,b,Y,o,x){const F=t.clone(o||t.name);return J.ClipKeysInPlace(F,b,Y,x)}static ClipKeysInPlace(t,b,Y,o){return J.ClipInPlace(t,b,Y,o,!1)}static ClipFrames(t,b,Y,o,x){const F=t.clone(o||t.name);return J.ClipFramesInPlace(F,b,Y,x)}static ClipFramesInPlace(t,b,Y,o){return J.ClipInPlace(t,b,Y,o,!0)}static ClipInPlace(t,b,Y,o){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4],F=Number.MAX_VALUE,r=-Number.MAX_VALUE;const R=t.targetedAnimations;for(let d=0;d<R.length;d++){const t=R[d],E=o?t.animation:t.animation.clone();x&&(E.createKeyForFrame(b),E.createKeyForFrame(Y));const U=E.getKeys(),C=[];let p=Number.MAX_VALUE;for(let o=0;o<U.length;o++){const t=U[o];if(!x&&o>=b&&o<=Y||x&&t.frame>=b&&t.frame<=Y){const b={frame:t.frame,value:t.value.clone?t.value.clone():t.value,inTangent:t.inTangent,outTangent:t.outTangent,interpolation:t.interpolation,lockedTangent:t.lockedTangent};p===Number.MAX_VALUE&&(p=b.frame),b.frame-=p,C.push(b)}}0!==C.length?(F>C[0].frame&&(F=C[0].frame),r<C[C.length-1].frame&&(r=C[C.length-1].frame),E.setKeys(C,!0),t.animation=E):(R.splice(d,1),d--)}return t._from=F,t._to=r,t}getClassName(){return"AnimationGroup"}toString(t){let b="Name: "+this.name;return b+=", type: "+this.getClassName(),t&&(b+=", from: "+this._from,b+=", to: "+this._to,b+=", isStarted: "+this._isStarted,b+=", speedRatio: "+this._speedRatio,b+=", targetedAnimations length: "+this._targetedAnimations.length,b+=", animatables length: "+this._animatables),b}}}}]);