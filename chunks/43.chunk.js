"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[43],{13074:(V,n,O)=>{O.r(n),O.d(n,{AnimationGroup:()=>a,TargetedAnimation:()=>X});var H=O(12388),g=O(1020),f=O(1047),x=O(1194),c=O(12384),e=O(1023);class U{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(V,n,O,g){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=n,this._target=V,this._scene=O,this._host=g,this._activeTargets=[],n._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===H.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=e.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const V={frame:0,value:this._minValue};this._keys.splice(0,0,V)}if(this._target instanceof Array){let V=0;for(const n of this._target)this._preparePath(n,V),this._getOriginalValues(V),V++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const f=n.getEvents();f&&f.length>0&&f.forEach((V=>{this._events.push(V._clone())})),this._enableBlending=V&&V.animationPropertiesOverride?V.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(V){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const O=this._animation.targetPropertyPath;if(O.length>1){let H=V;for(let V=0;V<O.length-1;V++){const n=O[V];if(H=H[n],void 0===H)throw new Error(`Invalid property (${n}) in property path (${O.join(".")})`)}this._targetPath=O[O.length-1],this._activeTargets[n]=H}else this._targetPath=O[0],this._activeTargets[n]=V;if(void 0===this._activeTargets[n][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${O.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let V=0;for(const n of this._target)void 0!==this._originalValue[V]&&this._setValue(n,this._activeTargets[V],this._originalValue[V],-1,V),V++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let V=0;V<this._events.length;V++)this._events[V].isDone=!1}isStopped(){return this._stopped}dispose(){const V=this._animation.runtimeAnimations.indexOf(this);V>-1&&this._animation.runtimeAnimations.splice(V,1)}setValue(V,n){if(this._targetIsArray)for(let O=0;O<this._target.length;O++){const H=this._target[O];this._setValue(H,this._activeTargets[O],V,n,O)}else this._setValue(this._target,this._directTarget,V,n,0)}_getOriginalValues(){let V,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const O=this._activeTargets[n];V=O.getLocalMatrix&&"_matrix"===this._targetPath?O.getLocalMatrix():O[this._targetPath],V&&V.clone?this._originalValue[n]=V.clone():this._originalValue[n]=V}_registerTargetForLateAnimationBinding(V,n){const O=V.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(O),O._lateAnimationHolders||(O._lateAnimationHolders={}),O._lateAnimationHolders[V.targetPath]||(O._lateAnimationHolders[V.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:n}),V.isAdditive?(O._lateAnimationHolders[V.targetPath].additiveAnimations.push(V),O._lateAnimationHolders[V.targetPath].totalAdditiveWeight+=V.weight):(O._lateAnimationHolders[V.targetPath].animations.push(V),O._lateAnimationHolders[V.targetPath].totalWeight+=V.weight)}_setValue(V,n,O,g,f){if(this._currentActiveTarget=n,this._weight=g,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const V=n[this._targetPath];V.clone?this._originalBlendValue=V.clone():this._originalBlendValue=V}this._originalBlendValue.m?H.b.AllowMatrixDecomposeForInterpolation?this._currentValue?e.b.DecomposeLerpToRef(this._originalBlendValue,O,this._blendingFactor,this._currentValue):this._currentValue=e.b.DecomposeLerp(this._originalBlendValue,O,this._blendingFactor):this._currentValue?e.b.LerpToRef(this._originalBlendValue,O,this._blendingFactor,this._currentValue):this._currentValue=e.b.Lerp(this._originalBlendValue,O,this._blendingFactor):this._currentValue=H.b._UniversalLerp(this._originalBlendValue,O,this._blendingFactor);const g=V&&V.animationPropertiesOverride?V.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=g}else this._currentValue?this._currentValue.p?this._currentValue.p(O):this._currentValue=O:null!==O&&void 0!==O&&O.clone?this._currentValue=O.clone():this._currentValue=O;-1!==g?this._registerTargetForLateAnimationBinding(this,this._originalValue[f]):this._animationState.loopMode===H.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[f],n[this._targetPath]):n[this._targetPath]=this._originalValue[f]+this._currentValue:n[this._targetPath]=this._currentValue,V.Oe&&V.Oe(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(V){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const O=this._animation.getKeys();V<O[0].frame?V=O[0].frame:V>O[O.length-1].frame&&(V=O[O.length-1].frame);const H=this._events;if(H.length)for(let f=0;f<H.length;f++)H[f].onlyOnce||(H[f].isDone=H[f].frame<V);this._currentFrame=V;const g=this._animation._interpolate(V,this._animationState);this.setValue(g,n)}_prepareForSpeedRatioChange(V){const n=this._previousElapsedTime*(this._animation.framePerSecond*V)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-n}animate(V,n,O,g,f){let x=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const c=this._animation,e=c.targetPropertyPath;if(!e||e.length<1)return this._stopped=!0,!1;let U=!0;(n<this._minFrame||n>this._maxFrame)&&(n=this._minFrame),(O<this._minFrame||O>this._maxFrame)&&(O=this._maxFrame);const M=O-n;let p,j=V*(c.framePerSecond*f)/1e3+this._absoluteFrameOffset,i=0,A=!1;const S=g&&this._animationState.loopMode===H.b.ANIMATIONLOOPMODE_YOYO;if(S){const V=(j-n)/M,O=Math.sin(V*Math.PI);j=Math.abs(O)*M+n;const H=O>=0?1:-1;this._yoyoDirection!==H&&(A=!0),this._yoyoDirection=H}if(this._previousElapsedTime=V,this._previousAbsoluteFrame=j,!g&&O>=n&&(j>=M&&f>0||j<=0&&f<0))U=!1,i=c._getKeyValue(this._maxValue);else if(!g&&n>=O&&(j<=M&&f<0||j>=0&&f>0))U=!1,i=c._getKeyValue(this._minValue);else if(this._animationState.loopMode!==H.b.ANIMATIONLOOPMODE_CYCLE){const V=O.toString()+n.toString();if(!this._offsetsCache[V]){this._animationState.repeatCount=0,this._animationState.loopMode=H.b.ANIMATIONLOOPMODE_CYCLE;const g=c._interpolate(n,this._animationState),f=c._interpolate(O,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),c.dataType){case H.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[V]=f-g;break;case H.b.ANIMATIONTYPE_QUATERNION:case H.b.ANIMATIONTYPE_VECTOR3:case H.b.ANIMATIONTYPE_VECTOR2:case H.b.ANIMATIONTYPE_SIZE:case H.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[V]=f.pd(g)}this._highLimitsCache[V]=f}i=this._highLimitsCache[V],p=this._offsetsCache[V]}if(void 0===p)switch(c.dataType){case H.b.ANIMATIONTYPE_FLOAT:p=0;break;case H.b.ANIMATIONTYPE_QUATERNION:p=H.k;break;case H.b.ANIMATIONTYPE_VECTOR3:p=H.u;break;case H.b.ANIMATIONTYPE_VECTOR2:p=H.q;break;case H.b.ANIMATIONTYPE_SIZE:p=H.n;break;case H.b.ANIMATIONTYPE_COLOR3:p=H.d;break;case H.b.ANIMATIONTYPE_COLOR4:p=H.h}let B;if(this._host&&this._host.syncRoot){const V=this._host.syncRoot;B=n+M*((V.masterFrame-V.fromFrame)/(V.toFrame-V.fromFrame))}else B=j>0&&n>O||j<0&&n<O?U&&0!==M?O+j%M:n:U&&0!==M?n+j%M:O;const X=this._events;if(!S&&(f>0&&this.currentFrame>B||f<0&&this.currentFrame<B)||S&&A){this._onLoop();for(let V=0;V<X.length;V++)X[V].onlyOnce||(X[V].isDone=!1);this._animationState.key=f>0?0:c.getKeys().length-1}this._currentFrame=B,this._animationState.repeatCount=0===M?0:j/M|0,this._animationState.highLimitValue=i,this._animationState.offsetValue=p;const a=c._interpolate(B,this._animationState);if(this.setValue(a,x),X.length)for(let H=0;H<X.length;H++)if(M>=0&&B>=X[H].frame&&X[H].frame>=n||M<0&&B<=X[H].frame&&X[H].frame<=n){const V=X[H];V.isDone||(V.onlyOnce&&(X.splice(H,1),H--),V.isDone=!0,V.action(B))}return U||(this._stopped=!0),U}}var M=O(1155);class p{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(V){this._weight=-1!==V?Math.min(Math.max(V,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(V){for(let n=0;n<this._runtimeAnimations.length;n++){this._runtimeAnimations[n]._prepareForSpeedRatioChange(V)}this._speedRatio=V,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(V,n){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,f=arguments.length>4&&void 0!==arguments[4]&&arguments[4],x=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,c=arguments.length>6?arguments[6]:void 0,e=arguments.length>7?arguments[7]:void 0,U=arguments.length>8?arguments[8]:void 0,M=arguments.length>9&&void 0!==arguments[9]&&arguments[9],p=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=n,this.fromFrame=O,this.toFrame=H,this.loopAnimation=f,this.onAnimationEnd=c,this.onAnimationLoop=U,this.isAdditive=M,this.playOrder=p,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.ae=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new g.d,this.onAnimationLoopObservable=new g.d,this._scene=V,e&&this.appendAnimations(n,e),this._speedRatio=x,V._activeAnimatables.push(this)}syncWith(V){if(this._syncRoot=V,V){const V=this._scene._activeAnimatables.indexOf(this);V>-1&&(this._scene._activeAnimatables.splice(V,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(V,n){for(let O=0;O<n.length;O++){const H=n[O],g=new U(V,H,this._scene,this);g._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(g)}}getAnimationByTargetProperty(V){const n=this._runtimeAnimations;for(let O=0;O<n.length;O++)if(n[O].animation.targetProperty===V)return n[O].animation;return null}getRuntimeAnimationByTargetProperty(V){const n=this._runtimeAnimations;for(let O=0;O<n.length;O++)if(n[O].animation.targetProperty===V)return n[O];return null}reset(){const V=this._runtimeAnimations;for(let n=0;n<V.length;n++)V[n].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(V){const n=this._runtimeAnimations;for(let O=0;O<n.length;O++)n[O].animation.enableBlending=!0,n[O].animation.blendingSpeed=V}disableBlending(){const V=this._runtimeAnimations;for(let n=0;n<V.length;n++)V[n].animation.enableBlending=!1}goToFrame(V){const n=this._runtimeAnimations;if(n[0]){const O=n[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??n[0].currentFrame;const H=0===this.speedRatio?0:(V-this._frameToSyncFromJump)/O*1e3/this.speedRatio;this._manualJumpDelay=-H}for(let O=0;O<n.length;O++)n[O].goToFrame(V,this._weight);this._goToFrame=V}get paused(){return this.ae}pause(){this.ae||(this.ae=!0)}restart(){this.ae=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(V,n){let O=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(V||n){const g=this._scene._activeAnimatables.indexOf(this);if(g>-1){const f=this._runtimeAnimations;for(let O=f.length-1;O>=0;O--){const H=f[O];V&&H.animation.name!=V||(n&&!n(H.target)||(H.dispose(),f.splice(O,1)))}0==f.length&&(O||this._scene._activeAnimatables.splice(g,1),H||this._raiseOnAnimationEnd())}}else{const V=this._scene._activeAnimatables.indexOf(this);if(V>-1){O||this._scene._activeAnimatables.splice(V,1);const n=this._runtimeAnimations;for(let V=0;V<n.length;V++)n[V].dispose();this._runtimeAnimations.length=0,H||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((V=>{this.onAnimationEndObservable.add((()=>{V(this)}),void 0,void 0,this,!0)}))}_animate(V){if(this.ae)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=V),!0;if(null===this._localDelayOffset?(this._localDelayOffset=V,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=V-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let n=!1;const O=this._runtimeAnimations;let H;for(H=0;H<O.length;H++){const g=O[H].animate(V-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);n=n||g}if(this.animationStarted=n,!n){if(this.disposeOnEnd)for(H=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(H,1),H=0;H<O.length;H++)O[H].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return n}}function j(V){if(0===V.totalWeight&&0===V.totalAdditiveWeight)return V.originalValue;let n=1;const O=e.h.je[0],H=e.h.je[1],g=e.h.Quaternion[0];let f=0;const x=V.animations[0],c=V.originalValue;let U=1,M=!1;if(V.totalWeight<1)U=1-V.totalWeight,c.decompose(H,g,O);else{if(f=1,n=V.totalWeight,U=x.weight/n,1==U){if(!V.totalAdditiveWeight)return x.currentValue;M=!0}x.currentValue.decompose(H,g,O)}if(!M){H.scaleInPlace(U),O.scaleInPlace(U),g.scaleInPlace(U);for(let x=f;x<V.animations.length;x++){const f=V.animations[x];if(0===f.weight)continue;U=f.weight/n;const c=e.h.je[2],M=e.h.je[3],p=e.h.Quaternion[1];f.currentValue.decompose(M,p,c),M.scaleAndAddToRef(U,H),p.scaleAndAddToRef(e.e.Dot(g,p)>0?U:-U,g),c.scaleAndAddToRef(U,O)}g.normalize()}for(let j=0;j<V.additiveAnimations.length;j++){const n=V.additiveAnimations[j];if(0===n.weight)continue;const f=e.h.je[2],x=e.h.je[3],c=e.h.Quaternion[1];n.currentValue.decompose(x,c,f),x.multiplyToRef(H,x),e.j.LerpToRef(H,x,n.weight,H),g.multiplyToRef(c,c),e.e.SlerpToRef(g,c,n.weight,g),f.scaleAndAddToRef(n.weight,O)}const p=x?x._animationState.workValue:e.h.Matrix[0].clone();return e.b.ComposeToRef(H,g,O,p),p}function i(V,n){if(0===V.totalWeight&&0===V.totalAdditiveWeight)return n;const O=V.animations[0],H=V.originalValue;let g=n;if(0===V.totalWeight&&V.totalAdditiveWeight>0)g.p(H);else if(1===V.animations.length){if(e.e.SlerpToRef(H,O.currentValue,Math.min(1,V.totalWeight),g),0===V.totalAdditiveWeight)return g}else if(V.animations.length>1){let O,f,x=1;if(V.totalWeight<1){const n=1-V.totalWeight;O=[],f=[],O.push(H),f.push(n)}else{if(2===V.animations.length&&(e.e.SlerpToRef(V.animations[0].currentValue,V.animations[1].currentValue,V.animations[1].weight/V.totalWeight,n),0===V.totalAdditiveWeight))return n;O=[],f=[],x=V.totalWeight}for(let n=0;n<V.animations.length;n++){const H=V.animations[n];O.push(H.currentValue),f.push(H.weight/x)}let c=0;for(let V=0;V<O.length;)V?(c+=f[V],e.e.SlerpToRef(g,O[V],f[V]/c,g),V++):(e.e.SlerpToRef(O[V],O[V+1],f[V+1]/(f[V]+f[V+1]),n),g=n,c=f[V]+f[V+1],V+=2)}for(let f=0;f<V.additiveAnimations.length;f++){const n=V.additiveAnimations[f];0!==n.weight&&(g.multiplyToRef(n.currentValue,e.h.Quaternion[0]),e.e.SlerpToRef(g,e.h.Quaternion[0],n.weight,g))}return g}var A,S,B=O(1242);A=B.d,(S=c.e)&&(S.prototype.copyAnimationRange=function(V,n,O){let g=arguments.length>3&&void 0!==arguments[3]&&arguments[3],f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new H.b(this.name,"_matrix",V.animations[0].framePerSecond,H.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const x=V.animations[0].getRange(n);if(!x)return!1;const c=x.from,e=x.to,U=V.animations[0].getKeys(),M=V.length,p=V.getParent(),j=this.getParent(),i=g&&p&&M&&this.length&&M!==this.length,A=i&&j&&p?j.length/p.length:1,S=g&&!j&&f&&(1!==f.x||1!==f.y||1!==f.z),B=this.animations[0].getKeys();let X,a,q;for(let H=0,G=U.length;H<G;H++)X=U[H],X.frame>=c&&X.frame<=e&&(g?(q=X.value.clone(),i?(a=q.getTranslation(),q.setTranslation(a.scaleInPlace(A))):S&&f?(a=q.getTranslation(),q.setTranslation(a.multiplyInPlace(f))):q=X.value):q=X.value,B.push({frame:X.frame+O,value:q}));return this.animations[0].createRange(n,c+O,e+O),!0}),A&&(A.prototype._animate=function(V){if(!this.animationsEnabled)return;const n=M.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=n}this.deltaTime=void 0!==V?V:this.useConstantAnimationDeltaTime?16:(n-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=n;const O=this._activeAnimatables;if(0===O.length)return;this._animationTime+=this.deltaTime;const g=this._animationTime;for(let H=0;H<O.length;H++){const V=O[H];!V._animate(g)&&V.disposeOnEnd&&H--}!function(V){if(V._registeredForLateAnimationBindings.length){for(let n=0;n<V._registeredForLateAnimationBindings.length;n++){const O=V._registeredForLateAnimationBindings.data[n];for(const V in O._lateAnimationHolders){const n=O._lateAnimationHolders[V],g=n.animations[0],f=n.originalValue;if(void 0===f||null===f)continue;const x=H.b.AllowMatrixDecomposeForInterpolation&&f.m;let c=O[V];if(x)c=j(n);else if(void 0!==f.w)c=i(n,c||e.e.Identity());else{let V=0,O=1;const x=g&&g._animationState.loopMode===H.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(n.totalWeight<1)c=x?f.clone?f.clone():f:g&&f.scale?f.scale(1-n.totalWeight):g?f*(1-n.totalWeight):f.clone?f.clone():f;else if(g){O=n.totalWeight;const H=g.weight/O;c=1!==H?g.currentValue.scale?g.currentValue.scale(H):g.currentValue*H:g.currentValue,x&&(c.addToRef?c.addToRef(f,c):c+=f),V=1}for(let H=V;H<n.animations.length;H++){const V=n.animations[H],g=V.weight/O;g&&(V.currentValue.scaleAndAddToRef?V.currentValue.scaleAndAddToRef(g,c):c+=V.currentValue*g)}for(let H=0;H<n.additiveAnimations.length;H++){const V=n.additiveAnimations[H],O=V.weight;O&&(V.currentValue.scaleAndAddToRef?V.currentValue.scaleAndAddToRef(O,c):c+=V.currentValue*O)}}O[V]=c}O._lateAnimationHolders={}}V._registeredForLateAnimationBindings.reset()}}(this)},A.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((V,n)=>V.playOrder-n.playOrder))},A.prototype.beginWeightedAnimation=function(V,n,O){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,g=arguments.length>4?arguments[4]:void 0,f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,x=arguments.length>6?arguments[6]:void 0,c=arguments.length>7?arguments[7]:void 0,e=arguments.length>8?arguments[8]:void 0,U=arguments.length>9?arguments[9]:void 0,M=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const p=this.beginAnimation(V,n,O,g,f,x,c,!1,e,U,M);return p.weight=H,p},A.prototype.beginAnimation=function(V,n,O,H){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,f=arguments.length>5?arguments[5]:void 0,x=arguments.length>6?arguments[6]:void 0,c=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],e=arguments.length>8?arguments[8]:void 0,U=arguments.length>9?arguments[9]:void 0,M=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(g<0){const V=n;n=O,O=V,g=-g}n>O&&(g=-g),c&&this.stopAnimation(V,void 0,e),x||(x=new p(this,V,n,O,H,g,f,void 0,U,M));const j=!e||e(V);if(V.animations&&j&&x.appendAnimations(V,V.animations),V.getAnimatables){const M=V.getAnimatables();for(let V=0;V<M.length;V++)this.beginAnimation(M[V],n,O,H,g,f,x,c,e,U)}return x.reset(),x},A.prototype.beginHierarchyAnimation=function(V,n,O,H,g){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,x=arguments.length>6?arguments[6]:void 0,c=arguments.length>7?arguments[7]:void 0,e=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],U=arguments.length>9?arguments[9]:void 0,M=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const p=V.getDescendants(n),j=[];j.push(this.beginAnimation(V,O,H,g,f,x,c,e,U,void 0,M));for(const i of p)j.push(this.beginAnimation(i,O,H,g,f,x,c,e,U,void 0,M));return j},A.prototype.beginDirectAnimation=function(V,n,O,H,g){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(f<0){const V=O;O=H,H=V,f=-f}return O>H&&(f=-f),new p(this,V,O,H,g,f,arguments.length>6?arguments[6]:void 0,n,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},A.prototype.beginDirectHierarchyAnimation=function(V,n,O,H,g,f,x,c,e){let U=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const M=V.getDescendants(n),p=[];p.push(this.beginDirectAnimation(V,O,H,g,f,x,c,e,U));for(const j of M)p.push(this.beginDirectAnimation(j,O,H,g,f,x,c,e,U));return p},A.prototype.getAnimatableByTarget=function(V){for(let n=0;n<this._activeAnimatables.length;n++)if(this._activeAnimatables[n].target===V)return this._activeAnimatables[n];return null},A.prototype.getAllAnimatablesByTarget=function(V){const n=[];for(let O=0;O<this._activeAnimatables.length;O++)this._activeAnimatables[O].target===V&&n.push(this._activeAnimatables[O]);return n},A.prototype.stopAnimation=function(V,n,O){const H=this.getAllAnimatablesByTarget(V);for(const g of H)g.stop(n,O)},A.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let V=0;V<this._activeAnimatables.length;V++)this._activeAnimatables[V].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const V of this.animationGroups)V.stop()});class X{getClassName(){return"TargetedAnimation"}serialize(){const V={};return V.animation=this.animation.serialize(),V.targetId=this.target.id,V}}class a{get mask(){return this._mask}set mask(V){this._mask!==V&&(this._mask=V,this.syncWithMask(!0))}syncWithMask(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||V){this._numActiveAnimatables=0;for(let V=0;V<this._animatables.length;++V){const n=this._animatables[V];!this.mask||this.mask.disabled||this.mask.retainsTarget(n.target.name)?(this._numActiveAnimatables++,n.paused&&n.restart()):n.paused||n.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let V=0;V<this._animatables.length;++V){const n=this._animatables[V];this.mask.retainsTarget(n.target.name)||(n.stop(),this._animatables.splice(V,1),--V)}for(let V=0;V<this._targetedAnimations.length;V++){const n=this._targetedAnimations[V];this.mask.retainsTarget(n.target.name)||(this._targetedAnimations.splice(V,1),--V)}}}get from(){return this._from}set from(V){if(this._from!==V){this._from=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].fromFrame=this._from}}}get to(){return this._to}set to(V){if(this._to!==V){this._to=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(V){if(this._speedRatio!==V){this._speedRatio=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(V){if(this._loopAnimation!==V){this._loopAnimation=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(V){if(this._isAdditive!==V){this._isAdditive=V;for(let V=0;V<this._animatables.length;V++){this._animatables[V].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(V){this._weight!==V&&(this._weight=V,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(V){if(this._playOrder!==V&&(this._playOrder=V,this._animatables.length>0)){for(let V=0;V<this._animatables.length;V++)this._animatables[V].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(V){if(this._enableBlending!==V&&(this._enableBlending=V,null!==V))for(let n=0;n<this._targetedAnimations.length;++n)this._targetedAnimations[n].animation.enableBlending=V}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(V){if(this._blendingSpeed!==V&&(this._blendingSpeed=V,null!==V))for(let n=0;n<this._targetedAnimations.length;++n)this._targetedAnimations[n].animation.blendingSpeed=V}getLength(V,n){V=V??this._from;return((n=n??this._to)-V)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(V){let n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],O=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=arguments.length>3?arguments[3]:void 0;if(0===V.length)return null;H=H??V[0].weight;let g=Number.MAX_VALUE,f=-Number.MAX_VALUE;if(O)for(const c of V)c.from<g&&(g=c.from),c.to>f&&(f=c.to);const x=new a(V[0].name+"_merged",V[0]._scene,H);for(const c of V){O&&c.normalize(g,f);for(const V of c.targetedAnimations)x.addTargetedAnimation(V.animation,V.target);n&&c.dispose()}return x}constructor(V){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=V,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new g.d,this.onAnimationLoopObservable=new g.d,this.onAnimationGroupLoopObservable=new g.d,this.onAnimationGroupEndObservable=new g.d,this.onAnimationGroupPauseObservable=new g.d,this.onAnimationGroupPlayObservable=new g.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=n||f.b.LastCreatedScene,this._weight=O,this._playOrder=H,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(V,n){const O=new X;O.animation=V,O.target=n;const H=V.getKeys();return this._from>H[0].frame&&(this._from=H[0].frame),this._to<H[H.length-1].frame&&(this._to=H[H.length-1].frame),null!==this._enableBlending&&(V.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(V.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(O),this._shouldStart=!0,O}removeTargetedAnimation(V){for(let n=this._targetedAnimations.length-1;n>-1;n--){this._targetedAnimations[n].animation===V&&this._targetedAnimations.splice(n,1)}}normalize(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==V&&(V=this._from),null==n&&(n=this._to);for(let O=0;O<this._targetedAnimations.length;O++){const H=this._targetedAnimations[O].animation.getKeys(),g=H[0],f=H[H.length-1];if(g.frame>V){const n={frame:V,value:g.value,inTangent:g.inTangent,outTangent:g.outTangent,interpolation:g.interpolation};H.splice(0,0,n)}if(f.frame<n){const V={frame:n,value:f.value,inTangent:f.inTangent,outTangent:f.outTangent,interpolation:f.interpolation};H.push(V)}}return this._from=V,this._to=n,this}_processLoop(V,n,O){V.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(n),this._animationLoopFlags[O]||(this._animationLoopFlags[O]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,O=arguments.length>2?arguments[2]:void 0,H=arguments.length>3?arguments[3]:void 0,g=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=V,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let f=0;f<this._targetedAnimations.length;f++){const x=this._targetedAnimations[f],c=this._scene.beginDirectAnimation(x.target,[x.animation],void 0!==O?O:this._from,void 0!==H?H:this._to,V,n,void 0,void 0,void 0!==g?g:this._isAdditive);c.weight=this._weight,c.playOrder=this._playOrder,c.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(x),this._checkAnimationGroupEnded(c)},this._processLoop(c,x,f),this._animatables.push(c)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=n,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let V=0;V<this._animatables.length;V++){this._animatables[V].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(V){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==V&&(this.loopAnimation=V),this.restart()):(this.stop(),this.start(V,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let V=0;V<this._animatables.length;V++){this._animatables[V].reset()}return this}restart(){if(!this._isStarted)return this;for(let V=0;V<this._animatables.length;V++){this._animatables[V].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const n=this._animatables.slice();for(let H=0;H<n.length;H++)n[H].stop(void 0,void 0,!0,V);let O=0;for(let H=0;H<this._scene._activeAnimatables.length;H++){const n=this._scene._activeAnimatables[H];n._runtimeAnimations.length>0?this._scene._activeAnimatables[O++]=n:V&&this._checkAnimationGroupEnded(n,V)}return this._scene._activeAnimatables.length=O,this._isStarted=!1,this}setWeightForAllAnimatables(V){for(let n=0;n<this._animatables.length;n++){this._animatables[n].weight=V}return this}syncAllAnimationsWith(V){for(let n=0;n<this._animatables.length;n++){this._animatables[n].syncWith(V)}return this}goToFrame(V){if(!this._isStarted)return this;for(let n=0;n<this._animatables.length;n++){this._animatables[n].goToFrame(V)}return this}getCurrentFrame(){var V;return(null===(V=this.animatables[0])||void 0===V?void 0:V.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const V=this._scene.animationGroups.indexOf(this);if(V>-1&&this._scene.animationGroups.splice(V,1),this._parentContainer){const V=this._parentContainer.animationGroups.indexOf(this);V>-1&&this._parentContainer.animationGroups.splice(V,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(V){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const O=this._animatables.indexOf(V);O>-1&&this._animatables.splice(O,1),0===this._animatables.length&&(this._isStarted=!1,n||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(V,n){let O=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const H=new a(V||this.name,this._scene,this._weight,this._playOrder);H._from=this.from,H._to=this.to,H._speedRatio=this.speedRatio,H._loopAnimation=this.loopAnimation,H._isAdditive=this.isAdditive,H._enableBlending=this.enableBlending,H._blendingSpeed=this.blendingSpeed,H.metadata=this.metadata,H.mask=this.mask;for(const g of this._targetedAnimations)H.addTargetedAnimation(O?g.animation.clone():g.animation,n?n(g.target):g.target);return H}serialize(){const V={};V.name=this.name,V.from=this.from,V.to=this.to,V.speedRatio=this.speedRatio,V.loopAnimation=this.loopAnimation,V.isAdditive=this.isAdditive,V.weight=this.weight,V.playOrder=this.playOrder,V.enableBlending=this.enableBlending,V.blendingSpeed=this.blendingSpeed,V.targetedAnimations=[];for(let n=0;n<this.targetedAnimations.length;n++){const O=this.targetedAnimations[n];V.targetedAnimations[n]=O.serialize()}return x.d&&x.d.HasTags(this)&&(V.tags=x.d.GetTags(this)),this.metadata&&(V.metadata=this.metadata),V}static Parse(V,n){const O=new a(V.name,n,V.weight,V.playOrder);for(let g=0;g<V.targetedAnimations.length;g++){const f=V.targetedAnimations[g],x=H.b.Parse(f.animation),c=f.targetId;if("influence"===f.animation.property){const V=n.getMorphTargetById(c);V&&O.addTargetedAnimation(x,V)}else{const V=n.getNodeById(c);null!=V&&O.addTargetedAnimation(x,V)}}return x.d&&x.d.AddTagsTo(O,V.tags),null!==V.from&&null!==V.to&&O.normalize(V.from,V.to),void 0!==V.speedRatio&&(O._speedRatio=V.speedRatio),void 0!==V.loopAnimation&&(O._loopAnimation=V.loopAnimation),void 0!==V.isAdditive&&(O._isAdditive=V.isAdditive),void 0!==V.weight&&(O._weight=V.weight),void 0!==V.playOrder&&(O._playOrder=V.playOrder),void 0!==V.enableBlending&&(O._enableBlending=V.enableBlending),void 0!==V.blendingSpeed&&(O._blendingSpeed=V.blendingSpeed),void 0!==V.metadata&&(O.metadata=V.metadata),O}static MakeAnimationAdditive(V,n,O){let g;g="object"===typeof n?n:{referenceFrame:n,range:O,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let f=V;g.cloneOriginalAnimationGroup&&(f=V.clone(g.clonedAnimationGroupName||f.name));const x=f.targetedAnimations;for(let c=0;c<x.length;c++){const V=x[c];V.animation=H.b.MakeAnimationAdditive(V.animation,g)}if(f.isAdditive=!0,g.clipKeys){let V=Number.MAX_VALUE,n=-Number.MAX_VALUE;const O=f.targetedAnimations;for(let H=0;H<O.length;H++){const g=O[H].animation.getKeys();V>g[0].frame&&(V=g[0].frame),n<g[g.length-1].frame&&(n=g[g.length-1].frame)}f._from=V,f._to=n}return f}static ClipKeys(V,n,O,H,g){const f=V.clone(H||V.name);return a.ClipKeysInPlace(f,n,O,g)}static ClipKeysInPlace(V,n,O,H){return a.ClipInPlace(V,n,O,H,!1)}static ClipFrames(V,n,O,H,g){const f=V.clone(H||V.name);return a.ClipFramesInPlace(f,n,O,g)}static ClipFramesInPlace(V,n,O,H){return a.ClipInPlace(V,n,O,H,!0)}static ClipInPlace(V,n,O,H){let g=arguments.length>4&&void 0!==arguments[4]&&arguments[4],f=Number.MAX_VALUE,x=-Number.MAX_VALUE;const c=V.targetedAnimations;for(let e=0;e<c.length;e++){const V=c[e],U=H?V.animation:V.animation.clone();g&&(U.createKeyForFrame(n),U.createKeyForFrame(O));const M=U.getKeys(),p=[];let j=Number.MAX_VALUE;for(let H=0;H<M.length;H++){const V=M[H];if(!g&&H>=n&&H<=O||g&&V.frame>=n&&V.frame<=O){const n={frame:V.frame,value:V.value.clone?V.value.clone():V.value,inTangent:V.inTangent,outTangent:V.outTangent,interpolation:V.interpolation,lockedTangent:V.lockedTangent};j===Number.MAX_VALUE&&(j=n.frame),n.frame-=j,p.push(n)}}0!==p.length?(f>p[0].frame&&(f=p[0].frame),x<p[p.length-1].frame&&(x=p[p.length-1].frame),U.setKeys(p,!0),V.animation=U):(c.splice(e,1),e--)}return V._from=f,V._to=x,V}getClassName(){return"AnimationGroup"}toString(V){let n="Name: "+this.name;return n+=", type: "+this.getClassName(),V&&(n+=", from: "+this._from,n+=", to: "+this._to,n+=", isStarted: "+this._isStarted,n+=", speedRatio: "+this._speedRatio,n+=", targetedAnimations length: "+this._targetedAnimations.length,n+=", animatables length: "+this._animatables),n}}}}]);