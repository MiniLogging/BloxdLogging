"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[80],{14188:(t,q,S)=>{S.r(q),S.d(q,{FlowGraphSetDelayBlock:()=>b});var o,B=S(12974),z=S(12927),L=S(485);!function(t){t[t.INIT=0]="INIT",t[t.STARTED=1]="STARTED",t[t.ENDED=2]="ENDED"}(o||(o={}));class r{constructor(t){this.onEachCountObservable=new L.b,this.onTimerAbortedObservable=new L.b,this.onTimerEndedObservable=new L.b,this.onStateChangedObservable=new L.b,this._observer=null,this._breakOnNextTick=!1,this._tick=t=>{const q=Date.now();this._timer=q-this._startTime;const S={startTime:this._startTime,currentTime:q,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:t},o=this._breakOnNextTick||this._breakCondition(S);o||this._timer>=this._timeToEnd?this._stop(S,o):this.onEachCountObservable.notifyObservers(S)},this._setState(0),this._contextObservable=t.contextObservable,this._observableParameters=t.observableParameters??{},this._breakCondition=t.breakCondition??(()=>!1),this._timeToEnd=t.timeout,t.onEnded&&this.onTimerEndedObservable.add(t.onEnded),t.el&&this.onEachCountObservable.add(t.el),t.onAborted&&this.onTimerAbortedObservable.add(t.onAborted)}set breakCondition(t){this._breakCondition=t}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=t,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(t){this._state=t,this.onStateChangedObservable.notifyObservers(this._state)}_stop(t){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),q?this.onTimerAbortedObservable.notifyObservers(t):this.onTimerEndedObservable.notifyObservers(t)}}var e=S(496),C=S(622),Z=S(12922);class b extends B.b{constructor(t){super(t),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",z.v),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",z.h,new Z.e(-1))}_preparePendingTasks(t){const q=this.duration.getValue(t);if(q<0||isNaN(q)||!isFinite(q))return this._reportError(t,"Invalid duration in SetDelay block");if(t._getGlobalContextVariable("activeDelays",0)>=b.MaxParallelDelayCount)return this._reportError(t,"Max parallel delays reached");const S=t._getGlobalContextVariable("lastDelayIndex",-1),o=t._getExecutionVariable(this,"pendingDelays",[]),B=t.configuration.Tk,z=new r({timeout:1e3*q,contextObservable:B.onBeforeRenderObservable,onEnded:()=>this._onEnded(z,t)});z.start();const L=S+1;this.lastDelayIndex.setValue(new Z.e(L),t),t._setGlobalContextVariable("lastDelayIndex",L),o[L]=z,t._setExecutionVariable(this,"pendingDelays",o),this._updateGlobalTimers(t)}_cancelPendingTasks(t){const q=t._getExecutionVariable(this,"pendingDelays",[]);for(const S of q)null===S||void 0===S||S.dispose();t._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new Z.e(-1),t),this._updateGlobalTimers(t)}_execute(t,q){q!==this.cancel?(this._preparePendingTasks(t),this.out._activateSignal(t)):this._cancelPendingTasks(t)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(t,q){const S=q._getExecutionVariable(this,"pendingDelays",[]),o=S.indexOf(t);-1!==o?S.splice(o,1):e.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),q._removePendingBlock(this),this.done._activateSignal(q),this._updateGlobalTimers(q)}_updateGlobalTimers(t){const q=t._getExecutionVariable(this,"pendingDelays",[]),S=t._getGlobalContextVariable("pendingDelays",[]);for(let o=0;o<q.length;o++){if(!q[o])continue;const t=q[o];S[o]&&S[o]!==t?e.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):S[o]=t}t._setGlobalContextVariable("pendingDelays",S)}}b.MaxParallelDelayCount=100,(0,C.c)("FlowGraphSetDelayBlock",b)}}]);