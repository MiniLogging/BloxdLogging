"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[80],{14505:(R,x,H)=>{H.r(x),H.d(x,{FlowGraphSetDelayBlock:()=>n});var k,c=H(13299),t=H(13246),A=H(476);!function(R){R[R.INIT=0]="INIT",R[R.STARTED=1]="STARTED",R[R.ENDED=2]="ENDED"}(k||(k={}));class D{constructor(R){this.onEachCountObservable=new A.d,this.onTimerAbortedObservable=new A.d,this.onTimerEndedObservable=new A.d,this.onStateChangedObservable=new A.d,this._observer=null,this._breakOnNextTick=!1,this._tick=R=>{const x=Date.now();this._timer=x-this._startTime;const H={startTime:this._startTime,currentTime:x,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:R},k=this._breakOnNextTick||this._breakCondition(H);k||this._timer>=this._timeToEnd?this._stop(H,k):this.onEachCountObservable.notifyObservers(H)},this._setState(0),this._contextObservable=R.contextObservable,this._observableParameters=R.observableParameters??{},this._breakCondition=R.breakCondition??(()=>!1),this._timeToEnd=R.timeout,R.onEnded&&this.onTimerEndedObservable.add(R.onEnded),R.dl&&this.onEachCountObservable.add(R.dl),R.onAborted&&this.onTimerAbortedObservable.add(R.onAborted)}set breakCondition(R){this._breakCondition=R}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=R,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(R){this._state=R,this.onStateChangedObservable.notifyObservers(this._state)}_stop(R){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),x?this.onTimerAbortedObservable.notifyObservers(R):this.onTimerEndedObservable.notifyObservers(R)}}var U=H(493),J=H(610),V=H(13244);class n extends c.b{constructor(R){super(R),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",t.m),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",t.d,new V.e(-1))}_preparePendingTasks(R){const x=this.duration.getValue(R);if(x<0||isNaN(x)||!isFinite(x))return this._reportError(R,"Invalid duration in SetDelay block");if(R._getGlobalContextVariable("activeDelays",0)>=n.MaxParallelDelayCount)return this._reportError(R,"Max parallel delays reached");const H=R._getGlobalContextVariable("lastDelayIndex",-1),k=R._getExecutionVariable(this,"pendingDelays",[]),c=R.configuration.Yk,t=new D({timeout:1e3*x,contextObservable:c.onBeforeRenderObservable,onEnded:()=>this._onEnded(t,R)});t.start();const A=H+1;this.lastDelayIndex.setValue(new V.e(A),R),R._setGlobalContextVariable("lastDelayIndex",A),k[A]=t,R._setExecutionVariable(this,"pendingDelays",k),this._updateGlobalTimers(R)}_cancelPendingTasks(R){const x=R._getExecutionVariable(this,"pendingDelays",[]);for(const H of x)null===H||void 0===H||H.dispose();R._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new V.e(-1),R),this._updateGlobalTimers(R)}_execute(R,x){x!==this.cancel?(this._preparePendingTasks(R),this.out._activateSignal(R)):this._cancelPendingTasks(R)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(R,x){const H=x._getExecutionVariable(this,"pendingDelays",[]),k=H.indexOf(R);-1!==k?H.splice(k,1):U.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),x._removePendingBlock(this),this.done._activateSignal(x),this._updateGlobalTimers(x)}_updateGlobalTimers(R){const x=R._getExecutionVariable(this,"pendingDelays",[]),H=R._getGlobalContextVariable("pendingDelays",[]);for(let k=0;k<x.length;k++){if(!x[k])continue;const R=x[k];H[k]&&H[k]!==R?U.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):H[k]=R}R._setGlobalContextVariable("pendingDelays",H)}}n.MaxParallelDelayCount=100,(0,J.h)("FlowGraphSetDelayBlock",n)}}]);