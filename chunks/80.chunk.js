"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[80],{14359:(P,f,Y)=>{Y.r(f),Y.d(f,{FlowGraphStopAnimationBlock:()=>o});var C=Y(12917),q=Y(11134),m=Y(11025),L=Y(12970);class o extends L.c{constructor(P){super(P),this.animationGroup=this.registerDataInput("animationGroup",C.d),this.stopAtFrame=this.registerDataInput("stopAtFrame",C.o,-1)}_preparePendingTasks(P){const f=this.animationGroup.getValue(P),Y=this.stopAtFrame.getValue(P)??-1,C=P._getGlobalContextVariable("pendingStopAnimations",[]);C.push({uniqueId:f.uniqueId,stopAtFrame:Y}),P._setGlobalContextVariable("pendingStopAnimations",C)}_cancelPendingTasks(P){const f=this.animationGroup.getValue(P),Y=P._getGlobalContextVariable("pendingStopAnimations",[]);for(let C=0;C<Y.length;C++)if(Y[C].uniqueId===f.uniqueId){Y.splice(C,1),P._setGlobalContextVariable("pendingStopAnimations",Y);break}}_execute(P){const f=this.animationGroup.getValue(P),Y=this.stopAtFrame.getValue(P)??-1;return f?isNaN(Y)?this._reportError(P,"Invalid stop time."):(Y>0?this._startPendingTasks(P):this._stopAnimation(f,P),void this.out._activateSignal(P)):(m.e.Warn("No animation group provided to stop."),this._reportError(P,"No animation group provided to stop."))}_executeOnTick(P){const f=this.animationGroup.getValue(P),Y=P._getGlobalContextVariable("pendingStopAnimations",[]);for(let C=0;C<Y.length;C++)if(Y[C].uniqueId===f.uniqueId&&f.getCurrentFrame()>=Y[C].stopAtFrame){this._stopAnimation(f,P),Y.splice(C,1),P._setGlobalContextVariable("pendingStopAnimations",Y),this.done._activateSignal(P),P._removePendingBlock(this);break}}getClassName(){return"FlowGraphStopAnimationBlock"}_stopAnimation(P,f){const Y=f._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),C=Y.indexOf(P.uniqueId);-1!==C&&(P.stop(),Y.splice(C,1),f._setGlobalContextVariable("currentlyRunningAnimationGroups",Y))}}(0,q.d)("FlowGraphStopAnimationBlock",o)}}]);