"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[80],{14238:(v,d,Q)=>{Q.r(d),Q.d(d,{FlowGraphSetDelayBlock:()=>y});var n,T=Q(12962),L=Q(12908),e=Q(473);!function(v){v[v.INIT=0]="INIT",v[v.STARTED=1]="STARTED",v[v.ENDED=2]="ENDED"}(n||(n={}));class F{constructor(v){this.onEachCountObservable=new e.e,this.onTimerAbortedObservable=new e.e,this.onTimerEndedObservable=new e.e,this.onStateChangedObservable=new e.e,this._observer=null,this._breakOnNextTick=!1,this._tick=v=>{const d=Date.now();this._timer=d-this._startTime;const Q={startTime:this._startTime,currentTime:d,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:v},n=this._breakOnNextTick||this._breakCondition(Q);n||this._timer>=this._timeToEnd?this._stop(Q,n):this.onEachCountObservable.notifyObservers(Q)},this._setState(0),this._contextObservable=v.contextObservable,this._observableParameters=v.observableParameters??{},this._breakCondition=v.breakCondition??(()=>!1),this._timeToEnd=v.timeout,v.onEnded&&this.onTimerEndedObservable.add(v.onEnded),v.bl&&this.onEachCountObservable.add(v.bl),v.onAborted&&this.onTimerAbortedObservable.add(v.onAborted)}set breakCondition(v){this._breakCondition=v}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let v=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=v,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(v){this._state=v,this.onStateChangedObservable.notifyObservers(this._state)}_stop(v){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),d?this.onTimerAbortedObservable.notifyObservers(v):this.onTimerEndedObservable.notifyObservers(v)}}var r=Q(482),C=Q(591),u=Q(12904);class y extends T.b{constructor(v){super(v),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",L.u),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",L.h,new u.b(-1))}_preparePendingTasks(v){const d=this.duration.getValue(v);if(d<0||isNaN(d)||!isFinite(d))return this._reportError(v,"Invalid duration in SetDelay block");if(v._getGlobalContextVariable("activeDelays",0)>=y.MaxParallelDelayCount)return this._reportError(v,"Max parallel delays reached");const Q=v._getGlobalContextVariable("lastDelayIndex",-1),n=v._getExecutionVariable(this,"pendingDelays",[]),T=v.configuration.yd,L=new F({timeout:1e3*d,contextObservable:T.onBeforeRenderObservable,onEnded:()=>this._onEnded(L,v)});L.start();const e=Q+1;this.lastDelayIndex.setValue(new u.b(e),v),v._setGlobalContextVariable("lastDelayIndex",e),n[e]=L,v._setExecutionVariable(this,"pendingDelays",n),this._updateGlobalTimers(v)}_cancelPendingTasks(v){const d=v._getExecutionVariable(this,"pendingDelays",[]);for(const Q of d)null===Q||void 0===Q||Q.dispose();v._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new u.b(-1),v),this._updateGlobalTimers(v)}_execute(v,d){d!==this.cancel?(this._preparePendingTasks(v),this.out._activateSignal(v)):this._cancelPendingTasks(v)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(v,d){const Q=d._getExecutionVariable(this,"pendingDelays",[]),n=Q.indexOf(v);-1!==n?Q.splice(n,1):r.d.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),d._removePendingBlock(this),this.done._activateSignal(d),this._updateGlobalTimers(d)}_updateGlobalTimers(v){const d=v._getExecutionVariable(this,"pendingDelays",[]),Q=v._getGlobalContextVariable("pendingDelays",[]);for(let n=0;n<d.length;n++){if(!d[n])continue;const v=d[n];Q[n]&&Q[n]!==v?r.d.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):Q[n]=v}v._setGlobalContextVariable("pendingDelays",Q)}}y.MaxParallelDelayCount=100,(0,C.f)("FlowGraphSetDelayBlock",y)}}]);