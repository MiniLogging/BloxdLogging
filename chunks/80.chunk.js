"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[80],{14352:(Q,X,C)=>{C.r(X),C.d(X,{FlowGraphSetDelayBlock:()=>L});var l,h=C(13111),M=C(13063),f=C(482);!function(Q){Q[Q.INIT=0]="INIT",Q[Q.STARTED=1]="STARTED",Q[Q.ENDED=2]="ENDED"}(l||(l={}));class O{constructor(Q){this.onEachCountObservable=new f.e,this.onTimerAbortedObservable=new f.e,this.onTimerEndedObservable=new f.e,this.onStateChangedObservable=new f.e,this._observer=null,this._breakOnNextTick=!1,this._tick=Q=>{const X=Date.now();this._timer=X-this._startTime;const C={startTime:this._startTime,currentTime:X,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:Q},l=this._breakOnNextTick||this._breakCondition(C);l||this._timer>=this._timeToEnd?this._stop(C,l):this.onEachCountObservable.notifyObservers(C)},this._setState(0),this._contextObservable=Q.contextObservable,this._observableParameters=Q.observableParameters??{},this._breakCondition=Q.breakCondition??(()=>!1),this._timeToEnd=Q.timeout,Q.onEnded&&this.onTimerEndedObservable.add(Q.onEnded),Q.Vk&&this.onEachCountObservable.add(Q.Vk),Q.onAborted&&this.onTimerAbortedObservable.add(Q.onAborted)}set breakCondition(Q){this._breakCondition=Q}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let Q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=Q,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(Q){this._state=Q,this.onStateChangedObservable.notifyObservers(this._state)}_stop(Q){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),X?this.onTimerAbortedObservable.notifyObservers(Q):this.onTimerEndedObservable.notifyObservers(Q)}}var m=C(501),W=C(620),U=C(13060);class L extends h.c{constructor(Q){super(Q),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",M.p),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",M.f,new U.d(-1))}_preparePendingTasks(Q){const X=this.duration.getValue(Q);if(X<0||isNaN(X)||!isFinite(X))return this._reportError(Q,"Invalid duration in SetDelay block");if(Q._getGlobalContextVariable("activeDelays",0)>=L.MaxParallelDelayCount)return this._reportError(Q,"Max parallel delays reached");const C=Q._getGlobalContextVariable("lastDelayIndex",-1),l=Q._getExecutionVariable(this,"pendingDelays",[]),h=Q.configuration.ld,M=new O({timeout:1e3*X,contextObservable:h.onBeforeRenderObservable,onEnded:()=>this._onEnded(M,Q)});M.start();const f=C+1;this.lastDelayIndex.setValue(new U.d(f),Q),Q._setGlobalContextVariable("lastDelayIndex",f),l[f]=M,Q._setExecutionVariable(this,"pendingDelays",l),this._updateGlobalTimers(Q)}_cancelPendingTasks(Q){const X=Q._getExecutionVariable(this,"pendingDelays",[]);for(const C of X)null===C||void 0===C||C.dispose();Q._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new U.d(-1),Q),this._updateGlobalTimers(Q)}_execute(Q,X){X!==this.cancel?(this._preparePendingTasks(Q),this.out._activateSignal(Q)):this._cancelPendingTasks(Q)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(Q,X){const C=X._getExecutionVariable(this,"pendingDelays",[]),l=C.indexOf(Q);-1!==l?C.splice(l,1):m.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),X._removePendingBlock(this),this.done._activateSignal(X),this._updateGlobalTimers(X)}_updateGlobalTimers(Q){const X=Q._getExecutionVariable(this,"pendingDelays",[]),C=Q._getGlobalContextVariable("pendingDelays",[]);for(let l=0;l<X.length;l++){if(!X[l])continue;const Q=X[l];C[l]&&C[l]!==Q?m.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):C[l]=Q}Q._setGlobalContextVariable("pendingDelays",C)}}L.MaxParallelDelayCount=100,(0,W.g)("FlowGraphSetDelayBlock",L)}}]);