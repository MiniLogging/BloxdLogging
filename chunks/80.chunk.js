"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[80],{14350:(B,I,C)=>{C.r(I),C.d(I,{FlowGraphStopAnimationBlock:()=>L});var M=C(12901),x=C(11149),y=C(11027),f=C(12950);class L extends f.b{constructor(B){super(B),this.animationGroup=this.registerDataInput("animationGroup",M.b),this.stopAtFrame=this.registerDataInput("stopAtFrame",M.m,-1)}_preparePendingTasks(B){const I=this.animationGroup.getValue(B),C=this.stopAtFrame.getValue(B)??-1,M=B._getGlobalContextVariable("pendingStopAnimations",[]);M.push({uniqueId:I.uniqueId,stopAtFrame:C}),B._setGlobalContextVariable("pendingStopAnimations",M)}_cancelPendingTasks(B){const I=this.animationGroup.getValue(B),C=B._getGlobalContextVariable("pendingStopAnimations",[]);for(let M=0;M<C.length;M++)if(C[M].uniqueId===I.uniqueId){C.splice(M,1),B._setGlobalContextVariable("pendingStopAnimations",C);break}}_execute(B){const I=this.animationGroup.getValue(B),C=this.stopAtFrame.getValue(B)??-1;return I?isNaN(C)?this._reportError(B,"Invalid stop time."):(C>0?this._startPendingTasks(B):this._stopAnimation(I,B),void this.out._activateSignal(B)):(y.b.Warn("No animation group provided to stop."),this._reportError(B,"No animation group provided to stop."))}_executeOnTick(B){const I=this.animationGroup.getValue(B),C=B._getGlobalContextVariable("pendingStopAnimations",[]);for(let M=0;M<C.length;M++)if(C[M].uniqueId===I.uniqueId&&I.getCurrentFrame()>=C[M].stopAtFrame){this._stopAnimation(I,B),C.splice(M,1),B._setGlobalContextVariable("pendingStopAnimations",C),this.done._activateSignal(B),B._removePendingBlock(this);break}}getClassName(){return"FlowGraphStopAnimationBlock"}_stopAnimation(B,I){const C=I._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),M=C.indexOf(B.uniqueId);-1!==M&&(B.stop(),C.splice(M,1),I._setGlobalContextVariable("currentlyRunningAnimationGroups",C))}}(0,x.h)("FlowGraphStopAnimationBlock",L)}}]);