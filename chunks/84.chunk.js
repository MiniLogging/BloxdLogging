"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[84],{14433:(Z,c,L)=>{L.r(c),L.d(c,{FlowGraphMultiGateBlock:()=>V});var k=L(11012),N=L(12839),R=L(12825),G=L(12817);class V extends N.b{constructor(Z){super(Z),this.config=Z,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",R.i,new G.b(-1)),this.setNumberOfOutputSignals(null===Z||void 0===Z?void 0:Z.outputSignalCount)}_getNextIndex(Z){if(Z.includes(!1)||this.config.isLoop&&Z.fill(!1),this.config.isRandom){const c=Z.map(((Z,c)=>Z?-1:c)).filter((Z=>-1!==Z));return c.length?c[Math.floor(Math.random()*c.length)]:-1}return Z.indexOf(!1)}setNumberOfOutputSignals(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>Z;){const Z=this.outputSignals.pop();Z&&(Z.disconnectFromAll(),this._unregisterSignalOutput(Z.name))}for(;this.outputSignals.length<Z;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(Z,c){if(Z._hasExecutionVariable(this,"indexesUsed")||Z._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),c===this.reset)return Z._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new G.b(-1),Z);const L=Z._getExecutionVariable(this,"indexesUsed",[]),k=this._getNextIndex(L);k>-1&&(this.lastIndex.setValue(new G.b(k),Z),L[k]=!0,Z._setExecutionVariable(this,"indexesUsed",L),this.outputSignals[k]._activateSignal(Z))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(Z){super.serialize(Z),Z.config.outputSignalCount=this.config.outputSignalCount,Z.config.isRandom=this.config.isRandom,Z.config.loop=this.config.isLoop,Z.config.startIndex=this.config.startIndex}}(0,k.g)("FlowGraphMultiGateBlock",V)}}]);