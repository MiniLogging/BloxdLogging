"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[84],{14473:(w,p,e)=>{e.r(p),e.d(p,{FlowGraphMultiGateBlock:()=>q});var r=e(11038),I=e(12891),d=e(12872),f=e(12867);class q extends I.b{constructor(w){super(w),this.config=w,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",d.h,new f.b(-1)),this.setNumberOfOutputSignals(null===w||void 0===w?void 0:w.outputSignalCount)}_getNextIndex(w){if(w.includes(!1)||this.config.isLoop&&w.fill(!1),this.config.isRandom){const p=w.map(((w,p)=>w?-1:p)).filter((w=>-1!==w));return p.length?p[Math.floor(Math.random()*p.length)]:-1}return w.indexOf(!1)}setNumberOfOutputSignals(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>w;){const w=this.outputSignals.pop();w&&(w.disconnectFromAll(),this._unregisterSignalOutput(w.name))}for(;this.outputSignals.length<w;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(w,p){if(w._hasExecutionVariable(this,"indexesUsed")||w._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),p===this.reset)return w._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new f.b(-1),w);const e=w._getExecutionVariable(this,"indexesUsed",[]),r=this._getNextIndex(e);r>-1&&(this.lastIndex.setValue(new f.b(r),w),e[r]=!0,w._setExecutionVariable(this,"indexesUsed",e),this.outputSignals[r]._activateSignal(w))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(w){super.serialize(w),w.config.outputSignalCount=this.config.outputSignalCount,w.config.isRandom=this.config.isRandom,w.config.loop=this.config.isLoop,w.config.startIndex=this.config.startIndex}}(0,r.d)("FlowGraphMultiGateBlock",q)}}]);