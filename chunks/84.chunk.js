"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[84],{14609:(G,V,W)=>{W.r(V),W.d(V,{FlowGraphMultiGateBlock:()=>z});var J=W(11159),R=W(13084),d=W(13071),k=W(13067);class z extends R.b{constructor(G){super(G),this.config=G,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",d.h,new k.e(-1)),this.setNumberOfOutputSignals(null===G||void 0===G?void 0:G.outputSignalCount)}_getNextIndex(G){if(G.includes(!1)||this.config.isLoop&&G.fill(!1),this.config.isRandom){const V=G.map(((G,V)=>G?-1:V)).filter((G=>-1!==G));return V.length?V[Math.floor(Math.random()*V.length)]:-1}return G.indexOf(!1)}setNumberOfOutputSignals(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>G;){const G=this.outputSignals.pop();G&&(G.disconnectFromAll(),this._unregisterSignalOutput(G.name))}for(;this.outputSignals.length<G;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(G,V){if(G._hasExecutionVariable(this,"indexesUsed")||G._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),V===this.reset)return G._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new k.e(-1),G);const W=G._getExecutionVariable(this,"indexesUsed",[]),J=this._getNextIndex(W);J>-1&&(this.lastIndex.setValue(new k.e(J),G),W[J]=!0,G._setExecutionVariable(this,"indexesUsed",W),this.outputSignals[J]._activateSignal(G))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(G){super.serialize(G),G.config.outputSignalCount=this.config.outputSignalCount,G.config.isRandom=this.config.isRandom,G.config.loop=this.config.isLoop,G.config.startIndex=this.config.startIndex}}(0,J.d)("FlowGraphMultiGateBlock",z)}}]);