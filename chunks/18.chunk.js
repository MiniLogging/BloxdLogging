"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12590:(u,G,s)=>{s.r(G),s.d(G,{_ExrTextureLoader:()=>a});var T=s(10584),z=s(10924);const O=65536,m=14,f=65537,C=16384;var x,g;!function(u){u[u.NO_COMPRESSION=0]="NO_COMPRESSION",u[u.RLE_COMPRESSION=1]="RLE_COMPRESSION",u[u.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",u[u.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",u[u.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",u[u.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(x||(x={})),function(u){u[u.INCREASING_Y=0]="INCREASING_Y",u[u.DECREASING_Y=1]="DECREASING_Y"}(g||(g={}));const b=function(){const u=new ArrayBuffer(4),G=new Float32Array(u),s=new Uint32Array(u),T=new Uint32Array(512),z=new Uint32Array(512);for(let C=0;C<256;++C){const u=C-127;u<-27?(T[C]=0,T[256|C]=32768,z[C]=24,z[256|C]=24):u<-14?(T[C]=1024>>-u-14,T[256|C]=1024>>-u-14|32768,z[C]=-u-1,z[256|C]=-u-1):u<=15?(T[C]=u+15<<10,T[256|C]=u+15<<10|32768,z[C]=13,z[256|C]=13):u<128?(T[C]=31744,T[256|C]=64512,z[C]=24,z[256|C]=24):(T[C]=31744,T[256|C]=64512,z[C]=13,z[256|C]=13)}const O=new Uint32Array(2048),m=new Uint32Array(64),f=new Uint32Array(64);for(let C=1;C<1024;++C){let u=C<<13,G=0;for(;0===(8388608&u);)u<<=1,G-=8388608;u&=-8388609,G+=947912704,O[C]=u|G}for(let C=1024;C<2048;++C)O[C]=939524096+(C-1024<<13);for(let C=1;C<31;++C)m[C]=C<<23;m[31]=1199570944,m[32]=2147483648;for(let C=33;C<63;++C)m[C]=2147483648+(C-32<<23);m[63]=3347054592;for(let C=1;C<64;++C)32!==C&&(f[C]=1024);return{floatView:G,uint32View:s,baseTable:T,shiftTable:z,mantissaTable:O,exponentTable:m,offsetTable:f}}();function Q(u,G){const s=new Uint8Array(u);let T=0;for(;0!=s[G.value+T];)T+=1;const z=(new TextDecoder).decode(s.slice(G.value,G.value+T));return G.value=G.value+T+1,z}function Y(u,G){const s=u.getInt32(G.value,!0);return G.value+=4,s}function n(u,G){const s=u.getUint32(G.value,!0);return G.value+=4,s}function V(u,G){const s=u.getUint8(G.value);return G.value+=1,s}function F(u,G){const s=u.getUint16(G.value,!0);return G.value+=2,s}function r(u,G){const s=u[G.value];return G.value+=1,s}function c(u,G){let s;return s="getBigInt64"in DataView.prototype?Number(u.getBigInt64(G.value,!0)):u.getUint32(G.value+4,!0)+Number(u.getUint32(G.value,!0)<<32),G.value+=8,s}function j(u,G){const s=u.getFloat32(G.value,!0);return G.value+=4,s}function l(u,G){return function(u){const G=(31744&u)>>10,s=1023&u;return(u>>15?-1:1)*(G?31===G?s?NaN:1/0:Math.pow(2,G-15)*(1+s/1024):s/1024*6103515625e-14)}(F(u,G))}function P(u,G){return function(u){if(Math.abs(u)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");u=(0,z.b)(u,-65504,65504),b.floatView[0]=u;const G=b.uint32View[0],s=G>>23&511;return b.baseTable[s]+((8388607&G)>>b.shiftTable[s])}(j(u,G))}function H(u,G,s,T){switch(s){case"string":case"stringvector":case"iccProfile":return function(u,G,s){const T=(new TextDecoder).decode(new Uint8Array(u).slice(G.value,G.value+s));return G.value=G.value+s,T}(u.buffer,G,T);case"chlist":return function(u,G,s){const T=G.value,z=[];for(;G.value<T+s-1;){const s=Q(u.buffer,G),T=Y(u,G),O=V(u,G);G.value+=3;const m=Y(u,G),f=Y(u,G);z.push({name:s,pixelType:T,pLinear:O,xSampling:m,ySampling:f})}return G.value+=1,z}(u,G,T);case"chromaticities":return function(u,G){return{redX:j(u,G),redY:j(u,G),greenX:j(u,G),greenY:j(u,G),blueX:j(u,G),blueY:j(u,G),whiteX:j(u,G),whiteY:j(u,G)}}(u,G);case"compression":return function(u,G){return V(u,G)}(u,G);case"box2i":return function(u,G){return{xMin:Y(u,G),yMin:Y(u,G),xMax:Y(u,G),yMax:Y(u,G)}}(u,G);case"lineOrder":return function(u,G){const s=V(u,G);return g[s]}(u,G);case"float":return j(u,G);case"v2f":return function(u,G){return[j(u,G),j(u,G)]}(u,G);case"v3f":return function(u,G){return[j(u,G),j(u,G),j(u,G)]}(u,G);case"int":return Y(u,G);case"rational":return function(u,G){return[Y(u,G),n(u,G)]}(u,G);case"timecode":return function(u,G){return[n(u,G),n(u,G)]}(u,G);case"preview":return G.value+=T,"skipped";default:return void(G.value+=T)}}function X(u){for(let G=1;G<u.length;G++){const s=u[G-1]+u[G]-128;u[G]=s}}function p(u,G){let s=0,T=Math.floor((u.length+1)/2),z=0;const O=u.length-1;for(;!(z>O)&&(G[z++]=u[s++],!(z>O));)G[z++]=u[T++]}function q(u,G,s,T,z){for(;s<u;)G=G<<8|r(T,z),s+=8;return{l:G>>(s-=u)&(1<<u)-1,c:G,lc:s}}function d(u,G,s,T){return{c:u=u<<8|r(s,T),lc:G+=8}}function v(u,G,s,T,z,O,m,f,C){if(u==G){if(T<8){const u=d(s,T,z,O);s=u.c,T=u.lc}let u=s>>(T-=8);if(u=new Uint8Array([u])[0],f.value+u>C)return null;const G=m[f.value-1];for(;u-- >0;)m[f.value++]=G}else{if(!(f.value<C))return null;m[f.value++]=u}return{c:s,lc:T}}const W=new Array(59);function M(u,G,s,T,z,O){const m=G;let C=0,x=0;for(;T<=z;T++){if(m.value-G.value>s)return;let f=q(6,C,x,u,m);const g=f.l;if(C=f.c,x=f.lc,O[T]=g,63==g){if(m.value-G.value>s)throw new Error("Error in HufUnpackEncTable");f=q(8,C,x,u,m);let g=f.l+6;if(C=f.c,x=f.lc,T+g>z+1)throw new Error("Error in HufUnpackEncTable");for(;g--;)O[T++]=0;T--}else if(g>=59){let u=g-59+2;if(T+u>z+1)throw new Error("Error in HufUnpackEncTable");for(;u--;)O[T++]=0;T--}}!function(u){for(let s=0;s<=58;++s)W[s]=0;for(let s=0;s<f;++s)W[u[s]]+=1;let G=0;for(let s=58;s>0;--s){const u=G+W[s]>>1;W[s]=G,G=u}for(let s=0;s<f;++s){const G=u[s];G>0&&(u[s]=G|W[G]++<<6)}}(O)}function o(u){return 63&u}function R(u){return u>>6}function B(u,G,s,T,z,O){const x=s.value,g=n(G,s),b=n(G,s);s.value+=4;const Q=n(G,s);if(s.value+=4,g<0||g>=f||b<0||b>=f)throw new Error("Wrong HUF_ENCSIZE");const Y=new Array(f),V=new Array(C);!function(u){for(let G=0;G<C;G++)u[G]={},u[G].len=0,u[G].lit=0,u[G].p=null}(V);if(M(u,s,T-(s.value-x),g,b,Y),Q>8*(T-(s.value-x)))throw new Error("Wrong hufUncompress");!function(u,G,s,T){for(;G<=s;G++){const s=R(u[G]),z=o(u[G]);if(s>>z)throw new Error("Invalid table entry");if(z>m){const u=T[s>>z-m];if(u.len)throw new Error("Invalid table entry");if(u.lit++,u.p){const G=u.p;u.p=new Array(u.lit);for(let s=0;s<u.lit-1;++s)u.p[s]=G[s]}else u.p=new Array(1);u.p[u.lit-1]=G}else if(z){let u=0;for(let O=1<<m-z;O>0;O--){const O=T[(s<<m-z)+u];if(O.len||O.p)throw new Error("Invalid table entry");O.len=z,O.lit=G,u++}}}}(Y,g,b,V),function(u,G,s,T,z,O,f,C,x){let g=0,b=0;const Q=f,Y=Math.trunc(T.value+(z+7)/8);for(;T.value<Y;){let z=d(g,b,s,T);for(g=z.c,b=z.lc;b>=m;){const f=G[g>>b-m&16383];if(f.len){b-=f.len;const u=v(f.lit,O,g,b,s,T,C,x,Q);u&&(g=u.c,b=u.lc)}else{if(!f.p)throw new Error("hufDecode issues");let G;for(G=0;G<f.lit;G++){const m=o(u[f.p[G]]);for(;b<m&&T.value<Y;)z=d(g,b,s,T),g=z.c,b=z.lc;if(b>=m&&R(u[f.p[G]])==(g>>b-m&(1<<m)-1)){b-=m;const u=v(f.p[G],O,g,b,s,T,C,x,Q);u&&(g=u.c,b=u.lc);break}}if(G==f.lit)throw new Error("HufDecode issues")}}}const n=8-z&7;for(g>>=n,b-=n;b>0;){const u=G[g<<m-b&16383];if(!u.len)throw new Error("HufDecode issues");{b-=u.len;const G=v(u.lit,O,g,b,s,T,C,x,Q);G&&(g=G.c,b=G.lc)}}}(Y,V,u,s,Q,b,O,z,{value:0})}function D(u){return 65535&u}function k(u){const G=D(u);return G>32767?G-65536:G}function w(u,G){const s=k(u),T=k(G),z=s+(1&T)+(T>>1);return{a:z,b:z-T}}function L(u,G){const s=D(u),T=D(G),z=s-(T>>1)&65535;return{a:T+z-32768&65535,b:z}}function S(u,G,s,T,z,O,m){const f=m<16384,C=s>z?z:s;let x,g,b=1;for(;b<=C;)b<<=1;for(b>>=1,x=b,b>>=1;b>=1;){g=0;const m=g+O*(z-x),C=O*b,Q=O*x,Y=T*b,n=T*x;let V,F,r,c;for(;g<=m;g+=Q){let z=g;const O=g+T*(s-x);for(;z<=O;z+=n){const s=z+Y,T=z+C,O=T+Y;if(f){let m=w(u[z+G],u[T+G]);V=m.a,r=m.b,m=w(u[s+G],u[O+G]),F=m.a,c=m.b,m=w(V,F),u[z+G]=m.a,u[s+G]=m.b,m=w(r,c),u[T+G]=m.a,u[O+G]=m.b}else{let m=L(u[z+G],u[T+G]);V=m.a,r=m.b,m=L(u[s+G],u[O+G]),F=m.a,c=m.b,m=L(V,F),u[z+G]=m.a,u[s+G]=m.b,m=L(r,c),u[T+G]=m.a,u[O+G]=m.b}}if(s&b){const s=z+C;let T;T=f?w(u[z+G],u[s+G]):L(u[z+G],u[s+G]),V=T.a,u[s+G]=T.b,u[z+G]=V}}if(z&b){let z=g;const O=g+T*(s-x);for(;z<=O;z+=n){const s=z+Y;let T;T=f?w(u[z+G],u[s+G]):L(u[z+G],u[s+G]),V=T.a,u[s+G]=T.b,u[z+G]=V}}x=b,b>>=1}return g}function e(u){return new DataView(u.array.buffer,u.offset.value,u.size)}function h(u){const G=u.viewer.buffer.slice(u.offset.value,u.offset.value+u.size),s=new Uint8Array(function(u){let G=u.byteLength;const s=new Array;let T=0;const z=new DataView(u);for(;G>0;){const u=z.getInt8(T++);if(u<0){const O=-u;G-=O+1;for(let u=0;u<O;u++)s.push(z.getUint8(T++))}else{const O=u;G-=2;const m=z.getUint8(T++);for(let u=0;u<O+1;u++)s.push(m)}}return s}(G)),T=new Uint8Array(s.length);return X(s),p(s,T),new DataView(T.buffer)}function I(u){const G=u.array.slice(u.offset.value,u.offset.value+u.size),s=fflate.unzlibSync(G),T=new Uint8Array(s.length);return X(s),p(s,T),new DataView(T.buffer)}function i(u){const G=u.array.slice(u.offset.value,u.offset.value+u.size),s=fflate.unzlibSync(G),T=u.lines*u.channels*u.width,z=1==u.type?new Uint16Array(T):new Uint32Array(T);let O=0,m=0;const f=new Array(4);for(let C=0;C<u.lines;C++)for(let G=0;G<u.channels;G++){let G=0;switch(u.type){case 1:f[0]=O,f[1]=f[0]+u.width,O=f[1]+u.width;for(let T=0;T<u.width;++T){G+=s[f[0]++]<<8|s[f[1]++],z[m]=G,m++}break;case 2:f[0]=O,f[1]=f[0]+u.width,f[2]=f[1]+u.width,O=f[2]+u.width;for(let T=0;T<u.width;++T){G+=s[f[0]++]<<24|s[f[1]++]<<16|s[f[2]++]<<8,z[m]=G,m++}}}return new DataView(z.buffer)}function J(u){const G=u.viewer,s={value:u.offset.value},T=new Uint16Array(u.width*u.scanlineBlockSize*(u.channels*u.type)),z=new Uint8Array(8192);let m=0;const f=new Array(u.channels);for(let O=0;O<u.channels;O++)f[O]={},f[O].start=m,f[O].end=f[O].start,f[O].nx=u.width,f[O].ny=u.lines,f[O].size=u.type,m+=f[O].nx*f[O].ny*f[O].size;const C=F(G,s),x=F(G,s);if(x>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(C<=x)for(let O=0;O<x-C+1;O++)z[O+C]=V(G,s);const g=new Uint16Array(O),b=function(u,G){let s=0;for(let z=0;z<O;++z)(0==z||u[z>>3]&1<<(7&z))&&(G[s++]=z);const T=s-1;for(;s<O;)G[s++]=0;return T}(z,g),Q=n(G,s);B(u.array,G,s,Q,T,m);for(let O=0;O<u.channels;++O){const u=f[O];for(let G=0;G<f[O].size;++G)S(T,u.start+G,u.nx,u.size,u.ny,u.nx*u.size,b)}!function(u,G,s){for(let T=0;T<s;++T)G[T]=u[G[T]]}(g,T,m);let Y=0;const r=new Uint8Array(T.buffer.byteLength);for(let O=0;O<u.lines;O++)for(let G=0;G<u.channels;G++){const u=f[G],s=u.nx*u.size,z=new Uint8Array(T.buffer,2*u.end,2*s);r.set(z,Y),Y+=2*s,u.end+=s}return new DataView(r.buffer)}var A,N=s(10564);!function(u){u[u.Float=0]="Float",u[u.HalfFloat=1]="HalfFloat"}(A||(A={}));class y{}y.DefaultOutputType=A.HalfFloat,y.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class a{constructor(){this.supportCascades=!1}loadCubeData(u,G,s,T,z){throw".exr not supported in Cube."}async loadData(u,G,s){const z=new DataView(u.buffer),O={value:0},m=function(u,G){if(20000630!=u.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const s=u.getUint8(4),z=u.getUint8(5),O={singleTile:!!(2&z),longName:!!(4&z),deepFormat:!!(8&z),multiPart:!!(16&z)};G.value=8;const m={};let f=!0;for(;f;){const s=Q(u.buffer,G);if(s){const z=Q(u.buffer,G),O=H(u,G,z,n(u,G));void 0===O?T.d.Warn(`Unknown header attribute type ${z}'.`):m[s]=O}else f=!1}if(0!=(-5&z))throw new Error("Unsupported file format");return{version:s,spec:O,...m}}(z,O),f=await async function(u,G,s,T){const z={size:0,viewer:G,array:new Uint8Array(G.buffer),offset:s,width:u.dataWindow.xMax-u.dataWindow.xMin+1,height:u.dataWindow.yMax-u.dataWindow.yMin+1,channels:u.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(u.compression){case x.NO_COMPRESSION:z.lines=1,z.uncompress=e;break;case x.RLE_COMPRESSION:z.lines=1,z.uncompress=h;break;case x.ZIPS_COMPRESSION:z.lines=1,z.uncompress=I,await N.e.LoadScriptAsync(y.FFLATEUrl);break;case x.ZIP_COMPRESSION:z.lines=16,z.uncompress=I,await N.e.LoadScriptAsync(y.FFLATEUrl);break;case x.PIZ_COMPRESSION:z.lines=32,z.uncompress=J;break;case x.PXR24_COMPRESSION:z.lines=16,z.uncompress=i,await N.e.LoadScriptAsync(y.FFLATEUrl);break;default:throw new Error(x[u.compression]+" is unsupported")}z.scanlineBlockSize=z.lines;const O={};for(const x of u.channels)switch(x.name){case"Y":case"R":case"G":case"B":case"A":O[x.name]=!0,z.type=x.pixelType}let m=!1;if(O.R&&O.G&&O.B)m=!O.A,z.outputChannels=4,z.decodeChannels={R:0,G:1,B:2,A:3};else{if(!O.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");z.outputChannels=1,z.decodeChannels={Y:0}}if(1===z.type)switch(T){case A.Float:z.getter=l,z.inputSize=2;break;case A.HalfFloat:z.getter=F,z.inputSize=2}else{if(2!==z.type)throw new Error("Unsupported pixelType "+z.type+" for "+u.compression);switch(T){case A.Float:z.getter=j,z.inputSize=4;break;case A.HalfFloat:z.getter=P,z.inputSize=4}}z.blockCount=z.height/z.scanlineBlockSize;for(let x=0;x<z.blockCount;x++)c(G,s);const f=z.width*z.height*z.outputChannels;switch(T){case A.Float:z.byteArray=new Float32Array(f),z.textureType=1,m&&z.byteArray.fill(1,0,f);break;case A.HalfFloat:z.byteArray=new Uint16Array(f),z.textureType=2,m&&z.byteArray.fill(15360,0,f);break;default:throw new Error("Unsupported type: "+T)}let C=0;for(const x of u.channels)void 0!==z.decodeChannels[x.name]&&(z.channelLineOffsets[x.name]=C*z.width),C+=2*x.pixelType;return z.bytesPerLine=z.width*C,z.outLineWidth=z.width*z.outputChannels,"INCREASING_Y"===u.lineOrder?z.scanOrder=u=>u:z.scanOrder=u=>z.height-1-u,4==z.outputChannels?(z.format=5,z.linearSpace=!0):(z.format=6,z.linearSpace=!1),z}(m,z,O,y.DefaultOutputType);!function(u,G,s,T){const z={value:0};for(let O=0;O<u.height/u.scanlineBlockSize;O++){const m=Y(s,T)-G.dataWindow.yMin;u.size=n(s,T),u.lines=m+u.scanlineBlockSize>u.height?u.height-m:u.scanlineBlockSize;const f=u.size<u.lines*u.bytesPerLine&&u.uncompress?u.uncompress(u):e(u);T.value+=u.size;for(let s=0;s<u.scanlineBlockSize;s++){const T=O*u.scanlineBlockSize,m=s+u.scanOrder(T);if(m>=u.height)continue;const C=s*u.bytesPerLine,x=(u.height-1-m)*u.outLineWidth;for(let s=0;s<u.channels;s++){const T=G.channels[s].name,O=u.channelLineOffsets[T],m=u.decodeChannels[T];if(void 0!==m){z.value=C+O;for(let G=0;G<u.width;G++){const s=x+G*u.outputChannels+m;u.byteArray&&(u.byteArray[s]=u.getter(f,z))}}}}}}(f,m,z,O);s(m.dataWindow.xMax-m.dataWindow.xMin+1,m.dataWindow.yMax-m.dataWindow.yMin+1,G.generateMipMaps,!1,(()=>{const u=G.getEngine();G.format=m.format,G.type=f.textureType,G.invertY=!1,G._gammaSpace=!m.linearSpace,f.byteArray&&u._uploadDataToTextureDirectly(G,f.byteArray,0,0,void 0,!0)}))}}}}]);