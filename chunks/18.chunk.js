"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{2538:(R,x,H)=>{function k(R){return Math.floor(R/8)}function c(R){return 1<<R%8}H.d(x,{OptimizeIndices:()=>A});class t{constructor(R){this.size=R,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(R){if(R>=this.size)throw new RangeError("Bit index out of range");const x=k(R),H=c(R);return 0!==(this._byteArray[x]&H)}set(R,x){if(R>=this.size)throw new RangeError("Bit index out of range");const H=k(R),t=c(R);x?this._byteArray[H]|=t:this._byteArray[H]&=~t}}function A(R){const x=[],H=R.length/3;for(let t=0;t<H;t++)x.push([R[3*t],R[3*t+1],R[3*t+2]]);const k=new Map;for(let t=0;t<x.length;t++){const R=x[t];for(const x of R){let R=k.get(x);R||k.set(x,R=[]),R.push(t)}}const c=new t(H),A=[],D=R=>{const H=[R];for(;H.length>0;){const R=H.pop();if(!c.get(R)){c.set(R,!0),A.push(x[R]);for(const t of x[R]){const R=k.get(t);if(!R)return;for(const x of R)c.get(x)||H.push(x)}}}};for(let t=0;t<H;t++)c.get(t)||D(t);let U=0;for(const t of A)R[U++]=t[0],R[U++]=t[1],R[U++]=t[2]}}}]);