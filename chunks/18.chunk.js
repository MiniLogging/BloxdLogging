"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{13064:(v,y,n)=>{n.r(y),n.d(y,{_ExrTextureLoader:()=>K});var B=n(10801),J=n(11091);const P=65536,b=14,Y=65537,l=16384;var a,Z;!function(v){v[v.NO_COMPRESSION=0]="NO_COMPRESSION",v[v.RLE_COMPRESSION=1]="RLE_COMPRESSION",v[v.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",v[v.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",v[v.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",v[v.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(a||(a={})),function(v){v[v.INCREASING_Y=0]="INCREASING_Y",v[v.DECREASING_Y=1]="DECREASING_Y"}(Z||(Z={}));const x=function(){const v=new ArrayBuffer(4),y=new Float32Array(v),n=new Uint32Array(v),B=new Uint32Array(512),J=new Uint32Array(512);for(let l=0;l<256;++l){const v=l-127;v<-27?(B[l]=0,B[256|l]=32768,J[l]=24,J[256|l]=24):v<-14?(B[l]=1024>>-v-14,B[256|l]=1024>>-v-14|32768,J[l]=-v-1,J[256|l]=-v-1):v<=15?(B[l]=v+15<<10,B[256|l]=v+15<<10|32768,J[l]=13,J[256|l]=13):v<128?(B[l]=31744,B[256|l]=64512,J[l]=24,J[256|l]=24):(B[l]=31744,B[256|l]=64512,J[l]=13,J[256|l]=13)}const P=new Uint32Array(2048),b=new Uint32Array(64),Y=new Uint32Array(64);for(let l=1;l<1024;++l){let v=l<<13,y=0;for(;0===(8388608&v);)v<<=1,y-=8388608;v&=-8388609,y+=947912704,P[l]=v|y}for(let l=1024;l<2048;++l)P[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)b[l]=l<<23;b[31]=1199570944,b[32]=2147483648;for(let l=33;l<63;++l)b[l]=2147483648+(l-32<<23);b[63]=3347054592;for(let l=1;l<64;++l)32!==l&&(Y[l]=1024);return{floatView:y,uint32View:n,baseTable:B,shiftTable:J,mantissaTable:P,exponentTable:b,offsetTable:Y}}();function f(v,y){const n=new Uint8Array(v);let B=0;for(;0!=n[y.value+B];)B+=1;const J=(new TextDecoder).decode(n.slice(y.value,y.value+B));return y.value=y.value+B+1,J}function N(v,y){const n=v.getInt32(y.value,!0);return y.value+=4,n}function i(v,y){const n=v.getUint32(y.value,!0);return y.value+=4,n}function g(v,y){const n=v.getUint8(y.value);return y.value+=1,n}function c(v,y){const n=v.getUint16(y.value,!0);return y.value+=2,n}function h(v,y){const n=v[y.value];return y.value+=1,n}function E(v,y){let n;return n="getBigInt64"in DataView.prototype?Number(v.getBigInt64(y.value,!0)):v.getUint32(y.value+4,!0)+Number(v.getUint32(y.value,!0)<<32),y.value+=8,n}function W(v,y){const n=v.getFloat32(y.value,!0);return y.value+=4,n}function s(v,y){return function(v){const y=(31744&v)>>10,n=1023&v;return(v>>15?-1:1)*(y?31===y?n?NaN:1/0:Math.pow(2,y-15)*(1+n/1024):n/1024*6103515625e-14)}(c(v,y))}function C(v,y){return function(v){if(Math.abs(v)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");v=(0,J.c)(v,-65504,65504),x.floatView[0]=v;const y=x.uint32View[0],n=y>>23&511;return x.baseTable[n]+((8388607&y)>>x.shiftTable[n])}(W(v,y))}function r(v,y,n,B){switch(n){case"string":case"stringvector":case"iccProfile":return function(v,y,n){const B=(new TextDecoder).decode(new Uint8Array(v).slice(y.value,y.value+n));return y.value=y.value+n,B}(v.buffer,y,B);case"chlist":return function(v,y,n){const B=y.value,J=[];for(;y.value<B+n-1;){const n=f(v.buffer,y),B=N(v,y),P=g(v,y);y.value+=3;const b=N(v,y),Y=N(v,y);J.push({name:n,pixelType:B,pLinear:P,xSampling:b,ySampling:Y})}return y.value+=1,J}(v,y,B);case"chromaticities":return function(v,y){return{redX:W(v,y),redY:W(v,y),greenX:W(v,y),greenY:W(v,y),blueX:W(v,y),blueY:W(v,y),whiteX:W(v,y),whiteY:W(v,y)}}(v,y);case"compression":return function(v,y){return g(v,y)}(v,y);case"box2i":return function(v,y){return{xMin:N(v,y),yMin:N(v,y),xMax:N(v,y),yMax:N(v,y)}}(v,y);case"lineOrder":return function(v,y){const n=g(v,y);return Z[n]}(v,y);case"float":return W(v,y);case"v2f":return function(v,y){return[W(v,y),W(v,y)]}(v,y);case"v3f":return function(v,y){return[W(v,y),W(v,y),W(v,y)]}(v,y);case"int":return N(v,y);case"rational":return function(v,y){return[N(v,y),i(v,y)]}(v,y);case"timecode":return function(v,y){return[i(v,y),i(v,y)]}(v,y);case"preview":return y.value+=B,"skipped";default:return void(y.value+=B)}}function u(v){for(let y=1;y<v.length;y++){const n=v[y-1]+v[y]-128;v[y]=n}}function O(v,y){let n=0,B=Math.floor((v.length+1)/2),J=0;const P=v.length-1;for(;!(J>P)&&(y[J++]=v[n++],!(J>P));)y[J++]=v[B++]}function d(v,y,n,B,J){for(;n<v;)y=y<<8|h(B,J),n+=8;return{l:y>>(n-=v)&(1<<v)-1,c:y,lc:n}}function q(v,y,n,B){return{c:v=v<<8|h(n,B),lc:y+=8}}function L(v,y,n,B,J,P,b,Y,l){if(v==y){if(B<8){const v=q(n,B,J,P);n=v.c,B=v.lc}let v=n>>(B-=8);if(v=new Uint8Array([v])[0],Y.value+v>l)return null;const y=b[Y.value-1];for(;v-- >0;)b[Y.value++]=y}else{if(!(Y.value<l))return null;b[Y.value++]=v}return{c:n,lc:B}}const t=new Array(59);function G(v,y,n,B,J,P){const b=y;let l=0,a=0;for(;B<=J;B++){if(b.value-y.value>n)return;let Y=d(6,l,a,v,b);const Z=Y.l;if(l=Y.c,a=Y.lc,P[B]=Z,63==Z){if(b.value-y.value>n)throw new Error("Error in HufUnpackEncTable");Y=d(8,l,a,v,b);let Z=Y.l+6;if(l=Y.c,a=Y.lc,B+Z>J+1)throw new Error("Error in HufUnpackEncTable");for(;Z--;)P[B++]=0;B--}else if(Z>=59){let v=Z-59+2;if(B+v>J+1)throw new Error("Error in HufUnpackEncTable");for(;v--;)P[B++]=0;B--}}!function(v){for(let n=0;n<=58;++n)t[n]=0;for(let n=0;n<Y;++n)t[v[n]]+=1;let y=0;for(let n=58;n>0;--n){const v=y+t[n]>>1;t[n]=y,y=v}for(let n=0;n<Y;++n){const y=v[n];y>0&&(v[n]=y|t[y]++<<6)}}(P)}function R(v){return 63&v}function F(v){return v>>6}function S(v,y,n,B,J,P){const a=n.value,Z=i(y,n),x=i(y,n);n.value+=4;const f=i(y,n);if(n.value+=4,Z<0||Z>=Y||x<0||x>=Y)throw new Error("Wrong HUF_ENCSIZE");const N=new Array(Y),g=new Array(l);!function(v){for(let y=0;y<l;y++)v[y]={},v[y].len=0,v[y].lit=0,v[y].p=null}(g);if(G(v,n,B-(n.value-a),Z,x,N),f>8*(B-(n.value-a)))throw new Error("Wrong hufUncompress");!function(v,y,n,B){for(;y<=n;y++){const n=F(v[y]),J=R(v[y]);if(n>>J)throw new Error("Invalid table entry");if(J>b){const v=B[n>>J-b];if(v.len)throw new Error("Invalid table entry");if(v.lit++,v.p){const y=v.p;v.p=new Array(v.lit);for(let n=0;n<v.lit-1;++n)v.p[n]=y[n]}else v.p=new Array(1);v.p[v.lit-1]=y}else if(J){let v=0;for(let P=1<<b-J;P>0;P--){const P=B[(n<<b-J)+v];if(P.len||P.p)throw new Error("Invalid table entry");P.len=J,P.lit=y,v++}}}}(N,Z,x,g),function(v,y,n,B,J,P,Y,l,a){let Z=0,x=0;const f=Y,N=Math.trunc(B.value+(J+7)/8);for(;B.value<N;){let J=q(Z,x,n,B);for(Z=J.c,x=J.lc;x>=b;){const Y=y[Z>>x-b&16383];if(Y.len){x-=Y.len;const v=L(Y.lit,P,Z,x,n,B,l,a,f);v&&(Z=v.c,x=v.lc)}else{if(!Y.p)throw new Error("hufDecode issues");let y;for(y=0;y<Y.lit;y++){const b=R(v[Y.p[y]]);for(;x<b&&B.value<N;)J=q(Z,x,n,B),Z=J.c,x=J.lc;if(x>=b&&F(v[Y.p[y]])==(Z>>x-b&(1<<b)-1)){x-=b;const v=L(Y.p[y],P,Z,x,n,B,l,a,f);v&&(Z=v.c,x=v.lc);break}}if(y==Y.lit)throw new Error("HufDecode issues")}}}const i=8-J&7;for(Z>>=i,x-=i;x>0;){const v=y[Z<<b-x&16383];if(!v.len)throw new Error("HufDecode issues");{x-=v.len;const y=L(v.lit,P,Z,x,n,B,l,a,f);y&&(Z=y.c,x=y.lc)}}}(N,g,v,n,f,x,P,J,{value:0})}function w(v){return 65535&v}function k(v){const y=w(v);return y>32767?y-65536:y}function M(v,y){const n=k(v),B=k(y),J=n+(1&B)+(B>>1);return{a:J,b:J-B}}function I(v,y){const n=w(v),B=w(y),J=n-(B>>1)&65535;return{a:B+J-32768&65535,b:J}}function j(v,y,n,B,J,P,b){const Y=b<16384,l=n>J?J:n;let a,Z,x=1;for(;x<=l;)x<<=1;for(x>>=1,a=x,x>>=1;x>=1;){Z=0;const b=Z+P*(J-a),l=P*x,f=P*a,N=B*x,i=B*a;let g,c,h,E;for(;Z<=b;Z+=f){let J=Z;const P=Z+B*(n-a);for(;J<=P;J+=i){const n=J+N,B=J+l,P=B+N;if(Y){let b=M(v[J+y],v[B+y]);g=b.a,h=b.b,b=M(v[n+y],v[P+y]),c=b.a,E=b.b,b=M(g,c),v[J+y]=b.a,v[n+y]=b.b,b=M(h,E),v[B+y]=b.a,v[P+y]=b.b}else{let b=I(v[J+y],v[B+y]);g=b.a,h=b.b,b=I(v[n+y],v[P+y]),c=b.a,E=b.b,b=I(g,c),v[J+y]=b.a,v[n+y]=b.b,b=I(h,E),v[B+y]=b.a,v[P+y]=b.b}}if(n&x){const n=J+l;let B;B=Y?M(v[J+y],v[n+y]):I(v[J+y],v[n+y]),g=B.a,v[n+y]=B.b,v[J+y]=g}}if(J&x){let J=Z;const P=Z+B*(n-a);for(;J<=P;J+=i){const n=J+N;let B;B=Y?M(v[J+y],v[n+y]):I(v[J+y],v[n+y]),g=B.a,v[n+y]=B.b,v[J+y]=g}}a=x,x>>=1}return Z}function V(v){return new DataView(v.array.buffer,v.offset.value,v.size)}function p(v){const y=v.viewer.buffer.slice(v.offset.value,v.offset.value+v.size),n=new Uint8Array(function(v){let y=v.byteLength;const n=new Array;let B=0;const J=new DataView(v);for(;y>0;){const v=J.getInt8(B++);if(v<0){const P=-v;y-=P+1;for(let v=0;v<P;v++)n.push(J.getUint8(B++))}else{const P=v;y-=2;const b=J.getUint8(B++);for(let v=0;v<P+1;v++)n.push(b)}}return n}(y)),B=new Uint8Array(n.length);return u(n),O(n,B),new DataView(B.buffer)}function H(v){const y=v.array.slice(v.offset.value,v.offset.value+v.size),n=fflate.unzlibSync(y),B=new Uint8Array(n.length);return u(n),O(n,B),new DataView(B.buffer)}function A(v){const y=v.array.slice(v.offset.value,v.offset.value+v.size),n=fflate.unzlibSync(y),B=v.lines*v.channels*v.width,J=1==v.type?new Uint16Array(B):new Uint32Array(B);let P=0,b=0;const Y=new Array(4);for(let l=0;l<v.lines;l++)for(let y=0;y<v.channels;y++){let y=0;switch(v.type){case 1:Y[0]=P,Y[1]=Y[0]+v.width,P=Y[1]+v.width;for(let B=0;B<v.width;++B){y+=n[Y[0]++]<<8|n[Y[1]++],J[b]=y,b++}break;case 2:Y[0]=P,Y[1]=Y[0]+v.width,Y[2]=Y[1]+v.width,P=Y[2]+v.width;for(let B=0;B<v.width;++B){y+=n[Y[0]++]<<24|n[Y[1]++]<<16|n[Y[2]++]<<8,J[b]=y,b++}}}return new DataView(J.buffer)}function X(v){const y=v.viewer,n={value:v.offset.value},B=new Uint16Array(v.width*v.scanlineBlockSize*(v.channels*v.type)),J=new Uint8Array(8192);let b=0;const Y=new Array(v.channels);for(let P=0;P<v.channels;P++)Y[P]={},Y[P].start=b,Y[P].end=Y[P].start,Y[P].nx=v.width,Y[P].ny=v.lines,Y[P].size=v.type,b+=Y[P].nx*Y[P].ny*Y[P].size;const l=c(y,n),a=c(y,n);if(a>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(l<=a)for(let P=0;P<a-l+1;P++)J[P+l]=g(y,n);const Z=new Uint16Array(P),x=function(v,y){let n=0;for(let J=0;J<P;++J)(0==J||v[J>>3]&1<<(7&J))&&(y[n++]=J);const B=n-1;for(;n<P;)y[n++]=0;return B}(J,Z),f=i(y,n);S(v.array,y,n,f,B,b);for(let P=0;P<v.channels;++P){const v=Y[P];for(let y=0;y<Y[P].size;++y)j(B,v.start+y,v.nx,v.size,v.ny,v.nx*v.size,x)}!function(v,y,n){for(let B=0;B<n;++B)y[B]=v[y[B]]}(Z,B,b);let N=0;const h=new Uint8Array(B.buffer.byteLength);for(let P=0;P<v.lines;P++)for(let y=0;y<v.channels;y++){const v=Y[y],n=v.nx*v.size,J=new Uint8Array(B.buffer,2*v.end,2*n);h.set(J,N),N+=2*n,v.end+=n}return new DataView(h.buffer)}var U,z=n(10791);!function(v){v[v.Float=0]="Float",v[v.HalfFloat=1]="HalfFloat"}(U||(U={}));class e{}e.DefaultOutputType=U.HalfFloat,e.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class K{constructor(){this.supportCascades=!1}loadCubeData(v,y,n,B,J){throw".exr not supported in Cube."}async loadData(v,y,n){const J=new DataView(v.buffer),P={value:0},b=function(v,y){if(20000630!=v.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const n=v.getUint8(4),J=v.getUint8(5),P={singleTile:!!(2&J),longName:!!(4&J),deepFormat:!!(8&J),multiPart:!!(16&J)};y.value=8;const b={};let Y=!0;for(;Y;){const n=f(v.buffer,y);if(n){const J=f(v.buffer,y),P=r(v,y,J,i(v,y));void 0===P?B.e.Warn(`Unknown header attribute type ${J}'.`):b[n]=P}else Y=!1}if(0!=(-5&J))throw new Error("Unsupported file format");return{version:n,spec:P,...b}}(J,P),Y=await async function(v,y,n,B){const J={size:0,viewer:y,array:new Uint8Array(y.buffer),offset:n,width:v.dataWindow.xMax-v.dataWindow.xMin+1,height:v.dataWindow.yMax-v.dataWindow.yMin+1,channels:v.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(v.compression){case a.NO_COMPRESSION:J.lines=1,J.uncompress=V;break;case a.RLE_COMPRESSION:J.lines=1,J.uncompress=p;break;case a.ZIPS_COMPRESSION:J.lines=1,J.uncompress=H,await z.g.LoadScriptAsync(e.FFLATEUrl);break;case a.ZIP_COMPRESSION:J.lines=16,J.uncompress=H,await z.g.LoadScriptAsync(e.FFLATEUrl);break;case a.PIZ_COMPRESSION:J.lines=32,J.uncompress=X;break;case a.PXR24_COMPRESSION:J.lines=16,J.uncompress=A,await z.g.LoadScriptAsync(e.FFLATEUrl);break;default:throw new Error(a[v.compression]+" is unsupported")}J.scanlineBlockSize=J.lines;const P={};for(const a of v.channels)switch(a.name){case"Y":case"R":case"G":case"B":case"A":P[a.name]=!0,J.type=a.pixelType}let b=!1;if(P.R&&P.G&&P.B)b=!P.A,J.outputChannels=4,J.decodeChannels={R:0,G:1,B:2,A:3};else{if(!P.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");J.outputChannels=1,J.decodeChannels={Y:0}}if(1===J.type)switch(B){case U.Float:J.getter=s,J.inputSize=2;break;case U.HalfFloat:J.getter=c,J.inputSize=2}else{if(2!==J.type)throw new Error("Unsupported pixelType "+J.type+" for "+v.compression);switch(B){case U.Float:J.getter=W,J.inputSize=4;break;case U.HalfFloat:J.getter=C,J.inputSize=4}}J.blockCount=J.height/J.scanlineBlockSize;for(let a=0;a<J.blockCount;a++)E(y,n);const Y=J.width*J.height*J.outputChannels;switch(B){case U.Float:J.byteArray=new Float32Array(Y),J.textureType=1,b&&J.byteArray.fill(1,0,Y);break;case U.HalfFloat:J.byteArray=new Uint16Array(Y),J.textureType=2,b&&J.byteArray.fill(15360,0,Y);break;default:throw new Error("Unsupported type: "+B)}let l=0;for(const a of v.channels)void 0!==J.decodeChannels[a.name]&&(J.channelLineOffsets[a.name]=l*J.width),l+=2*a.pixelType;return J.bytesPerLine=J.width*l,J.outLineWidth=J.width*J.outputChannels,"INCREASING_Y"===v.lineOrder?J.scanOrder=v=>v:J.scanOrder=v=>J.height-1-v,4==J.outputChannels?(J.format=5,J.linearSpace=!0):(J.format=6,J.linearSpace=!1),J}(b,J,P,e.DefaultOutputType);!function(v,y,n,B){const J={value:0};for(let P=0;P<v.height/v.scanlineBlockSize;P++){const b=N(n,B)-y.dataWindow.yMin;v.size=i(n,B),v.lines=b+v.scanlineBlockSize>v.height?v.height-b:v.scanlineBlockSize;const Y=v.size<v.lines*v.bytesPerLine&&v.uncompress?v.uncompress(v):V(v);B.value+=v.size;for(let n=0;n<v.scanlineBlockSize;n++){const B=P*v.scanlineBlockSize,b=n+v.scanOrder(B);if(b>=v.height)continue;const l=n*v.bytesPerLine,a=(v.height-1-b)*v.outLineWidth;for(let n=0;n<v.channels;n++){const B=y.channels[n].name,P=v.channelLineOffsets[B],b=v.decodeChannels[B];if(void 0!==b){J.value=l+P;for(let y=0;y<v.width;y++){const n=a+y*v.outputChannels+b;v.byteArray&&(v.byteArray[n]=v.getter(Y,J))}}}}}}(Y,b,J,P);n(b.dataWindow.xMax-b.dataWindow.xMin+1,b.dataWindow.yMax-b.dataWindow.yMin+1,y.generateMipMaps,!1,(()=>{const v=y.getEngine();y.format=b.format,y.type=Y.textureType,y.invertY=!1,y._gammaSpace=!b.linearSpace,Y.byteArray&&v._uploadDataToTextureDirectly(y,Y.byteArray,0,0,void 0,!0)}))}}}}]);