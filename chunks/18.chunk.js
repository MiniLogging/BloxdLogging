"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{13247:(V,p,W)=>{W.r(p),W.d(p,{_ExrTextureLoader:()=>m});var N=W(10870),d=W(11242);const E=65536,z=14,S=65537,Q=16384;var J,i;!function(V){V[V.NO_COMPRESSION=0]="NO_COMPRESSION",V[V.RLE_COMPRESSION=1]="RLE_COMPRESSION",V[V.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",V[V.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",V[V.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",V[V.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(J||(J={})),function(V){V[V.INCREASING_Y=0]="INCREASING_Y",V[V.DECREASING_Y=1]="DECREASING_Y"}(i||(i={}));const l=function(){const V=new ArrayBuffer(4),p=new Float32Array(V),W=new Uint32Array(V),N=new Uint32Array(512),d=new Uint32Array(512);for(let Q=0;Q<256;++Q){const V=Q-127;V<-27?(N[Q]=0,N[256|Q]=32768,d[Q]=24,d[256|Q]=24):V<-14?(N[Q]=1024>>-V-14,N[256|Q]=1024>>-V-14|32768,d[Q]=-V-1,d[256|Q]=-V-1):V<=15?(N[Q]=V+15<<10,N[256|Q]=V+15<<10|32768,d[Q]=13,d[256|Q]=13):V<128?(N[Q]=31744,N[256|Q]=64512,d[Q]=24,d[256|Q]=24):(N[Q]=31744,N[256|Q]=64512,d[Q]=13,d[256|Q]=13)}const E=new Uint32Array(2048),z=new Uint32Array(64),S=new Uint32Array(64);for(let Q=1;Q<1024;++Q){let V=Q<<13,p=0;for(;0===(8388608&V);)V<<=1,p-=8388608;V&=-8388609,p+=947912704,E[Q]=V|p}for(let Q=1024;Q<2048;++Q)E[Q]=939524096+(Q-1024<<13);for(let Q=1;Q<31;++Q)z[Q]=Q<<23;z[31]=1199570944,z[32]=2147483648;for(let Q=33;Q<63;++Q)z[Q]=2147483648+(Q-32<<23);z[63]=3347054592;for(let Q=1;Q<64;++Q)32!==Q&&(S[Q]=1024);return{floatView:p,uint32View:W,baseTable:N,shiftTable:d,mantissaTable:E,exponentTable:z,offsetTable:S}}();function j(V,p){const W=new Uint8Array(V);let N=0;for(;0!=W[p.value+N];)N+=1;const d=(new TextDecoder).decode(W.slice(p.value,p.value+N));return p.value=p.value+N+1,d}function k(V,p){const W=V.getInt32(p.value,!0);return p.value+=4,W}function u(V,p){const W=V.getUint32(p.value,!0);return p.value+=4,W}function f(V,p){const W=V.getUint8(p.value);return p.value+=1,W}function O(V,p){const W=V.getUint16(p.value,!0);return p.value+=2,W}function U(V,p){const W=V[p.value];return p.value+=1,W}function F(V,p){let W;return W="getBigInt64"in DataView.prototype?Number(V.getBigInt64(p.value,!0)):V.getUint32(p.value+4,!0)+Number(V.getUint32(p.value,!0)<<32),p.value+=8,W}function C(V,p){const W=V.getFloat32(p.value,!0);return p.value+=4,W}function A(V,p){return function(V){const p=(31744&V)>>10,W=1023&V;return(V>>15?-1:1)*(p?31===p?W?NaN:1/0:Math.pow(2,p-15)*(1+W/1024):W/1024*6103515625e-14)}(O(V,p))}function v(V,p){return function(V){if(Math.abs(V)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");V=(0,d.d)(V,-65504,65504),l.floatView[0]=V;const p=l.uint32View[0],W=p>>23&511;return l.baseTable[W]+((8388607&p)>>l.shiftTable[W])}(C(V,p))}function t(V,p,W,N){switch(W){case"string":case"stringvector":case"iccProfile":return function(V,p,W){const N=(new TextDecoder).decode(new Uint8Array(V).slice(p.value,p.value+W));return p.value=p.value+W,N}(V.buffer,p,N);case"chlist":return function(V,p,W){const N=p.value,d=[];for(;p.value<N+W-1;){const W=j(V.buffer,p),N=k(V,p),E=f(V,p);p.value+=3;const z=k(V,p),S=k(V,p);d.push({name:W,pixelType:N,pLinear:E,xSampling:z,ySampling:S})}return p.value+=1,d}(V,p,N);case"chromaticities":return function(V,p){return{redX:C(V,p),redY:C(V,p),greenX:C(V,p),greenY:C(V,p),blueX:C(V,p),blueY:C(V,p),whiteX:C(V,p),whiteY:C(V,p)}}(V,p);case"compression":return function(V,p){return f(V,p)}(V,p);case"box2i":return function(V,p){return{xMin:k(V,p),yMin:k(V,p),xMax:k(V,p),yMax:k(V,p)}}(V,p);case"lineOrder":return function(V,p){const W=f(V,p);return i[W]}(V,p);case"float":return C(V,p);case"v2f":return function(V,p){return[C(V,p),C(V,p)]}(V,p);case"v3f":return function(V,p){return[C(V,p),C(V,p),C(V,p)]}(V,p);case"int":return k(V,p);case"rational":return function(V,p){return[k(V,p),u(V,p)]}(V,p);case"timecode":return function(V,p){return[u(V,p),u(V,p)]}(V,p);case"preview":return p.value+=N,"skipped";default:return void(p.value+=N)}}function e(V){for(let p=1;p<V.length;p++){const W=V[p-1]+V[p]-128;V[p]=W}}function Z(V,p){let W=0,N=Math.floor((V.length+1)/2),d=0;const E=V.length-1;for(;!(d>E)&&(p[d++]=V[W++],!(d>E));)p[d++]=V[N++]}function o(V,p,W,N,d){for(;W<V;)p=p<<8|U(N,d),W+=8;return{l:p>>(W-=V)&(1<<V)-1,c:p,lc:W}}function K(V,p,W,N){return{c:V=V<<8|U(W,N),lc:p+=8}}function h(V,p,W,N,d,E,z,S,Q){if(V==p){if(N<8){const V=K(W,N,d,E);W=V.c,N=V.lc}let V=W>>(N-=8);if(V=new Uint8Array([V])[0],S.value+V>Q)return null;const p=z[S.value-1];for(;V-- >0;)z[S.value++]=p}else{if(!(S.value<Q))return null;z[S.value++]=V}return{c:W,lc:N}}const L=new Array(59);function x(V,p,W,N,d,E){const z=p;let Q=0,J=0;for(;N<=d;N++){if(z.value-p.value>W)return;let S=o(6,Q,J,V,z);const i=S.l;if(Q=S.c,J=S.lc,E[N]=i,63==i){if(z.value-p.value>W)throw new Error("Error in HufUnpackEncTable");S=o(8,Q,J,V,z);let i=S.l+6;if(Q=S.c,J=S.lc,N+i>d+1)throw new Error("Error in HufUnpackEncTable");for(;i--;)E[N++]=0;N--}else if(i>=59){let V=i-59+2;if(N+V>d+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)E[N++]=0;N--}}!function(V){for(let W=0;W<=58;++W)L[W]=0;for(let W=0;W<S;++W)L[V[W]]+=1;let p=0;for(let W=58;W>0;--W){const V=p+L[W]>>1;L[W]=p,p=V}for(let W=0;W<S;++W){const p=V[W];p>0&&(V[W]=p|L[p]++<<6)}}(E)}function T(V){return 63&V}function P(V){return V>>6}function b(V,p,W,N,d,E){const J=W.value,i=u(p,W),l=u(p,W);W.value+=4;const j=u(p,W);if(W.value+=4,i<0||i>=S||l<0||l>=S)throw new Error("Wrong HUF_ENCSIZE");const k=new Array(S),f=new Array(Q);!function(V){for(let p=0;p<Q;p++)V[p]={},V[p].len=0,V[p].lit=0,V[p].p=null}(f);if(x(V,W,N-(W.value-J),i,l,k),j>8*(N-(W.value-J)))throw new Error("Wrong hufUncompress");!function(V,p,W,N){for(;p<=W;p++){const W=P(V[p]),d=T(V[p]);if(W>>d)throw new Error("Invalid table entry");if(d>z){const V=N[W>>d-z];if(V.len)throw new Error("Invalid table entry");if(V.lit++,V.p){const p=V.p;V.p=new Array(V.lit);for(let W=0;W<V.lit-1;++W)V.p[W]=p[W]}else V.p=new Array(1);V.p[V.lit-1]=p}else if(d){let V=0;for(let E=1<<z-d;E>0;E--){const E=N[(W<<z-d)+V];if(E.len||E.p)throw new Error("Invalid table entry");E.len=d,E.lit=p,V++}}}}(k,i,l,f),function(V,p,W,N,d,E,S,Q,J){let i=0,l=0;const j=S,k=Math.trunc(N.value+(d+7)/8);for(;N.value<k;){let d=K(i,l,W,N);for(i=d.c,l=d.lc;l>=z;){const S=p[i>>l-z&16383];if(S.len){l-=S.len;const V=h(S.lit,E,i,l,W,N,Q,J,j);V&&(i=V.c,l=V.lc)}else{if(!S.p)throw new Error("hufDecode issues");let p;for(p=0;p<S.lit;p++){const z=T(V[S.p[p]]);for(;l<z&&N.value<k;)d=K(i,l,W,N),i=d.c,l=d.lc;if(l>=z&&P(V[S.p[p]])==(i>>l-z&(1<<z)-1)){l-=z;const V=h(S.p[p],E,i,l,W,N,Q,J,j);V&&(i=V.c,l=V.lc);break}}if(p==S.lit)throw new Error("HufDecode issues")}}}const u=8-d&7;for(i>>=u,l-=u;l>0;){const V=p[i<<z-l&16383];if(!V.len)throw new Error("HufDecode issues");{l-=V.len;const p=h(V.lit,E,i,l,W,N,Q,J,j);p&&(i=p.c,l=p.lc)}}}(k,f,V,W,j,l,E,d,{value:0})}function s(V){return 65535&V}function G(V){const p=s(V);return p>32767?p-65536:p}function R(V,p){const W=G(V),N=G(p),d=W+(1&N)+(N>>1);return{a:d,b:d-N}}function X(V,p){const W=s(V),N=s(p),d=W-(N>>1)&65535;return{a:N+d-32768&65535,b:d}}function r(V,p,W,N,d,E,z){const S=z<16384,Q=W>d?d:W;let J,i,l=1;for(;l<=Q;)l<<=1;for(l>>=1,J=l,l>>=1;l>=1;){i=0;const z=i+E*(d-J),Q=E*l,j=E*J,k=N*l,u=N*J;let f,O,U,F;for(;i<=z;i+=j){let d=i;const E=i+N*(W-J);for(;d<=E;d+=u){const W=d+k,N=d+Q,E=N+k;if(S){let z=R(V[d+p],V[N+p]);f=z.a,U=z.b,z=R(V[W+p],V[E+p]),O=z.a,F=z.b,z=R(f,O),V[d+p]=z.a,V[W+p]=z.b,z=R(U,F),V[N+p]=z.a,V[E+p]=z.b}else{let z=X(V[d+p],V[N+p]);f=z.a,U=z.b,z=X(V[W+p],V[E+p]),O=z.a,F=z.b,z=X(f,O),V[d+p]=z.a,V[W+p]=z.b,z=X(U,F),V[N+p]=z.a,V[E+p]=z.b}}if(W&l){const W=d+Q;let N;N=S?R(V[d+p],V[W+p]):X(V[d+p],V[W+p]),f=N.a,V[W+p]=N.b,V[d+p]=f}}if(d&l){let d=i;const E=i+N*(W-J);for(;d<=E;d+=u){const W=d+k;let N;N=S?R(V[d+p],V[W+p]):X(V[d+p],V[W+p]),f=N.a,V[W+p]=N.b,V[d+p]=f}}J=l,l>>=1}return i}function B(V){return new DataView(V.array.buffer,V.offset.value,V.size)}function Y(V){const p=V.viewer.buffer.slice(V.offset.value,V.offset.value+V.size),W=new Uint8Array(function(V){let p=V.byteLength;const W=new Array;let N=0;const d=new DataView(V);for(;p>0;){const V=d.getInt8(N++);if(V<0){const E=-V;p-=E+1;for(let V=0;V<E;V++)W.push(d.getUint8(N++))}else{const E=V;p-=2;const z=d.getUint8(N++);for(let V=0;V<E+1;V++)W.push(z)}}return W}(p)),N=new Uint8Array(W.length);return e(W),Z(W,N),new DataView(N.buffer)}function I(V){const p=V.array.slice(V.offset.value,V.offset.value+V.size),W=fflate.unzlibSync(p),N=new Uint8Array(W.length);return e(W),Z(W,N),new DataView(N.buffer)}function c(V){const p=V.array.slice(V.offset.value,V.offset.value+V.size),W=fflate.unzlibSync(p),N=V.lines*V.channels*V.width,d=1==V.type?new Uint16Array(N):new Uint32Array(N);let E=0,z=0;const S=new Array(4);for(let Q=0;Q<V.lines;Q++)for(let p=0;p<V.channels;p++){let p=0;switch(V.type){case 1:S[0]=E,S[1]=S[0]+V.width,E=S[1]+V.width;for(let N=0;N<V.width;++N){p+=W[S[0]++]<<8|W[S[1]++],d[z]=p,z++}break;case 2:S[0]=E,S[1]=S[0]+V.width,S[2]=S[1]+V.width,E=S[2]+V.width;for(let N=0;N<V.width;++N){p+=W[S[0]++]<<24|W[S[1]++]<<16|W[S[2]++]<<8,d[z]=p,z++}}}return new DataView(d.buffer)}function q(V){const p=V.viewer,W={value:V.offset.value},N=new Uint16Array(V.width*V.scanlineBlockSize*(V.channels*V.type)),d=new Uint8Array(8192);let z=0;const S=new Array(V.channels);for(let E=0;E<V.channels;E++)S[E]={},S[E].start=z,S[E].end=S[E].start,S[E].nx=V.width,S[E].ny=V.lines,S[E].size=V.type,z+=S[E].nx*S[E].ny*S[E].size;const Q=O(p,W),J=O(p,W);if(J>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(Q<=J)for(let E=0;E<J-Q+1;E++)d[E+Q]=f(p,W);const i=new Uint16Array(E),l=function(V,p){let W=0;for(let d=0;d<E;++d)(0==d||V[d>>3]&1<<(7&d))&&(p[W++]=d);const N=W-1;for(;W<E;)p[W++]=0;return N}(d,i),j=u(p,W);b(V.array,p,W,j,N,z);for(let E=0;E<V.channels;++E){const V=S[E];for(let p=0;p<S[E].size;++p)r(N,V.start+p,V.nx,V.size,V.ny,V.nx*V.size,l)}!function(V,p,W){for(let N=0;N<W;++N)p[N]=V[p[N]]}(i,N,z);let k=0;const U=new Uint8Array(N.buffer.byteLength);for(let E=0;E<V.lines;E++)for(let p=0;p<V.channels;p++){const V=S[p],W=V.nx*V.size,d=new Uint8Array(N.buffer,2*V.end,2*W);U.set(d,k),k+=2*W,V.end+=W}return new DataView(U.buffer)}var g,D=W(10848);!function(V){V[V.Float=0]="Float",V[V.HalfFloat=1]="HalfFloat"}(g||(g={}));class H{}H.DefaultOutputType=g.HalfFloat,H.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class m{constructor(){this.supportCascades=!1}loadCubeData(V,p,W,N,d){throw".exr not supported in Cube."}async loadData(V,p,W){const d=new DataView(V.buffer),E={value:0},z=function(V,p){if(20000630!=V.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const W=V.getUint8(4),d=V.getUint8(5),E={singleTile:!!(2&d),longName:!!(4&d),deepFormat:!!(8&d),multiPart:!!(16&d)};p.value=8;const z={};let S=!0;for(;S;){const W=j(V.buffer,p);if(W){const d=j(V.buffer,p),E=t(V,p,d,u(V,p));void 0===E?N.e.Warn(`Unknown header attribute type ${d}'.`):z[W]=E}else S=!1}if(0!=(-5&d))throw new Error("Unsupported file format");return{version:W,spec:E,...z}}(d,E),S=await async function(V,p,W,N){const d={size:0,viewer:p,array:new Uint8Array(p.buffer),offset:W,width:V.dataWindow.xMax-V.dataWindow.xMin+1,height:V.dataWindow.yMax-V.dataWindow.yMin+1,channels:V.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(V.compression){case J.NO_COMPRESSION:d.lines=1,d.uncompress=B;break;case J.RLE_COMPRESSION:d.lines=1,d.uncompress=Y;break;case J.ZIPS_COMPRESSION:d.lines=1,d.uncompress=I,await D.e.LoadScriptAsync(H.FFLATEUrl);break;case J.ZIP_COMPRESSION:d.lines=16,d.uncompress=I,await D.e.LoadScriptAsync(H.FFLATEUrl);break;case J.PIZ_COMPRESSION:d.lines=32,d.uncompress=q;break;case J.PXR24_COMPRESSION:d.lines=16,d.uncompress=c,await D.e.LoadScriptAsync(H.FFLATEUrl);break;default:throw new Error(J[V.compression]+" is unsupported")}d.scanlineBlockSize=d.lines;const E={};for(const J of V.channels)switch(J.name){case"Y":case"R":case"G":case"B":case"A":E[J.name]=!0,d.type=J.pixelType}let z=!1;if(E.R&&E.G&&E.B)z=!E.A,d.outputChannels=4,d.decodeChannels={R:0,G:1,B:2,A:3};else{if(!E.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");d.outputChannels=1,d.decodeChannels={Y:0}}if(1===d.type)switch(N){case g.Float:d.getter=A,d.inputSize=2;break;case g.HalfFloat:d.getter=O,d.inputSize=2}else{if(2!==d.type)throw new Error("Unsupported pixelType "+d.type+" for "+V.compression);switch(N){case g.Float:d.getter=C,d.inputSize=4;break;case g.HalfFloat:d.getter=v,d.inputSize=4}}d.blockCount=d.height/d.scanlineBlockSize;for(let J=0;J<d.blockCount;J++)F(p,W);const S=d.width*d.height*d.outputChannels;switch(N){case g.Float:d.byteArray=new Float32Array(S),d.textureType=1,z&&d.byteArray.fill(1,0,S);break;case g.HalfFloat:d.byteArray=new Uint16Array(S),d.textureType=2,z&&d.byteArray.fill(15360,0,S);break;default:throw new Error("Unsupported type: "+N)}let Q=0;for(const J of V.channels)void 0!==d.decodeChannels[J.name]&&(d.channelLineOffsets[J.name]=Q*d.width),Q+=2*J.pixelType;return d.bytesPerLine=d.width*Q,d.outLineWidth=d.width*d.outputChannels,"INCREASING_Y"===V.lineOrder?d.scanOrder=V=>V:d.scanOrder=V=>d.height-1-V,4==d.outputChannels?(d.format=5,d.linearSpace=!0):(d.format=6,d.linearSpace=!1),d}(z,d,E,H.DefaultOutputType);!function(V,p,W,N){const d={value:0};for(let E=0;E<V.height/V.scanlineBlockSize;E++){const z=k(W,N)-p.dataWindow.yMin;V.size=u(W,N),V.lines=z+V.scanlineBlockSize>V.height?V.height-z:V.scanlineBlockSize;const S=V.size<V.lines*V.bytesPerLine&&V.uncompress?V.uncompress(V):B(V);N.value+=V.size;for(let W=0;W<V.scanlineBlockSize;W++){const N=E*V.scanlineBlockSize,z=W+V.scanOrder(N);if(z>=V.height)continue;const Q=W*V.bytesPerLine,J=(V.height-1-z)*V.outLineWidth;for(let W=0;W<V.channels;W++){const N=p.channels[W].name,E=V.channelLineOffsets[N],z=V.decodeChannels[N];if(void 0!==z){d.value=Q+E;for(let p=0;p<V.width;p++){const W=J+p*V.outputChannels+z;V.byteArray&&(V.byteArray[W]=V.getter(S,d))}}}}}}(S,z,d,E);W(z.dataWindow.xMax-z.dataWindow.xMin+1,z.dataWindow.yMax-z.dataWindow.yMin+1,p.generateMipMaps,!1,(()=>{const V=p.getEngine();p.format=z.format,p.type=S.textureType,p.invertY=!1,p._gammaSpace=!z.linearSpace,S.byteArray&&V._uploadDataToTextureDirectly(p,S.byteArray,0,0,void 0,!0)}))}}}}]);