"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{13114:(H,c,y)=>{y.r(c),y.d(c,{_ExrTextureLoader:()=>w});var Z=y(10773),F=y(11106);const P=65536,S=14,n=65537,O=16384;var a,i;!function(H){H[H.NO_COMPRESSION=0]="NO_COMPRESSION",H[H.RLE_COMPRESSION=1]="RLE_COMPRESSION",H[H.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",H[H.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",H[H.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",H[H.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(a||(a={})),function(H){H[H.INCREASING_Y=0]="INCREASING_Y",H[H.DECREASING_Y=1]="DECREASING_Y"}(i||(i={}));const C=function(){const H=new ArrayBuffer(4),c=new Float32Array(H),y=new Uint32Array(H),Z=new Uint32Array(512),F=new Uint32Array(512);for(let O=0;O<256;++O){const H=O-127;H<-27?(Z[O]=0,Z[256|O]=32768,F[O]=24,F[256|O]=24):H<-14?(Z[O]=1024>>-H-14,Z[256|O]=1024>>-H-14|32768,F[O]=-H-1,F[256|O]=-H-1):H<=15?(Z[O]=H+15<<10,Z[256|O]=H+15<<10|32768,F[O]=13,F[256|O]=13):H<128?(Z[O]=31744,Z[256|O]=64512,F[O]=24,F[256|O]=24):(Z[O]=31744,Z[256|O]=64512,F[O]=13,F[256|O]=13)}const P=new Uint32Array(2048),S=new Uint32Array(64),n=new Uint32Array(64);for(let O=1;O<1024;++O){let H=O<<13,c=0;for(;0===(8388608&H);)H<<=1,c-=8388608;H&=-8388609,c+=947912704,P[O]=H|c}for(let O=1024;O<2048;++O)P[O]=939524096+(O-1024<<13);for(let O=1;O<31;++O)S[O]=O<<23;S[31]=1199570944,S[32]=2147483648;for(let O=33;O<63;++O)S[O]=2147483648+(O-32<<23);S[63]=3347054592;for(let O=1;O<64;++O)32!==O&&(n[O]=1024);return{floatView:c,uint32View:y,baseTable:Z,shiftTable:F,mantissaTable:P,exponentTable:S,offsetTable:n}}();function g(H,c){const y=new Uint8Array(H);let Z=0;for(;0!=y[c.value+Z];)Z+=1;const F=(new TextDecoder).decode(y.slice(c.value,c.value+Z));return c.value=c.value+Z+1,F}function v(H,c){const y=H.getInt32(c.value,!0);return c.value+=4,y}function m(H,c){const y=H.getUint32(c.value,!0);return c.value+=4,y}function z(H,c){const y=H.getUint8(c.value);return c.value+=1,y}function V(H,c){const y=H.getUint16(c.value,!0);return c.value+=2,y}function h(H,c){const y=H[c.value];return c.value+=1,y}function Q(H,c){let y;return y="getBigInt64"in DataView.prototype?Number(H.getBigInt64(c.value,!0)):H.getUint32(c.value+4,!0)+Number(H.getUint32(c.value,!0)<<32),c.value+=8,y}function D(H,c){const y=H.getFloat32(c.value,!0);return c.value+=4,y}function f(H,c){return function(H){const c=(31744&H)>>10,y=1023&H;return(H>>15?-1:1)*(c?31===c?y?NaN:1/0:Math.pow(2,c-15)*(1+y/1024):y/1024*6103515625e-14)}(V(H,c))}function J(H,c){return function(H){if(Math.abs(H)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");H=(0,F.e)(H,-65504,65504),C.floatView[0]=H;const c=C.uint32View[0],y=c>>23&511;return C.baseTable[y]+((8388607&c)>>C.shiftTable[y])}(D(H,c))}function l(H,c,y,Z){switch(y){case"string":case"stringvector":case"iccProfile":return function(H,c,y){const Z=(new TextDecoder).decode(new Uint8Array(H).slice(c.value,c.value+y));return c.value=c.value+y,Z}(H.buffer,c,Z);case"chlist":return function(H,c,y){const Z=c.value,F=[];for(;c.value<Z+y-1;){const y=g(H.buffer,c),Z=v(H,c),P=z(H,c);c.value+=3;const S=v(H,c),n=v(H,c);F.push({name:y,pixelType:Z,pLinear:P,xSampling:S,ySampling:n})}return c.value+=1,F}(H,c,Z);case"chromaticities":return function(H,c){return{redX:D(H,c),redY:D(H,c),greenX:D(H,c),greenY:D(H,c),blueX:D(H,c),blueY:D(H,c),whiteX:D(H,c),whiteY:D(H,c)}}(H,c);case"compression":return function(H,c){return z(H,c)}(H,c);case"box2i":return function(H,c){return{xMin:v(H,c),yMin:v(H,c),xMax:v(H,c),yMax:v(H,c)}}(H,c);case"lineOrder":return function(H,c){const y=z(H,c);return i[y]}(H,c);case"float":return D(H,c);case"v2f":return function(H,c){return[D(H,c),D(H,c)]}(H,c);case"v3f":return function(H,c){return[D(H,c),D(H,c),D(H,c)]}(H,c);case"int":return v(H,c);case"rational":return function(H,c){return[v(H,c),m(H,c)]}(H,c);case"timecode":return function(H,c){return[m(H,c),m(H,c)]}(H,c);case"preview":return c.value+=Z,"skipped";default:return void(c.value+=Z)}}function d(H){for(let c=1;c<H.length;c++){const y=H[c-1]+H[c]-128;H[c]=y}}function K(H,c){let y=0,Z=Math.floor((H.length+1)/2),F=0;const P=H.length-1;for(;!(F>P)&&(c[F++]=H[y++],!(F>P));)c[F++]=H[Z++]}function T(H,c,y,Z,F){for(;y<H;)c=c<<8|h(Z,F),y+=8;return{l:c>>(y-=H)&(1<<H)-1,c:c,lc:y}}function u(H,c,y,Z){return{c:H=H<<8|h(y,Z),lc:c+=8}}function E(H,c,y,Z,F,P,S,n,O){if(H==c){if(Z<8){const H=u(y,Z,F,P);y=H.c,Z=H.lc}let H=y>>(Z-=8);if(H=new Uint8Array([H])[0],n.value+H>O)return null;const c=S[n.value-1];for(;H-- >0;)S[n.value++]=c}else{if(!(n.value<O))return null;S[n.value++]=H}return{c:y,lc:Z}}const U=new Array(59);function G(H,c,y,Z,F,P){const S=c;let O=0,a=0;for(;Z<=F;Z++){if(S.value-c.value>y)return;let n=T(6,O,a,H,S);const i=n.l;if(O=n.c,a=n.lc,P[Z]=i,63==i){if(S.value-c.value>y)throw new Error("Error in HufUnpackEncTable");n=T(8,O,a,H,S);let i=n.l+6;if(O=n.c,a=n.lc,Z+i>F+1)throw new Error("Error in HufUnpackEncTable");for(;i--;)P[Z++]=0;Z--}else if(i>=59){let H=i-59+2;if(Z+H>F+1)throw new Error("Error in HufUnpackEncTable");for(;H--;)P[Z++]=0;Z--}}!function(H){for(let y=0;y<=58;++y)U[y]=0;for(let y=0;y<n;++y)U[H[y]]+=1;let c=0;for(let y=58;y>0;--y){const H=c+U[y]>>1;U[y]=c,c=H}for(let y=0;y<n;++y){const c=H[y];c>0&&(H[y]=c|U[c]++<<6)}}(P)}function p(H){return 63&H}function t(H){return H>>6}function o(H,c,y,Z,F,P){const a=y.value,i=m(c,y),C=m(c,y);y.value+=4;const g=m(c,y);if(y.value+=4,i<0||i>=n||C<0||C>=n)throw new Error("Wrong HUF_ENCSIZE");const v=new Array(n),z=new Array(O);!function(H){for(let c=0;c<O;c++)H[c]={},H[c].len=0,H[c].lit=0,H[c].p=null}(z);if(G(H,y,Z-(y.value-a),i,C,v),g>8*(Z-(y.value-a)))throw new Error("Wrong hufUncompress");!function(H,c,y,Z){for(;c<=y;c++){const y=t(H[c]),F=p(H[c]);if(y>>F)throw new Error("Invalid table entry");if(F>S){const H=Z[y>>F-S];if(H.len)throw new Error("Invalid table entry");if(H.lit++,H.p){const c=H.p;H.p=new Array(H.lit);for(let y=0;y<H.lit-1;++y)H.p[y]=c[y]}else H.p=new Array(1);H.p[H.lit-1]=c}else if(F){let H=0;for(let P=1<<S-F;P>0;P--){const P=Z[(y<<S-F)+H];if(P.len||P.p)throw new Error("Invalid table entry");P.len=F,P.lit=c,H++}}}}(v,i,C,z),function(H,c,y,Z,F,P,n,O,a){let i=0,C=0;const g=n,v=Math.trunc(Z.value+(F+7)/8);for(;Z.value<v;){let F=u(i,C,y,Z);for(i=F.c,C=F.lc;C>=S;){const n=c[i>>C-S&16383];if(n.len){C-=n.len;const H=E(n.lit,P,i,C,y,Z,O,a,g);H&&(i=H.c,C=H.lc)}else{if(!n.p)throw new Error("hufDecode issues");let c;for(c=0;c<n.lit;c++){const S=p(H[n.p[c]]);for(;C<S&&Z.value<v;)F=u(i,C,y,Z),i=F.c,C=F.lc;if(C>=S&&t(H[n.p[c]])==(i>>C-S&(1<<S)-1)){C-=S;const H=E(n.p[c],P,i,C,y,Z,O,a,g);H&&(i=H.c,C=H.lc);break}}if(c==n.lit)throw new Error("HufDecode issues")}}}const m=8-F&7;for(i>>=m,C-=m;C>0;){const H=c[i<<S-C&16383];if(!H.len)throw new Error("HufDecode issues");{C-=H.len;const c=E(H.lit,P,i,C,y,Z,O,a,g);c&&(i=c.c,C=c.lc)}}}(v,z,H,y,g,C,P,F,{value:0})}function s(H){return 65535&H}function q(H){const c=s(H);return c>32767?c-65536:c}function I(H,c){const y=q(H),Z=q(c),F=y+(1&Z)+(Z>>1);return{a:F,b:F-Z}}function j(H,c){const y=s(H),Z=s(c),F=y-(Z>>1)&65535;return{a:Z+F-32768&65535,b:F}}function k(H,c,y,Z,F,P,S){const n=S<16384,O=y>F?F:y;let a,i,C=1;for(;C<=O;)C<<=1;for(C>>=1,a=C,C>>=1;C>=1;){i=0;const S=i+P*(F-a),O=P*C,g=P*a,v=Z*C,m=Z*a;let z,V,h,Q;for(;i<=S;i+=g){let F=i;const P=i+Z*(y-a);for(;F<=P;F+=m){const y=F+v,Z=F+O,P=Z+v;if(n){let S=I(H[F+c],H[Z+c]);z=S.a,h=S.b,S=I(H[y+c],H[P+c]),V=S.a,Q=S.b,S=I(z,V),H[F+c]=S.a,H[y+c]=S.b,S=I(h,Q),H[Z+c]=S.a,H[P+c]=S.b}else{let S=j(H[F+c],H[Z+c]);z=S.a,h=S.b,S=j(H[y+c],H[P+c]),V=S.a,Q=S.b,S=j(z,V),H[F+c]=S.a,H[y+c]=S.b,S=j(h,Q),H[Z+c]=S.a,H[P+c]=S.b}}if(y&C){const y=F+O;let Z;Z=n?I(H[F+c],H[y+c]):j(H[F+c],H[y+c]),z=Z.a,H[y+c]=Z.b,H[F+c]=z}}if(F&C){let F=i;const P=i+Z*(y-a);for(;F<=P;F+=m){const y=F+v;let Z;Z=n?I(H[F+c],H[y+c]):j(H[F+c],H[y+c]),z=Z.a,H[y+c]=Z.b,H[F+c]=z}}a=C,C>>=1}return i}function W(H){return new DataView(H.array.buffer,H.offset.value,H.size)}function M(H){const c=H.viewer.buffer.slice(H.offset.value,H.offset.value+H.size),y=new Uint8Array(function(H){let c=H.byteLength;const y=new Array;let Z=0;const F=new DataView(H);for(;c>0;){const H=F.getInt8(Z++);if(H<0){const P=-H;c-=P+1;for(let H=0;H<P;H++)y.push(F.getUint8(Z++))}else{const P=H;c-=2;const S=F.getUint8(Z++);for(let H=0;H<P+1;H++)y.push(S)}}return y}(c)),Z=new Uint8Array(y.length);return d(y),K(y,Z),new DataView(Z.buffer)}function x(H){const c=H.array.slice(H.offset.value,H.offset.value+H.size),y=fflate.unzlibSync(c),Z=new Uint8Array(y.length);return d(y),K(y,Z),new DataView(Z.buffer)}function R(H){const c=H.array.slice(H.offset.value,H.offset.value+H.size),y=fflate.unzlibSync(c),Z=H.lines*H.channels*H.width,F=1==H.type?new Uint16Array(Z):new Uint32Array(Z);let P=0,S=0;const n=new Array(4);for(let O=0;O<H.lines;O++)for(let c=0;c<H.channels;c++){let c=0;switch(H.type){case 1:n[0]=P,n[1]=n[0]+H.width,P=n[1]+H.width;for(let Z=0;Z<H.width;++Z){c+=y[n[0]++]<<8|y[n[1]++],F[S]=c,S++}break;case 2:n[0]=P,n[1]=n[0]+H.width,n[2]=n[1]+H.width,P=n[2]+H.width;for(let Z=0;Z<H.width;++Z){c+=y[n[0]++]<<24|y[n[1]++]<<16|y[n[2]++]<<8,F[S]=c,S++}}}return new DataView(F.buffer)}function A(H){const c=H.viewer,y={value:H.offset.value},Z=new Uint16Array(H.width*H.scanlineBlockSize*(H.channels*H.type)),F=new Uint8Array(8192);let S=0;const n=new Array(H.channels);for(let P=0;P<H.channels;P++)n[P]={},n[P].start=S,n[P].end=n[P].start,n[P].nx=H.width,n[P].ny=H.lines,n[P].size=H.type,S+=n[P].nx*n[P].ny*n[P].size;const O=V(c,y),a=V(c,y);if(a>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(O<=a)for(let P=0;P<a-O+1;P++)F[P+O]=z(c,y);const i=new Uint16Array(P),C=function(H,c){let y=0;for(let F=0;F<P;++F)(0==F||H[F>>3]&1<<(7&F))&&(c[y++]=F);const Z=y-1;for(;y<P;)c[y++]=0;return Z}(F,i),g=m(c,y);o(H.array,c,y,g,Z,S);for(let P=0;P<H.channels;++P){const H=n[P];for(let c=0;c<n[P].size;++c)k(Z,H.start+c,H.nx,H.size,H.ny,H.nx*H.size,C)}!function(H,c,y){for(let Z=0;Z<y;++Z)c[Z]=H[c[Z]]}(i,Z,S);let v=0;const h=new Uint8Array(Z.buffer.byteLength);for(let P=0;P<H.lines;P++)for(let c=0;c<H.channels;c++){const H=n[c],y=H.nx*H.size,F=new Uint8Array(Z.buffer,2*H.end,2*y);h.set(F,v),v+=2*y,H.end+=y}return new DataView(h.buffer)}var e,r=y(10754);!function(H){H[H.Float=0]="Float",H[H.HalfFloat=1]="HalfFloat"}(e||(e={}));class N{}N.DefaultOutputType=e.HalfFloat,N.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class w{constructor(){this.supportCascades=!1}loadCubeData(H,c,y,Z,F){throw".exr not supported in Cube."}async loadData(H,c,y){const F=new DataView(H.buffer),P={value:0},S=function(H,c){if(20000630!=H.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const y=H.getUint8(4),F=H.getUint8(5),P={singleTile:!!(2&F),longName:!!(4&F),deepFormat:!!(8&F),multiPart:!!(16&F)};c.value=8;const S={};let n=!0;for(;n;){const y=g(H.buffer,c);if(y){const F=g(H.buffer,c),P=l(H,c,F,m(H,c));void 0===P?Z.d.Warn(`Unknown header attribute type ${F}'.`):S[y]=P}else n=!1}if(0!=(-5&F))throw new Error("Unsupported file format");return{version:y,spec:P,...S}}(F,P),n=await async function(H,c,y,Z){const F={size:0,viewer:c,array:new Uint8Array(c.buffer),offset:y,width:H.dataWindow.xMax-H.dataWindow.xMin+1,height:H.dataWindow.yMax-H.dataWindow.yMin+1,channels:H.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(H.compression){case a.NO_COMPRESSION:F.lines=1,F.uncompress=W;break;case a.RLE_COMPRESSION:F.lines=1,F.uncompress=M;break;case a.ZIPS_COMPRESSION:F.lines=1,F.uncompress=x,await r.c.LoadScriptAsync(N.FFLATEUrl);break;case a.ZIP_COMPRESSION:F.lines=16,F.uncompress=x,await r.c.LoadScriptAsync(N.FFLATEUrl);break;case a.PIZ_COMPRESSION:F.lines=32,F.uncompress=A;break;case a.PXR24_COMPRESSION:F.lines=16,F.uncompress=R,await r.c.LoadScriptAsync(N.FFLATEUrl);break;default:throw new Error(a[H.compression]+" is unsupported")}F.scanlineBlockSize=F.lines;const P={};for(const a of H.channels)switch(a.name){case"Y":case"R":case"G":case"B":case"A":P[a.name]=!0,F.type=a.pixelType}let S=!1;if(P.R&&P.G&&P.B)S=!P.A,F.outputChannels=4,F.decodeChannels={R:0,G:1,B:2,A:3};else{if(!P.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");F.outputChannels=1,F.decodeChannels={Y:0}}if(1===F.type)switch(Z){case e.Float:F.getter=f,F.inputSize=2;break;case e.HalfFloat:F.getter=V,F.inputSize=2}else{if(2!==F.type)throw new Error("Unsupported pixelType "+F.type+" for "+H.compression);switch(Z){case e.Float:F.getter=D,F.inputSize=4;break;case e.HalfFloat:F.getter=J,F.inputSize=4}}F.blockCount=F.height/F.scanlineBlockSize;for(let a=0;a<F.blockCount;a++)Q(c,y);const n=F.width*F.height*F.outputChannels;switch(Z){case e.Float:F.byteArray=new Float32Array(n),F.textureType=1,S&&F.byteArray.fill(1,0,n);break;case e.HalfFloat:F.byteArray=new Uint16Array(n),F.textureType=2,S&&F.byteArray.fill(15360,0,n);break;default:throw new Error("Unsupported type: "+Z)}let O=0;for(const a of H.channels)void 0!==F.decodeChannels[a.name]&&(F.channelLineOffsets[a.name]=O*F.width),O+=2*a.pixelType;return F.bytesPerLine=F.width*O,F.outLineWidth=F.width*F.outputChannels,"INCREASING_Y"===H.lineOrder?F.scanOrder=H=>H:F.scanOrder=H=>F.height-1-H,4==F.outputChannels?(F.format=5,F.linearSpace=!0):(F.format=6,F.linearSpace=!1),F}(S,F,P,N.DefaultOutputType);!function(H,c,y,Z){const F={value:0};for(let P=0;P<H.height/H.scanlineBlockSize;P++){const S=v(y,Z)-c.dataWindow.yMin;H.size=m(y,Z),H.lines=S+H.scanlineBlockSize>H.height?H.height-S:H.scanlineBlockSize;const n=H.size<H.lines*H.bytesPerLine&&H.uncompress?H.uncompress(H):W(H);Z.value+=H.size;for(let y=0;y<H.scanlineBlockSize;y++){const Z=P*H.scanlineBlockSize,S=y+H.scanOrder(Z);if(S>=H.height)continue;const O=y*H.bytesPerLine,a=(H.height-1-S)*H.outLineWidth;for(let y=0;y<H.channels;y++){const Z=c.channels[y].name,P=H.channelLineOffsets[Z],S=H.decodeChannels[Z];if(void 0!==S){F.value=O+P;for(let c=0;c<H.width;c++){const y=a+c*H.outputChannels+S;H.byteArray&&(H.byteArray[y]=H.getter(n,F))}}}}}}(n,S,F,P);y(S.dataWindow.xMax-S.dataWindow.xMin+1,S.dataWindow.yMax-S.dataWindow.yMin+1,c.generateMipMaps,!1,(()=>{const H=c.getEngine();c.format=S.format,c.type=n.textureType,c.invertY=!1,c._gammaSpace=!S.linearSpace,n.byteArray&&H._uploadDataToTextureDirectly(c,n.byteArray,0,0,void 0,!0)}))}}}}]);