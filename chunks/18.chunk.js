"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{2615:(Q,X,C)=>{function l(Q){return Math.floor(Q/8)}function h(Q){return 1<<Q%8}C.d(X,{OptimizeIndices:()=>f});class M{constructor(Q){this.size=Q,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(Q){if(Q>=this.size)throw new RangeError("Bit index out of range");const X=l(Q),C=h(Q);return 0!==(this._byteArray[X]&C)}set(Q,X){if(Q>=this.size)throw new RangeError("Bit index out of range");const C=l(Q),M=h(Q);X?this._byteArray[C]|=M:this._byteArray[C]&=~M}}function f(Q){const X=[],C=Q.length/3;for(let M=0;M<C;M++)X.push([Q[3*M],Q[3*M+1],Q[3*M+2]]);const l=new Map;for(let M=0;M<X.length;M++){const Q=X[M];for(const X of Q){let Q=l.get(X);Q||l.set(X,Q=[]),Q.push(M)}}const h=new M(C),f=[],O=Q=>{const C=[Q];for(;C.length>0;){const Q=C.pop();if(!h.get(Q)){h.set(Q,!0),f.push(X[Q]);for(const M of X[Q]){const Q=l.get(M);if(!Q)return;for(const X of Q)h.get(X)||C.push(X)}}}};for(let M=0;M<C;M++)h.get(M)||O(M);let m=0;for(const M of f)Q[m++]=M[0],Q[m++]=M[1],Q[m++]=M[2]}}}]);