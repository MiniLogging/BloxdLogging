"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12763:(E,Y,C)=>{C.r(Y),C.d(Y,{_ExrTextureLoader:()=>I});var P=C(10750),K=C(11080);const m=65536,u=14,T=65537,a=16384;var J,t;!function(E){E[E.NO_COMPRESSION=0]="NO_COMPRESSION",E[E.RLE_COMPRESSION=1]="RLE_COMPRESSION",E[E.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",E[E.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",E[E.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",E[E.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(J||(J={})),function(E){E[E.INCREASING_Y=0]="INCREASING_Y",E[E.DECREASING_Y=1]="DECREASING_Y"}(t||(t={}));const p=function(){const E=new ArrayBuffer(4),Y=new Float32Array(E),C=new Uint32Array(E),P=new Uint32Array(512),K=new Uint32Array(512);for(let a=0;a<256;++a){const E=a-127;E<-27?(P[a]=0,P[256|a]=32768,K[a]=24,K[256|a]=24):E<-14?(P[a]=1024>>-E-14,P[256|a]=1024>>-E-14|32768,K[a]=-E-1,K[256|a]=-E-1):E<=15?(P[a]=E+15<<10,P[256|a]=E+15<<10|32768,K[a]=13,K[256|a]=13):E<128?(P[a]=31744,P[256|a]=64512,K[a]=24,K[256|a]=24):(P[a]=31744,P[256|a]=64512,K[a]=13,K[256|a]=13)}const m=new Uint32Array(2048),u=new Uint32Array(64),T=new Uint32Array(64);for(let a=1;a<1024;++a){let E=a<<13,Y=0;for(;0===(8388608&E);)E<<=1,Y-=8388608;E&=-8388609,Y+=947912704,m[a]=E|Y}for(let a=1024;a<2048;++a)m[a]=939524096+(a-1024<<13);for(let a=1;a<31;++a)u[a]=a<<23;u[31]=1199570944,u[32]=2147483648;for(let a=33;a<63;++a)u[a]=2147483648+(a-32<<23);u[63]=3347054592;for(let a=1;a<64;++a)32!==a&&(T[a]=1024);return{floatView:Y,uint32View:C,baseTable:P,shiftTable:K,mantissaTable:m,exponentTable:u,offsetTable:T}}();function W(E,Y){const C=new Uint8Array(E);let P=0;for(;0!=C[Y.value+P];)P+=1;const K=(new TextDecoder).decode(C.slice(Y.value,Y.value+P));return Y.value=Y.value+P+1,K}function k(E,Y){const C=E.getInt32(Y.value,!0);return Y.value+=4,C}function y(E,Y){const C=E.getUint32(Y.value,!0);return Y.value+=4,C}function v(E,Y){const C=E.getUint8(Y.value);return Y.value+=1,C}function V(E,Y){const C=E.getUint16(Y.value,!0);return Y.value+=2,C}function Z(E,Y){const C=E[Y.value];return Y.value+=1,C}function M(E,Y){let C;return C="getBigInt64"in DataView.prototype?Number(E.getBigInt64(Y.value,!0)):E.getUint32(Y.value+4,!0)+Number(E.getUint32(Y.value,!0)<<32),Y.value+=8,C}function h(E,Y){const C=E.getFloat32(Y.value,!0);return Y.value+=4,C}function f(E,Y){return function(E){const Y=(31744&E)>>10,C=1023&E;return(E>>15?-1:1)*(Y?31===Y?C?NaN:1/0:Math.pow(2,Y-15)*(1+C/1024):C/1024*6103515625e-14)}(V(E,Y))}function G(E,Y){return function(E){if(Math.abs(E)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");E=(0,K.b)(E,-65504,65504),p.floatView[0]=E;const Y=p.uint32View[0],C=Y>>23&511;return p.baseTable[C]+((8388607&Y)>>p.shiftTable[C])}(h(E,Y))}function g(E,Y,C,P){switch(C){case"string":case"stringvector":case"iccProfile":return function(E,Y,C){const P=(new TextDecoder).decode(new Uint8Array(E).slice(Y.value,Y.value+C));return Y.value=Y.value+C,P}(E.buffer,Y,P);case"chlist":return function(E,Y,C){const P=Y.value,K=[];for(;Y.value<P+C-1;){const C=W(E.buffer,Y),P=k(E,Y),m=v(E,Y);Y.value+=3;const u=k(E,Y),T=k(E,Y);K.push({name:C,pixelType:P,pLinear:m,xSampling:u,ySampling:T})}return Y.value+=1,K}(E,Y,P);case"chromaticities":return function(E,Y){return{redX:h(E,Y),redY:h(E,Y),greenX:h(E,Y),greenY:h(E,Y),blueX:h(E,Y),blueY:h(E,Y),whiteX:h(E,Y),whiteY:h(E,Y)}}(E,Y);case"compression":return function(E,Y){return v(E,Y)}(E,Y);case"box2i":return function(E,Y){return{xMin:k(E,Y),yMin:k(E,Y),xMax:k(E,Y),yMax:k(E,Y)}}(E,Y);case"lineOrder":return function(E,Y){const C=v(E,Y);return t[C]}(E,Y);case"float":return h(E,Y);case"v2f":return function(E,Y){return[h(E,Y),h(E,Y)]}(E,Y);case"v3f":return function(E,Y){return[h(E,Y),h(E,Y),h(E,Y)]}(E,Y);case"int":return k(E,Y);case"rational":return function(E,Y){return[k(E,Y),y(E,Y)]}(E,Y);case"timecode":return function(E,Y){return[y(E,Y),y(E,Y)]}(E,Y);case"preview":return Y.value+=P,"skipped";default:return void(Y.value+=P)}}function c(E){for(let Y=1;Y<E.length;Y++){const C=E[Y-1]+E[Y]-128;E[Y]=C}}function D(E,Y){let C=0,P=Math.floor((E.length+1)/2),K=0;const m=E.length-1;for(;!(K>m)&&(Y[K++]=E[C++],!(K>m));)Y[K++]=E[P++]}function S(E,Y,C,P,K){for(;C<E;)Y=Y<<8|Z(P,K),C+=8;return{l:Y>>(C-=E)&(1<<E)-1,c:Y,lc:C}}function j(E,Y,C,P){return{c:E=E<<8|Z(C,P),lc:Y+=8}}function i(E,Y,C,P,K,m,u,T,a){if(E==Y){if(P<8){const E=j(C,P,K,m);C=E.c,P=E.lc}let E=C>>(P-=8);if(E=new Uint8Array([E])[0],T.value+E>a)return null;const Y=u[T.value-1];for(;E-- >0;)u[T.value++]=Y}else{if(!(T.value<a))return null;u[T.value++]=E}return{c:C,lc:P}}const R=new Array(59);function X(E,Y,C,P,K,m){const u=Y;let a=0,J=0;for(;P<=K;P++){if(u.value-Y.value>C)return;let T=S(6,a,J,E,u);const t=T.l;if(a=T.c,J=T.lc,m[P]=t,63==t){if(u.value-Y.value>C)throw new Error("Error in HufUnpackEncTable");T=S(8,a,J,E,u);let t=T.l+6;if(a=T.c,J=T.lc,P+t>K+1)throw new Error("Error in HufUnpackEncTable");for(;t--;)m[P++]=0;P--}else if(t>=59){let E=t-59+2;if(P+E>K+1)throw new Error("Error in HufUnpackEncTable");for(;E--;)m[P++]=0;P--}}!function(E){for(let C=0;C<=58;++C)R[C]=0;for(let C=0;C<T;++C)R[E[C]]+=1;let Y=0;for(let C=58;C>0;--C){const E=Y+R[C]>>1;R[C]=Y,Y=E}for(let C=0;C<T;++C){const Y=E[C];Y>0&&(E[C]=Y|R[Y]++<<6)}}(m)}function w(E){return 63&E}function d(E){return E>>6}function s(E,Y,C,P,K,m){const J=C.value,t=y(Y,C),p=y(Y,C);C.value+=4;const W=y(Y,C);if(C.value+=4,t<0||t>=T||p<0||p>=T)throw new Error("Wrong HUF_ENCSIZE");const k=new Array(T),v=new Array(a);!function(E){for(let Y=0;Y<a;Y++)E[Y]={},E[Y].len=0,E[Y].lit=0,E[Y].p=null}(v);if(X(E,C,P-(C.value-J),t,p,k),W>8*(P-(C.value-J)))throw new Error("Wrong hufUncompress");!function(E,Y,C,P){for(;Y<=C;Y++){const C=d(E[Y]),K=w(E[Y]);if(C>>K)throw new Error("Invalid table entry");if(K>u){const E=P[C>>K-u];if(E.len)throw new Error("Invalid table entry");if(E.lit++,E.p){const Y=E.p;E.p=new Array(E.lit);for(let C=0;C<E.lit-1;++C)E.p[C]=Y[C]}else E.p=new Array(1);E.p[E.lit-1]=Y}else if(K){let E=0;for(let m=1<<u-K;m>0;m--){const m=P[(C<<u-K)+E];if(m.len||m.p)throw new Error("Invalid table entry");m.len=K,m.lit=Y,E++}}}}(k,t,p,v),function(E,Y,C,P,K,m,T,a,J){let t=0,p=0;const W=T,k=Math.trunc(P.value+(K+7)/8);for(;P.value<k;){let K=j(t,p,C,P);for(t=K.c,p=K.lc;p>=u;){const T=Y[t>>p-u&16383];if(T.len){p-=T.len;const E=i(T.lit,m,t,p,C,P,a,J,W);E&&(t=E.c,p=E.lc)}else{if(!T.p)throw new Error("hufDecode issues");let Y;for(Y=0;Y<T.lit;Y++){const u=w(E[T.p[Y]]);for(;p<u&&P.value<k;)K=j(t,p,C,P),t=K.c,p=K.lc;if(p>=u&&d(E[T.p[Y]])==(t>>p-u&(1<<u)-1)){p-=u;const E=i(T.p[Y],m,t,p,C,P,a,J,W);E&&(t=E.c,p=E.lc);break}}if(Y==T.lit)throw new Error("HufDecode issues")}}}const y=8-K&7;for(t>>=y,p-=y;p>0;){const E=Y[t<<u-p&16383];if(!E.len)throw new Error("HufDecode issues");{p-=E.len;const Y=i(E.lit,m,t,p,C,P,a,J,W);Y&&(t=Y.c,p=Y.lc)}}}(k,v,E,C,W,p,m,K,{value:0})}function N(E){return 65535&E}function l(E){const Y=N(E);return Y>32767?Y-65536:Y}function H(E,Y){const C=l(E),P=l(Y),K=C+(1&P)+(P>>1);return{a:K,b:K-P}}function x(E,Y){const C=N(E),P=N(Y),K=C-(P>>1)&65535;return{a:P+K-32768&65535,b:K}}function Q(E,Y,C,P,K,m,u){const T=u<16384,a=C>K?K:C;let J,t,p=1;for(;p<=a;)p<<=1;for(p>>=1,J=p,p>>=1;p>=1;){t=0;const u=t+m*(K-J),a=m*p,W=m*J,k=P*p,y=P*J;let v,V,Z,M;for(;t<=u;t+=W){let K=t;const m=t+P*(C-J);for(;K<=m;K+=y){const C=K+k,P=K+a,m=P+k;if(T){let u=H(E[K+Y],E[P+Y]);v=u.a,Z=u.b,u=H(E[C+Y],E[m+Y]),V=u.a,M=u.b,u=H(v,V),E[K+Y]=u.a,E[C+Y]=u.b,u=H(Z,M),E[P+Y]=u.a,E[m+Y]=u.b}else{let u=x(E[K+Y],E[P+Y]);v=u.a,Z=u.b,u=x(E[C+Y],E[m+Y]),V=u.a,M=u.b,u=x(v,V),E[K+Y]=u.a,E[C+Y]=u.b,u=x(Z,M),E[P+Y]=u.a,E[m+Y]=u.b}}if(C&p){const C=K+a;let P;P=T?H(E[K+Y],E[C+Y]):x(E[K+Y],E[C+Y]),v=P.a,E[C+Y]=P.b,E[K+Y]=v}}if(K&p){let K=t;const m=t+P*(C-J);for(;K<=m;K+=y){const C=K+k;let P;P=T?H(E[K+Y],E[C+Y]):x(E[K+Y],E[C+Y]),v=P.a,E[C+Y]=P.b,E[K+Y]=v}}J=p,p>>=1}return t}function q(E){return new DataView(E.array.buffer,E.offset.value,E.size)}function n(E){const Y=E.viewer.buffer.slice(E.offset.value,E.offset.value+E.size),C=new Uint8Array(function(E){let Y=E.byteLength;const C=new Array;let P=0;const K=new DataView(E);for(;Y>0;){const E=K.getInt8(P++);if(E<0){const m=-E;Y-=m+1;for(let E=0;E<m;E++)C.push(K.getUint8(P++))}else{const m=E;Y-=2;const u=K.getUint8(P++);for(let E=0;E<m+1;E++)C.push(u)}}return C}(Y)),P=new Uint8Array(C.length);return c(C),D(C,P),new DataView(P.buffer)}function r(E){const Y=E.array.slice(E.offset.value,E.offset.value+E.size),C=fflate.unzlibSync(Y),P=new Uint8Array(C.length);return c(C),D(C,P),new DataView(P.buffer)}function A(E){const Y=E.array.slice(E.offset.value,E.offset.value+E.size),C=fflate.unzlibSync(Y),P=E.lines*E.channels*E.width,K=1==E.type?new Uint16Array(P):new Uint32Array(P);let m=0,u=0;const T=new Array(4);for(let a=0;a<E.lines;a++)for(let Y=0;Y<E.channels;Y++){let Y=0;switch(E.type){case 1:T[0]=m,T[1]=T[0]+E.width,m=T[1]+E.width;for(let P=0;P<E.width;++P){Y+=C[T[0]++]<<8|C[T[1]++],K[u]=Y,u++}break;case 2:T[0]=m,T[1]=T[0]+E.width,T[2]=T[1]+E.width,m=T[2]+E.width;for(let P=0;P<E.width;++P){Y+=C[T[0]++]<<24|C[T[1]++]<<16|C[T[2]++]<<8,K[u]=Y,u++}}}return new DataView(K.buffer)}function e(E){const Y=E.viewer,C={value:E.offset.value},P=new Uint16Array(E.width*E.scanlineBlockSize*(E.channels*E.type)),K=new Uint8Array(8192);let u=0;const T=new Array(E.channels);for(let m=0;m<E.channels;m++)T[m]={},T[m].start=u,T[m].end=T[m].start,T[m].nx=E.width,T[m].ny=E.lines,T[m].size=E.type,u+=T[m].nx*T[m].ny*T[m].size;const a=V(Y,C),J=V(Y,C);if(J>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(a<=J)for(let m=0;m<J-a+1;m++)K[m+a]=v(Y,C);const t=new Uint16Array(m),p=function(E,Y){let C=0;for(let K=0;K<m;++K)(0==K||E[K>>3]&1<<(7&K))&&(Y[C++]=K);const P=C-1;for(;C<m;)Y[C++]=0;return P}(K,t),W=y(Y,C);s(E.array,Y,C,W,P,u);for(let m=0;m<E.channels;++m){const E=T[m];for(let Y=0;Y<T[m].size;++Y)Q(P,E.start+Y,E.nx,E.size,E.ny,E.nx*E.size,p)}!function(E,Y,C){for(let P=0;P<C;++P)Y[P]=E[Y[P]]}(t,P,u);let k=0;const Z=new Uint8Array(P.buffer.byteLength);for(let m=0;m<E.lines;m++)for(let Y=0;Y<E.channels;Y++){const E=T[Y],C=E.nx*E.size,K=new Uint8Array(P.buffer,2*E.end,2*C);Z.set(K,k),k+=2*C,E.end+=C}return new DataView(Z.buffer)}var b,B=C(10737);!function(E){E[E.Float=0]="Float",E[E.HalfFloat=1]="HalfFloat"}(b||(b={}));class L{}L.DefaultOutputType=b.HalfFloat,L.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class I{constructor(){this.supportCascades=!1}loadCubeData(E,Y,C,P,K){throw".exr not supported in Cube."}async loadData(E,Y,C){const K=new DataView(E.buffer),m={value:0},u=function(E,Y){if(20000630!=E.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const C=E.getUint8(4),K=E.getUint8(5),m={singleTile:!!(2&K),longName:!!(4&K),deepFormat:!!(8&K),multiPart:!!(16&K)};Y.value=8;const u={};let T=!0;for(;T;){const C=W(E.buffer,Y);if(C){const K=W(E.buffer,Y),m=g(E,Y,K,y(E,Y));void 0===m?P.d.Warn(`Unknown header attribute type ${K}'.`):u[C]=m}else T=!1}if(0!=(-5&K))throw new Error("Unsupported file format");return{version:C,spec:m,...u}}(K,m),T=await async function(E,Y,C,P){const K={size:0,viewer:Y,array:new Uint8Array(Y.buffer),offset:C,width:E.dataWindow.xMax-E.dataWindow.xMin+1,height:E.dataWindow.yMax-E.dataWindow.yMin+1,channels:E.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(E.compression){case J.NO_COMPRESSION:K.lines=1,K.uncompress=q;break;case J.RLE_COMPRESSION:K.lines=1,K.uncompress=n;break;case J.ZIPS_COMPRESSION:K.lines=1,K.uncompress=r,await B.e.LoadScriptAsync(L.FFLATEUrl);break;case J.ZIP_COMPRESSION:K.lines=16,K.uncompress=r,await B.e.LoadScriptAsync(L.FFLATEUrl);break;case J.PIZ_COMPRESSION:K.lines=32,K.uncompress=e;break;case J.PXR24_COMPRESSION:K.lines=16,K.uncompress=A,await B.e.LoadScriptAsync(L.FFLATEUrl);break;default:throw new Error(J[E.compression]+" is unsupported")}K.scanlineBlockSize=K.lines;const m={};for(const J of E.channels)switch(J.name){case"Y":case"R":case"G":case"B":case"A":m[J.name]=!0,K.type=J.pixelType}let u=!1;if(m.R&&m.G&&m.B)u=!m.A,K.outputChannels=4,K.decodeChannels={R:0,G:1,B:2,A:3};else{if(!m.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");K.outputChannels=1,K.decodeChannels={Y:0}}if(1===K.type)switch(P){case b.Float:K.getter=f,K.inputSize=2;break;case b.HalfFloat:K.getter=V,K.inputSize=2}else{if(2!==K.type)throw new Error("Unsupported pixelType "+K.type+" for "+E.compression);switch(P){case b.Float:K.getter=h,K.inputSize=4;break;case b.HalfFloat:K.getter=G,K.inputSize=4}}K.blockCount=K.height/K.scanlineBlockSize;for(let J=0;J<K.blockCount;J++)M(Y,C);const T=K.width*K.height*K.outputChannels;switch(P){case b.Float:K.byteArray=new Float32Array(T),K.textureType=1,u&&K.byteArray.fill(1,0,T);break;case b.HalfFloat:K.byteArray=new Uint16Array(T),K.textureType=2,u&&K.byteArray.fill(15360,0,T);break;default:throw new Error("Unsupported type: "+P)}let a=0;for(const J of E.channels)void 0!==K.decodeChannels[J.name]&&(K.channelLineOffsets[J.name]=a*K.width),a+=2*J.pixelType;return K.bytesPerLine=K.width*a,K.outLineWidth=K.width*K.outputChannels,"INCREASING_Y"===E.lineOrder?K.scanOrder=E=>E:K.scanOrder=E=>K.height-1-E,4==K.outputChannels?(K.format=5,K.linearSpace=!0):(K.format=6,K.linearSpace=!1),K}(u,K,m,L.DefaultOutputType);!function(E,Y,C,P){const K={value:0};for(let m=0;m<E.height/E.scanlineBlockSize;m++){const u=k(C,P)-Y.dataWindow.yMin;E.size=y(C,P),E.lines=u+E.scanlineBlockSize>E.height?E.height-u:E.scanlineBlockSize;const T=E.size<E.lines*E.bytesPerLine&&E.uncompress?E.uncompress(E):q(E);P.value+=E.size;for(let C=0;C<E.scanlineBlockSize;C++){const P=m*E.scanlineBlockSize,u=C+E.scanOrder(P);if(u>=E.height)continue;const a=C*E.bytesPerLine,J=(E.height-1-u)*E.outLineWidth;for(let C=0;C<E.channels;C++){const P=Y.channels[C].name,m=E.channelLineOffsets[P],u=E.decodeChannels[P];if(void 0!==u){K.value=a+m;for(let Y=0;Y<E.width;Y++){const C=J+Y*E.outputChannels+u;E.byteArray&&(E.byteArray[C]=E.getter(T,K))}}}}}}(T,u,K,m);C(u.dataWindow.xMax-u.dataWindow.xMin+1,u.dataWindow.yMax-u.dataWindow.yMin+1,Y.generateMipMaps,!1,(()=>{const E=Y.getEngine();Y.format=u.format,Y.type=T.textureType,Y.invertY=!1,Y._gammaSpace=!u.linearSpace,T.byteArray&&E._uploadDataToTextureDirectly(Y,T.byteArray,0,0,void 0,!0)}))}}}}]);