"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12719:(Y,j,X)=>{X.r(j),X.d(j,{_ExrTextureLoader:()=>c});var u=X(10766),K=X(11080);const U=65536,I=14,y=65537,T=16384;var E,e;!function(Y){Y[Y.NO_COMPRESSION=0]="NO_COMPRESSION",Y[Y.RLE_COMPRESSION=1]="RLE_COMPRESSION",Y[Y.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Y[Y.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Y[Y.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Y[Y.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(E||(E={})),function(Y){Y[Y.INCREASING_Y=0]="INCREASING_Y",Y[Y.DECREASING_Y=1]="DECREASING_Y"}(e||(e={}));const a=function(){const Y=new ArrayBuffer(4),j=new Float32Array(Y),X=new Uint32Array(Y),u=new Uint32Array(512),K=new Uint32Array(512);for(let T=0;T<256;++T){const Y=T-127;Y<-27?(u[T]=0,u[256|T]=32768,K[T]=24,K[256|T]=24):Y<-14?(u[T]=1024>>-Y-14,u[256|T]=1024>>-Y-14|32768,K[T]=-Y-1,K[256|T]=-Y-1):Y<=15?(u[T]=Y+15<<10,u[256|T]=Y+15<<10|32768,K[T]=13,K[256|T]=13):Y<128?(u[T]=31744,u[256|T]=64512,K[T]=24,K[256|T]=24):(u[T]=31744,u[256|T]=64512,K[T]=13,K[256|T]=13)}const U=new Uint32Array(2048),I=new Uint32Array(64),y=new Uint32Array(64);for(let T=1;T<1024;++T){let Y=T<<13,j=0;for(;0===(8388608&Y);)Y<<=1,j-=8388608;Y&=-8388609,j+=947912704,U[T]=Y|j}for(let T=1024;T<2048;++T)U[T]=939524096+(T-1024<<13);for(let T=1;T<31;++T)I[T]=T<<23;I[31]=1199570944,I[32]=2147483648;for(let T=33;T<63;++T)I[T]=2147483648+(T-32<<23);I[63]=3347054592;for(let T=1;T<64;++T)32!==T&&(y[T]=1024);return{floatView:j,uint32View:X,baseTable:u,shiftTable:K,mantissaTable:U,exponentTable:I,offsetTable:y}}();function N(Y,j){const X=new Uint8Array(Y);let u=0;for(;0!=X[j.value+u];)u+=1;const K=(new TextDecoder).decode(X.slice(j.value,j.value+u));return j.value=j.value+u+1,K}function d(Y,j){const X=Y.getInt32(j.value,!0);return j.value+=4,X}function i(Y,j){const X=Y.getUint32(j.value,!0);return j.value+=4,X}function M(Y,j){const X=Y.getUint8(j.value);return j.value+=1,X}function R(Y,j){const X=Y.getUint16(j.value,!0);return j.value+=2,X}function C(Y,j){const X=Y[j.value];return j.value+=1,X}function O(Y,j){let X;return X="getBigInt64"in DataView.prototype?Number(Y.getBigInt64(j.value,!0)):Y.getUint32(j.value+4,!0)+Number(Y.getUint32(j.value,!0)<<32),j.value+=8,X}function P(Y,j){const X=Y.getFloat32(j.value,!0);return j.value+=4,X}function Q(Y,j){return function(Y){const j=(31744&Y)>>10,X=1023&Y;return(Y>>15?-1:1)*(j?31===j?X?NaN:1/0:Math.pow(2,j-15)*(1+X/1024):X/1024*6103515625e-14)}(R(Y,j))}function W(Y,j){return function(Y){if(Math.abs(Y)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Y=(0,K.c)(Y,-65504,65504),a.floatView[0]=Y;const j=a.uint32View[0],X=j>>23&511;return a.baseTable[X]+((8388607&j)>>a.shiftTable[X])}(P(Y,j))}function r(Y,j,X,u){switch(X){case"string":case"stringvector":case"iccProfile":return function(Y,j,X){const u=(new TextDecoder).decode(new Uint8Array(Y).slice(j.value,j.value+X));return j.value=j.value+X,u}(Y.buffer,j,u);case"chlist":return function(Y,j,X){const u=j.value,K=[];for(;j.value<u+X-1;){const X=N(Y.buffer,j),u=d(Y,j),U=M(Y,j);j.value+=3;const I=d(Y,j),y=d(Y,j);K.push({name:X,pixelType:u,pLinear:U,xSampling:I,ySampling:y})}return j.value+=1,K}(Y,j,u);case"chromaticities":return function(Y,j){return{redX:P(Y,j),redY:P(Y,j),greenX:P(Y,j),greenY:P(Y,j),blueX:P(Y,j),blueY:P(Y,j),whiteX:P(Y,j),whiteY:P(Y,j)}}(Y,j);case"compression":return function(Y,j){return M(Y,j)}(Y,j);case"box2i":return function(Y,j){return{xMin:d(Y,j),yMin:d(Y,j),xMax:d(Y,j),yMax:d(Y,j)}}(Y,j);case"lineOrder":return function(Y,j){const X=M(Y,j);return e[X]}(Y,j);case"float":return P(Y,j);case"v2f":return function(Y,j){return[P(Y,j),P(Y,j)]}(Y,j);case"v3f":return function(Y,j){return[P(Y,j),P(Y,j),P(Y,j)]}(Y,j);case"int":return d(Y,j);case"rational":return function(Y,j){return[d(Y,j),i(Y,j)]}(Y,j);case"timecode":return function(Y,j){return[i(Y,j),i(Y,j)]}(Y,j);case"preview":return j.value+=u,"skipped";default:return void(j.value+=u)}}function z(Y){for(let j=1;j<Y.length;j++){const X=Y[j-1]+Y[j]-128;Y[j]=X}}function k(Y,j){let X=0,u=Math.floor((Y.length+1)/2),K=0;const U=Y.length-1;for(;!(K>U)&&(j[K++]=Y[X++],!(K>U));)j[K++]=Y[u++]}function m(Y,j,X,u,K){for(;X<Y;)j=j<<8|C(u,K),X+=8;return{l:j>>(X-=Y)&(1<<Y)-1,c:j,lc:X}}function L(Y,j,X,u){return{c:Y=Y<<8|C(X,u),lc:j+=8}}function J(Y,j,X,u,K,U,I,y,T){if(Y==j){if(u<8){const Y=L(X,u,K,U);X=Y.c,u=Y.lc}let Y=X>>(u-=8);if(Y=new Uint8Array([Y])[0],y.value+Y>T)return null;const j=I[y.value-1];for(;Y-- >0;)I[y.value++]=j}else{if(!(y.value<T))return null;I[y.value++]=Y}return{c:X,lc:u}}const D=new Array(59);function V(Y,j,X,u,K,U){const I=j;let T=0,E=0;for(;u<=K;u++){if(I.value-j.value>X)return;let y=m(6,T,E,Y,I);const e=y.l;if(T=y.c,E=y.lc,U[u]=e,63==e){if(I.value-j.value>X)throw new Error("Error in HufUnpackEncTable");y=m(8,T,E,Y,I);let e=y.l+6;if(T=y.c,E=y.lc,u+e>K+1)throw new Error("Error in HufUnpackEncTable");for(;e--;)U[u++]=0;u--}else if(e>=59){let Y=e-59+2;if(u+Y>K+1)throw new Error("Error in HufUnpackEncTable");for(;Y--;)U[u++]=0;u--}}!function(Y){for(let X=0;X<=58;++X)D[X]=0;for(let X=0;X<y;++X)D[Y[X]]+=1;let j=0;for(let X=58;X>0;--X){const Y=j+D[X]>>1;D[X]=j,j=Y}for(let X=0;X<y;++X){const j=Y[X];j>0&&(Y[X]=j|D[j]++<<6)}}(U)}function p(Y){return 63&Y}function b(Y){return Y>>6}function B(Y,j,X,u,K,U){const E=X.value,e=i(j,X),a=i(j,X);X.value+=4;const N=i(j,X);if(X.value+=4,e<0||e>=y||a<0||a>=y)throw new Error("Wrong HUF_ENCSIZE");const d=new Array(y),M=new Array(T);!function(Y){for(let j=0;j<T;j++)Y[j]={},Y[j].len=0,Y[j].lit=0,Y[j].p=null}(M);if(V(Y,X,u-(X.value-E),e,a,d),N>8*(u-(X.value-E)))throw new Error("Wrong hufUncompress");!function(Y,j,X,u){for(;j<=X;j++){const X=b(Y[j]),K=p(Y[j]);if(X>>K)throw new Error("Invalid table entry");if(K>I){const Y=u[X>>K-I];if(Y.len)throw new Error("Invalid table entry");if(Y.lit++,Y.p){const j=Y.p;Y.p=new Array(Y.lit);for(let X=0;X<Y.lit-1;++X)Y.p[X]=j[X]}else Y.p=new Array(1);Y.p[Y.lit-1]=j}else if(K){let Y=0;for(let U=1<<I-K;U>0;U--){const U=u[(X<<I-K)+Y];if(U.len||U.p)throw new Error("Invalid table entry");U.len=K,U.lit=j,Y++}}}}(d,e,a,M),function(Y,j,X,u,K,U,y,T,E){let e=0,a=0;const N=y,d=Math.trunc(u.value+(K+7)/8);for(;u.value<d;){let K=L(e,a,X,u);for(e=K.c,a=K.lc;a>=I;){const y=j[e>>a-I&16383];if(y.len){a-=y.len;const Y=J(y.lit,U,e,a,X,u,T,E,N);Y&&(e=Y.c,a=Y.lc)}else{if(!y.p)throw new Error("hufDecode issues");let j;for(j=0;j<y.lit;j++){const I=p(Y[y.p[j]]);for(;a<I&&u.value<d;)K=L(e,a,X,u),e=K.c,a=K.lc;if(a>=I&&b(Y[y.p[j]])==(e>>a-I&(1<<I)-1)){a-=I;const Y=J(y.p[j],U,e,a,X,u,T,E,N);Y&&(e=Y.c,a=Y.lc);break}}if(j==y.lit)throw new Error("HufDecode issues")}}}const i=8-K&7;for(e>>=i,a-=i;a>0;){const Y=j[e<<I-a&16383];if(!Y.len)throw new Error("HufDecode issues");{a-=Y.len;const j=J(Y.lit,U,e,a,X,u,T,E,N);j&&(e=j.c,a=j.lc)}}}(d,M,Y,X,N,a,U,K,{value:0})}function w(Y){return 65535&Y}function H(Y){const j=w(Y);return j>32767?j-65536:j}function G(Y,j){const X=H(Y),u=H(j),K=X+(1&u)+(u>>1);return{a:K,b:K-u}}function l(Y,j){const X=w(Y),u=w(j),K=X-(u>>1)&65535;return{a:u+K-32768&65535,b:K}}function h(Y,j,X,u,K,U,I){const y=I<16384,T=X>K?K:X;let E,e,a=1;for(;a<=T;)a<<=1;for(a>>=1,E=a,a>>=1;a>=1;){e=0;const I=e+U*(K-E),T=U*a,N=U*E,d=u*a,i=u*E;let M,R,C,O;for(;e<=I;e+=N){let K=e;const U=e+u*(X-E);for(;K<=U;K+=i){const X=K+d,u=K+T,U=u+d;if(y){let I=G(Y[K+j],Y[u+j]);M=I.a,C=I.b,I=G(Y[X+j],Y[U+j]),R=I.a,O=I.b,I=G(M,R),Y[K+j]=I.a,Y[X+j]=I.b,I=G(C,O),Y[u+j]=I.a,Y[U+j]=I.b}else{let I=l(Y[K+j],Y[u+j]);M=I.a,C=I.b,I=l(Y[X+j],Y[U+j]),R=I.a,O=I.b,I=l(M,R),Y[K+j]=I.a,Y[X+j]=I.b,I=l(C,O),Y[u+j]=I.a,Y[U+j]=I.b}}if(X&a){const X=K+T;let u;u=y?G(Y[K+j],Y[X+j]):l(Y[K+j],Y[X+j]),M=u.a,Y[X+j]=u.b,Y[K+j]=M}}if(K&a){let K=e;const U=e+u*(X-E);for(;K<=U;K+=i){const X=K+d;let u;u=y?G(Y[K+j],Y[X+j]):l(Y[K+j],Y[X+j]),M=u.a,Y[X+j]=u.b,Y[K+j]=M}}E=a,a>>=1}return e}function o(Y){return new DataView(Y.array.buffer,Y.offset.value,Y.size)}function g(Y){const j=Y.viewer.buffer.slice(Y.offset.value,Y.offset.value+Y.size),X=new Uint8Array(function(Y){let j=Y.byteLength;const X=new Array;let u=0;const K=new DataView(Y);for(;j>0;){const Y=K.getInt8(u++);if(Y<0){const U=-Y;j-=U+1;for(let Y=0;Y<U;Y++)X.push(K.getUint8(u++))}else{const U=Y;j-=2;const I=K.getUint8(u++);for(let Y=0;Y<U+1;Y++)X.push(I)}}return X}(j)),u=new Uint8Array(X.length);return z(X),k(X,u),new DataView(u.buffer)}function n(Y){const j=Y.array.slice(Y.offset.value,Y.offset.value+Y.size),X=fflate.unzlibSync(j),u=new Uint8Array(X.length);return z(X),k(X,u),new DataView(u.buffer)}function f(Y){const j=Y.array.slice(Y.offset.value,Y.offset.value+Y.size),X=fflate.unzlibSync(j),u=Y.lines*Y.channels*Y.width,K=1==Y.type?new Uint16Array(u):new Uint32Array(u);let U=0,I=0;const y=new Array(4);for(let T=0;T<Y.lines;T++)for(let j=0;j<Y.channels;j++){let j=0;switch(Y.type){case 1:y[0]=U,y[1]=y[0]+Y.width,U=y[1]+Y.width;for(let u=0;u<Y.width;++u){j+=X[y[0]++]<<8|X[y[1]++],K[I]=j,I++}break;case 2:y[0]=U,y[1]=y[0]+Y.width,y[2]=y[1]+Y.width,U=y[2]+Y.width;for(let u=0;u<Y.width;++u){j+=X[y[0]++]<<24|X[y[1]++]<<16|X[y[2]++]<<8,K[I]=j,I++}}}return new DataView(K.buffer)}function q(Y){const j=Y.viewer,X={value:Y.offset.value},u=new Uint16Array(Y.width*Y.scanlineBlockSize*(Y.channels*Y.type)),K=new Uint8Array(8192);let I=0;const y=new Array(Y.channels);for(let U=0;U<Y.channels;U++)y[U]={},y[U].start=I,y[U].end=y[U].start,y[U].nx=Y.width,y[U].ny=Y.lines,y[U].size=Y.type,I+=y[U].nx*y[U].ny*y[U].size;const T=R(j,X),E=R(j,X);if(E>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(T<=E)for(let U=0;U<E-T+1;U++)K[U+T]=M(j,X);const e=new Uint16Array(U),a=function(Y,j){let X=0;for(let K=0;K<U;++K)(0==K||Y[K>>3]&1<<(7&K))&&(j[X++]=K);const u=X-1;for(;X<U;)j[X++]=0;return u}(K,e),N=i(j,X);B(Y.array,j,X,N,u,I);for(let U=0;U<Y.channels;++U){const Y=y[U];for(let j=0;j<y[U].size;++j)h(u,Y.start+j,Y.nx,Y.size,Y.ny,Y.nx*Y.size,a)}!function(Y,j,X){for(let u=0;u<X;++u)j[u]=Y[j[u]]}(e,u,I);let d=0;const C=new Uint8Array(u.buffer.byteLength);for(let U=0;U<Y.lines;U++)for(let j=0;j<Y.channels;j++){const Y=y[j],X=Y.nx*Y.size,K=new Uint8Array(u.buffer,2*Y.end,2*X);C.set(K,d),d+=2*X,Y.end+=X}return new DataView(C.buffer)}var F,S=X(10748);!function(Y){Y[Y.Float=0]="Float",Y[Y.HalfFloat=1]="HalfFloat"}(F||(F={}));class A{}A.DefaultOutputType=F.HalfFloat,A.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class c{constructor(){this.supportCascades=!1}loadCubeData(Y,j,X,u,K){throw".exr not supported in Cube."}async loadData(Y,j,X){const K=new DataView(Y.buffer),U={value:0},I=function(Y,j){if(20000630!=Y.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const X=Y.getUint8(4),K=Y.getUint8(5),U={singleTile:!!(2&K),longName:!!(4&K),deepFormat:!!(8&K),multiPart:!!(16&K)};j.value=8;const I={};let y=!0;for(;y;){const X=N(Y.buffer,j);if(X){const K=N(Y.buffer,j),U=r(Y,j,K,i(Y,j));void 0===U?u.c.Warn(`Unknown header attribute type ${K}'.`):I[X]=U}else y=!1}if(0!=(-5&K))throw new Error("Unsupported file format");return{version:X,spec:U,...I}}(K,U),y=await async function(Y,j,X,u){const K={size:0,viewer:j,array:new Uint8Array(j.buffer),offset:X,width:Y.dataWindow.xMax-Y.dataWindow.xMin+1,height:Y.dataWindow.yMax-Y.dataWindow.yMin+1,channels:Y.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Y.compression){case E.NO_COMPRESSION:K.lines=1,K.uncompress=o;break;case E.RLE_COMPRESSION:K.lines=1,K.uncompress=g;break;case E.ZIPS_COMPRESSION:K.lines=1,K.uncompress=n,await S.c.LoadScriptAsync(A.FFLATEUrl);break;case E.ZIP_COMPRESSION:K.lines=16,K.uncompress=n,await S.c.LoadScriptAsync(A.FFLATEUrl);break;case E.PIZ_COMPRESSION:K.lines=32,K.uncompress=q;break;case E.PXR24_COMPRESSION:K.lines=16,K.uncompress=f,await S.c.LoadScriptAsync(A.FFLATEUrl);break;default:throw new Error(E[Y.compression]+" is unsupported")}K.scanlineBlockSize=K.lines;const U={};for(const E of Y.channels)switch(E.name){case"Y":case"R":case"G":case"B":case"A":U[E.name]=!0,K.type=E.pixelType}let I=!1;if(U.R&&U.G&&U.B)I=!U.A,K.outputChannels=4,K.decodeChannels={R:0,G:1,B:2,A:3};else{if(!U.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");K.outputChannels=1,K.decodeChannels={Y:0}}if(1===K.type)switch(u){case F.Float:K.getter=Q,K.inputSize=2;break;case F.HalfFloat:K.getter=R,K.inputSize=2}else{if(2!==K.type)throw new Error("Unsupported pixelType "+K.type+" for "+Y.compression);switch(u){case F.Float:K.getter=P,K.inputSize=4;break;case F.HalfFloat:K.getter=W,K.inputSize=4}}K.blockCount=K.height/K.scanlineBlockSize;for(let E=0;E<K.blockCount;E++)O(j,X);const y=K.width*K.height*K.outputChannels;switch(u){case F.Float:K.byteArray=new Float32Array(y),K.textureType=1,I&&K.byteArray.fill(1,0,y);break;case F.HalfFloat:K.byteArray=new Uint16Array(y),K.textureType=2,I&&K.byteArray.fill(15360,0,y);break;default:throw new Error("Unsupported type: "+u)}let T=0;for(const E of Y.channels)void 0!==K.decodeChannels[E.name]&&(K.channelLineOffsets[E.name]=T*K.width),T+=2*E.pixelType;return K.bytesPerLine=K.width*T,K.outLineWidth=K.width*K.outputChannels,"INCREASING_Y"===Y.lineOrder?K.scanOrder=Y=>Y:K.scanOrder=Y=>K.height-1-Y,4==K.outputChannels?(K.format=5,K.linearSpace=!0):(K.format=6,K.linearSpace=!1),K}(I,K,U,A.DefaultOutputType);!function(Y,j,X,u){const K={value:0};for(let U=0;U<Y.height/Y.scanlineBlockSize;U++){const I=d(X,u)-j.dataWindow.yMin;Y.size=i(X,u),Y.lines=I+Y.scanlineBlockSize>Y.height?Y.height-I:Y.scanlineBlockSize;const y=Y.size<Y.lines*Y.bytesPerLine&&Y.uncompress?Y.uncompress(Y):o(Y);u.value+=Y.size;for(let X=0;X<Y.scanlineBlockSize;X++){const u=U*Y.scanlineBlockSize,I=X+Y.scanOrder(u);if(I>=Y.height)continue;const T=X*Y.bytesPerLine,E=(Y.height-1-I)*Y.outLineWidth;for(let X=0;X<Y.channels;X++){const u=j.channels[X].name,U=Y.channelLineOffsets[u],I=Y.decodeChannels[u];if(void 0!==I){K.value=T+U;for(let j=0;j<Y.width;j++){const X=E+j*Y.outputChannels+I;Y.byteArray&&(Y.byteArray[X]=Y.getter(y,K))}}}}}}(y,I,K,U);X(I.dataWindow.xMax-I.dataWindow.xMin+1,I.dataWindow.yMax-I.dataWindow.yMin+1,j.generateMipMaps,!1,(()=>{const Y=j.getEngine();j.format=I.format,j.type=y.textureType,j.invertY=!1,j._gammaSpace=!I.linearSpace,y.byteArray&&Y._uploadDataToTextureDirectly(j,y.byteArray,0,0,void 0,!0)}))}}}}]);