"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12853:(N,q,R)=>{R.r(q),R.d(q,{_ExrTextureLoader:()=>K});var z=R(10907),v=R(11197);const B=65536,F=14,S=65537,A=16384;var y,E;!function(N){N[N.NO_COMPRESSION=0]="NO_COMPRESSION",N[N.RLE_COMPRESSION=1]="RLE_COMPRESSION",N[N.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",N[N.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",N[N.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",N[N.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(y||(y={})),function(N){N[N.INCREASING_Y=0]="INCREASING_Y",N[N.DECREASING_Y=1]="DECREASING_Y"}(E||(E={}));const t=function(){const N=new ArrayBuffer(4),q=new Float32Array(N),R=new Uint32Array(N),z=new Uint32Array(512),v=new Uint32Array(512);for(let A=0;A<256;++A){const N=A-127;N<-27?(z[A]=0,z[256|A]=32768,v[A]=24,v[256|A]=24):N<-14?(z[A]=1024>>-N-14,z[256|A]=1024>>-N-14|32768,v[A]=-N-1,v[256|A]=-N-1):N<=15?(z[A]=N+15<<10,z[256|A]=N+15<<10|32768,v[A]=13,v[256|A]=13):N<128?(z[A]=31744,z[256|A]=64512,v[A]=24,v[256|A]=24):(z[A]=31744,z[256|A]=64512,v[A]=13,v[256|A]=13)}const B=new Uint32Array(2048),F=new Uint32Array(64),S=new Uint32Array(64);for(let A=1;A<1024;++A){let N=A<<13,q=0;for(;0===(8388608&N);)N<<=1,q-=8388608;N&=-8388609,q+=947912704,B[A]=N|q}for(let A=1024;A<2048;++A)B[A]=939524096+(A-1024<<13);for(let A=1;A<31;++A)F[A]=A<<23;F[31]=1199570944,F[32]=2147483648;for(let A=33;A<63;++A)F[A]=2147483648+(A-32<<23);F[63]=3347054592;for(let A=1;A<64;++A)32!==A&&(S[A]=1024);return{floatView:q,uint32View:R,baseTable:z,shiftTable:v,mantissaTable:B,exponentTable:F,offsetTable:S}}();function x(N,q){const R=new Uint8Array(N);let z=0;for(;0!=R[q.value+z];)z+=1;const v=(new TextDecoder).decode(R.slice(q.value,q.value+z));return q.value=q.value+z+1,v}function e(N,q){const R=N.getInt32(q.value,!0);return q.value+=4,R}function b(N,q){const R=N.getUint32(q.value,!0);return q.value+=4,R}function f(N,q){const R=N.getUint8(q.value);return q.value+=1,R}function D(N,q){const R=N.getUint16(q.value,!0);return q.value+=2,R}function V(N,q){const R=N[q.value];return q.value+=1,R}function H(N,q){let R;return R="getBigInt64"in DataView.prototype?Number(N.getBigInt64(q.value,!0)):N.getUint32(q.value+4,!0)+Number(N.getUint32(q.value,!0)<<32),q.value+=8,R}function Y(N,q){const R=N.getFloat32(q.value,!0);return q.value+=4,R}function T(N,q){return function(N){const q=(31744&N)>>10,R=1023&N;return(N>>15?-1:1)*(q?31===q?R?NaN:1/0:Math.pow(2,q-15)*(1+R/1024):R/1024*6103515625e-14)}(D(N,q))}function L(N,q){return function(N){if(Math.abs(N)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");N=(0,v.c)(N,-65504,65504),t.floatView[0]=N;const q=t.uint32View[0],R=q>>23&511;return t.baseTable[R]+((8388607&q)>>t.shiftTable[R])}(Y(N,q))}function X(N,q,R,z){switch(R){case"string":case"stringvector":case"iccProfile":return function(N,q,R){const z=(new TextDecoder).decode(new Uint8Array(N).slice(q.value,q.value+R));return q.value=q.value+R,z}(N.buffer,q,z);case"chlist":return function(N,q,R){const z=q.value,v=[];for(;q.value<z+R-1;){const R=x(N.buffer,q),z=e(N,q),B=f(N,q);q.value+=3;const F=e(N,q),S=e(N,q);v.push({name:R,pixelType:z,pLinear:B,xSampling:F,ySampling:S})}return q.value+=1,v}(N,q,z);case"chromaticities":return function(N,q){return{redX:Y(N,q),redY:Y(N,q),greenX:Y(N,q),greenY:Y(N,q),blueX:Y(N,q),blueY:Y(N,q),whiteX:Y(N,q),whiteY:Y(N,q)}}(N,q);case"compression":return function(N,q){return f(N,q)}(N,q);case"box2i":return function(N,q){return{xMin:e(N,q),yMin:e(N,q),xMax:e(N,q),yMax:e(N,q)}}(N,q);case"lineOrder":return function(N,q){const R=f(N,q);return E[R]}(N,q);case"float":return Y(N,q);case"v2f":return function(N,q){return[Y(N,q),Y(N,q)]}(N,q);case"v3f":return function(N,q){return[Y(N,q),Y(N,q),Y(N,q)]}(N,q);case"int":return e(N,q);case"rational":return function(N,q){return[e(N,q),b(N,q)]}(N,q);case"timecode":return function(N,q){return[b(N,q),b(N,q)]}(N,q);case"preview":return q.value+=z,"skipped";default:return void(q.value+=z)}}function Q(N){for(let q=1;q<N.length;q++){const R=N[q-1]+N[q]-128;N[q]=R}}function h(N,q){let R=0,z=Math.floor((N.length+1)/2),v=0;const B=N.length-1;for(;!(v>B)&&(q[v++]=N[R++],!(v>B));)q[v++]=N[z++]}function u(N,q,R,z,v){for(;R<N;)q=q<<8|V(z,v),R+=8;return{l:q>>(R-=N)&(1<<N)-1,c:q,lc:R}}function w(N,q,R,z){return{c:N=N<<8|V(R,z),lc:q+=8}}function c(N,q,R,z,v,B,F,S,A){if(N==q){if(z<8){const N=w(R,z,v,B);R=N.c,z=N.lc}let N=R>>(z-=8);if(N=new Uint8Array([N])[0],S.value+N>A)return null;const q=F[S.value-1];for(;N-- >0;)F[S.value++]=q}else{if(!(S.value<A))return null;F[S.value++]=N}return{c:R,lc:z}}const n=new Array(59);function G(N,q,R,z,v,B){const F=q;let A=0,y=0;for(;z<=v;z++){if(F.value-q.value>R)return;let S=u(6,A,y,N,F);const E=S.l;if(A=S.c,y=S.lc,B[z]=E,63==E){if(F.value-q.value>R)throw new Error("Error in HufUnpackEncTable");S=u(8,A,y,N,F);let E=S.l+6;if(A=S.c,y=S.lc,z+E>v+1)throw new Error("Error in HufUnpackEncTable");for(;E--;)B[z++]=0;z--}else if(E>=59){let N=E-59+2;if(z+N>v+1)throw new Error("Error in HufUnpackEncTable");for(;N--;)B[z++]=0;z--}}!function(N){for(let R=0;R<=58;++R)n[R]=0;for(let R=0;R<S;++R)n[N[R]]+=1;let q=0;for(let R=58;R>0;--R){const N=q+n[R]>>1;n[R]=q,q=N}for(let R=0;R<S;++R){const q=N[R];q>0&&(N[R]=q|n[q]++<<6)}}(B)}function s(N){return 63&N}function Z(N){return N>>6}function J(N,q,R,z,v,B){const y=R.value,E=b(q,R),t=b(q,R);R.value+=4;const x=b(q,R);if(R.value+=4,E<0||E>=S||t<0||t>=S)throw new Error("Wrong HUF_ENCSIZE");const e=new Array(S),f=new Array(A);!function(N){for(let q=0;q<A;q++)N[q]={},N[q].len=0,N[q].lit=0,N[q].p=null}(f);if(G(N,R,z-(R.value-y),E,t,e),x>8*(z-(R.value-y)))throw new Error("Wrong hufUncompress");!function(N,q,R,z){for(;q<=R;q++){const R=Z(N[q]),v=s(N[q]);if(R>>v)throw new Error("Invalid table entry");if(v>F){const N=z[R>>v-F];if(N.len)throw new Error("Invalid table entry");if(N.lit++,N.p){const q=N.p;N.p=new Array(N.lit);for(let R=0;R<N.lit-1;++R)N.p[R]=q[R]}else N.p=new Array(1);N.p[N.lit-1]=q}else if(v){let N=0;for(let B=1<<F-v;B>0;B--){const B=z[(R<<F-v)+N];if(B.len||B.p)throw new Error("Invalid table entry");B.len=v,B.lit=q,N++}}}}(e,E,t,f),function(N,q,R,z,v,B,S,A,y){let E=0,t=0;const x=S,e=Math.trunc(z.value+(v+7)/8);for(;z.value<e;){let v=w(E,t,R,z);for(E=v.c,t=v.lc;t>=F;){const S=q[E>>t-F&16383];if(S.len){t-=S.len;const N=c(S.lit,B,E,t,R,z,A,y,x);N&&(E=N.c,t=N.lc)}else{if(!S.p)throw new Error("hufDecode issues");let q;for(q=0;q<S.lit;q++){const F=s(N[S.p[q]]);for(;t<F&&z.value<e;)v=w(E,t,R,z),E=v.c,t=v.lc;if(t>=F&&Z(N[S.p[q]])==(E>>t-F&(1<<F)-1)){t-=F;const N=c(S.p[q],B,E,t,R,z,A,y,x);N&&(E=N.c,t=N.lc);break}}if(q==S.lit)throw new Error("HufDecode issues")}}}const b=8-v&7;for(E>>=b,t-=b;t>0;){const N=q[E<<F-t&16383];if(!N.len)throw new Error("HufDecode issues");{t-=N.len;const q=c(N.lit,B,E,t,R,z,A,y,x);q&&(E=q.c,t=q.lc)}}}(e,f,N,R,x,t,B,v,{value:0})}function M(N){return 65535&N}function m(N){const q=M(N);return q>32767?q-65536:q}function g(N,q){const R=m(N),z=m(q),v=R+(1&z)+(z>>1);return{a:v,b:v-z}}function j(N,q){const R=M(N),z=M(q),v=R-(z>>1)&65535;return{a:z+v-32768&65535,b:v}}function l(N,q,R,z,v,B,F){const S=F<16384,A=R>v?v:R;let y,E,t=1;for(;t<=A;)t<<=1;for(t>>=1,y=t,t>>=1;t>=1;){E=0;const F=E+B*(v-y),A=B*t,x=B*y,e=z*t,b=z*y;let f,D,V,H;for(;E<=F;E+=x){let v=E;const B=E+z*(R-y);for(;v<=B;v+=b){const R=v+e,z=v+A,B=z+e;if(S){let F=g(N[v+q],N[z+q]);f=F.a,V=F.b,F=g(N[R+q],N[B+q]),D=F.a,H=F.b,F=g(f,D),N[v+q]=F.a,N[R+q]=F.b,F=g(V,H),N[z+q]=F.a,N[B+q]=F.b}else{let F=j(N[v+q],N[z+q]);f=F.a,V=F.b,F=j(N[R+q],N[B+q]),D=F.a,H=F.b,F=j(f,D),N[v+q]=F.a,N[R+q]=F.b,F=j(V,H),N[z+q]=F.a,N[B+q]=F.b}}if(R&t){const R=v+A;let z;z=S?g(N[v+q],N[R+q]):j(N[v+q],N[R+q]),f=z.a,N[R+q]=z.b,N[v+q]=f}}if(v&t){let v=E;const B=E+z*(R-y);for(;v<=B;v+=b){const R=v+e;let z;z=S?g(N[v+q],N[R+q]):j(N[v+q],N[R+q]),f=z.a,N[R+q]=z.b,N[v+q]=f}}y=t,t>>=1}return E}function I(N){return new DataView(N.array.buffer,N.offset.value,N.size)}function U(N){const q=N.viewer.buffer.slice(N.offset.value,N.offset.value+N.size),R=new Uint8Array(function(N){let q=N.byteLength;const R=new Array;let z=0;const v=new DataView(N);for(;q>0;){const N=v.getInt8(z++);if(N<0){const B=-N;q-=B+1;for(let N=0;N<B;N++)R.push(v.getUint8(z++))}else{const B=N;q-=2;const F=v.getUint8(z++);for(let N=0;N<B+1;N++)R.push(F)}}return R}(q)),z=new Uint8Array(R.length);return Q(R),h(R,z),new DataView(z.buffer)}function O(N){const q=N.array.slice(N.offset.value,N.offset.value+N.size),R=fflate.unzlibSync(q),z=new Uint8Array(R.length);return Q(R),h(R,z),new DataView(z.buffer)}function i(N){const q=N.array.slice(N.offset.value,N.offset.value+N.size),R=fflate.unzlibSync(q),z=N.lines*N.channels*N.width,v=1==N.type?new Uint16Array(z):new Uint32Array(z);let B=0,F=0;const S=new Array(4);for(let A=0;A<N.lines;A++)for(let q=0;q<N.channels;q++){let q=0;switch(N.type){case 1:S[0]=B,S[1]=S[0]+N.width,B=S[1]+N.width;for(let z=0;z<N.width;++z){q+=R[S[0]++]<<8|R[S[1]++],v[F]=q,F++}break;case 2:S[0]=B,S[1]=S[0]+N.width,S[2]=S[1]+N.width,B=S[2]+N.width;for(let z=0;z<N.width;++z){q+=R[S[0]++]<<24|R[S[1]++]<<16|R[S[2]++]<<8,v[F]=q,F++}}}return new DataView(v.buffer)}function P(N){const q=N.viewer,R={value:N.offset.value},z=new Uint16Array(N.width*N.scanlineBlockSize*(N.channels*N.type)),v=new Uint8Array(8192);let F=0;const S=new Array(N.channels);for(let B=0;B<N.channels;B++)S[B]={},S[B].start=F,S[B].end=S[B].start,S[B].nx=N.width,S[B].ny=N.lines,S[B].size=N.type,F+=S[B].nx*S[B].ny*S[B].size;const A=D(q,R),y=D(q,R);if(y>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(A<=y)for(let B=0;B<y-A+1;B++)v[B+A]=f(q,R);const E=new Uint16Array(B),t=function(N,q){let R=0;for(let v=0;v<B;++v)(0==v||N[v>>3]&1<<(7&v))&&(q[R++]=v);const z=R-1;for(;R<B;)q[R++]=0;return z}(v,E),x=b(q,R);J(N.array,q,R,x,z,F);for(let B=0;B<N.channels;++B){const N=S[B];for(let q=0;q<S[B].size;++q)l(z,N.start+q,N.nx,N.size,N.ny,N.nx*N.size,t)}!function(N,q,R){for(let z=0;z<R;++z)q[z]=N[q[z]]}(E,z,F);let e=0;const V=new Uint8Array(z.buffer.byteLength);for(let B=0;B<N.lines;B++)for(let q=0;q<N.channels;q++){const N=S[q],R=N.nx*N.size,v=new Uint8Array(z.buffer,2*N.end,2*R);V.set(v,e),e+=2*R,N.end+=R}return new DataView(V.buffer)}var k,o=R(10888);!function(N){N[N.Float=0]="Float",N[N.HalfFloat=1]="HalfFloat"}(k||(k={}));class C{}C.DefaultOutputType=k.HalfFloat,C.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class K{constructor(){this.supportCascades=!1}loadCubeData(N,q,R,z,v){throw".exr not supported in Cube."}async loadData(N,q,R){const v=new DataView(N.buffer),B={value:0},F=function(N,q){if(20000630!=N.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const R=N.getUint8(4),v=N.getUint8(5),B={singleTile:!!(2&v),longName:!!(4&v),deepFormat:!!(8&v),multiPart:!!(16&v)};q.value=8;const F={};let S=!0;for(;S;){const R=x(N.buffer,q);if(R){const v=x(N.buffer,q),B=X(N,q,v,b(N,q));void 0===B?z.c.Warn(`Unknown header attribute type ${v}'.`):F[R]=B}else S=!1}if(0!=(-5&v))throw new Error("Unsupported file format");return{version:R,spec:B,...F}}(v,B),S=await async function(N,q,R,z){const v={size:0,viewer:q,array:new Uint8Array(q.buffer),offset:R,width:N.dataWindow.xMax-N.dataWindow.xMin+1,height:N.dataWindow.yMax-N.dataWindow.yMin+1,channels:N.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(N.compression){case y.NO_COMPRESSION:v.lines=1,v.uncompress=I;break;case y.RLE_COMPRESSION:v.lines=1,v.uncompress=U;break;case y.ZIPS_COMPRESSION:v.lines=1,v.uncompress=O,await o.f.LoadScriptAsync(C.FFLATEUrl);break;case y.ZIP_COMPRESSION:v.lines=16,v.uncompress=O,await o.f.LoadScriptAsync(C.FFLATEUrl);break;case y.PIZ_COMPRESSION:v.lines=32,v.uncompress=P;break;case y.PXR24_COMPRESSION:v.lines=16,v.uncompress=i,await o.f.LoadScriptAsync(C.FFLATEUrl);break;default:throw new Error(y[N.compression]+" is unsupported")}v.scanlineBlockSize=v.lines;const B={};for(const y of N.channels)switch(y.name){case"Y":case"R":case"G":case"B":case"A":B[y.name]=!0,v.type=y.pixelType}let F=!1;if(B.R&&B.G&&B.B)F=!B.A,v.outputChannels=4,v.decodeChannels={R:0,G:1,B:2,A:3};else{if(!B.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");v.outputChannels=1,v.decodeChannels={Y:0}}if(1===v.type)switch(z){case k.Float:v.getter=T,v.inputSize=2;break;case k.HalfFloat:v.getter=D,v.inputSize=2}else{if(2!==v.type)throw new Error("Unsupported pixelType "+v.type+" for "+N.compression);switch(z){case k.Float:v.getter=Y,v.inputSize=4;break;case k.HalfFloat:v.getter=L,v.inputSize=4}}v.blockCount=v.height/v.scanlineBlockSize;for(let y=0;y<v.blockCount;y++)H(q,R);const S=v.width*v.height*v.outputChannels;switch(z){case k.Float:v.byteArray=new Float32Array(S),v.textureType=1,F&&v.byteArray.fill(1,0,S);break;case k.HalfFloat:v.byteArray=new Uint16Array(S),v.textureType=2,F&&v.byteArray.fill(15360,0,S);break;default:throw new Error("Unsupported type: "+z)}let A=0;for(const y of N.channels)void 0!==v.decodeChannels[y.name]&&(v.channelLineOffsets[y.name]=A*v.width),A+=2*y.pixelType;return v.bytesPerLine=v.width*A,v.outLineWidth=v.width*v.outputChannels,"INCREASING_Y"===N.lineOrder?v.scanOrder=N=>N:v.scanOrder=N=>v.height-1-N,4==v.outputChannels?(v.format=5,v.linearSpace=!0):(v.format=6,v.linearSpace=!1),v}(F,v,B,C.DefaultOutputType);!function(N,q,R,z){const v={value:0};for(let B=0;B<N.height/N.scanlineBlockSize;B++){const F=e(R,z)-q.dataWindow.yMin;N.size=b(R,z),N.lines=F+N.scanlineBlockSize>N.height?N.height-F:N.scanlineBlockSize;const S=N.size<N.lines*N.bytesPerLine&&N.uncompress?N.uncompress(N):I(N);z.value+=N.size;for(let R=0;R<N.scanlineBlockSize;R++){const z=B*N.scanlineBlockSize,F=R+N.scanOrder(z);if(F>=N.height)continue;const A=R*N.bytesPerLine,y=(N.height-1-F)*N.outLineWidth;for(let R=0;R<N.channels;R++){const z=q.channels[R].name,B=N.channelLineOffsets[z],F=N.decodeChannels[z];if(void 0!==F){v.value=A+B;for(let q=0;q<N.width;q++){const R=y+q*N.outputChannels+F;N.byteArray&&(N.byteArray[R]=N.getter(S,v))}}}}}}(S,F,v,B);R(F.dataWindow.xMax-F.dataWindow.xMin+1,F.dataWindow.yMax-F.dataWindow.yMin+1,q.generateMipMaps,!1,(()=>{const N=q.getEngine();q.format=F.format,q.type=S.textureType,q.invertY=!1,q._gammaSpace=!F.linearSpace,S.byteArray&&N._uploadDataToTextureDirectly(q,S.byteArray,0,0,void 0,!0)}))}}}}]);