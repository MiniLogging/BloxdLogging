"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12934:(O,f,y)=>{y.r(f),y.d(f,{_ExrTextureLoader:()=>K});var S=y(11017),H=y(11345);const b=65536,h=14,v=65537,N=16384;var m,t;!function(O){O[O.NO_COMPRESSION=0]="NO_COMPRESSION",O[O.RLE_COMPRESSION=1]="RLE_COMPRESSION",O[O.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",O[O.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",O[O.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",O[O.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(m||(m={})),function(O){O[O.INCREASING_Y=0]="INCREASING_Y",O[O.DECREASING_Y=1]="DECREASING_Y"}(t||(t={}));const q=function(){const O=new ArrayBuffer(4),f=new Float32Array(O),y=new Uint32Array(O),S=new Uint32Array(512),H=new Uint32Array(512);for(let N=0;N<256;++N){const O=N-127;O<-27?(S[N]=0,S[256|N]=32768,H[N]=24,H[256|N]=24):O<-14?(S[N]=1024>>-O-14,S[256|N]=1024>>-O-14|32768,H[N]=-O-1,H[256|N]=-O-1):O<=15?(S[N]=O+15<<10,S[256|N]=O+15<<10|32768,H[N]=13,H[256|N]=13):O<128?(S[N]=31744,S[256|N]=64512,H[N]=24,H[256|N]=24):(S[N]=31744,S[256|N]=64512,H[N]=13,H[256|N]=13)}const b=new Uint32Array(2048),h=new Uint32Array(64),v=new Uint32Array(64);for(let N=1;N<1024;++N){let O=N<<13,f=0;for(;0===(8388608&O);)O<<=1,f-=8388608;O&=-8388609,f+=947912704,b[N]=O|f}for(let N=1024;N<2048;++N)b[N]=939524096+(N-1024<<13);for(let N=1;N<31;++N)h[N]=N<<23;h[31]=1199570944,h[32]=2147483648;for(let N=33;N<63;++N)h[N]=2147483648+(N-32<<23);h[63]=3347054592;for(let N=1;N<64;++N)32!==N&&(v[N]=1024);return{floatView:f,uint32View:y,baseTable:S,shiftTable:H,mantissaTable:b,exponentTable:h,offsetTable:v}}();function F(O,f){const y=new Uint8Array(O);let S=0;for(;0!=y[f.value+S];)S+=1;const H=(new TextDecoder).decode(y.slice(f.value,f.value+S));return f.value=f.value+S+1,H}function I(O,f){const y=O.getInt32(f.value,!0);return f.value+=4,y}function A(O,f){const y=O.getUint32(f.value,!0);return f.value+=4,y}function J(O,f){const y=O.getUint8(f.value);return f.value+=1,y}function X(O,f){const y=O.getUint16(f.value,!0);return f.value+=2,y}function w(O,f){const y=O[f.value];return f.value+=1,y}function B(O,f){let y;return y="getBigInt64"in DataView.prototype?Number(O.getBigInt64(f.value,!0)):O.getUint32(f.value+4,!0)+Number(O.getUint32(f.value,!0)<<32),f.value+=8,y}function j(O,f){const y=O.getFloat32(f.value,!0);return f.value+=4,y}function u(O,f){return function(O){const f=(31744&O)>>10,y=1023&O;return(O>>15?-1:1)*(f?31===f?y?NaN:1/0:Math.pow(2,f-15)*(1+y/1024):y/1024*6103515625e-14)}(X(O,f))}function L(O,f){return function(O){if(Math.abs(O)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");O=(0,H.c)(O,-65504,65504),q.floatView[0]=O;const f=q.uint32View[0],y=f>>23&511;return q.baseTable[y]+((8388607&f)>>q.shiftTable[y])}(j(O,f))}function p(O,f,y,S){switch(y){case"string":case"stringvector":case"iccProfile":return function(O,f,y){const S=(new TextDecoder).decode(new Uint8Array(O).slice(f.value,f.value+y));return f.value=f.value+y,S}(O.buffer,f,S);case"chlist":return function(O,f,y){const S=f.value,H=[];for(;f.value<S+y-1;){const y=F(O.buffer,f),S=I(O,f),b=J(O,f);f.value+=3;const h=I(O,f),v=I(O,f);H.push({name:y,pixelType:S,pLinear:b,xSampling:h,ySampling:v})}return f.value+=1,H}(O,f,S);case"chromaticities":return function(O,f){return{redX:j(O,f),redY:j(O,f),greenX:j(O,f),greenY:j(O,f),blueX:j(O,f),blueY:j(O,f),whiteX:j(O,f),whiteY:j(O,f)}}(O,f);case"compression":return function(O,f){return J(O,f)}(O,f);case"box2i":return function(O,f){return{xMin:I(O,f),yMin:I(O,f),xMax:I(O,f),yMax:I(O,f)}}(O,f);case"lineOrder":return function(O,f){const y=J(O,f);return t[y]}(O,f);case"float":return j(O,f);case"v2f":return function(O,f){return[j(O,f),j(O,f)]}(O,f);case"v3f":return function(O,f){return[j(O,f),j(O,f),j(O,f)]}(O,f);case"int":return I(O,f);case"rational":return function(O,f){return[I(O,f),A(O,f)]}(O,f);case"timecode":return function(O,f){return[A(O,f),A(O,f)]}(O,f);case"preview":return f.value+=S,"skipped";default:return void(f.value+=S)}}function U(O){for(let f=1;f<O.length;f++){const y=O[f-1]+O[f]-128;O[f]=y}}function l(O,f){let y=0,S=Math.floor((O.length+1)/2),H=0;const b=O.length-1;for(;!(H>b)&&(f[H++]=O[y++],!(H>b));)f[H++]=O[S++]}function x(O,f,y,S,H){for(;y<O;)f=f<<8|w(S,H),y+=8;return{l:f>>(y-=O)&(1<<O)-1,c:f,lc:y}}function W(O,f,y,S){return{c:O=O<<8|w(y,S),lc:f+=8}}function E(O,f,y,S,H,b,h,v,N){if(O==f){if(S<8){const O=W(y,S,H,b);y=O.c,S=O.lc}let O=y>>(S-=8);if(O=new Uint8Array([O])[0],v.value+O>N)return null;const f=h[v.value-1];for(;O-- >0;)h[v.value++]=f}else{if(!(v.value<N))return null;h[v.value++]=O}return{c:y,lc:S}}const o=new Array(59);function i(O,f,y,S,H,b){const h=f;let N=0,m=0;for(;S<=H;S++){if(h.value-f.value>y)return;let v=x(6,N,m,O,h);const t=v.l;if(N=v.c,m=v.lc,b[S]=t,63==t){if(h.value-f.value>y)throw new Error("Error in HufUnpackEncTable");v=x(8,N,m,O,h);let t=v.l+6;if(N=v.c,m=v.lc,S+t>H+1)throw new Error("Error in HufUnpackEncTable");for(;t--;)b[S++]=0;S--}else if(t>=59){let O=t-59+2;if(S+O>H+1)throw new Error("Error in HufUnpackEncTable");for(;O--;)b[S++]=0;S--}}!function(O){for(let y=0;y<=58;++y)o[y]=0;for(let y=0;y<v;++y)o[O[y]]+=1;let f=0;for(let y=58;y>0;--y){const O=f+o[y]>>1;o[y]=f,f=O}for(let y=0;y<v;++y){const f=O[y];f>0&&(O[y]=f|o[f]++<<6)}}(b)}function D(O){return 63&O}function V(O){return O>>6}function g(O,f,y,S,H,b){const m=y.value,t=A(f,y),q=A(f,y);y.value+=4;const F=A(f,y);if(y.value+=4,t<0||t>=v||q<0||q>=v)throw new Error("Wrong HUF_ENCSIZE");const I=new Array(v),J=new Array(N);!function(O){for(let f=0;f<N;f++)O[f]={},O[f].len=0,O[f].lit=0,O[f].p=null}(J);if(i(O,y,S-(y.value-m),t,q,I),F>8*(S-(y.value-m)))throw new Error("Wrong hufUncompress");!function(O,f,y,S){for(;f<=y;f++){const y=V(O[f]),H=D(O[f]);if(y>>H)throw new Error("Invalid table entry");if(H>h){const O=S[y>>H-h];if(O.len)throw new Error("Invalid table entry");if(O.lit++,O.p){const f=O.p;O.p=new Array(O.lit);for(let y=0;y<O.lit-1;++y)O.p[y]=f[y]}else O.p=new Array(1);O.p[O.lit-1]=f}else if(H){let O=0;for(let b=1<<h-H;b>0;b--){const b=S[(y<<h-H)+O];if(b.len||b.p)throw new Error("Invalid table entry");b.len=H,b.lit=f,O++}}}}(I,t,q,J),function(O,f,y,S,H,b,v,N,m){let t=0,q=0;const F=v,I=Math.trunc(S.value+(H+7)/8);for(;S.value<I;){let H=W(t,q,y,S);for(t=H.c,q=H.lc;q>=h;){const v=f[t>>q-h&16383];if(v.len){q-=v.len;const O=E(v.lit,b,t,q,y,S,N,m,F);O&&(t=O.c,q=O.lc)}else{if(!v.p)throw new Error("hufDecode issues");let f;for(f=0;f<v.lit;f++){const h=D(O[v.p[f]]);for(;q<h&&S.value<I;)H=W(t,q,y,S),t=H.c,q=H.lc;if(q>=h&&V(O[v.p[f]])==(t>>q-h&(1<<h)-1)){q-=h;const O=E(v.p[f],b,t,q,y,S,N,m,F);O&&(t=O.c,q=O.lc);break}}if(f==v.lit)throw new Error("HufDecode issues")}}}const A=8-H&7;for(t>>=A,q-=A;q>0;){const O=f[t<<h-q&16383];if(!O.len)throw new Error("HufDecode issues");{q-=O.len;const f=E(O.lit,b,t,q,y,S,N,m,F);f&&(t=f.c,q=f.lc)}}}(I,J,O,y,F,q,b,H,{value:0})}function R(O){return 65535&O}function s(O){const f=R(O);return f>32767?f-65536:f}function k(O,f){const y=s(O),S=s(f),H=y+(1&S)+(S>>1);return{a:H,b:H-S}}function z(O,f){const y=R(O),S=R(f),H=y-(S>>1)&65535;return{a:S+H-32768&65535,b:H}}function c(O,f,y,S,H,b,h){const v=h<16384,N=y>H?H:y;let m,t,q=1;for(;q<=N;)q<<=1;for(q>>=1,m=q,q>>=1;q>=1;){t=0;const h=t+b*(H-m),N=b*q,F=b*m,I=S*q,A=S*m;let J,X,w,B;for(;t<=h;t+=F){let H=t;const b=t+S*(y-m);for(;H<=b;H+=A){const y=H+I,S=H+N,b=S+I;if(v){let h=k(O[H+f],O[S+f]);J=h.a,w=h.b,h=k(O[y+f],O[b+f]),X=h.a,B=h.b,h=k(J,X),O[H+f]=h.a,O[y+f]=h.b,h=k(w,B),O[S+f]=h.a,O[b+f]=h.b}else{let h=z(O[H+f],O[S+f]);J=h.a,w=h.b,h=z(O[y+f],O[b+f]),X=h.a,B=h.b,h=z(J,X),O[H+f]=h.a,O[y+f]=h.b,h=z(w,B),O[S+f]=h.a,O[b+f]=h.b}}if(y&q){const y=H+N;let S;S=v?k(O[H+f],O[y+f]):z(O[H+f],O[y+f]),J=S.a,O[y+f]=S.b,O[H+f]=J}}if(H&q){let H=t;const b=t+S*(y-m);for(;H<=b;H+=A){const y=H+I;let S;S=v?k(O[H+f],O[y+f]):z(O[H+f],O[y+f]),J=S.a,O[y+f]=S.b,O[H+f]=J}}m=q,q>>=1}return t}function d(O){return new DataView(O.array.buffer,O.offset.value,O.size)}function G(O){const f=O.viewer.buffer.slice(O.offset.value,O.offset.value+O.size),y=new Uint8Array(function(O){let f=O.byteLength;const y=new Array;let S=0;const H=new DataView(O);for(;f>0;){const O=H.getInt8(S++);if(O<0){const b=-O;f-=b+1;for(let O=0;O<b;O++)y.push(H.getUint8(S++))}else{const b=O;f-=2;const h=H.getUint8(S++);for(let O=0;O<b+1;O++)y.push(h)}}return y}(f)),S=new Uint8Array(y.length);return U(y),l(y,S),new DataView(S.buffer)}function Y(O){const f=O.array.slice(O.offset.value,O.offset.value+O.size),y=fflate.unzlibSync(f),S=new Uint8Array(y.length);return U(y),l(y,S),new DataView(S.buffer)}function Z(O){const f=O.array.slice(O.offset.value,O.offset.value+O.size),y=fflate.unzlibSync(f),S=O.lines*O.channels*O.width,H=1==O.type?new Uint16Array(S):new Uint32Array(S);let b=0,h=0;const v=new Array(4);for(let N=0;N<O.lines;N++)for(let f=0;f<O.channels;f++){let f=0;switch(O.type){case 1:v[0]=b,v[1]=v[0]+O.width,b=v[1]+O.width;for(let S=0;S<O.width;++S){f+=y[v[0]++]<<8|y[v[1]++],H[h]=f,h++}break;case 2:v[0]=b,v[1]=v[0]+O.width,v[2]=v[1]+O.width,b=v[2]+O.width;for(let S=0;S<O.width;++S){f+=y[v[0]++]<<24|y[v[1]++]<<16|y[v[2]++]<<8,H[h]=f,h++}}}return new DataView(H.buffer)}function a(O){const f=O.viewer,y={value:O.offset.value},S=new Uint16Array(O.width*O.scanlineBlockSize*(O.channels*O.type)),H=new Uint8Array(8192);let h=0;const v=new Array(O.channels);for(let b=0;b<O.channels;b++)v[b]={},v[b].start=h,v[b].end=v[b].start,v[b].nx=O.width,v[b].ny=O.lines,v[b].size=O.type,h+=v[b].nx*v[b].ny*v[b].size;const N=X(f,y),m=X(f,y);if(m>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(N<=m)for(let b=0;b<m-N+1;b++)H[b+N]=J(f,y);const t=new Uint16Array(b),q=function(O,f){let y=0;for(let H=0;H<b;++H)(0==H||O[H>>3]&1<<(7&H))&&(f[y++]=H);const S=y-1;for(;y<b;)f[y++]=0;return S}(H,t),F=A(f,y);g(O.array,f,y,F,S,h);for(let b=0;b<O.channels;++b){const O=v[b];for(let f=0;f<v[b].size;++f)c(S,O.start+f,O.nx,O.size,O.ny,O.nx*O.size,q)}!function(O,f,y){for(let S=0;S<y;++S)f[S]=O[f[S]]}(t,S,h);let I=0;const w=new Uint8Array(S.buffer.byteLength);for(let b=0;b<O.lines;b++)for(let f=0;f<O.channels;f++){const O=v[f],y=O.nx*O.size,H=new Uint8Array(S.buffer,2*O.end,2*y);w.set(H,I),I+=2*y,O.end+=y}return new DataView(w.buffer)}var M,P=y(10995);!function(O){O[O.Float=0]="Float",O[O.HalfFloat=1]="HalfFloat"}(M||(M={}));class e{}e.DefaultOutputType=M.HalfFloat,e.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class K{constructor(){this.supportCascades=!1}loadCubeData(O,f,y,S,H){throw".exr not supported in Cube."}async loadData(O,f,y){const H=new DataView(O.buffer),b={value:0},h=function(O,f){if(20000630!=O.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const y=O.getUint8(4),H=O.getUint8(5),b={singleTile:!!(2&H),longName:!!(4&H),deepFormat:!!(8&H),multiPart:!!(16&H)};f.value=8;const h={};let v=!0;for(;v;){const y=F(O.buffer,f);if(y){const H=F(O.buffer,f),b=p(O,f,H,A(O,f));void 0===b?S.e.Warn(`Unknown header attribute type ${H}'.`):h[y]=b}else v=!1}if(0!=(-5&H))throw new Error("Unsupported file format");return{version:y,spec:b,...h}}(H,b),v=await async function(O,f,y,S){const H={size:0,viewer:f,array:new Uint8Array(f.buffer),offset:y,width:O.dataWindow.xMax-O.dataWindow.xMin+1,height:O.dataWindow.yMax-O.dataWindow.yMin+1,channels:O.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(O.compression){case m.NO_COMPRESSION:H.lines=1,H.uncompress=d;break;case m.RLE_COMPRESSION:H.lines=1,H.uncompress=G;break;case m.ZIPS_COMPRESSION:H.lines=1,H.uncompress=Y,await P.d.LoadScriptAsync(e.FFLATEUrl);break;case m.ZIP_COMPRESSION:H.lines=16,H.uncompress=Y,await P.d.LoadScriptAsync(e.FFLATEUrl);break;case m.PIZ_COMPRESSION:H.lines=32,H.uncompress=a;break;case m.PXR24_COMPRESSION:H.lines=16,H.uncompress=Z,await P.d.LoadScriptAsync(e.FFLATEUrl);break;default:throw new Error(m[O.compression]+" is unsupported")}H.scanlineBlockSize=H.lines;const b={};for(const m of O.channels)switch(m.name){case"Y":case"R":case"G":case"B":case"A":b[m.name]=!0,H.type=m.pixelType}let h=!1;if(b.R&&b.G&&b.B)h=!b.A,H.outputChannels=4,H.decodeChannels={R:0,G:1,B:2,A:3};else{if(!b.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");H.outputChannels=1,H.decodeChannels={Y:0}}if(1===H.type)switch(S){case M.Float:H.getter=u,H.inputSize=2;break;case M.HalfFloat:H.getter=X,H.inputSize=2}else{if(2!==H.type)throw new Error("Unsupported pixelType "+H.type+" for "+O.compression);switch(S){case M.Float:H.getter=j,H.inputSize=4;break;case M.HalfFloat:H.getter=L,H.inputSize=4}}H.blockCount=H.height/H.scanlineBlockSize;for(let m=0;m<H.blockCount;m++)B(f,y);const v=H.width*H.height*H.outputChannels;switch(S){case M.Float:H.byteArray=new Float32Array(v),H.textureType=1,h&&H.byteArray.fill(1,0,v);break;case M.HalfFloat:H.byteArray=new Uint16Array(v),H.textureType=2,h&&H.byteArray.fill(15360,0,v);break;default:throw new Error("Unsupported type: "+S)}let N=0;for(const m of O.channels)void 0!==H.decodeChannels[m.name]&&(H.channelLineOffsets[m.name]=N*H.width),N+=2*m.pixelType;return H.bytesPerLine=H.width*N,H.outLineWidth=H.width*H.outputChannels,"INCREASING_Y"===O.lineOrder?H.scanOrder=O=>O:H.scanOrder=O=>H.height-1-O,4==H.outputChannels?(H.format=5,H.linearSpace=!0):(H.format=6,H.linearSpace=!1),H}(h,H,b,e.DefaultOutputType);!function(O,f,y,S){const H={value:0};for(let b=0;b<O.height/O.scanlineBlockSize;b++){const h=I(y,S)-f.dataWindow.yMin;O.size=A(y,S),O.lines=h+O.scanlineBlockSize>O.height?O.height-h:O.scanlineBlockSize;const v=O.size<O.lines*O.bytesPerLine&&O.uncompress?O.uncompress(O):d(O);S.value+=O.size;for(let y=0;y<O.scanlineBlockSize;y++){const S=b*O.scanlineBlockSize,h=y+O.scanOrder(S);if(h>=O.height)continue;const N=y*O.bytesPerLine,m=(O.height-1-h)*O.outLineWidth;for(let y=0;y<O.channels;y++){const S=f.channels[y].name,b=O.channelLineOffsets[S],h=O.decodeChannels[S];if(void 0!==h){H.value=N+b;for(let f=0;f<O.width;f++){const y=m+f*O.outputChannels+h;O.byteArray&&(O.byteArray[y]=O.getter(v,H))}}}}}}(v,h,H,b);y(h.dataWindow.xMax-h.dataWindow.xMin+1,h.dataWindow.yMax-h.dataWindow.yMin+1,f.generateMipMaps,!1,(()=>{const O=f.getEngine();f.format=h.format,f.type=v.textureType,f.invertY=!1,f._gammaSpace=!h.linearSpace,v.byteArray&&O._uploadDataToTextureDirectly(f,v.byteArray,0,0,void 0,!0)}))}}}}]);