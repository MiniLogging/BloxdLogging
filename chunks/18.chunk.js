"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{13141:(a,v,p)=>{p.r(v),p.d(v,{_ExrTextureLoader:()=>E});var P=p(10905),b=p(11263);const L=65536,t=14,V=65537,K=16384;var C,F;!function(a){a[a.NO_COMPRESSION=0]="NO_COMPRESSION",a[a.RLE_COMPRESSION=1]="RLE_COMPRESSION",a[a.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",a[a.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",a[a.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",a[a.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(C||(C={})),function(a){a[a.INCREASING_Y=0]="INCREASING_Y",a[a.DECREASING_Y=1]="DECREASING_Y"}(F||(F={}));const u=function(){const a=new ArrayBuffer(4),v=new Float32Array(a),p=new Uint32Array(a),P=new Uint32Array(512),b=new Uint32Array(512);for(let K=0;K<256;++K){const a=K-127;a<-27?(P[K]=0,P[256|K]=32768,b[K]=24,b[256|K]=24):a<-14?(P[K]=1024>>-a-14,P[256|K]=1024>>-a-14|32768,b[K]=-a-1,b[256|K]=-a-1):a<=15?(P[K]=a+15<<10,P[256|K]=a+15<<10|32768,b[K]=13,b[256|K]=13):a<128?(P[K]=31744,P[256|K]=64512,b[K]=24,b[256|K]=24):(P[K]=31744,P[256|K]=64512,b[K]=13,b[256|K]=13)}const L=new Uint32Array(2048),t=new Uint32Array(64),V=new Uint32Array(64);for(let K=1;K<1024;++K){let a=K<<13,v=0;for(;0===(8388608&a);)a<<=1,v-=8388608;a&=-8388609,v+=947912704,L[K]=a|v}for(let K=1024;K<2048;++K)L[K]=939524096+(K-1024<<13);for(let K=1;K<31;++K)t[K]=K<<23;t[31]=1199570944,t[32]=2147483648;for(let K=33;K<63;++K)t[K]=2147483648+(K-32<<23);t[63]=3347054592;for(let K=1;K<64;++K)32!==K&&(V[K]=1024);return{floatView:v,uint32View:p,baseTable:P,shiftTable:b,mantissaTable:L,exponentTable:t,offsetTable:V}}();function c(a,v){const p=new Uint8Array(a);let P=0;for(;0!=p[v.value+P];)P+=1;const b=(new TextDecoder).decode(p.slice(v.value,v.value+P));return v.value=v.value+P+1,b}function f(a,v){const p=a.getInt32(v.value,!0);return v.value+=4,p}function H(a,v){const p=a.getUint32(v.value,!0);return v.value+=4,p}function A(a,v){const p=a.getUint8(v.value);return v.value+=1,p}function h(a,v){const p=a.getUint16(v.value,!0);return v.value+=2,p}function R(a,v){const p=a[v.value];return v.value+=1,p}function X(a,v){let p;return p="getBigInt64"in DataView.prototype?Number(a.getBigInt64(v.value,!0)):a.getUint32(v.value+4,!0)+Number(a.getUint32(v.value,!0)<<32),v.value+=8,p}function Q(a,v){const p=a.getFloat32(v.value,!0);return v.value+=4,p}function s(a,v){return function(a){const v=(31744&a)>>10,p=1023&a;return(a>>15?-1:1)*(v?31===v?p?NaN:1/0:Math.pow(2,v-15)*(1+p/1024):p/1024*6103515625e-14)}(h(a,v))}function D(a,v){return function(a){if(Math.abs(a)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");a=(0,b.e)(a,-65504,65504),u.floatView[0]=a;const v=u.uint32View[0],p=v>>23&511;return u.baseTable[p]+((8388607&v)>>u.shiftTable[p])}(Q(a,v))}function y(a,v,p,P){switch(p){case"string":case"stringvector":case"iccProfile":return function(a,v,p){const P=(new TextDecoder).decode(new Uint8Array(a).slice(v.value,v.value+p));return v.value=v.value+p,P}(a.buffer,v,P);case"chlist":return function(a,v,p){const P=v.value,b=[];for(;v.value<P+p-1;){const p=c(a.buffer,v),P=f(a,v),L=A(a,v);v.value+=3;const t=f(a,v),V=f(a,v);b.push({name:p,pixelType:P,pLinear:L,xSampling:t,ySampling:V})}return v.value+=1,b}(a,v,P);case"chromaticities":return function(a,v){return{redX:Q(a,v),redY:Q(a,v),greenX:Q(a,v),greenY:Q(a,v),blueX:Q(a,v),blueY:Q(a,v),whiteX:Q(a,v),whiteY:Q(a,v)}}(a,v);case"compression":return function(a,v){return A(a,v)}(a,v);case"box2i":return function(a,v){return{xMin:f(a,v),yMin:f(a,v),xMax:f(a,v),yMax:f(a,v)}}(a,v);case"lineOrder":return function(a,v){const p=A(a,v);return F[p]}(a,v);case"float":return Q(a,v);case"v2f":return function(a,v){return[Q(a,v),Q(a,v)]}(a,v);case"v3f":return function(a,v){return[Q(a,v),Q(a,v),Q(a,v)]}(a,v);case"int":return f(a,v);case"rational":return function(a,v){return[f(a,v),H(a,v)]}(a,v);case"timecode":return function(a,v){return[H(a,v),H(a,v)]}(a,v);case"preview":return v.value+=P,"skipped";default:return void(v.value+=P)}}function Z(a){for(let v=1;v<a.length;v++){const p=a[v-1]+a[v]-128;a[v]=p}}function M(a,v){let p=0,P=Math.floor((a.length+1)/2),b=0;const L=a.length-1;for(;!(b>L)&&(v[b++]=a[p++],!(b>L));)v[b++]=a[P++]}function S(a,v,p,P,b){for(;p<a;)v=v<<8|R(P,b),p+=8;return{l:v>>(p-=a)&(1<<a)-1,c:v,lc:p}}function n(a,v,p,P){return{c:a=a<<8|R(p,P),lc:v+=8}}function q(a,v,p,P,b,L,t,V,K){if(a==v){if(P<8){const a=n(p,P,b,L);p=a.c,P=a.lc}let a=p>>(P-=8);if(a=new Uint8Array([a])[0],V.value+a>K)return null;const v=t[V.value-1];for(;a-- >0;)t[V.value++]=v}else{if(!(V.value<K))return null;t[V.value++]=a}return{c:p,lc:P}}const T=new Array(59);function j(a,v,p,P,b,L){const t=v;let K=0,C=0;for(;P<=b;P++){if(t.value-v.value>p)return;let V=S(6,K,C,a,t);const F=V.l;if(K=V.c,C=V.lc,L[P]=F,63==F){if(t.value-v.value>p)throw new Error("Error in HufUnpackEncTable");V=S(8,K,C,a,t);let F=V.l+6;if(K=V.c,C=V.lc,P+F>b+1)throw new Error("Error in HufUnpackEncTable");for(;F--;)L[P++]=0;P--}else if(F>=59){let a=F-59+2;if(P+a>b+1)throw new Error("Error in HufUnpackEncTable");for(;a--;)L[P++]=0;P--}}!function(a){for(let p=0;p<=58;++p)T[p]=0;for(let p=0;p<V;++p)T[a[p]]+=1;let v=0;for(let p=58;p>0;--p){const a=v+T[p]>>1;T[p]=v,v=a}for(let p=0;p<V;++p){const v=a[p];v>0&&(a[p]=v|T[v]++<<6)}}(L)}function w(a){return 63&a}function J(a){return a>>6}function B(a,v,p,P,b,L){const C=p.value,F=H(v,p),u=H(v,p);p.value+=4;const c=H(v,p);if(p.value+=4,F<0||F>=V||u<0||u>=V)throw new Error("Wrong HUF_ENCSIZE");const f=new Array(V),A=new Array(K);!function(a){for(let v=0;v<K;v++)a[v]={},a[v].len=0,a[v].lit=0,a[v].p=null}(A);if(j(a,p,P-(p.value-C),F,u,f),c>8*(P-(p.value-C)))throw new Error("Wrong hufUncompress");!function(a,v,p,P){for(;v<=p;v++){const p=J(a[v]),b=w(a[v]);if(p>>b)throw new Error("Invalid table entry");if(b>t){const a=P[p>>b-t];if(a.len)throw new Error("Invalid table entry");if(a.lit++,a.p){const v=a.p;a.p=new Array(a.lit);for(let p=0;p<a.lit-1;++p)a.p[p]=v[p]}else a.p=new Array(1);a.p[a.lit-1]=v}else if(b){let a=0;for(let L=1<<t-b;L>0;L--){const L=P[(p<<t-b)+a];if(L.len||L.p)throw new Error("Invalid table entry");L.len=b,L.lit=v,a++}}}}(f,F,u,A),function(a,v,p,P,b,L,V,K,C){let F=0,u=0;const c=V,f=Math.trunc(P.value+(b+7)/8);for(;P.value<f;){let b=n(F,u,p,P);for(F=b.c,u=b.lc;u>=t;){const V=v[F>>u-t&16383];if(V.len){u-=V.len;const a=q(V.lit,L,F,u,p,P,K,C,c);a&&(F=a.c,u=a.lc)}else{if(!V.p)throw new Error("hufDecode issues");let v;for(v=0;v<V.lit;v++){const t=w(a[V.p[v]]);for(;u<t&&P.value<f;)b=n(F,u,p,P),F=b.c,u=b.lc;if(u>=t&&J(a[V.p[v]])==(F>>u-t&(1<<t)-1)){u-=t;const a=q(V.p[v],L,F,u,p,P,K,C,c);a&&(F=a.c,u=a.lc);break}}if(v==V.lit)throw new Error("HufDecode issues")}}}const H=8-b&7;for(F>>=H,u-=H;u>0;){const a=v[F<<t-u&16383];if(!a.len)throw new Error("HufDecode issues");{u-=a.len;const v=q(a.lit,L,F,u,p,P,K,C,c);v&&(F=v.c,u=v.lc)}}}(f,A,a,p,c,u,L,b,{value:0})}function x(a){return 65535&a}function r(a){const v=x(a);return v>32767?v-65536:v}function o(a,v){const p=r(a),P=r(v),b=p+(1&P)+(P>>1);return{a:b,b:b-P}}function m(a,v){const p=x(a),P=x(v),b=p-(P>>1)&65535;return{a:P+b-32768&65535,b:b}}function O(a,v,p,P,b,L,t){const V=t<16384,K=p>b?b:p;let C,F,u=1;for(;u<=K;)u<<=1;for(u>>=1,C=u,u>>=1;u>=1;){F=0;const t=F+L*(b-C),K=L*u,c=L*C,f=P*u,H=P*C;let A,h,R,X;for(;F<=t;F+=c){let b=F;const L=F+P*(p-C);for(;b<=L;b+=H){const p=b+f,P=b+K,L=P+f;if(V){let t=o(a[b+v],a[P+v]);A=t.a,R=t.b,t=o(a[p+v],a[L+v]),h=t.a,X=t.b,t=o(A,h),a[b+v]=t.a,a[p+v]=t.b,t=o(R,X),a[P+v]=t.a,a[L+v]=t.b}else{let t=m(a[b+v],a[P+v]);A=t.a,R=t.b,t=m(a[p+v],a[L+v]),h=t.a,X=t.b,t=m(A,h),a[b+v]=t.a,a[p+v]=t.b,t=m(R,X),a[P+v]=t.a,a[L+v]=t.b}}if(p&u){const p=b+K;let P;P=V?o(a[b+v],a[p+v]):m(a[b+v],a[p+v]),A=P.a,a[p+v]=P.b,a[b+v]=A}}if(b&u){let b=F;const L=F+P*(p-C);for(;b<=L;b+=H){const p=b+f;let P;P=V?o(a[b+v],a[p+v]):m(a[b+v],a[p+v]),A=P.a,a[p+v]=P.b,a[b+v]=A}}C=u,u>>=1}return F}function Y(a){return new DataView(a.array.buffer,a.offset.value,a.size)}function l(a){const v=a.viewer.buffer.slice(a.offset.value,a.offset.value+a.size),p=new Uint8Array(function(a){let v=a.byteLength;const p=new Array;let P=0;const b=new DataView(a);for(;v>0;){const a=b.getInt8(P++);if(a<0){const L=-a;v-=L+1;for(let a=0;a<L;a++)p.push(b.getUint8(P++))}else{const L=a;v-=2;const t=b.getUint8(P++);for(let a=0;a<L+1;a++)p.push(t)}}return p}(v)),P=new Uint8Array(p.length);return Z(p),M(p,P),new DataView(P.buffer)}function z(a){const v=a.array.slice(a.offset.value,a.offset.value+a.size),p=fflate.unzlibSync(v),P=new Uint8Array(p.length);return Z(p),M(p,P),new DataView(P.buffer)}function g(a){const v=a.array.slice(a.offset.value,a.offset.value+a.size),p=fflate.unzlibSync(v),P=a.lines*a.channels*a.width,b=1==a.type?new Uint16Array(P):new Uint32Array(P);let L=0,t=0;const V=new Array(4);for(let K=0;K<a.lines;K++)for(let v=0;v<a.channels;v++){let v=0;switch(a.type){case 1:V[0]=L,V[1]=V[0]+a.width,L=V[1]+a.width;for(let P=0;P<a.width;++P){v+=p[V[0]++]<<8|p[V[1]++],b[t]=v,t++}break;case 2:V[0]=L,V[1]=V[0]+a.width,V[2]=V[1]+a.width,L=V[2]+a.width;for(let P=0;P<a.width;++P){v+=p[V[0]++]<<24|p[V[1]++]<<16|p[V[2]++]<<8,b[t]=v,t++}}}return new DataView(b.buffer)}function G(a){const v=a.viewer,p={value:a.offset.value},P=new Uint16Array(a.width*a.scanlineBlockSize*(a.channels*a.type)),b=new Uint8Array(8192);let t=0;const V=new Array(a.channels);for(let L=0;L<a.channels;L++)V[L]={},V[L].start=t,V[L].end=V[L].start,V[L].nx=a.width,V[L].ny=a.lines,V[L].size=a.type,t+=V[L].nx*V[L].ny*V[L].size;const K=h(v,p),C=h(v,p);if(C>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(K<=C)for(let L=0;L<C-K+1;L++)b[L+K]=A(v,p);const F=new Uint16Array(L),u=function(a,v){let p=0;for(let b=0;b<L;++b)(0==b||a[b>>3]&1<<(7&b))&&(v[p++]=b);const P=p-1;for(;p<L;)v[p++]=0;return P}(b,F),c=H(v,p);B(a.array,v,p,c,P,t);for(let L=0;L<a.channels;++L){const a=V[L];for(let v=0;v<V[L].size;++v)O(P,a.start+v,a.nx,a.size,a.ny,a.nx*a.size,u)}!function(a,v,p){for(let P=0;P<p;++P)v[P]=a[v[P]]}(F,P,t);let f=0;const R=new Uint8Array(P.buffer.byteLength);for(let L=0;L<a.lines;L++)for(let v=0;v<a.channels;v++){const a=V[v],p=a.nx*a.size,b=new Uint8Array(P.buffer,2*a.end,2*p);R.set(b,f),f+=2*p,a.end+=p}return new DataView(R.buffer)}var e,k=p(10889);!function(a){a[a.Float=0]="Float",a[a.HalfFloat=1]="HalfFloat"}(e||(e={}));class d{}d.DefaultOutputType=e.HalfFloat,d.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class E{constructor(){this.supportCascades=!1}loadCubeData(a,v,p,P,b){throw".exr not supported in Cube."}async loadData(a,v,p){const b=new DataView(a.buffer),L={value:0},t=function(a,v){if(20000630!=a.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const p=a.getUint8(4),b=a.getUint8(5),L={singleTile:!!(2&b),longName:!!(4&b),deepFormat:!!(8&b),multiPart:!!(16&b)};v.value=8;const t={};let V=!0;for(;V;){const p=c(a.buffer,v);if(p){const b=c(a.buffer,v),L=y(a,v,b,H(a,v));void 0===L?P.d.Warn(`Unknown header attribute type ${b}'.`):t[p]=L}else V=!1}if(0!=(-5&b))throw new Error("Unsupported file format");return{version:p,spec:L,...t}}(b,L),V=await async function(a,v,p,P){const b={size:0,viewer:v,array:new Uint8Array(v.buffer),offset:p,width:a.dataWindow.xMax-a.dataWindow.xMin+1,height:a.dataWindow.yMax-a.dataWindow.yMin+1,channels:a.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(a.compression){case C.NO_COMPRESSION:b.lines=1,b.uncompress=Y;break;case C.RLE_COMPRESSION:b.lines=1,b.uncompress=l;break;case C.ZIPS_COMPRESSION:b.lines=1,b.uncompress=z,await k.e.LoadScriptAsync(d.FFLATEUrl);break;case C.ZIP_COMPRESSION:b.lines=16,b.uncompress=z,await k.e.LoadScriptAsync(d.FFLATEUrl);break;case C.PIZ_COMPRESSION:b.lines=32,b.uncompress=G;break;case C.PXR24_COMPRESSION:b.lines=16,b.uncompress=g,await k.e.LoadScriptAsync(d.FFLATEUrl);break;default:throw new Error(C[a.compression]+" is unsupported")}b.scanlineBlockSize=b.lines;const L={};for(const C of a.channels)switch(C.name){case"Y":case"R":case"G":case"B":case"A":L[C.name]=!0,b.type=C.pixelType}let t=!1;if(L.R&&L.G&&L.B)t=!L.A,b.outputChannels=4,b.decodeChannels={R:0,G:1,B:2,A:3};else{if(!L.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");b.outputChannels=1,b.decodeChannels={Y:0}}if(1===b.type)switch(P){case e.Float:b.getter=s,b.inputSize=2;break;case e.HalfFloat:b.getter=h,b.inputSize=2}else{if(2!==b.type)throw new Error("Unsupported pixelType "+b.type+" for "+a.compression);switch(P){case e.Float:b.getter=Q,b.inputSize=4;break;case e.HalfFloat:b.getter=D,b.inputSize=4}}b.blockCount=b.height/b.scanlineBlockSize;for(let C=0;C<b.blockCount;C++)X(v,p);const V=b.width*b.height*b.outputChannels;switch(P){case e.Float:b.byteArray=new Float32Array(V),b.textureType=1,t&&b.byteArray.fill(1,0,V);break;case e.HalfFloat:b.byteArray=new Uint16Array(V),b.textureType=2,t&&b.byteArray.fill(15360,0,V);break;default:throw new Error("Unsupported type: "+P)}let K=0;for(const C of a.channels)void 0!==b.decodeChannels[C.name]&&(b.channelLineOffsets[C.name]=K*b.width),K+=2*C.pixelType;return b.bytesPerLine=b.width*K,b.outLineWidth=b.width*b.outputChannels,"INCREASING_Y"===a.lineOrder?b.scanOrder=a=>a:b.scanOrder=a=>b.height-1-a,4==b.outputChannels?(b.format=5,b.linearSpace=!0):(b.format=6,b.linearSpace=!1),b}(t,b,L,d.DefaultOutputType);!function(a,v,p,P){const b={value:0};for(let L=0;L<a.height/a.scanlineBlockSize;L++){const t=f(p,P)-v.dataWindow.yMin;a.size=H(p,P),a.lines=t+a.scanlineBlockSize>a.height?a.height-t:a.scanlineBlockSize;const V=a.size<a.lines*a.bytesPerLine&&a.uncompress?a.uncompress(a):Y(a);P.value+=a.size;for(let p=0;p<a.scanlineBlockSize;p++){const P=L*a.scanlineBlockSize,t=p+a.scanOrder(P);if(t>=a.height)continue;const K=p*a.bytesPerLine,C=(a.height-1-t)*a.outLineWidth;for(let p=0;p<a.channels;p++){const P=v.channels[p].name,L=a.channelLineOffsets[P],t=a.decodeChannels[P];if(void 0!==t){b.value=K+L;for(let v=0;v<a.width;v++){const p=C+v*a.outputChannels+t;a.byteArray&&(a.byteArray[p]=a.getter(V,b))}}}}}}(V,t,b,L);p(t.dataWindow.xMax-t.dataWindow.xMin+1,t.dataWindow.yMax-t.dataWindow.yMin+1,v.generateMipMaps,!1,(()=>{const a=v.getEngine();v.format=t.format,v.type=V.textureType,v.invertY=!1,v._gammaSpace=!t.linearSpace,V.byteArray&&a._uploadDataToTextureDirectly(v,V.byteArray,0,0,void 0,!0)}))}}}}]);