"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{13043:(H,p,V)=>{V.r(p),V.d(p,{_ExrTextureLoader:()=>O});var c=V(10786),C=V(11123);const E=65536,z=14,w=65537,t=16384;var Q,P;!function(H){H[H.NO_COMPRESSION=0]="NO_COMPRESSION",H[H.RLE_COMPRESSION=1]="RLE_COMPRESSION",H[H.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",H[H.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",H[H.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",H[H.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(Q||(Q={})),function(H){H[H.INCREASING_Y=0]="INCREASING_Y",H[H.DECREASING_Y=1]="DECREASING_Y"}(P||(P={}));const U=function(){const H=new ArrayBuffer(4),p=new Float32Array(H),V=new Uint32Array(H),c=new Uint32Array(512),C=new Uint32Array(512);for(let t=0;t<256;++t){const H=t-127;H<-27?(c[t]=0,c[256|t]=32768,C[t]=24,C[256|t]=24):H<-14?(c[t]=1024>>-H-14,c[256|t]=1024>>-H-14|32768,C[t]=-H-1,C[256|t]=-H-1):H<=15?(c[t]=H+15<<10,c[256|t]=H+15<<10|32768,C[t]=13,C[256|t]=13):H<128?(c[t]=31744,c[256|t]=64512,C[t]=24,C[256|t]=24):(c[t]=31744,c[256|t]=64512,C[t]=13,C[256|t]=13)}const E=new Uint32Array(2048),z=new Uint32Array(64),w=new Uint32Array(64);for(let t=1;t<1024;++t){let H=t<<13,p=0;for(;0===(8388608&H);)H<<=1,p-=8388608;H&=-8388609,p+=947912704,E[t]=H|p}for(let t=1024;t<2048;++t)E[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)z[t]=t<<23;z[31]=1199570944,z[32]=2147483648;for(let t=33;t<63;++t)z[t]=2147483648+(t-32<<23);z[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(w[t]=1024);return{floatView:p,uint32View:V,baseTable:c,shiftTable:C,mantissaTable:E,exponentTable:z,offsetTable:w}}();function J(H,p){const V=new Uint8Array(H);let c=0;for(;0!=V[p.value+c];)c+=1;const C=(new TextDecoder).decode(V.slice(p.value,p.value+c));return p.value=p.value+c+1,C}function l(H,p){const V=H.getInt32(p.value,!0);return p.value+=4,V}function N(H,p){const V=H.getUint32(p.value,!0);return p.value+=4,V}function Z(H,p){const V=H.getUint8(p.value);return p.value+=1,V}function Y(H,p){const V=H.getUint16(p.value,!0);return p.value+=2,V}function y(H,p){const V=H[p.value];return p.value+=1,V}function M(H,p){let V;return V="getBigInt64"in DataView.prototype?Number(H.getBigInt64(p.value,!0)):H.getUint32(p.value+4,!0)+Number(H.getUint32(p.value,!0)<<32),p.value+=8,V}function q(H,p){const V=H.getFloat32(p.value,!0);return p.value+=4,V}function j(H,p){return function(H){const p=(31744&H)>>10,V=1023&H;return(H>>15?-1:1)*(p?31===p?V?NaN:1/0:Math.pow(2,p-15)*(1+V/1024):V/1024*6103515625e-14)}(Y(H,p))}function a(H,p){return function(H){if(Math.abs(H)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");H=(0,C.c)(H,-65504,65504),U.floatView[0]=H;const p=U.uint32View[0],V=p>>23&511;return U.baseTable[V]+((8388607&p)>>U.shiftTable[V])}(q(H,p))}function R(H,p,V,c){switch(V){case"string":case"stringvector":case"iccProfile":return function(H,p,V){const c=(new TextDecoder).decode(new Uint8Array(H).slice(p.value,p.value+V));return p.value=p.value+V,c}(H.buffer,p,c);case"chlist":return function(H,p,V){const c=p.value,C=[];for(;p.value<c+V-1;){const V=J(H.buffer,p),c=l(H,p),E=Z(H,p);p.value+=3;const z=l(H,p),w=l(H,p);C.push({name:V,pixelType:c,pLinear:E,xSampling:z,ySampling:w})}return p.value+=1,C}(H,p,c);case"chromaticities":return function(H,p){return{redX:q(H,p),redY:q(H,p),greenX:q(H,p),greenY:q(H,p),blueX:q(H,p),blueY:q(H,p),whiteX:q(H,p),whiteY:q(H,p)}}(H,p);case"compression":return function(H,p){return Z(H,p)}(H,p);case"box2i":return function(H,p){return{xMin:l(H,p),yMin:l(H,p),xMax:l(H,p),yMax:l(H,p)}}(H,p);case"lineOrder":return function(H,p){const V=Z(H,p);return P[V]}(H,p);case"float":return q(H,p);case"v2f":return function(H,p){return[q(H,p),q(H,p)]}(H,p);case"v3f":return function(H,p){return[q(H,p),q(H,p),q(H,p)]}(H,p);case"int":return l(H,p);case"rational":return function(H,p){return[l(H,p),N(H,p)]}(H,p);case"timecode":return function(H,p){return[N(H,p),N(H,p)]}(H,p);case"preview":return p.value+=c,"skipped";default:return void(p.value+=c)}}function L(H){for(let p=1;p<H.length;p++){const V=H[p-1]+H[p]-128;H[p]=V}}function T(H,p){let V=0,c=Math.floor((H.length+1)/2),C=0;const E=H.length-1;for(;!(C>E)&&(p[C++]=H[V++],!(C>E));)p[C++]=H[c++]}function X(H,p,V,c,C){for(;V<H;)p=p<<8|y(c,C),V+=8;return{l:p>>(V-=H)&(1<<H)-1,c:p,lc:V}}function x(H,p,V,c){return{c:H=H<<8|y(V,c),lc:p+=8}}function K(H,p,V,c,C,E,z,w,t){if(H==p){if(c<8){const H=x(V,c,C,E);V=H.c,c=H.lc}let H=V>>(c-=8);if(H=new Uint8Array([H])[0],w.value+H>t)return null;const p=z[w.value-1];for(;H-- >0;)z[w.value++]=p}else{if(!(w.value<t))return null;z[w.value++]=H}return{c:V,lc:c}}const i=new Array(59);function e(H,p,V,c,C,E){const z=p;let t=0,Q=0;for(;c<=C;c++){if(z.value-p.value>V)return;let w=X(6,t,Q,H,z);const P=w.l;if(t=w.c,Q=w.lc,E[c]=P,63==P){if(z.value-p.value>V)throw new Error("Error in HufUnpackEncTable");w=X(8,t,Q,H,z);let P=w.l+6;if(t=w.c,Q=w.lc,c+P>C+1)throw new Error("Error in HufUnpackEncTable");for(;P--;)E[c++]=0;c--}else if(P>=59){let H=P-59+2;if(c+H>C+1)throw new Error("Error in HufUnpackEncTable");for(;H--;)E[c++]=0;c--}}!function(H){for(let V=0;V<=58;++V)i[V]=0;for(let V=0;V<w;++V)i[H[V]]+=1;let p=0;for(let V=58;V>0;--V){const H=p+i[V]>>1;i[V]=p,p=H}for(let V=0;V<w;++V){const p=H[V];p>0&&(H[V]=p|i[p]++<<6)}}(E)}function m(H){return 63&H}function f(H){return H>>6}function u(H,p,V,c,C,E){const Q=V.value,P=N(p,V),U=N(p,V);V.value+=4;const J=N(p,V);if(V.value+=4,P<0||P>=w||U<0||U>=w)throw new Error("Wrong HUF_ENCSIZE");const l=new Array(w),Z=new Array(t);!function(H){for(let p=0;p<t;p++)H[p]={},H[p].len=0,H[p].lit=0,H[p].p=null}(Z);if(e(H,V,c-(V.value-Q),P,U,l),J>8*(c-(V.value-Q)))throw new Error("Wrong hufUncompress");!function(H,p,V,c){for(;p<=V;p++){const V=f(H[p]),C=m(H[p]);if(V>>C)throw new Error("Invalid table entry");if(C>z){const H=c[V>>C-z];if(H.len)throw new Error("Invalid table entry");if(H.lit++,H.p){const p=H.p;H.p=new Array(H.lit);for(let V=0;V<H.lit-1;++V)H.p[V]=p[V]}else H.p=new Array(1);H.p[H.lit-1]=p}else if(C){let H=0;for(let E=1<<z-C;E>0;E--){const E=c[(V<<z-C)+H];if(E.len||E.p)throw new Error("Invalid table entry");E.len=C,E.lit=p,H++}}}}(l,P,U,Z),function(H,p,V,c,C,E,w,t,Q){let P=0,U=0;const J=w,l=Math.trunc(c.value+(C+7)/8);for(;c.value<l;){let C=x(P,U,V,c);for(P=C.c,U=C.lc;U>=z;){const w=p[P>>U-z&16383];if(w.len){U-=w.len;const H=K(w.lit,E,P,U,V,c,t,Q,J);H&&(P=H.c,U=H.lc)}else{if(!w.p)throw new Error("hufDecode issues");let p;for(p=0;p<w.lit;p++){const z=m(H[w.p[p]]);for(;U<z&&c.value<l;)C=x(P,U,V,c),P=C.c,U=C.lc;if(U>=z&&f(H[w.p[p]])==(P>>U-z&(1<<z)-1)){U-=z;const H=K(w.p[p],E,P,U,V,c,t,Q,J);H&&(P=H.c,U=H.lc);break}}if(p==w.lit)throw new Error("HufDecode issues")}}}const N=8-C&7;for(P>>=N,U-=N;U>0;){const H=p[P<<z-U&16383];if(!H.len)throw new Error("HufDecode issues");{U-=H.len;const p=K(H.lit,E,P,U,V,c,t,Q,J);p&&(P=p.c,U=p.lc)}}}(l,Z,H,V,J,U,E,C,{value:0})}function A(H){return 65535&H}function h(H){const p=A(H);return p>32767?p-65536:p}function s(H,p){const V=h(H),c=h(p),C=V+(1&c)+(c>>1);return{a:C,b:C-c}}function I(H,p){const V=A(H),c=A(p),C=V-(c>>1)&65535;return{a:c+C-32768&65535,b:C}}function G(H,p,V,c,C,E,z){const w=z<16384,t=V>C?C:V;let Q,P,U=1;for(;U<=t;)U<<=1;for(U>>=1,Q=U,U>>=1;U>=1;){P=0;const z=P+E*(C-Q),t=E*U,J=E*Q,l=c*U,N=c*Q;let Z,Y,y,M;for(;P<=z;P+=J){let C=P;const E=P+c*(V-Q);for(;C<=E;C+=N){const V=C+l,c=C+t,E=c+l;if(w){let z=s(H[C+p],H[c+p]);Z=z.a,y=z.b,z=s(H[V+p],H[E+p]),Y=z.a,M=z.b,z=s(Z,Y),H[C+p]=z.a,H[V+p]=z.b,z=s(y,M),H[c+p]=z.a,H[E+p]=z.b}else{let z=I(H[C+p],H[c+p]);Z=z.a,y=z.b,z=I(H[V+p],H[E+p]),Y=z.a,M=z.b,z=I(Z,Y),H[C+p]=z.a,H[V+p]=z.b,z=I(y,M),H[c+p]=z.a,H[E+p]=z.b}}if(V&U){const V=C+t;let c;c=w?s(H[C+p],H[V+p]):I(H[C+p],H[V+p]),Z=c.a,H[V+p]=c.b,H[C+p]=Z}}if(C&U){let C=P;const E=P+c*(V-Q);for(;C<=E;C+=N){const V=C+l;let c;c=w?s(H[C+p],H[V+p]):I(H[C+p],H[V+p]),Z=c.a,H[V+p]=c.b,H[C+p]=Z}}Q=U,U>>=1}return P}function g(H){return new DataView(H.array.buffer,H.offset.value,H.size)}function o(H){const p=H.viewer.buffer.slice(H.offset.value,H.offset.value+H.size),V=new Uint8Array(function(H){let p=H.byteLength;const V=new Array;let c=0;const C=new DataView(H);for(;p>0;){const H=C.getInt8(c++);if(H<0){const E=-H;p-=E+1;for(let H=0;H<E;H++)V.push(C.getUint8(c++))}else{const E=H;p-=2;const z=C.getUint8(c++);for(let H=0;H<E+1;H++)V.push(z)}}return V}(p)),c=new Uint8Array(V.length);return L(V),T(V,c),new DataView(c.buffer)}function F(H){const p=H.array.slice(H.offset.value,H.offset.value+H.size),V=fflate.unzlibSync(p),c=new Uint8Array(V.length);return L(V),T(V,c),new DataView(c.buffer)}function W(H){const p=H.array.slice(H.offset.value,H.offset.value+H.size),V=fflate.unzlibSync(p),c=H.lines*H.channels*H.width,C=1==H.type?new Uint16Array(c):new Uint32Array(c);let E=0,z=0;const w=new Array(4);for(let t=0;t<H.lines;t++)for(let p=0;p<H.channels;p++){let p=0;switch(H.type){case 1:w[0]=E,w[1]=w[0]+H.width,E=w[1]+H.width;for(let c=0;c<H.width;++c){p+=V[w[0]++]<<8|V[w[1]++],C[z]=p,z++}break;case 2:w[0]=E,w[1]=w[0]+H.width,w[2]=w[1]+H.width,E=w[2]+H.width;for(let c=0;c<H.width;++c){p+=V[w[0]++]<<24|V[w[1]++]<<16|V[w[2]++]<<8,C[z]=p,z++}}}return new DataView(C.buffer)}function D(H){const p=H.viewer,V={value:H.offset.value},c=new Uint16Array(H.width*H.scanlineBlockSize*(H.channels*H.type)),C=new Uint8Array(8192);let z=0;const w=new Array(H.channels);for(let E=0;E<H.channels;E++)w[E]={},w[E].start=z,w[E].end=w[E].start,w[E].nx=H.width,w[E].ny=H.lines,w[E].size=H.type,z+=w[E].nx*w[E].ny*w[E].size;const t=Y(p,V),Q=Y(p,V);if(Q>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(t<=Q)for(let E=0;E<Q-t+1;E++)C[E+t]=Z(p,V);const P=new Uint16Array(E),U=function(H,p){let V=0;for(let C=0;C<E;++C)(0==C||H[C>>3]&1<<(7&C))&&(p[V++]=C);const c=V-1;for(;V<E;)p[V++]=0;return c}(C,P),J=N(p,V);u(H.array,p,V,J,c,z);for(let E=0;E<H.channels;++E){const H=w[E];for(let p=0;p<w[E].size;++p)G(c,H.start+p,H.nx,H.size,H.ny,H.nx*H.size,U)}!function(H,p,V){for(let c=0;c<V;++c)p[c]=H[p[c]]}(P,c,z);let l=0;const y=new Uint8Array(c.buffer.byteLength);for(let E=0;E<H.lines;E++)for(let p=0;p<H.channels;p++){const H=w[p],V=H.nx*H.size,C=new Uint8Array(c.buffer,2*H.end,2*V);y.set(C,l),l+=2*V,H.end+=V}return new DataView(y.buffer)}var b,v=V(10765);!function(H){H[H.Float=0]="Float",H[H.HalfFloat=1]="HalfFloat"}(b||(b={}));class k{}k.DefaultOutputType=b.HalfFloat,k.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class O{constructor(){this.supportCascades=!1}loadCubeData(H,p,V,c,C){throw".exr not supported in Cube."}async loadData(H,p,V){const C=new DataView(H.buffer),E={value:0},z=function(H,p){if(20000630!=H.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const V=H.getUint8(4),C=H.getUint8(5),E={singleTile:!!(2&C),longName:!!(4&C),deepFormat:!!(8&C),multiPart:!!(16&C)};p.value=8;const z={};let w=!0;for(;w;){const V=J(H.buffer,p);if(V){const C=J(H.buffer,p),E=R(H,p,C,N(H,p));void 0===E?c.e.Warn(`Unknown header attribute type ${C}'.`):z[V]=E}else w=!1}if(0!=(-5&C))throw new Error("Unsupported file format");return{version:V,spec:E,...z}}(C,E),w=await async function(H,p,V,c){const C={size:0,viewer:p,array:new Uint8Array(p.buffer),offset:V,width:H.dataWindow.xMax-H.dataWindow.xMin+1,height:H.dataWindow.yMax-H.dataWindow.yMin+1,channels:H.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(H.compression){case Q.NO_COMPRESSION:C.lines=1,C.uncompress=g;break;case Q.RLE_COMPRESSION:C.lines=1,C.uncompress=o;break;case Q.ZIPS_COMPRESSION:C.lines=1,C.uncompress=F,await v.c.LoadScriptAsync(k.FFLATEUrl);break;case Q.ZIP_COMPRESSION:C.lines=16,C.uncompress=F,await v.c.LoadScriptAsync(k.FFLATEUrl);break;case Q.PIZ_COMPRESSION:C.lines=32,C.uncompress=D;break;case Q.PXR24_COMPRESSION:C.lines=16,C.uncompress=W,await v.c.LoadScriptAsync(k.FFLATEUrl);break;default:throw new Error(Q[H.compression]+" is unsupported")}C.scanlineBlockSize=C.lines;const E={};for(const Q of H.channels)switch(Q.name){case"Y":case"R":case"G":case"B":case"A":E[Q.name]=!0,C.type=Q.pixelType}let z=!1;if(E.R&&E.G&&E.B)z=!E.A,C.outputChannels=4,C.decodeChannels={R:0,G:1,B:2,A:3};else{if(!E.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");C.outputChannels=1,C.decodeChannels={Y:0}}if(1===C.type)switch(c){case b.Float:C.getter=j,C.inputSize=2;break;case b.HalfFloat:C.getter=Y,C.inputSize=2}else{if(2!==C.type)throw new Error("Unsupported pixelType "+C.type+" for "+H.compression);switch(c){case b.Float:C.getter=q,C.inputSize=4;break;case b.HalfFloat:C.getter=a,C.inputSize=4}}C.blockCount=C.height/C.scanlineBlockSize;for(let Q=0;Q<C.blockCount;Q++)M(p,V);const w=C.width*C.height*C.outputChannels;switch(c){case b.Float:C.byteArray=new Float32Array(w),C.textureType=1,z&&C.byteArray.fill(1,0,w);break;case b.HalfFloat:C.byteArray=new Uint16Array(w),C.textureType=2,z&&C.byteArray.fill(15360,0,w);break;default:throw new Error("Unsupported type: "+c)}let t=0;for(const Q of H.channels)void 0!==C.decodeChannels[Q.name]&&(C.channelLineOffsets[Q.name]=t*C.width),t+=2*Q.pixelType;return C.bytesPerLine=C.width*t,C.outLineWidth=C.width*C.outputChannels,"INCREASING_Y"===H.lineOrder?C.scanOrder=H=>H:C.scanOrder=H=>C.height-1-H,4==C.outputChannels?(C.format=5,C.linearSpace=!0):(C.format=6,C.linearSpace=!1),C}(z,C,E,k.DefaultOutputType);!function(H,p,V,c){const C={value:0};for(let E=0;E<H.height/H.scanlineBlockSize;E++){const z=l(V,c)-p.dataWindow.yMin;H.size=N(V,c),H.lines=z+H.scanlineBlockSize>H.height?H.height-z:H.scanlineBlockSize;const w=H.size<H.lines*H.bytesPerLine&&H.uncompress?H.uncompress(H):g(H);c.value+=H.size;for(let V=0;V<H.scanlineBlockSize;V++){const c=E*H.scanlineBlockSize,z=V+H.scanOrder(c);if(z>=H.height)continue;const t=V*H.bytesPerLine,Q=(H.height-1-z)*H.outLineWidth;for(let V=0;V<H.channels;V++){const c=p.channels[V].name,E=H.channelLineOffsets[c],z=H.decodeChannels[c];if(void 0!==z){C.value=t+E;for(let p=0;p<H.width;p++){const V=Q+p*H.outputChannels+z;H.byteArray&&(H.byteArray[V]=H.getter(w,C))}}}}}}(w,z,C,E);V(z.dataWindow.xMax-z.dataWindow.xMin+1,z.dataWindow.yMax-z.dataWindow.yMin+1,p.generateMipMaps,!1,(()=>{const H=p.getEngine();p.format=z.format,p.type=w.textureType,p.invertY=!1,p._gammaSpace=!z.linearSpace,w.byteArray&&H._uploadDataToTextureDirectly(p,w.byteArray,0,0,void 0,!0)}))}}}}]);