"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12677:(K,q,p)=>{p.r(q),p.d(q,{_ExrTextureLoader:()=>Q});var Z=p(10716),z=p(11024);const S=65536,X=14,y=65537,V=16384;var C,h;!function(K){K[K.NO_COMPRESSION=0]="NO_COMPRESSION",K[K.RLE_COMPRESSION=1]="RLE_COMPRESSION",K[K.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",K[K.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",K[K.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",K[K.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(C||(C={})),function(K){K[K.INCREASING_Y=0]="INCREASING_Y",K[K.DECREASING_Y=1]="DECREASING_Y"}(h||(h={}));const U=function(){const K=new ArrayBuffer(4),q=new Float32Array(K),p=new Uint32Array(K),Z=new Uint32Array(512),z=new Uint32Array(512);for(let V=0;V<256;++V){const K=V-127;K<-27?(Z[V]=0,Z[256|V]=32768,z[V]=24,z[256|V]=24):K<-14?(Z[V]=1024>>-K-14,Z[256|V]=1024>>-K-14|32768,z[V]=-K-1,z[256|V]=-K-1):K<=15?(Z[V]=K+15<<10,Z[256|V]=K+15<<10|32768,z[V]=13,z[256|V]=13):K<128?(Z[V]=31744,Z[256|V]=64512,z[V]=24,z[256|V]=24):(Z[V]=31744,Z[256|V]=64512,z[V]=13,z[256|V]=13)}const S=new Uint32Array(2048),X=new Uint32Array(64),y=new Uint32Array(64);for(let V=1;V<1024;++V){let K=V<<13,q=0;for(;0===(8388608&K);)K<<=1,q-=8388608;K&=-8388609,q+=947912704,S[V]=K|q}for(let V=1024;V<2048;++V)S[V]=939524096+(V-1024<<13);for(let V=1;V<31;++V)X[V]=V<<23;X[31]=1199570944,X[32]=2147483648;for(let V=33;V<63;++V)X[V]=2147483648+(V-32<<23);X[63]=3347054592;for(let V=1;V<64;++V)32!==V&&(y[V]=1024);return{floatView:q,uint32View:p,baseTable:Z,shiftTable:z,mantissaTable:S,exponentTable:X,offsetTable:y}}();function Y(K,q){const p=new Uint8Array(K);let Z=0;for(;0!=p[q.value+Z];)Z+=1;const z=(new TextDecoder).decode(p.slice(q.value,q.value+Z));return q.value=q.value+Z+1,z}function k(K,q){const p=K.getInt32(q.value,!0);return q.value+=4,p}function F(K,q){const p=K.getUint32(q.value,!0);return q.value+=4,p}function x(K,q){const p=K.getUint8(q.value);return q.value+=1,p}function t(K,q){const p=K.getUint16(q.value,!0);return q.value+=2,p}function f(K,q){const p=K[q.value];return q.value+=1,p}function E(K,q){let p;return p="getBigInt64"in DataView.prototype?Number(K.getBigInt64(q.value,!0)):K.getUint32(q.value+4,!0)+Number(K.getUint32(q.value,!0)<<32),q.value+=8,p}function m(K,q){const p=K.getFloat32(q.value,!0);return q.value+=4,p}function c(K,q){return function(K){const q=(31744&K)>>10,p=1023&K;return(K>>15?-1:1)*(q?31===q?p?NaN:1/0:Math.pow(2,q-15)*(1+p/1024):p/1024*6103515625e-14)}(t(K,q))}function l(K,q){return function(K){if(Math.abs(K)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");K=(0,z.d)(K,-65504,65504),U.floatView[0]=K;const q=U.uint32View[0],p=q>>23&511;return U.baseTable[p]+((8388607&q)>>U.shiftTable[p])}(m(K,q))}function R(K,q,p,Z){switch(p){case"string":case"stringvector":case"iccProfile":return function(K,q,p){const Z=(new TextDecoder).decode(new Uint8Array(K).slice(q.value,q.value+p));return q.value=q.value+p,Z}(K.buffer,q,Z);case"chlist":return function(K,q,p){const Z=q.value,z=[];for(;q.value<Z+p-1;){const p=Y(K.buffer,q),Z=k(K,q),S=x(K,q);q.value+=3;const X=k(K,q),y=k(K,q);z.push({name:p,pixelType:Z,pLinear:S,xSampling:X,ySampling:y})}return q.value+=1,z}(K,q,Z);case"chromaticities":return function(K,q){return{redX:m(K,q),redY:m(K,q),greenX:m(K,q),greenY:m(K,q),blueX:m(K,q),blueY:m(K,q),whiteX:m(K,q),whiteY:m(K,q)}}(K,q);case"compression":return function(K,q){return x(K,q)}(K,q);case"box2i":return function(K,q){return{xMin:k(K,q),yMin:k(K,q),xMax:k(K,q),yMax:k(K,q)}}(K,q);case"lineOrder":return function(K,q){const p=x(K,q);return h[p]}(K,q);case"float":return m(K,q);case"v2f":return function(K,q){return[m(K,q),m(K,q)]}(K,q);case"v3f":return function(K,q){return[m(K,q),m(K,q),m(K,q)]}(K,q);case"int":return k(K,q);case"rational":return function(K,q){return[k(K,q),F(K,q)]}(K,q);case"timecode":return function(K,q){return[F(K,q),F(K,q)]}(K,q);case"preview":return q.value+=Z,"skipped";default:return void(q.value+=Z)}}function P(K){for(let q=1;q<K.length;q++){const p=K[q-1]+K[q]-128;K[q]=p}}function g(K,q){let p=0,Z=Math.floor((K.length+1)/2),z=0;const S=K.length-1;for(;!(z>S)&&(q[z++]=K[p++],!(z>S));)q[z++]=K[Z++]}function j(K,q,p,Z,z){for(;p<K;)q=q<<8|f(Z,z),p+=8;return{l:q>>(p-=K)&(1<<K)-1,c:q,lc:p}}function N(K,q,p,Z){return{c:K=K<<8|f(p,Z),lc:q+=8}}function I(K,q,p,Z,z,S,X,y,V){if(K==q){if(Z<8){const K=N(p,Z,z,S);p=K.c,Z=K.lc}let K=p>>(Z-=8);if(K=new Uint8Array([K])[0],y.value+K>V)return null;const q=X[y.value-1];for(;K-- >0;)X[y.value++]=q}else{if(!(y.value<V))return null;X[y.value++]=K}return{c:p,lc:Z}}const M=new Array(59);function i(K,q,p,Z,z,S){const X=q;let V=0,C=0;for(;Z<=z;Z++){if(X.value-q.value>p)return;let y=j(6,V,C,K,X);const h=y.l;if(V=y.c,C=y.lc,S[Z]=h,63==h){if(X.value-q.value>p)throw new Error("Error in HufUnpackEncTable");y=j(8,V,C,K,X);let h=y.l+6;if(V=y.c,C=y.lc,Z+h>z+1)throw new Error("Error in HufUnpackEncTable");for(;h--;)S[Z++]=0;Z--}else if(h>=59){let K=h-59+2;if(Z+K>z+1)throw new Error("Error in HufUnpackEncTable");for(;K--;)S[Z++]=0;Z--}}!function(K){for(let p=0;p<=58;++p)M[p]=0;for(let p=0;p<y;++p)M[K[p]]+=1;let q=0;for(let p=58;p>0;--p){const K=q+M[p]>>1;M[p]=q,q=K}for(let p=0;p<y;++p){const q=K[p];q>0&&(K[p]=q|M[q]++<<6)}}(S)}function H(K){return 63&K}function a(K){return K>>6}function G(K,q,p,Z,z,S){const C=p.value,h=F(q,p),U=F(q,p);p.value+=4;const Y=F(q,p);if(p.value+=4,h<0||h>=y||U<0||U>=y)throw new Error("Wrong HUF_ENCSIZE");const k=new Array(y),x=new Array(V);!function(K){for(let q=0;q<V;q++)K[q]={},K[q].len=0,K[q].lit=0,K[q].p=null}(x);if(i(K,p,Z-(p.value-C),h,U,k),Y>8*(Z-(p.value-C)))throw new Error("Wrong hufUncompress");!function(K,q,p,Z){for(;q<=p;q++){const p=a(K[q]),z=H(K[q]);if(p>>z)throw new Error("Invalid table entry");if(z>X){const K=Z[p>>z-X];if(K.len)throw new Error("Invalid table entry");if(K.lit++,K.p){const q=K.p;K.p=new Array(K.lit);for(let p=0;p<K.lit-1;++p)K.p[p]=q[p]}else K.p=new Array(1);K.p[K.lit-1]=q}else if(z){let K=0;for(let S=1<<X-z;S>0;S--){const S=Z[(p<<X-z)+K];if(S.len||S.p)throw new Error("Invalid table entry");S.len=z,S.lit=q,K++}}}}(k,h,U,x),function(K,q,p,Z,z,S,y,V,C){let h=0,U=0;const Y=y,k=Math.trunc(Z.value+(z+7)/8);for(;Z.value<k;){let z=N(h,U,p,Z);for(h=z.c,U=z.lc;U>=X;){const y=q[h>>U-X&16383];if(y.len){U-=y.len;const K=I(y.lit,S,h,U,p,Z,V,C,Y);K&&(h=K.c,U=K.lc)}else{if(!y.p)throw new Error("hufDecode issues");let q;for(q=0;q<y.lit;q++){const X=H(K[y.p[q]]);for(;U<X&&Z.value<k;)z=N(h,U,p,Z),h=z.c,U=z.lc;if(U>=X&&a(K[y.p[q]])==(h>>U-X&(1<<X)-1)){U-=X;const K=I(y.p[q],S,h,U,p,Z,V,C,Y);K&&(h=K.c,U=K.lc);break}}if(q==y.lit)throw new Error("HufDecode issues")}}}const F=8-z&7;for(h>>=F,U-=F;U>0;){const K=q[h<<X-U&16383];if(!K.len)throw new Error("HufDecode issues");{U-=K.len;const q=I(K.lit,S,h,U,p,Z,V,C,Y);q&&(h=q.c,U=q.lc)}}}(k,x,K,p,Y,U,S,z,{value:0})}function s(K){return 65535&K}function b(K){const q=s(K);return q>32767?q-65536:q}function e(K,q){const p=b(K),Z=b(q),z=p+(1&Z)+(Z>>1);return{a:z,b:z-Z}}function d(K,q){const p=s(K),Z=s(q),z=p-(Z>>1)&65535;return{a:Z+z-32768&65535,b:z}}function D(K,q,p,Z,z,S,X){const y=X<16384,V=p>z?z:p;let C,h,U=1;for(;U<=V;)U<<=1;for(U>>=1,C=U,U>>=1;U>=1;){h=0;const X=h+S*(z-C),V=S*U,Y=S*C,k=Z*U,F=Z*C;let x,t,f,E;for(;h<=X;h+=Y){let z=h;const S=h+Z*(p-C);for(;z<=S;z+=F){const p=z+k,Z=z+V,S=Z+k;if(y){let X=e(K[z+q],K[Z+q]);x=X.a,f=X.b,X=e(K[p+q],K[S+q]),t=X.a,E=X.b,X=e(x,t),K[z+q]=X.a,K[p+q]=X.b,X=e(f,E),K[Z+q]=X.a,K[S+q]=X.b}else{let X=d(K[z+q],K[Z+q]);x=X.a,f=X.b,X=d(K[p+q],K[S+q]),t=X.a,E=X.b,X=d(x,t),K[z+q]=X.a,K[p+q]=X.b,X=d(f,E),K[Z+q]=X.a,K[S+q]=X.b}}if(p&U){const p=z+V;let Z;Z=y?e(K[z+q],K[p+q]):d(K[z+q],K[p+q]),x=Z.a,K[p+q]=Z.b,K[z+q]=x}}if(z&U){let z=h;const S=h+Z*(p-C);for(;z<=S;z+=F){const p=z+k;let Z;Z=y?e(K[z+q],K[p+q]):d(K[z+q],K[p+q]),x=Z.a,K[p+q]=Z.b,K[z+q]=x}}C=U,U>>=1}return h}function O(K){return new DataView(K.array.buffer,K.offset.value,K.size)}function L(K){const q=K.viewer.buffer.slice(K.offset.value,K.offset.value+K.size),p=new Uint8Array(function(K){let q=K.byteLength;const p=new Array;let Z=0;const z=new DataView(K);for(;q>0;){const K=z.getInt8(Z++);if(K<0){const S=-K;q-=S+1;for(let K=0;K<S;K++)p.push(z.getUint8(Z++))}else{const S=K;q-=2;const X=z.getUint8(Z++);for(let K=0;K<S+1;K++)p.push(X)}}return p}(q)),Z=new Uint8Array(p.length);return P(p),g(p,Z),new DataView(Z.buffer)}function J(K){const q=K.array.slice(K.offset.value,K.offset.value+K.size),p=fflate.unzlibSync(q),Z=new Uint8Array(p.length);return P(p),g(p,Z),new DataView(Z.buffer)}function o(K){const q=K.array.slice(K.offset.value,K.offset.value+K.size),p=fflate.unzlibSync(q),Z=K.lines*K.channels*K.width,z=1==K.type?new Uint16Array(Z):new Uint32Array(Z);let S=0,X=0;const y=new Array(4);for(let V=0;V<K.lines;V++)for(let q=0;q<K.channels;q++){let q=0;switch(K.type){case 1:y[0]=S,y[1]=y[0]+K.width,S=y[1]+K.width;for(let Z=0;Z<K.width;++Z){q+=p[y[0]++]<<8|p[y[1]++],z[X]=q,X++}break;case 2:y[0]=S,y[1]=y[0]+K.width,y[2]=y[1]+K.width,S=y[2]+K.width;for(let Z=0;Z<K.width;++Z){q+=p[y[0]++]<<24|p[y[1]++]<<16|p[y[2]++]<<8,z[X]=q,X++}}}return new DataView(z.buffer)}function n(K){const q=K.viewer,p={value:K.offset.value},Z=new Uint16Array(K.width*K.scanlineBlockSize*(K.channels*K.type)),z=new Uint8Array(8192);let X=0;const y=new Array(K.channels);for(let S=0;S<K.channels;S++)y[S]={},y[S].start=X,y[S].end=y[S].start,y[S].nx=K.width,y[S].ny=K.lines,y[S].size=K.type,X+=y[S].nx*y[S].ny*y[S].size;const V=t(q,p),C=t(q,p);if(C>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(V<=C)for(let S=0;S<C-V+1;S++)z[S+V]=x(q,p);const h=new Uint16Array(S),U=function(K,q){let p=0;for(let z=0;z<S;++z)(0==z||K[z>>3]&1<<(7&z))&&(q[p++]=z);const Z=p-1;for(;p<S;)q[p++]=0;return Z}(z,h),Y=F(q,p);G(K.array,q,p,Y,Z,X);for(let S=0;S<K.channels;++S){const K=y[S];for(let q=0;q<y[S].size;++q)D(Z,K.start+q,K.nx,K.size,K.ny,K.nx*K.size,U)}!function(K,q,p){for(let Z=0;Z<p;++Z)q[Z]=K[q[Z]]}(h,Z,X);let k=0;const f=new Uint8Array(Z.buffer.byteLength);for(let S=0;S<K.lines;S++)for(let q=0;q<K.channels;q++){const K=y[q],p=K.nx*K.size,z=new Uint8Array(Z.buffer,2*K.end,2*p);f.set(z,k),k+=2*p,K.end+=p}return new DataView(f.buffer)}var W,v=p(10696);!function(K){K[K.Float=0]="Float",K[K.HalfFloat=1]="HalfFloat"}(W||(W={}));class w{}w.DefaultOutputType=W.HalfFloat,w.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Q{constructor(){this.supportCascades=!1}loadCubeData(K,q,p,Z,z){throw".exr not supported in Cube."}async loadData(K,q,p){const z=new DataView(K.buffer),S={value:0},X=function(K,q){if(20000630!=K.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const p=K.getUint8(4),z=K.getUint8(5),S={singleTile:!!(2&z),longName:!!(4&z),deepFormat:!!(8&z),multiPart:!!(16&z)};q.value=8;const X={};let y=!0;for(;y;){const p=Y(K.buffer,q);if(p){const z=Y(K.buffer,q),S=R(K,q,z,F(K,q));void 0===S?Z.c.Warn(`Unknown header attribute type ${z}'.`):X[p]=S}else y=!1}if(0!=(-5&z))throw new Error("Unsupported file format");return{version:p,spec:S,...X}}(z,S),y=await async function(K,q,p,Z){const z={size:0,viewer:q,array:new Uint8Array(q.buffer),offset:p,width:K.dataWindow.xMax-K.dataWindow.xMin+1,height:K.dataWindow.yMax-K.dataWindow.yMin+1,channels:K.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(K.compression){case C.NO_COMPRESSION:z.lines=1,z.uncompress=O;break;case C.RLE_COMPRESSION:z.lines=1,z.uncompress=L;break;case C.ZIPS_COMPRESSION:z.lines=1,z.uncompress=J,await v.h.LoadScriptAsync(w.FFLATEUrl);break;case C.ZIP_COMPRESSION:z.lines=16,z.uncompress=J,await v.h.LoadScriptAsync(w.FFLATEUrl);break;case C.PIZ_COMPRESSION:z.lines=32,z.uncompress=n;break;case C.PXR24_COMPRESSION:z.lines=16,z.uncompress=o,await v.h.LoadScriptAsync(w.FFLATEUrl);break;default:throw new Error(C[K.compression]+" is unsupported")}z.scanlineBlockSize=z.lines;const S={};for(const C of K.channels)switch(C.name){case"Y":case"R":case"G":case"B":case"A":S[C.name]=!0,z.type=C.pixelType}let X=!1;if(S.R&&S.G&&S.B)X=!S.A,z.outputChannels=4,z.decodeChannels={R:0,G:1,B:2,A:3};else{if(!S.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");z.outputChannels=1,z.decodeChannels={Y:0}}if(1===z.type)switch(Z){case W.Float:z.getter=c,z.inputSize=2;break;case W.HalfFloat:z.getter=t,z.inputSize=2}else{if(2!==z.type)throw new Error("Unsupported pixelType "+z.type+" for "+K.compression);switch(Z){case W.Float:z.getter=m,z.inputSize=4;break;case W.HalfFloat:z.getter=l,z.inputSize=4}}z.blockCount=z.height/z.scanlineBlockSize;for(let C=0;C<z.blockCount;C++)E(q,p);const y=z.width*z.height*z.outputChannels;switch(Z){case W.Float:z.byteArray=new Float32Array(y),z.textureType=1,X&&z.byteArray.fill(1,0,y);break;case W.HalfFloat:z.byteArray=new Uint16Array(y),z.textureType=2,X&&z.byteArray.fill(15360,0,y);break;default:throw new Error("Unsupported type: "+Z)}let V=0;for(const C of K.channels)void 0!==z.decodeChannels[C.name]&&(z.channelLineOffsets[C.name]=V*z.width),V+=2*C.pixelType;return z.bytesPerLine=z.width*V,z.outLineWidth=z.width*z.outputChannels,"INCREASING_Y"===K.lineOrder?z.scanOrder=K=>K:z.scanOrder=K=>z.height-1-K,4==z.outputChannels?(z.format=5,z.linearSpace=!0):(z.format=6,z.linearSpace=!1),z}(X,z,S,w.DefaultOutputType);!function(K,q,p,Z){const z={value:0};for(let S=0;S<K.height/K.scanlineBlockSize;S++){const X=k(p,Z)-q.dataWindow.yMin;K.size=F(p,Z),K.lines=X+K.scanlineBlockSize>K.height?K.height-X:K.scanlineBlockSize;const y=K.size<K.lines*K.bytesPerLine&&K.uncompress?K.uncompress(K):O(K);Z.value+=K.size;for(let p=0;p<K.scanlineBlockSize;p++){const Z=S*K.scanlineBlockSize,X=p+K.scanOrder(Z);if(X>=K.height)continue;const V=p*K.bytesPerLine,C=(K.height-1-X)*K.outLineWidth;for(let p=0;p<K.channels;p++){const Z=q.channels[p].name,S=K.channelLineOffsets[Z],X=K.decodeChannels[Z];if(void 0!==X){z.value=V+S;for(let q=0;q<K.width;q++){const p=C+q*K.outputChannels+X;K.byteArray&&(K.byteArray[p]=K.getter(y,z))}}}}}}(y,X,z,S);p(X.dataWindow.xMax-X.dataWindow.xMin+1,X.dataWindow.yMax-X.dataWindow.yMin+1,q.generateMipMaps,!1,(()=>{const K=q.getEngine();q.format=X.format,q.type=y.textureType,q.invertY=!1,q._gammaSpace=!X.linearSpace,y.byteArray&&K._uploadDataToTextureDirectly(q,y.byteArray,0,0,void 0,!0)}))}}}}]);