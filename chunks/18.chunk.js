"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{2230:(L,j,P)=>{function A(L){return Math.floor(L/8)}function R(L){return 1<<L%8}P.d(j,{OptimizeIndices:()=>Y});class o{constructor(L){this.size=L,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(L){if(L>=this.size)throw new RangeError("Bit index out of range");const j=A(L),P=R(L);return 0!==(this._byteArray[j]&P)}set(L,j){if(L>=this.size)throw new RangeError("Bit index out of range");const P=A(L),o=R(L);j?this._byteArray[P]|=o:this._byteArray[P]&=~o}}function Y(L){const j=[],P=L.length/3;for(let o=0;o<P;o++)j.push([L[3*o],L[3*o+1],L[3*o+2]]);const A=new Map;for(let o=0;o<j.length;o++){const L=j[o];for(const j of L){let L=A.get(j);L||A.set(j,L=[]),L.push(o)}}const R=new o(P),Y=[],u=L=>{const P=[L];for(;P.length>0;){const L=P.pop();if(!R.get(L)){R.set(L,!0),Y.push(j[L]);for(const o of j[L]){const L=A.get(o);if(!L)return;for(const j of L)R.get(j)||P.push(j)}}}};for(let o=0;o<P;o++)R.get(o)||u(o);let a=0;for(const o of Y)L[a++]=o[0],L[a++]=o[1],L[a++]=o[2]}}}]);