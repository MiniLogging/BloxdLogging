"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{2509:(Z,U,n)=>{function i(Z){return Math.floor(Z/8)}function B(Z){return 1<<Z%8}n.d(U,{OptimizeIndices:()=>H});class l{constructor(Z){this.size=Z,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(Z){if(Z>=this.size)throw new RangeError("Bit index out of range");const U=i(Z),n=B(Z);return 0!==(this._byteArray[U]&n)}set(Z,U){if(Z>=this.size)throw new RangeError("Bit index out of range");const n=i(Z),l=B(Z);U?this._byteArray[n]|=l:this._byteArray[n]&=~l}}function H(Z){const U=[],n=Z.length/3;for(let l=0;l<n;l++)U.push([Z[3*l],Z[3*l+1],Z[3*l+2]]);const i=new Map;for(let l=0;l<U.length;l++){const Z=U[l];for(const U of Z){let Z=i.get(U);Z||i.set(U,Z=[]),Z.push(l)}}const B=new l(n),H=[],V=Z=>{const n=[Z];for(;n.length>0;){const Z=n.pop();if(!B.get(Z)){B.set(Z,!0),H.push(U[Z]);for(const l of U[Z]){const Z=i.get(l);if(!Z)return;for(const U of Z)B.get(U)||n.push(U)}}}};for(let l=0;l<n;l++)B.get(l)||V(l);let G=0;for(const l of H)Z[G++]=l[0],Z[G++]=l[1],Z[G++]=l[2]}}}]);