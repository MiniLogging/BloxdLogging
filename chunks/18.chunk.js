"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12756:(a,R,Y)=>{Y.r(R),Y.d(R,{_ExrTextureLoader:()=>G});var T=Y(10753),c=Y(11099);const K=65536,g=14,t=65537,U=16384;var b,C;!function(a){a[a.NO_COMPRESSION=0]="NO_COMPRESSION",a[a.RLE_COMPRESSION=1]="RLE_COMPRESSION",a[a.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",a[a.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",a[a.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",a[a.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(b||(b={})),function(a){a[a.INCREASING_Y=0]="INCREASING_Y",a[a.DECREASING_Y=1]="DECREASING_Y"}(C||(C={}));const e=function(){const a=new ArrayBuffer(4),R=new Float32Array(a),Y=new Uint32Array(a),T=new Uint32Array(512),c=new Uint32Array(512);for(let U=0;U<256;++U){const a=U-127;a<-27?(T[U]=0,T[256|U]=32768,c[U]=24,c[256|U]=24):a<-14?(T[U]=1024>>-a-14,T[256|U]=1024>>-a-14|32768,c[U]=-a-1,c[256|U]=-a-1):a<=15?(T[U]=a+15<<10,T[256|U]=a+15<<10|32768,c[U]=13,c[256|U]=13):a<128?(T[U]=31744,T[256|U]=64512,c[U]=24,c[256|U]=24):(T[U]=31744,T[256|U]=64512,c[U]=13,c[256|U]=13)}const K=new Uint32Array(2048),g=new Uint32Array(64),t=new Uint32Array(64);for(let U=1;U<1024;++U){let a=U<<13,R=0;for(;0===(8388608&a);)a<<=1,R-=8388608;a&=-8388609,R+=947912704,K[U]=a|R}for(let U=1024;U<2048;++U)K[U]=939524096+(U-1024<<13);for(let U=1;U<31;++U)g[U]=U<<23;g[31]=1199570944,g[32]=2147483648;for(let U=33;U<63;++U)g[U]=2147483648+(U-32<<23);g[63]=3347054592;for(let U=1;U<64;++U)32!==U&&(t[U]=1024);return{floatView:R,uint32View:Y,baseTable:T,shiftTable:c,mantissaTable:K,exponentTable:g,offsetTable:t}}();function Z(a,R){const Y=new Uint8Array(a);let T=0;for(;0!=Y[R.value+T];)T+=1;const c=(new TextDecoder).decode(Y.slice(R.value,R.value+T));return R.value=R.value+T+1,c}function W(a,R){const Y=a.getInt32(R.value,!0);return R.value+=4,Y}function o(a,R){const Y=a.getUint32(R.value,!0);return R.value+=4,Y}function i(a,R){const Y=a.getUint8(R.value);return R.value+=1,Y}function d(a,R){const Y=a.getUint16(R.value,!0);return R.value+=2,Y}function v(a,R){const Y=a[R.value];return R.value+=1,Y}function A(a,R){let Y;return Y="getBigInt64"in DataView.prototype?Number(a.getBigInt64(R.value,!0)):a.getUint32(R.value+4,!0)+Number(a.getUint32(R.value,!0)<<32),R.value+=8,Y}function r(a,R){const Y=a.getFloat32(R.value,!0);return R.value+=4,Y}function m(a,R){return function(a){const R=(31744&a)>>10,Y=1023&a;return(a>>15?-1:1)*(R?31===R?Y?NaN:1/0:Math.pow(2,R-15)*(1+Y/1024):Y/1024*6103515625e-14)}(d(a,R))}function H(a,R){return function(a){if(Math.abs(a)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");a=(0,c.c)(a,-65504,65504),e.floatView[0]=a;const R=e.uint32View[0],Y=R>>23&511;return e.baseTable[Y]+((8388607&R)>>e.shiftTable[Y])}(r(a,R))}function L(a,R,Y,T){switch(Y){case"string":case"stringvector":case"iccProfile":return function(a,R,Y){const T=(new TextDecoder).decode(new Uint8Array(a).slice(R.value,R.value+Y));return R.value=R.value+Y,T}(a.buffer,R,T);case"chlist":return function(a,R,Y){const T=R.value,c=[];for(;R.value<T+Y-1;){const Y=Z(a.buffer,R),T=W(a,R),K=i(a,R);R.value+=3;const g=W(a,R),t=W(a,R);c.push({name:Y,pixelType:T,pLinear:K,xSampling:g,ySampling:t})}return R.value+=1,c}(a,R,T);case"chromaticities":return function(a,R){return{redX:r(a,R),redY:r(a,R),greenX:r(a,R),greenY:r(a,R),blueX:r(a,R),blueY:r(a,R),whiteX:r(a,R),whiteY:r(a,R)}}(a,R);case"compression":return function(a,R){return i(a,R)}(a,R);case"box2i":return function(a,R){return{xMin:W(a,R),yMin:W(a,R),xMax:W(a,R),yMax:W(a,R)}}(a,R);case"lineOrder":return function(a,R){const Y=i(a,R);return C[Y]}(a,R);case"float":return r(a,R);case"v2f":return function(a,R){return[r(a,R),r(a,R)]}(a,R);case"v3f":return function(a,R){return[r(a,R),r(a,R),r(a,R)]}(a,R);case"int":return W(a,R);case"rational":return function(a,R){return[W(a,R),o(a,R)]}(a,R);case"timecode":return function(a,R){return[o(a,R),o(a,R)]}(a,R);case"preview":return R.value+=T,"skipped";default:return void(R.value+=T)}}function N(a){for(let R=1;R<a.length;R++){const Y=a[R-1]+a[R]-128;a[R]=Y}}function k(a,R){let Y=0,T=Math.floor((a.length+1)/2),c=0;const K=a.length-1;for(;!(c>K)&&(R[c++]=a[Y++],!(c>K));)R[c++]=a[T++]}function J(a,R,Y,T,c){for(;Y<a;)R=R<<8|v(T,c),Y+=8;return{l:R>>(Y-=a)&(1<<a)-1,c:R,lc:Y}}function Q(a,R,Y,T){return{c:a=a<<8|v(Y,T),lc:R+=8}}function s(a,R,Y,T,c,K,g,t,U){if(a==R){if(T<8){const a=Q(Y,T,c,K);Y=a.c,T=a.lc}let a=Y>>(T-=8);if(a=new Uint8Array([a])[0],t.value+a>U)return null;const R=g[t.value-1];for(;a-- >0;)g[t.value++]=R}else{if(!(t.value<U))return null;g[t.value++]=a}return{c:Y,lc:T}}const F=new Array(59);function D(a,R,Y,T,c,K){const g=R;let U=0,b=0;for(;T<=c;T++){if(g.value-R.value>Y)return;let t=J(6,U,b,a,g);const C=t.l;if(U=t.c,b=t.lc,K[T]=C,63==C){if(g.value-R.value>Y)throw new Error("Error in HufUnpackEncTable");t=J(8,U,b,a,g);let C=t.l+6;if(U=t.c,b=t.lc,T+C>c+1)throw new Error("Error in HufUnpackEncTable");for(;C--;)K[T++]=0;T--}else if(C>=59){let a=C-59+2;if(T+a>c+1)throw new Error("Error in HufUnpackEncTable");for(;a--;)K[T++]=0;T--}}!function(a){for(let Y=0;Y<=58;++Y)F[Y]=0;for(let Y=0;Y<t;++Y)F[a[Y]]+=1;let R=0;for(let Y=58;Y>0;--Y){const a=R+F[Y]>>1;F[Y]=R,R=a}for(let Y=0;Y<t;++Y){const R=a[Y];R>0&&(a[Y]=R|F[R]++<<6)}}(K)}function B(a){return 63&a}function l(a){return a>>6}function V(a,R,Y,T,c,K){const b=Y.value,C=o(R,Y),e=o(R,Y);Y.value+=4;const Z=o(R,Y);if(Y.value+=4,C<0||C>=t||e<0||e>=t)throw new Error("Wrong HUF_ENCSIZE");const W=new Array(t),i=new Array(U);!function(a){for(let R=0;R<U;R++)a[R]={},a[R].len=0,a[R].lit=0,a[R].p=null}(i);if(D(a,Y,T-(Y.value-b),C,e,W),Z>8*(T-(Y.value-b)))throw new Error("Wrong hufUncompress");!function(a,R,Y,T){for(;R<=Y;R++){const Y=l(a[R]),c=B(a[R]);if(Y>>c)throw new Error("Invalid table entry");if(c>g){const a=T[Y>>c-g];if(a.len)throw new Error("Invalid table entry");if(a.lit++,a.p){const R=a.p;a.p=new Array(a.lit);for(let Y=0;Y<a.lit-1;++Y)a.p[Y]=R[Y]}else a.p=new Array(1);a.p[a.lit-1]=R}else if(c){let a=0;for(let K=1<<g-c;K>0;K--){const K=T[(Y<<g-c)+a];if(K.len||K.p)throw new Error("Invalid table entry");K.len=c,K.lit=R,a++}}}}(W,C,e,i),function(a,R,Y,T,c,K,t,U,b){let C=0,e=0;const Z=t,W=Math.trunc(T.value+(c+7)/8);for(;T.value<W;){let c=Q(C,e,Y,T);for(C=c.c,e=c.lc;e>=g;){const t=R[C>>e-g&16383];if(t.len){e-=t.len;const a=s(t.lit,K,C,e,Y,T,U,b,Z);a&&(C=a.c,e=a.lc)}else{if(!t.p)throw new Error("hufDecode issues");let R;for(R=0;R<t.lit;R++){const g=B(a[t.p[R]]);for(;e<g&&T.value<W;)c=Q(C,e,Y,T),C=c.c,e=c.lc;if(e>=g&&l(a[t.p[R]])==(C>>e-g&(1<<g)-1)){e-=g;const a=s(t.p[R],K,C,e,Y,T,U,b,Z);a&&(C=a.c,e=a.lc);break}}if(R==t.lit)throw new Error("HufDecode issues")}}}const o=8-c&7;for(C>>=o,e-=o;e>0;){const a=R[C<<g-e&16383];if(!a.len)throw new Error("HufDecode issues");{e-=a.len;const R=s(a.lit,K,C,e,Y,T,U,b,Z);R&&(C=R.c,e=R.lc)}}}(W,i,a,Y,Z,e,K,c,{value:0})}function f(a){return 65535&a}function I(a){const R=f(a);return R>32767?R-65536:R}function j(a,R){const Y=I(a),T=I(R),c=Y+(1&T)+(T>>1);return{a:c,b:c-T}}function x(a,R){const Y=f(a),T=f(R),c=Y-(T>>1)&65535;return{a:T+c-32768&65535,b:c}}function E(a,R,Y,T,c,K,g){const t=g<16384,U=Y>c?c:Y;let b,C,e=1;for(;e<=U;)e<<=1;for(e>>=1,b=e,e>>=1;e>=1;){C=0;const g=C+K*(c-b),U=K*e,Z=K*b,W=T*e,o=T*b;let i,d,v,A;for(;C<=g;C+=Z){let c=C;const K=C+T*(Y-b);for(;c<=K;c+=o){const Y=c+W,T=c+U,K=T+W;if(t){let g=j(a[c+R],a[T+R]);i=g.a,v=g.b,g=j(a[Y+R],a[K+R]),d=g.a,A=g.b,g=j(i,d),a[c+R]=g.a,a[Y+R]=g.b,g=j(v,A),a[T+R]=g.a,a[K+R]=g.b}else{let g=x(a[c+R],a[T+R]);i=g.a,v=g.b,g=x(a[Y+R],a[K+R]),d=g.a,A=g.b,g=x(i,d),a[c+R]=g.a,a[Y+R]=g.b,g=x(v,A),a[T+R]=g.a,a[K+R]=g.b}}if(Y&e){const Y=c+U;let T;T=t?j(a[c+R],a[Y+R]):x(a[c+R],a[Y+R]),i=T.a,a[Y+R]=T.b,a[c+R]=i}}if(c&e){let c=C;const K=C+T*(Y-b);for(;c<=K;c+=o){const Y=c+W;let T;T=t?j(a[c+R],a[Y+R]):x(a[c+R],a[Y+R]),i=T.a,a[Y+R]=T.b,a[c+R]=i}}b=e,e>>=1}return C}function O(a){return new DataView(a.array.buffer,a.offset.value,a.size)}function u(a){const R=a.viewer.buffer.slice(a.offset.value,a.offset.value+a.size),Y=new Uint8Array(function(a){let R=a.byteLength;const Y=new Array;let T=0;const c=new DataView(a);for(;R>0;){const a=c.getInt8(T++);if(a<0){const K=-a;R-=K+1;for(let a=0;a<K;a++)Y.push(c.getUint8(T++))}else{const K=a;R-=2;const g=c.getUint8(T++);for(let a=0;a<K+1;a++)Y.push(g)}}return Y}(R)),T=new Uint8Array(Y.length);return N(Y),k(Y,T),new DataView(T.buffer)}function M(a){const R=a.array.slice(a.offset.value,a.offset.value+a.size),Y=fflate.unzlibSync(R),T=new Uint8Array(Y.length);return N(Y),k(Y,T),new DataView(T.buffer)}function S(a){const R=a.array.slice(a.offset.value,a.offset.value+a.size),Y=fflate.unzlibSync(R),T=a.lines*a.channels*a.width,c=1==a.type?new Uint16Array(T):new Uint32Array(T);let K=0,g=0;const t=new Array(4);for(let U=0;U<a.lines;U++)for(let R=0;R<a.channels;R++){let R=0;switch(a.type){case 1:t[0]=K,t[1]=t[0]+a.width,K=t[1]+a.width;for(let T=0;T<a.width;++T){R+=Y[t[0]++]<<8|Y[t[1]++],c[g]=R,g++}break;case 2:t[0]=K,t[1]=t[0]+a.width,t[2]=t[1]+a.width,K=t[2]+a.width;for(let T=0;T<a.width;++T){R+=Y[t[0]++]<<24|Y[t[1]++]<<16|Y[t[2]++]<<8,c[g]=R,g++}}}return new DataView(c.buffer)}function h(a){const R=a.viewer,Y={value:a.offset.value},T=new Uint16Array(a.width*a.scanlineBlockSize*(a.channels*a.type)),c=new Uint8Array(8192);let g=0;const t=new Array(a.channels);for(let K=0;K<a.channels;K++)t[K]={},t[K].start=g,t[K].end=t[K].start,t[K].nx=a.width,t[K].ny=a.lines,t[K].size=a.type,g+=t[K].nx*t[K].ny*t[K].size;const U=d(R,Y),b=d(R,Y);if(b>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(U<=b)for(let K=0;K<b-U+1;K++)c[K+U]=i(R,Y);const C=new Uint16Array(K),e=function(a,R){let Y=0;for(let c=0;c<K;++c)(0==c||a[c>>3]&1<<(7&c))&&(R[Y++]=c);const T=Y-1;for(;Y<K;)R[Y++]=0;return T}(c,C),Z=o(R,Y);V(a.array,R,Y,Z,T,g);for(let K=0;K<a.channels;++K){const a=t[K];for(let R=0;R<t[K].size;++R)E(T,a.start+R,a.nx,a.size,a.ny,a.nx*a.size,e)}!function(a,R,Y){for(let T=0;T<Y;++T)R[T]=a[R[T]]}(C,T,g);let W=0;const v=new Uint8Array(T.buffer.byteLength);for(let K=0;K<a.lines;K++)for(let R=0;R<a.channels;R++){const a=t[R],Y=a.nx*a.size,c=new Uint8Array(T.buffer,2*a.end,2*Y);v.set(c,W),W+=2*Y,a.end+=Y}return new DataView(v.buffer)}var P,w=Y(10741);!function(a){a[a.Float=0]="Float",a[a.HalfFloat=1]="HalfFloat"}(P||(P={}));class p{}p.DefaultOutputType=P.HalfFloat,p.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class G{constructor(){this.supportCascades=!1}loadCubeData(a,R,Y,T,c){throw".exr not supported in Cube."}async loadData(a,R,Y){const c=new DataView(a.buffer),K={value:0},g=function(a,R){if(20000630!=a.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const Y=a.getUint8(4),c=a.getUint8(5),K={singleTile:!!(2&c),longName:!!(4&c),deepFormat:!!(8&c),multiPart:!!(16&c)};R.value=8;const g={};let t=!0;for(;t;){const Y=Z(a.buffer,R);if(Y){const c=Z(a.buffer,R),K=L(a,R,c,o(a,R));void 0===K?T.d.Warn(`Unknown header attribute type ${c}'.`):g[Y]=K}else t=!1}if(0!=(-5&c))throw new Error("Unsupported file format");return{version:Y,spec:K,...g}}(c,K),t=await async function(a,R,Y,T){const c={size:0,viewer:R,array:new Uint8Array(R.buffer),offset:Y,width:a.dataWindow.xMax-a.dataWindow.xMin+1,height:a.dataWindow.yMax-a.dataWindow.yMin+1,channels:a.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(a.compression){case b.NO_COMPRESSION:c.lines=1,c.uncompress=O;break;case b.RLE_COMPRESSION:c.lines=1,c.uncompress=u;break;case b.ZIPS_COMPRESSION:c.lines=1,c.uncompress=M,await w.h.LoadScriptAsync(p.FFLATEUrl);break;case b.ZIP_COMPRESSION:c.lines=16,c.uncompress=M,await w.h.LoadScriptAsync(p.FFLATEUrl);break;case b.PIZ_COMPRESSION:c.lines=32,c.uncompress=h;break;case b.PXR24_COMPRESSION:c.lines=16,c.uncompress=S,await w.h.LoadScriptAsync(p.FFLATEUrl);break;default:throw new Error(b[a.compression]+" is unsupported")}c.scanlineBlockSize=c.lines;const K={};for(const b of a.channels)switch(b.name){case"Y":case"R":case"G":case"B":case"A":K[b.name]=!0,c.type=b.pixelType}let g=!1;if(K.R&&K.G&&K.B)g=!K.A,c.outputChannels=4,c.decodeChannels={R:0,G:1,B:2,A:3};else{if(!K.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");c.outputChannels=1,c.decodeChannels={Y:0}}if(1===c.type)switch(T){case P.Float:c.getter=m,c.inputSize=2;break;case P.HalfFloat:c.getter=d,c.inputSize=2}else{if(2!==c.type)throw new Error("Unsupported pixelType "+c.type+" for "+a.compression);switch(T){case P.Float:c.getter=r,c.inputSize=4;break;case P.HalfFloat:c.getter=H,c.inputSize=4}}c.blockCount=c.height/c.scanlineBlockSize;for(let b=0;b<c.blockCount;b++)A(R,Y);const t=c.width*c.height*c.outputChannels;switch(T){case P.Float:c.byteArray=new Float32Array(t),c.textureType=1,g&&c.byteArray.fill(1,0,t);break;case P.HalfFloat:c.byteArray=new Uint16Array(t),c.textureType=2,g&&c.byteArray.fill(15360,0,t);break;default:throw new Error("Unsupported type: "+T)}let U=0;for(const b of a.channels)void 0!==c.decodeChannels[b.name]&&(c.channelLineOffsets[b.name]=U*c.width),U+=2*b.pixelType;return c.bytesPerLine=c.width*U,c.outLineWidth=c.width*c.outputChannels,"INCREASING_Y"===a.lineOrder?c.scanOrder=a=>a:c.scanOrder=a=>c.height-1-a,4==c.outputChannels?(c.format=5,c.linearSpace=!0):(c.format=6,c.linearSpace=!1),c}(g,c,K,p.DefaultOutputType);!function(a,R,Y,T){const c={value:0};for(let K=0;K<a.height/a.scanlineBlockSize;K++){const g=W(Y,T)-R.dataWindow.yMin;a.size=o(Y,T),a.lines=g+a.scanlineBlockSize>a.height?a.height-g:a.scanlineBlockSize;const t=a.size<a.lines*a.bytesPerLine&&a.uncompress?a.uncompress(a):O(a);T.value+=a.size;for(let Y=0;Y<a.scanlineBlockSize;Y++){const T=K*a.scanlineBlockSize,g=Y+a.scanOrder(T);if(g>=a.height)continue;const U=Y*a.bytesPerLine,b=(a.height-1-g)*a.outLineWidth;for(let Y=0;Y<a.channels;Y++){const T=R.channels[Y].name,K=a.channelLineOffsets[T],g=a.decodeChannels[T];if(void 0!==g){c.value=U+K;for(let R=0;R<a.width;R++){const Y=b+R*a.outputChannels+g;a.byteArray&&(a.byteArray[Y]=a.getter(t,c))}}}}}}(t,g,c,K);Y(g.dataWindow.xMax-g.dataWindow.xMin+1,g.dataWindow.yMax-g.dataWindow.yMin+1,R.generateMipMaps,!1,(()=>{const a=R.getEngine();R.format=g.format,R.type=t.textureType,R.invertY=!1,R._gammaSpace=!g.linearSpace,t.byteArray&&a._uploadDataToTextureDirectly(R,t.byteArray,0,0,void 0,!0)}))}}}}]);