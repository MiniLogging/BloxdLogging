"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12885:(V,O,Z)=>{Z.r(O),Z.d(O,{_ExrTextureLoader:()=>h});var d=Z(10914),p=Z(11263);const r=65536,Y=14,m=65537,a=16384;var R,i;!function(V){V[V.NO_COMPRESSION=0]="NO_COMPRESSION",V[V.RLE_COMPRESSION=1]="RLE_COMPRESSION",V[V.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",V[V.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",V[V.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",V[V.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(R||(R={})),function(V){V[V.INCREASING_Y=0]="INCREASING_Y",V[V.DECREASING_Y=1]="DECREASING_Y"}(i||(i={}));const M=function(){const V=new ArrayBuffer(4),O=new Float32Array(V),Z=new Uint32Array(V),d=new Uint32Array(512),p=new Uint32Array(512);for(let a=0;a<256;++a){const V=a-127;V<-27?(d[a]=0,d[256|a]=32768,p[a]=24,p[256|a]=24):V<-14?(d[a]=1024>>-V-14,d[256|a]=1024>>-V-14|32768,p[a]=-V-1,p[256|a]=-V-1):V<=15?(d[a]=V+15<<10,d[256|a]=V+15<<10|32768,p[a]=13,p[256|a]=13):V<128?(d[a]=31744,d[256|a]=64512,p[a]=24,p[256|a]=24):(d[a]=31744,d[256|a]=64512,p[a]=13,p[256|a]=13)}const r=new Uint32Array(2048),Y=new Uint32Array(64),m=new Uint32Array(64);for(let a=1;a<1024;++a){let V=a<<13,O=0;for(;0===(8388608&V);)V<<=1,O-=8388608;V&=-8388609,O+=947912704,r[a]=V|O}for(let a=1024;a<2048;++a)r[a]=939524096+(a-1024<<13);for(let a=1;a<31;++a)Y[a]=a<<23;Y[31]=1199570944,Y[32]=2147483648;for(let a=33;a<63;++a)Y[a]=2147483648+(a-32<<23);Y[63]=3347054592;for(let a=1;a<64;++a)32!==a&&(m[a]=1024);return{floatView:O,uint32View:Z,baseTable:d,shiftTable:p,mantissaTable:r,exponentTable:Y,offsetTable:m}}();function c(V,O){const Z=new Uint8Array(V);let d=0;for(;0!=Z[O.value+d];)d+=1;const p=(new TextDecoder).decode(Z.slice(O.value,O.value+d));return O.value=O.value+d+1,p}function W(V,O){const Z=V.getInt32(O.value,!0);return O.value+=4,Z}function F(V,O){const Z=V.getUint32(O.value,!0);return O.value+=4,Z}function Q(V,O){const Z=V.getUint8(O.value);return O.value+=1,Z}function b(V,O){const Z=V.getUint16(O.value,!0);return O.value+=2,Z}function U(V,O){const Z=V[O.value];return O.value+=1,Z}function H(V,O){let Z;return Z="getBigInt64"in DataView.prototype?Number(V.getBigInt64(O.value,!0)):V.getUint32(O.value+4,!0)+Number(V.getUint32(O.value,!0)<<32),O.value+=8,Z}function S(V,O){const Z=V.getFloat32(O.value,!0);return O.value+=4,Z}function z(V,O){return function(V){const O=(31744&V)>>10,Z=1023&V;return(V>>15?-1:1)*(O?31===O?Z?NaN:1/0:Math.pow(2,O-15)*(1+Z/1024):Z/1024*6103515625e-14)}(b(V,O))}function G(V,O){return function(V){if(Math.abs(V)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");V=(0,p.c)(V,-65504,65504),M.floatView[0]=V;const O=M.uint32View[0],Z=O>>23&511;return M.baseTable[Z]+((8388607&O)>>M.shiftTable[Z])}(S(V,O))}function w(V,O,Z,d){switch(Z){case"string":case"stringvector":case"iccProfile":return function(V,O,Z){const d=(new TextDecoder).decode(new Uint8Array(V).slice(O.value,O.value+Z));return O.value=O.value+Z,d}(V.buffer,O,d);case"chlist":return function(V,O,Z){const d=O.value,p=[];for(;O.value<d+Z-1;){const Z=c(V.buffer,O),d=W(V,O),r=Q(V,O);O.value+=3;const Y=W(V,O),m=W(V,O);p.push({name:Z,pixelType:d,pLinear:r,xSampling:Y,ySampling:m})}return O.value+=1,p}(V,O,d);case"chromaticities":return function(V,O){return{redX:S(V,O),redY:S(V,O),greenX:S(V,O),greenY:S(V,O),blueX:S(V,O),blueY:S(V,O),whiteX:S(V,O),whiteY:S(V,O)}}(V,O);case"compression":return function(V,O){return Q(V,O)}(V,O);case"box2i":return function(V,O){return{xMin:W(V,O),yMin:W(V,O),xMax:W(V,O),yMax:W(V,O)}}(V,O);case"lineOrder":return function(V,O){const Z=Q(V,O);return i[Z]}(V,O);case"float":return S(V,O);case"v2f":return function(V,O){return[S(V,O),S(V,O)]}(V,O);case"v3f":return function(V,O){return[S(V,O),S(V,O),S(V,O)]}(V,O);case"int":return W(V,O);case"rational":return function(V,O){return[W(V,O),F(V,O)]}(V,O);case"timecode":return function(V,O){return[F(V,O),F(V,O)]}(V,O);case"preview":return O.value+=d,"skipped";default:return void(O.value+=d)}}function t(V){for(let O=1;O<V.length;O++){const Z=V[O-1]+V[O]-128;V[O]=Z}}function C(V,O){let Z=0,d=Math.floor((V.length+1)/2),p=0;const r=V.length-1;for(;!(p>r)&&(O[p++]=V[Z++],!(p>r));)O[p++]=V[d++]}function v(V,O,Z,d,p){for(;Z<V;)O=O<<8|U(d,p),Z+=8;return{l:O>>(Z-=V)&(1<<V)-1,c:O,lc:Z}}function A(V,O,Z,d){return{c:V=V<<8|U(Z,d),lc:O+=8}}function l(V,O,Z,d,p,r,Y,m,a){if(V==O){if(d<8){const V=A(Z,d,p,r);Z=V.c,d=V.lc}let V=Z>>(d-=8);if(V=new Uint8Array([V])[0],m.value+V>a)return null;const O=Y[m.value-1];for(;V-- >0;)Y[m.value++]=O}else{if(!(m.value<a))return null;Y[m.value++]=V}return{c:Z,lc:d}}const I=new Array(59);function g(V,O,Z,d,p,r){const Y=O;let a=0,R=0;for(;d<=p;d++){if(Y.value-O.value>Z)return;let m=v(6,a,R,V,Y);const i=m.l;if(a=m.c,R=m.lc,r[d]=i,63==i){if(Y.value-O.value>Z)throw new Error("Error in HufUnpackEncTable");m=v(8,a,R,V,Y);let i=m.l+6;if(a=m.c,R=m.lc,d+i>p+1)throw new Error("Error in HufUnpackEncTable");for(;i--;)r[d++]=0;d--}else if(i>=59){let V=i-59+2;if(d+V>p+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)r[d++]=0;d--}}!function(V){for(let Z=0;Z<=58;++Z)I[Z]=0;for(let Z=0;Z<m;++Z)I[V[Z]]+=1;let O=0;for(let Z=58;Z>0;--Z){const V=O+I[Z]>>1;I[Z]=O,O=V}for(let Z=0;Z<m;++Z){const O=V[Z];O>0&&(V[Z]=O|I[O]++<<6)}}(r)}function n(V){return 63&V}function e(V){return V>>6}function u(V,O,Z,d,p,r){const R=Z.value,i=F(O,Z),M=F(O,Z);Z.value+=4;const c=F(O,Z);if(Z.value+=4,i<0||i>=m||M<0||M>=m)throw new Error("Wrong HUF_ENCSIZE");const W=new Array(m),Q=new Array(a);!function(V){for(let O=0;O<a;O++)V[O]={},V[O].len=0,V[O].lit=0,V[O].p=null}(Q);if(g(V,Z,d-(Z.value-R),i,M,W),c>8*(d-(Z.value-R)))throw new Error("Wrong hufUncompress");!function(V,O,Z,d){for(;O<=Z;O++){const Z=e(V[O]),p=n(V[O]);if(Z>>p)throw new Error("Invalid table entry");if(p>Y){const V=d[Z>>p-Y];if(V.len)throw new Error("Invalid table entry");if(V.lit++,V.p){const O=V.p;V.p=new Array(V.lit);for(let Z=0;Z<V.lit-1;++Z)V.p[Z]=O[Z]}else V.p=new Array(1);V.p[V.lit-1]=O}else if(p){let V=0;for(let r=1<<Y-p;r>0;r--){const r=d[(Z<<Y-p)+V];if(r.len||r.p)throw new Error("Invalid table entry");r.len=p,r.lit=O,V++}}}}(W,i,M,Q),function(V,O,Z,d,p,r,m,a,R){let i=0,M=0;const c=m,W=Math.trunc(d.value+(p+7)/8);for(;d.value<W;){let p=A(i,M,Z,d);for(i=p.c,M=p.lc;M>=Y;){const m=O[i>>M-Y&16383];if(m.len){M-=m.len;const V=l(m.lit,r,i,M,Z,d,a,R,c);V&&(i=V.c,M=V.lc)}else{if(!m.p)throw new Error("hufDecode issues");let O;for(O=0;O<m.lit;O++){const Y=n(V[m.p[O]]);for(;M<Y&&d.value<W;)p=A(i,M,Z,d),i=p.c,M=p.lc;if(M>=Y&&e(V[m.p[O]])==(i>>M-Y&(1<<Y)-1)){M-=Y;const V=l(m.p[O],r,i,M,Z,d,a,R,c);V&&(i=V.c,M=V.lc);break}}if(O==m.lit)throw new Error("HufDecode issues")}}}const F=8-p&7;for(i>>=F,M-=F;M>0;){const V=O[i<<Y-M&16383];if(!V.len)throw new Error("HufDecode issues");{M-=V.len;const O=l(V.lit,r,i,M,Z,d,a,R,c);O&&(i=O.c,M=O.lc)}}}(W,Q,V,Z,c,M,r,p,{value:0})}function k(V){return 65535&V}function D(V){const O=k(V);return O>32767?O-65536:O}function X(V,O){const Z=D(V),d=D(O),p=Z+(1&d)+(d>>1);return{a:p,b:p-d}}function o(V,O){const Z=k(V),d=k(O),p=Z-(d>>1)&65535;return{a:d+p-32768&65535,b:p}}function E(V,O,Z,d,p,r,Y){const m=Y<16384,a=Z>p?p:Z;let R,i,M=1;for(;M<=a;)M<<=1;for(M>>=1,R=M,M>>=1;M>=1;){i=0;const Y=i+r*(p-R),a=r*M,c=r*R,W=d*M,F=d*R;let Q,b,U,H;for(;i<=Y;i+=c){let p=i;const r=i+d*(Z-R);for(;p<=r;p+=F){const Z=p+W,d=p+a,r=d+W;if(m){let Y=X(V[p+O],V[d+O]);Q=Y.a,U=Y.b,Y=X(V[Z+O],V[r+O]),b=Y.a,H=Y.b,Y=X(Q,b),V[p+O]=Y.a,V[Z+O]=Y.b,Y=X(U,H),V[d+O]=Y.a,V[r+O]=Y.b}else{let Y=o(V[p+O],V[d+O]);Q=Y.a,U=Y.b,Y=o(V[Z+O],V[r+O]),b=Y.a,H=Y.b,Y=o(Q,b),V[p+O]=Y.a,V[Z+O]=Y.b,Y=o(U,H),V[d+O]=Y.a,V[r+O]=Y.b}}if(Z&M){const Z=p+a;let d;d=m?X(V[p+O],V[Z+O]):o(V[p+O],V[Z+O]),Q=d.a,V[Z+O]=d.b,V[p+O]=Q}}if(p&M){let p=i;const r=i+d*(Z-R);for(;p<=r;p+=F){const Z=p+W;let d;d=m?X(V[p+O],V[Z+O]):o(V[p+O],V[Z+O]),Q=d.a,V[Z+O]=d.b,V[p+O]=Q}}R=M,M>>=1}return i}function L(V){return new DataView(V.array.buffer,V.offset.value,V.size)}function J(V){const O=V.viewer.buffer.slice(V.offset.value,V.offset.value+V.size),Z=new Uint8Array(function(V){let O=V.byteLength;const Z=new Array;let d=0;const p=new DataView(V);for(;O>0;){const V=p.getInt8(d++);if(V<0){const r=-V;O-=r+1;for(let V=0;V<r;V++)Z.push(p.getUint8(d++))}else{const r=V;O-=2;const Y=p.getUint8(d++);for(let V=0;V<r+1;V++)Z.push(Y)}}return Z}(O)),d=new Uint8Array(Z.length);return t(Z),C(Z,d),new DataView(d.buffer)}function N(V){const O=V.array.slice(V.offset.value,V.offset.value+V.size),Z=fflate.unzlibSync(O),d=new Uint8Array(Z.length);return t(Z),C(Z,d),new DataView(d.buffer)}function P(V){const O=V.array.slice(V.offset.value,V.offset.value+V.size),Z=fflate.unzlibSync(O),d=V.lines*V.channels*V.width,p=1==V.type?new Uint16Array(d):new Uint32Array(d);let r=0,Y=0;const m=new Array(4);for(let a=0;a<V.lines;a++)for(let O=0;O<V.channels;O++){let O=0;switch(V.type){case 1:m[0]=r,m[1]=m[0]+V.width,r=m[1]+V.width;for(let d=0;d<V.width;++d){O+=Z[m[0]++]<<8|Z[m[1]++],p[Y]=O,Y++}break;case 2:m[0]=r,m[1]=m[0]+V.width,m[2]=m[1]+V.width,r=m[2]+V.width;for(let d=0;d<V.width;++d){O+=Z[m[0]++]<<24|Z[m[1]++]<<16|Z[m[2]++]<<8,p[Y]=O,Y++}}}return new DataView(p.buffer)}function f(V){const O=V.viewer,Z={value:V.offset.value},d=new Uint16Array(V.width*V.scanlineBlockSize*(V.channels*V.type)),p=new Uint8Array(8192);let Y=0;const m=new Array(V.channels);for(let r=0;r<V.channels;r++)m[r]={},m[r].start=Y,m[r].end=m[r].start,m[r].nx=V.width,m[r].ny=V.lines,m[r].size=V.type,Y+=m[r].nx*m[r].ny*m[r].size;const a=b(O,Z),R=b(O,Z);if(R>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(a<=R)for(let r=0;r<R-a+1;r++)p[r+a]=Q(O,Z);const i=new Uint16Array(r),M=function(V,O){let Z=0;for(let p=0;p<r;++p)(0==p||V[p>>3]&1<<(7&p))&&(O[Z++]=p);const d=Z-1;for(;Z<r;)O[Z++]=0;return d}(p,i),c=F(O,Z);u(V.array,O,Z,c,d,Y);for(let r=0;r<V.channels;++r){const V=m[r];for(let O=0;O<m[r].size;++O)E(d,V.start+O,V.nx,V.size,V.ny,V.nx*V.size,M)}!function(V,O,Z){for(let d=0;d<Z;++d)O[d]=V[O[d]]}(i,d,Y);let W=0;const U=new Uint8Array(d.buffer.byteLength);for(let r=0;r<V.lines;r++)for(let O=0;O<V.channels;O++){const V=m[O],Z=V.nx*V.size,p=new Uint8Array(d.buffer,2*V.end,2*Z);U.set(p,W),W+=2*Z,V.end+=Z}return new DataView(U.buffer)}var q,K=Z(10900);!function(V){V[V.Float=0]="Float",V[V.HalfFloat=1]="HalfFloat"}(q||(q={}));class s{}s.DefaultOutputType=q.HalfFloat,s.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class h{constructor(){this.supportCascades=!1}loadCubeData(V,O,Z,d,p){throw".exr not supported in Cube."}async loadData(V,O,Z){const p=new DataView(V.buffer),r={value:0},Y=function(V,O){if(20000630!=V.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const Z=V.getUint8(4),p=V.getUint8(5),r={singleTile:!!(2&p),longName:!!(4&p),deepFormat:!!(8&p),multiPart:!!(16&p)};O.value=8;const Y={};let m=!0;for(;m;){const Z=c(V.buffer,O);if(Z){const p=c(V.buffer,O),r=w(V,O,p,F(V,O));void 0===r?d.b.Warn(`Unknown header attribute type ${p}'.`):Y[Z]=r}else m=!1}if(0!=(-5&p))throw new Error("Unsupported file format");return{version:Z,spec:r,...Y}}(p,r),m=await async function(V,O,Z,d){const p={size:0,viewer:O,array:new Uint8Array(O.buffer),offset:Z,width:V.dataWindow.xMax-V.dataWindow.xMin+1,height:V.dataWindow.yMax-V.dataWindow.yMin+1,channels:V.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(V.compression){case R.NO_COMPRESSION:p.lines=1,p.uncompress=L;break;case R.RLE_COMPRESSION:p.lines=1,p.uncompress=J;break;case R.ZIPS_COMPRESSION:p.lines=1,p.uncompress=N,await K.e.LoadScriptAsync(s.FFLATEUrl);break;case R.ZIP_COMPRESSION:p.lines=16,p.uncompress=N,await K.e.LoadScriptAsync(s.FFLATEUrl);break;case R.PIZ_COMPRESSION:p.lines=32,p.uncompress=f;break;case R.PXR24_COMPRESSION:p.lines=16,p.uncompress=P,await K.e.LoadScriptAsync(s.FFLATEUrl);break;default:throw new Error(R[V.compression]+" is unsupported")}p.scanlineBlockSize=p.lines;const r={};for(const R of V.channels)switch(R.name){case"Y":case"R":case"G":case"B":case"A":r[R.name]=!0,p.type=R.pixelType}let Y=!1;if(r.R&&r.G&&r.B)Y=!r.A,p.outputChannels=4,p.decodeChannels={R:0,G:1,B:2,A:3};else{if(!r.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");p.outputChannels=1,p.decodeChannels={Y:0}}if(1===p.type)switch(d){case q.Float:p.getter=z,p.inputSize=2;break;case q.HalfFloat:p.getter=b,p.inputSize=2}else{if(2!==p.type)throw new Error("Unsupported pixelType "+p.type+" for "+V.compression);switch(d){case q.Float:p.getter=S,p.inputSize=4;break;case q.HalfFloat:p.getter=G,p.inputSize=4}}p.blockCount=p.height/p.scanlineBlockSize;for(let R=0;R<p.blockCount;R++)H(O,Z);const m=p.width*p.height*p.outputChannels;switch(d){case q.Float:p.byteArray=new Float32Array(m),p.textureType=1,Y&&p.byteArray.fill(1,0,m);break;case q.HalfFloat:p.byteArray=new Uint16Array(m),p.textureType=2,Y&&p.byteArray.fill(15360,0,m);break;default:throw new Error("Unsupported type: "+d)}let a=0;for(const R of V.channels)void 0!==p.decodeChannels[R.name]&&(p.channelLineOffsets[R.name]=a*p.width),a+=2*R.pixelType;return p.bytesPerLine=p.width*a,p.outLineWidth=p.width*p.outputChannels,"INCREASING_Y"===V.lineOrder?p.scanOrder=V=>V:p.scanOrder=V=>p.height-1-V,4==p.outputChannels?(p.format=5,p.linearSpace=!0):(p.format=6,p.linearSpace=!1),p}(Y,p,r,s.DefaultOutputType);!function(V,O,Z,d){const p={value:0};for(let r=0;r<V.height/V.scanlineBlockSize;r++){const Y=W(Z,d)-O.dataWindow.yMin;V.size=F(Z,d),V.lines=Y+V.scanlineBlockSize>V.height?V.height-Y:V.scanlineBlockSize;const m=V.size<V.lines*V.bytesPerLine&&V.uncompress?V.uncompress(V):L(V);d.value+=V.size;for(let Z=0;Z<V.scanlineBlockSize;Z++){const d=r*V.scanlineBlockSize,Y=Z+V.scanOrder(d);if(Y>=V.height)continue;const a=Z*V.bytesPerLine,R=(V.height-1-Y)*V.outLineWidth;for(let Z=0;Z<V.channels;Z++){const d=O.channels[Z].name,r=V.channelLineOffsets[d],Y=V.decodeChannels[d];if(void 0!==Y){p.value=a+r;for(let O=0;O<V.width;O++){const Z=R+O*V.outputChannels+Y;V.byteArray&&(V.byteArray[Z]=V.getter(m,p))}}}}}}(m,Y,p,r);Z(Y.dataWindow.xMax-Y.dataWindow.xMin+1,Y.dataWindow.yMax-Y.dataWindow.yMin+1,O.generateMipMaps,!1,(()=>{const V=O.getEngine();O.format=Y.format,O.type=m.textureType,O.invertY=!1,O._gammaSpace=!Y.linearSpace,m.byteArray&&V._uploadDataToTextureDirectly(O,m.byteArray,0,0,void 0,!0)}))}}}}]);