"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{2284:(U,W,l)=>{function M(U){return Math.floor(U/8)}function t(U){return 1<<U%8}l.d(W,{OptimizeIndices:()=>p});class L{constructor(U){this.size=U,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(U){if(U>=this.size)throw new RangeError("Bit index out of range");const W=M(U),l=t(U);return 0!==(this._byteArray[W]&l)}set(U,W){if(U>=this.size)throw new RangeError("Bit index out of range");const l=M(U),L=t(U);W?this._byteArray[l]|=L:this._byteArray[l]&=~L}}function p(U){const W=[],l=U.length/3;for(let L=0;L<l;L++)W.push([U[3*L],U[3*L+1],U[3*L+2]]);const M=new Map;for(let L=0;L<W.length;L++){const U=W[L];for(const W of U){let U=M.get(W);U||M.set(W,U=[]),U.push(L)}}const t=new L(l),p=[],B=U=>{const l=[U];for(;l.length>0;){const U=l.pop();if(!t.get(U)){t.set(U,!0),p.push(W[U]);for(const L of W[U]){const U=M.get(L);if(!U)return;for(const W of U)t.get(W)||l.push(W)}}}};for(let L=0;L<l;L++)t.get(L)||B(L);let k=0;for(const L of p)U[k++]=L[0],U[k++]=L[1],U[k++]=L[2]}}}]);