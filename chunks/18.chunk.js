"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12720:(A,e,E)=>{E.r(e),E.d(e,{_ExrTextureLoader:()=>X});var Q=E(10729),x=E(11037);const t=65536,H=14,h=65537,Y=16384;var F,w;!function(A){A[A.NO_COMPRESSION=0]="NO_COMPRESSION",A[A.RLE_COMPRESSION=1]="RLE_COMPRESSION",A[A.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",A[A.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",A[A.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",A[A.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(F||(F={})),function(A){A[A.INCREASING_Y=0]="INCREASING_Y",A[A.DECREASING_Y=1]="DECREASING_Y"}(w||(w={}));const r=function(){const A=new ArrayBuffer(4),e=new Float32Array(A),E=new Uint32Array(A),Q=new Uint32Array(512),x=new Uint32Array(512);for(let Y=0;Y<256;++Y){const A=Y-127;A<-27?(Q[Y]=0,Q[256|Y]=32768,x[Y]=24,x[256|Y]=24):A<-14?(Q[Y]=1024>>-A-14,Q[256|Y]=1024>>-A-14|32768,x[Y]=-A-1,x[256|Y]=-A-1):A<=15?(Q[Y]=A+15<<10,Q[256|Y]=A+15<<10|32768,x[Y]=13,x[256|Y]=13):A<128?(Q[Y]=31744,Q[256|Y]=64512,x[Y]=24,x[256|Y]=24):(Q[Y]=31744,Q[256|Y]=64512,x[Y]=13,x[256|Y]=13)}const t=new Uint32Array(2048),H=new Uint32Array(64),h=new Uint32Array(64);for(let Y=1;Y<1024;++Y){let A=Y<<13,e=0;for(;0===(8388608&A);)A<<=1,e-=8388608;A&=-8388609,e+=947912704,t[Y]=A|e}for(let Y=1024;Y<2048;++Y)t[Y]=939524096+(Y-1024<<13);for(let Y=1;Y<31;++Y)H[Y]=Y<<23;H[31]=1199570944,H[32]=2147483648;for(let Y=33;Y<63;++Y)H[Y]=2147483648+(Y-32<<23);H[63]=3347054592;for(let Y=1;Y<64;++Y)32!==Y&&(h[Y]=1024);return{floatView:e,uint32View:E,baseTable:Q,shiftTable:x,mantissaTable:t,exponentTable:H,offsetTable:h}}();function S(A,e){const E=new Uint8Array(A);let Q=0;for(;0!=E[e.value+Q];)Q+=1;const x=(new TextDecoder).decode(E.slice(e.value,e.value+Q));return e.value=e.value+Q+1,x}function v(A,e){const E=A.getInt32(e.value,!0);return e.value+=4,E}function c(A,e){const E=A.getUint32(e.value,!0);return e.value+=4,E}function D(A,e){const E=A.getUint8(e.value);return e.value+=1,E}function a(A,e){const E=A.getUint16(e.value,!0);return e.value+=2,E}function z(A,e){const E=A[e.value];return e.value+=1,E}function I(A,e){let E;return E="getBigInt64"in DataView.prototype?Number(A.getBigInt64(e.value,!0)):A.getUint32(e.value+4,!0)+Number(A.getUint32(e.value,!0)<<32),e.value+=8,E}function J(A,e){const E=A.getFloat32(e.value,!0);return e.value+=4,E}function K(A,e){return function(A){const e=(31744&A)>>10,E=1023&A;return(A>>15?-1:1)*(e?31===e?E?NaN:1/0:Math.pow(2,e-15)*(1+E/1024):E/1024*6103515625e-14)}(a(A,e))}function P(A,e){return function(A){if(Math.abs(A)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");A=(0,x.b)(A,-65504,65504),r.floatView[0]=A;const e=r.uint32View[0],E=e>>23&511;return r.baseTable[E]+((8388607&e)>>r.shiftTable[E])}(J(A,e))}function T(A,e,E,Q){switch(E){case"string":case"stringvector":case"iccProfile":return function(A,e,E){const Q=(new TextDecoder).decode(new Uint8Array(A).slice(e.value,e.value+E));return e.value=e.value+E,Q}(A.buffer,e,Q);case"chlist":return function(A,e,E){const Q=e.value,x=[];for(;e.value<Q+E-1;){const E=S(A.buffer,e),Q=v(A,e),t=D(A,e);e.value+=3;const H=v(A,e),h=v(A,e);x.push({name:E,pixelType:Q,pLinear:t,xSampling:H,ySampling:h})}return e.value+=1,x}(A,e,Q);case"chromaticities":return function(A,e){return{redX:J(A,e),redY:J(A,e),greenX:J(A,e),greenY:J(A,e),blueX:J(A,e),blueY:J(A,e),whiteX:J(A,e),whiteY:J(A,e)}}(A,e);case"compression":return function(A,e){return D(A,e)}(A,e);case"box2i":return function(A,e){return{xMin:v(A,e),yMin:v(A,e),xMax:v(A,e),yMax:v(A,e)}}(A,e);case"lineOrder":return function(A,e){const E=D(A,e);return w[E]}(A,e);case"float":return J(A,e);case"v2f":return function(A,e){return[J(A,e),J(A,e)]}(A,e);case"v3f":return function(A,e){return[J(A,e),J(A,e),J(A,e)]}(A,e);case"int":return v(A,e);case"rational":return function(A,e){return[v(A,e),c(A,e)]}(A,e);case"timecode":return function(A,e){return[c(A,e),c(A,e)]}(A,e);case"preview":return e.value+=Q,"skipped";default:return void(e.value+=Q)}}function u(A){for(let e=1;e<A.length;e++){const E=A[e-1]+A[e]-128;A[e]=E}}function g(A,e){let E=0,Q=Math.floor((A.length+1)/2),x=0;const t=A.length-1;for(;!(x>t)&&(e[x++]=A[E++],!(x>t));)e[x++]=A[Q++]}function q(A,e,E,Q,x){for(;E<A;)e=e<<8|z(Q,x),E+=8;return{l:e>>(E-=A)&(1<<A)-1,c:e,lc:E}}function O(A,e,E,Q){return{c:A=A<<8|z(E,Q),lc:e+=8}}function j(A,e,E,Q,x,t,H,h,Y){if(A==e){if(Q<8){const A=O(E,Q,x,t);E=A.c,Q=A.lc}let A=E>>(Q-=8);if(A=new Uint8Array([A])[0],h.value+A>Y)return null;const e=H[h.value-1];for(;A-- >0;)H[h.value++]=e}else{if(!(h.value<Y))return null;H[h.value++]=A}return{c:E,lc:Q}}const Z=new Array(59);function n(A,e,E,Q,x,t){const H=e;let Y=0,F=0;for(;Q<=x;Q++){if(H.value-e.value>E)return;let h=q(6,Y,F,A,H);const w=h.l;if(Y=h.c,F=h.lc,t[Q]=w,63==w){if(H.value-e.value>E)throw new Error("Error in HufUnpackEncTable");h=q(8,Y,F,A,H);let w=h.l+6;if(Y=h.c,F=h.lc,Q+w>x+1)throw new Error("Error in HufUnpackEncTable");for(;w--;)t[Q++]=0;Q--}else if(w>=59){let A=w-59+2;if(Q+A>x+1)throw new Error("Error in HufUnpackEncTable");for(;A--;)t[Q++]=0;Q--}}!function(A){for(let E=0;E<=58;++E)Z[E]=0;for(let E=0;E<h;++E)Z[A[E]]+=1;let e=0;for(let E=58;E>0;--E){const A=e+Z[E]>>1;Z[E]=e,e=A}for(let E=0;E<h;++E){const e=A[E];e>0&&(A[E]=e|Z[e]++<<6)}}(t)}function o(A){return 63&A}function m(A){return A>>6}function N(A,e,E,Q,x,t){const F=E.value,w=c(e,E),r=c(e,E);E.value+=4;const S=c(e,E);if(E.value+=4,w<0||w>=h||r<0||r>=h)throw new Error("Wrong HUF_ENCSIZE");const v=new Array(h),D=new Array(Y);!function(A){for(let e=0;e<Y;e++)A[e]={},A[e].len=0,A[e].lit=0,A[e].p=null}(D);if(n(A,E,Q-(E.value-F),w,r,v),S>8*(Q-(E.value-F)))throw new Error("Wrong hufUncompress");!function(A,e,E,Q){for(;e<=E;e++){const E=m(A[e]),x=o(A[e]);if(E>>x)throw new Error("Invalid table entry");if(x>H){const A=Q[E>>x-H];if(A.len)throw new Error("Invalid table entry");if(A.lit++,A.p){const e=A.p;A.p=new Array(A.lit);for(let E=0;E<A.lit-1;++E)A.p[E]=e[E]}else A.p=new Array(1);A.p[A.lit-1]=e}else if(x){let A=0;for(let t=1<<H-x;t>0;t--){const t=Q[(E<<H-x)+A];if(t.len||t.p)throw new Error("Invalid table entry");t.len=x,t.lit=e,A++}}}}(v,w,r,D),function(A,e,E,Q,x,t,h,Y,F){let w=0,r=0;const S=h,v=Math.trunc(Q.value+(x+7)/8);for(;Q.value<v;){let x=O(w,r,E,Q);for(w=x.c,r=x.lc;r>=H;){const h=e[w>>r-H&16383];if(h.len){r-=h.len;const A=j(h.lit,t,w,r,E,Q,Y,F,S);A&&(w=A.c,r=A.lc)}else{if(!h.p)throw new Error("hufDecode issues");let e;for(e=0;e<h.lit;e++){const H=o(A[h.p[e]]);for(;r<H&&Q.value<v;)x=O(w,r,E,Q),w=x.c,r=x.lc;if(r>=H&&m(A[h.p[e]])==(w>>r-H&(1<<H)-1)){r-=H;const A=j(h.p[e],t,w,r,E,Q,Y,F,S);A&&(w=A.c,r=A.lc);break}}if(e==h.lit)throw new Error("HufDecode issues")}}}const c=8-x&7;for(w>>=c,r-=c;r>0;){const A=e[w<<H-r&16383];if(!A.len)throw new Error("HufDecode issues");{r-=A.len;const e=j(A.lit,t,w,r,E,Q,Y,F,S);e&&(w=e.c,r=e.lc)}}}(v,D,A,E,S,r,t,x,{value:0})}function R(A){return 65535&A}function l(A){const e=R(A);return e>32767?e-65536:e}function i(A,e){const E=l(A),Q=l(e),x=E+(1&Q)+(Q>>1);return{a:x,b:x-Q}}function G(A,e){const E=R(A),Q=R(e),x=E-(Q>>1)&65535;return{a:Q+x-32768&65535,b:x}}function L(A,e,E,Q,x,t,H){const h=H<16384,Y=E>x?x:E;let F,w,r=1;for(;r<=Y;)r<<=1;for(r>>=1,F=r,r>>=1;r>=1;){w=0;const H=w+t*(x-F),Y=t*r,S=t*F,v=Q*r,c=Q*F;let D,a,z,I;for(;w<=H;w+=S){let x=w;const t=w+Q*(E-F);for(;x<=t;x+=c){const E=x+v,Q=x+Y,t=Q+v;if(h){let H=i(A[x+e],A[Q+e]);D=H.a,z=H.b,H=i(A[E+e],A[t+e]),a=H.a,I=H.b,H=i(D,a),A[x+e]=H.a,A[E+e]=H.b,H=i(z,I),A[Q+e]=H.a,A[t+e]=H.b}else{let H=G(A[x+e],A[Q+e]);D=H.a,z=H.b,H=G(A[E+e],A[t+e]),a=H.a,I=H.b,H=G(D,a),A[x+e]=H.a,A[E+e]=H.b,H=G(z,I),A[Q+e]=H.a,A[t+e]=H.b}}if(E&r){const E=x+Y;let Q;Q=h?i(A[x+e],A[E+e]):G(A[x+e],A[E+e]),D=Q.a,A[E+e]=Q.b,A[x+e]=D}}if(x&r){let x=w;const t=w+Q*(E-F);for(;x<=t;x+=c){const E=x+v;let Q;Q=h?i(A[x+e],A[E+e]):G(A[x+e],A[E+e]),D=Q.a,A[E+e]=Q.b,A[x+e]=D}}F=r,r>>=1}return w}function k(A){return new DataView(A.array.buffer,A.offset.value,A.size)}function b(A){const e=A.viewer.buffer.slice(A.offset.value,A.offset.value+A.size),E=new Uint8Array(function(A){let e=A.byteLength;const E=new Array;let Q=0;const x=new DataView(A);for(;e>0;){const A=x.getInt8(Q++);if(A<0){const t=-A;e-=t+1;for(let A=0;A<t;A++)E.push(x.getUint8(Q++))}else{const t=A;e-=2;const H=x.getUint8(Q++);for(let A=0;A<t+1;A++)E.push(H)}}return E}(e)),Q=new Uint8Array(E.length);return u(E),g(E,Q),new DataView(Q.buffer)}function W(A){const e=A.array.slice(A.offset.value,A.offset.value+A.size),E=fflate.unzlibSync(e),Q=new Uint8Array(E.length);return u(E),g(E,Q),new DataView(Q.buffer)}function p(A){const e=A.array.slice(A.offset.value,A.offset.value+A.size),E=fflate.unzlibSync(e),Q=A.lines*A.channels*A.width,x=1==A.type?new Uint16Array(Q):new Uint32Array(Q);let t=0,H=0;const h=new Array(4);for(let Y=0;Y<A.lines;Y++)for(let e=0;e<A.channels;e++){let e=0;switch(A.type){case 1:h[0]=t,h[1]=h[0]+A.width,t=h[1]+A.width;for(let Q=0;Q<A.width;++Q){e+=E[h[0]++]<<8|E[h[1]++],x[H]=e,H++}break;case 2:h[0]=t,h[1]=h[0]+A.width,h[2]=h[1]+A.width,t=h[2]+A.width;for(let Q=0;Q<A.width;++Q){e+=E[h[0]++]<<24|E[h[1]++]<<16|E[h[2]++]<<8,x[H]=e,H++}}}return new DataView(x.buffer)}function U(A){const e=A.viewer,E={value:A.offset.value},Q=new Uint16Array(A.width*A.scanlineBlockSize*(A.channels*A.type)),x=new Uint8Array(8192);let H=0;const h=new Array(A.channels);for(let t=0;t<A.channels;t++)h[t]={},h[t].start=H,h[t].end=h[t].start,h[t].nx=A.width,h[t].ny=A.lines,h[t].size=A.type,H+=h[t].nx*h[t].ny*h[t].size;const Y=a(e,E),F=a(e,E);if(F>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(Y<=F)for(let t=0;t<F-Y+1;t++)x[t+Y]=D(e,E);const w=new Uint16Array(t),r=function(A,e){let E=0;for(let x=0;x<t;++x)(0==x||A[x>>3]&1<<(7&x))&&(e[E++]=x);const Q=E-1;for(;E<t;)e[E++]=0;return Q}(x,w),S=c(e,E);N(A.array,e,E,S,Q,H);for(let t=0;t<A.channels;++t){const A=h[t];for(let e=0;e<h[t].size;++e)L(Q,A.start+e,A.nx,A.size,A.ny,A.nx*A.size,r)}!function(A,e,E){for(let Q=0;Q<E;++Q)e[Q]=A[e[Q]]}(w,Q,H);let v=0;const z=new Uint8Array(Q.buffer.byteLength);for(let t=0;t<A.lines;t++)for(let e=0;e<A.channels;e++){const A=h[e],E=A.nx*A.size,x=new Uint8Array(Q.buffer,2*A.end,2*E);z.set(x,v),v+=2*E,A.end+=E}return new DataView(z.buffer)}var V,s=E(10715);!function(A){A[A.Float=0]="Float",A[A.HalfFloat=1]="HalfFloat"}(V||(V={}));class f{}f.DefaultOutputType=V.HalfFloat,f.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class X{constructor(){this.supportCascades=!1}loadCubeData(A,e,E,Q,x){throw".exr not supported in Cube."}async loadData(A,e,E){const x=new DataView(A.buffer),t={value:0},H=function(A,e){if(20000630!=A.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const E=A.getUint8(4),x=A.getUint8(5),t={singleTile:!!(2&x),longName:!!(4&x),deepFormat:!!(8&x),multiPart:!!(16&x)};e.value=8;const H={};let h=!0;for(;h;){const E=S(A.buffer,e);if(E){const x=S(A.buffer,e),t=T(A,e,x,c(A,e));void 0===t?Q.d.Warn(`Unknown header attribute type ${x}'.`):H[E]=t}else h=!1}if(0!=(-5&x))throw new Error("Unsupported file format");return{version:E,spec:t,...H}}(x,t),h=await async function(A,e,E,Q){const x={size:0,viewer:e,array:new Uint8Array(e.buffer),offset:E,width:A.dataWindow.xMax-A.dataWindow.xMin+1,height:A.dataWindow.yMax-A.dataWindow.yMin+1,channels:A.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(A.compression){case F.NO_COMPRESSION:x.lines=1,x.uncompress=k;break;case F.RLE_COMPRESSION:x.lines=1,x.uncompress=b;break;case F.ZIPS_COMPRESSION:x.lines=1,x.uncompress=W,await s.c.LoadScriptAsync(f.FFLATEUrl);break;case F.ZIP_COMPRESSION:x.lines=16,x.uncompress=W,await s.c.LoadScriptAsync(f.FFLATEUrl);break;case F.PIZ_COMPRESSION:x.lines=32,x.uncompress=U;break;case F.PXR24_COMPRESSION:x.lines=16,x.uncompress=p,await s.c.LoadScriptAsync(f.FFLATEUrl);break;default:throw new Error(F[A.compression]+" is unsupported")}x.scanlineBlockSize=x.lines;const t={};for(const F of A.channels)switch(F.name){case"Y":case"R":case"G":case"B":case"A":t[F.name]=!0,x.type=F.pixelType}let H=!1;if(t.R&&t.G&&t.B)H=!t.A,x.outputChannels=4,x.decodeChannels={R:0,G:1,B:2,A:3};else{if(!t.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");x.outputChannels=1,x.decodeChannels={Y:0}}if(1===x.type)switch(Q){case V.Float:x.getter=K,x.inputSize=2;break;case V.HalfFloat:x.getter=a,x.inputSize=2}else{if(2!==x.type)throw new Error("Unsupported pixelType "+x.type+" for "+A.compression);switch(Q){case V.Float:x.getter=J,x.inputSize=4;break;case V.HalfFloat:x.getter=P,x.inputSize=4}}x.blockCount=x.height/x.scanlineBlockSize;for(let F=0;F<x.blockCount;F++)I(e,E);const h=x.width*x.height*x.outputChannels;switch(Q){case V.Float:x.byteArray=new Float32Array(h),x.textureType=1,H&&x.byteArray.fill(1,0,h);break;case V.HalfFloat:x.byteArray=new Uint16Array(h),x.textureType=2,H&&x.byteArray.fill(15360,0,h);break;default:throw new Error("Unsupported type: "+Q)}let Y=0;for(const F of A.channels)void 0!==x.decodeChannels[F.name]&&(x.channelLineOffsets[F.name]=Y*x.width),Y+=2*F.pixelType;return x.bytesPerLine=x.width*Y,x.outLineWidth=x.width*x.outputChannels,"INCREASING_Y"===A.lineOrder?x.scanOrder=A=>A:x.scanOrder=A=>x.height-1-A,4==x.outputChannels?(x.format=5,x.linearSpace=!0):(x.format=6,x.linearSpace=!1),x}(H,x,t,f.DefaultOutputType);!function(A,e,E,Q){const x={value:0};for(let t=0;t<A.height/A.scanlineBlockSize;t++){const H=v(E,Q)-e.dataWindow.yMin;A.size=c(E,Q),A.lines=H+A.scanlineBlockSize>A.height?A.height-H:A.scanlineBlockSize;const h=A.size<A.lines*A.bytesPerLine&&A.uncompress?A.uncompress(A):k(A);Q.value+=A.size;for(let E=0;E<A.scanlineBlockSize;E++){const Q=t*A.scanlineBlockSize,H=E+A.scanOrder(Q);if(H>=A.height)continue;const Y=E*A.bytesPerLine,F=(A.height-1-H)*A.outLineWidth;for(let E=0;E<A.channels;E++){const Q=e.channels[E].name,t=A.channelLineOffsets[Q],H=A.decodeChannels[Q];if(void 0!==H){x.value=Y+t;for(let e=0;e<A.width;e++){const E=F+e*A.outputChannels+H;A.byteArray&&(A.byteArray[E]=A.getter(h,x))}}}}}}(h,H,x,t);E(H.dataWindow.xMax-H.dataWindow.xMin+1,H.dataWindow.yMax-H.dataWindow.yMin+1,e.generateMipMaps,!1,(()=>{const A=e.getEngine();e.format=H.format,e.type=h.textureType,e.invertY=!1,e._gammaSpace=!H.linearSpace,h.byteArray&&A._uploadDataToTextureDirectly(e,h.byteArray,0,0,void 0,!0)}))}}}}]);