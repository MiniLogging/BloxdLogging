"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12770:(R,q,L)=>{L.r(q),L.d(q,{_ExrTextureLoader:()=>s});var B=L(10767),N=L(11099);const h=65536,Z=14,z=65537,Y=16384;var F,C;!function(R){R[R.NO_COMPRESSION=0]="NO_COMPRESSION",R[R.RLE_COMPRESSION=1]="RLE_COMPRESSION",R[R.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",R[R.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",R[R.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",R[R.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(F||(F={})),function(R){R[R.INCREASING_Y=0]="INCREASING_Y",R[R.DECREASING_Y=1]="DECREASING_Y"}(C||(C={}));const e=function(){const R=new ArrayBuffer(4),q=new Float32Array(R),L=new Uint32Array(R),B=new Uint32Array(512),N=new Uint32Array(512);for(let Y=0;Y<256;++Y){const R=Y-127;R<-27?(B[Y]=0,B[256|Y]=32768,N[Y]=24,N[256|Y]=24):R<-14?(B[Y]=1024>>-R-14,B[256|Y]=1024>>-R-14|32768,N[Y]=-R-1,N[256|Y]=-R-1):R<=15?(B[Y]=R+15<<10,B[256|Y]=R+15<<10|32768,N[Y]=13,N[256|Y]=13):R<128?(B[Y]=31744,B[256|Y]=64512,N[Y]=24,N[256|Y]=24):(B[Y]=31744,B[256|Y]=64512,N[Y]=13,N[256|Y]=13)}const h=new Uint32Array(2048),Z=new Uint32Array(64),z=new Uint32Array(64);for(let Y=1;Y<1024;++Y){let R=Y<<13,q=0;for(;0===(8388608&R);)R<<=1,q-=8388608;R&=-8388609,q+=947912704,h[Y]=R|q}for(let Y=1024;Y<2048;++Y)h[Y]=939524096+(Y-1024<<13);for(let Y=1;Y<31;++Y)Z[Y]=Y<<23;Z[31]=1199570944,Z[32]=2147483648;for(let Y=33;Y<63;++Y)Z[Y]=2147483648+(Y-32<<23);Z[63]=3347054592;for(let Y=1;Y<64;++Y)32!==Y&&(z[Y]=1024);return{floatView:q,uint32View:L,baseTable:B,shiftTable:N,mantissaTable:h,exponentTable:Z,offsetTable:z}}();function y(R,q){const L=new Uint8Array(R);let B=0;for(;0!=L[q.value+B];)B+=1;const N=(new TextDecoder).decode(L.slice(q.value,q.value+B));return q.value=q.value+B+1,N}function U(R,q){const L=R.getInt32(q.value,!0);return q.value+=4,L}function n(R,q){const L=R.getUint32(q.value,!0);return q.value+=4,L}function r(R,q){const L=R.getUint8(q.value);return q.value+=1,L}function p(R,q){const L=R.getUint16(q.value,!0);return q.value+=2,L}function c(R,q){const L=R[q.value];return q.value+=1,L}function d(R,q){let L;return L="getBigInt64"in DataView.prototype?Number(R.getBigInt64(q.value,!0)):R.getUint32(q.value+4,!0)+Number(R.getUint32(q.value,!0)<<32),q.value+=8,L}function f(R,q){const L=R.getFloat32(q.value,!0);return q.value+=4,L}function v(R,q){return function(R){const q=(31744&R)>>10,L=1023&R;return(R>>15?-1:1)*(q?31===q?L?NaN:1/0:Math.pow(2,q-15)*(1+L/1024):L/1024*6103515625e-14)}(p(R,q))}function T(R,q){return function(R){if(Math.abs(R)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");R=(0,N.b)(R,-65504,65504),e.floatView[0]=R;const q=e.uint32View[0],L=q>>23&511;return e.baseTable[L]+((8388607&q)>>e.shiftTable[L])}(f(R,q))}function t(R,q,L,B){switch(L){case"string":case"stringvector":case"iccProfile":return function(R,q,L){const B=(new TextDecoder).decode(new Uint8Array(R).slice(q.value,q.value+L));return q.value=q.value+L,B}(R.buffer,q,B);case"chlist":return function(R,q,L){const B=q.value,N=[];for(;q.value<B+L-1;){const L=y(R.buffer,q),B=U(R,q),h=r(R,q);q.value+=3;const Z=U(R,q),z=U(R,q);N.push({name:L,pixelType:B,pLinear:h,xSampling:Z,ySampling:z})}return q.value+=1,N}(R,q,B);case"chromaticities":return function(R,q){return{redX:f(R,q),redY:f(R,q),greenX:f(R,q),greenY:f(R,q),blueX:f(R,q),blueY:f(R,q),whiteX:f(R,q),whiteY:f(R,q)}}(R,q);case"compression":return function(R,q){return r(R,q)}(R,q);case"box2i":return function(R,q){return{xMin:U(R,q),yMin:U(R,q),xMax:U(R,q),yMax:U(R,q)}}(R,q);case"lineOrder":return function(R,q){const L=r(R,q);return C[L]}(R,q);case"float":return f(R,q);case"v2f":return function(R,q){return[f(R,q),f(R,q)]}(R,q);case"v3f":return function(R,q){return[f(R,q),f(R,q),f(R,q)]}(R,q);case"int":return U(R,q);case"rational":return function(R,q){return[U(R,q),n(R,q)]}(R,q);case"timecode":return function(R,q){return[n(R,q),n(R,q)]}(R,q);case"preview":return q.value+=B,"skipped";default:return void(q.value+=B)}}function D(R){for(let q=1;q<R.length;q++){const L=R[q-1]+R[q]-128;R[q]=L}}function S(R,q){let L=0,B=Math.floor((R.length+1)/2),N=0;const h=R.length-1;for(;!(N>h)&&(q[N++]=R[L++],!(N>h));)q[N++]=R[B++]}function I(R,q,L,B,N){for(;L<R;)q=q<<8|c(B,N),L+=8;return{l:q>>(L-=R)&(1<<R)-1,c:q,lc:L}}function K(R,q,L,B){return{c:R=R<<8|c(L,B),lc:q+=8}}function m(R,q,L,B,N,h,Z,z,Y){if(R==q){if(B<8){const R=K(L,B,N,h);L=R.c,B=R.lc}let R=L>>(B-=8);if(R=new Uint8Array([R])[0],z.value+R>Y)return null;const q=Z[z.value-1];for(;R-- >0;)Z[z.value++]=q}else{if(!(z.value<Y))return null;Z[z.value++]=R}return{c:L,lc:B}}const o=new Array(59);function l(R,q,L,B,N,h){const Z=q;let Y=0,F=0;for(;B<=N;B++){if(Z.value-q.value>L)return;let z=I(6,Y,F,R,Z);const C=z.l;if(Y=z.c,F=z.lc,h[B]=C,63==C){if(Z.value-q.value>L)throw new Error("Error in HufUnpackEncTable");z=I(8,Y,F,R,Z);let C=z.l+6;if(Y=z.c,F=z.lc,B+C>N+1)throw new Error("Error in HufUnpackEncTable");for(;C--;)h[B++]=0;B--}else if(C>=59){let R=C-59+2;if(B+R>N+1)throw new Error("Error in HufUnpackEncTable");for(;R--;)h[B++]=0;B--}}!function(R){for(let L=0;L<=58;++L)o[L]=0;for(let L=0;L<z;++L)o[R[L]]+=1;let q=0;for(let L=58;L>0;--L){const R=q+o[L]>>1;o[L]=q,q=R}for(let L=0;L<z;++L){const q=R[L];q>0&&(R[L]=q|o[q]++<<6)}}(h)}function G(R){return 63&R}function W(R){return R>>6}function H(R,q,L,B,N,h){const F=L.value,C=n(q,L),e=n(q,L);L.value+=4;const y=n(q,L);if(L.value+=4,C<0||C>=z||e<0||e>=z)throw new Error("Wrong HUF_ENCSIZE");const U=new Array(z),r=new Array(Y);!function(R){for(let q=0;q<Y;q++)R[q]={},R[q].len=0,R[q].lit=0,R[q].p=null}(r);if(l(R,L,B-(L.value-F),C,e,U),y>8*(B-(L.value-F)))throw new Error("Wrong hufUncompress");!function(R,q,L,B){for(;q<=L;q++){const L=W(R[q]),N=G(R[q]);if(L>>N)throw new Error("Invalid table entry");if(N>Z){const R=B[L>>N-Z];if(R.len)throw new Error("Invalid table entry");if(R.lit++,R.p){const q=R.p;R.p=new Array(R.lit);for(let L=0;L<R.lit-1;++L)R.p[L]=q[L]}else R.p=new Array(1);R.p[R.lit-1]=q}else if(N){let R=0;for(let h=1<<Z-N;h>0;h--){const h=B[(L<<Z-N)+R];if(h.len||h.p)throw new Error("Invalid table entry");h.len=N,h.lit=q,R++}}}}(U,C,e,r),function(R,q,L,B,N,h,z,Y,F){let C=0,e=0;const y=z,U=Math.trunc(B.value+(N+7)/8);for(;B.value<U;){let N=K(C,e,L,B);for(C=N.c,e=N.lc;e>=Z;){const z=q[C>>e-Z&16383];if(z.len){e-=z.len;const R=m(z.lit,h,C,e,L,B,Y,F,y);R&&(C=R.c,e=R.lc)}else{if(!z.p)throw new Error("hufDecode issues");let q;for(q=0;q<z.lit;q++){const Z=G(R[z.p[q]]);for(;e<Z&&B.value<U;)N=K(C,e,L,B),C=N.c,e=N.lc;if(e>=Z&&W(R[z.p[q]])==(C>>e-Z&(1<<Z)-1)){e-=Z;const R=m(z.p[q],h,C,e,L,B,Y,F,y);R&&(C=R.c,e=R.lc);break}}if(q==z.lit)throw new Error("HufDecode issues")}}}const n=8-N&7;for(C>>=n,e-=n;e>0;){const R=q[C<<Z-e&16383];if(!R.len)throw new Error("HufDecode issues");{e-=R.len;const q=m(R.lit,h,C,e,L,B,Y,F,y);q&&(C=q.c,e=q.lc)}}}(U,r,R,L,y,e,h,N,{value:0})}function P(R){return 65535&R}function O(R){const q=P(R);return q>32767?q-65536:q}function E(R,q){const L=O(R),B=O(q),N=L+(1&B)+(B>>1);return{a:N,b:N-B}}function a(R,q){const L=P(R),B=P(q),N=L-(B>>1)&65535;return{a:B+N-32768&65535,b:N}}function g(R,q,L,B,N,h,Z){const z=Z<16384,Y=L>N?N:L;let F,C,e=1;for(;e<=Y;)e<<=1;for(e>>=1,F=e,e>>=1;e>=1;){C=0;const Z=C+h*(N-F),Y=h*e,y=h*F,U=B*e,n=B*F;let r,p,c,d;for(;C<=Z;C+=y){let N=C;const h=C+B*(L-F);for(;N<=h;N+=n){const L=N+U,B=N+Y,h=B+U;if(z){let Z=E(R[N+q],R[B+q]);r=Z.a,c=Z.b,Z=E(R[L+q],R[h+q]),p=Z.a,d=Z.b,Z=E(r,p),R[N+q]=Z.a,R[L+q]=Z.b,Z=E(c,d),R[B+q]=Z.a,R[h+q]=Z.b}else{let Z=a(R[N+q],R[B+q]);r=Z.a,c=Z.b,Z=a(R[L+q],R[h+q]),p=Z.a,d=Z.b,Z=a(r,p),R[N+q]=Z.a,R[L+q]=Z.b,Z=a(c,d),R[B+q]=Z.a,R[h+q]=Z.b}}if(L&e){const L=N+Y;let B;B=z?E(R[N+q],R[L+q]):a(R[N+q],R[L+q]),r=B.a,R[L+q]=B.b,R[N+q]=r}}if(N&e){let N=C;const h=C+B*(L-F);for(;N<=h;N+=n){const L=N+U;let B;B=z?E(R[N+q],R[L+q]):a(R[N+q],R[L+q]),r=B.a,R[L+q]=B.b,R[N+q]=r}}F=e,e>>=1}return C}function Q(R){return new DataView(R.array.buffer,R.offset.value,R.size)}function i(R){const q=R.viewer.buffer.slice(R.offset.value,R.offset.value+R.size),L=new Uint8Array(function(R){let q=R.byteLength;const L=new Array;let B=0;const N=new DataView(R);for(;q>0;){const R=N.getInt8(B++);if(R<0){const h=-R;q-=h+1;for(let R=0;R<h;R++)L.push(N.getUint8(B++))}else{const h=R;q-=2;const Z=N.getUint8(B++);for(let R=0;R<h+1;R++)L.push(Z)}}return L}(q)),B=new Uint8Array(L.length);return D(L),S(L,B),new DataView(B.buffer)}function k(R){const q=R.array.slice(R.offset.value,R.offset.value+R.size),L=fflate.unzlibSync(q),B=new Uint8Array(L.length);return D(L),S(L,B),new DataView(B.buffer)}function V(R){const q=R.array.slice(R.offset.value,R.offset.value+R.size),L=fflate.unzlibSync(q),B=R.lines*R.channels*R.width,N=1==R.type?new Uint16Array(B):new Uint32Array(B);let h=0,Z=0;const z=new Array(4);for(let Y=0;Y<R.lines;Y++)for(let q=0;q<R.channels;q++){let q=0;switch(R.type){case 1:z[0]=h,z[1]=z[0]+R.width,h=z[1]+R.width;for(let B=0;B<R.width;++B){q+=L[z[0]++]<<8|L[z[1]++],N[Z]=q,Z++}break;case 2:z[0]=h,z[1]=z[0]+R.width,z[2]=z[1]+R.width,h=z[2]+R.width;for(let B=0;B<R.width;++B){q+=L[z[0]++]<<24|L[z[1]++]<<16|L[z[2]++]<<8,N[Z]=q,Z++}}}return new DataView(N.buffer)}function x(R){const q=R.viewer,L={value:R.offset.value},B=new Uint16Array(R.width*R.scanlineBlockSize*(R.channels*R.type)),N=new Uint8Array(8192);let Z=0;const z=new Array(R.channels);for(let h=0;h<R.channels;h++)z[h]={},z[h].start=Z,z[h].end=z[h].start,z[h].nx=R.width,z[h].ny=R.lines,z[h].size=R.type,Z+=z[h].nx*z[h].ny*z[h].size;const Y=p(q,L),F=p(q,L);if(F>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(Y<=F)for(let h=0;h<F-Y+1;h++)N[h+Y]=r(q,L);const C=new Uint16Array(h),e=function(R,q){let L=0;for(let N=0;N<h;++N)(0==N||R[N>>3]&1<<(7&N))&&(q[L++]=N);const B=L-1;for(;L<h;)q[L++]=0;return B}(N,C),y=n(q,L);H(R.array,q,L,y,B,Z);for(let h=0;h<R.channels;++h){const R=z[h];for(let q=0;q<z[h].size;++q)g(B,R.start+q,R.nx,R.size,R.ny,R.nx*R.size,e)}!function(R,q,L){for(let B=0;B<L;++B)q[B]=R[q[B]]}(C,B,Z);let U=0;const c=new Uint8Array(B.buffer.byteLength);for(let h=0;h<R.lines;h++)for(let q=0;q<R.channels;q++){const R=z[q],L=R.nx*R.size,N=new Uint8Array(B.buffer,2*R.end,2*L);c.set(N,U),U+=2*L,R.end+=L}return new DataView(c.buffer)}var w,j=L(10757);!function(R){R[R.Float=0]="Float",R[R.HalfFloat=1]="HalfFloat"}(w||(w={}));class J{}J.DefaultOutputType=w.HalfFloat,J.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class s{constructor(){this.supportCascades=!1}loadCubeData(R,q,L,B,N){throw".exr not supported in Cube."}async loadData(R,q,L){const N=new DataView(R.buffer),h={value:0},Z=function(R,q){if(20000630!=R.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const L=R.getUint8(4),N=R.getUint8(5),h={singleTile:!!(2&N),longName:!!(4&N),deepFormat:!!(8&N),multiPart:!!(16&N)};q.value=8;const Z={};let z=!0;for(;z;){const L=y(R.buffer,q);if(L){const N=y(R.buffer,q),h=t(R,q,N,n(R,q));void 0===h?B.d.Warn(`Unknown header attribute type ${N}'.`):Z[L]=h}else z=!1}if(0!=(-5&N))throw new Error("Unsupported file format");return{version:L,spec:h,...Z}}(N,h),z=await async function(R,q,L,B){const N={size:0,viewer:q,array:new Uint8Array(q.buffer),offset:L,width:R.dataWindow.xMax-R.dataWindow.xMin+1,height:R.dataWindow.yMax-R.dataWindow.yMin+1,channels:R.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(R.compression){case F.NO_COMPRESSION:N.lines=1,N.uncompress=Q;break;case F.RLE_COMPRESSION:N.lines=1,N.uncompress=i;break;case F.ZIPS_COMPRESSION:N.lines=1,N.uncompress=k,await j.f.LoadScriptAsync(J.FFLATEUrl);break;case F.ZIP_COMPRESSION:N.lines=16,N.uncompress=k,await j.f.LoadScriptAsync(J.FFLATEUrl);break;case F.PIZ_COMPRESSION:N.lines=32,N.uncompress=x;break;case F.PXR24_COMPRESSION:N.lines=16,N.uncompress=V,await j.f.LoadScriptAsync(J.FFLATEUrl);break;default:throw new Error(F[R.compression]+" is unsupported")}N.scanlineBlockSize=N.lines;const h={};for(const F of R.channels)switch(F.name){case"Y":case"R":case"G":case"B":case"A":h[F.name]=!0,N.type=F.pixelType}let Z=!1;if(h.R&&h.G&&h.B)Z=!h.A,N.outputChannels=4,N.decodeChannels={R:0,G:1,B:2,A:3};else{if(!h.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");N.outputChannels=1,N.decodeChannels={Y:0}}if(1===N.type)switch(B){case w.Float:N.getter=v,N.inputSize=2;break;case w.HalfFloat:N.getter=p,N.inputSize=2}else{if(2!==N.type)throw new Error("Unsupported pixelType "+N.type+" for "+R.compression);switch(B){case w.Float:N.getter=f,N.inputSize=4;break;case w.HalfFloat:N.getter=T,N.inputSize=4}}N.blockCount=N.height/N.scanlineBlockSize;for(let F=0;F<N.blockCount;F++)d(q,L);const z=N.width*N.height*N.outputChannels;switch(B){case w.Float:N.byteArray=new Float32Array(z),N.textureType=1,Z&&N.byteArray.fill(1,0,z);break;case w.HalfFloat:N.byteArray=new Uint16Array(z),N.textureType=2,Z&&N.byteArray.fill(15360,0,z);break;default:throw new Error("Unsupported type: "+B)}let Y=0;for(const F of R.channels)void 0!==N.decodeChannels[F.name]&&(N.channelLineOffsets[F.name]=Y*N.width),Y+=2*F.pixelType;return N.bytesPerLine=N.width*Y,N.outLineWidth=N.width*N.outputChannels,"INCREASING_Y"===R.lineOrder?N.scanOrder=R=>R:N.scanOrder=R=>N.height-1-R,4==N.outputChannels?(N.format=5,N.linearSpace=!0):(N.format=6,N.linearSpace=!1),N}(Z,N,h,J.DefaultOutputType);!function(R,q,L,B){const N={value:0};for(let h=0;h<R.height/R.scanlineBlockSize;h++){const Z=U(L,B)-q.dataWindow.yMin;R.size=n(L,B),R.lines=Z+R.scanlineBlockSize>R.height?R.height-Z:R.scanlineBlockSize;const z=R.size<R.lines*R.bytesPerLine&&R.uncompress?R.uncompress(R):Q(R);B.value+=R.size;for(let L=0;L<R.scanlineBlockSize;L++){const B=h*R.scanlineBlockSize,Z=L+R.scanOrder(B);if(Z>=R.height)continue;const Y=L*R.bytesPerLine,F=(R.height-1-Z)*R.outLineWidth;for(let L=0;L<R.channels;L++){const B=q.channels[L].name,h=R.channelLineOffsets[B],Z=R.decodeChannels[B];if(void 0!==Z){N.value=Y+h;for(let q=0;q<R.width;q++){const L=F+q*R.outputChannels+Z;R.byteArray&&(R.byteArray[L]=R.getter(z,N))}}}}}}(z,Z,N,h);L(Z.dataWindow.xMax-Z.dataWindow.xMin+1,Z.dataWindow.yMax-Z.dataWindow.yMin+1,q.generateMipMaps,!1,(()=>{const R=q.getEngine();q.format=Z.format,q.type=z.textureType,q.invertY=!1,q._gammaSpace=!Z.linearSpace,z.byteArray&&R._uploadDataToTextureDirectly(q,z.byteArray,0,0,void 0,!0)}))}}}}]);