"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[18],{12789:(Z,J,E)=>{E.r(J),E.d(J,{_ExrTextureLoader:()=>q});var O=E(10913),i=E(11219);const Y=65536,C=14,d=65537,z=16384;var g,A;!function(Z){Z[Z.NO_COMPRESSION=0]="NO_COMPRESSION",Z[Z.RLE_COMPRESSION=1]="RLE_COMPRESSION",Z[Z.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Z[Z.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Z[Z.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Z[Z.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(g||(g={})),function(Z){Z[Z.INCREASING_Y=0]="INCREASING_Y",Z[Z.DECREASING_Y=1]="DECREASING_Y"}(A||(A={}));const R=function(){const Z=new ArrayBuffer(4),J=new Float32Array(Z),E=new Uint32Array(Z),O=new Uint32Array(512),i=new Uint32Array(512);for(let z=0;z<256;++z){const Z=z-127;Z<-27?(O[z]=0,O[256|z]=32768,i[z]=24,i[256|z]=24):Z<-14?(O[z]=1024>>-Z-14,O[256|z]=1024>>-Z-14|32768,i[z]=-Z-1,i[256|z]=-Z-1):Z<=15?(O[z]=Z+15<<10,O[256|z]=Z+15<<10|32768,i[z]=13,i[256|z]=13):Z<128?(O[z]=31744,O[256|z]=64512,i[z]=24,i[256|z]=24):(O[z]=31744,O[256|z]=64512,i[z]=13,i[256|z]=13)}const Y=new Uint32Array(2048),C=new Uint32Array(64),d=new Uint32Array(64);for(let z=1;z<1024;++z){let Z=z<<13,J=0;for(;0===(8388608&Z);)Z<<=1,J-=8388608;Z&=-8388609,J+=947912704,Y[z]=Z|J}for(let z=1024;z<2048;++z)Y[z]=939524096+(z-1024<<13);for(let z=1;z<31;++z)C[z]=z<<23;C[31]=1199570944,C[32]=2147483648;for(let z=33;z<63;++z)C[z]=2147483648+(z-32<<23);C[63]=3347054592;for(let z=1;z<64;++z)32!==z&&(d[z]=1024);return{floatView:J,uint32View:E,baseTable:O,shiftTable:i,mantissaTable:Y,exponentTable:C,offsetTable:d}}();function h(Z,J){const E=new Uint8Array(Z);let O=0;for(;0!=E[J.value+O];)O+=1;const i=(new TextDecoder).decode(E.slice(J.value,J.value+O));return J.value=J.value+O+1,i}function L(Z,J){const E=Z.getInt32(J.value,!0);return J.value+=4,E}function v(Z,J){const E=Z.getUint32(J.value,!0);return J.value+=4,E}function X(Z,J){const E=Z.getUint8(J.value);return J.value+=1,E}function l(Z,J){const E=Z.getUint16(J.value,!0);return J.value+=2,E}function K(Z,J){const E=Z[J.value];return J.value+=1,E}function T(Z,J){let E;return E="getBigInt64"in DataView.prototype?Number(Z.getBigInt64(J.value,!0)):Z.getUint32(J.value+4,!0)+Number(Z.getUint32(J.value,!0)<<32),J.value+=8,E}function W(Z,J){const E=Z.getFloat32(J.value,!0);return J.value+=4,E}function n(Z,J){return function(Z){const J=(31744&Z)>>10,E=1023&Z;return(Z>>15?-1:1)*(J?31===J?E?NaN:1/0:Math.pow(2,J-15)*(1+E/1024):E/1024*6103515625e-14)}(l(Z,J))}function B(Z,J){return function(Z){if(Math.abs(Z)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Z=(0,i.b)(Z,-65504,65504),R.floatView[0]=Z;const J=R.uint32View[0],E=J>>23&511;return R.baseTable[E]+((8388607&J)>>R.shiftTable[E])}(W(Z,J))}function N(Z,J,E,O){switch(E){case"string":case"stringvector":case"iccProfile":return function(Z,J,E){const O=(new TextDecoder).decode(new Uint8Array(Z).slice(J.value,J.value+E));return J.value=J.value+E,O}(Z.buffer,J,O);case"chlist":return function(Z,J,E){const O=J.value,i=[];for(;J.value<O+E-1;){const E=h(Z.buffer,J),O=L(Z,J),Y=X(Z,J);J.value+=3;const C=L(Z,J),d=L(Z,J);i.push({name:E,pixelType:O,pLinear:Y,xSampling:C,ySampling:d})}return J.value+=1,i}(Z,J,O);case"chromaticities":return function(Z,J){return{redX:W(Z,J),redY:W(Z,J),greenX:W(Z,J),greenY:W(Z,J),blueX:W(Z,J),blueY:W(Z,J),whiteX:W(Z,J),whiteY:W(Z,J)}}(Z,J);case"compression":return function(Z,J){return X(Z,J)}(Z,J);case"box2i":return function(Z,J){return{xMin:L(Z,J),yMin:L(Z,J),xMax:L(Z,J),yMax:L(Z,J)}}(Z,J);case"lineOrder":return function(Z,J){const E=X(Z,J);return A[E]}(Z,J);case"float":return W(Z,J);case"v2f":return function(Z,J){return[W(Z,J),W(Z,J)]}(Z,J);case"v3f":return function(Z,J){return[W(Z,J),W(Z,J),W(Z,J)]}(Z,J);case"int":return L(Z,J);case"rational":return function(Z,J){return[L(Z,J),v(Z,J)]}(Z,J);case"timecode":return function(Z,J){return[v(Z,J),v(Z,J)]}(Z,J);case"preview":return J.value+=O,"skipped";default:return void(J.value+=O)}}function e(Z){for(let J=1;J<Z.length;J++){const E=Z[J-1]+Z[J]-128;Z[J]=E}}function D(Z,J){let E=0,O=Math.floor((Z.length+1)/2),i=0;const Y=Z.length-1;for(;!(i>Y)&&(J[i++]=Z[E++],!(i>Y));)J[i++]=Z[O++]}function p(Z,J,E,O,i){for(;E<Z;)J=J<<8|K(O,i),E+=8;return{l:J>>(E-=Z)&(1<<Z)-1,c:J,lc:E}}function s(Z,J,E,O){return{c:Z=Z<<8|K(E,O),lc:J+=8}}function m(Z,J,E,O,i,Y,C,d,z){if(Z==J){if(O<8){const Z=s(E,O,i,Y);E=Z.c,O=Z.lc}let Z=E>>(O-=8);if(Z=new Uint8Array([Z])[0],d.value+Z>z)return null;const J=C[d.value-1];for(;Z-- >0;)C[d.value++]=J}else{if(!(d.value<z))return null;C[d.value++]=Z}return{c:E,lc:O}}const f=new Array(59);function V(Z,J,E,O,i,Y){const C=J;let z=0,g=0;for(;O<=i;O++){if(C.value-J.value>E)return;let d=p(6,z,g,Z,C);const A=d.l;if(z=d.c,g=d.lc,Y[O]=A,63==A){if(C.value-J.value>E)throw new Error("Error in HufUnpackEncTable");d=p(8,z,g,Z,C);let A=d.l+6;if(z=d.c,g=d.lc,O+A>i+1)throw new Error("Error in HufUnpackEncTable");for(;A--;)Y[O++]=0;O--}else if(A>=59){let Z=A-59+2;if(O+Z>i+1)throw new Error("Error in HufUnpackEncTable");for(;Z--;)Y[O++]=0;O--}}!function(Z){for(let E=0;E<=58;++E)f[E]=0;for(let E=0;E<d;++E)f[Z[E]]+=1;let J=0;for(let E=58;E>0;--E){const Z=J+f[E]>>1;f[E]=J,J=Z}for(let E=0;E<d;++E){const J=Z[E];J>0&&(Z[E]=J|f[J]++<<6)}}(Y)}function t(Z){return 63&Z}function U(Z){return Z>>6}function S(Z,J,E,O,i,Y){const g=E.value,A=v(J,E),R=v(J,E);E.value+=4;const h=v(J,E);if(E.value+=4,A<0||A>=d||R<0||R>=d)throw new Error("Wrong HUF_ENCSIZE");const L=new Array(d),X=new Array(z);!function(Z){for(let J=0;J<z;J++)Z[J]={},Z[J].len=0,Z[J].lit=0,Z[J].p=null}(X);if(V(Z,E,O-(E.value-g),A,R,L),h>8*(O-(E.value-g)))throw new Error("Wrong hufUncompress");!function(Z,J,E,O){for(;J<=E;J++){const E=U(Z[J]),i=t(Z[J]);if(E>>i)throw new Error("Invalid table entry");if(i>C){const Z=O[E>>i-C];if(Z.len)throw new Error("Invalid table entry");if(Z.lit++,Z.p){const J=Z.p;Z.p=new Array(Z.lit);for(let E=0;E<Z.lit-1;++E)Z.p[E]=J[E]}else Z.p=new Array(1);Z.p[Z.lit-1]=J}else if(i){let Z=0;for(let Y=1<<C-i;Y>0;Y--){const Y=O[(E<<C-i)+Z];if(Y.len||Y.p)throw new Error("Invalid table entry");Y.len=i,Y.lit=J,Z++}}}}(L,A,R,X),function(Z,J,E,O,i,Y,d,z,g){let A=0,R=0;const h=d,L=Math.trunc(O.value+(i+7)/8);for(;O.value<L;){let i=s(A,R,E,O);for(A=i.c,R=i.lc;R>=C;){const d=J[A>>R-C&16383];if(d.len){R-=d.len;const Z=m(d.lit,Y,A,R,E,O,z,g,h);Z&&(A=Z.c,R=Z.lc)}else{if(!d.p)throw new Error("hufDecode issues");let J;for(J=0;J<d.lit;J++){const C=t(Z[d.p[J]]);for(;R<C&&O.value<L;)i=s(A,R,E,O),A=i.c,R=i.lc;if(R>=C&&U(Z[d.p[J]])==(A>>R-C&(1<<C)-1)){R-=C;const Z=m(d.p[J],Y,A,R,E,O,z,g,h);Z&&(A=Z.c,R=Z.lc);break}}if(J==d.lit)throw new Error("HufDecode issues")}}}const v=8-i&7;for(A>>=v,R-=v;R>0;){const Z=J[A<<C-R&16383];if(!Z.len)throw new Error("HufDecode issues");{R-=Z.len;const J=m(Z.lit,Y,A,R,E,O,z,g,h);J&&(A=J.c,R=J.lc)}}}(L,X,Z,E,h,R,Y,i,{value:0})}function a(Z){return 65535&Z}function c(Z){const J=a(Z);return J>32767?J-65536:J}function r(Z,J){const E=c(Z),O=c(J),i=E+(1&O)+(O>>1);return{a:i,b:i-O}}function P(Z,J){const E=a(Z),O=a(J),i=E-(O>>1)&65535;return{a:O+i-32768&65535,b:i}}function k(Z,J,E,O,i,Y,C){const d=C<16384,z=E>i?i:E;let g,A,R=1;for(;R<=z;)R<<=1;for(R>>=1,g=R,R>>=1;R>=1;){A=0;const C=A+Y*(i-g),z=Y*R,h=Y*g,L=O*R,v=O*g;let X,l,K,T;for(;A<=C;A+=h){let i=A;const Y=A+O*(E-g);for(;i<=Y;i+=v){const E=i+L,O=i+z,Y=O+L;if(d){let C=r(Z[i+J],Z[O+J]);X=C.a,K=C.b,C=r(Z[E+J],Z[Y+J]),l=C.a,T=C.b,C=r(X,l),Z[i+J]=C.a,Z[E+J]=C.b,C=r(K,T),Z[O+J]=C.a,Z[Y+J]=C.b}else{let C=P(Z[i+J],Z[O+J]);X=C.a,K=C.b,C=P(Z[E+J],Z[Y+J]),l=C.a,T=C.b,C=P(X,l),Z[i+J]=C.a,Z[E+J]=C.b,C=P(K,T),Z[O+J]=C.a,Z[Y+J]=C.b}}if(E&R){const E=i+z;let O;O=d?r(Z[i+J],Z[E+J]):P(Z[i+J],Z[E+J]),X=O.a,Z[E+J]=O.b,Z[i+J]=X}}if(i&R){let i=A;const Y=A+O*(E-g);for(;i<=Y;i+=v){const E=i+L;let O;O=d?r(Z[i+J],Z[E+J]):P(Z[i+J],Z[E+J]),X=O.a,Z[E+J]=O.b,Z[i+J]=X}}g=R,R>>=1}return A}function y(Z){return new DataView(Z.array.buffer,Z.offset.value,Z.size)}function o(Z){const J=Z.viewer.buffer.slice(Z.offset.value,Z.offset.value+Z.size),E=new Uint8Array(function(Z){let J=Z.byteLength;const E=new Array;let O=0;const i=new DataView(Z);for(;J>0;){const Z=i.getInt8(O++);if(Z<0){const Y=-Z;J-=Y+1;for(let Z=0;Z<Y;Z++)E.push(i.getUint8(O++))}else{const Y=Z;J-=2;const C=i.getUint8(O++);for(let Z=0;Z<Y+1;Z++)E.push(C)}}return E}(J)),O=new Uint8Array(E.length);return e(E),D(E,O),new DataView(O.buffer)}function j(Z){const J=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),E=fflate.unzlibSync(J),O=new Uint8Array(E.length);return e(E),D(E,O),new DataView(O.buffer)}function w(Z){const J=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),E=fflate.unzlibSync(J),O=Z.lines*Z.channels*Z.width,i=1==Z.type?new Uint16Array(O):new Uint32Array(O);let Y=0,C=0;const d=new Array(4);for(let z=0;z<Z.lines;z++)for(let J=0;J<Z.channels;J++){let J=0;switch(Z.type){case 1:d[0]=Y,d[1]=d[0]+Z.width,Y=d[1]+Z.width;for(let O=0;O<Z.width;++O){J+=E[d[0]++]<<8|E[d[1]++],i[C]=J,C++}break;case 2:d[0]=Y,d[1]=d[0]+Z.width,d[2]=d[1]+Z.width,Y=d[2]+Z.width;for(let O=0;O<Z.width;++O){J+=E[d[0]++]<<24|E[d[1]++]<<16|E[d[2]++]<<8,i[C]=J,C++}}}return new DataView(i.buffer)}function M(Z){const J=Z.viewer,E={value:Z.offset.value},O=new Uint16Array(Z.width*Z.scanlineBlockSize*(Z.channels*Z.type)),i=new Uint8Array(8192);let C=0;const d=new Array(Z.channels);for(let Y=0;Y<Z.channels;Y++)d[Y]={},d[Y].start=C,d[Y].end=d[Y].start,d[Y].nx=Z.width,d[Y].ny=Z.lines,d[Y].size=Z.type,C+=d[Y].nx*d[Y].ny*d[Y].size;const z=l(J,E),g=l(J,E);if(g>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(z<=g)for(let Y=0;Y<g-z+1;Y++)i[Y+z]=X(J,E);const A=new Uint16Array(Y),R=function(Z,J){let E=0;for(let i=0;i<Y;++i)(0==i||Z[i>>3]&1<<(7&i))&&(J[E++]=i);const O=E-1;for(;E<Y;)J[E++]=0;return O}(i,A),h=v(J,E);S(Z.array,J,E,h,O,C);for(let Y=0;Y<Z.channels;++Y){const Z=d[Y];for(let J=0;J<d[Y].size;++J)k(O,Z.start+J,Z.nx,Z.size,Z.ny,Z.nx*Z.size,R)}!function(Z,J,E){for(let O=0;O<E;++O)J[O]=Z[J[O]]}(A,O,C);let L=0;const K=new Uint8Array(O.buffer.byteLength);for(let Y=0;Y<Z.lines;Y++)for(let J=0;J<Z.channels;J++){const Z=d[J],E=Z.nx*Z.size,i=new Uint8Array(O.buffer,2*Z.end,2*E);K.set(i,L),L+=2*E,Z.end+=E}return new DataView(K.buffer)}var H,F=E(10899);!function(Z){Z[Z.Float=0]="Float",Z[Z.HalfFloat=1]="HalfFloat"}(H||(H={}));class Q{}Q.DefaultOutputType=H.HalfFloat,Q.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class q{constructor(){this.supportCascades=!1}loadCubeData(Z,J,E,O,i){throw".exr not supported in Cube."}async loadData(Z,J,E){const i=new DataView(Z.buffer),Y={value:0},C=function(Z,J){if(20000630!=Z.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const E=Z.getUint8(4),i=Z.getUint8(5),Y={singleTile:!!(2&i),longName:!!(4&i),deepFormat:!!(8&i),multiPart:!!(16&i)};J.value=8;const C={};let d=!0;for(;d;){const E=h(Z.buffer,J);if(E){const i=h(Z.buffer,J),Y=N(Z,J,i,v(Z,J));void 0===Y?O.b.Warn(`Unknown header attribute type ${i}'.`):C[E]=Y}else d=!1}if(0!=(-5&i))throw new Error("Unsupported file format");return{version:E,spec:Y,...C}}(i,Y),d=await async function(Z,J,E,O){const i={size:0,viewer:J,array:new Uint8Array(J.buffer),offset:E,width:Z.dataWindow.xMax-Z.dataWindow.xMin+1,height:Z.dataWindow.yMax-Z.dataWindow.yMin+1,channels:Z.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Z.compression){case g.NO_COMPRESSION:i.lines=1,i.uncompress=y;break;case g.RLE_COMPRESSION:i.lines=1,i.uncompress=o;break;case g.ZIPS_COMPRESSION:i.lines=1,i.uncompress=j,await F.f.LoadScriptAsync(Q.FFLATEUrl);break;case g.ZIP_COMPRESSION:i.lines=16,i.uncompress=j,await F.f.LoadScriptAsync(Q.FFLATEUrl);break;case g.PIZ_COMPRESSION:i.lines=32,i.uncompress=M;break;case g.PXR24_COMPRESSION:i.lines=16,i.uncompress=w,await F.f.LoadScriptAsync(Q.FFLATEUrl);break;default:throw new Error(g[Z.compression]+" is unsupported")}i.scanlineBlockSize=i.lines;const Y={};for(const g of Z.channels)switch(g.name){case"Y":case"R":case"G":case"B":case"A":Y[g.name]=!0,i.type=g.pixelType}let C=!1;if(Y.R&&Y.G&&Y.B)C=!Y.A,i.outputChannels=4,i.decodeChannels={R:0,G:1,B:2,A:3};else{if(!Y.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");i.outputChannels=1,i.decodeChannels={Y:0}}if(1===i.type)switch(O){case H.Float:i.getter=n,i.inputSize=2;break;case H.HalfFloat:i.getter=l,i.inputSize=2}else{if(2!==i.type)throw new Error("Unsupported pixelType "+i.type+" for "+Z.compression);switch(O){case H.Float:i.getter=W,i.inputSize=4;break;case H.HalfFloat:i.getter=B,i.inputSize=4}}i.blockCount=i.height/i.scanlineBlockSize;for(let g=0;g<i.blockCount;g++)T(J,E);const d=i.width*i.height*i.outputChannels;switch(O){case H.Float:i.byteArray=new Float32Array(d),i.textureType=1,C&&i.byteArray.fill(1,0,d);break;case H.HalfFloat:i.byteArray=new Uint16Array(d),i.textureType=2,C&&i.byteArray.fill(15360,0,d);break;default:throw new Error("Unsupported type: "+O)}let z=0;for(const g of Z.channels)void 0!==i.decodeChannels[g.name]&&(i.channelLineOffsets[g.name]=z*i.width),z+=2*g.pixelType;return i.bytesPerLine=i.width*z,i.outLineWidth=i.width*i.outputChannels,"INCREASING_Y"===Z.lineOrder?i.scanOrder=Z=>Z:i.scanOrder=Z=>i.height-1-Z,4==i.outputChannels?(i.format=5,i.linearSpace=!0):(i.format=6,i.linearSpace=!1),i}(C,i,Y,Q.DefaultOutputType);!function(Z,J,E,O){const i={value:0};for(let Y=0;Y<Z.height/Z.scanlineBlockSize;Y++){const C=L(E,O)-J.dataWindow.yMin;Z.size=v(E,O),Z.lines=C+Z.scanlineBlockSize>Z.height?Z.height-C:Z.scanlineBlockSize;const d=Z.size<Z.lines*Z.bytesPerLine&&Z.uncompress?Z.uncompress(Z):y(Z);O.value+=Z.size;for(let E=0;E<Z.scanlineBlockSize;E++){const O=Y*Z.scanlineBlockSize,C=E+Z.scanOrder(O);if(C>=Z.height)continue;const z=E*Z.bytesPerLine,g=(Z.height-1-C)*Z.outLineWidth;for(let E=0;E<Z.channels;E++){const O=J.channels[E].name,Y=Z.channelLineOffsets[O],C=Z.decodeChannels[O];if(void 0!==C){i.value=z+Y;for(let J=0;J<Z.width;J++){const E=g+J*Z.outputChannels+C;Z.byteArray&&(Z.byteArray[E]=Z.getter(d,i))}}}}}}(d,C,i,Y);E(C.dataWindow.xMax-C.dataWindow.xMin+1,C.dataWindow.yMax-C.dataWindow.yMin+1,J.generateMipMaps,!1,(()=>{const Z=J.getEngine();J.format=C.format,J.type=d.textureType,J.invertY=!1,J._gammaSpace=!C.linearSpace,d.byteArray&&Z._uploadDataToTextureDirectly(J,d.byteArray,0,0,void 0,!0)}))}}}}]);