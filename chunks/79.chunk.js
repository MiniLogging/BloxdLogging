"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[79],{14419:(Z,x,F)=>{F.r(x),F.d(x,{FlowGraphPlayAnimationBlock:()=>j});var u=F(13005),G=F(12954),f=F(11136),Y=F(14412);class j extends u.b{constructor(Z){super(Z,["animationLoop","animationEnd","animationGroupLoop"]),this.config=Z,this.speed=this.registerDataInput("speed",G.u),this.loop=this.registerDataInput("loop",G.f),this.from=this.registerDataInput("from",G.u,0),this.to=this.registerDataInput("to",G.u),this.currentFrame=this.registerDataOutput("currentFrame",G.u),this.currentTime=this.registerDataOutput("currentTime",G.u),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",G.d),this.animationGroup=this.registerDataInput("animationGroup",G.d,null===Z||void 0===Z?void 0:Z.animationGroup),this.animation=this.registerDataInput("animation",G.d),this.object=this.registerDataInput("object",G.d)}_preparePendingTasks(Z){const x=this.animationGroup.getValue(Z),F=this.animation.getValue(Z);if(!x&&!F)return this._reportError(Z,"No animation or animation group provided");{const G=this.currentAnimationGroup.getValue(Z);G&&G!==x&&G.dispose();let f=x;if(F&&!f){const x=this.object.getValue(Z);if(!x)return this._reportError(Z,"No target object provided");const u=Array.isArray(F)?F:[F],G=u[0].name;f=new Y.AnimationGroup("flowGraphAnimationGroup-"+G+"-"+x.name,Z.configuration.mx);let j=!1;const d=Z._getGlobalContextVariable("interpolationAnimations",[]);for(const Z of u)f.addTargetedAnimation(Z,x),-1!==d.indexOf(Z.uniqueId)&&(j=!0);j&&this._checkInterpolationDuplications(Z,u,x)}const j=this.speed.getValue(Z)||1,d=this.from.getValue(Z)??0,t=this.to.getValue(Z)||f.to,o=!isFinite(t)||this.loop.getValue(Z);this.currentAnimationGroup.setValue(f,Z);const c=Z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==c.indexOf(f.uniqueId)&&f.stop();try{f.start(o,j,d,t),f.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(Z))),f.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(Z))),f.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(Z))),f.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(Z))),c.push(f.uniqueId),Z._setGlobalContextVariable("currentlyRunningAnimationGroups",c)}catch(u){this._reportError(Z,u)}}}_reportError(Z,x){super._reportError(Z,x),this.currentFrame.setValue(-1,Z),this.currentTime.setValue(-1,Z)}_executeOnTick(Z){const x=this.currentAnimationGroup.getValue(Z);var F;x&&(this.currentFrame.setValue(x.getCurrentFrame(),Z),this.currentTime.setValue((null===(F=x.animatables[0])||void 0===F?void 0:F.elapsedTime)??0,Z))}_execute(Z){this._startPendingTasks(Z)}_onAnimationGroupEnd(Z){this._removeFromCurrentlyRunning(Z,this.currentAnimationGroup.getValue(Z)),this._resetAfterCanceled(Z),this.done._activateSignal(Z)}_checkInterpolationDuplications(Z,x,F){const u=Z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const G of u){const u=Z.assetsContext.animationGroups.find((Z=>Z.uniqueId===G));if(u)for(const G of u.targetedAnimations)for(const f of x)G.animation.targetProperty===f.targetProperty&&G.target===F&&this._stopAnimationGroup(Z,u)}}_stopAnimationGroup(Z,x){x.stop(!0),x.dispose(),this._removeFromCurrentlyRunning(Z,x)}_removeFromCurrentlyRunning(Z,x){const F=Z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),u=F.indexOf(x.uniqueId);-1!==u&&(F.splice(u,1),Z._setGlobalContextVariable("currentlyRunningAnimationGroups",F))}_cancelPendingTasks(Z){const x=this.currentAnimationGroup.getValue(Z);x&&this._stopAnimationGroup(Z,x)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,f.g)("FlowGraphPlayAnimationBlock",j)}}]);