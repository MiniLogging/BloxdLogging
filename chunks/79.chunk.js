"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[79],{14451:(H,O,S)=>{S.r(O),S.d(O,{FlowGraphPlayAnimationBlock:()=>U});var t=S(13082),q=S(13035),p=S(11262),G=S(14443);class U extends t.d{constructor(H){super(H,["animationLoop","animationEnd","animationGroupLoop"]),this.config=H,this.speed=this.registerDataInput("speed",q.t),this.loop=this.registerDataInput("loop",q.i),this.from=this.registerDataInput("from",q.t,0),this.to=this.registerDataInput("to",q.t),this.currentFrame=this.registerDataOutput("currentFrame",q.t),this.currentTime=this.registerDataOutput("currentTime",q.t),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",q.e),this.animationGroup=this.registerDataInput("animationGroup",q.e,null===H||void 0===H?void 0:H.animationGroup),this.animation=this.registerDataInput("animation",q.e),this.object=this.registerDataInput("object",q.e)}_preparePendingTasks(H){const O=this.animationGroup.getValue(H),S=this.animation.getValue(H);if(!O&&!S)return this._reportError(H,"No animation or animation group provided");{const q=this.currentAnimationGroup.getValue(H);q&&q!==O&&q.dispose();let p=O;if(S&&!p){const O=this.object.getValue(H);if(!O)return this._reportError(H,"No target object provided");const t=Array.isArray(S)?S:[S],q=t[0].name;p=new G.AnimationGroup("flowGraphAnimationGroup-"+q+"-"+O.name,H.configuration.EO);let U=!1;const V=H._getGlobalContextVariable("interpolationAnimations",[]);for(const H of t)p.addTargetedAnimation(H,O),-1!==V.indexOf(H.uniqueId)&&(U=!0);U&&this._checkInterpolationDuplications(H,t,O)}const U=this.speed.getValue(H)||1,V=this.from.getValue(H)??0,w=this.to.getValue(H)||p.to,o=!isFinite(w)||this.loop.getValue(H);this.currentAnimationGroup.setValue(p,H);const h=H._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==h.indexOf(p.uniqueId)&&p.stop();try{p.start(o,U,V,w),p.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(H))),p.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(H))),p.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(H))),p.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(H))),h.push(p.uniqueId),H._setGlobalContextVariable("currentlyRunningAnimationGroups",h)}catch(t){this._reportError(H,t)}}}_reportError(H,O){super._reportError(H,O),this.currentFrame.setValue(-1,H),this.currentTime.setValue(-1,H)}_executeOnTick(H){const O=this.currentAnimationGroup.getValue(H);var S;O&&(this.currentFrame.setValue(O.getCurrentFrame(),H),this.currentTime.setValue((null===(S=O.animatables[0])||void 0===S?void 0:S.elapsedTime)??0,H))}_execute(H){this._startPendingTasks(H)}_onAnimationGroupEnd(H){this._removeFromCurrentlyRunning(H,this.currentAnimationGroup.getValue(H)),this._resetAfterCanceled(H),this.done._activateSignal(H)}_checkInterpolationDuplications(H,O,S){const t=H._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const q of t){const t=H.assetsContext.animationGroups.find((H=>H.uniqueId===q));if(t)for(const q of t.targetedAnimations)for(const p of O)q.animation.targetProperty===p.targetProperty&&q.target===S&&this._stopAnimationGroup(H,t)}}_stopAnimationGroup(H,O){O.stop(!0),O.dispose(),this._removeFromCurrentlyRunning(H,O)}_removeFromCurrentlyRunning(H,O){const S=H._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),t=S.indexOf(O.uniqueId);-1!==t&&(S.splice(t,1),H._setGlobalContextVariable("currentlyRunningAnimationGroups",S))}_cancelPendingTasks(H){const O=this.currentAnimationGroup.getValue(H);O&&this._stopAnimationGroup(H,O)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,p.g)("FlowGraphPlayAnimationBlock",U)}}]);