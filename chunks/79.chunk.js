"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[79],{14341:(B,I,C)=>{C.r(I),C.d(I,{FlowGraphPlayAnimationBlock:()=>L});var M=C(12950),x=C(12901),y=C(11149),f=C(14332);class L extends M.b{constructor(B){super(B,["animationLoop","animationEnd","animationGroupLoop"]),this.config=B,this.speed=this.registerDataInput("speed",x.m),this.loop=this.registerDataInput("loop",x.e),this.from=this.registerDataInput("from",x.m,0),this.to=this.registerDataInput("to",x.m),this.currentFrame=this.registerDataOutput("currentFrame",x.m),this.currentTime=this.registerDataOutput("currentTime",x.m),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",x.b),this.animationGroup=this.registerDataInput("animationGroup",x.b,null===B||void 0===B?void 0:B.animationGroup),this.animation=this.registerDataInput("animation",x.b),this.object=this.registerDataInput("object",x.b)}_preparePendingTasks(B){const I=this.animationGroup.getValue(B),C=this.animation.getValue(B);if(!I&&!C)return this._reportError(B,"No animation or animation group provided");{const x=this.currentAnimationGroup.getValue(B);x&&x!==I&&x.dispose();let y=I;if(C&&!y){const I=this.object.getValue(B);if(!I)return this._reportError(B,"No target object provided");const M=Array.isArray(C)?C:[C],x=M[0].name;y=new f.AnimationGroup("flowGraphAnimationGroup-"+x+"-"+I.name,B.configuration.kI);let L=!1;const e=B._getGlobalContextVariable("interpolationAnimations",[]);for(const B of M)y.addTargetedAnimation(B,I),-1!==e.indexOf(B.uniqueId)&&(L=!0);L&&this._checkInterpolationDuplications(B,M,I)}const L=this.speed.getValue(B)||1,e=this.from.getValue(B)??0,g=this.to.getValue(B)||y.to,N=!isFinite(g)||this.loop.getValue(B);this.currentAnimationGroup.setValue(y,B);const R=B._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==R.indexOf(y.uniqueId)&&y.stop();try{y.start(N,L,e,g),y.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(B))),y.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(B))),y.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(B))),y.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(B))),R.push(y.uniqueId),B._setGlobalContextVariable("currentlyRunningAnimationGroups",R)}catch(M){this._reportError(B,M)}}}_reportError(B,I){super._reportError(B,I),this.currentFrame.setValue(-1,B),this.currentTime.setValue(-1,B)}_executeOnTick(B){const I=this.currentAnimationGroup.getValue(B);var C;I&&(this.currentFrame.setValue(I.getCurrentFrame(),B),this.currentTime.setValue((null===(C=I.animatables[0])||void 0===C?void 0:C.elapsedTime)??0,B))}_execute(B){this._startPendingTasks(B)}_onAnimationGroupEnd(B){this._removeFromCurrentlyRunning(B,this.currentAnimationGroup.getValue(B)),this._resetAfterCanceled(B),this.done._activateSignal(B)}_checkInterpolationDuplications(B,I,C){const M=B._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const x of M){const M=B.assetsContext.animationGroups.find((B=>B.uniqueId===x));if(M)for(const x of M.targetedAnimations)for(const y of I)x.animation.targetProperty===y.targetProperty&&x.target===C&&this._stopAnimationGroup(B,M)}}_stopAnimationGroup(B,I){I.stop(!0),I.dispose(),this._removeFromCurrentlyRunning(B,I)}_removeFromCurrentlyRunning(B,I){const C=B._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),M=C.indexOf(I.uniqueId);-1!==M&&(C.splice(M,1),B._setGlobalContextVariable("currentlyRunningAnimationGroups",C))}_cancelPendingTasks(B){const I=this.currentAnimationGroup.getValue(B);I&&this._stopAnimationGroup(B,I)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,y.h)("FlowGraphPlayAnimationBlock",L)}}]);