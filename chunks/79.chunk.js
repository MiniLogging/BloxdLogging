"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[79],{14360:(k,h,o)=>{o.r(h),o.d(h,{FlowGraphPlayAnimationBlock:()=>J});var x=o(12983),I=o(12936),q=o(11199),Y=o(14354);class J extends x.e{constructor(k){super(k,["animationLoop","animationEnd","animationGroupLoop"]),this.config=k,this.speed=this.registerDataInput("speed",I.o),this.loop=this.registerDataInput("loop",I.h),this.from=this.registerDataInput("from",I.o,0),this.to=this.registerDataInput("to",I.o),this.currentFrame=this.registerDataOutput("currentFrame",I.o),this.currentTime=this.registerDataOutput("currentTime",I.o),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",I.d),this.animationGroup=this.registerDataInput("animationGroup",I.d,null===k||void 0===k?void 0:k.animationGroup),this.animation=this.registerDataInput("animation",I.d),this.object=this.registerDataInput("object",I.d)}_preparePendingTasks(k){const h=this.animationGroup.getValue(k),o=this.animation.getValue(k);if(!h&&!o)return this._reportError(k,"No animation or animation group provided");{const I=this.currentAnimationGroup.getValue(k);I&&I!==h&&I.dispose();let q=h;if(o&&!q){const h=this.object.getValue(k);if(!h)return this._reportError(k,"No target object provided");const x=Array.isArray(o)?o:[o],I=x[0].name;q=new Y.AnimationGroup("flowGraphAnimationGroup-"+I+"-"+h.name,k.configuration.Fh);let J=!1;const G=k._getGlobalContextVariable("interpolationAnimations",[]);for(const k of x)q.addTargetedAnimation(k,h),-1!==G.indexOf(k.uniqueId)&&(J=!0);J&&this._checkInterpolationDuplications(k,x,h)}const J=this.speed.getValue(k)||1,G=this.from.getValue(k)??0,l=this.to.getValue(k)||q.to,A=!isFinite(l)||this.loop.getValue(k);this.currentAnimationGroup.setValue(q,k);const K=k._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==K.indexOf(q.uniqueId)&&q.stop();try{q.start(A,J,G,l),q.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(k))),q.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(k))),q.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(k))),q.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(k))),K.push(q.uniqueId),k._setGlobalContextVariable("currentlyRunningAnimationGroups",K)}catch(x){this._reportError(k,x)}}}_reportError(k,h){super._reportError(k,h),this.currentFrame.setValue(-1,k),this.currentTime.setValue(-1,k)}_executeOnTick(k){const h=this.currentAnimationGroup.getValue(k);var o;h&&(this.currentFrame.setValue(h.getCurrentFrame(),k),this.currentTime.setValue((null===(o=h.animatables[0])||void 0===o?void 0:o.elapsedTime)??0,k))}_execute(k){this._startPendingTasks(k)}_onAnimationGroupEnd(k){this._removeFromCurrentlyRunning(k,this.currentAnimationGroup.getValue(k)),this._resetAfterCanceled(k),this.done._activateSignal(k)}_checkInterpolationDuplications(k,h,o){const x=k._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const I of x){const x=k.assetsContext.animationGroups.find((k=>k.uniqueId===I));if(x)for(const I of x.targetedAnimations)for(const q of h)I.animation.targetProperty===q.targetProperty&&I.target===o&&this._stopAnimationGroup(k,x)}}_stopAnimationGroup(k,h){h.stop(!0),h.dispose(),this._removeFromCurrentlyRunning(k,h)}_removeFromCurrentlyRunning(k,h){const o=k._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),x=o.indexOf(h.uniqueId);-1!==x&&(o.splice(x,1),k._setGlobalContextVariable("currentlyRunningAnimationGroups",o))}_cancelPendingTasks(k){const h=this.currentAnimationGroup.getValue(k);h&&this._stopAnimationGroup(k,h)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,q.g)("FlowGraphPlayAnimationBlock",J)}}]);