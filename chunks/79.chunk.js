"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[79],{13908:(A,X,s)=>{s.r(X),s.d(X,{FlowGraphMultiGateBlock:()=>K});var N=s(616),f=s(12696),E=s(12677),g=s(12672);class K extends f.c{constructor(A){super(A),this.config=A,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",E.f,new g.e(-1)),this.setNumberOfOutputSignals(null===A||void 0===A?void 0:A.outputSignalCount)}_getNextIndex(A){if(A.includes(!1)||this.config.isLoop&&A.fill(!1),this.config.isRandom){const X=A.map(((A,X)=>A?-1:X)).filter((A=>-1!==A));return X.length?X[Math.floor(Math.random()*X.length)]:-1}return A.indexOf(!1)}setNumberOfOutputSignals(){let A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>A;){const A=this.outputSignals.pop();A&&(A.disconnectFromAll(),this._unregisterSignalOutput(A.name))}for(;this.outputSignals.length<A;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(A,X){if(A._hasExecutionVariable(this,"indexesUsed")||A._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),X===this.reset)return A._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new g.e(-1),A);const s=A._getExecutionVariable(this,"indexesUsed",[]),N=this._getNextIndex(s);N>-1&&(this.lastIndex.setValue(new g.e(N),A),s[N]=!0,A._setExecutionVariable(this,"indexesUsed",s),this.outputSignals[N]._activateSignal(A))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(A){super.serialize(A),A.config.outputSignalCount=this.config.outputSignalCount,A.config.isRandom=this.config.isRandom,A.config.loop=this.config.isLoop,A.config.startIndex=this.config.startIndex}}(0,N.f)("FlowGraphMultiGateBlock",K)}}]);