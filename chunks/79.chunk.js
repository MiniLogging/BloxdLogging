"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[79],{15605:(U,G,C)=>{C.r(G),C.d(G,{FlowGraphPlayAnimationBlock:()=>E});var L=C(14180),X=C(14134),l=C(12850),t=C(15600);class E extends L.b{constructor(U){super(U,["animationLoop","animationEnd","animationGroupLoop"]),this.config=U,this.speed=this.registerDataInput("speed",X.y),this.loop=this.registerDataInput("loop",X.g),this.from=this.registerDataInput("from",X.y,0),this.to=this.registerDataInput("to",X.y),this.currentFrame=this.registerDataOutput("currentFrame",X.y),this.currentTime=this.registerDataOutput("currentTime",X.y),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",X.c),this.animationGroup=this.registerDataInput("animationGroup",X.c,null===U||void 0===U?void 0:U.animationGroup),this.animation=this.registerDataInput("animation",X.c),this.object=this.registerDataInput("object",X.c)}_preparePendingTasks(U){const G=this.animationGroup.getValue(U),C=this.animation.getValue(U);if(!G&&!C)return this._reportError(U,"No animation or animation group provided");{var L;const l=this.currentAnimationGroup.getValue(U);l&&l!==G&&l.dispose();let E=G;if(C&&!E){const G=this.object.getValue(U);if(!G)return this._reportError(U,"No target object provided");const L=Array.isArray(C)?C:[C],X=L[0].name;E=new t.AnimationGroup("flowGraphAnimationGroup-"+X+"-"+G.name,U.configuration.HG);let l=!1;const K=U._getGlobalContextVariable("interpolationAnimations",[]);for(const U of L)E.addTargetedAnimation(U,G),-1!==K.indexOf(U.uniqueId)&&(l=!0);l&&this._checkInterpolationDuplications(U,L,G)}const K=this.speed.getValue(U)||1,P=null!==(L=this.from.getValue(U))&&void 0!==L?L:0,O=this.to.getValue(U)||E.to,T=!isFinite(O)||this.loop.getValue(U);this.currentAnimationGroup.setValue(E,U);const D=U._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==D.indexOf(E.uniqueId)&&E.stop();try{E.start(T,K,P,O),E.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(U))),E.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(U))),E.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(U))),E.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(U))),D.push(E.uniqueId),U._setGlobalContextVariable("currentlyRunningAnimationGroups",D)}catch(X){this._reportError(U,X)}}}_reportError(U,G){super._reportError(U,G),this.currentFrame.setValue(-1,U),this.currentTime.setValue(-1,U)}_executeOnTick(U){const G=this.currentAnimationGroup.getValue(U);var C,L;G&&(this.currentFrame.setValue(G.getCurrentFrame(),U),this.currentTime.setValue(null!==(C=null===(L=G.animatables[0])||void 0===L?void 0:L.elapsedTime)&&void 0!==C?C:0,U))}_execute(U){this._startPendingTasks(U)}_onAnimationGroupEnd(U){this._removeFromCurrentlyRunning(U,this.currentAnimationGroup.getValue(U)),this._resetAfterCanceled(U),this.done._activateSignal(U)}_checkInterpolationDuplications(U,G,C){const L=U._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const X of L){const L=U.assetsContext.animationGroups.find((U=>U.uniqueId===X));if(L)for(const X of L.targetedAnimations)for(const l of G)X.animation.targetProperty===l.targetProperty&&X.target===C&&this._stopAnimationGroup(U,L)}}_stopAnimationGroup(U,G){G.stop(!0),G.dispose(),this._removeFromCurrentlyRunning(U,G)}_removeFromCurrentlyRunning(U,G){const C=U._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),L=C.indexOf(G.uniqueId);-1!==L&&(C.splice(L,1),U._setGlobalContextVariable("currentlyRunningAnimationGroups",C))}_cancelPendingTasks(U){const G=this.currentAnimationGroup.getValue(U);G&&this._stopAnimationGroup(U,G)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,l.e)("FlowGraphPlayAnimationBlock",E)}}]);