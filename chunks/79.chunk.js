"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[79],{16051:(Y,b,C)=>{C.r(b),C.d(b,{FlowGraphPlayAnimationBlock:()=>B});var R=C(14460),q=C(14424),A=C(12790),E=C(16046);class B extends R.d{constructor(Y){super(Y,["animationLoop","animationEnd","animationGroupLoop"]),this.config=Y,this.speed=this.registerDataInput("speed",q.q),this.loop=this.registerDataInput("loop",q.f),this.from=this.registerDataInput("from",q.q,0),this.to=this.registerDataInput("to",q.q),this.currentFrame=this.registerDataOutput("currentFrame",q.q),this.currentTime=this.registerDataOutput("currentTime",q.q),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",q.b),this.animationGroup=this.registerDataInput("animationGroup",q.b,null===Y||void 0===Y?void 0:Y.animationGroup),this.animation=this.registerDataInput("animation",q.b),this.object=this.registerDataInput("object",q.b)}_preparePendingTasks(Y){const b=this.animationGroup.getValue(Y),C=this.animation.getValue(Y);if(!b&&!C)return this._reportError(Y,"No animation or animation group provided");{const q=this.currentAnimationGroup.getValue(Y);q&&q!==b&&q.dispose();let A=b;if(C&&!A){const b=this.object.getValue(Y);if(!b)return this._reportError(Y,"No target object provided");const R=Array.isArray(C)?C:[C],q=R[0].name;A=new E.AnimationGroup("flowGraphAnimationGroup-"+q+"-"+b.name,Y.configuration.BC);let B=!1;const g=Y._getGlobalContextVariable("interpolationAnimations",[]);for(const Y of R)A.addTargetedAnimation(Y,b),-1!==g.indexOf(Y.uniqueId)&&(B=!0);B&&this._checkInterpolationDuplications(Y,R,b)}const B=this.speed.getValue(Y)||1,g=this.from.getValue(Y)??0,r=this.to.getValue(Y)||A.to,O=!isFinite(r)||this.loop.getValue(Y);this.currentAnimationGroup.setValue(A,Y);const F=Y._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==F.indexOf(A.uniqueId)&&A.stop();try{A.start(O,B,g,r),A.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(Y))),A.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(Y))),A.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(Y))),A.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(Y))),F.push(A.uniqueId),Y._setGlobalContextVariable("currentlyRunningAnimationGroups",F)}catch(R){this._reportError(Y,R)}}}_reportError(Y,b){super._reportError(Y,b),this.currentFrame.setValue(-1,Y),this.currentTime.setValue(-1,Y)}_executeOnTick(Y){const b=this.currentAnimationGroup.getValue(Y);var C;b&&(this.currentFrame.setValue(b.getCurrentFrame(),Y),this.currentTime.setValue((null===(C=b.animatables[0])||void 0===C?void 0:C.elapsedTime)??0,Y))}_execute(Y){this._startPendingTasks(Y)}_onAnimationGroupEnd(Y){this._removeFromCurrentlyRunning(Y,this.currentAnimationGroup.getValue(Y)),this._resetAfterCanceled(Y),this.done._activateSignal(Y)}_checkInterpolationDuplications(Y,b,C){const R=Y._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const q of R){const R=Y.assetsContext.animationGroups.find((Y=>Y.uniqueId===q));if(R)for(const q of R.targetedAnimations)for(const A of b)q.animation.targetProperty===A.targetProperty&&q.target===C&&this._stopAnimationGroup(Y,R)}}_stopAnimationGroup(Y,b){b.stop(!0),b.dispose(),this._removeFromCurrentlyRunning(Y,b)}_removeFromCurrentlyRunning(Y,b){const C=Y._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),R=C.indexOf(b.uniqueId);-1!==R&&(C.splice(R,1),Y._setGlobalContextVariable("currentlyRunningAnimationGroups",C))}_cancelPendingTasks(Y){const b=this.currentAnimationGroup.getValue(Y);b&&this._stopAnimationGroup(Y,b)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,A.g)("FlowGraphPlayAnimationBlock",B)}}]);