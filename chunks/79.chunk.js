"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[79],{14286:(q,S,b)=>{b.r(S),b.d(S,{FlowGraphPlayAnimationBlock:()=>g});var z=b(12864),C=b(12839),v=b(11058),U=b(14278);class g extends z.c{constructor(q){super(q,["animationLoop","animationEnd","animationGroupLoop"]),this.config=q,this.speed=this.registerDataInput("speed",C.o),this.loop=this.registerDataInput("loop",C.f),this.from=this.registerDataInput("from",C.o,0),this.to=this.registerDataInput("to",C.o),this.currentFrame=this.registerDataOutput("currentFrame",C.o),this.currentTime=this.registerDataOutput("currentTime",C.o),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",C.d),this.animationGroup=this.registerDataInput("animationGroup",C.d,null===q||void 0===q?void 0:q.animationGroup),this.animation=this.registerDataInput("animation",C.d),this.object=this.registerDataInput("object",C.d)}_preparePendingTasks(q){const S=this.animationGroup.getValue(q),b=this.animation.getValue(q);if(!S&&!b)return this._reportError(q,"No animation or animation group provided");{const C=this.currentAnimationGroup.getValue(q);C&&C!==S&&C.dispose();let v=S;if(b&&!v){const S=this.object.getValue(q);if(!S)return this._reportError(q,"No target object provided");const z=Array.isArray(b)?b:[b],C=z[0].name;v=new U.AnimationGroup("flowGraphAnimationGroup-"+C+"-"+S.name,q.configuration.GS);let g=!1;const r=q._getGlobalContextVariable("interpolationAnimations",[]);for(const q of z)v.addTargetedAnimation(q,S),-1!==r.indexOf(q.uniqueId)&&(g=!0);g&&this._checkInterpolationDuplications(q,z,S)}const g=this.speed.getValue(q)||1,r=this.from.getValue(q)??0,I=this.to.getValue(q)||v.to,V=!isFinite(I)||this.loop.getValue(q);this.currentAnimationGroup.setValue(v,q);const l=q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==l.indexOf(v.uniqueId)&&v.stop();try{v.start(V,g,r,I),v.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(q))),v.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(q))),v.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(q))),v.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(q))),l.push(v.uniqueId),q._setGlobalContextVariable("currentlyRunningAnimationGroups",l)}catch(z){this._reportError(q,z)}}}_reportError(q,S){super._reportError(q,S),this.currentFrame.setValue(-1,q),this.currentTime.setValue(-1,q)}_executeOnTick(q){const S=this.currentAnimationGroup.getValue(q);var b;S&&(this.currentFrame.setValue(S.getCurrentFrame(),q),this.currentTime.setValue((null===(b=S.animatables[0])||void 0===b?void 0:b.elapsedTime)??0,q))}_execute(q){this._startPendingTasks(q)}_onAnimationGroupEnd(q){this._removeFromCurrentlyRunning(q,this.currentAnimationGroup.getValue(q)),this._resetAfterCanceled(q),this.done._activateSignal(q)}_checkInterpolationDuplications(q,S,b){const z=q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const C of z){const z=q.assetsContext.animationGroups.find((q=>q.uniqueId===C));if(z)for(const C of z.targetedAnimations)for(const v of S)C.animation.targetProperty===v.targetProperty&&C.target===b&&this._stopAnimationGroup(q,z)}}_stopAnimationGroup(q,S){S.stop(!0),S.dispose(),this._removeFromCurrentlyRunning(q,S)}_removeFromCurrentlyRunning(q,S){const b=q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),z=b.indexOf(S.uniqueId);-1!==z&&(b.splice(z,1),q._setGlobalContextVariable("currentlyRunningAnimationGroups",b))}_cancelPendingTasks(q){const S=this.currentAnimationGroup.getValue(q);S&&this._stopAnimationGroup(q,S)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,v.f)("FlowGraphPlayAnimationBlock",g)}}]);