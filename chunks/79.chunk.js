"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[79],{15810:(L,U,x)=>{x.r(U),x.d(U,{FlowGraphPlayAnimationBlock:()=>a});var mL=x(14396),p=x(14348),G=x(12547),F=x(15804);class a extends mL.c{constructor(L){super(L,["animationLoop","animationEnd","animationGroupLoop"]),this.config=L,this.speed=this.registerDataInput("speed",p.u),this.loop=this.registerDataInput("loop",p.e),this.from=this.registerDataInput("from",p.u,0),this.to=this.registerDataInput("to",p.u),this.currentFrame=this.registerDataOutput("currentFrame",p.u),this.currentTime=this.registerDataOutput("currentTime",p.u),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",p.c),this.animationGroup=this.registerDataInput("animationGroup",p.c,null===L||void 0===L?void 0:L.animationGroup),this.animation=this.registerDataInput("animation",p.c),this.object=this.registerDataInput("object",p.c)}_preparePendingTasks(L){const U=this.animationGroup.getValue(L),x=this.animation.getValue(L);if(!U&&!x)return this._reportError(L,"No animation or animation group provided");{const p=this.currentAnimationGroup.getValue(L);p&&p!==U&&p.dispose();let G=U;if(x&&!G){const U=this.object.getValue(L);if(!U)return this._reportError(L,"No target object provided");const mL=Array.isArray(x)?x:[x],p=mL[0].name;G=new F.AnimationGroup("flowGraphAnimationGroup-"+p+"-"+U.name,L.configuration.VU);let a=!1;const o=L._getGlobalContextVariable("interpolationAnimations",[]);for(const L of mL)G.addTargetedAnimation(L,U),-1!==o.indexOf(L.uniqueId)&&(a=!0);a&&this._checkInterpolationDuplications(L,mL,U)}const a=this.speed.getValue(L)||1,o=this.from.getValue(L)??0,A=this.to.getValue(L)||G.to,r=!isFinite(A)||this.loop.getValue(L);this.currentAnimationGroup.setValue(G,L);const h=L._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==h.indexOf(G.uniqueId)&&G.stop();try{G.start(r,a,o,A),G.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(L))),G.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(L))),G.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(L))),G.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(L))),h.push(G.uniqueId),L._setGlobalContextVariable("currentlyRunningAnimationGroups",h)}catch(mL){this._reportError(L,mL)}}}_reportError(L,U){super._reportError(L,U),this.currentFrame.setValue(-1,L),this.currentTime.setValue(-1,L)}_executeOnTick(L){const U=this.currentAnimationGroup.getValue(L);var x;U&&(this.currentFrame.setValue(U.getCurrentFrame(),L),this.currentTime.setValue((null===(x=U.animatables[0])||void 0===x?void 0:x.elapsedTime)??0,L))}_execute(L){this._startPendingTasks(L)}_onAnimationGroupEnd(L){this._removeFromCurrentlyRunning(L,this.currentAnimationGroup.getValue(L)),this._resetAfterCanceled(L),this.done._activateSignal(L)}_checkInterpolationDuplications(L,U,x){const mL=L._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const p of mL){const mL=L.assetsContext.animationGroups.find((L=>L.uniqueId===p));if(mL)for(const p of mL.targetedAnimations)for(const G of U)p.animation.targetProperty===G.targetProperty&&p.target===x&&this._stopAnimationGroup(L,mL)}}_stopAnimationGroup(L,U){U.stop(!0),U.dispose(),this._removeFromCurrentlyRunning(L,U)}_removeFromCurrentlyRunning(L,U){const x=L._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),mL=x.indexOf(U.uniqueId);-1!==mL&&(x.splice(mL,1),L._setGlobalContextVariable("currentlyRunningAnimationGroups",x))}_cancelPendingTasks(L){const U=this.currentAnimationGroup.getValue(L);U&&this._stopAnimationGroup(L,U)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,G.d)("FlowGraphPlayAnimationBlock",a)}}]);