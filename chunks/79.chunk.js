"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[79],{14311:(h,V,i)=>{i.r(V),i.d(V,{FlowGraphPlayAnimationBlock:()=>q});var S=i(12855),l=i(12805),Y=i(11091),g=i(14304);class q extends S.e{constructor(h){super(h,["animationLoop","animationEnd","animationGroupLoop"]),this.config=h,this.speed=this.registerDataInput("speed",l.u),this.loop=this.registerDataInput("loop",l.f),this.from=this.registerDataInput("from",l.u,0),this.to=this.registerDataInput("to",l.u),this.currentFrame=this.registerDataOutput("currentFrame",l.u),this.currentTime=this.registerDataOutput("currentTime",l.u),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",l.c),this.animationGroup=this.registerDataInput("animationGroup",l.c,null===h||void 0===h?void 0:h.animationGroup),this.animation=this.registerDataInput("animation",l.c),this.object=this.registerDataInput("object",l.c)}_preparePendingTasks(h){const V=this.animationGroup.getValue(h),i=this.animation.getValue(h);if(!V&&!i)return this._reportError(h,"No animation or animation group provided");{const l=this.currentAnimationGroup.getValue(h);l&&l!==V&&l.dispose();let Y=V;if(i&&!Y){const V=this.object.getValue(h);if(!V)return this._reportError(h,"No target object provided");const S=Array.isArray(i)?i:[i],l=S[0].name;Y=new g.AnimationGroup("flowGraphAnimationGroup-"+l+"-"+V.name,h.configuration.fV);let q=!1;const B=h._getGlobalContextVariable("interpolationAnimations",[]);for(const h of S)Y.addTargetedAnimation(h,V),-1!==B.indexOf(h.uniqueId)&&(q=!0);q&&this._checkInterpolationDuplications(h,S,V)}const q=this.speed.getValue(h)||1,B=this.from.getValue(h)??0,J=this.to.getValue(h)||Y.to,I=!isFinite(J)||this.loop.getValue(h);this.currentAnimationGroup.setValue(Y,h);const v=h._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==v.indexOf(Y.uniqueId)&&Y.stop();try{Y.start(I,q,B,J),Y.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(h))),Y.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(h))),Y.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(h))),Y.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(h))),v.push(Y.uniqueId),h._setGlobalContextVariable("currentlyRunningAnimationGroups",v)}catch(S){this._reportError(h,S)}}}_reportError(h,V){super._reportError(h,V),this.currentFrame.setValue(-1,h),this.currentTime.setValue(-1,h)}_executeOnTick(h){const V=this.currentAnimationGroup.getValue(h);var i;V&&(this.currentFrame.setValue(V.getCurrentFrame(),h),this.currentTime.setValue((null===(i=V.animatables[0])||void 0===i?void 0:i.elapsedTime)??0,h))}_execute(h){this._startPendingTasks(h)}_onAnimationGroupEnd(h){this._removeFromCurrentlyRunning(h,this.currentAnimationGroup.getValue(h)),this._resetAfterCanceled(h),this.done._activateSignal(h)}_checkInterpolationDuplications(h,V,i){const S=h._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const l of S){const S=h.assetsContext.animationGroups.find((h=>h.uniqueId===l));if(S)for(const l of S.targetedAnimations)for(const Y of V)l.animation.targetProperty===Y.targetProperty&&l.target===i&&this._stopAnimationGroup(h,S)}}_stopAnimationGroup(h,V){V.stop(!0),V.dispose(),this._removeFromCurrentlyRunning(h,V)}_removeFromCurrentlyRunning(h,V){const i=h._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),S=i.indexOf(V.uniqueId);-1!==S&&(i.splice(S,1),h._setGlobalContextVariable("currentlyRunningAnimationGroups",i))}_cancelPendingTasks(h){const V=this.currentAnimationGroup.getValue(h);V&&this._stopAnimationGroup(h,V)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,Y.f)("FlowGraphPlayAnimationBlock",q)}}]);