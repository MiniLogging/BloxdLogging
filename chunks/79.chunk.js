"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[79],{14106:(P,Q,O)=>{O.r(Q),O.d(Q,{FlowGraphMultiGateBlock:()=>q});var b=O(696),F=O(12882),g=O(12871),m=O(12867);class q extends F.d{constructor(P){super(P),this.config=P,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",g.h,new m.c(-1)),this.setNumberOfOutputSignals(null===P||void 0===P?void 0:P.outputSignalCount)}_getNextIndex(P){if(P.includes(!1)||this.config.isLoop&&P.fill(!1),this.config.isRandom){const Q=P.map(((P,Q)=>P?-1:Q)).filter((P=>-1!==P));return Q.length?Q[Math.floor(Math.random()*Q.length)]:-1}return P.indexOf(!1)}setNumberOfOutputSignals(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>P;){const P=this.outputSignals.pop();P&&(P.disconnectFromAll(),this._unregisterSignalOutput(P.name))}for(;this.outputSignals.length<P;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(P,Q){if(P._hasExecutionVariable(this,"indexesUsed")||P._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),Q===this.reset)return P._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new m.c(-1),P);const O=P._getExecutionVariable(this,"indexesUsed",[]),b=this._getNextIndex(O);b>-1&&(this.lastIndex.setValue(new m.c(b),P),O[b]=!0,P._setExecutionVariable(this,"indexesUsed",O),this.outputSignals[b]._activateSignal(P))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(P){super.serialize(P),P.config.outputSignalCount=this.config.outputSignalCount,P.config.isRandom=this.config.isRandom,P.config.loop=this.config.isLoop,P.config.startIndex=this.config.startIndex}}(0,b.f)("FlowGraphMultiGateBlock",q)}}]);