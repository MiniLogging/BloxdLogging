"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[79],{14414:(o,H,n)=>{n.r(H),n.d(H,{FlowGraphPlayAnimationBlock:()=>Y});var E=n(12974),k=n(12933),g=n(11140),O=n(14406);class Y extends E.e{constructor(o){super(o,["animationLoop","animationEnd","animationGroupLoop"]),this.config=o,this.speed=this.registerDataInput("speed",k.r),this.loop=this.registerDataInput("loop",k.d),this.from=this.registerDataInput("from",k.r,0),this.to=this.registerDataInput("to",k.r),this.currentFrame=this.registerDataOutput("currentFrame",k.r),this.currentTime=this.registerDataOutput("currentTime",k.r),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",k.b),this.animationGroup=this.registerDataInput("animationGroup",k.b,null===o||void 0===o?void 0:o.animationGroup),this.animation=this.registerDataInput("animation",k.b),this.object=this.registerDataInput("object",k.b)}_preparePendingTasks(o){const H=this.animationGroup.getValue(o),n=this.animation.getValue(o);if(!H&&!n)return this._reportError(o,"No animation or animation group provided");{const k=this.currentAnimationGroup.getValue(o);k&&k!==H&&k.dispose();let g=H;if(n&&!g){const H=this.object.getValue(o);if(!H)return this._reportError(o,"No target object provided");const E=Array.isArray(n)?n:[n],k=E[0].name;g=new O.AnimationGroup("flowGraphAnimationGroup-"+k+"-"+H.name,o.configuration.VH);let Y=!1;const y=o._getGlobalContextVariable("interpolationAnimations",[]);for(const o of E)g.addTargetedAnimation(o,H),-1!==y.indexOf(o.uniqueId)&&(Y=!0);Y&&this._checkInterpolationDuplications(o,E,H)}const Y=this.speed.getValue(o)||1,y=this.from.getValue(o)??0,S=this.to.getValue(o)||g.to,G=!isFinite(S)||this.loop.getValue(o);this.currentAnimationGroup.setValue(g,o);const c=o._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==c.indexOf(g.uniqueId)&&g.stop();try{g.start(G,Y,y,S),g.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(o))),g.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(o))),g.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(o))),g.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(o))),c.push(g.uniqueId),o._setGlobalContextVariable("currentlyRunningAnimationGroups",c)}catch(E){this._reportError(o,E)}}}_reportError(o,H){super._reportError(o,H),this.currentFrame.setValue(-1,o),this.currentTime.setValue(-1,o)}_executeOnTick(o){const H=this.currentAnimationGroup.getValue(o);var n;H&&(this.currentFrame.setValue(H.getCurrentFrame(),o),this.currentTime.setValue((null===(n=H.animatables[0])||void 0===n?void 0:n.elapsedTime)??0,o))}_execute(o){this._startPendingTasks(o)}_onAnimationGroupEnd(o){this._removeFromCurrentlyRunning(o,this.currentAnimationGroup.getValue(o)),this._resetAfterCanceled(o),this.done._activateSignal(o)}_checkInterpolationDuplications(o,H,n){const E=o._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const k of E){const E=o.assetsContext.animationGroups.find((o=>o.uniqueId===k));if(E)for(const k of E.targetedAnimations)for(const g of H)k.animation.targetProperty===g.targetProperty&&k.target===n&&this._stopAnimationGroup(o,E)}}_stopAnimationGroup(o,H){H.stop(!0),H.dispose(),this._removeFromCurrentlyRunning(o,H)}_removeFromCurrentlyRunning(o,H){const n=o._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),E=n.indexOf(H.uniqueId);-1!==E&&(n.splice(E,1),o._setGlobalContextVariable("currentlyRunningAnimationGroups",n))}_cancelPendingTasks(o){const H=this.currentAnimationGroup.getValue(o);H&&this._stopAnimationGroup(o,H)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,g.e)("FlowGraphPlayAnimationBlock",Y)}}]);