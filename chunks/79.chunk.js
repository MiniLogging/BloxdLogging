"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[79],{14357:(P,f,Y)=>{Y.r(f),Y.d(f,{FlowGraphPlayAnimationBlock:()=>o});var C=Y(12970),q=Y(12917),m=Y(11134),L=Y(14348);class o extends C.c{constructor(P){super(P,["animationLoop","animationEnd","animationGroupLoop"]),this.config=P,this.speed=this.registerDataInput("speed",q.o),this.loop=this.registerDataInput("loop",q.e),this.from=this.registerDataInput("from",q.o,0),this.to=this.registerDataInput("to",q.o),this.currentFrame=this.registerDataOutput("currentFrame",q.o),this.currentTime=this.registerDataOutput("currentTime",q.o),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",q.d),this.animationGroup=this.registerDataInput("animationGroup",q.d,null===P||void 0===P?void 0:P.animationGroup),this.animation=this.registerDataInput("animation",q.d),this.object=this.registerDataInput("object",q.d)}_preparePendingTasks(P){const f=this.animationGroup.getValue(P),Y=this.animation.getValue(P);if(!f&&!Y)return this._reportError(P,"No animation or animation group provided");{const q=this.currentAnimationGroup.getValue(P);q&&q!==f&&q.dispose();let m=f;if(Y&&!m){const f=this.object.getValue(P);if(!f)return this._reportError(P,"No target object provided");const C=Array.isArray(Y)?Y:[Y],q=C[0].name;m=new L.AnimationGroup("flowGraphAnimationGroup-"+q+"-"+f.name,P.configuration.lf);let o=!1;const w=P._getGlobalContextVariable("interpolationAnimations",[]);for(const P of C)m.addTargetedAnimation(P,f),-1!==w.indexOf(P.uniqueId)&&(o=!0);o&&this._checkInterpolationDuplications(P,C,f)}const o=this.speed.getValue(P)||1,w=this.from.getValue(P)??0,d=this.to.getValue(P)||m.to,R=!isFinite(d)||this.loop.getValue(P);this.currentAnimationGroup.setValue(m,P);const y=P._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==y.indexOf(m.uniqueId)&&m.stop();try{m.start(R,o,w,d),m.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(P))),m.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(P))),m.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(P))),m.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(P))),y.push(m.uniqueId),P._setGlobalContextVariable("currentlyRunningAnimationGroups",y)}catch(C){this._reportError(P,C)}}}_reportError(P,f){super._reportError(P,f),this.currentFrame.setValue(-1,P),this.currentTime.setValue(-1,P)}_executeOnTick(P){const f=this.currentAnimationGroup.getValue(P);var Y;f&&(this.currentFrame.setValue(f.getCurrentFrame(),P),this.currentTime.setValue((null===(Y=f.animatables[0])||void 0===Y?void 0:Y.elapsedTime)??0,P))}_execute(P){this._startPendingTasks(P)}_onAnimationGroupEnd(P){this._removeFromCurrentlyRunning(P,this.currentAnimationGroup.getValue(P)),this._resetAfterCanceled(P),this.done._activateSignal(P)}_checkInterpolationDuplications(P,f,Y){const C=P._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const q of C){const C=P.assetsContext.animationGroups.find((P=>P.uniqueId===q));if(C)for(const q of C.targetedAnimations)for(const m of f)q.animation.targetProperty===m.targetProperty&&q.target===Y&&this._stopAnimationGroup(P,C)}}_stopAnimationGroup(P,f){f.stop(!0),f.dispose(),this._removeFromCurrentlyRunning(P,f)}_removeFromCurrentlyRunning(P,f){const Y=P._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),C=Y.indexOf(f.uniqueId);-1!==C&&(Y.splice(C,1),P._setGlobalContextVariable("currentlyRunningAnimationGroups",Y))}_cancelPendingTasks(P){const f=this.currentAnimationGroup.getValue(P);f&&this._stopAnimationGroup(P,f)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,m.d)("FlowGraphPlayAnimationBlock",o)}}]);