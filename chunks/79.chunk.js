"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[79],{13831:(W,F,c)=>{c.r(F),c.d(F,{FlowGraphMultiGateBlock:()=>A});var T=c(642),Y=c(12536),Z=c(12517),w=c(12512);class A extends Y.c{constructor(W){super(W),this.config=W,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",Z.f,new w.c(-1)),this.setNumberOfOutputSignals(null===W||void 0===W?void 0:W.outputSignalCount)}_getNextIndex(W){if(W.includes(!1)||this.config.isLoop&&W.fill(!1),this.config.isRandom){const F=W.map(((W,F)=>W?-1:F)).filter((W=>-1!==W));return F.length?F[Math.floor(Math.random()*F.length)]:-1}return W.indexOf(!1)}setNumberOfOutputSignals(){let W=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>W;){const W=this.outputSignals.pop();W&&(W.disconnectFromAll(),this._unregisterSignalOutput(W.name))}for(;this.outputSignals.length<W;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(W,F){if(W._hasExecutionVariable(this,"indexesUsed")||W._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),F===this.reset)return W._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new w.c(-1),W);const c=W._getExecutionVariable(this,"indexesUsed",[]),T=this._getNextIndex(c);T>-1&&(this.lastIndex.setValue(new w.c(T),W),c[T]=!0,W._setExecutionVariable(this,"indexesUsed",c),this.outputSignals[T]._activateSignal(W))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(W){super.serialize(W),W.config.outputSignalCount=this.config.outputSignalCount,W.config.isRandom=this.config.isRandom,W.config.loop=this.config.isLoop,W.config.startIndex=this.config.startIndex}}(0,T.h)("FlowGraphMultiGateBlock",A)}}]);