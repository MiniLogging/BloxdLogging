"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[79],{14110:(n,k,T)=>{T.r(k),T.d(k,{FlowGraphMultiGateBlock:()=>w});var c=T(675),K=T(12843),Q=T(12831),G=T(12829);class w extends K.d{constructor(n){super(n),this.config=n,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",Q.j,new G.d(-1)),this.setNumberOfOutputSignals(null===n||void 0===n?void 0:n.outputSignalCount)}_getNextIndex(n){if(n.includes(!1)||this.config.isLoop&&n.fill(!1),this.config.isRandom){const k=n.map(((n,k)=>n?-1:k)).filter((n=>-1!==n));return k.length?k[Math.floor(Math.random()*k.length)]:-1}return n.indexOf(!1)}setNumberOfOutputSignals(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>n;){const n=this.outputSignals.pop();n&&(n.disconnectFromAll(),this._unregisterSignalOutput(n.name))}for(;this.outputSignals.length<n;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(n,k){if(n._hasExecutionVariable(this,"indexesUsed")||n._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),k===this.reset)return n._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new G.d(-1),n);const T=n._getExecutionVariable(this,"indexesUsed",[]),c=this._getNextIndex(T);c>-1&&(this.lastIndex.setValue(new G.d(c),n),T[c]=!0,n._setExecutionVariable(this,"indexesUsed",T),this.outputSignals[c]._activateSignal(n))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(n){super.serialize(n),n.config.outputSignalCount=this.config.outputSignalCount,n.config.isRandom=this.config.isRandom,n.config.loop=this.config.isLoop,n.config.startIndex=this.config.startIndex}}(0,c.f)("FlowGraphMultiGateBlock",w)}}]);