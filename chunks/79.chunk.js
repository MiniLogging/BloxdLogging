"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[79],{14325:(R,J,B)=>{B.r(J),B.d(J,{FlowGraphPlayAnimationBlock:()=>r});var Q=B(12943),h=B(12894),y=B(11142),N=B(14316);class r extends Q.c{constructor(R){super(R,["animationLoop","animationEnd","animationGroupLoop"]),this.config=R,this.speed=this.registerDataInput("speed",h.t),this.loop=this.registerDataInput("loop",h.g),this.from=this.registerDataInput("from",h.t,0),this.to=this.registerDataInput("to",h.t),this.currentFrame=this.registerDataOutput("currentFrame",h.t),this.currentTime=this.registerDataOutput("currentTime",h.t),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",h.e),this.animationGroup=this.registerDataInput("animationGroup",h.e,null===R||void 0===R?void 0:R.animationGroup),this.animation=this.registerDataInput("animation",h.e),this.object=this.registerDataInput("object",h.e)}_preparePendingTasks(R){const J=this.animationGroup.getValue(R),B=this.animation.getValue(R);if(!J&&!B)return this._reportError(R,"No animation or animation group provided");{const h=this.currentAnimationGroup.getValue(R);h&&h!==J&&h.dispose();let y=J;if(B&&!y){const J=this.object.getValue(R);if(!J)return this._reportError(R,"No target object provided");const Q=Array.isArray(B)?B:[B],h=Q[0].name;y=new N.AnimationGroup("flowGraphAnimationGroup-"+h+"-"+J.name,R.configuration.AJ);let r=!1;const q=R._getGlobalContextVariable("interpolationAnimations",[]);for(const R of Q)y.addTargetedAnimation(R,J),-1!==q.indexOf(R.uniqueId)&&(r=!0);r&&this._checkInterpolationDuplications(R,Q,J)}const r=this.speed.getValue(R)||1,q=this.from.getValue(R)??0,e=this.to.getValue(R)||y.to,D=!isFinite(e)||this.loop.getValue(R);this.currentAnimationGroup.setValue(y,R);const l=R._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==l.indexOf(y.uniqueId)&&y.stop();try{y.start(D,r,q,e),y.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(R))),y.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(R))),y.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(R))),y.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(R))),l.push(y.uniqueId),R._setGlobalContextVariable("currentlyRunningAnimationGroups",l)}catch(Q){this._reportError(R,Q)}}}_reportError(R,J){super._reportError(R,J),this.currentFrame.setValue(-1,R),this.currentTime.setValue(-1,R)}_executeOnTick(R){const J=this.currentAnimationGroup.getValue(R);var B;J&&(this.currentFrame.setValue(J.getCurrentFrame(),R),this.currentTime.setValue((null===(B=J.animatables[0])||void 0===B?void 0:B.elapsedTime)??0,R))}_execute(R){this._startPendingTasks(R)}_onAnimationGroupEnd(R){this._removeFromCurrentlyRunning(R,this.currentAnimationGroup.getValue(R)),this._resetAfterCanceled(R),this.done._activateSignal(R)}_checkInterpolationDuplications(R,J,B){const Q=R._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const h of Q){const Q=R.assetsContext.animationGroups.find((R=>R.uniqueId===h));if(Q)for(const h of Q.targetedAnimations)for(const y of J)h.animation.targetProperty===y.targetProperty&&h.target===B&&this._stopAnimationGroup(R,Q)}}_stopAnimationGroup(R,J){J.stop(!0),J.dispose(),this._removeFromCurrentlyRunning(R,J)}_removeFromCurrentlyRunning(R,J){const B=R._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),Q=B.indexOf(J.uniqueId);-1!==Q&&(B.splice(Q,1),R._setGlobalContextVariable("currentlyRunningAnimationGroups",B))}_cancelPendingTasks(R){const J=this.currentAnimationGroup.getValue(R);J&&this._stopAnimationGroup(R,J)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,y.h)("FlowGraphPlayAnimationBlock",r)}}]);