"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[35],{13616:(Z,c,L)=>{function k(Z){return Math.floor(Z/8)}function N(Z){return 1<<Z%8}L.d(c,{OptimizeIndices:()=>G});class R{constructor(Z){this.size=Z,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(Z){if(Z>=this.size)throw new RangeError("Bit index out of range");const c=k(Z),L=N(Z);return 0!==(this._byteArray[c]&L)}set(Z,c){if(Z>=this.size)throw new RangeError("Bit index out of range");const L=k(Z),R=N(Z);c?this._byteArray[L]|=R:this._byteArray[L]&=~R}}function G(Z){const c=[],L=Z.length/3;for(let R=0;R<L;R++)c.push([Z[3*R],Z[3*R+1],Z[3*R+2]]);const k=new Map;for(let R=0;R<c.length;R++){const Z=c[R];for(const c of Z){let Z=k.get(c);Z||k.set(c,Z=[]),Z.push(R)}}const N=new R(L),G=[],V=Z=>{const L=[Z];for(;L.length>0;){const Z=L.pop();if(!N.get(Z)){N.set(Z,!0),G.push(c[Z]);for(const R of c[Z]){const Z=k.get(R);if(!Z)return;for(const c of Z)N.get(c)||L.push(c)}}}};for(let R=0;R<L;R++)N.get(R)||V(R);let p=0;for(const R of G)Z[p++]=R[0],Z[p++]=R[1],Z[p++]=R[2]}}}]);