"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[35],{13691:(V,I,m)=>{function C(V){return Math.floor(V/8)}function l(V){return 1<<V%8}m.d(I,{OptimizeIndices:()=>F});class s{constructor(V){this.size=V,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(V){if(V>=this.size)throw new RangeError("Bit index out of range");const I=C(V),m=l(V);return 0!==(this._byteArray[I]&m)}set(V,I){if(V>=this.size)throw new RangeError("Bit index out of range");const m=C(V),s=l(V);I?this._byteArray[m]|=s:this._byteArray[m]&=~s}}function F(V){const I=[],m=V.length/3;for(let s=0;s<m;s++)I.push([V[3*s],V[3*s+1],V[3*s+2]]);const C=new Map;for(let s=0;s<I.length;s++){const V=I[s];for(const I of V){let V=C.get(I);V||C.set(I,V=[]),V.push(s)}}const l=new s(m),F=[],k=V=>{const m=[V];for(;m.length>0;){const V=m.pop();if(!l.get(V)){l.set(V,!0),F.push(I[V]);for(const s of I[V]){const V=C.get(s);if(!V)return;for(const I of V)l.get(I)||m.push(I)}}}};for(let s=0;s<m;s++)l.get(s)||k(s);let j=0;for(const s of F)V[j++]=s[0],V[j++]=s[1],V[j++]=s[2]}}}]);