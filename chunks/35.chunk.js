"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[35],{13815:(G,V,W)=>{function J(G){return Math.floor(G/8)}function R(G){return 1<<G%8}W.d(V,{OptimizeIndices:()=>k});class d{constructor(G){this.size=G,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(G){if(G>=this.size)throw new RangeError("Bit index out of range");const V=J(G),W=R(G);return 0!==(this._byteArray[V]&W)}set(G,V){if(G>=this.size)throw new RangeError("Bit index out of range");const W=J(G),d=R(G);V?this._byteArray[W]|=d:this._byteArray[W]&=~d}}function k(G){const V=[],W=G.length/3;for(let d=0;d<W;d++)V.push([G[3*d],G[3*d+1],G[3*d+2]]);const J=new Map;for(let d=0;d<V.length;d++){const G=V[d];for(const V of G){let G=J.get(V);G||J.set(V,G=[]),G.push(d)}}const R=new d(W),k=[],z=G=>{const W=[G];for(;W.length>0;){const G=W.pop();if(!R.get(G)){R.set(G,!0),k.push(V[G]);for(const d of V[G]){const G=J.get(d);if(!G)return;for(const V of G)R.get(V)||W.push(V)}}}};for(let d=0;d<W;d++)R.get(d)||z(d);let X=0;for(const d of k)G[X++]=d[0],G[X++]=d[1],G[X++]=d[2]}}}]);