"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[35],{13250:(z,u,Y)=>{function H(z){return Math.floor(z/8)}function E(z){return 1<<z%8}Y.d(u,{OptimizeIndices:()=>l});class J{constructor(z){this.size=z,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(z){if(z>=this.size)throw new RangeError("Bit index out of range");const u=H(z),Y=E(z);return 0!==(this._byteArray[u]&Y)}set(z,u){if(z>=this.size)throw new RangeError("Bit index out of range");const Y=H(z),J=E(z);u?this._byteArray[Y]|=J:this._byteArray[Y]&=~J}}function l(z){const u=[],Y=z.length/3;for(let J=0;J<Y;J++)u.push([z[3*J],z[3*J+1],z[3*J+2]]);const H=new Map;for(let J=0;J<u.length;J++){const z=u[J];for(const u of z){let z=H.get(u);z||H.set(u,z=[]),z.push(J)}}const E=new J(Y),l=[],T=z=>{const Y=[z];for(;Y.length>0;){const z=Y.pop();if(!E.get(z)){E.set(z,!0),l.push(u[z]);for(const J of u[z]){const z=H.get(J);if(!z)return;for(const u of z)E.get(u)||Y.push(u)}}}};for(let J=0;J<Y;J++)E.get(J)||T(J);let b=0;for(const J of l)z[b++]=J[0],z[b++]=J[1],z[b++]=J[2]}}}]);