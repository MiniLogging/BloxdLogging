"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[58],{13920:(z,u,Y)=>{Y.r(u),Y.d(u,{AnimationGroup:()=>d,TargetedAnimation:()=>o});var H=Y(11619),E=Y(10932),J=Y(10928),l=Y(11181),T=Y(12451),b=Y(10903);class L{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(z,u,Y,E){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=u,this._target=z,this._scene=Y,this._host=E,this._activeTargets=[],u._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===H.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=b.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const z={frame:0,value:this._minValue};this._keys.splice(0,0,z)}if(this._target instanceof Array){let z=0;for(const u of this._target)this._preparePath(u,z),this._getOriginalValues(z),z++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const J=u.getEvents();if(J&&J.length>0)for(const H of J)this._events.push(H._clone());this._enableBlending=z&&z.animationPropertiesOverride?z.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Y=this._animation.targetPropertyPath;if(Y.length>1){let H=z;for(let z=0;z<Y.length-1;z++){const u=Y[z];if(H=H[u],void 0===H)throw new Error(`Invalid property (${u}) in property path (${Y.join(".")})`)}this._targetPath=Y[Y.length-1],this._activeTargets[u]=H}else this._targetPath=Y[0],this._activeTargets[u]=z;if(void 0===this._activeTargets[u][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${Y.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let z=0;for(const u of this._target)void 0!==this._originalValue[z]&&this._setValue(u,this._activeTargets[z],this._originalValue[z],-1,z),z++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let z=0;z<this._events.length;z++)this._events[z].isDone=!1}isStopped(){return this._stopped}dispose(){const z=this._animation.runtimeAnimations.indexOf(this);z>-1&&this._animation.runtimeAnimations.splice(z,1)}setValue(z,u){if(this._targetIsArray)for(let Y=0;Y<this._target.length;Y++){const H=this._target[Y];this._setValue(H,this._activeTargets[Y],z,u,Y)}else this._setValue(this._target,this._directTarget,z,u,0)}_getOriginalValues(){let z,u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Y=this._activeTargets[u];z=Y.getLocalMatrix&&"_matrix"===this._targetPath?Y.getLocalMatrix():Y[this._targetPath],z&&z.clone?this._originalValue[u]=z.clone():this._originalValue[u]=z}_registerTargetForLateAnimationBinding(z,u){const Y=z.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(Y),Y._lateAnimationHolders||(Y._lateAnimationHolders={}),Y._lateAnimationHolders[z.targetPath]||(Y._lateAnimationHolders[z.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:u}),z.isAdditive?(Y._lateAnimationHolders[z.targetPath].additiveAnimations.push(z),Y._lateAnimationHolders[z.targetPath].totalAdditiveWeight+=z.weight):(Y._lateAnimationHolders[z.targetPath].animations.push(z),Y._lateAnimationHolders[z.targetPath].totalWeight+=z.weight)}_setValue(z,u,Y,E,J){if(this._currentActiveTarget=u,this._weight=E,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const z=u[this._targetPath];z.clone?this._originalBlendValue=z.clone():this._originalBlendValue=z}this._originalBlendValue.m?H.e.AllowMatrixDecomposeForInterpolation?this._currentValue?b.b.DecomposeLerpToRef(this._originalBlendValue,Y,this._blendingFactor,this._currentValue):this._currentValue=b.b.DecomposeLerp(this._originalBlendValue,Y,this._blendingFactor):this._currentValue?b.b.LerpToRef(this._originalBlendValue,Y,this._blendingFactor,this._currentValue):this._currentValue=b.b.Lerp(this._originalBlendValue,Y,this._blendingFactor):this._currentValue=H.e._UniversalLerp(this._originalBlendValue,Y,this._blendingFactor);const E=z&&z.animationPropertiesOverride?z.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=E}else this._currentValue?this._currentValue.J?this._currentValue.J(Y):this._currentValue=Y:null!==Y&&void 0!==Y&&Y.clone?this._currentValue=Y.clone():this._currentValue=Y;-1!==E?this._registerTargetForLateAnimationBinding(this,this._originalValue[J]):this._animationState.loopMode===H.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[J],u[this._targetPath]):u[this._targetPath]=this._originalValue[J]+this._currentValue:u[this._targetPath]=this._currentValue,z.uD&&z.uD(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const Y=this._animation.getKeys();z<Y[0].frame?z=Y[0].frame:z>Y[Y.length-1].frame&&(z=Y[Y.length-1].frame);const H=this._events;if(H.length)for(let J=0;J<H.length;J++)H[J].onlyOnce||(H[J].isDone=H[J].frame<z);this._currentFrame=z;const E=this._animation._interpolate(z,this._animationState);this.setValue(E,u)}_prepareForSpeedRatioChange(z){const u=this._previousElapsedTime*(this._animation.framePerSecond*z)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-u}animate(z,u,Y,E,J){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const T=this._animation,b=T.targetPropertyPath;if(!b||b.length<1)return this._stopped=!0,!1;let L,D=!0;const g=this._events;let M=0;if(this._coreRuntimeAnimation)M=Y-u,L=this._coreRuntimeAnimation.currentFrame,this._currentFrame=L,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let l;(u<this._minFrame||u>this._maxFrame)&&(u=this._minFrame),(Y<this._minFrame||Y>this._maxFrame)&&(Y=this._maxFrame),M=Y-u;let b=z*(T.framePerSecond*J)/1e3+this._absoluteFrameOffset,q=0,C=!1;const K=E&&this._animationState.loopMode===H.e.ANIMATIONLOOPMODE_YOYO;if(K){const z=(b-u)/M,Y=Math.sin(z*Math.PI);b=Math.abs(Y)*M+u;const H=Y>=0?1:-1;this._yoyoDirection!==H&&(C=!0),this._yoyoDirection=H}if(this._previousElapsedTime=z,this._previousAbsoluteFrame=b,!E&&Y>=u&&(b>=M&&J>0||b<=0&&J<0))D=!1,q=T._getKeyValue(this._maxValue);else if(!E&&u>=Y&&(b<=M&&J<0||b>=0&&J>0))D=!1,q=T._getKeyValue(this._minValue);else if(this._animationState.loopMode!==H.e.ANIMATIONLOOPMODE_CYCLE){const z=Y.toString()+u.toString();if(!this._offsetsCache[z]){this._animationState.repeatCount=0,this._animationState.loopMode=H.e.ANIMATIONLOOPMODE_CYCLE;const E=T._interpolate(u,this._animationState),J=T._interpolate(Y,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),T.dataType){case H.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[z]=J-E;break;case H.e.ANIMATIONTYPE_QUATERNION:case H.e.ANIMATIONTYPE_VECTOR3:case H.e.ANIMATIONTYPE_VECTOR2:case H.e.ANIMATIONTYPE_SIZE:case H.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[z]=J.JY(E)}this._highLimitsCache[z]=J}q=this._highLimitsCache[z],l=this._offsetsCache[z]}if(void 0===l)switch(T.dataType){case H.e.ANIMATIONTYPE_FLOAT:l=0;break;case H.e.ANIMATIONTYPE_QUATERNION:l=H.o;break;case H.e.ANIMATIONTYPE_VECTOR3:l=H.w;break;case H.e.ANIMATIONTYPE_VECTOR2:l=H.s;break;case H.e.ANIMATIONTYPE_SIZE:l=H.q;break;case H.e.ANIMATIONTYPE_COLOR3:l=H.i;break;case H.e.ANIMATIONTYPE_COLOR4:l=H.l}if(this._host&&this._host.syncRoot){const z=this._host.syncRoot;L=u+M*((z.masterFrame-z.fromFrame)/(z.toFrame-z.fromFrame))}else L=b>0&&u>Y||b<0&&u<Y?D&&0!==M?Y+b%M:u:D&&0!==M?u+b%M:Y;if(!K&&(J>0&&this.currentFrame>L||J<0&&this.currentFrame<L)||K&&C){this._onLoop();for(let z=0;z<g.length;z++)g[z].onlyOnce||(g[z].isDone=!1);this._animationState.key=J>0?0:T.getKeys().length-1}this._currentFrame=L,this._animationState.repeatCount=0===M?0:b/M|0,this._animationState.highLimitValue=q,this._animationState.offsetValue=l}const q=T._interpolate(L,this._animationState);if(this.setValue(q,l),g.length)for(let H=0;H<g.length;H++)if(M>=0&&L>=g[H].frame&&g[H].frame>=u||M<0&&L<=g[H].frame&&g[H].frame<=u){const z=g[H];z.isDone||(z.onlyOnce&&(g.splice(H,1),H--),z.isDone=!0,z.action(L))}return D||(this._stopped=!0),D}}var D=Y(10962);class g{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(z){this._weight=-1!==z?Math.min(Math.max(z,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(z){for(let u=0;u<this._runtimeAnimations.length;u++){this._runtimeAnimations[u]._prepareForSpeedRatioChange(z)}this._speedRatio=z,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(z,u){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,J=arguments.length>4&&void 0!==arguments[4]&&arguments[4],l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,T=arguments.length>6?arguments[6]:void 0,b=arguments.length>7?arguments[7]:void 0,L=arguments.length>8?arguments[8]:void 0,D=arguments.length>9&&void 0!==arguments[9]&&arguments[9],g=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=u,this.fromFrame=Y,this.toFrame=H,this.loopAnimation=J,this.onAnimationEnd=T,this.onAnimationLoop=L,this.isAdditive=D,this.playOrder=g,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Gl=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new E.e,this.onAnimationLoopObservable=new E.e,this._scene=z,b&&this.appendAnimations(u,b),this._speedRatio=l,z._activeAnimatables.push(this)}syncWith(z){if(this._syncRoot=z,z){const z=this._scene._activeAnimatables.indexOf(this);z>-1&&(this._scene._activeAnimatables.splice(z,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(z,u){for(let Y=0;Y<u.length;Y++){const H=u[Y],E=new L(z,H,this._scene,this);E._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(E)}}getAnimationByTargetProperty(z){const u=this._runtimeAnimations;for(let Y=0;Y<u.length;Y++)if(u[Y].animation.targetProperty===z)return u[Y].animation;return null}getRuntimeAnimationByTargetProperty(z){const u=this._runtimeAnimations;for(let Y=0;Y<u.length;Y++)if(u[Y].animation.targetProperty===z)return u[Y];return null}reset(){const z=this._runtimeAnimations;for(let u=0;u<z.length;u++)z[u].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(z){const u=this._runtimeAnimations;for(let Y=0;Y<u.length;Y++)u[Y].animation.enableBlending=!0,u[Y].animation.blendingSpeed=z}disableBlending(){const z=this._runtimeAnimations;for(let u=0;u<z.length;u++)z[u].animation.enableBlending=!1}goToFrame(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Y=this._runtimeAnimations;if(Y[0]){const u=Y[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??Y[0].currentFrame;const H=0===this.speedRatio?0:(z-this._frameToSyncFromJump)/u*1e3/this.speedRatio;this._manualJumpDelay=-H}for(let H=0;H<Y.length;H++)Y[H].goToFrame(z,u?this._weight:-1);this._goToFrame=z}get paused(){return this.Gl}pause(){this.Gl||(this.Gl=!0)}restart(){this.Gl=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(z,u){let Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(z||u){const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){const J=this._runtimeAnimations;for(let Y=J.length-1;Y>=0;Y--){const H=J[Y];z&&H.animation.name!=z||(u&&!u(H.target)||(H.dispose(),J.splice(Y,1)))}0==J.length&&(Y||this._scene._activeAnimatables.splice(E,1),H||this._raiseOnAnimationEnd())}}else{const z=this._scene._activeAnimatables.indexOf(this);if(z>-1){Y||this._scene._activeAnimatables.splice(z,1);const u=this._runtimeAnimations;for(let z=0;z<u.length;z++)u[z].dispose();this._runtimeAnimations.length=0,H||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((z=>{this.onAnimationEndObservable.add((()=>{z(this)}),void 0,void 0,this,!0)}))}_animate(z){if(this.Gl)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=z),!0;if(null===this._localDelayOffset?(this._localDelayOffset=z,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=z-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let u=!1;const Y=this._runtimeAnimations;let H;for(H=0;H<Y.length;H++){const E=Y[H].animate(z-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);u=u||E}if(this.animationStarted=u,!u){if(this.disposeOnEnd)for(H=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(H,1),H=0;H<Y.length;H++)Y[H].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return u}}function M(z){if(0===z.totalWeight&&0===z.totalAdditiveWeight)return z.originalValue;let u=1;const Y=b.i.Pl[0],H=b.i.Pl[1],E=b.i.Quaternion[0];let J=0;const l=z.animations[0],T=z.originalValue;let L=1,D=!1;if(z.totalWeight<1)L=1-z.totalWeight,T.decompose(H,E,Y);else{if(J=1,u=z.totalWeight,L=l.weight/u,1==L){if(!z.totalAdditiveWeight)return l.currentValue;D=!0}l.currentValue.decompose(H,E,Y)}if(!D){H.scaleInPlace(L),Y.scaleInPlace(L),E.scaleInPlace(L);for(let l=J;l<z.animations.length;l++){const J=z.animations[l];if(0===J.weight)continue;L=J.weight/u;const T=b.i.Pl[2],D=b.i.Pl[3],g=b.i.Quaternion[1];J.currentValue.decompose(D,g,T),D.scaleAndAddToRef(L,H),g.scaleAndAddToRef(b.f.Dot(E,g)>0?L:-L,E),T.scaleAndAddToRef(L,Y)}E.normalize()}for(let M=0;M<z.additiveAnimations.length;M++){const u=z.additiveAnimations[M];if(0===u.weight)continue;const J=b.i.Pl[2],l=b.i.Pl[3],T=b.i.Quaternion[1];u.currentValue.decompose(l,T,J),l.multiplyToRef(H,l),b.p.LerpToRef(H,l,u.weight,H),E.multiplyToRef(T,T),b.f.SlerpToRef(E,T,u.weight,E),J.scaleAndAddToRef(u.weight,Y)}const g=l?l._animationState.workValue:b.i.Matrix[0].clone();return b.b.ComposeToRef(H,E,Y,g),g}function q(z,u){if(0===z.totalWeight&&0===z.totalAdditiveWeight)return u;const Y=z.animations[0],H=z.originalValue;let E=u;if(0===z.totalWeight&&z.totalAdditiveWeight>0)E.J(H);else if(1===z.animations.length){if(b.f.SlerpToRef(H,Y.currentValue,Math.min(1,z.totalWeight),E),0===z.totalAdditiveWeight)return E}else if(z.animations.length>1){let Y,J,l=1;if(z.totalWeight<1){const u=1-z.totalWeight;Y=[],J=[],Y.push(H),J.push(u)}else{if(2===z.animations.length&&(b.f.SlerpToRef(z.animations[0].currentValue,z.animations[1].currentValue,z.animations[1].weight/z.totalWeight,u),0===z.totalAdditiveWeight))return u;Y=[],J=[],l=z.totalWeight}for(let u=0;u<z.animations.length;u++){const H=z.animations[u];Y.push(H.currentValue),J.push(H.weight/l)}let T=0;for(let z=0;z<Y.length;)z?(T+=J[z],b.f.SlerpToRef(E,Y[z],J[z]/T,E),z++):(b.f.SlerpToRef(Y[z],Y[z+1],J[z+1]/(J[z]+J[z+1]),u),E=u,T=J[z]+J[z+1],z+=2)}for(let J=0;J<z.additiveAnimations.length;J++){const u=z.additiveAnimations[J];0!==u.weight&&(E.multiplyToRef(u.currentValue,b.i.Quaternion[0]),b.f.SlerpToRef(E,b.i.Quaternion[0],u.weight,E))}return E}var C,K,h=Y(11504);C=h.d,(K=T.d)&&(K.prototype.copyAnimationRange=function(z,u,Y){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],J=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new H.e(this.name,"_matrix",z.animations[0].framePerSecond,H.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const l=z.animations[0].getRange(u);if(!l)return!1;const T=l.from,b=l.to,L=z.animations[0].getKeys(),D=z.length,g=z.getParent(),M=this.getParent(),q=E&&g&&D&&this.length&&D!==this.length,C=q&&M&&g?M.length/g.length:1,K=E&&!M&&J&&(1!==J.x||1!==J.y||1!==J.z),h=this.animations[0].getKeys();let o,d,t;for(let H=0,W=L.length;H<W;H++)o=L[H],o.frame>=T&&o.frame<=b&&(E?(t=o.value.clone(),q?(d=t.getTranslation(),t.setTranslation(d.scaleInPlace(C))):K&&J?(d=t.getTranslation(),t.setTranslation(d.multiplyInPlace(J))):t=o.value):t=o.value,h.push({frame:o.frame+Y,value:t}));return this.animations[0].createRange(u,T+Y,b+Y),!0}),C&&(C.prototype._animate=function(z){if(!this.animationsEnabled)return;const u=D.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=u}this.deltaTime=void 0!==z?z:this.useConstantAnimationDeltaTime?16:(u-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=u;const Y=this._activeAnimatables;if(0===Y.length)return;this._animationTime+=this.deltaTime;const E=this._animationTime;for(let H=0;H<Y.length;H++){const z=Y[H];!z._animate(E)&&z.disposeOnEnd&&H--}!function(z){if(z._registeredForLateAnimationBindings.length){for(let u=0;u<z._registeredForLateAnimationBindings.length;u++){const Y=z._registeredForLateAnimationBindings.data[u];for(const z in Y._lateAnimationHolders){const u=Y._lateAnimationHolders[z],E=u.animations[0],J=u.originalValue;if(void 0===J||null===J)continue;const l=H.e.AllowMatrixDecomposeForInterpolation&&J.m;let T=Y[z];if(l)T=M(u);else if(void 0!==J.w)T=q(u,T||b.f.Identity());else{let z=0,Y=1;const l=E&&E._animationState.loopMode===H.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(u.totalWeight<1)T=l?J.clone?J.clone():J:E&&J.scale?J.scale(1-u.totalWeight):E?J*(1-u.totalWeight):J.clone?J.clone():J;else if(E){Y=u.totalWeight;const H=E.weight/Y;T=1!==H?E.currentValue.scale?E.currentValue.scale(H):E.currentValue*H:E.currentValue,l&&(T.addToRef?T.addToRef(J,T):T+=J),z=1}for(let H=z;H<u.animations.length;H++){const z=u.animations[H],E=z.weight/Y;E&&(z.currentValue.scaleAndAddToRef?z.currentValue.scaleAndAddToRef(E,T):T+=z.currentValue*E)}for(let H=0;H<u.additiveAnimations.length;H++){const z=u.additiveAnimations[H],Y=z.weight;Y&&(z.currentValue.scaleAndAddToRef?z.currentValue.scaleAndAddToRef(Y,T):T+=z.currentValue*Y)}}Y[z]=T}Y._lateAnimationHolders={}}z._registeredForLateAnimationBindings.reset()}}(this)},C.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((z,u)=>z.playOrder-u.playOrder))},C.prototype.beginWeightedAnimation=function(z,u,Y){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,E=arguments.length>4?arguments[4]:void 0,J=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,l=arguments.length>6?arguments[6]:void 0,T=arguments.length>7?arguments[7]:void 0,b=arguments.length>8?arguments[8]:void 0,L=arguments.length>9?arguments[9]:void 0,D=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const g=this.beginAnimation(z,u,Y,E,J,l,T,!1,b,L,D);return g.weight=H,g},C.prototype.beginAnimation=function(z,u,Y,H){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,J=arguments.length>5?arguments[5]:void 0,l=arguments.length>6?arguments[6]:void 0,T=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],b=arguments.length>8?arguments[8]:void 0,L=arguments.length>9?arguments[9]:void 0,D=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(E<0){const z=u;u=Y,Y=z,E=-E}u>Y&&(E=-E),T&&this.stopAnimation(z,void 0,b),l||(l=new g(this,z,u,Y,H,E,J,void 0,L,D));const M=!b||b(z);if(z.animations&&M&&l.appendAnimations(z,z.animations),z.getAnimatables){const D=z.getAnimatables();for(let z=0;z<D.length;z++)this.beginAnimation(D[z],u,Y,H,E,J,l,T,b,L)}return l.reset(),l},C.prototype.beginHierarchyAnimation=function(z,u,Y,H,E){let J=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,l=arguments.length>6?arguments[6]:void 0,T=arguments.length>7?arguments[7]:void 0,b=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],L=arguments.length>9?arguments[9]:void 0,D=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const g=z.getDescendants(u),M=[];M.push(this.beginAnimation(z,Y,H,E,J,l,T,b,L,void 0,D));for(const q of g)M.push(this.beginAnimation(q,Y,H,E,J,l,T,b,L,void 0,D));return M},C.prototype.beginDirectAnimation=function(z,u,Y,H,E){let J=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(J<0){const z=Y;Y=H,H=z,J=-J}return Y>H&&(J=-J),new g(this,z,Y,H,E,J,arguments.length>6?arguments[6]:void 0,u,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},C.prototype.beginDirectHierarchyAnimation=function(z,u,Y,H,E,J,l,T,b){let L=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const D=z.getDescendants(u),g=[];g.push(this.beginDirectAnimation(z,Y,H,E,J,l,T,b,L));for(const M of D)g.push(this.beginDirectAnimation(M,Y,H,E,J,l,T,b,L));return g},C.prototype.getAnimatableByTarget=function(z){for(let u=0;u<this._activeAnimatables.length;u++)if(this._activeAnimatables[u].target===z)return this._activeAnimatables[u];return null},C.prototype.getAllAnimatablesByTarget=function(z){const u=[];for(let Y=0;Y<this._activeAnimatables.length;Y++)this._activeAnimatables[Y].target===z&&u.push(this._activeAnimatables[Y]);return u},C.prototype.stopAnimation=function(z,u,Y){const H=this.getAllAnimatablesByTarget(z);for(const E of H)E.stop(u,Y)},C.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let z=0;z<this._activeAnimatables.length;z++)this._activeAnimatables[z].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const z of this.animationGroups)z.stop()});class o{getClassName(){return"TargetedAnimation"}serialize(){const z={};return z.animation=this.animation.serialize(),z.targetId=this.target.id,z}}class d{get mask(){return this._mask}set mask(z){this._mask!==z&&(this._mask=z,this.syncWithMask(!0))}syncWithMask(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||z){this._numActiveAnimatables=0;for(let z=0;z<this._animatables.length;++z){const u=this._animatables[z];!this.mask||this.mask.disabled||this.mask.retainsTarget(u.target.name)?(this._numActiveAnimatables++,u.paused&&u.restart()):u.paused||u.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let z=0;z<this._animatables.length;++z){const u=this._animatables[z];this.mask.retainsTarget(u.target.name)||(u.stop(),this._animatables.splice(z,1),--z)}for(let z=0;z<this._targetedAnimations.length;z++){const u=this._targetedAnimations[z];this.mask.retainsTarget(u.target.name)||(this._targetedAnimations.splice(z,1),--z)}}}get from(){return this._from}set from(z){if(this._from!==z){this._from=z;for(let z=0;z<this._animatables.length;z++){this._animatables[z].fromFrame=this._from}}}get to(){return this._to}set to(z){if(this._to!==z){this._to=z;for(let z=0;z<this._animatables.length;z++){this._animatables[z].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(z){if(this._speedRatio!==z){this._speedRatio=z;for(let z=0;z<this._animatables.length;z++){this._animatables[z].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(z){if(this._loopAnimation!==z){this._loopAnimation=z;for(let z=0;z<this._animatables.length;z++){this._animatables[z].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(z){if(this._isAdditive!==z){this._isAdditive=z;for(let z=0;z<this._animatables.length;z++){this._animatables[z].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(z){this._weight!==z&&(this._weight=z,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(z){if(this._playOrder!==z&&(this._playOrder=z,this._animatables.length>0)){for(let z=0;z<this._animatables.length;z++)this._animatables[z].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(z){if(this._enableBlending!==z&&(this._enableBlending=z,null!==z))for(let u=0;u<this._targetedAnimations.length;++u)this._targetedAnimations[u].animation.enableBlending=z}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(z){if(this._blendingSpeed!==z&&(this._blendingSpeed=z,null!==z))for(let u=0;u<this._targetedAnimations.length;++u)this._targetedAnimations[u].animation.blendingSpeed=z}getLength(z,u){z=z??this._from;return((u=u??this._to)-z)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(z){let u=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],H=arguments.length>3?arguments[3]:void 0;if(0===z.length)return null;H=H??z[0].weight;let E=Number.MAX_VALUE,J=-Number.MAX_VALUE;if(Y)for(const T of z)T.from<E&&(E=T.from),T.to>J&&(J=T.to);const l=new d(z[0].name+"_merged",z[0]._scene,H);for(const T of z){Y&&T.normalize(E,J);for(const z of T.targetedAnimations)l.addTargetedAnimation(z.animation,z.target);u&&T.dispose()}return l}constructor(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=z,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new E.e,this.onAnimationLoopObservable=new E.e,this.onAnimationGroupLoopObservable=new E.e,this.onAnimationGroupEndObservable=new E.e,this.onAnimationGroupPauseObservable=new E.e,this.onAnimationGroupPlayObservable=new E.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=u||J.d.LastCreatedScene,this._weight=Y,this._playOrder=H,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(z,u){const Y=new o;Y.animation=z,Y.target=u;const H=z.getKeys();return this._from>H[0].frame&&(this._from=H[0].frame),this._to<H[H.length-1].frame&&(this._to=H[H.length-1].frame),null!==this._enableBlending&&(z.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(z.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(Y),this._shouldStart=!0,Y}removeTargetedAnimation(z){for(let u=this._targetedAnimations.length-1;u>-1;u--){this._targetedAnimations[u].animation===z&&this._targetedAnimations.splice(u,1)}}normalize(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==z&&(z=this._from),null==u&&(u=this._to);for(let Y=0;Y<this._targetedAnimations.length;Y++){const H=this._targetedAnimations[Y].animation.getKeys(),E=H[0],J=H[H.length-1];if(E.frame>z){const u={frame:z,value:E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation};H.splice(0,0,u)}if(J.frame<u){const z={frame:u,value:J.value,inTangent:J.inTangent,outTangent:J.outTangent,interpolation:J.interpolation};H.push(z)}}return this._from=z,this._to=u,this}_processLoop(z,u,Y){z.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(u),this._animationLoopFlags[Y]||(this._animationLoopFlags[Y]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0],u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Y=arguments.length>2?arguments[2]:void 0,H=arguments.length>3?arguments[3]:void 0,E=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=z,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let J=0;J<this._targetedAnimations.length;J++){const l=this._targetedAnimations[J],T=this._scene.beginDirectAnimation(l.target,[l.animation],void 0!==Y?Y:this._from,void 0!==H?H:this._to,z,u,void 0,void 0,void 0!==E?E:this._isAdditive);T.weight=this._weight,T.playOrder=this._playOrder,T.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(l),this._checkAnimationGroupEnded(T)},this._processLoop(T,l,J),this._animatables.push(T)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=u,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let z=0;z<this._animatables.length;z++){this._animatables[z].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(z){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==z&&(this.loopAnimation=z),this.restart()):(this.stop(),this.start(z,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let z=0;z<this._animatables.length;z++){this._animatables[z].reset()}return this}restart(){if(!this._isStarted)return this;for(let z=0;z<this._animatables.length;z++){this._animatables[z].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const u=this._animatables.slice();for(let H=0;H<u.length;H++)u[H].stop(void 0,void 0,!0,z);let Y=0;for(let H=0;H<this._scene._activeAnimatables.length;H++){const u=this._scene._activeAnimatables[H];u._runtimeAnimations.length>0?this._scene._activeAnimatables[Y++]=u:z&&this._checkAnimationGroupEnded(u,z)}return this._scene._activeAnimatables.length=Y,this._isStarted=!1,this}setWeightForAllAnimatables(z){for(let u=0;u<this._animatables.length;u++){this._animatables[u].weight=z}return this}syncAllAnimationsWith(z){for(let u=0;u<this._animatables.length;u++){this._animatables[u].syncWith(z)}return this}goToFrame(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].goToFrame(z,u)}return this}getCurrentFrame(){var z;return(null===(z=this.animatables[0])||void 0===z?void 0:z.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const z=this._scene.animationGroups.indexOf(this);if(z>-1&&this._scene.animationGroups.splice(z,1),this._parentContainer){const z=this._parentContainer.animationGroups.indexOf(this);z>-1&&this._parentContainer.animationGroups.splice(z,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Y=this._animatables.indexOf(z);Y>-1&&this._animatables.splice(Y,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,u||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(z,u){let Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const H=new d(z||this.name,this._scene,this._weight,this._playOrder);H._from=this.from,H._to=this.to,H._speedRatio=this.speedRatio,H._loopAnimation=this.loopAnimation,H._isAdditive=this.isAdditive,H._enableBlending=this.enableBlending,H._blendingSpeed=this.blendingSpeed,H.metadata=this.metadata,H.mask=this.mask;for(const E of this._targetedAnimations)H.addTargetedAnimation(Y?E.animation.clone():E.animation,u?u(E.target):E.target);return H}serialize(){const z={};z.name=this.name,z.from=this.from,z.to=this.to,z.speedRatio=this.speedRatio,z.loopAnimation=this.loopAnimation,z.isAdditive=this.isAdditive,z.weight=this.weight,z.playOrder=this.playOrder,z.enableBlending=this.enableBlending,z.blendingSpeed=this.blendingSpeed,z.targetedAnimations=[];for(let u=0;u<this.targetedAnimations.length;u++){const Y=this.targetedAnimations[u];z.targetedAnimations[u]=Y.serialize()}return l.e&&l.e.HasTags(this)&&(z.tags=l.e.GetTags(this)),this.metadata&&(z.metadata=this.metadata),z}static Parse(z,u){const Y=new d(z.name,u,z.weight,z.playOrder);for(let E=0;E<z.targetedAnimations.length;E++){const J=z.targetedAnimations[E],l=H.e.Parse(J.animation),T=J.targetId;if("influence"===J.animation.property){const z=u.getMorphTargetById(T);z&&Y.addTargetedAnimation(l,z)}else{const z=u.getNodeById(T);null!=z&&Y.addTargetedAnimation(l,z)}}return l.e&&l.e.AddTagsTo(Y,z.tags),null!==z.from&&null!==z.to&&Y.normalize(z.from,z.to),void 0!==z.speedRatio&&(Y._speedRatio=z.speedRatio),void 0!==z.loopAnimation&&(Y._loopAnimation=z.loopAnimation),void 0!==z.isAdditive&&(Y._isAdditive=z.isAdditive),void 0!==z.weight&&(Y._weight=z.weight),void 0!==z.playOrder&&(Y._playOrder=z.playOrder),void 0!==z.enableBlending&&(Y._enableBlending=z.enableBlending),void 0!==z.blendingSpeed&&(Y._blendingSpeed=z.blendingSpeed),void 0!==z.metadata&&(Y.metadata=z.metadata),Y}static MakeAnimationAdditive(z,u,Y){let E;E="object"===typeof u?u:{referenceFrame:u,range:Y,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let J=z;E.cloneOriginalAnimationGroup&&(J=z.clone(E.clonedAnimationGroupName||J.name));const l=J.targetedAnimations;for(let T=0;T<l.length;T++){const z=l[T];z.animation=H.e.MakeAnimationAdditive(z.animation,E)}if(J.isAdditive=!0,E.clipKeys){let z=Number.MAX_VALUE,u=-Number.MAX_VALUE;const Y=J.targetedAnimations;for(let H=0;H<Y.length;H++){const E=Y[H].animation.getKeys();z>E[0].frame&&(z=E[0].frame),u<E[E.length-1].frame&&(u=E[E.length-1].frame)}J._from=z,J._to=u}return J}static ClipKeys(z,u,Y,H,E){const J=z.clone(H||z.name);return d.ClipKeysInPlace(J,u,Y,E)}static ClipKeysInPlace(z,u,Y,H){return d.ClipInPlace(z,u,Y,H,!1)}static ClipFrames(z,u,Y,H,E){const J=z.clone(H||z.name);return d.ClipFramesInPlace(J,u,Y,E)}static ClipFramesInPlace(z,u,Y,H){return d.ClipInPlace(z,u,Y,H,!0)}static ClipInPlace(z,u,Y,H){let E=arguments.length>4&&void 0!==arguments[4]&&arguments[4],J=Number.MAX_VALUE,l=-Number.MAX_VALUE;const T=z.targetedAnimations;for(let b=0;b<T.length;b++){const z=T[b],L=H?z.animation:z.animation.clone();E&&(L.createKeyForFrame(u),L.createKeyForFrame(Y));const D=L.getKeys(),g=[];let M=Number.MAX_VALUE;for(let H=0;H<D.length;H++){const z=D[H];if(!E&&H>=u&&H<=Y||E&&z.frame>=u&&z.frame<=Y){const u={frame:z.frame,value:z.value.clone?z.value.clone():z.value,inTangent:z.inTangent,outTangent:z.outTangent,interpolation:z.interpolation,lockedTangent:z.lockedTangent};M===Number.MAX_VALUE&&(M=u.frame),u.frame-=M,g.push(u)}}0!==g.length?(J>g[0].frame&&(J=g[0].frame),l<g[g.length-1].frame&&(l=g[g.length-1].frame),L.setKeys(g,!0),z.animation=L):(T.splice(b,1),b--)}return z._from=J,z._to=l,z}getClassName(){return"AnimationGroup"}toString(z){let u="Name: "+this.name;return u+=", type: "+this.getClassName(),z&&(u+=", from: "+this._from,u+=", to: "+this._to,u+=", isStarted: "+this._isStarted,u+=", speedRatio: "+this._speedRatio,u+=", targetedAnimations length: "+this._targetedAnimations.length,u+=", animatables length: "+this._animatables),u}}}}]);