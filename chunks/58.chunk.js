"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[58],{14039:(q,c,U)=>{U.r(c),U.d(c,{AnimationGroup:()=>a,TargetedAnimation:()=>o});var J=U(11468),Q=U(10866),s=U(10864),g=U(11087),X=U(12580),n=U(10833);class W{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(q,c,U,Q){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=c,this._target=q,this._scene=U,this._host=Q,this._activeTargets=[],c._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===J.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=n.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const q={frame:0,value:this._minValue};this._keys.splice(0,0,q)}if(this._target instanceof Array){let q=0;for(const c of this._target)this._preparePath(c,q),this._getOriginalValues(q),q++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const s=c.getEvents();if(s&&s.length>0)for(const J of s)this._events.push(J._clone());this._enableBlending=q&&q.animationPropertiesOverride?q.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(q){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const U=this._animation.targetPropertyPath;if(U.length>1){let J=q;for(let q=0;q<U.length-1;q++){const c=U[q];if(J=J[c],void 0===J)throw new Error(`Invalid property (${c}) in property path (${U.join(".")})`)}this._targetPath=U[U.length-1],this._activeTargets[c]=J}else this._targetPath=U[0],this._activeTargets[c]=q;if(void 0===this._activeTargets[c][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${U.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let q=0;for(const c of this._target)void 0!==this._originalValue[q]&&this._setValue(c,this._activeTargets[q],this._originalValue[q],-1,q),q++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let q=0;q<this._events.length;q++)this._events[q].isDone=!1}isStopped(){return this._stopped}dispose(){const q=this._animation.runtimeAnimations.indexOf(this);q>-1&&this._animation.runtimeAnimations.splice(q,1)}setValue(q,c){if(this._targetIsArray)for(let U=0;U<this._target.length;U++){const J=this._target[U];this._setValue(J,this._activeTargets[U],q,c,U)}else this._setValue(this._target,this._directTarget,q,c,0)}_getOriginalValues(){let q,c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const U=this._activeTargets[c];q=U.getLocalMatrix&&"_matrix"===this._targetPath?U.getLocalMatrix():U[this._targetPath],q&&q.clone?this._originalValue[c]=q.clone():this._originalValue[c]=q}_registerTargetForLateAnimationBinding(q,c){const U=q.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(U),U._lateAnimationHolders||(U._lateAnimationHolders={}),U._lateAnimationHolders[q.targetPath]||(U._lateAnimationHolders[q.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:c}),q.isAdditive?(U._lateAnimationHolders[q.targetPath].additiveAnimations.push(q),U._lateAnimationHolders[q.targetPath].totalAdditiveWeight+=q.weight):(U._lateAnimationHolders[q.targetPath].animations.push(q),U._lateAnimationHolders[q.targetPath].totalWeight+=q.weight)}_setValue(q,c,U,Q,s){if(this._currentActiveTarget=c,this._weight=Q,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const q=c[this._targetPath];q.clone?this._originalBlendValue=q.clone():this._originalBlendValue=q}this._originalBlendValue.m?J.b.AllowMatrixDecomposeForInterpolation?this._currentValue?n.d.DecomposeLerpToRef(this._originalBlendValue,U,this._blendingFactor,this._currentValue):this._currentValue=n.d.DecomposeLerp(this._originalBlendValue,U,this._blendingFactor):this._currentValue?n.d.LerpToRef(this._originalBlendValue,U,this._blendingFactor,this._currentValue):this._currentValue=n.d.Lerp(this._originalBlendValue,U,this._blendingFactor):this._currentValue=J.b._UniversalLerp(this._originalBlendValue,U,this._blendingFactor);const Q=q&&q.animationPropertiesOverride?q.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=Q}else this._currentValue?this._currentValue.X?this._currentValue.X(U):this._currentValue=U:null!==U&&void 0!==U&&U.clone?this._currentValue=U.clone():this._currentValue=U;-1!==Q?this._registerTargetForLateAnimationBinding(this,this._originalValue[s]):this._animationState.loopMode===J.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[s],c[this._targetPath]):c[this._targetPath]=this._originalValue[s]+this._currentValue:c[this._targetPath]=this._currentValue,q.PW&&q.PW(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(q){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const U=this._animation.getKeys();q<U[0].frame?q=U[0].frame:q>U[U.length-1].frame&&(q=U[U.length-1].frame);const J=this._events;if(J.length)for(let s=0;s<J.length;s++)J[s].onlyOnce||(J[s].isDone=J[s].frame<q);this._currentFrame=q;const Q=this._animation._interpolate(q,this._animationState);this.setValue(Q,c)}_prepareForSpeedRatioChange(q){const c=this._previousElapsedTime*(this._animation.framePerSecond*q)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-c}animate(q,c,U,Q,s){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const X=this._animation,n=X.targetPropertyPath;if(!n||n.length<1)return this._stopped=!0,!1;let W,D=!0;const u=this._events;let K=0;if(this._coreRuntimeAnimation)K=U-c,W=this._coreRuntimeAnimation.currentFrame,this._currentFrame=W,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let g;(c<this._minFrame||c>this._maxFrame)&&(c=this._minFrame),(U<this._minFrame||U>this._maxFrame)&&(U=this._maxFrame),K=U-c;let n=q*(X.framePerSecond*s)/1e3+this._absoluteFrameOffset,r=0,H=!1;const b=Q&&this._animationState.loopMode===J.b.ANIMATIONLOOPMODE_YOYO;if(b){const q=(n-c)/K,U=Math.sin(q*Math.PI);n=Math.abs(U)*K+c;const J=U>=0?1:-1;this._yoyoDirection!==J&&(H=!0),this._yoyoDirection=J}if(this._previousElapsedTime=q,this._previousAbsoluteFrame=n,!Q&&U>=c&&(n>=K&&s>0||n<=0&&s<0))D=!1,r=X._getKeyValue(this._maxValue);else if(!Q&&c>=U&&(n<=K&&s<0||n>=0&&s>0))D=!1,r=X._getKeyValue(this._minValue);else if(this._animationState.loopMode!==J.b.ANIMATIONLOOPMODE_CYCLE){const q=U.toString()+c.toString();if(!this._offsetsCache[q]){this._animationState.repeatCount=0,this._animationState.loopMode=J.b.ANIMATIONLOOPMODE_CYCLE;const Q=X._interpolate(c,this._animationState),s=X._interpolate(U,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),X.dataType){case J.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[q]=s-Q;break;case J.b.ANIMATIONTYPE_QUATERNION:case J.b.ANIMATIONTYPE_VECTOR3:case J.b.ANIMATIONTYPE_VECTOR2:case J.b.ANIMATIONTYPE_SIZE:case J.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[q]=s.eU(Q)}this._highLimitsCache[q]=s}r=this._highLimitsCache[q],g=this._offsetsCache[q]}if(void 0===g)switch(X.dataType){case J.b.ANIMATIONTYPE_FLOAT:g=0;break;case J.b.ANIMATIONTYPE_QUATERNION:g=J.k;break;case J.b.ANIMATIONTYPE_VECTOR3:g=J.r;break;case J.b.ANIMATIONTYPE_VECTOR2:g=J.q;break;case J.b.ANIMATIONTYPE_SIZE:g=J.n;break;case J.b.ANIMATIONTYPE_COLOR3:g=J.e;break;case J.b.ANIMATIONTYPE_COLOR4:g=J.i}if(this._host&&this._host.syncRoot){const q=this._host.syncRoot;W=c+K*((q.masterFrame-q.fromFrame)/(q.toFrame-q.fromFrame))}else W=n>0&&c>U||n<0&&c<U?D&&0!==K?U+n%K:c:D&&0!==K?c+n%K:U;if(!b&&(s>0&&this.currentFrame>W||s<0&&this.currentFrame<W)||b&&H){this._onLoop();for(let q=0;q<u.length;q++)u[q].onlyOnce||(u[q].isDone=!1);this._animationState.key=s>0?0:X.getKeys().length-1}this._currentFrame=W,this._animationState.repeatCount=0===K?0:n/K|0,this._animationState.highLimitValue=r,this._animationState.offsetValue=g}const r=X._interpolate(W,this._animationState);if(this.setValue(r,g),u.length)for(let J=0;J<u.length;J++)if(K>=0&&W>=u[J].frame&&u[J].frame>=c||K<0&&W<=u[J].frame&&u[J].frame<=c){const q=u[J];q.isDone||(q.onlyOnce&&(u.splice(J,1),J--),q.isDone=!0,q.action(W))}return D||(this._stopped=!0),D}}var D=U(10902);class u{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(q){this._weight=-1!==q?Math.min(Math.max(q,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(q){for(let c=0;c<this._runtimeAnimations.length;c++){this._runtimeAnimations[c]._prepareForSpeedRatioChange(q)}this._speedRatio=q,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(q,c){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,X=arguments.length>6?arguments[6]:void 0,n=arguments.length>7?arguments[7]:void 0,W=arguments.length>8?arguments[8]:void 0,D=arguments.length>9&&void 0!==arguments[9]&&arguments[9],u=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=c,this.fromFrame=U,this.toFrame=J,this.loopAnimation=s,this.onAnimationEnd=X,this.onAnimationLoop=W,this.isAdditive=D,this.playOrder=u,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.NX=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new Q.e,this.onAnimationLoopObservable=new Q.e,this._scene=q,n&&this.appendAnimations(c,n),this._speedRatio=g,q._activeAnimatables.push(this)}syncWith(q){if(this._syncRoot=q,q){const q=this._scene._activeAnimatables.indexOf(this);q>-1&&(this._scene._activeAnimatables.splice(q,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(q,c){for(let U=0;U<c.length;U++){const J=c[U],Q=new W(q,J,this._scene,this);Q._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(Q)}}getAnimationByTargetProperty(q){const c=this._runtimeAnimations;for(let U=0;U<c.length;U++)if(c[U].animation.targetProperty===q)return c[U].animation;return null}getRuntimeAnimationByTargetProperty(q){const c=this._runtimeAnimations;for(let U=0;U<c.length;U++)if(c[U].animation.targetProperty===q)return c[U];return null}reset(){const q=this._runtimeAnimations;for(let c=0;c<q.length;c++)q[c].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(q){const c=this._runtimeAnimations;for(let U=0;U<c.length;U++)c[U].animation.enableBlending=!0,c[U].animation.blendingSpeed=q}disableBlending(){const q=this._runtimeAnimations;for(let c=0;c<q.length;c++)q[c].animation.enableBlending=!1}goToFrame(q){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const U=this._runtimeAnimations;if(U[0]){const c=U[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??U[0].currentFrame;const J=0===this.speedRatio?0:(q-this._frameToSyncFromJump)/c*1e3/this.speedRatio;this._manualJumpDelay=-J}for(let J=0;J<U.length;J++)U[J].goToFrame(q,c?this._weight:-1);this._goToFrame=q}get paused(){return this.NX}pause(){this.NX||(this.NX=!0)}restart(){this.NX=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(q,c){let U=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(q||c){const Q=this._scene._activeAnimatables.indexOf(this);if(Q>-1){const s=this._runtimeAnimations;for(let U=s.length-1;U>=0;U--){const J=s[U];q&&J.animation.name!=q||(c&&!c(J.target)||(J.dispose(),s.splice(U,1)))}0==s.length&&(U||this._scene._activeAnimatables.splice(Q,1),J||this._raiseOnAnimationEnd())}}else{const q=this._scene._activeAnimatables.indexOf(this);if(q>-1){U||this._scene._activeAnimatables.splice(q,1);const c=this._runtimeAnimations;for(let q=0;q<c.length;q++)c[q].dispose();this._runtimeAnimations.length=0,J||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((q=>{this.onAnimationEndObservable.add((()=>{q(this)}),void 0,void 0,this,!0)}))}_animate(q){if(this.NX)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=q),!0;if(null===this._localDelayOffset?(this._localDelayOffset=q,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=q-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let c=!1;const U=this._runtimeAnimations;let J;for(J=0;J<U.length;J++){const Q=U[J].animate(q-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);c=c||Q}if(this.animationStarted=c,!c){if(this.disposeOnEnd)for(J=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(J,1),J=0;J<U.length;J++)U[J].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return c}}function K(q){if(0===q.totalWeight&&0===q.totalAdditiveWeight)return q.originalValue;let c=1;const U=n.j.hc[0],J=n.j.hc[1],Q=n.j.Quaternion[0];let s=0;const g=q.animations[0],X=q.originalValue;let W=1,D=!1;if(q.totalWeight<1)W=1-q.totalWeight,X.decompose(J,Q,U);else{if(s=1,c=q.totalWeight,W=g.weight/c,1==W){if(!q.totalAdditiveWeight)return g.currentValue;D=!0}g.currentValue.decompose(J,Q,U)}if(!D){J.scaleInPlace(W),U.scaleInPlace(W),Q.scaleInPlace(W);for(let g=s;g<q.animations.length;g++){const s=q.animations[g];if(0===s.weight)continue;W=s.weight/c;const X=n.j.hc[2],D=n.j.hc[3],u=n.j.Quaternion[1];s.currentValue.decompose(D,u,X),D.scaleAndAddToRef(W,J),u.scaleAndAddToRef(n.g.Dot(Q,u)>0?W:-W,Q),X.scaleAndAddToRef(W,U)}Q.normalize()}for(let K=0;K<q.additiveAnimations.length;K++){const c=q.additiveAnimations[K];if(0===c.weight)continue;const s=n.j.hc[2],g=n.j.hc[3],X=n.j.Quaternion[1];c.currentValue.decompose(g,X,s),g.multiplyToRef(J,g),n.p.LerpToRef(J,g,c.weight,J),Q.multiplyToRef(X,X),n.g.SlerpToRef(Q,X,c.weight,Q),s.scaleAndAddToRef(c.weight,U)}const u=g?g._animationState.workValue:n.j.Matrix[0].clone();return n.d.ComposeToRef(J,Q,U,u),u}function r(q,c){if(0===q.totalWeight&&0===q.totalAdditiveWeight)return c;const U=q.animations[0],J=q.originalValue;let Q=c;if(0===q.totalWeight&&q.totalAdditiveWeight>0)Q.X(J);else if(1===q.animations.length){if(n.g.SlerpToRef(J,U.currentValue,Math.min(1,q.totalWeight),Q),0===q.totalAdditiveWeight)return Q}else if(q.animations.length>1){let U,s,g=1;if(q.totalWeight<1){const c=1-q.totalWeight;U=[],s=[],U.push(J),s.push(c)}else{if(2===q.animations.length&&(n.g.SlerpToRef(q.animations[0].currentValue,q.animations[1].currentValue,q.animations[1].weight/q.totalWeight,c),0===q.totalAdditiveWeight))return c;U=[],s=[],g=q.totalWeight}for(let c=0;c<q.animations.length;c++){const J=q.animations[c];U.push(J.currentValue),s.push(J.weight/g)}let X=0;for(let q=0;q<U.length;)q?(X+=s[q],n.g.SlerpToRef(Q,U[q],s[q]/X,Q),q++):(n.g.SlerpToRef(U[q],U[q+1],s[q+1]/(s[q]+s[q+1]),c),Q=c,X=s[q]+s[q+1],q+=2)}for(let s=0;s<q.additiveAnimations.length;s++){const c=q.additiveAnimations[s];0!==c.weight&&(Q.multiplyToRef(c.currentValue,n.j.Quaternion[0]),n.g.SlerpToRef(Q,n.j.Quaternion[0],c.weight,Q))}return Q}var H,b,h=U(11364);H=h.b,(b=X.b)&&(b.prototype.copyAnimationRange=function(q,c,U){let Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new J.b(this.name,"_matrix",q.animations[0].framePerSecond,J.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const g=q.animations[0].getRange(c);if(!g)return!1;const X=g.from,n=g.to,W=q.animations[0].getKeys(),D=q.length,u=q.getParent(),K=this.getParent(),r=Q&&u&&D&&this.length&&D!==this.length,H=r&&K&&u?K.length/u.length:1,b=Q&&!K&&s&&(1!==s.x||1!==s.y||1!==s.z),h=this.animations[0].getKeys();let o,a,p;for(let J=0,R=W.length;J<R;J++)o=W[J],o.frame>=X&&o.frame<=n&&(Q?(p=o.value.clone(),r?(a=p.getTranslation(),p.setTranslation(a.scaleInPlace(H))):b&&s?(a=p.getTranslation(),p.setTranslation(a.multiplyInPlace(s))):p=o.value):p=o.value,h.push({frame:o.frame+U,value:p}));return this.animations[0].createRange(c,X+U,n+U),!0}),H&&(H.prototype._animate=function(q){if(!this.animationsEnabled)return;const c=D.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=c}this.deltaTime=void 0!==q?q:this.useConstantAnimationDeltaTime?16:(c-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=c;const U=this._activeAnimatables;if(0===U.length)return;this._animationTime+=this.deltaTime;const Q=this._animationTime;for(let J=0;J<U.length;J++){const q=U[J];!q._animate(Q)&&q.disposeOnEnd&&J--}!function(q){if(q._registeredForLateAnimationBindings.length){for(let c=0;c<q._registeredForLateAnimationBindings.length;c++){const U=q._registeredForLateAnimationBindings.data[c];for(const q in U._lateAnimationHolders){const c=U._lateAnimationHolders[q],Q=c.animations[0],s=c.originalValue;if(void 0===s||null===s)continue;const g=J.b.AllowMatrixDecomposeForInterpolation&&s.m;let X=U[q];if(g)X=K(c);else if(void 0!==s.w)X=r(c,X||n.g.Identity());else{let q=0,U=1;const g=Q&&Q._animationState.loopMode===J.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(c.totalWeight<1)X=g?s.clone?s.clone():s:Q&&s.scale?s.scale(1-c.totalWeight):Q?s*(1-c.totalWeight):s.clone?s.clone():s;else if(Q){U=c.totalWeight;const J=Q.weight/U;X=1!==J?Q.currentValue.scale?Q.currentValue.scale(J):Q.currentValue*J:Q.currentValue,g&&(X.addToRef?X.addToRef(s,X):X+=s),q=1}for(let J=q;J<c.animations.length;J++){const q=c.animations[J],Q=q.weight/U;Q&&(q.currentValue.scaleAndAddToRef?q.currentValue.scaleAndAddToRef(Q,X):X+=q.currentValue*Q)}for(let J=0;J<c.additiveAnimations.length;J++){const q=c.additiveAnimations[J],U=q.weight;U&&(q.currentValue.scaleAndAddToRef?q.currentValue.scaleAndAddToRef(U,X):X+=q.currentValue*U)}}U[q]=X}U._lateAnimationHolders={}}q._registeredForLateAnimationBindings.reset()}}(this)},H.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((q,c)=>q.playOrder-c.playOrder))},H.prototype.beginWeightedAnimation=function(q,c,U){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,Q=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,X=arguments.length>7?arguments[7]:void 0,n=arguments.length>8?arguments[8]:void 0,W=arguments.length>9?arguments[9]:void 0,D=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const u=this.beginAnimation(q,c,U,Q,s,g,X,!1,n,W,D);return u.weight=J,u},H.prototype.beginAnimation=function(q,c,U,J){let Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=arguments.length>5?arguments[5]:void 0,g=arguments.length>6?arguments[6]:void 0,X=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],n=arguments.length>8?arguments[8]:void 0,W=arguments.length>9?arguments[9]:void 0,D=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(Q<0){const q=c;c=U,U=q,Q=-Q}c>U&&(Q=-Q),X&&this.stopAnimation(q,void 0,n),g||(g=new u(this,q,c,U,J,Q,s,void 0,W,D));const K=!n||n(q);if(q.animations&&K&&g.appendAnimations(q,q.animations),q.getAnimatables){const D=q.getAnimatables();for(let q=0;q<D.length;q++)this.beginAnimation(D[q],c,U,J,Q,s,g,X,n,W)}return g.reset(),g},H.prototype.beginHierarchyAnimation=function(q,c,U,J,Q){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,X=arguments.length>7?arguments[7]:void 0,n=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],W=arguments.length>9?arguments[9]:void 0,D=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const u=q.getDescendants(c),K=[];K.push(this.beginAnimation(q,U,J,Q,s,g,X,n,W,void 0,D));for(const r of u)K.push(this.beginAnimation(r,U,J,Q,s,g,X,n,W,void 0,D));return K},H.prototype.beginDirectAnimation=function(q,c,U,J,Q){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(s<0){const q=U;U=J,J=q,s=-s}return U>J&&(s=-s),new u(this,q,U,J,Q,s,arguments.length>6?arguments[6]:void 0,c,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},H.prototype.beginDirectHierarchyAnimation=function(q,c,U,J,Q,s,g,X,n){let W=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const D=q.getDescendants(c),u=[];u.push(this.beginDirectAnimation(q,U,J,Q,s,g,X,n,W));for(const K of D)u.push(this.beginDirectAnimation(K,U,J,Q,s,g,X,n,W));return u},H.prototype.getAnimatableByTarget=function(q){for(let c=0;c<this._activeAnimatables.length;c++)if(this._activeAnimatables[c].target===q)return this._activeAnimatables[c];return null},H.prototype.getAllAnimatablesByTarget=function(q){const c=[];for(let U=0;U<this._activeAnimatables.length;U++)this._activeAnimatables[U].target===q&&c.push(this._activeAnimatables[U]);return c},H.prototype.stopAnimation=function(q,c,U){const J=this.getAllAnimatablesByTarget(q);for(const Q of J)Q.stop(c,U)},H.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let q=0;q<this._activeAnimatables.length;q++)this._activeAnimatables[q].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const q of this.animationGroups)q.stop()});class o{getClassName(){return"TargetedAnimation"}serialize(){const q={};return q.animation=this.animation.serialize(),q.targetId=this.target.id,q}}class a{get mask(){return this._mask}set mask(q){this._mask!==q&&(this._mask=q,this.syncWithMask(!0))}syncWithMask(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||q){this._numActiveAnimatables=0;for(let q=0;q<this._animatables.length;++q){const c=this._animatables[q];!this.mask||this.mask.disabled||this.mask.retainsTarget(c.target.name)?(this._numActiveAnimatables++,c.paused&&c.restart()):c.paused||c.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let q=0;q<this._animatables.length;++q){const c=this._animatables[q];this.mask.retainsTarget(c.target.name)||(c.stop(),this._animatables.splice(q,1),--q)}for(let q=0;q<this._targetedAnimations.length;q++){const c=this._targetedAnimations[q];this.mask.retainsTarget(c.target.name)||(this._targetedAnimations.splice(q,1),--q)}}}get from(){return this._from}set from(q){if(this._from!==q){this._from=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].fromFrame=this._from}}}get to(){return this._to}set to(q){if(this._to!==q){this._to=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(q){if(this._speedRatio!==q){this._speedRatio=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(q){if(this._loopAnimation!==q){this._loopAnimation=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(q){if(this._isAdditive!==q){this._isAdditive=q;for(let q=0;q<this._animatables.length;q++){this._animatables[q].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(q){this._weight!==q&&(this._weight=q,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(q){if(this._playOrder!==q&&(this._playOrder=q,this._animatables.length>0)){for(let q=0;q<this._animatables.length;q++)this._animatables[q].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(q){if(this._enableBlending!==q&&(this._enableBlending=q,null!==q))for(let c=0;c<this._targetedAnimations.length;++c)this._targetedAnimations[c].animation.enableBlending=q}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(q){if(this._blendingSpeed!==q&&(this._blendingSpeed=q,null!==q))for(let c=0;c<this._targetedAnimations.length;++c)this._targetedAnimations[c].animation.blendingSpeed=q}getLength(q,c){q=q??this._from;return((c=c??this._to)-q)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(q){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],U=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=arguments.length>3?arguments[3]:void 0;if(0===q.length)return null;J=J??q[0].weight;let Q=Number.MAX_VALUE,s=-Number.MAX_VALUE;if(U)for(const X of q)X.from<Q&&(Q=X.from),X.to>s&&(s=X.to);const g=new a(q[0].name+"_merged",q[0]._scene,J);for(const X of q){U&&X.normalize(Q,s);for(const q of X.targetedAnimations)g.addTargetedAnimation(q.animation,q.target);c&&X.dispose()}return g}constructor(q){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=q,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new Q.e,this.onAnimationLoopObservable=new Q.e,this.onAnimationGroupLoopObservable=new Q.e,this.onAnimationGroupEndObservable=new Q.e,this.onAnimationGroupPauseObservable=new Q.e,this.onAnimationGroupPlayObservable=new Q.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=c||s.c.LastCreatedScene,this._weight=U,this._playOrder=J,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(q,c){const U=new o;U.animation=q,U.target=c;const J=q.getKeys();return this._from>J[0].frame&&(this._from=J[0].frame),this._to<J[J.length-1].frame&&(this._to=J[J.length-1].frame),null!==this._enableBlending&&(q.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(q.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(U),this._shouldStart=!0,U}removeTargetedAnimation(q){for(let c=this._targetedAnimations.length-1;c>-1;c--){this._targetedAnimations[c].animation===q&&this._targetedAnimations.splice(c,1)}}normalize(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==q&&(q=this._from),null==c&&(c=this._to);for(let U=0;U<this._targetedAnimations.length;U++){const J=this._targetedAnimations[U].animation.getKeys(),Q=J[0],s=J[J.length-1];if(Q.frame>q){const c={frame:q,value:Q.value,inTangent:Q.inTangent,outTangent:Q.outTangent,interpolation:Q.interpolation};J.splice(0,0,c)}if(s.frame<c){const q={frame:c,value:s.value,inTangent:s.inTangent,outTangent:s.outTangent,interpolation:s.interpolation};J.push(q)}}return this._from=q,this._to=c,this}_processLoop(q,c,U){q.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(c),this._animationLoopFlags[U]||(this._animationLoopFlags[U]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0],c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,U=arguments.length>2?arguments[2]:void 0,J=arguments.length>3?arguments[3]:void 0,Q=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=q,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let s=0;s<this._targetedAnimations.length;s++){const g=this._targetedAnimations[s],X=this._scene.beginDirectAnimation(g.target,[g.animation],void 0!==U?U:this._from,void 0!==J?J:this._to,q,c,void 0,void 0,void 0!==Q?Q:this._isAdditive);X.weight=this._weight,X.playOrder=this._playOrder,X.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(g),this._checkAnimationGroupEnded(X)},this._processLoop(X,g,s),this._animatables.push(X)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=c,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let q=0;q<this._animatables.length;q++){this._animatables[q].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(q){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==q&&(this.loopAnimation=q),this.restart()):(this.stop(),this.start(q,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].reset()}return this}restart(){if(!this._isStarted)return this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const c=this._animatables.slice();for(let J=0;J<c.length;J++)c[J].stop(void 0,void 0,!0,q);let U=0;for(let J=0;J<this._scene._activeAnimatables.length;J++){const c=this._scene._activeAnimatables[J];c._runtimeAnimations.length>0?this._scene._activeAnimatables[U++]=c:q&&this._checkAnimationGroupEnded(c,q)}return this._scene._activeAnimatables.length=U,this._isStarted=!1,this}setWeightForAllAnimatables(q){for(let c=0;c<this._animatables.length;c++){this._animatables[c].weight=q}return this}syncAllAnimationsWith(q){for(let c=0;c<this._animatables.length;c++){this._animatables[c].syncWith(q)}return this}goToFrame(q){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let U=0;U<this._animatables.length;U++){this._animatables[U].goToFrame(q,c)}return this}getCurrentFrame(){var q;return(null===(q=this.animatables[0])||void 0===q?void 0:q.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const q=this._scene.animationGroups.indexOf(this);if(q>-1&&this._scene.animationGroups.splice(q,1),this._parentContainer){const q=this._parentContainer.animationGroups.indexOf(this);q>-1&&this._parentContainer.animationGroups.splice(q,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(q){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const U=this._animatables.indexOf(q);U>-1&&this._animatables.splice(U,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,c||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(q,c){let U=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const J=new a(q||this.name,this._scene,this._weight,this._playOrder);J._from=this.from,J._to=this.to,J._speedRatio=this.speedRatio,J._loopAnimation=this.loopAnimation,J._isAdditive=this.isAdditive,J._enableBlending=this.enableBlending,J._blendingSpeed=this.blendingSpeed,J.metadata=this.metadata,J.mask=this.mask;for(const Q of this._targetedAnimations)J.addTargetedAnimation(U?Q.animation.clone():Q.animation,c?c(Q.target):Q.target);return J}serialize(){const q={};q.name=this.name,q.from=this.from,q.to=this.to,q.speedRatio=this.speedRatio,q.loopAnimation=this.loopAnimation,q.isAdditive=this.isAdditive,q.weight=this.weight,q.playOrder=this.playOrder,q.enableBlending=this.enableBlending,q.blendingSpeed=this.blendingSpeed,q.targetedAnimations=[];for(let c=0;c<this.targetedAnimations.length;c++){const U=this.targetedAnimations[c];q.targetedAnimations[c]=U.serialize()}return g.d&&g.d.HasTags(this)&&(q.tags=g.d.GetTags(this)),this.metadata&&(q.metadata=this.metadata),q}static Parse(q,c){const U=new a(q.name,c,q.weight,q.playOrder);for(let Q=0;Q<q.targetedAnimations.length;Q++){const s=q.targetedAnimations[Q],g=J.b.Parse(s.animation),X=s.targetId;if("influence"===s.animation.property){const q=c.getMorphTargetById(X);q&&U.addTargetedAnimation(g,q)}else{const q=c.getNodeById(X);null!=q&&U.addTargetedAnimation(g,q)}}return g.d&&g.d.AddTagsTo(U,q.tags),null!==q.from&&null!==q.to&&U.normalize(q.from,q.to),void 0!==q.speedRatio&&(U._speedRatio=q.speedRatio),void 0!==q.loopAnimation&&(U._loopAnimation=q.loopAnimation),void 0!==q.isAdditive&&(U._isAdditive=q.isAdditive),void 0!==q.weight&&(U._weight=q.weight),void 0!==q.playOrder&&(U._playOrder=q.playOrder),void 0!==q.enableBlending&&(U._enableBlending=q.enableBlending),void 0!==q.blendingSpeed&&(U._blendingSpeed=q.blendingSpeed),void 0!==q.metadata&&(U.metadata=q.metadata),U}static MakeAnimationAdditive(q,c,U){let Q;Q="object"===typeof c?c:{referenceFrame:c,range:U,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let s=q;Q.cloneOriginalAnimationGroup&&(s=q.clone(Q.clonedAnimationGroupName||s.name));const g=s.targetedAnimations;for(let X=0;X<g.length;X++){const q=g[X];q.animation=J.b.MakeAnimationAdditive(q.animation,Q)}if(s.isAdditive=!0,Q.clipKeys){let q=Number.MAX_VALUE,c=-Number.MAX_VALUE;const U=s.targetedAnimations;for(let J=0;J<U.length;J++){const Q=U[J].animation.getKeys();q>Q[0].frame&&(q=Q[0].frame),c<Q[Q.length-1].frame&&(c=Q[Q.length-1].frame)}s._from=q,s._to=c}return s}static ClipKeys(q,c,U,J,Q){const s=q.clone(J||q.name);return a.ClipKeysInPlace(s,c,U,Q)}static ClipKeysInPlace(q,c,U,J){return a.ClipInPlace(q,c,U,J,!1)}static ClipFrames(q,c,U,J,Q){const s=q.clone(J||q.name);return a.ClipFramesInPlace(s,c,U,Q)}static ClipFramesInPlace(q,c,U,J){return a.ClipInPlace(q,c,U,J,!0)}static ClipInPlace(q,c,U,J){let Q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=Number.MAX_VALUE,g=-Number.MAX_VALUE;const X=q.targetedAnimations;for(let n=0;n<X.length;n++){const q=X[n],W=J?q.animation:q.animation.clone();Q&&(W.createKeyForFrame(c),W.createKeyForFrame(U));const D=W.getKeys(),u=[];let K=Number.MAX_VALUE;for(let J=0;J<D.length;J++){const q=D[J];if(!Q&&J>=c&&J<=U||Q&&q.frame>=c&&q.frame<=U){const c={frame:q.frame,value:q.value.clone?q.value.clone():q.value,inTangent:q.inTangent,outTangent:q.outTangent,interpolation:q.interpolation,lockedTangent:q.lockedTangent};K===Number.MAX_VALUE&&(K=c.frame),c.frame-=K,u.push(c)}}0!==u.length?(s>u[0].frame&&(s=u[0].frame),g<u[u.length-1].frame&&(g=u[u.length-1].frame),W.setKeys(u,!0),q.animation=W):(X.splice(n,1),n--)}return q._from=s,q._to=g,q}getClassName(){return"AnimationGroup"}toString(q){let c="Name: "+this.name;return c+=", type: "+this.getClassName(),q&&(c+=", from: "+this._from,c+=", to: "+this._to,c+=", isStarted: "+this._isStarted,c+=", speedRatio: "+this._speedRatio,c+=", targetedAnimations length: "+this._targetedAnimations.length,c+=", animatables length: "+this._animatables),c}}}}]);