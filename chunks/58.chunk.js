"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[58],{14214:(s,Z,o)=>{o.r(Z),o.d(Z,{AnimationGroup:()=>d,TargetedAnimation:()=>A});var t=o(11611),j=o(10932),S=o(10927),a=o(11172),O=o(12699),v=o(10900);class G{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(s,Z,o,j){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=Z,this._target=s,this._scene=o,this._host=j,this._activeTargets=[],Z._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===t.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=v.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const s={frame:0,value:this._minValue};this._keys.splice(0,0,s)}if(this._target instanceof Array){let s=0;for(const Z of this._target)this._preparePath(Z,s),this._getOriginalValues(s),s++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const S=Z.getEvents();if(S&&S.length>0)for(const t of S)this._events.push(t._clone());this._enableBlending=s&&s.animationPropertiesOverride?s.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(s){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=this._animation.targetPropertyPath;if(o.length>1){let t=s;for(let s=0;s<o.length-1;s++){const Z=o[s];if(t=t[Z],void 0===t)throw new Error(`Invalid property (${Z}) in property path (${o.join(".")})`)}this._targetPath=o[o.length-1],this._activeTargets[Z]=t}else this._targetPath=o[0],this._activeTargets[Z]=s;if(void 0===this._activeTargets[Z][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${o.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let s=0;for(const Z of this._target)void 0!==this._originalValue[s]&&this._setValue(Z,this._activeTargets[s],this._originalValue[s],-1,s),s++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let s=0;s<this._events.length;s++)this._events[s].isDone=!1}isStopped(){return this._stopped}dispose(){const s=this._animation.runtimeAnimations.indexOf(this);s>-1&&this._animation.runtimeAnimations.splice(s,1)}setValue(s,Z){if(this._targetIsArray)for(let o=0;o<this._target.length;o++){const t=this._target[o];this._setValue(t,this._activeTargets[o],s,Z,o)}else this._setValue(this._target,this._directTarget,s,Z,0)}_getOriginalValues(){let s,Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const o=this._activeTargets[Z];s=o.getLocalMatrix&&"_matrix"===this._targetPath?o.getLocalMatrix():o[this._targetPath],s&&s.clone?this._originalValue[Z]=s.clone():this._originalValue[Z]=s}_registerTargetForLateAnimationBinding(s,Z){const o=s.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(o),o._lateAnimationHolders||(o._lateAnimationHolders={}),o._lateAnimationHolders[s.targetPath]||(o._lateAnimationHolders[s.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:Z}),s.isAdditive?(o._lateAnimationHolders[s.targetPath].additiveAnimations.push(s),o._lateAnimationHolders[s.targetPath].totalAdditiveWeight+=s.weight):(o._lateAnimationHolders[s.targetPath].animations.push(s),o._lateAnimationHolders[s.targetPath].totalWeight+=s.weight)}_setValue(s,Z,o,j,S){if(this._currentActiveTarget=Z,this._weight=j,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const s=Z[this._targetPath];s.clone?this._originalBlendValue=s.clone():this._originalBlendValue=s}this._originalBlendValue.m?t.e.AllowMatrixDecomposeForInterpolation?this._currentValue?v.b.DecomposeLerpToRef(this._originalBlendValue,o,this._blendingFactor,this._currentValue):this._currentValue=v.b.DecomposeLerp(this._originalBlendValue,o,this._blendingFactor):this._currentValue?v.b.LerpToRef(this._originalBlendValue,o,this._blendingFactor,this._currentValue):this._currentValue=v.b.Lerp(this._originalBlendValue,o,this._blendingFactor):this._currentValue=t.e._UniversalLerp(this._originalBlendValue,o,this._blendingFactor);const j=s&&s.animationPropertiesOverride?s.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=j}else this._currentValue?this._currentValue.O?this._currentValue.O(o):this._currentValue=o:null!==o&&void 0!==o&&o.clone?this._currentValue=o.clone():this._currentValue=o;-1!==j?this._registerTargetForLateAnimationBinding(this,this._originalValue[S]):this._animationState.loopMode===t.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[S],Z[this._targetPath]):Z[this._targetPath]=this._originalValue[S]+this._currentValue:Z[this._targetPath]=this._currentValue,s.dG&&s.dG(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(s){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const o=this._animation.getKeys();s<o[0].frame?s=o[0].frame:s>o[o.length-1].frame&&(s=o[o.length-1].frame);const t=this._events;if(t.length)for(let S=0;S<t.length;S++)t[S].onlyOnce||(t[S].isDone=t[S].frame<s);this._currentFrame=s;const j=this._animation._interpolate(s,this._animationState);this.setValue(j,Z)}_prepareForSpeedRatioChange(s){const Z=this._previousElapsedTime*(this._animation.framePerSecond*s)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-Z}animate(s,Z,o,j,S){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const O=this._animation,v=O.targetPropertyPath;if(!v||v.length<1)return this._stopped=!0,!1;let G,B=!0;const Q=this._events;let D=0;if(this._coreRuntimeAnimation)D=o-Z,G=this._coreRuntimeAnimation.currentFrame,this._currentFrame=G,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let a;(Z<this._minFrame||Z>this._maxFrame)&&(Z=this._minFrame),(o<this._minFrame||o>this._maxFrame)&&(o=this._maxFrame),D=o-Z;let v=s*(O.framePerSecond*S)/1e3+this._absoluteFrameOffset,z=0,Y=!1;const b=j&&this._animationState.loopMode===t.e.ANIMATIONLOOPMODE_YOYO;if(b){const s=(v-Z)/D,o=Math.sin(s*Math.PI);v=Math.abs(o)*D+Z;const t=o>=0?1:-1;this._yoyoDirection!==t&&(Y=!0),this._yoyoDirection=t}if(this._previousElapsedTime=s,this._previousAbsoluteFrame=v,!j&&o>=Z&&(v>=D&&S>0||v<=0&&S<0))B=!1,z=O._getKeyValue(this._maxValue);else if(!j&&Z>=o&&(v<=D&&S<0||v>=0&&S>0))B=!1,z=O._getKeyValue(this._minValue);else if(this._animationState.loopMode!==t.e.ANIMATIONLOOPMODE_CYCLE){const s=o.toString()+Z.toString();if(!this._offsetsCache[s]){this._animationState.repeatCount=0,this._animationState.loopMode=t.e.ANIMATIONLOOPMODE_CYCLE;const j=O._interpolate(Z,this._animationState),S=O._interpolate(o,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),O.dataType){case t.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[s]=S-j;break;case t.e.ANIMATIONTYPE_QUATERNION:case t.e.ANIMATIONTYPE_VECTOR3:case t.e.ANIMATIONTYPE_VECTOR2:case t.e.ANIMATIONTYPE_SIZE:case t.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[s]=S.Go(j)}this._highLimitsCache[s]=S}z=this._highLimitsCache[s],a=this._offsetsCache[s]}if(void 0===a)switch(O.dataType){case t.e.ANIMATIONTYPE_FLOAT:a=0;break;case t.e.ANIMATIONTYPE_QUATERNION:a=t.n;break;case t.e.ANIMATIONTYPE_VECTOR3:a=t.t;break;case t.e.ANIMATIONTYPE_VECTOR2:a=t.s;break;case t.e.ANIMATIONTYPE_SIZE:a=t.q;break;case t.e.ANIMATIONTYPE_COLOR3:a=t.i;break;case t.e.ANIMATIONTYPE_COLOR4:a=t.k}if(this._host&&this._host.syncRoot){const s=this._host.syncRoot;G=Z+D*((s.masterFrame-s.fromFrame)/(s.toFrame-s.fromFrame))}else G=v>0&&Z>o||v<0&&Z<o?B&&0!==D?o+v%D:Z:B&&0!==D?Z+v%D:o;if(!b&&(S>0&&this.currentFrame>G||S<0&&this.currentFrame<G)||b&&Y){this._onLoop();for(let s=0;s<Q.length;s++)Q[s].onlyOnce||(Q[s].isDone=!1);this._animationState.key=S>0?0:O.getKeys().length-1}this._currentFrame=G,this._animationState.repeatCount=0===D?0:v/D|0,this._animationState.highLimitValue=z,this._animationState.offsetValue=a}const z=O._interpolate(G,this._animationState);if(this.setValue(z,a),Q.length)for(let t=0;t<Q.length;t++)if(D>=0&&G>=Q[t].frame&&Q[t].frame>=Z||D<0&&G<=Q[t].frame&&Q[t].frame<=Z){const s=Q[t];s.isDone||(s.onlyOnce&&(Q.splice(t,1),t--),s.isDone=!0,s.action(G))}return B||(this._stopped=!0),B}}var B=o(10968);class Q{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(s){this._weight=-1!==s?Math.min(Math.max(s,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(s){for(let Z=0;Z<this._runtimeAnimations.length;Z++){this._runtimeAnimations[Z]._prepareForSpeedRatioChange(s)}this._speedRatio=s,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(s,Z){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,S=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,O=arguments.length>6?arguments[6]:void 0,v=arguments.length>7?arguments[7]:void 0,G=arguments.length>8?arguments[8]:void 0,B=arguments.length>9&&void 0!==arguments[9]&&arguments[9],Q=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=Z,this.fromFrame=o,this.toFrame=t,this.loopAnimation=S,this.onAnimationEnd=O,this.onAnimationLoop=G,this.isAdditive=B,this.playOrder=Q,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.ka=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new j.b,this.onAnimationLoopObservable=new j.b,this._scene=s,v&&this.appendAnimations(Z,v),this._speedRatio=a,s._activeAnimatables.push(this)}syncWith(s){if(this._syncRoot=s,s){const s=this._scene._activeAnimatables.indexOf(this);s>-1&&(this._scene._activeAnimatables.splice(s,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(s,Z){for(let o=0;o<Z.length;o++){const t=Z[o],j=new G(s,t,this._scene,this);j._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(j)}}getAnimationByTargetProperty(s){const Z=this._runtimeAnimations;for(let o=0;o<Z.length;o++)if(Z[o].animation.targetProperty===s)return Z[o].animation;return null}getRuntimeAnimationByTargetProperty(s){const Z=this._runtimeAnimations;for(let o=0;o<Z.length;o++)if(Z[o].animation.targetProperty===s)return Z[o];return null}reset(){const s=this._runtimeAnimations;for(let Z=0;Z<s.length;Z++)s[Z].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(s){const Z=this._runtimeAnimations;for(let o=0;o<Z.length;o++)Z[o].animation.enableBlending=!0,Z[o].animation.blendingSpeed=s}disableBlending(){const s=this._runtimeAnimations;for(let Z=0;Z<s.length;Z++)s[Z].animation.enableBlending=!1}goToFrame(s){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const o=this._runtimeAnimations;if(o[0]){const Z=o[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??o[0].currentFrame;const t=0===this.speedRatio?0:(s-this._frameToSyncFromJump)/Z*1e3/this.speedRatio;this._manualJumpDelay=-t}for(let t=0;t<o.length;t++)o[t].goToFrame(s,Z?this._weight:-1);this._goToFrame=s}get paused(){return this.ka}pause(){this.ka||(this.ka=!0)}restart(){this.ka=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(s,Z){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(s||Z){const j=this._scene._activeAnimatables.indexOf(this);if(j>-1){const S=this._runtimeAnimations;for(let o=S.length-1;o>=0;o--){const t=S[o];s&&t.animation.name!=s||(Z&&!Z(t.target)||(t.dispose(),S.splice(o,1)))}0==S.length&&(o||this._scene._activeAnimatables.splice(j,1),t||this._raiseOnAnimationEnd())}}else{const s=this._scene._activeAnimatables.indexOf(this);if(s>-1){o||this._scene._activeAnimatables.splice(s,1);const Z=this._runtimeAnimations;for(let s=0;s<Z.length;s++)Z[s].dispose();this._runtimeAnimations.length=0,t||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((s=>{this.onAnimationEndObservable.add((()=>{s(this)}),void 0,void 0,this,!0)}))}_animate(s){if(this.ka)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=s),!0;if(null===this._localDelayOffset?(this._localDelayOffset=s,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=s-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let Z=!1;const o=this._runtimeAnimations;let t;for(t=0;t<o.length;t++){const j=o[t].animate(s-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);Z=Z||j}if(this.animationStarted=Z,!Z){if(this.disposeOnEnd)for(t=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(t,1),t=0;t<o.length;t++)o[t].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return Z}}function D(s){if(0===s.totalWeight&&0===s.totalAdditiveWeight)return s.originalValue;let Z=1;const o=v.g.sO[0],t=v.g.sO[1],j=v.g.Quaternion[0];let S=0;const a=s.animations[0],O=s.originalValue;let G=1,B=!1;if(s.totalWeight<1)G=1-s.totalWeight,O.decompose(t,j,o);else{if(S=1,Z=s.totalWeight,G=a.weight/Z,1==G){if(!s.totalAdditiveWeight)return a.currentValue;B=!0}a.currentValue.decompose(t,j,o)}if(!B){t.scaleInPlace(G),o.scaleInPlace(G),j.scaleInPlace(G);for(let a=S;a<s.animations.length;a++){const S=s.animations[a];if(0===S.weight)continue;G=S.weight/Z;const O=v.g.sO[2],B=v.g.sO[3],Q=v.g.Quaternion[1];S.currentValue.decompose(B,Q,O),B.scaleAndAddToRef(G,t),Q.scaleAndAddToRef(v.e.Dot(j,Q)>0?G:-G,j),O.scaleAndAddToRef(G,o)}j.normalize()}for(let D=0;D<s.additiveAnimations.length;D++){const Z=s.additiveAnimations[D];if(0===Z.weight)continue;const S=v.g.sO[2],a=v.g.sO[3],O=v.g.Quaternion[1];Z.currentValue.decompose(a,O,S),a.multiplyToRef(t,a),v.n.LerpToRef(t,a,Z.weight,t),j.multiplyToRef(O,O),v.e.SlerpToRef(j,O,Z.weight,j),S.scaleAndAddToRef(Z.weight,o)}const Q=a?a._animationState.workValue:v.g.Matrix[0].clone();return v.b.ComposeToRef(t,j,o,Q),Q}function z(s,Z){if(0===s.totalWeight&&0===s.totalAdditiveWeight)return Z;const o=s.animations[0],t=s.originalValue;let j=Z;if(0===s.totalWeight&&s.totalAdditiveWeight>0)j.O(t);else if(1===s.animations.length){if(v.e.SlerpToRef(t,o.currentValue,Math.min(1,s.totalWeight),j),0===s.totalAdditiveWeight)return j}else if(s.animations.length>1){let o,S,a=1;if(s.totalWeight<1){const Z=1-s.totalWeight;o=[],S=[],o.push(t),S.push(Z)}else{if(2===s.animations.length&&(v.e.SlerpToRef(s.animations[0].currentValue,s.animations[1].currentValue,s.animations[1].weight/s.totalWeight,Z),0===s.totalAdditiveWeight))return Z;o=[],S=[],a=s.totalWeight}for(let Z=0;Z<s.animations.length;Z++){const t=s.animations[Z];o.push(t.currentValue),S.push(t.weight/a)}let O=0;for(let s=0;s<o.length;)s?(O+=S[s],v.e.SlerpToRef(j,o[s],S[s]/O,j),s++):(v.e.SlerpToRef(o[s],o[s+1],S[s+1]/(S[s]+S[s+1]),Z),j=Z,O=S[s]+S[s+1],s+=2)}for(let S=0;S<s.additiveAnimations.length;S++){const Z=s.additiveAnimations[S];0!==Z.weight&&(j.multiplyToRef(Z.currentValue,v.g.Quaternion[0]),v.e.SlerpToRef(j,v.g.Quaternion[0],Z.weight,j))}return j}var Y,b,f=o(11493);Y=f.c,(b=O.c)&&(b.prototype.copyAnimationRange=function(s,Z,o){let j=arguments.length>3&&void 0!==arguments[3]&&arguments[3],S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new t.e(this.name,"_matrix",s.animations[0].framePerSecond,t.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const a=s.animations[0].getRange(Z);if(!a)return!1;const O=a.from,v=a.to,G=s.animations[0].getKeys(),B=s.length,Q=s.getParent(),D=this.getParent(),z=j&&Q&&B&&this.length&&B!==this.length,Y=z&&D&&Q?D.length/Q.length:1,b=j&&!D&&S&&(1!==S.x||1!==S.y||1!==S.z),f=this.animations[0].getKeys();let A,d,U;for(let t=0,u=G.length;t<u;t++)A=G[t],A.frame>=O&&A.frame<=v&&(j?(U=A.value.clone(),z?(d=U.getTranslation(),U.setTranslation(d.scaleInPlace(Y))):b&&S?(d=U.getTranslation(),U.setTranslation(d.multiplyInPlace(S))):U=A.value):U=A.value,f.push({frame:A.frame+o,value:U}));return this.animations[0].createRange(Z,O+o,v+o),!0}),Y&&(Y.prototype._animate=function(s){if(!this.animationsEnabled)return;const Z=B.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=Z}this.deltaTime=void 0!==s?s:this.useConstantAnimationDeltaTime?16:(Z-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=Z;const o=this._activeAnimatables;if(0===o.length)return;this._animationTime+=this.deltaTime;const j=this._animationTime;for(let t=0;t<o.length;t++){const s=o[t];!s._animate(j)&&s.disposeOnEnd&&t--}!function(s){if(s._registeredForLateAnimationBindings.length){for(let Z=0;Z<s._registeredForLateAnimationBindings.length;Z++){const o=s._registeredForLateAnimationBindings.data[Z];for(const s in o._lateAnimationHolders){const Z=o._lateAnimationHolders[s],j=Z.animations[0],S=Z.originalValue;if(void 0===S||null===S)continue;const a=t.e.AllowMatrixDecomposeForInterpolation&&S.m;let O=o[s];if(a)O=D(Z);else if(void 0!==S.w)O=z(Z,O||v.e.Identity());else{let s=0,o=1;const a=j&&j._animationState.loopMode===t.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(Z.totalWeight<1)O=a?S.clone?S.clone():S:j&&S.scale?S.scale(1-Z.totalWeight):j?S*(1-Z.totalWeight):S.clone?S.clone():S;else if(j){o=Z.totalWeight;const t=j.weight/o;O=1!==t?j.currentValue.scale?j.currentValue.scale(t):j.currentValue*t:j.currentValue,a&&(O.addToRef?O.addToRef(S,O):O+=S),s=1}for(let t=s;t<Z.animations.length;t++){const s=Z.animations[t],j=s.weight/o;j&&(s.currentValue.scaleAndAddToRef?s.currentValue.scaleAndAddToRef(j,O):O+=s.currentValue*j)}for(let t=0;t<Z.additiveAnimations.length;t++){const s=Z.additiveAnimations[t],o=s.weight;o&&(s.currentValue.scaleAndAddToRef?s.currentValue.scaleAndAddToRef(o,O):O+=s.currentValue*o)}}o[s]=O}o._lateAnimationHolders={}}s._registeredForLateAnimationBindings.reset()}}(this)},Y.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((s,Z)=>s.playOrder-Z.playOrder))},Y.prototype.beginWeightedAnimation=function(s,Z,o){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,j=arguments.length>4?arguments[4]:void 0,S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,a=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,v=arguments.length>8?arguments[8]:void 0,G=arguments.length>9?arguments[9]:void 0,B=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const Q=this.beginAnimation(s,Z,o,j,S,a,O,!1,v,G,B);return Q.weight=t,Q},Y.prototype.beginAnimation=function(s,Z,o,t){let j=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,S=arguments.length>5?arguments[5]:void 0,a=arguments.length>6?arguments[6]:void 0,O=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],v=arguments.length>8?arguments[8]:void 0,G=arguments.length>9?arguments[9]:void 0,B=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(j<0){const s=Z;Z=o,o=s,j=-j}Z>o&&(j=-j),O&&this.stopAnimation(s,void 0,v),a||(a=new Q(this,s,Z,o,t,j,S,void 0,G,B));const D=!v||v(s);if(s.animations&&D&&a.appendAnimations(s,s.animations),s.getAnimatables){const B=s.getAnimatables();for(let s=0;s<B.length;s++)this.beginAnimation(B[s],Z,o,t,j,S,a,O,v,G)}return a.reset(),a},Y.prototype.beginHierarchyAnimation=function(s,Z,o,t,j){let S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,a=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,v=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],G=arguments.length>9?arguments[9]:void 0,B=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const Q=s.getDescendants(Z),D=[];D.push(this.beginAnimation(s,o,t,j,S,a,O,v,G,void 0,B));for(const z of Q)D.push(this.beginAnimation(z,o,t,j,S,a,O,v,G,void 0,B));return D},Y.prototype.beginDirectAnimation=function(s,Z,o,t,j){let S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(S<0){const s=o;o=t,t=s,S=-S}return o>t&&(S=-S),new Q(this,s,o,t,j,S,arguments.length>6?arguments[6]:void 0,Z,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},Y.prototype.beginDirectHierarchyAnimation=function(s,Z,o,t,j,S,a,O,v){let G=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const B=s.getDescendants(Z),Q=[];Q.push(this.beginDirectAnimation(s,o,t,j,S,a,O,v,G));for(const D of B)Q.push(this.beginDirectAnimation(D,o,t,j,S,a,O,v,G));return Q},Y.prototype.getAnimatableByTarget=function(s){for(let Z=0;Z<this._activeAnimatables.length;Z++)if(this._activeAnimatables[Z].target===s)return this._activeAnimatables[Z];return null},Y.prototype.getAllAnimatablesByTarget=function(s){const Z=[];for(let o=0;o<this._activeAnimatables.length;o++)this._activeAnimatables[o].target===s&&Z.push(this._activeAnimatables[o]);return Z},Y.prototype.stopAnimation=function(s,Z,o){const t=this.getAllAnimatablesByTarget(s);for(const j of t)j.stop(Z,o)},Y.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let s=0;s<this._activeAnimatables.length;s++)this._activeAnimatables[s].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const s of this.animationGroups)s.stop()});class A{getClassName(){return"TargetedAnimation"}serialize(){const s={};return s.animation=this.animation.serialize(),s.targetId=this.target.id,s}}class d{get mask(){return this._mask}set mask(s){this._mask!==s&&(this._mask=s,this.syncWithMask(!0))}syncWithMask(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||s){this._numActiveAnimatables=0;for(let s=0;s<this._animatables.length;++s){const Z=this._animatables[s];!this.mask||this.mask.disabled||this.mask.retainsTarget(Z.target.name)?(this._numActiveAnimatables++,Z.paused&&Z.restart()):Z.paused||Z.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let s=0;s<this._animatables.length;++s){const Z=this._animatables[s];this.mask.retainsTarget(Z.target.name)||(Z.stop(),this._animatables.splice(s,1),--s)}for(let s=0;s<this._targetedAnimations.length;s++){const Z=this._targetedAnimations[s];this.mask.retainsTarget(Z.target.name)||(this._targetedAnimations.splice(s,1),--s)}}}get from(){return this._from}set from(s){if(this._from!==s){this._from=s;for(let s=0;s<this._animatables.length;s++){this._animatables[s].fromFrame=this._from}}}get to(){return this._to}set to(s){if(this._to!==s){this._to=s;for(let s=0;s<this._animatables.length;s++){this._animatables[s].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(s){if(this._speedRatio!==s){this._speedRatio=s;for(let s=0;s<this._animatables.length;s++){this._animatables[s].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(s){if(this._loopAnimation!==s){this._loopAnimation=s;for(let s=0;s<this._animatables.length;s++){this._animatables[s].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(s){if(this._isAdditive!==s){this._isAdditive=s;for(let s=0;s<this._animatables.length;s++){this._animatables[s].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(s){this._weight!==s&&(this._weight=s,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(s){if(this._playOrder!==s&&(this._playOrder=s,this._animatables.length>0)){for(let s=0;s<this._animatables.length;s++)this._animatables[s].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(s){if(this._enableBlending!==s&&(this._enableBlending=s,null!==s))for(let Z=0;Z<this._targetedAnimations.length;++Z)this._targetedAnimations[Z].animation.enableBlending=s}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(s){if(this._blendingSpeed!==s&&(this._blendingSpeed=s,null!==s))for(let Z=0;Z<this._targetedAnimations.length;++Z)this._targetedAnimations[Z].animation.blendingSpeed=s}getLength(s,Z){s=s??this._from;return((Z=Z??this._to)-s)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(s){let Z=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=arguments.length>3?arguments[3]:void 0;if(0===s.length)return null;t=t??s[0].weight;let j=Number.MAX_VALUE,S=-Number.MAX_VALUE;if(o)for(const O of s)O.from<j&&(j=O.from),O.to>S&&(S=O.to);const a=new d(s[0].name+"_merged",s[0]._scene,t);for(const O of s){o&&O.normalize(j,S);for(const s of O.targetedAnimations)a.addTargetedAnimation(s.animation,s.target);Z&&O.dispose()}return a}constructor(s){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=s,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new j.b,this.onAnimationLoopObservable=new j.b,this.onAnimationGroupLoopObservable=new j.b,this.onAnimationGroupEndObservable=new j.b,this.onAnimationGroupPauseObservable=new j.b,this.onAnimationGroupPlayObservable=new j.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=Z||S.c.LastCreatedScene,this._weight=o,this._playOrder=t,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(s,Z){const o=new A;o.animation=s,o.target=Z;const t=s.getKeys();return this._from>t[0].frame&&(this._from=t[0].frame),this._to<t[t.length-1].frame&&(this._to=t[t.length-1].frame),null!==this._enableBlending&&(s.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(s.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(o),this._shouldStart=!0,o}removeTargetedAnimation(s){for(let Z=this._targetedAnimations.length-1;Z>-1;Z--){this._targetedAnimations[Z].animation===s&&this._targetedAnimations.splice(Z,1)}}normalize(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==s&&(s=this._from),null==Z&&(Z=this._to);for(let o=0;o<this._targetedAnimations.length;o++){const t=this._targetedAnimations[o].animation.getKeys(),j=t[0],S=t[t.length-1];if(j.frame>s){const Z={frame:s,value:j.value,inTangent:j.inTangent,outTangent:j.outTangent,interpolation:j.interpolation};t.splice(0,0,Z)}if(S.frame<Z){const s={frame:Z,value:S.value,inTangent:S.inTangent,outTangent:S.outTangent,interpolation:S.interpolation};t.push(s)}}return this._from=s,this._to=Z,this}_processLoop(s,Z,o){s.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(Z),this._animationLoopFlags[o]||(this._animationLoopFlags[o]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0],Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments.length>2?arguments[2]:void 0,t=arguments.length>3?arguments[3]:void 0,j=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=s,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let S=0;S<this._targetedAnimations.length;S++){const a=this._targetedAnimations[S],O=this._scene.beginDirectAnimation(a.target,[a.animation],void 0!==o?o:this._from,void 0!==t?t:this._to,s,Z,void 0,void 0,void 0!==j?j:this._isAdditive);O.weight=this._weight,O.playOrder=this._playOrder,O.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(a),this._checkAnimationGroupEnded(O)},this._processLoop(O,a,S),this._animatables.push(O)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=Z,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let s=0;s<this._animatables.length;s++){this._animatables[s].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(s){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==s&&(this.loopAnimation=s),this.restart()):(this.stop(),this.start(s,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let s=0;s<this._animatables.length;s++){this._animatables[s].reset()}return this}restart(){if(!this._isStarted)return this;for(let s=0;s<this._animatables.length;s++){this._animatables[s].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const Z=this._animatables.slice();for(let t=0;t<Z.length;t++)Z[t].stop(void 0,void 0,!0,s);let o=0;for(let t=0;t<this._scene._activeAnimatables.length;t++){const Z=this._scene._activeAnimatables[t];Z._runtimeAnimations.length>0?this._scene._activeAnimatables[o++]=Z:s&&this._checkAnimationGroupEnded(Z,s)}return this._scene._activeAnimatables.length=o,this._isStarted=!1,this}setWeightForAllAnimatables(s){for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].weight=s}return this}syncAllAnimationsWith(s){for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].syncWith(s)}return this}goToFrame(s){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let o=0;o<this._animatables.length;o++){this._animatables[o].goToFrame(s,Z)}return this}getCurrentFrame(){var s;return(null===(s=this.animatables[0])||void 0===s?void 0:s.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const s=this._scene.animationGroups.indexOf(this);if(s>-1&&this._scene.animationGroups.splice(s,1),this._parentContainer){const s=this._parentContainer.animationGroups.indexOf(this);s>-1&&this._parentContainer.animationGroups.splice(s,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(s){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const o=this._animatables.indexOf(s);o>-1&&this._animatables.splice(o,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,Z||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(s,Z){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=new d(s||this.name,this._scene,this._weight,this._playOrder);t._from=this.from,t._to=this.to,t._speedRatio=this.speedRatio,t._loopAnimation=this.loopAnimation,t._isAdditive=this.isAdditive,t._enableBlending=this.enableBlending,t._blendingSpeed=this.blendingSpeed,t.metadata=this.metadata,t.mask=this.mask;for(const j of this._targetedAnimations)t.addTargetedAnimation(o?j.animation.clone():j.animation,Z?Z(j.target):j.target);return t}serialize(){const s={};s.name=this.name,s.from=this.from,s.to=this.to,s.speedRatio=this.speedRatio,s.loopAnimation=this.loopAnimation,s.isAdditive=this.isAdditive,s.weight=this.weight,s.playOrder=this.playOrder,s.enableBlending=this.enableBlending,s.blendingSpeed=this.blendingSpeed,s.targetedAnimations=[];for(let Z=0;Z<this.targetedAnimations.length;Z++){const o=this.targetedAnimations[Z];s.targetedAnimations[Z]=o.serialize()}return a.b&&a.b.HasTags(this)&&(s.tags=a.b.GetTags(this)),this.metadata&&(s.metadata=this.metadata),s}static Parse(s,Z){const o=new d(s.name,Z,s.weight,s.playOrder);for(let j=0;j<s.targetedAnimations.length;j++){const S=s.targetedAnimations[j],a=t.e.Parse(S.animation),O=S.targetId;if("influence"===S.animation.property){const s=Z.getMorphTargetById(O);s&&o.addTargetedAnimation(a,s)}else{const s=Z.getNodeById(O);null!=s&&o.addTargetedAnimation(a,s)}}return a.b&&a.b.AddTagsTo(o,s.tags),null!==s.from&&null!==s.to&&o.normalize(s.from,s.to),void 0!==s.speedRatio&&(o._speedRatio=s.speedRatio),void 0!==s.loopAnimation&&(o._loopAnimation=s.loopAnimation),void 0!==s.isAdditive&&(o._isAdditive=s.isAdditive),void 0!==s.weight&&(o._weight=s.weight),void 0!==s.playOrder&&(o._playOrder=s.playOrder),void 0!==s.enableBlending&&(o._enableBlending=s.enableBlending),void 0!==s.blendingSpeed&&(o._blendingSpeed=s.blendingSpeed),void 0!==s.metadata&&(o.metadata=s.metadata),o}static MakeAnimationAdditive(s,Z,o){let j;j="object"===typeof Z?Z:{referenceFrame:Z,range:o,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let S=s;j.cloneOriginalAnimationGroup&&(S=s.clone(j.clonedAnimationGroupName||S.name));const a=S.targetedAnimations;for(let O=0;O<a.length;O++){const s=a[O];s.animation=t.e.MakeAnimationAdditive(s.animation,j)}if(S.isAdditive=!0,j.clipKeys){let s=Number.MAX_VALUE,Z=-Number.MAX_VALUE;const o=S.targetedAnimations;for(let t=0;t<o.length;t++){const j=o[t].animation.getKeys();s>j[0].frame&&(s=j[0].frame),Z<j[j.length-1].frame&&(Z=j[j.length-1].frame)}S._from=s,S._to=Z}return S}static ClipKeys(s,Z,o,t,j){const S=s.clone(t||s.name);return d.ClipKeysInPlace(S,Z,o,j)}static ClipKeysInPlace(s,Z,o,t){return d.ClipInPlace(s,Z,o,t,!1)}static ClipFrames(s,Z,o,t,j){const S=s.clone(t||s.name);return d.ClipFramesInPlace(S,Z,o,j)}static ClipFramesInPlace(s,Z,o,t){return d.ClipInPlace(s,Z,o,t,!0)}static ClipInPlace(s,Z,o,t){let j=arguments.length>4&&void 0!==arguments[4]&&arguments[4],S=Number.MAX_VALUE,a=-Number.MAX_VALUE;const O=s.targetedAnimations;for(let v=0;v<O.length;v++){const s=O[v],G=t?s.animation:s.animation.clone();j&&(G.createKeyForFrame(Z),G.createKeyForFrame(o));const B=G.getKeys(),Q=[];let D=Number.MAX_VALUE;for(let t=0;t<B.length;t++){const s=B[t];if(!j&&t>=Z&&t<=o||j&&s.frame>=Z&&s.frame<=o){const Z={frame:s.frame,value:s.value.clone?s.value.clone():s.value,inTangent:s.inTangent,outTangent:s.outTangent,interpolation:s.interpolation,lockedTangent:s.lockedTangent};D===Number.MAX_VALUE&&(D=Z.frame),Z.frame-=D,Q.push(Z)}}0!==Q.length?(S>Q[0].frame&&(S=Q[0].frame),a<Q[Q.length-1].frame&&(a=Q[Q.length-1].frame),G.setKeys(Q,!0),s.animation=G):(O.splice(v,1),v--)}return s._from=S,s._to=a,s}getClassName(){return"AnimationGroup"}toString(s){let Z="Name: "+this.name;return Z+=", type: "+this.getClassName(),s&&(Z+=", from: "+this._from,Z+=", to: "+this._to,Z+=", isStarted: "+this._isStarted,Z+=", speedRatio: "+this._speedRatio,Z+=", targetedAnimations length: "+this._targetedAnimations.length,Z+=", animatables length: "+this._animatables),Z}}}}]);