"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[58],{14477:(G,V,W)=>{W.r(V),W.d(V,{AnimationGroup:()=>S,TargetedAnimation:()=>B});var J=W(11847),R=W(11176),d=W(11169),k=W(11416),z=W(12987),X=W(11136);class P{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(G,V,W,R){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=V,this._target=G,this._scene=W,this._host=R,this._activeTargets=[],V._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===J.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=X.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const G={frame:0,value:this._minValue};this._keys.splice(0,0,G)}if(this._target instanceof Array){let G=0;for(const V of this._target)this._preparePath(V,G),this._getOriginalValues(G),G++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const d=V.getEvents();if(d&&d.length>0)for(const J of d)this._events.push(J._clone());this._enableBlending=G&&G.animationPropertiesOverride?G.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(G){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const W=this._animation.targetPropertyPath;if(W.length>1){let J=G;for(let G=0;G<W.length-1;G++){const V=W[G];if(J=J[V],void 0===J)throw new Error(`Invalid property (${V}) in property path (${W.join(".")})`)}this._targetPath=W[W.length-1],this._activeTargets[V]=J}else this._targetPath=W[0],this._activeTargets[V]=G;if(void 0===this._activeTargets[V][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${W.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let G=0;for(const V of this._target)void 0!==this._originalValue[G]&&this._setValue(V,this._activeTargets[G],this._originalValue[G],-1,G),G++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let G=0;G<this._events.length;G++)this._events[G].isDone=!1}isStopped(){return this._stopped}dispose(){const G=this._animation.runtimeAnimations.indexOf(this);G>-1&&this._animation.runtimeAnimations.splice(G,1)}setValue(G,V){if(this._targetIsArray)for(let W=0;W<this._target.length;W++){const J=this._target[W];this._setValue(J,this._activeTargets[W],G,V,W)}else this._setValue(this._target,this._directTarget,G,V,0)}_getOriginalValues(){let G,V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const W=this._activeTargets[V];G=W.getLocalMatrix&&"_matrix"===this._targetPath?W.getLocalMatrix():W[this._targetPath],G&&G.clone?this._originalValue[V]=G.clone():this._originalValue[V]=G}_registerTargetForLateAnimationBinding(G,V){const W=G.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(W),W._lateAnimationHolders||(W._lateAnimationHolders={}),W._lateAnimationHolders[G.targetPath]||(W._lateAnimationHolders[G.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:V}),G.isAdditive?(W._lateAnimationHolders[G.targetPath].additiveAnimations.push(G),W._lateAnimationHolders[G.targetPath].totalAdditiveWeight+=G.weight):(W._lateAnimationHolders[G.targetPath].animations.push(G),W._lateAnimationHolders[G.targetPath].totalWeight+=G.weight)}_setValue(G,V,W,R,d){if(this._currentActiveTarget=V,this._weight=R,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const G=V[this._targetPath];G.clone?this._originalBlendValue=G.clone():this._originalBlendValue=G}this._originalBlendValue.m?J.e.AllowMatrixDecomposeForInterpolation?this._currentValue?X.c.DecomposeLerpToRef(this._originalBlendValue,W,this._blendingFactor,this._currentValue):this._currentValue=X.c.DecomposeLerp(this._originalBlendValue,W,this._blendingFactor):this._currentValue?X.c.LerpToRef(this._originalBlendValue,W,this._blendingFactor,this._currentValue):this._currentValue=X.c.Lerp(this._originalBlendValue,W,this._blendingFactor):this._currentValue=J.e._UniversalLerp(this._originalBlendValue,W,this._blendingFactor);const R=G&&G.animationPropertiesOverride?G.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=R}else this._currentValue?this._currentValue.J?this._currentValue.J(W):this._currentValue=W:null!==W&&void 0!==W&&W.clone?this._currentValue=W.clone():this._currentValue=W;-1!==R?this._registerTargetForLateAnimationBinding(this,this._originalValue[d]):this._animationState.loopMode===J.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[d],V[this._targetPath]):V[this._targetPath]=this._originalValue[d]+this._currentValue:V[this._targetPath]=this._currentValue,G.pP&&G.pP(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(G){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const W=this._animation.getKeys();G<W[0].frame?G=W[0].frame:G>W[W.length-1].frame&&(G=W[W.length-1].frame);const J=this._events;if(J.length)for(let d=0;d<J.length;d++)J[d].onlyOnce||(J[d].isDone=J[d].frame<G);this._currentFrame=G;const R=this._animation._interpolate(G,this._animationState);this.setValue(R,V)}_prepareForSpeedRatioChange(G){const V=this._previousElapsedTime*(this._animation.framePerSecond*G)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-V}animate(G,V,W,R,d){let k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const z=this._animation,X=z.targetPropertyPath;if(!X||X.length<1)return this._stopped=!0,!1;let P,A=!0;const x=this._events;let q=0;if(this._coreRuntimeAnimation)q=W-V,P=this._coreRuntimeAnimation.currentFrame,this._currentFrame=P,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let k;(V<this._minFrame||V>this._maxFrame)&&(V=this._minFrame),(W<this._minFrame||W>this._maxFrame)&&(W=this._maxFrame),q=W-V;let X=G*(z.framePerSecond*d)/1e3+this._absoluteFrameOffset,L=0,t=!1;const Y=R&&this._animationState.loopMode===J.e.ANIMATIONLOOPMODE_YOYO;if(Y){const G=(X-V)/q,W=Math.sin(G*Math.PI);X=Math.abs(W)*q+V;const J=W>=0?1:-1;this._yoyoDirection!==J&&(t=!0),this._yoyoDirection=J}if(this._previousElapsedTime=G,this._previousAbsoluteFrame=X,!R&&W>=V&&(X>=q&&d>0||X<=0&&d<0))A=!1,L=z._getKeyValue(this._maxValue);else if(!R&&V>=W&&(X<=q&&d<0||X>=0&&d>0))A=!1,L=z._getKeyValue(this._minValue);else if(this._animationState.loopMode!==J.e.ANIMATIONLOOPMODE_CYCLE){const G=W.toString()+V.toString();if(!this._offsetsCache[G]){this._animationState.repeatCount=0,this._animationState.loopMode=J.e.ANIMATIONLOOPMODE_CYCLE;const R=z._interpolate(V,this._animationState),d=z._interpolate(W,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),z.dataType){case J.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[G]=d-R;break;case J.e.ANIMATIONTYPE_QUATERNION:case J.e.ANIMATIONTYPE_VECTOR3:case J.e.ANIMATIONTYPE_VECTOR2:case J.e.ANIMATIONTYPE_SIZE:case J.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[G]=d.zW(R)}this._highLimitsCache[G]=d}L=this._highLimitsCache[G],k=this._offsetsCache[G]}if(void 0===k)switch(z.dataType){case J.e.ANIMATIONTYPE_FLOAT:k=0;break;case J.e.ANIMATIONTYPE_QUATERNION:k=J.k;break;case J.e.ANIMATIONTYPE_VECTOR3:k=J.o;break;case J.e.ANIMATIONTYPE_VECTOR2:k=J.m;break;case J.e.ANIMATIONTYPE_SIZE:k=J.l;break;case J.e.ANIMATIONTYPE_COLOR3:k=J.g;break;case J.e.ANIMATIONTYPE_COLOR4:k=J.h}if(this._host&&this._host.syncRoot){const G=this._host.syncRoot;P=V+q*((G.masterFrame-G.fromFrame)/(G.toFrame-G.fromFrame))}else P=X>0&&V>W||X<0&&V<W?A&&0!==q?W+X%q:V:A&&0!==q?V+X%q:W;if(!Y&&(d>0&&this.currentFrame>P||d<0&&this.currentFrame<P)||Y&&t){this._onLoop();for(let G=0;G<x.length;G++)x[G].onlyOnce||(x[G].isDone=!1);this._animationState.key=d>0?0:z.getKeys().length-1}this._currentFrame=P,this._animationState.repeatCount=0===q?0:X/q|0,this._animationState.highLimitValue=L,this._animationState.offsetValue=k}const L=z._interpolate(P,this._animationState);if(this.setValue(L,k),x.length)for(let J=0;J<x.length;J++)if(q>=0&&P>=x[J].frame&&x[J].frame>=V||q<0&&P<=x[J].frame&&x[J].frame<=V){const G=x[J];G.isDone||(G.onlyOnce&&(x.splice(J,1),J--),G.isDone=!0,G.action(P))}return A||(this._stopped=!0),A}}var A=W(11211);class x{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(G){this._weight=-1!==G?Math.min(Math.max(G,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(G){for(let V=0;V<this._runtimeAnimations.length;V++){this._runtimeAnimations[V]._prepareForSpeedRatioChange(G)}this._speedRatio=G,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(G,V){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,d=arguments.length>4&&void 0!==arguments[4]&&arguments[4],k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,z=arguments.length>6?arguments[6]:void 0,X=arguments.length>7?arguments[7]:void 0,P=arguments.length>8?arguments[8]:void 0,A=arguments.length>9&&void 0!==arguments[9]&&arguments[9],x=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=V,this.fromFrame=W,this.toFrame=J,this.loopAnimation=d,this.onAnimationEnd=z,this.onAnimationLoop=P,this.isAdditive=A,this.playOrder=x,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.dz=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new R.b,this.onAnimationLoopObservable=new R.b,this._scene=G,X&&this.appendAnimations(V,X),this._speedRatio=k,G._activeAnimatables.push(this)}syncWith(G){if(this._syncRoot=G,G){const G=this._scene._activeAnimatables.indexOf(this);G>-1&&(this._scene._activeAnimatables.splice(G,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(G,V){for(let W=0;W<V.length;W++){const J=V[W],R=new P(G,J,this._scene,this);R._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(R)}}getAnimationByTargetProperty(G){const V=this._runtimeAnimations;for(let W=0;W<V.length;W++)if(V[W].animation.targetProperty===G)return V[W].animation;return null}getRuntimeAnimationByTargetProperty(G){const V=this._runtimeAnimations;for(let W=0;W<V.length;W++)if(V[W].animation.targetProperty===G)return V[W];return null}reset(){const G=this._runtimeAnimations;for(let V=0;V<G.length;V++)G[V].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(G){const V=this._runtimeAnimations;for(let W=0;W<V.length;W++)V[W].animation.enableBlending=!0,V[W].animation.blendingSpeed=G}disableBlending(){const G=this._runtimeAnimations;for(let V=0;V<G.length;V++)G[V].animation.enableBlending=!1}goToFrame(G){let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const W=this._runtimeAnimations;if(W[0]){const V=W[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??W[0].currentFrame;const J=0===this.speedRatio?0:(G-this._frameToSyncFromJump)/V*1e3/this.speedRatio;this._manualJumpDelay=-J}for(let J=0;J<W.length;J++)W[J].goToFrame(G,V?this._weight:-1);this._goToFrame=G}get paused(){return this.dz}pause(){this.dz||(this.dz=!0)}restart(){this.dz=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(G,V){let W=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(G||V){const R=this._scene._activeAnimatables.indexOf(this);if(R>-1){const d=this._runtimeAnimations;for(let W=d.length-1;W>=0;W--){const J=d[W];G&&J.animation.name!=G||(V&&!V(J.target)||(J.dispose(),d.splice(W,1)))}0==d.length&&(W||this._scene._activeAnimatables.splice(R,1),J||this._raiseOnAnimationEnd())}}else{const G=this._scene._activeAnimatables.indexOf(this);if(G>-1){W||this._scene._activeAnimatables.splice(G,1);const V=this._runtimeAnimations;for(let G=0;G<V.length;G++)V[G].dispose();this._runtimeAnimations.length=0,J||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((G=>{this.onAnimationEndObservable.add((()=>{G(this)}),void 0,void 0,this,!0)}))}_animate(G){if(this.dz)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=G),!0;if(null===this._localDelayOffset?(this._localDelayOffset=G,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=G-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let V=!1;const W=this._runtimeAnimations;let J;for(J=0;J<W.length;J++){const R=W[J].animate(G-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);V=V||R}if(this.animationStarted=V,!V){if(this.disposeOnEnd)for(J=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(J,1),J=0;J<W.length;J++)W[J].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return V}}function q(G){if(0===G.totalWeight&&0===G.totalAdditiveWeight)return G.originalValue;let V=1;const W=X.h.ed[0],J=X.h.ed[1],R=X.h.Quaternion[0];let d=0;const k=G.animations[0],z=G.originalValue;let P=1,A=!1;if(G.totalWeight<1)P=1-G.totalWeight,z.decompose(J,R,W);else{if(d=1,V=G.totalWeight,P=k.weight/V,1==P){if(!G.totalAdditiveWeight)return k.currentValue;A=!0}k.currentValue.decompose(J,R,W)}if(!A){J.scaleInPlace(P),W.scaleInPlace(P),R.scaleInPlace(P);for(let k=d;k<G.animations.length;k++){const d=G.animations[k];if(0===d.weight)continue;P=d.weight/V;const z=X.h.ed[2],A=X.h.ed[3],x=X.h.Quaternion[1];d.currentValue.decompose(A,x,z),A.scaleAndAddToRef(P,J),x.scaleAndAddToRef(X.g.Dot(R,x)>0?P:-P,R),z.scaleAndAddToRef(P,W)}R.normalize()}for(let q=0;q<G.additiveAnimations.length;q++){const V=G.additiveAnimations[q];if(0===V.weight)continue;const d=X.h.ed[2],k=X.h.ed[3],z=X.h.Quaternion[1];V.currentValue.decompose(k,z,d),k.multiplyToRef(J,k),X.o.LerpToRef(J,k,V.weight,J),R.multiplyToRef(z,z),X.g.SlerpToRef(R,z,V.weight,R),d.scaleAndAddToRef(V.weight,W)}const x=k?k._animationState.workValue:X.h.Matrix[0].clone();return X.c.ComposeToRef(J,R,W,x),x}function L(G,V){if(0===G.totalWeight&&0===G.totalAdditiveWeight)return V;const W=G.animations[0],J=G.originalValue;let R=V;if(0===G.totalWeight&&G.totalAdditiveWeight>0)R.J(J);else if(1===G.animations.length){if(X.g.SlerpToRef(J,W.currentValue,Math.min(1,G.totalWeight),R),0===G.totalAdditiveWeight)return R}else if(G.animations.length>1){let W,d,k=1;if(G.totalWeight<1){const V=1-G.totalWeight;W=[],d=[],W.push(J),d.push(V)}else{if(2===G.animations.length&&(X.g.SlerpToRef(G.animations[0].currentValue,G.animations[1].currentValue,G.animations[1].weight/G.totalWeight,V),0===G.totalAdditiveWeight))return V;W=[],d=[],k=G.totalWeight}for(let V=0;V<G.animations.length;V++){const J=G.animations[V];W.push(J.currentValue),d.push(J.weight/k)}let z=0;for(let G=0;G<W.length;)G?(z+=d[G],X.g.SlerpToRef(R,W[G],d[G]/z,R),G++):(X.g.SlerpToRef(W[G],W[G+1],d[G+1]/(d[G]+d[G+1]),V),R=V,z=d[G]+d[G+1],G+=2)}for(let d=0;d<G.additiveAnimations.length;d++){const V=G.additiveAnimations[d];0!==V.weight&&(R.multiplyToRef(V.currentValue,X.h.Quaternion[0]),X.g.SlerpToRef(R,X.h.Quaternion[0],V.weight,R))}return R}var t,Y,g=W(11737);t=g.e,(Y=z.b)&&(Y.prototype.copyAnimationRange=function(G,V,W){let R=arguments.length>3&&void 0!==arguments[3]&&arguments[3],d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new J.e(this.name,"_matrix",G.animations[0].framePerSecond,J.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const k=G.animations[0].getRange(V);if(!k)return!1;const z=k.from,X=k.to,P=G.animations[0].getKeys(),A=G.length,x=G.getParent(),q=this.getParent(),L=R&&x&&A&&this.length&&A!==this.length,t=L&&q&&x?q.length/x.length:1,Y=R&&!q&&d&&(1!==d.x||1!==d.y||1!==d.z),g=this.animations[0].getKeys();let B,S,p;for(let J=0,b=P.length;J<b;J++)B=P[J],B.frame>=z&&B.frame<=X&&(R?(p=B.value.clone(),L?(S=p.getTranslation(),p.setTranslation(S.scaleInPlace(t))):Y&&d?(S=p.getTranslation(),p.setTranslation(S.multiplyInPlace(d))):p=B.value):p=B.value,g.push({frame:B.frame+W,value:p}));return this.animations[0].createRange(V,z+W,X+W),!0}),t&&(t.prototype._animate=function(G){if(!this.animationsEnabled)return;const V=A.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=V}this.deltaTime=void 0!==G?G:this.useConstantAnimationDeltaTime?16:(V-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=V;const W=this._activeAnimatables;if(0===W.length)return;this._animationTime+=this.deltaTime;const R=this._animationTime;for(let J=0;J<W.length;J++){const G=W[J];!G._animate(R)&&G.disposeOnEnd&&J--}!function(G){if(G._registeredForLateAnimationBindings.length){for(let V=0;V<G._registeredForLateAnimationBindings.length;V++){const W=G._registeredForLateAnimationBindings.data[V];for(const G in W._lateAnimationHolders){const V=W._lateAnimationHolders[G],R=V.animations[0],d=V.originalValue;if(void 0===d||null===d)continue;const k=J.e.AllowMatrixDecomposeForInterpolation&&d.m;let z=W[G];if(k)z=q(V);else if(void 0!==d.w)z=L(V,z||X.g.Identity());else{let G=0,W=1;const k=R&&R._animationState.loopMode===J.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(V.totalWeight<1)z=k?d.clone?d.clone():d:R&&d.scale?d.scale(1-V.totalWeight):R?d*(1-V.totalWeight):d.clone?d.clone():d;else if(R){W=V.totalWeight;const J=R.weight/W;z=1!==J?R.currentValue.scale?R.currentValue.scale(J):R.currentValue*J:R.currentValue,k&&(z.addToRef?z.addToRef(d,z):z+=d),G=1}for(let J=G;J<V.animations.length;J++){const G=V.animations[J],R=G.weight/W;R&&(G.currentValue.scaleAndAddToRef?G.currentValue.scaleAndAddToRef(R,z):z+=G.currentValue*R)}for(let J=0;J<V.additiveAnimations.length;J++){const G=V.additiveAnimations[J],W=G.weight;W&&(G.currentValue.scaleAndAddToRef?G.currentValue.scaleAndAddToRef(W,z):z+=G.currentValue*W)}}W[G]=z}W._lateAnimationHolders={}}G._registeredForLateAnimationBindings.reset()}}(this)},t.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((G,V)=>G.playOrder-V.playOrder))},t.prototype.beginWeightedAnimation=function(G,V,W){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,R=arguments.length>4?arguments[4]:void 0,d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,X=arguments.length>8?arguments[8]:void 0,P=arguments.length>9?arguments[9]:void 0,A=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const x=this.beginAnimation(G,V,W,R,d,k,z,!1,X,P,A);return x.weight=J,x},t.prototype.beginAnimation=function(G,V,W,J){let R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,d=arguments.length>5?arguments[5]:void 0,k=arguments.length>6?arguments[6]:void 0,z=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],X=arguments.length>8?arguments[8]:void 0,P=arguments.length>9?arguments[9]:void 0,A=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(R<0){const G=V;V=W,W=G,R=-R}V>W&&(R=-R),z&&this.stopAnimation(G,void 0,X),k||(k=new x(this,G,V,W,J,R,d,void 0,P,A));const q=!X||X(G);if(G.animations&&q&&k.appendAnimations(G,G.animations),G.getAnimatables){const A=G.getAnimatables();for(let G=0;G<A.length;G++)this.beginAnimation(A[G],V,W,J,R,d,k,z,X,P)}return k.reset(),k},t.prototype.beginHierarchyAnimation=function(G,V,W,J,R){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,k=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,X=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],P=arguments.length>9?arguments[9]:void 0,A=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const x=G.getDescendants(V),q=[];q.push(this.beginAnimation(G,W,J,R,d,k,z,X,P,void 0,A));for(const L of x)q.push(this.beginAnimation(L,W,J,R,d,k,z,X,P,void 0,A));return q},t.prototype.beginDirectAnimation=function(G,V,W,J,R){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(d<0){const G=W;W=J,J=G,d=-d}return W>J&&(d=-d),new x(this,G,W,J,R,d,arguments.length>6?arguments[6]:void 0,V,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},t.prototype.beginDirectHierarchyAnimation=function(G,V,W,J,R,d,k,z,X){let P=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const A=G.getDescendants(V),x=[];x.push(this.beginDirectAnimation(G,W,J,R,d,k,z,X,P));for(const q of A)x.push(this.beginDirectAnimation(q,W,J,R,d,k,z,X,P));return x},t.prototype.getAnimatableByTarget=function(G){for(let V=0;V<this._activeAnimatables.length;V++)if(this._activeAnimatables[V].target===G)return this._activeAnimatables[V];return null},t.prototype.getAllAnimatablesByTarget=function(G){const V=[];for(let W=0;W<this._activeAnimatables.length;W++)this._activeAnimatables[W].target===G&&V.push(this._activeAnimatables[W]);return V},t.prototype.stopAnimation=function(G,V,W){const J=this.getAllAnimatablesByTarget(G);for(const R of J)R.stop(V,W)},t.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let G=0;G<this._activeAnimatables.length;G++)this._activeAnimatables[G].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const G of this.animationGroups)G.stop()});class B{getClassName(){return"TargetedAnimation"}serialize(){const G={};return G.animation=this.animation.serialize(),G.targetId=this.target.id,G}}class S{get mask(){return this._mask}set mask(G){this._mask!==G&&(this._mask=G,this.syncWithMask(!0))}syncWithMask(){let G=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||G){this._numActiveAnimatables=0;for(let G=0;G<this._animatables.length;++G){const V=this._animatables[G];!this.mask||this.mask.disabled||this.mask.retainsTarget(V.target.name)?(this._numActiveAnimatables++,V.paused&&V.restart()):V.paused||V.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let G=0;G<this._animatables.length;++G){const V=this._animatables[G];this.mask.retainsTarget(V.target.name)||(V.stop(),this._animatables.splice(G,1),--G)}for(let G=0;G<this._targetedAnimations.length;G++){const V=this._targetedAnimations[G];this.mask.retainsTarget(V.target.name)||(this._targetedAnimations.splice(G,1),--G)}}}get from(){return this._from}set from(G){if(this._from!==G){this._from=G;for(let G=0;G<this._animatables.length;G++){this._animatables[G].fromFrame=this._from}}}get to(){return this._to}set to(G){if(this._to!==G){this._to=G;for(let G=0;G<this._animatables.length;G++){this._animatables[G].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(G){if(this._speedRatio!==G){this._speedRatio=G;for(let G=0;G<this._animatables.length;G++){this._animatables[G].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(G){if(this._loopAnimation!==G){this._loopAnimation=G;for(let G=0;G<this._animatables.length;G++){this._animatables[G].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(G){if(this._isAdditive!==G){this._isAdditive=G;for(let G=0;G<this._animatables.length;G++){this._animatables[G].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(G){this._weight!==G&&(this._weight=G,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(G){if(this._playOrder!==G&&(this._playOrder=G,this._animatables.length>0)){for(let G=0;G<this._animatables.length;G++)this._animatables[G].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(G){if(this._enableBlending!==G&&(this._enableBlending=G,null!==G))for(let V=0;V<this._targetedAnimations.length;++V)this._targetedAnimations[V].animation.enableBlending=G}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(G){if(this._blendingSpeed!==G&&(this._blendingSpeed=G,null!==G))for(let V=0;V<this._targetedAnimations.length;++V)this._targetedAnimations[V].animation.blendingSpeed=G}getLength(G,V){G=G??this._from;return((V=V??this._to)-G)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(G){let V=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],W=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=arguments.length>3?arguments[3]:void 0;if(0===G.length)return null;J=J??G[0].weight;let R=Number.MAX_VALUE,d=-Number.MAX_VALUE;if(W)for(const z of G)z.from<R&&(R=z.from),z.to>d&&(d=z.to);const k=new S(G[0].name+"_merged",G[0]._scene,J);for(const z of G){W&&z.normalize(R,d);for(const G of z.targetedAnimations)k.addTargetedAnimation(G.animation,G.target);V&&z.dispose()}return k}constructor(G){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=G,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new R.b,this.onAnimationLoopObservable=new R.b,this.onAnimationGroupLoopObservable=new R.b,this.onAnimationGroupEndObservable=new R.b,this.onAnimationGroupPauseObservable=new R.b,this.onAnimationGroupPlayObservable=new R.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=V||d.c.LastCreatedScene,this._weight=W,this._playOrder=J,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(G,V){const W=new B;W.animation=G,W.target=V;const J=G.getKeys();return this._from>J[0].frame&&(this._from=J[0].frame),this._to<J[J.length-1].frame&&(this._to=J[J.length-1].frame),null!==this._enableBlending&&(G.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(G.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(W),this._shouldStart=!0,W}removeTargetedAnimation(G){for(let V=this._targetedAnimations.length-1;V>-1;V--){this._targetedAnimations[V].animation===G&&this._targetedAnimations.splice(V,1)}}normalize(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==G&&(G=this._from),null==V&&(V=this._to);for(let W=0;W<this._targetedAnimations.length;W++){const J=this._targetedAnimations[W].animation.getKeys(),R=J[0],d=J[J.length-1];if(R.frame>G){const V={frame:G,value:R.value,inTangent:R.inTangent,outTangent:R.outTangent,interpolation:R.interpolation};J.splice(0,0,V)}if(d.frame<V){const G={frame:V,value:d.value,inTangent:d.inTangent,outTangent:d.outTangent,interpolation:d.interpolation};J.push(G)}}return this._from=G,this._to=V,this}_processLoop(G,V,W){G.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(V),this._animationLoopFlags[W]||(this._animationLoopFlags[W]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let G=arguments.length>0&&void 0!==arguments[0]&&arguments[0],V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,W=arguments.length>2?arguments[2]:void 0,J=arguments.length>3?arguments[3]:void 0,R=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=G,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let d=0;d<this._targetedAnimations.length;d++){const k=this._targetedAnimations[d],z=this._scene.beginDirectAnimation(k.target,[k.animation],void 0!==W?W:this._from,void 0!==J?J:this._to,G,V,void 0,void 0,void 0!==R?R:this._isAdditive);z.weight=this._weight,z.playOrder=this._playOrder,z.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(k),this._checkAnimationGroupEnded(z)},this._processLoop(z,k,d),this._animatables.push(z)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=V,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let G=0;G<this._animatables.length;G++){this._animatables[G].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(G){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==G&&(this.loopAnimation=G),this.restart()):(this.stop(),this.start(G,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let G=0;G<this._animatables.length;G++){this._animatables[G].reset()}return this}restart(){if(!this._isStarted)return this;for(let G=0;G<this._animatables.length;G++){this._animatables[G].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let G=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const V=this._animatables.slice();for(let J=0;J<V.length;J++)V[J].stop(void 0,void 0,!0,G);let W=0;for(let J=0;J<this._scene._activeAnimatables.length;J++){const V=this._scene._activeAnimatables[J];V._runtimeAnimations.length>0?this._scene._activeAnimatables[W++]=V:G&&this._checkAnimationGroupEnded(V,G)}return this._scene._activeAnimatables.length=W,this._isStarted=!1,this}setWeightForAllAnimatables(G){for(let V=0;V<this._animatables.length;V++){this._animatables[V].weight=G}return this}syncAllAnimationsWith(G){for(let V=0;V<this._animatables.length;V++){this._animatables[V].syncWith(G)}return this}goToFrame(G){let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let W=0;W<this._animatables.length;W++){this._animatables[W].goToFrame(G,V)}return this}getCurrentFrame(){var G;return(null===(G=this.animatables[0])||void 0===G?void 0:G.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const G=this._scene.animationGroups.indexOf(this);if(G>-1&&this._scene.animationGroups.splice(G,1),this._parentContainer){const G=this._parentContainer.animationGroups.indexOf(this);G>-1&&this._parentContainer.animationGroups.splice(G,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(G){let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const W=this._animatables.indexOf(G);W>-1&&this._animatables.splice(W,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,V||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(G,V){let W=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const J=new S(G||this.name,this._scene,this._weight,this._playOrder);J._from=this.from,J._to=this.to,J._speedRatio=this.speedRatio,J._loopAnimation=this.loopAnimation,J._isAdditive=this.isAdditive,J._enableBlending=this.enableBlending,J._blendingSpeed=this.blendingSpeed,J.metadata=this.metadata,J.mask=this.mask;for(const R of this._targetedAnimations)J.addTargetedAnimation(W?R.animation.clone():R.animation,V?V(R.target):R.target);return J}serialize(){const G={};G.name=this.name,G.from=this.from,G.to=this.to,G.speedRatio=this.speedRatio,G.loopAnimation=this.loopAnimation,G.isAdditive=this.isAdditive,G.weight=this.weight,G.playOrder=this.playOrder,G.enableBlending=this.enableBlending,G.blendingSpeed=this.blendingSpeed,G.targetedAnimations=[];for(let V=0;V<this.targetedAnimations.length;V++){const W=this.targetedAnimations[V];G.targetedAnimations[V]=W.serialize()}return k.c&&k.c.HasTags(this)&&(G.tags=k.c.GetTags(this)),this.metadata&&(G.metadata=this.metadata),G}static Parse(G,V){const W=new S(G.name,V,G.weight,G.playOrder);for(let R=0;R<G.targetedAnimations.length;R++){const d=G.targetedAnimations[R],k=J.e.Parse(d.animation),z=d.targetId;if("influence"===d.animation.property){const G=V.getMorphTargetById(z);G&&W.addTargetedAnimation(k,G)}else{const G=V.getNodeById(z);null!=G&&W.addTargetedAnimation(k,G)}}return k.c&&k.c.AddTagsTo(W,G.tags),null!==G.from&&null!==G.to&&W.normalize(G.from,G.to),void 0!==G.speedRatio&&(W._speedRatio=G.speedRatio),void 0!==G.loopAnimation&&(W._loopAnimation=G.loopAnimation),void 0!==G.isAdditive&&(W._isAdditive=G.isAdditive),void 0!==G.weight&&(W._weight=G.weight),void 0!==G.playOrder&&(W._playOrder=G.playOrder),void 0!==G.enableBlending&&(W._enableBlending=G.enableBlending),void 0!==G.blendingSpeed&&(W._blendingSpeed=G.blendingSpeed),void 0!==G.metadata&&(W.metadata=G.metadata),W}static MakeAnimationAdditive(G,V,W){let R;R="object"===typeof V?V:{referenceFrame:V,range:W,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let d=G;R.cloneOriginalAnimationGroup&&(d=G.clone(R.clonedAnimationGroupName||d.name));const k=d.targetedAnimations;for(let z=0;z<k.length;z++){const G=k[z];G.animation=J.e.MakeAnimationAdditive(G.animation,R)}if(d.isAdditive=!0,R.clipKeys){let G=Number.MAX_VALUE,V=-Number.MAX_VALUE;const W=d.targetedAnimations;for(let J=0;J<W.length;J++){const R=W[J].animation.getKeys();G>R[0].frame&&(G=R[0].frame),V<R[R.length-1].frame&&(V=R[R.length-1].frame)}d._from=G,d._to=V}return d}static ClipKeys(G,V,W,J,R){const d=G.clone(J||G.name);return S.ClipKeysInPlace(d,V,W,R)}static ClipKeysInPlace(G,V,W,J){return S.ClipInPlace(G,V,W,J,!1)}static ClipFrames(G,V,W,J,R){const d=G.clone(J||G.name);return S.ClipFramesInPlace(d,V,W,R)}static ClipFramesInPlace(G,V,W,J){return S.ClipInPlace(G,V,W,J,!0)}static ClipInPlace(G,V,W,J){let R=arguments.length>4&&void 0!==arguments[4]&&arguments[4],d=Number.MAX_VALUE,k=-Number.MAX_VALUE;const z=G.targetedAnimations;for(let X=0;X<z.length;X++){const G=z[X],P=J?G.animation:G.animation.clone();R&&(P.createKeyForFrame(V),P.createKeyForFrame(W));const A=P.getKeys(),x=[];let q=Number.MAX_VALUE;for(let J=0;J<A.length;J++){const G=A[J];if(!R&&J>=V&&J<=W||R&&G.frame>=V&&G.frame<=W){const V={frame:G.frame,value:G.value.clone?G.value.clone():G.value,inTangent:G.inTangent,outTangent:G.outTangent,interpolation:G.interpolation,lockedTangent:G.lockedTangent};q===Number.MAX_VALUE&&(q=V.frame),V.frame-=q,x.push(V)}}0!==x.length?(d>x[0].frame&&(d=x[0].frame),k<x[x.length-1].frame&&(k=x[x.length-1].frame),P.setKeys(x,!0),G.animation=P):(z.splice(X,1),X--)}return G._from=d,G._to=k,G}getClassName(){return"AnimationGroup"}toString(G){let V="Name: "+this.name;return V+=", type: "+this.getClassName(),G&&(V+=", from: "+this._from,V+=", to: "+this._to,V+=", isStarted: "+this._isStarted,V+=", speedRatio: "+this._speedRatio,V+=", targetedAnimations length: "+this._targetedAnimations.length,V+=", animatables length: "+this._animatables),V}}}}]);