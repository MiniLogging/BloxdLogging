"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[58],{14144:(x,O,Q)=>{Q.r(O),Q.d(O,{AnimationGroup:()=>g,TargetedAnimation:()=>Y});var X=Q(11538),Z=Q(10882),n=Q(10877),V=Q(11127),o=Q(12622),l=Q(10849);class C{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(x,O,Q,Z){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=O,this._target=x,this._scene=Q,this._host=Z,this._activeTargets=[],O._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===X.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=l.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const x={frame:0,value:this._minValue};this._keys.splice(0,0,x)}if(this._target instanceof Array){let x=0;for(const O of this._target)this._preparePath(O,x),this._getOriginalValues(x),x++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const n=O.getEvents();if(n&&n.length>0)for(const X of n)this._events.push(X._clone());this._enableBlending=x&&x.animationPropertiesOverride?x.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(x){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Q=this._animation.targetPropertyPath;if(Q.length>1){let X=x;for(let x=0;x<Q.length-1;x++){const O=Q[x];if(X=X[O],void 0===X)throw new Error(`Invalid property (${O}) in property path (${Q.join(".")})`)}this._targetPath=Q[Q.length-1],this._activeTargets[O]=X}else this._targetPath=Q[0],this._activeTargets[O]=x;if(void 0===this._activeTargets[O][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${Q.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let x=0;for(const O of this._target)void 0!==this._originalValue[x]&&this._setValue(O,this._activeTargets[x],this._originalValue[x],-1,x),x++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let x=0;x<this._events.length;x++)this._events[x].isDone=!1}isStopped(){return this._stopped}dispose(){const x=this._animation.runtimeAnimations.indexOf(this);x>-1&&this._animation.runtimeAnimations.splice(x,1)}setValue(x,O){if(this._targetIsArray)for(let Q=0;Q<this._target.length;Q++){const X=this._target[Q];this._setValue(X,this._activeTargets[Q],x,O,Q)}else this._setValue(this._target,this._directTarget,x,O,0)}_getOriginalValues(){let x,O=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Q=this._activeTargets[O];x=Q.getLocalMatrix&&"_matrix"===this._targetPath?Q.getLocalMatrix():Q[this._targetPath],x&&x.clone?this._originalValue[O]=x.clone():this._originalValue[O]=x}_registerTargetForLateAnimationBinding(x,O){const Q=x.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(Q),Q._lateAnimationHolders||(Q._lateAnimationHolders={}),Q._lateAnimationHolders[x.targetPath]||(Q._lateAnimationHolders[x.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:O}),x.isAdditive?(Q._lateAnimationHolders[x.targetPath].additiveAnimations.push(x),Q._lateAnimationHolders[x.targetPath].totalAdditiveWeight+=x.weight):(Q._lateAnimationHolders[x.targetPath].animations.push(x),Q._lateAnimationHolders[x.targetPath].totalWeight+=x.weight)}_setValue(x,O,Q,Z,n){if(this._currentActiveTarget=O,this._weight=Z,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const x=O[this._targetPath];x.clone?this._originalBlendValue=x.clone():this._originalBlendValue=x}this._originalBlendValue.m?X.b.AllowMatrixDecomposeForInterpolation?this._currentValue?l.c.DecomposeLerpToRef(this._originalBlendValue,Q,this._blendingFactor,this._currentValue):this._currentValue=l.c.DecomposeLerp(this._originalBlendValue,Q,this._blendingFactor):this._currentValue?l.c.LerpToRef(this._originalBlendValue,Q,this._blendingFactor,this._currentValue):this._currentValue=l.c.Lerp(this._originalBlendValue,Q,this._blendingFactor):this._currentValue=X.b._UniversalLerp(this._originalBlendValue,Q,this._blendingFactor);const Z=x&&x.animationPropertiesOverride?x.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=Z}else this._currentValue?this._currentValue.V?this._currentValue.V(Q):this._currentValue=Q:null!==Q&&void 0!==Q&&Q.clone?this._currentValue=Q.clone():this._currentValue=Q;-1!==Z?this._registerTargetForLateAnimationBinding(this,this._originalValue[n]):this._animationState.loopMode===X.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[n],O[this._targetPath]):O[this._targetPath]=this._originalValue[n]+this._currentValue:O[this._targetPath]=this._currentValue,x.qC&&x.qC(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(x){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const Q=this._animation.getKeys();x<Q[0].frame?x=Q[0].frame:x>Q[Q.length-1].frame&&(x=Q[Q.length-1].frame);const X=this._events;if(X.length)for(let n=0;n<X.length;n++)X[n].onlyOnce||(X[n].isDone=X[n].frame<x);this._currentFrame=x;const Z=this._animation._interpolate(x,this._animationState);this.setValue(Z,O)}_prepareForSpeedRatioChange(x){const O=this._previousElapsedTime*(this._animation.framePerSecond*x)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-O}animate(x,O,Q,Z,n){let V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const o=this._animation,l=o.targetPropertyPath;if(!l||l.length<1)return this._stopped=!0,!1;let C,U=!0;const L=this._events;let h=0;if(this._coreRuntimeAnimation)h=Q-O,C=this._coreRuntimeAnimation.currentFrame,this._currentFrame=C,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let V;(O<this._minFrame||O>this._maxFrame)&&(O=this._minFrame),(Q<this._minFrame||Q>this._maxFrame)&&(Q=this._maxFrame),h=Q-O;let l=x*(o.framePerSecond*n)/1e3+this._absoluteFrameOffset,N=0,a=!1;const K=Z&&this._animationState.loopMode===X.b.ANIMATIONLOOPMODE_YOYO;if(K){const x=(l-O)/h,Q=Math.sin(x*Math.PI);l=Math.abs(Q)*h+O;const X=Q>=0?1:-1;this._yoyoDirection!==X&&(a=!0),this._yoyoDirection=X}if(this._previousElapsedTime=x,this._previousAbsoluteFrame=l,!Z&&Q>=O&&(l>=h&&n>0||l<=0&&n<0))U=!1,N=o._getKeyValue(this._maxValue);else if(!Z&&O>=Q&&(l<=h&&n<0||l>=0&&n>0))U=!1,N=o._getKeyValue(this._minValue);else if(this._animationState.loopMode!==X.b.ANIMATIONLOOPMODE_CYCLE){const x=Q.toString()+O.toString();if(!this._offsetsCache[x]){this._animationState.repeatCount=0,this._animationState.loopMode=X.b.ANIMATIONLOOPMODE_CYCLE;const Z=o._interpolate(O,this._animationState),n=o._interpolate(Q,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),o.dataType){case X.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[x]=n-Z;break;case X.b.ANIMATIONTYPE_QUATERNION:case X.b.ANIMATIONTYPE_VECTOR3:case X.b.ANIMATIONTYPE_VECTOR2:case X.b.ANIMATIONTYPE_SIZE:case X.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[x]=n.hQ(Z)}this._highLimitsCache[x]=n}N=this._highLimitsCache[x],V=this._offsetsCache[x]}if(void 0===V)switch(o.dataType){case X.b.ANIMATIONTYPE_FLOAT:V=0;break;case X.b.ANIMATIONTYPE_QUATERNION:V=X.e;break;case X.b.ANIMATIONTYPE_VECTOR3:V=X.o;break;case X.b.ANIMATIONTYPE_VECTOR2:V=X.k;break;case X.b.ANIMATIONTYPE_SIZE:V=X.h;break;case X.b.ANIMATIONTYPE_COLOR3:V=X.c;break;case X.b.ANIMATIONTYPE_COLOR4:V=X.d}if(this._host&&this._host.syncRoot){const x=this._host.syncRoot;C=O+h*((x.masterFrame-x.fromFrame)/(x.toFrame-x.fromFrame))}else C=l>0&&O>Q||l<0&&O<Q?U&&0!==h?Q+l%h:O:U&&0!==h?O+l%h:Q;if(!K&&(n>0&&this.currentFrame>C||n<0&&this.currentFrame<C)||K&&a){this._onLoop();for(let x=0;x<L.length;x++)L[x].onlyOnce||(L[x].isDone=!1);this._animationState.key=n>0?0:o.getKeys().length-1}this._currentFrame=C,this._animationState.repeatCount=0===h?0:l/h|0,this._animationState.highLimitValue=N,this._animationState.offsetValue=V}const N=o._interpolate(C,this._animationState);if(this.setValue(N,V),L.length)for(let X=0;X<L.length;X++)if(h>=0&&C>=L[X].frame&&L[X].frame>=O||h<0&&C<=L[X].frame&&L[X].frame<=O){const x=L[X];x.isDone||(x.onlyOnce&&(L.splice(X,1),X--),x.isDone=!0,x.action(C))}return U||(this._stopped=!0),U}}var U=Q(10917);class L{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(x){this._weight=-1!==x?Math.min(Math.max(x,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(x){for(let O=0;O<this._runtimeAnimations.length;O++){this._runtimeAnimations[O]._prepareForSpeedRatioChange(x)}this._speedRatio=x,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(x,O){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,n=arguments.length>4&&void 0!==arguments[4]&&arguments[4],V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0,l=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,U=arguments.length>9&&void 0!==arguments[9]&&arguments[9],L=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=O,this.fromFrame=Q,this.toFrame=X,this.loopAnimation=n,this.onAnimationEnd=o,this.onAnimationLoop=C,this.isAdditive=U,this.playOrder=L,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.eV=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new Z.b,this.onAnimationLoopObservable=new Z.b,this._scene=x,l&&this.appendAnimations(O,l),this._speedRatio=V,x._activeAnimatables.push(this)}syncWith(x){if(this._syncRoot=x,x){const x=this._scene._activeAnimatables.indexOf(this);x>-1&&(this._scene._activeAnimatables.splice(x,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(x,O){for(let Q=0;Q<O.length;Q++){const X=O[Q],Z=new C(x,X,this._scene,this);Z._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(Z)}}getAnimationByTargetProperty(x){const O=this._runtimeAnimations;for(let Q=0;Q<O.length;Q++)if(O[Q].animation.targetProperty===x)return O[Q].animation;return null}getRuntimeAnimationByTargetProperty(x){const O=this._runtimeAnimations;for(let Q=0;Q<O.length;Q++)if(O[Q].animation.targetProperty===x)return O[Q];return null}reset(){const x=this._runtimeAnimations;for(let O=0;O<x.length;O++)x[O].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(x){const O=this._runtimeAnimations;for(let Q=0;Q<O.length;Q++)O[Q].animation.enableBlending=!0,O[Q].animation.blendingSpeed=x}disableBlending(){const x=this._runtimeAnimations;for(let O=0;O<x.length;O++)x[O].animation.enableBlending=!1}goToFrame(x){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Q=this._runtimeAnimations;if(Q[0]){const O=Q[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??Q[0].currentFrame;const X=0===this.speedRatio?0:(x-this._frameToSyncFromJump)/O*1e3/this.speedRatio;this._manualJumpDelay=-X}for(let X=0;X<Q.length;X++)Q[X].goToFrame(x,O?this._weight:-1);this._goToFrame=x}get paused(){return this.eV}pause(){this.eV||(this.eV=!0)}restart(){this.eV=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(x,O){let Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],X=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(x||O){const Z=this._scene._activeAnimatables.indexOf(this);if(Z>-1){const n=this._runtimeAnimations;for(let Q=n.length-1;Q>=0;Q--){const X=n[Q];x&&X.animation.name!=x||(O&&!O(X.target)||(X.dispose(),n.splice(Q,1)))}0==n.length&&(Q||this._scene._activeAnimatables.splice(Z,1),X||this._raiseOnAnimationEnd())}}else{const x=this._scene._activeAnimatables.indexOf(this);if(x>-1){Q||this._scene._activeAnimatables.splice(x,1);const O=this._runtimeAnimations;for(let x=0;x<O.length;x++)O[x].dispose();this._runtimeAnimations.length=0,X||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((x=>{this.onAnimationEndObservable.add((()=>{x(this)}),void 0,void 0,this,!0)}))}_animate(x){if(this.eV)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=x),!0;if(null===this._localDelayOffset?(this._localDelayOffset=x,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=x-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let O=!1;const Q=this._runtimeAnimations;let X;for(X=0;X<Q.length;X++){const Z=Q[X].animate(x-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);O=O||Z}if(this.animationStarted=O,!O){if(this.disposeOnEnd)for(X=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(X,1),X=0;X<Q.length;X++)Q[X].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return O}}function h(x){if(0===x.totalWeight&&0===x.totalAdditiveWeight)return x.originalValue;let O=1;const Q=l.j.Oo[0],X=l.j.Oo[1],Z=l.j.Quaternion[0];let n=0;const V=x.animations[0],o=x.originalValue;let C=1,U=!1;if(x.totalWeight<1)C=1-x.totalWeight,o.decompose(X,Z,Q);else{if(n=1,O=x.totalWeight,C=V.weight/O,1==C){if(!x.totalAdditiveWeight)return V.currentValue;U=!0}V.currentValue.decompose(X,Z,Q)}if(!U){X.scaleInPlace(C),Q.scaleInPlace(C),Z.scaleInPlace(C);for(let V=n;V<x.animations.length;V++){const n=x.animations[V];if(0===n.weight)continue;C=n.weight/O;const o=l.j.Oo[2],U=l.j.Oo[3],L=l.j.Quaternion[1];n.currentValue.decompose(U,L,o),U.scaleAndAddToRef(C,X),L.scaleAndAddToRef(l.g.Dot(Z,L)>0?C:-C,Z),o.scaleAndAddToRef(C,Q)}Z.normalize()}for(let h=0;h<x.additiveAnimations.length;h++){const O=x.additiveAnimations[h];if(0===O.weight)continue;const n=l.j.Oo[2],V=l.j.Oo[3],o=l.j.Quaternion[1];O.currentValue.decompose(V,o,n),V.multiplyToRef(X,V),l.n.LerpToRef(X,V,O.weight,X),Z.multiplyToRef(o,o),l.g.SlerpToRef(Z,o,O.weight,Z),n.scaleAndAddToRef(O.weight,Q)}const L=V?V._animationState.workValue:l.j.Matrix[0].clone();return l.c.ComposeToRef(X,Z,Q,L),L}function N(x,O){if(0===x.totalWeight&&0===x.totalAdditiveWeight)return O;const Q=x.animations[0],X=x.originalValue;let Z=O;if(0===x.totalWeight&&x.totalAdditiveWeight>0)Z.V(X);else if(1===x.animations.length){if(l.g.SlerpToRef(X,Q.currentValue,Math.min(1,x.totalWeight),Z),0===x.totalAdditiveWeight)return Z}else if(x.animations.length>1){let Q,n,V=1;if(x.totalWeight<1){const O=1-x.totalWeight;Q=[],n=[],Q.push(X),n.push(O)}else{if(2===x.animations.length&&(l.g.SlerpToRef(x.animations[0].currentValue,x.animations[1].currentValue,x.animations[1].weight/x.totalWeight,O),0===x.totalAdditiveWeight))return O;Q=[],n=[],V=x.totalWeight}for(let O=0;O<x.animations.length;O++){const X=x.animations[O];Q.push(X.currentValue),n.push(X.weight/V)}let o=0;for(let x=0;x<Q.length;)x?(o+=n[x],l.g.SlerpToRef(Z,Q[x],n[x]/o,Z),x++):(l.g.SlerpToRef(Q[x],Q[x+1],n[x+1]/(n[x]+n[x+1]),O),Z=O,o=n[x]+n[x+1],x+=2)}for(let n=0;n<x.additiveAnimations.length;n++){const O=x.additiveAnimations[n];0!==O.weight&&(Z.multiplyToRef(O.currentValue,l.j.Quaternion[0]),l.g.SlerpToRef(Z,l.j.Quaternion[0],O.weight,Z))}return Z}var a,K,M=Q(11423);a=M.d,(K=o.c)&&(K.prototype.copyAnimationRange=function(x,O,Q){let Z=arguments.length>3&&void 0!==arguments[3]&&arguments[3],n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new X.b(this.name,"_matrix",x.animations[0].framePerSecond,X.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const V=x.animations[0].getRange(O);if(!V)return!1;const o=V.from,l=V.to,C=x.animations[0].getKeys(),U=x.length,L=x.getParent(),h=this.getParent(),N=Z&&L&&U&&this.length&&U!==this.length,a=N&&h&&L?h.length/L.length:1,K=Z&&!h&&n&&(1!==n.x||1!==n.y||1!==n.z),M=this.animations[0].getKeys();let Y,g,v;for(let X=0,R=C.length;X<R;X++)Y=C[X],Y.frame>=o&&Y.frame<=l&&(Z?(v=Y.value.clone(),N?(g=v.getTranslation(),v.setTranslation(g.scaleInPlace(a))):K&&n?(g=v.getTranslation(),v.setTranslation(g.multiplyInPlace(n))):v=Y.value):v=Y.value,M.push({frame:Y.frame+Q,value:v}));return this.animations[0].createRange(O,o+Q,l+Q),!0}),a&&(a.prototype._animate=function(x){if(!this.animationsEnabled)return;const O=U.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=O}this.deltaTime=void 0!==x?x:this.useConstantAnimationDeltaTime?16:(O-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=O;const Q=this._activeAnimatables;if(0===Q.length)return;this._animationTime+=this.deltaTime;const Z=this._animationTime;for(let X=0;X<Q.length;X++){const x=Q[X];!x._animate(Z)&&x.disposeOnEnd&&X--}!function(x){if(x._registeredForLateAnimationBindings.length){for(let O=0;O<x._registeredForLateAnimationBindings.length;O++){const Q=x._registeredForLateAnimationBindings.data[O];for(const x in Q._lateAnimationHolders){const O=Q._lateAnimationHolders[x],Z=O.animations[0],n=O.originalValue;if(void 0===n||null===n)continue;const V=X.b.AllowMatrixDecomposeForInterpolation&&n.m;let o=Q[x];if(V)o=h(O);else if(void 0!==n.w)o=N(O,o||l.g.Identity());else{let x=0,Q=1;const V=Z&&Z._animationState.loopMode===X.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(O.totalWeight<1)o=V?n.clone?n.clone():n:Z&&n.scale?n.scale(1-O.totalWeight):Z?n*(1-O.totalWeight):n.clone?n.clone():n;else if(Z){Q=O.totalWeight;const X=Z.weight/Q;o=1!==X?Z.currentValue.scale?Z.currentValue.scale(X):Z.currentValue*X:Z.currentValue,V&&(o.addToRef?o.addToRef(n,o):o+=n),x=1}for(let X=x;X<O.animations.length;X++){const x=O.animations[X],Z=x.weight/Q;Z&&(x.currentValue.scaleAndAddToRef?x.currentValue.scaleAndAddToRef(Z,o):o+=x.currentValue*Z)}for(let X=0;X<O.additiveAnimations.length;X++){const x=O.additiveAnimations[X],Q=x.weight;Q&&(x.currentValue.scaleAndAddToRef?x.currentValue.scaleAndAddToRef(Q,o):o+=x.currentValue*Q)}}Q[x]=o}Q._lateAnimationHolders={}}x._registeredForLateAnimationBindings.reset()}}(this)},a.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((x,O)=>x.playOrder-O.playOrder))},a.prototype.beginWeightedAnimation=function(x,O,Q){let X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,Z=arguments.length>4?arguments[4]:void 0,n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,V=arguments.length>6?arguments[6]:void 0,o=arguments.length>7?arguments[7]:void 0,l=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,U=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const L=this.beginAnimation(x,O,Q,Z,n,V,o,!1,l,C,U);return L.weight=X,L},a.prototype.beginAnimation=function(x,O,Q,X){let Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,n=arguments.length>5?arguments[5]:void 0,V=arguments.length>6?arguments[6]:void 0,o=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],l=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,U=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(Z<0){const x=O;O=Q,Q=x,Z=-Z}O>Q&&(Z=-Z),o&&this.stopAnimation(x,void 0,l),V||(V=new L(this,x,O,Q,X,Z,n,void 0,C,U));const h=!l||l(x);if(x.animations&&h&&V.appendAnimations(x,x.animations),x.getAnimatables){const U=x.getAnimatables();for(let x=0;x<U.length;x++)this.beginAnimation(U[x],O,Q,X,Z,n,V,o,l,C)}return V.reset(),V},a.prototype.beginHierarchyAnimation=function(x,O,Q,X,Z){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,V=arguments.length>6?arguments[6]:void 0,o=arguments.length>7?arguments[7]:void 0,l=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],C=arguments.length>9?arguments[9]:void 0,U=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const L=x.getDescendants(O),h=[];h.push(this.beginAnimation(x,Q,X,Z,n,V,o,l,C,void 0,U));for(const N of L)h.push(this.beginAnimation(N,Q,X,Z,n,V,o,l,C,void 0,U));return h},a.prototype.beginDirectAnimation=function(x,O,Q,X,Z){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(n<0){const x=Q;Q=X,X=x,n=-n}return Q>X&&(n=-n),new L(this,x,Q,X,Z,n,arguments.length>6?arguments[6]:void 0,O,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},a.prototype.beginDirectHierarchyAnimation=function(x,O,Q,X,Z,n,V,o,l){let C=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const U=x.getDescendants(O),L=[];L.push(this.beginDirectAnimation(x,Q,X,Z,n,V,o,l,C));for(const h of U)L.push(this.beginDirectAnimation(h,Q,X,Z,n,V,o,l,C));return L},a.prototype.getAnimatableByTarget=function(x){for(let O=0;O<this._activeAnimatables.length;O++)if(this._activeAnimatables[O].target===x)return this._activeAnimatables[O];return null},a.prototype.getAllAnimatablesByTarget=function(x){const O=[];for(let Q=0;Q<this._activeAnimatables.length;Q++)this._activeAnimatables[Q].target===x&&O.push(this._activeAnimatables[Q]);return O},a.prototype.stopAnimation=function(x,O,Q){const X=this.getAllAnimatablesByTarget(x);for(const Z of X)Z.stop(O,Q)},a.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let x=0;x<this._activeAnimatables.length;x++)this._activeAnimatables[x].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const x of this.animationGroups)x.stop()});class Y{getClassName(){return"TargetedAnimation"}serialize(){const x={};return x.animation=this.animation.serialize(),x.targetId=this.target.id,x}}class g{get mask(){return this._mask}set mask(x){this._mask!==x&&(this._mask=x,this.syncWithMask(!0))}syncWithMask(){let x=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||x){this._numActiveAnimatables=0;for(let x=0;x<this._animatables.length;++x){const O=this._animatables[x];!this.mask||this.mask.disabled||this.mask.retainsTarget(O.target.name)?(this._numActiveAnimatables++,O.paused&&O.restart()):O.paused||O.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let x=0;x<this._animatables.length;++x){const O=this._animatables[x];this.mask.retainsTarget(O.target.name)||(O.stop(),this._animatables.splice(x,1),--x)}for(let x=0;x<this._targetedAnimations.length;x++){const O=this._targetedAnimations[x];this.mask.retainsTarget(O.target.name)||(this._targetedAnimations.splice(x,1),--x)}}}get from(){return this._from}set from(x){if(this._from!==x){this._from=x;for(let x=0;x<this._animatables.length;x++){this._animatables[x].fromFrame=this._from}}}get to(){return this._to}set to(x){if(this._to!==x){this._to=x;for(let x=0;x<this._animatables.length;x++){this._animatables[x].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(x){if(this._speedRatio!==x){this._speedRatio=x;for(let x=0;x<this._animatables.length;x++){this._animatables[x].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(x){if(this._loopAnimation!==x){this._loopAnimation=x;for(let x=0;x<this._animatables.length;x++){this._animatables[x].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(x){if(this._isAdditive!==x){this._isAdditive=x;for(let x=0;x<this._animatables.length;x++){this._animatables[x].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(x){this._weight!==x&&(this._weight=x,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(x){if(this._playOrder!==x&&(this._playOrder=x,this._animatables.length>0)){for(let x=0;x<this._animatables.length;x++)this._animatables[x].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(x){if(this._enableBlending!==x&&(this._enableBlending=x,null!==x))for(let O=0;O<this._targetedAnimations.length;++O)this._targetedAnimations[O].animation.enableBlending=x}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(x){if(this._blendingSpeed!==x&&(this._blendingSpeed=x,null!==x))for(let O=0;O<this._targetedAnimations.length;++O)this._targetedAnimations[O].animation.blendingSpeed=x}getLength(x,O){x=x??this._from;return((O=O??this._to)-x)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(x){let O=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],X=arguments.length>3?arguments[3]:void 0;if(0===x.length)return null;X=X??x[0].weight;let Z=Number.MAX_VALUE,n=-Number.MAX_VALUE;if(Q)for(const o of x)o.from<Z&&(Z=o.from),o.to>n&&(n=o.to);const V=new g(x[0].name+"_merged",x[0]._scene,X);for(const o of x){Q&&o.normalize(Z,n);for(const x of o.targetedAnimations)V.addTargetedAnimation(x.animation,x.target);O&&o.dispose()}return V}constructor(x){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=x,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new Z.b,this.onAnimationLoopObservable=new Z.b,this.onAnimationGroupLoopObservable=new Z.b,this.onAnimationGroupEndObservable=new Z.b,this.onAnimationGroupPauseObservable=new Z.b,this.onAnimationGroupPlayObservable=new Z.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=O||n.c.LastCreatedScene,this._weight=Q,this._playOrder=X,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(x,O){const Q=new Y;Q.animation=x,Q.target=O;const X=x.getKeys();return this._from>X[0].frame&&(this._from=X[0].frame),this._to<X[X.length-1].frame&&(this._to=X[X.length-1].frame),null!==this._enableBlending&&(x.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(x.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(Q),this._shouldStart=!0,Q}removeTargetedAnimation(x){for(let O=this._targetedAnimations.length-1;O>-1;O--){this._targetedAnimations[O].animation===x&&this._targetedAnimations.splice(O,1)}}normalize(){let x=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==x&&(x=this._from),null==O&&(O=this._to);for(let Q=0;Q<this._targetedAnimations.length;Q++){const X=this._targetedAnimations[Q].animation.getKeys(),Z=X[0],n=X[X.length-1];if(Z.frame>x){const O={frame:x,value:Z.value,inTangent:Z.inTangent,outTangent:Z.outTangent,interpolation:Z.interpolation};X.splice(0,0,O)}if(n.frame<O){const x={frame:O,value:n.value,inTangent:n.inTangent,outTangent:n.outTangent,interpolation:n.interpolation};X.push(x)}}return this._from=x,this._to=O,this}_processLoop(x,O,Q){x.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(O),this._animationLoopFlags[Q]||(this._animationLoopFlags[Q]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let x=arguments.length>0&&void 0!==arguments[0]&&arguments[0],O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Q=arguments.length>2?arguments[2]:void 0,X=arguments.length>3?arguments[3]:void 0,Z=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=x,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let n=0;n<this._targetedAnimations.length;n++){const V=this._targetedAnimations[n],o=this._scene.beginDirectAnimation(V.target,[V.animation],void 0!==Q?Q:this._from,void 0!==X?X:this._to,x,O,void 0,void 0,void 0!==Z?Z:this._isAdditive);o.weight=this._weight,o.playOrder=this._playOrder,o.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(V),this._checkAnimationGroupEnded(o)},this._processLoop(o,V,n),this._animatables.push(o)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=O,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let x=0;x<this._animatables.length;x++){this._animatables[x].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(x){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==x&&(this.loopAnimation=x),this.restart()):(this.stop(),this.start(x,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let x=0;x<this._animatables.length;x++){this._animatables[x].reset()}return this}restart(){if(!this._isStarted)return this;for(let x=0;x<this._animatables.length;x++){this._animatables[x].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let x=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const O=this._animatables.slice();for(let X=0;X<O.length;X++)O[X].stop(void 0,void 0,!0,x);let Q=0;for(let X=0;X<this._scene._activeAnimatables.length;X++){const O=this._scene._activeAnimatables[X];O._runtimeAnimations.length>0?this._scene._activeAnimatables[Q++]=O:x&&this._checkAnimationGroupEnded(O,x)}return this._scene._activeAnimatables.length=Q,this._isStarted=!1,this}setWeightForAllAnimatables(x){for(let O=0;O<this._animatables.length;O++){this._animatables[O].weight=x}return this}syncAllAnimationsWith(x){for(let O=0;O<this._animatables.length;O++){this._animatables[O].syncWith(x)}return this}goToFrame(x){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].goToFrame(x,O)}return this}getCurrentFrame(){var x;return(null===(x=this.animatables[0])||void 0===x?void 0:x.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const x=this._scene.animationGroups.indexOf(this);if(x>-1&&this._scene.animationGroups.splice(x,1),this._parentContainer){const x=this._parentContainer.animationGroups.indexOf(this);x>-1&&this._parentContainer.animationGroups.splice(x,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(x){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Q=this._animatables.indexOf(x);Q>-1&&this._animatables.splice(Q,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,O||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(x,O){let Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const X=new g(x||this.name,this._scene,this._weight,this._playOrder);X._from=this.from,X._to=this.to,X._speedRatio=this.speedRatio,X._loopAnimation=this.loopAnimation,X._isAdditive=this.isAdditive,X._enableBlending=this.enableBlending,X._blendingSpeed=this.blendingSpeed,X.metadata=this.metadata,X.mask=this.mask;for(const Z of this._targetedAnimations)X.addTargetedAnimation(Q?Z.animation.clone():Z.animation,O?O(Z.target):Z.target);return X}serialize(){const x={};x.name=this.name,x.from=this.from,x.to=this.to,x.speedRatio=this.speedRatio,x.loopAnimation=this.loopAnimation,x.isAdditive=this.isAdditive,x.weight=this.weight,x.playOrder=this.playOrder,x.enableBlending=this.enableBlending,x.blendingSpeed=this.blendingSpeed,x.targetedAnimations=[];for(let O=0;O<this.targetedAnimations.length;O++){const Q=this.targetedAnimations[O];x.targetedAnimations[O]=Q.serialize()}return V.e&&V.e.HasTags(this)&&(x.tags=V.e.GetTags(this)),this.metadata&&(x.metadata=this.metadata),x}static Parse(x,O){const Q=new g(x.name,O,x.weight,x.playOrder);for(let Z=0;Z<x.targetedAnimations.length;Z++){const n=x.targetedAnimations[Z],V=X.b.Parse(n.animation),o=n.targetId;if("influence"===n.animation.property){const x=O.getMorphTargetById(o);x&&Q.addTargetedAnimation(V,x)}else{const x=O.getNodeById(o);null!=x&&Q.addTargetedAnimation(V,x)}}return V.e&&V.e.AddTagsTo(Q,x.tags),null!==x.from&&null!==x.to&&Q.normalize(x.from,x.to),void 0!==x.speedRatio&&(Q._speedRatio=x.speedRatio),void 0!==x.loopAnimation&&(Q._loopAnimation=x.loopAnimation),void 0!==x.isAdditive&&(Q._isAdditive=x.isAdditive),void 0!==x.weight&&(Q._weight=x.weight),void 0!==x.playOrder&&(Q._playOrder=x.playOrder),void 0!==x.enableBlending&&(Q._enableBlending=x.enableBlending),void 0!==x.blendingSpeed&&(Q._blendingSpeed=x.blendingSpeed),void 0!==x.metadata&&(Q.metadata=x.metadata),Q}static MakeAnimationAdditive(x,O,Q){let Z;Z="object"===typeof O?O:{referenceFrame:O,range:Q,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let n=x;Z.cloneOriginalAnimationGroup&&(n=x.clone(Z.clonedAnimationGroupName||n.name));const V=n.targetedAnimations;for(let o=0;o<V.length;o++){const x=V[o];x.animation=X.b.MakeAnimationAdditive(x.animation,Z)}if(n.isAdditive=!0,Z.clipKeys){let x=Number.MAX_VALUE,O=-Number.MAX_VALUE;const Q=n.targetedAnimations;for(let X=0;X<Q.length;X++){const Z=Q[X].animation.getKeys();x>Z[0].frame&&(x=Z[0].frame),O<Z[Z.length-1].frame&&(O=Z[Z.length-1].frame)}n._from=x,n._to=O}return n}static ClipKeys(x,O,Q,X,Z){const n=x.clone(X||x.name);return g.ClipKeysInPlace(n,O,Q,Z)}static ClipKeysInPlace(x,O,Q,X){return g.ClipInPlace(x,O,Q,X,!1)}static ClipFrames(x,O,Q,X,Z){const n=x.clone(X||x.name);return g.ClipFramesInPlace(n,O,Q,Z)}static ClipFramesInPlace(x,O,Q,X){return g.ClipInPlace(x,O,Q,X,!0)}static ClipInPlace(x,O,Q,X){let Z=arguments.length>4&&void 0!==arguments[4]&&arguments[4],n=Number.MAX_VALUE,V=-Number.MAX_VALUE;const o=x.targetedAnimations;for(let l=0;l<o.length;l++){const x=o[l],C=X?x.animation:x.animation.clone();Z&&(C.createKeyForFrame(O),C.createKeyForFrame(Q));const U=C.getKeys(),L=[];let h=Number.MAX_VALUE;for(let X=0;X<U.length;X++){const x=U[X];if(!Z&&X>=O&&X<=Q||Z&&x.frame>=O&&x.frame<=Q){const O={frame:x.frame,value:x.value.clone?x.value.clone():x.value,inTangent:x.inTangent,outTangent:x.outTangent,interpolation:x.interpolation,lockedTangent:x.lockedTangent};h===Number.MAX_VALUE&&(h=O.frame),O.frame-=h,L.push(O)}}0!==L.length?(n>L[0].frame&&(n=L[0].frame),V<L[L.length-1].frame&&(V=L[L.length-1].frame),C.setKeys(L,!0),x.animation=C):(o.splice(l,1),l--)}return x._from=n,x._to=V,x}getClassName(){return"AnimationGroup"}toString(x){let O="Name: "+this.name;return O+=", type: "+this.getClassName(),x&&(O+=", from: "+this._from,O+=", to: "+this._to,O+=", isStarted: "+this._isStarted,O+=", speedRatio: "+this._speedRatio,O+=", targetedAnimations length: "+this._targetedAnimations.length,O+=", animatables length: "+this._animatables),O}}}}]);