"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13649:(B,I,C)=>{C.r(I),C.d(I,{_HDRTextureLoader:()=>N});var M=C(11194);class x{static ConvertPanoramaToCubemap(B,I,C,M){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!B)throw"ConvertPanoramaToCubemap: input cannot be null";if(B.length!=I*C*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(M,this.FACE_FRONT,B,I,C,x),back:this.CreateCubemapTexture(M,this.FACE_BACK,B,I,C,x),left:this.CreateCubemapTexture(M,this.FACE_LEFT,B,I,C,x),right:this.CreateCubemapTexture(M,this.FACE_RIGHT,B,I,C,x),up:this.CreateCubemapTexture(M,this.FACE_UP,B,I,C,x),down:this.CreateCubemapTexture(M,this.FACE_DOWN,B,I,C,x),size:M,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(B,I,C,M,x){let y=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const f=new ArrayBuffer(B*B*4*3),L=new Float32Array(f),e=y?Math.max(1,Math.round(M/4/B)):1,g=1/e,N=g*g,R=I[1].FI(I[0]).scale(g/B),H=I[3].FI(I[2]).scale(g/B),F=1/B;let k=0;for(let q=0;q<B;q++)for(let y=0;y<e;y++){let y=I[0],f=I[2];for(let I=0;I<B;I++)for(let g=0;g<e;g++){const e=f.FI(y).scale(k).add(y);e.normalize();const g=this.CalcProjectionSpherical(e,C,M,x);L[q*B*3+3*I+0]+=g.r*N,L[q*B*3+3*I+1]+=g.g*N,L[q*B*3+3*I+2]+=g.b*N,y=y.add(R),f=f.add(H)}k+=F*g}return L}static CalcProjectionSpherical(B,I,C,M){let x=Math.atan2(B.z,B.x);const y=Math.acos(B.y);for(;x<-Math.PI;)x+=2*Math.PI;for(;x>Math.PI;)x-=2*Math.PI;let f=x/Math.PI;const L=y/Math.PI;f=.5*f+.5;let e=Math.round(f*C);e<0?e=0:e>=C&&(e=C-1);let g=Math.round(L*M);g<0?g=0:g>=M&&(g=M-1);const N=M-g-1;return{r:I[N*C*3+3*e+0],g:I[N*C*3+3*e+1],b:I[N*C*3+3*e+2]}}}function y(B,I,C,M,x,y){x>0?(x=function(B,I){return I>1023?B*Math.pow(2,1023)*Math.pow(2,I-1023):I<-1074?B*Math.pow(2,-1074)*Math.pow(2,I+1074):B*Math.pow(2,I)}(1,x-136),B[y+0]=I*x,B[y+1]=C*x,B[y+2]=M*x):(B[y+0]=0,B[y+1]=0,B[y+2]=0)}function f(B,I){let C="",M="";for(let x=I;x<B.length-I&&(M=String.fromCharCode(B[x]),"\n"!=M);x++)C+=M;return C}function L(B){let I=0,C=0,M=f(B,0);if("#"!=M[0]||"?"!=M[1])throw"Bad HDR Format.";let x=!1,y=!1,L=0;do{L+=M.length+1,M=f(B,L),"FORMAT=32-bit_rle_rgbe"==M?y=!0:0==M.length&&(x=!0)}while(!x);if(!y)throw"HDR Bad header format, unsupported FORMAT";L+=M.length+1,M=f(B,L);const e=/^-Y (.*) \+X (.*)$/g.exec(M);if(!e||e.length<3)throw"HDR Bad header format, no size";if(C=parseInt(e[2]),I=parseInt(e[1]),C<8||C>32767)throw"HDR Bad header format, unsupported size";return L+=M.length+1,{height:I,width:C,dataPosition:L}}function e(B,I){return function(B,I){let C=I.height;const M=I.width;let x,f,L,e,N,R=I.dataPosition,H=0,F=0,k=0;const q=new ArrayBuffer(4*M),S=new Uint8Array(q),o=new ArrayBuffer(I.width*I.height*4*3),U=new Float32Array(o);for(;C>0;){if(x=B[R++],f=B[R++],L=B[R++],e=B[R++],2!=x||2!=f||128&L||I.width<8||I.width>32767)return g(B,I);if((L<<8|e)!=M)throw"HDR Bad header format, wrong scan line width";for(H=0,k=0;k<4;k++)for(F=(k+1)*M;H<F;)if(x=B[R++],f=B[R++],x>128){if(N=x-128,0==N||N>F-H)throw"HDR Bad Format, bad scanline data (run)";for(;N-- >0;)S[H++]=f}else{if(N=x,0==N||N>F-H)throw"HDR Bad Format, bad scanline data (non-run)";if(S[H++]=f,--N>0)for(let I=0;I<N;I++)S[H++]=B[R++]}for(k=0;k<M;k++)x=S[k],f=S[k+M],L=S[k+2*M],e=S[k+3*M],y(U,x,f,L,e,(I.height-C)*M*3+3*k);C--}return U}(B,I)}function g(B,I){let C=I.height;const M=I.width;let x,f,L,e,g,N=I.dataPosition;const R=new ArrayBuffer(I.width*I.height*4*3),H=new Float32Array(R);for(;C>0;){for(g=0;g<I.width;g++)x=B[N++],f=B[N++],L=B[N++],e=B[N++],y(H,x,f,L,e,(I.height-C)*M*3+3*g);C--}return H}x.FACE_LEFT=[new M.HI(-1,-1,-1),new M.HI(1,-1,-1),new M.HI(-1,1,-1),new M.HI(1,1,-1)],x.FACE_RIGHT=[new M.HI(1,-1,1),new M.HI(-1,-1,1),new M.HI(1,1,1),new M.HI(-1,1,1)],x.FACE_FRONT=[new M.HI(1,-1,-1),new M.HI(1,-1,1),new M.HI(1,1,-1),new M.HI(1,1,1)],x.FACE_BACK=[new M.HI(-1,-1,1),new M.HI(-1,-1,-1),new M.HI(-1,1,1),new M.HI(-1,1,-1)],x.FACE_DOWN=[new M.HI(1,1,-1),new M.HI(1,1,1),new M.HI(-1,1,-1),new M.HI(-1,1,1)],x.FACE_UP=[new M.HI(-1,-1,-1),new M.HI(-1,-1,1),new M.HI(1,-1,-1),new M.HI(1,-1,1)];class N{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(B,I,C){const M=new Uint8Array(B.buffer,B.byteOffset,B.byteLength),x=L(M),y=e(M,x),f=x.width*x.height,g=new Float32Array(4*f);for(let L=0;L<f;L+=1)g[4*L]=y[3*L],g[4*L+1]=y[3*L+1],g[4*L+2]=y[3*L+2],g[4*L+3]=1;C(x.width,x.height,I.generateMipMaps,!1,(()=>{const B=I.getEngine();I.type=1,I.format=5,I._gammaSpace=!1,B._uploadDataToTextureDirectly(I,g)}))}}}}]);