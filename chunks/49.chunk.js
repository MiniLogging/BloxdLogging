"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[49],{14263:(Z,h,V)=>{V.r(h),V.d(h,{_HDRTextureLoader:()=>x});var v=V(11729);class A{static ConvertPanoramaToCubemap(Z,h,V,v){let A=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Z)throw"ConvertPanoramaToCubemap: input cannot be null";if(Z.length!=h*V*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(v,this.FACE_FRONT,Z,h,V,A),back:this.CreateCubemapTexture(v,this.FACE_BACK,Z,h,V,A),left:this.CreateCubemapTexture(v,this.FACE_LEFT,Z,h,V,A),right:this.CreateCubemapTexture(v,this.FACE_RIGHT,Z,h,V,A),up:this.CreateCubemapTexture(v,this.FACE_UP,Z,h,V,A),down:this.CreateCubemapTexture(v,this.FACE_DOWN,Z,h,V,A),size:v,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(Z,h,V,v,A){let H=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const K=new ArrayBuffer(Z*Z*4*3),d=new Float32Array(K),a=H?Math.max(1,Math.round(v/4/Z)):1,n=1/a,x=n*n,N=h[1].rh(h[0]).scale(n/Z),D=h[3].rh(h[2]).scale(n/Z),k=1/Z;let u=0;for(let F=0;F<Z;F++)for(let H=0;H<a;H++){let H=h[0],K=h[2];for(let h=0;h<Z;h++)for(let n=0;n<a;n++){const a=K.rh(H).scale(u).add(H);a.normalize();const n=this.CalcProjectionSpherical(a,V,v,A);d[F*Z*3+3*h+0]+=n.r*x,d[F*Z*3+3*h+1]+=n.g*x,d[F*Z*3+3*h+2]+=n.b*x,H=H.add(N),K=K.add(D)}u+=k*n}return d}static CalcProjectionSpherical(Z,h,V,v){let A=Math.atan2(Z.z,Z.x);const H=Math.acos(Z.y);for(;A<-Math.PI;)A+=2*Math.PI;for(;A>Math.PI;)A-=2*Math.PI;let K=A/Math.PI;const d=H/Math.PI;K=.5*K+.5;let a=Math.round(K*V);a<0?a=0:a>=V&&(a=V-1);let n=Math.round(d*v);n<0?n=0:n>=v&&(n=v-1);const x=v-n-1;return{r:h[x*V*3+3*a+0],g:h[x*V*3+3*a+1],b:h[x*V*3+3*a+2]}}}function H(Z,h,V,v,A,H){A>0?(A=function(Z,h){return h>1023?Z*Math.pow(2,1023)*Math.pow(2,h-1023):h<-1074?Z*Math.pow(2,-1074)*Math.pow(2,h+1074):Z*Math.pow(2,h)}(1,A-136),Z[H+0]=h*A,Z[H+1]=V*A,Z[H+2]=v*A):(Z[H+0]=0,Z[H+1]=0,Z[H+2]=0)}function K(Z,h){let V="",v="";for(let A=h;A<Z.length-h&&(v=String.fromCharCode(Z[A]),"\n"!=v);A++)V+=v;return V}function d(Z){let h=0,V=0,v=K(Z,0);if("#"!=v[0]||"?"!=v[1])throw"Bad HDR Format.";let A=!1,H=!1,d=0;do{d+=v.length+1,v=K(Z,d),"FORMAT=32-bit_rle_rgbe"==v?H=!0:0==v.length&&(A=!0)}while(!A);if(!H)throw"HDR Bad header format, unsupported FORMAT";d+=v.length+1,v=K(Z,d);const a=/^-Y (.*) \+X (.*)$/g.exec(v);if(!a||a.length<3)throw"HDR Bad header format, no size";if(V=parseInt(a[2]),h=parseInt(a[1]),V<8||V>32767)throw"HDR Bad header format, unsupported size";return d+=v.length+1,{height:h,width:V,dataPosition:d}}function a(Z,h){return function(Z,h){let V=h.height;const v=h.width;let A,K,d,a,x,N=h.dataPosition,D=0,k=0,u=0;const F=new ArrayBuffer(4*v),b=new Uint8Array(F),o=new ArrayBuffer(h.width*h.height*4*3),q=new Float32Array(o);for(;V>0;){if(A=Z[N++],K=Z[N++],d=Z[N++],a=Z[N++],2!=A||2!=K||128&d||h.width<8||h.width>32767)return n(Z,h);if((d<<8|a)!=v)throw"HDR Bad header format, wrong scan line width";for(D=0,u=0;u<4;u++)for(k=(u+1)*v;D<k;)if(A=Z[N++],K=Z[N++],A>128){if(x=A-128,0==x||x>k-D)throw"HDR Bad Format, bad scanline data (run)";for(;x-- >0;)b[D++]=K}else{if(x=A,0==x||x>k-D)throw"HDR Bad Format, bad scanline data (non-run)";if(b[D++]=K,--x>0)for(let h=0;h<x;h++)b[D++]=Z[N++]}for(u=0;u<v;u++)A=b[u],K=b[u+v],d=b[u+2*v],a=b[u+3*v],H(q,A,K,d,a,(h.height-V)*v*3+3*u);V--}return q}(Z,h)}function n(Z,h){let V=h.height;const v=h.width;let A,K,d,a,n,x=h.dataPosition;const N=new ArrayBuffer(h.width*h.height*4*3),D=new Float32Array(N);for(;V>0;){for(n=0;n<h.width;n++)A=Z[x++],K=Z[x++],d=Z[x++],a=Z[x++],H(D,A,K,d,a,(h.height-V)*v*3+3*n);V--}return D}A.FACE_LEFT=[new v.Ch(-1,-1,-1),new v.Ch(1,-1,-1),new v.Ch(-1,1,-1),new v.Ch(1,1,-1)],A.FACE_RIGHT=[new v.Ch(1,-1,1),new v.Ch(-1,-1,1),new v.Ch(1,1,1),new v.Ch(-1,1,1)],A.FACE_FRONT=[new v.Ch(1,-1,-1),new v.Ch(1,-1,1),new v.Ch(1,1,-1),new v.Ch(1,1,1)],A.FACE_BACK=[new v.Ch(-1,-1,1),new v.Ch(-1,-1,-1),new v.Ch(-1,1,1),new v.Ch(-1,1,-1)],A.FACE_DOWN=[new v.Ch(1,1,-1),new v.Ch(1,1,1),new v.Ch(-1,1,-1),new v.Ch(-1,1,1)],A.FACE_UP=[new v.Ch(-1,-1,-1),new v.Ch(-1,-1,1),new v.Ch(1,-1,-1),new v.Ch(1,-1,1)];class x{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(Z,h,V){const v=new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength),A=d(v),H=a(v,A),K=A.width*A.height,n=new Float32Array(4*K);for(let d=0;d<K;d+=1)n[4*d]=H[3*d],n[4*d+1]=H[3*d+1],n[4*d+2]=H[3*d+2],n[4*d+3]=1;V(A.width,A.height,h.generateMipMaps,!1,(()=>{const Z=h.getEngine();h.type=1,h.format=5,h._gammaSpace=!1,Z._uploadDataToTextureDirectly(h,n)}))}}}}]);