"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[49],{14792:(y,S,I)=>{I.r(S),I.d(S,{_HDRTextureLoader:()=>u});var V=I(12321);class i{static ConvertPanoramaToCubemap(y,S,I,V){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!y)throw"ConvertPanoramaToCubemap: input cannot be null";if(y.length!=S*I*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(V,this.FACE_FRONT,y,S,I,i),back:this.CreateCubemapTexture(V,this.FACE_BACK,y,S,I,i),left:this.CreateCubemapTexture(V,this.FACE_LEFT,y,S,I,i),right:this.CreateCubemapTexture(V,this.FACE_RIGHT,y,S,I,i),up:this.CreateCubemapTexture(V,this.FACE_UP,y,S,I,i),down:this.CreateCubemapTexture(V,this.FACE_DOWN,y,S,I,i),size:V,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(y,S,I,V,i){let A=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const B=new ArrayBuffer(y*y*4*3),d=new Float32Array(B),F=A?Math.max(1,Math.round(V/4/y)):1,J=1/F,u=J*J,K=S[1].fS(S[0]).scale(J/y),G=S[3].fS(S[2]).scale(J/y),p=1/y;let L=0;for(let T=0;T<y;T++)for(let A=0;A<F;A++){let A=S[0],B=S[2];for(let S=0;S<y;S++)for(let J=0;J<F;J++){const F=B.fS(A).scale(L).add(A);F.normalize();const J=this.CalcProjectionSpherical(F,I,V,i);d[T*y*3+3*S+0]+=J.r*u,d[T*y*3+3*S+1]+=J.g*u,d[T*y*3+3*S+2]+=J.b*u,A=A.add(K),B=B.add(G)}L+=p*J}return d}static CalcProjectionSpherical(y,S,I,V){let i=Math.atan2(y.z,y.x);const A=Math.acos(y.y);for(;i<-Math.PI;)i+=2*Math.PI;for(;i>Math.PI;)i-=2*Math.PI;let B=i/Math.PI;const d=A/Math.PI;B=.5*B+.5;let F=Math.round(B*I);F<0?F=0:F>=I&&(F=I-1);let J=Math.round(d*V);J<0?J=0:J>=V&&(J=V-1);const u=V-J-1;return{r:S[u*I*3+3*F+0],g:S[u*I*3+3*F+1],b:S[u*I*3+3*F+2]}}}function A(y,S,I,V,i,A){i>0?(i=function(y,S){return S>1023?y*Math.pow(2,1023)*Math.pow(2,S-1023):S<-1074?y*Math.pow(2,-1074)*Math.pow(2,S+1074):y*Math.pow(2,S)}(1,i-136),y[A+0]=S*i,y[A+1]=I*i,y[A+2]=V*i):(y[A+0]=0,y[A+1]=0,y[A+2]=0)}function B(y,S){let I="",V="";for(let i=S;i<y.length-S&&(V=String.fromCharCode(y[i]),"\n"!=V);i++)I+=V;return I}function d(y){let S=0,I=0,V=B(y,0);if("#"!=V[0]||"?"!=V[1])throw"Bad HDR Format.";let i=!1,A=!1,d=0;do{d+=V.length+1,V=B(y,d),"FORMAT=32-bit_rle_rgbe"==V?A=!0:0==V.length&&(i=!0)}while(!i);if(!A)throw"HDR Bad header format, unsupported FORMAT";d+=V.length+1,V=B(y,d);const F=/^-Y (.*) \+X (.*)$/g.exec(V);if(!F||F.length<3)throw"HDR Bad header format, no size";if(I=parseInt(F[2]),S=parseInt(F[1]),I<8||I>32767)throw"HDR Bad header format, unsupported size";return d+=V.length+1,{height:S,width:I,dataPosition:d}}function F(y,S){return function(y,S){let I=S.height;const V=S.width;let i,B,d,F,u,K=S.dataPosition,G=0,p=0,L=0;const T=new ArrayBuffer(4*V),l=new Uint8Array(T),j=new ArrayBuffer(S.width*S.height*4*3),s=new Float32Array(j);for(;I>0;){if(i=y[K++],B=y[K++],d=y[K++],F=y[K++],2!=i||2!=B||128&d||S.width<8||S.width>32767)return J(y,S);if((d<<8|F)!=V)throw"HDR Bad header format, wrong scan line width";for(G=0,L=0;L<4;L++)for(p=(L+1)*V;G<p;)if(i=y[K++],B=y[K++],i>128){if(u=i-128,0==u||u>p-G)throw"HDR Bad Format, bad scanline data (run)";for(;u-- >0;)l[G++]=B}else{if(u=i,0==u||u>p-G)throw"HDR Bad Format, bad scanline data (non-run)";if(l[G++]=B,--u>0)for(let S=0;S<u;S++)l[G++]=y[K++]}for(L=0;L<V;L++)i=l[L],B=l[L+V],d=l[L+2*V],F=l[L+3*V],A(s,i,B,d,F,(S.height-I)*V*3+3*L);I--}return s}(y,S)}function J(y,S){let I=S.height;const V=S.width;let i,B,d,F,J,u=S.dataPosition;const K=new ArrayBuffer(S.width*S.height*4*3),G=new Float32Array(K);for(;I>0;){for(J=0;J<S.width;J++)i=y[u++],B=y[u++],d=y[u++],F=y[u++],A(G,i,B,d,F,(S.height-I)*V*3+3*J);I--}return G}i.FACE_LEFT=[new V.OS(-1,-1,-1),new V.OS(1,-1,-1),new V.OS(-1,1,-1),new V.OS(1,1,-1)],i.FACE_RIGHT=[new V.OS(1,-1,1),new V.OS(-1,-1,1),new V.OS(1,1,1),new V.OS(-1,1,1)],i.FACE_FRONT=[new V.OS(1,-1,-1),new V.OS(1,-1,1),new V.OS(1,1,-1),new V.OS(1,1,1)],i.FACE_BACK=[new V.OS(-1,-1,1),new V.OS(-1,-1,-1),new V.OS(-1,1,1),new V.OS(-1,1,-1)],i.FACE_DOWN=[new V.OS(1,1,-1),new V.OS(1,1,1),new V.OS(-1,1,-1),new V.OS(-1,1,1)],i.FACE_UP=[new V.OS(-1,-1,-1),new V.OS(-1,-1,1),new V.OS(1,-1,-1),new V.OS(1,-1,1)];class u{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(y,S,I){const V=new Uint8Array(y.buffer,y.byteOffset,y.byteLength),i=d(V),A=F(V,i),B=i.width*i.height,J=new Float32Array(4*B);for(let d=0;d<B;d+=1)J[4*d]=A[3*d],J[4*d+1]=A[3*d+1],J[4*d+2]=A[3*d+2],J[4*d+3]=1;I(i.width,i.height,S.generateMipMaps,!1,(()=>{const y=S.getEngine();S.type=1,S.format=5,S._gammaSpace=!1,y._uploadDataToTextureDirectly(S,J)}))}}}}]);