"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[49],{15146:(K,A,T)=>{T.r(A),T.d(A,{_HDRTextureLoader:()=>Y});var G=T(12700);class B{static ConvertPanoramaToCubemap(K,A,T,G){let B=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!K)throw"ConvertPanoramaToCubemap: input cannot be null";if(K.length!=A*T*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(G,this.FACE_FRONT,K,A,T,B),back:this.CreateCubemapTexture(G,this.FACE_BACK,K,A,T,B),left:this.CreateCubemapTexture(G,this.FACE_LEFT,K,A,T,B),right:this.CreateCubemapTexture(G,this.FACE_RIGHT,K,A,T,B),up:this.CreateCubemapTexture(G,this.FACE_UP,K,A,T,B),down:this.CreateCubemapTexture(G,this.FACE_DOWN,K,A,T,B),size:G,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(K,A,T,G,B){let L=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const f=new ArrayBuffer(K*K*4*3),O=new Float32Array(f),C=L?Math.max(1,Math.round(G/4/K)):1,Q=1/C,Y=Q*Q,Z=A[1].FA(A[0]).scale(Q/K),x=A[3].FA(A[2]).scale(Q/K),J=1/K;let b=0;for(let P=0;P<K;P++)for(let L=0;L<C;L++){let L=A[0],f=A[2];for(let A=0;A<K;A++)for(let Q=0;Q<C;Q++){const C=f.FA(L).scale(b).add(L);C.normalize();const Q=this.CalcProjectionSpherical(C,T,G,B);O[P*K*3+3*A+0]+=Q.r*Y,O[P*K*3+3*A+1]+=Q.g*Y,O[P*K*3+3*A+2]+=Q.b*Y,L=L.add(Z),f=f.add(x)}b+=J*Q}return O}static CalcProjectionSpherical(K,A,T,G){let B=Math.atan2(K.z,K.x);const L=Math.acos(K.y);for(;B<-Math.PI;)B+=2*Math.PI;for(;B>Math.PI;)B-=2*Math.PI;let f=B/Math.PI;const O=L/Math.PI;f=.5*f+.5;let C=Math.round(f*T);C<0?C=0:C>=T&&(C=T-1);let Q=Math.round(O*G);Q<0?Q=0:Q>=G&&(Q=G-1);const Y=G-Q-1;return{r:A[Y*T*3+3*C+0],g:A[Y*T*3+3*C+1],b:A[Y*T*3+3*C+2]}}}function L(K,A,T,G,B,L){B>0?(B=function(K,A){return A>1023?K*Math.pow(2,1023)*Math.pow(2,A-1023):A<-1074?K*Math.pow(2,-1074)*Math.pow(2,A+1074):K*Math.pow(2,A)}(1,B-136),K[L+0]=A*B,K[L+1]=T*B,K[L+2]=G*B):(K[L+0]=0,K[L+1]=0,K[L+2]=0)}function f(K,A){let T="",G="";for(let B=A;B<K.length-A&&(G=String.fromCharCode(K[B]),"\n"!=G);B++)T+=G;return T}function O(K){let A=0,T=0,G=f(K,0);if("#"!=G[0]||"?"!=G[1])throw"Bad HDR Format.";let B=!1,L=!1,O=0;do{O+=G.length+1,G=f(K,O),"FORMAT=32-bit_rle_rgbe"==G?L=!0:0==G.length&&(B=!0)}while(!B);if(!L)throw"HDR Bad header format, unsupported FORMAT";O+=G.length+1,G=f(K,O);const C=/^-Y (.*) \+X (.*)$/g.exec(G);if(!C||C.length<3)throw"HDR Bad header format, no size";if(T=parseInt(C[2]),A=parseInt(C[1]),T<8||T>32767)throw"HDR Bad header format, unsupported size";return O+=G.length+1,{height:A,width:T,dataPosition:O}}function C(K,A){return function(K,A){let T=A.height;const G=A.width;let B,f,O,C,Y,Z=A.dataPosition,x=0,J=0,b=0;const P=new ArrayBuffer(4*G),F=new Uint8Array(P),d=new ArrayBuffer(A.width*A.height*4*3),N=new Float32Array(d);for(;T>0;){if(B=K[Z++],f=K[Z++],O=K[Z++],C=K[Z++],2!=B||2!=f||128&O||A.width<8||A.width>32767)return Q(K,A);if((O<<8|C)!=G)throw"HDR Bad header format, wrong scan line width";for(x=0,b=0;b<4;b++)for(J=(b+1)*G;x<J;)if(B=K[Z++],f=K[Z++],B>128){if(Y=B-128,0==Y||Y>J-x)throw"HDR Bad Format, bad scanline data (run)";for(;Y-- >0;)F[x++]=f}else{if(Y=B,0==Y||Y>J-x)throw"HDR Bad Format, bad scanline data (non-run)";if(F[x++]=f,--Y>0)for(let A=0;A<Y;A++)F[x++]=K[Z++]}for(b=0;b<G;b++)B=F[b],f=F[b+G],O=F[b+2*G],C=F[b+3*G],L(N,B,f,O,C,(A.height-T)*G*3+3*b);T--}return N}(K,A)}function Q(K,A){let T=A.height;const G=A.width;let B,f,O,C,Q,Y=A.dataPosition;const Z=new ArrayBuffer(A.width*A.height*4*3),x=new Float32Array(Z);for(;T>0;){for(Q=0;Q<A.width;Q++)B=K[Y++],f=K[Y++],O=K[Y++],C=K[Y++],L(x,B,f,O,C,(A.height-T)*G*3+3*Q);T--}return x}B.FACE_LEFT=[new G.PA(-1,-1,-1),new G.PA(1,-1,-1),new G.PA(-1,1,-1),new G.PA(1,1,-1)],B.FACE_RIGHT=[new G.PA(1,-1,1),new G.PA(-1,-1,1),new G.PA(1,1,1),new G.PA(-1,1,1)],B.FACE_FRONT=[new G.PA(1,-1,-1),new G.PA(1,-1,1),new G.PA(1,1,-1),new G.PA(1,1,1)],B.FACE_BACK=[new G.PA(-1,-1,1),new G.PA(-1,-1,-1),new G.PA(-1,1,1),new G.PA(-1,1,-1)],B.FACE_DOWN=[new G.PA(1,1,-1),new G.PA(1,1,1),new G.PA(-1,1,-1),new G.PA(-1,1,1)],B.FACE_UP=[new G.PA(-1,-1,-1),new G.PA(-1,-1,1),new G.PA(1,-1,-1),new G.PA(1,-1,1)];class Y{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(K,A,T){const G=new Uint8Array(K.buffer,K.byteOffset,K.byteLength),B=O(G),L=C(G,B),f=B.width*B.height,Q=new Float32Array(4*f);for(let O=0;O<f;O+=1)Q[4*O]=L[3*O],Q[4*O+1]=L[3*O+1],Q[4*O+2]=L[3*O+2],Q[4*O+3]=1;T(B.width,B.height,A.generateMipMaps,!1,(()=>{const K=A.getEngine();A.type=1,A.format=5,A._gammaSpace=!1,K._uploadDataToTextureDirectly(A,Q)}))}}}}]);