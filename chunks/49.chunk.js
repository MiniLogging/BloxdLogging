"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[49],{15098:(M,A,O)=>{O.r(A),O.d(A,{_HDRTextureLoader:()=>g});var S=O(12970);class z{static ConvertPanoramaToCubemap(M,A,O,S){let z=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!M)throw"ConvertPanoramaToCubemap: input cannot be null";if(M.length!=A*O*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(S,this.FACE_FRONT,M,A,O,z),back:this.CreateCubemapTexture(S,this.FACE_BACK,M,A,O,z),left:this.CreateCubemapTexture(S,this.FACE_LEFT,M,A,O,z),right:this.CreateCubemapTexture(S,this.FACE_RIGHT,M,A,O,z),up:this.CreateCubemapTexture(S,this.FACE_UP,M,A,O,z),down:this.CreateCubemapTexture(S,this.FACE_DOWN,M,A,O,z),size:S,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(M,A,O,S,z){let Q=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const X=new ArrayBuffer(M*M*4*3),c=new Float32Array(X),j=Q?Math.max(1,Math.round(S/4/M)):1,B=1/j,g=B*B,e=A[1].dA(A[0]).scale(B/M),T=A[3].dA(A[2]).scale(B/M),J=1/M;let K=0;for(let G=0;G<M;G++)for(let Q=0;Q<j;Q++){let Q=A[0],X=A[2];for(let A=0;A<M;A++)for(let B=0;B<j;B++){const j=X.dA(Q).scale(K).add(Q);j.normalize();const B=this.CalcProjectionSpherical(j,O,S,z);c[G*M*3+3*A+0]+=B.r*g,c[G*M*3+3*A+1]+=B.g*g,c[G*M*3+3*A+2]+=B.b*g,Q=Q.add(e),X=X.add(T)}K+=J*B}return c}static CalcProjectionSpherical(M,A,O,S){let z=Math.atan2(M.z,M.x);const Q=Math.acos(M.y);for(;z<-Math.PI;)z+=2*Math.PI;for(;z>Math.PI;)z-=2*Math.PI;let X=z/Math.PI;const c=Q/Math.PI;X=.5*X+.5;let j=Math.round(X*O);j<0?j=0:j>=O&&(j=O-1);let B=Math.round(c*S);B<0?B=0:B>=S&&(B=S-1);const g=S-B-1;return{r:A[g*O*3+3*j+0],g:A[g*O*3+3*j+1],b:A[g*O*3+3*j+2]}}}function Q(M,A,O,S,z,Q){z>0?(z=function(M,A){return A>1023?M*Math.pow(2,1023)*Math.pow(2,A-1023):A<-1074?M*Math.pow(2,-1074)*Math.pow(2,A+1074):M*Math.pow(2,A)}(1,z-136),M[Q+0]=A*z,M[Q+1]=O*z,M[Q+2]=S*z):(M[Q+0]=0,M[Q+1]=0,M[Q+2]=0)}function X(M,A){let O="",S="";for(let z=A;z<M.length-A&&(S=String.fromCharCode(M[z]),"\n"!=S);z++)O+=S;return O}function c(M){let A=0,O=0,S=X(M,0);if("#"!=S[0]||"?"!=S[1])throw"Bad HDR Format.";let z=!1,Q=!1,c=0;do{c+=S.length+1,S=X(M,c),"FORMAT=32-bit_rle_rgbe"==S?Q=!0:0==S.length&&(z=!0)}while(!z);if(!Q)throw"HDR Bad header format, unsupported FORMAT";c+=S.length+1,S=X(M,c);const j=/^-Y (.*) \+X (.*)$/g.exec(S);if(!j||j.length<3)throw"HDR Bad header format, no size";if(O=parseInt(j[2]),A=parseInt(j[1]),O<8||O>32767)throw"HDR Bad header format, unsupported size";return c+=S.length+1,{height:A,width:O,dataPosition:c}}function j(M,A){return function(M,A){let O=A.height;const S=A.width;let z,X,c,j,g,e=A.dataPosition,T=0,J=0,K=0;const G=new ArrayBuffer(4*S),d=new Uint8Array(G),w=new ArrayBuffer(A.width*A.height*4*3),I=new Float32Array(w);for(;O>0;){if(z=M[e++],X=M[e++],c=M[e++],j=M[e++],2!=z||2!=X||128&c||A.width<8||A.width>32767)return B(M,A);if((c<<8|j)!=S)throw"HDR Bad header format, wrong scan line width";for(T=0,K=0;K<4;K++)for(J=(K+1)*S;T<J;)if(z=M[e++],X=M[e++],z>128){if(g=z-128,0==g||g>J-T)throw"HDR Bad Format, bad scanline data (run)";for(;g-- >0;)d[T++]=X}else{if(g=z,0==g||g>J-T)throw"HDR Bad Format, bad scanline data (non-run)";if(d[T++]=X,--g>0)for(let A=0;A<g;A++)d[T++]=M[e++]}for(K=0;K<S;K++)z=d[K],X=d[K+S],c=d[K+2*S],j=d[K+3*S],Q(I,z,X,c,j,(A.height-O)*S*3+3*K);O--}return I}(M,A)}function B(M,A){let O=A.height;const S=A.width;let z,X,c,j,B,g=A.dataPosition;const e=new ArrayBuffer(A.width*A.height*4*3),T=new Float32Array(e);for(;O>0;){for(B=0;B<A.width;B++)z=M[g++],X=M[g++],c=M[g++],j=M[g++],Q(T,z,X,c,j,(A.height-O)*S*3+3*B);O--}return T}z.FACE_LEFT=[new S.GA(-1,-1,-1),new S.GA(1,-1,-1),new S.GA(-1,1,-1),new S.GA(1,1,-1)],z.FACE_RIGHT=[new S.GA(1,-1,1),new S.GA(-1,-1,1),new S.GA(1,1,1),new S.GA(-1,1,1)],z.FACE_FRONT=[new S.GA(1,-1,-1),new S.GA(1,-1,1),new S.GA(1,1,-1),new S.GA(1,1,1)],z.FACE_BACK=[new S.GA(-1,-1,1),new S.GA(-1,-1,-1),new S.GA(-1,1,1),new S.GA(-1,1,-1)],z.FACE_DOWN=[new S.GA(1,1,-1),new S.GA(1,1,1),new S.GA(-1,1,-1),new S.GA(-1,1,1)],z.FACE_UP=[new S.GA(-1,-1,-1),new S.GA(-1,-1,1),new S.GA(1,-1,-1),new S.GA(1,-1,1)];class g{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(M,A,O){const S=new Uint8Array(M.buffer,M.byteOffset,M.byteLength),z=c(S),Q=j(S,z),X=z.width*z.height,B=new Float32Array(4*X);for(let c=0;c<X;c+=1)B[4*c]=Q[3*c],B[4*c+1]=Q[3*c+1],B[4*c+2]=Q[3*c+2],B[4*c+3]=1;O(z.width,z.height,A.generateMipMaps,!1,(()=>{const M=A.getEngine();A.type=1,A.format=5,A._gammaSpace=!1,M._uploadDataToTextureDirectly(A,B)}))}}}}]);