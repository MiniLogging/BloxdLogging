"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13907:(P,Q,O)=>{O.r(Q),O.d(Q,{AnimationGroup:()=>K,TargetedAnimation:()=>r});var b=O(12759),F=O(537),g=O(598),m=O(715),q=O(12757),R=O(751);class X{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(P,Q,O,F){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=Q,this._target=P,this._scene=O,this._host=F,this._activeTargets=[],Q._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===b.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=R.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const P={frame:0,value:this._minValue};this._keys.splice(0,0,P)}if(this._target instanceof Array){let P=0;for(const Q of this._target)this._preparePath(Q,P),this._getOriginalValues(P),P++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const g=Q.getEvents();if(g&&g.length>0)for(const b of g)this._events.push(b._clone());this._enableBlending=P&&P.animationPropertiesOverride?P.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(P){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const O=this._animation.targetPropertyPath;if(O.length>1){let b=P;for(let P=0;P<O.length-1;P++){const Q=O[P];if(b=b[Q],void 0===b)throw new Error(`Invalid property (${Q}) in property path (${O.join(".")})`)}this._targetPath=O[O.length-1],this._activeTargets[Q]=b}else this._targetPath=O[0],this._activeTargets[Q]=P;if(void 0===this._activeTargets[Q][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${O.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let P=0;for(const Q of this._target)void 0!==this._originalValue[P]&&this._setValue(Q,this._activeTargets[P],this._originalValue[P],-1,P),P++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let P=0;P<this._events.length;P++)this._events[P].isDone=!1}isStopped(){return this._stopped}dispose(){const P=this._animation.runtimeAnimations.indexOf(this);P>-1&&this._animation.runtimeAnimations.splice(P,1)}setValue(P,Q){if(this._targetIsArray)for(let O=0;O<this._target.length;O++){const b=this._target[O];this._setValue(b,this._activeTargets[O],P,Q,O)}else this._setValue(this._target,this._directTarget,P,Q,0)}_getOriginalValues(){let P,Q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const O=this._activeTargets[Q];P=O.getLocalMatrix&&"_matrix"===this._targetPath?O.getLocalMatrix():O[this._targetPath],P&&P.clone?this._originalValue[Q]=P.clone():this._originalValue[Q]=P}_registerTargetForLateAnimationBinding(P,Q){const O=P.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(O),O._lateAnimationHolders||(O._lateAnimationHolders={}),O._lateAnimationHolders[P.targetPath]||(O._lateAnimationHolders[P.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:Q}),P.isAdditive?(O._lateAnimationHolders[P.targetPath].additiveAnimations.push(P),O._lateAnimationHolders[P.targetPath].totalAdditiveWeight+=P.weight):(O._lateAnimationHolders[P.targetPath].animations.push(P),O._lateAnimationHolders[P.targetPath].totalWeight+=P.weight)}_setValue(P,Q,O,F,g){if(this._currentActiveTarget=Q,this._weight=F,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const P=Q[this._targetPath];P.clone?this._originalBlendValue=P.clone():this._originalBlendValue=P}this._originalBlendValue.m?b.b.AllowMatrixDecomposeForInterpolation?this._currentValue?R.c.DecomposeLerpToRef(this._originalBlendValue,O,this._blendingFactor,this._currentValue):this._currentValue=R.c.DecomposeLerp(this._originalBlendValue,O,this._blendingFactor):this._currentValue?R.c.LerpToRef(this._originalBlendValue,O,this._blendingFactor,this._currentValue):this._currentValue=R.c.Lerp(this._originalBlendValue,O,this._blendingFactor):this._currentValue=b.b._UniversalLerp(this._originalBlendValue,O,this._blendingFactor);const F=P&&P.animationPropertiesOverride?P.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=F}else this._currentValue?this._currentValue.p?this._currentValue.p(O):this._currentValue=O:null!==O&&void 0!==O&&O.clone?this._currentValue=O.clone():this._currentValue=O;-1!==F?this._registerTargetForLateAnimationBinding(this,this._originalValue[g]):this._animationState.loopMode===b.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[g],Q[this._targetPath]):Q[this._targetPath]=this._originalValue[g]+this._currentValue:Q[this._targetPath]=this._currentValue,P._j&&P._j(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(P){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const O=this._animation.getKeys();P<O[0].frame?P=O[0].frame:P>O[O.length-1].frame&&(P=O[O.length-1].frame);const b=this._events;if(b.length)for(let g=0;g<b.length;g++)b[g].onlyOnce||(b[g].isDone=b[g].frame<P);this._currentFrame=P;const F=this._animation._interpolate(P,this._animationState);this.setValue(F,Q)}_prepareForSpeedRatioChange(P){const Q=this._previousElapsedTime*(this._animation.framePerSecond*P)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-Q}animate(P,Q,O,F,g){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const q=this._animation,R=q.targetPropertyPath;if(!R||R.length<1)return this._stopped=!0,!1;let X,C=!0;const L=this._events;let G=0;if(this._coreRuntimeAnimation)G=O-Q,X=this._coreRuntimeAnimation.currentFrame,this._currentFrame=X,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let m;(Q<this._minFrame||Q>this._maxFrame)&&(Q=this._minFrame),(O<this._minFrame||O>this._maxFrame)&&(O=this._maxFrame),G=O-Q;let R=P*(q.framePerSecond*g)/1e3+this._absoluteFrameOffset,A=0,j=!1;const w=F&&this._animationState.loopMode===b.b.ANIMATIONLOOPMODE_YOYO;if(w){const P=(R-Q)/G,O=Math.sin(P*Math.PI);R=Math.abs(O)*G+Q;const b=O>=0?1:-1;this._yoyoDirection!==b&&(j=!0),this._yoyoDirection=b}if(this._previousElapsedTime=P,this._previousAbsoluteFrame=R,!F&&O>=Q&&(R>=G&&g>0||R<=0&&g<0))C=!1,A=q._getKeyValue(this._maxValue);else if(!F&&Q>=O&&(R<=G&&g<0||R>=0&&g>0))C=!1,A=q._getKeyValue(this._minValue);else if(this._animationState.loopMode!==b.b.ANIMATIONLOOPMODE_CYCLE){const P=O.toString()+Q.toString();if(!this._offsetsCache[P]){this._animationState.repeatCount=0,this._animationState.loopMode=b.b.ANIMATIONLOOPMODE_CYCLE;const F=q._interpolate(Q,this._animationState),g=q._interpolate(O,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),q.dataType){case b.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[P]=g-F;break;case b.b.ANIMATIONTYPE_QUATERNION:case b.b.ANIMATIONTYPE_VECTOR3:case b.b.ANIMATIONTYPE_VECTOR2:case b.b.ANIMATIONTYPE_SIZE:case b.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[P]=g.ae(F)}this._highLimitsCache[P]=g}A=this._highLimitsCache[P],m=this._offsetsCache[P]}if(void 0===m)switch(q.dataType){case b.b.ANIMATIONTYPE_FLOAT:m=0;break;case b.b.ANIMATIONTYPE_QUATERNION:m=b.h;break;case b.b.ANIMATIONTYPE_VECTOR3:m=b.o;break;case b.b.ANIMATIONTYPE_VECTOR2:m=b.k;break;case b.b.ANIMATIONTYPE_SIZE:m=b.j;break;case b.b.ANIMATIONTYPE_COLOR3:m=b.d;break;case b.b.ANIMATIONTYPE_COLOR4:m=b.e}if(this._host&&this._host.syncRoot){const P=this._host.syncRoot;X=Q+G*((P.masterFrame-P.fromFrame)/(P.toFrame-P.fromFrame))}else X=R>0&&Q>O||R<0&&Q<O?C&&0!==G?O+R%G:Q:C&&0!==G?Q+R%G:O;if(!w&&(g>0&&this.currentFrame>X||g<0&&this.currentFrame<X)||w&&j){this._onLoop();for(let P=0;P<L.length;P++)L[P].onlyOnce||(L[P].isDone=!1);this._animationState.key=g>0?0:q.getKeys().length-1}this._currentFrame=X,this._animationState.repeatCount=0===G?0:R/G|0,this._animationState.highLimitValue=A,this._animationState.offsetValue=m}const A=q._interpolate(X,this._animationState);if(this.setValue(A,m),L.length)for(let b=0;b<L.length;b++)if(G>=0&&X>=L[b].frame&&L[b].frame>=Q||G<0&&X<=L[b].frame&&L[b].frame<=Q){const P=L[b];P.isDone||(P.onlyOnce&&(L.splice(b,1),b--),P.isDone=!0,P.action(X))}return C||(this._stopped=!0),C}}var C=O(574);class L{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(P){this._weight=-1!==P?Math.min(Math.max(P,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(P){for(let Q=0;Q<this._runtimeAnimations.length;Q++){this._runtimeAnimations[Q]._prepareForSpeedRatioChange(P)}this._speedRatio=P,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(P,Q){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,g=arguments.length>4&&void 0!==arguments[4]&&arguments[4],m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,q=arguments.length>6?arguments[6]:void 0,R=arguments.length>7?arguments[7]:void 0,X=arguments.length>8?arguments[8]:void 0,C=arguments.length>9&&void 0!==arguments[9]&&arguments[9],L=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=Q,this.fromFrame=O,this.toFrame=b,this.loopAnimation=g,this.onAnimationEnd=q,this.onAnimationLoop=X,this.isAdditive=C,this.playOrder=L,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Wj=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new F.d,this.onAnimationLoopObservable=new F.d,this._scene=P,R&&this.appendAnimations(Q,R),this._speedRatio=m,P._activeAnimatables.push(this)}syncWith(P){if(this._syncRoot=P,P){const P=this._scene._activeAnimatables.indexOf(this);P>-1&&(this._scene._activeAnimatables.splice(P,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(P,Q){for(let O=0;O<Q.length;O++){const b=Q[O],F=new X(P,b,this._scene,this);F._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(F)}}getAnimationByTargetProperty(P){const Q=this._runtimeAnimations;for(let O=0;O<Q.length;O++)if(Q[O].animation.targetProperty===P)return Q[O].animation;return null}getRuntimeAnimationByTargetProperty(P){const Q=this._runtimeAnimations;for(let O=0;O<Q.length;O++)if(Q[O].animation.targetProperty===P)return Q[O];return null}reset(){const P=this._runtimeAnimations;for(let Q=0;Q<P.length;Q++)P[Q].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(P){const Q=this._runtimeAnimations;for(let O=0;O<Q.length;O++)Q[O].animation.enableBlending=!0,Q[O].animation.blendingSpeed=P}disableBlending(){const P=this._runtimeAnimations;for(let Q=0;Q<P.length;Q++)P[Q].animation.enableBlending=!1}goToFrame(P){let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const O=this._runtimeAnimations;if(O[0]){const Q=O[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??O[0].currentFrame;const b=0===this.speedRatio?0:(P-this._frameToSyncFromJump)/Q*1e3/this.speedRatio;this._manualJumpDelay=-b}for(let b=0;b<O.length;b++)O[b].goToFrame(P,Q?this._weight:-1);this._goToFrame=P}get paused(){return this.Wj}pause(){this.Wj||(this.Wj=!0)}restart(){this.Wj=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(P,Q){let O=arguments.length>2&&void 0!==arguments[2]&&arguments[2],b=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(P||Q){const F=this._scene._activeAnimatables.indexOf(this);if(F>-1){const g=this._runtimeAnimations;for(let O=g.length-1;O>=0;O--){const b=g[O];P&&b.animation.name!=P||(Q&&!Q(b.target)||(b.dispose(),g.splice(O,1)))}0==g.length&&(O||this._scene._activeAnimatables.splice(F,1),b||this._raiseOnAnimationEnd())}}else{const P=this._scene._activeAnimatables.indexOf(this);if(P>-1){O||this._scene._activeAnimatables.splice(P,1);const Q=this._runtimeAnimations;for(let P=0;P<Q.length;P++)Q[P].dispose();this._runtimeAnimations.length=0,b||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((P=>{this.onAnimationEndObservable.add((()=>{P(this)}),void 0,void 0,this,!0)}))}_animate(P){if(this.Wj)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=P),!0;if(null===this._localDelayOffset?(this._localDelayOffset=P,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=P-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let Q=!1;const O=this._runtimeAnimations;let b;for(b=0;b<O.length;b++){const F=O[b].animate(P-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);Q=Q||F}if(this.animationStarted=Q,!Q){if(this.disposeOnEnd)for(b=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(b,1),b=0;b<O.length;b++)O[b].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return Q}}function G(P){if(0===P.totalWeight&&0===P.totalAdditiveWeight)return P.originalValue;let Q=1;const O=R.f.dk[0],b=R.f.dk[1],F=R.f.Quaternion[0];let g=0;const m=P.animations[0],q=P.originalValue;let X=1,C=!1;if(P.totalWeight<1)X=1-P.totalWeight,q.decompose(b,F,O);else{if(g=1,Q=P.totalWeight,X=m.weight/Q,1==X){if(!P.totalAdditiveWeight)return m.currentValue;C=!0}m.currentValue.decompose(b,F,O)}if(!C){b.scaleInPlace(X),O.scaleInPlace(X),F.scaleInPlace(X);for(let m=g;m<P.animations.length;m++){const g=P.animations[m];if(0===g.weight)continue;X=g.weight/Q;const q=R.f.dk[2],C=R.f.dk[3],L=R.f.Quaternion[1];g.currentValue.decompose(C,L,q),C.scaleAndAddToRef(X,b),L.scaleAndAddToRef(R.d.Dot(F,L)>0?X:-X,F),q.scaleAndAddToRef(X,O)}F.normalize()}for(let G=0;G<P.additiveAnimations.length;G++){const Q=P.additiveAnimations[G];if(0===Q.weight)continue;const g=R.f.dk[2],m=R.f.dk[3],q=R.f.Quaternion[1];Q.currentValue.decompose(m,q,g),m.multiplyToRef(b,m),R.j.LerpToRef(b,m,Q.weight,b),F.multiplyToRef(q,q),R.d.SlerpToRef(F,q,Q.weight,F),g.scaleAndAddToRef(Q.weight,O)}const L=m?m._animationState.workValue:R.f.Matrix[0].clone();return R.c.ComposeToRef(b,F,O,L),L}function A(P,Q){if(0===P.totalWeight&&0===P.totalAdditiveWeight)return Q;const O=P.animations[0],b=P.originalValue;let F=Q;if(0===P.totalWeight&&P.totalAdditiveWeight>0)F.p(b);else if(1===P.animations.length){if(R.d.SlerpToRef(b,O.currentValue,Math.min(1,P.totalWeight),F),0===P.totalAdditiveWeight)return F}else if(P.animations.length>1){let O,g,m=1;if(P.totalWeight<1){const Q=1-P.totalWeight;O=[],g=[],O.push(b),g.push(Q)}else{if(2===P.animations.length&&(R.d.SlerpToRef(P.animations[0].currentValue,P.animations[1].currentValue,P.animations[1].weight/P.totalWeight,Q),0===P.totalAdditiveWeight))return Q;O=[],g=[],m=P.totalWeight}for(let Q=0;Q<P.animations.length;Q++){const b=P.animations[Q];O.push(b.currentValue),g.push(b.weight/m)}let q=0;for(let P=0;P<O.length;)P?(q+=g[P],R.d.SlerpToRef(F,O[P],g[P]/q,F),P++):(R.d.SlerpToRef(O[P],O[P+1],g[P+1]/(g[P]+g[P+1]),Q),F=Q,q=g[P]+g[P+1],P+=2)}for(let g=0;g<P.additiveAnimations.length;g++){const Q=P.additiveAnimations[g];0!==Q.weight&&(F.multiplyToRef(Q.currentValue,R.f.Quaternion[0]),R.d.SlerpToRef(F,R.f.Quaternion[0],Q.weight,F))}return F}var j,w,W=O(2608);j=W.e,(w=q.d)&&(w.prototype.copyAnimationRange=function(P,Q,O){let F=arguments.length>3&&void 0!==arguments[3]&&arguments[3],g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new b.b(this.name,"_matrix",P.animations[0].framePerSecond,b.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const m=P.animations[0].getRange(Q);if(!m)return!1;const q=m.from,R=m.to,X=P.animations[0].getKeys(),C=P.length,L=P.getParent(),G=this.getParent(),A=F&&L&&C&&this.length&&C!==this.length,j=A&&G&&L?G.length/L.length:1,w=F&&!G&&g&&(1!==g.x||1!==g.y||1!==g.z),W=this.animations[0].getKeys();let r,K,T;for(let b=0,x=X.length;b<x;b++)r=X[b],r.frame>=q&&r.frame<=R&&(F?(T=r.value.clone(),A?(K=T.getTranslation(),T.setTranslation(K.scaleInPlace(j))):w&&g?(K=T.getTranslation(),T.setTranslation(K.multiplyInPlace(g))):T=r.value):T=r.value,W.push({frame:r.frame+O,value:T}));return this.animations[0].createRange(Q,q+O,R+O),!0}),j&&(j.prototype._animate=function(P){if(!this.animationsEnabled)return;const Q=C.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=Q}this.deltaTime=void 0!==P?P:this.useConstantAnimationDeltaTime?16:(Q-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=Q;const O=this._activeAnimatables;if(0===O.length)return;this._animationTime+=this.deltaTime;const F=this._animationTime;for(let b=0;b<O.length;b++){const P=O[b];!P._animate(F)&&P.disposeOnEnd&&b--}!function(P){if(P._registeredForLateAnimationBindings.length){for(let Q=0;Q<P._registeredForLateAnimationBindings.length;Q++){const O=P._registeredForLateAnimationBindings.data[Q];for(const P in O._lateAnimationHolders){const Q=O._lateAnimationHolders[P],F=Q.animations[0],g=Q.originalValue;if(void 0===g||null===g)continue;const m=b.b.AllowMatrixDecomposeForInterpolation&&g.m;let q=O[P];if(m)q=G(Q);else if(void 0!==g.w)q=A(Q,q||R.d.Identity());else{let P=0,O=1;const m=F&&F._animationState.loopMode===b.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(Q.totalWeight<1)q=m?g.clone?g.clone():g:F&&g.scale?g.scale(1-Q.totalWeight):F?g*(1-Q.totalWeight):g.clone?g.clone():g;else if(F){O=Q.totalWeight;const b=F.weight/O;q=1!==b?F.currentValue.scale?F.currentValue.scale(b):F.currentValue*b:F.currentValue,m&&(q.addToRef?q.addToRef(g,q):q+=g),P=1}for(let b=P;b<Q.animations.length;b++){const P=Q.animations[b],F=P.weight/O;F&&(P.currentValue.scaleAndAddToRef?P.currentValue.scaleAndAddToRef(F,q):q+=P.currentValue*F)}for(let b=0;b<Q.additiveAnimations.length;b++){const P=Q.additiveAnimations[b],O=P.weight;O&&(P.currentValue.scaleAndAddToRef?P.currentValue.scaleAndAddToRef(O,q):q+=P.currentValue*O)}}O[P]=q}O._lateAnimationHolders={}}P._registeredForLateAnimationBindings.reset()}}(this)},j.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((P,Q)=>P.playOrder-Q.playOrder))},j.prototype.beginWeightedAnimation=function(P,Q,O){let b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,F=arguments.length>4?arguments[4]:void 0,g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,m=arguments.length>6?arguments[6]:void 0,q=arguments.length>7?arguments[7]:void 0,R=arguments.length>8?arguments[8]:void 0,X=arguments.length>9?arguments[9]:void 0,C=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const L=this.beginAnimation(P,Q,O,F,g,m,q,!1,R,X,C);return L.weight=b,L},j.prototype.beginAnimation=function(P,Q,O,b){let F=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,g=arguments.length>5?arguments[5]:void 0,m=arguments.length>6?arguments[6]:void 0,q=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],R=arguments.length>8?arguments[8]:void 0,X=arguments.length>9?arguments[9]:void 0,C=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(F<0){const P=Q;Q=O,O=P,F=-F}Q>O&&(F=-F),q&&this.stopAnimation(P,void 0,R),m||(m=new L(this,P,Q,O,b,F,g,void 0,X,C));const G=!R||R(P);if(P.animations&&G&&m.appendAnimations(P,P.animations),P.getAnimatables){const C=P.getAnimatables();for(let P=0;P<C.length;P++)this.beginAnimation(C[P],Q,O,b,F,g,m,q,R,X)}return m.reset(),m},j.prototype.beginHierarchyAnimation=function(P,Q,O,b,F){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,m=arguments.length>6?arguments[6]:void 0,q=arguments.length>7?arguments[7]:void 0,R=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],X=arguments.length>9?arguments[9]:void 0,C=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const L=P.getDescendants(Q),G=[];G.push(this.beginAnimation(P,O,b,F,g,m,q,R,X,void 0,C));for(const A of L)G.push(this.beginAnimation(A,O,b,F,g,m,q,R,X,void 0,C));return G},j.prototype.beginDirectAnimation=function(P,Q,O,b,F){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(g<0){const P=O;O=b,b=P,g=-g}return O>b&&(g=-g),new L(this,P,O,b,F,g,arguments.length>6?arguments[6]:void 0,Q,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},j.prototype.beginDirectHierarchyAnimation=function(P,Q,O,b,F,g,m,q,R){let X=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const C=P.getDescendants(Q),L=[];L.push(this.beginDirectAnimation(P,O,b,F,g,m,q,R,X));for(const G of C)L.push(this.beginDirectAnimation(G,O,b,F,g,m,q,R,X));return L},j.prototype.getAnimatableByTarget=function(P){for(let Q=0;Q<this._activeAnimatables.length;Q++)if(this._activeAnimatables[Q].target===P)return this._activeAnimatables[Q];return null},j.prototype.getAllAnimatablesByTarget=function(P){const Q=[];for(let O=0;O<this._activeAnimatables.length;O++)this._activeAnimatables[O].target===P&&Q.push(this._activeAnimatables[O]);return Q},j.prototype.stopAnimation=function(P,Q,O){const b=this.getAllAnimatablesByTarget(P);for(const F of b)F.stop(Q,O)},j.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let P=0;P<this._activeAnimatables.length;P++)this._activeAnimatables[P].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const P of this.animationGroups)P.stop()});class r{getClassName(){return"TargetedAnimation"}serialize(){const P={};return P.animation=this.animation.serialize(),P.targetId=this.target.id,P}}class K{get mask(){return this._mask}set mask(P){this._mask!==P&&(this._mask=P,this.syncWithMask(!0))}syncWithMask(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||P){this._numActiveAnimatables=0;for(let P=0;P<this._animatables.length;++P){const Q=this._animatables[P];!this.mask||this.mask.disabled||this.mask.retainsTarget(Q.target.name)?(this._numActiveAnimatables++,Q.paused&&Q.restart()):Q.paused||Q.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let P=0;P<this._animatables.length;++P){const Q=this._animatables[P];this.mask.retainsTarget(Q.target.name)||(Q.stop(),this._animatables.splice(P,1),--P)}for(let P=0;P<this._targetedAnimations.length;P++){const Q=this._targetedAnimations[P];this.mask.retainsTarget(Q.target.name)||(this._targetedAnimations.splice(P,1),--P)}}}get from(){return this._from}set from(P){if(this._from!==P){this._from=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].fromFrame=this._from}}}get to(){return this._to}set to(P){if(this._to!==P){this._to=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(P){if(this._speedRatio!==P){this._speedRatio=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(P){if(this._loopAnimation!==P){this._loopAnimation=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(P){if(this._isAdditive!==P){this._isAdditive=P;for(let P=0;P<this._animatables.length;P++){this._animatables[P].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(P){this._weight!==P&&(this._weight=P,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(P){if(this._playOrder!==P&&(this._playOrder=P,this._animatables.length>0)){for(let P=0;P<this._animatables.length;P++)this._animatables[P].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(P){if(this._enableBlending!==P&&(this._enableBlending=P,null!==P))for(let Q=0;Q<this._targetedAnimations.length;++Q)this._targetedAnimations[Q].animation.enableBlending=P}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(P){if(this._blendingSpeed!==P&&(this._blendingSpeed=P,null!==P))for(let Q=0;Q<this._targetedAnimations.length;++Q)this._targetedAnimations[Q].animation.blendingSpeed=P}getLength(P,Q){P=P??this._from;return((Q=Q??this._to)-P)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(P){let Q=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],O=arguments.length>2&&void 0!==arguments[2]&&arguments[2],b=arguments.length>3?arguments[3]:void 0;if(0===P.length)return null;b=b??P[0].weight;let F=Number.MAX_VALUE,g=-Number.MAX_VALUE;if(O)for(const q of P)q.from<F&&(F=q.from),q.to>g&&(g=q.to);const m=new K(P[0].name+"_merged",P[0]._scene,b);for(const q of P){O&&q.normalize(F,g);for(const P of q.targetedAnimations)m.addTargetedAnimation(P.animation,P.target);Q&&q.dispose()}return m}constructor(P){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=P,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new F.d,this.onAnimationLoopObservable=new F.d,this.onAnimationGroupLoopObservable=new F.d,this.onAnimationGroupEndObservable=new F.d,this.onAnimationGroupPauseObservable=new F.d,this.onAnimationGroupPlayObservable=new F.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=Q||g.c.LastCreatedScene,this._weight=O,this._playOrder=b,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(P,Q){const O=new r;O.animation=P,O.target=Q;const b=P.getKeys();return this._from>b[0].frame&&(this._from=b[0].frame),this._to<b[b.length-1].frame&&(this._to=b[b.length-1].frame),null!==this._enableBlending&&(P.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(P.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(O),this._shouldStart=!0,O}removeTargetedAnimation(P){for(let Q=this._targetedAnimations.length-1;Q>-1;Q--){this._targetedAnimations[Q].animation===P&&this._targetedAnimations.splice(Q,1)}}normalize(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==P&&(P=this._from),null==Q&&(Q=this._to);for(let O=0;O<this._targetedAnimations.length;O++){const b=this._targetedAnimations[O].animation.getKeys(),F=b[0],g=b[b.length-1];if(F.frame>P){const Q={frame:P,value:F.value,inTangent:F.inTangent,outTangent:F.outTangent,interpolation:F.interpolation};b.splice(0,0,Q)}if(g.frame<Q){const P={frame:Q,value:g.value,inTangent:g.inTangent,outTangent:g.outTangent,interpolation:g.interpolation};b.push(P)}}return this._from=P,this._to=Q,this}_processLoop(P,Q,O){P.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(Q),this._animationLoopFlags[O]||(this._animationLoopFlags[O]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0],Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,O=arguments.length>2?arguments[2]:void 0,b=arguments.length>3?arguments[3]:void 0,F=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=P,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let g=0;g<this._targetedAnimations.length;g++){const m=this._targetedAnimations[g],q=this._scene.beginDirectAnimation(m.target,[m.animation],void 0!==O?O:this._from,void 0!==b?b:this._to,P,Q,void 0,void 0,void 0!==F?F:this._isAdditive);q.weight=this._weight,q.playOrder=this._playOrder,q.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(m),this._checkAnimationGroupEnded(q)},this._processLoop(q,m,g),this._animatables.push(q)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=Q,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let P=0;P<this._animatables.length;P++){this._animatables[P].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(P){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==P&&(this.loopAnimation=P),this.restart()):(this.stop(),this.start(P,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let P=0;P<this._animatables.length;P++){this._animatables[P].reset()}return this}restart(){if(!this._isStarted)return this;for(let P=0;P<this._animatables.length;P++){this._animatables[P].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const Q=this._animatables.slice();for(let b=0;b<Q.length;b++)Q[b].stop(void 0,void 0,!0,P);let O=0;for(let b=0;b<this._scene._activeAnimatables.length;b++){const Q=this._scene._activeAnimatables[b];Q._runtimeAnimations.length>0?this._scene._activeAnimatables[O++]=Q:P&&this._checkAnimationGroupEnded(Q,P)}return this._scene._activeAnimatables.length=O,this._isStarted=!1,this}setWeightForAllAnimatables(P){for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].weight=P}return this}syncAllAnimationsWith(P){for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].syncWith(P)}return this}goToFrame(P){let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let O=0;O<this._animatables.length;O++){this._animatables[O].goToFrame(P,Q)}return this}getCurrentFrame(){var P;return(null===(P=this.animatables[0])||void 0===P?void 0:P.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const P=this._scene.animationGroups.indexOf(this);if(P>-1&&this._scene.animationGroups.splice(P,1),this._parentContainer){const P=this._parentContainer.animationGroups.indexOf(this);P>-1&&this._parentContainer.animationGroups.splice(P,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(P){let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const O=this._animatables.indexOf(P);O>-1&&this._animatables.splice(O,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,Q||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(P,Q){let O=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const b=new K(P||this.name,this._scene,this._weight,this._playOrder);b._from=this.from,b._to=this.to,b._speedRatio=this.speedRatio,b._loopAnimation=this.loopAnimation,b._isAdditive=this.isAdditive,b._enableBlending=this.enableBlending,b._blendingSpeed=this.blendingSpeed,b.metadata=this.metadata,b.mask=this.mask;for(const F of this._targetedAnimations)b.addTargetedAnimation(O?F.animation.clone():F.animation,Q?Q(F.target):F.target);return b}serialize(){const P={};P.name=this.name,P.from=this.from,P.to=this.to,P.speedRatio=this.speedRatio,P.loopAnimation=this.loopAnimation,P.isAdditive=this.isAdditive,P.weight=this.weight,P.playOrder=this.playOrder,P.enableBlending=this.enableBlending,P.blendingSpeed=this.blendingSpeed,P.targetedAnimations=[];for(let Q=0;Q<this.targetedAnimations.length;Q++){const O=this.targetedAnimations[Q];P.targetedAnimations[Q]=O.serialize()}return m.c&&m.c.HasTags(this)&&(P.tags=m.c.GetTags(this)),this.metadata&&(P.metadata=this.metadata),P}static Parse(P,Q){const O=new K(P.name,Q,P.weight,P.playOrder);for(let F=0;F<P.targetedAnimations.length;F++){const g=P.targetedAnimations[F],m=b.b.Parse(g.animation),q=g.targetId;if("influence"===g.animation.property){const P=Q.getMorphTargetById(q);P&&O.addTargetedAnimation(m,P)}else{const P=Q.getNodeById(q);null!=P&&O.addTargetedAnimation(m,P)}}return m.c&&m.c.AddTagsTo(O,P.tags),null!==P.from&&null!==P.to&&O.normalize(P.from,P.to),void 0!==P.speedRatio&&(O._speedRatio=P.speedRatio),void 0!==P.loopAnimation&&(O._loopAnimation=P.loopAnimation),void 0!==P.isAdditive&&(O._isAdditive=P.isAdditive),void 0!==P.weight&&(O._weight=P.weight),void 0!==P.playOrder&&(O._playOrder=P.playOrder),void 0!==P.enableBlending&&(O._enableBlending=P.enableBlending),void 0!==P.blendingSpeed&&(O._blendingSpeed=P.blendingSpeed),void 0!==P.metadata&&(O.metadata=P.metadata),O}static MakeAnimationAdditive(P,Q,O){let F;F="object"===typeof Q?Q:{referenceFrame:Q,range:O,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let g=P;F.cloneOriginalAnimationGroup&&(g=P.clone(F.clonedAnimationGroupName||g.name));const m=g.targetedAnimations;for(let q=0;q<m.length;q++){const P=m[q];P.animation=b.b.MakeAnimationAdditive(P.animation,F)}if(g.isAdditive=!0,F.clipKeys){let P=Number.MAX_VALUE,Q=-Number.MAX_VALUE;const O=g.targetedAnimations;for(let b=0;b<O.length;b++){const F=O[b].animation.getKeys();P>F[0].frame&&(P=F[0].frame),Q<F[F.length-1].frame&&(Q=F[F.length-1].frame)}g._from=P,g._to=Q}return g}static ClipKeys(P,Q,O,b,F){const g=P.clone(b||P.name);return K.ClipKeysInPlace(g,Q,O,F)}static ClipKeysInPlace(P,Q,O,b){return K.ClipInPlace(P,Q,O,b,!1)}static ClipFrames(P,Q,O,b,F){const g=P.clone(b||P.name);return K.ClipFramesInPlace(g,Q,O,F)}static ClipFramesInPlace(P,Q,O,b){return K.ClipInPlace(P,Q,O,b,!0)}static ClipInPlace(P,Q,O,b){let F=arguments.length>4&&void 0!==arguments[4]&&arguments[4],g=Number.MAX_VALUE,m=-Number.MAX_VALUE;const q=P.targetedAnimations;for(let R=0;R<q.length;R++){const P=q[R],X=b?P.animation:P.animation.clone();F&&(X.createKeyForFrame(Q),X.createKeyForFrame(O));const C=X.getKeys(),L=[];let G=Number.MAX_VALUE;for(let b=0;b<C.length;b++){const P=C[b];if(!F&&b>=Q&&b<=O||F&&P.frame>=Q&&P.frame<=O){const Q={frame:P.frame,value:P.value.clone?P.value.clone():P.value,inTangent:P.inTangent,outTangent:P.outTangent,interpolation:P.interpolation,lockedTangent:P.lockedTangent};G===Number.MAX_VALUE&&(G=Q.frame),Q.frame-=G,L.push(Q)}}0!==L.length?(g>L[0].frame&&(g=L[0].frame),m<L[L.length-1].frame&&(m=L[L.length-1].frame),X.setKeys(L,!0),P.animation=X):(q.splice(R,1),R--)}return P._from=g,P._to=m,P}getClassName(){return"AnimationGroup"}toString(P){let Q="Name: "+this.name;return Q+=", type: "+this.getClassName(),P&&(Q+=", from: "+this._from,Q+=", to: "+this._to,Q+=", isStarted: "+this._isStarted,Q+=", speedRatio: "+this._speedRatio,Q+=", targetedAnimations length: "+this._targetedAnimations.length,Q+=", animatables length: "+this._animatables),Q}}}}]);