"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13672:(P,f,Y)=>{Y.r(f),Y.d(f,{_HDRTextureLoader:()=>R});var C=Y(11179);class q{static ConvertPanoramaToCubemap(P,f,Y,C){let q=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!P)throw"ConvertPanoramaToCubemap: input cannot be null";if(P.length!=f*Y*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(C,this.FACE_FRONT,P,f,Y,q),back:this.CreateCubemapTexture(C,this.FACE_BACK,P,f,Y,q),left:this.CreateCubemapTexture(C,this.FACE_LEFT,P,f,Y,q),right:this.CreateCubemapTexture(C,this.FACE_RIGHT,P,f,Y,q),up:this.CreateCubemapTexture(C,this.FACE_UP,P,f,Y,q),down:this.CreateCubemapTexture(C,this.FACE_DOWN,P,f,Y,q),size:C,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(P,f,Y,C,q){let m=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const L=new ArrayBuffer(P*P*4*3),o=new Float32Array(L),w=m?Math.max(1,Math.round(C/4/P)):1,d=1/w,R=d*d,y=f[1].nf(f[0]).scale(d/P),r=f[3].nf(f[2]).scale(d/P),i=1/P;let u=0;for(let g=0;g<P;g++)for(let m=0;m<w;m++){let m=f[0],L=f[2];for(let f=0;f<P;f++)for(let d=0;d<w;d++){const w=L.nf(m).scale(u).add(m);w.normalize();const d=this.CalcProjectionSpherical(w,Y,C,q);o[g*P*3+3*f+0]+=d.r*R,o[g*P*3+3*f+1]+=d.g*R,o[g*P*3+3*f+2]+=d.b*R,m=m.add(y),L=L.add(r)}u+=i*d}return o}static CalcProjectionSpherical(P,f,Y,C){let q=Math.atan2(P.z,P.x);const m=Math.acos(P.y);for(;q<-Math.PI;)q+=2*Math.PI;for(;q>Math.PI;)q-=2*Math.PI;let L=q/Math.PI;const o=m/Math.PI;L=.5*L+.5;let w=Math.round(L*Y);w<0?w=0:w>=Y&&(w=Y-1);let d=Math.round(o*C);d<0?d=0:d>=C&&(d=C-1);const R=C-d-1;return{r:f[R*Y*3+3*w+0],g:f[R*Y*3+3*w+1],b:f[R*Y*3+3*w+2]}}}function m(P,f,Y,C,q,m){q>0?(q=function(P,f){return f>1023?P*Math.pow(2,1023)*Math.pow(2,f-1023):f<-1074?P*Math.pow(2,-1074)*Math.pow(2,f+1074):P*Math.pow(2,f)}(1,q-136),P[m+0]=f*q,P[m+1]=Y*q,P[m+2]=C*q):(P[m+0]=0,P[m+1]=0,P[m+2]=0)}function L(P,f){let Y="",C="";for(let q=f;q<P.length-f&&(C=String.fromCharCode(P[q]),"\n"!=C);q++)Y+=C;return Y}function o(P){let f=0,Y=0,C=L(P,0);if("#"!=C[0]||"?"!=C[1])throw"Bad HDR Format.";let q=!1,m=!1,o=0;do{o+=C.length+1,C=L(P,o),"FORMAT=32-bit_rle_rgbe"==C?m=!0:0==C.length&&(q=!0)}while(!q);if(!m)throw"HDR Bad header format, unsupported FORMAT";o+=C.length+1,C=L(P,o);const w=/^-Y (.*) \+X (.*)$/g.exec(C);if(!w||w.length<3)throw"HDR Bad header format, no size";if(Y=parseInt(w[2]),f=parseInt(w[1]),Y<8||Y>32767)throw"HDR Bad header format, unsupported size";return o+=C.length+1,{height:f,width:Y,dataPosition:o}}function w(P,f){return function(P,f){let Y=f.height;const C=f.width;let q,L,o,w,R,y=f.dataPosition,r=0,i=0,u=0;const g=new ArrayBuffer(4*C),S=new Uint8Array(g),K=new ArrayBuffer(f.width*f.height*4*3),M=new Float32Array(K);for(;Y>0;){if(q=P[y++],L=P[y++],o=P[y++],w=P[y++],2!=q||2!=L||128&o||f.width<8||f.width>32767)return d(P,f);if((o<<8|w)!=C)throw"HDR Bad header format, wrong scan line width";for(r=0,u=0;u<4;u++)for(i=(u+1)*C;r<i;)if(q=P[y++],L=P[y++],q>128){if(R=q-128,0==R||R>i-r)throw"HDR Bad Format, bad scanline data (run)";for(;R-- >0;)S[r++]=L}else{if(R=q,0==R||R>i-r)throw"HDR Bad Format, bad scanline data (non-run)";if(S[r++]=L,--R>0)for(let f=0;f<R;f++)S[r++]=P[y++]}for(u=0;u<C;u++)q=S[u],L=S[u+C],o=S[u+2*C],w=S[u+3*C],m(M,q,L,o,w,(f.height-Y)*C*3+3*u);Y--}return M}(P,f)}function d(P,f){let Y=f.height;const C=f.width;let q,L,o,w,d,R=f.dataPosition;const y=new ArrayBuffer(f.width*f.height*4*3),r=new Float32Array(y);for(;Y>0;){for(d=0;d<f.width;d++)q=P[R++],L=P[R++],o=P[R++],w=P[R++],m(r,q,L,o,w,(f.height-Y)*C*3+3*d);Y--}return r}q.FACE_LEFT=[new C.Of(-1,-1,-1),new C.Of(1,-1,-1),new C.Of(-1,1,-1),new C.Of(1,1,-1)],q.FACE_RIGHT=[new C.Of(1,-1,1),new C.Of(-1,-1,1),new C.Of(1,1,1),new C.Of(-1,1,1)],q.FACE_FRONT=[new C.Of(1,-1,-1),new C.Of(1,-1,1),new C.Of(1,1,-1),new C.Of(1,1,1)],q.FACE_BACK=[new C.Of(-1,-1,1),new C.Of(-1,-1,-1),new C.Of(-1,1,1),new C.Of(-1,1,-1)],q.FACE_DOWN=[new C.Of(1,1,-1),new C.Of(1,1,1),new C.Of(-1,1,-1),new C.Of(-1,1,1)],q.FACE_UP=[new C.Of(-1,-1,-1),new C.Of(-1,-1,1),new C.Of(1,-1,-1),new C.Of(1,-1,1)];class R{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(P,f,Y){const C=new Uint8Array(P.buffer,P.byteOffset,P.byteLength),q=o(C),m=w(C,q),L=q.width*q.height,d=new Float32Array(4*L);for(let o=0;o<L;o+=1)d[4*o]=m[3*o],d[4*o+1]=m[3*o+1],d[4*o+2]=m[3*o+2],d[4*o+3]=1;Y(q.width,q.height,f.generateMipMaps,!1,(()=>{const P=f.getEngine();f.type=1,f.format=5,f._gammaSpace=!1,P._uploadDataToTextureDirectly(f,d)}))}}}}]);