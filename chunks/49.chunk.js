"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[49],{14044:(U,X,b)=>{b.r(X),b.d(X,{_HDRTextureLoader:()=>S});var F=b(11593);class E{static ConvertPanoramaToCubemap(U,X,b,F){let E=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!U)throw"ConvertPanoramaToCubemap: input cannot be null";if(U.length!=X*b*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(F,this.FACE_FRONT,U,X,b,E),back:this.CreateCubemapTexture(F,this.FACE_BACK,U,X,b,E),left:this.CreateCubemapTexture(F,this.FACE_LEFT,U,X,b,E),right:this.CreateCubemapTexture(F,this.FACE_RIGHT,U,X,b,E),up:this.CreateCubemapTexture(F,this.FACE_UP,U,X,b,E),down:this.CreateCubemapTexture(F,this.FACE_DOWN,U,X,b,E),size:F,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(U,X,b,F,E){let w=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const Q=new ArrayBuffer(U*U*4*3),z=new Float32Array(Q),q=w?Math.max(1,Math.round(F/4/U)):1,p=1/q,S=p*p,R=X[1].mX(X[0]).scale(p/U),n=X[3].mX(X[2]).scale(p/U),a=1/U;let J=0;for(let m=0;m<U;m++)for(let w=0;w<q;w++){let w=X[0],Q=X[2];for(let X=0;X<U;X++)for(let p=0;p<q;p++){const q=Q.mX(w).scale(J).add(w);q.normalize();const p=this.CalcProjectionSpherical(q,b,F,E);z[m*U*3+3*X+0]+=p.r*S,z[m*U*3+3*X+1]+=p.g*S,z[m*U*3+3*X+2]+=p.b*S,w=w.add(R),Q=Q.add(n)}J+=a*p}return z}static CalcProjectionSpherical(U,X,b,F){let E=Math.atan2(U.z,U.x);const w=Math.acos(U.y);for(;E<-Math.PI;)E+=2*Math.PI;for(;E>Math.PI;)E-=2*Math.PI;let Q=E/Math.PI;const z=w/Math.PI;Q=.5*Q+.5;let q=Math.round(Q*b);q<0?q=0:q>=b&&(q=b-1);let p=Math.round(z*F);p<0?p=0:p>=F&&(p=F-1);const S=F-p-1;return{r:X[S*b*3+3*q+0],g:X[S*b*3+3*q+1],b:X[S*b*3+3*q+2]}}}function w(U,X,b,F,E,w){E>0?(E=function(U,X){return X>1023?U*Math.pow(2,1023)*Math.pow(2,X-1023):X<-1074?U*Math.pow(2,-1074)*Math.pow(2,X+1074):U*Math.pow(2,X)}(1,E-136),U[w+0]=X*E,U[w+1]=b*E,U[w+2]=F*E):(U[w+0]=0,U[w+1]=0,U[w+2]=0)}function Q(U,X){let b="",F="";for(let E=X;E<U.length-X&&(F=String.fromCharCode(U[E]),"\n"!=F);E++)b+=F;return b}function z(U){let X=0,b=0,F=Q(U,0);if("#"!=F[0]||"?"!=F[1])throw"Bad HDR Format.";let E=!1,w=!1,z=0;do{z+=F.length+1,F=Q(U,z),"FORMAT=32-bit_rle_rgbe"==F?w=!0:0==F.length&&(E=!0)}while(!E);if(!w)throw"HDR Bad header format, unsupported FORMAT";z+=F.length+1,F=Q(U,z);const q=/^-Y (.*) \+X (.*)$/g.exec(F);if(!q||q.length<3)throw"HDR Bad header format, no size";if(b=parseInt(q[2]),X=parseInt(q[1]),b<8||b>32767)throw"HDR Bad header format, unsupported size";return z+=F.length+1,{height:X,width:b,dataPosition:z}}function q(U,X){return function(U,X){let b=X.height;const F=X.width;let E,Q,z,q,S,R=X.dataPosition,n=0,a=0,J=0;const m=new ArrayBuffer(4*F),x=new Uint8Array(m),I=new ArrayBuffer(X.width*X.height*4*3),O=new Float32Array(I);for(;b>0;){if(E=U[R++],Q=U[R++],z=U[R++],q=U[R++],2!=E||2!=Q||128&z||X.width<8||X.width>32767)return p(U,X);if((z<<8|q)!=F)throw"HDR Bad header format, wrong scan line width";for(n=0,J=0;J<4;J++)for(a=(J+1)*F;n<a;)if(E=U[R++],Q=U[R++],E>128){if(S=E-128,0==S||S>a-n)throw"HDR Bad Format, bad scanline data (run)";for(;S-- >0;)x[n++]=Q}else{if(S=E,0==S||S>a-n)throw"HDR Bad Format, bad scanline data (non-run)";if(x[n++]=Q,--S>0)for(let X=0;X<S;X++)x[n++]=U[R++]}for(J=0;J<F;J++)E=x[J],Q=x[J+F],z=x[J+2*F],q=x[J+3*F],w(O,E,Q,z,q,(X.height-b)*F*3+3*J);b--}return O}(U,X)}function p(U,X){let b=X.height;const F=X.width;let E,Q,z,q,p,S=X.dataPosition;const R=new ArrayBuffer(X.width*X.height*4*3),n=new Float32Array(R);for(;b>0;){for(p=0;p<X.width;p++)E=U[S++],Q=U[S++],z=U[S++],q=U[S++],w(n,E,Q,z,q,(X.height-b)*F*3+3*p);b--}return n}E.FACE_LEFT=[new F.JX(-1,-1,-1),new F.JX(1,-1,-1),new F.JX(-1,1,-1),new F.JX(1,1,-1)],E.FACE_RIGHT=[new F.JX(1,-1,1),new F.JX(-1,-1,1),new F.JX(1,1,1),new F.JX(-1,1,1)],E.FACE_FRONT=[new F.JX(1,-1,-1),new F.JX(1,-1,1),new F.JX(1,1,-1),new F.JX(1,1,1)],E.FACE_BACK=[new F.JX(-1,-1,1),new F.JX(-1,-1,-1),new F.JX(-1,1,1),new F.JX(-1,1,-1)],E.FACE_DOWN=[new F.JX(1,1,-1),new F.JX(1,1,1),new F.JX(-1,1,-1),new F.JX(-1,1,1)],E.FACE_UP=[new F.JX(-1,-1,-1),new F.JX(-1,-1,1),new F.JX(1,-1,-1),new F.JX(1,-1,1)];class S{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(U,X,b){const F=new Uint8Array(U.buffer,U.byteOffset,U.byteLength),E=z(F),w=q(F,E),Q=E.width*E.height,p=new Float32Array(4*Q);for(let z=0;z<Q;z+=1)p[4*z]=w[3*z],p[4*z+1]=w[3*z+1],p[4*z+2]=w[3*z+2],p[4*z+3]=1;b(E.width,E.height,X.generateMipMaps,!1,(()=>{const U=X.getEngine();X.type=1,X.format=5,X._gammaSpace=!1,U._uploadDataToTextureDirectly(X,p)}))}}}}]);