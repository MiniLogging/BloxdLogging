"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13709:(A,X,s)=>{s.r(X),s.d(X,{AnimationGroup:()=>C,TargetedAnimation:()=>R});var N=s(12567),f=s(454),E=s(503),g=s(638),K=s(12563),r=s(678);class i{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(A,X,s,f){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=X,this._target=A,this._scene=s,this._host=f,this._activeTargets=[],X._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===N.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=r.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const A={frame:0,value:this._minValue};this._keys.splice(0,0,A)}if(this._target instanceof Array){let A=0;for(const X of this._target)this._preparePath(X,A),this._getOriginalValues(A),A++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const E=X.getEvents();if(E&&E.length>0)for(const N of E)this._events.push(N._clone());this._enableBlending=A&&A.animationPropertiesOverride?A.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(A){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const s=this._animation.targetPropertyPath;if(s.length>1){let N=A;for(let A=0;A<s.length-1;A++){const X=s[A];if(N=N[X],void 0===N)throw new Error(`Invalid property (${X}) in property path (${s.join(".")})`)}this._targetPath=s[s.length-1],this._activeTargets[X]=N}else this._targetPath=s[0],this._activeTargets[X]=A;if(void 0===this._activeTargets[X][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${s.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let A=0;for(const X of this._target)void 0!==this._originalValue[A]&&this._setValue(X,this._activeTargets[A],this._originalValue[A],-1,A),A++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let A=0;A<this._events.length;A++)this._events[A].isDone=!1}isStopped(){return this._stopped}dispose(){const A=this._animation.runtimeAnimations.indexOf(this);A>-1&&this._animation.runtimeAnimations.splice(A,1)}setValue(A,X){if(this._targetIsArray)for(let s=0;s<this._target.length;s++){const N=this._target[s];this._setValue(N,this._activeTargets[s],A,X,s)}else this._setValue(this._target,this._directTarget,A,X,0)}_getOriginalValues(){let A,X=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const s=this._activeTargets[X];A=s.getLocalMatrix&&"_matrix"===this._targetPath?s.getLocalMatrix():s[this._targetPath],A&&A.clone?this._originalValue[X]=A.clone():this._originalValue[X]=A}_registerTargetForLateAnimationBinding(A,X){const s=A.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(s),s._lateAnimationHolders||(s._lateAnimationHolders={}),s._lateAnimationHolders[A.targetPath]||(s._lateAnimationHolders[A.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:X}),A.isAdditive?(s._lateAnimationHolders[A.targetPath].additiveAnimations.push(A),s._lateAnimationHolders[A.targetPath].totalAdditiveWeight+=A.weight):(s._lateAnimationHolders[A.targetPath].animations.push(A),s._lateAnimationHolders[A.targetPath].totalWeight+=A.weight)}_setValue(A,X,s,f,E){if(this._currentActiveTarget=X,this._weight=f,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const A=X[this._targetPath];A.clone?this._originalBlendValue=A.clone():this._originalBlendValue=A}this._originalBlendValue.m?N.e.AllowMatrixDecomposeForInterpolation?this._currentValue?r.c.DecomposeLerpToRef(this._originalBlendValue,s,this._blendingFactor,this._currentValue):this._currentValue=r.c.DecomposeLerp(this._originalBlendValue,s,this._blendingFactor):this._currentValue?r.c.LerpToRef(this._originalBlendValue,s,this._blendingFactor,this._currentValue):this._currentValue=r.c.Lerp(this._originalBlendValue,s,this._blendingFactor):this._currentValue=N.e._UniversalLerp(this._originalBlendValue,s,this._blendingFactor);const f=A&&A.animationPropertiesOverride?A.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=f}else this._currentValue?this._currentValue.p?this._currentValue.p(s):this._currentValue=s:null!==s&&void 0!==s&&s.clone?this._currentValue=s.clone():this._currentValue=s;-1!==f?this._registerTargetForLateAnimationBinding(this,this._originalValue[E]):this._animationState.loopMode===N.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[E],X[this._targetPath]):X[this._targetPath]=this._originalValue[E]+this._currentValue:X[this._targetPath]=this._currentValue,A.Oi&&A.Oi(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(A){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const s=this._animation.getKeys();A<s[0].frame?A=s[0].frame:A>s[s.length-1].frame&&(A=s[s.length-1].frame);const N=this._events;if(N.length)for(let E=0;E<N.length;E++)N[E].onlyOnce||(N[E].isDone=N[E].frame<A);this._currentFrame=A;const f=this._animation._interpolate(A,this._animationState);this.setValue(f,X)}_prepareForSpeedRatioChange(A){const X=this._previousElapsedTime*(this._animation.framePerSecond*A)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-X}animate(A,X,s,f,E){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const K=this._animation,r=K.targetPropertyPath;if(!r||r.length<1)return this._stopped=!0,!1;let i,Y=!0;const v=this._events;let c=0;if(this._coreRuntimeAnimation)c=s-X,i=this._coreRuntimeAnimation.currentFrame,this._currentFrame=i,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let g;(X<this._minFrame||X>this._maxFrame)&&(X=this._minFrame),(s<this._minFrame||s>this._maxFrame)&&(s=this._maxFrame),c=s-X;let r=A*(K.framePerSecond*E)/1e3+this._absoluteFrameOffset,M=0,d=!1;const Q=f&&this._animationState.loopMode===N.e.ANIMATIONLOOPMODE_YOYO;if(Q){const A=(r-X)/c,s=Math.sin(A*Math.PI);r=Math.abs(s)*c+X;const N=s>=0?1:-1;this._yoyoDirection!==N&&(d=!0),this._yoyoDirection=N}if(this._previousElapsedTime=A,this._previousAbsoluteFrame=r,!f&&s>=X&&(r>=c&&E>0||r<=0&&E<0))Y=!1,M=K._getKeyValue(this._maxValue);else if(!f&&X>=s&&(r<=c&&E<0||r>=0&&E>0))Y=!1,M=K._getKeyValue(this._minValue);else if(this._animationState.loopMode!==N.e.ANIMATIONLOOPMODE_CYCLE){const A=s.toString()+X.toString();if(!this._offsetsCache[A]){this._animationState.repeatCount=0,this._animationState.loopMode=N.e.ANIMATIONLOOPMODE_CYCLE;const f=K._interpolate(X,this._animationState),E=K._interpolate(s,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),K.dataType){case N.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[A]=E-f;break;case N.e.ANIMATIONTYPE_QUATERNION:case N.e.ANIMATIONTYPE_VECTOR3:case N.e.ANIMATIONTYPE_VECTOR2:case N.e.ANIMATIONTYPE_SIZE:case N.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[A]=E.Pg(f)}this._highLimitsCache[A]=E}M=this._highLimitsCache[A],g=this._offsetsCache[A]}if(void 0===g)switch(K.dataType){case N.e.ANIMATIONTYPE_FLOAT:g=0;break;case N.e.ANIMATIONTYPE_QUATERNION:g=N.m;break;case N.e.ANIMATIONTYPE_VECTOR3:g=N.w;break;case N.e.ANIMATIONTYPE_VECTOR2:g=N.t;break;case N.e.ANIMATIONTYPE_SIZE:g=N.p;break;case N.e.ANIMATIONTYPE_COLOR3:g=N.i;break;case N.e.ANIMATIONTYPE_COLOR4:g=N.l}if(this._host&&this._host.syncRoot){const A=this._host.syncRoot;i=X+c*((A.masterFrame-A.fromFrame)/(A.toFrame-A.fromFrame))}else i=r>0&&X>s||r<0&&X<s?Y&&0!==c?s+r%c:X:Y&&0!==c?X+r%c:s;if(!Q&&(E>0&&this.currentFrame>i||E<0&&this.currentFrame<i)||Q&&d){this._onLoop();for(let A=0;A<v.length;A++)v[A].onlyOnce||(v[A].isDone=!1);this._animationState.key=E>0?0:K.getKeys().length-1}this._currentFrame=i,this._animationState.repeatCount=0===c?0:r/c|0,this._animationState.highLimitValue=M,this._animationState.offsetValue=g}const M=K._interpolate(i,this._animationState);if(this.setValue(M,g),v.length)for(let N=0;N<v.length;N++)if(c>=0&&i>=v[N].frame&&v[N].frame>=X||c<0&&i<=v[N].frame&&v[N].frame<=X){const A=v[N];A.isDone||(A.onlyOnce&&(v.splice(N,1),N--),A.isDone=!0,A.action(i))}return Y||(this._stopped=!0),Y}}var Y=s(486);class v{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(A){this._weight=-1!==A?Math.min(Math.max(A,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(A){for(let X=0;X<this._runtimeAnimations.length;X++){this._runtimeAnimations[X]._prepareForSpeedRatioChange(A)}this._speedRatio=A,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(A,X){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,E=arguments.length>4&&void 0!==arguments[4]&&arguments[4],g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,K=arguments.length>6?arguments[6]:void 0,r=arguments.length>7?arguments[7]:void 0,i=arguments.length>8?arguments[8]:void 0,Y=arguments.length>9&&void 0!==arguments[9]&&arguments[9],v=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=X,this.fromFrame=s,this.toFrame=N,this.loopAnimation=E,this.onAnimationEnd=K,this.onAnimationLoop=i,this.isAdditive=Y,this.playOrder=v,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Nk=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new f.b,this.onAnimationLoopObservable=new f.b,this._scene=A,r&&this.appendAnimations(X,r),this._speedRatio=g,A._activeAnimatables.push(this)}syncWith(A){if(this._syncRoot=A,A){const A=this._scene._activeAnimatables.indexOf(this);A>-1&&(this._scene._activeAnimatables.splice(A,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(A,X){for(let s=0;s<X.length;s++){const N=X[s],f=new i(A,N,this._scene,this);f._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(f)}}getAnimationByTargetProperty(A){const X=this._runtimeAnimations;for(let s=0;s<X.length;s++)if(X[s].animation.targetProperty===A)return X[s].animation;return null}getRuntimeAnimationByTargetProperty(A){const X=this._runtimeAnimations;for(let s=0;s<X.length;s++)if(X[s].animation.targetProperty===A)return X[s];return null}reset(){const A=this._runtimeAnimations;for(let X=0;X<A.length;X++)A[X].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(A){const X=this._runtimeAnimations;for(let s=0;s<X.length;s++)X[s].animation.enableBlending=!0,X[s].animation.blendingSpeed=A}disableBlending(){const A=this._runtimeAnimations;for(let X=0;X<A.length;X++)A[X].animation.enableBlending=!1}goToFrame(A){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const s=this._runtimeAnimations;if(s[0]){const X=s[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??s[0].currentFrame;const N=0===this.speedRatio?0:(A-this._frameToSyncFromJump)/X*1e3/this.speedRatio;this._manualJumpDelay=-N}for(let N=0;N<s.length;N++)s[N].goToFrame(A,X?this._weight:-1);this._goToFrame=A}get paused(){return this.Nk}pause(){this.Nk||(this.Nk=!0)}restart(){this.Nk=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(A,X){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2],N=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(A||X){const f=this._scene._activeAnimatables.indexOf(this);if(f>-1){const E=this._runtimeAnimations;for(let s=E.length-1;s>=0;s--){const N=E[s];A&&N.animation.name!=A||(X&&!X(N.target)||(N.dispose(),E.splice(s,1)))}0==E.length&&(s||this._scene._activeAnimatables.splice(f,1),N||this._raiseOnAnimationEnd())}}else{const A=this._scene._activeAnimatables.indexOf(this);if(A>-1){s||this._scene._activeAnimatables.splice(A,1);const X=this._runtimeAnimations;for(let A=0;A<X.length;A++)X[A].dispose();this._runtimeAnimations.length=0,N||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((A=>{this.onAnimationEndObservable.add((()=>{A(this)}),void 0,void 0,this,!0)}))}_animate(A){if(this.Nk)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=A),!0;if(null===this._localDelayOffset?(this._localDelayOffset=A,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=A-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let X=!1;const s=this._runtimeAnimations;let N;for(N=0;N<s.length;N++){const f=s[N].animate(A-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);X=X||f}if(this.animationStarted=X,!X){if(this.disposeOnEnd)for(N=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(N,1),N=0;N<s.length;N++)s[N].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return X}}function c(A){if(0===A.totalWeight&&0===A.totalAdditiveWeight)return A.originalValue;let X=1;const s=r.f.oi[0],N=r.f.oi[1],f=r.f.Quaternion[0];let E=0;const g=A.animations[0],K=A.originalValue;let i=1,Y=!1;if(A.totalWeight<1)i=1-A.totalWeight,K.decompose(N,f,s);else{if(E=1,X=A.totalWeight,i=g.weight/X,1==i){if(!A.totalAdditiveWeight)return g.currentValue;Y=!0}g.currentValue.decompose(N,f,s)}if(!Y){N.scaleInPlace(i),s.scaleInPlace(i),f.scaleInPlace(i);for(let g=E;g<A.animations.length;g++){const E=A.animations[g];if(0===E.weight)continue;i=E.weight/X;const K=r.f.oi[2],Y=r.f.oi[3],v=r.f.Quaternion[1];E.currentValue.decompose(Y,v,K),Y.scaleAndAddToRef(i,N),v.scaleAndAddToRef(r.d.Dot(f,v)>0?i:-i,f),K.scaleAndAddToRef(i,s)}f.normalize()}for(let c=0;c<A.additiveAnimations.length;c++){const X=A.additiveAnimations[c];if(0===X.weight)continue;const E=r.f.oi[2],g=r.f.oi[3],K=r.f.Quaternion[1];X.currentValue.decompose(g,K,E),g.multiplyToRef(N,g),r.k.LerpToRef(N,g,X.weight,N),f.multiplyToRef(K,K),r.d.SlerpToRef(f,K,X.weight,f),E.scaleAndAddToRef(X.weight,s)}const v=g?g._animationState.workValue:r.f.Matrix[0].clone();return r.c.ComposeToRef(N,f,s,v),v}function M(A,X){if(0===A.totalWeight&&0===A.totalAdditiveWeight)return X;const s=A.animations[0],N=A.originalValue;let f=X;if(0===A.totalWeight&&A.totalAdditiveWeight>0)f.p(N);else if(1===A.animations.length){if(r.d.SlerpToRef(N,s.currentValue,Math.min(1,A.totalWeight),f),0===A.totalAdditiveWeight)return f}else if(A.animations.length>1){let s,E,g=1;if(A.totalWeight<1){const X=1-A.totalWeight;s=[],E=[],s.push(N),E.push(X)}else{if(2===A.animations.length&&(r.d.SlerpToRef(A.animations[0].currentValue,A.animations[1].currentValue,A.animations[1].weight/A.totalWeight,X),0===A.totalAdditiveWeight))return X;s=[],E=[],g=A.totalWeight}for(let X=0;X<A.animations.length;X++){const N=A.animations[X];s.push(N.currentValue),E.push(N.weight/g)}let K=0;for(let A=0;A<s.length;)A?(K+=E[A],r.d.SlerpToRef(f,s[A],E[A]/K,f),A++):(r.d.SlerpToRef(s[A],s[A+1],E[A+1]/(E[A]+E[A+1]),X),f=X,K=E[A]+E[A+1],A+=2)}for(let E=0;E<A.additiveAnimations.length;E++){const X=A.additiveAnimations[E];0!==X.weight&&(f.multiplyToRef(X.currentValue,r.f.Quaternion[0]),r.d.SlerpToRef(f,r.f.Quaternion[0],X.weight,f))}return f}var d,Q,w=s(2418);d=w.d,(Q=K.b)&&(Q.prototype.copyAnimationRange=function(A,X,s){let f=arguments.length>3&&void 0!==arguments[3]&&arguments[3],E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new N.e(this.name,"_matrix",A.animations[0].framePerSecond,N.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const g=A.animations[0].getRange(X);if(!g)return!1;const K=g.from,r=g.to,i=A.animations[0].getKeys(),Y=A.length,v=A.getParent(),c=this.getParent(),M=f&&v&&Y&&this.length&&Y!==this.length,d=M&&c&&v?c.length/v.length:1,Q=f&&!c&&E&&(1!==E.x||1!==E.y||1!==E.z),w=this.animations[0].getKeys();let R,C,J;for(let N=0,a=i.length;N<a;N++)R=i[N],R.frame>=K&&R.frame<=r&&(f?(J=R.value.clone(),M?(C=J.getTranslation(),J.setTranslation(C.scaleInPlace(d))):Q&&E?(C=J.getTranslation(),J.setTranslation(C.multiplyInPlace(E))):J=R.value):J=R.value,w.push({frame:R.frame+s,value:J}));return this.animations[0].createRange(X,K+s,r+s),!0}),d&&(d.prototype._animate=function(A){if(!this.animationsEnabled)return;const X=Y.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=X}this.deltaTime=void 0!==A?A:this.useConstantAnimationDeltaTime?16:(X-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=X;const s=this._activeAnimatables;if(0===s.length)return;this._animationTime+=this.deltaTime;const f=this._animationTime;for(let N=0;N<s.length;N++){const A=s[N];!A._animate(f)&&A.disposeOnEnd&&N--}!function(A){if(A._registeredForLateAnimationBindings.length){for(let X=0;X<A._registeredForLateAnimationBindings.length;X++){const s=A._registeredForLateAnimationBindings.data[X];for(const A in s._lateAnimationHolders){const X=s._lateAnimationHolders[A],f=X.animations[0],E=X.originalValue;if(void 0===E||null===E)continue;const g=N.e.AllowMatrixDecomposeForInterpolation&&E.m;let K=s[A];if(g)K=c(X);else if(void 0!==E.w)K=M(X,K||r.d.Identity());else{let A=0,s=1;const g=f&&f._animationState.loopMode===N.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(X.totalWeight<1)K=g?E.clone?E.clone():E:f&&E.scale?E.scale(1-X.totalWeight):f?E*(1-X.totalWeight):E.clone?E.clone():E;else if(f){s=X.totalWeight;const N=f.weight/s;K=1!==N?f.currentValue.scale?f.currentValue.scale(N):f.currentValue*N:f.currentValue,g&&(K.addToRef?K.addToRef(E,K):K+=E),A=1}for(let N=A;N<X.animations.length;N++){const A=X.animations[N],f=A.weight/s;f&&(A.currentValue.scaleAndAddToRef?A.currentValue.scaleAndAddToRef(f,K):K+=A.currentValue*f)}for(let N=0;N<X.additiveAnimations.length;N++){const A=X.additiveAnimations[N],s=A.weight;s&&(A.currentValue.scaleAndAddToRef?A.currentValue.scaleAndAddToRef(s,K):K+=A.currentValue*s)}}s[A]=K}s._lateAnimationHolders={}}A._registeredForLateAnimationBindings.reset()}}(this)},d.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((A,X)=>A.playOrder-X.playOrder))},d.prototype.beginWeightedAnimation=function(A,X,s){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,f=arguments.length>4?arguments[4]:void 0,E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,K=arguments.length>7?arguments[7]:void 0,r=arguments.length>8?arguments[8]:void 0,i=arguments.length>9?arguments[9]:void 0,Y=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const v=this.beginAnimation(A,X,s,f,E,g,K,!1,r,i,Y);return v.weight=N,v},d.prototype.beginAnimation=function(A,X,s,N){let f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,E=arguments.length>5?arguments[5]:void 0,g=arguments.length>6?arguments[6]:void 0,K=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],r=arguments.length>8?arguments[8]:void 0,i=arguments.length>9?arguments[9]:void 0,Y=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(f<0){const A=X;X=s,s=A,f=-f}X>s&&(f=-f),K&&this.stopAnimation(A,void 0,r),g||(g=new v(this,A,X,s,N,f,E,void 0,i,Y));const c=!r||r(A);if(A.animations&&c&&g.appendAnimations(A,A.animations),A.getAnimatables){const Y=A.getAnimatables();for(let A=0;A<Y.length;A++)this.beginAnimation(Y[A],X,s,N,f,E,g,K,r,i)}return g.reset(),g},d.prototype.beginHierarchyAnimation=function(A,X,s,N,f){let E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,g=arguments.length>6?arguments[6]:void 0,K=arguments.length>7?arguments[7]:void 0,r=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],i=arguments.length>9?arguments[9]:void 0,Y=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const v=A.getDescendants(X),c=[];c.push(this.beginAnimation(A,s,N,f,E,g,K,r,i,void 0,Y));for(const M of v)c.push(this.beginAnimation(M,s,N,f,E,g,K,r,i,void 0,Y));return c},d.prototype.beginDirectAnimation=function(A,X,s,N,f){let E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(E<0){const A=s;s=N,N=A,E=-E}return s>N&&(E=-E),new v(this,A,s,N,f,E,arguments.length>6?arguments[6]:void 0,X,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},d.prototype.beginDirectHierarchyAnimation=function(A,X,s,N,f,E,g,K,r){let i=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const Y=A.getDescendants(X),v=[];v.push(this.beginDirectAnimation(A,s,N,f,E,g,K,r,i));for(const c of Y)v.push(this.beginDirectAnimation(c,s,N,f,E,g,K,r,i));return v},d.prototype.getAnimatableByTarget=function(A){for(let X=0;X<this._activeAnimatables.length;X++)if(this._activeAnimatables[X].target===A)return this._activeAnimatables[X];return null},d.prototype.getAllAnimatablesByTarget=function(A){const X=[];for(let s=0;s<this._activeAnimatables.length;s++)this._activeAnimatables[s].target===A&&X.push(this._activeAnimatables[s]);return X},d.prototype.stopAnimation=function(A,X,s){const N=this.getAllAnimatablesByTarget(A);for(const f of N)f.stop(X,s)},d.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let A=0;A<this._activeAnimatables.length;A++)this._activeAnimatables[A].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const A of this.animationGroups)A.stop()});class R{getClassName(){return"TargetedAnimation"}serialize(){const A={};return A.animation=this.animation.serialize(),A.targetId=this.target.id,A}}class C{get mask(){return this._mask}set mask(A){this._mask!==A&&(this._mask=A,this.syncWithMask(!0))}syncWithMask(){let A=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||A){this._numActiveAnimatables=0;for(let A=0;A<this._animatables.length;++A){const X=this._animatables[A];!this.mask||this.mask.disabled||this.mask.retainsTarget(X.target.name)?(this._numActiveAnimatables++,X.paused&&X.restart()):X.paused||X.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let A=0;A<this._animatables.length;++A){const X=this._animatables[A];this.mask.retainsTarget(X.target.name)||(X.stop(),this._animatables.splice(A,1),--A)}for(let A=0;A<this._targetedAnimations.length;A++){const X=this._targetedAnimations[A];this.mask.retainsTarget(X.target.name)||(this._targetedAnimations.splice(A,1),--A)}}}get from(){return this._from}set from(A){if(this._from!==A){this._from=A;for(let A=0;A<this._animatables.length;A++){this._animatables[A].fromFrame=this._from}}}get to(){return this._to}set to(A){if(this._to!==A){this._to=A;for(let A=0;A<this._animatables.length;A++){this._animatables[A].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(A){if(this._speedRatio!==A){this._speedRatio=A;for(let A=0;A<this._animatables.length;A++){this._animatables[A].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(A){if(this._loopAnimation!==A){this._loopAnimation=A;for(let A=0;A<this._animatables.length;A++){this._animatables[A].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(A){if(this._isAdditive!==A){this._isAdditive=A;for(let A=0;A<this._animatables.length;A++){this._animatables[A].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(A){this._weight!==A&&(this._weight=A,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(A){if(this._playOrder!==A&&(this._playOrder=A,this._animatables.length>0)){for(let A=0;A<this._animatables.length;A++)this._animatables[A].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(A){if(this._enableBlending!==A&&(this._enableBlending=A,null!==A))for(let X=0;X<this._targetedAnimations.length;++X)this._targetedAnimations[X].animation.enableBlending=A}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(A){if(this._blendingSpeed!==A&&(this._blendingSpeed=A,null!==A))for(let X=0;X<this._targetedAnimations.length;++X)this._targetedAnimations[X].animation.blendingSpeed=A}getLength(A,X){A=A??this._from;return((X=X??this._to)-A)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(A){let X=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],s=arguments.length>2&&void 0!==arguments[2]&&arguments[2],N=arguments.length>3?arguments[3]:void 0;if(0===A.length)return null;N=N??A[0].weight;let f=Number.MAX_VALUE,E=-Number.MAX_VALUE;if(s)for(const K of A)K.from<f&&(f=K.from),K.to>E&&(E=K.to);const g=new C(A[0].name+"_merged",A[0]._scene,N);for(const K of A){s&&K.normalize(f,E);for(const A of K.targetedAnimations)g.addTargetedAnimation(A.animation,A.target);X&&K.dispose()}return g}constructor(A){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=A,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new f.b,this.onAnimationLoopObservable=new f.b,this.onAnimationGroupLoopObservable=new f.b,this.onAnimationGroupEndObservable=new f.b,this.onAnimationGroupPauseObservable=new f.b,this.onAnimationGroupPlayObservable=new f.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=X||E.b.LastCreatedScene,this._weight=s,this._playOrder=N,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(A,X){const s=new R;s.animation=A,s.target=X;const N=A.getKeys();return this._from>N[0].frame&&(this._from=N[0].frame),this._to<N[N.length-1].frame&&(this._to=N[N.length-1].frame),null!==this._enableBlending&&(A.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(A.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(s),this._shouldStart=!0,s}removeTargetedAnimation(A){for(let X=this._targetedAnimations.length-1;X>-1;X--){this._targetedAnimations[X].animation===A&&this._targetedAnimations.splice(X,1)}}normalize(){let A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==A&&(A=this._from),null==X&&(X=this._to);for(let s=0;s<this._targetedAnimations.length;s++){const N=this._targetedAnimations[s].animation.getKeys(),f=N[0],E=N[N.length-1];if(f.frame>A){const X={frame:A,value:f.value,inTangent:f.inTangent,outTangent:f.outTangent,interpolation:f.interpolation};N.splice(0,0,X)}if(E.frame<X){const A={frame:X,value:E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation};N.push(A)}}return this._from=A,this._to=X,this}_processLoop(A,X,s){A.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(X),this._animationLoopFlags[s]||(this._animationLoopFlags[s]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let A=arguments.length>0&&void 0!==arguments[0]&&arguments[0],X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,s=arguments.length>2?arguments[2]:void 0,N=arguments.length>3?arguments[3]:void 0,f=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=A,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let E=0;E<this._targetedAnimations.length;E++){const g=this._targetedAnimations[E],K=this._scene.beginDirectAnimation(g.target,[g.animation],void 0!==s?s:this._from,void 0!==N?N:this._to,A,X,void 0,void 0,void 0!==f?f:this._isAdditive);K.weight=this._weight,K.playOrder=this._playOrder,K.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(g),this._checkAnimationGroupEnded(K)},this._processLoop(K,g,E),this._animatables.push(K)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=X,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let A=0;A<this._animatables.length;A++){this._animatables[A].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(A){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==A&&(this.loopAnimation=A),this.restart()):(this.stop(),this.start(A,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let A=0;A<this._animatables.length;A++){this._animatables[A].reset()}return this}restart(){if(!this._isStarted)return this;for(let A=0;A<this._animatables.length;A++){this._animatables[A].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let A=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const X=this._animatables.slice();for(let N=0;N<X.length;N++)X[N].stop(void 0,void 0,!0,A);let s=0;for(let N=0;N<this._scene._activeAnimatables.length;N++){const X=this._scene._activeAnimatables[N];X._runtimeAnimations.length>0?this._scene._activeAnimatables[s++]=X:A&&this._checkAnimationGroupEnded(X,A)}return this._scene._activeAnimatables.length=s,this._isStarted=!1,this}setWeightForAllAnimatables(A){for(let X=0;X<this._animatables.length;X++){this._animatables[X].weight=A}return this}syncAllAnimationsWith(A){for(let X=0;X<this._animatables.length;X++){this._animatables[X].syncWith(A)}return this}goToFrame(A){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let s=0;s<this._animatables.length;s++){this._animatables[s].goToFrame(A,X)}return this}getCurrentFrame(){var A;return(null===(A=this.animatables[0])||void 0===A?void 0:A.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const A=this._scene.animationGroups.indexOf(this);if(A>-1&&this._scene.animationGroups.splice(A,1),this._parentContainer){const A=this._parentContainer.animationGroups.indexOf(this);A>-1&&this._parentContainer.animationGroups.splice(A,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(A){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const s=this._animatables.indexOf(A);s>-1&&this._animatables.splice(s,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,X||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(A,X){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const N=new C(A||this.name,this._scene,this._weight,this._playOrder);N._from=this.from,N._to=this.to,N._speedRatio=this.speedRatio,N._loopAnimation=this.loopAnimation,N._isAdditive=this.isAdditive,N._enableBlending=this.enableBlending,N._blendingSpeed=this.blendingSpeed,N.metadata=this.metadata,N.mask=this.mask;for(const f of this._targetedAnimations)N.addTargetedAnimation(s?f.animation.clone():f.animation,X?X(f.target):f.target);return N}serialize(){const A={};A.name=this.name,A.from=this.from,A.to=this.to,A.speedRatio=this.speedRatio,A.loopAnimation=this.loopAnimation,A.isAdditive=this.isAdditive,A.weight=this.weight,A.playOrder=this.playOrder,A.enableBlending=this.enableBlending,A.blendingSpeed=this.blendingSpeed,A.targetedAnimations=[];for(let X=0;X<this.targetedAnimations.length;X++){const s=this.targetedAnimations[X];A.targetedAnimations[X]=s.serialize()}return g.e&&g.e.HasTags(this)&&(A.tags=g.e.GetTags(this)),this.metadata&&(A.metadata=this.metadata),A}static Parse(A,X){const s=new C(A.name,X,A.weight,A.playOrder);for(let f=0;f<A.targetedAnimations.length;f++){const E=A.targetedAnimations[f],g=N.e.Parse(E.animation),K=E.targetId;if("influence"===E.animation.property){const A=X.getMorphTargetById(K);A&&s.addTargetedAnimation(g,A)}else{const A=X.getNodeById(K);null!=A&&s.addTargetedAnimation(g,A)}}return g.e&&g.e.AddTagsTo(s,A.tags),null!==A.from&&null!==A.to&&s.normalize(A.from,A.to),void 0!==A.speedRatio&&(s._speedRatio=A.speedRatio),void 0!==A.loopAnimation&&(s._loopAnimation=A.loopAnimation),void 0!==A.isAdditive&&(s._isAdditive=A.isAdditive),void 0!==A.weight&&(s._weight=A.weight),void 0!==A.playOrder&&(s._playOrder=A.playOrder),void 0!==A.enableBlending&&(s._enableBlending=A.enableBlending),void 0!==A.blendingSpeed&&(s._blendingSpeed=A.blendingSpeed),void 0!==A.metadata&&(s.metadata=A.metadata),s}static MakeAnimationAdditive(A,X,s){let f;f="object"===typeof X?X:{referenceFrame:X,range:s,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let E=A;f.cloneOriginalAnimationGroup&&(E=A.clone(f.clonedAnimationGroupName||E.name));const g=E.targetedAnimations;for(let K=0;K<g.length;K++){const A=g[K];A.animation=N.e.MakeAnimationAdditive(A.animation,f)}if(E.isAdditive=!0,f.clipKeys){let A=Number.MAX_VALUE,X=-Number.MAX_VALUE;const s=E.targetedAnimations;for(let N=0;N<s.length;N++){const f=s[N].animation.getKeys();A>f[0].frame&&(A=f[0].frame),X<f[f.length-1].frame&&(X=f[f.length-1].frame)}E._from=A,E._to=X}return E}static ClipKeys(A,X,s,N,f){const E=A.clone(N||A.name);return C.ClipKeysInPlace(E,X,s,f)}static ClipKeysInPlace(A,X,s,N){return C.ClipInPlace(A,X,s,N,!1)}static ClipFrames(A,X,s,N,f){const E=A.clone(N||A.name);return C.ClipFramesInPlace(E,X,s,f)}static ClipFramesInPlace(A,X,s,N){return C.ClipInPlace(A,X,s,N,!0)}static ClipInPlace(A,X,s,N){let f=arguments.length>4&&void 0!==arguments[4]&&arguments[4],E=Number.MAX_VALUE,g=-Number.MAX_VALUE;const K=A.targetedAnimations;for(let r=0;r<K.length;r++){const A=K[r],i=N?A.animation:A.animation.clone();f&&(i.createKeyForFrame(X),i.createKeyForFrame(s));const Y=i.getKeys(),v=[];let c=Number.MAX_VALUE;for(let N=0;N<Y.length;N++){const A=Y[N];if(!f&&N>=X&&N<=s||f&&A.frame>=X&&A.frame<=s){const X={frame:A.frame,value:A.value.clone?A.value.clone():A.value,inTangent:A.inTangent,outTangent:A.outTangent,interpolation:A.interpolation,lockedTangent:A.lockedTangent};c===Number.MAX_VALUE&&(c=X.frame),X.frame-=c,v.push(X)}}0!==v.length?(E>v[0].frame&&(E=v[0].frame),g<v[v.length-1].frame&&(g=v[v.length-1].frame),i.setKeys(v,!0),A.animation=i):(K.splice(r,1),r--)}return A._from=E,A._to=g,A}getClassName(){return"AnimationGroup"}toString(A){let X="Name: "+this.name;return X+=", type: "+this.getClassName(),A&&(X+=", from: "+this._from,X+=", to: "+this._to,X+=", isStarted: "+this._isStarted,X+=", speedRatio: "+this._speedRatio,X+=", targetedAnimations length: "+this._targetedAnimations.length,X+=", animatables length: "+this._animatables),X}}}}]);