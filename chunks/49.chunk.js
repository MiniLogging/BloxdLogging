"use strict";(self.ozi0exxand9=self.ozi0exxand9||[]).push([[49],{13839:(f,v,Z)=>{Z.r(v),Z.d(v,{_HDRTextureLoader:()=>O});var V=Z(11421);class h{static ConvertPanoramaToCubemap(f,v,Z,V){let h=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!f)throw"ConvertPanoramaToCubemap: input cannot be null";if(f.length!=v*Z*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(V,this.FACE_FRONT,f,v,Z,h),back:this.CreateCubemapTexture(V,this.FACE_BACK,f,v,Z,h),left:this.CreateCubemapTexture(V,this.FACE_LEFT,f,v,Z,h),right:this.CreateCubemapTexture(V,this.FACE_RIGHT,f,v,Z,h),up:this.CreateCubemapTexture(V,this.FACE_UP,f,v,Z,h),down:this.CreateCubemapTexture(V,this.FACE_DOWN,f,v,Z,h),size:V,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(f,v,Z,V,h){let J=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const l=new ArrayBuffer(f*f*4*3),e=new Float32Array(l),C=J?Math.max(1,Math.round(V/4/f)):1,H=1/C,O=H*H,u=v[1].Fv(v[0]).scale(H/f),W=v[3].Fv(v[2]).scale(H/f),a=1/f;let b=0;for(let X=0;X<f;X++)for(let J=0;J<C;J++){let J=v[0],l=v[2];for(let v=0;v<f;v++)for(let H=0;H<C;H++){const C=l.Fv(J).scale(b).add(J);C.normalize();const H=this.CalcProjectionSpherical(C,Z,V,h);e[X*f*3+3*v+0]+=H.r*O,e[X*f*3+3*v+1]+=H.g*O,e[X*f*3+3*v+2]+=H.b*O,J=J.add(u),l=l.add(W)}b+=a*H}return e}static CalcProjectionSpherical(f,v,Z,V){let h=Math.atan2(f.z,f.x);const J=Math.acos(f.y);for(;h<-Math.PI;)h+=2*Math.PI;for(;h>Math.PI;)h-=2*Math.PI;let l=h/Math.PI;const e=J/Math.PI;l=.5*l+.5;let C=Math.round(l*Z);C<0?C=0:C>=Z&&(C=Z-1);let H=Math.round(e*V);H<0?H=0:H>=V&&(H=V-1);const O=V-H-1;return{r:v[O*Z*3+3*C+0],g:v[O*Z*3+3*C+1],b:v[O*Z*3+3*C+2]}}}function J(f,v,Z,V,h,J){h>0?(h=function(f,v){return v>1023?f*Math.pow(2,1023)*Math.pow(2,v-1023):v<-1074?f*Math.pow(2,-1074)*Math.pow(2,v+1074):f*Math.pow(2,v)}(1,h-136),f[J+0]=v*h,f[J+1]=Z*h,f[J+2]=V*h):(f[J+0]=0,f[J+1]=0,f[J+2]=0)}function l(f,v){let Z="",V="";for(let h=v;h<f.length-v&&(V=String.fromCharCode(f[h]),"\n"!=V);h++)Z+=V;return Z}function e(f){let v=0,Z=0,V=l(f,0);if("#"!=V[0]||"?"!=V[1])throw"Bad HDR Format.";let h=!1,J=!1,e=0;do{e+=V.length+1,V=l(f,e),"FORMAT=32-bit_rle_rgbe"==V?J=!0:0==V.length&&(h=!0)}while(!h);if(!J)throw"HDR Bad header format, unsupported FORMAT";e+=V.length+1,V=l(f,e);const C=/^-Y (.*) \+X (.*)$/g.exec(V);if(!C||C.length<3)throw"HDR Bad header format, no size";if(Z=parseInt(C[2]),v=parseInt(C[1]),Z<8||Z>32767)throw"HDR Bad header format, unsupported size";return e+=V.length+1,{height:v,width:Z,dataPosition:e}}function C(f,v){return function(f,v){let Z=v.height;const V=v.width;let h,l,e,C,O,u=v.dataPosition,W=0,a=0,b=0;const X=new ArrayBuffer(4*V),F=new Uint8Array(X),U=new ArrayBuffer(v.width*v.height*4*3),K=new Float32Array(U);for(;Z>0;){if(h=f[u++],l=f[u++],e=f[u++],C=f[u++],2!=h||2!=l||128&e||v.width<8||v.width>32767)return H(f,v);if((e<<8|C)!=V)throw"HDR Bad header format, wrong scan line width";for(W=0,b=0;b<4;b++)for(a=(b+1)*V;W<a;)if(h=f[u++],l=f[u++],h>128){if(O=h-128,0==O||O>a-W)throw"HDR Bad Format, bad scanline data (run)";for(;O-- >0;)F[W++]=l}else{if(O=h,0==O||O>a-W)throw"HDR Bad Format, bad scanline data (non-run)";if(F[W++]=l,--O>0)for(let v=0;v<O;v++)F[W++]=f[u++]}for(b=0;b<V;b++)h=F[b],l=F[b+V],e=F[b+2*V],C=F[b+3*V],J(K,h,l,e,C,(v.height-Z)*V*3+3*b);Z--}return K}(f,v)}function H(f,v){let Z=v.height;const V=v.width;let h,l,e,C,H,O=v.dataPosition;const u=new ArrayBuffer(v.width*v.height*4*3),W=new Float32Array(u);for(;Z>0;){for(H=0;H<v.width;H++)h=f[O++],l=f[O++],e=f[O++],C=f[O++],J(W,h,l,e,C,(v.height-Z)*V*3+3*H);Z--}return W}h.FACE_LEFT=[new V.Xv(-1,-1,-1),new V.Xv(1,-1,-1),new V.Xv(-1,1,-1),new V.Xv(1,1,-1)],h.FACE_RIGHT=[new V.Xv(1,-1,1),new V.Xv(-1,-1,1),new V.Xv(1,1,1),new V.Xv(-1,1,1)],h.FACE_FRONT=[new V.Xv(1,-1,-1),new V.Xv(1,-1,1),new V.Xv(1,1,-1),new V.Xv(1,1,1)],h.FACE_BACK=[new V.Xv(-1,-1,1),new V.Xv(-1,-1,-1),new V.Xv(-1,1,1),new V.Xv(-1,1,-1)],h.FACE_DOWN=[new V.Xv(1,1,-1),new V.Xv(1,1,1),new V.Xv(-1,1,-1),new V.Xv(-1,1,1)],h.FACE_UP=[new V.Xv(-1,-1,-1),new V.Xv(-1,-1,1),new V.Xv(1,-1,-1),new V.Xv(1,-1,1)];class O{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(f,v,Z){const V=new Uint8Array(f.buffer,f.byteOffset,f.byteLength),h=e(V),J=C(V,h),l=h.width*h.height,H=new Float32Array(4*l);for(let e=0;e<l;e+=1)H[4*e]=J[3*e],H[4*e+1]=J[3*e+1],H[4*e+2]=J[3*e+2],H[4*e+3]=1;Z(h.width,h.height,v.generateMipMaps,!1,(()=>{const f=v.getEngine();v.type=1,v.format=5,v._gammaSpace=!1,f._uploadDataToTextureDirectly(v,H)}))}}}}]);