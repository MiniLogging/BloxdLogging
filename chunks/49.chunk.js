"use strict";(self["2fwzcez286e"]=self["2fwzcez286e"]||[]).push([[49],{15484:(B,u,F)=>{F.r(u),F.d(u,{_HDRTextureLoader:()=>Y});var Z=F(12979);class V{static ConvertPanoramaToCubemap(B,u,F,Z){let V=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!B)throw"ConvertPanoramaToCubemap: input cannot be null";if(B.length!=u*F*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(Z,this.FACE_FRONT,B,u,F,V),back:this.CreateCubemapTexture(Z,this.FACE_BACK,B,u,F,V),left:this.CreateCubemapTexture(Z,this.FACE_LEFT,B,u,F,V),right:this.CreateCubemapTexture(Z,this.FACE_RIGHT,B,u,F,V),up:this.CreateCubemapTexture(Z,this.FACE_UP,B,u,F,V),down:this.CreateCubemapTexture(Z,this.FACE_DOWN,B,u,F,V),size:Z,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(B,u,F,Z,V){let p=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const G=new ArrayBuffer(B*B*4*3),R=new Float32Array(G),e=p?Math.max(1,Math.round(Z/4/B)):1,s=1/e,Y=s*s,Q=u[1].Lu(u[0]).scale(s/B),t=u[3].Lu(u[2]).scale(s/B),v=1/B;let D=0;for(let L=0;L<B;L++)for(let p=0;p<e;p++){let p=u[0],G=u[2];for(let u=0;u<B;u++)for(let s=0;s<e;s++){const e=G.Lu(p).scale(D).add(p);e.normalize();const s=this.CalcProjectionSpherical(e,F,Z,V);R[L*B*3+3*u+0]+=s.r*Y,R[L*B*3+3*u+1]+=s.g*Y,R[L*B*3+3*u+2]+=s.b*Y,p=p.add(Q),G=G.add(t)}D+=v*s}return R}static CalcProjectionSpherical(B,u,F,Z){let V=Math.atan2(B.z,B.x);const p=Math.acos(B.y);for(;V<-Math.PI;)V+=2*Math.PI;for(;V>Math.PI;)V-=2*Math.PI;let G=V/Math.PI;const R=p/Math.PI;G=.5*G+.5;let e=Math.round(G*F);e<0?e=0:e>=F&&(e=F-1);let s=Math.round(R*Z);s<0?s=0:s>=Z&&(s=Z-1);const Y=Z-s-1;return{r:u[Y*F*3+3*e+0],g:u[Y*F*3+3*e+1],b:u[Y*F*3+3*e+2]}}}function p(B,u,F,Z,V,p){V>0?(V=function(B,u){return u>1023?B*Math.pow(2,1023)*Math.pow(2,u-1023):u<-1074?B*Math.pow(2,-1074)*Math.pow(2,u+1074):B*Math.pow(2,u)}(1,V-136),B[p+0]=u*V,B[p+1]=F*V,B[p+2]=Z*V):(B[p+0]=0,B[p+1]=0,B[p+2]=0)}function G(B,u){let F="",Z="";for(let V=u;V<B.length-u&&(Z=String.fromCharCode(B[V]),"\n"!=Z);V++)F+=Z;return F}function R(B){let u=0,F=0,Z=G(B,0);if("#"!=Z[0]||"?"!=Z[1])throw"Bad HDR Format.";let V=!1,p=!1,R=0;do{R+=Z.length+1,Z=G(B,R),"FORMAT=32-bit_rle_rgbe"==Z?p=!0:0==Z.length&&(V=!0)}while(!V);if(!p)throw"HDR Bad header format, unsupported FORMAT";R+=Z.length+1,Z=G(B,R);const e=/^-Y (.*) \+X (.*)$/g.exec(Z);if(!e||e.length<3)throw"HDR Bad header format, no size";if(F=parseInt(e[2]),u=parseInt(e[1]),F<8||F>32767)throw"HDR Bad header format, unsupported size";return R+=Z.length+1,{height:u,width:F,dataPosition:R}}function e(B,u){return function(B,u){let F=u.height;const Z=u.width;let V,G,R,e,Y,Q=u.dataPosition,t=0,v=0,D=0;const L=new ArrayBuffer(4*Z),q=new Uint8Array(L),W=new ArrayBuffer(u.width*u.height*4*3),X=new Float32Array(W);for(;F>0;){if(V=B[Q++],G=B[Q++],R=B[Q++],e=B[Q++],2!=V||2!=G||128&R||u.width<8||u.width>32767)return s(B,u);if((R<<8|e)!=Z)throw"HDR Bad header format, wrong scan line width";for(t=0,D=0;D<4;D++)for(v=(D+1)*Z;t<v;)if(V=B[Q++],G=B[Q++],V>128){if(Y=V-128,0==Y||Y>v-t)throw"HDR Bad Format, bad scanline data (run)";for(;Y-- >0;)q[t++]=G}else{if(Y=V,0==Y||Y>v-t)throw"HDR Bad Format, bad scanline data (non-run)";if(q[t++]=G,--Y>0)for(let u=0;u<Y;u++)q[t++]=B[Q++]}for(D=0;D<Z;D++)V=q[D],G=q[D+Z],R=q[D+2*Z],e=q[D+3*Z],p(X,V,G,R,e,(u.height-F)*Z*3+3*D);F--}return X}(B,u)}function s(B,u){let F=u.height;const Z=u.width;let V,G,R,e,s,Y=u.dataPosition;const Q=new ArrayBuffer(u.width*u.height*4*3),t=new Float32Array(Q);for(;F>0;){for(s=0;s<u.width;s++)V=B[Y++],G=B[Y++],R=B[Y++],e=B[Y++],p(t,V,G,R,e,(u.height-F)*Z*3+3*s);F--}return t}V.FACE_LEFT=[new Z.Du(-1,-1,-1),new Z.Du(1,-1,-1),new Z.Du(-1,1,-1),new Z.Du(1,1,-1)],V.FACE_RIGHT=[new Z.Du(1,-1,1),new Z.Du(-1,-1,1),new Z.Du(1,1,1),new Z.Du(-1,1,1)],V.FACE_FRONT=[new Z.Du(1,-1,-1),new Z.Du(1,-1,1),new Z.Du(1,1,-1),new Z.Du(1,1,1)],V.FACE_BACK=[new Z.Du(-1,-1,1),new Z.Du(-1,-1,-1),new Z.Du(-1,1,1),new Z.Du(-1,1,-1)],V.FACE_DOWN=[new Z.Du(1,1,-1),new Z.Du(1,1,1),new Z.Du(-1,1,-1),new Z.Du(-1,1,1)],V.FACE_UP=[new Z.Du(-1,-1,-1),new Z.Du(-1,-1,1),new Z.Du(1,-1,-1),new Z.Du(1,-1,1)];class Y{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(B,u,F){const Z=new Uint8Array(B.buffer,B.byteOffset,B.byteLength),V=R(Z),p=e(Z,V),G=V.width*V.height,s=new Float32Array(4*G);for(let R=0;R<G;R+=1)s[4*R]=p[3*R],s[4*R+1]=p[3*R+1],s[4*R+2]=p[3*R+2],s[4*R+3]=1;F(V.width,V.height,u.generateMipMaps,!1,(()=>{const B=u.getEngine();u.type=1,u.format=5,u._gammaSpace=!1,B._uploadDataToTextureDirectly(u,s)}))}}}}]);