"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[49],{14853:(M,Z,P)=>{P.r(Z),P.d(Z,{_HDRTextureLoader:()=>d});var x=P(12373);class c{static ConvertPanoramaToCubemap(M,Z,P,x){let c=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!M)throw"ConvertPanoramaToCubemap: input cannot be null";if(M.length!=Z*P*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(x,this.FACE_FRONT,M,Z,P,c),back:this.CreateCubemapTexture(x,this.FACE_BACK,M,Z,P,c),left:this.CreateCubemapTexture(x,this.FACE_LEFT,M,Z,P,c),right:this.CreateCubemapTexture(x,this.FACE_RIGHT,M,Z,P,c),up:this.CreateCubemapTexture(x,this.FACE_UP,M,Z,P,c),down:this.CreateCubemapTexture(x,this.FACE_DOWN,M,Z,P,c),size:x,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(M,Z,P,x,c){let w=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const v=new ArrayBuffer(M*M*4*3),G=new Float32Array(v),mM=w?Math.max(1,Math.round(x/4/M)):1,K=1/mM,d=K*K,O=Z[1].UZ(Z[0]).scale(K/M),H=Z[3].UZ(Z[2]).scale(K/M),j=1/M;let B=0;for(let U=0;U<M;U++)for(let w=0;w<mM;w++){let w=Z[0],v=Z[2];for(let Z=0;Z<M;Z++)for(let K=0;K<mM;K++){const mM=v.UZ(w).scale(B).add(w);mM.normalize();const K=this.CalcProjectionSpherical(mM,P,x,c);G[U*M*3+3*Z+0]+=K.r*d,G[U*M*3+3*Z+1]+=K.g*d,G[U*M*3+3*Z+2]+=K.b*d,w=w.add(O),v=v.add(H)}B+=j*K}return G}static CalcProjectionSpherical(M,Z,P,x){let c=Math.atan2(M.z,M.x);const w=Math.acos(M.y);for(;c<-Math.PI;)c+=2*Math.PI;for(;c>Math.PI;)c-=2*Math.PI;let v=c/Math.PI;const G=w/Math.PI;v=.5*v+.5;let mM=Math.round(v*P);mM<0?mM=0:mM>=P&&(mM=P-1);let K=Math.round(G*x);K<0?K=0:K>=x&&(K=x-1);const d=x-K-1;return{r:Z[d*P*3+3*mM+0],g:Z[d*P*3+3*mM+1],b:Z[d*P*3+3*mM+2]}}}function w(M,Z,P,x,c,w){c>0?(c=function(M,Z){return Z>1023?M*Math.pow(2,1023)*Math.pow(2,Z-1023):Z<-1074?M*Math.pow(2,-1074)*Math.pow(2,Z+1074):M*Math.pow(2,Z)}(1,c-136),M[w+0]=Z*c,M[w+1]=P*c,M[w+2]=x*c):(M[w+0]=0,M[w+1]=0,M[w+2]=0)}function v(M,Z){let P="",x="";for(let c=Z;c<M.length-Z&&(x=String.fromCharCode(M[c]),"\n"!=x);c++)P+=x;return P}function G(M){let Z=0,P=0,x=v(M,0);if("#"!=x[0]||"?"!=x[1])throw"Bad HDR Format.";let c=!1,w=!1,G=0;do{G+=x.length+1,x=v(M,G),"FORMAT=32-bit_rle_rgbe"==x?w=!0:0==x.length&&(c=!0)}while(!c);if(!w)throw"HDR Bad header format, unsupported FORMAT";G+=x.length+1,x=v(M,G);const mM=/^-Y (.*) \+X (.*)$/g.exec(x);if(!mM||mM.length<3)throw"HDR Bad header format, no size";if(P=parseInt(mM[2]),Z=parseInt(mM[1]),P<8||P>32767)throw"HDR Bad header format, unsupported size";return G+=x.length+1,{height:Z,width:P,dataPosition:G}}function mM(M,Z){return function(M,Z){let P=Z.height;const x=Z.width;let c,v,G,mM,d,O=Z.dataPosition,H=0,j=0,B=0;const U=new ArrayBuffer(4*x),n=new Uint8Array(U),L=new ArrayBuffer(Z.width*Z.height*4*3),u=new Float32Array(L);for(;P>0;){if(c=M[O++],v=M[O++],G=M[O++],mM=M[O++],2!=c||2!=v||128&G||Z.width<8||Z.width>32767)return K(M,Z);if((G<<8|mM)!=x)throw"HDR Bad header format, wrong scan line width";for(H=0,B=0;B<4;B++)for(j=(B+1)*x;H<j;)if(c=M[O++],v=M[O++],c>128){if(d=c-128,0==d||d>j-H)throw"HDR Bad Format, bad scanline data (run)";for(;d-- >0;)n[H++]=v}else{if(d=c,0==d||d>j-H)throw"HDR Bad Format, bad scanline data (non-run)";if(n[H++]=v,--d>0)for(let Z=0;Z<d;Z++)n[H++]=M[O++]}for(B=0;B<x;B++)c=n[B],v=n[B+x],G=n[B+2*x],mM=n[B+3*x],w(u,c,v,G,mM,(Z.height-P)*x*3+3*B);P--}return u}(M,Z)}function K(M,Z){let P=Z.height;const x=Z.width;let c,v,G,mM,K,d=Z.dataPosition;const O=new ArrayBuffer(Z.width*Z.height*4*3),H=new Float32Array(O);for(;P>0;){for(K=0;K<Z.width;K++)c=M[d++],v=M[d++],G=M[d++],mM=M[d++],w(H,c,v,G,mM,(Z.height-P)*x*3+3*K);P--}return H}c.FACE_LEFT=[new x.BZ(-1,-1,-1),new x.BZ(1,-1,-1),new x.BZ(-1,1,-1),new x.BZ(1,1,-1)],c.FACE_RIGHT=[new x.BZ(1,-1,1),new x.BZ(-1,-1,1),new x.BZ(1,1,1),new x.BZ(-1,1,1)],c.FACE_FRONT=[new x.BZ(1,-1,-1),new x.BZ(1,-1,1),new x.BZ(1,1,-1),new x.BZ(1,1,1)],c.FACE_BACK=[new x.BZ(-1,-1,1),new x.BZ(-1,-1,-1),new x.BZ(-1,1,1),new x.BZ(-1,1,-1)],c.FACE_DOWN=[new x.BZ(1,1,-1),new x.BZ(1,1,1),new x.BZ(-1,1,-1),new x.BZ(-1,1,1)],c.FACE_UP=[new x.BZ(-1,-1,-1),new x.BZ(-1,-1,1),new x.BZ(1,-1,-1),new x.BZ(1,-1,1)];class d{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(M,Z,P){const x=new Uint8Array(M.buffer,M.byteOffset,M.byteLength),c=G(x),w=mM(x,c),v=c.width*c.height,K=new Float32Array(4*v);for(let G=0;G<v;G+=1)K[4*G]=w[3*G],K[4*G+1]=w[3*G+1],K[4*G+2]=w[3*G+2],K[4*G+3]=1;P(c.width,c.height,Z.generateMipMaps,!1,(()=>{const M=Z.getEngine();Z.type=1,Z.format=5,Z._gammaSpace=!1,M._uploadDataToTextureDirectly(Z,K)}))}}}}]);