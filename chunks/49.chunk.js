"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{14024:(u,F,z)=>{z.r(F),z.d(F,{AnimationGroup:()=>d,TargetedAnimation:()=>e});var p=z(12829),b=z(523),R=z(575),c=z(688),I=z(12822),G=z(730);class X{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(u,F,z,b){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=F,this._target=u,this._scene=z,this._host=b,this._activeTargets=[],F._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===p.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=G.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const u={frame:0,value:this._minValue};this._keys.splice(0,0,u)}if(this._target instanceof Array){let u=0;for(const F of this._target)this._preparePath(F,u),this._getOriginalValues(u),u++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const R=F.getEvents();if(R&&R.length>0)for(const p of R)this._events.push(p._clone());this._enableBlending=u&&u.animationPropertiesOverride?u.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(u){let F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const z=this._animation.targetPropertyPath;if(z.length>1){let p=u;for(let u=0;u<z.length-1;u++){const F=z[u];if(p=p[F],void 0===p)throw new Error(`Invalid property (${F}) in property path (${z.join(".")})`)}this._targetPath=z[z.length-1],this._activeTargets[F]=p}else this._targetPath=z[0],this._activeTargets[F]=u;if(void 0===this._activeTargets[F][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${z.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let u=0;for(const F of this._target)void 0!==this._originalValue[u]&&this._setValue(F,this._activeTargets[u],this._originalValue[u],-1,u),u++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let u=0;u<this._events.length;u++)this._events[u].isDone=!1}isStopped(){return this._stopped}dispose(){const u=this._animation.runtimeAnimations.indexOf(this);u>-1&&this._animation.runtimeAnimations.splice(u,1)}setValue(u,F){if(this._targetIsArray)for(let z=0;z<this._target.length;z++){const p=this._target[z];this._setValue(p,this._activeTargets[z],u,F,z)}else this._setValue(this._target,this._directTarget,u,F,0)}_getOriginalValues(){let u,F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const z=this._activeTargets[F];u=z.getLocalMatrix&&"_matrix"===this._targetPath?z.getLocalMatrix():z[this._targetPath],u&&u.clone?this._originalValue[F]=u.clone():this._originalValue[F]=u}_registerTargetForLateAnimationBinding(u,F){const z=u.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(z),z._lateAnimationHolders||(z._lateAnimationHolders={}),z._lateAnimationHolders[u.targetPath]||(z._lateAnimationHolders[u.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:F}),u.isAdditive?(z._lateAnimationHolders[u.targetPath].additiveAnimations.push(u),z._lateAnimationHolders[u.targetPath].totalAdditiveWeight+=u.weight):(z._lateAnimationHolders[u.targetPath].animations.push(u),z._lateAnimationHolders[u.targetPath].totalWeight+=u.weight)}_setValue(u,F,z,b,R){if(this._currentActiveTarget=F,this._weight=b,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const u=F[this._targetPath];u.clone?this._originalBlendValue=u.clone():this._originalBlendValue=u}this._originalBlendValue.m?p.e.AllowMatrixDecomposeForInterpolation?this._currentValue?G.b.DecomposeLerpToRef(this._originalBlendValue,z,this._blendingFactor,this._currentValue):this._currentValue=G.b.DecomposeLerp(this._originalBlendValue,z,this._blendingFactor):this._currentValue?G.b.LerpToRef(this._originalBlendValue,z,this._blendingFactor,this._currentValue):this._currentValue=G.b.Lerp(this._originalBlendValue,z,this._blendingFactor):this._currentValue=p.e._UniversalLerp(this._originalBlendValue,z,this._blendingFactor);const b=u&&u.animationPropertiesOverride?u.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=b}else this._currentValue?this._currentValue.p?this._currentValue.p(z):this._currentValue=z:null!==z&&void 0!==z&&z.clone?this._currentValue=z.clone():this._currentValue=z;-1!==b?this._registerTargetForLateAnimationBinding(this,this._originalValue[R]):this._animationState.loopMode===p.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[R],F[this._targetPath]):F[this._targetPath]=this._originalValue[R]+this._currentValue:F[this._targetPath]=this._currentValue,u.Wj&&u.Wj(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(u){let F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const z=this._animation.getKeys();u<z[0].frame?u=z[0].frame:u>z[z.length-1].frame&&(u=z[z.length-1].frame);const p=this._events;if(p.length)for(let R=0;R<p.length;R++)p[R].onlyOnce||(p[R].isDone=p[R].frame<u);this._currentFrame=u;const b=this._animation._interpolate(u,this._animationState);this.setValue(b,F)}_prepareForSpeedRatioChange(u){const F=this._previousElapsedTime*(this._animation.framePerSecond*u)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-F}animate(u,F,z,b,R){let c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const I=this._animation,G=I.targetPropertyPath;if(!G||G.length<1)return this._stopped=!0,!1;let X,j=!0;const W=this._events;let E=0;if(this._coreRuntimeAnimation)E=z-F,X=this._coreRuntimeAnimation.currentFrame,this._currentFrame=X,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let c;(F<this._minFrame||F>this._maxFrame)&&(F=this._minFrame),(z<this._minFrame||z>this._maxFrame)&&(z=this._maxFrame),E=z-F;let G=u*(I.framePerSecond*R)/1e3+this._absoluteFrameOffset,L=0,k=!1;const N=b&&this._animationState.loopMode===p.e.ANIMATIONLOOPMODE_YOYO;if(N){const u=(G-F)/E,z=Math.sin(u*Math.PI);G=Math.abs(z)*E+F;const p=z>=0?1:-1;this._yoyoDirection!==p&&(k=!0),this._yoyoDirection=p}if(this._previousElapsedTime=u,this._previousAbsoluteFrame=G,!b&&z>=F&&(G>=E&&R>0||G<=0&&R<0))j=!1,L=I._getKeyValue(this._maxValue);else if(!b&&F>=z&&(G<=E&&R<0||G>=0&&R>0))j=!1,L=I._getKeyValue(this._minValue);else if(this._animationState.loopMode!==p.e.ANIMATIONLOOPMODE_CYCLE){const u=z.toString()+F.toString();if(!this._offsetsCache[u]){this._animationState.repeatCount=0,this._animationState.loopMode=p.e.ANIMATIONLOOPMODE_CYCLE;const b=I._interpolate(F,this._animationState),R=I._interpolate(z,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),I.dataType){case p.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[u]=R-b;break;case p.e.ANIMATIONTYPE_QUATERNION:case p.e.ANIMATIONTYPE_VECTOR3:case p.e.ANIMATIONTYPE_VECTOR2:case p.e.ANIMATIONTYPE_SIZE:case p.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[u]=R.Md(b)}this._highLimitsCache[u]=R}L=this._highLimitsCache[u],c=this._offsetsCache[u]}if(void 0===c)switch(I.dataType){case p.e.ANIMATIONTYPE_FLOAT:c=0;break;case p.e.ANIMATIONTYPE_QUATERNION:c=p.j;break;case p.e.ANIMATIONTYPE_VECTOR3:c=p.u;break;case p.e.ANIMATIONTYPE_VECTOR2:c=p.q;break;case p.e.ANIMATIONTYPE_SIZE:c=p.m;break;case p.e.ANIMATIONTYPE_COLOR3:c=p.h;break;case p.e.ANIMATIONTYPE_COLOR4:c=p.i}if(this._host&&this._host.syncRoot){const u=this._host.syncRoot;X=F+E*((u.masterFrame-u.fromFrame)/(u.toFrame-u.fromFrame))}else X=G>0&&F>z||G<0&&F<z?j&&0!==E?z+G%E:F:j&&0!==E?F+G%E:z;if(!N&&(R>0&&this.currentFrame>X||R<0&&this.currentFrame<X)||N&&k){this._onLoop();for(let u=0;u<W.length;u++)W[u].onlyOnce||(W[u].isDone=!1);this._animationState.key=R>0?0:I.getKeys().length-1}this._currentFrame=X,this._animationState.repeatCount=0===E?0:G/E|0,this._animationState.highLimitValue=L,this._animationState.offsetValue=c}const L=I._interpolate(X,this._animationState);if(this.setValue(L,c),W.length)for(let p=0;p<W.length;p++)if(E>=0&&X>=W[p].frame&&W[p].frame>=F||E<0&&X<=W[p].frame&&W[p].frame<=F){const u=W[p];u.isDone||(u.onlyOnce&&(W.splice(p,1),p--),u.isDone=!0,u.action(X))}return j||(this._stopped=!0),j}}var j=z(553);class W{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(u){this._weight=-1!==u?Math.min(Math.max(u,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(u){for(let F=0;F<this._runtimeAnimations.length;F++){this._runtimeAnimations[F]._prepareForSpeedRatioChange(u)}this._speedRatio=u,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(u,F){let z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,R=arguments.length>4&&void 0!==arguments[4]&&arguments[4],c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,I=arguments.length>6?arguments[6]:void 0,G=arguments.length>7?arguments[7]:void 0,X=arguments.length>8?arguments[8]:void 0,j=arguments.length>9&&void 0!==arguments[9]&&arguments[9],W=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=F,this.fromFrame=z,this.toFrame=p,this.loopAnimation=R,this.onAnimationEnd=I,this.onAnimationLoop=X,this.isAdditive=j,this.playOrder=W,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Rj=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new b.d,this.onAnimationLoopObservable=new b.d,this._scene=u,G&&this.appendAnimations(F,G),this._speedRatio=c,u._activeAnimatables.push(this)}syncWith(u){if(this._syncRoot=u,u){const u=this._scene._activeAnimatables.indexOf(this);u>-1&&(this._scene._activeAnimatables.splice(u,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(u,F){for(let z=0;z<F.length;z++){const p=F[z],b=new X(u,p,this._scene,this);b._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(b)}}getAnimationByTargetProperty(u){const F=this._runtimeAnimations;for(let z=0;z<F.length;z++)if(F[z].animation.targetProperty===u)return F[z].animation;return null}getRuntimeAnimationByTargetProperty(u){const F=this._runtimeAnimations;for(let z=0;z<F.length;z++)if(F[z].animation.targetProperty===u)return F[z];return null}reset(){const u=this._runtimeAnimations;for(let F=0;F<u.length;F++)u[F].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(u){const F=this._runtimeAnimations;for(let z=0;z<F.length;z++)F[z].animation.enableBlending=!0,F[z].animation.blendingSpeed=u}disableBlending(){const u=this._runtimeAnimations;for(let F=0;F<u.length;F++)u[F].animation.enableBlending=!1}goToFrame(u){let F=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const z=this._runtimeAnimations;if(z[0]){const F=z[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??z[0].currentFrame;const p=0===this.speedRatio?0:(u-this._frameToSyncFromJump)/F*1e3/this.speedRatio;this._manualJumpDelay=-p}for(let p=0;p<z.length;p++)z[p].goToFrame(u,F?this._weight:-1);this._goToFrame=u}get paused(){return this.Rj}pause(){this.Rj||(this.Rj=!0)}restart(){this.Rj=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(u,F){let z=arguments.length>2&&void 0!==arguments[2]&&arguments[2],p=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(u||F){const b=this._scene._activeAnimatables.indexOf(this);if(b>-1){const R=this._runtimeAnimations;for(let z=R.length-1;z>=0;z--){const p=R[z];u&&p.animation.name!=u||(F&&!F(p.target)||(p.dispose(),R.splice(z,1)))}0==R.length&&(z||this._scene._activeAnimatables.splice(b,1),p||this._raiseOnAnimationEnd())}}else{const u=this._scene._activeAnimatables.indexOf(this);if(u>-1){z||this._scene._activeAnimatables.splice(u,1);const F=this._runtimeAnimations;for(let u=0;u<F.length;u++)F[u].dispose();this._runtimeAnimations.length=0,p||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((u=>{this.onAnimationEndObservable.add((()=>{u(this)}),void 0,void 0,this,!0)}))}_animate(u){if(this.Rj)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=u),!0;if(null===this._localDelayOffset?(this._localDelayOffset=u,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=u-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let F=!1;const z=this._runtimeAnimations;let p;for(p=0;p<z.length;p++){const b=z[p].animate(u-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);F=F||b}if(this.animationStarted=F,!F){if(this.disposeOnEnd)for(p=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(p,1),p=0;p<z.length;p++)z[p].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return F}}function E(u){if(0===u.totalWeight&&0===u.totalAdditiveWeight)return u.originalValue;let F=1;const z=G.h.$j[0],p=G.h.$j[1],b=G.h.Quaternion[0];let R=0;const c=u.animations[0],I=u.originalValue;let X=1,j=!1;if(u.totalWeight<1)X=1-u.totalWeight,I.decompose(p,b,z);else{if(R=1,F=u.totalWeight,X=c.weight/F,1==X){if(!u.totalAdditiveWeight)return c.currentValue;j=!0}c.currentValue.decompose(p,b,z)}if(!j){p.scaleInPlace(X),z.scaleInPlace(X),b.scaleInPlace(X);for(let c=R;c<u.animations.length;c++){const R=u.animations[c];if(0===R.weight)continue;X=R.weight/F;const I=G.h.$j[2],j=G.h.$j[3],W=G.h.Quaternion[1];R.currentValue.decompose(j,W,I),j.scaleAndAddToRef(X,p),W.scaleAndAddToRef(G.f.Dot(b,W)>0?X:-X,b),I.scaleAndAddToRef(X,z)}b.normalize()}for(let E=0;E<u.additiveAnimations.length;E++){const F=u.additiveAnimations[E];if(0===F.weight)continue;const R=G.h.$j[2],c=G.h.$j[3],I=G.h.Quaternion[1];F.currentValue.decompose(c,I,R),c.multiplyToRef(p,c),G.l.LerpToRef(p,c,F.weight,p),b.multiplyToRef(I,I),G.f.SlerpToRef(b,I,F.weight,b),R.scaleAndAddToRef(F.weight,z)}const W=c?c._animationState.workValue:G.h.Matrix[0].clone();return G.b.ComposeToRef(p,b,z,W),W}function L(u,F){if(0===u.totalWeight&&0===u.totalAdditiveWeight)return F;const z=u.animations[0],p=u.originalValue;let b=F;if(0===u.totalWeight&&u.totalAdditiveWeight>0)b.p(p);else if(1===u.animations.length){if(G.f.SlerpToRef(p,z.currentValue,Math.min(1,u.totalWeight),b),0===u.totalAdditiveWeight)return b}else if(u.animations.length>1){let z,R,c=1;if(u.totalWeight<1){const F=1-u.totalWeight;z=[],R=[],z.push(p),R.push(F)}else{if(2===u.animations.length&&(G.f.SlerpToRef(u.animations[0].currentValue,u.animations[1].currentValue,u.animations[1].weight/u.totalWeight,F),0===u.totalAdditiveWeight))return F;z=[],R=[],c=u.totalWeight}for(let F=0;F<u.animations.length;F++){const p=u.animations[F];z.push(p.currentValue),R.push(p.weight/c)}let I=0;for(let u=0;u<z.length;)u?(I+=R[u],G.f.SlerpToRef(b,z[u],R[u]/I,b),u++):(G.f.SlerpToRef(z[u],z[u+1],R[u+1]/(R[u]+R[u+1]),F),b=F,I=R[u]+R[u+1],u+=2)}for(let R=0;R<u.additiveAnimations.length;R++){const F=u.additiveAnimations[R];0!==F.weight&&(b.multiplyToRef(F.currentValue,G.h.Quaternion[0]),G.f.SlerpToRef(b,G.h.Quaternion[0],F.weight,b))}return b}var k,N,Y=z(2531);k=Y.e,(N=I.b)&&(N.prototype.copyAnimationRange=function(u,F,z){let b=arguments.length>3&&void 0!==arguments[3]&&arguments[3],R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new p.e(this.name,"_matrix",u.animations[0].framePerSecond,p.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const c=u.animations[0].getRange(F);if(!c)return!1;const I=c.from,G=c.to,X=u.animations[0].getKeys(),j=u.length,W=u.getParent(),E=this.getParent(),L=b&&W&&j&&this.length&&j!==this.length,k=L&&E&&W?E.length/W.length:1,N=b&&!E&&R&&(1!==R.x||1!==R.y||1!==R.z),Y=this.animations[0].getKeys();let e,d,C;for(let p=0,r=X.length;p<r;p++)e=X[p],e.frame>=I&&e.frame<=G&&(b?(C=e.value.clone(),L?(d=C.getTranslation(),C.setTranslation(d.scaleInPlace(k))):N&&R?(d=C.getTranslation(),C.setTranslation(d.multiplyInPlace(R))):C=e.value):C=e.value,Y.push({frame:e.frame+z,value:C}));return this.animations[0].createRange(F,I+z,G+z),!0}),k&&(k.prototype._animate=function(u){if(!this.animationsEnabled)return;const F=j.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=F}this.deltaTime=void 0!==u?u:this.useConstantAnimationDeltaTime?16:(F-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=F;const z=this._activeAnimatables;if(0===z.length)return;this._animationTime+=this.deltaTime;const b=this._animationTime;for(let p=0;p<z.length;p++){const u=z[p];!u._animate(b)&&u.disposeOnEnd&&p--}!function(u){if(u._registeredForLateAnimationBindings.length){for(let F=0;F<u._registeredForLateAnimationBindings.length;F++){const z=u._registeredForLateAnimationBindings.data[F];for(const u in z._lateAnimationHolders){const F=z._lateAnimationHolders[u],b=F.animations[0],R=F.originalValue;if(void 0===R||null===R)continue;const c=p.e.AllowMatrixDecomposeForInterpolation&&R.m;let I=z[u];if(c)I=E(F);else if(void 0!==R.w)I=L(F,I||G.f.Identity());else{let u=0,z=1;const c=b&&b._animationState.loopMode===p.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(F.totalWeight<1)I=c?R.clone?R.clone():R:b&&R.scale?R.scale(1-F.totalWeight):b?R*(1-F.totalWeight):R.clone?R.clone():R;else if(b){z=F.totalWeight;const p=b.weight/z;I=1!==p?b.currentValue.scale?b.currentValue.scale(p):b.currentValue*p:b.currentValue,c&&(I.addToRef?I.addToRef(R,I):I+=R),u=1}for(let p=u;p<F.animations.length;p++){const u=F.animations[p],b=u.weight/z;b&&(u.currentValue.scaleAndAddToRef?u.currentValue.scaleAndAddToRef(b,I):I+=u.currentValue*b)}for(let p=0;p<F.additiveAnimations.length;p++){const u=F.additiveAnimations[p],z=u.weight;z&&(u.currentValue.scaleAndAddToRef?u.currentValue.scaleAndAddToRef(z,I):I+=u.currentValue*z)}}z[u]=I}z._lateAnimationHolders={}}u._registeredForLateAnimationBindings.reset()}}(this)},k.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((u,F)=>u.playOrder-F.playOrder))},k.prototype.beginWeightedAnimation=function(u,F,z){let p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,b=arguments.length>4?arguments[4]:void 0,R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,c=arguments.length>6?arguments[6]:void 0,I=arguments.length>7?arguments[7]:void 0,G=arguments.length>8?arguments[8]:void 0,X=arguments.length>9?arguments[9]:void 0,j=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const W=this.beginAnimation(u,F,z,b,R,c,I,!1,G,X,j);return W.weight=p,W},k.prototype.beginAnimation=function(u,F,z,p){let b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,R=arguments.length>5?arguments[5]:void 0,c=arguments.length>6?arguments[6]:void 0,I=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],G=arguments.length>8?arguments[8]:void 0,X=arguments.length>9?arguments[9]:void 0,j=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(b<0){const u=F;F=z,z=u,b=-b}F>z&&(b=-b),I&&this.stopAnimation(u,void 0,G),c||(c=new W(this,u,F,z,p,b,R,void 0,X,j));const E=!G||G(u);if(u.animations&&E&&c.appendAnimations(u,u.animations),u.getAnimatables){const j=u.getAnimatables();for(let u=0;u<j.length;u++)this.beginAnimation(j[u],F,z,p,b,R,c,I,G,X)}return c.reset(),c},k.prototype.beginHierarchyAnimation=function(u,F,z,p,b){let R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,c=arguments.length>6?arguments[6]:void 0,I=arguments.length>7?arguments[7]:void 0,G=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],X=arguments.length>9?arguments[9]:void 0,j=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const W=u.getDescendants(F),E=[];E.push(this.beginAnimation(u,z,p,b,R,c,I,G,X,void 0,j));for(const L of W)E.push(this.beginAnimation(L,z,p,b,R,c,I,G,X,void 0,j));return E},k.prototype.beginDirectAnimation=function(u,F,z,p,b){let R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(R<0){const u=z;z=p,p=u,R=-R}return z>p&&(R=-R),new W(this,u,z,p,b,R,arguments.length>6?arguments[6]:void 0,F,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},k.prototype.beginDirectHierarchyAnimation=function(u,F,z,p,b,R,c,I,G){let X=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const j=u.getDescendants(F),W=[];W.push(this.beginDirectAnimation(u,z,p,b,R,c,I,G,X));for(const E of j)W.push(this.beginDirectAnimation(E,z,p,b,R,c,I,G,X));return W},k.prototype.getAnimatableByTarget=function(u){for(let F=0;F<this._activeAnimatables.length;F++)if(this._activeAnimatables[F].target===u)return this._activeAnimatables[F];return null},k.prototype.getAllAnimatablesByTarget=function(u){const F=[];for(let z=0;z<this._activeAnimatables.length;z++)this._activeAnimatables[z].target===u&&F.push(this._activeAnimatables[z]);return F},k.prototype.stopAnimation=function(u,F,z){const p=this.getAllAnimatablesByTarget(u);for(const b of p)b.stop(F,z)},k.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let u=0;u<this._activeAnimatables.length;u++)this._activeAnimatables[u].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const u of this.animationGroups)u.stop()});class e{getClassName(){return"TargetedAnimation"}serialize(){const u={};return u.animation=this.animation.serialize(),u.targetId=this.target.id,u}}class d{get mask(){return this._mask}set mask(u){this._mask!==u&&(this._mask=u,this.syncWithMask(!0))}syncWithMask(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||u){this._numActiveAnimatables=0;for(let u=0;u<this._animatables.length;++u){const F=this._animatables[u];!this.mask||this.mask.disabled||this.mask.retainsTarget(F.target.name)?(this._numActiveAnimatables++,F.paused&&F.restart()):F.paused||F.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let u=0;u<this._animatables.length;++u){const F=this._animatables[u];this.mask.retainsTarget(F.target.name)||(F.stop(),this._animatables.splice(u,1),--u)}for(let u=0;u<this._targetedAnimations.length;u++){const F=this._targetedAnimations[u];this.mask.retainsTarget(F.target.name)||(this._targetedAnimations.splice(u,1),--u)}}}get from(){return this._from}set from(u){if(this._from!==u){this._from=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].fromFrame=this._from}}}get to(){return this._to}set to(u){if(this._to!==u){this._to=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(u){if(this._speedRatio!==u){this._speedRatio=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(u){if(this._loopAnimation!==u){this._loopAnimation=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(u){if(this._isAdditive!==u){this._isAdditive=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(u){this._weight!==u&&(this._weight=u,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(u){if(this._playOrder!==u&&(this._playOrder=u,this._animatables.length>0)){for(let u=0;u<this._animatables.length;u++)this._animatables[u].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(u){if(this._enableBlending!==u&&(this._enableBlending=u,null!==u))for(let F=0;F<this._targetedAnimations.length;++F)this._targetedAnimations[F].animation.enableBlending=u}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(u){if(this._blendingSpeed!==u&&(this._blendingSpeed=u,null!==u))for(let F=0;F<this._targetedAnimations.length;++F)this._targetedAnimations[F].animation.blendingSpeed=u}getLength(u,F){u=u??this._from;return((F=F??this._to)-u)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(u){let F=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2],p=arguments.length>3?arguments[3]:void 0;if(0===u.length)return null;p=p??u[0].weight;let b=Number.MAX_VALUE,R=-Number.MAX_VALUE;if(z)for(const I of u)I.from<b&&(b=I.from),I.to>R&&(R=I.to);const c=new d(u[0].name+"_merged",u[0]._scene,p);for(const I of u){z&&I.normalize(b,R);for(const u of I.targetedAnimations)c.addTargetedAnimation(u.animation,u.target);F&&I.dispose()}return c}constructor(u){let F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=u,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new b.d,this.onAnimationLoopObservable=new b.d,this.onAnimationGroupLoopObservable=new b.d,this.onAnimationGroupEndObservable=new b.d,this.onAnimationGroupPauseObservable=new b.d,this.onAnimationGroupPlayObservable=new b.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=F||R.e.LastCreatedScene,this._weight=z,this._playOrder=p,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(u,F){const z=new e;z.animation=u,z.target=F;const p=u.getKeys();return this._from>p[0].frame&&(this._from=p[0].frame),this._to<p[p.length-1].frame&&(this._to=p[p.length-1].frame),null!==this._enableBlending&&(u.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(u.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(z),this._shouldStart=!0,z}removeTargetedAnimation(u){for(let F=this._targetedAnimations.length-1;F>-1;F--){this._targetedAnimations[F].animation===u&&this._targetedAnimations.splice(F,1)}}normalize(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==u&&(u=this._from),null==F&&(F=this._to);for(let z=0;z<this._targetedAnimations.length;z++){const p=this._targetedAnimations[z].animation.getKeys(),b=p[0],R=p[p.length-1];if(b.frame>u){const F={frame:u,value:b.value,inTangent:b.inTangent,outTangent:b.outTangent,interpolation:b.interpolation};p.splice(0,0,F)}if(R.frame<F){const u={frame:F,value:R.value,inTangent:R.inTangent,outTangent:R.outTangent,interpolation:R.interpolation};p.push(u)}}return this._from=u,this._to=F,this}_processLoop(u,F,z){u.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(F),this._animationLoopFlags[z]||(this._animationLoopFlags[z]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0],F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,z=arguments.length>2?arguments[2]:void 0,p=arguments.length>3?arguments[3]:void 0,b=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=u,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let R=0;R<this._targetedAnimations.length;R++){const c=this._targetedAnimations[R],I=this._scene.beginDirectAnimation(c.target,[c.animation],void 0!==z?z:this._from,void 0!==p?p:this._to,u,F,void 0,void 0,void 0!==b?b:this._isAdditive);I.weight=this._weight,I.playOrder=this._playOrder,I.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(c),this._checkAnimationGroupEnded(I)},this._processLoop(I,c,R),this._animatables.push(I)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=F,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let u=0;u<this._animatables.length;u++){this._animatables[u].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(u){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==u&&(this.loopAnimation=u),this.restart()):(this.stop(),this.start(u,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let u=0;u<this._animatables.length;u++){this._animatables[u].reset()}return this}restart(){if(!this._isStarted)return this;for(let u=0;u<this._animatables.length;u++){this._animatables[u].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const F=this._animatables.slice();for(let p=0;p<F.length;p++)F[p].stop(void 0,void 0,!0,u);let z=0;for(let p=0;p<this._scene._activeAnimatables.length;p++){const F=this._scene._activeAnimatables[p];F._runtimeAnimations.length>0?this._scene._activeAnimatables[z++]=F:u&&this._checkAnimationGroupEnded(F,u)}return this._scene._activeAnimatables.length=z,this._isStarted=!1,this}setWeightForAllAnimatables(u){for(let F=0;F<this._animatables.length;F++){this._animatables[F].weight=u}return this}syncAllAnimationsWith(u){for(let F=0;F<this._animatables.length;F++){this._animatables[F].syncWith(u)}return this}goToFrame(u){let F=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let z=0;z<this._animatables.length;z++){this._animatables[z].goToFrame(u,F)}return this}getCurrentFrame(){var u;return(null===(u=this.animatables[0])||void 0===u?void 0:u.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const u=this._scene.animationGroups.indexOf(this);if(u>-1&&this._scene.animationGroups.splice(u,1),this._parentContainer){const u=this._parentContainer.animationGroups.indexOf(this);u>-1&&this._parentContainer.animationGroups.splice(u,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(u){let F=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const z=this._animatables.indexOf(u);z>-1&&this._animatables.splice(z,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,F||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(u,F){let z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const p=new d(u||this.name,this._scene,this._weight,this._playOrder);p._from=this.from,p._to=this.to,p._speedRatio=this.speedRatio,p._loopAnimation=this.loopAnimation,p._isAdditive=this.isAdditive,p._enableBlending=this.enableBlending,p._blendingSpeed=this.blendingSpeed,p.metadata=this.metadata,p.mask=this.mask;for(const b of this._targetedAnimations)p.addTargetedAnimation(z?b.animation.clone():b.animation,F?F(b.target):b.target);return p}serialize(){const u={};u.name=this.name,u.from=this.from,u.to=this.to,u.speedRatio=this.speedRatio,u.loopAnimation=this.loopAnimation,u.isAdditive=this.isAdditive,u.weight=this.weight,u.playOrder=this.playOrder,u.enableBlending=this.enableBlending,u.blendingSpeed=this.blendingSpeed,u.targetedAnimations=[];for(let F=0;F<this.targetedAnimations.length;F++){const z=this.targetedAnimations[F];u.targetedAnimations[F]=z.serialize()}return c.e&&c.e.HasTags(this)&&(u.tags=c.e.GetTags(this)),this.metadata&&(u.metadata=this.metadata),u}static Parse(u,F){const z=new d(u.name,F,u.weight,u.playOrder);for(let b=0;b<u.targetedAnimations.length;b++){const R=u.targetedAnimations[b],c=p.e.Parse(R.animation),I=R.targetId;if("influence"===R.animation.property){const u=F.getMorphTargetById(I);u&&z.addTargetedAnimation(c,u)}else{const u=F.getNodeById(I);null!=u&&z.addTargetedAnimation(c,u)}}return c.e&&c.e.AddTagsTo(z,u.tags),null!==u.from&&null!==u.to&&z.normalize(u.from,u.to),void 0!==u.speedRatio&&(z._speedRatio=u.speedRatio),void 0!==u.loopAnimation&&(z._loopAnimation=u.loopAnimation),void 0!==u.isAdditive&&(z._isAdditive=u.isAdditive),void 0!==u.weight&&(z._weight=u.weight),void 0!==u.playOrder&&(z._playOrder=u.playOrder),void 0!==u.enableBlending&&(z._enableBlending=u.enableBlending),void 0!==u.blendingSpeed&&(z._blendingSpeed=u.blendingSpeed),void 0!==u.metadata&&(z.metadata=u.metadata),z}static MakeAnimationAdditive(u,F,z){let b;b="object"===typeof F?F:{referenceFrame:F,range:z,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let R=u;b.cloneOriginalAnimationGroup&&(R=u.clone(b.clonedAnimationGroupName||R.name));const c=R.targetedAnimations;for(let I=0;I<c.length;I++){const u=c[I];u.animation=p.e.MakeAnimationAdditive(u.animation,b)}if(R.isAdditive=!0,b.clipKeys){let u=Number.MAX_VALUE,F=-Number.MAX_VALUE;const z=R.targetedAnimations;for(let p=0;p<z.length;p++){const b=z[p].animation.getKeys();u>b[0].frame&&(u=b[0].frame),F<b[b.length-1].frame&&(F=b[b.length-1].frame)}R._from=u,R._to=F}return R}static ClipKeys(u,F,z,p,b){const R=u.clone(p||u.name);return d.ClipKeysInPlace(R,F,z,b)}static ClipKeysInPlace(u,F,z,p){return d.ClipInPlace(u,F,z,p,!1)}static ClipFrames(u,F,z,p,b){const R=u.clone(p||u.name);return d.ClipFramesInPlace(R,F,z,b)}static ClipFramesInPlace(u,F,z,p){return d.ClipInPlace(u,F,z,p,!0)}static ClipInPlace(u,F,z,p){let b=arguments.length>4&&void 0!==arguments[4]&&arguments[4],R=Number.MAX_VALUE,c=-Number.MAX_VALUE;const I=u.targetedAnimations;for(let G=0;G<I.length;G++){const u=I[G],X=p?u.animation:u.animation.clone();b&&(X.createKeyForFrame(F),X.createKeyForFrame(z));const j=X.getKeys(),W=[];let E=Number.MAX_VALUE;for(let p=0;p<j.length;p++){const u=j[p];if(!b&&p>=F&&p<=z||b&&u.frame>=F&&u.frame<=z){const F={frame:u.frame,value:u.value.clone?u.value.clone():u.value,inTangent:u.inTangent,outTangent:u.outTangent,interpolation:u.interpolation,lockedTangent:u.lockedTangent};E===Number.MAX_VALUE&&(E=F.frame),F.frame-=E,W.push(F)}}0!==W.length?(R>W[0].frame&&(R=W[0].frame),c<W[W.length-1].frame&&(c=W[W.length-1].frame),X.setKeys(W,!0),u.animation=X):(I.splice(G,1),G--)}return u._from=R,u._to=c,u}getClassName(){return"AnimationGroup"}toString(u){let F="Name: "+this.name;return F+=", type: "+this.getClassName(),u&&(F+=", from: "+this._from,F+=", to: "+this._to,F+=", isStarted: "+this._isStarted,F+=", speedRatio: "+this._speedRatio,F+=", targetedAnimations length: "+this._targetedAnimations.length,F+=", animatables length: "+this._animatables),F}}}}]);