"use strict";(self.i6szn8jgzh=self.i6szn8jgzh||[]).push([[49],{14320:(b,n,i)=>{i.r(n),i.d(n,{_HDRTextureLoader:()=>mb});var e=i(11778);class V{static ConvertPanoramaToCubemap(b,n,i,e){let V=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!b)throw"ConvertPanoramaToCubemap: input cannot be null";if(b.length!=n*i*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(e,this.FACE_FRONT,b,n,i,V),back:this.CreateCubemapTexture(e,this.FACE_BACK,b,n,i,V),left:this.CreateCubemapTexture(e,this.FACE_LEFT,b,n,i,V),right:this.CreateCubemapTexture(e,this.FACE_RIGHT,b,n,i,V),up:this.CreateCubemapTexture(e,this.FACE_UP,b,n,i,V),down:this.CreateCubemapTexture(e,this.FACE_DOWN,b,n,i,V),size:e,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(b,n,i,e,V){let Q=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const U=new ArrayBuffer(b*b*4*3),Y=new Float32Array(U),L=Q?Math.max(1,Math.round(e/4/b)):1,B=1/L,mb=B*B,N=n[1].un(n[0]).scale(B/b),Z=n[3].un(n[2]).scale(B/b),T=1/b;let z=0;for(let K=0;K<b;K++)for(let Q=0;Q<L;Q++){let Q=n[0],U=n[2];for(let n=0;n<b;n++)for(let B=0;B<L;B++){const L=U.un(Q).scale(z).add(Q);L.normalize();const B=this.CalcProjectionSpherical(L,i,e,V);Y[K*b*3+3*n+0]+=B.r*mb,Y[K*b*3+3*n+1]+=B.g*mb,Y[K*b*3+3*n+2]+=B.b*mb,Q=Q.add(N),U=U.add(Z)}z+=T*B}return Y}static CalcProjectionSpherical(b,n,i,e){let V=Math.atan2(b.z,b.x);const Q=Math.acos(b.y);for(;V<-Math.PI;)V+=2*Math.PI;for(;V>Math.PI;)V-=2*Math.PI;let U=V/Math.PI;const Y=Q/Math.PI;U=.5*U+.5;let L=Math.round(U*i);L<0?L=0:L>=i&&(L=i-1);let B=Math.round(Y*e);B<0?B=0:B>=e&&(B=e-1);const mb=e-B-1;return{r:n[mb*i*3+3*L+0],g:n[mb*i*3+3*L+1],b:n[mb*i*3+3*L+2]}}}function Q(b,n,i,e,V,Q){V>0?(V=function(b,n){return n>1023?b*Math.pow(2,1023)*Math.pow(2,n-1023):n<-1074?b*Math.pow(2,-1074)*Math.pow(2,n+1074):b*Math.pow(2,n)}(1,V-136),b[Q+0]=n*V,b[Q+1]=i*V,b[Q+2]=e*V):(b[Q+0]=0,b[Q+1]=0,b[Q+2]=0)}function U(b,n){let i="",e="";for(let V=n;V<b.length-n&&(e=String.fromCharCode(b[V]),"\n"!=e);V++)i+=e;return i}function Y(b){let n=0,i=0,e=U(b,0);if("#"!=e[0]||"?"!=e[1])throw"Bad HDR Format.";let V=!1,Q=!1,Y=0;do{Y+=e.length+1,e=U(b,Y),"FORMAT=32-bit_rle_rgbe"==e?Q=!0:0==e.length&&(V=!0)}while(!V);if(!Q)throw"HDR Bad header format, unsupported FORMAT";Y+=e.length+1,e=U(b,Y);const L=/^-Y (.*) \+X (.*)$/g.exec(e);if(!L||L.length<3)throw"HDR Bad header format, no size";if(i=parseInt(L[2]),n=parseInt(L[1]),i<8||i>32767)throw"HDR Bad header format, unsupported size";return Y+=e.length+1,{height:n,width:i,dataPosition:Y}}function L(b,n){return function(b,n){let i=n.height;const e=n.width;let V,U,Y,L,mb,N=n.dataPosition,Z=0,T=0,z=0;const K=new ArrayBuffer(4*e),I=new Uint8Array(K),O=new ArrayBuffer(n.width*n.height*4*3),u=new Float32Array(O);for(;i>0;){if(V=b[N++],U=b[N++],Y=b[N++],L=b[N++],2!=V||2!=U||128&Y||n.width<8||n.width>32767)return B(b,n);if((Y<<8|L)!=e)throw"HDR Bad header format, wrong scan line width";for(Z=0,z=0;z<4;z++)for(T=(z+1)*e;Z<T;)if(V=b[N++],U=b[N++],V>128){if(mb=V-128,0==mb||mb>T-Z)throw"HDR Bad Format, bad scanline data (run)";for(;mb-- >0;)I[Z++]=U}else{if(mb=V,0==mb||mb>T-Z)throw"HDR Bad Format, bad scanline data (non-run)";if(I[Z++]=U,--mb>0)for(let n=0;n<mb;n++)I[Z++]=b[N++]}for(z=0;z<e;z++)V=I[z],U=I[z+e],Y=I[z+2*e],L=I[z+3*e],Q(u,V,U,Y,L,(n.height-i)*e*3+3*z);i--}return u}(b,n)}function B(b,n){let i=n.height;const e=n.width;let V,U,Y,L,B,mb=n.dataPosition;const N=new ArrayBuffer(n.width*n.height*4*3),Z=new Float32Array(N);for(;i>0;){for(B=0;B<n.width;B++)V=b[mb++],U=b[mb++],Y=b[mb++],L=b[mb++],Q(Z,V,U,Y,L,(n.height-i)*e*3+3*B);i--}return Z}V.FACE_LEFT=[new e.On(-1,-1,-1),new e.On(1,-1,-1),new e.On(-1,1,-1),new e.On(1,1,-1)],V.FACE_RIGHT=[new e.On(1,-1,1),new e.On(-1,-1,1),new e.On(1,1,1),new e.On(-1,1,1)],V.FACE_FRONT=[new e.On(1,-1,-1),new e.On(1,-1,1),new e.On(1,1,-1),new e.On(1,1,1)],V.FACE_BACK=[new e.On(-1,-1,1),new e.On(-1,-1,-1),new e.On(-1,1,1),new e.On(-1,1,-1)],V.FACE_DOWN=[new e.On(1,1,-1),new e.On(1,1,1),new e.On(-1,1,-1),new e.On(-1,1,1)],V.FACE_UP=[new e.On(-1,-1,-1),new e.On(-1,-1,1),new e.On(1,-1,-1),new e.On(1,-1,1)];class mb{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(b,n,i){const e=new Uint8Array(b.buffer,b.byteOffset,b.byteLength),V=Y(e),Q=L(e,V),U=V.width*V.height,B=new Float32Array(4*U);for(let Y=0;Y<U;Y+=1)B[4*Y]=Q[3*Y],B[4*Y+1]=Q[3*Y+1],B[4*Y+2]=Q[3*Y+2],B[4*Y+3]=1;i(V.width,V.height,n.generateMipMaps,!1,(()=>{const b=n.getEngine();n.type=1,n.format=5,n._gammaSpace=!1,b._uploadDataToTextureDirectly(n,B)}))}}}}]);