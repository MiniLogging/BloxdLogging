"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13564:(q,S,b)=>{b.r(S),b.d(S,{_HDRTextureLoader:()=>V});var z=b(11103);class C{static ConvertPanoramaToCubemap(q,S,b,z){let C=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!q)throw"ConvertPanoramaToCubemap: input cannot be null";if(q.length!=S*b*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(z,this.FACE_FRONT,q,S,b,C),back:this.CreateCubemapTexture(z,this.FACE_BACK,q,S,b,C),left:this.CreateCubemapTexture(z,this.FACE_LEFT,q,S,b,C),right:this.CreateCubemapTexture(z,this.FACE_RIGHT,q,S,b,C),up:this.CreateCubemapTexture(z,this.FACE_UP,q,S,b,C),down:this.CreateCubemapTexture(z,this.FACE_DOWN,q,S,b,C),size:z,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(q,S,b,z,C){let v=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const U=new ArrayBuffer(q*q*4*3),g=new Float32Array(U),r=v?Math.max(1,Math.round(z/4/q)):1,I=1/r,V=I*I,l=S[1].RS(S[0]).scale(I/q),y=S[3].RS(S[2]).scale(I/q),R=1/q;let G=0;for(let Z=0;Z<q;Z++)for(let v=0;v<r;v++){let v=S[0],U=S[2];for(let S=0;S<q;S++)for(let I=0;I<r;I++){const r=U.RS(v).scale(G).add(v);r.normalize();const I=this.CalcProjectionSpherical(r,b,z,C);g[Z*q*3+3*S+0]+=I.r*V,g[Z*q*3+3*S+1]+=I.g*V,g[Z*q*3+3*S+2]+=I.b*V,v=v.add(l),U=U.add(y)}G+=R*I}return g}static CalcProjectionSpherical(q,S,b,z){let C=Math.atan2(q.z,q.x);const v=Math.acos(q.y);for(;C<-Math.PI;)C+=2*Math.PI;for(;C>Math.PI;)C-=2*Math.PI;let U=C/Math.PI;const g=v/Math.PI;U=.5*U+.5;let r=Math.round(U*b);r<0?r=0:r>=b&&(r=b-1);let I=Math.round(g*z);I<0?I=0:I>=z&&(I=z-1);const V=z-I-1;return{r:S[V*b*3+3*r+0],g:S[V*b*3+3*r+1],b:S[V*b*3+3*r+2]}}}function v(q,S,b,z,C,v){C>0?(C=function(q,S){return S>1023?q*Math.pow(2,1023)*Math.pow(2,S-1023):S<-1074?q*Math.pow(2,-1074)*Math.pow(2,S+1074):q*Math.pow(2,S)}(1,C-136),q[v+0]=S*C,q[v+1]=b*C,q[v+2]=z*C):(q[v+0]=0,q[v+1]=0,q[v+2]=0)}function U(q,S){let b="",z="";for(let C=S;C<q.length-S&&(z=String.fromCharCode(q[C]),"\n"!=z);C++)b+=z;return b}function g(q){let S=0,b=0,z=U(q,0);if("#"!=z[0]||"?"!=z[1])throw"Bad HDR Format.";let C=!1,v=!1,g=0;do{g+=z.length+1,z=U(q,g),"FORMAT=32-bit_rle_rgbe"==z?v=!0:0==z.length&&(C=!0)}while(!C);if(!v)throw"HDR Bad header format, unsupported FORMAT";g+=z.length+1,z=U(q,g);const r=/^-Y (.*) \+X (.*)$/g.exec(z);if(!r||r.length<3)throw"HDR Bad header format, no size";if(b=parseInt(r[2]),S=parseInt(r[1]),b<8||b>32767)throw"HDR Bad header format, unsupported size";return g+=z.length+1,{height:S,width:b,dataPosition:g}}function r(q,S){return function(q,S){let b=S.height;const z=S.width;let C,U,g,r,V,l=S.dataPosition,y=0,R=0,G=0;const Z=new ArrayBuffer(4*z),H=new Uint8Array(Z),Q=new ArrayBuffer(S.width*S.height*4*3),k=new Float32Array(Q);for(;b>0;){if(C=q[l++],U=q[l++],g=q[l++],r=q[l++],2!=C||2!=U||128&g||S.width<8||S.width>32767)return I(q,S);if((g<<8|r)!=z)throw"HDR Bad header format, wrong scan line width";for(y=0,G=0;G<4;G++)for(R=(G+1)*z;y<R;)if(C=q[l++],U=q[l++],C>128){if(V=C-128,0==V||V>R-y)throw"HDR Bad Format, bad scanline data (run)";for(;V-- >0;)H[y++]=U}else{if(V=C,0==V||V>R-y)throw"HDR Bad Format, bad scanline data (non-run)";if(H[y++]=U,--V>0)for(let S=0;S<V;S++)H[y++]=q[l++]}for(G=0;G<z;G++)C=H[G],U=H[G+z],g=H[G+2*z],r=H[G+3*z],v(k,C,U,g,r,(S.height-b)*z*3+3*G);b--}return k}(q,S)}function I(q,S){let b=S.height;const z=S.width;let C,U,g,r,I,V=S.dataPosition;const l=new ArrayBuffer(S.width*S.height*4*3),y=new Float32Array(l);for(;b>0;){for(I=0;I<S.width;I++)C=q[V++],U=q[V++],g=q[V++],r=q[V++],v(y,C,U,g,r,(S.height-b)*z*3+3*I);b--}return y}C.FACE_LEFT=[new z.yS(-1,-1,-1),new z.yS(1,-1,-1),new z.yS(-1,1,-1),new z.yS(1,1,-1)],C.FACE_RIGHT=[new z.yS(1,-1,1),new z.yS(-1,-1,1),new z.yS(1,1,1),new z.yS(-1,1,1)],C.FACE_FRONT=[new z.yS(1,-1,-1),new z.yS(1,-1,1),new z.yS(1,1,-1),new z.yS(1,1,1)],C.FACE_BACK=[new z.yS(-1,-1,1),new z.yS(-1,-1,-1),new z.yS(-1,1,1),new z.yS(-1,1,-1)],C.FACE_DOWN=[new z.yS(1,1,-1),new z.yS(1,1,1),new z.yS(-1,1,-1),new z.yS(-1,1,1)],C.FACE_UP=[new z.yS(-1,-1,-1),new z.yS(-1,-1,1),new z.yS(1,-1,-1),new z.yS(1,-1,1)];class V{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(q,S,b){const z=new Uint8Array(q.buffer,q.byteOffset,q.byteLength),C=g(z),v=r(z,C),U=C.width*C.height,I=new Float32Array(4*U);for(let g=0;g<U;g+=1)I[4*g]=v[3*g],I[4*g+1]=v[3*g+1],I[4*g+2]=v[3*g+2],I[4*g+3]=1;b(C.width,C.height,S.generateMipMaps,!1,(()=>{const q=S.getEngine();S.type=1,S.format=5,S._gammaSpace=!1,q._uploadDataToTextureDirectly(S,I)}))}}}}]);