"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13715:(Z,x,F)=>{F.r(x),F.d(x,{_HDRTextureLoader:()=>o});var u=F(11179);class G{static ConvertPanoramaToCubemap(Z,x,F,u){let G=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Z)throw"ConvertPanoramaToCubemap: input cannot be null";if(Z.length!=x*F*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(u,this.FACE_FRONT,Z,x,F,G),back:this.CreateCubemapTexture(u,this.FACE_BACK,Z,x,F,G),left:this.CreateCubemapTexture(u,this.FACE_LEFT,Z,x,F,G),right:this.CreateCubemapTexture(u,this.FACE_RIGHT,Z,x,F,G),up:this.CreateCubemapTexture(u,this.FACE_UP,Z,x,F,G),down:this.CreateCubemapTexture(u,this.FACE_DOWN,Z,x,F,G),size:u,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(Z,x,F,u,G){let f=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const Y=new ArrayBuffer(Z*Z*4*3),j=new Float32Array(Y),d=f?Math.max(1,Math.round(u/4/Z)):1,t=1/d,o=t*t,c=x[1].Mx(x[0]).scale(t/Z),s=x[3].Mx(x[2]).scale(t/Z),J=1/Z;let p=0;for(let U=0;U<Z;U++)for(let f=0;f<d;f++){let f=x[0],Y=x[2];for(let x=0;x<Z;x++)for(let t=0;t<d;t++){const d=Y.Mx(f).scale(p).add(f);d.normalize();const t=this.CalcProjectionSpherical(d,F,u,G);j[U*Z*3+3*x+0]+=t.r*o,j[U*Z*3+3*x+1]+=t.g*o,j[U*Z*3+3*x+2]+=t.b*o,f=f.add(c),Y=Y.add(s)}p+=J*t}return j}static CalcProjectionSpherical(Z,x,F,u){let G=Math.atan2(Z.z,Z.x);const f=Math.acos(Z.y);for(;G<-Math.PI;)G+=2*Math.PI;for(;G>Math.PI;)G-=2*Math.PI;let Y=G/Math.PI;const j=f/Math.PI;Y=.5*Y+.5;let d=Math.round(Y*F);d<0?d=0:d>=F&&(d=F-1);let t=Math.round(j*u);t<0?t=0:t>=u&&(t=u-1);const o=u-t-1;return{r:x[o*F*3+3*d+0],g:x[o*F*3+3*d+1],b:x[o*F*3+3*d+2]}}}function f(Z,x,F,u,G,f){G>0?(G=function(Z,x){return x>1023?Z*Math.pow(2,1023)*Math.pow(2,x-1023):x<-1074?Z*Math.pow(2,-1074)*Math.pow(2,x+1074):Z*Math.pow(2,x)}(1,G-136),Z[f+0]=x*G,Z[f+1]=F*G,Z[f+2]=u*G):(Z[f+0]=0,Z[f+1]=0,Z[f+2]=0)}function Y(Z,x){let F="",u="";for(let G=x;G<Z.length-x&&(u=String.fromCharCode(Z[G]),"\n"!=u);G++)F+=u;return F}function j(Z){let x=0,F=0,u=Y(Z,0);if("#"!=u[0]||"?"!=u[1])throw"Bad HDR Format.";let G=!1,f=!1,j=0;do{j+=u.length+1,u=Y(Z,j),"FORMAT=32-bit_rle_rgbe"==u?f=!0:0==u.length&&(G=!0)}while(!G);if(!f)throw"HDR Bad header format, unsupported FORMAT";j+=u.length+1,u=Y(Z,j);const d=/^-Y (.*) \+X (.*)$/g.exec(u);if(!d||d.length<3)throw"HDR Bad header format, no size";if(F=parseInt(d[2]),x=parseInt(d[1]),F<8||F>32767)throw"HDR Bad header format, unsupported size";return j+=u.length+1,{height:x,width:F,dataPosition:j}}function d(Z,x){return function(Z,x){let F=x.height;const u=x.width;let G,Y,j,d,o,c=x.dataPosition,s=0,J=0,p=0;const U=new ArrayBuffer(4*u),k=new Uint8Array(U),M=new ArrayBuffer(x.width*x.height*4*3),m=new Float32Array(M);for(;F>0;){if(G=Z[c++],Y=Z[c++],j=Z[c++],d=Z[c++],2!=G||2!=Y||128&j||x.width<8||x.width>32767)return t(Z,x);if((j<<8|d)!=u)throw"HDR Bad header format, wrong scan line width";for(s=0,p=0;p<4;p++)for(J=(p+1)*u;s<J;)if(G=Z[c++],Y=Z[c++],G>128){if(o=G-128,0==o||o>J-s)throw"HDR Bad Format, bad scanline data (run)";for(;o-- >0;)k[s++]=Y}else{if(o=G,0==o||o>J-s)throw"HDR Bad Format, bad scanline data (non-run)";if(k[s++]=Y,--o>0)for(let x=0;x<o;x++)k[s++]=Z[c++]}for(p=0;p<u;p++)G=k[p],Y=k[p+u],j=k[p+2*u],d=k[p+3*u],f(m,G,Y,j,d,(x.height-F)*u*3+3*p);F--}return m}(Z,x)}function t(Z,x){let F=x.height;const u=x.width;let G,Y,j,d,t,o=x.dataPosition;const c=new ArrayBuffer(x.width*x.height*4*3),s=new Float32Array(c);for(;F>0;){for(t=0;t<x.width;t++)G=Z[o++],Y=Z[o++],j=Z[o++],d=Z[o++],f(s,G,Y,j,d,(x.height-F)*u*3+3*t);F--}return s}G.FACE_LEFT=[new u.kx(-1,-1,-1),new u.kx(1,-1,-1),new u.kx(-1,1,-1),new u.kx(1,1,-1)],G.FACE_RIGHT=[new u.kx(1,-1,1),new u.kx(-1,-1,1),new u.kx(1,1,1),new u.kx(-1,1,1)],G.FACE_FRONT=[new u.kx(1,-1,-1),new u.kx(1,-1,1),new u.kx(1,1,-1),new u.kx(1,1,1)],G.FACE_BACK=[new u.kx(-1,-1,1),new u.kx(-1,-1,-1),new u.kx(-1,1,1),new u.kx(-1,1,-1)],G.FACE_DOWN=[new u.kx(1,1,-1),new u.kx(1,1,1),new u.kx(-1,1,-1),new u.kx(-1,1,1)],G.FACE_UP=[new u.kx(-1,-1,-1),new u.kx(-1,-1,1),new u.kx(1,-1,-1),new u.kx(1,-1,1)];class o{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(Z,x,F){const u=new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength),G=j(u),f=d(u,G),Y=G.width*G.height,t=new Float32Array(4*Y);for(let j=0;j<Y;j+=1)t[4*j]=f[3*j],t[4*j+1]=f[3*j+1],t[4*j+2]=f[3*j+2],t[4*j+3]=1;F(G.width,G.height,x.generateMipMaps,!1,(()=>{const Z=x.getEngine();x.type=1,x.format=5,x._gammaSpace=!1,Z._uploadDataToTextureDirectly(x,t)}))}}}}]);