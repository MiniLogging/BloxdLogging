"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[49],{15376:(Y,b,C)=>{C.r(b),C.d(b,{_HDRTextureLoader:()=>O});var R=C(12831);class q{static ConvertPanoramaToCubemap(Y,b,C,R){let q=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Y)throw"ConvertPanoramaToCubemap: input cannot be null";if(Y.length!=b*C*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(R,this.FACE_FRONT,Y,b,C,q),back:this.CreateCubemapTexture(R,this.FACE_BACK,Y,b,C,q),left:this.CreateCubemapTexture(R,this.FACE_LEFT,Y,b,C,q),right:this.CreateCubemapTexture(R,this.FACE_RIGHT,Y,b,C,q),up:this.CreateCubemapTexture(R,this.FACE_UP,Y,b,C,q),down:this.CreateCubemapTexture(R,this.FACE_DOWN,Y,b,C,q),size:R,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(Y,b,C,R,q){let A=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const E=new ArrayBuffer(Y*Y*4*3),B=new Float32Array(E),g=A?Math.max(1,Math.round(R/4/Y)):1,r=1/g,O=r*r,F=b[1].EC(b[0]).scale(r/Y),y=b[3].EC(b[2]).scale(r/Y),S=1/Y;let n=0;for(let t=0;t<Y;t++)for(let A=0;A<g;A++){let A=b[0],E=b[2];for(let b=0;b<Y;b++)for(let r=0;r<g;r++){const g=E.EC(A).scale(n).add(A);g.normalize();const r=this.CalcProjectionSpherical(g,C,R,q);B[t*Y*3+3*b+0]+=r.r*O,B[t*Y*3+3*b+1]+=r.g*O,B[t*Y*3+3*b+2]+=r.b*O,A=A.add(F),E=E.add(y)}n+=S*r}return B}static CalcProjectionSpherical(Y,b,C,R){let q=Math.atan2(Y.z,Y.x);const A=Math.acos(Y.y);for(;q<-Math.PI;)q+=2*Math.PI;for(;q>Math.PI;)q-=2*Math.PI;let E=q/Math.PI;const B=A/Math.PI;E=.5*E+.5;let g=Math.round(E*C);g<0?g=0:g>=C&&(g=C-1);let r=Math.round(B*R);r<0?r=0:r>=R&&(r=R-1);const O=R-r-1;return{r:b[O*C*3+3*g+0],g:b[O*C*3+3*g+1],b:b[O*C*3+3*g+2]}}}function A(Y,b,C,R,q,A){q>0?(q=function(Y,b){return b>1023?Y*Math.pow(2,1023)*Math.pow(2,b-1023):b<-1074?Y*Math.pow(2,-1074)*Math.pow(2,b+1074):Y*Math.pow(2,b)}(1,q-136),Y[A+0]=b*q,Y[A+1]=C*q,Y[A+2]=R*q):(Y[A+0]=0,Y[A+1]=0,Y[A+2]=0)}function E(Y,b){let C="",R="";for(let q=b;q<Y.length-b&&(R=String.fromCharCode(Y[q]),"\n"!=R);q++)C+=R;return C}function B(Y){let b=0,C=0,R=E(Y,0);if("#"!=R[0]||"?"!=R[1])throw"Bad HDR Format.";let q=!1,A=!1,B=0;do{B+=R.length+1,R=E(Y,B),"FORMAT=32-bit_rle_rgbe"==R?A=!0:0==R.length&&(q=!0)}while(!q);if(!A)throw"HDR Bad header format, unsupported FORMAT";B+=R.length+1,R=E(Y,B);const g=/^-Y (.*) \+X (.*)$/g.exec(R);if(!g||g.length<3)throw"HDR Bad header format, no size";if(C=parseInt(g[2]),b=parseInt(g[1]),C<8||C>32767)throw"HDR Bad header format, unsupported size";return B+=R.length+1,{height:b,width:C,dataPosition:B}}function g(Y,b){return function(Y,b){let C=b.height;const R=b.width;let q,E,B,g,O,F=b.dataPosition,y=0,S=0,n=0;const t=new ArrayBuffer(4*R),I=new Uint8Array(t),w=new ArrayBuffer(b.width*b.height*4*3),Q=new Float32Array(w);for(;C>0;){if(q=Y[F++],E=Y[F++],B=Y[F++],g=Y[F++],2!=q||2!=E||128&B||b.width<8||b.width>32767)return r(Y,b);if((B<<8|g)!=R)throw"HDR Bad header format, wrong scan line width";for(y=0,n=0;n<4;n++)for(S=(n+1)*R;y<S;)if(q=Y[F++],E=Y[F++],q>128){if(O=q-128,0==O||O>S-y)throw"HDR Bad Format, bad scanline data (run)";for(;O-- >0;)I[y++]=E}else{if(O=q,0==O||O>S-y)throw"HDR Bad Format, bad scanline data (non-run)";if(I[y++]=E,--O>0)for(let b=0;b<O;b++)I[y++]=Y[F++]}for(n=0;n<R;n++)q=I[n],E=I[n+R],B=I[n+2*R],g=I[n+3*R],A(Q,q,E,B,g,(b.height-C)*R*3+3*n);C--}return Q}(Y,b)}function r(Y,b){let C=b.height;const R=b.width;let q,E,B,g,r,O=b.dataPosition;const F=new ArrayBuffer(b.width*b.height*4*3),y=new Float32Array(F);for(;C>0;){for(r=0;r<b.width;r++)q=Y[O++],E=Y[O++],B=Y[O++],g=Y[O++],A(y,q,E,B,g,(b.height-C)*R*3+3*r);C--}return y}q.FACE_LEFT=[new R.AC(-1,-1,-1),new R.AC(1,-1,-1),new R.AC(-1,1,-1),new R.AC(1,1,-1)],q.FACE_RIGHT=[new R.AC(1,-1,1),new R.AC(-1,-1,1),new R.AC(1,1,1),new R.AC(-1,1,1)],q.FACE_FRONT=[new R.AC(1,-1,-1),new R.AC(1,-1,1),new R.AC(1,1,-1),new R.AC(1,1,1)],q.FACE_BACK=[new R.AC(-1,-1,1),new R.AC(-1,-1,-1),new R.AC(-1,1,1),new R.AC(-1,1,-1)],q.FACE_DOWN=[new R.AC(1,1,-1),new R.AC(1,1,1),new R.AC(-1,1,-1),new R.AC(-1,1,1)],q.FACE_UP=[new R.AC(-1,-1,-1),new R.AC(-1,-1,1),new R.AC(1,-1,-1),new R.AC(1,-1,1)];class O{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(Y,b,C){const R=new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength),q=B(R),A=g(R,q),E=q.width*q.height,r=new Float32Array(4*E);for(let B=0;B<E;B+=1)r[4*B]=A[3*B],r[4*B+1]=A[3*B+1],r[4*B+2]=A[3*B+2],r[4*B+3]=1;C(q.width,q.height,b.generateMipMaps,!1,(()=>{const Y=b.getEngine();b.type=1,b.format=5,b._gammaSpace=!1,Y._uploadDataToTextureDirectly(b,r)}))}}}}]);