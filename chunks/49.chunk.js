"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13553:(h,V,i)=>{i.r(V),i.d(V,{_HDRTextureLoader:()=>I});var S=i(11138);class l{static ConvertPanoramaToCubemap(h,V,i,S){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!h)throw"ConvertPanoramaToCubemap: input cannot be null";if(h.length!=V*i*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(S,this.FACE_FRONT,h,V,i,l),back:this.CreateCubemapTexture(S,this.FACE_BACK,h,V,i,l),left:this.CreateCubemapTexture(S,this.FACE_LEFT,h,V,i,l),right:this.CreateCubemapTexture(S,this.FACE_RIGHT,h,V,i,l),up:this.CreateCubemapTexture(S,this.FACE_UP,h,V,i,l),down:this.CreateCubemapTexture(S,this.FACE_DOWN,h,V,i,l),size:S,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(h,V,i,S,l){let Y=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const g=new ArrayBuffer(h*h*4*3),q=new Float32Array(g),B=Y?Math.max(1,Math.round(S/4/h)):1,J=1/B,I=J*J,v=V[1].cV(V[0]).scale(J/h),s=V[3].cV(V[2]).scale(J/h),t=1/h;let T=0;for(let e=0;e<h;e++)for(let Y=0;Y<B;Y++){let Y=V[0],g=V[2];for(let V=0;V<h;V++)for(let J=0;J<B;J++){const B=g.cV(Y).scale(T).add(Y);B.normalize();const J=this.CalcProjectionSpherical(B,i,S,l);q[e*h*3+3*V+0]+=J.r*I,q[e*h*3+3*V+1]+=J.g*I,q[e*h*3+3*V+2]+=J.b*I,Y=Y.add(v),g=g.add(s)}T+=t*J}return q}static CalcProjectionSpherical(h,V,i,S){let l=Math.atan2(h.z,h.x);const Y=Math.acos(h.y);for(;l<-Math.PI;)l+=2*Math.PI;for(;l>Math.PI;)l-=2*Math.PI;let g=l/Math.PI;const q=Y/Math.PI;g=.5*g+.5;let B=Math.round(g*i);B<0?B=0:B>=i&&(B=i-1);let J=Math.round(q*S);J<0?J=0:J>=S&&(J=S-1);const I=S-J-1;return{r:V[I*i*3+3*B+0],g:V[I*i*3+3*B+1],b:V[I*i*3+3*B+2]}}}function Y(h,V,i,S,l,Y){l>0?(l=function(h,V){return V>1023?h*Math.pow(2,1023)*Math.pow(2,V-1023):V<-1074?h*Math.pow(2,-1074)*Math.pow(2,V+1074):h*Math.pow(2,V)}(1,l-136),h[Y+0]=V*l,h[Y+1]=i*l,h[Y+2]=S*l):(h[Y+0]=0,h[Y+1]=0,h[Y+2]=0)}function g(h,V){let i="",S="";for(let l=V;l<h.length-V&&(S=String.fromCharCode(h[l]),"\n"!=S);l++)i+=S;return i}function q(h){let V=0,i=0,S=g(h,0);if("#"!=S[0]||"?"!=S[1])throw"Bad HDR Format.";let l=!1,Y=!1,q=0;do{q+=S.length+1,S=g(h,q),"FORMAT=32-bit_rle_rgbe"==S?Y=!0:0==S.length&&(l=!0)}while(!l);if(!Y)throw"HDR Bad header format, unsupported FORMAT";q+=S.length+1,S=g(h,q);const B=/^-Y (.*) \+X (.*)$/g.exec(S);if(!B||B.length<3)throw"HDR Bad header format, no size";if(i=parseInt(B[2]),V=parseInt(B[1]),i<8||i>32767)throw"HDR Bad header format, unsupported size";return q+=S.length+1,{height:V,width:i,dataPosition:q}}function B(h,V){return function(h,V){let i=V.height;const S=V.width;let l,g,q,B,I,v=V.dataPosition,s=0,t=0,T=0;const e=new ArrayBuffer(4*S),n=new Uint8Array(e),c=new ArrayBuffer(V.width*V.height*4*3),f=new Float32Array(c);for(;i>0;){if(l=h[v++],g=h[v++],q=h[v++],B=h[v++],2!=l||2!=g||128&q||V.width<8||V.width>32767)return J(h,V);if((q<<8|B)!=S)throw"HDR Bad header format, wrong scan line width";for(s=0,T=0;T<4;T++)for(t=(T+1)*S;s<t;)if(l=h[v++],g=h[v++],l>128){if(I=l-128,0==I||I>t-s)throw"HDR Bad Format, bad scanline data (run)";for(;I-- >0;)n[s++]=g}else{if(I=l,0==I||I>t-s)throw"HDR Bad Format, bad scanline data (non-run)";if(n[s++]=g,--I>0)for(let V=0;V<I;V++)n[s++]=h[v++]}for(T=0;T<S;T++)l=n[T],g=n[T+S],q=n[T+2*S],B=n[T+3*S],Y(f,l,g,q,B,(V.height-i)*S*3+3*T);i--}return f}(h,V)}function J(h,V){let i=V.height;const S=V.width;let l,g,q,B,J,I=V.dataPosition;const v=new ArrayBuffer(V.width*V.height*4*3),s=new Float32Array(v);for(;i>0;){for(J=0;J<V.width;J++)l=h[I++],g=h[I++],q=h[I++],B=h[I++],Y(s,l,g,q,B,(V.height-i)*S*3+3*J);i--}return s}l.FACE_LEFT=[new S.nV(-1,-1,-1),new S.nV(1,-1,-1),new S.nV(-1,1,-1),new S.nV(1,1,-1)],l.FACE_RIGHT=[new S.nV(1,-1,1),new S.nV(-1,-1,1),new S.nV(1,1,1),new S.nV(-1,1,1)],l.FACE_FRONT=[new S.nV(1,-1,-1),new S.nV(1,-1,1),new S.nV(1,1,-1),new S.nV(1,1,1)],l.FACE_BACK=[new S.nV(-1,-1,1),new S.nV(-1,-1,-1),new S.nV(-1,1,1),new S.nV(-1,1,-1)],l.FACE_DOWN=[new S.nV(1,1,-1),new S.nV(1,1,1),new S.nV(-1,1,-1),new S.nV(-1,1,1)],l.FACE_UP=[new S.nV(-1,-1,-1),new S.nV(-1,-1,1),new S.nV(1,-1,-1),new S.nV(1,-1,1)];class I{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(h,V,i){const S=new Uint8Array(h.buffer,h.byteOffset,h.byteLength),l=q(S),Y=B(S,l),g=l.width*l.height,J=new Float32Array(4*g);for(let q=0;q<g;q+=1)J[4*q]=Y[3*q],J[4*q+1]=Y[3*q+1],J[4*q+2]=Y[3*q+2],J[4*q+3]=1;i(l.width,l.height,V.generateMipMaps,!1,(()=>{const h=V.getEngine();V.type=1,V.format=5,V._gammaSpace=!1,h._uploadDataToTextureDirectly(V,J)}))}}}}]);