"use strict";(self.fkqm0epoq5=self.fkqm0epoq5||[]).push([[49],{14142:(D,l,G)=>{G.r(l),G.d(l,{_HDRTextureLoader:()=>n});var V=G(11710);class N{static ConvertPanoramaToCubemap(D,l,G,V){let N=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!D)throw"ConvertPanoramaToCubemap: input cannot be null";if(D.length!=l*G*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(V,this.FACE_FRONT,D,l,G,N),back:this.CreateCubemapTexture(V,this.FACE_BACK,D,l,G,N),left:this.CreateCubemapTexture(V,this.FACE_LEFT,D,l,G,N),right:this.CreateCubemapTexture(V,this.FACE_RIGHT,D,l,G,N),up:this.CreateCubemapTexture(V,this.FACE_UP,D,l,G,N),down:this.CreateCubemapTexture(V,this.FACE_DOWN,D,l,G,N),size:V,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(D,l,G,V,N){let M=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const b=new ArrayBuffer(D*D*4*3),X=new Float32Array(b),t=M?Math.max(1,Math.round(V/4/D)):1,R=1/t,n=R*R,g=l[1].Fl(l[0]).scale(R/D),j=l[3].Fl(l[2]).scale(R/D),e=1/D;let K=0;for(let F=0;F<D;F++)for(let M=0;M<t;M++){let M=l[0],b=l[2];for(let l=0;l<D;l++)for(let R=0;R<t;R++){const t=b.Fl(M).scale(K).add(M);t.normalize();const R=this.CalcProjectionSpherical(t,G,V,N);X[F*D*3+3*l+0]+=R.r*n,X[F*D*3+3*l+1]+=R.g*n,X[F*D*3+3*l+2]+=R.b*n,M=M.add(g),b=b.add(j)}K+=e*R}return X}static CalcProjectionSpherical(D,l,G,V){let N=Math.atan2(D.z,D.x);const M=Math.acos(D.y);for(;N<-Math.PI;)N+=2*Math.PI;for(;N>Math.PI;)N-=2*Math.PI;let b=N/Math.PI;const X=M/Math.PI;b=.5*b+.5;let t=Math.round(b*G);t<0?t=0:t>=G&&(t=G-1);let R=Math.round(X*V);R<0?R=0:R>=V&&(R=V-1);const n=V-R-1;return{r:l[n*G*3+3*t+0],g:l[n*G*3+3*t+1],b:l[n*G*3+3*t+2]}}}function M(D,l,G,V,N,M){N>0?(N=function(D,l){return l>1023?D*Math.pow(2,1023)*Math.pow(2,l-1023):l<-1074?D*Math.pow(2,-1074)*Math.pow(2,l+1074):D*Math.pow(2,l)}(1,N-136),D[M+0]=l*N,D[M+1]=G*N,D[M+2]=V*N):(D[M+0]=0,D[M+1]=0,D[M+2]=0)}function b(D,l){let G="",V="";for(let N=l;N<D.length-l&&(V=String.fromCharCode(D[N]),"\n"!=V);N++)G+=V;return G}function X(D){let l=0,G=0,V=b(D,0);if("#"!=V[0]||"?"!=V[1])throw"Bad HDR Format.";let N=!1,M=!1,X=0;do{X+=V.length+1,V=b(D,X),"FORMAT=32-bit_rle_rgbe"==V?M=!0:0==V.length&&(N=!0)}while(!N);if(!M)throw"HDR Bad header format, unsupported FORMAT";X+=V.length+1,V=b(D,X);const t=/^-Y (.*) \+X (.*)$/g.exec(V);if(!t||t.length<3)throw"HDR Bad header format, no size";if(G=parseInt(t[2]),l=parseInt(t[1]),G<8||G>32767)throw"HDR Bad header format, unsupported size";return X+=V.length+1,{height:l,width:G,dataPosition:X}}function t(D,l){return function(D,l){let G=l.height;const V=l.width;let N,b,X,t,n,g=l.dataPosition,j=0,e=0,K=0;const F=new ArrayBuffer(4*V),d=new Uint8Array(F),H=new ArrayBuffer(l.width*l.height*4*3),h=new Float32Array(H);for(;G>0;){if(N=D[g++],b=D[g++],X=D[g++],t=D[g++],2!=N||2!=b||128&X||l.width<8||l.width>32767)return R(D,l);if((X<<8|t)!=V)throw"HDR Bad header format, wrong scan line width";for(j=0,K=0;K<4;K++)for(e=(K+1)*V;j<e;)if(N=D[g++],b=D[g++],N>128){if(n=N-128,0==n||n>e-j)throw"HDR Bad Format, bad scanline data (run)";for(;n-- >0;)d[j++]=b}else{if(n=N,0==n||n>e-j)throw"HDR Bad Format, bad scanline data (non-run)";if(d[j++]=b,--n>0)for(let l=0;l<n;l++)d[j++]=D[g++]}for(K=0;K<V;K++)N=d[K],b=d[K+V],X=d[K+2*V],t=d[K+3*V],M(h,N,b,X,t,(l.height-G)*V*3+3*K);G--}return h}(D,l)}function R(D,l){let G=l.height;const V=l.width;let N,b,X,t,R,n=l.dataPosition;const g=new ArrayBuffer(l.width*l.height*4*3),j=new Float32Array(g);for(;G>0;){for(R=0;R<l.width;R++)N=D[n++],b=D[n++],X=D[n++],t=D[n++],M(j,N,b,X,t,(l.height-G)*V*3+3*R);G--}return j}N.FACE_LEFT=[new V.Kl(-1,-1,-1),new V.Kl(1,-1,-1),new V.Kl(-1,1,-1),new V.Kl(1,1,-1)],N.FACE_RIGHT=[new V.Kl(1,-1,1),new V.Kl(-1,-1,1),new V.Kl(1,1,1),new V.Kl(-1,1,1)],N.FACE_FRONT=[new V.Kl(1,-1,-1),new V.Kl(1,-1,1),new V.Kl(1,1,-1),new V.Kl(1,1,1)],N.FACE_BACK=[new V.Kl(-1,-1,1),new V.Kl(-1,-1,-1),new V.Kl(-1,1,1),new V.Kl(-1,1,-1)],N.FACE_DOWN=[new V.Kl(1,1,-1),new V.Kl(1,1,1),new V.Kl(-1,1,-1),new V.Kl(-1,1,1)],N.FACE_UP=[new V.Kl(-1,-1,-1),new V.Kl(-1,-1,1),new V.Kl(1,-1,-1),new V.Kl(1,-1,1)];class n{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(D,l,G){const V=new Uint8Array(D.buffer,D.byteOffset,D.byteLength),N=X(V),M=t(V,N),b=N.width*N.height,R=new Float32Array(4*b);for(let X=0;X<b;X+=1)R[4*X]=M[3*X],R[4*X+1]=M[3*X+1],R[4*X+2]=M[3*X+2],R[4*X+3]=1;G(N.width,N.height,l.generateMipMaps,!1,(()=>{const D=l.getEngine();l.type=1,l.format=5,l._gammaSpace=!1,D._uploadDataToTextureDirectly(l,R)}))}}}}]);