"use strict";(self["686i8587bmi"]=self["686i8587bmi"]||[]).push([[49],{15269:(h,d,T)=>{T.r(d),T.d(d,{_HDRTextureLoader:()=>Z});var Y=T(12765);class y{static ConvertPanoramaToCubemap(h,d,T,Y){let y=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!h)throw"ConvertPanoramaToCubemap: input cannot be null";if(h.length!=d*T*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(Y,this.FACE_FRONT,h,d,T,y),back:this.CreateCubemapTexture(Y,this.FACE_BACK,h,d,T,y),left:this.CreateCubemapTexture(Y,this.FACE_LEFT,h,d,T,y),right:this.CreateCubemapTexture(Y,this.FACE_RIGHT,h,d,T,y),up:this.CreateCubemapTexture(Y,this.FACE_UP,h,d,T,y),down:this.CreateCubemapTexture(Y,this.FACE_DOWN,h,d,T,y),size:Y,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(h,d,T,Y,y){let C=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const n=new ArrayBuffer(h*h*4*3),X=new Float32Array(n),F=C?Math.max(1,Math.round(Y/4/h)):1,U=1/F,Z=U*U,S=d[1].Nd(d[0]).scale(U/h),r=d[3].Nd(d[2]).scale(U/h),c=1/h;let O=0;for(let f=0;f<h;f++)for(let C=0;C<F;C++){let C=d[0],n=d[2];for(let d=0;d<h;d++)for(let U=0;U<F;U++){const F=n.Nd(C).scale(O).add(C);F.normalize();const U=this.CalcProjectionSpherical(F,T,Y,y);X[f*h*3+3*d+0]+=U.r*Z,X[f*h*3+3*d+1]+=U.g*Z,X[f*h*3+3*d+2]+=U.b*Z,C=C.add(S),n=n.add(r)}O+=c*U}return X}static CalcProjectionSpherical(h,d,T,Y){let y=Math.atan2(h.z,h.x);const C=Math.acos(h.y);for(;y<-Math.PI;)y+=2*Math.PI;for(;y>Math.PI;)y-=2*Math.PI;let n=y/Math.PI;const X=C/Math.PI;n=.5*n+.5;let F=Math.round(n*T);F<0?F=0:F>=T&&(F=T-1);let U=Math.round(X*Y);U<0?U=0:U>=Y&&(U=Y-1);const Z=Y-U-1;return{r:d[Z*T*3+3*F+0],g:d[Z*T*3+3*F+1],b:d[Z*T*3+3*F+2]}}}function C(h,d,T,Y,y,C){y>0?(y=function(h,d){return d>1023?h*Math.pow(2,1023)*Math.pow(2,d-1023):d<-1074?h*Math.pow(2,-1074)*Math.pow(2,d+1074):h*Math.pow(2,d)}(1,y-136),h[C+0]=d*y,h[C+1]=T*y,h[C+2]=Y*y):(h[C+0]=0,h[C+1]=0,h[C+2]=0)}function n(h,d){let T="",Y="";for(let y=d;y<h.length-d&&(Y=String.fromCharCode(h[y]),"\n"!=Y);y++)T+=Y;return T}function X(h){let d=0,T=0,Y=n(h,0);if("#"!=Y[0]||"?"!=Y[1])throw"Bad HDR Format.";let y=!1,C=!1,X=0;do{X+=Y.length+1,Y=n(h,X),"FORMAT=32-bit_rle_rgbe"==Y?C=!0:0==Y.length&&(y=!0)}while(!y);if(!C)throw"HDR Bad header format, unsupported FORMAT";X+=Y.length+1,Y=n(h,X);const F=/^-Y (.*) \+X (.*)$/g.exec(Y);if(!F||F.length<3)throw"HDR Bad header format, no size";if(T=parseInt(F[2]),d=parseInt(F[1]),T<8||T>32767)throw"HDR Bad header format, unsupported size";return X+=Y.length+1,{height:d,width:T,dataPosition:X}}function F(h,d){return function(h,d){let T=d.height;const Y=d.width;let y,n,X,F,Z,S=d.dataPosition,r=0,c=0,O=0;const f=new ArrayBuffer(4*Y),J=new Uint8Array(f),W=new ArrayBuffer(d.width*d.height*4*3),L=new Float32Array(W);for(;T>0;){if(y=h[S++],n=h[S++],X=h[S++],F=h[S++],2!=y||2!=n||128&X||d.width<8||d.width>32767)return U(h,d);if((X<<8|F)!=Y)throw"HDR Bad header format, wrong scan line width";for(r=0,O=0;O<4;O++)for(c=(O+1)*Y;r<c;)if(y=h[S++],n=h[S++],y>128){if(Z=y-128,0==Z||Z>c-r)throw"HDR Bad Format, bad scanline data (run)";for(;Z-- >0;)J[r++]=n}else{if(Z=y,0==Z||Z>c-r)throw"HDR Bad Format, bad scanline data (non-run)";if(J[r++]=n,--Z>0)for(let d=0;d<Z;d++)J[r++]=h[S++]}for(O=0;O<Y;O++)y=J[O],n=J[O+Y],X=J[O+2*Y],F=J[O+3*Y],C(L,y,n,X,F,(d.height-T)*Y*3+3*O);T--}return L}(h,d)}function U(h,d){let T=d.height;const Y=d.width;let y,n,X,F,U,Z=d.dataPosition;const S=new ArrayBuffer(d.width*d.height*4*3),r=new Float32Array(S);for(;T>0;){for(U=0;U<d.width;U++)y=h[Z++],n=h[Z++],X=h[Z++],F=h[Z++],C(r,y,n,X,F,(d.height-T)*Y*3+3*U);T--}return r}y.FACE_LEFT=[new Y.pd(-1,-1,-1),new Y.pd(1,-1,-1),new Y.pd(-1,1,-1),new Y.pd(1,1,-1)],y.FACE_RIGHT=[new Y.pd(1,-1,1),new Y.pd(-1,-1,1),new Y.pd(1,1,1),new Y.pd(-1,1,1)],y.FACE_FRONT=[new Y.pd(1,-1,-1),new Y.pd(1,-1,1),new Y.pd(1,1,-1),new Y.pd(1,1,1)],y.FACE_BACK=[new Y.pd(-1,-1,1),new Y.pd(-1,-1,-1),new Y.pd(-1,1,1),new Y.pd(-1,1,-1)],y.FACE_DOWN=[new Y.pd(1,1,-1),new Y.pd(1,1,1),new Y.pd(-1,1,-1),new Y.pd(-1,1,1)],y.FACE_UP=[new Y.pd(-1,-1,-1),new Y.pd(-1,-1,1),new Y.pd(1,-1,-1),new Y.pd(1,-1,1)];class Z{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(h,d,T){const Y=new Uint8Array(h.buffer,h.byteOffset,h.byteLength),y=X(Y),C=F(Y,y),n=y.width*y.height,U=new Float32Array(4*n);for(let X=0;X<n;X+=1)U[4*X]=C[3*X],U[4*X+1]=C[3*X+1],U[4*X+2]=C[3*X+2],U[4*X+3]=1;T(y.width,y.height,d.generateMipMaps,!1,(()=>{const h=d.getEngine();d.type=1,d.format=5,d._gammaSpace=!1,h._uploadDataToTextureDirectly(d,U)}))}}}}]);