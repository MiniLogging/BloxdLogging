"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13915:(n,k,T)=>{T.r(k),T.d(k,{AnimationGroup:()=>z,TargetedAnimation:()=>C});var c=T(12706),K=T(539),Q=T(588),G=T(696),w=T(12703),E=T(730);class I{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(n,k,T,K){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=k,this._target=n,this._scene=T,this._host=K,this._activeTargets=[],k._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===c.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=E.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const n={frame:0,value:this._minValue};this._keys.splice(0,0,n)}if(this._target instanceof Array){let n=0;for(const k of this._target)this._preparePath(k,n),this._getOriginalValues(n),n++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const Q=k.getEvents();if(Q&&Q.length>0)for(const c of Q)this._events.push(c._clone());this._enableBlending=n&&n.animationPropertiesOverride?n.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(n){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const T=this._animation.targetPropertyPath;if(T.length>1){let c=n;for(let n=0;n<T.length-1;n++){const k=T[n];if(c=c[k],void 0===c)throw new Error(`Invalid property (${k}) in property path (${T.join(".")})`)}this._targetPath=T[T.length-1],this._activeTargets[k]=c}else this._targetPath=T[0],this._activeTargets[k]=n;if(void 0===this._activeTargets[k][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${T.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let n=0;for(const k of this._target)void 0!==this._originalValue[n]&&this._setValue(k,this._activeTargets[n],this._originalValue[n],-1,n),n++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let n=0;n<this._events.length;n++)this._events[n].isDone=!1}isStopped(){return this._stopped}dispose(){const n=this._animation.runtimeAnimations.indexOf(this);n>-1&&this._animation.runtimeAnimations.splice(n,1)}setValue(n,k){if(this._targetIsArray)for(let T=0;T<this._target.length;T++){const c=this._target[T];this._setValue(c,this._activeTargets[T],n,k,T)}else this._setValue(this._target,this._directTarget,n,k,0)}_getOriginalValues(){let n,k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const T=this._activeTargets[k];n=T.getLocalMatrix&&"_matrix"===this._targetPath?T.getLocalMatrix():T[this._targetPath],n&&n.clone?this._originalValue[k]=n.clone():this._originalValue[k]=n}_registerTargetForLateAnimationBinding(n,k){const T=n.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(T),T._lateAnimationHolders||(T._lateAnimationHolders={}),T._lateAnimationHolders[n.targetPath]||(T._lateAnimationHolders[n.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:k}),n.isAdditive?(T._lateAnimationHolders[n.targetPath].additiveAnimations.push(n),T._lateAnimationHolders[n.targetPath].totalAdditiveWeight+=n.weight):(T._lateAnimationHolders[n.targetPath].animations.push(n),T._lateAnimationHolders[n.targetPath].totalWeight+=n.weight)}_setValue(n,k,T,K,Q){if(this._currentActiveTarget=k,this._weight=K,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const n=k[this._targetPath];n.clone?this._originalBlendValue=n.clone():this._originalBlendValue=n}this._originalBlendValue.m?c.c.AllowMatrixDecomposeForInterpolation?this._currentValue?E.d.DecomposeLerpToRef(this._originalBlendValue,T,this._blendingFactor,this._currentValue):this._currentValue=E.d.DecomposeLerp(this._originalBlendValue,T,this._blendingFactor):this._currentValue?E.d.LerpToRef(this._originalBlendValue,T,this._blendingFactor,this._currentValue):this._currentValue=E.d.Lerp(this._originalBlendValue,T,this._blendingFactor):this._currentValue=c.c._UniversalLerp(this._originalBlendValue,T,this._blendingFactor);const K=n&&n.animationPropertiesOverride?n.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=K}else this._currentValue?this._currentValue.p?this._currentValue.p(T):this._currentValue=T:null!==T&&void 0!==T&&T.clone?this._currentValue=T.clone():this._currentValue=T;-1!==K?this._registerTargetForLateAnimationBinding(this,this._originalValue[Q]):this._animationState.loopMode===c.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[Q],k[this._targetPath]):k[this._targetPath]=this._originalValue[Q]+this._currentValue:k[this._targetPath]=this._currentValue,n.Li&&n.Li(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(n){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const T=this._animation.getKeys();n<T[0].frame?n=T[0].frame:n>T[T.length-1].frame&&(n=T[T.length-1].frame);const c=this._events;if(c.length)for(let Q=0;Q<c.length;Q++)c[Q].onlyOnce||(c[Q].isDone=c[Q].frame<n);this._currentFrame=n;const K=this._animation._interpolate(n,this._animationState);this.setValue(K,k)}_prepareForSpeedRatioChange(n){const k=this._previousElapsedTime*(this._animation.framePerSecond*n)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-k}animate(n,k,T,K,Q){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const w=this._animation,E=w.targetPropertyPath;if(!E||E.length<1)return this._stopped=!0,!1;let I,S=!0;const P=this._events;let W=0;if(this._coreRuntimeAnimation)W=T-k,I=this._coreRuntimeAnimation.currentFrame,this._currentFrame=I,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let G;(k<this._minFrame||k>this._maxFrame)&&(k=this._minFrame),(T<this._minFrame||T>this._maxFrame)&&(T=this._maxFrame),W=T-k;let E=n*(w.framePerSecond*Q)/1e3+this._absoluteFrameOffset,J=0,H=!1;const s=K&&this._animationState.loopMode===c.c.ANIMATIONLOOPMODE_YOYO;if(s){const n=(E-k)/W,T=Math.sin(n*Math.PI);E=Math.abs(T)*W+k;const c=T>=0?1:-1;this._yoyoDirection!==c&&(H=!0),this._yoyoDirection=c}if(this._previousElapsedTime=n,this._previousAbsoluteFrame=E,!K&&T>=k&&(E>=W&&Q>0||E<=0&&Q<0))S=!1,J=w._getKeyValue(this._maxValue);else if(!K&&k>=T&&(E<=W&&Q<0||E>=0&&Q>0))S=!1,J=w._getKeyValue(this._minValue);else if(this._animationState.loopMode!==c.c.ANIMATIONLOOPMODE_CYCLE){const n=T.toString()+k.toString();if(!this._offsetsCache[n]){this._animationState.repeatCount=0,this._animationState.loopMode=c.c.ANIMATIONLOOPMODE_CYCLE;const K=w._interpolate(k,this._animationState),Q=w._interpolate(T,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),w.dataType){case c.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[n]=Q-K;break;case c.c.ANIMATIONTYPE_QUATERNION:case c.c.ANIMATIONTYPE_VECTOR3:case c.c.ANIMATIONTYPE_VECTOR2:case c.c.ANIMATIONTYPE_SIZE:case c.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[n]=Q.Fg(K)}this._highLimitsCache[n]=Q}J=this._highLimitsCache[n],G=this._offsetsCache[n]}if(void 0===G)switch(w.dataType){case c.c.ANIMATIONTYPE_FLOAT:G=0;break;case c.c.ANIMATIONTYPE_QUATERNION:G=c.h;break;case c.c.ANIMATIONTYPE_VECTOR3:G=c.l;break;case c.c.ANIMATIONTYPE_VECTOR2:G=c.k;break;case c.c.ANIMATIONTYPE_SIZE:G=c.j;break;case c.c.ANIMATIONTYPE_COLOR3:G=c.d;break;case c.c.ANIMATIONTYPE_COLOR4:G=c.e}if(this._host&&this._host.syncRoot){const n=this._host.syncRoot;I=k+W*((n.masterFrame-n.fromFrame)/(n.toFrame-n.fromFrame))}else I=E>0&&k>T||E<0&&k<T?S&&0!==W?T+E%W:k:S&&0!==W?k+E%W:T;if(!s&&(Q>0&&this.currentFrame>I||Q<0&&this.currentFrame<I)||s&&H){this._onLoop();for(let n=0;n<P.length;n++)P[n].onlyOnce||(P[n].isDone=!1);this._animationState.key=Q>0?0:w.getKeys().length-1}this._currentFrame=I,this._animationState.repeatCount=0===W?0:E/W|0,this._animationState.highLimitValue=J,this._animationState.offsetValue=G}const J=w._interpolate(I,this._animationState);if(this.setValue(J,G),P.length)for(let c=0;c<P.length;c++)if(W>=0&&I>=P[c].frame&&P[c].frame>=k||W<0&&I<=P[c].frame&&P[c].frame<=k){const n=P[c];n.isDone||(n.onlyOnce&&(P.splice(c,1),c--),n.isDone=!0,n.action(I))}return S||(this._stopped=!0),S}}var S=T(573);class P{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(n){this._weight=-1!==n?Math.min(Math.max(n,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(n){for(let k=0;k<this._runtimeAnimations.length;k++){this._runtimeAnimations[k]._prepareForSpeedRatioChange(n)}this._speedRatio=n,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(n,k){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,Q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,w=arguments.length>6?arguments[6]:void 0,E=arguments.length>7?arguments[7]:void 0,I=arguments.length>8?arguments[8]:void 0,S=arguments.length>9&&void 0!==arguments[9]&&arguments[9],P=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=k,this.fromFrame=T,this.toFrame=c,this.loopAnimation=Q,this.onAnimationEnd=w,this.onAnimationLoop=I,this.isAdditive=S,this.playOrder=P,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Kk=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new K.b,this.onAnimationLoopObservable=new K.b,this._scene=n,E&&this.appendAnimations(k,E),this._speedRatio=G,n._activeAnimatables.push(this)}syncWith(n){if(this._syncRoot=n,n){const n=this._scene._activeAnimatables.indexOf(this);n>-1&&(this._scene._activeAnimatables.splice(n,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(n,k){for(let T=0;T<k.length;T++){const c=k[T],K=new I(n,c,this._scene,this);K._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(K)}}getAnimationByTargetProperty(n){const k=this._runtimeAnimations;for(let T=0;T<k.length;T++)if(k[T].animation.targetProperty===n)return k[T].animation;return null}getRuntimeAnimationByTargetProperty(n){const k=this._runtimeAnimations;for(let T=0;T<k.length;T++)if(k[T].animation.targetProperty===n)return k[T];return null}reset(){const n=this._runtimeAnimations;for(let k=0;k<n.length;k++)n[k].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(n){const k=this._runtimeAnimations;for(let T=0;T<k.length;T++)k[T].animation.enableBlending=!0,k[T].animation.blendingSpeed=n}disableBlending(){const n=this._runtimeAnimations;for(let k=0;k<n.length;k++)n[k].animation.enableBlending=!1}goToFrame(n){let k=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const T=this._runtimeAnimations;if(T[0]){const k=T[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??T[0].currentFrame;const c=0===this.speedRatio?0:(n-this._frameToSyncFromJump)/k*1e3/this.speedRatio;this._manualJumpDelay=-c}for(let c=0;c<T.length;c++)T[c].goToFrame(n,k?this._weight:-1);this._goToFrame=n}get paused(){return this.Kk}pause(){this.Kk||(this.Kk=!0)}restart(){this.Kk=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(n,k){let T=arguments.length>2&&void 0!==arguments[2]&&arguments[2],c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(n||k){const K=this._scene._activeAnimatables.indexOf(this);if(K>-1){const Q=this._runtimeAnimations;for(let T=Q.length-1;T>=0;T--){const c=Q[T];n&&c.animation.name!=n||(k&&!k(c.target)||(c.dispose(),Q.splice(T,1)))}0==Q.length&&(T||this._scene._activeAnimatables.splice(K,1),c||this._raiseOnAnimationEnd())}}else{const n=this._scene._activeAnimatables.indexOf(this);if(n>-1){T||this._scene._activeAnimatables.splice(n,1);const k=this._runtimeAnimations;for(let n=0;n<k.length;n++)k[n].dispose();this._runtimeAnimations.length=0,c||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((n=>{this.onAnimationEndObservable.add((()=>{n(this)}),void 0,void 0,this,!0)}))}_animate(n){if(this.Kk)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=n),!0;if(null===this._localDelayOffset?(this._localDelayOffset=n,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=n-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let k=!1;const T=this._runtimeAnimations;let c;for(c=0;c<T.length;c++){const K=T[c].animate(n-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);k=k||K}if(this.animationStarted=k,!k){if(this.disposeOnEnd)for(c=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(c,1),c=0;c<T.length;c++)T[c].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return k}}function W(n){if(0===n.totalWeight&&0===n.totalAdditiveWeight)return n.originalValue;let k=1;const T=E.l.li[0],c=E.l.li[1],K=E.l.Quaternion[0];let Q=0;const G=n.animations[0],w=n.originalValue;let I=1,S=!1;if(n.totalWeight<1)I=1-n.totalWeight,w.decompose(c,K,T);else{if(Q=1,k=n.totalWeight,I=G.weight/k,1==I){if(!n.totalAdditiveWeight)return G.currentValue;S=!0}G.currentValue.decompose(c,K,T)}if(!S){c.scaleInPlace(I),T.scaleInPlace(I),K.scaleInPlace(I);for(let G=Q;G<n.animations.length;G++){const Q=n.animations[G];if(0===Q.weight)continue;I=Q.weight/k;const w=E.l.li[2],S=E.l.li[3],P=E.l.Quaternion[1];Q.currentValue.decompose(S,P,w),S.scaleAndAddToRef(I,c),P.scaleAndAddToRef(E.h.Dot(K,P)>0?I:-I,K),w.scaleAndAddToRef(I,T)}K.normalize()}for(let W=0;W<n.additiveAnimations.length;W++){const k=n.additiveAnimations[W];if(0===k.weight)continue;const Q=E.l.li[2],G=E.l.li[3],w=E.l.Quaternion[1];k.currentValue.decompose(G,w,Q),G.multiplyToRef(c,G),E.o.LerpToRef(c,G,k.weight,c),K.multiplyToRef(w,w),E.h.SlerpToRef(K,w,k.weight,K),Q.scaleAndAddToRef(k.weight,T)}const P=G?G._animationState.workValue:E.l.Matrix[0].clone();return E.d.ComposeToRef(c,K,T,P),P}function J(n,k){if(0===n.totalWeight&&0===n.totalAdditiveWeight)return k;const T=n.animations[0],c=n.originalValue;let K=k;if(0===n.totalWeight&&n.totalAdditiveWeight>0)K.p(c);else if(1===n.animations.length){if(E.h.SlerpToRef(c,T.currentValue,Math.min(1,n.totalWeight),K),0===n.totalAdditiveWeight)return K}else if(n.animations.length>1){let T,Q,G=1;if(n.totalWeight<1){const k=1-n.totalWeight;T=[],Q=[],T.push(c),Q.push(k)}else{if(2===n.animations.length&&(E.h.SlerpToRef(n.animations[0].currentValue,n.animations[1].currentValue,n.animations[1].weight/n.totalWeight,k),0===n.totalAdditiveWeight))return k;T=[],Q=[],G=n.totalWeight}for(let k=0;k<n.animations.length;k++){const c=n.animations[k];T.push(c.currentValue),Q.push(c.weight/G)}let w=0;for(let n=0;n<T.length;)n?(w+=Q[n],E.h.SlerpToRef(K,T[n],Q[n]/w,K),n++):(E.h.SlerpToRef(T[n],T[n+1],Q[n+1]/(Q[n]+Q[n+1]),k),K=k,w=Q[n]+Q[n+1],n+=2)}for(let Q=0;Q<n.additiveAnimations.length;Q++){const k=n.additiveAnimations[Q];0!==k.weight&&(K.multiplyToRef(k.currentValue,E.l.Quaternion[0]),E.h.SlerpToRef(K,E.l.Quaternion[0],k.weight,K))}return K}var H,s,b=T(2475);H=b.c,(s=w.b)&&(s.prototype.copyAnimationRange=function(n,k,T){let K=arguments.length>3&&void 0!==arguments[3]&&arguments[3],Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new c.c(this.name,"_matrix",n.animations[0].framePerSecond,c.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const G=n.animations[0].getRange(k);if(!G)return!1;const w=G.from,E=G.to,I=n.animations[0].getKeys(),S=n.length,P=n.getParent(),W=this.getParent(),J=K&&P&&S&&this.length&&S!==this.length,H=J&&W&&P?W.length/P.length:1,s=K&&!W&&Q&&(1!==Q.x||1!==Q.y||1!==Q.z),b=this.animations[0].getKeys();let C,z,r;for(let c=0,q=I.length;c<q;c++)C=I[c],C.frame>=w&&C.frame<=E&&(K?(r=C.value.clone(),J?(z=r.getTranslation(),r.setTranslation(z.scaleInPlace(H))):s&&Q?(z=r.getTranslation(),r.setTranslation(z.multiplyInPlace(Q))):r=C.value):r=C.value,b.push({frame:C.frame+T,value:r}));return this.animations[0].createRange(k,w+T,E+T),!0}),H&&(H.prototype._animate=function(n){if(!this.animationsEnabled)return;const k=S.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=k}this.deltaTime=void 0!==n?n:this.useConstantAnimationDeltaTime?16:(k-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=k;const T=this._activeAnimatables;if(0===T.length)return;this._animationTime+=this.deltaTime;const K=this._animationTime;for(let c=0;c<T.length;c++){const n=T[c];!n._animate(K)&&n.disposeOnEnd&&c--}!function(n){if(n._registeredForLateAnimationBindings.length){for(let k=0;k<n._registeredForLateAnimationBindings.length;k++){const T=n._registeredForLateAnimationBindings.data[k];for(const n in T._lateAnimationHolders){const k=T._lateAnimationHolders[n],K=k.animations[0],Q=k.originalValue;if(void 0===Q||null===Q)continue;const G=c.c.AllowMatrixDecomposeForInterpolation&&Q.m;let w=T[n];if(G)w=W(k);else if(void 0!==Q.w)w=J(k,w||E.h.Identity());else{let n=0,T=1;const G=K&&K._animationState.loopMode===c.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(k.totalWeight<1)w=G?Q.clone?Q.clone():Q:K&&Q.scale?Q.scale(1-k.totalWeight):K?Q*(1-k.totalWeight):Q.clone?Q.clone():Q;else if(K){T=k.totalWeight;const c=K.weight/T;w=1!==c?K.currentValue.scale?K.currentValue.scale(c):K.currentValue*c:K.currentValue,G&&(w.addToRef?w.addToRef(Q,w):w+=Q),n=1}for(let c=n;c<k.animations.length;c++){const n=k.animations[c],K=n.weight/T;K&&(n.currentValue.scaleAndAddToRef?n.currentValue.scaleAndAddToRef(K,w):w+=n.currentValue*K)}for(let c=0;c<k.additiveAnimations.length;c++){const n=k.additiveAnimations[c],T=n.weight;T&&(n.currentValue.scaleAndAddToRef?n.currentValue.scaleAndAddToRef(T,w):w+=n.currentValue*T)}}T[n]=w}T._lateAnimationHolders={}}n._registeredForLateAnimationBindings.reset()}}(this)},H.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((n,k)=>n.playOrder-k.playOrder))},H.prototype.beginWeightedAnimation=function(n,k,T){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,K=arguments.length>4?arguments[4]:void 0,Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,G=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,E=arguments.length>8?arguments[8]:void 0,I=arguments.length>9?arguments[9]:void 0,S=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const P=this.beginAnimation(n,k,T,K,Q,G,w,!1,E,I,S);return P.weight=c,P},H.prototype.beginAnimation=function(n,k,T,c){let K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,Q=arguments.length>5?arguments[5]:void 0,G=arguments.length>6?arguments[6]:void 0,w=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],E=arguments.length>8?arguments[8]:void 0,I=arguments.length>9?arguments[9]:void 0,S=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(K<0){const n=k;k=T,T=n,K=-K}k>T&&(K=-K),w&&this.stopAnimation(n,void 0,E),G||(G=new P(this,n,k,T,c,K,Q,void 0,I,S));const W=!E||E(n);if(n.animations&&W&&G.appendAnimations(n,n.animations),n.getAnimatables){const S=n.getAnimatables();for(let n=0;n<S.length;n++)this.beginAnimation(S[n],k,T,c,K,Q,G,w,E,I)}return G.reset(),G},H.prototype.beginHierarchyAnimation=function(n,k,T,c,K){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,G=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,E=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],I=arguments.length>9?arguments[9]:void 0,S=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const P=n.getDescendants(k),W=[];W.push(this.beginAnimation(n,T,c,K,Q,G,w,E,I,void 0,S));for(const J of P)W.push(this.beginAnimation(J,T,c,K,Q,G,w,E,I,void 0,S));return W},H.prototype.beginDirectAnimation=function(n,k,T,c,K){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(Q<0){const n=T;T=c,c=n,Q=-Q}return T>c&&(Q=-Q),new P(this,n,T,c,K,Q,arguments.length>6?arguments[6]:void 0,k,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},H.prototype.beginDirectHierarchyAnimation=function(n,k,T,c,K,Q,G,w,E){let I=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const S=n.getDescendants(k),P=[];P.push(this.beginDirectAnimation(n,T,c,K,Q,G,w,E,I));for(const W of S)P.push(this.beginDirectAnimation(W,T,c,K,Q,G,w,E,I));return P},H.prototype.getAnimatableByTarget=function(n){for(let k=0;k<this._activeAnimatables.length;k++)if(this._activeAnimatables[k].target===n)return this._activeAnimatables[k];return null},H.prototype.getAllAnimatablesByTarget=function(n){const k=[];for(let T=0;T<this._activeAnimatables.length;T++)this._activeAnimatables[T].target===n&&k.push(this._activeAnimatables[T]);return k},H.prototype.stopAnimation=function(n,k,T){const c=this.getAllAnimatablesByTarget(n);for(const K of c)K.stop(k,T)},H.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let n=0;n<this._activeAnimatables.length;n++)this._activeAnimatables[n].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const n of this.animationGroups)n.stop()});class C{getClassName(){return"TargetedAnimation"}serialize(){const n={};return n.animation=this.animation.serialize(),n.targetId=this.target.id,n}}class z{get mask(){return this._mask}set mask(n){this._mask!==n&&(this._mask=n,this.syncWithMask(!0))}syncWithMask(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||n){this._numActiveAnimatables=0;for(let n=0;n<this._animatables.length;++n){const k=this._animatables[n];!this.mask||this.mask.disabled||this.mask.retainsTarget(k.target.name)?(this._numActiveAnimatables++,k.paused&&k.restart()):k.paused||k.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let n=0;n<this._animatables.length;++n){const k=this._animatables[n];this.mask.retainsTarget(k.target.name)||(k.stop(),this._animatables.splice(n,1),--n)}for(let n=0;n<this._targetedAnimations.length;n++){const k=this._targetedAnimations[n];this.mask.retainsTarget(k.target.name)||(this._targetedAnimations.splice(n,1),--n)}}}get from(){return this._from}set from(n){if(this._from!==n){this._from=n;for(let n=0;n<this._animatables.length;n++){this._animatables[n].fromFrame=this._from}}}get to(){return this._to}set to(n){if(this._to!==n){this._to=n;for(let n=0;n<this._animatables.length;n++){this._animatables[n].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(n){if(this._speedRatio!==n){this._speedRatio=n;for(let n=0;n<this._animatables.length;n++){this._animatables[n].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(n){if(this._loopAnimation!==n){this._loopAnimation=n;for(let n=0;n<this._animatables.length;n++){this._animatables[n].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(n){if(this._isAdditive!==n){this._isAdditive=n;for(let n=0;n<this._animatables.length;n++){this._animatables[n].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(n){this._weight!==n&&(this._weight=n,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(n){if(this._playOrder!==n&&(this._playOrder=n,this._animatables.length>0)){for(let n=0;n<this._animatables.length;n++)this._animatables[n].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(n){if(this._enableBlending!==n&&(this._enableBlending=n,null!==n))for(let k=0;k<this._targetedAnimations.length;++k)this._targetedAnimations[k].animation.enableBlending=n}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(n){if(this._blendingSpeed!==n&&(this._blendingSpeed=n,null!==n))for(let k=0;k<this._targetedAnimations.length;++k)this._targetedAnimations[k].animation.blendingSpeed=n}getLength(n,k){n=n??this._from;return((k=k??this._to)-n)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(n){let k=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],T=arguments.length>2&&void 0!==arguments[2]&&arguments[2],c=arguments.length>3?arguments[3]:void 0;if(0===n.length)return null;c=c??n[0].weight;let K=Number.MAX_VALUE,Q=-Number.MAX_VALUE;if(T)for(const w of n)w.from<K&&(K=w.from),w.to>Q&&(Q=w.to);const G=new z(n[0].name+"_merged",n[0]._scene,c);for(const w of n){T&&w.normalize(K,Q);for(const n of w.targetedAnimations)G.addTargetedAnimation(n.animation,n.target);k&&w.dispose()}return G}constructor(n){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=n,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new K.b,this.onAnimationLoopObservable=new K.b,this.onAnimationGroupLoopObservable=new K.b,this.onAnimationGroupEndObservable=new K.b,this.onAnimationGroupPauseObservable=new K.b,this.onAnimationGroupPlayObservable=new K.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=k||Q.e.LastCreatedScene,this._weight=T,this._playOrder=c,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(n,k){const T=new C;T.animation=n,T.target=k;const c=n.getKeys();return this._from>c[0].frame&&(this._from=c[0].frame),this._to<c[c.length-1].frame&&(this._to=c[c.length-1].frame),null!==this._enableBlending&&(n.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(n.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(T),this._shouldStart=!0,T}removeTargetedAnimation(n){for(let k=this._targetedAnimations.length-1;k>-1;k--){this._targetedAnimations[k].animation===n&&this._targetedAnimations.splice(k,1)}}normalize(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==n&&(n=this._from),null==k&&(k=this._to);for(let T=0;T<this._targetedAnimations.length;T++){const c=this._targetedAnimations[T].animation.getKeys(),K=c[0],Q=c[c.length-1];if(K.frame>n){const k={frame:n,value:K.value,inTangent:K.inTangent,outTangent:K.outTangent,interpolation:K.interpolation};c.splice(0,0,k)}if(Q.frame<k){const n={frame:k,value:Q.value,inTangent:Q.inTangent,outTangent:Q.outTangent,interpolation:Q.interpolation};c.push(n)}}return this._from=n,this._to=k,this}_processLoop(n,k,T){n.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(k),this._animationLoopFlags[T]||(this._animationLoopFlags[T]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0],k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0,c=arguments.length>3?arguments[3]:void 0,K=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=n,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let Q=0;Q<this._targetedAnimations.length;Q++){const G=this._targetedAnimations[Q],w=this._scene.beginDirectAnimation(G.target,[G.animation],void 0!==T?T:this._from,void 0!==c?c:this._to,n,k,void 0,void 0,void 0!==K?K:this._isAdditive);w.weight=this._weight,w.playOrder=this._playOrder,w.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(G),this._checkAnimationGroupEnded(w)},this._processLoop(w,G,Q),this._animatables.push(w)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=k,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let n=0;n<this._animatables.length;n++){this._animatables[n].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(n){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==n&&(this.loopAnimation=n),this.restart()):(this.stop(),this.start(n,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let n=0;n<this._animatables.length;n++){this._animatables[n].reset()}return this}restart(){if(!this._isStarted)return this;for(let n=0;n<this._animatables.length;n++){this._animatables[n].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const k=this._animatables.slice();for(let c=0;c<k.length;c++)k[c].stop(void 0,void 0,!0,n);let T=0;for(let c=0;c<this._scene._activeAnimatables.length;c++){const k=this._scene._activeAnimatables[c];k._runtimeAnimations.length>0?this._scene._activeAnimatables[T++]=k:n&&this._checkAnimationGroupEnded(k,n)}return this._scene._activeAnimatables.length=T,this._isStarted=!1,this}setWeightForAllAnimatables(n){for(let k=0;k<this._animatables.length;k++){this._animatables[k].weight=n}return this}syncAllAnimationsWith(n){for(let k=0;k<this._animatables.length;k++){this._animatables[k].syncWith(n)}return this}goToFrame(n){let k=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let T=0;T<this._animatables.length;T++){this._animatables[T].goToFrame(n,k)}return this}getCurrentFrame(){var n;return(null===(n=this.animatables[0])||void 0===n?void 0:n.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const n=this._scene.animationGroups.indexOf(this);if(n>-1&&this._scene.animationGroups.splice(n,1),this._parentContainer){const n=this._parentContainer.animationGroups.indexOf(this);n>-1&&this._parentContainer.animationGroups.splice(n,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(n){let k=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const T=this._animatables.indexOf(n);T>-1&&this._animatables.splice(T,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,k||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(n,k){let T=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=new z(n||this.name,this._scene,this._weight,this._playOrder);c._from=this.from,c._to=this.to,c._speedRatio=this.speedRatio,c._loopAnimation=this.loopAnimation,c._isAdditive=this.isAdditive,c._enableBlending=this.enableBlending,c._blendingSpeed=this.blendingSpeed,c.metadata=this.metadata,c.mask=this.mask;for(const K of this._targetedAnimations)c.addTargetedAnimation(T?K.animation.clone():K.animation,k?k(K.target):K.target);return c}serialize(){const n={};n.name=this.name,n.from=this.from,n.to=this.to,n.speedRatio=this.speedRatio,n.loopAnimation=this.loopAnimation,n.isAdditive=this.isAdditive,n.weight=this.weight,n.playOrder=this.playOrder,n.enableBlending=this.enableBlending,n.blendingSpeed=this.blendingSpeed,n.targetedAnimations=[];for(let k=0;k<this.targetedAnimations.length;k++){const T=this.targetedAnimations[k];n.targetedAnimations[k]=T.serialize()}return G.b&&G.b.HasTags(this)&&(n.tags=G.b.GetTags(this)),this.metadata&&(n.metadata=this.metadata),n}static Parse(n,k){const T=new z(n.name,k,n.weight,n.playOrder);for(let K=0;K<n.targetedAnimations.length;K++){const Q=n.targetedAnimations[K],G=c.c.Parse(Q.animation),w=Q.targetId;if("influence"===Q.animation.property){const n=k.getMorphTargetById(w);n&&T.addTargetedAnimation(G,n)}else{const n=k.getNodeById(w);null!=n&&T.addTargetedAnimation(G,n)}}return G.b&&G.b.AddTagsTo(T,n.tags),null!==n.from&&null!==n.to&&T.normalize(n.from,n.to),void 0!==n.speedRatio&&(T._speedRatio=n.speedRatio),void 0!==n.loopAnimation&&(T._loopAnimation=n.loopAnimation),void 0!==n.isAdditive&&(T._isAdditive=n.isAdditive),void 0!==n.weight&&(T._weight=n.weight),void 0!==n.playOrder&&(T._playOrder=n.playOrder),void 0!==n.enableBlending&&(T._enableBlending=n.enableBlending),void 0!==n.blendingSpeed&&(T._blendingSpeed=n.blendingSpeed),void 0!==n.metadata&&(T.metadata=n.metadata),T}static MakeAnimationAdditive(n,k,T){let K;K="object"===typeof k?k:{referenceFrame:k,range:T,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let Q=n;K.cloneOriginalAnimationGroup&&(Q=n.clone(K.clonedAnimationGroupName||Q.name));const G=Q.targetedAnimations;for(let w=0;w<G.length;w++){const n=G[w];n.animation=c.c.MakeAnimationAdditive(n.animation,K)}if(Q.isAdditive=!0,K.clipKeys){let n=Number.MAX_VALUE,k=-Number.MAX_VALUE;const T=Q.targetedAnimations;for(let c=0;c<T.length;c++){const K=T[c].animation.getKeys();n>K[0].frame&&(n=K[0].frame),k<K[K.length-1].frame&&(k=K[K.length-1].frame)}Q._from=n,Q._to=k}return Q}static ClipKeys(n,k,T,c,K){const Q=n.clone(c||n.name);return z.ClipKeysInPlace(Q,k,T,K)}static ClipKeysInPlace(n,k,T,c){return z.ClipInPlace(n,k,T,c,!1)}static ClipFrames(n,k,T,c,K){const Q=n.clone(c||n.name);return z.ClipFramesInPlace(Q,k,T,K)}static ClipFramesInPlace(n,k,T,c){return z.ClipInPlace(n,k,T,c,!0)}static ClipInPlace(n,k,T,c){let K=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Q=Number.MAX_VALUE,G=-Number.MAX_VALUE;const w=n.targetedAnimations;for(let E=0;E<w.length;E++){const n=w[E],I=c?n.animation:n.animation.clone();K&&(I.createKeyForFrame(k),I.createKeyForFrame(T));const S=I.getKeys(),P=[];let W=Number.MAX_VALUE;for(let c=0;c<S.length;c++){const n=S[c];if(!K&&c>=k&&c<=T||K&&n.frame>=k&&n.frame<=T){const k={frame:n.frame,value:n.value.clone?n.value.clone():n.value,inTangent:n.inTangent,outTangent:n.outTangent,interpolation:n.interpolation,lockedTangent:n.lockedTangent};W===Number.MAX_VALUE&&(W=k.frame),k.frame-=W,P.push(k)}}0!==P.length?(Q>P[0].frame&&(Q=P[0].frame),G<P[P.length-1].frame&&(G=P[P.length-1].frame),I.setKeys(P,!0),n.animation=I):(w.splice(E,1),E--)}return n._from=Q,n._to=G,n}getClassName(){return"AnimationGroup"}toString(n){let k="Name: "+this.name;return k+=", type: "+this.getClassName(),n&&(k+=", from: "+this._from,k+=", to: "+this._to,k+=", isStarted: "+this._isStarted,k+=", speedRatio: "+this._speedRatio,k+=", targetedAnimations length: "+this._targetedAnimations.length,k+=", animatables length: "+this._animatables),k}}}}]);