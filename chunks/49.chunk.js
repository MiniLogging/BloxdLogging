"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[49],{15080:(L,U,x)=>{x.r(U),x.d(U,{_HDRTextureLoader:()=>r});var mL=x(12589);class p{static ConvertPanoramaToCubemap(L,U,x,mL){let p=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!L)throw"ConvertPanoramaToCubemap: input cannot be null";if(L.length!=U*x*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(mL,this.FACE_FRONT,L,U,x,p),back:this.CreateCubemapTexture(mL,this.FACE_BACK,L,U,x,p),left:this.CreateCubemapTexture(mL,this.FACE_LEFT,L,U,x,p),right:this.CreateCubemapTexture(mL,this.FACE_RIGHT,L,U,x,p),up:this.CreateCubemapTexture(mL,this.FACE_UP,L,U,x,p),down:this.CreateCubemapTexture(mL,this.FACE_DOWN,L,U,x,p),size:mL,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(L,U,x,mL,p){let G=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const F=new ArrayBuffer(L*L*4*3),a=new Float32Array(F),o=G?Math.max(1,Math.round(mL/4/L)):1,A=1/o,r=A*A,h=U[1].SU(U[0]).scale(A/L),b=U[3].SU(U[2]).scale(A/L),E=1/L;let Y=0;for(let S=0;S<L;S++)for(let G=0;G<o;G++){let G=U[0],F=U[2];for(let U=0;U<L;U++)for(let A=0;A<o;A++){const o=F.SU(G).scale(Y).add(G);o.normalize();const A=this.CalcProjectionSpherical(o,x,mL,p);a[S*L*3+3*U+0]+=A.r*r,a[S*L*3+3*U+1]+=A.g*r,a[S*L*3+3*U+2]+=A.b*r,G=G.add(h),F=F.add(b)}Y+=E*A}return a}static CalcProjectionSpherical(L,U,x,mL){let p=Math.atan2(L.z,L.x);const G=Math.acos(L.y);for(;p<-Math.PI;)p+=2*Math.PI;for(;p>Math.PI;)p-=2*Math.PI;let F=p/Math.PI;const a=G/Math.PI;F=.5*F+.5;let o=Math.round(F*x);o<0?o=0:o>=x&&(o=x-1);let A=Math.round(a*mL);A<0?A=0:A>=mL&&(A=mL-1);const r=mL-A-1;return{r:U[r*x*3+3*o+0],g:U[r*x*3+3*o+1],b:U[r*x*3+3*o+2]}}}function G(L,U,x,mL,p,G){p>0?(p=function(L,U){return U>1023?L*Math.pow(2,1023)*Math.pow(2,U-1023):U<-1074?L*Math.pow(2,-1074)*Math.pow(2,U+1074):L*Math.pow(2,U)}(1,p-136),L[G+0]=U*p,L[G+1]=x*p,L[G+2]=mL*p):(L[G+0]=0,L[G+1]=0,L[G+2]=0)}function F(L,U){let x="",mL="";for(let p=U;p<L.length-U&&(mL=String.fromCharCode(L[p]),"\n"!=mL);p++)x+=mL;return x}function a(L){let U=0,x=0,mL=F(L,0);if("#"!=mL[0]||"?"!=mL[1])throw"Bad HDR Format.";let p=!1,G=!1,a=0;do{a+=mL.length+1,mL=F(L,a),"FORMAT=32-bit_rle_rgbe"==mL?G=!0:0==mL.length&&(p=!0)}while(!p);if(!G)throw"HDR Bad header format, unsupported FORMAT";a+=mL.length+1,mL=F(L,a);const o=/^-Y (.*) \+X (.*)$/g.exec(mL);if(!o||o.length<3)throw"HDR Bad header format, no size";if(x=parseInt(o[2]),U=parseInt(o[1]),x<8||x>32767)throw"HDR Bad header format, unsupported size";return a+=mL.length+1,{height:U,width:x,dataPosition:a}}function o(L,U){return function(L,U){let x=U.height;const mL=U.width;let p,F,a,o,r,h=U.dataPosition,b=0,E=0,Y=0;const S=new ArrayBuffer(4*mL),V=new Uint8Array(S),H=new ArrayBuffer(U.width*U.height*4*3),Q=new Float32Array(H);for(;x>0;){if(p=L[h++],F=L[h++],a=L[h++],o=L[h++],2!=p||2!=F||128&a||U.width<8||U.width>32767)return A(L,U);if((a<<8|o)!=mL)throw"HDR Bad header format, wrong scan line width";for(b=0,Y=0;Y<4;Y++)for(E=(Y+1)*mL;b<E;)if(p=L[h++],F=L[h++],p>128){if(r=p-128,0==r||r>E-b)throw"HDR Bad Format, bad scanline data (run)";for(;r-- >0;)V[b++]=F}else{if(r=p,0==r||r>E-b)throw"HDR Bad Format, bad scanline data (non-run)";if(V[b++]=F,--r>0)for(let U=0;U<r;U++)V[b++]=L[h++]}for(Y=0;Y<mL;Y++)p=V[Y],F=V[Y+mL],a=V[Y+2*mL],o=V[Y+3*mL],G(Q,p,F,a,o,(U.height-x)*mL*3+3*Y);x--}return Q}(L,U)}function A(L,U){let x=U.height;const mL=U.width;let p,F,a,o,A,r=U.dataPosition;const h=new ArrayBuffer(U.width*U.height*4*3),b=new Float32Array(h);for(;x>0;){for(A=0;A<U.width;A++)p=L[r++],F=L[r++],a=L[r++],o=L[r++],G(b,p,F,a,o,(U.height-x)*mL*3+3*A);x--}return b}p.FACE_LEFT=[new mL.YU(-1,-1,-1),new mL.YU(1,-1,-1),new mL.YU(-1,1,-1),new mL.YU(1,1,-1)],p.FACE_RIGHT=[new mL.YU(1,-1,1),new mL.YU(-1,-1,1),new mL.YU(1,1,1),new mL.YU(-1,1,1)],p.FACE_FRONT=[new mL.YU(1,-1,-1),new mL.YU(1,-1,1),new mL.YU(1,1,-1),new mL.YU(1,1,1)],p.FACE_BACK=[new mL.YU(-1,-1,1),new mL.YU(-1,-1,-1),new mL.YU(-1,1,1),new mL.YU(-1,1,-1)],p.FACE_DOWN=[new mL.YU(1,1,-1),new mL.YU(1,1,1),new mL.YU(-1,1,-1),new mL.YU(-1,1,1)],p.FACE_UP=[new mL.YU(-1,-1,-1),new mL.YU(-1,-1,1),new mL.YU(1,-1,-1),new mL.YU(1,-1,1)];class r{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(L,U,x){const mL=new Uint8Array(L.buffer,L.byteOffset,L.byteLength),p=a(mL),G=o(mL,p),F=p.width*p.height,A=new Float32Array(4*F);for(let a=0;a<F;a+=1)A[4*a]=G[3*a],A[4*a+1]=G[3*a+1],A[4*a+2]=G[3*a+2],A[4*a+3]=1;x(p.width,p.height,U.generateMipMaps,!1,(()=>{const L=U.getEngine();U.type=1,U.format=5,U._gammaSpace=!1,L._uploadDataToTextureDirectly(U,A)}))}}}}]);