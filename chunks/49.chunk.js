"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[49],{15339:(I,x,L)=>{L.r(x),L.d(x,{_HDRTextureLoader:()=>W});var F=L(12983);class X{static ConvertPanoramaToCubemap(I,x,L,F){let X=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!I)throw"ConvertPanoramaToCubemap: input cannot be null";if(I.length!=x*L*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(F,this.FACE_FRONT,I,x,L,X),back:this.CreateCubemapTexture(F,this.FACE_BACK,I,x,L,X),left:this.CreateCubemapTexture(F,this.FACE_LEFT,I,x,L,X),right:this.CreateCubemapTexture(F,this.FACE_RIGHT,I,x,L,X),up:this.CreateCubemapTexture(F,this.FACE_UP,I,x,L,X),down:this.CreateCubemapTexture(F,this.FACE_DOWN,I,x,L,X),size:F,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(I,x,L,F,X){let G=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const Y=new ArrayBuffer(I*I*4*3),p=new Float32Array(Y),B=G?Math.max(1,Math.round(F/4/I)):1,l=1/B,W=l*l,Q=x[1].Ux(x[0]).scale(l/I),e=x[3].Ux(x[2]).scale(l/I),g=1/I;let v=0;for(let z=0;z<I;z++)for(let G=0;G<B;G++){let G=x[0],Y=x[2];for(let x=0;x<I;x++)for(let l=0;l<B;l++){const B=Y.Ux(G).scale(v).add(G);B.normalize();const l=this.CalcProjectionSpherical(B,L,F,X);p[z*I*3+3*x+0]+=l.r*W,p[z*I*3+3*x+1]+=l.g*W,p[z*I*3+3*x+2]+=l.b*W,G=G.add(Q),Y=Y.add(e)}v+=g*l}return p}static CalcProjectionSpherical(I,x,L,F){let X=Math.atan2(I.z,I.x);const G=Math.acos(I.y);for(;X<-Math.PI;)X+=2*Math.PI;for(;X>Math.PI;)X-=2*Math.PI;let Y=X/Math.PI;const p=G/Math.PI;Y=.5*Y+.5;let B=Math.round(Y*L);B<0?B=0:B>=L&&(B=L-1);let l=Math.round(p*F);l<0?l=0:l>=F&&(l=F-1);const W=F-l-1;return{r:x[W*L*3+3*B+0],g:x[W*L*3+3*B+1],b:x[W*L*3+3*B+2]}}}function G(I,x,L,F,X,G){X>0?(X=function(I,x){return x>1023?I*Math.pow(2,1023)*Math.pow(2,x-1023):x<-1074?I*Math.pow(2,-1074)*Math.pow(2,x+1074):I*Math.pow(2,x)}(1,X-136),I[G+0]=x*X,I[G+1]=L*X,I[G+2]=F*X):(I[G+0]=0,I[G+1]=0,I[G+2]=0)}function Y(I,x){let L="",F="";for(let X=x;X<I.length-x&&(F=String.fromCharCode(I[X]),"\n"!=F);X++)L+=F;return L}function p(I){let x=0,L=0,F=Y(I,0);if("#"!=F[0]||"?"!=F[1])throw"Bad HDR Format.";let X=!1,G=!1,p=0;do{p+=F.length+1,F=Y(I,p),"FORMAT=32-bit_rle_rgbe"==F?G=!0:0==F.length&&(X=!0)}while(!X);if(!G)throw"HDR Bad header format, unsupported FORMAT";p+=F.length+1,F=Y(I,p);const B=/^-Y (.*) \+X (.*)$/g.exec(F);if(!B||B.length<3)throw"HDR Bad header format, no size";if(L=parseInt(B[2]),x=parseInt(B[1]),L<8||L>32767)throw"HDR Bad header format, unsupported size";return p+=F.length+1,{height:x,width:L,dataPosition:p}}function B(I,x){return function(I,x){let L=x.height;const F=x.width;let X,Y,p,B,W,Q=x.dataPosition,e=0,g=0,v=0;const z=new ArrayBuffer(4*F),H=new Uint8Array(z),s=new ArrayBuffer(x.width*x.height*4*3),U=new Float32Array(s);for(;L>0;){if(X=I[Q++],Y=I[Q++],p=I[Q++],B=I[Q++],2!=X||2!=Y||128&p||x.width<8||x.width>32767)return l(I,x);if((p<<8|B)!=F)throw"HDR Bad header format, wrong scan line width";for(e=0,v=0;v<4;v++)for(g=(v+1)*F;e<g;)if(X=I[Q++],Y=I[Q++],X>128){if(W=X-128,0==W||W>g-e)throw"HDR Bad Format, bad scanline data (run)";for(;W-- >0;)H[e++]=Y}else{if(W=X,0==W||W>g-e)throw"HDR Bad Format, bad scanline data (non-run)";if(H[e++]=Y,--W>0)for(let x=0;x<W;x++)H[e++]=I[Q++]}for(v=0;v<F;v++)X=H[v],Y=H[v+F],p=H[v+2*F],B=H[v+3*F],G(U,X,Y,p,B,(x.height-L)*F*3+3*v);L--}return U}(I,x)}function l(I,x){let L=x.height;const F=x.width;let X,Y,p,B,l,W=x.dataPosition;const Q=new ArrayBuffer(x.width*x.height*4*3),e=new Float32Array(Q);for(;L>0;){for(l=0;l<x.width;l++)X=I[W++],Y=I[W++],p=I[W++],B=I[W++],G(e,X,Y,p,B,(x.height-L)*F*3+3*l);L--}return e}X.FACE_LEFT=[new F.sx(-1,-1,-1),new F.sx(1,-1,-1),new F.sx(-1,1,-1),new F.sx(1,1,-1)],X.FACE_RIGHT=[new F.sx(1,-1,1),new F.sx(-1,-1,1),new F.sx(1,1,1),new F.sx(-1,1,1)],X.FACE_FRONT=[new F.sx(1,-1,-1),new F.sx(1,-1,1),new F.sx(1,1,-1),new F.sx(1,1,1)],X.FACE_BACK=[new F.sx(-1,-1,1),new F.sx(-1,-1,-1),new F.sx(-1,1,1),new F.sx(-1,1,-1)],X.FACE_DOWN=[new F.sx(1,1,-1),new F.sx(1,1,1),new F.sx(-1,1,-1),new F.sx(-1,1,1)],X.FACE_UP=[new F.sx(-1,-1,-1),new F.sx(-1,-1,1),new F.sx(1,-1,-1),new F.sx(1,-1,1)];class W{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(I,x,L){const F=new Uint8Array(I.buffer,I.byteOffset,I.byteLength),X=p(F),G=B(F,X),Y=X.width*X.height,l=new Float32Array(4*Y);for(let p=0;p<Y;p+=1)l[4*p]=G[3*p],l[4*p+1]=G[3*p+1],l[4*p+2]=G[3*p+2],l[4*p+3]=1;L(X.width,X.height,x.generateMipMaps,!1,(()=>{const I=x.getEngine();x.type=1,x.format=5,x._gammaSpace=!1,I._uploadDataToTextureDirectly(x,l)}))}}}}]);