"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13892:(U,M,b)=>{b.r(M),b.d(M,{AnimationGroup:()=>f,TargetedAnimation:()=>F});var a=b(12641),A=b(474),H=b(524),W=b(632),y=b(12632),O=b(670);class e{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(U,M,b,A){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=M,this._target=U,this._scene=b,this._host=A,this._activeTargets=[],M._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===a.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=O.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const U={frame:0,value:this._minValue};this._keys.splice(0,0,U)}if(this._target instanceof Array){let U=0;for(const M of this._target)this._preparePath(M,U),this._getOriginalValues(U),U++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const H=M.getEvents();if(H&&H.length>0)for(const a of H)this._events.push(a._clone());this._enableBlending=U&&U.animationPropertiesOverride?U.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(U){let M=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=this._animation.targetPropertyPath;if(b.length>1){let a=U;for(let U=0;U<b.length-1;U++){const M=b[U];if(a=a[M],void 0===a)throw new Error(`Invalid property (${M}) in property path (${b.join(".")})`)}this._targetPath=b[b.length-1],this._activeTargets[M]=a}else this._targetPath=b[0],this._activeTargets[M]=U;if(void 0===this._activeTargets[M][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${b.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let U=0;for(const M of this._target)void 0!==this._originalValue[U]&&this._setValue(M,this._activeTargets[U],this._originalValue[U],-1,U),U++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let U=0;U<this._events.length;U++)this._events[U].isDone=!1}isStopped(){return this._stopped}dispose(){const U=this._animation.runtimeAnimations.indexOf(this);U>-1&&this._animation.runtimeAnimations.splice(U,1)}setValue(U,M){if(this._targetIsArray)for(let b=0;b<this._target.length;b++){const a=this._target[b];this._setValue(a,this._activeTargets[b],U,M,b)}else this._setValue(this._target,this._directTarget,U,M,0)}_getOriginalValues(){let U,M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=this._activeTargets[M];U=b.getLocalMatrix&&"_matrix"===this._targetPath?b.getLocalMatrix():b[this._targetPath],U&&U.clone?this._originalValue[M]=U.clone():this._originalValue[M]=U}_registerTargetForLateAnimationBinding(U,M){const b=U.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(b),b._lateAnimationHolders||(b._lateAnimationHolders={}),b._lateAnimationHolders[U.targetPath]||(b._lateAnimationHolders[U.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:M}),U.isAdditive?(b._lateAnimationHolders[U.targetPath].additiveAnimations.push(U),b._lateAnimationHolders[U.targetPath].totalAdditiveWeight+=U.weight):(b._lateAnimationHolders[U.targetPath].animations.push(U),b._lateAnimationHolders[U.targetPath].totalWeight+=U.weight)}_setValue(U,M,b,A,H){if(this._currentActiveTarget=M,this._weight=A,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const U=M[this._targetPath];U.clone?this._originalBlendValue=U.clone():this._originalBlendValue=U}this._originalBlendValue.m?a.d.AllowMatrixDecomposeForInterpolation?this._currentValue?O.b.DecomposeLerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=O.b.DecomposeLerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue?O.b.LerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=O.b.Lerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue=a.d._UniversalLerp(this._originalBlendValue,b,this._blendingFactor);const A=U&&U.animationPropertiesOverride?U.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=A}else this._currentValue?this._currentValue.p?this._currentValue.p(b):this._currentValue=b:null!==b&&void 0!==b&&b.clone?this._currentValue=b.clone():this._currentValue=b;-1!==A?this._registerTargetForLateAnimationBinding(this,this._originalValue[H]):this._animationState.loopMode===a.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[H],M[this._targetPath]):M[this._targetPath]=this._originalValue[H]+this._currentValue:M[this._targetPath]=this._currentValue,U.hk&&U.hk(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(U){let M=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const b=this._animation.getKeys();U<b[0].frame?U=b[0].frame:U>b[b.length-1].frame&&(U=b[b.length-1].frame);const a=this._events;if(a.length)for(let H=0;H<a.length;H++)a[H].onlyOnce||(a[H].isDone=a[H].frame<U);this._currentFrame=U;const A=this._animation._interpolate(U,this._animationState);this.setValue(A,M)}_prepareForSpeedRatioChange(U){const M=this._previousElapsedTime*(this._animation.framePerSecond*U)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-M}animate(U,M,b,A,H){let W=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const y=this._animation,O=y.targetPropertyPath;if(!O||O.length<1)return this._stopped=!0,!1;let e,x=!0;const P=this._events;let Z=0;if(this._coreRuntimeAnimation)Z=b-M,e=this._coreRuntimeAnimation.currentFrame,this._currentFrame=e,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let W;(M<this._minFrame||M>this._maxFrame)&&(M=this._minFrame),(b<this._minFrame||b>this._maxFrame)&&(b=this._maxFrame),Z=b-M;let O=U*(y.framePerSecond*H)/1e3+this._absoluteFrameOffset,C=0,r=!1;const B=A&&this._animationState.loopMode===a.d.ANIMATIONLOOPMODE_YOYO;if(B){const U=(O-M)/Z,b=Math.sin(U*Math.PI);O=Math.abs(b)*Z+M;const a=b>=0?1:-1;this._yoyoDirection!==a&&(r=!0),this._yoyoDirection=a}if(this._previousElapsedTime=U,this._previousAbsoluteFrame=O,!A&&b>=M&&(O>=Z&&H>0||O<=0&&H<0))x=!1,C=y._getKeyValue(this._maxValue);else if(!A&&M>=b&&(O<=Z&&H<0||O>=0&&H>0))x=!1,C=y._getKeyValue(this._minValue);else if(this._animationState.loopMode!==a.d.ANIMATIONLOOPMODE_CYCLE){const U=b.toString()+M.toString();if(!this._offsetsCache[U]){this._animationState.repeatCount=0,this._animationState.loopMode=a.d.ANIMATIONLOOPMODE_CYCLE;const A=y._interpolate(M,this._animationState),H=y._interpolate(b,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),y.dataType){case a.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[U]=H-A;break;case a.d.ANIMATIONTYPE_QUATERNION:case a.d.ANIMATIONTYPE_VECTOR3:case a.d.ANIMATIONTYPE_VECTOR2:case a.d.ANIMATIONTYPE_SIZE:case a.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[U]=H.je(A)}this._highLimitsCache[U]=H}C=this._highLimitsCache[U],W=this._offsetsCache[U]}if(void 0===W)switch(y.dataType){case a.d.ANIMATIONTYPE_FLOAT:W=0;break;case a.d.ANIMATIONTYPE_QUATERNION:W=a.l;break;case a.d.ANIMATIONTYPE_VECTOR3:W=a.v;break;case a.d.ANIMATIONTYPE_VECTOR2:W=a.r;break;case a.d.ANIMATIONTYPE_SIZE:W=a.n;break;case a.d.ANIMATIONTYPE_COLOR3:W=a.g;break;case a.d.ANIMATIONTYPE_COLOR4:W=a.j}if(this._host&&this._host.syncRoot){const U=this._host.syncRoot;e=M+Z*((U.masterFrame-U.fromFrame)/(U.toFrame-U.fromFrame))}else e=O>0&&M>b||O<0&&M<b?x&&0!==Z?b+O%Z:M:x&&0!==Z?M+O%Z:b;if(!B&&(H>0&&this.currentFrame>e||H<0&&this.currentFrame<e)||B&&r){this._onLoop();for(let U=0;U<P.length;U++)P[U].onlyOnce||(P[U].isDone=!1);this._animationState.key=H>0?0:y.getKeys().length-1}this._currentFrame=e,this._animationState.repeatCount=0===Z?0:O/Z|0,this._animationState.highLimitValue=C,this._animationState.offsetValue=W}const C=y._interpolate(e,this._animationState);if(this.setValue(C,W),P.length)for(let a=0;a<P.length;a++)if(Z>=0&&e>=P[a].frame&&P[a].frame>=M||Z<0&&e<=P[a].frame&&P[a].frame<=M){const U=P[a];U.isDone||(U.onlyOnce&&(P.splice(a,1),a--),U.isDone=!0,U.action(e))}return x||(this._stopped=!0),x}}var x=b(503);class P{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(U){this._weight=-1!==U?Math.min(Math.max(U,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(U){for(let M=0;M<this._runtimeAnimations.length;M++){this._runtimeAnimations[M]._prepareForSpeedRatioChange(U)}this._speedRatio=U,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(U,M){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,H=arguments.length>4&&void 0!==arguments[4]&&arguments[4],W=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,y=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,e=arguments.length>8?arguments[8]:void 0,x=arguments.length>9&&void 0!==arguments[9]&&arguments[9],P=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=M,this.fromFrame=b,this.toFrame=a,this.loopAnimation=H,this.onAnimationEnd=y,this.onAnimationLoop=e,this.isAdditive=x,this.playOrder=P,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.ck=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new A.e,this.onAnimationLoopObservable=new A.e,this._scene=U,O&&this.appendAnimations(M,O),this._speedRatio=W,U._activeAnimatables.push(this)}syncWith(U){if(this._syncRoot=U,U){const U=this._scene._activeAnimatables.indexOf(this);U>-1&&(this._scene._activeAnimatables.splice(U,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(U,M){for(let b=0;b<M.length;b++){const a=M[b],A=new e(U,a,this._scene,this);A._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(A)}}getAnimationByTargetProperty(U){const M=this._runtimeAnimations;for(let b=0;b<M.length;b++)if(M[b].animation.targetProperty===U)return M[b].animation;return null}getRuntimeAnimationByTargetProperty(U){const M=this._runtimeAnimations;for(let b=0;b<M.length;b++)if(M[b].animation.targetProperty===U)return M[b];return null}reset(){const U=this._runtimeAnimations;for(let M=0;M<U.length;M++)U[M].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(U){const M=this._runtimeAnimations;for(let b=0;b<M.length;b++)M[b].animation.enableBlending=!0,M[b].animation.blendingSpeed=U}disableBlending(){const U=this._runtimeAnimations;for(let M=0;M<U.length;M++)U[M].animation.enableBlending=!1}goToFrame(U){let M=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._runtimeAnimations;if(b[0]){const M=b[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??b[0].currentFrame;const a=0===this.speedRatio?0:(U-this._frameToSyncFromJump)/M*1e3/this.speedRatio;this._manualJumpDelay=-a}for(let a=0;a<b.length;a++)b[a].goToFrame(U,M?this._weight:-1);this._goToFrame=U}get paused(){return this.ck}pause(){this.ck||(this.ck=!0)}restart(){this.ck=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(U,M){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(U||M){const A=this._scene._activeAnimatables.indexOf(this);if(A>-1){const H=this._runtimeAnimations;for(let b=H.length-1;b>=0;b--){const a=H[b];U&&a.animation.name!=U||(M&&!M(a.target)||(a.dispose(),H.splice(b,1)))}0==H.length&&(b||this._scene._activeAnimatables.splice(A,1),a||this._raiseOnAnimationEnd())}}else{const U=this._scene._activeAnimatables.indexOf(this);if(U>-1){b||this._scene._activeAnimatables.splice(U,1);const M=this._runtimeAnimations;for(let U=0;U<M.length;U++)M[U].dispose();this._runtimeAnimations.length=0,a||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((U=>{this.onAnimationEndObservable.add((()=>{U(this)}),void 0,void 0,this,!0)}))}_animate(U){if(this.ck)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=U),!0;if(null===this._localDelayOffset?(this._localDelayOffset=U,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=U-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let M=!1;const b=this._runtimeAnimations;let a;for(a=0;a<b.length;a++){const A=b[a].animate(U-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);M=M||A}if(this.animationStarted=M,!M){if(this.disposeOnEnd)for(a=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(a,1),a=0;a<b.length;a++)b[a].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return M}}function Z(U){if(0===U.totalWeight&&0===U.totalAdditiveWeight)return U.originalValue;let M=1;const b=O.g.lk[0],a=O.g.lk[1],A=O.g.Quaternion[0];let H=0;const W=U.animations[0],y=U.originalValue;let e=1,x=!1;if(U.totalWeight<1)e=1-U.totalWeight,y.decompose(a,A,b);else{if(H=1,M=U.totalWeight,e=W.weight/M,1==e){if(!U.totalAdditiveWeight)return W.currentValue;x=!0}W.currentValue.decompose(a,A,b)}if(!x){a.scaleInPlace(e),b.scaleInPlace(e),A.scaleInPlace(e);for(let W=H;W<U.animations.length;W++){const H=U.animations[W];if(0===H.weight)continue;e=H.weight/M;const y=O.g.lk[2],x=O.g.lk[3],P=O.g.Quaternion[1];H.currentValue.decompose(x,P,y),x.scaleAndAddToRef(e,a),P.scaleAndAddToRef(O.e.Dot(A,P)>0?e:-e,A),y.scaleAndAddToRef(e,b)}A.normalize()}for(let Z=0;Z<U.additiveAnimations.length;Z++){const M=U.additiveAnimations[Z];if(0===M.weight)continue;const H=O.g.lk[2],W=O.g.lk[3],y=O.g.Quaternion[1];M.currentValue.decompose(W,y,H),W.multiplyToRef(a,W),O.l.LerpToRef(a,W,M.weight,a),A.multiplyToRef(y,y),O.e.SlerpToRef(A,y,M.weight,A),H.scaleAndAddToRef(M.weight,b)}const P=W?W._animationState.workValue:O.g.Matrix[0].clone();return O.b.ComposeToRef(a,A,b,P),P}function C(U,M){if(0===U.totalWeight&&0===U.totalAdditiveWeight)return M;const b=U.animations[0],a=U.originalValue;let A=M;if(0===U.totalWeight&&U.totalAdditiveWeight>0)A.p(a);else if(1===U.animations.length){if(O.e.SlerpToRef(a,b.currentValue,Math.min(1,U.totalWeight),A),0===U.totalAdditiveWeight)return A}else if(U.animations.length>1){let b,H,W=1;if(U.totalWeight<1){const M=1-U.totalWeight;b=[],H=[],b.push(a),H.push(M)}else{if(2===U.animations.length&&(O.e.SlerpToRef(U.animations[0].currentValue,U.animations[1].currentValue,U.animations[1].weight/U.totalWeight,M),0===U.totalAdditiveWeight))return M;b=[],H=[],W=U.totalWeight}for(let M=0;M<U.animations.length;M++){const a=U.animations[M];b.push(a.currentValue),H.push(a.weight/W)}let y=0;for(let U=0;U<b.length;)U?(y+=H[U],O.e.SlerpToRef(A,b[U],H[U]/y,A),U++):(O.e.SlerpToRef(b[U],b[U+1],H[U+1]/(H[U]+H[U+1]),M),A=M,y=H[U]+H[U+1],U+=2)}for(let H=0;H<U.additiveAnimations.length;H++){const M=U.additiveAnimations[H];0!==M.weight&&(A.multiplyToRef(M.currentValue,O.g.Quaternion[0]),O.e.SlerpToRef(A,O.g.Quaternion[0],M.weight,A))}return A}var r,B,J=b(2492);r=J.b,(B=y.d)&&(B.prototype.copyAnimationRange=function(U,M,b){let A=arguments.length>3&&void 0!==arguments[3]&&arguments[3],H=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new a.d(this.name,"_matrix",U.animations[0].framePerSecond,a.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const W=U.animations[0].getRange(M);if(!W)return!1;const y=W.from,O=W.to,e=U.animations[0].getKeys(),x=U.length,P=U.getParent(),Z=this.getParent(),C=A&&P&&x&&this.length&&x!==this.length,r=C&&Z&&P?Z.length/P.length:1,B=A&&!Z&&H&&(1!==H.x||1!==H.y||1!==H.z),J=this.animations[0].getKeys();let F,f,L;for(let a=0,z=e.length;a<z;a++)F=e[a],F.frame>=y&&F.frame<=O&&(A?(L=F.value.clone(),C?(f=L.getTranslation(),L.setTranslation(f.scaleInPlace(r))):B&&H?(f=L.getTranslation(),L.setTranslation(f.multiplyInPlace(H))):L=F.value):L=F.value,J.push({frame:F.frame+b,value:L}));return this.animations[0].createRange(M,y+b,O+b),!0}),r&&(r.prototype._animate=function(U){if(!this.animationsEnabled)return;const M=x.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=M}this.deltaTime=void 0!==U?U:this.useConstantAnimationDeltaTime?16:(M-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=M;const b=this._activeAnimatables;if(0===b.length)return;this._animationTime+=this.deltaTime;const A=this._animationTime;for(let a=0;a<b.length;a++){const U=b[a];!U._animate(A)&&U.disposeOnEnd&&a--}!function(U){if(U._registeredForLateAnimationBindings.length){for(let M=0;M<U._registeredForLateAnimationBindings.length;M++){const b=U._registeredForLateAnimationBindings.data[M];for(const U in b._lateAnimationHolders){const M=b._lateAnimationHolders[U],A=M.animations[0],H=M.originalValue;if(void 0===H||null===H)continue;const W=a.d.AllowMatrixDecomposeForInterpolation&&H.m;let y=b[U];if(W)y=Z(M);else if(void 0!==H.w)y=C(M,y||O.e.Identity());else{let U=0,b=1;const W=A&&A._animationState.loopMode===a.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(M.totalWeight<1)y=W?H.clone?H.clone():H:A&&H.scale?H.scale(1-M.totalWeight):A?H*(1-M.totalWeight):H.clone?H.clone():H;else if(A){b=M.totalWeight;const a=A.weight/b;y=1!==a?A.currentValue.scale?A.currentValue.scale(a):A.currentValue*a:A.currentValue,W&&(y.addToRef?y.addToRef(H,y):y+=H),U=1}for(let a=U;a<M.animations.length;a++){const U=M.animations[a],A=U.weight/b;A&&(U.currentValue.scaleAndAddToRef?U.currentValue.scaleAndAddToRef(A,y):y+=U.currentValue*A)}for(let a=0;a<M.additiveAnimations.length;a++){const U=M.additiveAnimations[a],b=U.weight;b&&(U.currentValue.scaleAndAddToRef?U.currentValue.scaleAndAddToRef(b,y):y+=U.currentValue*b)}}b[U]=y}b._lateAnimationHolders={}}U._registeredForLateAnimationBindings.reset()}}(this)},r.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((U,M)=>U.playOrder-M.playOrder))},r.prototype.beginWeightedAnimation=function(U,M,b){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,A=arguments.length>4?arguments[4]:void 0,H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,W=arguments.length>6?arguments[6]:void 0,y=arguments.length>7?arguments[7]:void 0,O=arguments.length>8?arguments[8]:void 0,e=arguments.length>9?arguments[9]:void 0,x=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const P=this.beginAnimation(U,M,b,A,H,W,y,!1,O,e,x);return P.weight=a,P},r.prototype.beginAnimation=function(U,M,b,a){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,H=arguments.length>5?arguments[5]:void 0,W=arguments.length>6?arguments[6]:void 0,y=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],O=arguments.length>8?arguments[8]:void 0,e=arguments.length>9?arguments[9]:void 0,x=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(A<0){const U=M;M=b,b=U,A=-A}M>b&&(A=-A),y&&this.stopAnimation(U,void 0,O),W||(W=new P(this,U,M,b,a,A,H,void 0,e,x));const Z=!O||O(U);if(U.animations&&Z&&W.appendAnimations(U,U.animations),U.getAnimatables){const x=U.getAnimatables();for(let U=0;U<x.length;U++)this.beginAnimation(x[U],M,b,a,A,H,W,y,O,e)}return W.reset(),W},r.prototype.beginHierarchyAnimation=function(U,M,b,a,A){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,W=arguments.length>6?arguments[6]:void 0,y=arguments.length>7?arguments[7]:void 0,O=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],e=arguments.length>9?arguments[9]:void 0,x=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const P=U.getDescendants(M),Z=[];Z.push(this.beginAnimation(U,b,a,A,H,W,y,O,e,void 0,x));for(const C of P)Z.push(this.beginAnimation(C,b,a,A,H,W,y,O,e,void 0,x));return Z},r.prototype.beginDirectAnimation=function(U,M,b,a,A){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(H<0){const U=b;b=a,a=U,H=-H}return b>a&&(H=-H),new P(this,U,b,a,A,H,arguments.length>6?arguments[6]:void 0,M,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},r.prototype.beginDirectHierarchyAnimation=function(U,M,b,a,A,H,W,y,O){let e=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const x=U.getDescendants(M),P=[];P.push(this.beginDirectAnimation(U,b,a,A,H,W,y,O,e));for(const Z of x)P.push(this.beginDirectAnimation(Z,b,a,A,H,W,y,O,e));return P},r.prototype.getAnimatableByTarget=function(U){for(let M=0;M<this._activeAnimatables.length;M++)if(this._activeAnimatables[M].target===U)return this._activeAnimatables[M];return null},r.prototype.getAllAnimatablesByTarget=function(U){const M=[];for(let b=0;b<this._activeAnimatables.length;b++)this._activeAnimatables[b].target===U&&M.push(this._activeAnimatables[b]);return M},r.prototype.stopAnimation=function(U,M,b){const a=this.getAllAnimatablesByTarget(U);for(const A of a)A.stop(M,b)},r.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let U=0;U<this._activeAnimatables.length;U++)this._activeAnimatables[U].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const U of this.animationGroups)U.stop()});class F{getClassName(){return"TargetedAnimation"}serialize(){const U={};return U.animation=this.animation.serialize(),U.targetId=this.target.id,U}}class f{get mask(){return this._mask}set mask(U){this._mask!==U&&(this._mask=U,this.syncWithMask(!0))}syncWithMask(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||U){this._numActiveAnimatables=0;for(let U=0;U<this._animatables.length;++U){const M=this._animatables[U];!this.mask||this.mask.disabled||this.mask.retainsTarget(M.target.name)?(this._numActiveAnimatables++,M.paused&&M.restart()):M.paused||M.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let U=0;U<this._animatables.length;++U){const M=this._animatables[U];this.mask.retainsTarget(M.target.name)||(M.stop(),this._animatables.splice(U,1),--U)}for(let U=0;U<this._targetedAnimations.length;U++){const M=this._targetedAnimations[U];this.mask.retainsTarget(M.target.name)||(this._targetedAnimations.splice(U,1),--U)}}}get from(){return this._from}set from(U){if(this._from!==U){this._from=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].fromFrame=this._from}}}get to(){return this._to}set to(U){if(this._to!==U){this._to=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(U){if(this._speedRatio!==U){this._speedRatio=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(U){if(this._loopAnimation!==U){this._loopAnimation=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(U){if(this._isAdditive!==U){this._isAdditive=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(U){this._weight!==U&&(this._weight=U,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(U){if(this._playOrder!==U&&(this._playOrder=U,this._animatables.length>0)){for(let U=0;U<this._animatables.length;U++)this._animatables[U].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(U){if(this._enableBlending!==U&&(this._enableBlending=U,null!==U))for(let M=0;M<this._targetedAnimations.length;++M)this._targetedAnimations[M].animation.enableBlending=U}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(U){if(this._blendingSpeed!==U&&(this._blendingSpeed=U,null!==U))for(let M=0;M<this._targetedAnimations.length;++M)this._targetedAnimations[M].animation.blendingSpeed=U}getLength(U,M){U=U??this._from;return((M=M??this._to)-U)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(U){let M=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0;if(0===U.length)return null;a=a??U[0].weight;let A=Number.MAX_VALUE,H=-Number.MAX_VALUE;if(b)for(const y of U)y.from<A&&(A=y.from),y.to>H&&(H=y.to);const W=new f(U[0].name+"_merged",U[0]._scene,a);for(const y of U){b&&y.normalize(A,H);for(const U of y.targetedAnimations)W.addTargetedAnimation(U.animation,U.target);M&&y.dispose()}return W}constructor(U){let M=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=U,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new A.e,this.onAnimationLoopObservable=new A.e,this.onAnimationGroupLoopObservable=new A.e,this.onAnimationGroupEndObservable=new A.e,this.onAnimationGroupPauseObservable=new A.e,this.onAnimationGroupPlayObservable=new A.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=M||H.d.LastCreatedScene,this._weight=b,this._playOrder=a,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(U,M){const b=new F;b.animation=U,b.target=M;const a=U.getKeys();return this._from>a[0].frame&&(this._from=a[0].frame),this._to<a[a.length-1].frame&&(this._to=a[a.length-1].frame),null!==this._enableBlending&&(U.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(U.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(b),this._shouldStart=!0,b}removeTargetedAnimation(U){for(let M=this._targetedAnimations.length-1;M>-1;M--){this._targetedAnimations[M].animation===U&&this._targetedAnimations.splice(M,1)}}normalize(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,M=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==U&&(U=this._from),null==M&&(M=this._to);for(let b=0;b<this._targetedAnimations.length;b++){const a=this._targetedAnimations[b].animation.getKeys(),A=a[0],H=a[a.length-1];if(A.frame>U){const M={frame:U,value:A.value,inTangent:A.inTangent,outTangent:A.outTangent,interpolation:A.interpolation};a.splice(0,0,M)}if(H.frame<M){const U={frame:M,value:H.value,inTangent:H.inTangent,outTangent:H.outTangent,interpolation:H.interpolation};a.push(U)}}return this._from=U,this._to=M,this}_processLoop(U,M,b){U.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(M),this._animationLoopFlags[b]||(this._animationLoopFlags[b]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0],M=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,A=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=U,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let H=0;H<this._targetedAnimations.length;H++){const W=this._targetedAnimations[H],y=this._scene.beginDirectAnimation(W.target,[W.animation],void 0!==b?b:this._from,void 0!==a?a:this._to,U,M,void 0,void 0,void 0!==A?A:this._isAdditive);y.weight=this._weight,y.playOrder=this._playOrder,y.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(W),this._checkAnimationGroupEnded(y)},this._processLoop(y,W,H),this._animatables.push(y)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=M,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let U=0;U<this._animatables.length;U++){this._animatables[U].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(U){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==U&&(this.loopAnimation=U),this.restart()):(this.stop(),this.start(U,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let U=0;U<this._animatables.length;U++){this._animatables[U].reset()}return this}restart(){if(!this._isStarted)return this;for(let U=0;U<this._animatables.length;U++){this._animatables[U].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const M=this._animatables.slice();for(let a=0;a<M.length;a++)M[a].stop(void 0,void 0,!0,U);let b=0;for(let a=0;a<this._scene._activeAnimatables.length;a++){const M=this._scene._activeAnimatables[a];M._runtimeAnimations.length>0?this._scene._activeAnimatables[b++]=M:U&&this._checkAnimationGroupEnded(M,U)}return this._scene._activeAnimatables.length=b,this._isStarted=!1,this}setWeightForAllAnimatables(U){for(let M=0;M<this._animatables.length;M++){this._animatables[M].weight=U}return this}syncAllAnimationsWith(U){for(let M=0;M<this._animatables.length;M++){this._animatables[M].syncWith(U)}return this}goToFrame(U){let M=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].goToFrame(U,M)}return this}getCurrentFrame(){var U;return(null===(U=this.animatables[0])||void 0===U?void 0:U.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const U=this._scene.animationGroups.indexOf(this);if(U>-1&&this._scene.animationGroups.splice(U,1),this._parentContainer){const U=this._parentContainer.animationGroups.indexOf(this);U>-1&&this._parentContainer.animationGroups.splice(U,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(U){let M=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._animatables.indexOf(U);b>-1&&this._animatables.splice(b,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,M||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(U,M){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=new f(U||this.name,this._scene,this._weight,this._playOrder);a._from=this.from,a._to=this.to,a._speedRatio=this.speedRatio,a._loopAnimation=this.loopAnimation,a._isAdditive=this.isAdditive,a._enableBlending=this.enableBlending,a._blendingSpeed=this.blendingSpeed,a.metadata=this.metadata,a.mask=this.mask;for(const A of this._targetedAnimations)a.addTargetedAnimation(b?A.animation.clone():A.animation,M?M(A.target):A.target);return a}serialize(){const U={};U.name=this.name,U.from=this.from,U.to=this.to,U.speedRatio=this.speedRatio,U.loopAnimation=this.loopAnimation,U.isAdditive=this.isAdditive,U.weight=this.weight,U.playOrder=this.playOrder,U.enableBlending=this.enableBlending,U.blendingSpeed=this.blendingSpeed,U.targetedAnimations=[];for(let M=0;M<this.targetedAnimations.length;M++){const b=this.targetedAnimations[M];U.targetedAnimations[M]=b.serialize()}return W.d&&W.d.HasTags(this)&&(U.tags=W.d.GetTags(this)),this.metadata&&(U.metadata=this.metadata),U}static Parse(U,M){const b=new f(U.name,M,U.weight,U.playOrder);for(let A=0;A<U.targetedAnimations.length;A++){const H=U.targetedAnimations[A],W=a.d.Parse(H.animation),y=H.targetId;if("influence"===H.animation.property){const U=M.getMorphTargetById(y);U&&b.addTargetedAnimation(W,U)}else{const U=M.getNodeById(y);null!=U&&b.addTargetedAnimation(W,U)}}return W.d&&W.d.AddTagsTo(b,U.tags),null!==U.from&&null!==U.to&&b.normalize(U.from,U.to),void 0!==U.speedRatio&&(b._speedRatio=U.speedRatio),void 0!==U.loopAnimation&&(b._loopAnimation=U.loopAnimation),void 0!==U.isAdditive&&(b._isAdditive=U.isAdditive),void 0!==U.weight&&(b._weight=U.weight),void 0!==U.playOrder&&(b._playOrder=U.playOrder),void 0!==U.enableBlending&&(b._enableBlending=U.enableBlending),void 0!==U.blendingSpeed&&(b._blendingSpeed=U.blendingSpeed),void 0!==U.metadata&&(b.metadata=U.metadata),b}static MakeAnimationAdditive(U,M,b){let A;A="object"===typeof M?M:{referenceFrame:M,range:b,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let H=U;A.cloneOriginalAnimationGroup&&(H=U.clone(A.clonedAnimationGroupName||H.name));const W=H.targetedAnimations;for(let y=0;y<W.length;y++){const U=W[y];U.animation=a.d.MakeAnimationAdditive(U.animation,A)}if(H.isAdditive=!0,A.clipKeys){let U=Number.MAX_VALUE,M=-Number.MAX_VALUE;const b=H.targetedAnimations;for(let a=0;a<b.length;a++){const A=b[a].animation.getKeys();U>A[0].frame&&(U=A[0].frame),M<A[A.length-1].frame&&(M=A[A.length-1].frame)}H._from=U,H._to=M}return H}static ClipKeys(U,M,b,a,A){const H=U.clone(a||U.name);return f.ClipKeysInPlace(H,M,b,A)}static ClipKeysInPlace(U,M,b,a){return f.ClipInPlace(U,M,b,a,!1)}static ClipFrames(U,M,b,a,A){const H=U.clone(a||U.name);return f.ClipFramesInPlace(H,M,b,A)}static ClipFramesInPlace(U,M,b,a){return f.ClipInPlace(U,M,b,a,!0)}static ClipInPlace(U,M,b,a){let A=arguments.length>4&&void 0!==arguments[4]&&arguments[4],H=Number.MAX_VALUE,W=-Number.MAX_VALUE;const y=U.targetedAnimations;for(let O=0;O<y.length;O++){const U=y[O],e=a?U.animation:U.animation.clone();A&&(e.createKeyForFrame(M),e.createKeyForFrame(b));const x=e.getKeys(),P=[];let Z=Number.MAX_VALUE;for(let a=0;a<x.length;a++){const U=x[a];if(!A&&a>=M&&a<=b||A&&U.frame>=M&&U.frame<=b){const M={frame:U.frame,value:U.value.clone?U.value.clone():U.value,inTangent:U.inTangent,outTangent:U.outTangent,interpolation:U.interpolation,lockedTangent:U.lockedTangent};Z===Number.MAX_VALUE&&(Z=M.frame),M.frame-=Z,P.push(M)}}0!==P.length?(H>P[0].frame&&(H=P[0].frame),W<P[P.length-1].frame&&(W=P[P.length-1].frame),e.setKeys(P,!0),U.animation=e):(y.splice(O,1),O--)}return U._from=H,U._to=W,U}getClassName(){return"AnimationGroup"}toString(U){let M="Name: "+this.name;return M+=", type: "+this.getClassName(),U&&(M+=", from: "+this._from,M+=", to: "+this._to,M+=", isStarted: "+this._isStarted,M+=", speedRatio: "+this._speedRatio,M+=", targetedAnimations length: "+this._targetedAnimations.length,M+=", animatables length: "+this._animatables),M}}}}]);