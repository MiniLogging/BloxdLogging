"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[49],{13837:(m,S,h)=>{h.r(S),h.d(S,{_HDRTextureLoader:()=>V});var l=h(11347);class M{static ConvertPanoramaToCubemap(m,S,h,l){let M=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!m)throw"ConvertPanoramaToCubemap: input cannot be null";if(m.length!=S*h*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(l,this.FACE_FRONT,m,S,h,M),back:this.CreateCubemapTexture(l,this.FACE_BACK,m,S,h,M),left:this.CreateCubemapTexture(l,this.FACE_LEFT,m,S,h,M),right:this.CreateCubemapTexture(l,this.FACE_RIGHT,m,S,h,M),up:this.CreateCubemapTexture(l,this.FACE_UP,m,S,h,M),down:this.CreateCubemapTexture(l,this.FACE_DOWN,m,S,h,M),size:l,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(m,S,h,l,M){let O=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const u=new ArrayBuffer(m*m*4*3),b=new Float32Array(u),q=O?Math.max(1,Math.round(l/4/m)):1,Y=1/q,V=Y*Y,I=S[1].LS(S[0]).scale(Y/m),Z=S[3].LS(S[2]).scale(Y/m),C=1/m;let B=0;for(let D=0;D<m;D++)for(let O=0;O<q;O++){let O=S[0],u=S[2];for(let S=0;S<m;S++)for(let Y=0;Y<q;Y++){const q=u.LS(O).scale(B).add(O);q.normalize();const Y=this.CalcProjectionSpherical(q,h,l,M);b[D*m*3+3*S+0]+=Y.r*V,b[D*m*3+3*S+1]+=Y.g*V,b[D*m*3+3*S+2]+=Y.b*V,O=O.add(I),u=u.add(Z)}B+=C*Y}return b}static CalcProjectionSpherical(m,S,h,l){let M=Math.atan2(m.z,m.x);const O=Math.acos(m.y);for(;M<-Math.PI;)M+=2*Math.PI;for(;M>Math.PI;)M-=2*Math.PI;let u=M/Math.PI;const b=O/Math.PI;u=.5*u+.5;let q=Math.round(u*h);q<0?q=0:q>=h&&(q=h-1);let Y=Math.round(b*l);Y<0?Y=0:Y>=l&&(Y=l-1);const V=l-Y-1;return{r:S[V*h*3+3*q+0],g:S[V*h*3+3*q+1],b:S[V*h*3+3*q+2]}}}function O(m,S,h,l,M,O){M>0?(M=function(m,S){return S>1023?m*Math.pow(2,1023)*Math.pow(2,S-1023):S<-1074?m*Math.pow(2,-1074)*Math.pow(2,S+1074):m*Math.pow(2,S)}(1,M-136),m[O+0]=S*M,m[O+1]=h*M,m[O+2]=l*M):(m[O+0]=0,m[O+1]=0,m[O+2]=0)}function u(m,S){let h="",l="";for(let M=S;M<m.length-S&&(l=String.fromCharCode(m[M]),"\n"!=l);M++)h+=l;return h}function b(m){let S=0,h=0,l=u(m,0);if("#"!=l[0]||"?"!=l[1])throw"Bad HDR Format.";let M=!1,O=!1,b=0;do{b+=l.length+1,l=u(m,b),"FORMAT=32-bit_rle_rgbe"==l?O=!0:0==l.length&&(M=!0)}while(!M);if(!O)throw"HDR Bad header format, unsupported FORMAT";b+=l.length+1,l=u(m,b);const q=/^-Y (.*) \+X (.*)$/g.exec(l);if(!q||q.length<3)throw"HDR Bad header format, no size";if(h=parseInt(q[2]),S=parseInt(q[1]),h<8||h>32767)throw"HDR Bad header format, unsupported size";return b+=l.length+1,{height:S,width:h,dataPosition:b}}function q(m,S){return function(m,S){let h=S.height;const l=S.width;let M,u,b,q,V,I=S.dataPosition,Z=0,C=0,B=0;const D=new ArrayBuffer(4*l),E=new Uint8Array(D),n=new ArrayBuffer(S.width*S.height*4*3),L=new Float32Array(n);for(;h>0;){if(M=m[I++],u=m[I++],b=m[I++],q=m[I++],2!=M||2!=u||128&b||S.width<8||S.width>32767)return Y(m,S);if((b<<8|q)!=l)throw"HDR Bad header format, wrong scan line width";for(Z=0,B=0;B<4;B++)for(C=(B+1)*l;Z<C;)if(M=m[I++],u=m[I++],M>128){if(V=M-128,0==V||V>C-Z)throw"HDR Bad Format, bad scanline data (run)";for(;V-- >0;)E[Z++]=u}else{if(V=M,0==V||V>C-Z)throw"HDR Bad Format, bad scanline data (non-run)";if(E[Z++]=u,--V>0)for(let S=0;S<V;S++)E[Z++]=m[I++]}for(B=0;B<l;B++)M=E[B],u=E[B+l],b=E[B+2*l],q=E[B+3*l],O(L,M,u,b,q,(S.height-h)*l*3+3*B);h--}return L}(m,S)}function Y(m,S){let h=S.height;const l=S.width;let M,u,b,q,Y,V=S.dataPosition;const I=new ArrayBuffer(S.width*S.height*4*3),Z=new Float32Array(I);for(;h>0;){for(Y=0;Y<S.width;Y++)M=m[V++],u=m[V++],b=m[V++],q=m[V++],O(Z,M,u,b,q,(S.height-h)*l*3+3*Y);h--}return Z}M.FACE_LEFT=[new l.nS(-1,-1,-1),new l.nS(1,-1,-1),new l.nS(-1,1,-1),new l.nS(1,1,-1)],M.FACE_RIGHT=[new l.nS(1,-1,1),new l.nS(-1,-1,1),new l.nS(1,1,1),new l.nS(-1,1,1)],M.FACE_FRONT=[new l.nS(1,-1,-1),new l.nS(1,-1,1),new l.nS(1,1,-1),new l.nS(1,1,1)],M.FACE_BACK=[new l.nS(-1,-1,1),new l.nS(-1,-1,-1),new l.nS(-1,1,1),new l.nS(-1,1,-1)],M.FACE_DOWN=[new l.nS(1,1,-1),new l.nS(1,1,1),new l.nS(-1,1,-1),new l.nS(-1,1,1)],M.FACE_UP=[new l.nS(-1,-1,-1),new l.nS(-1,-1,1),new l.nS(1,-1,-1),new l.nS(1,-1,1)];class V{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(m,S,h){const l=new Uint8Array(m.buffer,m.byteOffset,m.byteLength),M=b(l),O=q(l,M),u=M.width*M.height,Y=new Float32Array(4*u);for(let b=0;b<u;b+=1)Y[4*b]=O[3*b],Y[4*b+1]=O[3*b+1],Y[4*b+2]=O[3*b+2],Y[4*b+3]=1;h(M.width,M.height,S.generateMipMaps,!1,(()=>{const m=S.getEngine();S.type=1,S.format=5,S._gammaSpace=!1,m._uploadDataToTextureDirectly(S,Y)}))}}}}]);