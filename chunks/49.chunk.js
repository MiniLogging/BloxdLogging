"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13689:(o,H,n)=>{n.r(H),n.d(H,{_HDRTextureLoader:()=>G});var E=n(11189);class k{static ConvertPanoramaToCubemap(o,H,n,E){let k=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!o)throw"ConvertPanoramaToCubemap: input cannot be null";if(o.length!=H*n*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(E,this.FACE_FRONT,o,H,n,k),back:this.CreateCubemapTexture(E,this.FACE_BACK,o,H,n,k),left:this.CreateCubemapTexture(E,this.FACE_LEFT,o,H,n,k),right:this.CreateCubemapTexture(E,this.FACE_RIGHT,o,H,n,k),up:this.CreateCubemapTexture(E,this.FACE_UP,o,H,n,k),down:this.CreateCubemapTexture(E,this.FACE_DOWN,o,H,n,k),size:E,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(o,H,n,E,k){let g=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const O=new ArrayBuffer(o*o*4*3),Y=new Float32Array(O),y=g?Math.max(1,Math.round(E/4/o)):1,S=1/y,G=S*S,c=H[1].zH(H[0]).scale(S/o),A=H[3].zH(H[2]).scale(S/o),l=1/o;let x=0;for(let z=0;z<o;z++)for(let g=0;g<y;g++){let g=H[0],O=H[2];for(let H=0;H<o;H++)for(let S=0;S<y;S++){const y=O.zH(g).scale(x).add(g);y.normalize();const S=this.CalcProjectionSpherical(y,n,E,k);Y[z*o*3+3*H+0]+=S.r*G,Y[z*o*3+3*H+1]+=S.g*G,Y[z*o*3+3*H+2]+=S.b*G,g=g.add(c),O=O.add(A)}x+=l*S}return Y}static CalcProjectionSpherical(o,H,n,E){let k=Math.atan2(o.z,o.x);const g=Math.acos(o.y);for(;k<-Math.PI;)k+=2*Math.PI;for(;k>Math.PI;)k-=2*Math.PI;let O=k/Math.PI;const Y=g/Math.PI;O=.5*O+.5;let y=Math.round(O*n);y<0?y=0:y>=n&&(y=n-1);let S=Math.round(Y*E);S<0?S=0:S>=E&&(S=E-1);const G=E-S-1;return{r:H[G*n*3+3*y+0],g:H[G*n*3+3*y+1],b:H[G*n*3+3*y+2]}}}function g(o,H,n,E,k,g){k>0?(k=function(o,H){return H>1023?o*Math.pow(2,1023)*Math.pow(2,H-1023):H<-1074?o*Math.pow(2,-1074)*Math.pow(2,H+1074):o*Math.pow(2,H)}(1,k-136),o[g+0]=H*k,o[g+1]=n*k,o[g+2]=E*k):(o[g+0]=0,o[g+1]=0,o[g+2]=0)}function O(o,H){let n="",E="";for(let k=H;k<o.length-H&&(E=String.fromCharCode(o[k]),"\n"!=E);k++)n+=E;return n}function Y(o){let H=0,n=0,E=O(o,0);if("#"!=E[0]||"?"!=E[1])throw"Bad HDR Format.";let k=!1,g=!1,Y=0;do{Y+=E.length+1,E=O(o,Y),"FORMAT=32-bit_rle_rgbe"==E?g=!0:0==E.length&&(k=!0)}while(!k);if(!g)throw"HDR Bad header format, unsupported FORMAT";Y+=E.length+1,E=O(o,Y);const y=/^-Y (.*) \+X (.*)$/g.exec(E);if(!y||y.length<3)throw"HDR Bad header format, no size";if(n=parseInt(y[2]),H=parseInt(y[1]),n<8||n>32767)throw"HDR Bad header format, unsupported size";return Y+=E.length+1,{height:H,width:n,dataPosition:Y}}function y(o,H){return function(o,H){let n=H.height;const E=H.width;let k,O,Y,y,G,c=H.dataPosition,A=0,l=0,x=0;const z=new ArrayBuffer(4*E),V=new Uint8Array(z),J=new ArrayBuffer(H.width*H.height*4*3),N=new Float32Array(J);for(;n>0;){if(k=o[c++],O=o[c++],Y=o[c++],y=o[c++],2!=k||2!=O||128&Y||H.width<8||H.width>32767)return S(o,H);if((Y<<8|y)!=E)throw"HDR Bad header format, wrong scan line width";for(A=0,x=0;x<4;x++)for(l=(x+1)*E;A<l;)if(k=o[c++],O=o[c++],k>128){if(G=k-128,0==G||G>l-A)throw"HDR Bad Format, bad scanline data (run)";for(;G-- >0;)V[A++]=O}else{if(G=k,0==G||G>l-A)throw"HDR Bad Format, bad scanline data (non-run)";if(V[A++]=O,--G>0)for(let H=0;H<G;H++)V[A++]=o[c++]}for(x=0;x<E;x++)k=V[x],O=V[x+E],Y=V[x+2*E],y=V[x+3*E],g(N,k,O,Y,y,(H.height-n)*E*3+3*x);n--}return N}(o,H)}function S(o,H){let n=H.height;const E=H.width;let k,O,Y,y,S,G=H.dataPosition;const c=new ArrayBuffer(H.width*H.height*4*3),A=new Float32Array(c);for(;n>0;){for(S=0;S<H.width;S++)k=o[G++],O=o[G++],Y=o[G++],y=o[G++],g(A,k,O,Y,y,(H.height-n)*E*3+3*S);n--}return A}k.FACE_LEFT=[new E.xH(-1,-1,-1),new E.xH(1,-1,-1),new E.xH(-1,1,-1),new E.xH(1,1,-1)],k.FACE_RIGHT=[new E.xH(1,-1,1),new E.xH(-1,-1,1),new E.xH(1,1,1),new E.xH(-1,1,1)],k.FACE_FRONT=[new E.xH(1,-1,-1),new E.xH(1,-1,1),new E.xH(1,1,-1),new E.xH(1,1,1)],k.FACE_BACK=[new E.xH(-1,-1,1),new E.xH(-1,-1,-1),new E.xH(-1,1,1),new E.xH(-1,1,-1)],k.FACE_DOWN=[new E.xH(1,1,-1),new E.xH(1,1,1),new E.xH(-1,1,-1),new E.xH(-1,1,1)],k.FACE_UP=[new E.xH(-1,-1,-1),new E.xH(-1,-1,1),new E.xH(1,-1,-1),new E.xH(1,-1,1)];class G{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(o,H,n){const E=new Uint8Array(o.buffer,o.byteOffset,o.byteLength),k=Y(E),g=y(E,k),O=k.width*k.height,S=new Float32Array(4*O);for(let Y=0;Y<O;Y+=1)S[4*Y]=g[3*Y],S[4*Y+1]=g[3*Y+1],S[4*Y+2]=g[3*Y+2],S[4*Y+3]=1;n(k.width,k.height,H.generateMipMaps,!1,(()=>{const o=H.getEngine();H.type=1,H.format=5,H._gammaSpace=!1,o._uploadDataToTextureDirectly(H,S)}))}}}}]);