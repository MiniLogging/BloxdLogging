"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[49],{14921:(u,R,I)=>{I.r(R),I.d(R,{_HDRTextureLoader:()=>G});var B=I(12481);class U{static ConvertPanoramaToCubemap(u,R,I,B){let U=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!u)throw"ConvertPanoramaToCubemap: input cannot be null";if(u.length!=R*I*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(B,this.FACE_FRONT,u,R,I,U),back:this.CreateCubemapTexture(B,this.FACE_BACK,u,R,I,U),left:this.CreateCubemapTexture(B,this.FACE_LEFT,u,R,I,U),right:this.CreateCubemapTexture(B,this.FACE_RIGHT,u,R,I,U),up:this.CreateCubemapTexture(B,this.FACE_UP,u,R,I,U),down:this.CreateCubemapTexture(B,this.FACE_DOWN,u,R,I,U),size:B,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(u,R,I,B,U){let K=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const C=new ArrayBuffer(u*u*4*3),D=new Float32Array(C),s=K?Math.max(1,Math.round(B/4/u)):1,t=1/s,G=t*t,S=R[1].XR(R[0]).scale(t/u),b=R[3].XR(R[2]).scale(t/u),r=1/u;let P=0;for(let X=0;X<u;X++)for(let K=0;K<s;K++){let K=R[0],C=R[2];for(let R=0;R<u;R++)for(let t=0;t<s;t++){const s=C.XR(K).scale(P).add(K);s.normalize();const t=this.CalcProjectionSpherical(s,I,B,U);D[X*u*3+3*R+0]+=t.r*G,D[X*u*3+3*R+1]+=t.g*G,D[X*u*3+3*R+2]+=t.b*G,K=K.add(S),C=C.add(b)}P+=r*t}return D}static CalcProjectionSpherical(u,R,I,B){let U=Math.atan2(u.z,u.x);const K=Math.acos(u.y);for(;U<-Math.PI;)U+=2*Math.PI;for(;U>Math.PI;)U-=2*Math.PI;let C=U/Math.PI;const D=K/Math.PI;C=.5*C+.5;let s=Math.round(C*I);s<0?s=0:s>=I&&(s=I-1);let t=Math.round(D*B);t<0?t=0:t>=B&&(t=B-1);const G=B-t-1;return{r:R[G*I*3+3*s+0],g:R[G*I*3+3*s+1],b:R[G*I*3+3*s+2]}}}function K(u,R,I,B,U,K){U>0?(U=function(u,R){return R>1023?u*Math.pow(2,1023)*Math.pow(2,R-1023):R<-1074?u*Math.pow(2,-1074)*Math.pow(2,R+1074):u*Math.pow(2,R)}(1,U-136),u[K+0]=R*U,u[K+1]=I*U,u[K+2]=B*U):(u[K+0]=0,u[K+1]=0,u[K+2]=0)}function C(u,R){let I="",B="";for(let U=R;U<u.length-R&&(B=String.fromCharCode(u[U]),"\n"!=B);U++)I+=B;return I}function D(u){let R=0,I=0,B=C(u,0);if("#"!=B[0]||"?"!=B[1])throw"Bad HDR Format.";let U=!1,K=!1,D=0;do{D+=B.length+1,B=C(u,D),"FORMAT=32-bit_rle_rgbe"==B?K=!0:0==B.length&&(U=!0)}while(!U);if(!K)throw"HDR Bad header format, unsupported FORMAT";D+=B.length+1,B=C(u,D);const s=/^-Y (.*) \+X (.*)$/g.exec(B);if(!s||s.length<3)throw"HDR Bad header format, no size";if(I=parseInt(s[2]),R=parseInt(s[1]),I<8||I>32767)throw"HDR Bad header format, unsupported size";return D+=B.length+1,{height:R,width:I,dataPosition:D}}function s(u,R){return function(u,R){let I=R.height;const B=R.width;let U,C,D,s,G,S=R.dataPosition,b=0,r=0,P=0;const X=new ArrayBuffer(4*B),E=new Uint8Array(X),z=new ArrayBuffer(R.width*R.height*4*3),f=new Float32Array(z);for(;I>0;){if(U=u[S++],C=u[S++],D=u[S++],s=u[S++],2!=U||2!=C||128&D||R.width<8||R.width>32767)return t(u,R);if((D<<8|s)!=B)throw"HDR Bad header format, wrong scan line width";for(b=0,P=0;P<4;P++)for(r=(P+1)*B;b<r;)if(U=u[S++],C=u[S++],U>128){if(G=U-128,0==G||G>r-b)throw"HDR Bad Format, bad scanline data (run)";for(;G-- >0;)E[b++]=C}else{if(G=U,0==G||G>r-b)throw"HDR Bad Format, bad scanline data (non-run)";if(E[b++]=C,--G>0)for(let R=0;R<G;R++)E[b++]=u[S++]}for(P=0;P<B;P++)U=E[P],C=E[P+B],D=E[P+2*B],s=E[P+3*B],K(f,U,C,D,s,(R.height-I)*B*3+3*P);I--}return f}(u,R)}function t(u,R){let I=R.height;const B=R.width;let U,C,D,s,t,G=R.dataPosition;const S=new ArrayBuffer(R.width*R.height*4*3),b=new Float32Array(S);for(;I>0;){for(t=0;t<R.width;t++)U=u[G++],C=u[G++],D=u[G++],s=u[G++],K(b,U,C,D,s,(R.height-I)*B*3+3*t);I--}return b}U.FACE_LEFT=[new B.PR(-1,-1,-1),new B.PR(1,-1,-1),new B.PR(-1,1,-1),new B.PR(1,1,-1)],U.FACE_RIGHT=[new B.PR(1,-1,1),new B.PR(-1,-1,1),new B.PR(1,1,1),new B.PR(-1,1,1)],U.FACE_FRONT=[new B.PR(1,-1,-1),new B.PR(1,-1,1),new B.PR(1,1,-1),new B.PR(1,1,1)],U.FACE_BACK=[new B.PR(-1,-1,1),new B.PR(-1,-1,-1),new B.PR(-1,1,1),new B.PR(-1,1,-1)],U.FACE_DOWN=[new B.PR(1,1,-1),new B.PR(1,1,1),new B.PR(-1,1,-1),new B.PR(-1,1,1)],U.FACE_UP=[new B.PR(-1,-1,-1),new B.PR(-1,-1,1),new B.PR(1,-1,-1),new B.PR(1,-1,1)];class G{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(u,R,I){const B=new Uint8Array(u.buffer,u.byteOffset,u.byteLength),U=D(B),K=s(B,U),C=U.width*U.height,t=new Float32Array(4*C);for(let D=0;D<C;D+=1)t[4*D]=K[3*D],t[4*D+1]=K[3*D+1],t[4*D+2]=K[3*D+2],t[4*D+3]=1;I(U.width,U.height,R.generateMipMaps,!1,(()=>{const u=R.getEngine();R.type=1,R.format=5,R._gammaSpace=!1,u._uploadDataToTextureDirectly(R,t)}))}}}}]);