"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[49],{14921:(U,G,C)=>{C.r(G),C.d(G,{_HDRTextureLoader:()=>O});var L=C(12896);class X{static ConvertPanoramaToCubemap(U,G,C,L){let X=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!U)throw"ConvertPanoramaToCubemap: input cannot be null";if(U.length!=G*C*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(L,this.FACE_FRONT,U,G,C,X),back:this.CreateCubemapTexture(L,this.FACE_BACK,U,G,C,X),left:this.CreateCubemapTexture(L,this.FACE_LEFT,U,G,C,X),right:this.CreateCubemapTexture(L,this.FACE_RIGHT,U,G,C,X),up:this.CreateCubemapTexture(L,this.FACE_UP,U,G,C,X),down:this.CreateCubemapTexture(L,this.FACE_DOWN,U,G,C,X),size:L,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(U,G,C,L,X){let l=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const t=new ArrayBuffer(U*U*4*3),E=new Float32Array(t),K=l?Math.max(1,Math.round(L/4/U)):1,P=1/K,O=P*P,T=G[1].IG(G[0]).scale(P/U),D=G[3].IG(G[2]).scale(P/U),y=1/U;let V=0;for(let p=0;p<U;p++)for(let l=0;l<K;l++){let l=G[0],t=G[2];for(let G=0;G<U;G++)for(let P=0;P<K;P++){const K=t.IG(l).scale(V).add(l);K.normalize();const P=this.CalcProjectionSpherical(K,C,L,X);E[p*U*3+3*G+0]+=P.r*O,E[p*U*3+3*G+1]+=P.g*O,E[p*U*3+3*G+2]+=P.b*O,l=l.add(T),t=t.add(D)}V+=y*P}return E}static CalcProjectionSpherical(U,G,C,L){let X=Math.atan2(U.z,U.x);const l=Math.acos(U.y);for(;X<-Math.PI;)X+=2*Math.PI;for(;X>Math.PI;)X-=2*Math.PI;let t=X/Math.PI;const E=l/Math.PI;t=.5*t+.5;let K=Math.round(t*C);K<0?K=0:K>=C&&(K=C-1);let P=Math.round(E*L);P<0?P=0:P>=L&&(P=L-1);const O=L-P-1;return{r:G[O*C*3+3*K+0],g:G[O*C*3+3*K+1],b:G[O*C*3+3*K+2]}}}function l(U,G,C,L,X,l){X>0?(X=function(U,G){return G>1023?U*Math.pow(2,1023)*Math.pow(2,G-1023):G<-1074?U*Math.pow(2,-1074)*Math.pow(2,G+1074):U*Math.pow(2,G)}(1,X-136),U[l+0]=G*X,U[l+1]=C*X,U[l+2]=L*X):(U[l+0]=0,U[l+1]=0,U[l+2]=0)}function t(U,G){let C="",L="";for(let X=G;X<U.length-G&&(L=String.fromCharCode(U[X]),"\n"!=L);X++)C+=L;return C}function E(U){let G=0,C=0,L=t(U,0);if("#"!=L[0]||"?"!=L[1])throw"Bad HDR Format.";let X=!1,l=!1,E=0;do{E+=L.length+1,L=t(U,E),"FORMAT=32-bit_rle_rgbe"==L?l=!0:0==L.length&&(X=!0)}while(!X);if(!l)throw"HDR Bad header format, unsupported FORMAT";E+=L.length+1,L=t(U,E);const K=/^-Y (.*) \+X (.*)$/g.exec(L);if(!K||K.length<3)throw"HDR Bad header format, no size";if(C=parseInt(K[2]),G=parseInt(K[1]),C<8||C>32767)throw"HDR Bad header format, unsupported size";return E+=L.length+1,{height:G,width:C,dataPosition:E}}function K(U,G){return function(U,G){let C=G.height;const L=G.width;let X,t,E,K,O,T=G.dataPosition,D=0,y=0,V=0;const p=new ArrayBuffer(4*L),I=new Uint8Array(p),H=new ArrayBuffer(G.width*G.height*4*3),x=new Float32Array(H);for(;C>0;){if(X=U[T++],t=U[T++],E=U[T++],K=U[T++],2!=X||2!=t||128&E||G.width<8||G.width>32767)return P(U,G);if((E<<8|K)!=L)throw"HDR Bad header format, wrong scan line width";for(D=0,V=0;V<4;V++)for(y=(V+1)*L;D<y;)if(X=U[T++],t=U[T++],X>128){if(O=X-128,0==O||O>y-D)throw"HDR Bad Format, bad scanline data (run)";for(;O-- >0;)I[D++]=t}else{if(O=X,0==O||O>y-D)throw"HDR Bad Format, bad scanline data (non-run)";if(I[D++]=t,--O>0)for(let G=0;G<O;G++)I[D++]=U[T++]}for(V=0;V<L;V++)X=I[V],t=I[V+L],E=I[V+2*L],K=I[V+3*L],l(x,X,t,E,K,(G.height-C)*L*3+3*V);C--}return x}(U,G)}function P(U,G){let C=G.height;const L=G.width;let X,t,E,K,P,O=G.dataPosition;const T=new ArrayBuffer(G.width*G.height*4*3),D=new Float32Array(T);for(;C>0;){for(P=0;P<G.width;P++)X=U[O++],t=U[O++],E=U[O++],K=U[O++],l(D,X,t,E,K,(G.height-C)*L*3+3*P);C--}return D}X.FACE_LEFT=[new L.pG(-1,-1,-1),new L.pG(1,-1,-1),new L.pG(-1,1,-1),new L.pG(1,1,-1)],X.FACE_RIGHT=[new L.pG(1,-1,1),new L.pG(-1,-1,1),new L.pG(1,1,1),new L.pG(-1,1,1)],X.FACE_FRONT=[new L.pG(1,-1,-1),new L.pG(1,-1,1),new L.pG(1,1,-1),new L.pG(1,1,1)],X.FACE_BACK=[new L.pG(-1,-1,1),new L.pG(-1,-1,-1),new L.pG(-1,1,1),new L.pG(-1,1,-1)],X.FACE_DOWN=[new L.pG(1,1,-1),new L.pG(1,1,1),new L.pG(-1,1,-1),new L.pG(-1,1,1)],X.FACE_UP=[new L.pG(-1,-1,-1),new L.pG(-1,-1,1),new L.pG(1,-1,-1),new L.pG(1,-1,1)];class O{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(U,G,C){const L=new Uint8Array(U.buffer,U.byteOffset,U.byteLength),X=E(L),l=K(L,X),t=X.width*X.height,P=new Float32Array(4*t);for(let E=0;E<t;E+=1)P[4*E]=l[3*E],P[4*E+1]=l[3*E+1],P[4*E+2]=l[3*E+2],P[4*E+3]=1;C(X.width,X.height,G.generateMipMaps,!1,(()=>{const U=G.getEngine();G.type=1,G.format=5,G._gammaSpace=!1,U._uploadDataToTextureDirectly(G,P)}))}}}}]);