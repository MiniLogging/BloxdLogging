"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[49],{13729:(J,T,b)=>{b.r(T),b.d(T,{AnimationGroup:()=>U,TargetedAnimation:()=>u});var q=b(12484),t=b(497),j=b(550),B=b(654),Y=b(12482),C=b(697);class F{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(J,T,b,t){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=T,this._target=J,this._scene=b,this._host=t,this._activeTargets=[],T._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===q.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=C.e.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const J={frame:0,value:this._minValue};this._keys.splice(0,0,J)}if(this._target instanceof Array){let J=0;for(const T of this._target)this._preparePath(T,J),this._getOriginalValues(J),J++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const j=T.getEvents();if(j&&j.length>0)for(const q of j)this._events.push(q._clone());this._enableBlending=J&&J.animationPropertiesOverride?J.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(J){let T=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=this._animation.targetPropertyPath;if(b.length>1){let q=J;for(let J=0;J<b.length-1;J++){const T=b[J];if(q=q[T],void 0===q)throw new Error(`Invalid property (${T}) in property path (${b.join(".")})`)}this._targetPath=b[b.length-1],this._activeTargets[T]=q}else this._targetPath=b[0],this._activeTargets[T]=J;if(void 0===this._activeTargets[T][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${b.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let J=0;for(const T of this._target)void 0!==this._originalValue[J]&&this._setValue(T,this._activeTargets[J],this._originalValue[J],-1,J),J++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let J=0;J<this._events.length;J++)this._events[J].isDone=!1}isStopped(){return this._stopped}dispose(){const J=this._animation.runtimeAnimations.indexOf(this);J>-1&&this._animation.runtimeAnimations.splice(J,1)}setValue(J,T){if(this._targetIsArray)for(let b=0;b<this._target.length;b++){const q=this._target[b];this._setValue(q,this._activeTargets[b],J,T,b)}else this._setValue(this._target,this._directTarget,J,T,0)}_getOriginalValues(){let J,T=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=this._activeTargets[T];J=b.getLocalMatrix&&"_matrix"===this._targetPath?b.getLocalMatrix():b[this._targetPath],J&&J.clone?this._originalValue[T]=J.clone():this._originalValue[T]=J}_registerTargetForLateAnimationBinding(J,T){const b=J.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(b),b._lateAnimationHolders||(b._lateAnimationHolders={}),b._lateAnimationHolders[J.targetPath]||(b._lateAnimationHolders[J.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:T}),J.isAdditive?(b._lateAnimationHolders[J.targetPath].additiveAnimations.push(J),b._lateAnimationHolders[J.targetPath].totalAdditiveWeight+=J.weight):(b._lateAnimationHolders[J.targetPath].animations.push(J),b._lateAnimationHolders[J.targetPath].totalWeight+=J.weight)}_setValue(J,T,b,t,j){if(this._currentActiveTarget=T,this._weight=t,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const J=T[this._targetPath];J.clone?this._originalBlendValue=J.clone():this._originalBlendValue=J}this._originalBlendValue.m?q.b.AllowMatrixDecomposeForInterpolation?this._currentValue?C.e.DecomposeLerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=C.e.DecomposeLerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue?C.e.LerpToRef(this._originalBlendValue,b,this._blendingFactor,this._currentValue):this._currentValue=C.e.Lerp(this._originalBlendValue,b,this._blendingFactor):this._currentValue=q.b._UniversalLerp(this._originalBlendValue,b,this._blendingFactor);const t=J&&J.animationPropertiesOverride?J.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=t}else this._currentValue?this._currentValue.p?this._currentValue.p(b):this._currentValue=b:null!==b&&void 0!==b&&b.clone?this._currentValue=b.clone():this._currentValue=b;-1!==t?this._registerTargetForLateAnimationBinding(this,this._originalValue[j]):this._animationState.loopMode===q.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[j],T[this._targetPath]):T[this._targetPath]=this._originalValue[j]+this._currentValue:T[this._targetPath]=this._currentValue,J.Pi&&J.Pi(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(J){let T=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const b=this._animation.getKeys();J<b[0].frame?J=b[0].frame:J>b[b.length-1].frame&&(J=b[b.length-1].frame);const q=this._events;if(q.length)for(let j=0;j<q.length;j++)q[j].onlyOnce||(q[j].isDone=q[j].frame<J);this._currentFrame=J;const t=this._animation._interpolate(J,this._animationState);this.setValue(t,T)}_prepareForSpeedRatioChange(J){const T=this._previousElapsedTime*(this._animation.framePerSecond*J)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-T}animate(J,T,b,t,j){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const Y=this._animation,C=Y.targetPropertyPath;if(!C||C.length<1)return this._stopped=!0,!1;let F,A=!0;const a=this._events;let P=0;if(this._coreRuntimeAnimation)P=b-T,F=this._coreRuntimeAnimation.currentFrame,this._currentFrame=F,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let B;(T<this._minFrame||T>this._maxFrame)&&(T=this._minFrame),(b<this._minFrame||b>this._maxFrame)&&(b=this._maxFrame),P=b-T;let C=J*(Y.framePerSecond*j)/1e3+this._absoluteFrameOffset,v=0,G=!1;const x=t&&this._animationState.loopMode===q.b.ANIMATIONLOOPMODE_YOYO;if(x){const J=(C-T)/P,b=Math.sin(J*Math.PI);C=Math.abs(b)*P+T;const q=b>=0?1:-1;this._yoyoDirection!==q&&(G=!0),this._yoyoDirection=q}if(this._previousElapsedTime=J,this._previousAbsoluteFrame=C,!t&&b>=T&&(C>=P&&j>0||C<=0&&j<0))A=!1,v=Y._getKeyValue(this._maxValue);else if(!t&&T>=b&&(C<=P&&j<0||C>=0&&j>0))A=!1,v=Y._getKeyValue(this._minValue);else if(this._animationState.loopMode!==q.b.ANIMATIONLOOPMODE_CYCLE){const J=b.toString()+T.toString();if(!this._offsetsCache[J]){this._animationState.repeatCount=0,this._animationState.loopMode=q.b.ANIMATIONLOOPMODE_CYCLE;const t=Y._interpolate(T,this._animationState),j=Y._interpolate(b,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),Y.dataType){case q.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[J]=j-t;break;case q.b.ANIMATIONTYPE_QUATERNION:case q.b.ANIMATIONTYPE_VECTOR3:case q.b.ANIMATIONTYPE_VECTOR2:case q.b.ANIMATIONTYPE_SIZE:case q.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[J]=j.Jg(t)}this._highLimitsCache[J]=j}v=this._highLimitsCache[J],B=this._offsetsCache[J]}if(void 0===B)switch(Y.dataType){case q.b.ANIMATIONTYPE_FLOAT:B=0;break;case q.b.ANIMATIONTYPE_QUATERNION:B=q.j;break;case q.b.ANIMATIONTYPE_VECTOR3:B=q.p;break;case q.b.ANIMATIONTYPE_VECTOR2:B=q.l;break;case q.b.ANIMATIONTYPE_SIZE:B=q.k;break;case q.b.ANIMATIONTYPE_COLOR3:B=q.c;break;case q.b.ANIMATIONTYPE_COLOR4:B=q.g}if(this._host&&this._host.syncRoot){const J=this._host.syncRoot;F=T+P*((J.masterFrame-J.fromFrame)/(J.toFrame-J.fromFrame))}else F=C>0&&T>b||C<0&&T<b?A&&0!==P?b+C%P:T:A&&0!==P?T+C%P:b;if(!x&&(j>0&&this.currentFrame>F||j<0&&this.currentFrame<F)||x&&G){this._onLoop();for(let J=0;J<a.length;J++)a[J].onlyOnce||(a[J].isDone=!1);this._animationState.key=j>0?0:Y.getKeys().length-1}this._currentFrame=F,this._animationState.repeatCount=0===P?0:C/P|0,this._animationState.highLimitValue=v,this._animationState.offsetValue=B}const v=Y._interpolate(F,this._animationState);if(this.setValue(v,B),a.length)for(let q=0;q<a.length;q++)if(P>=0&&F>=a[q].frame&&a[q].frame>=T||P<0&&F<=a[q].frame&&a[q].frame<=T){const J=a[q];J.isDone||(J.onlyOnce&&(a.splice(q,1),q--),J.isDone=!0,J.action(F))}return A||(this._stopped=!0),A}}var A=b(529);class a{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(J){this._weight=-1!==J?Math.min(Math.max(J,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(J){for(let T=0;T<this._runtimeAnimations.length;T++){this._runtimeAnimations[T]._prepareForSpeedRatioChange(J)}this._speedRatio=J,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(J,T){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,j=arguments.length>4&&void 0!==arguments[4]&&arguments[4],B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,C=arguments.length>7?arguments[7]:void 0,F=arguments.length>8?arguments[8]:void 0,A=arguments.length>9&&void 0!==arguments[9]&&arguments[9],a=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=T,this.fromFrame=b,this.toFrame=q,this.loopAnimation=j,this.onAnimationEnd=Y,this.onAnimationLoop=F,this.isAdditive=A,this.playOrder=a,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Ok=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new t.b,this.onAnimationLoopObservable=new t.b,this._scene=J,C&&this.appendAnimations(T,C),this._speedRatio=B,J._activeAnimatables.push(this)}syncWith(J){if(this._syncRoot=J,J){const J=this._scene._activeAnimatables.indexOf(this);J>-1&&(this._scene._activeAnimatables.splice(J,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(J,T){for(let b=0;b<T.length;b++){const q=T[b],t=new F(J,q,this._scene,this);t._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(t)}}getAnimationByTargetProperty(J){const T=this._runtimeAnimations;for(let b=0;b<T.length;b++)if(T[b].animation.targetProperty===J)return T[b].animation;return null}getRuntimeAnimationByTargetProperty(J){const T=this._runtimeAnimations;for(let b=0;b<T.length;b++)if(T[b].animation.targetProperty===J)return T[b];return null}reset(){const J=this._runtimeAnimations;for(let T=0;T<J.length;T++)J[T].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(J){const T=this._runtimeAnimations;for(let b=0;b<T.length;b++)T[b].animation.enableBlending=!0,T[b].animation.blendingSpeed=J}disableBlending(){const J=this._runtimeAnimations;for(let T=0;T<J.length;T++)J[T].animation.enableBlending=!1}goToFrame(J){let T=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._runtimeAnimations;if(b[0]){const T=b[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??b[0].currentFrame;const q=0===this.speedRatio?0:(J-this._frameToSyncFromJump)/T*1e3/this.speedRatio;this._manualJumpDelay=-q}for(let q=0;q<b.length;q++)b[q].goToFrame(J,T?this._weight:-1);this._goToFrame=J}get paused(){return this.Ok}pause(){this.Ok||(this.Ok=!0)}restart(){this.Ok=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(J,T){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(J||T){const t=this._scene._activeAnimatables.indexOf(this);if(t>-1){const j=this._runtimeAnimations;for(let b=j.length-1;b>=0;b--){const q=j[b];J&&q.animation.name!=J||(T&&!T(q.target)||(q.dispose(),j.splice(b,1)))}0==j.length&&(b||this._scene._activeAnimatables.splice(t,1),q||this._raiseOnAnimationEnd())}}else{const J=this._scene._activeAnimatables.indexOf(this);if(J>-1){b||this._scene._activeAnimatables.splice(J,1);const T=this._runtimeAnimations;for(let J=0;J<T.length;J++)T[J].dispose();this._runtimeAnimations.length=0,q||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((J=>{this.onAnimationEndObservable.add((()=>{J(this)}),void 0,void 0,this,!0)}))}_animate(J){if(this.Ok)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=J),!0;if(null===this._localDelayOffset?(this._localDelayOffset=J,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=J-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let T=!1;const b=this._runtimeAnimations;let q;for(q=0;q<b.length;q++){const t=b[q].animate(J-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);T=T||t}if(this.animationStarted=T,!T){if(this.disposeOnEnd)for(q=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(q,1),q=0;q<b.length;q++)b[q].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return T}}function P(J){if(0===J.totalWeight&&0===J.totalAdditiveWeight)return J.originalValue;let T=1;const b=C.j.pi[0],q=C.j.pi[1],t=C.j.Quaternion[0];let j=0;const B=J.animations[0],Y=J.originalValue;let F=1,A=!1;if(J.totalWeight<1)F=1-J.totalWeight,Y.decompose(q,t,b);else{if(j=1,T=J.totalWeight,F=B.weight/T,1==F){if(!J.totalAdditiveWeight)return B.currentValue;A=!0}B.currentValue.decompose(q,t,b)}if(!A){q.scaleInPlace(F),b.scaleInPlace(F),t.scaleInPlace(F);for(let B=j;B<J.animations.length;B++){const j=J.animations[B];if(0===j.weight)continue;F=j.weight/T;const Y=C.j.pi[2],A=C.j.pi[3],a=C.j.Quaternion[1];j.currentValue.decompose(A,a,Y),A.scaleAndAddToRef(F,q),a.scaleAndAddToRef(C.h.Dot(t,a)>0?F:-F,t),Y.scaleAndAddToRef(F,b)}t.normalize()}for(let P=0;P<J.additiveAnimations.length;P++){const T=J.additiveAnimations[P];if(0===T.weight)continue;const j=C.j.pi[2],B=C.j.pi[3],Y=C.j.Quaternion[1];T.currentValue.decompose(B,Y,j),B.multiplyToRef(q,B),C.n.LerpToRef(q,B,T.weight,q),t.multiplyToRef(Y,Y),C.h.SlerpToRef(t,Y,T.weight,t),j.scaleAndAddToRef(T.weight,b)}const a=B?B._animationState.workValue:C.j.Matrix[0].clone();return C.e.ComposeToRef(q,t,b,a),a}function v(J,T){if(0===J.totalWeight&&0===J.totalAdditiveWeight)return T;const b=J.animations[0],q=J.originalValue;let t=T;if(0===J.totalWeight&&J.totalAdditiveWeight>0)t.p(q);else if(1===J.animations.length){if(C.h.SlerpToRef(q,b.currentValue,Math.min(1,J.totalWeight),t),0===J.totalAdditiveWeight)return t}else if(J.animations.length>1){let b,j,B=1;if(J.totalWeight<1){const T=1-J.totalWeight;b=[],j=[],b.push(q),j.push(T)}else{if(2===J.animations.length&&(C.h.SlerpToRef(J.animations[0].currentValue,J.animations[1].currentValue,J.animations[1].weight/J.totalWeight,T),0===J.totalAdditiveWeight))return T;b=[],j=[],B=J.totalWeight}for(let T=0;T<J.animations.length;T++){const q=J.animations[T];b.push(q.currentValue),j.push(q.weight/B)}let Y=0;for(let J=0;J<b.length;)J?(Y+=j[J],C.h.SlerpToRef(t,b[J],j[J]/Y,t),J++):(C.h.SlerpToRef(b[J],b[J+1],j[J+1]/(j[J]+j[J+1]),T),t=T,Y=j[J]+j[J+1],J+=2)}for(let j=0;j<J.additiveAnimations.length;j++){const T=J.additiveAnimations[j];0!==T.weight&&(t.multiplyToRef(T.currentValue,C.j.Quaternion[0]),C.h.SlerpToRef(t,C.j.Quaternion[0],T.weight,t))}return t}var G,x,I=b(2440);G=I.b,(x=Y.b)&&(x.prototype.copyAnimationRange=function(J,T,b){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3],j=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new q.b(this.name,"_matrix",J.animations[0].framePerSecond,q.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const B=J.animations[0].getRange(T);if(!B)return!1;const Y=B.from,C=B.to,F=J.animations[0].getKeys(),A=J.length,a=J.getParent(),P=this.getParent(),v=t&&a&&A&&this.length&&A!==this.length,G=v&&P&&a?P.length/a.length:1,x=t&&!P&&j&&(1!==j.x||1!==j.y||1!==j.z),I=this.animations[0].getKeys();let u,U,K;for(let q=0,E=F.length;q<E;q++)u=F[q],u.frame>=Y&&u.frame<=C&&(t?(K=u.value.clone(),v?(U=K.getTranslation(),K.setTranslation(U.scaleInPlace(G))):x&&j?(U=K.getTranslation(),K.setTranslation(U.multiplyInPlace(j))):K=u.value):K=u.value,I.push({frame:u.frame+b,value:K}));return this.animations[0].createRange(T,Y+b,C+b),!0}),G&&(G.prototype._animate=function(J){if(!this.animationsEnabled)return;const T=A.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=T}this.deltaTime=void 0!==J?J:this.useConstantAnimationDeltaTime?16:(T-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=T;const b=this._activeAnimatables;if(0===b.length)return;this._animationTime+=this.deltaTime;const t=this._animationTime;for(let q=0;q<b.length;q++){const J=b[q];!J._animate(t)&&J.disposeOnEnd&&q--}!function(J){if(J._registeredForLateAnimationBindings.length){for(let T=0;T<J._registeredForLateAnimationBindings.length;T++){const b=J._registeredForLateAnimationBindings.data[T];for(const J in b._lateAnimationHolders){const T=b._lateAnimationHolders[J],t=T.animations[0],j=T.originalValue;if(void 0===j||null===j)continue;const B=q.b.AllowMatrixDecomposeForInterpolation&&j.m;let Y=b[J];if(B)Y=P(T);else if(void 0!==j.w)Y=v(T,Y||C.h.Identity());else{let J=0,b=1;const B=t&&t._animationState.loopMode===q.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(T.totalWeight<1)Y=B?j.clone?j.clone():j:t&&j.scale?j.scale(1-T.totalWeight):t?j*(1-T.totalWeight):j.clone?j.clone():j;else if(t){b=T.totalWeight;const q=t.weight/b;Y=1!==q?t.currentValue.scale?t.currentValue.scale(q):t.currentValue*q:t.currentValue,B&&(Y.addToRef?Y.addToRef(j,Y):Y+=j),J=1}for(let q=J;q<T.animations.length;q++){const J=T.animations[q],t=J.weight/b;t&&(J.currentValue.scaleAndAddToRef?J.currentValue.scaleAndAddToRef(t,Y):Y+=J.currentValue*t)}for(let q=0;q<T.additiveAnimations.length;q++){const J=T.additiveAnimations[q],b=J.weight;b&&(J.currentValue.scaleAndAddToRef?J.currentValue.scaleAndAddToRef(b,Y):Y+=J.currentValue*b)}}b[J]=Y}b._lateAnimationHolders={}}J._registeredForLateAnimationBindings.reset()}}(this)},G.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((J,T)=>J.playOrder-T.playOrder))},G.prototype.beginWeightedAnimation=function(J,T,b){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,t=arguments.length>4?arguments[4]:void 0,j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,B=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,F=arguments.length>9?arguments[9]:void 0,A=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const a=this.beginAnimation(J,T,b,t,j,B,Y,!1,C,F,A);return a.weight=q,a},G.prototype.beginAnimation=function(J,T,b,q){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,j=arguments.length>5?arguments[5]:void 0,B=arguments.length>6?arguments[6]:void 0,Y=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],C=arguments.length>8?arguments[8]:void 0,F=arguments.length>9?arguments[9]:void 0,A=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(t<0){const J=T;T=b,b=J,t=-t}T>b&&(t=-t),Y&&this.stopAnimation(J,void 0,C),B||(B=new a(this,J,T,b,q,t,j,void 0,F,A));const P=!C||C(J);if(J.animations&&P&&B.appendAnimations(J,J.animations),J.getAnimatables){const A=J.getAnimatables();for(let J=0;J<A.length;J++)this.beginAnimation(A[J],T,b,q,t,j,B,Y,C,F)}return B.reset(),B},G.prototype.beginHierarchyAnimation=function(J,T,b,q,t){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,B=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7?arguments[7]:void 0,C=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],F=arguments.length>9?arguments[9]:void 0,A=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const a=J.getDescendants(T),P=[];P.push(this.beginAnimation(J,b,q,t,j,B,Y,C,F,void 0,A));for(const v of a)P.push(this.beginAnimation(v,b,q,t,j,B,Y,C,F,void 0,A));return P},G.prototype.beginDirectAnimation=function(J,T,b,q,t){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(j<0){const J=b;b=q,q=J,j=-j}return b>q&&(j=-j),new a(this,J,b,q,t,j,arguments.length>6?arguments[6]:void 0,T,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},G.prototype.beginDirectHierarchyAnimation=function(J,T,b,q,t,j,B,Y,C){let F=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const A=J.getDescendants(T),a=[];a.push(this.beginDirectAnimation(J,b,q,t,j,B,Y,C,F));for(const P of A)a.push(this.beginDirectAnimation(P,b,q,t,j,B,Y,C,F));return a},G.prototype.getAnimatableByTarget=function(J){for(let T=0;T<this._activeAnimatables.length;T++)if(this._activeAnimatables[T].target===J)return this._activeAnimatables[T];return null},G.prototype.getAllAnimatablesByTarget=function(J){const T=[];for(let b=0;b<this._activeAnimatables.length;b++)this._activeAnimatables[b].target===J&&T.push(this._activeAnimatables[b]);return T},G.prototype.stopAnimation=function(J,T,b){const q=this.getAllAnimatablesByTarget(J);for(const t of q)t.stop(T,b)},G.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let J=0;J<this._activeAnimatables.length;J++)this._activeAnimatables[J].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const J of this.animationGroups)J.stop()});class u{getClassName(){return"TargetedAnimation"}serialize(){const J={};return J.animation=this.animation.serialize(),J.targetId=this.target.id,J}}class U{get mask(){return this._mask}set mask(J){this._mask!==J&&(this._mask=J,this.syncWithMask(!0))}syncWithMask(){let J=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||J){this._numActiveAnimatables=0;for(let J=0;J<this._animatables.length;++J){const T=this._animatables[J];!this.mask||this.mask.disabled||this.mask.retainsTarget(T.target.name)?(this._numActiveAnimatables++,T.paused&&T.restart()):T.paused||T.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let J=0;J<this._animatables.length;++J){const T=this._animatables[J];this.mask.retainsTarget(T.target.name)||(T.stop(),this._animatables.splice(J,1),--J)}for(let J=0;J<this._targetedAnimations.length;J++){const T=this._targetedAnimations[J];this.mask.retainsTarget(T.target.name)||(this._targetedAnimations.splice(J,1),--J)}}}get from(){return this._from}set from(J){if(this._from!==J){this._from=J;for(let J=0;J<this._animatables.length;J++){this._animatables[J].fromFrame=this._from}}}get to(){return this._to}set to(J){if(this._to!==J){this._to=J;for(let J=0;J<this._animatables.length;J++){this._animatables[J].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(J){if(this._speedRatio!==J){this._speedRatio=J;for(let J=0;J<this._animatables.length;J++){this._animatables[J].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(J){if(this._loopAnimation!==J){this._loopAnimation=J;for(let J=0;J<this._animatables.length;J++){this._animatables[J].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(J){if(this._isAdditive!==J){this._isAdditive=J;for(let J=0;J<this._animatables.length;J++){this._animatables[J].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(J){this._weight!==J&&(this._weight=J,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(J){if(this._playOrder!==J&&(this._playOrder=J,this._animatables.length>0)){for(let J=0;J<this._animatables.length;J++)this._animatables[J].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(J){if(this._enableBlending!==J&&(this._enableBlending=J,null!==J))for(let T=0;T<this._targetedAnimations.length;++T)this._targetedAnimations[T].animation.enableBlending=J}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(J){if(this._blendingSpeed!==J&&(this._blendingSpeed=J,null!==J))for(let T=0;T<this._targetedAnimations.length;++T)this._targetedAnimations[T].animation.blendingSpeed=J}getLength(J,T){J=J??this._from;return((T=T??this._to)-J)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(J){let T=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],q=arguments.length>3?arguments[3]:void 0;if(0===J.length)return null;q=q??J[0].weight;let t=Number.MAX_VALUE,j=-Number.MAX_VALUE;if(b)for(const Y of J)Y.from<t&&(t=Y.from),Y.to>j&&(j=Y.to);const B=new U(J[0].name+"_merged",J[0]._scene,q);for(const Y of J){b&&Y.normalize(t,j);for(const J of Y.targetedAnimations)B.addTargetedAnimation(J.animation,J.target);T&&Y.dispose()}return B}constructor(J){let T=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=J,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new t.b,this.onAnimationLoopObservable=new t.b,this.onAnimationGroupLoopObservable=new t.b,this.onAnimationGroupEndObservable=new t.b,this.onAnimationGroupPauseObservable=new t.b,this.onAnimationGroupPlayObservable=new t.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=T||j.e.LastCreatedScene,this._weight=b,this._playOrder=q,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(J,T){const b=new u;b.animation=J,b.target=T;const q=J.getKeys();return this._from>q[0].frame&&(this._from=q[0].frame),this._to<q[q.length-1].frame&&(this._to=q[q.length-1].frame),null!==this._enableBlending&&(J.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(J.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(b),this._shouldStart=!0,b}removeTargetedAnimation(J){for(let T=this._targetedAnimations.length-1;T>-1;T--){this._targetedAnimations[T].animation===J&&this._targetedAnimations.splice(T,1)}}normalize(){let J=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,T=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==J&&(J=this._from),null==T&&(T=this._to);for(let b=0;b<this._targetedAnimations.length;b++){const q=this._targetedAnimations[b].animation.getKeys(),t=q[0],j=q[q.length-1];if(t.frame>J){const T={frame:J,value:t.value,inTangent:t.inTangent,outTangent:t.outTangent,interpolation:t.interpolation};q.splice(0,0,T)}if(j.frame<T){const J={frame:T,value:j.value,inTangent:j.inTangent,outTangent:j.outTangent,interpolation:j.interpolation};q.push(J)}}return this._from=J,this._to=T,this}_processLoop(J,T,b){J.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(T),this._animationLoopFlags[b]||(this._animationLoopFlags[b]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let J=arguments.length>0&&void 0!==arguments[0]&&arguments[0],T=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0,q=arguments.length>3?arguments[3]:void 0,t=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=J,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let j=0;j<this._targetedAnimations.length;j++){const B=this._targetedAnimations[j],Y=this._scene.beginDirectAnimation(B.target,[B.animation],void 0!==b?b:this._from,void 0!==q?q:this._to,J,T,void 0,void 0,void 0!==t?t:this._isAdditive);Y.weight=this._weight,Y.playOrder=this._playOrder,Y.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(B),this._checkAnimationGroupEnded(Y)},this._processLoop(Y,B,j),this._animatables.push(Y)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=T,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let J=0;J<this._animatables.length;J++){this._animatables[J].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(J){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==J&&(this.loopAnimation=J),this.restart()):(this.stop(),this.start(J,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let J=0;J<this._animatables.length;J++){this._animatables[J].reset()}return this}restart(){if(!this._isStarted)return this;for(let J=0;J<this._animatables.length;J++){this._animatables[J].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let J=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const T=this._animatables.slice();for(let q=0;q<T.length;q++)T[q].stop(void 0,void 0,!0,J);let b=0;for(let q=0;q<this._scene._activeAnimatables.length;q++){const T=this._scene._activeAnimatables[q];T._runtimeAnimations.length>0?this._scene._activeAnimatables[b++]=T:J&&this._checkAnimationGroupEnded(T,J)}return this._scene._activeAnimatables.length=b,this._isStarted=!1,this}setWeightForAllAnimatables(J){for(let T=0;T<this._animatables.length;T++){this._animatables[T].weight=J}return this}syncAllAnimationsWith(J){for(let T=0;T<this._animatables.length;T++){this._animatables[T].syncWith(J)}return this}goToFrame(J){let T=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].goToFrame(J,T)}return this}getCurrentFrame(){var J;return(null===(J=this.animatables[0])||void 0===J?void 0:J.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const J=this._scene.animationGroups.indexOf(this);if(J>-1&&this._scene.animationGroups.splice(J,1),this._parentContainer){const J=this._parentContainer.animationGroups.indexOf(this);J>-1&&this._parentContainer.animationGroups.splice(J,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(J){let T=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const b=this._animatables.indexOf(J);b>-1&&this._animatables.splice(b,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,T||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(J,T){let b=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=new U(J||this.name,this._scene,this._weight,this._playOrder);q._from=this.from,q._to=this.to,q._speedRatio=this.speedRatio,q._loopAnimation=this.loopAnimation,q._isAdditive=this.isAdditive,q._enableBlending=this.enableBlending,q._blendingSpeed=this.blendingSpeed,q.metadata=this.metadata,q.mask=this.mask;for(const t of this._targetedAnimations)q.addTargetedAnimation(b?t.animation.clone():t.animation,T?T(t.target):t.target);return q}serialize(){const J={};J.name=this.name,J.from=this.from,J.to=this.to,J.speedRatio=this.speedRatio,J.loopAnimation=this.loopAnimation,J.isAdditive=this.isAdditive,J.weight=this.weight,J.playOrder=this.playOrder,J.enableBlending=this.enableBlending,J.blendingSpeed=this.blendingSpeed,J.targetedAnimations=[];for(let T=0;T<this.targetedAnimations.length;T++){const b=this.targetedAnimations[T];J.targetedAnimations[T]=b.serialize()}return B.c&&B.c.HasTags(this)&&(J.tags=B.c.GetTags(this)),this.metadata&&(J.metadata=this.metadata),J}static Parse(J,T){const b=new U(J.name,T,J.weight,J.playOrder);for(let t=0;t<J.targetedAnimations.length;t++){const j=J.targetedAnimations[t],B=q.b.Parse(j.animation),Y=j.targetId;if("influence"===j.animation.property){const J=T.getMorphTargetById(Y);J&&b.addTargetedAnimation(B,J)}else{const J=T.getNodeById(Y);null!=J&&b.addTargetedAnimation(B,J)}}return B.c&&B.c.AddTagsTo(b,J.tags),null!==J.from&&null!==J.to&&b.normalize(J.from,J.to),void 0!==J.speedRatio&&(b._speedRatio=J.speedRatio),void 0!==J.loopAnimation&&(b._loopAnimation=J.loopAnimation),void 0!==J.isAdditive&&(b._isAdditive=J.isAdditive),void 0!==J.weight&&(b._weight=J.weight),void 0!==J.playOrder&&(b._playOrder=J.playOrder),void 0!==J.enableBlending&&(b._enableBlending=J.enableBlending),void 0!==J.blendingSpeed&&(b._blendingSpeed=J.blendingSpeed),void 0!==J.metadata&&(b.metadata=J.metadata),b}static MakeAnimationAdditive(J,T,b){let t;t="object"===typeof T?T:{referenceFrame:T,range:b,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let j=J;t.cloneOriginalAnimationGroup&&(j=J.clone(t.clonedAnimationGroupName||j.name));const B=j.targetedAnimations;for(let Y=0;Y<B.length;Y++){const J=B[Y];J.animation=q.b.MakeAnimationAdditive(J.animation,t)}if(j.isAdditive=!0,t.clipKeys){let J=Number.MAX_VALUE,T=-Number.MAX_VALUE;const b=j.targetedAnimations;for(let q=0;q<b.length;q++){const t=b[q].animation.getKeys();J>t[0].frame&&(J=t[0].frame),T<t[t.length-1].frame&&(T=t[t.length-1].frame)}j._from=J,j._to=T}return j}static ClipKeys(J,T,b,q,t){const j=J.clone(q||J.name);return U.ClipKeysInPlace(j,T,b,t)}static ClipKeysInPlace(J,T,b,q){return U.ClipInPlace(J,T,b,q,!1)}static ClipFrames(J,T,b,q,t){const j=J.clone(q||J.name);return U.ClipFramesInPlace(j,T,b,t)}static ClipFramesInPlace(J,T,b,q){return U.ClipInPlace(J,T,b,q,!0)}static ClipInPlace(J,T,b,q){let t=arguments.length>4&&void 0!==arguments[4]&&arguments[4],j=Number.MAX_VALUE,B=-Number.MAX_VALUE;const Y=J.targetedAnimations;for(let C=0;C<Y.length;C++){const J=Y[C],F=q?J.animation:J.animation.clone();t&&(F.createKeyForFrame(T),F.createKeyForFrame(b));const A=F.getKeys(),a=[];let P=Number.MAX_VALUE;for(let q=0;q<A.length;q++){const J=A[q];if(!t&&q>=T&&q<=b||t&&J.frame>=T&&J.frame<=b){const T={frame:J.frame,value:J.value.clone?J.value.clone():J.value,inTangent:J.inTangent,outTangent:J.outTangent,interpolation:J.interpolation,lockedTangent:J.lockedTangent};P===Number.MAX_VALUE&&(P=T.frame),T.frame-=P,a.push(T)}}0!==a.length?(j>a[0].frame&&(j=a[0].frame),B<a[a.length-1].frame&&(B=a[a.length-1].frame),F.setKeys(a,!0),J.animation=F):(Y.splice(C,1),C--)}return J._from=j,J._to=B,J}getClassName(){return"AnimationGroup"}toString(J){let T="Name: "+this.name;return T+=", type: "+this.getClassName(),J&&(T+=", from: "+this._from,T+=", to: "+this._to,T+=", isStarted: "+this._isStarted,T+=", speedRatio: "+this._speedRatio,T+=", targetedAnimations length: "+this._targetedAnimations.length,T+=", animatables length: "+this._animatables),T}}}}]);