"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[49],{14057:(F,P,f)=>{f.r(P),f.d(P,{_HDRTextureLoader:()=>i});var c=f(11639);class N{static ConvertPanoramaToCubemap(F,P,f,c){let N=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!F)throw"ConvertPanoramaToCubemap: input cannot be null";if(F.length!=P*f*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(c,this.FACE_FRONT,F,P,f,N),back:this.CreateCubemapTexture(c,this.FACE_BACK,F,P,f,N),left:this.CreateCubemapTexture(c,this.FACE_LEFT,F,P,f,N),right:this.CreateCubemapTexture(c,this.FACE_RIGHT,F,P,f,N),up:this.CreateCubemapTexture(c,this.FACE_UP,F,P,f,N),down:this.CreateCubemapTexture(c,this.FACE_DOWN,F,P,f,N),size:c,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(F,P,f,c,N){let q=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const H=new ArrayBuffer(F*F*4*3),A=new Float32Array(H),o=q?Math.max(1,Math.round(c/4/F)):1,j=1/o,i=j*j,u=P[1].CP(P[0]).scale(j/F),T=P[3].CP(P[2]).scale(j/F),Y=1/F;let t=0;for(let C=0;C<F;C++)for(let q=0;q<o;q++){let q=P[0],H=P[2];for(let P=0;P<F;P++)for(let j=0;j<o;j++){const o=H.CP(q).scale(t).add(q);o.normalize();const j=this.CalcProjectionSpherical(o,f,c,N);A[C*F*3+3*P+0]+=j.r*i,A[C*F*3+3*P+1]+=j.g*i,A[C*F*3+3*P+2]+=j.b*i,q=q.add(u),H=H.add(T)}t+=Y*j}return A}static CalcProjectionSpherical(F,P,f,c){let N=Math.atan2(F.z,F.x);const q=Math.acos(F.y);for(;N<-Math.PI;)N+=2*Math.PI;for(;N>Math.PI;)N-=2*Math.PI;let H=N/Math.PI;const A=q/Math.PI;H=.5*H+.5;let o=Math.round(H*f);o<0?o=0:o>=f&&(o=f-1);let j=Math.round(A*c);j<0?j=0:j>=c&&(j=c-1);const i=c-j-1;return{r:P[i*f*3+3*o+0],g:P[i*f*3+3*o+1],b:P[i*f*3+3*o+2]}}}function q(F,P,f,c,N,q){N>0?(N=function(F,P){return P>1023?F*Math.pow(2,1023)*Math.pow(2,P-1023):P<-1074?F*Math.pow(2,-1074)*Math.pow(2,P+1074):F*Math.pow(2,P)}(1,N-136),F[q+0]=P*N,F[q+1]=f*N,F[q+2]=c*N):(F[q+0]=0,F[q+1]=0,F[q+2]=0)}function H(F,P){let f="",c="";for(let N=P;N<F.length-P&&(c=String.fromCharCode(F[N]),"\n"!=c);N++)f+=c;return f}function A(F){let P=0,f=0,c=H(F,0);if("#"!=c[0]||"?"!=c[1])throw"Bad HDR Format.";let N=!1,q=!1,A=0;do{A+=c.length+1,c=H(F,A),"FORMAT=32-bit_rle_rgbe"==c?q=!0:0==c.length&&(N=!0)}while(!N);if(!q)throw"HDR Bad header format, unsupported FORMAT";A+=c.length+1,c=H(F,A);const o=/^-Y (.*) \+X (.*)$/g.exec(c);if(!o||o.length<3)throw"HDR Bad header format, no size";if(f=parseInt(o[2]),P=parseInt(o[1]),f<8||f>32767)throw"HDR Bad header format, unsupported size";return A+=c.length+1,{height:P,width:f,dataPosition:A}}function o(F,P){return function(F,P){let f=P.height;const c=P.width;let N,H,A,o,i,u=P.dataPosition,T=0,Y=0,t=0;const C=new ArrayBuffer(4*c),L=new Uint8Array(C),J=new ArrayBuffer(P.width*P.height*4*3),B=new Float32Array(J);for(;f>0;){if(N=F[u++],H=F[u++],A=F[u++],o=F[u++],2!=N||2!=H||128&A||P.width<8||P.width>32767)return j(F,P);if((A<<8|o)!=c)throw"HDR Bad header format, wrong scan line width";for(T=0,t=0;t<4;t++)for(Y=(t+1)*c;T<Y;)if(N=F[u++],H=F[u++],N>128){if(i=N-128,0==i||i>Y-T)throw"HDR Bad Format, bad scanline data (run)";for(;i-- >0;)L[T++]=H}else{if(i=N,0==i||i>Y-T)throw"HDR Bad Format, bad scanline data (non-run)";if(L[T++]=H,--i>0)for(let P=0;P<i;P++)L[T++]=F[u++]}for(t=0;t<c;t++)N=L[t],H=L[t+c],A=L[t+2*c],o=L[t+3*c],q(B,N,H,A,o,(P.height-f)*c*3+3*t);f--}return B}(F,P)}function j(F,P){let f=P.height;const c=P.width;let N,H,A,o,j,i=P.dataPosition;const u=new ArrayBuffer(P.width*P.height*4*3),T=new Float32Array(u);for(;f>0;){for(j=0;j<P.width;j++)N=F[i++],H=F[i++],A=F[i++],o=F[i++],q(T,N,H,A,o,(P.height-f)*c*3+3*j);f--}return T}N.FACE_LEFT=[new c.tP(-1,-1,-1),new c.tP(1,-1,-1),new c.tP(-1,1,-1),new c.tP(1,1,-1)],N.FACE_RIGHT=[new c.tP(1,-1,1),new c.tP(-1,-1,1),new c.tP(1,1,1),new c.tP(-1,1,1)],N.FACE_FRONT=[new c.tP(1,-1,-1),new c.tP(1,-1,1),new c.tP(1,1,-1),new c.tP(1,1,1)],N.FACE_BACK=[new c.tP(-1,-1,1),new c.tP(-1,-1,-1),new c.tP(-1,1,1),new c.tP(-1,1,-1)],N.FACE_DOWN=[new c.tP(1,1,-1),new c.tP(1,1,1),new c.tP(-1,1,-1),new c.tP(-1,1,1)],N.FACE_UP=[new c.tP(-1,-1,-1),new c.tP(-1,-1,1),new c.tP(1,-1,-1),new c.tP(1,-1,1)];class i{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(F,P,f){const c=new Uint8Array(F.buffer,F.byteOffset,F.byteLength),N=A(c),q=o(c,N),H=N.width*N.height,j=new Float32Array(4*H);for(let A=0;A<H;A+=1)j[4*A]=q[3*A],j[4*A+1]=q[3*A+1],j[4*A+2]=q[3*A+2],j[4*A+3]=1;f(N.width,N.height,P.generateMipMaps,!1,(()=>{const F=P.getEngine();P.type=1,P.format=5,P._gammaSpace=!1,F._uploadDataToTextureDirectly(P,j)}))}}}}]);