"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[31],{13460:(x,O,Q)=>{Q.r(O),Q.d(O,{_HDRTextureLoader:()=>U});var X=Q(10849);class Z{static ConvertPanoramaToCubemap(x,O,Q,X){let Z=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!x)throw"ConvertPanoramaToCubemap: input cannot be null";if(x.length!=O*Q*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(X,this.FACE_FRONT,x,O,Q,Z),back:this.CreateCubemapTexture(X,this.FACE_BACK,x,O,Q,Z),left:this.CreateCubemapTexture(X,this.FACE_LEFT,x,O,Q,Z),right:this.CreateCubemapTexture(X,this.FACE_RIGHT,x,O,Q,Z),up:this.CreateCubemapTexture(X,this.FACE_UP,x,O,Q,Z),down:this.CreateCubemapTexture(X,this.FACE_DOWN,x,O,Q,Z),size:X,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(x,O,Q,X,Z){let n=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const V=new ArrayBuffer(x*x*4*3),o=new Float32Array(V),l=n?Math.max(1,Math.round(X/4/x)):1,C=1/l,U=C*C,L=O[1].hQ(O[0]).scale(C/x),h=O[3].hQ(O[2]).scale(C/x),N=1/x;let a=0;for(let K=0;K<x;K++)for(let n=0;n<l;n++){let n=O[0],V=O[2];for(let O=0;O<x;O++)for(let C=0;C<l;C++){const l=V.hQ(n).scale(a).add(n);l.normalize();const C=this.CalcProjectionSpherical(l,Q,X,Z);o[K*x*3+3*O+0]+=C.r*U,o[K*x*3+3*O+1]+=C.g*U,o[K*x*3+3*O+2]+=C.b*U,n=n.add(L),V=V.add(h)}a+=N*C}return o}static CalcProjectionSpherical(x,O,Q,X){let Z=Math.atan2(x.z,x.x);const n=Math.acos(x.y);for(;Z<-Math.PI;)Z+=2*Math.PI;for(;Z>Math.PI;)Z-=2*Math.PI;let V=Z/Math.PI;const o=n/Math.PI;V=.5*V+.5;let l=Math.round(V*Q);l<0?l=0:l>=Q&&(l=Q-1);let C=Math.round(o*X);C<0?C=0:C>=X&&(C=X-1);const U=X-C-1;return{r:O[U*Q*3+3*l+0],g:O[U*Q*3+3*l+1],b:O[U*Q*3+3*l+2]}}}function n(x,O,Q,X,Z,n){Z>0?(Z=function(x,O){return O>1023?x*Math.pow(2,1023)*Math.pow(2,O-1023):O<-1074?x*Math.pow(2,-1074)*Math.pow(2,O+1074):x*Math.pow(2,O)}(1,Z-136),x[n+0]=O*Z,x[n+1]=Q*Z,x[n+2]=X*Z):(x[n+0]=0,x[n+1]=0,x[n+2]=0)}function V(x,O){let Q="",X="";for(let Z=O;Z<x.length-O&&(X=String.fromCharCode(x[Z]),"\n"!=X);Z++)Q+=X;return Q}function o(x){let O=0,Q=0,X=V(x,0);if("#"!=X[0]||"?"!=X[1])throw"Bad HDR Format.";let Z=!1,n=!1,o=0;do{o+=X.length+1,X=V(x,o),"FORMAT=32-bit_rle_rgbe"==X?n=!0:0==X.length&&(Z=!0)}while(!Z);if(!n)throw"HDR Bad header format, unsupported FORMAT";o+=X.length+1,X=V(x,o);const l=/^-Y (.*) \+X (.*)$/g.exec(X);if(!l||l.length<3)throw"HDR Bad header format, no size";if(Q=parseInt(l[2]),O=parseInt(l[1]),Q<8||Q>32767)throw"HDR Bad header format, unsupported size";return o+=X.length+1,{height:O,width:Q,dataPosition:o}}function l(x,O){return function(x,O){let Q=O.height;const X=O.width;let Z,V,o,l,U,L=O.dataPosition,h=0,N=0,a=0;const K=new ArrayBuffer(4*X),M=new Uint8Array(K),Y=new ArrayBuffer(O.width*O.height*4*3),g=new Float32Array(Y);for(;Q>0;){if(Z=x[L++],V=x[L++],o=x[L++],l=x[L++],2!=Z||2!=V||128&o||O.width<8||O.width>32767)return C(x,O);if((o<<8|l)!=X)throw"HDR Bad header format, wrong scan line width";for(h=0,a=0;a<4;a++)for(N=(a+1)*X;h<N;)if(Z=x[L++],V=x[L++],Z>128){if(U=Z-128,0==U||U>N-h)throw"HDR Bad Format, bad scanline data (run)";for(;U-- >0;)M[h++]=V}else{if(U=Z,0==U||U>N-h)throw"HDR Bad Format, bad scanline data (non-run)";if(M[h++]=V,--U>0)for(let O=0;O<U;O++)M[h++]=x[L++]}for(a=0;a<X;a++)Z=M[a],V=M[a+X],o=M[a+2*X],l=M[a+3*X],n(g,Z,V,o,l,(O.height-Q)*X*3+3*a);Q--}return g}(x,O)}function C(x,O){let Q=O.height;const X=O.width;let Z,V,o,l,C,U=O.dataPosition;const L=new ArrayBuffer(O.width*O.height*4*3),h=new Float32Array(L);for(;Q>0;){for(C=0;C<O.width;C++)Z=x[U++],V=x[U++],o=x[U++],l=x[U++],n(h,Z,V,o,l,(O.height-Q)*X*3+3*C);Q--}return h}Z.FACE_LEFT=[new X.n(-1,-1,-1),new X.n(1,-1,-1),new X.n(-1,1,-1),new X.n(1,1,-1)],Z.FACE_RIGHT=[new X.n(1,-1,1),new X.n(-1,-1,1),new X.n(1,1,1),new X.n(-1,1,1)],Z.FACE_FRONT=[new X.n(1,-1,-1),new X.n(1,-1,1),new X.n(1,1,-1),new X.n(1,1,1)],Z.FACE_BACK=[new X.n(-1,-1,1),new X.n(-1,-1,-1),new X.n(-1,1,1),new X.n(-1,1,-1)],Z.FACE_DOWN=[new X.n(1,1,-1),new X.n(1,1,1),new X.n(-1,1,-1),new X.n(-1,1,1)],Z.FACE_UP=[new X.n(-1,-1,-1),new X.n(-1,-1,1),new X.n(1,-1,-1),new X.n(1,-1,1)];class U{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(x,O,Q){const X=new Uint8Array(x.buffer,x.byteOffset,x.byteLength),Z=o(X),n=l(X,Z),V=Z.width*Z.height,C=new Float32Array(4*V);for(let o=0;o<V;o+=1)C[4*o]=n[3*o],C[4*o+1]=n[3*o+1],C[4*o+2]=n[3*o+2],C[4*o+3]=1;Q(Z.width,Z.height,O.generateMipMaps,!1,(()=>{const x=O.getEngine();O.type=1,O.format=5,O._gammaSpace=!1,x._uploadDataToTextureDirectly(O,C)}))}}}}]);