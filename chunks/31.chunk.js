"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[31],{13391:(q,c,U)=>{U.r(c),U.d(c,{_HDRTextureLoader:()=>D});var J=U(10833);class Q{static ConvertPanoramaToCubemap(q,c,U,J){let Q=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!q)throw"ConvertPanoramaToCubemap: input cannot be null";if(q.length!=c*U*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(J,this.FACE_FRONT,q,c,U,Q),back:this.CreateCubemapTexture(J,this.FACE_BACK,q,c,U,Q),left:this.CreateCubemapTexture(J,this.FACE_LEFT,q,c,U,Q),right:this.CreateCubemapTexture(J,this.FACE_RIGHT,q,c,U,Q),up:this.CreateCubemapTexture(J,this.FACE_UP,q,c,U,Q),down:this.CreateCubemapTexture(J,this.FACE_DOWN,q,c,U,Q),size:J,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(q,c,U,J,Q){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const g=new ArrayBuffer(q*q*4*3),X=new Float32Array(g),n=s?Math.max(1,Math.round(J/4/q)):1,W=1/n,D=W*W,u=c[1].eU(c[0]).scale(W/q),K=c[3].eU(c[2]).scale(W/q),r=1/q;let H=0;for(let b=0;b<q;b++)for(let s=0;s<n;s++){let s=c[0],g=c[2];for(let c=0;c<q;c++)for(let W=0;W<n;W++){const n=g.eU(s).scale(H).add(s);n.normalize();const W=this.CalcProjectionSpherical(n,U,J,Q);X[b*q*3+3*c+0]+=W.r*D,X[b*q*3+3*c+1]+=W.g*D,X[b*q*3+3*c+2]+=W.b*D,s=s.add(u),g=g.add(K)}H+=r*W}return X}static CalcProjectionSpherical(q,c,U,J){let Q=Math.atan2(q.z,q.x);const s=Math.acos(q.y);for(;Q<-Math.PI;)Q+=2*Math.PI;for(;Q>Math.PI;)Q-=2*Math.PI;let g=Q/Math.PI;const X=s/Math.PI;g=.5*g+.5;let n=Math.round(g*U);n<0?n=0:n>=U&&(n=U-1);let W=Math.round(X*J);W<0?W=0:W>=J&&(W=J-1);const D=J-W-1;return{r:c[D*U*3+3*n+0],g:c[D*U*3+3*n+1],b:c[D*U*3+3*n+2]}}}function s(q,c,U,J,Q,s){Q>0?(Q=function(q,c){return c>1023?q*Math.pow(2,1023)*Math.pow(2,c-1023):c<-1074?q*Math.pow(2,-1074)*Math.pow(2,c+1074):q*Math.pow(2,c)}(1,Q-136),q[s+0]=c*Q,q[s+1]=U*Q,q[s+2]=J*Q):(q[s+0]=0,q[s+1]=0,q[s+2]=0)}function g(q,c){let U="",J="";for(let Q=c;Q<q.length-c&&(J=String.fromCharCode(q[Q]),"\n"!=J);Q++)U+=J;return U}function X(q){let c=0,U=0,J=g(q,0);if("#"!=J[0]||"?"!=J[1])throw"Bad HDR Format.";let Q=!1,s=!1,X=0;do{X+=J.length+1,J=g(q,X),"FORMAT=32-bit_rle_rgbe"==J?s=!0:0==J.length&&(Q=!0)}while(!Q);if(!s)throw"HDR Bad header format, unsupported FORMAT";X+=J.length+1,J=g(q,X);const n=/^-Y (.*) \+X (.*)$/g.exec(J);if(!n||n.length<3)throw"HDR Bad header format, no size";if(U=parseInt(n[2]),c=parseInt(n[1]),U<8||U>32767)throw"HDR Bad header format, unsupported size";return X+=J.length+1,{height:c,width:U,dataPosition:X}}function n(q,c){return function(q,c){let U=c.height;const J=c.width;let Q,g,X,n,D,u=c.dataPosition,K=0,r=0,H=0;const b=new ArrayBuffer(4*J),h=new Uint8Array(b),o=new ArrayBuffer(c.width*c.height*4*3),a=new Float32Array(o);for(;U>0;){if(Q=q[u++],g=q[u++],X=q[u++],n=q[u++],2!=Q||2!=g||128&X||c.width<8||c.width>32767)return W(q,c);if((X<<8|n)!=J)throw"HDR Bad header format, wrong scan line width";for(K=0,H=0;H<4;H++)for(r=(H+1)*J;K<r;)if(Q=q[u++],g=q[u++],Q>128){if(D=Q-128,0==D||D>r-K)throw"HDR Bad Format, bad scanline data (run)";for(;D-- >0;)h[K++]=g}else{if(D=Q,0==D||D>r-K)throw"HDR Bad Format, bad scanline data (non-run)";if(h[K++]=g,--D>0)for(let c=0;c<D;c++)h[K++]=q[u++]}for(H=0;H<J;H++)Q=h[H],g=h[H+J],X=h[H+2*J],n=h[H+3*J],s(a,Q,g,X,n,(c.height-U)*J*3+3*H);U--}return a}(q,c)}function W(q,c){let U=c.height;const J=c.width;let Q,g,X,n,W,D=c.dataPosition;const u=new ArrayBuffer(c.width*c.height*4*3),K=new Float32Array(u);for(;U>0;){for(W=0;W<c.width;W++)Q=q[D++],g=q[D++],X=q[D++],n=q[D++],s(K,Q,g,X,n,(c.height-U)*J*3+3*W);U--}return K}Q.FACE_LEFT=[new J.p(-1,-1,-1),new J.p(1,-1,-1),new J.p(-1,1,-1),new J.p(1,1,-1)],Q.FACE_RIGHT=[new J.p(1,-1,1),new J.p(-1,-1,1),new J.p(1,1,1),new J.p(-1,1,1)],Q.FACE_FRONT=[new J.p(1,-1,-1),new J.p(1,-1,1),new J.p(1,1,-1),new J.p(1,1,1)],Q.FACE_BACK=[new J.p(-1,-1,1),new J.p(-1,-1,-1),new J.p(-1,1,1),new J.p(-1,1,-1)],Q.FACE_DOWN=[new J.p(1,1,-1),new J.p(1,1,1),new J.p(-1,1,-1),new J.p(-1,1,1)],Q.FACE_UP=[new J.p(-1,-1,-1),new J.p(-1,-1,1),new J.p(1,-1,-1),new J.p(1,-1,1)];class D{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(q,c,U){const J=new Uint8Array(q.buffer,q.byteOffset,q.byteLength),Q=X(J),s=n(J,Q),g=Q.width*Q.height,W=new Float32Array(4*g);for(let X=0;X<g;X+=1)W[4*X]=s[3*X],W[4*X+1]=s[3*X+1],W[4*X+2]=s[3*X+2],W[4*X+3]=1;U(Q.width,Q.height,c.generateMipMaps,!1,(()=>{const q=c.getEngine();c.type=1,c.format=5,c._gammaSpace=!1,q._uploadDataToTextureDirectly(c,W)}))}}}}]);