"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[31],{13669:(V,I,m)=>{m.r(I),m.d(I,{_HDRTextureLoader:()=>K});var C=m(11040);class l{static ConvertPanoramaToCubemap(V,I,m,C){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!V)throw"ConvertPanoramaToCubemap: input cannot be null";if(V.length!=I*m*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(C,this.FACE_FRONT,V,I,m,l),back:this.CreateCubemapTexture(C,this.FACE_BACK,V,I,m,l),left:this.CreateCubemapTexture(C,this.FACE_LEFT,V,I,m,l),right:this.CreateCubemapTexture(C,this.FACE_RIGHT,V,I,m,l),up:this.CreateCubemapTexture(C,this.FACE_UP,V,I,m,l),down:this.CreateCubemapTexture(C,this.FACE_DOWN,V,I,m,l),size:C,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(V,I,m,C,l){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const F=new ArrayBuffer(V*V*4*3),k=new Float32Array(F),j=s?Math.max(1,Math.round(C/4/V)):1,E=1/j,K=E*E,Y=I[1].Fm(I[0]).scale(E/V),X=I[3].Fm(I[2]).scale(E/V),O=1/V;let v=0;for(let N=0;N<V;N++)for(let s=0;s<j;s++){let s=I[0],F=I[2];for(let I=0;I<V;I++)for(let E=0;E<j;E++){const j=F.Fm(s).scale(v).add(s);j.normalize();const E=this.CalcProjectionSpherical(j,m,C,l);k[N*V*3+3*I+0]+=E.r*K,k[N*V*3+3*I+1]+=E.g*K,k[N*V*3+3*I+2]+=E.b*K,s=s.add(Y),F=F.add(X)}v+=O*E}return k}static CalcProjectionSpherical(V,I,m,C){let l=Math.atan2(V.z,V.x);const s=Math.acos(V.y);for(;l<-Math.PI;)l+=2*Math.PI;for(;l>Math.PI;)l-=2*Math.PI;let F=l/Math.PI;const k=s/Math.PI;F=.5*F+.5;let j=Math.round(F*m);j<0?j=0:j>=m&&(j=m-1);let E=Math.round(k*C);E<0?E=0:E>=C&&(E=C-1);const K=C-E-1;return{r:I[K*m*3+3*j+0],g:I[K*m*3+3*j+1],b:I[K*m*3+3*j+2]}}}function s(V,I,m,C,l,s){l>0?(l=function(V,I){return I>1023?V*Math.pow(2,1023)*Math.pow(2,I-1023):I<-1074?V*Math.pow(2,-1074)*Math.pow(2,I+1074):V*Math.pow(2,I)}(1,l-136),V[s+0]=I*l,V[s+1]=m*l,V[s+2]=C*l):(V[s+0]=0,V[s+1]=0,V[s+2]=0)}function F(V,I){let m="",C="";for(let l=I;l<V.length-I&&(C=String.fromCharCode(V[l]),"\n"!=C);l++)m+=C;return m}function k(V){let I=0,m=0,C=F(V,0);if("#"!=C[0]||"?"!=C[1])throw"Bad HDR Format.";let l=!1,s=!1,k=0;do{k+=C.length+1,C=F(V,k),"FORMAT=32-bit_rle_rgbe"==C?s=!0:0==C.length&&(l=!0)}while(!l);if(!s)throw"HDR Bad header format, unsupported FORMAT";k+=C.length+1,C=F(V,k);const j=/^-Y (.*) \+X (.*)$/g.exec(C);if(!j||j.length<3)throw"HDR Bad header format, no size";if(m=parseInt(j[2]),I=parseInt(j[1]),m<8||m>32767)throw"HDR Bad header format, unsupported size";return k+=C.length+1,{height:I,width:m,dataPosition:k}}function j(V,I){return function(V,I){let m=I.height;const C=I.width;let l,F,k,j,K,Y=I.dataPosition,X=0,O=0,v=0;const N=new ArrayBuffer(4*C),t=new Uint8Array(N),D=new ArrayBuffer(I.width*I.height*4*3),b=new Float32Array(D);for(;m>0;){if(l=V[Y++],F=V[Y++],k=V[Y++],j=V[Y++],2!=l||2!=F||128&k||I.width<8||I.width>32767)return E(V,I);if((k<<8|j)!=C)throw"HDR Bad header format, wrong scan line width";for(X=0,v=0;v<4;v++)for(O=(v+1)*C;X<O;)if(l=V[Y++],F=V[Y++],l>128){if(K=l-128,0==K||K>O-X)throw"HDR Bad Format, bad scanline data (run)";for(;K-- >0;)t[X++]=F}else{if(K=l,0==K||K>O-X)throw"HDR Bad Format, bad scanline data (non-run)";if(t[X++]=F,--K>0)for(let I=0;I<K;I++)t[X++]=V[Y++]}for(v=0;v<C;v++)l=t[v],F=t[v+C],k=t[v+2*C],j=t[v+3*C],s(b,l,F,k,j,(I.height-m)*C*3+3*v);m--}return b}(V,I)}function E(V,I){let m=I.height;const C=I.width;let l,F,k,j,E,K=I.dataPosition;const Y=new ArrayBuffer(I.width*I.height*4*3),X=new Float32Array(Y);for(;m>0;){for(E=0;E<I.width;E++)l=V[K++],F=V[K++],k=V[K++],j=V[K++],s(X,l,F,k,j,(I.height-m)*C*3+3*E);m--}return X}l.FACE_LEFT=[new C.m(-1,-1,-1),new C.m(1,-1,-1),new C.m(-1,1,-1),new C.m(1,1,-1)],l.FACE_RIGHT=[new C.m(1,-1,1),new C.m(-1,-1,1),new C.m(1,1,1),new C.m(-1,1,1)],l.FACE_FRONT=[new C.m(1,-1,-1),new C.m(1,-1,1),new C.m(1,1,-1),new C.m(1,1,1)],l.FACE_BACK=[new C.m(-1,-1,1),new C.m(-1,-1,-1),new C.m(-1,1,1),new C.m(-1,1,-1)],l.FACE_DOWN=[new C.m(1,1,-1),new C.m(1,1,1),new C.m(-1,1,-1),new C.m(-1,1,1)],l.FACE_UP=[new C.m(-1,-1,-1),new C.m(-1,-1,1),new C.m(1,-1,-1),new C.m(1,-1,1)];class K{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(V,I,m){const C=new Uint8Array(V.buffer,V.byteOffset,V.byteLength),l=k(C),s=j(C,l),F=l.width*l.height,E=new Float32Array(4*F);for(let k=0;k<F;k+=1)E[4*k]=s[3*k],E[4*k+1]=s[3*k+1],E[4*k+2]=s[3*k+2],E[4*k+3]=1;m(l.width,l.height,I.generateMipMaps,!1,(()=>{const V=I.getEngine();I.type=1,I.format=5,I._gammaSpace=!1,V._uploadDataToTextureDirectly(I,E)}))}}}}]);