"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[31],{13789:(G,V,W)=>{W.r(V),W.d(V,{_HDRTextureLoader:()=>A});var J=W(11136);class R{static ConvertPanoramaToCubemap(G,V,W,J){let R=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!G)throw"ConvertPanoramaToCubemap: input cannot be null";if(G.length!=V*W*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(J,this.FACE_FRONT,G,V,W,R),back:this.CreateCubemapTexture(J,this.FACE_BACK,G,V,W,R),left:this.CreateCubemapTexture(J,this.FACE_LEFT,G,V,W,R),right:this.CreateCubemapTexture(J,this.FACE_RIGHT,G,V,W,R),up:this.CreateCubemapTexture(J,this.FACE_UP,G,V,W,R),down:this.CreateCubemapTexture(J,this.FACE_DOWN,G,V,W,R),size:J,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(G,V,W,J,R){let d=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const k=new ArrayBuffer(G*G*4*3),z=new Float32Array(k),X=d?Math.max(1,Math.round(J/4/G)):1,P=1/X,A=P*P,x=V[1].zW(V[0]).scale(P/G),q=V[3].zW(V[2]).scale(P/G),L=1/G;let t=0;for(let Y=0;Y<G;Y++)for(let d=0;d<X;d++){let d=V[0],k=V[2];for(let V=0;V<G;V++)for(let P=0;P<X;P++){const X=k.zW(d).scale(t).add(d);X.normalize();const P=this.CalcProjectionSpherical(X,W,J,R);z[Y*G*3+3*V+0]+=P.r*A,z[Y*G*3+3*V+1]+=P.g*A,z[Y*G*3+3*V+2]+=P.b*A,d=d.add(x),k=k.add(q)}t+=L*P}return z}static CalcProjectionSpherical(G,V,W,J){let R=Math.atan2(G.z,G.x);const d=Math.acos(G.y);for(;R<-Math.PI;)R+=2*Math.PI;for(;R>Math.PI;)R-=2*Math.PI;let k=R/Math.PI;const z=d/Math.PI;k=.5*k+.5;let X=Math.round(k*W);X<0?X=0:X>=W&&(X=W-1);let P=Math.round(z*J);P<0?P=0:P>=J&&(P=J-1);const A=J-P-1;return{r:V[A*W*3+3*X+0],g:V[A*W*3+3*X+1],b:V[A*W*3+3*X+2]}}}function d(G,V,W,J,R,d){R>0?(R=function(G,V){return V>1023?G*Math.pow(2,1023)*Math.pow(2,V-1023):V<-1074?G*Math.pow(2,-1074)*Math.pow(2,V+1074):G*Math.pow(2,V)}(1,R-136),G[d+0]=V*R,G[d+1]=W*R,G[d+2]=J*R):(G[d+0]=0,G[d+1]=0,G[d+2]=0)}function k(G,V){let W="",J="";for(let R=V;R<G.length-V&&(J=String.fromCharCode(G[R]),"\n"!=J);R++)W+=J;return W}function z(G){let V=0,W=0,J=k(G,0);if("#"!=J[0]||"?"!=J[1])throw"Bad HDR Format.";let R=!1,d=!1,z=0;do{z+=J.length+1,J=k(G,z),"FORMAT=32-bit_rle_rgbe"==J?d=!0:0==J.length&&(R=!0)}while(!R);if(!d)throw"HDR Bad header format, unsupported FORMAT";z+=J.length+1,J=k(G,z);const X=/^-Y (.*) \+X (.*)$/g.exec(J);if(!X||X.length<3)throw"HDR Bad header format, no size";if(W=parseInt(X[2]),V=parseInt(X[1]),W<8||W>32767)throw"HDR Bad header format, unsupported size";return z+=J.length+1,{height:V,width:W,dataPosition:z}}function X(G,V){return function(G,V){let W=V.height;const J=V.width;let R,k,z,X,A,x=V.dataPosition,q=0,L=0,t=0;const Y=new ArrayBuffer(4*J),g=new Uint8Array(Y),B=new ArrayBuffer(V.width*V.height*4*3),S=new Float32Array(B);for(;W>0;){if(R=G[x++],k=G[x++],z=G[x++],X=G[x++],2!=R||2!=k||128&z||V.width<8||V.width>32767)return P(G,V);if((z<<8|X)!=J)throw"HDR Bad header format, wrong scan line width";for(q=0,t=0;t<4;t++)for(L=(t+1)*J;q<L;)if(R=G[x++],k=G[x++],R>128){if(A=R-128,0==A||A>L-q)throw"HDR Bad Format, bad scanline data (run)";for(;A-- >0;)g[q++]=k}else{if(A=R,0==A||A>L-q)throw"HDR Bad Format, bad scanline data (non-run)";if(g[q++]=k,--A>0)for(let V=0;V<A;V++)g[q++]=G[x++]}for(t=0;t<J;t++)R=g[t],k=g[t+J],z=g[t+2*J],X=g[t+3*J],d(S,R,k,z,X,(V.height-W)*J*3+3*t);W--}return S}(G,V)}function P(G,V){let W=V.height;const J=V.width;let R,k,z,X,P,A=V.dataPosition;const x=new ArrayBuffer(V.width*V.height*4*3),q=new Float32Array(x);for(;W>0;){for(P=0;P<V.width;P++)R=G[A++],k=G[A++],z=G[A++],X=G[A++],d(q,R,k,z,X,(V.height-W)*J*3+3*P);W--}return q}R.FACE_LEFT=[new J.o(-1,-1,-1),new J.o(1,-1,-1),new J.o(-1,1,-1),new J.o(1,1,-1)],R.FACE_RIGHT=[new J.o(1,-1,1),new J.o(-1,-1,1),new J.o(1,1,1),new J.o(-1,1,1)],R.FACE_FRONT=[new J.o(1,-1,-1),new J.o(1,-1,1),new J.o(1,1,-1),new J.o(1,1,1)],R.FACE_BACK=[new J.o(-1,-1,1),new J.o(-1,-1,-1),new J.o(-1,1,1),new J.o(-1,1,-1)],R.FACE_DOWN=[new J.o(1,1,-1),new J.o(1,1,1),new J.o(-1,1,-1),new J.o(-1,1,1)],R.FACE_UP=[new J.o(-1,-1,-1),new J.o(-1,-1,1),new J.o(1,-1,-1),new J.o(1,-1,1)];class A{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(G,V,W){const J=new Uint8Array(G.buffer,G.byteOffset,G.byteLength),R=z(J),d=X(J,R),k=R.width*R.height,P=new Float32Array(4*k);for(let z=0;z<k;z+=1)P[4*z]=d[3*z],P[4*z+1]=d[3*z+1],P[4*z+2]=d[3*z+2],P[4*z+3]=1;W(R.width,R.height,V.generateMipMaps,!1,(()=>{const G=V.getEngine();V.type=1,V.format=5,V._gammaSpace=!1,G._uploadDataToTextureDirectly(V,P)}))}}}}]);