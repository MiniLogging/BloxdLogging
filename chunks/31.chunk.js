"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[31],{13226:(z,u,Y)=>{Y.r(u),Y.d(u,{_HDRTextureLoader:()=>D});var H=Y(10903);class E{static ConvertPanoramaToCubemap(z,u,Y,H){let E=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!z)throw"ConvertPanoramaToCubemap: input cannot be null";if(z.length!=u*Y*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(H,this.FACE_FRONT,z,u,Y,E),back:this.CreateCubemapTexture(H,this.FACE_BACK,z,u,Y,E),left:this.CreateCubemapTexture(H,this.FACE_LEFT,z,u,Y,E),right:this.CreateCubemapTexture(H,this.FACE_RIGHT,z,u,Y,E),up:this.CreateCubemapTexture(H,this.FACE_UP,z,u,Y,E),down:this.CreateCubemapTexture(H,this.FACE_DOWN,z,u,Y,E),size:H,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(z,u,Y,H,E){let J=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const l=new ArrayBuffer(z*z*4*3),T=new Float32Array(l),b=J?Math.max(1,Math.round(H/4/z)):1,L=1/b,D=L*L,g=u[1].JY(u[0]).scale(L/z),M=u[3].JY(u[2]).scale(L/z),q=1/z;let C=0;for(let K=0;K<z;K++)for(let J=0;J<b;J++){let J=u[0],l=u[2];for(let u=0;u<z;u++)for(let L=0;L<b;L++){const b=l.JY(J).scale(C).add(J);b.normalize();const L=this.CalcProjectionSpherical(b,Y,H,E);T[K*z*3+3*u+0]+=L.r*D,T[K*z*3+3*u+1]+=L.g*D,T[K*z*3+3*u+2]+=L.b*D,J=J.add(g),l=l.add(M)}C+=q*L}return T}static CalcProjectionSpherical(z,u,Y,H){let E=Math.atan2(z.z,z.x);const J=Math.acos(z.y);for(;E<-Math.PI;)E+=2*Math.PI;for(;E>Math.PI;)E-=2*Math.PI;let l=E/Math.PI;const T=J/Math.PI;l=.5*l+.5;let b=Math.round(l*Y);b<0?b=0:b>=Y&&(b=Y-1);let L=Math.round(T*H);L<0?L=0:L>=H&&(L=H-1);const D=H-L-1;return{r:u[D*Y*3+3*b+0],g:u[D*Y*3+3*b+1],b:u[D*Y*3+3*b+2]}}}function J(z,u,Y,H,E,J){E>0?(E=function(z,u){return u>1023?z*Math.pow(2,1023)*Math.pow(2,u-1023):u<-1074?z*Math.pow(2,-1074)*Math.pow(2,u+1074):z*Math.pow(2,u)}(1,E-136),z[J+0]=u*E,z[J+1]=Y*E,z[J+2]=H*E):(z[J+0]=0,z[J+1]=0,z[J+2]=0)}function l(z,u){let Y="",H="";for(let E=u;E<z.length-u&&(H=String.fromCharCode(z[E]),"\n"!=H);E++)Y+=H;return Y}function T(z){let u=0,Y=0,H=l(z,0);if("#"!=H[0]||"?"!=H[1])throw"Bad HDR Format.";let E=!1,J=!1,T=0;do{T+=H.length+1,H=l(z,T),"FORMAT=32-bit_rle_rgbe"==H?J=!0:0==H.length&&(E=!0)}while(!E);if(!J)throw"HDR Bad header format, unsupported FORMAT";T+=H.length+1,H=l(z,T);const b=/^-Y (.*) \+X (.*)$/g.exec(H);if(!b||b.length<3)throw"HDR Bad header format, no size";if(Y=parseInt(b[2]),u=parseInt(b[1]),Y<8||Y>32767)throw"HDR Bad header format, unsupported size";return T+=H.length+1,{height:u,width:Y,dataPosition:T}}function b(z,u){return function(z,u){let Y=u.height;const H=u.width;let E,l,T,b,D,g=u.dataPosition,M=0,q=0,C=0;const K=new ArrayBuffer(4*H),h=new Uint8Array(K),o=new ArrayBuffer(u.width*u.height*4*3),d=new Float32Array(o);for(;Y>0;){if(E=z[g++],l=z[g++],T=z[g++],b=z[g++],2!=E||2!=l||128&T||u.width<8||u.width>32767)return L(z,u);if((T<<8|b)!=H)throw"HDR Bad header format, wrong scan line width";for(M=0,C=0;C<4;C++)for(q=(C+1)*H;M<q;)if(E=z[g++],l=z[g++],E>128){if(D=E-128,0==D||D>q-M)throw"HDR Bad Format, bad scanline data (run)";for(;D-- >0;)h[M++]=l}else{if(D=E,0==D||D>q-M)throw"HDR Bad Format, bad scanline data (non-run)";if(h[M++]=l,--D>0)for(let u=0;u<D;u++)h[M++]=z[g++]}for(C=0;C<H;C++)E=h[C],l=h[C+H],T=h[C+2*H],b=h[C+3*H],J(d,E,l,T,b,(u.height-Y)*H*3+3*C);Y--}return d}(z,u)}function L(z,u){let Y=u.height;const H=u.width;let E,l,T,b,L,D=u.dataPosition;const g=new ArrayBuffer(u.width*u.height*4*3),M=new Float32Array(g);for(;Y>0;){for(L=0;L<u.width;L++)E=z[D++],l=z[D++],T=z[D++],b=z[D++],J(M,E,l,T,b,(u.height-Y)*H*3+3*L);Y--}return M}E.FACE_LEFT=[new H.p(-1,-1,-1),new H.p(1,-1,-1),new H.p(-1,1,-1),new H.p(1,1,-1)],E.FACE_RIGHT=[new H.p(1,-1,1),new H.p(-1,-1,1),new H.p(1,1,1),new H.p(-1,1,1)],E.FACE_FRONT=[new H.p(1,-1,-1),new H.p(1,-1,1),new H.p(1,1,-1),new H.p(1,1,1)],E.FACE_BACK=[new H.p(-1,-1,1),new H.p(-1,-1,-1),new H.p(-1,1,1),new H.p(-1,1,-1)],E.FACE_DOWN=[new H.p(1,1,-1),new H.p(1,1,1),new H.p(-1,1,-1),new H.p(-1,1,1)],E.FACE_UP=[new H.p(-1,-1,-1),new H.p(-1,-1,1),new H.p(1,-1,-1),new H.p(1,-1,1)];class D{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(z,u,Y){const H=new Uint8Array(z.buffer,z.byteOffset,z.byteLength),E=T(H),J=b(H,E),l=E.width*E.height,L=new Float32Array(4*l);for(let T=0;T<l;T+=1)L[4*T]=J[3*T],L[4*T+1]=J[3*T+1],L[4*T+2]=J[3*T+2],L[4*T+3]=1;Y(E.width,E.height,u.generateMipMaps,!1,(()=>{const z=u.getEngine();u.type=1,u.format=5,u._gammaSpace=!1,z._uploadDataToTextureDirectly(u,L)}))}}}}]);