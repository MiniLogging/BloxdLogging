"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[31],{13509:(s,Z,o)=>{o.r(Z),o.d(Z,{_HDRTextureLoader:()=>B});var t=o(10900);class j{static ConvertPanoramaToCubemap(s,Z,o,t){let j=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!s)throw"ConvertPanoramaToCubemap: input cannot be null";if(s.length!=Z*o*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(t,this.FACE_FRONT,s,Z,o,j),back:this.CreateCubemapTexture(t,this.FACE_BACK,s,Z,o,j),left:this.CreateCubemapTexture(t,this.FACE_LEFT,s,Z,o,j),right:this.CreateCubemapTexture(t,this.FACE_RIGHT,s,Z,o,j),up:this.CreateCubemapTexture(t,this.FACE_UP,s,Z,o,j),down:this.CreateCubemapTexture(t,this.FACE_DOWN,s,Z,o,j),size:t,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(s,Z,o,t,j){let S=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const a=new ArrayBuffer(s*s*4*3),O=new Float32Array(a),v=S?Math.max(1,Math.round(t/4/s)):1,G=1/v,B=G*G,Q=Z[1].Go(Z[0]).scale(G/s),D=Z[3].Go(Z[2]).scale(G/s),z=1/s;let Y=0;for(let b=0;b<s;b++)for(let S=0;S<v;S++){let S=Z[0],a=Z[2];for(let Z=0;Z<s;Z++)for(let G=0;G<v;G++){const v=a.Go(S).scale(Y).add(S);v.normalize();const G=this.CalcProjectionSpherical(v,o,t,j);O[b*s*3+3*Z+0]+=G.r*B,O[b*s*3+3*Z+1]+=G.g*B,O[b*s*3+3*Z+2]+=G.b*B,S=S.add(Q),a=a.add(D)}Y+=z*G}return O}static CalcProjectionSpherical(s,Z,o,t){let j=Math.atan2(s.z,s.x);const S=Math.acos(s.y);for(;j<-Math.PI;)j+=2*Math.PI;for(;j>Math.PI;)j-=2*Math.PI;let a=j/Math.PI;const O=S/Math.PI;a=.5*a+.5;let v=Math.round(a*o);v<0?v=0:v>=o&&(v=o-1);let G=Math.round(O*t);G<0?G=0:G>=t&&(G=t-1);const B=t-G-1;return{r:Z[B*o*3+3*v+0],g:Z[B*o*3+3*v+1],b:Z[B*o*3+3*v+2]}}}function S(s,Z,o,t,j,S){j>0?(j=function(s,Z){return Z>1023?s*Math.pow(2,1023)*Math.pow(2,Z-1023):Z<-1074?s*Math.pow(2,-1074)*Math.pow(2,Z+1074):s*Math.pow(2,Z)}(1,j-136),s[S+0]=Z*j,s[S+1]=o*j,s[S+2]=t*j):(s[S+0]=0,s[S+1]=0,s[S+2]=0)}function a(s,Z){let o="",t="";for(let j=Z;j<s.length-Z&&(t=String.fromCharCode(s[j]),"\n"!=t);j++)o+=t;return o}function O(s){let Z=0,o=0,t=a(s,0);if("#"!=t[0]||"?"!=t[1])throw"Bad HDR Format.";let j=!1,S=!1,O=0;do{O+=t.length+1,t=a(s,O),"FORMAT=32-bit_rle_rgbe"==t?S=!0:0==t.length&&(j=!0)}while(!j);if(!S)throw"HDR Bad header format, unsupported FORMAT";O+=t.length+1,t=a(s,O);const v=/^-Y (.*) \+X (.*)$/g.exec(t);if(!v||v.length<3)throw"HDR Bad header format, no size";if(o=parseInt(v[2]),Z=parseInt(v[1]),o<8||o>32767)throw"HDR Bad header format, unsupported size";return O+=t.length+1,{height:Z,width:o,dataPosition:O}}function v(s,Z){return function(s,Z){let o=Z.height;const t=Z.width;let j,a,O,v,B,Q=Z.dataPosition,D=0,z=0,Y=0;const b=new ArrayBuffer(4*t),f=new Uint8Array(b),A=new ArrayBuffer(Z.width*Z.height*4*3),d=new Float32Array(A);for(;o>0;){if(j=s[Q++],a=s[Q++],O=s[Q++],v=s[Q++],2!=j||2!=a||128&O||Z.width<8||Z.width>32767)return G(s,Z);if((O<<8|v)!=t)throw"HDR Bad header format, wrong scan line width";for(D=0,Y=0;Y<4;Y++)for(z=(Y+1)*t;D<z;)if(j=s[Q++],a=s[Q++],j>128){if(B=j-128,0==B||B>z-D)throw"HDR Bad Format, bad scanline data (run)";for(;B-- >0;)f[D++]=a}else{if(B=j,0==B||B>z-D)throw"HDR Bad Format, bad scanline data (non-run)";if(f[D++]=a,--B>0)for(let Z=0;Z<B;Z++)f[D++]=s[Q++]}for(Y=0;Y<t;Y++)j=f[Y],a=f[Y+t],O=f[Y+2*t],v=f[Y+3*t],S(d,j,a,O,v,(Z.height-o)*t*3+3*Y);o--}return d}(s,Z)}function G(s,Z){let o=Z.height;const t=Z.width;let j,a,O,v,G,B=Z.dataPosition;const Q=new ArrayBuffer(Z.width*Z.height*4*3),D=new Float32Array(Q);for(;o>0;){for(G=0;G<Z.width;G++)j=s[B++],a=s[B++],O=s[B++],v=s[B++],S(D,j,a,O,v,(Z.height-o)*t*3+3*G);o--}return D}j.FACE_LEFT=[new t.n(-1,-1,-1),new t.n(1,-1,-1),new t.n(-1,1,-1),new t.n(1,1,-1)],j.FACE_RIGHT=[new t.n(1,-1,1),new t.n(-1,-1,1),new t.n(1,1,1),new t.n(-1,1,1)],j.FACE_FRONT=[new t.n(1,-1,-1),new t.n(1,-1,1),new t.n(1,1,-1),new t.n(1,1,1)],j.FACE_BACK=[new t.n(-1,-1,1),new t.n(-1,-1,-1),new t.n(-1,1,1),new t.n(-1,1,-1)],j.FACE_DOWN=[new t.n(1,1,-1),new t.n(1,1,1),new t.n(-1,1,-1),new t.n(-1,1,1)],j.FACE_UP=[new t.n(-1,-1,-1),new t.n(-1,-1,1),new t.n(1,-1,-1),new t.n(1,-1,1)];class B{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(s,Z,o){const t=new Uint8Array(s.buffer,s.byteOffset,s.byteLength),j=O(t),S=v(t,j),a=j.width*j.height,G=new Float32Array(4*a);for(let O=0;O<a;O+=1)G[4*O]=S[3*O],G[4*O+1]=S[3*O+1],G[4*O+2]=S[3*O+2],G[4*O+3]=1;o(j.width,j.height,Z.generateMipMaps,!1,(()=>{const s=Z.getEngine();Z.type=1,Z.format=5,Z._gammaSpace=!1,s._uploadDataToTextureDirectly(Z,G)}))}}}}]);