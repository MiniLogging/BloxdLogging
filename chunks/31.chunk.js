"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[31],{13588:(Z,c,L)=>{L.r(c),L.d(c,{_HDRTextureLoader:()=>z});var k=L(10993);class N{static ConvertPanoramaToCubemap(Z,c,L,k){let N=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Z)throw"ConvertPanoramaToCubemap: input cannot be null";if(Z.length!=c*L*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(k,this.FACE_FRONT,Z,c,L,N),back:this.CreateCubemapTexture(k,this.FACE_BACK,Z,c,L,N),left:this.CreateCubemapTexture(k,this.FACE_LEFT,Z,c,L,N),right:this.CreateCubemapTexture(k,this.FACE_RIGHT,Z,c,L,N),up:this.CreateCubemapTexture(k,this.FACE_UP,Z,c,L,N),down:this.CreateCubemapTexture(k,this.FACE_DOWN,Z,c,L,N),size:k,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(Z,c,L,k,N){let R=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const G=new ArrayBuffer(Z*Z*4*3),V=new Float32Array(G),p=R?Math.max(1,Math.round(k/4/Z)):1,J=1/p,z=J*J,i=c[1].yL(c[0]).scale(J/Z),t=c[3].yL(c[2]).scale(J/Z),E=1/Z;let x=0;for(let q=0;q<Z;q++)for(let R=0;R<p;R++){let R=c[0],G=c[2];for(let c=0;c<Z;c++)for(let J=0;J<p;J++){const p=G.yL(R).scale(x).add(R);p.normalize();const J=this.CalcProjectionSpherical(p,L,k,N);V[q*Z*3+3*c+0]+=J.r*z,V[q*Z*3+3*c+1]+=J.g*z,V[q*Z*3+3*c+2]+=J.b*z,R=R.add(i),G=G.add(t)}x+=E*J}return V}static CalcProjectionSpherical(Z,c,L,k){let N=Math.atan2(Z.z,Z.x);const R=Math.acos(Z.y);for(;N<-Math.PI;)N+=2*Math.PI;for(;N>Math.PI;)N-=2*Math.PI;let G=N/Math.PI;const V=R/Math.PI;G=.5*G+.5;let p=Math.round(G*L);p<0?p=0:p>=L&&(p=L-1);let J=Math.round(V*k);J<0?J=0:J>=k&&(J=k-1);const z=k-J-1;return{r:c[z*L*3+3*p+0],g:c[z*L*3+3*p+1],b:c[z*L*3+3*p+2]}}}function R(Z,c,L,k,N,R){N>0?(N=function(Z,c){return c>1023?Z*Math.pow(2,1023)*Math.pow(2,c-1023):c<-1074?Z*Math.pow(2,-1074)*Math.pow(2,c+1074):Z*Math.pow(2,c)}(1,N-136),Z[R+0]=c*N,Z[R+1]=L*N,Z[R+2]=k*N):(Z[R+0]=0,Z[R+1]=0,Z[R+2]=0)}function G(Z,c){let L="",k="";for(let N=c;N<Z.length-c&&(k=String.fromCharCode(Z[N]),"\n"!=k);N++)L+=k;return L}function V(Z){let c=0,L=0,k=G(Z,0);if("#"!=k[0]||"?"!=k[1])throw"Bad HDR Format.";let N=!1,R=!1,V=0;do{V+=k.length+1,k=G(Z,V),"FORMAT=32-bit_rle_rgbe"==k?R=!0:0==k.length&&(N=!0)}while(!N);if(!R)throw"HDR Bad header format, unsupported FORMAT";V+=k.length+1,k=G(Z,V);const p=/^-Y (.*) \+X (.*)$/g.exec(k);if(!p||p.length<3)throw"HDR Bad header format, no size";if(L=parseInt(p[2]),c=parseInt(p[1]),L<8||L>32767)throw"HDR Bad header format, unsupported size";return V+=k.length+1,{height:c,width:L,dataPosition:V}}function p(Z,c){return function(Z,c){let L=c.height;const k=c.width;let N,G,V,p,z,i=c.dataPosition,t=0,E=0,x=0;const q=new ArrayBuffer(4*k),O=new Uint8Array(q),w=new ArrayBuffer(c.width*c.height*4*3),M=new Float32Array(w);for(;L>0;){if(N=Z[i++],G=Z[i++],V=Z[i++],p=Z[i++],2!=N||2!=G||128&V||c.width<8||c.width>32767)return J(Z,c);if((V<<8|p)!=k)throw"HDR Bad header format, wrong scan line width";for(t=0,x=0;x<4;x++)for(E=(x+1)*k;t<E;)if(N=Z[i++],G=Z[i++],N>128){if(z=N-128,0==z||z>E-t)throw"HDR Bad Format, bad scanline data (run)";for(;z-- >0;)O[t++]=G}else{if(z=N,0==z||z>E-t)throw"HDR Bad Format, bad scanline data (non-run)";if(O[t++]=G,--z>0)for(let c=0;c<z;c++)O[t++]=Z[i++]}for(x=0;x<k;x++)N=O[x],G=O[x+k],V=O[x+2*k],p=O[x+3*k],R(M,N,G,V,p,(c.height-L)*k*3+3*x);L--}return M}(Z,c)}function J(Z,c){let L=c.height;const k=c.width;let N,G,V,p,J,z=c.dataPosition;const i=new ArrayBuffer(c.width*c.height*4*3),t=new Float32Array(i);for(;L>0;){for(J=0;J<c.width;J++)N=Z[z++],G=Z[z++],V=Z[z++],p=Z[z++],R(t,N,G,V,p,(c.height-L)*k*3+3*J);L--}return t}N.FACE_LEFT=[new k.h(-1,-1,-1),new k.h(1,-1,-1),new k.h(-1,1,-1),new k.h(1,1,-1)],N.FACE_RIGHT=[new k.h(1,-1,1),new k.h(-1,-1,1),new k.h(1,1,1),new k.h(-1,1,1)],N.FACE_FRONT=[new k.h(1,-1,-1),new k.h(1,-1,1),new k.h(1,1,-1),new k.h(1,1,1)],N.FACE_BACK=[new k.h(-1,-1,1),new k.h(-1,-1,-1),new k.h(-1,1,1),new k.h(-1,1,-1)],N.FACE_DOWN=[new k.h(1,1,-1),new k.h(1,1,1),new k.h(-1,1,-1),new k.h(-1,1,1)],N.FACE_UP=[new k.h(-1,-1,-1),new k.h(-1,-1,1),new k.h(1,-1,-1),new k.h(1,-1,1)];class z{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(Z,c,L){const k=new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength),N=V(k),R=p(k,N),G=N.width*N.height,J=new Float32Array(4*G);for(let V=0;V<G;V+=1)J[4*V]=R[3*V],J[4*V+1]=R[3*V+1],J[4*V+2]=R[3*V+2],J[4*V+3]=1;L(N.width,N.height,c.generateMipMaps,!1,(()=>{const Z=c.getEngine();c.type=1,c.format=5,c._gammaSpace=!1,Z._uploadDataToTextureDirectly(c,J)}))}}}}]);