"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[62],{14242:(Q,X,C)=>{C.r(X),C.d(X,{AnimationGroup:()=>x,TargetedAnimation:()=>z});var l=C(12229),h=C(482),M=C(524),f=C(633),O=C(12994),m=C(668);class W{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(Q,X,C,h){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=X,this._target=Q,this._scene=C,this._host=h,this._activeTargets=[],X._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===l.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=m.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const Q={frame:0,value:this._minValue};this._keys.splice(0,0,Q)}if(this._target instanceof Array){let Q=0;for(const X of this._target)this._preparePath(X,Q),this._getOriginalValues(Q),Q++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const M=X.getEvents();if(M&&M.length>0)for(const l of M)this._events.push(l._clone());this._enableBlending=Q&&Q.animationPropertiesOverride?Q.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(Q){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this._animation.targetPropertyPath;if(C.length>1){let l=Q;for(let Q=0;Q<C.length-1;Q++){const X=C[Q];if(l=l[X],void 0===l)throw new Error(`Invalid property (${X}) in property path (${C.join(".")})`)}this._targetPath=C[C.length-1],this._activeTargets[X]=l}else this._targetPath=C[0],this._activeTargets[X]=Q;if(void 0===this._activeTargets[X][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${C.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let Q=0;for(const X of this._target)void 0!==this._originalValue[Q]&&this._setValue(X,this._activeTargets[Q],this._originalValue[Q],-1,Q),Q++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let Q=0;Q<this._events.length;Q++)this._events[Q].isDone=!1}isStopped(){return this._stopped}dispose(){const Q=this._animation.runtimeAnimations.indexOf(this);Q>-1&&this._animation.runtimeAnimations.splice(Q,1)}setValue(Q,X){if(this._targetIsArray)for(let C=0;C<this._target.length;C++){const l=this._target[C];this._setValue(l,this._activeTargets[C],Q,X,C)}else this._setValue(this._target,this._directTarget,Q,X,0)}_getOriginalValues(){let Q,X=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const C=this._activeTargets[X];Q=C.getLocalMatrix&&"_matrix"===this._targetPath?C.getLocalMatrix():C[this._targetPath],Q&&Q.clone?this._originalValue[X]=Q.clone():this._originalValue[X]=Q}_registerTargetForLateAnimationBinding(Q,X){const C=Q.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(C),C._lateAnimationHolders||(C._lateAnimationHolders={}),C._lateAnimationHolders[Q.targetPath]||(C._lateAnimationHolders[Q.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:X}),Q.isAdditive?(C._lateAnimationHolders[Q.targetPath].additiveAnimations.push(Q),C._lateAnimationHolders[Q.targetPath].totalAdditiveWeight+=Q.weight):(C._lateAnimationHolders[Q.targetPath].animations.push(Q),C._lateAnimationHolders[Q.targetPath].totalWeight+=Q.weight)}_setValue(Q,X,C,h,M){if(this._currentActiveTarget=X,this._weight=h,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const Q=X[this._targetPath];Q.clone?this._originalBlendValue=Q.clone():this._originalBlendValue=Q}this._originalBlendValue.m?l.e.AllowMatrixDecomposeForInterpolation?this._currentValue?m.b.DecomposeLerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=m.b.DecomposeLerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue?m.b.LerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=m.b.Lerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue=l.e._UniversalLerp(this._originalBlendValue,C,this._blendingFactor);const h=Q&&Q.animationPropertiesOverride?Q.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=h}else this._currentValue?this._currentValue.p?this._currentValue.p(C):this._currentValue=C:null!==C&&void 0!==C&&C.clone?this._currentValue=C.clone():this._currentValue=C;-1!==h?this._registerTargetForLateAnimationBinding(this,this._originalValue[M]):this._animationState.loopMode===l.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[M],X[this._targetPath]):X[this._targetPath]=this._originalValue[M]+this._currentValue:X[this._targetPath]=this._currentValue,Q.Uj&&Q.Uj(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(Q){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const C=this._animation.getKeys();Q<C[0].frame?Q=C[0].frame:Q>C[C.length-1].frame&&(Q=C[C.length-1].frame);const l=this._events;if(l.length)for(let M=0;M<l.length;M++)l[M].onlyOnce||(l[M].isDone=l[M].frame<Q);this._currentFrame=Q;const h=this._animation._interpolate(Q,this._animationState);this.setValue(h,X)}_prepareForSpeedRatioChange(Q){const X=this._previousElapsedTime*(this._animation.framePerSecond*Q)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-X}animate(Q,X,C,h,M){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const O=this._animation,m=O.targetPropertyPath;if(!m||m.length<1)return this._stopped=!0,!1;let W,U=!0;const L=this._events;let w=0;if(this._coreRuntimeAnimation)w=C-X,W=this._coreRuntimeAnimation.currentFrame,this._currentFrame=W,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let f;(X<this._minFrame||X>this._maxFrame)&&(X=this._minFrame),(C<this._minFrame||C>this._maxFrame)&&(C=this._maxFrame),w=C-X;let m=Q*(O.framePerSecond*M)/1e3+this._absoluteFrameOffset,i=0,a=!1;const F=h&&this._animationState.loopMode===l.e.ANIMATIONLOOPMODE_YOYO;if(F){const Q=(m-X)/w,C=Math.sin(Q*Math.PI);m=Math.abs(C)*w+X;const l=C>=0?1:-1;this._yoyoDirection!==l&&(a=!0),this._yoyoDirection=l}if(this._previousElapsedTime=Q,this._previousAbsoluteFrame=m,!h&&C>=X&&(m>=w&&M>0||m<=0&&M<0))U=!1,i=O._getKeyValue(this._maxValue);else if(!h&&X>=C&&(m<=w&&M<0||m>=0&&M>0))U=!1,i=O._getKeyValue(this._minValue);else if(this._animationState.loopMode!==l.e.ANIMATIONLOOPMODE_CYCLE){const Q=C.toString()+X.toString();if(!this._offsetsCache[Q]){this._animationState.repeatCount=0,this._animationState.loopMode=l.e.ANIMATIONLOOPMODE_CYCLE;const h=O._interpolate(X,this._animationState),M=O._interpolate(C,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),O.dataType){case l.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[Q]=M-h;break;case l.e.ANIMATIONTYPE_QUATERNION:case l.e.ANIMATIONTYPE_VECTOR3:case l.e.ANIMATIONTYPE_VECTOR2:case l.e.ANIMATIONTYPE_SIZE:case l.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[Q]=M.Od(h)}this._highLimitsCache[Q]=M}i=this._highLimitsCache[Q],f=this._offsetsCache[Q]}if(void 0===f)switch(O.dataType){case l.e.ANIMATIONTYPE_FLOAT:f=0;break;case l.e.ANIMATIONTYPE_QUATERNION:f=l.h;break;case l.e.ANIMATIONTYPE_VECTOR3:f=l.p;break;case l.e.ANIMATIONTYPE_VECTOR2:f=l.o;break;case l.e.ANIMATIONTYPE_SIZE:f=l.l;break;case l.e.ANIMATIONTYPE_COLOR3:f=l.f;break;case l.e.ANIMATIONTYPE_COLOR4:f=l.g}if(this._host&&this._host.syncRoot){const Q=this._host.syncRoot;W=X+w*((Q.masterFrame-Q.fromFrame)/(Q.toFrame-Q.fromFrame))}else W=m>0&&X>C||m<0&&X<C?U&&0!==w?C+m%w:X:U&&0!==w?X+m%w:C;if(!F&&(M>0&&this.currentFrame>W||M<0&&this.currentFrame<W)||F&&a){this._onLoop();for(let Q=0;Q<L.length;Q++)L[Q].onlyOnce||(L[Q].isDone=!1);this._animationState.key=M>0?0:O.getKeys().length-1}this._currentFrame=W,this._animationState.repeatCount=0===w?0:m/w|0,this._animationState.highLimitValue=i,this._animationState.offsetValue=f}const i=O._interpolate(W,this._animationState);if(this.setValue(i,f),L.length)for(let l=0;l<L.length;l++)if(w>=0&&W>=L[l].frame&&L[l].frame>=X||w<0&&W<=L[l].frame&&L[l].frame<=X){const Q=L[l];Q.isDone||(Q.onlyOnce&&(L.splice(l,1),l--),Q.isDone=!0,Q.action(W))}return U||(this._stopped=!0),U}}var U=C(507);class L{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(Q){this._weight=-1!==Q?Math.min(Math.max(Q,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(Q){for(let X=0;X<this._runtimeAnimations.length;X++){this._runtimeAnimations[X]._prepareForSpeedRatioChange(Q)}this._speedRatio=Q,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(Q,X){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,M=arguments.length>4&&void 0!==arguments[4]&&arguments[4],f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,O=arguments.length>6?arguments[6]:void 0,m=arguments.length>7?arguments[7]:void 0,W=arguments.length>8?arguments[8]:void 0,U=arguments.length>9&&void 0!==arguments[9]&&arguments[9],L=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=X,this.fromFrame=C,this.toFrame=l,this.loopAnimation=M,this.onAnimationEnd=O,this.onAnimationLoop=W,this.isAdditive=U,this.playOrder=L,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Pj=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new h.e,this.onAnimationLoopObservable=new h.e,this._scene=Q,m&&this.appendAnimations(X,m),this._speedRatio=f,Q._activeAnimatables.push(this)}syncWith(Q){if(this._syncRoot=Q,Q){const Q=this._scene._activeAnimatables.indexOf(this);Q>-1&&(this._scene._activeAnimatables.splice(Q,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(Q,X){for(let C=0;C<X.length;C++){const l=X[C],h=new W(Q,l,this._scene,this);h._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(h)}}getAnimationByTargetProperty(Q){const X=this._runtimeAnimations;for(let C=0;C<X.length;C++)if(X[C].animation.targetProperty===Q)return X[C].animation;return null}getRuntimeAnimationByTargetProperty(Q){const X=this._runtimeAnimations;for(let C=0;C<X.length;C++)if(X[C].animation.targetProperty===Q)return X[C];return null}reset(){const Q=this._runtimeAnimations;for(let X=0;X<Q.length;X++)Q[X].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(Q){const X=this._runtimeAnimations;for(let C=0;C<X.length;C++)X[C].animation.enableBlending=!0,X[C].animation.blendingSpeed=Q}disableBlending(){const Q=this._runtimeAnimations;for(let X=0;X<Q.length;X++)Q[X].animation.enableBlending=!1}goToFrame(Q){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const C=this._runtimeAnimations;if(C[0]){const X=C[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??C[0].currentFrame;const l=0===this.speedRatio?0:(Q-this._frameToSyncFromJump)/X*1e3/this.speedRatio;this._manualJumpDelay=-l}for(let l=0;l<C.length;l++)C[l].goToFrame(Q,X?this._weight:-1);this._goToFrame=Q}get paused(){return this.Pj}pause(){this.Pj||(this.Pj=!0)}restart(){this.Pj=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(Q,X){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],l=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Q||X){const h=this._scene._activeAnimatables.indexOf(this);if(h>-1){const M=this._runtimeAnimations;for(let C=M.length-1;C>=0;C--){const l=M[C];Q&&l.animation.name!=Q||(X&&!X(l.target)||(l.dispose(),M.splice(C,1)))}0==M.length&&(C||this._scene._activeAnimatables.splice(h,1),l||this._raiseOnAnimationEnd())}}else{const Q=this._scene._activeAnimatables.indexOf(this);if(Q>-1){C||this._scene._activeAnimatables.splice(Q,1);const X=this._runtimeAnimations;for(let Q=0;Q<X.length;Q++)X[Q].dispose();this._runtimeAnimations.length=0,l||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((Q=>{this.onAnimationEndObservable.add((()=>{Q(this)}),void 0,void 0,this,!0)}))}_animate(Q){if(this.Pj)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=Q),!0;if(null===this._localDelayOffset?(this._localDelayOffset=Q,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=Q-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let X=!1;const C=this._runtimeAnimations;let l;for(l=0;l<C.length;l++){const h=C[l].animate(Q-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);X=X||h}if(this.animationStarted=X,!X){if(this.disposeOnEnd)for(l=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(l,1),l=0;l<C.length;l++)C[l].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return X}}function w(Q){if(0===Q.totalWeight&&0===Q.totalAdditiveWeight)return Q.originalValue;let X=1;const C=m.e.Yj[0],l=m.e.Yj[1],h=m.e.Quaternion[0];let M=0;const f=Q.animations[0],O=Q.originalValue;let W=1,U=!1;if(Q.totalWeight<1)W=1-Q.totalWeight,O.decompose(l,h,C);else{if(M=1,X=Q.totalWeight,W=f.weight/X,1==W){if(!Q.totalAdditiveWeight)return f.currentValue;U=!0}f.currentValue.decompose(l,h,C)}if(!U){l.scaleInPlace(W),C.scaleInPlace(W),h.scaleInPlace(W);for(let f=M;f<Q.animations.length;f++){const M=Q.animations[f];if(0===M.weight)continue;W=M.weight/X;const O=m.e.Yj[2],U=m.e.Yj[3],L=m.e.Quaternion[1];M.currentValue.decompose(U,L,O),U.scaleAndAddToRef(W,l),L.scaleAndAddToRef(m.c.Dot(h,L)>0?W:-W,h),O.scaleAndAddToRef(W,C)}h.normalize()}for(let w=0;w<Q.additiveAnimations.length;w++){const X=Q.additiveAnimations[w];if(0===X.weight)continue;const M=m.e.Yj[2],f=m.e.Yj[3],O=m.e.Quaternion[1];X.currentValue.decompose(f,O,M),f.multiplyToRef(l,f),m.k.LerpToRef(l,f,X.weight,l),h.multiplyToRef(O,O),m.c.SlerpToRef(h,O,X.weight,h),M.scaleAndAddToRef(X.weight,C)}const L=f?f._animationState.workValue:m.e.Matrix[0].clone();return m.b.ComposeToRef(l,h,C,L),L}function i(Q,X){if(0===Q.totalWeight&&0===Q.totalAdditiveWeight)return X;const C=Q.animations[0],l=Q.originalValue;let h=X;if(0===Q.totalWeight&&Q.totalAdditiveWeight>0)h.p(l);else if(1===Q.animations.length){if(m.c.SlerpToRef(l,C.currentValue,Math.min(1,Q.totalWeight),h),0===Q.totalAdditiveWeight)return h}else if(Q.animations.length>1){let C,M,f=1;if(Q.totalWeight<1){const X=1-Q.totalWeight;C=[],M=[],C.push(l),M.push(X)}else{if(2===Q.animations.length&&(m.c.SlerpToRef(Q.animations[0].currentValue,Q.animations[1].currentValue,Q.animations[1].weight/Q.totalWeight,X),0===Q.totalAdditiveWeight))return X;C=[],M=[],f=Q.totalWeight}for(let X=0;X<Q.animations.length;X++){const l=Q.animations[X];C.push(l.currentValue),M.push(l.weight/f)}let O=0;for(let Q=0;Q<C.length;)Q?(O+=M[Q],m.c.SlerpToRef(h,C[Q],M[Q]/O,h),Q++):(m.c.SlerpToRef(C[Q],C[Q+1],M[Q+1]/(M[Q]+M[Q+1]),X),h=X,O=M[Q]+M[Q+1],Q+=2)}for(let M=0;M<Q.additiveAnimations.length;M++){const X=Q.additiveAnimations[M];0!==X.weight&&(h.multiplyToRef(X.currentValue,m.e.Quaternion[0]),m.c.SlerpToRef(h,m.e.Quaternion[0],X.weight,h))}return h}var a,F,s=C(2522);a=s.e,(F=O.d)&&(F.prototype.copyAnimationRange=function(Q,X,C){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3],M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new l.e(this.name,"_matrix",Q.animations[0].framePerSecond,l.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const f=Q.animations[0].getRange(X);if(!f)return!1;const O=f.from,m=f.to,W=Q.animations[0].getKeys(),U=Q.length,L=Q.getParent(),w=this.getParent(),i=h&&L&&U&&this.length&&U!==this.length,a=i&&w&&L?w.length/L.length:1,F=h&&!w&&M&&(1!==M.x||1!==M.y||1!==M.z),s=this.animations[0].getKeys();let z,x,r;for(let l=0,P=W.length;l<P;l++)z=W[l],z.frame>=O&&z.frame<=m&&(h?(r=z.value.clone(),i?(x=r.getTranslation(),r.setTranslation(x.scaleInPlace(a))):F&&M?(x=r.getTranslation(),r.setTranslation(x.multiplyInPlace(M))):r=z.value):r=z.value,s.push({frame:z.frame+C,value:r}));return this.animations[0].createRange(X,O+C,m+C),!0}),a&&(a.prototype._animate=function(Q){if(!this.animationsEnabled)return;const X=U.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=X}this.deltaTime=void 0!==Q?Q:this.useConstantAnimationDeltaTime?16:(X-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=X;const C=this._activeAnimatables;if(0===C.length)return;this._animationTime+=this.deltaTime;const h=this._animationTime;for(let l=0;l<C.length;l++){const Q=C[l];!Q._animate(h)&&Q.disposeOnEnd&&l--}!function(Q){if(Q._registeredForLateAnimationBindings.length){for(let X=0;X<Q._registeredForLateAnimationBindings.length;X++){const C=Q._registeredForLateAnimationBindings.data[X];for(const Q in C._lateAnimationHolders){const X=C._lateAnimationHolders[Q],h=X.animations[0],M=X.originalValue;if(void 0===M||null===M)continue;const f=l.e.AllowMatrixDecomposeForInterpolation&&M.m;let O=C[Q];if(f)O=w(X);else if(void 0!==M.w)O=i(X,O||m.c.Identity());else{let Q=0,C=1;const f=h&&h._animationState.loopMode===l.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(X.totalWeight<1)O=f?M.clone?M.clone():M:h&&M.scale?M.scale(1-X.totalWeight):h?M*(1-X.totalWeight):M.clone?M.clone():M;else if(h){C=X.totalWeight;const l=h.weight/C;O=1!==l?h.currentValue.scale?h.currentValue.scale(l):h.currentValue*l:h.currentValue,f&&(O.addToRef?O.addToRef(M,O):O+=M),Q=1}for(let l=Q;l<X.animations.length;l++){const Q=X.animations[l],h=Q.weight/C;h&&(Q.currentValue.scaleAndAddToRef?Q.currentValue.scaleAndAddToRef(h,O):O+=Q.currentValue*h)}for(let l=0;l<X.additiveAnimations.length;l++){const Q=X.additiveAnimations[l],C=Q.weight;C&&(Q.currentValue.scaleAndAddToRef?Q.currentValue.scaleAndAddToRef(C,O):O+=Q.currentValue*C)}}C[Q]=O}C._lateAnimationHolders={}}Q._registeredForLateAnimationBindings.reset()}}(this)},a.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((Q,X)=>Q.playOrder-X.playOrder))},a.prototype.beginWeightedAnimation=function(Q,X,C){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,h=arguments.length>4?arguments[4]:void 0,M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,m=arguments.length>8?arguments[8]:void 0,W=arguments.length>9?arguments[9]:void 0,U=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const L=this.beginAnimation(Q,X,C,h,M,f,O,!1,m,W,U);return L.weight=l,L},a.prototype.beginAnimation=function(Q,X,C,l){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,M=arguments.length>5?arguments[5]:void 0,f=arguments.length>6?arguments[6]:void 0,O=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],m=arguments.length>8?arguments[8]:void 0,W=arguments.length>9?arguments[9]:void 0,U=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(h<0){const Q=X;X=C,C=Q,h=-h}X>C&&(h=-h),O&&this.stopAnimation(Q,void 0,m),f||(f=new L(this,Q,X,C,l,h,M,void 0,W,U));const w=!m||m(Q);if(Q.animations&&w&&f.appendAnimations(Q,Q.animations),Q.getAnimatables){const U=Q.getAnimatables();for(let Q=0;Q<U.length;Q++)this.beginAnimation(U[Q],X,C,l,h,M,f,O,m,W)}return f.reset(),f},a.prototype.beginHierarchyAnimation=function(Q,X,C,l,h){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,m=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],W=arguments.length>9?arguments[9]:void 0,U=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const L=Q.getDescendants(X),w=[];w.push(this.beginAnimation(Q,C,l,h,M,f,O,m,W,void 0,U));for(const i of L)w.push(this.beginAnimation(i,C,l,h,M,f,O,m,W,void 0,U));return w},a.prototype.beginDirectAnimation=function(Q,X,C,l,h){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(M<0){const Q=C;C=l,l=Q,M=-M}return C>l&&(M=-M),new L(this,Q,C,l,h,M,arguments.length>6?arguments[6]:void 0,X,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},a.prototype.beginDirectHierarchyAnimation=function(Q,X,C,l,h,M,f,O,m){let W=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const U=Q.getDescendants(X),L=[];L.push(this.beginDirectAnimation(Q,C,l,h,M,f,O,m,W));for(const w of U)L.push(this.beginDirectAnimation(w,C,l,h,M,f,O,m,W));return L},a.prototype.getAnimatableByTarget=function(Q){for(let X=0;X<this._activeAnimatables.length;X++)if(this._activeAnimatables[X].target===Q)return this._activeAnimatables[X];return null},a.prototype.getAllAnimatablesByTarget=function(Q){const X=[];for(let C=0;C<this._activeAnimatables.length;C++)this._activeAnimatables[C].target===Q&&X.push(this._activeAnimatables[C]);return X},a.prototype.stopAnimation=function(Q,X,C){const l=this.getAllAnimatablesByTarget(Q);for(const h of l)h.stop(X,C)},a.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let Q=0;Q<this._activeAnimatables.length;Q++)this._activeAnimatables[Q].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const Q of this.animationGroups)Q.stop()});class z{getClassName(){return"TargetedAnimation"}serialize(){const Q={};return Q.animation=this.animation.serialize(),Q.targetId=this.target.id,Q}}class x{get mask(){return this._mask}set mask(Q){this._mask!==Q&&(this._mask=Q,this.syncWithMask(!0))}syncWithMask(){let Q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||Q){this._numActiveAnimatables=0;for(let Q=0;Q<this._animatables.length;++Q){const X=this._animatables[Q];!this.mask||this.mask.disabled||this.mask.retainsTarget(X.target.name)?(this._numActiveAnimatables++,X.paused&&X.restart()):X.paused||X.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let Q=0;Q<this._animatables.length;++Q){const X=this._animatables[Q];this.mask.retainsTarget(X.target.name)||(X.stop(),this._animatables.splice(Q,1),--Q)}for(let Q=0;Q<this._targetedAnimations.length;Q++){const X=this._targetedAnimations[Q];this.mask.retainsTarget(X.target.name)||(this._targetedAnimations.splice(Q,1),--Q)}}}get from(){return this._from}set from(Q){if(this._from!==Q){this._from=Q;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].fromFrame=this._from}}}get to(){return this._to}set to(Q){if(this._to!==Q){this._to=Q;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(Q){if(this._speedRatio!==Q){this._speedRatio=Q;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(Q){if(this._loopAnimation!==Q){this._loopAnimation=Q;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(Q){if(this._isAdditive!==Q){this._isAdditive=Q;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(Q){this._weight!==Q&&(this._weight=Q,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(Q){if(this._playOrder!==Q&&(this._playOrder=Q,this._animatables.length>0)){for(let Q=0;Q<this._animatables.length;Q++)this._animatables[Q].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(Q){if(this._enableBlending!==Q&&(this._enableBlending=Q,null!==Q))for(let X=0;X<this._targetedAnimations.length;++X)this._targetedAnimations[X].animation.enableBlending=Q}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(Q){if(this._blendingSpeed!==Q&&(this._blendingSpeed=Q,null!==Q))for(let X=0;X<this._targetedAnimations.length;++X)this._targetedAnimations[X].animation.blendingSpeed=Q}getLength(Q,X){Q=Q??this._from;return((X=X??this._to)-Q)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(Q){let X=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],l=arguments.length>3?arguments[3]:void 0;if(0===Q.length)return null;l=l??Q[0].weight;let h=Number.MAX_VALUE,M=-Number.MAX_VALUE;if(C)for(const O of Q)O.from<h&&(h=O.from),O.to>M&&(M=O.to);const f=new x(Q[0].name+"_merged",Q[0]._scene,l);for(const O of Q){C&&O.normalize(h,M);for(const Q of O.targetedAnimations)f.addTargetedAnimation(Q.animation,Q.target);X&&O.dispose()}return f}constructor(Q){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=Q,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new h.e,this.onAnimationLoopObservable=new h.e,this.onAnimationGroupLoopObservable=new h.e,this.onAnimationGroupEndObservable=new h.e,this.onAnimationGroupPauseObservable=new h.e,this.onAnimationGroupPlayObservable=new h.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=X||M.b.LastCreatedScene,this._weight=C,this._playOrder=l,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(Q,X){const C=new z;C.animation=Q,C.target=X;const l=Q.getKeys();return this._from>l[0].frame&&(this._from=l[0].frame),this._to<l[l.length-1].frame&&(this._to=l[l.length-1].frame),null!==this._enableBlending&&(Q.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(Q.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(C),this._shouldStart=!0,C}removeTargetedAnimation(Q){for(let X=this._targetedAnimations.length-1;X>-1;X--){this._targetedAnimations[X].animation===Q&&this._targetedAnimations.splice(X,1)}}normalize(){let Q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==Q&&(Q=this._from),null==X&&(X=this._to);for(let C=0;C<this._targetedAnimations.length;C++){const l=this._targetedAnimations[C].animation.getKeys(),h=l[0],M=l[l.length-1];if(h.frame>Q){const X={frame:Q,value:h.value,inTangent:h.inTangent,outTangent:h.outTangent,interpolation:h.interpolation};l.splice(0,0,X)}if(M.frame<X){const Q={frame:X,value:M.value,inTangent:M.inTangent,outTangent:M.outTangent,interpolation:M.interpolation};l.push(Q)}}return this._from=Q,this._to=X,this}_processLoop(Q,X,C){Q.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(X),this._animationLoopFlags[C]||(this._animationLoopFlags[C]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let Q=arguments.length>0&&void 0!==arguments[0]&&arguments[0],X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0,l=arguments.length>3?arguments[3]:void 0,h=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=Q,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let M=0;M<this._targetedAnimations.length;M++){const f=this._targetedAnimations[M],O=this._scene.beginDirectAnimation(f.target,[f.animation],void 0!==C?C:this._from,void 0!==l?l:this._to,Q,X,void 0,void 0,void 0!==h?h:this._isAdditive);O.weight=this._weight,O.playOrder=this._playOrder,O.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(f),this._checkAnimationGroupEnded(O)},this._processLoop(O,f,M),this._animatables.push(O)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=X,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(Q){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==Q&&(this.loopAnimation=Q),this.restart()):(this.stop(),this.start(Q,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].reset()}return this}restart(){if(!this._isStarted)return this;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let Q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const X=this._animatables.slice();for(let l=0;l<X.length;l++)X[l].stop(void 0,void 0,!0,Q);let C=0;for(let l=0;l<this._scene._activeAnimatables.length;l++){const X=this._scene._activeAnimatables[l];X._runtimeAnimations.length>0?this._scene._activeAnimatables[C++]=X:Q&&this._checkAnimationGroupEnded(X,Q)}return this._scene._activeAnimatables.length=C,this._isStarted=!1,this}setWeightForAllAnimatables(Q){for(let X=0;X<this._animatables.length;X++){this._animatables[X].weight=Q}return this}syncAllAnimationsWith(Q){for(let X=0;X<this._animatables.length;X++){this._animatables[X].syncWith(Q)}return this}goToFrame(Q){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let C=0;C<this._animatables.length;C++){this._animatables[C].goToFrame(Q,X)}return this}getCurrentFrame(){var Q;return(null===(Q=this.animatables[0])||void 0===Q?void 0:Q.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const Q=this._scene.animationGroups.indexOf(this);if(Q>-1&&this._scene.animationGroups.splice(Q,1),this._parentContainer){const Q=this._parentContainer.animationGroups.indexOf(this);Q>-1&&this._parentContainer.animationGroups.splice(Q,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(Q){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const C=this._animatables.indexOf(Q);C>-1&&this._animatables.splice(C,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,X||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(Q,X){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const l=new x(Q||this.name,this._scene,this._weight,this._playOrder);l._from=this.from,l._to=this.to,l._speedRatio=this.speedRatio,l._loopAnimation=this.loopAnimation,l._isAdditive=this.isAdditive,l._enableBlending=this.enableBlending,l._blendingSpeed=this.blendingSpeed,l.metadata=this.metadata,l.mask=this.mask;for(const h of this._targetedAnimations)l.addTargetedAnimation(C?h.animation.clone():h.animation,X?X(h.target):h.target);return l}serialize(){const Q={};Q.name=this.name,Q.from=this.from,Q.to=this.to,Q.speedRatio=this.speedRatio,Q.loopAnimation=this.loopAnimation,Q.isAdditive=this.isAdditive,Q.weight=this.weight,Q.playOrder=this.playOrder,Q.enableBlending=this.enableBlending,Q.blendingSpeed=this.blendingSpeed,Q.targetedAnimations=[];for(let X=0;X<this.targetedAnimations.length;X++){const C=this.targetedAnimations[X];Q.targetedAnimations[X]=C.serialize()}return f.e&&f.e.HasTags(this)&&(Q.tags=f.e.GetTags(this)),this.metadata&&(Q.metadata=this.metadata),Q}static Parse(Q,X){const C=new x(Q.name,X,Q.weight,Q.playOrder);for(let h=0;h<Q.targetedAnimations.length;h++){const M=Q.targetedAnimations[h],f=l.e.Parse(M.animation),O=M.targetId;if("influence"===M.animation.property){const Q=X.getMorphTargetById(O);Q&&C.addTargetedAnimation(f,Q)}else{const Q=X.getNodeById(O);null!=Q&&C.addTargetedAnimation(f,Q)}}return f.e&&f.e.AddTagsTo(C,Q.tags),null!==Q.from&&null!==Q.to&&C.normalize(Q.from,Q.to),void 0!==Q.speedRatio&&(C._speedRatio=Q.speedRatio),void 0!==Q.loopAnimation&&(C._loopAnimation=Q.loopAnimation),void 0!==Q.isAdditive&&(C._isAdditive=Q.isAdditive),void 0!==Q.weight&&(C._weight=Q.weight),void 0!==Q.playOrder&&(C._playOrder=Q.playOrder),void 0!==Q.enableBlending&&(C._enableBlending=Q.enableBlending),void 0!==Q.blendingSpeed&&(C._blendingSpeed=Q.blendingSpeed),void 0!==Q.metadata&&(C.metadata=Q.metadata),C}static MakeAnimationAdditive(Q,X,C){let h;h="object"===typeof X?X:{referenceFrame:X,range:C,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let M=Q;h.cloneOriginalAnimationGroup&&(M=Q.clone(h.clonedAnimationGroupName||M.name));const f=M.targetedAnimations;for(let O=0;O<f.length;O++){const Q=f[O];Q.animation=l.e.MakeAnimationAdditive(Q.animation,h)}if(M.isAdditive=!0,h.clipKeys){let Q=Number.MAX_VALUE,X=-Number.MAX_VALUE;const C=M.targetedAnimations;for(let l=0;l<C.length;l++){const h=C[l].animation.getKeys();Q>h[0].frame&&(Q=h[0].frame),X<h[h.length-1].frame&&(X=h[h.length-1].frame)}M._from=Q,M._to=X}return M}static ClipKeys(Q,X,C,l,h){const M=Q.clone(l||Q.name);return x.ClipKeysInPlace(M,X,C,h)}static ClipKeysInPlace(Q,X,C,l){return x.ClipInPlace(Q,X,C,l,!1)}static ClipFrames(Q,X,C,l,h){const M=Q.clone(l||Q.name);return x.ClipFramesInPlace(M,X,C,h)}static ClipFramesInPlace(Q,X,C,l){return x.ClipInPlace(Q,X,C,l,!0)}static ClipInPlace(Q,X,C,l){let h=arguments.length>4&&void 0!==arguments[4]&&arguments[4],M=Number.MAX_VALUE,f=-Number.MAX_VALUE;const O=Q.targetedAnimations;for(let m=0;m<O.length;m++){const Q=O[m],W=l?Q.animation:Q.animation.clone();h&&(W.createKeyForFrame(X),W.createKeyForFrame(C));const U=W.getKeys(),L=[];let w=Number.MAX_VALUE;for(let l=0;l<U.length;l++){const Q=U[l];if(!h&&l>=X&&l<=C||h&&Q.frame>=X&&Q.frame<=C){const X={frame:Q.frame,value:Q.value.clone?Q.value.clone():Q.value,inTangent:Q.inTangent,outTangent:Q.outTangent,interpolation:Q.interpolation,lockedTangent:Q.lockedTangent};w===Number.MAX_VALUE&&(w=X.frame),X.frame-=w,L.push(X)}}0!==L.length?(M>L[0].frame&&(M=L[0].frame),f<L[L.length-1].frame&&(f=L[L.length-1].frame),W.setKeys(L,!0),Q.animation=W):(O.splice(m,1),m--)}return Q._from=M,Q._to=f,Q}getClassName(){return"AnimationGroup"}toString(Q){let X="Name: "+this.name;return X+=", type: "+this.getClassName(),Q&&(X+=", from: "+this._from,X+=", to: "+this._to,X+=", isStarted: "+this._isStarted,X+=", speedRatio: "+this._speedRatio,X+=", targetedAnimations length: "+this._targetedAnimations.length,X+=", animatables length: "+this._animatables),X}}}}]);