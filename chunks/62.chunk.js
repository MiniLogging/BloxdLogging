"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[62],{13914:(U,W,l)=>{l.r(W),l.d(W,{AnimationGroup:()=>f,TargetedAnimation:()=>m});var M=l(11860),t=l(496),L=l(543),p=l(667),B=l(12625),k=l(706);class A{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(U,W,l,t){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=W,this._target=U,this._scene=l,this._host=t,this._activeTargets=[],W._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===M.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=k.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const U={frame:0,value:this._minValue};this._keys.splice(0,0,U)}if(this._target instanceof Array){let U=0;for(const W of this._target)this._preparePath(W,U),this._getOriginalValues(U),U++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const L=W.getEvents();if(L&&L.length>0)for(const M of L)this._events.push(M._clone());this._enableBlending=U&&U.animationPropertiesOverride?U.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(U){let W=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const l=this._animation.targetPropertyPath;if(l.length>1){let M=U;for(let U=0;U<l.length-1;U++){const W=l[U];if(M=M[W],void 0===M)throw new Error(`Invalid property (${W}) in property path (${l.join(".")})`)}this._targetPath=l[l.length-1],this._activeTargets[W]=M}else this._targetPath=l[0],this._activeTargets[W]=U;if(void 0===this._activeTargets[W][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${l.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let U=0;for(const W of this._target)void 0!==this._originalValue[U]&&this._setValue(W,this._activeTargets[U],this._originalValue[U],-1,U),U++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let U=0;U<this._events.length;U++)this._events[U].isDone=!1}isStopped(){return this._stopped}dispose(){const U=this._animation.runtimeAnimations.indexOf(this);U>-1&&this._animation.runtimeAnimations.splice(U,1)}setValue(U,W){if(this._targetIsArray)for(let l=0;l<this._target.length;l++){const M=this._target[l];this._setValue(M,this._activeTargets[l],U,W,l)}else this._setValue(this._target,this._directTarget,U,W,0)}_getOriginalValues(){let U,W=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const l=this._activeTargets[W];U=l.getLocalMatrix&&"_matrix"===this._targetPath?l.getLocalMatrix():l[this._targetPath],U&&U.clone?this._originalValue[W]=U.clone():this._originalValue[W]=U}_registerTargetForLateAnimationBinding(U,W){const l=U.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(l),l._lateAnimationHolders||(l._lateAnimationHolders={}),l._lateAnimationHolders[U.targetPath]||(l._lateAnimationHolders[U.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:W}),U.isAdditive?(l._lateAnimationHolders[U.targetPath].additiveAnimations.push(U),l._lateAnimationHolders[U.targetPath].totalAdditiveWeight+=U.weight):(l._lateAnimationHolders[U.targetPath].animations.push(U),l._lateAnimationHolders[U.targetPath].totalWeight+=U.weight)}_setValue(U,W,l,t,L){if(this._currentActiveTarget=W,this._weight=t,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const U=W[this._targetPath];U.clone?this._originalBlendValue=U.clone():this._originalBlendValue=U}this._originalBlendValue.m?M.c.AllowMatrixDecomposeForInterpolation?this._currentValue?k.c.DecomposeLerpToRef(this._originalBlendValue,l,this._blendingFactor,this._currentValue):this._currentValue=k.c.DecomposeLerp(this._originalBlendValue,l,this._blendingFactor):this._currentValue?k.c.LerpToRef(this._originalBlendValue,l,this._blendingFactor,this._currentValue):this._currentValue=k.c.Lerp(this._originalBlendValue,l,this._blendingFactor):this._currentValue=M.c._UniversalLerp(this._originalBlendValue,l,this._blendingFactor);const t=U&&U.animationPropertiesOverride?U.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=t}else this._currentValue?this._currentValue.p?this._currentValue.p(l):this._currentValue=l:null!==l&&void 0!==l&&l.clone?this._currentValue=l.clone():this._currentValue=l;-1!==t?this._registerTargetForLateAnimationBinding(this,this._originalValue[L]):this._animationState.loopMode===M.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[L],W[this._targetPath]):W[this._targetPath]=this._originalValue[L]+this._currentValue:W[this._targetPath]=this._currentValue,U.ek&&U.ek(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(U){let W=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const l=this._animation.getKeys();U<l[0].frame?U=l[0].frame:U>l[l.length-1].frame&&(U=l[l.length-1].frame);const M=this._events;if(M.length)for(let L=0;L<M.length;L++)M[L].onlyOnce||(M[L].isDone=M[L].frame<U);this._currentFrame=U;const t=this._animation._interpolate(U,this._animationState);this.setValue(t,W)}_prepareForSpeedRatioChange(U){const W=this._previousElapsedTime*(this._animation.framePerSecond*U)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-W}animate(U,W,l,t,L){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const B=this._animation,k=B.targetPropertyPath;if(!k||k.length<1)return this._stopped=!0,!1;let A,q=!0;const y=this._events;let j=0;if(this._coreRuntimeAnimation)j=l-W,A=this._coreRuntimeAnimation.currentFrame,this._currentFrame=A,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let p;(W<this._minFrame||W>this._maxFrame)&&(W=this._minFrame),(l<this._minFrame||l>this._maxFrame)&&(l=this._maxFrame),j=l-W;let k=U*(B.framePerSecond*L)/1e3+this._absoluteFrameOffset,s=0,w=!1;const K=t&&this._animationState.loopMode===M.c.ANIMATIONLOOPMODE_YOYO;if(K){const U=(k-W)/j,l=Math.sin(U*Math.PI);k=Math.abs(l)*j+W;const M=l>=0?1:-1;this._yoyoDirection!==M&&(w=!0),this._yoyoDirection=M}if(this._previousElapsedTime=U,this._previousAbsoluteFrame=k,!t&&l>=W&&(k>=j&&L>0||k<=0&&L<0))q=!1,s=B._getKeyValue(this._maxValue);else if(!t&&W>=l&&(k<=j&&L<0||k>=0&&L>0))q=!1,s=B._getKeyValue(this._minValue);else if(this._animationState.loopMode!==M.c.ANIMATIONLOOPMODE_CYCLE){const U=l.toString()+W.toString();if(!this._offsetsCache[U]){this._animationState.repeatCount=0,this._animationState.loopMode=M.c.ANIMATIONLOOPMODE_CYCLE;const t=B._interpolate(W,this._animationState),L=B._interpolate(l,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),B.dataType){case M.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[U]=L-t;break;case M.c.ANIMATIONTYPE_QUATERNION:case M.c.ANIMATIONTYPE_VECTOR3:case M.c.ANIMATIONTYPE_VECTOR2:case M.c.ANIMATIONTYPE_SIZE:case M.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[U]=L.de(t)}this._highLimitsCache[U]=L}s=this._highLimitsCache[U],p=this._offsetsCache[U]}if(void 0===p)switch(B.dataType){case M.c.ANIMATIONTYPE_FLOAT:p=0;break;case M.c.ANIMATIONTYPE_QUATERNION:p=M.g;break;case M.c.ANIMATIONTYPE_VECTOR3:p=M.o;break;case M.c.ANIMATIONTYPE_VECTOR2:p=M.l;break;case M.c.ANIMATIONTYPE_SIZE:p=M.i;break;case M.c.ANIMATIONTYPE_COLOR3:p=M.e;break;case M.c.ANIMATIONTYPE_COLOR4:p=M.f}if(this._host&&this._host.syncRoot){const U=this._host.syncRoot;A=W+j*((U.masterFrame-U.fromFrame)/(U.toFrame-U.fromFrame))}else A=k>0&&W>l||k<0&&W<l?q&&0!==j?l+k%j:W:q&&0!==j?W+k%j:l;if(!K&&(L>0&&this.currentFrame>A||L<0&&this.currentFrame<A)||K&&w){this._onLoop();for(let U=0;U<y.length;U++)y[U].onlyOnce||(y[U].isDone=!1);this._animationState.key=L>0?0:B.getKeys().length-1}this._currentFrame=A,this._animationState.repeatCount=0===j?0:k/j|0,this._animationState.highLimitValue=s,this._animationState.offsetValue=p}const s=B._interpolate(A,this._animationState);if(this.setValue(s,p),y.length)for(let M=0;M<y.length;M++)if(j>=0&&A>=y[M].frame&&y[M].frame>=W||j<0&&A<=y[M].frame&&y[M].frame<=W){const U=y[M];U.isDone||(U.onlyOnce&&(y.splice(M,1),M--),U.isDone=!0,U.action(A))}return q||(this._stopped=!0),q}}var q=l(524);class y{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(U){this._weight=-1!==U?Math.min(Math.max(U,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(U){for(let W=0;W<this._runtimeAnimations.length;W++){this._runtimeAnimations[W]._prepareForSpeedRatioChange(U)}this._speedRatio=U,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(U,W){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,L=arguments.length>4&&void 0!==arguments[4]&&arguments[4],p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,B=arguments.length>6?arguments[6]:void 0,k=arguments.length>7?arguments[7]:void 0,A=arguments.length>8?arguments[8]:void 0,q=arguments.length>9&&void 0!==arguments[9]&&arguments[9],y=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=W,this.fromFrame=l,this.toFrame=M,this.loopAnimation=L,this.onAnimationEnd=B,this.onAnimationLoop=A,this.isAdditive=q,this.playOrder=y,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this._j=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new t.b,this.onAnimationLoopObservable=new t.b,this._scene=U,k&&this.appendAnimations(W,k),this._speedRatio=p,U._activeAnimatables.push(this)}syncWith(U){if(this._syncRoot=U,U){const U=this._scene._activeAnimatables.indexOf(this);U>-1&&(this._scene._activeAnimatables.splice(U,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(U,W){for(let l=0;l<W.length;l++){const M=W[l],t=new A(U,M,this._scene,this);t._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(t)}}getAnimationByTargetProperty(U){const W=this._runtimeAnimations;for(let l=0;l<W.length;l++)if(W[l].animation.targetProperty===U)return W[l].animation;return null}getRuntimeAnimationByTargetProperty(U){const W=this._runtimeAnimations;for(let l=0;l<W.length;l++)if(W[l].animation.targetProperty===U)return W[l];return null}reset(){const U=this._runtimeAnimations;for(let W=0;W<U.length;W++)U[W].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(U){const W=this._runtimeAnimations;for(let l=0;l<W.length;l++)W[l].animation.enableBlending=!0,W[l].animation.blendingSpeed=U}disableBlending(){const U=this._runtimeAnimations;for(let W=0;W<U.length;W++)U[W].animation.enableBlending=!1}goToFrame(U){let W=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const l=this._runtimeAnimations;if(l[0]){const W=l[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??l[0].currentFrame;const M=0===this.speedRatio?0:(U-this._frameToSyncFromJump)/W*1e3/this.speedRatio;this._manualJumpDelay=-M}for(let M=0;M<l.length;M++)l[M].goToFrame(U,W?this._weight:-1);this._goToFrame=U}get paused(){return this._j}pause(){this._j||(this._j=!0)}restart(){this._j=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(U,W){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],M=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(U||W){const t=this._scene._activeAnimatables.indexOf(this);if(t>-1){const L=this._runtimeAnimations;for(let l=L.length-1;l>=0;l--){const M=L[l];U&&M.animation.name!=U||(W&&!W(M.target)||(M.dispose(),L.splice(l,1)))}0==L.length&&(l||this._scene._activeAnimatables.splice(t,1),M||this._raiseOnAnimationEnd())}}else{const U=this._scene._activeAnimatables.indexOf(this);if(U>-1){l||this._scene._activeAnimatables.splice(U,1);const W=this._runtimeAnimations;for(let U=0;U<W.length;U++)W[U].dispose();this._runtimeAnimations.length=0,M||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((U=>{this.onAnimationEndObservable.add((()=>{U(this)}),void 0,void 0,this,!0)}))}_animate(U){if(this._j)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=U),!0;if(null===this._localDelayOffset?(this._localDelayOffset=U,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=U-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let W=!1;const l=this._runtimeAnimations;let M;for(M=0;M<l.length;M++){const t=l[M].animate(U-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);W=W||t}if(this.animationStarted=W,!W){if(this.disposeOnEnd)for(M=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(M,1),M=0;M<l.length;M++)l[M].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return W}}function j(U){if(0===U.totalWeight&&0===U.totalAdditiveWeight)return U.originalValue;let W=1;const l=k.f.ik[0],M=k.f.ik[1],t=k.f.Quaternion[0];let L=0;const p=U.animations[0],B=U.originalValue;let A=1,q=!1;if(U.totalWeight<1)A=1-U.totalWeight,B.decompose(M,t,l);else{if(L=1,W=U.totalWeight,A=p.weight/W,1==A){if(!U.totalAdditiveWeight)return p.currentValue;q=!0}p.currentValue.decompose(M,t,l)}if(!q){M.scaleInPlace(A),l.scaleInPlace(A),t.scaleInPlace(A);for(let p=L;p<U.animations.length;p++){const L=U.animations[p];if(0===L.weight)continue;A=L.weight/W;const B=k.f.ik[2],q=k.f.ik[3],y=k.f.Quaternion[1];L.currentValue.decompose(q,y,B),q.scaleAndAddToRef(A,M),y.scaleAndAddToRef(k.e.Dot(t,y)>0?A:-A,t),B.scaleAndAddToRef(A,l)}t.normalize()}for(let j=0;j<U.additiveAnimations.length;j++){const W=U.additiveAnimations[j];if(0===W.weight)continue;const L=k.f.ik[2],p=k.f.ik[3],B=k.f.Quaternion[1];W.currentValue.decompose(p,B,L),p.multiplyToRef(M,p),k.l.LerpToRef(M,p,W.weight,M),t.multiplyToRef(B,B),k.e.SlerpToRef(t,B,W.weight,t),L.scaleAndAddToRef(W.weight,l)}const y=p?p._animationState.workValue:k.f.Matrix[0].clone();return k.c.ComposeToRef(M,t,l,y),y}function s(U,W){if(0===U.totalWeight&&0===U.totalAdditiveWeight)return W;const l=U.animations[0],M=U.originalValue;let t=W;if(0===U.totalWeight&&U.totalAdditiveWeight>0)t.p(M);else if(1===U.animations.length){if(k.e.SlerpToRef(M,l.currentValue,Math.min(1,U.totalWeight),t),0===U.totalAdditiveWeight)return t}else if(U.animations.length>1){let l,L,p=1;if(U.totalWeight<1){const W=1-U.totalWeight;l=[],L=[],l.push(M),L.push(W)}else{if(2===U.animations.length&&(k.e.SlerpToRef(U.animations[0].currentValue,U.animations[1].currentValue,U.animations[1].weight/U.totalWeight,W),0===U.totalAdditiveWeight))return W;l=[],L=[],p=U.totalWeight}for(let W=0;W<U.animations.length;W++){const M=U.animations[W];l.push(M.currentValue),L.push(M.weight/p)}let B=0;for(let U=0;U<l.length;)U?(B+=L[U],k.e.SlerpToRef(t,l[U],L[U]/B,t),U++):(k.e.SlerpToRef(l[U],l[U+1],L[U+1]/(L[U]+L[U+1]),W),t=W,B=L[U]+L[U+1],U+=2)}for(let L=0;L<U.additiveAnimations.length;L++){const W=U.additiveAnimations[L];0!==W.weight&&(t.multiplyToRef(W.currentValue,k.f.Quaternion[0]),k.e.SlerpToRef(t,k.f.Quaternion[0],W.weight,t))}return t}var w,K,r=l(2178);w=r.c,(K=B.c)&&(K.prototype.copyAnimationRange=function(U,W,l){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3],L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new M.c(this.name,"_matrix",U.animations[0].framePerSecond,M.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const p=U.animations[0].getRange(W);if(!p)return!1;const B=p.from,k=p.to,A=U.animations[0].getKeys(),q=U.length,y=U.getParent(),j=this.getParent(),s=t&&y&&q&&this.length&&q!==this.length,w=s&&j&&y?j.length/y.length:1,K=t&&!j&&L&&(1!==L.x||1!==L.y||1!==L.z),r=this.animations[0].getKeys();let m,f,g;for(let M=0,E=A.length;M<E;M++)m=A[M],m.frame>=B&&m.frame<=k&&(t?(g=m.value.clone(),s?(f=g.getTranslation(),g.setTranslation(f.scaleInPlace(w))):K&&L?(f=g.getTranslation(),g.setTranslation(f.multiplyInPlace(L))):g=m.value):g=m.value,r.push({frame:m.frame+l,value:g}));return this.animations[0].createRange(W,B+l,k+l),!0}),w&&(w.prototype._animate=function(U){if(!this.animationsEnabled)return;const W=q.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=W}this.deltaTime=void 0!==U?U:this.useConstantAnimationDeltaTime?16:(W-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=W;const l=this._activeAnimatables;if(0===l.length)return;this._animationTime+=this.deltaTime;const t=this._animationTime;for(let M=0;M<l.length;M++){const U=l[M];!U._animate(t)&&U.disposeOnEnd&&M--}!function(U){if(U._registeredForLateAnimationBindings.length){for(let W=0;W<U._registeredForLateAnimationBindings.length;W++){const l=U._registeredForLateAnimationBindings.data[W];for(const U in l._lateAnimationHolders){const W=l._lateAnimationHolders[U],t=W.animations[0],L=W.originalValue;if(void 0===L||null===L)continue;const p=M.c.AllowMatrixDecomposeForInterpolation&&L.m;let B=l[U];if(p)B=j(W);else if(void 0!==L.w)B=s(W,B||k.e.Identity());else{let U=0,l=1;const p=t&&t._animationState.loopMode===M.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(W.totalWeight<1)B=p?L.clone?L.clone():L:t&&L.scale?L.scale(1-W.totalWeight):t?L*(1-W.totalWeight):L.clone?L.clone():L;else if(t){l=W.totalWeight;const M=t.weight/l;B=1!==M?t.currentValue.scale?t.currentValue.scale(M):t.currentValue*M:t.currentValue,p&&(B.addToRef?B.addToRef(L,B):B+=L),U=1}for(let M=U;M<W.animations.length;M++){const U=W.animations[M],t=U.weight/l;t&&(U.currentValue.scaleAndAddToRef?U.currentValue.scaleAndAddToRef(t,B):B+=U.currentValue*t)}for(let M=0;M<W.additiveAnimations.length;M++){const U=W.additiveAnimations[M],l=U.weight;l&&(U.currentValue.scaleAndAddToRef?U.currentValue.scaleAndAddToRef(l,B):B+=U.currentValue*l)}}l[U]=B}l._lateAnimationHolders={}}U._registeredForLateAnimationBindings.reset()}}(this)},w.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((U,W)=>U.playOrder-W.playOrder))},w.prototype.beginWeightedAnimation=function(U,W,l){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,t=arguments.length>4?arguments[4]:void 0,L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,p=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0,k=arguments.length>8?arguments[8]:void 0,A=arguments.length>9?arguments[9]:void 0,q=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const y=this.beginAnimation(U,W,l,t,L,p,B,!1,k,A,q);return y.weight=M,y},w.prototype.beginAnimation=function(U,W,l,M){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,L=arguments.length>5?arguments[5]:void 0,p=arguments.length>6?arguments[6]:void 0,B=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],k=arguments.length>8?arguments[8]:void 0,A=arguments.length>9?arguments[9]:void 0,q=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(t<0){const U=W;W=l,l=U,t=-t}W>l&&(t=-t),B&&this.stopAnimation(U,void 0,k),p||(p=new y(this,U,W,l,M,t,L,void 0,A,q));const j=!k||k(U);if(U.animations&&j&&p.appendAnimations(U,U.animations),U.getAnimatables){const q=U.getAnimatables();for(let U=0;U<q.length;U++)this.beginAnimation(q[U],W,l,M,t,L,p,B,k,A)}return p.reset(),p},w.prototype.beginHierarchyAnimation=function(U,W,l,M,t){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,p=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0,k=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],A=arguments.length>9?arguments[9]:void 0,q=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const y=U.getDescendants(W),j=[];j.push(this.beginAnimation(U,l,M,t,L,p,B,k,A,void 0,q));for(const s of y)j.push(this.beginAnimation(s,l,M,t,L,p,B,k,A,void 0,q));return j},w.prototype.beginDirectAnimation=function(U,W,l,M,t){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(L<0){const U=l;l=M,M=U,L=-L}return l>M&&(L=-L),new y(this,U,l,M,t,L,arguments.length>6?arguments[6]:void 0,W,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},w.prototype.beginDirectHierarchyAnimation=function(U,W,l,M,t,L,p,B,k){let A=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const q=U.getDescendants(W),y=[];y.push(this.beginDirectAnimation(U,l,M,t,L,p,B,k,A));for(const j of q)y.push(this.beginDirectAnimation(j,l,M,t,L,p,B,k,A));return y},w.prototype.getAnimatableByTarget=function(U){for(let W=0;W<this._activeAnimatables.length;W++)if(this._activeAnimatables[W].target===U)return this._activeAnimatables[W];return null},w.prototype.getAllAnimatablesByTarget=function(U){const W=[];for(let l=0;l<this._activeAnimatables.length;l++)this._activeAnimatables[l].target===U&&W.push(this._activeAnimatables[l]);return W},w.prototype.stopAnimation=function(U,W,l){const M=this.getAllAnimatablesByTarget(U);for(const t of M)t.stop(W,l)},w.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let U=0;U<this._activeAnimatables.length;U++)this._activeAnimatables[U].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const U of this.animationGroups)U.stop()});class m{getClassName(){return"TargetedAnimation"}serialize(){const U={};return U.animation=this.animation.serialize(),U.targetId=this.target.id,U}}class f{get mask(){return this._mask}set mask(U){this._mask!==U&&(this._mask=U,this.syncWithMask(!0))}syncWithMask(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||U){this._numActiveAnimatables=0;for(let U=0;U<this._animatables.length;++U){const W=this._animatables[U];!this.mask||this.mask.disabled||this.mask.retainsTarget(W.target.name)?(this._numActiveAnimatables++,W.paused&&W.restart()):W.paused||W.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let U=0;U<this._animatables.length;++U){const W=this._animatables[U];this.mask.retainsTarget(W.target.name)||(W.stop(),this._animatables.splice(U,1),--U)}for(let U=0;U<this._targetedAnimations.length;U++){const W=this._targetedAnimations[U];this.mask.retainsTarget(W.target.name)||(this._targetedAnimations.splice(U,1),--U)}}}get from(){return this._from}set from(U){if(this._from!==U){this._from=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].fromFrame=this._from}}}get to(){return this._to}set to(U){if(this._to!==U){this._to=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(U){if(this._speedRatio!==U){this._speedRatio=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(U){if(this._loopAnimation!==U){this._loopAnimation=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(U){if(this._isAdditive!==U){this._isAdditive=U;for(let U=0;U<this._animatables.length;U++){this._animatables[U].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(U){this._weight!==U&&(this._weight=U,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(U){if(this._playOrder!==U&&(this._playOrder=U,this._animatables.length>0)){for(let U=0;U<this._animatables.length;U++)this._animatables[U].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(U){if(this._enableBlending!==U&&(this._enableBlending=U,null!==U))for(let W=0;W<this._targetedAnimations.length;++W)this._targetedAnimations[W].animation.enableBlending=U}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(U){if(this._blendingSpeed!==U&&(this._blendingSpeed=U,null!==U))for(let W=0;W<this._targetedAnimations.length;++W)this._targetedAnimations[W].animation.blendingSpeed=U}getLength(U,W){U=U??this._from;return((W=W??this._to)-U)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(U){let W=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2],M=arguments.length>3?arguments[3]:void 0;if(0===U.length)return null;M=M??U[0].weight;let t=Number.MAX_VALUE,L=-Number.MAX_VALUE;if(l)for(const B of U)B.from<t&&(t=B.from),B.to>L&&(L=B.to);const p=new f(U[0].name+"_merged",U[0]._scene,M);for(const B of U){l&&B.normalize(t,L);for(const U of B.targetedAnimations)p.addTargetedAnimation(U.animation,U.target);W&&B.dispose()}return p}constructor(U){let W=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=U,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new t.b,this.onAnimationLoopObservable=new t.b,this.onAnimationGroupLoopObservable=new t.b,this.onAnimationGroupEndObservable=new t.b,this.onAnimationGroupPauseObservable=new t.b,this.onAnimationGroupPlayObservable=new t.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=W||L.d.LastCreatedScene,this._weight=l,this._playOrder=M,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(U,W){const l=new m;l.animation=U,l.target=W;const M=U.getKeys();return this._from>M[0].frame&&(this._from=M[0].frame),this._to<M[M.length-1].frame&&(this._to=M[M.length-1].frame),null!==this._enableBlending&&(U.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(U.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(l),this._shouldStart=!0,l}removeTargetedAnimation(U){for(let W=this._targetedAnimations.length-1;W>-1;W--){this._targetedAnimations[W].animation===U&&this._targetedAnimations.splice(W,1)}}normalize(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,W=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==U&&(U=this._from),null==W&&(W=this._to);for(let l=0;l<this._targetedAnimations.length;l++){const M=this._targetedAnimations[l].animation.getKeys(),t=M[0],L=M[M.length-1];if(t.frame>U){const W={frame:U,value:t.value,inTangent:t.inTangent,outTangent:t.outTangent,interpolation:t.interpolation};M.splice(0,0,W)}if(L.frame<W){const U={frame:W,value:L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation};M.push(U)}}return this._from=U,this._to=W,this}_processLoop(U,W,l){U.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(W),this._animationLoopFlags[l]||(this._animationLoopFlags[l]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0],W=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,l=arguments.length>2?arguments[2]:void 0,M=arguments.length>3?arguments[3]:void 0,t=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=U,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let L=0;L<this._targetedAnimations.length;L++){const p=this._targetedAnimations[L],B=this._scene.beginDirectAnimation(p.target,[p.animation],void 0!==l?l:this._from,void 0!==M?M:this._to,U,W,void 0,void 0,void 0!==t?t:this._isAdditive);B.weight=this._weight,B.playOrder=this._playOrder,B.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(p),this._checkAnimationGroupEnded(B)},this._processLoop(B,p,L),this._animatables.push(B)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=W,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let U=0;U<this._animatables.length;U++){this._animatables[U].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(U){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==U&&(this.loopAnimation=U),this.restart()):(this.stop(),this.start(U,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let U=0;U<this._animatables.length;U++){this._animatables[U].reset()}return this}restart(){if(!this._isStarted)return this;for(let U=0;U<this._animatables.length;U++){this._animatables[U].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const W=this._animatables.slice();for(let M=0;M<W.length;M++)W[M].stop(void 0,void 0,!0,U);let l=0;for(let M=0;M<this._scene._activeAnimatables.length;M++){const W=this._scene._activeAnimatables[M];W._runtimeAnimations.length>0?this._scene._activeAnimatables[l++]=W:U&&this._checkAnimationGroupEnded(W,U)}return this._scene._activeAnimatables.length=l,this._isStarted=!1,this}setWeightForAllAnimatables(U){for(let W=0;W<this._animatables.length;W++){this._animatables[W].weight=U}return this}syncAllAnimationsWith(U){for(let W=0;W<this._animatables.length;W++){this._animatables[W].syncWith(U)}return this}goToFrame(U){let W=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let l=0;l<this._animatables.length;l++){this._animatables[l].goToFrame(U,W)}return this}getCurrentFrame(){var U;return(null===(U=this.animatables[0])||void 0===U?void 0:U.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const U=this._scene.animationGroups.indexOf(this);if(U>-1&&this._scene.animationGroups.splice(U,1),this._parentContainer){const U=this._parentContainer.animationGroups.indexOf(this);U>-1&&this._parentContainer.animationGroups.splice(U,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(U){let W=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const l=this._animatables.indexOf(U);l>-1&&this._animatables.splice(l,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,W||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(U,W){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const M=new f(U||this.name,this._scene,this._weight,this._playOrder);M._from=this.from,M._to=this.to,M._speedRatio=this.speedRatio,M._loopAnimation=this.loopAnimation,M._isAdditive=this.isAdditive,M._enableBlending=this.enableBlending,M._blendingSpeed=this.blendingSpeed,M.metadata=this.metadata,M.mask=this.mask;for(const t of this._targetedAnimations)M.addTargetedAnimation(l?t.animation.clone():t.animation,W?W(t.target):t.target);return M}serialize(){const U={};U.name=this.name,U.from=this.from,U.to=this.to,U.speedRatio=this.speedRatio,U.loopAnimation=this.loopAnimation,U.isAdditive=this.isAdditive,U.weight=this.weight,U.playOrder=this.playOrder,U.enableBlending=this.enableBlending,U.blendingSpeed=this.blendingSpeed,U.targetedAnimations=[];for(let W=0;W<this.targetedAnimations.length;W++){const l=this.targetedAnimations[W];U.targetedAnimations[W]=l.serialize()}return p.d&&p.d.HasTags(this)&&(U.tags=p.d.GetTags(this)),this.metadata&&(U.metadata=this.metadata),U}static Parse(U,W){const l=new f(U.name,W,U.weight,U.playOrder);for(let t=0;t<U.targetedAnimations.length;t++){const L=U.targetedAnimations[t],p=M.c.Parse(L.animation),B=L.targetId;if("influence"===L.animation.property){const U=W.getMorphTargetById(B);U&&l.addTargetedAnimation(p,U)}else{const U=W.getNodeById(B);null!=U&&l.addTargetedAnimation(p,U)}}return p.d&&p.d.AddTagsTo(l,U.tags),null!==U.from&&null!==U.to&&l.normalize(U.from,U.to),void 0!==U.speedRatio&&(l._speedRatio=U.speedRatio),void 0!==U.loopAnimation&&(l._loopAnimation=U.loopAnimation),void 0!==U.isAdditive&&(l._isAdditive=U.isAdditive),void 0!==U.weight&&(l._weight=U.weight),void 0!==U.playOrder&&(l._playOrder=U.playOrder),void 0!==U.enableBlending&&(l._enableBlending=U.enableBlending),void 0!==U.blendingSpeed&&(l._blendingSpeed=U.blendingSpeed),void 0!==U.metadata&&(l.metadata=U.metadata),l}static MakeAnimationAdditive(U,W,l){let t;t="object"===typeof W?W:{referenceFrame:W,range:l,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let L=U;t.cloneOriginalAnimationGroup&&(L=U.clone(t.clonedAnimationGroupName||L.name));const p=L.targetedAnimations;for(let B=0;B<p.length;B++){const U=p[B];U.animation=M.c.MakeAnimationAdditive(U.animation,t)}if(L.isAdditive=!0,t.clipKeys){let U=Number.MAX_VALUE,W=-Number.MAX_VALUE;const l=L.targetedAnimations;for(let M=0;M<l.length;M++){const t=l[M].animation.getKeys();U>t[0].frame&&(U=t[0].frame),W<t[t.length-1].frame&&(W=t[t.length-1].frame)}L._from=U,L._to=W}return L}static ClipKeys(U,W,l,M,t){const L=U.clone(M||U.name);return f.ClipKeysInPlace(L,W,l,t)}static ClipKeysInPlace(U,W,l,M){return f.ClipInPlace(U,W,l,M,!1)}static ClipFrames(U,W,l,M,t){const L=U.clone(M||U.name);return f.ClipFramesInPlace(L,W,l,t)}static ClipFramesInPlace(U,W,l,M){return f.ClipInPlace(U,W,l,M,!0)}static ClipInPlace(U,W,l,M){let t=arguments.length>4&&void 0!==arguments[4]&&arguments[4],L=Number.MAX_VALUE,p=-Number.MAX_VALUE;const B=U.targetedAnimations;for(let k=0;k<B.length;k++){const U=B[k],A=M?U.animation:U.animation.clone();t&&(A.createKeyForFrame(W),A.createKeyForFrame(l));const q=A.getKeys(),y=[];let j=Number.MAX_VALUE;for(let M=0;M<q.length;M++){const U=q[M];if(!t&&M>=W&&M<=l||t&&U.frame>=W&&U.frame<=l){const W={frame:U.frame,value:U.value.clone?U.value.clone():U.value,inTangent:U.inTangent,outTangent:U.outTangent,interpolation:U.interpolation,lockedTangent:U.lockedTangent};j===Number.MAX_VALUE&&(j=W.frame),W.frame-=j,y.push(W)}}0!==y.length?(L>y[0].frame&&(L=y[0].frame),p<y[y.length-1].frame&&(p=y[y.length-1].frame),A.setKeys(y,!0),U.animation=A):(B.splice(k,1),k--)}return U._from=L,U._to=p,U}getClassName(){return"AnimationGroup"}toString(U){let W="Name: "+this.name;return W+=", type: "+this.getClassName(),U&&(W+=", from: "+this._from,W+=", to: "+this._to,W+=", isStarted: "+this._isStarted,W+=", speedRatio: "+this._speedRatio,W+=", targetedAnimations length: "+this._targetedAnimations.length,W+=", animatables length: "+this._animatables),W}}}}]);