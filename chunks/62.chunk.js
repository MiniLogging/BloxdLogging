"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[62],{13709:(L,j,P)=>{P.r(j),P.d(j,{AnimationGroup:()=>K,TargetedAnimation:()=>h});var A=P(11669),R=P(469),o=P(519),Y=P(624),u=P(12445),a=P(656);class D{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(L,j,P,R){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=j,this._target=L,this._scene=P,this._host=R,this._activeTargets=[],j._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===A.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=a.e.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const L={frame:0,value:this._minValue};this._keys.splice(0,0,L)}if(this._target instanceof Array){let L=0;for(const j of this._target)this._preparePath(j,L),this._getOriginalValues(L),L++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const o=j.getEvents();if(o&&o.length>0)for(const A of o)this._events.push(A._clone());this._enableBlending=L&&L.animationPropertiesOverride?L.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(L){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=this._animation.targetPropertyPath;if(P.length>1){let A=L;for(let L=0;L<P.length-1;L++){const j=P[L];if(A=A[j],void 0===A)throw new Error(`Invalid property (${j}) in property path (${P.join(".")})`)}this._targetPath=P[P.length-1],this._activeTargets[j]=A}else this._targetPath=P[0],this._activeTargets[j]=L;if(void 0===this._activeTargets[j][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${P.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let L=0;for(const j of this._target)void 0!==this._originalValue[L]&&this._setValue(j,this._activeTargets[L],this._originalValue[L],-1,L),L++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let L=0;L<this._events.length;L++)this._events[L].isDone=!1}isStopped(){return this._stopped}dispose(){const L=this._animation.runtimeAnimations.indexOf(this);L>-1&&this._animation.runtimeAnimations.splice(L,1)}setValue(L,j){if(this._targetIsArray)for(let P=0;P<this._target.length;P++){const A=this._target[P];this._setValue(A,this._activeTargets[P],L,j,P)}else this._setValue(this._target,this._directTarget,L,j,0)}_getOriginalValues(){let L,j=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const P=this._activeTargets[j];L=P.getLocalMatrix&&"_matrix"===this._targetPath?P.getLocalMatrix():P[this._targetPath],L&&L.clone?this._originalValue[j]=L.clone():this._originalValue[j]=L}_registerTargetForLateAnimationBinding(L,j){const P=L.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(P),P._lateAnimationHolders||(P._lateAnimationHolders={}),P._lateAnimationHolders[L.targetPath]||(P._lateAnimationHolders[L.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:j}),L.isAdditive?(P._lateAnimationHolders[L.targetPath].additiveAnimations.push(L),P._lateAnimationHolders[L.targetPath].totalAdditiveWeight+=L.weight):(P._lateAnimationHolders[L.targetPath].animations.push(L),P._lateAnimationHolders[L.targetPath].totalWeight+=L.weight)}_setValue(L,j,P,R,o){if(this._currentActiveTarget=j,this._weight=R,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const L=j[this._targetPath];L.clone?this._originalBlendValue=L.clone():this._originalBlendValue=L}this._originalBlendValue.m?A.c.AllowMatrixDecomposeForInterpolation?this._currentValue?a.e.DecomposeLerpToRef(this._originalBlendValue,P,this._blendingFactor,this._currentValue):this._currentValue=a.e.DecomposeLerp(this._originalBlendValue,P,this._blendingFactor):this._currentValue?a.e.LerpToRef(this._originalBlendValue,P,this._blendingFactor,this._currentValue):this._currentValue=a.e.Lerp(this._originalBlendValue,P,this._blendingFactor):this._currentValue=A.c._UniversalLerp(this._originalBlendValue,P,this._blendingFactor);const R=L&&L.animationPropertiesOverride?L.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=R}else this._currentValue?this._currentValue.p?this._currentValue.p(P):this._currentValue=P:null!==P&&void 0!==P&&P.clone?this._currentValue=P.clone():this._currentValue=P;-1!==R?this._registerTargetForLateAnimationBinding(this,this._originalValue[o]):this._animationState.loopMode===A.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[o],j[this._targetPath]):j[this._targetPath]=this._originalValue[o]+this._currentValue:j[this._targetPath]=this._currentValue,L.Ti&&L.Ti(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(L){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const P=this._animation.getKeys();L<P[0].frame?L=P[0].frame:L>P[P.length-1].frame&&(L=P[P.length-1].frame);const A=this._events;if(A.length)for(let o=0;o<A.length;o++)A[o].onlyOnce||(A[o].isDone=A[o].frame<L);this._currentFrame=L;const R=this._animation._interpolate(L,this._animationState);this.setValue(R,j)}_prepareForSpeedRatioChange(L){const j=this._previousElapsedTime*(this._animation.framePerSecond*L)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-j}animate(L,j,P,R,o){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const u=this._animation,a=u.targetPropertyPath;if(!a||a.length<1)return this._stopped=!0,!1;let D,S=!0;const g=this._events;let V=0;if(this._coreRuntimeAnimation)V=P-j,D=this._coreRuntimeAnimation.currentFrame,this._currentFrame=D,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let Y;(j<this._minFrame||j>this._maxFrame)&&(j=this._minFrame),(P<this._minFrame||P>this._maxFrame)&&(P=this._maxFrame),V=P-j;let a=L*(u.framePerSecond*o)/1e3+this._absoluteFrameOffset,N=0,C=!1;const b=R&&this._animationState.loopMode===A.c.ANIMATIONLOOPMODE_YOYO;if(b){const L=(a-j)/V,P=Math.sin(L*Math.PI);a=Math.abs(P)*V+j;const A=P>=0?1:-1;this._yoyoDirection!==A&&(C=!0),this._yoyoDirection=A}if(this._previousElapsedTime=L,this._previousAbsoluteFrame=a,!R&&P>=j&&(a>=V&&o>0||a<=0&&o<0))S=!1,N=u._getKeyValue(this._maxValue);else if(!R&&j>=P&&(a<=V&&o<0||a>=0&&o>0))S=!1,N=u._getKeyValue(this._minValue);else if(this._animationState.loopMode!==A.c.ANIMATIONLOOPMODE_CYCLE){const L=P.toString()+j.toString();if(!this._offsetsCache[L]){this._animationState.repeatCount=0,this._animationState.loopMode=A.c.ANIMATIONLOOPMODE_CYCLE;const R=u._interpolate(j,this._animationState),o=u._interpolate(P,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),u.dataType){case A.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[L]=o-R;break;case A.c.ANIMATIONTYPE_QUATERNION:case A.c.ANIMATIONTYPE_VECTOR3:case A.c.ANIMATIONTYPE_VECTOR2:case A.c.ANIMATIONTYPE_SIZE:case A.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[L]=o.xg(R)}this._highLimitsCache[L]=o}N=this._highLimitsCache[L],Y=this._offsetsCache[L]}if(void 0===Y)switch(u.dataType){case A.c.ANIMATIONTYPE_FLOAT:Y=0;break;case A.c.ANIMATIONTYPE_QUATERNION:Y=A.k;break;case A.c.ANIMATIONTYPE_VECTOR3:Y=A.r;break;case A.c.ANIMATIONTYPE_VECTOR2:Y=A.p;break;case A.c.ANIMATIONTYPE_SIZE:Y=A.o;break;case A.c.ANIMATIONTYPE_COLOR3:Y=A.e;break;case A.c.ANIMATIONTYPE_COLOR4:Y=A.i}if(this._host&&this._host.syncRoot){const L=this._host.syncRoot;D=j+V*((L.masterFrame-L.fromFrame)/(L.toFrame-L.fromFrame))}else D=a>0&&j>P||a<0&&j<P?S&&0!==V?P+a%V:j:S&&0!==V?j+a%V:P;if(!b&&(o>0&&this.currentFrame>D||o<0&&this.currentFrame<D)||b&&C){this._onLoop();for(let L=0;L<g.length;L++)g[L].onlyOnce||(g[L].isDone=!1);this._animationState.key=o>0?0:u.getKeys().length-1}this._currentFrame=D,this._animationState.repeatCount=0===V?0:a/V|0,this._animationState.highLimitValue=N,this._animationState.offsetValue=Y}const N=u._interpolate(D,this._animationState);if(this.setValue(N,Y),g.length)for(let A=0;A<g.length;A++)if(V>=0&&D>=g[A].frame&&g[A].frame>=j||V<0&&D<=g[A].frame&&g[A].frame<=j){const L=g[A];L.isDone||(L.onlyOnce&&(g.splice(A,1),A--),L.isDone=!0,L.action(D))}return S||(this._stopped=!0),S}}var S=P(501);class g{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(L){this._weight=-1!==L?Math.min(Math.max(L,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(L){for(let j=0;j<this._runtimeAnimations.length;j++){this._runtimeAnimations[j]._prepareForSpeedRatioChange(L)}this._speedRatio=L,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(L,j){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,a=arguments.length>7?arguments[7]:void 0,D=arguments.length>8?arguments[8]:void 0,S=arguments.length>9&&void 0!==arguments[9]&&arguments[9],g=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=j,this.fromFrame=P,this.toFrame=A,this.loopAnimation=o,this.onAnimationEnd=u,this.onAnimationLoop=D,this.isAdditive=S,this.playOrder=g,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Tk=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new R.e,this.onAnimationLoopObservable=new R.e,this._scene=L,a&&this.appendAnimations(j,a),this._speedRatio=Y,L._activeAnimatables.push(this)}syncWith(L){if(this._syncRoot=L,L){const L=this._scene._activeAnimatables.indexOf(this);L>-1&&(this._scene._activeAnimatables.splice(L,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(L,j){for(let P=0;P<j.length;P++){const A=j[P],R=new D(L,A,this._scene,this);R._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(R)}}getAnimationByTargetProperty(L){const j=this._runtimeAnimations;for(let P=0;P<j.length;P++)if(j[P].animation.targetProperty===L)return j[P].animation;return null}getRuntimeAnimationByTargetProperty(L){const j=this._runtimeAnimations;for(let P=0;P<j.length;P++)if(j[P].animation.targetProperty===L)return j[P];return null}reset(){const L=this._runtimeAnimations;for(let j=0;j<L.length;j++)L[j].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(L){const j=this._runtimeAnimations;for(let P=0;P<j.length;P++)j[P].animation.enableBlending=!0,j[P].animation.blendingSpeed=L}disableBlending(){const L=this._runtimeAnimations;for(let j=0;j<L.length;j++)L[j].animation.enableBlending=!1}goToFrame(L){let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const P=this._runtimeAnimations;if(P[0]){const j=P[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??P[0].currentFrame;const A=0===this.speedRatio?0:(L-this._frameToSyncFromJump)/j*1e3/this.speedRatio;this._manualJumpDelay=-A}for(let A=0;A<P.length;A++)P[A].goToFrame(L,j?this._weight:-1);this._goToFrame=L}get paused(){return this.Tk}pause(){this.Tk||(this.Tk=!0)}restart(){this.Tk=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(L,j){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],A=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(L||j){const R=this._scene._activeAnimatables.indexOf(this);if(R>-1){const o=this._runtimeAnimations;for(let P=o.length-1;P>=0;P--){const A=o[P];L&&A.animation.name!=L||(j&&!j(A.target)||(A.dispose(),o.splice(P,1)))}0==o.length&&(P||this._scene._activeAnimatables.splice(R,1),A||this._raiseOnAnimationEnd())}}else{const L=this._scene._activeAnimatables.indexOf(this);if(L>-1){P||this._scene._activeAnimatables.splice(L,1);const j=this._runtimeAnimations;for(let L=0;L<j.length;L++)j[L].dispose();this._runtimeAnimations.length=0,A||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((L=>{this.onAnimationEndObservable.add((()=>{L(this)}),void 0,void 0,this,!0)}))}_animate(L){if(this.Tk)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=L),!0;if(null===this._localDelayOffset?(this._localDelayOffset=L,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=L-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let j=!1;const P=this._runtimeAnimations;let A;for(A=0;A<P.length;A++){const R=P[A].animate(L-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);j=j||R}if(this.animationStarted=j,!j){if(this.disposeOnEnd)for(A=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(A,1),A=0;A<P.length;A++)P[A].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return j}}function V(L){if(0===L.totalWeight&&0===L.totalAdditiveWeight)return L.originalValue;let j=1;const P=a.m.ti[0],A=a.m.ti[1],R=a.m.Quaternion[0];let o=0;const Y=L.animations[0],u=L.originalValue;let D=1,S=!1;if(L.totalWeight<1)D=1-L.totalWeight,u.decompose(A,R,P);else{if(o=1,j=L.totalWeight,D=Y.weight/j,1==D){if(!L.totalAdditiveWeight)return Y.currentValue;S=!0}Y.currentValue.decompose(A,R,P)}if(!S){A.scaleInPlace(D),P.scaleInPlace(D),R.scaleInPlace(D);for(let Y=o;Y<L.animations.length;Y++){const o=L.animations[Y];if(0===o.weight)continue;D=o.weight/j;const u=a.m.ti[2],S=a.m.ti[3],g=a.m.Quaternion[1];o.currentValue.decompose(S,g,u),S.scaleAndAddToRef(D,A),g.scaleAndAddToRef(a.i.Dot(R,g)>0?D:-D,R),u.scaleAndAddToRef(D,P)}R.normalize()}for(let V=0;V<L.additiveAnimations.length;V++){const j=L.additiveAnimations[V];if(0===j.weight)continue;const o=a.m.ti[2],Y=a.m.ti[3],u=a.m.Quaternion[1];j.currentValue.decompose(Y,u,o),Y.multiplyToRef(A,Y),a.r.LerpToRef(A,Y,j.weight,A),R.multiplyToRef(u,u),a.i.SlerpToRef(R,u,j.weight,R),o.scaleAndAddToRef(j.weight,P)}const g=Y?Y._animationState.workValue:a.m.Matrix[0].clone();return a.e.ComposeToRef(A,R,P,g),g}function N(L,j){if(0===L.totalWeight&&0===L.totalAdditiveWeight)return j;const P=L.animations[0],A=L.originalValue;let R=j;if(0===L.totalWeight&&L.totalAdditiveWeight>0)R.p(A);else if(1===L.animations.length){if(a.i.SlerpToRef(A,P.currentValue,Math.min(1,L.totalWeight),R),0===L.totalAdditiveWeight)return R}else if(L.animations.length>1){let P,o,Y=1;if(L.totalWeight<1){const j=1-L.totalWeight;P=[],o=[],P.push(A),o.push(j)}else{if(2===L.animations.length&&(a.i.SlerpToRef(L.animations[0].currentValue,L.animations[1].currentValue,L.animations[1].weight/L.totalWeight,j),0===L.totalAdditiveWeight))return j;P=[],o=[],Y=L.totalWeight}for(let j=0;j<L.animations.length;j++){const A=L.animations[j];P.push(A.currentValue),o.push(A.weight/Y)}let u=0;for(let L=0;L<P.length;)L?(u+=o[L],a.i.SlerpToRef(R,P[L],o[L]/u,R),L++):(a.i.SlerpToRef(P[L],P[L+1],o[L+1]/(o[L]+o[L+1]),j),R=j,u=o[L]+o[L+1],L+=2)}for(let o=0;o<L.additiveAnimations.length;o++){const j=L.additiveAnimations[o];0!==j.weight&&(R.multiplyToRef(j.currentValue,a.m.Quaternion[0]),a.i.SlerpToRef(R,a.m.Quaternion[0],j.weight,R))}return R}var C,b,f=P(2149);C=f.e,(b=u.d)&&(b.prototype.copyAnimationRange=function(L,j,P){let R=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new A.c(this.name,"_matrix",L.animations[0].framePerSecond,A.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Y=L.animations[0].getRange(j);if(!Y)return!1;const u=Y.from,a=Y.to,D=L.animations[0].getKeys(),S=L.length,g=L.getParent(),V=this.getParent(),N=R&&g&&S&&this.length&&S!==this.length,C=N&&V&&g?V.length/g.length:1,b=R&&!V&&o&&(1!==o.x||1!==o.y||1!==o.z),f=this.animations[0].getKeys();let h,K,v;for(let A=0,q=D.length;A<q;A++)h=D[A],h.frame>=u&&h.frame<=a&&(R?(v=h.value.clone(),N?(K=v.getTranslation(),v.setTranslation(K.scaleInPlace(C))):b&&o?(K=v.getTranslation(),v.setTranslation(K.multiplyInPlace(o))):v=h.value):v=h.value,f.push({frame:h.frame+P,value:v}));return this.animations[0].createRange(j,u+P,a+P),!0}),C&&(C.prototype._animate=function(L){if(!this.animationsEnabled)return;const j=S.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=j}this.deltaTime=void 0!==L?L:this.useConstantAnimationDeltaTime?16:(j-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=j;const P=this._activeAnimatables;if(0===P.length)return;this._animationTime+=this.deltaTime;const R=this._animationTime;for(let A=0;A<P.length;A++){const L=P[A];!L._animate(R)&&L.disposeOnEnd&&A--}!function(L){if(L._registeredForLateAnimationBindings.length){for(let j=0;j<L._registeredForLateAnimationBindings.length;j++){const P=L._registeredForLateAnimationBindings.data[j];for(const L in P._lateAnimationHolders){const j=P._lateAnimationHolders[L],R=j.animations[0],o=j.originalValue;if(void 0===o||null===o)continue;const Y=A.c.AllowMatrixDecomposeForInterpolation&&o.m;let u=P[L];if(Y)u=V(j);else if(void 0!==o.w)u=N(j,u||a.i.Identity());else{let L=0,P=1;const Y=R&&R._animationState.loopMode===A.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(j.totalWeight<1)u=Y?o.clone?o.clone():o:R&&o.scale?o.scale(1-j.totalWeight):R?o*(1-j.totalWeight):o.clone?o.clone():o;else if(R){P=j.totalWeight;const A=R.weight/P;u=1!==A?R.currentValue.scale?R.currentValue.scale(A):R.currentValue*A:R.currentValue,Y&&(u.addToRef?u.addToRef(o,u):u+=o),L=1}for(let A=L;A<j.animations.length;A++){const L=j.animations[A],R=L.weight/P;R&&(L.currentValue.scaleAndAddToRef?L.currentValue.scaleAndAddToRef(R,u):u+=L.currentValue*R)}for(let A=0;A<j.additiveAnimations.length;A++){const L=j.additiveAnimations[A],P=L.weight;P&&(L.currentValue.scaleAndAddToRef?L.currentValue.scaleAndAddToRef(P,u):u+=L.currentValue*P)}}P[L]=u}P._lateAnimationHolders={}}L._registeredForLateAnimationBindings.reset()}}(this)},C.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((L,j)=>L.playOrder-j.playOrder))},C.prototype.beginWeightedAnimation=function(L,j,P){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,R=arguments.length>4?arguments[4]:void 0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,u=arguments.length>7?arguments[7]:void 0,a=arguments.length>8?arguments[8]:void 0,D=arguments.length>9?arguments[9]:void 0,S=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const g=this.beginAnimation(L,j,P,R,o,Y,u,!1,a,D,S);return g.weight=A,g},C.prototype.beginAnimation=function(L,j,P,A){let R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,o=arguments.length>5?arguments[5]:void 0,Y=arguments.length>6?arguments[6]:void 0,u=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],a=arguments.length>8?arguments[8]:void 0,D=arguments.length>9?arguments[9]:void 0,S=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(R<0){const L=j;j=P,P=L,R=-R}j>P&&(R=-R),u&&this.stopAnimation(L,void 0,a),Y||(Y=new g(this,L,j,P,A,R,o,void 0,D,S));const V=!a||a(L);if(L.animations&&V&&Y.appendAnimations(L,L.animations),L.getAnimatables){const S=L.getAnimatables();for(let L=0;L<S.length;L++)this.beginAnimation(S[L],j,P,A,R,o,Y,u,a,D)}return Y.reset(),Y},C.prototype.beginHierarchyAnimation=function(L,j,P,A,R){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,u=arguments.length>7?arguments[7]:void 0,a=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],D=arguments.length>9?arguments[9]:void 0,S=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const g=L.getDescendants(j),V=[];V.push(this.beginAnimation(L,P,A,R,o,Y,u,a,D,void 0,S));for(const N of g)V.push(this.beginAnimation(N,P,A,R,o,Y,u,a,D,void 0,S));return V},C.prototype.beginDirectAnimation=function(L,j,P,A,R){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(o<0){const L=P;P=A,A=L,o=-o}return P>A&&(o=-o),new g(this,L,P,A,R,o,arguments.length>6?arguments[6]:void 0,j,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},C.prototype.beginDirectHierarchyAnimation=function(L,j,P,A,R,o,Y,u,a){let D=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const S=L.getDescendants(j),g=[];g.push(this.beginDirectAnimation(L,P,A,R,o,Y,u,a,D));for(const V of S)g.push(this.beginDirectAnimation(V,P,A,R,o,Y,u,a,D));return g},C.prototype.getAnimatableByTarget=function(L){for(let j=0;j<this._activeAnimatables.length;j++)if(this._activeAnimatables[j].target===L)return this._activeAnimatables[j];return null},C.prototype.getAllAnimatablesByTarget=function(L){const j=[];for(let P=0;P<this._activeAnimatables.length;P++)this._activeAnimatables[P].target===L&&j.push(this._activeAnimatables[P]);return j},C.prototype.stopAnimation=function(L,j,P){const A=this.getAllAnimatablesByTarget(L);for(const R of A)R.stop(j,P)},C.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let L=0;L<this._activeAnimatables.length;L++)this._activeAnimatables[L].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const L of this.animationGroups)L.stop()});class h{getClassName(){return"TargetedAnimation"}serialize(){const L={};return L.animation=this.animation.serialize(),L.targetId=this.target.id,L}}class K{get mask(){return this._mask}set mask(L){this._mask!==L&&(this._mask=L,this.syncWithMask(!0))}syncWithMask(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||L){this._numActiveAnimatables=0;for(let L=0;L<this._animatables.length;++L){const j=this._animatables[L];!this.mask||this.mask.disabled||this.mask.retainsTarget(j.target.name)?(this._numActiveAnimatables++,j.paused&&j.restart()):j.paused||j.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let L=0;L<this._animatables.length;++L){const j=this._animatables[L];this.mask.retainsTarget(j.target.name)||(j.stop(),this._animatables.splice(L,1),--L)}for(let L=0;L<this._targetedAnimations.length;L++){const j=this._targetedAnimations[L];this.mask.retainsTarget(j.target.name)||(this._targetedAnimations.splice(L,1),--L)}}}get from(){return this._from}set from(L){if(this._from!==L){this._from=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].fromFrame=this._from}}}get to(){return this._to}set to(L){if(this._to!==L){this._to=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(L){if(this._speedRatio!==L){this._speedRatio=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(L){if(this._loopAnimation!==L){this._loopAnimation=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(L){if(this._isAdditive!==L){this._isAdditive=L;for(let L=0;L<this._animatables.length;L++){this._animatables[L].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(L){this._weight!==L&&(this._weight=L,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(L){if(this._playOrder!==L&&(this._playOrder=L,this._animatables.length>0)){for(let L=0;L<this._animatables.length;L++)this._animatables[L].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(L){if(this._enableBlending!==L&&(this._enableBlending=L,null!==L))for(let j=0;j<this._targetedAnimations.length;++j)this._targetedAnimations[j].animation.enableBlending=L}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(L){if(this._blendingSpeed!==L&&(this._blendingSpeed=L,null!==L))for(let j=0;j<this._targetedAnimations.length;++j)this._targetedAnimations[j].animation.blendingSpeed=L}getLength(L,j){L=L??this._from;return((j=j??this._to)-L)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(L){let j=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],A=arguments.length>3?arguments[3]:void 0;if(0===L.length)return null;A=A??L[0].weight;let R=Number.MAX_VALUE,o=-Number.MAX_VALUE;if(P)for(const u of L)u.from<R&&(R=u.from),u.to>o&&(o=u.to);const Y=new K(L[0].name+"_merged",L[0]._scene,A);for(const u of L){P&&u.normalize(R,o);for(const L of u.targetedAnimations)Y.addTargetedAnimation(L.animation,L.target);j&&u.dispose()}return Y}constructor(L){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=L,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new R.e,this.onAnimationLoopObservable=new R.e,this.onAnimationGroupLoopObservable=new R.e,this.onAnimationGroupEndObservable=new R.e,this.onAnimationGroupPauseObservable=new R.e,this.onAnimationGroupPlayObservable=new R.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=j||o.b.LastCreatedScene,this._weight=P,this._playOrder=A,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(L,j){const P=new h;P.animation=L,P.target=j;const A=L.getKeys();return this._from>A[0].frame&&(this._from=A[0].frame),this._to<A[A.length-1].frame&&(this._to=A[A.length-1].frame),null!==this._enableBlending&&(L.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(L.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(P),this._shouldStart=!0,P}removeTargetedAnimation(L){for(let j=this._targetedAnimations.length-1;j>-1;j--){this._targetedAnimations[j].animation===L&&this._targetedAnimations.splice(j,1)}}normalize(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==L&&(L=this._from),null==j&&(j=this._to);for(let P=0;P<this._targetedAnimations.length;P++){const A=this._targetedAnimations[P].animation.getKeys(),R=A[0],o=A[A.length-1];if(R.frame>L){const j={frame:L,value:R.value,inTangent:R.inTangent,outTangent:R.outTangent,interpolation:R.interpolation};A.splice(0,0,j)}if(o.frame<j){const L={frame:j,value:o.value,inTangent:o.inTangent,outTangent:o.outTangent,interpolation:o.interpolation};A.push(L)}}return this._from=L,this._to=j,this}_processLoop(L,j,P){L.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(j),this._animationLoopFlags[P]||(this._animationLoopFlags[P]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0],j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0,A=arguments.length>3?arguments[3]:void 0,R=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=L,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let o=0;o<this._targetedAnimations.length;o++){const Y=this._targetedAnimations[o],u=this._scene.beginDirectAnimation(Y.target,[Y.animation],void 0!==P?P:this._from,void 0!==A?A:this._to,L,j,void 0,void 0,void 0!==R?R:this._isAdditive);u.weight=this._weight,u.playOrder=this._playOrder,u.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Y),this._checkAnimationGroupEnded(u)},this._processLoop(u,Y,o),this._animatables.push(u)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=j,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let L=0;L<this._animatables.length;L++){this._animatables[L].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(L){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==L&&(this.loopAnimation=L),this.restart()):(this.stop(),this.start(L,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let L=0;L<this._animatables.length;L++){this._animatables[L].reset()}return this}restart(){if(!this._isStarted)return this;for(let L=0;L<this._animatables.length;L++){this._animatables[L].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const j=this._animatables.slice();for(let A=0;A<j.length;A++)j[A].stop(void 0,void 0,!0,L);let P=0;for(let A=0;A<this._scene._activeAnimatables.length;A++){const j=this._scene._activeAnimatables[A];j._runtimeAnimations.length>0?this._scene._activeAnimatables[P++]=j:L&&this._checkAnimationGroupEnded(j,L)}return this._scene._activeAnimatables.length=P,this._isStarted=!1,this}setWeightForAllAnimatables(L){for(let j=0;j<this._animatables.length;j++){this._animatables[j].weight=L}return this}syncAllAnimationsWith(L){for(let j=0;j<this._animatables.length;j++){this._animatables[j].syncWith(L)}return this}goToFrame(L){let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let P=0;P<this._animatables.length;P++){this._animatables[P].goToFrame(L,j)}return this}getCurrentFrame(){var L;return(null===(L=this.animatables[0])||void 0===L?void 0:L.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const L=this._scene.animationGroups.indexOf(this);if(L>-1&&this._scene.animationGroups.splice(L,1),this._parentContainer){const L=this._parentContainer.animationGroups.indexOf(this);L>-1&&this._parentContainer.animationGroups.splice(L,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(L){let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const P=this._animatables.indexOf(L);P>-1&&this._animatables.splice(P,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,j||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(L,j){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const A=new K(L||this.name,this._scene,this._weight,this._playOrder);A._from=this.from,A._to=this.to,A._speedRatio=this.speedRatio,A._loopAnimation=this.loopAnimation,A._isAdditive=this.isAdditive,A._enableBlending=this.enableBlending,A._blendingSpeed=this.blendingSpeed,A.metadata=this.metadata,A.mask=this.mask;for(const R of this._targetedAnimations)A.addTargetedAnimation(P?R.animation.clone():R.animation,j?j(R.target):R.target);return A}serialize(){const L={};L.name=this.name,L.from=this.from,L.to=this.to,L.speedRatio=this.speedRatio,L.loopAnimation=this.loopAnimation,L.isAdditive=this.isAdditive,L.weight=this.weight,L.playOrder=this.playOrder,L.enableBlending=this.enableBlending,L.blendingSpeed=this.blendingSpeed,L.targetedAnimations=[];for(let j=0;j<this.targetedAnimations.length;j++){const P=this.targetedAnimations[j];L.targetedAnimations[j]=P.serialize()}return Y.d&&Y.d.HasTags(this)&&(L.tags=Y.d.GetTags(this)),this.metadata&&(L.metadata=this.metadata),L}static Parse(L,j){const P=new K(L.name,j,L.weight,L.playOrder);for(let R=0;R<L.targetedAnimations.length;R++){const o=L.targetedAnimations[R],Y=A.c.Parse(o.animation),u=o.targetId;if("influence"===o.animation.property){const L=j.getMorphTargetById(u);L&&P.addTargetedAnimation(Y,L)}else{const L=j.getNodeById(u);null!=L&&P.addTargetedAnimation(Y,L)}}return Y.d&&Y.d.AddTagsTo(P,L.tags),null!==L.from&&null!==L.to&&P.normalize(L.from,L.to),void 0!==L.speedRatio&&(P._speedRatio=L.speedRatio),void 0!==L.loopAnimation&&(P._loopAnimation=L.loopAnimation),void 0!==L.isAdditive&&(P._isAdditive=L.isAdditive),void 0!==L.weight&&(P._weight=L.weight),void 0!==L.playOrder&&(P._playOrder=L.playOrder),void 0!==L.enableBlending&&(P._enableBlending=L.enableBlending),void 0!==L.blendingSpeed&&(P._blendingSpeed=L.blendingSpeed),void 0!==L.metadata&&(P.metadata=L.metadata),P}static MakeAnimationAdditive(L,j,P){let R;R="object"===typeof j?j:{referenceFrame:j,range:P,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let o=L;R.cloneOriginalAnimationGroup&&(o=L.clone(R.clonedAnimationGroupName||o.name));const Y=o.targetedAnimations;for(let u=0;u<Y.length;u++){const L=Y[u];L.animation=A.c.MakeAnimationAdditive(L.animation,R)}if(o.isAdditive=!0,R.clipKeys){let L=Number.MAX_VALUE,j=-Number.MAX_VALUE;const P=o.targetedAnimations;for(let A=0;A<P.length;A++){const R=P[A].animation.getKeys();L>R[0].frame&&(L=R[0].frame),j<R[R.length-1].frame&&(j=R[R.length-1].frame)}o._from=L,o._to=j}return o}static ClipKeys(L,j,P,A,R){const o=L.clone(A||L.name);return K.ClipKeysInPlace(o,j,P,R)}static ClipKeysInPlace(L,j,P,A){return K.ClipInPlace(L,j,P,A,!1)}static ClipFrames(L,j,P,A,R){const o=L.clone(A||L.name);return K.ClipFramesInPlace(o,j,P,R)}static ClipFramesInPlace(L,j,P,A){return K.ClipInPlace(L,j,P,A,!0)}static ClipInPlace(L,j,P,A){let R=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=Number.MAX_VALUE,Y=-Number.MAX_VALUE;const u=L.targetedAnimations;for(let a=0;a<u.length;a++){const L=u[a],D=A?L.animation:L.animation.clone();R&&(D.createKeyForFrame(j),D.createKeyForFrame(P));const S=D.getKeys(),g=[];let V=Number.MAX_VALUE;for(let A=0;A<S.length;A++){const L=S[A];if(!R&&A>=j&&A<=P||R&&L.frame>=j&&L.frame<=P){const j={frame:L.frame,value:L.value.clone?L.value.clone():L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation,lockedTangent:L.lockedTangent};V===Number.MAX_VALUE&&(V=j.frame),j.frame-=V,g.push(j)}}0!==g.length?(o>g[0].frame&&(o=g[0].frame),Y<g[g.length-1].frame&&(Y=g[g.length-1].frame),D.setKeys(g,!0),L.animation=D):(u.splice(a,1),a--)}return L._from=o,L._to=Y,L}getClassName(){return"AnimationGroup"}toString(L){let j="Name: "+this.name;return j+=", type: "+this.getClassName(),L&&(j+=", from: "+this._from,j+=", to: "+this._to,j+=", isStarted: "+this._isStarted,j+=", speedRatio: "+this._speedRatio,j+=", targetedAnimations length: "+this._targetedAnimations.length,j+=", animatables length: "+this._animatables),j}}}}]);