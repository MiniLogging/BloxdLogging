"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[62],{14138:(v,d,Q)=>{Q.r(d),Q.d(d,{AnimationGroup:()=>S,TargetedAnimation:()=>h});var n=Q(12002),T=Q(473),L=Q(508),e=Q(608),F=Q(12843),r=Q(651);class C{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(v,d,Q,T){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=d,this._target=v,this._scene=Q,this._host=T,this._activeTargets=[],d._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===n.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=r.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const v={frame:0,value:this._minValue};this._keys.splice(0,0,v)}if(this._target instanceof Array){let v=0;for(const d of this._target)this._preparePath(d,v),this._getOriginalValues(v),v++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const L=d.getEvents();if(L&&L.length>0)for(const n of L)this._events.push(n._clone());this._enableBlending=v&&v.animationPropertiesOverride?v.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(v){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Q=this._animation.targetPropertyPath;if(Q.length>1){let n=v;for(let v=0;v<Q.length-1;v++){const d=Q[v];if(n=n[d],void 0===n)throw new Error(`Invalid property (${d}) in property path (${Q.join(".")})`)}this._targetPath=Q[Q.length-1],this._activeTargets[d]=n}else this._targetPath=Q[0],this._activeTargets[d]=v;if(void 0===this._activeTargets[d][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${Q.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let v=0;for(const d of this._target)void 0!==this._originalValue[v]&&this._setValue(d,this._activeTargets[v],this._originalValue[v],-1,v),v++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let v=0;v<this._events.length;v++)this._events[v].isDone=!1}isStopped(){return this._stopped}dispose(){const v=this._animation.runtimeAnimations.indexOf(this);v>-1&&this._animation.runtimeAnimations.splice(v,1)}setValue(v,d){if(this._targetIsArray)for(let Q=0;Q<this._target.length;Q++){const n=this._target[Q];this._setValue(n,this._activeTargets[Q],v,d,Q)}else this._setValue(this._target,this._directTarget,v,d,0)}_getOriginalValues(){let v,d=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Q=this._activeTargets[d];v=Q.getLocalMatrix&&"_matrix"===this._targetPath?Q.getLocalMatrix():Q[this._targetPath],v&&v.clone?this._originalValue[d]=v.clone():this._originalValue[d]=v}_registerTargetForLateAnimationBinding(v,d){const Q=v.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(Q),Q._lateAnimationHolders||(Q._lateAnimationHolders={}),Q._lateAnimationHolders[v.targetPath]||(Q._lateAnimationHolders[v.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:d}),v.isAdditive?(Q._lateAnimationHolders[v.targetPath].additiveAnimations.push(v),Q._lateAnimationHolders[v.targetPath].totalAdditiveWeight+=v.weight):(Q._lateAnimationHolders[v.targetPath].animations.push(v),Q._lateAnimationHolders[v.targetPath].totalWeight+=v.weight)}_setValue(v,d,Q,T,L){if(this._currentActiveTarget=d,this._weight=T,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const v=d[this._targetPath];v.clone?this._originalBlendValue=v.clone():this._originalBlendValue=v}this._originalBlendValue.m?n.d.AllowMatrixDecomposeForInterpolation?this._currentValue?r.b.DecomposeLerpToRef(this._originalBlendValue,Q,this._blendingFactor,this._currentValue):this._currentValue=r.b.DecomposeLerp(this._originalBlendValue,Q,this._blendingFactor):this._currentValue?r.b.LerpToRef(this._originalBlendValue,Q,this._blendingFactor,this._currentValue):this._currentValue=r.b.Lerp(this._originalBlendValue,Q,this._blendingFactor):this._currentValue=n.d._UniversalLerp(this._originalBlendValue,Q,this._blendingFactor);const T=v&&v.animationPropertiesOverride?v.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=T}else this._currentValue?this._currentValue.p?this._currentValue.p(Q):this._currentValue=Q:null!==Q&&void 0!==Q&&Q.clone?this._currentValue=Q.clone():this._currentValue=Q;-1!==T?this._registerTargetForLateAnimationBinding(this,this._originalValue[L]):this._animationState.loopMode===n.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[L],d[this._targetPath]):d[this._targetPath]=this._originalValue[L]+this._currentValue:d[this._targetPath]=this._currentValue,v.bk&&v.bk(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(v){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const Q=this._animation.getKeys();v<Q[0].frame?v=Q[0].frame:v>Q[Q.length-1].frame&&(v=Q[Q.length-1].frame);const n=this._events;if(n.length)for(let L=0;L<n.length;L++)n[L].onlyOnce||(n[L].isDone=n[L].frame<v);this._currentFrame=v;const T=this._animation._interpolate(v,this._animationState);this.setValue(T,d)}_prepareForSpeedRatioChange(v){const d=this._previousElapsedTime*(this._animation.framePerSecond*v)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-d}animate(v,d,Q,T,L){let e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const F=this._animation,r=F.targetPropertyPath;if(!r||r.length<1)return this._stopped=!0,!1;let C,u=!0;const y=this._events;let z=0;if(this._coreRuntimeAnimation)z=Q-d,C=this._coreRuntimeAnimation.currentFrame,this._currentFrame=C,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let e;(d<this._minFrame||d>this._maxFrame)&&(d=this._minFrame),(Q<this._minFrame||Q>this._maxFrame)&&(Q=this._maxFrame),z=Q-d;let r=v*(F.framePerSecond*L)/1e3+this._absoluteFrameOffset,B=0,X=!1;const m=T&&this._animationState.loopMode===n.d.ANIMATIONLOOPMODE_YOYO;if(m){const v=(r-d)/z,Q=Math.sin(v*Math.PI);r=Math.abs(Q)*z+d;const n=Q>=0?1:-1;this._yoyoDirection!==n&&(X=!0),this._yoyoDirection=n}if(this._previousElapsedTime=v,this._previousAbsoluteFrame=r,!T&&Q>=d&&(r>=z&&L>0||r<=0&&L<0))u=!1,B=F._getKeyValue(this._maxValue);else if(!T&&d>=Q&&(r<=z&&L<0||r>=0&&L>0))u=!1,B=F._getKeyValue(this._minValue);else if(this._animationState.loopMode!==n.d.ANIMATIONLOOPMODE_CYCLE){const v=Q.toString()+d.toString();if(!this._offsetsCache[v]){this._animationState.repeatCount=0,this._animationState.loopMode=n.d.ANIMATIONLOOPMODE_CYCLE;const T=F._interpolate(d,this._animationState),L=F._interpolate(Q,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),F.dataType){case n.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[v]=L-T;break;case n.d.ANIMATIONTYPE_QUATERNION:case n.d.ANIMATIONTYPE_VECTOR3:case n.d.ANIMATIONTYPE_VECTOR2:case n.d.ANIMATIONTYPE_SIZE:case n.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[v]=L.Wd(T)}this._highLimitsCache[v]=L}B=this._highLimitsCache[v],e=this._offsetsCache[v]}if(void 0===e)switch(F.dataType){case n.d.ANIMATIONTYPE_FLOAT:e=0;break;case n.d.ANIMATIONTYPE_QUATERNION:e=n.m;break;case n.d.ANIMATIONTYPE_VECTOR3:e=n.r;break;case n.d.ANIMATIONTYPE_VECTOR2:e=n.p;break;case n.d.ANIMATIONTYPE_SIZE:e=n.n;break;case n.d.ANIMATIONTYPE_COLOR3:e=n.h;break;case n.d.ANIMATIONTYPE_COLOR4:e=n.i}if(this._host&&this._host.syncRoot){const v=this._host.syncRoot;C=d+z*((v.masterFrame-v.fromFrame)/(v.toFrame-v.fromFrame))}else C=r>0&&d>Q||r<0&&d<Q?u&&0!==z?Q+r%z:d:u&&0!==z?d+r%z:Q;if(!m&&(L>0&&this.currentFrame>C||L<0&&this.currentFrame<C)||m&&X){this._onLoop();for(let v=0;v<y.length;v++)y[v].onlyOnce||(y[v].isDone=!1);this._animationState.key=L>0?0:F.getKeys().length-1}this._currentFrame=C,this._animationState.repeatCount=0===z?0:r/z|0,this._animationState.highLimitValue=B,this._animationState.offsetValue=e}const B=F._interpolate(C,this._animationState);if(this.setValue(B,e),y.length)for(let n=0;n<y.length;n++)if(z>=0&&C>=y[n].frame&&y[n].frame>=d||z<0&&C<=y[n].frame&&y[n].frame<=d){const v=y[n];v.isDone||(v.onlyOnce&&(y.splice(n,1),n--),v.isDone=!0,v.action(C))}return u||(this._stopped=!0),u}}var u=Q(488);class y{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(v){this._weight=-1!==v?Math.min(Math.max(v,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(v){for(let d=0;d<this._runtimeAnimations.length;d++){this._runtimeAnimations[d]._prepareForSpeedRatioChange(v)}this._speedRatio=v,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(v,d){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,L=arguments.length>4&&void 0!==arguments[4]&&arguments[4],e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,F=arguments.length>6?arguments[6]:void 0,r=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,u=arguments.length>9&&void 0!==arguments[9]&&arguments[9],y=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=d,this.fromFrame=Q,this.toFrame=n,this.loopAnimation=L,this.onAnimationEnd=F,this.onAnimationLoop=C,this.isAdditive=u,this.playOrder=y,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Yj=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new T.e,this.onAnimationLoopObservable=new T.e,this._scene=v,r&&this.appendAnimations(d,r),this._speedRatio=e,v._activeAnimatables.push(this)}syncWith(v){if(this._syncRoot=v,v){const v=this._scene._activeAnimatables.indexOf(this);v>-1&&(this._scene._activeAnimatables.splice(v,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(v,d){for(let Q=0;Q<d.length;Q++){const n=d[Q],T=new C(v,n,this._scene,this);T._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(T)}}getAnimationByTargetProperty(v){const d=this._runtimeAnimations;for(let Q=0;Q<d.length;Q++)if(d[Q].animation.targetProperty===v)return d[Q].animation;return null}getRuntimeAnimationByTargetProperty(v){const d=this._runtimeAnimations;for(let Q=0;Q<d.length;Q++)if(d[Q].animation.targetProperty===v)return d[Q];return null}reset(){const v=this._runtimeAnimations;for(let d=0;d<v.length;d++)v[d].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(v){const d=this._runtimeAnimations;for(let Q=0;Q<d.length;Q++)d[Q].animation.enableBlending=!0,d[Q].animation.blendingSpeed=v}disableBlending(){const v=this._runtimeAnimations;for(let d=0;d<v.length;d++)v[d].animation.enableBlending=!1}goToFrame(v){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Q=this._runtimeAnimations;if(Q[0]){const d=Q[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??Q[0].currentFrame;const n=0===this.speedRatio?0:(v-this._frameToSyncFromJump)/d*1e3/this.speedRatio;this._manualJumpDelay=-n}for(let n=0;n<Q.length;n++)Q[n].goToFrame(v,d?this._weight:-1);this._goToFrame=v}get paused(){return this.Yj}pause(){this.Yj||(this.Yj=!0)}restart(){this.Yj=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(v,d){let Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(v||d){const T=this._scene._activeAnimatables.indexOf(this);if(T>-1){const L=this._runtimeAnimations;for(let Q=L.length-1;Q>=0;Q--){const n=L[Q];v&&n.animation.name!=v||(d&&!d(n.target)||(n.dispose(),L.splice(Q,1)))}0==L.length&&(Q||this._scene._activeAnimatables.splice(T,1),n||this._raiseOnAnimationEnd())}}else{const v=this._scene._activeAnimatables.indexOf(this);if(v>-1){Q||this._scene._activeAnimatables.splice(v,1);const d=this._runtimeAnimations;for(let v=0;v<d.length;v++)d[v].dispose();this._runtimeAnimations.length=0,n||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((v=>{this.onAnimationEndObservable.add((()=>{v(this)}),void 0,void 0,this,!0)}))}_animate(v){if(this.Yj)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=v),!0;if(null===this._localDelayOffset?(this._localDelayOffset=v,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=v-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let d=!1;const Q=this._runtimeAnimations;let n;for(n=0;n<Q.length;n++){const T=Q[n].animate(v-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);d=d||T}if(this.animationStarted=d,!d){if(this.disposeOnEnd)for(n=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(n,1),n=0;n<Q.length;n++)Q[n].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return d}}function z(v){if(0===v.totalWeight&&0===v.totalAdditiveWeight)return v.originalValue;let d=1;const Q=r.g.fk[0],n=r.g.fk[1],T=r.g.Quaternion[0];let L=0;const e=v.animations[0],F=v.originalValue;let C=1,u=!1;if(v.totalWeight<1)C=1-v.totalWeight,F.decompose(n,T,Q);else{if(L=1,d=v.totalWeight,C=e.weight/d,1==C){if(!v.totalAdditiveWeight)return e.currentValue;u=!0}e.currentValue.decompose(n,T,Q)}if(!u){n.scaleInPlace(C),Q.scaleInPlace(C),T.scaleInPlace(C);for(let e=L;e<v.animations.length;e++){const L=v.animations[e];if(0===L.weight)continue;C=L.weight/d;const F=r.g.fk[2],u=r.g.fk[3],y=r.g.Quaternion[1];L.currentValue.decompose(u,y,F),u.scaleAndAddToRef(C,n),y.scaleAndAddToRef(r.c.Dot(T,y)>0?C:-C,T),F.scaleAndAddToRef(C,Q)}T.normalize()}for(let z=0;z<v.additiveAnimations.length;z++){const d=v.additiveAnimations[z];if(0===d.weight)continue;const L=r.g.fk[2],e=r.g.fk[3],F=r.g.Quaternion[1];d.currentValue.decompose(e,F,L),e.multiplyToRef(n,e),r.j.LerpToRef(n,e,d.weight,n),T.multiplyToRef(F,F),r.c.SlerpToRef(T,F,d.weight,T),L.scaleAndAddToRef(d.weight,Q)}const y=e?e._animationState.workValue:r.g.Matrix[0].clone();return r.b.ComposeToRef(n,T,Q,y),y}function B(v,d){if(0===v.totalWeight&&0===v.totalAdditiveWeight)return d;const Q=v.animations[0],n=v.originalValue;let T=d;if(0===v.totalWeight&&v.totalAdditiveWeight>0)T.p(n);else if(1===v.animations.length){if(r.c.SlerpToRef(n,Q.currentValue,Math.min(1,v.totalWeight),T),0===v.totalAdditiveWeight)return T}else if(v.animations.length>1){let Q,L,e=1;if(v.totalWeight<1){const d=1-v.totalWeight;Q=[],L=[],Q.push(n),L.push(d)}else{if(2===v.animations.length&&(r.c.SlerpToRef(v.animations[0].currentValue,v.animations[1].currentValue,v.animations[1].weight/v.totalWeight,d),0===v.totalAdditiveWeight))return d;Q=[],L=[],e=v.totalWeight}for(let d=0;d<v.animations.length;d++){const n=v.animations[d];Q.push(n.currentValue),L.push(n.weight/e)}let F=0;for(let v=0;v<Q.length;)v?(F+=L[v],r.c.SlerpToRef(T,Q[v],L[v]/F,T),v++):(r.c.SlerpToRef(Q[v],Q[v+1],L[v+1]/(L[v]+L[v+1]),d),T=d,F=L[v]+L[v+1],v+=2)}for(let L=0;L<v.additiveAnimations.length;L++){const d=v.additiveAnimations[L];0!==d.weight&&(T.multiplyToRef(d.currentValue,r.g.Quaternion[0]),r.c.SlerpToRef(T,r.g.Quaternion[0],d.weight,T))}return T}var X,m,V=Q(2167);X=V.d,(m=F.b)&&(m.prototype.copyAnimationRange=function(v,d,Q){let T=arguments.length>3&&void 0!==arguments[3]&&arguments[3],L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new n.d(this.name,"_matrix",v.animations[0].framePerSecond,n.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const e=v.animations[0].getRange(d);if(!e)return!1;const F=e.from,r=e.to,C=v.animations[0].getKeys(),u=v.length,y=v.getParent(),z=this.getParent(),B=T&&y&&u&&this.length&&u!==this.length,X=B&&z&&y?z.length/y.length:1,m=T&&!z&&L&&(1!==L.x||1!==L.y||1!==L.z),V=this.animations[0].getKeys();let h,S,A;for(let n=0,f=C.length;n<f;n++)h=C[n],h.frame>=F&&h.frame<=r&&(T?(A=h.value.clone(),B?(S=A.getTranslation(),A.setTranslation(S.scaleInPlace(X))):m&&L?(S=A.getTranslation(),A.setTranslation(S.multiplyInPlace(L))):A=h.value):A=h.value,V.push({frame:h.frame+Q,value:A}));return this.animations[0].createRange(d,F+Q,r+Q),!0}),X&&(X.prototype._animate=function(v){if(!this.animationsEnabled)return;const d=u.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=d}this.deltaTime=void 0!==v?v:this.useConstantAnimationDeltaTime?16:(d-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=d;const Q=this._activeAnimatables;if(0===Q.length)return;this._animationTime+=this.deltaTime;const T=this._animationTime;for(let n=0;n<Q.length;n++){const v=Q[n];!v._animate(T)&&v.disposeOnEnd&&n--}!function(v){if(v._registeredForLateAnimationBindings.length){for(let d=0;d<v._registeredForLateAnimationBindings.length;d++){const Q=v._registeredForLateAnimationBindings.data[d];for(const v in Q._lateAnimationHolders){const d=Q._lateAnimationHolders[v],T=d.animations[0],L=d.originalValue;if(void 0===L||null===L)continue;const e=n.d.AllowMatrixDecomposeForInterpolation&&L.m;let F=Q[v];if(e)F=z(d);else if(void 0!==L.w)F=B(d,F||r.c.Identity());else{let v=0,Q=1;const e=T&&T._animationState.loopMode===n.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(d.totalWeight<1)F=e?L.clone?L.clone():L:T&&L.scale?L.scale(1-d.totalWeight):T?L*(1-d.totalWeight):L.clone?L.clone():L;else if(T){Q=d.totalWeight;const n=T.weight/Q;F=1!==n?T.currentValue.scale?T.currentValue.scale(n):T.currentValue*n:T.currentValue,e&&(F.addToRef?F.addToRef(L,F):F+=L),v=1}for(let n=v;n<d.animations.length;n++){const v=d.animations[n],T=v.weight/Q;T&&(v.currentValue.scaleAndAddToRef?v.currentValue.scaleAndAddToRef(T,F):F+=v.currentValue*T)}for(let n=0;n<d.additiveAnimations.length;n++){const v=d.additiveAnimations[n],Q=v.weight;Q&&(v.currentValue.scaleAndAddToRef?v.currentValue.scaleAndAddToRef(Q,F):F+=v.currentValue*Q)}}Q[v]=F}Q._lateAnimationHolders={}}v._registeredForLateAnimationBindings.reset()}}(this)},X.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((v,d)=>v.playOrder-d.playOrder))},X.prototype.beginWeightedAnimation=function(v,d,Q){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,T=arguments.length>4?arguments[4]:void 0,L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,e=arguments.length>6?arguments[6]:void 0,F=arguments.length>7?arguments[7]:void 0,r=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,u=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const y=this.beginAnimation(v,d,Q,T,L,e,F,!1,r,C,u);return y.weight=n,y},X.prototype.beginAnimation=function(v,d,Q,n){let T=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,L=arguments.length>5?arguments[5]:void 0,e=arguments.length>6?arguments[6]:void 0,F=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],r=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,u=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(T<0){const v=d;d=Q,Q=v,T=-T}d>Q&&(T=-T),F&&this.stopAnimation(v,void 0,r),e||(e=new y(this,v,d,Q,n,T,L,void 0,C,u));const z=!r||r(v);if(v.animations&&z&&e.appendAnimations(v,v.animations),v.getAnimatables){const u=v.getAnimatables();for(let v=0;v<u.length;v++)this.beginAnimation(u[v],d,Q,n,T,L,e,F,r,C)}return e.reset(),e},X.prototype.beginHierarchyAnimation=function(v,d,Q,n,T){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,e=arguments.length>6?arguments[6]:void 0,F=arguments.length>7?arguments[7]:void 0,r=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],C=arguments.length>9?arguments[9]:void 0,u=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const y=v.getDescendants(d),z=[];z.push(this.beginAnimation(v,Q,n,T,L,e,F,r,C,void 0,u));for(const B of y)z.push(this.beginAnimation(B,Q,n,T,L,e,F,r,C,void 0,u));return z},X.prototype.beginDirectAnimation=function(v,d,Q,n,T){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(L<0){const v=Q;Q=n,n=v,L=-L}return Q>n&&(L=-L),new y(this,v,Q,n,T,L,arguments.length>6?arguments[6]:void 0,d,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},X.prototype.beginDirectHierarchyAnimation=function(v,d,Q,n,T,L,e,F,r){let C=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const u=v.getDescendants(d),y=[];y.push(this.beginDirectAnimation(v,Q,n,T,L,e,F,r,C));for(const z of u)y.push(this.beginDirectAnimation(z,Q,n,T,L,e,F,r,C));return y},X.prototype.getAnimatableByTarget=function(v){for(let d=0;d<this._activeAnimatables.length;d++)if(this._activeAnimatables[d].target===v)return this._activeAnimatables[d];return null},X.prototype.getAllAnimatablesByTarget=function(v){const d=[];for(let Q=0;Q<this._activeAnimatables.length;Q++)this._activeAnimatables[Q].target===v&&d.push(this._activeAnimatables[Q]);return d},X.prototype.stopAnimation=function(v,d,Q){const n=this.getAllAnimatablesByTarget(v);for(const T of n)T.stop(d,Q)},X.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let v=0;v<this._activeAnimatables.length;v++)this._activeAnimatables[v].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const v of this.animationGroups)v.stop()});class h{getClassName(){return"TargetedAnimation"}serialize(){const v={};return v.animation=this.animation.serialize(),v.targetId=this.target.id,v}}class S{get mask(){return this._mask}set mask(v){this._mask!==v&&(this._mask=v,this.syncWithMask(!0))}syncWithMask(){let v=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||v){this._numActiveAnimatables=0;for(let v=0;v<this._animatables.length;++v){const d=this._animatables[v];!this.mask||this.mask.disabled||this.mask.retainsTarget(d.target.name)?(this._numActiveAnimatables++,d.paused&&d.restart()):d.paused||d.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let v=0;v<this._animatables.length;++v){const d=this._animatables[v];this.mask.retainsTarget(d.target.name)||(d.stop(),this._animatables.splice(v,1),--v)}for(let v=0;v<this._targetedAnimations.length;v++){const d=this._targetedAnimations[v];this.mask.retainsTarget(d.target.name)||(this._targetedAnimations.splice(v,1),--v)}}}get from(){return this._from}set from(v){if(this._from!==v){this._from=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].fromFrame=this._from}}}get to(){return this._to}set to(v){if(this._to!==v){this._to=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(v){if(this._speedRatio!==v){this._speedRatio=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(v){if(this._loopAnimation!==v){this._loopAnimation=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(v){if(this._isAdditive!==v){this._isAdditive=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(v){this._weight!==v&&(this._weight=v,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(v){if(this._playOrder!==v&&(this._playOrder=v,this._animatables.length>0)){for(let v=0;v<this._animatables.length;v++)this._animatables[v].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(v){if(this._enableBlending!==v&&(this._enableBlending=v,null!==v))for(let d=0;d<this._targetedAnimations.length;++d)this._targetedAnimations[d].animation.enableBlending=v}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(v){if(this._blendingSpeed!==v&&(this._blendingSpeed=v,null!==v))for(let d=0;d<this._targetedAnimations.length;++d)this._targetedAnimations[d].animation.blendingSpeed=v}getLength(v,d){v=v??this._from;return((d=d??this._to)-v)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(v){let d=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3?arguments[3]:void 0;if(0===v.length)return null;n=n??v[0].weight;let T=Number.MAX_VALUE,L=-Number.MAX_VALUE;if(Q)for(const F of v)F.from<T&&(T=F.from),F.to>L&&(L=F.to);const e=new S(v[0].name+"_merged",v[0]._scene,n);for(const F of v){Q&&F.normalize(T,L);for(const v of F.targetedAnimations)e.addTargetedAnimation(v.animation,v.target);d&&F.dispose()}return e}constructor(v){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=v,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new T.e,this.onAnimationLoopObservable=new T.e,this.onAnimationGroupLoopObservable=new T.e,this.onAnimationGroupEndObservable=new T.e,this.onAnimationGroupPauseObservable=new T.e,this.onAnimationGroupPlayObservable=new T.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=d||L.c.LastCreatedScene,this._weight=Q,this._playOrder=n,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(v,d){const Q=new h;Q.animation=v,Q.target=d;const n=v.getKeys();return this._from>n[0].frame&&(this._from=n[0].frame),this._to<n[n.length-1].frame&&(this._to=n[n.length-1].frame),null!==this._enableBlending&&(v.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(v.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(Q),this._shouldStart=!0,Q}removeTargetedAnimation(v){for(let d=this._targetedAnimations.length-1;d>-1;d--){this._targetedAnimations[d].animation===v&&this._targetedAnimations.splice(d,1)}}normalize(){let v=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==v&&(v=this._from),null==d&&(d=this._to);for(let Q=0;Q<this._targetedAnimations.length;Q++){const n=this._targetedAnimations[Q].animation.getKeys(),T=n[0],L=n[n.length-1];if(T.frame>v){const d={frame:v,value:T.value,inTangent:T.inTangent,outTangent:T.outTangent,interpolation:T.interpolation};n.splice(0,0,d)}if(L.frame<d){const v={frame:d,value:L.value,inTangent:L.inTangent,outTangent:L.outTangent,interpolation:L.interpolation};n.push(v)}}return this._from=v,this._to=d,this}_processLoop(v,d,Q){v.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(d),this._animationLoopFlags[Q]||(this._animationLoopFlags[Q]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let v=arguments.length>0&&void 0!==arguments[0]&&arguments[0],d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Q=arguments.length>2?arguments[2]:void 0,n=arguments.length>3?arguments[3]:void 0,T=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=v,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let L=0;L<this._targetedAnimations.length;L++){const e=this._targetedAnimations[L],F=this._scene.beginDirectAnimation(e.target,[e.animation],void 0!==Q?Q:this._from,void 0!==n?n:this._to,v,d,void 0,void 0,void 0!==T?T:this._isAdditive);F.weight=this._weight,F.playOrder=this._playOrder,F.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(e),this._checkAnimationGroupEnded(F)},this._processLoop(F,e,L),this._animatables.push(F)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=d,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let v=0;v<this._animatables.length;v++){this._animatables[v].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(v){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==v&&(this.loopAnimation=v),this.restart()):(this.stop(),this.start(v,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let v=0;v<this._animatables.length;v++){this._animatables[v].reset()}return this}restart(){if(!this._isStarted)return this;for(let v=0;v<this._animatables.length;v++){this._animatables[v].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let v=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const d=this._animatables.slice();for(let n=0;n<d.length;n++)d[n].stop(void 0,void 0,!0,v);let Q=0;for(let n=0;n<this._scene._activeAnimatables.length;n++){const d=this._scene._activeAnimatables[n];d._runtimeAnimations.length>0?this._scene._activeAnimatables[Q++]=d:v&&this._checkAnimationGroupEnded(d,v)}return this._scene._activeAnimatables.length=Q,this._isStarted=!1,this}setWeightForAllAnimatables(v){for(let d=0;d<this._animatables.length;d++){this._animatables[d].weight=v}return this}syncAllAnimationsWith(v){for(let d=0;d<this._animatables.length;d++){this._animatables[d].syncWith(v)}return this}goToFrame(v){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let Q=0;Q<this._animatables.length;Q++){this._animatables[Q].goToFrame(v,d)}return this}getCurrentFrame(){var v;return(null===(v=this.animatables[0])||void 0===v?void 0:v.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const v=this._scene.animationGroups.indexOf(this);if(v>-1&&this._scene.animationGroups.splice(v,1),this._parentContainer){const v=this._parentContainer.animationGroups.indexOf(this);v>-1&&this._parentContainer.animationGroups.splice(v,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(v){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const Q=this._animatables.indexOf(v);Q>-1&&this._animatables.splice(Q,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,d||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(v,d){let Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=new S(v||this.name,this._scene,this._weight,this._playOrder);n._from=this.from,n._to=this.to,n._speedRatio=this.speedRatio,n._loopAnimation=this.loopAnimation,n._isAdditive=this.isAdditive,n._enableBlending=this.enableBlending,n._blendingSpeed=this.blendingSpeed,n.metadata=this.metadata,n.mask=this.mask;for(const T of this._targetedAnimations)n.addTargetedAnimation(Q?T.animation.clone():T.animation,d?d(T.target):T.target);return n}serialize(){const v={};v.name=this.name,v.from=this.from,v.to=this.to,v.speedRatio=this.speedRatio,v.loopAnimation=this.loopAnimation,v.isAdditive=this.isAdditive,v.weight=this.weight,v.playOrder=this.playOrder,v.enableBlending=this.enableBlending,v.blendingSpeed=this.blendingSpeed,v.targetedAnimations=[];for(let d=0;d<this.targetedAnimations.length;d++){const Q=this.targetedAnimations[d];v.targetedAnimations[d]=Q.serialize()}return e.b&&e.b.HasTags(this)&&(v.tags=e.b.GetTags(this)),this.metadata&&(v.metadata=this.metadata),v}static Parse(v,d){const Q=new S(v.name,d,v.weight,v.playOrder);for(let T=0;T<v.targetedAnimations.length;T++){const L=v.targetedAnimations[T],e=n.d.Parse(L.animation),F=L.targetId;if("influence"===L.animation.property){const v=d.getMorphTargetById(F);v&&Q.addTargetedAnimation(e,v)}else{const v=d.getNodeById(F);null!=v&&Q.addTargetedAnimation(e,v)}}return e.b&&e.b.AddTagsTo(Q,v.tags),null!==v.from&&null!==v.to&&Q.normalize(v.from,v.to),void 0!==v.speedRatio&&(Q._speedRatio=v.speedRatio),void 0!==v.loopAnimation&&(Q._loopAnimation=v.loopAnimation),void 0!==v.isAdditive&&(Q._isAdditive=v.isAdditive),void 0!==v.weight&&(Q._weight=v.weight),void 0!==v.playOrder&&(Q._playOrder=v.playOrder),void 0!==v.enableBlending&&(Q._enableBlending=v.enableBlending),void 0!==v.blendingSpeed&&(Q._blendingSpeed=v.blendingSpeed),void 0!==v.metadata&&(Q.metadata=v.metadata),Q}static MakeAnimationAdditive(v,d,Q){let T;T="object"===typeof d?d:{referenceFrame:d,range:Q,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let L=v;T.cloneOriginalAnimationGroup&&(L=v.clone(T.clonedAnimationGroupName||L.name));const e=L.targetedAnimations;for(let F=0;F<e.length;F++){const v=e[F];v.animation=n.d.MakeAnimationAdditive(v.animation,T)}if(L.isAdditive=!0,T.clipKeys){let v=Number.MAX_VALUE,d=-Number.MAX_VALUE;const Q=L.targetedAnimations;for(let n=0;n<Q.length;n++){const T=Q[n].animation.getKeys();v>T[0].frame&&(v=T[0].frame),d<T[T.length-1].frame&&(d=T[T.length-1].frame)}L._from=v,L._to=d}return L}static ClipKeys(v,d,Q,n,T){const L=v.clone(n||v.name);return S.ClipKeysInPlace(L,d,Q,T)}static ClipKeysInPlace(v,d,Q,n){return S.ClipInPlace(v,d,Q,n,!1)}static ClipFrames(v,d,Q,n,T){const L=v.clone(n||v.name);return S.ClipFramesInPlace(L,d,Q,T)}static ClipFramesInPlace(v,d,Q,n){return S.ClipInPlace(v,d,Q,n,!0)}static ClipInPlace(v,d,Q,n){let T=arguments.length>4&&void 0!==arguments[4]&&arguments[4],L=Number.MAX_VALUE,e=-Number.MAX_VALUE;const F=v.targetedAnimations;for(let r=0;r<F.length;r++){const v=F[r],C=n?v.animation:v.animation.clone();T&&(C.createKeyForFrame(d),C.createKeyForFrame(Q));const u=C.getKeys(),y=[];let z=Number.MAX_VALUE;for(let n=0;n<u.length;n++){const v=u[n];if(!T&&n>=d&&n<=Q||T&&v.frame>=d&&v.frame<=Q){const d={frame:v.frame,value:v.value.clone?v.value.clone():v.value,inTangent:v.inTangent,outTangent:v.outTangent,interpolation:v.interpolation,lockedTangent:v.lockedTangent};z===Number.MAX_VALUE&&(z=d.frame),d.frame-=z,y.push(d)}}0!==y.length?(L>y[0].frame&&(L=y[0].frame),e<y[y.length-1].frame&&(e=y[y.length-1].frame),C.setKeys(y,!0),v.animation=C):(F.splice(r,1),r--)}return v._from=L,v._to=e,v}getClassName(){return"AnimationGroup"}toString(v){let d="Name: "+this.name;return d+=", type: "+this.getClassName(),v&&(d+=", from: "+this._from,d+=", to: "+this._to,d+=", isStarted: "+this._isStarted,d+=", speedRatio: "+this._speedRatio,d+=", targetedAnimations length: "+this._targetedAnimations.length,d+=", animatables length: "+this._animatables),d}}}}]);