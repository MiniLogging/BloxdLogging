"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[62],{14406:(R,x,H)=>{H.r(x),H.d(x,{AnimationGroup:()=>b,TargetedAnimation:()=>L});var k=H(12331),c=H(476),t=H(513),A=H(622),D=H(13189),U=H(661);class J{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(R,x,H,c){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=x,this._target=R,this._scene=H,this._host=c,this._activeTargets=[],x._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===k.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=U.e.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const R={frame:0,value:this._minValue};this._keys.splice(0,0,R)}if(this._target instanceof Array){let R=0;for(const x of this._target)this._preparePath(x,R),this._getOriginalValues(R),R++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const t=x.getEvents();if(t&&t.length>0)for(const k of t)this._events.push(k._clone());this._enableBlending=R&&R.animationPropertiesOverride?R.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(R){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=this._animation.targetPropertyPath;if(H.length>1){let k=R;for(let R=0;R<H.length-1;R++){const x=H[R];if(k=k[x],void 0===k)throw new Error(`Invalid property (${x}) in property path (${H.join(".")})`)}this._targetPath=H[H.length-1],this._activeTargets[x]=k}else this._targetPath=H[0],this._activeTargets[x]=R;if(void 0===this._activeTargets[x][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${H.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let R=0;for(const x of this._target)void 0!==this._originalValue[R]&&this._setValue(x,this._activeTargets[R],this._originalValue[R],-1,R),R++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let R=0;R<this._events.length;R++)this._events[R].isDone=!1}isStopped(){return this._stopped}dispose(){const R=this._animation.runtimeAnimations.indexOf(this);R>-1&&this._animation.runtimeAnimations.splice(R,1)}setValue(R,x){if(this._targetIsArray)for(let H=0;H<this._target.length;H++){const k=this._target[H];this._setValue(k,this._activeTargets[H],R,x,H)}else this._setValue(this._target,this._directTarget,R,x,0)}_getOriginalValues(){let R,x=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const H=this._activeTargets[x];R=H.getLocalMatrix&&"_matrix"===this._targetPath?H.getLocalMatrix():H[this._targetPath],R&&R.clone?this._originalValue[x]=R.clone():this._originalValue[x]=R}_registerTargetForLateAnimationBinding(R,x){const H=R.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(H),H._lateAnimationHolders||(H._lateAnimationHolders={}),H._lateAnimationHolders[R.targetPath]||(H._lateAnimationHolders[R.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:x}),R.isAdditive?(H._lateAnimationHolders[R.targetPath].additiveAnimations.push(R),H._lateAnimationHolders[R.targetPath].totalAdditiveWeight+=R.weight):(H._lateAnimationHolders[R.targetPath].animations.push(R),H._lateAnimationHolders[R.targetPath].totalWeight+=R.weight)}_setValue(R,x,H,c,t){if(this._currentActiveTarget=x,this._weight=c,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const R=x[this._targetPath];R.clone?this._originalBlendValue=R.clone():this._originalBlendValue=R}this._originalBlendValue.m?k.c.AllowMatrixDecomposeForInterpolation?this._currentValue?U.e.DecomposeLerpToRef(this._originalBlendValue,H,this._blendingFactor,this._currentValue):this._currentValue=U.e.DecomposeLerp(this._originalBlendValue,H,this._blendingFactor):this._currentValue?U.e.LerpToRef(this._originalBlendValue,H,this._blendingFactor,this._currentValue):this._currentValue=U.e.Lerp(this._originalBlendValue,H,this._blendingFactor):this._currentValue=k.c._UniversalLerp(this._originalBlendValue,H,this._blendingFactor);const c=R&&R.animationPropertiesOverride?R.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=c}else this._currentValue?this._currentValue.p?this._currentValue.p(H):this._currentValue=H:null!==H&&void 0!==H&&H.clone?this._currentValue=H.clone():this._currentValue=H;-1!==c?this._registerTargetForLateAnimationBinding(this,this._originalValue[t]):this._animationState.loopMode===k.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[t],x[this._targetPath]):x[this._targetPath]=this._originalValue[t]+this._currentValue:x[this._targetPath]=this._currentValue,R._i&&R._i(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(R){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const H=this._animation.getKeys();R<H[0].frame?R=H[0].frame:R>H[H.length-1].frame&&(R=H[H.length-1].frame);const k=this._events;if(k.length)for(let t=0;t<k.length;t++)k[t].onlyOnce||(k[t].isDone=k[t].frame<R);this._currentFrame=R;const c=this._animation._interpolate(R,this._animationState);this.setValue(c,x)}_prepareForSpeedRatioChange(R){const x=this._previousElapsedTime*(this._animation.framePerSecond*R)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-x}animate(R,x,H,c,t){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const D=this._animation,U=D.targetPropertyPath;if(!U||U.length<1)return this._stopped=!0,!1;let J,V=!0;const n=this._events;let g=0;if(this._coreRuntimeAnimation)g=H-x,J=this._coreRuntimeAnimation.currentFrame,this._currentFrame=J,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let A;(x<this._minFrame||x>this._maxFrame)&&(x=this._minFrame),(H<this._minFrame||H>this._maxFrame)&&(H=this._maxFrame),g=H-x;let U=R*(D.framePerSecond*t)/1e3+this._absoluteFrameOffset,I=0,i=!1;const q=c&&this._animationState.loopMode===k.c.ANIMATIONLOOPMODE_YOYO;if(q){const R=(U-x)/g,H=Math.sin(R*Math.PI);U=Math.abs(H)*g+x;const k=H>=0?1:-1;this._yoyoDirection!==k&&(i=!0),this._yoyoDirection=k}if(this._previousElapsedTime=R,this._previousAbsoluteFrame=U,!c&&H>=x&&(U>=g&&t>0||U<=0&&t<0))V=!1,I=D._getKeyValue(this._maxValue);else if(!c&&x>=H&&(U<=g&&t<0||U>=0&&t>0))V=!1,I=D._getKeyValue(this._minValue);else if(this._animationState.loopMode!==k.c.ANIMATIONLOOPMODE_CYCLE){const R=H.toString()+x.toString();if(!this._offsetsCache[R]){this._animationState.repeatCount=0,this._animationState.loopMode=k.c.ANIMATIONLOOPMODE_CYCLE;const c=D._interpolate(x,this._animationState),t=D._interpolate(H,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),D.dataType){case k.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[R]=t-c;break;case k.c.ANIMATIONTYPE_QUATERNION:case k.c.ANIMATIONTYPE_VECTOR3:case k.c.ANIMATIONTYPE_VECTOR2:case k.c.ANIMATIONTYPE_SIZE:case k.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[R]=t.Pg(c)}this._highLimitsCache[R]=t}I=this._highLimitsCache[R],A=this._offsetsCache[R]}if(void 0===A)switch(D.dataType){case k.c.ANIMATIONTYPE_FLOAT:A=0;break;case k.c.ANIMATIONTYPE_QUATERNION:A=k.i;break;case k.c.ANIMATIONTYPE_VECTOR3:A=k.p;break;case k.c.ANIMATIONTYPE_VECTOR2:A=k.o;break;case k.c.ANIMATIONTYPE_SIZE:A=k.k;break;case k.c.ANIMATIONTYPE_COLOR3:A=k.e;break;case k.c.ANIMATIONTYPE_COLOR4:A=k.g}if(this._host&&this._host.syncRoot){const R=this._host.syncRoot;J=x+g*((R.masterFrame-R.fromFrame)/(R.toFrame-R.fromFrame))}else J=U>0&&x>H||U<0&&x<H?V&&0!==g?H+U%g:x:V&&0!==g?x+U%g:H;if(!q&&(t>0&&this.currentFrame>J||t<0&&this.currentFrame<J)||q&&i){this._onLoop();for(let R=0;R<n.length;R++)n[R].onlyOnce||(n[R].isDone=!1);this._animationState.key=t>0?0:D.getKeys().length-1}this._currentFrame=J,this._animationState.repeatCount=0===g?0:U/g|0,this._animationState.highLimitValue=I,this._animationState.offsetValue=A}const I=D._interpolate(J,this._animationState);if(this.setValue(I,A),n.length)for(let k=0;k<n.length;k++)if(g>=0&&J>=n[k].frame&&n[k].frame>=x||g<0&&J<=n[k].frame&&n[k].frame<=x){const R=n[k];R.isDone||(R.onlyOnce&&(n.splice(k,1),k--),R.isDone=!0,R.action(J))}return V||(this._stopped=!0),V}}var V=H(500);class n{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(R){this._weight=-1!==R?Math.min(Math.max(R,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(R){for(let x=0;x<this._runtimeAnimations.length;x++){this._runtimeAnimations[x]._prepareForSpeedRatioChange(R)}this._speedRatio=R,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(R,x){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,t=arguments.length>4&&void 0!==arguments[4]&&arguments[4],A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,D=arguments.length>6?arguments[6]:void 0,U=arguments.length>7?arguments[7]:void 0,J=arguments.length>8?arguments[8]:void 0,V=arguments.length>9&&void 0!==arguments[9]&&arguments[9],n=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=x,this.fromFrame=H,this.toFrame=k,this.loopAnimation=t,this.onAnimationEnd=D,this.onAnimationLoop=J,this.isAdditive=V,this.playOrder=n,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.$k=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new c.d,this.onAnimationLoopObservable=new c.d,this._scene=R,U&&this.appendAnimations(x,U),this._speedRatio=A,R._activeAnimatables.push(this)}syncWith(R){if(this._syncRoot=R,R){const R=this._scene._activeAnimatables.indexOf(this);R>-1&&(this._scene._activeAnimatables.splice(R,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(R,x){for(let H=0;H<x.length;H++){const k=x[H],c=new J(R,k,this._scene,this);c._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(c)}}getAnimationByTargetProperty(R){const x=this._runtimeAnimations;for(let H=0;H<x.length;H++)if(x[H].animation.targetProperty===R)return x[H].animation;return null}getRuntimeAnimationByTargetProperty(R){const x=this._runtimeAnimations;for(let H=0;H<x.length;H++)if(x[H].animation.targetProperty===R)return x[H];return null}reset(){const R=this._runtimeAnimations;for(let x=0;x<R.length;x++)R[x].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(R){const x=this._runtimeAnimations;for(let H=0;H<x.length;H++)x[H].animation.enableBlending=!0,x[H].animation.blendingSpeed=R}disableBlending(){const R=this._runtimeAnimations;for(let x=0;x<R.length;x++)R[x].animation.enableBlending=!1}goToFrame(R){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const H=this._runtimeAnimations;if(H[0]){const x=H[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??H[0].currentFrame;const k=0===this.speedRatio?0:(R-this._frameToSyncFromJump)/x*1e3/this.speedRatio;this._manualJumpDelay=-k}for(let k=0;k<H.length;k++)H[k].goToFrame(R,x?this._weight:-1);this._goToFrame=R}get paused(){return this.$k}pause(){this.$k||(this.$k=!0)}restart(){this.$k=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(R,x){let H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],k=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(R||x){const c=this._scene._activeAnimatables.indexOf(this);if(c>-1){const t=this._runtimeAnimations;for(let H=t.length-1;H>=0;H--){const k=t[H];R&&k.animation.name!=R||(x&&!x(k.target)||(k.dispose(),t.splice(H,1)))}0==t.length&&(H||this._scene._activeAnimatables.splice(c,1),k||this._raiseOnAnimationEnd())}}else{const R=this._scene._activeAnimatables.indexOf(this);if(R>-1){H||this._scene._activeAnimatables.splice(R,1);const x=this._runtimeAnimations;for(let R=0;R<x.length;R++)x[R].dispose();this._runtimeAnimations.length=0,k||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((R=>{this.onAnimationEndObservable.add((()=>{R(this)}),void 0,void 0,this,!0)}))}_animate(R){if(this.$k)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=R),!0;if(null===this._localDelayOffset?(this._localDelayOffset=R,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=R-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let x=!1;const H=this._runtimeAnimations;let k;for(k=0;k<H.length;k++){const c=H[k].animate(R-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);x=x||c}if(this.animationStarted=x,!x){if(this.disposeOnEnd)for(k=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(k,1),k=0;k<H.length;k++)H[k].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return x}}function g(R){if(0===R.totalWeight&&0===R.totalAdditiveWeight)return R.originalValue;let x=1;const H=U.g.Bi[0],k=U.g.Bi[1],c=U.g.Quaternion[0];let t=0;const A=R.animations[0],D=R.originalValue;let J=1,V=!1;if(R.totalWeight<1)J=1-R.totalWeight,D.decompose(k,c,H);else{if(t=1,x=R.totalWeight,J=A.weight/x,1==J){if(!R.totalAdditiveWeight)return A.currentValue;V=!0}A.currentValue.decompose(k,c,H)}if(!V){k.scaleInPlace(J),H.scaleInPlace(J),c.scaleInPlace(J);for(let A=t;A<R.animations.length;A++){const t=R.animations[A];if(0===t.weight)continue;J=t.weight/x;const D=U.g.Bi[2],V=U.g.Bi[3],n=U.g.Quaternion[1];t.currentValue.decompose(V,n,D),V.scaleAndAddToRef(J,k),n.scaleAndAddToRef(U.f.Dot(c,n)>0?J:-J,c),D.scaleAndAddToRef(J,H)}c.normalize()}for(let g=0;g<R.additiveAnimations.length;g++){const x=R.additiveAnimations[g];if(0===x.weight)continue;const t=U.g.Bi[2],A=U.g.Bi[3],D=U.g.Quaternion[1];x.currentValue.decompose(A,D,t),A.multiplyToRef(k,A),U.o.LerpToRef(k,A,x.weight,k),c.multiplyToRef(D,D),U.f.SlerpToRef(c,D,x.weight,c),t.scaleAndAddToRef(x.weight,H)}const n=A?A._animationState.workValue:U.g.Matrix[0].clone();return U.e.ComposeToRef(k,c,H,n),n}function I(R,x){if(0===R.totalWeight&&0===R.totalAdditiveWeight)return x;const H=R.animations[0],k=R.originalValue;let c=x;if(0===R.totalWeight&&R.totalAdditiveWeight>0)c.p(k);else if(1===R.animations.length){if(U.f.SlerpToRef(k,H.currentValue,Math.min(1,R.totalWeight),c),0===R.totalAdditiveWeight)return c}else if(R.animations.length>1){let H,t,A=1;if(R.totalWeight<1){const x=1-R.totalWeight;H=[],t=[],H.push(k),t.push(x)}else{if(2===R.animations.length&&(U.f.SlerpToRef(R.animations[0].currentValue,R.animations[1].currentValue,R.animations[1].weight/R.totalWeight,x),0===R.totalAdditiveWeight))return x;H=[],t=[],A=R.totalWeight}for(let x=0;x<R.animations.length;x++){const k=R.animations[x];H.push(k.currentValue),t.push(k.weight/A)}let D=0;for(let R=0;R<H.length;)R?(D+=t[R],U.f.SlerpToRef(c,H[R],t[R]/D,c),R++):(U.f.SlerpToRef(H[R],H[R+1],t[R+1]/(t[R]+t[R+1]),x),c=x,D=t[R]+t[R+1],R+=2)}for(let t=0;t<R.additiveAnimations.length;t++){const x=R.additiveAnimations[t];0!==x.weight&&(c.multiplyToRef(x.currentValue,U.g.Quaternion[0]),U.f.SlerpToRef(c,U.g.Quaternion[0],x.weight,c))}return c}var i,q,S=H(2445);i=S.e,(q=D.e)&&(q.prototype.copyAnimationRange=function(R,x,H){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3],t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new k.c(this.name,"_matrix",R.animations[0].framePerSecond,k.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const A=R.animations[0].getRange(x);if(!A)return!1;const D=A.from,U=A.to,J=R.animations[0].getKeys(),V=R.length,n=R.getParent(),g=this.getParent(),I=c&&n&&V&&this.length&&V!==this.length,i=I&&g&&n?g.length/n.length:1,q=c&&!g&&t&&(1!==t.x||1!==t.y||1!==t.z),S=this.animations[0].getKeys();let L,b,C;for(let k=0,F=J.length;k<F;k++)L=J[k],L.frame>=D&&L.frame<=U&&(c?(C=L.value.clone(),I?(b=C.getTranslation(),C.setTranslation(b.scaleInPlace(i))):q&&t?(b=C.getTranslation(),C.setTranslation(b.multiplyInPlace(t))):C=L.value):C=L.value,S.push({frame:L.frame+H,value:C}));return this.animations[0].createRange(x,D+H,U+H),!0}),i&&(i.prototype._animate=function(R){if(!this.animationsEnabled)return;const x=V.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=x}this.deltaTime=void 0!==R?R:this.useConstantAnimationDeltaTime?16:(x-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=x;const H=this._activeAnimatables;if(0===H.length)return;this._animationTime+=this.deltaTime;const c=this._animationTime;for(let k=0;k<H.length;k++){const R=H[k];!R._animate(c)&&R.disposeOnEnd&&k--}!function(R){if(R._registeredForLateAnimationBindings.length){for(let x=0;x<R._registeredForLateAnimationBindings.length;x++){const H=R._registeredForLateAnimationBindings.data[x];for(const R in H._lateAnimationHolders){const x=H._lateAnimationHolders[R],c=x.animations[0],t=x.originalValue;if(void 0===t||null===t)continue;const A=k.c.AllowMatrixDecomposeForInterpolation&&t.m;let D=H[R];if(A)D=g(x);else if(void 0!==t.w)D=I(x,D||U.f.Identity());else{let R=0,H=1;const A=c&&c._animationState.loopMode===k.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(x.totalWeight<1)D=A?t.clone?t.clone():t:c&&t.scale?t.scale(1-x.totalWeight):c?t*(1-x.totalWeight):t.clone?t.clone():t;else if(c){H=x.totalWeight;const k=c.weight/H;D=1!==k?c.currentValue.scale?c.currentValue.scale(k):c.currentValue*k:c.currentValue,A&&(D.addToRef?D.addToRef(t,D):D+=t),R=1}for(let k=R;k<x.animations.length;k++){const R=x.animations[k],c=R.weight/H;c&&(R.currentValue.scaleAndAddToRef?R.currentValue.scaleAndAddToRef(c,D):D+=R.currentValue*c)}for(let k=0;k<x.additiveAnimations.length;k++){const R=x.additiveAnimations[k],H=R.weight;H&&(R.currentValue.scaleAndAddToRef?R.currentValue.scaleAndAddToRef(H,D):D+=R.currentValue*H)}}H[R]=D}H._lateAnimationHolders={}}R._registeredForLateAnimationBindings.reset()}}(this)},i.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((R,x)=>R.playOrder-x.playOrder))},i.prototype.beginWeightedAnimation=function(R,x,H){let k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,c=arguments.length>4?arguments[4]:void 0,t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,D=arguments.length>7?arguments[7]:void 0,U=arguments.length>8?arguments[8]:void 0,J=arguments.length>9?arguments[9]:void 0,V=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const n=this.beginAnimation(R,x,H,c,t,A,D,!1,U,J,V);return n.weight=k,n},i.prototype.beginAnimation=function(R,x,H,k){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,t=arguments.length>5?arguments[5]:void 0,A=arguments.length>6?arguments[6]:void 0,D=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],U=arguments.length>8?arguments[8]:void 0,J=arguments.length>9?arguments[9]:void 0,V=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(c<0){const R=x;x=H,H=R,c=-c}x>H&&(c=-c),D&&this.stopAnimation(R,void 0,U),A||(A=new n(this,R,x,H,k,c,t,void 0,J,V));const g=!U||U(R);if(R.animations&&g&&A.appendAnimations(R,R.animations),R.getAnimatables){const V=R.getAnimatables();for(let R=0;R<V.length;R++)this.beginAnimation(V[R],x,H,k,c,t,A,D,U,J)}return A.reset(),A},i.prototype.beginHierarchyAnimation=function(R,x,H,k,c){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,A=arguments.length>6?arguments[6]:void 0,D=arguments.length>7?arguments[7]:void 0,U=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],J=arguments.length>9?arguments[9]:void 0,V=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const n=R.getDescendants(x),g=[];g.push(this.beginAnimation(R,H,k,c,t,A,D,U,J,void 0,V));for(const I of n)g.push(this.beginAnimation(I,H,k,c,t,A,D,U,J,void 0,V));return g},i.prototype.beginDirectAnimation=function(R,x,H,k,c){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(t<0){const R=H;H=k,k=R,t=-t}return H>k&&(t=-t),new n(this,R,H,k,c,t,arguments.length>6?arguments[6]:void 0,x,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},i.prototype.beginDirectHierarchyAnimation=function(R,x,H,k,c,t,A,D,U){let J=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const V=R.getDescendants(x),n=[];n.push(this.beginDirectAnimation(R,H,k,c,t,A,D,U,J));for(const g of V)n.push(this.beginDirectAnimation(g,H,k,c,t,A,D,U,J));return n},i.prototype.getAnimatableByTarget=function(R){for(let x=0;x<this._activeAnimatables.length;x++)if(this._activeAnimatables[x].target===R)return this._activeAnimatables[x];return null},i.prototype.getAllAnimatablesByTarget=function(R){const x=[];for(let H=0;H<this._activeAnimatables.length;H++)this._activeAnimatables[H].target===R&&x.push(this._activeAnimatables[H]);return x},i.prototype.stopAnimation=function(R,x,H){const k=this.getAllAnimatablesByTarget(R);for(const c of k)c.stop(x,H)},i.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let R=0;R<this._activeAnimatables.length;R++)this._activeAnimatables[R].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const R of this.animationGroups)R.stop()});class L{getClassName(){return"TargetedAnimation"}serialize(){const R={};return R.animation=this.animation.serialize(),R.targetId=this.target.id,R}}class b{get mask(){return this._mask}set mask(R){this._mask!==R&&(this._mask=R,this.syncWithMask(!0))}syncWithMask(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||R){this._numActiveAnimatables=0;for(let R=0;R<this._animatables.length;++R){const x=this._animatables[R];!this.mask||this.mask.disabled||this.mask.retainsTarget(x.target.name)?(this._numActiveAnimatables++,x.paused&&x.restart()):x.paused||x.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let R=0;R<this._animatables.length;++R){const x=this._animatables[R];this.mask.retainsTarget(x.target.name)||(x.stop(),this._animatables.splice(R,1),--R)}for(let R=0;R<this._targetedAnimations.length;R++){const x=this._targetedAnimations[R];this.mask.retainsTarget(x.target.name)||(this._targetedAnimations.splice(R,1),--R)}}}get from(){return this._from}set from(R){if(this._from!==R){this._from=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].fromFrame=this._from}}}get to(){return this._to}set to(R){if(this._to!==R){this._to=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(R){if(this._speedRatio!==R){this._speedRatio=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(R){if(this._loopAnimation!==R){this._loopAnimation=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(R){if(this._isAdditive!==R){this._isAdditive=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(R){this._weight!==R&&(this._weight=R,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(R){if(this._playOrder!==R&&(this._playOrder=R,this._animatables.length>0)){for(let R=0;R<this._animatables.length;R++)this._animatables[R].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(R){if(this._enableBlending!==R&&(this._enableBlending=R,null!==R))for(let x=0;x<this._targetedAnimations.length;++x)this._targetedAnimations[x].animation.enableBlending=R}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(R){if(this._blendingSpeed!==R&&(this._blendingSpeed=R,null!==R))for(let x=0;x<this._targetedAnimations.length;++x)this._targetedAnimations[x].animation.blendingSpeed=R}getLength(R,x){R=R??this._from;return((x=x??this._to)-R)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(R){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],k=arguments.length>3?arguments[3]:void 0;if(0===R.length)return null;k=k??R[0].weight;let c=Number.MAX_VALUE,t=-Number.MAX_VALUE;if(H)for(const D of R)D.from<c&&(c=D.from),D.to>t&&(t=D.to);const A=new b(R[0].name+"_merged",R[0]._scene,k);for(const D of R){H&&D.normalize(c,t);for(const R of D.targetedAnimations)A.addTargetedAnimation(R.animation,R.target);x&&D.dispose()}return A}constructor(R){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=R,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new c.d,this.onAnimationLoopObservable=new c.d,this.onAnimationGroupLoopObservable=new c.d,this.onAnimationGroupEndObservable=new c.d,this.onAnimationGroupPauseObservable=new c.d,this.onAnimationGroupPlayObservable=new c.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=x||t.c.LastCreatedScene,this._weight=H,this._playOrder=k,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(R,x){const H=new L;H.animation=R,H.target=x;const k=R.getKeys();return this._from>k[0].frame&&(this._from=k[0].frame),this._to<k[k.length-1].frame&&(this._to=k[k.length-1].frame),null!==this._enableBlending&&(R.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(R.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(H),this._shouldStart=!0,H}removeTargetedAnimation(R){for(let x=this._targetedAnimations.length-1;x>-1;x--){this._targetedAnimations[x].animation===R&&this._targetedAnimations.splice(x,1)}}normalize(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==R&&(R=this._from),null==x&&(x=this._to);for(let H=0;H<this._targetedAnimations.length;H++){const k=this._targetedAnimations[H].animation.getKeys(),c=k[0],t=k[k.length-1];if(c.frame>R){const x={frame:R,value:c.value,inTangent:c.inTangent,outTangent:c.outTangent,interpolation:c.interpolation};k.splice(0,0,x)}if(t.frame<x){const R={frame:x,value:t.value,inTangent:t.inTangent,outTangent:t.outTangent,interpolation:t.interpolation};k.push(R)}}return this._from=R,this._to=x,this}_processLoop(R,x,H){R.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(x),this._animationLoopFlags[H]||(this._animationLoopFlags[H]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0],x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0,k=arguments.length>3?arguments[3]:void 0,c=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=R,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let t=0;t<this._targetedAnimations.length;t++){const A=this._targetedAnimations[t],D=this._scene.beginDirectAnimation(A.target,[A.animation],void 0!==H?H:this._from,void 0!==k?k:this._to,R,x,void 0,void 0,void 0!==c?c:this._isAdditive);D.weight=this._weight,D.playOrder=this._playOrder,D.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(A),this._checkAnimationGroupEnded(D)},this._processLoop(D,A,t),this._animatables.push(D)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=x,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let R=0;R<this._animatables.length;R++){this._animatables[R].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(R){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==R&&(this.loopAnimation=R),this.restart()):(this.stop(),this.start(R,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let R=0;R<this._animatables.length;R++){this._animatables[R].reset()}return this}restart(){if(!this._isStarted)return this;for(let R=0;R<this._animatables.length;R++){this._animatables[R].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const x=this._animatables.slice();for(let k=0;k<x.length;k++)x[k].stop(void 0,void 0,!0,R);let H=0;for(let k=0;k<this._scene._activeAnimatables.length;k++){const x=this._scene._activeAnimatables[k];x._runtimeAnimations.length>0?this._scene._activeAnimatables[H++]=x:R&&this._checkAnimationGroupEnded(x,R)}return this._scene._activeAnimatables.length=H,this._isStarted=!1,this}setWeightForAllAnimatables(R){for(let x=0;x<this._animatables.length;x++){this._animatables[x].weight=R}return this}syncAllAnimationsWith(R){for(let x=0;x<this._animatables.length;x++){this._animatables[x].syncWith(R)}return this}goToFrame(R){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].goToFrame(R,x)}return this}getCurrentFrame(){var R;return(null===(R=this.animatables[0])||void 0===R?void 0:R.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const R=this._scene.animationGroups.indexOf(this);if(R>-1&&this._scene.animationGroups.splice(R,1),this._parentContainer){const R=this._parentContainer.animationGroups.indexOf(this);R>-1&&this._parentContainer.animationGroups.splice(R,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(R){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const H=this._animatables.indexOf(R);H>-1&&this._animatables.splice(H,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,x||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(R,x){let H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const k=new b(R||this.name,this._scene,this._weight,this._playOrder);k._from=this.from,k._to=this.to,k._speedRatio=this.speedRatio,k._loopAnimation=this.loopAnimation,k._isAdditive=this.isAdditive,k._enableBlending=this.enableBlending,k._blendingSpeed=this.blendingSpeed,k.metadata=this.metadata,k.mask=this.mask;for(const c of this._targetedAnimations)k.addTargetedAnimation(H?c.animation.clone():c.animation,x?x(c.target):c.target);return k}serialize(){const R={};R.name=this.name,R.from=this.from,R.to=this.to,R.speedRatio=this.speedRatio,R.loopAnimation=this.loopAnimation,R.isAdditive=this.isAdditive,R.weight=this.weight,R.playOrder=this.playOrder,R.enableBlending=this.enableBlending,R.blendingSpeed=this.blendingSpeed,R.targetedAnimations=[];for(let x=0;x<this.targetedAnimations.length;x++){const H=this.targetedAnimations[x];R.targetedAnimations[x]=H.serialize()}return A.c&&A.c.HasTags(this)&&(R.tags=A.c.GetTags(this)),this.metadata&&(R.metadata=this.metadata),R}static Parse(R,x){const H=new b(R.name,x,R.weight,R.playOrder);for(let c=0;c<R.targetedAnimations.length;c++){const t=R.targetedAnimations[c],A=k.c.Parse(t.animation),D=t.targetId;if("influence"===t.animation.property){const R=x.getMorphTargetById(D);R&&H.addTargetedAnimation(A,R)}else{const R=x.getNodeById(D);null!=R&&H.addTargetedAnimation(A,R)}}return A.c&&A.c.AddTagsTo(H,R.tags),null!==R.from&&null!==R.to&&H.normalize(R.from,R.to),void 0!==R.speedRatio&&(H._speedRatio=R.speedRatio),void 0!==R.loopAnimation&&(H._loopAnimation=R.loopAnimation),void 0!==R.isAdditive&&(H._isAdditive=R.isAdditive),void 0!==R.weight&&(H._weight=R.weight),void 0!==R.playOrder&&(H._playOrder=R.playOrder),void 0!==R.enableBlending&&(H._enableBlending=R.enableBlending),void 0!==R.blendingSpeed&&(H._blendingSpeed=R.blendingSpeed),void 0!==R.metadata&&(H.metadata=R.metadata),H}static MakeAnimationAdditive(R,x,H){let c;c="object"===typeof x?x:{referenceFrame:x,range:H,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let t=R;c.cloneOriginalAnimationGroup&&(t=R.clone(c.clonedAnimationGroupName||t.name));const A=t.targetedAnimations;for(let D=0;D<A.length;D++){const R=A[D];R.animation=k.c.MakeAnimationAdditive(R.animation,c)}if(t.isAdditive=!0,c.clipKeys){let R=Number.MAX_VALUE,x=-Number.MAX_VALUE;const H=t.targetedAnimations;for(let k=0;k<H.length;k++){const c=H[k].animation.getKeys();R>c[0].frame&&(R=c[0].frame),x<c[c.length-1].frame&&(x=c[c.length-1].frame)}t._from=R,t._to=x}return t}static ClipKeys(R,x,H,k,c){const t=R.clone(k||R.name);return b.ClipKeysInPlace(t,x,H,c)}static ClipKeysInPlace(R,x,H,k){return b.ClipInPlace(R,x,H,k,!1)}static ClipFrames(R,x,H,k,c){const t=R.clone(k||R.name);return b.ClipFramesInPlace(t,x,H,c)}static ClipFramesInPlace(R,x,H,k){return b.ClipInPlace(R,x,H,k,!0)}static ClipInPlace(R,x,H,k){let c=arguments.length>4&&void 0!==arguments[4]&&arguments[4],t=Number.MAX_VALUE,A=-Number.MAX_VALUE;const D=R.targetedAnimations;for(let U=0;U<D.length;U++){const R=D[U],J=k?R.animation:R.animation.clone();c&&(J.createKeyForFrame(x),J.createKeyForFrame(H));const V=J.getKeys(),n=[];let g=Number.MAX_VALUE;for(let k=0;k<V.length;k++){const R=V[k];if(!c&&k>=x&&k<=H||c&&R.frame>=x&&R.frame<=H){const x={frame:R.frame,value:R.value.clone?R.value.clone():R.value,inTangent:R.inTangent,outTangent:R.outTangent,interpolation:R.interpolation,lockedTangent:R.lockedTangent};g===Number.MAX_VALUE&&(g=x.frame),x.frame-=g,n.push(x)}}0!==n.length?(t>n[0].frame&&(t=n[0].frame),A<n[n.length-1].frame&&(A=n[n.length-1].frame),J.setKeys(n,!0),R.animation=J):(D.splice(U,1),U--)}return R._from=t,R._to=A,R}getClassName(){return"AnimationGroup"}toString(R){let x="Name: "+this.name;return x+=", type: "+this.getClassName(),R&&(x+=", from: "+this._from,x+=", to: "+this._to,x+=", isStarted: "+this._isStarted,x+=", speedRatio: "+this._speedRatio,x+=", targetedAnimations length: "+this._targetedAnimations.length,x+=", animatables length: "+this._animatables),x}}}}]);