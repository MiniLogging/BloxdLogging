"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[62],{14100:(t,q,S)=>{S.r(q),S.d(q,{AnimationGroup:()=>v,TargetedAnimation:()=>a});var o=S(12019),B=S(485),z=S(523),L=S(634),r=S(12869),e=S(678);class C{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(t,q,S,B){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=q,this._target=t,this._scene=S,this._host=B,this._activeTargets=[],q._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===o.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=e.e.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const t={frame:0,value:this._minValue};this._keys.splice(0,0,t)}if(this._target instanceof Array){let t=0;for(const q of this._target)this._preparePath(q,t),this._getOriginalValues(t),t++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const z=q.getEvents();if(z&&z.length>0)for(const o of z)this._events.push(o._clone());this._enableBlending=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(t){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const S=this._animation.targetPropertyPath;if(S.length>1){let o=t;for(let t=0;t<S.length-1;t++){const q=S[t];if(o=o[q],void 0===o)throw new Error(`Invalid property (${q}) in property path (${S.join(".")})`)}this._targetPath=S[S.length-1],this._activeTargets[q]=o}else this._targetPath=S[0],this._activeTargets[q]=t;if(void 0===this._activeTargets[q][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${S.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let t=0;for(const q of this._target)void 0!==this._originalValue[t]&&this._setValue(q,this._activeTargets[t],this._originalValue[t],-1,t),t++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let t=0;t<this._events.length;t++)this._events[t].isDone=!1}isStopped(){return this._stopped}dispose(){const t=this._animation.runtimeAnimations.indexOf(this);t>-1&&this._animation.runtimeAnimations.splice(t,1)}setValue(t,q){if(this._targetIsArray)for(let S=0;S<this._target.length;S++){const o=this._target[S];this._setValue(o,this._activeTargets[S],t,q,S)}else this._setValue(this._target,this._directTarget,t,q,0)}_getOriginalValues(){let t,q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const S=this._activeTargets[q];t=S.getLocalMatrix&&"_matrix"===this._targetPath?S.getLocalMatrix():S[this._targetPath],t&&t.clone?this._originalValue[q]=t.clone():this._originalValue[q]=t}_registerTargetForLateAnimationBinding(t,q){const S=t.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(S),S._lateAnimationHolders||(S._lateAnimationHolders={}),S._lateAnimationHolders[t.targetPath]||(S._lateAnimationHolders[t.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:q}),t.isAdditive?(S._lateAnimationHolders[t.targetPath].additiveAnimations.push(t),S._lateAnimationHolders[t.targetPath].totalAdditiveWeight+=t.weight):(S._lateAnimationHolders[t.targetPath].animations.push(t),S._lateAnimationHolders[t.targetPath].totalWeight+=t.weight)}_setValue(t,q,S,B,z){if(this._currentActiveTarget=q,this._weight=B,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const t=q[this._targetPath];t.clone?this._originalBlendValue=t.clone():this._originalBlendValue=t}this._originalBlendValue.m?o.b.AllowMatrixDecomposeForInterpolation?this._currentValue?e.e.DecomposeLerpToRef(this._originalBlendValue,S,this._blendingFactor,this._currentValue):this._currentValue=e.e.DecomposeLerp(this._originalBlendValue,S,this._blendingFactor):this._currentValue?e.e.LerpToRef(this._originalBlendValue,S,this._blendingFactor,this._currentValue):this._currentValue=e.e.Lerp(this._originalBlendValue,S,this._blendingFactor):this._currentValue=o.b._UniversalLerp(this._originalBlendValue,S,this._blendingFactor);const B=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=B}else this._currentValue?this._currentValue.p?this._currentValue.p(S):this._currentValue=S:null!==S&&void 0!==S&&S.clone?this._currentValue=S.clone():this._currentValue=S;-1!==B?this._registerTargetForLateAnimationBinding(this,this._originalValue[z]):this._animationState.loopMode===o.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[z],q[this._targetPath]):q[this._targetPath]=this._originalValue[z]+this._currentValue:q[this._targetPath]=this._currentValue,t.Vi&&t.Vi(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(t){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const S=this._animation.getKeys();t<S[0].frame?t=S[0].frame:t>S[S.length-1].frame&&(t=S[S.length-1].frame);const o=this._events;if(o.length)for(let z=0;z<o.length;z++)o[z].onlyOnce||(o[z].isDone=o[z].frame<t);this._currentFrame=t;const B=this._animation._interpolate(t,this._animationState);this.setValue(B,q)}_prepareForSpeedRatioChange(t){const q=this._previousElapsedTime*(this._animation.framePerSecond*t)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-q}animate(t,q,S,B,z){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const r=this._animation,e=r.targetPropertyPath;if(!e||e.length<1)return this._stopped=!0,!1;let C,Z=!0;const b=this._events;let O=0;if(this._coreRuntimeAnimation)O=S-q,C=this._coreRuntimeAnimation.currentFrame,this._currentFrame=C,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let L;(q<this._minFrame||q>this._maxFrame)&&(q=this._minFrame),(S<this._minFrame||S>this._maxFrame)&&(S=this._maxFrame),O=S-q;let e=t*(r.framePerSecond*z)/1e3+this._absoluteFrameOffset,i=0,h=!1;const l=B&&this._animationState.loopMode===o.b.ANIMATIONLOOPMODE_YOYO;if(l){const t=(e-q)/O,S=Math.sin(t*Math.PI);e=Math.abs(S)*O+q;const o=S>=0?1:-1;this._yoyoDirection!==o&&(h=!0),this._yoyoDirection=o}if(this._previousElapsedTime=t,this._previousAbsoluteFrame=e,!B&&S>=q&&(e>=O&&z>0||e<=0&&z<0))Z=!1,i=r._getKeyValue(this._maxValue);else if(!B&&q>=S&&(e<=O&&z<0||e>=0&&z>0))Z=!1,i=r._getKeyValue(this._minValue);else if(this._animationState.loopMode!==o.b.ANIMATIONLOOPMODE_CYCLE){const t=S.toString()+q.toString();if(!this._offsetsCache[t]){this._animationState.repeatCount=0,this._animationState.loopMode=o.b.ANIMATIONLOOPMODE_CYCLE;const B=r._interpolate(q,this._animationState),z=r._interpolate(S,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),r.dataType){case o.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[t]=z-B;break;case o.b.ANIMATIONTYPE_QUATERNION:case o.b.ANIMATIONTYPE_VECTOR3:case o.b.ANIMATIONTYPE_VECTOR2:case o.b.ANIMATIONTYPE_SIZE:case o.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[t]=z.Kg(B)}this._highLimitsCache[t]=z}i=this._highLimitsCache[t],L=this._offsetsCache[t]}if(void 0===L)switch(r.dataType){case o.b.ANIMATIONTYPE_FLOAT:L=0;break;case o.b.ANIMATIONTYPE_QUATERNION:L=o.i;break;case o.b.ANIMATIONTYPE_VECTOR3:L=o.m;break;case o.b.ANIMATIONTYPE_VECTOR2:L=o.l;break;case o.b.ANIMATIONTYPE_SIZE:L=o.k;break;case o.b.ANIMATIONTYPE_COLOR3:L=o.d;break;case o.b.ANIMATIONTYPE_COLOR4:L=o.g}if(this._host&&this._host.syncRoot){const t=this._host.syncRoot;C=q+O*((t.masterFrame-t.fromFrame)/(t.toFrame-t.fromFrame))}else C=e>0&&q>S||e<0&&q<S?Z&&0!==O?S+e%O:q:Z&&0!==O?q+e%O:S;if(!l&&(z>0&&this.currentFrame>C||z<0&&this.currentFrame<C)||l&&h){this._onLoop();for(let t=0;t<b.length;t++)b[t].onlyOnce||(b[t].isDone=!1);this._animationState.key=z>0?0:r.getKeys().length-1}this._currentFrame=C,this._animationState.repeatCount=0===O?0:e/O|0,this._animationState.highLimitValue=i,this._animationState.offsetValue=L}const i=r._interpolate(C,this._animationState);if(this.setValue(i,L),b.length)for(let o=0;o<b.length;o++)if(O>=0&&C>=b[o].frame&&b[o].frame>=q||O<0&&C<=b[o].frame&&b[o].frame<=q){const t=b[o];t.isDone||(t.onlyOnce&&(b.splice(o,1),o--),t.isDone=!0,t.action(C))}return Z||(this._stopped=!0),Z}}var Z=S(510);class b{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(t){this._weight=-1!==t?Math.min(Math.max(t,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(t){for(let q=0;q<this._runtimeAnimations.length;q++){this._runtimeAnimations[q]._prepareForSpeedRatioChange(t)}this._speedRatio=t,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(t,q){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,z=arguments.length>4&&void 0!==arguments[4]&&arguments[4],L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,r=arguments.length>6?arguments[6]:void 0,e=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,Z=arguments.length>9&&void 0!==arguments[9]&&arguments[9],b=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=q,this.fromFrame=S,this.toFrame=o,this.loopAnimation=z,this.onAnimationEnd=r,this.onAnimationLoop=C,this.isAdditive=Z,this.playOrder=b,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Vk=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new B.b,this.onAnimationLoopObservable=new B.b,this._scene=t,e&&this.appendAnimations(q,e),this._speedRatio=L,t._activeAnimatables.push(this)}syncWith(t){if(this._syncRoot=t,t){const t=this._scene._activeAnimatables.indexOf(this);t>-1&&(this._scene._activeAnimatables.splice(t,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(t,q){for(let S=0;S<q.length;S++){const o=q[S],B=new C(t,o,this._scene,this);B._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(B)}}getAnimationByTargetProperty(t){const q=this._runtimeAnimations;for(let S=0;S<q.length;S++)if(q[S].animation.targetProperty===t)return q[S].animation;return null}getRuntimeAnimationByTargetProperty(t){const q=this._runtimeAnimations;for(let S=0;S<q.length;S++)if(q[S].animation.targetProperty===t)return q[S];return null}reset(){const t=this._runtimeAnimations;for(let q=0;q<t.length;q++)t[q].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(t){const q=this._runtimeAnimations;for(let S=0;S<q.length;S++)q[S].animation.enableBlending=!0,q[S].animation.blendingSpeed=t}disableBlending(){const t=this._runtimeAnimations;for(let q=0;q<t.length;q++)t[q].animation.enableBlending=!1}goToFrame(t){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const S=this._runtimeAnimations;if(S[0]){const q=S[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??S[0].currentFrame;const o=0===this.speedRatio?0:(t-this._frameToSyncFromJump)/q*1e3/this.speedRatio;this._manualJumpDelay=-o}for(let o=0;o<S.length;o++)S[o].goToFrame(t,q?this._weight:-1);this._goToFrame=t}get paused(){return this.Vk}pause(){this.Vk||(this.Vk=!0)}restart(){this.Vk=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(t,q){let S=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t||q){const B=this._scene._activeAnimatables.indexOf(this);if(B>-1){const z=this._runtimeAnimations;for(let S=z.length-1;S>=0;S--){const o=z[S];t&&o.animation.name!=t||(q&&!q(o.target)||(o.dispose(),z.splice(S,1)))}0==z.length&&(S||this._scene._activeAnimatables.splice(B,1),o||this._raiseOnAnimationEnd())}}else{const t=this._scene._activeAnimatables.indexOf(this);if(t>-1){S||this._scene._activeAnimatables.splice(t,1);const q=this._runtimeAnimations;for(let t=0;t<q.length;t++)q[t].dispose();this._runtimeAnimations.length=0,o||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise((t=>{this.onAnimationEndObservable.add((()=>{t(this)}),void 0,void 0,this,!0)}))}_animate(t){if(this.Vk)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=t),!0;if(null===this._localDelayOffset?(this._localDelayOffset=t,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=t-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let q=!1;const S=this._runtimeAnimations;let o;for(o=0;o<S.length;o++){const B=S[o].animate(t-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);q=q||B}if(this.animationStarted=q,!q){if(this.disposeOnEnd)for(o=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(o,1),o=0;o<S.length;o++)S[o].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return q}}function O(t){if(0===t.totalWeight&&0===t.totalAdditiveWeight)return t.originalValue;let q=1;const S=e.j.wi[0],o=e.j.wi[1],B=e.j.Quaternion[0];let z=0;const L=t.animations[0],r=t.originalValue;let C=1,Z=!1;if(t.totalWeight<1)C=1-t.totalWeight,r.decompose(o,B,S);else{if(z=1,q=t.totalWeight,C=L.weight/q,1==C){if(!t.totalAdditiveWeight)return L.currentValue;Z=!0}L.currentValue.decompose(o,B,S)}if(!Z){o.scaleInPlace(C),S.scaleInPlace(C),B.scaleInPlace(C);for(let L=z;L<t.animations.length;L++){const z=t.animations[L];if(0===z.weight)continue;C=z.weight/q;const r=e.j.wi[2],Z=e.j.wi[3],b=e.j.Quaternion[1];z.currentValue.decompose(Z,b,r),Z.scaleAndAddToRef(C,o),b.scaleAndAddToRef(e.g.Dot(B,b)>0?C:-C,B),r.scaleAndAddToRef(C,S)}B.normalize()}for(let O=0;O<t.additiveAnimations.length;O++){const q=t.additiveAnimations[O];if(0===q.weight)continue;const z=e.j.wi[2],L=e.j.wi[3],r=e.j.Quaternion[1];q.currentValue.decompose(L,r,z),L.multiplyToRef(o,L),e.o.LerpToRef(o,L,q.weight,o),B.multiplyToRef(r,r),e.g.SlerpToRef(B,r,q.weight,B),z.scaleAndAddToRef(q.weight,S)}const b=L?L._animationState.workValue:e.j.Matrix[0].clone();return e.e.ComposeToRef(o,B,S,b),b}function i(t,q){if(0===t.totalWeight&&0===t.totalAdditiveWeight)return q;const S=t.animations[0],o=t.originalValue;let B=q;if(0===t.totalWeight&&t.totalAdditiveWeight>0)B.p(o);else if(1===t.animations.length){if(e.g.SlerpToRef(o,S.currentValue,Math.min(1,t.totalWeight),B),0===t.totalAdditiveWeight)return B}else if(t.animations.length>1){let S,z,L=1;if(t.totalWeight<1){const q=1-t.totalWeight;S=[],z=[],S.push(o),z.push(q)}else{if(2===t.animations.length&&(e.g.SlerpToRef(t.animations[0].currentValue,t.animations[1].currentValue,t.animations[1].weight/t.totalWeight,q),0===t.totalAdditiveWeight))return q;S=[],z=[],L=t.totalWeight}for(let q=0;q<t.animations.length;q++){const o=t.animations[q];S.push(o.currentValue),z.push(o.weight/L)}let r=0;for(let t=0;t<S.length;)t?(r+=z[t],e.g.SlerpToRef(B,S[t],z[t]/r,B),t++):(e.g.SlerpToRef(S[t],S[t+1],z[t+1]/(z[t]+z[t+1]),q),B=q,r=z[t]+z[t+1],t+=2)}for(let z=0;z<t.additiveAnimations.length;z++){const q=t.additiveAnimations[z];0!==q.weight&&(B.multiplyToRef(q.currentValue,e.j.Quaternion[0]),e.g.SlerpToRef(B,e.j.Quaternion[0],q.weight,B))}return B}var h,l,I=S(2428);h=I.d,(l=r.c)&&(l.prototype.copyAnimationRange=function(t,q,S){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3],z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new o.b(this.name,"_matrix",t.animations[0].framePerSecond,o.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const L=t.animations[0].getRange(q);if(!L)return!1;const r=L.from,e=L.to,C=t.animations[0].getKeys(),Z=t.length,b=t.getParent(),O=this.getParent(),i=B&&b&&Z&&this.length&&Z!==this.length,h=i&&O&&b?O.length/b.length:1,l=B&&!O&&z&&(1!==z.x||1!==z.y||1!==z.z),I=this.animations[0].getKeys();let a,v,M;for(let o=0,x=C.length;o<x;o++)a=C[o],a.frame>=r&&a.frame<=e&&(B?(M=a.value.clone(),i?(v=M.getTranslation(),M.setTranslation(v.scaleInPlace(h))):l&&z?(v=M.getTranslation(),M.setTranslation(v.multiplyInPlace(z))):M=a.value):M=a.value,I.push({frame:a.frame+S,value:M}));return this.animations[0].createRange(q,r+S,e+S),!0}),h&&(h.prototype._animate=function(t){if(!this.animationsEnabled)return;const q=Z.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=q}this.deltaTime=void 0!==t?t:this.useConstantAnimationDeltaTime?16:(q-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=q;const S=this._activeAnimatables;if(0===S.length)return;this._animationTime+=this.deltaTime;const B=this._animationTime;for(let o=0;o<S.length;o++){const t=S[o];!t._animate(B)&&t.disposeOnEnd&&o--}!function(t){if(t._registeredForLateAnimationBindings.length){for(let q=0;q<t._registeredForLateAnimationBindings.length;q++){const S=t._registeredForLateAnimationBindings.data[q];for(const t in S._lateAnimationHolders){const q=S._lateAnimationHolders[t],B=q.animations[0],z=q.originalValue;if(void 0===z||null===z)continue;const L=o.b.AllowMatrixDecomposeForInterpolation&&z.m;let r=S[t];if(L)r=O(q);else if(void 0!==z.w)r=i(q,r||e.g.Identity());else{let t=0,S=1;const L=B&&B._animationState.loopMode===o.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(q.totalWeight<1)r=L?z.clone?z.clone():z:B&&z.scale?z.scale(1-q.totalWeight):B?z*(1-q.totalWeight):z.clone?z.clone():z;else if(B){S=q.totalWeight;const o=B.weight/S;r=1!==o?B.currentValue.scale?B.currentValue.scale(o):B.currentValue*o:B.currentValue,L&&(r.addToRef?r.addToRef(z,r):r+=z),t=1}for(let o=t;o<q.animations.length;o++){const t=q.animations[o],B=t.weight/S;B&&(t.currentValue.scaleAndAddToRef?t.currentValue.scaleAndAddToRef(B,r):r+=t.currentValue*B)}for(let o=0;o<q.additiveAnimations.length;o++){const t=q.additiveAnimations[o],S=t.weight;S&&(t.currentValue.scaleAndAddToRef?t.currentValue.scaleAndAddToRef(S,r):r+=t.currentValue*S)}}S[t]=r}S._lateAnimationHolders={}}t._registeredForLateAnimationBindings.reset()}}(this)},h.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((t,q)=>t.playOrder-q.playOrder))},h.prototype.beginWeightedAnimation=function(t,q,S){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,B=arguments.length>4?arguments[4]:void 0,z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,L=arguments.length>6?arguments[6]:void 0,r=arguments.length>7?arguments[7]:void 0,e=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,Z=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const b=this.beginAnimation(t,q,S,B,z,L,r,!1,e,C,Z);return b.weight=o,b},h.prototype.beginAnimation=function(t,q,S,o){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,z=arguments.length>5?arguments[5]:void 0,L=arguments.length>6?arguments[6]:void 0,r=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],e=arguments.length>8?arguments[8]:void 0,C=arguments.length>9?arguments[9]:void 0,Z=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(B<0){const t=q;q=S,S=t,B=-B}q>S&&(B=-B),r&&this.stopAnimation(t,void 0,e),L||(L=new b(this,t,q,S,o,B,z,void 0,C,Z));const O=!e||e(t);if(t.animations&&O&&L.appendAnimations(t,t.animations),t.getAnimatables){const Z=t.getAnimatables();for(let t=0;t<Z.length;t++)this.beginAnimation(Z[t],q,S,o,B,z,L,r,e,C)}return L.reset(),L},h.prototype.beginHierarchyAnimation=function(t,q,S,o,B){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,L=arguments.length>6?arguments[6]:void 0,r=arguments.length>7?arguments[7]:void 0,e=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],C=arguments.length>9?arguments[9]:void 0,Z=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const b=t.getDescendants(q),O=[];O.push(this.beginAnimation(t,S,o,B,z,L,r,e,C,void 0,Z));for(const i of b)O.push(this.beginAnimation(i,S,o,B,z,L,r,e,C,void 0,Z));return O},h.prototype.beginDirectAnimation=function(t,q,S,o,B){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(z<0){const t=S;S=o,o=t,z=-z}return S>o&&(z=-z),new b(this,t,S,o,B,z,arguments.length>6?arguments[6]:void 0,q,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},h.prototype.beginDirectHierarchyAnimation=function(t,q,S,o,B,z,L,r,e){let C=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const Z=t.getDescendants(q),b=[];b.push(this.beginDirectAnimation(t,S,o,B,z,L,r,e,C));for(const O of Z)b.push(this.beginDirectAnimation(O,S,o,B,z,L,r,e,C));return b},h.prototype.getAnimatableByTarget=function(t){for(let q=0;q<this._activeAnimatables.length;q++)if(this._activeAnimatables[q].target===t)return this._activeAnimatables[q];return null},h.prototype.getAllAnimatablesByTarget=function(t){const q=[];for(let S=0;S<this._activeAnimatables.length;S++)this._activeAnimatables[S].target===t&&q.push(this._activeAnimatables[S]);return q},h.prototype.stopAnimation=function(t,q,S){const o=this.getAllAnimatablesByTarget(t);for(const B of o)B.stop(q,S)},h.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let t=0;t<this._activeAnimatables.length;t++)this._activeAnimatables[t].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const t of this.animationGroups)t.stop()});class a{getClassName(){return"TargetedAnimation"}serialize(){const t={};return t.animation=this.animation.serialize(),t.targetId=this.target.id,t}}class v{get mask(){return this._mask}set mask(t){this._mask!==t&&(this._mask=t,this.syncWithMask(!0))}syncWithMask(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||t){this._numActiveAnimatables=0;for(let t=0;t<this._animatables.length;++t){const q=this._animatables[t];!this.mask||this.mask.disabled||this.mask.retainsTarget(q.target.name)?(this._numActiveAnimatables++,q.paused&&q.restart()):q.paused||q.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let t=0;t<this._animatables.length;++t){const q=this._animatables[t];this.mask.retainsTarget(q.target.name)||(q.stop(),this._animatables.splice(t,1),--t)}for(let t=0;t<this._targetedAnimations.length;t++){const q=this._targetedAnimations[t];this.mask.retainsTarget(q.target.name)||(this._targetedAnimations.splice(t,1),--t)}}}get from(){return this._from}set from(t){if(this._from!==t){this._from=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].fromFrame=this._from}}}get to(){return this._to}set to(t){if(this._to!==t){this._to=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(t){if(this._speedRatio!==t){this._speedRatio=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(t){if(this._loopAnimation!==t){this._loopAnimation=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(t){if(this._isAdditive!==t){this._isAdditive=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(t){this._weight!==t&&(this._weight=t,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(t){if(this._playOrder!==t&&(this._playOrder=t,this._animatables.length>0)){for(let t=0;t<this._animatables.length;t++)this._animatables[t].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(t){if(this._enableBlending!==t&&(this._enableBlending=t,null!==t))for(let q=0;q<this._targetedAnimations.length;++q)this._targetedAnimations[q].animation.enableBlending=t}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(t){if(this._blendingSpeed!==t&&(this._blendingSpeed=t,null!==t))for(let q=0;q<this._targetedAnimations.length;++q)this._targetedAnimations[q].animation.blendingSpeed=t}getLength(t,q){t=t??this._from;return((q=q??this._to)-t)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(t){let q=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],S=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3?arguments[3]:void 0;if(0===t.length)return null;o=o??t[0].weight;let B=Number.MAX_VALUE,z=-Number.MAX_VALUE;if(S)for(const r of t)r.from<B&&(B=r.from),r.to>z&&(z=r.to);const L=new v(t[0].name+"_merged",t[0]._scene,o);for(const r of t){S&&r.normalize(B,z);for(const t of r.targetedAnimations)L.addTargetedAnimation(t.animation,t.target);q&&r.dispose()}return L}constructor(t){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=t,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new B.b,this.onAnimationLoopObservable=new B.b,this.onAnimationGroupLoopObservable=new B.b,this.onAnimationGroupEndObservable=new B.b,this.onAnimationGroupPauseObservable=new B.b,this.onAnimationGroupPlayObservable=new B.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=q||z.b.LastCreatedScene,this._weight=S,this._playOrder=o,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(t,q){const S=new a;S.animation=t,S.target=q;const o=t.getKeys();return this._from>o[0].frame&&(this._from=o[0].frame),this._to<o[o.length-1].frame&&(this._to=o[o.length-1].frame),null!==this._enableBlending&&(t.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(t.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(S),this._shouldStart=!0,S}removeTargetedAnimation(t){for(let q=this._targetedAnimations.length-1;q>-1;q--){this._targetedAnimations[q].animation===t&&this._targetedAnimations.splice(q,1)}}normalize(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==t&&(t=this._from),null==q&&(q=this._to);for(let S=0;S<this._targetedAnimations.length;S++){const o=this._targetedAnimations[S].animation.getKeys(),B=o[0],z=o[o.length-1];if(B.frame>t){const q={frame:t,value:B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation};o.splice(0,0,q)}if(z.frame<q){const t={frame:q,value:z.value,inTangent:z.inTangent,outTangent:z.outTangent,interpolation:z.interpolation};o.push(t)}}return this._from=t,this._to=q,this}_processLoop(t,q,S){t.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(q),this._animationLoopFlags[S]||(this._animationLoopFlags[S]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,S=arguments.length>2?arguments[2]:void 0,o=arguments.length>3?arguments[3]:void 0,B=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=t,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let z=0;z<this._targetedAnimations.length;z++){const L=this._targetedAnimations[z],r=this._scene.beginDirectAnimation(L.target,[L.animation],void 0!==S?S:this._from,void 0!==o?o:this._to,t,q,void 0,void 0,void 0!==B?B:this._isAdditive);r.weight=this._weight,r.playOrder=this._playOrder,r.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(L),this._checkAnimationGroupEnded(r)},this._processLoop(r,L,z),this._animatables.push(r)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=q,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let t=0;t<this._animatables.length;t++){this._animatables[t].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(t){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==t&&(this.loopAnimation=t),this.restart()):(this.stop(),this.start(t,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].reset()}return this}restart(){if(!this._isStarted)return this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const q=this._animatables.slice();for(let o=0;o<q.length;o++)q[o].stop(void 0,void 0,!0,t);let S=0;for(let o=0;o<this._scene._activeAnimatables.length;o++){const q=this._scene._activeAnimatables[o];q._runtimeAnimations.length>0?this._scene._activeAnimatables[S++]=q:t&&this._checkAnimationGroupEnded(q,t)}return this._scene._activeAnimatables.length=S,this._isStarted=!1,this}setWeightForAllAnimatables(t){for(let q=0;q<this._animatables.length;q++){this._animatables[q].weight=t}return this}syncAllAnimationsWith(t){for(let q=0;q<this._animatables.length;q++){this._animatables[q].syncWith(t)}return this}goToFrame(t){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._isStarted)return this;for(let S=0;S<this._animatables.length;S++){this._animatables[S].goToFrame(t,q)}return this}getCurrentFrame(){var t;return(null===(t=this.animatables[0])||void 0===t?void 0:t.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const t=this._scene.animationGroups.indexOf(this);if(t>-1&&this._scene.animationGroups.splice(t,1),this._parentContainer){const t=this._parentContainer.animationGroups.indexOf(this);t>-1&&this._parentContainer.animationGroups.splice(t,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(t){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const S=this._animatables.indexOf(t);S>-1&&this._animatables.splice(S,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,q||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(t,q){let S=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=new v(t||this.name,this._scene,this._weight,this._playOrder);o._from=this.from,o._to=this.to,o._speedRatio=this.speedRatio,o._loopAnimation=this.loopAnimation,o._isAdditive=this.isAdditive,o._enableBlending=this.enableBlending,o._blendingSpeed=this.blendingSpeed,o.metadata=this.metadata,o.mask=this.mask;for(const B of this._targetedAnimations)o.addTargetedAnimation(S?B.animation.clone():B.animation,q?q(B.target):B.target);return o}serialize(){const t={};t.name=this.name,t.from=this.from,t.to=this.to,t.speedRatio=this.speedRatio,t.loopAnimation=this.loopAnimation,t.isAdditive=this.isAdditive,t.weight=this.weight,t.playOrder=this.playOrder,t.enableBlending=this.enableBlending,t.blendingSpeed=this.blendingSpeed,t.targetedAnimations=[];for(let q=0;q<this.targetedAnimations.length;q++){const S=this.targetedAnimations[q];t.targetedAnimations[q]=S.serialize()}return L.e&&L.e.HasTags(this)&&(t.tags=L.e.GetTags(this)),this.metadata&&(t.metadata=this.metadata),t}static Parse(t,q){const S=new v(t.name,q,t.weight,t.playOrder);for(let B=0;B<t.targetedAnimations.length;B++){const z=t.targetedAnimations[B],L=o.b.Parse(z.animation),r=z.targetId;if("influence"===z.animation.property){const t=q.getMorphTargetById(r);t&&S.addTargetedAnimation(L,t)}else{const t=q.getNodeById(r);null!=t&&S.addTargetedAnimation(L,t)}}return L.e&&L.e.AddTagsTo(S,t.tags),null!==t.from&&null!==t.to&&S.normalize(t.from,t.to),void 0!==t.speedRatio&&(S._speedRatio=t.speedRatio),void 0!==t.loopAnimation&&(S._loopAnimation=t.loopAnimation),void 0!==t.isAdditive&&(S._isAdditive=t.isAdditive),void 0!==t.weight&&(S._weight=t.weight),void 0!==t.playOrder&&(S._playOrder=t.playOrder),void 0!==t.enableBlending&&(S._enableBlending=t.enableBlending),void 0!==t.blendingSpeed&&(S._blendingSpeed=t.blendingSpeed),void 0!==t.metadata&&(S.metadata=t.metadata),S}static MakeAnimationAdditive(t,q,S){let B;B="object"===typeof q?q:{referenceFrame:q,range:S,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let z=t;B.cloneOriginalAnimationGroup&&(z=t.clone(B.clonedAnimationGroupName||z.name));const L=z.targetedAnimations;for(let r=0;r<L.length;r++){const t=L[r];t.animation=o.b.MakeAnimationAdditive(t.animation,B)}if(z.isAdditive=!0,B.clipKeys){let t=Number.MAX_VALUE,q=-Number.MAX_VALUE;const S=z.targetedAnimations;for(let o=0;o<S.length;o++){const B=S[o].animation.getKeys();t>B[0].frame&&(t=B[0].frame),q<B[B.length-1].frame&&(q=B[B.length-1].frame)}z._from=t,z._to=q}return z}static ClipKeys(t,q,S,o,B){const z=t.clone(o||t.name);return v.ClipKeysInPlace(z,q,S,B)}static ClipKeysInPlace(t,q,S,o){return v.ClipInPlace(t,q,S,o,!1)}static ClipFrames(t,q,S,o,B){const z=t.clone(o||t.name);return v.ClipFramesInPlace(z,q,S,B)}static ClipFramesInPlace(t,q,S,o){return v.ClipInPlace(t,q,S,o,!0)}static ClipInPlace(t,q,S,o){let B=arguments.length>4&&void 0!==arguments[4]&&arguments[4],z=Number.MAX_VALUE,L=-Number.MAX_VALUE;const r=t.targetedAnimations;for(let e=0;e<r.length;e++){const t=r[e],C=o?t.animation:t.animation.clone();B&&(C.createKeyForFrame(q),C.createKeyForFrame(S));const Z=C.getKeys(),b=[];let O=Number.MAX_VALUE;for(let o=0;o<Z.length;o++){const t=Z[o];if(!B&&o>=q&&o<=S||B&&t.frame>=q&&t.frame<=S){const q={frame:t.frame,value:t.value.clone?t.value.clone():t.value,inTangent:t.inTangent,outTangent:t.outTangent,interpolation:t.interpolation,lockedTangent:t.lockedTangent};O===Number.MAX_VALUE&&(O=q.frame),q.frame-=O,b.push(q)}}0!==b.length?(z>b[0].frame&&(z=b[0].frame),L<b[b.length-1].frame&&(L=b[b.length-1].frame),C.setKeys(b,!0),t.animation=C):(r.splice(e,1),e--)}return t._from=z,t._to=L,t}getClassName(){return"AnimationGroup"}toString(t){let q="Name: "+this.name;return q+=", type: "+this.getClassName(),t&&(q+=", from: "+this._from,q+=", to: "+this._to,q+=", isStarted: "+this._isStarted,q+=", speedRatio: "+this._speedRatio,q+=", targetedAnimations length: "+this._targetedAnimations.length,q+=", animatables length: "+this._animatables),q}}}}]);