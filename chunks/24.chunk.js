"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[24],{13031:(G,V,W)=>{W.d(V,{b:()=>t,c:()=>S,g:()=>u,j:()=>H});var J=W(11189),R=W(11136),d=W(11182),k=W(11620),z=W(11285),X=W(11645),P=(W(11737),W(11686)),A=W(11201);W(11730),W(11710),W(11820);const x="image/png",q=2,L=[134,22,135,150,246,214,150,54];function t(G){const V=new DataView(G.buffer,G.byteOffset,G.byteLength);let W=0;for(let k=0;k<L.length;k++)if(V.getUint8(W++)!==L[k])return A.c.Error("Not a babylon environment map"),null;let J="",R=0;for(;R=V.getUint8(W++);)J+=String.fromCharCode(R);let d=JSON.parse(J);return d=Y(d),d.binaryDataPosition=W,d.sP&&(d.sP.lodGenerationScale=d.sP.lodGenerationScale||.8),d}function Y(G){if(G.version>q)throw new Error(`Unsupported babylon environment map version "${G.version}". Latest supported version is "${q}".`);return 2===G.version?G:G={...G,version:2,imageType:x}}function g(G,V){const W=(V=Y(V)).sP;let J=Math.log2(V.width);if(J=Math.round(J)+1,W.mipmaps.length!==6*J)throw new Error(`Unsupported specular mipmaps number "${W.mipmaps.length}"`);const R=new Array(J);for(let d=0;d<J;d++){R[d]=new Array(6);for(let J=0;J<6;J++){const k=W.mipmaps[6*d+J];R[d][J]=new Uint8Array(G.buffer,G.byteOffset+V.binaryDataPosition+k.position,k.length)}}return R}function B(G,V){var W;V=Y(V);const J=new Array(6),R=null===(W=V.irradiance)||void 0===W?void 0:W.irradianceTexture;if(R){if(6!==R.faces.length)throw new Error(`Incorrect irradiance texture faces number "${R.faces.length}"`);for(let W=0;W<6;W++){const d=R.faces[W];J[W]=new Uint8Array(G.buffer,G.byteOffset+V.binaryDataPosition+d.position,d.length)}}return J}function S(G,V,W){var J;const d=(W=Y(W)).sP;if(!d)return Promise.resolve([]);G._lodGenerationScale=d.lodGenerationScale;const k=[],z=g(V,W);k.push(b(G,z,W.imageType));const X=null===(J=W.irradiance)||void 0===J?void 0:J.irradianceTexture;if(X){var P,A;const J=B(V,W);let d=null;null!==(P=W.irradiance)&&void 0!==P&&null!==(A=P.irradianceTexture)&&void 0!==A&&A.dominantDirection&&(d=R.o.ld(W.irradiance.irradianceTexture.dominantDirection)),k.push(r(G,J,X.size,W.imageType,d))}return Promise.all(k)}async function p(G,V,W,J,R,d,k,z,X,P,A){return await new Promise(((x,q)=>{if(W){const W=V.createTexture(null,!0,!0,null,1,null,(G=>{q(G)}),G);null===J||void 0===J||J.onEffectCreatedObservable.addOnce((z=>{z.executeWhenCompiled((()=>{J.externalTextureSamplerBinding=!0,J.onApply=J=>{J._bindTexture("textureSampler",W),J.setFloat2("scale",1,V._features.needsInvertingBitmap&&G instanceof ImageBitmap?-1:1)},V.scenes.length&&(V.scenes[0].postProcessManager.directRender([J],P,!0,d,k),V.restoreDefaultFramebuffer(),W.dispose(),URL.revokeObjectURL(R),x())}))}))}else{if(V._uploadImageToTexture(A,G,d,k),z){const W=X[k];W&&V._uploadImageToTexture(W._texture,G,d,0)}x()}}))}async function b(G,V){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:x;const J=G.getEngine();G.format=5,G.type=0,G.generateMipMaps=!0,G._cachedAnisotropicFilteringLevel=null,J.updateTextureSamplingMode(3,G),await y(G,V,!0,W),G.isReady=!0}async function r(G,V,W){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:x,R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const d=G.getEngine(),k=new z.d(d,5),P=new X.b(d,k);G._irradianceTexture=P,P._dominantDirection=R,k.isCube=!0,k.format=5,k.type=0,k.generateMipMaps=!0,k._cachedAnisotropicFilteringLevel=null,k.generateMipMaps=!0,k.width=W,k.height=W,d.updateTextureSamplingMode(3,k),await y(k,[V],!1,J),d.generateMipMapsForCubemap(k),k.isReady=!0}async function y(G,V,R){let k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:x;if(!J.h.IsExponentOfTwo(G.width))throw new Error("Texture size must be a power of two");const A=(0,d.ILog2)(G.width)+1,q=G.getEngine();let L=!1,t=!1,Y=null,g=null,B=null;const S=q.getCaps();S.textureLOD?q._features.supportRenderAndCopyToLodForFloatTextures?S.textureHalfFloatRender&&S.textureHalfFloatLinearFiltering?(L=!0,G.type=2):S.textureFloatRender&&S.textureFloatLinearFiltering&&(L=!0,G.type=1):L=!1:(L=!1,t=R);let b=0;if(L)q.isWebGPU?(b=1,await W.e(21).then(W.bind(W,13878))):await W.e(14).then(W.bind(W,13882)),Y=new P.c("rgbdDecode","rgbdDecode",null,null,1,null,3,q,!1,void 0,G.type,void 0,null,!1,void 0,b),G._isRGBD=!1,G.invertY=!1,g=q.createRenderTargetCubeTexture(G.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:G.type,format:5});else if(G._isRGBD=!0,G.invertY=!0,t){const V=3;B={};const W=G._lodGenerationScale,J=G._lodGenerationOffset;for(let R=0;R<V;R++){const d=(A-1)*W+J,k=J+(d-J)*(1-R/(V-1)),P=Math.round(Math.min(Math.max(k,0),d)),x=new z.d(q,2);x.isCube=!0,x.invertY=!0,x.generateMipMaps=!1,q.updateTextureSamplingMode(2,x);const L=new X.b(null);switch(L._isCube=!0,L._texture=x,B[P]=L,R){case 0:G._lodTextureLow=L;break;case 1:G._lodTextureMid=L;break;case 2:G._lodTextureHigh=L}}}const r=[];for(let W=0;W<V.length;W++)for(let J=0;J<6;J++){const R=V[W][J],d=new Blob([R],{type:k}),z=URL.createObjectURL(d);let X;if(q._features.forceBitmapOverHTMLImageElement)X=q.createImageBitmap(d,{premultiplyAlpha:"none"}).then((async V=>await p(V,q,L,Y,z,J,W,t,B,g,G)));else{const V=new Image;V.src=z,X=new Promise(((R,d)=>{V.onload=()=>{p(V,q,L,Y,z,J,W,t,B,g,G).then((()=>R())).catch((G=>{d(G)}))},V.onerror=G=>{d(G)}}))}r.push(X)}if(await Promise.all(r),V.length<A){let W;const J=Math.pow(2,A-1-V.length),R=J*J*4;switch(G.type){case 0:W=new Uint8Array(R);break;case 2:W=new Uint16Array(R);break;case 1:W=new Float32Array(R)}for(let d=V.length;d<A;d++)for(let V=0;V<6;V++){var y;q._uploadArrayBufferViewToTexture((null===(y=g)||void 0===y?void 0:y.texture)||G,W,V,d)}}if(g){const V=G._irradianceTexture;G._irradianceTexture=null,q._releaseTexture(G),g._swapAndDie(G),G._irradianceTexture=V}Y&&Y.dispose(),t&&(G._lodTextureHigh&&G._lodTextureHigh._texture&&(G._lodTextureHigh._texture.isReady=!0),G._lodTextureMid&&G._lodTextureMid._texture&&(G._lodTextureMid._texture.isReady=!0),G._lodTextureLow&&G._lodTextureLow._texture&&(G._lodTextureLow._texture.isReady=!0))}function u(G,V){const W=(V=Y(V)).irradiance;if(!W)return;const J=new k.g;R.o.FromArrayToRef(W.x,0,J.x),R.o.FromArrayToRef(W.y,0,J.y),R.o.FromArrayToRef(W.z,0,J.z),R.o.FromArrayToRef(W.xx,0,J.xx),R.o.FromArrayToRef(W.yy,0,J.yy),R.o.FromArrayToRef(W.zz,0,J.zz),R.o.FromArrayToRef(W.yz,0,J.yz),R.o.FromArrayToRef(W.zx,0,J.zx),R.o.FromArrayToRef(W.xy,0,J.xy),G._sphericalPolynomial=J}function H(G,V,W,J,R){const d=b(G.getEngine().createRawCubeTexture(null,G.width,G.format,G.type,G.generateMipMaps,G.invertY,G.samplingMode,G._compression),V).then((()=>G));return G.onRebuildCallback=G=>({proxy:d,isReady:!0,isAsync:!0}),G._source=13,G._bufferViewArrayArray=V,G._lodGenerationScale=J,G._lodGenerationOffset=R,G._sphericalPolynomial=W,b(G,V).then((()=>(G.isReady=!0,G)))}}}]);