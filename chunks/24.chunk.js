"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[24],{13190:(U,G,C)=>{C.d(G,{b:()=>L});class L{constructor(U,G,C){this.bu=U,this.bv=G,this.distance=C,this.faceId=0,this.subMeshId=0}}},13200:(U,G,C)=>{C.d(G,{d:()=>t});var L=C(12907),X=C(12896),l=C(12898);class t{constructor(U,G,C){this.vectors=(0,L.e)(8,X.pG.Zero),this.center=X.pG.Zero(),this.centerWorld=X.pG.Zero(),this.extendSize=X.pG.Zero(),this.extendSizeWorld=X.pG.Zero(),this.directions=(0,L.e)(3,X.pG.Zero),this.vectorsWorld=(0,L.e)(8,X.pG.Zero),this.minimumWorld=X.pG.Zero(),this.maximumWorld=X.pG.Zero(),this.minimum=X.pG.Zero(),this.maximum=X.pG.Zero(),this._drawWrapperFront=null,this._drawWrapperBack=null,this.reConstruct(U,G,C)}reConstruct(U,G,C){const L=U.x,l=U.y,t=U.z,E=G.x,K=G.y,P=G.z,O=this.vectors;this.minimum.WE(L,l,t),this.maximum.WE(E,K,P),O[0].WE(L,l,t),O[1].WE(E,K,P),O[2].WE(E,l,t),O[3].WE(L,K,t),O[4].WE(L,l,P),O[5].WE(E,K,t),O[6].WE(L,K,P),O[7].WE(E,l,P),G.addToRef(U,this.center).scaleInPlace(.5),G.subtractToRef(U,this.extendSize).scaleInPlace(.5),this._worldMatrix=C||X.Matrix.IdentityReadOnly,this._update(this._worldMatrix)}scale(U){const G=t._TmpVector3,C=this.maximum.subtractToRef(this.minimum,G[0]),L=C.length();C.normalizeFromLength(L);const X=L*U,l=C.scaleInPlace(.5*X),E=this.center.subtractToRef(l,G[1]),K=this.center.addToRef(l,G[2]);return this.reConstruct(E,K,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(U){const G=this.minimumWorld,C=this.maximumWorld,L=this.directions,l=this.vectorsWorld,t=this.vectors;if(U.isIdentity()){G.L(this.minimum),C.L(this.maximum);for(let U=0;U<8;++U)l[U].L(t[U]);this.extendSizeWorld.L(this.extendSize),this.centerWorld.L(this.center)}else{G.rE(Number.MAX_VALUE),C.rE(-Number.MAX_VALUE);for(let L=0;L<8;++L){const E=l[L];X.pG.TransformCoordinatesToRef(t[L],U,E),G.minimizeInPlace(E),C.maximizeInPlace(E)}C.subtractToRef(G,this.extendSizeWorld).scaleInPlace(.5),C.addToRef(G,this.centerWorld).scaleInPlace(.5)}X.pG.FromArrayToRef(U.m,0,L[0]),X.pG.FromArrayToRef(U.m,4,L[1]),X.pG.FromArrayToRef(U.m,8,L[2]),this._worldMatrix=U}isInFrustum(U){return t.IsInFrustum(this.vectorsWorld,U)}isCompletelyInFrustum(U){return t.IsCompletelyInFrustum(this.vectorsWorld,U)}intersectsPoint(U){const G=this.minimumWorld,C=this.maximumWorld,L=G.x,X=G.y,t=G.z,E=C.x,K=C.y,P=C.z,O=U.x,T=U.y,D=U.z,y=-l.d;return!(E-O<y||y>O-L)&&(!(K-T<y||y>T-X)&&!(P-D<y||y>D-t))}intersectsSphere(U){return t.IntersectsSphere(this.minimumWorld,this.maximumWorld,U.centerWorld,U.radiusWorld)}intersectsMinMax(U,G){const C=this.minimumWorld,L=this.maximumWorld,X=C.x,l=C.y,t=C.z,E=L.x,K=L.y,P=L.z,O=U.x,T=U.y,D=U.z,y=G.x,V=G.y,p=G.z;return!(E<O||X>y)&&(!(K<T||l>V)&&!(P<D||t>p))}dispose(){var U,G;null===(U=this._drawWrapperFront)||void 0===U||U.dispose(),null===(G=this._drawWrapperBack)||void 0===G||G.dispose()}static Intersects(U,G){return U.intersectsMinMax(G.minimumWorld,G.maximumWorld)}static IntersectsSphere(U,G,C,L){const l=t._TmpVector3[0];X.pG.ClampToRef(C,U,G,l);return X.pG.DistanceSquared(C,l)<=L*L}static IsCompletelyInFrustum(U,G){for(let C=0;C<6;++C){const L=G[C];for(let G=0;G<8;++G)if(L.dotCoordinate(U[G])<0)return!1}return!0}static IsInFrustum(U,G){for(let C=0;C<6;++C){let L=!0;const X=G[C];for(let G=0;G<8;++G)if(X.dotCoordinate(U[G])>=0){L=!1;break}if(L)return!1}return!0}}t._TmpVector3=(0,L.e)(3,X.pG.Zero)},13192:(U,G,C)=>{C.d(G,{c:()=>T});var L=C(12907),X=C(12896),l=C(13200),t=C(13206);const E={min:0,max:0},K={min:0,max:0},P=(U,G,C)=>{const L=X.pG.Dot(G.centerWorld,U),l=Math.abs(X.pG.Dot(G.directions[0],U))*G.extendSize.x+Math.abs(X.pG.Dot(G.directions[1],U))*G.extendSize.y+Math.abs(X.pG.Dot(G.directions[2],U))*G.extendSize.z;C.min=L-l,C.max=L+l},O=(U,G,C)=>(P(U,G,E),P(U,C,K),!(E.min>K.max||K.min>E.max));class T{constructor(U,G,C){this._isLocked=!1,this.boundingBox=new l.d(U,G,C),this.boundingSphere=new t.d(U,G,C)}reConstruct(U,G,C){this.boundingBox.reConstruct(U,G,C),this.boundingSphere.reConstruct(U,G,C)}get minimum(){return this.boundingBox.minimum}get maximum(){return this.boundingBox.maximum}get isLocked(){return this._isLocked}set isLocked(U){this._isLocked=U}update(U){this._isLocked||(this.boundingBox._update(U),this.boundingSphere._update(U))}centerOn(U,G){const C=T._TmpVector3[0].L(U).uT(G),L=T._TmpVector3[1].L(U).addInPlace(G);return this.boundingBox.reConstruct(C,L,this.boundingBox.getWorldMatrix()),this.boundingSphere.reConstruct(C,L,this.boundingBox.getWorldMatrix()),this}encapsulate(U){const G=X.pG.Minimize(this.minimum,U),C=X.pG.Maximize(this.maximum,U);return this.reConstruct(G,C,this.boundingBox.getWorldMatrix()),this}encapsulateBoundingInfo(U){const G=X.TmpVectors.Matrix[0];this.boundingBox.getWorldMatrix().invertToRef(G);const C=X.TmpVectors.pG[0];return X.pG.TransformCoordinatesToRef(U.boundingBox.minimumWorld,G,C),this.encapsulate(C),X.pG.TransformCoordinatesToRef(U.boundingBox.maximumWorld,G,C),this.encapsulate(C),this}scale(U){return this.boundingBox.scale(U),this.boundingSphere.scale(U),this}isInFrustum(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if((2===G||3===G)&&this.boundingSphere.isCenterInFrustum(U))return!0;if(!this.boundingSphere.isInFrustum(U))return!1;return!(1!==G&&3!==G)||this.boundingBox.isInFrustum(U)}get diagonalLength(){const U=this.boundingBox;return U.maximumWorld.subtractToRef(U.minimumWorld,T._TmpVector3[0]).length()}isCompletelyInFrustum(U){return this.boundingBox.isCompletelyInFrustum(U)}_checkCollision(U){return U._canDoCollision(this.boundingSphere.centerWorld,this.boundingSphere.radiusWorld,this.boundingBox.minimumWorld,this.boundingBox.maximumWorld)}intersectsPoint(U){return!!this.boundingSphere.centerWorld&&(!!this.boundingSphere.intersectsPoint(U)&&!!this.boundingBox.intersectsPoint(U))}intersects(U,G){if(!t.d.Intersects(this.boundingSphere,U.boundingSphere))return!1;if(!l.d.Intersects(this.boundingBox,U.boundingBox))return!1;if(!G)return!0;const C=this.boundingBox,L=U.boundingBox;return!!O(C.directions[0],C,L)&&(!!O(C.directions[1],C,L)&&(!!O(C.directions[2],C,L)&&(!!O(L.directions[0],C,L)&&(!!O(L.directions[1],C,L)&&(!!O(L.directions[2],C,L)&&(!!O(X.pG.Cross(C.directions[0],L.directions[0]),C,L)&&(!!O(X.pG.Cross(C.directions[0],L.directions[1]),C,L)&&(!!O(X.pG.Cross(C.directions[0],L.directions[2]),C,L)&&(!!O(X.pG.Cross(C.directions[1],L.directions[0]),C,L)&&(!!O(X.pG.Cross(C.directions[1],L.directions[1]),C,L)&&(!!O(X.pG.Cross(C.directions[1],L.directions[2]),C,L)&&(!!O(X.pG.Cross(C.directions[2],L.directions[0]),C,L)&&(!!O(X.pG.Cross(C.directions[2],L.directions[1]),C,L)&&!!O(X.pG.Cross(C.directions[2],L.directions[2]),C,L))))))))))))))}}T._TmpVector3=(0,L.e)(2,X.pG.Zero)},13206:(U,G,C)=>{C.d(G,{d:()=>l});var L=C(12907),X=C(12896);class l{constructor(U,G,C){this.center=X.pG.Zero(),this.centerWorld=X.pG.Zero(),this.minimum=X.pG.Zero(),this.maximum=X.pG.Zero(),this.reConstruct(U,G,C)}reConstruct(U,G,C){this.minimum.L(U),this.maximum.L(G);const L=X.pG.Distance(U,G);G.addToRef(U,this.center).scaleInPlace(.5),this.radius=.5*L,this._update(C||X.Matrix.IdentityReadOnly)}scale(U){const G=this.radius*U,C=l._TmpVector3,L=C[0].rE(G),X=this.center.subtractToRef(L,C[1]),t=this.center.addToRef(L,C[2]);return this.reConstruct(X,t,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(U){if(U.isIdentity())this.centerWorld.L(this.center),this.radiusWorld=this.radius;else{X.pG.TransformCoordinatesToRef(this.center,U,this.centerWorld);const G=l._TmpVector3[0];X.pG.TransformNormalFromFloatsToRef(1,1,1,U,G),this.radiusWorld=Math.max(Math.abs(G.x),Math.abs(G.y),Math.abs(G.z))*this.radius}}isInFrustum(U){const G=this.centerWorld,C=this.radiusWorld;for(let L=0;L<6;L++)if(U[L].dotCoordinate(G)<=-C)return!1;return!0}isCenterInFrustum(U){const G=this.centerWorld;for(let C=0;C<6;C++)if(U[C].dotCoordinate(G)<0)return!1;return!0}intersectsPoint(U){const G=X.pG.DistanceSquared(this.centerWorld,U);return!(this.radiusWorld*this.radiusWorld<G)}static Intersects(U,G){const C=X.pG.DistanceSquared(U.centerWorld,G.centerWorld),L=U.radiusWorld+G.radiusWorld;return!(L*L<C)}static CreateFromCenterAndRadius(U,G,C){this._TmpVector3[0].L(U),this._TmpVector3[1].WE(0,0,G),this._TmpVector3[2].L(U),this._TmpVector3[0].addInPlace(this._TmpVector3[1]),this._TmpVector3[2].uT(this._TmpVector3[1]);const L=new l(this._TmpVector3[0],this._TmpVector3[2]);return L._worldMatrix=C||X.Matrix.Identity(),L}}l._TmpVector3=(0,L.e)(3,X.pG.Zero)},13224:(U,G,C)=>{function L(U){-1===U.indexOf("vClipPlane")&&U.push("vClipPlane"),-1===U.indexOf("vClipPlane2")&&U.push("vClipPlane2"),-1===U.indexOf("vClipPlane3")&&U.push("vClipPlane3"),-1===U.indexOf("vClipPlane4")&&U.push("vClipPlane4"),-1===U.indexOf("vClipPlane5")&&U.push("vClipPlane5"),-1===U.indexOf("vClipPlane6")&&U.push("vClipPlane6")}function X(U,G,C){var L,X,l,t,E,K;const P=!!(null!==(L=U.clipPlane)&&void 0!==L?L:G.clipPlane),O=!!(null!==(X=U.clipPlane2)&&void 0!==X?X:G.clipPlane2),T=!!(null!==(l=U.clipPlane3)&&void 0!==l?l:G.clipPlane3),D=!!(null!==(t=U.clipPlane4)&&void 0!==t?t:G.clipPlane4),y=!!(null!==(E=U.clipPlane5)&&void 0!==E?E:G.clipPlane5),V=!!(null!==(K=U.clipPlane6)&&void 0!==K?K:G.clipPlane6);P&&C.push("#define CLIPPLANE"),O&&C.push("#define CLIPPLANE2"),T&&C.push("#define CLIPPLANE3"),D&&C.push("#define CLIPPLANE4"),y&&C.push("#define CLIPPLANE5"),V&&C.push("#define CLIPPLANE6")}function l(U,G,C){var L,X,l,t,E,K;let P=!1;const O=!!(null!==(L=U.clipPlane)&&void 0!==L?L:G.clipPlane),T=!!(null!==(X=U.clipPlane2)&&void 0!==X?X:G.clipPlane2),D=!!(null!==(l=U.clipPlane3)&&void 0!==l?l:G.clipPlane3),y=!!(null!==(t=U.clipPlane4)&&void 0!==t?t:G.clipPlane4),V=!!(null!==(E=U.clipPlane5)&&void 0!==E?E:G.clipPlane5),p=!!(null!==(K=U.clipPlane6)&&void 0!==K?K:G.clipPlane6);return C.CLIPPLANE!==O&&(C.CLIPPLANE=O,P=!0),C.CLIPPLANE2!==T&&(C.CLIPPLANE2=T,P=!0),C.CLIPPLANE3!==D&&(C.CLIPPLANE3=D,P=!0),C.CLIPPLANE4!==y&&(C.CLIPPLANE4=y,P=!0),C.CLIPPLANE5!==V&&(C.CLIPPLANE5=V,P=!0),C.CLIPPLANE6!==p&&(C.CLIPPLANE6=p,P=!0),P}function t(U,G,C){var L,X,l,t,K,P;let O=null!==(L=G.clipPlane)&&void 0!==L?L:C.clipPlane;E(U,"vClipPlane",O),O=null!==(X=G.clipPlane2)&&void 0!==X?X:C.clipPlane2,E(U,"vClipPlane2",O),O=null!==(l=G.clipPlane3)&&void 0!==l?l:C.clipPlane3,E(U,"vClipPlane3",O),O=null!==(t=G.clipPlane4)&&void 0!==t?t:C.clipPlane4,E(U,"vClipPlane4",O),O=null!==(K=G.clipPlane5)&&void 0!==K?K:C.clipPlane5,E(U,"vClipPlane5",O),O=null!==(P=G.clipPlane6)&&void 0!==P?P:C.clipPlane6,E(U,"vClipPlane6",O)}function E(U,G,C){C&&U.setFloat4(G,C.normal.x,C.normal.y,C.normal.z,C.d)}C.d(G,{b:()=>L,e:()=>t,f:()=>l,g:()=>X})},13170:(U,G,C)=>{C.d(G,{d:()=>L});class L{constructor(){this._defines={},this._currentRank=32,this._maxRank=-1,this._mesh=null}unBindMesh(){this._mesh=null}addFallback(U,G){this._defines[U]||(U<this._currentRank&&(this._currentRank=U),U>this._maxRank&&(this._maxRank=U),this._defines[U]=new Array),this._defines[U].push(G)}addCPUSkinningFallback(U,G){this._mesh=G,U<this._currentRank&&(this._currentRank=U),U>this._maxRank&&(this._maxRank=U)}get hasMoreFallbacks(){return this._currentRank<=this._maxRank}reduce(U,G){if(this._mesh&&this._mesh.computeBonesUsingShaders&&this._mesh.numBoneInfluencers>0){this._mesh.computeBonesUsingShaders=!1,U=U.replace("#define NUM_BONE_INFLUENCERS "+this._mesh.numBoneInfluencers,"#define NUM_BONE_INFLUENCERS 0"),G._bonesComputationForcedToCPU=!0;const C=this._mesh.wU();for(let U=0;U<C.meshes.length;U++){const L=C.meshes[U];if(L.material){if(L.computeBonesUsingShaders&&0!==L.numBoneInfluencers)if(L.material.getEffect()===G)L.computeBonesUsingShaders=!1;else if(L.zE)for(const U of L.zE){if(U.effect===G){L.computeBonesUsingShaders=!1;break}}}else!this._mesh.material&&L.computeBonesUsingShaders&&L.numBoneInfluencers>0&&(L.computeBonesUsingShaders=!1)}}else{const G=this._defines[this._currentRank];if(G)for(let C=0;C<G.length;C++)U=U.replace("#define "+G[C],"");this._currentRank++}return U}}},13178:(U,G,C)=>{C.d(G,{c:()=>H});var L=C(26),X=C(12876),l=C(12884),t=C(12718),E=C(12721),K=C(12763),P=C(13184),O=C(13116),T=C(12731),D=C(12940),y=C(13003),V=C(12928);class p{constructor(){this.reset()}reset(){this.enabled=!1,this.mask=255,this.func=519,this.funcRef=1,this.funcMask=255,this.opStencilFail=7680,this.opDepthFail=7680,this.opStencilDepthPass=7681}get func(){return this._func}set func(U){this._func=U}get funcRef(){return this._funcRef}set funcRef(U){this._funcRef=U}get funcMask(){return this._funcMask}set funcMask(U){this._funcMask=U}get opStencilFail(){return this._opStencilFail}set opStencilFail(U){this._opStencilFail=U}get opDepthFail(){return this._opDepthFail}set opDepthFail(U){this._opDepthFail=U}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(U){this._opStencilDepthPass=U}get mask(){return this._mask}set mask(U){this._mask=U}get enabled(){return this._enabled}set enabled(U){this._enabled=U}getClassName(){return"MaterialStencilState"}copyTo(U){V.c.Clone((()=>U),this)}serialize(){return V.c.Serialize(this)}parse(U,G,C){V.c.Parse((()=>this),U,G,C)}}(0,X.d)([(0,l.H)()],p.prototype,"func",null),(0,X.d)([(0,l.H)()],p.prototype,"funcRef",null),(0,X.d)([(0,l.H)()],p.prototype,"funcMask",null),(0,X.d)([(0,l.H)()],p.prototype,"opStencilFail",null),(0,X.d)([(0,l.H)()],p.prototype,"opDepthFail",null),(0,X.d)([(0,l.H)()],p.prototype,"opStencilDepthPass",null),(0,X.d)([(0,l.H)()],p.prototype,"mask",null),(0,X.d)([(0,l.H)()],p.prototype,"enabled",null);var I=C(13217);class H{get _supportGlowLayer(){return!1}set _glowModeEnabled(U){}get shaderLanguage(){return this._shaderLanguage}get canRenderToMRT(){return!1}set alpha(U){if(this._alpha===U)return;const G=this._alpha;this._alpha=U,1!==G&&1!==U||this.IO(H.MiscDirtyFlag+H.PrePassDirtyFlag)}get alpha(){return this._alpha}set RE(U){this._backFaceCulling!==U&&(this._backFaceCulling=U,this.IO(H.TextureDirtyFlag))}get RE(){return this._backFaceCulling}set cullBackFaces(U){this._cullBackFaces!==U&&(this._cullBackFaces=U,this.IO(H.TextureDirtyFlag))}get cullBackFaces(){return this._cullBackFaces}get blockDirtyMechanism(){return this._blockDirtyMechanism}set blockDirtyMechanism(U){this._blockDirtyMechanism!==U&&(this._blockDirtyMechanism=U,U||this.pD())}atomicMaterialsUpdate(U){this.blockDirtyMechanism=!0;try{U(this)}finally{this.blockDirtyMechanism=!1}}get hasRenderTargetTextures(){return this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._eventInfo.hasRenderTargetTextures}set onDispose(U){this._onDisposeObserver&&this.aE.remove(this._onDisposeObserver),this._onDisposeObserver=this.aE.add(U)}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new E.e),this._onBindObservable}set onBind(U){this._onBindObserver&&this.onBindObservable.remove(this._onBindObserver),this._onBindObserver=this.onBindObservable.add(U)}get onUnBindObservable(){return this._onUnBindObservable||(this._onUnBindObservable=new E.e),this._onUnBindObservable}get onEffectCreatedObservable(){return this._onEffectCreatedObservable||(this._onEffectCreatedObservable=new E.e),this._onEffectCreatedObservable}set alphaMode(U){this._alphaMode!==U&&(this._alphaMode=U,this.IO(H.TextureDirtyFlag))}get alphaMode(){return this._alphaMode}set needDepthPrePass(U){this._needDepthPrePass!==U&&(this._needDepthPrePass=U,this._needDepthPrePass&&(this.checkReadyOnEveryCall=!0))}get needDepthPrePass(){return this._needDepthPrePass}get isPrePassCapable(){return!1}set fogEnabled(U){this._fogEnabled!==U&&(this._fogEnabled=U,this.IO(H.MiscDirtyFlag))}get fogEnabled(){return this._fogEnabled}get wireframe(){switch(this._fillMode){case H.WireFrameFillMode:case H.LineListDrawMode:case H.LineLoopDrawMode:case H.LineStripDrawMode:return!0}return this._scene.forceWireframe}set wireframe(U){this.fillMode=U?H.WireFrameFillMode:H.TriangleFillMode}get pointsCloud(){switch(this._fillMode){case H.PointFillMode:case H.PointListDrawMode:return!0}return this._scene.forcePointsCloud}set pointsCloud(U){this.fillMode=U?H.PointFillMode:H.TriangleFillMode}get fillMode(){return this._fillMode}set fillMode(U){this._fillMode!==U&&(this._fillMode=U,this.IO(H.MiscDirtyFlag))}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(U){const G=this.wU().getEngine().getCaps().fragmentDepthSupported;U&&!G&&T.d.Warn("Logarithmic depth has been requested for a material on a device that doesn't support it."),this._useLogarithmicDepth=U&&G,this._markAllSubMeshesAsMiscDirty()}_getDrawWrapper(){return this._drawWrapper}_setDrawWrapper(U){this._drawWrapper=U}constructor(U,G,C){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.shadowDepthWrapper=null,this.allowShaderHotSwapping=!0,this._shaderLanguage=0,this._forceGLSL=!1,this.metadata=null,this.reservedDataStore=null,this.checkReadyOnEveryCall=!1,this.checkReadyOnlyOnce=!1,this.state="",this._alpha=1,this._backFaceCulling=!0,this._cullBackFaces=!0,this._blockDirtyMechanism=!1,this.sideOrientation=null,this.onCompiled=null,this.onError=null,this.getRenderTargetTextures=null,this.doNotSerialize=!1,this._storeEffectOnSubMeshes=!1,this.animations=null,this.aE=new E.e,this._onDisposeObserver=null,this._onUnBindObservable=null,this._onBindObserver=null,this._alphaMode=2,this._needDepthPrePass=!1,this.disableDepthWrite=!1,this.disableColorWrite=!1,this.forceDepthWrite=!1,this.depthFunction=0,this.separateCullingPass=!1,this._fogEnabled=!0,this.pointSize=1,this.zOffset=0,this.zOffsetUnits=0,this.kE=new p,this._useUBO=!1,this._fillMode=H.TriangleFillMode,this._cachedDepthWriteState=!1,this._cachedColorWriteState=!1,this._cachedDepthFunctionState=0,this._indexInSceneMaterialArray=-1,this.meshMap=null,this._parentContainer=null,this._uniformBufferLayoutBuilt=!1,this._eventInfo={},this._callbackPluginEventGeneric=()=>{},this._callbackPluginEventIsReadyForSubMesh=()=>{},this._callbackPluginEventPrepareDefines=()=>{},this._callbackPluginEventPrepareDefinesBeforeAttributes=()=>{},this._callbackPluginEventHardBindForSubMesh=()=>{},this._callbackPluginEventBindForSubMesh=()=>{},this._callbackPluginEventHasRenderTargetTextures=()=>{},this._callbackPluginEventFillRenderTargetTextures=()=>{},this._transparencyMode=null,this.name=U;const X=G||K.d.LastCreatedScene;X&&(this._scene=X,this._dirtyCallbacks={},this._forceGLSL=L,this._dirtyCallbacks[1]=this._markAllSubMeshesAsTexturesDirty.bind(this),this._dirtyCallbacks[2]=this._markAllSubMeshesAsLightsDirty.bind(this),this._dirtyCallbacks[4]=this._markAllSubMeshesAsFresnelDirty.bind(this),this._dirtyCallbacks[8]=this._markAllSubMeshesAsAttributesDirty.bind(this),this._dirtyCallbacks[16]=this._markAllSubMeshesAsMiscDirty.bind(this),this._dirtyCallbacks[32]=this._markAllSubMeshesAsPrePassDirty.bind(this),this._dirtyCallbacks[127]=this._markAllSubMeshesAsAllDirty.bind(this),this.id=U||t.Tools.RandomId(),this.uniqueId=this._scene.getUniqueId(),this._materialContext=this._scene.getEngine().createMaterialContext(),this._drawWrapper=new y.e(this._scene.getEngine(),!1),this._drawWrapper.materialContext=this._materialContext,this._uniformBuffer=new O.d(this._scene.getEngine(),void 0,void 0,U),this._useUBO=this.wU().getEngine().supportsUniformBuffers,this._createUniformBuffer(),C||this._scene.addMaterial(this),this._scene.useMaterialMeshMap&&(this.meshMap={}),H.OnEventObservable.notifyObservers(this,1))}_createUniformBuffer(){var U;const G=this.wU().getEngine();null===(U=this._uniformBuffer)||void 0===U||U.dispose(),G.isWebGPU&&!this._forceGLSL?(this._uniformBuffer=new O.d(G,void 0,void 0,this.name,!0),this._shaderLanguage=1):this._uniformBuffer=new O.d(this._scene.getEngine(),void 0,void 0,this.name),this._uniformBufferLayoutBuilt=!1}toString(U){return"Name: "+this.name}getClassName(){return"Material"}get _isMaterial(){return!0}get isFrozen(){return this.checkReadyOnlyOnce}freeze(){this.pD(),this.checkReadyOnlyOnce=!0}unfreeze(){this.pD(),this.checkReadyOnlyOnce=!1}isReady(U,G){return!0}isReadyForSubMesh(U,G,C){const L=G.materialDefines;return!!L&&(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=L,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),this._eventInfo.isReadyForSubMesh)}getEffect(){return this._drawWrapper.effect}wU(){return this._scene}_getEffectiveOrientation(U){return null!==this.sideOrientation?this.sideOrientation:U.sideOrientation}get transparencyMode(){return this._transparencyMode}set transparencyMode(U){this._transparencyMode!==U&&(this._transparencyMode=U,this._markAllSubMeshesAsTexturesAndMiscDirty())}get _hasTransparencyMode(){return null!=this._transparencyMode}get _transparencyModeIsBlend(){return this._transparencyMode===H.MATERIAL_ALPHABLEND||this._transparencyMode===H.MATERIAL_ALPHATESTANDBLEND}get _transparencyModeIsTest(){return this._transparencyMode===H.MATERIAL_ALPHATEST||this._transparencyMode===H.MATERIAL_ALPHATESTANDBLEND}get _disableAlphaBlending(){return this._transparencyMode===H.MATERIAL_OPAQUE||this._transparencyMode===H.MATERIAL_ALPHATEST}needAlphaBlending(){return this._hasTransparencyMode?this._transparencyModeIsBlend:!this._disableAlphaBlending&&this.alpha<1}needAlphaBlendingForMesh(U){return this._hasTransparencyMode?this._transparencyModeIsBlend:U.visibility<1||!this._disableAlphaBlending&&(U.hasVertexAlpha||this.needAlphaBlending())}needAlphaTesting(){return!!this._hasTransparencyMode&&this._transparencyModeIsTest}needAlphaTestingForMesh(U){return this._hasTransparencyMode?this._transparencyModeIsTest:!this.needAlphaBlendingForMesh(U)&&this.needAlphaTesting()}getAlphaTestTexture(){return null}pD(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const G=this.wU().meshes;for(const C of G)if(C.zE)for(const G of C.zE)if(G.QU()===this)for(const C of G._drawWrappers)C&&this._materialContext===C.materialContext&&(C._wasPreviouslyReady=!1,C._wasPreviouslyUsingInstances=null,C._forceRebindOnNextCall=U);U&&this.IO(H.AllDirtyFlag)}_preBind(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const C=this._scene.getEngine(),L=(null==G?this.sideOrientation:G)===H.ClockWiseSideOrientation;return C.enableEffect(U||this._getDrawWrapper()),C.setState(this.RE,this.zOffset,!1,L,this._scene._mirroredCameraPosition?!this.cullBackFaces:this.cullBackFaces,this.kE,this.zOffsetUnits),L}bind(U,G){}buildUniformLayout(){const U=this._uniformBuffer;this._eventInfo.ubo=U,this._callbackPluginEventGeneric(8,this._eventInfo),U.create(),this._uniformBufferLayoutBuilt=!0}bindForSubMesh(U,G,C){const L=C._drawWrapper;this._eventInfo.subMesh=C,this._callbackPluginEventBindForSubMesh(this._eventInfo),L._forceRebindOnNextCall=!1}bindOnlyWorldMatrix(U){}bindView(U){this._useUBO?this._needToBindSceneUbo=!0:U.setMatrix("view",this.wU().getViewMatrix())}bindViewProjection(U){this._useUBO?this._needToBindSceneUbo=!0:(U.setMatrix("viewProjection",this.wU().getTransformMatrix()),U.setMatrix("projection",this.wU().getProjectionMatrix()))}bindEyePosition(U,G){this._useUBO?this._needToBindSceneUbo=!0:this._scene.bindEyePosition(U,G)}_afterBind(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(this._scene._cachedMaterial=this,this._needToBindSceneUbo&&G&&(this._needToBindSceneUbo=!1,(0,I.r)(G,this.wU().getSceneUniformBuffer()),this._scene.finalizeSceneUbo()),this._scene._cachedVisibility=U?U.visibility:1,this._onBindObservable&&U&&this._onBindObservable.notifyObservers(U),this.disableDepthWrite){const U=this._scene.getEngine();this._cachedDepthWriteState=U.getDepthWrite(),U.setDepthWrite(!1)}if(this.disableColorWrite){const U=this._scene.getEngine();this._cachedColorWriteState=U.getColorWrite(),U.setColorWrite(!1)}if(0!==this.depthFunction){const U=this._scene.getEngine();this._cachedDepthFunctionState=U.getDepthFunction()||0,U.setDepthFunction(this.depthFunction)}}unbind(){if(this._scene.getSceneUniformBuffer().unbindEffect(),this._onUnBindObservable&&this._onUnBindObservable.notifyObservers(this),0!==this.depthFunction){this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState)}if(this.disableDepthWrite){this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState)}if(this.disableColorWrite){this._scene.getEngine().setColorWrite(this._cachedColorWriteState)}}getAnimatables(){return this._eventInfo.animatables=[],this._callbackPluginEventGeneric(256,this._eventInfo),this._eventInfo.animatables}getActiveTextures(){return this._eventInfo.activeTextures=[],this._callbackPluginEventGeneric(512,this._eventInfo),this._eventInfo.activeTextures}hasTexture(U){return this._eventInfo.hasTexture=!1,this._eventInfo.texture=U,this._callbackPluginEventGeneric(1024,this._eventInfo),this._eventInfo.hasTexture}clone(U){return null}_clonePlugins(U,G){const C={};if(this._serializePlugins(C),H._ParsePlugins(C,U,this._scene,G),this.pluginManager)for(const L of this.pluginManager._plugins){const G=U.pluginManager.getPlugin(L.name);G&&L.copyTo(G)}}getBindedMeshes(){if(this.meshMap){const U=[];for(const G in this.meshMap){const C=this.meshMap[G];C&&U.push(C)}return U}return this._scene.meshes.filter((U=>U.material===this))}forceCompilation(U,G,C,X){const l=(0,L.b)({clipPlane:!1,useInstances:!1},C),t=this.wU(),E=this.allowShaderHotSwapping;this.allowShaderHotSwapping=!1;const K=()=>{if(!this._scene||!this._scene.getEngine())return;const C=t.clipPlane;if(l.clipPlane&&(t.clipPlane=new D.b(0,0,0,1)),this._storeEffectOnSubMeshes){let C=!0,L=null;if(U.zE){const G=new P.e(0,0,0,0,0,U,void 0,!1,!1);G.materialDefines&&(G.materialDefines._renderId=-1),this.isReadyForSubMesh(U,G,l.useInstances)||(G.effect&&G.effect.getCompilationError()&&G.effect.allFallbacksProcessed()?L=G.effect.getCompilationError():(C=!1,setTimeout(K,16)))}C&&(this.allowShaderHotSwapping=E,L&&X&&X(L),G&&G(this))}else this.isReady()?(this.allowShaderHotSwapping=E,G&&G(this)):setTimeout(K,16);l.clipPlane&&(t.clipPlane=C)};K()}async forceCompilationAsync(U,G){return await new Promise(((C,L)=>{this.forceCompilation(U,(()=>{C()}),G,(U=>{L(U)}))}))}IO(U){this.wU().blockMaterialDirtyMechanism||this._blockDirtyMechanism||(H._DirtyCallbackArray.length=0,U&H.ImageProcessingDirtyFlag&&H._DirtyCallbackArray.push(H._ImageProcessingDirtyCallBack),U&H.TextureDirtyFlag&&H._DirtyCallbackArray.push(H._TextureDirtyCallBack),U&H.LightDirtyFlag&&H._DirtyCallbackArray.push(H._LightsDirtyCallBack),U&H.FresnelDirtyFlag&&H._DirtyCallbackArray.push(H._FresnelDirtyCallBack),U&H.AttributesDirtyFlag&&H._DirtyCallbackArray.push(H._AttributeDirtyCallBack),U&H.MiscDirtyFlag&&H._DirtyCallbackArray.push(H._MiscDirtyCallBack),U&H.PrePassDirtyFlag&&H._DirtyCallbackArray.push(H._PrePassDirtyCallBack),H._DirtyCallbackArray.length&&this._markAllSubMeshesAsDirty(H._RunDirtyCallBacks),this.wU().resetCachedMaterial())}resetDrawCache(){const U=this.wU().meshes;for(const G of U)if(G.zE)for(const U of G.zE)U.QU()===this&&U.resetDrawCache()}_markAllSubMeshesAsDirty(U){const G=this.wU();if(G.blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const C=G.meshes;for(const L of C)if(L.zE)for(const C of L.zE){if((C.QU()||(G._hasDefaultMaterial?G.defaultMaterial:null))===this)for(const G of C._drawWrappers)G&&G.defines&&G.defines.markAllAsDirty&&this._materialContext===G.materialContext&&U(G.defines)}}_markScenePrePassDirty(){if(this.wU().blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const U=this.wU().enablePrePassRenderer();U&&U.IO()}_markAllSubMeshesAsAllDirty(){this._markAllSubMeshesAsDirty(H._AllDirtyCallBack)}_markAllSubMeshesAsImageProcessingDirty(){this._markAllSubMeshesAsDirty(H._ImageProcessingDirtyCallBack)}_markAllSubMeshesAsTexturesDirty(){this._markAllSubMeshesAsDirty(H._TextureDirtyCallBack)}_markAllSubMeshesAsFresnelDirty(){this._markAllSubMeshesAsDirty(H._FresnelDirtyCallBack)}_markAllSubMeshesAsFresnelAndMiscDirty(){this._markAllSubMeshesAsDirty(H._FresnelAndMiscDirtyCallBack)}_markAllSubMeshesAsLightsDirty(){this._markAllSubMeshesAsDirty(H._LightsDirtyCallBack)}_markAllSubMeshesAsAttributesDirty(){this._markAllSubMeshesAsDirty(H._AttributeDirtyCallBack)}_markAllSubMeshesAsMiscDirty(){this._markAllSubMeshesAsDirty(H._MiscDirtyCallBack)}_markAllSubMeshesAsPrePassDirty(){this._markAllSubMeshesAsDirty(H._PrePassDirtyCallBack)}_markAllSubMeshesAsTexturesAndMiscDirty(){this._markAllSubMeshesAsDirty(H._TextureAndMiscDirtyCallBack)}_checkScenePerformancePriority(){if(0!==this._scene.performancePriority){this.checkReadyOnlyOnce=!0;const U=this._scene.onScenePerformancePriorityChangedObservable.addOnce((()=>{this.checkReadyOnlyOnce=!1}));this.aE.add((()=>{this._scene.onScenePerformancePriorityChangedObservable.remove(U)}))}}setPrePassRenderer(U){return!1}dispose(U,G,C){const L=this.wU();if(L.stopAnimation(this),L.freeProcessedMaterials(),L.removeMaterial(this),this._eventInfo.forceDisposeTextures=G,this._callbackPluginEventGeneric(2,this._eventInfo),this._parentContainer){const U=this._parentContainer.materials.indexOf(this);U>-1&&this._parentContainer.materials.splice(U,1),this._parentContainer=null}if(!0!==C)if(this.meshMap)for(const X in this.meshMap){const U=this.meshMap[X];this._disposeMeshResources(U)}else{const U=L.meshes;for(const G of U)this._disposeMeshResources(G)}this._uniformBuffer.dispose(),this._drawWrapper.effect&&(this._storeEffectOnSubMeshes||this._drawWrapper.effect.dispose(),this._drawWrapper.effect=null),this.metadata=null,this.aE.notifyObservers(this),this.aE.clear(),this._onBindObservable&&this._onBindObservable.clear(),this._onUnBindObservable&&this._onUnBindObservable.clear(),this._onEffectCreatedObservable&&this._onEffectCreatedObservable.clear(),this._eventInfo&&(this._eventInfo={})}_disposeMeshResources(U){if(!U)return;const G=U.iE,C=U._internalAbstractMeshDataInfo._materialForRenderPass;if(this._storeEffectOnSubMeshes){if(U.zE&&C)for(const X of U.zE){const U=X._drawWrappers;for(let l=0;l<U.length;l++){var L;const t=null===(L=U[l])||void 0===L?void 0:L.effect;if(!t)continue;C[l]===this&&(null===G||void 0===G||G._releaseVertexArrayObject(t),X._removeDrawWrapper(l,!0,!0))}}}else null===G||void 0===G||G._releaseVertexArrayObject(this._drawWrapper.effect);U.material!==this||U.sourceMesh||(U.material=null)}serialize(){const U=V.c.Serialize(this);return U.kE=this.kE.serialize(),U.uniqueId=this.uniqueId,this._serializePlugins(U),U}_serializePlugins(U){if(U.plugins={},this.pluginManager)for(const G of this.pluginManager._plugins)G.doNotSerialize||(U.plugins[G.getClassName()]=G.serialize())}static Parse(U,G,C){if(U.customType){if("BABYLON.PBRMaterial"===U.customType&&U.overloadedAlbedo&&(U.customType="BABYLON.LegacyPBRMaterial",!BABYLON.LegacyPBRMaterial))return T.d.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."),null}else U.customType="BABYLON.StandardMaterial";const L=t.Tools.Instantiate(U.customType).Parse(U,G,C);return L._loadedUniqueId=U.uniqueId,L}static _ParsePlugins(U,G,C,L){if(U.plugins)for(const E in U.plugins){var X,l;const K=U.plugins[E];let P=null===(X=G.pluginManager)||void 0===X?void 0:X.getPlugin(K.name);if(!P){const U=t.Tools.Instantiate("BABYLON."+E);U&&(P=new U(G))}null===(l=P)||void 0===l||l.parse(K,C,L)}}}H.TriangleFillMode=0,H.WireFrameFillMode=1,H.PointFillMode=2,H.PointListDrawMode=3,H.LineListDrawMode=4,H.LineLoopDrawMode=5,H.LineStripDrawMode=6,H.TriangleStripDrawMode=7,H.TriangleFanDrawMode=8,H.ClockWiseSideOrientation=0,H.CounterClockWiseSideOrientation=1,H.ImageProcessingDirtyFlag=64,H.TextureDirtyFlag=1,H.LightDirtyFlag=2,H.FresnelDirtyFlag=4,H.AttributesDirtyFlag=8,H.MiscDirtyFlag=16,H.PrePassDirtyFlag=32,H.AllDirtyFlag=127,H.MATERIAL_OPAQUE=0,H.MATERIAL_ALPHATEST=1,H.MATERIAL_ALPHABLEND=2,H.MATERIAL_ALPHATESTANDBLEND=3,H.MATERIAL_NORMALBLENDMETHOD_WHITEOUT=0,H.MATERIAL_NORMALBLENDMETHOD_RNM=1,H.OnEventObservable=new E.e,H._AllDirtyCallBack=U=>U.markAllAsDirty(),H._ImageProcessingDirtyCallBack=U=>U.markAsImageProcessingDirty(),H._TextureDirtyCallBack=U=>U.markAsTexturesDirty(),H._FresnelDirtyCallBack=U=>U.markAsFresnelDirty(),H._MiscDirtyCallBack=U=>U.markAsMiscDirty(),H._PrePassDirtyCallBack=U=>U.markAsPrePassDirty(),H._LightsDirtyCallBack=U=>U.markAsLightDirty(),H._AttributeDirtyCallBack=U=>U.markAsAttributesDirty(),H._FresnelAndMiscDirtyCallBack=U=>{H._FresnelDirtyCallBack(U),H._MiscDirtyCallBack(U)},H._TextureAndMiscDirtyCallBack=U=>{H._TextureDirtyCallBack(U),H._MiscDirtyCallBack(U)},H._DirtyCallbackArray=[],H._RunDirtyCallBacks=U=>{for(const G of H._DirtyCallbackArray)G(U)},(0,X.d)([(0,l.H)()],H.prototype,"id",void 0),(0,X.d)([(0,l.H)()],H.prototype,"uniqueId",void 0),(0,X.d)([(0,l.H)()],H.prototype,"name",void 0),(0,X.d)([(0,l.H)()],H.prototype,"metadata",void 0),(0,X.d)([(0,l.H)()],H.prototype,"checkReadyOnEveryCall",void 0),(0,X.d)([(0,l.H)()],H.prototype,"checkReadyOnlyOnce",void 0),(0,X.d)([(0,l.H)()],H.prototype,"state",void 0),(0,X.d)([(0,l.H)("alpha")],H.prototype,"_alpha",void 0),(0,X.d)([(0,l.H)("RE")],H.prototype,"_backFaceCulling",void 0),(0,X.d)([(0,l.H)("cullBackFaces")],H.prototype,"_cullBackFaces",void 0),(0,X.d)([(0,l.H)()],H.prototype,"sideOrientation",void 0),(0,X.d)([(0,l.H)("alphaMode")],H.prototype,"_alphaMode",void 0),(0,X.d)([(0,l.H)()],H.prototype,"_needDepthPrePass",void 0),(0,X.d)([(0,l.H)()],H.prototype,"disableDepthWrite",void 0),(0,X.d)([(0,l.H)()],H.prototype,"disableColorWrite",void 0),(0,X.d)([(0,l.H)()],H.prototype,"forceDepthWrite",void 0),(0,X.d)([(0,l.H)()],H.prototype,"depthFunction",void 0),(0,X.d)([(0,l.H)()],H.prototype,"separateCullingPass",void 0),(0,X.d)([(0,l.H)("fogEnabled")],H.prototype,"_fogEnabled",void 0),(0,X.d)([(0,l.H)()],H.prototype,"pointSize",void 0),(0,X.d)([(0,l.H)()],H.prototype,"zOffset",void 0),(0,X.d)([(0,l.H)()],H.prototype,"zOffsetUnits",void 0),(0,X.d)([(0,l.H)()],H.prototype,"pointsCloud",null),(0,X.d)([(0,l.H)()],H.prototype,"fillMode",null),(0,X.d)([(0,l.H)()],H.prototype,"useLogarithmicDepth",null),(0,X.d)([(0,l.H)()],H.prototype,"transparencyMode",null)},13217:(U,G,C)=>{C.d(G,{B:()=>h,F:()=>w,G:()=>S,K:()=>y,N:()=>D,R:()=>F,U:()=>Z,X:()=>d,_:()=>H,ab:()=>u,bb:()=>q,e:()=>N,eb:()=>a,h:()=>T,hb:()=>k,k:()=>o,kb:()=>Q,lb:()=>V,m:()=>O,o:()=>p,r:()=>I,v:()=>x,x:()=>v});var L=C(12731),X=C(12934),l=C(12763),t=C(13165),E=C(13224);const K=X.hG.Black(),P={NUM_MORPH_INFLUENCERS:0,NORMAL:!1,TANGENT:!1,UV:!1,UV2:!1,COLOR:!1};function O(U,G,C){if(!U||U.LOGARITHMICDEPTH||U.indexOf&&U.indexOf("LOGARITHMICDEPTH")>=0){const U=C.activeCamera;1===U.mode&&L.d.Error("Logarithmic depth is not compatible with orthographic cameras!",20),G.setFloat("logarithmicDepthConstant",2/(Math.log(U.maxZ+1)/Math.LN2))}}function T(U,G,C){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3];C&&U.fogEnabled&&(!G||G.applyFog)&&0!==U.fogMode&&(C.setFloat4("vFogInfos",U.fogMode,U.fogStart,U.fogEnd,U.fogDensity),L?(U.fogColor.toLinearSpaceToRef(K,U.getEngine().useExactSrgbConversions),C.setColor3("vFogColor",K)):C.setColor3("vFogColor",U.fogColor))}function D(U,G,C,L,X,l,t,E,K,O){const T=U.numMaxInfluencers||U.numInfluencers;return T<=0?0:(G.push("#define MORPHTARGETS"),U.hasPositions&&G.push("#define MORPHTARGETTEXTURE_HASPOSITIONS"),U.hasNormals&&G.push("#define MORPHTARGETTEXTURE_HASNORMALS"),U.hasTangents&&G.push("#define MORPHTARGETTEXTURE_HASTANGENTS"),U.hasUVs&&G.push("#define MORPHTARGETTEXTURE_HASUVS"),U.hasUV2s&&G.push("#define MORPHTARGETTEXTURE_HASUV2S"),U.hasColors&&G.push("#define MORPHTARGETTEXTURE_HASCOLORS"),U.supportsPositions&&X&&G.push("#define MORPHTARGETS_POSITION"),U.supportsNormals&&l&&G.push("#define MORPHTARGETS_NORMAL"),U.supportsTangents&&t&&G.push("#define MORPHTARGETS_TANGENT"),U.supportsUVs&&E&&G.push("#define MORPHTARGETS_UV"),U.supportsUV2s&&K&&G.push("#define MORPHTARGETS_UV2"),U.supportsColors&&O&&G.push("#define MORPHTARGETS_COLOR"),G.push("#define NUM_MORPH_INFLUENCERS "+T),U.isUsingTextureForTargets&&G.push("#define MORPHTARGETS_TEXTURE"),P.NUM_MORPH_INFLUENCERS=T,P.NORMAL=l,P.TANGENT=t,P.UV=E,P.UV2=K,P.COLOR=O,y(C,L,P,X),T)}function y(U,G,C){let X=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const t=C.NUM_MORPH_INFLUENCERS;if(t>0&&l.d.LastCreatedEngine){const E=l.d.LastCreatedEngine.getCaps().maxVertexAttribs,K=G.morphTargetManager;if(null!==K&&void 0!==K&&K.isUsingTextureForTargets)return;const P=K&&K.supportsPositions&&X,O=K&&K.supportsNormals&&C.NORMAL,T=K&&K.supportsTangents&&C.TANGENT,D=K&&K.supportsUVs&&C.UV1,y=K&&K.supportsUV2s&&C.UV2,V=K&&K.supportsColors&&C.VERTEXCOLOR;for(let C=0;C<t;C++)P&&U.push("position"+C),O&&U.push("normal"+C),T&&U.push("tangent"+C),D&&U.push("uv_"+C),y&&U.push("uv2_"+C),V&&U.push("color"+C),U.length>E&&L.d.Error("Cannot add more vertex attributes for mesh "+G.name)}}function V(U){let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1];U.push("world0"),U.push("world1"),U.push("world2"),U.push("world3"),G&&(U.push("previousWorld0"),U.push("previousWorld1"),U.push("previousWorld2"),U.push("previousWorld3"))}function p(U,G){const C=U.morphTargetManager;U&&C&&G.setFloatArray("morphTargetInfluences",C.influences)}function I(U,G){G.bindToEffect(U,"Scene")}function H(U,G,C){G._needUVs=!0,G[C]=!0,U.optimizeUVAllocation&&U.getTextureMatrix().isIdentityAs3x2()?(G[C+"DIRECTUV"]=U.coordinatesIndex+1,G["MAINUV"+(U.coordinatesIndex+1)]=!0):G[C+"DIRECTUV"]=0}function x(U,G,C){const L=U.getTextureMatrix();G.YE(C+"Matrix",L)}function h(U,G,C){C.BAKED_VERTEX_ANIMATION_TEXTURE&&C.INSTANCES&&U.push("bakedVertexAnimationSettingsInstanced")}function N(U,G,C){var L;if(G&&U&&(U.computeBonesUsingShaders&&G._bonesComputationForcedToCPU&&(U.computeBonesUsingShaders=!1),U.useBones&&U.computeBonesUsingShaders&&U.skeleton)){const X=U.skeleton;if(X.isUsingTextureForMatrices&&G.getUniformIndex("boneTextureWidth")>-1){const C=X.getTransformMatrixTexture(U);G.setTexture("boneSampler",C),G.setFloat("boneTextureWidth",4*(X.bones.length+1))}else{const l=X.getTransformMatrices(U);l&&(G.setMatrices("mBones",l),C&&U.wU().prePassRenderer&&U.wU().prePassRenderer.getIndex(2)&&(C.previousBones[U.uniqueId]||(C.previousBones[U.uniqueId]=l.slice()),G.setMatrices("mPreviousBones",C.previousBones[U.uniqueId]),L=l,C.previousBones[U.uniqueId].set(L)))}}}function b(U,G,C,L,X){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];U._bindLight(G,C,L,X,l)}function o(U,G,C,L){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Math.min(G.lightSources.length,X);for(let t=0;t<l;t++){b(G.lightSources[t],t,U,C,"boolean"===typeof L?L:L.SPECULARTERM,G.receiveShadows)}}function w(U,G,C,L){C.NUM_BONE_INFLUENCERS>0&&(L.addCPUSkinningFallback(0,G),U.push("matricesIndices"),U.push("matricesWeights"),C.NUM_BONE_INFLUENCERS>4&&(U.push("matricesIndicesExtra"),U.push("matricesWeightsExtra")))}function S(U,G){(G.INSTANCES||G.THIN_INSTANCES)&&V(U,!!G.PREPASS_VELOCITY),G.INSTANCESCOLOR&&U.push("instanceColor")}function v(U,G){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:4,L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,X=0;for(let l=0;l<C&&U["LIGHT"+l];l++)l>0&&(X=L+l,G.addFallback(X,"LIGHT"+l)),U.SHADOWS||(U["SHADOW"+l]&&G.addFallback(L,"SHADOW"+l),U["SHADOWPCF"+l]&&G.addFallback(L,"SHADOWPCF"+l),U["SHADOWPCSS"+l]&&G.addFallback(L,"SHADOWPCSS"+l),U["SHADOWPOISSON"+l]&&G.addFallback(L,"SHADOWPOISSON"+l),U["SHADOWESM"+l]&&G.addFallback(L,"SHADOWESM"+l),U["SHADOWCLOSEESM"+l]&&G.addFallback(L,"SHADOWCLOSEESM"+l));return X++}function u(U,G,C,L,X,l,t){let E=arguments.length>7&&void 0!==arguments[7]&&arguments[7];t._areMiscDirty&&(t.LOGARITHMICDEPTH=C,t.POINTSIZE=L,t.FOG=X&&function(U,G){return G.fogEnabled&&U.applyFog&&0!==G.fogMode}(U,G),t.NONUNIFORMSCALING=U.nonUniformScaling,t.ALPHATEST=l,t.DECAL_AFTER_DETAIL=E)}function d(U,G,C,L){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4,l=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(!C._areLightsDirty)return C._needNormals;let t=0;const E={needNormals:C._needNormals,needRebuild:!1,lightmapMode:!1,shadowEnabled:!1,specularEnabled:!1};if(U.lightsEnabled&&!l)for(const P of G.lightSources)if(g(U,G,P,t,C,L,E),t++,t===X)break;C.SPECULARTERM=E.specularEnabled,C.SHADOWS=E.shadowEnabled;for(let P=t;P<X;P++)void 0!==C["LIGHT"+P]&&(C["LIGHT"+P]=!1,C["HEMILIGHT"+P]=!1,C["POINTLIGHT"+P]=!1,C["DIRLIGHT"+P]=!1,C["SPOTLIGHT"+P]=!1,C["AREALIGHT"+P]=!1,C["SHADOW"+P]=!1,C["SHADOWCSM"+P]=!1,C["SHADOWCSMDEBUG"+P]=!1,C["SHADOWCSMNUM_CASCADES"+P]=!1,C["SHADOWCSMUSESHADOWMAXZ"+P]=!1,C["SHADOWCSMNOBLEND"+P]=!1,C["SHADOWCSM_RIGHTHANDED"+P]=!1,C["SHADOWPCF"+P]=!1,C["SHADOWPCSS"+P]=!1,C["SHADOWPOISSON"+P]=!1,C["SHADOWESM"+P]=!1,C["SHADOWCLOSEESM"+P]=!1,C["SHADOWCUBE"+P]=!1,C["SHADOWLOWQUALITY"+P]=!1,C["SHADOWMEDIUMQUALITY"+P]=!1);const K=U.getEngine().getCaps();return void 0===C.SHADOWFLOAT&&(E.needRebuild=!0),C.SHADOWFLOAT=E.shadowEnabled&&(K.textureFloatRender&&K.textureFloatLinearFiltering||K.textureHalfFloatRender&&K.textureHalfFloatLinearFiltering),C.LIGHTMAPEXCLUDED=E.lightmapMode,E.needRebuild&&C.rebuild(),E.needNormals}function g(U,G,C,L,X,l,E){switch(E.needNormals=!0,void 0===X["LIGHT"+L]&&(E.needRebuild=!0),X["LIGHT"+L]=!0,X["SPOTLIGHT"+L]=!1,X["HEMILIGHT"+L]=!1,X["POINTLIGHT"+L]=!1,X["DIRLIGHT"+L]=!1,X["AREALIGHT"+L]=!1,C.prepareLightSpecificDefines(X,L),X["LIGHT_FALLOFF_PHYSICAL"+L]=!1,X["LIGHT_FALLOFF_GLTF"+L]=!1,X["LIGHT_FALLOFF_STANDARD"+L]=!1,C.falloffType){case t.b.FALLOFF_GLTF:X["LIGHT_FALLOFF_GLTF"+L]=!0;break;case t.b.FALLOFF_PHYSICAL:X["LIGHT_FALLOFF_PHYSICAL"+L]=!0;break;case t.b.FALLOFF_STANDARD:X["LIGHT_FALLOFF_STANDARD"+L]=!0}if(l&&!C.jO.equalsFloats(0,0,0)&&(E.specularEnabled=!0),X["SHADOW"+L]=!1,X["SHADOWCSM"+L]=!1,X["SHADOWCSMDEBUG"+L]=!1,X["SHADOWCSMNUM_CASCADES"+L]=!1,X["SHADOWCSMUSESHADOWMAXZ"+L]=!1,X["SHADOWCSMNOBLEND"+L]=!1,X["SHADOWCSM_RIGHTHANDED"+L]=!1,X["SHADOWPCF"+L]=!1,X["SHADOWPCSS"+L]=!1,X["SHADOWPOISSON"+L]=!1,X["SHADOWESM"+L]=!1,X["SHADOWCLOSEESM"+L]=!1,X["SHADOWCUBE"+L]=!1,X["SHADOWLOWQUALITY"+L]=!1,X["SHADOWMEDIUMQUALITY"+L]=!1,G&&G.receiveShadows&&U.shadowsEnabled&&C.shadowEnabled){var K;const G=null!==(K=C.getShadowGenerator(U.activeCamera))&&void 0!==K?K:C.getShadowGenerator();if(G){const U=G.getShadowMap();U&&U.renderList&&U.renderList.length>0&&(E.shadowEnabled=!0,G.prepareDefines(X,L))}}C.lightmapMode!=t.b.LIGHTMAP_DEFAULT?(E.lightmapMode=!0,X["LIGHTMAPEXCLUDED"+L]=!0,X["LIGHTMAPNOSPECULAR"+L]=C.lightmapMode==t.b.LIGHTMAP_SHADOWSONLY):(X["LIGHTMAPEXCLUDED"+L]=!1,X["LIGHTMAPNOSPECULAR"+L]=!1)}function Z(U,G,C,L,X){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,t=arguments.length>6&&void 0!==arguments[6]&&arguments[6],K=function(U,G){let C=!1;if(U.activeCamera){const L=G.CAMERA_ORTHOGRAPHIC?1:0,X=G.CAMERA_PERSPECTIVE?1:0,l=1===U.activeCamera.mode?1:0,t=0===U.activeCamera.mode?1:0;(L^l||X^t)&&(G.CAMERA_ORTHOGRAPHIC=1===l,G.CAMERA_PERSPECTIVE=1===t,C=!0)}return C}(U,L);!1!==l&&(K=(0,E.f)(C,U,L)),L.DEPTHPREPASS!==!G.getColorWrite()&&(L.DEPTHPREPASS=!L.DEPTHPREPASS,K=!0),L.INSTANCES!==X&&(L.INSTANCES=X,K=!0),L.THIN_INSTANCES!==t&&(L.THIN_INSTANCES=t,K=!0),K&&L.markAsUnprocessed()}function F(U,G,C,L){let X=arguments.length>4&&void 0!==arguments[4]&&arguments[4],l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],t=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(!G._areAttributesDirty&&G._needNormals===G._normals&&G._needUVs===G._uvs)return!1;G._normals=G._needNormals,G._uvs=G._needUVs,G.NORMAL=G._needNormals&&U.isVerticesDataPresent("normal"),G._needNormals&&U.isVerticesDataPresent("tangent")&&(G.TANGENT=!0);for(let E=1;E<=6;++E)G["UV"+E]=!!G._needUVs&&U.isVerticesDataPresent("uv".concat(1===E?"":E));if(C){const C=U.useVertexColors&&U.isVerticesDataPresent("color");G.VERTEXCOLOR=C,G.VERTEXALPHA=U.hasVertexAlpha&&C&&l}return U.isVerticesDataPresent("instanceColor")&&(U.hasInstances||U.hasThinInstances)&&(G.INSTANCESCOLOR=!0),L&&function(U,G){if(U.useBones&&U.computeBonesUsingShaders&&U.skeleton){G.NUM_BONE_INFLUENCERS=U.numBoneInfluencers;const C=void 0!==G.BONETEXTURE;if(U.skeleton.isUsingTextureForMatrices&&C)G.BONETEXTURE=!0;else{G.BonesPerMesh=U.skeleton.bones.length+1,G.BONETEXTURE=!C&&void 0;const L=U.wU().prePassRenderer;if(L&&L.enabled){const C=-1===L.excludedSkinnedMesh.indexOf(U);G.BONES_VELOCITY_ENABLED=C}}}else G.NUM_BONE_INFLUENCERS=0,G.BonesPerMesh=0,void 0!==G.BONETEXTURE&&(G.BONETEXTURE=!1)}(U,G),X&&function(U,G){const C=U.morphTargetManager;C?(G.MORPHTARGETS_UV=C.supportsUVs&&G.UV1,G.MORPHTARGETS_UV2=C.supportsUV2s&&G.UV2,G.MORPHTARGETS_TANGENT=C.supportsTangents&&G.TANGENT,G.MORPHTARGETS_NORMAL=C.supportsNormals&&G.NORMAL,G.MORPHTARGETS_POSITION=C.supportsPositions,G.MORPHTARGETS_COLOR=C.supportsColors,G.MORPHTARGETTEXTURE_HASUVS=C.hasUVs,G.MORPHTARGETTEXTURE_HASUV2S=C.hasUV2s,G.MORPHTARGETTEXTURE_HASTANGENTS=C.hasTangents,G.MORPHTARGETTEXTURE_HASNORMALS=C.hasNormals,G.MORPHTARGETTEXTURE_HASPOSITIONS=C.hasPositions,G.MORPHTARGETTEXTURE_HASCOLORS=C.hasColors,G.NUM_MORPH_INFLUENCERS=C.numMaxInfluencers||C.numInfluencers,G.MORPHTARGETS=G.NUM_MORPH_INFLUENCERS>0,G.MORPHTARGETS_TEXTURE=C.isUsingTextureForTargets):(G.MORPHTARGETS_UV=!1,G.MORPHTARGETS_UV2=!1,G.MORPHTARGETS_TANGENT=!1,G.MORPHTARGETS_NORMAL=!1,G.MORPHTARGETS_POSITION=!1,G.MORPHTARGETS_COLOR=!1,G.MORPHTARGETTEXTURE_HASUVS=!1,G.MORPHTARGETTEXTURE_HASUV2S=!1,G.MORPHTARGETTEXTURE_HASTANGENTS=!1,G.MORPHTARGETTEXTURE_HASNORMALS=!1,G.MORPHTARGETTEXTURE_HASPOSITIONS=!1,G.MORPHTARGETTEXTURE_HAS_COLORS=!1,G.MORPHTARGETS=!1,G.NUM_MORPH_INFLUENCERS=0)}(U,G),t&&function(U,G){const C=U.bakedVertexAnimationManager;G.BAKED_VERTEX_ANIMATION_TEXTURE=!(!C||!C.isEnabled)}(U,G),!0}function q(U,G){if(U.activeCamera){const C=G.MULTIVIEW;G.MULTIVIEW=null!==U.activeCamera.outputRenderTarget&&U.activeCamera.outputRenderTarget.getViewCount()>1,G.MULTIVIEW!=C&&G.markAsUnprocessed()}}function a(U,G,C){const L=G.ORDER_INDEPENDENT_TRANSPARENCY,X=G.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;G.ORDER_INDEPENDENT_TRANSPARENCY=U.useOrderIndependentTransparency&&C,G.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!U.getEngine().getCaps().textureFloatLinearFiltering,L===G.ORDER_INDEPENDENT_TRANSPARENCY&&X===G.ORDER_INDEPENDENT_TRANSPARENCY_16BITS||G.markAsUnprocessed()}function k(U,G,C){const L=G.PREPASS;if(!G._arePrePassDirty)return;const X=[{type:1,define:"PREPASS_POSITION",index:"PREPASS_POSITION_INDEX"},{type:9,define:"PREPASS_LOCAL_POSITION",index:"PREPASS_LOCAL_POSITION_INDEX"},{type:2,define:"PREPASS_VELOCITY",index:"PREPASS_VELOCITY_INDEX"},{type:11,define:"PREPASS_VELOCITY_LINEAR",index:"PREPASS_VELOCITY_LINEAR_INDEX"},{type:3,define:"PREPASS_REFLECTIVITY",index:"PREPASS_REFLECTIVITY_INDEX"},{type:0,define:"PREPASS_IRRADIANCE",index:"PREPASS_IRRADIANCE_INDEX"},{type:7,define:"PREPASS_ALBEDO_SQRT",index:"PREPASS_ALBEDO_SQRT_INDEX"},{type:5,define:"PREPASS_DEPTH",index:"PREPASS_DEPTH_INDEX"},{type:10,define:"PREPASS_SCREENSPACE_DEPTH",index:"PREPASS_SCREENSPACE_DEPTH_INDEX"},{type:6,define:"PREPASS_NORMAL",index:"PREPASS_NORMAL_INDEX"},{type:8,define:"PREPASS_WORLD_NORMAL",index:"PREPASS_WORLD_NORMAL_INDEX"}];if(U.prePassRenderer&&U.prePassRenderer.enabled&&C){G.PREPASS=!0,G.SCENE_MRT_COUNT=U.prePassRenderer.mrtCount,G.PREPASS_NORMAL_WORLDSPACE=U.prePassRenderer.generateNormalsInWorldSpace,G.PREPASS_COLOR=!0,G.PREPASS_COLOR_INDEX=0;for(let C=0;C<X.length;C++){const L=U.prePassRenderer.getIndex(X[C].type);-1!==L?(G[X[C].define]=!0,G[X[C].index]=L):G[X[C].define]=!1}}else{G.PREPASS=!1;for(let U=0;U<X.length;U++)G[X[U].define]=!1}G.PREPASS!=L&&(G.markAsUnprocessed(),G.markAsImageProcessingDirty())}function n(U,G,C,L){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,l=arguments.length>5&&void 0!==arguments[5]&&arguments[5],t=arguments.length>6&&void 0!==arguments[6]&&arguments[6];X&&X.push("Light"+U),l||(G.push("vLightData"+U,"vLightDiffuse"+U,"vLightSpecular"+U,"vLightDirection"+U,"vLightWidth"+U,"vLightHeight"+U,"vLightFalloff"+U,"vLightGround"+U,"lightMatrix"+U,"shadowsInfo"+U,"depthValues"+U),C.push("shadowTexture"+U),C.push("depthTexture"+U),G.push("viewFrustumZ"+U,"cascadeBlendFactor"+U,"lightSizeUVCorrection"+U,"depthCorrection"+U,"penumbraDarkness"+U,"frustumLengths"+U),L&&(C.push("projectionLightTexture"+U),G.push("textureProjectionMatrix"+U)),t&&C.push("iesLightTexture"+U))}function Q(U,G,C){let L,X,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:4;if(U.uniformsNames){const t=U;L=t.uniformsNames,X=t.uniformBuffersNames,G=t.samplers,C=t.defines,l=t.maxSimultaneousLights||0}else L=U,G||(G=[]);for(let t=0;t<l&&C["LIGHT"+t];t++)n(t,L,G,C["PROJECTEDLIGHTTEXTURE"+t],X,!1,C["IESLIGHTTEXTURE"+t]);C.NUM_MORPH_INFLUENCERS&&(L.push("morphTargetInfluences"),L.push("morphTargetCount")),C.BAKED_VERTEX_ANIMATION_TEXTURE&&(L.push("bakedVertexAnimationSettings"),L.push("bakedVertexAnimationTextureSizeInverted"),L.push("bakedVertexAnimationTime"),G.push("bakedVertexAnimationTexture"))}},13175:(U,G,C)=>{C.d(G,{c:()=>l});var L=C(12896),X=C(13178);class l extends X.c{constructor(U,G){let C=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(U,G,void 0,arguments.length>3&&void 0!==arguments[3]&&arguments[3]),this._normalMatrix=new L.Matrix,this._storeEffectOnSubMeshes=C}getEffect(){return this._storeEffectOnSubMeshes?this._activeEffect:super.getEffect()}isReady(U,G){return!!U&&(!this._storeEffectOnSubMeshes||(!U.zE||0===U.zE.length||this.isReadyForSubMesh(U,U.zE[0],G)))}_isReadyForSubMesh(U){const G=U.materialDefines;return!(this.checkReadyOnEveryCall||!U.effect||!G||G._renderId!==this.wU().getRenderId())}bindOnlyWorldMatrix(U){this._activeEffect.setMatrix("world",U)}bindOnlyNormalMatrix(U){this._activeEffect.setMatrix("normalMatrix",U)}bind(U,G){G&&this.bindForSubMesh(U,G,G.zE[0])}_afterBind(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,C=arguments.length>2?arguments[2]:void 0;super._afterBind(U,G,C),this.wU()._cachedEffect=G,C?C._drawWrapper._forceRebindOnNextCall=!1:this._drawWrapper._forceRebindOnNextCall=!1}_mustRebind(U,G,C){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return C._drawWrapper._forceRebindOnNextCall||U.isCachedMaterialInvalid(this,G,L)}dispose(U,G,C){this._activeEffect=void 0,super.dispose(U,G,C)}}},13211:(U,G,C)=>{C.d(G,{e:()=>E,h:()=>K});var L=C(12876),X=C(12896),l=C(12884);class t{static extractMinAndMaxIndexed(U,G,C,L,X,l){for(let t=C;t<C+L;t++){const C=3*G[t],L=U[C],E=U[C+1],K=U[C+2];X.minimizeInPlaceFromFloats(L,E,K),l.maximizeInPlaceFromFloats(L,E,K)}}static extractMinAndMax(U,G,C,L,X,l){for(let t=G,E=G*L;t<G+C;t++,E+=L){const G=U[E],C=U[E+1],L=U[E+2];X.minimizeInPlaceFromFloats(G,C,L),l.maximizeInPlaceFromFloats(G,C,L)}}}function E(U,G,C,L){let l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const E=new X.pG(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),K=new X.pG(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return t.extractMinAndMaxIndexed(U,G,C,L,E,K),l&&(E.x-=E.x*l.x+l.y,E.y-=E.y*l.x+l.y,E.z-=E.z*l.x+l.y,K.x+=K.x*l.x+l.y,K.y+=K.y*l.x+l.y,K.z+=K.z*l.x+l.y),{minimum:E,maximum:K}}function K(U,G,C){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,l=arguments.length>4?arguments[4]:void 0;const E=new X.pG(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),K=new X.pG(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return l||(l=3),t.extractMinAndMax(U,G,C,l,E,K),L&&(E.x-=E.x*L.x+L.y,E.y-=E.y*L.x+L.y,E.z-=E.z*L.x+L.y,K.x+=K.x*L.x+L.y,K.y+=K.y*L.x+L.y,K.z+=K.z*L.x+L.y),{minimum:E,maximum:K}}(0,L.d)([l.e.filter((function(){for(var U=arguments.length,G=new Array(U),C=0;C<U;C++)G[C]=arguments[C];let[L,X]=G;return!Array.isArray(L)&&!Array.isArray(X)}))],t,"extractMinAndMaxIndexed",null),(0,L.d)([l.e.filter((function(){for(var U=arguments.length,G=new Array(U),C=0;C<U;C++)G[C]=arguments[C];let[L]=G;return!Array.isArray(L)}))],t,"extractMinAndMax",null)},13184:(U,G,C)=>{C.d(G,{e:()=>K});var L=C(12957),X=C(13190),l=C(13192),t=C(13211),E=C(13003);class K{get materialDefines(){var U;return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.defines:null===(U=this._getDrawWrapper())||void 0===U?void 0:U.defines}set materialDefines(U){var G;(null!==(G=this._mainDrawWrapperOverride)&&void 0!==G?G:this._getDrawWrapper(void 0,!0)).defines=U}_getDrawWrapper(U){var G;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1];U=null!==(G=U)&&void 0!==G?G:this._engine.currentRenderPassId;let L=this._drawWrappers[U];return!L&&C&&(this._drawWrappers[U]=L=new E.e(this._mesh.wU().getEngine())),L}_removeDrawWrapper(U){let G=arguments.length>2&&void 0!==arguments[2]&&arguments[2];var C;arguments.length>1&&void 0!==arguments[1]&&!arguments[1]||(null===(C=this._drawWrappers[U])||void 0===C||C.dispose(G));this._drawWrappers[U]=void 0}get effect(){var U,G;return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.effect:null!==(U=null===(G=this._getDrawWrapper())||void 0===G?void 0:G.effect)&&void 0!==U?U:null}get _drawWrapper(){var U;return null!==(U=this._mainDrawWrapperOverride)&&void 0!==U?U:this._getDrawWrapper(void 0,!0)}get _drawWrapperOverride(){return this._mainDrawWrapperOverride}_setMainDrawWrapperOverride(U){this._mainDrawWrapperOverride=U}setEffect(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,C=arguments.length>2?arguments[2]:void 0,L=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const X=this._drawWrapper;X.setEffect(U,G,L),void 0!==C&&(X.materialContext=C),U||(X.defines=null,X.materialContext=void 0)}resetDrawCache(U){let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this._drawWrappers){if(void 0!==U)return void this._removeDrawWrapper(U,!0,G);for(const U of this._drawWrappers)null===U||void 0===U||U.dispose(G)}this._drawWrappers=[]}static AddToMesh(U,G,C,L,X,l,t){return new K(U,G,C,L,X,l,t,!(arguments.length>7&&void 0!==arguments[7])||arguments[7])}constructor(U,G,C,L,X,l,t){let E=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],K=!(arguments.length>8&&void 0!==arguments[8])||arguments[8];this.materialIndex=U,this.verticesStart=G,this.verticesCount=C,this.indexStart=L,this.indexCount=X,this._mainDrawWrapperOverride=null,this._linesIndexCount=0,this._linesIndexBuffer=null,this._lastColliderWorldVertices=null,this._lastColliderTransformMatrix=null,this._wasDispatched=!1,this._renderId=0,this._alphaIndex=0,this._distanceToCamera=0,this._currentMaterial=null,this._mesh=l,this._renderingMesh=t||l,K&&l.zE.push(this),this._engine=this._mesh.wU().getEngine(),this.resetDrawCache(),this._trianglePlanes=[],this._id=l.zE.length-1,E&&(this.refreshBoundingInfo(),l.eE(!0))}get IsGlobal(){return 0===this.verticesStart&&this.verticesCount===this._mesh.getTotalVertices()&&0===this.indexStart&&this.indexCount===this._mesh.getTotalIndices()}getBoundingInfo(){return this.IsGlobal||this._mesh.hasThinInstances?this._mesh.getBoundingInfo():this._boundingInfo}setBoundingInfo(U){return this._boundingInfo=U,this}getMesh(){return this._mesh}getRenderingMesh(){return this._renderingMesh}getReplacementMesh(){return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null}getEffectiveMesh(){const U=this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null;return U||this._renderingMesh}QU(){var U;let G=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];const C=null!==(U=this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId))&&void 0!==U?U:this._renderingMesh.material;if(!C)return G&&this._mesh.wU()._hasDefaultMaterial?this._mesh.wU().defaultMaterial:null;if(this._isMultiMaterial(C)){const U=C.getSubMaterial(this.materialIndex);return this._currentMaterial!==U&&(this._currentMaterial=U,this.resetDrawCache()),U}return C}_isMultiMaterial(U){return void 0!==U.getSubMaterial}refreshBoundingInfo(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(this._lastColliderWorldVertices=null,this.IsGlobal||!this._renderingMesh||!this._renderingMesh.iE)return this;if(U||(U=this._renderingMesh.getVerticesData(L.e.PositionKind)),!U)return this._boundingInfo=this._mesh.getBoundingInfo(),this;const G=this._renderingMesh.cE();let C;if(0===this.indexStart&&this.indexCount===G.length){const U=this._renderingMesh.getBoundingInfo();C={minimum:U.minimum.clone(),maximum:U.maximum.clone()}}else C=(0,t.e)(U,G,this.indexStart,this.indexCount,this._renderingMesh.iE.boundingBias);return this._boundingInfo?this._boundingInfo.reConstruct(C.minimum,C.maximum):this._boundingInfo=new l.c(C.minimum,C.maximum),this}_checkCollision(U){return this.getBoundingInfo()._checkCollision(U)}updateBoundingInfo(U){let G=this.getBoundingInfo();return G||(this.refreshBoundingInfo(),G=this.getBoundingInfo()),G&&G.update(U),this}isInFrustum(U){const G=this.getBoundingInfo();return!!G&&G.isInFrustum(U,this._mesh.zT)}isCompletelyInFrustum(U){const G=this.getBoundingInfo();return!!G&&G.isCompletelyInFrustum(U)}render(U){return this._renderingMesh.render(this,U,this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:void 0),this}_getLinesIndexBuffer(U,G){if(!this._linesIndexBuffer){const C=6*Math.floor(this.indexCount/3),L=this.verticesStart+this.verticesCount>65535?new Uint32Array(C):new Uint16Array(C);let X=0;if(0===U.length)for(let U=this.indexStart;U<this.indexStart+this.indexCount;U+=3)L[X++]=U,L[X++]=U+1,L[X++]=U+1,L[X++]=U+2,L[X++]=U+2,L[X++]=U;else for(let G=this.indexStart;G<this.indexStart+this.indexCount;G+=3)L[X++]=U[G],L[X++]=U[G+1],L[X++]=U[G+1],L[X++]=U[G+2],L[X++]=U[G+2],L[X++]=U[G];this._linesIndexBuffer=G.createIndexBuffer(L),this._linesIndexCount=L.length}return this._linesIndexBuffer}canIntersects(U){const G=this.getBoundingInfo();return!!G&&U.intersectsBox(G.boundingBox)}intersects(U,G,C,L,X){const l=this.QU();if(!l)return null;let t=3,E=!1;switch(l.fillMode){case 3:case 5:case 6:case 8:return null;case 7:t=1,E=!0}return 4===l.fillMode?C.length?this._intersectLines(U,G,C,this._mesh.intersectionThreshold,L):this._intersectUnIndexedLines(U,G,C,this._mesh.intersectionThreshold,L):!C.length&&this._mesh._unIndexed?this._intersectUnIndexedTriangles(U,G,C,L,X):this._intersectTriangles(U,G,C,t,E,L,X)}_intersectLines(U,G,C,L,l){let t=null;for(let E=this.indexStart;E<this.indexStart+this.indexCount;E+=2){const K=G[C[E]],P=G[C[E+1]],O=U.intersectionSegment(K,P,L);if(!(O<0)&&((l||!t||O<t.distance)&&(t=new X.b(null,null,O),t.faceId=E/2,l)))break}return t}_intersectUnIndexedLines(U,G,C,L,l){let t=null;for(let E=this.verticesStart;E<this.verticesStart+this.verticesCount;E+=2){const C=G[E],K=G[E+1],P=U.intersectionSegment(C,K,L);if(!(P<0)&&((l||!t||P<t.distance)&&(t=new X.b(null,null,P),t.faceId=E/2,l)))break}return t}_intersectTriangles(U,G,C,L,X,l,t){let E=null,K=-1;for(let P=this.indexStart;P<this.indexStart+this.indexCount-(3-L);P+=L){K++;const L=C[P],O=C[P+1],T=C[P+2];if(X&&4294967295===T){P+=2;continue}const D=G[L],y=G[O],V=G[T];if(!D||!y||!V)continue;if(t&&!t(D,y,V,U,L,O,T))continue;const p=U.intersectsTriangle(D,y,V);if(p){if(p.distance<0)continue;if((l||!E||p.distance<E.distance)&&(E=p,E.faceId=K,l))break}}return E}_intersectUnIndexedTriangles(U,G,C,L,X){let l=null;for(let t=this.verticesStart;t<this.verticesStart+this.verticesCount;t+=3){const C=G[t],E=G[t+1],K=G[t+2];if(X&&!X(C,E,K,U,-1,-1,-1))continue;const P=U.intersectsTriangle(C,E,K);if(P){if(P.distance<0)continue;if((L||!l||P.distance<l.distance)&&(l=P,l.faceId=t/3,L))break}}return l}_rebuild(){this._linesIndexBuffer&&(this._linesIndexBuffer=null)}clone(U,G){const C=new K(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,U,G,!1);if(!this.IsGlobal){const U=this.getBoundingInfo();if(!U)return C;C._boundingInfo=new l.c(U.minimum,U.maximum)}return C}dispose(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this._linesIndexBuffer&&(this._mesh.wU().getEngine()._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=null);const G=this._mesh.zE.indexOf(this);this._mesh.zE.splice(G,1),this.resetDrawCache(void 0,U)}getClassName(){return"SubMesh"}static CreateFromIndices(U,G,C,L,X){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],t=Number.MAX_VALUE,E=-Number.MAX_VALUE;const P=(X||L).cE();for(let K=G;K<G+C;K++){const U=P[K];U<t&&(t=U),U>E&&(E=U)}return new K(U,t,E-t+1,G,C,L,X,l)}}}}]);