"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[24],{12665:(x,O,Q)=>{Q.d(O,{e:()=>a,h:()=>g,l:()=>G,n:()=>k});var X=Q(10894),Z=Q(10849),n=Q(10889),V=Q(11298),o=Q(10994),l=Q(11323),C=(Q(11423),Q(11361)),U=Q(10905);Q(11411),Q(11387),Q(11496);const L="image/png",h=2,N=[134,22,135,150,246,214,150,54];function a(x){const O=new DataView(x.buffer,x.byteOffset,x.byteLength);let Q=0;for(let V=0;V<N.length;V++)if(O.getUint8(Q++)!==N[V])return U.e.Error("Not a babylon environment map"),null;let X="",Z=0;for(;Z=O.getUint8(Q++);)X+=String.fromCharCode(Z);let n=JSON.parse(X);return n=K(n),n.binaryDataPosition=Q,n.iC&&(n.iC.lodGenerationScale=n.iC.lodGenerationScale||.8),n}function K(x){if(x.version>h)throw new Error(`Unsupported babylon environment map version "${x.version}". Latest supported version is "${h}".`);return 2===x.version?x:x={...x,version:2,imageType:L}}function M(x,O){const Q=(O=K(O)).iC;let X=Math.log2(O.width);if(X=Math.round(X)+1,Q.mipmaps.length!==6*X)throw new Error(`Unsupported specular mipmaps number "${Q.mipmaps.length}"`);const Z=new Array(X);for(let n=0;n<X;n++){Z[n]=new Array(6);for(let X=0;X<6;X++){const V=Q.mipmaps[6*n+X];Z[n][X]=new Uint8Array(x.buffer,x.byteOffset+O.binaryDataPosition+V.position,V.length)}}return Z}function Y(x,O){var Q;O=K(O);const X=new Array(6),Z=null===(Q=O.irradiance)||void 0===Q?void 0:Q.irradianceTexture;if(Z){if(6!==Z.faces.length)throw new Error(`Incorrect irradiance texture faces number "${Z.faces.length}"`);for(let Q=0;Q<6;Q++){const n=Z.faces[Q];X[Q]=new Uint8Array(x.buffer,x.byteOffset+O.binaryDataPosition+n.position,n.length)}}return X}function g(x,O,Q){var X;const n=(Q=K(Q)).iC;if(!n)return Promise.resolve([]);x._lodGenerationScale=n.lodGenerationScale;const V=[],o=M(O,Q);V.push(R(x,o,Q.imageType));const l=null===(X=Q.irradiance)||void 0===X?void 0:X.irradianceTexture;if(l){var C,U;const X=Y(O,Q);let n=null;null!==(C=Q.irradiance)&&void 0!==C&&null!==(U=C.irradianceTexture)&&void 0!==U&&U.dominantDirection&&(n=Z.n.Xo(Q.irradiance.irradianceTexture.dominantDirection)),V.push(s(x,X,l.size,Q.imageType,n))}return Promise.all(V)}async function v(x,O,Q,X,Z,n,V,o,l,C,U){return await new Promise(((L,h)=>{if(Q){const Q=O.createTexture(null,!0,!0,null,1,null,(x=>{h(x)}),x);null===X||void 0===X||X.onEffectCreatedObservable.addOnce((o=>{o.executeWhenCompiled((()=>{X.externalTextureSamplerBinding=!0,X.onApply=X=>{X._bindTexture("textureSampler",Q),X.setFloat2("scale",1,O._features.needsInvertingBitmap&&x instanceof ImageBitmap?-1:1)},O.scenes.length&&(O.scenes[0].postProcessManager.directRender([X],C,!0,n,V),O.restoreDefaultFramebuffer(),Q.dispose(),URL.revokeObjectURL(Z),L())}))}))}else{if(O._uploadImageToTexture(U,x,n,V),o){const Q=l[V];Q&&O._uploadImageToTexture(Q._texture,x,n,0)}L()}}))}async function R(x,O){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:L;const X=x.getEngine();x.format=5,x.type=0,x.generateMipMaps=!0,x._cachedAnisotropicFilteringLevel=null,X.updateTextureSamplingMode(3,x),await q(x,O,!0,Q),x.isReady=!0}async function s(x,O,Q){let X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L,Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const n=x.getEngine(),V=new o.e(n,5),C=new l.b(n,V);x._irradianceTexture=C,C._dominantDirection=Z,V.isCube=!0,V.format=5,V.type=0,V.generateMipMaps=!0,V._cachedAnisotropicFilteringLevel=null,V.generateMipMaps=!0,V.width=Q,V.height=Q,n.updateTextureSamplingMode(3,V),await q(V,[O],!1,X),n.generateMipMapsForCubemap(V),V.isReady=!0}async function q(x,O,Z){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L;if(!X.g.IsExponentOfTwo(x.width))throw new Error("Texture size must be a power of two");const U=(0,n.ILog2)(x.width)+1,h=x.getEngine();let N=!1,a=!1,K=null,M=null,Y=null;const g=h.getCaps();g.textureLOD?h._features.supportRenderAndCopyToLodForFloatTextures?g.textureHalfFloatRender&&g.textureHalfFloatLinearFiltering?(N=!0,x.type=2):g.textureFloatRender&&g.textureFloatLinearFiltering&&(N=!0,x.type=1):N=!1:(N=!1,a=Z);let R=0;if(N)h.isWebGPU?(R=1,await Q.e(21).then(Q.bind(Q,13536))):await Q.e(14).then(Q.bind(Q,13541)),K=new C.e("rgbdDecode","rgbdDecode",null,null,1,null,3,h,!1,void 0,x.type,void 0,null,!1,void 0,R),x._isRGBD=!1,x.invertY=!1,M=h.createRenderTargetCubeTexture(x.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:x.type,format:5});else if(x._isRGBD=!0,x.invertY=!0,a){const O=3;Y={};const Q=x._lodGenerationScale,X=x._lodGenerationOffset;for(let Z=0;Z<O;Z++){const n=(U-1)*Q+X,V=X+(n-X)*(1-Z/(O-1)),C=Math.round(Math.min(Math.max(V,0),n)),L=new o.e(h,2);L.isCube=!0,L.invertY=!0,L.generateMipMaps=!1,h.updateTextureSamplingMode(2,L);const N=new l.b(null);switch(N._isCube=!0,N._texture=L,Y[C]=N,Z){case 0:x._lodTextureLow=N;break;case 1:x._lodTextureMid=N;break;case 2:x._lodTextureHigh=N}}}const s=[];for(let Q=0;Q<O.length;Q++)for(let X=0;X<6;X++){const Z=O[Q][X],n=new Blob([Z],{type:V}),o=URL.createObjectURL(n);let l;if(h._features.forceBitmapOverHTMLImageElement)l=h.createImageBitmap(n,{premultiplyAlpha:"none"}).then((async O=>await v(O,h,N,K,o,X,Q,a,Y,M,x)));else{const O=new Image;O.src=o,l=new Promise(((Z,n)=>{O.onload=()=>{v(O,h,N,K,o,X,Q,a,Y,M,x).then((()=>Z())).catch((x=>{n(x)}))},O.onerror=x=>{n(x)}}))}s.push(l)}if(await Promise.all(s),O.length<U){let Q;const X=Math.pow(2,U-1-O.length),Z=X*X*4;switch(x.type){case 0:Q=new Uint8Array(Z);break;case 2:Q=new Uint16Array(Z);break;case 1:Q=new Float32Array(Z)}for(let n=O.length;n<U;n++)for(let O=0;O<6;O++){var q;h._uploadArrayBufferViewToTexture((null===(q=M)||void 0===q?void 0:q.texture)||x,Q,O,n)}}if(M){const O=x._irradianceTexture;x._irradianceTexture=null,h._releaseTexture(x),M._swapAndDie(x),x._irradianceTexture=O}K&&K.dispose(),a&&(x._lodTextureHigh&&x._lodTextureHigh._texture&&(x._lodTextureHigh._texture.isReady=!0),x._lodTextureMid&&x._lodTextureMid._texture&&(x._lodTextureMid._texture.isReady=!0),x._lodTextureLow&&x._lodTextureLow._texture&&(x._lodTextureLow._texture.isReady=!0))}function G(x,O){const Q=(O=K(O)).irradiance;if(!Q)return;const X=new V.d;Z.n.FromArrayToRef(Q.x,0,X.x),Z.n.FromArrayToRef(Q.y,0,X.y),Z.n.FromArrayToRef(Q.z,0,X.z),Z.n.FromArrayToRef(Q.xx,0,X.xx),Z.n.FromArrayToRef(Q.yy,0,X.yy),Z.n.FromArrayToRef(Q.zz,0,X.zz),Z.n.FromArrayToRef(Q.yz,0,X.yz),Z.n.FromArrayToRef(Q.zx,0,X.zx),Z.n.FromArrayToRef(Q.xy,0,X.xy),x._sphericalPolynomial=X}function k(x,O,Q,X,Z){const n=R(x.getEngine().createRawCubeTexture(null,x.width,x.format,x.type,x.generateMipMaps,x.invertY,x.samplingMode,x._compression),O).then((()=>x));return x.onRebuildCallback=x=>({proxy:n,isReady:!0,isAsync:!0}),x._source=13,x._bufferViewArrayArray=O,x._lodGenerationScale=X,x._lodGenerationOffset=Z,x._sphericalPolynomial=Q,R(x,O).then((()=>(x.isReady=!0,x)))}}}]);