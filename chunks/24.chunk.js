"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[24],{12730:(V,h,mV)=>{mV.d(h,{e:()=>t});class t{constructor(V,h,mV){this.bu=V,this.bv=h,this.distance=mV,this.faceId=0,this.subMeshId=0}}},12738:(V,h,mV)=>{mV.d(h,{e:()=>A});var t=mV(12433),L=mV(12422),N=mV(12425);class A{constructor(V,h,mV){this.vectors=(0,t.c)(8,L.sh.Zero),this.center=L.sh.Zero(),this.centerWorld=L.sh.Zero(),this.extendSize=L.sh.Zero(),this.extendSizeWorld=L.sh.Zero(),this.directions=(0,t.c)(3,L.sh.Zero),this.vectorsWorld=(0,t.c)(8,L.sh.Zero),this.minimumWorld=L.sh.Zero(),this.maximumWorld=L.sh.Zero(),this.minimum=L.sh.Zero(),this.maximum=L.sh.Zero(),this._drawWrapperFront=null,this._drawWrapperBack=null,this.reConstruct(V,h,mV)}reConstruct(V,h,mV){const t=V.x,N=V.y,A=V.z,k=h.x,C=h.y,K=h.z,o=this.vectors;this.minimum.Hk(t,N,A),this.maximum.Hk(k,C,K),o[0].Hk(t,N,A),o[1].Hk(k,C,K),o[2].Hk(k,N,A),o[3].Hk(t,C,A),o[4].Hk(t,N,K),o[5].Hk(k,C,A),o[6].Hk(t,C,K),o[7].Hk(k,N,K),h.addToRef(V,this.center).scaleInPlace(.5),h.subtractToRef(V,this.extendSize).scaleInPlace(.5),this._worldMatrix=mV||L.Matrix.IdentityReadOnly,this._update(this._worldMatrix)}scale(V){const h=A._TmpVector3,mV=this.maximum.subtractToRef(this.minimum,h[0]),t=mV.length();mV.normalizeFromLength(t);const L=t*V,N=mV.scaleInPlace(.5*L),k=this.center.subtractToRef(N,h[1]),C=this.center.addToRef(N,h[2]);return this.reConstruct(k,C,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(V){const h=this.minimumWorld,mV=this.maximumWorld,t=this.directions,N=this.vectorsWorld,A=this.vectors;if(V.isIdentity()){h.t(this.minimum),mV.t(this.maximum);for(let V=0;V<8;++V)N[V].t(A[V]);this.extendSizeWorld.t(this.extendSize),this.centerWorld.t(this.center)}else{h.lk(Number.MAX_VALUE),mV.lk(-Number.MAX_VALUE);for(let t=0;t<8;++t){const k=N[t];L.sh.TransformCoordinatesToRef(A[t],V,k),h.minimizeInPlace(k),mV.maximizeInPlace(k)}mV.subtractToRef(h,this.extendSizeWorld).scaleInPlace(.5),mV.addToRef(h,this.centerWorld).scaleInPlace(.5)}L.sh.FromArrayToRef(V.m,0,t[0]),L.sh.FromArrayToRef(V.m,4,t[1]),L.sh.FromArrayToRef(V.m,8,t[2]),this._worldMatrix=V}isInFrustum(V){return A.IsInFrustum(this.vectorsWorld,V)}isCompletelyInFrustum(V){return A.IsCompletelyInFrustum(this.vectorsWorld,V)}intersectsPoint(V){const h=this.minimumWorld,mV=this.maximumWorld,t=h.x,L=h.y,A=h.z,k=mV.x,C=mV.y,K=mV.z,o=V.x,n=V.y,q=V.z,x=-N.c;return!(k-o<x||x>o-t)&&(!(C-n<x||x>n-L)&&!(K-q<x||x>q-A))}intersectsSphere(V){return A.IntersectsSphere(this.minimumWorld,this.maximumWorld,V.centerWorld,V.radiusWorld)}intersectsMinMax(V,h){const mV=this.minimumWorld,t=this.maximumWorld,L=mV.x,N=mV.y,A=mV.z,k=t.x,C=t.y,K=t.z,o=V.x,n=V.y,q=V.z,x=h.x,R=h.y,d=h.z;return!(k<o||L>x)&&(!(C<n||N>R)&&!(K<q||A>d))}dispose(){var V,h;null===(V=this._drawWrapperFront)||void 0===V||V.dispose(),null===(h=this._drawWrapperBack)||void 0===h||h.dispose()}static Intersects(V,h){return V.intersectsMinMax(h.minimumWorld,h.maximumWorld)}static IntersectsSphere(V,h,mV,t){const N=A._TmpVector3[0];L.sh.ClampToRef(mV,V,h,N);return L.sh.DistanceSquared(mV,N)<=t*t}static IsCompletelyInFrustum(V,h){for(let mV=0;mV<6;++mV){const t=h[mV];for(let h=0;h<8;++h)if(t.dotCoordinate(V[h])<0)return!1}return!0}static IsInFrustum(V,h){for(let mV=0;mV<6;++mV){let t=!0;const L=h[mV];for(let h=0;h<8;++h)if(L.dotCoordinate(V[h])>=0){t=!1;break}if(t)return!1}return!0}}A._TmpVector3=(0,t.c)(3,L.sh.Zero)},12734:(V,h,mV)=>{mV.d(h,{e:()=>n});var t=mV(12433),L=mV(12422),N=mV(12738),A=mV(12740);const k={min:0,max:0},C={min:0,max:0},K=(V,h,mV)=>{const t=L.sh.Dot(h.centerWorld,V),N=Math.abs(L.sh.Dot(h.directions[0],V))*h.extendSize.x+Math.abs(L.sh.Dot(h.directions[1],V))*h.extendSize.y+Math.abs(L.sh.Dot(h.directions[2],V))*h.extendSize.z;mV.min=t-N,mV.max=t+N},o=(V,h,mV)=>(K(V,h,k),K(V,mV,C),!(k.min>C.max||C.min>k.max));class n{constructor(V,h,mV){this._isLocked=!1,this.boundingBox=new N.e(V,h,mV),this.boundingSphere=new A.e(V,h,mV)}reConstruct(V,h,mV){this.boundingBox.reConstruct(V,h,mV),this.boundingSphere.reConstruct(V,h,mV)}get minimum(){return this.boundingBox.minimum}get maximum(){return this.boundingBox.maximum}get isLocked(){return this._isLocked}set isLocked(V){this._isLocked=V}update(V){this._isLocked||(this.boundingBox._update(V),this.boundingSphere._update(V))}centerOn(V,h){const mV=n._TmpVector3[0].t(V).An(h),t=n._TmpVector3[1].t(V).addInPlace(h);return this.boundingBox.reConstruct(mV,t,this.boundingBox.getWorldMatrix()),this.boundingSphere.reConstruct(mV,t,this.boundingBox.getWorldMatrix()),this}encapsulate(V){const h=L.sh.Minimize(this.minimum,V),mV=L.sh.Maximize(this.maximum,V);return this.reConstruct(h,mV,this.boundingBox.getWorldMatrix()),this}encapsulateBoundingInfo(V){const h=L.TmpVectors.Matrix[0];this.boundingBox.getWorldMatrix().invertToRef(h);const mV=L.TmpVectors.sh[0];return L.sh.TransformCoordinatesToRef(V.boundingBox.minimumWorld,h,mV),this.encapsulate(mV),L.sh.TransformCoordinatesToRef(V.boundingBox.maximumWorld,h,mV),this.encapsulate(mV),this}scale(V){return this.boundingBox.scale(V),this.boundingSphere.scale(V),this}isInFrustum(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if((2===h||3===h)&&this.boundingSphere.isCenterInFrustum(V))return!0;if(!this.boundingSphere.isInFrustum(V))return!1;return!(1!==h&&3!==h)||this.boundingBox.isInFrustum(V)}get diagonalLength(){const V=this.boundingBox;return V.maximumWorld.subtractToRef(V.minimumWorld,n._TmpVector3[0]).length()}isCompletelyInFrustum(V){return this.boundingBox.isCompletelyInFrustum(V)}_checkCollision(V){return V._canDoCollision(this.boundingSphere.centerWorld,this.boundingSphere.radiusWorld,this.boundingBox.minimumWorld,this.boundingBox.maximumWorld)}intersectsPoint(V){return!!this.boundingSphere.centerWorld&&(!!this.boundingSphere.intersectsPoint(V)&&!!this.boundingBox.intersectsPoint(V))}intersects(V,h){if(!A.e.Intersects(this.boundingSphere,V.boundingSphere))return!1;if(!N.e.Intersects(this.boundingBox,V.boundingBox))return!1;if(!h)return!0;const mV=this.boundingBox,t=V.boundingBox;return!!o(mV.directions[0],mV,t)&&(!!o(mV.directions[1],mV,t)&&(!!o(mV.directions[2],mV,t)&&(!!o(t.directions[0],mV,t)&&(!!o(t.directions[1],mV,t)&&(!!o(t.directions[2],mV,t)&&(!!o(L.sh.Cross(mV.directions[0],t.directions[0]),mV,t)&&(!!o(L.sh.Cross(mV.directions[0],t.directions[1]),mV,t)&&(!!o(L.sh.Cross(mV.directions[0],t.directions[2]),mV,t)&&(!!o(L.sh.Cross(mV.directions[1],t.directions[0]),mV,t)&&(!!o(L.sh.Cross(mV.directions[1],t.directions[1]),mV,t)&&(!!o(L.sh.Cross(mV.directions[1],t.directions[2]),mV,t)&&(!!o(L.sh.Cross(mV.directions[2],t.directions[0]),mV,t)&&(!!o(L.sh.Cross(mV.directions[2],t.directions[1]),mV,t)&&!!o(L.sh.Cross(mV.directions[2],t.directions[2]),mV,t))))))))))))))}}n._TmpVector3=(0,t.c)(2,L.sh.Zero)},12740:(V,h,mV)=>{mV.d(h,{e:()=>N});var t=mV(12433),L=mV(12422);class N{constructor(V,h,mV){this.center=L.sh.Zero(),this.centerWorld=L.sh.Zero(),this.minimum=L.sh.Zero(),this.maximum=L.sh.Zero(),this.reConstruct(V,h,mV)}reConstruct(V,h,mV){this.minimum.t(V),this.maximum.t(h);const t=L.sh.Distance(V,h);h.addToRef(V,this.center).scaleInPlace(.5),this.radius=.5*t,this._update(mV||L.Matrix.IdentityReadOnly)}scale(V){const h=this.radius*V,mV=N._TmpVector3,t=mV[0].lk(h),L=this.center.subtractToRef(t,mV[1]),A=this.center.addToRef(t,mV[2]);return this.reConstruct(L,A,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(V){if(V.isIdentity())this.centerWorld.t(this.center),this.radiusWorld=this.radius;else{L.sh.TransformCoordinatesToRef(this.center,V,this.centerWorld);const h=N._TmpVector3[0];L.sh.TransformNormalFromFloatsToRef(1,1,1,V,h),this.radiusWorld=Math.max(Math.abs(h.x),Math.abs(h.y),Math.abs(h.z))*this.radius}}isInFrustum(V){const h=this.centerWorld,mV=this.radiusWorld;for(let t=0;t<6;t++)if(V[t].dotCoordinate(h)<=-mV)return!1;return!0}isCenterInFrustum(V){const h=this.centerWorld;for(let mV=0;mV<6;mV++)if(V[mV].dotCoordinate(h)<0)return!1;return!0}intersectsPoint(V){const h=L.sh.DistanceSquared(this.centerWorld,V);return!(this.radiusWorld*this.radiusWorld<h)}static Intersects(V,h){const mV=L.sh.DistanceSquared(V.centerWorld,h.centerWorld),t=V.radiusWorld+h.radiusWorld;return!(t*t<mV)}static CreateFromCenterAndRadius(V,h,mV){this._TmpVector3[0].t(V),this._TmpVector3[1].Hk(0,0,h),this._TmpVector3[2].t(V),this._TmpVector3[0].addInPlace(this._TmpVector3[1]),this._TmpVector3[2].An(this._TmpVector3[1]);const t=new N(this._TmpVector3[0],this._TmpVector3[2]);return t._worldMatrix=mV||L.Matrix.Identity(),t}}N._TmpVector3=(0,t.c)(3,L.sh.Zero)},12751:(V,h,mV)=>{function t(V){-1===V.indexOf("vClipPlane")&&V.push("vClipPlane"),-1===V.indexOf("vClipPlane2")&&V.push("vClipPlane2"),-1===V.indexOf("vClipPlane3")&&V.push("vClipPlane3"),-1===V.indexOf("vClipPlane4")&&V.push("vClipPlane4"),-1===V.indexOf("vClipPlane5")&&V.push("vClipPlane5"),-1===V.indexOf("vClipPlane6")&&V.push("vClipPlane6")}function L(V,h,mV){const t=!!(V.clipPlane??h.clipPlane),L=!!(V.clipPlane2??h.clipPlane2),N=!!(V.clipPlane3??h.clipPlane3),A=!!(V.clipPlane4??h.clipPlane4),k=!!(V.clipPlane5??h.clipPlane5),C=!!(V.clipPlane6??h.clipPlane6);t&&mV.push("#define CLIPPLANE"),L&&mV.push("#define CLIPPLANE2"),N&&mV.push("#define CLIPPLANE3"),A&&mV.push("#define CLIPPLANE4"),k&&mV.push("#define CLIPPLANE5"),C&&mV.push("#define CLIPPLANE6")}function N(V,h,mV){let t=!1;const L=!!(V.clipPlane??h.clipPlane),N=!!(V.clipPlane2??h.clipPlane2),A=!!(V.clipPlane3??h.clipPlane3),k=!!(V.clipPlane4??h.clipPlane4),C=!!(V.clipPlane5??h.clipPlane5),K=!!(V.clipPlane6??h.clipPlane6);return mV.CLIPPLANE!==L&&(mV.CLIPPLANE=L,t=!0),mV.CLIPPLANE2!==N&&(mV.CLIPPLANE2=N,t=!0),mV.CLIPPLANE3!==A&&(mV.CLIPPLANE3=A,t=!0),mV.CLIPPLANE4!==k&&(mV.CLIPPLANE4=k,t=!0),mV.CLIPPLANE5!==C&&(mV.CLIPPLANE5=C,t=!0),mV.CLIPPLANE6!==K&&(mV.CLIPPLANE6=K,t=!0),t}function A(V,h,mV){let t=h.clipPlane??mV.clipPlane;k(V,"vClipPlane",t),t=h.clipPlane2??mV.clipPlane2,k(V,"vClipPlane2",t),t=h.clipPlane3??mV.clipPlane3,k(V,"vClipPlane3",t),t=h.clipPlane4??mV.clipPlane4,k(V,"vClipPlane4",t),t=h.clipPlane5??mV.clipPlane5,k(V,"vClipPlane5",t),t=h.clipPlane6??mV.clipPlane6,k(V,"vClipPlane6",t)}function k(V,h,mV){mV&&V.setFloat4(h,mV.normal.x,mV.normal.y,mV.normal.z,mV.d)}mV.d(h,{e:()=>t,h:()=>A,i:()=>N,k:()=>L})},12704:(V,h,mV)=>{mV.d(h,{b:()=>t});class t{constructor(){this._defines={},this._currentRank=32,this._maxRank=-1,this._mesh=null}unBindMesh(){this._mesh=null}addFallback(V,h){this._defines[V]||(V<this._currentRank&&(this._currentRank=V),V>this._maxRank&&(this._maxRank=V),this._defines[V]=new Array),this._defines[V].push(h)}addCPUSkinningFallback(V,h){this._mesh=h,V<this._currentRank&&(this._currentRank=V),V>this._maxRank&&(this._maxRank=V)}get hasMoreFallbacks(){return this._currentRank<=this._maxRank}reduce(V,h){if(this._mesh&&this._mesh.computeBonesUsingShaders&&this._mesh.numBoneInfluencers>0){this._mesh.computeBonesUsingShaders=!1,V=V.replace("#define NUM_BONE_INFLUENCERS "+this._mesh.numBoneInfluencers,"#define NUM_BONE_INFLUENCERS 0"),h._bonesComputationForcedToCPU=!0;const mV=this._mesh.DV();for(let V=0;V<mV.meshes.length;V++){const t=mV.meshes[V];if(t.material){if(t.computeBonesUsingShaders&&0!==t.numBoneInfluencers)if(t.material.getEffect()===h)t.computeBonesUsingShaders=!1;else if(t.dk)for(const V of t.dk){if(V.effect===h){t.computeBonesUsingShaders=!1;break}}}else!this._mesh.material&&t.computeBonesUsingShaders&&t.numBoneInfluencers>0&&(t.computeBonesUsingShaders=!1)}}else{const h=this._defines[this._currentRank];if(h)for(let mV=0;mV<h.length;mV++)V=V.replace("#define "+h[mV],"");this._currentRank++}return V}}},12718:(V,h,mV)=>{mV.d(h,{c:()=>s});var t=mV(12409),L=mV(12413),N=mV(12253),A=mV(12258),k=mV(12300),C=mV(12723),K=mV(12665),o=mV(12264),n=mV(12458),q=mV(12532),x=mV(12448);class R{constructor(){this.reset()}reset(){this.enabled=!1,this.mask=255,this.func=519,this.funcRef=1,this.funcMask=255,this.opStencilFail=7680,this.opDepthFail=7680,this.opStencilDepthPass=7681}get func(){return this._func}set func(V){this._func=V}get funcRef(){return this._funcRef}set funcRef(V){this._funcRef=V}get funcMask(){return this._funcMask}set funcMask(V){this._funcMask=V}get opStencilFail(){return this._opStencilFail}set opStencilFail(V){this._opStencilFail=V}get opDepthFail(){return this._opDepthFail}set opDepthFail(V){this._opDepthFail=V}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(V){this._opStencilDepthPass=V}get mask(){return this._mask}set mask(V){this._mask=V}get enabled(){return this._enabled}set enabled(V){this._enabled=V}getClassName(){return"MaterialStencilState"}copyTo(V){x.e.Clone((()=>V),this)}serialize(){return x.e.Serialize(this)}parse(V,h,mV){x.e.Parse((()=>this),V,h,mV)}}(0,t.e)([(0,L.J)()],R.prototype,"func",null),(0,t.e)([(0,L.J)()],R.prototype,"funcRef",null),(0,t.e)([(0,L.J)()],R.prototype,"funcMask",null),(0,t.e)([(0,L.J)()],R.prototype,"opStencilFail",null),(0,t.e)([(0,L.J)()],R.prototype,"opDepthFail",null),(0,t.e)([(0,L.J)()],R.prototype,"opStencilDepthPass",null),(0,t.e)([(0,L.J)()],R.prototype,"mask",null),(0,t.e)([(0,L.J)()],R.prototype,"enabled",null);var d=mV(12746);class s{get _supportGlowLayer(){return!1}set _glowModeEnabled(V){}get shaderLanguage(){return this._shaderLanguage}get canRenderToMRT(){return!1}set alpha(V){if(this._alpha===V)return;const h=this._alpha;this._alpha=V,1!==h&&1!==V||this.UK(s.MiscDirtyFlag+s.PrePassDirtyFlag)}get alpha(){return this._alpha}set Dk(V){this._backFaceCulling!==V&&(this._backFaceCulling=V,this.UK(s.TextureDirtyFlag))}get Dk(){return this._backFaceCulling}set cullBackFaces(V){this._cullBackFaces!==V&&(this._cullBackFaces=V,this.UK(s.TextureDirtyFlag))}get cullBackFaces(){return this._cullBackFaces}get blockDirtyMechanism(){return this._blockDirtyMechanism}set blockDirtyMechanism(V){this._blockDirtyMechanism!==V&&(this._blockDirtyMechanism=V,V||this.en())}atomicMaterialsUpdate(V){this.blockDirtyMechanism=!0;try{V(this)}finally{this.blockDirtyMechanism=!1}}get hasRenderTargetTextures(){return this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._eventInfo.hasRenderTargetTextures}set onDispose(V){this._onDisposeObserver&&this.XL.remove(this._onDisposeObserver),this._onDisposeObserver=this.XL.add(V)}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new A.d),this._onBindObservable}set onBind(V){this._onBindObserver&&this.onBindObservable.remove(this._onBindObserver),this._onBindObserver=this.onBindObservable.add(V)}get onUnBindObservable(){return this._onUnBindObservable||(this._onUnBindObservable=new A.d),this._onUnBindObservable}get onEffectCreatedObservable(){return this._onEffectCreatedObservable||(this._onEffectCreatedObservable=new A.d),this._onEffectCreatedObservable}set alphaMode(V){this._alphaMode!==V&&(this._alphaMode=V,this.UK(s.TextureDirtyFlag))}get alphaMode(){return this._alphaMode}set needDepthPrePass(V){this._needDepthPrePass!==V&&(this._needDepthPrePass=V,this._needDepthPrePass&&(this.checkReadyOnEveryCall=!0))}get needDepthPrePass(){return this._needDepthPrePass}get isPrePassCapable(){return!1}set fogEnabled(V){this._fogEnabled!==V&&(this._fogEnabled=V,this.UK(s.MiscDirtyFlag))}get fogEnabled(){return this._fogEnabled}get wireframe(){switch(this._fillMode){case s.WireFrameFillMode:case s.LineListDrawMode:case s.LineLoopDrawMode:case s.LineStripDrawMode:return!0}return this._scene.forceWireframe}set wireframe(V){this.fillMode=V?s.WireFrameFillMode:s.TriangleFillMode}get pointsCloud(){switch(this._fillMode){case s.PointFillMode:case s.PointListDrawMode:return!0}return this._scene.forcePointsCloud}set pointsCloud(V){this.fillMode=V?s.PointFillMode:s.TriangleFillMode}get fillMode(){return this._fillMode}set fillMode(V){this._fillMode!==V&&(this._fillMode=V,this.UK(s.MiscDirtyFlag))}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(V){const h=this.DV().getEngine().getCaps().fragmentDepthSupported;V&&!h&&o.e.Warn("Logarithmic depth has been requested for a material on a device that doesn't support it."),this._useLogarithmicDepth=V&&h,this._markAllSubMeshesAsMiscDirty()}_getDrawWrapper(){return this._drawWrapper}_setDrawWrapper(V){this._drawWrapper=V}constructor(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.shadowDepthWrapper=null,this.allowShaderHotSwapping=!0,this._shaderLanguage=0,this._forceGLSL=!1,this.metadata=null,this.reservedDataStore=null,this.checkReadyOnEveryCall=!1,this.checkReadyOnlyOnce=!1,this.state="",this._alpha=1,this._backFaceCulling=!0,this._cullBackFaces=!0,this._blockDirtyMechanism=!1,this.sideOrientation=null,this.onCompiled=null,this.onError=null,this.getRenderTargetTextures=null,this.doNotSerialize=!1,this._storeEffectOnSubMeshes=!1,this.animations=null,this.XL=new A.d,this._onDisposeObserver=null,this._onUnBindObservable=null,this._onBindObserver=null,this._alphaMode=2,this._needDepthPrePass=!1,this.disableDepthWrite=!1,this.disableColorWrite=!1,this.forceDepthWrite=!1,this.depthFunction=0,this.separateCullingPass=!1,this._fogEnabled=!0,this.pointSize=1,this.zOffset=0,this.zOffsetUnits=0,this.Ck=new R,this._useUBO=!1,this._fillMode=s.TriangleFillMode,this._cachedDepthWriteState=!1,this._cachedColorWriteState=!1,this._cachedDepthFunctionState=0,this._indexInSceneMaterialArray=-1,this.meshMap=null,this._parentContainer=null,this._uniformBufferLayoutBuilt=!1,this._eventInfo={},this._callbackPluginEventGeneric=()=>{},this._callbackPluginEventIsReadyForSubMesh=()=>{},this._callbackPluginEventPrepareDefines=()=>{},this._callbackPluginEventPrepareDefinesBeforeAttributes=()=>{},this._callbackPluginEventHardBindForSubMesh=()=>{},this._callbackPluginEventBindForSubMesh=()=>{},this._callbackPluginEventHasRenderTargetTextures=()=>{},this._callbackPluginEventFillRenderTargetTextures=()=>{},this._transparencyMode=null,this.name=V;const L=h||k.b.LastCreatedScene;L&&(this._scene=L,this._dirtyCallbacks={},this._forceGLSL=t,this._dirtyCallbacks[1]=this._markAllSubMeshesAsTexturesDirty.bind(this),this._dirtyCallbacks[2]=this._markAllSubMeshesAsLightsDirty.bind(this),this._dirtyCallbacks[4]=this._markAllSubMeshesAsFresnelDirty.bind(this),this._dirtyCallbacks[8]=this._markAllSubMeshesAsAttributesDirty.bind(this),this._dirtyCallbacks[16]=this._markAllSubMeshesAsMiscDirty.bind(this),this._dirtyCallbacks[32]=this._markAllSubMeshesAsPrePassDirty.bind(this),this._dirtyCallbacks[127]=this._markAllSubMeshesAsAllDirty.bind(this),this.id=V||N.Tools.RandomId(),this.uniqueId=this._scene.getUniqueId(),this._materialContext=this._scene.getEngine().createMaterialContext(),this._drawWrapper=new q.e(this._scene.getEngine(),!1),this._drawWrapper.materialContext=this._materialContext,this._uniformBuffer=new K.b(this._scene.getEngine(),void 0,void 0,V),this._useUBO=this.DV().getEngine().supportsUniformBuffers,this._createUniformBuffer(),mV||this._scene.addMaterial(this),this._scene.useMaterialMeshMap&&(this.meshMap={}),s.OnEventObservable.notifyObservers(this,1))}_createUniformBuffer(){var V;const h=this.DV().getEngine();null===(V=this._uniformBuffer)||void 0===V||V.dispose(),h.isWebGPU&&!this._forceGLSL?(this._uniformBuffer=new K.b(h,void 0,void 0,this.name,!0),this._shaderLanguage=1):this._uniformBuffer=new K.b(this._scene.getEngine(),void 0,void 0,this.name),this._uniformBufferLayoutBuilt=!1}toString(V){return"Name: "+this.name}getClassName(){return"Material"}get _isMaterial(){return!0}get isFrozen(){return this.checkReadyOnlyOnce}freeze(){this.en(),this.checkReadyOnlyOnce=!0}unfreeze(){this.en(),this.checkReadyOnlyOnce=!1}isReady(V,h){return!0}isReadyForSubMesh(V,h,mV){const t=h.materialDefines;return!!t&&(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=t,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),this._eventInfo.isReadyForSubMesh)}getEffect(){return this._drawWrapper.effect}DV(){return this._scene}_getEffectiveOrientation(V){return null!==this.sideOrientation?this.sideOrientation:V.sideOrientation}get transparencyMode(){return this._transparencyMode}set transparencyMode(V){this._transparencyMode!==V&&(this._transparencyMode=V,this._markAllSubMeshesAsTexturesAndMiscDirty())}get _hasTransparencyMode(){return null!=this._transparencyMode}get _transparencyModeIsBlend(){return this._transparencyMode===s.MATERIAL_ALPHABLEND||this._transparencyMode===s.MATERIAL_ALPHATESTANDBLEND}get _transparencyModeIsTest(){return this._transparencyMode===s.MATERIAL_ALPHATEST||this._transparencyMode===s.MATERIAL_ALPHATESTANDBLEND}get _disableAlphaBlending(){return this._transparencyMode===s.MATERIAL_OPAQUE||this._transparencyMode===s.MATERIAL_ALPHATEST}needAlphaBlending(){return this._hasTransparencyMode?this._transparencyModeIsBlend:!this._disableAlphaBlending&&this.alpha<1}needAlphaBlendingForMesh(V){return this._hasTransparencyMode?this._transparencyModeIsBlend:V.visibility<1||!this._disableAlphaBlending&&(V.hasVertexAlpha||this.needAlphaBlending())}needAlphaTesting(){return!!this._hasTransparencyMode&&this._transparencyModeIsTest}needAlphaTestingForMesh(V){return this._hasTransparencyMode?this._transparencyModeIsTest:!this.needAlphaBlendingForMesh(V)&&this.needAlphaTesting()}getAlphaTestTexture(){return null}en(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=this.DV().meshes;for(const mV of h)if(mV.dk)for(const h of mV.dk)if(h.ZV()===this)for(const mV of h._drawWrappers)mV&&this._materialContext===mV.materialContext&&(mV._wasPreviouslyReady=!1,mV._wasPreviouslyUsingInstances=null,mV._forceRebindOnNextCall=V);V&&this.UK(s.AllDirtyFlag)}_preBind(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const mV=this._scene.getEngine(),t=(null==h?this.sideOrientation:h)===s.ClockWiseSideOrientation;return mV.enableEffect(V||this._getDrawWrapper()),mV.setState(this.Dk,this.zOffset,!1,t,this._scene._mirroredCameraPosition?!this.cullBackFaces:this.cullBackFaces,this.Ck,this.zOffsetUnits),t}bind(V,h){}buildUniformLayout(){const V=this._uniformBuffer;this._eventInfo.ubo=V,this._callbackPluginEventGeneric(8,this._eventInfo),V.create(),this._uniformBufferLayoutBuilt=!0}bindForSubMesh(V,h,mV){const t=mV._drawWrapper;this._eventInfo.subMesh=mV,this._callbackPluginEventBindForSubMesh(this._eventInfo),t._forceRebindOnNextCall=!1}bindOnlyWorldMatrix(V){}bindView(V){this._useUBO?this._needToBindSceneUbo=!0:V.setMatrix("view",this.DV().getViewMatrix())}bindViewProjection(V){this._useUBO?this._needToBindSceneUbo=!0:(V.setMatrix("viewProjection",this.DV().getTransformMatrix()),V.setMatrix("projection",this.DV().getProjectionMatrix()))}bindEyePosition(V,h){this._useUBO?this._needToBindSceneUbo=!0:this._scene.bindEyePosition(V,h)}_afterBind(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(this._scene._cachedMaterial=this,this._needToBindSceneUbo&&h&&(this._needToBindSceneUbo=!1,(0,d.k)(h,this.DV().getSceneUniformBuffer()),this._scene.finalizeSceneUbo()),this._scene._cachedVisibility=V?V.visibility:1,this._onBindObservable&&V&&this._onBindObservable.notifyObservers(V),this.disableDepthWrite){const V=this._scene.getEngine();this._cachedDepthWriteState=V.getDepthWrite(),V.setDepthWrite(!1)}if(this.disableColorWrite){const V=this._scene.getEngine();this._cachedColorWriteState=V.getColorWrite(),V.setColorWrite(!1)}if(0!==this.depthFunction){const V=this._scene.getEngine();this._cachedDepthFunctionState=V.getDepthFunction()||0,V.setDepthFunction(this.depthFunction)}}unbind(){if(this._scene.getSceneUniformBuffer().unbindEffect(),this._onUnBindObservable&&this._onUnBindObservable.notifyObservers(this),0!==this.depthFunction){this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState)}if(this.disableDepthWrite){this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState)}if(this.disableColorWrite){this._scene.getEngine().setColorWrite(this._cachedColorWriteState)}}getAnimatables(){return this._eventInfo.animatables=[],this._callbackPluginEventGeneric(256,this._eventInfo),this._eventInfo.animatables}getActiveTextures(){return this._eventInfo.activeTextures=[],this._callbackPluginEventGeneric(512,this._eventInfo),this._eventInfo.activeTextures}hasTexture(V){return this._eventInfo.hasTexture=!1,this._eventInfo.texture=V,this._callbackPluginEventGeneric(1024,this._eventInfo),this._eventInfo.hasTexture}clone(V){return null}_clonePlugins(V,h){const mV={};if(this._serializePlugins(mV),s._ParsePlugins(mV,V,this._scene,h),this.pluginManager)for(const t of this.pluginManager._plugins){const h=V.pluginManager.getPlugin(t.name);h&&t.copyTo(h)}}getBindedMeshes(){if(this.meshMap){const V=[];for(const h in this.meshMap){const mV=this.meshMap[h];mV&&V.push(mV)}return V}return this._scene.meshes.filter((V=>V.material===this))}forceCompilation(V,h,mV,t){const L={clipPlane:!1,useInstances:!1,...mV},N=this.DV(),A=this.allowShaderHotSwapping;this.allowShaderHotSwapping=!1;const k=()=>{if(!this._scene||!this._scene.getEngine())return;const mV=N.clipPlane;if(L.clipPlane&&(N.clipPlane=new n.b(0,0,0,1)),this._storeEffectOnSubMeshes){let mV=!0,N=null;if(V.dk){const h=new C.b(0,0,0,0,0,V,void 0,!1,!1);h.materialDefines&&(h.materialDefines._renderId=-1),this.isReadyForSubMesh(V,h,L.useInstances)||(h.effect&&h.effect.getCompilationError()&&h.effect.allFallbacksProcessed()?N=h.effect.getCompilationError():(mV=!1,setTimeout(k,16)))}mV&&(this.allowShaderHotSwapping=A,N&&t&&t(N),h&&h(this))}else this.isReady()?(this.allowShaderHotSwapping=A,h&&h(this)):setTimeout(k,16);L.clipPlane&&(N.clipPlane=mV)};k()}async forceCompilationAsync(V,h){return await new Promise(((mV,t)=>{this.forceCompilation(V,(()=>{mV()}),h,(V=>{t(V)}))}))}UK(V){this.DV().blockMaterialDirtyMechanism||this._blockDirtyMechanism||(s._DirtyCallbackArray.length=0,V&s.ImageProcessingDirtyFlag&&s._DirtyCallbackArray.push(s._ImageProcessingDirtyCallBack),V&s.TextureDirtyFlag&&s._DirtyCallbackArray.push(s._TextureDirtyCallBack),V&s.LightDirtyFlag&&s._DirtyCallbackArray.push(s._LightsDirtyCallBack),V&s.FresnelDirtyFlag&&s._DirtyCallbackArray.push(s._FresnelDirtyCallBack),V&s.AttributesDirtyFlag&&s._DirtyCallbackArray.push(s._AttributeDirtyCallBack),V&s.MiscDirtyFlag&&s._DirtyCallbackArray.push(s._MiscDirtyCallBack),V&s.PrePassDirtyFlag&&s._DirtyCallbackArray.push(s._PrePassDirtyCallBack),s._DirtyCallbackArray.length&&this._markAllSubMeshesAsDirty(s._RunDirtyCallBacks),this.DV().resetCachedMaterial())}resetDrawCache(){const V=this.DV().meshes;for(const h of V)if(h.dk)for(const V of h.dk)V.ZV()===this&&V.resetDrawCache()}_markAllSubMeshesAsDirty(V){const h=this.DV();if(h.blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const mV=h.meshes;for(const t of mV)if(t.dk)for(const mV of t.dk){if((mV.ZV()||(h._hasDefaultMaterial?h.defaultMaterial:null))===this)for(const h of mV._drawWrappers)h&&h.defines&&h.defines.markAllAsDirty&&this._materialContext===h.materialContext&&V(h.defines)}}_markScenePrePassDirty(){if(this.DV().blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const V=this.DV().enablePrePassRenderer();V&&V.UK()}_markAllSubMeshesAsAllDirty(){this._markAllSubMeshesAsDirty(s._AllDirtyCallBack)}_markAllSubMeshesAsImageProcessingDirty(){this._markAllSubMeshesAsDirty(s._ImageProcessingDirtyCallBack)}_markAllSubMeshesAsTexturesDirty(){this._markAllSubMeshesAsDirty(s._TextureDirtyCallBack)}_markAllSubMeshesAsFresnelDirty(){this._markAllSubMeshesAsDirty(s._FresnelDirtyCallBack)}_markAllSubMeshesAsFresnelAndMiscDirty(){this._markAllSubMeshesAsDirty(s._FresnelAndMiscDirtyCallBack)}_markAllSubMeshesAsLightsDirty(){this._markAllSubMeshesAsDirty(s._LightsDirtyCallBack)}_markAllSubMeshesAsAttributesDirty(){this._markAllSubMeshesAsDirty(s._AttributeDirtyCallBack)}_markAllSubMeshesAsMiscDirty(){this._markAllSubMeshesAsDirty(s._MiscDirtyCallBack)}_markAllSubMeshesAsPrePassDirty(){this._markAllSubMeshesAsDirty(s._PrePassDirtyCallBack)}_markAllSubMeshesAsTexturesAndMiscDirty(){this._markAllSubMeshesAsDirty(s._TextureAndMiscDirtyCallBack)}_checkScenePerformancePriority(){if(0!==this._scene.performancePriority){this.checkReadyOnlyOnce=!0;const V=this._scene.onScenePerformancePriorityChangedObservable.addOnce((()=>{this.checkReadyOnlyOnce=!1}));this.XL.add((()=>{this._scene.onScenePerformancePriorityChangedObservable.remove(V)}))}}setPrePassRenderer(V){return!1}dispose(V,h,mV){const t=this.DV();if(t.stopAnimation(this),t.freeProcessedMaterials(),t.removeMaterial(this),this._eventInfo.forceDisposeTextures=h,this._callbackPluginEventGeneric(2,this._eventInfo),this._parentContainer){const V=this._parentContainer.materials.indexOf(this);V>-1&&this._parentContainer.materials.splice(V,1),this._parentContainer=null}if(!0!==mV)if(this.meshMap)for(const L in this.meshMap){const V=this.meshMap[L];this._disposeMeshResources(V)}else{const V=t.meshes;for(const h of V)this._disposeMeshResources(h)}this._uniformBuffer.dispose(),this._drawWrapper.effect&&(this._storeEffectOnSubMeshes||this._drawWrapper.effect.dispose(),this._drawWrapper.effect=null),this.metadata=null,this.XL.notifyObservers(this),this.XL.clear(),this._onBindObservable&&this._onBindObservable.clear(),this._onUnBindObservable&&this._onUnBindObservable.clear(),this._onEffectCreatedObservable&&this._onEffectCreatedObservable.clear(),this._eventInfo&&(this._eventInfo={})}_disposeMeshResources(V){if(!V)return;const h=V.Jk,mV=V._internalAbstractMeshDataInfo._materialForRenderPass;if(this._storeEffectOnSubMeshes){if(V.dk&&mV)for(const L of V.dk){const V=L._drawWrappers;for(let N=0;N<V.length;N++){var t;const A=null===(t=V[N])||void 0===t?void 0:t.effect;if(!A)continue;mV[N]===this&&(null===h||void 0===h||h._releaseVertexArrayObject(A),L._removeDrawWrapper(N,!0,!0))}}}else null===h||void 0===h||h._releaseVertexArrayObject(this._drawWrapper.effect);V.material!==this||V.sourceMesh||(V.material=null)}serialize(){const V=x.e.Serialize(this);return V.Ck=this.Ck.serialize(),V.uniqueId=this.uniqueId,this._serializePlugins(V),V}_serializePlugins(V){if(V.plugins={},this.pluginManager)for(const h of this.pluginManager._plugins)h.doNotSerialize||(V.plugins[h.getClassName()]=h.serialize())}static Parse(V,h,mV){if(V.customType){if("BABYLON.PBRMaterial"===V.customType&&V.overloadedAlbedo&&(V.customType="BABYLON.LegacyPBRMaterial",!BABYLON.LegacyPBRMaterial))return o.e.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."),null}else V.customType="BABYLON.StandardMaterial";const t=N.Tools.Instantiate(V.customType).Parse(V,h,mV);return t._loadedUniqueId=V.uniqueId,t}static _ParsePlugins(V,h,mV,t){if(V.plugins)for(const k in V.plugins){var L,A;const C=V.plugins[k];let K=null===(L=h.pluginManager)||void 0===L?void 0:L.getPlugin(C.name);if(!K){const V=N.Tools.Instantiate("BABYLON."+k);V&&(K=new V(h))}null===(A=K)||void 0===A||A.parse(C,mV,t)}}}s.TriangleFillMode=0,s.WireFrameFillMode=1,s.PointFillMode=2,s.PointListDrawMode=3,s.LineListDrawMode=4,s.LineLoopDrawMode=5,s.LineStripDrawMode=6,s.TriangleStripDrawMode=7,s.TriangleFanDrawMode=8,s.ClockWiseSideOrientation=0,s.CounterClockWiseSideOrientation=1,s.ImageProcessingDirtyFlag=64,s.TextureDirtyFlag=1,s.LightDirtyFlag=2,s.FresnelDirtyFlag=4,s.AttributesDirtyFlag=8,s.MiscDirtyFlag=16,s.PrePassDirtyFlag=32,s.AllDirtyFlag=127,s.MATERIAL_OPAQUE=0,s.MATERIAL_ALPHATEST=1,s.MATERIAL_ALPHABLEND=2,s.MATERIAL_ALPHATESTANDBLEND=3,s.MATERIAL_NORMALBLENDMETHOD_WHITEOUT=0,s.MATERIAL_NORMALBLENDMETHOD_RNM=1,s.OnEventObservable=new A.d,s._AllDirtyCallBack=V=>V.markAllAsDirty(),s._ImageProcessingDirtyCallBack=V=>V.markAsImageProcessingDirty(),s._TextureDirtyCallBack=V=>V.markAsTexturesDirty(),s._FresnelDirtyCallBack=V=>V.markAsFresnelDirty(),s._MiscDirtyCallBack=V=>V.markAsMiscDirty(),s._PrePassDirtyCallBack=V=>V.markAsPrePassDirty(),s._LightsDirtyCallBack=V=>V.markAsLightDirty(),s._AttributeDirtyCallBack=V=>V.markAsAttributesDirty(),s._FresnelAndMiscDirtyCallBack=V=>{s._FresnelDirtyCallBack(V),s._MiscDirtyCallBack(V)},s._TextureAndMiscDirtyCallBack=V=>{s._TextureDirtyCallBack(V),s._MiscDirtyCallBack(V)},s._DirtyCallbackArray=[],s._RunDirtyCallBacks=V=>{for(const h of s._DirtyCallbackArray)h(V)},(0,t.e)([(0,L.J)()],s.prototype,"id",void 0),(0,t.e)([(0,L.J)()],s.prototype,"uniqueId",void 0),(0,t.e)([(0,L.J)()],s.prototype,"name",void 0),(0,t.e)([(0,L.J)()],s.prototype,"metadata",void 0),(0,t.e)([(0,L.J)()],s.prototype,"checkReadyOnEveryCall",void 0),(0,t.e)([(0,L.J)()],s.prototype,"checkReadyOnlyOnce",void 0),(0,t.e)([(0,L.J)()],s.prototype,"state",void 0),(0,t.e)([(0,L.J)("alpha")],s.prototype,"_alpha",void 0),(0,t.e)([(0,L.J)("Dk")],s.prototype,"_backFaceCulling",void 0),(0,t.e)([(0,L.J)("cullBackFaces")],s.prototype,"_cullBackFaces",void 0),(0,t.e)([(0,L.J)()],s.prototype,"sideOrientation",void 0),(0,t.e)([(0,L.J)("alphaMode")],s.prototype,"_alphaMode",void 0),(0,t.e)([(0,L.J)()],s.prototype,"_needDepthPrePass",void 0),(0,t.e)([(0,L.J)()],s.prototype,"disableDepthWrite",void 0),(0,t.e)([(0,L.J)()],s.prototype,"disableColorWrite",void 0),(0,t.e)([(0,L.J)()],s.prototype,"forceDepthWrite",void 0),(0,t.e)([(0,L.J)()],s.prototype,"depthFunction",void 0),(0,t.e)([(0,L.J)()],s.prototype,"separateCullingPass",void 0),(0,t.e)([(0,L.J)("fogEnabled")],s.prototype,"_fogEnabled",void 0),(0,t.e)([(0,L.J)()],s.prototype,"pointSize",void 0),(0,t.e)([(0,L.J)()],s.prototype,"zOffset",void 0),(0,t.e)([(0,L.J)()],s.prototype,"zOffsetUnits",void 0),(0,t.e)([(0,L.J)()],s.prototype,"pointsCloud",null),(0,t.e)([(0,L.J)()],s.prototype,"fillMode",null),(0,t.e)([(0,L.J)()],s.prototype,"useLogarithmicDepth",null),(0,t.e)([(0,L.J)()],s.prototype,"transparencyMode",null)},12746:(V,h,mV)=>{mV.d(h,{A:()=>O,E:()=>G,I:()=>M,M:()=>l,N:()=>r,Q:()=>T,R:()=>F,V:()=>Z,X:()=>R,c:()=>Q,d:()=>n,f:()=>v,g:()=>o,i:()=>d,k:()=>s,n:()=>c,o:()=>j,s:()=>z,u:()=>D,w:()=>H,x:()=>x,y:()=>q,z:()=>I});var t=mV(12264),L=mV(12453),N=mV(12300),A=mV(12701),k=mV(12751);const C=L.Jh.Black(),K={NUM_MORPH_INFLUENCERS:0,NORMAL:!1,TANGENT:!1,UV:!1,UV2:!1,COLOR:!1};function o(V,h,mV){if(!V||V.LOGARITHMICDEPTH||V.indexOf&&V.indexOf("LOGARITHMICDEPTH")>=0){const V=mV.activeCamera;1===V.mode&&t.e.Error("Logarithmic depth is not compatible with orthographic cameras!",20),h.setFloat("logarithmicDepthConstant",2/(Math.log(V.maxZ+1)/Math.LN2))}}function n(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];mV&&V.fogEnabled&&(!h||h.applyFog)&&0!==V.fogMode&&(mV.setFloat4("vFogInfos",V.fogMode,V.fogStart,V.fogEnd,V.fogDensity),t?(V.fogColor.toLinearSpaceToRef(C,V.getEngine().useExactSrgbConversions),mV.setColor3("vFogColor",C)):mV.setColor3("vFogColor",V.fogColor))}function q(V,h,mV,t,L,N,A,k,C,o){const n=V.numMaxInfluencers||V.numInfluencers;return n<=0?0:(h.push("#define MORPHTARGETS"),V.hasPositions&&h.push("#define MORPHTARGETTEXTURE_HASPOSITIONS"),V.hasNormals&&h.push("#define MORPHTARGETTEXTURE_HASNORMALS"),V.hasTangents&&h.push("#define MORPHTARGETTEXTURE_HASTANGENTS"),V.hasUVs&&h.push("#define MORPHTARGETTEXTURE_HASUVS"),V.hasUV2s&&h.push("#define MORPHTARGETTEXTURE_HASUV2S"),V.hasColors&&h.push("#define MORPHTARGETTEXTURE_HASCOLORS"),V.supportsPositions&&L&&h.push("#define MORPHTARGETS_POSITION"),V.supportsNormals&&N&&h.push("#define MORPHTARGETS_NORMAL"),V.supportsTangents&&A&&h.push("#define MORPHTARGETS_TANGENT"),V.supportsUVs&&k&&h.push("#define MORPHTARGETS_UV"),V.supportsUV2s&&C&&h.push("#define MORPHTARGETS_UV2"),V.supportsColors&&o&&h.push("#define MORPHTARGETS_COLOR"),h.push("#define NUM_MORPH_INFLUENCERS "+n),V.isUsingTextureForTargets&&h.push("#define MORPHTARGETS_TEXTURE"),K.NUM_MORPH_INFLUENCERS=n,K.NORMAL=N,K.TANGENT=A,K.UV=k,K.UV2=C,K.COLOR=o,x(mV,t,K,L),n)}function x(V,h,mV){let L=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const A=mV.NUM_MORPH_INFLUENCERS;if(A>0&&N.b.LastCreatedEngine){const k=N.b.LastCreatedEngine.getCaps().maxVertexAttribs,C=h.morphTargetManager;if(null!==C&&void 0!==C&&C.isUsingTextureForTargets)return;const K=C&&C.supportsPositions&&L,o=C&&C.supportsNormals&&mV.NORMAL,n=C&&C.supportsTangents&&mV.TANGENT,q=C&&C.supportsUVs&&mV.UV1,x=C&&C.supportsUV2s&&mV.UV2,R=C&&C.supportsColors&&mV.VERTEXCOLOR;for(let mV=0;mV<A;mV++)K&&V.push("position"+mV),o&&V.push("normal"+mV),n&&V.push("tangent"+mV),q&&V.push("uv_"+mV),x&&V.push("uv2_"+mV),R&&V.push("color"+mV),V.length>k&&t.e.Error("Cannot add more vertex attributes for mesh "+h.name)}}function R(V){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];V.push("world0"),V.push("world1"),V.push("world2"),V.push("world3"),h&&(V.push("previousWorld0"),V.push("previousWorld1"),V.push("previousWorld2"),V.push("previousWorld3"))}function d(V,h){const mV=V.morphTargetManager;V&&mV&&h.setFloatArray("morphTargetInfluences",mV.influences)}function s(V,h){h.bindToEffect(V,"Scene")}function M(V,h,mV){h._needUVs=!0,h[mV]=!0,V.optimizeUVAllocation&&V.getTextureMatrix().isIdentityAs3x2()?(h[mV+"DIRECTUV"]=V.coordinatesIndex+1,h["MAINUV"+(V.coordinatesIndex+1)]=!0):h[mV+"DIRECTUV"]=0}function c(V,h,mV){const t=V.getTextureMatrix();h.zk(mV+"Matrix",t)}function z(V,h,mV){mV.BAKED_VERTEX_ANIMATION_TEXTURE&&mV.INSTANCES&&V.push("bakedVertexAnimationSettingsInstanced")}function Q(V,h,mV){var t;if(h&&V&&(V.computeBonesUsingShaders&&h._bonesComputationForcedToCPU&&(V.computeBonesUsingShaders=!1),V.useBones&&V.computeBonesUsingShaders&&V.skeleton)){const L=V.skeleton;if(L.isUsingTextureForMatrices&&h.getUniformIndex("boneTextureWidth")>-1){const mV=L.getTransformMatrixTexture(V);h.setTexture("boneSampler",mV),h.setFloat("boneTextureWidth",4*(L.bones.length+1))}else{const N=L.getTransformMatrices(V);N&&(h.setMatrices("mBones",N),mV&&V.DV().prePassRenderer&&V.DV().prePassRenderer.getIndex(2)&&(mV.previousBones[V.uniqueId]||(mV.previousBones[V.uniqueId]=N.slice()),h.setMatrices("mPreviousBones",mV.previousBones[V.uniqueId]),t=N,mV.previousBones[V.uniqueId].set(t)))}}}function J(V,h,mV,t,L){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];V._bindLight(h,mV,t,L,N)}function v(V,h,mV,t){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const N=Math.min(h.lightSources.length,L);for(let A=0;A<N;A++){J(h.lightSources[A],A,V,mV,"boolean"===typeof t?t:t.SPECULARTERM,h.receiveShadows)}}function D(V,h,mV,t){mV.NUM_BONE_INFLUENCERS>0&&(t.addCPUSkinningFallback(0,h),V.push("matricesIndices"),V.push("matricesWeights"),mV.NUM_BONE_INFLUENCERS>4&&(V.push("matricesIndicesExtra"),V.push("matricesWeightsExtra")))}function H(V,h){(h.INSTANCES||h.THIN_INSTANCES)&&R(V,!!h.PREPASS_VELOCITY),h.INSTANCESCOLOR&&V.push("instanceColor")}function j(V,h){let mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:4,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,L=0;for(let N=0;N<mV&&V["LIGHT"+N];N++)N>0&&(L=t+N,h.addFallback(L,"LIGHT"+N)),V.SHADOWS||(V["SHADOW"+N]&&h.addFallback(t,"SHADOW"+N),V["SHADOWPCF"+N]&&h.addFallback(t,"SHADOWPCF"+N),V["SHADOWPCSS"+N]&&h.addFallback(t,"SHADOWPCSS"+N),V["SHADOWPOISSON"+N]&&h.addFallback(t,"SHADOWPOISSON"+N),V["SHADOWESM"+N]&&h.addFallback(t,"SHADOWESM"+N),V["SHADOWCLOSEESM"+N]&&h.addFallback(t,"SHADOWCLOSEESM"+N));return L++}function l(V,h,mV,t,L,N,A){let k=arguments.length>7&&void 0!==arguments[7]&&arguments[7];A._areMiscDirty&&(A.LOGARITHMICDEPTH=mV,A.POINTSIZE=t,A.FOG=L&&function(V,h){return h.fogEnabled&&V.applyFog&&0!==h.fogMode}(V,h),A.NONUNIFORMSCALING=V.nonUniformScaling,A.ALPHATEST=N,A.DECAL_AFTER_DETAIL=k)}function G(V,h,mV,t){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4,N=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(!mV._areLightsDirty)return mV._needNormals;let A=0;const k={needNormals:mV._needNormals,needRebuild:!1,lightmapMode:!1,shadowEnabled:!1,specularEnabled:!1};if(V.lightsEnabled&&!N)for(const K of h.lightSources)if(y(V,h,K,A,mV,t,k),A++,A===L)break;mV.SPECULARTERM=k.specularEnabled,mV.SHADOWS=k.shadowEnabled;for(let K=A;K<L;K++)void 0!==mV["LIGHT"+K]&&(mV["LIGHT"+K]=!1,mV["HEMILIGHT"+K]=!1,mV["POINTLIGHT"+K]=!1,mV["DIRLIGHT"+K]=!1,mV["SPOTLIGHT"+K]=!1,mV["AREALIGHT"+K]=!1,mV["SHADOW"+K]=!1,mV["SHADOWCSM"+K]=!1,mV["SHADOWCSMDEBUG"+K]=!1,mV["SHADOWCSMNUM_CASCADES"+K]=!1,mV["SHADOWCSMUSESHADOWMAXZ"+K]=!1,mV["SHADOWCSMNOBLEND"+K]=!1,mV["SHADOWCSM_RIGHTHANDED"+K]=!1,mV["SHADOWPCF"+K]=!1,mV["SHADOWPCSS"+K]=!1,mV["SHADOWPOISSON"+K]=!1,mV["SHADOWESM"+K]=!1,mV["SHADOWCLOSEESM"+K]=!1,mV["SHADOWCUBE"+K]=!1,mV["SHADOWLOWQUALITY"+K]=!1,mV["SHADOWMEDIUMQUALITY"+K]=!1);const C=V.getEngine().getCaps();return void 0===mV.SHADOWFLOAT&&(k.needRebuild=!0),mV.SHADOWFLOAT=k.shadowEnabled&&(C.textureFloatRender&&C.textureFloatLinearFiltering||C.textureHalfFloatRender&&C.textureHalfFloatLinearFiltering),mV.LIGHTMAPEXCLUDED=k.lightmapMode,k.needRebuild&&mV.rebuild(),k.needNormals}function y(V,h,mV,t,L,N,k){switch(k.needNormals=!0,void 0===L["LIGHT"+t]&&(k.needRebuild=!0),L["LIGHT"+t]=!0,L["SPOTLIGHT"+t]=!1,L["HEMILIGHT"+t]=!1,L["POINTLIGHT"+t]=!1,L["DIRLIGHT"+t]=!1,L["AREALIGHT"+t]=!1,mV.prepareLightSpecificDefines(L,t),L["LIGHT_FALLOFF_PHYSICAL"+t]=!1,L["LIGHT_FALLOFF_GLTF"+t]=!1,L["LIGHT_FALLOFF_STANDARD"+t]=!1,mV.falloffType){case A.e.FALLOFF_GLTF:L["LIGHT_FALLOFF_GLTF"+t]=!0;break;case A.e.FALLOFF_PHYSICAL:L["LIGHT_FALLOFF_PHYSICAL"+t]=!0;break;case A.e.FALLOFF_STANDARD:L["LIGHT_FALLOFF_STANDARD"+t]=!0}if(N&&!mV.so.equalsFloats(0,0,0)&&(k.specularEnabled=!0),L["SHADOW"+t]=!1,L["SHADOWCSM"+t]=!1,L["SHADOWCSMDEBUG"+t]=!1,L["SHADOWCSMNUM_CASCADES"+t]=!1,L["SHADOWCSMUSESHADOWMAXZ"+t]=!1,L["SHADOWCSMNOBLEND"+t]=!1,L["SHADOWCSM_RIGHTHANDED"+t]=!1,L["SHADOWPCF"+t]=!1,L["SHADOWPCSS"+t]=!1,L["SHADOWPOISSON"+t]=!1,L["SHADOWESM"+t]=!1,L["SHADOWCLOSEESM"+t]=!1,L["SHADOWCUBE"+t]=!1,L["SHADOWLOWQUALITY"+t]=!1,L["SHADOWMEDIUMQUALITY"+t]=!1,h&&h.receiveShadows&&V.shadowsEnabled&&mV.shadowEnabled){const h=mV.getShadowGenerator(V.activeCamera)??mV.getShadowGenerator();if(h){const V=h.getShadowMap();V&&V.renderList&&V.renderList.length>0&&(k.shadowEnabled=!0,h.prepareDefines(L,t))}}mV.lightmapMode!=A.e.LIGHTMAP_DEFAULT?(k.lightmapMode=!0,L["LIGHTMAPEXCLUDED"+t]=!0,L["LIGHTMAPNOSPECULAR"+t]=mV.lightmapMode==A.e.LIGHTMAP_SHADOWSONLY):(L["LIGHTMAPEXCLUDED"+t]=!1,L["LIGHTMAPNOSPECULAR"+t]=!1)}function O(V,h,mV,t,L){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,A=arguments.length>6&&void 0!==arguments[6]&&arguments[6],C=function(V,h){let mV=!1;if(V.activeCamera){const t=h.CAMERA_ORTHOGRAPHIC?1:0,L=h.CAMERA_PERSPECTIVE?1:0,N=1===V.activeCamera.mode?1:0,A=0===V.activeCamera.mode?1:0;(t^N||L^A)&&(h.CAMERA_ORTHOGRAPHIC=1===N,h.CAMERA_PERSPECTIVE=1===A,mV=!0)}return mV}(V,t);!1!==N&&(C=(0,k.i)(mV,V,t)),t.DEPTHPREPASS!==!h.getColorWrite()&&(t.DEPTHPREPASS=!t.DEPTHPREPASS,C=!0),t.INSTANCES!==L&&(t.INSTANCES=L,C=!0),t.THIN_INSTANCES!==A&&(t.THIN_INSTANCES=A,C=!0),C&&t.markAsUnprocessed()}function I(V,h,mV,t){let L=arguments.length>4&&void 0!==arguments[4]&&arguments[4],N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],A=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(!h._areAttributesDirty&&h._needNormals===h._normals&&h._needUVs===h._uvs)return!1;h._normals=h._needNormals,h._uvs=h._needUVs,h.NORMAL=h._needNormals&&V.isVerticesDataPresent("normal"),h._needNormals&&V.isVerticesDataPresent("tangent")&&(h.TANGENT=!0);for(let k=1;k<=6;++k)h["UV"+k]=!!h._needUVs&&V.isVerticesDataPresent(`uv${1===k?"":k}`);if(mV){const mV=V.useVertexColors&&V.isVerticesDataPresent("color");h.VERTEXCOLOR=mV,h.VERTEXALPHA=V.hasVertexAlpha&&mV&&N}return V.isVerticesDataPresent("instanceColor")&&(V.hasInstances||V.hasThinInstances)&&(h.INSTANCESCOLOR=!0),t&&function(V,h){if(V.useBones&&V.computeBonesUsingShaders&&V.skeleton){h.NUM_BONE_INFLUENCERS=V.numBoneInfluencers;const mV=void 0!==h.BONETEXTURE;if(V.skeleton.isUsingTextureForMatrices&&mV)h.BONETEXTURE=!0;else{h.BonesPerMesh=V.skeleton.bones.length+1,h.BONETEXTURE=!mV&&void 0;const t=V.DV().prePassRenderer;if(t&&t.enabled){const mV=-1===t.excludedSkinnedMesh.indexOf(V);h.BONES_VELOCITY_ENABLED=mV}}}else h.NUM_BONE_INFLUENCERS=0,h.BonesPerMesh=0,void 0!==h.BONETEXTURE&&(h.BONETEXTURE=!1)}(V,h),L&&function(V,h){const mV=V.morphTargetManager;mV?(h.MORPHTARGETS_UV=mV.supportsUVs&&h.UV1,h.MORPHTARGETS_UV2=mV.supportsUV2s&&h.UV2,h.MORPHTARGETS_TANGENT=mV.supportsTangents&&h.TANGENT,h.MORPHTARGETS_NORMAL=mV.supportsNormals&&h.NORMAL,h.MORPHTARGETS_POSITION=mV.supportsPositions,h.MORPHTARGETS_COLOR=mV.supportsColors,h.MORPHTARGETTEXTURE_HASUVS=mV.hasUVs,h.MORPHTARGETTEXTURE_HASUV2S=mV.hasUV2s,h.MORPHTARGETTEXTURE_HASTANGENTS=mV.hasTangents,h.MORPHTARGETTEXTURE_HASNORMALS=mV.hasNormals,h.MORPHTARGETTEXTURE_HASPOSITIONS=mV.hasPositions,h.MORPHTARGETTEXTURE_HASCOLORS=mV.hasColors,h.NUM_MORPH_INFLUENCERS=mV.numMaxInfluencers||mV.numInfluencers,h.MORPHTARGETS=h.NUM_MORPH_INFLUENCERS>0,h.MORPHTARGETS_TEXTURE=mV.isUsingTextureForTargets):(h.MORPHTARGETS_UV=!1,h.MORPHTARGETS_UV2=!1,h.MORPHTARGETS_TANGENT=!1,h.MORPHTARGETS_NORMAL=!1,h.MORPHTARGETS_POSITION=!1,h.MORPHTARGETS_COLOR=!1,h.MORPHTARGETTEXTURE_HASUVS=!1,h.MORPHTARGETTEXTURE_HASUV2S=!1,h.MORPHTARGETTEXTURE_HASTANGENTS=!1,h.MORPHTARGETTEXTURE_HASNORMALS=!1,h.MORPHTARGETTEXTURE_HASPOSITIONS=!1,h.MORPHTARGETTEXTURE_HAS_COLORS=!1,h.MORPHTARGETS=!1,h.NUM_MORPH_INFLUENCERS=0)}(V,h),A&&function(V,h){const mV=V.bakedVertexAnimationManager;h.BAKED_VERTEX_ANIMATION_TEXTURE=!(!mV||!mV.isEnabled)}(V,h),!0}function r(V,h){if(V.activeCamera){const mV=h.MULTIVIEW;h.MULTIVIEW=null!==V.activeCamera.outputRenderTarget&&V.activeCamera.outputRenderTarget.getViewCount()>1,h.MULTIVIEW!=mV&&h.markAsUnprocessed()}}function T(V,h,mV){const t=h.ORDER_INDEPENDENT_TRANSPARENCY,L=h.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;h.ORDER_INDEPENDENT_TRANSPARENCY=V.useOrderIndependentTransparency&&mV,h.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!V.getEngine().getCaps().textureFloatLinearFiltering,t===h.ORDER_INDEPENDENT_TRANSPARENCY&&L===h.ORDER_INDEPENDENT_TRANSPARENCY_16BITS||h.markAsUnprocessed()}function F(V,h,mV){const t=h.PREPASS;if(!h._arePrePassDirty)return;const L=[{type:1,define:"PREPASS_POSITION",index:"PREPASS_POSITION_INDEX"},{type:9,define:"PREPASS_LOCAL_POSITION",index:"PREPASS_LOCAL_POSITION_INDEX"},{type:2,define:"PREPASS_VELOCITY",index:"PREPASS_VELOCITY_INDEX"},{type:11,define:"PREPASS_VELOCITY_LINEAR",index:"PREPASS_VELOCITY_LINEAR_INDEX"},{type:3,define:"PREPASS_REFLECTIVITY",index:"PREPASS_REFLECTIVITY_INDEX"},{type:0,define:"PREPASS_IRRADIANCE",index:"PREPASS_IRRADIANCE_INDEX"},{type:7,define:"PREPASS_ALBEDO_SQRT",index:"PREPASS_ALBEDO_SQRT_INDEX"},{type:5,define:"PREPASS_DEPTH",index:"PREPASS_DEPTH_INDEX"},{type:10,define:"PREPASS_SCREENSPACE_DEPTH",index:"PREPASS_SCREENSPACE_DEPTH_INDEX"},{type:6,define:"PREPASS_NORMAL",index:"PREPASS_NORMAL_INDEX"},{type:8,define:"PREPASS_WORLD_NORMAL",index:"PREPASS_WORLD_NORMAL_INDEX"}];if(V.prePassRenderer&&V.prePassRenderer.enabled&&mV){h.PREPASS=!0,h.SCENE_MRT_COUNT=V.prePassRenderer.mrtCount,h.PREPASS_NORMAL_WORLDSPACE=V.prePassRenderer.generateNormalsInWorldSpace,h.PREPASS_COLOR=!0,h.PREPASS_COLOR_INDEX=0;for(let mV=0;mV<L.length;mV++){const t=V.prePassRenderer.getIndex(L[mV].type);-1!==t?(h[L[mV].define]=!0,h[L[mV].index]=t):h[L[mV].define]=!1}}else{h.PREPASS=!1;for(let V=0;V<L.length;V++)h[L[V].define]=!1}h.PREPASS!=t&&(h.markAsUnprocessed(),h.markAsImageProcessingDirty())}function p(V,h,mV,t){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,N=arguments.length>5&&void 0!==arguments[5]&&arguments[5],A=arguments.length>6&&void 0!==arguments[6]&&arguments[6];L&&L.push("Light"+V),N||(h.push("vLightData"+V,"vLightDiffuse"+V,"vLightSpecular"+V,"vLightDirection"+V,"vLightWidth"+V,"vLightHeight"+V,"vLightFalloff"+V,"vLightGround"+V,"lightMatrix"+V,"shadowsInfo"+V,"depthValues"+V),mV.push("shadowTexture"+V),mV.push("depthTexture"+V),h.push("viewFrustumZ"+V,"cascadeBlendFactor"+V,"lightSizeUVCorrection"+V,"depthCorrection"+V,"penumbraDarkness"+V,"frustumLengths"+V),t&&(mV.push("projectionLightTexture"+V),h.push("textureProjectionMatrix"+V)),A&&mV.push("iesLightTexture"+V))}function Z(V,h,mV){let t,L,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:4;if(V.uniformsNames){const A=V;t=A.uniformsNames,L=A.uniformBuffersNames,h=A.samplers,mV=A.defines,N=A.maxSimultaneousLights||0}else t=V,h||(h=[]);for(let A=0;A<N&&mV["LIGHT"+A];A++)p(A,t,h,mV["PROJECTEDLIGHTTEXTURE"+A],L,!1,mV["IESLIGHTTEXTURE"+A]);mV.NUM_MORPH_INFLUENCERS&&(t.push("morphTargetInfluences"),t.push("morphTargetCount")),mV.BAKED_VERTEX_ANIMATION_TEXTURE&&(t.push("bakedVertexAnimationSettings"),t.push("bakedVertexAnimationTextureSizeInverted"),t.push("bakedVertexAnimationTime"),h.push("bakedVertexAnimationTexture"))}},12711:(V,h,mV)=>{mV.d(h,{d:()=>N});var t=mV(12422),L=mV(12718);class N extends L.c{constructor(V,h){let mV=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(V,h,void 0,arguments.length>3&&void 0!==arguments[3]&&arguments[3]),this._normalMatrix=new t.Matrix,this._storeEffectOnSubMeshes=mV}getEffect(){return this._storeEffectOnSubMeshes?this._activeEffect:super.getEffect()}isReady(V,h){return!!V&&(!this._storeEffectOnSubMeshes||(!V.dk||0===V.dk.length||this.isReadyForSubMesh(V,V.dk[0],h)))}_isReadyForSubMesh(V){const h=V.materialDefines;return!(this.checkReadyOnEveryCall||!V.effect||!h||h._renderId!==this.DV().getRenderId())}bindOnlyWorldMatrix(V){this._activeEffect.setMatrix("world",V)}bindOnlyNormalMatrix(V){this._activeEffect.setMatrix("normalMatrix",V)}bind(V,h){h&&this.bindForSubMesh(V,h,h.dk[0])}_afterBind(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,mV=arguments.length>2?arguments[2]:void 0;super._afterBind(V,h,mV),this.DV()._cachedEffect=h,mV?mV._drawWrapper._forceRebindOnNextCall=!1:this._drawWrapper._forceRebindOnNextCall=!1}_mustRebind(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return mV._drawWrapper._forceRebindOnNextCall||V.isCachedMaterialInvalid(this,h,t)}dispose(V,h,mV){this._activeEffect=void 0,super.dispose(V,h,mV)}}},12744:(V,h,mV)=>{mV.d(h,{d:()=>k,e:()=>C});var t=mV(12409),L=mV(12422),N=mV(12413);class A{static extractMinAndMaxIndexed(V,h,mV,t,L,N){for(let A=mV;A<mV+t;A++){const mV=3*h[A],t=V[mV],k=V[mV+1],C=V[mV+2];L.minimizeInPlaceFromFloats(t,k,C),N.maximizeInPlaceFromFloats(t,k,C)}}static extractMinAndMax(V,h,mV,t,L,N){for(let A=h,k=h*t;A<h+mV;A++,k+=t){const h=V[k],mV=V[k+1],t=V[k+2];L.minimizeInPlaceFromFloats(h,mV,t),N.maximizeInPlaceFromFloats(h,mV,t)}}}function k(V,h,mV,t){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const k=new L.sh(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),C=new L.sh(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return A.extractMinAndMaxIndexed(V,h,mV,t,k,C),N&&(k.x-=k.x*N.x+N.y,k.y-=k.y*N.x+N.y,k.z-=k.z*N.x+N.y,C.x+=C.x*N.x+N.y,C.y+=C.y*N.x+N.y,C.z+=C.z*N.x+N.y),{minimum:k,maximum:C}}function C(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,N=arguments.length>4?arguments[4]:void 0;const k=new L.sh(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),C=new L.sh(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return N||(N=3),A.extractMinAndMax(V,h,mV,N,k,C),t&&(k.x-=k.x*t.x+t.y,k.y-=k.y*t.x+t.y,k.z-=k.z*t.x+t.y,C.x+=C.x*t.x+t.y,C.y+=C.y*t.x+t.y,C.z+=C.z*t.x+t.y),{minimum:k,maximum:C}}(0,t.e)([N.e.filter((function(){for(var V=arguments.length,h=new Array(V),mV=0;mV<V;mV++)h[mV]=arguments[mV];let[t,L]=h;return!Array.isArray(t)&&!Array.isArray(L)}))],A,"extractMinAndMaxIndexed",null),(0,t.e)([N.e.filter((function(){for(var V=arguments.length,h=new Array(V),mV=0;mV<V;mV++)h[mV]=arguments[mV];let[t]=h;return!Array.isArray(t)}))],A,"extractMinAndMax",null)},12723:(V,h,mV)=>{mV.d(h,{b:()=>C});var t=mV(12481),L=mV(12730),N=mV(12734),A=mV(12744),k=mV(12532);class C{get materialDefines(){var V;return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.defines:null===(V=this._getDrawWrapper())||void 0===V?void 0:V.defines}set materialDefines(V){(this._mainDrawWrapperOverride??this._getDrawWrapper(void 0,!0)).defines=V}_getDrawWrapper(V){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];V=V??this._engine.currentRenderPassId;let mV=this._drawWrappers[V];return!mV&&h&&(this._drawWrappers[V]=mV=new k.e(this._mesh.DV().getEngine())),mV}_removeDrawWrapper(V){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];var mV;arguments.length>1&&void 0!==arguments[1]&&!arguments[1]||(null===(mV=this._drawWrappers[V])||void 0===mV||mV.dispose(h));this._drawWrappers[V]=void 0}get effect(){var V;return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.effect:(null===(V=this._getDrawWrapper())||void 0===V?void 0:V.effect)??null}get _drawWrapper(){return this._mainDrawWrapperOverride??this._getDrawWrapper(void 0,!0)}get _drawWrapperOverride(){return this._mainDrawWrapperOverride}_setMainDrawWrapperOverride(V){this._mainDrawWrapperOverride=V}setEffect(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,mV=arguments.length>2?arguments[2]:void 0,t=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const L=this._drawWrapper;L.setEffect(V,h,t),void 0!==mV&&(L.materialContext=mV),V||(L.defines=null,L.materialContext=void 0)}resetDrawCache(V){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this._drawWrappers){if(void 0!==V)return void this._removeDrawWrapper(V,!0,h);for(const V of this._drawWrappers)null===V||void 0===V||V.dispose(h)}this._drawWrappers=[]}static AddToMesh(V,h,mV,t,L,N,A){return new C(V,h,mV,t,L,N,A,!(arguments.length>7&&void 0!==arguments[7])||arguments[7])}constructor(V,h,mV,t,L,N,A){let k=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],C=!(arguments.length>8&&void 0!==arguments[8])||arguments[8];this.materialIndex=V,this.verticesStart=h,this.verticesCount=mV,this.indexStart=t,this.indexCount=L,this._mainDrawWrapperOverride=null,this._linesIndexCount=0,this._linesIndexBuffer=null,this._lastColliderWorldVertices=null,this._lastColliderTransformMatrix=null,this._wasDispatched=!1,this._renderId=0,this._alphaIndex=0,this._distanceToCamera=0,this._currentMaterial=null,this._mesh=N,this._renderingMesh=A||N,C&&N.dk.push(this),this._engine=this._mesh.DV().getEngine(),this.resetDrawCache(),this._trianglePlanes=[],this._id=N.dk.length-1,k&&(this.refreshBoundingInfo(),N.Qk(!0))}get IsGlobal(){return 0===this.verticesStart&&this.verticesCount===this._mesh.getTotalVertices()&&0===this.indexStart&&this.indexCount===this._mesh.getTotalIndices()}getBoundingInfo(){return this.IsGlobal||this._mesh.hasThinInstances?this._mesh.getBoundingInfo():this._boundingInfo}setBoundingInfo(V){return this._boundingInfo=V,this}getMesh(){return this._mesh}getRenderingMesh(){return this._renderingMesh}getReplacementMesh(){return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null}getEffectiveMesh(){const V=this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null;return V||this._renderingMesh}ZV(){let V=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];const h=this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)??this._renderingMesh.material;if(!h)return V&&this._mesh.DV()._hasDefaultMaterial?this._mesh.DV().defaultMaterial:null;if(this._isMultiMaterial(h)){const V=h.getSubMaterial(this.materialIndex);return this._currentMaterial!==V&&(this._currentMaterial=V,this.resetDrawCache()),V}return h}_isMultiMaterial(V){return void 0!==V.getSubMaterial}refreshBoundingInfo(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(this._lastColliderWorldVertices=null,this.IsGlobal||!this._renderingMesh||!this._renderingMesh.Jk)return this;if(V||(V=this._renderingMesh.getVerticesData(t.i.PositionKind)),!V)return this._boundingInfo=this._mesh.getBoundingInfo(),this;const h=this._renderingMesh.vk();let mV;if(0===this.indexStart&&this.indexCount===h.length){const V=this._renderingMesh.getBoundingInfo();mV={minimum:V.minimum.clone(),maximum:V.maximum.clone()}}else mV=(0,A.d)(V,h,this.indexStart,this.indexCount,this._renderingMesh.Jk.boundingBias);return this._boundingInfo?this._boundingInfo.reConstruct(mV.minimum,mV.maximum):this._boundingInfo=new N.e(mV.minimum,mV.maximum),this}_checkCollision(V){return this.getBoundingInfo()._checkCollision(V)}updateBoundingInfo(V){let h=this.getBoundingInfo();return h||(this.refreshBoundingInfo(),h=this.getBoundingInfo()),h&&h.update(V),this}isInFrustum(V){const h=this.getBoundingInfo();return!!h&&h.isInFrustum(V,this._mesh.Qn)}isCompletelyInFrustum(V){const h=this.getBoundingInfo();return!!h&&h.isCompletelyInFrustum(V)}render(V){return this._renderingMesh.render(this,V,this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:void 0),this}_getLinesIndexBuffer(V,h){if(!this._linesIndexBuffer){const mV=6*Math.floor(this.indexCount/3),t=this.verticesStart+this.verticesCount>65535?new Uint32Array(mV):new Uint16Array(mV);let L=0;if(0===V.length)for(let V=this.indexStart;V<this.indexStart+this.indexCount;V+=3)t[L++]=V,t[L++]=V+1,t[L++]=V+1,t[L++]=V+2,t[L++]=V+2,t[L++]=V;else for(let h=this.indexStart;h<this.indexStart+this.indexCount;h+=3)t[L++]=V[h],t[L++]=V[h+1],t[L++]=V[h+1],t[L++]=V[h+2],t[L++]=V[h+2],t[L++]=V[h];this._linesIndexBuffer=h.createIndexBuffer(t),this._linesIndexCount=t.length}return this._linesIndexBuffer}canIntersects(V){const h=this.getBoundingInfo();return!!h&&V.intersectsBox(h.boundingBox)}intersects(V,h,mV,t,L){const N=this.ZV();if(!N)return null;let A=3,k=!1;switch(N.fillMode){case 3:case 5:case 6:case 8:return null;case 7:A=1,k=!0}return 4===N.fillMode?mV.length?this._intersectLines(V,h,mV,this._mesh.intersectionThreshold,t):this._intersectUnIndexedLines(V,h,mV,this._mesh.intersectionThreshold,t):!mV.length&&this._mesh._unIndexed?this._intersectUnIndexedTriangles(V,h,mV,t,L):this._intersectTriangles(V,h,mV,A,k,t,L)}_intersectLines(V,h,mV,t,N){let A=null;for(let k=this.indexStart;k<this.indexStart+this.indexCount;k+=2){const C=h[mV[k]],K=h[mV[k+1]],o=V.intersectionSegment(C,K,t);if(!(o<0)&&((N||!A||o<A.distance)&&(A=new L.e(null,null,o),A.faceId=k/2,N)))break}return A}_intersectUnIndexedLines(V,h,mV,t,N){let A=null;for(let k=this.verticesStart;k<this.verticesStart+this.verticesCount;k+=2){const mV=h[k],C=h[k+1],K=V.intersectionSegment(mV,C,t);if(!(K<0)&&((N||!A||K<A.distance)&&(A=new L.e(null,null,K),A.faceId=k/2,N)))break}return A}_intersectTriangles(V,h,mV,t,L,N,A){let k=null,C=-1;for(let K=this.indexStart;K<this.indexStart+this.indexCount-(3-t);K+=t){C++;const t=mV[K],o=mV[K+1],n=mV[K+2];if(L&&4294967295===n){K+=2;continue}const q=h[t],x=h[o],R=h[n];if(!q||!x||!R)continue;if(A&&!A(q,x,R,V,t,o,n))continue;const d=V.intersectsTriangle(q,x,R);if(d){if(d.distance<0)continue;if((N||!k||d.distance<k.distance)&&(k=d,k.faceId=C,N))break}}return k}_intersectUnIndexedTriangles(V,h,mV,t,L){let N=null;for(let A=this.verticesStart;A<this.verticesStart+this.verticesCount;A+=3){const mV=h[A],k=h[A+1],C=h[A+2];if(L&&!L(mV,k,C,V,-1,-1,-1))continue;const K=V.intersectsTriangle(mV,k,C);if(K){if(K.distance<0)continue;if((t||!N||K.distance<N.distance)&&(N=K,N.faceId=A/3,t))break}}return N}_rebuild(){this._linesIndexBuffer&&(this._linesIndexBuffer=null)}clone(V,h){const mV=new C(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,V,h,!1);if(!this.IsGlobal){const V=this.getBoundingInfo();if(!V)return mV;mV._boundingInfo=new N.e(V.minimum,V.maximum)}return mV}dispose(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this._linesIndexBuffer&&(this._mesh.DV().getEngine()._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=null);const h=this._mesh.dk.indexOf(this);this._mesh.dk.splice(h,1),this.resetDrawCache(void 0,V)}getClassName(){return"SubMesh"}static CreateFromIndices(V,h,mV,t,L){let N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],A=Number.MAX_VALUE,k=-Number.MAX_VALUE;const K=(L||t).vk();for(let C=h;C<h+mV;C++){const V=K[C];V<A&&(A=V),V>k&&(k=V)}return new C(V,A,k-A+1,h,mV,t,L,N)}}}}]);