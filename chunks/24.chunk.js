"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[24],{12861:(V,I,m)=>{m.d(I,{e:()=>v,f:()=>b,h:()=>c,l:()=>H});var C=m(11076),l=m(11040),s=m(11074),F=m(11488),k=m(11161),j=m(11507),E=(m(11596),m(11530)),K=m(11085);m(11583),m(11560),m(11674);const Y="image/png",X=2,O=[134,22,135,150,246,214,150,54];function v(V){const I=new DataView(V.buffer,V.byteOffset,V.byteLength);let m=0;for(let F=0;F<O.length;F++)if(I.getUint8(m++)!==O[F])return K.d.Error("Not a babylon environment map"),null;let C="",l=0;for(;l=I.getUint8(m++);)C+=String.fromCharCode(l);let s=JSON.parse(C);return s=N(s),s.binaryDataPosition=m,s.oE&&(s.oE.lodGenerationScale=s.oE.lodGenerationScale||.8),s}function N(V){if(V.version>X)throw new Error(`Unsupported babylon environment map version "${V.version}". Latest supported version is "${X}".`);return 2===V.version?V:V={...V,version:2,imageType:Y}}function t(V,I){const m=(I=N(I)).oE;let C=Math.log2(I.width);if(C=Math.round(C)+1,m.mipmaps.length!==6*C)throw new Error(`Unsupported specular mipmaps number "${m.mipmaps.length}"`);const l=new Array(C);for(let s=0;s<C;s++){l[s]=new Array(6);for(let C=0;C<6;C++){const F=m.mipmaps[6*s+C];l[s][C]=new Uint8Array(V.buffer,V.byteOffset+I.binaryDataPosition+F.position,F.length)}}return l}function D(V,I){var m;I=N(I);const C=new Array(6),l=null===(m=I.irradiance)||void 0===m?void 0:m.irradianceTexture;if(l){if(6!==l.faces.length)throw new Error(`Incorrect irradiance texture faces number "${l.faces.length}"`);for(let m=0;m<6;m++){const s=l.faces[m];C[m]=new Uint8Array(V.buffer,V.byteOffset+I.binaryDataPosition+s.position,s.length)}}return C}function b(V,I,m){var C;const s=(m=N(m)).oE;if(!s)return Promise.resolve([]);V._lodGenerationScale=s.lodGenerationScale;const F=[],k=t(I,m);F.push(n(V,k,m.imageType));const j=null===(C=m.irradiance)||void 0===C?void 0:C.irradianceTexture;if(j){var E,K;const C=D(I,m);let s=null;null!==(E=m.irradiance)&&void 0!==E&&null!==(K=E.irradianceTexture)&&void 0!==K&&K.dominantDirection&&(s=l.m.Ik(m.irradiance.irradianceTexture.dominantDirection)),F.push(x(V,C,j.size,m.imageType,s))}return Promise.all(F)}async function T(V,I,m,C,l,s,F,k,j,E,K){return await new Promise(((Y,X)=>{if(m){const m=I.createTexture(null,!0,!0,null,1,null,(V=>{X(V)}),V);null===C||void 0===C||C.onEffectCreatedObservable.addOnce((k=>{k.executeWhenCompiled((()=>{C.externalTextureSamplerBinding=!0,C.onApply=C=>{C._bindTexture("textureSampler",m),C.setFloat2("scale",1,I._features.needsInvertingBitmap&&V instanceof ImageBitmap?-1:1)},I.scenes.length&&(I.scenes[0].postProcessManager.directRender([C],E,!0,s,F),I.restoreDefaultFramebuffer(),m.dispose(),URL.revokeObjectURL(l),Y())}))}))}else{if(I._uploadImageToTexture(K,V,s,F),k){const m=j[F];m&&I._uploadImageToTexture(m._texture,V,s,0)}Y()}}))}async function n(V,I){let m=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Y;const C=V.getEngine();V.format=5,V.type=0,V.generateMipMaps=!0,V._cachedAnisotropicFilteringLevel=null,C.updateTextureSamplingMode(3,V),await S(V,I,!0,m),V.isReady=!0}async function x(V,I,m){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Y,l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const s=V.getEngine(),F=new k.e(s,5),E=new j.b(s,F);V._irradianceTexture=E,E._dominantDirection=l,F.isCube=!0,F.format=5,F.type=0,F.generateMipMaps=!0,F._cachedAnisotropicFilteringLevel=null,F.generateMipMaps=!0,F.width=m,F.height=m,s.updateTextureSamplingMode(3,F),await S(F,[I],!1,C),s.generateMipMapsForCubemap(F),F.isReady=!0}async function S(V,I,l){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Y;if(!C.d.IsExponentOfTwo(V.width))throw new Error("Texture size must be a power of two");const K=(0,s.ILog2)(V.width)+1,X=V.getEngine();let O=!1,v=!1,N=null,t=null,D=null;const b=X.getCaps();b.textureLOD?X._features.supportRenderAndCopyToLodForFloatTextures?b.textureHalfFloatRender&&b.textureHalfFloatLinearFiltering?(O=!0,V.type=2):b.textureFloatRender&&b.textureFloatLinearFiltering&&(O=!0,V.type=1):O=!1:(O=!1,v=l);let n=0;if(O)X.isWebGPU?(n=1,await m.e(21).then(m.bind(m,13759))):await m.e(14).then(m.bind(m,13761)),N=new E.e("rgbdDecode","rgbdDecode",null,null,1,null,3,X,!1,void 0,V.type,void 0,null,!1,void 0,n),V._isRGBD=!1,V.invertY=!1,t=X.createRenderTargetCubeTexture(V.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:V.type,format:5});else if(V._isRGBD=!0,V.invertY=!0,v){const I=3;D={};const m=V._lodGenerationScale,C=V._lodGenerationOffset;for(let l=0;l<I;l++){const s=(K-1)*m+C,F=C+(s-C)*(1-l/(I-1)),E=Math.round(Math.min(Math.max(F,0),s)),Y=new k.e(X,2);Y.isCube=!0,Y.invertY=!0,Y.generateMipMaps=!1,X.updateTextureSamplingMode(2,Y);const O=new j.b(null);switch(O._isCube=!0,O._texture=Y,D[E]=O,l){case 0:V._lodTextureLow=O;break;case 1:V._lodTextureMid=O;break;case 2:V._lodTextureHigh=O}}}const x=[];for(let m=0;m<I.length;m++)for(let C=0;C<6;C++){const l=I[m][C],s=new Blob([l],{type:F}),k=URL.createObjectURL(s);let j;if(X._features.forceBitmapOverHTMLImageElement)j=X.createImageBitmap(s,{premultiplyAlpha:"none"}).then((async I=>await T(I,X,O,N,k,C,m,v,D,t,V)));else{const I=new Image;I.src=k,j=new Promise(((l,s)=>{I.onload=()=>{T(I,X,O,N,k,C,m,v,D,t,V).then((()=>l())).catch((V=>{s(V)}))},I.onerror=V=>{s(V)}}))}x.push(j)}if(await Promise.all(x),I.length<K){let m;const C=Math.pow(2,K-1-I.length),l=C*C*4;switch(V.type){case 0:m=new Uint8Array(l);break;case 2:m=new Uint16Array(l);break;case 1:m=new Float32Array(l)}for(let s=I.length;s<K;s++)for(let I=0;I<6;I++){var S;X._uploadArrayBufferViewToTexture((null===(S=t)||void 0===S?void 0:S.texture)||V,m,I,s)}}if(t){const I=V._irradianceTexture;V._irradianceTexture=null,X._releaseTexture(V),t._swapAndDie(V),V._irradianceTexture=I}N&&N.dispose(),v&&(V._lodTextureHigh&&V._lodTextureHigh._texture&&(V._lodTextureHigh._texture.isReady=!0),V._lodTextureMid&&V._lodTextureMid._texture&&(V._lodTextureMid._texture.isReady=!0),V._lodTextureLow&&V._lodTextureLow._texture&&(V._lodTextureLow._texture.isReady=!0))}function c(V,I){const m=(I=N(I)).irradiance;if(!m)return;const C=new F.c;l.m.FromArrayToRef(m.x,0,C.x),l.m.FromArrayToRef(m.y,0,C.y),l.m.FromArrayToRef(m.z,0,C.z),l.m.FromArrayToRef(m.xx,0,C.xx),l.m.FromArrayToRef(m.yy,0,C.yy),l.m.FromArrayToRef(m.zz,0,C.zz),l.m.FromArrayToRef(m.yz,0,C.yz),l.m.FromArrayToRef(m.zx,0,C.zx),l.m.FromArrayToRef(m.xy,0,C.xy),V._sphericalPolynomial=C}function H(V,I,m,C,l){const s=n(V.getEngine().createRawCubeTexture(null,V.width,V.format,V.type,V.generateMipMaps,V.invertY,V.samplingMode,V._compression),I).then((()=>V));return V.onRebuildCallback=V=>({proxy:s,isReady:!0,isAsync:!0}),V._source=13,V._bufferViewArrayArray=I,V._lodGenerationScale=C,V._lodGenerationOffset=l,V._sphericalPolynomial=m,n(V,I).then((()=>(V.isReady=!0,V)))}}}]);