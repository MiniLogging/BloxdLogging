"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[97],{14559:(w,p,e)=>{e.r(p),e.d(p,{EasingFunctionType:()=>r,FlowGraphEasingBlock:()=>E});var r,I=e(13355),d=e(12893),f=e(12872),q=e(11038);!function(w){w[w.CircleEase=0]="CircleEase",w[w.BackEase=1]="BackEase",w[w.BounceEase=2]="BounceEase",w[w.CubicEase=3]="CubicEase",w[w.ElasticEase=4]="ElasticEase",w[w.ExponentialEase=5]="ExponentialEase",w[w.PowerEase=6]="PowerEase",w[w.QuadraticEase=7]="QuadraticEase",w[w.QuarticEase=8]="QuarticEase",w[w.QuinticEase=9]="QuinticEase",w[w.SineEase=10]="SineEase",w[w.BezierCurveEase=11]="BezierCurveEase"}(r||(r={}));class E extends d.e{constructor(w){super(w),this.config=w,this._easingFunctions={},this.type=this.registerDataInput("type",f.c,11),this.mode=this.registerDataInput("mode",f.o,0),this.parameters=this.registerDataInput("parameters",f.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",f.c)}_updateOutputs(w){const p=this.type.getValue(w),e=this.mode.getValue(w),r=this.parameters.getValue(w);if(void 0===p||void 0===e)return;const d=`${p}-${e}-${r.join("-")}`;if(!this._easingFunctions[d]){const w=function(w){for(var p=arguments.length,e=new Array(p>1?p-1:0),r=1;r<p;r++)e[r-1]=arguments[r];switch(w){case 11:return new I.g(...e);case 0:return new I.k;case 1:return new I.d(...e);case 2:return new I.j(...e);case 3:return new I.n;case 4:return new I.r(...e);case 5:return new I.v(...e);default:throw new Error("Easing type not yet implemented")}}(p,...r);w.setEasingMode(e),this._easingFunctions[d]=w}this.easingFunction.setValue(this._easingFunctions[d],w)}getClassName(){return"FlowGraphEasingBlock"}}(0,q.d)("FlowGraphEasingBlock",E)}}]);