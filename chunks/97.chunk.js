"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[97],{14539:(Z,c,L)=>{L.r(c),L.d(c,{EasingFunctionType:()=>k,FlowGraphEasingBlock:()=>p});var k,N=L(13296),R=L(12846),G=L(12825),V=L(11012);!function(Z){Z[Z.CircleEase=0]="CircleEase",Z[Z.BackEase=1]="BackEase",Z[Z.BounceEase=2]="BounceEase",Z[Z.CubicEase=3]="CubicEase",Z[Z.ElasticEase=4]="ElasticEase",Z[Z.ExponentialEase=5]="ExponentialEase",Z[Z.PowerEase=6]="PowerEase",Z[Z.QuadraticEase=7]="QuadraticEase",Z[Z.QuarticEase=8]="QuarticEase",Z[Z.QuinticEase=9]="QuinticEase",Z[Z.SineEase=10]="SineEase",Z[Z.BezierCurveEase=11]="BezierCurveEase"}(k||(k={}));class p extends R.c{constructor(Z){super(Z),this.config=Z,this._easingFunctions={},this.type=this.registerDataInput("type",G.e,11),this.mode=this.registerDataInput("mode",G.t,0),this.parameters=this.registerDataInput("parameters",G.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",G.e)}_updateOutputs(Z){const c=this.type.getValue(Z),L=this.mode.getValue(Z),k=this.parameters.getValue(Z);if(void 0===c||void 0===L)return;const R=`${c}-${L}-${k.join("-")}`;if(!this._easingFunctions[R]){const Z=function(Z){for(var c=arguments.length,L=new Array(c>1?c-1:0),k=1;k<c;k++)L[k-1]=arguments[k];switch(Z){case 11:return new N.f(...L);case 0:return new N.l;case 1:return new N.d(...L);case 2:return new N.h(...L);case 3:return new N.m;case 4:return new N.r(...L);case 5:return new N.s(...L);default:throw new Error("Easing type not yet implemented")}}(c,...k);Z.setEasingMode(L),this._easingFunctions[R]=Z}this.easingFunction.setValue(this._easingFunctions[R],Z)}getClassName(){return"FlowGraphEasingBlock"}}(0,V.g)("FlowGraphEasingBlock",p)}}]);