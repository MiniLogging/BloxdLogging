"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[97],{14702:(G,V,W)=>{W.r(V),W.d(V,{EasingFunctionType:()=>J,FlowGraphEasingBlock:()=>X});var J,R=W(13484),d=W(13093),k=W(13071),z=W(11159);!function(G){G[G.CircleEase=0]="CircleEase",G[G.BackEase=1]="BackEase",G[G.BounceEase=2]="BounceEase",G[G.CubicEase=3]="CubicEase",G[G.ElasticEase=4]="ElasticEase",G[G.ExponentialEase=5]="ExponentialEase",G[G.PowerEase=6]="PowerEase",G[G.QuadraticEase=7]="QuadraticEase",G[G.QuarticEase=8]="QuarticEase",G[G.QuinticEase=9]="QuinticEase",G[G.SineEase=10]="SineEase",G[G.BezierCurveEase=11]="BezierCurveEase"}(J||(J={}));class X extends d.c{constructor(G){super(G),this.config=G,this._easingFunctions={},this.type=this.registerDataInput("type",k.b,11),this.mode=this.registerDataInput("mode",k.r,0),this.parameters=this.registerDataInput("parameters",k.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",k.b)}_updateOutputs(G){const V=this.type.getValue(G),W=this.mode.getValue(G),J=this.parameters.getValue(G);if(void 0===V||void 0===W)return;const d=`${V}-${W}-${J.join("-")}`;if(!this._easingFunctions[d]){const G=function(G){for(var V=arguments.length,W=new Array(V>1?V-1:0),J=1;J<V;J++)W[J-1]=arguments[J];switch(G){case 11:return new R.d(...W);case 0:return new R.j;case 1:return new R.c(...W);case 2:return new R.f(...W);case 3:return new R.n;case 4:return new R.r(...W);case 5:return new R.v(...W);default:throw new Error("Easing type not yet implemented")}}(V,...J);G.setEasingMode(W),this._easingFunctions[d]=G}this.easingFunction.setValue(this._easingFunctions[d],G)}getClassName(){return"FlowGraphEasingBlock"}}(0,z.d)("FlowGraphEasingBlock",X)}}]);