"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[97],{14266:(q,c,U)=>{U.r(c),U.d(c,{EasingFunctionType:()=>J,FlowGraphEasingBlock:()=>n});var J,Q=U(13096),s=U(12667),g=U(12648),X=U(10850);!function(q){q[q.CircleEase=0]="CircleEase",q[q.BackEase=1]="BackEase",q[q.BounceEase=2]="BounceEase",q[q.CubicEase=3]="CubicEase",q[q.ElasticEase=4]="ElasticEase",q[q.ExponentialEase=5]="ExponentialEase",q[q.PowerEase=6]="PowerEase",q[q.QuadraticEase=7]="QuadraticEase",q[q.QuarticEase=8]="QuarticEase",q[q.QuinticEase=9]="QuinticEase",q[q.SineEase=10]="SineEase",q[q.BezierCurveEase=11]="BezierCurveEase"}(J||(J={}));class n extends s.c{constructor(q){super(q),this.config=q,this._easingFunctions={},this.type=this.registerDataInput("type",g.c,11),this.mode=this.registerDataInput("mode",g.t,0),this.parameters=this.registerDataInput("parameters",g.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",g.c)}_updateOutputs(q){const c=this.type.getValue(q),U=this.mode.getValue(q),J=this.parameters.getValue(q);if(void 0===c||void 0===U)return;const s=`${c}-${U}-${J.join("-")}`;if(!this._easingFunctions[s]){const q=function(q){for(var c=arguments.length,U=new Array(c>1?c-1:0),J=1;J<c;J++)U[J-1]=arguments[J];switch(q){case 11:return new Q.f(...U);case 0:return new Q.k;case 1:return new Q.d(...U);case 2:return new Q.i(...U);case 3:return new Q.o;case 4:return new Q.u(...U);case 5:return new Q.v(...U);default:throw new Error("Easing type not yet implemented")}}(c,...J);q.setEasingMode(U),this._easingFunctions[s]=q}this.easingFunction.setValue(this._easingFunctions[s],q)}getClassName(){return"FlowGraphEasingBlock"}}(0,X.f)("FlowGraphEasingBlock",n)}}]);