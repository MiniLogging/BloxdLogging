"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[97],{14570:(V,I,m)=>{m.r(I),m.d(I,{EasingFunctionType:()=>C,FlowGraphEasingBlock:()=>j});var C,l=m(13362),s=m(12921),F=m(12899),k=m(11048);!function(V){V[V.CircleEase=0]="CircleEase",V[V.BackEase=1]="BackEase",V[V.BounceEase=2]="BounceEase",V[V.CubicEase=3]="CubicEase",V[V.ElasticEase=4]="ElasticEase",V[V.ExponentialEase=5]="ExponentialEase",V[V.PowerEase=6]="PowerEase",V[V.QuadraticEase=7]="QuadraticEase",V[V.QuarticEase=8]="QuarticEase",V[V.QuinticEase=9]="QuinticEase",V[V.SineEase=10]="SineEase",V[V.BezierCurveEase=11]="BezierCurveEase"}(C||(C={}));class j extends s.e{constructor(V){super(V),this.config=V,this._easingFunctions={},this.type=this.registerDataInput("type",F.b,11),this.mode=this.registerDataInput("mode",F.r,0),this.parameters=this.registerDataInput("parameters",F.b,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",F.b)}_updateOutputs(V){const I=this.type.getValue(V),m=this.mode.getValue(V),C=this.parameters.getValue(V);if(void 0===I||void 0===m)return;const s=`${I}-${m}-${C.join("-")}`;if(!this._easingFunctions[s]){const V=function(V){for(var I=arguments.length,m=new Array(I>1?I-1:0),C=1;C<I;C++)m[C-1]=arguments[C];switch(V){case 11:return new l.f(...m);case 0:return new l.j;case 1:return new l.e(...m);case 2:return new l.i(...m);case 3:return new l.m;case 4:return new l.u(...m);case 5:return new l.x(...m);default:throw new Error("Easing type not yet implemented")}}(I,...C);V.setEasingMode(m),this._easingFunctions[s]=V}this.easingFunction.setValue(this._easingFunctions[s],V)}getClassName(){return"FlowGraphEasingBlock"}}(0,k.h)("FlowGraphEasingBlock",j)}}]);