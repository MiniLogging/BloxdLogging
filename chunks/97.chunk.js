"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[97],{14333:(q,f,j)=>{j.r(f),j.d(f,{EasingFunctionType:()=>d,FlowGraphEasingBlock:()=>H});var d,g=j(13131),h=j(12726),L=j(12709),Q=j(10965);!function(q){q[q.CircleEase=0]="CircleEase",q[q.BackEase=1]="BackEase",q[q.BounceEase=2]="BounceEase",q[q.CubicEase=3]="CubicEase",q[q.ElasticEase=4]="ElasticEase",q[q.ExponentialEase=5]="ExponentialEase",q[q.PowerEase=6]="PowerEase",q[q.QuadraticEase=7]="QuadraticEase",q[q.QuarticEase=8]="QuarticEase",q[q.QuinticEase=9]="QuinticEase",q[q.SineEase=10]="SineEase",q[q.BezierCurveEase=11]="BezierCurveEase"}(d||(d={}));class H extends h.e{constructor(q){super(q),this.config=q,this._easingFunctions={},this.type=this.registerDataInput("type",L.c,11),this.mode=this.registerDataInput("mode",L.o,0),this.parameters=this.registerDataInput("parameters",L.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",L.c)}_updateOutputs(q){const f=this.type.getValue(q),j=this.mode.getValue(q),d=this.parameters.getValue(q);if(void 0===f||void 0===j)return;const h=`${f}-${j}-${d.join("-")}`;if(!this._easingFunctions[h]){const q=function(q){for(var f=arguments.length,j=new Array(f>1?f-1:0),d=1;d<f;d++)j[d-1]=arguments[d];switch(q){case 11:return new g.e(...j);case 0:return new g.j;case 1:return new g.b(...j);case 2:return new g.g(...j);case 3:return new g.m;case 4:return new g.r(...j);case 5:return new g.t(...j);default:throw new Error("Easing type not yet implemented")}}(f,...d);q.setEasingMode(j),this._easingFunctions[h]=q}this.easingFunction.setValue(this._easingFunctions[h],q)}getClassName(){return"FlowGraphEasingBlock"}}(0,Q.f)("FlowGraphEasingBlock",H)}}]);