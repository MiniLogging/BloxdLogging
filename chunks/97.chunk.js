"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[97],{14264:(h,d,m)=>{m.r(d),m.d(d,{EasingFunctionType:()=>j,FlowGraphEasingBlock:()=>D});var j,A=m(13098),b=m(12687),w=m(12671),a=m(11080);!function(h){h[h.CircleEase=0]="CircleEase",h[h.BackEase=1]="BackEase",h[h.BounceEase=2]="BounceEase",h[h.CubicEase=3]="CubicEase",h[h.ElasticEase=4]="ElasticEase",h[h.ExponentialEase=5]="ExponentialEase",h[h.PowerEase=6]="PowerEase",h[h.QuadraticEase=7]="QuadraticEase",h[h.QuarticEase=8]="QuarticEase",h[h.QuinticEase=9]="QuinticEase",h[h.SineEase=10]="SineEase",h[h.BezierCurveEase=11]="BezierCurveEase"}(j||(j={}));class D extends b.d{constructor(h){super(h),this.config=h,this._easingFunctions={},this.type=this.registerDataInput("type",w.e,11),this.mode=this.registerDataInput("mode",w.y,0),this.parameters=this.registerDataInput("parameters",w.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",w.e)}_updateOutputs(h){const d=this.type.getValue(h),m=this.mode.getValue(h),j=this.parameters.getValue(h);if(void 0===d||void 0===m)return;const b=`${d}-${m}-${j.join("-")}`;if(!this._easingFunctions[b]){const h=function(h){for(var d=arguments.length,m=new Array(d>1?d-1:0),j=1;j<d;j++)m[j-1]=arguments[j];switch(h){case 11:return new A.g(...m);case 0:return new A.j;case 1:return new A.c(...m);case 2:return new A.i(...m);case 3:return new A.k;case 4:return new A.q(...m);case 5:return new A.t(...m);default:throw new Error("Easing type not yet implemented")}}(d,...j);h.setEasingMode(m),this._easingFunctions[b]=h}this.easingFunction.setValue(this._easingFunctions[b],h)}getClassName(){return"FlowGraphEasingBlock"}}(0,a.i)("FlowGraphEasingBlock",D)}}]);