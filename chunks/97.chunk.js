"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[97],{14160:(z,u,Y)=>{Y.r(u),Y.d(u,{EasingFunctionType:()=>H,FlowGraphEasingBlock:()=>b});var H,E=Y(12924),J=Y(12549),l=Y(12531),T=Y(10918);!function(z){z[z.CircleEase=0]="CircleEase",z[z.BackEase=1]="BackEase",z[z.BounceEase=2]="BounceEase",z[z.CubicEase=3]="CubicEase",z[z.ElasticEase=4]="ElasticEase",z[z.ExponentialEase=5]="ExponentialEase",z[z.PowerEase=6]="PowerEase",z[z.QuadraticEase=7]="QuadraticEase",z[z.QuarticEase=8]="QuarticEase",z[z.QuinticEase=9]="QuinticEase",z[z.SineEase=10]="SineEase",z[z.BezierCurveEase=11]="BezierCurveEase"}(H||(H={}));class b extends J.b{constructor(z){super(z),this.config=z,this._easingFunctions={},this.type=this.registerDataInput("type",l.e,11),this.mode=this.registerDataInput("mode",l.p,0),this.parameters=this.registerDataInput("parameters",l.e,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",l.e)}_updateOutputs(z){const u=this.type.getValue(z),Y=this.mode.getValue(z),H=this.parameters.getValue(z);if(void 0===u||void 0===Y)return;const J=`${u}-${Y}-${H.join("-")}`;if(!this._easingFunctions[J]){const z=function(z){for(var u=arguments.length,Y=new Array(u>1?u-1:0),H=1;H<u;H++)Y[H-1]=arguments[H];switch(z){case 11:return new E.f(...Y);case 0:return new E.k;case 1:return new E.c(...Y);case 2:return new E.j(...Y);case 3:return new E.o;case 4:return new E.u(...Y);case 5:return new E.w(...Y);default:throw new Error("Easing type not yet implemented")}}(u,...H);z.setEasingMode(Y),this._easingFunctions[J]=z}this.easingFunction.setValue(this._easingFunctions[J],z)}getClassName(){return"FlowGraphEasingBlock"}}(0,T.d)("FlowGraphEasingBlock",b)}}]);