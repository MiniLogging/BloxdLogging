"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[97],{14377:(x,O,Q)=>{Q.r(O),Q.d(O,{EasingFunctionType:()=>X,FlowGraphEasingBlock:()=>l});var X,Z=Q(13174),n=Q(12726),V=Q(12707),o=Q(10866);!function(x){x[x.CircleEase=0]="CircleEase",x[x.BackEase=1]="BackEase",x[x.BounceEase=2]="BounceEase",x[x.CubicEase=3]="CubicEase",x[x.ElasticEase=4]="ElasticEase",x[x.ExponentialEase=5]="ExponentialEase",x[x.PowerEase=6]="PowerEase",x[x.QuadraticEase=7]="QuadraticEase",x[x.QuarticEase=8]="QuarticEase",x[x.QuinticEase=9]="QuinticEase",x[x.SineEase=10]="SineEase",x[x.BezierCurveEase=11]="BezierCurveEase"}(X||(X={}));class l extends n.d{constructor(x){super(x),this.config=x,this._easingFunctions={},this.type=this.registerDataInput("type",V.d,11),this.mode=this.registerDataInput("mode",V.q,0),this.parameters=this.registerDataInput("parameters",V.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",V.d)}_updateOutputs(x){const O=this.type.getValue(x),Q=this.mode.getValue(x),X=this.parameters.getValue(x);if(void 0===O||void 0===Q)return;const n=`${O}-${Q}-${X.join("-")}`;if(!this._easingFunctions[n]){const x=function(x){for(var O=arguments.length,Q=new Array(O>1?O-1:0),X=1;X<O;X++)Q[X-1]=arguments[X];switch(x){case 11:return new Z.e(...Q);case 0:return new Z.i;case 1:return new Z.c(...Q);case 2:return new Z.g(...Q);case 3:return new Z.l;case 4:return new Z.t(...Q);case 5:return new Z.v(...Q);default:throw new Error("Easing type not yet implemented")}}(O,...X);x.setEasingMode(Q),this._easingFunctions[n]=x}this.easingFunction.setValue(this._easingFunctions[n],x)}getClassName(){return"FlowGraphEasingBlock"}}(0,o.d)("FlowGraphEasingBlock",l)}}]);