"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[97],{14416:(s,Z,o)=>{o.r(Z),o.d(Z,{EasingFunctionType:()=>t,FlowGraphEasingBlock:()=>v});var t,j=o(13212),S=o(12802),a=o(12775),O=o(10916);!function(s){s[s.CircleEase=0]="CircleEase",s[s.BackEase=1]="BackEase",s[s.BounceEase=2]="BounceEase",s[s.CubicEase=3]="CubicEase",s[s.ElasticEase=4]="ElasticEase",s[s.ExponentialEase=5]="ExponentialEase",s[s.PowerEase=6]="PowerEase",s[s.QuadraticEase=7]="QuadraticEase",s[s.QuarticEase=8]="QuarticEase",s[s.QuinticEase=9]="QuinticEase",s[s.SineEase=10]="SineEase",s[s.BezierCurveEase=11]="BezierCurveEase"}(t||(t={}));class v extends S.e{constructor(s){super(s),this.config=s,this._easingFunctions={},this.type=this.registerDataInput("type",a.d,11),this.mode=this.registerDataInput("mode",a.w,0),this.parameters=this.registerDataInput("parameters",a.d,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",a.d)}_updateOutputs(s){const Z=this.type.getValue(s),o=this.mode.getValue(s),t=this.parameters.getValue(s);if(void 0===Z||void 0===o)return;const S=`${Z}-${o}-${t.join("-")}`;if(!this._easingFunctions[S]){const s=function(s){for(var Z=arguments.length,o=new Array(Z>1?Z-1:0),t=1;t<Z;t++)o[t-1]=arguments[t];switch(s){case 11:return new j.f(...o);case 0:return new j.h;case 1:return new j.b(...o);case 2:return new j.g(...o);case 3:return new j.j;case 4:return new j.q(...o);case 5:return new j.u(...o);default:throw new Error("Easing type not yet implemented")}}(Z,...t);s.setEasingMode(o),this._easingFunctions[S]=s}this.easingFunction.setValue(this._easingFunctions[S],s)}getClassName(){return"FlowGraphEasingBlock"}}(0,O.f)("FlowGraphEasingBlock",v)}}]);