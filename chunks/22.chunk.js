"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[22],{12561:(H,u,J)=>{J.r(u),J.d(u,{ShaderMaterial:()=>p});var O=J(12365),U=J(12568),h=J(12338),w=J(12410),g=J(12321),B=J(12304),b=J(12641),d=J(12201),G=J(12645),P=J(12203),mH=J(12675),l=J(12673);const r={effect:null,subMesh:null};class p extends G.c{constructor(H,u,J){let O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(H,u,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new h.Matrix,this._cachedWorldViewProjectionMatrix=new h.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=J,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...O}}get shaderPath(){return this._shaderPath}set shaderPath(H){this._shaderPath=H}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(H){-1===this._options.uniforms.indexOf(H)&&this._options.uniforms.push(H)}setTexture(H,u){return-1===this._options.samplers.indexOf(H)&&this._options.samplers.push(H),this._textures[H]=u,this}removeTexture(H){delete this._textures[H]}setTextureArray(H,u){return-1===this._options.samplers.indexOf(H)&&this._options.samplers.push(H),this._checkUniform(H),this._textureArrays[H]=u,this}setExternalTexture(H,u){return-1===this._options.externalTextures.indexOf(H)&&this._options.externalTextures.push(H),this._externalTextures[H]=u,this}setFloat(H,u){return this._checkUniform(H),this._floats[H]=u,this}setInt(H,u){return this._checkUniform(H),this._ints[H]=u,this}setUInt(H,u){return this._checkUniform(H),this._uints[H]=u,this}setFloats(H,u){return this._checkUniform(H),this._floatsArrays[H]=u,this}setColor3(H,u){return this._checkUniform(H),this._colors3[H]=u,this}setColor3Array(H,u){return this._checkUniform(H),this._colors3Arrays[H]=u.reduce(((H,u)=>(H.push(u.r,u.g,u.b),H)),[]),this}setColor4(H,u){return this._checkUniform(H),this._colors4[H]=u,this}setColor4Array(H,u){return this._checkUniform(H),this._colors4Arrays[H]=u.reduce(((H,u)=>(H.push(u.r,u.g,u.b,u.a),H)),[]),this}setVector2(H,u){return this._checkUniform(H),this._vectors2[H]=u,this}setVector3(H,u){return this._checkUniform(H),this._vectors3[H]=u,this}setVector4(H,u){return this._checkUniform(H),this._vectors4[H]=u,this}setQuaternion(H,u){return this._checkUniform(H),this._quaternions[H]=u,this}setQuaternionArray(H,u){return this._checkUniform(H),this._quaternionsArrays[H]=u.reduce(((H,u)=>(u.toArray(H,H.length),H)),[]),this}setMatrix(H,u){return this._checkUniform(H),this._matrices[H]=u,this}setMatrices(H,u){this._checkUniform(H);const J=new Float32Array(16*u.length);for(let O=0;O<u.length;O++){u[O].copyToArray(J,16*O)}return this._matrixArrays[H]=J,this}setMatrix3x3(H,u){return this._checkUniform(H),this._matrices3x3[H]=u,this}setMatrix2x2(H,u){return this._checkUniform(H),this._matrices2x2[H]=u,this}setArray2(H,u){return this._checkUniform(H),this._vectors2Arrays[H]=u,this}setArray3(H,u){return this._checkUniform(H),this._vectors3Arrays[H]=u,this}setArray4(H,u){return this._checkUniform(H),this._vectors4Arrays[H]=u,this}setUniformBuffer(H,u){return-1===this._options.uniformBuffers.indexOf(H)&&this._options.uniformBuffers.push(H),this._uniformBuffers[H]=u,this}setTextureSampler(H,u){return-1===this._options.samplerObjects.indexOf(H)&&this._options.samplerObjects.push(H),this._textureSamplers[H]=u,this}setStorageBuffer(H,u){return-1===this._options.storageBuffers.indexOf(H)&&this._options.storageBuffers.push(H),this._storageBuffers[H]=u,this}setDefine(H,u){const J=H.trimEnd()+" ",O=this.options.defines.findIndex((u=>u===H||u.startsWith(J)));return O>=0&&this.options.defines.splice(O,1),("boolean"!==typeof u||u)&&this.options.defines.push(J+u),this}isReadyForSubMesh(H,u,J){return this.isReady(H,J,u)}isReady(H,u,J){var O;const h=J&&this._storeEffectOnSubMeshes;if(this.isFrozen){const H=h?J._drawWrapper:this._drawWrapper;if(H.effect&&H._wasPreviouslyReady&&H._wasPreviouslyUsingInstances===u)return!0}const g=this.ZH(),B=g.getEngine(),d=[],G=[];let P=null,p=this._shaderPath,a=this._options.uniforms,k=this._options.uniformBuffers,C=this._options.samplers;B.getCaps().multiview&&g.activeCamera&&g.activeCamera.outputRenderTarget&&g.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,d.push("#define MULTIVIEW"),-1!==a.indexOf("viewProjection")&&-1===a.indexOf("viewProjectionR")&&a.push("viewProjectionR"));for(let U=0;U<this._options.defines.length;U++){const H=0===this._options.defines[U].indexOf("#define")?this._options.defines[U]:`#define ${this._options.defines[U]}`;d.push(H)}for(let U=0;U<this._options.attributes.length;U++)G.push(this._options.attributes[U]);if(H&&H.isVerticesDataPresent(w.d.ColorKind)&&(-1===G.indexOf(w.d.ColorKind)&&G.push(w.d.ColorKind),d.push("#define VERTEXCOLOR")),u&&(d.push("#define INSTANCES"),(0,l.Z)(G,this._materialHelperNeedsPreviousMatrices),null!==H&&void 0!==H&&H.hasThinInstances&&(d.push("#define THIN_INSTANCES"),H&&H.isVerticesDataPresent(w.d.ColorInstanceKind)&&(G.push(w.d.ColorInstanceKind),d.push("#define INSTANCESCOLOR")))),H&&H.useBones&&H.computeBonesUsingShaders&&H.skeleton){G.push(w.d.MatricesIndicesKind),G.push(w.d.MatricesWeightsKind),H.numBoneInfluencers>4&&(G.push(w.d.MatricesIndicesExtraKind),G.push(w.d.MatricesWeightsExtraKind));const u=H.skeleton;d.push("#define NUM_BONE_INFLUENCERS "+H.numBoneInfluencers),P=new b.e,P.addCPUSkinningFallback(0,H),u.isUsingTextureForMatrices?(d.push("#define BONETEXTURE"),-1===a.indexOf("boneTextureWidth")&&a.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(d.push("#define BonesPerMesh "+(u.bones.length+1)),-1===a.indexOf("mBones")&&a.push("mBones"))}else d.push("#define NUM_BONE_INFLUENCERS 0");let j=0;const M=H?H.morphTargetManager:null;if(M){const u=-1!==d.indexOf("#define UV1"),J=-1!==d.indexOf("#define UV2"),O=-1!==d.indexOf("#define TANGENT"),U=-1!==d.indexOf("#define NORMAL"),h=-1!==d.indexOf("#define VERTEXCOLOR");j=(0,l.F)(M,d,G,H,!0,U,O,u,J,h),M.isUsingTextureForTargets&&(-1===a.indexOf("morphTargetTextureIndices")&&a.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),j>0&&(a=a.slice(),a.push("morphTargetInfluences"),a.push("morphTargetCount"),a.push("morphTargetTextureInfo"),a.push("morphTargetTextureIndices"))}else d.push("#define NUM_MORPH_INFLUENCERS 0");if(H){const u=H.bakedVertexAnimationManager;u&&u.isEnabled&&(d.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===a.indexOf("bakedVertexAnimationSettings")&&a.push("bakedVertexAnimationSettings"),-1===a.indexOf("bakedVertexAnimationTextureSizeInverted")&&a.push("bakedVertexAnimationTextureSizeInverted"),-1===a.indexOf("bakedVertexAnimationTime")&&a.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,l.v)(G,H,d)}for(const U in this._textures)if(!this._textures[U].isReady())return!1;H&&this.needAlphaTestingForMesh(H)&&d.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,mH.e)(a),(0,mH.l)(this,g,d)),g.fogEnabled&&null!==H&&void 0!==H&&H.applyFog&&g.fogMode!==U.d.FOGMODE_NONE&&(d.push("#define FOG"),-1===a.indexOf("view")&&a.push("view"),-1===a.indexOf("vFogInfos")&&a.push("vFogInfos"),-1===a.indexOf("vFogColor")&&a.push("vFogColor")),this._useLogarithmicDepth&&(d.push("#define LOGARITHMICDEPTH"),-1===a.indexOf("logarithmicDepthConstant")&&a.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(a=a.slice(),k=k.slice(),C=C.slice(),p=this.customShaderNameResolve(this.name,a,k,C,d,G));const L=h?J._getDrawWrapper(void 0,!0):this._drawWrapper,Z=(null===L||void 0===L?void 0:L.effect)??null,Y=(null===L||void 0===L?void 0:L.defines)??null,F=d.join("\n");let s=Z;return Y!==F&&(s=B.createEffect(p,{attributes:G,uniformsNames:a,uniformBuffersNames:k,samplers:C,defines:F,fallbacks:P,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:j},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},B),h?J.setEffect(s,F,this._materialContext):L&&L.setEffect(s,F),this._onEffectCreatedObservable&&(r.effect=s,r.subMesh=J??(null===H||void 0===H?void 0:H.mg[0])??null,this._onEffectCreatedObservable.notifyObservers(r))),L._wasPreviouslyUsingInstances=!!u,!(null===(O=s)||void 0===O||!O.isReady())&&(Z!==s&&g.resetCachedMaterial(),L._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(H,u){const J=u??this.getEffect();if(!J)return;const O=this._options.uniforms;-1!==O.indexOf("world")&&J.setMatrix("world",H);const U=this.ZH();-1!==O.indexOf("worldView")&&(H.multiplyToRef(U.getViewMatrix(),this._cachedWorldViewMatrix),J.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==O.indexOf("worldViewProjection")&&(H.multiplyToRef(U.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),J.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==O.indexOf("view")&&J.setMatrix("view",U.getViewMatrix())}bindForSubMesh(H,u,J){var O;this.bind(H,u,null===(O=J._drawWrapperOverride)||void 0===O?void 0:O.effect,J)}bind(H,u,J,O){const U=O&&this._storeEffectOnSubMeshes,h=J??(U?O.effect:this.getEffect());if(!h)return;const w=this.ZH();this._activeEffect=h,this.bindOnlyWorldMatrix(H,J);const g=this._options.uniformBuffers;let B=!1;if(h&&g&&g.length>0&&w.getEngine().supportsUniformBuffers)for(let G=0;G<g.length;++G){switch(g[G]){case"Mesh":u&&(u.getMeshUniformBuffer().bindToEffect(h,"Mesh"),u.transferToEffect(H));break;case"Scene":(0,l.o)(h,w.getSceneUniformBuffer()),w.finalizeSceneUbo(),B=!0}}const b=u&&U?this._mustRebind(w,h,O,u.visibility):w.getCachedMaterial()!==this;if(h&&b){let H;for(H in B||-1===this._options.uniforms.indexOf("view")||h.setMatrix("view",w.getViewMatrix()),B||-1===this._options.uniforms.indexOf("projection")||h.setMatrix("projection",w.getProjectionMatrix()),B||-1===this._options.uniforms.indexOf("viewProjection")||(h.setMatrix("viewProjection",w.getTransformMatrix()),this._multiview&&h.setMatrix("viewProjectionR",w._transformMatrixR)),w.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&h.setVector3("cameraPosition",w.activeCamera.globalPosition),(0,l.b)(u,h),(0,mH.f)(h,this,w),this._useLogarithmicDepth&&(0,l.h)(U?O.materialDefines:h.defines,h,w),u&&(0,l.c)(w,u,h),this._textures)h.setTexture(H,this._textures[H]);for(H in this._textureArrays)h.setTextureArray(H,this._textureArrays[H]);for(H in this._ints)h.setInt(H,this._ints[H]);for(H in this._uints)h.setUInt(H,this._uints[H]);for(H in this._floats)h.setFloat(H,this._floats[H]);for(H in this._floatsArrays)h.setArray(H,this._floatsArrays[H]);for(H in this._colors3)h.setColor3(H,this._colors3[H]);for(H in this._colors3Arrays)h.setArray3(H,this._colors3Arrays[H]);for(H in this._colors4){const u=this._colors4[H];h.setFloat4(H,u.r,u.g,u.b,u.a)}for(H in this._colors4Arrays)h.setArray4(H,this._colors4Arrays[H]);for(H in this._vectors2)h.setVector2(H,this._vectors2[H]);for(H in this._vectors3)h.setVector3(H,this._vectors3[H]);for(H in this._vectors4)h.setVector4(H,this._vectors4[H]);for(H in this._quaternions)h.setQuaternion(H,this._quaternions[H]);for(H in this._matrices)h.setMatrix(H,this._matrices[H]);for(H in this._matrixArrays)h.setMatrices(H,this._matrixArrays[H]);for(H in this._matrices3x3)h.setMatrix3x3(H,this._matrices3x3[H]);for(H in this._matrices2x2)h.setMatrix2x2(H,this._matrices2x2[H]);for(H in this._vectors2Arrays)h.setArray2(H,this._vectors2Arrays[H]);for(H in this._vectors3Arrays)h.setArray3(H,this._vectors3Arrays[H]);for(H in this._vectors4Arrays)h.setArray4(H,this._vectors4Arrays[H]);for(H in this._quaternionsArrays)h.setArray4(H,this._quaternionsArrays[H]);for(H in this._uniformBuffers){const u=this._uniformBuffers[H].getBuffer();u&&h.bindUniformBuffer(u,H)}const J=w.getEngine(),g=J.setExternalTexture;if(g)for(H in this._externalTextures)g.call(J,H,this._externalTextures[H]);const b=J.setTextureSampler;if(b)for(H in this._textureSamplers)b.call(J,H,this._textureSamplers[H]);const d=J.setStorageBuffer;if(d)for(H in this._storageBuffers)d.call(J,H,this._storageBuffers[H])}if(h&&u&&(b||!this.isFrozen)){(0,l.l)(u,h),u.morphTargetManager&&u.morphTargetManager.isUsingTextureForTargets&&u.morphTargetManager._bind(h);const H=u.bakedVertexAnimationManager;if(H&&H.isEnabled){var d;const H=U?O._drawWrapper:this._drawWrapper;null===(d=u.bakedVertexAnimationManager)||void 0===d||d.bind(h,!!H._wasPreviouslyUsingInstances)}}this._afterBind(u,h,O)}getActiveTextures(){const H=super.getActiveTextures();for(const u in this._textures)H.push(this._textures[u]);for(const u in this._textureArrays){const J=this._textureArrays[u];for(let u=0;u<J.length;u++)H.push(J[u])}return H}hasTexture(H){if(super.hasTexture(H))return!0;for(const u in this._textures)if(this._textures[u]===H)return!0;for(const u in this._textureArrays){const J=this._textureArrays[u];for(let u=0;u<J.length;u++)if(J[u]===H)return!0}return!1}clone(H){const u=O.d.Clone((()=>new p(H,this.ZH(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);u.name=H,u.id=H,"object"===typeof u._shaderPath&&(u._shaderPath={...u._shaderPath}),this._options={...this._options};const J=Object.keys(this._options);for(const O of J){const H=this._options[O];Array.isArray(H)&&(this._options[O]=H.slice(0))}this.Rh.copyTo(u.Rh);for(const O in this._textures)u.setTexture(O,this._textures[O]);for(const O in this._textureArrays)u.setTextureArray(O,this._textureArrays[O]);for(const O in this._externalTextures)u.setExternalTexture(O,this._externalTextures[O]);for(const O in this._ints)u.setInt(O,this._ints[O]);for(const O in this._uints)u.setUInt(O,this._uints[O]);for(const O in this._floats)u.setFloat(O,this._floats[O]);for(const O in this._floatsArrays)u.setFloats(O,this._floatsArrays[O]);for(const O in this._colors3)u.setColor3(O,this._colors3[O]);for(const O in this._colors3Arrays)u._colors3Arrays[O]=this._colors3Arrays[O];for(const O in this._colors4)u.setColor4(O,this._colors4[O]);for(const O in this._colors4Arrays)u._colors4Arrays[O]=this._colors4Arrays[O];for(const O in this._vectors2)u.setVector2(O,this._vectors2[O]);for(const O in this._vectors3)u.setVector3(O,this._vectors3[O]);for(const O in this._vectors4)u.setVector4(O,this._vectors4[O]);for(const O in this._quaternions)u.setQuaternion(O,this._quaternions[O]);for(const O in this._quaternionsArrays)u._quaternionsArrays[O]=this._quaternionsArrays[O];for(const O in this._matrices)u.setMatrix(O,this._matrices[O]);for(const O in this._matrixArrays)u._matrixArrays[O]=this._matrixArrays[O].slice();for(const O in this._matrices3x3)u.setMatrix3x3(O,this._matrices3x3[O]);for(const O in this._matrices2x2)u.setMatrix2x2(O,this._matrices2x2[O]);for(const O in this._vectors2Arrays)u.setArray2(O,this._vectors2Arrays[O]);for(const O in this._vectors3Arrays)u.setArray3(O,this._vectors3Arrays[O]);for(const O in this._vectors4Arrays)u.setArray4(O,this._vectors4Arrays[O]);for(const O in this._uniformBuffers)u.setUniformBuffer(O,this._uniformBuffers[O]);for(const O in this._textureSamplers)u.setTextureSampler(O,this._textureSamplers[O]);for(const O in this._storageBuffers)u.setStorageBuffer(O,this._storageBuffers[O]);return u}dispose(H,u,J){if(u){let H;for(H in this._textures)this._textures[H].dispose();for(H in this._textureArrays){const u=this._textureArrays[H];for(let H=0;H<u.length;H++)u[H].dispose()}}this._textures={},super.dispose(H,u,J)}serialize(){const H=O.d.Serialize(this);let u;for(u in H.customType="BABYLON.ShaderMaterial",H.uniqueId=this.uniqueId,H.options=this._options,H.shaderPath=this._shaderPath,H.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,H.Rh=this.Rh.serialize(),H.textures={},this._textures)H.textures[u]=this._textures[u].serialize();for(u in H.textureArrays={},this._textureArrays){H.textureArrays[u]=[];const J=this._textureArrays[u];for(let O=0;O<J.length;O++)H.textureArrays[u].push(J[O].serialize())}for(u in H.ints={},this._ints)H.ints[u]=this._ints[u];for(u in H.uints={},this._uints)H.uints[u]=this._uints[u];for(u in H.floats={},this._floats)H.floats[u]=this._floats[u];for(u in H.floatsArrays={},this._floatsArrays)H.floatsArrays[u]=this._floatsArrays[u];for(u in H.colors3={},this._colors3){const J=this._colors3[u];H.colors3[u]=[J.r,J.g,J.b]}for(u in H.colors3Arrays={},this._colors3Arrays)H.colors3Arrays[u]=this._colors3Arrays[u];for(u in H.colors4={},this._colors4){const J=this._colors4[u];H.colors4[u]=[J.r,J.g,J.b,J.a]}for(u in H.colors4Arrays={},this._colors4Arrays)H.colors4Arrays[u]=this._colors4Arrays[u];for(u in H.vectors2={},this._vectors2){const J=this._vectors2[u];H.vectors2[u]=[J.x,J.y]}for(u in H.vectors3={},this._vectors3){const J=this._vectors3[u];H.vectors3[u]=[J.x,J.y,J.z]}for(u in H.vectors4={},this._vectors4){const J=this._vectors4[u];H.vectors4[u]=[J.x,J.y,J.z,J.w]}for(u in H.quaternions={},this._quaternions)H.quaternions[u]=this._quaternions[u].Hg();for(u in H.matrices={},this._matrices)H.matrices[u]=this._matrices[u].Hg();for(u in H.matrixArray={},this._matrixArrays)H.matrixArray[u]=this._matrixArrays[u];for(u in H.matrices3x3={},this._matrices3x3)H.matrices3x3[u]=this._matrices3x3[u];for(u in H.matrices2x2={},this._matrices2x2)H.matrices2x2[u]=this._matrices2x2[u];for(u in H.vectors2Arrays={},this._vectors2Arrays)H.vectors2Arrays[u]=this._vectors2Arrays[u];for(u in H.vectors3Arrays={},this._vectors3Arrays)H.vectors3Arrays[u]=this._vectors3Arrays[u];for(u in H.vectors4Arrays={},this._vectors4Arrays)H.vectors4Arrays[u]=this._vectors4Arrays[u];for(u in H.quaternionsArrays={},this._quaternionsArrays)H.quaternionsArrays[u]=this._quaternionsArrays[u];return H}static Parse(H,u,J){const U=O.d.Parse((()=>new p(H.name,u,H.shaderPath,H.options,H.storeEffectOnSubMeshes)),H,u,J);let w;for(w in H.Rh&&U.Rh.parse(H.Rh,u,J),H.textures)U.setTexture(w,g.b.Parse(H.textures[w],u,J));for(w in H.textureArrays){const O=H.textureArrays[w],h=[];for(let H=0;H<O.length;H++)h.push(g.b.Parse(O[H],u,J));U.setTextureArray(w,h)}for(w in H.ints)U.setInt(w,H.ints[w]);for(w in H.uints)U.setUInt(w,H.uints[w]);for(w in H.floats)U.setFloat(w,H.floats[w]);for(w in H.floatsArrays)U.setFloats(w,H.floatsArrays[w]);for(w in H.colors3){const u=H.colors3[w];U.setColor3(w,{r:u[0],g:u[1],b:u[2]})}for(w in H.colors3Arrays){const u=H.colors3Arrays[w].reduce(((H,u,J)=>(J%3===0?H.push([u]):H[H.length-1].push(u),H)),[]).map((H=>({r:H[0],g:H[1],b:H[2]})));U.setColor3Array(w,u)}for(w in H.colors4){const u=H.colors4[w];U.setColor4(w,{r:u[0],g:u[1],b:u[2],a:u[3]})}for(w in H.colors4Arrays){const u=H.colors4Arrays[w].reduce(((H,u,J)=>(J%4===0?H.push([u]):H[H.length-1].push(u),H)),[]).map((H=>({r:H[0],g:H[1],b:H[2],a:H[3]})));U.setColor4Array(w,u)}for(w in H.vectors2){const u=H.vectors2[w];U.setVector2(w,{x:u[0],y:u[1]})}for(w in H.vectors3){const u=H.vectors3[w];U.setVector3(w,{x:u[0],y:u[1],z:u[2]})}for(w in H.vectors4){const u=H.vectors4[w];U.setVector4(w,{x:u[0],y:u[1],z:u[2],w:u[3]})}for(w in H.quaternions)U.setQuaternion(w,h.Quaternion.Cu(H.quaternions[w]));for(w in H.matrices)U.setMatrix(w,h.Matrix.Cu(H.matrices[w]));for(w in H.matrixArray)U._matrixArrays[w]=new Float32Array(H.matrixArray[w]);for(w in H.matrices3x3)U.setMatrix3x3(w,H.matrices3x3[w]);for(w in H.matrices2x2)U.setMatrix2x2(w,H.matrices2x2[w]);for(w in H.vectors2Arrays)U.setArray2(w,H.vectors2Arrays[w]);for(w in H.vectors3Arrays)U.setArray3(w,H.vectors3Arrays[w]);for(w in H.vectors4Arrays)U.setArray4(w,H.vectors4Arrays[w]);for(w in H.quaternionsArrays)U.setArray4(w,H.quaternionsArrays[w]);return U}static async ParseFromFileAsync(H,u,J){let O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((U,h)=>{const w=new d.d;w.addEventListener("readystatechange",(()=>{if(4==w.readyState)if(200==w.status){const u=JSON.parse(w.responseText),h=this.Parse(u,J||P.e.LastCreatedScene,O);H&&(h.name=H),U(h)}else h("Unable to load the ShaderMaterial")})),w.open("GET",u),w.send()}))}static async ParseFromSnippetAsync(H,u){let J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((O,U)=>{const h=new d.d;h.addEventListener("readystatechange",(()=>{if(4==h.readyState)if(200==h.status){const U=JSON.parse(JSON.parse(h.responseText).jsonPayload),w=JSON.parse(U.shaderMaterial),g=this.Parse(w,u||P.e.LastCreatedScene,J);g.snippetId=H,O(g)}else U("Unable to load the snippet "+H)})),h.open("GET",this.SnippetUrl+"/"+H.replace(/#/g,"/")),h.send()}))}}p.SnippetUrl="https://snippet.babylonjs.com",p.CreateFromSnippetAsync=p.ParseFromSnippetAsync,(0,B.f)("BABYLON.ShaderMaterial",p)}}]);