"use strict";(self.b15p7b72fr8=self.b15p7b72fr8||[]).push([[22],{12827:(s,k,h)=>{h.r(k),h.d(k,{ShaderMaterial:()=>j});var A=h(12623),g=h(12836),ms=h(12590),i=h(12664),K=h(12567),H=h(12543),O=h(12904),c=h(12442),S=h(12911),a=h(12445),r=h(12976),d=h(12968);const E={effect:null,subMesh:null};class j extends S.b{constructor(s,k,h){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(s,k,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new ms.Matrix,this._cachedWorldViewProjectionMatrix=new ms.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=h,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...A}}get shaderPath(){return this._shaderPath}set shaderPath(s){this._shaderPath=s}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(s){-1===this._options.uniforms.indexOf(s)&&this._options.uniforms.push(s)}setTexture(s,k){return-1===this._options.samplers.indexOf(s)&&this._options.samplers.push(s),this._textures[s]=k,this}removeTexture(s){delete this._textures[s]}setTextureArray(s,k){return-1===this._options.samplers.indexOf(s)&&this._options.samplers.push(s),this._checkUniform(s),this._textureArrays[s]=k,this}setExternalTexture(s,k){return-1===this._options.externalTextures.indexOf(s)&&this._options.externalTextures.push(s),this._externalTextures[s]=k,this}setFloat(s,k){return this._checkUniform(s),this._floats[s]=k,this}setInt(s,k){return this._checkUniform(s),this._ints[s]=k,this}setUInt(s,k){return this._checkUniform(s),this._uints[s]=k,this}setFloats(s,k){return this._checkUniform(s),this._floatsArrays[s]=k,this}setColor3(s,k){return this._checkUniform(s),this._colors3[s]=k,this}setColor3Array(s,k){return this._checkUniform(s),this._colors3Arrays[s]=k.reduce(((s,k)=>(s.push(k.r,k.g,k.b),s)),[]),this}setColor4(s,k){return this._checkUniform(s),this._colors4[s]=k,this}setColor4Array(s,k){return this._checkUniform(s),this._colors4Arrays[s]=k.reduce(((s,k)=>(s.push(k.r,k.g,k.b,k.a),s)),[]),this}setVector2(s,k){return this._checkUniform(s),this._vectors2[s]=k,this}setVector3(s,k){return this._checkUniform(s),this._vectors3[s]=k,this}setVector4(s,k){return this._checkUniform(s),this._vectors4[s]=k,this}setQuaternion(s,k){return this._checkUniform(s),this._quaternions[s]=k,this}setQuaternionArray(s,k){return this._checkUniform(s),this._quaternionsArrays[s]=k.reduce(((s,k)=>(k.toArray(s,s.length),s)),[]),this}setMatrix(s,k){return this._checkUniform(s),this._matrices[s]=k,this}setMatrices(s,k){this._checkUniform(s);const h=new Float32Array(16*k.length);for(let A=0;A<k.length;A++){k[A].copyToArray(h,16*A)}return this._matrixArrays[s]=h,this}setMatrix3x3(s,k){return this._checkUniform(s),this._matrices3x3[s]=k,this}setMatrix2x2(s,k){return this._checkUniform(s),this._matrices2x2[s]=k,this}setArray2(s,k){return this._checkUniform(s),this._vectors2Arrays[s]=k,this}setArray3(s,k){return this._checkUniform(s),this._vectors3Arrays[s]=k,this}setArray4(s,k){return this._checkUniform(s),this._vectors4Arrays[s]=k,this}setUniformBuffer(s,k){return-1===this._options.uniformBuffers.indexOf(s)&&this._options.uniformBuffers.push(s),this._uniformBuffers[s]=k,this}setTextureSampler(s,k){return-1===this._options.samplerObjects.indexOf(s)&&this._options.samplerObjects.push(s),this._textureSamplers[s]=k,this}setStorageBuffer(s,k){return-1===this._options.storageBuffers.indexOf(s)&&this._options.storageBuffers.push(s),this._storageBuffers[s]=k,this}setDefine(s,k){const h=s.trimEnd()+" ",A=this.options.defines.findIndex((k=>k===s||k.startsWith(h)));return A>=0&&this.options.defines.splice(A,1),("boolean"!==typeof k||k)&&this.options.defines.push(h+k),this}isReadyForSubMesh(s,k,h){return this.isReady(s,h,k)}isReady(s,k,h){var A;const ms=h&&this._storeEffectOnSubMeshes;if(this.isFrozen){const s=ms?h._drawWrapper:this._drawWrapper;if(s.effect&&s._wasPreviouslyReady&&s._wasPreviouslyUsingInstances===k)return!0}const K=this.Is(),H=K.getEngine(),c=[],S=[];let a=null,j=this._shaderPath,P=this._options.uniforms,R=this._options.uniformBuffers,D=this._options.samplers;H.getCaps().multiview&&K.activeCamera&&K.activeCamera.outputRenderTarget&&K.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,c.push("#define MULTIVIEW"),-1!==P.indexOf("viewProjection")&&-1===P.indexOf("viewProjectionR")&&P.push("viewProjectionR"));for(let g=0;g<this._options.defines.length;g++){const s=0===this._options.defines[g].indexOf("#define")?this._options.defines[g]:`#define ${this._options.defines[g]}`;c.push(s)}for(let g=0;g<this._options.attributes.length;g++)S.push(this._options.attributes[g]);if(s&&s.isVerticesDataPresent(i.e.ColorKind)&&(-1===S.indexOf(i.e.ColorKind)&&S.push(i.e.ColorKind),c.push("#define VERTEXCOLOR")),k&&(c.push("#define INSTANCES"),(0,d._)(S,this._materialHelperNeedsPreviousMatrices),null!==s&&void 0!==s&&s.hasThinInstances&&(c.push("#define THIN_INSTANCES"),s&&s.isVerticesDataPresent(i.e.ColorInstanceKind)&&(S.push(i.e.ColorInstanceKind),c.push("#define INSTANCESCOLOR")))),s&&s.useBones&&s.computeBonesUsingShaders&&s.skeleton){S.push(i.e.MatricesIndicesKind),S.push(i.e.MatricesWeightsKind),s.numBoneInfluencers>4&&(S.push(i.e.MatricesIndicesExtraKind),S.push(i.e.MatricesWeightsExtraKind));const k=s.skeleton;c.push("#define NUM_BONE_INFLUENCERS "+s.numBoneInfluencers),a=new O.e,a.addCPUSkinningFallback(0,s),k.isUsingTextureForMatrices?(c.push("#define BONETEXTURE"),-1===P.indexOf("boneTextureWidth")&&P.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(c.push("#define BonesPerMesh "+(k.bones.length+1)),-1===P.indexOf("mBones")&&P.push("mBones"))}else c.push("#define NUM_BONE_INFLUENCERS 0");let w=0;const B=s?s.morphTargetManager:null;if(B){const k=-1!==c.indexOf("#define UV1"),h=-1!==c.indexOf("#define UV2"),A=-1!==c.indexOf("#define TANGENT"),g=-1!==c.indexOf("#define NORMAL"),ms=-1!==c.indexOf("#define VERTEXCOLOR");w=(0,d.C)(B,c,S,s,!0,g,A,k,h,ms),B.isUsingTextureForTargets&&(-1===P.indexOf("morphTargetTextureIndices")&&P.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),w>0&&(P=P.slice(),P.push("morphTargetInfluences"),P.push("morphTargetCount"),P.push("morphTargetTextureInfo"),P.push("morphTargetTextureIndices"))}else c.push("#define NUM_MORPH_INFLUENCERS 0");if(s){const k=s.bakedVertexAnimationManager;k&&k.isEnabled&&(c.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===P.indexOf("bakedVertexAnimationSettings")&&P.push("bakedVertexAnimationSettings"),-1===P.indexOf("bakedVertexAnimationTextureSizeInverted")&&P.push("bakedVertexAnimationTextureSizeInverted"),-1===P.indexOf("bakedVertexAnimationTime")&&P.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,d.w)(S,s,c)}for(const g in this._textures)if(!this._textures[g].isReady())return!1;s&&this.needAlphaTestingForMesh(s)&&c.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,r.c)(P),(0,r.j)(this,K,c)),K.fogEnabled&&null!==s&&void 0!==s&&s.applyFog&&K.fogMode!==g.d.FOGMODE_NONE&&(c.push("#define FOG"),-1===P.indexOf("view")&&P.push("view"),-1===P.indexOf("vFogInfos")&&P.push("vFogInfos"),-1===P.indexOf("vFogColor")&&P.push("vFogColor")),this._useLogarithmicDepth&&(c.push("#define LOGARITHMICDEPTH"),-1===P.indexOf("logarithmicDepthConstant")&&P.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(P=P.slice(),R=R.slice(),D=D.slice(),j=this.customShaderNameResolve(this.name,P,R,D,c,S));const u=ms?h._getDrawWrapper(void 0,!0):this._drawWrapper,G=(null===u||void 0===u?void 0:u.effect)??null,Q=(null===u||void 0===u?void 0:u.defines)??null,p=c.join("\n");let I=G;return Q!==p&&(I=H.createEffect(j,{attributes:S,uniformsNames:P,uniformBuffersNames:R,samplers:D,defines:p,fallbacks:a,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:w},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},H),ms?h.setEffect(I,p,this._materialContext):u&&u.setEffect(I,p),this._onEffectCreatedObservable&&(E.effect=I,E.subMesh=h??(null===s||void 0===s?void 0:s.Lh[0])??null,this._onEffectCreatedObservable.notifyObservers(E))),u._wasPreviouslyUsingInstances=!!k,!(null===(A=I)||void 0===A||!A.isReady())&&(G!==I&&K.resetCachedMaterial(),u._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(s,k){const h=k??this.getEffect();if(!h)return;const A=this._options.uniforms;-1!==A.indexOf("world")&&h.setMatrix("world",s);const g=this.Is();-1!==A.indexOf("worldView")&&(s.multiplyToRef(g.getViewMatrix(),this._cachedWorldViewMatrix),h.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==A.indexOf("worldViewProjection")&&(s.multiplyToRef(g.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),h.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==A.indexOf("view")&&h.setMatrix("view",g.getViewMatrix())}bindForSubMesh(s,k,h){var A;this.bind(s,k,null===(A=h._drawWrapperOverride)||void 0===A?void 0:A.effect,h)}bind(s,k,h,A){const g=A&&this._storeEffectOnSubMeshes,ms=h??(g?A.effect:this.getEffect());if(!ms)return;const i=this.Is();this._activeEffect=ms,this.bindOnlyWorldMatrix(s,h);const K=this._options.uniformBuffers;let H=!1;if(ms&&K&&K.length>0&&i.getEngine().supportsUniformBuffers)for(let S=0;S<K.length;++S){switch(K[S]){case"Mesh":k&&(k.getMeshUniformBuffer().bindToEffect(ms,"Mesh"),k.transferToEffect(s));break;case"Scene":(0,d.p)(ms,i.getSceneUniformBuffer()),i.finalizeSceneUbo(),H=!0}}const O=k&&g?this._mustRebind(i,ms,A,k.visibility):i.getCachedMaterial()!==this;if(ms&&O){let s;for(s in H||-1===this._options.uniforms.indexOf("view")||ms.setMatrix("view",i.getViewMatrix()),H||-1===this._options.uniforms.indexOf("projection")||ms.setMatrix("projection",i.getProjectionMatrix()),H||-1===this._options.uniforms.indexOf("viewProjection")||(ms.setMatrix("viewProjection",i.getTransformMatrix()),this._multiview&&ms.setMatrix("viewProjectionR",i._transformMatrixR)),i.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&ms.setVector3("cameraPosition",i.activeCamera.globalPosition),(0,d.c)(k,ms),(0,r.d)(ms,this,i),this._useLogarithmicDepth&&(0,d.j)(g?A.materialDefines:ms.defines,ms,i),k&&(0,d.f)(i,k,ms),this._textures)ms.setTexture(s,this._textures[s]);for(s in this._textureArrays)ms.setTextureArray(s,this._textureArrays[s]);for(s in this._ints)ms.setInt(s,this._ints[s]);for(s in this._uints)ms.setUInt(s,this._uints[s]);for(s in this._floats)ms.setFloat(s,this._floats[s]);for(s in this._floatsArrays)ms.setArray(s,this._floatsArrays[s]);for(s in this._colors3)ms.setColor3(s,this._colors3[s]);for(s in this._colors3Arrays)ms.setArray3(s,this._colors3Arrays[s]);for(s in this._colors4){const k=this._colors4[s];ms.setFloat4(s,k.r,k.g,k.b,k.a)}for(s in this._colors4Arrays)ms.setArray4(s,this._colors4Arrays[s]);for(s in this._vectors2)ms.setVector2(s,this._vectors2[s]);for(s in this._vectors3)ms.setVector3(s,this._vectors3[s]);for(s in this._vectors4)ms.setVector4(s,this._vectors4[s]);for(s in this._quaternions)ms.setQuaternion(s,this._quaternions[s]);for(s in this._matrices)ms.setMatrix(s,this._matrices[s]);for(s in this._matrixArrays)ms.setMatrices(s,this._matrixArrays[s]);for(s in this._matrices3x3)ms.setMatrix3x3(s,this._matrices3x3[s]);for(s in this._matrices2x2)ms.setMatrix2x2(s,this._matrices2x2[s]);for(s in this._vectors2Arrays)ms.setArray2(s,this._vectors2Arrays[s]);for(s in this._vectors3Arrays)ms.setArray3(s,this._vectors3Arrays[s]);for(s in this._vectors4Arrays)ms.setArray4(s,this._vectors4Arrays[s]);for(s in this._quaternionsArrays)ms.setArray4(s,this._quaternionsArrays[s]);for(s in this._uniformBuffers){const k=this._uniformBuffers[s].getBuffer();k&&ms.bindUniformBuffer(k,s)}const h=i.getEngine(),K=h.setExternalTexture;if(K)for(s in this._externalTextures)K.call(h,s,this._externalTextures[s]);const O=h.setTextureSampler;if(O)for(s in this._textureSamplers)O.call(h,s,this._textureSamplers[s]);const c=h.setStorageBuffer;if(c)for(s in this._storageBuffers)c.call(h,s,this._storageBuffers[s])}if(ms&&k&&(O||!this.isFrozen)){(0,d.m)(k,ms),k.morphTargetManager&&k.morphTargetManager.isUsingTextureForTargets&&k.morphTargetManager._bind(ms);const s=k.bakedVertexAnimationManager;if(s&&s.isEnabled){var c;const s=g?A._drawWrapper:this._drawWrapper;null===(c=k.bakedVertexAnimationManager)||void 0===c||c.bind(ms,!!s._wasPreviouslyUsingInstances)}}this._afterBind(k,ms,A)}getActiveTextures(){const s=super.getActiveTextures();for(const k in this._textures)s.push(this._textures[k]);for(const k in this._textureArrays){const h=this._textureArrays[k];for(let k=0;k<h.length;k++)s.push(h[k])}return s}hasTexture(s){if(super.hasTexture(s))return!0;for(const k in this._textures)if(this._textures[k]===s)return!0;for(const k in this._textureArrays){const h=this._textureArrays[k];for(let k=0;k<h.length;k++)if(h[k]===s)return!0}return!1}clone(s){const k=A.e.Clone((()=>new j(s,this.Is(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);k.name=s,k.id=s,"object"===typeof k._shaderPath&&(k._shaderPath={...k._shaderPath}),this._options={...this._options};const h=Object.keys(this._options);for(const A of h){const s=this._options[A];Array.isArray(s)&&(this._options[A]=s.slice(0))}this.Bh.copyTo(k.Bh);for(const A in this._textures)k.setTexture(A,this._textures[A]);for(const A in this._textureArrays)k.setTextureArray(A,this._textureArrays[A]);for(const A in this._externalTextures)k.setExternalTexture(A,this._externalTextures[A]);for(const A in this._ints)k.setInt(A,this._ints[A]);for(const A in this._uints)k.setUInt(A,this._uints[A]);for(const A in this._floats)k.setFloat(A,this._floats[A]);for(const A in this._floatsArrays)k.setFloats(A,this._floatsArrays[A]);for(const A in this._colors3)k.setColor3(A,this._colors3[A]);for(const A in this._colors3Arrays)k._colors3Arrays[A]=this._colors3Arrays[A];for(const A in this._colors4)k.setColor4(A,this._colors4[A]);for(const A in this._colors4Arrays)k._colors4Arrays[A]=this._colors4Arrays[A];for(const A in this._vectors2)k.setVector2(A,this._vectors2[A]);for(const A in this._vectors3)k.setVector3(A,this._vectors3[A]);for(const A in this._vectors4)k.setVector4(A,this._vectors4[A]);for(const A in this._quaternions)k.setQuaternion(A,this._quaternions[A]);for(const A in this._quaternionsArrays)k._quaternionsArrays[A]=this._quaternionsArrays[A];for(const A in this._matrices)k.setMatrix(A,this._matrices[A]);for(const A in this._matrixArrays)k._matrixArrays[A]=this._matrixArrays[A].slice();for(const A in this._matrices3x3)k.setMatrix3x3(A,this._matrices3x3[A]);for(const A in this._matrices2x2)k.setMatrix2x2(A,this._matrices2x2[A]);for(const A in this._vectors2Arrays)k.setArray2(A,this._vectors2Arrays[A]);for(const A in this._vectors3Arrays)k.setArray3(A,this._vectors3Arrays[A]);for(const A in this._vectors4Arrays)k.setArray4(A,this._vectors4Arrays[A]);for(const A in this._uniformBuffers)k.setUniformBuffer(A,this._uniformBuffers[A]);for(const A in this._textureSamplers)k.setTextureSampler(A,this._textureSamplers[A]);for(const A in this._storageBuffers)k.setStorageBuffer(A,this._storageBuffers[A]);return k}dispose(s,k,h){if(k){let s;for(s in this._textures)this._textures[s].dispose();for(s in this._textureArrays){const k=this._textureArrays[s];for(let s=0;s<k.length;s++)k[s].dispose()}}this._textures={},super.dispose(s,k,h)}serialize(){const s=A.e.Serialize(this);let k;for(k in s.customType="BABYLON.ShaderMaterial",s.uniqueId=this.uniqueId,s.options=this._options,s.shaderPath=this._shaderPath,s.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,s.Bh=this.Bh.serialize(),s.textures={},this._textures)s.textures[k]=this._textures[k].serialize();for(k in s.textureArrays={},this._textureArrays){s.textureArrays[k]=[];const h=this._textureArrays[k];for(let A=0;A<h.length;A++)s.textureArrays[k].push(h[A].serialize())}for(k in s.ints={},this._ints)s.ints[k]=this._ints[k];for(k in s.uints={},this._uints)s.uints[k]=this._uints[k];for(k in s.floats={},this._floats)s.floats[k]=this._floats[k];for(k in s.floatsArrays={},this._floatsArrays)s.floatsArrays[k]=this._floatsArrays[k];for(k in s.colors3={},this._colors3){const h=this._colors3[k];s.colors3[k]=[h.r,h.g,h.b]}for(k in s.colors3Arrays={},this._colors3Arrays)s.colors3Arrays[k]=this._colors3Arrays[k];for(k in s.colors4={},this._colors4){const h=this._colors4[k];s.colors4[k]=[h.r,h.g,h.b,h.a]}for(k in s.colors4Arrays={},this._colors4Arrays)s.colors4Arrays[k]=this._colors4Arrays[k];for(k in s.vectors2={},this._vectors2){const h=this._vectors2[k];s.vectors2[k]=[h.x,h.y]}for(k in s.vectors3={},this._vectors3){const h=this._vectors3[k];s.vectors3[k]=[h.x,h.y,h.z]}for(k in s.vectors4={},this._vectors4){const h=this._vectors4[k];s.vectors4[k]=[h.x,h.y,h.z,h.w]}for(k in s.quaternions={},this._quaternions)s.quaternions[k]=this._quaternions[k].yh();for(k in s.matrices={},this._matrices)s.matrices[k]=this._matrices[k].yh();for(k in s.matrixArray={},this._matrixArrays)s.matrixArray[k]=this._matrixArrays[k];for(k in s.matrices3x3={},this._matrices3x3)s.matrices3x3[k]=this._matrices3x3[k];for(k in s.matrices2x2={},this._matrices2x2)s.matrices2x2[k]=this._matrices2x2[k];for(k in s.vectors2Arrays={},this._vectors2Arrays)s.vectors2Arrays[k]=this._vectors2Arrays[k];for(k in s.vectors3Arrays={},this._vectors3Arrays)s.vectors3Arrays[k]=this._vectors3Arrays[k];for(k in s.vectors4Arrays={},this._vectors4Arrays)s.vectors4Arrays[k]=this._vectors4Arrays[k];for(k in s.quaternionsArrays={},this._quaternionsArrays)s.quaternionsArrays[k]=this._quaternionsArrays[k];return s}static Parse(s,k,h){const g=A.e.Parse((()=>new j(s.name,k,s.shaderPath,s.options,s.storeEffectOnSubMeshes)),s,k,h);let i;for(i in s.Bh&&g.Bh.parse(s.Bh,k,h),s.textures)g.setTexture(i,K.b.Parse(s.textures[i],k,h));for(i in s.textureArrays){const A=s.textureArrays[i],ms=[];for(let s=0;s<A.length;s++)ms.push(K.b.Parse(A[s],k,h));g.setTextureArray(i,ms)}for(i in s.ints)g.setInt(i,s.ints[i]);for(i in s.uints)g.setUInt(i,s.uints[i]);for(i in s.floats)g.setFloat(i,s.floats[i]);for(i in s.floatsArrays)g.setFloats(i,s.floatsArrays[i]);for(i in s.colors3){const k=s.colors3[i];g.setColor3(i,{r:k[0],g:k[1],b:k[2]})}for(i in s.colors3Arrays){const k=s.colors3Arrays[i].reduce(((s,k,h)=>(h%3===0?s.push([k]):s[s.length-1].push(k),s)),[]).map((s=>({r:s[0],g:s[1],b:s[2]})));g.setColor3Array(i,k)}for(i in s.colors4){const k=s.colors4[i];g.setColor4(i,{r:k[0],g:k[1],b:k[2],a:k[3]})}for(i in s.colors4Arrays){const k=s.colors4Arrays[i].reduce(((s,k,h)=>(h%4===0?s.push([k]):s[s.length-1].push(k),s)),[]).map((s=>({r:s[0],g:s[1],b:s[2],a:s[3]})));g.setColor4Array(i,k)}for(i in s.vectors2){const k=s.vectors2[i];g.setVector2(i,{x:k[0],y:k[1]})}for(i in s.vectors3){const k=s.vectors3[i];g.setVector3(i,{x:k[0],y:k[1],z:k[2]})}for(i in s.vectors4){const k=s.vectors4[i];g.setVector4(i,{x:k[0],y:k[1],z:k[2],w:k[3]})}for(i in s.quaternions)g.setQuaternion(i,ms.Quaternion.uk(s.quaternions[i]));for(i in s.matrices)g.setMatrix(i,ms.Matrix.uk(s.matrices[i]));for(i in s.matrixArray)g._matrixArrays[i]=new Float32Array(s.matrixArray[i]);for(i in s.matrices3x3)g.setMatrix3x3(i,s.matrices3x3[i]);for(i in s.matrices2x2)g.setMatrix2x2(i,s.matrices2x2[i]);for(i in s.vectors2Arrays)g.setArray2(i,s.vectors2Arrays[i]);for(i in s.vectors3Arrays)g.setArray3(i,s.vectors3Arrays[i]);for(i in s.vectors4Arrays)g.setArray4(i,s.vectors4Arrays[i]);for(i in s.quaternionsArrays)g.setArray4(i,s.quaternionsArrays[i]);return g}static async ParseFromFileAsync(s,k,h){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((g,ms)=>{const i=new c.d;i.addEventListener("readystatechange",(()=>{if(4==i.readyState)if(200==i.status){const k=JSON.parse(i.responseText),ms=this.Parse(k,h||a.b.LastCreatedScene,A);s&&(ms.name=s),g(ms)}else ms("Unable to load the ShaderMaterial")})),i.open("GET",k),i.send()}))}static async ParseFromSnippetAsync(s,k){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((A,g)=>{const ms=new c.d;ms.addEventListener("readystatechange",(()=>{if(4==ms.readyState)if(200==ms.status){const g=JSON.parse(JSON.parse(ms.responseText).jsonPayload),i=JSON.parse(g.shaderMaterial),K=this.Parse(i,k||a.b.LastCreatedScene,h);K.snippetId=s,A(K)}else g("Unable to load the snippet "+s)})),ms.open("GET",this.SnippetUrl+"/"+s.replace(/#/g,"/")),ms.send()}))}}j.SnippetUrl="https://snippet.babylonjs.com",j.CreateFromSnippetAsync=j.ParseFromSnippetAsync,(0,H.f)("BABYLON.ShaderMaterial",j)}}]);