"use strict";(self.fkqm0epoq5=self.fkqm0epoq5||[]).push([[22],{11955:(D,l,G)=>{G.r(l),G.d(l,{ShaderMaterial:()=>d});var V=G(11739),N=G(11963),M=G(11710),b=G(11788),X=G(11686),t=G(11667),R=G(12038),n=G(11565),g=G(12045),j=G(11571),e=G(12100),K=G(12097);const F={effect:null,subMesh:null};class d extends g.e{constructor(D,l,G){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(D,l,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new M.Matrix,this._cachedWorldViewProjectionMatrix=new M.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=G,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...V}}get shaderPath(){return this._shaderPath}set shaderPath(D){this._shaderPath=D}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(D){-1===this._options.uniforms.indexOf(D)&&this._options.uniforms.push(D)}setTexture(D,l){return-1===this._options.samplers.indexOf(D)&&this._options.samplers.push(D),this._textures[D]=l,this}removeTexture(D){delete this._textures[D]}setTextureArray(D,l){return-1===this._options.samplers.indexOf(D)&&this._options.samplers.push(D),this._checkUniform(D),this._textureArrays[D]=l,this}setExternalTexture(D,l){return-1===this._options.externalTextures.indexOf(D)&&this._options.externalTextures.push(D),this._externalTextures[D]=l,this}setFloat(D,l){return this._checkUniform(D),this._floats[D]=l,this}setInt(D,l){return this._checkUniform(D),this._ints[D]=l,this}setUInt(D,l){return this._checkUniform(D),this._uints[D]=l,this}setFloats(D,l){return this._checkUniform(D),this._floatsArrays[D]=l,this}setColor3(D,l){return this._checkUniform(D),this._colors3[D]=l,this}setColor3Array(D,l){return this._checkUniform(D),this._colors3Arrays[D]=l.reduce(((D,l)=>(D.push(l.r,l.g,l.b),D)),[]),this}setColor4(D,l){return this._checkUniform(D),this._colors4[D]=l,this}setColor4Array(D,l){return this._checkUniform(D),this._colors4Arrays[D]=l.reduce(((D,l)=>(D.push(l.r,l.g,l.b,l.a),D)),[]),this}setVector2(D,l){return this._checkUniform(D),this._vectors2[D]=l,this}setVector3(D,l){return this._checkUniform(D),this._vectors3[D]=l,this}setVector4(D,l){return this._checkUniform(D),this._vectors4[D]=l,this}setQuaternion(D,l){return this._checkUniform(D),this._quaternions[D]=l,this}setQuaternionArray(D,l){return this._checkUniform(D),this._quaternionsArrays[D]=l.reduce(((D,l)=>(l.toArray(D,D.length),D)),[]),this}setMatrix(D,l){return this._checkUniform(D),this._matrices[D]=l,this}setMatrices(D,l){this._checkUniform(D);const G=new Float32Array(16*l.length);for(let V=0;V<l.length;V++){l[V].copyToArray(G,16*V)}return this._matrixArrays[D]=G,this}setMatrix3x3(D,l){return this._checkUniform(D),this._matrices3x3[D]=l,this}setMatrix2x2(D,l){return this._checkUniform(D),this._matrices2x2[D]=l,this}setArray2(D,l){return this._checkUniform(D),this._vectors2Arrays[D]=l,this}setArray3(D,l){return this._checkUniform(D),this._vectors3Arrays[D]=l,this}setArray4(D,l){return this._checkUniform(D),this._vectors4Arrays[D]=l,this}setUniformBuffer(D,l){return-1===this._options.uniformBuffers.indexOf(D)&&this._options.uniformBuffers.push(D),this._uniformBuffers[D]=l,this}setTextureSampler(D,l){return-1===this._options.samplerObjects.indexOf(D)&&this._options.samplerObjects.push(D),this._textureSamplers[D]=l,this}setStorageBuffer(D,l){return-1===this._options.storageBuffers.indexOf(D)&&this._options.storageBuffers.push(D),this._storageBuffers[D]=l,this}setDefine(D,l){const G=D.trimEnd()+" ",V=this.options.defines.findIndex((l=>l===D||l.startsWith(G)));return V>=0&&this.options.defines.splice(V,1),("boolean"!==typeof l||l)&&this.options.defines.push(G+l),this}isReadyForSubMesh(D,l,G){return this.isReady(D,G,l)}isReady(D,l,G){var V;const M=G&&this._storeEffectOnSubMeshes;if(this.isFrozen){const D=M?G._drawWrapper:this._drawWrapper;if(D.effect&&D._wasPreviouslyReady&&D._wasPreviouslyUsingInstances===l)return!0}const X=this.uD(),t=X.getEngine(),n=[],g=[];let j=null,d=this._shaderPath,H=this._options.uniforms,h=this._options.uniformBuffers,x=this._options.samplers;t.getCaps().multiview&&X.activeCamera&&X.activeCamera.outputRenderTarget&&X.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,n.push("#define MULTIVIEW"),-1!==H.indexOf("viewProjection")&&-1===H.indexOf("viewProjectionR")&&H.push("viewProjectionR"));for(let N=0;N<this._options.defines.length;N++){const D=0===this._options.defines[N].indexOf("#define")?this._options.defines[N]:`#define ${this._options.defines[N]}`;n.push(D)}for(let N=0;N<this._options.attributes.length;N++)g.push(this._options.attributes[N]);if(D&&D.isVerticesDataPresent(b.e.ColorKind)&&(-1===g.indexOf(b.e.ColorKind)&&g.push(b.e.ColorKind),n.push("#define VERTEXCOLOR")),l&&(n.push("#define INSTANCES"),(0,K.db)(g,this._materialHelperNeedsPreviousMatrices),null!==D&&void 0!==D&&D.hasThinInstances&&(n.push("#define THIN_INSTANCES"),D&&D.isVerticesDataPresent(b.e.ColorInstanceKind)&&(g.push(b.e.ColorInstanceKind),n.push("#define INSTANCESCOLOR")))),D&&D.useBones&&D.computeBonesUsingShaders&&D.skeleton){g.push(b.e.MatricesIndicesKind),g.push(b.e.MatricesWeightsKind),D.numBoneInfluencers>4&&(g.push(b.e.MatricesIndicesExtraKind),g.push(b.e.MatricesWeightsExtraKind));const l=D.skeleton;n.push("#define NUM_BONE_INFLUENCERS "+D.numBoneInfluencers),j=new R.d,j.addCPUSkinningFallback(0,D),l.isUsingTextureForMatrices?(n.push("#define BONETEXTURE"),-1===H.indexOf("boneTextureWidth")&&H.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(n.push("#define BonesPerMesh "+(l.bones.length+1)),-1===H.indexOf("mBones")&&H.push("mBones"))}else n.push("#define NUM_BONE_INFLUENCERS 0");let r=0;const o=D?D.morphTargetManager:null;if(o){const l=-1!==n.indexOf("#define UV1"),G=-1!==n.indexOf("#define UV2"),V=-1!==n.indexOf("#define TANGENT"),N=-1!==n.indexOf("#define NORMAL"),M=-1!==n.indexOf("#define VERTEXCOLOR");r=(0,K.C)(o,n,g,D,!0,N,V,l,G,M),o.isUsingTextureForTargets&&(-1===H.indexOf("morphTargetTextureIndices")&&H.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),r>0&&(H=H.slice(),H.push("morphTargetInfluences"),H.push("morphTargetCount"),H.push("morphTargetTextureInfo"),H.push("morphTargetTextureIndices"))}else n.push("#define NUM_MORPH_INFLUENCERS 0");if(D){const l=D.bakedVertexAnimationManager;l&&l.isEnabled&&(n.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===H.indexOf("bakedVertexAnimationSettings")&&H.push("bakedVertexAnimationSettings"),-1===H.indexOf("bakedVertexAnimationTextureSizeInverted")&&H.push("bakedVertexAnimationTextureSizeInverted"),-1===H.indexOf("bakedVertexAnimationTime")&&H.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,K.t)(g,D,n)}for(const N in this._textures)if(!this._textures[N].isReady())return!1;D&&this.needAlphaTestingForMesh(D)&&n.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,e.d)(H),(0,e.k)(this,X,n)),X.fogEnabled&&null!==D&&void 0!==D&&D.applyFog&&X.fogMode!==N.b.FOGMODE_NONE&&(n.push("#define FOG"),-1===H.indexOf("view")&&H.push("view"),-1===H.indexOf("vFogInfos")&&H.push("vFogInfos"),-1===H.indexOf("vFogColor")&&H.push("vFogColor")),this._useLogarithmicDepth&&(n.push("#define LOGARITHMICDEPTH"),-1===H.indexOf("logarithmicDepthConstant")&&H.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(H=H.slice(),h=h.slice(),x=x.slice(),d=this.customShaderNameResolve(this.name,H,h,x,n,g));const L=M?G._getDrawWrapper(void 0,!0):this._drawWrapper,u=(null===L||void 0===L?void 0:L.effect)??null,B=(null===L||void 0===L?void 0:L.defines)??null,I=n.join("\n");let W=u;return B!==I&&(W=t.createEffect(d,{attributes:g,uniformsNames:H,uniformBuffersNames:h,samplers:x,defines:I,fallbacks:j,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:r},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},t),M?G.setEffect(W,I,this._materialContext):L&&L.setEffect(W,I),this._onEffectCreatedObservable&&(F.effect=W,F.subMesh=G??(null===D||void 0===D?void 0:D.nb[0])??null,this._onEffectCreatedObservable.notifyObservers(F))),L._wasPreviouslyUsingInstances=!!l,!(null===(V=W)||void 0===V||!V.isReady())&&(u!==W&&X.resetCachedMaterial(),L._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(D,l){const G=l??this.getEffect();if(!G)return;const V=this._options.uniforms;-1!==V.indexOf("world")&&G.setMatrix("world",D);const N=this.uD();-1!==V.indexOf("worldView")&&(D.multiplyToRef(N.getViewMatrix(),this._cachedWorldViewMatrix),G.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==V.indexOf("worldViewProjection")&&(D.multiplyToRef(N.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),G.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==V.indexOf("view")&&G.setMatrix("view",N.getViewMatrix())}bindForSubMesh(D,l,G){var V;this.bind(D,l,null===(V=G._drawWrapperOverride)||void 0===V?void 0:V.effect,G)}bind(D,l,G,V){const N=V&&this._storeEffectOnSubMeshes,M=G??(N?V.effect:this.getEffect());if(!M)return;const b=this.uD();this._activeEffect=M,this.bindOnlyWorldMatrix(D,G);const X=this._options.uniformBuffers;let t=!1;if(M&&X&&X.length>0&&b.getEngine().supportsUniformBuffers)for(let g=0;g<X.length;++g){switch(X[g]){case"Mesh":l&&(l.getMeshUniformBuffer().bindToEffect(M,"Mesh"),l.transferToEffect(D));break;case"Scene":(0,K.o)(M,b.getSceneUniformBuffer()),b.finalizeSceneUbo(),t=!0}}const R=l&&N?this._mustRebind(b,M,V,l.visibility):b.getCachedMaterial()!==this;if(M&&R){let D;for(D in t||-1===this._options.uniforms.indexOf("view")||M.setMatrix("view",b.getViewMatrix()),t||-1===this._options.uniforms.indexOf("projection")||M.setMatrix("projection",b.getProjectionMatrix()),t||-1===this._options.uniforms.indexOf("viewProjection")||(M.setMatrix("viewProjection",b.getTransformMatrix()),this._multiview&&M.setMatrix("viewProjectionR",b._transformMatrixR)),b.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&M.setVector3("cameraPosition",b.activeCamera.globalPosition),(0,K.d)(l,M),(0,e.f)(M,this,b),this._useLogarithmicDepth&&(0,K.j)(N?V.materialDefines:M.defines,M,b),l&&(0,K.g)(b,l,M),this._textures)M.setTexture(D,this._textures[D]);for(D in this._textureArrays)M.setTextureArray(D,this._textureArrays[D]);for(D in this._ints)M.setInt(D,this._ints[D]);for(D in this._uints)M.setUInt(D,this._uints[D]);for(D in this._floats)M.setFloat(D,this._floats[D]);for(D in this._floatsArrays)M.setArray(D,this._floatsArrays[D]);for(D in this._colors3)M.setColor3(D,this._colors3[D]);for(D in this._colors3Arrays)M.setArray3(D,this._colors3Arrays[D]);for(D in this._colors4){const l=this._colors4[D];M.setFloat4(D,l.r,l.g,l.b,l.a)}for(D in this._colors4Arrays)M.setArray4(D,this._colors4Arrays[D]);for(D in this._vectors2)M.setVector2(D,this._vectors2[D]);for(D in this._vectors3)M.setVector3(D,this._vectors3[D]);for(D in this._vectors4)M.setVector4(D,this._vectors4[D]);for(D in this._quaternions)M.setQuaternion(D,this._quaternions[D]);for(D in this._matrices)M.setMatrix(D,this._matrices[D]);for(D in this._matrixArrays)M.setMatrices(D,this._matrixArrays[D]);for(D in this._matrices3x3)M.setMatrix3x3(D,this._matrices3x3[D]);for(D in this._matrices2x2)M.setMatrix2x2(D,this._matrices2x2[D]);for(D in this._vectors2Arrays)M.setArray2(D,this._vectors2Arrays[D]);for(D in this._vectors3Arrays)M.setArray3(D,this._vectors3Arrays[D]);for(D in this._vectors4Arrays)M.setArray4(D,this._vectors4Arrays[D]);for(D in this._quaternionsArrays)M.setArray4(D,this._quaternionsArrays[D]);for(D in this._uniformBuffers){const l=this._uniformBuffers[D].getBuffer();l&&M.bindUniformBuffer(l,D)}const G=b.getEngine(),X=G.setExternalTexture;if(X)for(D in this._externalTextures)X.call(G,D,this._externalTextures[D]);const R=G.setTextureSampler;if(R)for(D in this._textureSamplers)R.call(G,D,this._textureSamplers[D]);const n=G.setStorageBuffer;if(n)for(D in this._storageBuffers)n.call(G,D,this._storageBuffers[D])}if(M&&l&&(R||!this.isFrozen)){(0,K.k)(l,M),l.morphTargetManager&&l.morphTargetManager.isUsingTextureForTargets&&l.morphTargetManager._bind(M);const D=l.bakedVertexAnimationManager;if(D&&D.isEnabled){var n;const D=N?V._drawWrapper:this._drawWrapper;null===(n=l.bakedVertexAnimationManager)||void 0===n||n.bind(M,!!D._wasPreviouslyUsingInstances)}}this._afterBind(l,M,V)}getActiveTextures(){const D=super.getActiveTextures();for(const l in this._textures)D.push(this._textures[l]);for(const l in this._textureArrays){const G=this._textureArrays[l];for(let l=0;l<G.length;l++)D.push(G[l])}return D}hasTexture(D){if(super.hasTexture(D))return!0;for(const l in this._textures)if(this._textures[l]===D)return!0;for(const l in this._textureArrays){const G=this._textureArrays[l];for(let l=0;l<G.length;l++)if(G[l]===D)return!0}return!1}clone(D){const l=V.c.Clone((()=>new d(D,this.uD(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);l.name=D,l.id=D,"object"===typeof l._shaderPath&&(l._shaderPath={...l._shaderPath}),this._options={...this._options};const G=Object.keys(this._options);for(const V of G){const D=this._options[V];Array.isArray(D)&&(this._options[V]=D.slice(0))}this.stencil.copyTo(l.stencil);for(const V in this._textures)l.setTexture(V,this._textures[V]);for(const V in this._textureArrays)l.setTextureArray(V,this._textureArrays[V]);for(const V in this._externalTextures)l.setExternalTexture(V,this._externalTextures[V]);for(const V in this._ints)l.setInt(V,this._ints[V]);for(const V in this._uints)l.setUInt(V,this._uints[V]);for(const V in this._floats)l.setFloat(V,this._floats[V]);for(const V in this._floatsArrays)l.setFloats(V,this._floatsArrays[V]);for(const V in this._colors3)l.setColor3(V,this._colors3[V]);for(const V in this._colors3Arrays)l._colors3Arrays[V]=this._colors3Arrays[V];for(const V in this._colors4)l.setColor4(V,this._colors4[V]);for(const V in this._colors4Arrays)l._colors4Arrays[V]=this._colors4Arrays[V];for(const V in this._vectors2)l.setVector2(V,this._vectors2[V]);for(const V in this._vectors3)l.setVector3(V,this._vectors3[V]);for(const V in this._vectors4)l.setVector4(V,this._vectors4[V]);for(const V in this._quaternions)l.setQuaternion(V,this._quaternions[V]);for(const V in this._quaternionsArrays)l._quaternionsArrays[V]=this._quaternionsArrays[V];for(const V in this._matrices)l.setMatrix(V,this._matrices[V]);for(const V in this._matrixArrays)l._matrixArrays[V]=this._matrixArrays[V].slice();for(const V in this._matrices3x3)l.setMatrix3x3(V,this._matrices3x3[V]);for(const V in this._matrices2x2)l.setMatrix2x2(V,this._matrices2x2[V]);for(const V in this._vectors2Arrays)l.setArray2(V,this._vectors2Arrays[V]);for(const V in this._vectors3Arrays)l.setArray3(V,this._vectors3Arrays[V]);for(const V in this._vectors4Arrays)l.setArray4(V,this._vectors4Arrays[V]);for(const V in this._uniformBuffers)l.setUniformBuffer(V,this._uniformBuffers[V]);for(const V in this._textureSamplers)l.setTextureSampler(V,this._textureSamplers[V]);for(const V in this._storageBuffers)l.setStorageBuffer(V,this._storageBuffers[V]);return l}dispose(D,l,G){if(l){let D;for(D in this._textures)this._textures[D].dispose();for(D in this._textureArrays){const l=this._textureArrays[D];for(let D=0;D<l.length;D++)l[D].dispose()}}this._textures={},super.dispose(D,l,G)}serialize(){const D=V.c.Serialize(this);let l;for(l in D.customType="BABYLON.ShaderMaterial",D.uniqueId=this.uniqueId,D.options=this._options,D.shaderPath=this._shaderPath,D.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,D.stencil=this.stencil.serialize(),D.textures={},this._textures)D.textures[l]=this._textures[l].serialize();for(l in D.textureArrays={},this._textureArrays){D.textureArrays[l]=[];const G=this._textureArrays[l];for(let V=0;V<G.length;V++)D.textureArrays[l].push(G[V].serialize())}for(l in D.ints={},this._ints)D.ints[l]=this._ints[l];for(l in D.uints={},this._uints)D.uints[l]=this._uints[l];for(l in D.floats={},this._floats)D.floats[l]=this._floats[l];for(l in D.floatsArrays={},this._floatsArrays)D.floatsArrays[l]=this._floatsArrays[l];for(l in D.colors3={},this._colors3){const G=this._colors3[l];D.colors3[l]=[G.r,G.g,G.b]}for(l in D.colors3Arrays={},this._colors3Arrays)D.colors3Arrays[l]=this._colors3Arrays[l];for(l in D.colors4={},this._colors4){const G=this._colors4[l];D.colors4[l]=[G.r,G.g,G.b,G.a]}for(l in D.colors4Arrays={},this._colors4Arrays)D.colors4Arrays[l]=this._colors4Arrays[l];for(l in D.vectors2={},this._vectors2){const G=this._vectors2[l];D.vectors2[l]=[G.x,G.y]}for(l in D.vectors3={},this._vectors3){const G=this._vectors3[l];D.vectors3[l]=[G.x,G.y,G.z]}for(l in D.vectors4={},this._vectors4){const G=this._vectors4[l];D.vectors4[l]=[G.x,G.y,G.z,G.w]}for(l in D.quaternions={},this._quaternions)D.quaternions[l]=this._quaternions[l].gb();for(l in D.matrices={},this._matrices)D.matrices[l]=this._matrices[l].gb();for(l in D.matrixArray={},this._matrixArrays)D.matrixArray[l]=this._matrixArrays[l];for(l in D.matrices3x3={},this._matrices3x3)D.matrices3x3[l]=this._matrices3x3[l];for(l in D.matrices2x2={},this._matrices2x2)D.matrices2x2[l]=this._matrices2x2[l];for(l in D.vectors2Arrays={},this._vectors2Arrays)D.vectors2Arrays[l]=this._vectors2Arrays[l];for(l in D.vectors3Arrays={},this._vectors3Arrays)D.vectors3Arrays[l]=this._vectors3Arrays[l];for(l in D.vectors4Arrays={},this._vectors4Arrays)D.vectors4Arrays[l]=this._vectors4Arrays[l];for(l in D.quaternionsArrays={},this._quaternionsArrays)D.quaternionsArrays[l]=this._quaternionsArrays[l];return D}static Parse(D,l,G){const N=V.c.Parse((()=>new d(D.name,l,D.shaderPath,D.options,D.storeEffectOnSubMeshes)),D,l,G);let b;for(b in D.stencil&&N.stencil.parse(D.stencil,l,G),D.textures)N.setTexture(b,X.b.Parse(D.textures[b],l,G));for(b in D.textureArrays){const V=D.textureArrays[b],M=[];for(let D=0;D<V.length;D++)M.push(X.b.Parse(V[D],l,G));N.setTextureArray(b,M)}for(b in D.ints)N.setInt(b,D.ints[b]);for(b in D.uints)N.setUInt(b,D.uints[b]);for(b in D.floats)N.setFloat(b,D.floats[b]);for(b in D.floatsArrays)N.setFloats(b,D.floatsArrays[b]);for(b in D.colors3){const l=D.colors3[b];N.setColor3(b,{r:l[0],g:l[1],b:l[2]})}for(b in D.colors3Arrays){const l=D.colors3Arrays[b].reduce(((D,l,G)=>(G%3===0?D.push([l]):D[D.length-1].push(l),D)),[]).map((D=>({r:D[0],g:D[1],b:D[2]})));N.setColor3Array(b,l)}for(b in D.colors4){const l=D.colors4[b];N.setColor4(b,{r:l[0],g:l[1],b:l[2],a:l[3]})}for(b in D.colors4Arrays){const l=D.colors4Arrays[b].reduce(((D,l,G)=>(G%4===0?D.push([l]):D[D.length-1].push(l),D)),[]).map((D=>({r:D[0],g:D[1],b:D[2],a:D[3]})));N.setColor4Array(b,l)}for(b in D.vectors2){const l=D.vectors2[b];N.setVector2(b,{x:l[0],y:l[1]})}for(b in D.vectors3){const l=D.vectors3[b];N.setVector3(b,{x:l[0],y:l[1],z:l[2]})}for(b in D.vectors4){const l=D.vectors4[b];N.setVector4(b,{x:l[0],y:l[1],z:l[2],w:l[3]})}for(b in D.quaternions)N.setQuaternion(b,M.Quaternion.xl(D.quaternions[b]));for(b in D.matrices)N.setMatrix(b,M.Matrix.xl(D.matrices[b]));for(b in D.matrixArray)N._matrixArrays[b]=new Float32Array(D.matrixArray[b]);for(b in D.matrices3x3)N.setMatrix3x3(b,D.matrices3x3[b]);for(b in D.matrices2x2)N.setMatrix2x2(b,D.matrices2x2[b]);for(b in D.vectors2Arrays)N.setArray2(b,D.vectors2Arrays[b]);for(b in D.vectors3Arrays)N.setArray3(b,D.vectors3Arrays[b]);for(b in D.vectors4Arrays)N.setArray4(b,D.vectors4Arrays[b]);for(b in D.quaternionsArrays)N.setArray4(b,D.quaternionsArrays[b]);return N}static async ParseFromFileAsync(D,l,G){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((N,M)=>{const b=new n.d;b.addEventListener("readystatechange",(()=>{if(4==b.readyState)if(200==b.status){const l=JSON.parse(b.responseText),M=this.Parse(l,G||j.d.LastCreatedScene,V);D&&(M.name=D),N(M)}else M("Unable to load the ShaderMaterial")})),b.open("GET",l),b.send()}))}static async ParseFromSnippetAsync(D,l){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((V,N)=>{const M=new n.d;M.addEventListener("readystatechange",(()=>{if(4==M.readyState)if(200==M.status){const N=JSON.parse(JSON.parse(M.responseText).jsonPayload),b=JSON.parse(N.shaderMaterial),X=this.Parse(b,l||j.d.LastCreatedScene,G);X.snippetId=D,V(X)}else N("Unable to load the snippet "+D)})),M.open("GET",this.SnippetUrl+"/"+D.replace(/#/g,"/")),M.send()}))}}d.SnippetUrl="https://snippet.babylonjs.com",d.CreateFromSnippetAsync=d.ParseFromSnippetAsync,(0,t.c)("BABYLON.ShaderMaterial",d)}}]);