"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[22],{12813:(L,U,x)=>{x.r(U),x.d(U,{ShaderMaterial:()=>V});var mL=x(12625),p=x(12820),G=x(12589),F=x(12666),a=x(12565),o=x(12547),A=x(12906),r=x(12434),h=x(12909),b=x(12440),E=x(12966),Y=x(12961);const S={effect:null,subMesh:null};class V extends h.d{constructor(L,U,x){let mL=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(L,U,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new G.Matrix,this._cachedWorldViewProjectionMatrix=new G.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=x,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...mL}}get shaderPath(){return this._shaderPath}set shaderPath(L){this._shaderPath=L}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(L){-1===this._options.uniforms.indexOf(L)&&this._options.uniforms.push(L)}setTexture(L,U){return-1===this._options.samplers.indexOf(L)&&this._options.samplers.push(L),this._textures[L]=U,this}removeTexture(L){delete this._textures[L]}setTextureArray(L,U){return-1===this._options.samplers.indexOf(L)&&this._options.samplers.push(L),this._checkUniform(L),this._textureArrays[L]=U,this}setExternalTexture(L,U){return-1===this._options.externalTextures.indexOf(L)&&this._options.externalTextures.push(L),this._externalTextures[L]=U,this}setFloat(L,U){return this._checkUniform(L),this._floats[L]=U,this}setInt(L,U){return this._checkUniform(L),this._ints[L]=U,this}setUInt(L,U){return this._checkUniform(L),this._uints[L]=U,this}setFloats(L,U){return this._checkUniform(L),this._floatsArrays[L]=U,this}setColor3(L,U){return this._checkUniform(L),this._colors3[L]=U,this}setColor3Array(L,U){return this._checkUniform(L),this._colors3Arrays[L]=U.reduce(((L,U)=>(L.push(U.r,U.g,U.b),L)),[]),this}setColor4(L,U){return this._checkUniform(L),this._colors4[L]=U,this}setColor4Array(L,U){return this._checkUniform(L),this._colors4Arrays[L]=U.reduce(((L,U)=>(L.push(U.r,U.g,U.b,U.a),L)),[]),this}setVector2(L,U){return this._checkUniform(L),this._vectors2[L]=U,this}setVector3(L,U){return this._checkUniform(L),this._vectors3[L]=U,this}setVector4(L,U){return this._checkUniform(L),this._vectors4[L]=U,this}setQuaternion(L,U){return this._checkUniform(L),this._quaternions[L]=U,this}setQuaternionArray(L,U){return this._checkUniform(L),this._quaternionsArrays[L]=U.reduce(((L,U)=>(U.toArray(L,L.length),L)),[]),this}setMatrix(L,U){return this._checkUniform(L),this._matrices[L]=U,this}setMatrices(L,U){this._checkUniform(L);const x=new Float32Array(16*U.length);for(let mL=0;mL<U.length;mL++){U[mL].copyToArray(x,16*mL)}return this._matrixArrays[L]=x,this}setMatrix3x3(L,U){return this._checkUniform(L),this._matrices3x3[L]=U,this}setMatrix2x2(L,U){return this._checkUniform(L),this._matrices2x2[L]=U,this}setArray2(L,U){return this._checkUniform(L),this._vectors2Arrays[L]=U,this}setArray3(L,U){return this._checkUniform(L),this._vectors3Arrays[L]=U,this}setArray4(L,U){return this._checkUniform(L),this._vectors4Arrays[L]=U,this}setUniformBuffer(L,U){return-1===this._options.uniformBuffers.indexOf(L)&&this._options.uniformBuffers.push(L),this._uniformBuffers[L]=U,this}setTextureSampler(L,U){return-1===this._options.samplerObjects.indexOf(L)&&this._options.samplerObjects.push(L),this._textureSamplers[L]=U,this}setStorageBuffer(L,U){return-1===this._options.storageBuffers.indexOf(L)&&this._options.storageBuffers.push(L),this._storageBuffers[L]=U,this}setDefine(L,U){const x=L.trimEnd()+" ",mL=this.options.defines.findIndex((U=>U===L||U.startsWith(x)));return mL>=0&&this.options.defines.splice(mL,1),("boolean"!==typeof U||U)&&this.options.defines.push(x+U),this}isReadyForSubMesh(L,U,x){return this.isReady(L,x,U)}isReady(L,U,x){var mL;const G=x&&this._storeEffectOnSubMeshes;if(this.isFrozen){const L=G?x._drawWrapper:this._drawWrapper;if(L.effect&&L._wasPreviouslyReady&&L._wasPreviouslyUsingInstances===U)return!0}const a=this.PL(),o=a.getEngine(),r=[],h=[];let b=null,V=this._shaderPath,H=this._options.uniforms,Q=this._options.uniformBuffers,q=this._options.samplers;o.getCaps().multiview&&a.activeCamera&&a.activeCamera.outputRenderTarget&&a.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,r.push("#define MULTIVIEW"),-1!==H.indexOf("viewProjection")&&-1===H.indexOf("viewProjectionR")&&H.push("viewProjectionR"));for(let p=0;p<this._options.defines.length;p++){const L=0===this._options.defines[p].indexOf("#define")?this._options.defines[p]:`#define ${this._options.defines[p]}`;r.push(L)}for(let p=0;p<this._options.attributes.length;p++)h.push(this._options.attributes[p]);if(L&&L.isVerticesDataPresent(F.h.ColorKind)&&(-1===h.indexOf(F.h.ColorKind)&&h.push(F.h.ColorKind),r.push("#define VERTEXCOLOR")),U&&(r.push("#define INSTANCES"),(0,Y.gb)(h,this._materialHelperNeedsPreviousMatrices),null!==L&&void 0!==L&&L.hasThinInstances&&(r.push("#define THIN_INSTANCES"),L&&L.isVerticesDataPresent(F.h.ColorInstanceKind)&&(h.push(F.h.ColorInstanceKind),r.push("#define INSTANCESCOLOR")))),L&&L.useBones&&L.computeBonesUsingShaders&&L.skeleton){h.push(F.h.MatricesIndicesKind),h.push(F.h.MatricesWeightsKind),L.numBoneInfluencers>4&&(h.push(F.h.MatricesIndicesExtraKind),h.push(F.h.MatricesWeightsExtraKind));const U=L.skeleton;r.push("#define NUM_BONE_INFLUENCERS "+L.numBoneInfluencers),b=new A.b,b.addCPUSkinningFallback(0,L),U.isUsingTextureForMatrices?(r.push("#define BONETEXTURE"),-1===H.indexOf("boneTextureWidth")&&H.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(r.push("#define BonesPerMesh "+(U.bones.length+1)),-1===H.indexOf("mBones")&&H.push("mBones"))}else r.push("#define NUM_BONE_INFLUENCERS 0");let f=0;const v=L?L.morphTargetManager:null;if(v){const U=-1!==r.indexOf("#define UV1"),x=-1!==r.indexOf("#define UV2"),mL=-1!==r.indexOf("#define TANGENT"),p=-1!==r.indexOf("#define NORMAL"),G=-1!==r.indexOf("#define VERTEXCOLOR");f=(0,Y.D)(v,r,h,L,!0,p,mL,U,x,G),v.isUsingTextureForTargets&&(-1===H.indexOf("morphTargetTextureIndices")&&H.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),f>0&&(H=H.slice(),H.push("morphTargetInfluences"),H.push("morphTargetCount"),H.push("morphTargetTextureInfo"),H.push("morphTargetTextureIndices"))}else r.push("#define NUM_MORPH_INFLUENCERS 0");if(L){const U=L.bakedVertexAnimationManager;U&&U.isEnabled&&(r.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===H.indexOf("bakedVertexAnimationSettings")&&H.push("bakedVertexAnimationSettings"),-1===H.indexOf("bakedVertexAnimationTextureSizeInverted")&&H.push("bakedVertexAnimationTextureSizeInverted"),-1===H.indexOf("bakedVertexAnimationTime")&&H.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,Y.t)(h,L,r)}for(const p in this._textures)if(!this._textures[p].isReady())return!1;L&&this.needAlphaTestingForMesh(L)&&r.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,E.e)(H),(0,E.o)(this,a,r)),a.fogEnabled&&null!==L&&void 0!==L&&L.applyFog&&a.fogMode!==p.e.FOGMODE_NONE&&(r.push("#define FOG"),-1===H.indexOf("view")&&H.push("view"),-1===H.indexOf("vFogInfos")&&H.push("vFogInfos"),-1===H.indexOf("vFogColor")&&H.push("vFogColor")),this._useLogarithmicDepth&&(r.push("#define LOGARITHMICDEPTH"),-1===H.indexOf("logarithmicDepthConstant")&&H.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(H=H.slice(),Q=Q.slice(),q=q.slice(),V=this.customShaderNameResolve(this.name,H,Q,q,r,h));const D=G?x._getDrawWrapper(void 0,!0):this._drawWrapper,P=(null===D||void 0===D?void 0:D.effect)??null,d=(null===D||void 0===D?void 0:D.defines)??null,K=r.join("\n");let l=P;return d!==K&&(l=o.createEffect(V,{attributes:h,uniformsNames:H,uniformBuffersNames:Q,samplers:q,defines:K,fallbacks:b,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:f},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},o),G?x.setEffect(l,K,this._materialContext):D&&D.setEffect(l,K),this._onEffectCreatedObservable&&(S.effect=l,S.subMesh=x??(null===L||void 0===L?void 0:L.Sa[0])??null,this._onEffectCreatedObservable.notifyObservers(S))),D._wasPreviouslyUsingInstances=!!U,!(null===(mL=l)||void 0===mL||!mL.isReady())&&(P!==l&&a.resetCachedMaterial(),D._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(L,U){const x=U??this.getEffect();if(!x)return;const mL=this._options.uniforms;-1!==mL.indexOf("world")&&x.setMatrix("world",L);const p=this.PL();-1!==mL.indexOf("worldView")&&(L.multiplyToRef(p.getViewMatrix(),this._cachedWorldViewMatrix),x.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==mL.indexOf("worldViewProjection")&&(L.multiplyToRef(p.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),x.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==mL.indexOf("view")&&x.setMatrix("view",p.getViewMatrix())}bindForSubMesh(L,U,x){var mL;this.bind(L,U,null===(mL=x._drawWrapperOverride)||void 0===mL?void 0:mL.effect,x)}bind(L,U,x,mL){const p=mL&&this._storeEffectOnSubMeshes,G=x??(p?mL.effect:this.getEffect());if(!G)return;const F=this.PL();this._activeEffect=G,this.bindOnlyWorldMatrix(L,x);const a=this._options.uniformBuffers;let o=!1;if(G&&a&&a.length>0&&F.getEngine().supportsUniformBuffers)for(let h=0;h<a.length;++h){switch(a[h]){case"Mesh":U&&(U.getMeshUniformBuffer().bindToEffect(G,"Mesh"),U.transferToEffect(L));break;case"Scene":(0,Y.n)(G,F.getSceneUniformBuffer()),F.finalizeSceneUbo(),o=!0}}const A=U&&p?this._mustRebind(F,G,mL,U.visibility):F.getCachedMaterial()!==this;if(G&&A){let L;for(L in o||-1===this._options.uniforms.indexOf("view")||G.setMatrix("view",F.getViewMatrix()),o||-1===this._options.uniforms.indexOf("projection")||G.setMatrix("projection",F.getProjectionMatrix()),o||-1===this._options.uniforms.indexOf("viewProjection")||(G.setMatrix("viewProjection",F.getTransformMatrix()),this._multiview&&G.setMatrix("viewProjectionR",F._transformMatrixR)),F.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&G.setVector3("cameraPosition",F.activeCamera.globalPosition),(0,Y.b)(U,G),(0,E.i)(G,this,F),this._useLogarithmicDepth&&(0,Y.l)(p?mL.materialDefines:G.defines,G,F),U&&(0,Y.f)(F,U,G),this._textures)G.setTexture(L,this._textures[L]);for(L in this._textureArrays)G.setTextureArray(L,this._textureArrays[L]);for(L in this._ints)G.setInt(L,this._ints[L]);for(L in this._uints)G.setUInt(L,this._uints[L]);for(L in this._floats)G.setFloat(L,this._floats[L]);for(L in this._floatsArrays)G.setArray(L,this._floatsArrays[L]);for(L in this._colors3)G.setColor3(L,this._colors3[L]);for(L in this._colors3Arrays)G.setArray3(L,this._colors3Arrays[L]);for(L in this._colors4){const U=this._colors4[L];G.setFloat4(L,U.r,U.g,U.b,U.a)}for(L in this._colors4Arrays)G.setArray4(L,this._colors4Arrays[L]);for(L in this._vectors2)G.setVector2(L,this._vectors2[L]);for(L in this._vectors3)G.setVector3(L,this._vectors3[L]);for(L in this._vectors4)G.setVector4(L,this._vectors4[L]);for(L in this._quaternions)G.setQuaternion(L,this._quaternions[L]);for(L in this._matrices)G.setMatrix(L,this._matrices[L]);for(L in this._matrixArrays)G.setMatrices(L,this._matrixArrays[L]);for(L in this._matrices3x3)G.setMatrix3x3(L,this._matrices3x3[L]);for(L in this._matrices2x2)G.setMatrix2x2(L,this._matrices2x2[L]);for(L in this._vectors2Arrays)G.setArray2(L,this._vectors2Arrays[L]);for(L in this._vectors3Arrays)G.setArray3(L,this._vectors3Arrays[L]);for(L in this._vectors4Arrays)G.setArray4(L,this._vectors4Arrays[L]);for(L in this._quaternionsArrays)G.setArray4(L,this._quaternionsArrays[L]);for(L in this._uniformBuffers){const U=this._uniformBuffers[L].getBuffer();U&&G.bindUniformBuffer(U,L)}const x=F.getEngine(),a=x.setExternalTexture;if(a)for(L in this._externalTextures)a.call(x,L,this._externalTextures[L]);const A=x.setTextureSampler;if(A)for(L in this._textureSamplers)A.call(x,L,this._textureSamplers[L]);const r=x.setStorageBuffer;if(r)for(L in this._storageBuffers)r.call(x,L,this._storageBuffers[L])}if(G&&U&&(A||!this.isFrozen)){(0,Y.m)(U,G),U.morphTargetManager&&U.morphTargetManager.isUsingTextureForTargets&&U.morphTargetManager._bind(G);const L=U.bakedVertexAnimationManager;if(L&&L.isEnabled){var r;const L=p?mL._drawWrapper:this._drawWrapper;null===(r=U.bakedVertexAnimationManager)||void 0===r||r.bind(G,!!L._wasPreviouslyUsingInstances)}}this._afterBind(U,G,mL)}getActiveTextures(){const L=super.getActiveTextures();for(const U in this._textures)L.push(this._textures[U]);for(const U in this._textureArrays){const x=this._textureArrays[U];for(let U=0;U<x.length;U++)L.push(x[U])}return L}hasTexture(L){if(super.hasTexture(L))return!0;for(const U in this._textures)if(this._textures[U]===L)return!0;for(const U in this._textureArrays){const x=this._textureArrays[U];for(let U=0;U<x.length;U++)if(x[U]===L)return!0}return!1}clone(L){const U=mL.e.Clone((()=>new V(L,this.PL(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);U.name=L,U.id=L,"object"===typeof U._shaderPath&&(U._shaderPath={...U._shaderPath}),this._options={...this._options};const x=Object.keys(this._options);for(const mL of x){const L=this._options[mL];Array.isArray(L)&&(this._options[mL]=L.slice(0))}this.Aa.copyTo(U.Aa);for(const mL in this._textures)U.setTexture(mL,this._textures[mL]);for(const mL in this._textureArrays)U.setTextureArray(mL,this._textureArrays[mL]);for(const mL in this._externalTextures)U.setExternalTexture(mL,this._externalTextures[mL]);for(const mL in this._ints)U.setInt(mL,this._ints[mL]);for(const mL in this._uints)U.setUInt(mL,this._uints[mL]);for(const mL in this._floats)U.setFloat(mL,this._floats[mL]);for(const mL in this._floatsArrays)U.setFloats(mL,this._floatsArrays[mL]);for(const mL in this._colors3)U.setColor3(mL,this._colors3[mL]);for(const mL in this._colors3Arrays)U._colors3Arrays[mL]=this._colors3Arrays[mL];for(const mL in this._colors4)U.setColor4(mL,this._colors4[mL]);for(const mL in this._colors4Arrays)U._colors4Arrays[mL]=this._colors4Arrays[mL];for(const mL in this._vectors2)U.setVector2(mL,this._vectors2[mL]);for(const mL in this._vectors3)U.setVector3(mL,this._vectors3[mL]);for(const mL in this._vectors4)U.setVector4(mL,this._vectors4[mL]);for(const mL in this._quaternions)U.setQuaternion(mL,this._quaternions[mL]);for(const mL in this._quaternionsArrays)U._quaternionsArrays[mL]=this._quaternionsArrays[mL];for(const mL in this._matrices)U.setMatrix(mL,this._matrices[mL]);for(const mL in this._matrixArrays)U._matrixArrays[mL]=this._matrixArrays[mL].slice();for(const mL in this._matrices3x3)U.setMatrix3x3(mL,this._matrices3x3[mL]);for(const mL in this._matrices2x2)U.setMatrix2x2(mL,this._matrices2x2[mL]);for(const mL in this._vectors2Arrays)U.setArray2(mL,this._vectors2Arrays[mL]);for(const mL in this._vectors3Arrays)U.setArray3(mL,this._vectors3Arrays[mL]);for(const mL in this._vectors4Arrays)U.setArray4(mL,this._vectors4Arrays[mL]);for(const mL in this._uniformBuffers)U.setUniformBuffer(mL,this._uniformBuffers[mL]);for(const mL in this._textureSamplers)U.setTextureSampler(mL,this._textureSamplers[mL]);for(const mL in this._storageBuffers)U.setStorageBuffer(mL,this._storageBuffers[mL]);return U}dispose(L,U,x){if(U){let L;for(L in this._textures)this._textures[L].dispose();for(L in this._textureArrays){const U=this._textureArrays[L];for(let L=0;L<U.length;L++)U[L].dispose()}}this._textures={},super.dispose(L,U,x)}serialize(){const L=mL.e.Serialize(this);let U;for(U in L.customType="BABYLON.ShaderMaterial",L.uniqueId=this.uniqueId,L.options=this._options,L.shaderPath=this._shaderPath,L.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,L.Aa=this.Aa.serialize(),L.textures={},this._textures)L.textures[U]=this._textures[U].serialize();for(U in L.textureArrays={},this._textureArrays){L.textureArrays[U]=[];const x=this._textureArrays[U];for(let mL=0;mL<x.length;mL++)L.textureArrays[U].push(x[mL].serialize())}for(U in L.ints={},this._ints)L.ints[U]=this._ints[U];for(U in L.uints={},this._uints)L.uints[U]=this._uints[U];for(U in L.floats={},this._floats)L.floats[U]=this._floats[U];for(U in L.floatsArrays={},this._floatsArrays)L.floatsArrays[U]=this._floatsArrays[U];for(U in L.colors3={},this._colors3){const x=this._colors3[U];L.colors3[U]=[x.r,x.g,x.b]}for(U in L.colors3Arrays={},this._colors3Arrays)L.colors3Arrays[U]=this._colors3Arrays[U];for(U in L.colors4={},this._colors4){const x=this._colors4[U];L.colors4[U]=[x.r,x.g,x.b,x.a]}for(U in L.colors4Arrays={},this._colors4Arrays)L.colors4Arrays[U]=this._colors4Arrays[U];for(U in L.vectors2={},this._vectors2){const x=this._vectors2[U];L.vectors2[U]=[x.x,x.y]}for(U in L.vectors3={},this._vectors3){const x=this._vectors3[U];L.vectors3[U]=[x.x,x.y,x.z]}for(U in L.vectors4={},this._vectors4){const x=this._vectors4[U];L.vectors4[U]=[x.x,x.y,x.z,x.w]}for(U in L.quaternions={},this._quaternions)L.quaternions[U]=this._quaternions[U].Va();for(U in L.matrices={},this._matrices)L.matrices[U]=this._matrices[U].Va();for(U in L.matrixArray={},this._matrixArrays)L.matrixArray[U]=this._matrixArrays[U];for(U in L.matrices3x3={},this._matrices3x3)L.matrices3x3[U]=this._matrices3x3[U];for(U in L.matrices2x2={},this._matrices2x2)L.matrices2x2[U]=this._matrices2x2[U];for(U in L.vectors2Arrays={},this._vectors2Arrays)L.vectors2Arrays[U]=this._vectors2Arrays[U];for(U in L.vectors3Arrays={},this._vectors3Arrays)L.vectors3Arrays[U]=this._vectors3Arrays[U];for(U in L.vectors4Arrays={},this._vectors4Arrays)L.vectors4Arrays[U]=this._vectors4Arrays[U];for(U in L.quaternionsArrays={},this._quaternionsArrays)L.quaternionsArrays[U]=this._quaternionsArrays[U];return L}static Parse(L,U,x){const p=mL.e.Parse((()=>new V(L.name,U,L.shaderPath,L.options,L.storeEffectOnSubMeshes)),L,U,x);let F;for(F in L.Aa&&p.Aa.parse(L.Aa,U,x),L.textures)p.setTexture(F,a.e.Parse(L.textures[F],U,x));for(F in L.textureArrays){const mL=L.textureArrays[F],G=[];for(let L=0;L<mL.length;L++)G.push(a.e.Parse(mL[L],U,x));p.setTextureArray(F,G)}for(F in L.ints)p.setInt(F,L.ints[F]);for(F in L.uints)p.setUInt(F,L.uints[F]);for(F in L.floats)p.setFloat(F,L.floats[F]);for(F in L.floatsArrays)p.setFloats(F,L.floatsArrays[F]);for(F in L.colors3){const U=L.colors3[F];p.setColor3(F,{r:U[0],g:U[1],b:U[2]})}for(F in L.colors3Arrays){const U=L.colors3Arrays[F].reduce(((L,U,x)=>(x%3===0?L.push([U]):L[L.length-1].push(U),L)),[]).map((L=>({r:L[0],g:L[1],b:L[2]})));p.setColor3Array(F,U)}for(F in L.colors4){const U=L.colors4[F];p.setColor4(F,{r:U[0],g:U[1],b:U[2],a:U[3]})}for(F in L.colors4Arrays){const U=L.colors4Arrays[F].reduce(((L,U,x)=>(x%4===0?L.push([U]):L[L.length-1].push(U),L)),[]).map((L=>({r:L[0],g:L[1],b:L[2],a:L[3]})));p.setColor4Array(F,U)}for(F in L.vectors2){const U=L.vectors2[F];p.setVector2(F,{x:U[0],y:U[1]})}for(F in L.vectors3){const U=L.vectors3[F];p.setVector3(F,{x:U[0],y:U[1],z:U[2]})}for(F in L.vectors4){const U=L.vectors4[F];p.setVector4(F,{x:U[0],y:U[1],z:U[2],w:U[3]})}for(F in L.quaternions)p.setQuaternion(F,G.Quaternion.qU(L.quaternions[F]));for(F in L.matrices)p.setMatrix(F,G.Matrix.qU(L.matrices[F]));for(F in L.matrixArray)p._matrixArrays[F]=new Float32Array(L.matrixArray[F]);for(F in L.matrices3x3)p.setMatrix3x3(F,L.matrices3x3[F]);for(F in L.matrices2x2)p.setMatrix2x2(F,L.matrices2x2[F]);for(F in L.vectors2Arrays)p.setArray2(F,L.vectors2Arrays[F]);for(F in L.vectors3Arrays)p.setArray3(F,L.vectors3Arrays[F]);for(F in L.vectors4Arrays)p.setArray4(F,L.vectors4Arrays[F]);for(F in L.quaternionsArrays)p.setArray4(F,L.quaternionsArrays[F]);return p}static async ParseFromFileAsync(L,U,x){let mL=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((p,G)=>{const F=new r.e;F.addEventListener("readystatechange",(()=>{if(4==F.readyState)if(200==F.status){const U=JSON.parse(F.responseText),G=this.Parse(U,x||b.c.LastCreatedScene,mL);L&&(G.name=L),p(G)}else G("Unable to load the ShaderMaterial")})),F.open("GET",U),F.send()}))}static async ParseFromSnippetAsync(L,U){let x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((mL,p)=>{const G=new r.e;G.addEventListener("readystatechange",(()=>{if(4==G.readyState)if(200==G.status){const p=JSON.parse(JSON.parse(G.responseText).jsonPayload),F=JSON.parse(p.shaderMaterial),a=this.Parse(F,U||b.c.LastCreatedScene,x);a.snippetId=L,mL(a)}else p("Unable to load the snippet "+L)})),G.open("GET",this.SnippetUrl+"/"+L.replace(/#/g,"/")),G.send()}))}}V.SnippetUrl="https://snippet.babylonjs.com",V.CreateFromSnippetAsync=V.ParseFromSnippetAsync,(0,o.d)("BABYLON.ShaderMaterial",V)}}]);