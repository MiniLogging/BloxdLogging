"use strict";(self.n52dyox90qa=self.n52dyox90qa||[]).push([[22],{12046:(E,t,z)=>{z.r(t),z.d(t,{ShaderMaterial:()=>a});var A=z(11849),X=z(12051),R=z(11812),u=z(11894),p=z(11790),C=z(11766),Z=z(12110),H=z(11661),h=z(12116),d=z(11667),y=z(12168),O=z(12162);const c={effect:null,subMesh:null};class a extends h.c{constructor(E,t,z){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(E,t,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new R.Matrix,this._cachedWorldViewProjectionMatrix=new R.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=z,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...A}}get shaderPath(){return this._shaderPath}set shaderPath(E){this._shaderPath=E}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(E){-1===this._options.uniforms.indexOf(E)&&this._options.uniforms.push(E)}setTexture(E,t){return-1===this._options.samplers.indexOf(E)&&this._options.samplers.push(E),this._textures[E]=t,this}removeTexture(E){delete this._textures[E]}setTextureArray(E,t){return-1===this._options.samplers.indexOf(E)&&this._options.samplers.push(E),this._checkUniform(E),this._textureArrays[E]=t,this}setExternalTexture(E,t){return-1===this._options.externalTextures.indexOf(E)&&this._options.externalTextures.push(E),this._externalTextures[E]=t,this}setFloat(E,t){return this._checkUniform(E),this._floats[E]=t,this}setInt(E,t){return this._checkUniform(E),this._ints[E]=t,this}setUInt(E,t){return this._checkUniform(E),this._uints[E]=t,this}setFloats(E,t){return this._checkUniform(E),this._floatsArrays[E]=t,this}setColor3(E,t){return this._checkUniform(E),this._colors3[E]=t,this}setColor3Array(E,t){return this._checkUniform(E),this._colors3Arrays[E]=t.reduce(((E,t)=>(E.push(t.r,t.g,t.b),E)),[]),this}setColor4(E,t){return this._checkUniform(E),this._colors4[E]=t,this}setColor4Array(E,t){return this._checkUniform(E),this._colors4Arrays[E]=t.reduce(((E,t)=>(E.push(t.r,t.g,t.b,t.a),E)),[]),this}setVector2(E,t){return this._checkUniform(E),this._vectors2[E]=t,this}setVector3(E,t){return this._checkUniform(E),this._vectors3[E]=t,this}setVector4(E,t){return this._checkUniform(E),this._vectors4[E]=t,this}setQuaternion(E,t){return this._checkUniform(E),this._quaternions[E]=t,this}setQuaternionArray(E,t){return this._checkUniform(E),this._quaternionsArrays[E]=t.reduce(((E,t)=>(t.toArray(E,E.length),E)),[]),this}setMatrix(E,t){return this._checkUniform(E),this._matrices[E]=t,this}setMatrices(E,t){this._checkUniform(E);const z=new Float32Array(16*t.length);for(let A=0;A<t.length;A++){t[A].copyToArray(z,16*A)}return this._matrixArrays[E]=z,this}setMatrix3x3(E,t){return this._checkUniform(E),this._matrices3x3[E]=t,this}setMatrix2x2(E,t){return this._checkUniform(E),this._matrices2x2[E]=t,this}setArray2(E,t){return this._checkUniform(E),this._vectors2Arrays[E]=t,this}setArray3(E,t){return this._checkUniform(E),this._vectors3Arrays[E]=t,this}setArray4(E,t){return this._checkUniform(E),this._vectors4Arrays[E]=t,this}setUniformBuffer(E,t){return-1===this._options.uniformBuffers.indexOf(E)&&this._options.uniformBuffers.push(E),this._uniformBuffers[E]=t,this}setTextureSampler(E,t){return-1===this._options.samplerObjects.indexOf(E)&&this._options.samplerObjects.push(E),this._textureSamplers[E]=t,this}setStorageBuffer(E,t){return-1===this._options.storageBuffers.indexOf(E)&&this._options.storageBuffers.push(E),this._storageBuffers[E]=t,this}setDefine(E,t){const z=E.trimEnd()+" ",A=this.options.defines.findIndex((t=>t===E||t.startsWith(z)));return A>=0&&this.options.defines.splice(A,1),("boolean"!==typeof t||t)&&this.options.defines.push(z+t),this}isReadyForSubMesh(E,t,z){return this.isReady(E,z,t)}isReady(E,t,z){var A;const R=z&&this._storeEffectOnSubMeshes;if(this.isFrozen){const E=R?z._drawWrapper:this._drawWrapper;if(E.effect&&E._wasPreviouslyReady&&E._wasPreviouslyUsingInstances===t)return!0}const p=this.lE(),C=p.getEngine(),H=[],h=[];let d=null,a=this._shaderPath,L=this._options.uniforms,mE=this._options.uniformBuffers,W=this._options.samplers;C.getCaps().multiview&&p.activeCamera&&p.activeCamera.outputRenderTarget&&p.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,H.push("#define MULTIVIEW"),-1!==L.indexOf("viewProjection")&&-1===L.indexOf("viewProjectionR")&&L.push("viewProjectionR"));for(let X=0;X<this._options.defines.length;X++){const E=0===this._options.defines[X].indexOf("#define")?this._options.defines[X]:`#define ${this._options.defines[X]}`;H.push(E)}for(let X=0;X<this._options.attributes.length;X++)h.push(this._options.attributes[X]);if(E&&E.isVerticesDataPresent(u.f.ColorKind)&&(-1===h.indexOf(u.f.ColorKind)&&h.push(u.f.ColorKind),H.push("#define VERTEXCOLOR")),t&&(H.push("#define INSTANCES"),(0,O.ib)(h,this._materialHelperNeedsPreviousMatrices),null!==E&&void 0!==E&&E.hasThinInstances&&(H.push("#define THIN_INSTANCES"),E&&E.isVerticesDataPresent(u.f.ColorInstanceKind)&&(h.push(u.f.ColorInstanceKind),H.push("#define INSTANCESCOLOR")))),E&&E.useBones&&E.computeBonesUsingShaders&&E.skeleton){h.push(u.f.MatricesIndicesKind),h.push(u.f.MatricesWeightsKind),E.numBoneInfluencers>4&&(h.push(u.f.MatricesIndicesExtraKind),h.push(u.f.MatricesWeightsExtraKind));const t=E.skeleton;H.push("#define NUM_BONE_INFLUENCERS "+E.numBoneInfluencers),d=new Z.d,d.addCPUSkinningFallback(0,E),t.isUsingTextureForMatrices?(H.push("#define BONETEXTURE"),-1===L.indexOf("boneTextureWidth")&&L.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(H.push("#define BonesPerMesh "+(t.bones.length+1)),-1===L.indexOf("mBones")&&L.push("mBones"))}else H.push("#define NUM_BONE_INFLUENCERS 0");let I=0;const e=E?E.morphTargetManager:null;if(e){const t=-1!==H.indexOf("#define UV1"),z=-1!==H.indexOf("#define UV2"),A=-1!==H.indexOf("#define TANGENT"),X=-1!==H.indexOf("#define NORMAL"),R=-1!==H.indexOf("#define VERTEXCOLOR");I=(0,O.F)(e,H,h,E,!0,X,A,t,z,R),e.isUsingTextureForTargets&&(-1===L.indexOf("morphTargetTextureIndices")&&L.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),I>0&&(L=L.slice(),L.push("morphTargetInfluences"),L.push("morphTargetCount"),L.push("morphTargetTextureInfo"),L.push("morphTargetTextureIndices"))}else H.push("#define NUM_MORPH_INFLUENCERS 0");if(E){const t=E.bakedVertexAnimationManager;t&&t.isEnabled&&(H.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===L.indexOf("bakedVertexAnimationSettings")&&L.push("bakedVertexAnimationSettings"),-1===L.indexOf("bakedVertexAnimationTextureSizeInverted")&&L.push("bakedVertexAnimationTextureSizeInverted"),-1===L.indexOf("bakedVertexAnimationTime")&&L.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,O.A)(h,E,H)}for(const X in this._textures)if(!this._textures[X].isReady())return!1;E&&this.needAlphaTestingForMesh(E)&&H.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,y.d)(L),(0,y.k)(this,p,H)),p.fogEnabled&&null!==E&&void 0!==E&&E.applyFog&&p.fogMode!==X.c.FOGMODE_NONE&&(H.push("#define FOG"),-1===L.indexOf("view")&&L.push("view"),-1===L.indexOf("vFogInfos")&&L.push("vFogInfos"),-1===L.indexOf("vFogColor")&&L.push("vFogColor")),this._useLogarithmicDepth&&(H.push("#define LOGARITHMICDEPTH"),-1===L.indexOf("logarithmicDepthConstant")&&L.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(L=L.slice(),mE=mE.slice(),W=W.slice(),a=this.customShaderNameResolve(this.name,L,mE,W,H,h));const D=R?z._getDrawWrapper(void 0,!0):this._drawWrapper,S=(null===D||void 0===D?void 0:D.effect)??null,l=(null===D||void 0===D?void 0:D.defines)??null,f=H.join("\n");let K=S;return l!==f&&(K=C.createEffect(a,{attributes:h,uniformsNames:L,uniformBuffersNames:mE,samplers:W,defines:f,fallbacks:d,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:I},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},C),R?z.setEffect(K,f,this._materialContext):D&&D.setEffect(K,f),this._onEffectCreatedObservable&&(c.effect=K,c.subMesh=z??(null===E||void 0===E?void 0:E.Rp[0])??null,this._onEffectCreatedObservable.notifyObservers(c))),D._wasPreviouslyUsingInstances=!!t,!(null===(A=K)||void 0===A||!A.isReady())&&(S!==K&&p.resetCachedMaterial(),D._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(E,t){const z=t??this.getEffect();if(!z)return;const A=this._options.uniforms;-1!==A.indexOf("world")&&z.setMatrix("world",E);const X=this.lE();-1!==A.indexOf("worldView")&&(E.multiplyToRef(X.getViewMatrix(),this._cachedWorldViewMatrix),z.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==A.indexOf("worldViewProjection")&&(E.multiplyToRef(X.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),z.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==A.indexOf("view")&&z.setMatrix("view",X.getViewMatrix())}bindForSubMesh(E,t,z){var A;this.bind(E,t,null===(A=z._drawWrapperOverride)||void 0===A?void 0:A.effect,z)}bind(E,t,z,A){const X=A&&this._storeEffectOnSubMeshes,R=z??(X?A.effect:this.getEffect());if(!R)return;const u=this.lE();this._activeEffect=R,this.bindOnlyWorldMatrix(E,z);const p=this._options.uniformBuffers;let C=!1;if(R&&p&&p.length>0&&u.getEngine().supportsUniformBuffers)for(let h=0;h<p.length;++h){switch(p[h]){case"Mesh":t&&(t.getMeshUniformBuffer().bindToEffect(R,"Mesh"),t.transferToEffect(E));break;case"Scene":(0,O.u)(R,u.getSceneUniformBuffer()),u.finalizeSceneUbo(),C=!0}}const Z=t&&X?this._mustRebind(u,R,A,t.visibility):u.getCachedMaterial()!==this;if(R&&Z){let E;for(E in C||-1===this._options.uniforms.indexOf("view")||R.setMatrix("view",u.getViewMatrix()),C||-1===this._options.uniforms.indexOf("projection")||R.setMatrix("projection",u.getProjectionMatrix()),C||-1===this._options.uniforms.indexOf("viewProjection")||(R.setMatrix("viewProjection",u.getTransformMatrix()),this._multiview&&R.setMatrix("viewProjectionR",u._transformMatrixR)),u.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&R.setVector3("cameraPosition",u.activeCamera.globalPosition),(0,O.e)(t,R),(0,y.g)(R,this,u),this._useLogarithmicDepth&&(0,O.o)(X?A.materialDefines:R.defines,R,u),t&&(0,O.i)(u,t,R),this._textures)R.setTexture(E,this._textures[E]);for(E in this._textureArrays)R.setTextureArray(E,this._textureArrays[E]);for(E in this._ints)R.setInt(E,this._ints[E]);for(E in this._uints)R.setUInt(E,this._uints[E]);for(E in this._floats)R.setFloat(E,this._floats[E]);for(E in this._floatsArrays)R.setArray(E,this._floatsArrays[E]);for(E in this._colors3)R.setColor3(E,this._colors3[E]);for(E in this._colors3Arrays)R.setArray3(E,this._colors3Arrays[E]);for(E in this._colors4){const t=this._colors4[E];R.setFloat4(E,t.r,t.g,t.b,t.a)}for(E in this._colors4Arrays)R.setArray4(E,this._colors4Arrays[E]);for(E in this._vectors2)R.setVector2(E,this._vectors2[E]);for(E in this._vectors3)R.setVector3(E,this._vectors3[E]);for(E in this._vectors4)R.setVector4(E,this._vectors4[E]);for(E in this._quaternions)R.setQuaternion(E,this._quaternions[E]);for(E in this._matrices)R.setMatrix(E,this._matrices[E]);for(E in this._matrixArrays)R.setMatrices(E,this._matrixArrays[E]);for(E in this._matrices3x3)R.setMatrix3x3(E,this._matrices3x3[E]);for(E in this._matrices2x2)R.setMatrix2x2(E,this._matrices2x2[E]);for(E in this._vectors2Arrays)R.setArray2(E,this._vectors2Arrays[E]);for(E in this._vectors3Arrays)R.setArray3(E,this._vectors3Arrays[E]);for(E in this._vectors4Arrays)R.setArray4(E,this._vectors4Arrays[E]);for(E in this._quaternionsArrays)R.setArray4(E,this._quaternionsArrays[E]);for(E in this._uniformBuffers){const t=this._uniformBuffers[E].getBuffer();t&&R.bindUniformBuffer(t,E)}const z=u.getEngine(),p=z.setExternalTexture;if(p)for(E in this._externalTextures)p.call(z,E,this._externalTextures[E]);const Z=z.setTextureSampler;if(Z)for(E in this._textureSamplers)Z.call(z,E,this._textureSamplers[E]);const H=z.setStorageBuffer;if(H)for(E in this._storageBuffers)H.call(z,E,this._storageBuffers[E])}if(R&&t&&(Z||!this.isFrozen)){(0,O.r)(t,R),t.morphTargetManager&&t.morphTargetManager.isUsingTextureForTargets&&t.morphTargetManager._bind(R);const E=t.bakedVertexAnimationManager;if(E&&E.isEnabled){var H;const E=X?A._drawWrapper:this._drawWrapper;null===(H=t.bakedVertexAnimationManager)||void 0===H||H.bind(R,!!E._wasPreviouslyUsingInstances)}}this._afterBind(t,R,A)}getActiveTextures(){const E=super.getActiveTextures();for(const t in this._textures)E.push(this._textures[t]);for(const t in this._textureArrays){const z=this._textureArrays[t];for(let t=0;t<z.length;t++)E.push(z[t])}return E}hasTexture(E){if(super.hasTexture(E))return!0;for(const t in this._textures)if(this._textures[t]===E)return!0;for(const t in this._textureArrays){const z=this._textureArrays[t];for(let t=0;t<z.length;t++)if(z[t]===E)return!0}return!1}clone(E){const t=A.b.Clone((()=>new a(E,this.lE(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);t.name=E,t.id=E,"object"===typeof t._shaderPath&&(t._shaderPath={...t._shaderPath}),this._options={...this._options};const z=Object.keys(this._options);for(const A of z){const E=this._options[A];Array.isArray(E)&&(this._options[A]=E.slice(0))}this.stencil.copyTo(t.stencil);for(const A in this._textures)t.setTexture(A,this._textures[A]);for(const A in this._textureArrays)t.setTextureArray(A,this._textureArrays[A]);for(const A in this._externalTextures)t.setExternalTexture(A,this._externalTextures[A]);for(const A in this._ints)t.setInt(A,this._ints[A]);for(const A in this._uints)t.setUInt(A,this._uints[A]);for(const A in this._floats)t.setFloat(A,this._floats[A]);for(const A in this._floatsArrays)t.setFloats(A,this._floatsArrays[A]);for(const A in this._colors3)t.setColor3(A,this._colors3[A]);for(const A in this._colors3Arrays)t._colors3Arrays[A]=this._colors3Arrays[A];for(const A in this._colors4)t.setColor4(A,this._colors4[A]);for(const A in this._colors4Arrays)t._colors4Arrays[A]=this._colors4Arrays[A];for(const A in this._vectors2)t.setVector2(A,this._vectors2[A]);for(const A in this._vectors3)t.setVector3(A,this._vectors3[A]);for(const A in this._vectors4)t.setVector4(A,this._vectors4[A]);for(const A in this._quaternions)t.setQuaternion(A,this._quaternions[A]);for(const A in this._quaternionsArrays)t._quaternionsArrays[A]=this._quaternionsArrays[A];for(const A in this._matrices)t.setMatrix(A,this._matrices[A]);for(const A in this._matrixArrays)t._matrixArrays[A]=this._matrixArrays[A].slice();for(const A in this._matrices3x3)t.setMatrix3x3(A,this._matrices3x3[A]);for(const A in this._matrices2x2)t.setMatrix2x2(A,this._matrices2x2[A]);for(const A in this._vectors2Arrays)t.setArray2(A,this._vectors2Arrays[A]);for(const A in this._vectors3Arrays)t.setArray3(A,this._vectors3Arrays[A]);for(const A in this._vectors4Arrays)t.setArray4(A,this._vectors4Arrays[A]);for(const A in this._uniformBuffers)t.setUniformBuffer(A,this._uniformBuffers[A]);for(const A in this._textureSamplers)t.setTextureSampler(A,this._textureSamplers[A]);for(const A in this._storageBuffers)t.setStorageBuffer(A,this._storageBuffers[A]);return t}dispose(E,t,z){if(t){let E;for(E in this._textures)this._textures[E].dispose();for(E in this._textureArrays){const t=this._textureArrays[E];for(let E=0;E<t.length;E++)t[E].dispose()}}this._textures={},super.dispose(E,t,z)}serialize(){const E=A.b.Serialize(this);let t;for(t in E.customType="BABYLON.ShaderMaterial",E.uniqueId=this.uniqueId,E.options=this._options,E.shaderPath=this._shaderPath,E.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,E.stencil=this.stencil.serialize(),E.textures={},this._textures)E.textures[t]=this._textures[t].serialize();for(t in E.textureArrays={},this._textureArrays){E.textureArrays[t]=[];const z=this._textureArrays[t];for(let A=0;A<z.length;A++)E.textureArrays[t].push(z[A].serialize())}for(t in E.ints={},this._ints)E.ints[t]=this._ints[t];for(t in E.uints={},this._uints)E.uints[t]=this._uints[t];for(t in E.floats={},this._floats)E.floats[t]=this._floats[t];for(t in E.floatsArrays={},this._floatsArrays)E.floatsArrays[t]=this._floatsArrays[t];for(t in E.colors3={},this._colors3){const z=this._colors3[t];E.colors3[t]=[z.r,z.g,z.b]}for(t in E.colors3Arrays={},this._colors3Arrays)E.colors3Arrays[t]=this._colors3Arrays[t];for(t in E.colors4={},this._colors4){const z=this._colors4[t];E.colors4[t]=[z.r,z.g,z.b,z.a]}for(t in E.colors4Arrays={},this._colors4Arrays)E.colors4Arrays[t]=this._colors4Arrays[t];for(t in E.vectors2={},this._vectors2){const z=this._vectors2[t];E.vectors2[t]=[z.x,z.y]}for(t in E.vectors3={},this._vectors3){const z=this._vectors3[t];E.vectors3[t]=[z.x,z.y,z.z]}for(t in E.vectors4={},this._vectors4){const z=this._vectors4[t];E.vectors4[t]=[z.x,z.y,z.z,z.w]}for(t in E.quaternions={},this._quaternions)E.quaternions[t]=this._quaternions[t].upE();for(t in E.matrices={},this._matrices)E.matrices[t]=this._matrices[t].upE();for(t in E.matrixArray={},this._matrixArrays)E.matrixArray[t]=this._matrixArrays[t];for(t in E.matrices3x3={},this._matrices3x3)E.matrices3x3[t]=this._matrices3x3[t];for(t in E.matrices2x2={},this._matrices2x2)E.matrices2x2[t]=this._matrices2x2[t];for(t in E.vectors2Arrays={},this._vectors2Arrays)E.vectors2Arrays[t]=this._vectors2Arrays[t];for(t in E.vectors3Arrays={},this._vectors3Arrays)E.vectors3Arrays[t]=this._vectors3Arrays[t];for(t in E.vectors4Arrays={},this._vectors4Arrays)E.vectors4Arrays[t]=this._vectors4Arrays[t];for(t in E.quaternionsArrays={},this._quaternionsArrays)E.quaternionsArrays[t]=this._quaternionsArrays[t];return E}static Parse(E,t,z){const X=A.b.Parse((()=>new a(E.name,t,E.shaderPath,E.options,E.storeEffectOnSubMeshes)),E,t,z);let u;for(u in E.stencil&&X.stencil.parse(E.stencil,t,z),E.textures)X.setTexture(u,p.d.Parse(E.textures[u],t,z));for(u in E.textureArrays){const A=E.textureArrays[u],R=[];for(let E=0;E<A.length;E++)R.push(p.d.Parse(A[E],t,z));X.setTextureArray(u,R)}for(u in E.ints)X.setInt(u,E.ints[u]);for(u in E.uints)X.setUInt(u,E.uints[u]);for(u in E.floats)X.setFloat(u,E.floats[u]);for(u in E.floatsArrays)X.setFloats(u,E.floatsArrays[u]);for(u in E.colors3){const t=E.colors3[u];X.setColor3(u,{r:t[0],g:t[1],b:t[2]})}for(u in E.colors3Arrays){const t=E.colors3Arrays[u].reduce(((E,t,z)=>(z%3===0?E.push([t]):E[E.length-1].push(t),E)),[]).map((E=>({r:E[0],g:E[1],b:E[2]})));X.setColor3Array(u,t)}for(u in E.colors4){const t=E.colors4[u];X.setColor4(u,{r:t[0],g:t[1],b:t[2],a:t[3]})}for(u in E.colors4Arrays){const t=E.colors4Arrays[u].reduce(((E,t,z)=>(z%4===0?E.push([t]):E[E.length-1].push(t),E)),[]).map((E=>({r:E[0],g:E[1],b:E[2],a:E[3]})));X.setColor4Array(u,t)}for(u in E.vectors2){const t=E.vectors2[u];X.setVector2(u,{x:t[0],y:t[1]})}for(u in E.vectors3){const t=E.vectors3[u];X.setVector3(u,{x:t[0],y:t[1],z:t[2]})}for(u in E.vectors4){const t=E.vectors4[u];X.setVector4(u,{x:t[0],y:t[1],z:t[2],w:t[3]})}for(u in E.quaternions)X.setQuaternion(u,R.Quaternion.St(E.quaternions[u]));for(u in E.matrices)X.setMatrix(u,R.Matrix.St(E.matrices[u]));for(u in E.matrixArray)X._matrixArrays[u]=new Float32Array(E.matrixArray[u]);for(u in E.matrices3x3)X.setMatrix3x3(u,E.matrices3x3[u]);for(u in E.matrices2x2)X.setMatrix2x2(u,E.matrices2x2[u]);for(u in E.vectors2Arrays)X.setArray2(u,E.vectors2Arrays[u]);for(u in E.vectors3Arrays)X.setArray3(u,E.vectors3Arrays[u]);for(u in E.vectors4Arrays)X.setArray4(u,E.vectors4Arrays[u]);for(u in E.quaternionsArrays)X.setArray4(u,E.quaternionsArrays[u]);return X}static async ParseFromFileAsync(E,t,z){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((X,R)=>{const u=new H.d;u.addEventListener("readystatechange",(()=>{if(4==u.readyState)if(200==u.status){const t=JSON.parse(u.responseText),R=this.Parse(t,z||d.d.LastCreatedScene,A);E&&(R.name=E),X(R)}else R("Unable to load the ShaderMaterial")})),u.open("GET",t),u.send()}))}static async ParseFromSnippetAsync(E,t){let z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((A,X)=>{const R=new H.d;R.addEventListener("readystatechange",(()=>{if(4==R.readyState)if(200==R.status){const X=JSON.parse(JSON.parse(R.responseText).jsonPayload),u=JSON.parse(X.shaderMaterial),p=this.Parse(u,t||d.d.LastCreatedScene,z);p.snippetId=E,A(p)}else X("Unable to load the snippet "+E)})),R.open("GET",this.SnippetUrl+"/"+E.replace(/#/g,"/")),R.send()}))}}a.SnippetUrl="https://snippet.babylonjs.com",a.CreateFromSnippetAsync=a.ParseFromSnippetAsync,(0,C.f)("BABYLON.ShaderMaterial",a)}}]);