"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[22],{11427:(P,f,Y)=>{Y.r(f),Y.d(f,{ShaderMaterial:()=>S});var C=Y(11216),q=Y(11429),m=Y(11179),L=Y(11255),o=Y(11160),w=Y(11134),d=Y(11511),R=Y(11046),y=Y(11520),r=Y(11052),i=Y(11561),u=Y(11555);const g={effect:null,subMesh:null};class S extends y.b{constructor(P,f,Y){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(P,f,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new m.Matrix,this._cachedWorldViewProjectionMatrix=new m.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=Y,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...C}}get shaderPath(){return this._shaderPath}set shaderPath(P){this._shaderPath=P}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(P){-1===this._options.uniforms.indexOf(P)&&this._options.uniforms.push(P)}setTexture(P,f){return-1===this._options.samplers.indexOf(P)&&this._options.samplers.push(P),this._textures[P]=f,this}removeTexture(P){delete this._textures[P]}setTextureArray(P,f){return-1===this._options.samplers.indexOf(P)&&this._options.samplers.push(P),this._checkUniform(P),this._textureArrays[P]=f,this}setExternalTexture(P,f){return-1===this._options.externalTextures.indexOf(P)&&this._options.externalTextures.push(P),this._externalTextures[P]=f,this}setFloat(P,f){return this._checkUniform(P),this._floats[P]=f,this}setInt(P,f){return this._checkUniform(P),this._ints[P]=f,this}setUInt(P,f){return this._checkUniform(P),this._uints[P]=f,this}setFloats(P,f){return this._checkUniform(P),this._floatsArrays[P]=f,this}setColor3(P,f){return this._checkUniform(P),this._colors3[P]=f,this}setColor3Array(P,f){return this._checkUniform(P),this._colors3Arrays[P]=f.reduce(((P,f)=>(P.push(f.r,f.g,f.b),P)),[]),this}setColor4(P,f){return this._checkUniform(P),this._colors4[P]=f,this}setColor4Array(P,f){return this._checkUniform(P),this._colors4Arrays[P]=f.reduce(((P,f)=>(P.push(f.r,f.g,f.b,f.a),P)),[]),this}setVector2(P,f){return this._checkUniform(P),this._vectors2[P]=f,this}setVector3(P,f){return this._checkUniform(P),this._vectors3[P]=f,this}setVector4(P,f){return this._checkUniform(P),this._vectors4[P]=f,this}setQuaternion(P,f){return this._checkUniform(P),this._quaternions[P]=f,this}setQuaternionArray(P,f){return this._checkUniform(P),this._quaternionsArrays[P]=f.reduce(((P,f)=>(f.toArray(P,P.length),P)),[]),this}setMatrix(P,f){return this._checkUniform(P),this._matrices[P]=f,this}setMatrices(P,f){this._checkUniform(P);const Y=new Float32Array(16*f.length);for(let C=0;C<f.length;C++){f[C].copyToArray(Y,16*C)}return this._matrixArrays[P]=Y,this}setMatrix3x3(P,f){return this._checkUniform(P),this._matrices3x3[P]=f,this}setMatrix2x2(P,f){return this._checkUniform(P),this._matrices2x2[P]=f,this}setArray2(P,f){return this._checkUniform(P),this._vectors2Arrays[P]=f,this}setArray3(P,f){return this._checkUniform(P),this._vectors3Arrays[P]=f,this}setArray4(P,f){return this._checkUniform(P),this._vectors4Arrays[P]=f,this}setUniformBuffer(P,f){return-1===this._options.uniformBuffers.indexOf(P)&&this._options.uniformBuffers.push(P),this._uniformBuffers[P]=f,this}setTextureSampler(P,f){return-1===this._options.samplerObjects.indexOf(P)&&this._options.samplerObjects.push(P),this._textureSamplers[P]=f,this}setStorageBuffer(P,f){return-1===this._options.storageBuffers.indexOf(P)&&this._options.storageBuffers.push(P),this._storageBuffers[P]=f,this}setDefine(P,f){const Y=P.trimEnd()+" ",C=this.options.defines.findIndex((f=>f===P||f.startsWith(Y)));return C>=0&&this.options.defines.splice(C,1),("boolean"!==typeof f||f)&&this.options.defines.push(Y+f),this}isReadyForSubMesh(P,f,Y){return this.isReady(P,Y,f)}isReady(P,f,Y){var C;const m=Y&&this._storeEffectOnSubMeshes;if(this.isFrozen){const P=m?Y._drawWrapper:this._drawWrapper;if(P.effect&&P._wasPreviouslyReady&&P._wasPreviouslyUsingInstances===f)return!0}const o=this.vP(),w=o.getEngine(),R=[],y=[];let r=null,S=this._shaderPath,K=this._options.uniforms,M=this._options.uniformBuffers,V=this._options.samplers;w.getCaps().multiview&&o.activeCamera&&o.activeCamera.outputRenderTarget&&o.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,R.push("#define MULTIVIEW"),-1!==K.indexOf("viewProjection")&&-1===K.indexOf("viewProjectionR")&&K.push("viewProjectionR"));for(let q=0;q<this._options.defines.length;q++){const P=0===this._options.defines[q].indexOf("#define")?this._options.defines[q]:`#define ${this._options.defines[q]}`;R.push(P)}for(let q=0;q<this._options.attributes.length;q++)y.push(this._options.attributes[q]);if(P&&P.isVerticesDataPresent(L.d.ColorKind)&&(-1===y.indexOf(L.d.ColorKind)&&y.push(L.d.ColorKind),R.push("#define VERTEXCOLOR")),f&&(R.push("#define INSTANCES"),(0,u.fb)(y,this._materialHelperNeedsPreviousMatrices),null!==P&&void 0!==P&&P.hasThinInstances&&(R.push("#define THIN_INSTANCES"),P&&P.isVerticesDataPresent(L.d.ColorInstanceKind)&&(y.push(L.d.ColorInstanceKind),R.push("#define INSTANCESCOLOR")))),P&&P.useBones&&P.computeBonesUsingShaders&&P.skeleton){y.push(L.d.MatricesIndicesKind),y.push(L.d.MatricesWeightsKind),P.numBoneInfluencers>4&&(y.push(L.d.MatricesIndicesExtraKind),y.push(L.d.MatricesWeightsExtraKind));const f=P.skeleton;R.push("#define NUM_BONE_INFLUENCERS "+P.numBoneInfluencers),r=new d.d,r.addCPUSkinningFallback(0,P),f.isUsingTextureForMatrices?(R.push("#define BONETEXTURE"),-1===K.indexOf("boneTextureWidth")&&K.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(R.push("#define BonesPerMesh "+(f.bones.length+1)),-1===K.indexOf("mBones")&&K.push("mBones"))}else R.push("#define NUM_BONE_INFLUENCERS 0");let O=0;const n=P?P.morphTargetManager:null;if(n){const f=-1!==R.indexOf("#define UV1"),Y=-1!==R.indexOf("#define UV2"),C=-1!==R.indexOf("#define TANGENT"),q=-1!==R.indexOf("#define NORMAL"),m=-1!==R.indexOf("#define VERTEXCOLOR");O=(0,u.F)(n,R,y,P,!0,q,C,f,Y,m),n.isUsingTextureForTargets&&(-1===K.indexOf("morphTargetTextureIndices")&&K.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),O>0&&(K=K.slice(),K.push("morphTargetInfluences"),K.push("morphTargetCount"),K.push("morphTargetTextureInfo"),K.push("morphTargetTextureIndices"))}else R.push("#define NUM_MORPH_INFLUENCERS 0");if(P){const f=P.bakedVertexAnimationManager;f&&f.isEnabled&&(R.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===K.indexOf("bakedVertexAnimationSettings")&&K.push("bakedVertexAnimationSettings"),-1===K.indexOf("bakedVertexAnimationTextureSizeInverted")&&K.push("bakedVertexAnimationTextureSizeInverted"),-1===K.indexOf("bakedVertexAnimationTime")&&K.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,u.y)(y,P,R)}for(const q in this._textures)if(!this._textures[q].isReady())return!1;P&&this.needAlphaTestingForMesh(P)&&R.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,i.d)(K),(0,i.l)(this,o,R)),o.fogEnabled&&null!==P&&void 0!==P&&P.applyFog&&o.fogMode!==q.e.FOGMODE_NONE&&(R.push("#define FOG"),-1===K.indexOf("view")&&K.push("view"),-1===K.indexOf("vFogInfos")&&K.push("vFogInfos"),-1===K.indexOf("vFogColor")&&K.push("vFogColor")),this._useLogarithmicDepth&&(R.push("#define LOGARITHMICDEPTH"),-1===K.indexOf("logarithmicDepthConstant")&&K.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(K=K.slice(),M=M.slice(),V=V.slice(),S=this.customShaderNameResolve(this.name,K,M,V,R,y));const l=m?Y._getDrawWrapper(void 0,!0):this._drawWrapper,v=(null===l||void 0===l?void 0:l.effect)??null,c=(null===l||void 0===l?void 0:l.defines)??null,T=R.join("\n");let U=v;return c!==T&&(U=w.createEffect(S,{attributes:y,uniformsNames:K,uniformBuffersNames:M,samplers:V,defines:T,fallbacks:r,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:O},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},w),m?Y.setEffect(U,T,this._materialContext):l&&l.setEffect(U,T),this._onEffectCreatedObservable&&(g.effect=U,g.subMesh=Y??(null===P||void 0===P?void 0:P.Jf[0])??null,this._onEffectCreatedObservable.notifyObservers(g))),l._wasPreviouslyUsingInstances=!!f,!(null===(C=U)||void 0===C||!C.isReady())&&(v!==U&&o.resetCachedMaterial(),l._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(P,f){const Y=f??this.getEffect();if(!Y)return;const C=this._options.uniforms;-1!==C.indexOf("world")&&Y.setMatrix("world",P);const q=this.vP();-1!==C.indexOf("worldView")&&(P.multiplyToRef(q.getViewMatrix(),this._cachedWorldViewMatrix),Y.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==C.indexOf("worldViewProjection")&&(P.multiplyToRef(q.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),Y.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==C.indexOf("view")&&Y.setMatrix("view",q.getViewMatrix())}bindForSubMesh(P,f,Y){var C;this.bind(P,f,null===(C=Y._drawWrapperOverride)||void 0===C?void 0:C.effect,Y)}bind(P,f,Y,C){const q=C&&this._storeEffectOnSubMeshes,m=Y??(q?C.effect:this.getEffect());if(!m)return;const L=this.vP();this._activeEffect=m,this.bindOnlyWorldMatrix(P,Y);const o=this._options.uniformBuffers;let w=!1;if(m&&o&&o.length>0&&L.getEngine().supportsUniformBuffers)for(let y=0;y<o.length;++y){switch(o[y]){case"Mesh":f&&(f.getMeshUniformBuffer().bindToEffect(m,"Mesh"),f.transferToEffect(P));break;case"Scene":(0,u.o)(m,L.getSceneUniformBuffer()),L.finalizeSceneUbo(),w=!0}}const d=f&&q?this._mustRebind(L,m,C,f.visibility):L.getCachedMaterial()!==this;if(m&&d){let P;for(P in w||-1===this._options.uniforms.indexOf("view")||m.setMatrix("view",L.getViewMatrix()),w||-1===this._options.uniforms.indexOf("projection")||m.setMatrix("projection",L.getProjectionMatrix()),w||-1===this._options.uniforms.indexOf("viewProjection")||(m.setMatrix("viewProjection",L.getTransformMatrix()),this._multiview&&m.setMatrix("viewProjectionR",L._transformMatrixR)),L.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&m.setVector3("cameraPosition",L.activeCamera.globalPosition),(0,u.c)(f,m),(0,i.f)(m,this,L),this._useLogarithmicDepth&&(0,u.i)(q?C.materialDefines:m.defines,m,L),f&&(0,u.d)(L,f,m),this._textures)m.setTexture(P,this._textures[P]);for(P in this._textureArrays)m.setTextureArray(P,this._textureArrays[P]);for(P in this._ints)m.setInt(P,this._ints[P]);for(P in this._uints)m.setUInt(P,this._uints[P]);for(P in this._floats)m.setFloat(P,this._floats[P]);for(P in this._floatsArrays)m.setArray(P,this._floatsArrays[P]);for(P in this._colors3)m.setColor3(P,this._colors3[P]);for(P in this._colors3Arrays)m.setArray3(P,this._colors3Arrays[P]);for(P in this._colors4){const f=this._colors4[P];m.setFloat4(P,f.r,f.g,f.b,f.a)}for(P in this._colors4Arrays)m.setArray4(P,this._colors4Arrays[P]);for(P in this._vectors2)m.setVector2(P,this._vectors2[P]);for(P in this._vectors3)m.setVector3(P,this._vectors3[P]);for(P in this._vectors4)m.setVector4(P,this._vectors4[P]);for(P in this._quaternions)m.setQuaternion(P,this._quaternions[P]);for(P in this._matrices)m.setMatrix(P,this._matrices[P]);for(P in this._matrixArrays)m.setMatrices(P,this._matrixArrays[P]);for(P in this._matrices3x3)m.setMatrix3x3(P,this._matrices3x3[P]);for(P in this._matrices2x2)m.setMatrix2x2(P,this._matrices2x2[P]);for(P in this._vectors2Arrays)m.setArray2(P,this._vectors2Arrays[P]);for(P in this._vectors3Arrays)m.setArray3(P,this._vectors3Arrays[P]);for(P in this._vectors4Arrays)m.setArray4(P,this._vectors4Arrays[P]);for(P in this._quaternionsArrays)m.setArray4(P,this._quaternionsArrays[P]);for(P in this._uniformBuffers){const f=this._uniformBuffers[P].getBuffer();f&&m.bindUniformBuffer(f,P)}const Y=L.getEngine(),o=Y.setExternalTexture;if(o)for(P in this._externalTextures)o.call(Y,P,this._externalTextures[P]);const d=Y.setTextureSampler;if(d)for(P in this._textureSamplers)d.call(Y,P,this._textureSamplers[P]);const R=Y.setStorageBuffer;if(R)for(P in this._storageBuffers)R.call(Y,P,this._storageBuffers[P])}if(m&&f&&(d||!this.isFrozen)){(0,u.k)(f,m),f.morphTargetManager&&f.morphTargetManager.isUsingTextureForTargets&&f.morphTargetManager._bind(m);const P=f.bakedVertexAnimationManager;if(P&&P.isEnabled){var R;const P=q?C._drawWrapper:this._drawWrapper;null===(R=f.bakedVertexAnimationManager)||void 0===R||R.bind(m,!!P._wasPreviouslyUsingInstances)}}this._afterBind(f,m,C)}getActiveTextures(){const P=super.getActiveTextures();for(const f in this._textures)P.push(this._textures[f]);for(const f in this._textureArrays){const Y=this._textureArrays[f];for(let f=0;f<Y.length;f++)P.push(Y[f])}return P}hasTexture(P){if(super.hasTexture(P))return!0;for(const f in this._textures)if(this._textures[f]===P)return!0;for(const f in this._textureArrays){const Y=this._textureArrays[f];for(let f=0;f<Y.length;f++)if(Y[f]===P)return!0}return!1}clone(P){const f=C.e.Clone((()=>new S(P,this.vP(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);f.name=P,f.id=P,"object"===typeof f._shaderPath&&(f._shaderPath={...f._shaderPath}),this._options={...this._options};const Y=Object.keys(this._options);for(const C of Y){const P=this._options[C];Array.isArray(P)&&(this._options[C]=P.slice(0))}this.stencil.copyTo(f.stencil);for(const C in this._textures)f.setTexture(C,this._textures[C]);for(const C in this._textureArrays)f.setTextureArray(C,this._textureArrays[C]);for(const C in this._externalTextures)f.setExternalTexture(C,this._externalTextures[C]);for(const C in this._ints)f.setInt(C,this._ints[C]);for(const C in this._uints)f.setUInt(C,this._uints[C]);for(const C in this._floats)f.setFloat(C,this._floats[C]);for(const C in this._floatsArrays)f.setFloats(C,this._floatsArrays[C]);for(const C in this._colors3)f.setColor3(C,this._colors3[C]);for(const C in this._colors3Arrays)f._colors3Arrays[C]=this._colors3Arrays[C];for(const C in this._colors4)f.setColor4(C,this._colors4[C]);for(const C in this._colors4Arrays)f._colors4Arrays[C]=this._colors4Arrays[C];for(const C in this._vectors2)f.setVector2(C,this._vectors2[C]);for(const C in this._vectors3)f.setVector3(C,this._vectors3[C]);for(const C in this._vectors4)f.setVector4(C,this._vectors4[C]);for(const C in this._quaternions)f.setQuaternion(C,this._quaternions[C]);for(const C in this._quaternionsArrays)f._quaternionsArrays[C]=this._quaternionsArrays[C];for(const C in this._matrices)f.setMatrix(C,this._matrices[C]);for(const C in this._matrixArrays)f._matrixArrays[C]=this._matrixArrays[C].slice();for(const C in this._matrices3x3)f.setMatrix3x3(C,this._matrices3x3[C]);for(const C in this._matrices2x2)f.setMatrix2x2(C,this._matrices2x2[C]);for(const C in this._vectors2Arrays)f.setArray2(C,this._vectors2Arrays[C]);for(const C in this._vectors3Arrays)f.setArray3(C,this._vectors3Arrays[C]);for(const C in this._vectors4Arrays)f.setArray4(C,this._vectors4Arrays[C]);for(const C in this._uniformBuffers)f.setUniformBuffer(C,this._uniformBuffers[C]);for(const C in this._textureSamplers)f.setTextureSampler(C,this._textureSamplers[C]);for(const C in this._storageBuffers)f.setStorageBuffer(C,this._storageBuffers[C]);return f}dispose(P,f,Y){if(f){let P;for(P in this._textures)this._textures[P].dispose();for(P in this._textureArrays){const f=this._textureArrays[P];for(let P=0;P<f.length;P++)f[P].dispose()}}this._textures={},super.dispose(P,f,Y)}serialize(){const P=C.e.Serialize(this);let f;for(f in P.customType="BABYLON.ShaderMaterial",P.uniqueId=this.uniqueId,P.options=this._options,P.shaderPath=this._shaderPath,P.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,P.stencil=this.stencil.serialize(),P.textures={},this._textures)P.textures[f]=this._textures[f].serialize();for(f in P.textureArrays={},this._textureArrays){P.textureArrays[f]=[];const Y=this._textureArrays[f];for(let C=0;C<Y.length;C++)P.textureArrays[f].push(Y[C].serialize())}for(f in P.ints={},this._ints)P.ints[f]=this._ints[f];for(f in P.uints={},this._uints)P.uints[f]=this._uints[f];for(f in P.floats={},this._floats)P.floats[f]=this._floats[f];for(f in P.floatsArrays={},this._floatsArrays)P.floatsArrays[f]=this._floatsArrays[f];for(f in P.colors3={},this._colors3){const Y=this._colors3[f];P.colors3[f]=[Y.r,Y.g,Y.b]}for(f in P.colors3Arrays={},this._colors3Arrays)P.colors3Arrays[f]=this._colors3Arrays[f];for(f in P.colors4={},this._colors4){const Y=this._colors4[f];P.colors4[f]=[Y.r,Y.g,Y.b,Y.a]}for(f in P.colors4Arrays={},this._colors4Arrays)P.colors4Arrays[f]=this._colors4Arrays[f];for(f in P.vectors2={},this._vectors2){const Y=this._vectors2[f];P.vectors2[f]=[Y.x,Y.y]}for(f in P.vectors3={},this._vectors3){const Y=this._vectors3[f];P.vectors3[f]=[Y.x,Y.y,Y.z]}for(f in P.vectors4={},this._vectors4){const Y=this._vectors4[f];P.vectors4[f]=[Y.x,Y.y,Y.z,Y.w]}for(f in P.quaternions={},this._quaternions)P.quaternions[f]=this._quaternions[f].If();for(f in P.matrices={},this._matrices)P.matrices[f]=this._matrices[f].If();for(f in P.matrixArray={},this._matrixArrays)P.matrixArray[f]=this._matrixArrays[f];for(f in P.matrices3x3={},this._matrices3x3)P.matrices3x3[f]=this._matrices3x3[f];for(f in P.matrices2x2={},this._matrices2x2)P.matrices2x2[f]=this._matrices2x2[f];for(f in P.vectors2Arrays={},this._vectors2Arrays)P.vectors2Arrays[f]=this._vectors2Arrays[f];for(f in P.vectors3Arrays={},this._vectors3Arrays)P.vectors3Arrays[f]=this._vectors3Arrays[f];for(f in P.vectors4Arrays={},this._vectors4Arrays)P.vectors4Arrays[f]=this._vectors4Arrays[f];for(f in P.quaternionsArrays={},this._quaternionsArrays)P.quaternionsArrays[f]=this._quaternionsArrays[f];return P}static Parse(P,f,Y){const q=C.e.Parse((()=>new S(P.name,f,P.shaderPath,P.options,P.storeEffectOnSubMeshes)),P,f,Y);let L;for(L in P.stencil&&q.stencil.parse(P.stencil,f,Y),P.textures)q.setTexture(L,o.c.Parse(P.textures[L],f,Y));for(L in P.textureArrays){const C=P.textureArrays[L],m=[];for(let P=0;P<C.length;P++)m.push(o.c.Parse(C[P],f,Y));q.setTextureArray(L,m)}for(L in P.ints)q.setInt(L,P.ints[L]);for(L in P.uints)q.setUInt(L,P.uints[L]);for(L in P.floats)q.setFloat(L,P.floats[L]);for(L in P.floatsArrays)q.setFloats(L,P.floatsArrays[L]);for(L in P.colors3){const f=P.colors3[L];q.setColor3(L,{r:f[0],g:f[1],b:f[2]})}for(L in P.colors3Arrays){const f=P.colors3Arrays[L].reduce(((P,f,Y)=>(Y%3===0?P.push([f]):P[P.length-1].push(f),P)),[]).map((P=>({r:P[0],g:P[1],b:P[2]})));q.setColor3Array(L,f)}for(L in P.colors4){const f=P.colors4[L];q.setColor4(L,{r:f[0],g:f[1],b:f[2],a:f[3]})}for(L in P.colors4Arrays){const f=P.colors4Arrays[L].reduce(((P,f,Y)=>(Y%4===0?P.push([f]):P[P.length-1].push(f),P)),[]).map((P=>({r:P[0],g:P[1],b:P[2],a:P[3]})));q.setColor4Array(L,f)}for(L in P.vectors2){const f=P.vectors2[L];q.setVector2(L,{x:f[0],y:f[1]})}for(L in P.vectors3){const f=P.vectors3[L];q.setVector3(L,{x:f[0],y:f[1],z:f[2]})}for(L in P.vectors4){const f=P.vectors4[L];q.setVector4(L,{x:f[0],y:f[1],z:f[2],w:f[3]})}for(L in P.quaternions)q.setQuaternion(L,m.Quaternion.ef(P.quaternions[L]));for(L in P.matrices)q.setMatrix(L,m.Matrix.ef(P.matrices[L]));for(L in P.matrixArray)q._matrixArrays[L]=new Float32Array(P.matrixArray[L]);for(L in P.matrices3x3)q.setMatrix3x3(L,P.matrices3x3[L]);for(L in P.matrices2x2)q.setMatrix2x2(L,P.matrices2x2[L]);for(L in P.vectors2Arrays)q.setArray2(L,P.vectors2Arrays[L]);for(L in P.vectors3Arrays)q.setArray3(L,P.vectors3Arrays[L]);for(L in P.vectors4Arrays)q.setArray4(L,P.vectors4Arrays[L]);for(L in P.quaternionsArrays)q.setArray4(L,P.quaternionsArrays[L]);return q}static async ParseFromFileAsync(P,f,Y){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((q,m)=>{const L=new R.d;L.addEventListener("readystatechange",(()=>{if(4==L.readyState)if(200==L.status){const f=JSON.parse(L.responseText),m=this.Parse(f,Y||r.e.LastCreatedScene,C);P&&(m.name=P),q(m)}else m("Unable to load the ShaderMaterial")})),L.open("GET",f),L.send()}))}static async ParseFromSnippetAsync(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((C,q)=>{const m=new R.d;m.addEventListener("readystatechange",(()=>{if(4==m.readyState)if(200==m.status){const q=JSON.parse(JSON.parse(m.responseText).jsonPayload),L=JSON.parse(q.shaderMaterial),o=this.Parse(L,f||r.e.LastCreatedScene,Y);o.snippetId=P,C(o)}else q("Unable to load the snippet "+P)})),m.open("GET",this.SnippetUrl+"/"+P.replace(/#/g,"/")),m.send()}))}}S.SnippetUrl="https://snippet.babylonjs.com",S.CreateFromSnippetAsync=S.ParseFromSnippetAsync,(0,w.d)("BABYLON.ShaderMaterial",S)}}]);