"use strict";(self["6xhfpmwgjr5"]=self["6xhfpmwgjr5"]||[]).push([[22],{12628:(P,a,R)=>{R.r(a),R.d(a,{ShaderMaterial:()=>y});var S=R(12447),A=R(12636),Z=R(12415),p=R(12489),j=R(12399),U=R(12376),Q=R(12712),h=R(12268),l=R(12720),V=R(12277),f=R(12760),O=R(12757);const q={effect:null,subMesh:null};class y extends l.e{constructor(P,a,R){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(P,a,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new Z.Matrix,this._cachedWorldViewProjectionMatrix=new Z.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=R,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...S}}get shaderPath(){return this._shaderPath}set shaderPath(P){this._shaderPath=P}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(P){-1===this._options.uniforms.indexOf(P)&&this._options.uniforms.push(P)}setTexture(P,a){return-1===this._options.samplers.indexOf(P)&&this._options.samplers.push(P),this._textures[P]=a,this}removeTexture(P){delete this._textures[P]}setTextureArray(P,a){return-1===this._options.samplers.indexOf(P)&&this._options.samplers.push(P),this._checkUniform(P),this._textureArrays[P]=a,this}setExternalTexture(P,a){return-1===this._options.externalTextures.indexOf(P)&&this._options.externalTextures.push(P),this._externalTextures[P]=a,this}setFloat(P,a){return this._checkUniform(P),this._floats[P]=a,this}setInt(P,a){return this._checkUniform(P),this._ints[P]=a,this}setUInt(P,a){return this._checkUniform(P),this._uints[P]=a,this}setFloats(P,a){return this._checkUniform(P),this._floatsArrays[P]=a,this}setColor3(P,a){return this._checkUniform(P),this._colors3[P]=a,this}setColor3Array(P,a){return this._checkUniform(P),this._colors3Arrays[P]=a.reduce(((P,a)=>(P.push(a.r,a.g,a.b),P)),[]),this}setColor4(P,a){return this._checkUniform(P),this._colors4[P]=a,this}setColor4Array(P,a){return this._checkUniform(P),this._colors4Arrays[P]=a.reduce(((P,a)=>(P.push(a.r,a.g,a.b,a.a),P)),[]),this}setVector2(P,a){return this._checkUniform(P),this._vectors2[P]=a,this}setVector3(P,a){return this._checkUniform(P),this._vectors3[P]=a,this}setVector4(P,a){return this._checkUniform(P),this._vectors4[P]=a,this}setQuaternion(P,a){return this._checkUniform(P),this._quaternions[P]=a,this}setQuaternionArray(P,a){return this._checkUniform(P),this._quaternionsArrays[P]=a.reduce(((P,a)=>(a.toArray(P,P.length),P)),[]),this}setMatrix(P,a){return this._checkUniform(P),this._matrices[P]=a,this}setMatrices(P,a){this._checkUniform(P);const R=new Float32Array(16*a.length);for(let S=0;S<a.length;S++){a[S].copyToArray(R,16*S)}return this._matrixArrays[P]=R,this}setMatrix3x3(P,a){return this._checkUniform(P),this._matrices3x3[P]=a,this}setMatrix2x2(P,a){return this._checkUniform(P),this._matrices2x2[P]=a,this}setArray2(P,a){return this._checkUniform(P),this._vectors2Arrays[P]=a,this}setArray3(P,a){return this._checkUniform(P),this._vectors3Arrays[P]=a,this}setArray4(P,a){return this._checkUniform(P),this._vectors4Arrays[P]=a,this}setUniformBuffer(P,a){return-1===this._options.uniformBuffers.indexOf(P)&&this._options.uniformBuffers.push(P),this._uniformBuffers[P]=a,this}setTextureSampler(P,a){return-1===this._options.samplerObjects.indexOf(P)&&this._options.samplerObjects.push(P),this._textureSamplers[P]=a,this}setStorageBuffer(P,a){return-1===this._options.storageBuffers.indexOf(P)&&this._options.storageBuffers.push(P),this._storageBuffers[P]=a,this}setDefine(P,a){const R=P.trimEnd()+" ",S=this.options.defines.findIndex((a=>a===P||a.startsWith(R)));return S>=0&&this.options.defines.splice(S,1),("boolean"!==typeof a||a)&&this.options.defines.push(R+a),this}isReadyForSubMesh(P,a,R){return this.isReady(P,R,a)}isReady(P,a,R){var S;const Z=R&&this._storeEffectOnSubMeshes;if(this.isFrozen){const P=Z?R._drawWrapper:this._drawWrapper;if(P.effect&&P._wasPreviouslyReady&&P._wasPreviouslyUsingInstances===a)return!0}const j=this.GP(),U=j.getEngine(),h=[],l=[];let V=null,y=this._shaderPath,t=this._options.uniforms,W=this._options.uniformBuffers,k=this._options.samplers;U.getCaps().multiview&&j.activeCamera&&j.activeCamera.outputRenderTarget&&j.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,h.push("#define MULTIVIEW"),-1!==t.indexOf("viewProjection")&&-1===t.indexOf("viewProjectionR")&&t.push("viewProjectionR"));for(let A=0;A<this._options.defines.length;A++){const P=0===this._options.defines[A].indexOf("#define")?this._options.defines[A]:`#define ${this._options.defines[A]}`;h.push(P)}for(let A=0;A<this._options.attributes.length;A++)l.push(this._options.attributes[A]);if(P&&P.isVerticesDataPresent(p.i.ColorKind)&&(-1===l.indexOf(p.i.ColorKind)&&l.push(p.i.ColorKind),h.push("#define VERTEXCOLOR")),a&&(h.push("#define INSTANCES"),(0,O.db)(l,this._materialHelperNeedsPreviousMatrices),null!==P&&void 0!==P&&P.hasThinInstances&&(h.push("#define THIN_INSTANCES"),P&&P.isVerticesDataPresent(p.i.ColorInstanceKind)&&(l.push(p.i.ColorInstanceKind),h.push("#define INSTANCESCOLOR")))),P&&P.useBones&&P.computeBonesUsingShaders&&P.skeleton){l.push(p.i.MatricesIndicesKind),l.push(p.i.MatricesWeightsKind),P.numBoneInfluencers>4&&(l.push(p.i.MatricesIndicesExtraKind),l.push(p.i.MatricesWeightsExtraKind));const a=P.skeleton;h.push("#define NUM_BONE_INFLUENCERS "+P.numBoneInfluencers),V=new Q.d,V.addCPUSkinningFallback(0,P),a.isUsingTextureForMatrices?(h.push("#define BONETEXTURE"),-1===t.indexOf("boneTextureWidth")&&t.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(h.push("#define BonesPerMesh "+(a.bones.length+1)),-1===t.indexOf("mBones")&&t.push("mBones"))}else h.push("#define NUM_BONE_INFLUENCERS 0");let x=0;const s=P?P.morphTargetManager:null;if(s){const a=-1!==h.indexOf("#define UV1"),R=-1!==h.indexOf("#define UV2"),S=-1!==h.indexOf("#define TANGENT"),A=-1!==h.indexOf("#define NORMAL"),Z=-1!==h.indexOf("#define VERTEXCOLOR");x=(0,O.I)(s,h,l,P,!0,A,S,a,R,Z),s.isUsingTextureForTargets&&(-1===t.indexOf("morphTargetTextureIndices")&&t.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),x>0&&(t=t.slice(),t.push("morphTargetInfluences"),t.push("morphTargetCount"),t.push("morphTargetTextureInfo"),t.push("morphTargetTextureIndices"))}else h.push("#define NUM_MORPH_INFLUENCERS 0");if(P){const a=P.bakedVertexAnimationManager;a&&a.isEnabled&&(h.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===t.indexOf("bakedVertexAnimationSettings")&&t.push("bakedVertexAnimationSettings"),-1===t.indexOf("bakedVertexAnimationTextureSizeInverted")&&t.push("bakedVertexAnimationTextureSizeInverted"),-1===t.indexOf("bakedVertexAnimationTime")&&t.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,O.y)(l,P,h)}for(const A in this._textures)if(!this._textures[A].isReady())return!1;P&&this.needAlphaTestingForMesh(P)&&h.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,f.c)(t),(0,f.h)(this,j,h)),j.fogEnabled&&null!==P&&void 0!==P&&P.applyFog&&j.fogMode!==A.b.FOGMODE_NONE&&(h.push("#define FOG"),-1===t.indexOf("view")&&t.push("view"),-1===t.indexOf("vFogInfos")&&t.push("vFogInfos"),-1===t.indexOf("vFogColor")&&t.push("vFogColor")),this._useLogarithmicDepth&&(h.push("#define LOGARITHMICDEPTH"),-1===t.indexOf("logarithmicDepthConstant")&&t.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(t=t.slice(),W=W.slice(),k=k.slice(),y=this.customShaderNameResolve(this.name,t,W,k,h,l));const d=Z?R._getDrawWrapper(void 0,!0):this._drawWrapper,G=(null===d||void 0===d?void 0:d.effect)??null,H=(null===d||void 0===d?void 0:d.defines)??null,mP=h.join("\n");let N=G;return H!==mP&&(N=U.createEffect(y,{attributes:l,uniformsNames:t,uniformBuffersNames:W,samplers:k,defines:mP,fallbacks:V,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:x},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},U),Z?R.setEffect(N,mP,this._materialContext):d&&d.setEffect(N,mP),this._onEffectCreatedObservable&&(q.effect=N,q.subMesh=R??(null===P||void 0===P?void 0:P.Zj[0])??null,this._onEffectCreatedObservable.notifyObservers(q))),d._wasPreviouslyUsingInstances=!!a,!(null===(S=N)||void 0===S||!S.isReady())&&(G!==N&&j.resetCachedMaterial(),d._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(P,a){const R=a??this.getEffect();if(!R)return;const S=this._options.uniforms;-1!==S.indexOf("world")&&R.setMatrix("world",P);const A=this.GP();-1!==S.indexOf("worldView")&&(P.multiplyToRef(A.getViewMatrix(),this._cachedWorldViewMatrix),R.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==S.indexOf("worldViewProjection")&&(P.multiplyToRef(A.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),R.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==S.indexOf("view")&&R.setMatrix("view",A.getViewMatrix())}bindForSubMesh(P,a,R){var S;this.bind(P,a,null===(S=R._drawWrapperOverride)||void 0===S?void 0:S.effect,R)}bind(P,a,R,S){const A=S&&this._storeEffectOnSubMeshes,Z=R??(A?S.effect:this.getEffect());if(!Z)return;const p=this.GP();this._activeEffect=Z,this.bindOnlyWorldMatrix(P,R);const j=this._options.uniformBuffers;let U=!1;if(Z&&j&&j.length>0&&p.getEngine().supportsUniformBuffers)for(let l=0;l<j.length;++l){switch(j[l]){case"Mesh":a&&(a.getMeshUniformBuffer().bindToEffect(Z,"Mesh"),a.transferToEffect(P));break;case"Scene":(0,O.r)(Z,p.getSceneUniformBuffer()),p.finalizeSceneUbo(),U=!0}}const Q=a&&A?this._mustRebind(p,Z,S,a.visibility):p.getCachedMaterial()!==this;if(Z&&Q){let P;for(P in U||-1===this._options.uniforms.indexOf("view")||Z.setMatrix("view",p.getViewMatrix()),U||-1===this._options.uniforms.indexOf("projection")||Z.setMatrix("projection",p.getProjectionMatrix()),U||-1===this._options.uniforms.indexOf("viewProjection")||(Z.setMatrix("viewProjection",p.getTransformMatrix()),this._multiview&&Z.setMatrix("viewProjectionR",p._transformMatrixR)),p.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&Z.setVector3("cameraPosition",p.activeCamera.globalPosition),(0,O.d)(a,Z),(0,f.f)(Z,this,p),this._useLogarithmicDepth&&(0,O.m)(A?S.materialDefines:Z.defines,Z,p),a&&(0,O.h)(p,a,Z),this._textures)Z.setTexture(P,this._textures[P]);for(P in this._textureArrays)Z.setTextureArray(P,this._textureArrays[P]);for(P in this._ints)Z.setInt(P,this._ints[P]);for(P in this._uints)Z.setUInt(P,this._uints[P]);for(P in this._floats)Z.setFloat(P,this._floats[P]);for(P in this._floatsArrays)Z.setArray(P,this._floatsArrays[P]);for(P in this._colors3)Z.setColor3(P,this._colors3[P]);for(P in this._colors3Arrays)Z.setArray3(P,this._colors3Arrays[P]);for(P in this._colors4){const a=this._colors4[P];Z.setFloat4(P,a.r,a.g,a.b,a.a)}for(P in this._colors4Arrays)Z.setArray4(P,this._colors4Arrays[P]);for(P in this._vectors2)Z.setVector2(P,this._vectors2[P]);for(P in this._vectors3)Z.setVector3(P,this._vectors3[P]);for(P in this._vectors4)Z.setVector4(P,this._vectors4[P]);for(P in this._quaternions)Z.setQuaternion(P,this._quaternions[P]);for(P in this._matrices)Z.setMatrix(P,this._matrices[P]);for(P in this._matrixArrays)Z.setMatrices(P,this._matrixArrays[P]);for(P in this._matrices3x3)Z.setMatrix3x3(P,this._matrices3x3[P]);for(P in this._matrices2x2)Z.setMatrix2x2(P,this._matrices2x2[P]);for(P in this._vectors2Arrays)Z.setArray2(P,this._vectors2Arrays[P]);for(P in this._vectors3Arrays)Z.setArray3(P,this._vectors3Arrays[P]);for(P in this._vectors4Arrays)Z.setArray4(P,this._vectors4Arrays[P]);for(P in this._quaternionsArrays)Z.setArray4(P,this._quaternionsArrays[P]);for(P in this._uniformBuffers){const a=this._uniformBuffers[P].getBuffer();a&&Z.bindUniformBuffer(a,P)}const R=p.getEngine(),j=R.setExternalTexture;if(j)for(P in this._externalTextures)j.call(R,P,this._externalTextures[P]);const Q=R.setTextureSampler;if(Q)for(P in this._textureSamplers)Q.call(R,P,this._textureSamplers[P]);const h=R.setStorageBuffer;if(h)for(P in this._storageBuffers)h.call(R,P,this._storageBuffers[P])}if(Z&&a&&(Q||!this.isFrozen)){(0,O.q)(a,Z),a.morphTargetManager&&a.morphTargetManager.isUsingTextureForTargets&&a.morphTargetManager._bind(Z);const P=a.bakedVertexAnimationManager;if(P&&P.isEnabled){var h;const P=A?S._drawWrapper:this._drawWrapper;null===(h=a.bakedVertexAnimationManager)||void 0===h||h.bind(Z,!!P._wasPreviouslyUsingInstances)}}this._afterBind(a,Z,S)}getActiveTextures(){const P=super.getActiveTextures();for(const a in this._textures)P.push(this._textures[a]);for(const a in this._textureArrays){const R=this._textureArrays[a];for(let a=0;a<R.length;a++)P.push(R[a])}return P}hasTexture(P){if(super.hasTexture(P))return!0;for(const a in this._textures)if(this._textures[a]===P)return!0;for(const a in this._textureArrays){const R=this._textureArrays[a];for(let a=0;a<R.length;a++)if(R[a]===P)return!0}return!1}clone(P){const a=S.e.Clone((()=>new y(P,this.GP(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);a.name=P,a.id=P,"object"===typeof a._shaderPath&&(a._shaderPath={...a._shaderPath}),this._options={...this._options};const R=Object.keys(this._options);for(const S of R){const P=this._options[S];Array.isArray(P)&&(this._options[S]=P.slice(0))}this.gp.copyTo(a.gp);for(const S in this._textures)a.setTexture(S,this._textures[S]);for(const S in this._textureArrays)a.setTextureArray(S,this._textureArrays[S]);for(const S in this._externalTextures)a.setExternalTexture(S,this._externalTextures[S]);for(const S in this._ints)a.setInt(S,this._ints[S]);for(const S in this._uints)a.setUInt(S,this._uints[S]);for(const S in this._floats)a.setFloat(S,this._floats[S]);for(const S in this._floatsArrays)a.setFloats(S,this._floatsArrays[S]);for(const S in this._colors3)a.setColor3(S,this._colors3[S]);for(const S in this._colors3Arrays)a._colors3Arrays[S]=this._colors3Arrays[S];for(const S in this._colors4)a.setColor4(S,this._colors4[S]);for(const S in this._colors4Arrays)a._colors4Arrays[S]=this._colors4Arrays[S];for(const S in this._vectors2)a.setVector2(S,this._vectors2[S]);for(const S in this._vectors3)a.setVector3(S,this._vectors3[S]);for(const S in this._vectors4)a.setVector4(S,this._vectors4[S]);for(const S in this._quaternions)a.setQuaternion(S,this._quaternions[S]);for(const S in this._quaternionsArrays)a._quaternionsArrays[S]=this._quaternionsArrays[S];for(const S in this._matrices)a.setMatrix(S,this._matrices[S]);for(const S in this._matrixArrays)a._matrixArrays[S]=this._matrixArrays[S].slice();for(const S in this._matrices3x3)a.setMatrix3x3(S,this._matrices3x3[S]);for(const S in this._matrices2x2)a.setMatrix2x2(S,this._matrices2x2[S]);for(const S in this._vectors2Arrays)a.setArray2(S,this._vectors2Arrays[S]);for(const S in this._vectors3Arrays)a.setArray3(S,this._vectors3Arrays[S]);for(const S in this._vectors4Arrays)a.setArray4(S,this._vectors4Arrays[S]);for(const S in this._uniformBuffers)a.setUniformBuffer(S,this._uniformBuffers[S]);for(const S in this._textureSamplers)a.setTextureSampler(S,this._textureSamplers[S]);for(const S in this._storageBuffers)a.setStorageBuffer(S,this._storageBuffers[S]);return a}dispose(P,a,R){if(a){let P;for(P in this._textures)this._textures[P].dispose();for(P in this._textureArrays){const a=this._textureArrays[P];for(let P=0;P<a.length;P++)a[P].dispose()}}this._textures={},super.dispose(P,a,R)}serialize(){const P=S.e.Serialize(this);let a;for(a in P.customType="BABYLON.ShaderMaterial",P.uniqueId=this.uniqueId,P.options=this._options,P.shaderPath=this._shaderPath,P.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,P.gp=this.gp.serialize(),P.textures={},this._textures)P.textures[a]=this._textures[a].serialize();for(a in P.textureArrays={},this._textureArrays){P.textureArrays[a]=[];const R=this._textureArrays[a];for(let S=0;S<R.length;S++)P.textureArrays[a].push(R[S].serialize())}for(a in P.ints={},this._ints)P.ints[a]=this._ints[a];for(a in P.uints={},this._uints)P.uints[a]=this._uints[a];for(a in P.floats={},this._floats)P.floats[a]=this._floats[a];for(a in P.floatsArrays={},this._floatsArrays)P.floatsArrays[a]=this._floatsArrays[a];for(a in P.colors3={},this._colors3){const R=this._colors3[a];P.colors3[a]=[R.r,R.g,R.b]}for(a in P.colors3Arrays={},this._colors3Arrays)P.colors3Arrays[a]=this._colors3Arrays[a];for(a in P.colors4={},this._colors4){const R=this._colors4[a];P.colors4[a]=[R.r,R.g,R.b,R.a]}for(a in P.colors4Arrays={},this._colors4Arrays)P.colors4Arrays[a]=this._colors4Arrays[a];for(a in P.vectors2={},this._vectors2){const R=this._vectors2[a];P.vectors2[a]=[R.x,R.y]}for(a in P.vectors3={},this._vectors3){const R=this._vectors3[a];P.vectors3[a]=[R.x,R.y,R.z]}for(a in P.vectors4={},this._vectors4){const R=this._vectors4[a];P.vectors4[a]=[R.x,R.y,R.z,R.w]}for(a in P.quaternions={},this._quaternions)P.quaternions[a]=this._quaternions[a].pj();for(a in P.matrices={},this._matrices)P.matrices[a]=this._matrices[a].pj();for(a in P.matrixArray={},this._matrixArrays)P.matrixArray[a]=this._matrixArrays[a];for(a in P.matrices3x3={},this._matrices3x3)P.matrices3x3[a]=this._matrices3x3[a];for(a in P.matrices2x2={},this._matrices2x2)P.matrices2x2[a]=this._matrices2x2[a];for(a in P.vectors2Arrays={},this._vectors2Arrays)P.vectors2Arrays[a]=this._vectors2Arrays[a];for(a in P.vectors3Arrays={},this._vectors3Arrays)P.vectors3Arrays[a]=this._vectors3Arrays[a];for(a in P.vectors4Arrays={},this._vectors4Arrays)P.vectors4Arrays[a]=this._vectors4Arrays[a];for(a in P.quaternionsArrays={},this._quaternionsArrays)P.quaternionsArrays[a]=this._quaternionsArrays[a];return P}static Parse(P,a,R){const A=S.e.Parse((()=>new y(P.name,a,P.shaderPath,P.options,P.storeEffectOnSubMeshes)),P,a,R);let p;for(p in P.gp&&A.gp.parse(P.gp,a,R),P.textures)A.setTexture(p,j.e.Parse(P.textures[p],a,R));for(p in P.textureArrays){const S=P.textureArrays[p],Z=[];for(let P=0;P<S.length;P++)Z.push(j.e.Parse(S[P],a,R));A.setTextureArray(p,Z)}for(p in P.ints)A.setInt(p,P.ints[p]);for(p in P.uints)A.setUInt(p,P.uints[p]);for(p in P.floats)A.setFloat(p,P.floats[p]);for(p in P.floatsArrays)A.setFloats(p,P.floatsArrays[p]);for(p in P.colors3){const a=P.colors3[p];A.setColor3(p,{r:a[0],g:a[1],b:a[2]})}for(p in P.colors3Arrays){const a=P.colors3Arrays[p].reduce(((P,a,R)=>(R%3===0?P.push([a]):P[P.length-1].push(a),P)),[]).map((P=>({r:P[0],g:P[1],b:P[2]})));A.setColor3Array(p,a)}for(p in P.colors4){const a=P.colors4[p];A.setColor4(p,{r:a[0],g:a[1],b:a[2],a:a[3]})}for(p in P.colors4Arrays){const a=P.colors4Arrays[p].reduce(((P,a,R)=>(R%4===0?P.push([a]):P[P.length-1].push(a),P)),[]).map((P=>({r:P[0],g:P[1],b:P[2],a:P[3]})));A.setColor4Array(p,a)}for(p in P.vectors2){const a=P.vectors2[p];A.setVector2(p,{x:a[0],y:a[1]})}for(p in P.vectors3){const a=P.vectors3[p];A.setVector3(p,{x:a[0],y:a[1],z:a[2]})}for(p in P.vectors4){const a=P.vectors4[p];A.setVector4(p,{x:a[0],y:a[1],z:a[2],w:a[3]})}for(p in P.quaternions)A.setQuaternion(p,Z.Quaternion.ka(P.quaternions[p]));for(p in P.matrices)A.setMatrix(p,Z.Matrix.ka(P.matrices[p]));for(p in P.matrixArray)A._matrixArrays[p]=new Float32Array(P.matrixArray[p]);for(p in P.matrices3x3)A.setMatrix3x3(p,P.matrices3x3[p]);for(p in P.matrices2x2)A.setMatrix2x2(p,P.matrices2x2[p]);for(p in P.vectors2Arrays)A.setArray2(p,P.vectors2Arrays[p]);for(p in P.vectors3Arrays)A.setArray3(p,P.vectors3Arrays[p]);for(p in P.vectors4Arrays)A.setArray4(p,P.vectors4Arrays[p]);for(p in P.quaternionsArrays)A.setArray4(p,P.quaternionsArrays[p]);return A}static async ParseFromFileAsync(P,a,R){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((A,Z)=>{const p=new h.e;p.addEventListener("readystatechange",(()=>{if(4==p.readyState)if(200==p.status){const a=JSON.parse(p.responseText),Z=this.Parse(a,R||V.e.LastCreatedScene,S);P&&(Z.name=P),A(Z)}else Z("Unable to load the ShaderMaterial")})),p.open("GET",a),p.send()}))}static async ParseFromSnippetAsync(P,a){let R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((S,A)=>{const Z=new h.e;Z.addEventListener("readystatechange",(()=>{if(4==Z.readyState)if(200==Z.status){const A=JSON.parse(JSON.parse(Z.responseText).jsonPayload),p=JSON.parse(A.shaderMaterial),j=this.Parse(p,a||V.e.LastCreatedScene,R);j.snippetId=P,S(j)}else A("Unable to load the snippet "+P)})),Z.open("GET",this.SnippetUrl+"/"+P.replace(/#/g,"/")),Z.send()}))}}y.SnippetUrl="https://snippet.babylonjs.com",y.CreateFromSnippetAsync=y.ParseFromSnippetAsync,(0,U.d)("BABYLON.ShaderMaterial",y)}}]);