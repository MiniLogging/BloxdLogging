"use strict";(self.bjbkv7h3qsd=self.bjbkv7h3qsd||[]).push([[22],{11449:(G,A,j)=>{j.r(A),j.d(A,{ShaderMaterial:()=>C});var u=j(11251),k=j(11458),B=j(11218),x=j(11290),s=j(11196),O=j(11181),d=j(11517),h=j(11078),H=j(11522),F=j(11085),R=j(11566),U=j(11560);const S={effect:null,subMesh:null};class C extends H.d{constructor(G,A,j){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(G,A,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new B.Matrix,this._cachedWorldViewProjectionMatrix=new B.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=j,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...u}}get shaderPath(){return this._shaderPath}set shaderPath(G){this._shaderPath=G}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(G){-1===this._options.uniforms.indexOf(G)&&this._options.uniforms.push(G)}setTexture(G,A){return-1===this._options.samplers.indexOf(G)&&this._options.samplers.push(G),this._textures[G]=A,this}removeTexture(G){delete this._textures[G]}setTextureArray(G,A){return-1===this._options.samplers.indexOf(G)&&this._options.samplers.push(G),this._checkUniform(G),this._textureArrays[G]=A,this}setExternalTexture(G,A){return-1===this._options.externalTextures.indexOf(G)&&this._options.externalTextures.push(G),this._externalTextures[G]=A,this}setFloat(G,A){return this._checkUniform(G),this._floats[G]=A,this}setInt(G,A){return this._checkUniform(G),this._ints[G]=A,this}setUInt(G,A){return this._checkUniform(G),this._uints[G]=A,this}setFloats(G,A){return this._checkUniform(G),this._floatsArrays[G]=A,this}setColor3(G,A){return this._checkUniform(G),this._colors3[G]=A,this}setColor3Array(G,A){return this._checkUniform(G),this._colors3Arrays[G]=A.reduce(((G,A)=>(G.push(A.r,A.g,A.b),G)),[]),this}setColor4(G,A){return this._checkUniform(G),this._colors4[G]=A,this}setColor4Array(G,A){return this._checkUniform(G),this._colors4Arrays[G]=A.reduce(((G,A)=>(G.push(A.r,A.g,A.b,A.a),G)),[]),this}setVector2(G,A){return this._checkUniform(G),this._vectors2[G]=A,this}setVector3(G,A){return this._checkUniform(G),this._vectors3[G]=A,this}setVector4(G,A){return this._checkUniform(G),this._vectors4[G]=A,this}setQuaternion(G,A){return this._checkUniform(G),this._quaternions[G]=A,this}setQuaternionArray(G,A){return this._checkUniform(G),this._quaternionsArrays[G]=A.reduce(((G,A)=>(A.toArray(G,G.length),G)),[]),this}setMatrix(G,A){return this._checkUniform(G),this._matrices[G]=A,this}setMatrices(G,A){this._checkUniform(G);const j=new Float32Array(16*A.length);for(let u=0;u<A.length;u++){A[u].copyToArray(j,16*u)}return this._matrixArrays[G]=j,this}setMatrix3x3(G,A){return this._checkUniform(G),this._matrices3x3[G]=A,this}setMatrix2x2(G,A){return this._checkUniform(G),this._matrices2x2[G]=A,this}setArray2(G,A){return this._checkUniform(G),this._vectors2Arrays[G]=A,this}setArray3(G,A){return this._checkUniform(G),this._vectors3Arrays[G]=A,this}setArray4(G,A){return this._checkUniform(G),this._vectors4Arrays[G]=A,this}setUniformBuffer(G,A){return-1===this._options.uniformBuffers.indexOf(G)&&this._options.uniformBuffers.push(G),this._uniformBuffers[G]=A,this}setTextureSampler(G,A){return-1===this._options.samplerObjects.indexOf(G)&&this._options.samplerObjects.push(G),this._textureSamplers[G]=A,this}setStorageBuffer(G,A){return-1===this._options.storageBuffers.indexOf(G)&&this._options.storageBuffers.push(G),this._storageBuffers[G]=A,this}setDefine(G,A){const j=G.trimEnd()+" ",u=this.options.defines.findIndex((A=>A===G||A.startsWith(j)));return u>=0&&this.options.defines.splice(u,1),("boolean"!==typeof A||A)&&this.options.defines.push(j+A),this}isReadyForSubMesh(G,A,j){return this.isReady(G,j,A)}isReady(G,A,j){var u;const B=j&&this._storeEffectOnSubMeshes;if(this.isFrozen){const G=B?j._drawWrapper:this._drawWrapper;if(G.effect&&G._wasPreviouslyReady&&G._wasPreviouslyUsingInstances===A)return!0}const s=this.gG(),O=s.getEngine(),h=[],H=[];let F=null,C=this._shaderPath,t=this._options.uniforms,Y=this._options.uniformBuffers,n=this._options.samplers;O.getCaps().multiview&&s.activeCamera&&s.activeCamera.outputRenderTarget&&s.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,h.push("#define MULTIVIEW"),-1!==t.indexOf("viewProjection")&&-1===t.indexOf("viewProjectionR")&&t.push("viewProjectionR"));for(let k=0;k<this._options.defines.length;k++){const G=0===this._options.defines[k].indexOf("#define")?this._options.defines[k]:`#define ${this._options.defines[k]}`;h.push(G)}for(let k=0;k<this._options.attributes.length;k++)H.push(this._options.attributes[k]);if(G&&G.isVerticesDataPresent(x.h.ColorKind)&&(-1===H.indexOf(x.h.ColorKind)&&H.push(x.h.ColorKind),h.push("#define VERTEXCOLOR")),A&&(h.push("#define INSTANCES"),(0,U.mb)(H,this._materialHelperNeedsPreviousMatrices),null!==G&&void 0!==G&&G.hasThinInstances&&(h.push("#define THIN_INSTANCES"),G&&G.isVerticesDataPresent(x.h.ColorInstanceKind)&&(H.push(x.h.ColorInstanceKind),h.push("#define INSTANCESCOLOR")))),G&&G.useBones&&G.computeBonesUsingShaders&&G.skeleton){H.push(x.h.MatricesIndicesKind),H.push(x.h.MatricesWeightsKind),G.numBoneInfluencers>4&&(H.push(x.h.MatricesIndicesExtraKind),H.push(x.h.MatricesWeightsExtraKind));const A=G.skeleton;h.push("#define NUM_BONE_INFLUENCERS "+G.numBoneInfluencers),F=new d.e,F.addCPUSkinningFallback(0,G),A.isUsingTextureForMatrices?(h.push("#define BONETEXTURE"),-1===t.indexOf("boneTextureWidth")&&t.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(h.push("#define BonesPerMesh "+(A.bones.length+1)),-1===t.indexOf("mBones")&&t.push("mBones"))}else h.push("#define NUM_BONE_INFLUENCERS 0");let Q=0;const X=G?G.morphTargetManager:null;if(X){const A=-1!==h.indexOf("#define UV1"),j=-1!==h.indexOf("#define UV2"),u=-1!==h.indexOf("#define TANGENT"),k=-1!==h.indexOf("#define NORMAL"),B=-1!==h.indexOf("#define VERTEXCOLOR");Q=(0,U.M)(X,h,H,G,!0,k,u,A,j,B),X.isUsingTextureForTargets&&(-1===t.indexOf("morphTargetTextureIndices")&&t.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),Q>0&&(t=t.slice(),t.push("morphTargetInfluences"),t.push("morphTargetCount"),t.push("morphTargetTextureInfo"),t.push("morphTargetTextureIndices"))}else h.push("#define NUM_MORPH_INFLUENCERS 0");if(G){const A=G.bakedVertexAnimationManager;A&&A.isEnabled&&(h.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===t.indexOf("bakedVertexAnimationSettings")&&t.push("bakedVertexAnimationSettings"),-1===t.indexOf("bakedVertexAnimationTextureSizeInverted")&&t.push("bakedVertexAnimationTextureSizeInverted"),-1===t.indexOf("bakedVertexAnimationTime")&&t.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,U.D)(H,G,h)}for(const k in this._textures)if(!this._textures[k].isReady())return!1;G&&this.needAlphaTestingForMesh(G)&&h.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,R.d)(t),(0,R.k)(this,s,h)),s.fogEnabled&&null!==G&&void 0!==G&&G.applyFog&&s.fogMode!==k.b.FOGMODE_NONE&&(h.push("#define FOG"),-1===t.indexOf("view")&&t.push("view"),-1===t.indexOf("vFogInfos")&&t.push("vFogInfos"),-1===t.indexOf("vFogColor")&&t.push("vFogColor")),this._useLogarithmicDepth&&(h.push("#define LOGARITHMICDEPTH"),-1===t.indexOf("logarithmicDepthConstant")&&t.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(t=t.slice(),Y=Y.slice(),n=n.slice(),C=this.customShaderNameResolve(this.name,t,Y,n,h,H));const I=B?j._getDrawWrapper(void 0,!0):this._drawWrapper,D=(null===I||void 0===I?void 0:I.effect)??null,g=(null===I||void 0===I?void 0:I.defines)??null,c=h.join("\n");let E=D;return g!==c&&(E=O.createEffect(C,{attributes:H,uniformsNames:t,uniformBuffersNames:Y,samplers:n,defines:c,fallbacks:F,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:Q},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},O),B?j.setEffect(E,c,this._materialContext):I&&I.setEffect(E,c),this._onEffectCreatedObservable&&(S.effect=E,S.subMesh=j??(null===G||void 0===G?void 0:G.ds[0])??null,this._onEffectCreatedObservable.notifyObservers(S))),I._wasPreviouslyUsingInstances=!!A,!(null===(u=E)||void 0===u||!u.isReady())&&(D!==E&&s.resetCachedMaterial(),I._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(G,A){const j=A??this.getEffect();if(!j)return;const u=this._options.uniforms;-1!==u.indexOf("world")&&j.setMatrix("world",G);const k=this.gG();-1!==u.indexOf("worldView")&&(G.multiplyToRef(k.getViewMatrix(),this._cachedWorldViewMatrix),j.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==u.indexOf("worldViewProjection")&&(G.multiplyToRef(k.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),j.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==u.indexOf("view")&&j.setMatrix("view",k.getViewMatrix())}bindForSubMesh(G,A,j){var u;this.bind(G,A,null===(u=j._drawWrapperOverride)||void 0===u?void 0:u.effect,j)}bind(G,A,j,u){const k=u&&this._storeEffectOnSubMeshes,B=j??(k?u.effect:this.getEffect());if(!B)return;const x=this.gG();this._activeEffect=B,this.bindOnlyWorldMatrix(G,j);const s=this._options.uniformBuffers;let O=!1;if(B&&s&&s.length>0&&x.getEngine().supportsUniformBuffers)for(let H=0;H<s.length;++H){switch(s[H]){case"Mesh":A&&(A.getMeshUniformBuffer().bindToEffect(B,"Mesh"),A.transferToEffect(G));break;case"Scene":(0,U.s)(B,x.getSceneUniformBuffer()),x.finalizeSceneUbo(),O=!0}}const d=A&&k?this._mustRebind(x,B,u,A.visibility):x.getCachedMaterial()!==this;if(B&&d){let G;for(G in O||-1===this._options.uniforms.indexOf("view")||B.setMatrix("view",x.getViewMatrix()),O||-1===this._options.uniforms.indexOf("projection")||B.setMatrix("projection",x.getProjectionMatrix()),O||-1===this._options.uniforms.indexOf("viewProjection")||(B.setMatrix("viewProjection",x.getTransformMatrix()),this._multiview&&B.setMatrix("viewProjectionR",x._transformMatrixR)),x.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&B.setVector3("cameraPosition",x.activeCamera.globalPosition),(0,U.c)(A,B),(0,R.g)(B,this,x),this._useLogarithmicDepth&&(0,U.n)(k?u.materialDefines:B.defines,B,x),A&&(0,U.f)(x,A,B),this._textures)B.setTexture(G,this._textures[G]);for(G in this._textureArrays)B.setTextureArray(G,this._textureArrays[G]);for(G in this._ints)B.setInt(G,this._ints[G]);for(G in this._uints)B.setUInt(G,this._uints[G]);for(G in this._floats)B.setFloat(G,this._floats[G]);for(G in this._floatsArrays)B.setArray(G,this._floatsArrays[G]);for(G in this._colors3)B.setColor3(G,this._colors3[G]);for(G in this._colors3Arrays)B.setArray3(G,this._colors3Arrays[G]);for(G in this._colors4){const A=this._colors4[G];B.setFloat4(G,A.r,A.g,A.b,A.a)}for(G in this._colors4Arrays)B.setArray4(G,this._colors4Arrays[G]);for(G in this._vectors2)B.setVector2(G,this._vectors2[G]);for(G in this._vectors3)B.setVector3(G,this._vectors3[G]);for(G in this._vectors4)B.setVector4(G,this._vectors4[G]);for(G in this._quaternions)B.setQuaternion(G,this._quaternions[G]);for(G in this._matrices)B.setMatrix(G,this._matrices[G]);for(G in this._matrixArrays)B.setMatrices(G,this._matrixArrays[G]);for(G in this._matrices3x3)B.setMatrix3x3(G,this._matrices3x3[G]);for(G in this._matrices2x2)B.setMatrix2x2(G,this._matrices2x2[G]);for(G in this._vectors2Arrays)B.setArray2(G,this._vectors2Arrays[G]);for(G in this._vectors3Arrays)B.setArray3(G,this._vectors3Arrays[G]);for(G in this._vectors4Arrays)B.setArray4(G,this._vectors4Arrays[G]);for(G in this._quaternionsArrays)B.setArray4(G,this._quaternionsArrays[G]);for(G in this._uniformBuffers){const A=this._uniformBuffers[G].getBuffer();A&&B.bindUniformBuffer(A,G)}const j=x.getEngine(),s=j.setExternalTexture;if(s)for(G in this._externalTextures)s.call(j,G,this._externalTextures[G]);const d=j.setTextureSampler;if(d)for(G in this._textureSamplers)d.call(j,G,this._textureSamplers[G]);const h=j.setStorageBuffer;if(h)for(G in this._storageBuffers)h.call(j,G,this._storageBuffers[G])}if(B&&A&&(d||!this.isFrozen)){(0,U.r)(A,B),A.morphTargetManager&&A.morphTargetManager.isUsingTextureForTargets&&A.morphTargetManager._bind(B);const G=A.bakedVertexAnimationManager;if(G&&G.isEnabled){var h;const G=k?u._drawWrapper:this._drawWrapper;null===(h=A.bakedVertexAnimationManager)||void 0===h||h.bind(B,!!G._wasPreviouslyUsingInstances)}}this._afterBind(A,B,u)}getActiveTextures(){const G=super.getActiveTextures();for(const A in this._textures)G.push(this._textures[A]);for(const A in this._textureArrays){const j=this._textureArrays[A];for(let A=0;A<j.length;A++)G.push(j[A])}return G}hasTexture(G){if(super.hasTexture(G))return!0;for(const A in this._textures)if(this._textures[A]===G)return!0;for(const A in this._textureArrays){const j=this._textureArrays[A];for(let A=0;A<j.length;A++)if(j[A]===G)return!0}return!1}clone(G){const A=u.c.Clone((()=>new C(G,this.gG(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);A.name=G,A.id=G,"object"===typeof A._shaderPath&&(A._shaderPath={...A._shaderPath}),this._options={...this._options};const j=Object.keys(this._options);for(const u of j){const G=this._options[u];Array.isArray(G)&&(this._options[u]=G.slice(0))}this.stencil.copyTo(A.stencil);for(const u in this._textures)A.setTexture(u,this._textures[u]);for(const u in this._textureArrays)A.setTextureArray(u,this._textureArrays[u]);for(const u in this._externalTextures)A.setExternalTexture(u,this._externalTextures[u]);for(const u in this._ints)A.setInt(u,this._ints[u]);for(const u in this._uints)A.setUInt(u,this._uints[u]);for(const u in this._floats)A.setFloat(u,this._floats[u]);for(const u in this._floatsArrays)A.setFloats(u,this._floatsArrays[u]);for(const u in this._colors3)A.setColor3(u,this._colors3[u]);for(const u in this._colors3Arrays)A._colors3Arrays[u]=this._colors3Arrays[u];for(const u in this._colors4)A.setColor4(u,this._colors4[u]);for(const u in this._colors4Arrays)A._colors4Arrays[u]=this._colors4Arrays[u];for(const u in this._vectors2)A.setVector2(u,this._vectors2[u]);for(const u in this._vectors3)A.setVector3(u,this._vectors3[u]);for(const u in this._vectors4)A.setVector4(u,this._vectors4[u]);for(const u in this._quaternions)A.setQuaternion(u,this._quaternions[u]);for(const u in this._quaternionsArrays)A._quaternionsArrays[u]=this._quaternionsArrays[u];for(const u in this._matrices)A.setMatrix(u,this._matrices[u]);for(const u in this._matrixArrays)A._matrixArrays[u]=this._matrixArrays[u].slice();for(const u in this._matrices3x3)A.setMatrix3x3(u,this._matrices3x3[u]);for(const u in this._matrices2x2)A.setMatrix2x2(u,this._matrices2x2[u]);for(const u in this._vectors2Arrays)A.setArray2(u,this._vectors2Arrays[u]);for(const u in this._vectors3Arrays)A.setArray3(u,this._vectors3Arrays[u]);for(const u in this._vectors4Arrays)A.setArray4(u,this._vectors4Arrays[u]);for(const u in this._uniformBuffers)A.setUniformBuffer(u,this._uniformBuffers[u]);for(const u in this._textureSamplers)A.setTextureSampler(u,this._textureSamplers[u]);for(const u in this._storageBuffers)A.setStorageBuffer(u,this._storageBuffers[u]);return A}dispose(G,A,j){if(A){let G;for(G in this._textures)this._textures[G].dispose();for(G in this._textureArrays){const A=this._textureArrays[G];for(let G=0;G<A.length;G++)A[G].dispose()}}this._textures={},super.dispose(G,A,j)}serialize(){const G=u.c.Serialize(this);let A;for(A in G.customType="BABYLON.ShaderMaterial",G.uniqueId=this.uniqueId,G.options=this._options,G.shaderPath=this._shaderPath,G.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,G.stencil=this.stencil.serialize(),G.textures={},this._textures)G.textures[A]=this._textures[A].serialize();for(A in G.textureArrays={},this._textureArrays){G.textureArrays[A]=[];const j=this._textureArrays[A];for(let u=0;u<j.length;u++)G.textureArrays[A].push(j[u].serialize())}for(A in G.ints={},this._ints)G.ints[A]=this._ints[A];for(A in G.uints={},this._uints)G.uints[A]=this._uints[A];for(A in G.floats={},this._floats)G.floats[A]=this._floats[A];for(A in G.floatsArrays={},this._floatsArrays)G.floatsArrays[A]=this._floatsArrays[A];for(A in G.colors3={},this._colors3){const j=this._colors3[A];G.colors3[A]=[j.r,j.g,j.b]}for(A in G.colors3Arrays={},this._colors3Arrays)G.colors3Arrays[A]=this._colors3Arrays[A];for(A in G.colors4={},this._colors4){const j=this._colors4[A];G.colors4[A]=[j.r,j.g,j.b,j.a]}for(A in G.colors4Arrays={},this._colors4Arrays)G.colors4Arrays[A]=this._colors4Arrays[A];for(A in G.vectors2={},this._vectors2){const j=this._vectors2[A];G.vectors2[A]=[j.x,j.y]}for(A in G.vectors3={},this._vectors3){const j=this._vectors3[A];G.vectors3[A]=[j.x,j.y,j.z]}for(A in G.vectors4={},this._vectors4){const j=this._vectors4[A];G.vectors4[A]=[j.x,j.y,j.z,j.w]}for(A in G.quaternions={},this._quaternions)G.quaternions[A]=this._quaternions[A].hs();for(A in G.matrices={},this._matrices)G.matrices[A]=this._matrices[A].hs();for(A in G.matrixArray={},this._matrixArrays)G.matrixArray[A]=this._matrixArrays[A];for(A in G.matrices3x3={},this._matrices3x3)G.matrices3x3[A]=this._matrices3x3[A];for(A in G.matrices2x2={},this._matrices2x2)G.matrices2x2[A]=this._matrices2x2[A];for(A in G.vectors2Arrays={},this._vectors2Arrays)G.vectors2Arrays[A]=this._vectors2Arrays[A];for(A in G.vectors3Arrays={},this._vectors3Arrays)G.vectors3Arrays[A]=this._vectors3Arrays[A];for(A in G.vectors4Arrays={},this._vectors4Arrays)G.vectors4Arrays[A]=this._vectors4Arrays[A];for(A in G.quaternionsArrays={},this._quaternionsArrays)G.quaternionsArrays[A]=this._quaternionsArrays[A];return G}static Parse(G,A,j){const k=u.c.Parse((()=>new C(G.name,A,G.shaderPath,G.options,G.storeEffectOnSubMeshes)),G,A,j);let x;for(x in G.stencil&&k.stencil.parse(G.stencil,A,j),G.textures)k.setTexture(x,s.e.Parse(G.textures[x],A,j));for(x in G.textureArrays){const u=G.textureArrays[x],B=[];for(let G=0;G<u.length;G++)B.push(s.e.Parse(u[G],A,j));k.setTextureArray(x,B)}for(x in G.ints)k.setInt(x,G.ints[x]);for(x in G.uints)k.setUInt(x,G.uints[x]);for(x in G.floats)k.setFloat(x,G.floats[x]);for(x in G.floatsArrays)k.setFloats(x,G.floatsArrays[x]);for(x in G.colors3){const A=G.colors3[x];k.setColor3(x,{r:A[0],g:A[1],b:A[2]})}for(x in G.colors3Arrays){const A=G.colors3Arrays[x].reduce(((G,A,j)=>(j%3===0?G.push([A]):G[G.length-1].push(A),G)),[]).map((G=>({r:G[0],g:G[1],b:G[2]})));k.setColor3Array(x,A)}for(x in G.colors4){const A=G.colors4[x];k.setColor4(x,{r:A[0],g:A[1],b:A[2],a:A[3]})}for(x in G.colors4Arrays){const A=G.colors4Arrays[x].reduce(((G,A,j)=>(j%4===0?G.push([A]):G[G.length-1].push(A),G)),[]).map((G=>({r:G[0],g:G[1],b:G[2],a:G[3]})));k.setColor4Array(x,A)}for(x in G.vectors2){const A=G.vectors2[x];k.setVector2(x,{x:A[0],y:A[1]})}for(x in G.vectors3){const A=G.vectors3[x];k.setVector3(x,{x:A[0],y:A[1],z:A[2]})}for(x in G.vectors4){const A=G.vectors4[x];k.setVector4(x,{x:A[0],y:A[1],z:A[2],w:A[3]})}for(x in G.quaternions)k.setQuaternion(x,B.Quaternion.QA(G.quaternions[x]));for(x in G.matrices)k.setMatrix(x,B.Matrix.QA(G.matrices[x]));for(x in G.matrixArray)k._matrixArrays[x]=new Float32Array(G.matrixArray[x]);for(x in G.matrices3x3)k.setMatrix3x3(x,G.matrices3x3[x]);for(x in G.matrices2x2)k.setMatrix2x2(x,G.matrices2x2[x]);for(x in G.vectors2Arrays)k.setArray2(x,G.vectors2Arrays[x]);for(x in G.vectors3Arrays)k.setArray3(x,G.vectors3Arrays[x]);for(x in G.vectors4Arrays)k.setArray4(x,G.vectors4Arrays[x]);for(x in G.quaternionsArrays)k.setArray4(x,G.quaternionsArrays[x]);return k}static async ParseFromFileAsync(G,A,j){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((k,B)=>{const x=new h.c;x.addEventListener("readystatechange",(()=>{if(4==x.readyState)if(200==x.status){const A=JSON.parse(x.responseText),B=this.Parse(A,j||F.d.LastCreatedScene,u);G&&(B.name=G),k(B)}else B("Unable to load the ShaderMaterial")})),x.open("GET",A),x.send()}))}static async ParseFromSnippetAsync(G,A){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((u,k)=>{const B=new h.c;B.addEventListener("readystatechange",(()=>{if(4==B.readyState)if(200==B.status){const k=JSON.parse(JSON.parse(B.responseText).jsonPayload),x=JSON.parse(k.shaderMaterial),s=this.Parse(x,A||F.d.LastCreatedScene,j);s.snippetId=G,u(s)}else k("Unable to load the snippet "+G)})),B.open("GET",this.SnippetUrl+"/"+G.replace(/#/g,"/")),B.send()}))}}C.SnippetUrl="https://snippet.babylonjs.com",C.CreateFromSnippetAsync=C.ParseFromSnippetAsync,(0,O.h)("BABYLON.ShaderMaterial",C)}}]);