"use strict";(self.c2c3ycupenc=self.c2c3ycupenc||[]).push([[22],{11915:(c,r,D)=>{D.r(r),D.d(r,{ShaderMaterial:()=>w});var W=D(11717),B=D(11924),t=D(11683),u=D(11750),a=D(11656),H=D(11637),x=D(12003),M=D(11532),E=D(12008),m=D(11538),Y=D(12050),v=D(12048);const k={effect:null,subMesh:null};class w extends E.e{constructor(c,r,D){let W=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(c,r,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new t.Matrix,this._cachedWorldViewProjectionMatrix=new t.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=D,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...W}}get shaderPath(){return this._shaderPath}set shaderPath(c){this._shaderPath=c}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(c){-1===this._options.uniforms.indexOf(c)&&this._options.uniforms.push(c)}setTexture(c,r){return-1===this._options.samplers.indexOf(c)&&this._options.samplers.push(c),this._textures[c]=r,this}removeTexture(c){delete this._textures[c]}setTextureArray(c,r){return-1===this._options.samplers.indexOf(c)&&this._options.samplers.push(c),this._checkUniform(c),this._textureArrays[c]=r,this}setExternalTexture(c,r){return-1===this._options.externalTextures.indexOf(c)&&this._options.externalTextures.push(c),this._externalTextures[c]=r,this}setFloat(c,r){return this._checkUniform(c),this._floats[c]=r,this}setInt(c,r){return this._checkUniform(c),this._ints[c]=r,this}setUInt(c,r){return this._checkUniform(c),this._uints[c]=r,this}setFloats(c,r){return this._checkUniform(c),this._floatsArrays[c]=r,this}setColor3(c,r){return this._checkUniform(c),this._colors3[c]=r,this}setColor3Array(c,r){return this._checkUniform(c),this._colors3Arrays[c]=r.reduce(((c,r)=>(c.push(r.r,r.g,r.b),c)),[]),this}setColor4(c,r){return this._checkUniform(c),this._colors4[c]=r,this}setColor4Array(c,r){return this._checkUniform(c),this._colors4Arrays[c]=r.reduce(((c,r)=>(c.push(r.r,r.g,r.b,r.a),c)),[]),this}setVector2(c,r){return this._checkUniform(c),this._vectors2[c]=r,this}setVector3(c,r){return this._checkUniform(c),this._vectors3[c]=r,this}setVector4(c,r){return this._checkUniform(c),this._vectors4[c]=r,this}setQuaternion(c,r){return this._checkUniform(c),this._quaternions[c]=r,this}setQuaternionArray(c,r){return this._checkUniform(c),this._quaternionsArrays[c]=r.reduce(((c,r)=>(r.toArray(c,c.length),c)),[]),this}setMatrix(c,r){return this._checkUniform(c),this._matrices[c]=r,this}setMatrices(c,r){this._checkUniform(c);const D=new Float32Array(16*r.length);for(let W=0;W<r.length;W++){r[W].copyToArray(D,16*W)}return this._matrixArrays[c]=D,this}setMatrix3x3(c,r){return this._checkUniform(c),this._matrices3x3[c]=r,this}setMatrix2x2(c,r){return this._checkUniform(c),this._matrices2x2[c]=r,this}setArray2(c,r){return this._checkUniform(c),this._vectors2Arrays[c]=r,this}setArray3(c,r){return this._checkUniform(c),this._vectors3Arrays[c]=r,this}setArray4(c,r){return this._checkUniform(c),this._vectors4Arrays[c]=r,this}setUniformBuffer(c,r){return-1===this._options.uniformBuffers.indexOf(c)&&this._options.uniformBuffers.push(c),this._uniformBuffers[c]=r,this}setTextureSampler(c,r){return-1===this._options.samplerObjects.indexOf(c)&&this._options.samplerObjects.push(c),this._textureSamplers[c]=r,this}setStorageBuffer(c,r){return-1===this._options.storageBuffers.indexOf(c)&&this._options.storageBuffers.push(c),this._storageBuffers[c]=r,this}setDefine(c,r){const D=c.trimEnd()+" ",W=this.options.defines.findIndex((r=>r===c||r.startsWith(D)));return W>=0&&this.options.defines.splice(W,1),("boolean"!==typeof r||r)&&this.options.defines.push(D+r),this}isReadyForSubMesh(c,r,D){return this.isReady(c,D,r)}isReady(c,r,D){var W;const t=D&&this._storeEffectOnSubMeshes;if(this.isFrozen){const c=t?D._drawWrapper:this._drawWrapper;if(c.effect&&c._wasPreviouslyReady&&c._wasPreviouslyUsingInstances===r)return!0}const a=this.yc(),H=a.getEngine(),M=[],E=[];let m=null,w=this._shaderPath,Z=this._options.uniforms,J=this._options.uniformBuffers,q=this._options.samplers;H.getCaps().multiview&&a.activeCamera&&a.activeCamera.outputRenderTarget&&a.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,M.push("#define MULTIVIEW"),-1!==Z.indexOf("viewProjection")&&-1===Z.indexOf("viewProjectionR")&&Z.push("viewProjectionR"));for(let B=0;B<this._options.defines.length;B++){const c=0===this._options.defines[B].indexOf("#define")?this._options.defines[B]:`#define ${this._options.defines[B]}`;M.push(c)}for(let B=0;B<this._options.attributes.length;B++)E.push(this._options.attributes[B]);if(c&&c.isVerticesDataPresent(u.d.ColorKind)&&(-1===E.indexOf(u.d.ColorKind)&&E.push(u.d.ColorKind),M.push("#define VERTEXCOLOR")),r&&(M.push("#define INSTANCES"),(0,v.V)(E,this._materialHelperNeedsPreviousMatrices),null!==c&&void 0!==c&&c.hasThinInstances&&(M.push("#define THIN_INSTANCES"),c&&c.isVerticesDataPresent(u.d.ColorInstanceKind)&&(E.push(u.d.ColorInstanceKind),M.push("#define INSTANCESCOLOR")))),c&&c.useBones&&c.computeBonesUsingShaders&&c.skeleton){E.push(u.d.MatricesIndicesKind),E.push(u.d.MatricesWeightsKind),c.numBoneInfluencers>4&&(E.push(u.d.MatricesIndicesExtraKind),E.push(u.d.MatricesWeightsExtraKind));const r=c.skeleton;M.push("#define NUM_BONE_INFLUENCERS "+c.numBoneInfluencers),m=new x.c,m.addCPUSkinningFallback(0,c),r.isUsingTextureForMatrices?(M.push("#define BONETEXTURE"),-1===Z.indexOf("boneTextureWidth")&&Z.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(M.push("#define BonesPerMesh "+(r.bones.length+1)),-1===Z.indexOf("mBones")&&Z.push("mBones"))}else M.push("#define NUM_BONE_INFLUENCERS 0");let j=0;const X=c?c.morphTargetManager:null;if(X){const r=-1!==M.indexOf("#define UV1"),D=-1!==M.indexOf("#define UV2"),W=-1!==M.indexOf("#define TANGENT"),B=-1!==M.indexOf("#define NORMAL"),t=-1!==M.indexOf("#define VERTEXCOLOR");j=(0,v.G)(X,M,E,c,!0,B,W,r,D,t),X.isUsingTextureForTargets&&(-1===Z.indexOf("morphTargetTextureIndices")&&Z.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),j>0&&(Z=Z.slice(),Z.push("morphTargetInfluences"),Z.push("morphTargetCount"),Z.push("morphTargetTextureInfo"),Z.push("morphTargetTextureIndices"))}else M.push("#define NUM_MORPH_INFLUENCERS 0");if(c){const r=c.bakedVertexAnimationManager;r&&r.isEnabled&&(M.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===Z.indexOf("bakedVertexAnimationSettings")&&Z.push("bakedVertexAnimationSettings"),-1===Z.indexOf("bakedVertexAnimationTextureSizeInverted")&&Z.push("bakedVertexAnimationTextureSizeInverted"),-1===Z.indexOf("bakedVertexAnimationTime")&&Z.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,v.t)(E,c,M)}for(const B in this._textures)if(!this._textures[B].isReady())return!1;c&&this.needAlphaTestingForMesh(c)&&M.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,Y.c)(Z),(0,Y.j)(this,a,M)),a.fogEnabled&&null!==c&&void 0!==c&&c.applyFog&&a.fogMode!==B.b.FOGMODE_NONE&&(M.push("#define FOG"),-1===Z.indexOf("view")&&Z.push("view"),-1===Z.indexOf("vFogInfos")&&Z.push("vFogInfos"),-1===Z.indexOf("vFogColor")&&Z.push("vFogColor")),this._useLogarithmicDepth&&(M.push("#define LOGARITHMICDEPTH"),-1===Z.indexOf("logarithmicDepthConstant")&&Z.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(Z=Z.slice(),J=J.slice(),q=q.slice(),w=this.customShaderNameResolve(this.name,Z,J,q,M,E));const e=t?D._getDrawWrapper(void 0,!0):this._drawWrapper,y=(null===e||void 0===e?void 0:e.effect)??null,U=(null===e||void 0===e?void 0:e.defines)??null,N=M.join("\n");let g=y;return U!==N&&(g=H.createEffect(w,{attributes:E,uniformsNames:Z,uniformBuffersNames:J,samplers:q,defines:N,fallbacks:m,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:j},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},H),t?D.setEffect(g,N,this._materialContext):e&&e.setEffect(g,N),this._onEffectCreatedObservable&&(k.effect=g,k.subMesh=D??(null===c||void 0===c?void 0:c.xa[0])??null,this._onEffectCreatedObservable.notifyObservers(k))),e._wasPreviouslyUsingInstances=!!r,!(null===(W=g)||void 0===W||!W.isReady())&&(y!==g&&a.resetCachedMaterial(),e._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(c,r){const D=r??this.getEffect();if(!D)return;const W=this._options.uniforms;-1!==W.indexOf("world")&&D.setMatrix("world",c);const B=this.yc();-1!==W.indexOf("worldView")&&(c.multiplyToRef(B.getViewMatrix(),this._cachedWorldViewMatrix),D.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==W.indexOf("worldViewProjection")&&(c.multiplyToRef(B.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),D.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==W.indexOf("view")&&D.setMatrix("view",B.getViewMatrix())}bindForSubMesh(c,r,D){var W;this.bind(c,r,null===(W=D._drawWrapperOverride)||void 0===W?void 0:W.effect,D)}bind(c,r,D,W){const B=W&&this._storeEffectOnSubMeshes,t=D??(B?W.effect:this.getEffect());if(!t)return;const u=this.yc();this._activeEffect=t,this.bindOnlyWorldMatrix(c,D);const a=this._options.uniformBuffers;let H=!1;if(t&&a&&a.length>0&&u.getEngine().supportsUniformBuffers)for(let E=0;E<a.length;++E){switch(a[E]){case"Mesh":r&&(r.getMeshUniformBuffer().bindToEffect(t,"Mesh"),r.transferToEffect(c));break;case"Scene":(0,v.o)(t,u.getSceneUniformBuffer()),u.finalizeSceneUbo(),H=!0}}const x=r&&B?this._mustRebind(u,t,W,r.visibility):u.getCachedMaterial()!==this;if(t&&x){let c;for(c in H||-1===this._options.uniforms.indexOf("view")||t.setMatrix("view",u.getViewMatrix()),H||-1===this._options.uniforms.indexOf("projection")||t.setMatrix("projection",u.getProjectionMatrix()),H||-1===this._options.uniforms.indexOf("viewProjection")||(t.setMatrix("viewProjection",u.getTransformMatrix()),this._multiview&&t.setMatrix("viewProjectionR",u._transformMatrixR)),u.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&t.setVector3("cameraPosition",u.activeCamera.globalPosition),(0,v.b)(r,t),(0,Y.d)(t,this,u),this._useLogarithmicDepth&&(0,v.m)(B?W.materialDefines:t.defines,t,u),r&&(0,v.f)(u,r,t),this._textures)t.setTexture(c,this._textures[c]);for(c in this._textureArrays)t.setTextureArray(c,this._textureArrays[c]);for(c in this._ints)t.setInt(c,this._ints[c]);for(c in this._uints)t.setUInt(c,this._uints[c]);for(c in this._floats)t.setFloat(c,this._floats[c]);for(c in this._floatsArrays)t.setArray(c,this._floatsArrays[c]);for(c in this._colors3)t.setColor3(c,this._colors3[c]);for(c in this._colors3Arrays)t.setArray3(c,this._colors3Arrays[c]);for(c in this._colors4){const r=this._colors4[c];t.setFloat4(c,r.r,r.g,r.b,r.a)}for(c in this._colors4Arrays)t.setArray4(c,this._colors4Arrays[c]);for(c in this._vectors2)t.setVector2(c,this._vectors2[c]);for(c in this._vectors3)t.setVector3(c,this._vectors3[c]);for(c in this._vectors4)t.setVector4(c,this._vectors4[c]);for(c in this._quaternions)t.setQuaternion(c,this._quaternions[c]);for(c in this._matrices)t.setMatrix(c,this._matrices[c]);for(c in this._matrixArrays)t.setMatrices(c,this._matrixArrays[c]);for(c in this._matrices3x3)t.setMatrix3x3(c,this._matrices3x3[c]);for(c in this._matrices2x2)t.setMatrix2x2(c,this._matrices2x2[c]);for(c in this._vectors2Arrays)t.setArray2(c,this._vectors2Arrays[c]);for(c in this._vectors3Arrays)t.setArray3(c,this._vectors3Arrays[c]);for(c in this._vectors4Arrays)t.setArray4(c,this._vectors4Arrays[c]);for(c in this._quaternionsArrays)t.setArray4(c,this._quaternionsArrays[c]);for(c in this._uniformBuffers){const r=this._uniformBuffers[c].getBuffer();r&&t.bindUniformBuffer(r,c)}const D=u.getEngine(),a=D.setExternalTexture;if(a)for(c in this._externalTextures)a.call(D,c,this._externalTextures[c]);const x=D.setTextureSampler;if(x)for(c in this._textureSamplers)x.call(D,c,this._textureSamplers[c]);const M=D.setStorageBuffer;if(M)for(c in this._storageBuffers)M.call(D,c,this._storageBuffers[c])}if(t&&r&&(x||!this.isFrozen)){(0,v.n)(r,t),r.morphTargetManager&&r.morphTargetManager.isUsingTextureForTargets&&r.morphTargetManager._bind(t);const c=r.bakedVertexAnimationManager;if(c&&c.isEnabled){var M;const c=B?W._drawWrapper:this._drawWrapper;null===(M=r.bakedVertexAnimationManager)||void 0===M||M.bind(t,!!c._wasPreviouslyUsingInstances)}}this._afterBind(r,t,W)}getActiveTextures(){const c=super.getActiveTextures();for(const r in this._textures)c.push(this._textures[r]);for(const r in this._textureArrays){const D=this._textureArrays[r];for(let r=0;r<D.length;r++)c.push(D[r])}return c}hasTexture(c){if(super.hasTexture(c))return!0;for(const r in this._textures)if(this._textures[r]===c)return!0;for(const r in this._textureArrays){const D=this._textureArrays[r];for(let r=0;r<D.length;r++)if(D[r]===c)return!0}return!1}clone(c){const r=W.d.Clone((()=>new w(c,this.yc(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);r.name=c,r.id=c,"object"===typeof r._shaderPath&&(r._shaderPath={...r._shaderPath}),this._options={...this._options};const D=Object.keys(this._options);for(const W of D){const c=this._options[W];Array.isArray(c)&&(this._options[W]=c.slice(0))}this.stencil.copyTo(r.stencil);for(const W in this._textures)r.setTexture(W,this._textures[W]);for(const W in this._textureArrays)r.setTextureArray(W,this._textureArrays[W]);for(const W in this._externalTextures)r.setExternalTexture(W,this._externalTextures[W]);for(const W in this._ints)r.setInt(W,this._ints[W]);for(const W in this._uints)r.setUInt(W,this._uints[W]);for(const W in this._floats)r.setFloat(W,this._floats[W]);for(const W in this._floatsArrays)r.setFloats(W,this._floatsArrays[W]);for(const W in this._colors3)r.setColor3(W,this._colors3[W]);for(const W in this._colors3Arrays)r._colors3Arrays[W]=this._colors3Arrays[W];for(const W in this._colors4)r.setColor4(W,this._colors4[W]);for(const W in this._colors4Arrays)r._colors4Arrays[W]=this._colors4Arrays[W];for(const W in this._vectors2)r.setVector2(W,this._vectors2[W]);for(const W in this._vectors3)r.setVector3(W,this._vectors3[W]);for(const W in this._vectors4)r.setVector4(W,this._vectors4[W]);for(const W in this._quaternions)r.setQuaternion(W,this._quaternions[W]);for(const W in this._quaternionsArrays)r._quaternionsArrays[W]=this._quaternionsArrays[W];for(const W in this._matrices)r.setMatrix(W,this._matrices[W]);for(const W in this._matrixArrays)r._matrixArrays[W]=this._matrixArrays[W].slice();for(const W in this._matrices3x3)r.setMatrix3x3(W,this._matrices3x3[W]);for(const W in this._matrices2x2)r.setMatrix2x2(W,this._matrices2x2[W]);for(const W in this._vectors2Arrays)r.setArray2(W,this._vectors2Arrays[W]);for(const W in this._vectors3Arrays)r.setArray3(W,this._vectors3Arrays[W]);for(const W in this._vectors4Arrays)r.setArray4(W,this._vectors4Arrays[W]);for(const W in this._uniformBuffers)r.setUniformBuffer(W,this._uniformBuffers[W]);for(const W in this._textureSamplers)r.setTextureSampler(W,this._textureSamplers[W]);for(const W in this._storageBuffers)r.setStorageBuffer(W,this._storageBuffers[W]);return r}dispose(c,r,D){if(r){let c;for(c in this._textures)this._textures[c].dispose();for(c in this._textureArrays){const r=this._textureArrays[c];for(let c=0;c<r.length;c++)r[c].dispose()}}this._textures={},super.dispose(c,r,D)}serialize(){const c=W.d.Serialize(this);let r;for(r in c.customType="BABYLON.ShaderMaterial",c.uniqueId=this.uniqueId,c.options=this._options,c.shaderPath=this._shaderPath,c.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,c.stencil=this.stencil.serialize(),c.textures={},this._textures)c.textures[r]=this._textures[r].serialize();for(r in c.textureArrays={},this._textureArrays){c.textureArrays[r]=[];const D=this._textureArrays[r];for(let W=0;W<D.length;W++)c.textureArrays[r].push(D[W].serialize())}for(r in c.ints={},this._ints)c.ints[r]=this._ints[r];for(r in c.uints={},this._uints)c.uints[r]=this._uints[r];for(r in c.floats={},this._floats)c.floats[r]=this._floats[r];for(r in c.floatsArrays={},this._floatsArrays)c.floatsArrays[r]=this._floatsArrays[r];for(r in c.colors3={},this._colors3){const D=this._colors3[r];c.colors3[r]=[D.r,D.g,D.b]}for(r in c.colors3Arrays={},this._colors3Arrays)c.colors3Arrays[r]=this._colors3Arrays[r];for(r in c.colors4={},this._colors4){const D=this._colors4[r];c.colors4[r]=[D.r,D.g,D.b,D.a]}for(r in c.colors4Arrays={},this._colors4Arrays)c.colors4Arrays[r]=this._colors4Arrays[r];for(r in c.vectors2={},this._vectors2){const D=this._vectors2[r];c.vectors2[r]=[D.x,D.y]}for(r in c.vectors3={},this._vectors3){const D=this._vectors3[r];c.vectors3[r]=[D.x,D.y,D.z]}for(r in c.vectors4={},this._vectors4){const D=this._vectors4[r];c.vectors4[r]=[D.x,D.y,D.z,D.w]}for(r in c.quaternions={},this._quaternions)c.quaternions[r]=this._quaternions[r].Ma();for(r in c.matrices={},this._matrices)c.matrices[r]=this._matrices[r].Ma();for(r in c.matrixArray={},this._matrixArrays)c.matrixArray[r]=this._matrixArrays[r];for(r in c.matrices3x3={},this._matrices3x3)c.matrices3x3[r]=this._matrices3x3[r];for(r in c.matrices2x2={},this._matrices2x2)c.matrices2x2[r]=this._matrices2x2[r];for(r in c.vectors2Arrays={},this._vectors2Arrays)c.vectors2Arrays[r]=this._vectors2Arrays[r];for(r in c.vectors3Arrays={},this._vectors3Arrays)c.vectors3Arrays[r]=this._vectors3Arrays[r];for(r in c.vectors4Arrays={},this._vectors4Arrays)c.vectors4Arrays[r]=this._vectors4Arrays[r];for(r in c.quaternionsArrays={},this._quaternionsArrays)c.quaternionsArrays[r]=this._quaternionsArrays[r];return c}static Parse(c,r,D){const B=W.d.Parse((()=>new w(c.name,r,c.shaderPath,c.options,c.storeEffectOnSubMeshes)),c,r,D);let u;for(u in c.stencil&&B.stencil.parse(c.stencil,r,D),c.textures)B.setTexture(u,a.b.Parse(c.textures[u],r,D));for(u in c.textureArrays){const W=c.textureArrays[u],t=[];for(let c=0;c<W.length;c++)t.push(a.b.Parse(W[c],r,D));B.setTextureArray(u,t)}for(u in c.ints)B.setInt(u,c.ints[u]);for(u in c.uints)B.setUInt(u,c.uints[u]);for(u in c.floats)B.setFloat(u,c.floats[u]);for(u in c.floatsArrays)B.setFloats(u,c.floatsArrays[u]);for(u in c.colors3){const r=c.colors3[u];B.setColor3(u,{r:r[0],g:r[1],b:r[2]})}for(u in c.colors3Arrays){const r=c.colors3Arrays[u].reduce(((c,r,D)=>(D%3===0?c.push([r]):c[c.length-1].push(r),c)),[]).map((c=>({r:c[0],g:c[1],b:c[2]})));B.setColor3Array(u,r)}for(u in c.colors4){const r=c.colors4[u];B.setColor4(u,{r:r[0],g:r[1],b:r[2],a:r[3]})}for(u in c.colors4Arrays){const r=c.colors4Arrays[u].reduce(((c,r,D)=>(D%4===0?c.push([r]):c[c.length-1].push(r),c)),[]).map((c=>({r:c[0],g:c[1],b:c[2],a:c[3]})));B.setColor4Array(u,r)}for(u in c.vectors2){const r=c.vectors2[u];B.setVector2(u,{x:r[0],y:r[1]})}for(u in c.vectors3){const r=c.vectors3[u];B.setVector3(u,{x:r[0],y:r[1],z:r[2]})}for(u in c.vectors4){const r=c.vectors4[u];B.setVector4(u,{x:r[0],y:r[1],z:r[2],w:r[3]})}for(u in c.quaternions)B.setQuaternion(u,t.Quaternion.er(c.quaternions[u]));for(u in c.matrices)B.setMatrix(u,t.Matrix.er(c.matrices[u]));for(u in c.matrixArray)B._matrixArrays[u]=new Float32Array(c.matrixArray[u]);for(u in c.matrices3x3)B.setMatrix3x3(u,c.matrices3x3[u]);for(u in c.matrices2x2)B.setMatrix2x2(u,c.matrices2x2[u]);for(u in c.vectors2Arrays)B.setArray2(u,c.vectors2Arrays[u]);for(u in c.vectors3Arrays)B.setArray3(u,c.vectors3Arrays[u]);for(u in c.vectors4Arrays)B.setArray4(u,c.vectors4Arrays[u]);for(u in c.quaternionsArrays)B.setArray4(u,c.quaternionsArrays[u]);return B}static async ParseFromFileAsync(c,r,D){let W=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((B,t)=>{const u=new M.d;u.addEventListener("readystatechange",(()=>{if(4==u.readyState)if(200==u.status){const r=JSON.parse(u.responseText),t=this.Parse(r,D||m.c.LastCreatedScene,W);c&&(t.name=c),B(t)}else t("Unable to load the ShaderMaterial")})),u.open("GET",r),u.send()}))}static async ParseFromSnippetAsync(c,r){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((W,B)=>{const t=new M.d;t.addEventListener("readystatechange",(()=>{if(4==t.readyState)if(200==t.status){const B=JSON.parse(JSON.parse(t.responseText).jsonPayload),u=JSON.parse(B.shaderMaterial),a=this.Parse(u,r||m.c.LastCreatedScene,D);a.snippetId=c,W(a)}else B("Unable to load the snippet "+c)})),t.open("GET",this.SnippetUrl+"/"+c.replace(/#/g,"/")),t.send()}))}}w.SnippetUrl="https://snippet.babylonjs.com",w.CreateFromSnippetAsync=w.ParseFromSnippetAsync,(0,H.e)("BABYLON.ShaderMaterial",w)}}]);