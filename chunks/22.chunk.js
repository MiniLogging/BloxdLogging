"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[22],{13106:(Y,c,h)=>{h.r(c),h.d(c,{ShaderMaterial:()=>y});var C=h(12906),E=h(13110),N=h(12869),Q=h(12951),b=h(12848),H=h(12825),w=h(13182),W=h(12719),q=h(13189),k=h(12722),M=h(13245),p=h(13240);const P={effect:null,subMesh:null};class y extends q.d{constructor(Y,c,h){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(Y,c,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new N.Matrix,this._cachedWorldViewProjectionMatrix=new N.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=h,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...C}}get shaderPath(){return this._shaderPath}set shaderPath(Y){this._shaderPath=Y}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(Y){-1===this._options.uniforms.indexOf(Y)&&this._options.uniforms.push(Y)}setTexture(Y,c){return-1===this._options.samplers.indexOf(Y)&&this._options.samplers.push(Y),this._textures[Y]=c,this}removeTexture(Y){delete this._textures[Y]}setTextureArray(Y,c){return-1===this._options.samplers.indexOf(Y)&&this._options.samplers.push(Y),this._checkUniform(Y),this._textureArrays[Y]=c,this}setExternalTexture(Y,c){return-1===this._options.externalTextures.indexOf(Y)&&this._options.externalTextures.push(Y),this._externalTextures[Y]=c,this}setFloat(Y,c){return this._checkUniform(Y),this._floats[Y]=c,this}setInt(Y,c){return this._checkUniform(Y),this._ints[Y]=c,this}setUInt(Y,c){return this._checkUniform(Y),this._uints[Y]=c,this}setFloats(Y,c){return this._checkUniform(Y),this._floatsArrays[Y]=c,this}setColor3(Y,c){return this._checkUniform(Y),this._colors3[Y]=c,this}setColor3Array(Y,c){return this._checkUniform(Y),this._colors3Arrays[Y]=c.reduce(((Y,c)=>(Y.push(c.r,c.g,c.b),Y)),[]),this}setColor4(Y,c){return this._checkUniform(Y),this._colors4[Y]=c,this}setColor4Array(Y,c){return this._checkUniform(Y),this._colors4Arrays[Y]=c.reduce(((Y,c)=>(Y.push(c.r,c.g,c.b,c.a),Y)),[]),this}setVector2(Y,c){return this._checkUniform(Y),this._vectors2[Y]=c,this}setVector3(Y,c){return this._checkUniform(Y),this._vectors3[Y]=c,this}setVector4(Y,c){return this._checkUniform(Y),this._vectors4[Y]=c,this}setQuaternion(Y,c){return this._checkUniform(Y),this._quaternions[Y]=c,this}setQuaternionArray(Y,c){return this._checkUniform(Y),this._quaternionsArrays[Y]=c.reduce(((Y,c)=>(c.toArray(Y,Y.length),Y)),[]),this}setMatrix(Y,c){return this._checkUniform(Y),this._matrices[Y]=c,this}setMatrices(Y,c){this._checkUniform(Y);const h=new Float32Array(16*c.length);for(let C=0;C<c.length;C++){c[C].copyToArray(h,16*C)}return this._matrixArrays[Y]=h,this}setMatrix3x3(Y,c){return this._checkUniform(Y),this._matrices3x3[Y]=c,this}setMatrix2x2(Y,c){return this._checkUniform(Y),this._matrices2x2[Y]=c,this}setArray2(Y,c){return this._checkUniform(Y),this._vectors2Arrays[Y]=c,this}setArray3(Y,c){return this._checkUniform(Y),this._vectors3Arrays[Y]=c,this}setArray4(Y,c){return this._checkUniform(Y),this._vectors4Arrays[Y]=c,this}setUniformBuffer(Y,c){return-1===this._options.uniformBuffers.indexOf(Y)&&this._options.uniformBuffers.push(Y),this._uniformBuffers[Y]=c,this}setTextureSampler(Y,c){return-1===this._options.samplerObjects.indexOf(Y)&&this._options.samplerObjects.push(Y),this._textureSamplers[Y]=c,this}setStorageBuffer(Y,c){return-1===this._options.storageBuffers.indexOf(Y)&&this._options.storageBuffers.push(Y),this._storageBuffers[Y]=c,this}setDefine(Y,c){const h=Y.trimEnd()+" ",C=this.options.defines.findIndex((c=>c===Y||c.startsWith(h)));return C>=0&&this.options.defines.splice(C,1),("boolean"!==typeof c||c)&&this.options.defines.push(h+c),this}isReadyForSubMesh(Y,c,h){return this.isReady(Y,h,c)}isReady(Y,c,h){var C;const N=h&&this._storeEffectOnSubMeshes;if(this.isFrozen){const Y=N?h._drawWrapper:this._drawWrapper;if(Y.effect&&Y._wasPreviouslyReady&&Y._wasPreviouslyUsingInstances===c)return!0}const b=this.ZY(),H=b.getEngine(),W=[],q=[];let k=null,y=this._shaderPath,d=this._options.uniforms,D=this._options.uniformBuffers,T=this._options.samplers;H.getCaps().multiview&&b.activeCamera&&b.activeCamera.outputRenderTarget&&b.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,W.push("#define MULTIVIEW"),-1!==d.indexOf("viewProjection")&&-1===d.indexOf("viewProjectionR")&&d.push("viewProjectionR"));for(let E=0;E<this._options.defines.length;E++){const Y=0===this._options.defines[E].indexOf("#define")?this._options.defines[E]:`#define ${this._options.defines[E]}`;W.push(Y)}for(let E=0;E<this._options.attributes.length;E++)q.push(this._options.attributes[E]);if(Y&&Y.isVerticesDataPresent(Q.f.ColorKind)&&(-1===q.indexOf(Q.f.ColorKind)&&q.push(Q.f.ColorKind),W.push("#define VERTEXCOLOR")),c&&(W.push("#define INSTANCES"),(0,p.nb)(q,this._materialHelperNeedsPreviousMatrices),null!==Y&&void 0!==Y&&Y.hasThinInstances&&(W.push("#define THIN_INSTANCES"),Y&&Y.isVerticesDataPresent(Q.f.ColorInstanceKind)&&(q.push(Q.f.ColorInstanceKind),W.push("#define INSTANCESCOLOR")))),Y&&Y.useBones&&Y.computeBonesUsingShaders&&Y.skeleton){q.push(Q.f.MatricesIndicesKind),q.push(Q.f.MatricesWeightsKind),Y.numBoneInfluencers>4&&(q.push(Q.f.MatricesIndicesExtraKind),q.push(Q.f.MatricesWeightsExtraKind));const c=Y.skeleton;W.push("#define NUM_BONE_INFLUENCERS "+Y.numBoneInfluencers),k=new w.c,k.addCPUSkinningFallback(0,Y),c.isUsingTextureForMatrices?(W.push("#define BONETEXTURE"),-1===d.indexOf("boneTextureWidth")&&d.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(W.push("#define BonesPerMesh "+(c.bones.length+1)),-1===d.indexOf("mBones")&&d.push("mBones"))}else W.push("#define NUM_BONE_INFLUENCERS 0");let e=0;const r=Y?Y.morphTargetManager:null;if(r){const c=-1!==W.indexOf("#define UV1"),h=-1!==W.indexOf("#define UV2"),C=-1!==W.indexOf("#define TANGENT"),E=-1!==W.indexOf("#define NORMAL"),N=-1!==W.indexOf("#define VERTEXCOLOR");e=(0,p.N)(r,W,q,Y,!0,E,C,c,h,N),r.isUsingTextureForTargets&&(-1===d.indexOf("morphTargetTextureIndices")&&d.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),e>0&&(d=d.slice(),d.push("morphTargetInfluences"),d.push("morphTargetCount"),d.push("morphTargetTextureInfo"),d.push("morphTargetTextureIndices"))}else W.push("#define NUM_MORPH_INFLUENCERS 0");if(Y){const c=Y.bakedVertexAnimationManager;c&&c.isEnabled&&(W.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===d.indexOf("bakedVertexAnimationSettings")&&d.push("bakedVertexAnimationSettings"),-1===d.indexOf("bakedVertexAnimationTextureSizeInverted")&&d.push("bakedVertexAnimationTextureSizeInverted"),-1===d.indexOf("bakedVertexAnimationTime")&&d.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,p.B)(q,Y,W)}for(const E in this._textures)if(!this._textures[E].isReady())return!1;Y&&this.needAlphaTestingForMesh(Y)&&W.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,M.b)(d),(0,M.g)(this,b,W)),b.fogEnabled&&null!==Y&&void 0!==Y&&Y.applyFog&&b.fogMode!==E.e.FOGMODE_NONE&&(W.push("#define FOG"),-1===d.indexOf("view")&&d.push("view"),-1===d.indexOf("vFogInfos")&&d.push("vFogInfos"),-1===d.indexOf("vFogColor")&&d.push("vFogColor")),this._useLogarithmicDepth&&(W.push("#define LOGARITHMICDEPTH"),-1===d.indexOf("logarithmicDepthConstant")&&d.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(d=d.slice(),D=D.slice(),T=T.slice(),y=this.customShaderNameResolve(this.name,d,D,T,W,q));const X=N?h._getDrawWrapper(void 0,!0):this._drawWrapper,Z=(null===X||void 0===X?void 0:X.effect)??null,a=(null===X||void 0===X?void 0:X.defines)??null,G=W.join("\n");let K=Z;return a!==G&&(K=H.createEffect(y,{attributes:q,uniformsNames:d,uniformBuffersNames:D,samplers:T,defines:G,fallbacks:k,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:e},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},H),N?h.setEffect(K,G,this._materialContext):X&&X.setEffect(K,G),this._onEffectCreatedObservable&&(P.effect=K,P.subMesh=h??(null===Y||void 0===Y?void 0:Y.rc[0])??null,this._onEffectCreatedObservable.notifyObservers(P))),X._wasPreviouslyUsingInstances=!!c,!(null===(C=K)||void 0===C||!C.isReady())&&(Z!==K&&b.resetCachedMaterial(),X._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(Y,c){const h=c??this.getEffect();if(!h)return;const C=this._options.uniforms;-1!==C.indexOf("world")&&h.setMatrix("world",Y);const E=this.ZY();-1!==C.indexOf("worldView")&&(Y.multiplyToRef(E.getViewMatrix(),this._cachedWorldViewMatrix),h.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==C.indexOf("worldViewProjection")&&(Y.multiplyToRef(E.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),h.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==C.indexOf("view")&&h.setMatrix("view",E.getViewMatrix())}bindForSubMesh(Y,c,h){var C;this.bind(Y,c,null===(C=h._drawWrapperOverride)||void 0===C?void 0:C.effect,h)}bind(Y,c,h,C){const E=C&&this._storeEffectOnSubMeshes,N=h??(E?C.effect:this.getEffect());if(!N)return;const Q=this.ZY();this._activeEffect=N,this.bindOnlyWorldMatrix(Y,h);const b=this._options.uniformBuffers;let H=!1;if(N&&b&&b.length>0&&Q.getEngine().supportsUniformBuffers)for(let q=0;q<b.length;++q){switch(b[q]){case"Mesh":c&&(c.getMeshUniformBuffer().bindToEffect(N,"Mesh"),c.transferToEffect(Y));break;case"Scene":(0,p.t)(N,Q.getSceneUniformBuffer()),Q.finalizeSceneUbo(),H=!0}}const w=c&&E?this._mustRebind(Q,N,C,c.visibility):Q.getCachedMaterial()!==this;if(N&&w){let Y;for(Y in H||-1===this._options.uniforms.indexOf("view")||N.setMatrix("view",Q.getViewMatrix()),H||-1===this._options.uniforms.indexOf("projection")||N.setMatrix("projection",Q.getProjectionMatrix()),H||-1===this._options.uniforms.indexOf("viewProjection")||(N.setMatrix("viewProjection",Q.getTransformMatrix()),this._multiview&&N.setMatrix("viewProjectionR",Q._transformMatrixR)),Q.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&N.setVector3("cameraPosition",Q.activeCamera.globalPosition),(0,p.e)(c,N),(0,M.c)(N,this,Q),this._useLogarithmicDepth&&(0,p.n)(E?C.materialDefines:N.defines,N,Q),c&&(0,p.f)(Q,c,N),this._textures)N.setTexture(Y,this._textures[Y]);for(Y in this._textureArrays)N.setTextureArray(Y,this._textureArrays[Y]);for(Y in this._ints)N.setInt(Y,this._ints[Y]);for(Y in this._uints)N.setUInt(Y,this._uints[Y]);for(Y in this._floats)N.setFloat(Y,this._floats[Y]);for(Y in this._floatsArrays)N.setArray(Y,this._floatsArrays[Y]);for(Y in this._colors3)N.setColor3(Y,this._colors3[Y]);for(Y in this._colors3Arrays)N.setArray3(Y,this._colors3Arrays[Y]);for(Y in this._colors4){const c=this._colors4[Y];N.setFloat4(Y,c.r,c.g,c.b,c.a)}for(Y in this._colors4Arrays)N.setArray4(Y,this._colors4Arrays[Y]);for(Y in this._vectors2)N.setVector2(Y,this._vectors2[Y]);for(Y in this._vectors3)N.setVector3(Y,this._vectors3[Y]);for(Y in this._vectors4)N.setVector4(Y,this._vectors4[Y]);for(Y in this._quaternions)N.setQuaternion(Y,this._quaternions[Y]);for(Y in this._matrices)N.setMatrix(Y,this._matrices[Y]);for(Y in this._matrixArrays)N.setMatrices(Y,this._matrixArrays[Y]);for(Y in this._matrices3x3)N.setMatrix3x3(Y,this._matrices3x3[Y]);for(Y in this._matrices2x2)N.setMatrix2x2(Y,this._matrices2x2[Y]);for(Y in this._vectors2Arrays)N.setArray2(Y,this._vectors2Arrays[Y]);for(Y in this._vectors3Arrays)N.setArray3(Y,this._vectors3Arrays[Y]);for(Y in this._vectors4Arrays)N.setArray4(Y,this._vectors4Arrays[Y]);for(Y in this._quaternionsArrays)N.setArray4(Y,this._quaternionsArrays[Y]);for(Y in this._uniformBuffers){const c=this._uniformBuffers[Y].getBuffer();c&&N.bindUniformBuffer(c,Y)}const h=Q.getEngine(),b=h.setExternalTexture;if(b)for(Y in this._externalTextures)b.call(h,Y,this._externalTextures[Y]);const w=h.setTextureSampler;if(w)for(Y in this._textureSamplers)w.call(h,Y,this._textureSamplers[Y]);const W=h.setStorageBuffer;if(W)for(Y in this._storageBuffers)W.call(h,Y,this._storageBuffers[Y])}if(N&&c&&(w||!this.isFrozen)){(0,p.q)(c,N),c.morphTargetManager&&c.morphTargetManager.isUsingTextureForTargets&&c.morphTargetManager._bind(N);const Y=c.bakedVertexAnimationManager;if(Y&&Y.isEnabled){var W;const Y=E?C._drawWrapper:this._drawWrapper;null===(W=c.bakedVertexAnimationManager)||void 0===W||W.bind(N,!!Y._wasPreviouslyUsingInstances)}}this._afterBind(c,N,C)}getActiveTextures(){const Y=super.getActiveTextures();for(const c in this._textures)Y.push(this._textures[c]);for(const c in this._textureArrays){const h=this._textureArrays[c];for(let c=0;c<h.length;c++)Y.push(h[c])}return Y}hasTexture(Y){if(super.hasTexture(Y))return!0;for(const c in this._textures)if(this._textures[c]===Y)return!0;for(const c in this._textureArrays){const h=this._textureArrays[c];for(let c=0;c<h.length;c++)if(h[c]===Y)return!0}return!1}clone(Y){const c=C.d.Clone((()=>new y(Y,this.ZY(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);c.name=Y,c.id=Y,"object"===typeof c._shaderPath&&(c._shaderPath={...c._shaderPath}),this._options={...this._options};const h=Object.keys(this._options);for(const C of h){const Y=this._options[C];Array.isArray(Y)&&(this._options[C]=Y.slice(0))}this.Pc.copyTo(c.Pc);for(const C in this._textures)c.setTexture(C,this._textures[C]);for(const C in this._textureArrays)c.setTextureArray(C,this._textureArrays[C]);for(const C in this._externalTextures)c.setExternalTexture(C,this._externalTextures[C]);for(const C in this._ints)c.setInt(C,this._ints[C]);for(const C in this._uints)c.setUInt(C,this._uints[C]);for(const C in this._floats)c.setFloat(C,this._floats[C]);for(const C in this._floatsArrays)c.setFloats(C,this._floatsArrays[C]);for(const C in this._colors3)c.setColor3(C,this._colors3[C]);for(const C in this._colors3Arrays)c._colors3Arrays[C]=this._colors3Arrays[C];for(const C in this._colors4)c.setColor4(C,this._colors4[C]);for(const C in this._colors4Arrays)c._colors4Arrays[C]=this._colors4Arrays[C];for(const C in this._vectors2)c.setVector2(C,this._vectors2[C]);for(const C in this._vectors3)c.setVector3(C,this._vectors3[C]);for(const C in this._vectors4)c.setVector4(C,this._vectors4[C]);for(const C in this._quaternions)c.setQuaternion(C,this._quaternions[C]);for(const C in this._quaternionsArrays)c._quaternionsArrays[C]=this._quaternionsArrays[C];for(const C in this._matrices)c.setMatrix(C,this._matrices[C]);for(const C in this._matrixArrays)c._matrixArrays[C]=this._matrixArrays[C].slice();for(const C in this._matrices3x3)c.setMatrix3x3(C,this._matrices3x3[C]);for(const C in this._matrices2x2)c.setMatrix2x2(C,this._matrices2x2[C]);for(const C in this._vectors2Arrays)c.setArray2(C,this._vectors2Arrays[C]);for(const C in this._vectors3Arrays)c.setArray3(C,this._vectors3Arrays[C]);for(const C in this._vectors4Arrays)c.setArray4(C,this._vectors4Arrays[C]);for(const C in this._uniformBuffers)c.setUniformBuffer(C,this._uniformBuffers[C]);for(const C in this._textureSamplers)c.setTextureSampler(C,this._textureSamplers[C]);for(const C in this._storageBuffers)c.setStorageBuffer(C,this._storageBuffers[C]);return c}dispose(Y,c,h){if(c){let Y;for(Y in this._textures)this._textures[Y].dispose();for(Y in this._textureArrays){const c=this._textureArrays[Y];for(let Y=0;Y<c.length;Y++)c[Y].dispose()}}this._textures={},super.dispose(Y,c,h)}serialize(){const Y=C.d.Serialize(this);let c;for(c in Y.customType="BABYLON.ShaderMaterial",Y.uniqueId=this.uniqueId,Y.options=this._options,Y.shaderPath=this._shaderPath,Y.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,Y.Pc=this.Pc.serialize(),Y.textures={},this._textures)Y.textures[c]=this._textures[c].serialize();for(c in Y.textureArrays={},this._textureArrays){Y.textureArrays[c]=[];const h=this._textureArrays[c];for(let C=0;C<h.length;C++)Y.textureArrays[c].push(h[C].serialize())}for(c in Y.ints={},this._ints)Y.ints[c]=this._ints[c];for(c in Y.uints={},this._uints)Y.uints[c]=this._uints[c];for(c in Y.floats={},this._floats)Y.floats[c]=this._floats[c];for(c in Y.floatsArrays={},this._floatsArrays)Y.floatsArrays[c]=this._floatsArrays[c];for(c in Y.colors3={},this._colors3){const h=this._colors3[c];Y.colors3[c]=[h.r,h.g,h.b]}for(c in Y.colors3Arrays={},this._colors3Arrays)Y.colors3Arrays[c]=this._colors3Arrays[c];for(c in Y.colors4={},this._colors4){const h=this._colors4[c];Y.colors4[c]=[h.r,h.g,h.b,h.a]}for(c in Y.colors4Arrays={},this._colors4Arrays)Y.colors4Arrays[c]=this._colors4Arrays[c];for(c in Y.vectors2={},this._vectors2){const h=this._vectors2[c];Y.vectors2[c]=[h.x,h.y]}for(c in Y.vectors3={},this._vectors3){const h=this._vectors3[c];Y.vectors3[c]=[h.x,h.y,h.z]}for(c in Y.vectors4={},this._vectors4){const h=this._vectors4[c];Y.vectors4[c]=[h.x,h.y,h.z,h.w]}for(c in Y.quaternions={},this._quaternions)Y.quaternions[c]=this._quaternions[c].Xc();for(c in Y.matrices={},this._matrices)Y.matrices[c]=this._matrices[c].Xc();for(c in Y.matrixArray={},this._matrixArrays)Y.matrixArray[c]=this._matrixArrays[c];for(c in Y.matrices3x3={},this._matrices3x3)Y.matrices3x3[c]=this._matrices3x3[c];for(c in Y.matrices2x2={},this._matrices2x2)Y.matrices2x2[c]=this._matrices2x2[c];for(c in Y.vectors2Arrays={},this._vectors2Arrays)Y.vectors2Arrays[c]=this._vectors2Arrays[c];for(c in Y.vectors3Arrays={},this._vectors3Arrays)Y.vectors3Arrays[c]=this._vectors3Arrays[c];for(c in Y.vectors4Arrays={},this._vectors4Arrays)Y.vectors4Arrays[c]=this._vectors4Arrays[c];for(c in Y.quaternionsArrays={},this._quaternionsArrays)Y.quaternionsArrays[c]=this._quaternionsArrays[c];return Y}static Parse(Y,c,h){const E=C.d.Parse((()=>new y(Y.name,c,Y.shaderPath,Y.options,Y.storeEffectOnSubMeshes)),Y,c,h);let Q;for(Q in Y.Pc&&E.Pc.parse(Y.Pc,c,h),Y.textures)E.setTexture(Q,b.d.Parse(Y.textures[Q],c,h));for(Q in Y.textureArrays){const C=Y.textureArrays[Q],N=[];for(let Y=0;Y<C.length;Y++)N.push(b.d.Parse(C[Y],c,h));E.setTextureArray(Q,N)}for(Q in Y.ints)E.setInt(Q,Y.ints[Q]);for(Q in Y.uints)E.setUInt(Q,Y.uints[Q]);for(Q in Y.floats)E.setFloat(Q,Y.floats[Q]);for(Q in Y.floatsArrays)E.setFloats(Q,Y.floatsArrays[Q]);for(Q in Y.colors3){const c=Y.colors3[Q];E.setColor3(Q,{r:c[0],g:c[1],b:c[2]})}for(Q in Y.colors3Arrays){const c=Y.colors3Arrays[Q].reduce(((Y,c,h)=>(h%3===0?Y.push([c]):Y[Y.length-1].push(c),Y)),[]).map((Y=>({r:Y[0],g:Y[1],b:Y[2]})));E.setColor3Array(Q,c)}for(Q in Y.colors4){const c=Y.colors4[Q];E.setColor4(Q,{r:c[0],g:c[1],b:c[2],a:c[3]})}for(Q in Y.colors4Arrays){const c=Y.colors4Arrays[Q].reduce(((Y,c,h)=>(h%4===0?Y.push([c]):Y[Y.length-1].push(c),Y)),[]).map((Y=>({r:Y[0],g:Y[1],b:Y[2],a:Y[3]})));E.setColor4Array(Q,c)}for(Q in Y.vectors2){const c=Y.vectors2[Q];E.setVector2(Q,{x:c[0],y:c[1]})}for(Q in Y.vectors3){const c=Y.vectors3[Q];E.setVector3(Q,{x:c[0],y:c[1],z:c[2]})}for(Q in Y.vectors4){const c=Y.vectors4[Q];E.setVector4(Q,{x:c[0],y:c[1],z:c[2],w:c[3]})}for(Q in Y.quaternions)E.setQuaternion(Q,N.Quaternion.dh(Y.quaternions[Q]));for(Q in Y.matrices)E.setMatrix(Q,N.Matrix.dh(Y.matrices[Q]));for(Q in Y.matrixArray)E._matrixArrays[Q]=new Float32Array(Y.matrixArray[Q]);for(Q in Y.matrices3x3)E.setMatrix3x3(Q,Y.matrices3x3[Q]);for(Q in Y.matrices2x2)E.setMatrix2x2(Q,Y.matrices2x2[Q]);for(Q in Y.vectors2Arrays)E.setArray2(Q,Y.vectors2Arrays[Q]);for(Q in Y.vectors3Arrays)E.setArray3(Q,Y.vectors3Arrays[Q]);for(Q in Y.vectors4Arrays)E.setArray4(Q,Y.vectors4Arrays[Q]);for(Q in Y.quaternionsArrays)E.setArray4(Q,Y.quaternionsArrays[Q]);return E}static async ParseFromFileAsync(Y,c,h){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((E,N)=>{const Q=new W.c;Q.addEventListener("readystatechange",(()=>{if(4==Q.readyState)if(200==Q.status){const c=JSON.parse(Q.responseText),N=this.Parse(c,h||k.d.LastCreatedScene,C);Y&&(N.name=Y),E(N)}else N("Unable to load the ShaderMaterial")})),Q.open("GET",c),Q.send()}))}static async ParseFromSnippetAsync(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((C,E)=>{const N=new W.c;N.addEventListener("readystatechange",(()=>{if(4==N.readyState)if(200==N.status){const E=JSON.parse(JSON.parse(N.responseText).jsonPayload),Q=JSON.parse(E.shaderMaterial),b=this.Parse(Q,c||k.d.LastCreatedScene,h);b.snippetId=Y,C(b)}else E("Unable to load the snippet "+Y)})),N.open("GET",this.SnippetUrl+"/"+Y.replace(/#/g,"/")),N.send()}))}}y.SnippetUrl="https://snippet.babylonjs.com",y.CreateFromSnippetAsync=y.ParseFromSnippetAsync,(0,H.e)("BABYLON.ShaderMaterial",y)}}]);