"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[22],{11843:(F,P,f)=>{f.r(P),f.d(P,{ShaderMaterial:()=>L});var c=f(11677),N=f(11845),q=f(11639),H=f(11706),A=f(11612),o=f(11587),j=f(11926),i=f(11494),u=f(11931),T=f(11501),Y=f(11976),t=f(11973);const C={effect:null,subMesh:null};class L extends u.d{constructor(F,P,f){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(F,P,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new q.Matrix,this._cachedWorldViewProjectionMatrix=new q.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=f,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...c}}get shaderPath(){return this._shaderPath}set shaderPath(F){this._shaderPath=F}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(F){-1===this._options.uniforms.indexOf(F)&&this._options.uniforms.push(F)}setTexture(F,P){return-1===this._options.samplers.indexOf(F)&&this._options.samplers.push(F),this._textures[F]=P,this}removeTexture(F){delete this._textures[F]}setTextureArray(F,P){return-1===this._options.samplers.indexOf(F)&&this._options.samplers.push(F),this._checkUniform(F),this._textureArrays[F]=P,this}setExternalTexture(F,P){return-1===this._options.externalTextures.indexOf(F)&&this._options.externalTextures.push(F),this._externalTextures[F]=P,this}setFloat(F,P){return this._checkUniform(F),this._floats[F]=P,this}setInt(F,P){return this._checkUniform(F),this._ints[F]=P,this}setUInt(F,P){return this._checkUniform(F),this._uints[F]=P,this}setFloats(F,P){return this._checkUniform(F),this._floatsArrays[F]=P,this}setColor3(F,P){return this._checkUniform(F),this._colors3[F]=P,this}setColor3Array(F,P){return this._checkUniform(F),this._colors3Arrays[F]=P.reduce(((F,P)=>(F.push(P.r,P.g,P.b),F)),[]),this}setColor4(F,P){return this._checkUniform(F),this._colors4[F]=P,this}setColor4Array(F,P){return this._checkUniform(F),this._colors4Arrays[F]=P.reduce(((F,P)=>(F.push(P.r,P.g,P.b,P.a),F)),[]),this}setVector2(F,P){return this._checkUniform(F),this._vectors2[F]=P,this}setVector3(F,P){return this._checkUniform(F),this._vectors3[F]=P,this}setVector4(F,P){return this._checkUniform(F),this._vectors4[F]=P,this}setQuaternion(F,P){return this._checkUniform(F),this._quaternions[F]=P,this}setQuaternionArray(F,P){return this._checkUniform(F),this._quaternionsArrays[F]=P.reduce(((F,P)=>(P.toArray(F,F.length),F)),[]),this}setMatrix(F,P){return this._checkUniform(F),this._matrices[F]=P,this}setMatrices(F,P){this._checkUniform(F);const f=new Float32Array(16*P.length);for(let c=0;c<P.length;c++){P[c].copyToArray(f,16*c)}return this._matrixArrays[F]=f,this}setMatrix3x3(F,P){return this._checkUniform(F),this._matrices3x3[F]=P,this}setMatrix2x2(F,P){return this._checkUniform(F),this._matrices2x2[F]=P,this}setArray2(F,P){return this._checkUniform(F),this._vectors2Arrays[F]=P,this}setArray3(F,P){return this._checkUniform(F),this._vectors3Arrays[F]=P,this}setArray4(F,P){return this._checkUniform(F),this._vectors4Arrays[F]=P,this}setUniformBuffer(F,P){return-1===this._options.uniformBuffers.indexOf(F)&&this._options.uniformBuffers.push(F),this._uniformBuffers[F]=P,this}setTextureSampler(F,P){return-1===this._options.samplerObjects.indexOf(F)&&this._options.samplerObjects.push(F),this._textureSamplers[F]=P,this}setStorageBuffer(F,P){return-1===this._options.storageBuffers.indexOf(F)&&this._options.storageBuffers.push(F),this._storageBuffers[F]=P,this}setDefine(F,P){const f=F.trimEnd()+" ",c=this.options.defines.findIndex((P=>P===F||P.startsWith(f)));return c>=0&&this.options.defines.splice(c,1),("boolean"!==typeof P||P)&&this.options.defines.push(f+P),this}isReadyForSubMesh(F,P,f){return this.isReady(F,f,P)}isReady(F,P,f){var c;const q=f&&this._storeEffectOnSubMeshes;if(this.isFrozen){const F=q?f._drawWrapper:this._drawWrapper;if(F.effect&&F._wasPreviouslyReady&&F._wasPreviouslyUsingInstances===P)return!0}const A=this.OF(),o=A.getEngine(),i=[],u=[];let T=null,L=this._shaderPath,J=this._options.uniforms,B=this._options.uniformBuffers,z=this._options.samplers;o.getCaps().multiview&&A.activeCamera&&A.activeCamera.outputRenderTarget&&A.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,i.push("#define MULTIVIEW"),-1!==J.indexOf("viewProjection")&&-1===J.indexOf("viewProjectionR")&&J.push("viewProjectionR"));for(let N=0;N<this._options.defines.length;N++){const F=0===this._options.defines[N].indexOf("#define")?this._options.defines[N]:`#define ${this._options.defines[N]}`;i.push(F)}for(let N=0;N<this._options.attributes.length;N++)u.push(this._options.attributes[N]);if(F&&F.isVerticesDataPresent(H.f.ColorKind)&&(-1===u.indexOf(H.f.ColorKind)&&u.push(H.f.ColorKind),i.push("#define VERTEXCOLOR")),P&&(i.push("#define INSTANCES"),(0,t.ib)(u,this._materialHelperNeedsPreviousMatrices),null!==F&&void 0!==F&&F.hasThinInstances&&(i.push("#define THIN_INSTANCES"),F&&F.isVerticesDataPresent(H.f.ColorInstanceKind)&&(u.push(H.f.ColorInstanceKind),i.push("#define INSTANCESCOLOR")))),F&&F.useBones&&F.computeBonesUsingShaders&&F.skeleton){u.push(H.f.MatricesIndicesKind),u.push(H.f.MatricesWeightsKind),F.numBoneInfluencers>4&&(u.push(H.f.MatricesIndicesExtraKind),u.push(H.f.MatricesWeightsExtraKind));const P=F.skeleton;i.push("#define NUM_BONE_INFLUENCERS "+F.numBoneInfluencers),T=new j.c,T.addCPUSkinningFallback(0,F),P.isUsingTextureForMatrices?(i.push("#define BONETEXTURE"),-1===J.indexOf("boneTextureWidth")&&J.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(i.push("#define BonesPerMesh "+(P.bones.length+1)),-1===J.indexOf("mBones")&&J.push("mBones"))}else i.push("#define NUM_BONE_INFLUENCERS 0");let Z=0;const R=F?F.morphTargetManager:null;if(R){const P=-1!==i.indexOf("#define UV1"),f=-1!==i.indexOf("#define UV2"),c=-1!==i.indexOf("#define TANGENT"),N=-1!==i.indexOf("#define NORMAL"),q=-1!==i.indexOf("#define VERTEXCOLOR");Z=(0,t.O)(R,i,u,F,!0,N,c,P,f,q),R.isUsingTextureForTargets&&(-1===J.indexOf("morphTargetTextureIndices")&&J.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),Z>0&&(J=J.slice(),J.push("morphTargetInfluences"),J.push("morphTargetCount"),J.push("morphTargetTextureInfo"),J.push("morphTargetTextureIndices"))}else i.push("#define NUM_MORPH_INFLUENCERS 0");if(F){const P=F.bakedVertexAnimationManager;P&&P.isEnabled&&(i.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===J.indexOf("bakedVertexAnimationSettings")&&J.push("bakedVertexAnimationSettings"),-1===J.indexOf("bakedVertexAnimationTextureSizeInverted")&&J.push("bakedVertexAnimationTextureSizeInverted"),-1===J.indexOf("bakedVertexAnimationTime")&&J.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,t.D)(u,F,i)}for(const N in this._textures)if(!this._textures[N].isReady())return!1;F&&this.needAlphaTestingForMesh(F)&&i.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,Y.c)(J),(0,Y.l)(this,A,i)),A.fogEnabled&&null!==F&&void 0!==F&&F.applyFog&&A.fogMode!==N.e.FOGMODE_NONE&&(i.push("#define FOG"),-1===J.indexOf("view")&&J.push("view"),-1===J.indexOf("vFogInfos")&&J.push("vFogInfos"),-1===J.indexOf("vFogColor")&&J.push("vFogColor")),this._useLogarithmicDepth&&(i.push("#define LOGARITHMICDEPTH"),-1===J.indexOf("logarithmicDepthConstant")&&J.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(J=J.slice(),B=B.slice(),z=z.slice(),L=this.customShaderNameResolve(this.name,J,B,z,i,u));const y=q?f._getDrawWrapper(void 0,!0):this._drawWrapper,O=(null===y||void 0===y?void 0:y.effect)??null,d=(null===y||void 0===y?void 0:y.defines)??null,M=i.join("\n");let V=O;return d!==M&&(V=o.createEffect(L,{attributes:u,uniformsNames:J,uniformBuffersNames:B,samplers:z,defines:M,fallbacks:T,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:Z},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},o),q?f.setEffect(V,M,this._materialContext):y&&y.setEffect(V,M),this._onEffectCreatedObservable&&(C.effect=V,C.subMesh=f??(null===F||void 0===F?void 0:F.nf[0])??null,this._onEffectCreatedObservable.notifyObservers(C))),y._wasPreviouslyUsingInstances=!!P,!(null===(c=V)||void 0===c||!c.isReady())&&(O!==V&&A.resetCachedMaterial(),y._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(F,P){const f=P??this.getEffect();if(!f)return;const c=this._options.uniforms;-1!==c.indexOf("world")&&f.setMatrix("world",F);const N=this.OF();-1!==c.indexOf("worldView")&&(F.multiplyToRef(N.getViewMatrix(),this._cachedWorldViewMatrix),f.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==c.indexOf("worldViewProjection")&&(F.multiplyToRef(N.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),f.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==c.indexOf("view")&&f.setMatrix("view",N.getViewMatrix())}bindForSubMesh(F,P,f){var c;this.bind(F,P,null===(c=f._drawWrapperOverride)||void 0===c?void 0:c.effect,f)}bind(F,P,f,c){const N=c&&this._storeEffectOnSubMeshes,q=f??(N?c.effect:this.getEffect());if(!q)return;const H=this.OF();this._activeEffect=q,this.bindOnlyWorldMatrix(F,f);const A=this._options.uniformBuffers;let o=!1;if(q&&A&&A.length>0&&H.getEngine().supportsUniformBuffers)for(let u=0;u<A.length;++u){switch(A[u]){case"Mesh":P&&(P.getMeshUniformBuffer().bindToEffect(q,"Mesh"),P.transferToEffect(F));break;case"Scene":(0,t.s)(q,H.getSceneUniformBuffer()),H.finalizeSceneUbo(),o=!0}}const j=P&&N?this._mustRebind(H,q,c,P.visibility):H.getCachedMaterial()!==this;if(q&&j){let F;for(F in o||-1===this._options.uniforms.indexOf("view")||q.setMatrix("view",H.getViewMatrix()),o||-1===this._options.uniforms.indexOf("projection")||q.setMatrix("projection",H.getProjectionMatrix()),o||-1===this._options.uniforms.indexOf("viewProjection")||(q.setMatrix("viewProjection",H.getTransformMatrix()),this._multiview&&q.setMatrix("viewProjectionR",H._transformMatrixR)),H.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&q.setVector3("cameraPosition",H.activeCamera.globalPosition),(0,t.c)(P,q),(0,Y.d)(q,this,H),this._useLogarithmicDepth&&(0,t.n)(N?c.materialDefines:q.defines,q,H),P&&(0,t.f)(H,P,q),this._textures)q.setTexture(F,this._textures[F]);for(F in this._textureArrays)q.setTextureArray(F,this._textureArrays[F]);for(F in this._ints)q.setInt(F,this._ints[F]);for(F in this._uints)q.setUInt(F,this._uints[F]);for(F in this._floats)q.setFloat(F,this._floats[F]);for(F in this._floatsArrays)q.setArray(F,this._floatsArrays[F]);for(F in this._colors3)q.setColor3(F,this._colors3[F]);for(F in this._colors3Arrays)q.setArray3(F,this._colors3Arrays[F]);for(F in this._colors4){const P=this._colors4[F];q.setFloat4(F,P.r,P.g,P.b,P.a)}for(F in this._colors4Arrays)q.setArray4(F,this._colors4Arrays[F]);for(F in this._vectors2)q.setVector2(F,this._vectors2[F]);for(F in this._vectors3)q.setVector3(F,this._vectors3[F]);for(F in this._vectors4)q.setVector4(F,this._vectors4[F]);for(F in this._quaternions)q.setQuaternion(F,this._quaternions[F]);for(F in this._matrices)q.setMatrix(F,this._matrices[F]);for(F in this._matrixArrays)q.setMatrices(F,this._matrixArrays[F]);for(F in this._matrices3x3)q.setMatrix3x3(F,this._matrices3x3[F]);for(F in this._matrices2x2)q.setMatrix2x2(F,this._matrices2x2[F]);for(F in this._vectors2Arrays)q.setArray2(F,this._vectors2Arrays[F]);for(F in this._vectors3Arrays)q.setArray3(F,this._vectors3Arrays[F]);for(F in this._vectors4Arrays)q.setArray4(F,this._vectors4Arrays[F]);for(F in this._quaternionsArrays)q.setArray4(F,this._quaternionsArrays[F]);for(F in this._uniformBuffers){const P=this._uniformBuffers[F].getBuffer();P&&q.bindUniformBuffer(P,F)}const f=H.getEngine(),A=f.setExternalTexture;if(A)for(F in this._externalTextures)A.call(f,F,this._externalTextures[F]);const j=f.setTextureSampler;if(j)for(F in this._textureSamplers)j.call(f,F,this._textureSamplers[F]);const i=f.setStorageBuffer;if(i)for(F in this._storageBuffers)i.call(f,F,this._storageBuffers[F])}if(q&&P&&(j||!this.isFrozen)){(0,t.o)(P,q),P.morphTargetManager&&P.morphTargetManager.isUsingTextureForTargets&&P.morphTargetManager._bind(q);const F=P.bakedVertexAnimationManager;if(F&&F.isEnabled){var i;const F=N?c._drawWrapper:this._drawWrapper;null===(i=P.bakedVertexAnimationManager)||void 0===i||i.bind(q,!!F._wasPreviouslyUsingInstances)}}this._afterBind(P,q,c)}getActiveTextures(){const F=super.getActiveTextures();for(const P in this._textures)F.push(this._textures[P]);for(const P in this._textureArrays){const f=this._textureArrays[P];for(let P=0;P<f.length;P++)F.push(f[P])}return F}hasTexture(F){if(super.hasTexture(F))return!0;for(const P in this._textures)if(this._textures[P]===F)return!0;for(const P in this._textureArrays){const f=this._textureArrays[P];for(let P=0;P<f.length;P++)if(f[P]===F)return!0}return!1}clone(F){const P=c.e.Clone((()=>new L(F,this.OF(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);P.name=F,P.id=F,"object"===typeof P._shaderPath&&(P._shaderPath={...P._shaderPath}),this._options={...this._options};const f=Object.keys(this._options);for(const c of f){const F=this._options[c];Array.isArray(F)&&(this._options[c]=F.slice(0))}this.stencil.copyTo(P.stencil);for(const c in this._textures)P.setTexture(c,this._textures[c]);for(const c in this._textureArrays)P.setTextureArray(c,this._textureArrays[c]);for(const c in this._externalTextures)P.setExternalTexture(c,this._externalTextures[c]);for(const c in this._ints)P.setInt(c,this._ints[c]);for(const c in this._uints)P.setUInt(c,this._uints[c]);for(const c in this._floats)P.setFloat(c,this._floats[c]);for(const c in this._floatsArrays)P.setFloats(c,this._floatsArrays[c]);for(const c in this._colors3)P.setColor3(c,this._colors3[c]);for(const c in this._colors3Arrays)P._colors3Arrays[c]=this._colors3Arrays[c];for(const c in this._colors4)P.setColor4(c,this._colors4[c]);for(const c in this._colors4Arrays)P._colors4Arrays[c]=this._colors4Arrays[c];for(const c in this._vectors2)P.setVector2(c,this._vectors2[c]);for(const c in this._vectors3)P.setVector3(c,this._vectors3[c]);for(const c in this._vectors4)P.setVector4(c,this._vectors4[c]);for(const c in this._quaternions)P.setQuaternion(c,this._quaternions[c]);for(const c in this._quaternionsArrays)P._quaternionsArrays[c]=this._quaternionsArrays[c];for(const c in this._matrices)P.setMatrix(c,this._matrices[c]);for(const c in this._matrixArrays)P._matrixArrays[c]=this._matrixArrays[c].slice();for(const c in this._matrices3x3)P.setMatrix3x3(c,this._matrices3x3[c]);for(const c in this._matrices2x2)P.setMatrix2x2(c,this._matrices2x2[c]);for(const c in this._vectors2Arrays)P.setArray2(c,this._vectors2Arrays[c]);for(const c in this._vectors3Arrays)P.setArray3(c,this._vectors3Arrays[c]);for(const c in this._vectors4Arrays)P.setArray4(c,this._vectors4Arrays[c]);for(const c in this._uniformBuffers)P.setUniformBuffer(c,this._uniformBuffers[c]);for(const c in this._textureSamplers)P.setTextureSampler(c,this._textureSamplers[c]);for(const c in this._storageBuffers)P.setStorageBuffer(c,this._storageBuffers[c]);return P}dispose(F,P,f){if(P){let F;for(F in this._textures)this._textures[F].dispose();for(F in this._textureArrays){const P=this._textureArrays[F];for(let F=0;F<P.length;F++)P[F].dispose()}}this._textures={},super.dispose(F,P,f)}serialize(){const F=c.e.Serialize(this);let P;for(P in F.customType="BABYLON.ShaderMaterial",F.uniqueId=this.uniqueId,F.options=this._options,F.shaderPath=this._shaderPath,F.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,F.stencil=this.stencil.serialize(),F.textures={},this._textures)F.textures[P]=this._textures[P].serialize();for(P in F.textureArrays={},this._textureArrays){F.textureArrays[P]=[];const f=this._textureArrays[P];for(let c=0;c<f.length;c++)F.textureArrays[P].push(f[c].serialize())}for(P in F.ints={},this._ints)F.ints[P]=this._ints[P];for(P in F.uints={},this._uints)F.uints[P]=this._uints[P];for(P in F.floats={},this._floats)F.floats[P]=this._floats[P];for(P in F.floatsArrays={},this._floatsArrays)F.floatsArrays[P]=this._floatsArrays[P];for(P in F.colors3={},this._colors3){const f=this._colors3[P];F.colors3[P]=[f.r,f.g,f.b]}for(P in F.colors3Arrays={},this._colors3Arrays)F.colors3Arrays[P]=this._colors3Arrays[P];for(P in F.colors4={},this._colors4){const f=this._colors4[P];F.colors4[P]=[f.r,f.g,f.b,f.a]}for(P in F.colors4Arrays={},this._colors4Arrays)F.colors4Arrays[P]=this._colors4Arrays[P];for(P in F.vectors2={},this._vectors2){const f=this._vectors2[P];F.vectors2[P]=[f.x,f.y]}for(P in F.vectors3={},this._vectors3){const f=this._vectors3[P];F.vectors3[P]=[f.x,f.y,f.z]}for(P in F.vectors4={},this._vectors4){const f=this._vectors4[P];F.vectors4[P]=[f.x,f.y,f.z,f.w]}for(P in F.quaternions={},this._quaternions)F.quaternions[P]=this._quaternions[P].pf();for(P in F.matrices={},this._matrices)F.matrices[P]=this._matrices[P].pf();for(P in F.matrixArray={},this._matrixArrays)F.matrixArray[P]=this._matrixArrays[P];for(P in F.matrices3x3={},this._matrices3x3)F.matrices3x3[P]=this._matrices3x3[P];for(P in F.matrices2x2={},this._matrices2x2)F.matrices2x2[P]=this._matrices2x2[P];for(P in F.vectors2Arrays={},this._vectors2Arrays)F.vectors2Arrays[P]=this._vectors2Arrays[P];for(P in F.vectors3Arrays={},this._vectors3Arrays)F.vectors3Arrays[P]=this._vectors3Arrays[P];for(P in F.vectors4Arrays={},this._vectors4Arrays)F.vectors4Arrays[P]=this._vectors4Arrays[P];for(P in F.quaternionsArrays={},this._quaternionsArrays)F.quaternionsArrays[P]=this._quaternionsArrays[P];return F}static Parse(F,P,f){const N=c.e.Parse((()=>new L(F.name,P,F.shaderPath,F.options,F.storeEffectOnSubMeshes)),F,P,f);let H;for(H in F.stencil&&N.stencil.parse(F.stencil,P,f),F.textures)N.setTexture(H,A.e.Parse(F.textures[H],P,f));for(H in F.textureArrays){const c=F.textureArrays[H],q=[];for(let F=0;F<c.length;F++)q.push(A.e.Parse(c[F],P,f));N.setTextureArray(H,q)}for(H in F.ints)N.setInt(H,F.ints[H]);for(H in F.uints)N.setUInt(H,F.uints[H]);for(H in F.floats)N.setFloat(H,F.floats[H]);for(H in F.floatsArrays)N.setFloats(H,F.floatsArrays[H]);for(H in F.colors3){const P=F.colors3[H];N.setColor3(H,{r:P[0],g:P[1],b:P[2]})}for(H in F.colors3Arrays){const P=F.colors3Arrays[H].reduce(((F,P,f)=>(f%3===0?F.push([P]):F[F.length-1].push(P),F)),[]).map((F=>({r:F[0],g:F[1],b:F[2]})));N.setColor3Array(H,P)}for(H in F.colors4){const P=F.colors4[H];N.setColor4(H,{r:P[0],g:P[1],b:P[2],a:P[3]})}for(H in F.colors4Arrays){const P=F.colors4Arrays[H].reduce(((F,P,f)=>(f%4===0?F.push([P]):F[F.length-1].push(P),F)),[]).map((F=>({r:F[0],g:F[1],b:F[2],a:F[3]})));N.setColor4Array(H,P)}for(H in F.vectors2){const P=F.vectors2[H];N.setVector2(H,{x:P[0],y:P[1]})}for(H in F.vectors3){const P=F.vectors3[H];N.setVector3(H,{x:P[0],y:P[1],z:P[2]})}for(H in F.vectors4){const P=F.vectors4[H];N.setVector4(H,{x:P[0],y:P[1],z:P[2],w:P[3]})}for(H in F.quaternions)N.setQuaternion(H,q.Quaternion.zP(F.quaternions[H]));for(H in F.matrices)N.setMatrix(H,q.Matrix.zP(F.matrices[H]));for(H in F.matrixArray)N._matrixArrays[H]=new Float32Array(F.matrixArray[H]);for(H in F.matrices3x3)N.setMatrix3x3(H,F.matrices3x3[H]);for(H in F.matrices2x2)N.setMatrix2x2(H,F.matrices2x2[H]);for(H in F.vectors2Arrays)N.setArray2(H,F.vectors2Arrays[H]);for(H in F.vectors3Arrays)N.setArray3(H,F.vectors3Arrays[H]);for(H in F.vectors4Arrays)N.setArray4(H,F.vectors4Arrays[H]);for(H in F.quaternionsArrays)N.setArray4(H,F.quaternionsArrays[H]);return N}static async ParseFromFileAsync(F,P,f){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((N,q)=>{const H=new i.e;H.addEventListener("readystatechange",(()=>{if(4==H.readyState)if(200==H.status){const P=JSON.parse(H.responseText),q=this.Parse(P,f||T.b.LastCreatedScene,c);F&&(q.name=F),N(q)}else q("Unable to load the ShaderMaterial")})),H.open("GET",P),H.send()}))}static async ParseFromSnippetAsync(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((c,N)=>{const q=new i.e;q.addEventListener("readystatechange",(()=>{if(4==q.readyState)if(200==q.status){const N=JSON.parse(JSON.parse(q.responseText).jsonPayload),H=JSON.parse(N.shaderMaterial),A=this.Parse(H,P||T.b.LastCreatedScene,f);A.snippetId=F,c(A)}else N("Unable to load the snippet "+F)})),q.open("GET",this.SnippetUrl+"/"+F.replace(/#/g,"/")),q.send()}))}}L.SnippetUrl="https://snippet.babylonjs.com",L.CreateFromSnippetAsync=L.ParseFromSnippetAsync,(0,o.f)("BABYLON.ShaderMaterial",L)}}]);