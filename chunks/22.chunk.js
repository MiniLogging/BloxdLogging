"use strict";(self["5dou0t7wntc"]=self["5dou0t7wntc"]||[]).push([[22],{11962:(K,O,F)=>{F.r(O),F.d(O,{ShaderMaterial:()=>o});var f=F(11753),r=F(11964),l=F(11713),q=F(11793),J=F(11688),c=F(11661),E=F(12043),M=F(11550),t=F(12050),j=F(11559),X=F(12099),u=F(12092);const T={effect:null,subMesh:null};class o extends t.b{constructor(K,O,F){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(K,O,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new l.Matrix,this._cachedWorldViewProjectionMatrix=new l.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=F,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...f}}get shaderPath(){return this._shaderPath}set shaderPath(K){this._shaderPath=K}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(K){-1===this._options.uniforms.indexOf(K)&&this._options.uniforms.push(K)}setTexture(K,O){return-1===this._options.samplers.indexOf(K)&&this._options.samplers.push(K),this._textures[K]=O,this}removeTexture(K){delete this._textures[K]}setTextureArray(K,O){return-1===this._options.samplers.indexOf(K)&&this._options.samplers.push(K),this._checkUniform(K),this._textureArrays[K]=O,this}setExternalTexture(K,O){return-1===this._options.externalTextures.indexOf(K)&&this._options.externalTextures.push(K),this._externalTextures[K]=O,this}setFloat(K,O){return this._checkUniform(K),this._floats[K]=O,this}setInt(K,O){return this._checkUniform(K),this._ints[K]=O,this}setUInt(K,O){return this._checkUniform(K),this._uints[K]=O,this}setFloats(K,O){return this._checkUniform(K),this._floatsArrays[K]=O,this}setColor3(K,O){return this._checkUniform(K),this._colors3[K]=O,this}setColor3Array(K,O){return this._checkUniform(K),this._colors3Arrays[K]=O.reduce(((K,O)=>(K.push(O.r,O.g,O.b),K)),[]),this}setColor4(K,O){return this._checkUniform(K),this._colors4[K]=O,this}setColor4Array(K,O){return this._checkUniform(K),this._colors4Arrays[K]=O.reduce(((K,O)=>(K.push(O.r,O.g,O.b,O.a),K)),[]),this}setVector2(K,O){return this._checkUniform(K),this._vectors2[K]=O,this}setVector3(K,O){return this._checkUniform(K),this._vectors3[K]=O,this}setVector4(K,O){return this._checkUniform(K),this._vectors4[K]=O,this}setQuaternion(K,O){return this._checkUniform(K),this._quaternions[K]=O,this}setQuaternionArray(K,O){return this._checkUniform(K),this._quaternionsArrays[K]=O.reduce(((K,O)=>(O.toArray(K,K.length),K)),[]),this}setMatrix(K,O){return this._checkUniform(K),this._matrices[K]=O,this}setMatrices(K,O){this._checkUniform(K);const F=new Float32Array(16*O.length);for(let f=0;f<O.length;f++){O[f].copyToArray(F,16*f)}return this._matrixArrays[K]=F,this}setMatrix3x3(K,O){return this._checkUniform(K),this._matrices3x3[K]=O,this}setMatrix2x2(K,O){return this._checkUniform(K),this._matrices2x2[K]=O,this}setArray2(K,O){return this._checkUniform(K),this._vectors2Arrays[K]=O,this}setArray3(K,O){return this._checkUniform(K),this._vectors3Arrays[K]=O,this}setArray4(K,O){return this._checkUniform(K),this._vectors4Arrays[K]=O,this}setUniformBuffer(K,O){return-1===this._options.uniformBuffers.indexOf(K)&&this._options.uniformBuffers.push(K),this._uniformBuffers[K]=O,this}setTextureSampler(K,O){return-1===this._options.samplerObjects.indexOf(K)&&this._options.samplerObjects.push(K),this._textureSamplers[K]=O,this}setStorageBuffer(K,O){return-1===this._options.storageBuffers.indexOf(K)&&this._options.storageBuffers.push(K),this._storageBuffers[K]=O,this}setDefine(K,O){const F=K.trimEnd()+" ",f=this.options.defines.findIndex((O=>O===K||O.startsWith(F)));return f>=0&&this.options.defines.splice(f,1),("boolean"!==typeof O||O)&&this.options.defines.push(F+O),this}isReadyForSubMesh(K,O,F){return this.isReady(K,F,O)}isReady(K,O,F){var f;const l=F&&this._storeEffectOnSubMeshes;if(this.isFrozen){const K=l?F._drawWrapper:this._drawWrapper;if(K.effect&&K._wasPreviouslyReady&&K._wasPreviouslyUsingInstances===O)return!0}const J=this.HK(),c=J.getEngine(),M=[],t=[];let j=null,o=this._shaderPath,k=this._options.uniforms,N=this._options.uniformBuffers,Z=this._options.samplers;c.getCaps().multiview&&J.activeCamera&&J.activeCamera.outputRenderTarget&&J.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,M.push("#define MULTIVIEW"),-1!==k.indexOf("viewProjection")&&-1===k.indexOf("viewProjectionR")&&k.push("viewProjectionR"));for(let r=0;r<this._options.defines.length;r++){const K=0===this._options.defines[r].indexOf("#define")?this._options.defines[r]:`#define ${this._options.defines[r]}`;M.push(K)}for(let r=0;r<this._options.attributes.length;r++)t.push(this._options.attributes[r]);if(K&&K.isVerticesDataPresent(q.d.ColorKind)&&(-1===t.indexOf(q.d.ColorKind)&&t.push(q.d.ColorKind),M.push("#define VERTEXCOLOR")),O&&(M.push("#define INSTANCES"),(0,u.gb)(t,this._materialHelperNeedsPreviousMatrices),null!==K&&void 0!==K&&K.hasThinInstances&&(M.push("#define THIN_INSTANCES"),K&&K.isVerticesDataPresent(q.d.ColorInstanceKind)&&(t.push(q.d.ColorInstanceKind),M.push("#define INSTANCESCOLOR")))),K&&K.useBones&&K.computeBonesUsingShaders&&K.skeleton){t.push(q.d.MatricesIndicesKind),t.push(q.d.MatricesWeightsKind),K.numBoneInfluencers>4&&(t.push(q.d.MatricesIndicesExtraKind),t.push(q.d.MatricesWeightsExtraKind));const O=K.skeleton;M.push("#define NUM_BONE_INFLUENCERS "+K.numBoneInfluencers),j=new E.b,j.addCPUSkinningFallback(0,K),O.isUsingTextureForMatrices?(M.push("#define BONETEXTURE"),-1===k.indexOf("boneTextureWidth")&&k.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(M.push("#define BonesPerMesh "+(O.bones.length+1)),-1===k.indexOf("mBones")&&k.push("mBones"))}else M.push("#define NUM_BONE_INFLUENCERS 0");let L=0;const d=K?K.morphTargetManager:null;if(d){const O=-1!==M.indexOf("#define UV1"),F=-1!==M.indexOf("#define UV2"),f=-1!==M.indexOf("#define TANGENT"),r=-1!==M.indexOf("#define NORMAL"),l=-1!==M.indexOf("#define VERTEXCOLOR");L=(0,u.I)(d,M,t,K,!0,r,f,O,F,l),d.isUsingTextureForTargets&&(-1===k.indexOf("morphTargetTextureIndices")&&k.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),L>0&&(k=k.slice(),k.push("morphTargetInfluences"),k.push("morphTargetCount"),k.push("morphTargetTextureInfo"),k.push("morphTargetTextureIndices"))}else M.push("#define NUM_MORPH_INFLUENCERS 0");if(K){const O=K.bakedVertexAnimationManager;O&&O.isEnabled&&(M.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===k.indexOf("bakedVertexAnimationSettings")&&k.push("bakedVertexAnimationSettings"),-1===k.indexOf("bakedVertexAnimationTextureSizeInverted")&&k.push("bakedVertexAnimationTextureSizeInverted"),-1===k.indexOf("bakedVertexAnimationTime")&&k.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,u.A)(t,K,M)}for(const r in this._textures)if(!this._textures[r].isReady())return!1;K&&this.needAlphaTestingForMesh(K)&&M.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,X.e)(k),(0,X.i)(this,J,M)),J.fogEnabled&&null!==K&&void 0!==K&&K.applyFog&&J.fogMode!==r.d.FOGMODE_NONE&&(M.push("#define FOG"),-1===k.indexOf("view")&&k.push("view"),-1===k.indexOf("vFogInfos")&&k.push("vFogInfos"),-1===k.indexOf("vFogColor")&&k.push("vFogColor")),this._useLogarithmicDepth&&(M.push("#define LOGARITHMICDEPTH"),-1===k.indexOf("logarithmicDepthConstant")&&k.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(k=k.slice(),N=N.slice(),Z=Z.slice(),o=this.customShaderNameResolve(this.name,k,N,Z,M,t));const a=l?F._getDrawWrapper(void 0,!0):this._drawWrapper,g=(null===a||void 0===a?void 0:a.effect)??null,H=(null===a||void 0===a?void 0:a.defines)??null,e=M.join("\n");let W=g;return H!==e&&(W=c.createEffect(o,{attributes:t,uniformsNames:k,uniformBuffersNames:N,samplers:Z,defines:e,fallbacks:j,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:L},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},c),l?F.setEffect(W,e,this._materialContext):a&&a.setEffect(W,e),this._onEffectCreatedObservable&&(T.effect=W,T.subMesh=F??(null===K||void 0===K?void 0:K.Df[0])??null,this._onEffectCreatedObservable.notifyObservers(T))),a._wasPreviouslyUsingInstances=!!O,!(null===(f=W)||void 0===f||!f.isReady())&&(g!==W&&J.resetCachedMaterial(),a._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(K,O){const F=O??this.getEffect();if(!F)return;const f=this._options.uniforms;-1!==f.indexOf("world")&&F.setMatrix("world",K);const r=this.HK();-1!==f.indexOf("worldView")&&(K.multiplyToRef(r.getViewMatrix(),this._cachedWorldViewMatrix),F.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==f.indexOf("worldViewProjection")&&(K.multiplyToRef(r.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),F.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==f.indexOf("view")&&F.setMatrix("view",r.getViewMatrix())}bindForSubMesh(K,O,F){var f;this.bind(K,O,null===(f=F._drawWrapperOverride)||void 0===f?void 0:f.effect,F)}bind(K,O,F,f){const r=f&&this._storeEffectOnSubMeshes,l=F??(r?f.effect:this.getEffect());if(!l)return;const q=this.HK();this._activeEffect=l,this.bindOnlyWorldMatrix(K,F);const J=this._options.uniformBuffers;let c=!1;if(l&&J&&J.length>0&&q.getEngine().supportsUniformBuffers)for(let t=0;t<J.length;++t){switch(J[t]){case"Mesh":O&&(O.getMeshUniformBuffer().bindToEffect(l,"Mesh"),O.transferToEffect(K));break;case"Scene":(0,u.p)(l,q.getSceneUniformBuffer()),q.finalizeSceneUbo(),c=!0}}const E=O&&r?this._mustRebind(q,l,f,O.visibility):q.getCachedMaterial()!==this;if(l&&E){let K;for(K in c||-1===this._options.uniforms.indexOf("view")||l.setMatrix("view",q.getViewMatrix()),c||-1===this._options.uniforms.indexOf("projection")||l.setMatrix("projection",q.getProjectionMatrix()),c||-1===this._options.uniforms.indexOf("viewProjection")||(l.setMatrix("viewProjection",q.getTransformMatrix()),this._multiview&&l.setMatrix("viewProjectionR",q._transformMatrixR)),q.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&l.setVector3("cameraPosition",q.activeCamera.globalPosition),(0,u.c)(O,l),(0,X.g)(l,this,q),this._useLogarithmicDepth&&(0,u.j)(r?f.materialDefines:l.defines,l,q),O&&(0,u.f)(q,O,l),this._textures)l.setTexture(K,this._textures[K]);for(K in this._textureArrays)l.setTextureArray(K,this._textureArrays[K]);for(K in this._ints)l.setInt(K,this._ints[K]);for(K in this._uints)l.setUInt(K,this._uints[K]);for(K in this._floats)l.setFloat(K,this._floats[K]);for(K in this._floatsArrays)l.setArray(K,this._floatsArrays[K]);for(K in this._colors3)l.setColor3(K,this._colors3[K]);for(K in this._colors3Arrays)l.setArray3(K,this._colors3Arrays[K]);for(K in this._colors4){const O=this._colors4[K];l.setFloat4(K,O.r,O.g,O.b,O.a)}for(K in this._colors4Arrays)l.setArray4(K,this._colors4Arrays[K]);for(K in this._vectors2)l.setVector2(K,this._vectors2[K]);for(K in this._vectors3)l.setVector3(K,this._vectors3[K]);for(K in this._vectors4)l.setVector4(K,this._vectors4[K]);for(K in this._quaternions)l.setQuaternion(K,this._quaternions[K]);for(K in this._matrices)l.setMatrix(K,this._matrices[K]);for(K in this._matrixArrays)l.setMatrices(K,this._matrixArrays[K]);for(K in this._matrices3x3)l.setMatrix3x3(K,this._matrices3x3[K]);for(K in this._matrices2x2)l.setMatrix2x2(K,this._matrices2x2[K]);for(K in this._vectors2Arrays)l.setArray2(K,this._vectors2Arrays[K]);for(K in this._vectors3Arrays)l.setArray3(K,this._vectors3Arrays[K]);for(K in this._vectors4Arrays)l.setArray4(K,this._vectors4Arrays[K]);for(K in this._quaternionsArrays)l.setArray4(K,this._quaternionsArrays[K]);for(K in this._uniformBuffers){const O=this._uniformBuffers[K].getBuffer();O&&l.bindUniformBuffer(O,K)}const F=q.getEngine(),J=F.setExternalTexture;if(J)for(K in this._externalTextures)J.call(F,K,this._externalTextures[K]);const E=F.setTextureSampler;if(E)for(K in this._textureSamplers)E.call(F,K,this._textureSamplers[K]);const M=F.setStorageBuffer;if(M)for(K in this._storageBuffers)M.call(F,K,this._storageBuffers[K])}if(l&&O&&(E||!this.isFrozen)){(0,u.m)(O,l),O.morphTargetManager&&O.morphTargetManager.isUsingTextureForTargets&&O.morphTargetManager._bind(l);const K=O.bakedVertexAnimationManager;if(K&&K.isEnabled){var M;const K=r?f._drawWrapper:this._drawWrapper;null===(M=O.bakedVertexAnimationManager)||void 0===M||M.bind(l,!!K._wasPreviouslyUsingInstances)}}this._afterBind(O,l,f)}getActiveTextures(){const K=super.getActiveTextures();for(const O in this._textures)K.push(this._textures[O]);for(const O in this._textureArrays){const F=this._textureArrays[O];for(let O=0;O<F.length;O++)K.push(F[O])}return K}hasTexture(K){if(super.hasTexture(K))return!0;for(const O in this._textures)if(this._textures[O]===K)return!0;for(const O in this._textureArrays){const F=this._textureArrays[O];for(let O=0;O<F.length;O++)if(F[O]===K)return!0}return!1}clone(K){const O=f.e.Clone((()=>new o(K,this.HK(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);O.name=K,O.id=K,"object"===typeof O._shaderPath&&(O._shaderPath={...O._shaderPath}),this._options={...this._options};const F=Object.keys(this._options);for(const f of F){const K=this._options[f];Array.isArray(K)&&(this._options[f]=K.slice(0))}this.stencil.copyTo(O.stencil);for(const f in this._textures)O.setTexture(f,this._textures[f]);for(const f in this._textureArrays)O.setTextureArray(f,this._textureArrays[f]);for(const f in this._externalTextures)O.setExternalTexture(f,this._externalTextures[f]);for(const f in this._ints)O.setInt(f,this._ints[f]);for(const f in this._uints)O.setUInt(f,this._uints[f]);for(const f in this._floats)O.setFloat(f,this._floats[f]);for(const f in this._floatsArrays)O.setFloats(f,this._floatsArrays[f]);for(const f in this._colors3)O.setColor3(f,this._colors3[f]);for(const f in this._colors3Arrays)O._colors3Arrays[f]=this._colors3Arrays[f];for(const f in this._colors4)O.setColor4(f,this._colors4[f]);for(const f in this._colors4Arrays)O._colors4Arrays[f]=this._colors4Arrays[f];for(const f in this._vectors2)O.setVector2(f,this._vectors2[f]);for(const f in this._vectors3)O.setVector3(f,this._vectors3[f]);for(const f in this._vectors4)O.setVector4(f,this._vectors4[f]);for(const f in this._quaternions)O.setQuaternion(f,this._quaternions[f]);for(const f in this._quaternionsArrays)O._quaternionsArrays[f]=this._quaternionsArrays[f];for(const f in this._matrices)O.setMatrix(f,this._matrices[f]);for(const f in this._matrixArrays)O._matrixArrays[f]=this._matrixArrays[f].slice();for(const f in this._matrices3x3)O.setMatrix3x3(f,this._matrices3x3[f]);for(const f in this._matrices2x2)O.setMatrix2x2(f,this._matrices2x2[f]);for(const f in this._vectors2Arrays)O.setArray2(f,this._vectors2Arrays[f]);for(const f in this._vectors3Arrays)O.setArray3(f,this._vectors3Arrays[f]);for(const f in this._vectors4Arrays)O.setArray4(f,this._vectors4Arrays[f]);for(const f in this._uniformBuffers)O.setUniformBuffer(f,this._uniformBuffers[f]);for(const f in this._textureSamplers)O.setTextureSampler(f,this._textureSamplers[f]);for(const f in this._storageBuffers)O.setStorageBuffer(f,this._storageBuffers[f]);return O}dispose(K,O,F){if(O){let K;for(K in this._textures)this._textures[K].dispose();for(K in this._textureArrays){const O=this._textureArrays[K];for(let K=0;K<O.length;K++)O[K].dispose()}}this._textures={},super.dispose(K,O,F)}serialize(){const K=f.e.Serialize(this);let O;for(O in K.customType="BABYLON.ShaderMaterial",K.uniqueId=this.uniqueId,K.options=this._options,K.shaderPath=this._shaderPath,K.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,K.stencil=this.stencil.serialize(),K.textures={},this._textures)K.textures[O]=this._textures[O].serialize();for(O in K.textureArrays={},this._textureArrays){K.textureArrays[O]=[];const F=this._textureArrays[O];for(let f=0;f<F.length;f++)K.textureArrays[O].push(F[f].serialize())}for(O in K.ints={},this._ints)K.ints[O]=this._ints[O];for(O in K.uints={},this._uints)K.uints[O]=this._uints[O];for(O in K.floats={},this._floats)K.floats[O]=this._floats[O];for(O in K.floatsArrays={},this._floatsArrays)K.floatsArrays[O]=this._floatsArrays[O];for(O in K.colors3={},this._colors3){const F=this._colors3[O];K.colors3[O]=[F.r,F.g,F.b]}for(O in K.colors3Arrays={},this._colors3Arrays)K.colors3Arrays[O]=this._colors3Arrays[O];for(O in K.colors4={},this._colors4){const F=this._colors4[O];K.colors4[O]=[F.r,F.g,F.b,F.a]}for(O in K.colors4Arrays={},this._colors4Arrays)K.colors4Arrays[O]=this._colors4Arrays[O];for(O in K.vectors2={},this._vectors2){const F=this._vectors2[O];K.vectors2[O]=[F.x,F.y]}for(O in K.vectors3={},this._vectors3){const F=this._vectors3[O];K.vectors3[O]=[F.x,F.y,F.z]}for(O in K.vectors4={},this._vectors4){const F=this._vectors4[O];K.vectors4[O]=[F.x,F.y,F.z,F.w]}for(O in K.quaternions={},this._quaternions)K.quaternions[O]=this._quaternions[O].hf();for(O in K.matrices={},this._matrices)K.matrices[O]=this._matrices[O].hf();for(O in K.matrixArray={},this._matrixArrays)K.matrixArray[O]=this._matrixArrays[O];for(O in K.matrices3x3={},this._matrices3x3)K.matrices3x3[O]=this._matrices3x3[O];for(O in K.matrices2x2={},this._matrices2x2)K.matrices2x2[O]=this._matrices2x2[O];for(O in K.vectors2Arrays={},this._vectors2Arrays)K.vectors2Arrays[O]=this._vectors2Arrays[O];for(O in K.vectors3Arrays={},this._vectors3Arrays)K.vectors3Arrays[O]=this._vectors3Arrays[O];for(O in K.vectors4Arrays={},this._vectors4Arrays)K.vectors4Arrays[O]=this._vectors4Arrays[O];for(O in K.quaternionsArrays={},this._quaternionsArrays)K.quaternionsArrays[O]=this._quaternionsArrays[O];return K}static Parse(K,O,F){const r=f.e.Parse((()=>new o(K.name,O,K.shaderPath,K.options,K.storeEffectOnSubMeshes)),K,O,F);let q;for(q in K.stencil&&r.stencil.parse(K.stencil,O,F),K.textures)r.setTexture(q,J.b.Parse(K.textures[q],O,F));for(q in K.textureArrays){const f=K.textureArrays[q],l=[];for(let K=0;K<f.length;K++)l.push(J.b.Parse(f[K],O,F));r.setTextureArray(q,l)}for(q in K.ints)r.setInt(q,K.ints[q]);for(q in K.uints)r.setUInt(q,K.uints[q]);for(q in K.floats)r.setFloat(q,K.floats[q]);for(q in K.floatsArrays)r.setFloats(q,K.floatsArrays[q]);for(q in K.colors3){const O=K.colors3[q];r.setColor3(q,{r:O[0],g:O[1],b:O[2]})}for(q in K.colors3Arrays){const O=K.colors3Arrays[q].reduce(((K,O,F)=>(F%3===0?K.push([O]):K[K.length-1].push(O),K)),[]).map((K=>({r:K[0],g:K[1],b:K[2]})));r.setColor3Array(q,O)}for(q in K.colors4){const O=K.colors4[q];r.setColor4(q,{r:O[0],g:O[1],b:O[2],a:O[3]})}for(q in K.colors4Arrays){const O=K.colors4Arrays[q].reduce(((K,O,F)=>(F%4===0?K.push([O]):K[K.length-1].push(O),K)),[]).map((K=>({r:K[0],g:K[1],b:K[2],a:K[3]})));r.setColor4Array(q,O)}for(q in K.vectors2){const O=K.vectors2[q];r.setVector2(q,{x:O[0],y:O[1]})}for(q in K.vectors3){const O=K.vectors3[q];r.setVector3(q,{x:O[0],y:O[1],z:O[2]})}for(q in K.vectors4){const O=K.vectors4[q];r.setVector4(q,{x:O[0],y:O[1],z:O[2],w:O[3]})}for(q in K.quaternions)r.setQuaternion(q,l.Quaternion.LO(K.quaternions[q]));for(q in K.matrices)r.setMatrix(q,l.Matrix.LO(K.matrices[q]));for(q in K.matrixArray)r._matrixArrays[q]=new Float32Array(K.matrixArray[q]);for(q in K.matrices3x3)r.setMatrix3x3(q,K.matrices3x3[q]);for(q in K.matrices2x2)r.setMatrix2x2(q,K.matrices2x2[q]);for(q in K.vectors2Arrays)r.setArray2(q,K.vectors2Arrays[q]);for(q in K.vectors3Arrays)r.setArray3(q,K.vectors3Arrays[q]);for(q in K.vectors4Arrays)r.setArray4(q,K.vectors4Arrays[q]);for(q in K.quaternionsArrays)r.setArray4(q,K.quaternionsArrays[q]);return r}static async ParseFromFileAsync(K,O,F){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((r,l)=>{const q=new M.e;q.addEventListener("readystatechange",(()=>{if(4==q.readyState)if(200==q.status){const O=JSON.parse(q.responseText),l=this.Parse(O,F||j.e.LastCreatedScene,f);K&&(l.name=K),r(l)}else l("Unable to load the ShaderMaterial")})),q.open("GET",O),q.send()}))}static async ParseFromSnippetAsync(K,O){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((f,r)=>{const l=new M.e;l.addEventListener("readystatechange",(()=>{if(4==l.readyState)if(200==l.status){const r=JSON.parse(JSON.parse(l.responseText).jsonPayload),q=JSON.parse(r.shaderMaterial),J=this.Parse(q,O||j.e.LastCreatedScene,F);J.snippetId=K,f(J)}else r("Unable to load the snippet "+K)})),l.open("GET",this.SnippetUrl+"/"+K.replace(/#/g,"/")),l.send()}))}}o.SnippetUrl="https://snippet.babylonjs.com",o.CreateFromSnippetAsync=o.ParseFromSnippetAsync,(0,c.g)("BABYLON.ShaderMaterial",o)}}]);