"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[22],{11417:(R,J,B)=>{B.r(J),B.d(J,{ShaderMaterial:()=>A});var Q=B(11217),h=B(11419),y=B(11186),N=B(11262),r=B(11161),q=B(11142),e=B(11489),D=B(11060),l=B(11495),E=B(11065),O=B(11547),n=B(11539);const P={effect:null,subMesh:null};class A extends l.d{constructor(R,J,B){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(R,J,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new y.Matrix,this._cachedWorldViewProjectionMatrix=new y.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=B,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...Q}}get shaderPath(){return this._shaderPath}set shaderPath(R){this._shaderPath=R}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(R){-1===this._options.uniforms.indexOf(R)&&this._options.uniforms.push(R)}setTexture(R,J){return-1===this._options.samplers.indexOf(R)&&this._options.samplers.push(R),this._textures[R]=J,this}removeTexture(R){delete this._textures[R]}setTextureArray(R,J){return-1===this._options.samplers.indexOf(R)&&this._options.samplers.push(R),this._checkUniform(R),this._textureArrays[R]=J,this}setExternalTexture(R,J){return-1===this._options.externalTextures.indexOf(R)&&this._options.externalTextures.push(R),this._externalTextures[R]=J,this}setFloat(R,J){return this._checkUniform(R),this._floats[R]=J,this}setInt(R,J){return this._checkUniform(R),this._ints[R]=J,this}setUInt(R,J){return this._checkUniform(R),this._uints[R]=J,this}setFloats(R,J){return this._checkUniform(R),this._floatsArrays[R]=J,this}setColor3(R,J){return this._checkUniform(R),this._colors3[R]=J,this}setColor3Array(R,J){return this._checkUniform(R),this._colors3Arrays[R]=J.reduce(((R,J)=>(R.push(J.r,J.g,J.b),R)),[]),this}setColor4(R,J){return this._checkUniform(R),this._colors4[R]=J,this}setColor4Array(R,J){return this._checkUniform(R),this._colors4Arrays[R]=J.reduce(((R,J)=>(R.push(J.r,J.g,J.b,J.a),R)),[]),this}setVector2(R,J){return this._checkUniform(R),this._vectors2[R]=J,this}setVector3(R,J){return this._checkUniform(R),this._vectors3[R]=J,this}setVector4(R,J){return this._checkUniform(R),this._vectors4[R]=J,this}setQuaternion(R,J){return this._checkUniform(R),this._quaternions[R]=J,this}setQuaternionArray(R,J){return this._checkUniform(R),this._quaternionsArrays[R]=J.reduce(((R,J)=>(J.toArray(R,R.length),R)),[]),this}setMatrix(R,J){return this._checkUniform(R),this._matrices[R]=J,this}setMatrices(R,J){this._checkUniform(R);const B=new Float32Array(16*J.length);for(let Q=0;Q<J.length;Q++){J[Q].copyToArray(B,16*Q)}return this._matrixArrays[R]=B,this}setMatrix3x3(R,J){return this._checkUniform(R),this._matrices3x3[R]=J,this}setMatrix2x2(R,J){return this._checkUniform(R),this._matrices2x2[R]=J,this}setArray2(R,J){return this._checkUniform(R),this._vectors2Arrays[R]=J,this}setArray3(R,J){return this._checkUniform(R),this._vectors3Arrays[R]=J,this}setArray4(R,J){return this._checkUniform(R),this._vectors4Arrays[R]=J,this}setUniformBuffer(R,J){return-1===this._options.uniformBuffers.indexOf(R)&&this._options.uniformBuffers.push(R),this._uniformBuffers[R]=J,this}setTextureSampler(R,J){return-1===this._options.samplerObjects.indexOf(R)&&this._options.samplerObjects.push(R),this._textureSamplers[R]=J,this}setStorageBuffer(R,J){return-1===this._options.storageBuffers.indexOf(R)&&this._options.storageBuffers.push(R),this._storageBuffers[R]=J,this}setDefine(R,J){const B=R.trimEnd()+" ",Q=this.options.defines.findIndex((J=>J===R||J.startsWith(B)));return Q>=0&&this.options.defines.splice(Q,1),("boolean"!==typeof J||J)&&this.options.defines.push(B+J),this}isReadyForSubMesh(R,J,B){return this.isReady(R,B,J)}isReady(R,J,B){var Q;const y=B&&this._storeEffectOnSubMeshes;if(this.isFrozen){const R=y?B._drawWrapper:this._drawWrapper;if(R.effect&&R._wasPreviouslyReady&&R._wasPreviouslyUsingInstances===J)return!0}const r=this.IR(),q=r.getEngine(),D=[],l=[];let E=null,A=this._shaderPath,u=this._options.uniforms,S=this._options.uniformBuffers,f=this._options.samplers;q.getCaps().multiview&&r.activeCamera&&r.activeCamera.outputRenderTarget&&r.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,D.push("#define MULTIVIEW"),-1!==u.indexOf("viewProjection")&&-1===u.indexOf("viewProjectionR")&&u.push("viewProjectionR"));for(let h=0;h<this._options.defines.length;h++){const R=0===this._options.defines[h].indexOf("#define")?this._options.defines[h]:`#define ${this._options.defines[h]}`;D.push(R)}for(let h=0;h<this._options.attributes.length;h++)l.push(this._options.attributes[h]);if(R&&R.isVerticesDataPresent(N.h.ColorKind)&&(-1===l.indexOf(N.h.ColorKind)&&l.push(N.h.ColorKind),D.push("#define VERTEXCOLOR")),J&&(D.push("#define INSTANCES"),(0,n.db)(l,this._materialHelperNeedsPreviousMatrices),null!==R&&void 0!==R&&R.hasThinInstances&&(D.push("#define THIN_INSTANCES"),R&&R.isVerticesDataPresent(N.h.ColorInstanceKind)&&(l.push(N.h.ColorInstanceKind),D.push("#define INSTANCESCOLOR")))),R&&R.useBones&&R.computeBonesUsingShaders&&R.skeleton){l.push(N.h.MatricesIndicesKind),l.push(N.h.MatricesWeightsKind),R.numBoneInfluencers>4&&(l.push(N.h.MatricesIndicesExtraKind),l.push(N.h.MatricesWeightsExtraKind));const J=R.skeleton;D.push("#define NUM_BONE_INFLUENCERS "+R.numBoneInfluencers),E=new e.c,E.addCPUSkinningFallback(0,R),J.isUsingTextureForMatrices?(D.push("#define BONETEXTURE"),-1===u.indexOf("boneTextureWidth")&&u.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(D.push("#define BonesPerMesh "+(J.bones.length+1)),-1===u.indexOf("mBones")&&u.push("mBones"))}else D.push("#define NUM_BONE_INFLUENCERS 0");let a=0;const s=R?R.morphTargetManager:null;if(s){const J=-1!==D.indexOf("#define UV1"),B=-1!==D.indexOf("#define UV2"),Q=-1!==D.indexOf("#define TANGENT"),h=-1!==D.indexOf("#define NORMAL"),y=-1!==D.indexOf("#define VERTEXCOLOR");a=(0,n.H)(s,D,l,R,!0,h,Q,J,B,y),s.isUsingTextureForTargets&&(-1===u.indexOf("morphTargetTextureIndices")&&u.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),a>0&&(u=u.slice(),u.push("morphTargetInfluences"),u.push("morphTargetCount"),u.push("morphTargetTextureInfo"),u.push("morphTargetTextureIndices"))}else D.push("#define NUM_MORPH_INFLUENCERS 0");if(R){const J=R.bakedVertexAnimationManager;J&&J.isEnabled&&(D.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===u.indexOf("bakedVertexAnimationSettings")&&u.push("bakedVertexAnimationSettings"),-1===u.indexOf("bakedVertexAnimationTextureSizeInverted")&&u.push("bakedVertexAnimationTextureSizeInverted"),-1===u.indexOf("bakedVertexAnimationTime")&&u.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,n.u)(l,R,D)}for(const h in this._textures)if(!this._textures[h].isReady())return!1;R&&this.needAlphaTestingForMesh(R)&&D.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,O.e)(u),(0,O.j)(this,r,D)),r.fogEnabled&&null!==R&&void 0!==R&&R.applyFog&&r.fogMode!==h.d.FOGMODE_NONE&&(D.push("#define FOG"),-1===u.indexOf("view")&&u.push("view"),-1===u.indexOf("vFogInfos")&&u.push("vFogInfos"),-1===u.indexOf("vFogColor")&&u.push("vFogColor")),this._useLogarithmicDepth&&(D.push("#define LOGARITHMICDEPTH"),-1===u.indexOf("logarithmicDepthConstant")&&u.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(u=u.slice(),S=S.slice(),f=f.slice(),A=this.customShaderNameResolve(this.name,u,S,f,D,l));const x=y?B._getDrawWrapper(void 0,!0):this._drawWrapper,I=(null===x||void 0===x?void 0:x.effect)??null,V=(null===x||void 0===x?void 0:x.defines)??null,M=D.join("\n");let H=I;return V!==M&&(H=q.createEffect(A,{attributes:l,uniformsNames:u,uniformBuffersNames:S,samplers:f,defines:M,fallbacks:E,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:a},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},q),y?B.setEffect(H,M,this._materialContext):x&&x.setEffect(H,M),this._onEffectCreatedObservable&&(P.effect=H,P.subMesh=B??(null===R||void 0===R?void 0:R.Fh[0])??null,this._onEffectCreatedObservable.notifyObservers(P))),x._wasPreviouslyUsingInstances=!!J,!(null===(Q=H)||void 0===Q||!Q.isReady())&&(I!==H&&r.resetCachedMaterial(),x._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(R,J){const B=J??this.getEffect();if(!B)return;const Q=this._options.uniforms;-1!==Q.indexOf("world")&&B.setMatrix("world",R);const h=this.IR();-1!==Q.indexOf("worldView")&&(R.multiplyToRef(h.getViewMatrix(),this._cachedWorldViewMatrix),B.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==Q.indexOf("worldViewProjection")&&(R.multiplyToRef(h.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),B.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==Q.indexOf("view")&&B.setMatrix("view",h.getViewMatrix())}bindForSubMesh(R,J,B){var Q;this.bind(R,J,null===(Q=B._drawWrapperOverride)||void 0===Q?void 0:Q.effect,B)}bind(R,J,B,Q){const h=Q&&this._storeEffectOnSubMeshes,y=B??(h?Q.effect:this.getEffect());if(!y)return;const N=this.IR();this._activeEffect=y,this.bindOnlyWorldMatrix(R,B);const r=this._options.uniformBuffers;let q=!1;if(y&&r&&r.length>0&&N.getEngine().supportsUniformBuffers)for(let l=0;l<r.length;++l){switch(r[l]){case"Mesh":J&&(J.getMeshUniformBuffer().bindToEffect(y,"Mesh"),J.transferToEffect(R));break;case"Scene":(0,n.q)(y,N.getSceneUniformBuffer()),N.finalizeSceneUbo(),q=!0}}const e=J&&h?this._mustRebind(N,y,Q,J.visibility):N.getCachedMaterial()!==this;if(y&&e){let R;for(R in q||-1===this._options.uniforms.indexOf("view")||y.setMatrix("view",N.getViewMatrix()),q||-1===this._options.uniforms.indexOf("projection")||y.setMatrix("projection",N.getProjectionMatrix()),q||-1===this._options.uniforms.indexOf("viewProjection")||(y.setMatrix("viewProjection",N.getTransformMatrix()),this._multiview&&y.setMatrix("viewProjectionR",N._transformMatrixR)),N.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&y.setVector3("cameraPosition",N.activeCamera.globalPosition),(0,n.c)(J,y),(0,O.g)(y,this,N),this._useLogarithmicDepth&&(0,n.i)(h?Q.materialDefines:y.defines,y,N),J&&(0,n.d)(N,J,y),this._textures)y.setTexture(R,this._textures[R]);for(R in this._textureArrays)y.setTextureArray(R,this._textureArrays[R]);for(R in this._ints)y.setInt(R,this._ints[R]);for(R in this._uints)y.setUInt(R,this._uints[R]);for(R in this._floats)y.setFloat(R,this._floats[R]);for(R in this._floatsArrays)y.setArray(R,this._floatsArrays[R]);for(R in this._colors3)y.setColor3(R,this._colors3[R]);for(R in this._colors3Arrays)y.setArray3(R,this._colors3Arrays[R]);for(R in this._colors4){const J=this._colors4[R];y.setFloat4(R,J.r,J.g,J.b,J.a)}for(R in this._colors4Arrays)y.setArray4(R,this._colors4Arrays[R]);for(R in this._vectors2)y.setVector2(R,this._vectors2[R]);for(R in this._vectors3)y.setVector3(R,this._vectors3[R]);for(R in this._vectors4)y.setVector4(R,this._vectors4[R]);for(R in this._quaternions)y.setQuaternion(R,this._quaternions[R]);for(R in this._matrices)y.setMatrix(R,this._matrices[R]);for(R in this._matrixArrays)y.setMatrices(R,this._matrixArrays[R]);for(R in this._matrices3x3)y.setMatrix3x3(R,this._matrices3x3[R]);for(R in this._matrices2x2)y.setMatrix2x2(R,this._matrices2x2[R]);for(R in this._vectors2Arrays)y.setArray2(R,this._vectors2Arrays[R]);for(R in this._vectors3Arrays)y.setArray3(R,this._vectors3Arrays[R]);for(R in this._vectors4Arrays)y.setArray4(R,this._vectors4Arrays[R]);for(R in this._quaternionsArrays)y.setArray4(R,this._quaternionsArrays[R]);for(R in this._uniformBuffers){const J=this._uniformBuffers[R].getBuffer();J&&y.bindUniformBuffer(J,R)}const B=N.getEngine(),r=B.setExternalTexture;if(r)for(R in this._externalTextures)r.call(B,R,this._externalTextures[R]);const e=B.setTextureSampler;if(e)for(R in this._textureSamplers)e.call(B,R,this._textureSamplers[R]);const D=B.setStorageBuffer;if(D)for(R in this._storageBuffers)D.call(B,R,this._storageBuffers[R])}if(y&&J&&(e||!this.isFrozen)){(0,n.m)(J,y),J.morphTargetManager&&J.morphTargetManager.isUsingTextureForTargets&&J.morphTargetManager._bind(y);const R=J.bakedVertexAnimationManager;if(R&&R.isEnabled){var D;const R=h?Q._drawWrapper:this._drawWrapper;null===(D=J.bakedVertexAnimationManager)||void 0===D||D.bind(y,!!R._wasPreviouslyUsingInstances)}}this._afterBind(J,y,Q)}getActiveTextures(){const R=super.getActiveTextures();for(const J in this._textures)R.push(this._textures[J]);for(const J in this._textureArrays){const B=this._textureArrays[J];for(let J=0;J<B.length;J++)R.push(B[J])}return R}hasTexture(R){if(super.hasTexture(R))return!0;for(const J in this._textures)if(this._textures[J]===R)return!0;for(const J in this._textureArrays){const B=this._textureArrays[J];for(let J=0;J<B.length;J++)if(B[J]===R)return!0}return!1}clone(R){const J=Q.c.Clone((()=>new A(R,this.IR(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);J.name=R,J.id=R,"object"===typeof J._shaderPath&&(J._shaderPath={...J._shaderPath}),this._options={...this._options};const B=Object.keys(this._options);for(const Q of B){const R=this._options[Q];Array.isArray(R)&&(this._options[Q]=R.slice(0))}this.stencil.copyTo(J.stencil);for(const Q in this._textures)J.setTexture(Q,this._textures[Q]);for(const Q in this._textureArrays)J.setTextureArray(Q,this._textureArrays[Q]);for(const Q in this._externalTextures)J.setExternalTexture(Q,this._externalTextures[Q]);for(const Q in this._ints)J.setInt(Q,this._ints[Q]);for(const Q in this._uints)J.setUInt(Q,this._uints[Q]);for(const Q in this._floats)J.setFloat(Q,this._floats[Q]);for(const Q in this._floatsArrays)J.setFloats(Q,this._floatsArrays[Q]);for(const Q in this._colors3)J.setColor3(Q,this._colors3[Q]);for(const Q in this._colors3Arrays)J._colors3Arrays[Q]=this._colors3Arrays[Q];for(const Q in this._colors4)J.setColor4(Q,this._colors4[Q]);for(const Q in this._colors4Arrays)J._colors4Arrays[Q]=this._colors4Arrays[Q];for(const Q in this._vectors2)J.setVector2(Q,this._vectors2[Q]);for(const Q in this._vectors3)J.setVector3(Q,this._vectors3[Q]);for(const Q in this._vectors4)J.setVector4(Q,this._vectors4[Q]);for(const Q in this._quaternions)J.setQuaternion(Q,this._quaternions[Q]);for(const Q in this._quaternionsArrays)J._quaternionsArrays[Q]=this._quaternionsArrays[Q];for(const Q in this._matrices)J.setMatrix(Q,this._matrices[Q]);for(const Q in this._matrixArrays)J._matrixArrays[Q]=this._matrixArrays[Q].slice();for(const Q in this._matrices3x3)J.setMatrix3x3(Q,this._matrices3x3[Q]);for(const Q in this._matrices2x2)J.setMatrix2x2(Q,this._matrices2x2[Q]);for(const Q in this._vectors2Arrays)J.setArray2(Q,this._vectors2Arrays[Q]);for(const Q in this._vectors3Arrays)J.setArray3(Q,this._vectors3Arrays[Q]);for(const Q in this._vectors4Arrays)J.setArray4(Q,this._vectors4Arrays[Q]);for(const Q in this._uniformBuffers)J.setUniformBuffer(Q,this._uniformBuffers[Q]);for(const Q in this._textureSamplers)J.setTextureSampler(Q,this._textureSamplers[Q]);for(const Q in this._storageBuffers)J.setStorageBuffer(Q,this._storageBuffers[Q]);return J}dispose(R,J,B){if(J){let R;for(R in this._textures)this._textures[R].dispose();for(R in this._textureArrays){const J=this._textureArrays[R];for(let R=0;R<J.length;R++)J[R].dispose()}}this._textures={},super.dispose(R,J,B)}serialize(){const R=Q.c.Serialize(this);let J;for(J in R.customType="BABYLON.ShaderMaterial",R.uniqueId=this.uniqueId,R.options=this._options,R.shaderPath=this._shaderPath,R.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,R.stencil=this.stencil.serialize(),R.textures={},this._textures)R.textures[J]=this._textures[J].serialize();for(J in R.textureArrays={},this._textureArrays){R.textureArrays[J]=[];const B=this._textureArrays[J];for(let Q=0;Q<B.length;Q++)R.textureArrays[J].push(B[Q].serialize())}for(J in R.ints={},this._ints)R.ints[J]=this._ints[J];for(J in R.uints={},this._uints)R.uints[J]=this._uints[J];for(J in R.floats={},this._floats)R.floats[J]=this._floats[J];for(J in R.floatsArrays={},this._floatsArrays)R.floatsArrays[J]=this._floatsArrays[J];for(J in R.colors3={},this._colors3){const B=this._colors3[J];R.colors3[J]=[B.r,B.g,B.b]}for(J in R.colors3Arrays={},this._colors3Arrays)R.colors3Arrays[J]=this._colors3Arrays[J];for(J in R.colors4={},this._colors4){const B=this._colors4[J];R.colors4[J]=[B.r,B.g,B.b,B.a]}for(J in R.colors4Arrays={},this._colors4Arrays)R.colors4Arrays[J]=this._colors4Arrays[J];for(J in R.vectors2={},this._vectors2){const B=this._vectors2[J];R.vectors2[J]=[B.x,B.y]}for(J in R.vectors3={},this._vectors3){const B=this._vectors3[J];R.vectors3[J]=[B.x,B.y,B.z]}for(J in R.vectors4={},this._vectors4){const B=this._vectors4[J];R.vectors4[J]=[B.x,B.y,B.z,B.w]}for(J in R.quaternions={},this._quaternions)R.quaternions[J]=this._quaternions[J].Ch();for(J in R.matrices={},this._matrices)R.matrices[J]=this._matrices[J].Ch();for(J in R.matrixArray={},this._matrixArrays)R.matrixArray[J]=this._matrixArrays[J];for(J in R.matrices3x3={},this._matrices3x3)R.matrices3x3[J]=this._matrices3x3[J];for(J in R.matrices2x2={},this._matrices2x2)R.matrices2x2[J]=this._matrices2x2[J];for(J in R.vectors2Arrays={},this._vectors2Arrays)R.vectors2Arrays[J]=this._vectors2Arrays[J];for(J in R.vectors3Arrays={},this._vectors3Arrays)R.vectors3Arrays[J]=this._vectors3Arrays[J];for(J in R.vectors4Arrays={},this._vectors4Arrays)R.vectors4Arrays[J]=this._vectors4Arrays[J];for(J in R.quaternionsArrays={},this._quaternionsArrays)R.quaternionsArrays[J]=this._quaternionsArrays[J];return R}static Parse(R,J,B){const h=Q.c.Parse((()=>new A(R.name,J,R.shaderPath,R.options,R.storeEffectOnSubMeshes)),R,J,B);let N;for(N in R.stencil&&h.stencil.parse(R.stencil,J,B),R.textures)h.setTexture(N,r.d.Parse(R.textures[N],J,B));for(N in R.textureArrays){const Q=R.textureArrays[N],y=[];for(let R=0;R<Q.length;R++)y.push(r.d.Parse(Q[R],J,B));h.setTextureArray(N,y)}for(N in R.ints)h.setInt(N,R.ints[N]);for(N in R.uints)h.setUInt(N,R.uints[N]);for(N in R.floats)h.setFloat(N,R.floats[N]);for(N in R.floatsArrays)h.setFloats(N,R.floatsArrays[N]);for(N in R.colors3){const J=R.colors3[N];h.setColor3(N,{r:J[0],g:J[1],b:J[2]})}for(N in R.colors3Arrays){const J=R.colors3Arrays[N].reduce(((R,J,B)=>(B%3===0?R.push([J]):R[R.length-1].push(J),R)),[]).map((R=>({r:R[0],g:R[1],b:R[2]})));h.setColor3Array(N,J)}for(N in R.colors4){const J=R.colors4[N];h.setColor4(N,{r:J[0],g:J[1],b:J[2],a:J[3]})}for(N in R.colors4Arrays){const J=R.colors4Arrays[N].reduce(((R,J,B)=>(B%4===0?R.push([J]):R[R.length-1].push(J),R)),[]).map((R=>({r:R[0],g:R[1],b:R[2],a:R[3]})));h.setColor4Array(N,J)}for(N in R.vectors2){const J=R.vectors2[N];h.setVector2(N,{x:J[0],y:J[1]})}for(N in R.vectors3){const J=R.vectors3[N];h.setVector3(N,{x:J[0],y:J[1],z:J[2]})}for(N in R.vectors4){const J=R.vectors4[N];h.setVector4(N,{x:J[0],y:J[1],z:J[2],w:J[3]})}for(N in R.quaternions)h.setQuaternion(N,y.Quaternion.fJ(R.quaternions[N]));for(N in R.matrices)h.setMatrix(N,y.Matrix.fJ(R.matrices[N]));for(N in R.matrixArray)h._matrixArrays[N]=new Float32Array(R.matrixArray[N]);for(N in R.matrices3x3)h.setMatrix3x3(N,R.matrices3x3[N]);for(N in R.matrices2x2)h.setMatrix2x2(N,R.matrices2x2[N]);for(N in R.vectors2Arrays)h.setArray2(N,R.vectors2Arrays[N]);for(N in R.vectors3Arrays)h.setArray3(N,R.vectors3Arrays[N]);for(N in R.vectors4Arrays)h.setArray4(N,R.vectors4Arrays[N]);for(N in R.quaternionsArrays)h.setArray4(N,R.quaternionsArrays[N]);return h}static async ParseFromFileAsync(R,J,B){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((h,y)=>{const N=new D.c;N.addEventListener("readystatechange",(()=>{if(4==N.readyState)if(200==N.status){const J=JSON.parse(N.responseText),y=this.Parse(J,B||E.e.LastCreatedScene,Q);R&&(y.name=R),h(y)}else y("Unable to load the ShaderMaterial")})),N.open("GET",J),N.send()}))}static async ParseFromSnippetAsync(R,J){let B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((Q,h)=>{const y=new D.c;y.addEventListener("readystatechange",(()=>{if(4==y.readyState)if(200==y.status){const h=JSON.parse(JSON.parse(y.responseText).jsonPayload),N=JSON.parse(h.shaderMaterial),r=this.Parse(N,J||E.e.LastCreatedScene,B);r.snippetId=R,Q(r)}else h("Unable to load the snippet "+R)})),y.open("GET",this.SnippetUrl+"/"+R.replace(/#/g,"/")),y.send()}))}}A.SnippetUrl="https://snippet.babylonjs.com",A.CreateFromSnippetAsync=A.ParseFromSnippetAsync,(0,q.h)("BABYLON.ShaderMaterial",A)}}]);