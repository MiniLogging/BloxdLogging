"use strict";(self["9x1utqq1axc"]=self["9x1utqq1axc"]||[]).push([[22],{12549:(y,c,A)=>{A.r(c),A.d(c,{ShaderMaterial:()=>P});var l=A(12363),w=A(12553),N=A(12325),p=A(12400),W=A(12303),h=A(12283),I=A(12619),q=A(12182),o=A(12625),O=A(12184),L=A(12692),i=A(12683);const H={effect:null,subMesh:null};class P extends o.b{constructor(y,c,A){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(y,c,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new N.Matrix,this._cachedWorldViewProjectionMatrix=new N.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=A,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...l}}get shaderPath(){return this._shaderPath}set shaderPath(y){this._shaderPath=y}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(y){-1===this._options.uniforms.indexOf(y)&&this._options.uniforms.push(y)}setTexture(y,c){return-1===this._options.samplers.indexOf(y)&&this._options.samplers.push(y),this._textures[y]=c,this}removeTexture(y){delete this._textures[y]}setTextureArray(y,c){return-1===this._options.samplers.indexOf(y)&&this._options.samplers.push(y),this._checkUniform(y),this._textureArrays[y]=c,this}setExternalTexture(y,c){return-1===this._options.externalTextures.indexOf(y)&&this._options.externalTextures.push(y),this._externalTextures[y]=c,this}setFloat(y,c){return this._checkUniform(y),this._floats[y]=c,this}setInt(y,c){return this._checkUniform(y),this._ints[y]=c,this}setUInt(y,c){return this._checkUniform(y),this._uints[y]=c,this}setFloats(y,c){return this._checkUniform(y),this._floatsArrays[y]=c,this}setColor3(y,c){return this._checkUniform(y),this._colors3[y]=c,this}setColor3Array(y,c){return this._checkUniform(y),this._colors3Arrays[y]=c.reduce(((y,c)=>(y.push(c.r,c.g,c.b),y)),[]),this}setColor4(y,c){return this._checkUniform(y),this._colors4[y]=c,this}setColor4Array(y,c){return this._checkUniform(y),this._colors4Arrays[y]=c.reduce(((y,c)=>(y.push(c.r,c.g,c.b,c.a),y)),[]),this}setVector2(y,c){return this._checkUniform(y),this._vectors2[y]=c,this}setVector3(y,c){return this._checkUniform(y),this._vectors3[y]=c,this}setVector4(y,c){return this._checkUniform(y),this._vectors4[y]=c,this}setQuaternion(y,c){return this._checkUniform(y),this._quaternions[y]=c,this}setQuaternionArray(y,c){return this._checkUniform(y),this._quaternionsArrays[y]=c.reduce(((y,c)=>(c.toArray(y,y.length),y)),[]),this}setMatrix(y,c){return this._checkUniform(y),this._matrices[y]=c,this}setMatrices(y,c){this._checkUniform(y);const A=new Float32Array(16*c.length);for(let l=0;l<c.length;l++){c[l].copyToArray(A,16*l)}return this._matrixArrays[y]=A,this}setMatrix3x3(y,c){return this._checkUniform(y),this._matrices3x3[y]=c,this}setMatrix2x2(y,c){return this._checkUniform(y),this._matrices2x2[y]=c,this}setArray2(y,c){return this._checkUniform(y),this._vectors2Arrays[y]=c,this}setArray3(y,c){return this._checkUniform(y),this._vectors3Arrays[y]=c,this}setArray4(y,c){return this._checkUniform(y),this._vectors4Arrays[y]=c,this}setUniformBuffer(y,c){return-1===this._options.uniformBuffers.indexOf(y)&&this._options.uniformBuffers.push(y),this._uniformBuffers[y]=c,this}setTextureSampler(y,c){return-1===this._options.samplerObjects.indexOf(y)&&this._options.samplerObjects.push(y),this._textureSamplers[y]=c,this}setStorageBuffer(y,c){return-1===this._options.storageBuffers.indexOf(y)&&this._options.storageBuffers.push(y),this._storageBuffers[y]=c,this}setDefine(y,c){const A=y.trimEnd()+" ",l=this.options.defines.findIndex((c=>c===y||c.startsWith(A)));return l>=0&&this.options.defines.splice(l,1),("boolean"!==typeof c||c)&&this.options.defines.push(A+c),this}isReadyForSubMesh(y,c,A){return this.isReady(y,A,c)}isReady(y,c,A){var l;const N=A&&this._storeEffectOnSubMeshes;if(this.isFrozen){const y=N?A._drawWrapper:this._drawWrapper;if(y.effect&&y._wasPreviouslyReady&&y._wasPreviouslyUsingInstances===c)return!0}const W=this.mc(),h=W.getEngine(),q=[],o=[];let O=null,P=this._shaderPath,D=this._options.uniforms,t=this._options.uniformBuffers,s=this._options.samplers;h.getCaps().multiview&&W.activeCamera&&W.activeCamera.outputRenderTarget&&W.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,q.push("#define MULTIVIEW"),-1!==D.indexOf("viewProjection")&&-1===D.indexOf("viewProjectionR")&&D.push("viewProjectionR"));for(let w=0;w<this._options.defines.length;w++){const y=0===this._options.defines[w].indexOf("#define")?this._options.defines[w]:`#define ${this._options.defines[w]}`;q.push(y)}for(let w=0;w<this._options.attributes.length;w++)o.push(this._options.attributes[w]);if(y&&y.isVerticesDataPresent(p.e.ColorKind)&&(-1===o.indexOf(p.e.ColorKind)&&o.push(p.e.ColorKind),q.push("#define VERTEXCOLOR")),c&&(q.push("#define INSTANCES"),(0,i.eb)(o,this._materialHelperNeedsPreviousMatrices),null!==y&&void 0!==y&&y.hasThinInstances&&(q.push("#define THIN_INSTANCES"),y&&y.isVerticesDataPresent(p.e.ColorInstanceKind)&&(o.push(p.e.ColorInstanceKind),q.push("#define INSTANCESCOLOR")))),y&&y.useBones&&y.computeBonesUsingShaders&&y.skeleton){o.push(p.e.MatricesIndicesKind),o.push(p.e.MatricesWeightsKind),y.numBoneInfluencers>4&&(o.push(p.e.MatricesIndicesExtraKind),o.push(p.e.MatricesWeightsExtraKind));const c=y.skeleton;q.push("#define NUM_BONE_INFLUENCERS "+y.numBoneInfluencers),O=new I.c,O.addCPUSkinningFallback(0,y),c.isUsingTextureForMatrices?(q.push("#define BONETEXTURE"),-1===D.indexOf("boneTextureWidth")&&D.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(q.push("#define BonesPerMesh "+(c.bones.length+1)),-1===D.indexOf("mBones")&&D.push("mBones"))}else q.push("#define NUM_BONE_INFLUENCERS 0");let B=0;const X=y?y.morphTargetManager:null;if(X){const c=-1!==q.indexOf("#define UV1"),A=-1!==q.indexOf("#define UV2"),l=-1!==q.indexOf("#define TANGENT"),w=-1!==q.indexOf("#define NORMAL"),N=-1!==q.indexOf("#define VERTEXCOLOR");B=(0,i.I)(X,q,o,y,!0,w,l,c,A,N),X.isUsingTextureForTargets&&(-1===D.indexOf("morphTargetTextureIndices")&&D.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),B>0&&(D=D.slice(),D.push("morphTargetInfluences"),D.push("morphTargetCount"),D.push("morphTargetTextureInfo"),D.push("morphTargetTextureIndices"))}else q.push("#define NUM_MORPH_INFLUENCERS 0");if(y){const c=y.bakedVertexAnimationManager;c&&c.isEnabled&&(q.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===D.indexOf("bakedVertexAnimationSettings")&&D.push("bakedVertexAnimationSettings"),-1===D.indexOf("bakedVertexAnimationTextureSizeInverted")&&D.push("bakedVertexAnimationTextureSizeInverted"),-1===D.indexOf("bakedVertexAnimationTime")&&D.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,i.x)(o,y,q)}for(const w in this._textures)if(!this._textures[w].isReady())return!1;y&&this.needAlphaTestingForMesh(y)&&q.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,L.d)(D),(0,L.l)(this,W,q)),W.fogEnabled&&null!==y&&void 0!==y&&y.applyFog&&W.fogMode!==w.b.FOGMODE_NONE&&(q.push("#define FOG"),-1===D.indexOf("view")&&D.push("view"),-1===D.indexOf("vFogInfos")&&D.push("vFogInfos"),-1===D.indexOf("vFogColor")&&D.push("vFogColor")),this._useLogarithmicDepth&&(q.push("#define LOGARITHMICDEPTH"),-1===D.indexOf("logarithmicDepthConstant")&&D.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(D=D.slice(),t=t.slice(),s=s.slice(),P=this.customShaderNameResolve(this.name,D,t,s,q,o));const C=N?A._getDrawWrapper(void 0,!0):this._drawWrapper,K=(null===C||void 0===C?void 0:C.effect)??null,my=(null===C||void 0===C?void 0:C.defines)??null,T=q.join("\n");let z=K;return my!==T&&(z=h.createEffect(P,{attributes:o,uniformsNames:D,uniformBuffersNames:t,samplers:s,defines:T,fallbacks:O,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:B},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},h),N?A.setEffect(z,T,this._materialContext):C&&C.setEffect(z,T),this._onEffectCreatedObservable&&(H.effect=z,H.subMesh=A??(null===y||void 0===y?void 0:y.jc[0])??null,this._onEffectCreatedObservable.notifyObservers(H))),C._wasPreviouslyUsingInstances=!!c,!(null===(l=z)||void 0===l||!l.isReady())&&(K!==z&&W.resetCachedMaterial(),C._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(y,c){const A=c??this.getEffect();if(!A)return;const l=this._options.uniforms;-1!==l.indexOf("world")&&A.setMatrix("world",y);const w=this.mc();-1!==l.indexOf("worldView")&&(y.multiplyToRef(w.getViewMatrix(),this._cachedWorldViewMatrix),A.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==l.indexOf("worldViewProjection")&&(y.multiplyToRef(w.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),A.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==l.indexOf("view")&&A.setMatrix("view",w.getViewMatrix())}bindForSubMesh(y,c,A){var l;this.bind(y,c,null===(l=A._drawWrapperOverride)||void 0===l?void 0:l.effect,A)}bind(y,c,A,l){const w=l&&this._storeEffectOnSubMeshes,N=A??(w?l.effect:this.getEffect());if(!N)return;const p=this.mc();this._activeEffect=N,this.bindOnlyWorldMatrix(y,A);const W=this._options.uniformBuffers;let h=!1;if(N&&W&&W.length>0&&p.getEngine().supportsUniformBuffers)for(let o=0;o<W.length;++o){switch(W[o]){case"Mesh":c&&(c.getMeshUniformBuffer().bindToEffect(N,"Mesh"),c.transferToEffect(y));break;case"Scene":(0,i.o)(N,p.getSceneUniformBuffer()),p.finalizeSceneUbo(),h=!0}}const I=c&&w?this._mustRebind(p,N,l,c.visibility):p.getCachedMaterial()!==this;if(N&&I){let y;for(y in h||-1===this._options.uniforms.indexOf("view")||N.setMatrix("view",p.getViewMatrix()),h||-1===this._options.uniforms.indexOf("projection")||N.setMatrix("projection",p.getProjectionMatrix()),h||-1===this._options.uniforms.indexOf("viewProjection")||(N.setMatrix("viewProjection",p.getTransformMatrix()),this._multiview&&N.setMatrix("viewProjectionR",p._transformMatrixR)),p.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&N.setVector3("cameraPosition",p.activeCamera.globalPosition),(0,i.e)(c,N),(0,L.g)(N,this,p),this._useLogarithmicDepth&&(0,i.l)(w?l.materialDefines:N.defines,N,p),c&&(0,i.f)(p,c,N),this._textures)N.setTexture(y,this._textures[y]);for(y in this._textureArrays)N.setTextureArray(y,this._textureArrays[y]);for(y in this._ints)N.setInt(y,this._ints[y]);for(y in this._uints)N.setUInt(y,this._uints[y]);for(y in this._floats)N.setFloat(y,this._floats[y]);for(y in this._floatsArrays)N.setArray(y,this._floatsArrays[y]);for(y in this._colors3)N.setColor3(y,this._colors3[y]);for(y in this._colors3Arrays)N.setArray3(y,this._colors3Arrays[y]);for(y in this._colors4){const c=this._colors4[y];N.setFloat4(y,c.r,c.g,c.b,c.a)}for(y in this._colors4Arrays)N.setArray4(y,this._colors4Arrays[y]);for(y in this._vectors2)N.setVector2(y,this._vectors2[y]);for(y in this._vectors3)N.setVector3(y,this._vectors3[y]);for(y in this._vectors4)N.setVector4(y,this._vectors4[y]);for(y in this._quaternions)N.setQuaternion(y,this._quaternions[y]);for(y in this._matrices)N.setMatrix(y,this._matrices[y]);for(y in this._matrixArrays)N.setMatrices(y,this._matrixArrays[y]);for(y in this._matrices3x3)N.setMatrix3x3(y,this._matrices3x3[y]);for(y in this._matrices2x2)N.setMatrix2x2(y,this._matrices2x2[y]);for(y in this._vectors2Arrays)N.setArray2(y,this._vectors2Arrays[y]);for(y in this._vectors3Arrays)N.setArray3(y,this._vectors3Arrays[y]);for(y in this._vectors4Arrays)N.setArray4(y,this._vectors4Arrays[y]);for(y in this._quaternionsArrays)N.setArray4(y,this._quaternionsArrays[y]);for(y in this._uniformBuffers){const c=this._uniformBuffers[y].getBuffer();c&&N.bindUniformBuffer(c,y)}const A=p.getEngine(),W=A.setExternalTexture;if(W)for(y in this._externalTextures)W.call(A,y,this._externalTextures[y]);const I=A.setTextureSampler;if(I)for(y in this._textureSamplers)I.call(A,y,this._textureSamplers[y]);const q=A.setStorageBuffer;if(q)for(y in this._storageBuffers)q.call(A,y,this._storageBuffers[y])}if(N&&c&&(I||!this.isFrozen)){(0,i.m)(c,N),c.morphTargetManager&&c.morphTargetManager.isUsingTextureForTargets&&c.morphTargetManager._bind(N);const y=c.bakedVertexAnimationManager;if(y&&y.isEnabled){var q;const y=w?l._drawWrapper:this._drawWrapper;null===(q=c.bakedVertexAnimationManager)||void 0===q||q.bind(N,!!y._wasPreviouslyUsingInstances)}}this._afterBind(c,N,l)}getActiveTextures(){const y=super.getActiveTextures();for(const c in this._textures)y.push(this._textures[c]);for(const c in this._textureArrays){const A=this._textureArrays[c];for(let c=0;c<A.length;c++)y.push(A[c])}return y}hasTexture(y){if(super.hasTexture(y))return!0;for(const c in this._textures)if(this._textures[c]===y)return!0;for(const c in this._textureArrays){const A=this._textureArrays[c];for(let c=0;c<A.length;c++)if(A[c]===y)return!0}return!1}clone(y){const c=l.d.Clone((()=>new P(y,this.mc(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);c.name=y,c.id=y,"object"===typeof c._shaderPath&&(c._shaderPath={...c._shaderPath}),this._options={...this._options};const A=Object.keys(this._options);for(const l of A){const y=this._options[l];Array.isArray(y)&&(this._options[l]=y.slice(0))}this.Sc.copyTo(c.Sc);for(const l in this._textures)c.setTexture(l,this._textures[l]);for(const l in this._textureArrays)c.setTextureArray(l,this._textureArrays[l]);for(const l in this._externalTextures)c.setExternalTexture(l,this._externalTextures[l]);for(const l in this._ints)c.setInt(l,this._ints[l]);for(const l in this._uints)c.setUInt(l,this._uints[l]);for(const l in this._floats)c.setFloat(l,this._floats[l]);for(const l in this._floatsArrays)c.setFloats(l,this._floatsArrays[l]);for(const l in this._colors3)c.setColor3(l,this._colors3[l]);for(const l in this._colors3Arrays)c._colors3Arrays[l]=this._colors3Arrays[l];for(const l in this._colors4)c.setColor4(l,this._colors4[l]);for(const l in this._colors4Arrays)c._colors4Arrays[l]=this._colors4Arrays[l];for(const l in this._vectors2)c.setVector2(l,this._vectors2[l]);for(const l in this._vectors3)c.setVector3(l,this._vectors3[l]);for(const l in this._vectors4)c.setVector4(l,this._vectors4[l]);for(const l in this._quaternions)c.setQuaternion(l,this._quaternions[l]);for(const l in this._quaternionsArrays)c._quaternionsArrays[l]=this._quaternionsArrays[l];for(const l in this._matrices)c.setMatrix(l,this._matrices[l]);for(const l in this._matrixArrays)c._matrixArrays[l]=this._matrixArrays[l].slice();for(const l in this._matrices3x3)c.setMatrix3x3(l,this._matrices3x3[l]);for(const l in this._matrices2x2)c.setMatrix2x2(l,this._matrices2x2[l]);for(const l in this._vectors2Arrays)c.setArray2(l,this._vectors2Arrays[l]);for(const l in this._vectors3Arrays)c.setArray3(l,this._vectors3Arrays[l]);for(const l in this._vectors4Arrays)c.setArray4(l,this._vectors4Arrays[l]);for(const l in this._uniformBuffers)c.setUniformBuffer(l,this._uniformBuffers[l]);for(const l in this._textureSamplers)c.setTextureSampler(l,this._textureSamplers[l]);for(const l in this._storageBuffers)c.setStorageBuffer(l,this._storageBuffers[l]);return c}dispose(y,c,A){if(c){let y;for(y in this._textures)this._textures[y].dispose();for(y in this._textureArrays){const c=this._textureArrays[y];for(let y=0;y<c.length;y++)c[y].dispose()}}this._textures={},super.dispose(y,c,A)}serialize(){const y=l.d.Serialize(this);let c;for(c in y.customType="BABYLON.ShaderMaterial",y.uniqueId=this.uniqueId,y.options=this._options,y.shaderPath=this._shaderPath,y.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,y.Sc=this.Sc.serialize(),y.textures={},this._textures)y.textures[c]=this._textures[c].serialize();for(c in y.textureArrays={},this._textureArrays){y.textureArrays[c]=[];const A=this._textureArrays[c];for(let l=0;l<A.length;l++)y.textureArrays[c].push(A[l].serialize())}for(c in y.ints={},this._ints)y.ints[c]=this._ints[c];for(c in y.uints={},this._uints)y.uints[c]=this._uints[c];for(c in y.floats={},this._floats)y.floats[c]=this._floats[c];for(c in y.floatsArrays={},this._floatsArrays)y.floatsArrays[c]=this._floatsArrays[c];for(c in y.colors3={},this._colors3){const A=this._colors3[c];y.colors3[c]=[A.r,A.g,A.b]}for(c in y.colors3Arrays={},this._colors3Arrays)y.colors3Arrays[c]=this._colors3Arrays[c];for(c in y.colors4={},this._colors4){const A=this._colors4[c];y.colors4[c]=[A.r,A.g,A.b,A.a]}for(c in y.colors4Arrays={},this._colors4Arrays)y.colors4Arrays[c]=this._colors4Arrays[c];for(c in y.vectors2={},this._vectors2){const A=this._vectors2[c];y.vectors2[c]=[A.x,A.y]}for(c in y.vectors3={},this._vectors3){const A=this._vectors3[c];y.vectors3[c]=[A.x,A.y,A.z]}for(c in y.vectors4={},this._vectors4){const A=this._vectors4[c];y.vectors4[c]=[A.x,A.y,A.z,A.w]}for(c in y.quaternions={},this._quaternions)y.quaternions[c]=this._quaternions[c].fc();for(c in y.matrices={},this._matrices)y.matrices[c]=this._matrices[c].fc();for(c in y.matrixArray={},this._matrixArrays)y.matrixArray[c]=this._matrixArrays[c];for(c in y.matrices3x3={},this._matrices3x3)y.matrices3x3[c]=this._matrices3x3[c];for(c in y.matrices2x2={},this._matrices2x2)y.matrices2x2[c]=this._matrices2x2[c];for(c in y.vectors2Arrays={},this._vectors2Arrays)y.vectors2Arrays[c]=this._vectors2Arrays[c];for(c in y.vectors3Arrays={},this._vectors3Arrays)y.vectors3Arrays[c]=this._vectors3Arrays[c];for(c in y.vectors4Arrays={},this._vectors4Arrays)y.vectors4Arrays[c]=this._vectors4Arrays[c];for(c in y.quaternionsArrays={},this._quaternionsArrays)y.quaternionsArrays[c]=this._quaternionsArrays[c];return y}static Parse(y,c,A){const w=l.d.Parse((()=>new P(y.name,c,y.shaderPath,y.options,y.storeEffectOnSubMeshes)),y,c,A);let p;for(p in y.Sc&&w.Sc.parse(y.Sc,c,A),y.textures)w.setTexture(p,W.d.Parse(y.textures[p],c,A));for(p in y.textureArrays){const l=y.textureArrays[p],N=[];for(let y=0;y<l.length;y++)N.push(W.d.Parse(l[y],c,A));w.setTextureArray(p,N)}for(p in y.ints)w.setInt(p,y.ints[p]);for(p in y.uints)w.setUInt(p,y.uints[p]);for(p in y.floats)w.setFloat(p,y.floats[p]);for(p in y.floatsArrays)w.setFloats(p,y.floatsArrays[p]);for(p in y.colors3){const c=y.colors3[p];w.setColor3(p,{r:c[0],g:c[1],b:c[2]})}for(p in y.colors3Arrays){const c=y.colors3Arrays[p].reduce(((y,c,A)=>(A%3===0?y.push([c]):y[y.length-1].push(c),y)),[]).map((y=>({r:y[0],g:y[1],b:y[2]})));w.setColor3Array(p,c)}for(p in y.colors4){const c=y.colors4[p];w.setColor4(p,{r:c[0],g:c[1],b:c[2],a:c[3]})}for(p in y.colors4Arrays){const c=y.colors4Arrays[p].reduce(((y,c,A)=>(A%4===0?y.push([c]):y[y.length-1].push(c),y)),[]).map((y=>({r:y[0],g:y[1],b:y[2],a:y[3]})));w.setColor4Array(p,c)}for(p in y.vectors2){const c=y.vectors2[p];w.setVector2(p,{x:c[0],y:c[1]})}for(p in y.vectors3){const c=y.vectors3[p];w.setVector3(p,{x:c[0],y:c[1],z:c[2]})}for(p in y.vectors4){const c=y.vectors4[p];w.setVector4(p,{x:c[0],y:c[1],z:c[2],w:c[3]})}for(p in y.quaternions)w.setQuaternion(p,N.Quaternion.yA(y.quaternions[p]));for(p in y.matrices)w.setMatrix(p,N.Matrix.yA(y.matrices[p]));for(p in y.matrixArray)w._matrixArrays[p]=new Float32Array(y.matrixArray[p]);for(p in y.matrices3x3)w.setMatrix3x3(p,y.matrices3x3[p]);for(p in y.matrices2x2)w.setMatrix2x2(p,y.matrices2x2[p]);for(p in y.vectors2Arrays)w.setArray2(p,y.vectors2Arrays[p]);for(p in y.vectors3Arrays)w.setArray3(p,y.vectors3Arrays[p]);for(p in y.vectors4Arrays)w.setArray4(p,y.vectors4Arrays[p]);for(p in y.quaternionsArrays)w.setArray4(p,y.quaternionsArrays[p]);return w}static async ParseFromFileAsync(y,c,A){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((w,N)=>{const p=new q.d;p.addEventListener("readystatechange",(()=>{if(4==p.readyState)if(200==p.status){const c=JSON.parse(p.responseText),N=this.Parse(c,A||O.c.LastCreatedScene,l);y&&(N.name=y),w(N)}else N("Unable to load the ShaderMaterial")})),p.open("GET",c),p.send()}))}static async ParseFromSnippetAsync(y,c){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((l,w)=>{const N=new q.d;N.addEventListener("readystatechange",(()=>{if(4==N.readyState)if(200==N.status){const w=JSON.parse(JSON.parse(N.responseText).jsonPayload),p=JSON.parse(w.shaderMaterial),W=this.Parse(p,c||O.c.LastCreatedScene,A);W.snippetId=y,l(W)}else w("Unable to load the snippet "+y)})),N.open("GET",this.SnippetUrl+"/"+y.replace(/#/g,"/")),N.send()}))}}P.SnippetUrl="https://snippet.babylonjs.com",P.CreateFromSnippetAsync=P.ParseFromSnippetAsync,(0,h.f)("BABYLON.ShaderMaterial",P)}}]);