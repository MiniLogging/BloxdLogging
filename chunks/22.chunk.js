"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[22],{11539:(H,O,S)=>{S.r(O),S.d(O,{ShaderMaterial:()=>E});var t=S(11338),q=S(11541),p=S(11301),G=S(11378),U=S(11279),V=S(11262),w=S(11609),o=S(11175),h=S(11615),a=S(11180),j=S(11671),e=S(11669);const X={effect:null,subMesh:null};class E extends h.c{constructor(H,O,S){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(H,O,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new p.Matrix,this._cachedWorldViewProjectionMatrix=new p.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=S,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...t}}get shaderPath(){return this._shaderPath}set shaderPath(H){this._shaderPath=H}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(H){-1===this._options.uniforms.indexOf(H)&&this._options.uniforms.push(H)}setTexture(H,O){return-1===this._options.samplers.indexOf(H)&&this._options.samplers.push(H),this._textures[H]=O,this}removeTexture(H){delete this._textures[H]}setTextureArray(H,O){return-1===this._options.samplers.indexOf(H)&&this._options.samplers.push(H),this._checkUniform(H),this._textureArrays[H]=O,this}setExternalTexture(H,O){return-1===this._options.externalTextures.indexOf(H)&&this._options.externalTextures.push(H),this._externalTextures[H]=O,this}setFloat(H,O){return this._checkUniform(H),this._floats[H]=O,this}setInt(H,O){return this._checkUniform(H),this._ints[H]=O,this}setUInt(H,O){return this._checkUniform(H),this._uints[H]=O,this}setFloats(H,O){return this._checkUniform(H),this._floatsArrays[H]=O,this}setColor3(H,O){return this._checkUniform(H),this._colors3[H]=O,this}setColor3Array(H,O){return this._checkUniform(H),this._colors3Arrays[H]=O.reduce(((H,O)=>(H.push(O.r,O.g,O.b),H)),[]),this}setColor4(H,O){return this._checkUniform(H),this._colors4[H]=O,this}setColor4Array(H,O){return this._checkUniform(H),this._colors4Arrays[H]=O.reduce(((H,O)=>(H.push(O.r,O.g,O.b,O.a),H)),[]),this}setVector2(H,O){return this._checkUniform(H),this._vectors2[H]=O,this}setVector3(H,O){return this._checkUniform(H),this._vectors3[H]=O,this}setVector4(H,O){return this._checkUniform(H),this._vectors4[H]=O,this}setQuaternion(H,O){return this._checkUniform(H),this._quaternions[H]=O,this}setQuaternionArray(H,O){return this._checkUniform(H),this._quaternionsArrays[H]=O.reduce(((H,O)=>(O.toArray(H,H.length),H)),[]),this}setMatrix(H,O){return this._checkUniform(H),this._matrices[H]=O,this}setMatrices(H,O){this._checkUniform(H);const S=new Float32Array(16*O.length);for(let t=0;t<O.length;t++){O[t].copyToArray(S,16*t)}return this._matrixArrays[H]=S,this}setMatrix3x3(H,O){return this._checkUniform(H),this._matrices3x3[H]=O,this}setMatrix2x2(H,O){return this._checkUniform(H),this._matrices2x2[H]=O,this}setArray2(H,O){return this._checkUniform(H),this._vectors2Arrays[H]=O,this}setArray3(H,O){return this._checkUniform(H),this._vectors3Arrays[H]=O,this}setArray4(H,O){return this._checkUniform(H),this._vectors4Arrays[H]=O,this}setUniformBuffer(H,O){return-1===this._options.uniformBuffers.indexOf(H)&&this._options.uniformBuffers.push(H),this._uniformBuffers[H]=O,this}setTextureSampler(H,O){return-1===this._options.samplerObjects.indexOf(H)&&this._options.samplerObjects.push(H),this._textureSamplers[H]=O,this}setStorageBuffer(H,O){return-1===this._options.storageBuffers.indexOf(H)&&this._options.storageBuffers.push(H),this._storageBuffers[H]=O,this}setDefine(H,O){const S=H.trimEnd()+" ",t=this.options.defines.findIndex((O=>O===H||O.startsWith(S)));return t>=0&&this.options.defines.splice(t,1),("boolean"!==typeof O||O)&&this.options.defines.push(S+O),this}isReadyForSubMesh(H,O,S){return this.isReady(H,S,O)}isReady(H,O,S){var t;const p=S&&this._storeEffectOnSubMeshes;if(this.isFrozen){const H=p?S._drawWrapper:this._drawWrapper;if(H.effect&&H._wasPreviouslyReady&&H._wasPreviouslyUsingInstances===O)return!0}const U=this.YH(),V=U.getEngine(),o=[],h=[];let a=null,E=this._shaderPath,y=this._options.uniforms,T=this._options.uniformBuffers,K=this._options.samplers;V.getCaps().multiview&&U.activeCamera&&U.activeCamera.outputRenderTarget&&U.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,o.push("#define MULTIVIEW"),-1!==y.indexOf("viewProjection")&&-1===y.indexOf("viewProjectionR")&&y.push("viewProjectionR"));for(let q=0;q<this._options.defines.length;q++){const H=0===this._options.defines[q].indexOf("#define")?this._options.defines[q]:`#define ${this._options.defines[q]}`;o.push(H)}for(let q=0;q<this._options.attributes.length;q++)h.push(this._options.attributes[q]);if(H&&H.isVerticesDataPresent(G.h.ColorKind)&&(-1===h.indexOf(G.h.ColorKind)&&h.push(G.h.ColorKind),o.push("#define VERTEXCOLOR")),O&&(o.push("#define INSTANCES"),(0,e.Z)(h,this._materialHelperNeedsPreviousMatrices),null!==H&&void 0!==H&&H.hasThinInstances&&(o.push("#define THIN_INSTANCES"),H&&H.isVerticesDataPresent(G.h.ColorInstanceKind)&&(h.push(G.h.ColorInstanceKind),o.push("#define INSTANCESCOLOR")))),H&&H.useBones&&H.computeBonesUsingShaders&&H.skeleton){h.push(G.h.MatricesIndicesKind),h.push(G.h.MatricesWeightsKind),H.numBoneInfluencers>4&&(h.push(G.h.MatricesIndicesExtraKind),h.push(G.h.MatricesWeightsExtraKind));const O=H.skeleton;o.push("#define NUM_BONE_INFLUENCERS "+H.numBoneInfluencers),a=new w.c,a.addCPUSkinningFallback(0,H),O.isUsingTextureForMatrices?(o.push("#define BONETEXTURE"),-1===y.indexOf("boneTextureWidth")&&y.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(o.push("#define BonesPerMesh "+(O.bones.length+1)),-1===y.indexOf("mBones")&&y.push("mBones"))}else o.push("#define NUM_BONE_INFLUENCERS 0");let b=0;const D=H?H.morphTargetManager:null;if(D){const O=-1!==o.indexOf("#define UV1"),S=-1!==o.indexOf("#define UV2"),t=-1!==o.indexOf("#define TANGENT"),q=-1!==o.indexOf("#define NORMAL"),p=-1!==o.indexOf("#define VERTEXCOLOR");b=(0,e.F)(D,o,h,H,!0,q,t,O,S,p),D.isUsingTextureForTargets&&(-1===y.indexOf("morphTargetTextureIndices")&&y.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),b>0&&(y=y.slice(),y.push("morphTargetInfluences"),y.push("morphTargetCount"),y.push("morphTargetTextureInfo"),y.push("morphTargetTextureIndices"))}else o.push("#define NUM_MORPH_INFLUENCERS 0");if(H){const O=H.bakedVertexAnimationManager;O&&O.isEnabled&&(o.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===y.indexOf("bakedVertexAnimationSettings")&&y.push("bakedVertexAnimationSettings"),-1===y.indexOf("bakedVertexAnimationTextureSizeInverted")&&y.push("bakedVertexAnimationTextureSizeInverted"),-1===y.indexOf("bakedVertexAnimationTime")&&y.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,e.u)(h,H,o)}for(const q in this._textures)if(!this._textures[q].isReady())return!1;H&&this.needAlphaTestingForMesh(H)&&o.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,j.d)(y),(0,j.n)(this,U,o)),U.fogEnabled&&null!==H&&void 0!==H&&H.applyFog&&U.fogMode!==q.e.FOGMODE_NONE&&(o.push("#define FOG"),-1===y.indexOf("view")&&y.push("view"),-1===y.indexOf("vFogInfos")&&y.push("vFogInfos"),-1===y.indexOf("vFogColor")&&y.push("vFogColor")),this._useLogarithmicDepth&&(o.push("#define LOGARITHMICDEPTH"),-1===y.indexOf("logarithmicDepthConstant")&&y.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(y=y.slice(),T=T.slice(),K=K.slice(),E=this.customShaderNameResolve(this.name,y,T,K,o,h));const F=p?S._getDrawWrapper(void 0,!0):this._drawWrapper,Y=(null===F||void 0===F?void 0:F.effect)??null,l=(null===F||void 0===F?void 0:F.defines)??null,d=o.join("\n");let v=Y;return l!==d&&(v=V.createEffect(E,{attributes:h,uniformsNames:y,uniformBuffersNames:T,samplers:K,defines:d,fallbacks:a,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:b},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},V),p?S.setEffect(v,d,this._materialContext):F&&F.setEffect(v,d),this._onEffectCreatedObservable&&(X.effect=v,X.subMesh=S??(null===H||void 0===H?void 0:H.qU[0])??null,this._onEffectCreatedObservable.notifyObservers(X))),F._wasPreviouslyUsingInstances=!!O,!(null===(t=v)||void 0===t||!t.isReady())&&(Y!==v&&U.resetCachedMaterial(),F._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(H,O){const S=O??this.getEffect();if(!S)return;const t=this._options.uniforms;-1!==t.indexOf("world")&&S.setMatrix("world",H);const q=this.YH();-1!==t.indexOf("worldView")&&(H.multiplyToRef(q.getViewMatrix(),this._cachedWorldViewMatrix),S.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==t.indexOf("worldViewProjection")&&(H.multiplyToRef(q.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),S.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==t.indexOf("view")&&S.setMatrix("view",q.getViewMatrix())}bindForSubMesh(H,O,S){var t;this.bind(H,O,null===(t=S._drawWrapperOverride)||void 0===t?void 0:t.effect,S)}bind(H,O,S,t){const q=t&&this._storeEffectOnSubMeshes,p=S??(q?t.effect:this.getEffect());if(!p)return;const G=this.YH();this._activeEffect=p,this.bindOnlyWorldMatrix(H,S);const U=this._options.uniformBuffers;let V=!1;if(p&&U&&U.length>0&&G.getEngine().supportsUniformBuffers)for(let h=0;h<U.length;++h){switch(U[h]){case"Mesh":O&&(O.getMeshUniformBuffer().bindToEffect(p,"Mesh"),O.transferToEffect(H));break;case"Scene":(0,e.m)(p,G.getSceneUniformBuffer()),G.finalizeSceneUbo(),V=!0}}const w=O&&q?this._mustRebind(G,p,t,O.visibility):G.getCachedMaterial()!==this;if(p&&w){let H;for(H in V||-1===this._options.uniforms.indexOf("view")||p.setMatrix("view",G.getViewMatrix()),V||-1===this._options.uniforms.indexOf("projection")||p.setMatrix("projection",G.getProjectionMatrix()),V||-1===this._options.uniforms.indexOf("viewProjection")||(p.setMatrix("viewProjection",G.getTransformMatrix()),this._multiview&&p.setMatrix("viewProjectionR",G._transformMatrixR)),G.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&p.setVector3("cameraPosition",G.activeCamera.globalPosition),(0,e.c)(O,p),(0,j.g)(p,this,G),this._useLogarithmicDepth&&(0,e.h)(q?t.materialDefines:p.defines,p,G),O&&(0,e.f)(G,O,p),this._textures)p.setTexture(H,this._textures[H]);for(H in this._textureArrays)p.setTextureArray(H,this._textureArrays[H]);for(H in this._ints)p.setInt(H,this._ints[H]);for(H in this._uints)p.setUInt(H,this._uints[H]);for(H in this._floats)p.setFloat(H,this._floats[H]);for(H in this._floatsArrays)p.setArray(H,this._floatsArrays[H]);for(H in this._colors3)p.setColor3(H,this._colors3[H]);for(H in this._colors3Arrays)p.setArray3(H,this._colors3Arrays[H]);for(H in this._colors4){const O=this._colors4[H];p.setFloat4(H,O.r,O.g,O.b,O.a)}for(H in this._colors4Arrays)p.setArray4(H,this._colors4Arrays[H]);for(H in this._vectors2)p.setVector2(H,this._vectors2[H]);for(H in this._vectors3)p.setVector3(H,this._vectors3[H]);for(H in this._vectors4)p.setVector4(H,this._vectors4[H]);for(H in this._quaternions)p.setQuaternion(H,this._quaternions[H]);for(H in this._matrices)p.setMatrix(H,this._matrices[H]);for(H in this._matrixArrays)p.setMatrices(H,this._matrixArrays[H]);for(H in this._matrices3x3)p.setMatrix3x3(H,this._matrices3x3[H]);for(H in this._matrices2x2)p.setMatrix2x2(H,this._matrices2x2[H]);for(H in this._vectors2Arrays)p.setArray2(H,this._vectors2Arrays[H]);for(H in this._vectors3Arrays)p.setArray3(H,this._vectors3Arrays[H]);for(H in this._vectors4Arrays)p.setArray4(H,this._vectors4Arrays[H]);for(H in this._quaternionsArrays)p.setArray4(H,this._quaternionsArrays[H]);for(H in this._uniformBuffers){const O=this._uniformBuffers[H].getBuffer();O&&p.bindUniformBuffer(O,H)}const S=G.getEngine(),U=S.setExternalTexture;if(U)for(H in this._externalTextures)U.call(S,H,this._externalTextures[H]);const w=S.setTextureSampler;if(w)for(H in this._textureSamplers)w.call(S,H,this._textureSamplers[H]);const o=S.setStorageBuffer;if(o)for(H in this._storageBuffers)o.call(S,H,this._storageBuffers[H])}if(p&&O&&(w||!this.isFrozen)){(0,e.l)(O,p),O.morphTargetManager&&O.morphTargetManager.isUsingTextureForTargets&&O.morphTargetManager._bind(p);const H=O.bakedVertexAnimationManager;if(H&&H.isEnabled){var o;const H=q?t._drawWrapper:this._drawWrapper;null===(o=O.bakedVertexAnimationManager)||void 0===o||o.bind(p,!!H._wasPreviouslyUsingInstances)}}this._afterBind(O,p,t)}getActiveTextures(){const H=super.getActiveTextures();for(const O in this._textures)H.push(this._textures[O]);for(const O in this._textureArrays){const S=this._textureArrays[O];for(let O=0;O<S.length;O++)H.push(S[O])}return H}hasTexture(H){if(super.hasTexture(H))return!0;for(const O in this._textures)if(this._textures[O]===H)return!0;for(const O in this._textureArrays){const S=this._textureArrays[O];for(let O=0;O<S.length;O++)if(S[O]===H)return!0}return!1}clone(H){const O=t.e.Clone((()=>new E(H,this.YH(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);O.name=H,O.id=H,"object"===typeof O._shaderPath&&(O._shaderPath={...O._shaderPath}),this._options={...this._options};const S=Object.keys(this._options);for(const t of S){const H=this._options[t];Array.isArray(H)&&(this._options[t]=H.slice(0))}this.stencil.copyTo(O.stencil);for(const t in this._textures)O.setTexture(t,this._textures[t]);for(const t in this._textureArrays)O.setTextureArray(t,this._textureArrays[t]);for(const t in this._externalTextures)O.setExternalTexture(t,this._externalTextures[t]);for(const t in this._ints)O.setInt(t,this._ints[t]);for(const t in this._uints)O.setUInt(t,this._uints[t]);for(const t in this._floats)O.setFloat(t,this._floats[t]);for(const t in this._floatsArrays)O.setFloats(t,this._floatsArrays[t]);for(const t in this._colors3)O.setColor3(t,this._colors3[t]);for(const t in this._colors3Arrays)O._colors3Arrays[t]=this._colors3Arrays[t];for(const t in this._colors4)O.setColor4(t,this._colors4[t]);for(const t in this._colors4Arrays)O._colors4Arrays[t]=this._colors4Arrays[t];for(const t in this._vectors2)O.setVector2(t,this._vectors2[t]);for(const t in this._vectors3)O.setVector3(t,this._vectors3[t]);for(const t in this._vectors4)O.setVector4(t,this._vectors4[t]);for(const t in this._quaternions)O.setQuaternion(t,this._quaternions[t]);for(const t in this._quaternionsArrays)O._quaternionsArrays[t]=this._quaternionsArrays[t];for(const t in this._matrices)O.setMatrix(t,this._matrices[t]);for(const t in this._matrixArrays)O._matrixArrays[t]=this._matrixArrays[t].slice();for(const t in this._matrices3x3)O.setMatrix3x3(t,this._matrices3x3[t]);for(const t in this._matrices2x2)O.setMatrix2x2(t,this._matrices2x2[t]);for(const t in this._vectors2Arrays)O.setArray2(t,this._vectors2Arrays[t]);for(const t in this._vectors3Arrays)O.setArray3(t,this._vectors3Arrays[t]);for(const t in this._vectors4Arrays)O.setArray4(t,this._vectors4Arrays[t]);for(const t in this._uniformBuffers)O.setUniformBuffer(t,this._uniformBuffers[t]);for(const t in this._textureSamplers)O.setTextureSampler(t,this._textureSamplers[t]);for(const t in this._storageBuffers)O.setStorageBuffer(t,this._storageBuffers[t]);return O}dispose(H,O,S){if(O){let H;for(H in this._textures)this._textures[H].dispose();for(H in this._textureArrays){const O=this._textureArrays[H];for(let H=0;H<O.length;H++)O[H].dispose()}}this._textures={},super.dispose(H,O,S)}serialize(){const H=t.e.Serialize(this);let O;for(O in H.customType="BABYLON.ShaderMaterial",H.uniqueId=this.uniqueId,H.options=this._options,H.shaderPath=this._shaderPath,H.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,H.stencil=this.stencil.serialize(),H.textures={},this._textures)H.textures[O]=this._textures[O].serialize();for(O in H.textureArrays={},this._textureArrays){H.textureArrays[O]=[];const S=this._textureArrays[O];for(let t=0;t<S.length;t++)H.textureArrays[O].push(S[t].serialize())}for(O in H.ints={},this._ints)H.ints[O]=this._ints[O];for(O in H.uints={},this._uints)H.uints[O]=this._uints[O];for(O in H.floats={},this._floats)H.floats[O]=this._floats[O];for(O in H.floatsArrays={},this._floatsArrays)H.floatsArrays[O]=this._floatsArrays[O];for(O in H.colors3={},this._colors3){const S=this._colors3[O];H.colors3[O]=[S.r,S.g,S.b]}for(O in H.colors3Arrays={},this._colors3Arrays)H.colors3Arrays[O]=this._colors3Arrays[O];for(O in H.colors4={},this._colors4){const S=this._colors4[O];H.colors4[O]=[S.r,S.g,S.b,S.a]}for(O in H.colors4Arrays={},this._colors4Arrays)H.colors4Arrays[O]=this._colors4Arrays[O];for(O in H.vectors2={},this._vectors2){const S=this._vectors2[O];H.vectors2[O]=[S.x,S.y]}for(O in H.vectors3={},this._vectors3){const S=this._vectors3[O];H.vectors3[O]=[S.x,S.y,S.z]}for(O in H.vectors4={},this._vectors4){const S=this._vectors4[O];H.vectors4[O]=[S.x,S.y,S.z,S.w]}for(O in H.quaternions={},this._quaternions)H.quaternions[O]=this._quaternions[O].pU();for(O in H.matrices={},this._matrices)H.matrices[O]=this._matrices[O].pU();for(O in H.matrixArray={},this._matrixArrays)H.matrixArray[O]=this._matrixArrays[O];for(O in H.matrices3x3={},this._matrices3x3)H.matrices3x3[O]=this._matrices3x3[O];for(O in H.matrices2x2={},this._matrices2x2)H.matrices2x2[O]=this._matrices2x2[O];for(O in H.vectors2Arrays={},this._vectors2Arrays)H.vectors2Arrays[O]=this._vectors2Arrays[O];for(O in H.vectors3Arrays={},this._vectors3Arrays)H.vectors3Arrays[O]=this._vectors3Arrays[O];for(O in H.vectors4Arrays={},this._vectors4Arrays)H.vectors4Arrays[O]=this._vectors4Arrays[O];for(O in H.quaternionsArrays={},this._quaternionsArrays)H.quaternionsArrays[O]=this._quaternionsArrays[O];return H}static Parse(H,O,S){const q=t.e.Parse((()=>new E(H.name,O,H.shaderPath,H.options,H.storeEffectOnSubMeshes)),H,O,S);let G;for(G in H.stencil&&q.stencil.parse(H.stencil,O,S),H.textures)q.setTexture(G,U.b.Parse(H.textures[G],O,S));for(G in H.textureArrays){const t=H.textureArrays[G],p=[];for(let H=0;H<t.length;H++)p.push(U.b.Parse(t[H],O,S));q.setTextureArray(G,p)}for(G in H.ints)q.setInt(G,H.ints[G]);for(G in H.uints)q.setUInt(G,H.uints[G]);for(G in H.floats)q.setFloat(G,H.floats[G]);for(G in H.floatsArrays)q.setFloats(G,H.floatsArrays[G]);for(G in H.colors3){const O=H.colors3[G];q.setColor3(G,{r:O[0],g:O[1],b:O[2]})}for(G in H.colors3Arrays){const O=H.colors3Arrays[G].reduce(((H,O,S)=>(S%3===0?H.push([O]):H[H.length-1].push(O),H)),[]).map((H=>({r:H[0],g:H[1],b:H[2]})));q.setColor3Array(G,O)}for(G in H.colors4){const O=H.colors4[G];q.setColor4(G,{r:O[0],g:O[1],b:O[2],a:O[3]})}for(G in H.colors4Arrays){const O=H.colors4Arrays[G].reduce(((H,O,S)=>(S%4===0?H.push([O]):H[H.length-1].push(O),H)),[]).map((H=>({r:H[0],g:H[1],b:H[2],a:H[3]})));q.setColor4Array(G,O)}for(G in H.vectors2){const O=H.vectors2[G];q.setVector2(G,{x:O[0],y:O[1]})}for(G in H.vectors3){const O=H.vectors3[G];q.setVector3(G,{x:O[0],y:O[1],z:O[2]})}for(G in H.vectors4){const O=H.vectors4[G];q.setVector4(G,{x:O[0],y:O[1],z:O[2],w:O[3]})}for(G in H.quaternions)q.setQuaternion(G,p.Quaternion.KO(H.quaternions[G]));for(G in H.matrices)q.setMatrix(G,p.Matrix.KO(H.matrices[G]));for(G in H.matrixArray)q._matrixArrays[G]=new Float32Array(H.matrixArray[G]);for(G in H.matrices3x3)q.setMatrix3x3(G,H.matrices3x3[G]);for(G in H.matrices2x2)q.setMatrix2x2(G,H.matrices2x2[G]);for(G in H.vectors2Arrays)q.setArray2(G,H.vectors2Arrays[G]);for(G in H.vectors3Arrays)q.setArray3(G,H.vectors3Arrays[G]);for(G in H.vectors4Arrays)q.setArray4(G,H.vectors4Arrays[G]);for(G in H.quaternionsArrays)q.setArray4(G,H.quaternionsArrays[G]);return q}static async ParseFromFileAsync(H,O,S){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((q,p)=>{const G=new o.c;G.addEventListener("readystatechange",(()=>{if(4==G.readyState)if(200==G.status){const O=JSON.parse(G.responseText),p=this.Parse(O,S||a.c.LastCreatedScene,t);H&&(p.name=H),q(p)}else p("Unable to load the ShaderMaterial")})),G.open("GET",O),G.send()}))}static async ParseFromSnippetAsync(H,O){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((t,q)=>{const p=new o.c;p.addEventListener("readystatechange",(()=>{if(4==p.readyState)if(200==p.status){const q=JSON.parse(JSON.parse(p.responseText).jsonPayload),G=JSON.parse(q.shaderMaterial),U=this.Parse(G,O||a.c.LastCreatedScene,S);U.snippetId=H,t(U)}else q("Unable to load the snippet "+H)})),p.open("GET",this.SnippetUrl+"/"+H.replace(/#/g,"/")),p.send()}))}}E.SnippetUrl="https://snippet.babylonjs.com",E.CreateFromSnippetAsync=E.ParseFromSnippetAsync,(0,V.g)("BABYLON.ShaderMaterial",E)}}]);