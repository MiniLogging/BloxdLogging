"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[22],{12480:(I,O,C)=>{C.r(O),C.d(O,{ShaderMaterial:()=>E});var j=C(12296),K=C(12487),i=C(12272),y=C(12329),S=C(12245),U=C(12226),p=C(12556),N=C(12130),Q=C(12565),s=C(12132),Z=C(12599),q=C(12596);const mI={effect:null,subMesh:null};class E extends Q.b{constructor(I,O,C){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(I,O,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new i.Matrix,this._cachedWorldViewProjectionMatrix=new i.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=C,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...j}}get shaderPath(){return this._shaderPath}set shaderPath(I){this._shaderPath=I}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(I){-1===this._options.uniforms.indexOf(I)&&this._options.uniforms.push(I)}setTexture(I,O){return-1===this._options.samplers.indexOf(I)&&this._options.samplers.push(I),this._textures[I]=O,this}removeTexture(I){delete this._textures[I]}setTextureArray(I,O){return-1===this._options.samplers.indexOf(I)&&this._options.samplers.push(I),this._checkUniform(I),this._textureArrays[I]=O,this}setExternalTexture(I,O){return-1===this._options.externalTextures.indexOf(I)&&this._options.externalTextures.push(I),this._externalTextures[I]=O,this}setFloat(I,O){return this._checkUniform(I),this._floats[I]=O,this}setInt(I,O){return this._checkUniform(I),this._ints[I]=O,this}setUInt(I,O){return this._checkUniform(I),this._uints[I]=O,this}setFloats(I,O){return this._checkUniform(I),this._floatsArrays[I]=O,this}setColor3(I,O){return this._checkUniform(I),this._colors3[I]=O,this}setColor3Array(I,O){return this._checkUniform(I),this._colors3Arrays[I]=O.reduce(((I,O)=>(I.push(O.r,O.g,O.b),I)),[]),this}setColor4(I,O){return this._checkUniform(I),this._colors4[I]=O,this}setColor4Array(I,O){return this._checkUniform(I),this._colors4Arrays[I]=O.reduce(((I,O)=>(I.push(O.r,O.g,O.b,O.a),I)),[]),this}setVector2(I,O){return this._checkUniform(I),this._vectors2[I]=O,this}setVector3(I,O){return this._checkUniform(I),this._vectors3[I]=O,this}setVector4(I,O){return this._checkUniform(I),this._vectors4[I]=O,this}setQuaternion(I,O){return this._checkUniform(I),this._quaternions[I]=O,this}setQuaternionArray(I,O){return this._checkUniform(I),this._quaternionsArrays[I]=O.reduce(((I,O)=>(O.toArray(I,I.length),I)),[]),this}setMatrix(I,O){return this._checkUniform(I),this._matrices[I]=O,this}setMatrices(I,O){this._checkUniform(I);const C=new Float32Array(16*O.length);for(let j=0;j<O.length;j++){O[j].copyToArray(C,16*j)}return this._matrixArrays[I]=C,this}setMatrix3x3(I,O){return this._checkUniform(I),this._matrices3x3[I]=O,this}setMatrix2x2(I,O){return this._checkUniform(I),this._matrices2x2[I]=O,this}setArray2(I,O){return this._checkUniform(I),this._vectors2Arrays[I]=O,this}setArray3(I,O){return this._checkUniform(I),this._vectors3Arrays[I]=O,this}setArray4(I,O){return this._checkUniform(I),this._vectors4Arrays[I]=O,this}setUniformBuffer(I,O){return-1===this._options.uniformBuffers.indexOf(I)&&this._options.uniformBuffers.push(I),this._uniformBuffers[I]=O,this}setTextureSampler(I,O){return-1===this._options.samplerObjects.indexOf(I)&&this._options.samplerObjects.push(I),this._textureSamplers[I]=O,this}setStorageBuffer(I,O){return-1===this._options.storageBuffers.indexOf(I)&&this._options.storageBuffers.push(I),this._storageBuffers[I]=O,this}setDefine(I,O){const C=I.trimEnd()+" ",j=this.options.defines.findIndex((O=>O===I||O.startsWith(C)));return j>=0&&this.options.defines.splice(j,1),("boolean"!==typeof O||O)&&this.options.defines.push(C+O),this}isReadyForSubMesh(I,O,C){return this.isReady(I,C,O)}isReady(I,O,C){var j;const i=C&&this._storeEffectOnSubMeshes;if(this.isFrozen){const I=i?C._drawWrapper:this._drawWrapper;if(I.effect&&I._wasPreviouslyReady&&I._wasPreviouslyUsingInstances===O)return!0}const S=this.nI(),U=S.getEngine(),N=[],Q=[];let s=null,E=this._shaderPath,h=this._options.uniforms,r=this._options.uniformBuffers,W=this._options.samplers;U.getCaps().multiview&&S.activeCamera&&S.activeCamera.outputRenderTarget&&S.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,N.push("#define MULTIVIEW"),-1!==h.indexOf("viewProjection")&&-1===h.indexOf("viewProjectionR")&&h.push("viewProjectionR"));for(let K=0;K<this._options.defines.length;K++){const I=0===this._options.defines[K].indexOf("#define")?this._options.defines[K]:`#define ${this._options.defines[K]}`;N.push(I)}for(let K=0;K<this._options.attributes.length;K++)Q.push(this._options.attributes[K]);if(I&&I.isVerticesDataPresent(y.e.ColorKind)&&(-1===Q.indexOf(y.e.ColorKind)&&Q.push(y.e.ColorKind),N.push("#define VERTEXCOLOR")),O&&(N.push("#define INSTANCES"),(0,q.sb)(Q,this._materialHelperNeedsPreviousMatrices),null!==I&&void 0!==I&&I.hasThinInstances&&(N.push("#define THIN_INSTANCES"),I&&I.isVerticesDataPresent(y.e.ColorInstanceKind)&&(Q.push(y.e.ColorInstanceKind),N.push("#define INSTANCESCOLOR")))),I&&I.useBones&&I.computeBonesUsingShaders&&I.skeleton){Q.push(y.e.MatricesIndicesKind),Q.push(y.e.MatricesWeightsKind),I.numBoneInfluencers>4&&(Q.push(y.e.MatricesIndicesExtraKind),Q.push(y.e.MatricesWeightsExtraKind));const O=I.skeleton;N.push("#define NUM_BONE_INFLUENCERS "+I.numBoneInfluencers),s=new p.e,s.addCPUSkinningFallback(0,I),O.isUsingTextureForMatrices?(N.push("#define BONETEXTURE"),-1===h.indexOf("boneTextureWidth")&&h.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(N.push("#define BonesPerMesh "+(O.bones.length+1)),-1===h.indexOf("mBones")&&h.push("mBones"))}else N.push("#define NUM_BONE_INFLUENCERS 0");let Y=0;const o=I?I.morphTargetManager:null;if(o){const O=-1!==N.indexOf("#define UV1"),C=-1!==N.indexOf("#define UV2"),j=-1!==N.indexOf("#define TANGENT"),K=-1!==N.indexOf("#define NORMAL"),i=-1!==N.indexOf("#define VERTEXCOLOR");Y=(0,q.Q)(o,N,Q,I,!0,K,j,O,C,i),o.isUsingTextureForTargets&&(-1===h.indexOf("morphTargetTextureIndices")&&h.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),Y>0&&(h=h.slice(),h.push("morphTargetInfluences"),h.push("morphTargetCount"),h.push("morphTargetTextureInfo"),h.push("morphTargetTextureIndices"))}else N.push("#define NUM_MORPH_INFLUENCERS 0");if(I){const O=I.bakedVertexAnimationManager;O&&O.isEnabled&&(N.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===h.indexOf("bakedVertexAnimationSettings")&&h.push("bakedVertexAnimationSettings"),-1===h.indexOf("bakedVertexAnimationTextureSizeInverted")&&h.push("bakedVertexAnimationTextureSizeInverted"),-1===h.indexOf("bakedVertexAnimationTime")&&h.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,q.G)(Q,I,N)}for(const K in this._textures)if(!this._textures[K].isReady())return!1;I&&this.needAlphaTestingForMesh(I)&&N.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,Z.d)(h),(0,Z.j)(this,S,N)),S.fogEnabled&&null!==I&&void 0!==I&&I.applyFog&&S.fogMode!==K.b.FOGMODE_NONE&&(N.push("#define FOG"),-1===h.indexOf("view")&&h.push("view"),-1===h.indexOf("vFogInfos")&&h.push("vFogInfos"),-1===h.indexOf("vFogColor")&&h.push("vFogColor")),this._useLogarithmicDepth&&(N.push("#define LOGARITHMICDEPTH"),-1===h.indexOf("logarithmicDepthConstant")&&h.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(h=h.slice(),r=r.slice(),W=W.slice(),E=this.customShaderNameResolve(this.name,h,r,W,N,Q));const c=i?C._getDrawWrapper(void 0,!0):this._drawWrapper,n=(null===c||void 0===c?void 0:c.effect)??null,X=(null===c||void 0===c?void 0:c.defines)??null,T=N.join("\n");let H=n;return X!==T&&(H=U.createEffect(E,{attributes:Q,uniformsNames:h,uniformBuffersNames:r,samplers:W,defines:T,fallbacks:s,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:Y},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},U),i?C.setEffect(H,T,this._materialContext):c&&c.setEffect(H,T),this._onEffectCreatedObservable&&(mI.effect=H,mI.subMesh=C??(null===I||void 0===I?void 0:I.ZS[0])??null,this._onEffectCreatedObservable.notifyObservers(mI))),c._wasPreviouslyUsingInstances=!!O,!(null===(j=H)||void 0===j||!j.isReady())&&(n!==H&&S.resetCachedMaterial(),c._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(I,O){const C=O??this.getEffect();if(!C)return;const j=this._options.uniforms;-1!==j.indexOf("world")&&C.setMatrix("world",I);const K=this.nI();-1!==j.indexOf("worldView")&&(I.multiplyToRef(K.getViewMatrix(),this._cachedWorldViewMatrix),C.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==j.indexOf("worldViewProjection")&&(I.multiplyToRef(K.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),C.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==j.indexOf("view")&&C.setMatrix("view",K.getViewMatrix())}bindForSubMesh(I,O,C){var j;this.bind(I,O,null===(j=C._drawWrapperOverride)||void 0===j?void 0:j.effect,C)}bind(I,O,C,j){const K=j&&this._storeEffectOnSubMeshes,i=C??(K?j.effect:this.getEffect());if(!i)return;const y=this.nI();this._activeEffect=i,this.bindOnlyWorldMatrix(I,C);const S=this._options.uniformBuffers;let U=!1;if(i&&S&&S.length>0&&y.getEngine().supportsUniformBuffers)for(let Q=0;Q<S.length;++Q){switch(S[Q]){case"Mesh":O&&(O.getMeshUniformBuffer().bindToEffect(i,"Mesh"),O.transferToEffect(I));break;case"Scene":(0,q.w)(i,y.getSceneUniformBuffer()),y.finalizeSceneUbo(),U=!0}}const p=O&&K?this._mustRebind(y,i,j,O.visibility):y.getCachedMaterial()!==this;if(i&&p){let I;for(I in U||-1===this._options.uniforms.indexOf("view")||i.setMatrix("view",y.getViewMatrix()),U||-1===this._options.uniforms.indexOf("projection")||i.setMatrix("projection",y.getProjectionMatrix()),U||-1===this._options.uniforms.indexOf("viewProjection")||(i.setMatrix("viewProjection",y.getTransformMatrix()),this._multiview&&i.setMatrix("viewProjectionR",y._transformMatrixR)),y.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&i.setVector3("cameraPosition",y.activeCamera.globalPosition),(0,q.d)(O,i),(0,Z.g)(i,this,y),this._useLogarithmicDepth&&(0,q.o)(K?j.materialDefines:i.defines,i,y),O&&(0,q.h)(y,O,i),this._textures)i.setTexture(I,this._textures[I]);for(I in this._textureArrays)i.setTextureArray(I,this._textureArrays[I]);for(I in this._ints)i.setInt(I,this._ints[I]);for(I in this._uints)i.setUInt(I,this._uints[I]);for(I in this._floats)i.setFloat(I,this._floats[I]);for(I in this._floatsArrays)i.setArray(I,this._floatsArrays[I]);for(I in this._colors3)i.setColor3(I,this._colors3[I]);for(I in this._colors3Arrays)i.setArray3(I,this._colors3Arrays[I]);for(I in this._colors4){const O=this._colors4[I];i.setFloat4(I,O.r,O.g,O.b,O.a)}for(I in this._colors4Arrays)i.setArray4(I,this._colors4Arrays[I]);for(I in this._vectors2)i.setVector2(I,this._vectors2[I]);for(I in this._vectors3)i.setVector3(I,this._vectors3[I]);for(I in this._vectors4)i.setVector4(I,this._vectors4[I]);for(I in this._quaternions)i.setQuaternion(I,this._quaternions[I]);for(I in this._matrices)i.setMatrix(I,this._matrices[I]);for(I in this._matrixArrays)i.setMatrices(I,this._matrixArrays[I]);for(I in this._matrices3x3)i.setMatrix3x3(I,this._matrices3x3[I]);for(I in this._matrices2x2)i.setMatrix2x2(I,this._matrices2x2[I]);for(I in this._vectors2Arrays)i.setArray2(I,this._vectors2Arrays[I]);for(I in this._vectors3Arrays)i.setArray3(I,this._vectors3Arrays[I]);for(I in this._vectors4Arrays)i.setArray4(I,this._vectors4Arrays[I]);for(I in this._quaternionsArrays)i.setArray4(I,this._quaternionsArrays[I]);for(I in this._uniformBuffers){const O=this._uniformBuffers[I].getBuffer();O&&i.bindUniformBuffer(O,I)}const C=y.getEngine(),S=C.setExternalTexture;if(S)for(I in this._externalTextures)S.call(C,I,this._externalTextures[I]);const p=C.setTextureSampler;if(p)for(I in this._textureSamplers)p.call(C,I,this._textureSamplers[I]);const N=C.setStorageBuffer;if(N)for(I in this._storageBuffers)N.call(C,I,this._storageBuffers[I])}if(i&&O&&(p||!this.isFrozen)){(0,q.s)(O,i),O.morphTargetManager&&O.morphTargetManager.isUsingTextureForTargets&&O.morphTargetManager._bind(i);const I=O.bakedVertexAnimationManager;if(I&&I.isEnabled){var N;const I=K?j._drawWrapper:this._drawWrapper;null===(N=O.bakedVertexAnimationManager)||void 0===N||N.bind(i,!!I._wasPreviouslyUsingInstances)}}this._afterBind(O,i,j)}getActiveTextures(){const I=super.getActiveTextures();for(const O in this._textures)I.push(this._textures[O]);for(const O in this._textureArrays){const C=this._textureArrays[O];for(let O=0;O<C.length;O++)I.push(C[O])}return I}hasTexture(I){if(super.hasTexture(I))return!0;for(const O in this._textures)if(this._textures[O]===I)return!0;for(const O in this._textureArrays){const C=this._textureArrays[O];for(let O=0;O<C.length;O++)if(C[O]===I)return!0}return!1}clone(I){const O=j.e.Clone((()=>new E(I,this.nI(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);O.name=I,O.id=I,"object"===typeof O._shaderPath&&(O._shaderPath={...O._shaderPath}),this._options={...this._options};const C=Object.keys(this._options);for(const j of C){const I=this._options[j];Array.isArray(I)&&(this._options[j]=I.slice(0))}this.SS.copyTo(O.SS);for(const j in this._textures)O.setTexture(j,this._textures[j]);for(const j in this._textureArrays)O.setTextureArray(j,this._textureArrays[j]);for(const j in this._externalTextures)O.setExternalTexture(j,this._externalTextures[j]);for(const j in this._ints)O.setInt(j,this._ints[j]);for(const j in this._uints)O.setUInt(j,this._uints[j]);for(const j in this._floats)O.setFloat(j,this._floats[j]);for(const j in this._floatsArrays)O.setFloats(j,this._floatsArrays[j]);for(const j in this._colors3)O.setColor3(j,this._colors3[j]);for(const j in this._colors3Arrays)O._colors3Arrays[j]=this._colors3Arrays[j];for(const j in this._colors4)O.setColor4(j,this._colors4[j]);for(const j in this._colors4Arrays)O._colors4Arrays[j]=this._colors4Arrays[j];for(const j in this._vectors2)O.setVector2(j,this._vectors2[j]);for(const j in this._vectors3)O.setVector3(j,this._vectors3[j]);for(const j in this._vectors4)O.setVector4(j,this._vectors4[j]);for(const j in this._quaternions)O.setQuaternion(j,this._quaternions[j]);for(const j in this._quaternionsArrays)O._quaternionsArrays[j]=this._quaternionsArrays[j];for(const j in this._matrices)O.setMatrix(j,this._matrices[j]);for(const j in this._matrixArrays)O._matrixArrays[j]=this._matrixArrays[j].slice();for(const j in this._matrices3x3)O.setMatrix3x3(j,this._matrices3x3[j]);for(const j in this._matrices2x2)O.setMatrix2x2(j,this._matrices2x2[j]);for(const j in this._vectors2Arrays)O.setArray2(j,this._vectors2Arrays[j]);for(const j in this._vectors3Arrays)O.setArray3(j,this._vectors3Arrays[j]);for(const j in this._vectors4Arrays)O.setArray4(j,this._vectors4Arrays[j]);for(const j in this._uniformBuffers)O.setUniformBuffer(j,this._uniformBuffers[j]);for(const j in this._textureSamplers)O.setTextureSampler(j,this._textureSamplers[j]);for(const j in this._storageBuffers)O.setStorageBuffer(j,this._storageBuffers[j]);return O}dispose(I,O,C){if(O){let I;for(I in this._textures)this._textures[I].dispose();for(I in this._textureArrays){const O=this._textureArrays[I];for(let I=0;I<O.length;I++)O[I].dispose()}}this._textures={},super.dispose(I,O,C)}serialize(){const I=j.e.Serialize(this);let O;for(O in I.customType="BABYLON.ShaderMaterial",I.uniqueId=this.uniqueId,I.options=this._options,I.shaderPath=this._shaderPath,I.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,I.SS=this.SS.serialize(),I.textures={},this._textures)I.textures[O]=this._textures[O].serialize();for(O in I.textureArrays={},this._textureArrays){I.textureArrays[O]=[];const C=this._textureArrays[O];for(let j=0;j<C.length;j++)I.textureArrays[O].push(C[j].serialize())}for(O in I.ints={},this._ints)I.ints[O]=this._ints[O];for(O in I.uints={},this._uints)I.uints[O]=this._uints[O];for(O in I.floats={},this._floats)I.floats[O]=this._floats[O];for(O in I.floatsArrays={},this._floatsArrays)I.floatsArrays[O]=this._floatsArrays[O];for(O in I.colors3={},this._colors3){const C=this._colors3[O];I.colors3[O]=[C.r,C.g,C.b]}for(O in I.colors3Arrays={},this._colors3Arrays)I.colors3Arrays[O]=this._colors3Arrays[O];for(O in I.colors4={},this._colors4){const C=this._colors4[O];I.colors4[O]=[C.r,C.g,C.b,C.a]}for(O in I.colors4Arrays={},this._colors4Arrays)I.colors4Arrays[O]=this._colors4Arrays[O];for(O in I.vectors2={},this._vectors2){const C=this._vectors2[O];I.vectors2[O]=[C.x,C.y]}for(O in I.vectors3={},this._vectors3){const C=this._vectors3[O];I.vectors3[O]=[C.x,C.y,C.z]}for(O in I.vectors4={},this._vectors4){const C=this._vectors4[O];I.vectors4[O]=[C.x,C.y,C.z,C.w]}for(O in I.quaternions={},this._quaternions)I.quaternions[O]=this._quaternions[O].qS();for(O in I.matrices={},this._matrices)I.matrices[O]=this._matrices[O].qS();for(O in I.matrixArray={},this._matrixArrays)I.matrixArray[O]=this._matrixArrays[O];for(O in I.matrices3x3={},this._matrices3x3)I.matrices3x3[O]=this._matrices3x3[O];for(O in I.matrices2x2={},this._matrices2x2)I.matrices2x2[O]=this._matrices2x2[O];for(O in I.vectors2Arrays={},this._vectors2Arrays)I.vectors2Arrays[O]=this._vectors2Arrays[O];for(O in I.vectors3Arrays={},this._vectors3Arrays)I.vectors3Arrays[O]=this._vectors3Arrays[O];for(O in I.vectors4Arrays={},this._vectors4Arrays)I.vectors4Arrays[O]=this._vectors4Arrays[O];for(O in I.quaternionsArrays={},this._quaternionsArrays)I.quaternionsArrays[O]=this._quaternionsArrays[O];return I}static Parse(I,O,C){const K=j.e.Parse((()=>new E(I.name,O,I.shaderPath,I.options,I.storeEffectOnSubMeshes)),I,O,C);let y;for(y in I.SS&&K.SS.parse(I.SS,O,C),I.textures)K.setTexture(y,S.e.Parse(I.textures[y],O,C));for(y in I.textureArrays){const j=I.textureArrays[y],i=[];for(let I=0;I<j.length;I++)i.push(S.e.Parse(j[I],O,C));K.setTextureArray(y,i)}for(y in I.ints)K.setInt(y,I.ints[y]);for(y in I.uints)K.setUInt(y,I.uints[y]);for(y in I.floats)K.setFloat(y,I.floats[y]);for(y in I.floatsArrays)K.setFloats(y,I.floatsArrays[y]);for(y in I.colors3){const O=I.colors3[y];K.setColor3(y,{r:O[0],g:O[1],b:O[2]})}for(y in I.colors3Arrays){const O=I.colors3Arrays[y].reduce(((I,O,C)=>(C%3===0?I.push([O]):I[I.length-1].push(O),I)),[]).map((I=>({r:I[0],g:I[1],b:I[2]})));K.setColor3Array(y,O)}for(y in I.colors4){const O=I.colors4[y];K.setColor4(y,{r:O[0],g:O[1],b:O[2],a:O[3]})}for(y in I.colors4Arrays){const O=I.colors4Arrays[y].reduce(((I,O,C)=>(C%4===0?I.push([O]):I[I.length-1].push(O),I)),[]).map((I=>({r:I[0],g:I[1],b:I[2],a:I[3]})));K.setColor4Array(y,O)}for(y in I.vectors2){const O=I.vectors2[y];K.setVector2(y,{x:O[0],y:O[1]})}for(y in I.vectors3){const O=I.vectors3[y];K.setVector3(y,{x:O[0],y:O[1],z:O[2]})}for(y in I.vectors4){const O=I.vectors4[y];K.setVector4(y,{x:O[0],y:O[1],z:O[2],w:O[3]})}for(y in I.quaternions)K.setQuaternion(y,i.Quaternion.YO(I.quaternions[y]));for(y in I.matrices)K.setMatrix(y,i.Matrix.YO(I.matrices[y]));for(y in I.matrixArray)K._matrixArrays[y]=new Float32Array(I.matrixArray[y]);for(y in I.matrices3x3)K.setMatrix3x3(y,I.matrices3x3[y]);for(y in I.matrices2x2)K.setMatrix2x2(y,I.matrices2x2[y]);for(y in I.vectors2Arrays)K.setArray2(y,I.vectors2Arrays[y]);for(y in I.vectors3Arrays)K.setArray3(y,I.vectors3Arrays[y]);for(y in I.vectors4Arrays)K.setArray4(y,I.vectors4Arrays[y]);for(y in I.quaternionsArrays)K.setArray4(y,I.quaternionsArrays[y]);return K}static async ParseFromFileAsync(I,O,C){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((K,i)=>{const y=new N.d;y.addEventListener("readystatechange",(()=>{if(4==y.readyState)if(200==y.status){const O=JSON.parse(y.responseText),i=this.Parse(O,C||s.e.LastCreatedScene,j);I&&(i.name=I),K(i)}else i("Unable to load the ShaderMaterial")})),y.open("GET",O),y.send()}))}static async ParseFromSnippetAsync(I,O){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((j,K)=>{const i=new N.d;i.addEventListener("readystatechange",(()=>{if(4==i.readyState)if(200==i.status){const K=JSON.parse(JSON.parse(i.responseText).jsonPayload),y=JSON.parse(K.shaderMaterial),S=this.Parse(y,O||s.e.LastCreatedScene,C);S.snippetId=I,j(S)}else K("Unable to load the snippet "+I)})),i.open("GET",this.SnippetUrl+"/"+I.replace(/#/g,"/")),i.send()}))}}E.SnippetUrl="https://snippet.babylonjs.com",E.CreateFromSnippetAsync=E.ParseFromSnippetAsync,(0,U.e)("BABYLON.ShaderMaterial",E)}}]);