"use strict";(self.h66iwo8dvgq=self.h66iwo8dvgq||[]).push([[22],{12084:(b,X,P)=>{P.r(X),P.d(X,{ShaderMaterial:()=>t});var Q=P(11862),S=P(12093),d=P(11834),N=P(11912),a=P(11814),u=P(11802),w=P(12163),f=P(11728),O=P(12169),e=P(11732),Y=P(12229),D=P(12221);const E={effect:null,subMesh:null};class t extends O.d{constructor(b,X,P){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(b,X,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new d.Matrix,this._cachedWorldViewProjectionMatrix=new d.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=P,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...Q}}get shaderPath(){return this._shaderPath}set shaderPath(b){this._shaderPath=b}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(b){-1===this._options.uniforms.indexOf(b)&&this._options.uniforms.push(b)}setTexture(b,X){return-1===this._options.samplers.indexOf(b)&&this._options.samplers.push(b),this._textures[b]=X,this}removeTexture(b){delete this._textures[b]}setTextureArray(b,X){return-1===this._options.samplers.indexOf(b)&&this._options.samplers.push(b),this._checkUniform(b),this._textureArrays[b]=X,this}setExternalTexture(b,X){return-1===this._options.externalTextures.indexOf(b)&&this._options.externalTextures.push(b),this._externalTextures[b]=X,this}setFloat(b,X){return this._checkUniform(b),this._floats[b]=X,this}setInt(b,X){return this._checkUniform(b),this._ints[b]=X,this}setUInt(b,X){return this._checkUniform(b),this._uints[b]=X,this}setFloats(b,X){return this._checkUniform(b),this._floatsArrays[b]=X,this}setColor3(b,X){return this._checkUniform(b),this._colors3[b]=X,this}setColor3Array(b,X){return this._checkUniform(b),this._colors3Arrays[b]=X.reduce(((b,X)=>(b.push(X.r,X.g,X.b),b)),[]),this}setColor4(b,X){return this._checkUniform(b),this._colors4[b]=X,this}setColor4Array(b,X){return this._checkUniform(b),this._colors4Arrays[b]=X.reduce(((b,X)=>(b.push(X.r,X.g,X.b,X.a),b)),[]),this}setVector2(b,X){return this._checkUniform(b),this._vectors2[b]=X,this}setVector3(b,X){return this._checkUniform(b),this._vectors3[b]=X,this}setVector4(b,X){return this._checkUniform(b),this._vectors4[b]=X,this}setQuaternion(b,X){return this._checkUniform(b),this._quaternions[b]=X,this}setQuaternionArray(b,X){return this._checkUniform(b),this._quaternionsArrays[b]=X.reduce(((b,X)=>(X.toArray(b,b.length),b)),[]),this}setMatrix(b,X){return this._checkUniform(b),this._matrices[b]=X,this}setMatrices(b,X){this._checkUniform(b);const P=new Float32Array(16*X.length);for(let Q=0;Q<X.length;Q++){X[Q].copyToArray(P,16*Q)}return this._matrixArrays[b]=P,this}setMatrix3x3(b,X){return this._checkUniform(b),this._matrices3x3[b]=X,this}setMatrix2x2(b,X){return this._checkUniform(b),this._matrices2x2[b]=X,this}setArray2(b,X){return this._checkUniform(b),this._vectors2Arrays[b]=X,this}setArray3(b,X){return this._checkUniform(b),this._vectors3Arrays[b]=X,this}setArray4(b,X){return this._checkUniform(b),this._vectors4Arrays[b]=X,this}setUniformBuffer(b,X){return-1===this._options.uniformBuffers.indexOf(b)&&this._options.uniformBuffers.push(b),this._uniformBuffers[b]=X,this}setTextureSampler(b,X){return-1===this._options.samplerObjects.indexOf(b)&&this._options.samplerObjects.push(b),this._textureSamplers[b]=X,this}setStorageBuffer(b,X){return-1===this._options.storageBuffers.indexOf(b)&&this._options.storageBuffers.push(b),this._storageBuffers[b]=X,this}setDefine(b,X){const P=b.trimEnd()+" ",Q=this.options.defines.findIndex((X=>X===b||X.startsWith(P)));return Q>=0&&this.options.defines.splice(Q,1),("boolean"!==typeof X||X)&&this.options.defines.push(P+X),this}isReadyForSubMesh(b,X,P){return this.isReady(b,P,X)}isReady(b,X,P){var Q;const d=P&&this._storeEffectOnSubMeshes;if(this.isFrozen){const b=d?P._drawWrapper:this._drawWrapper;if(b.effect&&b._wasPreviouslyReady&&b._wasPreviouslyUsingInstances===X)return!0}const a=this.Ab(),u=a.getEngine(),f=[],O=[];let e=null,t=this._shaderPath,B=this._options.uniforms,W=this._options.uniformBuffers,n=this._options.samplers;u.getCaps().multiview&&a.activeCamera&&a.activeCamera.outputRenderTarget&&a.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,f.push("#define MULTIVIEW"),-1!==B.indexOf("viewProjection")&&-1===B.indexOf("viewProjectionR")&&B.push("viewProjectionR"));for(let S=0;S<this._options.defines.length;S++){const b=0===this._options.defines[S].indexOf("#define")?this._options.defines[S]:`#define ${this._options.defines[S]}`;f.push(b)}for(let S=0;S<this._options.attributes.length;S++)O.push(this._options.attributes[S]);if(b&&b.isVerticesDataPresent(N.g.ColorKind)&&(-1===O.indexOf(N.g.ColorKind)&&O.push(N.g.ColorKind),f.push("#define VERTEXCOLOR")),X&&(f.push("#define INSTANCES"),(0,D.lb)(O,this._materialHelperNeedsPreviousMatrices),null!==b&&void 0!==b&&b.hasThinInstances&&(f.push("#define THIN_INSTANCES"),b&&b.isVerticesDataPresent(N.g.ColorInstanceKind)&&(O.push(N.g.ColorInstanceKind),f.push("#define INSTANCESCOLOR")))),b&&b.useBones&&b.computeBonesUsingShaders&&b.skeleton){O.push(N.g.MatricesIndicesKind),O.push(N.g.MatricesWeightsKind),b.numBoneInfluencers>4&&(O.push(N.g.MatricesIndicesExtraKind),O.push(N.g.MatricesWeightsExtraKind));const X=b.skeleton;f.push("#define NUM_BONE_INFLUENCERS "+b.numBoneInfluencers),e=new w.c,e.addCPUSkinningFallback(0,b),X.isUsingTextureForMatrices?(f.push("#define BONETEXTURE"),-1===B.indexOf("boneTextureWidth")&&B.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(f.push("#define BonesPerMesh "+(X.bones.length+1)),-1===B.indexOf("mBones")&&B.push("mBones"))}else f.push("#define NUM_BONE_INFLUENCERS 0");let y=0;const h=b?b.morphTargetManager:null;if(h){const X=-1!==f.indexOf("#define UV1"),P=-1!==f.indexOf("#define UV2"),Q=-1!==f.indexOf("#define TANGENT"),S=-1!==f.indexOf("#define NORMAL"),d=-1!==f.indexOf("#define VERTEXCOLOR");y=(0,D.L)(h,f,O,b,!0,S,Q,X,P,d),h.isUsingTextureForTargets&&(-1===B.indexOf("morphTargetTextureIndices")&&B.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),y>0&&(B=B.slice(),B.push("morphTargetInfluences"),B.push("morphTargetCount"),B.push("morphTargetTextureInfo"),B.push("morphTargetTextureIndices"))}else f.push("#define NUM_MORPH_INFLUENCERS 0");if(b){const X=b.bakedVertexAnimationManager;X&&X.isEnabled&&(f.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===B.indexOf("bakedVertexAnimationSettings")&&B.push("bakedVertexAnimationSettings"),-1===B.indexOf("bakedVertexAnimationTextureSizeInverted")&&B.push("bakedVertexAnimationTextureSizeInverted"),-1===B.indexOf("bakedVertexAnimationTime")&&B.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,D.B)(O,b,f)}for(const S in this._textures)if(!this._textures[S].isReady())return!1;b&&this.needAlphaTestingForMesh(b)&&f.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,Y.e)(B),(0,Y.m)(this,a,f)),a.fogEnabled&&null!==b&&void 0!==b&&b.applyFog&&a.fogMode!==S.e.FOGMODE_NONE&&(f.push("#define FOG"),-1===B.indexOf("view")&&B.push("view"),-1===B.indexOf("vFogInfos")&&B.push("vFogInfos"),-1===B.indexOf("vFogColor")&&B.push("vFogColor")),this._useLogarithmicDepth&&(f.push("#define LOGARITHMICDEPTH"),-1===B.indexOf("logarithmicDepthConstant")&&B.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(B=B.slice(),W=W.slice(),n=n.slice(),t=this.customShaderNameResolve(this.name,B,W,n,f,O));const L=d?P._getDrawWrapper(void 0,!0):this._drawWrapper,Z=(null===L||void 0===L?void 0:L.effect)??null,v=(null===L||void 0===L?void 0:L.defines)??null,A=f.join("\n");let o=Z;return v!==A&&(o=u.createEffect(t,{attributes:O,uniformsNames:B,uniformBuffersNames:W,samplers:n,defines:A,fallbacks:e,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:y},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},u),d?P.setEffect(o,A,this._materialContext):L&&L.setEffect(o,A),this._onEffectCreatedObservable&&(E.effect=o,E.subMesh=P??(null===b||void 0===b?void 0:b.hd[0])??null,this._onEffectCreatedObservable.notifyObservers(E))),L._wasPreviouslyUsingInstances=!!X,!(null===(Q=o)||void 0===Q||!Q.isReady())&&(Z!==o&&a.resetCachedMaterial(),L._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(b,X){const P=X??this.getEffect();if(!P)return;const Q=this._options.uniforms;-1!==Q.indexOf("world")&&P.setMatrix("world",b);const S=this.Ab();-1!==Q.indexOf("worldView")&&(b.multiplyToRef(S.getViewMatrix(),this._cachedWorldViewMatrix),P.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==Q.indexOf("worldViewProjection")&&(b.multiplyToRef(S.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),P.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==Q.indexOf("view")&&P.setMatrix("view",S.getViewMatrix())}bindForSubMesh(b,X,P){var Q;this.bind(b,X,null===(Q=P._drawWrapperOverride)||void 0===Q?void 0:Q.effect,P)}bind(b,X,P,Q){const S=Q&&this._storeEffectOnSubMeshes,d=P??(S?Q.effect:this.getEffect());if(!d)return;const N=this.Ab();this._activeEffect=d,this.bindOnlyWorldMatrix(b,P);const a=this._options.uniformBuffers;let u=!1;if(d&&a&&a.length>0&&N.getEngine().supportsUniformBuffers)for(let O=0;O<a.length;++O){switch(a[O]){case"Mesh":X&&(X.getMeshUniformBuffer().bindToEffect(d,"Mesh"),X.transferToEffect(b));break;case"Scene":(0,D.s)(d,N.getSceneUniformBuffer()),N.finalizeSceneUbo(),u=!0}}const w=X&&S?this._mustRebind(N,d,Q,X.visibility):N.getCachedMaterial()!==this;if(d&&w){let b;for(b in u||-1===this._options.uniforms.indexOf("view")||d.setMatrix("view",N.getViewMatrix()),u||-1===this._options.uniforms.indexOf("projection")||d.setMatrix("projection",N.getProjectionMatrix()),u||-1===this._options.uniforms.indexOf("viewProjection")||(d.setMatrix("viewProjection",N.getTransformMatrix()),this._multiview&&d.setMatrix("viewProjectionR",N._transformMatrixR)),N.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&d.setVector3("cameraPosition",N.activeCamera.globalPosition),(0,D.c)(X,d),(0,Y.i)(d,this,N),this._useLogarithmicDepth&&(0,D.k)(S?Q.materialDefines:d.defines,d,N),X&&(0,D.g)(N,X,d),this._textures)d.setTexture(b,this._textures[b]);for(b in this._textureArrays)d.setTextureArray(b,this._textureArrays[b]);for(b in this._ints)d.setInt(b,this._ints[b]);for(b in this._uints)d.setUInt(b,this._uints[b]);for(b in this._floats)d.setFloat(b,this._floats[b]);for(b in this._floatsArrays)d.setArray(b,this._floatsArrays[b]);for(b in this._colors3)d.setColor3(b,this._colors3[b]);for(b in this._colors3Arrays)d.setArray3(b,this._colors3Arrays[b]);for(b in this._colors4){const X=this._colors4[b];d.setFloat4(b,X.r,X.g,X.b,X.a)}for(b in this._colors4Arrays)d.setArray4(b,this._colors4Arrays[b]);for(b in this._vectors2)d.setVector2(b,this._vectors2[b]);for(b in this._vectors3)d.setVector3(b,this._vectors3[b]);for(b in this._vectors4)d.setVector4(b,this._vectors4[b]);for(b in this._quaternions)d.setQuaternion(b,this._quaternions[b]);for(b in this._matrices)d.setMatrix(b,this._matrices[b]);for(b in this._matrixArrays)d.setMatrices(b,this._matrixArrays[b]);for(b in this._matrices3x3)d.setMatrix3x3(b,this._matrices3x3[b]);for(b in this._matrices2x2)d.setMatrix2x2(b,this._matrices2x2[b]);for(b in this._vectors2Arrays)d.setArray2(b,this._vectors2Arrays[b]);for(b in this._vectors3Arrays)d.setArray3(b,this._vectors3Arrays[b]);for(b in this._vectors4Arrays)d.setArray4(b,this._vectors4Arrays[b]);for(b in this._quaternionsArrays)d.setArray4(b,this._quaternionsArrays[b]);for(b in this._uniformBuffers){const X=this._uniformBuffers[b].getBuffer();X&&d.bindUniformBuffer(X,b)}const P=N.getEngine(),a=P.setExternalTexture;if(a)for(b in this._externalTextures)a.call(P,b,this._externalTextures[b]);const w=P.setTextureSampler;if(w)for(b in this._textureSamplers)w.call(P,b,this._textureSamplers[b]);const f=P.setStorageBuffer;if(f)for(b in this._storageBuffers)f.call(P,b,this._storageBuffers[b])}if(d&&X&&(w||!this.isFrozen)){(0,D.o)(X,d),X.morphTargetManager&&X.morphTargetManager.isUsingTextureForTargets&&X.morphTargetManager._bind(d);const b=X.bakedVertexAnimationManager;if(b&&b.isEnabled){var f;const b=S?Q._drawWrapper:this._drawWrapper;null===(f=X.bakedVertexAnimationManager)||void 0===f||f.bind(d,!!b._wasPreviouslyUsingInstances)}}this._afterBind(X,d,Q)}getActiveTextures(){const b=super.getActiveTextures();for(const X in this._textures)b.push(this._textures[X]);for(const X in this._textureArrays){const P=this._textureArrays[X];for(let X=0;X<P.length;X++)b.push(P[X])}return b}hasTexture(b){if(super.hasTexture(b))return!0;for(const X in this._textures)if(this._textures[X]===b)return!0;for(const X in this._textureArrays){const P=this._textureArrays[X];for(let X=0;X<P.length;X++)if(P[X]===b)return!0}return!1}clone(b){const X=Q.b.Clone((()=>new t(b,this.Ab(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);X.name=b,X.id=b,"object"===typeof X._shaderPath&&(X._shaderPath={...X._shaderPath}),this._options={...this._options};const P=Object.keys(this._options);for(const Q of P){const b=this._options[Q];Array.isArray(b)&&(this._options[Q]=b.slice(0))}this.stencil.copyTo(X.stencil);for(const Q in this._textures)X.setTexture(Q,this._textures[Q]);for(const Q in this._textureArrays)X.setTextureArray(Q,this._textureArrays[Q]);for(const Q in this._externalTextures)X.setExternalTexture(Q,this._externalTextures[Q]);for(const Q in this._ints)X.setInt(Q,this._ints[Q]);for(const Q in this._uints)X.setUInt(Q,this._uints[Q]);for(const Q in this._floats)X.setFloat(Q,this._floats[Q]);for(const Q in this._floatsArrays)X.setFloats(Q,this._floatsArrays[Q]);for(const Q in this._colors3)X.setColor3(Q,this._colors3[Q]);for(const Q in this._colors3Arrays)X._colors3Arrays[Q]=this._colors3Arrays[Q];for(const Q in this._colors4)X.setColor4(Q,this._colors4[Q]);for(const Q in this._colors4Arrays)X._colors4Arrays[Q]=this._colors4Arrays[Q];for(const Q in this._vectors2)X.setVector2(Q,this._vectors2[Q]);for(const Q in this._vectors3)X.setVector3(Q,this._vectors3[Q]);for(const Q in this._vectors4)X.setVector4(Q,this._vectors4[Q]);for(const Q in this._quaternions)X.setQuaternion(Q,this._quaternions[Q]);for(const Q in this._quaternionsArrays)X._quaternionsArrays[Q]=this._quaternionsArrays[Q];for(const Q in this._matrices)X.setMatrix(Q,this._matrices[Q]);for(const Q in this._matrixArrays)X._matrixArrays[Q]=this._matrixArrays[Q].slice();for(const Q in this._matrices3x3)X.setMatrix3x3(Q,this._matrices3x3[Q]);for(const Q in this._matrices2x2)X.setMatrix2x2(Q,this._matrices2x2[Q]);for(const Q in this._vectors2Arrays)X.setArray2(Q,this._vectors2Arrays[Q]);for(const Q in this._vectors3Arrays)X.setArray3(Q,this._vectors3Arrays[Q]);for(const Q in this._vectors4Arrays)X.setArray4(Q,this._vectors4Arrays[Q]);for(const Q in this._uniformBuffers)X.setUniformBuffer(Q,this._uniformBuffers[Q]);for(const Q in this._textureSamplers)X.setTextureSampler(Q,this._textureSamplers[Q]);for(const Q in this._storageBuffers)X.setStorageBuffer(Q,this._storageBuffers[Q]);return X}dispose(b,X,P){if(X){let b;for(b in this._textures)this._textures[b].dispose();for(b in this._textureArrays){const X=this._textureArrays[b];for(let b=0;b<X.length;b++)X[b].dispose()}}this._textures={},super.dispose(b,X,P)}serialize(){const b=Q.b.Serialize(this);let X;for(X in b.customType="BABYLON.ShaderMaterial",b.uniqueId=this.uniqueId,b.options=this._options,b.shaderPath=this._shaderPath,b.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,b.stencil=this.stencil.serialize(),b.textures={},this._textures)b.textures[X]=this._textures[X].serialize();for(X in b.textureArrays={},this._textureArrays){b.textureArrays[X]=[];const P=this._textureArrays[X];for(let Q=0;Q<P.length;Q++)b.textureArrays[X].push(P[Q].serialize())}for(X in b.ints={},this._ints)b.ints[X]=this._ints[X];for(X in b.uints={},this._uints)b.uints[X]=this._uints[X];for(X in b.floats={},this._floats)b.floats[X]=this._floats[X];for(X in b.floatsArrays={},this._floatsArrays)b.floatsArrays[X]=this._floatsArrays[X];for(X in b.colors3={},this._colors3){const P=this._colors3[X];b.colors3[X]=[P.r,P.g,P.b]}for(X in b.colors3Arrays={},this._colors3Arrays)b.colors3Arrays[X]=this._colors3Arrays[X];for(X in b.colors4={},this._colors4){const P=this._colors4[X];b.colors4[X]=[P.r,P.g,P.b,P.a]}for(X in b.colors4Arrays={},this._colors4Arrays)b.colors4Arrays[X]=this._colors4Arrays[X];for(X in b.vectors2={},this._vectors2){const P=this._vectors2[X];b.vectors2[X]=[P.x,P.y]}for(X in b.vectors3={},this._vectors3){const P=this._vectors3[X];b.vectors3[X]=[P.x,P.y,P.z]}for(X in b.vectors4={},this._vectors4){const P=this._vectors4[X];b.vectors4[X]=[P.x,P.y,P.z,P.w]}for(X in b.quaternions={},this._quaternions)b.quaternions[X]=this._quaternions[X].Zd();for(X in b.matrices={},this._matrices)b.matrices[X]=this._matrices[X].Zd();for(X in b.matrixArray={},this._matrixArrays)b.matrixArray[X]=this._matrixArrays[X];for(X in b.matrices3x3={},this._matrices3x3)b.matrices3x3[X]=this._matrices3x3[X];for(X in b.matrices2x2={},this._matrices2x2)b.matrices2x2[X]=this._matrices2x2[X];for(X in b.vectors2Arrays={},this._vectors2Arrays)b.vectors2Arrays[X]=this._vectors2Arrays[X];for(X in b.vectors3Arrays={},this._vectors3Arrays)b.vectors3Arrays[X]=this._vectors3Arrays[X];for(X in b.vectors4Arrays={},this._vectors4Arrays)b.vectors4Arrays[X]=this._vectors4Arrays[X];for(X in b.quaternionsArrays={},this._quaternionsArrays)b.quaternionsArrays[X]=this._quaternionsArrays[X];return b}static Parse(b,X,P){const S=Q.b.Parse((()=>new t(b.name,X,b.shaderPath,b.options,b.storeEffectOnSubMeshes)),b,X,P);let N;for(N in b.stencil&&S.stencil.parse(b.stencil,X,P),b.textures)S.setTexture(N,a.d.Parse(b.textures[N],X,P));for(N in b.textureArrays){const Q=b.textureArrays[N],d=[];for(let b=0;b<Q.length;b++)d.push(a.d.Parse(Q[b],X,P));S.setTextureArray(N,d)}for(N in b.ints)S.setInt(N,b.ints[N]);for(N in b.uints)S.setUInt(N,b.uints[N]);for(N in b.floats)S.setFloat(N,b.floats[N]);for(N in b.floatsArrays)S.setFloats(N,b.floatsArrays[N]);for(N in b.colors3){const X=b.colors3[N];S.setColor3(N,{r:X[0],g:X[1],b:X[2]})}for(N in b.colors3Arrays){const X=b.colors3Arrays[N].reduce(((b,X,P)=>(P%3===0?b.push([X]):b[b.length-1].push(X),b)),[]).map((b=>({r:b[0],g:b[1],b:b[2]})));S.setColor3Array(N,X)}for(N in b.colors4){const X=b.colors4[N];S.setColor4(N,{r:X[0],g:X[1],b:X[2],a:X[3]})}for(N in b.colors4Arrays){const X=b.colors4Arrays[N].reduce(((b,X,P)=>(P%4===0?b.push([X]):b[b.length-1].push(X),b)),[]).map((b=>({r:b[0],g:b[1],b:b[2],a:b[3]})));S.setColor4Array(N,X)}for(N in b.vectors2){const X=b.vectors2[N];S.setVector2(N,{x:X[0],y:X[1]})}for(N in b.vectors3){const X=b.vectors3[N];S.setVector3(N,{x:X[0],y:X[1],z:X[2]})}for(N in b.vectors4){const X=b.vectors4[N];S.setVector4(N,{x:X[0],y:X[1],z:X[2],w:X[3]})}for(N in b.quaternions)S.setQuaternion(N,d.Quaternion.hX(b.quaternions[N]));for(N in b.matrices)S.setMatrix(N,d.Matrix.hX(b.matrices[N]));for(N in b.matrixArray)S._matrixArrays[N]=new Float32Array(b.matrixArray[N]);for(N in b.matrices3x3)S.setMatrix3x3(N,b.matrices3x3[N]);for(N in b.matrices2x2)S.setMatrix2x2(N,b.matrices2x2[N]);for(N in b.vectors2Arrays)S.setArray2(N,b.vectors2Arrays[N]);for(N in b.vectors3Arrays)S.setArray3(N,b.vectors3Arrays[N]);for(N in b.vectors4Arrays)S.setArray4(N,b.vectors4Arrays[N]);for(N in b.quaternionsArrays)S.setArray4(N,b.quaternionsArrays[N]);return S}static async ParseFromFileAsync(b,X,P){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((S,d)=>{const N=new f.c;N.addEventListener("readystatechange",(()=>{if(4==N.readyState)if(200==N.status){const X=JSON.parse(N.responseText),d=this.Parse(X,P||e.e.LastCreatedScene,Q);b&&(d.name=b),S(d)}else d("Unable to load the ShaderMaterial")})),N.open("GET",X),N.send()}))}static async ParseFromSnippetAsync(b,X){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((Q,S)=>{const d=new f.c;d.addEventListener("readystatechange",(()=>{if(4==d.readyState)if(200==d.status){const S=JSON.parse(JSON.parse(d.responseText).jsonPayload),N=JSON.parse(S.shaderMaterial),a=this.Parse(N,X||e.e.LastCreatedScene,P);a.snippetId=b,Q(a)}else S("Unable to load the snippet "+b)})),d.open("GET",this.SnippetUrl+"/"+b.replace(/#/g,"/")),d.send()}))}}t.SnippetUrl="https://snippet.babylonjs.com",t.CreateFromSnippetAsync=t.ParseFromSnippetAsync,(0,u.h)("BABYLON.ShaderMaterial",t)}}]);