"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[22],{11599:(B,E,v)=>{v.r(E),v.d(E,{ShaderMaterial:()=>a});var z=v(11409),o=v(11601),q=v(11380),c=v(11442),S=v(11361),x=v(11345),D=v(11688),h=v(11237),y=v(11697),Q=v(11242),P=v(11752),G=v(11749);const Y={effect:null,subMesh:null};class a extends y.e{constructor(B,E,v){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(B,E,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new q.Matrix,this._cachedWorldViewProjectionMatrix=new q.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=v,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...z}}get shaderPath(){return this._shaderPath}set shaderPath(B){this._shaderPath=B}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(B){-1===this._options.uniforms.indexOf(B)&&this._options.uniforms.push(B)}setTexture(B,E){return-1===this._options.samplers.indexOf(B)&&this._options.samplers.push(B),this._textures[B]=E,this}removeTexture(B){delete this._textures[B]}setTextureArray(B,E){return-1===this._options.samplers.indexOf(B)&&this._options.samplers.push(B),this._checkUniform(B),this._textureArrays[B]=E,this}setExternalTexture(B,E){return-1===this._options.externalTextures.indexOf(B)&&this._options.externalTextures.push(B),this._externalTextures[B]=E,this}setFloat(B,E){return this._checkUniform(B),this._floats[B]=E,this}setInt(B,E){return this._checkUniform(B),this._ints[B]=E,this}setUInt(B,E){return this._checkUniform(B),this._uints[B]=E,this}setFloats(B,E){return this._checkUniform(B),this._floatsArrays[B]=E,this}setColor3(B,E){return this._checkUniform(B),this._colors3[B]=E,this}setColor3Array(B,E){return this._checkUniform(B),this._colors3Arrays[B]=E.reduce(((B,E)=>(B.push(E.r,E.g,E.b),B)),[]),this}setColor4(B,E){return this._checkUniform(B),this._colors4[B]=E,this}setColor4Array(B,E){return this._checkUniform(B),this._colors4Arrays[B]=E.reduce(((B,E)=>(B.push(E.r,E.g,E.b,E.a),B)),[]),this}setVector2(B,E){return this._checkUniform(B),this._vectors2[B]=E,this}setVector3(B,E){return this._checkUniform(B),this._vectors3[B]=E,this}setVector4(B,E){return this._checkUniform(B),this._vectors4[B]=E,this}setQuaternion(B,E){return this._checkUniform(B),this._quaternions[B]=E,this}setQuaternionArray(B,E){return this._checkUniform(B),this._quaternionsArrays[B]=E.reduce(((B,E)=>(E.toArray(B,B.length),B)),[]),this}setMatrix(B,E){return this._checkUniform(B),this._matrices[B]=E,this}setMatrices(B,E){this._checkUniform(B);const v=new Float32Array(16*E.length);for(let z=0;z<E.length;z++){E[z].copyToArray(v,16*z)}return this._matrixArrays[B]=v,this}setMatrix3x3(B,E){return this._checkUniform(B),this._matrices3x3[B]=E,this}setMatrix2x2(B,E){return this._checkUniform(B),this._matrices2x2[B]=E,this}setArray2(B,E){return this._checkUniform(B),this._vectors2Arrays[B]=E,this}setArray3(B,E){return this._checkUniform(B),this._vectors3Arrays[B]=E,this}setArray4(B,E){return this._checkUniform(B),this._vectors4Arrays[B]=E,this}setUniformBuffer(B,E){return-1===this._options.uniformBuffers.indexOf(B)&&this._options.uniformBuffers.push(B),this._uniformBuffers[B]=E,this}setTextureSampler(B,E){return-1===this._options.samplerObjects.indexOf(B)&&this._options.samplerObjects.push(B),this._textureSamplers[B]=E,this}setStorageBuffer(B,E){return-1===this._options.storageBuffers.indexOf(B)&&this._options.storageBuffers.push(B),this._storageBuffers[B]=E,this}setDefine(B,E){const v=B.trimEnd()+" ",z=this.options.defines.findIndex((E=>E===B||E.startsWith(v)));return z>=0&&this.options.defines.splice(z,1),("boolean"!==typeof E||E)&&this.options.defines.push(v+E),this}isReadyForSubMesh(B,E,v){return this.isReady(B,v,E)}isReady(B,E,v){var z;const q=v&&this._storeEffectOnSubMeshes;if(this.isFrozen){const B=q?v._drawWrapper:this._drawWrapper;if(B.effect&&B._wasPreviouslyReady&&B._wasPreviouslyUsingInstances===E)return!0}const S=this.rB(),x=S.getEngine(),h=[],y=[];let Q=null,a=this._shaderPath,m=this._options.uniforms,g=this._options.uniformBuffers,V=this._options.samplers;x.getCaps().multiview&&S.activeCamera&&S.activeCamera.outputRenderTarget&&S.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,h.push("#define MULTIVIEW"),-1!==m.indexOf("viewProjection")&&-1===m.indexOf("viewProjectionR")&&m.push("viewProjectionR"));for(let o=0;o<this._options.defines.length;o++){const B=0===this._options.defines[o].indexOf("#define")?this._options.defines[o]:`#define ${this._options.defines[o]}`;h.push(B)}for(let o=0;o<this._options.attributes.length;o++)y.push(this._options.attributes[o]);if(B&&B.isVerticesDataPresent(c.e.ColorKind)&&(-1===y.indexOf(c.e.ColorKind)&&y.push(c.e.ColorKind),h.push("#define VERTEXCOLOR")),E&&(h.push("#define INSTANCES"),(0,G.gb)(y,this._materialHelperNeedsPreviousMatrices),null!==B&&void 0!==B&&B.hasThinInstances&&(h.push("#define THIN_INSTANCES"),B&&B.isVerticesDataPresent(c.e.ColorInstanceKind)&&(y.push(c.e.ColorInstanceKind),h.push("#define INSTANCESCOLOR")))),B&&B.useBones&&B.computeBonesUsingShaders&&B.skeleton){y.push(c.e.MatricesIndicesKind),y.push(c.e.MatricesWeightsKind),B.numBoneInfluencers>4&&(y.push(c.e.MatricesIndicesExtraKind),y.push(c.e.MatricesWeightsExtraKind));const E=B.skeleton;h.push("#define NUM_BONE_INFLUENCERS "+B.numBoneInfluencers),Q=new D.c,Q.addCPUSkinningFallback(0,B),E.isUsingTextureForMatrices?(h.push("#define BONETEXTURE"),-1===m.indexOf("boneTextureWidth")&&m.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(h.push("#define BonesPerMesh "+(E.bones.length+1)),-1===m.indexOf("mBones")&&m.push("mBones"))}else h.push("#define NUM_BONE_INFLUENCERS 0");let T=0;const N=B?B.morphTargetManager:null;if(N){const E=-1!==h.indexOf("#define UV1"),v=-1!==h.indexOf("#define UV2"),z=-1!==h.indexOf("#define TANGENT"),o=-1!==h.indexOf("#define NORMAL"),q=-1!==h.indexOf("#define VERTEXCOLOR");T=(0,G.I)(N,h,y,B,!0,o,z,E,v,q),N.isUsingTextureForTargets&&(-1===m.indexOf("morphTargetTextureIndices")&&m.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),T>0&&(m=m.slice(),m.push("morphTargetInfluences"),m.push("morphTargetCount"),m.push("morphTargetTextureInfo"),m.push("morphTargetTextureIndices"))}else h.push("#define NUM_MORPH_INFLUENCERS 0");if(B){const E=B.bakedVertexAnimationManager;E&&E.isEnabled&&(h.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===m.indexOf("bakedVertexAnimationSettings")&&m.push("bakedVertexAnimationSettings"),-1===m.indexOf("bakedVertexAnimationTextureSizeInverted")&&m.push("bakedVertexAnimationTextureSizeInverted"),-1===m.indexOf("bakedVertexAnimationTime")&&m.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,G.v)(y,B,h)}for(const o in this._textures)if(!this._textures[o].isReady())return!1;B&&this.needAlphaTestingForMesh(B)&&h.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,P.d)(m),(0,P.i)(this,S,h)),S.fogEnabled&&null!==B&&void 0!==B&&B.applyFog&&S.fogMode!==o.c.FOGMODE_NONE&&(h.push("#define FOG"),-1===m.indexOf("view")&&m.push("view"),-1===m.indexOf("vFogInfos")&&m.push("vFogInfos"),-1===m.indexOf("vFogColor")&&m.push("vFogColor")),this._useLogarithmicDepth&&(h.push("#define LOGARITHMICDEPTH"),-1===m.indexOf("logarithmicDepthConstant")&&m.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(m=m.slice(),g=g.slice(),V=V.slice(),a=this.customShaderNameResolve(this.name,m,g,V,h,y));const X=q?v._getDrawWrapper(void 0,!0):this._drawWrapper,r=(null===X||void 0===X?void 0:X.effect)??null,i=(null===X||void 0===X?void 0:X.defines)??null,u=h.join("\n");let I=r;return i!==u&&(I=x.createEffect(a,{attributes:y,uniformsNames:m,uniformBuffersNames:g,samplers:V,defines:u,fallbacks:Q,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:T},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},x),q?v.setEffect(I,u,this._materialContext):X&&X.setEffect(I,u),this._onEffectCreatedObservable&&(Y.effect=I,Y.subMesh=v??(null===B||void 0===B?void 0:B.qc[0])??null,this._onEffectCreatedObservable.notifyObservers(Y))),X._wasPreviouslyUsingInstances=!!E,!(null===(z=I)||void 0===z||!z.isReady())&&(r!==I&&S.resetCachedMaterial(),X._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(B,E){const v=E??this.getEffect();if(!v)return;const z=this._options.uniforms;-1!==z.indexOf("world")&&v.setMatrix("world",B);const o=this.rB();-1!==z.indexOf("worldView")&&(B.multiplyToRef(o.getViewMatrix(),this._cachedWorldViewMatrix),v.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==z.indexOf("worldViewProjection")&&(B.multiplyToRef(o.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),v.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==z.indexOf("view")&&v.setMatrix("view",o.getViewMatrix())}bindForSubMesh(B,E,v){var z;this.bind(B,E,null===(z=v._drawWrapperOverride)||void 0===z?void 0:z.effect,v)}bind(B,E,v,z){const o=z&&this._storeEffectOnSubMeshes,q=v??(o?z.effect:this.getEffect());if(!q)return;const c=this.rB();this._activeEffect=q,this.bindOnlyWorldMatrix(B,v);const S=this._options.uniformBuffers;let x=!1;if(q&&S&&S.length>0&&c.getEngine().supportsUniformBuffers)for(let y=0;y<S.length;++y){switch(S[y]){case"Mesh":E&&(E.getMeshUniformBuffer().bindToEffect(q,"Mesh"),E.transferToEffect(B));break;case"Scene":(0,G.n)(q,c.getSceneUniformBuffer()),c.finalizeSceneUbo(),x=!0}}const D=E&&o?this._mustRebind(c,q,z,E.visibility):c.getCachedMaterial()!==this;if(q&&D){let B;for(B in x||-1===this._options.uniforms.indexOf("view")||q.setMatrix("view",c.getViewMatrix()),x||-1===this._options.uniforms.indexOf("projection")||q.setMatrix("projection",c.getProjectionMatrix()),x||-1===this._options.uniforms.indexOf("viewProjection")||(q.setMatrix("viewProjection",c.getTransformMatrix()),this._multiview&&q.setMatrix("viewProjectionR",c._transformMatrixR)),c.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&q.setVector3("cameraPosition",c.activeCamera.globalPosition),(0,G.e)(E,q),(0,P.f)(q,this,c),this._useLogarithmicDepth&&(0,G.k)(o?z.materialDefines:q.defines,q,c),E&&(0,G.g)(c,E,q),this._textures)q.setTexture(B,this._textures[B]);for(B in this._textureArrays)q.setTextureArray(B,this._textureArrays[B]);for(B in this._ints)q.setInt(B,this._ints[B]);for(B in this._uints)q.setUInt(B,this._uints[B]);for(B in this._floats)q.setFloat(B,this._floats[B]);for(B in this._floatsArrays)q.setArray(B,this._floatsArrays[B]);for(B in this._colors3)q.setColor3(B,this._colors3[B]);for(B in this._colors3Arrays)q.setArray3(B,this._colors3Arrays[B]);for(B in this._colors4){const E=this._colors4[B];q.setFloat4(B,E.r,E.g,E.b,E.a)}for(B in this._colors4Arrays)q.setArray4(B,this._colors4Arrays[B]);for(B in this._vectors2)q.setVector2(B,this._vectors2[B]);for(B in this._vectors3)q.setVector3(B,this._vectors3[B]);for(B in this._vectors4)q.setVector4(B,this._vectors4[B]);for(B in this._quaternions)q.setQuaternion(B,this._quaternions[B]);for(B in this._matrices)q.setMatrix(B,this._matrices[B]);for(B in this._matrixArrays)q.setMatrices(B,this._matrixArrays[B]);for(B in this._matrices3x3)q.setMatrix3x3(B,this._matrices3x3[B]);for(B in this._matrices2x2)q.setMatrix2x2(B,this._matrices2x2[B]);for(B in this._vectors2Arrays)q.setArray2(B,this._vectors2Arrays[B]);for(B in this._vectors3Arrays)q.setArray3(B,this._vectors3Arrays[B]);for(B in this._vectors4Arrays)q.setArray4(B,this._vectors4Arrays[B]);for(B in this._quaternionsArrays)q.setArray4(B,this._quaternionsArrays[B]);for(B in this._uniformBuffers){const E=this._uniformBuffers[B].getBuffer();E&&q.bindUniformBuffer(E,B)}const v=c.getEngine(),S=v.setExternalTexture;if(S)for(B in this._externalTextures)S.call(v,B,this._externalTextures[B]);const D=v.setTextureSampler;if(D)for(B in this._textureSamplers)D.call(v,B,this._textureSamplers[B]);const h=v.setStorageBuffer;if(h)for(B in this._storageBuffers)h.call(v,B,this._storageBuffers[B])}if(q&&E&&(D||!this.isFrozen)){(0,G.m)(E,q),E.morphTargetManager&&E.morphTargetManager.isUsingTextureForTargets&&E.morphTargetManager._bind(q);const B=E.bakedVertexAnimationManager;if(B&&B.isEnabled){var h;const B=o?z._drawWrapper:this._drawWrapper;null===(h=E.bakedVertexAnimationManager)||void 0===h||h.bind(q,!!B._wasPreviouslyUsingInstances)}}this._afterBind(E,q,z)}getActiveTextures(){const B=super.getActiveTextures();for(const E in this._textures)B.push(this._textures[E]);for(const E in this._textureArrays){const v=this._textureArrays[E];for(let E=0;E<v.length;E++)B.push(v[E])}return B}hasTexture(B){if(super.hasTexture(B))return!0;for(const E in this._textures)if(this._textures[E]===B)return!0;for(const E in this._textureArrays){const v=this._textureArrays[E];for(let E=0;E<v.length;E++)if(v[E]===B)return!0}return!1}clone(B){const E=z.b.Clone((()=>new a(B,this.rB(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);E.name=B,E.id=B,"object"===typeof E._shaderPath&&(E._shaderPath={...E._shaderPath}),this._options={...this._options};const v=Object.keys(this._options);for(const z of v){const B=this._options[z];Array.isArray(B)&&(this._options[z]=B.slice(0))}this.stencil.copyTo(E.stencil);for(const z in this._textures)E.setTexture(z,this._textures[z]);for(const z in this._textureArrays)E.setTextureArray(z,this._textureArrays[z]);for(const z in this._externalTextures)E.setExternalTexture(z,this._externalTextures[z]);for(const z in this._ints)E.setInt(z,this._ints[z]);for(const z in this._uints)E.setUInt(z,this._uints[z]);for(const z in this._floats)E.setFloat(z,this._floats[z]);for(const z in this._floatsArrays)E.setFloats(z,this._floatsArrays[z]);for(const z in this._colors3)E.setColor3(z,this._colors3[z]);for(const z in this._colors3Arrays)E._colors3Arrays[z]=this._colors3Arrays[z];for(const z in this._colors4)E.setColor4(z,this._colors4[z]);for(const z in this._colors4Arrays)E._colors4Arrays[z]=this._colors4Arrays[z];for(const z in this._vectors2)E.setVector2(z,this._vectors2[z]);for(const z in this._vectors3)E.setVector3(z,this._vectors3[z]);for(const z in this._vectors4)E.setVector4(z,this._vectors4[z]);for(const z in this._quaternions)E.setQuaternion(z,this._quaternions[z]);for(const z in this._quaternionsArrays)E._quaternionsArrays[z]=this._quaternionsArrays[z];for(const z in this._matrices)E.setMatrix(z,this._matrices[z]);for(const z in this._matrixArrays)E._matrixArrays[z]=this._matrixArrays[z].slice();for(const z in this._matrices3x3)E.setMatrix3x3(z,this._matrices3x3[z]);for(const z in this._matrices2x2)E.setMatrix2x2(z,this._matrices2x2[z]);for(const z in this._vectors2Arrays)E.setArray2(z,this._vectors2Arrays[z]);for(const z in this._vectors3Arrays)E.setArray3(z,this._vectors3Arrays[z]);for(const z in this._vectors4Arrays)E.setArray4(z,this._vectors4Arrays[z]);for(const z in this._uniformBuffers)E.setUniformBuffer(z,this._uniformBuffers[z]);for(const z in this._textureSamplers)E.setTextureSampler(z,this._textureSamplers[z]);for(const z in this._storageBuffers)E.setStorageBuffer(z,this._storageBuffers[z]);return E}dispose(B,E,v){if(E){let B;for(B in this._textures)this._textures[B].dispose();for(B in this._textureArrays){const E=this._textureArrays[B];for(let B=0;B<E.length;B++)E[B].dispose()}}this._textures={},super.dispose(B,E,v)}serialize(){const B=z.b.Serialize(this);let E;for(E in B.customType="BABYLON.ShaderMaterial",B.uniqueId=this.uniqueId,B.options=this._options,B.shaderPath=this._shaderPath,B.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,B.stencil=this.stencil.serialize(),B.textures={},this._textures)B.textures[E]=this._textures[E].serialize();for(E in B.textureArrays={},this._textureArrays){B.textureArrays[E]=[];const v=this._textureArrays[E];for(let z=0;z<v.length;z++)B.textureArrays[E].push(v[z].serialize())}for(E in B.ints={},this._ints)B.ints[E]=this._ints[E];for(E in B.uints={},this._uints)B.uints[E]=this._uints[E];for(E in B.floats={},this._floats)B.floats[E]=this._floats[E];for(E in B.floatsArrays={},this._floatsArrays)B.floatsArrays[E]=this._floatsArrays[E];for(E in B.colors3={},this._colors3){const v=this._colors3[E];B.colors3[E]=[v.r,v.g,v.b]}for(E in B.colors3Arrays={},this._colors3Arrays)B.colors3Arrays[E]=this._colors3Arrays[E];for(E in B.colors4={},this._colors4){const v=this._colors4[E];B.colors4[E]=[v.r,v.g,v.b,v.a]}for(E in B.colors4Arrays={},this._colors4Arrays)B.colors4Arrays[E]=this._colors4Arrays[E];for(E in B.vectors2={},this._vectors2){const v=this._vectors2[E];B.vectors2[E]=[v.x,v.y]}for(E in B.vectors3={},this._vectors3){const v=this._vectors3[E];B.vectors3[E]=[v.x,v.y,v.z]}for(E in B.vectors4={},this._vectors4){const v=this._vectors4[E];B.vectors4[E]=[v.x,v.y,v.z,v.w]}for(E in B.quaternions={},this._quaternions)B.quaternions[E]=this._quaternions[E].cc();for(E in B.matrices={},this._matrices)B.matrices[E]=this._matrices[E].cc();for(E in B.matrixArray={},this._matrixArrays)B.matrixArray[E]=this._matrixArrays[E];for(E in B.matrices3x3={},this._matrices3x3)B.matrices3x3[E]=this._matrices3x3[E];for(E in B.matrices2x2={},this._matrices2x2)B.matrices2x2[E]=this._matrices2x2[E];for(E in B.vectors2Arrays={},this._vectors2Arrays)B.vectors2Arrays[E]=this._vectors2Arrays[E];for(E in B.vectors3Arrays={},this._vectors3Arrays)B.vectors3Arrays[E]=this._vectors3Arrays[E];for(E in B.vectors4Arrays={},this._vectors4Arrays)B.vectors4Arrays[E]=this._vectors4Arrays[E];for(E in B.quaternionsArrays={},this._quaternionsArrays)B.quaternionsArrays[E]=this._quaternionsArrays[E];return B}static Parse(B,E,v){const o=z.b.Parse((()=>new a(B.name,E,B.shaderPath,B.options,B.storeEffectOnSubMeshes)),B,E,v);let c;for(c in B.stencil&&o.stencil.parse(B.stencil,E,v),B.textures)o.setTexture(c,S.b.Parse(B.textures[c],E,v));for(c in B.textureArrays){const z=B.textureArrays[c],q=[];for(let B=0;B<z.length;B++)q.push(S.b.Parse(z[B],E,v));o.setTextureArray(c,q)}for(c in B.ints)o.setInt(c,B.ints[c]);for(c in B.uints)o.setUInt(c,B.uints[c]);for(c in B.floats)o.setFloat(c,B.floats[c]);for(c in B.floatsArrays)o.setFloats(c,B.floatsArrays[c]);for(c in B.colors3){const E=B.colors3[c];o.setColor3(c,{r:E[0],g:E[1],b:E[2]})}for(c in B.colors3Arrays){const E=B.colors3Arrays[c].reduce(((B,E,v)=>(v%3===0?B.push([E]):B[B.length-1].push(E),B)),[]).map((B=>({r:B[0],g:B[1],b:B[2]})));o.setColor3Array(c,E)}for(c in B.colors4){const E=B.colors4[c];o.setColor4(c,{r:E[0],g:E[1],b:E[2],a:E[3]})}for(c in B.colors4Arrays){const E=B.colors4Arrays[c].reduce(((B,E,v)=>(v%4===0?B.push([E]):B[B.length-1].push(E),B)),[]).map((B=>({r:B[0],g:B[1],b:B[2],a:B[3]})));o.setColor4Array(c,E)}for(c in B.vectors2){const E=B.vectors2[c];o.setVector2(c,{x:E[0],y:E[1]})}for(c in B.vectors3){const E=B.vectors3[c];o.setVector3(c,{x:E[0],y:E[1],z:E[2]})}for(c in B.vectors4){const E=B.vectors4[c];o.setVector4(c,{x:E[0],y:E[1],z:E[2],w:E[3]})}for(c in B.quaternions)o.setQuaternion(c,q.Quaternion.VE(B.quaternions[c]));for(c in B.matrices)o.setMatrix(c,q.Matrix.VE(B.matrices[c]));for(c in B.matrixArray)o._matrixArrays[c]=new Float32Array(B.matrixArray[c]);for(c in B.matrices3x3)o.setMatrix3x3(c,B.matrices3x3[c]);for(c in B.matrices2x2)o.setMatrix2x2(c,B.matrices2x2[c]);for(c in B.vectors2Arrays)o.setArray2(c,B.vectors2Arrays[c]);for(c in B.vectors3Arrays)o.setArray3(c,B.vectors3Arrays[c]);for(c in B.vectors4Arrays)o.setArray4(c,B.vectors4Arrays[c]);for(c in B.quaternionsArrays)o.setArray4(c,B.quaternionsArrays[c]);return o}static async ParseFromFileAsync(B,E,v){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((o,q)=>{const c=new h.b;c.addEventListener("readystatechange",(()=>{if(4==c.readyState)if(200==c.status){const E=JSON.parse(c.responseText),q=this.Parse(E,v||Q.b.LastCreatedScene,z);B&&(q.name=B),o(q)}else q("Unable to load the ShaderMaterial")})),c.open("GET",E),c.send()}))}static async ParseFromSnippetAsync(B,E){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((z,o)=>{const q=new h.b;q.addEventListener("readystatechange",(()=>{if(4==q.readyState)if(200==q.status){const o=JSON.parse(JSON.parse(q.responseText).jsonPayload),c=JSON.parse(o.shaderMaterial),S=this.Parse(c,E||Q.b.LastCreatedScene,v);S.snippetId=B,z(S)}else o("Unable to load the snippet "+B)})),q.open("GET",this.SnippetUrl+"/"+B.replace(/#/g,"/")),q.send()}))}}a.SnippetUrl="https://snippet.babylonjs.com",a.CreateFromSnippetAsync=a.ParseFromSnippetAsync,(0,x.f)("BABYLON.ShaderMaterial",a)}}]);