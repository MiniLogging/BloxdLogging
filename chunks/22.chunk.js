"use strict";(self["9d4d30r2sf"]=self["9d4d30r2sf"]||[]).push([[22],{12745:(o,v,V)=>{V.r(v),V.d(v,{ShaderMaterial:()=>c});var g=V(12535),E=V(12747),I=V(12488),Q=V(12577),U=V(12471),n=V(12449),O=V(12817),h=V(12332),x=V(12825),f=V(12339),l=V(12884),S=V(12878);const T={effect:null,subMesh:null};class c extends x.c{constructor(o,v,V){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(o,v,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new I.Matrix,this._cachedWorldViewProjectionMatrix=new I.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=V,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...g}}get shaderPath(){return this._shaderPath}set shaderPath(o){this._shaderPath=o}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(o){-1===this._options.uniforms.indexOf(o)&&this._options.uniforms.push(o)}setTexture(o,v){return-1===this._options.samplers.indexOf(o)&&this._options.samplers.push(o),this._textures[o]=v,this}removeTexture(o){delete this._textures[o]}setTextureArray(o,v){return-1===this._options.samplers.indexOf(o)&&this._options.samplers.push(o),this._checkUniform(o),this._textureArrays[o]=v,this}setExternalTexture(o,v){return-1===this._options.externalTextures.indexOf(o)&&this._options.externalTextures.push(o),this._externalTextures[o]=v,this}setFloat(o,v){return this._checkUniform(o),this._floats[o]=v,this}setInt(o,v){return this._checkUniform(o),this._ints[o]=v,this}setUInt(o,v){return this._checkUniform(o),this._uints[o]=v,this}setFloats(o,v){return this._checkUniform(o),this._floatsArrays[o]=v,this}setColor3(o,v){return this._checkUniform(o),this._colors3[o]=v,this}setColor3Array(o,v){return this._checkUniform(o),this._colors3Arrays[o]=v.reduce(((o,v)=>(o.push(v.r,v.g,v.b),o)),[]),this}setColor4(o,v){return this._checkUniform(o),this._colors4[o]=v,this}setColor4Array(o,v){return this._checkUniform(o),this._colors4Arrays[o]=v.reduce(((o,v)=>(o.push(v.r,v.g,v.b,v.a),o)),[]),this}setVector2(o,v){return this._checkUniform(o),this._vectors2[o]=v,this}setVector3(o,v){return this._checkUniform(o),this._vectors3[o]=v,this}setVector4(o,v){return this._checkUniform(o),this._vectors4[o]=v,this}setQuaternion(o,v){return this._checkUniform(o),this._quaternions[o]=v,this}setQuaternionArray(o,v){return this._checkUniform(o),this._quaternionsArrays[o]=v.reduce(((o,v)=>(v.toArray(o,o.length),o)),[]),this}setMatrix(o,v){return this._checkUniform(o),this._matrices[o]=v,this}setMatrices(o,v){this._checkUniform(o);const V=new Float32Array(16*v.length);for(let g=0;g<v.length;g++){v[g].copyToArray(V,16*g)}return this._matrixArrays[o]=V,this}setMatrix3x3(o,v){return this._checkUniform(o),this._matrices3x3[o]=v,this}setMatrix2x2(o,v){return this._checkUniform(o),this._matrices2x2[o]=v,this}setArray2(o,v){return this._checkUniform(o),this._vectors2Arrays[o]=v,this}setArray3(o,v){return this._checkUniform(o),this._vectors3Arrays[o]=v,this}setArray4(o,v){return this._checkUniform(o),this._vectors4Arrays[o]=v,this}setUniformBuffer(o,v){return-1===this._options.uniformBuffers.indexOf(o)&&this._options.uniformBuffers.push(o),this._uniformBuffers[o]=v,this}setTextureSampler(o,v){return-1===this._options.samplerObjects.indexOf(o)&&this._options.samplerObjects.push(o),this._textureSamplers[o]=v,this}setStorageBuffer(o,v){return-1===this._options.storageBuffers.indexOf(o)&&this._options.storageBuffers.push(o),this._storageBuffers[o]=v,this}setDefine(o,v){const V=o.trimEnd()+" ",g=this.options.defines.findIndex((v=>v===o||v.startsWith(V)));return g>=0&&this.options.defines.splice(g,1),("boolean"!==typeof v||v)&&this.options.defines.push(V+v),this}isReadyForSubMesh(o,v,V){return this.isReady(o,V,v)}isReady(o,v,V){var g;const I=V&&this._storeEffectOnSubMeshes;if(this.isFrozen){const o=I?V._drawWrapper:this._drawWrapper;if(o.effect&&o._wasPreviouslyReady&&o._wasPreviouslyUsingInstances===v)return!0}const U=this.Fo(),n=U.getEngine(),h=[],x=[];let f=null,c=this._shaderPath,R=this._options.uniforms,j=this._options.uniformBuffers,t=this._options.samplers;n.getCaps().multiview&&U.activeCamera&&U.activeCamera.outputRenderTarget&&U.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,h.push("#define MULTIVIEW"),-1!==R.indexOf("viewProjection")&&-1===R.indexOf("viewProjectionR")&&R.push("viewProjectionR"));for(let E=0;E<this._options.defines.length;E++){const o=0===this._options.defines[E].indexOf("#define")?this._options.defines[E]:`#define ${this._options.defines[E]}`;h.push(o)}for(let E=0;E<this._options.attributes.length;E++)x.push(this._options.attributes[E]);if(o&&o.isVerticesDataPresent(Q.e.ColorKind)&&(-1===x.indexOf(Q.e.ColorKind)&&x.push(Q.e.ColorKind),h.push("#define VERTEXCOLOR")),v&&(h.push("#define INSTANCES"),(0,S.ab)(x,this._materialHelperNeedsPreviousMatrices),null!==o&&void 0!==o&&o.hasThinInstances&&(h.push("#define THIN_INSTANCES"),o&&o.isVerticesDataPresent(Q.e.ColorInstanceKind)&&(x.push(Q.e.ColorInstanceKind),h.push("#define INSTANCESCOLOR")))),o&&o.useBones&&o.computeBonesUsingShaders&&o.skeleton){x.push(Q.e.MatricesIndicesKind),x.push(Q.e.MatricesWeightsKind),o.numBoneInfluencers>4&&(x.push(Q.e.MatricesIndicesExtraKind),x.push(Q.e.MatricesWeightsExtraKind));const v=o.skeleton;h.push("#define NUM_BONE_INFLUENCERS "+o.numBoneInfluencers),f=new O.d,f.addCPUSkinningFallback(0,o),v.isUsingTextureForMatrices?(h.push("#define BONETEXTURE"),-1===R.indexOf("boneTextureWidth")&&R.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(h.push("#define BonesPerMesh "+(v.bones.length+1)),-1===R.indexOf("mBones")&&R.push("mBones"))}else h.push("#define NUM_BONE_INFLUENCERS 0");let s=0;const L=o?o.morphTargetManager:null;if(L){const v=-1!==h.indexOf("#define UV1"),V=-1!==h.indexOf("#define UV2"),g=-1!==h.indexOf("#define TANGENT"),E=-1!==h.indexOf("#define NORMAL"),I=-1!==h.indexOf("#define VERTEXCOLOR");s=(0,S.G)(L,h,x,o,!0,E,g,v,V,I),L.isUsingTextureForTargets&&(-1===R.indexOf("morphTargetTextureIndices")&&R.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),s>0&&(R=R.slice(),R.push("morphTargetInfluences"),R.push("morphTargetCount"),R.push("morphTargetTextureInfo"),R.push("morphTargetTextureIndices"))}else h.push("#define NUM_MORPH_INFLUENCERS 0");if(o){const v=o.bakedVertexAnimationManager;v&&v.isEnabled&&(h.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===R.indexOf("bakedVertexAnimationSettings")&&R.push("bakedVertexAnimationSettings"),-1===R.indexOf("bakedVertexAnimationTextureSizeInverted")&&R.push("bakedVertexAnimationTextureSizeInverted"),-1===R.indexOf("bakedVertexAnimationTime")&&R.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,S.s)(x,o,h)}for(const E in this._textures)if(!this._textures[E].isReady())return!1;o&&this.needAlphaTestingForMesh(o)&&h.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,l.b)(R),(0,l.g)(this,U,h)),U.fogEnabled&&null!==o&&void 0!==o&&o.applyFog&&U.fogMode!==E.b.FOGMODE_NONE&&(h.push("#define FOG"),-1===R.indexOf("view")&&R.push("view"),-1===R.indexOf("vFogInfos")&&R.push("vFogInfos"),-1===R.indexOf("vFogColor")&&R.push("vFogColor")),this._useLogarithmicDepth&&(h.push("#define LOGARITHMICDEPTH"),-1===R.indexOf("logarithmicDepthConstant")&&R.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(R=R.slice(),j=j.slice(),t=t.slice(),c=this.customShaderNameResolve(this.name,R,j,t,h,x));const b=I?V._getDrawWrapper(void 0,!0):this._drawWrapper,u=(null===b||void 0===b?void 0:b.effect)??null,mo=(null===b||void 0===b?void 0:b.defines)??null,a=h.join("\n");let F=u;return mo!==a&&(F=n.createEffect(c,{attributes:x,uniformsNames:R,uniformBuffersNames:j,samplers:t,defines:a,fallbacks:f,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:s},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},n),I?V.setEffect(F,a,this._materialContext):b&&b.setEffect(F,a),this._onEffectCreatedObservable&&(T.effect=F,T.subMesh=V??(null===o||void 0===o?void 0:o.wg[0])??null,this._onEffectCreatedObservable.notifyObservers(T))),b._wasPreviouslyUsingInstances=!!v,!(null===(g=F)||void 0===g||!g.isReady())&&(u!==F&&U.resetCachedMaterial(),b._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(o,v){const V=v??this.getEffect();if(!V)return;const g=this._options.uniforms;-1!==g.indexOf("world")&&V.setMatrix("world",o);const E=this.Fo();-1!==g.indexOf("worldView")&&(o.multiplyToRef(E.getViewMatrix(),this._cachedWorldViewMatrix),V.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==g.indexOf("worldViewProjection")&&(o.multiplyToRef(E.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),V.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==g.indexOf("view")&&V.setMatrix("view",E.getViewMatrix())}bindForSubMesh(o,v,V){var g;this.bind(o,v,null===(g=V._drawWrapperOverride)||void 0===g?void 0:g.effect,V)}bind(o,v,V,g){const E=g&&this._storeEffectOnSubMeshes,I=V??(E?g.effect:this.getEffect());if(!I)return;const Q=this.Fo();this._activeEffect=I,this.bindOnlyWorldMatrix(o,V);const U=this._options.uniformBuffers;let n=!1;if(I&&U&&U.length>0&&Q.getEngine().supportsUniformBuffers)for(let x=0;x<U.length;++x){switch(U[x]){case"Mesh":v&&(v.getMeshUniformBuffer().bindToEffect(I,"Mesh"),v.transferToEffect(o));break;case"Scene":(0,S.l)(I,Q.getSceneUniformBuffer()),Q.finalizeSceneUbo(),n=!0}}const O=v&&E?this._mustRebind(Q,I,g,v.visibility):Q.getCachedMaterial()!==this;if(I&&O){let o;for(o in n||-1===this._options.uniforms.indexOf("view")||I.setMatrix("view",Q.getViewMatrix()),n||-1===this._options.uniforms.indexOf("projection")||I.setMatrix("projection",Q.getProjectionMatrix()),n||-1===this._options.uniforms.indexOf("viewProjection")||(I.setMatrix("viewProjection",Q.getTransformMatrix()),this._multiview&&I.setMatrix("viewProjectionR",Q._transformMatrixR)),Q.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&I.setVector3("cameraPosition",Q.activeCamera.globalPosition),(0,S.c)(v,I),(0,l.c)(I,this,Q),this._useLogarithmicDepth&&(0,S.j)(E?g.materialDefines:I.defines,I,Q),v&&(0,S.e)(Q,v,I),this._textures)I.setTexture(o,this._textures[o]);for(o in this._textureArrays)I.setTextureArray(o,this._textureArrays[o]);for(o in this._ints)I.setInt(o,this._ints[o]);for(o in this._uints)I.setUInt(o,this._uints[o]);for(o in this._floats)I.setFloat(o,this._floats[o]);for(o in this._floatsArrays)I.setArray(o,this._floatsArrays[o]);for(o in this._colors3)I.setColor3(o,this._colors3[o]);for(o in this._colors3Arrays)I.setArray3(o,this._colors3Arrays[o]);for(o in this._colors4){const v=this._colors4[o];I.setFloat4(o,v.r,v.g,v.b,v.a)}for(o in this._colors4Arrays)I.setArray4(o,this._colors4Arrays[o]);for(o in this._vectors2)I.setVector2(o,this._vectors2[o]);for(o in this._vectors3)I.setVector3(o,this._vectors3[o]);for(o in this._vectors4)I.setVector4(o,this._vectors4[o]);for(o in this._quaternions)I.setQuaternion(o,this._quaternions[o]);for(o in this._matrices)I.setMatrix(o,this._matrices[o]);for(o in this._matrixArrays)I.setMatrices(o,this._matrixArrays[o]);for(o in this._matrices3x3)I.setMatrix3x3(o,this._matrices3x3[o]);for(o in this._matrices2x2)I.setMatrix2x2(o,this._matrices2x2[o]);for(o in this._vectors2Arrays)I.setArray2(o,this._vectors2Arrays[o]);for(o in this._vectors3Arrays)I.setArray3(o,this._vectors3Arrays[o]);for(o in this._vectors4Arrays)I.setArray4(o,this._vectors4Arrays[o]);for(o in this._quaternionsArrays)I.setArray4(o,this._quaternionsArrays[o]);for(o in this._uniformBuffers){const v=this._uniformBuffers[o].getBuffer();v&&I.bindUniformBuffer(v,o)}const V=Q.getEngine(),U=V.setExternalTexture;if(U)for(o in this._externalTextures)U.call(V,o,this._externalTextures[o]);const O=V.setTextureSampler;if(O)for(o in this._textureSamplers)O.call(V,o,this._textureSamplers[o]);const h=V.setStorageBuffer;if(h)for(o in this._storageBuffers)h.call(V,o,this._storageBuffers[o])}if(I&&v&&(O||!this.isFrozen)){(0,S.k)(v,I),v.morphTargetManager&&v.morphTargetManager.isUsingTextureForTargets&&v.morphTargetManager._bind(I);const o=v.bakedVertexAnimationManager;if(o&&o.isEnabled){var h;const o=E?g._drawWrapper:this._drawWrapper;null===(h=v.bakedVertexAnimationManager)||void 0===h||h.bind(I,!!o._wasPreviouslyUsingInstances)}}this._afterBind(v,I,g)}getActiveTextures(){const o=super.getActiveTextures();for(const v in this._textures)o.push(this._textures[v]);for(const v in this._textureArrays){const V=this._textureArrays[v];for(let v=0;v<V.length;v++)o.push(V[v])}return o}hasTexture(o){if(super.hasTexture(o))return!0;for(const v in this._textures)if(this._textures[v]===o)return!0;for(const v in this._textureArrays){const V=this._textureArrays[v];for(let v=0;v<V.length;v++)if(V[v]===o)return!0}return!1}clone(o){const v=g.c.Clone((()=>new c(o,this.Fo(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);v.name=o,v.id=o,"object"===typeof v._shaderPath&&(v._shaderPath={...v._shaderPath}),this._options={...this._options};const V=Object.keys(this._options);for(const g of V){const o=this._options[g];Array.isArray(o)&&(this._options[g]=o.slice(0))}this.Rg.copyTo(v.Rg);for(const g in this._textures)v.setTexture(g,this._textures[g]);for(const g in this._textureArrays)v.setTextureArray(g,this._textureArrays[g]);for(const g in this._externalTextures)v.setExternalTexture(g,this._externalTextures[g]);for(const g in this._ints)v.setInt(g,this._ints[g]);for(const g in this._uints)v.setUInt(g,this._uints[g]);for(const g in this._floats)v.setFloat(g,this._floats[g]);for(const g in this._floatsArrays)v.setFloats(g,this._floatsArrays[g]);for(const g in this._colors3)v.setColor3(g,this._colors3[g]);for(const g in this._colors3Arrays)v._colors3Arrays[g]=this._colors3Arrays[g];for(const g in this._colors4)v.setColor4(g,this._colors4[g]);for(const g in this._colors4Arrays)v._colors4Arrays[g]=this._colors4Arrays[g];for(const g in this._vectors2)v.setVector2(g,this._vectors2[g]);for(const g in this._vectors3)v.setVector3(g,this._vectors3[g]);for(const g in this._vectors4)v.setVector4(g,this._vectors4[g]);for(const g in this._quaternions)v.setQuaternion(g,this._quaternions[g]);for(const g in this._quaternionsArrays)v._quaternionsArrays[g]=this._quaternionsArrays[g];for(const g in this._matrices)v.setMatrix(g,this._matrices[g]);for(const g in this._matrixArrays)v._matrixArrays[g]=this._matrixArrays[g].slice();for(const g in this._matrices3x3)v.setMatrix3x3(g,this._matrices3x3[g]);for(const g in this._matrices2x2)v.setMatrix2x2(g,this._matrices2x2[g]);for(const g in this._vectors2Arrays)v.setArray2(g,this._vectors2Arrays[g]);for(const g in this._vectors3Arrays)v.setArray3(g,this._vectors3Arrays[g]);for(const g in this._vectors4Arrays)v.setArray4(g,this._vectors4Arrays[g]);for(const g in this._uniformBuffers)v.setUniformBuffer(g,this._uniformBuffers[g]);for(const g in this._textureSamplers)v.setTextureSampler(g,this._textureSamplers[g]);for(const g in this._storageBuffers)v.setStorageBuffer(g,this._storageBuffers[g]);return v}dispose(o,v,V){if(v){let o;for(o in this._textures)this._textures[o].dispose();for(o in this._textureArrays){const v=this._textureArrays[o];for(let o=0;o<v.length;o++)v[o].dispose()}}this._textures={},super.dispose(o,v,V)}serialize(){const o=g.c.Serialize(this);let v;for(v in o.customType="BABYLON.ShaderMaterial",o.uniqueId=this.uniqueId,o.options=this._options,o.shaderPath=this._shaderPath,o.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,o.Rg=this.Rg.serialize(),o.textures={},this._textures)o.textures[v]=this._textures[v].serialize();for(v in o.textureArrays={},this._textureArrays){o.textureArrays[v]=[];const V=this._textureArrays[v];for(let g=0;g<V.length;g++)o.textureArrays[v].push(V[g].serialize())}for(v in o.ints={},this._ints)o.ints[v]=this._ints[v];for(v in o.uints={},this._uints)o.uints[v]=this._uints[v];for(v in o.floats={},this._floats)o.floats[v]=this._floats[v];for(v in o.floatsArrays={},this._floatsArrays)o.floatsArrays[v]=this._floatsArrays[v];for(v in o.colors3={},this._colors3){const V=this._colors3[v];o.colors3[v]=[V.r,V.g,V.b]}for(v in o.colors3Arrays={},this._colors3Arrays)o.colors3Arrays[v]=this._colors3Arrays[v];for(v in o.colors4={},this._colors4){const V=this._colors4[v];o.colors4[v]=[V.r,V.g,V.b,V.a]}for(v in o.colors4Arrays={},this._colors4Arrays)o.colors4Arrays[v]=this._colors4Arrays[v];for(v in o.vectors2={},this._vectors2){const V=this._vectors2[v];o.vectors2[v]=[V.x,V.y]}for(v in o.vectors3={},this._vectors3){const V=this._vectors3[v];o.vectors3[v]=[V.x,V.y,V.z]}for(v in o.vectors4={},this._vectors4){const V=this._vectors4[v];o.vectors4[v]=[V.x,V.y,V.z,V.w]}for(v in o.quaternions={},this._quaternions)o.quaternions[v]=this._quaternions[v].Dg();for(v in o.matrices={},this._matrices)o.matrices[v]=this._matrices[v].Dg();for(v in o.matrixArray={},this._matrixArrays)o.matrixArray[v]=this._matrixArrays[v];for(v in o.matrices3x3={},this._matrices3x3)o.matrices3x3[v]=this._matrices3x3[v];for(v in o.matrices2x2={},this._matrices2x2)o.matrices2x2[v]=this._matrices2x2[v];for(v in o.vectors2Arrays={},this._vectors2Arrays)o.vectors2Arrays[v]=this._vectors2Arrays[v];for(v in o.vectors3Arrays={},this._vectors3Arrays)o.vectors3Arrays[v]=this._vectors3Arrays[v];for(v in o.vectors4Arrays={},this._vectors4Arrays)o.vectors4Arrays[v]=this._vectors4Arrays[v];for(v in o.quaternionsArrays={},this._quaternionsArrays)o.quaternionsArrays[v]=this._quaternionsArrays[v];return o}static Parse(o,v,V){const E=g.c.Parse((()=>new c(o.name,v,o.shaderPath,o.options,o.storeEffectOnSubMeshes)),o,v,V);let Q;for(Q in o.Rg&&E.Rg.parse(o.Rg,v,V),o.textures)E.setTexture(Q,U.e.Parse(o.textures[Q],v,V));for(Q in o.textureArrays){const g=o.textureArrays[Q],I=[];for(let o=0;o<g.length;o++)I.push(U.e.Parse(g[o],v,V));E.setTextureArray(Q,I)}for(Q in o.ints)E.setInt(Q,o.ints[Q]);for(Q in o.uints)E.setUInt(Q,o.uints[Q]);for(Q in o.floats)E.setFloat(Q,o.floats[Q]);for(Q in o.floatsArrays)E.setFloats(Q,o.floatsArrays[Q]);for(Q in o.colors3){const v=o.colors3[Q];E.setColor3(Q,{r:v[0],g:v[1],b:v[2]})}for(Q in o.colors3Arrays){const v=o.colors3Arrays[Q].reduce(((o,v,V)=>(V%3===0?o.push([v]):o[o.length-1].push(v),o)),[]).map((o=>({r:o[0],g:o[1],b:o[2]})));E.setColor3Array(Q,v)}for(Q in o.colors4){const v=o.colors4[Q];E.setColor4(Q,{r:v[0],g:v[1],b:v[2],a:v[3]})}for(Q in o.colors4Arrays){const v=o.colors4Arrays[Q].reduce(((o,v,V)=>(V%4===0?o.push([v]):o[o.length-1].push(v),o)),[]).map((o=>({r:o[0],g:o[1],b:o[2],a:o[3]})));E.setColor4Array(Q,v)}for(Q in o.vectors2){const v=o.vectors2[Q];E.setVector2(Q,{x:v[0],y:v[1]})}for(Q in o.vectors3){const v=o.vectors3[Q];E.setVector3(Q,{x:v[0],y:v[1],z:v[2]})}for(Q in o.vectors4){const v=o.vectors4[Q];E.setVector4(Q,{x:v[0],y:v[1],z:v[2],w:v[3]})}for(Q in o.quaternions)E.setQuaternion(Q,I.Quaternion.bv(o.quaternions[Q]));for(Q in o.matrices)E.setMatrix(Q,I.Matrix.bv(o.matrices[Q]));for(Q in o.matrixArray)E._matrixArrays[Q]=new Float32Array(o.matrixArray[Q]);for(Q in o.matrices3x3)E.setMatrix3x3(Q,o.matrices3x3[Q]);for(Q in o.matrices2x2)E.setMatrix2x2(Q,o.matrices2x2[Q]);for(Q in o.vectors2Arrays)E.setArray2(Q,o.vectors2Arrays[Q]);for(Q in o.vectors3Arrays)E.setArray3(Q,o.vectors3Arrays[Q]);for(Q in o.vectors4Arrays)E.setArray4(Q,o.vectors4Arrays[Q]);for(Q in o.quaternionsArrays)E.setArray4(Q,o.quaternionsArrays[Q]);return E}static async ParseFromFileAsync(o,v,V){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((E,I)=>{const Q=new h.b;Q.addEventListener("readystatechange",(()=>{if(4==Q.readyState)if(200==Q.status){const v=JSON.parse(Q.responseText),I=this.Parse(v,V||f.d.LastCreatedScene,g);o&&(I.name=o),E(I)}else I("Unable to load the ShaderMaterial")})),Q.open("GET",v),Q.send()}))}static async ParseFromSnippetAsync(o,v){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((g,E)=>{const I=new h.b;I.addEventListener("readystatechange",(()=>{if(4==I.readyState)if(200==I.status){const E=JSON.parse(JSON.parse(I.responseText).jsonPayload),Q=JSON.parse(E.shaderMaterial),U=this.Parse(Q,v||f.d.LastCreatedScene,V);U.snippetId=o,g(U)}else E("Unable to load the snippet "+o)})),I.open("GET",this.SnippetUrl+"/"+o.replace(/#/g,"/")),I.send()}))}}c.SnippetUrl="https://snippet.babylonjs.com",c.CreateFromSnippetAsync=c.ParseFromSnippetAsync,(0,n.h)("BABYLON.ShaderMaterial",c)}}]);