"use strict";(self.wy695la1oic=self.wy695la1oic||[]).push([[22],{11616:(S,v,D)=>{D.r(v),D.d(v,{ShaderMaterial:()=>I});var z=D(11415),e=D(11619),N=D(11371),m=D(11452),B=D(11350),g=D(11329),E=D(11687),h=D(11214),A=D(11692),w=D(11222),n=D(11738),R=D(11736);const O={effect:null,subMesh:null};class I extends A.c{constructor(S,v,D){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(S,v,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new N.Matrix,this._cachedWorldViewProjectionMatrix=new N.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=D,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...z}}get shaderPath(){return this._shaderPath}set shaderPath(S){this._shaderPath=S}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(S){-1===this._options.uniforms.indexOf(S)&&this._options.uniforms.push(S)}setTexture(S,v){return-1===this._options.samplers.indexOf(S)&&this._options.samplers.push(S),this._textures[S]=v,this}removeTexture(S){delete this._textures[S]}setTextureArray(S,v){return-1===this._options.samplers.indexOf(S)&&this._options.samplers.push(S),this._checkUniform(S),this._textureArrays[S]=v,this}setExternalTexture(S,v){return-1===this._options.externalTextures.indexOf(S)&&this._options.externalTextures.push(S),this._externalTextures[S]=v,this}setFloat(S,v){return this._checkUniform(S),this._floats[S]=v,this}setInt(S,v){return this._checkUniform(S),this._ints[S]=v,this}setUInt(S,v){return this._checkUniform(S),this._uints[S]=v,this}setFloats(S,v){return this._checkUniform(S),this._floatsArrays[S]=v,this}setColor3(S,v){return this._checkUniform(S),this._colors3[S]=v,this}setColor3Array(S,v){return this._checkUniform(S),this._colors3Arrays[S]=v.reduce(((S,v)=>(S.push(v.r,v.g,v.b),S)),[]),this}setColor4(S,v){return this._checkUniform(S),this._colors4[S]=v,this}setColor4Array(S,v){return this._checkUniform(S),this._colors4Arrays[S]=v.reduce(((S,v)=>(S.push(v.r,v.g,v.b,v.a),S)),[]),this}setVector2(S,v){return this._checkUniform(S),this._vectors2[S]=v,this}setVector3(S,v){return this._checkUniform(S),this._vectors3[S]=v,this}setVector4(S,v){return this._checkUniform(S),this._vectors4[S]=v,this}setQuaternion(S,v){return this._checkUniform(S),this._quaternions[S]=v,this}setQuaternionArray(S,v){return this._checkUniform(S),this._quaternionsArrays[S]=v.reduce(((S,v)=>(v.toArray(S,S.length),S)),[]),this}setMatrix(S,v){return this._checkUniform(S),this._matrices[S]=v,this}setMatrices(S,v){this._checkUniform(S);const D=new Float32Array(16*v.length);for(let z=0;z<v.length;z++){v[z].copyToArray(D,16*z)}return this._matrixArrays[S]=D,this}setMatrix3x3(S,v){return this._checkUniform(S),this._matrices3x3[S]=v,this}setMatrix2x2(S,v){return this._checkUniform(S),this._matrices2x2[S]=v,this}setArray2(S,v){return this._checkUniform(S),this._vectors2Arrays[S]=v,this}setArray3(S,v){return this._checkUniform(S),this._vectors3Arrays[S]=v,this}setArray4(S,v){return this._checkUniform(S),this._vectors4Arrays[S]=v,this}setUniformBuffer(S,v){return-1===this._options.uniformBuffers.indexOf(S)&&this._options.uniformBuffers.push(S),this._uniformBuffers[S]=v,this}setTextureSampler(S,v){return-1===this._options.samplerObjects.indexOf(S)&&this._options.samplerObjects.push(S),this._textureSamplers[S]=v,this}setStorageBuffer(S,v){return-1===this._options.storageBuffers.indexOf(S)&&this._options.storageBuffers.push(S),this._storageBuffers[S]=v,this}setDefine(S,v){const D=S.trimEnd()+" ",z=this.options.defines.findIndex((v=>v===S||v.startsWith(D)));return z>=0&&this.options.defines.splice(z,1),("boolean"!==typeof v||v)&&this.options.defines.push(D+v),this}isReadyForSubMesh(S,v,D){return this.isReady(S,D,v)}isReady(S,v,D){var z;const N=D&&this._storeEffectOnSubMeshes;if(this.isFrozen){const S=N?D._drawWrapper:this._drawWrapper;if(S.effect&&S._wasPreviouslyReady&&S._wasPreviouslyUsingInstances===v)return!0}const B=this.xS(),g=B.getEngine(),h=[],A=[];let w=null,I=this._shaderPath,K=this._options.uniforms,q=this._options.uniformBuffers,u=this._options.samplers;g.getCaps().multiview&&B.activeCamera&&B.activeCamera.outputRenderTarget&&B.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,h.push("#define MULTIVIEW"),-1!==K.indexOf("viewProjection")&&-1===K.indexOf("viewProjectionR")&&K.push("viewProjectionR"));for(let e=0;e<this._options.defines.length;e++){const S=0===this._options.defines[e].indexOf("#define")?this._options.defines[e]:`#define ${this._options.defines[e]}`;h.push(S)}for(let e=0;e<this._options.attributes.length;e++)A.push(this._options.attributes[e]);if(S&&S.isVerticesDataPresent(m.d.ColorKind)&&(-1===A.indexOf(m.d.ColorKind)&&A.push(m.d.ColorKind),h.push("#define VERTEXCOLOR")),v&&(h.push("#define INSTANCES"),(0,R.cb)(A,this._materialHelperNeedsPreviousMatrices),null!==S&&void 0!==S&&S.hasThinInstances&&(h.push("#define THIN_INSTANCES"),S&&S.isVerticesDataPresent(m.d.ColorInstanceKind)&&(A.push(m.d.ColorInstanceKind),h.push("#define INSTANCESCOLOR")))),S&&S.useBones&&S.computeBonesUsingShaders&&S.skeleton){A.push(m.d.MatricesIndicesKind),A.push(m.d.MatricesWeightsKind),S.numBoneInfluencers>4&&(A.push(m.d.MatricesIndicesExtraKind),A.push(m.d.MatricesWeightsExtraKind));const v=S.skeleton;h.push("#define NUM_BONE_INFLUENCERS "+S.numBoneInfluencers),w=new E.d,w.addCPUSkinningFallback(0,S),v.isUsingTextureForMatrices?(h.push("#define BONETEXTURE"),-1===K.indexOf("boneTextureWidth")&&K.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(h.push("#define BonesPerMesh "+(v.bones.length+1)),-1===K.indexOf("mBones")&&K.push("mBones"))}else h.push("#define NUM_BONE_INFLUENCERS 0");let s=0;const r=S?S.morphTargetManager:null;if(r){const v=-1!==h.indexOf("#define UV1"),D=-1!==h.indexOf("#define UV2"),z=-1!==h.indexOf("#define TANGENT"),e=-1!==h.indexOf("#define NORMAL"),N=-1!==h.indexOf("#define VERTEXCOLOR");s=(0,R.H)(r,h,A,S,!0,e,z,v,D,N),r.isUsingTextureForTargets&&(-1===K.indexOf("morphTargetTextureIndices")&&K.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),s>0&&(K=K.slice(),K.push("morphTargetInfluences"),K.push("morphTargetCount"),K.push("morphTargetTextureInfo"),K.push("morphTargetTextureIndices"))}else h.push("#define NUM_MORPH_INFLUENCERS 0");if(S){const v=S.bakedVertexAnimationManager;v&&v.isEnabled&&(h.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===K.indexOf("bakedVertexAnimationSettings")&&K.push("bakedVertexAnimationSettings"),-1===K.indexOf("bakedVertexAnimationTextureSizeInverted")&&K.push("bakedVertexAnimationTextureSizeInverted"),-1===K.indexOf("bakedVertexAnimationTime")&&K.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,R.z)(A,S,h)}for(const e in this._textures)if(!this._textures[e].isReady())return!1;S&&this.needAlphaTestingForMesh(S)&&h.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,n.d)(K),(0,n.h)(this,B,h)),B.fogEnabled&&null!==S&&void 0!==S&&S.applyFog&&B.fogMode!==e.d.FOGMODE_NONE&&(h.push("#define FOG"),-1===K.indexOf("view")&&K.push("view"),-1===K.indexOf("vFogInfos")&&K.push("vFogInfos"),-1===K.indexOf("vFogColor")&&K.push("vFogColor")),this._useLogarithmicDepth&&(h.push("#define LOGARITHMICDEPTH"),-1===K.indexOf("logarithmicDepthConstant")&&K.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(K=K.slice(),q=q.slice(),u=u.slice(),I=this.customShaderNameResolve(this.name,K,q,u,h,A));const d=N?D._getDrawWrapper(void 0,!0):this._drawWrapper,x=(null===d||void 0===d?void 0:d.effect)??null,W=(null===d||void 0===d?void 0:d.defines)??null,p=h.join("\n");let b=x;return W!==p&&(b=g.createEffect(I,{attributes:A,uniformsNames:K,uniformBuffersNames:q,samplers:u,defines:p,fallbacks:w,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:s},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},g),N?D.setEffect(b,p,this._materialContext):d&&d.setEffect(b,p),this._onEffectCreatedObservable&&(O.effect=b,O.subMesh=D??(null===S||void 0===S?void 0:S.he[0])??null,this._onEffectCreatedObservable.notifyObservers(O))),d._wasPreviouslyUsingInstances=!!v,!(null===(z=b)||void 0===z||!z.isReady())&&(x!==b&&B.resetCachedMaterial(),d._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(S,v){const D=v??this.getEffect();if(!D)return;const z=this._options.uniforms;-1!==z.indexOf("world")&&D.setMatrix("world",S);const e=this.xS();-1!==z.indexOf("worldView")&&(S.multiplyToRef(e.getViewMatrix(),this._cachedWorldViewMatrix),D.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==z.indexOf("worldViewProjection")&&(S.multiplyToRef(e.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),D.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==z.indexOf("view")&&D.setMatrix("view",e.getViewMatrix())}bindForSubMesh(S,v,D){var z;this.bind(S,v,null===(z=D._drawWrapperOverride)||void 0===z?void 0:z.effect,D)}bind(S,v,D,z){const e=z&&this._storeEffectOnSubMeshes,N=D??(e?z.effect:this.getEffect());if(!N)return;const m=this.xS();this._activeEffect=N,this.bindOnlyWorldMatrix(S,D);const B=this._options.uniformBuffers;let g=!1;if(N&&B&&B.length>0&&m.getEngine().supportsUniformBuffers)for(let A=0;A<B.length;++A){switch(B[A]){case"Mesh":v&&(v.getMeshUniformBuffer().bindToEffect(N,"Mesh"),v.transferToEffect(S));break;case"Scene":(0,R.r)(N,m.getSceneUniformBuffer()),m.finalizeSceneUbo(),g=!0}}const E=v&&e?this._mustRebind(m,N,z,v.visibility):m.getCachedMaterial()!==this;if(N&&E){let S;for(S in g||-1===this._options.uniforms.indexOf("view")||N.setMatrix("view",m.getViewMatrix()),g||-1===this._options.uniforms.indexOf("projection")||N.setMatrix("projection",m.getProjectionMatrix()),g||-1===this._options.uniforms.indexOf("viewProjection")||(N.setMatrix("viewProjection",m.getTransformMatrix()),this._multiview&&N.setMatrix("viewProjectionR",m._transformMatrixR)),m.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&N.setVector3("cameraPosition",m.activeCamera.globalPosition),(0,R.e)(v,N),(0,n.e)(N,this,m),this._useLogarithmicDepth&&(0,R.m)(e?z.materialDefines:N.defines,N,m),v&&(0,R.h)(m,v,N),this._textures)N.setTexture(S,this._textures[S]);for(S in this._textureArrays)N.setTextureArray(S,this._textureArrays[S]);for(S in this._ints)N.setInt(S,this._ints[S]);for(S in this._uints)N.setUInt(S,this._uints[S]);for(S in this._floats)N.setFloat(S,this._floats[S]);for(S in this._floatsArrays)N.setArray(S,this._floatsArrays[S]);for(S in this._colors3)N.setColor3(S,this._colors3[S]);for(S in this._colors3Arrays)N.setArray3(S,this._colors3Arrays[S]);for(S in this._colors4){const v=this._colors4[S];N.setFloat4(S,v.r,v.g,v.b,v.a)}for(S in this._colors4Arrays)N.setArray4(S,this._colors4Arrays[S]);for(S in this._vectors2)N.setVector2(S,this._vectors2[S]);for(S in this._vectors3)N.setVector3(S,this._vectors3[S]);for(S in this._vectors4)N.setVector4(S,this._vectors4[S]);for(S in this._quaternions)N.setQuaternion(S,this._quaternions[S]);for(S in this._matrices)N.setMatrix(S,this._matrices[S]);for(S in this._matrixArrays)N.setMatrices(S,this._matrixArrays[S]);for(S in this._matrices3x3)N.setMatrix3x3(S,this._matrices3x3[S]);for(S in this._matrices2x2)N.setMatrix2x2(S,this._matrices2x2[S]);for(S in this._vectors2Arrays)N.setArray2(S,this._vectors2Arrays[S]);for(S in this._vectors3Arrays)N.setArray3(S,this._vectors3Arrays[S]);for(S in this._vectors4Arrays)N.setArray4(S,this._vectors4Arrays[S]);for(S in this._quaternionsArrays)N.setArray4(S,this._quaternionsArrays[S]);for(S in this._uniformBuffers){const v=this._uniformBuffers[S].getBuffer();v&&N.bindUniformBuffer(v,S)}const D=m.getEngine(),B=D.setExternalTexture;if(B)for(S in this._externalTextures)B.call(D,S,this._externalTextures[S]);const E=D.setTextureSampler;if(E)for(S in this._textureSamplers)E.call(D,S,this._textureSamplers[S]);const h=D.setStorageBuffer;if(h)for(S in this._storageBuffers)h.call(D,S,this._storageBuffers[S])}if(N&&v&&(E||!this.isFrozen)){(0,R.p)(v,N),v.morphTargetManager&&v.morphTargetManager.isUsingTextureForTargets&&v.morphTargetManager._bind(N);const S=v.bakedVertexAnimationManager;if(S&&S.isEnabled){var h;const S=e?z._drawWrapper:this._drawWrapper;null===(h=v.bakedVertexAnimationManager)||void 0===h||h.bind(N,!!S._wasPreviouslyUsingInstances)}}this._afterBind(v,N,z)}getActiveTextures(){const S=super.getActiveTextures();for(const v in this._textures)S.push(this._textures[v]);for(const v in this._textureArrays){const D=this._textureArrays[v];for(let v=0;v<D.length;v++)S.push(D[v])}return S}hasTexture(S){if(super.hasTexture(S))return!0;for(const v in this._textures)if(this._textures[v]===S)return!0;for(const v in this._textureArrays){const D=this._textureArrays[v];for(let v=0;v<D.length;v++)if(D[v]===S)return!0}return!1}clone(S){const v=z.b.Clone((()=>new I(S,this.xS(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);v.name=S,v.id=S,"object"===typeof v._shaderPath&&(v._shaderPath={...v._shaderPath}),this._options={...this._options};const D=Object.keys(this._options);for(const z of D){const S=this._options[z];Array.isArray(S)&&(this._options[z]=S.slice(0))}this.stencil.copyTo(v.stencil);for(const z in this._textures)v.setTexture(z,this._textures[z]);for(const z in this._textureArrays)v.setTextureArray(z,this._textureArrays[z]);for(const z in this._externalTextures)v.setExternalTexture(z,this._externalTextures[z]);for(const z in this._ints)v.setInt(z,this._ints[z]);for(const z in this._uints)v.setUInt(z,this._uints[z]);for(const z in this._floats)v.setFloat(z,this._floats[z]);for(const z in this._floatsArrays)v.setFloats(z,this._floatsArrays[z]);for(const z in this._colors3)v.setColor3(z,this._colors3[z]);for(const z in this._colors3Arrays)v._colors3Arrays[z]=this._colors3Arrays[z];for(const z in this._colors4)v.setColor4(z,this._colors4[z]);for(const z in this._colors4Arrays)v._colors4Arrays[z]=this._colors4Arrays[z];for(const z in this._vectors2)v.setVector2(z,this._vectors2[z]);for(const z in this._vectors3)v.setVector3(z,this._vectors3[z]);for(const z in this._vectors4)v.setVector4(z,this._vectors4[z]);for(const z in this._quaternions)v.setQuaternion(z,this._quaternions[z]);for(const z in this._quaternionsArrays)v._quaternionsArrays[z]=this._quaternionsArrays[z];for(const z in this._matrices)v.setMatrix(z,this._matrices[z]);for(const z in this._matrixArrays)v._matrixArrays[z]=this._matrixArrays[z].slice();for(const z in this._matrices3x3)v.setMatrix3x3(z,this._matrices3x3[z]);for(const z in this._matrices2x2)v.setMatrix2x2(z,this._matrices2x2[z]);for(const z in this._vectors2Arrays)v.setArray2(z,this._vectors2Arrays[z]);for(const z in this._vectors3Arrays)v.setArray3(z,this._vectors3Arrays[z]);for(const z in this._vectors4Arrays)v.setArray4(z,this._vectors4Arrays[z]);for(const z in this._uniformBuffers)v.setUniformBuffer(z,this._uniformBuffers[z]);for(const z in this._textureSamplers)v.setTextureSampler(z,this._textureSamplers[z]);for(const z in this._storageBuffers)v.setStorageBuffer(z,this._storageBuffers[z]);return v}dispose(S,v,D){if(v){let S;for(S in this._textures)this._textures[S].dispose();for(S in this._textureArrays){const v=this._textureArrays[S];for(let S=0;S<v.length;S++)v[S].dispose()}}this._textures={},super.dispose(S,v,D)}serialize(){const S=z.b.Serialize(this);let v;for(v in S.customType="BABYLON.ShaderMaterial",S.uniqueId=this.uniqueId,S.options=this._options,S.shaderPath=this._shaderPath,S.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,S.stencil=this.stencil.serialize(),S.textures={},this._textures)S.textures[v]=this._textures[v].serialize();for(v in S.textureArrays={},this._textureArrays){S.textureArrays[v]=[];const D=this._textureArrays[v];for(let z=0;z<D.length;z++)S.textureArrays[v].push(D[z].serialize())}for(v in S.ints={},this._ints)S.ints[v]=this._ints[v];for(v in S.uints={},this._uints)S.uints[v]=this._uints[v];for(v in S.floats={},this._floats)S.floats[v]=this._floats[v];for(v in S.floatsArrays={},this._floatsArrays)S.floatsArrays[v]=this._floatsArrays[v];for(v in S.colors3={},this._colors3){const D=this._colors3[v];S.colors3[v]=[D.r,D.g,D.b]}for(v in S.colors3Arrays={},this._colors3Arrays)S.colors3Arrays[v]=this._colors3Arrays[v];for(v in S.colors4={},this._colors4){const D=this._colors4[v];S.colors4[v]=[D.r,D.g,D.b,D.a]}for(v in S.colors4Arrays={},this._colors4Arrays)S.colors4Arrays[v]=this._colors4Arrays[v];for(v in S.vectors2={},this._vectors2){const D=this._vectors2[v];S.vectors2[v]=[D.x,D.y]}for(v in S.vectors3={},this._vectors3){const D=this._vectors3[v];S.vectors3[v]=[D.x,D.y,D.z]}for(v in S.vectors4={},this._vectors4){const D=this._vectors4[v];S.vectors4[v]=[D.x,D.y,D.z,D.w]}for(v in S.quaternions={},this._quaternions)S.quaternions[v]=this._quaternions[v].Oe();for(v in S.matrices={},this._matrices)S.matrices[v]=this._matrices[v].Oe();for(v in S.matrixArray={},this._matrixArrays)S.matrixArray[v]=this._matrixArrays[v];for(v in S.matrices3x3={},this._matrices3x3)S.matrices3x3[v]=this._matrices3x3[v];for(v in S.matrices2x2={},this._matrices2x2)S.matrices2x2[v]=this._matrices2x2[v];for(v in S.vectors2Arrays={},this._vectors2Arrays)S.vectors2Arrays[v]=this._vectors2Arrays[v];for(v in S.vectors3Arrays={},this._vectors3Arrays)S.vectors3Arrays[v]=this._vectors3Arrays[v];for(v in S.vectors4Arrays={},this._vectors4Arrays)S.vectors4Arrays[v]=this._vectors4Arrays[v];for(v in S.quaternionsArrays={},this._quaternionsArrays)S.quaternionsArrays[v]=this._quaternionsArrays[v];return S}static Parse(S,v,D){const e=z.b.Parse((()=>new I(S.name,v,S.shaderPath,S.options,S.storeEffectOnSubMeshes)),S,v,D);let m;for(m in S.stencil&&e.stencil.parse(S.stencil,v,D),S.textures)e.setTexture(m,B.d.Parse(S.textures[m],v,D));for(m in S.textureArrays){const z=S.textureArrays[m],N=[];for(let S=0;S<z.length;S++)N.push(B.d.Parse(z[S],v,D));e.setTextureArray(m,N)}for(m in S.ints)e.setInt(m,S.ints[m]);for(m in S.uints)e.setUInt(m,S.uints[m]);for(m in S.floats)e.setFloat(m,S.floats[m]);for(m in S.floatsArrays)e.setFloats(m,S.floatsArrays[m]);for(m in S.colors3){const v=S.colors3[m];e.setColor3(m,{r:v[0],g:v[1],b:v[2]})}for(m in S.colors3Arrays){const v=S.colors3Arrays[m].reduce(((S,v,D)=>(D%3===0?S.push([v]):S[S.length-1].push(v),S)),[]).map((S=>({r:S[0],g:S[1],b:S[2]})));e.setColor3Array(m,v)}for(m in S.colors4){const v=S.colors4[m];e.setColor4(m,{r:v[0],g:v[1],b:v[2],a:v[3]})}for(m in S.colors4Arrays){const v=S.colors4Arrays[m].reduce(((S,v,D)=>(D%4===0?S.push([v]):S[S.length-1].push(v),S)),[]).map((S=>({r:S[0],g:S[1],b:S[2],a:S[3]})));e.setColor4Array(m,v)}for(m in S.vectors2){const v=S.vectors2[m];e.setVector2(m,{x:v[0],y:v[1]})}for(m in S.vectors3){const v=S.vectors3[m];e.setVector3(m,{x:v[0],y:v[1],z:v[2]})}for(m in S.vectors4){const v=S.vectors4[m];e.setVector4(m,{x:v[0],y:v[1],z:v[2],w:v[3]})}for(m in S.quaternions)e.setQuaternion(m,N.Quaternion.uv(S.quaternions[m]));for(m in S.matrices)e.setMatrix(m,N.Matrix.uv(S.matrices[m]));for(m in S.matrixArray)e._matrixArrays[m]=new Float32Array(S.matrixArray[m]);for(m in S.matrices3x3)e.setMatrix3x3(m,S.matrices3x3[m]);for(m in S.matrices2x2)e.setMatrix2x2(m,S.matrices2x2[m]);for(m in S.vectors2Arrays)e.setArray2(m,S.vectors2Arrays[m]);for(m in S.vectors3Arrays)e.setArray3(m,S.vectors3Arrays[m]);for(m in S.vectors4Arrays)e.setArray4(m,S.vectors4Arrays[m]);for(m in S.quaternionsArrays)e.setArray4(m,S.quaternionsArrays[m]);return e}static async ParseFromFileAsync(S,v,D){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((e,N)=>{const m=new h.c;m.addEventListener("readystatechange",(()=>{if(4==m.readyState)if(200==m.status){const v=JSON.parse(m.responseText),N=this.Parse(v,D||w.c.LastCreatedScene,z);S&&(N.name=S),e(N)}else N("Unable to load the ShaderMaterial")})),m.open("GET",v),m.send()}))}static async ParseFromSnippetAsync(S,v){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((z,e)=>{const N=new h.c;N.addEventListener("readystatechange",(()=>{if(4==N.readyState)if(200==N.status){const e=JSON.parse(JSON.parse(N.responseText).jsonPayload),m=JSON.parse(e.shaderMaterial),B=this.Parse(m,v||w.c.LastCreatedScene,D);B.snippetId=S,z(B)}else e("Unable to load the snippet "+S)})),N.open("GET",this.SnippetUrl+"/"+S.replace(/#/g,"/")),N.send()}))}}I.SnippetUrl="https://snippet.babylonjs.com",I.CreateFromSnippetAsync=I.ParseFromSnippetAsync,(0,g.f)("BABYLON.ShaderMaterial",I)}}]);