"use strict";(self.gpkvekif0vo=self.gpkvekif0vo||[]).push([[22],{12646:(a,O,i)=>{i.r(O),i.d(O,{ShaderMaterial:()=>r});var H=i(12427),b=i(12648),G=i(12395),q=i(12470),Q=i(12370),k=i(12346),I=i(12722),P=i(12227),e=i(12726),h=i(12236),j=i(12773),Z=i(12771);const F={effect:null,subMesh:null};class r extends e.d{constructor(a,O,i){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(a,O,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new G.Matrix,this._cachedWorldViewProjectionMatrix=new G.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=i,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...H}}get shaderPath(){return this._shaderPath}set shaderPath(a){this._shaderPath=a}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(a){-1===this._options.uniforms.indexOf(a)&&this._options.uniforms.push(a)}setTexture(a,O){return-1===this._options.samplers.indexOf(a)&&this._options.samplers.push(a),this._textures[a]=O,this}removeTexture(a){delete this._textures[a]}setTextureArray(a,O){return-1===this._options.samplers.indexOf(a)&&this._options.samplers.push(a),this._checkUniform(a),this._textureArrays[a]=O,this}setExternalTexture(a,O){return-1===this._options.externalTextures.indexOf(a)&&this._options.externalTextures.push(a),this._externalTextures[a]=O,this}setFloat(a,O){return this._checkUniform(a),this._floats[a]=O,this}setInt(a,O){return this._checkUniform(a),this._ints[a]=O,this}setUInt(a,O){return this._checkUniform(a),this._uints[a]=O,this}setFloats(a,O){return this._checkUniform(a),this._floatsArrays[a]=O,this}setColor3(a,O){return this._checkUniform(a),this._colors3[a]=O,this}setColor3Array(a,O){return this._checkUniform(a),this._colors3Arrays[a]=O.reduce(((a,O)=>(a.push(O.r,O.g,O.b),a)),[]),this}setColor4(a,O){return this._checkUniform(a),this._colors4[a]=O,this}setColor4Array(a,O){return this._checkUniform(a),this._colors4Arrays[a]=O.reduce(((a,O)=>(a.push(O.r,O.g,O.b,O.a),a)),[]),this}setVector2(a,O){return this._checkUniform(a),this._vectors2[a]=O,this}setVector3(a,O){return this._checkUniform(a),this._vectors3[a]=O,this}setVector4(a,O){return this._checkUniform(a),this._vectors4[a]=O,this}setQuaternion(a,O){return this._checkUniform(a),this._quaternions[a]=O,this}setQuaternionArray(a,O){return this._checkUniform(a),this._quaternionsArrays[a]=O.reduce(((a,O)=>(O.toArray(a,a.length),a)),[]),this}setMatrix(a,O){return this._checkUniform(a),this._matrices[a]=O,this}setMatrices(a,O){this._checkUniform(a);const i=new Float32Array(16*O.length);for(let H=0;H<O.length;H++){O[H].copyToArray(i,16*H)}return this._matrixArrays[a]=i,this}setMatrix3x3(a,O){return this._checkUniform(a),this._matrices3x3[a]=O,this}setMatrix2x2(a,O){return this._checkUniform(a),this._matrices2x2[a]=O,this}setArray2(a,O){return this._checkUniform(a),this._vectors2Arrays[a]=O,this}setArray3(a,O){return this._checkUniform(a),this._vectors3Arrays[a]=O,this}setArray4(a,O){return this._checkUniform(a),this._vectors4Arrays[a]=O,this}setUniformBuffer(a,O){return-1===this._options.uniformBuffers.indexOf(a)&&this._options.uniformBuffers.push(a),this._uniformBuffers[a]=O,this}setTextureSampler(a,O){return-1===this._options.samplerObjects.indexOf(a)&&this._options.samplerObjects.push(a),this._textureSamplers[a]=O,this}setStorageBuffer(a,O){return-1===this._options.storageBuffers.indexOf(a)&&this._options.storageBuffers.push(a),this._storageBuffers[a]=O,this}setDefine(a,O){const i=a.trimEnd()+" ",H=this.options.defines.findIndex((O=>O===a||O.startsWith(i)));return H>=0&&this.options.defines.splice(H,1),("boolean"!==typeof O||O)&&this.options.defines.push(i+O),this}isReadyForSubMesh(a,O,i){return this.isReady(a,i,O)}isReady(a,O,i){var H;const G=i&&this._storeEffectOnSubMeshes;if(this.isFrozen){const a=G?i._drawWrapper:this._drawWrapper;if(a.effect&&a._wasPreviouslyReady&&a._wasPreviouslyUsingInstances===O)return!0}const Q=this.Ua(),k=Q.getEngine(),P=[],e=[];let h=null,r=this._shaderPath,J=this._options.uniforms,ma=this._options.uniformBuffers,M=this._options.samplers;k.getCaps().multiview&&Q.activeCamera&&Q.activeCamera.outputRenderTarget&&Q.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,P.push("#define MULTIVIEW"),-1!==J.indexOf("viewProjection")&&-1===J.indexOf("viewProjectionR")&&J.push("viewProjectionR"));for(let b=0;b<this._options.defines.length;b++){const a=0===this._options.defines[b].indexOf("#define")?this._options.defines[b]:`#define ${this._options.defines[b]}`;P.push(a)}for(let b=0;b<this._options.attributes.length;b++)e.push(this._options.attributes[b]);if(a&&a.isVerticesDataPresent(q.c.ColorKind)&&(-1===e.indexOf(q.c.ColorKind)&&e.push(q.c.ColorKind),P.push("#define VERTEXCOLOR")),O&&(P.push("#define INSTANCES"),(0,Z._)(e,this._materialHelperNeedsPreviousMatrices),null!==a&&void 0!==a&&a.hasThinInstances&&(P.push("#define THIN_INSTANCES"),a&&a.isVerticesDataPresent(q.c.ColorInstanceKind)&&(e.push(q.c.ColorInstanceKind),P.push("#define INSTANCESCOLOR")))),a&&a.useBones&&a.computeBonesUsingShaders&&a.skeleton){e.push(q.c.MatricesIndicesKind),e.push(q.c.MatricesWeightsKind),a.numBoneInfluencers>4&&(e.push(q.c.MatricesIndicesExtraKind),e.push(q.c.MatricesWeightsExtraKind));const O=a.skeleton;P.push("#define NUM_BONE_INFLUENCERS "+a.numBoneInfluencers),h=new I.c,h.addCPUSkinningFallback(0,a),O.isUsingTextureForMatrices?(P.push("#define BONETEXTURE"),-1===J.indexOf("boneTextureWidth")&&J.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(P.push("#define BonesPerMesh "+(O.bones.length+1)),-1===J.indexOf("mBones")&&J.push("mBones"))}else P.push("#define NUM_BONE_INFLUENCERS 0");let C=0;const n=a?a.morphTargetManager:null;if(n){const O=-1!==P.indexOf("#define UV1"),i=-1!==P.indexOf("#define UV2"),H=-1!==P.indexOf("#define TANGENT"),b=-1!==P.indexOf("#define NORMAL"),G=-1!==P.indexOf("#define VERTEXCOLOR");C=(0,Z.D)(n,P,e,a,!0,b,H,O,i,G),n.isUsingTextureForTargets&&(-1===J.indexOf("morphTargetTextureIndices")&&J.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),C>0&&(J=J.slice(),J.push("morphTargetInfluences"),J.push("morphTargetCount"),J.push("morphTargetTextureInfo"),J.push("morphTargetTextureIndices"))}else P.push("#define NUM_MORPH_INFLUENCERS 0");if(a){const O=a.bakedVertexAnimationManager;O&&O.isEnabled&&(P.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===J.indexOf("bakedVertexAnimationSettings")&&J.push("bakedVertexAnimationSettings"),-1===J.indexOf("bakedVertexAnimationTextureSizeInverted")&&J.push("bakedVertexAnimationTextureSizeInverted"),-1===J.indexOf("bakedVertexAnimationTime")&&J.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,Z.v)(e,a,P)}for(const b in this._textures)if(!this._textures[b].isReady())return!1;a&&this.needAlphaTestingForMesh(a)&&P.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,j.d)(J),(0,j.h)(this,Q,P)),Q.fogEnabled&&null!==a&&void 0!==a&&a.applyFog&&Q.fogMode!==b.c.FOGMODE_NONE&&(P.push("#define FOG"),-1===J.indexOf("view")&&J.push("view"),-1===J.indexOf("vFogInfos")&&J.push("vFogInfos"),-1===J.indexOf("vFogColor")&&J.push("vFogColor")),this._useLogarithmicDepth&&(P.push("#define LOGARITHMICDEPTH"),-1===J.indexOf("logarithmicDepthConstant")&&J.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(J=J.slice(),ma=ma.slice(),M=M.slice(),r=this.customShaderNameResolve(this.name,J,ma,M,P,e));const D=G?i._getDrawWrapper(void 0,!0):this._drawWrapper,U=(null===D||void 0===D?void 0:D.effect)??null,y=(null===D||void 0===D?void 0:D.defines)??null,w=P.join("\n");let K=U;return y!==w&&(K=k.createEffect(r,{attributes:e,uniformsNames:J,uniformBuffersNames:ma,samplers:M,defines:w,fallbacks:h,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:C},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},k),G?i.setEffect(K,w,this._materialContext):D&&D.setEffect(K,w),this._onEffectCreatedObservable&&(F.effect=K,F.subMesh=i??(null===a||void 0===a?void 0:a.Mb[0])??null,this._onEffectCreatedObservable.notifyObservers(F))),D._wasPreviouslyUsingInstances=!!O,!(null===(H=K)||void 0===H||!H.isReady())&&(U!==K&&Q.resetCachedMaterial(),D._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(a,O){const i=O??this.getEffect();if(!i)return;const H=this._options.uniforms;-1!==H.indexOf("world")&&i.setMatrix("world",a);const b=this.Ua();-1!==H.indexOf("worldView")&&(a.multiplyToRef(b.getViewMatrix(),this._cachedWorldViewMatrix),i.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==H.indexOf("worldViewProjection")&&(a.multiplyToRef(b.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),i.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==H.indexOf("view")&&i.setMatrix("view",b.getViewMatrix())}bindForSubMesh(a,O,i){var H;this.bind(a,O,null===(H=i._drawWrapperOverride)||void 0===H?void 0:H.effect,i)}bind(a,O,i,H){const b=H&&this._storeEffectOnSubMeshes,G=i??(b?H.effect:this.getEffect());if(!G)return;const q=this.Ua();this._activeEffect=G,this.bindOnlyWorldMatrix(a,i);const Q=this._options.uniformBuffers;let k=!1;if(G&&Q&&Q.length>0&&q.getEngine().supportsUniformBuffers)for(let e=0;e<Q.length;++e){switch(Q[e]){case"Mesh":O&&(O.getMeshUniformBuffer().bindToEffect(G,"Mesh"),O.transferToEffect(a));break;case"Scene":(0,Z.m)(G,q.getSceneUniformBuffer()),q.finalizeSceneUbo(),k=!0}}const I=O&&b?this._mustRebind(q,G,H,O.visibility):q.getCachedMaterial()!==this;if(G&&I){let a;for(a in k||-1===this._options.uniforms.indexOf("view")||G.setMatrix("view",q.getViewMatrix()),k||-1===this._options.uniforms.indexOf("projection")||G.setMatrix("projection",q.getProjectionMatrix()),k||-1===this._options.uniforms.indexOf("viewProjection")||(G.setMatrix("viewProjection",q.getTransformMatrix()),this._multiview&&G.setMatrix("viewProjectionR",q._transformMatrixR)),q.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&G.setVector3("cameraPosition",q.activeCamera.globalPosition),(0,Z.b)(O,G),(0,j.f)(G,this,q),this._useLogarithmicDepth&&(0,Z.h)(b?H.materialDefines:G.defines,G,q),O&&(0,Z.d)(q,O,G),this._textures)G.setTexture(a,this._textures[a]);for(a in this._textureArrays)G.setTextureArray(a,this._textureArrays[a]);for(a in this._ints)G.setInt(a,this._ints[a]);for(a in this._uints)G.setUInt(a,this._uints[a]);for(a in this._floats)G.setFloat(a,this._floats[a]);for(a in this._floatsArrays)G.setArray(a,this._floatsArrays[a]);for(a in this._colors3)G.setColor3(a,this._colors3[a]);for(a in this._colors3Arrays)G.setArray3(a,this._colors3Arrays[a]);for(a in this._colors4){const O=this._colors4[a];G.setFloat4(a,O.r,O.g,O.b,O.a)}for(a in this._colors4Arrays)G.setArray4(a,this._colors4Arrays[a]);for(a in this._vectors2)G.setVector2(a,this._vectors2[a]);for(a in this._vectors3)G.setVector3(a,this._vectors3[a]);for(a in this._vectors4)G.setVector4(a,this._vectors4[a]);for(a in this._quaternions)G.setQuaternion(a,this._quaternions[a]);for(a in this._matrices)G.setMatrix(a,this._matrices[a]);for(a in this._matrixArrays)G.setMatrices(a,this._matrixArrays[a]);for(a in this._matrices3x3)G.setMatrix3x3(a,this._matrices3x3[a]);for(a in this._matrices2x2)G.setMatrix2x2(a,this._matrices2x2[a]);for(a in this._vectors2Arrays)G.setArray2(a,this._vectors2Arrays[a]);for(a in this._vectors3Arrays)G.setArray3(a,this._vectors3Arrays[a]);for(a in this._vectors4Arrays)G.setArray4(a,this._vectors4Arrays[a]);for(a in this._quaternionsArrays)G.setArray4(a,this._quaternionsArrays[a]);for(a in this._uniformBuffers){const O=this._uniformBuffers[a].getBuffer();O&&G.bindUniformBuffer(O,a)}const i=q.getEngine(),Q=i.setExternalTexture;if(Q)for(a in this._externalTextures)Q.call(i,a,this._externalTextures[a]);const I=i.setTextureSampler;if(I)for(a in this._textureSamplers)I.call(i,a,this._textureSamplers[a]);const P=i.setStorageBuffer;if(P)for(a in this._storageBuffers)P.call(i,a,this._storageBuffers[a])}if(G&&O&&(I||!this.isFrozen)){(0,Z.j)(O,G),O.morphTargetManager&&O.morphTargetManager.isUsingTextureForTargets&&O.morphTargetManager._bind(G);const a=O.bakedVertexAnimationManager;if(a&&a.isEnabled){var P;const a=b?H._drawWrapper:this._drawWrapper;null===(P=O.bakedVertexAnimationManager)||void 0===P||P.bind(G,!!a._wasPreviouslyUsingInstances)}}this._afterBind(O,G,H)}getActiveTextures(){const a=super.getActiveTextures();for(const O in this._textures)a.push(this._textures[O]);for(const O in this._textureArrays){const i=this._textureArrays[O];for(let O=0;O<i.length;O++)a.push(i[O])}return a}hasTexture(a){if(super.hasTexture(a))return!0;for(const O in this._textures)if(this._textures[O]===a)return!0;for(const O in this._textureArrays){const i=this._textureArrays[O];for(let O=0;O<i.length;O++)if(i[O]===a)return!0}return!1}clone(a){const O=H.d.Clone((()=>new r(a,this.Ua(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);O.name=a,O.id=a,"object"===typeof O._shaderPath&&(O._shaderPath={...O._shaderPath}),this._options={...this._options};const i=Object.keys(this._options);for(const H of i){const a=this._options[H];Array.isArray(a)&&(this._options[H]=a.slice(0))}this.hb.copyTo(O.hb);for(const H in this._textures)O.setTexture(H,this._textures[H]);for(const H in this._textureArrays)O.setTextureArray(H,this._textureArrays[H]);for(const H in this._externalTextures)O.setExternalTexture(H,this._externalTextures[H]);for(const H in this._ints)O.setInt(H,this._ints[H]);for(const H in this._uints)O.setUInt(H,this._uints[H]);for(const H in this._floats)O.setFloat(H,this._floats[H]);for(const H in this._floatsArrays)O.setFloats(H,this._floatsArrays[H]);for(const H in this._colors3)O.setColor3(H,this._colors3[H]);for(const H in this._colors3Arrays)O._colors3Arrays[H]=this._colors3Arrays[H];for(const H in this._colors4)O.setColor4(H,this._colors4[H]);for(const H in this._colors4Arrays)O._colors4Arrays[H]=this._colors4Arrays[H];for(const H in this._vectors2)O.setVector2(H,this._vectors2[H]);for(const H in this._vectors3)O.setVector3(H,this._vectors3[H]);for(const H in this._vectors4)O.setVector4(H,this._vectors4[H]);for(const H in this._quaternions)O.setQuaternion(H,this._quaternions[H]);for(const H in this._quaternionsArrays)O._quaternionsArrays[H]=this._quaternionsArrays[H];for(const H in this._matrices)O.setMatrix(H,this._matrices[H]);for(const H in this._matrixArrays)O._matrixArrays[H]=this._matrixArrays[H].slice();for(const H in this._matrices3x3)O.setMatrix3x3(H,this._matrices3x3[H]);for(const H in this._matrices2x2)O.setMatrix2x2(H,this._matrices2x2[H]);for(const H in this._vectors2Arrays)O.setArray2(H,this._vectors2Arrays[H]);for(const H in this._vectors3Arrays)O.setArray3(H,this._vectors3Arrays[H]);for(const H in this._vectors4Arrays)O.setArray4(H,this._vectors4Arrays[H]);for(const H in this._uniformBuffers)O.setUniformBuffer(H,this._uniformBuffers[H]);for(const H in this._textureSamplers)O.setTextureSampler(H,this._textureSamplers[H]);for(const H in this._storageBuffers)O.setStorageBuffer(H,this._storageBuffers[H]);return O}dispose(a,O,i){if(O){let a;for(a in this._textures)this._textures[a].dispose();for(a in this._textureArrays){const O=this._textureArrays[a];for(let a=0;a<O.length;a++)O[a].dispose()}}this._textures={},super.dispose(a,O,i)}serialize(){const a=H.d.Serialize(this);let O;for(O in a.customType="BABYLON.ShaderMaterial",a.uniqueId=this.uniqueId,a.options=this._options,a.shaderPath=this._shaderPath,a.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,a.hb=this.hb.serialize(),a.textures={},this._textures)a.textures[O]=this._textures[O].serialize();for(O in a.textureArrays={},this._textureArrays){a.textureArrays[O]=[];const i=this._textureArrays[O];for(let H=0;H<i.length;H++)a.textureArrays[O].push(i[H].serialize())}for(O in a.ints={},this._ints)a.ints[O]=this._ints[O];for(O in a.uints={},this._uints)a.uints[O]=this._uints[O];for(O in a.floats={},this._floats)a.floats[O]=this._floats[O];for(O in a.floatsArrays={},this._floatsArrays)a.floatsArrays[O]=this._floatsArrays[O];for(O in a.colors3={},this._colors3){const i=this._colors3[O];a.colors3[O]=[i.r,i.g,i.b]}for(O in a.colors3Arrays={},this._colors3Arrays)a.colors3Arrays[O]=this._colors3Arrays[O];for(O in a.colors4={},this._colors4){const i=this._colors4[O];a.colors4[O]=[i.r,i.g,i.b,i.a]}for(O in a.colors4Arrays={},this._colors4Arrays)a.colors4Arrays[O]=this._colors4Arrays[O];for(O in a.vectors2={},this._vectors2){const i=this._vectors2[O];a.vectors2[O]=[i.x,i.y]}for(O in a.vectors3={},this._vectors3){const i=this._vectors3[O];a.vectors3[O]=[i.x,i.y,i.z]}for(O in a.vectors4={},this._vectors4){const i=this._vectors4[O];a.vectors4[O]=[i.x,i.y,i.z,i.w]}for(O in a.quaternions={},this._quaternions)a.quaternions[O]=this._quaternions[O].Cb();for(O in a.matrices={},this._matrices)a.matrices[O]=this._matrices[O].Cb();for(O in a.matrixArray={},this._matrixArrays)a.matrixArray[O]=this._matrixArrays[O];for(O in a.matrices3x3={},this._matrices3x3)a.matrices3x3[O]=this._matrices3x3[O];for(O in a.matrices2x2={},this._matrices2x2)a.matrices2x2[O]=this._matrices2x2[O];for(O in a.vectors2Arrays={},this._vectors2Arrays)a.vectors2Arrays[O]=this._vectors2Arrays[O];for(O in a.vectors3Arrays={},this._vectors3Arrays)a.vectors3Arrays[O]=this._vectors3Arrays[O];for(O in a.vectors4Arrays={},this._vectors4Arrays)a.vectors4Arrays[O]=this._vectors4Arrays[O];for(O in a.quaternionsArrays={},this._quaternionsArrays)a.quaternionsArrays[O]=this._quaternionsArrays[O];return a}static Parse(a,O,i){const b=H.d.Parse((()=>new r(a.name,O,a.shaderPath,a.options,a.storeEffectOnSubMeshes)),a,O,i);let q;for(q in a.hb&&b.hb.parse(a.hb,O,i),a.textures)b.setTexture(q,Q.e.Parse(a.textures[q],O,i));for(q in a.textureArrays){const H=a.textureArrays[q],G=[];for(let a=0;a<H.length;a++)G.push(Q.e.Parse(H[a],O,i));b.setTextureArray(q,G)}for(q in a.ints)b.setInt(q,a.ints[q]);for(q in a.uints)b.setUInt(q,a.uints[q]);for(q in a.floats)b.setFloat(q,a.floats[q]);for(q in a.floatsArrays)b.setFloats(q,a.floatsArrays[q]);for(q in a.colors3){const O=a.colors3[q];b.setColor3(q,{r:O[0],g:O[1],b:O[2]})}for(q in a.colors3Arrays){const O=a.colors3Arrays[q].reduce(((a,O,i)=>(i%3===0?a.push([O]):a[a.length-1].push(O),a)),[]).map((a=>({r:a[0],g:a[1],b:a[2]})));b.setColor3Array(q,O)}for(q in a.colors4){const O=a.colors4[q];b.setColor4(q,{r:O[0],g:O[1],b:O[2],a:O[3]})}for(q in a.colors4Arrays){const O=a.colors4Arrays[q].reduce(((a,O,i)=>(i%4===0?a.push([O]):a[a.length-1].push(O),a)),[]).map((a=>({r:a[0],g:a[1],b:a[2],a:a[3]})));b.setColor4Array(q,O)}for(q in a.vectors2){const O=a.vectors2[q];b.setVector2(q,{x:O[0],y:O[1]})}for(q in a.vectors3){const O=a.vectors3[q];b.setVector3(q,{x:O[0],y:O[1],z:O[2]})}for(q in a.vectors4){const O=a.vectors4[q];b.setVector4(q,{x:O[0],y:O[1],z:O[2],w:O[3]})}for(q in a.quaternions)b.setQuaternion(q,G.Quaternion.MO(a.quaternions[q]));for(q in a.matrices)b.setMatrix(q,G.Matrix.MO(a.matrices[q]));for(q in a.matrixArray)b._matrixArrays[q]=new Float32Array(a.matrixArray[q]);for(q in a.matrices3x3)b.setMatrix3x3(q,a.matrices3x3[q]);for(q in a.matrices2x2)b.setMatrix2x2(q,a.matrices2x2[q]);for(q in a.vectors2Arrays)b.setArray2(q,a.vectors2Arrays[q]);for(q in a.vectors3Arrays)b.setArray3(q,a.vectors3Arrays[q]);for(q in a.vectors4Arrays)b.setArray4(q,a.vectors4Arrays[q]);for(q in a.quaternionsArrays)b.setArray4(q,a.quaternionsArrays[q]);return b}static async ParseFromFileAsync(a,O,i){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((b,G)=>{const q=new P.e;q.addEventListener("readystatechange",(()=>{if(4==q.readyState)if(200==q.status){const O=JSON.parse(q.responseText),G=this.Parse(O,i||h.b.LastCreatedScene,H);a&&(G.name=a),b(G)}else G("Unable to load the ShaderMaterial")})),q.open("GET",O),q.send()}))}static async ParseFromSnippetAsync(a,O){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((H,b)=>{const G=new P.e;G.addEventListener("readystatechange",(()=>{if(4==G.readyState)if(200==G.status){const b=JSON.parse(JSON.parse(G.responseText).jsonPayload),q=JSON.parse(b.shaderMaterial),Q=this.Parse(q,O||h.b.LastCreatedScene,i);Q.snippetId=a,H(Q)}else b("Unable to load the snippet "+a)})),G.open("GET",this.SnippetUrl+"/"+a.replace(/#/g,"/")),G.send()}))}}r.SnippetUrl="https://snippet.babylonjs.com",r.CreateFromSnippetAsync=r.ParseFromSnippetAsync,(0,k.h)("BABYLON.ShaderMaterial",r)}}]);