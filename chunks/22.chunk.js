"use strict";(self["7c63p8lin4r"]=self["7c63p8lin4r"]||[]).push([[22],{13153:(z,u,U)=>{U.r(u),U.d(u,{ShaderMaterial:()=>r});var J=U(21),v=U(12955),f=U(13161),g=U(12914),w=U(13e3),P=U(12894),R=U(12875),S=U(13219),d=U(12790),mz=U(13221),Z=U(12797),A=U(13266),E=U(13261);const C={effect:null,subMesh:null};class r extends mz.c{constructor(z,u,U){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(z,u,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new g.Matrix,this._cachedWorldViewProjectionMatrix=new g.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=U,this._options=(0,J.e)({needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1},v)}get shaderPath(){return this._shaderPath}set shaderPath(z){this._shaderPath=z}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(z){-1===this._options.uniforms.indexOf(z)&&this._options.uniforms.push(z)}setTexture(z,u){return-1===this._options.samplers.indexOf(z)&&this._options.samplers.push(z),this._textures[z]=u,this}removeTexture(z){delete this._textures[z]}setTextureArray(z,u){return-1===this._options.samplers.indexOf(z)&&this._options.samplers.push(z),this._checkUniform(z),this._textureArrays[z]=u,this}setExternalTexture(z,u){return-1===this._options.externalTextures.indexOf(z)&&this._options.externalTextures.push(z),this._externalTextures[z]=u,this}setFloat(z,u){return this._checkUniform(z),this._floats[z]=u,this}setInt(z,u){return this._checkUniform(z),this._ints[z]=u,this}setUInt(z,u){return this._checkUniform(z),this._uints[z]=u,this}setFloats(z,u){return this._checkUniform(z),this._floatsArrays[z]=u,this}setColor3(z,u){return this._checkUniform(z),this._colors3[z]=u,this}setColor3Array(z,u){return this._checkUniform(z),this._colors3Arrays[z]=u.reduce(((z,u)=>(z.push(u.r,u.g,u.b),z)),[]),this}setColor4(z,u){return this._checkUniform(z),this._colors4[z]=u,this}setColor4Array(z,u){return this._checkUniform(z),this._colors4Arrays[z]=u.reduce(((z,u)=>(z.push(u.r,u.g,u.b,u.a),z)),[]),this}setVector2(z,u){return this._checkUniform(z),this._vectors2[z]=u,this}setVector3(z,u){return this._checkUniform(z),this._vectors3[z]=u,this}setVector4(z,u){return this._checkUniform(z),this._vectors4[z]=u,this}setQuaternion(z,u){return this._checkUniform(z),this._quaternions[z]=u,this}setQuaternionArray(z,u){return this._checkUniform(z),this._quaternionsArrays[z]=u.reduce(((z,u)=>(u.toArray(z,z.length),z)),[]),this}setMatrix(z,u){return this._checkUniform(z),this._matrices[z]=u,this}setMatrices(z,u){this._checkUniform(z);const U=new Float32Array(16*u.length);for(let J=0;J<u.length;J++){u[J].copyToArray(U,16*J)}return this._matrixArrays[z]=U,this}setMatrix3x3(z,u){return this._checkUniform(z),this._matrices3x3[z]=u,this}setMatrix2x2(z,u){return this._checkUniform(z),this._matrices2x2[z]=u,this}setArray2(z,u){return this._checkUniform(z),this._vectors2Arrays[z]=u,this}setArray3(z,u){return this._checkUniform(z),this._vectors3Arrays[z]=u,this}setArray4(z,u){return this._checkUniform(z),this._vectors4Arrays[z]=u,this}setUniformBuffer(z,u){return-1===this._options.uniformBuffers.indexOf(z)&&this._options.uniformBuffers.push(z),this._uniformBuffers[z]=u,this}setTextureSampler(z,u){return-1===this._options.samplerObjects.indexOf(z)&&this._options.samplerObjects.push(z),this._textureSamplers[z]=u,this}setStorageBuffer(z,u){return-1===this._options.storageBuffers.indexOf(z)&&this._options.storageBuffers.push(z),this._storageBuffers[z]=u,this}setDefine(z,u){const U=z.trimEnd()+" ",J=this.options.defines.findIndex((u=>u===z||u.startsWith(U)));return J>=0&&this.options.defines.splice(J,1),("boolean"!==typeof u||u)&&this.options.defines.push(U+u),this}isReadyForSubMesh(z,u,U){return this.isReady(z,U,u)}isReady(z,u,U){var J,v,g;const P=U&&this._storeEffectOnSubMeshes;if(this.isFrozen){const z=P?U._drawWrapper:this._drawWrapper;if(z.effect&&z._wasPreviouslyReady&&z._wasPreviouslyUsingInstances===u)return!0}const R=this.Vz(),d=R.getEngine(),mz=[],Z=[];let r=null,M=this._shaderPath,T=this._options.uniforms,X=this._options.uniformBuffers,h=this._options.samplers;d.getCaps().multiview&&R.activeCamera&&R.activeCamera.outputRenderTarget&&R.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,mz.push("#define MULTIVIEW"),-1!==T.indexOf("viewProjection")&&-1===T.indexOf("viewProjectionR")&&T.push("viewProjectionR"));for(let f=0;f<this._options.defines.length;f++){const z=0===this._options.defines[f].indexOf("#define")?this._options.defines[f]:"#define ".concat(this._options.defines[f]);mz.push(z)}for(let f=0;f<this._options.attributes.length;f++)Z.push(this._options.attributes[f]);if(z&&z.isVerticesDataPresent(w.g.ColorKind)&&(-1===Z.indexOf(w.g.ColorKind)&&Z.push(w.g.ColorKind),mz.push("#define VERTEXCOLOR")),u&&(mz.push("#define INSTANCES"),(0,E.Q)(Z,this._materialHelperNeedsPreviousMatrices),null!==z&&void 0!==z&&z.hasThinInstances&&(mz.push("#define THIN_INSTANCES"),z&&z.isVerticesDataPresent(w.g.ColorInstanceKind)&&(Z.push(w.g.ColorInstanceKind),mz.push("#define INSTANCESCOLOR")))),z&&z.useBones&&z.computeBonesUsingShaders&&z.skeleton){Z.push(w.g.MatricesIndicesKind),Z.push(w.g.MatricesWeightsKind),z.numBoneInfluencers>4&&(Z.push(w.g.MatricesIndicesExtraKind),Z.push(w.g.MatricesWeightsExtraKind));const u=z.skeleton;mz.push("#define NUM_BONE_INFLUENCERS "+z.numBoneInfluencers),r=new S.d,r.addCPUSkinningFallback(0,z),u.isUsingTextureForMatrices?(mz.push("#define BONETEXTURE"),-1===T.indexOf("boneTextureWidth")&&T.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(mz.push("#define BonesPerMesh "+(u.bones.length+1)),-1===T.indexOf("mBones")&&T.push("mBones"))}else mz.push("#define NUM_BONE_INFLUENCERS 0");let t=0;const V=z?z.morphTargetManager:null;if(V){const u=-1!==mz.indexOf("#define UV1"),U=-1!==mz.indexOf("#define UV2"),J=-1!==mz.indexOf("#define TANGENT"),v=-1!==mz.indexOf("#define NORMAL"),f=-1!==mz.indexOf("#define VERTEXCOLOR");t=(0,E.y)(V,mz,Z,z,!0,v,J,u,U,f),V.isUsingTextureForTargets&&(-1===T.indexOf("morphTargetTextureIndices")&&T.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),t>0&&(T=T.slice(),T.push("morphTargetInfluences"),T.push("morphTargetCount"),T.push("morphTargetTextureInfo"),T.push("morphTargetTextureIndices"))}else mz.push("#define NUM_MORPH_INFLUENCERS 0");if(z){const u=z.bakedVertexAnimationManager;u&&u.isEnabled&&(mz.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===T.indexOf("bakedVertexAnimationSettings")&&T.push("bakedVertexAnimationSettings"),-1===T.indexOf("bakedVertexAnimationTextureSizeInverted")&&T.push("bakedVertexAnimationTextureSizeInverted"),-1===T.indexOf("bakedVertexAnimationTime")&&T.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,E.q)(Z,z,mz)}for(const f in this._textures)if(!this._textures[f].isReady())return!1;z&&this.needAlphaTestingForMesh(z)&&mz.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,A.b)(T),(0,A.k)(this,R,mz)),R.fogEnabled&&null!==z&&void 0!==z&&z.applyFog&&R.fogMode!==f.d.FOGMODE_NONE&&(mz.push("#define FOG"),-1===T.indexOf("view")&&T.push("view"),-1===T.indexOf("vFogInfos")&&T.push("vFogInfos"),-1===T.indexOf("vFogColor")&&T.push("vFogColor")),this._useLogarithmicDepth&&(mz.push("#define LOGARITHMICDEPTH"),-1===T.indexOf("logarithmicDepthConstant")&&T.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(T=T.slice(),X=X.slice(),h=h.slice(),M=this.customShaderNameResolve(this.name,T,X,h,mz,Z));const L=P?U._getDrawWrapper(void 0,!0):this._drawWrapper,O=null!==(J=null===L||void 0===L?void 0:L.effect)&&void 0!==J?J:null,x=null!==(v=null===L||void 0===L?void 0:L.defines)&&void 0!==v?v:null,Q=mz.join("\n");let K=O;var Y;x!==Q&&(K=d.createEffect(M,{attributes:Z,uniformsNames:T,uniformBuffersNames:X,samplers:h,defines:Q,fallbacks:r,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:t},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},d),P?U.setEffect(K,Q,this._materialContext):L&&L.setEffect(K,Q),this._onEffectCreatedObservable&&(C.effect=K,C.subMesh=null!==(Y=null!==U&&void 0!==U?U:null===z||void 0===z?void 0:z.cf[0])&&void 0!==Y?Y:null,this._onEffectCreatedObservable.notifyObservers(C)));return L._wasPreviouslyUsingInstances=!!u,!(null===(g=K)||void 0===g||!g.isReady())&&(O!==K&&R.resetCachedMaterial(),L._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(z,u){const U=null!==u&&void 0!==u?u:this.getEffect();if(!U)return;const J=this._options.uniforms;-1!==J.indexOf("world")&&U.setMatrix("world",z);const v=this.Vz();-1!==J.indexOf("worldView")&&(z.multiplyToRef(v.getViewMatrix(),this._cachedWorldViewMatrix),U.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==J.indexOf("worldViewProjection")&&(z.multiplyToRef(v.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),U.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==J.indexOf("view")&&U.setMatrix("view",v.getViewMatrix())}bindForSubMesh(z,u,U){var J;this.bind(z,u,null===(J=U._drawWrapperOverride)||void 0===J?void 0:J.effect,U)}bind(z,u,U,J){const v=J&&this._storeEffectOnSubMeshes,f=null!==U&&void 0!==U?U:v?J.effect:this.getEffect();if(!f)return;const g=this.Vz();this._activeEffect=f,this.bindOnlyWorldMatrix(z,U);const w=this._options.uniformBuffers;let P=!1;if(f&&w&&w.length>0&&g.getEngine().supportsUniformBuffers)for(let d=0;d<w.length;++d){switch(w[d]){case"Mesh":u&&(u.getMeshUniformBuffer().bindToEffect(f,"Mesh"),u.transferToEffect(z));break;case"Scene":(0,E.m)(f,g.getSceneUniformBuffer()),g.finalizeSceneUbo(),P=!0}}const R=u&&v?this._mustRebind(g,f,J,u.visibility):g.getCachedMaterial()!==this;if(f&&R){let z;for(z in P||-1===this._options.uniforms.indexOf("view")||f.setMatrix("view",g.getViewMatrix()),P||-1===this._options.uniforms.indexOf("projection")||f.setMatrix("projection",g.getProjectionMatrix()),P||-1===this._options.uniforms.indexOf("viewProjection")||(f.setMatrix("viewProjection",g.getTransformMatrix()),this._multiview&&f.setMatrix("viewProjectionR",g._transformMatrixR)),g.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&f.setVector3("cameraPosition",g.activeCamera.globalPosition),(0,E.d)(u,f),(0,A.f)(f,this,g),this._useLogarithmicDepth&&(0,E.h)(v?J.materialDefines:f.defines,f,g),u&&(0,E.f)(g,u,f),this._textures)f.setTexture(z,this._textures[z]);for(z in this._textureArrays)f.setTextureArray(z,this._textureArrays[z]);for(z in this._ints)f.setInt(z,this._ints[z]);for(z in this._uints)f.setUInt(z,this._uints[z]);for(z in this._floats)f.setFloat(z,this._floats[z]);for(z in this._floatsArrays)f.setArray(z,this._floatsArrays[z]);for(z in this._colors3)f.setColor3(z,this._colors3[z]);for(z in this._colors3Arrays)f.setArray3(z,this._colors3Arrays[z]);for(z in this._colors4){const u=this._colors4[z];f.setFloat4(z,u.r,u.g,u.b,u.a)}for(z in this._colors4Arrays)f.setArray4(z,this._colors4Arrays[z]);for(z in this._vectors2)f.setVector2(z,this._vectors2[z]);for(z in this._vectors3)f.setVector3(z,this._vectors3[z]);for(z in this._vectors4)f.setVector4(z,this._vectors4[z]);for(z in this._quaternions)f.setQuaternion(z,this._quaternions[z]);for(z in this._matrices)f.setMatrix(z,this._matrices[z]);for(z in this._matrixArrays)f.setMatrices(z,this._matrixArrays[z]);for(z in this._matrices3x3)f.setMatrix3x3(z,this._matrices3x3[z]);for(z in this._matrices2x2)f.setMatrix2x2(z,this._matrices2x2[z]);for(z in this._vectors2Arrays)f.setArray2(z,this._vectors2Arrays[z]);for(z in this._vectors3Arrays)f.setArray3(z,this._vectors3Arrays[z]);for(z in this._vectors4Arrays)f.setArray4(z,this._vectors4Arrays[z]);for(z in this._quaternionsArrays)f.setArray4(z,this._quaternionsArrays[z]);for(z in this._uniformBuffers){const u=this._uniformBuffers[z].getBuffer();u&&f.bindUniformBuffer(u,z)}const U=g.getEngine(),w=U.setExternalTexture;if(w)for(z in this._externalTextures)w.call(U,z,this._externalTextures[z]);const R=U.setTextureSampler;if(R)for(z in this._textureSamplers)R.call(U,z,this._textureSamplers[z]);const S=U.setStorageBuffer;if(S)for(z in this._storageBuffers)S.call(U,z,this._storageBuffers[z])}if(f&&u&&(R||!this.isFrozen)){(0,E.l)(u,f),u.morphTargetManager&&u.morphTargetManager.isUsingTextureForTargets&&u.morphTargetManager._bind(f);const z=u.bakedVertexAnimationManager;if(z&&z.isEnabled){var S;const z=v?J._drawWrapper:this._drawWrapper;null===(S=u.bakedVertexAnimationManager)||void 0===S||S.bind(f,!!z._wasPreviouslyUsingInstances)}}this._afterBind(u,f,J)}getActiveTextures(){const z=super.getActiveTextures();for(const u in this._textures)z.push(this._textures[u]);for(const u in this._textureArrays){const U=this._textureArrays[u];for(let u=0;u<U.length;u++)z.push(U[u])}return z}hasTexture(z){if(super.hasTexture(z))return!0;for(const u in this._textures)if(this._textures[u]===z)return!0;for(const u in this._textureArrays){const U=this._textureArrays[u];for(let u=0;u<U.length;u++)if(U[u]===z)return!0}return!1}clone(z){const u=v.b.Clone((()=>new r(z,this.Vz(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);u.name=z,u.id=z,"object"===typeof u._shaderPath&&(u._shaderPath=(0,J.e)({},u._shaderPath)),this._options=(0,J.e)({},this._options);const U=Object.keys(this._options);for(const J of U){const z=this._options[J];Array.isArray(z)&&(this._options[J]=z.slice(0))}this.tf.copyTo(u.tf);for(const J in this._textures)u.setTexture(J,this._textures[J]);for(const J in this._textureArrays)u.setTextureArray(J,this._textureArrays[J]);for(const J in this._externalTextures)u.setExternalTexture(J,this._externalTextures[J]);for(const J in this._ints)u.setInt(J,this._ints[J]);for(const J in this._uints)u.setUInt(J,this._uints[J]);for(const J in this._floats)u.setFloat(J,this._floats[J]);for(const J in this._floatsArrays)u.setFloats(J,this._floatsArrays[J]);for(const J in this._colors3)u.setColor3(J,this._colors3[J]);for(const J in this._colors3Arrays)u._colors3Arrays[J]=this._colors3Arrays[J];for(const J in this._colors4)u.setColor4(J,this._colors4[J]);for(const J in this._colors4Arrays)u._colors4Arrays[J]=this._colors4Arrays[J];for(const J in this._vectors2)u.setVector2(J,this._vectors2[J]);for(const J in this._vectors3)u.setVector3(J,this._vectors3[J]);for(const J in this._vectors4)u.setVector4(J,this._vectors4[J]);for(const J in this._quaternions)u.setQuaternion(J,this._quaternions[J]);for(const J in this._quaternionsArrays)u._quaternionsArrays[J]=this._quaternionsArrays[J];for(const J in this._matrices)u.setMatrix(J,this._matrices[J]);for(const J in this._matrixArrays)u._matrixArrays[J]=this._matrixArrays[J].slice();for(const J in this._matrices3x3)u.setMatrix3x3(J,this._matrices3x3[J]);for(const J in this._matrices2x2)u.setMatrix2x2(J,this._matrices2x2[J]);for(const J in this._vectors2Arrays)u.setArray2(J,this._vectors2Arrays[J]);for(const J in this._vectors3Arrays)u.setArray3(J,this._vectors3Arrays[J]);for(const J in this._vectors4Arrays)u.setArray4(J,this._vectors4Arrays[J]);for(const J in this._uniformBuffers)u.setUniformBuffer(J,this._uniformBuffers[J]);for(const J in this._textureSamplers)u.setTextureSampler(J,this._textureSamplers[J]);for(const J in this._storageBuffers)u.setStorageBuffer(J,this._storageBuffers[J]);return u}dispose(z,u,U){if(u){let z;for(z in this._textures)this._textures[z].dispose();for(z in this._textureArrays){const u=this._textureArrays[z];for(let z=0;z<u.length;z++)u[z].dispose()}}this._textures={},super.dispose(z,u,U)}serialize(){const z=v.b.Serialize(this);let u;for(u in z.customType="BABYLON.ShaderMaterial",z.uniqueId=this.uniqueId,z.options=this._options,z.shaderPath=this._shaderPath,z.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,z.tf=this.tf.serialize(),z.textures={},this._textures)z.textures[u]=this._textures[u].serialize();for(u in z.textureArrays={},this._textureArrays){z.textureArrays[u]=[];const U=this._textureArrays[u];for(let J=0;J<U.length;J++)z.textureArrays[u].push(U[J].serialize())}for(u in z.ints={},this._ints)z.ints[u]=this._ints[u];for(u in z.uints={},this._uints)z.uints[u]=this._uints[u];for(u in z.floats={},this._floats)z.floats[u]=this._floats[u];for(u in z.floatsArrays={},this._floatsArrays)z.floatsArrays[u]=this._floatsArrays[u];for(u in z.colors3={},this._colors3){const U=this._colors3[u];z.colors3[u]=[U.r,U.g,U.b]}for(u in z.colors3Arrays={},this._colors3Arrays)z.colors3Arrays[u]=this._colors3Arrays[u];for(u in z.colors4={},this._colors4){const U=this._colors4[u];z.colors4[u]=[U.r,U.g,U.b,U.a]}for(u in z.colors4Arrays={},this._colors4Arrays)z.colors4Arrays[u]=this._colors4Arrays[u];for(u in z.vectors2={},this._vectors2){const U=this._vectors2[u];z.vectors2[u]=[U.x,U.y]}for(u in z.vectors3={},this._vectors3){const U=this._vectors3[u];z.vectors3[u]=[U.x,U.y,U.z]}for(u in z.vectors4={},this._vectors4){const U=this._vectors4[u];z.vectors4[u]=[U.x,U.y,U.z,U.w]}for(u in z.quaternions={},this._quaternions)z.quaternions[u]=this._quaternions[u].jf();for(u in z.matrices={},this._matrices)z.matrices[u]=this._matrices[u].jf();for(u in z.matrixArray={},this._matrixArrays)z.matrixArray[u]=this._matrixArrays[u];for(u in z.matrices3x3={},this._matrices3x3)z.matrices3x3[u]=this._matrices3x3[u];for(u in z.matrices2x2={},this._matrices2x2)z.matrices2x2[u]=this._matrices2x2[u];for(u in z.vectors2Arrays={},this._vectors2Arrays)z.vectors2Arrays[u]=this._vectors2Arrays[u];for(u in z.vectors3Arrays={},this._vectors3Arrays)z.vectors3Arrays[u]=this._vectors3Arrays[u];for(u in z.vectors4Arrays={},this._vectors4Arrays)z.vectors4Arrays[u]=this._vectors4Arrays[u];for(u in z.quaternionsArrays={},this._quaternionsArrays)z.quaternionsArrays[u]=this._quaternionsArrays[u];return z}static Parse(z,u,U){const J=v.b.Parse((()=>new r(z.name,u,z.shaderPath,z.options,z.storeEffectOnSubMeshes)),z,u,U);let f;for(f in z.tf&&J.tf.parse(z.tf,u,U),z.textures)J.setTexture(f,P.e.Parse(z.textures[f],u,U));for(f in z.textureArrays){const v=z.textureArrays[f],g=[];for(let z=0;z<v.length;z++)g.push(P.e.Parse(v[z],u,U));J.setTextureArray(f,g)}for(f in z.ints)J.setInt(f,z.ints[f]);for(f in z.uints)J.setUInt(f,z.uints[f]);for(f in z.floats)J.setFloat(f,z.floats[f]);for(f in z.floatsArrays)J.setFloats(f,z.floatsArrays[f]);for(f in z.colors3){const u=z.colors3[f];J.setColor3(f,{r:u[0],g:u[1],b:u[2]})}for(f in z.colors3Arrays){const u=z.colors3Arrays[f].reduce(((z,u,U)=>(U%3===0?z.push([u]):z[z.length-1].push(u),z)),[]).map((z=>({r:z[0],g:z[1],b:z[2]})));J.setColor3Array(f,u)}for(f in z.colors4){const u=z.colors4[f];J.setColor4(f,{r:u[0],g:u[1],b:u[2],a:u[3]})}for(f in z.colors4Arrays){const u=z.colors4Arrays[f].reduce(((z,u,U)=>(U%4===0?z.push([u]):z[z.length-1].push(u),z)),[]).map((z=>({r:z[0],g:z[1],b:z[2],a:z[3]})));J.setColor4Array(f,u)}for(f in z.vectors2){const u=z.vectors2[f];J.setVector2(f,{x:u[0],y:u[1]})}for(f in z.vectors3){const u=z.vectors3[f];J.setVector3(f,{x:u[0],y:u[1],z:u[2]})}for(f in z.vectors4){const u=z.vectors4[f];J.setVector4(f,{x:u[0],y:u[1],z:u[2],w:u[3]})}for(f in z.quaternions)J.setQuaternion(f,g.Quaternion.Xu(z.quaternions[f]));for(f in z.matrices)J.setMatrix(f,g.Matrix.Xu(z.matrices[f]));for(f in z.matrixArray)J._matrixArrays[f]=new Float32Array(z.matrixArray[f]);for(f in z.matrices3x3)J.setMatrix3x3(f,z.matrices3x3[f]);for(f in z.matrices2x2)J.setMatrix2x2(f,z.matrices2x2[f]);for(f in z.vectors2Arrays)J.setArray2(f,z.vectors2Arrays[f]);for(f in z.vectors3Arrays)J.setArray3(f,z.vectors3Arrays[f]);for(f in z.vectors4Arrays)J.setArray4(f,z.vectors4Arrays[f]);for(f in z.quaternionsArrays)J.setArray4(f,z.quaternionsArrays[f]);return J}static async ParseFromFileAsync(z,u,U){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((v,f)=>{const g=new d.b;g.addEventListener("readystatechange",(()=>{if(4==g.readyState)if(200==g.status){const u=JSON.parse(g.responseText),f=this.Parse(u,U||Z.e.LastCreatedScene,J);z&&(f.name=z),v(f)}else f("Unable to load the ShaderMaterial")})),g.open("GET",u),g.send()}))}static async ParseFromSnippetAsync(z,u){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((J,v)=>{const f=new d.b;f.addEventListener("readystatechange",(()=>{if(4==f.readyState)if(200==f.status){const v=JSON.parse(JSON.parse(f.responseText).jsonPayload),g=JSON.parse(v.shaderMaterial),w=this.Parse(g,u||Z.e.LastCreatedScene,U);w.snippetId=z,J(w)}else v("Unable to load the snippet "+z)})),f.open("GET",this.SnippetUrl+"/"+z.replace(/#/g,"/")),f.send()}))}}r.SnippetUrl="https://snippet.babylonjs.com",r.CreateFromSnippetAsync=r.ParseFromSnippetAsync,(0,R.f)("BABYLON.ShaderMaterial",r)}}]);