"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[22],{12924:(K,A,T)=>{T.r(A),T.d(A,{ShaderMaterial:()=>F});var G=T(12733),B=T(12931),L=T(12700),f=T(12768),O=T(12674),C=T(12651),Q=T(13009),Y=T(12563),Z=T(13011),x=T(12565),J=T(13063),b=T(13056);const P={effect:null,subMesh:null};class F extends Z.e{constructor(K,A,T){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(K,A,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new L.Matrix,this._cachedWorldViewProjectionMatrix=new L.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=T,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...G}}get shaderPath(){return this._shaderPath}set shaderPath(K){this._shaderPath=K}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(K){-1===this._options.uniforms.indexOf(K)&&this._options.uniforms.push(K)}setTexture(K,A){return-1===this._options.samplers.indexOf(K)&&this._options.samplers.push(K),this._textures[K]=A,this}removeTexture(K){delete this._textures[K]}setTextureArray(K,A){return-1===this._options.samplers.indexOf(K)&&this._options.samplers.push(K),this._checkUniform(K),this._textureArrays[K]=A,this}setExternalTexture(K,A){return-1===this._options.externalTextures.indexOf(K)&&this._options.externalTextures.push(K),this._externalTextures[K]=A,this}setFloat(K,A){return this._checkUniform(K),this._floats[K]=A,this}setInt(K,A){return this._checkUniform(K),this._ints[K]=A,this}setUInt(K,A){return this._checkUniform(K),this._uints[K]=A,this}setFloats(K,A){return this._checkUniform(K),this._floatsArrays[K]=A,this}setColor3(K,A){return this._checkUniform(K),this._colors3[K]=A,this}setColor3Array(K,A){return this._checkUniform(K),this._colors3Arrays[K]=A.reduce(((K,A)=>(K.push(A.r,A.g,A.b),K)),[]),this}setColor4(K,A){return this._checkUniform(K),this._colors4[K]=A,this}setColor4Array(K,A){return this._checkUniform(K),this._colors4Arrays[K]=A.reduce(((K,A)=>(K.push(A.r,A.g,A.b,A.a),K)),[]),this}setVector2(K,A){return this._checkUniform(K),this._vectors2[K]=A,this}setVector3(K,A){return this._checkUniform(K),this._vectors3[K]=A,this}setVector4(K,A){return this._checkUniform(K),this._vectors4[K]=A,this}setQuaternion(K,A){return this._checkUniform(K),this._quaternions[K]=A,this}setQuaternionArray(K,A){return this._checkUniform(K),this._quaternionsArrays[K]=A.reduce(((K,A)=>(A.toArray(K,K.length),K)),[]),this}setMatrix(K,A){return this._checkUniform(K),this._matrices[K]=A,this}setMatrices(K,A){this._checkUniform(K);const T=new Float32Array(16*A.length);for(let G=0;G<A.length;G++){A[G].copyToArray(T,16*G)}return this._matrixArrays[K]=T,this}setMatrix3x3(K,A){return this._checkUniform(K),this._matrices3x3[K]=A,this}setMatrix2x2(K,A){return this._checkUniform(K),this._matrices2x2[K]=A,this}setArray2(K,A){return this._checkUniform(K),this._vectors2Arrays[K]=A,this}setArray3(K,A){return this._checkUniform(K),this._vectors3Arrays[K]=A,this}setArray4(K,A){return this._checkUniform(K),this._vectors4Arrays[K]=A,this}setUniformBuffer(K,A){return-1===this._options.uniformBuffers.indexOf(K)&&this._options.uniformBuffers.push(K),this._uniformBuffers[K]=A,this}setTextureSampler(K,A){return-1===this._options.samplerObjects.indexOf(K)&&this._options.samplerObjects.push(K),this._textureSamplers[K]=A,this}setStorageBuffer(K,A){return-1===this._options.storageBuffers.indexOf(K)&&this._options.storageBuffers.push(K),this._storageBuffers[K]=A,this}setDefine(K,A){const T=K.trimEnd()+" ",G=this.options.defines.findIndex((A=>A===K||A.startsWith(T)));return G>=0&&this.options.defines.splice(G,1),("boolean"!==typeof A||A)&&this.options.defines.push(T+A),this}isReadyForSubMesh(K,A,T){return this.isReady(K,T,A)}isReady(K,A,T){var G;const L=T&&this._storeEffectOnSubMeshes;if(this.isFrozen){const K=L?T._drawWrapper:this._drawWrapper;if(K.effect&&K._wasPreviouslyReady&&K._wasPreviouslyUsingInstances===A)return!0}const O=this.SK(),C=O.getEngine(),Y=[],Z=[];let x=null,F=this._shaderPath,d=this._options.uniforms,N=this._options.uniformBuffers,D=this._options.samplers;C.getCaps().multiview&&O.activeCamera&&O.activeCamera.outputRenderTarget&&O.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,Y.push("#define MULTIVIEW"),-1!==d.indexOf("viewProjection")&&-1===d.indexOf("viewProjectionR")&&d.push("viewProjectionR"));for(let B=0;B<this._options.defines.length;B++){const K=0===this._options.defines[B].indexOf("#define")?this._options.defines[B]:`#define ${this._options.defines[B]}`;Y.push(K)}for(let B=0;B<this._options.attributes.length;B++)Z.push(this._options.attributes[B]);if(K&&K.isVerticesDataPresent(f.d.ColorKind)&&(-1===Z.indexOf(f.d.ColorKind)&&Z.push(f.d.ColorKind),Y.push("#define VERTEXCOLOR")),A&&(Y.push("#define INSTANCES"),(0,b.eb)(Z,this._materialHelperNeedsPreviousMatrices),null!==K&&void 0!==K&&K.hasThinInstances&&(Y.push("#define THIN_INSTANCES"),K&&K.isVerticesDataPresent(f.d.ColorInstanceKind)&&(Z.push(f.d.ColorInstanceKind),Y.push("#define INSTANCESCOLOR")))),K&&K.useBones&&K.computeBonesUsingShaders&&K.skeleton){Z.push(f.d.MatricesIndicesKind),Z.push(f.d.MatricesWeightsKind),K.numBoneInfluencers>4&&(Z.push(f.d.MatricesIndicesExtraKind),Z.push(f.d.MatricesWeightsExtraKind));const A=K.skeleton;Y.push("#define NUM_BONE_INFLUENCERS "+K.numBoneInfluencers),x=new Q.d,x.addCPUSkinningFallback(0,K),A.isUsingTextureForMatrices?(Y.push("#define BONETEXTURE"),-1===d.indexOf("boneTextureWidth")&&d.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(Y.push("#define BonesPerMesh "+(A.bones.length+1)),-1===d.indexOf("mBones")&&d.push("mBones"))}else Y.push("#define NUM_BONE_INFLUENCERS 0");let mK=0;const U=K?K.morphTargetManager:null;if(U){const A=-1!==Y.indexOf("#define UV1"),T=-1!==Y.indexOf("#define UV2"),G=-1!==Y.indexOf("#define TANGENT"),B=-1!==Y.indexOf("#define NORMAL"),L=-1!==Y.indexOf("#define VERTEXCOLOR");mK=(0,b.L)(U,Y,Z,K,!0,B,G,A,T,L),U.isUsingTextureForTargets&&(-1===d.indexOf("morphTargetTextureIndices")&&d.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),mK>0&&(d=d.slice(),d.push("morphTargetInfluences"),d.push("morphTargetCount"),d.push("morphTargetTextureInfo"),d.push("morphTargetTextureIndices"))}else Y.push("#define NUM_MORPH_INFLUENCERS 0");if(K){const A=K.bakedVertexAnimationManager;A&&A.isEnabled&&(Y.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===d.indexOf("bakedVertexAnimationSettings")&&d.push("bakedVertexAnimationSettings"),-1===d.indexOf("bakedVertexAnimationTextureSizeInverted")&&d.push("bakedVertexAnimationTextureSizeInverted"),-1===d.indexOf("bakedVertexAnimationTime")&&d.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,b.x)(Z,K,Y)}for(const B in this._textures)if(!this._textures[B].isReady())return!1;K&&this.needAlphaTestingForMesh(K)&&Y.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,J.e)(d),(0,J.o)(this,O,Y)),O.fogEnabled&&null!==K&&void 0!==K&&K.applyFog&&O.fogMode!==B.c.FOGMODE_NONE&&(Y.push("#define FOG"),-1===d.indexOf("view")&&d.push("view"),-1===d.indexOf("vFogInfos")&&d.push("vFogInfos"),-1===d.indexOf("vFogColor")&&d.push("vFogColor")),this._useLogarithmicDepth&&(Y.push("#define LOGARITHMICDEPTH"),-1===d.indexOf("logarithmicDepthConstant")&&d.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(d=d.slice(),N=N.slice(),D=D.slice(),F=this.customShaderNameResolve(this.name,d,N,D,Y,Z));const z=L?T._getDrawWrapper(void 0,!0):this._drawWrapper,g=(null===z||void 0===z?void 0:z.effect)??null,S=(null===z||void 0===z?void 0:z.defines)??null,l=Y.join("\n");let u=g;return S!==l&&(u=C.createEffect(F,{attributes:Z,uniformsNames:d,uniformBuffersNames:N,samplers:D,defines:l,fallbacks:x,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:mK},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},C),L?T.setEffect(u,l,this._materialContext):z&&z.setEffect(u,l),this._onEffectCreatedObservable&&(P.effect=u,P.subMesh=T??(null===K||void 0===K?void 0:K.hf[0])??null,this._onEffectCreatedObservable.notifyObservers(P))),z._wasPreviouslyUsingInstances=!!A,!(null===(G=u)||void 0===G||!G.isReady())&&(g!==u&&O.resetCachedMaterial(),z._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(K,A){const T=A??this.getEffect();if(!T)return;const G=this._options.uniforms;-1!==G.indexOf("world")&&T.setMatrix("world",K);const B=this.SK();-1!==G.indexOf("worldView")&&(K.multiplyToRef(B.getViewMatrix(),this._cachedWorldViewMatrix),T.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==G.indexOf("worldViewProjection")&&(K.multiplyToRef(B.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),T.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==G.indexOf("view")&&T.setMatrix("view",B.getViewMatrix())}bindForSubMesh(K,A,T){var G;this.bind(K,A,null===(G=T._drawWrapperOverride)||void 0===G?void 0:G.effect,T)}bind(K,A,T,G){const B=G&&this._storeEffectOnSubMeshes,L=T??(B?G.effect:this.getEffect());if(!L)return;const f=this.SK();this._activeEffect=L,this.bindOnlyWorldMatrix(K,T);const O=this._options.uniformBuffers;let C=!1;if(L&&O&&O.length>0&&f.getEngine().supportsUniformBuffers)for(let Z=0;Z<O.length;++Z){switch(O[Z]){case"Mesh":A&&(A.getMeshUniformBuffer().bindToEffect(L,"Mesh"),A.transferToEffect(K));break;case"Scene":(0,b.s)(L,f.getSceneUniformBuffer()),f.finalizeSceneUbo(),C=!0}}const Q=A&&B?this._mustRebind(f,L,G,A.visibility):f.getCachedMaterial()!==this;if(L&&Q){let K;for(K in C||-1===this._options.uniforms.indexOf("view")||L.setMatrix("view",f.getViewMatrix()),C||-1===this._options.uniforms.indexOf("projection")||L.setMatrix("projection",f.getProjectionMatrix()),C||-1===this._options.uniforms.indexOf("viewProjection")||(L.setMatrix("viewProjection",f.getTransformMatrix()),this._multiview&&L.setMatrix("viewProjectionR",f._transformMatrixR)),f.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&L.setVector3("cameraPosition",f.activeCamera.globalPosition),(0,b.e)(A,L),(0,J.g)(L,this,f),this._useLogarithmicDepth&&(0,b.k)(B?G.materialDefines:L.defines,L,f),A&&(0,b.h)(f,A,L),this._textures)L.setTexture(K,this._textures[K]);for(K in this._textureArrays)L.setTextureArray(K,this._textureArrays[K]);for(K in this._ints)L.setInt(K,this._ints[K]);for(K in this._uints)L.setUInt(K,this._uints[K]);for(K in this._floats)L.setFloat(K,this._floats[K]);for(K in this._floatsArrays)L.setArray(K,this._floatsArrays[K]);for(K in this._colors3)L.setColor3(K,this._colors3[K]);for(K in this._colors3Arrays)L.setArray3(K,this._colors3Arrays[K]);for(K in this._colors4){const A=this._colors4[K];L.setFloat4(K,A.r,A.g,A.b,A.a)}for(K in this._colors4Arrays)L.setArray4(K,this._colors4Arrays[K]);for(K in this._vectors2)L.setVector2(K,this._vectors2[K]);for(K in this._vectors3)L.setVector3(K,this._vectors3[K]);for(K in this._vectors4)L.setVector4(K,this._vectors4[K]);for(K in this._quaternions)L.setQuaternion(K,this._quaternions[K]);for(K in this._matrices)L.setMatrix(K,this._matrices[K]);for(K in this._matrixArrays)L.setMatrices(K,this._matrixArrays[K]);for(K in this._matrices3x3)L.setMatrix3x3(K,this._matrices3x3[K]);for(K in this._matrices2x2)L.setMatrix2x2(K,this._matrices2x2[K]);for(K in this._vectors2Arrays)L.setArray2(K,this._vectors2Arrays[K]);for(K in this._vectors3Arrays)L.setArray3(K,this._vectors3Arrays[K]);for(K in this._vectors4Arrays)L.setArray4(K,this._vectors4Arrays[K]);for(K in this._quaternionsArrays)L.setArray4(K,this._quaternionsArrays[K]);for(K in this._uniformBuffers){const A=this._uniformBuffers[K].getBuffer();A&&L.bindUniformBuffer(A,K)}const T=f.getEngine(),O=T.setExternalTexture;if(O)for(K in this._externalTextures)O.call(T,K,this._externalTextures[K]);const Q=T.setTextureSampler;if(Q)for(K in this._textureSamplers)Q.call(T,K,this._textureSamplers[K]);const Y=T.setStorageBuffer;if(Y)for(K in this._storageBuffers)Y.call(T,K,this._storageBuffers[K])}if(L&&A&&(Q||!this.isFrozen)){(0,b.o)(A,L),A.morphTargetManager&&A.morphTargetManager.isUsingTextureForTargets&&A.morphTargetManager._bind(L);const K=A.bakedVertexAnimationManager;if(K&&K.isEnabled){var Y;const K=B?G._drawWrapper:this._drawWrapper;null===(Y=A.bakedVertexAnimationManager)||void 0===Y||Y.bind(L,!!K._wasPreviouslyUsingInstances)}}this._afterBind(A,L,G)}getActiveTextures(){const K=super.getActiveTextures();for(const A in this._textures)K.push(this._textures[A]);for(const A in this._textureArrays){const T=this._textureArrays[A];for(let A=0;A<T.length;A++)K.push(T[A])}return K}hasTexture(K){if(super.hasTexture(K))return!0;for(const A in this._textures)if(this._textures[A]===K)return!0;for(const A in this._textureArrays){const T=this._textureArrays[A];for(let A=0;A<T.length;A++)if(T[A]===K)return!0}return!1}clone(K){const A=G.c.Clone((()=>new F(K,this.SK(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);A.name=K,A.id=K,"object"===typeof A._shaderPath&&(A._shaderPath={...A._shaderPath}),this._options={...this._options};const T=Object.keys(this._options);for(const G of T){const K=this._options[G];Array.isArray(K)&&(this._options[G]=K.slice(0))}this.df.copyTo(A.df);for(const G in this._textures)A.setTexture(G,this._textures[G]);for(const G in this._textureArrays)A.setTextureArray(G,this._textureArrays[G]);for(const G in this._externalTextures)A.setExternalTexture(G,this._externalTextures[G]);for(const G in this._ints)A.setInt(G,this._ints[G]);for(const G in this._uints)A.setUInt(G,this._uints[G]);for(const G in this._floats)A.setFloat(G,this._floats[G]);for(const G in this._floatsArrays)A.setFloats(G,this._floatsArrays[G]);for(const G in this._colors3)A.setColor3(G,this._colors3[G]);for(const G in this._colors3Arrays)A._colors3Arrays[G]=this._colors3Arrays[G];for(const G in this._colors4)A.setColor4(G,this._colors4[G]);for(const G in this._colors4Arrays)A._colors4Arrays[G]=this._colors4Arrays[G];for(const G in this._vectors2)A.setVector2(G,this._vectors2[G]);for(const G in this._vectors3)A.setVector3(G,this._vectors3[G]);for(const G in this._vectors4)A.setVector4(G,this._vectors4[G]);for(const G in this._quaternions)A.setQuaternion(G,this._quaternions[G]);for(const G in this._quaternionsArrays)A._quaternionsArrays[G]=this._quaternionsArrays[G];for(const G in this._matrices)A.setMatrix(G,this._matrices[G]);for(const G in this._matrixArrays)A._matrixArrays[G]=this._matrixArrays[G].slice();for(const G in this._matrices3x3)A.setMatrix3x3(G,this._matrices3x3[G]);for(const G in this._matrices2x2)A.setMatrix2x2(G,this._matrices2x2[G]);for(const G in this._vectors2Arrays)A.setArray2(G,this._vectors2Arrays[G]);for(const G in this._vectors3Arrays)A.setArray3(G,this._vectors3Arrays[G]);for(const G in this._vectors4Arrays)A.setArray4(G,this._vectors4Arrays[G]);for(const G in this._uniformBuffers)A.setUniformBuffer(G,this._uniformBuffers[G]);for(const G in this._textureSamplers)A.setTextureSampler(G,this._textureSamplers[G]);for(const G in this._storageBuffers)A.setStorageBuffer(G,this._storageBuffers[G]);return A}dispose(K,A,T){if(A){let K;for(K in this._textures)this._textures[K].dispose();for(K in this._textureArrays){const A=this._textureArrays[K];for(let K=0;K<A.length;K++)A[K].dispose()}}this._textures={},super.dispose(K,A,T)}serialize(){const K=G.c.Serialize(this);let A;for(A in K.customType="BABYLON.ShaderMaterial",K.uniqueId=this.uniqueId,K.options=this._options,K.shaderPath=this._shaderPath,K.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,K.df=this.df.serialize(),K.textures={},this._textures)K.textures[A]=this._textures[A].serialize();for(A in K.textureArrays={},this._textureArrays){K.textureArrays[A]=[];const T=this._textureArrays[A];for(let G=0;G<T.length;G++)K.textureArrays[A].push(T[G].serialize())}for(A in K.ints={},this._ints)K.ints[A]=this._ints[A];for(A in K.uints={},this._uints)K.uints[A]=this._uints[A];for(A in K.floats={},this._floats)K.floats[A]=this._floats[A];for(A in K.floatsArrays={},this._floatsArrays)K.floatsArrays[A]=this._floatsArrays[A];for(A in K.colors3={},this._colors3){const T=this._colors3[A];K.colors3[A]=[T.r,T.g,T.b]}for(A in K.colors3Arrays={},this._colors3Arrays)K.colors3Arrays[A]=this._colors3Arrays[A];for(A in K.colors4={},this._colors4){const T=this._colors4[A];K.colors4[A]=[T.r,T.g,T.b,T.a]}for(A in K.colors4Arrays={},this._colors4Arrays)K.colors4Arrays[A]=this._colors4Arrays[A];for(A in K.vectors2={},this._vectors2){const T=this._vectors2[A];K.vectors2[A]=[T.x,T.y]}for(A in K.vectors3={},this._vectors3){const T=this._vectors3[A];K.vectors3[A]=[T.x,T.y,T.z]}for(A in K.vectors4={},this._vectors4){const T=this._vectors4[A];K.vectors4[A]=[T.x,T.y,T.z,T.w]}for(A in K.quaternions={},this._quaternions)K.quaternions[A]=this._quaternions[A].kf();for(A in K.matrices={},this._matrices)K.matrices[A]=this._matrices[A].kf();for(A in K.matrixArray={},this._matrixArrays)K.matrixArray[A]=this._matrixArrays[A];for(A in K.matrices3x3={},this._matrices3x3)K.matrices3x3[A]=this._matrices3x3[A];for(A in K.matrices2x2={},this._matrices2x2)K.matrices2x2[A]=this._matrices2x2[A];for(A in K.vectors2Arrays={},this._vectors2Arrays)K.vectors2Arrays[A]=this._vectors2Arrays[A];for(A in K.vectors3Arrays={},this._vectors3Arrays)K.vectors3Arrays[A]=this._vectors3Arrays[A];for(A in K.vectors4Arrays={},this._vectors4Arrays)K.vectors4Arrays[A]=this._vectors4Arrays[A];for(A in K.quaternionsArrays={},this._quaternionsArrays)K.quaternionsArrays[A]=this._quaternionsArrays[A];return K}static Parse(K,A,T){const B=G.c.Parse((()=>new F(K.name,A,K.shaderPath,K.options,K.storeEffectOnSubMeshes)),K,A,T);let f;for(f in K.df&&B.df.parse(K.df,A,T),K.textures)B.setTexture(f,O.c.Parse(K.textures[f],A,T));for(f in K.textureArrays){const G=K.textureArrays[f],L=[];for(let K=0;K<G.length;K++)L.push(O.c.Parse(G[K],A,T));B.setTextureArray(f,L)}for(f in K.ints)B.setInt(f,K.ints[f]);for(f in K.uints)B.setUInt(f,K.uints[f]);for(f in K.floats)B.setFloat(f,K.floats[f]);for(f in K.floatsArrays)B.setFloats(f,K.floatsArrays[f]);for(f in K.colors3){const A=K.colors3[f];B.setColor3(f,{r:A[0],g:A[1],b:A[2]})}for(f in K.colors3Arrays){const A=K.colors3Arrays[f].reduce(((K,A,T)=>(T%3===0?K.push([A]):K[K.length-1].push(A),K)),[]).map((K=>({r:K[0],g:K[1],b:K[2]})));B.setColor3Array(f,A)}for(f in K.colors4){const A=K.colors4[f];B.setColor4(f,{r:A[0],g:A[1],b:A[2],a:A[3]})}for(f in K.colors4Arrays){const A=K.colors4Arrays[f].reduce(((K,A,T)=>(T%4===0?K.push([A]):K[K.length-1].push(A),K)),[]).map((K=>({r:K[0],g:K[1],b:K[2],a:K[3]})));B.setColor4Array(f,A)}for(f in K.vectors2){const A=K.vectors2[f];B.setVector2(f,{x:A[0],y:A[1]})}for(f in K.vectors3){const A=K.vectors3[f];B.setVector3(f,{x:A[0],y:A[1],z:A[2]})}for(f in K.vectors4){const A=K.vectors4[f];B.setVector4(f,{x:A[0],y:A[1],z:A[2],w:A[3]})}for(f in K.quaternions)B.setQuaternion(f,L.Quaternion.mT(K.quaternions[f]));for(f in K.matrices)B.setMatrix(f,L.Matrix.mT(K.matrices[f]));for(f in K.matrixArray)B._matrixArrays[f]=new Float32Array(K.matrixArray[f]);for(f in K.matrices3x3)B.setMatrix3x3(f,K.matrices3x3[f]);for(f in K.matrices2x2)B.setMatrix2x2(f,K.matrices2x2[f]);for(f in K.vectors2Arrays)B.setArray2(f,K.vectors2Arrays[f]);for(f in K.vectors3Arrays)B.setArray3(f,K.vectors3Arrays[f]);for(f in K.vectors4Arrays)B.setArray4(f,K.vectors4Arrays[f]);for(f in K.quaternionsArrays)B.setArray4(f,K.quaternionsArrays[f]);return B}static async ParseFromFileAsync(K,A,T){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((B,L)=>{const f=new Y.b;f.addEventListener("readystatechange",(()=>{if(4==f.readyState)if(200==f.status){const A=JSON.parse(f.responseText),L=this.Parse(A,T||x.b.LastCreatedScene,G);K&&(L.name=K),B(L)}else L("Unable to load the ShaderMaterial")})),f.open("GET",A),f.send()}))}static async ParseFromSnippetAsync(K,A){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((G,B)=>{const L=new Y.b;L.addEventListener("readystatechange",(()=>{if(4==L.readyState)if(200==L.status){const B=JSON.parse(JSON.parse(L.responseText).jsonPayload),f=JSON.parse(B.shaderMaterial),O=this.Parse(f,A||x.b.LastCreatedScene,T);O.snippetId=K,G(O)}else B("Unable to load the snippet "+K)})),L.open("GET",this.SnippetUrl+"/"+K.replace(/#/g,"/")),L.send()}))}}F.SnippetUrl="https://snippet.babylonjs.com",F.CreateFromSnippetAsync=F.ParseFromSnippetAsync,(0,C.c)("BABYLON.ShaderMaterial",F)}}]);