"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[22],{12072:(C,U,K)=>{K.r(U),K.d(U,{ShaderMaterial:()=>Q});var m=K(11863),O=K(12078),X=K(11827),A=K(11905),e=K(11808),t=K(11789),z=K(12148),j=K(11701),p=K(12150),E=K(11703),u=K(12200),b=K(12198);const v={effect:null,subMesh:null};class Q extends p.b{constructor(C,U,K){let m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(C,U,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new X.Matrix,this._cachedWorldViewProjectionMatrix=new X.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=K,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...m}}get shaderPath(){return this._shaderPath}set shaderPath(C){this._shaderPath=C}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(C){-1===this._options.uniforms.indexOf(C)&&this._options.uniforms.push(C)}setTexture(C,U){return-1===this._options.samplers.indexOf(C)&&this._options.samplers.push(C),this._textures[C]=U,this}removeTexture(C){delete this._textures[C]}setTextureArray(C,U){return-1===this._options.samplers.indexOf(C)&&this._options.samplers.push(C),this._checkUniform(C),this._textureArrays[C]=U,this}setExternalTexture(C,U){return-1===this._options.externalTextures.indexOf(C)&&this._options.externalTextures.push(C),this._externalTextures[C]=U,this}setFloat(C,U){return this._checkUniform(C),this._floats[C]=U,this}setInt(C,U){return this._checkUniform(C),this._ints[C]=U,this}setUInt(C,U){return this._checkUniform(C),this._uints[C]=U,this}setFloats(C,U){return this._checkUniform(C),this._floatsArrays[C]=U,this}setColor3(C,U){return this._checkUniform(C),this._colors3[C]=U,this}setColor3Array(C,U){return this._checkUniform(C),this._colors3Arrays[C]=U.reduce(((C,U)=>(C.push(U.r,U.g,U.b),C)),[]),this}setColor4(C,U){return this._checkUniform(C),this._colors4[C]=U,this}setColor4Array(C,U){return this._checkUniform(C),this._colors4Arrays[C]=U.reduce(((C,U)=>(C.push(U.r,U.g,U.b,U.a),C)),[]),this}setVector2(C,U){return this._checkUniform(C),this._vectors2[C]=U,this}setVector3(C,U){return this._checkUniform(C),this._vectors3[C]=U,this}setVector4(C,U){return this._checkUniform(C),this._vectors4[C]=U,this}setQuaternion(C,U){return this._checkUniform(C),this._quaternions[C]=U,this}setQuaternionArray(C,U){return this._checkUniform(C),this._quaternionsArrays[C]=U.reduce(((C,U)=>(U.toArray(C,C.length),C)),[]),this}setMatrix(C,U){return this._checkUniform(C),this._matrices[C]=U,this}setMatrices(C,U){this._checkUniform(C);const K=new Float32Array(16*U.length);for(let m=0;m<U.length;m++){U[m].copyToArray(K,16*m)}return this._matrixArrays[C]=K,this}setMatrix3x3(C,U){return this._checkUniform(C),this._matrices3x3[C]=U,this}setMatrix2x2(C,U){return this._checkUniform(C),this._matrices2x2[C]=U,this}setArray2(C,U){return this._checkUniform(C),this._vectors2Arrays[C]=U,this}setArray3(C,U){return this._checkUniform(C),this._vectors3Arrays[C]=U,this}setArray4(C,U){return this._checkUniform(C),this._vectors4Arrays[C]=U,this}setUniformBuffer(C,U){return-1===this._options.uniformBuffers.indexOf(C)&&this._options.uniformBuffers.push(C),this._uniformBuffers[C]=U,this}setTextureSampler(C,U){return-1===this._options.samplerObjects.indexOf(C)&&this._options.samplerObjects.push(C),this._textureSamplers[C]=U,this}setStorageBuffer(C,U){return-1===this._options.storageBuffers.indexOf(C)&&this._options.storageBuffers.push(C),this._storageBuffers[C]=U,this}setDefine(C,U){const K=C.trimEnd()+" ",m=this.options.defines.findIndex((U=>U===C||U.startsWith(K)));return m>=0&&this.options.defines.splice(m,1),("boolean"!==typeof U||U)&&this.options.defines.push(K+U),this}isReadyForSubMesh(C,U,K){return this.isReady(C,K,U)}isReady(C,U,K){var m;const X=K&&this._storeEffectOnSubMeshes;if(this.isFrozen){const C=X?K._drawWrapper:this._drawWrapper;if(C.effect&&C._wasPreviouslyReady&&C._wasPreviouslyUsingInstances===U)return!0}const e=this.dC(),t=e.getEngine(),j=[],p=[];let E=null,Q=this._shaderPath,V=this._options.uniforms,f=this._options.uniformBuffers,F=this._options.samplers;t.getCaps().multiview&&e.activeCamera&&e.activeCamera.outputRenderTarget&&e.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,j.push("#define MULTIVIEW"),-1!==V.indexOf("viewProjection")&&-1===V.indexOf("viewProjectionR")&&V.push("viewProjectionR"));for(let O=0;O<this._options.defines.length;O++){const C=0===this._options.defines[O].indexOf("#define")?this._options.defines[O]:`#define ${this._options.defines[O]}`;j.push(C)}for(let O=0;O<this._options.attributes.length;O++)p.push(this._options.attributes[O]);if(C&&C.isVerticesDataPresent(A.d.ColorKind)&&(-1===p.indexOf(A.d.ColorKind)&&p.push(A.d.ColorKind),j.push("#define VERTEXCOLOR")),U&&(j.push("#define INSTANCES"),(0,b.X)(p,this._materialHelperNeedsPreviousMatrices),null!==C&&void 0!==C&&C.hasThinInstances&&(j.push("#define THIN_INSTANCES"),C&&C.isVerticesDataPresent(A.d.ColorInstanceKind)&&(p.push(A.d.ColorInstanceKind),j.push("#define INSTANCESCOLOR")))),C&&C.useBones&&C.computeBonesUsingShaders&&C.skeleton){p.push(A.d.MatricesIndicesKind),p.push(A.d.MatricesWeightsKind),C.numBoneInfluencers>4&&(p.push(A.d.MatricesIndicesExtraKind),p.push(A.d.MatricesWeightsExtraKind));const U=C.skeleton;j.push("#define NUM_BONE_INFLUENCERS "+C.numBoneInfluencers),E=new z.d,E.addCPUSkinningFallback(0,C),U.isUsingTextureForMatrices?(j.push("#define BONETEXTURE"),-1===V.indexOf("boneTextureWidth")&&V.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(j.push("#define BonesPerMesh "+(U.bones.length+1)),-1===V.indexOf("mBones")&&V.push("mBones"))}else j.push("#define NUM_BONE_INFLUENCERS 0");let Z=0;const P=C?C.morphTargetManager:null;if(P){const U=-1!==j.indexOf("#define UV1"),K=-1!==j.indexOf("#define UV2"),m=-1!==j.indexOf("#define TANGENT"),O=-1!==j.indexOf("#define NORMAL"),X=-1!==j.indexOf("#define VERTEXCOLOR");Z=(0,b.G)(P,j,p,C,!0,O,m,U,K,X),P.isUsingTextureForTargets&&(-1===V.indexOf("morphTargetTextureIndices")&&V.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),Z>0&&(V=V.slice(),V.push("morphTargetInfluences"),V.push("morphTargetCount"),V.push("morphTargetTextureInfo"),V.push("morphTargetTextureIndices"))}else j.push("#define NUM_MORPH_INFLUENCERS 0");if(C){const U=C.bakedVertexAnimationManager;U&&U.isEnabled&&(j.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===V.indexOf("bakedVertexAnimationSettings")&&V.push("bakedVertexAnimationSettings"),-1===V.indexOf("bakedVertexAnimationTextureSizeInverted")&&V.push("bakedVertexAnimationTextureSizeInverted"),-1===V.indexOf("bakedVertexAnimationTime")&&V.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,b.y)(p,C,j)}for(const O in this._textures)if(!this._textures[O].isReady())return!1;C&&this.needAlphaTestingForMesh(C)&&j.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,u.d)(V),(0,u.k)(this,e,j)),e.fogEnabled&&null!==C&&void 0!==C&&C.applyFog&&e.fogMode!==O.b.FOGMODE_NONE&&(j.push("#define FOG"),-1===V.indexOf("view")&&V.push("view"),-1===V.indexOf("vFogInfos")&&V.push("vFogInfos"),-1===V.indexOf("vFogColor")&&V.push("vFogColor")),this._useLogarithmicDepth&&(j.push("#define LOGARITHMICDEPTH"),-1===V.indexOf("logarithmicDepthConstant")&&V.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(V=V.slice(),f=f.slice(),F=F.slice(),Q=this.customShaderNameResolve(this.name,V,f,F,j,p));const H=X?K._getDrawWrapper(void 0,!0):this._drawWrapper,d=(null===H||void 0===H?void 0:H.effect)??null,T=(null===H||void 0===H?void 0:H.defines)??null,y=j.join("\n");let a=d;return T!==y&&(a=t.createEffect(Q,{attributes:p,uniformsNames:V,uniformBuffersNames:f,samplers:F,defines:y,fallbacks:E,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:Z},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},t),X?K.setEffect(a,y,this._materialContext):H&&H.setEffect(a,y),this._onEffectCreatedObservable&&(v.effect=a,v.subMesh=K??(null===C||void 0===C?void 0:C.me[0])??null,this._onEffectCreatedObservable.notifyObservers(v))),H._wasPreviouslyUsingInstances=!!U,!(null===(m=a)||void 0===m||!m.isReady())&&(d!==a&&e.resetCachedMaterial(),H._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(C,U){const K=U??this.getEffect();if(!K)return;const m=this._options.uniforms;-1!==m.indexOf("world")&&K.setMatrix("world",C);const O=this.dC();-1!==m.indexOf("worldView")&&(C.multiplyToRef(O.getViewMatrix(),this._cachedWorldViewMatrix),K.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==m.indexOf("worldViewProjection")&&(C.multiplyToRef(O.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),K.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==m.indexOf("view")&&K.setMatrix("view",O.getViewMatrix())}bindForSubMesh(C,U,K){var m;this.bind(C,U,null===(m=K._drawWrapperOverride)||void 0===m?void 0:m.effect,K)}bind(C,U,K,m){const O=m&&this._storeEffectOnSubMeshes,X=K??(O?m.effect:this.getEffect());if(!X)return;const A=this.dC();this._activeEffect=X,this.bindOnlyWorldMatrix(C,K);const e=this._options.uniformBuffers;let t=!1;if(X&&e&&e.length>0&&A.getEngine().supportsUniformBuffers)for(let p=0;p<e.length;++p){switch(e[p]){case"Mesh":U&&(U.getMeshUniformBuffer().bindToEffect(X,"Mesh"),U.transferToEffect(C));break;case"Scene":(0,b.r)(X,A.getSceneUniformBuffer()),A.finalizeSceneUbo(),t=!0}}const z=U&&O?this._mustRebind(A,X,m,U.visibility):A.getCachedMaterial()!==this;if(X&&z){let C;for(C in t||-1===this._options.uniforms.indexOf("view")||X.setMatrix("view",A.getViewMatrix()),t||-1===this._options.uniforms.indexOf("projection")||X.setMatrix("projection",A.getProjectionMatrix()),t||-1===this._options.uniforms.indexOf("viewProjection")||(X.setMatrix("viewProjection",A.getTransformMatrix()),this._multiview&&X.setMatrix("viewProjectionR",A._transformMatrixR)),A.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&X.setVector3("cameraPosition",A.activeCamera.globalPosition),(0,b.b)(U,X),(0,u.f)(X,this,A),this._useLogarithmicDepth&&(0,b.k)(O?m.materialDefines:X.defines,X,A),U&&(0,b.f)(A,U,X),this._textures)X.setTexture(C,this._textures[C]);for(C in this._textureArrays)X.setTextureArray(C,this._textureArrays[C]);for(C in this._ints)X.setInt(C,this._ints[C]);for(C in this._uints)X.setUInt(C,this._uints[C]);for(C in this._floats)X.setFloat(C,this._floats[C]);for(C in this._floatsArrays)X.setArray(C,this._floatsArrays[C]);for(C in this._colors3)X.setColor3(C,this._colors3[C]);for(C in this._colors3Arrays)X.setArray3(C,this._colors3Arrays[C]);for(C in this._colors4){const U=this._colors4[C];X.setFloat4(C,U.r,U.g,U.b,U.a)}for(C in this._colors4Arrays)X.setArray4(C,this._colors4Arrays[C]);for(C in this._vectors2)X.setVector2(C,this._vectors2[C]);for(C in this._vectors3)X.setVector3(C,this._vectors3[C]);for(C in this._vectors4)X.setVector4(C,this._vectors4[C]);for(C in this._quaternions)X.setQuaternion(C,this._quaternions[C]);for(C in this._matrices)X.setMatrix(C,this._matrices[C]);for(C in this._matrixArrays)X.setMatrices(C,this._matrixArrays[C]);for(C in this._matrices3x3)X.setMatrix3x3(C,this._matrices3x3[C]);for(C in this._matrices2x2)X.setMatrix2x2(C,this._matrices2x2[C]);for(C in this._vectors2Arrays)X.setArray2(C,this._vectors2Arrays[C]);for(C in this._vectors3Arrays)X.setArray3(C,this._vectors3Arrays[C]);for(C in this._vectors4Arrays)X.setArray4(C,this._vectors4Arrays[C]);for(C in this._quaternionsArrays)X.setArray4(C,this._quaternionsArrays[C]);for(C in this._uniformBuffers){const U=this._uniformBuffers[C].getBuffer();U&&X.bindUniformBuffer(U,C)}const K=A.getEngine(),e=K.setExternalTexture;if(e)for(C in this._externalTextures)e.call(K,C,this._externalTextures[C]);const z=K.setTextureSampler;if(z)for(C in this._textureSamplers)z.call(K,C,this._textureSamplers[C]);const j=K.setStorageBuffer;if(j)for(C in this._storageBuffers)j.call(K,C,this._storageBuffers[C])}if(X&&U&&(z||!this.isFrozen)){(0,b.n)(U,X),U.morphTargetManager&&U.morphTargetManager.isUsingTextureForTargets&&U.morphTargetManager._bind(X);const C=U.bakedVertexAnimationManager;if(C&&C.isEnabled){var j;const C=O?m._drawWrapper:this._drawWrapper;null===(j=U.bakedVertexAnimationManager)||void 0===j||j.bind(X,!!C._wasPreviouslyUsingInstances)}}this._afterBind(U,X,m)}getActiveTextures(){const C=super.getActiveTextures();for(const U in this._textures)C.push(this._textures[U]);for(const U in this._textureArrays){const K=this._textureArrays[U];for(let U=0;U<K.length;U++)C.push(K[U])}return C}hasTexture(C){if(super.hasTexture(C))return!0;for(const U in this._textures)if(this._textures[U]===C)return!0;for(const U in this._textureArrays){const K=this._textureArrays[U];for(let U=0;U<K.length;U++)if(K[U]===C)return!0}return!1}clone(C){const U=m.c.Clone((()=>new Q(C,this.dC(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);U.name=C,U.id=C,"object"===typeof U._shaderPath&&(U._shaderPath={...U._shaderPath}),this._options={...this._options};const K=Object.keys(this._options);for(const m of K){const C=this._options[m];Array.isArray(C)&&(this._options[m]=C.slice(0))}this.stencil.copyTo(U.stencil);for(const m in this._textures)U.setTexture(m,this._textures[m]);for(const m in this._textureArrays)U.setTextureArray(m,this._textureArrays[m]);for(const m in this._externalTextures)U.setExternalTexture(m,this._externalTextures[m]);for(const m in this._ints)U.setInt(m,this._ints[m]);for(const m in this._uints)U.setUInt(m,this._uints[m]);for(const m in this._floats)U.setFloat(m,this._floats[m]);for(const m in this._floatsArrays)U.setFloats(m,this._floatsArrays[m]);for(const m in this._colors3)U.setColor3(m,this._colors3[m]);for(const m in this._colors3Arrays)U._colors3Arrays[m]=this._colors3Arrays[m];for(const m in this._colors4)U.setColor4(m,this._colors4[m]);for(const m in this._colors4Arrays)U._colors4Arrays[m]=this._colors4Arrays[m];for(const m in this._vectors2)U.setVector2(m,this._vectors2[m]);for(const m in this._vectors3)U.setVector3(m,this._vectors3[m]);for(const m in this._vectors4)U.setVector4(m,this._vectors4[m]);for(const m in this._quaternions)U.setQuaternion(m,this._quaternions[m]);for(const m in this._quaternionsArrays)U._quaternionsArrays[m]=this._quaternionsArrays[m];for(const m in this._matrices)U.setMatrix(m,this._matrices[m]);for(const m in this._matrixArrays)U._matrixArrays[m]=this._matrixArrays[m].slice();for(const m in this._matrices3x3)U.setMatrix3x3(m,this._matrices3x3[m]);for(const m in this._matrices2x2)U.setMatrix2x2(m,this._matrices2x2[m]);for(const m in this._vectors2Arrays)U.setArray2(m,this._vectors2Arrays[m]);for(const m in this._vectors3Arrays)U.setArray3(m,this._vectors3Arrays[m]);for(const m in this._vectors4Arrays)U.setArray4(m,this._vectors4Arrays[m]);for(const m in this._uniformBuffers)U.setUniformBuffer(m,this._uniformBuffers[m]);for(const m in this._textureSamplers)U.setTextureSampler(m,this._textureSamplers[m]);for(const m in this._storageBuffers)U.setStorageBuffer(m,this._storageBuffers[m]);return U}dispose(C,U,K){if(U){let C;for(C in this._textures)this._textures[C].dispose();for(C in this._textureArrays){const U=this._textureArrays[C];for(let C=0;C<U.length;C++)U[C].dispose()}}this._textures={},super.dispose(C,U,K)}serialize(){const C=m.c.Serialize(this);let U;for(U in C.customType="BABYLON.ShaderMaterial",C.uniqueId=this.uniqueId,C.options=this._options,C.shaderPath=this._shaderPath,C.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,C.stencil=this.stencil.serialize(),C.textures={},this._textures)C.textures[U]=this._textures[U].serialize();for(U in C.textureArrays={},this._textureArrays){C.textureArrays[U]=[];const K=this._textureArrays[U];for(let m=0;m<K.length;m++)C.textureArrays[U].push(K[m].serialize())}for(U in C.ints={},this._ints)C.ints[U]=this._ints[U];for(U in C.uints={},this._uints)C.uints[U]=this._uints[U];for(U in C.floats={},this._floats)C.floats[U]=this._floats[U];for(U in C.floatsArrays={},this._floatsArrays)C.floatsArrays[U]=this._floatsArrays[U];for(U in C.colors3={},this._colors3){const K=this._colors3[U];C.colors3[U]=[K.r,K.g,K.b]}for(U in C.colors3Arrays={},this._colors3Arrays)C.colors3Arrays[U]=this._colors3Arrays[U];for(U in C.colors4={},this._colors4){const K=this._colors4[U];C.colors4[U]=[K.r,K.g,K.b,K.a]}for(U in C.colors4Arrays={},this._colors4Arrays)C.colors4Arrays[U]=this._colors4Arrays[U];for(U in C.vectors2={},this._vectors2){const K=this._vectors2[U];C.vectors2[U]=[K.x,K.y]}for(U in C.vectors3={},this._vectors3){const K=this._vectors3[U];C.vectors3[U]=[K.x,K.y,K.z]}for(U in C.vectors4={},this._vectors4){const K=this._vectors4[U];C.vectors4[U]=[K.x,K.y,K.z,K.w]}for(U in C.quaternions={},this._quaternions)C.quaternions[U]=this._quaternions[U].Oe();for(U in C.matrices={},this._matrices)C.matrices[U]=this._matrices[U].Oe();for(U in C.matrixArray={},this._matrixArrays)C.matrixArray[U]=this._matrixArrays[U];for(U in C.matrices3x3={},this._matrices3x3)C.matrices3x3[U]=this._matrices3x3[U];for(U in C.matrices2x2={},this._matrices2x2)C.matrices2x2[U]=this._matrices2x2[U];for(U in C.vectors2Arrays={},this._vectors2Arrays)C.vectors2Arrays[U]=this._vectors2Arrays[U];for(U in C.vectors3Arrays={},this._vectors3Arrays)C.vectors3Arrays[U]=this._vectors3Arrays[U];for(U in C.vectors4Arrays={},this._vectors4Arrays)C.vectors4Arrays[U]=this._vectors4Arrays[U];for(U in C.quaternionsArrays={},this._quaternionsArrays)C.quaternionsArrays[U]=this._quaternionsArrays[U];return C}static Parse(C,U,K){const O=m.c.Parse((()=>new Q(C.name,U,C.shaderPath,C.options,C.storeEffectOnSubMeshes)),C,U,K);let A;for(A in C.stencil&&O.stencil.parse(C.stencil,U,K),C.textures)O.setTexture(A,e.b.Parse(C.textures[A],U,K));for(A in C.textureArrays){const m=C.textureArrays[A],X=[];for(let C=0;C<m.length;C++)X.push(e.b.Parse(m[C],U,K));O.setTextureArray(A,X)}for(A in C.ints)O.setInt(A,C.ints[A]);for(A in C.uints)O.setUInt(A,C.uints[A]);for(A in C.floats)O.setFloat(A,C.floats[A]);for(A in C.floatsArrays)O.setFloats(A,C.floatsArrays[A]);for(A in C.colors3){const U=C.colors3[A];O.setColor3(A,{r:U[0],g:U[1],b:U[2]})}for(A in C.colors3Arrays){const U=C.colors3Arrays[A].reduce(((C,U,K)=>(K%3===0?C.push([U]):C[C.length-1].push(U),C)),[]).map((C=>({r:C[0],g:C[1],b:C[2]})));O.setColor3Array(A,U)}for(A in C.colors4){const U=C.colors4[A];O.setColor4(A,{r:U[0],g:U[1],b:U[2],a:U[3]})}for(A in C.colors4Arrays){const U=C.colors4Arrays[A].reduce(((C,U,K)=>(K%4===0?C.push([U]):C[C.length-1].push(U),C)),[]).map((C=>({r:C[0],g:C[1],b:C[2],a:C[3]})));O.setColor4Array(A,U)}for(A in C.vectors2){const U=C.vectors2[A];O.setVector2(A,{x:U[0],y:U[1]})}for(A in C.vectors3){const U=C.vectors3[A];O.setVector3(A,{x:U[0],y:U[1],z:U[2]})}for(A in C.vectors4){const U=C.vectors4[A];O.setVector4(A,{x:U[0],y:U[1],z:U[2],w:U[3]})}for(A in C.quaternions)O.setQuaternion(A,X.Quaternion.FU(C.quaternions[A]));for(A in C.matrices)O.setMatrix(A,X.Matrix.FU(C.matrices[A]));for(A in C.matrixArray)O._matrixArrays[A]=new Float32Array(C.matrixArray[A]);for(A in C.matrices3x3)O.setMatrix3x3(A,C.matrices3x3[A]);for(A in C.matrices2x2)O.setMatrix2x2(A,C.matrices2x2[A]);for(A in C.vectors2Arrays)O.setArray2(A,C.vectors2Arrays[A]);for(A in C.vectors3Arrays)O.setArray3(A,C.vectors3Arrays[A]);for(A in C.vectors4Arrays)O.setArray4(A,C.vectors4Arrays[A]);for(A in C.quaternionsArrays)O.setArray4(A,C.quaternionsArrays[A]);return O}static async ParseFromFileAsync(C,U,K){let m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((O,X)=>{const A=new j.b;A.addEventListener("readystatechange",(()=>{if(4==A.readyState)if(200==A.status){const U=JSON.parse(A.responseText),X=this.Parse(U,K||E.c.LastCreatedScene,m);C&&(X.name=C),O(X)}else X("Unable to load the ShaderMaterial")})),A.open("GET",U),A.send()}))}static async ParseFromSnippetAsync(C,U){let K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((m,O)=>{const X=new j.b;X.addEventListener("readystatechange",(()=>{if(4==X.readyState)if(200==X.status){const O=JSON.parse(JSON.parse(X.responseText).jsonPayload),A=JSON.parse(O.shaderMaterial),e=this.Parse(A,U||E.c.LastCreatedScene,K);e.snippetId=C,m(e)}else O("Unable to load the snippet "+C)})),X.open("GET",this.SnippetUrl+"/"+C.replace(/#/g,"/")),X.send()}))}}Q.SnippetUrl="https://snippet.babylonjs.com",Q.CreateFromSnippetAsync=Q.ParseFromSnippetAsync,(0,t.h)("BABYLON.ShaderMaterial",Q)}}]);