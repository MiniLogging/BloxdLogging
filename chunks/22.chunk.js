"use strict";(self.ynu1yiqvs98=self.ynu1yiqvs98||[]).push([[22],{11356:(I,E,j)=>{j.r(E),j.d(E,{ShaderMaterial:()=>F});var e=j(11149),w=j(11363),z=j(11117),h=j(11197),t=j(11097),U=j(11073),R=j(11422),P=j(10988),o=j(11427),Z=j(10993),c=j(11477),K=j(11470);const L={effect:null,subMesh:null};class F extends o.e{constructor(I,E,j){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(I,E,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new z.Matrix,this._cachedWorldViewProjectionMatrix=new z.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=j,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...e}}get shaderPath(){return this._shaderPath}set shaderPath(I){this._shaderPath=I}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(I){-1===this._options.uniforms.indexOf(I)&&this._options.uniforms.push(I)}setTexture(I,E){return-1===this._options.samplers.indexOf(I)&&this._options.samplers.push(I),this._textures[I]=E,this}removeTexture(I){delete this._textures[I]}setTextureArray(I,E){return-1===this._options.samplers.indexOf(I)&&this._options.samplers.push(I),this._checkUniform(I),this._textureArrays[I]=E,this}setExternalTexture(I,E){return-1===this._options.externalTextures.indexOf(I)&&this._options.externalTextures.push(I),this._externalTextures[I]=E,this}setFloat(I,E){return this._checkUniform(I),this._floats[I]=E,this}setInt(I,E){return this._checkUniform(I),this._ints[I]=E,this}setUInt(I,E){return this._checkUniform(I),this._uints[I]=E,this}setFloats(I,E){return this._checkUniform(I),this._floatsArrays[I]=E,this}setColor3(I,E){return this._checkUniform(I),this._colors3[I]=E,this}setColor3Array(I,E){return this._checkUniform(I),this._colors3Arrays[I]=E.reduce(((I,E)=>(I.push(E.r,E.g,E.b),I)),[]),this}setColor4(I,E){return this._checkUniform(I),this._colors4[I]=E,this}setColor4Array(I,E){return this._checkUniform(I),this._colors4Arrays[I]=E.reduce(((I,E)=>(I.push(E.r,E.g,E.b,E.a),I)),[]),this}setVector2(I,E){return this._checkUniform(I),this._vectors2[I]=E,this}setVector3(I,E){return this._checkUniform(I),this._vectors3[I]=E,this}setVector4(I,E){return this._checkUniform(I),this._vectors4[I]=E,this}setQuaternion(I,E){return this._checkUniform(I),this._quaternions[I]=E,this}setQuaternionArray(I,E){return this._checkUniform(I),this._quaternionsArrays[I]=E.reduce(((I,E)=>(E.toArray(I,I.length),I)),[]),this}setMatrix(I,E){return this._checkUniform(I),this._matrices[I]=E,this}setMatrices(I,E){this._checkUniform(I);const j=new Float32Array(16*E.length);for(let e=0;e<E.length;e++){E[e].copyToArray(j,16*e)}return this._matrixArrays[I]=j,this}setMatrix3x3(I,E){return this._checkUniform(I),this._matrices3x3[I]=E,this}setMatrix2x2(I,E){return this._checkUniform(I),this._matrices2x2[I]=E,this}setArray2(I,E){return this._checkUniform(I),this._vectors2Arrays[I]=E,this}setArray3(I,E){return this._checkUniform(I),this._vectors3Arrays[I]=E,this}setArray4(I,E){return this._checkUniform(I),this._vectors4Arrays[I]=E,this}setUniformBuffer(I,E){return-1===this._options.uniformBuffers.indexOf(I)&&this._options.uniformBuffers.push(I),this._uniformBuffers[I]=E,this}setTextureSampler(I,E){return-1===this._options.samplerObjects.indexOf(I)&&this._options.samplerObjects.push(I),this._textureSamplers[I]=E,this}setStorageBuffer(I,E){return-1===this._options.storageBuffers.indexOf(I)&&this._options.storageBuffers.push(I),this._storageBuffers[I]=E,this}setDefine(I,E){const j=I.trimEnd()+" ",e=this.options.defines.findIndex((E=>E===I||E.startsWith(j)));return e>=0&&this.options.defines.splice(e,1),("boolean"!==typeof E||E)&&this.options.defines.push(j+E),this}isReadyForSubMesh(I,E,j){return this.isReady(I,j,E)}isReady(I,E,j){var e;const z=j&&this._storeEffectOnSubMeshes;if(this.isFrozen){const I=z?j._drawWrapper:this._drawWrapper;if(I.effect&&I._wasPreviouslyReady&&I._wasPreviouslyUsingInstances===E)return!0}const t=this.GI(),U=t.getEngine(),P=[],o=[];let Z=null,F=this._shaderPath,C=this._options.uniforms,X=this._options.uniformBuffers,q=this._options.samplers;U.getCaps().multiview&&t.activeCamera&&t.activeCamera.outputRenderTarget&&t.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,P.push("#define MULTIVIEW"),-1!==C.indexOf("viewProjection")&&-1===C.indexOf("viewProjectionR")&&C.push("viewProjectionR"));for(let w=0;w<this._options.defines.length;w++){const I=0===this._options.defines[w].indexOf("#define")?this._options.defines[w]:`#define ${this._options.defines[w]}`;P.push(I)}for(let w=0;w<this._options.attributes.length;w++)o.push(this._options.attributes[w]);if(I&&I.isVerticesDataPresent(h.e.ColorKind)&&(-1===o.indexOf(h.e.ColorKind)&&o.push(h.e.ColorKind),P.push("#define VERTEXCOLOR")),E&&(P.push("#define INSTANCES"),(0,K.$)(o,this._materialHelperNeedsPreviousMatrices),null!==I&&void 0!==I&&I.hasThinInstances&&(P.push("#define THIN_INSTANCES"),I&&I.isVerticesDataPresent(h.e.ColorInstanceKind)&&(o.push(h.e.ColorInstanceKind),P.push("#define INSTANCESCOLOR")))),I&&I.useBones&&I.computeBonesUsingShaders&&I.skeleton){o.push(h.e.MatricesIndicesKind),o.push(h.e.MatricesWeightsKind),I.numBoneInfluencers>4&&(o.push(h.e.MatricesIndicesExtraKind),o.push(h.e.MatricesWeightsExtraKind));const E=I.skeleton;P.push("#define NUM_BONE_INFLUENCERS "+I.numBoneInfluencers),Z=new R.e,Z.addCPUSkinningFallback(0,I),E.isUsingTextureForMatrices?(P.push("#define BONETEXTURE"),-1===C.indexOf("boneTextureWidth")&&C.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(P.push("#define BonesPerMesh "+(E.bones.length+1)),-1===C.indexOf("mBones")&&C.push("mBones"))}else P.push("#define NUM_BONE_INFLUENCERS 0");let x=0;const u=I?I.morphTargetManager:null;if(u){const E=-1!==P.indexOf("#define UV1"),j=-1!==P.indexOf("#define UV2"),e=-1!==P.indexOf("#define TANGENT"),w=-1!==P.indexOf("#define NORMAL"),z=-1!==P.indexOf("#define VERTEXCOLOR");x=(0,K.B)(u,P,o,I,!0,w,e,E,j,z),u.isUsingTextureForTargets&&(-1===C.indexOf("morphTargetTextureIndices")&&C.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),x>0&&(C=C.slice(),C.push("morphTargetInfluences"),C.push("morphTargetCount"),C.push("morphTargetTextureInfo"),C.push("morphTargetTextureIndices"))}else P.push("#define NUM_MORPH_INFLUENCERS 0");if(I){const E=I.bakedVertexAnimationManager;E&&E.isEnabled&&(P.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===C.indexOf("bakedVertexAnimationSettings")&&C.push("bakedVertexAnimationSettings"),-1===C.indexOf("bakedVertexAnimationTextureSizeInverted")&&C.push("bakedVertexAnimationTextureSizeInverted"),-1===C.indexOf("bakedVertexAnimationTime")&&C.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,K.s)(o,I,P)}for(const w in this._textures)if(!this._textures[w].isReady())return!1;I&&this.needAlphaTestingForMesh(I)&&P.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,c.d)(C),(0,c.l)(this,t,P)),t.fogEnabled&&null!==I&&void 0!==I&&I.applyFog&&t.fogMode!==w.c.FOGMODE_NONE&&(P.push("#define FOG"),-1===C.indexOf("view")&&C.push("view"),-1===C.indexOf("vFogInfos")&&C.push("vFogInfos"),-1===C.indexOf("vFogColor")&&C.push("vFogColor")),this._useLogarithmicDepth&&(P.push("#define LOGARITHMICDEPTH"),-1===C.indexOf("logarithmicDepthConstant")&&C.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(C=C.slice(),X=X.slice(),q=q.slice(),F=this.customShaderNameResolve(this.name,C,X,q,P,o));const b=z?j._getDrawWrapper(void 0,!0):this._drawWrapper,Q=(null===b||void 0===b?void 0:b.effect)??null,G=(null===b||void 0===b?void 0:b.defines)??null,y=P.join("\n");let d=Q;return G!==y&&(d=U.createEffect(F,{attributes:o,uniformsNames:C,uniformBuffersNames:X,samplers:q,defines:y,fallbacks:Z,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:x},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},U),z?j.setEffect(d,y,this._materialContext):b&&b.setEffect(d,y),this._onEffectCreatedObservable&&(L.effect=d,L.subMesh=j??(null===I||void 0===I?void 0:I.ie[0])??null,this._onEffectCreatedObservable.notifyObservers(L))),b._wasPreviouslyUsingInstances=!!E,!(null===(e=d)||void 0===e||!e.isReady())&&(Q!==d&&t.resetCachedMaterial(),b._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(I,E){const j=E??this.getEffect();if(!j)return;const e=this._options.uniforms;-1!==e.indexOf("world")&&j.setMatrix("world",I);const w=this.GI();-1!==e.indexOf("worldView")&&(I.multiplyToRef(w.getViewMatrix(),this._cachedWorldViewMatrix),j.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==e.indexOf("worldViewProjection")&&(I.multiplyToRef(w.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),j.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==e.indexOf("view")&&j.setMatrix("view",w.getViewMatrix())}bindForSubMesh(I,E,j){var e;this.bind(I,E,null===(e=j._drawWrapperOverride)||void 0===e?void 0:e.effect,j)}bind(I,E,j,e){const w=e&&this._storeEffectOnSubMeshes,z=j??(w?e.effect:this.getEffect());if(!z)return;const h=this.GI();this._activeEffect=z,this.bindOnlyWorldMatrix(I,j);const t=this._options.uniformBuffers;let U=!1;if(z&&t&&t.length>0&&h.getEngine().supportsUniformBuffers)for(let o=0;o<t.length;++o){switch(t[o]){case"Mesh":E&&(E.getMeshUniformBuffer().bindToEffect(z,"Mesh"),E.transferToEffect(I));break;case"Scene":(0,K.l)(z,h.getSceneUniformBuffer()),h.finalizeSceneUbo(),U=!0}}const R=E&&w?this._mustRebind(h,z,e,E.visibility):h.getCachedMaterial()!==this;if(z&&R){let I;for(I in U||-1===this._options.uniforms.indexOf("view")||z.setMatrix("view",h.getViewMatrix()),U||-1===this._options.uniforms.indexOf("projection")||z.setMatrix("projection",h.getProjectionMatrix()),U||-1===this._options.uniforms.indexOf("viewProjection")||(z.setMatrix("viewProjection",h.getTransformMatrix()),this._multiview&&z.setMatrix("viewProjectionR",h._transformMatrixR)),h.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&z.setVector3("cameraPosition",h.activeCamera.globalPosition),(0,K.c)(E,z),(0,c.f)(z,this,h),this._useLogarithmicDepth&&(0,K.g)(w?e.materialDefines:z.defines,z,h),E&&(0,K.d)(h,E,z),this._textures)z.setTexture(I,this._textures[I]);for(I in this._textureArrays)z.setTextureArray(I,this._textureArrays[I]);for(I in this._ints)z.setInt(I,this._ints[I]);for(I in this._uints)z.setUInt(I,this._uints[I]);for(I in this._floats)z.setFloat(I,this._floats[I]);for(I in this._floatsArrays)z.setArray(I,this._floatsArrays[I]);for(I in this._colors3)z.setColor3(I,this._colors3[I]);for(I in this._colors3Arrays)z.setArray3(I,this._colors3Arrays[I]);for(I in this._colors4){const E=this._colors4[I];z.setFloat4(I,E.r,E.g,E.b,E.a)}for(I in this._colors4Arrays)z.setArray4(I,this._colors4Arrays[I]);for(I in this._vectors2)z.setVector2(I,this._vectors2[I]);for(I in this._vectors3)z.setVector3(I,this._vectors3[I]);for(I in this._vectors4)z.setVector4(I,this._vectors4[I]);for(I in this._quaternions)z.setQuaternion(I,this._quaternions[I]);for(I in this._matrices)z.setMatrix(I,this._matrices[I]);for(I in this._matrixArrays)z.setMatrices(I,this._matrixArrays[I]);for(I in this._matrices3x3)z.setMatrix3x3(I,this._matrices3x3[I]);for(I in this._matrices2x2)z.setMatrix2x2(I,this._matrices2x2[I]);for(I in this._vectors2Arrays)z.setArray2(I,this._vectors2Arrays[I]);for(I in this._vectors3Arrays)z.setArray3(I,this._vectors3Arrays[I]);for(I in this._vectors4Arrays)z.setArray4(I,this._vectors4Arrays[I]);for(I in this._quaternionsArrays)z.setArray4(I,this._quaternionsArrays[I]);for(I in this._uniformBuffers){const E=this._uniformBuffers[I].getBuffer();E&&z.bindUniformBuffer(E,I)}const j=h.getEngine(),t=j.setExternalTexture;if(t)for(I in this._externalTextures)t.call(j,I,this._externalTextures[I]);const R=j.setTextureSampler;if(R)for(I in this._textureSamplers)R.call(j,I,this._textureSamplers[I]);const P=j.setStorageBuffer;if(P)for(I in this._storageBuffers)P.call(j,I,this._storageBuffers[I])}if(z&&E&&(R||!this.isFrozen)){(0,K.j)(E,z),E.morphTargetManager&&E.morphTargetManager.isUsingTextureForTargets&&E.morphTargetManager._bind(z);const I=E.bakedVertexAnimationManager;if(I&&I.isEnabled){var P;const I=w?e._drawWrapper:this._drawWrapper;null===(P=E.bakedVertexAnimationManager)||void 0===P||P.bind(z,!!I._wasPreviouslyUsingInstances)}}this._afterBind(E,z,e)}getActiveTextures(){const I=super.getActiveTextures();for(const E in this._textures)I.push(this._textures[E]);for(const E in this._textureArrays){const j=this._textureArrays[E];for(let E=0;E<j.length;E++)I.push(j[E])}return I}hasTexture(I){if(super.hasTexture(I))return!0;for(const E in this._textures)if(this._textures[E]===I)return!0;for(const E in this._textureArrays){const j=this._textureArrays[E];for(let E=0;E<j.length;E++)if(j[E]===I)return!0}return!1}clone(I){const E=e.e.Clone((()=>new F(I,this.GI(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);E.name=I,E.id=I,"object"===typeof E._shaderPath&&(E._shaderPath={...E._shaderPath}),this._options={...this._options};const j=Object.keys(this._options);for(const e of j){const I=this._options[e];Array.isArray(I)&&(this._options[e]=I.slice(0))}this.stencil.copyTo(E.stencil);for(const e in this._textures)E.setTexture(e,this._textures[e]);for(const e in this._textureArrays)E.setTextureArray(e,this._textureArrays[e]);for(const e in this._externalTextures)E.setExternalTexture(e,this._externalTextures[e]);for(const e in this._ints)E.setInt(e,this._ints[e]);for(const e in this._uints)E.setUInt(e,this._uints[e]);for(const e in this._floats)E.setFloat(e,this._floats[e]);for(const e in this._floatsArrays)E.setFloats(e,this._floatsArrays[e]);for(const e in this._colors3)E.setColor3(e,this._colors3[e]);for(const e in this._colors3Arrays)E._colors3Arrays[e]=this._colors3Arrays[e];for(const e in this._colors4)E.setColor4(e,this._colors4[e]);for(const e in this._colors4Arrays)E._colors4Arrays[e]=this._colors4Arrays[e];for(const e in this._vectors2)E.setVector2(e,this._vectors2[e]);for(const e in this._vectors3)E.setVector3(e,this._vectors3[e]);for(const e in this._vectors4)E.setVector4(e,this._vectors4[e]);for(const e in this._quaternions)E.setQuaternion(e,this._quaternions[e]);for(const e in this._quaternionsArrays)E._quaternionsArrays[e]=this._quaternionsArrays[e];for(const e in this._matrices)E.setMatrix(e,this._matrices[e]);for(const e in this._matrixArrays)E._matrixArrays[e]=this._matrixArrays[e].slice();for(const e in this._matrices3x3)E.setMatrix3x3(e,this._matrices3x3[e]);for(const e in this._matrices2x2)E.setMatrix2x2(e,this._matrices2x2[e]);for(const e in this._vectors2Arrays)E.setArray2(e,this._vectors2Arrays[e]);for(const e in this._vectors3Arrays)E.setArray3(e,this._vectors3Arrays[e]);for(const e in this._vectors4Arrays)E.setArray4(e,this._vectors4Arrays[e]);for(const e in this._uniformBuffers)E.setUniformBuffer(e,this._uniformBuffers[e]);for(const e in this._textureSamplers)E.setTextureSampler(e,this._textureSamplers[e]);for(const e in this._storageBuffers)E.setStorageBuffer(e,this._storageBuffers[e]);return E}dispose(I,E,j){if(E){let I;for(I in this._textures)this._textures[I].dispose();for(I in this._textureArrays){const E=this._textureArrays[I];for(let I=0;I<E.length;I++)E[I].dispose()}}this._textures={},super.dispose(I,E,j)}serialize(){const I=e.e.Serialize(this);let E;for(E in I.customType="BABYLON.ShaderMaterial",I.uniqueId=this.uniqueId,I.options=this._options,I.shaderPath=this._shaderPath,I.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,I.stencil=this.stencil.serialize(),I.textures={},this._textures)I.textures[E]=this._textures[E].serialize();for(E in I.textureArrays={},this._textureArrays){I.textureArrays[E]=[];const j=this._textureArrays[E];for(let e=0;e<j.length;e++)I.textureArrays[E].push(j[e].serialize())}for(E in I.ints={},this._ints)I.ints[E]=this._ints[E];for(E in I.uints={},this._uints)I.uints[E]=this._uints[E];for(E in I.floats={},this._floats)I.floats[E]=this._floats[E];for(E in I.floatsArrays={},this._floatsArrays)I.floatsArrays[E]=this._floatsArrays[E];for(E in I.colors3={},this._colors3){const j=this._colors3[E];I.colors3[E]=[j.r,j.g,j.b]}for(E in I.colors3Arrays={},this._colors3Arrays)I.colors3Arrays[E]=this._colors3Arrays[E];for(E in I.colors4={},this._colors4){const j=this._colors4[E];I.colors4[E]=[j.r,j.g,j.b,j.a]}for(E in I.colors4Arrays={},this._colors4Arrays)I.colors4Arrays[E]=this._colors4Arrays[E];for(E in I.vectors2={},this._vectors2){const j=this._vectors2[E];I.vectors2[E]=[j.x,j.y]}for(E in I.vectors3={},this._vectors3){const j=this._vectors3[E];I.vectors3[E]=[j.x,j.y,j.z]}for(E in I.vectors4={},this._vectors4){const j=this._vectors4[E];I.vectors4[E]=[j.x,j.y,j.z,j.w]}for(E in I.quaternions={},this._quaternions)I.quaternions[E]=this._quaternions[E].re();for(E in I.matrices={},this._matrices)I.matrices[E]=this._matrices[E].re();for(E in I.matrixArray={},this._matrixArrays)I.matrixArray[E]=this._matrixArrays[E];for(E in I.matrices3x3={},this._matrices3x3)I.matrices3x3[E]=this._matrices3x3[E];for(E in I.matrices2x2={},this._matrices2x2)I.matrices2x2[E]=this._matrices2x2[E];for(E in I.vectors2Arrays={},this._vectors2Arrays)I.vectors2Arrays[E]=this._vectors2Arrays[E];for(E in I.vectors3Arrays={},this._vectors3Arrays)I.vectors3Arrays[E]=this._vectors3Arrays[E];for(E in I.vectors4Arrays={},this._vectors4Arrays)I.vectors4Arrays[E]=this._vectors4Arrays[E];for(E in I.quaternionsArrays={},this._quaternionsArrays)I.quaternionsArrays[E]=this._quaternionsArrays[E];return I}static Parse(I,E,j){const w=e.e.Parse((()=>new F(I.name,E,I.shaderPath,I.options,I.storeEffectOnSubMeshes)),I,E,j);let h;for(h in I.stencil&&w.stencil.parse(I.stencil,E,j),I.textures)w.setTexture(h,t.d.Parse(I.textures[h],E,j));for(h in I.textureArrays){const e=I.textureArrays[h],z=[];for(let I=0;I<e.length;I++)z.push(t.d.Parse(e[I],E,j));w.setTextureArray(h,z)}for(h in I.ints)w.setInt(h,I.ints[h]);for(h in I.uints)w.setUInt(h,I.uints[h]);for(h in I.floats)w.setFloat(h,I.floats[h]);for(h in I.floatsArrays)w.setFloats(h,I.floatsArrays[h]);for(h in I.colors3){const E=I.colors3[h];w.setColor3(h,{r:E[0],g:E[1],b:E[2]})}for(h in I.colors3Arrays){const E=I.colors3Arrays[h].reduce(((I,E,j)=>(j%3===0?I.push([E]):I[I.length-1].push(E),I)),[]).map((I=>({r:I[0],g:I[1],b:I[2]})));w.setColor3Array(h,E)}for(h in I.colors4){const E=I.colors4[h];w.setColor4(h,{r:E[0],g:E[1],b:E[2],a:E[3]})}for(h in I.colors4Arrays){const E=I.colors4Arrays[h].reduce(((I,E,j)=>(j%4===0?I.push([E]):I[I.length-1].push(E),I)),[]).map((I=>({r:I[0],g:I[1],b:I[2],a:I[3]})));w.setColor4Array(h,E)}for(h in I.vectors2){const E=I.vectors2[h];w.setVector2(h,{x:E[0],y:E[1]})}for(h in I.vectors3){const E=I.vectors3[h];w.setVector3(h,{x:E[0],y:E[1],z:E[2]})}for(h in I.vectors4){const E=I.vectors4[h];w.setVector4(h,{x:E[0],y:E[1],z:E[2],w:E[3]})}for(h in I.quaternions)w.setQuaternion(h,z.Quaternion.xE(I.quaternions[h]));for(h in I.matrices)w.setMatrix(h,z.Matrix.xE(I.matrices[h]));for(h in I.matrixArray)w._matrixArrays[h]=new Float32Array(I.matrixArray[h]);for(h in I.matrices3x3)w.setMatrix3x3(h,I.matrices3x3[h]);for(h in I.matrices2x2)w.setMatrix2x2(h,I.matrices2x2[h]);for(h in I.vectors2Arrays)w.setArray2(h,I.vectors2Arrays[h]);for(h in I.vectors3Arrays)w.setArray3(h,I.vectors3Arrays[h]);for(h in I.vectors4Arrays)w.setArray4(h,I.vectors4Arrays[h]);for(h in I.quaternionsArrays)w.setArray4(h,I.quaternionsArrays[h]);return w}static async ParseFromFileAsync(I,E,j){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((w,z)=>{const h=new P.c;h.addEventListener("readystatechange",(()=>{if(4==h.readyState)if(200==h.status){const E=JSON.parse(h.responseText),z=this.Parse(E,j||Z.d.LastCreatedScene,e);I&&(z.name=I),w(z)}else z("Unable to load the ShaderMaterial")})),h.open("GET",E),h.send()}))}static async ParseFromSnippetAsync(I,E){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((e,w)=>{const z=new P.c;z.addEventListener("readystatechange",(()=>{if(4==z.readyState)if(200==z.status){const w=JSON.parse(JSON.parse(z.responseText).jsonPayload),h=JSON.parse(w.shaderMaterial),t=this.Parse(h,E||Z.d.LastCreatedScene,j);t.snippetId=I,e(t)}else w("Unable to load the snippet "+I)})),z.open("GET",this.SnippetUrl+"/"+I.replace(/#/g,"/")),z.send()}))}}F.SnippetUrl="https://snippet.babylonjs.com",F.CreateFromSnippetAsync=F.ParseFromSnippetAsync,(0,U.h)("BABYLON.ShaderMaterial",F)}}]);