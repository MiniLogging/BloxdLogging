"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[22],{11431:(o,H,n)=>{n.r(H),n.d(H,{ShaderMaterial:()=>V});var E=n(11224),k=n(11435),g=n(11189),O=n(11259),Y=n(11168),y=n(11140),S=n(11520),G=n(11057),c=n(11525),A=n(11060),l=n(11565),x=n(11562);const z={effect:null,subMesh:null};class V extends c.b{constructor(o,H,n){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(o,H,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new g.Matrix,this._cachedWorldViewProjectionMatrix=new g.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=n,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...E}}get shaderPath(){return this._shaderPath}set shaderPath(o){this._shaderPath=o}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(o){-1===this._options.uniforms.indexOf(o)&&this._options.uniforms.push(o)}setTexture(o,H){return-1===this._options.samplers.indexOf(o)&&this._options.samplers.push(o),this._textures[o]=H,this}removeTexture(o){delete this._textures[o]}setTextureArray(o,H){return-1===this._options.samplers.indexOf(o)&&this._options.samplers.push(o),this._checkUniform(o),this._textureArrays[o]=H,this}setExternalTexture(o,H){return-1===this._options.externalTextures.indexOf(o)&&this._options.externalTextures.push(o),this._externalTextures[o]=H,this}setFloat(o,H){return this._checkUniform(o),this._floats[o]=H,this}setInt(o,H){return this._checkUniform(o),this._ints[o]=H,this}setUInt(o,H){return this._checkUniform(o),this._uints[o]=H,this}setFloats(o,H){return this._checkUniform(o),this._floatsArrays[o]=H,this}setColor3(o,H){return this._checkUniform(o),this._colors3[o]=H,this}setColor3Array(o,H){return this._checkUniform(o),this._colors3Arrays[o]=H.reduce(((o,H)=>(o.push(H.r,H.g,H.b),o)),[]),this}setColor4(o,H){return this._checkUniform(o),this._colors4[o]=H,this}setColor4Array(o,H){return this._checkUniform(o),this._colors4Arrays[o]=H.reduce(((o,H)=>(o.push(H.r,H.g,H.b,H.a),o)),[]),this}setVector2(o,H){return this._checkUniform(o),this._vectors2[o]=H,this}setVector3(o,H){return this._checkUniform(o),this._vectors3[o]=H,this}setVector4(o,H){return this._checkUniform(o),this._vectors4[o]=H,this}setQuaternion(o,H){return this._checkUniform(o),this._quaternions[o]=H,this}setQuaternionArray(o,H){return this._checkUniform(o),this._quaternionsArrays[o]=H.reduce(((o,H)=>(H.toArray(o,o.length),o)),[]),this}setMatrix(o,H){return this._checkUniform(o),this._matrices[o]=H,this}setMatrices(o,H){this._checkUniform(o);const n=new Float32Array(16*H.length);for(let E=0;E<H.length;E++){H[E].copyToArray(n,16*E)}return this._matrixArrays[o]=n,this}setMatrix3x3(o,H){return this._checkUniform(o),this._matrices3x3[o]=H,this}setMatrix2x2(o,H){return this._checkUniform(o),this._matrices2x2[o]=H,this}setArray2(o,H){return this._checkUniform(o),this._vectors2Arrays[o]=H,this}setArray3(o,H){return this._checkUniform(o),this._vectors3Arrays[o]=H,this}setArray4(o,H){return this._checkUniform(o),this._vectors4Arrays[o]=H,this}setUniformBuffer(o,H){return-1===this._options.uniformBuffers.indexOf(o)&&this._options.uniformBuffers.push(o),this._uniformBuffers[o]=H,this}setTextureSampler(o,H){return-1===this._options.samplerObjects.indexOf(o)&&this._options.samplerObjects.push(o),this._textureSamplers[o]=H,this}setStorageBuffer(o,H){return-1===this._options.storageBuffers.indexOf(o)&&this._options.storageBuffers.push(o),this._storageBuffers[o]=H,this}setDefine(o,H){const n=o.trimEnd()+" ",E=this.options.defines.findIndex((H=>H===o||H.startsWith(n)));return E>=0&&this.options.defines.splice(E,1),("boolean"!==typeof H||H)&&this.options.defines.push(n+H),this}isReadyForSubMesh(o,H,n){return this.isReady(o,n,H)}isReady(o,H,n){var E;const g=n&&this._storeEffectOnSubMeshes;if(this.isFrozen){const o=g?n._drawWrapper:this._drawWrapper;if(o.effect&&o._wasPreviouslyReady&&o._wasPreviouslyUsingInstances===H)return!0}const Y=this.bo(),y=Y.getEngine(),G=[],c=[];let A=null,V=this._shaderPath,J=this._options.uniforms,N=this._options.uniformBuffers,h=this._options.samplers;y.getCaps().multiview&&Y.activeCamera&&Y.activeCamera.outputRenderTarget&&Y.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,G.push("#define MULTIVIEW"),-1!==J.indexOf("viewProjection")&&-1===J.indexOf("viewProjectionR")&&J.push("viewProjectionR"));for(let k=0;k<this._options.defines.length;k++){const o=0===this._options.defines[k].indexOf("#define")?this._options.defines[k]:`#define ${this._options.defines[k]}`;G.push(o)}for(let k=0;k<this._options.attributes.length;k++)c.push(this._options.attributes[k]);if(o&&o.isVerticesDataPresent(O.d.ColorKind)&&(-1===c.indexOf(O.d.ColorKind)&&c.push(O.d.ColorKind),G.push("#define VERTEXCOLOR")),H&&(G.push("#define INSTANCES"),(0,x.fb)(c,this._materialHelperNeedsPreviousMatrices),null!==o&&void 0!==o&&o.hasThinInstances&&(G.push("#define THIN_INSTANCES"),o&&o.isVerticesDataPresent(O.d.ColorInstanceKind)&&(c.push(O.d.ColorInstanceKind),G.push("#define INSTANCESCOLOR")))),o&&o.useBones&&o.computeBonesUsingShaders&&o.skeleton){c.push(O.d.MatricesIndicesKind),c.push(O.d.MatricesWeightsKind),o.numBoneInfluencers>4&&(c.push(O.d.MatricesIndicesExtraKind),c.push(O.d.MatricesWeightsExtraKind));const H=o.skeleton;G.push("#define NUM_BONE_INFLUENCERS "+o.numBoneInfluencers),A=new S.d,A.addCPUSkinningFallback(0,o),H.isUsingTextureForMatrices?(G.push("#define BONETEXTURE"),-1===J.indexOf("boneTextureWidth")&&J.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(G.push("#define BonesPerMesh "+(H.bones.length+1)),-1===J.indexOf("mBones")&&J.push("mBones"))}else G.push("#define NUM_BONE_INFLUENCERS 0");let Q=0;const p=o?o.morphTargetManager:null;if(p){const H=-1!==G.indexOf("#define UV1"),n=-1!==G.indexOf("#define UV2"),E=-1!==G.indexOf("#define TANGENT"),k=-1!==G.indexOf("#define NORMAL"),g=-1!==G.indexOf("#define VERTEXCOLOR");Q=(0,x.M)(p,G,c,o,!0,k,E,H,n,g),p.isUsingTextureForTargets&&(-1===J.indexOf("morphTargetTextureIndices")&&J.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),Q>0&&(J=J.slice(),J.push("morphTargetInfluences"),J.push("morphTargetCount"),J.push("morphTargetTextureInfo"),J.push("morphTargetTextureIndices"))}else G.push("#define NUM_MORPH_INFLUENCERS 0");if(o){const H=o.bakedVertexAnimationManager;H&&H.isEnabled&&(G.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===J.indexOf("bakedVertexAnimationSettings")&&J.push("bakedVertexAnimationSettings"),-1===J.indexOf("bakedVertexAnimationTextureSizeInverted")&&J.push("bakedVertexAnimationTextureSizeInverted"),-1===J.indexOf("bakedVertexAnimationTime")&&J.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,x.A)(c,o,G)}for(const k in this._textures)if(!this._textures[k].isReady())return!1;o&&this.needAlphaTestingForMesh(o)&&G.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,l.e)(J),(0,l.n)(this,Y,G)),Y.fogEnabled&&null!==o&&void 0!==o&&o.applyFog&&Y.fogMode!==k.c.FOGMODE_NONE&&(G.push("#define FOG"),-1===J.indexOf("view")&&J.push("view"),-1===J.indexOf("vFogInfos")&&J.push("vFogInfos"),-1===J.indexOf("vFogColor")&&J.push("vFogColor")),this._useLogarithmicDepth&&(G.push("#define LOGARITHMICDEPTH"),-1===J.indexOf("logarithmicDepthConstant")&&J.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(J=J.slice(),N=N.slice(),h=h.slice(),V=this.customShaderNameResolve(this.name,J,N,h,G,c));const j=g?n._getDrawWrapper(void 0,!0):this._drawWrapper,m=(null===j||void 0===j?void 0:j.effect)??null,P=(null===j||void 0===j?void 0:j.defines)??null,b=G.join("\n");let e=m;return P!==b&&(e=y.createEffect(V,{attributes:c,uniformsNames:J,uniformBuffersNames:N,samplers:h,defines:b,fallbacks:A,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:Q},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},y),g?n.setEffect(e,b,this._materialContext):j&&j.setEffect(e,b),this._onEffectCreatedObservable&&(z.effect=e,z.subMesh=n??(null===o||void 0===o?void 0:o.jg[0])??null,this._onEffectCreatedObservable.notifyObservers(z))),j._wasPreviouslyUsingInstances=!!H,!(null===(E=e)||void 0===E||!E.isReady())&&(m!==e&&Y.resetCachedMaterial(),j._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(o,H){const n=H??this.getEffect();if(!n)return;const E=this._options.uniforms;-1!==E.indexOf("world")&&n.setMatrix("world",o);const k=this.bo();-1!==E.indexOf("worldView")&&(o.multiplyToRef(k.getViewMatrix(),this._cachedWorldViewMatrix),n.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==E.indexOf("worldViewProjection")&&(o.multiplyToRef(k.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),n.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==E.indexOf("view")&&n.setMatrix("view",k.getViewMatrix())}bindForSubMesh(o,H,n){var E;this.bind(o,H,null===(E=n._drawWrapperOverride)||void 0===E?void 0:E.effect,n)}bind(o,H,n,E){const k=E&&this._storeEffectOnSubMeshes,g=n??(k?E.effect:this.getEffect());if(!g)return;const O=this.bo();this._activeEffect=g,this.bindOnlyWorldMatrix(o,n);const Y=this._options.uniformBuffers;let y=!1;if(g&&Y&&Y.length>0&&O.getEngine().supportsUniformBuffers)for(let c=0;c<Y.length;++c){switch(Y[c]){case"Mesh":H&&(H.getMeshUniformBuffer().bindToEffect(g,"Mesh"),H.transferToEffect(o));break;case"Scene":(0,x.t)(g,O.getSceneUniformBuffer()),O.finalizeSceneUbo(),y=!0}}const S=H&&k?this._mustRebind(O,g,E,H.visibility):O.getCachedMaterial()!==this;if(g&&S){let o;for(o in y||-1===this._options.uniforms.indexOf("view")||g.setMatrix("view",O.getViewMatrix()),y||-1===this._options.uniforms.indexOf("projection")||g.setMatrix("projection",O.getProjectionMatrix()),y||-1===this._options.uniforms.indexOf("viewProjection")||(g.setMatrix("viewProjection",O.getTransformMatrix()),this._multiview&&g.setMatrix("viewProjectionR",O._transformMatrixR)),O.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&g.setVector3("cameraPosition",O.activeCamera.globalPosition),(0,x.c)(H,g),(0,l.i)(g,this,O),this._useLogarithmicDepth&&(0,x.l)(k?E.materialDefines:g.defines,g,O),H&&(0,x.f)(O,H,g),this._textures)g.setTexture(o,this._textures[o]);for(o in this._textureArrays)g.setTextureArray(o,this._textureArrays[o]);for(o in this._ints)g.setInt(o,this._ints[o]);for(o in this._uints)g.setUInt(o,this._uints[o]);for(o in this._floats)g.setFloat(o,this._floats[o]);for(o in this._floatsArrays)g.setArray(o,this._floatsArrays[o]);for(o in this._colors3)g.setColor3(o,this._colors3[o]);for(o in this._colors3Arrays)g.setArray3(o,this._colors3Arrays[o]);for(o in this._colors4){const H=this._colors4[o];g.setFloat4(o,H.r,H.g,H.b,H.a)}for(o in this._colors4Arrays)g.setArray4(o,this._colors4Arrays[o]);for(o in this._vectors2)g.setVector2(o,this._vectors2[o]);for(o in this._vectors3)g.setVector3(o,this._vectors3[o]);for(o in this._vectors4)g.setVector4(o,this._vectors4[o]);for(o in this._quaternions)g.setQuaternion(o,this._quaternions[o]);for(o in this._matrices)g.setMatrix(o,this._matrices[o]);for(o in this._matrixArrays)g.setMatrices(o,this._matrixArrays[o]);for(o in this._matrices3x3)g.setMatrix3x3(o,this._matrices3x3[o]);for(o in this._matrices2x2)g.setMatrix2x2(o,this._matrices2x2[o]);for(o in this._vectors2Arrays)g.setArray2(o,this._vectors2Arrays[o]);for(o in this._vectors3Arrays)g.setArray3(o,this._vectors3Arrays[o]);for(o in this._vectors4Arrays)g.setArray4(o,this._vectors4Arrays[o]);for(o in this._quaternionsArrays)g.setArray4(o,this._quaternionsArrays[o]);for(o in this._uniformBuffers){const H=this._uniformBuffers[o].getBuffer();H&&g.bindUniformBuffer(H,o)}const n=O.getEngine(),Y=n.setExternalTexture;if(Y)for(o in this._externalTextures)Y.call(n,o,this._externalTextures[o]);const S=n.setTextureSampler;if(S)for(o in this._textureSamplers)S.call(n,o,this._textureSamplers[o]);const G=n.setStorageBuffer;if(G)for(o in this._storageBuffers)G.call(n,o,this._storageBuffers[o])}if(g&&H&&(S||!this.isFrozen)){(0,x.p)(H,g),H.morphTargetManager&&H.morphTargetManager.isUsingTextureForTargets&&H.morphTargetManager._bind(g);const o=H.bakedVertexAnimationManager;if(o&&o.isEnabled){var G;const o=k?E._drawWrapper:this._drawWrapper;null===(G=H.bakedVertexAnimationManager)||void 0===G||G.bind(g,!!o._wasPreviouslyUsingInstances)}}this._afterBind(H,g,E)}getActiveTextures(){const o=super.getActiveTextures();for(const H in this._textures)o.push(this._textures[H]);for(const H in this._textureArrays){const n=this._textureArrays[H];for(let H=0;H<n.length;H++)o.push(n[H])}return o}hasTexture(o){if(super.hasTexture(o))return!0;for(const H in this._textures)if(this._textures[H]===o)return!0;for(const H in this._textureArrays){const n=this._textureArrays[H];for(let H=0;H<n.length;H++)if(n[H]===o)return!0}return!1}clone(o){const H=E.e.Clone((()=>new V(o,this.bo(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);H.name=o,H.id=o,"object"===typeof H._shaderPath&&(H._shaderPath={...H._shaderPath}),this._options={...this._options};const n=Object.keys(this._options);for(const E of n){const o=this._options[E];Array.isArray(o)&&(this._options[E]=o.slice(0))}this.stencil.copyTo(H.stencil);for(const E in this._textures)H.setTexture(E,this._textures[E]);for(const E in this._textureArrays)H.setTextureArray(E,this._textureArrays[E]);for(const E in this._externalTextures)H.setExternalTexture(E,this._externalTextures[E]);for(const E in this._ints)H.setInt(E,this._ints[E]);for(const E in this._uints)H.setUInt(E,this._uints[E]);for(const E in this._floats)H.setFloat(E,this._floats[E]);for(const E in this._floatsArrays)H.setFloats(E,this._floatsArrays[E]);for(const E in this._colors3)H.setColor3(E,this._colors3[E]);for(const E in this._colors3Arrays)H._colors3Arrays[E]=this._colors3Arrays[E];for(const E in this._colors4)H.setColor4(E,this._colors4[E]);for(const E in this._colors4Arrays)H._colors4Arrays[E]=this._colors4Arrays[E];for(const E in this._vectors2)H.setVector2(E,this._vectors2[E]);for(const E in this._vectors3)H.setVector3(E,this._vectors3[E]);for(const E in this._vectors4)H.setVector4(E,this._vectors4[E]);for(const E in this._quaternions)H.setQuaternion(E,this._quaternions[E]);for(const E in this._quaternionsArrays)H._quaternionsArrays[E]=this._quaternionsArrays[E];for(const E in this._matrices)H.setMatrix(E,this._matrices[E]);for(const E in this._matrixArrays)H._matrixArrays[E]=this._matrixArrays[E].slice();for(const E in this._matrices3x3)H.setMatrix3x3(E,this._matrices3x3[E]);for(const E in this._matrices2x2)H.setMatrix2x2(E,this._matrices2x2[E]);for(const E in this._vectors2Arrays)H.setArray2(E,this._vectors2Arrays[E]);for(const E in this._vectors3Arrays)H.setArray3(E,this._vectors3Arrays[E]);for(const E in this._vectors4Arrays)H.setArray4(E,this._vectors4Arrays[E]);for(const E in this._uniformBuffers)H.setUniformBuffer(E,this._uniformBuffers[E]);for(const E in this._textureSamplers)H.setTextureSampler(E,this._textureSamplers[E]);for(const E in this._storageBuffers)H.setStorageBuffer(E,this._storageBuffers[E]);return H}dispose(o,H,n){if(H){let o;for(o in this._textures)this._textures[o].dispose();for(o in this._textureArrays){const H=this._textureArrays[o];for(let o=0;o<H.length;o++)H[o].dispose()}}this._textures={},super.dispose(o,H,n)}serialize(){const o=E.e.Serialize(this);let H;for(H in o.customType="BABYLON.ShaderMaterial",o.uniqueId=this.uniqueId,o.options=this._options,o.shaderPath=this._shaderPath,o.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,o.stencil=this.stencil.serialize(),o.textures={},this._textures)o.textures[H]=this._textures[H].serialize();for(H in o.textureArrays={},this._textureArrays){o.textureArrays[H]=[];const n=this._textureArrays[H];for(let E=0;E<n.length;E++)o.textureArrays[H].push(n[E].serialize())}for(H in o.ints={},this._ints)o.ints[H]=this._ints[H];for(H in o.uints={},this._uints)o.uints[H]=this._uints[H];for(H in o.floats={},this._floats)o.floats[H]=this._floats[H];for(H in o.floatsArrays={},this._floatsArrays)o.floatsArrays[H]=this._floatsArrays[H];for(H in o.colors3={},this._colors3){const n=this._colors3[H];o.colors3[H]=[n.r,n.g,n.b]}for(H in o.colors3Arrays={},this._colors3Arrays)o.colors3Arrays[H]=this._colors3Arrays[H];for(H in o.colors4={},this._colors4){const n=this._colors4[H];o.colors4[H]=[n.r,n.g,n.b,n.a]}for(H in o.colors4Arrays={},this._colors4Arrays)o.colors4Arrays[H]=this._colors4Arrays[H];for(H in o.vectors2={},this._vectors2){const n=this._vectors2[H];o.vectors2[H]=[n.x,n.y]}for(H in o.vectors3={},this._vectors3){const n=this._vectors3[H];o.vectors3[H]=[n.x,n.y,n.z]}for(H in o.vectors4={},this._vectors4){const n=this._vectors4[H];o.vectors4[H]=[n.x,n.y,n.z,n.w]}for(H in o.quaternions={},this._quaternions)o.quaternions[H]=this._quaternions[H].bg();for(H in o.matrices={},this._matrices)o.matrices[H]=this._matrices[H].bg();for(H in o.matrixArray={},this._matrixArrays)o.matrixArray[H]=this._matrixArrays[H];for(H in o.matrices3x3={},this._matrices3x3)o.matrices3x3[H]=this._matrices3x3[H];for(H in o.matrices2x2={},this._matrices2x2)o.matrices2x2[H]=this._matrices2x2[H];for(H in o.vectors2Arrays={},this._vectors2Arrays)o.vectors2Arrays[H]=this._vectors2Arrays[H];for(H in o.vectors3Arrays={},this._vectors3Arrays)o.vectors3Arrays[H]=this._vectors3Arrays[H];for(H in o.vectors4Arrays={},this._vectors4Arrays)o.vectors4Arrays[H]=this._vectors4Arrays[H];for(H in o.quaternionsArrays={},this._quaternionsArrays)o.quaternionsArrays[H]=this._quaternionsArrays[H];return o}static Parse(o,H,n){const k=E.e.Parse((()=>new V(o.name,H,o.shaderPath,o.options,o.storeEffectOnSubMeshes)),o,H,n);let O;for(O in o.stencil&&k.stencil.parse(o.stencil,H,n),o.textures)k.setTexture(O,Y.c.Parse(o.textures[O],H,n));for(O in o.textureArrays){const E=o.textureArrays[O],g=[];for(let o=0;o<E.length;o++)g.push(Y.c.Parse(E[o],H,n));k.setTextureArray(O,g)}for(O in o.ints)k.setInt(O,o.ints[O]);for(O in o.uints)k.setUInt(O,o.uints[O]);for(O in o.floats)k.setFloat(O,o.floats[O]);for(O in o.floatsArrays)k.setFloats(O,o.floatsArrays[O]);for(O in o.colors3){const H=o.colors3[O];k.setColor3(O,{r:H[0],g:H[1],b:H[2]})}for(O in o.colors3Arrays){const H=o.colors3Arrays[O].reduce(((o,H,n)=>(n%3===0?o.push([H]):o[o.length-1].push(H),o)),[]).map((o=>({r:o[0],g:o[1],b:o[2]})));k.setColor3Array(O,H)}for(O in o.colors4){const H=o.colors4[O];k.setColor4(O,{r:H[0],g:H[1],b:H[2],a:H[3]})}for(O in o.colors4Arrays){const H=o.colors4Arrays[O].reduce(((o,H,n)=>(n%4===0?o.push([H]):o[o.length-1].push(H),o)),[]).map((o=>({r:o[0],g:o[1],b:o[2],a:o[3]})));k.setColor4Array(O,H)}for(O in o.vectors2){const H=o.vectors2[O];k.setVector2(O,{x:H[0],y:H[1]})}for(O in o.vectors3){const H=o.vectors3[O];k.setVector3(O,{x:H[0],y:H[1],z:H[2]})}for(O in o.vectors4){const H=o.vectors4[O];k.setVector4(O,{x:H[0],y:H[1],z:H[2],w:H[3]})}for(O in o.quaternions)k.setQuaternion(O,g.Quaternion.Mg(o.quaternions[O]));for(O in o.matrices)k.setMatrix(O,g.Matrix.Mg(o.matrices[O]));for(O in o.matrixArray)k._matrixArrays[O]=new Float32Array(o.matrixArray[O]);for(O in o.matrices3x3)k.setMatrix3x3(O,o.matrices3x3[O]);for(O in o.matrices2x2)k.setMatrix2x2(O,o.matrices2x2[O]);for(O in o.vectors2Arrays)k.setArray2(O,o.vectors2Arrays[O]);for(O in o.vectors3Arrays)k.setArray3(O,o.vectors3Arrays[O]);for(O in o.vectors4Arrays)k.setArray4(O,o.vectors4Arrays[O]);for(O in o.quaternionsArrays)k.setArray4(O,o.quaternionsArrays[O]);return k}static async ParseFromFileAsync(o,H,n){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((k,g)=>{const O=new G.d;O.addEventListener("readystatechange",(()=>{if(4==O.readyState)if(200==O.status){const H=JSON.parse(O.responseText),g=this.Parse(H,n||A.e.LastCreatedScene,E);o&&(g.name=o),k(g)}else g("Unable to load the ShaderMaterial")})),O.open("GET",H),O.send()}))}static async ParseFromSnippetAsync(o,H){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((E,k)=>{const g=new G.d;g.addEventListener("readystatechange",(()=>{if(4==g.readyState)if(200==g.status){const k=JSON.parse(JSON.parse(g.responseText).jsonPayload),O=JSON.parse(k.shaderMaterial),Y=this.Parse(O,H||A.e.LastCreatedScene,n);Y.snippetId=o,E(Y)}else k("Unable to load the snippet "+o)})),g.open("GET",this.SnippetUrl+"/"+o.replace(/#/g,"/")),g.send()}))}}V.SnippetUrl="https://snippet.babylonjs.com",V.CreateFromSnippetAsync=V.ParseFromSnippetAsync,(0,y.e)("BABYLON.ShaderMaterial",V)}}]);