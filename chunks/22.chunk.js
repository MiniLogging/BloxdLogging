"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[22],{11391:(g,w,q)=>{q.r(w),q.d(w,{ShaderMaterial:()=>l});var R=q(11218),o=q(11395),r=q(11180),S=q(11250),i=q(11152),T=q(11128),z=q(11462),t=q(11032),m=q(11466),e=q(11034),y=q(11506),L=q(11499);const A={effect:null,subMesh:null};class l extends m.b{constructor(g,w,q){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(g,w,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new r.Matrix,this._cachedWorldViewProjectionMatrix=new r.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=q,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","Lw","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...R}}get shaderPath(){return this._shaderPath}set shaderPath(g){this._shaderPath=g}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(g){-1===this._options.uniforms.indexOf(g)&&this._options.uniforms.push(g)}setTexture(g,w){return-1===this._options.samplers.indexOf(g)&&this._options.samplers.push(g),this._textures[g]=w,this}removeTexture(g){delete this._textures[g]}setTextureArray(g,w){return-1===this._options.samplers.indexOf(g)&&this._options.samplers.push(g),this._checkUniform(g),this._textureArrays[g]=w,this}setExternalTexture(g,w){return-1===this._options.externalTextures.indexOf(g)&&this._options.externalTextures.push(g),this._externalTextures[g]=w,this}setFloat(g,w){return this._checkUniform(g),this._floats[g]=w,this}setInt(g,w){return this._checkUniform(g),this._ints[g]=w,this}setUInt(g,w){return this._checkUniform(g),this._uints[g]=w,this}setFloats(g,w){return this._checkUniform(g),this._floatsArrays[g]=w,this}setColor3(g,w){return this._checkUniform(g),this._colors3[g]=w,this}setColor3Array(g,w){return this._checkUniform(g),this._colors3Arrays[g]=w.reduce(((g,w)=>(g.push(w.r,w.g,w.b),g)),[]),this}setColor4(g,w){return this._checkUniform(g),this._colors4[g]=w,this}setColor4Array(g,w){return this._checkUniform(g),this._colors4Arrays[g]=w.reduce(((g,w)=>(g.push(w.r,w.g,w.b,w.a),g)),[]),this}setVector2(g,w){return this._checkUniform(g),this._vectors2[g]=w,this}setVector3(g,w){return this._checkUniform(g),this._vectors3[g]=w,this}setVector4(g,w){return this._checkUniform(g),this._vectors4[g]=w,this}setQuaternion(g,w){return this._checkUniform(g),this._quaternions[g]=w,this}setQuaternionArray(g,w){return this._checkUniform(g),this._quaternionsArrays[g]=w.reduce(((g,w)=>(w.toArray(g,g.length),g)),[]),this}setMatrix(g,w){return this._checkUniform(g),this._matrices[g]=w,this}setMatrices(g,w){this._checkUniform(g);const q=new Float32Array(16*w.length);for(let R=0;R<w.length;R++){w[R].copyToArray(q,16*R)}return this._matrixArrays[g]=q,this}setMatrix3x3(g,w){return this._checkUniform(g),this._matrices3x3[g]=w,this}setMatrix2x2(g,w){return this._checkUniform(g),this._matrices2x2[g]=w,this}setArray2(g,w){return this._checkUniform(g),this._vectors2Arrays[g]=w,this}setArray3(g,w){return this._checkUniform(g),this._vectors3Arrays[g]=w,this}setArray4(g,w){return this._checkUniform(g),this._vectors4Arrays[g]=w,this}setUniformBuffer(g,w){return-1===this._options.uniformBuffers.indexOf(g)&&this._options.uniformBuffers.push(g),this._uniformBuffers[g]=w,this}setTextureSampler(g,w){return-1===this._options.samplerObjects.indexOf(g)&&this._options.samplerObjects.push(g),this._textureSamplers[g]=w,this}setStorageBuffer(g,w){return-1===this._options.storageBuffers.indexOf(g)&&this._options.storageBuffers.push(g),this._storageBuffers[g]=w,this}setDefine(g,w){const q=g.trimEnd()+" ",R=this.options.defines.findIndex((w=>w===g||w.startsWith(q)));return R>=0&&this.options.defines.splice(R,1),("boolean"!==typeof w||w)&&this.options.defines.push(q+w),this}isReadyForSubMesh(g,w,q){return this.isReady(g,q,w)}isReady(g,w,q){var R;const r=q&&this._storeEffectOnSubMeshes;if(this.isFrozen){const g=r?q._drawWrapper:this._drawWrapper;if(g.effect&&g._wasPreviouslyReady&&g._wasPreviouslyUsingInstances===w)return!0}const i=this.Ng(),T=i.getEngine(),t=[],m=[];let e=null,l=this._shaderPath,J=this._options.uniforms,x=this._options.uniformBuffers,G=this._options.samplers;T.getCaps().multiview&&i.activeCamera&&i.activeCamera.outputRenderTarget&&i.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,t.push("#define MULTIVIEW"),-1!==J.indexOf("viewProjection")&&-1===J.indexOf("viewProjectionR")&&J.push("viewProjectionR"));for(let o=0;o<this._options.defines.length;o++){const g=0===this._options.defines[o].indexOf("#define")?this._options.defines[o]:`#define ${this._options.defines[o]}`;t.push(g)}for(let o=0;o<this._options.attributes.length;o++)m.push(this._options.attributes[o]);if(g&&g.isVerticesDataPresent(S.h.ColorKind)&&(-1===m.indexOf(S.h.ColorKind)&&m.push(S.h.ColorKind),t.push("#define VERTEXCOLOR")),w&&(t.push("#define INSTANCES"),(0,L.bb)(m,this._materialHelperNeedsPreviousMatrices),null!==g&&void 0!==g&&g.hasThinInstances&&(t.push("#define THIN_INSTANCES"),g&&g.isVerticesDataPresent(S.h.ColorInstanceKind)&&(m.push(S.h.ColorInstanceKind),t.push("#define INSTANCESCOLOR")))),g&&g.useBones&&g.computeBonesUsingShaders&&g.skeleton){m.push(S.h.MatricesIndicesKind),m.push(S.h.MatricesWeightsKind),g.numBoneInfluencers>4&&(m.push(S.h.MatricesIndicesExtraKind),m.push(S.h.MatricesWeightsExtraKind));const w=g.skeleton;t.push("#define NUM_BONE_INFLUENCERS "+g.numBoneInfluencers),e=new z.e,e.addCPUSkinningFallback(0,g),w.isUsingTextureForMatrices?(t.push("#define BONETEXTURE"),-1===J.indexOf("boneTextureWidth")&&J.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(t.push("#define BonesPerMesh "+(w.bones.length+1)),-1===J.indexOf("mBones")&&J.push("mBones"))}else t.push("#define NUM_BONE_INFLUENCERS 0");let d=0;const D=g?g.morphTargetManager:null;if(D){const w=-1!==t.indexOf("#define UV1"),q=-1!==t.indexOf("#define UV2"),R=-1!==t.indexOf("#define TANGENT"),o=-1!==t.indexOf("#define NORMAL"),r=-1!==t.indexOf("#define VERTEXCOLOR");d=(0,L.G)(D,t,m,g,!0,o,R,w,q,r),D.isUsingTextureForTargets&&(-1===J.indexOf("morphTargetTextureIndices")&&J.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),d>0&&(J=J.slice(),J.push("morphTargetInfluences"),J.push("morphTargetCount"),J.push("morphTargetTextureInfo"),J.push("morphTargetTextureIndices"))}else t.push("#define NUM_MORPH_INFLUENCERS 0");if(g){const w=g.bakedVertexAnimationManager;w&&w.isEnabled&&(t.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===J.indexOf("bakedVertexAnimationSettings")&&J.push("bakedVertexAnimationSettings"),-1===J.indexOf("bakedVertexAnimationTextureSizeInverted")&&J.push("bakedVertexAnimationTextureSizeInverted"),-1===J.indexOf("bakedVertexAnimationTime")&&J.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,L.y)(m,g,t)}for(const o in this._textures)if(!this._textures[o].isReady())return!1;g&&this.needAlphaTestingForMesh(g)&&t.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,y.c)(J),(0,y.l)(this,i,t)),i.fogEnabled&&null!==g&&void 0!==g&&g.applyFog&&i.fogMode!==o.c.FOGMODE_NONE&&(t.push("#define FOG"),-1===J.indexOf("view")&&J.push("view"),-1===J.indexOf("vFogInfos")&&J.push("vFogInfos"),-1===J.indexOf("vFogColor")&&J.push("vFogColor")),this._useLogarithmicDepth&&(t.push("#define LOGARITHMICDEPTH"),-1===J.indexOf("logarithmicDepthConstant")&&J.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(J=J.slice(),x=x.slice(),G=G.slice(),l=this.customShaderNameResolve(this.name,J,x,G,t,m));const U=r?q._getDrawWrapper(void 0,!0):this._drawWrapper,N=(null===U||void 0===U?void 0:U.effect)??null,a=(null===U||void 0===U?void 0:U.defines)??null,H=t.join("\n");let C=N;return a!==H&&(C=T.createEffect(l,{attributes:m,uniformsNames:J,uniformBuffersNames:x,samplers:G,defines:H,fallbacks:e,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:d},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},T),r?q.setEffect(C,H,this._materialContext):U&&U.setEffect(C,H),this._onEffectCreatedObservable&&(A.effect=C,A.subMesh=q??(null===g||void 0===g?void 0:g.wi[0])??null,this._onEffectCreatedObservable.notifyObservers(A))),U._wasPreviouslyUsingInstances=!!w,!(null===(R=C)||void 0===R||!R.isReady())&&(N!==C&&i.resetCachedMaterial(),U._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(g,w){const q=w??this.getEffect();if(!q)return;const R=this._options.uniforms;-1!==R.indexOf("world")&&q.setMatrix("world",g);const o=this.Ng();-1!==R.indexOf("worldView")&&(g.multiplyToRef(o.getViewMatrix(),this._cachedWorldViewMatrix),q.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==R.indexOf("worldViewProjection")&&(g.multiplyToRef(o.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),q.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==R.indexOf("view")&&q.setMatrix("view",o.getViewMatrix())}bindForSubMesh(g,w,q){var R;this.bind(g,w,null===(R=q._drawWrapperOverride)||void 0===R?void 0:R.effect,q)}bind(g,w,q,R){const o=R&&this._storeEffectOnSubMeshes,r=q??(o?R.effect:this.getEffect());if(!r)return;const S=this.Ng();this._activeEffect=r,this.bindOnlyWorldMatrix(g,q);const i=this._options.uniformBuffers;let T=!1;if(r&&i&&i.length>0&&S.getEngine().supportsUniformBuffers)for(let m=0;m<i.length;++m){switch(i[m]){case"Mesh":w&&(w.getMeshUniformBuffer().bindToEffect(r,"Mesh"),w.transferToEffect(g));break;case"Scene":(0,L.r)(r,S.getSceneUniformBuffer()),S.finalizeSceneUbo(),T=!0}}const z=w&&o?this._mustRebind(S,r,R,w.visibility):S.getCachedMaterial()!==this;if(r&&z){let g;for(g in T||-1===this._options.uniforms.indexOf("view")||r.setMatrix("view",S.getViewMatrix()),T||-1===this._options.uniforms.indexOf("projection")||r.setMatrix("projection",S.getProjectionMatrix()),T||-1===this._options.uniforms.indexOf("viewProjection")||(r.setMatrix("viewProjection",S.getTransformMatrix()),this._multiview&&r.setMatrix("viewProjectionR",S._transformMatrixR)),S.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&r.setVector3("cameraPosition",S.activeCamera.globalPosition),(0,L.c)(w,r),(0,y.d)(r,this,S),this._useLogarithmicDepth&&(0,L.j)(o?R.materialDefines:r.defines,r,S),w&&(0,L.e)(S,w,r),this._textures)r.setTexture(g,this._textures[g]);for(g in this._textureArrays)r.setTextureArray(g,this._textureArrays[g]);for(g in this._ints)r.setInt(g,this._ints[g]);for(g in this._uints)r.setUInt(g,this._uints[g]);for(g in this._floats)r.setFloat(g,this._floats[g]);for(g in this._floatsArrays)r.setArray(g,this._floatsArrays[g]);for(g in this._colors3)r.setColor3(g,this._colors3[g]);for(g in this._colors3Arrays)r.setArray3(g,this._colors3Arrays[g]);for(g in this._colors4){const w=this._colors4[g];r.setFloat4(g,w.r,w.g,w.b,w.a)}for(g in this._colors4Arrays)r.setArray4(g,this._colors4Arrays[g]);for(g in this._vectors2)r.setVector2(g,this._vectors2[g]);for(g in this._vectors3)r.setVector3(g,this._vectors3[g]);for(g in this._vectors4)r.setVector4(g,this._vectors4[g]);for(g in this._quaternions)r.setQuaternion(g,this._quaternions[g]);for(g in this._matrices)r.setMatrix(g,this._matrices[g]);for(g in this._matrixArrays)r.setMatrices(g,this._matrixArrays[g]);for(g in this._matrices3x3)r.setMatrix3x3(g,this._matrices3x3[g]);for(g in this._matrices2x2)r.setMatrix2x2(g,this._matrices2x2[g]);for(g in this._vectors2Arrays)r.setArray2(g,this._vectors2Arrays[g]);for(g in this._vectors3Arrays)r.setArray3(g,this._vectors3Arrays[g]);for(g in this._vectors4Arrays)r.setArray4(g,this._vectors4Arrays[g]);for(g in this._quaternionsArrays)r.setArray4(g,this._quaternionsArrays[g]);for(g in this._uniformBuffers){const w=this._uniformBuffers[g].getBuffer();w&&r.bindUniformBuffer(w,g)}const q=S.getEngine(),i=q.setExternalTexture;if(i)for(g in this._externalTextures)i.call(q,g,this._externalTextures[g]);const z=q.setTextureSampler;if(z)for(g in this._textureSamplers)z.call(q,g,this._textureSamplers[g]);const t=q.setStorageBuffer;if(t)for(g in this._storageBuffers)t.call(q,g,this._storageBuffers[g])}if(r&&w&&(z||!this.isFrozen)){(0,L.n)(w,r),w.morphTargetManager&&w.morphTargetManager.isUsingTextureForTargets&&w.morphTargetManager._bind(r);const g=w.bakedVertexAnimationManager;if(g&&g.isEnabled){var t;const g=o?R._drawWrapper:this._drawWrapper;null===(t=w.bakedVertexAnimationManager)||void 0===t||t.bind(r,!!g._wasPreviouslyUsingInstances)}}this._afterBind(w,r,R)}getActiveTextures(){const g=super.getActiveTextures();for(const w in this._textures)g.push(this._textures[w]);for(const w in this._textureArrays){const q=this._textureArrays[w];for(let w=0;w<q.length;w++)g.push(q[w])}return g}hasTexture(g){if(super.hasTexture(g))return!0;for(const w in this._textures)if(this._textures[w]===g)return!0;for(const w in this._textureArrays){const q=this._textureArrays[w];for(let w=0;w<q.length;w++)if(q[w]===g)return!0}return!1}clone(g){const w=R.c.Clone((()=>new l(g,this.Ng(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);w.name=g,w.id=g,"object"===typeof w._shaderPath&&(w._shaderPath={...w._shaderPath}),this._options={...this._options};const q=Object.keys(this._options);for(const R of q){const g=this._options[R];Array.isArray(g)&&(this._options[R]=g.slice(0))}this.stencil.copyTo(w.stencil);for(const R in this._textures)w.setTexture(R,this._textures[R]);for(const R in this._textureArrays)w.setTextureArray(R,this._textureArrays[R]);for(const R in this._externalTextures)w.setExternalTexture(R,this._externalTextures[R]);for(const R in this._ints)w.setInt(R,this._ints[R]);for(const R in this._uints)w.setUInt(R,this._uints[R]);for(const R in this._floats)w.setFloat(R,this._floats[R]);for(const R in this._floatsArrays)w.setFloats(R,this._floatsArrays[R]);for(const R in this._colors3)w.setColor3(R,this._colors3[R]);for(const R in this._colors3Arrays)w._colors3Arrays[R]=this._colors3Arrays[R];for(const R in this._colors4)w.setColor4(R,this._colors4[R]);for(const R in this._colors4Arrays)w._colors4Arrays[R]=this._colors4Arrays[R];for(const R in this._vectors2)w.setVector2(R,this._vectors2[R]);for(const R in this._vectors3)w.setVector3(R,this._vectors3[R]);for(const R in this._vectors4)w.setVector4(R,this._vectors4[R]);for(const R in this._quaternions)w.setQuaternion(R,this._quaternions[R]);for(const R in this._quaternionsArrays)w._quaternionsArrays[R]=this._quaternionsArrays[R];for(const R in this._matrices)w.setMatrix(R,this._matrices[R]);for(const R in this._matrixArrays)w._matrixArrays[R]=this._matrixArrays[R].slice();for(const R in this._matrices3x3)w.setMatrix3x3(R,this._matrices3x3[R]);for(const R in this._matrices2x2)w.setMatrix2x2(R,this._matrices2x2[R]);for(const R in this._vectors2Arrays)w.setArray2(R,this._vectors2Arrays[R]);for(const R in this._vectors3Arrays)w.setArray3(R,this._vectors3Arrays[R]);for(const R in this._vectors4Arrays)w.setArray4(R,this._vectors4Arrays[R]);for(const R in this._uniformBuffers)w.setUniformBuffer(R,this._uniformBuffers[R]);for(const R in this._textureSamplers)w.setTextureSampler(R,this._textureSamplers[R]);for(const R in this._storageBuffers)w.setStorageBuffer(R,this._storageBuffers[R]);return w}dispose(g,w,q){if(w){let g;for(g in this._textures)this._textures[g].dispose();for(g in this._textureArrays){const w=this._textureArrays[g];for(let g=0;g<w.length;g++)w[g].dispose()}}this._textures={},super.dispose(g,w,q)}serialize(){const g=R.c.Serialize(this);let w;for(w in g.customType="BABYLON.ShaderMaterial",g.uniqueId=this.uniqueId,g.options=this._options,g.shaderPath=this._shaderPath,g.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,g.stencil=this.stencil.serialize(),g.textures={},this._textures)g.textures[w]=this._textures[w].serialize();for(w in g.textureArrays={},this._textureArrays){g.textureArrays[w]=[];const q=this._textureArrays[w];for(let R=0;R<q.length;R++)g.textureArrays[w].push(q[R].serialize())}for(w in g.ints={},this._ints)g.ints[w]=this._ints[w];for(w in g.uints={},this._uints)g.uints[w]=this._uints[w];for(w in g.floats={},this._floats)g.floats[w]=this._floats[w];for(w in g.floatsArrays={},this._floatsArrays)g.floatsArrays[w]=this._floatsArrays[w];for(w in g.colors3={},this._colors3){const q=this._colors3[w];g.colors3[w]=[q.r,q.g,q.b]}for(w in g.colors3Arrays={},this._colors3Arrays)g.colors3Arrays[w]=this._colors3Arrays[w];for(w in g.colors4={},this._colors4){const q=this._colors4[w];g.colors4[w]=[q.r,q.g,q.b,q.a]}for(w in g.colors4Arrays={},this._colors4Arrays)g.colors4Arrays[w]=this._colors4Arrays[w];for(w in g.vectors2={},this._vectors2){const q=this._vectors2[w];g.vectors2[w]=[q.x,q.y]}for(w in g.vectors3={},this._vectors3){const q=this._vectors3[w];g.vectors3[w]=[q.x,q.y,q.z]}for(w in g.vectors4={},this._vectors4){const q=this._vectors4[w];g.vectors4[w]=[q.x,q.y,q.z,q.w]}for(w in g.quaternions={},this._quaternions)g.quaternions[w]=this._quaternions[w].qi();for(w in g.matrices={},this._matrices)g.matrices[w]=this._matrices[w].qi();for(w in g.matrixArray={},this._matrixArrays)g.matrixArray[w]=this._matrixArrays[w];for(w in g.matrices3x3={},this._matrices3x3)g.matrices3x3[w]=this._matrices3x3[w];for(w in g.matrices2x2={},this._matrices2x2)g.matrices2x2[w]=this._matrices2x2[w];for(w in g.vectors2Arrays={},this._vectors2Arrays)g.vectors2Arrays[w]=this._vectors2Arrays[w];for(w in g.vectors3Arrays={},this._vectors3Arrays)g.vectors3Arrays[w]=this._vectors3Arrays[w];for(w in g.vectors4Arrays={},this._vectors4Arrays)g.vectors4Arrays[w]=this._vectors4Arrays[w];for(w in g.quaternionsArrays={},this._quaternionsArrays)g.quaternionsArrays[w]=this._quaternionsArrays[w];return g}static Parse(g,w,q){const o=R.c.Parse((()=>new l(g.name,w,g.shaderPath,g.options,g.storeEffectOnSubMeshes)),g,w,q);let S;for(S in g.stencil&&o.stencil.parse(g.stencil,w,q),g.textures)o.setTexture(S,i.e.Parse(g.textures[S],w,q));for(S in g.textureArrays){const R=g.textureArrays[S],r=[];for(let g=0;g<R.length;g++)r.push(i.e.Parse(R[g],w,q));o.setTextureArray(S,r)}for(S in g.ints)o.setInt(S,g.ints[S]);for(S in g.uints)o.setUInt(S,g.uints[S]);for(S in g.floats)o.setFloat(S,g.floats[S]);for(S in g.floatsArrays)o.setFloats(S,g.floatsArrays[S]);for(S in g.colors3){const w=g.colors3[S];o.setColor3(S,{r:w[0],g:w[1],b:w[2]})}for(S in g.colors3Arrays){const w=g.colors3Arrays[S].reduce(((g,w,q)=>(q%3===0?g.push([w]):g[g.length-1].push(w),g)),[]).map((g=>({r:g[0],g:g[1],b:g[2]})));o.setColor3Array(S,w)}for(S in g.colors4){const w=g.colors4[S];o.setColor4(S,{r:w[0],g:w[1],b:w[2],a:w[3]})}for(S in g.colors4Arrays){const w=g.colors4Arrays[S].reduce(((g,w,q)=>(q%4===0?g.push([w]):g[g.length-1].push(w),g)),[]).map((g=>({r:g[0],g:g[1],b:g[2],a:g[3]})));o.setColor4Array(S,w)}for(S in g.vectors2){const w=g.vectors2[S];o.setVector2(S,{x:w[0],y:w[1]})}for(S in g.vectors3){const w=g.vectors3[S];o.setVector3(S,{x:w[0],y:w[1],z:w[2]})}for(S in g.vectors4){const w=g.vectors4[S];o.setVector4(S,{x:w[0],y:w[1],z:w[2],w:w[3]})}for(S in g.quaternions)o.setQuaternion(S,r.Quaternion.Ri(g.quaternions[S]));for(S in g.matrices)o.setMatrix(S,r.Matrix.Ri(g.matrices[S]));for(S in g.matrixArray)o._matrixArrays[S]=new Float32Array(g.matrixArray[S]);for(S in g.matrices3x3)o.setMatrix3x3(S,g.matrices3x3[S]);for(S in g.matrices2x2)o.setMatrix2x2(S,g.matrices2x2[S]);for(S in g.vectors2Arrays)o.setArray2(S,g.vectors2Arrays[S]);for(S in g.vectors3Arrays)o.setArray3(S,g.vectors3Arrays[S]);for(S in g.vectors4Arrays)o.setArray4(S,g.vectors4Arrays[S]);for(S in g.quaternionsArrays)o.setArray4(S,g.quaternionsArrays[S]);return o}static async ParseFromFileAsync(g,w,q){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((o,r)=>{const S=new t.e;S.addEventListener("readystatechange",(()=>{if(4==S.readyState)if(200==S.status){const w=JSON.parse(S.responseText),r=this.Parse(w,q||e.c.LastCreatedScene,R);g&&(r.name=g),o(r)}else r("Unable to load the ShaderMaterial")})),S.open("GET",w),S.send()}))}static async ParseFromSnippetAsync(g,w){let q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((R,o)=>{const r=new t.e;r.addEventListener("readystatechange",(()=>{if(4==r.readyState)if(200==r.status){const o=JSON.parse(JSON.parse(r.responseText).jsonPayload),S=JSON.parse(o.shaderMaterial),i=this.Parse(S,w||e.c.LastCreatedScene,q);i.snippetId=g,R(i)}else o("Unable to load the snippet "+g)})),r.open("GET",this.SnippetUrl+"/"+g.replace(/#/g,"/")),r.send()}))}}l.SnippetUrl="https://snippet.babylonjs.com",l.CreateFromSnippetAsync=l.ParseFromSnippetAsync,(0,T.g)("BABYLON.ShaderMaterial",l)}}]);