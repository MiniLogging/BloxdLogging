"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[22],{11432:(B,I,C)=>{C.r(I),C.d(I,{ShaderMaterial:()=>S});var M=C(11226),x=C(11440),y=C(11194),f=C(11270),L=C(11171),e=C(11149),g=C(11509),N=C(11051),R=C(11513),H=C(11056),F=C(11565),k=C(11559);const q={effect:null,subMesh:null};class S extends R.c{constructor(B,I,C){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(B,I,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new y.Matrix,this._cachedWorldViewProjectionMatrix=new y.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=C,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...M}}get shaderPath(){return this._shaderPath}set shaderPath(B){this._shaderPath=B}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(B){-1===this._options.uniforms.indexOf(B)&&this._options.uniforms.push(B)}setTexture(B,I){return-1===this._options.samplers.indexOf(B)&&this._options.samplers.push(B),this._textures[B]=I,this}removeTexture(B){delete this._textures[B]}setTextureArray(B,I){return-1===this._options.samplers.indexOf(B)&&this._options.samplers.push(B),this._checkUniform(B),this._textureArrays[B]=I,this}setExternalTexture(B,I){return-1===this._options.externalTextures.indexOf(B)&&this._options.externalTextures.push(B),this._externalTextures[B]=I,this}setFloat(B,I){return this._checkUniform(B),this._floats[B]=I,this}setInt(B,I){return this._checkUniform(B),this._ints[B]=I,this}setUInt(B,I){return this._checkUniform(B),this._uints[B]=I,this}setFloats(B,I){return this._checkUniform(B),this._floatsArrays[B]=I,this}setColor3(B,I){return this._checkUniform(B),this._colors3[B]=I,this}setColor3Array(B,I){return this._checkUniform(B),this._colors3Arrays[B]=I.reduce(((B,I)=>(B.push(I.r,I.g,I.b),B)),[]),this}setColor4(B,I){return this._checkUniform(B),this._colors4[B]=I,this}setColor4Array(B,I){return this._checkUniform(B),this._colors4Arrays[B]=I.reduce(((B,I)=>(B.push(I.r,I.g,I.b,I.a),B)),[]),this}setVector2(B,I){return this._checkUniform(B),this._vectors2[B]=I,this}setVector3(B,I){return this._checkUniform(B),this._vectors3[B]=I,this}setVector4(B,I){return this._checkUniform(B),this._vectors4[B]=I,this}setQuaternion(B,I){return this._checkUniform(B),this._quaternions[B]=I,this}setQuaternionArray(B,I){return this._checkUniform(B),this._quaternionsArrays[B]=I.reduce(((B,I)=>(I.toArray(B,B.length),B)),[]),this}setMatrix(B,I){return this._checkUniform(B),this._matrices[B]=I,this}setMatrices(B,I){this._checkUniform(B);const C=new Float32Array(16*I.length);for(let M=0;M<I.length;M++){I[M].copyToArray(C,16*M)}return this._matrixArrays[B]=C,this}setMatrix3x3(B,I){return this._checkUniform(B),this._matrices3x3[B]=I,this}setMatrix2x2(B,I){return this._checkUniform(B),this._matrices2x2[B]=I,this}setArray2(B,I){return this._checkUniform(B),this._vectors2Arrays[B]=I,this}setArray3(B,I){return this._checkUniform(B),this._vectors3Arrays[B]=I,this}setArray4(B,I){return this._checkUniform(B),this._vectors4Arrays[B]=I,this}setUniformBuffer(B,I){return-1===this._options.uniformBuffers.indexOf(B)&&this._options.uniformBuffers.push(B),this._uniformBuffers[B]=I,this}setTextureSampler(B,I){return-1===this._options.samplerObjects.indexOf(B)&&this._options.samplerObjects.push(B),this._textureSamplers[B]=I,this}setStorageBuffer(B,I){return-1===this._options.storageBuffers.indexOf(B)&&this._options.storageBuffers.push(B),this._storageBuffers[B]=I,this}setDefine(B,I){const C=B.trimEnd()+" ",M=this.options.defines.findIndex((I=>I===B||I.startsWith(C)));return M>=0&&this.options.defines.splice(M,1),("boolean"!==typeof I||I)&&this.options.defines.push(C+I),this}isReadyForSubMesh(B,I,C){return this.isReady(B,C,I)}isReady(B,I,C){var M;const y=C&&this._storeEffectOnSubMeshes;if(this.isFrozen){const B=y?C._drawWrapper:this._drawWrapper;if(B.effect&&B._wasPreviouslyReady&&B._wasPreviouslyUsingInstances===I)return!0}const L=this.rB(),e=L.getEngine(),N=[],R=[];let H=null,S=this._shaderPath,o=this._options.uniforms,U=this._options.uniformBuffers,G=this._options.samplers;e.getCaps().multiview&&L.activeCamera&&L.activeCamera.outputRenderTarget&&L.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,N.push("#define MULTIVIEW"),-1!==o.indexOf("viewProjection")&&-1===o.indexOf("viewProjectionR")&&o.push("viewProjectionR"));for(let x=0;x<this._options.defines.length;x++){const B=0===this._options.defines[x].indexOf("#define")?this._options.defines[x]:`#define ${this._options.defines[x]}`;N.push(B)}for(let x=0;x<this._options.attributes.length;x++)R.push(this._options.attributes[x]);if(B&&B.isVerticesDataPresent(f.g.ColorKind)&&(-1===R.indexOf(f.g.ColorKind)&&R.push(f.g.ColorKind),N.push("#define VERTEXCOLOR")),I&&(N.push("#define INSTANCES"),(0,k.ab)(R,this._materialHelperNeedsPreviousMatrices),null!==B&&void 0!==B&&B.hasThinInstances&&(N.push("#define THIN_INSTANCES"),B&&B.isVerticesDataPresent(f.g.ColorInstanceKind)&&(R.push(f.g.ColorInstanceKind),N.push("#define INSTANCESCOLOR")))),B&&B.useBones&&B.computeBonesUsingShaders&&B.skeleton){R.push(f.g.MatricesIndicesKind),R.push(f.g.MatricesWeightsKind),B.numBoneInfluencers>4&&(R.push(f.g.MatricesIndicesExtraKind),R.push(f.g.MatricesWeightsExtraKind));const I=B.skeleton;N.push("#define NUM_BONE_INFLUENCERS "+B.numBoneInfluencers),H=new g.b,H.addCPUSkinningFallback(0,B),I.isUsingTextureForMatrices?(N.push("#define BONETEXTURE"),-1===o.indexOf("boneTextureWidth")&&o.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(N.push("#define BonesPerMesh "+(I.bones.length+1)),-1===o.indexOf("mBones")&&o.push("mBones"))}else N.push("#define NUM_BONE_INFLUENCERS 0");let V=0;const c=B?B.morphTargetManager:null;if(c){const I=-1!==N.indexOf("#define UV1"),C=-1!==N.indexOf("#define UV2"),M=-1!==N.indexOf("#define TANGENT"),x=-1!==N.indexOf("#define NORMAL"),y=-1!==N.indexOf("#define VERTEXCOLOR");V=(0,k.C)(c,N,R,B,!0,x,M,I,C,y),c.isUsingTextureForTargets&&(-1===o.indexOf("morphTargetTextureIndices")&&o.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),V>0&&(o=o.slice(),o.push("morphTargetInfluences"),o.push("morphTargetCount"),o.push("morphTargetTextureInfo"),o.push("morphTargetTextureIndices"))}else N.push("#define NUM_MORPH_INFLUENCERS 0");if(B){const I=B.bakedVertexAnimationManager;I&&I.isEnabled&&(N.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===o.indexOf("bakedVertexAnimationSettings")&&o.push("bakedVertexAnimationSettings"),-1===o.indexOf("bakedVertexAnimationTextureSizeInverted")&&o.push("bakedVertexAnimationTextureSizeInverted"),-1===o.indexOf("bakedVertexAnimationTime")&&o.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,k.r)(R,B,N)}for(const x in this._textures)if(!this._textures[x].isReady())return!1;B&&this.needAlphaTestingForMesh(B)&&N.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,F.e)(o),(0,F.l)(this,L,N)),L.fogEnabled&&null!==B&&void 0!==B&&B.applyFog&&L.fogMode!==x.b.FOGMODE_NONE&&(N.push("#define FOG"),-1===o.indexOf("view")&&o.push("view"),-1===o.indexOf("vFogInfos")&&o.push("vFogInfos"),-1===o.indexOf("vFogColor")&&o.push("vFogColor")),this._useLogarithmicDepth&&(N.push("#define LOGARITHMICDEPTH"),-1===o.indexOf("logarithmicDepthConstant")&&o.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(o=o.slice(),U=U.slice(),G=G.slice(),S=this.customShaderNameResolve(this.name,o,U,G,N,R));const t=y?C._getDrawWrapper(void 0,!0):this._drawWrapper,r=(null===t||void 0===t?void 0:t.effect)??null,A=(null===t||void 0===t?void 0:t.defines)??null,D=N.join("\n");let J=r;return A!==D&&(J=e.createEffect(S,{attributes:R,uniformsNames:o,uniformBuffersNames:U,samplers:G,defines:D,fallbacks:H,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:V},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},e),y?C.setEffect(J,D,this._materialContext):t&&t.setEffect(J,D),this._onEffectCreatedObservable&&(q.effect=J,q.subMesh=C??(null===B||void 0===B?void 0:B.cf[0])??null,this._onEffectCreatedObservable.notifyObservers(q))),t._wasPreviouslyUsingInstances=!!I,!(null===(M=J)||void 0===M||!M.isReady())&&(r!==J&&L.resetCachedMaterial(),t._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(B,I){const C=I??this.getEffect();if(!C)return;const M=this._options.uniforms;-1!==M.indexOf("world")&&C.setMatrix("world",B);const x=this.rB();-1!==M.indexOf("worldView")&&(B.multiplyToRef(x.getViewMatrix(),this._cachedWorldViewMatrix),C.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==M.indexOf("worldViewProjection")&&(B.multiplyToRef(x.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),C.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==M.indexOf("view")&&C.setMatrix("view",x.getViewMatrix())}bindForSubMesh(B,I,C){var M;this.bind(B,I,null===(M=C._drawWrapperOverride)||void 0===M?void 0:M.effect,C)}bind(B,I,C,M){const x=M&&this._storeEffectOnSubMeshes,y=C??(x?M.effect:this.getEffect());if(!y)return;const f=this.rB();this._activeEffect=y,this.bindOnlyWorldMatrix(B,C);const L=this._options.uniformBuffers;let e=!1;if(y&&L&&L.length>0&&f.getEngine().supportsUniformBuffers)for(let R=0;R<L.length;++R){switch(L[R]){case"Mesh":I&&(I.getMeshUniformBuffer().bindToEffect(y,"Mesh"),I.transferToEffect(B));break;case"Scene":(0,k.l)(y,f.getSceneUniformBuffer()),f.finalizeSceneUbo(),e=!0}}const g=I&&x?this._mustRebind(f,y,M,I.visibility):f.getCachedMaterial()!==this;if(y&&g){let B;for(B in e||-1===this._options.uniforms.indexOf("view")||y.setMatrix("view",f.getViewMatrix()),e||-1===this._options.uniforms.indexOf("projection")||y.setMatrix("projection",f.getProjectionMatrix()),e||-1===this._options.uniforms.indexOf("viewProjection")||(y.setMatrix("viewProjection",f.getTransformMatrix()),this._multiview&&y.setMatrix("viewProjectionR",f._transformMatrixR)),f.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&y.setVector3("cameraPosition",f.activeCamera.globalPosition),(0,k.d)(I,y),(0,F.f)(y,this,f),this._useLogarithmicDepth&&(0,k.h)(x?M.materialDefines:y.defines,y,f),I&&(0,k.e)(f,I,y),this._textures)y.setTexture(B,this._textures[B]);for(B in this._textureArrays)y.setTextureArray(B,this._textureArrays[B]);for(B in this._ints)y.setInt(B,this._ints[B]);for(B in this._uints)y.setUInt(B,this._uints[B]);for(B in this._floats)y.setFloat(B,this._floats[B]);for(B in this._floatsArrays)y.setArray(B,this._floatsArrays[B]);for(B in this._colors3)y.setColor3(B,this._colors3[B]);for(B in this._colors3Arrays)y.setArray3(B,this._colors3Arrays[B]);for(B in this._colors4){const I=this._colors4[B];y.setFloat4(B,I.r,I.g,I.b,I.a)}for(B in this._colors4Arrays)y.setArray4(B,this._colors4Arrays[B]);for(B in this._vectors2)y.setVector2(B,this._vectors2[B]);for(B in this._vectors3)y.setVector3(B,this._vectors3[B]);for(B in this._vectors4)y.setVector4(B,this._vectors4[B]);for(B in this._quaternions)y.setQuaternion(B,this._quaternions[B]);for(B in this._matrices)y.setMatrix(B,this._matrices[B]);for(B in this._matrixArrays)y.setMatrices(B,this._matrixArrays[B]);for(B in this._matrices3x3)y.setMatrix3x3(B,this._matrices3x3[B]);for(B in this._matrices2x2)y.setMatrix2x2(B,this._matrices2x2[B]);for(B in this._vectors2Arrays)y.setArray2(B,this._vectors2Arrays[B]);for(B in this._vectors3Arrays)y.setArray3(B,this._vectors3Arrays[B]);for(B in this._vectors4Arrays)y.setArray4(B,this._vectors4Arrays[B]);for(B in this._quaternionsArrays)y.setArray4(B,this._quaternionsArrays[B]);for(B in this._uniformBuffers){const I=this._uniformBuffers[B].getBuffer();I&&y.bindUniformBuffer(I,B)}const C=f.getEngine(),L=C.setExternalTexture;if(L)for(B in this._externalTextures)L.call(C,B,this._externalTextures[B]);const g=C.setTextureSampler;if(g)for(B in this._textureSamplers)g.call(C,B,this._textureSamplers[B]);const N=C.setStorageBuffer;if(N)for(B in this._storageBuffers)N.call(C,B,this._storageBuffers[B])}if(y&&I&&(g||!this.isFrozen)){(0,k.i)(I,y),I.morphTargetManager&&I.morphTargetManager.isUsingTextureForTargets&&I.morphTargetManager._bind(y);const B=I.bakedVertexAnimationManager;if(B&&B.isEnabled){var N;const B=x?M._drawWrapper:this._drawWrapper;null===(N=I.bakedVertexAnimationManager)||void 0===N||N.bind(y,!!B._wasPreviouslyUsingInstances)}}this._afterBind(I,y,M)}getActiveTextures(){const B=super.getActiveTextures();for(const I in this._textures)B.push(this._textures[I]);for(const I in this._textureArrays){const C=this._textureArrays[I];for(let I=0;I<C.length;I++)B.push(C[I])}return B}hasTexture(B){if(super.hasTexture(B))return!0;for(const I in this._textures)if(this._textures[I]===B)return!0;for(const I in this._textureArrays){const C=this._textureArrays[I];for(let I=0;I<C.length;I++)if(C[I]===B)return!0}return!1}clone(B){const I=M.d.Clone((()=>new S(B,this.rB(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);I.name=B,I.id=B,"object"===typeof I._shaderPath&&(I._shaderPath={...I._shaderPath}),this._options={...this._options};const C=Object.keys(this._options);for(const M of C){const B=this._options[M];Array.isArray(B)&&(this._options[M]=B.slice(0))}this.stencil.copyTo(I.stencil);for(const M in this._textures)I.setTexture(M,this._textures[M]);for(const M in this._textureArrays)I.setTextureArray(M,this._textureArrays[M]);for(const M in this._externalTextures)I.setExternalTexture(M,this._externalTextures[M]);for(const M in this._ints)I.setInt(M,this._ints[M]);for(const M in this._uints)I.setUInt(M,this._uints[M]);for(const M in this._floats)I.setFloat(M,this._floats[M]);for(const M in this._floatsArrays)I.setFloats(M,this._floatsArrays[M]);for(const M in this._colors3)I.setColor3(M,this._colors3[M]);for(const M in this._colors3Arrays)I._colors3Arrays[M]=this._colors3Arrays[M];for(const M in this._colors4)I.setColor4(M,this._colors4[M]);for(const M in this._colors4Arrays)I._colors4Arrays[M]=this._colors4Arrays[M];for(const M in this._vectors2)I.setVector2(M,this._vectors2[M]);for(const M in this._vectors3)I.setVector3(M,this._vectors3[M]);for(const M in this._vectors4)I.setVector4(M,this._vectors4[M]);for(const M in this._quaternions)I.setQuaternion(M,this._quaternions[M]);for(const M in this._quaternionsArrays)I._quaternionsArrays[M]=this._quaternionsArrays[M];for(const M in this._matrices)I.setMatrix(M,this._matrices[M]);for(const M in this._matrixArrays)I._matrixArrays[M]=this._matrixArrays[M].slice();for(const M in this._matrices3x3)I.setMatrix3x3(M,this._matrices3x3[M]);for(const M in this._matrices2x2)I.setMatrix2x2(M,this._matrices2x2[M]);for(const M in this._vectors2Arrays)I.setArray2(M,this._vectors2Arrays[M]);for(const M in this._vectors3Arrays)I.setArray3(M,this._vectors3Arrays[M]);for(const M in this._vectors4Arrays)I.setArray4(M,this._vectors4Arrays[M]);for(const M in this._uniformBuffers)I.setUniformBuffer(M,this._uniformBuffers[M]);for(const M in this._textureSamplers)I.setTextureSampler(M,this._textureSamplers[M]);for(const M in this._storageBuffers)I.setStorageBuffer(M,this._storageBuffers[M]);return I}dispose(B,I,C){if(I){let B;for(B in this._textures)this._textures[B].dispose();for(B in this._textureArrays){const I=this._textureArrays[B];for(let B=0;B<I.length;B++)I[B].dispose()}}this._textures={},super.dispose(B,I,C)}serialize(){const B=M.d.Serialize(this);let I;for(I in B.customType="BABYLON.ShaderMaterial",B.uniqueId=this.uniqueId,B.options=this._options,B.shaderPath=this._shaderPath,B.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,B.stencil=this.stencil.serialize(),B.textures={},this._textures)B.textures[I]=this._textures[I].serialize();for(I in B.textureArrays={},this._textureArrays){B.textureArrays[I]=[];const C=this._textureArrays[I];for(let M=0;M<C.length;M++)B.textureArrays[I].push(C[M].serialize())}for(I in B.ints={},this._ints)B.ints[I]=this._ints[I];for(I in B.uints={},this._uints)B.uints[I]=this._uints[I];for(I in B.floats={},this._floats)B.floats[I]=this._floats[I];for(I in B.floatsArrays={},this._floatsArrays)B.floatsArrays[I]=this._floatsArrays[I];for(I in B.colors3={},this._colors3){const C=this._colors3[I];B.colors3[I]=[C.r,C.g,C.b]}for(I in B.colors3Arrays={},this._colors3Arrays)B.colors3Arrays[I]=this._colors3Arrays[I];for(I in B.colors4={},this._colors4){const C=this._colors4[I];B.colors4[I]=[C.r,C.g,C.b,C.a]}for(I in B.colors4Arrays={},this._colors4Arrays)B.colors4Arrays[I]=this._colors4Arrays[I];for(I in B.vectors2={},this._vectors2){const C=this._vectors2[I];B.vectors2[I]=[C.x,C.y]}for(I in B.vectors3={},this._vectors3){const C=this._vectors3[I];B.vectors3[I]=[C.x,C.y,C.z]}for(I in B.vectors4={},this._vectors4){const C=this._vectors4[I];B.vectors4[I]=[C.x,C.y,C.z,C.w]}for(I in B.quaternions={},this._quaternions)B.quaternions[I]=this._quaternions[I].Df();for(I in B.matrices={},this._matrices)B.matrices[I]=this._matrices[I].Df();for(I in B.matrixArray={},this._matrixArrays)B.matrixArray[I]=this._matrixArrays[I];for(I in B.matrices3x3={},this._matrices3x3)B.matrices3x3[I]=this._matrices3x3[I];for(I in B.matrices2x2={},this._matrices2x2)B.matrices2x2[I]=this._matrices2x2[I];for(I in B.vectors2Arrays={},this._vectors2Arrays)B.vectors2Arrays[I]=this._vectors2Arrays[I];for(I in B.vectors3Arrays={},this._vectors3Arrays)B.vectors3Arrays[I]=this._vectors3Arrays[I];for(I in B.vectors4Arrays={},this._vectors4Arrays)B.vectors4Arrays[I]=this._vectors4Arrays[I];for(I in B.quaternionsArrays={},this._quaternionsArrays)B.quaternionsArrays[I]=this._quaternionsArrays[I];return B}static Parse(B,I,C){const x=M.d.Parse((()=>new S(B.name,I,B.shaderPath,B.options,B.storeEffectOnSubMeshes)),B,I,C);let f;for(f in B.stencil&&x.stencil.parse(B.stencil,I,C),B.textures)x.setTexture(f,L.c.Parse(B.textures[f],I,C));for(f in B.textureArrays){const M=B.textureArrays[f],y=[];for(let B=0;B<M.length;B++)y.push(L.c.Parse(M[B],I,C));x.setTextureArray(f,y)}for(f in B.ints)x.setInt(f,B.ints[f]);for(f in B.uints)x.setUInt(f,B.uints[f]);for(f in B.floats)x.setFloat(f,B.floats[f]);for(f in B.floatsArrays)x.setFloats(f,B.floatsArrays[f]);for(f in B.colors3){const I=B.colors3[f];x.setColor3(f,{r:I[0],g:I[1],b:I[2]})}for(f in B.colors3Arrays){const I=B.colors3Arrays[f].reduce(((B,I,C)=>(C%3===0?B.push([I]):B[B.length-1].push(I),B)),[]).map((B=>({r:B[0],g:B[1],b:B[2]})));x.setColor3Array(f,I)}for(f in B.colors4){const I=B.colors4[f];x.setColor4(f,{r:I[0],g:I[1],b:I[2],a:I[3]})}for(f in B.colors4Arrays){const I=B.colors4Arrays[f].reduce(((B,I,C)=>(C%4===0?B.push([I]):B[B.length-1].push(I),B)),[]).map((B=>({r:B[0],g:B[1],b:B[2],a:B[3]})));x.setColor4Array(f,I)}for(f in B.vectors2){const I=B.vectors2[f];x.setVector2(f,{x:I[0],y:I[1]})}for(f in B.vectors3){const I=B.vectors3[f];x.setVector3(f,{x:I[0],y:I[1],z:I[2]})}for(f in B.vectors4){const I=B.vectors4[f];x.setVector4(f,{x:I[0],y:I[1],z:I[2],w:I[3]})}for(f in B.quaternions)x.setQuaternion(f,y.Quaternion.oI(B.quaternions[f]));for(f in B.matrices)x.setMatrix(f,y.Matrix.oI(B.matrices[f]));for(f in B.matrixArray)x._matrixArrays[f]=new Float32Array(B.matrixArray[f]);for(f in B.matrices3x3)x.setMatrix3x3(f,B.matrices3x3[f]);for(f in B.matrices2x2)x.setMatrix2x2(f,B.matrices2x2[f]);for(f in B.vectors2Arrays)x.setArray2(f,B.vectors2Arrays[f]);for(f in B.vectors3Arrays)x.setArray3(f,B.vectors3Arrays[f]);for(f in B.vectors4Arrays)x.setArray4(f,B.vectors4Arrays[f]);for(f in B.quaternionsArrays)x.setArray4(f,B.quaternionsArrays[f]);return x}static async ParseFromFileAsync(B,I,C){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((x,y)=>{const f=new N.c;f.addEventListener("readystatechange",(()=>{if(4==f.readyState)if(200==f.status){const I=JSON.parse(f.responseText),y=this.Parse(I,C||H.c.LastCreatedScene,M);B&&(y.name=B),x(y)}else y("Unable to load the ShaderMaterial")})),f.open("GET",I),f.send()}))}static async ParseFromSnippetAsync(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((M,x)=>{const y=new N.c;y.addEventListener("readystatechange",(()=>{if(4==y.readyState)if(200==y.status){const x=JSON.parse(JSON.parse(y.responseText).jsonPayload),f=JSON.parse(x.shaderMaterial),L=this.Parse(f,I||H.c.LastCreatedScene,C);L.snippetId=B,M(L)}else x("Unable to load the snippet "+B)})),y.open("GET",this.SnippetUrl+"/"+B.replace(/#/g,"/")),y.send()}))}}S.SnippetUrl="https://snippet.babylonjs.com",S.CreateFromSnippetAsync=S.ParseFromSnippetAsync,(0,e.h)("BABYLON.ShaderMaterial",S)}}]);