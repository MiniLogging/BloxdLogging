"use strict";(self["686i8587bmi"]=self["686i8587bmi"]||[]).push([[22],{12982:(h,d,T)=>{T.r(d),T.d(d,{ShaderMaterial:()=>J});var Y=T(12801),y=T(12990),C=T(12765),n=T(12835),X=T(12741),F=T(12714),U=T(13081),Z=T(12623),S=T(13084),r=T(12625),c=T(13132),O=T(13124);const f={effect:null,subMesh:null};class J extends S.e{constructor(h,d,T){let Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(h,d,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new C.Matrix,this._cachedWorldViewProjectionMatrix=new C.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=T,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...Y}}get shaderPath(){return this._shaderPath}set shaderPath(h){this._shaderPath=h}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(h){-1===this._options.uniforms.indexOf(h)&&this._options.uniforms.push(h)}setTexture(h,d){return-1===this._options.samplers.indexOf(h)&&this._options.samplers.push(h),this._textures[h]=d,this}removeTexture(h){delete this._textures[h]}setTextureArray(h,d){return-1===this._options.samplers.indexOf(h)&&this._options.samplers.push(h),this._checkUniform(h),this._textureArrays[h]=d,this}setExternalTexture(h,d){return-1===this._options.externalTextures.indexOf(h)&&this._options.externalTextures.push(h),this._externalTextures[h]=d,this}setFloat(h,d){return this._checkUniform(h),this._floats[h]=d,this}setInt(h,d){return this._checkUniform(h),this._ints[h]=d,this}setUInt(h,d){return this._checkUniform(h),this._uints[h]=d,this}setFloats(h,d){return this._checkUniform(h),this._floatsArrays[h]=d,this}setColor3(h,d){return this._checkUniform(h),this._colors3[h]=d,this}setColor3Array(h,d){return this._checkUniform(h),this._colors3Arrays[h]=d.reduce(((h,d)=>(h.push(d.r,d.g,d.b),h)),[]),this}setColor4(h,d){return this._checkUniform(h),this._colors4[h]=d,this}setColor4Array(h,d){return this._checkUniform(h),this._colors4Arrays[h]=d.reduce(((h,d)=>(h.push(d.r,d.g,d.b,d.a),h)),[]),this}setVector2(h,d){return this._checkUniform(h),this._vectors2[h]=d,this}setVector3(h,d){return this._checkUniform(h),this._vectors3[h]=d,this}setVector4(h,d){return this._checkUniform(h),this._vectors4[h]=d,this}setQuaternion(h,d){return this._checkUniform(h),this._quaternions[h]=d,this}setQuaternionArray(h,d){return this._checkUniform(h),this._quaternionsArrays[h]=d.reduce(((h,d)=>(d.toArray(h,h.length),h)),[]),this}setMatrix(h,d){return this._checkUniform(h),this._matrices[h]=d,this}setMatrices(h,d){this._checkUniform(h);const T=new Float32Array(16*d.length);for(let Y=0;Y<d.length;Y++){d[Y].copyToArray(T,16*Y)}return this._matrixArrays[h]=T,this}setMatrix3x3(h,d){return this._checkUniform(h),this._matrices3x3[h]=d,this}setMatrix2x2(h,d){return this._checkUniform(h),this._matrices2x2[h]=d,this}setArray2(h,d){return this._checkUniform(h),this._vectors2Arrays[h]=d,this}setArray3(h,d){return this._checkUniform(h),this._vectors3Arrays[h]=d,this}setArray4(h,d){return this._checkUniform(h),this._vectors4Arrays[h]=d,this}setUniformBuffer(h,d){return-1===this._options.uniformBuffers.indexOf(h)&&this._options.uniformBuffers.push(h),this._uniformBuffers[h]=d,this}setTextureSampler(h,d){return-1===this._options.samplerObjects.indexOf(h)&&this._options.samplerObjects.push(h),this._textureSamplers[h]=d,this}setStorageBuffer(h,d){return-1===this._options.storageBuffers.indexOf(h)&&this._options.storageBuffers.push(h),this._storageBuffers[h]=d,this}setDefine(h,d){const T=h.trimEnd()+" ",Y=this.options.defines.findIndex((d=>d===h||d.startsWith(T)));return Y>=0&&this.options.defines.splice(Y,1),("boolean"!==typeof d||d)&&this.options.defines.push(T+d),this}isReadyForSubMesh(h,d,T){return this.isReady(h,T,d)}isReady(h,d,T){var Y;const C=T&&this._storeEffectOnSubMeshes;if(this.isFrozen){const h=C?T._drawWrapper:this._drawWrapper;if(h.effect&&h._wasPreviouslyReady&&h._wasPreviouslyUsingInstances===d)return!0}const X=this.Eh(),F=X.getEngine(),Z=[],S=[];let r=null,J=this._shaderPath,W=this._options.uniforms,L=this._options.uniformBuffers,D=this._options.samplers;F.getCaps().multiview&&X.activeCamera&&X.activeCamera.outputRenderTarget&&X.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,Z.push("#define MULTIVIEW"),-1!==W.indexOf("viewProjection")&&-1===W.indexOf("viewProjectionR")&&W.push("viewProjectionR"));for(let y=0;y<this._options.defines.length;y++){const h=0===this._options.defines[y].indexOf("#define")?this._options.defines[y]:`#define ${this._options.defines[y]}`;Z.push(h)}for(let y=0;y<this._options.attributes.length;y++)S.push(this._options.attributes[y]);if(h&&h.isVerticesDataPresent(n.g.ColorKind)&&(-1===S.indexOf(n.g.ColorKind)&&S.push(n.g.ColorKind),Z.push("#define VERTEXCOLOR")),d&&(Z.push("#define INSTANCES"),(0,O.db)(S,this._materialHelperNeedsPreviousMatrices),null!==h&&void 0!==h&&h.hasThinInstances&&(Z.push("#define THIN_INSTANCES"),h&&h.isVerticesDataPresent(n.g.ColorInstanceKind)&&(S.push(n.g.ColorInstanceKind),Z.push("#define INSTANCESCOLOR")))),h&&h.useBones&&h.computeBonesUsingShaders&&h.skeleton){S.push(n.g.MatricesIndicesKind),S.push(n.g.MatricesWeightsKind),h.numBoneInfluencers>4&&(S.push(n.g.MatricesIndicesExtraKind),S.push(n.g.MatricesWeightsExtraKind));const d=h.skeleton;Z.push("#define NUM_BONE_INFLUENCERS "+h.numBoneInfluencers),r=new U.b,r.addCPUSkinningFallback(0,h),d.isUsingTextureForMatrices?(Z.push("#define BONETEXTURE"),-1===W.indexOf("boneTextureWidth")&&W.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(Z.push("#define BonesPerMesh "+(d.bones.length+1)),-1===W.indexOf("mBones")&&W.push("mBones"))}else Z.push("#define NUM_BONE_INFLUENCERS 0");let V=0;const i=h?h.morphTargetManager:null;if(i){const d=-1!==Z.indexOf("#define UV1"),T=-1!==Z.indexOf("#define UV2"),Y=-1!==Z.indexOf("#define TANGENT"),y=-1!==Z.indexOf("#define NORMAL"),C=-1!==Z.indexOf("#define VERTEXCOLOR");V=(0,O.E)(i,Z,S,h,!0,y,Y,d,T,C),i.isUsingTextureForTargets&&(-1===W.indexOf("morphTargetTextureIndices")&&W.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),V>0&&(W=W.slice(),W.push("morphTargetInfluences"),W.push("morphTargetCount"),W.push("morphTargetTextureInfo"),W.push("morphTargetTextureIndices"))}else Z.push("#define NUM_MORPH_INFLUENCERS 0");if(h){const d=h.bakedVertexAnimationManager;d&&d.isEnabled&&(Z.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===W.indexOf("bakedVertexAnimationSettings")&&W.push("bakedVertexAnimationSettings"),-1===W.indexOf("bakedVertexAnimationTextureSizeInverted")&&W.push("bakedVertexAnimationTextureSizeInverted"),-1===W.indexOf("bakedVertexAnimationTime")&&W.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,O.s)(S,h,Z)}for(const y in this._textures)if(!this._textures[y].isReady())return!1;h&&this.needAlphaTestingForMesh(h)&&Z.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,c.d)(W),(0,c.h)(this,X,Z)),X.fogEnabled&&null!==h&&void 0!==h&&h.applyFog&&X.fogMode!==y.d.FOGMODE_NONE&&(Z.push("#define FOG"),-1===W.indexOf("view")&&W.push("view"),-1===W.indexOf("vFogInfos")&&W.push("vFogInfos"),-1===W.indexOf("vFogColor")&&W.push("vFogColor")),this._useLogarithmicDepth&&(Z.push("#define LOGARITHMICDEPTH"),-1===W.indexOf("logarithmicDepthConstant")&&W.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(W=W.slice(),L=L.slice(),D=D.slice(),J=this.customShaderNameResolve(this.name,W,L,D,Z,S));const w=C?T._getDrawWrapper(void 0,!0):this._drawWrapper,s=(null===w||void 0===w?void 0:w.effect)??null,E=(null===w||void 0===w?void 0:w.defines)??null,z=Z.join("\n");let x=s;return E!==z&&(x=F.createEffect(J,{attributes:S,uniformsNames:W,uniformBuffersNames:L,samplers:D,defines:z,fallbacks:r,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:V},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},F),C?T.setEffect(x,z,this._materialContext):w&&w.setEffect(x,z),this._onEffectCreatedObservable&&(f.effect=x,f.subMesh=T??(null===h||void 0===h?void 0:h.ld[0])??null,this._onEffectCreatedObservable.notifyObservers(f))),w._wasPreviouslyUsingInstances=!!d,!(null===(Y=x)||void 0===Y||!Y.isReady())&&(s!==x&&X.resetCachedMaterial(),w._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(h,d){const T=d??this.getEffect();if(!T)return;const Y=this._options.uniforms;-1!==Y.indexOf("world")&&T.setMatrix("world",h);const y=this.Eh();-1!==Y.indexOf("worldView")&&(h.multiplyToRef(y.getViewMatrix(),this._cachedWorldViewMatrix),T.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==Y.indexOf("worldViewProjection")&&(h.multiplyToRef(y.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),T.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==Y.indexOf("view")&&T.setMatrix("view",y.getViewMatrix())}bindForSubMesh(h,d,T){var Y;this.bind(h,d,null===(Y=T._drawWrapperOverride)||void 0===Y?void 0:Y.effect,T)}bind(h,d,T,Y){const y=Y&&this._storeEffectOnSubMeshes,C=T??(y?Y.effect:this.getEffect());if(!C)return;const n=this.Eh();this._activeEffect=C,this.bindOnlyWorldMatrix(h,T);const X=this._options.uniformBuffers;let F=!1;if(C&&X&&X.length>0&&n.getEngine().supportsUniformBuffers)for(let S=0;S<X.length;++S){switch(X[S]){case"Mesh":d&&(d.getMeshUniformBuffer().bindToEffect(C,"Mesh"),d.transferToEffect(h));break;case"Scene":(0,O.l)(C,n.getSceneUniformBuffer()),n.finalizeSceneUbo(),F=!0}}const U=d&&y?this._mustRebind(n,C,Y,d.visibility):n.getCachedMaterial()!==this;if(C&&U){let h;for(h in F||-1===this._options.uniforms.indexOf("view")||C.setMatrix("view",n.getViewMatrix()),F||-1===this._options.uniforms.indexOf("projection")||C.setMatrix("projection",n.getProjectionMatrix()),F||-1===this._options.uniforms.indexOf("viewProjection")||(C.setMatrix("viewProjection",n.getTransformMatrix()),this._multiview&&C.setMatrix("viewProjectionR",n._transformMatrixR)),n.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&C.setVector3("cameraPosition",n.activeCamera.globalPosition),(0,O.c)(d,C),(0,c.e)(C,this,n),this._useLogarithmicDepth&&(0,O.i)(y?Y.materialDefines:C.defines,C,n),d&&(0,O.e)(n,d,C),this._textures)C.setTexture(h,this._textures[h]);for(h in this._textureArrays)C.setTextureArray(h,this._textureArrays[h]);for(h in this._ints)C.setInt(h,this._ints[h]);for(h in this._uints)C.setUInt(h,this._uints[h]);for(h in this._floats)C.setFloat(h,this._floats[h]);for(h in this._floatsArrays)C.setArray(h,this._floatsArrays[h]);for(h in this._colors3)C.setColor3(h,this._colors3[h]);for(h in this._colors3Arrays)C.setArray3(h,this._colors3Arrays[h]);for(h in this._colors4){const d=this._colors4[h];C.setFloat4(h,d.r,d.g,d.b,d.a)}for(h in this._colors4Arrays)C.setArray4(h,this._colors4Arrays[h]);for(h in this._vectors2)C.setVector2(h,this._vectors2[h]);for(h in this._vectors3)C.setVector3(h,this._vectors3[h]);for(h in this._vectors4)C.setVector4(h,this._vectors4[h]);for(h in this._quaternions)C.setQuaternion(h,this._quaternions[h]);for(h in this._matrices)C.setMatrix(h,this._matrices[h]);for(h in this._matrixArrays)C.setMatrices(h,this._matrixArrays[h]);for(h in this._matrices3x3)C.setMatrix3x3(h,this._matrices3x3[h]);for(h in this._matrices2x2)C.setMatrix2x2(h,this._matrices2x2[h]);for(h in this._vectors2Arrays)C.setArray2(h,this._vectors2Arrays[h]);for(h in this._vectors3Arrays)C.setArray3(h,this._vectors3Arrays[h]);for(h in this._vectors4Arrays)C.setArray4(h,this._vectors4Arrays[h]);for(h in this._quaternionsArrays)C.setArray4(h,this._quaternionsArrays[h]);for(h in this._uniformBuffers){const d=this._uniformBuffers[h].getBuffer();d&&C.bindUniformBuffer(d,h)}const T=n.getEngine(),X=T.setExternalTexture;if(X)for(h in this._externalTextures)X.call(T,h,this._externalTextures[h]);const U=T.setTextureSampler;if(U)for(h in this._textureSamplers)U.call(T,h,this._textureSamplers[h]);const Z=T.setStorageBuffer;if(Z)for(h in this._storageBuffers)Z.call(T,h,this._storageBuffers[h])}if(C&&d&&(U||!this.isFrozen)){(0,O.k)(d,C),d.morphTargetManager&&d.morphTargetManager.isUsingTextureForTargets&&d.morphTargetManager._bind(C);const h=d.bakedVertexAnimationManager;if(h&&h.isEnabled){var Z;const h=y?Y._drawWrapper:this._drawWrapper;null===(Z=d.bakedVertexAnimationManager)||void 0===Z||Z.bind(C,!!h._wasPreviouslyUsingInstances)}}this._afterBind(d,C,Y)}getActiveTextures(){const h=super.getActiveTextures();for(const d in this._textures)h.push(this._textures[d]);for(const d in this._textureArrays){const T=this._textureArrays[d];for(let d=0;d<T.length;d++)h.push(T[d])}return h}hasTexture(h){if(super.hasTexture(h))return!0;for(const d in this._textures)if(this._textures[d]===h)return!0;for(const d in this._textureArrays){const T=this._textureArrays[d];for(let d=0;d<T.length;d++)if(T[d]===h)return!0}return!1}clone(h){const d=Y.e.Clone((()=>new J(h,this.Eh(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);d.name=h,d.id=h,"object"===typeof d._shaderPath&&(d._shaderPath={...d._shaderPath}),this._options={...this._options};const T=Object.keys(this._options);for(const Y of T){const h=this._options[Y];Array.isArray(h)&&(this._options[Y]=h.slice(0))}this.xd.copyTo(d.xd);for(const Y in this._textures)d.setTexture(Y,this._textures[Y]);for(const Y in this._textureArrays)d.setTextureArray(Y,this._textureArrays[Y]);for(const Y in this._externalTextures)d.setExternalTexture(Y,this._externalTextures[Y]);for(const Y in this._ints)d.setInt(Y,this._ints[Y]);for(const Y in this._uints)d.setUInt(Y,this._uints[Y]);for(const Y in this._floats)d.setFloat(Y,this._floats[Y]);for(const Y in this._floatsArrays)d.setFloats(Y,this._floatsArrays[Y]);for(const Y in this._colors3)d.setColor3(Y,this._colors3[Y]);for(const Y in this._colors3Arrays)d._colors3Arrays[Y]=this._colors3Arrays[Y];for(const Y in this._colors4)d.setColor4(Y,this._colors4[Y]);for(const Y in this._colors4Arrays)d._colors4Arrays[Y]=this._colors4Arrays[Y];for(const Y in this._vectors2)d.setVector2(Y,this._vectors2[Y]);for(const Y in this._vectors3)d.setVector3(Y,this._vectors3[Y]);for(const Y in this._vectors4)d.setVector4(Y,this._vectors4[Y]);for(const Y in this._quaternions)d.setQuaternion(Y,this._quaternions[Y]);for(const Y in this._quaternionsArrays)d._quaternionsArrays[Y]=this._quaternionsArrays[Y];for(const Y in this._matrices)d.setMatrix(Y,this._matrices[Y]);for(const Y in this._matrixArrays)d._matrixArrays[Y]=this._matrixArrays[Y].slice();for(const Y in this._matrices3x3)d.setMatrix3x3(Y,this._matrices3x3[Y]);for(const Y in this._matrices2x2)d.setMatrix2x2(Y,this._matrices2x2[Y]);for(const Y in this._vectors2Arrays)d.setArray2(Y,this._vectors2Arrays[Y]);for(const Y in this._vectors3Arrays)d.setArray3(Y,this._vectors3Arrays[Y]);for(const Y in this._vectors4Arrays)d.setArray4(Y,this._vectors4Arrays[Y]);for(const Y in this._uniformBuffers)d.setUniformBuffer(Y,this._uniformBuffers[Y]);for(const Y in this._textureSamplers)d.setTextureSampler(Y,this._textureSamplers[Y]);for(const Y in this._storageBuffers)d.setStorageBuffer(Y,this._storageBuffers[Y]);return d}dispose(h,d,T){if(d){let h;for(h in this._textures)this._textures[h].dispose();for(h in this._textureArrays){const d=this._textureArrays[h];for(let h=0;h<d.length;h++)d[h].dispose()}}this._textures={},super.dispose(h,d,T)}serialize(){const h=Y.e.Serialize(this);let d;for(d in h.customType="BABYLON.ShaderMaterial",h.uniqueId=this.uniqueId,h.options=this._options,h.shaderPath=this._shaderPath,h.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,h.xd=this.xd.serialize(),h.textures={},this._textures)h.textures[d]=this._textures[d].serialize();for(d in h.textureArrays={},this._textureArrays){h.textureArrays[d]=[];const T=this._textureArrays[d];for(let Y=0;Y<T.length;Y++)h.textureArrays[d].push(T[Y].serialize())}for(d in h.ints={},this._ints)h.ints[d]=this._ints[d];for(d in h.uints={},this._uints)h.uints[d]=this._uints[d];for(d in h.floats={},this._floats)h.floats[d]=this._floats[d];for(d in h.floatsArrays={},this._floatsArrays)h.floatsArrays[d]=this._floatsArrays[d];for(d in h.colors3={},this._colors3){const T=this._colors3[d];h.colors3[d]=[T.r,T.g,T.b]}for(d in h.colors3Arrays={},this._colors3Arrays)h.colors3Arrays[d]=this._colors3Arrays[d];for(d in h.colors4={},this._colors4){const T=this._colors4[d];h.colors4[d]=[T.r,T.g,T.b,T.a]}for(d in h.colors4Arrays={},this._colors4Arrays)h.colors4Arrays[d]=this._colors4Arrays[d];for(d in h.vectors2={},this._vectors2){const T=this._vectors2[d];h.vectors2[d]=[T.x,T.y]}for(d in h.vectors3={},this._vectors3){const T=this._vectors3[d];h.vectors3[d]=[T.x,T.y,T.z]}for(d in h.vectors4={},this._vectors4){const T=this._vectors4[d];h.vectors4[d]=[T.x,T.y,T.z,T.w]}for(d in h.quaternions={},this._quaternions)h.quaternions[d]=this._quaternions[d].ad();for(d in h.matrices={},this._matrices)h.matrices[d]=this._matrices[d].ad();for(d in h.matrixArray={},this._matrixArrays)h.matrixArray[d]=this._matrixArrays[d];for(d in h.matrices3x3={},this._matrices3x3)h.matrices3x3[d]=this._matrices3x3[d];for(d in h.matrices2x2={},this._matrices2x2)h.matrices2x2[d]=this._matrices2x2[d];for(d in h.vectors2Arrays={},this._vectors2Arrays)h.vectors2Arrays[d]=this._vectors2Arrays[d];for(d in h.vectors3Arrays={},this._vectors3Arrays)h.vectors3Arrays[d]=this._vectors3Arrays[d];for(d in h.vectors4Arrays={},this._vectors4Arrays)h.vectors4Arrays[d]=this._vectors4Arrays[d];for(d in h.quaternionsArrays={},this._quaternionsArrays)h.quaternionsArrays[d]=this._quaternionsArrays[d];return h}static Parse(h,d,T){const y=Y.e.Parse((()=>new J(h.name,d,h.shaderPath,h.options,h.storeEffectOnSubMeshes)),h,d,T);let n;for(n in h.xd&&y.xd.parse(h.xd,d,T),h.textures)y.setTexture(n,X.c.Parse(h.textures[n],d,T));for(n in h.textureArrays){const Y=h.textureArrays[n],C=[];for(let h=0;h<Y.length;h++)C.push(X.c.Parse(Y[h],d,T));y.setTextureArray(n,C)}for(n in h.ints)y.setInt(n,h.ints[n]);for(n in h.uints)y.setUInt(n,h.uints[n]);for(n in h.floats)y.setFloat(n,h.floats[n]);for(n in h.floatsArrays)y.setFloats(n,h.floatsArrays[n]);for(n in h.colors3){const d=h.colors3[n];y.setColor3(n,{r:d[0],g:d[1],b:d[2]})}for(n in h.colors3Arrays){const d=h.colors3Arrays[n].reduce(((h,d,T)=>(T%3===0?h.push([d]):h[h.length-1].push(d),h)),[]).map((h=>({r:h[0],g:h[1],b:h[2]})));y.setColor3Array(n,d)}for(n in h.colors4){const d=h.colors4[n];y.setColor4(n,{r:d[0],g:d[1],b:d[2],a:d[3]})}for(n in h.colors4Arrays){const d=h.colors4Arrays[n].reduce(((h,d,T)=>(T%4===0?h.push([d]):h[h.length-1].push(d),h)),[]).map((h=>({r:h[0],g:h[1],b:h[2],a:h[3]})));y.setColor4Array(n,d)}for(n in h.vectors2){const d=h.vectors2[n];y.setVector2(n,{x:d[0],y:d[1]})}for(n in h.vectors3){const d=h.vectors3[n];y.setVector3(n,{x:d[0],y:d[1],z:d[2]})}for(n in h.vectors4){const d=h.vectors4[n];y.setVector4(n,{x:d[0],y:d[1],z:d[2],w:d[3]})}for(n in h.quaternions)y.setQuaternion(n,C.Quaternion.Bd(h.quaternions[n]));for(n in h.matrices)y.setMatrix(n,C.Matrix.Bd(h.matrices[n]));for(n in h.matrixArray)y._matrixArrays[n]=new Float32Array(h.matrixArray[n]);for(n in h.matrices3x3)y.setMatrix3x3(n,h.matrices3x3[n]);for(n in h.matrices2x2)y.setMatrix2x2(n,h.matrices2x2[n]);for(n in h.vectors2Arrays)y.setArray2(n,h.vectors2Arrays[n]);for(n in h.vectors3Arrays)y.setArray3(n,h.vectors3Arrays[n]);for(n in h.vectors4Arrays)y.setArray4(n,h.vectors4Arrays[n]);for(n in h.quaternionsArrays)y.setArray4(n,h.quaternionsArrays[n]);return y}static async ParseFromFileAsync(h,d,T){let Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((y,C)=>{const n=new Z.b;n.addEventListener("readystatechange",(()=>{if(4==n.readyState)if(200==n.status){const d=JSON.parse(n.responseText),C=this.Parse(d,T||r.d.LastCreatedScene,Y);h&&(C.name=h),y(C)}else C("Unable to load the ShaderMaterial")})),n.open("GET",d),n.send()}))}static async ParseFromSnippetAsync(h,d){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((Y,y)=>{const C=new Z.b;C.addEventListener("readystatechange",(()=>{if(4==C.readyState)if(200==C.status){const y=JSON.parse(JSON.parse(C.responseText).jsonPayload),n=JSON.parse(y.shaderMaterial),X=this.Parse(n,d||r.d.LastCreatedScene,T);X.snippetId=h,Y(X)}else y("Unable to load the snippet "+h)})),C.open("GET",this.SnippetUrl+"/"+h.replace(/#/g,"/")),C.send()}))}}J.SnippetUrl="https://snippet.babylonjs.com",J.CreateFromSnippetAsync=J.ParseFromSnippetAsync,(0,F.e)("BABYLON.ShaderMaterial",J)}}]);