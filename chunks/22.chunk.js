"use strict";(self.ozi0exxand9=self.ozi0exxand9||[]).push([[22],{11637:(f,v,Z)=>{Z.r(v),Z.d(v,{ShaderMaterial:()=>F});var V=Z(11462),h=Z(11646),J=Z(11421),l=Z(11494),e=Z(11401),C=Z(11372),H=Z(11713),O=Z(11272),u=Z(11722),W=Z(11281),a=Z(11768),b=Z(11760);const X={effect:null,subMesh:null};class F extends u.b{constructor(f,v,Z){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(f,v,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new J.Matrix,this._cachedWorldViewProjectionMatrix=new J.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=Z,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...V}}get shaderPath(){return this._shaderPath}set shaderPath(f){this._shaderPath=f}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(f){-1===this._options.uniforms.indexOf(f)&&this._options.uniforms.push(f)}setTexture(f,v){return-1===this._options.samplers.indexOf(f)&&this._options.samplers.push(f),this._textures[f]=v,this}removeTexture(f){delete this._textures[f]}setTextureArray(f,v){return-1===this._options.samplers.indexOf(f)&&this._options.samplers.push(f),this._checkUniform(f),this._textureArrays[f]=v,this}setExternalTexture(f,v){return-1===this._options.externalTextures.indexOf(f)&&this._options.externalTextures.push(f),this._externalTextures[f]=v,this}setFloat(f,v){return this._checkUniform(f),this._floats[f]=v,this}setInt(f,v){return this._checkUniform(f),this._ints[f]=v,this}setUInt(f,v){return this._checkUniform(f),this._uints[f]=v,this}setFloats(f,v){return this._checkUniform(f),this._floatsArrays[f]=v,this}setColor3(f,v){return this._checkUniform(f),this._colors3[f]=v,this}setColor3Array(f,v){return this._checkUniform(f),this._colors3Arrays[f]=v.reduce(((f,v)=>(f.push(v.r,v.g,v.b),f)),[]),this}setColor4(f,v){return this._checkUniform(f),this._colors4[f]=v,this}setColor4Array(f,v){return this._checkUniform(f),this._colors4Arrays[f]=v.reduce(((f,v)=>(f.push(v.r,v.g,v.b,v.a),f)),[]),this}setVector2(f,v){return this._checkUniform(f),this._vectors2[f]=v,this}setVector3(f,v){return this._checkUniform(f),this._vectors3[f]=v,this}setVector4(f,v){return this._checkUniform(f),this._vectors4[f]=v,this}setQuaternion(f,v){return this._checkUniform(f),this._quaternions[f]=v,this}setQuaternionArray(f,v){return this._checkUniform(f),this._quaternionsArrays[f]=v.reduce(((f,v)=>(v.toArray(f,f.length),f)),[]),this}setMatrix(f,v){return this._checkUniform(f),this._matrices[f]=v,this}setMatrices(f,v){this._checkUniform(f);const Z=new Float32Array(16*v.length);for(let V=0;V<v.length;V++){v[V].copyToArray(Z,16*V)}return this._matrixArrays[f]=Z,this}setMatrix3x3(f,v){return this._checkUniform(f),this._matrices3x3[f]=v,this}setMatrix2x2(f,v){return this._checkUniform(f),this._matrices2x2[f]=v,this}setArray2(f,v){return this._checkUniform(f),this._vectors2Arrays[f]=v,this}setArray3(f,v){return this._checkUniform(f),this._vectors3Arrays[f]=v,this}setArray4(f,v){return this._checkUniform(f),this._vectors4Arrays[f]=v,this}setUniformBuffer(f,v){return-1===this._options.uniformBuffers.indexOf(f)&&this._options.uniformBuffers.push(f),this._uniformBuffers[f]=v,this}setTextureSampler(f,v){return-1===this._options.samplerObjects.indexOf(f)&&this._options.samplerObjects.push(f),this._textureSamplers[f]=v,this}setStorageBuffer(f,v){return-1===this._options.storageBuffers.indexOf(f)&&this._options.storageBuffers.push(f),this._storageBuffers[f]=v,this}setDefine(f,v){const Z=f.trimEnd()+" ",V=this.options.defines.findIndex((v=>v===f||v.startsWith(Z)));return V>=0&&this.options.defines.splice(V,1),("boolean"!==typeof v||v)&&this.options.defines.push(Z+v),this}isReadyForSubMesh(f,v,Z){return this.isReady(f,Z,v)}isReady(f,v,Z){var V;const J=Z&&this._storeEffectOnSubMeshes;if(this.isFrozen){const f=J?Z._drawWrapper:this._drawWrapper;if(f.effect&&f._wasPreviouslyReady&&f._wasPreviouslyUsingInstances===v)return!0}const e=this.Yf(),C=e.getEngine(),O=[],u=[];let W=null,F=this._shaderPath,U=this._options.uniforms,K=this._options.uniformBuffers,M=this._options.samplers;C.getCaps().multiview&&e.activeCamera&&e.activeCamera.outputRenderTarget&&e.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,O.push("#define MULTIVIEW"),-1!==U.indexOf("viewProjection")&&-1===U.indexOf("viewProjectionR")&&U.push("viewProjectionR"));for(let h=0;h<this._options.defines.length;h++){const f=0===this._options.defines[h].indexOf("#define")?this._options.defines[h]:`#define ${this._options.defines[h]}`;O.push(f)}for(let h=0;h<this._options.attributes.length;h++)u.push(this._options.attributes[h]);if(f&&f.isVerticesDataPresent(l.g.ColorKind)&&(-1===u.indexOf(l.g.ColorKind)&&u.push(l.g.ColorKind),O.push("#define VERTEXCOLOR")),v&&(O.push("#define INSTANCES"),(0,b.ib)(u,this._materialHelperNeedsPreviousMatrices),null!==f&&void 0!==f&&f.hasThinInstances&&(O.push("#define THIN_INSTANCES"),f&&f.isVerticesDataPresent(l.g.ColorInstanceKind)&&(u.push(l.g.ColorInstanceKind),O.push("#define INSTANCESCOLOR")))),f&&f.useBones&&f.computeBonesUsingShaders&&f.skeleton){u.push(l.g.MatricesIndicesKind),u.push(l.g.MatricesWeightsKind),f.numBoneInfluencers>4&&(u.push(l.g.MatricesIndicesExtraKind),u.push(l.g.MatricesWeightsExtraKind));const v=f.skeleton;O.push("#define NUM_BONE_INFLUENCERS "+f.numBoneInfluencers),W=new H.c,W.addCPUSkinningFallback(0,f),v.isUsingTextureForMatrices?(O.push("#define BONETEXTURE"),-1===U.indexOf("boneTextureWidth")&&U.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(O.push("#define BonesPerMesh "+(v.bones.length+1)),-1===U.indexOf("mBones")&&U.push("mBones"))}else O.push("#define NUM_BONE_INFLUENCERS 0");let A=0;const s=f?f.morphTargetManager:null;if(s){const v=-1!==O.indexOf("#define UV1"),Z=-1!==O.indexOf("#define UV2"),V=-1!==O.indexOf("#define TANGENT"),h=-1!==O.indexOf("#define NORMAL"),J=-1!==O.indexOf("#define VERTEXCOLOR");A=(0,b.K)(s,O,u,f,!0,h,V,v,Z,J),s.isUsingTextureForTargets&&(-1===U.indexOf("morphTargetTextureIndices")&&U.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),A>0&&(U=U.slice(),U.push("morphTargetInfluences"),U.push("morphTargetCount"),U.push("morphTargetTextureInfo"),U.push("morphTargetTextureIndices"))}else O.push("#define NUM_MORPH_INFLUENCERS 0");if(f){const v=f.bakedVertexAnimationManager;v&&v.isEnabled&&(O.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===U.indexOf("bakedVertexAnimationSettings")&&U.push("bakedVertexAnimationSettings"),-1===U.indexOf("bakedVertexAnimationTextureSizeInverted")&&U.push("bakedVertexAnimationTextureSizeInverted"),-1===U.indexOf("bakedVertexAnimationTime")&&U.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,b.x)(u,f,O)}for(const h in this._textures)if(!this._textures[h].isReady())return!1;f&&this.needAlphaTestingForMesh(f)&&O.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,a.b)(U),(0,a.g)(this,e,O)),e.fogEnabled&&null!==f&&void 0!==f&&f.applyFog&&e.fogMode!==h.b.FOGMODE_NONE&&(O.push("#define FOG"),-1===U.indexOf("view")&&U.push("view"),-1===U.indexOf("vFogInfos")&&U.push("vFogInfos"),-1===U.indexOf("vFogColor")&&U.push("vFogColor")),this._useLogarithmicDepth&&(O.push("#define LOGARITHMICDEPTH"),-1===U.indexOf("logarithmicDepthConstant")&&U.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(U=U.slice(),K=K.slice(),M=M.slice(),F=this.customShaderNameResolve(this.name,U,K,M,O,u));const z=J?Z._getDrawWrapper(void 0,!0):this._drawWrapper,Y=(null===z||void 0===z?void 0:z.effect)??null,y=(null===z||void 0===z?void 0:z.defines)??null,N=O.join("\n");let i=Y;return y!==N&&(i=C.createEffect(F,{attributes:u,uniformsNames:U,uniformBuffersNames:K,samplers:M,defines:N,fallbacks:W,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:A},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},C),J?Z.setEffect(i,N,this._materialContext):z&&z.setEffect(i,N),this._onEffectCreatedObservable&&(X.effect=i,X.subMesh=Z??(null===f||void 0===f?void 0:f.Bh[0])??null,this._onEffectCreatedObservable.notifyObservers(X))),z._wasPreviouslyUsingInstances=!!v,!(null===(V=i)||void 0===V||!V.isReady())&&(Y!==i&&e.resetCachedMaterial(),z._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(f,v){const Z=v??this.getEffect();if(!Z)return;const V=this._options.uniforms;-1!==V.indexOf("world")&&Z.setMatrix("world",f);const h=this.Yf();-1!==V.indexOf("worldView")&&(f.multiplyToRef(h.getViewMatrix(),this._cachedWorldViewMatrix),Z.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==V.indexOf("worldViewProjection")&&(f.multiplyToRef(h.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),Z.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==V.indexOf("view")&&Z.setMatrix("view",h.getViewMatrix())}bindForSubMesh(f,v,Z){var V;this.bind(f,v,null===(V=Z._drawWrapperOverride)||void 0===V?void 0:V.effect,Z)}bind(f,v,Z,V){const h=V&&this._storeEffectOnSubMeshes,J=Z??(h?V.effect:this.getEffect());if(!J)return;const l=this.Yf();this._activeEffect=J,this.bindOnlyWorldMatrix(f,Z);const e=this._options.uniformBuffers;let C=!1;if(J&&e&&e.length>0&&l.getEngine().supportsUniformBuffers)for(let u=0;u<e.length;++u){switch(e[u]){case"Mesh":v&&(v.getMeshUniformBuffer().bindToEffect(J,"Mesh"),v.transferToEffect(f));break;case"Scene":(0,b.n)(J,l.getSceneUniformBuffer()),l.finalizeSceneUbo(),C=!0}}const H=v&&h?this._mustRebind(l,J,V,v.visibility):l.getCachedMaterial()!==this;if(J&&H){let f;for(f in C||-1===this._options.uniforms.indexOf("view")||J.setMatrix("view",l.getViewMatrix()),C||-1===this._options.uniforms.indexOf("projection")||J.setMatrix("projection",l.getProjectionMatrix()),C||-1===this._options.uniforms.indexOf("viewProjection")||(J.setMatrix("viewProjection",l.getTransformMatrix()),this._multiview&&J.setMatrix("viewProjectionR",l._transformMatrixR)),l.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&J.setVector3("cameraPosition",l.activeCamera.globalPosition),(0,b.b)(v,J),(0,a.c)(J,this,l),this._useLogarithmicDepth&&(0,b.h)(h?V.materialDefines:J.defines,J,l),v&&(0,b.d)(l,v,J),this._textures)J.setTexture(f,this._textures[f]);for(f in this._textureArrays)J.setTextureArray(f,this._textureArrays[f]);for(f in this._ints)J.setInt(f,this._ints[f]);for(f in this._uints)J.setUInt(f,this._uints[f]);for(f in this._floats)J.setFloat(f,this._floats[f]);for(f in this._floatsArrays)J.setArray(f,this._floatsArrays[f]);for(f in this._colors3)J.setColor3(f,this._colors3[f]);for(f in this._colors3Arrays)J.setArray3(f,this._colors3Arrays[f]);for(f in this._colors4){const v=this._colors4[f];J.setFloat4(f,v.r,v.g,v.b,v.a)}for(f in this._colors4Arrays)J.setArray4(f,this._colors4Arrays[f]);for(f in this._vectors2)J.setVector2(f,this._vectors2[f]);for(f in this._vectors3)J.setVector3(f,this._vectors3[f]);for(f in this._vectors4)J.setVector4(f,this._vectors4[f]);for(f in this._quaternions)J.setQuaternion(f,this._quaternions[f]);for(f in this._matrices)J.setMatrix(f,this._matrices[f]);for(f in this._matrixArrays)J.setMatrices(f,this._matrixArrays[f]);for(f in this._matrices3x3)J.setMatrix3x3(f,this._matrices3x3[f]);for(f in this._matrices2x2)J.setMatrix2x2(f,this._matrices2x2[f]);for(f in this._vectors2Arrays)J.setArray2(f,this._vectors2Arrays[f]);for(f in this._vectors3Arrays)J.setArray3(f,this._vectors3Arrays[f]);for(f in this._vectors4Arrays)J.setArray4(f,this._vectors4Arrays[f]);for(f in this._quaternionsArrays)J.setArray4(f,this._quaternionsArrays[f]);for(f in this._uniformBuffers){const v=this._uniformBuffers[f].getBuffer();v&&J.bindUniformBuffer(v,f)}const Z=l.getEngine(),e=Z.setExternalTexture;if(e)for(f in this._externalTextures)e.call(Z,f,this._externalTextures[f]);const H=Z.setTextureSampler;if(H)for(f in this._textureSamplers)H.call(Z,f,this._textureSamplers[f]);const O=Z.setStorageBuffer;if(O)for(f in this._storageBuffers)O.call(Z,f,this._storageBuffers[f])}if(J&&v&&(H||!this.isFrozen)){(0,b.l)(v,J),v.morphTargetManager&&v.morphTargetManager.isUsingTextureForTargets&&v.morphTargetManager._bind(J);const f=v.bakedVertexAnimationManager;if(f&&f.isEnabled){var O;const f=h?V._drawWrapper:this._drawWrapper;null===(O=v.bakedVertexAnimationManager)||void 0===O||O.bind(J,!!f._wasPreviouslyUsingInstances)}}this._afterBind(v,J,V)}getActiveTextures(){const f=super.getActiveTextures();for(const v in this._textures)f.push(this._textures[v]);for(const v in this._textureArrays){const Z=this._textureArrays[v];for(let v=0;v<Z.length;v++)f.push(Z[v])}return f}hasTexture(f){if(super.hasTexture(f))return!0;for(const v in this._textures)if(this._textures[v]===f)return!0;for(const v in this._textureArrays){const Z=this._textureArrays[v];for(let v=0;v<Z.length;v++)if(Z[v]===f)return!0}return!1}clone(f){const v=V.b.Clone((()=>new F(f,this.Yf(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);v.name=f,v.id=f,"object"===typeof v._shaderPath&&(v._shaderPath={...v._shaderPath}),this._options={...this._options};const Z=Object.keys(this._options);for(const V of Z){const f=this._options[V];Array.isArray(f)&&(this._options[V]=f.slice(0))}this.stencil.copyTo(v.stencil);for(const V in this._textures)v.setTexture(V,this._textures[V]);for(const V in this._textureArrays)v.setTextureArray(V,this._textureArrays[V]);for(const V in this._externalTextures)v.setExternalTexture(V,this._externalTextures[V]);for(const V in this._ints)v.setInt(V,this._ints[V]);for(const V in this._uints)v.setUInt(V,this._uints[V]);for(const V in this._floats)v.setFloat(V,this._floats[V]);for(const V in this._floatsArrays)v.setFloats(V,this._floatsArrays[V]);for(const V in this._colors3)v.setColor3(V,this._colors3[V]);for(const V in this._colors3Arrays)v._colors3Arrays[V]=this._colors3Arrays[V];for(const V in this._colors4)v.setColor4(V,this._colors4[V]);for(const V in this._colors4Arrays)v._colors4Arrays[V]=this._colors4Arrays[V];for(const V in this._vectors2)v.setVector2(V,this._vectors2[V]);for(const V in this._vectors3)v.setVector3(V,this._vectors3[V]);for(const V in this._vectors4)v.setVector4(V,this._vectors4[V]);for(const V in this._quaternions)v.setQuaternion(V,this._quaternions[V]);for(const V in this._quaternionsArrays)v._quaternionsArrays[V]=this._quaternionsArrays[V];for(const V in this._matrices)v.setMatrix(V,this._matrices[V]);for(const V in this._matrixArrays)v._matrixArrays[V]=this._matrixArrays[V].slice();for(const V in this._matrices3x3)v.setMatrix3x3(V,this._matrices3x3[V]);for(const V in this._matrices2x2)v.setMatrix2x2(V,this._matrices2x2[V]);for(const V in this._vectors2Arrays)v.setArray2(V,this._vectors2Arrays[V]);for(const V in this._vectors3Arrays)v.setArray3(V,this._vectors3Arrays[V]);for(const V in this._vectors4Arrays)v.setArray4(V,this._vectors4Arrays[V]);for(const V in this._uniformBuffers)v.setUniformBuffer(V,this._uniformBuffers[V]);for(const V in this._textureSamplers)v.setTextureSampler(V,this._textureSamplers[V]);for(const V in this._storageBuffers)v.setStorageBuffer(V,this._storageBuffers[V]);return v}dispose(f,v,Z){if(v){let f;for(f in this._textures)this._textures[f].dispose();for(f in this._textureArrays){const v=this._textureArrays[f];for(let f=0;f<v.length;f++)v[f].dispose()}}this._textures={},super.dispose(f,v,Z)}serialize(){const f=V.b.Serialize(this);let v;for(v in f.customType="BABYLON.ShaderMaterial",f.uniqueId=this.uniqueId,f.options=this._options,f.shaderPath=this._shaderPath,f.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,f.stencil=this.stencil.serialize(),f.textures={},this._textures)f.textures[v]=this._textures[v].serialize();for(v in f.textureArrays={},this._textureArrays){f.textureArrays[v]=[];const Z=this._textureArrays[v];for(let V=0;V<Z.length;V++)f.textureArrays[v].push(Z[V].serialize())}for(v in f.ints={},this._ints)f.ints[v]=this._ints[v];for(v in f.uints={},this._uints)f.uints[v]=this._uints[v];for(v in f.floats={},this._floats)f.floats[v]=this._floats[v];for(v in f.floatsArrays={},this._floatsArrays)f.floatsArrays[v]=this._floatsArrays[v];for(v in f.colors3={},this._colors3){const Z=this._colors3[v];f.colors3[v]=[Z.r,Z.g,Z.b]}for(v in f.colors3Arrays={},this._colors3Arrays)f.colors3Arrays[v]=this._colors3Arrays[v];for(v in f.colors4={},this._colors4){const Z=this._colors4[v];f.colors4[v]=[Z.r,Z.g,Z.b,Z.a]}for(v in f.colors4Arrays={},this._colors4Arrays)f.colors4Arrays[v]=this._colors4Arrays[v];for(v in f.vectors2={},this._vectors2){const Z=this._vectors2[v];f.vectors2[v]=[Z.x,Z.y]}for(v in f.vectors3={},this._vectors3){const Z=this._vectors3[v];f.vectors3[v]=[Z.x,Z.y,Z.z]}for(v in f.vectors4={},this._vectors4){const Z=this._vectors4[v];f.vectors4[v]=[Z.x,Z.y,Z.z,Z.w]}for(v in f.quaternions={},this._quaternions)f.quaternions[v]=this._quaternions[v].Ph();for(v in f.matrices={},this._matrices)f.matrices[v]=this._matrices[v].Ph();for(v in f.matrixArray={},this._matrixArrays)f.matrixArray[v]=this._matrixArrays[v];for(v in f.matrices3x3={},this._matrices3x3)f.matrices3x3[v]=this._matrices3x3[v];for(v in f.matrices2x2={},this._matrices2x2)f.matrices2x2[v]=this._matrices2x2[v];for(v in f.vectors2Arrays={},this._vectors2Arrays)f.vectors2Arrays[v]=this._vectors2Arrays[v];for(v in f.vectors3Arrays={},this._vectors3Arrays)f.vectors3Arrays[v]=this._vectors3Arrays[v];for(v in f.vectors4Arrays={},this._vectors4Arrays)f.vectors4Arrays[v]=this._vectors4Arrays[v];for(v in f.quaternionsArrays={},this._quaternionsArrays)f.quaternionsArrays[v]=this._quaternionsArrays[v];return f}static Parse(f,v,Z){const h=V.b.Parse((()=>new F(f.name,v,f.shaderPath,f.options,f.storeEffectOnSubMeshes)),f,v,Z);let l;for(l in f.stencil&&h.stencil.parse(f.stencil,v,Z),f.textures)h.setTexture(l,e.e.Parse(f.textures[l],v,Z));for(l in f.textureArrays){const V=f.textureArrays[l],J=[];for(let f=0;f<V.length;f++)J.push(e.e.Parse(V[f],v,Z));h.setTextureArray(l,J)}for(l in f.ints)h.setInt(l,f.ints[l]);for(l in f.uints)h.setUInt(l,f.uints[l]);for(l in f.floats)h.setFloat(l,f.floats[l]);for(l in f.floatsArrays)h.setFloats(l,f.floatsArrays[l]);for(l in f.colors3){const v=f.colors3[l];h.setColor3(l,{r:v[0],g:v[1],b:v[2]})}for(l in f.colors3Arrays){const v=f.colors3Arrays[l].reduce(((f,v,Z)=>(Z%3===0?f.push([v]):f[f.length-1].push(v),f)),[]).map((f=>({r:f[0],g:f[1],b:f[2]})));h.setColor3Array(l,v)}for(l in f.colors4){const v=f.colors4[l];h.setColor4(l,{r:v[0],g:v[1],b:v[2],a:v[3]})}for(l in f.colors4Arrays){const v=f.colors4Arrays[l].reduce(((f,v,Z)=>(Z%4===0?f.push([v]):f[f.length-1].push(v),f)),[]).map((f=>({r:f[0],g:f[1],b:f[2],a:f[3]})));h.setColor4Array(l,v)}for(l in f.vectors2){const v=f.vectors2[l];h.setVector2(l,{x:v[0],y:v[1]})}for(l in f.vectors3){const v=f.vectors3[l];h.setVector3(l,{x:v[0],y:v[1],z:v[2]})}for(l in f.vectors4){const v=f.vectors4[l];h.setVector4(l,{x:v[0],y:v[1],z:v[2],w:v[3]})}for(l in f.quaternions)h.setQuaternion(l,J.Quaternion.Av(f.quaternions[l]));for(l in f.matrices)h.setMatrix(l,J.Matrix.Av(f.matrices[l]));for(l in f.matrixArray)h._matrixArrays[l]=new Float32Array(f.matrixArray[l]);for(l in f.matrices3x3)h.setMatrix3x3(l,f.matrices3x3[l]);for(l in f.matrices2x2)h.setMatrix2x2(l,f.matrices2x2[l]);for(l in f.vectors2Arrays)h.setArray2(l,f.vectors2Arrays[l]);for(l in f.vectors3Arrays)h.setArray3(l,f.vectors3Arrays[l]);for(l in f.vectors4Arrays)h.setArray4(l,f.vectors4Arrays[l]);for(l in f.quaternionsArrays)h.setArray4(l,f.quaternionsArrays[l]);return h}static async ParseFromFileAsync(f,v,Z){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((h,J)=>{const l=new O.c;l.addEventListener("readystatechange",(()=>{if(4==l.readyState)if(200==l.status){const v=JSON.parse(l.responseText),J=this.Parse(v,Z||W.c.LastCreatedScene,V);f&&(J.name=f),h(J)}else J("Unable to load the ShaderMaterial")})),l.open("GET",v),l.send()}))}static async ParseFromSnippetAsync(f,v){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((V,h)=>{const J=new O.c;J.addEventListener("readystatechange",(()=>{if(4==J.readyState)if(200==J.status){const h=JSON.parse(JSON.parse(J.responseText).jsonPayload),l=JSON.parse(h.shaderMaterial),e=this.Parse(l,v||W.c.LastCreatedScene,Z);e.snippetId=f,V(e)}else h("Unable to load the snippet "+f)})),J.open("GET",this.SnippetUrl+"/"+f.replace(/#/g,"/")),J.send()}))}}F.SnippetUrl="https://snippet.babylonjs.com",F.CreateFromSnippetAsync=F.ParseFromSnippetAsync,(0,C.h)("BABYLON.ShaderMaterial",F)}}]);