"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[22],{11826:(U,X,b)=>{b.r(X),b.d(X,{ShaderMaterial:()=>x});var F=b(11623),E=b(11833),w=b(11593),Q=b(11664),z=b(11570),q=b(11551),p=b(11916),S=b(11436),R=b(11922),n=b(11442),a=b(11972),J=b(11969);const m={effect:null,subMesh:null};class x extends R.b{constructor(U,X,b){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(U,X,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new w.Matrix,this._cachedWorldViewProjectionMatrix=new w.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=b,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...F}}get shaderPath(){return this._shaderPath}set shaderPath(U){this._shaderPath=U}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(U){-1===this._options.uniforms.indexOf(U)&&this._options.uniforms.push(U)}setTexture(U,X){return-1===this._options.samplers.indexOf(U)&&this._options.samplers.push(U),this._textures[U]=X,this}removeTexture(U){delete this._textures[U]}setTextureArray(U,X){return-1===this._options.samplers.indexOf(U)&&this._options.samplers.push(U),this._checkUniform(U),this._textureArrays[U]=X,this}setExternalTexture(U,X){return-1===this._options.externalTextures.indexOf(U)&&this._options.externalTextures.push(U),this._externalTextures[U]=X,this}setFloat(U,X){return this._checkUniform(U),this._floats[U]=X,this}setInt(U,X){return this._checkUniform(U),this._ints[U]=X,this}setUInt(U,X){return this._checkUniform(U),this._uints[U]=X,this}setFloats(U,X){return this._checkUniform(U),this._floatsArrays[U]=X,this}setColor3(U,X){return this._checkUniform(U),this._colors3[U]=X,this}setColor3Array(U,X){return this._checkUniform(U),this._colors3Arrays[U]=X.reduce(((U,X)=>(U.push(X.r,X.g,X.b),U)),[]),this}setColor4(U,X){return this._checkUniform(U),this._colors4[U]=X,this}setColor4Array(U,X){return this._checkUniform(U),this._colors4Arrays[U]=X.reduce(((U,X)=>(U.push(X.r,X.g,X.b,X.a),U)),[]),this}setVector2(U,X){return this._checkUniform(U),this._vectors2[U]=X,this}setVector3(U,X){return this._checkUniform(U),this._vectors3[U]=X,this}setVector4(U,X){return this._checkUniform(U),this._vectors4[U]=X,this}setQuaternion(U,X){return this._checkUniform(U),this._quaternions[U]=X,this}setQuaternionArray(U,X){return this._checkUniform(U),this._quaternionsArrays[U]=X.reduce(((U,X)=>(X.toArray(U,U.length),U)),[]),this}setMatrix(U,X){return this._checkUniform(U),this._matrices[U]=X,this}setMatrices(U,X){this._checkUniform(U);const b=new Float32Array(16*X.length);for(let F=0;F<X.length;F++){X[F].copyToArray(b,16*F)}return this._matrixArrays[U]=b,this}setMatrix3x3(U,X){return this._checkUniform(U),this._matrices3x3[U]=X,this}setMatrix2x2(U,X){return this._checkUniform(U),this._matrices2x2[U]=X,this}setArray2(U,X){return this._checkUniform(U),this._vectors2Arrays[U]=X,this}setArray3(U,X){return this._checkUniform(U),this._vectors3Arrays[U]=X,this}setArray4(U,X){return this._checkUniform(U),this._vectors4Arrays[U]=X,this}setUniformBuffer(U,X){return-1===this._options.uniformBuffers.indexOf(U)&&this._options.uniformBuffers.push(U),this._uniformBuffers[U]=X,this}setTextureSampler(U,X){return-1===this._options.samplerObjects.indexOf(U)&&this._options.samplerObjects.push(U),this._textureSamplers[U]=X,this}setStorageBuffer(U,X){return-1===this._options.storageBuffers.indexOf(U)&&this._options.storageBuffers.push(U),this._storageBuffers[U]=X,this}setDefine(U,X){const b=U.trimEnd()+" ",F=this.options.defines.findIndex((X=>X===U||X.startsWith(b)));return F>=0&&this.options.defines.splice(F,1),("boolean"!==typeof X||X)&&this.options.defines.push(b+X),this}isReadyForSubMesh(U,X,b){return this.isReady(U,b,X)}isReady(U,X,b){var F;const w=b&&this._storeEffectOnSubMeshes;if(this.isFrozen){const U=w?b._drawWrapper:this._drawWrapper;if(U.effect&&U._wasPreviouslyReady&&U._wasPreviouslyUsingInstances===X)return!0}const z=this.fU(),q=z.getEngine(),S=[],R=[];let n=null,x=this._shaderPath,I=this._options.uniforms,O=this._options.uniformBuffers,N=this._options.samplers;q.getCaps().multiview&&z.activeCamera&&z.activeCamera.outputRenderTarget&&z.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,S.push("#define MULTIVIEW"),-1!==I.indexOf("viewProjection")&&-1===I.indexOf("viewProjectionR")&&I.push("viewProjectionR"));for(let E=0;E<this._options.defines.length;E++){const U=0===this._options.defines[E].indexOf("#define")?this._options.defines[E]:`#define ${this._options.defines[E]}`;S.push(U)}for(let E=0;E<this._options.attributes.length;E++)R.push(this._options.attributes[E]);if(U&&U.isVerticesDataPresent(Q.h.ColorKind)&&(-1===R.indexOf(Q.h.ColorKind)&&R.push(Q.h.ColorKind),S.push("#define VERTEXCOLOR")),X&&(S.push("#define INSTANCES"),(0,J.db)(R,this._materialHelperNeedsPreviousMatrices),null!==U&&void 0!==U&&U.hasThinInstances&&(S.push("#define THIN_INSTANCES"),U&&U.isVerticesDataPresent(Q.h.ColorInstanceKind)&&(R.push(Q.h.ColorInstanceKind),S.push("#define INSTANCESCOLOR")))),U&&U.useBones&&U.computeBonesUsingShaders&&U.skeleton){R.push(Q.h.MatricesIndicesKind),R.push(Q.h.MatricesWeightsKind),U.numBoneInfluencers>4&&(R.push(Q.h.MatricesIndicesExtraKind),R.push(Q.h.MatricesWeightsExtraKind));const X=U.skeleton;S.push("#define NUM_BONE_INFLUENCERS "+U.numBoneInfluencers),n=new p.d,n.addCPUSkinningFallback(0,U),X.isUsingTextureForMatrices?(S.push("#define BONETEXTURE"),-1===I.indexOf("boneTextureWidth")&&I.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(S.push("#define BonesPerMesh "+(X.bones.length+1)),-1===I.indexOf("mBones")&&I.push("mBones"))}else S.push("#define NUM_BONE_INFLUENCERS 0");let u=0;const i=U?U.morphTargetManager:null;if(i){const X=-1!==S.indexOf("#define UV1"),b=-1!==S.indexOf("#define UV2"),F=-1!==S.indexOf("#define TANGENT"),E=-1!==S.indexOf("#define NORMAL"),w=-1!==S.indexOf("#define VERTEXCOLOR");u=(0,J.K)(i,S,R,U,!0,E,F,X,b,w),i.isUsingTextureForTargets&&(-1===I.indexOf("morphTargetTextureIndices")&&I.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),u>0&&(I=I.slice(),I.push("morphTargetInfluences"),I.push("morphTargetCount"),I.push("morphTargetTextureInfo"),I.push("morphTargetTextureIndices"))}else S.push("#define NUM_MORPH_INFLUENCERS 0");if(U){const X=U.bakedVertexAnimationManager;X&&X.isEnabled&&(S.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===I.indexOf("bakedVertexAnimationSettings")&&I.push("bakedVertexAnimationSettings"),-1===I.indexOf("bakedVertexAnimationTextureSizeInverted")&&I.push("bakedVertexAnimationTextureSizeInverted"),-1===I.indexOf("bakedVertexAnimationTime")&&I.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,J.A)(R,U,S)}for(const E in this._textures)if(!this._textures[E].isReady())return!1;U&&this.needAlphaTestingForMesh(U)&&S.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,a.b)(I),(0,a.h)(this,z,S)),z.fogEnabled&&null!==U&&void 0!==U&&U.applyFog&&z.fogMode!==E.c.FOGMODE_NONE&&(S.push("#define FOG"),-1===I.indexOf("view")&&I.push("view"),-1===I.indexOf("vFogInfos")&&I.push("vFogInfos"),-1===I.indexOf("vFogColor")&&I.push("vFogColor")),this._useLogarithmicDepth&&(S.push("#define LOGARITHMICDEPTH"),-1===I.indexOf("logarithmicDepthConstant")&&I.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(I=I.slice(),O=O.slice(),N=N.slice(),x=this.customShaderNameResolve(this.name,I,O,N,S,R));const P=w?b._getDrawWrapper(void 0,!0):this._drawWrapper,f=(null===P||void 0===P?void 0:P.effect)??null,j=(null===P||void 0===P?void 0:P.defines)??null,e=S.join("\n");let l=f;return j!==e&&(l=q.createEffect(x,{attributes:R,uniformsNames:I,uniformBuffersNames:O,samplers:N,defines:e,fallbacks:n,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:u},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},q),w?b.setEffect(l,e,this._materialContext):P&&P.setEffect(l,e),this._onEffectCreatedObservable&&(m.effect=l,m.subMesh=b??(null===U||void 0===U?void 0:U.ab[0])??null,this._onEffectCreatedObservable.notifyObservers(m))),P._wasPreviouslyUsingInstances=!!X,!(null===(F=l)||void 0===F||!F.isReady())&&(f!==l&&z.resetCachedMaterial(),P._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(U,X){const b=X??this.getEffect();if(!b)return;const F=this._options.uniforms;-1!==F.indexOf("world")&&b.setMatrix("world",U);const E=this.fU();-1!==F.indexOf("worldView")&&(U.multiplyToRef(E.getViewMatrix(),this._cachedWorldViewMatrix),b.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==F.indexOf("worldViewProjection")&&(U.multiplyToRef(E.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),b.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==F.indexOf("view")&&b.setMatrix("view",E.getViewMatrix())}bindForSubMesh(U,X,b){var F;this.bind(U,X,null===(F=b._drawWrapperOverride)||void 0===F?void 0:F.effect,b)}bind(U,X,b,F){const E=F&&this._storeEffectOnSubMeshes,w=b??(E?F.effect:this.getEffect());if(!w)return;const Q=this.fU();this._activeEffect=w,this.bindOnlyWorldMatrix(U,b);const z=this._options.uniformBuffers;let q=!1;if(w&&z&&z.length>0&&Q.getEngine().supportsUniformBuffers)for(let R=0;R<z.length;++R){switch(z[R]){case"Mesh":X&&(X.getMeshUniformBuffer().bindToEffect(w,"Mesh"),X.transferToEffect(U));break;case"Scene":(0,J.r)(w,Q.getSceneUniformBuffer()),Q.finalizeSceneUbo(),q=!0}}const p=X&&E?this._mustRebind(Q,w,F,X.visibility):Q.getCachedMaterial()!==this;if(w&&p){let U;for(U in q||-1===this._options.uniforms.indexOf("view")||w.setMatrix("view",Q.getViewMatrix()),q||-1===this._options.uniforms.indexOf("projection")||w.setMatrix("projection",Q.getProjectionMatrix()),q||-1===this._options.uniforms.indexOf("viewProjection")||(w.setMatrix("viewProjection",Q.getTransformMatrix()),this._multiview&&w.setMatrix("viewProjectionR",Q._transformMatrixR)),Q.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&w.setVector3("cameraPosition",Q.activeCamera.globalPosition),(0,J.e)(X,w),(0,a.d)(w,this,Q),this._useLogarithmicDepth&&(0,J.l)(E?F.materialDefines:w.defines,w,Q),X&&(0,J.g)(Q,X,w),this._textures)w.setTexture(U,this._textures[U]);for(U in this._textureArrays)w.setTextureArray(U,this._textureArrays[U]);for(U in this._ints)w.setInt(U,this._ints[U]);for(U in this._uints)w.setUInt(U,this._uints[U]);for(U in this._floats)w.setFloat(U,this._floats[U]);for(U in this._floatsArrays)w.setArray(U,this._floatsArrays[U]);for(U in this._colors3)w.setColor3(U,this._colors3[U]);for(U in this._colors3Arrays)w.setArray3(U,this._colors3Arrays[U]);for(U in this._colors4){const X=this._colors4[U];w.setFloat4(U,X.r,X.g,X.b,X.a)}for(U in this._colors4Arrays)w.setArray4(U,this._colors4Arrays[U]);for(U in this._vectors2)w.setVector2(U,this._vectors2[U]);for(U in this._vectors3)w.setVector3(U,this._vectors3[U]);for(U in this._vectors4)w.setVector4(U,this._vectors4[U]);for(U in this._quaternions)w.setQuaternion(U,this._quaternions[U]);for(U in this._matrices)w.setMatrix(U,this._matrices[U]);for(U in this._matrixArrays)w.setMatrices(U,this._matrixArrays[U]);for(U in this._matrices3x3)w.setMatrix3x3(U,this._matrices3x3[U]);for(U in this._matrices2x2)w.setMatrix2x2(U,this._matrices2x2[U]);for(U in this._vectors2Arrays)w.setArray2(U,this._vectors2Arrays[U]);for(U in this._vectors3Arrays)w.setArray3(U,this._vectors3Arrays[U]);for(U in this._vectors4Arrays)w.setArray4(U,this._vectors4Arrays[U]);for(U in this._quaternionsArrays)w.setArray4(U,this._quaternionsArrays[U]);for(U in this._uniformBuffers){const X=this._uniformBuffers[U].getBuffer();X&&w.bindUniformBuffer(X,U)}const b=Q.getEngine(),z=b.setExternalTexture;if(z)for(U in this._externalTextures)z.call(b,U,this._externalTextures[U]);const p=b.setTextureSampler;if(p)for(U in this._textureSamplers)p.call(b,U,this._textureSamplers[U]);const S=b.setStorageBuffer;if(S)for(U in this._storageBuffers)S.call(b,U,this._storageBuffers[U])}if(w&&X&&(p||!this.isFrozen)){(0,J.o)(X,w),X.morphTargetManager&&X.morphTargetManager.isUsingTextureForTargets&&X.morphTargetManager._bind(w);const U=X.bakedVertexAnimationManager;if(U&&U.isEnabled){var S;const U=E?F._drawWrapper:this._drawWrapper;null===(S=X.bakedVertexAnimationManager)||void 0===S||S.bind(w,!!U._wasPreviouslyUsingInstances)}}this._afterBind(X,w,F)}getActiveTextures(){const U=super.getActiveTextures();for(const X in this._textures)U.push(this._textures[X]);for(const X in this._textureArrays){const b=this._textureArrays[X];for(let X=0;X<b.length;X++)U.push(b[X])}return U}hasTexture(U){if(super.hasTexture(U))return!0;for(const X in this._textures)if(this._textures[X]===U)return!0;for(const X in this._textureArrays){const b=this._textureArrays[X];for(let X=0;X<b.length;X++)if(b[X]===U)return!0}return!1}clone(U){const X=F.d.Clone((()=>new x(U,this.fU(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);X.name=U,X.id=U,"object"===typeof X._shaderPath&&(X._shaderPath={...X._shaderPath}),this._options={...this._options};const b=Object.keys(this._options);for(const F of b){const U=this._options[F];Array.isArray(U)&&(this._options[F]=U.slice(0))}this.stencil.copyTo(X.stencil);for(const F in this._textures)X.setTexture(F,this._textures[F]);for(const F in this._textureArrays)X.setTextureArray(F,this._textureArrays[F]);for(const F in this._externalTextures)X.setExternalTexture(F,this._externalTextures[F]);for(const F in this._ints)X.setInt(F,this._ints[F]);for(const F in this._uints)X.setUInt(F,this._uints[F]);for(const F in this._floats)X.setFloat(F,this._floats[F]);for(const F in this._floatsArrays)X.setFloats(F,this._floatsArrays[F]);for(const F in this._colors3)X.setColor3(F,this._colors3[F]);for(const F in this._colors3Arrays)X._colors3Arrays[F]=this._colors3Arrays[F];for(const F in this._colors4)X.setColor4(F,this._colors4[F]);for(const F in this._colors4Arrays)X._colors4Arrays[F]=this._colors4Arrays[F];for(const F in this._vectors2)X.setVector2(F,this._vectors2[F]);for(const F in this._vectors3)X.setVector3(F,this._vectors3[F]);for(const F in this._vectors4)X.setVector4(F,this._vectors4[F]);for(const F in this._quaternions)X.setQuaternion(F,this._quaternions[F]);for(const F in this._quaternionsArrays)X._quaternionsArrays[F]=this._quaternionsArrays[F];for(const F in this._matrices)X.setMatrix(F,this._matrices[F]);for(const F in this._matrixArrays)X._matrixArrays[F]=this._matrixArrays[F].slice();for(const F in this._matrices3x3)X.setMatrix3x3(F,this._matrices3x3[F]);for(const F in this._matrices2x2)X.setMatrix2x2(F,this._matrices2x2[F]);for(const F in this._vectors2Arrays)X.setArray2(F,this._vectors2Arrays[F]);for(const F in this._vectors3Arrays)X.setArray3(F,this._vectors3Arrays[F]);for(const F in this._vectors4Arrays)X.setArray4(F,this._vectors4Arrays[F]);for(const F in this._uniformBuffers)X.setUniformBuffer(F,this._uniformBuffers[F]);for(const F in this._textureSamplers)X.setTextureSampler(F,this._textureSamplers[F]);for(const F in this._storageBuffers)X.setStorageBuffer(F,this._storageBuffers[F]);return X}dispose(U,X,b){if(X){let U;for(U in this._textures)this._textures[U].dispose();for(U in this._textureArrays){const X=this._textureArrays[U];for(let U=0;U<X.length;U++)X[U].dispose()}}this._textures={},super.dispose(U,X,b)}serialize(){const U=F.d.Serialize(this);let X;for(X in U.customType="BABYLON.ShaderMaterial",U.uniqueId=this.uniqueId,U.options=this._options,U.shaderPath=this._shaderPath,U.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,U.stencil=this.stencil.serialize(),U.textures={},this._textures)U.textures[X]=this._textures[X].serialize();for(X in U.textureArrays={},this._textureArrays){U.textureArrays[X]=[];const b=this._textureArrays[X];for(let F=0;F<b.length;F++)U.textureArrays[X].push(b[F].serialize())}for(X in U.ints={},this._ints)U.ints[X]=this._ints[X];for(X in U.uints={},this._uints)U.uints[X]=this._uints[X];for(X in U.floats={},this._floats)U.floats[X]=this._floats[X];for(X in U.floatsArrays={},this._floatsArrays)U.floatsArrays[X]=this._floatsArrays[X];for(X in U.colors3={},this._colors3){const b=this._colors3[X];U.colors3[X]=[b.r,b.g,b.b]}for(X in U.colors3Arrays={},this._colors3Arrays)U.colors3Arrays[X]=this._colors3Arrays[X];for(X in U.colors4={},this._colors4){const b=this._colors4[X];U.colors4[X]=[b.r,b.g,b.b,b.a]}for(X in U.colors4Arrays={},this._colors4Arrays)U.colors4Arrays[X]=this._colors4Arrays[X];for(X in U.vectors2={},this._vectors2){const b=this._vectors2[X];U.vectors2[X]=[b.x,b.y]}for(X in U.vectors3={},this._vectors3){const b=this._vectors3[X];U.vectors3[X]=[b.x,b.y,b.z]}for(X in U.vectors4={},this._vectors4){const b=this._vectors4[X];U.vectors4[X]=[b.x,b.y,b.z,b.w]}for(X in U.quaternions={},this._quaternions)U.quaternions[X]=this._quaternions[X].Jb();for(X in U.matrices={},this._matrices)U.matrices[X]=this._matrices[X].Jb();for(X in U.matrixArray={},this._matrixArrays)U.matrixArray[X]=this._matrixArrays[X];for(X in U.matrices3x3={},this._matrices3x3)U.matrices3x3[X]=this._matrices3x3[X];for(X in U.matrices2x2={},this._matrices2x2)U.matrices2x2[X]=this._matrices2x2[X];for(X in U.vectors2Arrays={},this._vectors2Arrays)U.vectors2Arrays[X]=this._vectors2Arrays[X];for(X in U.vectors3Arrays={},this._vectors3Arrays)U.vectors3Arrays[X]=this._vectors3Arrays[X];for(X in U.vectors4Arrays={},this._vectors4Arrays)U.vectors4Arrays[X]=this._vectors4Arrays[X];for(X in U.quaternionsArrays={},this._quaternionsArrays)U.quaternionsArrays[X]=this._quaternionsArrays[X];return U}static Parse(U,X,b){const E=F.d.Parse((()=>new x(U.name,X,U.shaderPath,U.options,U.storeEffectOnSubMeshes)),U,X,b);let Q;for(Q in U.stencil&&E.stencil.parse(U.stencil,X,b),U.textures)E.setTexture(Q,z.c.Parse(U.textures[Q],X,b));for(Q in U.textureArrays){const F=U.textureArrays[Q],w=[];for(let U=0;U<F.length;U++)w.push(z.c.Parse(F[U],X,b));E.setTextureArray(Q,w)}for(Q in U.ints)E.setInt(Q,U.ints[Q]);for(Q in U.uints)E.setUInt(Q,U.uints[Q]);for(Q in U.floats)E.setFloat(Q,U.floats[Q]);for(Q in U.floatsArrays)E.setFloats(Q,U.floatsArrays[Q]);for(Q in U.colors3){const X=U.colors3[Q];E.setColor3(Q,{r:X[0],g:X[1],b:X[2]})}for(Q in U.colors3Arrays){const X=U.colors3Arrays[Q].reduce(((U,X,b)=>(b%3===0?U.push([X]):U[U.length-1].push(X),U)),[]).map((U=>({r:U[0],g:U[1],b:U[2]})));E.setColor3Array(Q,X)}for(Q in U.colors4){const X=U.colors4[Q];E.setColor4(Q,{r:X[0],g:X[1],b:X[2],a:X[3]})}for(Q in U.colors4Arrays){const X=U.colors4Arrays[Q].reduce(((U,X,b)=>(b%4===0?U.push([X]):U[U.length-1].push(X),U)),[]).map((U=>({r:U[0],g:U[1],b:U[2],a:U[3]})));E.setColor4Array(Q,X)}for(Q in U.vectors2){const X=U.vectors2[Q];E.setVector2(Q,{x:X[0],y:X[1]})}for(Q in U.vectors3){const X=U.vectors3[Q];E.setVector3(Q,{x:X[0],y:X[1],z:X[2]})}for(Q in U.vectors4){const X=U.vectors4[Q];E.setVector4(Q,{x:X[0],y:X[1],z:X[2],w:X[3]})}for(Q in U.quaternions)E.setQuaternion(Q,w.Quaternion.uX(U.quaternions[Q]));for(Q in U.matrices)E.setMatrix(Q,w.Matrix.uX(U.matrices[Q]));for(Q in U.matrixArray)E._matrixArrays[Q]=new Float32Array(U.matrixArray[Q]);for(Q in U.matrices3x3)E.setMatrix3x3(Q,U.matrices3x3[Q]);for(Q in U.matrices2x2)E.setMatrix2x2(Q,U.matrices2x2[Q]);for(Q in U.vectors2Arrays)E.setArray2(Q,U.vectors2Arrays[Q]);for(Q in U.vectors3Arrays)E.setArray3(Q,U.vectors3Arrays[Q]);for(Q in U.vectors4Arrays)E.setArray4(Q,U.vectors4Arrays[Q]);for(Q in U.quaternionsArrays)E.setArray4(Q,U.quaternionsArrays[Q]);return E}static async ParseFromFileAsync(U,X,b){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((E,w)=>{const Q=new S.b;Q.addEventListener("readystatechange",(()=>{if(4==Q.readyState)if(200==Q.status){const X=JSON.parse(Q.responseText),w=this.Parse(X,b||n.c.LastCreatedScene,F);U&&(w.name=U),E(w)}else w("Unable to load the ShaderMaterial")})),Q.open("GET",X),Q.send()}))}static async ParseFromSnippetAsync(U,X){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((F,E)=>{const w=new S.b;w.addEventListener("readystatechange",(()=>{if(4==w.readyState)if(200==w.status){const E=JSON.parse(JSON.parse(w.responseText).jsonPayload),Q=JSON.parse(E.shaderMaterial),z=this.Parse(Q,X||n.c.LastCreatedScene,b);z.snippetId=U,F(z)}else E("Unable to load the snippet "+U)})),w.open("GET",this.SnippetUrl+"/"+U.replace(/#/g,"/")),w.send()}))}}x.SnippetUrl="https://snippet.babylonjs.com",x.CreateFromSnippetAsync=x.ParseFromSnippetAsync,(0,q.f)("BABYLON.ShaderMaterial",x)}}]);