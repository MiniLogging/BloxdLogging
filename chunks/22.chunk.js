"use strict";(self["2fwzcez286e"]=self["2fwzcez286e"]||[]).push([[22],{13219:(B,u,F)=>{F.r(u),F.d(u,{ShaderMaterial:()=>q});var Z=F(13014),V=F(13221),p=F(12979),G=F(13047),R=F(12969),e=F(12949),s=F(13291),Y=F(12852),Q=F(13296),t=F(12855),v=F(13352),D=F(13349);const L={effect:null,subMesh:null};class q extends Q.e{constructor(B,u,F){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(B,u,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new p.Matrix,this._cachedWorldViewProjectionMatrix=new p.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=F,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...Z}}get shaderPath(){return this._shaderPath}set shaderPath(B){this._shaderPath=B}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(B){-1===this._options.uniforms.indexOf(B)&&this._options.uniforms.push(B)}setTexture(B,u){return-1===this._options.samplers.indexOf(B)&&this._options.samplers.push(B),this._textures[B]=u,this}removeTexture(B){delete this._textures[B]}setTextureArray(B,u){return-1===this._options.samplers.indexOf(B)&&this._options.samplers.push(B),this._checkUniform(B),this._textureArrays[B]=u,this}setExternalTexture(B,u){return-1===this._options.externalTextures.indexOf(B)&&this._options.externalTextures.push(B),this._externalTextures[B]=u,this}setFloat(B,u){return this._checkUniform(B),this._floats[B]=u,this}setInt(B,u){return this._checkUniform(B),this._ints[B]=u,this}setUInt(B,u){return this._checkUniform(B),this._uints[B]=u,this}setFloats(B,u){return this._checkUniform(B),this._floatsArrays[B]=u,this}setColor3(B,u){return this._checkUniform(B),this._colors3[B]=u,this}setColor3Array(B,u){return this._checkUniform(B),this._colors3Arrays[B]=u.reduce(((B,u)=>(B.push(u.r,u.g,u.b),B)),[]),this}setColor4(B,u){return this._checkUniform(B),this._colors4[B]=u,this}setColor4Array(B,u){return this._checkUniform(B),this._colors4Arrays[B]=u.reduce(((B,u)=>(B.push(u.r,u.g,u.b,u.a),B)),[]),this}setVector2(B,u){return this._checkUniform(B),this._vectors2[B]=u,this}setVector3(B,u){return this._checkUniform(B),this._vectors3[B]=u,this}setVector4(B,u){return this._checkUniform(B),this._vectors4[B]=u,this}setQuaternion(B,u){return this._checkUniform(B),this._quaternions[B]=u,this}setQuaternionArray(B,u){return this._checkUniform(B),this._quaternionsArrays[B]=u.reduce(((B,u)=>(u.toArray(B,B.length),B)),[]),this}setMatrix(B,u){return this._checkUniform(B),this._matrices[B]=u,this}setMatrices(B,u){this._checkUniform(B);const F=new Float32Array(16*u.length);for(let Z=0;Z<u.length;Z++){u[Z].copyToArray(F,16*Z)}return this._matrixArrays[B]=F,this}setMatrix3x3(B,u){return this._checkUniform(B),this._matrices3x3[B]=u,this}setMatrix2x2(B,u){return this._checkUniform(B),this._matrices2x2[B]=u,this}setArray2(B,u){return this._checkUniform(B),this._vectors2Arrays[B]=u,this}setArray3(B,u){return this._checkUniform(B),this._vectors3Arrays[B]=u,this}setArray4(B,u){return this._checkUniform(B),this._vectors4Arrays[B]=u,this}setUniformBuffer(B,u){return-1===this._options.uniformBuffers.indexOf(B)&&this._options.uniformBuffers.push(B),this._uniformBuffers[B]=u,this}setTextureSampler(B,u){return-1===this._options.samplerObjects.indexOf(B)&&this._options.samplerObjects.push(B),this._textureSamplers[B]=u,this}setStorageBuffer(B,u){return-1===this._options.storageBuffers.indexOf(B)&&this._options.storageBuffers.push(B),this._storageBuffers[B]=u,this}setDefine(B,u){const F=B.trimEnd()+" ",Z=this.options.defines.findIndex((u=>u===B||u.startsWith(F)));return Z>=0&&this.options.defines.splice(Z,1),("boolean"!==typeof u||u)&&this.options.defines.push(F+u),this}isReadyForSubMesh(B,u,F){return this.isReady(B,F,u)}isReady(B,u,F){var Z;const p=F&&this._storeEffectOnSubMeshes;if(this.isFrozen){const B=p?F._drawWrapper:this._drawWrapper;if(B.effect&&B._wasPreviouslyReady&&B._wasPreviouslyUsingInstances===u)return!0}const R=this.yB(),e=R.getEngine(),Y=[],Q=[];let t=null,q=this._shaderPath,W=this._options.uniforms,X=this._options.uniformBuffers,f=this._options.samplers;e.getCaps().multiview&&R.activeCamera&&R.activeCamera.outputRenderTarget&&R.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,Y.push("#define MULTIVIEW"),-1!==W.indexOf("viewProjection")&&-1===W.indexOf("viewProjectionR")&&W.push("viewProjectionR"));for(let V=0;V<this._options.defines.length;V++){const B=0===this._options.defines[V].indexOf("#define")?this._options.defines[V]:`#define ${this._options.defines[V]}`;Y.push(B)}for(let V=0;V<this._options.attributes.length;V++)Q.push(this._options.attributes[V]);if(B&&B.isVerticesDataPresent(G.f.ColorKind)&&(-1===Q.indexOf(G.f.ColorKind)&&Q.push(G.f.ColorKind),Y.push("#define VERTEXCOLOR")),u&&(Y.push("#define INSTANCES"),(0,D.$)(Q,this._materialHelperNeedsPreviousMatrices),null!==B&&void 0!==B&&B.hasThinInstances&&(Y.push("#define THIN_INSTANCES"),B&&B.isVerticesDataPresent(G.f.ColorInstanceKind)&&(Q.push(G.f.ColorInstanceKind),Y.push("#define INSTANCESCOLOR")))),B&&B.useBones&&B.computeBonesUsingShaders&&B.skeleton){Q.push(G.f.MatricesIndicesKind),Q.push(G.f.MatricesWeightsKind),B.numBoneInfluencers>4&&(Q.push(G.f.MatricesIndicesExtraKind),Q.push(G.f.MatricesWeightsExtraKind));const u=B.skeleton;Y.push("#define NUM_BONE_INFLUENCERS "+B.numBoneInfluencers),t=new s.c,t.addCPUSkinningFallback(0,B),u.isUsingTextureForMatrices?(Y.push("#define BONETEXTURE"),-1===W.indexOf("boneTextureWidth")&&W.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(Y.push("#define BonesPerMesh "+(u.bones.length+1)),-1===W.indexOf("mBones")&&W.push("mBones"))}else Y.push("#define NUM_BONE_INFLUENCERS 0");let C=0;const x=B?B.morphTargetManager:null;if(x){const u=-1!==Y.indexOf("#define UV1"),F=-1!==Y.indexOf("#define UV2"),Z=-1!==Y.indexOf("#define TANGENT"),V=-1!==Y.indexOf("#define NORMAL"),p=-1!==Y.indexOf("#define VERTEXCOLOR");C=(0,D.D)(x,Y,Q,B,!0,V,Z,u,F,p),x.isUsingTextureForTargets&&(-1===W.indexOf("morphTargetTextureIndices")&&W.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),C>0&&(W=W.slice(),W.push("morphTargetInfluences"),W.push("morphTargetCount"),W.push("morphTargetTextureInfo"),W.push("morphTargetTextureIndices"))}else Y.push("#define NUM_MORPH_INFLUENCERS 0");if(B){const u=B.bakedVertexAnimationManager;u&&u.isEnabled&&(Y.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===W.indexOf("bakedVertexAnimationSettings")&&W.push("bakedVertexAnimationSettings"),-1===W.indexOf("bakedVertexAnimationTextureSizeInverted")&&W.push("bakedVertexAnimationTextureSizeInverted"),-1===W.indexOf("bakedVertexAnimationTime")&&W.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,D.x)(Q,B,Y)}for(const V in this._textures)if(!this._textures[V].isReady())return!1;B&&this.needAlphaTestingForMesh(B)&&Y.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,v.c)(W),(0,v.k)(this,R,Y)),R.fogEnabled&&null!==B&&void 0!==B&&B.applyFog&&R.fogMode!==V.e.FOGMODE_NONE&&(Y.push("#define FOG"),-1===W.indexOf("view")&&W.push("view"),-1===W.indexOf("vFogInfos")&&W.push("vFogInfos"),-1===W.indexOf("vFogColor")&&W.push("vFogColor")),this._useLogarithmicDepth&&(Y.push("#define LOGARITHMICDEPTH"),-1===W.indexOf("logarithmicDepthConstant")&&W.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(W=W.slice(),X=X.slice(),f=f.slice(),q=this.customShaderNameResolve(this.name,W,X,f,Y,Q));const U=p?F._getDrawWrapper(void 0,!0):this._drawWrapper,y=(null===U||void 0===U?void 0:U.effect)??null,O=(null===U||void 0===U?void 0:U.defines)??null,g=Y.join("\n");let J=y;return O!==g&&(J=e.createEffect(q,{attributes:Q,uniformsNames:W,uniformBuffersNames:X,samplers:f,defines:g,fallbacks:t,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:C},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},e),p?F.setEffect(J,g,this._materialContext):U&&U.setEffect(J,g),this._onEffectCreatedObservable&&(L.effect=J,L.subMesh=F??(null===B||void 0===B?void 0:B.vR[0])??null,this._onEffectCreatedObservable.notifyObservers(L))),U._wasPreviouslyUsingInstances=!!u,!(null===(Z=J)||void 0===Z||!Z.isReady())&&(y!==J&&R.resetCachedMaterial(),U._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(B,u){const F=u??this.getEffect();if(!F)return;const Z=this._options.uniforms;-1!==Z.indexOf("world")&&F.setMatrix("world",B);const V=this.yB();-1!==Z.indexOf("worldView")&&(B.multiplyToRef(V.getViewMatrix(),this._cachedWorldViewMatrix),F.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==Z.indexOf("worldViewProjection")&&(B.multiplyToRef(V.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),F.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==Z.indexOf("view")&&F.setMatrix("view",V.getViewMatrix())}bindForSubMesh(B,u,F){var Z;this.bind(B,u,null===(Z=F._drawWrapperOverride)||void 0===Z?void 0:Z.effect,F)}bind(B,u,F,Z){const V=Z&&this._storeEffectOnSubMeshes,p=F??(V?Z.effect:this.getEffect());if(!p)return;const G=this.yB();this._activeEffect=p,this.bindOnlyWorldMatrix(B,F);const R=this._options.uniformBuffers;let e=!1;if(p&&R&&R.length>0&&G.getEngine().supportsUniformBuffers)for(let Q=0;Q<R.length;++Q){switch(R[Q]){case"Mesh":u&&(u.getMeshUniformBuffer().bindToEffect(p,"Mesh"),u.transferToEffect(B));break;case"Scene":(0,D.l)(p,G.getSceneUniformBuffer()),G.finalizeSceneUbo(),e=!0}}const s=u&&V?this._mustRebind(G,p,Z,u.visibility):G.getCachedMaterial()!==this;if(p&&s){let B;for(B in e||-1===this._options.uniforms.indexOf("view")||p.setMatrix("view",G.getViewMatrix()),e||-1===this._options.uniforms.indexOf("projection")||p.setMatrix("projection",G.getProjectionMatrix()),e||-1===this._options.uniforms.indexOf("viewProjection")||(p.setMatrix("viewProjection",G.getTransformMatrix()),this._multiview&&p.setMatrix("viewProjectionR",G._transformMatrixR)),G.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&p.setVector3("cameraPosition",G.activeCamera.globalPosition),(0,D.c)(u,p),(0,v.g)(p,this,G),this._useLogarithmicDepth&&(0,D.h)(V?Z.materialDefines:p.defines,p,G),u&&(0,D.d)(G,u,p),this._textures)p.setTexture(B,this._textures[B]);for(B in this._textureArrays)p.setTextureArray(B,this._textureArrays[B]);for(B in this._ints)p.setInt(B,this._ints[B]);for(B in this._uints)p.setUInt(B,this._uints[B]);for(B in this._floats)p.setFloat(B,this._floats[B]);for(B in this._floatsArrays)p.setArray(B,this._floatsArrays[B]);for(B in this._colors3)p.setColor3(B,this._colors3[B]);for(B in this._colors3Arrays)p.setArray3(B,this._colors3Arrays[B]);for(B in this._colors4){const u=this._colors4[B];p.setFloat4(B,u.r,u.g,u.b,u.a)}for(B in this._colors4Arrays)p.setArray4(B,this._colors4Arrays[B]);for(B in this._vectors2)p.setVector2(B,this._vectors2[B]);for(B in this._vectors3)p.setVector3(B,this._vectors3[B]);for(B in this._vectors4)p.setVector4(B,this._vectors4[B]);for(B in this._quaternions)p.setQuaternion(B,this._quaternions[B]);for(B in this._matrices)p.setMatrix(B,this._matrices[B]);for(B in this._matrixArrays)p.setMatrices(B,this._matrixArrays[B]);for(B in this._matrices3x3)p.setMatrix3x3(B,this._matrices3x3[B]);for(B in this._matrices2x2)p.setMatrix2x2(B,this._matrices2x2[B]);for(B in this._vectors2Arrays)p.setArray2(B,this._vectors2Arrays[B]);for(B in this._vectors3Arrays)p.setArray3(B,this._vectors3Arrays[B]);for(B in this._vectors4Arrays)p.setArray4(B,this._vectors4Arrays[B]);for(B in this._quaternionsArrays)p.setArray4(B,this._quaternionsArrays[B]);for(B in this._uniformBuffers){const u=this._uniformBuffers[B].getBuffer();u&&p.bindUniformBuffer(u,B)}const F=G.getEngine(),R=F.setExternalTexture;if(R)for(B in this._externalTextures)R.call(F,B,this._externalTextures[B]);const s=F.setTextureSampler;if(s)for(B in this._textureSamplers)s.call(F,B,this._textureSamplers[B]);const Y=F.setStorageBuffer;if(Y)for(B in this._storageBuffers)Y.call(F,B,this._storageBuffers[B])}if(p&&u&&(s||!this.isFrozen)){(0,D.i)(u,p),u.morphTargetManager&&u.morphTargetManager.isUsingTextureForTargets&&u.morphTargetManager._bind(p);const B=u.bakedVertexAnimationManager;if(B&&B.isEnabled){var Y;const B=V?Z._drawWrapper:this._drawWrapper;null===(Y=u.bakedVertexAnimationManager)||void 0===Y||Y.bind(p,!!B._wasPreviouslyUsingInstances)}}this._afterBind(u,p,Z)}getActiveTextures(){const B=super.getActiveTextures();for(const u in this._textures)B.push(this._textures[u]);for(const u in this._textureArrays){const F=this._textureArrays[u];for(let u=0;u<F.length;u++)B.push(F[u])}return B}hasTexture(B){if(super.hasTexture(B))return!0;for(const u in this._textures)if(this._textures[u]===B)return!0;for(const u in this._textureArrays){const F=this._textureArrays[u];for(let u=0;u<F.length;u++)if(F[u]===B)return!0}return!1}clone(B){const u=Z.c.Clone((()=>new q(B,this.yB(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);u.name=B,u.id=B,"object"===typeof u._shaderPath&&(u._shaderPath={...u._shaderPath}),this._options={...this._options};const F=Object.keys(this._options);for(const Z of F){const B=this._options[Z];Array.isArray(B)&&(this._options[Z]=B.slice(0))}this.RR.copyTo(u.RR);for(const Z in this._textures)u.setTexture(Z,this._textures[Z]);for(const Z in this._textureArrays)u.setTextureArray(Z,this._textureArrays[Z]);for(const Z in this._externalTextures)u.setExternalTexture(Z,this._externalTextures[Z]);for(const Z in this._ints)u.setInt(Z,this._ints[Z]);for(const Z in this._uints)u.setUInt(Z,this._uints[Z]);for(const Z in this._floats)u.setFloat(Z,this._floats[Z]);for(const Z in this._floatsArrays)u.setFloats(Z,this._floatsArrays[Z]);for(const Z in this._colors3)u.setColor3(Z,this._colors3[Z]);for(const Z in this._colors3Arrays)u._colors3Arrays[Z]=this._colors3Arrays[Z];for(const Z in this._colors4)u.setColor4(Z,this._colors4[Z]);for(const Z in this._colors4Arrays)u._colors4Arrays[Z]=this._colors4Arrays[Z];for(const Z in this._vectors2)u.setVector2(Z,this._vectors2[Z]);for(const Z in this._vectors3)u.setVector3(Z,this._vectors3[Z]);for(const Z in this._vectors4)u.setVector4(Z,this._vectors4[Z]);for(const Z in this._quaternions)u.setQuaternion(Z,this._quaternions[Z]);for(const Z in this._quaternionsArrays)u._quaternionsArrays[Z]=this._quaternionsArrays[Z];for(const Z in this._matrices)u.setMatrix(Z,this._matrices[Z]);for(const Z in this._matrixArrays)u._matrixArrays[Z]=this._matrixArrays[Z].slice();for(const Z in this._matrices3x3)u.setMatrix3x3(Z,this._matrices3x3[Z]);for(const Z in this._matrices2x2)u.setMatrix2x2(Z,this._matrices2x2[Z]);for(const Z in this._vectors2Arrays)u.setArray2(Z,this._vectors2Arrays[Z]);for(const Z in this._vectors3Arrays)u.setArray3(Z,this._vectors3Arrays[Z]);for(const Z in this._vectors4Arrays)u.setArray4(Z,this._vectors4Arrays[Z]);for(const Z in this._uniformBuffers)u.setUniformBuffer(Z,this._uniformBuffers[Z]);for(const Z in this._textureSamplers)u.setTextureSampler(Z,this._textureSamplers[Z]);for(const Z in this._storageBuffers)u.setStorageBuffer(Z,this._storageBuffers[Z]);return u}dispose(B,u,F){if(u){let B;for(B in this._textures)this._textures[B].dispose();for(B in this._textureArrays){const u=this._textureArrays[B];for(let B=0;B<u.length;B++)u[B].dispose()}}this._textures={},super.dispose(B,u,F)}serialize(){const B=Z.c.Serialize(this);let u;for(u in B.customType="BABYLON.ShaderMaterial",B.uniqueId=this.uniqueId,B.options=this._options,B.shaderPath=this._shaderPath,B.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,B.RR=this.RR.serialize(),B.textures={},this._textures)B.textures[u]=this._textures[u].serialize();for(u in B.textureArrays={},this._textureArrays){B.textureArrays[u]=[];const F=this._textureArrays[u];for(let Z=0;Z<F.length;Z++)B.textureArrays[u].push(F[Z].serialize())}for(u in B.ints={},this._ints)B.ints[u]=this._ints[u];for(u in B.uints={},this._uints)B.uints[u]=this._uints[u];for(u in B.floats={},this._floats)B.floats[u]=this._floats[u];for(u in B.floatsArrays={},this._floatsArrays)B.floatsArrays[u]=this._floatsArrays[u];for(u in B.colors3={},this._colors3){const F=this._colors3[u];B.colors3[u]=[F.r,F.g,F.b]}for(u in B.colors3Arrays={},this._colors3Arrays)B.colors3Arrays[u]=this._colors3Arrays[u];for(u in B.colors4={},this._colors4){const F=this._colors4[u];B.colors4[u]=[F.r,F.g,F.b,F.a]}for(u in B.colors4Arrays={},this._colors4Arrays)B.colors4Arrays[u]=this._colors4Arrays[u];for(u in B.vectors2={},this._vectors2){const F=this._vectors2[u];B.vectors2[u]=[F.x,F.y]}for(u in B.vectors3={},this._vectors3){const F=this._vectors3[u];B.vectors3[u]=[F.x,F.y,F.z]}for(u in B.vectors4={},this._vectors4){const F=this._vectors4[u];B.vectors4[u]=[F.x,F.y,F.z,F.w]}for(u in B.quaternions={},this._quaternions)B.quaternions[u]=this._quaternions[u].DR();for(u in B.matrices={},this._matrices)B.matrices[u]=this._matrices[u].DR();for(u in B.matrixArray={},this._matrixArrays)B.matrixArray[u]=this._matrixArrays[u];for(u in B.matrices3x3={},this._matrices3x3)B.matrices3x3[u]=this._matrices3x3[u];for(u in B.matrices2x2={},this._matrices2x2)B.matrices2x2[u]=this._matrices2x2[u];for(u in B.vectors2Arrays={},this._vectors2Arrays)B.vectors2Arrays[u]=this._vectors2Arrays[u];for(u in B.vectors3Arrays={},this._vectors3Arrays)B.vectors3Arrays[u]=this._vectors3Arrays[u];for(u in B.vectors4Arrays={},this._vectors4Arrays)B.vectors4Arrays[u]=this._vectors4Arrays[u];for(u in B.quaternionsArrays={},this._quaternionsArrays)B.quaternionsArrays[u]=this._quaternionsArrays[u];return B}static Parse(B,u,F){const V=Z.c.Parse((()=>new q(B.name,u,B.shaderPath,B.options,B.storeEffectOnSubMeshes)),B,u,F);let G;for(G in B.RR&&V.RR.parse(B.RR,u,F),B.textures)V.setTexture(G,R.d.Parse(B.textures[G],u,F));for(G in B.textureArrays){const Z=B.textureArrays[G],p=[];for(let B=0;B<Z.length;B++)p.push(R.d.Parse(Z[B],u,F));V.setTextureArray(G,p)}for(G in B.ints)V.setInt(G,B.ints[G]);for(G in B.uints)V.setUInt(G,B.uints[G]);for(G in B.floats)V.setFloat(G,B.floats[G]);for(G in B.floatsArrays)V.setFloats(G,B.floatsArrays[G]);for(G in B.colors3){const u=B.colors3[G];V.setColor3(G,{r:u[0],g:u[1],b:u[2]})}for(G in B.colors3Arrays){const u=B.colors3Arrays[G].reduce(((B,u,F)=>(F%3===0?B.push([u]):B[B.length-1].push(u),B)),[]).map((B=>({r:B[0],g:B[1],b:B[2]})));V.setColor3Array(G,u)}for(G in B.colors4){const u=B.colors4[G];V.setColor4(G,{r:u[0],g:u[1],b:u[2],a:u[3]})}for(G in B.colors4Arrays){const u=B.colors4Arrays[G].reduce(((B,u,F)=>(F%4===0?B.push([u]):B[B.length-1].push(u),B)),[]).map((B=>({r:B[0],g:B[1],b:B[2],a:B[3]})));V.setColor4Array(G,u)}for(G in B.vectors2){const u=B.vectors2[G];V.setVector2(G,{x:u[0],y:u[1]})}for(G in B.vectors3){const u=B.vectors3[G];V.setVector3(G,{x:u[0],y:u[1],z:u[2]})}for(G in B.vectors4){const u=B.vectors4[G];V.setVector4(G,{x:u[0],y:u[1],z:u[2],w:u[3]})}for(G in B.quaternions)V.setQuaternion(G,p.Quaternion.fu(B.quaternions[G]));for(G in B.matrices)V.setMatrix(G,p.Matrix.fu(B.matrices[G]));for(G in B.matrixArray)V._matrixArrays[G]=new Float32Array(B.matrixArray[G]);for(G in B.matrices3x3)V.setMatrix3x3(G,B.matrices3x3[G]);for(G in B.matrices2x2)V.setMatrix2x2(G,B.matrices2x2[G]);for(G in B.vectors2Arrays)V.setArray2(G,B.vectors2Arrays[G]);for(G in B.vectors3Arrays)V.setArray3(G,B.vectors3Arrays[G]);for(G in B.vectors4Arrays)V.setArray4(G,B.vectors4Arrays[G]);for(G in B.quaternionsArrays)V.setArray4(G,B.quaternionsArrays[G]);return V}static async ParseFromFileAsync(B,u,F){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((V,p)=>{const G=new Y.c;G.addEventListener("readystatechange",(()=>{if(4==G.readyState)if(200==G.status){const u=JSON.parse(G.responseText),p=this.Parse(u,F||t.b.LastCreatedScene,Z);B&&(p.name=B),V(p)}else p("Unable to load the ShaderMaterial")})),G.open("GET",u),G.send()}))}static async ParseFromSnippetAsync(B,u){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((Z,V)=>{const p=new Y.c;p.addEventListener("readystatechange",(()=>{if(4==p.readyState)if(200==p.status){const V=JSON.parse(JSON.parse(p.responseText).jsonPayload),G=JSON.parse(V.shaderMaterial),R=this.Parse(G,u||t.b.LastCreatedScene,F);R.snippetId=B,Z(R)}else V("Unable to load the snippet "+B)})),p.open("GET",this.SnippetUrl+"/"+B.replace(/#/g,"/")),p.send()}))}}q.SnippetUrl="https://snippet.babylonjs.com",q.CreateFromSnippetAsync=q.ParseFromSnippetAsync,(0,e.f)("BABYLON.ShaderMaterial",q)}}]);