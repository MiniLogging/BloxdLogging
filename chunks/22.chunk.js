"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[22],{12565:(E,U,g)=>{g.r(U),g.d(U,{ShaderMaterial:()=>y});var N=g(12367),L=g(12573),D=g(12334),S=g(12407),u=g(12311),s=g(12292),C=g(12646),B=g(12202),P=g(12652),F=g(12205),f=g(12699),d=g(12693);const I={effect:null,subMesh:null};class y extends P.e{constructor(E,U,g){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(E,U,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new D.Matrix,this._cachedWorldViewProjectionMatrix=new D.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=g,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...N}}get shaderPath(){return this._shaderPath}set shaderPath(E){this._shaderPath=E}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(E){-1===this._options.uniforms.indexOf(E)&&this._options.uniforms.push(E)}setTexture(E,U){return-1===this._options.samplers.indexOf(E)&&this._options.samplers.push(E),this._textures[E]=U,this}removeTexture(E){delete this._textures[E]}setTextureArray(E,U){return-1===this._options.samplers.indexOf(E)&&this._options.samplers.push(E),this._checkUniform(E),this._textureArrays[E]=U,this}setExternalTexture(E,U){return-1===this._options.externalTextures.indexOf(E)&&this._options.externalTextures.push(E),this._externalTextures[E]=U,this}setFloat(E,U){return this._checkUniform(E),this._floats[E]=U,this}setInt(E,U){return this._checkUniform(E),this._ints[E]=U,this}setUInt(E,U){return this._checkUniform(E),this._uints[E]=U,this}setFloats(E,U){return this._checkUniform(E),this._floatsArrays[E]=U,this}setColor3(E,U){return this._checkUniform(E),this._colors3[E]=U,this}setColor3Array(E,U){return this._checkUniform(E),this._colors3Arrays[E]=U.reduce(((E,U)=>(E.push(U.r,U.g,U.b),E)),[]),this}setColor4(E,U){return this._checkUniform(E),this._colors4[E]=U,this}setColor4Array(E,U){return this._checkUniform(E),this._colors4Arrays[E]=U.reduce(((E,U)=>(E.push(U.r,U.g,U.b,U.a),E)),[]),this}setVector2(E,U){return this._checkUniform(E),this._vectors2[E]=U,this}setVector3(E,U){return this._checkUniform(E),this._vectors3[E]=U,this}setVector4(E,U){return this._checkUniform(E),this._vectors4[E]=U,this}setQuaternion(E,U){return this._checkUniform(E),this._quaternions[E]=U,this}setQuaternionArray(E,U){return this._checkUniform(E),this._quaternionsArrays[E]=U.reduce(((E,U)=>(U.toArray(E,E.length),E)),[]),this}setMatrix(E,U){return this._checkUniform(E),this._matrices[E]=U,this}setMatrices(E,U){this._checkUniform(E);const g=new Float32Array(16*U.length);for(let N=0;N<U.length;N++){U[N].copyToArray(g,16*N)}return this._matrixArrays[E]=g,this}setMatrix3x3(E,U){return this._checkUniform(E),this._matrices3x3[E]=U,this}setMatrix2x2(E,U){return this._checkUniform(E),this._matrices2x2[E]=U,this}setArray2(E,U){return this._checkUniform(E),this._vectors2Arrays[E]=U,this}setArray3(E,U){return this._checkUniform(E),this._vectors3Arrays[E]=U,this}setArray4(E,U){return this._checkUniform(E),this._vectors4Arrays[E]=U,this}setUniformBuffer(E,U){return-1===this._options.uniformBuffers.indexOf(E)&&this._options.uniformBuffers.push(E),this._uniformBuffers[E]=U,this}setTextureSampler(E,U){return-1===this._options.samplerObjects.indexOf(E)&&this._options.samplerObjects.push(E),this._textureSamplers[E]=U,this}setStorageBuffer(E,U){return-1===this._options.storageBuffers.indexOf(E)&&this._options.storageBuffers.push(E),this._storageBuffers[E]=U,this}setDefine(E,U){const g=E.trimEnd()+" ",N=this.options.defines.findIndex((U=>U===E||U.startsWith(g)));return N>=0&&this.options.defines.splice(N,1),("boolean"!==typeof U||U)&&this.options.defines.push(g+U),this}isReadyForSubMesh(E,U,g){return this.isReady(E,g,U)}isReady(E,U,g){var N;const D=g&&this._storeEffectOnSubMeshes;if(this.isFrozen){const E=D?g._drawWrapper:this._drawWrapper;if(E.effect&&E._wasPreviouslyReady&&E._wasPreviouslyUsingInstances===U)return!0}const u=this.tE(),s=u.getEngine(),B=[],P=[];let F=null,y=this._shaderPath,h=this._options.uniforms,V=this._options.uniformBuffers,e=this._options.samplers;s.getCaps().multiview&&u.activeCamera&&u.activeCamera.outputRenderTarget&&u.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,B.push("#define MULTIVIEW"),-1!==h.indexOf("viewProjection")&&-1===h.indexOf("viewProjectionR")&&h.push("viewProjectionR"));for(let L=0;L<this._options.defines.length;L++){const E=0===this._options.defines[L].indexOf("#define")?this._options.defines[L]:`#define ${this._options.defines[L]}`;B.push(E)}for(let L=0;L<this._options.attributes.length;L++)P.push(this._options.attributes[L]);if(E&&E.isVerticesDataPresent(S.f.ColorKind)&&(-1===P.indexOf(S.f.ColorKind)&&P.push(S.f.ColorKind),B.push("#define VERTEXCOLOR")),U&&(B.push("#define INSTANCES"),(0,d.bb)(P,this._materialHelperNeedsPreviousMatrices),null!==E&&void 0!==E&&E.hasThinInstances&&(B.push("#define THIN_INSTANCES"),E&&E.isVerticesDataPresent(S.f.ColorInstanceKind)&&(P.push(S.f.ColorInstanceKind),B.push("#define INSTANCESCOLOR")))),E&&E.useBones&&E.computeBonesUsingShaders&&E.skeleton){P.push(S.f.MatricesIndicesKind),P.push(S.f.MatricesWeightsKind),E.numBoneInfluencers>4&&(P.push(S.f.MatricesIndicesExtraKind),P.push(S.f.MatricesWeightsExtraKind));const U=E.skeleton;B.push("#define NUM_BONE_INFLUENCERS "+E.numBoneInfluencers),F=new C.b,F.addCPUSkinningFallback(0,E),U.isUsingTextureForMatrices?(B.push("#define BONETEXTURE"),-1===h.indexOf("boneTextureWidth")&&h.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(B.push("#define BonesPerMesh "+(U.bones.length+1)),-1===h.indexOf("mBones")&&h.push("mBones"))}else B.push("#define NUM_BONE_INFLUENCERS 0");let x=0;const l=E?E.morphTargetManager:null;if(l){const U=-1!==B.indexOf("#define UV1"),g=-1!==B.indexOf("#define UV2"),N=-1!==B.indexOf("#define TANGENT"),L=-1!==B.indexOf("#define NORMAL"),D=-1!==B.indexOf("#define VERTEXCOLOR");x=(0,d.F)(l,B,P,E,!0,L,N,U,g,D),l.isUsingTextureForTargets&&(-1===h.indexOf("morphTargetTextureIndices")&&h.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),x>0&&(h=h.slice(),h.push("morphTargetInfluences"),h.push("morphTargetCount"),h.push("morphTargetTextureInfo"),h.push("morphTargetTextureIndices"))}else B.push("#define NUM_MORPH_INFLUENCERS 0");if(E){const U=E.bakedVertexAnimationManager;U&&U.isEnabled&&(B.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===h.indexOf("bakedVertexAnimationSettings")&&h.push("bakedVertexAnimationSettings"),-1===h.indexOf("bakedVertexAnimationTextureSizeInverted")&&h.push("bakedVertexAnimationTextureSizeInverted"),-1===h.indexOf("bakedVertexAnimationTime")&&h.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,d.y)(P,E,B)}for(const L in this._textures)if(!this._textures[L].isReady())return!1;E&&this.needAlphaTestingForMesh(E)&&B.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,f.d)(h),(0,f.k)(this,u,B)),u.fogEnabled&&null!==E&&void 0!==E&&E.applyFog&&u.fogMode!==L.c.FOGMODE_NONE&&(B.push("#define FOG"),-1===h.indexOf("view")&&h.push("view"),-1===h.indexOf("vFogInfos")&&h.push("vFogInfos"),-1===h.indexOf("vFogColor")&&h.push("vFogColor")),this._useLogarithmicDepth&&(B.push("#define LOGARITHMICDEPTH"),-1===h.indexOf("logarithmicDepthConstant")&&h.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(h=h.slice(),V=V.slice(),e=e.slice(),y=this.customShaderNameResolve(this.name,h,V,e,B,P));const Y=D?g._getDrawWrapper(void 0,!0):this._drawWrapper,t=(null===Y||void 0===Y?void 0:Y.effect)??null,G=(null===Y||void 0===Y?void 0:Y.defines)??null,b=B.join("\n");let T=t;return G!==b&&(T=s.createEffect(y,{attributes:P,uniformsNames:h,uniformBuffersNames:V,samplers:e,defines:b,fallbacks:F,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:x},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},s),D?g.setEffect(T,b,this._materialContext):Y&&Y.setEffect(T,b),this._onEffectCreatedObservable&&(I.effect=T,I.subMesh=g??(null===E||void 0===E?void 0:E.Wg[0])??null,this._onEffectCreatedObservable.notifyObservers(I))),Y._wasPreviouslyUsingInstances=!!U,!(null===(N=T)||void 0===N||!N.isReady())&&(t!==T&&u.resetCachedMaterial(),Y._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(E,U){const g=U??this.getEffect();if(!g)return;const N=this._options.uniforms;-1!==N.indexOf("world")&&g.setMatrix("world",E);const L=this.tE();-1!==N.indexOf("worldView")&&(E.multiplyToRef(L.getViewMatrix(),this._cachedWorldViewMatrix),g.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==N.indexOf("worldViewProjection")&&(E.multiplyToRef(L.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),g.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==N.indexOf("view")&&g.setMatrix("view",L.getViewMatrix())}bindForSubMesh(E,U,g){var N;this.bind(E,U,null===(N=g._drawWrapperOverride)||void 0===N?void 0:N.effect,g)}bind(E,U,g,N){const L=N&&this._storeEffectOnSubMeshes,D=g??(L?N.effect:this.getEffect());if(!D)return;const S=this.tE();this._activeEffect=D,this.bindOnlyWorldMatrix(E,g);const u=this._options.uniformBuffers;let s=!1;if(D&&u&&u.length>0&&S.getEngine().supportsUniformBuffers)for(let P=0;P<u.length;++P){switch(u[P]){case"Mesh":U&&(U.getMeshUniformBuffer().bindToEffect(D,"Mesh"),U.transferToEffect(E));break;case"Scene":(0,d.p)(D,S.getSceneUniformBuffer()),S.finalizeSceneUbo(),s=!0}}const C=U&&L?this._mustRebind(S,D,N,U.visibility):S.getCachedMaterial()!==this;if(D&&C){let E;for(E in s||-1===this._options.uniforms.indexOf("view")||D.setMatrix("view",S.getViewMatrix()),s||-1===this._options.uniforms.indexOf("projection")||D.setMatrix("projection",S.getProjectionMatrix()),s||-1===this._options.uniforms.indexOf("viewProjection")||(D.setMatrix("viewProjection",S.getTransformMatrix()),this._multiview&&D.setMatrix("viewProjectionR",S._transformMatrixR)),S.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&D.setVector3("cameraPosition",S.activeCamera.globalPosition),(0,d.e)(U,D),(0,f.e)(D,this,S),this._useLogarithmicDepth&&(0,d.k)(L?N.materialDefines:D.defines,D,S),U&&(0,d.f)(S,U,D),this._textures)D.setTexture(E,this._textures[E]);for(E in this._textureArrays)D.setTextureArray(E,this._textureArrays[E]);for(E in this._ints)D.setInt(E,this._ints[E]);for(E in this._uints)D.setUInt(E,this._uints[E]);for(E in this._floats)D.setFloat(E,this._floats[E]);for(E in this._floatsArrays)D.setArray(E,this._floatsArrays[E]);for(E in this._colors3)D.setColor3(E,this._colors3[E]);for(E in this._colors3Arrays)D.setArray3(E,this._colors3Arrays[E]);for(E in this._colors4){const U=this._colors4[E];D.setFloat4(E,U.r,U.g,U.b,U.a)}for(E in this._colors4Arrays)D.setArray4(E,this._colors4Arrays[E]);for(E in this._vectors2)D.setVector2(E,this._vectors2[E]);for(E in this._vectors3)D.setVector3(E,this._vectors3[E]);for(E in this._vectors4)D.setVector4(E,this._vectors4[E]);for(E in this._quaternions)D.setQuaternion(E,this._quaternions[E]);for(E in this._matrices)D.setMatrix(E,this._matrices[E]);for(E in this._matrixArrays)D.setMatrices(E,this._matrixArrays[E]);for(E in this._matrices3x3)D.setMatrix3x3(E,this._matrices3x3[E]);for(E in this._matrices2x2)D.setMatrix2x2(E,this._matrices2x2[E]);for(E in this._vectors2Arrays)D.setArray2(E,this._vectors2Arrays[E]);for(E in this._vectors3Arrays)D.setArray3(E,this._vectors3Arrays[E]);for(E in this._vectors4Arrays)D.setArray4(E,this._vectors4Arrays[E]);for(E in this._quaternionsArrays)D.setArray4(E,this._quaternionsArrays[E]);for(E in this._uniformBuffers){const U=this._uniformBuffers[E].getBuffer();U&&D.bindUniformBuffer(U,E)}const g=S.getEngine(),u=g.setExternalTexture;if(u)for(E in this._externalTextures)u.call(g,E,this._externalTextures[E]);const C=g.setTextureSampler;if(C)for(E in this._textureSamplers)C.call(g,E,this._textureSamplers[E]);const B=g.setStorageBuffer;if(B)for(E in this._storageBuffers)B.call(g,E,this._storageBuffers[E])}if(D&&U&&(C||!this.isFrozen)){(0,d.o)(U,D),U.morphTargetManager&&U.morphTargetManager.isUsingTextureForTargets&&U.morphTargetManager._bind(D);const E=U.bakedVertexAnimationManager;if(E&&E.isEnabled){var B;const E=L?N._drawWrapper:this._drawWrapper;null===(B=U.bakedVertexAnimationManager)||void 0===B||B.bind(D,!!E._wasPreviouslyUsingInstances)}}this._afterBind(U,D,N)}getActiveTextures(){const E=super.getActiveTextures();for(const U in this._textures)E.push(this._textures[U]);for(const U in this._textureArrays){const g=this._textureArrays[U];for(let U=0;U<g.length;U++)E.push(g[U])}return E}hasTexture(E){if(super.hasTexture(E))return!0;for(const U in this._textures)if(this._textures[U]===E)return!0;for(const U in this._textureArrays){const g=this._textureArrays[U];for(let U=0;U<g.length;U++)if(g[U]===E)return!0}return!1}clone(E){const U=N.b.Clone((()=>new y(E,this.tE(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);U.name=E,U.id=E,"object"===typeof U._shaderPath&&(U._shaderPath={...U._shaderPath}),this._options={...this._options};const g=Object.keys(this._options);for(const N of g){const E=this._options[N];Array.isArray(E)&&(this._options[N]=E.slice(0))}this.Vg.copyTo(U.Vg);for(const N in this._textures)U.setTexture(N,this._textures[N]);for(const N in this._textureArrays)U.setTextureArray(N,this._textureArrays[N]);for(const N in this._externalTextures)U.setExternalTexture(N,this._externalTextures[N]);for(const N in this._ints)U.setInt(N,this._ints[N]);for(const N in this._uints)U.setUInt(N,this._uints[N]);for(const N in this._floats)U.setFloat(N,this._floats[N]);for(const N in this._floatsArrays)U.setFloats(N,this._floatsArrays[N]);for(const N in this._colors3)U.setColor3(N,this._colors3[N]);for(const N in this._colors3Arrays)U._colors3Arrays[N]=this._colors3Arrays[N];for(const N in this._colors4)U.setColor4(N,this._colors4[N]);for(const N in this._colors4Arrays)U._colors4Arrays[N]=this._colors4Arrays[N];for(const N in this._vectors2)U.setVector2(N,this._vectors2[N]);for(const N in this._vectors3)U.setVector3(N,this._vectors3[N]);for(const N in this._vectors4)U.setVector4(N,this._vectors4[N]);for(const N in this._quaternions)U.setQuaternion(N,this._quaternions[N]);for(const N in this._quaternionsArrays)U._quaternionsArrays[N]=this._quaternionsArrays[N];for(const N in this._matrices)U.setMatrix(N,this._matrices[N]);for(const N in this._matrixArrays)U._matrixArrays[N]=this._matrixArrays[N].slice();for(const N in this._matrices3x3)U.setMatrix3x3(N,this._matrices3x3[N]);for(const N in this._matrices2x2)U.setMatrix2x2(N,this._matrices2x2[N]);for(const N in this._vectors2Arrays)U.setArray2(N,this._vectors2Arrays[N]);for(const N in this._vectors3Arrays)U.setArray3(N,this._vectors3Arrays[N]);for(const N in this._vectors4Arrays)U.setArray4(N,this._vectors4Arrays[N]);for(const N in this._uniformBuffers)U.setUniformBuffer(N,this._uniformBuffers[N]);for(const N in this._textureSamplers)U.setTextureSampler(N,this._textureSamplers[N]);for(const N in this._storageBuffers)U.setStorageBuffer(N,this._storageBuffers[N]);return U}dispose(E,U,g){if(U){let E;for(E in this._textures)this._textures[E].dispose();for(E in this._textureArrays){const U=this._textureArrays[E];for(let E=0;E<U.length;E++)U[E].dispose()}}this._textures={},super.dispose(E,U,g)}serialize(){const E=N.b.Serialize(this);let U;for(U in E.customType="BABYLON.ShaderMaterial",E.uniqueId=this.uniqueId,E.options=this._options,E.shaderPath=this._shaderPath,E.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,E.Vg=this.Vg.serialize(),E.textures={},this._textures)E.textures[U]=this._textures[U].serialize();for(U in E.textureArrays={},this._textureArrays){E.textureArrays[U]=[];const g=this._textureArrays[U];for(let N=0;N<g.length;N++)E.textureArrays[U].push(g[N].serialize())}for(U in E.ints={},this._ints)E.ints[U]=this._ints[U];for(U in E.uints={},this._uints)E.uints[U]=this._uints[U];for(U in E.floats={},this._floats)E.floats[U]=this._floats[U];for(U in E.floatsArrays={},this._floatsArrays)E.floatsArrays[U]=this._floatsArrays[U];for(U in E.colors3={},this._colors3){const g=this._colors3[U];E.colors3[U]=[g.r,g.g,g.b]}for(U in E.colors3Arrays={},this._colors3Arrays)E.colors3Arrays[U]=this._colors3Arrays[U];for(U in E.colors4={},this._colors4){const g=this._colors4[U];E.colors4[U]=[g.r,g.g,g.b,g.a]}for(U in E.colors4Arrays={},this._colors4Arrays)E.colors4Arrays[U]=this._colors4Arrays[U];for(U in E.vectors2={},this._vectors2){const g=this._vectors2[U];E.vectors2[U]=[g.x,g.y]}for(U in E.vectors3={},this._vectors3){const g=this._vectors3[U];E.vectors3[U]=[g.x,g.y,g.z]}for(U in E.vectors4={},this._vectors4){const g=this._vectors4[U];E.vectors4[U]=[g.x,g.y,g.z,g.w]}for(U in E.quaternions={},this._quaternions)E.quaternions[U]=this._quaternions[U].Og();for(U in E.matrices={},this._matrices)E.matrices[U]=this._matrices[U].Og();for(U in E.matrixArray={},this._matrixArrays)E.matrixArray[U]=this._matrixArrays[U];for(U in E.matrices3x3={},this._matrices3x3)E.matrices3x3[U]=this._matrices3x3[U];for(U in E.matrices2x2={},this._matrices2x2)E.matrices2x2[U]=this._matrices2x2[U];for(U in E.vectors2Arrays={},this._vectors2Arrays)E.vectors2Arrays[U]=this._vectors2Arrays[U];for(U in E.vectors3Arrays={},this._vectors3Arrays)E.vectors3Arrays[U]=this._vectors3Arrays[U];for(U in E.vectors4Arrays={},this._vectors4Arrays)E.vectors4Arrays[U]=this._vectors4Arrays[U];for(U in E.quaternionsArrays={},this._quaternionsArrays)E.quaternionsArrays[U]=this._quaternionsArrays[U];return E}static Parse(E,U,g){const L=N.b.Parse((()=>new y(E.name,U,E.shaderPath,E.options,E.storeEffectOnSubMeshes)),E,U,g);let S;for(S in E.Vg&&L.Vg.parse(E.Vg,U,g),E.textures)L.setTexture(S,u.c.Parse(E.textures[S],U,g));for(S in E.textureArrays){const N=E.textureArrays[S],D=[];for(let E=0;E<N.length;E++)D.push(u.c.Parse(N[E],U,g));L.setTextureArray(S,D)}for(S in E.ints)L.setInt(S,E.ints[S]);for(S in E.uints)L.setUInt(S,E.uints[S]);for(S in E.floats)L.setFloat(S,E.floats[S]);for(S in E.floatsArrays)L.setFloats(S,E.floatsArrays[S]);for(S in E.colors3){const U=E.colors3[S];L.setColor3(S,{r:U[0],g:U[1],b:U[2]})}for(S in E.colors3Arrays){const U=E.colors3Arrays[S].reduce(((E,U,g)=>(g%3===0?E.push([U]):E[E.length-1].push(U),E)),[]).map((E=>({r:E[0],g:E[1],b:E[2]})));L.setColor3Array(S,U)}for(S in E.colors4){const U=E.colors4[S];L.setColor4(S,{r:U[0],g:U[1],b:U[2],a:U[3]})}for(S in E.colors4Arrays){const U=E.colors4Arrays[S].reduce(((E,U,g)=>(g%4===0?E.push([U]):E[E.length-1].push(U),E)),[]).map((E=>({r:E[0],g:E[1],b:E[2],a:E[3]})));L.setColor4Array(S,U)}for(S in E.vectors2){const U=E.vectors2[S];L.setVector2(S,{x:U[0],y:U[1]})}for(S in E.vectors3){const U=E.vectors3[S];L.setVector3(S,{x:U[0],y:U[1],z:U[2]})}for(S in E.vectors4){const U=E.vectors4[S];L.setVector4(S,{x:U[0],y:U[1],z:U[2],w:U[3]})}for(S in E.quaternions)L.setQuaternion(S,D.Quaternion.eU(E.quaternions[S]));for(S in E.matrices)L.setMatrix(S,D.Matrix.eU(E.matrices[S]));for(S in E.matrixArray)L._matrixArrays[S]=new Float32Array(E.matrixArray[S]);for(S in E.matrices3x3)L.setMatrix3x3(S,E.matrices3x3[S]);for(S in E.matrices2x2)L.setMatrix2x2(S,E.matrices2x2[S]);for(S in E.vectors2Arrays)L.setArray2(S,E.vectors2Arrays[S]);for(S in E.vectors3Arrays)L.setArray3(S,E.vectors3Arrays[S]);for(S in E.vectors4Arrays)L.setArray4(S,E.vectors4Arrays[S]);for(S in E.quaternionsArrays)L.setArray4(S,E.quaternionsArrays[S]);return L}static async ParseFromFileAsync(E,U,g){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((L,D)=>{const S=new B.e;S.addEventListener("readystatechange",(()=>{if(4==S.readyState)if(200==S.status){const U=JSON.parse(S.responseText),D=this.Parse(U,g||F.b.LastCreatedScene,N);E&&(D.name=E),L(D)}else D("Unable to load the ShaderMaterial")})),S.open("GET",U),S.send()}))}static async ParseFromSnippetAsync(E,U){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((N,L)=>{const D=new B.e;D.addEventListener("readystatechange",(()=>{if(4==D.readyState)if(200==D.status){const L=JSON.parse(JSON.parse(D.responseText).jsonPayload),S=JSON.parse(L.shaderMaterial),u=this.Parse(S,U||F.b.LastCreatedScene,g);u.snippetId=E,N(u)}else L("Unable to load the snippet "+E)})),D.open("GET",this.SnippetUrl+"/"+E.replace(/#/g,"/")),D.send()}))}}y.SnippetUrl="https://snippet.babylonjs.com",y.CreateFromSnippetAsync=y.ParseFromSnippetAsync,(0,s.f)("BABYLON.ShaderMaterial",y)}}]);