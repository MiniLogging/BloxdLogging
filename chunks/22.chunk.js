"use strict";(self["269hv5nclphh"]=self["269hv5nclphh"]||[]).push([[22],{12627:(E,H,d)=>{d.r(H),d.d(H,{ShaderMaterial:()=>Q});var n=d(12428),Z=d(12634),I=d(12384),g=d(12463),l=d(12366),r=d(12344),t=d(12712),S=d(12260),M=d(12721),V=d(12268),C=d(12768),w=d(12763);const R={effect:null,subMesh:null};class Q extends M.d{constructor(E,H,d){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(E,H,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new I.Matrix,this._cachedWorldViewProjectionMatrix=new I.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=d,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...n}}get shaderPath(){return this._shaderPath}set shaderPath(E){this._shaderPath=E}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(E){-1===this._options.uniforms.indexOf(E)&&this._options.uniforms.push(E)}setTexture(E,H){return-1===this._options.samplers.indexOf(E)&&this._options.samplers.push(E),this._textures[E]=H,this}removeTexture(E){delete this._textures[E]}setTextureArray(E,H){return-1===this._options.samplers.indexOf(E)&&this._options.samplers.push(E),this._checkUniform(E),this._textureArrays[E]=H,this}setExternalTexture(E,H){return-1===this._options.externalTextures.indexOf(E)&&this._options.externalTextures.push(E),this._externalTextures[E]=H,this}setFloat(E,H){return this._checkUniform(E),this._floats[E]=H,this}setInt(E,H){return this._checkUniform(E),this._ints[E]=H,this}setUInt(E,H){return this._checkUniform(E),this._uints[E]=H,this}setFloats(E,H){return this._checkUniform(E),this._floatsArrays[E]=H,this}setColor3(E,H){return this._checkUniform(E),this._colors3[E]=H,this}setColor3Array(E,H){return this._checkUniform(E),this._colors3Arrays[E]=H.reduce(((E,H)=>(E.push(H.r,H.g,H.b),E)),[]),this}setColor4(E,H){return this._checkUniform(E),this._colors4[E]=H,this}setColor4Array(E,H){return this._checkUniform(E),this._colors4Arrays[E]=H.reduce(((E,H)=>(E.push(H.r,H.g,H.b,H.a),E)),[]),this}setVector2(E,H){return this._checkUniform(E),this._vectors2[E]=H,this}setVector3(E,H){return this._checkUniform(E),this._vectors3[E]=H,this}setVector4(E,H){return this._checkUniform(E),this._vectors4[E]=H,this}setQuaternion(E,H){return this._checkUniform(E),this._quaternions[E]=H,this}setQuaternionArray(E,H){return this._checkUniform(E),this._quaternionsArrays[E]=H.reduce(((E,H)=>(H.toArray(E,E.length),E)),[]),this}setMatrix(E,H){return this._checkUniform(E),this._matrices[E]=H,this}setMatrices(E,H){this._checkUniform(E);const d=new Float32Array(16*H.length);for(let n=0;n<H.length;n++){H[n].copyToArray(d,16*n)}return this._matrixArrays[E]=d,this}setMatrix3x3(E,H){return this._checkUniform(E),this._matrices3x3[E]=H,this}setMatrix2x2(E,H){return this._checkUniform(E),this._matrices2x2[E]=H,this}setArray2(E,H){return this._checkUniform(E),this._vectors2Arrays[E]=H,this}setArray3(E,H){return this._checkUniform(E),this._vectors3Arrays[E]=H,this}setArray4(E,H){return this._checkUniform(E),this._vectors4Arrays[E]=H,this}setUniformBuffer(E,H){return-1===this._options.uniformBuffers.indexOf(E)&&this._options.uniformBuffers.push(E),this._uniformBuffers[E]=H,this}setTextureSampler(E,H){return-1===this._options.samplerObjects.indexOf(E)&&this._options.samplerObjects.push(E),this._textureSamplers[E]=H,this}setStorageBuffer(E,H){return-1===this._options.storageBuffers.indexOf(E)&&this._options.storageBuffers.push(E),this._storageBuffers[E]=H,this}setDefine(E,H){const d=E.trimEnd()+" ",n=this.options.defines.findIndex((H=>H===E||H.startsWith(d)));return n>=0&&this.options.defines.splice(n,1),("boolean"!==typeof H||H)&&this.options.defines.push(d+H),this}isReadyForSubMesh(E,H,d){return this.isReady(E,d,H)}isReady(E,H,d){var n;const I=d&&this._storeEffectOnSubMeshes;if(this.isFrozen){const E=I?d._drawWrapper:this._drawWrapper;if(E.effect&&E._wasPreviouslyReady&&E._wasPreviouslyUsingInstances===H)return!0}const l=this.fE(),r=l.getEngine(),S=[],M=[];let V=null,Q=this._shaderPath,L=this._options.uniforms,D=this._options.uniformBuffers,e=this._options.samplers;r.getCaps().multiview&&l.activeCamera&&l.activeCamera.outputRenderTarget&&l.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,S.push("#define MULTIVIEW"),-1!==L.indexOf("viewProjection")&&-1===L.indexOf("viewProjectionR")&&L.push("viewProjectionR"));for(let Z=0;Z<this._options.defines.length;Z++){const E=0===this._options.defines[Z].indexOf("#define")?this._options.defines[Z]:`#define ${this._options.defines[Z]}`;S.push(E)}for(let Z=0;Z<this._options.attributes.length;Z++)M.push(this._options.attributes[Z]);if(E&&E.isVerticesDataPresent(g.g.ColorKind)&&(-1===M.indexOf(g.g.ColorKind)&&M.push(g.g.ColorKind),S.push("#define VERTEXCOLOR")),H&&(S.push("#define INSTANCES"),(0,w.ab)(M,this._materialHelperNeedsPreviousMatrices),null!==E&&void 0!==E&&E.hasThinInstances&&(S.push("#define THIN_INSTANCES"),E&&E.isVerticesDataPresent(g.g.ColorInstanceKind)&&(M.push(g.g.ColorInstanceKind),S.push("#define INSTANCESCOLOR")))),E&&E.useBones&&E.computeBonesUsingShaders&&E.skeleton){M.push(g.g.MatricesIndicesKind),M.push(g.g.MatricesWeightsKind),E.numBoneInfluencers>4&&(M.push(g.g.MatricesIndicesExtraKind),M.push(g.g.MatricesWeightsExtraKind));const H=E.skeleton;S.push("#define NUM_BONE_INFLUENCERS "+E.numBoneInfluencers),V=new t.c,V.addCPUSkinningFallback(0,E),H.isUsingTextureForMatrices?(S.push("#define BONETEXTURE"),-1===L.indexOf("boneTextureWidth")&&L.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(S.push("#define BonesPerMesh "+(H.bones.length+1)),-1===L.indexOf("mBones")&&L.push("mBones"))}else S.push("#define NUM_BONE_INFLUENCERS 0");let s=0;const i=E?E.morphTargetManager:null;if(i){const H=-1!==S.indexOf("#define UV1"),d=-1!==S.indexOf("#define UV2"),n=-1!==S.indexOf("#define TANGENT"),Z=-1!==S.indexOf("#define NORMAL"),I=-1!==S.indexOf("#define VERTEXCOLOR");s=(0,w.E)(i,S,M,E,!0,Z,n,H,d,I),i.isUsingTextureForTargets&&(-1===L.indexOf("morphTargetTextureIndices")&&L.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),s>0&&(L=L.slice(),L.push("morphTargetInfluences"),L.push("morphTargetCount"),L.push("morphTargetTextureInfo"),L.push("morphTargetTextureIndices"))}else S.push("#define NUM_MORPH_INFLUENCERS 0");if(E){const H=E.bakedVertexAnimationManager;H&&H.isEnabled&&(S.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===L.indexOf("bakedVertexAnimationSettings")&&L.push("bakedVertexAnimationSettings"),-1===L.indexOf("bakedVertexAnimationTextureSizeInverted")&&L.push("bakedVertexAnimationTextureSizeInverted"),-1===L.indexOf("bakedVertexAnimationTime")&&L.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,w.t)(M,E,S)}for(const Z in this._textures)if(!this._textures[Z].isReady())return!1;E&&this.needAlphaTestingForMesh(E)&&S.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,C.e)(L),(0,C.m)(this,l,S)),l.fogEnabled&&null!==E&&void 0!==E&&E.applyFog&&l.fogMode!==Z.c.FOGMODE_NONE&&(S.push("#define FOG"),-1===L.indexOf("view")&&L.push("view"),-1===L.indexOf("vFogInfos")&&L.push("vFogInfos"),-1===L.indexOf("vFogColor")&&L.push("vFogColor")),this._useLogarithmicDepth&&(S.push("#define LOGARITHMICDEPTH"),-1===L.indexOf("logarithmicDepthConstant")&&L.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(L=L.slice(),D=D.slice(),e=e.slice(),Q=this.customShaderNameResolve(this.name,L,D,e,S,M));const p=I?d._getDrawWrapper(void 0,!0):this._drawWrapper,f=(null===p||void 0===p?void 0:p.effect)??null,P=(null===p||void 0===p?void 0:p.defines)??null,j=S.join("\n");let X=f;return P!==j&&(X=r.createEffect(Q,{attributes:M,uniformsNames:L,uniformBuffersNames:D,samplers:e,defines:j,fallbacks:V,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:s},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},r),I?d.setEffect(X,j,this._materialContext):p&&p.setEffect(X,j),this._onEffectCreatedObservable&&(R.effect=X,R.subMesh=d??(null===E||void 0===E?void 0:E.od[0])??null,this._onEffectCreatedObservable.notifyObservers(R))),p._wasPreviouslyUsingInstances=!!H,!(null===(n=X)||void 0===n||!n.isReady())&&(f!==X&&l.resetCachedMaterial(),p._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(E,H){const d=H??this.getEffect();if(!d)return;const n=this._options.uniforms;-1!==n.indexOf("world")&&d.setMatrix("world",E);const Z=this.fE();-1!==n.indexOf("worldView")&&(E.multiplyToRef(Z.getViewMatrix(),this._cachedWorldViewMatrix),d.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==n.indexOf("worldViewProjection")&&(E.multiplyToRef(Z.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),d.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==n.indexOf("view")&&d.setMatrix("view",Z.getViewMatrix())}bindForSubMesh(E,H,d){var n;this.bind(E,H,null===(n=d._drawWrapperOverride)||void 0===n?void 0:n.effect,d)}bind(E,H,d,n){const Z=n&&this._storeEffectOnSubMeshes,I=d??(Z?n.effect:this.getEffect());if(!I)return;const g=this.fE();this._activeEffect=I,this.bindOnlyWorldMatrix(E,d);const l=this._options.uniformBuffers;let r=!1;if(I&&l&&l.length>0&&g.getEngine().supportsUniformBuffers)for(let M=0;M<l.length;++M){switch(l[M]){case"Mesh":H&&(H.getMeshUniformBuffer().bindToEffect(I,"Mesh"),H.transferToEffect(E));break;case"Scene":(0,w.n)(I,g.getSceneUniformBuffer()),g.finalizeSceneUbo(),r=!0}}const t=H&&Z?this._mustRebind(g,I,n,H.visibility):g.getCachedMaterial()!==this;if(I&&t){let E;for(E in r||-1===this._options.uniforms.indexOf("view")||I.setMatrix("view",g.getViewMatrix()),r||-1===this._options.uniforms.indexOf("projection")||I.setMatrix("projection",g.getProjectionMatrix()),r||-1===this._options.uniforms.indexOf("viewProjection")||(I.setMatrix("viewProjection",g.getTransformMatrix()),this._multiview&&I.setMatrix("viewProjectionR",g._transformMatrixR)),g.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&I.setVector3("cameraPosition",g.activeCamera.globalPosition),(0,w.b)(H,I),(0,C.f)(I,this,g),this._useLogarithmicDepth&&(0,w.j)(Z?n.materialDefines:I.defines,I,g),H&&(0,w.d)(g,H,I),this._textures)I.setTexture(E,this._textures[E]);for(E in this._textureArrays)I.setTextureArray(E,this._textureArrays[E]);for(E in this._ints)I.setInt(E,this._ints[E]);for(E in this._uints)I.setUInt(E,this._uints[E]);for(E in this._floats)I.setFloat(E,this._floats[E]);for(E in this._floatsArrays)I.setArray(E,this._floatsArrays[E]);for(E in this._colors3)I.setColor3(E,this._colors3[E]);for(E in this._colors3Arrays)I.setArray3(E,this._colors3Arrays[E]);for(E in this._colors4){const H=this._colors4[E];I.setFloat4(E,H.r,H.g,H.b,H.a)}for(E in this._colors4Arrays)I.setArray4(E,this._colors4Arrays[E]);for(E in this._vectors2)I.setVector2(E,this._vectors2[E]);for(E in this._vectors3)I.setVector3(E,this._vectors3[E]);for(E in this._vectors4)I.setVector4(E,this._vectors4[E]);for(E in this._quaternions)I.setQuaternion(E,this._quaternions[E]);for(E in this._matrices)I.setMatrix(E,this._matrices[E]);for(E in this._matrixArrays)I.setMatrices(E,this._matrixArrays[E]);for(E in this._matrices3x3)I.setMatrix3x3(E,this._matrices3x3[E]);for(E in this._matrices2x2)I.setMatrix2x2(E,this._matrices2x2[E]);for(E in this._vectors2Arrays)I.setArray2(E,this._vectors2Arrays[E]);for(E in this._vectors3Arrays)I.setArray3(E,this._vectors3Arrays[E]);for(E in this._vectors4Arrays)I.setArray4(E,this._vectors4Arrays[E]);for(E in this._quaternionsArrays)I.setArray4(E,this._quaternionsArrays[E]);for(E in this._uniformBuffers){const H=this._uniformBuffers[E].getBuffer();H&&I.bindUniformBuffer(H,E)}const d=g.getEngine(),l=d.setExternalTexture;if(l)for(E in this._externalTextures)l.call(d,E,this._externalTextures[E]);const t=d.setTextureSampler;if(t)for(E in this._textureSamplers)t.call(d,E,this._textureSamplers[E]);const S=d.setStorageBuffer;if(S)for(E in this._storageBuffers)S.call(d,E,this._storageBuffers[E])}if(I&&H&&(t||!this.isFrozen)){(0,w.m)(H,I),H.morphTargetManager&&H.morphTargetManager.isUsingTextureForTargets&&H.morphTargetManager._bind(I);const E=H.bakedVertexAnimationManager;if(E&&E.isEnabled){var S;const E=Z?n._drawWrapper:this._drawWrapper;null===(S=H.bakedVertexAnimationManager)||void 0===S||S.bind(I,!!E._wasPreviouslyUsingInstances)}}this._afterBind(H,I,n)}getActiveTextures(){const E=super.getActiveTextures();for(const H in this._textures)E.push(this._textures[H]);for(const H in this._textureArrays){const d=this._textureArrays[H];for(let H=0;H<d.length;H++)E.push(d[H])}return E}hasTexture(E){if(super.hasTexture(E))return!0;for(const H in this._textures)if(this._textures[H]===E)return!0;for(const H in this._textureArrays){const d=this._textureArrays[H];for(let H=0;H<d.length;H++)if(d[H]===E)return!0}return!1}clone(E){const H=n.c.Clone((()=>new Q(E,this.fE(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);H.name=E,H.id=E,"object"===typeof H._shaderPath&&(H._shaderPath={...H._shaderPath}),this._options={...this._options};const d=Object.keys(this._options);for(const n of d){const E=this._options[n];Array.isArray(E)&&(this._options[n]=E.slice(0))}this.ed.copyTo(H.ed);for(const n in this._textures)H.setTexture(n,this._textures[n]);for(const n in this._textureArrays)H.setTextureArray(n,this._textureArrays[n]);for(const n in this._externalTextures)H.setExternalTexture(n,this._externalTextures[n]);for(const n in this._ints)H.setInt(n,this._ints[n]);for(const n in this._uints)H.setUInt(n,this._uints[n]);for(const n in this._floats)H.setFloat(n,this._floats[n]);for(const n in this._floatsArrays)H.setFloats(n,this._floatsArrays[n]);for(const n in this._colors3)H.setColor3(n,this._colors3[n]);for(const n in this._colors3Arrays)H._colors3Arrays[n]=this._colors3Arrays[n];for(const n in this._colors4)H.setColor4(n,this._colors4[n]);for(const n in this._colors4Arrays)H._colors4Arrays[n]=this._colors4Arrays[n];for(const n in this._vectors2)H.setVector2(n,this._vectors2[n]);for(const n in this._vectors3)H.setVector3(n,this._vectors3[n]);for(const n in this._vectors4)H.setVector4(n,this._vectors4[n]);for(const n in this._quaternions)H.setQuaternion(n,this._quaternions[n]);for(const n in this._quaternionsArrays)H._quaternionsArrays[n]=this._quaternionsArrays[n];for(const n in this._matrices)H.setMatrix(n,this._matrices[n]);for(const n in this._matrixArrays)H._matrixArrays[n]=this._matrixArrays[n].slice();for(const n in this._matrices3x3)H.setMatrix3x3(n,this._matrices3x3[n]);for(const n in this._matrices2x2)H.setMatrix2x2(n,this._matrices2x2[n]);for(const n in this._vectors2Arrays)H.setArray2(n,this._vectors2Arrays[n]);for(const n in this._vectors3Arrays)H.setArray3(n,this._vectors3Arrays[n]);for(const n in this._vectors4Arrays)H.setArray4(n,this._vectors4Arrays[n]);for(const n in this._uniformBuffers)H.setUniformBuffer(n,this._uniformBuffers[n]);for(const n in this._textureSamplers)H.setTextureSampler(n,this._textureSamplers[n]);for(const n in this._storageBuffers)H.setStorageBuffer(n,this._storageBuffers[n]);return H}dispose(E,H,d){if(H){let E;for(E in this._textures)this._textures[E].dispose();for(E in this._textureArrays){const H=this._textureArrays[E];for(let E=0;E<H.length;E++)H[E].dispose()}}this._textures={},super.dispose(E,H,d)}serialize(){const E=n.c.Serialize(this);let H;for(H in E.customType="BABYLON.ShaderMaterial",E.uniqueId=this.uniqueId,E.options=this._options,E.shaderPath=this._shaderPath,E.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,E.ed=this.ed.serialize(),E.textures={},this._textures)E.textures[H]=this._textures[H].serialize();for(H in E.textureArrays={},this._textureArrays){E.textureArrays[H]=[];const d=this._textureArrays[H];for(let n=0;n<d.length;n++)E.textureArrays[H].push(d[n].serialize())}for(H in E.ints={},this._ints)E.ints[H]=this._ints[H];for(H in E.uints={},this._uints)E.uints[H]=this._uints[H];for(H in E.floats={},this._floats)E.floats[H]=this._floats[H];for(H in E.floatsArrays={},this._floatsArrays)E.floatsArrays[H]=this._floatsArrays[H];for(H in E.colors3={},this._colors3){const d=this._colors3[H];E.colors3[H]=[d.r,d.g,d.b]}for(H in E.colors3Arrays={},this._colors3Arrays)E.colors3Arrays[H]=this._colors3Arrays[H];for(H in E.colors4={},this._colors4){const d=this._colors4[H];E.colors4[H]=[d.r,d.g,d.b,d.a]}for(H in E.colors4Arrays={},this._colors4Arrays)E.colors4Arrays[H]=this._colors4Arrays[H];for(H in E.vectors2={},this._vectors2){const d=this._vectors2[H];E.vectors2[H]=[d.x,d.y]}for(H in E.vectors3={},this._vectors3){const d=this._vectors3[H];E.vectors3[H]=[d.x,d.y,d.z]}for(H in E.vectors4={},this._vectors4){const d=this._vectors4[H];E.vectors4[H]=[d.x,d.y,d.z,d.w]}for(H in E.quaternions={},this._quaternions)E.quaternions[H]=this._quaternions[H].kd();for(H in E.matrices={},this._matrices)E.matrices[H]=this._matrices[H].kd();for(H in E.matrixArray={},this._matrixArrays)E.matrixArray[H]=this._matrixArrays[H];for(H in E.matrices3x3={},this._matrices3x3)E.matrices3x3[H]=this._matrices3x3[H];for(H in E.matrices2x2={},this._matrices2x2)E.matrices2x2[H]=this._matrices2x2[H];for(H in E.vectors2Arrays={},this._vectors2Arrays)E.vectors2Arrays[H]=this._vectors2Arrays[H];for(H in E.vectors3Arrays={},this._vectors3Arrays)E.vectors3Arrays[H]=this._vectors3Arrays[H];for(H in E.vectors4Arrays={},this._vectors4Arrays)E.vectors4Arrays[H]=this._vectors4Arrays[H];for(H in E.quaternionsArrays={},this._quaternionsArrays)E.quaternionsArrays[H]=this._quaternionsArrays[H];return E}static Parse(E,H,d){const Z=n.c.Parse((()=>new Q(E.name,H,E.shaderPath,E.options,E.storeEffectOnSubMeshes)),E,H,d);let g;for(g in E.ed&&Z.ed.parse(E.ed,H,d),E.textures)Z.setTexture(g,l.c.Parse(E.textures[g],H,d));for(g in E.textureArrays){const n=E.textureArrays[g],I=[];for(let E=0;E<n.length;E++)I.push(l.c.Parse(n[E],H,d));Z.setTextureArray(g,I)}for(g in E.ints)Z.setInt(g,E.ints[g]);for(g in E.uints)Z.setUInt(g,E.uints[g]);for(g in E.floats)Z.setFloat(g,E.floats[g]);for(g in E.floatsArrays)Z.setFloats(g,E.floatsArrays[g]);for(g in E.colors3){const H=E.colors3[g];Z.setColor3(g,{r:H[0],g:H[1],b:H[2]})}for(g in E.colors3Arrays){const H=E.colors3Arrays[g].reduce(((E,H,d)=>(d%3===0?E.push([H]):E[E.length-1].push(H),E)),[]).map((E=>({r:E[0],g:E[1],b:E[2]})));Z.setColor3Array(g,H)}for(g in E.colors4){const H=E.colors4[g];Z.setColor4(g,{r:H[0],g:H[1],b:H[2],a:H[3]})}for(g in E.colors4Arrays){const H=E.colors4Arrays[g].reduce(((E,H,d)=>(d%4===0?E.push([H]):E[E.length-1].push(H),E)),[]).map((E=>({r:E[0],g:E[1],b:E[2],a:E[3]})));Z.setColor4Array(g,H)}for(g in E.vectors2){const H=E.vectors2[g];Z.setVector2(g,{x:H[0],y:H[1]})}for(g in E.vectors3){const H=E.vectors3[g];Z.setVector3(g,{x:H[0],y:H[1],z:H[2]})}for(g in E.vectors4){const H=E.vectors4[g];Z.setVector4(g,{x:H[0],y:H[1],z:H[2],w:H[3]})}for(g in E.quaternions)Z.setQuaternion(g,I.Quaternion.eH(E.quaternions[g]));for(g in E.matrices)Z.setMatrix(g,I.Matrix.eH(E.matrices[g]));for(g in E.matrixArray)Z._matrixArrays[g]=new Float32Array(E.matrixArray[g]);for(g in E.matrices3x3)Z.setMatrix3x3(g,E.matrices3x3[g]);for(g in E.matrices2x2)Z.setMatrix2x2(g,E.matrices2x2[g]);for(g in E.vectors2Arrays)Z.setArray2(g,E.vectors2Arrays[g]);for(g in E.vectors3Arrays)Z.setArray3(g,E.vectors3Arrays[g]);for(g in E.vectors4Arrays)Z.setArray4(g,E.vectors4Arrays[g]);for(g in E.quaternionsArrays)Z.setArray4(g,E.quaternionsArrays[g]);return Z}static async ParseFromFileAsync(E,H,d){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((Z,I)=>{const g=new S.b;g.addEventListener("readystatechange",(()=>{if(4==g.readyState)if(200==g.status){const H=JSON.parse(g.responseText),I=this.Parse(H,d||V.b.LastCreatedScene,n);E&&(I.name=E),Z(I)}else I("Unable to load the ShaderMaterial")})),g.open("GET",H),g.send()}))}static async ParseFromSnippetAsync(E,H){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((n,Z)=>{const I=new S.b;I.addEventListener("readystatechange",(()=>{if(4==I.readyState)if(200==I.status){const Z=JSON.parse(JSON.parse(I.responseText).jsonPayload),g=JSON.parse(Z.shaderMaterial),l=this.Parse(g,H||V.b.LastCreatedScene,d);l.snippetId=E,n(l)}else Z("Unable to load the snippet "+E)})),I.open("GET",this.SnippetUrl+"/"+E.replace(/#/g,"/")),I.send()}))}}Q.SnippetUrl="https://snippet.babylonjs.com",Q.CreateFromSnippetAsync=Q.ParseFromSnippetAsync,(0,r.e)("BABYLON.ShaderMaterial",Q)}}]);