"use strict";(self.xeuzlpp225k=self.xeuzlpp225k||[]).push([[22],{11535:(k,Q,i)=>{i.r(Q),i.d(Q,{ShaderMaterial:()=>E});var Z=i(11334),U=i(11538),C=i(11298),B=i(11378),o=i(11273),m=i(11253),O=i(11603),J=i(11150),G=i(11607),H=i(11157),e=i(11657),F=i(11652);const z={effect:null,subMesh:null};class E extends G.c{constructor(k,Q,i){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(k,Q,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new C.Matrix,this._cachedWorldViewProjectionMatrix=new C.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=i,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...Z}}get shaderPath(){return this._shaderPath}set shaderPath(k){this._shaderPath=k}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(k){-1===this._options.uniforms.indexOf(k)&&this._options.uniforms.push(k)}setTexture(k,Q){return-1===this._options.samplers.indexOf(k)&&this._options.samplers.push(k),this._textures[k]=Q,this}removeTexture(k){delete this._textures[k]}setTextureArray(k,Q){return-1===this._options.samplers.indexOf(k)&&this._options.samplers.push(k),this._checkUniform(k),this._textureArrays[k]=Q,this}setExternalTexture(k,Q){return-1===this._options.externalTextures.indexOf(k)&&this._options.externalTextures.push(k),this._externalTextures[k]=Q,this}setFloat(k,Q){return this._checkUniform(k),this._floats[k]=Q,this}setInt(k,Q){return this._checkUniform(k),this._ints[k]=Q,this}setUInt(k,Q){return this._checkUniform(k),this._uints[k]=Q,this}setFloats(k,Q){return this._checkUniform(k),this._floatsArrays[k]=Q,this}setColor3(k,Q){return this._checkUniform(k),this._colors3[k]=Q,this}setColor3Array(k,Q){return this._checkUniform(k),this._colors3Arrays[k]=Q.reduce(((k,Q)=>(k.push(Q.r,Q.g,Q.b),k)),[]),this}setColor4(k,Q){return this._checkUniform(k),this._colors4[k]=Q,this}setColor4Array(k,Q){return this._checkUniform(k),this._colors4Arrays[k]=Q.reduce(((k,Q)=>(k.push(Q.r,Q.g,Q.b,Q.a),k)),[]),this}setVector2(k,Q){return this._checkUniform(k),this._vectors2[k]=Q,this}setVector3(k,Q){return this._checkUniform(k),this._vectors3[k]=Q,this}setVector4(k,Q){return this._checkUniform(k),this._vectors4[k]=Q,this}setQuaternion(k,Q){return this._checkUniform(k),this._quaternions[k]=Q,this}setQuaternionArray(k,Q){return this._checkUniform(k),this._quaternionsArrays[k]=Q.reduce(((k,Q)=>(Q.toArray(k,k.length),k)),[]),this}setMatrix(k,Q){return this._checkUniform(k),this._matrices[k]=Q,this}setMatrices(k,Q){this._checkUniform(k);const i=new Float32Array(16*Q.length);for(let Z=0;Z<Q.length;Z++){Q[Z].copyToArray(i,16*Z)}return this._matrixArrays[k]=i,this}setMatrix3x3(k,Q){return this._checkUniform(k),this._matrices3x3[k]=Q,this}setMatrix2x2(k,Q){return this._checkUniform(k),this._matrices2x2[k]=Q,this}setArray2(k,Q){return this._checkUniform(k),this._vectors2Arrays[k]=Q,this}setArray3(k,Q){return this._checkUniform(k),this._vectors3Arrays[k]=Q,this}setArray4(k,Q){return this._checkUniform(k),this._vectors4Arrays[k]=Q,this}setUniformBuffer(k,Q){return-1===this._options.uniformBuffers.indexOf(k)&&this._options.uniformBuffers.push(k),this._uniformBuffers[k]=Q,this}setTextureSampler(k,Q){return-1===this._options.samplerObjects.indexOf(k)&&this._options.samplerObjects.push(k),this._textureSamplers[k]=Q,this}setStorageBuffer(k,Q){return-1===this._options.storageBuffers.indexOf(k)&&this._options.storageBuffers.push(k),this._storageBuffers[k]=Q,this}setDefine(k,Q){const i=k.trimEnd()+" ",Z=this.options.defines.findIndex((Q=>Q===k||Q.startsWith(i)));return Z>=0&&this.options.defines.splice(Z,1),("boolean"!==typeof Q||Q)&&this.options.defines.push(i+Q),this}isReadyForSubMesh(k,Q,i){return this.isReady(k,i,Q)}isReady(k,Q,i){var Z;const C=i&&this._storeEffectOnSubMeshes;if(this.isFrozen){const k=C?i._drawWrapper:this._drawWrapper;if(k.effect&&k._wasPreviouslyReady&&k._wasPreviouslyUsingInstances===Q)return!0}const o=this.sk(),m=o.getEngine(),J=[],G=[];let H=null,E=this._shaderPath,l=this._options.uniforms,h=this._options.uniformBuffers,c=this._options.samplers;m.getCaps().multiview&&o.activeCamera&&o.activeCamera.outputRenderTarget&&o.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,J.push("#define MULTIVIEW"),-1!==l.indexOf("viewProjection")&&-1===l.indexOf("viewProjectionR")&&l.push("viewProjectionR"));for(let U=0;U<this._options.defines.length;U++){const k=0===this._options.defines[U].indexOf("#define")?this._options.defines[U]:`#define ${this._options.defines[U]}`;J.push(k)}for(let U=0;U<this._options.attributes.length;U++)G.push(this._options.attributes[U]);if(k&&k.isVerticesDataPresent(B.h.ColorKind)&&(-1===G.indexOf(B.h.ColorKind)&&G.push(B.h.ColorKind),J.push("#define VERTEXCOLOR")),Q&&(J.push("#define INSTANCES"),(0,F.cb)(G,this._materialHelperNeedsPreviousMatrices),null!==k&&void 0!==k&&k.hasThinInstances&&(J.push("#define THIN_INSTANCES"),k&&k.isVerticesDataPresent(B.h.ColorInstanceKind)&&(G.push(B.h.ColorInstanceKind),J.push("#define INSTANCESCOLOR")))),k&&k.useBones&&k.computeBonesUsingShaders&&k.skeleton){G.push(B.h.MatricesIndicesKind),G.push(B.h.MatricesWeightsKind),k.numBoneInfluencers>4&&(G.push(B.h.MatricesIndicesExtraKind),G.push(B.h.MatricesWeightsExtraKind));const Q=k.skeleton;J.push("#define NUM_BONE_INFLUENCERS "+k.numBoneInfluencers),H=new O.e,H.addCPUSkinningFallback(0,k),Q.isUsingTextureForMatrices?(J.push("#define BONETEXTURE"),-1===l.indexOf("boneTextureWidth")&&l.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(J.push("#define BonesPerMesh "+(Q.bones.length+1)),-1===l.indexOf("mBones")&&l.push("mBones"))}else J.push("#define NUM_BONE_INFLUENCERS 0");let f=0;const Y=k?k.morphTargetManager:null;if(Y){const Q=-1!==J.indexOf("#define UV1"),i=-1!==J.indexOf("#define UV2"),Z=-1!==J.indexOf("#define TANGENT"),U=-1!==J.indexOf("#define NORMAL"),C=-1!==J.indexOf("#define VERTEXCOLOR");f=(0,F.E)(Y,J,G,k,!0,U,Z,Q,i,C),Y.isUsingTextureForTargets&&(-1===l.indexOf("morphTargetTextureIndices")&&l.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),f>0&&(l=l.slice(),l.push("morphTargetInfluences"),l.push("morphTargetCount"),l.push("morphTargetTextureInfo"),l.push("morphTargetTextureIndices"))}else J.push("#define NUM_MORPH_INFLUENCERS 0");if(k){const Q=k.bakedVertexAnimationManager;Q&&Q.isEnabled&&(J.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===l.indexOf("bakedVertexAnimationSettings")&&l.push("bakedVertexAnimationSettings"),-1===l.indexOf("bakedVertexAnimationTextureSizeInverted")&&l.push("bakedVertexAnimationTextureSizeInverted"),-1===l.indexOf("bakedVertexAnimationTime")&&l.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,F.s)(G,k,J)}for(const U in this._textures)if(!this._textures[U].isReady())return!1;k&&this.needAlphaTestingForMesh(k)&&J.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,e.c)(l),(0,e.i)(this,o,J)),o.fogEnabled&&null!==k&&void 0!==k&&k.applyFog&&o.fogMode!==U.b.FOGMODE_NONE&&(J.push("#define FOG"),-1===l.indexOf("view")&&l.push("view"),-1===l.indexOf("vFogInfos")&&l.push("vFogInfos"),-1===l.indexOf("vFogColor")&&l.push("vFogColor")),this._useLogarithmicDepth&&(J.push("#define LOGARITHMICDEPTH"),-1===l.indexOf("logarithmicDepthConstant")&&l.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(l=l.slice(),h=h.slice(),c=c.slice(),E=this.customShaderNameResolve(this.name,l,h,c,J,G));const y=C?i._getDrawWrapper(void 0,!0):this._drawWrapper,L=(null===y||void 0===y?void 0:y.effect)??null,s=(null===y||void 0===y?void 0:y.defines)??null,u=J.join("\n");let a=L;return s!==u&&(a=m.createEffect(E,{attributes:G,uniformsNames:l,uniformBuffersNames:h,samplers:c,defines:u,fallbacks:H,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:f},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},m),C?i.setEffect(a,u,this._materialContext):y&&y.setEffect(a,u),this._onEffectCreatedObservable&&(z.effect=a,z.subMesh=i??(null===k||void 0===k?void 0:k.io[0])??null,this._onEffectCreatedObservable.notifyObservers(z))),y._wasPreviouslyUsingInstances=!!Q,!(null===(Z=a)||void 0===Z||!Z.isReady())&&(L!==a&&o.resetCachedMaterial(),y._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(k,Q){const i=Q??this.getEffect();if(!i)return;const Z=this._options.uniforms;-1!==Z.indexOf("world")&&i.setMatrix("world",k);const U=this.sk();-1!==Z.indexOf("worldView")&&(k.multiplyToRef(U.getViewMatrix(),this._cachedWorldViewMatrix),i.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==Z.indexOf("worldViewProjection")&&(k.multiplyToRef(U.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),i.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==Z.indexOf("view")&&i.setMatrix("view",U.getViewMatrix())}bindForSubMesh(k,Q,i){var Z;this.bind(k,Q,null===(Z=i._drawWrapperOverride)||void 0===Z?void 0:Z.effect,i)}bind(k,Q,i,Z){const U=Z&&this._storeEffectOnSubMeshes,C=i??(U?Z.effect:this.getEffect());if(!C)return;const B=this.sk();this._activeEffect=C,this.bindOnlyWorldMatrix(k,i);const o=this._options.uniformBuffers;let m=!1;if(C&&o&&o.length>0&&B.getEngine().supportsUniformBuffers)for(let G=0;G<o.length;++G){switch(o[G]){case"Mesh":Q&&(Q.getMeshUniformBuffer().bindToEffect(C,"Mesh"),Q.transferToEffect(k));break;case"Scene":(0,F.l)(C,B.getSceneUniformBuffer()),B.finalizeSceneUbo(),m=!0}}const O=Q&&U?this._mustRebind(B,C,Z,Q.visibility):B.getCachedMaterial()!==this;if(C&&O){let k;for(k in m||-1===this._options.uniforms.indexOf("view")||C.setMatrix("view",B.getViewMatrix()),m||-1===this._options.uniforms.indexOf("projection")||C.setMatrix("projection",B.getProjectionMatrix()),m||-1===this._options.uniforms.indexOf("viewProjection")||(C.setMatrix("viewProjection",B.getTransformMatrix()),this._multiview&&C.setMatrix("viewProjectionR",B._transformMatrixR)),B.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&C.setVector3("cameraPosition",B.activeCamera.globalPosition),(0,F.c)(Q,C),(0,e.g)(C,this,B),this._useLogarithmicDepth&&(0,F.j)(U?Z.materialDefines:C.defines,C,B),Q&&(0,F.e)(B,Q,C),this._textures)C.setTexture(k,this._textures[k]);for(k in this._textureArrays)C.setTextureArray(k,this._textureArrays[k]);for(k in this._ints)C.setInt(k,this._ints[k]);for(k in this._uints)C.setUInt(k,this._uints[k]);for(k in this._floats)C.setFloat(k,this._floats[k]);for(k in this._floatsArrays)C.setArray(k,this._floatsArrays[k]);for(k in this._colors3)C.setColor3(k,this._colors3[k]);for(k in this._colors3Arrays)C.setArray3(k,this._colors3Arrays[k]);for(k in this._colors4){const Q=this._colors4[k];C.setFloat4(k,Q.r,Q.g,Q.b,Q.a)}for(k in this._colors4Arrays)C.setArray4(k,this._colors4Arrays[k]);for(k in this._vectors2)C.setVector2(k,this._vectors2[k]);for(k in this._vectors3)C.setVector3(k,this._vectors3[k]);for(k in this._vectors4)C.setVector4(k,this._vectors4[k]);for(k in this._quaternions)C.setQuaternion(k,this._quaternions[k]);for(k in this._matrices)C.setMatrix(k,this._matrices[k]);for(k in this._matrixArrays)C.setMatrices(k,this._matrixArrays[k]);for(k in this._matrices3x3)C.setMatrix3x3(k,this._matrices3x3[k]);for(k in this._matrices2x2)C.setMatrix2x2(k,this._matrices2x2[k]);for(k in this._vectors2Arrays)C.setArray2(k,this._vectors2Arrays[k]);for(k in this._vectors3Arrays)C.setArray3(k,this._vectors3Arrays[k]);for(k in this._vectors4Arrays)C.setArray4(k,this._vectors4Arrays[k]);for(k in this._quaternionsArrays)C.setArray4(k,this._quaternionsArrays[k]);for(k in this._uniformBuffers){const Q=this._uniformBuffers[k].getBuffer();Q&&C.bindUniformBuffer(Q,k)}const i=B.getEngine(),o=i.setExternalTexture;if(o)for(k in this._externalTextures)o.call(i,k,this._externalTextures[k]);const O=i.setTextureSampler;if(O)for(k in this._textureSamplers)O.call(i,k,this._textureSamplers[k]);const J=i.setStorageBuffer;if(J)for(k in this._storageBuffers)J.call(i,k,this._storageBuffers[k])}if(C&&Q&&(O||!this.isFrozen)){(0,F.k)(Q,C),Q.morphTargetManager&&Q.morphTargetManager.isUsingTextureForTargets&&Q.morphTargetManager._bind(C);const k=Q.bakedVertexAnimationManager;if(k&&k.isEnabled){var J;const k=U?Z._drawWrapper:this._drawWrapper;null===(J=Q.bakedVertexAnimationManager)||void 0===J||J.bind(C,!!k._wasPreviouslyUsingInstances)}}this._afterBind(Q,C,Z)}getActiveTextures(){const k=super.getActiveTextures();for(const Q in this._textures)k.push(this._textures[Q]);for(const Q in this._textureArrays){const i=this._textureArrays[Q];for(let Q=0;Q<i.length;Q++)k.push(i[Q])}return k}hasTexture(k){if(super.hasTexture(k))return!0;for(const Q in this._textures)if(this._textures[Q]===k)return!0;for(const Q in this._textureArrays){const i=this._textureArrays[Q];for(let Q=0;Q<i.length;Q++)if(i[Q]===k)return!0}return!1}clone(k){const Q=Z.d.Clone((()=>new E(k,this.sk(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);Q.name=k,Q.id=k,"object"===typeof Q._shaderPath&&(Q._shaderPath={...Q._shaderPath}),this._options={...this._options};const i=Object.keys(this._options);for(const Z of i){const k=this._options[Z];Array.isArray(k)&&(this._options[Z]=k.slice(0))}this.stencil.copyTo(Q.stencil);for(const Z in this._textures)Q.setTexture(Z,this._textures[Z]);for(const Z in this._textureArrays)Q.setTextureArray(Z,this._textureArrays[Z]);for(const Z in this._externalTextures)Q.setExternalTexture(Z,this._externalTextures[Z]);for(const Z in this._ints)Q.setInt(Z,this._ints[Z]);for(const Z in this._uints)Q.setUInt(Z,this._uints[Z]);for(const Z in this._floats)Q.setFloat(Z,this._floats[Z]);for(const Z in this._floatsArrays)Q.setFloats(Z,this._floatsArrays[Z]);for(const Z in this._colors3)Q.setColor3(Z,this._colors3[Z]);for(const Z in this._colors3Arrays)Q._colors3Arrays[Z]=this._colors3Arrays[Z];for(const Z in this._colors4)Q.setColor4(Z,this._colors4[Z]);for(const Z in this._colors4Arrays)Q._colors4Arrays[Z]=this._colors4Arrays[Z];for(const Z in this._vectors2)Q.setVector2(Z,this._vectors2[Z]);for(const Z in this._vectors3)Q.setVector3(Z,this._vectors3[Z]);for(const Z in this._vectors4)Q.setVector4(Z,this._vectors4[Z]);for(const Z in this._quaternions)Q.setQuaternion(Z,this._quaternions[Z]);for(const Z in this._quaternionsArrays)Q._quaternionsArrays[Z]=this._quaternionsArrays[Z];for(const Z in this._matrices)Q.setMatrix(Z,this._matrices[Z]);for(const Z in this._matrixArrays)Q._matrixArrays[Z]=this._matrixArrays[Z].slice();for(const Z in this._matrices3x3)Q.setMatrix3x3(Z,this._matrices3x3[Z]);for(const Z in this._matrices2x2)Q.setMatrix2x2(Z,this._matrices2x2[Z]);for(const Z in this._vectors2Arrays)Q.setArray2(Z,this._vectors2Arrays[Z]);for(const Z in this._vectors3Arrays)Q.setArray3(Z,this._vectors3Arrays[Z]);for(const Z in this._vectors4Arrays)Q.setArray4(Z,this._vectors4Arrays[Z]);for(const Z in this._uniformBuffers)Q.setUniformBuffer(Z,this._uniformBuffers[Z]);for(const Z in this._textureSamplers)Q.setTextureSampler(Z,this._textureSamplers[Z]);for(const Z in this._storageBuffers)Q.setStorageBuffer(Z,this._storageBuffers[Z]);return Q}dispose(k,Q,i){if(Q){let k;for(k in this._textures)this._textures[k].dispose();for(k in this._textureArrays){const Q=this._textureArrays[k];for(let k=0;k<Q.length;k++)Q[k].dispose()}}this._textures={},super.dispose(k,Q,i)}serialize(){const k=Z.d.Serialize(this);let Q;for(Q in k.customType="BABYLON.ShaderMaterial",k.uniqueId=this.uniqueId,k.options=this._options,k.shaderPath=this._shaderPath,k.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,k.stencil=this.stencil.serialize(),k.textures={},this._textures)k.textures[Q]=this._textures[Q].serialize();for(Q in k.textureArrays={},this._textureArrays){k.textureArrays[Q]=[];const i=this._textureArrays[Q];for(let Z=0;Z<i.length;Z++)k.textureArrays[Q].push(i[Z].serialize())}for(Q in k.ints={},this._ints)k.ints[Q]=this._ints[Q];for(Q in k.uints={},this._uints)k.uints[Q]=this._uints[Q];for(Q in k.floats={},this._floats)k.floats[Q]=this._floats[Q];for(Q in k.floatsArrays={},this._floatsArrays)k.floatsArrays[Q]=this._floatsArrays[Q];for(Q in k.colors3={},this._colors3){const i=this._colors3[Q];k.colors3[Q]=[i.r,i.g,i.b]}for(Q in k.colors3Arrays={},this._colors3Arrays)k.colors3Arrays[Q]=this._colors3Arrays[Q];for(Q in k.colors4={},this._colors4){const i=this._colors4[Q];k.colors4[Q]=[i.r,i.g,i.b,i.a]}for(Q in k.colors4Arrays={},this._colors4Arrays)k.colors4Arrays[Q]=this._colors4Arrays[Q];for(Q in k.vectors2={},this._vectors2){const i=this._vectors2[Q];k.vectors2[Q]=[i.x,i.y]}for(Q in k.vectors3={},this._vectors3){const i=this._vectors3[Q];k.vectors3[Q]=[i.x,i.y,i.z]}for(Q in k.vectors4={},this._vectors4){const i=this._vectors4[Q];k.vectors4[Q]=[i.x,i.y,i.z,i.w]}for(Q in k.quaternions={},this._quaternions)k.quaternions[Q]=this._quaternions[Q].Zo();for(Q in k.matrices={},this._matrices)k.matrices[Q]=this._matrices[Q].Zo();for(Q in k.matrixArray={},this._matrixArrays)k.matrixArray[Q]=this._matrixArrays[Q];for(Q in k.matrices3x3={},this._matrices3x3)k.matrices3x3[Q]=this._matrices3x3[Q];for(Q in k.matrices2x2={},this._matrices2x2)k.matrices2x2[Q]=this._matrices2x2[Q];for(Q in k.vectors2Arrays={},this._vectors2Arrays)k.vectors2Arrays[Q]=this._vectors2Arrays[Q];for(Q in k.vectors3Arrays={},this._vectors3Arrays)k.vectors3Arrays[Q]=this._vectors3Arrays[Q];for(Q in k.vectors4Arrays={},this._vectors4Arrays)k.vectors4Arrays[Q]=this._vectors4Arrays[Q];for(Q in k.quaternionsArrays={},this._quaternionsArrays)k.quaternionsArrays[Q]=this._quaternionsArrays[Q];return k}static Parse(k,Q,i){const U=Z.d.Parse((()=>new E(k.name,Q,k.shaderPath,k.options,k.storeEffectOnSubMeshes)),k,Q,i);let B;for(B in k.stencil&&U.stencil.parse(k.stencil,Q,i),k.textures)U.setTexture(B,o.c.Parse(k.textures[B],Q,i));for(B in k.textureArrays){const Z=k.textureArrays[B],C=[];for(let k=0;k<Z.length;k++)C.push(o.c.Parse(Z[k],Q,i));U.setTextureArray(B,C)}for(B in k.ints)U.setInt(B,k.ints[B]);for(B in k.uints)U.setUInt(B,k.uints[B]);for(B in k.floats)U.setFloat(B,k.floats[B]);for(B in k.floatsArrays)U.setFloats(B,k.floatsArrays[B]);for(B in k.colors3){const Q=k.colors3[B];U.setColor3(B,{r:Q[0],g:Q[1],b:Q[2]})}for(B in k.colors3Arrays){const Q=k.colors3Arrays[B].reduce(((k,Q,i)=>(i%3===0?k.push([Q]):k[k.length-1].push(Q),k)),[]).map((k=>({r:k[0],g:k[1],b:k[2]})));U.setColor3Array(B,Q)}for(B in k.colors4){const Q=k.colors4[B];U.setColor4(B,{r:Q[0],g:Q[1],b:Q[2],a:Q[3]})}for(B in k.colors4Arrays){const Q=k.colors4Arrays[B].reduce(((k,Q,i)=>(i%4===0?k.push([Q]):k[k.length-1].push(Q),k)),[]).map((k=>({r:k[0],g:k[1],b:k[2],a:k[3]})));U.setColor4Array(B,Q)}for(B in k.vectors2){const Q=k.vectors2[B];U.setVector2(B,{x:Q[0],y:Q[1]})}for(B in k.vectors3){const Q=k.vectors3[B];U.setVector3(B,{x:Q[0],y:Q[1],z:Q[2]})}for(B in k.vectors4){const Q=k.vectors4[B];U.setVector4(B,{x:Q[0],y:Q[1],z:Q[2],w:Q[3]})}for(B in k.quaternions)U.setQuaternion(B,C.Quaternion.fQ(k.quaternions[B]));for(B in k.matrices)U.setMatrix(B,C.Matrix.fQ(k.matrices[B]));for(B in k.matrixArray)U._matrixArrays[B]=new Float32Array(k.matrixArray[B]);for(B in k.matrices3x3)U.setMatrix3x3(B,k.matrices3x3[B]);for(B in k.matrices2x2)U.setMatrix2x2(B,k.matrices2x2[B]);for(B in k.vectors2Arrays)U.setArray2(B,k.vectors2Arrays[B]);for(B in k.vectors3Arrays)U.setArray3(B,k.vectors3Arrays[B]);for(B in k.vectors4Arrays)U.setArray4(B,k.vectors4Arrays[B]);for(B in k.quaternionsArrays)U.setArray4(B,k.quaternionsArrays[B]);return U}static async ParseFromFileAsync(k,Q,i){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((U,C)=>{const B=new J.d;B.addEventListener("readystatechange",(()=>{if(4==B.readyState)if(200==B.status){const Q=JSON.parse(B.responseText),C=this.Parse(Q,i||H.b.LastCreatedScene,Z);k&&(C.name=k),U(C)}else C("Unable to load the ShaderMaterial")})),B.open("GET",Q),B.send()}))}static async ParseFromSnippetAsync(k,Q){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((Z,U)=>{const C=new J.d;C.addEventListener("readystatechange",(()=>{if(4==C.readyState)if(200==C.status){const U=JSON.parse(JSON.parse(C.responseText).jsonPayload),B=JSON.parse(U.shaderMaterial),o=this.Parse(B,Q||H.b.LastCreatedScene,i);o.snippetId=k,Z(o)}else U("Unable to load the snippet "+k)})),C.open("GET",this.SnippetUrl+"/"+k.replace(/#/g,"/")),C.send()}))}}E.SnippetUrl="https://snippet.babylonjs.com",E.CreateFromSnippetAsync=E.ParseFromSnippetAsync,(0,m.e)("BABYLON.ShaderMaterial",E)}}]);