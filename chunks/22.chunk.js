"use strict";(self.uw9p3pwwsje=self.uw9p3pwwsje||[]).push([[22],{13056:(D,h,o)=>{o.r(h),o.d(h,{ShaderMaterial:()=>s});var H=o(12860),g=o(13065),j=o(12831),M=o(12894),R=o(12807),t=o(12793),S=o(13139),k=o(12674),K=o(13148),Q=o(12683),v=o(13198),r=o(13189);const B={effect:null,subMesh:null};class s extends K.d{constructor(D,h,o){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(D,h,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new j.Matrix,this._cachedWorldViewProjectionMatrix=new j.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=o,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...H}}get shaderPath(){return this._shaderPath}set shaderPath(D){this._shaderPath=D}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(D){-1===this._options.uniforms.indexOf(D)&&this._options.uniforms.push(D)}setTexture(D,h){return-1===this._options.samplers.indexOf(D)&&this._options.samplers.push(D),this._textures[D]=h,this}removeTexture(D){delete this._textures[D]}setTextureArray(D,h){return-1===this._options.samplers.indexOf(D)&&this._options.samplers.push(D),this._checkUniform(D),this._textureArrays[D]=h,this}setExternalTexture(D,h){return-1===this._options.externalTextures.indexOf(D)&&this._options.externalTextures.push(D),this._externalTextures[D]=h,this}setFloat(D,h){return this._checkUniform(D),this._floats[D]=h,this}setInt(D,h){return this._checkUniform(D),this._ints[D]=h,this}setUInt(D,h){return this._checkUniform(D),this._uints[D]=h,this}setFloats(D,h){return this._checkUniform(D),this._floatsArrays[D]=h,this}setColor3(D,h){return this._checkUniform(D),this._colors3[D]=h,this}setColor3Array(D,h){return this._checkUniform(D),this._colors3Arrays[D]=h.reduce(((D,h)=>(D.push(h.r,h.g,h.b),D)),[]),this}setColor4(D,h){return this._checkUniform(D),this._colors4[D]=h,this}setColor4Array(D,h){return this._checkUniform(D),this._colors4Arrays[D]=h.reduce(((D,h)=>(D.push(h.r,h.g,h.b,h.a),D)),[]),this}setVector2(D,h){return this._checkUniform(D),this._vectors2[D]=h,this}setVector3(D,h){return this._checkUniform(D),this._vectors3[D]=h,this}setVector4(D,h){return this._checkUniform(D),this._vectors4[D]=h,this}setQuaternion(D,h){return this._checkUniform(D),this._quaternions[D]=h,this}setQuaternionArray(D,h){return this._checkUniform(D),this._quaternionsArrays[D]=h.reduce(((D,h)=>(h.toArray(D,D.length),D)),[]),this}setMatrix(D,h){return this._checkUniform(D),this._matrices[D]=h,this}setMatrices(D,h){this._checkUniform(D);const o=new Float32Array(16*h.length);for(let H=0;H<h.length;H++){h[H].copyToArray(o,16*H)}return this._matrixArrays[D]=o,this}setMatrix3x3(D,h){return this._checkUniform(D),this._matrices3x3[D]=h,this}setMatrix2x2(D,h){return this._checkUniform(D),this._matrices2x2[D]=h,this}setArray2(D,h){return this._checkUniform(D),this._vectors2Arrays[D]=h,this}setArray3(D,h){return this._checkUniform(D),this._vectors3Arrays[D]=h,this}setArray4(D,h){return this._checkUniform(D),this._vectors4Arrays[D]=h,this}setUniformBuffer(D,h){return-1===this._options.uniformBuffers.indexOf(D)&&this._options.uniformBuffers.push(D),this._uniformBuffers[D]=h,this}setTextureSampler(D,h){return-1===this._options.samplerObjects.indexOf(D)&&this._options.samplerObjects.push(D),this._textureSamplers[D]=h,this}setStorageBuffer(D,h){return-1===this._options.storageBuffers.indexOf(D)&&this._options.storageBuffers.push(D),this._storageBuffers[D]=h,this}setDefine(D,h){const o=D.trimEnd()+" ",H=this.options.defines.findIndex((h=>h===D||h.startsWith(o)));return H>=0&&this.options.defines.splice(H,1),("boolean"!==typeof h||h)&&this.options.defines.push(o+h),this}isReadyForSubMesh(D,h,o){return this.isReady(D,o,h)}isReady(D,h,o){var H;const j=o&&this._storeEffectOnSubMeshes;if(this.isFrozen){const D=j?o._drawWrapper:this._drawWrapper;if(D.effect&&D._wasPreviouslyReady&&D._wasPreviouslyUsingInstances===h)return!0}const R=this.GD(),t=R.getEngine(),k=[],K=[];let Q=null,s=this._shaderPath,U=this._options.uniforms,q=this._options.uniformBuffers,c=this._options.samplers;t.getCaps().multiview&&R.activeCamera&&R.activeCamera.outputRenderTarget&&R.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,k.push("#define MULTIVIEW"),-1!==U.indexOf("viewProjection")&&-1===U.indexOf("viewProjectionR")&&U.push("viewProjectionR"));for(let g=0;g<this._options.defines.length;g++){const D=0===this._options.defines[g].indexOf("#define")?this._options.defines[g]:`#define ${this._options.defines[g]}`;k.push(D)}for(let g=0;g<this._options.attributes.length;g++)K.push(this._options.attributes[g]);if(D&&D.isVerticesDataPresent(M.f.ColorKind)&&(-1===K.indexOf(M.f.ColorKind)&&K.push(M.f.ColorKind),k.push("#define VERTEXCOLOR")),h&&(k.push("#define INSTANCES"),(0,r.cb)(K,this._materialHelperNeedsPreviousMatrices),null!==D&&void 0!==D&&D.hasThinInstances&&(k.push("#define THIN_INSTANCES"),D&&D.isVerticesDataPresent(M.f.ColorInstanceKind)&&(K.push(M.f.ColorInstanceKind),k.push("#define INSTANCESCOLOR")))),D&&D.useBones&&D.computeBonesUsingShaders&&D.skeleton){K.push(M.f.MatricesIndicesKind),K.push(M.f.MatricesWeightsKind),D.numBoneInfluencers>4&&(K.push(M.f.MatricesIndicesExtraKind),K.push(M.f.MatricesWeightsExtraKind));const h=D.skeleton;k.push("#define NUM_BONE_INFLUENCERS "+D.numBoneInfluencers),Q=new S.c,Q.addCPUSkinningFallback(0,D),h.isUsingTextureForMatrices?(k.push("#define BONETEXTURE"),-1===U.indexOf("boneTextureWidth")&&U.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(k.push("#define BonesPerMesh "+(h.bones.length+1)),-1===U.indexOf("mBones")&&U.push("mBones"))}else k.push("#define NUM_BONE_INFLUENCERS 0");let y=0;const b=D?D.morphTargetManager:null;if(b){const h=-1!==k.indexOf("#define UV1"),o=-1!==k.indexOf("#define UV2"),H=-1!==k.indexOf("#define TANGENT"),g=-1!==k.indexOf("#define NORMAL"),j=-1!==k.indexOf("#define VERTEXCOLOR");y=(0,r.E)(b,k,K,D,!0,g,H,h,o,j),b.isUsingTextureForTargets&&(-1===U.indexOf("morphTargetTextureIndices")&&U.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),y>0&&(U=U.slice(),U.push("morphTargetInfluences"),U.push("morphTargetCount"),U.push("morphTargetTextureInfo"),U.push("morphTargetTextureIndices"))}else k.push("#define NUM_MORPH_INFLUENCERS 0");if(D){const h=D.bakedVertexAnimationManager;h&&h.isEnabled&&(k.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===U.indexOf("bakedVertexAnimationSettings")&&U.push("bakedVertexAnimationSettings"),-1===U.indexOf("bakedVertexAnimationTextureSizeInverted")&&U.push("bakedVertexAnimationTextureSizeInverted"),-1===U.indexOf("bakedVertexAnimationTime")&&U.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,r.r)(K,D,k)}for(const g in this._textures)if(!this._textures[g].isReady())return!1;D&&this.needAlphaTestingForMesh(D)&&k.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,v.e)(U),(0,v.k)(this,R,k)),R.fogEnabled&&null!==D&&void 0!==D&&D.applyFog&&R.fogMode!==g.b.FOGMODE_NONE&&(k.push("#define FOG"),-1===U.indexOf("view")&&U.push("view"),-1===U.indexOf("vFogInfos")&&U.push("vFogInfos"),-1===U.indexOf("vFogColor")&&U.push("vFogColor")),this._useLogarithmicDepth&&(k.push("#define LOGARITHMICDEPTH"),-1===U.indexOf("logarithmicDepthConstant")&&U.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(U=U.slice(),q=q.slice(),c=c.slice(),s=this.customShaderNameResolve(this.name,U,q,c,k,K));const i=j?o._getDrawWrapper(void 0,!0):this._drawWrapper,G=(null===i||void 0===i?void 0:i.effect)??null,N=(null===i||void 0===i?void 0:i.defines)??null,J=k.join("\n");let O=G;return N!==J&&(O=t.createEffect(s,{attributes:K,uniformsNames:U,uniformBuffersNames:q,samplers:c,defines:J,fallbacks:Q,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:y},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},t),j?o.setEffect(O,J,this._materialContext):i&&i.setEffect(O,J),this._onEffectCreatedObservable&&(B.effect=O,B.subMesh=o??(null===D||void 0===D?void 0:D.nh[0])??null,this._onEffectCreatedObservable.notifyObservers(B))),i._wasPreviouslyUsingInstances=!!h,!(null===(H=O)||void 0===H||!H.isReady())&&(G!==O&&R.resetCachedMaterial(),i._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(D,h){const o=h??this.getEffect();if(!o)return;const H=this._options.uniforms;-1!==H.indexOf("world")&&o.setMatrix("world",D);const g=this.GD();-1!==H.indexOf("worldView")&&(D.multiplyToRef(g.getViewMatrix(),this._cachedWorldViewMatrix),o.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==H.indexOf("worldViewProjection")&&(D.multiplyToRef(g.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),o.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==H.indexOf("view")&&o.setMatrix("view",g.getViewMatrix())}bindForSubMesh(D,h,o){var H;this.bind(D,h,null===(H=o._drawWrapperOverride)||void 0===H?void 0:H.effect,o)}bind(D,h,o,H){const g=H&&this._storeEffectOnSubMeshes,j=o??(g?H.effect:this.getEffect());if(!j)return;const M=this.GD();this._activeEffect=j,this.bindOnlyWorldMatrix(D,o);const R=this._options.uniformBuffers;let t=!1;if(j&&R&&R.length>0&&M.getEngine().supportsUniformBuffers)for(let K=0;K<R.length;++K){switch(R[K]){case"Mesh":h&&(h.getMeshUniformBuffer().bindToEffect(j,"Mesh"),h.transferToEffect(D));break;case"Scene":(0,r.n)(j,M.getSceneUniformBuffer()),M.finalizeSceneUbo(),t=!0}}const S=h&&g?this._mustRebind(M,j,H,h.visibility):M.getCachedMaterial()!==this;if(j&&S){let D;for(D in t||-1===this._options.uniforms.indexOf("view")||j.setMatrix("view",M.getViewMatrix()),t||-1===this._options.uniforms.indexOf("projection")||j.setMatrix("projection",M.getProjectionMatrix()),t||-1===this._options.uniforms.indexOf("viewProjection")||(j.setMatrix("viewProjection",M.getTransformMatrix()),this._multiview&&j.setMatrix("viewProjectionR",M._transformMatrixR)),M.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&j.setVector3("cameraPosition",M.activeCamera.globalPosition),(0,r.b)(h,j),(0,v.g)(j,this,M),this._useLogarithmicDepth&&(0,r.j)(g?H.materialDefines:j.defines,j,M),h&&(0,r.d)(M,h,j),this._textures)j.setTexture(D,this._textures[D]);for(D in this._textureArrays)j.setTextureArray(D,this._textureArrays[D]);for(D in this._ints)j.setInt(D,this._ints[D]);for(D in this._uints)j.setUInt(D,this._uints[D]);for(D in this._floats)j.setFloat(D,this._floats[D]);for(D in this._floatsArrays)j.setArray(D,this._floatsArrays[D]);for(D in this._colors3)j.setColor3(D,this._colors3[D]);for(D in this._colors3Arrays)j.setArray3(D,this._colors3Arrays[D]);for(D in this._colors4){const h=this._colors4[D];j.setFloat4(D,h.r,h.g,h.b,h.a)}for(D in this._colors4Arrays)j.setArray4(D,this._colors4Arrays[D]);for(D in this._vectors2)j.setVector2(D,this._vectors2[D]);for(D in this._vectors3)j.setVector3(D,this._vectors3[D]);for(D in this._vectors4)j.setVector4(D,this._vectors4[D]);for(D in this._quaternions)j.setQuaternion(D,this._quaternions[D]);for(D in this._matrices)j.setMatrix(D,this._matrices[D]);for(D in this._matrixArrays)j.setMatrices(D,this._matrixArrays[D]);for(D in this._matrices3x3)j.setMatrix3x3(D,this._matrices3x3[D]);for(D in this._matrices2x2)j.setMatrix2x2(D,this._matrices2x2[D]);for(D in this._vectors2Arrays)j.setArray2(D,this._vectors2Arrays[D]);for(D in this._vectors3Arrays)j.setArray3(D,this._vectors3Arrays[D]);for(D in this._vectors4Arrays)j.setArray4(D,this._vectors4Arrays[D]);for(D in this._quaternionsArrays)j.setArray4(D,this._quaternionsArrays[D]);for(D in this._uniformBuffers){const h=this._uniformBuffers[D].getBuffer();h&&j.bindUniformBuffer(h,D)}const o=M.getEngine(),R=o.setExternalTexture;if(R)for(D in this._externalTextures)R.call(o,D,this._externalTextures[D]);const S=o.setTextureSampler;if(S)for(D in this._textureSamplers)S.call(o,D,this._textureSamplers[D]);const k=o.setStorageBuffer;if(k)for(D in this._storageBuffers)k.call(o,D,this._storageBuffers[D])}if(j&&h&&(S||!this.isFrozen)){(0,r.k)(h,j),h.morphTargetManager&&h.morphTargetManager.isUsingTextureForTargets&&h.morphTargetManager._bind(j);const D=h.bakedVertexAnimationManager;if(D&&D.isEnabled){var k;const D=g?H._drawWrapper:this._drawWrapper;null===(k=h.bakedVertexAnimationManager)||void 0===k||k.bind(j,!!D._wasPreviouslyUsingInstances)}}this._afterBind(h,j,H)}getActiveTextures(){const D=super.getActiveTextures();for(const h in this._textures)D.push(this._textures[h]);for(const h in this._textureArrays){const o=this._textureArrays[h];for(let h=0;h<o.length;h++)D.push(o[h])}return D}hasTexture(D){if(super.hasTexture(D))return!0;for(const h in this._textures)if(this._textures[h]===D)return!0;for(const h in this._textureArrays){const o=this._textureArrays[h];for(let h=0;h<o.length;h++)if(o[h]===D)return!0}return!1}clone(D){const h=H.d.Clone((()=>new s(D,this.GD(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);h.name=D,h.id=D,"object"===typeof h._shaderPath&&(h._shaderPath={...h._shaderPath}),this._options={...this._options};const o=Object.keys(this._options);for(const H of o){const D=this._options[H];Array.isArray(D)&&(this._options[H]=D.slice(0))}this.Oh.copyTo(h.Oh);for(const H in this._textures)h.setTexture(H,this._textures[H]);for(const H in this._textureArrays)h.setTextureArray(H,this._textureArrays[H]);for(const H in this._externalTextures)h.setExternalTexture(H,this._externalTextures[H]);for(const H in this._ints)h.setInt(H,this._ints[H]);for(const H in this._uints)h.setUInt(H,this._uints[H]);for(const H in this._floats)h.setFloat(H,this._floats[H]);for(const H in this._floatsArrays)h.setFloats(H,this._floatsArrays[H]);for(const H in this._colors3)h.setColor3(H,this._colors3[H]);for(const H in this._colors3Arrays)h._colors3Arrays[H]=this._colors3Arrays[H];for(const H in this._colors4)h.setColor4(H,this._colors4[H]);for(const H in this._colors4Arrays)h._colors4Arrays[H]=this._colors4Arrays[H];for(const H in this._vectors2)h.setVector2(H,this._vectors2[H]);for(const H in this._vectors3)h.setVector3(H,this._vectors3[H]);for(const H in this._vectors4)h.setVector4(H,this._vectors4[H]);for(const H in this._quaternions)h.setQuaternion(H,this._quaternions[H]);for(const H in this._quaternionsArrays)h._quaternionsArrays[H]=this._quaternionsArrays[H];for(const H in this._matrices)h.setMatrix(H,this._matrices[H]);for(const H in this._matrixArrays)h._matrixArrays[H]=this._matrixArrays[H].slice();for(const H in this._matrices3x3)h.setMatrix3x3(H,this._matrices3x3[H]);for(const H in this._matrices2x2)h.setMatrix2x2(H,this._matrices2x2[H]);for(const H in this._vectors2Arrays)h.setArray2(H,this._vectors2Arrays[H]);for(const H in this._vectors3Arrays)h.setArray3(H,this._vectors3Arrays[H]);for(const H in this._vectors4Arrays)h.setArray4(H,this._vectors4Arrays[H]);for(const H in this._uniformBuffers)h.setUniformBuffer(H,this._uniformBuffers[H]);for(const H in this._textureSamplers)h.setTextureSampler(H,this._textureSamplers[H]);for(const H in this._storageBuffers)h.setStorageBuffer(H,this._storageBuffers[H]);return h}dispose(D,h,o){if(h){let D;for(D in this._textures)this._textures[D].dispose();for(D in this._textureArrays){const h=this._textureArrays[D];for(let D=0;D<h.length;D++)h[D].dispose()}}this._textures={},super.dispose(D,h,o)}serialize(){const D=H.d.Serialize(this);let h;for(h in D.customType="BABYLON.ShaderMaterial",D.uniqueId=this.uniqueId,D.options=this._options,D.shaderPath=this._shaderPath,D.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,D.Oh=this.Oh.serialize(),D.textures={},this._textures)D.textures[h]=this._textures[h].serialize();for(h in D.textureArrays={},this._textureArrays){D.textureArrays[h]=[];const o=this._textureArrays[h];for(let H=0;H<o.length;H++)D.textureArrays[h].push(o[H].serialize())}for(h in D.ints={},this._ints)D.ints[h]=this._ints[h];for(h in D.uints={},this._uints)D.uints[h]=this._uints[h];for(h in D.floats={},this._floats)D.floats[h]=this._floats[h];for(h in D.floatsArrays={},this._floatsArrays)D.floatsArrays[h]=this._floatsArrays[h];for(h in D.colors3={},this._colors3){const o=this._colors3[h];D.colors3[h]=[o.r,o.g,o.b]}for(h in D.colors3Arrays={},this._colors3Arrays)D.colors3Arrays[h]=this._colors3Arrays[h];for(h in D.colors4={},this._colors4){const o=this._colors4[h];D.colors4[h]=[o.r,o.g,o.b,o.a]}for(h in D.colors4Arrays={},this._colors4Arrays)D.colors4Arrays[h]=this._colors4Arrays[h];for(h in D.vectors2={},this._vectors2){const o=this._vectors2[h];D.vectors2[h]=[o.x,o.y]}for(h in D.vectors3={},this._vectors3){const o=this._vectors3[h];D.vectors3[h]=[o.x,o.y,o.z]}for(h in D.vectors4={},this._vectors4){const o=this._vectors4[h];D.vectors4[h]=[o.x,o.y,o.z,o.w]}for(h in D.quaternions={},this._quaternions)D.quaternions[h]=this._quaternions[h].Fh();for(h in D.matrices={},this._matrices)D.matrices[h]=this._matrices[h].Fh();for(h in D.matrixArray={},this._matrixArrays)D.matrixArray[h]=this._matrixArrays[h];for(h in D.matrices3x3={},this._matrices3x3)D.matrices3x3[h]=this._matrices3x3[h];for(h in D.matrices2x2={},this._matrices2x2)D.matrices2x2[h]=this._matrices2x2[h];for(h in D.vectors2Arrays={},this._vectors2Arrays)D.vectors2Arrays[h]=this._vectors2Arrays[h];for(h in D.vectors3Arrays={},this._vectors3Arrays)D.vectors3Arrays[h]=this._vectors3Arrays[h];for(h in D.vectors4Arrays={},this._vectors4Arrays)D.vectors4Arrays[h]=this._vectors4Arrays[h];for(h in D.quaternionsArrays={},this._quaternionsArrays)D.quaternionsArrays[h]=this._quaternionsArrays[h];return D}static Parse(D,h,o){const g=H.d.Parse((()=>new s(D.name,h,D.shaderPath,D.options,D.storeEffectOnSubMeshes)),D,h,o);let M;for(M in D.Oh&&g.Oh.parse(D.Oh,h,o),D.textures)g.setTexture(M,R.b.Parse(D.textures[M],h,o));for(M in D.textureArrays){const H=D.textureArrays[M],j=[];for(let D=0;D<H.length;D++)j.push(R.b.Parse(H[D],h,o));g.setTextureArray(M,j)}for(M in D.ints)g.setInt(M,D.ints[M]);for(M in D.uints)g.setUInt(M,D.uints[M]);for(M in D.floats)g.setFloat(M,D.floats[M]);for(M in D.floatsArrays)g.setFloats(M,D.floatsArrays[M]);for(M in D.colors3){const h=D.colors3[M];g.setColor3(M,{r:h[0],g:h[1],b:h[2]})}for(M in D.colors3Arrays){const h=D.colors3Arrays[M].reduce(((D,h,o)=>(o%3===0?D.push([h]):D[D.length-1].push(h),D)),[]).map((D=>({r:D[0],g:D[1],b:D[2]})));g.setColor3Array(M,h)}for(M in D.colors4){const h=D.colors4[M];g.setColor4(M,{r:h[0],g:h[1],b:h[2],a:h[3]})}for(M in D.colors4Arrays){const h=D.colors4Arrays[M].reduce(((D,h,o)=>(o%4===0?D.push([h]):D[D.length-1].push(h),D)),[]).map((D=>({r:D[0],g:D[1],b:D[2],a:D[3]})));g.setColor4Array(M,h)}for(M in D.vectors2){const h=D.vectors2[M];g.setVector2(M,{x:h[0],y:h[1]})}for(M in D.vectors3){const h=D.vectors3[M];g.setVector3(M,{x:h[0],y:h[1],z:h[2]})}for(M in D.vectors4){const h=D.vectors4[M];g.setVector4(M,{x:h[0],y:h[1],z:h[2],w:h[3]})}for(M in D.quaternions)g.setQuaternion(M,j.Quaternion.Ih(D.quaternions[M]));for(M in D.matrices)g.setMatrix(M,j.Matrix.Ih(D.matrices[M]));for(M in D.matrixArray)g._matrixArrays[M]=new Float32Array(D.matrixArray[M]);for(M in D.matrices3x3)g.setMatrix3x3(M,D.matrices3x3[M]);for(M in D.matrices2x2)g.setMatrix2x2(M,D.matrices2x2[M]);for(M in D.vectors2Arrays)g.setArray2(M,D.vectors2Arrays[M]);for(M in D.vectors3Arrays)g.setArray3(M,D.vectors3Arrays[M]);for(M in D.vectors4Arrays)g.setArray4(M,D.vectors4Arrays[M]);for(M in D.quaternionsArrays)g.setArray4(M,D.quaternionsArrays[M]);return g}static async ParseFromFileAsync(D,h,o){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((g,j)=>{const M=new k.e;M.addEventListener("readystatechange",(()=>{if(4==M.readyState)if(200==M.status){const h=JSON.parse(M.responseText),j=this.Parse(h,o||Q.d.LastCreatedScene,H);D&&(j.name=D),g(j)}else j("Unable to load the ShaderMaterial")})),M.open("GET",h),M.send()}))}static async ParseFromSnippetAsync(D,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((H,g)=>{const j=new k.e;j.addEventListener("readystatechange",(()=>{if(4==j.readyState)if(200==j.status){const g=JSON.parse(JSON.parse(j.responseText).jsonPayload),M=JSON.parse(g.shaderMaterial),R=this.Parse(M,h||Q.d.LastCreatedScene,o);R.snippetId=D,H(R)}else g("Unable to load the snippet "+D)})),j.open("GET",this.SnippetUrl+"/"+D.replace(/#/g,"/")),j.send()}))}}s.SnippetUrl="https://snippet.babylonjs.com",s.CreateFromSnippetAsync=s.ParseFromSnippetAsync,(0,t.g)("BABYLON.ShaderMaterial",s)}}]);