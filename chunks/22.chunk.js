"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[22],{11336:(q,S,b)=>{b.r(S),b.d(S,{ShaderMaterial:()=>H});var z=b(11137),C=b(11339),v=b(11103),U=b(11172),g=b(11075),r=b(11058),I=b(11412),V=b(10966),l=b(11416),y=b(10975),R=b(11476),G=b(11468);const Z={effect:null,subMesh:null};class H extends l.b{constructor(q,S,b){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(q,S,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new v.Matrix,this._cachedWorldViewProjectionMatrix=new v.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=b,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...z}}get shaderPath(){return this._shaderPath}set shaderPath(q){this._shaderPath=q}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(q){-1===this._options.uniforms.indexOf(q)&&this._options.uniforms.push(q)}setTexture(q,S){return-1===this._options.samplers.indexOf(q)&&this._options.samplers.push(q),this._textures[q]=S,this}removeTexture(q){delete this._textures[q]}setTextureArray(q,S){return-1===this._options.samplers.indexOf(q)&&this._options.samplers.push(q),this._checkUniform(q),this._textureArrays[q]=S,this}setExternalTexture(q,S){return-1===this._options.externalTextures.indexOf(q)&&this._options.externalTextures.push(q),this._externalTextures[q]=S,this}setFloat(q,S){return this._checkUniform(q),this._floats[q]=S,this}setInt(q,S){return this._checkUniform(q),this._ints[q]=S,this}setUInt(q,S){return this._checkUniform(q),this._uints[q]=S,this}setFloats(q,S){return this._checkUniform(q),this._floatsArrays[q]=S,this}setColor3(q,S){return this._checkUniform(q),this._colors3[q]=S,this}setColor3Array(q,S){return this._checkUniform(q),this._colors3Arrays[q]=S.reduce(((q,S)=>(q.push(S.r,S.g,S.b),q)),[]),this}setColor4(q,S){return this._checkUniform(q),this._colors4[q]=S,this}setColor4Array(q,S){return this._checkUniform(q),this._colors4Arrays[q]=S.reduce(((q,S)=>(q.push(S.r,S.g,S.b,S.a),q)),[]),this}setVector2(q,S){return this._checkUniform(q),this._vectors2[q]=S,this}setVector3(q,S){return this._checkUniform(q),this._vectors3[q]=S,this}setVector4(q,S){return this._checkUniform(q),this._vectors4[q]=S,this}setQuaternion(q,S){return this._checkUniform(q),this._quaternions[q]=S,this}setQuaternionArray(q,S){return this._checkUniform(q),this._quaternionsArrays[q]=S.reduce(((q,S)=>(S.toArray(q,q.length),q)),[]),this}setMatrix(q,S){return this._checkUniform(q),this._matrices[q]=S,this}setMatrices(q,S){this._checkUniform(q);const b=new Float32Array(16*S.length);for(let z=0;z<S.length;z++){S[z].copyToArray(b,16*z)}return this._matrixArrays[q]=b,this}setMatrix3x3(q,S){return this._checkUniform(q),this._matrices3x3[q]=S,this}setMatrix2x2(q,S){return this._checkUniform(q),this._matrices2x2[q]=S,this}setArray2(q,S){return this._checkUniform(q),this._vectors2Arrays[q]=S,this}setArray3(q,S){return this._checkUniform(q),this._vectors3Arrays[q]=S,this}setArray4(q,S){return this._checkUniform(q),this._vectors4Arrays[q]=S,this}setUniformBuffer(q,S){return-1===this._options.uniformBuffers.indexOf(q)&&this._options.uniformBuffers.push(q),this._uniformBuffers[q]=S,this}setTextureSampler(q,S){return-1===this._options.samplerObjects.indexOf(q)&&this._options.samplerObjects.push(q),this._textureSamplers[q]=S,this}setStorageBuffer(q,S){return-1===this._options.storageBuffers.indexOf(q)&&this._options.storageBuffers.push(q),this._storageBuffers[q]=S,this}setDefine(q,S){const b=q.trimEnd()+" ",z=this.options.defines.findIndex((S=>S===q||S.startsWith(b)));return z>=0&&this.options.defines.splice(z,1),("boolean"!==typeof S||S)&&this.options.defines.push(b+S),this}isReadyForSubMesh(q,S,b){return this.isReady(q,b,S)}isReady(q,S,b){var z;const v=b&&this._storeEffectOnSubMeshes;if(this.isFrozen){const q=v?b._drawWrapper:this._drawWrapper;if(q.effect&&q._wasPreviouslyReady&&q._wasPreviouslyUsingInstances===S)return!0}const g=this.Tq(),r=g.getEngine(),V=[],l=[];let y=null,H=this._shaderPath,Q=this._options.uniforms,k=this._options.uniformBuffers,W=this._options.samplers;r.getCaps().multiview&&g.activeCamera&&g.activeCamera.outputRenderTarget&&g.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,V.push("#define MULTIVIEW"),-1!==Q.indexOf("viewProjection")&&-1===Q.indexOf("viewProjectionR")&&Q.push("viewProjectionR"));for(let C=0;C<this._options.defines.length;C++){const q=0===this._options.defines[C].indexOf("#define")?this._options.defines[C]:`#define ${this._options.defines[C]}`;V.push(q)}for(let C=0;C<this._options.attributes.length;C++)l.push(this._options.attributes[C]);if(q&&q.isVerticesDataPresent(U.f.ColorKind)&&(-1===l.indexOf(U.f.ColorKind)&&l.push(U.f.ColorKind),V.push("#define VERTEXCOLOR")),S&&(V.push("#define INSTANCES"),(0,G.nb)(l,this._materialHelperNeedsPreviousMatrices),null!==q&&void 0!==q&&q.hasThinInstances&&(V.push("#define THIN_INSTANCES"),q&&q.isVerticesDataPresent(U.f.ColorInstanceKind)&&(l.push(U.f.ColorInstanceKind),V.push("#define INSTANCESCOLOR")))),q&&q.useBones&&q.computeBonesUsingShaders&&q.skeleton){l.push(U.f.MatricesIndicesKind),l.push(U.f.MatricesWeightsKind),q.numBoneInfluencers>4&&(l.push(U.f.MatricesIndicesExtraKind),l.push(U.f.MatricesWeightsExtraKind));const S=q.skeleton;V.push("#define NUM_BONE_INFLUENCERS "+q.numBoneInfluencers),y=new I.b,y.addCPUSkinningFallback(0,q),S.isUsingTextureForMatrices?(V.push("#define BONETEXTURE"),-1===Q.indexOf("boneTextureWidth")&&Q.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(V.push("#define BonesPerMesh "+(S.bones.length+1)),-1===Q.indexOf("mBones")&&Q.push("mBones"))}else V.push("#define NUM_BONE_INFLUENCERS 0");let N=0;const u=q?q.morphTargetManager:null;if(u){const S=-1!==V.indexOf("#define UV1"),b=-1!==V.indexOf("#define UV2"),z=-1!==V.indexOf("#define TANGENT"),C=-1!==V.indexOf("#define NORMAL"),v=-1!==V.indexOf("#define VERTEXCOLOR");N=(0,G.O)(u,V,l,q,!0,C,z,S,b,v),u.isUsingTextureForTargets&&(-1===Q.indexOf("morphTargetTextureIndices")&&Q.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),N>0&&(Q=Q.slice(),Q.push("morphTargetInfluences"),Q.push("morphTargetCount"),Q.push("morphTargetTextureInfo"),Q.push("morphTargetTextureIndices"))}else V.push("#define NUM_MORPH_INFLUENCERS 0");if(q){const S=q.bakedVertexAnimationManager;S&&S.isEnabled&&(V.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===Q.indexOf("bakedVertexAnimationSettings")&&Q.push("bakedVertexAnimationSettings"),-1===Q.indexOf("bakedVertexAnimationTextureSizeInverted")&&Q.push("bakedVertexAnimationTextureSizeInverted"),-1===Q.indexOf("bakedVertexAnimationTime")&&Q.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,G.A)(l,q,V)}for(const C in this._textures)if(!this._textures[C].isReady())return!1;q&&this.needAlphaTestingForMesh(q)&&V.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,R.d)(Q),(0,R.k)(this,g,V)),g.fogEnabled&&null!==q&&void 0!==q&&q.applyFog&&g.fogMode!==C.c.FOGMODE_NONE&&(V.push("#define FOG"),-1===Q.indexOf("view")&&Q.push("view"),-1===Q.indexOf("vFogInfos")&&Q.push("vFogInfos"),-1===Q.indexOf("vFogColor")&&Q.push("vFogColor")),this._useLogarithmicDepth&&(V.push("#define LOGARITHMICDEPTH"),-1===Q.indexOf("logarithmicDepthConstant")&&Q.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(Q=Q.slice(),k=k.slice(),W=W.slice(),H=this.customShaderNameResolve(this.name,Q,k,W,V,l));const X=v?b._getDrawWrapper(void 0,!0):this._drawWrapper,T=(null===X||void 0===X?void 0:X.effect)??null,B=(null===X||void 0===X?void 0:X.defines)??null,t=V.join("\n");let f=T;return B!==t&&(f=r.createEffect(H,{attributes:l,uniformsNames:Q,uniformBuffersNames:k,samplers:W,defines:t,fallbacks:y,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:N},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},r),v?b.setEffect(f,t,this._materialContext):X&&X.setEffect(f,t),this._onEffectCreatedObservable&&(Z.effect=f,Z.subMesh=b??(null===q||void 0===q?void 0:q.Gb[0])??null,this._onEffectCreatedObservable.notifyObservers(Z))),X._wasPreviouslyUsingInstances=!!S,!(null===(z=f)||void 0===z||!z.isReady())&&(T!==f&&g.resetCachedMaterial(),X._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(q,S){const b=S??this.getEffect();if(!b)return;const z=this._options.uniforms;-1!==z.indexOf("world")&&b.setMatrix("world",q);const C=this.Tq();-1!==z.indexOf("worldView")&&(q.multiplyToRef(C.getViewMatrix(),this._cachedWorldViewMatrix),b.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==z.indexOf("worldViewProjection")&&(q.multiplyToRef(C.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),b.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==z.indexOf("view")&&b.setMatrix("view",C.getViewMatrix())}bindForSubMesh(q,S,b){var z;this.bind(q,S,null===(z=b._drawWrapperOverride)||void 0===z?void 0:z.effect,b)}bind(q,S,b,z){const C=z&&this._storeEffectOnSubMeshes,v=b??(C?z.effect:this.getEffect());if(!v)return;const U=this.Tq();this._activeEffect=v,this.bindOnlyWorldMatrix(q,b);const g=this._options.uniformBuffers;let r=!1;if(v&&g&&g.length>0&&U.getEngine().supportsUniformBuffers)for(let l=0;l<g.length;++l){switch(g[l]){case"Mesh":S&&(S.getMeshUniformBuffer().bindToEffect(v,"Mesh"),S.transferToEffect(q));break;case"Scene":(0,G.q)(v,U.getSceneUniformBuffer()),U.finalizeSceneUbo(),r=!0}}const I=S&&C?this._mustRebind(U,v,z,S.visibility):U.getCachedMaterial()!==this;if(v&&I){let q;for(q in r||-1===this._options.uniforms.indexOf("view")||v.setMatrix("view",U.getViewMatrix()),r||-1===this._options.uniforms.indexOf("projection")||v.setMatrix("projection",U.getProjectionMatrix()),r||-1===this._options.uniforms.indexOf("viewProjection")||(v.setMatrix("viewProjection",U.getTransformMatrix()),this._multiview&&v.setMatrix("viewProjectionR",U._transformMatrixR)),U.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&v.setVector3("cameraPosition",U.activeCamera.globalPosition),(0,G.c)(S,v),(0,R.f)(v,this,U),this._useLogarithmicDepth&&(0,G.l)(C?z.materialDefines:v.defines,v,U),S&&(0,G.g)(U,S,v),this._textures)v.setTexture(q,this._textures[q]);for(q in this._textureArrays)v.setTextureArray(q,this._textureArrays[q]);for(q in this._ints)v.setInt(q,this._ints[q]);for(q in this._uints)v.setUInt(q,this._uints[q]);for(q in this._floats)v.setFloat(q,this._floats[q]);for(q in this._floatsArrays)v.setArray(q,this._floatsArrays[q]);for(q in this._colors3)v.setColor3(q,this._colors3[q]);for(q in this._colors3Arrays)v.setArray3(q,this._colors3Arrays[q]);for(q in this._colors4){const S=this._colors4[q];v.setFloat4(q,S.r,S.g,S.b,S.a)}for(q in this._colors4Arrays)v.setArray4(q,this._colors4Arrays[q]);for(q in this._vectors2)v.setVector2(q,this._vectors2[q]);for(q in this._vectors3)v.setVector3(q,this._vectors3[q]);for(q in this._vectors4)v.setVector4(q,this._vectors4[q]);for(q in this._quaternions)v.setQuaternion(q,this._quaternions[q]);for(q in this._matrices)v.setMatrix(q,this._matrices[q]);for(q in this._matrixArrays)v.setMatrices(q,this._matrixArrays[q]);for(q in this._matrices3x3)v.setMatrix3x3(q,this._matrices3x3[q]);for(q in this._matrices2x2)v.setMatrix2x2(q,this._matrices2x2[q]);for(q in this._vectors2Arrays)v.setArray2(q,this._vectors2Arrays[q]);for(q in this._vectors3Arrays)v.setArray3(q,this._vectors3Arrays[q]);for(q in this._vectors4Arrays)v.setArray4(q,this._vectors4Arrays[q]);for(q in this._quaternionsArrays)v.setArray4(q,this._quaternionsArrays[q]);for(q in this._uniformBuffers){const S=this._uniformBuffers[q].getBuffer();S&&v.bindUniformBuffer(S,q)}const b=U.getEngine(),g=b.setExternalTexture;if(g)for(q in this._externalTextures)g.call(b,q,this._externalTextures[q]);const I=b.setTextureSampler;if(I)for(q in this._textureSamplers)I.call(b,q,this._textureSamplers[q]);const V=b.setStorageBuffer;if(V)for(q in this._storageBuffers)V.call(b,q,this._storageBuffers[q])}if(v&&S&&(I||!this.isFrozen)){(0,G.o)(S,v),S.morphTargetManager&&S.morphTargetManager.isUsingTextureForTargets&&S.morphTargetManager._bind(v);const q=S.bakedVertexAnimationManager;if(q&&q.isEnabled){var V;const q=C?z._drawWrapper:this._drawWrapper;null===(V=S.bakedVertexAnimationManager)||void 0===V||V.bind(v,!!q._wasPreviouslyUsingInstances)}}this._afterBind(S,v,z)}getActiveTextures(){const q=super.getActiveTextures();for(const S in this._textures)q.push(this._textures[S]);for(const S in this._textureArrays){const b=this._textureArrays[S];for(let S=0;S<b.length;S++)q.push(b[S])}return q}hasTexture(q){if(super.hasTexture(q))return!0;for(const S in this._textures)if(this._textures[S]===q)return!0;for(const S in this._textureArrays){const b=this._textureArrays[S];for(let S=0;S<b.length;S++)if(b[S]===q)return!0}return!1}clone(q){const S=z.b.Clone((()=>new H(q,this.Tq(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);S.name=q,S.id=q,"object"===typeof S._shaderPath&&(S._shaderPath={...S._shaderPath}),this._options={...this._options};const b=Object.keys(this._options);for(const z of b){const q=this._options[z];Array.isArray(q)&&(this._options[z]=q.slice(0))}this.stencil.copyTo(S.stencil);for(const z in this._textures)S.setTexture(z,this._textures[z]);for(const z in this._textureArrays)S.setTextureArray(z,this._textureArrays[z]);for(const z in this._externalTextures)S.setExternalTexture(z,this._externalTextures[z]);for(const z in this._ints)S.setInt(z,this._ints[z]);for(const z in this._uints)S.setUInt(z,this._uints[z]);for(const z in this._floats)S.setFloat(z,this._floats[z]);for(const z in this._floatsArrays)S.setFloats(z,this._floatsArrays[z]);for(const z in this._colors3)S.setColor3(z,this._colors3[z]);for(const z in this._colors3Arrays)S._colors3Arrays[z]=this._colors3Arrays[z];for(const z in this._colors4)S.setColor4(z,this._colors4[z]);for(const z in this._colors4Arrays)S._colors4Arrays[z]=this._colors4Arrays[z];for(const z in this._vectors2)S.setVector2(z,this._vectors2[z]);for(const z in this._vectors3)S.setVector3(z,this._vectors3[z]);for(const z in this._vectors4)S.setVector4(z,this._vectors4[z]);for(const z in this._quaternions)S.setQuaternion(z,this._quaternions[z]);for(const z in this._quaternionsArrays)S._quaternionsArrays[z]=this._quaternionsArrays[z];for(const z in this._matrices)S.setMatrix(z,this._matrices[z]);for(const z in this._matrixArrays)S._matrixArrays[z]=this._matrixArrays[z].slice();for(const z in this._matrices3x3)S.setMatrix3x3(z,this._matrices3x3[z]);for(const z in this._matrices2x2)S.setMatrix2x2(z,this._matrices2x2[z]);for(const z in this._vectors2Arrays)S.setArray2(z,this._vectors2Arrays[z]);for(const z in this._vectors3Arrays)S.setArray3(z,this._vectors3Arrays[z]);for(const z in this._vectors4Arrays)S.setArray4(z,this._vectors4Arrays[z]);for(const z in this._uniformBuffers)S.setUniformBuffer(z,this._uniformBuffers[z]);for(const z in this._textureSamplers)S.setTextureSampler(z,this._textureSamplers[z]);for(const z in this._storageBuffers)S.setStorageBuffer(z,this._storageBuffers[z]);return S}dispose(q,S,b){if(S){let q;for(q in this._textures)this._textures[q].dispose();for(q in this._textureArrays){const S=this._textureArrays[q];for(let q=0;q<S.length;q++)S[q].dispose()}}this._textures={},super.dispose(q,S,b)}serialize(){const q=z.b.Serialize(this);let S;for(S in q.customType="BABYLON.ShaderMaterial",q.uniqueId=this.uniqueId,q.options=this._options,q.shaderPath=this._shaderPath,q.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,q.stencil=this.stencil.serialize(),q.textures={},this._textures)q.textures[S]=this._textures[S].serialize();for(S in q.textureArrays={},this._textureArrays){q.textureArrays[S]=[];const b=this._textureArrays[S];for(let z=0;z<b.length;z++)q.textureArrays[S].push(b[z].serialize())}for(S in q.ints={},this._ints)q.ints[S]=this._ints[S];for(S in q.uints={},this._uints)q.uints[S]=this._uints[S];for(S in q.floats={},this._floats)q.floats[S]=this._floats[S];for(S in q.floatsArrays={},this._floatsArrays)q.floatsArrays[S]=this._floatsArrays[S];for(S in q.colors3={},this._colors3){const b=this._colors3[S];q.colors3[S]=[b.r,b.g,b.b]}for(S in q.colors3Arrays={},this._colors3Arrays)q.colors3Arrays[S]=this._colors3Arrays[S];for(S in q.colors4={},this._colors4){const b=this._colors4[S];q.colors4[S]=[b.r,b.g,b.b,b.a]}for(S in q.colors4Arrays={},this._colors4Arrays)q.colors4Arrays[S]=this._colors4Arrays[S];for(S in q.vectors2={},this._vectors2){const b=this._vectors2[S];q.vectors2[S]=[b.x,b.y]}for(S in q.vectors3={},this._vectors3){const b=this._vectors3[S];q.vectors3[S]=[b.x,b.y,b.z]}for(S in q.vectors4={},this._vectors4){const b=this._vectors4[S];q.vectors4[S]=[b.x,b.y,b.z,b.w]}for(S in q.quaternions={},this._quaternions)q.quaternions[S]=this._quaternions[S].Zb();for(S in q.matrices={},this._matrices)q.matrices[S]=this._matrices[S].Zb();for(S in q.matrixArray={},this._matrixArrays)q.matrixArray[S]=this._matrixArrays[S];for(S in q.matrices3x3={},this._matrices3x3)q.matrices3x3[S]=this._matrices3x3[S];for(S in q.matrices2x2={},this._matrices2x2)q.matrices2x2[S]=this._matrices2x2[S];for(S in q.vectors2Arrays={},this._vectors2Arrays)q.vectors2Arrays[S]=this._vectors2Arrays[S];for(S in q.vectors3Arrays={},this._vectors3Arrays)q.vectors3Arrays[S]=this._vectors3Arrays[S];for(S in q.vectors4Arrays={},this._vectors4Arrays)q.vectors4Arrays[S]=this._vectors4Arrays[S];for(S in q.quaternionsArrays={},this._quaternionsArrays)q.quaternionsArrays[S]=this._quaternionsArrays[S];return q}static Parse(q,S,b){const C=z.b.Parse((()=>new H(q.name,S,q.shaderPath,q.options,q.storeEffectOnSubMeshes)),q,S,b);let U;for(U in q.stencil&&C.stencil.parse(q.stencil,S,b),q.textures)C.setTexture(U,g.e.Parse(q.textures[U],S,b));for(U in q.textureArrays){const z=q.textureArrays[U],v=[];for(let q=0;q<z.length;q++)v.push(g.e.Parse(z[q],S,b));C.setTextureArray(U,v)}for(U in q.ints)C.setInt(U,q.ints[U]);for(U in q.uints)C.setUInt(U,q.uints[U]);for(U in q.floats)C.setFloat(U,q.floats[U]);for(U in q.floatsArrays)C.setFloats(U,q.floatsArrays[U]);for(U in q.colors3){const S=q.colors3[U];C.setColor3(U,{r:S[0],g:S[1],b:S[2]})}for(U in q.colors3Arrays){const S=q.colors3Arrays[U].reduce(((q,S,b)=>(b%3===0?q.push([S]):q[q.length-1].push(S),q)),[]).map((q=>({r:q[0],g:q[1],b:q[2]})));C.setColor3Array(U,S)}for(U in q.colors4){const S=q.colors4[U];C.setColor4(U,{r:S[0],g:S[1],b:S[2],a:S[3]})}for(U in q.colors4Arrays){const S=q.colors4Arrays[U].reduce(((q,S,b)=>(b%4===0?q.push([S]):q[q.length-1].push(S),q)),[]).map((q=>({r:q[0],g:q[1],b:q[2],a:q[3]})));C.setColor4Array(U,S)}for(U in q.vectors2){const S=q.vectors2[U];C.setVector2(U,{x:S[0],y:S[1]})}for(U in q.vectors3){const S=q.vectors3[U];C.setVector3(U,{x:S[0],y:S[1],z:S[2]})}for(U in q.vectors4){const S=q.vectors4[U];C.setVector4(U,{x:S[0],y:S[1],z:S[2],w:S[3]})}for(U in q.quaternions)C.setQuaternion(U,v.Quaternion.Hb(q.quaternions[U]));for(U in q.matrices)C.setMatrix(U,v.Matrix.Hb(q.matrices[U]));for(U in q.matrixArray)C._matrixArrays[U]=new Float32Array(q.matrixArray[U]);for(U in q.matrices3x3)C.setMatrix3x3(U,q.matrices3x3[U]);for(U in q.matrices2x2)C.setMatrix2x2(U,q.matrices2x2[U]);for(U in q.vectors2Arrays)C.setArray2(U,q.vectors2Arrays[U]);for(U in q.vectors3Arrays)C.setArray3(U,q.vectors3Arrays[U]);for(U in q.vectors4Arrays)C.setArray4(U,q.vectors4Arrays[U]);for(U in q.quaternionsArrays)C.setArray4(U,q.quaternionsArrays[U]);return C}static async ParseFromFileAsync(q,S,b){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((C,v)=>{const U=new V.c;U.addEventListener("readystatechange",(()=>{if(4==U.readyState)if(200==U.status){const S=JSON.parse(U.responseText),v=this.Parse(S,b||y.b.LastCreatedScene,z);q&&(v.name=q),C(v)}else v("Unable to load the ShaderMaterial")})),U.open("GET",S),U.send()}))}static async ParseFromSnippetAsync(q,S){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((z,C)=>{const v=new V.c;v.addEventListener("readystatechange",(()=>{if(4==v.readyState)if(200==v.status){const C=JSON.parse(JSON.parse(v.responseText).jsonPayload),U=JSON.parse(C.shaderMaterial),g=this.Parse(U,S||y.b.LastCreatedScene,b);g.snippetId=q,z(g)}else C("Unable to load the snippet "+q)})),v.open("GET",this.SnippetUrl+"/"+q.replace(/#/g,"/")),v.send()}))}}H.SnippetUrl="https://snippet.babylonjs.com",H.CreateFromSnippetAsync=H.ParseFromSnippetAsync,(0,r.f)("BABYLON.ShaderMaterial",H)}}]);