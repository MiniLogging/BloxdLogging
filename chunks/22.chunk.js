"use strict";(self.bbj0x35f849=self.bbj0x35f849||[]).push([[22],{11361:(N,q,C)=>{C.r(q),C.d(q,{ShaderMaterial:()=>v});var d=C(11155),U=C(11364),W=C(11122),a=C(11199),F=C(11101),w=C(11076),A=C(11437),n=C(10992),t=C(11441),V=C(10995),Z=C(11494),J=C(11487);const Q={effect:null,subMesh:null};class v extends t.d{constructor(N,q,C){let d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(N,q,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new W.Matrix,this._cachedWorldViewProjectionMatrix=new W.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=C,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...d}}get shaderPath(){return this._shaderPath}set shaderPath(N){this._shaderPath=N}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(N){-1===this._options.uniforms.indexOf(N)&&this._options.uniforms.push(N)}setTexture(N,q){return-1===this._options.samplers.indexOf(N)&&this._options.samplers.push(N),this._textures[N]=q,this}removeTexture(N){delete this._textures[N]}setTextureArray(N,q){return-1===this._options.samplers.indexOf(N)&&this._options.samplers.push(N),this._checkUniform(N),this._textureArrays[N]=q,this}setExternalTexture(N,q){return-1===this._options.externalTextures.indexOf(N)&&this._options.externalTextures.push(N),this._externalTextures[N]=q,this}setFloat(N,q){return this._checkUniform(N),this._floats[N]=q,this}setInt(N,q){return this._checkUniform(N),this._ints[N]=q,this}setUInt(N,q){return this._checkUniform(N),this._uints[N]=q,this}setFloats(N,q){return this._checkUniform(N),this._floatsArrays[N]=q,this}setColor3(N,q){return this._checkUniform(N),this._colors3[N]=q,this}setColor3Array(N,q){return this._checkUniform(N),this._colors3Arrays[N]=q.reduce(((N,q)=>(N.push(q.r,q.g,q.b),N)),[]),this}setColor4(N,q){return this._checkUniform(N),this._colors4[N]=q,this}setColor4Array(N,q){return this._checkUniform(N),this._colors4Arrays[N]=q.reduce(((N,q)=>(N.push(q.r,q.g,q.b,q.a),N)),[]),this}setVector2(N,q){return this._checkUniform(N),this._vectors2[N]=q,this}setVector3(N,q){return this._checkUniform(N),this._vectors3[N]=q,this}setVector4(N,q){return this._checkUniform(N),this._vectors4[N]=q,this}setQuaternion(N,q){return this._checkUniform(N),this._quaternions[N]=q,this}setQuaternionArray(N,q){return this._checkUniform(N),this._quaternionsArrays[N]=q.reduce(((N,q)=>(q.toArray(N,N.length),N)),[]),this}setMatrix(N,q){return this._checkUniform(N),this._matrices[N]=q,this}setMatrices(N,q){this._checkUniform(N);const C=new Float32Array(16*q.length);for(let d=0;d<q.length;d++){q[d].copyToArray(C,16*d)}return this._matrixArrays[N]=C,this}setMatrix3x3(N,q){return this._checkUniform(N),this._matrices3x3[N]=q,this}setMatrix2x2(N,q){return this._checkUniform(N),this._matrices2x2[N]=q,this}setArray2(N,q){return this._checkUniform(N),this._vectors2Arrays[N]=q,this}setArray3(N,q){return this._checkUniform(N),this._vectors3Arrays[N]=q,this}setArray4(N,q){return this._checkUniform(N),this._vectors4Arrays[N]=q,this}setUniformBuffer(N,q){return-1===this._options.uniformBuffers.indexOf(N)&&this._options.uniformBuffers.push(N),this._uniformBuffers[N]=q,this}setTextureSampler(N,q){return-1===this._options.samplerObjects.indexOf(N)&&this._options.samplerObjects.push(N),this._textureSamplers[N]=q,this}setStorageBuffer(N,q){return-1===this._options.storageBuffers.indexOf(N)&&this._options.storageBuffers.push(N),this._storageBuffers[N]=q,this}setDefine(N,q){const C=N.trimEnd()+" ",d=this.options.defines.findIndex((q=>q===N||q.startsWith(C)));return d>=0&&this.options.defines.splice(d,1),("boolean"!==typeof q||q)&&this.options.defines.push(C+q),this}isReadyForSubMesh(N,q,C){return this.isReady(N,C,q)}isReady(N,q,C){var d;const W=C&&this._storeEffectOnSubMeshes;if(this.isFrozen){const N=W?C._drawWrapper:this._drawWrapper;if(N.effect&&N._wasPreviouslyReady&&N._wasPreviouslyUsingInstances===q)return!0}const F=this.lN(),w=F.getEngine(),n=[],t=[];let V=null,v=this._shaderPath,r=this._options.uniforms,O=this._options.uniformBuffers,K=this._options.samplers;w.getCaps().multiview&&F.activeCamera&&F.activeCamera.outputRenderTarget&&F.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,n.push("#define MULTIVIEW"),-1!==r.indexOf("viewProjection")&&-1===r.indexOf("viewProjectionR")&&r.push("viewProjectionR"));for(let U=0;U<this._options.defines.length;U++){const N=0===this._options.defines[U].indexOf("#define")?this._options.defines[U]:`#define ${this._options.defines[U]}`;n.push(N)}for(let U=0;U<this._options.attributes.length;U++)t.push(this._options.attributes[U]);if(N&&N.isVerticesDataPresent(a.g.ColorKind)&&(-1===t.indexOf(a.g.ColorKind)&&t.push(a.g.ColorKind),n.push("#define VERTEXCOLOR")),q&&(n.push("#define INSTANCES"),(0,J.fb)(t,this._materialHelperNeedsPreviousMatrices),null!==N&&void 0!==N&&N.hasThinInstances&&(n.push("#define THIN_INSTANCES"),N&&N.isVerticesDataPresent(a.g.ColorInstanceKind)&&(t.push(a.g.ColorInstanceKind),n.push("#define INSTANCESCOLOR")))),N&&N.useBones&&N.computeBonesUsingShaders&&N.skeleton){t.push(a.g.MatricesIndicesKind),t.push(a.g.MatricesWeightsKind),N.numBoneInfluencers>4&&(t.push(a.g.MatricesIndicesExtraKind),t.push(a.g.MatricesWeightsExtraKind));const q=N.skeleton;n.push("#define NUM_BONE_INFLUENCERS "+N.numBoneInfluencers),V=new A.b,V.addCPUSkinningFallback(0,N),q.isUsingTextureForMatrices?(n.push("#define BONETEXTURE"),-1===r.indexOf("boneTextureWidth")&&r.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(n.push("#define BonesPerMesh "+(q.bones.length+1)),-1===r.indexOf("mBones")&&r.push("mBones"))}else n.push("#define NUM_BONE_INFLUENCERS 0");let i=0;const I=N?N.morphTargetManager:null;if(I){const q=-1!==n.indexOf("#define UV1"),C=-1!==n.indexOf("#define UV2"),d=-1!==n.indexOf("#define TANGENT"),U=-1!==n.indexOf("#define NORMAL"),W=-1!==n.indexOf("#define VERTEXCOLOR");i=(0,J.H)(I,n,t,N,!0,U,d,q,C,W),I.isUsingTextureForTargets&&(-1===r.indexOf("morphTargetTextureIndices")&&r.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),i>0&&(r=r.slice(),r.push("morphTargetInfluences"),r.push("morphTargetCount"),r.push("morphTargetTextureInfo"),r.push("morphTargetTextureIndices"))}else n.push("#define NUM_MORPH_INFLUENCERS 0");if(N){const q=N.bakedVertexAnimationManager;q&&q.isEnabled&&(n.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===r.indexOf("bakedVertexAnimationSettings")&&r.push("bakedVertexAnimationSettings"),-1===r.indexOf("bakedVertexAnimationTextureSizeInverted")&&r.push("bakedVertexAnimationTextureSizeInverted"),-1===r.indexOf("bakedVertexAnimationTime")&&r.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,J.x)(t,N,n)}for(const U in this._textures)if(!this._textures[U].isReady())return!1;N&&this.needAlphaTestingForMesh(N)&&n.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,Z.c)(r),(0,Z.i)(this,F,n)),F.fogEnabled&&null!==N&&void 0!==N&&N.applyFog&&F.fogMode!==U.c.FOGMODE_NONE&&(n.push("#define FOG"),-1===r.indexOf("view")&&r.push("view"),-1===r.indexOf("vFogInfos")&&r.push("vFogInfos"),-1===r.indexOf("vFogColor")&&r.push("vFogColor")),this._useLogarithmicDepth&&(n.push("#define LOGARITHMICDEPTH"),-1===r.indexOf("logarithmicDepthConstant")&&r.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(r=r.slice(),O=O.slice(),K=K.slice(),v=this.customShaderNameResolve(this.name,r,O,K,n,t));const j=W?C._getDrawWrapper(void 0,!0):this._drawWrapper,l=(null===j||void 0===j?void 0:j.effect)??null,T=(null===j||void 0===j?void 0:j.defines)??null,z=n.join("\n");let p=l;return T!==z&&(p=w.createEffect(v,{attributes:t,uniformsNames:r,uniformBuffersNames:O,samplers:K,defines:z,fallbacks:V,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:i},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},w),W?C.setEffect(p,z,this._materialContext):j&&j.setEffect(p,z),this._onEffectCreatedObservable&&(Q.effect=p,Q.subMesh=C??(null===N||void 0===N?void 0:N.jd[0])??null,this._onEffectCreatedObservable.notifyObservers(Q))),j._wasPreviouslyUsingInstances=!!q,!(null===(d=p)||void 0===d||!d.isReady())&&(l!==p&&F.resetCachedMaterial(),j._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(N,q){const C=q??this.getEffect();if(!C)return;const d=this._options.uniforms;-1!==d.indexOf("world")&&C.setMatrix("world",N);const U=this.lN();-1!==d.indexOf("worldView")&&(N.multiplyToRef(U.getViewMatrix(),this._cachedWorldViewMatrix),C.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==d.indexOf("worldViewProjection")&&(N.multiplyToRef(U.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),C.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==d.indexOf("view")&&C.setMatrix("view",U.getViewMatrix())}bindForSubMesh(N,q,C){var d;this.bind(N,q,null===(d=C._drawWrapperOverride)||void 0===d?void 0:d.effect,C)}bind(N,q,C,d){const U=d&&this._storeEffectOnSubMeshes,W=C??(U?d.effect:this.getEffect());if(!W)return;const a=this.lN();this._activeEffect=W,this.bindOnlyWorldMatrix(N,C);const F=this._options.uniformBuffers;let w=!1;if(W&&F&&F.length>0&&a.getEngine().supportsUniformBuffers)for(let t=0;t<F.length;++t){switch(F[t]){case"Mesh":q&&(q.getMeshUniformBuffer().bindToEffect(W,"Mesh"),q.transferToEffect(N));break;case"Scene":(0,J.t)(W,a.getSceneUniformBuffer()),a.finalizeSceneUbo(),w=!0}}const A=q&&U?this._mustRebind(a,W,d,q.visibility):a.getCachedMaterial()!==this;if(W&&A){let N;for(N in w||-1===this._options.uniforms.indexOf("view")||W.setMatrix("view",a.getViewMatrix()),w||-1===this._options.uniforms.indexOf("projection")||W.setMatrix("projection",a.getProjectionMatrix()),w||-1===this._options.uniforms.indexOf("viewProjection")||(W.setMatrix("viewProjection",a.getTransformMatrix()),this._multiview&&W.setMatrix("viewProjectionR",a._transformMatrixR)),a.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&W.setVector3("cameraPosition",a.activeCamera.globalPosition),(0,J.c)(q,W),(0,Z.d)(W,this,a),this._useLogarithmicDepth&&(0,J.n)(U?d.materialDefines:W.defines,W,a),q&&(0,J.g)(a,q,W),this._textures)W.setTexture(N,this._textures[N]);for(N in this._textureArrays)W.setTextureArray(N,this._textureArrays[N]);for(N in this._ints)W.setInt(N,this._ints[N]);for(N in this._uints)W.setUInt(N,this._uints[N]);for(N in this._floats)W.setFloat(N,this._floats[N]);for(N in this._floatsArrays)W.setArray(N,this._floatsArrays[N]);for(N in this._colors3)W.setColor3(N,this._colors3[N]);for(N in this._colors3Arrays)W.setArray3(N,this._colors3Arrays[N]);for(N in this._colors4){const q=this._colors4[N];W.setFloat4(N,q.r,q.g,q.b,q.a)}for(N in this._colors4Arrays)W.setArray4(N,this._colors4Arrays[N]);for(N in this._vectors2)W.setVector2(N,this._vectors2[N]);for(N in this._vectors3)W.setVector3(N,this._vectors3[N]);for(N in this._vectors4)W.setVector4(N,this._vectors4[N]);for(N in this._quaternions)W.setQuaternion(N,this._quaternions[N]);for(N in this._matrices)W.setMatrix(N,this._matrices[N]);for(N in this._matrixArrays)W.setMatrices(N,this._matrixArrays[N]);for(N in this._matrices3x3)W.setMatrix3x3(N,this._matrices3x3[N]);for(N in this._matrices2x2)W.setMatrix2x2(N,this._matrices2x2[N]);for(N in this._vectors2Arrays)W.setArray2(N,this._vectors2Arrays[N]);for(N in this._vectors3Arrays)W.setArray3(N,this._vectors3Arrays[N]);for(N in this._vectors4Arrays)W.setArray4(N,this._vectors4Arrays[N]);for(N in this._quaternionsArrays)W.setArray4(N,this._quaternionsArrays[N]);for(N in this._uniformBuffers){const q=this._uniformBuffers[N].getBuffer();q&&W.bindUniformBuffer(q,N)}const C=a.getEngine(),F=C.setExternalTexture;if(F)for(N in this._externalTextures)F.call(C,N,this._externalTextures[N]);const A=C.setTextureSampler;if(A)for(N in this._textureSamplers)A.call(C,N,this._textureSamplers[N]);const n=C.setStorageBuffer;if(n)for(N in this._storageBuffers)n.call(C,N,this._storageBuffers[N])}if(W&&q&&(A||!this.isFrozen)){(0,J.r)(q,W),q.morphTargetManager&&q.morphTargetManager.isUsingTextureForTargets&&q.morphTargetManager._bind(W);const N=q.bakedVertexAnimationManager;if(N&&N.isEnabled){var n;const N=U?d._drawWrapper:this._drawWrapper;null===(n=q.bakedVertexAnimationManager)||void 0===n||n.bind(W,!!N._wasPreviouslyUsingInstances)}}this._afterBind(q,W,d)}getActiveTextures(){const N=super.getActiveTextures();for(const q in this._textures)N.push(this._textures[q]);for(const q in this._textureArrays){const C=this._textureArrays[q];for(let q=0;q<C.length;q++)N.push(C[q])}return N}hasTexture(N){if(super.hasTexture(N))return!0;for(const q in this._textures)if(this._textures[q]===N)return!0;for(const q in this._textureArrays){const C=this._textureArrays[q];for(let q=0;q<C.length;q++)if(C[q]===N)return!0}return!1}clone(N){const q=d.d.Clone((()=>new v(N,this.lN(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);q.name=N,q.id=N,"object"===typeof q._shaderPath&&(q._shaderPath={...q._shaderPath}),this._options={...this._options};const C=Object.keys(this._options);for(const d of C){const N=this._options[d];Array.isArray(N)&&(this._options[d]=N.slice(0))}this.stencil.copyTo(q.stencil);for(const d in this._textures)q.setTexture(d,this._textures[d]);for(const d in this._textureArrays)q.setTextureArray(d,this._textureArrays[d]);for(const d in this._externalTextures)q.setExternalTexture(d,this._externalTextures[d]);for(const d in this._ints)q.setInt(d,this._ints[d]);for(const d in this._uints)q.setUInt(d,this._uints[d]);for(const d in this._floats)q.setFloat(d,this._floats[d]);for(const d in this._floatsArrays)q.setFloats(d,this._floatsArrays[d]);for(const d in this._colors3)q.setColor3(d,this._colors3[d]);for(const d in this._colors3Arrays)q._colors3Arrays[d]=this._colors3Arrays[d];for(const d in this._colors4)q.setColor4(d,this._colors4[d]);for(const d in this._colors4Arrays)q._colors4Arrays[d]=this._colors4Arrays[d];for(const d in this._vectors2)q.setVector2(d,this._vectors2[d]);for(const d in this._vectors3)q.setVector3(d,this._vectors3[d]);for(const d in this._vectors4)q.setVector4(d,this._vectors4[d]);for(const d in this._quaternions)q.setQuaternion(d,this._quaternions[d]);for(const d in this._quaternionsArrays)q._quaternionsArrays[d]=this._quaternionsArrays[d];for(const d in this._matrices)q.setMatrix(d,this._matrices[d]);for(const d in this._matrixArrays)q._matrixArrays[d]=this._matrixArrays[d].slice();for(const d in this._matrices3x3)q.setMatrix3x3(d,this._matrices3x3[d]);for(const d in this._matrices2x2)q.setMatrix2x2(d,this._matrices2x2[d]);for(const d in this._vectors2Arrays)q.setArray2(d,this._vectors2Arrays[d]);for(const d in this._vectors3Arrays)q.setArray3(d,this._vectors3Arrays[d]);for(const d in this._vectors4Arrays)q.setArray4(d,this._vectors4Arrays[d]);for(const d in this._uniformBuffers)q.setUniformBuffer(d,this._uniformBuffers[d]);for(const d in this._textureSamplers)q.setTextureSampler(d,this._textureSamplers[d]);for(const d in this._storageBuffers)q.setStorageBuffer(d,this._storageBuffers[d]);return q}dispose(N,q,C){if(q){let N;for(N in this._textures)this._textures[N].dispose();for(N in this._textureArrays){const q=this._textureArrays[N];for(let N=0;N<q.length;N++)q[N].dispose()}}this._textures={},super.dispose(N,q,C)}serialize(){const N=d.d.Serialize(this);let q;for(q in N.customType="BABYLON.ShaderMaterial",N.uniqueId=this.uniqueId,N.options=this._options,N.shaderPath=this._shaderPath,N.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,N.stencil=this.stencil.serialize(),N.textures={},this._textures)N.textures[q]=this._textures[q].serialize();for(q in N.textureArrays={},this._textureArrays){N.textureArrays[q]=[];const C=this._textureArrays[q];for(let d=0;d<C.length;d++)N.textureArrays[q].push(C[d].serialize())}for(q in N.ints={},this._ints)N.ints[q]=this._ints[q];for(q in N.uints={},this._uints)N.uints[q]=this._uints[q];for(q in N.floats={},this._floats)N.floats[q]=this._floats[q];for(q in N.floatsArrays={},this._floatsArrays)N.floatsArrays[q]=this._floatsArrays[q];for(q in N.colors3={},this._colors3){const C=this._colors3[q];N.colors3[q]=[C.r,C.g,C.b]}for(q in N.colors3Arrays={},this._colors3Arrays)N.colors3Arrays[q]=this._colors3Arrays[q];for(q in N.colors4={},this._colors4){const C=this._colors4[q];N.colors4[q]=[C.r,C.g,C.b,C.a]}for(q in N.colors4Arrays={},this._colors4Arrays)N.colors4Arrays[q]=this._colors4Arrays[q];for(q in N.vectors2={},this._vectors2){const C=this._vectors2[q];N.vectors2[q]=[C.x,C.y]}for(q in N.vectors3={},this._vectors3){const C=this._vectors3[q];N.vectors3[q]=[C.x,C.y,C.z]}for(q in N.vectors4={},this._vectors4){const C=this._vectors4[q];N.vectors4[q]=[C.x,C.y,C.z,C.w]}for(q in N.quaternions={},this._quaternions)N.quaternions[q]=this._quaternions[q].zd();for(q in N.matrices={},this._matrices)N.matrices[q]=this._matrices[q].zd();for(q in N.matrixArray={},this._matrixArrays)N.matrixArray[q]=this._matrixArrays[q];for(q in N.matrices3x3={},this._matrices3x3)N.matrices3x3[q]=this._matrices3x3[q];for(q in N.matrices2x2={},this._matrices2x2)N.matrices2x2[q]=this._matrices2x2[q];for(q in N.vectors2Arrays={},this._vectors2Arrays)N.vectors2Arrays[q]=this._vectors2Arrays[q];for(q in N.vectors3Arrays={},this._vectors3Arrays)N.vectors3Arrays[q]=this._vectors3Arrays[q];for(q in N.vectors4Arrays={},this._vectors4Arrays)N.vectors4Arrays[q]=this._vectors4Arrays[q];for(q in N.quaternionsArrays={},this._quaternionsArrays)N.quaternionsArrays[q]=this._quaternionsArrays[q];return N}static Parse(N,q,C){const U=d.d.Parse((()=>new v(N.name,q,N.shaderPath,N.options,N.storeEffectOnSubMeshes)),N,q,C);let a;for(a in N.stencil&&U.stencil.parse(N.stencil,q,C),N.textures)U.setTexture(a,F.c.Parse(N.textures[a],q,C));for(a in N.textureArrays){const d=N.textureArrays[a],W=[];for(let N=0;N<d.length;N++)W.push(F.c.Parse(d[N],q,C));U.setTextureArray(a,W)}for(a in N.ints)U.setInt(a,N.ints[a]);for(a in N.uints)U.setUInt(a,N.uints[a]);for(a in N.floats)U.setFloat(a,N.floats[a]);for(a in N.floatsArrays)U.setFloats(a,N.floatsArrays[a]);for(a in N.colors3){const q=N.colors3[a];U.setColor3(a,{r:q[0],g:q[1],b:q[2]})}for(a in N.colors3Arrays){const q=N.colors3Arrays[a].reduce(((N,q,C)=>(C%3===0?N.push([q]):N[N.length-1].push(q),N)),[]).map((N=>({r:N[0],g:N[1],b:N[2]})));U.setColor3Array(a,q)}for(a in N.colors4){const q=N.colors4[a];U.setColor4(a,{r:q[0],g:q[1],b:q[2],a:q[3]})}for(a in N.colors4Arrays){const q=N.colors4Arrays[a].reduce(((N,q,C)=>(C%4===0?N.push([q]):N[N.length-1].push(q),N)),[]).map((N=>({r:N[0],g:N[1],b:N[2],a:N[3]})));U.setColor4Array(a,q)}for(a in N.vectors2){const q=N.vectors2[a];U.setVector2(a,{x:q[0],y:q[1]})}for(a in N.vectors3){const q=N.vectors3[a];U.setVector3(a,{x:q[0],y:q[1],z:q[2]})}for(a in N.vectors4){const q=N.vectors4[a];U.setVector4(a,{x:q[0],y:q[1],z:q[2],w:q[3]})}for(a in N.quaternions)U.setQuaternion(a,W.Quaternion.Kq(N.quaternions[a]));for(a in N.matrices)U.setMatrix(a,W.Matrix.Kq(N.matrices[a]));for(a in N.matrixArray)U._matrixArrays[a]=new Float32Array(N.matrixArray[a]);for(a in N.matrices3x3)U.setMatrix3x3(a,N.matrices3x3[a]);for(a in N.matrices2x2)U.setMatrix2x2(a,N.matrices2x2[a]);for(a in N.vectors2Arrays)U.setArray2(a,N.vectors2Arrays[a]);for(a in N.vectors3Arrays)U.setArray3(a,N.vectors3Arrays[a]);for(a in N.vectors4Arrays)U.setArray4(a,N.vectors4Arrays[a]);for(a in N.quaternionsArrays)U.setArray4(a,N.quaternionsArrays[a]);return U}static async ParseFromFileAsync(N,q,C){let d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((U,W)=>{const a=new n.e;a.addEventListener("readystatechange",(()=>{if(4==a.readyState)if(200==a.status){const q=JSON.parse(a.responseText),W=this.Parse(q,C||V.e.LastCreatedScene,d);N&&(W.name=N),U(W)}else W("Unable to load the ShaderMaterial")})),a.open("GET",q),a.send()}))}static async ParseFromSnippetAsync(N,q){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((d,U)=>{const W=new n.e;W.addEventListener("readystatechange",(()=>{if(4==W.readyState)if(200==W.status){const U=JSON.parse(JSON.parse(W.responseText).jsonPayload),a=JSON.parse(U.shaderMaterial),F=this.Parse(a,q||V.e.LastCreatedScene,C);F.snippetId=N,d(F)}else U("Unable to load the snippet "+N)})),W.open("GET",this.SnippetUrl+"/"+N.replace(/#/g,"/")),W.send()}))}}v.SnippetUrl="https://snippet.babylonjs.com",v.CreateFromSnippetAsync=v.ParseFromSnippetAsync,(0,w.h)("BABYLON.ShaderMaterial",v)}}]);