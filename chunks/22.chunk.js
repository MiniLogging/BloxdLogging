"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[22],{13095:(U,G,C)=>{C.r(G),C.d(G,{ShaderMaterial:()=>H});var L=C(26),X=C(12928),l=C(13097),t=C(12896),E=C(12957),K=C(12873),P=C(12850),O=C(13170),T=C(12756),D=C(13175),y=C(12763),V=C(13224),p=C(13217);const I={effect:null,subMesh:null};class H extends D.c{constructor(U,G,C){let X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(U,G,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new t.Matrix,this._cachedWorldViewProjectionMatrix=new t.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=C,this._options=(0,L.b)({needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1},X)}get shaderPath(){return this._shaderPath}set shaderPath(U){this._shaderPath=U}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(U){-1===this._options.uniforms.indexOf(U)&&this._options.uniforms.push(U)}setTexture(U,G){return-1===this._options.samplers.indexOf(U)&&this._options.samplers.push(U),this._textures[U]=G,this}removeTexture(U){delete this._textures[U]}setTextureArray(U,G){return-1===this._options.samplers.indexOf(U)&&this._options.samplers.push(U),this._checkUniform(U),this._textureArrays[U]=G,this}setExternalTexture(U,G){return-1===this._options.externalTextures.indexOf(U)&&this._options.externalTextures.push(U),this._externalTextures[U]=G,this}setFloat(U,G){return this._checkUniform(U),this._floats[U]=G,this}setInt(U,G){return this._checkUniform(U),this._ints[U]=G,this}setUInt(U,G){return this._checkUniform(U),this._uints[U]=G,this}setFloats(U,G){return this._checkUniform(U),this._floatsArrays[U]=G,this}setColor3(U,G){return this._checkUniform(U),this._colors3[U]=G,this}setColor3Array(U,G){return this._checkUniform(U),this._colors3Arrays[U]=G.reduce(((U,G)=>(U.push(G.r,G.g,G.b),U)),[]),this}setColor4(U,G){return this._checkUniform(U),this._colors4[U]=G,this}setColor4Array(U,G){return this._checkUniform(U),this._colors4Arrays[U]=G.reduce(((U,G)=>(U.push(G.r,G.g,G.b,G.a),U)),[]),this}setVector2(U,G){return this._checkUniform(U),this._vectors2[U]=G,this}setVector3(U,G){return this._checkUniform(U),this._vectors3[U]=G,this}setVector4(U,G){return this._checkUniform(U),this._vectors4[U]=G,this}setQuaternion(U,G){return this._checkUniform(U),this._quaternions[U]=G,this}setQuaternionArray(U,G){return this._checkUniform(U),this._quaternionsArrays[U]=G.reduce(((U,G)=>(G.toArray(U,U.length),U)),[]),this}setMatrix(U,G){return this._checkUniform(U),this._matrices[U]=G,this}setMatrices(U,G){this._checkUniform(U);const C=new Float32Array(16*G.length);for(let L=0;L<G.length;L++){G[L].copyToArray(C,16*L)}return this._matrixArrays[U]=C,this}setMatrix3x3(U,G){return this._checkUniform(U),this._matrices3x3[U]=G,this}setMatrix2x2(U,G){return this._checkUniform(U),this._matrices2x2[U]=G,this}setArray2(U,G){return this._checkUniform(U),this._vectors2Arrays[U]=G,this}setArray3(U,G){return this._checkUniform(U),this._vectors3Arrays[U]=G,this}setArray4(U,G){return this._checkUniform(U),this._vectors4Arrays[U]=G,this}setUniformBuffer(U,G){return-1===this._options.uniformBuffers.indexOf(U)&&this._options.uniformBuffers.push(U),this._uniformBuffers[U]=G,this}setTextureSampler(U,G){return-1===this._options.samplerObjects.indexOf(U)&&this._options.samplerObjects.push(U),this._textureSamplers[U]=G,this}setStorageBuffer(U,G){return-1===this._options.storageBuffers.indexOf(U)&&this._options.storageBuffers.push(U),this._storageBuffers[U]=G,this}setDefine(U,G){const C=U.trimEnd()+" ",L=this.options.defines.findIndex((G=>G===U||G.startsWith(C)));return L>=0&&this.options.defines.splice(L,1),("boolean"!==typeof G||G)&&this.options.defines.push(C+G),this}isReadyForSubMesh(U,G,C){return this.isReady(U,C,G)}isReady(U,G,C){var L,X,t;const K=C&&this._storeEffectOnSubMeshes;if(this.isFrozen){const U=K?C._drawWrapper:this._drawWrapper;if(U.effect&&U._wasPreviouslyReady&&U._wasPreviouslyUsingInstances===G)return!0}const P=this.wU(),T=P.getEngine(),D=[],y=[];let H=null,x=this._shaderPath,h=this._options.uniforms,N=this._options.uniformBuffers,b=this._options.samplers;T.getCaps().multiview&&P.activeCamera&&P.activeCamera.outputRenderTarget&&P.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,D.push("#define MULTIVIEW"),-1!==h.indexOf("viewProjection")&&-1===h.indexOf("viewProjectionR")&&h.push("viewProjectionR"));for(let l=0;l<this._options.defines.length;l++){const U=0===this._options.defines[l].indexOf("#define")?this._options.defines[l]:"#define ".concat(this._options.defines[l]);D.push(U)}for(let l=0;l<this._options.attributes.length;l++)y.push(this._options.attributes[l]);if(U&&U.isVerticesDataPresent(E.e.ColorKind)&&(-1===y.indexOf(E.e.ColorKind)&&y.push(E.e.ColorKind),D.push("#define VERTEXCOLOR")),G&&(D.push("#define INSTANCES"),(0,p.lb)(y,this._materialHelperNeedsPreviousMatrices),null!==U&&void 0!==U&&U.hasThinInstances&&(D.push("#define THIN_INSTANCES"),U&&U.isVerticesDataPresent(E.e.ColorInstanceKind)&&(y.push(E.e.ColorInstanceKind),D.push("#define INSTANCESCOLOR")))),U&&U.useBones&&U.computeBonesUsingShaders&&U.skeleton){y.push(E.e.MatricesIndicesKind),y.push(E.e.MatricesWeightsKind),U.numBoneInfluencers>4&&(y.push(E.e.MatricesIndicesExtraKind),y.push(E.e.MatricesWeightsExtraKind));const G=U.skeleton;D.push("#define NUM_BONE_INFLUENCERS "+U.numBoneInfluencers),H=new O.d,H.addCPUSkinningFallback(0,U),G.isUsingTextureForMatrices?(D.push("#define BONETEXTURE"),-1===h.indexOf("boneTextureWidth")&&h.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(D.push("#define BonesPerMesh "+(G.bones.length+1)),-1===h.indexOf("mBones")&&h.push("mBones"))}else D.push("#define NUM_BONE_INFLUENCERS 0");let o=0;const w=U?U.morphTargetManager:null;if(w){const G=-1!==D.indexOf("#define UV1"),C=-1!==D.indexOf("#define UV2"),L=-1!==D.indexOf("#define TANGENT"),X=-1!==D.indexOf("#define NORMAL"),l=-1!==D.indexOf("#define VERTEXCOLOR");o=(0,p.N)(w,D,y,U,!0,X,L,G,C,l),w.isUsingTextureForTargets&&(-1===h.indexOf("morphTargetTextureIndices")&&h.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),o>0&&(h=h.slice(),h.push("morphTargetInfluences"),h.push("morphTargetCount"),h.push("morphTargetTextureInfo"),h.push("morphTargetTextureIndices"))}else D.push("#define NUM_MORPH_INFLUENCERS 0");if(U){const G=U.bakedVertexAnimationManager;G&&G.isEnabled&&(D.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===h.indexOf("bakedVertexAnimationSettings")&&h.push("bakedVertexAnimationSettings"),-1===h.indexOf("bakedVertexAnimationTextureSizeInverted")&&h.push("bakedVertexAnimationTextureSizeInverted"),-1===h.indexOf("bakedVertexAnimationTime")&&h.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,p.B)(y,U,D)}for(const l in this._textures)if(!this._textures[l].isReady())return!1;U&&this.needAlphaTestingForMesh(U)&&D.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,V.b)(h),(0,V.g)(this,P,D)),P.fogEnabled&&null!==U&&void 0!==U&&U.applyFog&&P.fogMode!==l.e.FOGMODE_NONE&&(D.push("#define FOG"),-1===h.indexOf("view")&&h.push("view"),-1===h.indexOf("vFogInfos")&&h.push("vFogInfos"),-1===h.indexOf("vFogColor")&&h.push("vFogColor")),this._useLogarithmicDepth&&(D.push("#define LOGARITHMICDEPTH"),-1===h.indexOf("logarithmicDepthConstant")&&h.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(h=h.slice(),N=N.slice(),b=b.slice(),x=this.customShaderNameResolve(this.name,h,N,b,D,y));const S=K?C._getDrawWrapper(void 0,!0):this._drawWrapper,v=null!==(L=null===S||void 0===S?void 0:S.effect)&&void 0!==L?L:null,u=null!==(X=null===S||void 0===S?void 0:S.defines)&&void 0!==X?X:null,d=D.join("\n");let g=v;var Z;u!==d&&(g=T.createEffect(x,{attributes:y,uniformsNames:h,uniformBuffersNames:N,samplers:b,defines:d,fallbacks:H,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:o},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},T),K?C.setEffect(g,d,this._materialContext):S&&S.setEffect(g,d),this._onEffectCreatedObservable&&(I.effect=g,I.subMesh=null!==(Z=null!==C&&void 0!==C?C:null===U||void 0===U?void 0:U.zE[0])&&void 0!==Z?Z:null,this._onEffectCreatedObservable.notifyObservers(I)));return S._wasPreviouslyUsingInstances=!!G,!(null===(t=g)||void 0===t||!t.isReady())&&(v!==g&&P.resetCachedMaterial(),S._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(U,G){const C=null!==G&&void 0!==G?G:this.getEffect();if(!C)return;const L=this._options.uniforms;-1!==L.indexOf("world")&&C.setMatrix("world",U);const X=this.wU();-1!==L.indexOf("worldView")&&(U.multiplyToRef(X.getViewMatrix(),this._cachedWorldViewMatrix),C.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==L.indexOf("worldViewProjection")&&(U.multiplyToRef(X.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),C.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==L.indexOf("view")&&C.setMatrix("view",X.getViewMatrix())}bindForSubMesh(U,G,C){var L;this.bind(U,G,null===(L=C._drawWrapperOverride)||void 0===L?void 0:L.effect,C)}bind(U,G,C,L){const X=L&&this._storeEffectOnSubMeshes,l=null!==C&&void 0!==C?C:X?L.effect:this.getEffect();if(!l)return;const t=this.wU();this._activeEffect=l,this.bindOnlyWorldMatrix(U,C);const E=this._options.uniformBuffers;let K=!1;if(l&&E&&E.length>0&&t.getEngine().supportsUniformBuffers)for(let T=0;T<E.length;++T){switch(E[T]){case"Mesh":G&&(G.getMeshUniformBuffer().bindToEffect(l,"Mesh"),G.transferToEffect(U));break;case"Scene":(0,p.r)(l,t.getSceneUniformBuffer()),t.finalizeSceneUbo(),K=!0}}const P=G&&X?this._mustRebind(t,l,L,G.visibility):t.getCachedMaterial()!==this;if(l&&P){let U;for(U in K||-1===this._options.uniforms.indexOf("view")||l.setMatrix("view",t.getViewMatrix()),K||-1===this._options.uniforms.indexOf("projection")||l.setMatrix("projection",t.getProjectionMatrix()),K||-1===this._options.uniforms.indexOf("viewProjection")||(l.setMatrix("viewProjection",t.getTransformMatrix()),this._multiview&&l.setMatrix("viewProjectionR",t._transformMatrixR)),t.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&l.setVector3("cameraPosition",t.activeCamera.globalPosition),(0,p.e)(G,l),(0,V.e)(l,this,t),this._useLogarithmicDepth&&(0,p.m)(X?L.materialDefines:l.defines,l,t),G&&(0,p.h)(t,G,l),this._textures)l.setTexture(U,this._textures[U]);for(U in this._textureArrays)l.setTextureArray(U,this._textureArrays[U]);for(U in this._ints)l.setInt(U,this._ints[U]);for(U in this._uints)l.setUInt(U,this._uints[U]);for(U in this._floats)l.setFloat(U,this._floats[U]);for(U in this._floatsArrays)l.setArray(U,this._floatsArrays[U]);for(U in this._colors3)l.setColor3(U,this._colors3[U]);for(U in this._colors3Arrays)l.setArray3(U,this._colors3Arrays[U]);for(U in this._colors4){const G=this._colors4[U];l.setFloat4(U,G.r,G.g,G.b,G.a)}for(U in this._colors4Arrays)l.setArray4(U,this._colors4Arrays[U]);for(U in this._vectors2)l.setVector2(U,this._vectors2[U]);for(U in this._vectors3)l.setVector3(U,this._vectors3[U]);for(U in this._vectors4)l.setVector4(U,this._vectors4[U]);for(U in this._quaternions)l.setQuaternion(U,this._quaternions[U]);for(U in this._matrices)l.setMatrix(U,this._matrices[U]);for(U in this._matrixArrays)l.setMatrices(U,this._matrixArrays[U]);for(U in this._matrices3x3)l.setMatrix3x3(U,this._matrices3x3[U]);for(U in this._matrices2x2)l.setMatrix2x2(U,this._matrices2x2[U]);for(U in this._vectors2Arrays)l.setArray2(U,this._vectors2Arrays[U]);for(U in this._vectors3Arrays)l.setArray3(U,this._vectors3Arrays[U]);for(U in this._vectors4Arrays)l.setArray4(U,this._vectors4Arrays[U]);for(U in this._quaternionsArrays)l.setArray4(U,this._quaternionsArrays[U]);for(U in this._uniformBuffers){const G=this._uniformBuffers[U].getBuffer();G&&l.bindUniformBuffer(G,U)}const C=t.getEngine(),E=C.setExternalTexture;if(E)for(U in this._externalTextures)E.call(C,U,this._externalTextures[U]);const P=C.setTextureSampler;if(P)for(U in this._textureSamplers)P.call(C,U,this._textureSamplers[U]);const O=C.setStorageBuffer;if(O)for(U in this._storageBuffers)O.call(C,U,this._storageBuffers[U])}if(l&&G&&(P||!this.isFrozen)){(0,p.o)(G,l),G.morphTargetManager&&G.morphTargetManager.isUsingTextureForTargets&&G.morphTargetManager._bind(l);const U=G.bakedVertexAnimationManager;if(U&&U.isEnabled){var O;const U=X?L._drawWrapper:this._drawWrapper;null===(O=G.bakedVertexAnimationManager)||void 0===O||O.bind(l,!!U._wasPreviouslyUsingInstances)}}this._afterBind(G,l,L)}getActiveTextures(){const U=super.getActiveTextures();for(const G in this._textures)U.push(this._textures[G]);for(const G in this._textureArrays){const C=this._textureArrays[G];for(let G=0;G<C.length;G++)U.push(C[G])}return U}hasTexture(U){if(super.hasTexture(U))return!0;for(const G in this._textures)if(this._textures[G]===U)return!0;for(const G in this._textureArrays){const C=this._textureArrays[G];for(let G=0;G<C.length;G++)if(C[G]===U)return!0}return!1}clone(U){const G=X.c.Clone((()=>new H(U,this.wU(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);G.name=U,G.id=U,"object"===typeof G._shaderPath&&(G._shaderPath=(0,L.b)({},G._shaderPath)),this._options=(0,L.b)({},this._options);const C=Object.keys(this._options);for(const L of C){const U=this._options[L];Array.isArray(U)&&(this._options[L]=U.slice(0))}this.kE.copyTo(G.kE);for(const L in this._textures)G.setTexture(L,this._textures[L]);for(const L in this._textureArrays)G.setTextureArray(L,this._textureArrays[L]);for(const L in this._externalTextures)G.setExternalTexture(L,this._externalTextures[L]);for(const L in this._ints)G.setInt(L,this._ints[L]);for(const L in this._uints)G.setUInt(L,this._uints[L]);for(const L in this._floats)G.setFloat(L,this._floats[L]);for(const L in this._floatsArrays)G.setFloats(L,this._floatsArrays[L]);for(const L in this._colors3)G.setColor3(L,this._colors3[L]);for(const L in this._colors3Arrays)G._colors3Arrays[L]=this._colors3Arrays[L];for(const L in this._colors4)G.setColor4(L,this._colors4[L]);for(const L in this._colors4Arrays)G._colors4Arrays[L]=this._colors4Arrays[L];for(const L in this._vectors2)G.setVector2(L,this._vectors2[L]);for(const L in this._vectors3)G.setVector3(L,this._vectors3[L]);for(const L in this._vectors4)G.setVector4(L,this._vectors4[L]);for(const L in this._quaternions)G.setQuaternion(L,this._quaternions[L]);for(const L in this._quaternionsArrays)G._quaternionsArrays[L]=this._quaternionsArrays[L];for(const L in this._matrices)G.setMatrix(L,this._matrices[L]);for(const L in this._matrixArrays)G._matrixArrays[L]=this._matrixArrays[L].slice();for(const L in this._matrices3x3)G.setMatrix3x3(L,this._matrices3x3[L]);for(const L in this._matrices2x2)G.setMatrix2x2(L,this._matrices2x2[L]);for(const L in this._vectors2Arrays)G.setArray2(L,this._vectors2Arrays[L]);for(const L in this._vectors3Arrays)G.setArray3(L,this._vectors3Arrays[L]);for(const L in this._vectors4Arrays)G.setArray4(L,this._vectors4Arrays[L]);for(const L in this._uniformBuffers)G.setUniformBuffer(L,this._uniformBuffers[L]);for(const L in this._textureSamplers)G.setTextureSampler(L,this._textureSamplers[L]);for(const L in this._storageBuffers)G.setStorageBuffer(L,this._storageBuffers[L]);return G}dispose(U,G,C){if(G){let U;for(U in this._textures)this._textures[U].dispose();for(U in this._textureArrays){const G=this._textureArrays[U];for(let U=0;U<G.length;U++)G[U].dispose()}}this._textures={},super.dispose(U,G,C)}serialize(){const U=X.c.Serialize(this);let G;for(G in U.customType="BABYLON.ShaderMaterial",U.uniqueId=this.uniqueId,U.options=this._options,U.shaderPath=this._shaderPath,U.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,U.kE=this.kE.serialize(),U.textures={},this._textures)U.textures[G]=this._textures[G].serialize();for(G in U.textureArrays={},this._textureArrays){U.textureArrays[G]=[];const C=this._textureArrays[G];for(let L=0;L<C.length;L++)U.textureArrays[G].push(C[L].serialize())}for(G in U.ints={},this._ints)U.ints[G]=this._ints[G];for(G in U.uints={},this._uints)U.uints[G]=this._uints[G];for(G in U.floats={},this._floats)U.floats[G]=this._floats[G];for(G in U.floatsArrays={},this._floatsArrays)U.floatsArrays[G]=this._floatsArrays[G];for(G in U.colors3={},this._colors3){const C=this._colors3[G];U.colors3[G]=[C.r,C.g,C.b]}for(G in U.colors3Arrays={},this._colors3Arrays)U.colors3Arrays[G]=this._colors3Arrays[G];for(G in U.colors4={},this._colors4){const C=this._colors4[G];U.colors4[G]=[C.r,C.g,C.b,C.a]}for(G in U.colors4Arrays={},this._colors4Arrays)U.colors4Arrays[G]=this._colors4Arrays[G];for(G in U.vectors2={},this._vectors2){const C=this._vectors2[G];U.vectors2[G]=[C.x,C.y]}for(G in U.vectors3={},this._vectors3){const C=this._vectors3[G];U.vectors3[G]=[C.x,C.y,C.z]}for(G in U.vectors4={},this._vectors4){const C=this._vectors4[G];U.vectors4[G]=[C.x,C.y,C.z,C.w]}for(G in U.quaternions={},this._quaternions)U.quaternions[G]=this._quaternions[G].sE();for(G in U.matrices={},this._matrices)U.matrices[G]=this._matrices[G].sE();for(G in U.matrixArray={},this._matrixArrays)U.matrixArray[G]=this._matrixArrays[G];for(G in U.matrices3x3={},this._matrices3x3)U.matrices3x3[G]=this._matrices3x3[G];for(G in U.matrices2x2={},this._matrices2x2)U.matrices2x2[G]=this._matrices2x2[G];for(G in U.vectors2Arrays={},this._vectors2Arrays)U.vectors2Arrays[G]=this._vectors2Arrays[G];for(G in U.vectors3Arrays={},this._vectors3Arrays)U.vectors3Arrays[G]=this._vectors3Arrays[G];for(G in U.vectors4Arrays={},this._vectors4Arrays)U.vectors4Arrays[G]=this._vectors4Arrays[G];for(G in U.quaternionsArrays={},this._quaternionsArrays)U.quaternionsArrays[G]=this._quaternionsArrays[G];return U}static Parse(U,G,C){const L=X.c.Parse((()=>new H(U.name,G,U.shaderPath,U.options,U.storeEffectOnSubMeshes)),U,G,C);let l;for(l in U.kE&&L.kE.parse(U.kE,G,C),U.textures)L.setTexture(l,K.c.Parse(U.textures[l],G,C));for(l in U.textureArrays){const X=U.textureArrays[l],t=[];for(let U=0;U<X.length;U++)t.push(K.c.Parse(X[U],G,C));L.setTextureArray(l,t)}for(l in U.ints)L.setInt(l,U.ints[l]);for(l in U.uints)L.setUInt(l,U.uints[l]);for(l in U.floats)L.setFloat(l,U.floats[l]);for(l in U.floatsArrays)L.setFloats(l,U.floatsArrays[l]);for(l in U.colors3){const G=U.colors3[l];L.setColor3(l,{r:G[0],g:G[1],b:G[2]})}for(l in U.colors3Arrays){const G=U.colors3Arrays[l].reduce(((U,G,C)=>(C%3===0?U.push([G]):U[U.length-1].push(G),U)),[]).map((U=>({r:U[0],g:U[1],b:U[2]})));L.setColor3Array(l,G)}for(l in U.colors4){const G=U.colors4[l];L.setColor4(l,{r:G[0],g:G[1],b:G[2],a:G[3]})}for(l in U.colors4Arrays){const G=U.colors4Arrays[l].reduce(((U,G,C)=>(C%4===0?U.push([G]):U[U.length-1].push(G),U)),[]).map((U=>({r:U[0],g:U[1],b:U[2],a:U[3]})));L.setColor4Array(l,G)}for(l in U.vectors2){const G=U.vectors2[l];L.setVector2(l,{x:G[0],y:G[1]})}for(l in U.vectors3){const G=U.vectors3[l];L.setVector3(l,{x:G[0],y:G[1],z:G[2]})}for(l in U.vectors4){const G=U.vectors4[l];L.setVector4(l,{x:G[0],y:G[1],z:G[2],w:G[3]})}for(l in U.quaternions)L.setQuaternion(l,t.Quaternion.NG(U.quaternions[l]));for(l in U.matrices)L.setMatrix(l,t.Matrix.NG(U.matrices[l]));for(l in U.matrixArray)L._matrixArrays[l]=new Float32Array(U.matrixArray[l]);for(l in U.matrices3x3)L.setMatrix3x3(l,U.matrices3x3[l]);for(l in U.matrices2x2)L.setMatrix2x2(l,U.matrices2x2[l]);for(l in U.vectors2Arrays)L.setArray2(l,U.vectors2Arrays[l]);for(l in U.vectors3Arrays)L.setArray3(l,U.vectors3Arrays[l]);for(l in U.vectors4Arrays)L.setArray4(l,U.vectors4Arrays[l]);for(l in U.quaternionsArrays)L.setArray4(l,U.quaternionsArrays[l]);return L}static async ParseFromFileAsync(U,G,C){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((X,l)=>{const t=new T.d;t.addEventListener("readystatechange",(()=>{if(4==t.readyState)if(200==t.status){const G=JSON.parse(t.responseText),l=this.Parse(G,C||y.d.LastCreatedScene,L);U&&(l.name=U),X(l)}else l("Unable to load the ShaderMaterial")})),t.open("GET",G),t.send()}))}static async ParseFromSnippetAsync(U,G){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((L,X)=>{const l=new T.d;l.addEventListener("readystatechange",(()=>{if(4==l.readyState)if(200==l.status){const X=JSON.parse(JSON.parse(l.responseText).jsonPayload),t=JSON.parse(X.shaderMaterial),E=this.Parse(t,G||y.d.LastCreatedScene,C);E.snippetId=U,L(E)}else X("Unable to load the snippet "+U)})),l.open("GET",this.SnippetUrl+"/"+U.replace(/#/g,"/")),l.send()}))}}H.SnippetUrl="https://snippet.babylonjs.com",H.CreateFromSnippetAsync=H.ParseFromSnippetAsync,(0,P.e)("BABYLON.ShaderMaterial",H)}}]);