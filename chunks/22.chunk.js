"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[22],{12640:(V,h,mV)=>{mV.r(h),mV.d(h,{ShaderMaterial:()=>s});var t=mV(12448),L=mV(12648),N=mV(12422),A=mV(12481),k=mV(12406),C=mV(12388),K=mV(12704),o=mV(12292),n=mV(12711),q=mV(12300),x=mV(12751),R=mV(12746);const d={effect:null,subMesh:null};class s extends n.d{constructor(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(V,h,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new N.Matrix,this._cachedWorldViewProjectionMatrix=new N.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=mV,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...t}}get shaderPath(){return this._shaderPath}set shaderPath(V){this._shaderPath=V}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(V){-1===this._options.uniforms.indexOf(V)&&this._options.uniforms.push(V)}setTexture(V,h){return-1===this._options.samplers.indexOf(V)&&this._options.samplers.push(V),this._textures[V]=h,this}removeTexture(V){delete this._textures[V]}setTextureArray(V,h){return-1===this._options.samplers.indexOf(V)&&this._options.samplers.push(V),this._checkUniform(V),this._textureArrays[V]=h,this}setExternalTexture(V,h){return-1===this._options.externalTextures.indexOf(V)&&this._options.externalTextures.push(V),this._externalTextures[V]=h,this}setFloat(V,h){return this._checkUniform(V),this._floats[V]=h,this}setInt(V,h){return this._checkUniform(V),this._ints[V]=h,this}setUInt(V,h){return this._checkUniform(V),this._uints[V]=h,this}setFloats(V,h){return this._checkUniform(V),this._floatsArrays[V]=h,this}setColor3(V,h){return this._checkUniform(V),this._colors3[V]=h,this}setColor3Array(V,h){return this._checkUniform(V),this._colors3Arrays[V]=h.reduce(((V,h)=>(V.push(h.r,h.g,h.b),V)),[]),this}setColor4(V,h){return this._checkUniform(V),this._colors4[V]=h,this}setColor4Array(V,h){return this._checkUniform(V),this._colors4Arrays[V]=h.reduce(((V,h)=>(V.push(h.r,h.g,h.b,h.a),V)),[]),this}setVector2(V,h){return this._checkUniform(V),this._vectors2[V]=h,this}setVector3(V,h){return this._checkUniform(V),this._vectors3[V]=h,this}setVector4(V,h){return this._checkUniform(V),this._vectors4[V]=h,this}setQuaternion(V,h){return this._checkUniform(V),this._quaternions[V]=h,this}setQuaternionArray(V,h){return this._checkUniform(V),this._quaternionsArrays[V]=h.reduce(((V,h)=>(h.toArray(V,V.length),V)),[]),this}setMatrix(V,h){return this._checkUniform(V),this._matrices[V]=h,this}setMatrices(V,h){this._checkUniform(V);const mV=new Float32Array(16*h.length);for(let t=0;t<h.length;t++){h[t].copyToArray(mV,16*t)}return this._matrixArrays[V]=mV,this}setMatrix3x3(V,h){return this._checkUniform(V),this._matrices3x3[V]=h,this}setMatrix2x2(V,h){return this._checkUniform(V),this._matrices2x2[V]=h,this}setArray2(V,h){return this._checkUniform(V),this._vectors2Arrays[V]=h,this}setArray3(V,h){return this._checkUniform(V),this._vectors3Arrays[V]=h,this}setArray4(V,h){return this._checkUniform(V),this._vectors4Arrays[V]=h,this}setUniformBuffer(V,h){return-1===this._options.uniformBuffers.indexOf(V)&&this._options.uniformBuffers.push(V),this._uniformBuffers[V]=h,this}setTextureSampler(V,h){return-1===this._options.samplerObjects.indexOf(V)&&this._options.samplerObjects.push(V),this._textureSamplers[V]=h,this}setStorageBuffer(V,h){return-1===this._options.storageBuffers.indexOf(V)&&this._options.storageBuffers.push(V),this._storageBuffers[V]=h,this}setDefine(V,h){const mV=V.trimEnd()+" ",t=this.options.defines.findIndex((h=>h===V||h.startsWith(mV)));return t>=0&&this.options.defines.splice(t,1),("boolean"!==typeof h||h)&&this.options.defines.push(mV+h),this}isReadyForSubMesh(V,h,mV){return this.isReady(V,mV,h)}isReady(V,h,mV){var t;const N=mV&&this._storeEffectOnSubMeshes;if(this.isFrozen){const V=N?mV._drawWrapper:this._drawWrapper;if(V.effect&&V._wasPreviouslyReady&&V._wasPreviouslyUsingInstances===h)return!0}const k=this.DV(),C=k.getEngine(),o=[],n=[];let q=null,s=this._shaderPath,M=this._options.uniforms,c=this._options.uniformBuffers,z=this._options.samplers;C.getCaps().multiview&&k.activeCamera&&k.activeCamera.outputRenderTarget&&k.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,o.push("#define MULTIVIEW"),-1!==M.indexOf("viewProjection")&&-1===M.indexOf("viewProjectionR")&&M.push("viewProjectionR"));for(let L=0;L<this._options.defines.length;L++){const V=0===this._options.defines[L].indexOf("#define")?this._options.defines[L]:`#define ${this._options.defines[L]}`;o.push(V)}for(let L=0;L<this._options.attributes.length;L++)n.push(this._options.attributes[L]);if(V&&V.isVerticesDataPresent(A.i.ColorKind)&&(-1===n.indexOf(A.i.ColorKind)&&n.push(A.i.ColorKind),o.push("#define VERTEXCOLOR")),h&&(o.push("#define INSTANCES"),(0,R.X)(n,this._materialHelperNeedsPreviousMatrices),null!==V&&void 0!==V&&V.hasThinInstances&&(o.push("#define THIN_INSTANCES"),V&&V.isVerticesDataPresent(A.i.ColorInstanceKind)&&(n.push(A.i.ColorInstanceKind),o.push("#define INSTANCESCOLOR")))),V&&V.useBones&&V.computeBonesUsingShaders&&V.skeleton){n.push(A.i.MatricesIndicesKind),n.push(A.i.MatricesWeightsKind),V.numBoneInfluencers>4&&(n.push(A.i.MatricesIndicesExtraKind),n.push(A.i.MatricesWeightsExtraKind));const h=V.skeleton;o.push("#define NUM_BONE_INFLUENCERS "+V.numBoneInfluencers),q=new K.b,q.addCPUSkinningFallback(0,V),h.isUsingTextureForMatrices?(o.push("#define BONETEXTURE"),-1===M.indexOf("boneTextureWidth")&&M.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(o.push("#define BonesPerMesh "+(h.bones.length+1)),-1===M.indexOf("mBones")&&M.push("mBones"))}else o.push("#define NUM_BONE_INFLUENCERS 0");let Q=0;const J=V?V.morphTargetManager:null;if(J){const h=-1!==o.indexOf("#define UV1"),mV=-1!==o.indexOf("#define UV2"),t=-1!==o.indexOf("#define TANGENT"),L=-1!==o.indexOf("#define NORMAL"),N=-1!==o.indexOf("#define VERTEXCOLOR");Q=(0,R.y)(J,o,n,V,!0,L,t,h,mV,N),J.isUsingTextureForTargets&&(-1===M.indexOf("morphTargetTextureIndices")&&M.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),Q>0&&(M=M.slice(),M.push("morphTargetInfluences"),M.push("morphTargetCount"),M.push("morphTargetTextureInfo"),M.push("morphTargetTextureIndices"))}else o.push("#define NUM_MORPH_INFLUENCERS 0");if(V){const h=V.bakedVertexAnimationManager;h&&h.isEnabled&&(o.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===M.indexOf("bakedVertexAnimationSettings")&&M.push("bakedVertexAnimationSettings"),-1===M.indexOf("bakedVertexAnimationTextureSizeInverted")&&M.push("bakedVertexAnimationTextureSizeInverted"),-1===M.indexOf("bakedVertexAnimationTime")&&M.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,R.s)(n,V,o)}for(const L in this._textures)if(!this._textures[L].isReady())return!1;V&&this.needAlphaTestingForMesh(V)&&o.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,x.e)(M),(0,x.k)(this,k,o)),k.fogEnabled&&null!==V&&void 0!==V&&V.applyFog&&k.fogMode!==L.d.FOGMODE_NONE&&(o.push("#define FOG"),-1===M.indexOf("view")&&M.push("view"),-1===M.indexOf("vFogInfos")&&M.push("vFogInfos"),-1===M.indexOf("vFogColor")&&M.push("vFogColor")),this._useLogarithmicDepth&&(o.push("#define LOGARITHMICDEPTH"),-1===M.indexOf("logarithmicDepthConstant")&&M.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(M=M.slice(),c=c.slice(),z=z.slice(),s=this.customShaderNameResolve(this.name,M,c,z,o,n));const v=N?mV._getDrawWrapper(void 0,!0):this._drawWrapper,D=(null===v||void 0===v?void 0:v.effect)??null,H=(null===v||void 0===v?void 0:v.defines)??null,j=o.join("\n");let l=D;return H!==j&&(l=C.createEffect(s,{attributes:n,uniformsNames:M,uniformBuffersNames:c,samplers:z,defines:j,fallbacks:q,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:Q},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},C),N?mV.setEffect(l,j,this._materialContext):v&&v.setEffect(l,j),this._onEffectCreatedObservable&&(d.effect=l,d.subMesh=mV??(null===V||void 0===V?void 0:V.dk[0])??null,this._onEffectCreatedObservable.notifyObservers(d))),v._wasPreviouslyUsingInstances=!!h,!(null===(t=l)||void 0===t||!t.isReady())&&(D!==l&&k.resetCachedMaterial(),v._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(V,h){const mV=h??this.getEffect();if(!mV)return;const t=this._options.uniforms;-1!==t.indexOf("world")&&mV.setMatrix("world",V);const L=this.DV();-1!==t.indexOf("worldView")&&(V.multiplyToRef(L.getViewMatrix(),this._cachedWorldViewMatrix),mV.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==t.indexOf("worldViewProjection")&&(V.multiplyToRef(L.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),mV.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==t.indexOf("view")&&mV.setMatrix("view",L.getViewMatrix())}bindForSubMesh(V,h,mV){var t;this.bind(V,h,null===(t=mV._drawWrapperOverride)||void 0===t?void 0:t.effect,mV)}bind(V,h,mV,t){const L=t&&this._storeEffectOnSubMeshes,N=mV??(L?t.effect:this.getEffect());if(!N)return;const A=this.DV();this._activeEffect=N,this.bindOnlyWorldMatrix(V,mV);const k=this._options.uniformBuffers;let C=!1;if(N&&k&&k.length>0&&A.getEngine().supportsUniformBuffers)for(let n=0;n<k.length;++n){switch(k[n]){case"Mesh":h&&(h.getMeshUniformBuffer().bindToEffect(N,"Mesh"),h.transferToEffect(V));break;case"Scene":(0,R.k)(N,A.getSceneUniformBuffer()),A.finalizeSceneUbo(),C=!0}}const K=h&&L?this._mustRebind(A,N,t,h.visibility):A.getCachedMaterial()!==this;if(N&&K){let V;for(V in C||-1===this._options.uniforms.indexOf("view")||N.setMatrix("view",A.getViewMatrix()),C||-1===this._options.uniforms.indexOf("projection")||N.setMatrix("projection",A.getProjectionMatrix()),C||-1===this._options.uniforms.indexOf("viewProjection")||(N.setMatrix("viewProjection",A.getTransformMatrix()),this._multiview&&N.setMatrix("viewProjectionR",A._transformMatrixR)),A.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&N.setVector3("cameraPosition",A.activeCamera.globalPosition),(0,R.c)(h,N),(0,x.h)(N,this,A),this._useLogarithmicDepth&&(0,R.g)(L?t.materialDefines:N.defines,N,A),h&&(0,R.d)(A,h,N),this._textures)N.setTexture(V,this._textures[V]);for(V in this._textureArrays)N.setTextureArray(V,this._textureArrays[V]);for(V in this._ints)N.setInt(V,this._ints[V]);for(V in this._uints)N.setUInt(V,this._uints[V]);for(V in this._floats)N.setFloat(V,this._floats[V]);for(V in this._floatsArrays)N.setArray(V,this._floatsArrays[V]);for(V in this._colors3)N.setColor3(V,this._colors3[V]);for(V in this._colors3Arrays)N.setArray3(V,this._colors3Arrays[V]);for(V in this._colors4){const h=this._colors4[V];N.setFloat4(V,h.r,h.g,h.b,h.a)}for(V in this._colors4Arrays)N.setArray4(V,this._colors4Arrays[V]);for(V in this._vectors2)N.setVector2(V,this._vectors2[V]);for(V in this._vectors3)N.setVector3(V,this._vectors3[V]);for(V in this._vectors4)N.setVector4(V,this._vectors4[V]);for(V in this._quaternions)N.setQuaternion(V,this._quaternions[V]);for(V in this._matrices)N.setMatrix(V,this._matrices[V]);for(V in this._matrixArrays)N.setMatrices(V,this._matrixArrays[V]);for(V in this._matrices3x3)N.setMatrix3x3(V,this._matrices3x3[V]);for(V in this._matrices2x2)N.setMatrix2x2(V,this._matrices2x2[V]);for(V in this._vectors2Arrays)N.setArray2(V,this._vectors2Arrays[V]);for(V in this._vectors3Arrays)N.setArray3(V,this._vectors3Arrays[V]);for(V in this._vectors4Arrays)N.setArray4(V,this._vectors4Arrays[V]);for(V in this._quaternionsArrays)N.setArray4(V,this._quaternionsArrays[V]);for(V in this._uniformBuffers){const h=this._uniformBuffers[V].getBuffer();h&&N.bindUniformBuffer(h,V)}const mV=A.getEngine(),k=mV.setExternalTexture;if(k)for(V in this._externalTextures)k.call(mV,V,this._externalTextures[V]);const K=mV.setTextureSampler;if(K)for(V in this._textureSamplers)K.call(mV,V,this._textureSamplers[V]);const o=mV.setStorageBuffer;if(o)for(V in this._storageBuffers)o.call(mV,V,this._storageBuffers[V])}if(N&&h&&(K||!this.isFrozen)){(0,R.i)(h,N),h.morphTargetManager&&h.morphTargetManager.isUsingTextureForTargets&&h.morphTargetManager._bind(N);const V=h.bakedVertexAnimationManager;if(V&&V.isEnabled){var o;const V=L?t._drawWrapper:this._drawWrapper;null===(o=h.bakedVertexAnimationManager)||void 0===o||o.bind(N,!!V._wasPreviouslyUsingInstances)}}this._afterBind(h,N,t)}getActiveTextures(){const V=super.getActiveTextures();for(const h in this._textures)V.push(this._textures[h]);for(const h in this._textureArrays){const mV=this._textureArrays[h];for(let h=0;h<mV.length;h++)V.push(mV[h])}return V}hasTexture(V){if(super.hasTexture(V))return!0;for(const h in this._textures)if(this._textures[h]===V)return!0;for(const h in this._textureArrays){const mV=this._textureArrays[h];for(let h=0;h<mV.length;h++)if(mV[h]===V)return!0}return!1}clone(V){const h=t.e.Clone((()=>new s(V,this.DV(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);h.name=V,h.id=V,"object"===typeof h._shaderPath&&(h._shaderPath={...h._shaderPath}),this._options={...this._options};const mV=Object.keys(this._options);for(const t of mV){const V=this._options[t];Array.isArray(V)&&(this._options[t]=V.slice(0))}this.Ck.copyTo(h.Ck);for(const t in this._textures)h.setTexture(t,this._textures[t]);for(const t in this._textureArrays)h.setTextureArray(t,this._textureArrays[t]);for(const t in this._externalTextures)h.setExternalTexture(t,this._externalTextures[t]);for(const t in this._ints)h.setInt(t,this._ints[t]);for(const t in this._uints)h.setUInt(t,this._uints[t]);for(const t in this._floats)h.setFloat(t,this._floats[t]);for(const t in this._floatsArrays)h.setFloats(t,this._floatsArrays[t]);for(const t in this._colors3)h.setColor3(t,this._colors3[t]);for(const t in this._colors3Arrays)h._colors3Arrays[t]=this._colors3Arrays[t];for(const t in this._colors4)h.setColor4(t,this._colors4[t]);for(const t in this._colors4Arrays)h._colors4Arrays[t]=this._colors4Arrays[t];for(const t in this._vectors2)h.setVector2(t,this._vectors2[t]);for(const t in this._vectors3)h.setVector3(t,this._vectors3[t]);for(const t in this._vectors4)h.setVector4(t,this._vectors4[t]);for(const t in this._quaternions)h.setQuaternion(t,this._quaternions[t]);for(const t in this._quaternionsArrays)h._quaternionsArrays[t]=this._quaternionsArrays[t];for(const t in this._matrices)h.setMatrix(t,this._matrices[t]);for(const t in this._matrixArrays)h._matrixArrays[t]=this._matrixArrays[t].slice();for(const t in this._matrices3x3)h.setMatrix3x3(t,this._matrices3x3[t]);for(const t in this._matrices2x2)h.setMatrix2x2(t,this._matrices2x2[t]);for(const t in this._vectors2Arrays)h.setArray2(t,this._vectors2Arrays[t]);for(const t in this._vectors3Arrays)h.setArray3(t,this._vectors3Arrays[t]);for(const t in this._vectors4Arrays)h.setArray4(t,this._vectors4Arrays[t]);for(const t in this._uniformBuffers)h.setUniformBuffer(t,this._uniformBuffers[t]);for(const t in this._textureSamplers)h.setTextureSampler(t,this._textureSamplers[t]);for(const t in this._storageBuffers)h.setStorageBuffer(t,this._storageBuffers[t]);return h}dispose(V,h,mV){if(h){let V;for(V in this._textures)this._textures[V].dispose();for(V in this._textureArrays){const h=this._textureArrays[V];for(let V=0;V<h.length;V++)h[V].dispose()}}this._textures={},super.dispose(V,h,mV)}serialize(){const V=t.e.Serialize(this);let h;for(h in V.customType="BABYLON.ShaderMaterial",V.uniqueId=this.uniqueId,V.options=this._options,V.shaderPath=this._shaderPath,V.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,V.Ck=this.Ck.serialize(),V.textures={},this._textures)V.textures[h]=this._textures[h].serialize();for(h in V.textureArrays={},this._textureArrays){V.textureArrays[h]=[];const mV=this._textureArrays[h];for(let t=0;t<mV.length;t++)V.textureArrays[h].push(mV[t].serialize())}for(h in V.ints={},this._ints)V.ints[h]=this._ints[h];for(h in V.uints={},this._uints)V.uints[h]=this._uints[h];for(h in V.floats={},this._floats)V.floats[h]=this._floats[h];for(h in V.floatsArrays={},this._floatsArrays)V.floatsArrays[h]=this._floatsArrays[h];for(h in V.colors3={},this._colors3){const mV=this._colors3[h];V.colors3[h]=[mV.r,mV.g,mV.b]}for(h in V.colors3Arrays={},this._colors3Arrays)V.colors3Arrays[h]=this._colors3Arrays[h];for(h in V.colors4={},this._colors4){const mV=this._colors4[h];V.colors4[h]=[mV.r,mV.g,mV.b,mV.a]}for(h in V.colors4Arrays={},this._colors4Arrays)V.colors4Arrays[h]=this._colors4Arrays[h];for(h in V.vectors2={},this._vectors2){const mV=this._vectors2[h];V.vectors2[h]=[mV.x,mV.y]}for(h in V.vectors3={},this._vectors3){const mV=this._vectors3[h];V.vectors3[h]=[mV.x,mV.y,mV.z]}for(h in V.vectors4={},this._vectors4){const mV=this._vectors4[h];V.vectors4[h]=[mV.x,mV.y,mV.z,mV.w]}for(h in V.quaternions={},this._quaternions)V.quaternions[h]=this._quaternions[h].sk();for(h in V.matrices={},this._matrices)V.matrices[h]=this._matrices[h].sk();for(h in V.matrixArray={},this._matrixArrays)V.matrixArray[h]=this._matrixArrays[h];for(h in V.matrices3x3={},this._matrices3x3)V.matrices3x3[h]=this._matrices3x3[h];for(h in V.matrices2x2={},this._matrices2x2)V.matrices2x2[h]=this._matrices2x2[h];for(h in V.vectors2Arrays={},this._vectors2Arrays)V.vectors2Arrays[h]=this._vectors2Arrays[h];for(h in V.vectors3Arrays={},this._vectors3Arrays)V.vectors3Arrays[h]=this._vectors3Arrays[h];for(h in V.vectors4Arrays={},this._vectors4Arrays)V.vectors4Arrays[h]=this._vectors4Arrays[h];for(h in V.quaternionsArrays={},this._quaternionsArrays)V.quaternionsArrays[h]=this._quaternionsArrays[h];return V}static Parse(V,h,mV){const L=t.e.Parse((()=>new s(V.name,h,V.shaderPath,V.options,V.storeEffectOnSubMeshes)),V,h,mV);let A;for(A in V.Ck&&L.Ck.parse(V.Ck,h,mV),V.textures)L.setTexture(A,k.d.Parse(V.textures[A],h,mV));for(A in V.textureArrays){const t=V.textureArrays[A],N=[];for(let V=0;V<t.length;V++)N.push(k.d.Parse(t[V],h,mV));L.setTextureArray(A,N)}for(A in V.ints)L.setInt(A,V.ints[A]);for(A in V.uints)L.setUInt(A,V.uints[A]);for(A in V.floats)L.setFloat(A,V.floats[A]);for(A in V.floatsArrays)L.setFloats(A,V.floatsArrays[A]);for(A in V.colors3){const h=V.colors3[A];L.setColor3(A,{r:h[0],g:h[1],b:h[2]})}for(A in V.colors3Arrays){const h=V.colors3Arrays[A].reduce(((V,h,mV)=>(mV%3===0?V.push([h]):V[V.length-1].push(h),V)),[]).map((V=>({r:V[0],g:V[1],b:V[2]})));L.setColor3Array(A,h)}for(A in V.colors4){const h=V.colors4[A];L.setColor4(A,{r:h[0],g:h[1],b:h[2],a:h[3]})}for(A in V.colors4Arrays){const h=V.colors4Arrays[A].reduce(((V,h,mV)=>(mV%4===0?V.push([h]):V[V.length-1].push(h),V)),[]).map((V=>({r:V[0],g:V[1],b:V[2],a:V[3]})));L.setColor4Array(A,h)}for(A in V.vectors2){const h=V.vectors2[A];L.setVector2(A,{x:h[0],y:h[1]})}for(A in V.vectors3){const h=V.vectors3[A];L.setVector3(A,{x:h[0],y:h[1],z:h[2]})}for(A in V.vectors4){const h=V.vectors4[A];L.setVector4(A,{x:h[0],y:h[1],z:h[2],w:h[3]})}for(A in V.quaternions)L.setQuaternion(A,N.Quaternion.Dh(V.quaternions[A]));for(A in V.matrices)L.setMatrix(A,N.Matrix.Dh(V.matrices[A]));for(A in V.matrixArray)L._matrixArrays[A]=new Float32Array(V.matrixArray[A]);for(A in V.matrices3x3)L.setMatrix3x3(A,V.matrices3x3[A]);for(A in V.matrices2x2)L.setMatrix2x2(A,V.matrices2x2[A]);for(A in V.vectors2Arrays)L.setArray2(A,V.vectors2Arrays[A]);for(A in V.vectors3Arrays)L.setArray3(A,V.vectors3Arrays[A]);for(A in V.vectors4Arrays)L.setArray4(A,V.vectors4Arrays[A]);for(A in V.quaternionsArrays)L.setArray4(A,V.quaternionsArrays[A]);return L}static async ParseFromFileAsync(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((L,N)=>{const A=new o.e;A.addEventListener("readystatechange",(()=>{if(4==A.readyState)if(200==A.status){const h=JSON.parse(A.responseText),N=this.Parse(h,mV||q.b.LastCreatedScene,t);V&&(N.name=V),L(N)}else N("Unable to load the ShaderMaterial")})),A.open("GET",h),A.send()}))}static async ParseFromSnippetAsync(V,h){let mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((t,L)=>{const N=new o.e;N.addEventListener("readystatechange",(()=>{if(4==N.readyState)if(200==N.status){const L=JSON.parse(JSON.parse(N.responseText).jsonPayload),A=JSON.parse(L.shaderMaterial),k=this.Parse(A,h||q.b.LastCreatedScene,mV);k.snippetId=V,t(k)}else L("Unable to load the snippet "+V)})),N.open("GET",this.SnippetUrl+"/"+V.replace(/#/g,"/")),N.send()}))}}s.SnippetUrl="https://snippet.babylonjs.com",s.CreateFromSnippetAsync=s.ParseFromSnippetAsync,(0,C.i)("BABYLON.ShaderMaterial",s)}}]);